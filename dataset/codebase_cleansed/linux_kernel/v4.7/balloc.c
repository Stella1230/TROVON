static int read_block_bitmap(struct super_block *sb,\r\nstruct udf_bitmap *bitmap, unsigned int block,\r\nunsigned long bitmap_nr)\r\n{\r\nstruct buffer_head *bh = NULL;\r\nint retval = 0;\r\nstruct kernel_lb_addr loc;\r\nloc.logicalBlockNum = bitmap->s_extPosition;\r\nloc.partitionReferenceNum = UDF_SB(sb)->s_partition;\r\nbh = udf_tread(sb, udf_get_lb_pblock(sb, &loc, block));\r\nif (!bh)\r\nretval = -EIO;\r\nbitmap->s_block_bitmap[bitmap_nr] = bh;\r\nreturn retval;\r\n}\r\nstatic int __load_block_bitmap(struct super_block *sb,\r\nstruct udf_bitmap *bitmap,\r\nunsigned int block_group)\r\n{\r\nint retval = 0;\r\nint nr_groups = bitmap->s_nr_groups;\r\nif (block_group >= nr_groups) {\r\nudf_debug("block_group (%d) > nr_groups (%d)\n",\r\nblock_group, nr_groups);\r\n}\r\nif (bitmap->s_block_bitmap[block_group])\r\nreturn block_group;\r\nretval = read_block_bitmap(sb, bitmap, block_group, block_group);\r\nif (retval < 0)\r\nreturn retval;\r\nreturn block_group;\r\n}\r\nstatic inline int load_block_bitmap(struct super_block *sb,\r\nstruct udf_bitmap *bitmap,\r\nunsigned int block_group)\r\n{\r\nint slot;\r\nslot = __load_block_bitmap(sb, bitmap, block_group);\r\nif (slot < 0)\r\nreturn slot;\r\nif (!bitmap->s_block_bitmap[slot])\r\nreturn -EIO;\r\nreturn slot;\r\n}\r\nstatic void udf_add_free_space(struct super_block *sb, u16 partition, u32 cnt)\r\n{\r\nstruct udf_sb_info *sbi = UDF_SB(sb);\r\nstruct logicalVolIntegrityDesc *lvid;\r\nif (!sbi->s_lvid_bh)\r\nreturn;\r\nlvid = (struct logicalVolIntegrityDesc *)sbi->s_lvid_bh->b_data;\r\nle32_add_cpu(&lvid->freeSpaceTable[partition], cnt);\r\nudf_updated_lvid(sb);\r\n}\r\nstatic void udf_bitmap_free_blocks(struct super_block *sb,\r\nstruct udf_bitmap *bitmap,\r\nstruct kernel_lb_addr *bloc,\r\nuint32_t offset,\r\nuint32_t count)\r\n{\r\nstruct udf_sb_info *sbi = UDF_SB(sb);\r\nstruct buffer_head *bh = NULL;\r\nstruct udf_part_map *partmap;\r\nunsigned long block;\r\nunsigned long block_group;\r\nunsigned long bit;\r\nunsigned long i;\r\nint bitmap_nr;\r\nunsigned long overflow;\r\nmutex_lock(&sbi->s_alloc_mutex);\r\npartmap = &sbi->s_partmaps[bloc->partitionReferenceNum];\r\nif (bloc->logicalBlockNum + count < count ||\r\n(bloc->logicalBlockNum + count) > partmap->s_partition_len) {\r\nudf_debug("%d < %d || %d + %d > %d\n",\r\nbloc->logicalBlockNum, 0,\r\nbloc->logicalBlockNum, count,\r\npartmap->s_partition_len);\r\ngoto error_return;\r\n}\r\nblock = bloc->logicalBlockNum + offset +\r\n(sizeof(struct spaceBitmapDesc) << 3);\r\ndo {\r\noverflow = 0;\r\nblock_group = block >> (sb->s_blocksize_bits + 3);\r\nbit = block % (sb->s_blocksize << 3);\r\nif (bit + count > (sb->s_blocksize << 3)) {\r\noverflow = bit + count - (sb->s_blocksize << 3);\r\ncount -= overflow;\r\n}\r\nbitmap_nr = load_block_bitmap(sb, bitmap, block_group);\r\nif (bitmap_nr < 0)\r\ngoto error_return;\r\nbh = bitmap->s_block_bitmap[bitmap_nr];\r\nfor (i = 0; i < count; i++) {\r\nif (udf_set_bit(bit + i, bh->b_data)) {\r\nudf_debug("bit %ld already set\n", bit + i);\r\nudf_debug("byte=%2x\n",\r\n((char *)bh->b_data)[(bit + i) >> 3]);\r\n}\r\n}\r\nudf_add_free_space(sb, sbi->s_partition, count);\r\nmark_buffer_dirty(bh);\r\nif (overflow) {\r\nblock += count;\r\ncount = overflow;\r\n}\r\n} while (overflow);\r\nerror_return:\r\nmutex_unlock(&sbi->s_alloc_mutex);\r\n}\r\nstatic int udf_bitmap_prealloc_blocks(struct super_block *sb,\r\nstruct udf_bitmap *bitmap,\r\nuint16_t partition, uint32_t first_block,\r\nuint32_t block_count)\r\n{\r\nstruct udf_sb_info *sbi = UDF_SB(sb);\r\nint alloc_count = 0;\r\nint bit, block, block_group, group_start;\r\nint nr_groups, bitmap_nr;\r\nstruct buffer_head *bh;\r\n__u32 part_len;\r\nmutex_lock(&sbi->s_alloc_mutex);\r\npart_len = sbi->s_partmaps[partition].s_partition_len;\r\nif (first_block >= part_len)\r\ngoto out;\r\nif (first_block + block_count > part_len)\r\nblock_count = part_len - first_block;\r\ndo {\r\nnr_groups = udf_compute_nr_groups(sb, partition);\r\nblock = first_block + (sizeof(struct spaceBitmapDesc) << 3);\r\nblock_group = block >> (sb->s_blocksize_bits + 3);\r\ngroup_start = block_group ? 0 : sizeof(struct spaceBitmapDesc);\r\nbitmap_nr = load_block_bitmap(sb, bitmap, block_group);\r\nif (bitmap_nr < 0)\r\ngoto out;\r\nbh = bitmap->s_block_bitmap[bitmap_nr];\r\nbit = block % (sb->s_blocksize << 3);\r\nwhile (bit < (sb->s_blocksize << 3) && block_count > 0) {\r\nif (!udf_clear_bit(bit, bh->b_data))\r\ngoto out;\r\nblock_count--;\r\nalloc_count++;\r\nbit++;\r\nblock++;\r\n}\r\nmark_buffer_dirty(bh);\r\n} while (block_count > 0);\r\nout:\r\nudf_add_free_space(sb, partition, -alloc_count);\r\nmutex_unlock(&sbi->s_alloc_mutex);\r\nreturn alloc_count;\r\n}\r\nstatic int udf_bitmap_new_block(struct super_block *sb,\r\nstruct udf_bitmap *bitmap, uint16_t partition,\r\nuint32_t goal, int *err)\r\n{\r\nstruct udf_sb_info *sbi = UDF_SB(sb);\r\nint newbit, bit = 0, block, block_group, group_start;\r\nint end_goal, nr_groups, bitmap_nr, i;\r\nstruct buffer_head *bh = NULL;\r\nchar *ptr;\r\nint newblock = 0;\r\n*err = -ENOSPC;\r\nmutex_lock(&sbi->s_alloc_mutex);\r\nrepeat:\r\nif (goal >= sbi->s_partmaps[partition].s_partition_len)\r\ngoal = 0;\r\nnr_groups = bitmap->s_nr_groups;\r\nblock = goal + (sizeof(struct spaceBitmapDesc) << 3);\r\nblock_group = block >> (sb->s_blocksize_bits + 3);\r\ngroup_start = block_group ? 0 : sizeof(struct spaceBitmapDesc);\r\nbitmap_nr = load_block_bitmap(sb, bitmap, block_group);\r\nif (bitmap_nr < 0)\r\ngoto error_return;\r\nbh = bitmap->s_block_bitmap[bitmap_nr];\r\nptr = memscan((char *)bh->b_data + group_start, 0xFF,\r\nsb->s_blocksize - group_start);\r\nif ((ptr - ((char *)bh->b_data)) < sb->s_blocksize) {\r\nbit = block % (sb->s_blocksize << 3);\r\nif (udf_test_bit(bit, bh->b_data))\r\ngoto got_block;\r\nend_goal = (bit + 63) & ~63;\r\nbit = udf_find_next_one_bit(bh->b_data, end_goal, bit);\r\nif (bit < end_goal)\r\ngoto got_block;\r\nptr = memscan((char *)bh->b_data + (bit >> 3), 0xFF,\r\nsb->s_blocksize - ((bit + 7) >> 3));\r\nnewbit = (ptr - ((char *)bh->b_data)) << 3;\r\nif (newbit < sb->s_blocksize << 3) {\r\nbit = newbit;\r\ngoto search_back;\r\n}\r\nnewbit = udf_find_next_one_bit(bh->b_data,\r\nsb->s_blocksize << 3, bit);\r\nif (newbit < sb->s_blocksize << 3) {\r\nbit = newbit;\r\ngoto got_block;\r\n}\r\n}\r\nfor (i = 0; i < (nr_groups * 2); i++) {\r\nblock_group++;\r\nif (block_group >= nr_groups)\r\nblock_group = 0;\r\ngroup_start = block_group ? 0 : sizeof(struct spaceBitmapDesc);\r\nbitmap_nr = load_block_bitmap(sb, bitmap, block_group);\r\nif (bitmap_nr < 0)\r\ngoto error_return;\r\nbh = bitmap->s_block_bitmap[bitmap_nr];\r\nif (i < nr_groups) {\r\nptr = memscan((char *)bh->b_data + group_start, 0xFF,\r\nsb->s_blocksize - group_start);\r\nif ((ptr - ((char *)bh->b_data)) < sb->s_blocksize) {\r\nbit = (ptr - ((char *)bh->b_data)) << 3;\r\nbreak;\r\n}\r\n} else {\r\nbit = udf_find_next_one_bit(bh->b_data,\r\nsb->s_blocksize << 3,\r\ngroup_start << 3);\r\nif (bit < sb->s_blocksize << 3)\r\nbreak;\r\n}\r\n}\r\nif (i >= (nr_groups * 2)) {\r\nmutex_unlock(&sbi->s_alloc_mutex);\r\nreturn newblock;\r\n}\r\nif (bit < sb->s_blocksize << 3)\r\ngoto search_back;\r\nelse\r\nbit = udf_find_next_one_bit(bh->b_data, sb->s_blocksize << 3,\r\ngroup_start << 3);\r\nif (bit >= sb->s_blocksize << 3) {\r\nmutex_unlock(&sbi->s_alloc_mutex);\r\nreturn 0;\r\n}\r\nsearch_back:\r\ni = 0;\r\nwhile (i < 7 && bit > (group_start << 3) &&\r\nudf_test_bit(bit - 1, bh->b_data)) {\r\n++i;\r\n--bit;\r\n}\r\ngot_block:\r\nnewblock = bit + (block_group << (sb->s_blocksize_bits + 3)) -\r\n(sizeof(struct spaceBitmapDesc) << 3);\r\nif (!udf_clear_bit(bit, bh->b_data)) {\r\nudf_debug("bit already cleared for block %d\n", bit);\r\ngoto repeat;\r\n}\r\nmark_buffer_dirty(bh);\r\nudf_add_free_space(sb, partition, -1);\r\nmutex_unlock(&sbi->s_alloc_mutex);\r\n*err = 0;\r\nreturn newblock;\r\nerror_return:\r\n*err = -EIO;\r\nmutex_unlock(&sbi->s_alloc_mutex);\r\nreturn 0;\r\n}\r\nstatic void udf_table_free_blocks(struct super_block *sb,\r\nstruct inode *table,\r\nstruct kernel_lb_addr *bloc,\r\nuint32_t offset,\r\nuint32_t count)\r\n{\r\nstruct udf_sb_info *sbi = UDF_SB(sb);\r\nstruct udf_part_map *partmap;\r\nuint32_t start, end;\r\nuint32_t elen;\r\nstruct kernel_lb_addr eloc;\r\nstruct extent_position oepos, epos;\r\nint8_t etype;\r\nstruct udf_inode_info *iinfo;\r\nmutex_lock(&sbi->s_alloc_mutex);\r\npartmap = &sbi->s_partmaps[bloc->partitionReferenceNum];\r\nif (bloc->logicalBlockNum + count < count ||\r\n(bloc->logicalBlockNum + count) > partmap->s_partition_len) {\r\nudf_debug("%d < %d || %d + %d > %d\n",\r\nbloc->logicalBlockNum, 0,\r\nbloc->logicalBlockNum, count,\r\npartmap->s_partition_len);\r\ngoto error_return;\r\n}\r\niinfo = UDF_I(table);\r\nudf_add_free_space(sb, sbi->s_partition, count);\r\nstart = bloc->logicalBlockNum + offset;\r\nend = bloc->logicalBlockNum + offset + count - 1;\r\nepos.offset = oepos.offset = sizeof(struct unallocSpaceEntry);\r\nelen = 0;\r\nepos.block = oepos.block = iinfo->i_location;\r\nepos.bh = oepos.bh = NULL;\r\nwhile (count &&\r\n(etype = udf_next_aext(table, &epos, &eloc, &elen, 1)) != -1) {\r\nif (((eloc.logicalBlockNum +\r\n(elen >> sb->s_blocksize_bits)) == start)) {\r\nif ((0x3FFFFFFF - elen) <\r\n(count << sb->s_blocksize_bits)) {\r\nuint32_t tmp = ((0x3FFFFFFF - elen) >>\r\nsb->s_blocksize_bits);\r\ncount -= tmp;\r\nstart += tmp;\r\nelen = (etype << 30) |\r\n(0x40000000 - sb->s_blocksize);\r\n} else {\r\nelen = (etype << 30) |\r\n(elen +\r\n(count << sb->s_blocksize_bits));\r\nstart += count;\r\ncount = 0;\r\n}\r\nudf_write_aext(table, &oepos, &eloc, elen, 1);\r\n} else if (eloc.logicalBlockNum == (end + 1)) {\r\nif ((0x3FFFFFFF - elen) <\r\n(count << sb->s_blocksize_bits)) {\r\nuint32_t tmp = ((0x3FFFFFFF - elen) >>\r\nsb->s_blocksize_bits);\r\ncount -= tmp;\r\nend -= tmp;\r\neloc.logicalBlockNum -= tmp;\r\nelen = (etype << 30) |\r\n(0x40000000 - sb->s_blocksize);\r\n} else {\r\neloc.logicalBlockNum = start;\r\nelen = (etype << 30) |\r\n(elen +\r\n(count << sb->s_blocksize_bits));\r\nend -= count;\r\ncount = 0;\r\n}\r\nudf_write_aext(table, &oepos, &eloc, elen, 1);\r\n}\r\nif (epos.bh != oepos.bh) {\r\noepos.block = epos.block;\r\nbrelse(oepos.bh);\r\nget_bh(epos.bh);\r\noepos.bh = epos.bh;\r\noepos.offset = 0;\r\n} else {\r\noepos.offset = epos.offset;\r\n}\r\n}\r\nif (count) {\r\nint adsize;\r\neloc.logicalBlockNum = start;\r\nelen = EXT_RECORDED_ALLOCATED |\r\n(count << sb->s_blocksize_bits);\r\nif (iinfo->i_alloc_type == ICBTAG_FLAG_AD_SHORT)\r\nadsize = sizeof(struct short_ad);\r\nelse if (iinfo->i_alloc_type == ICBTAG_FLAG_AD_LONG)\r\nadsize = sizeof(struct long_ad);\r\nelse {\r\nbrelse(oepos.bh);\r\nbrelse(epos.bh);\r\ngoto error_return;\r\n}\r\nif (epos.offset + (2 * adsize) > sb->s_blocksize) {\r\nudf_setup_indirect_aext(table, eloc.logicalBlockNum,\r\n&epos);\r\neloc.logicalBlockNum++;\r\nelen -= sb->s_blocksize;\r\n}\r\nif (elen)\r\n__udf_add_aext(table, &epos, &eloc, elen, 1);\r\n}\r\nbrelse(epos.bh);\r\nbrelse(oepos.bh);\r\nerror_return:\r\nmutex_unlock(&sbi->s_alloc_mutex);\r\nreturn;\r\n}\r\nstatic int udf_table_prealloc_blocks(struct super_block *sb,\r\nstruct inode *table, uint16_t partition,\r\nuint32_t first_block, uint32_t block_count)\r\n{\r\nstruct udf_sb_info *sbi = UDF_SB(sb);\r\nint alloc_count = 0;\r\nuint32_t elen, adsize;\r\nstruct kernel_lb_addr eloc;\r\nstruct extent_position epos;\r\nint8_t etype = -1;\r\nstruct udf_inode_info *iinfo;\r\nif (first_block >= sbi->s_partmaps[partition].s_partition_len)\r\nreturn 0;\r\niinfo = UDF_I(table);\r\nif (iinfo->i_alloc_type == ICBTAG_FLAG_AD_SHORT)\r\nadsize = sizeof(struct short_ad);\r\nelse if (iinfo->i_alloc_type == ICBTAG_FLAG_AD_LONG)\r\nadsize = sizeof(struct long_ad);\r\nelse\r\nreturn 0;\r\nmutex_lock(&sbi->s_alloc_mutex);\r\nepos.offset = sizeof(struct unallocSpaceEntry);\r\nepos.block = iinfo->i_location;\r\nepos.bh = NULL;\r\neloc.logicalBlockNum = 0xFFFFFFFF;\r\nwhile (first_block != eloc.logicalBlockNum &&\r\n(etype = udf_next_aext(table, &epos, &eloc, &elen, 1)) != -1) {\r\nudf_debug("eloc=%d, elen=%d, first_block=%d\n",\r\neloc.logicalBlockNum, elen, first_block);\r\n;\r\n}\r\nif (first_block == eloc.logicalBlockNum) {\r\nepos.offset -= adsize;\r\nalloc_count = (elen >> sb->s_blocksize_bits);\r\nif (alloc_count > block_count) {\r\nalloc_count = block_count;\r\neloc.logicalBlockNum += alloc_count;\r\nelen -= (alloc_count << sb->s_blocksize_bits);\r\nudf_write_aext(table, &epos, &eloc,\r\n(etype << 30) | elen, 1);\r\n} else\r\nudf_delete_aext(table, epos, eloc,\r\n(etype << 30) | elen);\r\n} else {\r\nalloc_count = 0;\r\n}\r\nbrelse(epos.bh);\r\nif (alloc_count)\r\nudf_add_free_space(sb, partition, -alloc_count);\r\nmutex_unlock(&sbi->s_alloc_mutex);\r\nreturn alloc_count;\r\n}\r\nstatic int udf_table_new_block(struct super_block *sb,\r\nstruct inode *table, uint16_t partition,\r\nuint32_t goal, int *err)\r\n{\r\nstruct udf_sb_info *sbi = UDF_SB(sb);\r\nuint32_t spread = 0xFFFFFFFF, nspread = 0xFFFFFFFF;\r\nuint32_t newblock = 0, adsize;\r\nuint32_t elen, goal_elen = 0;\r\nstruct kernel_lb_addr eloc, uninitialized_var(goal_eloc);\r\nstruct extent_position epos, goal_epos;\r\nint8_t etype;\r\nstruct udf_inode_info *iinfo = UDF_I(table);\r\n*err = -ENOSPC;\r\nif (iinfo->i_alloc_type == ICBTAG_FLAG_AD_SHORT)\r\nadsize = sizeof(struct short_ad);\r\nelse if (iinfo->i_alloc_type == ICBTAG_FLAG_AD_LONG)\r\nadsize = sizeof(struct long_ad);\r\nelse\r\nreturn newblock;\r\nmutex_lock(&sbi->s_alloc_mutex);\r\nif (goal >= sbi->s_partmaps[partition].s_partition_len)\r\ngoal = 0;\r\nepos.offset = sizeof(struct unallocSpaceEntry);\r\nepos.block = iinfo->i_location;\r\nepos.bh = goal_epos.bh = NULL;\r\nwhile (spread &&\r\n(etype = udf_next_aext(table, &epos, &eloc, &elen, 1)) != -1) {\r\nif (goal >= eloc.logicalBlockNum) {\r\nif (goal < eloc.logicalBlockNum +\r\n(elen >> sb->s_blocksize_bits))\r\nnspread = 0;\r\nelse\r\nnspread = goal - eloc.logicalBlockNum -\r\n(elen >> sb->s_blocksize_bits);\r\n} else {\r\nnspread = eloc.logicalBlockNum - goal;\r\n}\r\nif (nspread < spread) {\r\nspread = nspread;\r\nif (goal_epos.bh != epos.bh) {\r\nbrelse(goal_epos.bh);\r\ngoal_epos.bh = epos.bh;\r\nget_bh(goal_epos.bh);\r\n}\r\ngoal_epos.block = epos.block;\r\ngoal_epos.offset = epos.offset - adsize;\r\ngoal_eloc = eloc;\r\ngoal_elen = (etype << 30) | elen;\r\n}\r\n}\r\nbrelse(epos.bh);\r\nif (spread == 0xFFFFFFFF) {\r\nbrelse(goal_epos.bh);\r\nmutex_unlock(&sbi->s_alloc_mutex);\r\nreturn 0;\r\n}\r\nnewblock = goal_eloc.logicalBlockNum;\r\ngoal_eloc.logicalBlockNum++;\r\ngoal_elen -= sb->s_blocksize;\r\nif (goal_elen)\r\nudf_write_aext(table, &goal_epos, &goal_eloc, goal_elen, 1);\r\nelse\r\nudf_delete_aext(table, goal_epos, goal_eloc, goal_elen);\r\nbrelse(goal_epos.bh);\r\nudf_add_free_space(sb, partition, -1);\r\nmutex_unlock(&sbi->s_alloc_mutex);\r\n*err = 0;\r\nreturn newblock;\r\n}\r\nvoid udf_free_blocks(struct super_block *sb, struct inode *inode,\r\nstruct kernel_lb_addr *bloc, uint32_t offset,\r\nuint32_t count)\r\n{\r\nuint16_t partition = bloc->partitionReferenceNum;\r\nstruct udf_part_map *map = &UDF_SB(sb)->s_partmaps[partition];\r\nif (map->s_partition_flags & UDF_PART_FLAG_UNALLOC_BITMAP) {\r\nudf_bitmap_free_blocks(sb, map->s_uspace.s_bitmap,\r\nbloc, offset, count);\r\n} else if (map->s_partition_flags & UDF_PART_FLAG_UNALLOC_TABLE) {\r\nudf_table_free_blocks(sb, map->s_uspace.s_table,\r\nbloc, offset, count);\r\n} else if (map->s_partition_flags & UDF_PART_FLAG_FREED_BITMAP) {\r\nudf_bitmap_free_blocks(sb, map->s_fspace.s_bitmap,\r\nbloc, offset, count);\r\n} else if (map->s_partition_flags & UDF_PART_FLAG_FREED_TABLE) {\r\nudf_table_free_blocks(sb, map->s_fspace.s_table,\r\nbloc, offset, count);\r\n}\r\nif (inode) {\r\ninode_sub_bytes(inode,\r\n((sector_t)count) << sb->s_blocksize_bits);\r\n}\r\n}\r\ninline int udf_prealloc_blocks(struct super_block *sb,\r\nstruct inode *inode,\r\nuint16_t partition, uint32_t first_block,\r\nuint32_t block_count)\r\n{\r\nstruct udf_part_map *map = &UDF_SB(sb)->s_partmaps[partition];\r\nint allocated;\r\nif (map->s_partition_flags & UDF_PART_FLAG_UNALLOC_BITMAP)\r\nallocated = udf_bitmap_prealloc_blocks(sb,\r\nmap->s_uspace.s_bitmap,\r\npartition, first_block,\r\nblock_count);\r\nelse if (map->s_partition_flags & UDF_PART_FLAG_UNALLOC_TABLE)\r\nallocated = udf_table_prealloc_blocks(sb,\r\nmap->s_uspace.s_table,\r\npartition, first_block,\r\nblock_count);\r\nelse if (map->s_partition_flags & UDF_PART_FLAG_FREED_BITMAP)\r\nallocated = udf_bitmap_prealloc_blocks(sb,\r\nmap->s_fspace.s_bitmap,\r\npartition, first_block,\r\nblock_count);\r\nelse if (map->s_partition_flags & UDF_PART_FLAG_FREED_TABLE)\r\nallocated = udf_table_prealloc_blocks(sb,\r\nmap->s_fspace.s_table,\r\npartition, first_block,\r\nblock_count);\r\nelse\r\nreturn 0;\r\nif (inode && allocated > 0)\r\ninode_add_bytes(inode, allocated << sb->s_blocksize_bits);\r\nreturn allocated;\r\n}\r\ninline int udf_new_block(struct super_block *sb,\r\nstruct inode *inode,\r\nuint16_t partition, uint32_t goal, int *err)\r\n{\r\nstruct udf_part_map *map = &UDF_SB(sb)->s_partmaps[partition];\r\nint block;\r\nif (map->s_partition_flags & UDF_PART_FLAG_UNALLOC_BITMAP)\r\nblock = udf_bitmap_new_block(sb,\r\nmap->s_uspace.s_bitmap,\r\npartition, goal, err);\r\nelse if (map->s_partition_flags & UDF_PART_FLAG_UNALLOC_TABLE)\r\nblock = udf_table_new_block(sb,\r\nmap->s_uspace.s_table,\r\npartition, goal, err);\r\nelse if (map->s_partition_flags & UDF_PART_FLAG_FREED_BITMAP)\r\nblock = udf_bitmap_new_block(sb,\r\nmap->s_fspace.s_bitmap,\r\npartition, goal, err);\r\nelse if (map->s_partition_flags & UDF_PART_FLAG_FREED_TABLE)\r\nblock = udf_table_new_block(sb,\r\nmap->s_fspace.s_table,\r\npartition, goal, err);\r\nelse {\r\n*err = -EIO;\r\nreturn 0;\r\n}\r\nif (inode && block)\r\ninode_add_bytes(inode, sb->s_blocksize);\r\nreturn block;\r\n}
