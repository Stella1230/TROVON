static inline const char *mtt_states_str(enum res_mtt_states state)\r\n{\r\nswitch (state) {\r\ncase RES_MTT_BUSY: return "RES_MTT_BUSY";\r\ncase RES_MTT_ALLOCATED: return "RES_MTT_ALLOCATED";\r\ndefault: return "Unknown";\r\n}\r\n}\r\nstatic void *res_tracker_lookup(struct rb_root *root, u64 res_id)\r\n{\r\nstruct rb_node *node = root->rb_node;\r\nwhile (node) {\r\nstruct res_common *res = container_of(node, struct res_common,\r\nnode);\r\nif (res_id < res->res_id)\r\nnode = node->rb_left;\r\nelse if (res_id > res->res_id)\r\nnode = node->rb_right;\r\nelse\r\nreturn res;\r\n}\r\nreturn NULL;\r\n}\r\nstatic int res_tracker_insert(struct rb_root *root, struct res_common *res)\r\n{\r\nstruct rb_node **new = &(root->rb_node), *parent = NULL;\r\nwhile (*new) {\r\nstruct res_common *this = container_of(*new, struct res_common,\r\nnode);\r\nparent = *new;\r\nif (res->res_id < this->res_id)\r\nnew = &((*new)->rb_left);\r\nelse if (res->res_id > this->res_id)\r\nnew = &((*new)->rb_right);\r\nelse\r\nreturn -EEXIST;\r\n}\r\nrb_link_node(&res->node, parent, new);\r\nrb_insert_color(&res->node, root);\r\nreturn 0;\r\n}\r\nstatic const char *resource_str(enum mlx4_resource rt)\r\n{\r\nswitch (rt) {\r\ncase RES_QP: return "RES_QP";\r\ncase RES_CQ: return "RES_CQ";\r\ncase RES_SRQ: return "RES_SRQ";\r\ncase RES_MPT: return "RES_MPT";\r\ncase RES_MTT: return "RES_MTT";\r\ncase RES_MAC: return "RES_MAC";\r\ncase RES_VLAN: return "RES_VLAN";\r\ncase RES_EQ: return "RES_EQ";\r\ncase RES_COUNTER: return "RES_COUNTER";\r\ncase RES_FS_RULE: return "RES_FS_RULE";\r\ncase RES_XRCD: return "RES_XRCD";\r\ndefault: return "Unknown resource type !!!";\r\n};\r\n}\r\nstatic inline int mlx4_grant_resource(struct mlx4_dev *dev, int slave,\r\nenum mlx4_resource res_type, int count,\r\nint port)\r\n{\r\nstruct mlx4_priv *priv = mlx4_priv(dev);\r\nstruct resource_allocator *res_alloc =\r\n&priv->mfunc.master.res_tracker.res_alloc[res_type];\r\nint err = -EINVAL;\r\nint allocated, free, reserved, guaranteed, from_free;\r\nint from_rsvd;\r\nif (slave > dev->persist->num_vfs)\r\nreturn -EINVAL;\r\nspin_lock(&res_alloc->alloc_lock);\r\nallocated = (port > 0) ?\r\nres_alloc->allocated[(port - 1) *\r\n(dev->persist->num_vfs + 1) + slave] :\r\nres_alloc->allocated[slave];\r\nfree = (port > 0) ? res_alloc->res_port_free[port - 1] :\r\nres_alloc->res_free;\r\nreserved = (port > 0) ? res_alloc->res_port_rsvd[port - 1] :\r\nres_alloc->res_reserved;\r\nguaranteed = res_alloc->guaranteed[slave];\r\nif (allocated + count > res_alloc->quota[slave]) {\r\nmlx4_warn(dev, "VF %d port %d res %s: quota exceeded, count %d alloc %d quota %d\n",\r\nslave, port, resource_str(res_type), count,\r\nallocated, res_alloc->quota[slave]);\r\ngoto out;\r\n}\r\nif (allocated + count <= guaranteed) {\r\nerr = 0;\r\nfrom_rsvd = count;\r\n} else {\r\nif (guaranteed - allocated > 0)\r\nfrom_free = count - (guaranteed - allocated);\r\nelse\r\nfrom_free = count;\r\nfrom_rsvd = count - from_free;\r\nif (free - from_free >= reserved)\r\nerr = 0;\r\nelse\r\nmlx4_warn(dev, "VF %d port %d res %s: free pool empty, free %d from_free %d rsvd %d\n",\r\nslave, port, resource_str(res_type), free,\r\nfrom_free, reserved);\r\n}\r\nif (!err) {\r\nif (port > 0) {\r\nres_alloc->allocated[(port - 1) *\r\n(dev->persist->num_vfs + 1) + slave] += count;\r\nres_alloc->res_port_free[port - 1] -= count;\r\nres_alloc->res_port_rsvd[port - 1] -= from_rsvd;\r\n} else {\r\nres_alloc->allocated[slave] += count;\r\nres_alloc->res_free -= count;\r\nres_alloc->res_reserved -= from_rsvd;\r\n}\r\n}\r\nout:\r\nspin_unlock(&res_alloc->alloc_lock);\r\nreturn err;\r\n}\r\nstatic inline void mlx4_release_resource(struct mlx4_dev *dev, int slave,\r\nenum mlx4_resource res_type, int count,\r\nint port)\r\n{\r\nstruct mlx4_priv *priv = mlx4_priv(dev);\r\nstruct resource_allocator *res_alloc =\r\n&priv->mfunc.master.res_tracker.res_alloc[res_type];\r\nint allocated, guaranteed, from_rsvd;\r\nif (slave > dev->persist->num_vfs)\r\nreturn;\r\nspin_lock(&res_alloc->alloc_lock);\r\nallocated = (port > 0) ?\r\nres_alloc->allocated[(port - 1) *\r\n(dev->persist->num_vfs + 1) + slave] :\r\nres_alloc->allocated[slave];\r\nguaranteed = res_alloc->guaranteed[slave];\r\nif (allocated - count >= guaranteed) {\r\nfrom_rsvd = 0;\r\n} else {\r\nif (allocated - guaranteed > 0)\r\nfrom_rsvd = count - (allocated - guaranteed);\r\nelse\r\nfrom_rsvd = count;\r\n}\r\nif (port > 0) {\r\nres_alloc->allocated[(port - 1) *\r\n(dev->persist->num_vfs + 1) + slave] -= count;\r\nres_alloc->res_port_free[port - 1] += count;\r\nres_alloc->res_port_rsvd[port - 1] += from_rsvd;\r\n} else {\r\nres_alloc->allocated[slave] -= count;\r\nres_alloc->res_free += count;\r\nres_alloc->res_reserved += from_rsvd;\r\n}\r\nspin_unlock(&res_alloc->alloc_lock);\r\nreturn;\r\n}\r\nstatic inline void initialize_res_quotas(struct mlx4_dev *dev,\r\nstruct resource_allocator *res_alloc,\r\nenum mlx4_resource res_type,\r\nint vf, int num_instances)\r\n{\r\nres_alloc->guaranteed[vf] = num_instances /\r\n(2 * (dev->persist->num_vfs + 1));\r\nres_alloc->quota[vf] = (num_instances / 2) + res_alloc->guaranteed[vf];\r\nif (vf == mlx4_master_func_num(dev)) {\r\nres_alloc->res_free = num_instances;\r\nif (res_type == RES_MTT) {\r\nres_alloc->res_free += dev->caps.reserved_mtts;\r\nres_alloc->guaranteed[vf] += dev->caps.reserved_mtts;\r\nres_alloc->quota[vf] += dev->caps.reserved_mtts;\r\n}\r\n}\r\n}\r\nvoid mlx4_init_quotas(struct mlx4_dev *dev)\r\n{\r\nstruct mlx4_priv *priv = mlx4_priv(dev);\r\nint pf;\r\nif (mlx4_is_slave(dev))\r\nreturn;\r\nif (!mlx4_is_mfunc(dev)) {\r\ndev->quotas.qp = dev->caps.num_qps - dev->caps.reserved_qps -\r\nmlx4_num_reserved_sqps(dev);\r\ndev->quotas.cq = dev->caps.num_cqs - dev->caps.reserved_cqs;\r\ndev->quotas.srq = dev->caps.num_srqs - dev->caps.reserved_srqs;\r\ndev->quotas.mtt = dev->caps.num_mtts - dev->caps.reserved_mtts;\r\ndev->quotas.mpt = dev->caps.num_mpts - dev->caps.reserved_mrws;\r\nreturn;\r\n}\r\npf = mlx4_master_func_num(dev);\r\ndev->quotas.qp =\r\npriv->mfunc.master.res_tracker.res_alloc[RES_QP].quota[pf];\r\ndev->quotas.cq =\r\npriv->mfunc.master.res_tracker.res_alloc[RES_CQ].quota[pf];\r\ndev->quotas.srq =\r\npriv->mfunc.master.res_tracker.res_alloc[RES_SRQ].quota[pf];\r\ndev->quotas.mtt =\r\npriv->mfunc.master.res_tracker.res_alloc[RES_MTT].quota[pf];\r\ndev->quotas.mpt =\r\npriv->mfunc.master.res_tracker.res_alloc[RES_MPT].quota[pf];\r\n}\r\nstatic int get_max_gauranteed_vfs_counter(struct mlx4_dev *dev)\r\n{\r\nreturn (dev->caps.max_counters - 1 -\r\n(MLX4_PF_COUNTERS_PER_PORT * MLX4_MAX_PORTS))\r\n/ MLX4_MAX_PORTS;\r\n}\r\nint mlx4_init_resource_tracker(struct mlx4_dev *dev)\r\n{\r\nstruct mlx4_priv *priv = mlx4_priv(dev);\r\nint i, j;\r\nint t;\r\nint max_vfs_guarantee_counter = get_max_gauranteed_vfs_counter(dev);\r\npriv->mfunc.master.res_tracker.slave_list =\r\nkzalloc(dev->num_slaves * sizeof(struct slave_list),\r\nGFP_KERNEL);\r\nif (!priv->mfunc.master.res_tracker.slave_list)\r\nreturn -ENOMEM;\r\nfor (i = 0 ; i < dev->num_slaves; i++) {\r\nfor (t = 0; t < MLX4_NUM_OF_RESOURCE_TYPE; ++t)\r\nINIT_LIST_HEAD(&priv->mfunc.master.res_tracker.\r\nslave_list[i].res_list[t]);\r\nmutex_init(&priv->mfunc.master.res_tracker.slave_list[i].mutex);\r\n}\r\nmlx4_dbg(dev, "Started init_resource_tracker: %ld slaves\n",\r\ndev->num_slaves);\r\nfor (i = 0 ; i < MLX4_NUM_OF_RESOURCE_TYPE; i++)\r\npriv->mfunc.master.res_tracker.res_tree[i] = RB_ROOT;\r\nfor (i = 0; i < MLX4_NUM_OF_RESOURCE_TYPE; i++) {\r\nstruct resource_allocator *res_alloc =\r\n&priv->mfunc.master.res_tracker.res_alloc[i];\r\nres_alloc->quota = kmalloc((dev->persist->num_vfs + 1) *\r\nsizeof(int), GFP_KERNEL);\r\nres_alloc->guaranteed = kmalloc((dev->persist->num_vfs + 1) *\r\nsizeof(int), GFP_KERNEL);\r\nif (i == RES_MAC || i == RES_VLAN)\r\nres_alloc->allocated = kzalloc(MLX4_MAX_PORTS *\r\n(dev->persist->num_vfs\r\n+ 1) *\r\nsizeof(int), GFP_KERNEL);\r\nelse\r\nres_alloc->allocated = kzalloc((dev->persist->\r\nnum_vfs + 1) *\r\nsizeof(int), GFP_KERNEL);\r\nif (i == RES_COUNTER)\r\nres_alloc->res_free = dev->caps.max_counters - 1;\r\nif (!res_alloc->quota || !res_alloc->guaranteed ||\r\n!res_alloc->allocated)\r\ngoto no_mem_err;\r\nspin_lock_init(&res_alloc->alloc_lock);\r\nfor (t = 0; t < dev->persist->num_vfs + 1; t++) {\r\nstruct mlx4_active_ports actv_ports =\r\nmlx4_get_active_ports(dev, t);\r\nswitch (i) {\r\ncase RES_QP:\r\ninitialize_res_quotas(dev, res_alloc, RES_QP,\r\nt, dev->caps.num_qps -\r\ndev->caps.reserved_qps -\r\nmlx4_num_reserved_sqps(dev));\r\nbreak;\r\ncase RES_CQ:\r\ninitialize_res_quotas(dev, res_alloc, RES_CQ,\r\nt, dev->caps.num_cqs -\r\ndev->caps.reserved_cqs);\r\nbreak;\r\ncase RES_SRQ:\r\ninitialize_res_quotas(dev, res_alloc, RES_SRQ,\r\nt, dev->caps.num_srqs -\r\ndev->caps.reserved_srqs);\r\nbreak;\r\ncase RES_MPT:\r\ninitialize_res_quotas(dev, res_alloc, RES_MPT,\r\nt, dev->caps.num_mpts -\r\ndev->caps.reserved_mrws);\r\nbreak;\r\ncase RES_MTT:\r\ninitialize_res_quotas(dev, res_alloc, RES_MTT,\r\nt, dev->caps.num_mtts -\r\ndev->caps.reserved_mtts);\r\nbreak;\r\ncase RES_MAC:\r\nif (t == mlx4_master_func_num(dev)) {\r\nint max_vfs_pport = 0;\r\nfor (j = 0; j < dev->caps.num_ports;\r\nj++) {\r\nstruct mlx4_slaves_pport slaves_pport =\r\nmlx4_phys_to_slaves_pport(dev, j + 1);\r\nunsigned current_slaves =\r\nbitmap_weight(slaves_pport.slaves,\r\ndev->caps.num_ports) - 1;\r\nif (max_vfs_pport < current_slaves)\r\nmax_vfs_pport =\r\ncurrent_slaves;\r\n}\r\nres_alloc->quota[t] =\r\nMLX4_MAX_MAC_NUM -\r\n2 * max_vfs_pport;\r\nres_alloc->guaranteed[t] = 2;\r\nfor (j = 0; j < MLX4_MAX_PORTS; j++)\r\nres_alloc->res_port_free[j] =\r\nMLX4_MAX_MAC_NUM;\r\n} else {\r\nres_alloc->quota[t] = MLX4_MAX_MAC_NUM;\r\nres_alloc->guaranteed[t] = 2;\r\n}\r\nbreak;\r\ncase RES_VLAN:\r\nif (t == mlx4_master_func_num(dev)) {\r\nres_alloc->quota[t] = MLX4_MAX_VLAN_NUM;\r\nres_alloc->guaranteed[t] = MLX4_MAX_VLAN_NUM / 2;\r\nfor (j = 0; j < MLX4_MAX_PORTS; j++)\r\nres_alloc->res_port_free[j] =\r\nres_alloc->quota[t];\r\n} else {\r\nres_alloc->quota[t] = MLX4_MAX_VLAN_NUM / 2;\r\nres_alloc->guaranteed[t] = 0;\r\n}\r\nbreak;\r\ncase RES_COUNTER:\r\nres_alloc->quota[t] = dev->caps.max_counters;\r\nif (t == mlx4_master_func_num(dev))\r\nres_alloc->guaranteed[t] =\r\nMLX4_PF_COUNTERS_PER_PORT *\r\nMLX4_MAX_PORTS;\r\nelse if (t <= max_vfs_guarantee_counter)\r\nres_alloc->guaranteed[t] =\r\nMLX4_VF_COUNTERS_PER_PORT *\r\nMLX4_MAX_PORTS;\r\nelse\r\nres_alloc->guaranteed[t] = 0;\r\nres_alloc->res_free -= res_alloc->guaranteed[t];\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nif (i == RES_MAC || i == RES_VLAN) {\r\nfor (j = 0; j < dev->caps.num_ports; j++)\r\nif (test_bit(j, actv_ports.ports))\r\nres_alloc->res_port_rsvd[j] +=\r\nres_alloc->guaranteed[t];\r\n} else {\r\nres_alloc->res_reserved += res_alloc->guaranteed[t];\r\n}\r\n}\r\n}\r\nspin_lock_init(&priv->mfunc.master.res_tracker.lock);\r\nreturn 0;\r\nno_mem_err:\r\nfor (i = 0; i < MLX4_NUM_OF_RESOURCE_TYPE; i++) {\r\nkfree(priv->mfunc.master.res_tracker.res_alloc[i].allocated);\r\npriv->mfunc.master.res_tracker.res_alloc[i].allocated = NULL;\r\nkfree(priv->mfunc.master.res_tracker.res_alloc[i].guaranteed);\r\npriv->mfunc.master.res_tracker.res_alloc[i].guaranteed = NULL;\r\nkfree(priv->mfunc.master.res_tracker.res_alloc[i].quota);\r\npriv->mfunc.master.res_tracker.res_alloc[i].quota = NULL;\r\n}\r\nreturn -ENOMEM;\r\n}\r\nvoid mlx4_free_resource_tracker(struct mlx4_dev *dev,\r\nenum mlx4_res_tracker_free_type type)\r\n{\r\nstruct mlx4_priv *priv = mlx4_priv(dev);\r\nint i;\r\nif (priv->mfunc.master.res_tracker.slave_list) {\r\nif (type != RES_TR_FREE_STRUCTS_ONLY) {\r\nfor (i = 0; i < dev->num_slaves; i++) {\r\nif (type == RES_TR_FREE_ALL ||\r\ndev->caps.function != i)\r\nmlx4_delete_all_resources_for_slave(dev, i);\r\n}\r\ni = dev->caps.function;\r\nmlx4_reset_roce_gids(dev, i);\r\nmutex_lock(&priv->mfunc.master.res_tracker.slave_list[i].mutex);\r\nrem_slave_vlans(dev, i);\r\nmutex_unlock(&priv->mfunc.master.res_tracker.slave_list[i].mutex);\r\n}\r\nif (type != RES_TR_FREE_SLAVES_ONLY) {\r\nfor (i = 0; i < MLX4_NUM_OF_RESOURCE_TYPE; i++) {\r\nkfree(priv->mfunc.master.res_tracker.res_alloc[i].allocated);\r\npriv->mfunc.master.res_tracker.res_alloc[i].allocated = NULL;\r\nkfree(priv->mfunc.master.res_tracker.res_alloc[i].guaranteed);\r\npriv->mfunc.master.res_tracker.res_alloc[i].guaranteed = NULL;\r\nkfree(priv->mfunc.master.res_tracker.res_alloc[i].quota);\r\npriv->mfunc.master.res_tracker.res_alloc[i].quota = NULL;\r\n}\r\nkfree(priv->mfunc.master.res_tracker.slave_list);\r\npriv->mfunc.master.res_tracker.slave_list = NULL;\r\n}\r\n}\r\n}\r\nstatic void update_pkey_index(struct mlx4_dev *dev, int slave,\r\nstruct mlx4_cmd_mailbox *inbox)\r\n{\r\nu8 sched = *(u8 *)(inbox->buf + 64);\r\nu8 orig_index = *(u8 *)(inbox->buf + 35);\r\nu8 new_index;\r\nstruct mlx4_priv *priv = mlx4_priv(dev);\r\nint port;\r\nport = (sched >> 6 & 1) + 1;\r\nnew_index = priv->virt2phys_pkey[slave][port - 1][orig_index];\r\n*(u8 *)(inbox->buf + 35) = new_index;\r\n}\r\nstatic void update_gid(struct mlx4_dev *dev, struct mlx4_cmd_mailbox *inbox,\r\nu8 slave)\r\n{\r\nstruct mlx4_qp_context *qp_ctx = inbox->buf + 8;\r\nenum mlx4_qp_optpar optpar = be32_to_cpu(*(__be32 *) inbox->buf);\r\nu32 ts = (be32_to_cpu(qp_ctx->flags) >> 16) & 0xff;\r\nint port;\r\nif (MLX4_QP_ST_UD == ts) {\r\nport = (qp_ctx->pri_path.sched_queue >> 6 & 1) + 1;\r\nif (mlx4_is_eth(dev, port))\r\nqp_ctx->pri_path.mgid_index =\r\nmlx4_get_base_gid_ix(dev, slave, port) | 0x80;\r\nelse\r\nqp_ctx->pri_path.mgid_index = slave | 0x80;\r\n} else if (MLX4_QP_ST_RC == ts || MLX4_QP_ST_XRC == ts || MLX4_QP_ST_UC == ts) {\r\nif (optpar & MLX4_QP_OPTPAR_PRIMARY_ADDR_PATH) {\r\nport = (qp_ctx->pri_path.sched_queue >> 6 & 1) + 1;\r\nif (mlx4_is_eth(dev, port)) {\r\nqp_ctx->pri_path.mgid_index +=\r\nmlx4_get_base_gid_ix(dev, slave, port);\r\nqp_ctx->pri_path.mgid_index &= 0x7f;\r\n} else {\r\nqp_ctx->pri_path.mgid_index = slave & 0x7F;\r\n}\r\n}\r\nif (optpar & MLX4_QP_OPTPAR_ALT_ADDR_PATH) {\r\nport = (qp_ctx->alt_path.sched_queue >> 6 & 1) + 1;\r\nif (mlx4_is_eth(dev, port)) {\r\nqp_ctx->alt_path.mgid_index +=\r\nmlx4_get_base_gid_ix(dev, slave, port);\r\nqp_ctx->alt_path.mgid_index &= 0x7f;\r\n} else {\r\nqp_ctx->alt_path.mgid_index = slave & 0x7F;\r\n}\r\n}\r\n}\r\n}\r\nstatic int update_vport_qp_param(struct mlx4_dev *dev,\r\nstruct mlx4_cmd_mailbox *inbox,\r\nu8 slave, u32 qpn)\r\n{\r\nstruct mlx4_qp_context *qpc = inbox->buf + 8;\r\nstruct mlx4_vport_oper_state *vp_oper;\r\nstruct mlx4_priv *priv;\r\nu32 qp_type;\r\nint port, err = 0;\r\nport = (qpc->pri_path.sched_queue & 0x40) ? 2 : 1;\r\npriv = mlx4_priv(dev);\r\nvp_oper = &priv->mfunc.master.vf_oper[slave].vport[port];\r\nqp_type = (be32_to_cpu(qpc->flags) >> 16) & 0xff;\r\nerr = handle_counter(dev, qpc, slave, port);\r\nif (err)\r\ngoto out;\r\nif (MLX4_VGT != vp_oper->state.default_vlan) {\r\nif (mlx4_is_qp_reserved(dev, qpn))\r\nreturn 0;\r\nif (qp_type == MLX4_QP_ST_UD ||\r\n(qp_type == MLX4_QP_ST_MLX && mlx4_is_eth(dev, port))) {\r\nif (dev->caps.bmme_flags & MLX4_BMME_FLAG_VSD_INIT2RTR) {\r\n*(__be32 *)inbox->buf =\r\ncpu_to_be32(be32_to_cpu(*(__be32 *)inbox->buf) |\r\nMLX4_QP_OPTPAR_VLAN_STRIPPING);\r\nqpc->param3 &= ~cpu_to_be32(MLX4_STRIP_VLAN);\r\n} else {\r\nstruct mlx4_update_qp_params params = {.flags = 0};\r\nerr = mlx4_update_qp(dev, qpn, MLX4_UPDATE_QP_VSD, &params);\r\nif (err)\r\ngoto out;\r\n}\r\n}\r\nqpc->pri_path.vlan_control &=\r\nMLX4_CTRL_ETH_SRC_CHECK_IF_COUNTER;\r\nif (vp_oper->state.link_state == IFLA_VF_LINK_STATE_DISABLE &&\r\ndev->caps.flags2 & MLX4_DEV_CAP_FLAG2_UPDATE_QP) {\r\nqpc->pri_path.vlan_control |=\r\nMLX4_VLAN_CTRL_ETH_TX_BLOCK_TAGGED |\r\nMLX4_VLAN_CTRL_ETH_TX_BLOCK_PRIO_TAGGED |\r\nMLX4_VLAN_CTRL_ETH_TX_BLOCK_UNTAGGED |\r\nMLX4_VLAN_CTRL_ETH_RX_BLOCK_PRIO_TAGGED |\r\nMLX4_VLAN_CTRL_ETH_RX_BLOCK_UNTAGGED |\r\nMLX4_VLAN_CTRL_ETH_RX_BLOCK_TAGGED;\r\n} else if (0 != vp_oper->state.default_vlan) {\r\nqpc->pri_path.vlan_control |=\r\nMLX4_VLAN_CTRL_ETH_TX_BLOCK_TAGGED |\r\nMLX4_VLAN_CTRL_ETH_RX_BLOCK_PRIO_TAGGED |\r\nMLX4_VLAN_CTRL_ETH_RX_BLOCK_UNTAGGED;\r\n} else {\r\nqpc->pri_path.vlan_control |=\r\nMLX4_VLAN_CTRL_ETH_TX_BLOCK_TAGGED |\r\nMLX4_VLAN_CTRL_ETH_RX_BLOCK_TAGGED;\r\n}\r\nqpc->pri_path.fvl_rx |= MLX4_FVL_RX_FORCE_ETH_VLAN;\r\nqpc->pri_path.vlan_index = vp_oper->vlan_idx;\r\nqpc->pri_path.fl |= MLX4_FL_CV | MLX4_FL_ETH_HIDE_CQE_VLAN;\r\nqpc->pri_path.feup |= MLX4_FEUP_FORCE_ETH_UP | MLX4_FVL_FORCE_ETH_VLAN;\r\nqpc->pri_path.sched_queue &= 0xC7;\r\nqpc->pri_path.sched_queue |= (vp_oper->state.default_qos) << 3;\r\nqpc->qos_vport = vp_oper->state.qos_vport;\r\n}\r\nif (vp_oper->state.spoofchk) {\r\nqpc->pri_path.feup |= MLX4_FSM_FORCE_ETH_SRC_MAC;\r\nqpc->pri_path.grh_mylmc = (0x80 & qpc->pri_path.grh_mylmc) + vp_oper->mac_idx;\r\n}\r\nout:\r\nreturn err;\r\n}\r\nstatic int mpt_mask(struct mlx4_dev *dev)\r\n{\r\nreturn dev->caps.num_mpts - 1;\r\n}\r\nstatic void *find_res(struct mlx4_dev *dev, u64 res_id,\r\nenum mlx4_resource type)\r\n{\r\nstruct mlx4_priv *priv = mlx4_priv(dev);\r\nreturn res_tracker_lookup(&priv->mfunc.master.res_tracker.res_tree[type],\r\nres_id);\r\n}\r\nstatic int get_res(struct mlx4_dev *dev, int slave, u64 res_id,\r\nenum mlx4_resource type,\r\nvoid *res)\r\n{\r\nstruct res_common *r;\r\nint err = 0;\r\nspin_lock_irq(mlx4_tlock(dev));\r\nr = find_res(dev, res_id, type);\r\nif (!r) {\r\nerr = -ENONET;\r\ngoto exit;\r\n}\r\nif (r->state == RES_ANY_BUSY) {\r\nerr = -EBUSY;\r\ngoto exit;\r\n}\r\nif (r->owner != slave) {\r\nerr = -EPERM;\r\ngoto exit;\r\n}\r\nr->from_state = r->state;\r\nr->state = RES_ANY_BUSY;\r\nif (res)\r\n*((struct res_common **)res) = r;\r\nexit:\r\nspin_unlock_irq(mlx4_tlock(dev));\r\nreturn err;\r\n}\r\nint mlx4_get_slave_from_resource_id(struct mlx4_dev *dev,\r\nenum mlx4_resource type,\r\nu64 res_id, int *slave)\r\n{\r\nstruct res_common *r;\r\nint err = -ENOENT;\r\nint id = res_id;\r\nif (type == RES_QP)\r\nid &= 0x7fffff;\r\nspin_lock(mlx4_tlock(dev));\r\nr = find_res(dev, id, type);\r\nif (r) {\r\n*slave = r->owner;\r\nerr = 0;\r\n}\r\nspin_unlock(mlx4_tlock(dev));\r\nreturn err;\r\n}\r\nstatic void put_res(struct mlx4_dev *dev, int slave, u64 res_id,\r\nenum mlx4_resource type)\r\n{\r\nstruct res_common *r;\r\nspin_lock_irq(mlx4_tlock(dev));\r\nr = find_res(dev, res_id, type);\r\nif (r)\r\nr->state = r->from_state;\r\nspin_unlock_irq(mlx4_tlock(dev));\r\n}\r\nstatic int handle_existing_counter(struct mlx4_dev *dev, u8 slave, int port,\r\nint counter_index)\r\n{\r\nstruct res_common *r;\r\nstruct res_counter *counter;\r\nint ret = 0;\r\nif (counter_index == MLX4_SINK_COUNTER_INDEX(dev))\r\nreturn ret;\r\nspin_lock_irq(mlx4_tlock(dev));\r\nr = find_res(dev, counter_index, RES_COUNTER);\r\nif (!r || r->owner != slave) {\r\nret = -EINVAL;\r\n} else {\r\ncounter = container_of(r, struct res_counter, com);\r\nif (!counter->port)\r\ncounter->port = port;\r\n}\r\nspin_unlock_irq(mlx4_tlock(dev));\r\nreturn ret;\r\n}\r\nstatic int handle_unexisting_counter(struct mlx4_dev *dev,\r\nstruct mlx4_qp_context *qpc, u8 slave,\r\nint port)\r\n{\r\nstruct mlx4_priv *priv = mlx4_priv(dev);\r\nstruct mlx4_resource_tracker *tracker = &priv->mfunc.master.res_tracker;\r\nstruct res_common *tmp;\r\nstruct res_counter *counter;\r\nu64 counter_idx = MLX4_SINK_COUNTER_INDEX(dev);\r\nint err = 0;\r\nspin_lock_irq(mlx4_tlock(dev));\r\nlist_for_each_entry(tmp,\r\n&tracker->slave_list[slave].res_list[RES_COUNTER],\r\nlist) {\r\ncounter = container_of(tmp, struct res_counter, com);\r\nif (port == counter->port) {\r\nqpc->pri_path.counter_index = counter->com.res_id;\r\nspin_unlock_irq(mlx4_tlock(dev));\r\nreturn 0;\r\n}\r\n}\r\nspin_unlock_irq(mlx4_tlock(dev));\r\nerr = counter_alloc_res(dev, slave, RES_OP_RESERVE, 0, 0, &counter_idx,\r\nport);\r\nif (err == -ENOENT) {\r\nerr = 0;\r\n} else if (err && err != -ENOSPC) {\r\nmlx4_err(dev, "%s: failed to create new counter for slave %d err %d\n",\r\n__func__, slave, err);\r\n} else {\r\nqpc->pri_path.counter_index = counter_idx;\r\nmlx4_dbg(dev, "%s: alloc new counter for slave %d index %d\n",\r\n__func__, slave, qpc->pri_path.counter_index);\r\nerr = 0;\r\n}\r\nreturn err;\r\n}\r\nstatic int handle_counter(struct mlx4_dev *dev, struct mlx4_qp_context *qpc,\r\nu8 slave, int port)\r\n{\r\nif (qpc->pri_path.counter_index != MLX4_SINK_COUNTER_INDEX(dev))\r\nreturn handle_existing_counter(dev, slave, port,\r\nqpc->pri_path.counter_index);\r\nreturn handle_unexisting_counter(dev, qpc, slave, port);\r\n}\r\nstatic struct res_common *alloc_qp_tr(int id)\r\n{\r\nstruct res_qp *ret;\r\nret = kzalloc(sizeof *ret, GFP_KERNEL);\r\nif (!ret)\r\nreturn NULL;\r\nret->com.res_id = id;\r\nret->com.state = RES_QP_RESERVED;\r\nret->local_qpn = id;\r\nINIT_LIST_HEAD(&ret->mcg_list);\r\nspin_lock_init(&ret->mcg_spl);\r\natomic_set(&ret->ref_count, 0);\r\nreturn &ret->com;\r\n}\r\nstatic struct res_common *alloc_mtt_tr(int id, int order)\r\n{\r\nstruct res_mtt *ret;\r\nret = kzalloc(sizeof *ret, GFP_KERNEL);\r\nif (!ret)\r\nreturn NULL;\r\nret->com.res_id = id;\r\nret->order = order;\r\nret->com.state = RES_MTT_ALLOCATED;\r\natomic_set(&ret->ref_count, 0);\r\nreturn &ret->com;\r\n}\r\nstatic struct res_common *alloc_mpt_tr(int id, int key)\r\n{\r\nstruct res_mpt *ret;\r\nret = kzalloc(sizeof *ret, GFP_KERNEL);\r\nif (!ret)\r\nreturn NULL;\r\nret->com.res_id = id;\r\nret->com.state = RES_MPT_RESERVED;\r\nret->key = key;\r\nreturn &ret->com;\r\n}\r\nstatic struct res_common *alloc_eq_tr(int id)\r\n{\r\nstruct res_eq *ret;\r\nret = kzalloc(sizeof *ret, GFP_KERNEL);\r\nif (!ret)\r\nreturn NULL;\r\nret->com.res_id = id;\r\nret->com.state = RES_EQ_RESERVED;\r\nreturn &ret->com;\r\n}\r\nstatic struct res_common *alloc_cq_tr(int id)\r\n{\r\nstruct res_cq *ret;\r\nret = kzalloc(sizeof *ret, GFP_KERNEL);\r\nif (!ret)\r\nreturn NULL;\r\nret->com.res_id = id;\r\nret->com.state = RES_CQ_ALLOCATED;\r\natomic_set(&ret->ref_count, 0);\r\nreturn &ret->com;\r\n}\r\nstatic struct res_common *alloc_srq_tr(int id)\r\n{\r\nstruct res_srq *ret;\r\nret = kzalloc(sizeof *ret, GFP_KERNEL);\r\nif (!ret)\r\nreturn NULL;\r\nret->com.res_id = id;\r\nret->com.state = RES_SRQ_ALLOCATED;\r\natomic_set(&ret->ref_count, 0);\r\nreturn &ret->com;\r\n}\r\nstatic struct res_common *alloc_counter_tr(int id, int port)\r\n{\r\nstruct res_counter *ret;\r\nret = kzalloc(sizeof *ret, GFP_KERNEL);\r\nif (!ret)\r\nreturn NULL;\r\nret->com.res_id = id;\r\nret->com.state = RES_COUNTER_ALLOCATED;\r\nret->port = port;\r\nreturn &ret->com;\r\n}\r\nstatic struct res_common *alloc_xrcdn_tr(int id)\r\n{\r\nstruct res_xrcdn *ret;\r\nret = kzalloc(sizeof *ret, GFP_KERNEL);\r\nif (!ret)\r\nreturn NULL;\r\nret->com.res_id = id;\r\nret->com.state = RES_XRCD_ALLOCATED;\r\nreturn &ret->com;\r\n}\r\nstatic struct res_common *alloc_fs_rule_tr(u64 id, int qpn)\r\n{\r\nstruct res_fs_rule *ret;\r\nret = kzalloc(sizeof *ret, GFP_KERNEL);\r\nif (!ret)\r\nreturn NULL;\r\nret->com.res_id = id;\r\nret->com.state = RES_FS_RULE_ALLOCATED;\r\nret->qpn = qpn;\r\nreturn &ret->com;\r\n}\r\nstatic struct res_common *alloc_tr(u64 id, enum mlx4_resource type, int slave,\r\nint extra)\r\n{\r\nstruct res_common *ret;\r\nswitch (type) {\r\ncase RES_QP:\r\nret = alloc_qp_tr(id);\r\nbreak;\r\ncase RES_MPT:\r\nret = alloc_mpt_tr(id, extra);\r\nbreak;\r\ncase RES_MTT:\r\nret = alloc_mtt_tr(id, extra);\r\nbreak;\r\ncase RES_EQ:\r\nret = alloc_eq_tr(id);\r\nbreak;\r\ncase RES_CQ:\r\nret = alloc_cq_tr(id);\r\nbreak;\r\ncase RES_SRQ:\r\nret = alloc_srq_tr(id);\r\nbreak;\r\ncase RES_MAC:\r\npr_err("implementation missing\n");\r\nreturn NULL;\r\ncase RES_COUNTER:\r\nret = alloc_counter_tr(id, extra);\r\nbreak;\r\ncase RES_XRCD:\r\nret = alloc_xrcdn_tr(id);\r\nbreak;\r\ncase RES_FS_RULE:\r\nret = alloc_fs_rule_tr(id, extra);\r\nbreak;\r\ndefault:\r\nreturn NULL;\r\n}\r\nif (ret)\r\nret->owner = slave;\r\nreturn ret;\r\n}\r\nint mlx4_calc_vf_counters(struct mlx4_dev *dev, int slave, int port,\r\nstruct mlx4_counter *data)\r\n{\r\nstruct mlx4_priv *priv = mlx4_priv(dev);\r\nstruct mlx4_resource_tracker *tracker = &priv->mfunc.master.res_tracker;\r\nstruct res_common *tmp;\r\nstruct res_counter *counter;\r\nint *counters_arr;\r\nint i = 0, err = 0;\r\nmemset(data, 0, sizeof(*data));\r\ncounters_arr = kmalloc_array(dev->caps.max_counters,\r\nsizeof(*counters_arr), GFP_KERNEL);\r\nif (!counters_arr)\r\nreturn -ENOMEM;\r\nspin_lock_irq(mlx4_tlock(dev));\r\nlist_for_each_entry(tmp,\r\n&tracker->slave_list[slave].res_list[RES_COUNTER],\r\nlist) {\r\ncounter = container_of(tmp, struct res_counter, com);\r\nif (counter->port == port) {\r\ncounters_arr[i] = (int)tmp->res_id;\r\ni++;\r\n}\r\n}\r\nspin_unlock_irq(mlx4_tlock(dev));\r\ncounters_arr[i] = -1;\r\ni = 0;\r\nwhile (counters_arr[i] != -1) {\r\nerr = mlx4_get_counter_stats(dev, counters_arr[i], data,\r\n0);\r\nif (err) {\r\nmemset(data, 0, sizeof(*data));\r\ngoto table_changed;\r\n}\r\ni++;\r\n}\r\ntable_changed:\r\nkfree(counters_arr);\r\nreturn 0;\r\n}\r\nstatic int add_res_range(struct mlx4_dev *dev, int slave, u64 base, int count,\r\nenum mlx4_resource type, int extra)\r\n{\r\nint i;\r\nint err;\r\nstruct mlx4_priv *priv = mlx4_priv(dev);\r\nstruct res_common **res_arr;\r\nstruct mlx4_resource_tracker *tracker = &priv->mfunc.master.res_tracker;\r\nstruct rb_root *root = &tracker->res_tree[type];\r\nres_arr = kzalloc(count * sizeof *res_arr, GFP_KERNEL);\r\nif (!res_arr)\r\nreturn -ENOMEM;\r\nfor (i = 0; i < count; ++i) {\r\nres_arr[i] = alloc_tr(base + i, type, slave, extra);\r\nif (!res_arr[i]) {\r\nfor (--i; i >= 0; --i)\r\nkfree(res_arr[i]);\r\nkfree(res_arr);\r\nreturn -ENOMEM;\r\n}\r\n}\r\nspin_lock_irq(mlx4_tlock(dev));\r\nfor (i = 0; i < count; ++i) {\r\nif (find_res(dev, base + i, type)) {\r\nerr = -EEXIST;\r\ngoto undo;\r\n}\r\nerr = res_tracker_insert(root, res_arr[i]);\r\nif (err)\r\ngoto undo;\r\nlist_add_tail(&res_arr[i]->list,\r\n&tracker->slave_list[slave].res_list[type]);\r\n}\r\nspin_unlock_irq(mlx4_tlock(dev));\r\nkfree(res_arr);\r\nreturn 0;\r\nundo:\r\nfor (--i; i >= 0; --i) {\r\nrb_erase(&res_arr[i]->node, root);\r\nlist_del_init(&res_arr[i]->list);\r\n}\r\nspin_unlock_irq(mlx4_tlock(dev));\r\nfor (i = 0; i < count; ++i)\r\nkfree(res_arr[i]);\r\nkfree(res_arr);\r\nreturn err;\r\n}\r\nstatic int remove_qp_ok(struct res_qp *res)\r\n{\r\nif (res->com.state == RES_QP_BUSY || atomic_read(&res->ref_count) ||\r\n!list_empty(&res->mcg_list)) {\r\npr_err("resource tracker: fail to remove qp, state %d, ref_count %d\n",\r\nres->com.state, atomic_read(&res->ref_count));\r\nreturn -EBUSY;\r\n} else if (res->com.state != RES_QP_RESERVED) {\r\nreturn -EPERM;\r\n}\r\nreturn 0;\r\n}\r\nstatic int remove_mtt_ok(struct res_mtt *res, int order)\r\n{\r\nif (res->com.state == RES_MTT_BUSY ||\r\natomic_read(&res->ref_count)) {\r\npr_devel("%s-%d: state %s, ref_count %d\n",\r\n__func__, __LINE__,\r\nmtt_states_str(res->com.state),\r\natomic_read(&res->ref_count));\r\nreturn -EBUSY;\r\n} else if (res->com.state != RES_MTT_ALLOCATED)\r\nreturn -EPERM;\r\nelse if (res->order != order)\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\nstatic int remove_mpt_ok(struct res_mpt *res)\r\n{\r\nif (res->com.state == RES_MPT_BUSY)\r\nreturn -EBUSY;\r\nelse if (res->com.state != RES_MPT_RESERVED)\r\nreturn -EPERM;\r\nreturn 0;\r\n}\r\nstatic int remove_eq_ok(struct res_eq *res)\r\n{\r\nif (res->com.state == RES_MPT_BUSY)\r\nreturn -EBUSY;\r\nelse if (res->com.state != RES_MPT_RESERVED)\r\nreturn -EPERM;\r\nreturn 0;\r\n}\r\nstatic int remove_counter_ok(struct res_counter *res)\r\n{\r\nif (res->com.state == RES_COUNTER_BUSY)\r\nreturn -EBUSY;\r\nelse if (res->com.state != RES_COUNTER_ALLOCATED)\r\nreturn -EPERM;\r\nreturn 0;\r\n}\r\nstatic int remove_xrcdn_ok(struct res_xrcdn *res)\r\n{\r\nif (res->com.state == RES_XRCD_BUSY)\r\nreturn -EBUSY;\r\nelse if (res->com.state != RES_XRCD_ALLOCATED)\r\nreturn -EPERM;\r\nreturn 0;\r\n}\r\nstatic int remove_fs_rule_ok(struct res_fs_rule *res)\r\n{\r\nif (res->com.state == RES_FS_RULE_BUSY)\r\nreturn -EBUSY;\r\nelse if (res->com.state != RES_FS_RULE_ALLOCATED)\r\nreturn -EPERM;\r\nreturn 0;\r\n}\r\nstatic int remove_cq_ok(struct res_cq *res)\r\n{\r\nif (res->com.state == RES_CQ_BUSY)\r\nreturn -EBUSY;\r\nelse if (res->com.state != RES_CQ_ALLOCATED)\r\nreturn -EPERM;\r\nreturn 0;\r\n}\r\nstatic int remove_srq_ok(struct res_srq *res)\r\n{\r\nif (res->com.state == RES_SRQ_BUSY)\r\nreturn -EBUSY;\r\nelse if (res->com.state != RES_SRQ_ALLOCATED)\r\nreturn -EPERM;\r\nreturn 0;\r\n}\r\nstatic int remove_ok(struct res_common *res, enum mlx4_resource type, int extra)\r\n{\r\nswitch (type) {\r\ncase RES_QP:\r\nreturn remove_qp_ok((struct res_qp *)res);\r\ncase RES_CQ:\r\nreturn remove_cq_ok((struct res_cq *)res);\r\ncase RES_SRQ:\r\nreturn remove_srq_ok((struct res_srq *)res);\r\ncase RES_MPT:\r\nreturn remove_mpt_ok((struct res_mpt *)res);\r\ncase RES_MTT:\r\nreturn remove_mtt_ok((struct res_mtt *)res, extra);\r\ncase RES_MAC:\r\nreturn -ENOSYS;\r\ncase RES_EQ:\r\nreturn remove_eq_ok((struct res_eq *)res);\r\ncase RES_COUNTER:\r\nreturn remove_counter_ok((struct res_counter *)res);\r\ncase RES_XRCD:\r\nreturn remove_xrcdn_ok((struct res_xrcdn *)res);\r\ncase RES_FS_RULE:\r\nreturn remove_fs_rule_ok((struct res_fs_rule *)res);\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\n}\r\nstatic int rem_res_range(struct mlx4_dev *dev, int slave, u64 base, int count,\r\nenum mlx4_resource type, int extra)\r\n{\r\nu64 i;\r\nint err;\r\nstruct mlx4_priv *priv = mlx4_priv(dev);\r\nstruct mlx4_resource_tracker *tracker = &priv->mfunc.master.res_tracker;\r\nstruct res_common *r;\r\nspin_lock_irq(mlx4_tlock(dev));\r\nfor (i = base; i < base + count; ++i) {\r\nr = res_tracker_lookup(&tracker->res_tree[type], i);\r\nif (!r) {\r\nerr = -ENOENT;\r\ngoto out;\r\n}\r\nif (r->owner != slave) {\r\nerr = -EPERM;\r\ngoto out;\r\n}\r\nerr = remove_ok(r, type, extra);\r\nif (err)\r\ngoto out;\r\n}\r\nfor (i = base; i < base + count; ++i) {\r\nr = res_tracker_lookup(&tracker->res_tree[type], i);\r\nrb_erase(&r->node, &tracker->res_tree[type]);\r\nlist_del(&r->list);\r\nkfree(r);\r\n}\r\nerr = 0;\r\nout:\r\nspin_unlock_irq(mlx4_tlock(dev));\r\nreturn err;\r\n}\r\nstatic int qp_res_start_move_to(struct mlx4_dev *dev, int slave, int qpn,\r\nenum res_qp_states state, struct res_qp **qp,\r\nint alloc)\r\n{\r\nstruct mlx4_priv *priv = mlx4_priv(dev);\r\nstruct mlx4_resource_tracker *tracker = &priv->mfunc.master.res_tracker;\r\nstruct res_qp *r;\r\nint err = 0;\r\nspin_lock_irq(mlx4_tlock(dev));\r\nr = res_tracker_lookup(&tracker->res_tree[RES_QP], qpn);\r\nif (!r)\r\nerr = -ENOENT;\r\nelse if (r->com.owner != slave)\r\nerr = -EPERM;\r\nelse {\r\nswitch (state) {\r\ncase RES_QP_BUSY:\r\nmlx4_dbg(dev, "%s: failed RES_QP, 0x%llx\n",\r\n__func__, r->com.res_id);\r\nerr = -EBUSY;\r\nbreak;\r\ncase RES_QP_RESERVED:\r\nif (r->com.state == RES_QP_MAPPED && !alloc)\r\nbreak;\r\nmlx4_dbg(dev, "failed RES_QP, 0x%llx\n", r->com.res_id);\r\nerr = -EINVAL;\r\nbreak;\r\ncase RES_QP_MAPPED:\r\nif ((r->com.state == RES_QP_RESERVED && alloc) ||\r\nr->com.state == RES_QP_HW)\r\nbreak;\r\nelse {\r\nmlx4_dbg(dev, "failed RES_QP, 0x%llx\n",\r\nr->com.res_id);\r\nerr = -EINVAL;\r\n}\r\nbreak;\r\ncase RES_QP_HW:\r\nif (r->com.state != RES_QP_MAPPED)\r\nerr = -EINVAL;\r\nbreak;\r\ndefault:\r\nerr = -EINVAL;\r\n}\r\nif (!err) {\r\nr->com.from_state = r->com.state;\r\nr->com.to_state = state;\r\nr->com.state = RES_QP_BUSY;\r\nif (qp)\r\n*qp = r;\r\n}\r\n}\r\nspin_unlock_irq(mlx4_tlock(dev));\r\nreturn err;\r\n}\r\nstatic int mr_res_start_move_to(struct mlx4_dev *dev, int slave, int index,\r\nenum res_mpt_states state, struct res_mpt **mpt)\r\n{\r\nstruct mlx4_priv *priv = mlx4_priv(dev);\r\nstruct mlx4_resource_tracker *tracker = &priv->mfunc.master.res_tracker;\r\nstruct res_mpt *r;\r\nint err = 0;\r\nspin_lock_irq(mlx4_tlock(dev));\r\nr = res_tracker_lookup(&tracker->res_tree[RES_MPT], index);\r\nif (!r)\r\nerr = -ENOENT;\r\nelse if (r->com.owner != slave)\r\nerr = -EPERM;\r\nelse {\r\nswitch (state) {\r\ncase RES_MPT_BUSY:\r\nerr = -EINVAL;\r\nbreak;\r\ncase RES_MPT_RESERVED:\r\nif (r->com.state != RES_MPT_MAPPED)\r\nerr = -EINVAL;\r\nbreak;\r\ncase RES_MPT_MAPPED:\r\nif (r->com.state != RES_MPT_RESERVED &&\r\nr->com.state != RES_MPT_HW)\r\nerr = -EINVAL;\r\nbreak;\r\ncase RES_MPT_HW:\r\nif (r->com.state != RES_MPT_MAPPED)\r\nerr = -EINVAL;\r\nbreak;\r\ndefault:\r\nerr = -EINVAL;\r\n}\r\nif (!err) {\r\nr->com.from_state = r->com.state;\r\nr->com.to_state = state;\r\nr->com.state = RES_MPT_BUSY;\r\nif (mpt)\r\n*mpt = r;\r\n}\r\n}\r\nspin_unlock_irq(mlx4_tlock(dev));\r\nreturn err;\r\n}\r\nstatic int eq_res_start_move_to(struct mlx4_dev *dev, int slave, int index,\r\nenum res_eq_states state, struct res_eq **eq)\r\n{\r\nstruct mlx4_priv *priv = mlx4_priv(dev);\r\nstruct mlx4_resource_tracker *tracker = &priv->mfunc.master.res_tracker;\r\nstruct res_eq *r;\r\nint err = 0;\r\nspin_lock_irq(mlx4_tlock(dev));\r\nr = res_tracker_lookup(&tracker->res_tree[RES_EQ], index);\r\nif (!r)\r\nerr = -ENOENT;\r\nelse if (r->com.owner != slave)\r\nerr = -EPERM;\r\nelse {\r\nswitch (state) {\r\ncase RES_EQ_BUSY:\r\nerr = -EINVAL;\r\nbreak;\r\ncase RES_EQ_RESERVED:\r\nif (r->com.state != RES_EQ_HW)\r\nerr = -EINVAL;\r\nbreak;\r\ncase RES_EQ_HW:\r\nif (r->com.state != RES_EQ_RESERVED)\r\nerr = -EINVAL;\r\nbreak;\r\ndefault:\r\nerr = -EINVAL;\r\n}\r\nif (!err) {\r\nr->com.from_state = r->com.state;\r\nr->com.to_state = state;\r\nr->com.state = RES_EQ_BUSY;\r\nif (eq)\r\n*eq = r;\r\n}\r\n}\r\nspin_unlock_irq(mlx4_tlock(dev));\r\nreturn err;\r\n}\r\nstatic int cq_res_start_move_to(struct mlx4_dev *dev, int slave, int cqn,\r\nenum res_cq_states state, struct res_cq **cq)\r\n{\r\nstruct mlx4_priv *priv = mlx4_priv(dev);\r\nstruct mlx4_resource_tracker *tracker = &priv->mfunc.master.res_tracker;\r\nstruct res_cq *r;\r\nint err;\r\nspin_lock_irq(mlx4_tlock(dev));\r\nr = res_tracker_lookup(&tracker->res_tree[RES_CQ], cqn);\r\nif (!r) {\r\nerr = -ENOENT;\r\n} else if (r->com.owner != slave) {\r\nerr = -EPERM;\r\n} else if (state == RES_CQ_ALLOCATED) {\r\nif (r->com.state != RES_CQ_HW)\r\nerr = -EINVAL;\r\nelse if (atomic_read(&r->ref_count))\r\nerr = -EBUSY;\r\nelse\r\nerr = 0;\r\n} else if (state != RES_CQ_HW || r->com.state != RES_CQ_ALLOCATED) {\r\nerr = -EINVAL;\r\n} else {\r\nerr = 0;\r\n}\r\nif (!err) {\r\nr->com.from_state = r->com.state;\r\nr->com.to_state = state;\r\nr->com.state = RES_CQ_BUSY;\r\nif (cq)\r\n*cq = r;\r\n}\r\nspin_unlock_irq(mlx4_tlock(dev));\r\nreturn err;\r\n}\r\nstatic int srq_res_start_move_to(struct mlx4_dev *dev, int slave, int index,\r\nenum res_srq_states state, struct res_srq **srq)\r\n{\r\nstruct mlx4_priv *priv = mlx4_priv(dev);\r\nstruct mlx4_resource_tracker *tracker = &priv->mfunc.master.res_tracker;\r\nstruct res_srq *r;\r\nint err = 0;\r\nspin_lock_irq(mlx4_tlock(dev));\r\nr = res_tracker_lookup(&tracker->res_tree[RES_SRQ], index);\r\nif (!r) {\r\nerr = -ENOENT;\r\n} else if (r->com.owner != slave) {\r\nerr = -EPERM;\r\n} else if (state == RES_SRQ_ALLOCATED) {\r\nif (r->com.state != RES_SRQ_HW)\r\nerr = -EINVAL;\r\nelse if (atomic_read(&r->ref_count))\r\nerr = -EBUSY;\r\n} else if (state != RES_SRQ_HW || r->com.state != RES_SRQ_ALLOCATED) {\r\nerr = -EINVAL;\r\n}\r\nif (!err) {\r\nr->com.from_state = r->com.state;\r\nr->com.to_state = state;\r\nr->com.state = RES_SRQ_BUSY;\r\nif (srq)\r\n*srq = r;\r\n}\r\nspin_unlock_irq(mlx4_tlock(dev));\r\nreturn err;\r\n}\r\nstatic void res_abort_move(struct mlx4_dev *dev, int slave,\r\nenum mlx4_resource type, int id)\r\n{\r\nstruct mlx4_priv *priv = mlx4_priv(dev);\r\nstruct mlx4_resource_tracker *tracker = &priv->mfunc.master.res_tracker;\r\nstruct res_common *r;\r\nspin_lock_irq(mlx4_tlock(dev));\r\nr = res_tracker_lookup(&tracker->res_tree[type], id);\r\nif (r && (r->owner == slave))\r\nr->state = r->from_state;\r\nspin_unlock_irq(mlx4_tlock(dev));\r\n}\r\nstatic void res_end_move(struct mlx4_dev *dev, int slave,\r\nenum mlx4_resource type, int id)\r\n{\r\nstruct mlx4_priv *priv = mlx4_priv(dev);\r\nstruct mlx4_resource_tracker *tracker = &priv->mfunc.master.res_tracker;\r\nstruct res_common *r;\r\nspin_lock_irq(mlx4_tlock(dev));\r\nr = res_tracker_lookup(&tracker->res_tree[type], id);\r\nif (r && (r->owner == slave))\r\nr->state = r->to_state;\r\nspin_unlock_irq(mlx4_tlock(dev));\r\n}\r\nstatic int valid_reserved(struct mlx4_dev *dev, int slave, int qpn)\r\n{\r\nreturn mlx4_is_qp_reserved(dev, qpn) &&\r\n(mlx4_is_master(dev) || mlx4_is_guest_proxy(dev, slave, qpn));\r\n}\r\nstatic int fw_reserved(struct mlx4_dev *dev, int qpn)\r\n{\r\nreturn qpn < dev->caps.reserved_qps_cnt[MLX4_QP_REGION_FW];\r\n}\r\nstatic int qp_alloc_res(struct mlx4_dev *dev, int slave, int op, int cmd,\r\nu64 in_param, u64 *out_param)\r\n{\r\nint err;\r\nint count;\r\nint align;\r\nint base;\r\nint qpn;\r\nu8 flags;\r\nswitch (op) {\r\ncase RES_OP_RESERVE:\r\ncount = get_param_l(&in_param) & 0xffffff;\r\nflags = (get_param_l(&in_param) >> 24) & dev->caps.alloc_res_qp_mask;\r\nalign = get_param_h(&in_param);\r\nerr = mlx4_grant_resource(dev, slave, RES_QP, count, 0);\r\nif (err)\r\nreturn err;\r\nerr = __mlx4_qp_reserve_range(dev, count, align, &base, flags);\r\nif (err) {\r\nmlx4_release_resource(dev, slave, RES_QP, count, 0);\r\nreturn err;\r\n}\r\nerr = add_res_range(dev, slave, base, count, RES_QP, 0);\r\nif (err) {\r\nmlx4_release_resource(dev, slave, RES_QP, count, 0);\r\n__mlx4_qp_release_range(dev, base, count);\r\nreturn err;\r\n}\r\nset_param_l(out_param, base);\r\nbreak;\r\ncase RES_OP_MAP_ICM:\r\nqpn = get_param_l(&in_param) & 0x7fffff;\r\nif (valid_reserved(dev, slave, qpn)) {\r\nerr = add_res_range(dev, slave, qpn, 1, RES_QP, 0);\r\nif (err)\r\nreturn err;\r\n}\r\nerr = qp_res_start_move_to(dev, slave, qpn, RES_QP_MAPPED,\r\nNULL, 1);\r\nif (err)\r\nreturn err;\r\nif (!fw_reserved(dev, qpn)) {\r\nerr = __mlx4_qp_alloc_icm(dev, qpn, GFP_KERNEL);\r\nif (err) {\r\nres_abort_move(dev, slave, RES_QP, qpn);\r\nreturn err;\r\n}\r\n}\r\nres_end_move(dev, slave, RES_QP, qpn);\r\nbreak;\r\ndefault:\r\nerr = -EINVAL;\r\nbreak;\r\n}\r\nreturn err;\r\n}\r\nstatic int mtt_alloc_res(struct mlx4_dev *dev, int slave, int op, int cmd,\r\nu64 in_param, u64 *out_param)\r\n{\r\nint err = -EINVAL;\r\nint base;\r\nint order;\r\nif (op != RES_OP_RESERVE_AND_MAP)\r\nreturn err;\r\norder = get_param_l(&in_param);\r\nerr = mlx4_grant_resource(dev, slave, RES_MTT, 1 << order, 0);\r\nif (err)\r\nreturn err;\r\nbase = __mlx4_alloc_mtt_range(dev, order);\r\nif (base == -1) {\r\nmlx4_release_resource(dev, slave, RES_MTT, 1 << order, 0);\r\nreturn -ENOMEM;\r\n}\r\nerr = add_res_range(dev, slave, base, 1, RES_MTT, order);\r\nif (err) {\r\nmlx4_release_resource(dev, slave, RES_MTT, 1 << order, 0);\r\n__mlx4_free_mtt_range(dev, base, order);\r\n} else {\r\nset_param_l(out_param, base);\r\n}\r\nreturn err;\r\n}\r\nstatic int mpt_alloc_res(struct mlx4_dev *dev, int slave, int op, int cmd,\r\nu64 in_param, u64 *out_param)\r\n{\r\nint err = -EINVAL;\r\nint index;\r\nint id;\r\nstruct res_mpt *mpt;\r\nswitch (op) {\r\ncase RES_OP_RESERVE:\r\nerr = mlx4_grant_resource(dev, slave, RES_MPT, 1, 0);\r\nif (err)\r\nbreak;\r\nindex = __mlx4_mpt_reserve(dev);\r\nif (index == -1) {\r\nmlx4_release_resource(dev, slave, RES_MPT, 1, 0);\r\nbreak;\r\n}\r\nid = index & mpt_mask(dev);\r\nerr = add_res_range(dev, slave, id, 1, RES_MPT, index);\r\nif (err) {\r\nmlx4_release_resource(dev, slave, RES_MPT, 1, 0);\r\n__mlx4_mpt_release(dev, index);\r\nbreak;\r\n}\r\nset_param_l(out_param, index);\r\nbreak;\r\ncase RES_OP_MAP_ICM:\r\nindex = get_param_l(&in_param);\r\nid = index & mpt_mask(dev);\r\nerr = mr_res_start_move_to(dev, slave, id,\r\nRES_MPT_MAPPED, &mpt);\r\nif (err)\r\nreturn err;\r\nerr = __mlx4_mpt_alloc_icm(dev, mpt->key, GFP_KERNEL);\r\nif (err) {\r\nres_abort_move(dev, slave, RES_MPT, id);\r\nreturn err;\r\n}\r\nres_end_move(dev, slave, RES_MPT, id);\r\nbreak;\r\n}\r\nreturn err;\r\n}\r\nstatic int cq_alloc_res(struct mlx4_dev *dev, int slave, int op, int cmd,\r\nu64 in_param, u64 *out_param)\r\n{\r\nint cqn;\r\nint err;\r\nswitch (op) {\r\ncase RES_OP_RESERVE_AND_MAP:\r\nerr = mlx4_grant_resource(dev, slave, RES_CQ, 1, 0);\r\nif (err)\r\nbreak;\r\nerr = __mlx4_cq_alloc_icm(dev, &cqn);\r\nif (err) {\r\nmlx4_release_resource(dev, slave, RES_CQ, 1, 0);\r\nbreak;\r\n}\r\nerr = add_res_range(dev, slave, cqn, 1, RES_CQ, 0);\r\nif (err) {\r\nmlx4_release_resource(dev, slave, RES_CQ, 1, 0);\r\n__mlx4_cq_free_icm(dev, cqn);\r\nbreak;\r\n}\r\nset_param_l(out_param, cqn);\r\nbreak;\r\ndefault:\r\nerr = -EINVAL;\r\n}\r\nreturn err;\r\n}\r\nstatic int srq_alloc_res(struct mlx4_dev *dev, int slave, int op, int cmd,\r\nu64 in_param, u64 *out_param)\r\n{\r\nint srqn;\r\nint err;\r\nswitch (op) {\r\ncase RES_OP_RESERVE_AND_MAP:\r\nerr = mlx4_grant_resource(dev, slave, RES_SRQ, 1, 0);\r\nif (err)\r\nbreak;\r\nerr = __mlx4_srq_alloc_icm(dev, &srqn);\r\nif (err) {\r\nmlx4_release_resource(dev, slave, RES_SRQ, 1, 0);\r\nbreak;\r\n}\r\nerr = add_res_range(dev, slave, srqn, 1, RES_SRQ, 0);\r\nif (err) {\r\nmlx4_release_resource(dev, slave, RES_SRQ, 1, 0);\r\n__mlx4_srq_free_icm(dev, srqn);\r\nbreak;\r\n}\r\nset_param_l(out_param, srqn);\r\nbreak;\r\ndefault:\r\nerr = -EINVAL;\r\n}\r\nreturn err;\r\n}\r\nstatic int mac_find_smac_ix_in_slave(struct mlx4_dev *dev, int slave, int port,\r\nu8 smac_index, u64 *mac)\r\n{\r\nstruct mlx4_priv *priv = mlx4_priv(dev);\r\nstruct mlx4_resource_tracker *tracker = &priv->mfunc.master.res_tracker;\r\nstruct list_head *mac_list =\r\n&tracker->slave_list[slave].res_list[RES_MAC];\r\nstruct mac_res *res, *tmp;\r\nlist_for_each_entry_safe(res, tmp, mac_list, list) {\r\nif (res->smac_index == smac_index && res->port == (u8) port) {\r\n*mac = res->mac;\r\nreturn 0;\r\n}\r\n}\r\nreturn -ENOENT;\r\n}\r\nstatic int mac_add_to_slave(struct mlx4_dev *dev, int slave, u64 mac, int port, u8 smac_index)\r\n{\r\nstruct mlx4_priv *priv = mlx4_priv(dev);\r\nstruct mlx4_resource_tracker *tracker = &priv->mfunc.master.res_tracker;\r\nstruct list_head *mac_list =\r\n&tracker->slave_list[slave].res_list[RES_MAC];\r\nstruct mac_res *res, *tmp;\r\nlist_for_each_entry_safe(res, tmp, mac_list, list) {\r\nif (res->mac == mac && res->port == (u8) port) {\r\n++res->ref_count;\r\nreturn 0;\r\n}\r\n}\r\nif (mlx4_grant_resource(dev, slave, RES_MAC, 1, port))\r\nreturn -EINVAL;\r\nres = kzalloc(sizeof *res, GFP_KERNEL);\r\nif (!res) {\r\nmlx4_release_resource(dev, slave, RES_MAC, 1, port);\r\nreturn -ENOMEM;\r\n}\r\nres->mac = mac;\r\nres->port = (u8) port;\r\nres->smac_index = smac_index;\r\nres->ref_count = 1;\r\nlist_add_tail(&res->list,\r\n&tracker->slave_list[slave].res_list[RES_MAC]);\r\nreturn 0;\r\n}\r\nstatic void mac_del_from_slave(struct mlx4_dev *dev, int slave, u64 mac,\r\nint port)\r\n{\r\nstruct mlx4_priv *priv = mlx4_priv(dev);\r\nstruct mlx4_resource_tracker *tracker = &priv->mfunc.master.res_tracker;\r\nstruct list_head *mac_list =\r\n&tracker->slave_list[slave].res_list[RES_MAC];\r\nstruct mac_res *res, *tmp;\r\nlist_for_each_entry_safe(res, tmp, mac_list, list) {\r\nif (res->mac == mac && res->port == (u8) port) {\r\nif (!--res->ref_count) {\r\nlist_del(&res->list);\r\nmlx4_release_resource(dev, slave, RES_MAC, 1, port);\r\nkfree(res);\r\n}\r\nbreak;\r\n}\r\n}\r\n}\r\nstatic void rem_slave_macs(struct mlx4_dev *dev, int slave)\r\n{\r\nstruct mlx4_priv *priv = mlx4_priv(dev);\r\nstruct mlx4_resource_tracker *tracker = &priv->mfunc.master.res_tracker;\r\nstruct list_head *mac_list =\r\n&tracker->slave_list[slave].res_list[RES_MAC];\r\nstruct mac_res *res, *tmp;\r\nint i;\r\nlist_for_each_entry_safe(res, tmp, mac_list, list) {\r\nlist_del(&res->list);\r\nfor (i = 0; i < res->ref_count; i++)\r\n__mlx4_unregister_mac(dev, res->port, res->mac);\r\nmlx4_release_resource(dev, slave, RES_MAC, 1, res->port);\r\nkfree(res);\r\n}\r\n}\r\nstatic int mac_alloc_res(struct mlx4_dev *dev, int slave, int op, int cmd,\r\nu64 in_param, u64 *out_param, int in_port)\r\n{\r\nint err = -EINVAL;\r\nint port;\r\nu64 mac;\r\nu8 smac_index;\r\nif (op != RES_OP_RESERVE_AND_MAP)\r\nreturn err;\r\nport = !in_port ? get_param_l(out_param) : in_port;\r\nport = mlx4_slave_convert_port(\r\ndev, slave, port);\r\nif (port < 0)\r\nreturn -EINVAL;\r\nmac = in_param;\r\nerr = __mlx4_register_mac(dev, port, mac);\r\nif (err >= 0) {\r\nsmac_index = err;\r\nset_param_l(out_param, err);\r\nerr = 0;\r\n}\r\nif (!err) {\r\nerr = mac_add_to_slave(dev, slave, mac, port, smac_index);\r\nif (err)\r\n__mlx4_unregister_mac(dev, port, mac);\r\n}\r\nreturn err;\r\n}\r\nstatic int vlan_add_to_slave(struct mlx4_dev *dev, int slave, u16 vlan,\r\nint port, int vlan_index)\r\n{\r\nstruct mlx4_priv *priv = mlx4_priv(dev);\r\nstruct mlx4_resource_tracker *tracker = &priv->mfunc.master.res_tracker;\r\nstruct list_head *vlan_list =\r\n&tracker->slave_list[slave].res_list[RES_VLAN];\r\nstruct vlan_res *res, *tmp;\r\nlist_for_each_entry_safe(res, tmp, vlan_list, list) {\r\nif (res->vlan == vlan && res->port == (u8) port) {\r\n++res->ref_count;\r\nreturn 0;\r\n}\r\n}\r\nif (mlx4_grant_resource(dev, slave, RES_VLAN, 1, port))\r\nreturn -EINVAL;\r\nres = kzalloc(sizeof(*res), GFP_KERNEL);\r\nif (!res) {\r\nmlx4_release_resource(dev, slave, RES_VLAN, 1, port);\r\nreturn -ENOMEM;\r\n}\r\nres->vlan = vlan;\r\nres->port = (u8) port;\r\nres->vlan_index = vlan_index;\r\nres->ref_count = 1;\r\nlist_add_tail(&res->list,\r\n&tracker->slave_list[slave].res_list[RES_VLAN]);\r\nreturn 0;\r\n}\r\nstatic void vlan_del_from_slave(struct mlx4_dev *dev, int slave, u16 vlan,\r\nint port)\r\n{\r\nstruct mlx4_priv *priv = mlx4_priv(dev);\r\nstruct mlx4_resource_tracker *tracker = &priv->mfunc.master.res_tracker;\r\nstruct list_head *vlan_list =\r\n&tracker->slave_list[slave].res_list[RES_VLAN];\r\nstruct vlan_res *res, *tmp;\r\nlist_for_each_entry_safe(res, tmp, vlan_list, list) {\r\nif (res->vlan == vlan && res->port == (u8) port) {\r\nif (!--res->ref_count) {\r\nlist_del(&res->list);\r\nmlx4_release_resource(dev, slave, RES_VLAN,\r\n1, port);\r\nkfree(res);\r\n}\r\nbreak;\r\n}\r\n}\r\n}\r\nstatic void rem_slave_vlans(struct mlx4_dev *dev, int slave)\r\n{\r\nstruct mlx4_priv *priv = mlx4_priv(dev);\r\nstruct mlx4_resource_tracker *tracker = &priv->mfunc.master.res_tracker;\r\nstruct list_head *vlan_list =\r\n&tracker->slave_list[slave].res_list[RES_VLAN];\r\nstruct vlan_res *res, *tmp;\r\nint i;\r\nlist_for_each_entry_safe(res, tmp, vlan_list, list) {\r\nlist_del(&res->list);\r\nfor (i = 0; i < res->ref_count; i++)\r\n__mlx4_unregister_vlan(dev, res->port, res->vlan);\r\nmlx4_release_resource(dev, slave, RES_VLAN, 1, res->port);\r\nkfree(res);\r\n}\r\n}\r\nstatic int vlan_alloc_res(struct mlx4_dev *dev, int slave, int op, int cmd,\r\nu64 in_param, u64 *out_param, int in_port)\r\n{\r\nstruct mlx4_priv *priv = mlx4_priv(dev);\r\nstruct mlx4_slave_state *slave_state = priv->mfunc.master.slave_state;\r\nint err;\r\nu16 vlan;\r\nint vlan_index;\r\nint port;\r\nport = !in_port ? get_param_l(out_param) : in_port;\r\nif (!port || op != RES_OP_RESERVE_AND_MAP)\r\nreturn -EINVAL;\r\nport = mlx4_slave_convert_port(\r\ndev, slave, port);\r\nif (port < 0)\r\nreturn -EINVAL;\r\nif (!in_port && port > 0 && port <= dev->caps.num_ports) {\r\nslave_state[slave].old_vlan_api = true;\r\nreturn 0;\r\n}\r\nvlan = (u16) in_param;\r\nerr = __mlx4_register_vlan(dev, port, vlan, &vlan_index);\r\nif (!err) {\r\nset_param_l(out_param, (u32) vlan_index);\r\nerr = vlan_add_to_slave(dev, slave, vlan, port, vlan_index);\r\nif (err)\r\n__mlx4_unregister_vlan(dev, port, vlan);\r\n}\r\nreturn err;\r\n}\r\nstatic int counter_alloc_res(struct mlx4_dev *dev, int slave, int op, int cmd,\r\nu64 in_param, u64 *out_param, int port)\r\n{\r\nu32 index;\r\nint err;\r\nif (op != RES_OP_RESERVE)\r\nreturn -EINVAL;\r\nerr = mlx4_grant_resource(dev, slave, RES_COUNTER, 1, 0);\r\nif (err)\r\nreturn err;\r\nerr = __mlx4_counter_alloc(dev, &index);\r\nif (err) {\r\nmlx4_release_resource(dev, slave, RES_COUNTER, 1, 0);\r\nreturn err;\r\n}\r\nerr = add_res_range(dev, slave, index, 1, RES_COUNTER, port);\r\nif (err) {\r\n__mlx4_counter_free(dev, index);\r\nmlx4_release_resource(dev, slave, RES_COUNTER, 1, 0);\r\n} else {\r\nset_param_l(out_param, index);\r\n}\r\nreturn err;\r\n}\r\nstatic int xrcdn_alloc_res(struct mlx4_dev *dev, int slave, int op, int cmd,\r\nu64 in_param, u64 *out_param)\r\n{\r\nu32 xrcdn;\r\nint err;\r\nif (op != RES_OP_RESERVE)\r\nreturn -EINVAL;\r\nerr = __mlx4_xrcd_alloc(dev, &xrcdn);\r\nif (err)\r\nreturn err;\r\nerr = add_res_range(dev, slave, xrcdn, 1, RES_XRCD, 0);\r\nif (err)\r\n__mlx4_xrcd_free(dev, xrcdn);\r\nelse\r\nset_param_l(out_param, xrcdn);\r\nreturn err;\r\n}\r\nint mlx4_ALLOC_RES_wrapper(struct mlx4_dev *dev, int slave,\r\nstruct mlx4_vhcr *vhcr,\r\nstruct mlx4_cmd_mailbox *inbox,\r\nstruct mlx4_cmd_mailbox *outbox,\r\nstruct mlx4_cmd_info *cmd)\r\n{\r\nint err;\r\nint alop = vhcr->op_modifier;\r\nswitch (vhcr->in_modifier & 0xFF) {\r\ncase RES_QP:\r\nerr = qp_alloc_res(dev, slave, vhcr->op_modifier, alop,\r\nvhcr->in_param, &vhcr->out_param);\r\nbreak;\r\ncase RES_MTT:\r\nerr = mtt_alloc_res(dev, slave, vhcr->op_modifier, alop,\r\nvhcr->in_param, &vhcr->out_param);\r\nbreak;\r\ncase RES_MPT:\r\nerr = mpt_alloc_res(dev, slave, vhcr->op_modifier, alop,\r\nvhcr->in_param, &vhcr->out_param);\r\nbreak;\r\ncase RES_CQ:\r\nerr = cq_alloc_res(dev, slave, vhcr->op_modifier, alop,\r\nvhcr->in_param, &vhcr->out_param);\r\nbreak;\r\ncase RES_SRQ:\r\nerr = srq_alloc_res(dev, slave, vhcr->op_modifier, alop,\r\nvhcr->in_param, &vhcr->out_param);\r\nbreak;\r\ncase RES_MAC:\r\nerr = mac_alloc_res(dev, slave, vhcr->op_modifier, alop,\r\nvhcr->in_param, &vhcr->out_param,\r\n(vhcr->in_modifier >> 8) & 0xFF);\r\nbreak;\r\ncase RES_VLAN:\r\nerr = vlan_alloc_res(dev, slave, vhcr->op_modifier, alop,\r\nvhcr->in_param, &vhcr->out_param,\r\n(vhcr->in_modifier >> 8) & 0xFF);\r\nbreak;\r\ncase RES_COUNTER:\r\nerr = counter_alloc_res(dev, slave, vhcr->op_modifier, alop,\r\nvhcr->in_param, &vhcr->out_param, 0);\r\nbreak;\r\ncase RES_XRCD:\r\nerr = xrcdn_alloc_res(dev, slave, vhcr->op_modifier, alop,\r\nvhcr->in_param, &vhcr->out_param);\r\nbreak;\r\ndefault:\r\nerr = -EINVAL;\r\nbreak;\r\n}\r\nreturn err;\r\n}\r\nstatic int qp_free_res(struct mlx4_dev *dev, int slave, int op, int cmd,\r\nu64 in_param)\r\n{\r\nint err;\r\nint count;\r\nint base;\r\nint qpn;\r\nswitch (op) {\r\ncase RES_OP_RESERVE:\r\nbase = get_param_l(&in_param) & 0x7fffff;\r\ncount = get_param_h(&in_param);\r\nerr = rem_res_range(dev, slave, base, count, RES_QP, 0);\r\nif (err)\r\nbreak;\r\nmlx4_release_resource(dev, slave, RES_QP, count, 0);\r\n__mlx4_qp_release_range(dev, base, count);\r\nbreak;\r\ncase RES_OP_MAP_ICM:\r\nqpn = get_param_l(&in_param) & 0x7fffff;\r\nerr = qp_res_start_move_to(dev, slave, qpn, RES_QP_RESERVED,\r\nNULL, 0);\r\nif (err)\r\nreturn err;\r\nif (!fw_reserved(dev, qpn))\r\n__mlx4_qp_free_icm(dev, qpn);\r\nres_end_move(dev, slave, RES_QP, qpn);\r\nif (valid_reserved(dev, slave, qpn))\r\nerr = rem_res_range(dev, slave, qpn, 1, RES_QP, 0);\r\nbreak;\r\ndefault:\r\nerr = -EINVAL;\r\nbreak;\r\n}\r\nreturn err;\r\n}\r\nstatic int mtt_free_res(struct mlx4_dev *dev, int slave, int op, int cmd,\r\nu64 in_param, u64 *out_param)\r\n{\r\nint err = -EINVAL;\r\nint base;\r\nint order;\r\nif (op != RES_OP_RESERVE_AND_MAP)\r\nreturn err;\r\nbase = get_param_l(&in_param);\r\norder = get_param_h(&in_param);\r\nerr = rem_res_range(dev, slave, base, 1, RES_MTT, order);\r\nif (!err) {\r\nmlx4_release_resource(dev, slave, RES_MTT, 1 << order, 0);\r\n__mlx4_free_mtt_range(dev, base, order);\r\n}\r\nreturn err;\r\n}\r\nstatic int mpt_free_res(struct mlx4_dev *dev, int slave, int op, int cmd,\r\nu64 in_param)\r\n{\r\nint err = -EINVAL;\r\nint index;\r\nint id;\r\nstruct res_mpt *mpt;\r\nswitch (op) {\r\ncase RES_OP_RESERVE:\r\nindex = get_param_l(&in_param);\r\nid = index & mpt_mask(dev);\r\nerr = get_res(dev, slave, id, RES_MPT, &mpt);\r\nif (err)\r\nbreak;\r\nindex = mpt->key;\r\nput_res(dev, slave, id, RES_MPT);\r\nerr = rem_res_range(dev, slave, id, 1, RES_MPT, 0);\r\nif (err)\r\nbreak;\r\nmlx4_release_resource(dev, slave, RES_MPT, 1, 0);\r\n__mlx4_mpt_release(dev, index);\r\nbreak;\r\ncase RES_OP_MAP_ICM:\r\nindex = get_param_l(&in_param);\r\nid = index & mpt_mask(dev);\r\nerr = mr_res_start_move_to(dev, slave, id,\r\nRES_MPT_RESERVED, &mpt);\r\nif (err)\r\nreturn err;\r\n__mlx4_mpt_free_icm(dev, mpt->key);\r\nres_end_move(dev, slave, RES_MPT, id);\r\nreturn err;\r\nbreak;\r\ndefault:\r\nerr = -EINVAL;\r\nbreak;\r\n}\r\nreturn err;\r\n}\r\nstatic int cq_free_res(struct mlx4_dev *dev, int slave, int op, int cmd,\r\nu64 in_param, u64 *out_param)\r\n{\r\nint cqn;\r\nint err;\r\nswitch (op) {\r\ncase RES_OP_RESERVE_AND_MAP:\r\ncqn = get_param_l(&in_param);\r\nerr = rem_res_range(dev, slave, cqn, 1, RES_CQ, 0);\r\nif (err)\r\nbreak;\r\nmlx4_release_resource(dev, slave, RES_CQ, 1, 0);\r\n__mlx4_cq_free_icm(dev, cqn);\r\nbreak;\r\ndefault:\r\nerr = -EINVAL;\r\nbreak;\r\n}\r\nreturn err;\r\n}\r\nstatic int srq_free_res(struct mlx4_dev *dev, int slave, int op, int cmd,\r\nu64 in_param, u64 *out_param)\r\n{\r\nint srqn;\r\nint err;\r\nswitch (op) {\r\ncase RES_OP_RESERVE_AND_MAP:\r\nsrqn = get_param_l(&in_param);\r\nerr = rem_res_range(dev, slave, srqn, 1, RES_SRQ, 0);\r\nif (err)\r\nbreak;\r\nmlx4_release_resource(dev, slave, RES_SRQ, 1, 0);\r\n__mlx4_srq_free_icm(dev, srqn);\r\nbreak;\r\ndefault:\r\nerr = -EINVAL;\r\nbreak;\r\n}\r\nreturn err;\r\n}\r\nstatic int mac_free_res(struct mlx4_dev *dev, int slave, int op, int cmd,\r\nu64 in_param, u64 *out_param, int in_port)\r\n{\r\nint port;\r\nint err = 0;\r\nswitch (op) {\r\ncase RES_OP_RESERVE_AND_MAP:\r\nport = !in_port ? get_param_l(out_param) : in_port;\r\nport = mlx4_slave_convert_port(\r\ndev, slave, port);\r\nif (port < 0)\r\nreturn -EINVAL;\r\nmac_del_from_slave(dev, slave, in_param, port);\r\n__mlx4_unregister_mac(dev, port, in_param);\r\nbreak;\r\ndefault:\r\nerr = -EINVAL;\r\nbreak;\r\n}\r\nreturn err;\r\n}\r\nstatic int vlan_free_res(struct mlx4_dev *dev, int slave, int op, int cmd,\r\nu64 in_param, u64 *out_param, int port)\r\n{\r\nstruct mlx4_priv *priv = mlx4_priv(dev);\r\nstruct mlx4_slave_state *slave_state = priv->mfunc.master.slave_state;\r\nint err = 0;\r\nport = mlx4_slave_convert_port(\r\ndev, slave, port);\r\nif (port < 0)\r\nreturn -EINVAL;\r\nswitch (op) {\r\ncase RES_OP_RESERVE_AND_MAP:\r\nif (slave_state[slave].old_vlan_api)\r\nreturn 0;\r\nif (!port)\r\nreturn -EINVAL;\r\nvlan_del_from_slave(dev, slave, in_param, port);\r\n__mlx4_unregister_vlan(dev, port, in_param);\r\nbreak;\r\ndefault:\r\nerr = -EINVAL;\r\nbreak;\r\n}\r\nreturn err;\r\n}\r\nstatic int counter_free_res(struct mlx4_dev *dev, int slave, int op, int cmd,\r\nu64 in_param, u64 *out_param)\r\n{\r\nint index;\r\nint err;\r\nif (op != RES_OP_RESERVE)\r\nreturn -EINVAL;\r\nindex = get_param_l(&in_param);\r\nif (index == MLX4_SINK_COUNTER_INDEX(dev))\r\nreturn 0;\r\nerr = rem_res_range(dev, slave, index, 1, RES_COUNTER, 0);\r\nif (err)\r\nreturn err;\r\n__mlx4_counter_free(dev, index);\r\nmlx4_release_resource(dev, slave, RES_COUNTER, 1, 0);\r\nreturn err;\r\n}\r\nstatic int xrcdn_free_res(struct mlx4_dev *dev, int slave, int op, int cmd,\r\nu64 in_param, u64 *out_param)\r\n{\r\nint xrcdn;\r\nint err;\r\nif (op != RES_OP_RESERVE)\r\nreturn -EINVAL;\r\nxrcdn = get_param_l(&in_param);\r\nerr = rem_res_range(dev, slave, xrcdn, 1, RES_XRCD, 0);\r\nif (err)\r\nreturn err;\r\n__mlx4_xrcd_free(dev, xrcdn);\r\nreturn err;\r\n}\r\nint mlx4_FREE_RES_wrapper(struct mlx4_dev *dev, int slave,\r\nstruct mlx4_vhcr *vhcr,\r\nstruct mlx4_cmd_mailbox *inbox,\r\nstruct mlx4_cmd_mailbox *outbox,\r\nstruct mlx4_cmd_info *cmd)\r\n{\r\nint err = -EINVAL;\r\nint alop = vhcr->op_modifier;\r\nswitch (vhcr->in_modifier & 0xFF) {\r\ncase RES_QP:\r\nerr = qp_free_res(dev, slave, vhcr->op_modifier, alop,\r\nvhcr->in_param);\r\nbreak;\r\ncase RES_MTT:\r\nerr = mtt_free_res(dev, slave, vhcr->op_modifier, alop,\r\nvhcr->in_param, &vhcr->out_param);\r\nbreak;\r\ncase RES_MPT:\r\nerr = mpt_free_res(dev, slave, vhcr->op_modifier, alop,\r\nvhcr->in_param);\r\nbreak;\r\ncase RES_CQ:\r\nerr = cq_free_res(dev, slave, vhcr->op_modifier, alop,\r\nvhcr->in_param, &vhcr->out_param);\r\nbreak;\r\ncase RES_SRQ:\r\nerr = srq_free_res(dev, slave, vhcr->op_modifier, alop,\r\nvhcr->in_param, &vhcr->out_param);\r\nbreak;\r\ncase RES_MAC:\r\nerr = mac_free_res(dev, slave, vhcr->op_modifier, alop,\r\nvhcr->in_param, &vhcr->out_param,\r\n(vhcr->in_modifier >> 8) & 0xFF);\r\nbreak;\r\ncase RES_VLAN:\r\nerr = vlan_free_res(dev, slave, vhcr->op_modifier, alop,\r\nvhcr->in_param, &vhcr->out_param,\r\n(vhcr->in_modifier >> 8) & 0xFF);\r\nbreak;\r\ncase RES_COUNTER:\r\nerr = counter_free_res(dev, slave, vhcr->op_modifier, alop,\r\nvhcr->in_param, &vhcr->out_param);\r\nbreak;\r\ncase RES_XRCD:\r\nerr = xrcdn_free_res(dev, slave, vhcr->op_modifier, alop,\r\nvhcr->in_param, &vhcr->out_param);\r\ndefault:\r\nbreak;\r\n}\r\nreturn err;\r\n}\r\nstatic int mr_phys_mpt(struct mlx4_mpt_entry *mpt)\r\n{\r\nreturn (be32_to_cpu(mpt->flags) >> 9) & 1;\r\n}\r\nstatic int mr_get_mtt_addr(struct mlx4_mpt_entry *mpt)\r\n{\r\nreturn (int)be64_to_cpu(mpt->mtt_addr) & 0xfffffff8;\r\n}\r\nstatic int mr_get_mtt_size(struct mlx4_mpt_entry *mpt)\r\n{\r\nreturn be32_to_cpu(mpt->mtt_sz);\r\n}\r\nstatic u32 mr_get_pd(struct mlx4_mpt_entry *mpt)\r\n{\r\nreturn be32_to_cpu(mpt->pd_flags) & 0x00ffffff;\r\n}\r\nstatic int mr_is_fmr(struct mlx4_mpt_entry *mpt)\r\n{\r\nreturn be32_to_cpu(mpt->pd_flags) & MLX4_MPT_PD_FLAG_FAST_REG;\r\n}\r\nstatic int mr_is_bind_enabled(struct mlx4_mpt_entry *mpt)\r\n{\r\nreturn be32_to_cpu(mpt->flags) & MLX4_MPT_FLAG_BIND_ENABLE;\r\n}\r\nstatic int mr_is_region(struct mlx4_mpt_entry *mpt)\r\n{\r\nreturn be32_to_cpu(mpt->flags) & MLX4_MPT_FLAG_REGION;\r\n}\r\nstatic int qp_get_mtt_addr(struct mlx4_qp_context *qpc)\r\n{\r\nreturn be32_to_cpu(qpc->mtt_base_addr_l) & 0xfffffff8;\r\n}\r\nstatic int srq_get_mtt_addr(struct mlx4_srq_context *srqc)\r\n{\r\nreturn be32_to_cpu(srqc->mtt_base_addr_l) & 0xfffffff8;\r\n}\r\nstatic int qp_get_mtt_size(struct mlx4_qp_context *qpc)\r\n{\r\nint page_shift = (qpc->log_page_size & 0x3f) + 12;\r\nint log_sq_size = (qpc->sq_size_stride >> 3) & 0xf;\r\nint log_sq_sride = qpc->sq_size_stride & 7;\r\nint log_rq_size = (qpc->rq_size_stride >> 3) & 0xf;\r\nint log_rq_stride = qpc->rq_size_stride & 7;\r\nint srq = (be32_to_cpu(qpc->srqn) >> 24) & 1;\r\nint rss = (be32_to_cpu(qpc->flags) >> 13) & 1;\r\nu32 ts = (be32_to_cpu(qpc->flags) >> 16) & 0xff;\r\nint xrc = (ts == MLX4_QP_ST_XRC) ? 1 : 0;\r\nint sq_size;\r\nint rq_size;\r\nint total_pages;\r\nint total_mem;\r\nint page_offset = (be32_to_cpu(qpc->params2) >> 6) & 0x3f;\r\nsq_size = 1 << (log_sq_size + log_sq_sride + 4);\r\nrq_size = (srq|rss|xrc) ? 0 : (1 << (log_rq_size + log_rq_stride + 4));\r\ntotal_mem = sq_size + rq_size;\r\ntotal_pages =\r\nroundup_pow_of_two((total_mem + (page_offset << 6)) >>\r\npage_shift);\r\nreturn total_pages;\r\n}\r\nstatic int check_mtt_range(struct mlx4_dev *dev, int slave, int start,\r\nint size, struct res_mtt *mtt)\r\n{\r\nint res_start = mtt->com.res_id;\r\nint res_size = (1 << mtt->order);\r\nif (start < res_start || start + size > res_start + res_size)\r\nreturn -EPERM;\r\nreturn 0;\r\n}\r\nint mlx4_SW2HW_MPT_wrapper(struct mlx4_dev *dev, int slave,\r\nstruct mlx4_vhcr *vhcr,\r\nstruct mlx4_cmd_mailbox *inbox,\r\nstruct mlx4_cmd_mailbox *outbox,\r\nstruct mlx4_cmd_info *cmd)\r\n{\r\nint err;\r\nint index = vhcr->in_modifier;\r\nstruct res_mtt *mtt;\r\nstruct res_mpt *mpt;\r\nint mtt_base = mr_get_mtt_addr(inbox->buf) / dev->caps.mtt_entry_sz;\r\nint phys;\r\nint id;\r\nu32 pd;\r\nint pd_slave;\r\nid = index & mpt_mask(dev);\r\nerr = mr_res_start_move_to(dev, slave, id, RES_MPT_HW, &mpt);\r\nif (err)\r\nreturn err;\r\nif (!mr_is_region(inbox->buf)) {\r\nerr = -EPERM;\r\ngoto ex_abort;\r\n}\r\npd = mr_get_pd(inbox->buf);\r\npd_slave = (pd >> 17) & 0x7f;\r\nif (pd_slave != 0 && --pd_slave != slave) {\r\nerr = -EPERM;\r\ngoto ex_abort;\r\n}\r\nif (mr_is_fmr(inbox->buf)) {\r\nif (mr_is_bind_enabled(inbox->buf)) {\r\nerr = -EPERM;\r\ngoto ex_abort;\r\n}\r\nif (!mr_is_region(inbox->buf)) {\r\nerr = -EPERM;\r\ngoto ex_abort;\r\n}\r\n}\r\nphys = mr_phys_mpt(inbox->buf);\r\nif (!phys) {\r\nerr = get_res(dev, slave, mtt_base, RES_MTT, &mtt);\r\nif (err)\r\ngoto ex_abort;\r\nerr = check_mtt_range(dev, slave, mtt_base,\r\nmr_get_mtt_size(inbox->buf), mtt);\r\nif (err)\r\ngoto ex_put;\r\nmpt->mtt = mtt;\r\n}\r\nerr = mlx4_DMA_wrapper(dev, slave, vhcr, inbox, outbox, cmd);\r\nif (err)\r\ngoto ex_put;\r\nif (!phys) {\r\natomic_inc(&mtt->ref_count);\r\nput_res(dev, slave, mtt->com.res_id, RES_MTT);\r\n}\r\nres_end_move(dev, slave, RES_MPT, id);\r\nreturn 0;\r\nex_put:\r\nif (!phys)\r\nput_res(dev, slave, mtt->com.res_id, RES_MTT);\r\nex_abort:\r\nres_abort_move(dev, slave, RES_MPT, id);\r\nreturn err;\r\n}\r\nint mlx4_HW2SW_MPT_wrapper(struct mlx4_dev *dev, int slave,\r\nstruct mlx4_vhcr *vhcr,\r\nstruct mlx4_cmd_mailbox *inbox,\r\nstruct mlx4_cmd_mailbox *outbox,\r\nstruct mlx4_cmd_info *cmd)\r\n{\r\nint err;\r\nint index = vhcr->in_modifier;\r\nstruct res_mpt *mpt;\r\nint id;\r\nid = index & mpt_mask(dev);\r\nerr = mr_res_start_move_to(dev, slave, id, RES_MPT_MAPPED, &mpt);\r\nif (err)\r\nreturn err;\r\nerr = mlx4_DMA_wrapper(dev, slave, vhcr, inbox, outbox, cmd);\r\nif (err)\r\ngoto ex_abort;\r\nif (mpt->mtt)\r\natomic_dec(&mpt->mtt->ref_count);\r\nres_end_move(dev, slave, RES_MPT, id);\r\nreturn 0;\r\nex_abort:\r\nres_abort_move(dev, slave, RES_MPT, id);\r\nreturn err;\r\n}\r\nint mlx4_QUERY_MPT_wrapper(struct mlx4_dev *dev, int slave,\r\nstruct mlx4_vhcr *vhcr,\r\nstruct mlx4_cmd_mailbox *inbox,\r\nstruct mlx4_cmd_mailbox *outbox,\r\nstruct mlx4_cmd_info *cmd)\r\n{\r\nint err;\r\nint index = vhcr->in_modifier;\r\nstruct res_mpt *mpt;\r\nint id;\r\nid = index & mpt_mask(dev);\r\nerr = get_res(dev, slave, id, RES_MPT, &mpt);\r\nif (err)\r\nreturn err;\r\nif (mpt->com.from_state == RES_MPT_MAPPED) {\r\nstruct mlx4_mpt_entry *mpt_entry = mlx4_table_find(\r\n&mlx4_priv(dev)->mr_table.dmpt_table,\r\nmpt->key, NULL);\r\nif (NULL == mpt_entry || NULL == outbox->buf) {\r\nerr = -EINVAL;\r\ngoto out;\r\n}\r\nmemcpy(outbox->buf, mpt_entry, sizeof(*mpt_entry));\r\nerr = 0;\r\n} else if (mpt->com.from_state == RES_MPT_HW) {\r\nerr = mlx4_DMA_wrapper(dev, slave, vhcr, inbox, outbox, cmd);\r\n} else {\r\nerr = -EBUSY;\r\ngoto out;\r\n}\r\nout:\r\nput_res(dev, slave, id, RES_MPT);\r\nreturn err;\r\n}\r\nstatic int qp_get_rcqn(struct mlx4_qp_context *qpc)\r\n{\r\nreturn be32_to_cpu(qpc->cqn_recv) & 0xffffff;\r\n}\r\nstatic int qp_get_scqn(struct mlx4_qp_context *qpc)\r\n{\r\nreturn be32_to_cpu(qpc->cqn_send) & 0xffffff;\r\n}\r\nstatic u32 qp_get_srqn(struct mlx4_qp_context *qpc)\r\n{\r\nreturn be32_to_cpu(qpc->srqn) & 0x1ffffff;\r\n}\r\nstatic void adjust_proxy_tun_qkey(struct mlx4_dev *dev, struct mlx4_vhcr *vhcr,\r\nstruct mlx4_qp_context *context)\r\n{\r\nu32 qpn = vhcr->in_modifier & 0xffffff;\r\nu32 qkey = 0;\r\nif (mlx4_get_parav_qkey(dev, qpn, &qkey))\r\nreturn;\r\ncontext->qkey = cpu_to_be32(qkey);\r\n}\r\nint mlx4_RST2INIT_QP_wrapper(struct mlx4_dev *dev, int slave,\r\nstruct mlx4_vhcr *vhcr,\r\nstruct mlx4_cmd_mailbox *inbox,\r\nstruct mlx4_cmd_mailbox *outbox,\r\nstruct mlx4_cmd_info *cmd)\r\n{\r\nint err;\r\nint qpn = vhcr->in_modifier & 0x7fffff;\r\nstruct res_mtt *mtt;\r\nstruct res_qp *qp;\r\nstruct mlx4_qp_context *qpc = inbox->buf + 8;\r\nint mtt_base = qp_get_mtt_addr(qpc) / dev->caps.mtt_entry_sz;\r\nint mtt_size = qp_get_mtt_size(qpc);\r\nstruct res_cq *rcq;\r\nstruct res_cq *scq;\r\nint rcqn = qp_get_rcqn(qpc);\r\nint scqn = qp_get_scqn(qpc);\r\nu32 srqn = qp_get_srqn(qpc) & 0xffffff;\r\nint use_srq = (qp_get_srqn(qpc) >> 24) & 1;\r\nstruct res_srq *srq;\r\nint local_qpn = be32_to_cpu(qpc->local_qpn) & 0xffffff;\r\nerr = adjust_qp_sched_queue(dev, slave, qpc, inbox);\r\nif (err)\r\nreturn err;\r\nerr = qp_res_start_move_to(dev, slave, qpn, RES_QP_HW, &qp, 0);\r\nif (err)\r\nreturn err;\r\nqp->local_qpn = local_qpn;\r\nqp->sched_queue = 0;\r\nqp->param3 = 0;\r\nqp->vlan_control = 0;\r\nqp->fvl_rx = 0;\r\nqp->pri_path_fl = 0;\r\nqp->vlan_index = 0;\r\nqp->feup = 0;\r\nqp->qpc_flags = be32_to_cpu(qpc->flags);\r\nerr = get_res(dev, slave, mtt_base, RES_MTT, &mtt);\r\nif (err)\r\ngoto ex_abort;\r\nerr = check_mtt_range(dev, slave, mtt_base, mtt_size, mtt);\r\nif (err)\r\ngoto ex_put_mtt;\r\nerr = get_res(dev, slave, rcqn, RES_CQ, &rcq);\r\nif (err)\r\ngoto ex_put_mtt;\r\nif (scqn != rcqn) {\r\nerr = get_res(dev, slave, scqn, RES_CQ, &scq);\r\nif (err)\r\ngoto ex_put_rcq;\r\n} else\r\nscq = rcq;\r\nif (use_srq) {\r\nerr = get_res(dev, slave, srqn, RES_SRQ, &srq);\r\nif (err)\r\ngoto ex_put_scq;\r\n}\r\nadjust_proxy_tun_qkey(dev, vhcr, qpc);\r\nupdate_pkey_index(dev, slave, inbox);\r\nerr = mlx4_DMA_wrapper(dev, slave, vhcr, inbox, outbox, cmd);\r\nif (err)\r\ngoto ex_put_srq;\r\natomic_inc(&mtt->ref_count);\r\nqp->mtt = mtt;\r\natomic_inc(&rcq->ref_count);\r\nqp->rcq = rcq;\r\natomic_inc(&scq->ref_count);\r\nqp->scq = scq;\r\nif (scqn != rcqn)\r\nput_res(dev, slave, scqn, RES_CQ);\r\nif (use_srq) {\r\natomic_inc(&srq->ref_count);\r\nput_res(dev, slave, srqn, RES_SRQ);\r\nqp->srq = srq;\r\n}\r\nput_res(dev, slave, rcqn, RES_CQ);\r\nput_res(dev, slave, mtt_base, RES_MTT);\r\nres_end_move(dev, slave, RES_QP, qpn);\r\nreturn 0;\r\nex_put_srq:\r\nif (use_srq)\r\nput_res(dev, slave, srqn, RES_SRQ);\r\nex_put_scq:\r\nif (scqn != rcqn)\r\nput_res(dev, slave, scqn, RES_CQ);\r\nex_put_rcq:\r\nput_res(dev, slave, rcqn, RES_CQ);\r\nex_put_mtt:\r\nput_res(dev, slave, mtt_base, RES_MTT);\r\nex_abort:\r\nres_abort_move(dev, slave, RES_QP, qpn);\r\nreturn err;\r\n}\r\nstatic int eq_get_mtt_addr(struct mlx4_eq_context *eqc)\r\n{\r\nreturn be32_to_cpu(eqc->mtt_base_addr_l) & 0xfffffff8;\r\n}\r\nstatic int eq_get_mtt_size(struct mlx4_eq_context *eqc)\r\n{\r\nint log_eq_size = eqc->log_eq_size & 0x1f;\r\nint page_shift = (eqc->log_page_size & 0x3f) + 12;\r\nif (log_eq_size + 5 < page_shift)\r\nreturn 1;\r\nreturn 1 << (log_eq_size + 5 - page_shift);\r\n}\r\nstatic int cq_get_mtt_addr(struct mlx4_cq_context *cqc)\r\n{\r\nreturn be32_to_cpu(cqc->mtt_base_addr_l) & 0xfffffff8;\r\n}\r\nstatic int cq_get_mtt_size(struct mlx4_cq_context *cqc)\r\n{\r\nint log_cq_size = (be32_to_cpu(cqc->logsize_usrpage) >> 24) & 0x1f;\r\nint page_shift = (cqc->log_page_size & 0x3f) + 12;\r\nif (log_cq_size + 5 < page_shift)\r\nreturn 1;\r\nreturn 1 << (log_cq_size + 5 - page_shift);\r\n}\r\nint mlx4_SW2HW_EQ_wrapper(struct mlx4_dev *dev, int slave,\r\nstruct mlx4_vhcr *vhcr,\r\nstruct mlx4_cmd_mailbox *inbox,\r\nstruct mlx4_cmd_mailbox *outbox,\r\nstruct mlx4_cmd_info *cmd)\r\n{\r\nint err;\r\nint eqn = vhcr->in_modifier;\r\nint res_id = (slave << 10) | eqn;\r\nstruct mlx4_eq_context *eqc = inbox->buf;\r\nint mtt_base = eq_get_mtt_addr(eqc) / dev->caps.mtt_entry_sz;\r\nint mtt_size = eq_get_mtt_size(eqc);\r\nstruct res_eq *eq;\r\nstruct res_mtt *mtt;\r\nerr = add_res_range(dev, slave, res_id, 1, RES_EQ, 0);\r\nif (err)\r\nreturn err;\r\nerr = eq_res_start_move_to(dev, slave, res_id, RES_EQ_HW, &eq);\r\nif (err)\r\ngoto out_add;\r\nerr = get_res(dev, slave, mtt_base, RES_MTT, &mtt);\r\nif (err)\r\ngoto out_move;\r\nerr = check_mtt_range(dev, slave, mtt_base, mtt_size, mtt);\r\nif (err)\r\ngoto out_put;\r\nerr = mlx4_DMA_wrapper(dev, slave, vhcr, inbox, outbox, cmd);\r\nif (err)\r\ngoto out_put;\r\natomic_inc(&mtt->ref_count);\r\neq->mtt = mtt;\r\nput_res(dev, slave, mtt->com.res_id, RES_MTT);\r\nres_end_move(dev, slave, RES_EQ, res_id);\r\nreturn 0;\r\nout_put:\r\nput_res(dev, slave, mtt->com.res_id, RES_MTT);\r\nout_move:\r\nres_abort_move(dev, slave, RES_EQ, res_id);\r\nout_add:\r\nrem_res_range(dev, slave, res_id, 1, RES_EQ, 0);\r\nreturn err;\r\n}\r\nint mlx4_CONFIG_DEV_wrapper(struct mlx4_dev *dev, int slave,\r\nstruct mlx4_vhcr *vhcr,\r\nstruct mlx4_cmd_mailbox *inbox,\r\nstruct mlx4_cmd_mailbox *outbox,\r\nstruct mlx4_cmd_info *cmd)\r\n{\r\nint err;\r\nu8 get = vhcr->op_modifier;\r\nif (get != 1)\r\nreturn -EPERM;\r\nerr = mlx4_DMA_wrapper(dev, slave, vhcr, inbox, outbox, cmd);\r\nreturn err;\r\n}\r\nstatic int get_containing_mtt(struct mlx4_dev *dev, int slave, int start,\r\nint len, struct res_mtt **res)\r\n{\r\nstruct mlx4_priv *priv = mlx4_priv(dev);\r\nstruct mlx4_resource_tracker *tracker = &priv->mfunc.master.res_tracker;\r\nstruct res_mtt *mtt;\r\nint err = -EINVAL;\r\nspin_lock_irq(mlx4_tlock(dev));\r\nlist_for_each_entry(mtt, &tracker->slave_list[slave].res_list[RES_MTT],\r\ncom.list) {\r\nif (!check_mtt_range(dev, slave, start, len, mtt)) {\r\n*res = mtt;\r\nmtt->com.from_state = mtt->com.state;\r\nmtt->com.state = RES_MTT_BUSY;\r\nerr = 0;\r\nbreak;\r\n}\r\n}\r\nspin_unlock_irq(mlx4_tlock(dev));\r\nreturn err;\r\n}\r\nstatic int verify_qp_parameters(struct mlx4_dev *dev,\r\nstruct mlx4_vhcr *vhcr,\r\nstruct mlx4_cmd_mailbox *inbox,\r\nenum qp_transition transition, u8 slave)\r\n{\r\nu32 qp_type;\r\nu32 qpn;\r\nstruct mlx4_qp_context *qp_ctx;\r\nenum mlx4_qp_optpar optpar;\r\nint port;\r\nint num_gids;\r\nqp_ctx = inbox->buf + 8;\r\nqp_type = (be32_to_cpu(qp_ctx->flags) >> 16) & 0xff;\r\noptpar = be32_to_cpu(*(__be32 *) inbox->buf);\r\nif (slave != mlx4_master_func_num(dev)) {\r\nqp_ctx->params2 &= ~MLX4_QP_BIT_FPP;\r\nif (qp_ctx->rate_limit_params)\r\nreturn -EPERM;\r\n}\r\nswitch (qp_type) {\r\ncase MLX4_QP_ST_RC:\r\ncase MLX4_QP_ST_XRC:\r\ncase MLX4_QP_ST_UC:\r\nswitch (transition) {\r\ncase QP_TRANS_INIT2RTR:\r\ncase QP_TRANS_RTR2RTS:\r\ncase QP_TRANS_RTS2RTS:\r\ncase QP_TRANS_SQD2SQD:\r\ncase QP_TRANS_SQD2RTS:\r\nif (slave != mlx4_master_func_num(dev)) {\r\nif (optpar & MLX4_QP_OPTPAR_PRIMARY_ADDR_PATH) {\r\nport = (qp_ctx->pri_path.sched_queue >> 6 & 1) + 1;\r\nif (dev->caps.port_mask[port] != MLX4_PORT_TYPE_IB)\r\nnum_gids = mlx4_get_slave_num_gids(dev, slave, port);\r\nelse\r\nnum_gids = 1;\r\nif (qp_ctx->pri_path.mgid_index >= num_gids)\r\nreturn -EINVAL;\r\n}\r\nif (optpar & MLX4_QP_OPTPAR_ALT_ADDR_PATH) {\r\nport = (qp_ctx->alt_path.sched_queue >> 6 & 1) + 1;\r\nif (dev->caps.port_mask[port] != MLX4_PORT_TYPE_IB)\r\nnum_gids = mlx4_get_slave_num_gids(dev, slave, port);\r\nelse\r\nnum_gids = 1;\r\nif (qp_ctx->alt_path.mgid_index >= num_gids)\r\nreturn -EINVAL;\r\n}\r\n}\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nbreak;\r\ncase MLX4_QP_ST_MLX:\r\nqpn = vhcr->in_modifier & 0x7fffff;\r\nport = (qp_ctx->pri_path.sched_queue >> 6 & 1) + 1;\r\nif (transition == QP_TRANS_INIT2RTR &&\r\nslave != mlx4_master_func_num(dev) &&\r\nmlx4_is_qp_reserved(dev, qpn) &&\r\n!mlx4_vf_smi_enabled(dev, slave, port)) {\r\nmlx4_err(dev, "%s: unprivileged slave %d attempting to create an MLX proxy special QP on port %d\n",\r\n__func__, slave, port);\r\nreturn -EPERM;\r\n}\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nint mlx4_WRITE_MTT_wrapper(struct mlx4_dev *dev, int slave,\r\nstruct mlx4_vhcr *vhcr,\r\nstruct mlx4_cmd_mailbox *inbox,\r\nstruct mlx4_cmd_mailbox *outbox,\r\nstruct mlx4_cmd_info *cmd)\r\n{\r\nstruct mlx4_mtt mtt;\r\n__be64 *page_list = inbox->buf;\r\nu64 *pg_list = (u64 *)page_list;\r\nint i;\r\nstruct res_mtt *rmtt = NULL;\r\nint start = be64_to_cpu(page_list[0]);\r\nint npages = vhcr->in_modifier;\r\nint err;\r\nerr = get_containing_mtt(dev, slave, start, npages, &rmtt);\r\nif (err)\r\nreturn err;\r\nmtt.offset = 0;\r\nmtt.order = 0;\r\nmtt.page_shift = 0;\r\nfor (i = 0; i < npages; ++i)\r\npg_list[i + 2] = (be64_to_cpu(page_list[i + 2]) & ~1ULL);\r\nerr = __mlx4_write_mtt(dev, &mtt, be64_to_cpu(page_list[0]), npages,\r\n((u64 *)page_list + 2));\r\nif (rmtt)\r\nput_res(dev, slave, rmtt->com.res_id, RES_MTT);\r\nreturn err;\r\n}\r\nint mlx4_HW2SW_EQ_wrapper(struct mlx4_dev *dev, int slave,\r\nstruct mlx4_vhcr *vhcr,\r\nstruct mlx4_cmd_mailbox *inbox,\r\nstruct mlx4_cmd_mailbox *outbox,\r\nstruct mlx4_cmd_info *cmd)\r\n{\r\nint eqn = vhcr->in_modifier;\r\nint res_id = eqn | (slave << 10);\r\nstruct res_eq *eq;\r\nint err;\r\nerr = eq_res_start_move_to(dev, slave, res_id, RES_EQ_RESERVED, &eq);\r\nif (err)\r\nreturn err;\r\nerr = get_res(dev, slave, eq->mtt->com.res_id, RES_MTT, NULL);\r\nif (err)\r\ngoto ex_abort;\r\nerr = mlx4_DMA_wrapper(dev, slave, vhcr, inbox, outbox, cmd);\r\nif (err)\r\ngoto ex_put;\r\natomic_dec(&eq->mtt->ref_count);\r\nput_res(dev, slave, eq->mtt->com.res_id, RES_MTT);\r\nres_end_move(dev, slave, RES_EQ, res_id);\r\nrem_res_range(dev, slave, res_id, 1, RES_EQ, 0);\r\nreturn 0;\r\nex_put:\r\nput_res(dev, slave, eq->mtt->com.res_id, RES_MTT);\r\nex_abort:\r\nres_abort_move(dev, slave, RES_EQ, res_id);\r\nreturn err;\r\n}\r\nint mlx4_GEN_EQE(struct mlx4_dev *dev, int slave, struct mlx4_eqe *eqe)\r\n{\r\nstruct mlx4_priv *priv = mlx4_priv(dev);\r\nstruct mlx4_slave_event_eq_info *event_eq;\r\nstruct mlx4_cmd_mailbox *mailbox;\r\nu32 in_modifier = 0;\r\nint err;\r\nint res_id;\r\nstruct res_eq *req;\r\nif (!priv->mfunc.master.slave_state)\r\nreturn -EINVAL;\r\nif (slave < 0 || slave > dev->persist->num_vfs ||\r\nslave == dev->caps.function ||\r\n!priv->mfunc.master.slave_state[slave].active)\r\nreturn 0;\r\nevent_eq = &priv->mfunc.master.slave_state[slave].event_eq[eqe->type];\r\nif (event_eq->eqn < 0)\r\nreturn 0;\r\nmutex_lock(&priv->mfunc.master.gen_eqe_mutex[slave]);\r\nres_id = (slave << 10) | event_eq->eqn;\r\nerr = get_res(dev, slave, res_id, RES_EQ, &req);\r\nif (err)\r\ngoto unlock;\r\nif (req->com.from_state != RES_EQ_HW) {\r\nerr = -EINVAL;\r\ngoto put;\r\n}\r\nmailbox = mlx4_alloc_cmd_mailbox(dev);\r\nif (IS_ERR(mailbox)) {\r\nerr = PTR_ERR(mailbox);\r\ngoto put;\r\n}\r\nif (eqe->type == MLX4_EVENT_TYPE_CMD) {\r\n++event_eq->token;\r\neqe->event.cmd.token = cpu_to_be16(event_eq->token);\r\n}\r\nmemcpy(mailbox->buf, (u8 *) eqe, 28);\r\nin_modifier = (slave & 0xff) | ((event_eq->eqn & 0x3ff) << 16);\r\nerr = mlx4_cmd(dev, mailbox->dma, in_modifier, 0,\r\nMLX4_CMD_GEN_EQE, MLX4_CMD_TIME_CLASS_B,\r\nMLX4_CMD_NATIVE);\r\nput_res(dev, slave, res_id, RES_EQ);\r\nmutex_unlock(&priv->mfunc.master.gen_eqe_mutex[slave]);\r\nmlx4_free_cmd_mailbox(dev, mailbox);\r\nreturn err;\r\nput:\r\nput_res(dev, slave, res_id, RES_EQ);\r\nunlock:\r\nmutex_unlock(&priv->mfunc.master.gen_eqe_mutex[slave]);\r\nreturn err;\r\n}\r\nint mlx4_QUERY_EQ_wrapper(struct mlx4_dev *dev, int slave,\r\nstruct mlx4_vhcr *vhcr,\r\nstruct mlx4_cmd_mailbox *inbox,\r\nstruct mlx4_cmd_mailbox *outbox,\r\nstruct mlx4_cmd_info *cmd)\r\n{\r\nint eqn = vhcr->in_modifier;\r\nint res_id = eqn | (slave << 10);\r\nstruct res_eq *eq;\r\nint err;\r\nerr = get_res(dev, slave, res_id, RES_EQ, &eq);\r\nif (err)\r\nreturn err;\r\nif (eq->com.from_state != RES_EQ_HW) {\r\nerr = -EINVAL;\r\ngoto ex_put;\r\n}\r\nerr = mlx4_DMA_wrapper(dev, slave, vhcr, inbox, outbox, cmd);\r\nex_put:\r\nput_res(dev, slave, res_id, RES_EQ);\r\nreturn err;\r\n}\r\nint mlx4_SW2HW_CQ_wrapper(struct mlx4_dev *dev, int slave,\r\nstruct mlx4_vhcr *vhcr,\r\nstruct mlx4_cmd_mailbox *inbox,\r\nstruct mlx4_cmd_mailbox *outbox,\r\nstruct mlx4_cmd_info *cmd)\r\n{\r\nint err;\r\nint cqn = vhcr->in_modifier;\r\nstruct mlx4_cq_context *cqc = inbox->buf;\r\nint mtt_base = cq_get_mtt_addr(cqc) / dev->caps.mtt_entry_sz;\r\nstruct res_cq *cq = NULL;\r\nstruct res_mtt *mtt;\r\nerr = cq_res_start_move_to(dev, slave, cqn, RES_CQ_HW, &cq);\r\nif (err)\r\nreturn err;\r\nerr = get_res(dev, slave, mtt_base, RES_MTT, &mtt);\r\nif (err)\r\ngoto out_move;\r\nerr = check_mtt_range(dev, slave, mtt_base, cq_get_mtt_size(cqc), mtt);\r\nif (err)\r\ngoto out_put;\r\nerr = mlx4_DMA_wrapper(dev, slave, vhcr, inbox, outbox, cmd);\r\nif (err)\r\ngoto out_put;\r\natomic_inc(&mtt->ref_count);\r\ncq->mtt = mtt;\r\nput_res(dev, slave, mtt->com.res_id, RES_MTT);\r\nres_end_move(dev, slave, RES_CQ, cqn);\r\nreturn 0;\r\nout_put:\r\nput_res(dev, slave, mtt->com.res_id, RES_MTT);\r\nout_move:\r\nres_abort_move(dev, slave, RES_CQ, cqn);\r\nreturn err;\r\n}\r\nint mlx4_HW2SW_CQ_wrapper(struct mlx4_dev *dev, int slave,\r\nstruct mlx4_vhcr *vhcr,\r\nstruct mlx4_cmd_mailbox *inbox,\r\nstruct mlx4_cmd_mailbox *outbox,\r\nstruct mlx4_cmd_info *cmd)\r\n{\r\nint err;\r\nint cqn = vhcr->in_modifier;\r\nstruct res_cq *cq = NULL;\r\nerr = cq_res_start_move_to(dev, slave, cqn, RES_CQ_ALLOCATED, &cq);\r\nif (err)\r\nreturn err;\r\nerr = mlx4_DMA_wrapper(dev, slave, vhcr, inbox, outbox, cmd);\r\nif (err)\r\ngoto out_move;\r\natomic_dec(&cq->mtt->ref_count);\r\nres_end_move(dev, slave, RES_CQ, cqn);\r\nreturn 0;\r\nout_move:\r\nres_abort_move(dev, slave, RES_CQ, cqn);\r\nreturn err;\r\n}\r\nint mlx4_QUERY_CQ_wrapper(struct mlx4_dev *dev, int slave,\r\nstruct mlx4_vhcr *vhcr,\r\nstruct mlx4_cmd_mailbox *inbox,\r\nstruct mlx4_cmd_mailbox *outbox,\r\nstruct mlx4_cmd_info *cmd)\r\n{\r\nint cqn = vhcr->in_modifier;\r\nstruct res_cq *cq;\r\nint err;\r\nerr = get_res(dev, slave, cqn, RES_CQ, &cq);\r\nif (err)\r\nreturn err;\r\nif (cq->com.from_state != RES_CQ_HW)\r\ngoto ex_put;\r\nerr = mlx4_DMA_wrapper(dev, slave, vhcr, inbox, outbox, cmd);\r\nex_put:\r\nput_res(dev, slave, cqn, RES_CQ);\r\nreturn err;\r\n}\r\nstatic int handle_resize(struct mlx4_dev *dev, int slave,\r\nstruct mlx4_vhcr *vhcr,\r\nstruct mlx4_cmd_mailbox *inbox,\r\nstruct mlx4_cmd_mailbox *outbox,\r\nstruct mlx4_cmd_info *cmd,\r\nstruct res_cq *cq)\r\n{\r\nint err;\r\nstruct res_mtt *orig_mtt;\r\nstruct res_mtt *mtt;\r\nstruct mlx4_cq_context *cqc = inbox->buf;\r\nint mtt_base = cq_get_mtt_addr(cqc) / dev->caps.mtt_entry_sz;\r\nerr = get_res(dev, slave, cq->mtt->com.res_id, RES_MTT, &orig_mtt);\r\nif (err)\r\nreturn err;\r\nif (orig_mtt != cq->mtt) {\r\nerr = -EINVAL;\r\ngoto ex_put;\r\n}\r\nerr = get_res(dev, slave, mtt_base, RES_MTT, &mtt);\r\nif (err)\r\ngoto ex_put;\r\nerr = check_mtt_range(dev, slave, mtt_base, cq_get_mtt_size(cqc), mtt);\r\nif (err)\r\ngoto ex_put1;\r\nerr = mlx4_DMA_wrapper(dev, slave, vhcr, inbox, outbox, cmd);\r\nif (err)\r\ngoto ex_put1;\r\natomic_dec(&orig_mtt->ref_count);\r\nput_res(dev, slave, orig_mtt->com.res_id, RES_MTT);\r\natomic_inc(&mtt->ref_count);\r\ncq->mtt = mtt;\r\nput_res(dev, slave, mtt->com.res_id, RES_MTT);\r\nreturn 0;\r\nex_put1:\r\nput_res(dev, slave, mtt->com.res_id, RES_MTT);\r\nex_put:\r\nput_res(dev, slave, orig_mtt->com.res_id, RES_MTT);\r\nreturn err;\r\n}\r\nint mlx4_MODIFY_CQ_wrapper(struct mlx4_dev *dev, int slave,\r\nstruct mlx4_vhcr *vhcr,\r\nstruct mlx4_cmd_mailbox *inbox,\r\nstruct mlx4_cmd_mailbox *outbox,\r\nstruct mlx4_cmd_info *cmd)\r\n{\r\nint cqn = vhcr->in_modifier;\r\nstruct res_cq *cq;\r\nint err;\r\nerr = get_res(dev, slave, cqn, RES_CQ, &cq);\r\nif (err)\r\nreturn err;\r\nif (cq->com.from_state != RES_CQ_HW)\r\ngoto ex_put;\r\nif (vhcr->op_modifier == 0) {\r\nerr = handle_resize(dev, slave, vhcr, inbox, outbox, cmd, cq);\r\ngoto ex_put;\r\n}\r\nerr = mlx4_DMA_wrapper(dev, slave, vhcr, inbox, outbox, cmd);\r\nex_put:\r\nput_res(dev, slave, cqn, RES_CQ);\r\nreturn err;\r\n}\r\nstatic int srq_get_mtt_size(struct mlx4_srq_context *srqc)\r\n{\r\nint log_srq_size = (be32_to_cpu(srqc->state_logsize_srqn) >> 24) & 0xf;\r\nint log_rq_stride = srqc->logstride & 7;\r\nint page_shift = (srqc->log_page_size & 0x3f) + 12;\r\nif (log_srq_size + log_rq_stride + 4 < page_shift)\r\nreturn 1;\r\nreturn 1 << (log_srq_size + log_rq_stride + 4 - page_shift);\r\n}\r\nint mlx4_SW2HW_SRQ_wrapper(struct mlx4_dev *dev, int slave,\r\nstruct mlx4_vhcr *vhcr,\r\nstruct mlx4_cmd_mailbox *inbox,\r\nstruct mlx4_cmd_mailbox *outbox,\r\nstruct mlx4_cmd_info *cmd)\r\n{\r\nint err;\r\nint srqn = vhcr->in_modifier;\r\nstruct res_mtt *mtt;\r\nstruct res_srq *srq = NULL;\r\nstruct mlx4_srq_context *srqc = inbox->buf;\r\nint mtt_base = srq_get_mtt_addr(srqc) / dev->caps.mtt_entry_sz;\r\nif (srqn != (be32_to_cpu(srqc->state_logsize_srqn) & 0xffffff))\r\nreturn -EINVAL;\r\nerr = srq_res_start_move_to(dev, slave, srqn, RES_SRQ_HW, &srq);\r\nif (err)\r\nreturn err;\r\nerr = get_res(dev, slave, mtt_base, RES_MTT, &mtt);\r\nif (err)\r\ngoto ex_abort;\r\nerr = check_mtt_range(dev, slave, mtt_base, srq_get_mtt_size(srqc),\r\nmtt);\r\nif (err)\r\ngoto ex_put_mtt;\r\nerr = mlx4_DMA_wrapper(dev, slave, vhcr, inbox, outbox, cmd);\r\nif (err)\r\ngoto ex_put_mtt;\r\natomic_inc(&mtt->ref_count);\r\nsrq->mtt = mtt;\r\nput_res(dev, slave, mtt->com.res_id, RES_MTT);\r\nres_end_move(dev, slave, RES_SRQ, srqn);\r\nreturn 0;\r\nex_put_mtt:\r\nput_res(dev, slave, mtt->com.res_id, RES_MTT);\r\nex_abort:\r\nres_abort_move(dev, slave, RES_SRQ, srqn);\r\nreturn err;\r\n}\r\nint mlx4_HW2SW_SRQ_wrapper(struct mlx4_dev *dev, int slave,\r\nstruct mlx4_vhcr *vhcr,\r\nstruct mlx4_cmd_mailbox *inbox,\r\nstruct mlx4_cmd_mailbox *outbox,\r\nstruct mlx4_cmd_info *cmd)\r\n{\r\nint err;\r\nint srqn = vhcr->in_modifier;\r\nstruct res_srq *srq = NULL;\r\nerr = srq_res_start_move_to(dev, slave, srqn, RES_SRQ_ALLOCATED, &srq);\r\nif (err)\r\nreturn err;\r\nerr = mlx4_DMA_wrapper(dev, slave, vhcr, inbox, outbox, cmd);\r\nif (err)\r\ngoto ex_abort;\r\natomic_dec(&srq->mtt->ref_count);\r\nif (srq->cq)\r\natomic_dec(&srq->cq->ref_count);\r\nres_end_move(dev, slave, RES_SRQ, srqn);\r\nreturn 0;\r\nex_abort:\r\nres_abort_move(dev, slave, RES_SRQ, srqn);\r\nreturn err;\r\n}\r\nint mlx4_QUERY_SRQ_wrapper(struct mlx4_dev *dev, int slave,\r\nstruct mlx4_vhcr *vhcr,\r\nstruct mlx4_cmd_mailbox *inbox,\r\nstruct mlx4_cmd_mailbox *outbox,\r\nstruct mlx4_cmd_info *cmd)\r\n{\r\nint err;\r\nint srqn = vhcr->in_modifier;\r\nstruct res_srq *srq;\r\nerr = get_res(dev, slave, srqn, RES_SRQ, &srq);\r\nif (err)\r\nreturn err;\r\nif (srq->com.from_state != RES_SRQ_HW) {\r\nerr = -EBUSY;\r\ngoto out;\r\n}\r\nerr = mlx4_DMA_wrapper(dev, slave, vhcr, inbox, outbox, cmd);\r\nout:\r\nput_res(dev, slave, srqn, RES_SRQ);\r\nreturn err;\r\n}\r\nint mlx4_ARM_SRQ_wrapper(struct mlx4_dev *dev, int slave,\r\nstruct mlx4_vhcr *vhcr,\r\nstruct mlx4_cmd_mailbox *inbox,\r\nstruct mlx4_cmd_mailbox *outbox,\r\nstruct mlx4_cmd_info *cmd)\r\n{\r\nint err;\r\nint srqn = vhcr->in_modifier;\r\nstruct res_srq *srq;\r\nerr = get_res(dev, slave, srqn, RES_SRQ, &srq);\r\nif (err)\r\nreturn err;\r\nif (srq->com.from_state != RES_SRQ_HW) {\r\nerr = -EBUSY;\r\ngoto out;\r\n}\r\nerr = mlx4_DMA_wrapper(dev, slave, vhcr, inbox, outbox, cmd);\r\nout:\r\nput_res(dev, slave, srqn, RES_SRQ);\r\nreturn err;\r\n}\r\nint mlx4_GEN_QP_wrapper(struct mlx4_dev *dev, int slave,\r\nstruct mlx4_vhcr *vhcr,\r\nstruct mlx4_cmd_mailbox *inbox,\r\nstruct mlx4_cmd_mailbox *outbox,\r\nstruct mlx4_cmd_info *cmd)\r\n{\r\nint err;\r\nint qpn = vhcr->in_modifier & 0x7fffff;\r\nstruct res_qp *qp;\r\nerr = get_res(dev, slave, qpn, RES_QP, &qp);\r\nif (err)\r\nreturn err;\r\nif (qp->com.from_state != RES_QP_HW) {\r\nerr = -EBUSY;\r\ngoto out;\r\n}\r\nerr = mlx4_DMA_wrapper(dev, slave, vhcr, inbox, outbox, cmd);\r\nout:\r\nput_res(dev, slave, qpn, RES_QP);\r\nreturn err;\r\n}\r\nint mlx4_INIT2INIT_QP_wrapper(struct mlx4_dev *dev, int slave,\r\nstruct mlx4_vhcr *vhcr,\r\nstruct mlx4_cmd_mailbox *inbox,\r\nstruct mlx4_cmd_mailbox *outbox,\r\nstruct mlx4_cmd_info *cmd)\r\n{\r\nstruct mlx4_qp_context *context = inbox->buf + 8;\r\nadjust_proxy_tun_qkey(dev, vhcr, context);\r\nupdate_pkey_index(dev, slave, inbox);\r\nreturn mlx4_GEN_QP_wrapper(dev, slave, vhcr, inbox, outbox, cmd);\r\n}\r\nstatic int adjust_qp_sched_queue(struct mlx4_dev *dev, int slave,\r\nstruct mlx4_qp_context *qpc,\r\nstruct mlx4_cmd_mailbox *inbox)\r\n{\r\nenum mlx4_qp_optpar optpar = be32_to_cpu(*(__be32 *)inbox->buf);\r\nu8 pri_sched_queue;\r\nint port = mlx4_slave_convert_port(\r\ndev, slave, (qpc->pri_path.sched_queue >> 6 & 1) + 1) - 1;\r\nif (port < 0)\r\nreturn -EINVAL;\r\npri_sched_queue = (qpc->pri_path.sched_queue & ~(1 << 6)) |\r\n((port & 1) << 6);\r\nif (optpar & (MLX4_QP_OPTPAR_PRIMARY_ADDR_PATH | MLX4_QP_OPTPAR_SCHED_QUEUE) ||\r\nqpc->pri_path.sched_queue || mlx4_is_eth(dev, port + 1)) {\r\nqpc->pri_path.sched_queue = pri_sched_queue;\r\n}\r\nif (optpar & MLX4_QP_OPTPAR_ALT_ADDR_PATH) {\r\nport = mlx4_slave_convert_port(\r\ndev, slave, (qpc->alt_path.sched_queue >> 6 & 1)\r\n+ 1) - 1;\r\nif (port < 0)\r\nreturn -EINVAL;\r\nqpc->alt_path.sched_queue =\r\n(qpc->alt_path.sched_queue & ~(1 << 6)) |\r\n(port & 1) << 6;\r\n}\r\nreturn 0;\r\n}\r\nstatic int roce_verify_mac(struct mlx4_dev *dev, int slave,\r\nstruct mlx4_qp_context *qpc,\r\nstruct mlx4_cmd_mailbox *inbox)\r\n{\r\nu64 mac;\r\nint port;\r\nu32 ts = (be32_to_cpu(qpc->flags) >> 16) & 0xff;\r\nu8 sched = *(u8 *)(inbox->buf + 64);\r\nu8 smac_ix;\r\nport = (sched >> 6 & 1) + 1;\r\nif (mlx4_is_eth(dev, port) && (ts != MLX4_QP_ST_MLX)) {\r\nsmac_ix = qpc->pri_path.grh_mylmc & 0x7f;\r\nif (mac_find_smac_ix_in_slave(dev, slave, port, smac_ix, &mac))\r\nreturn -ENOENT;\r\n}\r\nreturn 0;\r\n}\r\nint mlx4_INIT2RTR_QP_wrapper(struct mlx4_dev *dev, int slave,\r\nstruct mlx4_vhcr *vhcr,\r\nstruct mlx4_cmd_mailbox *inbox,\r\nstruct mlx4_cmd_mailbox *outbox,\r\nstruct mlx4_cmd_info *cmd)\r\n{\r\nint err;\r\nstruct mlx4_qp_context *qpc = inbox->buf + 8;\r\nint qpn = vhcr->in_modifier & 0x7fffff;\r\nstruct res_qp *qp;\r\nu8 orig_sched_queue;\r\n__be32 orig_param3 = qpc->param3;\r\nu8 orig_vlan_control = qpc->pri_path.vlan_control;\r\nu8 orig_fvl_rx = qpc->pri_path.fvl_rx;\r\nu8 orig_pri_path_fl = qpc->pri_path.fl;\r\nu8 orig_vlan_index = qpc->pri_path.vlan_index;\r\nu8 orig_feup = qpc->pri_path.feup;\r\nerr = adjust_qp_sched_queue(dev, slave, qpc, inbox);\r\nif (err)\r\nreturn err;\r\nerr = verify_qp_parameters(dev, vhcr, inbox, QP_TRANS_INIT2RTR, slave);\r\nif (err)\r\nreturn err;\r\nif (roce_verify_mac(dev, slave, qpc, inbox))\r\nreturn -EINVAL;\r\nupdate_pkey_index(dev, slave, inbox);\r\nupdate_gid(dev, inbox, (u8)slave);\r\nadjust_proxy_tun_qkey(dev, vhcr, qpc);\r\norig_sched_queue = qpc->pri_path.sched_queue;\r\nerr = get_res(dev, slave, qpn, RES_QP, &qp);\r\nif (err)\r\nreturn err;\r\nif (qp->com.from_state != RES_QP_HW) {\r\nerr = -EBUSY;\r\ngoto out;\r\n}\r\nerr = update_vport_qp_param(dev, inbox, slave, qpn);\r\nif (err)\r\ngoto out;\r\nerr = mlx4_DMA_wrapper(dev, slave, vhcr, inbox, outbox, cmd);\r\nout:\r\nif (!err) {\r\nqp->sched_queue = orig_sched_queue;\r\nqp->param3 = orig_param3;\r\nqp->vlan_control = orig_vlan_control;\r\nqp->fvl_rx = orig_fvl_rx;\r\nqp->pri_path_fl = orig_pri_path_fl;\r\nqp->vlan_index = orig_vlan_index;\r\nqp->feup = orig_feup;\r\n}\r\nput_res(dev, slave, qpn, RES_QP);\r\nreturn err;\r\n}\r\nint mlx4_RTR2RTS_QP_wrapper(struct mlx4_dev *dev, int slave,\r\nstruct mlx4_vhcr *vhcr,\r\nstruct mlx4_cmd_mailbox *inbox,\r\nstruct mlx4_cmd_mailbox *outbox,\r\nstruct mlx4_cmd_info *cmd)\r\n{\r\nint err;\r\nstruct mlx4_qp_context *context = inbox->buf + 8;\r\nerr = adjust_qp_sched_queue(dev, slave, context, inbox);\r\nif (err)\r\nreturn err;\r\nerr = verify_qp_parameters(dev, vhcr, inbox, QP_TRANS_RTR2RTS, slave);\r\nif (err)\r\nreturn err;\r\nupdate_pkey_index(dev, slave, inbox);\r\nupdate_gid(dev, inbox, (u8)slave);\r\nadjust_proxy_tun_qkey(dev, vhcr, context);\r\nreturn mlx4_GEN_QP_wrapper(dev, slave, vhcr, inbox, outbox, cmd);\r\n}\r\nint mlx4_RTS2RTS_QP_wrapper(struct mlx4_dev *dev, int slave,\r\nstruct mlx4_vhcr *vhcr,\r\nstruct mlx4_cmd_mailbox *inbox,\r\nstruct mlx4_cmd_mailbox *outbox,\r\nstruct mlx4_cmd_info *cmd)\r\n{\r\nint err;\r\nstruct mlx4_qp_context *context = inbox->buf + 8;\r\nerr = adjust_qp_sched_queue(dev, slave, context, inbox);\r\nif (err)\r\nreturn err;\r\nerr = verify_qp_parameters(dev, vhcr, inbox, QP_TRANS_RTS2RTS, slave);\r\nif (err)\r\nreturn err;\r\nupdate_pkey_index(dev, slave, inbox);\r\nupdate_gid(dev, inbox, (u8)slave);\r\nadjust_proxy_tun_qkey(dev, vhcr, context);\r\nreturn mlx4_GEN_QP_wrapper(dev, slave, vhcr, inbox, outbox, cmd);\r\n}\r\nint mlx4_SQERR2RTS_QP_wrapper(struct mlx4_dev *dev, int slave,\r\nstruct mlx4_vhcr *vhcr,\r\nstruct mlx4_cmd_mailbox *inbox,\r\nstruct mlx4_cmd_mailbox *outbox,\r\nstruct mlx4_cmd_info *cmd)\r\n{\r\nstruct mlx4_qp_context *context = inbox->buf + 8;\r\nint err = adjust_qp_sched_queue(dev, slave, context, inbox);\r\nif (err)\r\nreturn err;\r\nadjust_proxy_tun_qkey(dev, vhcr, context);\r\nreturn mlx4_GEN_QP_wrapper(dev, slave, vhcr, inbox, outbox, cmd);\r\n}\r\nint mlx4_SQD2SQD_QP_wrapper(struct mlx4_dev *dev, int slave,\r\nstruct mlx4_vhcr *vhcr,\r\nstruct mlx4_cmd_mailbox *inbox,\r\nstruct mlx4_cmd_mailbox *outbox,\r\nstruct mlx4_cmd_info *cmd)\r\n{\r\nint err;\r\nstruct mlx4_qp_context *context = inbox->buf + 8;\r\nerr = adjust_qp_sched_queue(dev, slave, context, inbox);\r\nif (err)\r\nreturn err;\r\nerr = verify_qp_parameters(dev, vhcr, inbox, QP_TRANS_SQD2SQD, slave);\r\nif (err)\r\nreturn err;\r\nadjust_proxy_tun_qkey(dev, vhcr, context);\r\nupdate_gid(dev, inbox, (u8)slave);\r\nupdate_pkey_index(dev, slave, inbox);\r\nreturn mlx4_GEN_QP_wrapper(dev, slave, vhcr, inbox, outbox, cmd);\r\n}\r\nint mlx4_SQD2RTS_QP_wrapper(struct mlx4_dev *dev, int slave,\r\nstruct mlx4_vhcr *vhcr,\r\nstruct mlx4_cmd_mailbox *inbox,\r\nstruct mlx4_cmd_mailbox *outbox,\r\nstruct mlx4_cmd_info *cmd)\r\n{\r\nint err;\r\nstruct mlx4_qp_context *context = inbox->buf + 8;\r\nerr = adjust_qp_sched_queue(dev, slave, context, inbox);\r\nif (err)\r\nreturn err;\r\nerr = verify_qp_parameters(dev, vhcr, inbox, QP_TRANS_SQD2RTS, slave);\r\nif (err)\r\nreturn err;\r\nadjust_proxy_tun_qkey(dev, vhcr, context);\r\nupdate_gid(dev, inbox, (u8)slave);\r\nupdate_pkey_index(dev, slave, inbox);\r\nreturn mlx4_GEN_QP_wrapper(dev, slave, vhcr, inbox, outbox, cmd);\r\n}\r\nint mlx4_2RST_QP_wrapper(struct mlx4_dev *dev, int slave,\r\nstruct mlx4_vhcr *vhcr,\r\nstruct mlx4_cmd_mailbox *inbox,\r\nstruct mlx4_cmd_mailbox *outbox,\r\nstruct mlx4_cmd_info *cmd)\r\n{\r\nint err;\r\nint qpn = vhcr->in_modifier & 0x7fffff;\r\nstruct res_qp *qp;\r\nerr = qp_res_start_move_to(dev, slave, qpn, RES_QP_MAPPED, &qp, 0);\r\nif (err)\r\nreturn err;\r\nerr = mlx4_DMA_wrapper(dev, slave, vhcr, inbox, outbox, cmd);\r\nif (err)\r\ngoto ex_abort;\r\natomic_dec(&qp->mtt->ref_count);\r\natomic_dec(&qp->rcq->ref_count);\r\natomic_dec(&qp->scq->ref_count);\r\nif (qp->srq)\r\natomic_dec(&qp->srq->ref_count);\r\nres_end_move(dev, slave, RES_QP, qpn);\r\nreturn 0;\r\nex_abort:\r\nres_abort_move(dev, slave, RES_QP, qpn);\r\nreturn err;\r\n}\r\nstatic struct res_gid *find_gid(struct mlx4_dev *dev, int slave,\r\nstruct res_qp *rqp, u8 *gid)\r\n{\r\nstruct res_gid *res;\r\nlist_for_each_entry(res, &rqp->mcg_list, list) {\r\nif (!memcmp(res->gid, gid, 16))\r\nreturn res;\r\n}\r\nreturn NULL;\r\n}\r\nstatic int add_mcg_res(struct mlx4_dev *dev, int slave, struct res_qp *rqp,\r\nu8 *gid, enum mlx4_protocol prot,\r\nenum mlx4_steer_type steer, u64 reg_id)\r\n{\r\nstruct res_gid *res;\r\nint err;\r\nres = kzalloc(sizeof *res, GFP_KERNEL);\r\nif (!res)\r\nreturn -ENOMEM;\r\nspin_lock_irq(&rqp->mcg_spl);\r\nif (find_gid(dev, slave, rqp, gid)) {\r\nkfree(res);\r\nerr = -EEXIST;\r\n} else {\r\nmemcpy(res->gid, gid, 16);\r\nres->prot = prot;\r\nres->steer = steer;\r\nres->reg_id = reg_id;\r\nlist_add_tail(&res->list, &rqp->mcg_list);\r\nerr = 0;\r\n}\r\nspin_unlock_irq(&rqp->mcg_spl);\r\nreturn err;\r\n}\r\nstatic int rem_mcg_res(struct mlx4_dev *dev, int slave, struct res_qp *rqp,\r\nu8 *gid, enum mlx4_protocol prot,\r\nenum mlx4_steer_type steer, u64 *reg_id)\r\n{\r\nstruct res_gid *res;\r\nint err;\r\nspin_lock_irq(&rqp->mcg_spl);\r\nres = find_gid(dev, slave, rqp, gid);\r\nif (!res || res->prot != prot || res->steer != steer)\r\nerr = -EINVAL;\r\nelse {\r\n*reg_id = res->reg_id;\r\nlist_del(&res->list);\r\nkfree(res);\r\nerr = 0;\r\n}\r\nspin_unlock_irq(&rqp->mcg_spl);\r\nreturn err;\r\n}\r\nstatic int qp_attach(struct mlx4_dev *dev, int slave, struct mlx4_qp *qp,\r\nu8 gid[16], int block_loopback, enum mlx4_protocol prot,\r\nenum mlx4_steer_type type, u64 *reg_id)\r\n{\r\nswitch (dev->caps.steering_mode) {\r\ncase MLX4_STEERING_MODE_DEVICE_MANAGED: {\r\nint port = mlx4_slave_convert_port(dev, slave, gid[5]);\r\nif (port < 0)\r\nreturn port;\r\nreturn mlx4_trans_to_dmfs_attach(dev, qp, gid, port,\r\nblock_loopback, prot,\r\nreg_id);\r\n}\r\ncase MLX4_STEERING_MODE_B0:\r\nif (prot == MLX4_PROT_ETH) {\r\nint port = mlx4_slave_convert_port(dev, slave, gid[5]);\r\nif (port < 0)\r\nreturn port;\r\ngid[5] = port;\r\n}\r\nreturn mlx4_qp_attach_common(dev, qp, gid,\r\nblock_loopback, prot, type);\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\n}\r\nstatic int qp_detach(struct mlx4_dev *dev, struct mlx4_qp *qp,\r\nu8 gid[16], enum mlx4_protocol prot,\r\nenum mlx4_steer_type type, u64 reg_id)\r\n{\r\nswitch (dev->caps.steering_mode) {\r\ncase MLX4_STEERING_MODE_DEVICE_MANAGED:\r\nreturn mlx4_flow_detach(dev, reg_id);\r\ncase MLX4_STEERING_MODE_B0:\r\nreturn mlx4_qp_detach_common(dev, qp, gid, prot, type);\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\n}\r\nstatic int mlx4_adjust_port(struct mlx4_dev *dev, int slave,\r\nu8 *gid, enum mlx4_protocol prot)\r\n{\r\nint real_port;\r\nif (prot != MLX4_PROT_ETH)\r\nreturn 0;\r\nif (dev->caps.steering_mode == MLX4_STEERING_MODE_B0 ||\r\ndev->caps.steering_mode == MLX4_STEERING_MODE_DEVICE_MANAGED) {\r\nreal_port = mlx4_slave_convert_port(dev, slave, gid[5]);\r\nif (real_port < 0)\r\nreturn -EINVAL;\r\ngid[5] = real_port;\r\n}\r\nreturn 0;\r\n}\r\nint mlx4_QP_ATTACH_wrapper(struct mlx4_dev *dev, int slave,\r\nstruct mlx4_vhcr *vhcr,\r\nstruct mlx4_cmd_mailbox *inbox,\r\nstruct mlx4_cmd_mailbox *outbox,\r\nstruct mlx4_cmd_info *cmd)\r\n{\r\nstruct mlx4_qp qp;\r\nu8 *gid = inbox->buf;\r\nenum mlx4_protocol prot = (vhcr->in_modifier >> 28) & 0x7;\r\nint err;\r\nint qpn;\r\nstruct res_qp *rqp;\r\nu64 reg_id = 0;\r\nint attach = vhcr->op_modifier;\r\nint block_loopback = vhcr->in_modifier >> 31;\r\nu8 steer_type_mask = 2;\r\nenum mlx4_steer_type type = (gid[7] & steer_type_mask) >> 1;\r\nqpn = vhcr->in_modifier & 0xffffff;\r\nerr = get_res(dev, slave, qpn, RES_QP, &rqp);\r\nif (err)\r\nreturn err;\r\nqp.qpn = qpn;\r\nif (attach) {\r\nerr = qp_attach(dev, slave, &qp, gid, block_loopback, prot,\r\ntype, &reg_id);\r\nif (err) {\r\npr_err("Fail to attach rule to qp 0x%x\n", qpn);\r\ngoto ex_put;\r\n}\r\nerr = add_mcg_res(dev, slave, rqp, gid, prot, type, reg_id);\r\nif (err)\r\ngoto ex_detach;\r\n} else {\r\nerr = mlx4_adjust_port(dev, slave, gid, prot);\r\nif (err)\r\ngoto ex_put;\r\nerr = rem_mcg_res(dev, slave, rqp, gid, prot, type, &reg_id);\r\nif (err)\r\ngoto ex_put;\r\nerr = qp_detach(dev, &qp, gid, prot, type, reg_id);\r\nif (err)\r\npr_err("Fail to detach rule from qp 0x%x reg_id = 0x%llx\n",\r\nqpn, reg_id);\r\n}\r\nput_res(dev, slave, qpn, RES_QP);\r\nreturn err;\r\nex_detach:\r\nqp_detach(dev, &qp, gid, prot, type, reg_id);\r\nex_put:\r\nput_res(dev, slave, qpn, RES_QP);\r\nreturn err;\r\n}\r\nstatic int validate_eth_header_mac(int slave, struct _rule_hw *eth_header,\r\nstruct list_head *rlist)\r\n{\r\nstruct mac_res *res, *tmp;\r\n__be64 be_mac;\r\nif (!is_multicast_ether_addr(eth_header->eth.dst_mac) &&\r\n!is_broadcast_ether_addr(eth_header->eth.dst_mac)) {\r\nlist_for_each_entry_safe(res, tmp, rlist, list) {\r\nbe_mac = cpu_to_be64(res->mac << 16);\r\nif (ether_addr_equal((u8 *)&be_mac, eth_header->eth.dst_mac))\r\nreturn 0;\r\n}\r\npr_err("MAC %pM doesn't belong to VF %d, Steering rule rejected\n",\r\neth_header->eth.dst_mac, slave);\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic void handle_eth_header_mcast_prio(struct mlx4_net_trans_rule_hw_ctrl *ctrl,\r\nstruct _rule_hw *eth_header)\r\n{\r\nif (is_multicast_ether_addr(eth_header->eth.dst_mac) ||\r\nis_broadcast_ether_addr(eth_header->eth.dst_mac)) {\r\nstruct mlx4_net_trans_rule_hw_eth *eth =\r\n(struct mlx4_net_trans_rule_hw_eth *)eth_header;\r\nstruct _rule_hw *next_rule = (struct _rule_hw *)(eth + 1);\r\nbool last_rule = next_rule->size == 0 && next_rule->id == 0 &&\r\nnext_rule->rsvd == 0;\r\nif (last_rule)\r\nctrl->prio = cpu_to_be16(MLX4_DOMAIN_NIC);\r\n}\r\n}\r\nstatic int add_eth_header(struct mlx4_dev *dev, int slave,\r\nstruct mlx4_cmd_mailbox *inbox,\r\nstruct list_head *rlist, int header_id)\r\n{\r\nstruct mac_res *res, *tmp;\r\nu8 port;\r\nstruct mlx4_net_trans_rule_hw_ctrl *ctrl;\r\nstruct mlx4_net_trans_rule_hw_eth *eth_header;\r\nstruct mlx4_net_trans_rule_hw_ipv4 *ip_header;\r\nstruct mlx4_net_trans_rule_hw_tcp_udp *l4_header;\r\n__be64 be_mac = 0;\r\n__be64 mac_msk = cpu_to_be64(MLX4_MAC_MASK << 16);\r\nctrl = (struct mlx4_net_trans_rule_hw_ctrl *)inbox->buf;\r\nport = ctrl->port;\r\neth_header = (struct mlx4_net_trans_rule_hw_eth *)(ctrl + 1);\r\nswitch (header_id) {\r\ncase MLX4_NET_TRANS_RULE_ID_IPV4:\r\nip_header =\r\n(struct mlx4_net_trans_rule_hw_ipv4 *)(eth_header + 1);\r\nmemmove(ip_header, eth_header,\r\nsizeof(*ip_header) + sizeof(*l4_header));\r\nbreak;\r\ncase MLX4_NET_TRANS_RULE_ID_TCP:\r\ncase MLX4_NET_TRANS_RULE_ID_UDP:\r\nl4_header = (struct mlx4_net_trans_rule_hw_tcp_udp *)\r\n(eth_header + 1);\r\nmemmove(l4_header, eth_header, sizeof(*l4_header));\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nlist_for_each_entry_safe(res, tmp, rlist, list) {\r\nif (port == res->port) {\r\nbe_mac = cpu_to_be64(res->mac << 16);\r\nbreak;\r\n}\r\n}\r\nif (!be_mac) {\r\npr_err("Failed adding eth header to FS rule, Can't find matching MAC for port %d\n",\r\nport);\r\nreturn -EINVAL;\r\n}\r\nmemset(eth_header, 0, sizeof(*eth_header));\r\neth_header->size = sizeof(*eth_header) >> 2;\r\neth_header->id = cpu_to_be16(__sw_id_hw[MLX4_NET_TRANS_RULE_ID_ETH]);\r\nmemcpy(eth_header->dst_mac, &be_mac, ETH_ALEN);\r\nmemcpy(eth_header->dst_mac_msk, &mac_msk, ETH_ALEN);\r\nreturn 0;\r\n}\r\nint mlx4_UPDATE_QP_wrapper(struct mlx4_dev *dev, int slave,\r\nstruct mlx4_vhcr *vhcr,\r\nstruct mlx4_cmd_mailbox *inbox,\r\nstruct mlx4_cmd_mailbox *outbox,\r\nstruct mlx4_cmd_info *cmd_info)\r\n{\r\nint err;\r\nu32 qpn = vhcr->in_modifier & 0xffffff;\r\nstruct res_qp *rqp;\r\nu64 mac;\r\nunsigned port;\r\nu64 pri_addr_path_mask;\r\nstruct mlx4_update_qp_context *cmd;\r\nint smac_index;\r\ncmd = (struct mlx4_update_qp_context *)inbox->buf;\r\npri_addr_path_mask = be64_to_cpu(cmd->primary_addr_path_mask);\r\nif (cmd->qp_mask || cmd->secondary_addr_path_mask ||\r\n(pri_addr_path_mask & ~MLX4_UPD_QP_PATH_MASK_SUPPORTED))\r\nreturn -EPERM;\r\nif ((pri_addr_path_mask &\r\n(1ULL << MLX4_UPD_QP_PATH_MASK_ETH_SRC_CHECK_MC_LB)) &&\r\n!(dev->caps.flags2 &\r\nMLX4_DEV_CAP_FLAG2_UPDATE_QP_SRC_CHECK_LB)) {\r\nmlx4_warn(dev,\r\n"Src check LB for slave %d isn't supported\n",\r\nslave);\r\nreturn -ENOTSUPP;\r\n}\r\nerr = get_res(dev, slave, qpn, RES_QP, &rqp);\r\nif (err) {\r\nmlx4_err(dev, "Updating qpn 0x%x for slave %d rejected\n", qpn, slave);\r\nreturn err;\r\n}\r\nport = (rqp->sched_queue >> 6 & 1) + 1;\r\nif (pri_addr_path_mask & (1ULL << MLX4_UPD_QP_PATH_MASK_MAC_INDEX)) {\r\nsmac_index = cmd->qp_context.pri_path.grh_mylmc;\r\nerr = mac_find_smac_ix_in_slave(dev, slave, port,\r\nsmac_index, &mac);\r\nif (err) {\r\nmlx4_err(dev, "Failed to update qpn 0x%x, MAC is invalid. smac_ix: %d\n",\r\nqpn, smac_index);\r\ngoto err_mac;\r\n}\r\n}\r\nerr = mlx4_cmd(dev, inbox->dma,\r\nvhcr->in_modifier, 0,\r\nMLX4_CMD_UPDATE_QP, MLX4_CMD_TIME_CLASS_A,\r\nMLX4_CMD_NATIVE);\r\nif (err) {\r\nmlx4_err(dev, "Failed to update qpn on qpn 0x%x, command failed\n", qpn);\r\ngoto err_mac;\r\n}\r\nerr_mac:\r\nput_res(dev, slave, qpn, RES_QP);\r\nreturn err;\r\n}\r\nstatic u32 qp_attach_mbox_size(void *mbox)\r\n{\r\nu32 size = sizeof(struct mlx4_net_trans_rule_hw_ctrl);\r\nstruct _rule_hw *rule_header;\r\nrule_header = (struct _rule_hw *)(mbox + size);\r\nwhile (rule_header->size) {\r\nsize += rule_header->size * sizeof(u32);\r\nrule_header += 1;\r\n}\r\nreturn size;\r\n}\r\nint mlx4_QP_FLOW_STEERING_ATTACH_wrapper(struct mlx4_dev *dev, int slave,\r\nstruct mlx4_vhcr *vhcr,\r\nstruct mlx4_cmd_mailbox *inbox,\r\nstruct mlx4_cmd_mailbox *outbox,\r\nstruct mlx4_cmd_info *cmd)\r\n{\r\nstruct mlx4_priv *priv = mlx4_priv(dev);\r\nstruct mlx4_resource_tracker *tracker = &priv->mfunc.master.res_tracker;\r\nstruct list_head *rlist = &tracker->slave_list[slave].res_list[RES_MAC];\r\nint err;\r\nint qpn;\r\nstruct res_qp *rqp;\r\nstruct mlx4_net_trans_rule_hw_ctrl *ctrl;\r\nstruct _rule_hw *rule_header;\r\nint header_id;\r\nstruct res_fs_rule *rrule;\r\nu32 mbox_size;\r\nif (dev->caps.steering_mode !=\r\nMLX4_STEERING_MODE_DEVICE_MANAGED)\r\nreturn -EOPNOTSUPP;\r\nctrl = (struct mlx4_net_trans_rule_hw_ctrl *)inbox->buf;\r\nerr = mlx4_slave_convert_port(dev, slave, ctrl->port);\r\nif (err <= 0)\r\nreturn -EINVAL;\r\nctrl->port = err;\r\nqpn = be32_to_cpu(ctrl->qpn) & 0xffffff;\r\nerr = get_res(dev, slave, qpn, RES_QP, &rqp);\r\nif (err) {\r\npr_err("Steering rule with qpn 0x%x rejected\n", qpn);\r\nreturn err;\r\n}\r\nrule_header = (struct _rule_hw *)(ctrl + 1);\r\nheader_id = map_hw_to_sw_id(be16_to_cpu(rule_header->id));\r\nif (header_id == MLX4_NET_TRANS_RULE_ID_ETH)\r\nhandle_eth_header_mcast_prio(ctrl, rule_header);\r\nif (slave == dev->caps.function)\r\ngoto execute;\r\nswitch (header_id) {\r\ncase MLX4_NET_TRANS_RULE_ID_ETH:\r\nif (validate_eth_header_mac(slave, rule_header, rlist)) {\r\nerr = -EINVAL;\r\ngoto err_put_qp;\r\n}\r\nbreak;\r\ncase MLX4_NET_TRANS_RULE_ID_IB:\r\nbreak;\r\ncase MLX4_NET_TRANS_RULE_ID_IPV4:\r\ncase MLX4_NET_TRANS_RULE_ID_TCP:\r\ncase MLX4_NET_TRANS_RULE_ID_UDP:\r\npr_warn("Can't attach FS rule without L2 headers, adding L2 header\n");\r\nif (add_eth_header(dev, slave, inbox, rlist, header_id)) {\r\nerr = -EINVAL;\r\ngoto err_put_qp;\r\n}\r\nvhcr->in_modifier +=\r\nsizeof(struct mlx4_net_trans_rule_hw_eth) >> 2;\r\nbreak;\r\ndefault:\r\npr_err("Corrupted mailbox\n");\r\nerr = -EINVAL;\r\ngoto err_put_qp;\r\n}\r\nexecute:\r\nerr = mlx4_cmd_imm(dev, inbox->dma, &vhcr->out_param,\r\nvhcr->in_modifier, 0,\r\nMLX4_QP_FLOW_STEERING_ATTACH, MLX4_CMD_TIME_CLASS_A,\r\nMLX4_CMD_NATIVE);\r\nif (err)\r\ngoto err_put_qp;\r\nerr = add_res_range(dev, slave, vhcr->out_param, 1, RES_FS_RULE, qpn);\r\nif (err) {\r\nmlx4_err(dev, "Fail to add flow steering resources\n");\r\ngoto err_detach;\r\n}\r\nerr = get_res(dev, slave, vhcr->out_param, RES_FS_RULE, &rrule);\r\nif (err)\r\ngoto err_detach;\r\nmbox_size = qp_attach_mbox_size(inbox->buf);\r\nrrule->mirr_mbox = kmalloc(mbox_size, GFP_KERNEL);\r\nif (!rrule->mirr_mbox) {\r\nerr = -ENOMEM;\r\ngoto err_put_rule;\r\n}\r\nrrule->mirr_mbox_size = mbox_size;\r\nrrule->mirr_rule_id = 0;\r\nmemcpy(rrule->mirr_mbox, inbox->buf, mbox_size);\r\nctrl = (struct mlx4_net_trans_rule_hw_ctrl *)rrule->mirr_mbox;\r\nif (ctrl->port == 1)\r\nctrl->port = 2;\r\nelse\r\nctrl->port = 1;\r\nif (mlx4_is_bonded(dev))\r\nmlx4_do_mirror_rule(dev, rrule);\r\natomic_inc(&rqp->ref_count);\r\nerr_put_rule:\r\nput_res(dev, slave, vhcr->out_param, RES_FS_RULE);\r\nerr_detach:\r\nif (err)\r\nmlx4_cmd(dev, vhcr->out_param, 0, 0,\r\nMLX4_QP_FLOW_STEERING_DETACH, MLX4_CMD_TIME_CLASS_A,\r\nMLX4_CMD_NATIVE);\r\nerr_put_qp:\r\nput_res(dev, slave, qpn, RES_QP);\r\nreturn err;\r\n}\r\nstatic int mlx4_undo_mirror_rule(struct mlx4_dev *dev, struct res_fs_rule *fs_rule)\r\n{\r\nint err;\r\nerr = rem_res_range(dev, fs_rule->com.owner, fs_rule->com.res_id, 1, RES_FS_RULE, 0);\r\nif (err) {\r\nmlx4_err(dev, "Fail to remove flow steering resources\n");\r\nreturn err;\r\n}\r\nmlx4_cmd(dev, fs_rule->com.res_id, 0, 0, MLX4_QP_FLOW_STEERING_DETACH,\r\nMLX4_CMD_TIME_CLASS_A, MLX4_CMD_NATIVE);\r\nreturn 0;\r\n}\r\nint mlx4_QP_FLOW_STEERING_DETACH_wrapper(struct mlx4_dev *dev, int slave,\r\nstruct mlx4_vhcr *vhcr,\r\nstruct mlx4_cmd_mailbox *inbox,\r\nstruct mlx4_cmd_mailbox *outbox,\r\nstruct mlx4_cmd_info *cmd)\r\n{\r\nint err;\r\nstruct res_qp *rqp;\r\nstruct res_fs_rule *rrule;\r\nu64 mirr_reg_id;\r\nif (dev->caps.steering_mode !=\r\nMLX4_STEERING_MODE_DEVICE_MANAGED)\r\nreturn -EOPNOTSUPP;\r\nerr = get_res(dev, slave, vhcr->in_param, RES_FS_RULE, &rrule);\r\nif (err)\r\nreturn err;\r\nif (!rrule->mirr_mbox) {\r\nmlx4_err(dev, "Mirror rules cannot be removed explicitly\n");\r\nput_res(dev, slave, vhcr->in_param, RES_FS_RULE);\r\nreturn -EINVAL;\r\n}\r\nmirr_reg_id = rrule->mirr_rule_id;\r\nkfree(rrule->mirr_mbox);\r\nput_res(dev, slave, vhcr->in_param, RES_FS_RULE);\r\nerr = get_res(dev, slave, rrule->qpn, RES_QP, &rqp);\r\nif (err)\r\nreturn err;\r\nif (mirr_reg_id && mlx4_is_bonded(dev)) {\r\nerr = get_res(dev, slave, mirr_reg_id, RES_FS_RULE, &rrule);\r\nif (err) {\r\nmlx4_err(dev, "Fail to get resource of mirror rule\n");\r\n} else {\r\nput_res(dev, slave, mirr_reg_id, RES_FS_RULE);\r\nmlx4_undo_mirror_rule(dev, rrule);\r\n}\r\n}\r\nerr = rem_res_range(dev, slave, vhcr->in_param, 1, RES_FS_RULE, 0);\r\nif (err) {\r\nmlx4_err(dev, "Fail to remove flow steering resources\n");\r\ngoto out;\r\n}\r\nerr = mlx4_cmd(dev, vhcr->in_param, 0, 0,\r\nMLX4_QP_FLOW_STEERING_DETACH, MLX4_CMD_TIME_CLASS_A,\r\nMLX4_CMD_NATIVE);\r\nif (!err)\r\natomic_dec(&rqp->ref_count);\r\nout:\r\nput_res(dev, slave, rrule->qpn, RES_QP);\r\nreturn err;\r\n}\r\nint mlx4_QUERY_IF_STAT_wrapper(struct mlx4_dev *dev, int slave,\r\nstruct mlx4_vhcr *vhcr,\r\nstruct mlx4_cmd_mailbox *inbox,\r\nstruct mlx4_cmd_mailbox *outbox,\r\nstruct mlx4_cmd_info *cmd)\r\n{\r\nint err;\r\nint index = vhcr->in_modifier & 0xffff;\r\nerr = get_res(dev, slave, index, RES_COUNTER, NULL);\r\nif (err)\r\nreturn err;\r\nerr = mlx4_DMA_wrapper(dev, slave, vhcr, inbox, outbox, cmd);\r\nput_res(dev, slave, index, RES_COUNTER);\r\nreturn err;\r\n}\r\nstatic void detach_qp(struct mlx4_dev *dev, int slave, struct res_qp *rqp)\r\n{\r\nstruct res_gid *rgid;\r\nstruct res_gid *tmp;\r\nstruct mlx4_qp qp;\r\nlist_for_each_entry_safe(rgid, tmp, &rqp->mcg_list, list) {\r\nswitch (dev->caps.steering_mode) {\r\ncase MLX4_STEERING_MODE_DEVICE_MANAGED:\r\nmlx4_flow_detach(dev, rgid->reg_id);\r\nbreak;\r\ncase MLX4_STEERING_MODE_B0:\r\nqp.qpn = rqp->local_qpn;\r\n(void) mlx4_qp_detach_common(dev, &qp, rgid->gid,\r\nrgid->prot, rgid->steer);\r\nbreak;\r\n}\r\nlist_del(&rgid->list);\r\nkfree(rgid);\r\n}\r\n}\r\nstatic int _move_all_busy(struct mlx4_dev *dev, int slave,\r\nenum mlx4_resource type, int print)\r\n{\r\nstruct mlx4_priv *priv = mlx4_priv(dev);\r\nstruct mlx4_resource_tracker *tracker =\r\n&priv->mfunc.master.res_tracker;\r\nstruct list_head *rlist = &tracker->slave_list[slave].res_list[type];\r\nstruct res_common *r;\r\nstruct res_common *tmp;\r\nint busy;\r\nbusy = 0;\r\nspin_lock_irq(mlx4_tlock(dev));\r\nlist_for_each_entry_safe(r, tmp, rlist, list) {\r\nif (r->owner == slave) {\r\nif (!r->removing) {\r\nif (r->state == RES_ANY_BUSY) {\r\nif (print)\r\nmlx4_dbg(dev,\r\n"%s id 0x%llx is busy\n",\r\nresource_str(type),\r\nr->res_id);\r\n++busy;\r\n} else {\r\nr->from_state = r->state;\r\nr->state = RES_ANY_BUSY;\r\nr->removing = 1;\r\n}\r\n}\r\n}\r\n}\r\nspin_unlock_irq(mlx4_tlock(dev));\r\nreturn busy;\r\n}\r\nstatic int move_all_busy(struct mlx4_dev *dev, int slave,\r\nenum mlx4_resource type)\r\n{\r\nunsigned long begin;\r\nint busy;\r\nbegin = jiffies;\r\ndo {\r\nbusy = _move_all_busy(dev, slave, type, 0);\r\nif (time_after(jiffies, begin + 5 * HZ))\r\nbreak;\r\nif (busy)\r\ncond_resched();\r\n} while (busy);\r\nif (busy)\r\nbusy = _move_all_busy(dev, slave, type, 1);\r\nreturn busy;\r\n}\r\nstatic void rem_slave_qps(struct mlx4_dev *dev, int slave)\r\n{\r\nstruct mlx4_priv *priv = mlx4_priv(dev);\r\nstruct mlx4_resource_tracker *tracker = &priv->mfunc.master.res_tracker;\r\nstruct list_head *qp_list =\r\n&tracker->slave_list[slave].res_list[RES_QP];\r\nstruct res_qp *qp;\r\nstruct res_qp *tmp;\r\nint state;\r\nu64 in_param;\r\nint qpn;\r\nint err;\r\nerr = move_all_busy(dev, slave, RES_QP);\r\nif (err)\r\nmlx4_warn(dev, "rem_slave_qps: Could not move all qps to busy for slave %d\n",\r\nslave);\r\nspin_lock_irq(mlx4_tlock(dev));\r\nlist_for_each_entry_safe(qp, tmp, qp_list, com.list) {\r\nspin_unlock_irq(mlx4_tlock(dev));\r\nif (qp->com.owner == slave) {\r\nqpn = qp->com.res_id;\r\ndetach_qp(dev, slave, qp);\r\nstate = qp->com.from_state;\r\nwhile (state != 0) {\r\nswitch (state) {\r\ncase RES_QP_RESERVED:\r\nspin_lock_irq(mlx4_tlock(dev));\r\nrb_erase(&qp->com.node,\r\n&tracker->res_tree[RES_QP]);\r\nlist_del(&qp->com.list);\r\nspin_unlock_irq(mlx4_tlock(dev));\r\nif (!valid_reserved(dev, slave, qpn)) {\r\n__mlx4_qp_release_range(dev, qpn, 1);\r\nmlx4_release_resource(dev, slave,\r\nRES_QP, 1, 0);\r\n}\r\nkfree(qp);\r\nstate = 0;\r\nbreak;\r\ncase RES_QP_MAPPED:\r\nif (!valid_reserved(dev, slave, qpn))\r\n__mlx4_qp_free_icm(dev, qpn);\r\nstate = RES_QP_RESERVED;\r\nbreak;\r\ncase RES_QP_HW:\r\nin_param = slave;\r\nerr = mlx4_cmd(dev, in_param,\r\nqp->local_qpn, 2,\r\nMLX4_CMD_2RST_QP,\r\nMLX4_CMD_TIME_CLASS_A,\r\nMLX4_CMD_NATIVE);\r\nif (err)\r\nmlx4_dbg(dev, "rem_slave_qps: failed to move slave %d qpn %d to reset\n",\r\nslave, qp->local_qpn);\r\natomic_dec(&qp->rcq->ref_count);\r\natomic_dec(&qp->scq->ref_count);\r\natomic_dec(&qp->mtt->ref_count);\r\nif (qp->srq)\r\natomic_dec(&qp->srq->ref_count);\r\nstate = RES_QP_MAPPED;\r\nbreak;\r\ndefault:\r\nstate = 0;\r\n}\r\n}\r\n}\r\nspin_lock_irq(mlx4_tlock(dev));\r\n}\r\nspin_unlock_irq(mlx4_tlock(dev));\r\n}\r\nstatic void rem_slave_srqs(struct mlx4_dev *dev, int slave)\r\n{\r\nstruct mlx4_priv *priv = mlx4_priv(dev);\r\nstruct mlx4_resource_tracker *tracker = &priv->mfunc.master.res_tracker;\r\nstruct list_head *srq_list =\r\n&tracker->slave_list[slave].res_list[RES_SRQ];\r\nstruct res_srq *srq;\r\nstruct res_srq *tmp;\r\nint state;\r\nu64 in_param;\r\nLIST_HEAD(tlist);\r\nint srqn;\r\nint err;\r\nerr = move_all_busy(dev, slave, RES_SRQ);\r\nif (err)\r\nmlx4_warn(dev, "rem_slave_srqs: Could not move all srqs - too busy for slave %d\n",\r\nslave);\r\nspin_lock_irq(mlx4_tlock(dev));\r\nlist_for_each_entry_safe(srq, tmp, srq_list, com.list) {\r\nspin_unlock_irq(mlx4_tlock(dev));\r\nif (srq->com.owner == slave) {\r\nsrqn = srq->com.res_id;\r\nstate = srq->com.from_state;\r\nwhile (state != 0) {\r\nswitch (state) {\r\ncase RES_SRQ_ALLOCATED:\r\n__mlx4_srq_free_icm(dev, srqn);\r\nspin_lock_irq(mlx4_tlock(dev));\r\nrb_erase(&srq->com.node,\r\n&tracker->res_tree[RES_SRQ]);\r\nlist_del(&srq->com.list);\r\nspin_unlock_irq(mlx4_tlock(dev));\r\nmlx4_release_resource(dev, slave,\r\nRES_SRQ, 1, 0);\r\nkfree(srq);\r\nstate = 0;\r\nbreak;\r\ncase RES_SRQ_HW:\r\nin_param = slave;\r\nerr = mlx4_cmd(dev, in_param, srqn, 1,\r\nMLX4_CMD_HW2SW_SRQ,\r\nMLX4_CMD_TIME_CLASS_A,\r\nMLX4_CMD_NATIVE);\r\nif (err)\r\nmlx4_dbg(dev, "rem_slave_srqs: failed to move slave %d srq %d to SW ownership\n",\r\nslave, srqn);\r\natomic_dec(&srq->mtt->ref_count);\r\nif (srq->cq)\r\natomic_dec(&srq->cq->ref_count);\r\nstate = RES_SRQ_ALLOCATED;\r\nbreak;\r\ndefault:\r\nstate = 0;\r\n}\r\n}\r\n}\r\nspin_lock_irq(mlx4_tlock(dev));\r\n}\r\nspin_unlock_irq(mlx4_tlock(dev));\r\n}\r\nstatic void rem_slave_cqs(struct mlx4_dev *dev, int slave)\r\n{\r\nstruct mlx4_priv *priv = mlx4_priv(dev);\r\nstruct mlx4_resource_tracker *tracker = &priv->mfunc.master.res_tracker;\r\nstruct list_head *cq_list =\r\n&tracker->slave_list[slave].res_list[RES_CQ];\r\nstruct res_cq *cq;\r\nstruct res_cq *tmp;\r\nint state;\r\nu64 in_param;\r\nLIST_HEAD(tlist);\r\nint cqn;\r\nint err;\r\nerr = move_all_busy(dev, slave, RES_CQ);\r\nif (err)\r\nmlx4_warn(dev, "rem_slave_cqs: Could not move all cqs - too busy for slave %d\n",\r\nslave);\r\nspin_lock_irq(mlx4_tlock(dev));\r\nlist_for_each_entry_safe(cq, tmp, cq_list, com.list) {\r\nspin_unlock_irq(mlx4_tlock(dev));\r\nif (cq->com.owner == slave && !atomic_read(&cq->ref_count)) {\r\ncqn = cq->com.res_id;\r\nstate = cq->com.from_state;\r\nwhile (state != 0) {\r\nswitch (state) {\r\ncase RES_CQ_ALLOCATED:\r\n__mlx4_cq_free_icm(dev, cqn);\r\nspin_lock_irq(mlx4_tlock(dev));\r\nrb_erase(&cq->com.node,\r\n&tracker->res_tree[RES_CQ]);\r\nlist_del(&cq->com.list);\r\nspin_unlock_irq(mlx4_tlock(dev));\r\nmlx4_release_resource(dev, slave,\r\nRES_CQ, 1, 0);\r\nkfree(cq);\r\nstate = 0;\r\nbreak;\r\ncase RES_CQ_HW:\r\nin_param = slave;\r\nerr = mlx4_cmd(dev, in_param, cqn, 1,\r\nMLX4_CMD_HW2SW_CQ,\r\nMLX4_CMD_TIME_CLASS_A,\r\nMLX4_CMD_NATIVE);\r\nif (err)\r\nmlx4_dbg(dev, "rem_slave_cqs: failed to move slave %d cq %d to SW ownership\n",\r\nslave, cqn);\r\natomic_dec(&cq->mtt->ref_count);\r\nstate = RES_CQ_ALLOCATED;\r\nbreak;\r\ndefault:\r\nstate = 0;\r\n}\r\n}\r\n}\r\nspin_lock_irq(mlx4_tlock(dev));\r\n}\r\nspin_unlock_irq(mlx4_tlock(dev));\r\n}\r\nstatic void rem_slave_mrs(struct mlx4_dev *dev, int slave)\r\n{\r\nstruct mlx4_priv *priv = mlx4_priv(dev);\r\nstruct mlx4_resource_tracker *tracker = &priv->mfunc.master.res_tracker;\r\nstruct list_head *mpt_list =\r\n&tracker->slave_list[slave].res_list[RES_MPT];\r\nstruct res_mpt *mpt;\r\nstruct res_mpt *tmp;\r\nint state;\r\nu64 in_param;\r\nLIST_HEAD(tlist);\r\nint mptn;\r\nint err;\r\nerr = move_all_busy(dev, slave, RES_MPT);\r\nif (err)\r\nmlx4_warn(dev, "rem_slave_mrs: Could not move all mpts - too busy for slave %d\n",\r\nslave);\r\nspin_lock_irq(mlx4_tlock(dev));\r\nlist_for_each_entry_safe(mpt, tmp, mpt_list, com.list) {\r\nspin_unlock_irq(mlx4_tlock(dev));\r\nif (mpt->com.owner == slave) {\r\nmptn = mpt->com.res_id;\r\nstate = mpt->com.from_state;\r\nwhile (state != 0) {\r\nswitch (state) {\r\ncase RES_MPT_RESERVED:\r\n__mlx4_mpt_release(dev, mpt->key);\r\nspin_lock_irq(mlx4_tlock(dev));\r\nrb_erase(&mpt->com.node,\r\n&tracker->res_tree[RES_MPT]);\r\nlist_del(&mpt->com.list);\r\nspin_unlock_irq(mlx4_tlock(dev));\r\nmlx4_release_resource(dev, slave,\r\nRES_MPT, 1, 0);\r\nkfree(mpt);\r\nstate = 0;\r\nbreak;\r\ncase RES_MPT_MAPPED:\r\n__mlx4_mpt_free_icm(dev, mpt->key);\r\nstate = RES_MPT_RESERVED;\r\nbreak;\r\ncase RES_MPT_HW:\r\nin_param = slave;\r\nerr = mlx4_cmd(dev, in_param, mptn, 0,\r\nMLX4_CMD_HW2SW_MPT,\r\nMLX4_CMD_TIME_CLASS_A,\r\nMLX4_CMD_NATIVE);\r\nif (err)\r\nmlx4_dbg(dev, "rem_slave_mrs: failed to move slave %d mpt %d to SW ownership\n",\r\nslave, mptn);\r\nif (mpt->mtt)\r\natomic_dec(&mpt->mtt->ref_count);\r\nstate = RES_MPT_MAPPED;\r\nbreak;\r\ndefault:\r\nstate = 0;\r\n}\r\n}\r\n}\r\nspin_lock_irq(mlx4_tlock(dev));\r\n}\r\nspin_unlock_irq(mlx4_tlock(dev));\r\n}\r\nstatic void rem_slave_mtts(struct mlx4_dev *dev, int slave)\r\n{\r\nstruct mlx4_priv *priv = mlx4_priv(dev);\r\nstruct mlx4_resource_tracker *tracker =\r\n&priv->mfunc.master.res_tracker;\r\nstruct list_head *mtt_list =\r\n&tracker->slave_list[slave].res_list[RES_MTT];\r\nstruct res_mtt *mtt;\r\nstruct res_mtt *tmp;\r\nint state;\r\nLIST_HEAD(tlist);\r\nint base;\r\nint err;\r\nerr = move_all_busy(dev, slave, RES_MTT);\r\nif (err)\r\nmlx4_warn(dev, "rem_slave_mtts: Could not move all mtts - too busy for slave %d\n",\r\nslave);\r\nspin_lock_irq(mlx4_tlock(dev));\r\nlist_for_each_entry_safe(mtt, tmp, mtt_list, com.list) {\r\nspin_unlock_irq(mlx4_tlock(dev));\r\nif (mtt->com.owner == slave) {\r\nbase = mtt->com.res_id;\r\nstate = mtt->com.from_state;\r\nwhile (state != 0) {\r\nswitch (state) {\r\ncase RES_MTT_ALLOCATED:\r\n__mlx4_free_mtt_range(dev, base,\r\nmtt->order);\r\nspin_lock_irq(mlx4_tlock(dev));\r\nrb_erase(&mtt->com.node,\r\n&tracker->res_tree[RES_MTT]);\r\nlist_del(&mtt->com.list);\r\nspin_unlock_irq(mlx4_tlock(dev));\r\nmlx4_release_resource(dev, slave, RES_MTT,\r\n1 << mtt->order, 0);\r\nkfree(mtt);\r\nstate = 0;\r\nbreak;\r\ndefault:\r\nstate = 0;\r\n}\r\n}\r\n}\r\nspin_lock_irq(mlx4_tlock(dev));\r\n}\r\nspin_unlock_irq(mlx4_tlock(dev));\r\n}\r\nstatic int mlx4_do_mirror_rule(struct mlx4_dev *dev, struct res_fs_rule *fs_rule)\r\n{\r\nstruct mlx4_cmd_mailbox *mailbox;\r\nint err;\r\nstruct res_fs_rule *mirr_rule;\r\nu64 reg_id;\r\nmailbox = mlx4_alloc_cmd_mailbox(dev);\r\nif (IS_ERR(mailbox))\r\nreturn PTR_ERR(mailbox);\r\nif (!fs_rule->mirr_mbox) {\r\nmlx4_err(dev, "rule mirroring mailbox is null\n");\r\nreturn -EINVAL;\r\n}\r\nmemcpy(mailbox->buf, fs_rule->mirr_mbox, fs_rule->mirr_mbox_size);\r\nerr = mlx4_cmd_imm(dev, mailbox->dma, &reg_id, fs_rule->mirr_mbox_size >> 2, 0,\r\nMLX4_QP_FLOW_STEERING_ATTACH, MLX4_CMD_TIME_CLASS_A,\r\nMLX4_CMD_NATIVE);\r\nmlx4_free_cmd_mailbox(dev, mailbox);\r\nif (err)\r\ngoto err;\r\nerr = add_res_range(dev, fs_rule->com.owner, reg_id, 1, RES_FS_RULE, fs_rule->qpn);\r\nif (err)\r\ngoto err_detach;\r\nerr = get_res(dev, fs_rule->com.owner, reg_id, RES_FS_RULE, &mirr_rule);\r\nif (err)\r\ngoto err_rem;\r\nfs_rule->mirr_rule_id = reg_id;\r\nmirr_rule->mirr_rule_id = 0;\r\nmirr_rule->mirr_mbox_size = 0;\r\nmirr_rule->mirr_mbox = NULL;\r\nput_res(dev, fs_rule->com.owner, reg_id, RES_FS_RULE);\r\nreturn 0;\r\nerr_rem:\r\nrem_res_range(dev, fs_rule->com.owner, reg_id, 1, RES_FS_RULE, 0);\r\nerr_detach:\r\nmlx4_cmd(dev, reg_id, 0, 0, MLX4_QP_FLOW_STEERING_DETACH,\r\nMLX4_CMD_TIME_CLASS_A, MLX4_CMD_NATIVE);\r\nerr:\r\nreturn err;\r\n}\r\nstatic int mlx4_mirror_fs_rules(struct mlx4_dev *dev, bool bond)\r\n{\r\nstruct mlx4_priv *priv = mlx4_priv(dev);\r\nstruct mlx4_resource_tracker *tracker =\r\n&priv->mfunc.master.res_tracker;\r\nstruct rb_root *root = &tracker->res_tree[RES_FS_RULE];\r\nstruct rb_node *p;\r\nstruct res_fs_rule *fs_rule;\r\nint err = 0;\r\nLIST_HEAD(mirr_list);\r\nfor (p = rb_first(root); p; p = rb_next(p)) {\r\nfs_rule = rb_entry(p, struct res_fs_rule, com.node);\r\nif ((bond && fs_rule->mirr_mbox_size) ||\r\n(!bond && !fs_rule->mirr_mbox_size))\r\nlist_add_tail(&fs_rule->mirr_list, &mirr_list);\r\n}\r\nlist_for_each_entry(fs_rule, &mirr_list, mirr_list) {\r\nif (bond)\r\nerr += mlx4_do_mirror_rule(dev, fs_rule);\r\nelse\r\nerr += mlx4_undo_mirror_rule(dev, fs_rule);\r\n}\r\nreturn err;\r\n}\r\nint mlx4_bond_fs_rules(struct mlx4_dev *dev)\r\n{\r\nreturn mlx4_mirror_fs_rules(dev, true);\r\n}\r\nint mlx4_unbond_fs_rules(struct mlx4_dev *dev)\r\n{\r\nreturn mlx4_mirror_fs_rules(dev, false);\r\n}\r\nstatic void rem_slave_fs_rule(struct mlx4_dev *dev, int slave)\r\n{\r\nstruct mlx4_priv *priv = mlx4_priv(dev);\r\nstruct mlx4_resource_tracker *tracker =\r\n&priv->mfunc.master.res_tracker;\r\nstruct list_head *fs_rule_list =\r\n&tracker->slave_list[slave].res_list[RES_FS_RULE];\r\nstruct res_fs_rule *fs_rule;\r\nstruct res_fs_rule *tmp;\r\nint state;\r\nu64 base;\r\nint err;\r\nerr = move_all_busy(dev, slave, RES_FS_RULE);\r\nif (err)\r\nmlx4_warn(dev, "rem_slave_fs_rule: Could not move all mtts to busy for slave %d\n",\r\nslave);\r\nspin_lock_irq(mlx4_tlock(dev));\r\nlist_for_each_entry_safe(fs_rule, tmp, fs_rule_list, com.list) {\r\nspin_unlock_irq(mlx4_tlock(dev));\r\nif (fs_rule->com.owner == slave) {\r\nbase = fs_rule->com.res_id;\r\nstate = fs_rule->com.from_state;\r\nwhile (state != 0) {\r\nswitch (state) {\r\ncase RES_FS_RULE_ALLOCATED:\r\nerr = mlx4_cmd(dev, base, 0, 0,\r\nMLX4_QP_FLOW_STEERING_DETACH,\r\nMLX4_CMD_TIME_CLASS_A,\r\nMLX4_CMD_NATIVE);\r\nspin_lock_irq(mlx4_tlock(dev));\r\nrb_erase(&fs_rule->com.node,\r\n&tracker->res_tree[RES_FS_RULE]);\r\nlist_del(&fs_rule->com.list);\r\nspin_unlock_irq(mlx4_tlock(dev));\r\nkfree(fs_rule);\r\nstate = 0;\r\nbreak;\r\ndefault:\r\nstate = 0;\r\n}\r\n}\r\n}\r\nspin_lock_irq(mlx4_tlock(dev));\r\n}\r\nspin_unlock_irq(mlx4_tlock(dev));\r\n}\r\nstatic void rem_slave_eqs(struct mlx4_dev *dev, int slave)\r\n{\r\nstruct mlx4_priv *priv = mlx4_priv(dev);\r\nstruct mlx4_resource_tracker *tracker = &priv->mfunc.master.res_tracker;\r\nstruct list_head *eq_list =\r\n&tracker->slave_list[slave].res_list[RES_EQ];\r\nstruct res_eq *eq;\r\nstruct res_eq *tmp;\r\nint err;\r\nint state;\r\nLIST_HEAD(tlist);\r\nint eqn;\r\nerr = move_all_busy(dev, slave, RES_EQ);\r\nif (err)\r\nmlx4_warn(dev, "rem_slave_eqs: Could not move all eqs - too busy for slave %d\n",\r\nslave);\r\nspin_lock_irq(mlx4_tlock(dev));\r\nlist_for_each_entry_safe(eq, tmp, eq_list, com.list) {\r\nspin_unlock_irq(mlx4_tlock(dev));\r\nif (eq->com.owner == slave) {\r\neqn = eq->com.res_id;\r\nstate = eq->com.from_state;\r\nwhile (state != 0) {\r\nswitch (state) {\r\ncase RES_EQ_RESERVED:\r\nspin_lock_irq(mlx4_tlock(dev));\r\nrb_erase(&eq->com.node,\r\n&tracker->res_tree[RES_EQ]);\r\nlist_del(&eq->com.list);\r\nspin_unlock_irq(mlx4_tlock(dev));\r\nkfree(eq);\r\nstate = 0;\r\nbreak;\r\ncase RES_EQ_HW:\r\nerr = mlx4_cmd(dev, slave, eqn & 0x3ff,\r\n1, MLX4_CMD_HW2SW_EQ,\r\nMLX4_CMD_TIME_CLASS_A,\r\nMLX4_CMD_NATIVE);\r\nif (err)\r\nmlx4_dbg(dev, "rem_slave_eqs: failed to move slave %d eqs %d to SW ownership\n",\r\nslave, eqn & 0x3ff);\r\natomic_dec(&eq->mtt->ref_count);\r\nstate = RES_EQ_RESERVED;\r\nbreak;\r\ndefault:\r\nstate = 0;\r\n}\r\n}\r\n}\r\nspin_lock_irq(mlx4_tlock(dev));\r\n}\r\nspin_unlock_irq(mlx4_tlock(dev));\r\n}\r\nstatic void rem_slave_counters(struct mlx4_dev *dev, int slave)\r\n{\r\nstruct mlx4_priv *priv = mlx4_priv(dev);\r\nstruct mlx4_resource_tracker *tracker = &priv->mfunc.master.res_tracker;\r\nstruct list_head *counter_list =\r\n&tracker->slave_list[slave].res_list[RES_COUNTER];\r\nstruct res_counter *counter;\r\nstruct res_counter *tmp;\r\nint err;\r\nint *counters_arr = NULL;\r\nint i, j;\r\nerr = move_all_busy(dev, slave, RES_COUNTER);\r\nif (err)\r\nmlx4_warn(dev, "rem_slave_counters: Could not move all counters - too busy for slave %d\n",\r\nslave);\r\ncounters_arr = kmalloc_array(dev->caps.max_counters,\r\nsizeof(*counters_arr), GFP_KERNEL);\r\nif (!counters_arr)\r\nreturn;\r\ndo {\r\ni = 0;\r\nj = 0;\r\nspin_lock_irq(mlx4_tlock(dev));\r\nlist_for_each_entry_safe(counter, tmp, counter_list, com.list) {\r\nif (counter->com.owner == slave) {\r\ncounters_arr[i++] = counter->com.res_id;\r\nrb_erase(&counter->com.node,\r\n&tracker->res_tree[RES_COUNTER]);\r\nlist_del(&counter->com.list);\r\nkfree(counter);\r\n}\r\n}\r\nspin_unlock_irq(mlx4_tlock(dev));\r\nwhile (j < i) {\r\n__mlx4_counter_free(dev, counters_arr[j++]);\r\nmlx4_release_resource(dev, slave, RES_COUNTER, 1, 0);\r\n}\r\n} while (i);\r\nkfree(counters_arr);\r\n}\r\nstatic void rem_slave_xrcdns(struct mlx4_dev *dev, int slave)\r\n{\r\nstruct mlx4_priv *priv = mlx4_priv(dev);\r\nstruct mlx4_resource_tracker *tracker = &priv->mfunc.master.res_tracker;\r\nstruct list_head *xrcdn_list =\r\n&tracker->slave_list[slave].res_list[RES_XRCD];\r\nstruct res_xrcdn *xrcd;\r\nstruct res_xrcdn *tmp;\r\nint err;\r\nint xrcdn;\r\nerr = move_all_busy(dev, slave, RES_XRCD);\r\nif (err)\r\nmlx4_warn(dev, "rem_slave_xrcdns: Could not move all xrcdns - too busy for slave %d\n",\r\nslave);\r\nspin_lock_irq(mlx4_tlock(dev));\r\nlist_for_each_entry_safe(xrcd, tmp, xrcdn_list, com.list) {\r\nif (xrcd->com.owner == slave) {\r\nxrcdn = xrcd->com.res_id;\r\nrb_erase(&xrcd->com.node, &tracker->res_tree[RES_XRCD]);\r\nlist_del(&xrcd->com.list);\r\nkfree(xrcd);\r\n__mlx4_xrcd_free(dev, xrcdn);\r\n}\r\n}\r\nspin_unlock_irq(mlx4_tlock(dev));\r\n}\r\nvoid mlx4_delete_all_resources_for_slave(struct mlx4_dev *dev, int slave)\r\n{\r\nstruct mlx4_priv *priv = mlx4_priv(dev);\r\nmlx4_reset_roce_gids(dev, slave);\r\nmutex_lock(&priv->mfunc.master.res_tracker.slave_list[slave].mutex);\r\nrem_slave_vlans(dev, slave);\r\nrem_slave_macs(dev, slave);\r\nrem_slave_fs_rule(dev, slave);\r\nrem_slave_qps(dev, slave);\r\nrem_slave_srqs(dev, slave);\r\nrem_slave_cqs(dev, slave);\r\nrem_slave_mrs(dev, slave);\r\nrem_slave_eqs(dev, slave);\r\nrem_slave_mtts(dev, slave);\r\nrem_slave_counters(dev, slave);\r\nrem_slave_xrcdns(dev, slave);\r\nmutex_unlock(&priv->mfunc.master.res_tracker.slave_list[slave].mutex);\r\n}\r\nvoid mlx4_vf_immed_vlan_work_handler(struct work_struct *_work)\r\n{\r\nstruct mlx4_vf_immed_vlan_work *work =\r\ncontainer_of(_work, struct mlx4_vf_immed_vlan_work, work);\r\nstruct mlx4_cmd_mailbox *mailbox;\r\nstruct mlx4_update_qp_context *upd_context;\r\nstruct mlx4_dev *dev = &work->priv->dev;\r\nstruct mlx4_resource_tracker *tracker =\r\n&work->priv->mfunc.master.res_tracker;\r\nstruct list_head *qp_list =\r\n&tracker->slave_list[work->slave].res_list[RES_QP];\r\nstruct res_qp *qp;\r\nstruct res_qp *tmp;\r\nu64 qp_path_mask_vlan_ctrl =\r\n((1ULL << MLX4_UPD_QP_PATH_MASK_ETH_TX_BLOCK_UNTAGGED) |\r\n(1ULL << MLX4_UPD_QP_PATH_MASK_ETH_TX_BLOCK_1P) |\r\n(1ULL << MLX4_UPD_QP_PATH_MASK_ETH_TX_BLOCK_TAGGED) |\r\n(1ULL << MLX4_UPD_QP_PATH_MASK_ETH_RX_BLOCK_UNTAGGED) |\r\n(1ULL << MLX4_UPD_QP_PATH_MASK_ETH_RX_BLOCK_1P) |\r\n(1ULL << MLX4_UPD_QP_PATH_MASK_ETH_RX_BLOCK_TAGGED));\r\nu64 qp_path_mask = ((1ULL << MLX4_UPD_QP_PATH_MASK_VLAN_INDEX) |\r\n(1ULL << MLX4_UPD_QP_PATH_MASK_FVL) |\r\n(1ULL << MLX4_UPD_QP_PATH_MASK_CV) |\r\n(1ULL << MLX4_UPD_QP_PATH_MASK_ETH_HIDE_CQE_VLAN) |\r\n(1ULL << MLX4_UPD_QP_PATH_MASK_FEUP) |\r\n(1ULL << MLX4_UPD_QP_PATH_MASK_FVL_RX) |\r\n(1ULL << MLX4_UPD_QP_PATH_MASK_SCHED_QUEUE));\r\nint err;\r\nint port, errors = 0;\r\nu8 vlan_control;\r\nif (mlx4_is_slave(dev)) {\r\nmlx4_warn(dev, "Trying to update-qp in slave %d\n",\r\nwork->slave);\r\ngoto out;\r\n}\r\nmailbox = mlx4_alloc_cmd_mailbox(dev);\r\nif (IS_ERR(mailbox))\r\ngoto out;\r\nif (work->flags & MLX4_VF_IMMED_VLAN_FLAG_LINK_DISABLE)\r\nvlan_control = MLX4_VLAN_CTRL_ETH_TX_BLOCK_TAGGED |\r\nMLX4_VLAN_CTRL_ETH_TX_BLOCK_PRIO_TAGGED |\r\nMLX4_VLAN_CTRL_ETH_TX_BLOCK_UNTAGGED |\r\nMLX4_VLAN_CTRL_ETH_RX_BLOCK_PRIO_TAGGED |\r\nMLX4_VLAN_CTRL_ETH_RX_BLOCK_UNTAGGED |\r\nMLX4_VLAN_CTRL_ETH_RX_BLOCK_TAGGED;\r\nelse if (!work->vlan_id)\r\nvlan_control = MLX4_VLAN_CTRL_ETH_TX_BLOCK_TAGGED |\r\nMLX4_VLAN_CTRL_ETH_RX_BLOCK_TAGGED;\r\nelse\r\nvlan_control = MLX4_VLAN_CTRL_ETH_TX_BLOCK_TAGGED |\r\nMLX4_VLAN_CTRL_ETH_RX_BLOCK_PRIO_TAGGED |\r\nMLX4_VLAN_CTRL_ETH_RX_BLOCK_UNTAGGED;\r\nupd_context = mailbox->buf;\r\nupd_context->qp_mask = cpu_to_be64(1ULL << MLX4_UPD_QP_MASK_VSD);\r\nspin_lock_irq(mlx4_tlock(dev));\r\nlist_for_each_entry_safe(qp, tmp, qp_list, com.list) {\r\nspin_unlock_irq(mlx4_tlock(dev));\r\nif (qp->com.owner == work->slave) {\r\nif (qp->com.from_state != RES_QP_HW ||\r\n!qp->sched_queue ||\r\nmlx4_is_qp_reserved(dev, qp->local_qpn) ||\r\nqp->qpc_flags & (1 << MLX4_RSS_QPC_FLAG_OFFSET)) {\r\nspin_lock_irq(mlx4_tlock(dev));\r\ncontinue;\r\n}\r\nport = (qp->sched_queue >> 6 & 1) + 1;\r\nif (port != work->port) {\r\nspin_lock_irq(mlx4_tlock(dev));\r\ncontinue;\r\n}\r\nif (MLX4_QP_ST_RC == ((qp->qpc_flags >> 16) & 0xff))\r\nupd_context->primary_addr_path_mask = cpu_to_be64(qp_path_mask);\r\nelse\r\nupd_context->primary_addr_path_mask =\r\ncpu_to_be64(qp_path_mask | qp_path_mask_vlan_ctrl);\r\nif (work->vlan_id == MLX4_VGT) {\r\nupd_context->qp_context.param3 = qp->param3;\r\nupd_context->qp_context.pri_path.vlan_control = qp->vlan_control;\r\nupd_context->qp_context.pri_path.fvl_rx = qp->fvl_rx;\r\nupd_context->qp_context.pri_path.vlan_index = qp->vlan_index;\r\nupd_context->qp_context.pri_path.fl = qp->pri_path_fl;\r\nupd_context->qp_context.pri_path.feup = qp->feup;\r\nupd_context->qp_context.pri_path.sched_queue =\r\nqp->sched_queue;\r\n} else {\r\nupd_context->qp_context.param3 = qp->param3 & ~cpu_to_be32(MLX4_STRIP_VLAN);\r\nupd_context->qp_context.pri_path.vlan_control = vlan_control;\r\nupd_context->qp_context.pri_path.vlan_index = work->vlan_ix;\r\nupd_context->qp_context.pri_path.fvl_rx =\r\nqp->fvl_rx | MLX4_FVL_RX_FORCE_ETH_VLAN;\r\nupd_context->qp_context.pri_path.fl =\r\nqp->pri_path_fl | MLX4_FL_CV | MLX4_FL_ETH_HIDE_CQE_VLAN;\r\nupd_context->qp_context.pri_path.feup =\r\nqp->feup | MLX4_FEUP_FORCE_ETH_UP | MLX4_FVL_FORCE_ETH_VLAN;\r\nupd_context->qp_context.pri_path.sched_queue =\r\nqp->sched_queue & 0xC7;\r\nupd_context->qp_context.pri_path.sched_queue |=\r\n((work->qos & 0x7) << 3);\r\nupd_context->qp_mask |=\r\ncpu_to_be64(1ULL <<\r\nMLX4_UPD_QP_MASK_QOS_VPP);\r\nupd_context->qp_context.qos_vport =\r\nwork->qos_vport;\r\n}\r\nerr = mlx4_cmd(dev, mailbox->dma,\r\nqp->local_qpn & 0xffffff,\r\n0, MLX4_CMD_UPDATE_QP,\r\nMLX4_CMD_TIME_CLASS_C, MLX4_CMD_NATIVE);\r\nif (err) {\r\nmlx4_info(dev, "UPDATE_QP failed for slave %d, port %d, qpn %d (%d)\n",\r\nwork->slave, port, qp->local_qpn, err);\r\nerrors++;\r\n}\r\n}\r\nspin_lock_irq(mlx4_tlock(dev));\r\n}\r\nspin_unlock_irq(mlx4_tlock(dev));\r\nmlx4_free_cmd_mailbox(dev, mailbox);\r\nif (errors)\r\nmlx4_err(dev, "%d UPDATE_QP failures for slave %d, port %d\n",\r\nerrors, work->slave, work->port);\r\nif (work->flags & MLX4_VF_IMMED_VLAN_FLAG_VLAN && !errors &&\r\nNO_INDX != work->orig_vlan_ix)\r\n__mlx4_unregister_vlan(&work->priv->dev, work->port,\r\nwork->orig_vlan_id);\r\nout:\r\nkfree(work);\r\nreturn;\r\n}
