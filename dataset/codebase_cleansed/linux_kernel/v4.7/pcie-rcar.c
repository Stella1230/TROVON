static inline struct rcar_msi *to_rcar_msi(struct msi_controller *chip)\r\n{\r\nreturn container_of(chip, struct rcar_msi, chip);\r\n}\r\nstatic void rcar_pci_write_reg(struct rcar_pcie *pcie, unsigned long val,\r\nunsigned long reg)\r\n{\r\nwritel(val, pcie->base + reg);\r\n}\r\nstatic unsigned long rcar_pci_read_reg(struct rcar_pcie *pcie,\r\nunsigned long reg)\r\n{\r\nreturn readl(pcie->base + reg);\r\n}\r\nstatic void rcar_rmw32(struct rcar_pcie *pcie, int where, u32 mask, u32 data)\r\n{\r\nint shift = 8 * (where & 3);\r\nu32 val = rcar_pci_read_reg(pcie, where & ~3);\r\nval &= ~(mask << shift);\r\nval |= data << shift;\r\nrcar_pci_write_reg(pcie, val, where & ~3);\r\n}\r\nstatic u32 rcar_read_conf(struct rcar_pcie *pcie, int where)\r\n{\r\nint shift = 8 * (where & 3);\r\nu32 val = rcar_pci_read_reg(pcie, where & ~3);\r\nreturn val >> shift;\r\n}\r\nstatic int rcar_pcie_config_access(struct rcar_pcie *pcie,\r\nunsigned char access_type, struct pci_bus *bus,\r\nunsigned int devfn, int where, u32 *data)\r\n{\r\nint dev, func, reg, index;\r\ndev = PCI_SLOT(devfn);\r\nfunc = PCI_FUNC(devfn);\r\nreg = where & ~3;\r\nindex = reg / 4;\r\nif (pci_is_root_bus(bus)) {\r\nif (dev != 0)\r\nreturn PCIBIOS_DEVICE_NOT_FOUND;\r\nif (access_type == RCAR_PCI_ACCESS_READ) {\r\n*data = rcar_pci_read_reg(pcie, PCICONF(index));\r\n} else {\r\nif (pci_is_root_bus(bus) && (reg == PCI_PRIMARY_BUS))\r\npcie->root_bus_nr = *data & 0xff;\r\nrcar_pci_write_reg(pcie, *data, PCICONF(index));\r\n}\r\nreturn PCIBIOS_SUCCESSFUL;\r\n}\r\nif (pcie->root_bus_nr < 0)\r\nreturn PCIBIOS_DEVICE_NOT_FOUND;\r\nrcar_pci_write_reg(pcie, rcar_pci_read_reg(pcie, PCIEERRFR), PCIEERRFR);\r\nrcar_pci_write_reg(pcie, PCIE_CONF_BUS(bus->number) |\r\nPCIE_CONF_DEV(dev) | PCIE_CONF_FUNC(func) | reg, PCIECAR);\r\nif (bus->parent->number == pcie->root_bus_nr)\r\nrcar_pci_write_reg(pcie, CONFIG_SEND_ENABLE | TYPE0, PCIECCTLR);\r\nelse\r\nrcar_pci_write_reg(pcie, CONFIG_SEND_ENABLE | TYPE1, PCIECCTLR);\r\nif (rcar_pci_read_reg(pcie, PCIEERRFR) & UNSUPPORTED_REQUEST)\r\nreturn PCIBIOS_DEVICE_NOT_FOUND;\r\nif (rcar_read_conf(pcie, RCONF(PCI_STATUS)) &\r\n(PCI_STATUS_REC_MASTER_ABORT | PCI_STATUS_REC_TARGET_ABORT))\r\nreturn PCIBIOS_DEVICE_NOT_FOUND;\r\nif (access_type == RCAR_PCI_ACCESS_READ)\r\n*data = rcar_pci_read_reg(pcie, PCIECDR);\r\nelse\r\nrcar_pci_write_reg(pcie, *data, PCIECDR);\r\nrcar_pci_write_reg(pcie, 0, PCIECCTLR);\r\nreturn PCIBIOS_SUCCESSFUL;\r\n}\r\nstatic int rcar_pcie_read_conf(struct pci_bus *bus, unsigned int devfn,\r\nint where, int size, u32 *val)\r\n{\r\nstruct rcar_pcie *pcie = bus->sysdata;\r\nint ret;\r\nret = rcar_pcie_config_access(pcie, RCAR_PCI_ACCESS_READ,\r\nbus, devfn, where, val);\r\nif (ret != PCIBIOS_SUCCESSFUL) {\r\n*val = 0xffffffff;\r\nreturn ret;\r\n}\r\nif (size == 1)\r\n*val = (*val >> (8 * (where & 3))) & 0xff;\r\nelse if (size == 2)\r\n*val = (*val >> (8 * (where & 2))) & 0xffff;\r\ndev_dbg(&bus->dev, "pcie-config-read: bus=%3d devfn=0x%04x where=0x%04x size=%d val=0x%08lx\n",\r\nbus->number, devfn, where, size, (unsigned long)*val);\r\nreturn ret;\r\n}\r\nstatic int rcar_pcie_write_conf(struct pci_bus *bus, unsigned int devfn,\r\nint where, int size, u32 val)\r\n{\r\nstruct rcar_pcie *pcie = bus->sysdata;\r\nint shift, ret;\r\nu32 data;\r\nret = rcar_pcie_config_access(pcie, RCAR_PCI_ACCESS_READ,\r\nbus, devfn, where, &data);\r\nif (ret != PCIBIOS_SUCCESSFUL)\r\nreturn ret;\r\ndev_dbg(&bus->dev, "pcie-config-write: bus=%3d devfn=0x%04x where=0x%04x size=%d val=0x%08lx\n",\r\nbus->number, devfn, where, size, (unsigned long)val);\r\nif (size == 1) {\r\nshift = 8 * (where & 3);\r\ndata &= ~(0xff << shift);\r\ndata |= ((val & 0xff) << shift);\r\n} else if (size == 2) {\r\nshift = 8 * (where & 2);\r\ndata &= ~(0xffff << shift);\r\ndata |= ((val & 0xffff) << shift);\r\n} else\r\ndata = val;\r\nret = rcar_pcie_config_access(pcie, RCAR_PCI_ACCESS_WRITE,\r\nbus, devfn, where, &data);\r\nreturn ret;\r\n}\r\nstatic void rcar_pcie_setup_window(int win, struct rcar_pcie *pcie,\r\nstruct resource *res)\r\n{\r\nresource_size_t size;\r\nresource_size_t res_start;\r\nu32 mask;\r\nrcar_pci_write_reg(pcie, 0x00000000, PCIEPTCTLR(win));\r\nsize = resource_size(res);\r\nmask = (roundup_pow_of_two(size) / SZ_128) - 1;\r\nrcar_pci_write_reg(pcie, mask << 7, PCIEPAMR(win));\r\nif (res->flags & IORESOURCE_IO)\r\nres_start = pci_pio_to_address(res->start);\r\nelse\r\nres_start = res->start;\r\nrcar_pci_write_reg(pcie, upper_32_bits(res_start), PCIEPAUR(win));\r\nrcar_pci_write_reg(pcie, lower_32_bits(res_start) & ~0x7F,\r\nPCIEPALR(win));\r\nmask = PAR_ENABLE;\r\nif (res->flags & IORESOURCE_IO)\r\nmask |= IO_SPACE;\r\nrcar_pci_write_reg(pcie, mask, PCIEPTCTLR(win));\r\n}\r\nstatic int rcar_pcie_setup(struct list_head *resource, struct rcar_pcie *pci)\r\n{\r\nstruct resource_entry *win;\r\nint i = 0;\r\nresource_list_for_each_entry(win, &pci->resources) {\r\nstruct resource *res = win->res;\r\nif (!res->flags)\r\ncontinue;\r\nswitch (resource_type(res)) {\r\ncase IORESOURCE_IO:\r\ncase IORESOURCE_MEM:\r\nrcar_pcie_setup_window(i, pci, res);\r\ni++;\r\nbreak;\r\ncase IORESOURCE_BUS:\r\npci->root_bus_nr = res->start;\r\nbreak;\r\ndefault:\r\ncontinue;\r\n}\r\npci_add_resource(resource, res);\r\n}\r\nreturn 1;\r\n}\r\nstatic int rcar_pcie_enable(struct rcar_pcie *pcie)\r\n{\r\nstruct pci_bus *bus, *child;\r\nLIST_HEAD(res);\r\nrcar_pcie_setup(&res, pcie);\r\npci_add_flags(PCI_REASSIGN_ALL_RSRC | PCI_REASSIGN_ALL_BUS);\r\nif (IS_ENABLED(CONFIG_PCI_MSI))\r\nbus = pci_scan_root_bus_msi(pcie->dev, pcie->root_bus_nr,\r\n&rcar_pcie_ops, pcie, &res, &pcie->msi.chip);\r\nelse\r\nbus = pci_scan_root_bus(pcie->dev, pcie->root_bus_nr,\r\n&rcar_pcie_ops, pcie, &res);\r\nif (!bus) {\r\ndev_err(pcie->dev, "Scanning rootbus failed");\r\nreturn -ENODEV;\r\n}\r\npci_fixup_irqs(pci_common_swizzle, of_irq_parse_and_map_pci);\r\npci_bus_size_bridges(bus);\r\npci_bus_assign_resources(bus);\r\nlist_for_each_entry(child, &bus->children, node)\r\npcie_bus_configure_settings(child);\r\npci_bus_add_devices(bus);\r\nreturn 0;\r\n}\r\nstatic int phy_wait_for_ack(struct rcar_pcie *pcie)\r\n{\r\nunsigned int timeout = 100;\r\nwhile (timeout--) {\r\nif (rcar_pci_read_reg(pcie, H1_PCIEPHYADRR) & PHY_ACK)\r\nreturn 0;\r\nudelay(100);\r\n}\r\ndev_err(pcie->dev, "Access to PCIe phy timed out\n");\r\nreturn -ETIMEDOUT;\r\n}\r\nstatic void phy_write_reg(struct rcar_pcie *pcie,\r\nunsigned int rate, unsigned int addr,\r\nunsigned int lane, unsigned int data)\r\n{\r\nunsigned long phyaddr;\r\nphyaddr = WRITE_CMD |\r\n((rate & 1) << RATE_POS) |\r\n((lane & 0xf) << LANE_POS) |\r\n((addr & 0xff) << ADR_POS);\r\nrcar_pci_write_reg(pcie, data, H1_PCIEPHYDOUTR);\r\nrcar_pci_write_reg(pcie, phyaddr, H1_PCIEPHYADRR);\r\nphy_wait_for_ack(pcie);\r\nrcar_pci_write_reg(pcie, 0, H1_PCIEPHYDOUTR);\r\nrcar_pci_write_reg(pcie, 0, H1_PCIEPHYADRR);\r\nphy_wait_for_ack(pcie);\r\n}\r\nstatic int rcar_pcie_wait_for_dl(struct rcar_pcie *pcie)\r\n{\r\nunsigned int timeout = 10;\r\nwhile (timeout--) {\r\nif ((rcar_pci_read_reg(pcie, PCIETSTR) & DATA_LINK_ACTIVE))\r\nreturn 0;\r\nmsleep(5);\r\n}\r\nreturn -ETIMEDOUT;\r\n}\r\nstatic int rcar_pcie_hw_init(struct rcar_pcie *pcie)\r\n{\r\nint err;\r\nrcar_pci_write_reg(pcie, 0, PCIETCTLR);\r\nrcar_pci_write_reg(pcie, 1, PCIEMSR);\r\nrcar_pci_write_reg(pcie, PCI_CLASS_BRIDGE_PCI << 16, IDSETR1);\r\nrcar_rmw32(pcie, RCONF(PCI_SECONDARY_BUS), 0xff, 1);\r\nrcar_rmw32(pcie, RCONF(PCI_SUBORDINATE_BUS), 0xff, 1);\r\nrcar_rmw32(pcie, REXPCAP(0), 0xff, PCI_CAP_ID_EXP);\r\nrcar_rmw32(pcie, REXPCAP(PCI_EXP_FLAGS),\r\nPCI_EXP_FLAGS_TYPE, PCI_EXP_TYPE_ROOT_PORT << 4);\r\nrcar_rmw32(pcie, RCONF(PCI_HEADER_TYPE), 0x7f,\r\nPCI_HEADER_TYPE_BRIDGE);\r\nrcar_rmw32(pcie, REXPCAP(PCI_EXP_LNKCAP), PCI_EXP_LNKCAP_DLLLARC,\r\nPCI_EXP_LNKCAP_DLLLARC);\r\nrcar_rmw32(pcie, REXPCAP(PCI_EXP_SLTCAP), PCI_EXP_SLTCAP_PSN, 0);\r\nrcar_rmw32(pcie, TLCTLR + 1, 0x3f, 50);\r\nrcar_rmw32(pcie, RVCCAP(0), 0xfff00000, 0);\r\nif (IS_ENABLED(CONFIG_PCI_MSI))\r\nrcar_pci_write_reg(pcie, 0x801f0000, PCIEMSITXR);\r\nrcar_pci_write_reg(pcie, CFINIT, PCIETCTLR);\r\nerr = rcar_pcie_wait_for_dl(pcie);\r\nif (err)\r\nreturn err;\r\nrcar_rmw32(pcie, PCIEINTXR, 0, 0xF << 8);\r\nwmb();\r\nreturn 0;\r\n}\r\nstatic int rcar_pcie_hw_init_h1(struct rcar_pcie *pcie)\r\n{\r\nunsigned int timeout = 10;\r\nphy_write_reg(pcie, 0, 0x42, 0x1, 0x0EC34191);\r\nphy_write_reg(pcie, 1, 0x42, 0x1, 0x0EC34180);\r\nphy_write_reg(pcie, 0, 0x43, 0x1, 0x00210188);\r\nphy_write_reg(pcie, 1, 0x43, 0x1, 0x00210188);\r\nphy_write_reg(pcie, 0, 0x44, 0x1, 0x015C0014);\r\nphy_write_reg(pcie, 1, 0x44, 0x1, 0x015C0014);\r\nphy_write_reg(pcie, 1, 0x4C, 0x1, 0x786174A0);\r\nphy_write_reg(pcie, 1, 0x4D, 0x1, 0x048000BB);\r\nphy_write_reg(pcie, 0, 0x51, 0x1, 0x079EC062);\r\nphy_write_reg(pcie, 0, 0x52, 0x1, 0x20000000);\r\nphy_write_reg(pcie, 1, 0x52, 0x1, 0x20000000);\r\nphy_write_reg(pcie, 1, 0x56, 0x1, 0x00003806);\r\nphy_write_reg(pcie, 0, 0x60, 0x1, 0x004B03A5);\r\nphy_write_reg(pcie, 0, 0x64, 0x1, 0x3F0F1F0F);\r\nphy_write_reg(pcie, 0, 0x66, 0x1, 0x00008000);\r\nwhile (timeout--) {\r\nif (rcar_pci_read_reg(pcie, H1_PCIEPHYSR))\r\nreturn rcar_pcie_hw_init(pcie);\r\nmsleep(5);\r\n}\r\nreturn -ETIMEDOUT;\r\n}\r\nstatic int rcar_pcie_hw_init_gen2(struct rcar_pcie *pcie)\r\n{\r\nrcar_pci_write_reg(pcie, 0x000f0030, GEN2_PCIEPHYADDR);\r\nrcar_pci_write_reg(pcie, 0x00381203, GEN2_PCIEPHYDATA);\r\nrcar_pci_write_reg(pcie, 0x00000001, GEN2_PCIEPHYCTRL);\r\nrcar_pci_write_reg(pcie, 0x00000006, GEN2_PCIEPHYCTRL);\r\nrcar_pci_write_reg(pcie, 0x000f0054, GEN2_PCIEPHYADDR);\r\nrcar_pci_write_reg(pcie, 0x13802007, GEN2_PCIEPHYDATA);\r\nrcar_pci_write_reg(pcie, 0x00000001, GEN2_PCIEPHYCTRL);\r\nrcar_pci_write_reg(pcie, 0x00000006, GEN2_PCIEPHYCTRL);\r\nreturn rcar_pcie_hw_init(pcie);\r\n}\r\nstatic int rcar_msi_alloc(struct rcar_msi *chip)\r\n{\r\nint msi;\r\nmutex_lock(&chip->lock);\r\nmsi = find_first_zero_bit(chip->used, INT_PCI_MSI_NR);\r\nif (msi < INT_PCI_MSI_NR)\r\nset_bit(msi, chip->used);\r\nelse\r\nmsi = -ENOSPC;\r\nmutex_unlock(&chip->lock);\r\nreturn msi;\r\n}\r\nstatic void rcar_msi_free(struct rcar_msi *chip, unsigned long irq)\r\n{\r\nmutex_lock(&chip->lock);\r\nclear_bit(irq, chip->used);\r\nmutex_unlock(&chip->lock);\r\n}\r\nstatic irqreturn_t rcar_pcie_msi_irq(int irq, void *data)\r\n{\r\nstruct rcar_pcie *pcie = data;\r\nstruct rcar_msi *msi = &pcie->msi;\r\nunsigned long reg;\r\nreg = rcar_pci_read_reg(pcie, PCIEMSIFR);\r\nif (!reg)\r\nreturn IRQ_NONE;\r\nwhile (reg) {\r\nunsigned int index = find_first_bit(&reg, 32);\r\nunsigned int irq;\r\nrcar_pci_write_reg(pcie, 1 << index, PCIEMSIFR);\r\nirq = irq_find_mapping(msi->domain, index);\r\nif (irq) {\r\nif (test_bit(index, msi->used))\r\ngeneric_handle_irq(irq);\r\nelse\r\ndev_info(pcie->dev, "unhandled MSI\n");\r\n} else {\r\ndev_dbg(pcie->dev, "unexpected MSI\n");\r\n}\r\nreg = rcar_pci_read_reg(pcie, PCIEMSIFR);\r\n}\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int rcar_msi_setup_irq(struct msi_controller *chip, struct pci_dev *pdev,\r\nstruct msi_desc *desc)\r\n{\r\nstruct rcar_msi *msi = to_rcar_msi(chip);\r\nstruct rcar_pcie *pcie = container_of(chip, struct rcar_pcie, msi.chip);\r\nstruct msi_msg msg;\r\nunsigned int irq;\r\nint hwirq;\r\nhwirq = rcar_msi_alloc(msi);\r\nif (hwirq < 0)\r\nreturn hwirq;\r\nirq = irq_create_mapping(msi->domain, hwirq);\r\nif (!irq) {\r\nrcar_msi_free(msi, hwirq);\r\nreturn -EINVAL;\r\n}\r\nirq_set_msi_desc(irq, desc);\r\nmsg.address_lo = rcar_pci_read_reg(pcie, PCIEMSIALR) & ~MSIFE;\r\nmsg.address_hi = rcar_pci_read_reg(pcie, PCIEMSIAUR);\r\nmsg.data = hwirq;\r\npci_write_msi_msg(irq, &msg);\r\nreturn 0;\r\n}\r\nstatic void rcar_msi_teardown_irq(struct msi_controller *chip, unsigned int irq)\r\n{\r\nstruct rcar_msi *msi = to_rcar_msi(chip);\r\nstruct irq_data *d = irq_get_irq_data(irq);\r\nrcar_msi_free(msi, d->hwirq);\r\n}\r\nstatic int rcar_msi_map(struct irq_domain *domain, unsigned int irq,\r\nirq_hw_number_t hwirq)\r\n{\r\nirq_set_chip_and_handler(irq, &rcar_msi_irq_chip, handle_simple_irq);\r\nirq_set_chip_data(irq, domain->host_data);\r\nreturn 0;\r\n}\r\nstatic int rcar_pcie_enable_msi(struct rcar_pcie *pcie)\r\n{\r\nstruct platform_device *pdev = to_platform_device(pcie->dev);\r\nstruct rcar_msi *msi = &pcie->msi;\r\nunsigned long base;\r\nint err;\r\nmutex_init(&msi->lock);\r\nmsi->chip.dev = pcie->dev;\r\nmsi->chip.setup_irq = rcar_msi_setup_irq;\r\nmsi->chip.teardown_irq = rcar_msi_teardown_irq;\r\nmsi->domain = irq_domain_add_linear(pcie->dev->of_node, INT_PCI_MSI_NR,\r\n&msi_domain_ops, &msi->chip);\r\nif (!msi->domain) {\r\ndev_err(&pdev->dev, "failed to create IRQ domain\n");\r\nreturn -ENOMEM;\r\n}\r\nerr = devm_request_irq(&pdev->dev, msi->irq1, rcar_pcie_msi_irq,\r\nIRQF_SHARED | IRQF_NO_THREAD,\r\nrcar_msi_irq_chip.name, pcie);\r\nif (err < 0) {\r\ndev_err(&pdev->dev, "failed to request IRQ: %d\n", err);\r\ngoto err;\r\n}\r\nerr = devm_request_irq(&pdev->dev, msi->irq2, rcar_pcie_msi_irq,\r\nIRQF_SHARED | IRQF_NO_THREAD,\r\nrcar_msi_irq_chip.name, pcie);\r\nif (err < 0) {\r\ndev_err(&pdev->dev, "failed to request IRQ: %d\n", err);\r\ngoto err;\r\n}\r\nmsi->pages = __get_free_pages(GFP_KERNEL, 0);\r\nbase = virt_to_phys((void *)msi->pages);\r\nrcar_pci_write_reg(pcie, base | MSIFE, PCIEMSIALR);\r\nrcar_pci_write_reg(pcie, 0, PCIEMSIAUR);\r\nrcar_pci_write_reg(pcie, 0xffffffff, PCIEMSIIER);\r\nreturn 0;\r\nerr:\r\nirq_domain_remove(msi->domain);\r\nreturn err;\r\n}\r\nstatic int rcar_pcie_get_resources(struct platform_device *pdev,\r\nstruct rcar_pcie *pcie)\r\n{\r\nstruct resource res;\r\nint err, i;\r\nerr = of_address_to_resource(pdev->dev.of_node, 0, &res);\r\nif (err)\r\nreturn err;\r\npcie->clk = devm_clk_get(&pdev->dev, "pcie");\r\nif (IS_ERR(pcie->clk)) {\r\ndev_err(pcie->dev, "cannot get platform clock\n");\r\nreturn PTR_ERR(pcie->clk);\r\n}\r\nerr = clk_prepare_enable(pcie->clk);\r\nif (err)\r\ngoto fail_clk;\r\npcie->bus_clk = devm_clk_get(&pdev->dev, "pcie_bus");\r\nif (IS_ERR(pcie->bus_clk)) {\r\ndev_err(pcie->dev, "cannot get pcie bus clock\n");\r\nerr = PTR_ERR(pcie->bus_clk);\r\ngoto fail_clk;\r\n}\r\nerr = clk_prepare_enable(pcie->bus_clk);\r\nif (err)\r\ngoto err_map_reg;\r\ni = irq_of_parse_and_map(pdev->dev.of_node, 0);\r\nif (!i) {\r\ndev_err(pcie->dev, "cannot get platform resources for msi interrupt\n");\r\nerr = -ENOENT;\r\ngoto err_map_reg;\r\n}\r\npcie->msi.irq1 = i;\r\ni = irq_of_parse_and_map(pdev->dev.of_node, 1);\r\nif (!i) {\r\ndev_err(pcie->dev, "cannot get platform resources for msi interrupt\n");\r\nerr = -ENOENT;\r\ngoto err_map_reg;\r\n}\r\npcie->msi.irq2 = i;\r\npcie->base = devm_ioremap_resource(&pdev->dev, &res);\r\nif (IS_ERR(pcie->base)) {\r\nerr = PTR_ERR(pcie->base);\r\ngoto err_map_reg;\r\n}\r\nreturn 0;\r\nerr_map_reg:\r\nclk_disable_unprepare(pcie->bus_clk);\r\nfail_clk:\r\nclk_disable_unprepare(pcie->clk);\r\nreturn err;\r\n}\r\nstatic int rcar_pcie_inbound_ranges(struct rcar_pcie *pcie,\r\nstruct of_pci_range *range,\r\nint *index)\r\n{\r\nu64 restype = range->flags;\r\nu64 cpu_addr = range->cpu_addr;\r\nu64 cpu_end = range->cpu_addr + range->size;\r\nu64 pci_addr = range->pci_addr;\r\nu32 flags = LAM_64BIT | LAR_ENABLE;\r\nu64 mask;\r\nu64 size;\r\nint idx = *index;\r\nif (restype & IORESOURCE_PREFETCH)\r\nflags |= LAM_PREFETCH;\r\nif (cpu_addr > 0) {\r\nunsigned long nr_zeros = __ffs64(cpu_addr);\r\nu64 alignment = 1ULL << nr_zeros;\r\nsize = min(range->size, alignment);\r\n} else {\r\nsize = range->size;\r\n}\r\nsize = min(size, 1ULL << 32);\r\nmask = roundup_pow_of_two(size) - 1;\r\nmask &= ~0xf;\r\nwhile (cpu_addr < cpu_end) {\r\nrcar_pci_write_reg(pcie, lower_32_bits(pci_addr), PCIEPRAR(idx));\r\nrcar_pci_write_reg(pcie, lower_32_bits(cpu_addr), PCIELAR(idx));\r\nrcar_pci_write_reg(pcie, lower_32_bits(mask) | flags, PCIELAMR(idx));\r\nrcar_pci_write_reg(pcie, upper_32_bits(pci_addr), PCIEPRAR(idx+1));\r\nrcar_pci_write_reg(pcie, upper_32_bits(cpu_addr), PCIELAR(idx+1));\r\nrcar_pci_write_reg(pcie, 0, PCIELAMR(idx + 1));\r\npci_addr += size;\r\ncpu_addr += size;\r\nidx += 2;\r\nif (idx > MAX_NR_INBOUND_MAPS) {\r\ndev_err(pcie->dev, "Failed to map inbound regions!\n");\r\nreturn -EINVAL;\r\n}\r\n}\r\n*index = idx;\r\nreturn 0;\r\n}\r\nstatic int pci_dma_range_parser_init(struct of_pci_range_parser *parser,\r\nstruct device_node *node)\r\n{\r\nconst int na = 3, ns = 2;\r\nint rlen;\r\nparser->node = node;\r\nparser->pna = of_n_addr_cells(node);\r\nparser->np = parser->pna + na + ns;\r\nparser->range = of_get_property(node, "dma-ranges", &rlen);\r\nif (!parser->range)\r\nreturn -ENOENT;\r\nparser->end = parser->range + rlen / sizeof(__be32);\r\nreturn 0;\r\n}\r\nstatic int rcar_pcie_parse_map_dma_ranges(struct rcar_pcie *pcie,\r\nstruct device_node *np)\r\n{\r\nstruct of_pci_range range;\r\nstruct of_pci_range_parser parser;\r\nint index = 0;\r\nint err;\r\nif (pci_dma_range_parser_init(&parser, np))\r\nreturn -EINVAL;\r\nfor_each_of_pci_range(&parser, &range) {\r\nu64 end = range.cpu_addr + range.size - 1;\r\ndev_dbg(pcie->dev, "0x%08x 0x%016llx..0x%016llx -> 0x%016llx\n",\r\nrange.flags, range.cpu_addr, end, range.pci_addr);\r\nerr = rcar_pcie_inbound_ranges(pcie, &range, &index);\r\nif (err)\r\nreturn err;\r\n}\r\nreturn 0;\r\n}\r\nstatic void rcar_pcie_release_of_pci_ranges(struct rcar_pcie *pci)\r\n{\r\npci_free_resource_list(&pci->resources);\r\n}\r\nstatic int rcar_pcie_parse_request_of_pci_ranges(struct rcar_pcie *pci)\r\n{\r\nint err;\r\nstruct device *dev = pci->dev;\r\nstruct device_node *np = dev->of_node;\r\nresource_size_t iobase;\r\nstruct resource_entry *win;\r\nerr = of_pci_get_host_bridge_resources(np, 0, 0xff, &pci->resources, &iobase);\r\nif (err)\r\nreturn err;\r\nresource_list_for_each_entry(win, &pci->resources) {\r\nstruct resource *parent, *res = win->res;\r\nswitch (resource_type(res)) {\r\ncase IORESOURCE_IO:\r\nparent = &ioport_resource;\r\nerr = pci_remap_iospace(res, iobase);\r\nif (err) {\r\ndev_warn(dev, "error %d: failed to map resource %pR\n",\r\nerr, res);\r\ncontinue;\r\n}\r\nbreak;\r\ncase IORESOURCE_MEM:\r\nparent = &iomem_resource;\r\nbreak;\r\ncase IORESOURCE_BUS:\r\ndefault:\r\ncontinue;\r\n}\r\nerr = devm_request_resource(dev, parent, res);\r\nif (err)\r\ngoto out_release_res;\r\n}\r\nreturn 0;\r\nout_release_res:\r\nrcar_pcie_release_of_pci_ranges(pci);\r\nreturn err;\r\n}\r\nstatic int rcar_pcie_probe(struct platform_device *pdev)\r\n{\r\nstruct rcar_pcie *pcie;\r\nunsigned int data;\r\nconst struct of_device_id *of_id;\r\nint err;\r\nint (*hw_init_fn)(struct rcar_pcie *);\r\npcie = devm_kzalloc(&pdev->dev, sizeof(*pcie), GFP_KERNEL);\r\nif (!pcie)\r\nreturn -ENOMEM;\r\npcie->dev = &pdev->dev;\r\nplatform_set_drvdata(pdev, pcie);\r\nINIT_LIST_HEAD(&pcie->resources);\r\nrcar_pcie_parse_request_of_pci_ranges(pcie);\r\nerr = rcar_pcie_get_resources(pdev, pcie);\r\nif (err < 0) {\r\ndev_err(&pdev->dev, "failed to request resources: %d\n", err);\r\nreturn err;\r\n}\r\nerr = rcar_pcie_parse_map_dma_ranges(pcie, pdev->dev.of_node);\r\nif (err)\r\nreturn err;\r\nof_id = of_match_device(rcar_pcie_of_match, pcie->dev);\r\nif (!of_id || !of_id->data)\r\nreturn -EINVAL;\r\nhw_init_fn = of_id->data;\r\npm_runtime_enable(pcie->dev);\r\nerr = pm_runtime_get_sync(pcie->dev);\r\nif (err < 0) {\r\ndev_err(pcie->dev, "pm_runtime_get_sync failed\n");\r\ngoto err_pm_disable;\r\n}\r\nerr = hw_init_fn(pcie);\r\nif (err) {\r\ndev_info(&pdev->dev, "PCIe link down\n");\r\nerr = 0;\r\ngoto err_pm_put;\r\n}\r\ndata = rcar_pci_read_reg(pcie, MACSR);\r\ndev_info(&pdev->dev, "PCIe x%d: link up\n", (data >> 20) & 0x3f);\r\nif (IS_ENABLED(CONFIG_PCI_MSI)) {\r\nerr = rcar_pcie_enable_msi(pcie);\r\nif (err < 0) {\r\ndev_err(&pdev->dev,\r\n"failed to enable MSI support: %d\n",\r\nerr);\r\ngoto err_pm_put;\r\n}\r\n}\r\nerr = rcar_pcie_enable(pcie);\r\nif (err)\r\ngoto err_pm_put;\r\nreturn 0;\r\nerr_pm_put:\r\npm_runtime_put(pcie->dev);\r\nerr_pm_disable:\r\npm_runtime_disable(pcie->dev);\r\nreturn err;\r\n}
