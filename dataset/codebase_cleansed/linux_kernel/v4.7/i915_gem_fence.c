static void i965_write_fence_reg(struct drm_device *dev, int reg,\r\nstruct drm_i915_gem_object *obj)\r\n{\r\nstruct drm_i915_private *dev_priv = dev->dev_private;\r\ni915_reg_t fence_reg_lo, fence_reg_hi;\r\nint fence_pitch_shift;\r\nif (INTEL_INFO(dev)->gen >= 6) {\r\nfence_reg_lo = FENCE_REG_GEN6_LO(reg);\r\nfence_reg_hi = FENCE_REG_GEN6_HI(reg);\r\nfence_pitch_shift = GEN6_FENCE_PITCH_SHIFT;\r\n} else {\r\nfence_reg_lo = FENCE_REG_965_LO(reg);\r\nfence_reg_hi = FENCE_REG_965_HI(reg);\r\nfence_pitch_shift = I965_FENCE_PITCH_SHIFT;\r\n}\r\nI915_WRITE(fence_reg_lo, 0);\r\nPOSTING_READ(fence_reg_lo);\r\nif (obj) {\r\nu32 size = i915_gem_obj_ggtt_size(obj);\r\nuint64_t val;\r\nif (obj->tiling_mode != I915_TILING_NONE) {\r\nuint32_t row_size = obj->stride *\r\n(obj->tiling_mode == I915_TILING_Y ? 32 : 8);\r\nsize = (size / row_size) * row_size;\r\n}\r\nval = (uint64_t)((i915_gem_obj_ggtt_offset(obj) + size - 4096) &\r\n0xfffff000) << 32;\r\nval |= i915_gem_obj_ggtt_offset(obj) & 0xfffff000;\r\nval |= (uint64_t)((obj->stride / 128) - 1) << fence_pitch_shift;\r\nif (obj->tiling_mode == I915_TILING_Y)\r\nval |= 1 << I965_FENCE_TILING_Y_SHIFT;\r\nval |= I965_FENCE_REG_VALID;\r\nI915_WRITE(fence_reg_hi, val >> 32);\r\nPOSTING_READ(fence_reg_hi);\r\nI915_WRITE(fence_reg_lo, val);\r\nPOSTING_READ(fence_reg_lo);\r\n} else {\r\nI915_WRITE(fence_reg_hi, 0);\r\nPOSTING_READ(fence_reg_hi);\r\n}\r\n}\r\nstatic void i915_write_fence_reg(struct drm_device *dev, int reg,\r\nstruct drm_i915_gem_object *obj)\r\n{\r\nstruct drm_i915_private *dev_priv = dev->dev_private;\r\nu32 val;\r\nif (obj) {\r\nu32 size = i915_gem_obj_ggtt_size(obj);\r\nint pitch_val;\r\nint tile_width;\r\nWARN((i915_gem_obj_ggtt_offset(obj) & ~I915_FENCE_START_MASK) ||\r\n(size & -size) != size ||\r\n(i915_gem_obj_ggtt_offset(obj) & (size - 1)),\r\n"object 0x%08llx [fenceable? %d] not 1M or pot-size (0x%08x) aligned\n",\r\ni915_gem_obj_ggtt_offset(obj), obj->map_and_fenceable, size);\r\nif (obj->tiling_mode == I915_TILING_Y && HAS_128_BYTE_Y_TILING(dev))\r\ntile_width = 128;\r\nelse\r\ntile_width = 512;\r\npitch_val = obj->stride / tile_width;\r\npitch_val = ffs(pitch_val) - 1;\r\nval = i915_gem_obj_ggtt_offset(obj);\r\nif (obj->tiling_mode == I915_TILING_Y)\r\nval |= 1 << I830_FENCE_TILING_Y_SHIFT;\r\nval |= I915_FENCE_SIZE_BITS(size);\r\nval |= pitch_val << I830_FENCE_PITCH_SHIFT;\r\nval |= I830_FENCE_REG_VALID;\r\n} else\r\nval = 0;\r\nI915_WRITE(FENCE_REG(reg), val);\r\nPOSTING_READ(FENCE_REG(reg));\r\n}\r\nstatic void i830_write_fence_reg(struct drm_device *dev, int reg,\r\nstruct drm_i915_gem_object *obj)\r\n{\r\nstruct drm_i915_private *dev_priv = dev->dev_private;\r\nuint32_t val;\r\nif (obj) {\r\nu32 size = i915_gem_obj_ggtt_size(obj);\r\nuint32_t pitch_val;\r\nWARN((i915_gem_obj_ggtt_offset(obj) & ~I830_FENCE_START_MASK) ||\r\n(size & -size) != size ||\r\n(i915_gem_obj_ggtt_offset(obj) & (size - 1)),\r\n"object 0x%08llx not 512K or pot-size 0x%08x aligned\n",\r\ni915_gem_obj_ggtt_offset(obj), size);\r\npitch_val = obj->stride / 128;\r\npitch_val = ffs(pitch_val) - 1;\r\nval = i915_gem_obj_ggtt_offset(obj);\r\nif (obj->tiling_mode == I915_TILING_Y)\r\nval |= 1 << I830_FENCE_TILING_Y_SHIFT;\r\nval |= I830_FENCE_SIZE_BITS(size);\r\nval |= pitch_val << I830_FENCE_PITCH_SHIFT;\r\nval |= I830_FENCE_REG_VALID;\r\n} else\r\nval = 0;\r\nI915_WRITE(FENCE_REG(reg), val);\r\nPOSTING_READ(FENCE_REG(reg));\r\n}\r\ninline static bool i915_gem_object_needs_mb(struct drm_i915_gem_object *obj)\r\n{\r\nreturn obj && obj->base.read_domains & I915_GEM_DOMAIN_GTT;\r\n}\r\nstatic void i915_gem_write_fence(struct drm_device *dev, int reg,\r\nstruct drm_i915_gem_object *obj)\r\n{\r\nstruct drm_i915_private *dev_priv = dev->dev_private;\r\nif (i915_gem_object_needs_mb(dev_priv->fence_regs[reg].obj))\r\nmb();\r\nWARN(obj && (!obj->stride || !obj->tiling_mode),\r\n"bogus fence setup with stride: 0x%x, tiling mode: %i\n",\r\nobj->stride, obj->tiling_mode);\r\nif (IS_GEN2(dev))\r\ni830_write_fence_reg(dev, reg, obj);\r\nelse if (IS_GEN3(dev))\r\ni915_write_fence_reg(dev, reg, obj);\r\nelse if (INTEL_INFO(dev)->gen >= 4)\r\ni965_write_fence_reg(dev, reg, obj);\r\nif (i915_gem_object_needs_mb(obj))\r\nmb();\r\n}\r\nstatic inline int fence_number(struct drm_i915_private *dev_priv,\r\nstruct drm_i915_fence_reg *fence)\r\n{\r\nreturn fence - dev_priv->fence_regs;\r\n}\r\nstatic void i915_gem_object_update_fence(struct drm_i915_gem_object *obj,\r\nstruct drm_i915_fence_reg *fence,\r\nbool enable)\r\n{\r\nstruct drm_i915_private *dev_priv = obj->base.dev->dev_private;\r\nint reg = fence_number(dev_priv, fence);\r\ni915_gem_write_fence(obj->base.dev, reg, enable ? obj : NULL);\r\nif (enable) {\r\nobj->fence_reg = reg;\r\nfence->obj = obj;\r\nlist_move_tail(&fence->lru_list, &dev_priv->mm.fence_list);\r\n} else {\r\nobj->fence_reg = I915_FENCE_REG_NONE;\r\nfence->obj = NULL;\r\nlist_del_init(&fence->lru_list);\r\n}\r\nobj->fence_dirty = false;\r\n}\r\nstatic inline void i915_gem_object_fence_lost(struct drm_i915_gem_object *obj)\r\n{\r\nif (obj->tiling_mode)\r\ni915_gem_release_mmap(obj);\r\nobj->fence_dirty = false;\r\nobj->fence_reg = I915_FENCE_REG_NONE;\r\n}\r\nstatic int\r\ni915_gem_object_wait_fence(struct drm_i915_gem_object *obj)\r\n{\r\nif (obj->last_fenced_req) {\r\nint ret = i915_wait_request(obj->last_fenced_req);\r\nif (ret)\r\nreturn ret;\r\ni915_gem_request_assign(&obj->last_fenced_req, NULL);\r\n}\r\nreturn 0;\r\n}\r\nint\r\ni915_gem_object_put_fence(struct drm_i915_gem_object *obj)\r\n{\r\nstruct drm_i915_private *dev_priv = obj->base.dev->dev_private;\r\nstruct drm_i915_fence_reg *fence;\r\nint ret;\r\nret = i915_gem_object_wait_fence(obj);\r\nif (ret)\r\nreturn ret;\r\nif (obj->fence_reg == I915_FENCE_REG_NONE)\r\nreturn 0;\r\nfence = &dev_priv->fence_regs[obj->fence_reg];\r\nif (WARN_ON(fence->pin_count))\r\nreturn -EBUSY;\r\ni915_gem_object_fence_lost(obj);\r\ni915_gem_object_update_fence(obj, fence, false);\r\nreturn 0;\r\n}\r\nstatic struct drm_i915_fence_reg *\r\ni915_find_fence_reg(struct drm_device *dev)\r\n{\r\nstruct drm_i915_private *dev_priv = dev->dev_private;\r\nstruct drm_i915_fence_reg *reg, *avail;\r\nint i;\r\navail = NULL;\r\nfor (i = 0; i < dev_priv->num_fence_regs; i++) {\r\nreg = &dev_priv->fence_regs[i];\r\nif (!reg->obj)\r\nreturn reg;\r\nif (!reg->pin_count)\r\navail = reg;\r\n}\r\nif (avail == NULL)\r\ngoto deadlock;\r\nlist_for_each_entry(reg, &dev_priv->mm.fence_list, lru_list) {\r\nif (reg->pin_count)\r\ncontinue;\r\nreturn reg;\r\n}\r\ndeadlock:\r\nif (intel_has_pending_fb_unpin(dev))\r\nreturn ERR_PTR(-EAGAIN);\r\nreturn ERR_PTR(-EDEADLK);\r\n}\r\nint\r\ni915_gem_object_get_fence(struct drm_i915_gem_object *obj)\r\n{\r\nstruct drm_device *dev = obj->base.dev;\r\nstruct drm_i915_private *dev_priv = dev->dev_private;\r\nbool enable = obj->tiling_mode != I915_TILING_NONE;\r\nstruct drm_i915_fence_reg *reg;\r\nint ret;\r\nif (obj->fence_dirty) {\r\nret = i915_gem_object_wait_fence(obj);\r\nif (ret)\r\nreturn ret;\r\n}\r\nif (obj->fence_reg != I915_FENCE_REG_NONE) {\r\nreg = &dev_priv->fence_regs[obj->fence_reg];\r\nif (!obj->fence_dirty) {\r\nlist_move_tail(&reg->lru_list,\r\n&dev_priv->mm.fence_list);\r\nreturn 0;\r\n}\r\n} else if (enable) {\r\nif (WARN_ON(!obj->map_and_fenceable))\r\nreturn -EINVAL;\r\nreg = i915_find_fence_reg(dev);\r\nif (IS_ERR(reg))\r\nreturn PTR_ERR(reg);\r\nif (reg->obj) {\r\nstruct drm_i915_gem_object *old = reg->obj;\r\nret = i915_gem_object_wait_fence(old);\r\nif (ret)\r\nreturn ret;\r\ni915_gem_object_fence_lost(old);\r\n}\r\n} else\r\nreturn 0;\r\ni915_gem_object_update_fence(obj, reg, enable);\r\nreturn 0;\r\n}\r\nbool\r\ni915_gem_object_pin_fence(struct drm_i915_gem_object *obj)\r\n{\r\nif (obj->fence_reg != I915_FENCE_REG_NONE) {\r\nstruct drm_i915_private *dev_priv = obj->base.dev->dev_private;\r\nstruct i915_vma *ggtt_vma = i915_gem_obj_to_ggtt(obj);\r\nWARN_ON(!ggtt_vma ||\r\ndev_priv->fence_regs[obj->fence_reg].pin_count >\r\nggtt_vma->pin_count);\r\ndev_priv->fence_regs[obj->fence_reg].pin_count++;\r\nreturn true;\r\n} else\r\nreturn false;\r\n}\r\nvoid\r\ni915_gem_object_unpin_fence(struct drm_i915_gem_object *obj)\r\n{\r\nif (obj->fence_reg != I915_FENCE_REG_NONE) {\r\nstruct drm_i915_private *dev_priv = obj->base.dev->dev_private;\r\nWARN_ON(dev_priv->fence_regs[obj->fence_reg].pin_count <= 0);\r\ndev_priv->fence_regs[obj->fence_reg].pin_count--;\r\n}\r\n}\r\nvoid i915_gem_restore_fences(struct drm_device *dev)\r\n{\r\nstruct drm_i915_private *dev_priv = dev->dev_private;\r\nint i;\r\nfor (i = 0; i < dev_priv->num_fence_regs; i++) {\r\nstruct drm_i915_fence_reg *reg = &dev_priv->fence_regs[i];\r\nif (reg->obj) {\r\ni915_gem_object_update_fence(reg->obj, reg,\r\nreg->obj->tiling_mode);\r\n} else {\r\ni915_gem_write_fence(dev, i, NULL);\r\n}\r\n}\r\n}\r\nvoid\r\ni915_gem_detect_bit_6_swizzle(struct drm_device *dev)\r\n{\r\nstruct drm_i915_private *dev_priv = dev->dev_private;\r\nuint32_t swizzle_x = I915_BIT_6_SWIZZLE_UNKNOWN;\r\nuint32_t swizzle_y = I915_BIT_6_SWIZZLE_UNKNOWN;\r\nif (INTEL_INFO(dev)->gen >= 8 || IS_VALLEYVIEW(dev)) {\r\nswizzle_x = I915_BIT_6_SWIZZLE_NONE;\r\nswizzle_y = I915_BIT_6_SWIZZLE_NONE;\r\n} else if (INTEL_INFO(dev)->gen >= 6) {\r\nif (dev_priv->preserve_bios_swizzle) {\r\nif (I915_READ(DISP_ARB_CTL) &\r\nDISP_TILE_SURFACE_SWIZZLING) {\r\nswizzle_x = I915_BIT_6_SWIZZLE_9_10;\r\nswizzle_y = I915_BIT_6_SWIZZLE_9;\r\n} else {\r\nswizzle_x = I915_BIT_6_SWIZZLE_NONE;\r\nswizzle_y = I915_BIT_6_SWIZZLE_NONE;\r\n}\r\n} else {\r\nuint32_t dimm_c0, dimm_c1;\r\ndimm_c0 = I915_READ(MAD_DIMM_C0);\r\ndimm_c1 = I915_READ(MAD_DIMM_C1);\r\ndimm_c0 &= MAD_DIMM_A_SIZE_MASK | MAD_DIMM_B_SIZE_MASK;\r\ndimm_c1 &= MAD_DIMM_A_SIZE_MASK | MAD_DIMM_B_SIZE_MASK;\r\nif (dimm_c0 == dimm_c1) {\r\nswizzle_x = I915_BIT_6_SWIZZLE_9_10;\r\nswizzle_y = I915_BIT_6_SWIZZLE_9;\r\n} else {\r\nswizzle_x = I915_BIT_6_SWIZZLE_NONE;\r\nswizzle_y = I915_BIT_6_SWIZZLE_NONE;\r\n}\r\n}\r\n} else if (IS_GEN5(dev)) {\r\nswizzle_x = I915_BIT_6_SWIZZLE_9_10;\r\nswizzle_y = I915_BIT_6_SWIZZLE_9;\r\n} else if (IS_GEN2(dev)) {\r\nswizzle_x = I915_BIT_6_SWIZZLE_NONE;\r\nswizzle_y = I915_BIT_6_SWIZZLE_NONE;\r\n} else if (IS_MOBILE(dev) || (IS_GEN3(dev) && !IS_G33(dev))) {\r\nuint32_t dcc;\r\ndcc = I915_READ(DCC);\r\nswitch (dcc & DCC_ADDRESSING_MODE_MASK) {\r\ncase DCC_ADDRESSING_MODE_SINGLE_CHANNEL:\r\ncase DCC_ADDRESSING_MODE_DUAL_CHANNEL_ASYMMETRIC:\r\nswizzle_x = I915_BIT_6_SWIZZLE_NONE;\r\nswizzle_y = I915_BIT_6_SWIZZLE_NONE;\r\nbreak;\r\ncase DCC_ADDRESSING_MODE_DUAL_CHANNEL_INTERLEAVED:\r\nif (dcc & DCC_CHANNEL_XOR_DISABLE) {\r\nswizzle_x = I915_BIT_6_SWIZZLE_9_10;\r\nswizzle_y = I915_BIT_6_SWIZZLE_9;\r\n} else if ((dcc & DCC_CHANNEL_XOR_BIT_17) == 0) {\r\nswizzle_x = I915_BIT_6_SWIZZLE_9_10_11;\r\nswizzle_y = I915_BIT_6_SWIZZLE_9_11;\r\n} else {\r\nswizzle_x = I915_BIT_6_SWIZZLE_9_10_17;\r\nswizzle_y = I915_BIT_6_SWIZZLE_9_17;\r\n}\r\nbreak;\r\n}\r\nif (IS_GEN4(dev) &&\r\n!(I915_READ(DCC2) & DCC2_MODIFIED_ENHANCED_DISABLE)) {\r\nswizzle_x = I915_BIT_6_SWIZZLE_UNKNOWN;\r\nswizzle_y = I915_BIT_6_SWIZZLE_UNKNOWN;\r\n}\r\nif (dcc == 0xffffffff) {\r\nDRM_ERROR("Couldn't read from MCHBAR. "\r\n"Disabling tiling.\n");\r\nswizzle_x = I915_BIT_6_SWIZZLE_UNKNOWN;\r\nswizzle_y = I915_BIT_6_SWIZZLE_UNKNOWN;\r\n}\r\n} else {\r\nif (I915_READ16(C0DRB3) == I915_READ16(C1DRB3)) {\r\nswizzle_x = I915_BIT_6_SWIZZLE_9_10;\r\nswizzle_y = I915_BIT_6_SWIZZLE_9;\r\n}\r\n}\r\nif (swizzle_x == I915_BIT_6_SWIZZLE_UNKNOWN ||\r\nswizzle_y == I915_BIT_6_SWIZZLE_UNKNOWN) {\r\ndev_priv->quirks |= QUIRK_PIN_SWIZZLED_PAGES;\r\nswizzle_x = I915_BIT_6_SWIZZLE_NONE;\r\nswizzle_y = I915_BIT_6_SWIZZLE_NONE;\r\n}\r\ndev_priv->mm.bit_6_swizzle_x = swizzle_x;\r\ndev_priv->mm.bit_6_swizzle_y = swizzle_y;\r\n}\r\nstatic void\r\ni915_gem_swizzle_page(struct page *page)\r\n{\r\nchar temp[64];\r\nchar *vaddr;\r\nint i;\r\nvaddr = kmap(page);\r\nfor (i = 0; i < PAGE_SIZE; i += 128) {\r\nmemcpy(temp, &vaddr[i], 64);\r\nmemcpy(&vaddr[i], &vaddr[i + 64], 64);\r\nmemcpy(&vaddr[i + 64], temp, 64);\r\n}\r\nkunmap(page);\r\n}\r\nvoid\r\ni915_gem_object_do_bit_17_swizzle(struct drm_i915_gem_object *obj)\r\n{\r\nstruct sg_page_iter sg_iter;\r\nint i;\r\nif (obj->bit_17 == NULL)\r\nreturn;\r\ni = 0;\r\nfor_each_sg_page(obj->pages->sgl, &sg_iter, obj->pages->nents, 0) {\r\nstruct page *page = sg_page_iter_page(&sg_iter);\r\nchar new_bit_17 = page_to_phys(page) >> 17;\r\nif ((new_bit_17 & 0x1) !=\r\n(test_bit(i, obj->bit_17) != 0)) {\r\ni915_gem_swizzle_page(page);\r\nset_page_dirty(page);\r\n}\r\ni++;\r\n}\r\n}\r\nvoid\r\ni915_gem_object_save_bit_17_swizzle(struct drm_i915_gem_object *obj)\r\n{\r\nstruct sg_page_iter sg_iter;\r\nint page_count = obj->base.size >> PAGE_SHIFT;\r\nint i;\r\nif (obj->bit_17 == NULL) {\r\nobj->bit_17 = kcalloc(BITS_TO_LONGS(page_count),\r\nsizeof(long), GFP_KERNEL);\r\nif (obj->bit_17 == NULL) {\r\nDRM_ERROR("Failed to allocate memory for bit 17 "\r\n"record\n");\r\nreturn;\r\n}\r\n}\r\ni = 0;\r\nfor_each_sg_page(obj->pages->sgl, &sg_iter, obj->pages->nents, 0) {\r\nif (page_to_phys(sg_page_iter_page(&sg_iter)) & (1 << 17))\r\n__set_bit(i, obj->bit_17);\r\nelse\r\n__clear_bit(i, obj->bit_17);\r\ni++;\r\n}\r\n}
