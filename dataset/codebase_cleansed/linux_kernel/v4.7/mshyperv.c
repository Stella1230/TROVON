void hyperv_vector_handler(struct pt_regs *regs)\r\n{\r\nstruct pt_regs *old_regs = set_irq_regs(regs);\r\nentering_irq();\r\ninc_irq_stat(irq_hv_callback_count);\r\nif (vmbus_handler)\r\nvmbus_handler();\r\nexiting_irq();\r\nset_irq_regs(old_regs);\r\n}\r\nvoid hv_setup_vmbus_irq(void (*handler)(void))\r\n{\r\nvmbus_handler = handler;\r\nif (!test_bit(HYPERVISOR_CALLBACK_VECTOR, used_vectors))\r\nalloc_intr_gate(HYPERVISOR_CALLBACK_VECTOR,\r\nhyperv_callback_vector);\r\n}\r\nvoid hv_remove_vmbus_irq(void)\r\n{\r\nvmbus_handler = NULL;\r\n}\r\nvoid hv_setup_kexec_handler(void (*handler)(void))\r\n{\r\nhv_kexec_handler = handler;\r\n}\r\nvoid hv_remove_kexec_handler(void)\r\n{\r\nhv_kexec_handler = NULL;\r\n}\r\nvoid hv_setup_crash_handler(void (*handler)(struct pt_regs *regs))\r\n{\r\nhv_crash_handler = handler;\r\n}\r\nvoid hv_remove_crash_handler(void)\r\n{\r\nhv_crash_handler = NULL;\r\n}\r\nstatic void hv_machine_shutdown(void)\r\n{\r\nif (kexec_in_progress && hv_kexec_handler)\r\nhv_kexec_handler();\r\nnative_machine_shutdown();\r\n}\r\nstatic void hv_machine_crash_shutdown(struct pt_regs *regs)\r\n{\r\nif (hv_crash_handler)\r\nhv_crash_handler(regs);\r\nnative_machine_crash_shutdown(regs);\r\n}\r\nstatic uint32_t __init ms_hyperv_platform(void)\r\n{\r\nu32 eax;\r\nu32 hyp_signature[3];\r\nif (!boot_cpu_has(X86_FEATURE_HYPERVISOR))\r\nreturn 0;\r\ncpuid(HYPERV_CPUID_VENDOR_AND_MAX_FUNCTIONS,\r\n&eax, &hyp_signature[0], &hyp_signature[1], &hyp_signature[2]);\r\nif (eax >= HYPERV_CPUID_MIN &&\r\neax <= HYPERV_CPUID_MAX &&\r\n!memcmp("Microsoft Hv", hyp_signature, 12))\r\nreturn HYPERV_CPUID_VENDOR_AND_MAX_FUNCTIONS;\r\nreturn 0;\r\n}\r\nstatic cycle_t read_hv_clock(struct clocksource *arg)\r\n{\r\ncycle_t current_tick;\r\nrdmsrl(HV_X64_MSR_TIME_REF_COUNT, current_tick);\r\nreturn current_tick;\r\n}\r\nstatic unsigned char hv_get_nmi_reason(void)\r\n{\r\nreturn 0;\r\n}\r\nstatic void __init ms_hyperv_init_platform(void)\r\n{\r\nms_hyperv.features = cpuid_eax(HYPERV_CPUID_FEATURES);\r\nms_hyperv.misc_features = cpuid_edx(HYPERV_CPUID_FEATURES);\r\nms_hyperv.hints = cpuid_eax(HYPERV_CPUID_ENLIGHTMENT_INFO);\r\npr_info("HyperV: features 0x%x, hints 0x%x\n",\r\nms_hyperv.features, ms_hyperv.hints);\r\n#ifdef CONFIG_X86_LOCAL_APIC\r\nif (ms_hyperv.features & HV_X64_MSR_APIC_FREQUENCY_AVAILABLE) {\r\nu64 hv_lapic_frequency;\r\nrdmsrl(HV_X64_MSR_APIC_FREQUENCY, hv_lapic_frequency);\r\nhv_lapic_frequency = div_u64(hv_lapic_frequency, HZ);\r\nlapic_timer_frequency = hv_lapic_frequency;\r\npr_info("HyperV: LAPIC Timer Frequency: %#x\n",\r\nlapic_timer_frequency);\r\n}\r\n#endif\r\nif (ms_hyperv.features & HV_X64_MSR_TIME_REF_COUNT_AVAILABLE)\r\nclocksource_register_hz(&hyperv_cs, NSEC_PER_SEC/100);\r\n#ifdef CONFIG_X86_IO_APIC\r\nno_timer_check = 1;\r\n#endif\r\n#if IS_ENABLED(CONFIG_HYPERV) && defined(CONFIG_KEXEC_CORE)\r\nmachine_ops.shutdown = hv_machine_shutdown;\r\nmachine_ops.crash_shutdown = hv_machine_crash_shutdown;\r\n#endif\r\nmark_tsc_unstable("running on Hyper-V");\r\nif (efi_enabled(EFI_BOOT))\r\nx86_platform.get_nmi_reason = hv_get_nmi_reason;\r\n}
