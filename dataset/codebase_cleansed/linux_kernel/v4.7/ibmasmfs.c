static struct dentry *ibmasmfs_mount(struct file_system_type *fst,\r\nint flags, const char *name, void *data)\r\n{\r\nreturn mount_single(fst, flags, data, ibmasmfs_fill_super);\r\n}\r\nstatic int ibmasmfs_fill_super (struct super_block *sb, void *data, int silent)\r\n{\r\nstruct inode *root;\r\nsb->s_blocksize = PAGE_SIZE;\r\nsb->s_blocksize_bits = PAGE_SHIFT;\r\nsb->s_magic = IBMASMFS_MAGIC;\r\nsb->s_op = &ibmasmfs_s_ops;\r\nsb->s_time_gran = 1;\r\nroot = ibmasmfs_make_inode (sb, S_IFDIR | 0500);\r\nif (!root)\r\nreturn -ENOMEM;\r\nroot->i_op = &simple_dir_inode_operations;\r\nroot->i_fop = ibmasmfs_dir_ops;\r\nsb->s_root = d_make_root(root);\r\nif (!sb->s_root)\r\nreturn -ENOMEM;\r\nibmasmfs_create_files(sb);\r\nreturn 0;\r\n}\r\nstatic struct inode *ibmasmfs_make_inode(struct super_block *sb, int mode)\r\n{\r\nstruct inode *ret = new_inode(sb);\r\nif (ret) {\r\nret->i_ino = get_next_ino();\r\nret->i_mode = mode;\r\nret->i_atime = ret->i_mtime = ret->i_ctime = CURRENT_TIME;\r\n}\r\nreturn ret;\r\n}\r\nstatic struct dentry *ibmasmfs_create_file(struct dentry *parent,\r\nconst char *name,\r\nconst struct file_operations *fops,\r\nvoid *data,\r\nint mode)\r\n{\r\nstruct dentry *dentry;\r\nstruct inode *inode;\r\ndentry = d_alloc_name(parent, name);\r\nif (!dentry)\r\nreturn NULL;\r\ninode = ibmasmfs_make_inode(parent->d_sb, S_IFREG | mode);\r\nif (!inode) {\r\ndput(dentry);\r\nreturn NULL;\r\n}\r\ninode->i_fop = fops;\r\ninode->i_private = data;\r\nd_add(dentry, inode);\r\nreturn dentry;\r\n}\r\nstatic struct dentry *ibmasmfs_create_dir(struct dentry *parent,\r\nconst char *name)\r\n{\r\nstruct dentry *dentry;\r\nstruct inode *inode;\r\ndentry = d_alloc_name(parent, name);\r\nif (!dentry)\r\nreturn NULL;\r\ninode = ibmasmfs_make_inode(parent->d_sb, S_IFDIR | 0500);\r\nif (!inode) {\r\ndput(dentry);\r\nreturn NULL;\r\n}\r\ninode->i_op = &simple_dir_inode_operations;\r\ninode->i_fop = ibmasmfs_dir_ops;\r\nd_add(dentry, inode);\r\nreturn dentry;\r\n}\r\nint ibmasmfs_register(void)\r\n{\r\nreturn register_filesystem(&ibmasmfs_type);\r\n}\r\nvoid ibmasmfs_unregister(void)\r\n{\r\nunregister_filesystem(&ibmasmfs_type);\r\n}\r\nvoid ibmasmfs_add_sp(struct service_processor *sp)\r\n{\r\nlist_add(&sp->node, &service_processors);\r\n}\r\nstatic int command_file_open(struct inode *inode, struct file *file)\r\n{\r\nstruct ibmasmfs_command_data *command_data;\r\nif (!inode->i_private)\r\nreturn -ENODEV;\r\ncommand_data = kmalloc(sizeof(struct ibmasmfs_command_data), GFP_KERNEL);\r\nif (!command_data)\r\nreturn -ENOMEM;\r\ncommand_data->command = NULL;\r\ncommand_data->sp = inode->i_private;\r\nfile->private_data = command_data;\r\nreturn 0;\r\n}\r\nstatic int command_file_close(struct inode *inode, struct file *file)\r\n{\r\nstruct ibmasmfs_command_data *command_data = file->private_data;\r\nif (command_data->command)\r\ncommand_put(command_data->command);\r\nkfree(command_data);\r\nreturn 0;\r\n}\r\nstatic ssize_t command_file_read(struct file *file, char __user *buf, size_t count, loff_t *offset)\r\n{\r\nstruct ibmasmfs_command_data *command_data = file->private_data;\r\nstruct command *cmd;\r\nint len;\r\nunsigned long flags;\r\nif (*offset < 0)\r\nreturn -EINVAL;\r\nif (count == 0 || count > IBMASM_CMD_MAX_BUFFER_SIZE)\r\nreturn 0;\r\nif (*offset != 0)\r\nreturn 0;\r\nspin_lock_irqsave(&command_data->sp->lock, flags);\r\ncmd = command_data->command;\r\nif (cmd == NULL) {\r\nspin_unlock_irqrestore(&command_data->sp->lock, flags);\r\nreturn 0;\r\n}\r\ncommand_data->command = NULL;\r\nspin_unlock_irqrestore(&command_data->sp->lock, flags);\r\nif (cmd->status != IBMASM_CMD_COMPLETE) {\r\ncommand_put(cmd);\r\nreturn -EIO;\r\n}\r\nlen = min(count, cmd->buffer_size);\r\nif (copy_to_user(buf, cmd->buffer, len)) {\r\ncommand_put(cmd);\r\nreturn -EFAULT;\r\n}\r\ncommand_put(cmd);\r\nreturn len;\r\n}\r\nstatic ssize_t command_file_write(struct file *file, const char __user *ubuff, size_t count, loff_t *offset)\r\n{\r\nstruct ibmasmfs_command_data *command_data = file->private_data;\r\nstruct command *cmd;\r\nunsigned long flags;\r\nif (*offset < 0)\r\nreturn -EINVAL;\r\nif (count == 0 || count > IBMASM_CMD_MAX_BUFFER_SIZE)\r\nreturn 0;\r\nif (*offset != 0)\r\nreturn 0;\r\nif (command_data->command)\r\nreturn -EAGAIN;\r\ncmd = ibmasm_new_command(command_data->sp, count);\r\nif (!cmd)\r\nreturn -ENOMEM;\r\nif (copy_from_user(cmd->buffer, ubuff, count)) {\r\ncommand_put(cmd);\r\nreturn -EFAULT;\r\n}\r\nspin_lock_irqsave(&command_data->sp->lock, flags);\r\nif (command_data->command) {\r\nspin_unlock_irqrestore(&command_data->sp->lock, flags);\r\ncommand_put(cmd);\r\nreturn -EAGAIN;\r\n}\r\ncommand_data->command = cmd;\r\nspin_unlock_irqrestore(&command_data->sp->lock, flags);\r\nibmasm_exec_command(command_data->sp, cmd);\r\nibmasm_wait_for_response(cmd, get_dot_command_timeout(cmd->buffer));\r\nreturn count;\r\n}\r\nstatic int event_file_open(struct inode *inode, struct file *file)\r\n{\r\nstruct ibmasmfs_event_data *event_data;\r\nstruct service_processor *sp;\r\nif (!inode->i_private)\r\nreturn -ENODEV;\r\nsp = inode->i_private;\r\nevent_data = kmalloc(sizeof(struct ibmasmfs_event_data), GFP_KERNEL);\r\nif (!event_data)\r\nreturn -ENOMEM;\r\nibmasm_event_reader_register(sp, &event_data->reader);\r\nevent_data->sp = sp;\r\nevent_data->active = 0;\r\nfile->private_data = event_data;\r\nreturn 0;\r\n}\r\nstatic int event_file_close(struct inode *inode, struct file *file)\r\n{\r\nstruct ibmasmfs_event_data *event_data = file->private_data;\r\nibmasm_event_reader_unregister(event_data->sp, &event_data->reader);\r\nkfree(event_data);\r\nreturn 0;\r\n}\r\nstatic ssize_t event_file_read(struct file *file, char __user *buf, size_t count, loff_t *offset)\r\n{\r\nstruct ibmasmfs_event_data *event_data = file->private_data;\r\nstruct event_reader *reader = &event_data->reader;\r\nstruct service_processor *sp = event_data->sp;\r\nint ret;\r\nunsigned long flags;\r\nif (*offset < 0)\r\nreturn -EINVAL;\r\nif (count == 0 || count > IBMASM_EVENT_MAX_SIZE)\r\nreturn 0;\r\nif (*offset != 0)\r\nreturn 0;\r\nspin_lock_irqsave(&sp->lock, flags);\r\nif (event_data->active) {\r\nspin_unlock_irqrestore(&sp->lock, flags);\r\nreturn -EBUSY;\r\n}\r\nevent_data->active = 1;\r\nspin_unlock_irqrestore(&sp->lock, flags);\r\nret = ibmasm_get_next_event(sp, reader);\r\nif (ret <= 0)\r\ngoto out;\r\nif (count < reader->data_size) {\r\nret = -EINVAL;\r\ngoto out;\r\n}\r\nif (copy_to_user(buf, reader->data, reader->data_size)) {\r\nret = -EFAULT;\r\ngoto out;\r\n}\r\nret = reader->data_size;\r\nout:\r\nevent_data->active = 0;\r\nreturn ret;\r\n}\r\nstatic ssize_t event_file_write(struct file *file, const char __user *buf, size_t count, loff_t *offset)\r\n{\r\nstruct ibmasmfs_event_data *event_data = file->private_data;\r\nif (*offset < 0)\r\nreturn -EINVAL;\r\nif (count != 1)\r\nreturn 0;\r\nif (*offset != 0)\r\nreturn 0;\r\nibmasm_cancel_next_event(&event_data->reader);\r\nreturn 0;\r\n}\r\nstatic int r_heartbeat_file_open(struct inode *inode, struct file *file)\r\n{\r\nstruct ibmasmfs_heartbeat_data *rhbeat;\r\nif (!inode->i_private)\r\nreturn -ENODEV;\r\nrhbeat = kmalloc(sizeof(struct ibmasmfs_heartbeat_data), GFP_KERNEL);\r\nif (!rhbeat)\r\nreturn -ENOMEM;\r\nrhbeat->sp = inode->i_private;\r\nrhbeat->active = 0;\r\nibmasm_init_reverse_heartbeat(rhbeat->sp, &rhbeat->heartbeat);\r\nfile->private_data = rhbeat;\r\nreturn 0;\r\n}\r\nstatic int r_heartbeat_file_close(struct inode *inode, struct file *file)\r\n{\r\nstruct ibmasmfs_heartbeat_data *rhbeat = file->private_data;\r\nkfree(rhbeat);\r\nreturn 0;\r\n}\r\nstatic ssize_t r_heartbeat_file_read(struct file *file, char __user *buf, size_t count, loff_t *offset)\r\n{\r\nstruct ibmasmfs_heartbeat_data *rhbeat = file->private_data;\r\nunsigned long flags;\r\nint result;\r\nif (*offset < 0)\r\nreturn -EINVAL;\r\nif (count == 0 || count > 1024)\r\nreturn 0;\r\nif (*offset != 0)\r\nreturn 0;\r\nspin_lock_irqsave(&rhbeat->sp->lock, flags);\r\nif (rhbeat->active) {\r\nspin_unlock_irqrestore(&rhbeat->sp->lock, flags);\r\nreturn -EBUSY;\r\n}\r\nrhbeat->active = 1;\r\nspin_unlock_irqrestore(&rhbeat->sp->lock, flags);\r\nresult = ibmasm_start_reverse_heartbeat(rhbeat->sp, &rhbeat->heartbeat);\r\nrhbeat->active = 0;\r\nreturn result;\r\n}\r\nstatic ssize_t r_heartbeat_file_write(struct file *file, const char __user *buf, size_t count, loff_t *offset)\r\n{\r\nstruct ibmasmfs_heartbeat_data *rhbeat = file->private_data;\r\nif (*offset < 0)\r\nreturn -EINVAL;\r\nif (count != 1)\r\nreturn 0;\r\nif (*offset != 0)\r\nreturn 0;\r\nif (rhbeat->active)\r\nibmasm_stop_reverse_heartbeat(&rhbeat->heartbeat);\r\nreturn 1;\r\n}\r\nstatic int remote_settings_file_close(struct inode *inode, struct file *file)\r\n{\r\nreturn 0;\r\n}\r\nstatic ssize_t remote_settings_file_read(struct file *file, char __user *buf, size_t count, loff_t *offset)\r\n{\r\nvoid __iomem *address = (void __iomem *)file->private_data;\r\nunsigned char *page;\r\nint retval;\r\nint len = 0;\r\nunsigned int value;\r\nif (*offset < 0)\r\nreturn -EINVAL;\r\nif (count == 0 || count > 1024)\r\nreturn 0;\r\nif (*offset != 0)\r\nreturn 0;\r\npage = (unsigned char *)__get_free_page(GFP_KERNEL);\r\nif (!page)\r\nreturn -ENOMEM;\r\nvalue = readl(address);\r\nlen = sprintf(page, "%d\n", value);\r\nif (copy_to_user(buf, page, len)) {\r\nretval = -EFAULT;\r\ngoto exit;\r\n}\r\n*offset += len;\r\nretval = len;\r\nexit:\r\nfree_page((unsigned long)page);\r\nreturn retval;\r\n}\r\nstatic ssize_t remote_settings_file_write(struct file *file, const char __user *ubuff, size_t count, loff_t *offset)\r\n{\r\nvoid __iomem *address = (void __iomem *)file->private_data;\r\nchar *buff;\r\nunsigned int value;\r\nif (*offset < 0)\r\nreturn -EINVAL;\r\nif (count == 0 || count > 1024)\r\nreturn 0;\r\nif (*offset != 0)\r\nreturn 0;\r\nbuff = kzalloc (count + 1, GFP_KERNEL);\r\nif (!buff)\r\nreturn -ENOMEM;\r\nif (copy_from_user(buff, ubuff, count)) {\r\nkfree(buff);\r\nreturn -EFAULT;\r\n}\r\nvalue = simple_strtoul(buff, NULL, 10);\r\nwritel(value, address);\r\nkfree(buff);\r\nreturn count;\r\n}\r\nstatic void ibmasmfs_create_files (struct super_block *sb)\r\n{\r\nstruct list_head *entry;\r\nstruct service_processor *sp;\r\nlist_for_each(entry, &service_processors) {\r\nstruct dentry *dir;\r\nstruct dentry *remote_dir;\r\nsp = list_entry(entry, struct service_processor, node);\r\ndir = ibmasmfs_create_dir(sb->s_root, sp->dirname);\r\nif (!dir)\r\ncontinue;\r\nibmasmfs_create_file(dir, "command", &command_fops, sp, S_IRUSR|S_IWUSR);\r\nibmasmfs_create_file(dir, "event", &event_fops, sp, S_IRUSR|S_IWUSR);\r\nibmasmfs_create_file(dir, "reverse_heartbeat", &r_heartbeat_fops, sp, S_IRUSR|S_IWUSR);\r\nremote_dir = ibmasmfs_create_dir(dir, "remote_video");\r\nif (!remote_dir)\r\ncontinue;\r\nibmasmfs_create_file(remote_dir, "width", &remote_settings_fops, (void *)display_width(sp), S_IRUSR|S_IWUSR);\r\nibmasmfs_create_file(remote_dir, "height", &remote_settings_fops, (void *)display_height(sp), S_IRUSR|S_IWUSR);\r\nibmasmfs_create_file(remote_dir, "depth", &remote_settings_fops, (void *)display_depth(sp), S_IRUSR|S_IWUSR);\r\n}\r\n}
