static u32 bfin_fifo_offset(u8 epnum)\r\n{\r\nreturn USB_OFFSET(USB_EP0_FIFO) + (epnum * 8);\r\n}\r\nstatic u8 bfin_readb(const void __iomem *addr, unsigned offset)\r\n{\r\nreturn (u8)(bfin_read16(addr + offset));\r\n}\r\nstatic u16 bfin_readw(const void __iomem *addr, unsigned offset)\r\n{\r\nreturn bfin_read16(addr + offset);\r\n}\r\nstatic u32 bfin_readl(const void __iomem *addr, unsigned offset)\r\n{\r\nreturn (u32)(bfin_read16(addr + offset));\r\n}\r\nstatic void bfin_writeb(void __iomem *addr, unsigned offset, u8 data)\r\n{\r\nbfin_write16(addr + offset, (u16)data);\r\n}\r\nstatic void bfin_writew(void __iomem *addr, unsigned offset, u16 data)\r\n{\r\nbfin_write16(addr + offset, data);\r\n}\r\nstatic void bfin_writel(void __iomem *addr, unsigned offset, u32 data)\r\n{\r\nbfin_write16(addr + offset, (u16)data);\r\n}\r\nstatic void bfin_write_fifo(struct musb_hw_ep *hw_ep, u16 len, const u8 *src)\r\n{\r\nstruct musb *musb = hw_ep->musb;\r\nvoid __iomem *fifo = hw_ep->fifo;\r\nvoid __iomem *epio = hw_ep->regs;\r\nu8 epnum = hw_ep->epnum;\r\nprefetch((u8 *)src);\r\nmusb_writew(epio, MUSB_TXCOUNT, len);\r\ndev_dbg(musb->controller, "TX ep%d fifo %p count %d buf %p, epio %p\n",\r\nhw_ep->epnum, fifo, len, src, epio);\r\ndump_fifo_data(src, len);\r\nif (!ANOMALY_05000380 && epnum != 0) {\r\nu16 dma_reg;\r\nflush_dcache_range((unsigned long)src,\r\n(unsigned long)(src + len));\r\ndma_reg = (u32)src;\r\nbfin_write16(USB_DMA_REG(epnum, USB_DMAx_ADDR_LOW), dma_reg);\r\nSSYNC();\r\ndma_reg = (u32)src >> 16;\r\nbfin_write16(USB_DMA_REG(epnum, USB_DMAx_ADDR_HIGH), dma_reg);\r\nSSYNC();\r\nbfin_write16(USB_DMA_REG(epnum, USB_DMAx_COUNT_LOW), len);\r\nbfin_write16(USB_DMA_REG(epnum, USB_DMAx_COUNT_HIGH), 0);\r\nSSYNC();\r\ndma_reg = (epnum << 4) | DMA_ENA | INT_ENA | DIRECTION;\r\nbfin_write16(USB_DMA_REG(epnum, USB_DMAx_CTRL), dma_reg);\r\nSSYNC();\r\nwhile (!(bfin_read_USB_DMA_INTERRUPT() & (1 << epnum)))\r\ncpu_relax();\r\nbfin_write_USB_DMA_INTERRUPT(1 << epnum);\r\nSSYNC();\r\nbfin_write16(USB_DMA_REG(epnum, USB_DMAx_CTRL), 0);\r\nSSYNC();\r\n} else {\r\nSSYNC();\r\nif (unlikely((unsigned long)src & 0x01))\r\noutsw_8((unsigned long)fifo, src, (len + 1) >> 1);\r\nelse\r\noutsw((unsigned long)fifo, src, (len + 1) >> 1);\r\n}\r\n}\r\nstatic void bfin_read_fifo(struct musb_hw_ep *hw_ep, u16 len, u8 *dst)\r\n{\r\nstruct musb *musb = hw_ep->musb;\r\nvoid __iomem *fifo = hw_ep->fifo;\r\nu8 epnum = hw_ep->epnum;\r\nif (ANOMALY_05000467 && epnum != 0) {\r\nu16 dma_reg;\r\ninvalidate_dcache_range((unsigned long)dst,\r\n(unsigned long)(dst + len));\r\ndma_reg = (u32)dst;\r\nbfin_write16(USB_DMA_REG(epnum, USB_DMAx_ADDR_LOW), dma_reg);\r\nSSYNC();\r\ndma_reg = (u32)dst >> 16;\r\nbfin_write16(USB_DMA_REG(epnum, USB_DMAx_ADDR_HIGH), dma_reg);\r\nSSYNC();\r\nbfin_write16(USB_DMA_REG(epnum, USB_DMAx_COUNT_LOW), len);\r\nbfin_write16(USB_DMA_REG(epnum, USB_DMAx_COUNT_HIGH), 0);\r\nSSYNC();\r\ndma_reg = (epnum << 4) | DMA_ENA | INT_ENA;\r\nbfin_write16(USB_DMA_REG(epnum, USB_DMAx_CTRL), dma_reg);\r\nSSYNC();\r\nwhile (!(bfin_read_USB_DMA_INTERRUPT() & (1 << epnum)))\r\ncpu_relax();\r\nbfin_write_USB_DMA_INTERRUPT(1 << epnum);\r\nSSYNC();\r\nbfin_write16(USB_DMA_REG(epnum, USB_DMAx_CTRL), 0);\r\nSSYNC();\r\n} else {\r\nSSYNC();\r\nif (len == 1)\r\n*dst = (u8)inw((unsigned long)fifo + 4);\r\nelse {\r\nif (unlikely((unsigned long)dst & 0x01))\r\ninsw_8((unsigned long)fifo, dst, len >> 1);\r\nelse\r\ninsw((unsigned long)fifo, dst, len >> 1);\r\nif (len & 0x01)\r\n*(dst + len - 1) = (u8)inw((unsigned long)fifo + 4);\r\n}\r\n}\r\ndev_dbg(musb->controller, "%cX ep%d fifo %p count %d buf %p\n",\r\n'R', hw_ep->epnum, fifo, len, dst);\r\ndump_fifo_data(dst, len);\r\n}\r\nstatic irqreturn_t blackfin_interrupt(int irq, void *__hci)\r\n{\r\nunsigned long flags;\r\nirqreturn_t retval = IRQ_NONE;\r\nstruct musb *musb = __hci;\r\nspin_lock_irqsave(&musb->lock, flags);\r\nmusb->int_usb = musb_readb(musb->mregs, MUSB_INTRUSB);\r\nmusb->int_tx = musb_readw(musb->mregs, MUSB_INTRTX);\r\nmusb->int_rx = musb_readw(musb->mregs, MUSB_INTRRX);\r\nif (musb->int_usb || musb->int_tx || musb->int_rx) {\r\nmusb_writeb(musb->mregs, MUSB_INTRUSB, musb->int_usb);\r\nmusb_writew(musb->mregs, MUSB_INTRTX, musb->int_tx);\r\nmusb_writew(musb->mregs, MUSB_INTRRX, musb->int_rx);\r\nretval = musb_interrupt(musb);\r\n}\r\nif ((musb->xceiv->otg->state == OTG_STATE_B_IDLE\r\n|| musb->xceiv->otg->state == OTG_STATE_A_WAIT_BCON) ||\r\n(musb->int_usb & MUSB_INTR_DISCONNECT && is_host_active(musb))) {\r\nmod_timer(&musb_conn_timer, jiffies + TIMER_DELAY);\r\nmusb->a_wait_bcon = TIMER_DELAY;\r\n}\r\nspin_unlock_irqrestore(&musb->lock, flags);\r\nreturn retval;\r\n}\r\nstatic void musb_conn_timer_handler(unsigned long _musb)\r\n{\r\nstruct musb *musb = (void *)_musb;\r\nunsigned long flags;\r\nu16 val;\r\nstatic u8 toggle;\r\nspin_lock_irqsave(&musb->lock, flags);\r\nswitch (musb->xceiv->otg->state) {\r\ncase OTG_STATE_A_IDLE:\r\ncase OTG_STATE_A_WAIT_BCON:\r\nval = musb_readw(musb->mregs, MUSB_DEVCTL);\r\nval &= ~MUSB_DEVCTL_SESSION;\r\nmusb_writew(musb->mregs, MUSB_DEVCTL, val);\r\nval |= MUSB_DEVCTL_SESSION;\r\nmusb_writew(musb->mregs, MUSB_DEVCTL, val);\r\nval = musb_readw(musb->mregs, MUSB_DEVCTL);\r\nif (!(val & MUSB_DEVCTL_BDEVICE)) {\r\ngpio_set_value(musb->config->gpio_vrsel, 1);\r\nmusb->xceiv->otg->state = OTG_STATE_A_WAIT_BCON;\r\n} else {\r\ngpio_set_value(musb->config->gpio_vrsel, 0);\r\nval = musb_readb(musb->mregs, MUSB_INTRUSBE);\r\nval &= ~MUSB_INTR_VBUSERROR;\r\nmusb_writeb(musb->mregs, MUSB_INTRUSBE, val);\r\nval = MUSB_INTR_SUSPEND | MUSB_INTR_VBUSERROR;\r\nmusb_writeb(musb->mregs, MUSB_INTRUSB, val);\r\nmusb->xceiv->otg->state = OTG_STATE_B_IDLE;\r\n}\r\nmod_timer(&musb_conn_timer, jiffies + TIMER_DELAY);\r\nbreak;\r\ncase OTG_STATE_B_IDLE:\r\nval = musb_readw(musb->mregs, MUSB_DEVCTL);\r\nval |= MUSB_DEVCTL_SESSION;\r\nmusb_writew(musb->mregs, MUSB_DEVCTL, val);\r\nval = musb_readw(musb->mregs, MUSB_DEVCTL);\r\nif (!(val & MUSB_DEVCTL_BDEVICE)) {\r\ngpio_set_value(musb->config->gpio_vrsel, 1);\r\nmusb->xceiv->otg->state = OTG_STATE_A_WAIT_BCON;\r\n} else {\r\ngpio_set_value(musb->config->gpio_vrsel, 0);\r\nval = musb_readb(musb->mregs, MUSB_INTRUSBE);\r\nval &= ~MUSB_INTR_VBUSERROR;\r\nmusb_writeb(musb->mregs, MUSB_INTRUSBE, val);\r\nval = MUSB_INTR_SUSPEND | MUSB_INTR_VBUSERROR;\r\nmusb_writeb(musb->mregs, MUSB_INTRUSB, val);\r\nif (toggle) {\r\nval = musb_readb(musb->mregs, MUSB_POWER);\r\nval &= ~MUSB_POWER_SOFTCONN;\r\nmusb_writeb(musb->mregs, MUSB_POWER, val);\r\ntoggle = 0;\r\n} else {\r\nval = musb_readb(musb->mregs, MUSB_POWER);\r\nval |= MUSB_POWER_SOFTCONN;\r\nmusb_writeb(musb->mregs, MUSB_POWER, val);\r\ntoggle = 1;\r\n}\r\nmod_timer(&musb_conn_timer, jiffies + TIMER_DELAY / 4);\r\n}\r\nbreak;\r\ndefault:\r\ndev_dbg(musb->controller, "%s state not handled\n",\r\nusb_otg_state_string(musb->xceiv->otg->state));\r\nbreak;\r\n}\r\nspin_unlock_irqrestore(&musb->lock, flags);\r\ndev_dbg(musb->controller, "state is %s\n",\r\nusb_otg_state_string(musb->xceiv->otg->state));\r\n}\r\nstatic void bfin_musb_enable(struct musb *musb)\r\n{\r\n}\r\nstatic void bfin_musb_disable(struct musb *musb)\r\n{\r\n}\r\nstatic void bfin_musb_set_vbus(struct musb *musb, int is_on)\r\n{\r\nint value = musb->config->gpio_vrsel_active;\r\nif (!is_on)\r\nvalue = !value;\r\ngpio_set_value(musb->config->gpio_vrsel, value);\r\ndev_dbg(musb->controller, "VBUS %s, devctl %02x "\r\n"\n",\r\nusb_otg_state_string(musb->xceiv->otg->state),\r\nmusb_readb(musb->mregs, MUSB_DEVCTL));\r\n}\r\nstatic int bfin_musb_set_power(struct usb_phy *x, unsigned mA)\r\n{\r\nreturn 0;\r\n}\r\nstatic int bfin_musb_vbus_status(struct musb *musb)\r\n{\r\nreturn 0;\r\n}\r\nstatic int bfin_musb_set_mode(struct musb *musb, u8 musb_mode)\r\n{\r\nreturn -EIO;\r\n}\r\nstatic int bfin_musb_adjust_channel_params(struct dma_channel *channel,\r\nu16 packet_sz, u8 *mode,\r\ndma_addr_t *dma_addr, u32 *len)\r\n{\r\nstruct musb_dma_channel *musb_channel = channel->private_data;\r\nif (ANOMALY_05000450) {\r\nif (musb_channel->transmit && *mode == 1)\r\n*len = *len - (*len % packet_sz);\r\n}\r\nreturn 0;\r\n}\r\nstatic void bfin_musb_reg_init(struct musb *musb)\r\n{\r\nif (ANOMALY_05000346) {\r\nbfin_write_USB_APHY_CALIB(ANOMALY_05000346_value);\r\nSSYNC();\r\n}\r\nif (ANOMALY_05000347) {\r\nbfin_write_USB_APHY_CNTRL(0x0);\r\nSSYNC();\r\n}\r\nbfin_write_USB_PLLOSC_CTRL(0x3080 |\r\n((480/musb->config->clkin) << 1));\r\nSSYNC();\r\nbfin_write_USB_SRP_CLKDIV((get_sclk()/1000) / 32 - 1);\r\nSSYNC();\r\nbfin_write_USB_EP_NI0_RXMAXP(64);\r\nSSYNC();\r\nbfin_write_USB_EP_NI0_TXMAXP(64);\r\nSSYNC();\r\nbfin_write_USB_GLOBINTR(0x7);\r\nSSYNC();\r\nbfin_write_USB_GLOBAL_CTL(GLOBAL_ENA | EP1_TX_ENA | EP2_TX_ENA |\r\nEP3_TX_ENA | EP4_TX_ENA | EP5_TX_ENA |\r\nEP6_TX_ENA | EP7_TX_ENA | EP1_RX_ENA |\r\nEP2_RX_ENA | EP3_RX_ENA | EP4_RX_ENA |\r\nEP5_RX_ENA | EP6_RX_ENA | EP7_RX_ENA);\r\nSSYNC();\r\n}\r\nstatic int bfin_musb_init(struct musb *musb)\r\n{\r\nif (gpio_request(musb->config->gpio_vrsel, "USB_VRSEL")) {\r\nprintk(KERN_ERR "Failed ro request USB_VRSEL GPIO_%d\n",\r\nmusb->config->gpio_vrsel);\r\nreturn -ENODEV;\r\n}\r\ngpio_direction_output(musb->config->gpio_vrsel, 0);\r\nmusb->xceiv = usb_get_phy(USB_PHY_TYPE_USB2);\r\nif (IS_ERR_OR_NULL(musb->xceiv)) {\r\ngpio_free(musb->config->gpio_vrsel);\r\nreturn -EPROBE_DEFER;\r\n}\r\nbfin_musb_reg_init(musb);\r\nsetup_timer(&musb_conn_timer, musb_conn_timer_handler,\r\n(unsigned long) musb);\r\nmusb->xceiv->set_power = bfin_musb_set_power;\r\nmusb->isr = blackfin_interrupt;\r\nmusb->double_buffer_not_ok = true;\r\nreturn 0;\r\n}\r\nstatic int bfin_musb_exit(struct musb *musb)\r\n{\r\ngpio_free(musb->config->gpio_vrsel);\r\nusb_put_phy(musb->xceiv);\r\nreturn 0;\r\n}\r\nstatic int bfin_probe(struct platform_device *pdev)\r\n{\r\nstruct resource musb_resources[2];\r\nstruct musb_hdrc_platform_data *pdata = dev_get_platdata(&pdev->dev);\r\nstruct platform_device *musb;\r\nstruct bfin_glue *glue;\r\nint ret = -ENOMEM;\r\nglue = devm_kzalloc(&pdev->dev, sizeof(*glue), GFP_KERNEL);\r\nif (!glue)\r\ngoto err0;\r\nmusb = platform_device_alloc("musb-hdrc", PLATFORM_DEVID_AUTO);\r\nif (!musb)\r\ngoto err0;\r\nmusb->dev.parent = &pdev->dev;\r\nmusb->dev.dma_mask = &bfin_dmamask;\r\nmusb->dev.coherent_dma_mask = bfin_dmamask;\r\nglue->dev = &pdev->dev;\r\nglue->musb = musb;\r\npdata->platform_ops = &bfin_ops;\r\nglue->phy = usb_phy_generic_register();\r\nif (IS_ERR(glue->phy))\r\ngoto err1;\r\nplatform_set_drvdata(pdev, glue);\r\nmemset(musb_resources, 0x00, sizeof(*musb_resources) *\r\nARRAY_SIZE(musb_resources));\r\nmusb_resources[0].name = pdev->resource[0].name;\r\nmusb_resources[0].start = pdev->resource[0].start;\r\nmusb_resources[0].end = pdev->resource[0].end;\r\nmusb_resources[0].flags = pdev->resource[0].flags;\r\nmusb_resources[1].name = pdev->resource[1].name;\r\nmusb_resources[1].start = pdev->resource[1].start;\r\nmusb_resources[1].end = pdev->resource[1].end;\r\nmusb_resources[1].flags = pdev->resource[1].flags;\r\nret = platform_device_add_resources(musb, musb_resources,\r\nARRAY_SIZE(musb_resources));\r\nif (ret) {\r\ndev_err(&pdev->dev, "failed to add resources\n");\r\ngoto err2;\r\n}\r\nret = platform_device_add_data(musb, pdata, sizeof(*pdata));\r\nif (ret) {\r\ndev_err(&pdev->dev, "failed to add platform_data\n");\r\ngoto err2;\r\n}\r\nret = platform_device_add(musb);\r\nif (ret) {\r\ndev_err(&pdev->dev, "failed to register musb device\n");\r\ngoto err2;\r\n}\r\nreturn 0;\r\nerr2:\r\nusb_phy_generic_unregister(glue->phy);\r\nerr1:\r\nplatform_device_put(musb);\r\nerr0:\r\nreturn ret;\r\n}\r\nstatic int bfin_remove(struct platform_device *pdev)\r\n{\r\nstruct bfin_glue *glue = platform_get_drvdata(pdev);\r\nplatform_device_unregister(glue->musb);\r\nusb_phy_generic_unregister(glue->phy);\r\nreturn 0;\r\n}\r\nstatic int bfin_suspend(struct device *dev)\r\n{\r\nstruct bfin_glue *glue = dev_get_drvdata(dev);\r\nstruct musb *musb = glue_to_musb(glue);\r\nif (is_host_active(musb))\r\ngpio_set_value(musb->config->gpio_vrsel, 0);\r\nreturn 0;\r\n}\r\nstatic int bfin_resume(struct device *dev)\r\n{\r\nstruct bfin_glue *glue = dev_get_drvdata(dev);\r\nstruct musb *musb = glue_to_musb(glue);\r\nbfin_musb_reg_init(musb);\r\nreturn 0;\r\n}
