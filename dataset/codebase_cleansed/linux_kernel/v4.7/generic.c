static inline const char *plural(int n)\r\n{\r\nreturn (n == 1 ? "" : "s");\r\n}\r\nstatic int is_rndis(struct usb_interface_descriptor *desc)\r\n{\r\nreturn desc->bInterfaceClass == USB_CLASS_COMM\r\n&& desc->bInterfaceSubClass == 2\r\n&& desc->bInterfaceProtocol == 0xff;\r\n}\r\nstatic int is_activesync(struct usb_interface_descriptor *desc)\r\n{\r\nreturn desc->bInterfaceClass == USB_CLASS_MISC\r\n&& desc->bInterfaceSubClass == 1\r\n&& desc->bInterfaceProtocol == 1;\r\n}\r\nint usb_choose_configuration(struct usb_device *udev)\r\n{\r\nint i;\r\nint num_configs;\r\nint insufficient_power = 0;\r\nstruct usb_host_config *c, *best;\r\nif (usb_device_is_owned(udev))\r\nreturn 0;\r\nbest = NULL;\r\nc = udev->config;\r\nnum_configs = udev->descriptor.bNumConfigurations;\r\nfor (i = 0; i < num_configs; (i++, c++)) {\r\nstruct usb_interface_descriptor *desc = NULL;\r\nif (c->desc.bNumInterfaces > 0)\r\ndesc = &c->intf_cache[0]->altsetting->desc;\r\n#if 0\r\nif (bus_powered && (c->desc.bmAttributes &\r\nUSB_CONFIG_ATT_SELFPOWER))\r\ncontinue;\r\n#endif\r\nif (usb_get_max_power(udev, c) > udev->bus_mA) {\r\ninsufficient_power++;\r\ncontinue;\r\n}\r\nif (i == 0 && num_configs > 1 && desc &&\r\n(is_rndis(desc) || is_activesync(desc))) {\r\n#if !defined(CONFIG_USB_NET_RNDIS_HOST) && !defined(CONFIG_USB_NET_RNDIS_HOST_MODULE)\r\ncontinue;\r\n#else\r\nbest = c;\r\n#endif\r\n}\r\nelse if (udev->descriptor.bDeviceClass !=\r\nUSB_CLASS_VENDOR_SPEC &&\r\n(desc && desc->bInterfaceClass !=\r\nUSB_CLASS_VENDOR_SPEC)) {\r\nbest = c;\r\nbreak;\r\n}\r\nelse if (!best)\r\nbest = c;\r\n}\r\nif (insufficient_power > 0)\r\ndev_info(&udev->dev, "rejected %d configuration%s "\r\n"due to insufficient available bus power\n",\r\ninsufficient_power, plural(insufficient_power));\r\nif (best) {\r\ni = best->desc.bConfigurationValue;\r\ndev_dbg(&udev->dev,\r\n"configuration #%d chosen from %d choice%s\n",\r\ni, num_configs, plural(num_configs));\r\n} else {\r\ni = -1;\r\ndev_warn(&udev->dev,\r\n"no configuration chosen from %d choice%s\n",\r\nnum_configs, plural(num_configs));\r\n}\r\nreturn i;\r\n}\r\nstatic int generic_probe(struct usb_device *udev)\r\n{\r\nint err, c;\r\nif (udev->authorized == 0)\r\ndev_err(&udev->dev, "Device is not authorized for usage\n");\r\nelse {\r\nc = usb_choose_configuration(udev);\r\nif (c >= 0) {\r\nerr = usb_set_configuration(udev, c);\r\nif (err && err != -ENODEV) {\r\ndev_err(&udev->dev, "can't set config #%d, error %d\n",\r\nc, err);\r\n}\r\n}\r\n}\r\nusb_notify_add_device(udev);\r\nreturn 0;\r\n}\r\nstatic void generic_disconnect(struct usb_device *udev)\r\n{\r\nusb_notify_remove_device(udev);\r\nif (udev->actconfig)\r\nusb_set_configuration(udev, -1);\r\n}\r\nstatic int generic_suspend(struct usb_device *udev, pm_message_t msg)\r\n{\r\nint rc;\r\nif (!udev->parent)\r\nrc = hcd_bus_suspend(udev, msg);\r\nelse if (msg.event == PM_EVENT_FREEZE || msg.event == PM_EVENT_PRETHAW)\r\nrc = 0;\r\nelse\r\nrc = usb_port_suspend(udev, msg);\r\nreturn rc;\r\n}\r\nstatic int generic_resume(struct usb_device *udev, pm_message_t msg)\r\n{\r\nint rc;\r\nif (!udev->parent)\r\nrc = hcd_bus_resume(udev, msg);\r\nelse\r\nrc = usb_port_resume(udev, msg);\r\nreturn rc;\r\n}
