static void cirrus_crtc_load_lut(struct drm_crtc *crtc)\r\n{\r\nstruct cirrus_crtc *cirrus_crtc = to_cirrus_crtc(crtc);\r\nstruct drm_device *dev = crtc->dev;\r\nstruct cirrus_device *cdev = dev->dev_private;\r\nint i;\r\nif (!crtc->enabled)\r\nreturn;\r\nfor (i = 0; i < CIRRUS_LUT_SIZE; i++) {\r\nWREG8(PALETTE_INDEX, i);\r\nWREG8(PALETTE_DATA, cirrus_crtc->lut_r[i]);\r\nWREG8(PALETTE_DATA, cirrus_crtc->lut_g[i]);\r\nWREG8(PALETTE_DATA, cirrus_crtc->lut_b[i]);\r\n}\r\n}\r\nstatic void cirrus_crtc_dpms(struct drm_crtc *crtc, int mode)\r\n{\r\nstruct drm_device *dev = crtc->dev;\r\nstruct cirrus_device *cdev = dev->dev_private;\r\nu8 sr01, gr0e;\r\nswitch (mode) {\r\ncase DRM_MODE_DPMS_ON:\r\nsr01 = 0x00;\r\ngr0e = 0x00;\r\nbreak;\r\ncase DRM_MODE_DPMS_STANDBY:\r\nsr01 = 0x20;\r\ngr0e = 0x02;\r\nbreak;\r\ncase DRM_MODE_DPMS_SUSPEND:\r\nsr01 = 0x20;\r\ngr0e = 0x04;\r\nbreak;\r\ncase DRM_MODE_DPMS_OFF:\r\nsr01 = 0x20;\r\ngr0e = 0x06;\r\nbreak;\r\ndefault:\r\nreturn;\r\n}\r\nWREG8(SEQ_INDEX, 0x1);\r\nsr01 |= RREG8(SEQ_DATA) & ~0x20;\r\nWREG_SEQ(0x1, sr01);\r\nWREG8(GFX_INDEX, 0xe);\r\ngr0e |= RREG8(GFX_DATA) & ~0x06;\r\nWREG_GFX(0xe, gr0e);\r\n}\r\nstatic void cirrus_set_start_address(struct drm_crtc *crtc, unsigned offset)\r\n{\r\nstruct cirrus_device *cdev = crtc->dev->dev_private;\r\nu32 addr;\r\nu8 tmp;\r\naddr = offset >> 2;\r\nWREG_CRT(0x0c, (u8)((addr >> 8) & 0xff));\r\nWREG_CRT(0x0d, (u8)(addr & 0xff));\r\nWREG8(CRT_INDEX, 0x1b);\r\ntmp = RREG8(CRT_DATA);\r\ntmp &= 0xf2;\r\ntmp |= (addr >> 16) & 0x01;\r\ntmp |= (addr >> 15) & 0x0c;\r\nWREG_CRT(0x1b, tmp);\r\nWREG8(CRT_INDEX, 0x1d);\r\ntmp = RREG8(CRT_DATA);\r\ntmp &= 0x7f;\r\ntmp |= (addr >> 12) & 0x80;\r\nWREG_CRT(0x1d, tmp);\r\n}\r\nstatic int cirrus_crtc_do_set_base(struct drm_crtc *crtc,\r\nstruct drm_framebuffer *fb,\r\nint x, int y, int atomic)\r\n{\r\nstruct cirrus_device *cdev = crtc->dev->dev_private;\r\nstruct drm_gem_object *obj;\r\nstruct cirrus_framebuffer *cirrus_fb;\r\nstruct cirrus_bo *bo;\r\nint ret;\r\nu64 gpu_addr;\r\nif (!atomic && fb) {\r\ncirrus_fb = to_cirrus_framebuffer(fb);\r\nobj = cirrus_fb->obj;\r\nbo = gem_to_cirrus_bo(obj);\r\nret = cirrus_bo_reserve(bo, false);\r\nif (ret)\r\nreturn ret;\r\ncirrus_bo_push_sysram(bo);\r\ncirrus_bo_unreserve(bo);\r\n}\r\ncirrus_fb = to_cirrus_framebuffer(crtc->primary->fb);\r\nobj = cirrus_fb->obj;\r\nbo = gem_to_cirrus_bo(obj);\r\nret = cirrus_bo_reserve(bo, false);\r\nif (ret)\r\nreturn ret;\r\nret = cirrus_bo_pin(bo, TTM_PL_FLAG_VRAM, &gpu_addr);\r\nif (ret) {\r\ncirrus_bo_unreserve(bo);\r\nreturn ret;\r\n}\r\nif (&cdev->mode_info.gfbdev->gfb == cirrus_fb) {\r\nret = ttm_bo_kmap(&bo->bo, 0, bo->bo.num_pages, &bo->kmap);\r\nif (ret)\r\nDRM_ERROR("failed to kmap fbcon\n");\r\n}\r\ncirrus_bo_unreserve(bo);\r\ncirrus_set_start_address(crtc, (u32)gpu_addr);\r\nreturn 0;\r\n}\r\nstatic int cirrus_crtc_mode_set_base(struct drm_crtc *crtc, int x, int y,\r\nstruct drm_framebuffer *old_fb)\r\n{\r\nreturn cirrus_crtc_do_set_base(crtc, old_fb, x, y, 0);\r\n}\r\nstatic int cirrus_crtc_mode_set(struct drm_crtc *crtc,\r\nstruct drm_display_mode *mode,\r\nstruct drm_display_mode *adjusted_mode,\r\nint x, int y, struct drm_framebuffer *old_fb)\r\n{\r\nstruct drm_device *dev = crtc->dev;\r\nstruct cirrus_device *cdev = dev->dev_private;\r\nint hsyncstart, hsyncend, htotal, hdispend;\r\nint vtotal, vdispend;\r\nint tmp;\r\nint sr07 = 0, hdr = 0;\r\nhtotal = mode->htotal / 8;\r\nhsyncend = mode->hsync_end / 8;\r\nhsyncstart = mode->hsync_start / 8;\r\nhdispend = mode->hdisplay / 8;\r\nvtotal = mode->vtotal;\r\nvdispend = mode->vdisplay;\r\nvdispend -= 1;\r\nvtotal -= 2;\r\nhtotal -= 5;\r\nhdispend -= 1;\r\nhsyncstart += 1;\r\nhsyncend += 1;\r\nWREG_CRT(VGA_CRTC_V_SYNC_END, 0x20);\r\nWREG_CRT(VGA_CRTC_H_TOTAL, htotal);\r\nWREG_CRT(VGA_CRTC_H_DISP, hdispend);\r\nWREG_CRT(VGA_CRTC_H_SYNC_START, hsyncstart);\r\nWREG_CRT(VGA_CRTC_H_SYNC_END, hsyncend);\r\nWREG_CRT(VGA_CRTC_V_TOTAL, vtotal & 0xff);\r\nWREG_CRT(VGA_CRTC_V_DISP_END, vdispend & 0xff);\r\ntmp = 0x40;\r\nif ((vdispend + 1) & 512)\r\ntmp |= 0x20;\r\nWREG_CRT(VGA_CRTC_MAX_SCAN, tmp);\r\ntmp = 16;\r\nif (vtotal & 256)\r\ntmp |= 1;\r\nif (vdispend & 256)\r\ntmp |= 2;\r\nif ((vdispend + 1) & 256)\r\ntmp |= 8;\r\nif (vtotal & 512)\r\ntmp |= 32;\r\nif (vdispend & 512)\r\ntmp |= 64;\r\nWREG_CRT(VGA_CRTC_OVERFLOW, tmp);\r\ntmp = 0;\r\nif ((htotal + 5) & 64)\r\ntmp |= 16;\r\nif ((htotal + 5) & 128)\r\ntmp |= 32;\r\nif (vtotal & 256)\r\ntmp |= 64;\r\nif (vtotal & 512)\r\ntmp |= 128;\r\nWREG_CRT(CL_CRT1A, tmp);\r\nWREG_CRT(VGA_CRTC_MODE, 0x03);\r\nWREG8(SEQ_INDEX, 0x7);\r\nsr07 = RREG8(SEQ_DATA);\r\nsr07 &= 0xe0;\r\nhdr = 0;\r\nswitch (crtc->primary->fb->bits_per_pixel) {\r\ncase 8:\r\nsr07 |= 0x11;\r\nbreak;\r\ncase 16:\r\nsr07 |= 0x17;\r\nhdr = 0xc1;\r\nbreak;\r\ncase 24:\r\nsr07 |= 0x15;\r\nhdr = 0xc5;\r\nbreak;\r\ncase 32:\r\nsr07 |= 0x19;\r\nhdr = 0xc5;\r\nbreak;\r\ndefault:\r\nreturn -1;\r\n}\r\nWREG_SEQ(0x7, sr07);\r\ntmp = crtc->primary->fb->pitches[0] / 8;\r\nWREG_CRT(VGA_CRTC_OFFSET, tmp);\r\ntmp = 0x22;\r\ntmp |= (crtc->primary->fb->pitches[0] >> 7) & 0x10;\r\ntmp |= (crtc->primary->fb->pitches[0] >> 6) & 0x40;\r\nWREG_CRT(0x1b, tmp);\r\nWREG_GFX(VGA_GFX_MODE, 0x40);\r\nWREG_GFX(VGA_GFX_MISC, 0x01);\r\nWREG_HDR(hdr);\r\ncirrus_crtc_do_set_base(crtc, old_fb, x, y, 0);\r\noutb(0x20, 0x3c0);\r\nreturn 0;\r\n}\r\nstatic void cirrus_crtc_prepare(struct drm_crtc *crtc)\r\n{\r\n}\r\nstatic void cirrus_crtc_commit(struct drm_crtc *crtc)\r\n{\r\n}\r\nstatic void cirrus_crtc_gamma_set(struct drm_crtc *crtc, u16 *red, u16 *green,\r\nu16 *blue, uint32_t start, uint32_t size)\r\n{\r\nstruct cirrus_crtc *cirrus_crtc = to_cirrus_crtc(crtc);\r\nint i;\r\nif (size != CIRRUS_LUT_SIZE)\r\nreturn;\r\nfor (i = 0; i < CIRRUS_LUT_SIZE; i++) {\r\ncirrus_crtc->lut_r[i] = red[i];\r\ncirrus_crtc->lut_g[i] = green[i];\r\ncirrus_crtc->lut_b[i] = blue[i];\r\n}\r\ncirrus_crtc_load_lut(crtc);\r\n}\r\nstatic void cirrus_crtc_destroy(struct drm_crtc *crtc)\r\n{\r\nstruct cirrus_crtc *cirrus_crtc = to_cirrus_crtc(crtc);\r\ndrm_crtc_cleanup(crtc);\r\nkfree(cirrus_crtc);\r\n}\r\nstatic void cirrus_crtc_init(struct drm_device *dev)\r\n{\r\nstruct cirrus_device *cdev = dev->dev_private;\r\nstruct cirrus_crtc *cirrus_crtc;\r\nint i;\r\ncirrus_crtc = kzalloc(sizeof(struct cirrus_crtc) +\r\n(CIRRUSFB_CONN_LIMIT * sizeof(struct drm_connector *)),\r\nGFP_KERNEL);\r\nif (cirrus_crtc == NULL)\r\nreturn;\r\ndrm_crtc_init(dev, &cirrus_crtc->base, &cirrus_crtc_funcs);\r\ndrm_mode_crtc_set_gamma_size(&cirrus_crtc->base, CIRRUS_LUT_SIZE);\r\ncdev->mode_info.crtc = cirrus_crtc;\r\nfor (i = 0; i < CIRRUS_LUT_SIZE; i++) {\r\ncirrus_crtc->lut_r[i] = i;\r\ncirrus_crtc->lut_g[i] = i;\r\ncirrus_crtc->lut_b[i] = i;\r\n}\r\ndrm_crtc_helper_add(&cirrus_crtc->base, &cirrus_helper_funcs);\r\n}\r\nvoid cirrus_crtc_fb_gamma_set(struct drm_crtc *crtc, u16 red, u16 green,\r\nu16 blue, int regno)\r\n{\r\nstruct cirrus_crtc *cirrus_crtc = to_cirrus_crtc(crtc);\r\ncirrus_crtc->lut_r[regno] = red;\r\ncirrus_crtc->lut_g[regno] = green;\r\ncirrus_crtc->lut_b[regno] = blue;\r\n}\r\nvoid cirrus_crtc_fb_gamma_get(struct drm_crtc *crtc, u16 *red, u16 *green,\r\nu16 *blue, int regno)\r\n{\r\nstruct cirrus_crtc *cirrus_crtc = to_cirrus_crtc(crtc);\r\n*red = cirrus_crtc->lut_r[regno];\r\n*green = cirrus_crtc->lut_g[regno];\r\n*blue = cirrus_crtc->lut_b[regno];\r\n}\r\nstatic void cirrus_encoder_mode_set(struct drm_encoder *encoder,\r\nstruct drm_display_mode *mode,\r\nstruct drm_display_mode *adjusted_mode)\r\n{\r\n}\r\nstatic void cirrus_encoder_dpms(struct drm_encoder *encoder, int state)\r\n{\r\nreturn;\r\n}\r\nstatic void cirrus_encoder_prepare(struct drm_encoder *encoder)\r\n{\r\n}\r\nstatic void cirrus_encoder_commit(struct drm_encoder *encoder)\r\n{\r\n}\r\nstatic void cirrus_encoder_destroy(struct drm_encoder *encoder)\r\n{\r\nstruct cirrus_encoder *cirrus_encoder = to_cirrus_encoder(encoder);\r\ndrm_encoder_cleanup(encoder);\r\nkfree(cirrus_encoder);\r\n}\r\nstatic struct drm_encoder *cirrus_encoder_init(struct drm_device *dev)\r\n{\r\nstruct drm_encoder *encoder;\r\nstruct cirrus_encoder *cirrus_encoder;\r\ncirrus_encoder = kzalloc(sizeof(struct cirrus_encoder), GFP_KERNEL);\r\nif (!cirrus_encoder)\r\nreturn NULL;\r\nencoder = &cirrus_encoder->base;\r\nencoder->possible_crtcs = 0x1;\r\ndrm_encoder_init(dev, encoder, &cirrus_encoder_encoder_funcs,\r\nDRM_MODE_ENCODER_DAC, NULL);\r\ndrm_encoder_helper_add(encoder, &cirrus_encoder_helper_funcs);\r\nreturn encoder;\r\n}\r\nstatic int cirrus_vga_get_modes(struct drm_connector *connector)\r\n{\r\nint count;\r\nif (cirrus_bpp <= 24) {\r\ncount = drm_add_modes_noedid(connector, 1280, 1024);\r\ndrm_set_preferred_mode(connector, 1024, 768);\r\n} else {\r\ncount = drm_add_modes_noedid(connector, 800, 600);\r\ndrm_set_preferred_mode(connector, 800, 600);\r\n}\r\nreturn count;\r\n}\r\nstatic struct drm_encoder *cirrus_connector_best_encoder(struct drm_connector\r\n*connector)\r\n{\r\nint enc_id = connector->encoder_ids[0];\r\nif (enc_id)\r\nreturn drm_encoder_find(connector->dev, enc_id);\r\nreturn NULL;\r\n}\r\nstatic enum drm_connector_status cirrus_vga_detect(struct drm_connector\r\n*connector, bool force)\r\n{\r\nreturn connector_status_connected;\r\n}\r\nstatic void cirrus_connector_destroy(struct drm_connector *connector)\r\n{\r\ndrm_connector_cleanup(connector);\r\nkfree(connector);\r\n}\r\nstatic struct drm_connector *cirrus_vga_init(struct drm_device *dev)\r\n{\r\nstruct drm_connector *connector;\r\nstruct cirrus_connector *cirrus_connector;\r\ncirrus_connector = kzalloc(sizeof(struct cirrus_connector), GFP_KERNEL);\r\nif (!cirrus_connector)\r\nreturn NULL;\r\nconnector = &cirrus_connector->base;\r\ndrm_connector_init(dev, connector,\r\n&cirrus_vga_connector_funcs, DRM_MODE_CONNECTOR_VGA);\r\ndrm_connector_helper_add(connector, &cirrus_vga_connector_helper_funcs);\r\ndrm_connector_register(connector);\r\nreturn connector;\r\n}\r\nint cirrus_modeset_init(struct cirrus_device *cdev)\r\n{\r\nstruct drm_encoder *encoder;\r\nstruct drm_connector *connector;\r\nint ret;\r\ndrm_mode_config_init(cdev->dev);\r\ncdev->mode_info.mode_config_initialized = true;\r\ncdev->dev->mode_config.max_width = CIRRUS_MAX_FB_WIDTH;\r\ncdev->dev->mode_config.max_height = CIRRUS_MAX_FB_HEIGHT;\r\ncdev->dev->mode_config.fb_base = cdev->mc.vram_base;\r\ncdev->dev->mode_config.preferred_depth = 24;\r\ncdev->dev->mode_config.prefer_shadow = 0;\r\ncirrus_crtc_init(cdev->dev);\r\nencoder = cirrus_encoder_init(cdev->dev);\r\nif (!encoder) {\r\nDRM_ERROR("cirrus_encoder_init failed\n");\r\nreturn -1;\r\n}\r\nconnector = cirrus_vga_init(cdev->dev);\r\nif (!connector) {\r\nDRM_ERROR("cirrus_vga_init failed\n");\r\nreturn -1;\r\n}\r\ndrm_mode_connector_attach_encoder(connector, encoder);\r\nret = cirrus_fbdev_init(cdev);\r\nif (ret) {\r\nDRM_ERROR("cirrus_fbdev_init failed\n");\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nvoid cirrus_modeset_fini(struct cirrus_device *cdev)\r\n{\r\ncirrus_fbdev_fini(cdev);\r\nif (cdev->mode_info.mode_config_initialized) {\r\ndrm_mode_config_cleanup(cdev->dev);\r\ncdev->mode_info.mode_config_initialized = false;\r\n}\r\n}
