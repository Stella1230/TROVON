static bool\r\nai_buscore_setup(struct si_info *sii, struct bcma_device *cc)\r\n{\r\nif (cc->bus->nr_cores == 0)\r\nreturn false;\r\nsii->pub.ccrev = cc->id.rev;\r\nsii->chipst = bcma_read32(cc, CHIPCREGOFFS(chipstatus));\r\nsii->pub.cccaps = bcma_read32(cc, CHIPCREGOFFS(capabilities));\r\nif (ai_get_cccaps(&sii->pub) & CC_CAP_PMU) {\r\nsii->pub.pmucaps = bcma_read32(cc,\r\nCHIPCREGOFFS(pmucapabilities));\r\nsii->pub.pmurev = sii->pub.pmucaps & PCAP_REV_MASK;\r\n}\r\nreturn true;\r\n}\r\nstatic struct si_info *ai_doattach(struct si_info *sii,\r\nstruct bcma_bus *pbus)\r\n{\r\nstruct si_pub *sih = &sii->pub;\r\nstruct bcma_device *cc;\r\nsii->icbus = pbus;\r\nsii->pcibus = pbus->host_pci;\r\ncc = pbus->drv_cc.core;\r\nsih->chip = pbus->chipinfo.id;\r\nsih->chiprev = pbus->chipinfo.rev;\r\nsih->chippkg = pbus->chipinfo.pkg;\r\nsih->boardvendor = pbus->boardinfo.vendor;\r\nsih->boardtype = pbus->boardinfo.type;\r\nif (!ai_buscore_setup(sii, cc))\r\ngoto exit;\r\nbcma_write32(cc, CHIPCREGOFFS(gpiopullup), 0);\r\nbcma_write32(cc, CHIPCREGOFFS(gpiopulldown), 0);\r\nif (ai_get_cccaps(sih) & CC_CAP_PMU) {\r\n(void)si_pmu_measure_alpclk(sih);\r\n}\r\nreturn sii;\r\nexit:\r\nreturn NULL;\r\n}\r\nstruct si_pub *\r\nai_attach(struct bcma_bus *pbus)\r\n{\r\nstruct si_info *sii;\r\nsii = kzalloc(sizeof(struct si_info), GFP_ATOMIC);\r\nif (sii == NULL)\r\nreturn NULL;\r\nif (ai_doattach(sii, pbus) == NULL) {\r\nkfree(sii);\r\nreturn NULL;\r\n}\r\nreturn (struct si_pub *) sii;\r\n}\r\nvoid ai_detach(struct si_pub *sih)\r\n{\r\nstruct si_info *sii;\r\nsii = container_of(sih, struct si_info, pub);\r\nif (sii == NULL)\r\nreturn;\r\nkfree(sii);\r\n}\r\nuint ai_cc_reg(struct si_pub *sih, uint regoff, u32 mask, u32 val)\r\n{\r\nstruct bcma_device *cc;\r\nu32 w;\r\nstruct si_info *sii;\r\nsii = container_of(sih, struct si_info, pub);\r\ncc = sii->icbus->drv_cc.core;\r\nif (mask || val)\r\nbcma_maskset32(cc, regoff, ~mask, val);\r\nw = bcma_read32(cc, regoff);\r\nreturn w;\r\n}\r\nstatic uint ai_slowclk_src(struct si_pub *sih, struct bcma_device *cc)\r\n{\r\nreturn SCC_SS_XTAL;\r\n}\r\nstatic uint ai_slowclk_freq(struct si_pub *sih, bool max_freq,\r\nstruct bcma_device *cc)\r\n{\r\nuint div;\r\ndiv = bcma_read32(cc, CHIPCREGOFFS(system_clk_ctl));\r\ndiv = 4 * ((div >> SYCC_CD_SHIFT) + 1);\r\nreturn max_freq ? XTALMAXFREQ : (XTALMINFREQ / div);\r\n}\r\nstatic void\r\nai_clkctl_setdelay(struct si_pub *sih, struct bcma_device *cc)\r\n{\r\nuint slowmaxfreq, pll_delay, slowclk;\r\nuint pll_on_delay, fref_sel_delay;\r\npll_delay = PLL_DELAY;\r\nslowclk = ai_slowclk_src(sih, cc);\r\nif (slowclk != SCC_SS_XTAL)\r\npll_delay += XTAL_ON_DELAY;\r\nslowmaxfreq =\r\nai_slowclk_freq(sih, false, cc);\r\npll_on_delay = ((slowmaxfreq * pll_delay) + 999999) / 1000000;\r\nfref_sel_delay = ((slowmaxfreq * FREF_DELAY) + 999999) / 1000000;\r\nbcma_write32(cc, CHIPCREGOFFS(pll_on_delay), pll_on_delay);\r\nbcma_write32(cc, CHIPCREGOFFS(fref_sel_delay), fref_sel_delay);\r\n}\r\nvoid ai_clkctl_init(struct si_pub *sih)\r\n{\r\nstruct si_info *sii = container_of(sih, struct si_info, pub);\r\nstruct bcma_device *cc;\r\nif (!(ai_get_cccaps(sih) & CC_CAP_PWR_CTL))\r\nreturn;\r\ncc = sii->icbus->drv_cc.core;\r\nif (cc == NULL)\r\nreturn;\r\nbcma_maskset32(cc, CHIPCREGOFFS(system_clk_ctl), SYCC_CD_MASK,\r\n(ILP_DIV_1MHZ << SYCC_CD_SHIFT));\r\nai_clkctl_setdelay(sih, cc);\r\n}\r\nu16 ai_clkctl_fast_pwrup_delay(struct si_pub *sih)\r\n{\r\nstruct si_info *sii;\r\nstruct bcma_device *cc;\r\nuint slowminfreq;\r\nu16 fpdelay;\r\nsii = container_of(sih, struct si_info, pub);\r\nif (ai_get_cccaps(sih) & CC_CAP_PMU) {\r\nfpdelay = si_pmu_fast_pwrup_delay(sih);\r\nreturn fpdelay;\r\n}\r\nif (!(ai_get_cccaps(sih) & CC_CAP_PWR_CTL))\r\nreturn 0;\r\nfpdelay = 0;\r\ncc = sii->icbus->drv_cc.core;\r\nif (cc) {\r\nslowminfreq = ai_slowclk_freq(sih, false, cc);\r\nfpdelay = (((bcma_read32(cc, CHIPCREGOFFS(pll_on_delay)) + 2)\r\n* 1000000) + (slowminfreq - 1)) / slowminfreq;\r\n}\r\nreturn fpdelay;\r\n}\r\nbool ai_clkctl_cc(struct si_pub *sih, enum bcma_clkmode mode)\r\n{\r\nstruct si_info *sii;\r\nstruct bcma_device *cc;\r\nsii = container_of(sih, struct si_info, pub);\r\ncc = sii->icbus->drv_cc.core;\r\nbcma_core_set_clockmode(cc, mode);\r\nreturn mode == BCMA_CLKMODE_FAST;\r\n}\r\nvoid ai_epa_4313war(struct si_pub *sih)\r\n{\r\nstruct si_info *sii = container_of(sih, struct si_info, pub);\r\nstruct bcma_device *cc;\r\ncc = sii->icbus->drv_cc.core;\r\nbcma_set32(cc, CHIPCREGOFFS(gpiocontrol), GPIO_CTRL_EPA_EN_MASK);\r\n}\r\nbool ai_deviceremoved(struct si_pub *sih)\r\n{\r\nu32 w = 0;\r\nstruct si_info *sii;\r\nsii = container_of(sih, struct si_info, pub);\r\nif (sii->icbus->hosttype != BCMA_HOSTTYPE_PCI)\r\nreturn false;\r\npci_read_config_dword(sii->pcibus, PCI_VENDOR_ID, &w);\r\nif ((w & 0xFFFF) != PCI_VENDOR_ID_BROADCOM)\r\nreturn true;\r\nreturn false;\r\n}
