static void gsc_hpdi_drain_dma(struct comedi_device *dev, unsigned int channel)\r\n{\r\nstruct hpdi_private *devpriv = dev->private;\r\nstruct comedi_subdevice *s = dev->read_subdev;\r\nstruct comedi_cmd *cmd = &s->async->cmd;\r\nunsigned int idx;\r\nunsigned int start;\r\nunsigned int desc;\r\nunsigned int size;\r\nunsigned int next;\r\nif (channel)\r\nnext = readl(devpriv->plx9080_mmio + PLX_DMA1_PCI_ADDRESS_REG);\r\nelse\r\nnext = readl(devpriv->plx9080_mmio + PLX_DMA0_PCI_ADDRESS_REG);\r\nidx = devpriv->dma_desc_index;\r\nstart = le32_to_cpu(devpriv->dma_desc[idx].pci_start_addr);\r\nfor (desc = 0; (next < start || next >= start + devpriv->block_size) &&\r\ndesc < devpriv->num_dma_descriptors; desc++) {\r\nsize = devpriv->block_size / sizeof(u32);\r\nif (cmd->stop_src == TRIG_COUNT) {\r\nif (size > devpriv->dio_count)\r\nsize = devpriv->dio_count;\r\ndevpriv->dio_count -= size;\r\n}\r\ncomedi_buf_write_samples(s, devpriv->desc_dio_buffer[idx],\r\nsize);\r\nidx++;\r\nidx %= devpriv->num_dma_descriptors;\r\nstart = le32_to_cpu(devpriv->dma_desc[idx].pci_start_addr);\r\ndevpriv->dma_desc_index = idx;\r\n}\r\n}\r\nstatic irqreturn_t gsc_hpdi_interrupt(int irq, void *d)\r\n{\r\nstruct comedi_device *dev = d;\r\nstruct hpdi_private *devpriv = dev->private;\r\nstruct comedi_subdevice *s = dev->read_subdev;\r\nstruct comedi_async *async = s->async;\r\nu32 hpdi_intr_status, hpdi_board_status;\r\nu32 plx_status;\r\nu32 plx_bits;\r\nu8 dma0_status, dma1_status;\r\nunsigned long flags;\r\nif (!dev->attached)\r\nreturn IRQ_NONE;\r\nplx_status = readl(devpriv->plx9080_mmio + PLX_INTRCS_REG);\r\nif ((plx_status & (ICS_DMA0_A | ICS_DMA1_A | ICS_LIA)) == 0)\r\nreturn IRQ_NONE;\r\nhpdi_intr_status = readl(dev->mmio + INTERRUPT_STATUS_REG);\r\nhpdi_board_status = readl(dev->mmio + BOARD_STATUS_REG);\r\nif (hpdi_intr_status)\r\nwritel(hpdi_intr_status, dev->mmio + INTERRUPT_STATUS_REG);\r\nspin_lock_irqsave(&dev->spinlock, flags);\r\ndma0_status = readb(devpriv->plx9080_mmio + PLX_DMA0_CS_REG);\r\nif (plx_status & ICS_DMA0_A) {\r\nwriteb((dma0_status & PLX_DMA_EN_BIT) | PLX_CLEAR_DMA_INTR_BIT,\r\ndevpriv->plx9080_mmio + PLX_DMA0_CS_REG);\r\nif (dma0_status & PLX_DMA_EN_BIT)\r\ngsc_hpdi_drain_dma(dev, 0);\r\n}\r\nspin_unlock_irqrestore(&dev->spinlock, flags);\r\nspin_lock_irqsave(&dev->spinlock, flags);\r\ndma1_status = readb(devpriv->plx9080_mmio + PLX_DMA1_CS_REG);\r\nif (plx_status & ICS_DMA1_A) {\r\nwriteb((dma1_status & PLX_DMA_EN_BIT) | PLX_CLEAR_DMA_INTR_BIT,\r\ndevpriv->plx9080_mmio + PLX_DMA1_CS_REG);\r\n}\r\nspin_unlock_irqrestore(&dev->spinlock, flags);\r\nif (plx_status & ICS_LDIA) {\r\nplx_bits = readl(devpriv->plx9080_mmio + PLX_DBR_OUT_REG);\r\nwritel(plx_bits, devpriv->plx9080_mmio + PLX_DBR_OUT_REG);\r\n}\r\nif (hpdi_board_status & RX_OVERRUN_BIT) {\r\ndev_err(dev->class_dev, "rx fifo overrun\n");\r\nasync->events |= COMEDI_CB_ERROR;\r\n}\r\nif (hpdi_board_status & RX_UNDERRUN_BIT) {\r\ndev_err(dev->class_dev, "rx fifo underrun\n");\r\nasync->events |= COMEDI_CB_ERROR;\r\n}\r\nif (devpriv->dio_count == 0)\r\nasync->events |= COMEDI_CB_EOA;\r\ncomedi_handle_events(dev, s);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void gsc_hpdi_abort_dma(struct comedi_device *dev, unsigned int channel)\r\n{\r\nstruct hpdi_private *devpriv = dev->private;\r\nunsigned long flags;\r\nspin_lock_irqsave(&dev->spinlock, flags);\r\nplx9080_abort_dma(devpriv->plx9080_mmio, channel);\r\nspin_unlock_irqrestore(&dev->spinlock, flags);\r\n}\r\nstatic int gsc_hpdi_cancel(struct comedi_device *dev,\r\nstruct comedi_subdevice *s)\r\n{\r\nwritel(0, dev->mmio + BOARD_CONTROL_REG);\r\nwritel(0, dev->mmio + INTERRUPT_CONTROL_REG);\r\ngsc_hpdi_abort_dma(dev, 0);\r\nreturn 0;\r\n}\r\nstatic int gsc_hpdi_cmd(struct comedi_device *dev,\r\nstruct comedi_subdevice *s)\r\n{\r\nstruct hpdi_private *devpriv = dev->private;\r\nstruct comedi_async *async = s->async;\r\nstruct comedi_cmd *cmd = &async->cmd;\r\nunsigned long flags;\r\nu32 bits;\r\nif (s->io_bits)\r\nreturn -EINVAL;\r\nwritel(RX_FIFO_RESET_BIT, dev->mmio + BOARD_CONTROL_REG);\r\ngsc_hpdi_abort_dma(dev, 0);\r\ndevpriv->dma_desc_index = 0;\r\nwritel(0, devpriv->plx9080_mmio + PLX_DMA0_TRANSFER_SIZE_REG);\r\nwritel(0, devpriv->plx9080_mmio + PLX_DMA0_PCI_ADDRESS_REG);\r\nwritel(0, devpriv->plx9080_mmio + PLX_DMA0_LOCAL_ADDRESS_REG);\r\nbits = devpriv->dma_desc_phys_addr | PLX_DESC_IN_PCI_BIT |\r\nPLX_INTR_TERM_COUNT | PLX_XFER_LOCAL_TO_PCI;\r\nwritel(bits, devpriv->plx9080_mmio + PLX_DMA0_DESCRIPTOR_REG);\r\nspin_lock_irqsave(&dev->spinlock, flags);\r\nwriteb(PLX_DMA_EN_BIT | PLX_DMA_START_BIT | PLX_CLEAR_DMA_INTR_BIT,\r\ndevpriv->plx9080_mmio + PLX_DMA0_CS_REG);\r\nspin_unlock_irqrestore(&dev->spinlock, flags);\r\nif (cmd->stop_src == TRIG_COUNT)\r\ndevpriv->dio_count = cmd->stop_arg;\r\nelse\r\ndevpriv->dio_count = 1;\r\nwritel(RX_UNDERRUN_BIT | RX_OVERRUN_BIT, dev->mmio + BOARD_STATUS_REG);\r\nwritel(RX_FULL_INTR, dev->mmio + INTERRUPT_CONTROL_REG);\r\nwritel(RX_ENABLE_BIT, dev->mmio + BOARD_CONTROL_REG);\r\nreturn 0;\r\n}\r\nstatic int gsc_hpdi_check_chanlist(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_cmd *cmd)\r\n{\r\nint i;\r\nfor (i = 0; i < cmd->chanlist_len; i++) {\r\nunsigned int chan = CR_CHAN(cmd->chanlist[i]);\r\nif (chan != i) {\r\ndev_dbg(dev->class_dev,\r\n"chanlist must be ch 0 to 31 in order\n");\r\nreturn -EINVAL;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int gsc_hpdi_cmd_test(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_cmd *cmd)\r\n{\r\nint err = 0;\r\nif (s->io_bits)\r\nreturn -EINVAL;\r\nerr |= comedi_check_trigger_src(&cmd->start_src, TRIG_NOW);\r\nerr |= comedi_check_trigger_src(&cmd->scan_begin_src, TRIG_EXT);\r\nerr |= comedi_check_trigger_src(&cmd->convert_src, TRIG_NOW);\r\nerr |= comedi_check_trigger_src(&cmd->scan_end_src, TRIG_COUNT);\r\nerr |= comedi_check_trigger_src(&cmd->stop_src, TRIG_COUNT | TRIG_NONE);\r\nif (err)\r\nreturn 1;\r\nerr |= comedi_check_trigger_is_unique(cmd->stop_src);\r\nif (err)\r\nreturn 2;\r\nerr |= comedi_check_trigger_arg_is(&cmd->start_arg, 0);\r\nif (!cmd->chanlist_len || !cmd->chanlist) {\r\ncmd->chanlist_len = 32;\r\nerr |= -EINVAL;\r\n}\r\nerr |= comedi_check_trigger_arg_is(&cmd->scan_end_arg,\r\ncmd->chanlist_len);\r\nif (cmd->stop_src == TRIG_COUNT)\r\nerr |= comedi_check_trigger_arg_min(&cmd->stop_arg, 1);\r\nelse\r\nerr |= comedi_check_trigger_arg_is(&cmd->stop_arg, 0);\r\nif (err)\r\nreturn 3;\r\nif (cmd->chanlist && cmd->chanlist_len > 0)\r\nerr |= gsc_hpdi_check_chanlist(dev, s, cmd);\r\nif (err)\r\nreturn 5;\r\nreturn 0;\r\n}\r\nstatic int gsc_hpdi_setup_dma_descriptors(struct comedi_device *dev,\r\nunsigned int len)\r\n{\r\nstruct hpdi_private *devpriv = dev->private;\r\ndma_addr_t phys_addr = devpriv->dma_desc_phys_addr;\r\nu32 next_bits = PLX_DESC_IN_PCI_BIT | PLX_INTR_TERM_COUNT |\r\nPLX_XFER_LOCAL_TO_PCI;\r\nunsigned int offset = 0;\r\nunsigned int idx = 0;\r\nunsigned int i;\r\nif (len > DMA_BUFFER_SIZE)\r\nlen = DMA_BUFFER_SIZE;\r\nlen -= len % sizeof(u32);\r\nif (len == 0)\r\nreturn -EINVAL;\r\nfor (i = 0; i < NUM_DMA_DESCRIPTORS && idx < NUM_DMA_BUFFERS; i++) {\r\ndevpriv->dma_desc[i].pci_start_addr =\r\ncpu_to_le32(devpriv->dio_buffer_phys_addr[idx] + offset);\r\ndevpriv->dma_desc[i].local_start_addr = cpu_to_le32(FIFO_REG);\r\ndevpriv->dma_desc[i].transfer_size = cpu_to_le32(len);\r\ndevpriv->dma_desc[i].next = cpu_to_le32((phys_addr +\r\n(i + 1) * sizeof(devpriv->dma_desc[0])) | next_bits);\r\ndevpriv->desc_dio_buffer[i] = devpriv->dio_buffer[idx] +\r\n(offset / sizeof(u32));\r\noffset += len;\r\nif (len + offset > DMA_BUFFER_SIZE) {\r\noffset = 0;\r\nidx++;\r\n}\r\n}\r\ndevpriv->num_dma_descriptors = i;\r\ndevpriv->dma_desc[i - 1].next = cpu_to_le32(phys_addr | next_bits);\r\ndevpriv->block_size = len;\r\nreturn len;\r\n}\r\nstatic int gsc_hpdi_dio_insn_config(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_insn *insn,\r\nunsigned int *data)\r\n{\r\nint ret;\r\nswitch (data[0]) {\r\ncase INSN_CONFIG_BLOCK_SIZE:\r\nret = gsc_hpdi_setup_dma_descriptors(dev, data[1]);\r\nif (ret)\r\nreturn ret;\r\ndata[1] = ret;\r\nbreak;\r\ndefault:\r\nret = comedi_dio_insn_config(dev, s, insn, data, 0xffffffff);\r\nif (ret)\r\nreturn ret;\r\nbreak;\r\n}\r\nreturn insn->n;\r\n}\r\nstatic void gsc_hpdi_free_dma(struct comedi_device *dev)\r\n{\r\nstruct pci_dev *pcidev = comedi_to_pci_dev(dev);\r\nstruct hpdi_private *devpriv = dev->private;\r\nint i;\r\nif (!devpriv)\r\nreturn;\r\nfor (i = 0; i < NUM_DMA_BUFFERS; i++) {\r\nif (devpriv->dio_buffer[i])\r\ndma_free_coherent(&pcidev->dev,\r\nDMA_BUFFER_SIZE,\r\ndevpriv->dio_buffer[i],\r\ndevpriv->dio_buffer_phys_addr[i]);\r\n}\r\nif (devpriv->dma_desc)\r\ndma_free_coherent(&pcidev->dev,\r\nsizeof(struct plx_dma_desc) *\r\nNUM_DMA_DESCRIPTORS,\r\ndevpriv->dma_desc,\r\ndevpriv->dma_desc_phys_addr);\r\n}\r\nstatic int gsc_hpdi_init(struct comedi_device *dev)\r\n{\r\nstruct hpdi_private *devpriv = dev->private;\r\nu32 plx_intcsr_bits;\r\nwritel(BOARD_RESET_BIT, dev->mmio + BOARD_CONTROL_REG);\r\nusleep_range(10, 1000);\r\nwritel(ALMOST_EMPTY_BITS(32) | ALMOST_FULL_BITS(32),\r\ndev->mmio + RX_PROG_ALMOST_REG);\r\nwritel(ALMOST_EMPTY_BITS(32) | ALMOST_FULL_BITS(32),\r\ndev->mmio + TX_PROG_ALMOST_REG);\r\ndevpriv->tx_fifo_size = readl(dev->mmio + TX_FIFO_SIZE_REG) &\r\nFIFO_SIZE_MASK;\r\ndevpriv->rx_fifo_size = readl(dev->mmio + RX_FIFO_SIZE_REG) &\r\nFIFO_SIZE_MASK;\r\nwritel(0, dev->mmio + INTERRUPT_CONTROL_REG);\r\nplx_intcsr_bits =\r\nICS_AERR | ICS_PERR | ICS_PIE | ICS_PLIE | ICS_PAIE | ICS_LIE |\r\nICS_DMA0_E;\r\nwritel(plx_intcsr_bits, devpriv->plx9080_mmio + PLX_INTRCS_REG);\r\nreturn 0;\r\n}\r\nstatic void gsc_hpdi_init_plx9080(struct comedi_device *dev)\r\n{\r\nstruct hpdi_private *devpriv = dev->private;\r\nu32 bits;\r\nvoid __iomem *plx_iobase = devpriv->plx9080_mmio;\r\n#ifdef __BIG_ENDIAN\r\nbits = BIGEND_DMA0 | BIGEND_DMA1;\r\n#else\r\nbits = 0;\r\n#endif\r\nwritel(bits, devpriv->plx9080_mmio + PLX_BIGEND_REG);\r\nwritel(0, devpriv->plx9080_mmio + PLX_INTRCS_REG);\r\ngsc_hpdi_abort_dma(dev, 0);\r\ngsc_hpdi_abort_dma(dev, 1);\r\nbits = 0;\r\nbits |= PLX_DMA_EN_READYIN_BIT;\r\nbits |= PLX_EN_CHAIN_BIT;\r\nbits |= PLX_EN_DMA_DONE_INTR_BIT;\r\nbits |= PLX_LOCAL_ADDR_CONST_BIT;\r\nbits |= PLX_DMA_INTR_PCI_BIT;\r\nbits |= PLX_DEMAND_MODE_BIT;\r\nbits |= PLX_DMA_LOCAL_BURST_EN_BIT;\r\nbits |= PLX_LOCAL_BUS_32_WIDE_BITS;\r\nwritel(bits, plx_iobase + PLX_DMA0_MODE_REG);\r\n}\r\nstatic int gsc_hpdi_auto_attach(struct comedi_device *dev,\r\nunsigned long context_unused)\r\n{\r\nstruct pci_dev *pcidev = comedi_to_pci_dev(dev);\r\nstruct hpdi_private *devpriv;\r\nstruct comedi_subdevice *s;\r\nint i;\r\nint retval;\r\ndev->board_name = "pci-hpdi32";\r\ndevpriv = comedi_alloc_devpriv(dev, sizeof(*devpriv));\r\nif (!devpriv)\r\nreturn -ENOMEM;\r\nretval = comedi_pci_enable(dev);\r\nif (retval)\r\nreturn retval;\r\npci_set_master(pcidev);\r\ndevpriv->plx9080_mmio = pci_ioremap_bar(pcidev, 0);\r\ndev->mmio = pci_ioremap_bar(pcidev, 2);\r\nif (!devpriv->plx9080_mmio || !dev->mmio) {\r\ndev_warn(dev->class_dev, "failed to remap io memory\n");\r\nreturn -ENOMEM;\r\n}\r\ngsc_hpdi_init_plx9080(dev);\r\nif (request_irq(pcidev->irq, gsc_hpdi_interrupt, IRQF_SHARED,\r\ndev->board_name, dev)) {\r\ndev_warn(dev->class_dev,\r\n"unable to allocate irq %u\n", pcidev->irq);\r\nreturn -EINVAL;\r\n}\r\ndev->irq = pcidev->irq;\r\ndev_dbg(dev->class_dev, " irq %u\n", dev->irq);\r\nfor (i = 0; i < NUM_DMA_BUFFERS; i++) {\r\ndevpriv->dio_buffer[i] =\r\ndma_alloc_coherent(&pcidev->dev, DMA_BUFFER_SIZE,\r\n&devpriv->dio_buffer_phys_addr[i],\r\nGFP_KERNEL);\r\n}\r\ndevpriv->dma_desc = dma_alloc_coherent(&pcidev->dev,\r\nsizeof(struct plx_dma_desc) *\r\nNUM_DMA_DESCRIPTORS,\r\n&devpriv->dma_desc_phys_addr,\r\nGFP_KERNEL);\r\nif (devpriv->dma_desc_phys_addr & 0xf) {\r\ndev_warn(dev->class_dev,\r\n" dma descriptors not quad-word aligned (bug)\n");\r\nreturn -EIO;\r\n}\r\nretval = gsc_hpdi_setup_dma_descriptors(dev, 0x1000);\r\nif (retval < 0)\r\nreturn retval;\r\nretval = comedi_alloc_subdevices(dev, 1);\r\nif (retval)\r\nreturn retval;\r\ns = &dev->subdevices[0];\r\ndev->read_subdev = s;\r\ns->type = COMEDI_SUBD_DIO;\r\ns->subdev_flags = SDF_READABLE | SDF_WRITABLE | SDF_LSAMPL |\r\nSDF_CMD_READ;\r\ns->n_chan = 32;\r\ns->len_chanlist = 32;\r\ns->maxdata = 1;\r\ns->range_table = &range_digital;\r\ns->insn_config = gsc_hpdi_dio_insn_config;\r\ns->do_cmd = gsc_hpdi_cmd;\r\ns->do_cmdtest = gsc_hpdi_cmd_test;\r\ns->cancel = gsc_hpdi_cancel;\r\nreturn gsc_hpdi_init(dev);\r\n}\r\nstatic void gsc_hpdi_detach(struct comedi_device *dev)\r\n{\r\nstruct hpdi_private *devpriv = dev->private;\r\nif (dev->irq)\r\nfree_irq(dev->irq, dev);\r\nif (devpriv) {\r\nif (devpriv->plx9080_mmio) {\r\nwritel(0, devpriv->plx9080_mmio + PLX_INTRCS_REG);\r\niounmap(devpriv->plx9080_mmio);\r\n}\r\nif (dev->mmio)\r\niounmap(dev->mmio);\r\n}\r\ncomedi_pci_disable(dev);\r\ngsc_hpdi_free_dma(dev);\r\n}\r\nstatic int gsc_hpdi_pci_probe(struct pci_dev *dev,\r\nconst struct pci_device_id *id)\r\n{\r\nreturn comedi_pci_auto_config(dev, &gsc_hpdi_driver, id->driver_data);\r\n}
