static void\r\nnvkm_therm_temp_set_defaults(struct nvkm_therm *therm)\r\n{\r\ntherm->bios_sensor.offset_constant = 0;\r\ntherm->bios_sensor.thrs_fan_boost.temp = 90;\r\ntherm->bios_sensor.thrs_fan_boost.hysteresis = 3;\r\ntherm->bios_sensor.thrs_down_clock.temp = 95;\r\ntherm->bios_sensor.thrs_down_clock.hysteresis = 3;\r\ntherm->bios_sensor.thrs_critical.temp = 105;\r\ntherm->bios_sensor.thrs_critical.hysteresis = 5;\r\ntherm->bios_sensor.thrs_shutdown.temp = 135;\r\ntherm->bios_sensor.thrs_shutdown.hysteresis = 5;\r\n}\r\nstatic void\r\nnvkm_therm_temp_safety_checks(struct nvkm_therm *therm)\r\n{\r\nstruct nvbios_therm_sensor *s = &therm->bios_sensor;\r\ns->thrs_fan_boost.hysteresis = max_t(u8, s->thrs_fan_boost.hysteresis, 2);\r\ns->thrs_down_clock.hysteresis = max_t(u8, s->thrs_down_clock.hysteresis, 2);\r\ns->thrs_critical.hysteresis = max_t(u8, s->thrs_critical.hysteresis, 2);\r\ns->thrs_shutdown.hysteresis = max_t(u8, s->thrs_shutdown.hysteresis, 2);\r\n}\r\nvoid\r\nnvkm_therm_sensor_set_threshold_state(struct nvkm_therm *therm,\r\nenum nvkm_therm_thrs thrs,\r\nenum nvkm_therm_thrs_state st)\r\n{\r\ntherm->sensor.alarm_state[thrs] = st;\r\n}\r\nenum nvkm_therm_thrs_state\r\nnvkm_therm_sensor_get_threshold_state(struct nvkm_therm *therm,\r\nenum nvkm_therm_thrs thrs)\r\n{\r\nreturn therm->sensor.alarm_state[thrs];\r\n}\r\nstatic void\r\nnv_poweroff_work(struct work_struct *work)\r\n{\r\norderly_poweroff(true);\r\nkfree(work);\r\n}\r\nvoid\r\nnvkm_therm_sensor_event(struct nvkm_therm *therm, enum nvkm_therm_thrs thrs,\r\nenum nvkm_therm_thrs_direction dir)\r\n{\r\nstruct nvkm_subdev *subdev = &therm->subdev;\r\nbool active;\r\nconst char *thresolds[] = {\r\n"fanboost", "downclock", "critical", "shutdown"\r\n};\r\nint temperature = therm->func->temp_get(therm);\r\nif (thrs < 0 || thrs > 3)\r\nreturn;\r\nif (dir == NVKM_THERM_THRS_FALLING)\r\nnvkm_info(subdev,\r\n"temperature (%i C) went below the '%s' threshold\n",\r\ntemperature, thresolds[thrs]);\r\nelse\r\nnvkm_info(subdev, "temperature (%i C) hit the '%s' threshold\n",\r\ntemperature, thresolds[thrs]);\r\nactive = (dir == NVKM_THERM_THRS_RISING);\r\nswitch (thrs) {\r\ncase NVKM_THERM_THRS_FANBOOST:\r\nif (active) {\r\nnvkm_therm_fan_set(therm, true, 100);\r\nnvkm_therm_fan_mode(therm, NVKM_THERM_CTRL_AUTO);\r\n}\r\nbreak;\r\ncase NVKM_THERM_THRS_DOWNCLOCK:\r\nif (therm->emergency.downclock)\r\ntherm->emergency.downclock(therm, active);\r\nbreak;\r\ncase NVKM_THERM_THRS_CRITICAL:\r\nif (therm->emergency.pause)\r\ntherm->emergency.pause(therm, active);\r\nbreak;\r\ncase NVKM_THERM_THRS_SHUTDOWN:\r\nif (active) {\r\nstruct work_struct *work;\r\nwork = kmalloc(sizeof(*work), GFP_ATOMIC);\r\nif (work) {\r\nINIT_WORK(work, nv_poweroff_work);\r\nschedule_work(work);\r\n}\r\n}\r\nbreak;\r\ncase NVKM_THERM_THRS_NR:\r\nbreak;\r\n}\r\n}\r\nstatic void\r\nnvkm_therm_threshold_hyst_polling(struct nvkm_therm *therm,\r\nconst struct nvbios_therm_threshold *thrs,\r\nenum nvkm_therm_thrs thrs_name)\r\n{\r\nenum nvkm_therm_thrs_direction direction;\r\nenum nvkm_therm_thrs_state prev_state, new_state;\r\nint temp = therm->func->temp_get(therm);\r\nprev_state = nvkm_therm_sensor_get_threshold_state(therm, thrs_name);\r\nif (temp >= thrs->temp && prev_state == NVKM_THERM_THRS_LOWER) {\r\ndirection = NVKM_THERM_THRS_RISING;\r\nnew_state = NVKM_THERM_THRS_HIGHER;\r\n} else if (temp <= thrs->temp - thrs->hysteresis &&\r\nprev_state == NVKM_THERM_THRS_HIGHER) {\r\ndirection = NVKM_THERM_THRS_FALLING;\r\nnew_state = NVKM_THERM_THRS_LOWER;\r\n} else\r\nreturn;\r\nnvkm_therm_sensor_set_threshold_state(therm, thrs_name, new_state);\r\nnvkm_therm_sensor_event(therm, thrs_name, direction);\r\n}\r\nstatic void\r\nalarm_timer_callback(struct nvkm_alarm *alarm)\r\n{\r\nstruct nvkm_therm *therm =\r\ncontainer_of(alarm, struct nvkm_therm, sensor.therm_poll_alarm);\r\nstruct nvbios_therm_sensor *sensor = &therm->bios_sensor;\r\nstruct nvkm_timer *tmr = therm->subdev.device->timer;\r\nunsigned long flags;\r\nspin_lock_irqsave(&therm->sensor.alarm_program_lock, flags);\r\nnvkm_therm_threshold_hyst_polling(therm, &sensor->thrs_fan_boost,\r\nNVKM_THERM_THRS_FANBOOST);\r\nnvkm_therm_threshold_hyst_polling(therm,\r\n&sensor->thrs_down_clock,\r\nNVKM_THERM_THRS_DOWNCLOCK);\r\nnvkm_therm_threshold_hyst_polling(therm, &sensor->thrs_critical,\r\nNVKM_THERM_THRS_CRITICAL);\r\nnvkm_therm_threshold_hyst_polling(therm, &sensor->thrs_shutdown,\r\nNVKM_THERM_THRS_SHUTDOWN);\r\nspin_unlock_irqrestore(&therm->sensor.alarm_program_lock, flags);\r\nif (therm->func->temp_get(therm) >= 0 && list_empty(&alarm->head))\r\nnvkm_timer_alarm(tmr, 1000000000ULL, alarm);\r\n}\r\nvoid\r\nnvkm_therm_program_alarms_polling(struct nvkm_therm *therm)\r\n{\r\nstruct nvbios_therm_sensor *sensor = &therm->bios_sensor;\r\nnvkm_debug(&therm->subdev,\r\n"programmed thresholds [ %d(%d), %d(%d), %d(%d), %d(%d) ]\n",\r\nsensor->thrs_fan_boost.temp,\r\nsensor->thrs_fan_boost.hysteresis,\r\nsensor->thrs_down_clock.temp,\r\nsensor->thrs_down_clock.hysteresis,\r\nsensor->thrs_critical.temp,\r\nsensor->thrs_critical.hysteresis,\r\nsensor->thrs_shutdown.temp,\r\nsensor->thrs_shutdown.hysteresis);\r\nalarm_timer_callback(&therm->sensor.therm_poll_alarm);\r\n}\r\nint\r\nnvkm_therm_sensor_init(struct nvkm_therm *therm)\r\n{\r\ntherm->func->program_alarms(therm);\r\nreturn 0;\r\n}\r\nint\r\nnvkm_therm_sensor_fini(struct nvkm_therm *therm, bool suspend)\r\n{\r\nstruct nvkm_timer *tmr = therm->subdev.device->timer;\r\nif (suspend)\r\nnvkm_timer_alarm_cancel(tmr, &therm->sensor.therm_poll_alarm);\r\nreturn 0;\r\n}\r\nvoid\r\nnvkm_therm_sensor_preinit(struct nvkm_therm *therm)\r\n{\r\nconst char *sensor_avail = "yes";\r\nif (therm->func->temp_get(therm) < 0)\r\nsensor_avail = "no";\r\nnvkm_debug(&therm->subdev, "internal sensor: %s\n", sensor_avail);\r\n}\r\nint\r\nnvkm_therm_sensor_ctor(struct nvkm_therm *therm)\r\n{\r\nstruct nvkm_subdev *subdev = &therm->subdev;\r\nstruct nvkm_bios *bios = subdev->device->bios;\r\nnvkm_alarm_init(&therm->sensor.therm_poll_alarm, alarm_timer_callback);\r\nnvkm_therm_temp_set_defaults(therm);\r\nif (nvbios_therm_sensor_parse(bios, NVBIOS_THERM_DOMAIN_CORE,\r\n&therm->bios_sensor))\r\nnvkm_error(subdev, "nvbios_therm_sensor_parse failed\n");\r\nnvkm_therm_temp_safety_checks(therm);\r\nreturn 0;\r\n}
