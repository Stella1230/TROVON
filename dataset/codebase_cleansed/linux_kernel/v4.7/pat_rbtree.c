static int is_node_overlap(struct memtype *node, u64 start, u64 end)\r\n{\r\nif (node->start >= end || node->end <= start)\r\nreturn 0;\r\nreturn 1;\r\n}\r\nstatic u64 get_subtree_max_end(struct rb_node *node)\r\n{\r\nu64 ret = 0;\r\nif (node) {\r\nstruct memtype *data = container_of(node, struct memtype, rb);\r\nret = data->subtree_max_end;\r\n}\r\nreturn ret;\r\n}\r\nstatic u64 compute_subtree_max_end(struct memtype *data)\r\n{\r\nu64 max_end = data->end, child_max_end;\r\nchild_max_end = get_subtree_max_end(data->rb.rb_right);\r\nif (child_max_end > max_end)\r\nmax_end = child_max_end;\r\nchild_max_end = get_subtree_max_end(data->rb.rb_left);\r\nif (child_max_end > max_end)\r\nmax_end = child_max_end;\r\nreturn max_end;\r\n}\r\nstatic struct memtype *memtype_rb_lowest_match(struct rb_root *root,\r\nu64 start, u64 end)\r\n{\r\nstruct rb_node *node = root->rb_node;\r\nstruct memtype *last_lower = NULL;\r\nwhile (node) {\r\nstruct memtype *data = container_of(node, struct memtype, rb);\r\nif (get_subtree_max_end(node->rb_left) > start) {\r\nnode = node->rb_left;\r\n} else if (is_node_overlap(data, start, end)) {\r\nlast_lower = data;\r\nbreak;\r\n} else if (start >= data->start) {\r\nnode = node->rb_right;\r\n} else {\r\nbreak;\r\n}\r\n}\r\nreturn last_lower;\r\n}\r\nstatic struct memtype *memtype_rb_match(struct rb_root *root,\r\nu64 start, u64 end, int match_type)\r\n{\r\nstruct memtype *match;\r\nmatch = memtype_rb_lowest_match(root, start, end);\r\nwhile (match != NULL && match->start < end) {\r\nstruct rb_node *node;\r\nif ((match_type == MEMTYPE_EXACT_MATCH) &&\r\n(match->start == start) && (match->end == end))\r\nreturn match;\r\nif ((match_type == MEMTYPE_END_MATCH) &&\r\n(match->start < start) && (match->end == end))\r\nreturn match;\r\nnode = rb_next(&match->rb);\r\nif (node)\r\nmatch = container_of(node, struct memtype, rb);\r\nelse\r\nmatch = NULL;\r\n}\r\nreturn NULL;\r\n}\r\nstatic int memtype_rb_check_conflict(struct rb_root *root,\r\nu64 start, u64 end,\r\nenum page_cache_mode reqtype,\r\nenum page_cache_mode *newtype)\r\n{\r\nstruct rb_node *node;\r\nstruct memtype *match;\r\nenum page_cache_mode found_type = reqtype;\r\nmatch = memtype_rb_lowest_match(&memtype_rbroot, start, end);\r\nif (match == NULL)\r\ngoto success;\r\nif (match->type != found_type && newtype == NULL)\r\ngoto failure;\r\ndprintk("Overlap at 0x%Lx-0x%Lx\n", match->start, match->end);\r\nfound_type = match->type;\r\nnode = rb_next(&match->rb);\r\nwhile (node) {\r\nmatch = container_of(node, struct memtype, rb);\r\nif (match->start >= end)\r\ngoto success;\r\nif (is_node_overlap(match, start, end) &&\r\nmatch->type != found_type) {\r\ngoto failure;\r\n}\r\nnode = rb_next(&match->rb);\r\n}\r\nsuccess:\r\nif (newtype)\r\n*newtype = found_type;\r\nreturn 0;\r\nfailure:\r\npr_info("x86/PAT: %s:%d conflicting memory types %Lx-%Lx %s<->%s\n",\r\ncurrent->comm, current->pid, start, end,\r\ncattr_name(found_type), cattr_name(match->type));\r\nreturn -EBUSY;\r\n}\r\nstatic void memtype_rb_insert(struct rb_root *root, struct memtype *newdata)\r\n{\r\nstruct rb_node **node = &(root->rb_node);\r\nstruct rb_node *parent = NULL;\r\nwhile (*node) {\r\nstruct memtype *data = container_of(*node, struct memtype, rb);\r\nparent = *node;\r\nif (data->subtree_max_end < newdata->end)\r\ndata->subtree_max_end = newdata->end;\r\nif (newdata->start <= data->start)\r\nnode = &((*node)->rb_left);\r\nelse if (newdata->start > data->start)\r\nnode = &((*node)->rb_right);\r\n}\r\nnewdata->subtree_max_end = newdata->end;\r\nrb_link_node(&newdata->rb, parent, node);\r\nrb_insert_augmented(&newdata->rb, root, &memtype_rb_augment_cb);\r\n}\r\nint rbt_memtype_check_insert(struct memtype *new,\r\nenum page_cache_mode *ret_type)\r\n{\r\nint err = 0;\r\nerr = memtype_rb_check_conflict(&memtype_rbroot, new->start, new->end,\r\nnew->type, ret_type);\r\nif (!err) {\r\nif (ret_type)\r\nnew->type = *ret_type;\r\nnew->subtree_max_end = new->end;\r\nmemtype_rb_insert(&memtype_rbroot, new);\r\n}\r\nreturn err;\r\n}\r\nstruct memtype *rbt_memtype_erase(u64 start, u64 end)\r\n{\r\nstruct memtype *data;\r\ndata = memtype_rb_match(&memtype_rbroot, start, end,\r\nMEMTYPE_EXACT_MATCH);\r\nif (!data) {\r\ndata = memtype_rb_match(&memtype_rbroot, start, end,\r\nMEMTYPE_END_MATCH);\r\nif (!data)\r\nreturn ERR_PTR(-EINVAL);\r\n}\r\nif (data->start == start) {\r\nrb_erase_augmented(&data->rb, &memtype_rbroot,\r\n&memtype_rb_augment_cb);\r\n} else {\r\nrb_erase_augmented(&data->rb, &memtype_rbroot,\r\n&memtype_rb_augment_cb);\r\ndata->end = start;\r\ndata->subtree_max_end = data->end;\r\nmemtype_rb_insert(&memtype_rbroot, data);\r\nreturn NULL;\r\n}\r\nreturn data;\r\n}\r\nstruct memtype *rbt_memtype_lookup(u64 addr)\r\n{\r\nstruct memtype *data;\r\ndata = memtype_rb_lowest_match(&memtype_rbroot, addr, addr + PAGE_SIZE);\r\nreturn data;\r\n}\r\nint rbt_memtype_copy_nth_element(struct memtype *out, loff_t pos)\r\n{\r\nstruct rb_node *node;\r\nint i = 1;\r\nnode = rb_first(&memtype_rbroot);\r\nwhile (node && pos != i) {\r\nnode = rb_next(node);\r\ni++;\r\n}\r\nif (node) {\r\nstruct memtype *this = container_of(node, struct memtype, rb);\r\n*out = *this;\r\nreturn 0;\r\n} else {\r\nreturn 1;\r\n}\r\n}
