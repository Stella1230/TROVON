static u32 csi_reg_read(struct mx3_camera_dev *mx3, off_t reg)\r\n{\r\nreturn __raw_readl(mx3->base + reg);\r\n}\r\nstatic void csi_reg_write(struct mx3_camera_dev *mx3, u32 value, off_t reg)\r\n{\r\n__raw_writel(value, mx3->base + reg);\r\n}\r\nstatic struct mx3_camera_buffer *to_mx3_vb(struct vb2_v4l2_buffer *vb)\r\n{\r\nreturn container_of(vb, struct mx3_camera_buffer, vb);\r\n}\r\nstatic void mx3_cam_dma_done(void *arg)\r\n{\r\nstruct idmac_tx_desc *desc = to_tx_desc(arg);\r\nstruct dma_chan *chan = desc->txd.chan;\r\nstruct idmac_channel *ichannel = to_idmac_chan(chan);\r\nstruct mx3_camera_dev *mx3_cam = ichannel->client;\r\ndev_dbg(chan->device->dev, "callback cookie %d, active DMA %pad\n",\r\ndesc->txd.cookie, mx3_cam->active ? &sg_dma_address(&mx3_cam->active->sg) : NULL);\r\nspin_lock(&mx3_cam->lock);\r\nif (mx3_cam->active) {\r\nstruct vb2_v4l2_buffer *vb = &mx3_cam->active->vb;\r\nstruct mx3_camera_buffer *buf = to_mx3_vb(vb);\r\nlist_del_init(&buf->queue);\r\nvb->vb2_buf.timestamp = ktime_get_ns();\r\nvb->field = mx3_cam->field;\r\nvb->sequence = mx3_cam->sequence++;\r\nvb2_buffer_done(&vb->vb2_buf, VB2_BUF_STATE_DONE);\r\n}\r\nif (list_empty(&mx3_cam->capture)) {\r\nmx3_cam->active = NULL;\r\nspin_unlock(&mx3_cam->lock);\r\nreturn;\r\n}\r\nmx3_cam->active = list_entry(mx3_cam->capture.next,\r\nstruct mx3_camera_buffer, queue);\r\nspin_unlock(&mx3_cam->lock);\r\n}\r\nstatic int mx3_videobuf_setup(struct vb2_queue *vq,\r\nunsigned int *count, unsigned int *num_planes,\r\nunsigned int sizes[], void *alloc_ctxs[])\r\n{\r\nstruct soc_camera_device *icd = soc_camera_from_vb2q(vq);\r\nstruct soc_camera_host *ici = to_soc_camera_host(icd->parent);\r\nstruct mx3_camera_dev *mx3_cam = ici->priv;\r\nif (!mx3_cam->idmac_channel[0])\r\nreturn -EINVAL;\r\nalloc_ctxs[0] = mx3_cam->alloc_ctx;\r\nif (!vq->num_buffers)\r\nmx3_cam->sequence = 0;\r\nif (!*count)\r\n*count = 2;\r\nif (!*num_planes)\r\nsizes[0] = icd->sizeimage;\r\nelse if (sizes[0] < icd->sizeimage)\r\nreturn -EINVAL;\r\nif (sizes[0] * *count + mx3_cam->buf_total > MAX_VIDEO_MEM * 1024 * 1024)\r\n*count = (MAX_VIDEO_MEM * 1024 * 1024 - mx3_cam->buf_total) /\r\nsizes[0];\r\n*num_planes = 1;\r\nreturn 0;\r\n}\r\nstatic enum pixel_fmt fourcc_to_ipu_pix(__u32 fourcc)\r\n{\r\nswitch (fourcc) {\r\ncase V4L2_PIX_FMT_RGB24:\r\nreturn IPU_PIX_FMT_RGB24;\r\ncase V4L2_PIX_FMT_UYVY:\r\ncase V4L2_PIX_FMT_RGB565:\r\ndefault:\r\nreturn IPU_PIX_FMT_GENERIC;\r\n}\r\n}\r\nstatic void mx3_videobuf_queue(struct vb2_buffer *vb)\r\n{\r\nstruct vb2_v4l2_buffer *vbuf = to_vb2_v4l2_buffer(vb);\r\nstruct soc_camera_device *icd = soc_camera_from_vb2q(vb->vb2_queue);\r\nstruct soc_camera_host *ici = to_soc_camera_host(icd->parent);\r\nstruct mx3_camera_dev *mx3_cam = ici->priv;\r\nstruct mx3_camera_buffer *buf = to_mx3_vb(vbuf);\r\nstruct scatterlist *sg = &buf->sg;\r\nstruct dma_async_tx_descriptor *txd;\r\nstruct idmac_channel *ichan = mx3_cam->idmac_channel[0];\r\nstruct idmac_video_param *video = &ichan->params.video;\r\nconst struct soc_mbus_pixelfmt *host_fmt = icd->current_fmt->host_fmt;\r\ndma_cookie_t cookie;\r\nsize_t new_size;\r\nnew_size = icd->sizeimage;\r\nif (vb2_plane_size(vb, 0) < new_size) {\r\ndev_err(icd->parent, "Buffer #%d too small (%lu < %zu)\n",\r\nvbuf->vb2_buf.index, vb2_plane_size(vb, 0), new_size);\r\ngoto error;\r\n}\r\nif (!buf->txd) {\r\nsg_dma_address(sg) = vb2_dma_contig_plane_dma_addr(vb, 0);\r\nsg_dma_len(sg) = new_size;\r\ntxd = dmaengine_prep_slave_sg(\r\n&ichan->dma_chan, sg, 1, DMA_DEV_TO_MEM,\r\nDMA_PREP_INTERRUPT);\r\nif (!txd)\r\ngoto error;\r\ntxd->callback_param = txd;\r\ntxd->callback = mx3_cam_dma_done;\r\nbuf->txd = txd;\r\n} else {\r\ntxd = buf->txd;\r\n}\r\nvb2_set_plane_payload(vb, 0, new_size);\r\nvideo->out_pixel_fmt = fourcc_to_ipu_pix(host_fmt->fourcc);\r\nif (video->out_pixel_fmt == IPU_PIX_FMT_GENERIC) {\r\nvideo->out_width = icd->bytesperline;\r\nvideo->out_height = icd->user_height;\r\nvideo->out_stride = icd->bytesperline;\r\n} else {\r\nvideo->out_width = icd->user_width;\r\nvideo->out_height = icd->user_height;\r\nvideo->out_stride = icd->user_width;\r\n}\r\n#ifdef DEBUG\r\nif (vb2_plane_vaddr(vb, 0))\r\nmemset(vb2_plane_vaddr(vb, 0), 0xaa, vb2_get_plane_payload(vb, 0));\r\n#endif\r\nspin_lock_irq(&mx3_cam->lock);\r\nlist_add_tail(&buf->queue, &mx3_cam->capture);\r\nif (!mx3_cam->active)\r\nmx3_cam->active = buf;\r\nspin_unlock_irq(&mx3_cam->lock);\r\ncookie = txd->tx_submit(txd);\r\ndev_dbg(icd->parent, "Submitted cookie %d DMA %pad\n",\r\ncookie, &sg_dma_address(&buf->sg));\r\nif (cookie >= 0)\r\nreturn;\r\nspin_lock_irq(&mx3_cam->lock);\r\nlist_del_init(&buf->queue);\r\nif (mx3_cam->active == buf)\r\nmx3_cam->active = NULL;\r\nspin_unlock_irq(&mx3_cam->lock);\r\nerror:\r\nvb2_buffer_done(vb, VB2_BUF_STATE_ERROR);\r\n}\r\nstatic void mx3_videobuf_release(struct vb2_buffer *vb)\r\n{\r\nstruct vb2_v4l2_buffer *vbuf = to_vb2_v4l2_buffer(vb);\r\nstruct soc_camera_device *icd = soc_camera_from_vb2q(vb->vb2_queue);\r\nstruct soc_camera_host *ici = to_soc_camera_host(icd->parent);\r\nstruct mx3_camera_dev *mx3_cam = ici->priv;\r\nstruct mx3_camera_buffer *buf = to_mx3_vb(vbuf);\r\nstruct dma_async_tx_descriptor *txd = buf->txd;\r\nunsigned long flags;\r\ndev_dbg(icd->parent,\r\n"Release%s DMA %pad, queue %sempty\n",\r\nmx3_cam->active == buf ? " active" : "", &sg_dma_address(&buf->sg),\r\nlist_empty(&buf->queue) ? "" : "not ");\r\nspin_lock_irqsave(&mx3_cam->lock, flags);\r\nif (mx3_cam->active == buf)\r\nmx3_cam->active = NULL;\r\nlist_del_init(&buf->queue);\r\nif (txd) {\r\nbuf->txd = NULL;\r\nif (mx3_cam->idmac_channel[0])\r\nasync_tx_ack(txd);\r\n}\r\nspin_unlock_irqrestore(&mx3_cam->lock, flags);\r\nmx3_cam->buf_total -= vb2_plane_size(vb, 0);\r\n}\r\nstatic int mx3_videobuf_init(struct vb2_buffer *vb)\r\n{\r\nstruct vb2_v4l2_buffer *vbuf = to_vb2_v4l2_buffer(vb);\r\nstruct soc_camera_device *icd = soc_camera_from_vb2q(vb->vb2_queue);\r\nstruct soc_camera_host *ici = to_soc_camera_host(icd->parent);\r\nstruct mx3_camera_dev *mx3_cam = ici->priv;\r\nstruct mx3_camera_buffer *buf = to_mx3_vb(vbuf);\r\nif (!buf->txd) {\r\nINIT_LIST_HEAD(&buf->queue);\r\nsg_init_table(&buf->sg, 1);\r\nmx3_cam->buf_total += vb2_plane_size(vb, 0);\r\n}\r\nreturn 0;\r\n}\r\nstatic void mx3_stop_streaming(struct vb2_queue *q)\r\n{\r\nstruct soc_camera_device *icd = soc_camera_from_vb2q(q);\r\nstruct soc_camera_host *ici = to_soc_camera_host(icd->parent);\r\nstruct mx3_camera_dev *mx3_cam = ici->priv;\r\nstruct idmac_channel *ichan = mx3_cam->idmac_channel[0];\r\nstruct mx3_camera_buffer *buf, *tmp;\r\nunsigned long flags;\r\nif (ichan)\r\ndmaengine_pause(&ichan->dma_chan);\r\nspin_lock_irqsave(&mx3_cam->lock, flags);\r\nmx3_cam->active = NULL;\r\nlist_for_each_entry_safe(buf, tmp, &mx3_cam->capture, queue) {\r\nlist_del_init(&buf->queue);\r\nvb2_buffer_done(&buf->vb.vb2_buf, VB2_BUF_STATE_ERROR);\r\n}\r\nspin_unlock_irqrestore(&mx3_cam->lock, flags);\r\n}\r\nstatic int mx3_camera_init_videobuf(struct vb2_queue *q,\r\nstruct soc_camera_device *icd)\r\n{\r\nstruct soc_camera_host *ici = to_soc_camera_host(icd->parent);\r\nq->type = V4L2_BUF_TYPE_VIDEO_CAPTURE;\r\nq->io_modes = VB2_MMAP | VB2_USERPTR;\r\nq->drv_priv = icd;\r\nq->ops = &mx3_videobuf_ops;\r\nq->mem_ops = &vb2_dma_contig_memops;\r\nq->buf_struct_size = sizeof(struct mx3_camera_buffer);\r\nq->timestamp_flags = V4L2_BUF_FLAG_TIMESTAMP_MONOTONIC;\r\nq->lock = &ici->host_lock;\r\nreturn vb2_queue_init(q);\r\n}\r\nstatic void mx3_camera_activate(struct mx3_camera_dev *mx3_cam)\r\n{\r\nu32 conf;\r\nlong rate;\r\ncsi_reg_write(mx3_cam, (640 - 1) | ((480 - 1) << 16), CSI_ACT_FRM_SIZE);\r\nconf = csi_reg_read(mx3_cam, CSI_OUT_FRM_CTRL) & 0xffff0000;\r\ncsi_reg_write(mx3_cam, conf, CSI_OUT_FRM_CTRL);\r\nconf = 0 << CSI_SENS_CONF_SENS_PRTCL_SHIFT;\r\nconf |= CSI_SENS_CONF_DATA_FMT_BAYER;\r\nif (mx3_cam->platform_flags & MX3_CAMERA_DATAWIDTH_15)\r\nconf |= 3 << CSI_SENS_CONF_DATA_WIDTH_SHIFT;\r\nelse if (mx3_cam->platform_flags & MX3_CAMERA_DATAWIDTH_10)\r\nconf |= 2 << CSI_SENS_CONF_DATA_WIDTH_SHIFT;\r\nelse if (mx3_cam->platform_flags & MX3_CAMERA_DATAWIDTH_8)\r\nconf |= 1 << CSI_SENS_CONF_DATA_WIDTH_SHIFT;\r\nelse\r\nconf |= 0 << CSI_SENS_CONF_DATA_WIDTH_SHIFT;\r\nif (mx3_cam->platform_flags & MX3_CAMERA_CLK_SRC)\r\nconf |= 1 << CSI_SENS_CONF_SENS_CLKSRC_SHIFT;\r\nif (mx3_cam->platform_flags & MX3_CAMERA_EXT_VSYNC)\r\nconf |= 1 << CSI_SENS_CONF_EXT_VSYNC_SHIFT;\r\nif (mx3_cam->platform_flags & MX3_CAMERA_DP)\r\nconf |= 1 << CSI_SENS_CONF_DATA_POL_SHIFT;\r\nif (mx3_cam->platform_flags & MX3_CAMERA_PCP)\r\nconf |= 1 << CSI_SENS_CONF_PIX_CLK_POL_SHIFT;\r\nif (mx3_cam->platform_flags & MX3_CAMERA_HSP)\r\nconf |= 1 << CSI_SENS_CONF_HSYNC_POL_SHIFT;\r\nif (mx3_cam->platform_flags & MX3_CAMERA_VSP)\r\nconf |= 1 << CSI_SENS_CONF_VSYNC_POL_SHIFT;\r\ncsi_reg_write(mx3_cam, conf, CSI_SENS_CONF);\r\nclk_prepare_enable(mx3_cam->clk);\r\nrate = clk_round_rate(mx3_cam->clk, mx3_cam->mclk);\r\ndev_dbg(mx3_cam->soc_host.v4l2_dev.dev, "Set SENS_CONF to %x, rate %ld\n", conf, rate);\r\nif (rate)\r\nclk_set_rate(mx3_cam->clk, rate);\r\n}\r\nstatic int mx3_camera_add_device(struct soc_camera_device *icd)\r\n{\r\ndev_info(icd->parent, "MX3 Camera driver attached to camera %d\n",\r\nicd->devnum);\r\nreturn 0;\r\n}\r\nstatic void mx3_camera_remove_device(struct soc_camera_device *icd)\r\n{\r\ndev_info(icd->parent, "MX3 Camera driver detached from camera %d\n",\r\nicd->devnum);\r\n}\r\nstatic int mx3_camera_clock_start(struct soc_camera_host *ici)\r\n{\r\nstruct mx3_camera_dev *mx3_cam = ici->priv;\r\nmx3_camera_activate(mx3_cam);\r\nmx3_cam->buf_total = 0;\r\nreturn 0;\r\n}\r\nstatic void mx3_camera_clock_stop(struct soc_camera_host *ici)\r\n{\r\nstruct mx3_camera_dev *mx3_cam = ici->priv;\r\nstruct idmac_channel **ichan = &mx3_cam->idmac_channel[0];\r\nif (*ichan) {\r\ndma_release_channel(&(*ichan)->dma_chan);\r\n*ichan = NULL;\r\n}\r\nclk_disable_unprepare(mx3_cam->clk);\r\n}\r\nstatic int test_platform_param(struct mx3_camera_dev *mx3_cam,\r\nunsigned char buswidth, unsigned long *flags)\r\n{\r\nif (buswidth > fls(mx3_cam->width_flags))\r\nreturn -EINVAL;\r\n*flags = V4L2_MBUS_MASTER |\r\nV4L2_MBUS_HSYNC_ACTIVE_HIGH |\r\nV4L2_MBUS_HSYNC_ACTIVE_LOW |\r\nV4L2_MBUS_VSYNC_ACTIVE_HIGH |\r\nV4L2_MBUS_VSYNC_ACTIVE_LOW |\r\nV4L2_MBUS_PCLK_SAMPLE_RISING |\r\nV4L2_MBUS_PCLK_SAMPLE_FALLING |\r\nV4L2_MBUS_DATA_ACTIVE_HIGH |\r\nV4L2_MBUS_DATA_ACTIVE_LOW;\r\nreturn 0;\r\n}\r\nstatic int mx3_camera_try_bus_param(struct soc_camera_device *icd,\r\nconst unsigned int depth)\r\n{\r\nstruct v4l2_subdev *sd = soc_camera_to_subdev(icd);\r\nstruct soc_camera_host *ici = to_soc_camera_host(icd->parent);\r\nstruct mx3_camera_dev *mx3_cam = ici->priv;\r\nstruct v4l2_mbus_config cfg = {.type = V4L2_MBUS_PARALLEL,};\r\nunsigned long bus_flags, common_flags;\r\nint ret = test_platform_param(mx3_cam, depth, &bus_flags);\r\ndev_dbg(icd->parent, "request bus width %d bit: %d\n", depth, ret);\r\nif (ret < 0)\r\nreturn ret;\r\nret = v4l2_subdev_call(sd, video, g_mbus_config, &cfg);\r\nif (!ret) {\r\ncommon_flags = soc_mbus_config_compatible(&cfg,\r\nbus_flags);\r\nif (!common_flags) {\r\ndev_warn(icd->parent,\r\n"Flags incompatible: camera 0x%x, host 0x%lx\n",\r\ncfg.flags, bus_flags);\r\nreturn -EINVAL;\r\n}\r\n} else if (ret != -ENOIOCTLCMD) {\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic bool chan_filter(struct dma_chan *chan, void *arg)\r\n{\r\nstruct dma_chan_request *rq = arg;\r\nstruct mx3_camera_pdata *pdata;\r\nif (!imx_dma_is_ipu(chan))\r\nreturn false;\r\nif (!rq)\r\nreturn false;\r\npdata = rq->mx3_cam->soc_host.v4l2_dev.dev->platform_data;\r\nreturn rq->id == chan->chan_id &&\r\npdata->dma_dev == chan->device->dev;\r\n}\r\nstatic bool mx3_camera_packing_supported(const struct soc_mbus_pixelfmt *fmt)\r\n{\r\nreturn fmt->packing == SOC_MBUS_PACKING_NONE ||\r\n(fmt->bits_per_sample == 8 &&\r\nfmt->packing == SOC_MBUS_PACKING_2X8_PADHI) ||\r\n(fmt->bits_per_sample > 8 &&\r\nfmt->packing == SOC_MBUS_PACKING_EXTEND16);\r\n}\r\nstatic int mx3_camera_get_formats(struct soc_camera_device *icd, unsigned int idx,\r\nstruct soc_camera_format_xlate *xlate)\r\n{\r\nstruct v4l2_subdev *sd = soc_camera_to_subdev(icd);\r\nstruct device *dev = icd->parent;\r\nint formats = 0, ret;\r\nstruct v4l2_subdev_mbus_code_enum code = {\r\n.which = V4L2_SUBDEV_FORMAT_ACTIVE,\r\n.index = idx,\r\n};\r\nconst struct soc_mbus_pixelfmt *fmt;\r\nret = v4l2_subdev_call(sd, pad, enum_mbus_code, NULL, &code);\r\nif (ret < 0)\r\nreturn 0;\r\nfmt = soc_mbus_get_fmtdesc(code.code);\r\nif (!fmt) {\r\ndev_warn(icd->parent,\r\n"Unsupported format code #%u: 0x%x\n", idx, code.code);\r\nreturn 0;\r\n}\r\nret = mx3_camera_try_bus_param(icd, fmt->bits_per_sample);\r\nif (ret < 0)\r\nreturn 0;\r\nswitch (code.code) {\r\ncase MEDIA_BUS_FMT_SBGGR10_1X10:\r\nformats++;\r\nif (xlate) {\r\nxlate->host_fmt = &mx3_camera_formats[0];\r\nxlate->code = code.code;\r\nxlate++;\r\ndev_dbg(dev, "Providing format %s using code 0x%x\n",\r\nmx3_camera_formats[0].name, code.code);\r\n}\r\nbreak;\r\ncase MEDIA_BUS_FMT_Y10_1X10:\r\nformats++;\r\nif (xlate) {\r\nxlate->host_fmt = &mx3_camera_formats[1];\r\nxlate->code = code.code;\r\nxlate++;\r\ndev_dbg(dev, "Providing format %s using code 0x%x\n",\r\nmx3_camera_formats[1].name, code.code);\r\n}\r\nbreak;\r\ndefault:\r\nif (!mx3_camera_packing_supported(fmt))\r\nreturn 0;\r\n}\r\nformats++;\r\nif (xlate) {\r\nxlate->host_fmt = fmt;\r\nxlate->code = code.code;\r\ndev_dbg(dev, "Providing format %c%c%c%c in pass-through mode\n",\r\n(fmt->fourcc >> (0*8)) & 0xFF,\r\n(fmt->fourcc >> (1*8)) & 0xFF,\r\n(fmt->fourcc >> (2*8)) & 0xFF,\r\n(fmt->fourcc >> (3*8)) & 0xFF);\r\nxlate++;\r\n}\r\nreturn formats;\r\n}\r\nstatic void configure_geometry(struct mx3_camera_dev *mx3_cam,\r\nunsigned int width, unsigned int height,\r\nconst struct soc_mbus_pixelfmt *fmt)\r\n{\r\nu32 ctrl, width_field, height_field;\r\nif (fourcc_to_ipu_pix(fmt->fourcc) == IPU_PIX_FMT_GENERIC) {\r\nunsigned int num, den;\r\nint ret = soc_mbus_samples_per_pixel(fmt, &num, &den);\r\nBUG_ON(ret < 0);\r\nwidth = width * num / den;\r\n}\r\nwidth_field = width - 1;\r\nheight_field = height - 1;\r\ncsi_reg_write(mx3_cam, width_field | (height_field << 16), CSI_SENS_FRM_SIZE);\r\ncsi_reg_write(mx3_cam, width_field << 16, CSI_FLASH_STROBE_1);\r\ncsi_reg_write(mx3_cam, (height_field << 16) | 0x22, CSI_FLASH_STROBE_2);\r\ncsi_reg_write(mx3_cam, width_field | (height_field << 16), CSI_ACT_FRM_SIZE);\r\nctrl = csi_reg_read(mx3_cam, CSI_OUT_FRM_CTRL) & 0xffff0000;\r\ncsi_reg_write(mx3_cam, ctrl | 0 | (0 << 8), CSI_OUT_FRM_CTRL);\r\n}\r\nstatic int acquire_dma_channel(struct mx3_camera_dev *mx3_cam)\r\n{\r\ndma_cap_mask_t mask;\r\nstruct dma_chan *chan;\r\nstruct idmac_channel **ichan = &mx3_cam->idmac_channel[0];\r\nstruct dma_chan_request rq = {.mx3_cam = mx3_cam,\r\n.id = IDMAC_IC_7};\r\ndma_cap_zero(mask);\r\ndma_cap_set(DMA_SLAVE, mask);\r\ndma_cap_set(DMA_PRIVATE, mask);\r\nchan = dma_request_channel(mask, chan_filter, &rq);\r\nif (!chan)\r\nreturn -EBUSY;\r\n*ichan = to_idmac_chan(chan);\r\n(*ichan)->client = mx3_cam;\r\nreturn 0;\r\n}\r\nstatic inline void stride_align(__u32 *width)\r\n{\r\nif (ALIGN(*width, 8) < 4096)\r\n*width = ALIGN(*width, 8);\r\nelse\r\n*width = *width & ~7;\r\n}\r\nstatic int mx3_camera_set_crop(struct soc_camera_device *icd,\r\nconst struct v4l2_crop *a)\r\n{\r\nstruct v4l2_crop a_writable = *a;\r\nstruct v4l2_rect *rect = &a_writable.c;\r\nstruct soc_camera_host *ici = to_soc_camera_host(icd->parent);\r\nstruct mx3_camera_dev *mx3_cam = ici->priv;\r\nstruct v4l2_subdev *sd = soc_camera_to_subdev(icd);\r\nstruct v4l2_subdev_format fmt = {\r\n.which = V4L2_SUBDEV_FORMAT_ACTIVE,\r\n};\r\nstruct v4l2_mbus_framefmt *mf = &fmt.format;\r\nint ret;\r\nsoc_camera_limit_side(&rect->left, &rect->width, 0, 2, 4096);\r\nsoc_camera_limit_side(&rect->top, &rect->height, 0, 2, 4096);\r\nret = v4l2_subdev_call(sd, video, s_crop, a);\r\nif (ret < 0)\r\nreturn ret;\r\nret = v4l2_subdev_call(sd, pad, get_fmt, NULL, &fmt);\r\nif (ret < 0)\r\nreturn ret;\r\nif (mf->code != icd->current_fmt->code)\r\nreturn -EINVAL;\r\nif (mf->width & 7) {\r\nstride_align(&mf->width);\r\nret = v4l2_subdev_call(sd, pad, set_fmt, NULL, &fmt);\r\nif (ret < 0)\r\nreturn ret;\r\n}\r\nif (mf->width != icd->user_width || mf->height != icd->user_height)\r\nconfigure_geometry(mx3_cam, mf->width, mf->height,\r\nicd->current_fmt->host_fmt);\r\ndev_dbg(icd->parent, "Sensor cropped %dx%d\n",\r\nmf->width, mf->height);\r\nicd->user_width = mf->width;\r\nicd->user_height = mf->height;\r\nreturn ret;\r\n}\r\nstatic int mx3_camera_set_fmt(struct soc_camera_device *icd,\r\nstruct v4l2_format *f)\r\n{\r\nstruct soc_camera_host *ici = to_soc_camera_host(icd->parent);\r\nstruct mx3_camera_dev *mx3_cam = ici->priv;\r\nstruct v4l2_subdev *sd = soc_camera_to_subdev(icd);\r\nconst struct soc_camera_format_xlate *xlate;\r\nstruct v4l2_pix_format *pix = &f->fmt.pix;\r\nstruct v4l2_subdev_format format = {\r\n.which = V4L2_SUBDEV_FORMAT_ACTIVE,\r\n};\r\nstruct v4l2_mbus_framefmt *mf = &format.format;\r\nint ret;\r\nxlate = soc_camera_xlate_by_fourcc(icd, pix->pixelformat);\r\nif (!xlate) {\r\ndev_warn(icd->parent, "Format %x not found\n",\r\npix->pixelformat);\r\nreturn -EINVAL;\r\n}\r\nstride_align(&pix->width);\r\ndev_dbg(icd->parent, "Set format %dx%d\n", pix->width, pix->height);\r\nconfigure_geometry(mx3_cam, pix->width, pix->height, xlate->host_fmt);\r\nmf->width = pix->width;\r\nmf->height = pix->height;\r\nmf->field = pix->field;\r\nmf->colorspace = pix->colorspace;\r\nmf->code = xlate->code;\r\nret = v4l2_subdev_call(sd, pad, set_fmt, NULL, &format);\r\nif (ret < 0)\r\nreturn ret;\r\nif (mf->code != xlate->code)\r\nreturn -EINVAL;\r\nif (!mx3_cam->idmac_channel[0]) {\r\nret = acquire_dma_channel(mx3_cam);\r\nif (ret < 0)\r\nreturn ret;\r\n}\r\npix->width = mf->width;\r\npix->height = mf->height;\r\npix->field = mf->field;\r\nmx3_cam->field = mf->field;\r\npix->colorspace = mf->colorspace;\r\nicd->current_fmt = xlate;\r\ndev_dbg(icd->parent, "Sensor set %dx%d\n", pix->width, pix->height);\r\nreturn ret;\r\n}\r\nstatic int mx3_camera_try_fmt(struct soc_camera_device *icd,\r\nstruct v4l2_format *f)\r\n{\r\nstruct v4l2_subdev *sd = soc_camera_to_subdev(icd);\r\nconst struct soc_camera_format_xlate *xlate;\r\nstruct v4l2_pix_format *pix = &f->fmt.pix;\r\nstruct v4l2_subdev_pad_config pad_cfg;\r\nstruct v4l2_subdev_format format = {\r\n.which = V4L2_SUBDEV_FORMAT_TRY,\r\n};\r\nstruct v4l2_mbus_framefmt *mf = &format.format;\r\n__u32 pixfmt = pix->pixelformat;\r\nint ret;\r\nxlate = soc_camera_xlate_by_fourcc(icd, pixfmt);\r\nif (pixfmt && !xlate) {\r\ndev_warn(icd->parent, "Format %x not found\n", pixfmt);\r\nreturn -EINVAL;\r\n}\r\nif (pix->height > 4096)\r\npix->height = 4096;\r\nif (pix->width > 4096)\r\npix->width = 4096;\r\nmf->width = pix->width;\r\nmf->height = pix->height;\r\nmf->field = pix->field;\r\nmf->colorspace = pix->colorspace;\r\nmf->code = xlate->code;\r\nret = v4l2_subdev_call(sd, pad, set_fmt, &pad_cfg, &format);\r\nif (ret < 0)\r\nreturn ret;\r\npix->width = mf->width;\r\npix->height = mf->height;\r\npix->colorspace = mf->colorspace;\r\nswitch (mf->field) {\r\ncase V4L2_FIELD_ANY:\r\npix->field = V4L2_FIELD_NONE;\r\nbreak;\r\ncase V4L2_FIELD_NONE:\r\nbreak;\r\ndefault:\r\ndev_err(icd->parent, "Field type %d unsupported.\n",\r\nmf->field);\r\nret = -EINVAL;\r\n}\r\nreturn ret;\r\n}\r\nstatic int mx3_camera_reqbufs(struct soc_camera_device *icd,\r\nstruct v4l2_requestbuffers *p)\r\n{\r\nreturn 0;\r\n}\r\nstatic unsigned int mx3_camera_poll(struct file *file, poll_table *pt)\r\n{\r\nstruct soc_camera_device *icd = file->private_data;\r\nreturn vb2_poll(&icd->vb2_vidq, file, pt);\r\n}\r\nstatic int mx3_camera_querycap(struct soc_camera_host *ici,\r\nstruct v4l2_capability *cap)\r\n{\r\nstrlcpy(cap->card, "i.MX3x Camera", sizeof(cap->card));\r\ncap->device_caps = V4L2_CAP_VIDEO_CAPTURE | V4L2_CAP_STREAMING;\r\ncap->capabilities = cap->device_caps | V4L2_CAP_DEVICE_CAPS;\r\nreturn 0;\r\n}\r\nstatic int mx3_camera_set_bus_param(struct soc_camera_device *icd)\r\n{\r\nstruct v4l2_subdev *sd = soc_camera_to_subdev(icd);\r\nstruct soc_camera_host *ici = to_soc_camera_host(icd->parent);\r\nstruct mx3_camera_dev *mx3_cam = ici->priv;\r\nstruct v4l2_mbus_config cfg = {.type = V4L2_MBUS_PARALLEL,};\r\nu32 pixfmt = icd->current_fmt->host_fmt->fourcc;\r\nunsigned long bus_flags, common_flags;\r\nu32 dw, sens_conf;\r\nconst struct soc_mbus_pixelfmt *fmt;\r\nint buswidth;\r\nint ret;\r\nconst struct soc_camera_format_xlate *xlate;\r\nstruct device *dev = icd->parent;\r\nfmt = soc_mbus_get_fmtdesc(icd->current_fmt->code);\r\nif (!fmt)\r\nreturn -EINVAL;\r\nxlate = soc_camera_xlate_by_fourcc(icd, pixfmt);\r\nif (!xlate) {\r\ndev_warn(dev, "Format %x not found\n", pixfmt);\r\nreturn -EINVAL;\r\n}\r\nbuswidth = fmt->bits_per_sample;\r\nret = test_platform_param(mx3_cam, buswidth, &bus_flags);\r\ndev_dbg(dev, "requested bus width %d bit: %d\n", buswidth, ret);\r\nif (ret < 0)\r\nreturn ret;\r\nret = v4l2_subdev_call(sd, video, g_mbus_config, &cfg);\r\nif (!ret) {\r\ncommon_flags = soc_mbus_config_compatible(&cfg,\r\nbus_flags);\r\nif (!common_flags) {\r\ndev_warn(icd->parent,\r\n"Flags incompatible: camera 0x%x, host 0x%lx\n",\r\ncfg.flags, bus_flags);\r\nreturn -EINVAL;\r\n}\r\n} else if (ret != -ENOIOCTLCMD) {\r\nreturn ret;\r\n} else {\r\ncommon_flags = bus_flags;\r\n}\r\ndev_dbg(dev, "Flags cam: 0x%x host: 0x%lx common: 0x%lx\n",\r\ncfg.flags, bus_flags, common_flags);\r\nif ((common_flags & V4L2_MBUS_HSYNC_ACTIVE_HIGH) &&\r\n(common_flags & V4L2_MBUS_HSYNC_ACTIVE_LOW)) {\r\nif (mx3_cam->platform_flags & MX3_CAMERA_HSP)\r\ncommon_flags &= ~V4L2_MBUS_HSYNC_ACTIVE_HIGH;\r\nelse\r\ncommon_flags &= ~V4L2_MBUS_HSYNC_ACTIVE_LOW;\r\n}\r\nif ((common_flags & V4L2_MBUS_VSYNC_ACTIVE_HIGH) &&\r\n(common_flags & V4L2_MBUS_VSYNC_ACTIVE_LOW)) {\r\nif (mx3_cam->platform_flags & MX3_CAMERA_VSP)\r\ncommon_flags &= ~V4L2_MBUS_VSYNC_ACTIVE_HIGH;\r\nelse\r\ncommon_flags &= ~V4L2_MBUS_VSYNC_ACTIVE_LOW;\r\n}\r\nif ((common_flags & V4L2_MBUS_DATA_ACTIVE_HIGH) &&\r\n(common_flags & V4L2_MBUS_DATA_ACTIVE_LOW)) {\r\nif (mx3_cam->platform_flags & MX3_CAMERA_DP)\r\ncommon_flags &= ~V4L2_MBUS_DATA_ACTIVE_HIGH;\r\nelse\r\ncommon_flags &= ~V4L2_MBUS_DATA_ACTIVE_LOW;\r\n}\r\nif ((common_flags & V4L2_MBUS_PCLK_SAMPLE_RISING) &&\r\n(common_flags & V4L2_MBUS_PCLK_SAMPLE_FALLING)) {\r\nif (mx3_cam->platform_flags & MX3_CAMERA_PCP)\r\ncommon_flags &= ~V4L2_MBUS_PCLK_SAMPLE_RISING;\r\nelse\r\ncommon_flags &= ~V4L2_MBUS_PCLK_SAMPLE_FALLING;\r\n}\r\ncfg.flags = common_flags;\r\nret = v4l2_subdev_call(sd, video, s_mbus_config, &cfg);\r\nif (ret < 0 && ret != -ENOIOCTLCMD) {\r\ndev_dbg(dev, "camera s_mbus_config(0x%lx) returned %d\n",\r\ncommon_flags, ret);\r\nreturn ret;\r\n}\r\nsens_conf = csi_reg_read(mx3_cam, CSI_SENS_CONF) &\r\n~((1 << CSI_SENS_CONF_VSYNC_POL_SHIFT) |\r\n(1 << CSI_SENS_CONF_HSYNC_POL_SHIFT) |\r\n(1 << CSI_SENS_CONF_DATA_POL_SHIFT) |\r\n(1 << CSI_SENS_CONF_PIX_CLK_POL_SHIFT) |\r\n(3 << CSI_SENS_CONF_DATA_FMT_SHIFT) |\r\n(3 << CSI_SENS_CONF_DATA_WIDTH_SHIFT));\r\nsens_conf |= CSI_SENS_CONF_DATA_FMT_BAYER;\r\nif (common_flags & V4L2_MBUS_PCLK_SAMPLE_FALLING)\r\nsens_conf |= 1 << CSI_SENS_CONF_PIX_CLK_POL_SHIFT;\r\nif (common_flags & V4L2_MBUS_HSYNC_ACTIVE_LOW)\r\nsens_conf |= 1 << CSI_SENS_CONF_HSYNC_POL_SHIFT;\r\nif (common_flags & V4L2_MBUS_VSYNC_ACTIVE_LOW)\r\nsens_conf |= 1 << CSI_SENS_CONF_VSYNC_POL_SHIFT;\r\nif (common_flags & V4L2_MBUS_DATA_ACTIVE_LOW)\r\nsens_conf |= 1 << CSI_SENS_CONF_DATA_POL_SHIFT;\r\nswitch (xlate->host_fmt->bits_per_sample) {\r\ncase 4:\r\ndw = 0 << CSI_SENS_CONF_DATA_WIDTH_SHIFT;\r\nbreak;\r\ncase 8:\r\ndw = 1 << CSI_SENS_CONF_DATA_WIDTH_SHIFT;\r\nbreak;\r\ncase 10:\r\ndw = 2 << CSI_SENS_CONF_DATA_WIDTH_SHIFT;\r\nbreak;\r\ndefault:\r\ncase 15:\r\ndw = 3 << CSI_SENS_CONF_DATA_WIDTH_SHIFT;\r\n}\r\ncsi_reg_write(mx3_cam, sens_conf | dw, CSI_SENS_CONF);\r\ndev_dbg(dev, "Set SENS_CONF to %x\n", sens_conf | dw);\r\nreturn 0;\r\n}\r\nstatic int mx3_camera_probe(struct platform_device *pdev)\r\n{\r\nstruct mx3_camera_pdata *pdata = pdev->dev.platform_data;\r\nstruct mx3_camera_dev *mx3_cam;\r\nstruct resource *res;\r\nvoid __iomem *base;\r\nint err = 0;\r\nstruct soc_camera_host *soc_host;\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nbase = devm_ioremap_resource(&pdev->dev, res);\r\nif (IS_ERR(base))\r\nreturn PTR_ERR(base);\r\nif (!pdata)\r\nreturn -EINVAL;\r\nmx3_cam = devm_kzalloc(&pdev->dev, sizeof(*mx3_cam), GFP_KERNEL);\r\nif (!mx3_cam) {\r\ndev_err(&pdev->dev, "Could not allocate mx3 camera object\n");\r\nreturn -ENOMEM;\r\n}\r\nmx3_cam->clk = devm_clk_get(&pdev->dev, NULL);\r\nif (IS_ERR(mx3_cam->clk))\r\nreturn PTR_ERR(mx3_cam->clk);\r\nmx3_cam->pdata = pdata;\r\nmx3_cam->platform_flags = pdata->flags;\r\nif (!(mx3_cam->platform_flags & MX3_CAMERA_DATAWIDTH_MASK)) {\r\ndev_warn(&pdev->dev, "WARNING! Platform hasn't set available "\r\n"data widths, using default 8 bit\n");\r\nmx3_cam->platform_flags |= MX3_CAMERA_DATAWIDTH_8;\r\n}\r\nif (mx3_cam->platform_flags & MX3_CAMERA_DATAWIDTH_4)\r\nmx3_cam->width_flags = 1 << 3;\r\nif (mx3_cam->platform_flags & MX3_CAMERA_DATAWIDTH_8)\r\nmx3_cam->width_flags |= 1 << 7;\r\nif (mx3_cam->platform_flags & MX3_CAMERA_DATAWIDTH_10)\r\nmx3_cam->width_flags |= 1 << 9;\r\nif (mx3_cam->platform_flags & MX3_CAMERA_DATAWIDTH_15)\r\nmx3_cam->width_flags |= 1 << 14;\r\nmx3_cam->mclk = pdata->mclk_10khz * 10000;\r\nif (!mx3_cam->mclk) {\r\ndev_warn(&pdev->dev,\r\n"mclk_10khz == 0! Please, fix your platform data. "\r\n"Using default 20MHz\n");\r\nmx3_cam->mclk = 20000000;\r\n}\r\nINIT_LIST_HEAD(&mx3_cam->capture);\r\nspin_lock_init(&mx3_cam->lock);\r\nmx3_cam->base = base;\r\nsoc_host = &mx3_cam->soc_host;\r\nsoc_host->drv_name = MX3_CAM_DRV_NAME;\r\nsoc_host->ops = &mx3_soc_camera_host_ops;\r\nsoc_host->priv = mx3_cam;\r\nsoc_host->v4l2_dev.dev = &pdev->dev;\r\nsoc_host->nr = pdev->id;\r\nmx3_cam->alloc_ctx = vb2_dma_contig_init_ctx(&pdev->dev);\r\nif (IS_ERR(mx3_cam->alloc_ctx))\r\nreturn PTR_ERR(mx3_cam->alloc_ctx);\r\nif (pdata->asd_sizes) {\r\nsoc_host->asd = pdata->asd;\r\nsoc_host->asd_sizes = pdata->asd_sizes;\r\n}\r\nerr = soc_camera_host_register(soc_host);\r\nif (err)\r\ngoto ecamhostreg;\r\ndmaengine_get();\r\nreturn 0;\r\necamhostreg:\r\nvb2_dma_contig_cleanup_ctx(mx3_cam->alloc_ctx);\r\nreturn err;\r\n}\r\nstatic int mx3_camera_remove(struct platform_device *pdev)\r\n{\r\nstruct soc_camera_host *soc_host = to_soc_camera_host(&pdev->dev);\r\nstruct mx3_camera_dev *mx3_cam = container_of(soc_host,\r\nstruct mx3_camera_dev, soc_host);\r\nsoc_camera_host_unregister(soc_host);\r\nif (WARN_ON(mx3_cam->idmac_channel[0]))\r\ndma_release_channel(&mx3_cam->idmac_channel[0]->dma_chan);\r\nvb2_dma_contig_cleanup_ctx(mx3_cam->alloc_ctx);\r\ndmaengine_put();\r\nreturn 0;\r\n}
