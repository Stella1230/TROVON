static int ramoops_pstore_open(struct pstore_info *psi)\r\n{\r\nstruct ramoops_context *cxt = psi->data;\r\ncxt->dump_read_cnt = 0;\r\ncxt->console_read_cnt = 0;\r\ncxt->ftrace_read_cnt = 0;\r\ncxt->pmsg_read_cnt = 0;\r\nreturn 0;\r\n}\r\nstatic struct persistent_ram_zone *\r\nramoops_get_next_prz(struct persistent_ram_zone *przs[], uint *c, uint max,\r\nu64 *id,\r\nenum pstore_type_id *typep, enum pstore_type_id type,\r\nbool update)\r\n{\r\nstruct persistent_ram_zone *prz;\r\nint i = (*c)++;\r\nif (i >= max)\r\nreturn NULL;\r\nprz = przs[i];\r\nif (!prz)\r\nreturn NULL;\r\nif (update)\r\npersistent_ram_save_old(prz);\r\nif (!persistent_ram_old_size(prz))\r\nreturn NULL;\r\n*typep = type;\r\n*id = i;\r\nreturn prz;\r\n}\r\nstatic int ramoops_read_kmsg_hdr(char *buffer, struct timespec *time,\r\nbool *compressed)\r\n{\r\nchar data_type;\r\nint header_length = 0;\r\nif (sscanf(buffer, RAMOOPS_KERNMSG_HDR "%lu.%lu-%c\n%n", &time->tv_sec,\r\n&time->tv_nsec, &data_type, &header_length) == 3) {\r\nif (data_type == 'C')\r\n*compressed = true;\r\nelse\r\n*compressed = false;\r\n} else if (sscanf(buffer, RAMOOPS_KERNMSG_HDR "%lu.%lu\n%n",\r\n&time->tv_sec, &time->tv_nsec, &header_length) == 2) {\r\n*compressed = false;\r\n} else {\r\ntime->tv_sec = 0;\r\ntime->tv_nsec = 0;\r\n*compressed = false;\r\n}\r\nreturn header_length;\r\n}\r\nstatic bool prz_ok(struct persistent_ram_zone *prz)\r\n{\r\nreturn !!prz && !!(persistent_ram_old_size(prz) +\r\npersistent_ram_ecc_string(prz, NULL, 0));\r\n}\r\nstatic ssize_t ramoops_pstore_read(u64 *id, enum pstore_type_id *type,\r\nint *count, struct timespec *time,\r\nchar **buf, bool *compressed,\r\nstruct pstore_info *psi)\r\n{\r\nssize_t size;\r\nssize_t ecc_notice_size;\r\nstruct ramoops_context *cxt = psi->data;\r\nstruct persistent_ram_zone *prz = NULL;\r\nint header_length = 0;\r\ntime->tv_sec = 0;\r\ntime->tv_nsec = 0;\r\n*compressed = false;\r\nwhile (cxt->dump_read_cnt < cxt->max_dump_cnt && !prz) {\r\nprz = ramoops_get_next_prz(cxt->przs, &cxt->dump_read_cnt,\r\ncxt->max_dump_cnt, id, type,\r\nPSTORE_TYPE_DMESG, 1);\r\nif (!prz_ok(prz))\r\ncontinue;\r\nheader_length = ramoops_read_kmsg_hdr(persistent_ram_old(prz),\r\ntime, compressed);\r\nif (!header_length) {\r\npersistent_ram_free_old(prz);\r\npersistent_ram_zap(prz);\r\nprz = NULL;\r\n}\r\n}\r\nif (!prz_ok(prz))\r\nprz = ramoops_get_next_prz(&cxt->cprz, &cxt->console_read_cnt,\r\n1, id, type, PSTORE_TYPE_CONSOLE, 0);\r\nif (!prz_ok(prz))\r\nprz = ramoops_get_next_prz(&cxt->fprz, &cxt->ftrace_read_cnt,\r\n1, id, type, PSTORE_TYPE_FTRACE, 0);\r\nif (!prz_ok(prz))\r\nprz = ramoops_get_next_prz(&cxt->mprz, &cxt->pmsg_read_cnt,\r\n1, id, type, PSTORE_TYPE_PMSG, 0);\r\nif (!prz_ok(prz))\r\nreturn 0;\r\nsize = persistent_ram_old_size(prz) - header_length;\r\necc_notice_size = persistent_ram_ecc_string(prz, NULL, 0);\r\n*buf = kmalloc(size + ecc_notice_size + 1, GFP_KERNEL);\r\nif (*buf == NULL)\r\nreturn -ENOMEM;\r\nmemcpy(*buf, (char *)persistent_ram_old(prz) + header_length, size);\r\npersistent_ram_ecc_string(prz, *buf + size, ecc_notice_size + 1);\r\nreturn size + ecc_notice_size;\r\n}\r\nstatic size_t ramoops_write_kmsg_hdr(struct persistent_ram_zone *prz,\r\nbool compressed)\r\n{\r\nchar *hdr;\r\nstruct timespec timestamp;\r\nsize_t len;\r\nif (__getnstimeofday(&timestamp)) {\r\ntimestamp.tv_sec = 0;\r\ntimestamp.tv_nsec = 0;\r\n}\r\nhdr = kasprintf(GFP_ATOMIC, RAMOOPS_KERNMSG_HDR "%lu.%lu-%c\n",\r\n(long)timestamp.tv_sec, (long)(timestamp.tv_nsec / 1000),\r\ncompressed ? 'C' : 'D');\r\nWARN_ON_ONCE(!hdr);\r\nlen = hdr ? strlen(hdr) : 0;\r\npersistent_ram_write(prz, hdr, len);\r\nkfree(hdr);\r\nreturn len;\r\n}\r\nstatic int notrace ramoops_pstore_write_buf(enum pstore_type_id type,\r\nenum kmsg_dump_reason reason,\r\nu64 *id, unsigned int part,\r\nconst char *buf,\r\nbool compressed, size_t size,\r\nstruct pstore_info *psi)\r\n{\r\nstruct ramoops_context *cxt = psi->data;\r\nstruct persistent_ram_zone *prz;\r\nsize_t hlen;\r\nif (type == PSTORE_TYPE_CONSOLE) {\r\nif (!cxt->cprz)\r\nreturn -ENOMEM;\r\npersistent_ram_write(cxt->cprz, buf, size);\r\nreturn 0;\r\n} else if (type == PSTORE_TYPE_FTRACE) {\r\nif (!cxt->fprz)\r\nreturn -ENOMEM;\r\npersistent_ram_write(cxt->fprz, buf, size);\r\nreturn 0;\r\n} else if (type == PSTORE_TYPE_PMSG) {\r\nif (!cxt->mprz)\r\nreturn -ENOMEM;\r\npersistent_ram_write(cxt->mprz, buf, size);\r\nreturn 0;\r\n}\r\nif (type != PSTORE_TYPE_DMESG)\r\nreturn -EINVAL;\r\nif (reason != KMSG_DUMP_OOPS &&\r\nreason != KMSG_DUMP_PANIC)\r\nreturn -EINVAL;\r\nif (reason == KMSG_DUMP_OOPS && !cxt->dump_oops)\r\nreturn -EINVAL;\r\nif (part != 1)\r\nreturn -ENOSPC;\r\nif (!cxt->przs)\r\nreturn -ENOSPC;\r\nprz = cxt->przs[cxt->dump_write_cnt];\r\nhlen = ramoops_write_kmsg_hdr(prz, compressed);\r\nif (size + hlen > prz->buffer_size)\r\nsize = prz->buffer_size - hlen;\r\npersistent_ram_write(prz, buf, size);\r\ncxt->dump_write_cnt = (cxt->dump_write_cnt + 1) % cxt->max_dump_cnt;\r\nreturn 0;\r\n}\r\nstatic int ramoops_pstore_erase(enum pstore_type_id type, u64 id, int count,\r\nstruct timespec time, struct pstore_info *psi)\r\n{\r\nstruct ramoops_context *cxt = psi->data;\r\nstruct persistent_ram_zone *prz;\r\nswitch (type) {\r\ncase PSTORE_TYPE_DMESG:\r\nif (id >= cxt->max_dump_cnt)\r\nreturn -EINVAL;\r\nprz = cxt->przs[id];\r\nbreak;\r\ncase PSTORE_TYPE_CONSOLE:\r\nprz = cxt->cprz;\r\nbreak;\r\ncase PSTORE_TYPE_FTRACE:\r\nprz = cxt->fprz;\r\nbreak;\r\ncase PSTORE_TYPE_PMSG:\r\nprz = cxt->mprz;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\npersistent_ram_free_old(prz);\r\npersistent_ram_zap(prz);\r\nreturn 0;\r\n}\r\nstatic void ramoops_free_przs(struct ramoops_context *cxt)\r\n{\r\nint i;\r\ncxt->max_dump_cnt = 0;\r\nif (!cxt->przs)\r\nreturn;\r\nfor (i = 0; !IS_ERR_OR_NULL(cxt->przs[i]); i++)\r\npersistent_ram_free(cxt->przs[i]);\r\nkfree(cxt->przs);\r\n}\r\nstatic int ramoops_init_przs(struct device *dev, struct ramoops_context *cxt,\r\nphys_addr_t *paddr, size_t dump_mem_sz)\r\n{\r\nint err = -ENOMEM;\r\nint i;\r\nif (!cxt->record_size)\r\nreturn 0;\r\nif (*paddr + dump_mem_sz - cxt->phys_addr > cxt->size) {\r\ndev_err(dev, "no room for dumps\n");\r\nreturn -ENOMEM;\r\n}\r\ncxt->max_dump_cnt = dump_mem_sz / cxt->record_size;\r\nif (!cxt->max_dump_cnt)\r\nreturn -ENOMEM;\r\ncxt->przs = kzalloc(sizeof(*cxt->przs) * cxt->max_dump_cnt,\r\nGFP_KERNEL);\r\nif (!cxt->przs) {\r\ndev_err(dev, "failed to initialize a prz array for dumps\n");\r\ngoto fail_prz;\r\n}\r\nfor (i = 0; i < cxt->max_dump_cnt; i++) {\r\ncxt->przs[i] = persistent_ram_new(*paddr, cxt->record_size, 0,\r\n&cxt->ecc_info,\r\ncxt->memtype);\r\nif (IS_ERR(cxt->przs[i])) {\r\nerr = PTR_ERR(cxt->przs[i]);\r\ndev_err(dev, "failed to request mem region (0x%zx@0x%llx): %d\n",\r\ncxt->record_size, (unsigned long long)*paddr, err);\r\ngoto fail_prz;\r\n}\r\n*paddr += cxt->record_size;\r\n}\r\nreturn 0;\r\nfail_prz:\r\nramoops_free_przs(cxt);\r\nreturn err;\r\n}\r\nstatic int ramoops_init_prz(struct device *dev, struct ramoops_context *cxt,\r\nstruct persistent_ram_zone **prz,\r\nphys_addr_t *paddr, size_t sz, u32 sig)\r\n{\r\nif (!sz)\r\nreturn 0;\r\nif (*paddr + sz - cxt->phys_addr > cxt->size) {\r\ndev_err(dev, "no room for mem region (0x%zx@0x%llx) in (0x%lx@0x%llx)\n",\r\nsz, (unsigned long long)*paddr,\r\ncxt->size, (unsigned long long)cxt->phys_addr);\r\nreturn -ENOMEM;\r\n}\r\n*prz = persistent_ram_new(*paddr, sz, sig, &cxt->ecc_info, cxt->memtype);\r\nif (IS_ERR(*prz)) {\r\nint err = PTR_ERR(*prz);\r\ndev_err(dev, "failed to request mem region (0x%zx@0x%llx): %d\n",\r\nsz, (unsigned long long)*paddr, err);\r\nreturn err;\r\n}\r\npersistent_ram_zap(*prz);\r\n*paddr += sz;\r\nreturn 0;\r\n}\r\nstatic int ramoops_probe(struct platform_device *pdev)\r\n{\r\nstruct device *dev = &pdev->dev;\r\nstruct ramoops_platform_data *pdata = pdev->dev.platform_data;\r\nstruct ramoops_context *cxt = &oops_cxt;\r\nsize_t dump_mem_sz;\r\nphys_addr_t paddr;\r\nint err = -EINVAL;\r\nif (cxt->max_dump_cnt)\r\ngoto fail_out;\r\nif (!pdata->mem_size || (!pdata->record_size && !pdata->console_size &&\r\n!pdata->ftrace_size && !pdata->pmsg_size)) {\r\npr_err("The memory size and the record/console size must be "\r\n"non-zero\n");\r\ngoto fail_out;\r\n}\r\nif (pdata->record_size && !is_power_of_2(pdata->record_size))\r\npdata->record_size = rounddown_pow_of_two(pdata->record_size);\r\nif (pdata->console_size && !is_power_of_2(pdata->console_size))\r\npdata->console_size = rounddown_pow_of_two(pdata->console_size);\r\nif (pdata->ftrace_size && !is_power_of_2(pdata->ftrace_size))\r\npdata->ftrace_size = rounddown_pow_of_two(pdata->ftrace_size);\r\nif (pdata->pmsg_size && !is_power_of_2(pdata->pmsg_size))\r\npdata->pmsg_size = rounddown_pow_of_two(pdata->pmsg_size);\r\ncxt->size = pdata->mem_size;\r\ncxt->phys_addr = pdata->mem_address;\r\ncxt->memtype = pdata->mem_type;\r\ncxt->record_size = pdata->record_size;\r\ncxt->console_size = pdata->console_size;\r\ncxt->ftrace_size = pdata->ftrace_size;\r\ncxt->pmsg_size = pdata->pmsg_size;\r\ncxt->dump_oops = pdata->dump_oops;\r\ncxt->ecc_info = pdata->ecc_info;\r\npaddr = cxt->phys_addr;\r\ndump_mem_sz = cxt->size - cxt->console_size - cxt->ftrace_size\r\n- cxt->pmsg_size;\r\nerr = ramoops_init_przs(dev, cxt, &paddr, dump_mem_sz);\r\nif (err)\r\ngoto fail_out;\r\nerr = ramoops_init_prz(dev, cxt, &cxt->cprz, &paddr,\r\ncxt->console_size, 0);\r\nif (err)\r\ngoto fail_init_cprz;\r\nerr = ramoops_init_prz(dev, cxt, &cxt->fprz, &paddr, cxt->ftrace_size,\r\nLINUX_VERSION_CODE);\r\nif (err)\r\ngoto fail_init_fprz;\r\nerr = ramoops_init_prz(dev, cxt, &cxt->mprz, &paddr, cxt->pmsg_size, 0);\r\nif (err)\r\ngoto fail_init_mprz;\r\ncxt->pstore.data = cxt;\r\nif (cxt->console_size)\r\ncxt->pstore.bufsize = 1024;\r\ncxt->pstore.bufsize = max(cxt->record_size, cxt->pstore.bufsize);\r\ncxt->pstore.buf = kmalloc(cxt->pstore.bufsize, GFP_KERNEL);\r\nspin_lock_init(&cxt->pstore.buf_lock);\r\nif (!cxt->pstore.buf) {\r\npr_err("cannot allocate pstore buffer\n");\r\nerr = -ENOMEM;\r\ngoto fail_clear;\r\n}\r\nerr = pstore_register(&cxt->pstore);\r\nif (err) {\r\npr_err("registering with pstore failed\n");\r\ngoto fail_buf;\r\n}\r\nmem_size = pdata->mem_size;\r\nmem_address = pdata->mem_address;\r\nrecord_size = pdata->record_size;\r\ndump_oops = pdata->dump_oops;\r\nramoops_console_size = pdata->console_size;\r\nramoops_pmsg_size = pdata->pmsg_size;\r\nramoops_ftrace_size = pdata->ftrace_size;\r\npr_info("attached 0x%lx@0x%llx, ecc: %d/%d\n",\r\ncxt->size, (unsigned long long)cxt->phys_addr,\r\ncxt->ecc_info.ecc_size, cxt->ecc_info.block_size);\r\nreturn 0;\r\nfail_buf:\r\nkfree(cxt->pstore.buf);\r\nfail_clear:\r\ncxt->pstore.bufsize = 0;\r\nkfree(cxt->mprz);\r\nfail_init_mprz:\r\nkfree(cxt->fprz);\r\nfail_init_fprz:\r\nkfree(cxt->cprz);\r\nfail_init_cprz:\r\nramoops_free_przs(cxt);\r\nfail_out:\r\nreturn err;\r\n}\r\nstatic int ramoops_remove(struct platform_device *pdev)\r\n{\r\nstruct ramoops_context *cxt = &oops_cxt;\r\npstore_unregister(&cxt->pstore);\r\ncxt->max_dump_cnt = 0;\r\nkfree(cxt->pstore.buf);\r\ncxt->pstore.bufsize = 0;\r\npersistent_ram_free(cxt->mprz);\r\npersistent_ram_free(cxt->fprz);\r\npersistent_ram_free(cxt->cprz);\r\nramoops_free_przs(cxt);\r\nreturn 0;\r\n}\r\nstatic void ramoops_register_dummy(void)\r\n{\r\nif (!mem_size)\r\nreturn;\r\npr_info("using module parameters\n");\r\ndummy_data = kzalloc(sizeof(*dummy_data), GFP_KERNEL);\r\nif (!dummy_data) {\r\npr_info("could not allocate pdata\n");\r\nreturn;\r\n}\r\ndummy_data->mem_size = mem_size;\r\ndummy_data->mem_address = mem_address;\r\ndummy_data->mem_type = mem_type;\r\ndummy_data->record_size = record_size;\r\ndummy_data->console_size = ramoops_console_size;\r\ndummy_data->ftrace_size = ramoops_ftrace_size;\r\ndummy_data->pmsg_size = ramoops_pmsg_size;\r\ndummy_data->dump_oops = dump_oops;\r\ndummy_data->ecc_info.ecc_size = ramoops_ecc == 1 ? 16 : ramoops_ecc;\r\ndummy = platform_device_register_data(NULL, "ramoops", -1,\r\ndummy_data, sizeof(struct ramoops_platform_data));\r\nif (IS_ERR(dummy)) {\r\npr_info("could not create platform device: %ld\n",\r\nPTR_ERR(dummy));\r\n}\r\n}\r\nstatic int __init ramoops_init(void)\r\n{\r\nramoops_register_dummy();\r\nreturn platform_driver_register(&ramoops_driver);\r\n}\r\nstatic void __exit ramoops_exit(void)\r\n{\r\nplatform_driver_unregister(&ramoops_driver);\r\nplatform_device_unregister(dummy);\r\nkfree(dummy_data);\r\n}
