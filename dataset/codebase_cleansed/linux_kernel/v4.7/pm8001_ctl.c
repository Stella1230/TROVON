static ssize_t pm8001_ctl_mpi_interface_rev_show(struct device *cdev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct Scsi_Host *shost = class_to_shost(cdev);\r\nstruct sas_ha_struct *sha = SHOST_TO_SAS_HA(shost);\r\nstruct pm8001_hba_info *pm8001_ha = sha->lldd_ha;\r\nif (pm8001_ha->chip_id == chip_8001) {\r\nreturn snprintf(buf, PAGE_SIZE, "%d\n",\r\npm8001_ha->main_cfg_tbl.pm8001_tbl.interface_rev);\r\n} else {\r\nreturn snprintf(buf, PAGE_SIZE, "%d\n",\r\npm8001_ha->main_cfg_tbl.pm80xx_tbl.interface_rev);\r\n}\r\n}\r\nstatic ssize_t pm8001_ctl_fw_version_show(struct device *cdev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct Scsi_Host *shost = class_to_shost(cdev);\r\nstruct sas_ha_struct *sha = SHOST_TO_SAS_HA(shost);\r\nstruct pm8001_hba_info *pm8001_ha = sha->lldd_ha;\r\nif (pm8001_ha->chip_id == chip_8001) {\r\nreturn snprintf(buf, PAGE_SIZE, "%02x.%02x.%02x.%02x\n",\r\n(u8)(pm8001_ha->main_cfg_tbl.pm8001_tbl.firmware_rev >> 24),\r\n(u8)(pm8001_ha->main_cfg_tbl.pm8001_tbl.firmware_rev >> 16),\r\n(u8)(pm8001_ha->main_cfg_tbl.pm8001_tbl.firmware_rev >> 8),\r\n(u8)(pm8001_ha->main_cfg_tbl.pm8001_tbl.firmware_rev));\r\n} else {\r\nreturn snprintf(buf, PAGE_SIZE, "%02x.%02x.%02x.%02x\n",\r\n(u8)(pm8001_ha->main_cfg_tbl.pm80xx_tbl.firmware_rev >> 24),\r\n(u8)(pm8001_ha->main_cfg_tbl.pm80xx_tbl.firmware_rev >> 16),\r\n(u8)(pm8001_ha->main_cfg_tbl.pm80xx_tbl.firmware_rev >> 8),\r\n(u8)(pm8001_ha->main_cfg_tbl.pm80xx_tbl.firmware_rev));\r\n}\r\n}\r\nstatic ssize_t pm8001_ctl_max_out_io_show(struct device *cdev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct Scsi_Host *shost = class_to_shost(cdev);\r\nstruct sas_ha_struct *sha = SHOST_TO_SAS_HA(shost);\r\nstruct pm8001_hba_info *pm8001_ha = sha->lldd_ha;\r\nif (pm8001_ha->chip_id == chip_8001) {\r\nreturn snprintf(buf, PAGE_SIZE, "%d\n",\r\npm8001_ha->main_cfg_tbl.pm8001_tbl.max_out_io);\r\n} else {\r\nreturn snprintf(buf, PAGE_SIZE, "%d\n",\r\npm8001_ha->main_cfg_tbl.pm80xx_tbl.max_out_io);\r\n}\r\n}\r\nstatic ssize_t pm8001_ctl_max_devices_show(struct device *cdev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct Scsi_Host *shost = class_to_shost(cdev);\r\nstruct sas_ha_struct *sha = SHOST_TO_SAS_HA(shost);\r\nstruct pm8001_hba_info *pm8001_ha = sha->lldd_ha;\r\nif (pm8001_ha->chip_id == chip_8001) {\r\nreturn snprintf(buf, PAGE_SIZE, "%04d\n",\r\n(u16)(pm8001_ha->main_cfg_tbl.pm8001_tbl.max_sgl >> 16)\r\n);\r\n} else {\r\nreturn snprintf(buf, PAGE_SIZE, "%04d\n",\r\n(u16)(pm8001_ha->main_cfg_tbl.pm80xx_tbl.max_sgl >> 16)\r\n);\r\n}\r\n}\r\nstatic ssize_t pm8001_ctl_max_sg_list_show(struct device *cdev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct Scsi_Host *shost = class_to_shost(cdev);\r\nstruct sas_ha_struct *sha = SHOST_TO_SAS_HA(shost);\r\nstruct pm8001_hba_info *pm8001_ha = sha->lldd_ha;\r\nif (pm8001_ha->chip_id == chip_8001) {\r\nreturn snprintf(buf, PAGE_SIZE, "%04d\n",\r\npm8001_ha->main_cfg_tbl.pm8001_tbl.max_sgl & 0x0000FFFF\r\n);\r\n} else {\r\nreturn snprintf(buf, PAGE_SIZE, "%04d\n",\r\npm8001_ha->main_cfg_tbl.pm80xx_tbl.max_sgl & 0x0000FFFF\r\n);\r\n}\r\n}\r\nstatic ssize_t\r\nshow_sas_spec_support_status(unsigned int mode, char *buf)\r\n{\r\nssize_t len = 0;\r\nif (mode & SAS_1_1)\r\nlen = sprintf(buf, "%s", "SAS1.1");\r\nif (mode & SAS_2_0)\r\nlen += sprintf(buf + len, "%s%s", len ? ", " : "", "SAS2.0");\r\nlen += sprintf(buf + len, "\n");\r\nreturn len;\r\n}\r\nstatic ssize_t pm8001_ctl_sas_spec_support_show(struct device *cdev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nunsigned int mode;\r\nstruct Scsi_Host *shost = class_to_shost(cdev);\r\nstruct sas_ha_struct *sha = SHOST_TO_SAS_HA(shost);\r\nstruct pm8001_hba_info *pm8001_ha = sha->lldd_ha;\r\nif (pm8001_ha->chip_id == chip_8001)\r\nmode = (pm8001_ha->main_cfg_tbl.pm8001_tbl.ctrl_cap_flag &\r\n0xfe000000)>>25;\r\nelse\r\nmode = (pm8001_ha->main_cfg_tbl.pm80xx_tbl.ctrl_cap_flag &\r\n0xfe000000)>>25;\r\nreturn show_sas_spec_support_status(mode, buf);\r\n}\r\nstatic ssize_t pm8001_ctl_host_sas_address_show(struct device *cdev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct Scsi_Host *shost = class_to_shost(cdev);\r\nstruct sas_ha_struct *sha = SHOST_TO_SAS_HA(shost);\r\nstruct pm8001_hba_info *pm8001_ha = sha->lldd_ha;\r\nreturn snprintf(buf, PAGE_SIZE, "0x%016llx\n",\r\nbe64_to_cpu(*(__be64 *)pm8001_ha->sas_addr));\r\n}\r\nstatic ssize_t pm8001_ctl_logging_level_show(struct device *cdev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct Scsi_Host *shost = class_to_shost(cdev);\r\nstruct sas_ha_struct *sha = SHOST_TO_SAS_HA(shost);\r\nstruct pm8001_hba_info *pm8001_ha = sha->lldd_ha;\r\nreturn snprintf(buf, PAGE_SIZE, "%08xh\n", pm8001_ha->logging_level);\r\n}\r\nstatic ssize_t pm8001_ctl_logging_level_store(struct device *cdev,\r\nstruct device_attribute *attr, const char *buf, size_t count)\r\n{\r\nstruct Scsi_Host *shost = class_to_shost(cdev);\r\nstruct sas_ha_struct *sha = SHOST_TO_SAS_HA(shost);\r\nstruct pm8001_hba_info *pm8001_ha = sha->lldd_ha;\r\nint val = 0;\r\nif (sscanf(buf, "%x", &val) != 1)\r\nreturn -EINVAL;\r\npm8001_ha->logging_level = val;\r\nreturn strlen(buf);\r\n}\r\nstatic ssize_t pm8001_ctl_aap_log_show(struct device *cdev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct Scsi_Host *shost = class_to_shost(cdev);\r\nstruct sas_ha_struct *sha = SHOST_TO_SAS_HA(shost);\r\nstruct pm8001_hba_info *pm8001_ha = sha->lldd_ha;\r\nint i;\r\n#define AAP1_MEMMAP(r, c) \\r\n(*(u32 *)((u8*)pm8001_ha->memoryMap.region[AAP1].virt_ptr + (r) * 32 \\r\n+ (c)))\r\nchar *str = buf;\r\nint max = 2;\r\nfor (i = 0; i < max; i++) {\r\nstr += sprintf(str, "0x%08x 0x%08x 0x%08x 0x%08x 0x%08x 0x%08x"\r\n"0x%08x 0x%08x\n",\r\nAAP1_MEMMAP(i, 0),\r\nAAP1_MEMMAP(i, 4),\r\nAAP1_MEMMAP(i, 8),\r\nAAP1_MEMMAP(i, 12),\r\nAAP1_MEMMAP(i, 16),\r\nAAP1_MEMMAP(i, 20),\r\nAAP1_MEMMAP(i, 24),\r\nAAP1_MEMMAP(i, 28));\r\n}\r\nreturn str - buf;\r\n}\r\nstatic ssize_t pm8001_ctl_ib_queue_log_show(struct device *cdev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct Scsi_Host *shost = class_to_shost(cdev);\r\nstruct sas_ha_struct *sha = SHOST_TO_SAS_HA(shost);\r\nstruct pm8001_hba_info *pm8001_ha = sha->lldd_ha;\r\nint offset;\r\nchar *str = buf;\r\nint start = 0;\r\n#define IB_MEMMAP(c) \\r\n(*(u32 *)((u8 *)pm8001_ha-> \\r\nmemoryMap.region[IB].virt_ptr + \\r\npm8001_ha->evtlog_ib_offset + (c)))\r\nfor (offset = 0; offset < IB_OB_READ_TIMES; offset++) {\r\nstr += sprintf(str, "0x%08x\n", IB_MEMMAP(start));\r\nstart = start + 4;\r\n}\r\npm8001_ha->evtlog_ib_offset += SYSFS_OFFSET;\r\nif (((pm8001_ha->evtlog_ib_offset) % (PM80XX_IB_OB_QUEUE_SIZE)) == 0)\r\npm8001_ha->evtlog_ib_offset = 0;\r\nreturn str - buf;\r\n}\r\nstatic ssize_t pm8001_ctl_ob_queue_log_show(struct device *cdev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct Scsi_Host *shost = class_to_shost(cdev);\r\nstruct sas_ha_struct *sha = SHOST_TO_SAS_HA(shost);\r\nstruct pm8001_hba_info *pm8001_ha = sha->lldd_ha;\r\nint offset;\r\nchar *str = buf;\r\nint start = 0;\r\n#define OB_MEMMAP(c) \\r\n(*(u32 *)((u8 *)pm8001_ha-> \\r\nmemoryMap.region[OB].virt_ptr + \\r\npm8001_ha->evtlog_ob_offset + (c)))\r\nfor (offset = 0; offset < IB_OB_READ_TIMES; offset++) {\r\nstr += sprintf(str, "0x%08x\n", OB_MEMMAP(start));\r\nstart = start + 4;\r\n}\r\npm8001_ha->evtlog_ob_offset += SYSFS_OFFSET;\r\nif (((pm8001_ha->evtlog_ob_offset) % (PM80XX_IB_OB_QUEUE_SIZE)) == 0)\r\npm8001_ha->evtlog_ob_offset = 0;\r\nreturn str - buf;\r\n}\r\nstatic ssize_t pm8001_ctl_bios_version_show(struct device *cdev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct Scsi_Host *shost = class_to_shost(cdev);\r\nstruct sas_ha_struct *sha = SHOST_TO_SAS_HA(shost);\r\nstruct pm8001_hba_info *pm8001_ha = sha->lldd_ha;\r\nchar *str = buf;\r\nint bios_index;\r\nDECLARE_COMPLETION_ONSTACK(completion);\r\nstruct pm8001_ioctl_payload payload;\r\npm8001_ha->nvmd_completion = &completion;\r\npayload.minor_function = 7;\r\npayload.offset = 0;\r\npayload.length = 4096;\r\npayload.func_specific = kzalloc(4096, GFP_KERNEL);\r\nif (!payload.func_specific)\r\nreturn -ENOMEM;\r\nif (PM8001_CHIP_DISP->get_nvmd_req(pm8001_ha, &payload)) {\r\nkfree(payload.func_specific);\r\nreturn -ENOMEM;\r\n}\r\nwait_for_completion(&completion);\r\nfor (bios_index = BIOSOFFSET; bios_index < BIOS_OFFSET_LIMIT;\r\nbios_index++)\r\nstr += sprintf(str, "%c",\r\n*(payload.func_specific+bios_index));\r\nkfree(payload.func_specific);\r\nreturn str - buf;\r\n}\r\nstatic ssize_t pm8001_ctl_iop_log_show(struct device *cdev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct Scsi_Host *shost = class_to_shost(cdev);\r\nstruct sas_ha_struct *sha = SHOST_TO_SAS_HA(shost);\r\nstruct pm8001_hba_info *pm8001_ha = sha->lldd_ha;\r\n#define IOP_MEMMAP(r, c) \\r\n(*(u32 *)((u8*)pm8001_ha->memoryMap.region[IOP].virt_ptr + (r) * 32 \\r\n+ (c)))\r\nint i;\r\nchar *str = buf;\r\nint max = 2;\r\nfor (i = 0; i < max; i++) {\r\nstr += sprintf(str, "0x%08x 0x%08x 0x%08x 0x%08x 0x%08x 0x%08x"\r\n"0x%08x 0x%08x\n",\r\nIOP_MEMMAP(i, 0),\r\nIOP_MEMMAP(i, 4),\r\nIOP_MEMMAP(i, 8),\r\nIOP_MEMMAP(i, 12),\r\nIOP_MEMMAP(i, 16),\r\nIOP_MEMMAP(i, 20),\r\nIOP_MEMMAP(i, 24),\r\nIOP_MEMMAP(i, 28));\r\n}\r\nreturn str - buf;\r\n}\r\nstatic ssize_t pm8001_ctl_fatal_log_show(struct device *cdev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nssize_t count;\r\ncount = pm80xx_get_fatal_dump(cdev, attr, buf);\r\nreturn count;\r\n}\r\nstatic ssize_t pm8001_ctl_gsm_log_show(struct device *cdev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nssize_t count;\r\ncount = pm8001_get_gsm_dump(cdev, SYSFS_OFFSET, buf);\r\nreturn count;\r\n}\r\nstatic int pm8001_set_nvmd(struct pm8001_hba_info *pm8001_ha)\r\n{\r\nstruct pm8001_ioctl_payload *payload;\r\nDECLARE_COMPLETION_ONSTACK(completion);\r\nu8 *ioctlbuffer;\r\nu32 ret;\r\nu32 length = 1024 * 5 + sizeof(*payload) - 1;\r\nif (pm8001_ha->fw_image->size > 4096) {\r\npm8001_ha->fw_status = FAIL_FILE_SIZE;\r\nreturn -EFAULT;\r\n}\r\nioctlbuffer = kzalloc(length, GFP_KERNEL);\r\nif (!ioctlbuffer) {\r\npm8001_ha->fw_status = FAIL_OUT_MEMORY;\r\nreturn -ENOMEM;\r\n}\r\npayload = (struct pm8001_ioctl_payload *)ioctlbuffer;\r\nmemcpy((u8 *)&payload->func_specific, (u8 *)pm8001_ha->fw_image->data,\r\npm8001_ha->fw_image->size);\r\npayload->length = pm8001_ha->fw_image->size;\r\npayload->id = 0;\r\npayload->minor_function = 0x1;\r\npm8001_ha->nvmd_completion = &completion;\r\nret = PM8001_CHIP_DISP->set_nvmd_req(pm8001_ha, payload);\r\nif (ret) {\r\npm8001_ha->fw_status = FAIL_OUT_MEMORY;\r\ngoto out;\r\n}\r\nwait_for_completion(&completion);\r\nout:\r\nkfree(ioctlbuffer);\r\nreturn ret;\r\n}\r\nstatic int pm8001_update_flash(struct pm8001_hba_info *pm8001_ha)\r\n{\r\nstruct pm8001_ioctl_payload *payload;\r\nDECLARE_COMPLETION_ONSTACK(completion);\r\nu8 *ioctlbuffer;\r\nstruct fw_control_info *fwControl;\r\nu32 partitionSize, partitionSizeTmp;\r\nu32 loopNumber, loopcount;\r\nstruct pm8001_fw_image_header *image_hdr;\r\nu32 sizeRead = 0;\r\nu32 ret = 0;\r\nu32 length = 1024 * 16 + sizeof(*payload) - 1;\r\nif (pm8001_ha->fw_image->size < 28) {\r\npm8001_ha->fw_status = FAIL_FILE_SIZE;\r\nreturn -EFAULT;\r\n}\r\nioctlbuffer = kzalloc(length, GFP_KERNEL);\r\nif (!ioctlbuffer) {\r\npm8001_ha->fw_status = FAIL_OUT_MEMORY;\r\nreturn -ENOMEM;\r\n}\r\nimage_hdr = (struct pm8001_fw_image_header *)pm8001_ha->fw_image->data;\r\nwhile (sizeRead < pm8001_ha->fw_image->size) {\r\npartitionSizeTmp =\r\n*(u32 *)((u8 *)&image_hdr->image_length + sizeRead);\r\npartitionSize = be32_to_cpu(partitionSizeTmp);\r\nloopcount = DIV_ROUND_UP(partitionSize + HEADER_LEN,\r\nIOCTL_BUF_SIZE);\r\nfor (loopNumber = 0; loopNumber < loopcount; loopNumber++) {\r\npayload = (struct pm8001_ioctl_payload *)ioctlbuffer;\r\npayload->length = 1024*16;\r\npayload->id = 0;\r\nfwControl =\r\n(struct fw_control_info *)&payload->func_specific;\r\nfwControl->len = IOCTL_BUF_SIZE;\r\nfwControl->size = partitionSize + HEADER_LEN;\r\nfwControl->retcode = 0;\r\nfwControl->offset = loopNumber * IOCTL_BUF_SIZE;\r\nif (((loopcount-loopNumber) == 1) &&\r\n((partitionSize + HEADER_LEN) % IOCTL_BUF_SIZE)) {\r\nfwControl->len =\r\n(partitionSize + HEADER_LEN) % IOCTL_BUF_SIZE;\r\nmemcpy((u8 *)fwControl->buffer,\r\n(u8 *)pm8001_ha->fw_image->data + sizeRead,\r\n(partitionSize + HEADER_LEN) % IOCTL_BUF_SIZE);\r\nsizeRead +=\r\n(partitionSize + HEADER_LEN) % IOCTL_BUF_SIZE;\r\n} else {\r\nmemcpy((u8 *)fwControl->buffer,\r\n(u8 *)pm8001_ha->fw_image->data + sizeRead,\r\nIOCTL_BUF_SIZE);\r\nsizeRead += IOCTL_BUF_SIZE;\r\n}\r\npm8001_ha->nvmd_completion = &completion;\r\nret = PM8001_CHIP_DISP->fw_flash_update_req(pm8001_ha, payload);\r\nif (ret) {\r\npm8001_ha->fw_status = FAIL_OUT_MEMORY;\r\ngoto out;\r\n}\r\nwait_for_completion(&completion);\r\nif (fwControl->retcode > FLASH_UPDATE_IN_PROGRESS) {\r\npm8001_ha->fw_status = fwControl->retcode;\r\nret = -EFAULT;\r\ngoto out;\r\n}\r\n}\r\n}\r\nout:\r\nkfree(ioctlbuffer);\r\nreturn ret;\r\n}\r\nstatic ssize_t pm8001_store_update_fw(struct device *cdev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct Scsi_Host *shost = class_to_shost(cdev);\r\nstruct sas_ha_struct *sha = SHOST_TO_SAS_HA(shost);\r\nstruct pm8001_hba_info *pm8001_ha = sha->lldd_ha;\r\nchar *cmd_ptr, *filename_ptr;\r\nint res, i;\r\nint flash_command = FLASH_CMD_NONE;\r\nint ret;\r\nif (!capable(CAP_SYS_ADMIN))\r\nreturn -EACCES;\r\nif (pm8001_ha->fw_status == FLASH_IN_PROGRESS)\r\nreturn -EINPROGRESS;\r\npm8001_ha->fw_status = FLASH_IN_PROGRESS;\r\ncmd_ptr = kzalloc(count*2, GFP_KERNEL);\r\nif (!cmd_ptr) {\r\npm8001_ha->fw_status = FAIL_OUT_MEMORY;\r\nreturn -ENOMEM;\r\n}\r\nfilename_ptr = cmd_ptr + count;\r\nres = sscanf(buf, "%s %s", cmd_ptr, filename_ptr);\r\nif (res != 2) {\r\npm8001_ha->fw_status = FAIL_PARAMETERS;\r\nret = -EINVAL;\r\ngoto out;\r\n}\r\nfor (i = 0; flash_command_table[i].code != FLASH_CMD_NONE; i++) {\r\nif (!memcmp(flash_command_table[i].command,\r\ncmd_ptr, strlen(cmd_ptr))) {\r\nflash_command = flash_command_table[i].code;\r\nbreak;\r\n}\r\n}\r\nif (flash_command == FLASH_CMD_NONE) {\r\npm8001_ha->fw_status = FAIL_PARAMETERS;\r\nret = -EINVAL;\r\ngoto out;\r\n}\r\nret = request_firmware(&pm8001_ha->fw_image,\r\nfilename_ptr,\r\npm8001_ha->dev);\r\nif (ret) {\r\nPM8001_FAIL_DBG(pm8001_ha,\r\npm8001_printk(\r\n"Failed to load firmware image file %s, error %d\n",\r\nfilename_ptr, ret));\r\npm8001_ha->fw_status = FAIL_OPEN_BIOS_FILE;\r\ngoto out;\r\n}\r\nif (FLASH_CMD_UPDATE == flash_command)\r\nret = pm8001_update_flash(pm8001_ha);\r\nelse\r\nret = pm8001_set_nvmd(pm8001_ha);\r\nrelease_firmware(pm8001_ha->fw_image);\r\nout:\r\nkfree(cmd_ptr);\r\nif (ret)\r\nreturn ret;\r\npm8001_ha->fw_status = FLASH_OK;\r\nreturn count;\r\n}\r\nstatic ssize_t pm8001_show_update_fw(struct device *cdev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nint i;\r\nstruct Scsi_Host *shost = class_to_shost(cdev);\r\nstruct sas_ha_struct *sha = SHOST_TO_SAS_HA(shost);\r\nstruct pm8001_hba_info *pm8001_ha = sha->lldd_ha;\r\nfor (i = 0; flash_error_table[i].err_code != 0; i++) {\r\nif (flash_error_table[i].err_code == pm8001_ha->fw_status)\r\nbreak;\r\n}\r\nif (pm8001_ha->fw_status != FLASH_IN_PROGRESS)\r\npm8001_ha->fw_status = FLASH_OK;\r\nreturn snprintf(buf, PAGE_SIZE, "status=%x %s\n",\r\nflash_error_table[i].err_code,\r\nflash_error_table[i].reason);\r\n}
