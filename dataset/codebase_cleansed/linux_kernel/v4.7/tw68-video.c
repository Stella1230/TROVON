static const struct tw68_format *format_by_fourcc(unsigned int fourcc)\r\n{\r\nunsigned int i;\r\nfor (i = 0; i < FORMATS; i++)\r\nif (formats[i].fourcc == fourcc)\r\nreturn formats+i;\r\nreturn NULL;\r\n}\r\nstatic void set_tvnorm(struct tw68_dev *dev, const struct tw68_tvnorm *norm)\r\n{\r\nif (norm != dev->tvnorm) {\r\ndev->width = 720;\r\ndev->height = (norm->id & V4L2_STD_525_60) ? 480 : 576;\r\ndev->tvnorm = norm;\r\ntw68_set_tvnorm_hw(dev);\r\n}\r\n}\r\nstatic int tw68_set_scale(struct tw68_dev *dev, unsigned int width,\r\nunsigned int height, enum v4l2_field field)\r\n{\r\nconst struct tw68_tvnorm *norm = dev->tvnorm;\r\nint hactive, hdelay, hscale;\r\nint vactive, vdelay, vscale;\r\nint comb;\r\nif (V4L2_FIELD_HAS_BOTH(field))\r\nheight /= 2;\r\npr_debug("%s: width=%d, height=%d, both=%d\n"\r\n" tvnorm h_delay=%d, h_start=%d, h_stop=%d, "\r\n"v_delay=%d, v_start=%d, v_stop=%d\n" , __func__,\r\nwidth, height, V4L2_FIELD_HAS_BOTH(field),\r\nnorm->h_delay, norm->h_start, norm->h_stop,\r\nnorm->v_delay, norm->video_v_start,\r\nnorm->video_v_stop);\r\nswitch (dev->vdecoder) {\r\ncase TW6800:\r\nhdelay = norm->h_delay0;\r\nbreak;\r\ndefault:\r\nhdelay = norm->h_delay;\r\nbreak;\r\n}\r\nhdelay += norm->h_start;\r\nhactive = norm->h_stop - norm->h_start + 1;\r\nhscale = (hactive * 256) / (width);\r\nvdelay = norm->v_delay;\r\nvactive = ((norm->id & V4L2_STD_525_60) ? 524 : 624) / 2 - norm->video_v_start;\r\nvscale = (vactive * 256) / height;\r\npr_debug("%s: %dx%d [%s%s,%s]\n", __func__,\r\nwidth, height,\r\nV4L2_FIELD_HAS_TOP(field) ? "T" : "",\r\nV4L2_FIELD_HAS_BOTTOM(field) ? "B" : "",\r\nv4l2_norm_to_name(dev->tvnorm->id));\r\npr_debug("%s: hactive=%d, hdelay=%d, hscale=%d; "\r\n"vactive=%d, vdelay=%d, vscale=%d\n", __func__,\r\nhactive, hdelay, hscale, vactive, vdelay, vscale);\r\ncomb = ((vdelay & 0x300) >> 2) |\r\n((vactive & 0x300) >> 4) |\r\n((hdelay & 0x300) >> 6) |\r\n((hactive & 0x300) >> 8);\r\npr_debug("%s: setting CROP_HI=%02x, VDELAY_LO=%02x, "\r\n"VACTIVE_LO=%02x, HDELAY_LO=%02x, HACTIVE_LO=%02x\n",\r\n__func__, comb, vdelay, vactive, hdelay, hactive);\r\ntw_writeb(TW68_CROP_HI, comb);\r\ntw_writeb(TW68_VDELAY_LO, vdelay & 0xff);\r\ntw_writeb(TW68_VACTIVE_LO, vactive & 0xff);\r\ntw_writeb(TW68_HDELAY_LO, hdelay & 0xff);\r\ntw_writeb(TW68_HACTIVE_LO, hactive & 0xff);\r\ncomb = ((vscale & 0xf00) >> 4) | ((hscale & 0xf00) >> 8);\r\npr_debug("%s: setting SCALE_HI=%02x, VSCALE_LO=%02x, "\r\n"HSCALE_LO=%02x\n", __func__, comb, vscale, hscale);\r\ntw_writeb(TW68_SCALE_HI, comb);\r\ntw_writeb(TW68_VSCALE_LO, vscale);\r\ntw_writeb(TW68_HSCALE_LO, hscale);\r\nreturn 0;\r\n}\r\nint tw68_video_start_dma(struct tw68_dev *dev, struct tw68_buf *buf)\r\n{\r\ntw68_set_scale(dev, dev->width, dev->height, dev->field);\r\ntw_clearl(TW68_DMAC, TW68_DMAP_EN);\r\ntw_writel(TW68_DMAP_SA, buf->dma);\r\ntw_writel(TW68_INTSTAT, dev->board_virqmask);\r\ntw_andorl(TW68_DMAC, 0xff, dev->fmt->twformat |\r\nColorFormatGamma | TW68_DMAP_EN | TW68_FIFO_EN);\r\ndev->pci_irqmask |= dev->board_virqmask;\r\ntw_setl(TW68_INTMASK, dev->pci_irqmask);\r\nreturn 0;\r\n}\r\nstatic int tw68_buffer_count(unsigned int size, unsigned int count)\r\n{\r\nunsigned int maxcount;\r\nmaxcount = (4 * 1024 * 1024) / roundup(size, PAGE_SIZE);\r\nif (count > maxcount)\r\ncount = maxcount;\r\nreturn count;\r\n}\r\nstatic int tw68_queue_setup(struct vb2_queue *q,\r\nunsigned int *num_buffers, unsigned int *num_planes,\r\nunsigned int sizes[], void *alloc_ctxs[])\r\n{\r\nstruct tw68_dev *dev = vb2_get_drv_priv(q);\r\nunsigned tot_bufs = q->num_buffers + *num_buffers;\r\nunsigned size = (dev->fmt->depth * dev->width * dev->height) >> 3;\r\nif (tot_bufs < 2)\r\ntot_bufs = 2;\r\ntot_bufs = tw68_buffer_count(size, tot_bufs);\r\n*num_buffers = tot_bufs - q->num_buffers;\r\nalloc_ctxs[0] = dev->alloc_ctx;\r\nif (*num_planes)\r\nreturn sizes[0] < size ? -EINVAL : 0;\r\n*num_planes = 1;\r\nsizes[0] = size;\r\nreturn 0;\r\n}\r\nstatic void tw68_buf_queue(struct vb2_buffer *vb)\r\n{\r\nstruct vb2_v4l2_buffer *vbuf = to_vb2_v4l2_buffer(vb);\r\nstruct vb2_queue *vq = vb->vb2_queue;\r\nstruct tw68_dev *dev = vb2_get_drv_priv(vq);\r\nstruct tw68_buf *buf = container_of(vbuf, struct tw68_buf, vb);\r\nstruct tw68_buf *prev;\r\nunsigned long flags;\r\nspin_lock_irqsave(&dev->slock, flags);\r\nbuf->jmp[0] = cpu_to_le32(RISC_JUMP);\r\nbuf->jmp[1] = cpu_to_le32(buf->dma + 8);\r\nif (!list_empty(&dev->active)) {\r\nprev = list_entry(dev->active.prev, struct tw68_buf, list);\r\nbuf->cpu[0] |= cpu_to_le32(RISC_INT_BIT);\r\nprev->jmp[1] = cpu_to_le32(buf->dma);\r\n}\r\nlist_add_tail(&buf->list, &dev->active);\r\nspin_unlock_irqrestore(&dev->slock, flags);\r\n}\r\nstatic int tw68_buf_prepare(struct vb2_buffer *vb)\r\n{\r\nstruct vb2_v4l2_buffer *vbuf = to_vb2_v4l2_buffer(vb);\r\nstruct vb2_queue *vq = vb->vb2_queue;\r\nstruct tw68_dev *dev = vb2_get_drv_priv(vq);\r\nstruct tw68_buf *buf = container_of(vbuf, struct tw68_buf, vb);\r\nstruct sg_table *dma = vb2_dma_sg_plane_desc(vb, 0);\r\nunsigned size, bpl;\r\nsize = (dev->width * dev->height * dev->fmt->depth) >> 3;\r\nif (vb2_plane_size(vb, 0) < size)\r\nreturn -EINVAL;\r\nvb2_set_plane_payload(vb, 0, size);\r\nbpl = (dev->width * dev->fmt->depth) >> 3;\r\nswitch (dev->field) {\r\ncase V4L2_FIELD_TOP:\r\ntw68_risc_buffer(dev->pci, buf, dma->sgl,\r\n0, UNSET, bpl, 0, dev->height);\r\nbreak;\r\ncase V4L2_FIELD_BOTTOM:\r\ntw68_risc_buffer(dev->pci, buf, dma->sgl,\r\nUNSET, 0, bpl, 0, dev->height);\r\nbreak;\r\ncase V4L2_FIELD_SEQ_TB:\r\ntw68_risc_buffer(dev->pci, buf, dma->sgl,\r\n0, bpl * (dev->height >> 1),\r\nbpl, 0, dev->height >> 1);\r\nbreak;\r\ncase V4L2_FIELD_SEQ_BT:\r\ntw68_risc_buffer(dev->pci, buf, dma->sgl,\r\nbpl * (dev->height >> 1), 0,\r\nbpl, 0, dev->height >> 1);\r\nbreak;\r\ncase V4L2_FIELD_INTERLACED:\r\ndefault:\r\ntw68_risc_buffer(dev->pci, buf, dma->sgl,\r\n0, bpl, bpl, bpl, dev->height >> 1);\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic void tw68_buf_finish(struct vb2_buffer *vb)\r\n{\r\nstruct vb2_v4l2_buffer *vbuf = to_vb2_v4l2_buffer(vb);\r\nstruct vb2_queue *vq = vb->vb2_queue;\r\nstruct tw68_dev *dev = vb2_get_drv_priv(vq);\r\nstruct tw68_buf *buf = container_of(vbuf, struct tw68_buf, vb);\r\npci_free_consistent(dev->pci, buf->size, buf->cpu, buf->dma);\r\n}\r\nstatic int tw68_start_streaming(struct vb2_queue *q, unsigned int count)\r\n{\r\nstruct tw68_dev *dev = vb2_get_drv_priv(q);\r\nstruct tw68_buf *buf =\r\ncontainer_of(dev->active.next, struct tw68_buf, list);\r\ndev->seqnr = 0;\r\ntw68_video_start_dma(dev, buf);\r\nreturn 0;\r\n}\r\nstatic void tw68_stop_streaming(struct vb2_queue *q)\r\n{\r\nstruct tw68_dev *dev = vb2_get_drv_priv(q);\r\ntw_clearl(TW68_DMAC, TW68_DMAP_EN | TW68_FIFO_EN);\r\nwhile (!list_empty(&dev->active)) {\r\nstruct tw68_buf *buf =\r\ncontainer_of(dev->active.next, struct tw68_buf, list);\r\nlist_del(&buf->list);\r\nvb2_buffer_done(&buf->vb.vb2_buf, VB2_BUF_STATE_ERROR);\r\n}\r\n}\r\nstatic int tw68_s_ctrl(struct v4l2_ctrl *ctrl)\r\n{\r\nstruct tw68_dev *dev =\r\ncontainer_of(ctrl->handler, struct tw68_dev, hdl);\r\nswitch (ctrl->id) {\r\ncase V4L2_CID_BRIGHTNESS:\r\ntw_writeb(TW68_BRIGHT, ctrl->val);\r\nbreak;\r\ncase V4L2_CID_HUE:\r\ntw_writeb(TW68_HUE, ctrl->val);\r\nbreak;\r\ncase V4L2_CID_CONTRAST:\r\ntw_writeb(TW68_CONTRAST, ctrl->val);\r\nbreak;\r\ncase V4L2_CID_SATURATION:\r\ntw_writeb(TW68_SAT_U, ctrl->val);\r\ntw_writeb(TW68_SAT_V, ctrl->val);\r\nbreak;\r\ncase V4L2_CID_COLOR_KILLER:\r\nif (ctrl->val)\r\ntw_andorb(TW68_MISC2, 0xe0, 0xe0);\r\nelse\r\ntw_andorb(TW68_MISC2, 0xe0, 0x00);\r\nbreak;\r\ncase V4L2_CID_CHROMA_AGC:\r\nif (ctrl->val)\r\ntw_andorb(TW68_LOOP, 0x30, 0x20);\r\nelse\r\ntw_andorb(TW68_LOOP, 0x30, 0x00);\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic int tw68_g_fmt_vid_cap(struct file *file, void *priv,\r\nstruct v4l2_format *f)\r\n{\r\nstruct tw68_dev *dev = video_drvdata(file);\r\nf->fmt.pix.width = dev->width;\r\nf->fmt.pix.height = dev->height;\r\nf->fmt.pix.field = dev->field;\r\nf->fmt.pix.pixelformat = dev->fmt->fourcc;\r\nf->fmt.pix.bytesperline =\r\n(f->fmt.pix.width * (dev->fmt->depth)) >> 3;\r\nf->fmt.pix.sizeimage =\r\nf->fmt.pix.height * f->fmt.pix.bytesperline;\r\nf->fmt.pix.colorspace = V4L2_COLORSPACE_SMPTE170M;\r\nf->fmt.pix.priv = 0;\r\nreturn 0;\r\n}\r\nstatic int tw68_try_fmt_vid_cap(struct file *file, void *priv,\r\nstruct v4l2_format *f)\r\n{\r\nstruct tw68_dev *dev = video_drvdata(file);\r\nconst struct tw68_format *fmt;\r\nenum v4l2_field field;\r\nunsigned int maxh;\r\nfmt = format_by_fourcc(f->fmt.pix.pixelformat);\r\nif (NULL == fmt)\r\nreturn -EINVAL;\r\nfield = f->fmt.pix.field;\r\nmaxh = (dev->tvnorm->id & V4L2_STD_525_60) ? 480 : 576;\r\nswitch (field) {\r\ncase V4L2_FIELD_TOP:\r\ncase V4L2_FIELD_BOTTOM:\r\nbreak;\r\ncase V4L2_FIELD_INTERLACED:\r\ncase V4L2_FIELD_SEQ_BT:\r\ncase V4L2_FIELD_SEQ_TB:\r\nmaxh = maxh * 2;\r\nbreak;\r\ndefault:\r\nfield = (f->fmt.pix.height > maxh / 2)\r\n? V4L2_FIELD_INTERLACED\r\n: V4L2_FIELD_BOTTOM;\r\nbreak;\r\n}\r\nf->fmt.pix.field = field;\r\nif (f->fmt.pix.width < 48)\r\nf->fmt.pix.width = 48;\r\nif (f->fmt.pix.height < 32)\r\nf->fmt.pix.height = 32;\r\nif (f->fmt.pix.width > 720)\r\nf->fmt.pix.width = 720;\r\nif (f->fmt.pix.height > maxh)\r\nf->fmt.pix.height = maxh;\r\nf->fmt.pix.width &= ~0x03;\r\nf->fmt.pix.bytesperline =\r\n(f->fmt.pix.width * (fmt->depth)) >> 3;\r\nf->fmt.pix.sizeimage =\r\nf->fmt.pix.height * f->fmt.pix.bytesperline;\r\nf->fmt.pix.colorspace = V4L2_COLORSPACE_SMPTE170M;\r\nreturn 0;\r\n}\r\nstatic int tw68_s_fmt_vid_cap(struct file *file, void *priv,\r\nstruct v4l2_format *f)\r\n{\r\nstruct tw68_dev *dev = video_drvdata(file);\r\nint err;\r\nerr = tw68_try_fmt_vid_cap(file, priv, f);\r\nif (0 != err)\r\nreturn err;\r\ndev->fmt = format_by_fourcc(f->fmt.pix.pixelformat);\r\ndev->width = f->fmt.pix.width;\r\ndev->height = f->fmt.pix.height;\r\ndev->field = f->fmt.pix.field;\r\nreturn 0;\r\n}\r\nstatic int tw68_enum_input(struct file *file, void *priv,\r\nstruct v4l2_input *i)\r\n{\r\nstruct tw68_dev *dev = video_drvdata(file);\r\nunsigned int n;\r\nn = i->index;\r\nif (n >= TW68_INPUT_MAX)\r\nreturn -EINVAL;\r\ni->index = n;\r\ni->type = V4L2_INPUT_TYPE_CAMERA;\r\nsnprintf(i->name, sizeof(i->name), "Composite %d", n);\r\nif (n == dev->input) {\r\nint v1 = tw_readb(TW68_STATUS1);\r\nint v2 = tw_readb(TW68_MVSN);\r\nif (0 != (v1 & (1 << 7)))\r\ni->status |= V4L2_IN_ST_NO_SYNC;\r\nif (0 != (v1 & (1 << 6)))\r\ni->status |= V4L2_IN_ST_NO_H_LOCK;\r\nif (0 != (v1 & (1 << 2)))\r\ni->status |= V4L2_IN_ST_NO_SIGNAL;\r\nif (0 != (v1 & 1 << 1))\r\ni->status |= V4L2_IN_ST_NO_COLOR;\r\nif (0 != (v2 & (1 << 2)))\r\ni->status |= V4L2_IN_ST_MACROVISION;\r\n}\r\ni->std = video_devdata(file)->tvnorms;\r\nreturn 0;\r\n}\r\nstatic int tw68_g_input(struct file *file, void *priv, unsigned int *i)\r\n{\r\nstruct tw68_dev *dev = video_drvdata(file);\r\n*i = dev->input;\r\nreturn 0;\r\n}\r\nstatic int tw68_s_input(struct file *file, void *priv, unsigned int i)\r\n{\r\nstruct tw68_dev *dev = video_drvdata(file);\r\nif (i >= TW68_INPUT_MAX)\r\nreturn -EINVAL;\r\ndev->input = i;\r\ntw_andorb(TW68_INFORM, 0x03 << 2, dev->input << 2);\r\nreturn 0;\r\n}\r\nstatic int tw68_querycap(struct file *file, void *priv,\r\nstruct v4l2_capability *cap)\r\n{\r\nstruct tw68_dev *dev = video_drvdata(file);\r\nstrcpy(cap->driver, "tw68");\r\nstrlcpy(cap->card, "Techwell Capture Card",\r\nsizeof(cap->card));\r\nsprintf(cap->bus_info, "PCI:%s", pci_name(dev->pci));\r\ncap->device_caps =\r\nV4L2_CAP_VIDEO_CAPTURE |\r\nV4L2_CAP_READWRITE |\r\nV4L2_CAP_STREAMING;\r\ncap->capabilities = cap->device_caps | V4L2_CAP_DEVICE_CAPS;\r\nreturn 0;\r\n}\r\nstatic int tw68_s_std(struct file *file, void *priv, v4l2_std_id id)\r\n{\r\nstruct tw68_dev *dev = video_drvdata(file);\r\nunsigned int i;\r\nif (vb2_is_busy(&dev->vidq))\r\nreturn -EBUSY;\r\nfor (i = 0; i < TVNORMS; i++) {\r\nif (id == tvnorms[i].id)\r\nbreak;\r\n}\r\nif (i == TVNORMS) {\r\nfor (i = 0; i < TVNORMS; i++)\r\nif (id & tvnorms[i].id)\r\nbreak;\r\n}\r\nif (i == TVNORMS)\r\nreturn -EINVAL;\r\nset_tvnorm(dev, &tvnorms[i]);\r\nreturn 0;\r\n}\r\nstatic int tw68_g_std(struct file *file, void *priv, v4l2_std_id *id)\r\n{\r\nstruct tw68_dev *dev = video_drvdata(file);\r\n*id = dev->tvnorm->id;\r\nreturn 0;\r\n}\r\nstatic int tw68_enum_fmt_vid_cap(struct file *file, void *priv,\r\nstruct v4l2_fmtdesc *f)\r\n{\r\nif (f->index >= FORMATS)\r\nreturn -EINVAL;\r\nstrlcpy(f->description, formats[f->index].name,\r\nsizeof(f->description));\r\nf->pixelformat = formats[f->index].fourcc;\r\nreturn 0;\r\n}\r\nstatic void tw68_dump_regs(struct tw68_dev *dev)\r\n{\r\nunsigned char line[80];\r\nint i, j, k;\r\nunsigned char *cptr;\r\npr_info("Full dump of TW68 registers:\n");\r\nfor (i = 0; i < 0x100; i += 32) {\r\ncptr = line;\r\ncptr += sprintf(cptr, "%03x ", i);\r\nfor (j = i; j < i + 16; j += 4)\r\ncptr += sprintf(cptr, "%08x ", tw_readl(j));\r\n*cptr++ = ' ';\r\nfor (; j < i + 32; j += 4)\r\ncptr += sprintf(cptr, "%08x ", tw_readl(j));\r\n*cptr++ = '\n';\r\n*cptr = 0;\r\npr_info("%s", line);\r\n}\r\nwhile (i < 0x400) {\r\ncptr = line;\r\ncptr += sprintf(cptr, "%03x ", i);\r\nfor (j = 0; j < 4; j++) {\r\nfor (k = 0; k < 4; k++) {\r\ncptr += sprintf(cptr, "%02x ",\r\ntw_readb(i));\r\ni += 4;\r\n}\r\n*cptr++ = ' ';\r\n}\r\n*cptr++ = '\n';\r\n*cptr = 0;\r\npr_info("%s", line);\r\n}\r\n}\r\nstatic int vidioc_log_status(struct file *file, void *priv)\r\n{\r\nstruct tw68_dev *dev = video_drvdata(file);\r\ntw68_dump_regs(dev);\r\nreturn v4l2_ctrl_log_status(file, priv);\r\n}\r\nstatic int vidioc_g_register(struct file *file, void *priv,\r\nstruct v4l2_dbg_register *reg)\r\n{\r\nstruct tw68_dev *dev = video_drvdata(file);\r\nif (reg->size == 1)\r\nreg->val = tw_readb(reg->reg);\r\nelse\r\nreg->val = tw_readl(reg->reg);\r\nreturn 0;\r\n}\r\nstatic int vidioc_s_register(struct file *file, void *priv,\r\nconst struct v4l2_dbg_register *reg)\r\n{\r\nstruct tw68_dev *dev = video_drvdata(file);\r\nif (reg->size == 1)\r\ntw_writeb(reg->reg, reg->val);\r\nelse\r\ntw_writel(reg->reg & 0xffff, reg->val);\r\nreturn 0;\r\n}\r\nvoid tw68_set_tvnorm_hw(struct tw68_dev *dev)\r\n{\r\ntw_andorb(TW68_SDT, 0x07, dev->tvnorm->format);\r\n}\r\nint tw68_video_init1(struct tw68_dev *dev)\r\n{\r\nstruct v4l2_ctrl_handler *hdl = &dev->hdl;\r\nv4l2_ctrl_handler_init(hdl, 6);\r\nv4l2_ctrl_new_std(hdl, &tw68_ctrl_ops,\r\nV4L2_CID_BRIGHTNESS, -128, 127, 1, 20);\r\nv4l2_ctrl_new_std(hdl, &tw68_ctrl_ops,\r\nV4L2_CID_CONTRAST, 0, 255, 1, 100);\r\nv4l2_ctrl_new_std(hdl, &tw68_ctrl_ops,\r\nV4L2_CID_SATURATION, 0, 255, 1, 128);\r\nv4l2_ctrl_new_std(hdl, &tw68_ctrl_ops,\r\nV4L2_CID_HUE, -128, 127, 1, 0);\r\nv4l2_ctrl_new_std(hdl, &tw68_ctrl_ops,\r\nV4L2_CID_COLOR_KILLER, 0, 1, 1, 0);\r\nv4l2_ctrl_new_std(hdl, &tw68_ctrl_ops,\r\nV4L2_CID_CHROMA_AGC, 0, 1, 1, 1);\r\nif (hdl->error) {\r\nv4l2_ctrl_handler_free(hdl);\r\nreturn hdl->error;\r\n}\r\ndev->v4l2_dev.ctrl_handler = hdl;\r\nv4l2_ctrl_handler_setup(hdl);\r\nreturn 0;\r\n}\r\nint tw68_video_init2(struct tw68_dev *dev, int video_nr)\r\n{\r\nint ret;\r\nset_tvnorm(dev, &tvnorms[0]);\r\ndev->fmt = format_by_fourcc(V4L2_PIX_FMT_BGR24);\r\ndev->width = 720;\r\ndev->height = 576;\r\ndev->field = V4L2_FIELD_INTERLACED;\r\nINIT_LIST_HEAD(&dev->active);\r\ndev->vidq.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;\r\ndev->vidq.timestamp_flags = V4L2_BUF_FLAG_TIMESTAMP_MONOTONIC;\r\ndev->vidq.io_modes = VB2_MMAP | VB2_USERPTR | VB2_READ | VB2_DMABUF;\r\ndev->vidq.ops = &tw68_video_qops;\r\ndev->vidq.mem_ops = &vb2_dma_sg_memops;\r\ndev->vidq.drv_priv = dev;\r\ndev->vidq.gfp_flags = __GFP_DMA32 | __GFP_KSWAPD_RECLAIM;\r\ndev->vidq.buf_struct_size = sizeof(struct tw68_buf);\r\ndev->vidq.lock = &dev->lock;\r\ndev->vidq.min_buffers_needed = 2;\r\nret = vb2_queue_init(&dev->vidq);\r\nif (ret)\r\nreturn ret;\r\ndev->vdev = tw68_video_template;\r\ndev->vdev.v4l2_dev = &dev->v4l2_dev;\r\ndev->vdev.lock = &dev->lock;\r\ndev->vdev.queue = &dev->vidq;\r\nvideo_set_drvdata(&dev->vdev, dev);\r\nreturn video_register_device(&dev->vdev, VFL_TYPE_GRABBER, video_nr);\r\n}\r\nvoid tw68_irq_video_done(struct tw68_dev *dev, unsigned long status)\r\n{\r\n__u32 reg;\r\ntw_writel(TW68_INTSTAT, status);\r\nif (status & TW68_DMAPI) {\r\nstruct tw68_buf *buf;\r\nspin_lock(&dev->slock);\r\nbuf = list_entry(dev->active.next, struct tw68_buf, list);\r\nlist_del(&buf->list);\r\nspin_unlock(&dev->slock);\r\nbuf->vb.vb2_buf.timestamp = ktime_get_ns();\r\nbuf->vb.field = dev->field;\r\nbuf->vb.sequence = dev->seqnr++;\r\nvb2_buffer_done(&buf->vb.vb2_buf, VB2_BUF_STATE_DONE);\r\nstatus &= ~(TW68_DMAPI);\r\nif (0 == status)\r\nreturn;\r\n}\r\nif (status & (TW68_VLOCK | TW68_HLOCK))\r\ndev_dbg(&dev->pci->dev, "Lost sync\n");\r\nif (status & TW68_PABORT)\r\ndev_err(&dev->pci->dev, "PABORT interrupt\n");\r\nif (status & TW68_DMAPERR)\r\ndev_err(&dev->pci->dev, "DMAPERR interrupt\n");\r\nif (status & TW68_FDMIS)\r\ndev_dbg(&dev->pci->dev, "FDMIS interrupt\n");\r\nif (status & TW68_FFOF) {\r\nreg = tw_readl(TW68_DMAC) & TW68_FIFO_EN;\r\ntw_clearl(TW68_DMAC, TW68_FIFO_EN);\r\ndev_dbg(&dev->pci->dev, "FFOF interrupt\n");\r\ntw_setl(TW68_DMAC, reg);\r\n}\r\nif (status & TW68_FFERR)\r\ndev_dbg(&dev->pci->dev, "FFERR interrupt\n");\r\n}
