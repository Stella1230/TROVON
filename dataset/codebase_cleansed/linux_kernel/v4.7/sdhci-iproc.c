static inline u32 sdhci_iproc_readl(struct sdhci_host *host, int reg)\r\n{\r\nu32 val = readl(host->ioaddr + reg);\r\npr_debug("%s: readl [0x%02x] 0x%08x\n",\r\nmmc_hostname(host->mmc), reg, val);\r\nreturn val;\r\n}\r\nstatic u16 sdhci_iproc_readw(struct sdhci_host *host, int reg)\r\n{\r\nu32 val = sdhci_iproc_readl(host, (reg & ~3));\r\nu16 word = val >> REG_OFFSET_IN_BITS(reg) & 0xffff;\r\nreturn word;\r\n}\r\nstatic u8 sdhci_iproc_readb(struct sdhci_host *host, int reg)\r\n{\r\nu32 val = sdhci_iproc_readl(host, (reg & ~3));\r\nu8 byte = val >> REG_OFFSET_IN_BITS(reg) & 0xff;\r\nreturn byte;\r\n}\r\nstatic inline void sdhci_iproc_writel(struct sdhci_host *host, u32 val, int reg)\r\n{\r\npr_debug("%s: writel [0x%02x] 0x%08x\n",\r\nmmc_hostname(host->mmc), reg, val);\r\nwritel(val, host->ioaddr + reg);\r\nif (host->clock <= 400000) {\r\nif (host->clock)\r\nudelay((4 * 1000000 + host->clock - 1) / host->clock);\r\nelse\r\nudelay(10);\r\n}\r\n}\r\nstatic void sdhci_iproc_writew(struct sdhci_host *host, u16 val, int reg)\r\n{\r\nstruct sdhci_pltfm_host *pltfm_host = sdhci_priv(host);\r\nstruct sdhci_iproc_host *iproc_host = sdhci_pltfm_priv(pltfm_host);\r\nu32 word_shift = REG_OFFSET_IN_BITS(reg);\r\nu32 mask = 0xffff << word_shift;\r\nu32 oldval, newval;\r\nif (reg == SDHCI_COMMAND) {\r\nif (iproc_host->shadow_blk != 0) {\r\nsdhci_iproc_writel(host, iproc_host->shadow_blk,\r\nSDHCI_BLOCK_SIZE);\r\niproc_host->shadow_blk = 0;\r\n}\r\noldval = iproc_host->shadow_cmd;\r\n} else if (reg == SDHCI_BLOCK_SIZE || reg == SDHCI_BLOCK_COUNT) {\r\noldval = iproc_host->shadow_blk;\r\n} else {\r\noldval = sdhci_iproc_readl(host, (reg & ~3));\r\n}\r\nnewval = (oldval & ~mask) | (val << word_shift);\r\nif (reg == SDHCI_TRANSFER_MODE) {\r\niproc_host->shadow_cmd = newval;\r\n} else if (reg == SDHCI_BLOCK_SIZE || reg == SDHCI_BLOCK_COUNT) {\r\niproc_host->shadow_blk = newval;\r\n} else {\r\nsdhci_iproc_writel(host, newval, reg & ~3);\r\n}\r\n}\r\nstatic void sdhci_iproc_writeb(struct sdhci_host *host, u8 val, int reg)\r\n{\r\nu32 oldval = sdhci_iproc_readl(host, (reg & ~3));\r\nu32 byte_shift = REG_OFFSET_IN_BITS(reg);\r\nu32 mask = 0xff << byte_shift;\r\nu32 newval = (oldval & ~mask) | (val << byte_shift);\r\nsdhci_iproc_writel(host, newval, reg & ~3);\r\n}\r\nstatic int sdhci_iproc_probe(struct platform_device *pdev)\r\n{\r\nconst struct of_device_id *match;\r\nconst struct sdhci_iproc_data *iproc_data;\r\nstruct sdhci_host *host;\r\nstruct sdhci_iproc_host *iproc_host;\r\nstruct sdhci_pltfm_host *pltfm_host;\r\nint ret;\r\nmatch = of_match_device(sdhci_iproc_of_match, &pdev->dev);\r\nif (!match)\r\nreturn -EINVAL;\r\niproc_data = match->data;\r\nhost = sdhci_pltfm_init(pdev, iproc_data->pdata, sizeof(*iproc_host));\r\nif (IS_ERR(host))\r\nreturn PTR_ERR(host);\r\npltfm_host = sdhci_priv(host);\r\niproc_host = sdhci_pltfm_priv(pltfm_host);\r\niproc_host->data = iproc_data;\r\nmmc_of_parse(host->mmc);\r\nsdhci_get_of_property(pdev);\r\nhost->mmc->caps |= iproc_host->data->mmc_caps;\r\npltfm_host->clk = devm_clk_get(&pdev->dev, NULL);\r\nif (IS_ERR(pltfm_host->clk)) {\r\nret = PTR_ERR(pltfm_host->clk);\r\ngoto err;\r\n}\r\nret = clk_prepare_enable(pltfm_host->clk);\r\nif (ret) {\r\ndev_err(&pdev->dev, "failed to enable host clk\n");\r\ngoto err;\r\n}\r\nif (iproc_host->data->pdata->quirks & SDHCI_QUIRK_MISSING_CAPS) {\r\nhost->caps = iproc_host->data->caps;\r\nhost->caps1 = iproc_host->data->caps1;\r\n}\r\nret = sdhci_add_host(host);\r\nif (ret)\r\ngoto err_clk;\r\nreturn 0;\r\nerr_clk:\r\nclk_disable_unprepare(pltfm_host->clk);\r\nerr:\r\nsdhci_pltfm_free(pdev);\r\nreturn ret;\r\n}
