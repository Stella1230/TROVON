static __be32 rpfilter_get_saddr(__be32 addr)\r\n{\r\nif (ipv4_is_multicast(addr) || ipv4_is_lbcast(addr) ||\r\nipv4_is_zeronet(addr))\r\nreturn 0;\r\nreturn addr;\r\n}\r\nstatic bool rpfilter_lookup_reverse(struct net *net, struct flowi4 *fl4,\r\nconst struct net_device *dev, u8 flags)\r\n{\r\nstruct fib_result res;\r\nbool dev_match;\r\nint ret __maybe_unused;\r\nif (fib_lookup(net, fl4, &res, FIB_LOOKUP_IGNORE_LINKSTATE))\r\nreturn false;\r\nif (res.type != RTN_UNICAST) {\r\nif (res.type != RTN_LOCAL || !(flags & XT_RPFILTER_ACCEPT_LOCAL))\r\nreturn false;\r\n}\r\ndev_match = false;\r\n#ifdef CONFIG_IP_ROUTE_MULTIPATH\r\nfor (ret = 0; ret < res.fi->fib_nhs; ret++) {\r\nstruct fib_nh *nh = &res.fi->fib_nh[ret];\r\nif (nh->nh_dev == dev) {\r\ndev_match = true;\r\nbreak;\r\n}\r\n}\r\n#else\r\nif (FIB_RES_DEV(res) == dev)\r\ndev_match = true;\r\n#endif\r\nreturn dev_match || flags & XT_RPFILTER_LOOSE;\r\n}\r\nstatic bool rpfilter_is_local(const struct sk_buff *skb)\r\n{\r\nconst struct rtable *rt = skb_rtable(skb);\r\nreturn rt && (rt->rt_flags & RTCF_LOCAL);\r\n}\r\nstatic bool rpfilter_mt(const struct sk_buff *skb, struct xt_action_param *par)\r\n{\r\nconst struct xt_rpfilter_info *info;\r\nconst struct iphdr *iph;\r\nstruct flowi4 flow;\r\nbool invert;\r\ninfo = par->matchinfo;\r\ninvert = info->flags & XT_RPFILTER_INVERT;\r\nif (rpfilter_is_local(skb))\r\nreturn true ^ invert;\r\niph = ip_hdr(skb);\r\nif (ipv4_is_multicast(iph->daddr)) {\r\nif (ipv4_is_zeronet(iph->saddr))\r\nreturn ipv4_is_local_multicast(iph->daddr) ^ invert;\r\n}\r\nflow.flowi4_iif = LOOPBACK_IFINDEX;\r\nflow.daddr = iph->saddr;\r\nflow.saddr = rpfilter_get_saddr(iph->daddr);\r\nflow.flowi4_oif = 0;\r\nflow.flowi4_mark = info->flags & XT_RPFILTER_VALID_MARK ? skb->mark : 0;\r\nflow.flowi4_tos = RT_TOS(iph->tos);\r\nflow.flowi4_scope = RT_SCOPE_UNIVERSE;\r\nreturn rpfilter_lookup_reverse(par->net, &flow, par->in, info->flags) ^ invert;\r\n}\r\nstatic int rpfilter_check(const struct xt_mtchk_param *par)\r\n{\r\nconst struct xt_rpfilter_info *info = par->matchinfo;\r\nunsigned int options = ~XT_RPFILTER_OPTION_MASK;\r\nif (info->flags & options) {\r\npr_info("unknown options encountered");\r\nreturn -EINVAL;\r\n}\r\nif (strcmp(par->table, "mangle") != 0 &&\r\nstrcmp(par->table, "raw") != 0) {\r\npr_info("match only valid in the \'raw\' "\r\n"or \'mangle\' tables, not \'%s\'.\n", par->table);\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int __init rpfilter_mt_init(void)\r\n{\r\nreturn xt_register_match(&rpfilter_mt_reg);\r\n}\r\nstatic void __exit rpfilter_mt_exit(void)\r\n{\r\nxt_unregister_match(&rpfilter_mt_reg);\r\n}
