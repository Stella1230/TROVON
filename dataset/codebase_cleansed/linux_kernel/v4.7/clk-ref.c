static int clk_ref_enable(struct clk_hw *hw)\r\n{\r\nstruct clk_ref *ref = to_clk_ref(hw);\r\nwritel_relaxed(1 << ((ref->idx + 1) * 8 - 1), ref->reg + CLR);\r\nreturn 0;\r\n}\r\nstatic void clk_ref_disable(struct clk_hw *hw)\r\n{\r\nstruct clk_ref *ref = to_clk_ref(hw);\r\nwritel_relaxed(1 << ((ref->idx + 1) * 8 - 1), ref->reg + SET);\r\n}\r\nstatic unsigned long clk_ref_recalc_rate(struct clk_hw *hw,\r\nunsigned long parent_rate)\r\n{\r\nstruct clk_ref *ref = to_clk_ref(hw);\r\nu64 tmp = parent_rate;\r\nu8 frac = (readl_relaxed(ref->reg) >> (ref->idx * 8)) & 0x3f;\r\ntmp *= 18;\r\ndo_div(tmp, frac);\r\nreturn tmp;\r\n}\r\nstatic long clk_ref_round_rate(struct clk_hw *hw, unsigned long rate,\r\nunsigned long *prate)\r\n{\r\nunsigned long parent_rate = *prate;\r\nu64 tmp = parent_rate;\r\nu8 frac;\r\ntmp = tmp * 18 + rate / 2;\r\ndo_div(tmp, rate);\r\nfrac = tmp;\r\nif (frac < 18)\r\nfrac = 18;\r\nelse if (frac > 35)\r\nfrac = 35;\r\ntmp = parent_rate;\r\ntmp *= 18;\r\ndo_div(tmp, frac);\r\nreturn tmp;\r\n}\r\nstatic int clk_ref_set_rate(struct clk_hw *hw, unsigned long rate,\r\nunsigned long parent_rate)\r\n{\r\nstruct clk_ref *ref = to_clk_ref(hw);\r\nunsigned long flags;\r\nu64 tmp = parent_rate;\r\nu32 val;\r\nu8 frac, shift = ref->idx * 8;\r\ntmp = tmp * 18 + rate / 2;\r\ndo_div(tmp, rate);\r\nfrac = tmp;\r\nif (frac < 18)\r\nfrac = 18;\r\nelse if (frac > 35)\r\nfrac = 35;\r\nspin_lock_irqsave(&mxs_lock, flags);\r\nval = readl_relaxed(ref->reg);\r\nval &= ~(0x3f << shift);\r\nval |= frac << shift;\r\nwritel_relaxed(val, ref->reg);\r\nspin_unlock_irqrestore(&mxs_lock, flags);\r\nreturn 0;\r\n}\r\nstruct clk *mxs_clk_ref(const char *name, const char *parent_name,\r\nvoid __iomem *reg, u8 idx)\r\n{\r\nstruct clk_ref *ref;\r\nstruct clk *clk;\r\nstruct clk_init_data init;\r\nref = kzalloc(sizeof(*ref), GFP_KERNEL);\r\nif (!ref)\r\nreturn ERR_PTR(-ENOMEM);\r\ninit.name = name;\r\ninit.ops = &clk_ref_ops;\r\ninit.flags = 0;\r\ninit.parent_names = (parent_name ? &parent_name: NULL);\r\ninit.num_parents = (parent_name ? 1 : 0);\r\nref->reg = reg;\r\nref->idx = idx;\r\nref->hw.init = &init;\r\nclk = clk_register(NULL, &ref->hw);\r\nif (IS_ERR(clk))\r\nkfree(ref);\r\nreturn clk;\r\n}
