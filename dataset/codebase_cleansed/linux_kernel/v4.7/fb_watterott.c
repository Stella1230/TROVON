static void write_reg8_bus8(struct fbtft_par *par, int len, ...)\r\n{\r\nva_list args;\r\nint i, ret;\r\nu8 *buf = par->buf;\r\nva_start(args, len);\r\nfor (i = 0; i < len; i++)\r\n*buf++ = (u8)va_arg(args, unsigned int);\r\nva_end(args);\r\nfbtft_par_dbg_hex(DEBUG_WRITE_REGISTER, par,\r\npar->info->device, u8, par->buf, len, "%s: ", __func__);\r\nret = par->fbtftops.write(par, par->buf, len);\r\nif (ret < 0) {\r\ndev_err(par->info->device,\r\n"write() failed and returned %d\n", ret);\r\nreturn;\r\n}\r\n}\r\nstatic int write_vmem(struct fbtft_par *par, size_t offset, size_t len)\r\n{\r\nunsigned start_line, end_line;\r\nu16 *vmem16 = (u16 *)(par->info->screen_buffer + offset);\r\nu16 *pos = par->txbuf.buf + 1;\r\nu16 *buf16 = par->txbuf.buf + 10;\r\nint i, j;\r\nint ret = 0;\r\nstart_line = offset / par->info->fix.line_length;\r\nend_line = start_line + (len / par->info->fix.line_length) - 1;\r\n((u8 *)par->txbuf.buf)[0] = CMD_LCD_DRAWIMAGE;\r\npos[0] = 0;\r\npos[2] = cpu_to_be16(par->info->var.xres);\r\npos[3] = cpu_to_be16(1);\r\n((u8 *)par->txbuf.buf)[9] = COLOR_RGB565;\r\nfor (i = start_line; i <= end_line; i++) {\r\npos[1] = cpu_to_be16(i);\r\nfor (j = 0; j < par->info->var.xres; j++)\r\nbuf16[j] = cpu_to_be16(*vmem16++);\r\nret = par->fbtftops.write(par,\r\npar->txbuf.buf, 10 + par->info->fix.line_length);\r\nif (ret < 0)\r\nreturn ret;\r\nudelay(300);\r\n}\r\nreturn 0;\r\n}\r\nstatic int write_vmem_8bit(struct fbtft_par *par, size_t offset, size_t len)\r\n{\r\nunsigned start_line, end_line;\r\nu16 *vmem16 = (u16 *)(par->info->screen_buffer + offset);\r\nu16 *pos = par->txbuf.buf + 1;\r\nu8 *buf8 = par->txbuf.buf + 10;\r\nint i, j;\r\nint ret = 0;\r\nstart_line = offset / par->info->fix.line_length;\r\nend_line = start_line + (len / par->info->fix.line_length) - 1;\r\n((u8 *)par->txbuf.buf)[0] = CMD_LCD_DRAWIMAGE;\r\npos[0] = 0;\r\npos[2] = cpu_to_be16(par->info->var.xres);\r\npos[3] = cpu_to_be16(1);\r\n((u8 *)par->txbuf.buf)[9] = COLOR_RGB332;\r\nfor (i = start_line; i <= end_line; i++) {\r\npos[1] = cpu_to_be16(i);\r\nfor (j = 0; j < par->info->var.xres; j++) {\r\nbuf8[j] = RGB565toRGB332(*vmem16);\r\nvmem16++;\r\n}\r\nret = par->fbtftops.write(par,\r\npar->txbuf.buf, 10 + par->info->var.xres);\r\nif (ret < 0)\r\nreturn ret;\r\nudelay(700);\r\n}\r\nreturn 0;\r\n}\r\nstatic unsigned firmware_version(struct fbtft_par *par)\r\n{\r\nu8 rxbuf[4] = {0, };\r\nwrite_reg(par, CMD_VERSION);\r\npar->fbtftops.read(par, rxbuf, 4);\r\nif (rxbuf[1] != '.')\r\nreturn 0;\r\nreturn (rxbuf[0] - '0') << 8 | (rxbuf[2] - '0') << 4 | (rxbuf[3] - '0');\r\n}\r\nstatic int init_display(struct fbtft_par *par)\r\n{\r\nint ret;\r\nunsigned version;\r\nu8 save_mode;\r\nsave_mode = par->spi->mode;\r\npar->spi->mode |= SPI_CS_HIGH;\r\nret = spi_setup(par->spi);\r\nif (ret) {\r\ndev_err(par->info->device, "Could not set SPI_CS_HIGH\n");\r\nreturn ret;\r\n}\r\nwrite_reg(par, 0x00);\r\nmdelay(50);\r\npar->fbtftops.reset(par);\r\nmdelay(1000);\r\npar->spi->mode = save_mode;\r\nret = spi_setup(par->spi);\r\nif (ret) {\r\ndev_err(par->info->device, "Could not restore SPI mode\n");\r\nreturn ret;\r\n}\r\nwrite_reg(par, 0x00);\r\nversion = firmware_version(par);\r\nfbtft_par_dbg(DEBUG_INIT_DISPLAY, par, "Firmware version: %x.%02x\n",\r\nversion >> 8, version & 0xFF);\r\nif (mode == 332)\r\npar->fbtftops.write_vmem = write_vmem_8bit;\r\nreturn 0;\r\n}\r\nstatic void set_addr_win(struct fbtft_par *par, int xs, int ys, int xe, int ye)\r\n{\r\n}\r\nstatic int set_var(struct fbtft_par *par)\r\n{\r\nu8 rotate;\r\nswitch (par->info->var.rotate) {\r\ncase 90:\r\nrotate = 27;\r\nbreak;\r\ncase 180:\r\nrotate = 18;\r\nbreak;\r\ncase 270:\r\nrotate = 9;\r\nbreak;\r\ndefault:\r\nrotate = 0;\r\n}\r\nwrite_reg(par, CMD_LCD_ORIENTATION, rotate);\r\nreturn 0;\r\n}\r\nstatic int verify_gpios(struct fbtft_par *par)\r\n{\r\nif (par->gpio.reset < 0) {\r\ndev_err(par->info->device, "Missing 'reset' gpio. Aborting.\n");\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int backlight_chip_update_status(struct backlight_device *bd)\r\n{\r\nstruct fbtft_par *par = bl_get_data(bd);\r\nint brightness = bd->props.brightness;\r\nfbtft_par_dbg(DEBUG_BACKLIGHT, par,\r\n"%s: brightness=%d, power=%d, fb_blank=%d\n",\r\n__func__, bd->props.brightness, bd->props.power,\r\nbd->props.fb_blank);\r\nif (bd->props.power != FB_BLANK_UNBLANK)\r\nbrightness = 0;\r\nif (bd->props.fb_blank != FB_BLANK_UNBLANK)\r\nbrightness = 0;\r\nwrite_reg(par, CMD_LCD_LED, brightness);\r\nreturn 0;\r\n}\r\nstatic void register_chip_backlight(struct fbtft_par *par)\r\n{\r\nstruct backlight_device *bd;\r\nstruct backlight_properties bl_props = { 0, };\r\nbl_props.type = BACKLIGHT_RAW;\r\nbl_props.power = FB_BLANK_POWERDOWN;\r\nbl_props.max_brightness = 100;\r\nbl_props.brightness = DEFAULT_BRIGHTNESS;\r\nbd = backlight_device_register(dev_driver_string(par->info->device),\r\npar->info->device, par, &bl_ops, &bl_props);\r\nif (IS_ERR(bd)) {\r\ndev_err(par->info->device,\r\n"cannot register backlight device (%ld)\n",\r\nPTR_ERR(bd));\r\nreturn;\r\n}\r\npar->info->bl_dev = bd;\r\nif (!par->fbtftops.unregister_backlight)\r\npar->fbtftops.unregister_backlight = fbtft_unregister_backlight;\r\n}
