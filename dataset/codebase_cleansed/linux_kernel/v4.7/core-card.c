int fw_compute_block_crc(__be32 *block)\r\n{\r\nint length;\r\nu16 crc;\r\nlength = (be32_to_cpu(block[0]) >> 16) & 0xff;\r\ncrc = crc_itu_t(0, (u8 *)&block[1], length * 4);\r\n*block |= cpu_to_be32(crc);\r\nreturn length;\r\n}\r\nstatic void generate_config_rom(struct fw_card *card, __be32 *config_rom)\r\n{\r\nstruct fw_descriptor *desc;\r\nint i, j, k, length;\r\nconfig_rom[0] = cpu_to_be32(\r\nBIB_CRC_LENGTH(4) | BIB_INFO_LENGTH(4) | BIB_CRC(0));\r\nconfig_rom[1] = cpu_to_be32(BIB_BUS_NAME);\r\nconfig_rom[2] = cpu_to_be32(\r\nBIB_LINK_SPEED(card->link_speed) |\r\nBIB_GENERATION(card->config_rom_generation++ % 14 + 2) |\r\nBIB_MAX_ROM(2) |\r\nBIB_MAX_RECEIVE(card->max_receive) |\r\nBIB_BMC | BIB_ISC | BIB_CMC | BIB_IRMC);\r\nconfig_rom[3] = cpu_to_be32(card->guid >> 32);\r\nconfig_rom[4] = cpu_to_be32(card->guid);\r\nconfig_rom[6] = cpu_to_be32(NODE_CAPABILITIES);\r\ni = 7;\r\nj = 7 + descriptor_count;\r\nlist_for_each_entry (desc, &descriptor_list, link) {\r\nif (desc->immediate > 0)\r\nconfig_rom[i++] = cpu_to_be32(desc->immediate);\r\nconfig_rom[i] = cpu_to_be32(desc->key | (j - i));\r\ni++;\r\nj += desc->length;\r\n}\r\nconfig_rom[5] = cpu_to_be32((i - 5 - 1) << 16);\r\nlist_for_each_entry (desc, &descriptor_list, link) {\r\nfor (k = 0; k < desc->length; k++)\r\nconfig_rom[i + k] = cpu_to_be32(desc->data[k]);\r\ni += desc->length;\r\n}\r\nfor (i = 0; i < j; i += length + 1)\r\nlength = fw_compute_block_crc(config_rom + i);\r\nWARN_ON(j != config_rom_length);\r\n}\r\nstatic void update_config_roms(void)\r\n{\r\nstruct fw_card *card;\r\nlist_for_each_entry (card, &card_list, link) {\r\ngenerate_config_rom(card, tmp_config_rom);\r\ncard->driver->set_config_rom(card, tmp_config_rom,\r\nconfig_rom_length);\r\n}\r\n}\r\nstatic size_t required_space(struct fw_descriptor *desc)\r\n{\r\nreturn desc->length + 1 + (desc->immediate > 0 ? 1 : 0);\r\n}\r\nint fw_core_add_descriptor(struct fw_descriptor *desc)\r\n{\r\nsize_t i;\r\nint ret;\r\ni = 0;\r\nwhile (i < desc->length)\r\ni += (desc->data[i] >> 16) + 1;\r\nif (i != desc->length)\r\nreturn -EINVAL;\r\nmutex_lock(&card_mutex);\r\nif (config_rom_length + required_space(desc) > 256) {\r\nret = -EBUSY;\r\n} else {\r\nlist_add_tail(&desc->link, &descriptor_list);\r\nconfig_rom_length += required_space(desc);\r\ndescriptor_count++;\r\nif (desc->immediate > 0)\r\ndescriptor_count++;\r\nupdate_config_roms();\r\nret = 0;\r\n}\r\nmutex_unlock(&card_mutex);\r\nreturn ret;\r\n}\r\nvoid fw_core_remove_descriptor(struct fw_descriptor *desc)\r\n{\r\nmutex_lock(&card_mutex);\r\nlist_del(&desc->link);\r\nconfig_rom_length -= required_space(desc);\r\ndescriptor_count--;\r\nif (desc->immediate > 0)\r\ndescriptor_count--;\r\nupdate_config_roms();\r\nmutex_unlock(&card_mutex);\r\n}\r\nstatic int reset_bus(struct fw_card *card, bool short_reset)\r\n{\r\nint reg = short_reset ? 5 : 1;\r\nint bit = short_reset ? PHY_BUS_SHORT_RESET : PHY_BUS_RESET;\r\nreturn card->driver->update_phy_reg(card, reg, 0, bit);\r\n}\r\nvoid fw_schedule_bus_reset(struct fw_card *card, bool delayed, bool short_reset)\r\n{\r\ncard->br_short = short_reset;\r\nfw_card_get(card);\r\nif (!queue_delayed_work(fw_workqueue, &card->br_work,\r\ndelayed ? DIV_ROUND_UP(HZ, 100) : 0))\r\nfw_card_put(card);\r\n}\r\nstatic void br_work(struct work_struct *work)\r\n{\r\nstruct fw_card *card = container_of(work, struct fw_card, br_work.work);\r\nif (card->reset_jiffies != 0 &&\r\ntime_before64(get_jiffies_64(), card->reset_jiffies + 2 * HZ)) {\r\nif (!queue_delayed_work(fw_workqueue, &card->br_work, 2 * HZ))\r\nfw_card_put(card);\r\nreturn;\r\n}\r\nfw_send_phy_config(card, FW_PHY_CONFIG_NO_NODE_ID, card->generation,\r\nFW_PHY_CONFIG_CURRENT_GAP_COUNT);\r\nreset_bus(card, card->br_short);\r\nfw_card_put(card);\r\n}\r\nstatic void allocate_broadcast_channel(struct fw_card *card, int generation)\r\n{\r\nint channel, bandwidth = 0;\r\nif (!card->broadcast_channel_allocated) {\r\nfw_iso_resource_manage(card, generation, 1ULL << 31,\r\n&channel, &bandwidth, true);\r\nif (channel != 31) {\r\nfw_notice(card, "failed to allocate broadcast channel\n");\r\nreturn;\r\n}\r\ncard->broadcast_channel_allocated = true;\r\n}\r\ndevice_for_each_child(card->device, (void *)(long)generation,\r\nfw_device_set_broadcast_channel);\r\n}\r\nvoid fw_schedule_bm_work(struct fw_card *card, unsigned long delay)\r\n{\r\nfw_card_get(card);\r\nif (!schedule_delayed_work(&card->bm_work, delay))\r\nfw_card_put(card);\r\n}\r\nstatic void bm_work(struct work_struct *work)\r\n{\r\nstruct fw_card *card = container_of(work, struct fw_card, bm_work.work);\r\nstruct fw_device *root_device, *irm_device;\r\nstruct fw_node *root_node;\r\nint root_id, new_root_id, irm_id, bm_id, local_id;\r\nint gap_count, generation, grace, rcode;\r\nbool do_reset = false;\r\nbool root_device_is_running;\r\nbool root_device_is_cmc;\r\nbool irm_is_1394_1995_only;\r\nbool keep_this_irm;\r\n__be32 transaction_data[2];\r\nspin_lock_irq(&card->lock);\r\nif (card->local_node == NULL) {\r\nspin_unlock_irq(&card->lock);\r\ngoto out_put_card;\r\n}\r\ngeneration = card->generation;\r\nroot_node = card->root_node;\r\nfw_node_get(root_node);\r\nroot_device = root_node->data;\r\nroot_device_is_running = root_device &&\r\natomic_read(&root_device->state) == FW_DEVICE_RUNNING;\r\nroot_device_is_cmc = root_device && root_device->cmc;\r\nirm_device = card->irm_node->data;\r\nirm_is_1394_1995_only = irm_device && irm_device->config_rom &&\r\n(irm_device->config_rom[2] & 0x000000f0) == 0;\r\nkeep_this_irm = irm_device && irm_device->config_rom &&\r\nirm_device->config_rom[3] >> 8 == CANON_OUI;\r\nroot_id = root_node->node_id;\r\nirm_id = card->irm_node->node_id;\r\nlocal_id = card->local_node->node_id;\r\ngrace = time_after64(get_jiffies_64(),\r\ncard->reset_jiffies + DIV_ROUND_UP(HZ, 8));\r\nif ((is_next_generation(generation, card->bm_generation) &&\r\n!card->bm_abdicate) ||\r\n(card->bm_generation != generation && grace)) {\r\nif (!card->irm_node->link_on) {\r\nnew_root_id = local_id;\r\nfw_notice(card, "%s, making local node (%02x) root\n",\r\n"IRM has link off", new_root_id);\r\ngoto pick_me;\r\n}\r\nif (irm_is_1394_1995_only && !keep_this_irm) {\r\nnew_root_id = local_id;\r\nfw_notice(card, "%s, making local node (%02x) root\n",\r\n"IRM is not 1394a compliant", new_root_id);\r\ngoto pick_me;\r\n}\r\ntransaction_data[0] = cpu_to_be32(0x3f);\r\ntransaction_data[1] = cpu_to_be32(local_id);\r\nspin_unlock_irq(&card->lock);\r\nrcode = fw_run_transaction(card, TCODE_LOCK_COMPARE_SWAP,\r\nirm_id, generation, SCODE_100,\r\nCSR_REGISTER_BASE + CSR_BUS_MANAGER_ID,\r\ntransaction_data, 8);\r\nif (rcode == RCODE_GENERATION)\r\ngoto out;\r\nbm_id = be32_to_cpu(transaction_data[0]);\r\nspin_lock_irq(&card->lock);\r\nif (rcode == RCODE_COMPLETE && generation == card->generation)\r\ncard->bm_node_id =\r\nbm_id == 0x3f ? local_id : 0xffc0 | bm_id;\r\nspin_unlock_irq(&card->lock);\r\nif (rcode == RCODE_COMPLETE && bm_id != 0x3f) {\r\nif (local_id == irm_id)\r\nallocate_broadcast_channel(card, generation);\r\ngoto out;\r\n}\r\nif (rcode == RCODE_SEND_ERROR) {\r\nfw_schedule_bm_work(card, DIV_ROUND_UP(HZ, 8));\r\ngoto out;\r\n}\r\nspin_lock_irq(&card->lock);\r\nif (rcode != RCODE_COMPLETE && !keep_this_irm) {\r\nnew_root_id = local_id;\r\nfw_notice(card, "BM lock failed (%s), making local node (%02x) root\n",\r\nfw_rcode_string(rcode), new_root_id);\r\ngoto pick_me;\r\n}\r\n} else if (card->bm_generation != generation) {\r\nspin_unlock_irq(&card->lock);\r\nfw_schedule_bm_work(card, DIV_ROUND_UP(HZ, 8));\r\ngoto out;\r\n}\r\ncard->bm_generation = generation;\r\nif (root_device == NULL) {\r\nnew_root_id = local_id;\r\n} else if (!root_device_is_running) {\r\nspin_unlock_irq(&card->lock);\r\ngoto out;\r\n} else if (root_device_is_cmc) {\r\nnew_root_id = root_id;\r\n} else {\r\nnew_root_id = local_id;\r\n}\r\npick_me:\r\nif (!card->beta_repeaters_present &&\r\nroot_node->max_hops < ARRAY_SIZE(gap_count_table))\r\ngap_count = gap_count_table[root_node->max_hops];\r\nelse\r\ngap_count = 63;\r\nif (card->bm_retries++ < 5 &&\r\n(card->gap_count != gap_count || new_root_id != root_id))\r\ndo_reset = true;\r\nspin_unlock_irq(&card->lock);\r\nif (do_reset) {\r\nfw_notice(card, "phy config: new root=%x, gap_count=%d\n",\r\nnew_root_id, gap_count);\r\nfw_send_phy_config(card, new_root_id, generation, gap_count);\r\nreset_bus(card, true);\r\ngoto out;\r\n}\r\nif (root_device_is_cmc) {\r\ntransaction_data[0] = cpu_to_be32(CSR_STATE_BIT_CMSTR);\r\nrcode = fw_run_transaction(card, TCODE_WRITE_QUADLET_REQUEST,\r\nroot_id, generation, SCODE_100,\r\nCSR_REGISTER_BASE + CSR_STATE_SET,\r\ntransaction_data, 4);\r\nif (rcode == RCODE_GENERATION)\r\ngoto out;\r\n}\r\nif (local_id == irm_id)\r\nallocate_broadcast_channel(card, generation);\r\nout:\r\nfw_node_put(root_node);\r\nout_put_card:\r\nfw_card_put(card);\r\n}\r\nvoid fw_card_initialize(struct fw_card *card,\r\nconst struct fw_card_driver *driver,\r\nstruct device *device)\r\n{\r\nstatic atomic_t index = ATOMIC_INIT(-1);\r\ncard->index = atomic_inc_return(&index);\r\ncard->driver = driver;\r\ncard->device = device;\r\ncard->current_tlabel = 0;\r\ncard->tlabel_mask = 0;\r\ncard->split_timeout_hi = DEFAULT_SPLIT_TIMEOUT / 8000;\r\ncard->split_timeout_lo = (DEFAULT_SPLIT_TIMEOUT % 8000) << 19;\r\ncard->split_timeout_cycles = DEFAULT_SPLIT_TIMEOUT;\r\ncard->split_timeout_jiffies =\r\nDIV_ROUND_UP(DEFAULT_SPLIT_TIMEOUT * HZ, 8000);\r\ncard->color = 0;\r\ncard->broadcast_channel = BROADCAST_CHANNEL_INITIAL;\r\nkref_init(&card->kref);\r\ninit_completion(&card->done);\r\nINIT_LIST_HEAD(&card->transaction_list);\r\nINIT_LIST_HEAD(&card->phy_receiver_list);\r\nspin_lock_init(&card->lock);\r\ncard->local_node = NULL;\r\nINIT_DELAYED_WORK(&card->br_work, br_work);\r\nINIT_DELAYED_WORK(&card->bm_work, bm_work);\r\n}\r\nint fw_card_add(struct fw_card *card,\r\nu32 max_receive, u32 link_speed, u64 guid)\r\n{\r\nint ret;\r\ncard->max_receive = max_receive;\r\ncard->link_speed = link_speed;\r\ncard->guid = guid;\r\nmutex_lock(&card_mutex);\r\ngenerate_config_rom(card, tmp_config_rom);\r\nret = card->driver->enable(card, tmp_config_rom, config_rom_length);\r\nif (ret == 0)\r\nlist_add_tail(&card->link, &card_list);\r\nmutex_unlock(&card_mutex);\r\nreturn ret;\r\n}\r\nstatic int dummy_read_phy_reg(struct fw_card *card, int address)\r\n{\r\nreturn -ENODEV;\r\n}\r\nstatic int dummy_update_phy_reg(struct fw_card *card, int address,\r\nint clear_bits, int set_bits)\r\n{\r\nreturn -ENODEV;\r\n}\r\nstatic void dummy_send_request(struct fw_card *card, struct fw_packet *packet)\r\n{\r\npacket->callback(packet, card, RCODE_CANCELLED);\r\n}\r\nstatic void dummy_send_response(struct fw_card *card, struct fw_packet *packet)\r\n{\r\npacket->callback(packet, card, RCODE_CANCELLED);\r\n}\r\nstatic int dummy_cancel_packet(struct fw_card *card, struct fw_packet *packet)\r\n{\r\nreturn -ENOENT;\r\n}\r\nstatic int dummy_enable_phys_dma(struct fw_card *card,\r\nint node_id, int generation)\r\n{\r\nreturn -ENODEV;\r\n}\r\nstatic struct fw_iso_context *dummy_allocate_iso_context(struct fw_card *card,\r\nint type, int channel, size_t header_size)\r\n{\r\nreturn ERR_PTR(-ENODEV);\r\n}\r\nstatic int dummy_start_iso(struct fw_iso_context *ctx,\r\ns32 cycle, u32 sync, u32 tags)\r\n{\r\nreturn -ENODEV;\r\n}\r\nstatic int dummy_set_iso_channels(struct fw_iso_context *ctx, u64 *channels)\r\n{\r\nreturn -ENODEV;\r\n}\r\nstatic int dummy_queue_iso(struct fw_iso_context *ctx, struct fw_iso_packet *p,\r\nstruct fw_iso_buffer *buffer, unsigned long payload)\r\n{\r\nreturn -ENODEV;\r\n}\r\nstatic void dummy_flush_queue_iso(struct fw_iso_context *ctx)\r\n{\r\n}\r\nstatic int dummy_flush_iso_completions(struct fw_iso_context *ctx)\r\n{\r\nreturn -ENODEV;\r\n}\r\nvoid fw_card_release(struct kref *kref)\r\n{\r\nstruct fw_card *card = container_of(kref, struct fw_card, kref);\r\ncomplete(&card->done);\r\n}\r\nvoid fw_core_remove_card(struct fw_card *card)\r\n{\r\nstruct fw_card_driver dummy_driver = dummy_driver_template;\r\ncard->driver->update_phy_reg(card, 4,\r\nPHY_LINK_ACTIVE | PHY_CONTENDER, 0);\r\nfw_schedule_bus_reset(card, false, true);\r\nmutex_lock(&card_mutex);\r\nlist_del_init(&card->link);\r\nmutex_unlock(&card_mutex);\r\ndummy_driver.free_iso_context = card->driver->free_iso_context;\r\ndummy_driver.stop_iso = card->driver->stop_iso;\r\ncard->driver = &dummy_driver;\r\nfw_destroy_nodes(card);\r\nfw_card_put(card);\r\nwait_for_completion(&card->done);\r\nWARN_ON(!list_empty(&card->transaction_list));\r\n}
