static int FlashPoint_ProbeHostAdapter(struct sccb_mgr_info *pCardInfo)\r\n{\r\nstatic unsigned char first_time = 1;\r\nunsigned char i, j, id, ScamFlg;\r\nunsigned short temp, temp2, temp3, temp4, temp5, temp6;\r\nu32 ioport;\r\nstruct nvram_info *pCurrNvRam;\r\nioport = pCardInfo->si_baseaddr;\r\nif (RD_HARPOON(ioport + hp_vendor_id_0) != ORION_VEND_0)\r\nreturn (int)FAILURE;\r\nif ((RD_HARPOON(ioport + hp_vendor_id_1) != ORION_VEND_1))\r\nreturn (int)FAILURE;\r\nif ((RD_HARPOON(ioport + hp_device_id_0) != ORION_DEV_0))\r\nreturn (int)FAILURE;\r\nif ((RD_HARPOON(ioport + hp_device_id_1) != ORION_DEV_1))\r\nreturn (int)FAILURE;\r\nif (RD_HARPOON(ioport + hp_rev_num) != 0x0f) {\r\nif (RD_HARPOON(ioport + hp_sub_device_id_0) & 0x0f)\r\nreturn (int)FAILURE;\r\n}\r\nif (first_time) {\r\nFPT_SccbMgrTableInitAll();\r\nfirst_time = 0;\r\nFPT_mbCards = 0;\r\n}\r\nif (FPT_RdStack(ioport, 0) != 0x00) {\r\nif (FPT_ChkIfChipInitialized(ioport) == 0) {\r\npCurrNvRam = NULL;\r\nWR_HARPOON(ioport + hp_semaphore, 0x00);\r\nFPT_XbowInit(ioport, 0);\r\nFPT_DiagEEPROM(ioport);\r\n} else {\r\nif (FPT_mbCards < MAX_MB_CARDS) {\r\npCurrNvRam = &FPT_nvRamInfo[FPT_mbCards];\r\nFPT_mbCards++;\r\npCurrNvRam->niBaseAddr = ioport;\r\nFPT_RNVRamData(pCurrNvRam);\r\n} else\r\nreturn (int)FAILURE;\r\n}\r\n} else\r\npCurrNvRam = NULL;\r\nWR_HARPOON(ioport + hp_clkctrl_0, CLKCTRL_DEFAULT);\r\nWR_HARPOON(ioport + hp_sys_ctrl, 0x00);\r\nif (pCurrNvRam)\r\npCardInfo->si_id = pCurrNvRam->niAdapId;\r\nelse\r\npCardInfo->si_id =\r\n(unsigned\r\nchar)(FPT_utilEERead(ioport,\r\n(ADAPTER_SCSI_ID /\r\n2)) & (unsigned char)0x0FF);\r\npCardInfo->si_lun = 0x00;\r\npCardInfo->si_fw_revision = ORION_FW_REV;\r\ntemp2 = 0x0000;\r\ntemp3 = 0x0000;\r\ntemp4 = 0x0000;\r\ntemp5 = 0x0000;\r\ntemp6 = 0x0000;\r\nfor (id = 0; id < (16 / 2); id++) {\r\nif (pCurrNvRam) {\r\ntemp = (unsigned short)pCurrNvRam->niSyncTbl[id];\r\ntemp = ((temp & 0x03) + ((temp << 4) & 0xc0)) +\r\n(((temp << 4) & 0x0300) + ((temp << 8) & 0xc000));\r\n} else\r\ntemp =\r\nFPT_utilEERead(ioport,\r\n(unsigned short)((SYNC_RATE_TBL / 2)\r\n+ id));\r\nfor (i = 0; i < 2; temp >>= 8, i++) {\r\ntemp2 >>= 1;\r\ntemp3 >>= 1;\r\ntemp4 >>= 1;\r\ntemp5 >>= 1;\r\ntemp6 >>= 1;\r\nswitch (temp & 0x3) {\r\ncase AUTO_RATE_20:\r\ntemp6 |= 0x8000;\r\ncase AUTO_RATE_10:\r\ntemp5 |= 0x8000;\r\ncase AUTO_RATE_05:\r\ntemp2 |= 0x8000;\r\ncase AUTO_RATE_00:\r\nbreak;\r\n}\r\nif (temp & DISC_ENABLE_BIT)\r\ntemp3 |= 0x8000;\r\nif (temp & WIDE_NEGO_BIT)\r\ntemp4 |= 0x8000;\r\n}\r\n}\r\npCardInfo->si_per_targ_init_sync = temp2;\r\npCardInfo->si_per_targ_no_disc = temp3;\r\npCardInfo->si_per_targ_wide_nego = temp4;\r\npCardInfo->si_per_targ_fast_nego = temp5;\r\npCardInfo->si_per_targ_ultra_nego = temp6;\r\nif (pCurrNvRam)\r\ni = pCurrNvRam->niSysConf;\r\nelse\r\ni = (unsigned\r\nchar)(FPT_utilEERead(ioport, (SYSTEM_CONFIG / 2)));\r\nif (pCurrNvRam)\r\nScamFlg = pCurrNvRam->niScamConf;\r\nelse\r\nScamFlg =\r\n(unsigned char)FPT_utilEERead(ioport, SCAM_CONFIG / 2);\r\npCardInfo->si_flags = 0x0000;\r\nif (i & 0x01)\r\npCardInfo->si_flags |= SCSI_PARITY_ENA;\r\nif (!(i & 0x02))\r\npCardInfo->si_flags |= SOFT_RESET;\r\nif (i & 0x10)\r\npCardInfo->si_flags |= EXTENDED_TRANSLATION;\r\nif (ScamFlg & SCAM_ENABLED)\r\npCardInfo->si_flags |= FLAG_SCAM_ENABLED;\r\nif (ScamFlg & SCAM_LEVEL2)\r\npCardInfo->si_flags |= FLAG_SCAM_LEVEL2;\r\nj = (RD_HARPOON(ioport + hp_bm_ctrl) & ~SCSI_TERM_ENA_L);\r\nif (i & 0x04) {\r\nj |= SCSI_TERM_ENA_L;\r\n}\r\nWR_HARPOON(ioport + hp_bm_ctrl, j);\r\nj = (RD_HARPOON(ioport + hp_ee_ctrl) & ~SCSI_TERM_ENA_H);\r\nif (i & 0x08) {\r\nj |= SCSI_TERM_ENA_H;\r\n}\r\nWR_HARPOON(ioport + hp_ee_ctrl, j);\r\nif (!(RD_HARPOON(ioport + hp_page_ctrl) & NARROW_SCSI_CARD))\r\npCardInfo->si_flags |= SUPPORT_16TAR_32LUN;\r\npCardInfo->si_card_family = HARPOON_FAMILY;\r\npCardInfo->si_bustype = BUSTYPE_PCI;\r\nif (pCurrNvRam) {\r\npCardInfo->si_card_model[0] = '9';\r\nswitch (pCurrNvRam->niModel & 0x0f) {\r\ncase MODEL_LT:\r\npCardInfo->si_card_model[1] = '3';\r\npCardInfo->si_card_model[2] = '0';\r\nbreak;\r\ncase MODEL_LW:\r\npCardInfo->si_card_model[1] = '5';\r\npCardInfo->si_card_model[2] = '0';\r\nbreak;\r\ncase MODEL_DL:\r\npCardInfo->si_card_model[1] = '3';\r\npCardInfo->si_card_model[2] = '2';\r\nbreak;\r\ncase MODEL_DW:\r\npCardInfo->si_card_model[1] = '5';\r\npCardInfo->si_card_model[2] = '2';\r\nbreak;\r\n}\r\n} else {\r\ntemp = FPT_utilEERead(ioport, (MODEL_NUMB_0 / 2));\r\npCardInfo->si_card_model[0] = (unsigned char)(temp >> 8);\r\ntemp = FPT_utilEERead(ioport, (MODEL_NUMB_2 / 2));\r\npCardInfo->si_card_model[1] = (unsigned char)(temp & 0x00FF);\r\npCardInfo->si_card_model[2] = (unsigned char)(temp >> 8);\r\n}\r\nif (pCardInfo->si_card_model[1] == '3') {\r\nif (RD_HARPOON(ioport + hp_ee_ctrl) & BIT(7))\r\npCardInfo->si_flags |= LOW_BYTE_TERM;\r\n} else if (pCardInfo->si_card_model[2] == '0') {\r\ntemp = RD_HARPOON(ioport + hp_xfer_pad);\r\nWR_HARPOON(ioport + hp_xfer_pad, (temp & ~BIT(4)));\r\nif (RD_HARPOON(ioport + hp_ee_ctrl) & BIT(7))\r\npCardInfo->si_flags |= LOW_BYTE_TERM;\r\nWR_HARPOON(ioport + hp_xfer_pad, (temp | BIT(4)));\r\nif (RD_HARPOON(ioport + hp_ee_ctrl) & BIT(7))\r\npCardInfo->si_flags |= HIGH_BYTE_TERM;\r\nWR_HARPOON(ioport + hp_xfer_pad, temp);\r\n} else {\r\ntemp = RD_HARPOON(ioport + hp_ee_ctrl);\r\ntemp2 = RD_HARPOON(ioport + hp_xfer_pad);\r\nWR_HARPOON(ioport + hp_ee_ctrl, (temp | SEE_CS));\r\nWR_HARPOON(ioport + hp_xfer_pad, (temp2 | BIT(4)));\r\ntemp3 = 0;\r\nfor (i = 0; i < 8; i++) {\r\ntemp3 <<= 1;\r\nif (!(RD_HARPOON(ioport + hp_ee_ctrl) & BIT(7)))\r\ntemp3 |= 1;\r\nWR_HARPOON(ioport + hp_xfer_pad, (temp2 & ~BIT(4)));\r\nWR_HARPOON(ioport + hp_xfer_pad, (temp2 | BIT(4)));\r\n}\r\nWR_HARPOON(ioport + hp_ee_ctrl, temp);\r\nWR_HARPOON(ioport + hp_xfer_pad, temp2);\r\nif (!(temp3 & BIT(7)))\r\npCardInfo->si_flags |= LOW_BYTE_TERM;\r\nif (!(temp3 & BIT(6)))\r\npCardInfo->si_flags |= HIGH_BYTE_TERM;\r\n}\r\nARAM_ACCESS(ioport);\r\nfor (i = 0; i < 4; i++) {\r\npCardInfo->si_XlatInfo[i] =\r\nRD_HARPOON(ioport + hp_aramBase + BIOS_DATA_OFFSET + i);\r\n}\r\npCardInfo->si_relative_cardnum =\r\n(unsigned\r\nchar)(RD_HARPOON(ioport + hp_aramBase + BIOS_RELATIVE_CARD) - 1);\r\nSGRAM_ACCESS(ioport);\r\nFPT_s_PhaseTbl[0] = FPT_phaseDataOut;\r\nFPT_s_PhaseTbl[1] = FPT_phaseDataIn;\r\nFPT_s_PhaseTbl[2] = FPT_phaseIllegal;\r\nFPT_s_PhaseTbl[3] = FPT_phaseIllegal;\r\nFPT_s_PhaseTbl[4] = FPT_phaseCommand;\r\nFPT_s_PhaseTbl[5] = FPT_phaseStatus;\r\nFPT_s_PhaseTbl[6] = FPT_phaseMsgOut;\r\nFPT_s_PhaseTbl[7] = FPT_phaseMsgIn;\r\npCardInfo->si_present = 0x01;\r\nreturn 0;\r\n}\r\nstatic void *FlashPoint_HardwareResetHostAdapter(struct sccb_mgr_info\r\n*pCardInfo)\r\n{\r\nstruct sccb_card *CurrCard = NULL;\r\nstruct nvram_info *pCurrNvRam;\r\nunsigned char i, j, thisCard, ScamFlg;\r\nunsigned short temp, sync_bit_map, id;\r\nu32 ioport;\r\nioport = pCardInfo->si_baseaddr;\r\nfor (thisCard = 0; thisCard <= MAX_CARDS; thisCard++) {\r\nif (thisCard == MAX_CARDS)\r\nreturn (void *)FAILURE;\r\nif (FPT_BL_Card[thisCard].ioPort == ioport) {\r\nCurrCard = &FPT_BL_Card[thisCard];\r\nFPT_SccbMgrTableInitCard(CurrCard, thisCard);\r\nbreak;\r\n}\r\nelse if (FPT_BL_Card[thisCard].ioPort == 0x00) {\r\nFPT_BL_Card[thisCard].ioPort = ioport;\r\nCurrCard = &FPT_BL_Card[thisCard];\r\nif (FPT_mbCards)\r\nfor (i = 0; i < FPT_mbCards; i++) {\r\nif (CurrCard->ioPort ==\r\nFPT_nvRamInfo[i].niBaseAddr)\r\nCurrCard->pNvRamInfo =\r\n&FPT_nvRamInfo[i];\r\n}\r\nFPT_SccbMgrTableInitCard(CurrCard, thisCard);\r\nCurrCard->cardIndex = thisCard;\r\nCurrCard->cardInfo = pCardInfo;\r\nbreak;\r\n}\r\n}\r\npCurrNvRam = CurrCard->pNvRamInfo;\r\nif (pCurrNvRam) {\r\nScamFlg = pCurrNvRam->niScamConf;\r\n} else {\r\nScamFlg =\r\n(unsigned char)FPT_utilEERead(ioport, SCAM_CONFIG / 2);\r\n}\r\nFPT_BusMasterInit(ioport);\r\nFPT_XbowInit(ioport, ScamFlg);\r\nFPT_autoLoadDefaultMap(ioport);\r\nfor (i = 0, id = 0x01; i != pCardInfo->si_id; i++, id <<= 1) {\r\n}\r\nWR_HARPOON(ioport + hp_selfid_0, id);\r\nWR_HARPOON(ioport + hp_selfid_1, 0x00);\r\nWR_HARPOON(ioport + hp_arb_id, pCardInfo->si_id);\r\nCurrCard->ourId = pCardInfo->si_id;\r\ni = (unsigned char)pCardInfo->si_flags;\r\nif (i & SCSI_PARITY_ENA)\r\nWR_HARPOON(ioport + hp_portctrl_1, (HOST_MODE8 | CHK_SCSI_P));\r\nj = (RD_HARPOON(ioport + hp_bm_ctrl) & ~SCSI_TERM_ENA_L);\r\nif (i & LOW_BYTE_TERM)\r\nj |= SCSI_TERM_ENA_L;\r\nWR_HARPOON(ioport + hp_bm_ctrl, j);\r\nj = (RD_HARPOON(ioport + hp_ee_ctrl) & ~SCSI_TERM_ENA_H);\r\nif (i & HIGH_BYTE_TERM)\r\nj |= SCSI_TERM_ENA_H;\r\nWR_HARPOON(ioport + hp_ee_ctrl, j);\r\nif (!(pCardInfo->si_flags & SOFT_RESET)) {\r\nFPT_sresb(ioport, thisCard);\r\nFPT_scini(thisCard, pCardInfo->si_id, 0);\r\n}\r\nif (pCardInfo->si_flags & POST_ALL_UNDERRRUNS)\r\nCurrCard->globalFlags |= F_NO_FILTER;\r\nif (pCurrNvRam) {\r\nif (pCurrNvRam->niSysConf & 0x10)\r\nCurrCard->globalFlags |= F_GREEN_PC;\r\n} else {\r\nif (FPT_utilEERead(ioport, (SYSTEM_CONFIG / 2)) & GREEN_PC_ENA)\r\nCurrCard->globalFlags |= F_GREEN_PC;\r\n}\r\nif (pCurrNvRam) {\r\nif (pCurrNvRam->niScsiConf & 0x04)\r\nCurrCard->globalFlags |= F_DO_RENEGO;\r\n} else {\r\nif (FPT_utilEERead(ioport, (SCSI_CONFIG / 2)) & RENEGO_ENA)\r\nCurrCard->globalFlags |= F_DO_RENEGO;\r\n}\r\nif (pCurrNvRam) {\r\nif (pCurrNvRam->niScsiConf & 0x08)\r\nCurrCard->globalFlags |= F_CONLUN_IO;\r\n} else {\r\nif (FPT_utilEERead(ioport, (SCSI_CONFIG / 2)) & CONNIO_ENA)\r\nCurrCard->globalFlags |= F_CONLUN_IO;\r\n}\r\ntemp = pCardInfo->si_per_targ_no_disc;\r\nfor (i = 0, id = 1; i < MAX_SCSI_TAR; i++, id <<= 1) {\r\nif (temp & id)\r\nFPT_sccbMgrTbl[thisCard][i].TarStatus |= TAR_ALLOW_DISC;\r\n}\r\nsync_bit_map = 0x0001;\r\nfor (id = 0; id < (MAX_SCSI_TAR / 2); id++) {\r\nif (pCurrNvRam) {\r\ntemp = (unsigned short)pCurrNvRam->niSyncTbl[id];\r\ntemp = ((temp & 0x03) + ((temp << 4) & 0xc0)) +\r\n(((temp << 4) & 0x0300) + ((temp << 8) & 0xc000));\r\n} else\r\ntemp =\r\nFPT_utilEERead(ioport,\r\n(unsigned short)((SYNC_RATE_TBL / 2)\r\n+ id));\r\nfor (i = 0; i < 2; temp >>= 8, i++) {\r\nif (pCardInfo->si_per_targ_init_sync & sync_bit_map) {\r\nFPT_sccbMgrTbl[thisCard][id * 2 +\r\ni].TarEEValue =\r\n(unsigned char)temp;\r\n}\r\nelse {\r\nFPT_sccbMgrTbl[thisCard][id * 2 +\r\ni].TarStatus |=\r\nSYNC_SUPPORTED;\r\nFPT_sccbMgrTbl[thisCard][id * 2 +\r\ni].TarEEValue =\r\n(unsigned char)(temp & ~EE_SYNC_MASK);\r\n}\r\nif (pCardInfo->si_per_targ_wide_nego & sync_bit_map) {\r\nFPT_sccbMgrTbl[thisCard][id * 2 +\r\ni].TarEEValue |=\r\nEE_WIDE_SCSI;\r\n}\r\nelse {\r\nFPT_sccbMgrTbl[thisCard][id * 2 +\r\ni].TarStatus |=\r\nWIDE_NEGOCIATED;\r\n}\r\nsync_bit_map <<= 1;\r\n}\r\n}\r\nWR_HARPOON((ioport + hp_semaphore),\r\n(unsigned char)(RD_HARPOON((ioport + hp_semaphore)) |\r\nSCCB_MGR_PRESENT));\r\nreturn (void *)CurrCard;\r\n}\r\nstatic void FlashPoint_ReleaseHostAdapter(void *pCurrCard)\r\n{\r\nunsigned char i;\r\nu32 portBase;\r\nu32 regOffset;\r\nu32 scamData;\r\nu32 *pScamTbl;\r\nstruct nvram_info *pCurrNvRam;\r\npCurrNvRam = ((struct sccb_card *)pCurrCard)->pNvRamInfo;\r\nif (pCurrNvRam) {\r\nFPT_WrStack(pCurrNvRam->niBaseAddr, 0, pCurrNvRam->niModel);\r\nFPT_WrStack(pCurrNvRam->niBaseAddr, 1, pCurrNvRam->niSysConf);\r\nFPT_WrStack(pCurrNvRam->niBaseAddr, 2, pCurrNvRam->niScsiConf);\r\nFPT_WrStack(pCurrNvRam->niBaseAddr, 3, pCurrNvRam->niScamConf);\r\nFPT_WrStack(pCurrNvRam->niBaseAddr, 4, pCurrNvRam->niAdapId);\r\nfor (i = 0; i < MAX_SCSI_TAR / 2; i++)\r\nFPT_WrStack(pCurrNvRam->niBaseAddr,\r\n(unsigned char)(i + 5),\r\npCurrNvRam->niSyncTbl[i]);\r\nportBase = pCurrNvRam->niBaseAddr;\r\nfor (i = 0; i < MAX_SCSI_TAR; i++) {\r\nregOffset = hp_aramBase + 64 + i * 4;\r\npScamTbl = (u32 *)&pCurrNvRam->niScamTbl[i];\r\nscamData = *pScamTbl;\r\nWR_HARP32(portBase, regOffset, scamData);\r\n}\r\n} else {\r\nFPT_WrStack(((struct sccb_card *)pCurrCard)->ioPort, 0, 0);\r\n}\r\n}\r\nstatic void FPT_RNVRamData(struct nvram_info *pNvRamInfo)\r\n{\r\nunsigned char i;\r\nu32 portBase;\r\nu32 regOffset;\r\nu32 scamData;\r\nu32 *pScamTbl;\r\npNvRamInfo->niModel = FPT_RdStack(pNvRamInfo->niBaseAddr, 0);\r\npNvRamInfo->niSysConf = FPT_RdStack(pNvRamInfo->niBaseAddr, 1);\r\npNvRamInfo->niScsiConf = FPT_RdStack(pNvRamInfo->niBaseAddr, 2);\r\npNvRamInfo->niScamConf = FPT_RdStack(pNvRamInfo->niBaseAddr, 3);\r\npNvRamInfo->niAdapId = FPT_RdStack(pNvRamInfo->niBaseAddr, 4);\r\nfor (i = 0; i < MAX_SCSI_TAR / 2; i++)\r\npNvRamInfo->niSyncTbl[i] =\r\nFPT_RdStack(pNvRamInfo->niBaseAddr, (unsigned char)(i + 5));\r\nportBase = pNvRamInfo->niBaseAddr;\r\nfor (i = 0; i < MAX_SCSI_TAR; i++) {\r\nregOffset = hp_aramBase + 64 + i * 4;\r\nRD_HARP32(portBase, regOffset, scamData);\r\npScamTbl = (u32 *)&pNvRamInfo->niScamTbl[i];\r\n*pScamTbl = scamData;\r\n}\r\n}\r\nstatic unsigned char FPT_RdStack(u32 portBase, unsigned char index)\r\n{\r\nWR_HARPOON(portBase + hp_stack_addr, index);\r\nreturn RD_HARPOON(portBase + hp_stack_data);\r\n}\r\nstatic void FPT_WrStack(u32 portBase, unsigned char index, unsigned char data)\r\n{\r\nWR_HARPOON(portBase + hp_stack_addr, index);\r\nWR_HARPOON(portBase + hp_stack_data, data);\r\n}\r\nstatic unsigned char FPT_ChkIfChipInitialized(u32 ioPort)\r\n{\r\nif ((RD_HARPOON(ioPort + hp_arb_id) & 0x0f) != FPT_RdStack(ioPort, 4))\r\nreturn 0;\r\nif ((RD_HARPOON(ioPort + hp_clkctrl_0) & CLKCTRL_DEFAULT)\r\n!= CLKCTRL_DEFAULT)\r\nreturn 0;\r\nif ((RD_HARPOON(ioPort + hp_seltimeout) == TO_250ms) ||\r\n(RD_HARPOON(ioPort + hp_seltimeout) == TO_290ms))\r\nreturn 1;\r\nreturn 0;\r\n}\r\nstatic void FlashPoint_StartCCB(void *curr_card, struct sccb *p_Sccb)\r\n{\r\nu32 ioport;\r\nunsigned char thisCard, lun;\r\nstruct sccb *pSaveSccb;\r\nCALL_BK_FN callback;\r\nstruct sccb_card *pCurrCard = curr_card;\r\nthisCard = pCurrCard->cardIndex;\r\nioport = pCurrCard->ioPort;\r\nif ((p_Sccb->TargID >= MAX_SCSI_TAR) || (p_Sccb->Lun >= MAX_LUN)) {\r\np_Sccb->HostStatus = SCCB_COMPLETE;\r\np_Sccb->SccbStatus = SCCB_ERROR;\r\ncallback = (CALL_BK_FN) p_Sccb->SccbCallback;\r\nif (callback)\r\ncallback(p_Sccb);\r\nreturn;\r\n}\r\nFPT_sinits(p_Sccb, thisCard);\r\nif (!pCurrCard->cmdCounter) {\r\nWR_HARPOON(ioport + hp_semaphore,\r\n(RD_HARPOON(ioport + hp_semaphore)\r\n| SCCB_MGR_ACTIVE));\r\nif (pCurrCard->globalFlags & F_GREEN_PC) {\r\nWR_HARPOON(ioport + hp_clkctrl_0, CLKCTRL_DEFAULT);\r\nWR_HARPOON(ioport + hp_sys_ctrl, 0x00);\r\n}\r\n}\r\npCurrCard->cmdCounter++;\r\nif (RD_HARPOON(ioport + hp_semaphore) & BIOS_IN_USE) {\r\nWR_HARPOON(ioport + hp_semaphore,\r\n(RD_HARPOON(ioport + hp_semaphore)\r\n| TICKLE_ME));\r\nif (p_Sccb->OperationCode == RESET_COMMAND) {\r\npSaveSccb =\r\npCurrCard->currentSCCB;\r\npCurrCard->currentSCCB = p_Sccb;\r\nFPT_queueSelectFail(&FPT_BL_Card[thisCard], thisCard);\r\npCurrCard->currentSCCB =\r\npSaveSccb;\r\n} else {\r\nFPT_queueAddSccb(p_Sccb, thisCard);\r\n}\r\n}\r\nelse if ((RD_HARPOON(ioport + hp_page_ctrl) & G_INT_DISABLE)) {\r\nif (p_Sccb->OperationCode == RESET_COMMAND) {\r\npSaveSccb =\r\npCurrCard->currentSCCB;\r\npCurrCard->currentSCCB = p_Sccb;\r\nFPT_queueSelectFail(&FPT_BL_Card[thisCard], thisCard);\r\npCurrCard->currentSCCB =\r\npSaveSccb;\r\n} else {\r\nFPT_queueAddSccb(p_Sccb, thisCard);\r\n}\r\n}\r\nelse {\r\nMDISABLE_INT(ioport);\r\nif ((pCurrCard->globalFlags & F_CONLUN_IO) &&\r\n((FPT_sccbMgrTbl[thisCard][p_Sccb->TargID].\r\nTarStatus & TAR_TAG_Q_MASK) != TAG_Q_TRYING))\r\nlun = p_Sccb->Lun;\r\nelse\r\nlun = 0;\r\nif ((pCurrCard->currentSCCB == NULL) &&\r\n(FPT_sccbMgrTbl[thisCard][p_Sccb->TargID].TarSelQ_Cnt == 0)\r\n&& (FPT_sccbMgrTbl[thisCard][p_Sccb->TargID].TarLUNBusy[lun]\r\n== 0)) {\r\npCurrCard->currentSCCB = p_Sccb;\r\nFPT_ssel(p_Sccb->SccbIOPort, thisCard);\r\n}\r\nelse {\r\nif (p_Sccb->OperationCode == RESET_COMMAND) {\r\npSaveSccb = pCurrCard->currentSCCB;\r\npCurrCard->currentSCCB = p_Sccb;\r\nFPT_queueSelectFail(&FPT_BL_Card[thisCard],\r\nthisCard);\r\npCurrCard->currentSCCB = pSaveSccb;\r\n} else {\r\nFPT_queueAddSccb(p_Sccb, thisCard);\r\n}\r\n}\r\nMENABLE_INT(ioport);\r\n}\r\n}\r\nstatic int FlashPoint_AbortCCB(void *pCurrCard, struct sccb *p_Sccb)\r\n{\r\nu32 ioport;\r\nunsigned char thisCard;\r\nCALL_BK_FN callback;\r\nunsigned char TID;\r\nstruct sccb *pSaveSCCB;\r\nstruct sccb_mgr_tar_info *currTar_Info;\r\nioport = ((struct sccb_card *)pCurrCard)->ioPort;\r\nthisCard = ((struct sccb_card *)pCurrCard)->cardIndex;\r\nif (!(RD_HARPOON(ioport + hp_page_ctrl) & G_INT_DISABLE)) {\r\nif (FPT_queueFindSccb(p_Sccb, thisCard)) {\r\n((struct sccb_card *)pCurrCard)->cmdCounter--;\r\nif (!((struct sccb_card *)pCurrCard)->cmdCounter)\r\nWR_HARPOON(ioport + hp_semaphore,\r\n(RD_HARPOON(ioport + hp_semaphore)\r\n& (unsigned\r\nchar)(~(SCCB_MGR_ACTIVE |\r\nTICKLE_ME))));\r\np_Sccb->SccbStatus = SCCB_ABORT;\r\ncallback = p_Sccb->SccbCallback;\r\ncallback(p_Sccb);\r\nreturn 0;\r\n}\r\nelse {\r\nif (((struct sccb_card *)pCurrCard)->currentSCCB ==\r\np_Sccb) {\r\np_Sccb->SccbStatus = SCCB_ABORT;\r\nreturn 0;\r\n}\r\nelse {\r\nTID = p_Sccb->TargID;\r\nif (p_Sccb->Sccb_tag) {\r\nMDISABLE_INT(ioport);\r\nif (((struct sccb_card *)pCurrCard)->\r\ndiscQ_Tbl[p_Sccb->Sccb_tag] ==\r\np_Sccb) {\r\np_Sccb->SccbStatus = SCCB_ABORT;\r\np_Sccb->Sccb_scsistat =\r\nABORT_ST;\r\np_Sccb->Sccb_scsimsg =\r\nSMABORT_TAG;\r\nif (((struct sccb_card *)\r\npCurrCard)->currentSCCB ==\r\nNULL) {\r\n((struct sccb_card *)\r\npCurrCard)->\r\ncurrentSCCB = p_Sccb;\r\nFPT_ssel(ioport,\r\nthisCard);\r\n} else {\r\npSaveSCCB =\r\n((struct sccb_card\r\n*)pCurrCard)->\r\ncurrentSCCB;\r\n((struct sccb_card *)\r\npCurrCard)->\r\ncurrentSCCB = p_Sccb;\r\nFPT_queueSelectFail((struct sccb_card *)pCurrCard, thisCard);\r\n((struct sccb_card *)\r\npCurrCard)->\r\ncurrentSCCB = pSaveSCCB;\r\n}\r\n}\r\nMENABLE_INT(ioport);\r\nreturn 0;\r\n} else {\r\ncurrTar_Info =\r\n&FPT_sccbMgrTbl[thisCard][p_Sccb->\r\nTargID];\r\nif (FPT_BL_Card[thisCard].\r\ndiscQ_Tbl[currTar_Info->\r\nLunDiscQ_Idx[p_Sccb->Lun]]\r\n== p_Sccb) {\r\np_Sccb->SccbStatus = SCCB_ABORT;\r\nreturn 0;\r\n}\r\n}\r\n}\r\n}\r\n}\r\nreturn -1;\r\n}\r\nstatic unsigned char FlashPoint_InterruptPending(void *pCurrCard)\r\n{\r\nu32 ioport;\r\nioport = ((struct sccb_card *)pCurrCard)->ioPort;\r\nif (RD_HARPOON(ioport + hp_int_status) & INT_ASSERTED) {\r\nreturn 1;\r\n}\r\nelse\r\nreturn 0;\r\n}\r\nstatic int FlashPoint_HandleInterrupt(void *pcard)\r\n{\r\nstruct sccb *currSCCB;\r\nunsigned char thisCard, result, bm_status, bm_int_st;\r\nunsigned short hp_int;\r\nunsigned char i, target;\r\nstruct sccb_card *pCurrCard = pcard;\r\nu32 ioport;\r\nthisCard = pCurrCard->cardIndex;\r\nioport = pCurrCard->ioPort;\r\nMDISABLE_INT(ioport);\r\nif ((bm_int_st = RD_HARPOON(ioport + hp_int_status)) & EXT_STATUS_ON)\r\nbm_status = RD_HARPOON(ioport + hp_ext_status) &\r\n(unsigned char)BAD_EXT_STATUS;\r\nelse\r\nbm_status = 0;\r\nWR_HARPOON(ioport + hp_int_mask, (INT_CMD_COMPL | SCSI_INTERRUPT));\r\nwhile ((hp_int = RDW_HARPOON((ioport + hp_intstat)) &\r\nFPT_default_intena) | bm_status) {\r\ncurrSCCB = pCurrCard->currentSCCB;\r\nif (hp_int & (FIFO | TIMEOUT | RESET | SCAM_SEL) || bm_status) {\r\nresult =\r\nFPT_SccbMgr_bad_isr(ioport, thisCard, pCurrCard,\r\nhp_int);\r\nWRW_HARPOON((ioport + hp_intstat),\r\n(FIFO | TIMEOUT | RESET | SCAM_SEL));\r\nbm_status = 0;\r\nif (result) {\r\nMENABLE_INT(ioport);\r\nreturn result;\r\n}\r\n}\r\nelse if (hp_int & ICMD_COMP) {\r\nif (!(hp_int & BUS_FREE)) {\r\nwhile (!\r\n(RDW_HARPOON((ioport + hp_intstat)) &\r\n(BUS_FREE | RSEL))) ;\r\n}\r\nif (pCurrCard->globalFlags & F_HOST_XFER_ACT)\r\nFPT_phaseChkFifo(ioport, thisCard);\r\nWRW_HARPOON((ioport + hp_intstat), CLR_ALL_INT_1);\r\nFPT_autoCmdCmplt(ioport, thisCard);\r\n}\r\nelse if (hp_int & ITAR_DISC) {\r\nif (pCurrCard->globalFlags & F_HOST_XFER_ACT)\r\nFPT_phaseChkFifo(ioport, thisCard);\r\nif (RD_HARPOON(ioport + hp_gp_reg_1) ==\r\nSMSAVE_DATA_PTR) {\r\nWR_HARPOON(ioport + hp_gp_reg_1, 0x00);\r\ncurrSCCB->Sccb_XferState |= F_NO_DATA_YET;\r\ncurrSCCB->Sccb_savedATC = currSCCB->Sccb_ATC;\r\n}\r\ncurrSCCB->Sccb_scsistat = DISCONNECT_ST;\r\nFPT_queueDisconnect(currSCCB, thisCard);\r\nwhile (!\r\n(RDW_HARPOON((ioport + hp_intstat)) &\r\n(BUS_FREE | RSEL))\r\n&& !((RDW_HARPOON((ioport + hp_intstat)) & PHASE)\r\n&& RD_HARPOON((ioport + hp_scsisig)) ==\r\n(SCSI_BSY | SCSI_REQ | SCSI_CD | SCSI_MSG |\r\nSCSI_IOBIT))) ;\r\nif (!\r\n(RDW_HARPOON((ioport + hp_intstat)) &\r\n(BUS_FREE | RSEL))) {\r\nMENABLE_INT(ioport);\r\nreturn 0xFE;\r\n}\r\nWRW_HARPOON((ioport + hp_intstat),\r\n(BUS_FREE | ITAR_DISC));\r\npCurrCard->globalFlags |= F_NEW_SCCB_CMD;\r\n}\r\nelse if (hp_int & RSEL) {\r\nWRW_HARPOON((ioport + hp_intstat),\r\n(PROG_HLT | RSEL | PHASE | BUS_FREE));\r\nif (RDW_HARPOON((ioport + hp_intstat)) & ITAR_DISC) {\r\nif (pCurrCard->globalFlags & F_HOST_XFER_ACT)\r\nFPT_phaseChkFifo(ioport, thisCard);\r\nif (RD_HARPOON(ioport + hp_gp_reg_1) ==\r\nSMSAVE_DATA_PTR) {\r\nWR_HARPOON(ioport + hp_gp_reg_1, 0x00);\r\ncurrSCCB->Sccb_XferState |=\r\nF_NO_DATA_YET;\r\ncurrSCCB->Sccb_savedATC =\r\ncurrSCCB->Sccb_ATC;\r\n}\r\nWRW_HARPOON((ioport + hp_intstat),\r\n(BUS_FREE | ITAR_DISC));\r\ncurrSCCB->Sccb_scsistat = DISCONNECT_ST;\r\nFPT_queueDisconnect(currSCCB, thisCard);\r\n}\r\nFPT_sres(ioport, thisCard, pCurrCard);\r\nFPT_phaseDecode(ioport, thisCard);\r\n}\r\nelse if ((hp_int & IDO_STRT) && (!(hp_int & BUS_FREE))) {\r\nWRW_HARPOON((ioport + hp_intstat),\r\n(IDO_STRT | XFER_CNT_0));\r\nFPT_phaseDecode(ioport, thisCard);\r\n}\r\nelse if ((hp_int & IUNKWN) || (hp_int & PROG_HLT)) {\r\nWRW_HARPOON((ioport + hp_intstat),\r\n(PHASE | IUNKWN | PROG_HLT));\r\nif ((RD_HARPOON(ioport + hp_prgmcnt_0) & (unsigned char)\r\n0x3f) < (unsigned char)SELCHK) {\r\nFPT_phaseDecode(ioport, thisCard);\r\n} else {\r\ni = (unsigned\r\nchar)(RD_HARPOON(ioport + hp_fifowrite));\r\ntarget =\r\n(unsigned\r\nchar)(RD_HARPOON(ioport + hp_gp_reg_3));\r\nWR_HARPOON(ioport + hp_xfer_pad,\r\n(unsigned char)ID_UNLOCK);\r\nWR_HARPOON(ioport + hp_select_id,\r\n(unsigned char)(target | target <<\r\n4));\r\nWR_HARPOON(ioport + hp_xfer_pad,\r\n(unsigned char)0x00);\r\nWR_HARPOON(ioport + hp_fifowrite, i);\r\nWR_HARPOON(ioport + hp_autostart_3,\r\n(AUTO_IMMED + TAG_STRT));\r\n}\r\n}\r\nelse if (hp_int & XFER_CNT_0) {\r\nWRW_HARPOON((ioport + hp_intstat), XFER_CNT_0);\r\nFPT_schkdd(ioport, thisCard);\r\n}\r\nelse if (hp_int & BUS_FREE) {\r\nWRW_HARPOON((ioport + hp_intstat), BUS_FREE);\r\nif (pCurrCard->globalFlags & F_HOST_XFER_ACT) {\r\nFPT_hostDataXferAbort(ioport, thisCard,\r\ncurrSCCB);\r\n}\r\nFPT_phaseBusFree(ioport, thisCard);\r\n}\r\nelse if (hp_int & ITICKLE) {\r\nWRW_HARPOON((ioport + hp_intstat), ITICKLE);\r\npCurrCard->globalFlags |= F_NEW_SCCB_CMD;\r\n}\r\nif (((struct sccb_card *)pCurrCard)->\r\nglobalFlags & F_NEW_SCCB_CMD) {\r\npCurrCard->globalFlags &= ~F_NEW_SCCB_CMD;\r\nif (pCurrCard->currentSCCB == NULL)\r\nFPT_queueSearchSelect(pCurrCard, thisCard);\r\nif (pCurrCard->currentSCCB != NULL) {\r\npCurrCard->globalFlags &= ~F_NEW_SCCB_CMD;\r\nFPT_ssel(ioport, thisCard);\r\n}\r\nbreak;\r\n}\r\n}\r\nMENABLE_INT(ioport);\r\nreturn 0;\r\n}\r\nstatic unsigned char FPT_SccbMgr_bad_isr(u32 p_port, unsigned char p_card,\r\nstruct sccb_card *pCurrCard,\r\nunsigned short p_int)\r\n{\r\nunsigned char temp, ScamFlg;\r\nstruct sccb_mgr_tar_info *currTar_Info;\r\nstruct nvram_info *pCurrNvRam;\r\nif (RD_HARPOON(p_port + hp_ext_status) &\r\n(BM_FORCE_OFF | PCI_DEV_TMOUT | BM_PARITY_ERR | PIO_OVERRUN)) {\r\nif (pCurrCard->globalFlags & F_HOST_XFER_ACT) {\r\nFPT_hostDataXferAbort(p_port, p_card,\r\npCurrCard->currentSCCB);\r\n}\r\nif (RD_HARPOON(p_port + hp_pci_stat_cfg) & REC_MASTER_ABORT)\r\n{\r\nWR_HARPOON(p_port + hp_pci_stat_cfg,\r\n(RD_HARPOON(p_port + hp_pci_stat_cfg) &\r\n~REC_MASTER_ABORT));\r\nWR_HARPOON(p_port + hp_host_blk_cnt, 0x00);\r\n}\r\nif (pCurrCard->currentSCCB != NULL) {\r\nif (!pCurrCard->currentSCCB->HostStatus)\r\npCurrCard->currentSCCB->HostStatus =\r\nSCCB_BM_ERR;\r\nFPT_sxfrp(p_port, p_card);\r\ntemp = (unsigned char)(RD_HARPOON(p_port + hp_ee_ctrl) &\r\n(EXT_ARB_ACK | SCSI_TERM_ENA_H));\r\nWR_HARPOON(p_port + hp_ee_ctrl,\r\n((unsigned char)temp | SEE_MS | SEE_CS));\r\nWR_HARPOON(p_port + hp_ee_ctrl, temp);\r\nif (!\r\n(RDW_HARPOON((p_port + hp_intstat)) &\r\n(BUS_FREE | RESET))) {\r\nFPT_phaseDecode(p_port, p_card);\r\n}\r\n}\r\n}\r\nelse if (p_int & RESET) {\r\nWR_HARPOON(p_port + hp_clkctrl_0, CLKCTRL_DEFAULT);\r\nWR_HARPOON(p_port + hp_sys_ctrl, 0x00);\r\nif (pCurrCard->currentSCCB != NULL) {\r\nif (pCurrCard->globalFlags & F_HOST_XFER_ACT)\r\nFPT_hostDataXferAbort(p_port, p_card,\r\npCurrCard->currentSCCB);\r\n}\r\nDISABLE_AUTO(p_port);\r\nFPT_sresb(p_port, p_card);\r\nwhile (RD_HARPOON(p_port + hp_scsictrl_0) & SCSI_RST) {\r\n}\r\npCurrNvRam = pCurrCard->pNvRamInfo;\r\nif (pCurrNvRam) {\r\nScamFlg = pCurrNvRam->niScamConf;\r\n} else {\r\nScamFlg =\r\n(unsigned char)FPT_utilEERead(p_port,\r\nSCAM_CONFIG / 2);\r\n}\r\nFPT_XbowInit(p_port, ScamFlg);\r\nFPT_scini(p_card, pCurrCard->ourId, 0);\r\nreturn 0xFF;\r\n}\r\nelse if (p_int & FIFO) {\r\nWRW_HARPOON((p_port + hp_intstat), FIFO);\r\nif (pCurrCard->currentSCCB != NULL)\r\nFPT_sxfrp(p_port, p_card);\r\n}\r\nelse if (p_int & TIMEOUT) {\r\nDISABLE_AUTO(p_port);\r\nWRW_HARPOON((p_port + hp_intstat),\r\n(PROG_HLT | TIMEOUT | SEL | BUS_FREE | PHASE |\r\nIUNKWN));\r\npCurrCard->currentSCCB->HostStatus = SCCB_SELECTION_TIMEOUT;\r\ncurrTar_Info =\r\n&FPT_sccbMgrTbl[p_card][pCurrCard->currentSCCB->TargID];\r\nif ((pCurrCard->globalFlags & F_CONLUN_IO)\r\n&& ((currTar_Info->TarStatus & TAR_TAG_Q_MASK) !=\r\nTAG_Q_TRYING))\r\ncurrTar_Info->TarLUNBusy[pCurrCard->currentSCCB->Lun] =\r\n0;\r\nelse\r\ncurrTar_Info->TarLUNBusy[0] = 0;\r\nif (currTar_Info->TarEEValue & EE_SYNC_MASK) {\r\ncurrTar_Info->TarSyncCtrl = 0;\r\ncurrTar_Info->TarStatus &= ~TAR_SYNC_MASK;\r\n}\r\nif (currTar_Info->TarEEValue & EE_WIDE_SCSI) {\r\ncurrTar_Info->TarStatus &= ~TAR_WIDE_MASK;\r\n}\r\nFPT_sssyncv(p_port, pCurrCard->currentSCCB->TargID, NARROW_SCSI,\r\ncurrTar_Info);\r\nFPT_queueCmdComplete(pCurrCard, pCurrCard->currentSCCB, p_card);\r\n}\r\nelse if (p_int & SCAM_SEL) {\r\nFPT_scarb(p_port, LEVEL2_TAR);\r\nFPT_scsel(p_port);\r\nFPT_scasid(p_card, p_port);\r\nFPT_scbusf(p_port);\r\nWRW_HARPOON((p_port + hp_intstat), SCAM_SEL);\r\n}\r\nreturn 0x00;\r\n}\r\nstatic void FPT_SccbMgrTableInitAll(void)\r\n{\r\nunsigned char thisCard;\r\nfor (thisCard = 0; thisCard < MAX_CARDS; thisCard++) {\r\nFPT_SccbMgrTableInitCard(&FPT_BL_Card[thisCard], thisCard);\r\nFPT_BL_Card[thisCard].ioPort = 0x00;\r\nFPT_BL_Card[thisCard].cardInfo = NULL;\r\nFPT_BL_Card[thisCard].cardIndex = 0xFF;\r\nFPT_BL_Card[thisCard].ourId = 0x00;\r\nFPT_BL_Card[thisCard].pNvRamInfo = NULL;\r\n}\r\n}\r\nstatic void FPT_SccbMgrTableInitCard(struct sccb_card *pCurrCard,\r\nunsigned char p_card)\r\n{\r\nunsigned char scsiID, qtag;\r\nfor (qtag = 0; qtag < QUEUE_DEPTH; qtag++) {\r\nFPT_BL_Card[p_card].discQ_Tbl[qtag] = NULL;\r\n}\r\nfor (scsiID = 0; scsiID < MAX_SCSI_TAR; scsiID++) {\r\nFPT_sccbMgrTbl[p_card][scsiID].TarStatus = 0;\r\nFPT_sccbMgrTbl[p_card][scsiID].TarEEValue = 0;\r\nFPT_SccbMgrTableInitTarget(p_card, scsiID);\r\n}\r\npCurrCard->scanIndex = 0x00;\r\npCurrCard->currentSCCB = NULL;\r\npCurrCard->globalFlags = 0x00;\r\npCurrCard->cmdCounter = 0x00;\r\npCurrCard->tagQ_Lst = 0x01;\r\npCurrCard->discQCount = 0;\r\n}\r\nstatic void FPT_SccbMgrTableInitTarget(unsigned char p_card,\r\nunsigned char target)\r\n{\r\nunsigned char lun, qtag;\r\nstruct sccb_mgr_tar_info *currTar_Info;\r\ncurrTar_Info = &FPT_sccbMgrTbl[p_card][target];\r\ncurrTar_Info->TarSelQ_Cnt = 0;\r\ncurrTar_Info->TarSyncCtrl = 0;\r\ncurrTar_Info->TarSelQ_Head = NULL;\r\ncurrTar_Info->TarSelQ_Tail = NULL;\r\ncurrTar_Info->TarTagQ_Cnt = 0;\r\ncurrTar_Info->TarLUN_CA = 0;\r\nfor (lun = 0; lun < MAX_LUN; lun++) {\r\ncurrTar_Info->TarLUNBusy[lun] = 0;\r\ncurrTar_Info->LunDiscQ_Idx[lun] = 0;\r\n}\r\nfor (qtag = 0; qtag < QUEUE_DEPTH; qtag++) {\r\nif (FPT_BL_Card[p_card].discQ_Tbl[qtag] != NULL) {\r\nif (FPT_BL_Card[p_card].discQ_Tbl[qtag]->TargID ==\r\ntarget) {\r\nFPT_BL_Card[p_card].discQ_Tbl[qtag] = NULL;\r\nFPT_BL_Card[p_card].discQCount--;\r\n}\r\n}\r\n}\r\n}\r\nstatic unsigned char FPT_sfm(u32 port, struct sccb *pCurrSCCB)\r\n{\r\nunsigned char message;\r\nunsigned short TimeOutLoop;\r\nTimeOutLoop = 0;\r\nwhile ((!(RD_HARPOON(port + hp_scsisig) & SCSI_REQ)) &&\r\n(TimeOutLoop++ < 20000)) {\r\n}\r\nWR_HARPOON(port + hp_portctrl_0, SCSI_PORT);\r\nmessage = RD_HARPOON(port + hp_scsidata_0);\r\nWR_HARPOON(port + hp_scsisig, SCSI_ACK + S_MSGI_PH);\r\nif (TimeOutLoop > 20000)\r\nmessage = 0x00;\r\nif ((RDW_HARPOON((port + hp_intstat)) & PARITY) &&\r\n(RD_HARPOON(port + hp_addstat) & SCSI_PAR_ERR)) {\r\nWR_HARPOON(port + hp_scsisig, (SCSI_ACK + S_ILL_PH));\r\nWR_HARPOON(port + hp_xferstat, 0);\r\nWR_HARPOON(port + hp_fiforead, 0);\r\nWR_HARPOON(port + hp_fifowrite, 0);\r\nif (pCurrSCCB != NULL) {\r\npCurrSCCB->Sccb_scsimsg = SMPARITY;\r\n}\r\nmessage = 0x00;\r\ndo {\r\nACCEPT_MSG_ATN(port);\r\nTimeOutLoop = 0;\r\nwhile ((!(RD_HARPOON(port + hp_scsisig) & SCSI_REQ)) &&\r\n(TimeOutLoop++ < 20000)) {\r\n}\r\nif (TimeOutLoop > 20000) {\r\nWRW_HARPOON((port + hp_intstat), PARITY);\r\nreturn message;\r\n}\r\nif ((RD_HARPOON(port + hp_scsisig) & S_SCSI_PHZ) !=\r\nS_MSGI_PH) {\r\nWRW_HARPOON((port + hp_intstat), PARITY);\r\nreturn message;\r\n}\r\nWR_HARPOON(port + hp_portctrl_0, SCSI_PORT);\r\nRD_HARPOON(port + hp_scsidata_0);\r\nWR_HARPOON(port + hp_scsisig, (SCSI_ACK + S_ILL_PH));\r\n} while (1);\r\n}\r\nWR_HARPOON(port + hp_scsisig, (SCSI_ACK + S_ILL_PH));\r\nWR_HARPOON(port + hp_xferstat, 0);\r\nWR_HARPOON(port + hp_fiforead, 0);\r\nWR_HARPOON(port + hp_fifowrite, 0);\r\nreturn message;\r\n}\r\nstatic void FPT_ssel(u32 port, unsigned char p_card)\r\n{\r\nunsigned char auto_loaded, i, target, *theCCB;\r\nu32 cdb_reg;\r\nstruct sccb_card *CurrCard;\r\nstruct sccb *currSCCB;\r\nstruct sccb_mgr_tar_info *currTar_Info;\r\nunsigned char lastTag, lun;\r\nCurrCard = &FPT_BL_Card[p_card];\r\ncurrSCCB = CurrCard->currentSCCB;\r\ntarget = currSCCB->TargID;\r\ncurrTar_Info = &FPT_sccbMgrTbl[p_card][target];\r\nlastTag = CurrCard->tagQ_Lst;\r\nARAM_ACCESS(port);\r\nif ((currTar_Info->TarStatus & TAR_TAG_Q_MASK) == TAG_Q_REJECT)\r\ncurrSCCB->ControlByte &= ~F_USE_CMD_Q;\r\nif (((CurrCard->globalFlags & F_CONLUN_IO) &&\r\n((currTar_Info->TarStatus & TAR_TAG_Q_MASK) != TAG_Q_TRYING)))\r\nlun = currSCCB->Lun;\r\nelse\r\nlun = 0;\r\nif (CurrCard->globalFlags & F_TAG_STARTED) {\r\nif (!(currSCCB->ControlByte & F_USE_CMD_Q)) {\r\nif ((currTar_Info->TarLUN_CA == 0)\r\n&& ((currTar_Info->TarStatus & TAR_TAG_Q_MASK)\r\n== TAG_Q_TRYING)) {\r\nif (currTar_Info->TarTagQ_Cnt != 0) {\r\ncurrTar_Info->TarLUNBusy[lun] = 1;\r\nFPT_queueSelectFail(CurrCard, p_card);\r\nSGRAM_ACCESS(port);\r\nreturn;\r\n}\r\nelse {\r\ncurrTar_Info->TarLUNBusy[lun] = 1;\r\n}\r\n}\r\nelse {\r\ncurrTar_Info->TarLUNBusy[lun] = 1;\r\n}\r\n}\r\nelse {\r\nif (currTar_Info->TarLUN_CA == 1) {\r\nFPT_queueSelectFail(CurrCard, p_card);\r\nSGRAM_ACCESS(port);\r\nreturn;\r\n}\r\ncurrTar_Info->TarLUNBusy[lun] = 1;\r\n}\r\n}\r\nelse {\r\ncurrTar_Info->TarLUNBusy[lun] = 1;\r\n}\r\nif ((((CurrCard->globalFlags & F_CONLUN_IO) &&\r\n((currTar_Info->TarStatus & TAR_TAG_Q_MASK) != TAG_Q_TRYING))\r\n|| (!(currSCCB->ControlByte & F_USE_CMD_Q)))) {\r\nif (CurrCard->discQCount >= QUEUE_DEPTH) {\r\ncurrTar_Info->TarLUNBusy[lun] = 1;\r\nFPT_queueSelectFail(CurrCard, p_card);\r\nSGRAM_ACCESS(port);\r\nreturn;\r\n}\r\nfor (i = 1; i < QUEUE_DEPTH; i++) {\r\nif (++lastTag >= QUEUE_DEPTH)\r\nlastTag = 1;\r\nif (CurrCard->discQ_Tbl[lastTag] == NULL) {\r\nCurrCard->tagQ_Lst = lastTag;\r\ncurrTar_Info->LunDiscQ_Idx[lun] = lastTag;\r\nCurrCard->discQ_Tbl[lastTag] = currSCCB;\r\nCurrCard->discQCount++;\r\nbreak;\r\n}\r\n}\r\nif (i == QUEUE_DEPTH) {\r\ncurrTar_Info->TarLUNBusy[lun] = 1;\r\nFPT_queueSelectFail(CurrCard, p_card);\r\nSGRAM_ACCESS(port);\r\nreturn;\r\n}\r\n}\r\nauto_loaded = 0;\r\nWR_HARPOON(port + hp_select_id, target);\r\nWR_HARPOON(port + hp_gp_reg_3, target);\r\nif (currSCCB->OperationCode == RESET_COMMAND) {\r\nWRW_HARPOON((port + ID_MSG_STRT), (MPM_OP + AMSG_OUT +\r\n(currSCCB->\r\nSccb_idmsg & ~DISC_PRIV)));\r\nWRW_HARPOON((port + ID_MSG_STRT + 2), BRH_OP + ALWAYS + NP);\r\ncurrSCCB->Sccb_scsimsg = SMDEV_RESET;\r\nWR_HARPOON(port + hp_autostart_3, (SELECT + SELCHK_STRT));\r\nauto_loaded = 1;\r\ncurrSCCB->Sccb_scsistat = SELECT_BDR_ST;\r\nif (currTar_Info->TarEEValue & EE_SYNC_MASK) {\r\ncurrTar_Info->TarSyncCtrl = 0;\r\ncurrTar_Info->TarStatus &= ~TAR_SYNC_MASK;\r\n}\r\nif (currTar_Info->TarEEValue & EE_WIDE_SCSI) {\r\ncurrTar_Info->TarStatus &= ~TAR_WIDE_MASK;\r\n}\r\nFPT_sssyncv(port, target, NARROW_SCSI, currTar_Info);\r\nFPT_SccbMgrTableInitTarget(p_card, target);\r\n}\r\nelse if (currSCCB->Sccb_scsistat == ABORT_ST) {\r\nWRW_HARPOON((port + ID_MSG_STRT), (MPM_OP + AMSG_OUT +\r\n(currSCCB->\r\nSccb_idmsg & ~DISC_PRIV)));\r\nWRW_HARPOON((port + ID_MSG_STRT + 2), BRH_OP + ALWAYS + CMDPZ);\r\nWRW_HARPOON((port + SYNC_MSGS + 0), (MPM_OP + AMSG_OUT +\r\n(((unsigned\r\nchar)(currSCCB->\r\nControlByte &\r\nTAG_TYPE_MASK)\r\n>> 6) | (unsigned char)\r\n0x20)));\r\nWRW_HARPOON((port + SYNC_MSGS + 2),\r\n(MPM_OP + AMSG_OUT + currSCCB->Sccb_tag));\r\nWRW_HARPOON((port + SYNC_MSGS + 4), (BRH_OP + ALWAYS + NP));\r\nWR_HARPOON(port + hp_autostart_3, (SELECT + SELCHK_STRT));\r\nauto_loaded = 1;\r\n}\r\nelse if (!(currTar_Info->TarStatus & WIDE_NEGOCIATED)) {\r\nauto_loaded = FPT_siwidn(port, p_card);\r\ncurrSCCB->Sccb_scsistat = SELECT_WN_ST;\r\n}\r\nelse if (!((currTar_Info->TarStatus & TAR_SYNC_MASK)\r\n== SYNC_SUPPORTED)) {\r\nauto_loaded = FPT_sisyncn(port, p_card, 0);\r\ncurrSCCB->Sccb_scsistat = SELECT_SN_ST;\r\n}\r\nif (!auto_loaded) {\r\nif (currSCCB->ControlByte & F_USE_CMD_Q) {\r\nCurrCard->globalFlags |= F_TAG_STARTED;\r\nif ((currTar_Info->TarStatus & TAR_TAG_Q_MASK)\r\n== TAG_Q_REJECT) {\r\ncurrSCCB->ControlByte &= ~F_USE_CMD_Q;\r\nWRW_HARPOON((port + ID_MSG_STRT),\r\nBRH_OP + ALWAYS + NTCMD);\r\nWRW_HARPOON((port + NON_TAG_ID_MSG),\r\n(MPM_OP + AMSG_OUT +\r\ncurrSCCB->Sccb_idmsg));\r\nWR_HARPOON(port + hp_autostart_3,\r\n(SELECT + SELCHK_STRT));\r\ncurrSCCB->Sccb_scsistat = SELECT_ST;\r\ncurrTar_Info->TarLUNBusy[lun] = 1;\r\n}\r\nelse {\r\nWRW_HARPOON((port + ID_MSG_STRT),\r\n(MPM_OP + AMSG_OUT +\r\ncurrSCCB->Sccb_idmsg));\r\nWRW_HARPOON((port + ID_MSG_STRT + 2),\r\n(MPM_OP + AMSG_OUT +\r\n(((unsigned char)(currSCCB->\r\nControlByte &\r\nTAG_TYPE_MASK)\r\n>> 6) | (unsigned char)0x20)));\r\nfor (i = 1; i < QUEUE_DEPTH; i++) {\r\nif (++lastTag >= QUEUE_DEPTH)\r\nlastTag = 1;\r\nif (CurrCard->discQ_Tbl[lastTag] ==\r\nNULL) {\r\nWRW_HARPOON((port +\r\nID_MSG_STRT + 6),\r\n(MPM_OP + AMSG_OUT +\r\nlastTag));\r\nCurrCard->tagQ_Lst = lastTag;\r\ncurrSCCB->Sccb_tag = lastTag;\r\nCurrCard->discQ_Tbl[lastTag] =\r\ncurrSCCB;\r\nCurrCard->discQCount++;\r\nbreak;\r\n}\r\n}\r\nif (i == QUEUE_DEPTH) {\r\ncurrTar_Info->TarLUNBusy[lun] = 1;\r\nFPT_queueSelectFail(CurrCard, p_card);\r\nSGRAM_ACCESS(port);\r\nreturn;\r\n}\r\ncurrSCCB->Sccb_scsistat = SELECT_Q_ST;\r\nWR_HARPOON(port + hp_autostart_3,\r\n(SELECT + SELCHK_STRT));\r\n}\r\n}\r\nelse {\r\nWRW_HARPOON((port + ID_MSG_STRT),\r\nBRH_OP + ALWAYS + NTCMD);\r\nWRW_HARPOON((port + NON_TAG_ID_MSG),\r\n(MPM_OP + AMSG_OUT + currSCCB->Sccb_idmsg));\r\ncurrSCCB->Sccb_scsistat = SELECT_ST;\r\nWR_HARPOON(port + hp_autostart_3,\r\n(SELECT + SELCHK_STRT));\r\n}\r\ntheCCB = (unsigned char *)&currSCCB->Cdb[0];\r\ncdb_reg = port + CMD_STRT;\r\nfor (i = 0; i < currSCCB->CdbLength; i++) {\r\nWRW_HARPOON(cdb_reg, (MPM_OP + ACOMMAND + *theCCB));\r\ncdb_reg += 2;\r\ntheCCB++;\r\n}\r\nif (currSCCB->CdbLength != TWELVE_BYTE_CMD)\r\nWRW_HARPOON(cdb_reg, (BRH_OP + ALWAYS + NP));\r\n}\r\nWRW_HARPOON((port + hp_fiforead), (unsigned short)0x00);\r\nWR_HARPOON(port + hp_xferstat, 0x00);\r\nWRW_HARPOON((port + hp_intstat), (PROG_HLT | TIMEOUT | SEL | BUS_FREE));\r\nWR_HARPOON(port + hp_portctrl_0, (SCSI_PORT));\r\nif (!(currSCCB->Sccb_MGRFlags & F_DEV_SELECTED)) {\r\nWR_HARPOON(port + hp_scsictrl_0,\r\n(SEL_TAR | ENA_ATN | ENA_RESEL | ENA_SCAM_SEL));\r\n} else {\r\nauto_loaded = AUTO_IMMED;\r\nDISABLE_AUTO(port);\r\nWR_HARPOON(port + hp_autostart_3, auto_loaded);\r\n}\r\nSGRAM_ACCESS(port);\r\n}\r\nstatic void FPT_sres(u32 port, unsigned char p_card,\r\nstruct sccb_card *pCurrCard)\r\n{\r\nunsigned char our_target, message, lun = 0, tag, msgRetryCount;\r\nstruct sccb_mgr_tar_info *currTar_Info;\r\nstruct sccb *currSCCB;\r\nif (pCurrCard->currentSCCB != NULL) {\r\ncurrTar_Info =\r\n&FPT_sccbMgrTbl[p_card][pCurrCard->currentSCCB->TargID];\r\nDISABLE_AUTO(port);\r\nWR_HARPOON((port + hp_scsictrl_0), (ENA_RESEL | ENA_SCAM_SEL));\r\ncurrSCCB = pCurrCard->currentSCCB;\r\nif (currSCCB->Sccb_scsistat == SELECT_WN_ST) {\r\ncurrTar_Info->TarStatus &= ~TAR_WIDE_MASK;\r\ncurrSCCB->Sccb_scsistat = BUS_FREE_ST;\r\n}\r\nif (currSCCB->Sccb_scsistat == SELECT_SN_ST) {\r\ncurrTar_Info->TarStatus &= ~TAR_SYNC_MASK;\r\ncurrSCCB->Sccb_scsistat = BUS_FREE_ST;\r\n}\r\nif (((pCurrCard->globalFlags & F_CONLUN_IO) &&\r\n((currTar_Info->TarStatus & TAR_TAG_Q_MASK) !=\r\nTAG_Q_TRYING))) {\r\ncurrTar_Info->TarLUNBusy[currSCCB->Lun] = 0;\r\nif (currSCCB->Sccb_scsistat != ABORT_ST) {\r\npCurrCard->discQCount--;\r\npCurrCard->discQ_Tbl[currTar_Info->\r\nLunDiscQ_Idx[currSCCB->\r\nLun]]\r\n= NULL;\r\n}\r\n} else {\r\ncurrTar_Info->TarLUNBusy[0] = 0;\r\nif (currSCCB->Sccb_tag) {\r\nif (currSCCB->Sccb_scsistat != ABORT_ST) {\r\npCurrCard->discQCount--;\r\npCurrCard->discQ_Tbl[currSCCB->\r\nSccb_tag] = NULL;\r\n}\r\n} else {\r\nif (currSCCB->Sccb_scsistat != ABORT_ST) {\r\npCurrCard->discQCount--;\r\npCurrCard->discQ_Tbl[currTar_Info->\r\nLunDiscQ_Idx[0]] =\r\nNULL;\r\n}\r\n}\r\n}\r\nFPT_queueSelectFail(&FPT_BL_Card[p_card], p_card);\r\n}\r\nWRW_HARPOON((port + hp_fiforead), (unsigned short)0x00);\r\nour_target = (unsigned char)(RD_HARPOON(port + hp_select_id) >> 4);\r\ncurrTar_Info = &FPT_sccbMgrTbl[p_card][our_target];\r\nmsgRetryCount = 0;\r\ndo {\r\ncurrTar_Info = &FPT_sccbMgrTbl[p_card][our_target];\r\ntag = 0;\r\nwhile (!(RD_HARPOON(port + hp_scsisig) & SCSI_REQ)) {\r\nif (!(RD_HARPOON(port + hp_scsisig) & SCSI_BSY)) {\r\nWRW_HARPOON((port + hp_intstat), PHASE);\r\nreturn;\r\n}\r\n}\r\nWRW_HARPOON((port + hp_intstat), PHASE);\r\nif ((RD_HARPOON(port + hp_scsisig) & S_SCSI_PHZ) == S_MSGI_PH) {\r\nmessage = FPT_sfm(port, pCurrCard->currentSCCB);\r\nif (message) {\r\nif (message <= (0x80 | LUN_MASK)) {\r\nlun = message & (unsigned char)LUN_MASK;\r\nif ((currTar_Info->\r\nTarStatus & TAR_TAG_Q_MASK) ==\r\nTAG_Q_TRYING) {\r\nif (currTar_Info->TarTagQ_Cnt !=\r\n0) {\r\nif (!\r\n(currTar_Info->\r\nTarLUN_CA)) {\r\nACCEPT_MSG(port);\r\nmessage =\r\nFPT_sfm\r\n(port,\r\npCurrCard->\r\ncurrentSCCB);\r\nif (message) {\r\nACCEPT_MSG\r\n(port);\r\n}\r\nelse\r\nmessage\r\n= 0;\r\nif (message !=\r\n0) {\r\ntag =\r\nFPT_sfm\r\n(port,\r\npCurrCard->\r\ncurrentSCCB);\r\nif (!\r\n(tag))\r\nmessage\r\n=\r\n0;\r\n}\r\n}\r\n}\r\n}\r\n}\r\nelse {\r\nACCEPT_MSG_ATN(port);\r\n}\r\n}\r\nelse {\r\nmessage = 0;\r\n}\r\n} else {\r\nACCEPT_MSG_ATN(port);\r\nwhile (!\r\n(RDW_HARPOON((port + hp_intstat)) &\r\n(PHASE | RESET))\r\n&& !(RD_HARPOON(port + hp_scsisig) & SCSI_REQ)\r\n&& (RD_HARPOON(port + hp_scsisig) & SCSI_BSY)) ;\r\nreturn;\r\n}\r\nif (message == 0) {\r\nmsgRetryCount++;\r\nif (msgRetryCount == 1) {\r\nFPT_SendMsg(port, SMPARITY);\r\n} else {\r\nFPT_SendMsg(port, SMDEV_RESET);\r\nFPT_sssyncv(port, our_target, NARROW_SCSI,\r\ncurrTar_Info);\r\nif (FPT_sccbMgrTbl[p_card][our_target].\r\nTarEEValue & EE_SYNC_MASK) {\r\nFPT_sccbMgrTbl[p_card][our_target].\r\nTarStatus &= ~TAR_SYNC_MASK;\r\n}\r\nif (FPT_sccbMgrTbl[p_card][our_target].\r\nTarEEValue & EE_WIDE_SCSI) {\r\nFPT_sccbMgrTbl[p_card][our_target].\r\nTarStatus &= ~TAR_WIDE_MASK;\r\n}\r\nFPT_queueFlushTargSccb(p_card, our_target,\r\nSCCB_COMPLETE);\r\nFPT_SccbMgrTableInitTarget(p_card, our_target);\r\nreturn;\r\n}\r\n}\r\n} while (message == 0);\r\nif (((pCurrCard->globalFlags & F_CONLUN_IO) &&\r\n((currTar_Info->TarStatus & TAR_TAG_Q_MASK) != TAG_Q_TRYING))) {\r\ncurrTar_Info->TarLUNBusy[lun] = 1;\r\npCurrCard->currentSCCB =\r\npCurrCard->discQ_Tbl[currTar_Info->LunDiscQ_Idx[lun]];\r\nif (pCurrCard->currentSCCB != NULL) {\r\nACCEPT_MSG(port);\r\n} else {\r\nACCEPT_MSG_ATN(port);\r\n}\r\n} else {\r\ncurrTar_Info->TarLUNBusy[0] = 1;\r\nif (tag) {\r\nif (pCurrCard->discQ_Tbl[tag] != NULL) {\r\npCurrCard->currentSCCB =\r\npCurrCard->discQ_Tbl[tag];\r\ncurrTar_Info->TarTagQ_Cnt--;\r\nACCEPT_MSG(port);\r\n} else {\r\nACCEPT_MSG_ATN(port);\r\n}\r\n} else {\r\npCurrCard->currentSCCB =\r\npCurrCard->discQ_Tbl[currTar_Info->LunDiscQ_Idx[0]];\r\nif (pCurrCard->currentSCCB != NULL) {\r\nACCEPT_MSG(port);\r\n} else {\r\nACCEPT_MSG_ATN(port);\r\n}\r\n}\r\n}\r\nif (pCurrCard->currentSCCB != NULL) {\r\nif (pCurrCard->currentSCCB->Sccb_scsistat == ABORT_ST) {\r\nFPT_queueFindSccb(pCurrCard->currentSCCB, p_card);\r\n}\r\n}\r\nwhile (!(RDW_HARPOON((port + hp_intstat)) & (PHASE | RESET)) &&\r\n!(RD_HARPOON(port + hp_scsisig) & SCSI_REQ) &&\r\n(RD_HARPOON(port + hp_scsisig) & SCSI_BSY)) ;\r\n}\r\nstatic void FPT_SendMsg(u32 port, unsigned char message)\r\n{\r\nwhile (!(RD_HARPOON(port + hp_scsisig) & SCSI_REQ)) {\r\nif (!(RD_HARPOON(port + hp_scsisig) & SCSI_BSY)) {\r\nWRW_HARPOON((port + hp_intstat), PHASE);\r\nreturn;\r\n}\r\n}\r\nWRW_HARPOON((port + hp_intstat), PHASE);\r\nif ((RD_HARPOON(port + hp_scsisig) & S_SCSI_PHZ) == S_MSGO_PH) {\r\nWRW_HARPOON((port + hp_intstat),\r\n(BUS_FREE | PHASE | XFER_CNT_0));\r\nWR_HARPOON(port + hp_portctrl_0, SCSI_BUS_EN);\r\nWR_HARPOON(port + hp_scsidata_0, message);\r\nWR_HARPOON(port + hp_scsisig, (SCSI_ACK + S_ILL_PH));\r\nACCEPT_MSG(port);\r\nWR_HARPOON(port + hp_portctrl_0, 0x00);\r\nif ((message == SMABORT) || (message == SMDEV_RESET) ||\r\n(message == SMABORT_TAG)) {\r\nwhile (!\r\n(RDW_HARPOON((port + hp_intstat)) &\r\n(BUS_FREE | PHASE))) {\r\n}\r\nif (RDW_HARPOON((port + hp_intstat)) & BUS_FREE) {\r\nWRW_HARPOON((port + hp_intstat), BUS_FREE);\r\n}\r\n}\r\n}\r\n}\r\nstatic void FPT_sdecm(unsigned char message, u32 port, unsigned char p_card)\r\n{\r\nstruct sccb *currSCCB;\r\nstruct sccb_card *CurrCard;\r\nstruct sccb_mgr_tar_info *currTar_Info;\r\nCurrCard = &FPT_BL_Card[p_card];\r\ncurrSCCB = CurrCard->currentSCCB;\r\ncurrTar_Info = &FPT_sccbMgrTbl[p_card][currSCCB->TargID];\r\nif (message == SMREST_DATA_PTR) {\r\nif (!(currSCCB->Sccb_XferState & F_NO_DATA_YET)) {\r\ncurrSCCB->Sccb_ATC = currSCCB->Sccb_savedATC;\r\nFPT_hostDataXferRestart(currSCCB);\r\n}\r\nACCEPT_MSG(port);\r\nWR_HARPOON(port + hp_autostart_1,\r\n(AUTO_IMMED + DISCONNECT_START));\r\n}\r\nelse if (message == SMCMD_COMP) {\r\nif (currSCCB->Sccb_scsistat == SELECT_Q_ST) {\r\ncurrTar_Info->TarStatus &=\r\n~(unsigned char)TAR_TAG_Q_MASK;\r\ncurrTar_Info->TarStatus |= (unsigned char)TAG_Q_REJECT;\r\n}\r\nACCEPT_MSG(port);\r\n}\r\nelse if ((message == SMNO_OP) || (message >= SMIDENT)\r\n|| (message == SMINIT_RECOVERY) || (message == SMREL_RECOVERY)) {\r\nACCEPT_MSG(port);\r\nWR_HARPOON(port + hp_autostart_1,\r\n(AUTO_IMMED + DISCONNECT_START));\r\n}\r\nelse if (message == SMREJECT) {\r\nif ((currSCCB->Sccb_scsistat == SELECT_SN_ST) ||\r\n(currSCCB->Sccb_scsistat == SELECT_WN_ST) ||\r\n((currTar_Info->TarStatus & TAR_SYNC_MASK) == SYNC_TRYING)\r\n|| ((currTar_Info->TarStatus & TAR_TAG_Q_MASK) ==\r\nTAG_Q_TRYING))\r\n{\r\nWRW_HARPOON((port + hp_intstat), BUS_FREE);\r\nACCEPT_MSG(port);\r\nwhile ((!(RD_HARPOON(port + hp_scsisig) & SCSI_REQ)) &&\r\n(!(RDW_HARPOON((port + hp_intstat)) & BUS_FREE)))\r\n{\r\n}\r\nif (currSCCB->Lun == 0x00) {\r\nif ((currSCCB->Sccb_scsistat == SELECT_SN_ST)) {\r\ncurrTar_Info->TarStatus |=\r\n(unsigned char)SYNC_SUPPORTED;\r\ncurrTar_Info->TarEEValue &=\r\n~EE_SYNC_MASK;\r\n}\r\nelse if ((currSCCB->Sccb_scsistat ==\r\nSELECT_WN_ST)) {\r\ncurrTar_Info->TarStatus =\r\n(currTar_Info->\r\nTarStatus & ~WIDE_ENABLED) |\r\nWIDE_NEGOCIATED;\r\ncurrTar_Info->TarEEValue &=\r\n~EE_WIDE_SCSI;\r\n}\r\nelse if ((currTar_Info->\r\nTarStatus & TAR_TAG_Q_MASK) ==\r\nTAG_Q_TRYING) {\r\ncurrTar_Info->TarStatus =\r\n(currTar_Info->\r\nTarStatus & ~(unsigned char)\r\nTAR_TAG_Q_MASK) | TAG_Q_REJECT;\r\ncurrSCCB->ControlByte &= ~F_USE_CMD_Q;\r\nCurrCard->discQCount--;\r\nCurrCard->discQ_Tbl[currSCCB->\r\nSccb_tag] = NULL;\r\ncurrSCCB->Sccb_tag = 0x00;\r\n}\r\n}\r\nif (RDW_HARPOON((port + hp_intstat)) & BUS_FREE) {\r\nif (currSCCB->Lun == 0x00) {\r\nWRW_HARPOON((port + hp_intstat),\r\nBUS_FREE);\r\nCurrCard->globalFlags |= F_NEW_SCCB_CMD;\r\n}\r\n}\r\nelse {\r\nif ((CurrCard->globalFlags & F_CONLUN_IO) &&\r\n((currTar_Info->\r\nTarStatus & TAR_TAG_Q_MASK) !=\r\nTAG_Q_TRYING))\r\ncurrTar_Info->TarLUNBusy[currSCCB->\r\nLun] = 1;\r\nelse\r\ncurrTar_Info->TarLUNBusy[0] = 1;\r\ncurrSCCB->ControlByte &=\r\n~(unsigned char)F_USE_CMD_Q;\r\nWR_HARPOON(port + hp_autostart_1,\r\n(AUTO_IMMED + DISCONNECT_START));\r\n}\r\n}\r\nelse {\r\nACCEPT_MSG(port);\r\nwhile ((!(RD_HARPOON(port + hp_scsisig) & SCSI_REQ)) &&\r\n(!(RDW_HARPOON((port + hp_intstat)) & BUS_FREE)))\r\n{\r\n}\r\nif (!(RDW_HARPOON((port + hp_intstat)) & BUS_FREE)) {\r\nWR_HARPOON(port + hp_autostart_1,\r\n(AUTO_IMMED + DISCONNECT_START));\r\n}\r\n}\r\n}\r\nelse if (message == SMEXT) {\r\nACCEPT_MSG(port);\r\nFPT_shandem(port, p_card, currSCCB);\r\n}\r\nelse if (message == SMIGNORWR) {\r\nACCEPT_MSG(port);\r\nmessage = FPT_sfm(port, currSCCB);\r\nif (currSCCB->Sccb_scsimsg != SMPARITY)\r\nACCEPT_MSG(port);\r\nWR_HARPOON(port + hp_autostart_1,\r\n(AUTO_IMMED + DISCONNECT_START));\r\n}\r\nelse {\r\ncurrSCCB->HostStatus = SCCB_PHASE_SEQUENCE_FAIL;\r\ncurrSCCB->Sccb_scsimsg = SMREJECT;\r\nACCEPT_MSG_ATN(port);\r\nWR_HARPOON(port + hp_autostart_1,\r\n(AUTO_IMMED + DISCONNECT_START));\r\n}\r\n}\r\nstatic void FPT_shandem(u32 port, unsigned char p_card, struct sccb *pCurrSCCB)\r\n{\r\nunsigned char length, message;\r\nlength = FPT_sfm(port, pCurrSCCB);\r\nif (length) {\r\nACCEPT_MSG(port);\r\nmessage = FPT_sfm(port, pCurrSCCB);\r\nif (message) {\r\nif (message == SMSYNC) {\r\nif (length == 0x03) {\r\nACCEPT_MSG(port);\r\nFPT_stsyncn(port, p_card);\r\n} else {\r\npCurrSCCB->Sccb_scsimsg = SMREJECT;\r\nACCEPT_MSG_ATN(port);\r\n}\r\n} else if (message == SMWDTR) {\r\nif (length == 0x02) {\r\nACCEPT_MSG(port);\r\nFPT_stwidn(port, p_card);\r\n} else {\r\npCurrSCCB->Sccb_scsimsg = SMREJECT;\r\nACCEPT_MSG_ATN(port);\r\nWR_HARPOON(port + hp_autostart_1,\r\n(AUTO_IMMED +\r\nDISCONNECT_START));\r\n}\r\n} else {\r\npCurrSCCB->Sccb_scsimsg = SMREJECT;\r\nACCEPT_MSG_ATN(port);\r\nWR_HARPOON(port + hp_autostart_1,\r\n(AUTO_IMMED + DISCONNECT_START));\r\n}\r\n} else {\r\nif (pCurrSCCB->Sccb_scsimsg != SMPARITY)\r\nACCEPT_MSG(port);\r\nWR_HARPOON(port + hp_autostart_1,\r\n(AUTO_IMMED + DISCONNECT_START));\r\n}\r\n} else {\r\nif (pCurrSCCB->Sccb_scsimsg == SMPARITY)\r\nWR_HARPOON(port + hp_autostart_1,\r\n(AUTO_IMMED + DISCONNECT_START));\r\n}\r\n}\r\nstatic unsigned char FPT_sisyncn(u32 port, unsigned char p_card,\r\nunsigned char syncFlag)\r\n{\r\nstruct sccb *currSCCB;\r\nstruct sccb_mgr_tar_info *currTar_Info;\r\ncurrSCCB = FPT_BL_Card[p_card].currentSCCB;\r\ncurrTar_Info = &FPT_sccbMgrTbl[p_card][currSCCB->TargID];\r\nif (!((currTar_Info->TarStatus & TAR_SYNC_MASK) == SYNC_TRYING)) {\r\nWRW_HARPOON((port + ID_MSG_STRT),\r\n(MPM_OP + AMSG_OUT +\r\n(currSCCB->\r\nSccb_idmsg & ~(unsigned char)DISC_PRIV)));\r\nWRW_HARPOON((port + ID_MSG_STRT + 2), BRH_OP + ALWAYS + CMDPZ);\r\nWRW_HARPOON((port + SYNC_MSGS + 0),\r\n(MPM_OP + AMSG_OUT + SMEXT));\r\nWRW_HARPOON((port + SYNC_MSGS + 2), (MPM_OP + AMSG_OUT + 0x03));\r\nWRW_HARPOON((port + SYNC_MSGS + 4),\r\n(MPM_OP + AMSG_OUT + SMSYNC));\r\nif ((currTar_Info->TarEEValue & EE_SYNC_MASK) == EE_SYNC_20MB)\r\nWRW_HARPOON((port + SYNC_MSGS + 6),\r\n(MPM_OP + AMSG_OUT + 12));\r\nelse if ((currTar_Info->TarEEValue & EE_SYNC_MASK) ==\r\nEE_SYNC_10MB)\r\nWRW_HARPOON((port + SYNC_MSGS + 6),\r\n(MPM_OP + AMSG_OUT + 25));\r\nelse if ((currTar_Info->TarEEValue & EE_SYNC_MASK) ==\r\nEE_SYNC_5MB)\r\nWRW_HARPOON((port + SYNC_MSGS + 6),\r\n(MPM_OP + AMSG_OUT + 50));\r\nelse\r\nWRW_HARPOON((port + SYNC_MSGS + 6),\r\n(MPM_OP + AMSG_OUT + 00));\r\nWRW_HARPOON((port + SYNC_MSGS + 8), (RAT_OP));\r\nWRW_HARPOON((port + SYNC_MSGS + 10),\r\n(MPM_OP + AMSG_OUT + DEFAULT_OFFSET));\r\nWRW_HARPOON((port + SYNC_MSGS + 12), (BRH_OP + ALWAYS + NP));\r\nif (syncFlag == 0) {\r\nWR_HARPOON(port + hp_autostart_3,\r\n(SELECT + SELCHK_STRT));\r\ncurrTar_Info->TarStatus =\r\n((currTar_Info->\r\nTarStatus & ~(unsigned char)TAR_SYNC_MASK) |\r\n(unsigned char)SYNC_TRYING);\r\n} else {\r\nWR_HARPOON(port + hp_autostart_3,\r\n(AUTO_IMMED + CMD_ONLY_STRT));\r\n}\r\nreturn 1;\r\n}\r\nelse {\r\ncurrTar_Info->TarStatus |= (unsigned char)SYNC_SUPPORTED;\r\ncurrTar_Info->TarEEValue &= ~EE_SYNC_MASK;\r\nreturn 0;\r\n}\r\n}\r\nstatic void FPT_stsyncn(u32 port, unsigned char p_card)\r\n{\r\nunsigned char sync_msg, offset, sync_reg, our_sync_msg;\r\nstruct sccb *currSCCB;\r\nstruct sccb_mgr_tar_info *currTar_Info;\r\ncurrSCCB = FPT_BL_Card[p_card].currentSCCB;\r\ncurrTar_Info = &FPT_sccbMgrTbl[p_card][currSCCB->TargID];\r\nsync_msg = FPT_sfm(port, currSCCB);\r\nif ((sync_msg == 0x00) && (currSCCB->Sccb_scsimsg == SMPARITY)) {\r\nWR_HARPOON(port + hp_autostart_1,\r\n(AUTO_IMMED + DISCONNECT_START));\r\nreturn;\r\n}\r\nACCEPT_MSG(port);\r\noffset = FPT_sfm(port, currSCCB);\r\nif ((offset == 0x00) && (currSCCB->Sccb_scsimsg == SMPARITY)) {\r\nWR_HARPOON(port + hp_autostart_1,\r\n(AUTO_IMMED + DISCONNECT_START));\r\nreturn;\r\n}\r\nif ((currTar_Info->TarEEValue & EE_SYNC_MASK) == EE_SYNC_20MB)\r\nour_sync_msg = 12;\r\nelse if ((currTar_Info->TarEEValue & EE_SYNC_MASK) == EE_SYNC_10MB)\r\nour_sync_msg = 25;\r\nelse if ((currTar_Info->TarEEValue & EE_SYNC_MASK) == EE_SYNC_5MB)\r\nour_sync_msg = 50;\r\nelse\r\nour_sync_msg = 0;\r\nif (sync_msg < our_sync_msg) {\r\nsync_msg = our_sync_msg;\r\n}\r\nif (offset == ASYNC)\r\nsync_msg = ASYNC;\r\nif (offset > MAX_OFFSET)\r\noffset = MAX_OFFSET;\r\nsync_reg = 0x00;\r\nif (sync_msg > 12)\r\nsync_reg = 0x20;\r\nif (sync_msg > 25)\r\nsync_reg = 0x40;\r\nif (sync_msg > 38)\r\nsync_reg = 0x60;\r\nif (sync_msg > 50)\r\nsync_reg = 0x80;\r\nif (sync_msg > 62)\r\nsync_reg = 0xA0;\r\nif (sync_msg > 75)\r\nsync_reg = 0xC0;\r\nif (sync_msg > 87)\r\nsync_reg = 0xE0;\r\nif (sync_msg > 100) {\r\nsync_reg = 0x00;\r\noffset = 0x00;\r\n}\r\nif (currTar_Info->TarStatus & WIDE_ENABLED)\r\nsync_reg |= offset;\r\nelse\r\nsync_reg |= (offset | NARROW_SCSI);\r\nFPT_sssyncv(port, currSCCB->TargID, sync_reg, currTar_Info);\r\nif (currSCCB->Sccb_scsistat == SELECT_SN_ST) {\r\nACCEPT_MSG(port);\r\ncurrTar_Info->TarStatus = ((currTar_Info->TarStatus &\r\n~(unsigned char)TAR_SYNC_MASK) |\r\n(unsigned char)SYNC_SUPPORTED);\r\nWR_HARPOON(port + hp_autostart_1,\r\n(AUTO_IMMED + DISCONNECT_START));\r\n}\r\nelse {\r\nACCEPT_MSG_ATN(port);\r\nFPT_sisyncr(port, sync_msg, offset);\r\ncurrTar_Info->TarStatus = ((currTar_Info->TarStatus &\r\n~(unsigned char)TAR_SYNC_MASK) |\r\n(unsigned char)SYNC_SUPPORTED);\r\n}\r\n}\r\nstatic void FPT_sisyncr(u32 port, unsigned char sync_pulse,\r\nunsigned char offset)\r\n{\r\nARAM_ACCESS(port);\r\nWRW_HARPOON((port + SYNC_MSGS + 0), (MPM_OP + AMSG_OUT + SMEXT));\r\nWRW_HARPOON((port + SYNC_MSGS + 2), (MPM_OP + AMSG_OUT + 0x03));\r\nWRW_HARPOON((port + SYNC_MSGS + 4), (MPM_OP + AMSG_OUT + SMSYNC));\r\nWRW_HARPOON((port + SYNC_MSGS + 6), (MPM_OP + AMSG_OUT + sync_pulse));\r\nWRW_HARPOON((port + SYNC_MSGS + 8), (RAT_OP));\r\nWRW_HARPOON((port + SYNC_MSGS + 10), (MPM_OP + AMSG_OUT + offset));\r\nWRW_HARPOON((port + SYNC_MSGS + 12), (BRH_OP + ALWAYS + NP));\r\nSGRAM_ACCESS(port);\r\nWR_HARPOON(port + hp_portctrl_0, SCSI_PORT);\r\nWRW_HARPOON((port + hp_intstat), CLR_ALL_INT_1);\r\nWR_HARPOON(port + hp_autostart_3, (AUTO_IMMED + CMD_ONLY_STRT));\r\nwhile (!(RDW_HARPOON((port + hp_intstat)) & (BUS_FREE | AUTO_INT))) {\r\n}\r\n}\r\nstatic unsigned char FPT_siwidn(u32 port, unsigned char p_card)\r\n{\r\nstruct sccb *currSCCB;\r\nstruct sccb_mgr_tar_info *currTar_Info;\r\ncurrSCCB = FPT_BL_Card[p_card].currentSCCB;\r\ncurrTar_Info = &FPT_sccbMgrTbl[p_card][currSCCB->TargID];\r\nif (!((currTar_Info->TarStatus & TAR_WIDE_MASK) == WIDE_NEGOCIATED)) {\r\nWRW_HARPOON((port + ID_MSG_STRT),\r\n(MPM_OP + AMSG_OUT +\r\n(currSCCB->\r\nSccb_idmsg & ~(unsigned char)DISC_PRIV)));\r\nWRW_HARPOON((port + ID_MSG_STRT + 2), BRH_OP + ALWAYS + CMDPZ);\r\nWRW_HARPOON((port + SYNC_MSGS + 0),\r\n(MPM_OP + AMSG_OUT + SMEXT));\r\nWRW_HARPOON((port + SYNC_MSGS + 2), (MPM_OP + AMSG_OUT + 0x02));\r\nWRW_HARPOON((port + SYNC_MSGS + 4),\r\n(MPM_OP + AMSG_OUT + SMWDTR));\r\nWRW_HARPOON((port + SYNC_MSGS + 6), (RAT_OP));\r\nWRW_HARPOON((port + SYNC_MSGS + 8),\r\n(MPM_OP + AMSG_OUT + SM16BIT));\r\nWRW_HARPOON((port + SYNC_MSGS + 10), (BRH_OP + ALWAYS + NP));\r\nWR_HARPOON(port + hp_autostart_3, (SELECT + SELCHK_STRT));\r\ncurrTar_Info->TarStatus = ((currTar_Info->TarStatus &\r\n~(unsigned char)TAR_WIDE_MASK) |\r\n(unsigned char)WIDE_ENABLED);\r\nreturn 1;\r\n}\r\nelse {\r\ncurrTar_Info->TarStatus = ((currTar_Info->TarStatus &\r\n~(unsigned char)TAR_WIDE_MASK) |\r\nWIDE_NEGOCIATED);\r\ncurrTar_Info->TarEEValue &= ~EE_WIDE_SCSI;\r\nreturn 0;\r\n}\r\n}\r\nstatic void FPT_stwidn(u32 port, unsigned char p_card)\r\n{\r\nunsigned char width;\r\nstruct sccb *currSCCB;\r\nstruct sccb_mgr_tar_info *currTar_Info;\r\ncurrSCCB = FPT_BL_Card[p_card].currentSCCB;\r\ncurrTar_Info = &FPT_sccbMgrTbl[p_card][currSCCB->TargID];\r\nwidth = FPT_sfm(port, currSCCB);\r\nif ((width == 0x00) && (currSCCB->Sccb_scsimsg == SMPARITY)) {\r\nWR_HARPOON(port + hp_autostart_1,\r\n(AUTO_IMMED + DISCONNECT_START));\r\nreturn;\r\n}\r\nif (!(currTar_Info->TarEEValue & EE_WIDE_SCSI))\r\nwidth = 0;\r\nif (width) {\r\ncurrTar_Info->TarStatus |= WIDE_ENABLED;\r\nwidth = 0;\r\n} else {\r\nwidth = NARROW_SCSI;\r\ncurrTar_Info->TarStatus &= ~WIDE_ENABLED;\r\n}\r\nFPT_sssyncv(port, currSCCB->TargID, width, currTar_Info);\r\nif (currSCCB->Sccb_scsistat == SELECT_WN_ST) {\r\ncurrTar_Info->TarStatus |= WIDE_NEGOCIATED;\r\nif (!\r\n((currTar_Info->TarStatus & TAR_SYNC_MASK) ==\r\nSYNC_SUPPORTED)) {\r\nACCEPT_MSG_ATN(port);\r\nARAM_ACCESS(port);\r\nFPT_sisyncn(port, p_card, 1);\r\ncurrSCCB->Sccb_scsistat = SELECT_SN_ST;\r\nSGRAM_ACCESS(port);\r\n} else {\r\nACCEPT_MSG(port);\r\nWR_HARPOON(port + hp_autostart_1,\r\n(AUTO_IMMED + DISCONNECT_START));\r\n}\r\n}\r\nelse {\r\nACCEPT_MSG_ATN(port);\r\nif (currTar_Info->TarEEValue & EE_WIDE_SCSI)\r\nwidth = SM16BIT;\r\nelse\r\nwidth = SM8BIT;\r\nFPT_siwidr(port, width);\r\ncurrTar_Info->TarStatus |= (WIDE_NEGOCIATED | WIDE_ENABLED);\r\n}\r\n}\r\nstatic void FPT_siwidr(u32 port, unsigned char width)\r\n{\r\nARAM_ACCESS(port);\r\nWRW_HARPOON((port + SYNC_MSGS + 0), (MPM_OP + AMSG_OUT + SMEXT));\r\nWRW_HARPOON((port + SYNC_MSGS + 2), (MPM_OP + AMSG_OUT + 0x02));\r\nWRW_HARPOON((port + SYNC_MSGS + 4), (MPM_OP + AMSG_OUT + SMWDTR));\r\nWRW_HARPOON((port + SYNC_MSGS + 6), (RAT_OP));\r\nWRW_HARPOON((port + SYNC_MSGS + 8), (MPM_OP + AMSG_OUT + width));\r\nWRW_HARPOON((port + SYNC_MSGS + 10), (BRH_OP + ALWAYS + NP));\r\nSGRAM_ACCESS(port);\r\nWR_HARPOON(port + hp_portctrl_0, SCSI_PORT);\r\nWRW_HARPOON((port + hp_intstat), CLR_ALL_INT_1);\r\nWR_HARPOON(port + hp_autostart_3, (AUTO_IMMED + CMD_ONLY_STRT));\r\nwhile (!(RDW_HARPOON((port + hp_intstat)) & (BUS_FREE | AUTO_INT))) {\r\n}\r\n}\r\nstatic void FPT_sssyncv(u32 p_port, unsigned char p_id,\r\nunsigned char p_sync_value,\r\nstruct sccb_mgr_tar_info *currTar_Info)\r\n{\r\nunsigned char index;\r\nindex = p_id;\r\nswitch (index) {\r\ncase 0:\r\nindex = 12;\r\nbreak;\r\ncase 1:\r\nindex = 13;\r\nbreak;\r\ncase 2:\r\nindex = 14;\r\nbreak;\r\ncase 3:\r\nindex = 15;\r\nbreak;\r\ncase 4:\r\nindex = 8;\r\nbreak;\r\ncase 5:\r\nindex = 9;\r\nbreak;\r\ncase 6:\r\nindex = 10;\r\nbreak;\r\ncase 7:\r\nindex = 11;\r\nbreak;\r\ncase 8:\r\nindex = 4;\r\nbreak;\r\ncase 9:\r\nindex = 5;\r\nbreak;\r\ncase 10:\r\nindex = 6;\r\nbreak;\r\ncase 11:\r\nindex = 7;\r\nbreak;\r\ncase 12:\r\nindex = 0;\r\nbreak;\r\ncase 13:\r\nindex = 1;\r\nbreak;\r\ncase 14:\r\nindex = 2;\r\nbreak;\r\ncase 15:\r\nindex = 3;\r\n}\r\nWR_HARPOON(p_port + hp_synctarg_base + index, p_sync_value);\r\ncurrTar_Info->TarSyncCtrl = p_sync_value;\r\n}\r\nstatic void FPT_sresb(u32 port, unsigned char p_card)\r\n{\r\nunsigned char scsiID, i;\r\nstruct sccb_mgr_tar_info *currTar_Info;\r\nWR_HARPOON(port + hp_page_ctrl,\r\n(RD_HARPOON(port + hp_page_ctrl) | G_INT_DISABLE));\r\nWRW_HARPOON((port + hp_intstat), CLR_ALL_INT);\r\nWR_HARPOON(port + hp_scsictrl_0, SCSI_RST);\r\nscsiID = RD_HARPOON(port + hp_seltimeout);\r\nWR_HARPOON(port + hp_seltimeout, TO_5ms);\r\nWRW_HARPOON((port + hp_intstat), TIMEOUT);\r\nWR_HARPOON(port + hp_portctrl_0, (SCSI_PORT | START_TO));\r\nwhile (!(RDW_HARPOON((port + hp_intstat)) & TIMEOUT)) {\r\n}\r\nWR_HARPOON(port + hp_seltimeout, scsiID);\r\nWR_HARPOON(port + hp_scsictrl_0, ENA_SCAM_SEL);\r\nFPT_Wait(port, TO_5ms);\r\nWRW_HARPOON((port + hp_intstat), CLR_ALL_INT);\r\nWR_HARPOON(port + hp_int_mask, (RD_HARPOON(port + hp_int_mask) | 0x00));\r\nfor (scsiID = 0; scsiID < MAX_SCSI_TAR; scsiID++) {\r\ncurrTar_Info = &FPT_sccbMgrTbl[p_card][scsiID];\r\nif (currTar_Info->TarEEValue & EE_SYNC_MASK) {\r\ncurrTar_Info->TarSyncCtrl = 0;\r\ncurrTar_Info->TarStatus &= ~TAR_SYNC_MASK;\r\n}\r\nif (currTar_Info->TarEEValue & EE_WIDE_SCSI) {\r\ncurrTar_Info->TarStatus &= ~TAR_WIDE_MASK;\r\n}\r\nFPT_sssyncv(port, scsiID, NARROW_SCSI, currTar_Info);\r\nFPT_SccbMgrTableInitTarget(p_card, scsiID);\r\n}\r\nFPT_BL_Card[p_card].scanIndex = 0x00;\r\nFPT_BL_Card[p_card].currentSCCB = NULL;\r\nFPT_BL_Card[p_card].globalFlags &= ~(F_TAG_STARTED | F_HOST_XFER_ACT\r\n| F_NEW_SCCB_CMD);\r\nFPT_BL_Card[p_card].cmdCounter = 0x00;\r\nFPT_BL_Card[p_card].discQCount = 0x00;\r\nFPT_BL_Card[p_card].tagQ_Lst = 0x01;\r\nfor (i = 0; i < QUEUE_DEPTH; i++)\r\nFPT_BL_Card[p_card].discQ_Tbl[i] = NULL;\r\nWR_HARPOON(port + hp_page_ctrl,\r\n(RD_HARPOON(port + hp_page_ctrl) & ~G_INT_DISABLE));\r\n}\r\nstatic void FPT_ssenss(struct sccb_card *pCurrCard)\r\n{\r\nunsigned char i;\r\nstruct sccb *currSCCB;\r\ncurrSCCB = pCurrCard->currentSCCB;\r\ncurrSCCB->Save_CdbLen = currSCCB->CdbLength;\r\nfor (i = 0; i < 6; i++) {\r\ncurrSCCB->Save_Cdb[i] = currSCCB->Cdb[i];\r\n}\r\ncurrSCCB->CdbLength = SIX_BYTE_CMD;\r\ncurrSCCB->Cdb[0] = SCSI_REQUEST_SENSE;\r\ncurrSCCB->Cdb[1] = currSCCB->Cdb[1] & (unsigned char)0xE0;\r\ncurrSCCB->Cdb[2] = 0x00;\r\ncurrSCCB->Cdb[3] = 0x00;\r\ncurrSCCB->Cdb[4] = currSCCB->RequestSenseLength;\r\ncurrSCCB->Cdb[5] = 0x00;\r\ncurrSCCB->Sccb_XferCnt = (u32)currSCCB->RequestSenseLength;\r\ncurrSCCB->Sccb_ATC = 0x00;\r\ncurrSCCB->Sccb_XferState |= F_AUTO_SENSE;\r\ncurrSCCB->Sccb_XferState &= ~F_SG_XFER;\r\ncurrSCCB->Sccb_idmsg = currSCCB->Sccb_idmsg & ~(unsigned char)DISC_PRIV;\r\ncurrSCCB->ControlByte = 0x00;\r\ncurrSCCB->Sccb_MGRFlags &= F_STATUSLOADED;\r\n}\r\nstatic void FPT_sxfrp(u32 p_port, unsigned char p_card)\r\n{\r\nunsigned char curr_phz;\r\nDISABLE_AUTO(p_port);\r\nif (FPT_BL_Card[p_card].globalFlags & F_HOST_XFER_ACT) {\r\nFPT_hostDataXferAbort(p_port, p_card,\r\nFPT_BL_Card[p_card].currentSCCB);\r\n}\r\nif (RDW_HARPOON((p_port + hp_intstat)) &\r\n(BUS_FREE | XFER_CNT_0 | AUTO_INT))\r\nreturn;\r\nWR_HARPOON(p_port + hp_xfercnt_0, 0x00);\r\ncurr_phz = RD_HARPOON(p_port + hp_scsisig) & (unsigned char)S_SCSI_PHZ;\r\nWRW_HARPOON((p_port + hp_intstat), XFER_CNT_0);\r\nWR_HARPOON(p_port + hp_scsisig, curr_phz);\r\nwhile (!(RDW_HARPOON((p_port + hp_intstat)) & (BUS_FREE | RESET)) &&\r\n(curr_phz ==\r\n(RD_HARPOON(p_port + hp_scsisig) & (unsigned char)S_SCSI_PHZ)))\r\n{\r\nif (curr_phz & (unsigned char)SCSI_IOBIT) {\r\nWR_HARPOON(p_port + hp_portctrl_0,\r\n(SCSI_PORT | HOST_PORT | SCSI_INBIT));\r\nif (!(RD_HARPOON(p_port + hp_xferstat) & FIFO_EMPTY)) {\r\nRD_HARPOON(p_port + hp_fifodata_0);\r\n}\r\n} else {\r\nWR_HARPOON(p_port + hp_portctrl_0,\r\n(SCSI_PORT | HOST_PORT | HOST_WRT));\r\nif (RD_HARPOON(p_port + hp_xferstat) & FIFO_EMPTY) {\r\nWR_HARPOON(p_port + hp_fifodata_0, 0xFA);\r\n}\r\n}\r\n}\r\nwhile (!(RDW_HARPOON((p_port + hp_intstat)) & (BUS_FREE | RESET))) {\r\nif (RD_HARPOON(p_port + hp_scsisig) & SCSI_REQ)\r\nbreak;\r\n}\r\nWR_HARPOON(p_port + hp_portctrl_0,\r\n(SCSI_PORT | HOST_PORT | SCSI_INBIT));\r\nwhile (!(RD_HARPOON(p_port + hp_xferstat) & FIFO_EMPTY)) {\r\nRD_HARPOON(p_port + hp_fifodata_0);\r\n}\r\nif (!(RDW_HARPOON((p_port + hp_intstat)) & (BUS_FREE | RESET))) {\r\nWR_HARPOON(p_port + hp_autostart_0,\r\n(AUTO_IMMED + DISCONNECT_START));\r\nwhile (!(RDW_HARPOON((p_port + hp_intstat)) & AUTO_INT)) {\r\n}\r\nif (RDW_HARPOON((p_port + hp_intstat)) &\r\n(ICMD_COMP | ITAR_DISC))\r\nwhile (!\r\n(RDW_HARPOON((p_port + hp_intstat)) &\r\n(BUS_FREE | RSEL))) ;\r\n}\r\n}\r\nstatic void FPT_schkdd(u32 port, unsigned char p_card)\r\n{\r\nunsigned short TimeOutLoop;\r\nunsigned char sPhase;\r\nstruct sccb *currSCCB;\r\ncurrSCCB = FPT_BL_Card[p_card].currentSCCB;\r\nif ((currSCCB->Sccb_scsistat != DATA_OUT_ST) &&\r\n(currSCCB->Sccb_scsistat != DATA_IN_ST)) {\r\nreturn;\r\n}\r\nif (currSCCB->Sccb_XferState & F_ODD_BALL_CNT) {\r\ncurrSCCB->Sccb_ATC += (currSCCB->Sccb_XferCnt - 1);\r\ncurrSCCB->Sccb_XferCnt = 1;\r\ncurrSCCB->Sccb_XferState &= ~F_ODD_BALL_CNT;\r\nWRW_HARPOON((port + hp_fiforead), (unsigned short)0x00);\r\nWR_HARPOON(port + hp_xferstat, 0x00);\r\n}\r\nelse {\r\ncurrSCCB->Sccb_ATC += currSCCB->Sccb_XferCnt;\r\ncurrSCCB->Sccb_XferCnt = 0;\r\n}\r\nif ((RDW_HARPOON((port + hp_intstat)) & PARITY) &&\r\n(currSCCB->HostStatus == SCCB_COMPLETE)) {\r\ncurrSCCB->HostStatus = SCCB_PARITY_ERR;\r\nWRW_HARPOON((port + hp_intstat), PARITY);\r\n}\r\nFPT_hostDataXferAbort(port, p_card, currSCCB);\r\nwhile (RD_HARPOON(port + hp_scsisig) & SCSI_ACK) {\r\n}\r\nTimeOutLoop = 0;\r\nwhile (RD_HARPOON(port + hp_xferstat) & FIFO_EMPTY) {\r\nif (RDW_HARPOON((port + hp_intstat)) & BUS_FREE) {\r\nreturn;\r\n}\r\nif (RD_HARPOON(port + hp_offsetctr) & (unsigned char)0x1F) {\r\nbreak;\r\n}\r\nif (RDW_HARPOON((port + hp_intstat)) & RESET) {\r\nreturn;\r\n}\r\nif ((RD_HARPOON(port + hp_scsisig) & SCSI_REQ)\r\n|| (TimeOutLoop++ > 0x3000))\r\nbreak;\r\n}\r\nsPhase = RD_HARPOON(port + hp_scsisig) & (SCSI_BSY | S_SCSI_PHZ);\r\nif ((!(RD_HARPOON(port + hp_xferstat) & FIFO_EMPTY)) ||\r\n(RD_HARPOON(port + hp_offsetctr) & (unsigned char)0x1F) ||\r\n(sPhase == (SCSI_BSY | S_DATAO_PH)) ||\r\n(sPhase == (SCSI_BSY | S_DATAI_PH))) {\r\nWR_HARPOON(port + hp_portctrl_0, SCSI_PORT);\r\nif (!(currSCCB->Sccb_XferState & F_ALL_XFERRED)) {\r\nif (currSCCB->Sccb_XferState & F_HOST_XFER_DIR) {\r\nFPT_phaseDataIn(port, p_card);\r\n}\r\nelse {\r\nFPT_phaseDataOut(port, p_card);\r\n}\r\n} else {\r\nFPT_sxfrp(port, p_card);\r\nif (!(RDW_HARPOON((port + hp_intstat)) &\r\n(BUS_FREE | ICMD_COMP | ITAR_DISC | RESET))) {\r\nWRW_HARPOON((port + hp_intstat), AUTO_INT);\r\nFPT_phaseDecode(port, p_card);\r\n}\r\n}\r\n}\r\nelse {\r\nWR_HARPOON(port + hp_portctrl_0, 0x00);\r\n}\r\n}\r\nstatic void FPT_sinits(struct sccb *p_sccb, unsigned char p_card)\r\n{\r\nstruct sccb_mgr_tar_info *currTar_Info;\r\nif ((p_sccb->TargID >= MAX_SCSI_TAR) || (p_sccb->Lun >= MAX_LUN)) {\r\nreturn;\r\n}\r\ncurrTar_Info = &FPT_sccbMgrTbl[p_card][p_sccb->TargID];\r\np_sccb->Sccb_XferState = 0x00;\r\np_sccb->Sccb_XferCnt = p_sccb->DataLength;\r\nif ((p_sccb->OperationCode == SCATTER_GATHER_COMMAND) ||\r\n(p_sccb->OperationCode == RESIDUAL_SG_COMMAND)) {\r\np_sccb->Sccb_SGoffset = 0;\r\np_sccb->Sccb_XferState = F_SG_XFER;\r\np_sccb->Sccb_XferCnt = 0x00;\r\n}\r\nif (p_sccb->DataLength == 0x00)\r\np_sccb->Sccb_XferState |= F_ALL_XFERRED;\r\nif (p_sccb->ControlByte & F_USE_CMD_Q) {\r\nif ((currTar_Info->TarStatus & TAR_TAG_Q_MASK) == TAG_Q_REJECT)\r\np_sccb->ControlByte &= ~F_USE_CMD_Q;\r\nelse\r\ncurrTar_Info->TarStatus |= TAG_Q_TRYING;\r\n}\r\nif ((currTar_Info->TarStatus & TAR_ALLOW_DISC) ||\r\n(currTar_Info->TarStatus & TAG_Q_TRYING)) {\r\np_sccb->Sccb_idmsg =\r\n(unsigned char)(SMIDENT | DISC_PRIV) | p_sccb->Lun;\r\n}\r\nelse {\r\np_sccb->Sccb_idmsg = (unsigned char)SMIDENT | p_sccb->Lun;\r\n}\r\np_sccb->HostStatus = 0x00;\r\np_sccb->TargetStatus = 0x00;\r\np_sccb->Sccb_tag = 0x00;\r\np_sccb->Sccb_MGRFlags = 0x00;\r\np_sccb->Sccb_sgseg = 0x00;\r\np_sccb->Sccb_ATC = 0x00;\r\np_sccb->Sccb_savedATC = 0x00;\r\np_sccb->Sccb_scsistat = BUS_FREE_ST;\r\np_sccb->SccbStatus = SCCB_IN_PROCESS;\r\np_sccb->Sccb_scsimsg = SMNO_OP;\r\n}\r\nstatic void FPT_phaseDecode(u32 p_port, unsigned char p_card)\r\n{\r\nunsigned char phase_ref;\r\nvoid (*phase) (u32, unsigned char);\r\nDISABLE_AUTO(p_port);\r\nphase_ref =\r\n(unsigned char)(RD_HARPOON(p_port + hp_scsisig) & S_SCSI_PHZ);\r\nphase = FPT_s_PhaseTbl[phase_ref];\r\n(*phase) (p_port, p_card);\r\n}\r\nstatic void FPT_phaseDataOut(u32 port, unsigned char p_card)\r\n{\r\nstruct sccb *currSCCB;\r\ncurrSCCB = FPT_BL_Card[p_card].currentSCCB;\r\nif (currSCCB == NULL) {\r\nreturn;\r\n}\r\ncurrSCCB->Sccb_scsistat = DATA_OUT_ST;\r\ncurrSCCB->Sccb_XferState &= ~(F_HOST_XFER_DIR | F_NO_DATA_YET);\r\nWR_HARPOON(port + hp_portctrl_0, SCSI_PORT);\r\nWRW_HARPOON((port + hp_intstat), XFER_CNT_0);\r\nWR_HARPOON(port + hp_autostart_0, (END_DATA + END_DATA_START));\r\nFPT_dataXferProcessor(port, &FPT_BL_Card[p_card]);\r\nif (currSCCB->Sccb_XferCnt == 0) {\r\nif ((currSCCB->ControlByte & SCCB_DATA_XFER_OUT) &&\r\n(currSCCB->HostStatus == SCCB_COMPLETE))\r\ncurrSCCB->HostStatus = SCCB_DATA_OVER_RUN;\r\nFPT_sxfrp(port, p_card);\r\nif (!(RDW_HARPOON((port + hp_intstat)) & (BUS_FREE | RESET)))\r\nFPT_phaseDecode(port, p_card);\r\n}\r\n}\r\nstatic void FPT_phaseDataIn(u32 port, unsigned char p_card)\r\n{\r\nstruct sccb *currSCCB;\r\ncurrSCCB = FPT_BL_Card[p_card].currentSCCB;\r\nif (currSCCB == NULL) {\r\nreturn;\r\n}\r\ncurrSCCB->Sccb_scsistat = DATA_IN_ST;\r\ncurrSCCB->Sccb_XferState |= F_HOST_XFER_DIR;\r\ncurrSCCB->Sccb_XferState &= ~F_NO_DATA_YET;\r\nWR_HARPOON(port + hp_portctrl_0, SCSI_PORT);\r\nWRW_HARPOON((port + hp_intstat), XFER_CNT_0);\r\nWR_HARPOON(port + hp_autostart_0, (END_DATA + END_DATA_START));\r\nFPT_dataXferProcessor(port, &FPT_BL_Card[p_card]);\r\nif (currSCCB->Sccb_XferCnt == 0) {\r\nif ((currSCCB->ControlByte & SCCB_DATA_XFER_IN) &&\r\n(currSCCB->HostStatus == SCCB_COMPLETE))\r\ncurrSCCB->HostStatus = SCCB_DATA_OVER_RUN;\r\nFPT_sxfrp(port, p_card);\r\nif (!(RDW_HARPOON((port + hp_intstat)) & (BUS_FREE | RESET)))\r\nFPT_phaseDecode(port, p_card);\r\n}\r\n}\r\nstatic void FPT_phaseCommand(u32 p_port, unsigned char p_card)\r\n{\r\nstruct sccb *currSCCB;\r\nu32 cdb_reg;\r\nunsigned char i;\r\ncurrSCCB = FPT_BL_Card[p_card].currentSCCB;\r\nif (currSCCB->OperationCode == RESET_COMMAND) {\r\ncurrSCCB->HostStatus = SCCB_PHASE_SEQUENCE_FAIL;\r\ncurrSCCB->CdbLength = SIX_BYTE_CMD;\r\n}\r\nWR_HARPOON(p_port + hp_scsisig, 0x00);\r\nARAM_ACCESS(p_port);\r\ncdb_reg = p_port + CMD_STRT;\r\nfor (i = 0; i < currSCCB->CdbLength; i++) {\r\nif (currSCCB->OperationCode == RESET_COMMAND)\r\nWRW_HARPOON(cdb_reg, (MPM_OP + ACOMMAND + 0x00));\r\nelse\r\nWRW_HARPOON(cdb_reg,\r\n(MPM_OP + ACOMMAND + currSCCB->Cdb[i]));\r\ncdb_reg += 2;\r\n}\r\nif (currSCCB->CdbLength != TWELVE_BYTE_CMD)\r\nWRW_HARPOON(cdb_reg, (BRH_OP + ALWAYS + NP));\r\nWR_HARPOON(p_port + hp_portctrl_0, (SCSI_PORT));\r\ncurrSCCB->Sccb_scsistat = COMMAND_ST;\r\nWR_HARPOON(p_port + hp_autostart_3, (AUTO_IMMED | CMD_ONLY_STRT));\r\nSGRAM_ACCESS(p_port);\r\n}\r\nstatic void FPT_phaseStatus(u32 port, unsigned char p_card)\r\n{\r\nWR_HARPOON(port + hp_scsisig, 0x00);\r\nWR_HARPOON(port + hp_autostart_0, (AUTO_IMMED + END_DATA_START));\r\n}\r\nstatic void FPT_phaseMsgOut(u32 port, unsigned char p_card)\r\n{\r\nunsigned char message, scsiID;\r\nstruct sccb *currSCCB;\r\nstruct sccb_mgr_tar_info *currTar_Info;\r\ncurrSCCB = FPT_BL_Card[p_card].currentSCCB;\r\nif (currSCCB != NULL) {\r\nmessage = currSCCB->Sccb_scsimsg;\r\nscsiID = currSCCB->TargID;\r\nif (message == SMDEV_RESET) {\r\ncurrTar_Info = &FPT_sccbMgrTbl[p_card][scsiID];\r\ncurrTar_Info->TarSyncCtrl = 0;\r\nFPT_sssyncv(port, scsiID, NARROW_SCSI, currTar_Info);\r\nif (FPT_sccbMgrTbl[p_card][scsiID].\r\nTarEEValue & EE_SYNC_MASK) {\r\nFPT_sccbMgrTbl[p_card][scsiID].TarStatus &=\r\n~TAR_SYNC_MASK;\r\n}\r\nif (FPT_sccbMgrTbl[p_card][scsiID].\r\nTarEEValue & EE_WIDE_SCSI) {\r\nFPT_sccbMgrTbl[p_card][scsiID].TarStatus &=\r\n~TAR_WIDE_MASK;\r\n}\r\nFPT_queueFlushSccb(p_card, SCCB_COMPLETE);\r\nFPT_SccbMgrTableInitTarget(p_card, scsiID);\r\n} else if (currSCCB->Sccb_scsistat == ABORT_ST) {\r\ncurrSCCB->HostStatus = SCCB_COMPLETE;\r\nif (FPT_BL_Card[p_card].discQ_Tbl[currSCCB->Sccb_tag] !=\r\nNULL) {\r\nFPT_BL_Card[p_card].discQ_Tbl[currSCCB->\r\nSccb_tag] = NULL;\r\nFPT_sccbMgrTbl[p_card][scsiID].TarTagQ_Cnt--;\r\n}\r\n}\r\nelse if (currSCCB->Sccb_scsistat < COMMAND_ST) {\r\nif (message == SMNO_OP) {\r\ncurrSCCB->Sccb_MGRFlags |= F_DEV_SELECTED;\r\nFPT_ssel(port, p_card);\r\nreturn;\r\n}\r\n} else {\r\nif (message == SMABORT)\r\nFPT_queueFlushSccb(p_card, SCCB_COMPLETE);\r\n}\r\n} else {\r\nmessage = SMABORT;\r\n}\r\nWRW_HARPOON((port + hp_intstat), (BUS_FREE | PHASE | XFER_CNT_0));\r\nWR_HARPOON(port + hp_portctrl_0, SCSI_BUS_EN);\r\nWR_HARPOON(port + hp_scsidata_0, message);\r\nWR_HARPOON(port + hp_scsisig, (SCSI_ACK + S_ILL_PH));\r\nACCEPT_MSG(port);\r\nWR_HARPOON(port + hp_portctrl_0, 0x00);\r\nif ((message == SMABORT) || (message == SMDEV_RESET) ||\r\n(message == SMABORT_TAG)) {\r\nwhile (!(RDW_HARPOON((port + hp_intstat)) & (BUS_FREE | PHASE))) {\r\n}\r\nif (RDW_HARPOON((port + hp_intstat)) & BUS_FREE) {\r\nWRW_HARPOON((port + hp_intstat), BUS_FREE);\r\nif (currSCCB != NULL) {\r\nif ((FPT_BL_Card[p_card].\r\nglobalFlags & F_CONLUN_IO)\r\n&&\r\n((FPT_sccbMgrTbl[p_card][currSCCB->TargID].\r\nTarStatus & TAR_TAG_Q_MASK) !=\r\nTAG_Q_TRYING))\r\nFPT_sccbMgrTbl[p_card][currSCCB->\r\nTargID].\r\nTarLUNBusy[currSCCB->Lun] = 0;\r\nelse\r\nFPT_sccbMgrTbl[p_card][currSCCB->\r\nTargID].\r\nTarLUNBusy[0] = 0;\r\nFPT_queueCmdComplete(&FPT_BL_Card[p_card],\r\ncurrSCCB, p_card);\r\n}\r\nelse {\r\nFPT_BL_Card[p_card].globalFlags |=\r\nF_NEW_SCCB_CMD;\r\n}\r\n}\r\nelse {\r\nFPT_sxfrp(port, p_card);\r\n}\r\n}\r\nelse {\r\nif (message == SMPARITY) {\r\ncurrSCCB->Sccb_scsimsg = SMNO_OP;\r\nWR_HARPOON(port + hp_autostart_1,\r\n(AUTO_IMMED + DISCONNECT_START));\r\n} else {\r\nFPT_sxfrp(port, p_card);\r\n}\r\n}\r\n}\r\nstatic void FPT_phaseMsgIn(u32 port, unsigned char p_card)\r\n{\r\nunsigned char message;\r\nstruct sccb *currSCCB;\r\ncurrSCCB = FPT_BL_Card[p_card].currentSCCB;\r\nif (FPT_BL_Card[p_card].globalFlags & F_HOST_XFER_ACT) {\r\nFPT_phaseChkFifo(port, p_card);\r\n}\r\nmessage = RD_HARPOON(port + hp_scsidata_0);\r\nif ((message == SMDISC) || (message == SMSAVE_DATA_PTR)) {\r\nWR_HARPOON(port + hp_autostart_1,\r\n(AUTO_IMMED + END_DATA_START));\r\n}\r\nelse {\r\nmessage = FPT_sfm(port, currSCCB);\r\nif (message) {\r\nFPT_sdecm(message, port, p_card);\r\n} else {\r\nif (currSCCB->Sccb_scsimsg != SMPARITY)\r\nACCEPT_MSG(port);\r\nWR_HARPOON(port + hp_autostart_1,\r\n(AUTO_IMMED + DISCONNECT_START));\r\n}\r\n}\r\n}\r\nstatic void FPT_phaseIllegal(u32 port, unsigned char p_card)\r\n{\r\nstruct sccb *currSCCB;\r\ncurrSCCB = FPT_BL_Card[p_card].currentSCCB;\r\nWR_HARPOON(port + hp_scsisig, RD_HARPOON(port + hp_scsisig));\r\nif (currSCCB != NULL) {\r\ncurrSCCB->HostStatus = SCCB_PHASE_SEQUENCE_FAIL;\r\ncurrSCCB->Sccb_scsistat = ABORT_ST;\r\ncurrSCCB->Sccb_scsimsg = SMABORT;\r\n}\r\nACCEPT_MSG_ATN(port);\r\n}\r\nstatic void FPT_phaseChkFifo(u32 port, unsigned char p_card)\r\n{\r\nu32 xfercnt;\r\nstruct sccb *currSCCB;\r\ncurrSCCB = FPT_BL_Card[p_card].currentSCCB;\r\nif (currSCCB->Sccb_scsistat == DATA_IN_ST) {\r\nwhile ((!(RD_HARPOON(port + hp_xferstat) & FIFO_EMPTY)) &&\r\n(RD_HARPOON(port + hp_ext_status) & BM_CMD_BUSY)) {\r\n}\r\nif (!(RD_HARPOON(port + hp_xferstat) & FIFO_EMPTY)) {\r\ncurrSCCB->Sccb_ATC += currSCCB->Sccb_XferCnt;\r\ncurrSCCB->Sccb_XferCnt = 0;\r\nif ((RDW_HARPOON((port + hp_intstat)) & PARITY) &&\r\n(currSCCB->HostStatus == SCCB_COMPLETE)) {\r\ncurrSCCB->HostStatus = SCCB_PARITY_ERR;\r\nWRW_HARPOON((port + hp_intstat), PARITY);\r\n}\r\nFPT_hostDataXferAbort(port, p_card, currSCCB);\r\nFPT_dataXferProcessor(port, &FPT_BL_Card[p_card]);\r\nwhile ((!(RD_HARPOON(port + hp_xferstat) & FIFO_EMPTY))\r\n&& (RD_HARPOON(port + hp_ext_status) &\r\nBM_CMD_BUSY)) {\r\n}\r\n}\r\n}\r\nGET_XFER_CNT(port, xfercnt);\r\nWR_HARPOON(port + hp_xfercnt_0, 0x00);\r\nWR_HARPOON(port + hp_portctrl_0, 0x00);\r\ncurrSCCB->Sccb_ATC += (currSCCB->Sccb_XferCnt - xfercnt);\r\ncurrSCCB->Sccb_XferCnt = xfercnt;\r\nif ((RDW_HARPOON((port + hp_intstat)) & PARITY) &&\r\n(currSCCB->HostStatus == SCCB_COMPLETE)) {\r\ncurrSCCB->HostStatus = SCCB_PARITY_ERR;\r\nWRW_HARPOON((port + hp_intstat), PARITY);\r\n}\r\nFPT_hostDataXferAbort(port, p_card, currSCCB);\r\nWR_HARPOON(port + hp_fifowrite, 0x00);\r\nWR_HARPOON(port + hp_fiforead, 0x00);\r\nWR_HARPOON(port + hp_xferstat, 0x00);\r\nWRW_HARPOON((port + hp_intstat), XFER_CNT_0);\r\n}\r\nstatic void FPT_phaseBusFree(u32 port, unsigned char p_card)\r\n{\r\nstruct sccb *currSCCB;\r\ncurrSCCB = FPT_BL_Card[p_card].currentSCCB;\r\nif (currSCCB != NULL) {\r\nDISABLE_AUTO(port);\r\nif (currSCCB->OperationCode == RESET_COMMAND) {\r\nif ((FPT_BL_Card[p_card].globalFlags & F_CONLUN_IO) &&\r\n((FPT_sccbMgrTbl[p_card][currSCCB->TargID].\r\nTarStatus & TAR_TAG_Q_MASK) != TAG_Q_TRYING))\r\nFPT_sccbMgrTbl[p_card][currSCCB->TargID].\r\nTarLUNBusy[currSCCB->Lun] = 0;\r\nelse\r\nFPT_sccbMgrTbl[p_card][currSCCB->TargID].\r\nTarLUNBusy[0] = 0;\r\nFPT_queueCmdComplete(&FPT_BL_Card[p_card], currSCCB,\r\np_card);\r\nFPT_queueSearchSelect(&FPT_BL_Card[p_card], p_card);\r\n}\r\nelse if (currSCCB->Sccb_scsistat == SELECT_SN_ST) {\r\nFPT_sccbMgrTbl[p_card][currSCCB->TargID].TarStatus |=\r\n(unsigned char)SYNC_SUPPORTED;\r\nFPT_sccbMgrTbl[p_card][currSCCB->TargID].TarEEValue &=\r\n~EE_SYNC_MASK;\r\n}\r\nelse if (currSCCB->Sccb_scsistat == SELECT_WN_ST) {\r\nFPT_sccbMgrTbl[p_card][currSCCB->TargID].TarStatus =\r\n(FPT_sccbMgrTbl[p_card][currSCCB->TargID].\r\nTarStatus & ~WIDE_ENABLED) | WIDE_NEGOCIATED;\r\nFPT_sccbMgrTbl[p_card][currSCCB->TargID].TarEEValue &=\r\n~EE_WIDE_SCSI;\r\n}\r\nelse if (currSCCB->Sccb_scsistat == SELECT_Q_ST) {\r\nif ((!(RD_HARPOON(port + hp_scsisig) & SCSI_BSY)) ||\r\n(RDW_HARPOON((port + hp_intstat)) & RSEL)) {\r\nFPT_sccbMgrTbl[p_card][currSCCB->TargID].\r\nTarStatus &= ~TAR_TAG_Q_MASK;\r\nFPT_sccbMgrTbl[p_card][currSCCB->TargID].\r\nTarStatus |= TAG_Q_REJECT;\r\n}\r\nelse {\r\nreturn;\r\n}\r\n}\r\nelse {\r\ncurrSCCB->Sccb_scsistat = BUS_FREE_ST;\r\nif (!currSCCB->HostStatus) {\r\ncurrSCCB->HostStatus = SCCB_PHASE_SEQUENCE_FAIL;\r\n}\r\nif ((FPT_BL_Card[p_card].globalFlags & F_CONLUN_IO) &&\r\n((FPT_sccbMgrTbl[p_card][currSCCB->TargID].\r\nTarStatus & TAR_TAG_Q_MASK) != TAG_Q_TRYING))\r\nFPT_sccbMgrTbl[p_card][currSCCB->TargID].\r\nTarLUNBusy[currSCCB->Lun] = 0;\r\nelse\r\nFPT_sccbMgrTbl[p_card][currSCCB->TargID].\r\nTarLUNBusy[0] = 0;\r\nFPT_queueCmdComplete(&FPT_BL_Card[p_card], currSCCB,\r\np_card);\r\nreturn;\r\n}\r\nFPT_BL_Card[p_card].globalFlags |= F_NEW_SCCB_CMD;\r\n}\r\n}\r\nstatic void FPT_autoLoadDefaultMap(u32 p_port)\r\n{\r\nu32 map_addr;\r\nARAM_ACCESS(p_port);\r\nmap_addr = p_port + hp_aramBase;\r\nWRW_HARPOON(map_addr, (MPM_OP + AMSG_OUT + 0xC0));\r\nmap_addr += 2;\r\nWRW_HARPOON(map_addr, (MPM_OP + AMSG_OUT + 0x20));\r\nmap_addr += 2;\r\nWRW_HARPOON(map_addr, RAT_OP);\r\nmap_addr += 2;\r\nWRW_HARPOON(map_addr, (MPM_OP + AMSG_OUT + 0x00));\r\nmap_addr += 2;\r\nWRW_HARPOON(map_addr, (MPM_OP + ACOMMAND + 0x00));\r\nmap_addr += 2;\r\nWRW_HARPOON(map_addr, (MPM_OP + ACOMMAND + 0x00));\r\nmap_addr += 2;\r\nWRW_HARPOON(map_addr, (MPM_OP + ACOMMAND + 0x00));\r\nmap_addr += 2;\r\nWRW_HARPOON(map_addr, (MPM_OP + ACOMMAND + 0x00));\r\nmap_addr += 2;\r\nWRW_HARPOON(map_addr, (MPM_OP + ACOMMAND + 0x00));\r\nmap_addr += 2;\r\nWRW_HARPOON(map_addr, (MPM_OP + ACOMMAND + 0x00));\r\nmap_addr += 2;\r\nWRW_HARPOON(map_addr, (MPM_OP + ACOMMAND + 0x00));\r\nmap_addr += 2;\r\nWRW_HARPOON(map_addr, (MPM_OP + ACOMMAND + 0x00));\r\nmap_addr += 2;\r\nWRW_HARPOON(map_addr, (MPM_OP + ACOMMAND + 0x00));\r\nmap_addr += 2;\r\nWRW_HARPOON(map_addr, (MPM_OP + ACOMMAND + 0x00));\r\nmap_addr += 2;\r\nWRW_HARPOON(map_addr, (MPM_OP + ACOMMAND + 0x00));\r\nmap_addr += 2;\r\nWRW_HARPOON(map_addr, (MPM_OP + ACOMMAND + 0x00));\r\nmap_addr += 2;\r\nWRW_HARPOON(map_addr, (CPE_OP + ADATA_OUT + DINT));\r\nmap_addr += 2;\r\nWRW_HARPOON(map_addr, (TCB_OP + FIFO_0 + DI));\r\nmap_addr += 2;\r\nWRW_HARPOON(map_addr, (SSI_OP + SSI_IDO_STRT));\r\nmap_addr += 2;\r\nWRW_HARPOON(map_addr, (CPE_OP + ADATA_IN + DINT));\r\nmap_addr += 2;\r\nWRW_HARPOON(map_addr, (CPN_OP + AMSG_IN + ST));\r\nmap_addr += 2;\r\nWRW_HARPOON(map_addr, (CRD_OP + SDATA + 0x02));\r\nmap_addr += 2;\r\nWRW_HARPOON(map_addr, (BRH_OP + NOT_EQ + DC));\r\nmap_addr += 2;\r\nWRW_HARPOON(map_addr, (MRR_OP + SDATA + D_AR1));\r\nmap_addr += 2;\r\nWRW_HARPOON(map_addr, (CPN_OP + AMSG_IN + ST));\r\nmap_addr += 2;\r\nWRW_HARPOON(map_addr, (CRD_OP + SDATA + 0x04));\r\nmap_addr += 2;\r\nWRW_HARPOON(map_addr, (BRH_OP + NOT_EQ + UNKNWN));\r\nmap_addr += 2;\r\nWRW_HARPOON(map_addr, (MRR_OP + SDATA + D_BUCKET));\r\nmap_addr += 2;\r\nWRW_HARPOON(map_addr, (SSI_OP + SSI_ITAR_DISC));\r\nmap_addr += 2;\r\nWRW_HARPOON(map_addr, (CPN_OP + ASTATUS + UNKNWN));\r\nmap_addr += 2;\r\nWRW_HARPOON(map_addr, (MRR_OP + SDATA + D_AR0));\r\nmap_addr += 2;\r\nWRW_HARPOON(map_addr, (CPN_OP + AMSG_IN + CC));\r\nmap_addr += 2;\r\nWRW_HARPOON(map_addr, (CRD_OP + SDATA + 0x00));\r\nmap_addr += 2;\r\nWRW_HARPOON(map_addr, (BRH_OP + NOT_EQ + CC));\r\nmap_addr += 2;\r\nWRW_HARPOON(map_addr, (MRR_OP + SDATA + D_BUCKET));\r\nmap_addr += 2;\r\nWRW_HARPOON(map_addr, (SSI_OP + SSI_ICMD_COMP));\r\nmap_addr += 2;\r\nWRW_HARPOON(map_addr, (SSI_OP + SSI_IUNKWN));\r\nmap_addr += 2;\r\nWRW_HARPOON(map_addr, (SSI_OP + SSI_INO_CC));\r\nmap_addr += 2;\r\nWRW_HARPOON(map_addr, (SSI_OP + SSI_ITICKLE));\r\nmap_addr += 2;\r\nWRW_HARPOON(map_addr, (SSI_OP + SSI_IRFAIL));\r\nmap_addr += 2;\r\nWRW_HARPOON(map_addr, (CRR_OP + AR3 + S_IDREG));\r\nmap_addr += 2;\r\nWRW_HARPOON(map_addr, (BRH_OP + EQUAL + 0x00));\r\nmap_addr += 2;\r\nWRW_HARPOON(map_addr, (SSI_OP + SSI_INO_CC));\r\nSGRAM_ACCESS(p_port);\r\n}\r\nstatic void FPT_autoCmdCmplt(u32 p_port, unsigned char p_card)\r\n{\r\nstruct sccb *currSCCB;\r\nunsigned char status_byte;\r\ncurrSCCB = FPT_BL_Card[p_card].currentSCCB;\r\nstatus_byte = RD_HARPOON(p_port + hp_gp_reg_0);\r\nFPT_sccbMgrTbl[p_card][currSCCB->TargID].TarLUN_CA = 0;\r\nif (status_byte != SSGOOD) {\r\nif (status_byte == SSQ_FULL) {\r\nif (((FPT_BL_Card[p_card].globalFlags & F_CONLUN_IO) &&\r\n((FPT_sccbMgrTbl[p_card][currSCCB->TargID].\r\nTarStatus & TAR_TAG_Q_MASK) != TAG_Q_TRYING))) {\r\nFPT_sccbMgrTbl[p_card][currSCCB->TargID].\r\nTarLUNBusy[currSCCB->Lun] = 1;\r\nif (FPT_BL_Card[p_card].discQCount != 0)\r\nFPT_BL_Card[p_card].discQCount--;\r\nFPT_BL_Card[p_card].\r\ndiscQ_Tbl[FPT_sccbMgrTbl[p_card]\r\n[currSCCB->TargID].\r\nLunDiscQ_Idx[currSCCB->Lun]] =\r\nNULL;\r\n} else {\r\nFPT_sccbMgrTbl[p_card][currSCCB->TargID].\r\nTarLUNBusy[0] = 1;\r\nif (currSCCB->Sccb_tag) {\r\nif (FPT_BL_Card[p_card].discQCount != 0)\r\nFPT_BL_Card[p_card].\r\ndiscQCount--;\r\nFPT_BL_Card[p_card].discQ_Tbl[currSCCB->\r\nSccb_tag]\r\n= NULL;\r\n} else {\r\nif (FPT_BL_Card[p_card].discQCount != 0)\r\nFPT_BL_Card[p_card].\r\ndiscQCount--;\r\nFPT_BL_Card[p_card].\r\ndiscQ_Tbl[FPT_sccbMgrTbl[p_card]\r\n[currSCCB->TargID].\r\nLunDiscQ_Idx[0]] = NULL;\r\n}\r\n}\r\ncurrSCCB->Sccb_MGRFlags |= F_STATUSLOADED;\r\nFPT_queueSelectFail(&FPT_BL_Card[p_card], p_card);\r\nreturn;\r\n}\r\nif (currSCCB->Sccb_scsistat == SELECT_SN_ST) {\r\nFPT_sccbMgrTbl[p_card][currSCCB->TargID].TarStatus |=\r\n(unsigned char)SYNC_SUPPORTED;\r\nFPT_sccbMgrTbl[p_card][currSCCB->TargID].TarEEValue &=\r\n~EE_SYNC_MASK;\r\nFPT_BL_Card[p_card].globalFlags |= F_NEW_SCCB_CMD;\r\nif (((FPT_BL_Card[p_card].globalFlags & F_CONLUN_IO) &&\r\n((FPT_sccbMgrTbl[p_card][currSCCB->TargID].\r\nTarStatus & TAR_TAG_Q_MASK) != TAG_Q_TRYING))) {\r\nFPT_sccbMgrTbl[p_card][currSCCB->TargID].\r\nTarLUNBusy[currSCCB->Lun] = 1;\r\nif (FPT_BL_Card[p_card].discQCount != 0)\r\nFPT_BL_Card[p_card].discQCount--;\r\nFPT_BL_Card[p_card].\r\ndiscQ_Tbl[FPT_sccbMgrTbl[p_card]\r\n[currSCCB->TargID].\r\nLunDiscQ_Idx[currSCCB->Lun]] =\r\nNULL;\r\n} else {\r\nFPT_sccbMgrTbl[p_card][currSCCB->TargID].\r\nTarLUNBusy[0] = 1;\r\nif (currSCCB->Sccb_tag) {\r\nif (FPT_BL_Card[p_card].discQCount != 0)\r\nFPT_BL_Card[p_card].\r\ndiscQCount--;\r\nFPT_BL_Card[p_card].discQ_Tbl[currSCCB->\r\nSccb_tag]\r\n= NULL;\r\n} else {\r\nif (FPT_BL_Card[p_card].discQCount != 0)\r\nFPT_BL_Card[p_card].\r\ndiscQCount--;\r\nFPT_BL_Card[p_card].\r\ndiscQ_Tbl[FPT_sccbMgrTbl[p_card]\r\n[currSCCB->TargID].\r\nLunDiscQ_Idx[0]] = NULL;\r\n}\r\n}\r\nreturn;\r\n}\r\nif (currSCCB->Sccb_scsistat == SELECT_WN_ST) {\r\nFPT_sccbMgrTbl[p_card][currSCCB->TargID].TarStatus =\r\n(FPT_sccbMgrTbl[p_card][currSCCB->TargID].\r\nTarStatus & ~WIDE_ENABLED) | WIDE_NEGOCIATED;\r\nFPT_sccbMgrTbl[p_card][currSCCB->TargID].TarEEValue &=\r\n~EE_WIDE_SCSI;\r\nFPT_BL_Card[p_card].globalFlags |= F_NEW_SCCB_CMD;\r\nif (((FPT_BL_Card[p_card].globalFlags & F_CONLUN_IO) &&\r\n((FPT_sccbMgrTbl[p_card][currSCCB->TargID].\r\nTarStatus & TAR_TAG_Q_MASK) != TAG_Q_TRYING))) {\r\nFPT_sccbMgrTbl[p_card][currSCCB->TargID].\r\nTarLUNBusy[currSCCB->Lun] = 1;\r\nif (FPT_BL_Card[p_card].discQCount != 0)\r\nFPT_BL_Card[p_card].discQCount--;\r\nFPT_BL_Card[p_card].\r\ndiscQ_Tbl[FPT_sccbMgrTbl[p_card]\r\n[currSCCB->TargID].\r\nLunDiscQ_Idx[currSCCB->Lun]] =\r\nNULL;\r\n} else {\r\nFPT_sccbMgrTbl[p_card][currSCCB->TargID].\r\nTarLUNBusy[0] = 1;\r\nif (currSCCB->Sccb_tag) {\r\nif (FPT_BL_Card[p_card].discQCount != 0)\r\nFPT_BL_Card[p_card].\r\ndiscQCount--;\r\nFPT_BL_Card[p_card].discQ_Tbl[currSCCB->\r\nSccb_tag]\r\n= NULL;\r\n} else {\r\nif (FPT_BL_Card[p_card].discQCount != 0)\r\nFPT_BL_Card[p_card].\r\ndiscQCount--;\r\nFPT_BL_Card[p_card].\r\ndiscQ_Tbl[FPT_sccbMgrTbl[p_card]\r\n[currSCCB->TargID].\r\nLunDiscQ_Idx[0]] = NULL;\r\n}\r\n}\r\nreturn;\r\n}\r\nif (status_byte == SSCHECK) {\r\nif (FPT_BL_Card[p_card].globalFlags & F_DO_RENEGO) {\r\nif (FPT_sccbMgrTbl[p_card][currSCCB->TargID].\r\nTarEEValue & EE_SYNC_MASK) {\r\nFPT_sccbMgrTbl[p_card][currSCCB->\r\nTargID].\r\nTarStatus &= ~TAR_SYNC_MASK;\r\n}\r\nif (FPT_sccbMgrTbl[p_card][currSCCB->TargID].\r\nTarEEValue & EE_WIDE_SCSI) {\r\nFPT_sccbMgrTbl[p_card][currSCCB->\r\nTargID].\r\nTarStatus &= ~TAR_WIDE_MASK;\r\n}\r\n}\r\n}\r\nif (!(currSCCB->Sccb_XferState & F_AUTO_SENSE)) {\r\ncurrSCCB->SccbStatus = SCCB_ERROR;\r\ncurrSCCB->TargetStatus = status_byte;\r\nif (status_byte == SSCHECK) {\r\nFPT_sccbMgrTbl[p_card][currSCCB->TargID].\r\nTarLUN_CA = 1;\r\nif (currSCCB->RequestSenseLength !=\r\nNO_AUTO_REQUEST_SENSE) {\r\nif (currSCCB->RequestSenseLength == 0)\r\ncurrSCCB->RequestSenseLength =\r\n14;\r\nFPT_ssenss(&FPT_BL_Card[p_card]);\r\nFPT_BL_Card[p_card].globalFlags |=\r\nF_NEW_SCCB_CMD;\r\nif (((FPT_BL_Card[p_card].\r\nglobalFlags & F_CONLUN_IO)\r\n&&\r\n((FPT_sccbMgrTbl[p_card]\r\n[currSCCB->TargID].\r\nTarStatus & TAR_TAG_Q_MASK) !=\r\nTAG_Q_TRYING))) {\r\nFPT_sccbMgrTbl[p_card]\r\n[currSCCB->TargID].\r\nTarLUNBusy[currSCCB->Lun] =\r\n1;\r\nif (FPT_BL_Card[p_card].\r\ndiscQCount != 0)\r\nFPT_BL_Card[p_card].\r\ndiscQCount--;\r\nFPT_BL_Card[p_card].\r\ndiscQ_Tbl[FPT_sccbMgrTbl\r\n[p_card]\r\n[currSCCB->\r\nTargID].\r\nLunDiscQ_Idx\r\n[currSCCB->Lun]] =\r\nNULL;\r\n} else {\r\nFPT_sccbMgrTbl[p_card]\r\n[currSCCB->TargID].\r\nTarLUNBusy[0] = 1;\r\nif (currSCCB->Sccb_tag) {\r\nif (FPT_BL_Card[p_card].\r\ndiscQCount != 0)\r\nFPT_BL_Card\r\n[p_card].\r\ndiscQCount--;\r\nFPT_BL_Card[p_card].\r\ndiscQ_Tbl[currSCCB->\r\nSccb_tag]\r\n= NULL;\r\n} else {\r\nif (FPT_BL_Card[p_card].\r\ndiscQCount != 0)\r\nFPT_BL_Card\r\n[p_card].\r\ndiscQCount--;\r\nFPT_BL_Card[p_card].\r\ndiscQ_Tbl\r\n[FPT_sccbMgrTbl\r\n[p_card][currSCCB->\r\nTargID].\r\nLunDiscQ_Idx[0]] =\r\nNULL;\r\n}\r\n}\r\nreturn;\r\n}\r\n}\r\n}\r\n}\r\nif ((FPT_BL_Card[p_card].globalFlags & F_CONLUN_IO) &&\r\n((FPT_sccbMgrTbl[p_card][currSCCB->TargID].\r\nTarStatus & TAR_TAG_Q_MASK) != TAG_Q_TRYING))\r\nFPT_sccbMgrTbl[p_card][currSCCB->TargID].TarLUNBusy[currSCCB->\r\nLun] = 0;\r\nelse\r\nFPT_sccbMgrTbl[p_card][currSCCB->TargID].TarLUNBusy[0] = 0;\r\nFPT_queueCmdComplete(&FPT_BL_Card[p_card], currSCCB, p_card);\r\n}\r\nstatic void FPT_dataXferProcessor(u32 port, struct sccb_card *pCurrCard)\r\n{\r\nstruct sccb *currSCCB;\r\ncurrSCCB = pCurrCard->currentSCCB;\r\nif (currSCCB->Sccb_XferState & F_SG_XFER) {\r\nif (pCurrCard->globalFlags & F_HOST_XFER_ACT)\r\n{\r\ncurrSCCB->Sccb_sgseg += (unsigned char)SG_BUF_CNT;\r\ncurrSCCB->Sccb_SGoffset = 0x00;\r\n}\r\npCurrCard->globalFlags |= F_HOST_XFER_ACT;\r\nFPT_busMstrSGDataXferStart(port, currSCCB);\r\n}\r\nelse {\r\nif (!(pCurrCard->globalFlags & F_HOST_XFER_ACT)) {\r\npCurrCard->globalFlags |= F_HOST_XFER_ACT;\r\nFPT_busMstrDataXferStart(port, currSCCB);\r\n}\r\n}\r\n}\r\nstatic void FPT_busMstrSGDataXferStart(u32 p_port, struct sccb *pcurrSCCB)\r\n{\r\nu32 count, addr, tmpSGCnt;\r\nunsigned int sg_index;\r\nunsigned char sg_count, i;\r\nu32 reg_offset;\r\nstruct blogic_sg_seg *segp;\r\nif (pcurrSCCB->Sccb_XferState & F_HOST_XFER_DIR)\r\ncount = ((u32)HOST_RD_CMD) << 24;\r\nelse\r\ncount = ((u32)HOST_WRT_CMD) << 24;\r\nsg_count = 0;\r\ntmpSGCnt = 0;\r\nsg_index = pcurrSCCB->Sccb_sgseg;\r\nreg_offset = hp_aramBase;\r\ni = (unsigned char)(RD_HARPOON(p_port + hp_page_ctrl) &\r\n~(SGRAM_ARAM | SCATTER_EN));\r\nWR_HARPOON(p_port + hp_page_ctrl, i);\r\nwhile ((sg_count < (unsigned char)SG_BUF_CNT) &&\r\n((sg_index * (unsigned int)SG_ELEMENT_SIZE) <\r\npcurrSCCB->DataLength)) {\r\nsegp = (struct blogic_sg_seg *)(pcurrSCCB->DataPointer) +\r\nsg_index;\r\ntmpSGCnt += segp->segbytes;\r\ncount |= segp->segbytes;\r\naddr = segp->segdata;\r\nif ((!sg_count) && (pcurrSCCB->Sccb_SGoffset)) {\r\naddr +=\r\n((count & 0x00FFFFFFL) - pcurrSCCB->Sccb_SGoffset);\r\ncount =\r\n(count & 0xFF000000L) | pcurrSCCB->Sccb_SGoffset;\r\ntmpSGCnt = count & 0x00FFFFFFL;\r\n}\r\nWR_HARP32(p_port, reg_offset, addr);\r\nreg_offset += 4;\r\nWR_HARP32(p_port, reg_offset, count);\r\nreg_offset += 4;\r\ncount &= 0xFF000000L;\r\nsg_index++;\r\nsg_count++;\r\n}\r\npcurrSCCB->Sccb_XferCnt = tmpSGCnt;\r\nWR_HARPOON(p_port + hp_sg_addr, (sg_count << 4));\r\nif (pcurrSCCB->Sccb_XferState & F_HOST_XFER_DIR) {\r\nWR_HARP32(p_port, hp_xfercnt_0, tmpSGCnt);\r\nWR_HARPOON(p_port + hp_portctrl_0,\r\n(DMA_PORT | SCSI_PORT | SCSI_INBIT));\r\nWR_HARPOON(p_port + hp_scsisig, S_DATAI_PH);\r\n}\r\nelse {\r\nif ((!(RD_HARPOON(p_port + hp_synctarg_0) & NARROW_SCSI)) &&\r\n(tmpSGCnt & 0x000000001)) {\r\npcurrSCCB->Sccb_XferState |= F_ODD_BALL_CNT;\r\ntmpSGCnt--;\r\n}\r\nWR_HARP32(p_port, hp_xfercnt_0, tmpSGCnt);\r\nWR_HARPOON(p_port + hp_portctrl_0,\r\n(SCSI_PORT | DMA_PORT | DMA_RD));\r\nWR_HARPOON(p_port + hp_scsisig, S_DATAO_PH);\r\n}\r\nWR_HARPOON(p_port + hp_page_ctrl, (unsigned char)(i | SCATTER_EN));\r\n}\r\nstatic void FPT_busMstrDataXferStart(u32 p_port, struct sccb *pcurrSCCB)\r\n{\r\nu32 addr, count;\r\nif (!(pcurrSCCB->Sccb_XferState & F_AUTO_SENSE)) {\r\ncount = pcurrSCCB->Sccb_XferCnt;\r\naddr = (u32)(unsigned long)pcurrSCCB->DataPointer + pcurrSCCB->Sccb_ATC;\r\n}\r\nelse {\r\naddr = pcurrSCCB->SensePointer;\r\ncount = pcurrSCCB->RequestSenseLength;\r\n}\r\nHP_SETUP_ADDR_CNT(p_port, addr, count);\r\nif (pcurrSCCB->Sccb_XferState & F_HOST_XFER_DIR) {\r\nWR_HARPOON(p_port + hp_portctrl_0,\r\n(DMA_PORT | SCSI_PORT | SCSI_INBIT));\r\nWR_HARPOON(p_port + hp_scsisig, S_DATAI_PH);\r\nWR_HARPOON(p_port + hp_xfer_cmd,\r\n(XFER_DMA_HOST | XFER_HOST_AUTO | XFER_DMA_8BIT));\r\n}\r\nelse {\r\nWR_HARPOON(p_port + hp_portctrl_0,\r\n(SCSI_PORT | DMA_PORT | DMA_RD));\r\nWR_HARPOON(p_port + hp_scsisig, S_DATAO_PH);\r\nWR_HARPOON(p_port + hp_xfer_cmd,\r\n(XFER_HOST_DMA | XFER_HOST_AUTO | XFER_DMA_8BIT));\r\n}\r\n}\r\nstatic unsigned char FPT_busMstrTimeOut(u32 p_port)\r\n{\r\nunsigned long timeout;\r\ntimeout = LONG_WAIT;\r\nWR_HARPOON(p_port + hp_sys_ctrl, HALT_MACH);\r\nwhile ((!(RD_HARPOON(p_port + hp_ext_status) & CMD_ABORTED))\r\n&& timeout--) {\r\n}\r\nif (RD_HARPOON(p_port + hp_ext_status) & BM_CMD_BUSY) {\r\nWR_HARPOON(p_port + hp_sys_ctrl, HARD_ABORT);\r\ntimeout = LONG_WAIT;\r\nwhile ((RD_HARPOON(p_port + hp_ext_status) & BM_CMD_BUSY)\r\n&& timeout--) {\r\n}\r\n}\r\nRD_HARPOON(p_port + hp_int_status);\r\nif (RD_HARPOON(p_port + hp_ext_status) & BM_CMD_BUSY) {\r\nreturn 1;\r\n}\r\nelse {\r\nreturn 0;\r\n}\r\n}\r\nstatic void FPT_hostDataXferAbort(u32 port, unsigned char p_card,\r\nstruct sccb *pCurrSCCB)\r\n{\r\nunsigned long timeout;\r\nunsigned long remain_cnt;\r\nu32 sg_ptr;\r\nstruct blogic_sg_seg *segp;\r\nFPT_BL_Card[p_card].globalFlags &= ~F_HOST_XFER_ACT;\r\nif (pCurrSCCB->Sccb_XferState & F_AUTO_SENSE) {\r\nif (!(RD_HARPOON(port + hp_int_status) & INT_CMD_COMPL)) {\r\nWR_HARPOON(port + hp_bm_ctrl,\r\n(RD_HARPOON(port + hp_bm_ctrl) |\r\nFLUSH_XFER_CNTR));\r\ntimeout = LONG_WAIT;\r\nwhile ((RD_HARPOON(port + hp_ext_status) & BM_CMD_BUSY)\r\n&& timeout--) {\r\n}\r\nWR_HARPOON(port + hp_bm_ctrl,\r\n(RD_HARPOON(port + hp_bm_ctrl) &\r\n~FLUSH_XFER_CNTR));\r\nif (RD_HARPOON(port + hp_ext_status) & BM_CMD_BUSY) {\r\nif (FPT_busMstrTimeOut(port)) {\r\nif (pCurrSCCB->HostStatus == 0x00)\r\npCurrSCCB->HostStatus =\r\nSCCB_BM_ERR;\r\n}\r\nif (RD_HARPOON(port + hp_int_status) &\r\nINT_EXT_STATUS)\r\nif (RD_HARPOON(port + hp_ext_status) &\r\nBAD_EXT_STATUS)\r\nif (pCurrSCCB->HostStatus ==\r\n0x00)\r\n{\r\npCurrSCCB->HostStatus =\r\nSCCB_BM_ERR;\r\n}\r\n}\r\n}\r\n}\r\nelse if (pCurrSCCB->Sccb_XferCnt) {\r\nif (pCurrSCCB->Sccb_XferState & F_SG_XFER) {\r\nWR_HARPOON(port + hp_page_ctrl,\r\n(RD_HARPOON(port + hp_page_ctrl) &\r\n~SCATTER_EN));\r\nWR_HARPOON(port + hp_sg_addr, 0x00);\r\nsg_ptr = pCurrSCCB->Sccb_sgseg + SG_BUF_CNT;\r\nif (sg_ptr >\r\n(unsigned int)(pCurrSCCB->DataLength /\r\nSG_ELEMENT_SIZE)) {\r\nsg_ptr = (u32)(pCurrSCCB->DataLength /\r\nSG_ELEMENT_SIZE);\r\n}\r\nremain_cnt = pCurrSCCB->Sccb_XferCnt;\r\nwhile (remain_cnt < 0x01000000L) {\r\nsg_ptr--;\r\nsegp = (struct blogic_sg_seg *)(pCurrSCCB->\r\nDataPointer) + (sg_ptr * 2);\r\nif (remain_cnt > (unsigned long)segp->segbytes)\r\nremain_cnt -=\r\n(unsigned long)segp->segbytes;\r\nelse\r\nbreak;\r\n}\r\nif (remain_cnt < 0x01000000L) {\r\npCurrSCCB->Sccb_SGoffset = remain_cnt;\r\npCurrSCCB->Sccb_sgseg = (unsigned short)sg_ptr;\r\nif ((unsigned long)(sg_ptr * SG_ELEMENT_SIZE) ==\r\npCurrSCCB->DataLength && (remain_cnt == 0))\r\npCurrSCCB->Sccb_XferState |=\r\nF_ALL_XFERRED;\r\n}\r\nelse {\r\nif (pCurrSCCB->HostStatus == 0x00) {\r\npCurrSCCB->HostStatus =\r\nSCCB_GROSS_FW_ERR;\r\n}\r\n}\r\n}\r\nif (!(pCurrSCCB->Sccb_XferState & F_HOST_XFER_DIR)) {\r\nif (RD_HARPOON(port + hp_ext_status) & BM_CMD_BUSY) {\r\nFPT_busMstrTimeOut(port);\r\n}\r\nelse {\r\nif (RD_HARPOON(port + hp_int_status) &\r\nINT_EXT_STATUS) {\r\nif (RD_HARPOON(port + hp_ext_status) &\r\nBAD_EXT_STATUS) {\r\nif (pCurrSCCB->HostStatus ==\r\n0x00) {\r\npCurrSCCB->HostStatus =\r\nSCCB_BM_ERR;\r\n}\r\n}\r\n}\r\n}\r\n}\r\nelse {\r\nif ((RD_HARPOON(port + hp_fifo_cnt)) >= BM_THRESHOLD) {\r\ntimeout = SHORT_WAIT;\r\nwhile ((RD_HARPOON(port + hp_ext_status) &\r\nBM_CMD_BUSY)\r\n&& ((RD_HARPOON(port + hp_fifo_cnt)) >=\r\nBM_THRESHOLD) && timeout--) {\r\n}\r\n}\r\nif (RD_HARPOON(port + hp_ext_status) & BM_CMD_BUSY) {\r\nWR_HARPOON(port + hp_bm_ctrl,\r\n(RD_HARPOON(port + hp_bm_ctrl) |\r\nFLUSH_XFER_CNTR));\r\ntimeout = LONG_WAIT;\r\nwhile ((RD_HARPOON(port + hp_ext_status) &\r\nBM_CMD_BUSY) && timeout--) {\r\n}\r\nWR_HARPOON(port + hp_bm_ctrl,\r\n(RD_HARPOON(port + hp_bm_ctrl) &\r\n~FLUSH_XFER_CNTR));\r\nif (RD_HARPOON(port + hp_ext_status) &\r\nBM_CMD_BUSY) {\r\nif (pCurrSCCB->HostStatus == 0x00) {\r\npCurrSCCB->HostStatus =\r\nSCCB_BM_ERR;\r\n}\r\nFPT_busMstrTimeOut(port);\r\n}\r\n}\r\nif (RD_HARPOON(port + hp_int_status) & INT_EXT_STATUS) {\r\nif (RD_HARPOON(port + hp_ext_status) &\r\nBAD_EXT_STATUS) {\r\nif (pCurrSCCB->HostStatus == 0x00) {\r\npCurrSCCB->HostStatus =\r\nSCCB_BM_ERR;\r\n}\r\n}\r\n}\r\n}\r\n}\r\nelse {\r\nif (RD_HARPOON(port + hp_ext_status) & BM_CMD_BUSY) {\r\ntimeout = LONG_WAIT;\r\nwhile ((RD_HARPOON(port + hp_ext_status) & BM_CMD_BUSY)\r\n&& timeout--) {\r\n}\r\nif (RD_HARPOON(port + hp_ext_status) & BM_CMD_BUSY) {\r\nif (pCurrSCCB->HostStatus == 0x00) {\r\npCurrSCCB->HostStatus = SCCB_BM_ERR;\r\n}\r\nFPT_busMstrTimeOut(port);\r\n}\r\n}\r\nif (RD_HARPOON(port + hp_int_status) & INT_EXT_STATUS) {\r\nif (RD_HARPOON(port + hp_ext_status) & BAD_EXT_STATUS) {\r\nif (pCurrSCCB->HostStatus == 0x00) {\r\npCurrSCCB->HostStatus = SCCB_BM_ERR;\r\n}\r\n}\r\n}\r\nif (pCurrSCCB->Sccb_XferState & F_SG_XFER) {\r\nWR_HARPOON(port + hp_page_ctrl,\r\n(RD_HARPOON(port + hp_page_ctrl) &\r\n~SCATTER_EN));\r\nWR_HARPOON(port + hp_sg_addr, 0x00);\r\npCurrSCCB->Sccb_sgseg += SG_BUF_CNT;\r\npCurrSCCB->Sccb_SGoffset = 0x00;\r\nif ((u32)(pCurrSCCB->Sccb_sgseg * SG_ELEMENT_SIZE) >=\r\npCurrSCCB->DataLength) {\r\npCurrSCCB->Sccb_XferState |= F_ALL_XFERRED;\r\npCurrSCCB->Sccb_sgseg =\r\n(unsigned short)(pCurrSCCB->DataLength /\r\nSG_ELEMENT_SIZE);\r\n}\r\n}\r\nelse {\r\nif (!(pCurrSCCB->Sccb_XferState & F_AUTO_SENSE))\r\npCurrSCCB->Sccb_XferState |= F_ALL_XFERRED;\r\n}\r\n}\r\nWR_HARPOON(port + hp_int_mask, (INT_CMD_COMPL | SCSI_INTERRUPT));\r\n}\r\nstatic void FPT_hostDataXferRestart(struct sccb *currSCCB)\r\n{\r\nunsigned long data_count;\r\nunsigned int sg_index;\r\nstruct blogic_sg_seg *segp;\r\nif (currSCCB->Sccb_XferState & F_SG_XFER) {\r\ncurrSCCB->Sccb_XferCnt = 0;\r\nsg_index = 0xffff;\r\ndata_count = 0;\r\nwhile (data_count < currSCCB->Sccb_ATC) {\r\nsg_index++;\r\nsegp = (struct blogic_sg_seg *)(currSCCB->DataPointer) +\r\n(sg_index * 2);\r\ndata_count += segp->segbytes;\r\n}\r\nif (data_count == currSCCB->Sccb_ATC) {\r\ncurrSCCB->Sccb_SGoffset = 0;\r\nsg_index++;\r\n}\r\nelse {\r\ncurrSCCB->Sccb_SGoffset =\r\ndata_count - currSCCB->Sccb_ATC;\r\n}\r\ncurrSCCB->Sccb_sgseg = (unsigned short)sg_index;\r\n}\r\nelse {\r\ncurrSCCB->Sccb_XferCnt =\r\ncurrSCCB->DataLength - currSCCB->Sccb_ATC;\r\n}\r\n}\r\nstatic void FPT_scini(unsigned char p_card, unsigned char p_our_id,\r\nunsigned char p_power_up)\r\n{\r\nunsigned char loser, assigned_id;\r\nu32 p_port;\r\nunsigned char i, k, ScamFlg;\r\nstruct sccb_card *currCard;\r\nstruct nvram_info *pCurrNvRam;\r\ncurrCard = &FPT_BL_Card[p_card];\r\np_port = currCard->ioPort;\r\npCurrNvRam = currCard->pNvRamInfo;\r\nif (pCurrNvRam) {\r\nScamFlg = pCurrNvRam->niScamConf;\r\ni = pCurrNvRam->niSysConf;\r\n} else {\r\nScamFlg =\r\n(unsigned char)FPT_utilEERead(p_port, SCAM_CONFIG / 2);\r\ni = (unsigned\r\nchar)(FPT_utilEERead(p_port, (SYSTEM_CONFIG / 2)));\r\n}\r\nif (!(i & 0x02))\r\nreturn;\r\nFPT_inisci(p_card, p_port, p_our_id);\r\nFPT_Wait1Second(p_port);\r\nif ((ScamFlg & SCAM_ENABLED) && (ScamFlg & SCAM_LEVEL2)) {\r\nwhile (!(FPT_scarb(p_port, INIT_SELTD))) {\r\n}\r\nFPT_scsel(p_port);\r\ndo {\r\nFPT_scxferc(p_port, SYNC_PTRN);\r\nFPT_scxferc(p_port, DOM_MSTR);\r\nloser =\r\nFPT_scsendi(p_port,\r\n&FPT_scamInfo[p_our_id].id_string[0]);\r\n} while (loser == 0xFF);\r\nFPT_scbusf(p_port);\r\nif ((p_power_up) && (!loser)) {\r\nFPT_sresb(p_port, p_card);\r\nFPT_Wait(p_port, TO_250ms);\r\nwhile (!(FPT_scarb(p_port, INIT_SELTD))) {\r\n}\r\nFPT_scsel(p_port);\r\ndo {\r\nFPT_scxferc(p_port, SYNC_PTRN);\r\nFPT_scxferc(p_port, DOM_MSTR);\r\nloser =\r\nFPT_scsendi(p_port,\r\n&FPT_scamInfo[p_our_id].\r\nid_string[0]);\r\n} while (loser == 0xFF);\r\nFPT_scbusf(p_port);\r\n}\r\n}\r\nelse {\r\nloser = 0;\r\n}\r\nif (!loser) {\r\nFPT_scamInfo[p_our_id].state = ID_ASSIGNED;\r\nif (ScamFlg & SCAM_ENABLED) {\r\nfor (i = 0; i < MAX_SCSI_TAR; i++) {\r\nif ((FPT_scamInfo[i].state == ID_UNASSIGNED) ||\r\n(FPT_scamInfo[i].state == ID_UNUSED)) {\r\nif (FPT_scsell(p_port, i)) {\r\nFPT_scamInfo[i].state = LEGACY;\r\nif ((FPT_scamInfo[i].\r\nid_string[0] != 0xFF)\r\n|| (FPT_scamInfo[i].\r\nid_string[1] != 0xFA)) {\r\nFPT_scamInfo[i].\r\nid_string[0] = 0xFF;\r\nFPT_scamInfo[i].\r\nid_string[1] = 0xFA;\r\nif (pCurrNvRam == NULL)\r\ncurrCard->\r\nglobalFlags\r\n|=\r\nF_UPDATE_EEPROM;\r\n}\r\n}\r\n}\r\n}\r\nFPT_sresb(p_port, p_card);\r\nFPT_Wait1Second(p_port);\r\nwhile (!(FPT_scarb(p_port, INIT_SELTD))) {\r\n}\r\nFPT_scsel(p_port);\r\nFPT_scasid(p_card, p_port);\r\n}\r\n}\r\nelse if ((loser) && (ScamFlg & SCAM_ENABLED)) {\r\nFPT_scamInfo[p_our_id].id_string[0] = SLV_TYPE_CODE0;\r\nassigned_id = 0;\r\nFPT_scwtsel(p_port);\r\ndo {\r\nwhile (FPT_scxferc(p_port, 0x00) != SYNC_PTRN) {\r\n}\r\ni = FPT_scxferc(p_port, 0x00);\r\nif (i == ASSIGN_ID) {\r\nif (!\r\n(FPT_scsendi\r\n(p_port,\r\n&FPT_scamInfo[p_our_id].id_string[0]))) {\r\ni = FPT_scxferc(p_port, 0x00);\r\nif (FPT_scvalq(i)) {\r\nk = FPT_scxferc(p_port, 0x00);\r\nif (FPT_scvalq(k)) {\r\ncurrCard->ourId =\r\n((unsigned char)(i\r\n<<\r\n3)\r\n+\r\n(k &\r\n(unsigned char)7))\r\n& (unsigned char)\r\n0x3F;\r\nFPT_inisci(p_card,\r\np_port,\r\np_our_id);\r\nFPT_scamInfo[currCard->\r\nourId].\r\nstate = ID_ASSIGNED;\r\nFPT_scamInfo[currCard->\r\nourId].\r\nid_string[0]\r\n= SLV_TYPE_CODE0;\r\nassigned_id = 1;\r\n}\r\n}\r\n}\r\n}\r\nelse if (i == SET_P_FLAG) {\r\nif (!(FPT_scsendi(p_port,\r\n&FPT_scamInfo[p_our_id].\r\nid_string[0])))\r\nFPT_scamInfo[p_our_id].id_string[0] |=\r\n0x80;\r\n}\r\n} while (!assigned_id);\r\nwhile (FPT_scxferc(p_port, 0x00) != CFG_CMPLT) {\r\n}\r\n}\r\nif (ScamFlg & SCAM_ENABLED) {\r\nFPT_scbusf(p_port);\r\nif (currCard->globalFlags & F_UPDATE_EEPROM) {\r\nFPT_scsavdi(p_card, p_port);\r\ncurrCard->globalFlags &= ~F_UPDATE_EEPROM;\r\n}\r\n}\r\n}\r\nstatic int FPT_scarb(u32 p_port, unsigned char p_sel_type)\r\n{\r\nif (p_sel_type == INIT_SELTD) {\r\nwhile (RD_HARPOON(p_port + hp_scsisig) & (SCSI_SEL | SCSI_BSY)) {\r\n}\r\nif (RD_HARPOON(p_port + hp_scsisig) & SCSI_SEL)\r\nreturn 0;\r\nif (RD_HARPOON(p_port + hp_scsidata_0) != 00)\r\nreturn 0;\r\nWR_HARPOON(p_port + hp_scsisig,\r\n(RD_HARPOON(p_port + hp_scsisig) | SCSI_BSY));\r\nif (RD_HARPOON(p_port + hp_scsisig) & SCSI_SEL) {\r\nWR_HARPOON(p_port + hp_scsisig,\r\n(RD_HARPOON(p_port + hp_scsisig) &\r\n~SCSI_BSY));\r\nreturn 0;\r\n}\r\nWR_HARPOON(p_port + hp_scsisig,\r\n(RD_HARPOON(p_port + hp_scsisig) | SCSI_SEL));\r\nif (RD_HARPOON(p_port + hp_scsidata_0) != 00) {\r\nWR_HARPOON(p_port + hp_scsisig,\r\n(RD_HARPOON(p_port + hp_scsisig) &\r\n~(SCSI_BSY | SCSI_SEL)));\r\nreturn 0;\r\n}\r\n}\r\nWR_HARPOON(p_port + hp_clkctrl_0, (RD_HARPOON(p_port + hp_clkctrl_0)\r\n& ~ACTdeassert));\r\nWR_HARPOON(p_port + hp_scsireset, SCAM_EN);\r\nWR_HARPOON(p_port + hp_scsidata_0, 0x00);\r\nWR_HARPOON(p_port + hp_scsidata_1, 0x00);\r\nWR_HARPOON(p_port + hp_portctrl_0, SCSI_BUS_EN);\r\nWR_HARPOON(p_port + hp_scsisig,\r\n(RD_HARPOON(p_port + hp_scsisig) | SCSI_MSG));\r\nWR_HARPOON(p_port + hp_scsisig, (RD_HARPOON(p_port + hp_scsisig)\r\n& ~SCSI_BSY));\r\nFPT_Wait(p_port, TO_250ms);\r\nreturn 1;\r\n}\r\nstatic void FPT_scbusf(u32 p_port)\r\n{\r\nWR_HARPOON(p_port + hp_page_ctrl,\r\n(RD_HARPOON(p_port + hp_page_ctrl) | G_INT_DISABLE));\r\nWR_HARPOON(p_port + hp_scsidata_0, 0x00);\r\nWR_HARPOON(p_port + hp_portctrl_0, (RD_HARPOON(p_port + hp_portctrl_0)\r\n& ~SCSI_BUS_EN));\r\nWR_HARPOON(p_port + hp_scsisig, 0x00);\r\nWR_HARPOON(p_port + hp_scsireset, (RD_HARPOON(p_port + hp_scsireset)\r\n& ~SCAM_EN));\r\nWR_HARPOON(p_port + hp_clkctrl_0, (RD_HARPOON(p_port + hp_clkctrl_0)\r\n| ACTdeassert));\r\nWRW_HARPOON((p_port + hp_intstat), (BUS_FREE | AUTO_INT | SCAM_SEL));\r\nWR_HARPOON(p_port + hp_page_ctrl,\r\n(RD_HARPOON(p_port + hp_page_ctrl) & ~G_INT_DISABLE));\r\n}\r\nstatic void FPT_scasid(unsigned char p_card, u32 p_port)\r\n{\r\nunsigned char temp_id_string[ID_STRING_LENGTH];\r\nunsigned char i, k, scam_id;\r\nunsigned char crcBytes[3];\r\nstruct nvram_info *pCurrNvRam;\r\nunsigned short *pCrcBytes;\r\npCurrNvRam = FPT_BL_Card[p_card].pNvRamInfo;\r\ni = 0;\r\nwhile (!i) {\r\nfor (k = 0; k < ID_STRING_LENGTH; k++) {\r\ntemp_id_string[k] = (unsigned char)0x00;\r\n}\r\nFPT_scxferc(p_port, SYNC_PTRN);\r\nFPT_scxferc(p_port, ASSIGN_ID);\r\nif (!(FPT_sciso(p_port, &temp_id_string[0]))) {\r\nif (pCurrNvRam) {\r\npCrcBytes = (unsigned short *)&crcBytes[0];\r\n*pCrcBytes = FPT_CalcCrc16(&temp_id_string[0]);\r\ncrcBytes[2] = FPT_CalcLrc(&temp_id_string[0]);\r\ntemp_id_string[1] = crcBytes[2];\r\ntemp_id_string[2] = crcBytes[0];\r\ntemp_id_string[3] = crcBytes[1];\r\nfor (k = 4; k < ID_STRING_LENGTH; k++)\r\ntemp_id_string[k] = (unsigned char)0x00;\r\n}\r\ni = FPT_scmachid(p_card, temp_id_string);\r\nif (i == CLR_PRIORITY) {\r\nFPT_scxferc(p_port, MISC_CODE);\r\nFPT_scxferc(p_port, CLR_P_FLAG);\r\ni = 0;\r\n}\r\nelse if (i != NO_ID_AVAIL) {\r\nif (i < 8)\r\nFPT_scxferc(p_port, ID_0_7);\r\nelse\r\nFPT_scxferc(p_port, ID_8_F);\r\nscam_id = (i & (unsigned char)0x07);\r\nfor (k = 1; k < 0x08; k <<= 1)\r\nif (!(k & i))\r\nscam_id += 0x08;\r\nFPT_scxferc(p_port, scam_id);\r\ni = 0;\r\n}\r\n}\r\nelse {\r\ni = 1;\r\n}\r\n}\r\nFPT_scxferc(p_port, SYNC_PTRN);\r\nFPT_scxferc(p_port, CFG_CMPLT);\r\n}\r\nstatic void FPT_scsel(u32 p_port)\r\n{\r\nWR_HARPOON(p_port + hp_scsisig, SCSI_SEL);\r\nFPT_scwiros(p_port, SCSI_MSG);\r\nWR_HARPOON(p_port + hp_scsisig, (SCSI_SEL | SCSI_BSY));\r\nWR_HARPOON(p_port + hp_scsisig,\r\n(SCSI_SEL | SCSI_BSY | SCSI_IOBIT | SCSI_CD));\r\nWR_HARPOON(p_port + hp_scsidata_0,\r\n(unsigned char)(RD_HARPOON(p_port + hp_scsidata_0) |\r\n(unsigned char)(BIT(7) + BIT(6))));\r\nWR_HARPOON(p_port + hp_scsisig, (SCSI_BSY | SCSI_IOBIT | SCSI_CD));\r\nFPT_scwiros(p_port, SCSI_SEL);\r\nWR_HARPOON(p_port + hp_scsidata_0,\r\n(unsigned char)(RD_HARPOON(p_port + hp_scsidata_0) &\r\n~(unsigned char)BIT(6)));\r\nFPT_scwirod(p_port, BIT(6));\r\nWR_HARPOON(p_port + hp_scsisig,\r\n(SCSI_SEL | SCSI_BSY | SCSI_IOBIT | SCSI_CD));\r\n}\r\nstatic unsigned char FPT_scxferc(u32 p_port, unsigned char p_data)\r\n{\r\nunsigned char curr_data, ret_data;\r\ncurr_data = p_data | BIT(7) | BIT(5);\r\nWR_HARPOON(p_port + hp_scsidata_0, curr_data);\r\ncurr_data &= ~BIT(7);\r\nWR_HARPOON(p_port + hp_scsidata_0, curr_data);\r\nFPT_scwirod(p_port, BIT(7));\r\nwhile (!(RD_HARPOON(p_port + hp_scsidata_0) & BIT(5))) ;\r\nret_data = (RD_HARPOON(p_port + hp_scsidata_0) & (unsigned char)0x1F);\r\ncurr_data |= BIT(6);\r\nWR_HARPOON(p_port + hp_scsidata_0, curr_data);\r\ncurr_data &= ~BIT(5);\r\nWR_HARPOON(p_port + hp_scsidata_0, curr_data);\r\nFPT_scwirod(p_port, BIT(5));\r\ncurr_data &= ~(BIT(4) | BIT(3) | BIT(2) | BIT(1) | BIT(0));\r\ncurr_data |= BIT(7);\r\nWR_HARPOON(p_port + hp_scsidata_0, curr_data);\r\ncurr_data &= ~BIT(6);\r\nWR_HARPOON(p_port + hp_scsidata_0, curr_data);\r\nFPT_scwirod(p_port, BIT(6));\r\nreturn ret_data;\r\n}\r\nstatic unsigned char FPT_scsendi(u32 p_port, unsigned char p_id_string[])\r\n{\r\nunsigned char ret_data, byte_cnt, bit_cnt, defer;\r\ndefer = 0;\r\nfor (byte_cnt = 0; byte_cnt < ID_STRING_LENGTH; byte_cnt++) {\r\nfor (bit_cnt = 0x80; bit_cnt != 0; bit_cnt >>= 1) {\r\nif (defer)\r\nret_data = FPT_scxferc(p_port, 00);\r\nelse if (p_id_string[byte_cnt] & bit_cnt)\r\nret_data = FPT_scxferc(p_port, 02);\r\nelse {\r\nret_data = FPT_scxferc(p_port, 01);\r\nif (ret_data & 02)\r\ndefer = 1;\r\n}\r\nif ((ret_data & 0x1C) == 0x10)\r\nreturn 0x00;\r\nif (ret_data & 0x1C)\r\nreturn 0xFF;\r\nif ((defer) && (!(ret_data & 0x1F)))\r\nreturn 0x01;\r\n}\r\n}\r\nif (defer)\r\nreturn 0x01;\r\nelse\r\nreturn 0;\r\n}\r\nstatic unsigned char FPT_sciso(u32 p_port, unsigned char p_id_string[])\r\n{\r\nunsigned char ret_data, the_data, byte_cnt, bit_cnt;\r\nthe_data = 0;\r\nfor (byte_cnt = 0; byte_cnt < ID_STRING_LENGTH; byte_cnt++) {\r\nfor (bit_cnt = 0; bit_cnt < 8; bit_cnt++) {\r\nret_data = FPT_scxferc(p_port, 0);\r\nif (ret_data & 0xFC)\r\nreturn 0xFF;\r\nelse {\r\nthe_data <<= 1;\r\nif (ret_data & BIT(1)) {\r\nthe_data |= 1;\r\n}\r\n}\r\nif ((ret_data & 0x1F) == 0) {\r\nif (byte_cnt)\r\nreturn 0x00;\r\nelse\r\nreturn 0xFF;\r\n}\r\n}\r\np_id_string[byte_cnt] = the_data;\r\n}\r\nreturn 0;\r\n}\r\nstatic void FPT_scwirod(u32 p_port, unsigned char p_data_bit)\r\n{\r\nunsigned char i;\r\ni = 0;\r\nwhile (i < MAX_SCSI_TAR) {\r\nif (RD_HARPOON(p_port + hp_scsidata_0) & p_data_bit)\r\ni = 0;\r\nelse\r\ni++;\r\n}\r\n}\r\nstatic void FPT_scwiros(u32 p_port, unsigned char p_data_bit)\r\n{\r\nunsigned char i;\r\ni = 0;\r\nwhile (i < MAX_SCSI_TAR) {\r\nif (RD_HARPOON(p_port + hp_scsisig) & p_data_bit)\r\ni = 0;\r\nelse\r\ni++;\r\n}\r\n}\r\nstatic unsigned char FPT_scvalq(unsigned char p_quintet)\r\n{\r\nunsigned char count;\r\nfor (count = 1; count < 0x08; count <<= 1) {\r\nif (!(p_quintet & count))\r\np_quintet -= 0x80;\r\n}\r\nif (p_quintet & 0x18)\r\nreturn 0;\r\nelse\r\nreturn 1;\r\n}\r\nstatic unsigned char FPT_scsell(u32 p_port, unsigned char targ_id)\r\n{\r\nunsigned long i;\r\nWR_HARPOON(p_port + hp_page_ctrl,\r\n(RD_HARPOON(p_port + hp_page_ctrl) | G_INT_DISABLE));\r\nARAM_ACCESS(p_port);\r\nWR_HARPOON(p_port + hp_addstat,\r\n(RD_HARPOON(p_port + hp_addstat) | SCAM_TIMER));\r\nWR_HARPOON(p_port + hp_seltimeout, TO_4ms);\r\nfor (i = p_port + CMD_STRT; i < p_port + CMD_STRT + 12; i += 2) {\r\nWRW_HARPOON(i, (MPM_OP + ACOMMAND));\r\n}\r\nWRW_HARPOON(i, (BRH_OP + ALWAYS + NP));\r\nWRW_HARPOON((p_port + hp_intstat),\r\n(RESET | TIMEOUT | SEL | BUS_FREE | AUTO_INT));\r\nWR_HARPOON(p_port + hp_select_id, targ_id);\r\nWR_HARPOON(p_port + hp_portctrl_0, SCSI_PORT);\r\nWR_HARPOON(p_port + hp_autostart_3, (SELECT | CMD_ONLY_STRT));\r\nWR_HARPOON(p_port + hp_scsictrl_0, (SEL_TAR | ENA_RESEL));\r\nwhile (!(RDW_HARPOON((p_port + hp_intstat)) &\r\n(RESET | PROG_HLT | TIMEOUT | AUTO_INT))) {\r\n}\r\nif (RDW_HARPOON((p_port + hp_intstat)) & RESET)\r\nFPT_Wait(p_port, TO_250ms);\r\nDISABLE_AUTO(p_port);\r\nWR_HARPOON(p_port + hp_addstat,\r\n(RD_HARPOON(p_port + hp_addstat) & ~SCAM_TIMER));\r\nWR_HARPOON(p_port + hp_seltimeout, TO_290ms);\r\nSGRAM_ACCESS(p_port);\r\nif (RDW_HARPOON((p_port + hp_intstat)) & (RESET | TIMEOUT)) {\r\nWRW_HARPOON((p_port + hp_intstat),\r\n(RESET | TIMEOUT | SEL | BUS_FREE | PHASE));\r\nWR_HARPOON(p_port + hp_page_ctrl,\r\n(RD_HARPOON(p_port + hp_page_ctrl) &\r\n~G_INT_DISABLE));\r\nreturn 0;\r\n}\r\nelse {\r\nwhile (!(RDW_HARPOON((p_port + hp_intstat)) & BUS_FREE)) {\r\nif (RD_HARPOON(p_port + hp_scsisig) & SCSI_REQ) {\r\nWR_HARPOON(p_port + hp_scsisig,\r\n(SCSI_ACK + S_ILL_PH));\r\nACCEPT_MSG(p_port);\r\n}\r\n}\r\nWRW_HARPOON((p_port + hp_intstat), CLR_ALL_INT_1);\r\nWR_HARPOON(p_port + hp_page_ctrl,\r\n(RD_HARPOON(p_port + hp_page_ctrl) &\r\n~G_INT_DISABLE));\r\nreturn 1;\r\n}\r\n}\r\nstatic void FPT_scwtsel(u32 p_port)\r\n{\r\nwhile (!(RDW_HARPOON((p_port + hp_intstat)) & SCAM_SEL)) {\r\n}\r\n}\r\nstatic void FPT_inisci(unsigned char p_card, u32 p_port, unsigned char p_our_id)\r\n{\r\nunsigned char i, k, max_id;\r\nunsigned short ee_data;\r\nstruct nvram_info *pCurrNvRam;\r\npCurrNvRam = FPT_BL_Card[p_card].pNvRamInfo;\r\nif (RD_HARPOON(p_port + hp_page_ctrl) & NARROW_SCSI_CARD)\r\nmax_id = 0x08;\r\nelse\r\nmax_id = 0x10;\r\nif (pCurrNvRam) {\r\nfor (i = 0; i < max_id; i++) {\r\nfor (k = 0; k < 4; k++)\r\nFPT_scamInfo[i].id_string[k] =\r\npCurrNvRam->niScamTbl[i][k];\r\nfor (k = 4; k < ID_STRING_LENGTH; k++)\r\nFPT_scamInfo[i].id_string[k] =\r\n(unsigned char)0x00;\r\nif (FPT_scamInfo[i].id_string[0] == 0x00)\r\nFPT_scamInfo[i].state = ID_UNUSED;\r\nelse\r\nFPT_scamInfo[i].state = ID_UNASSIGNED;\r\n}\r\n} else {\r\nfor (i = 0; i < max_id; i++) {\r\nfor (k = 0; k < ID_STRING_LENGTH; k += 2) {\r\nee_data =\r\nFPT_utilEERead(p_port,\r\n(unsigned\r\nshort)((EE_SCAMBASE / 2) +\r\n(unsigned short)(i *\r\n((unsigned short)ID_STRING_LENGTH / 2)) + (unsigned short)(k / 2)));\r\nFPT_scamInfo[i].id_string[k] =\r\n(unsigned char)ee_data;\r\nee_data >>= 8;\r\nFPT_scamInfo[i].id_string[k + 1] =\r\n(unsigned char)ee_data;\r\n}\r\nif ((FPT_scamInfo[i].id_string[0] == 0x00) ||\r\n(FPT_scamInfo[i].id_string[0] == 0xFF))\r\nFPT_scamInfo[i].state = ID_UNUSED;\r\nelse\r\nFPT_scamInfo[i].state = ID_UNASSIGNED;\r\n}\r\n}\r\nfor (k = 0; k < ID_STRING_LENGTH; k++)\r\nFPT_scamInfo[p_our_id].id_string[k] = FPT_scamHAString[k];\r\n}\r\nstatic unsigned char FPT_scmachid(unsigned char p_card,\r\nunsigned char p_id_string[])\r\n{\r\nunsigned char i, k, match;\r\nfor (i = 0; i < MAX_SCSI_TAR; i++) {\r\nmatch = 1;\r\nfor (k = 0; k < ID_STRING_LENGTH; k++) {\r\nif (p_id_string[k] != FPT_scamInfo[i].id_string[k])\r\nmatch = 0;\r\n}\r\nif (match) {\r\nFPT_scamInfo[i].state = ID_ASSIGNED;\r\nreturn i;\r\n}\r\n}\r\nif (p_id_string[0] & BIT(5))\r\ni = 8;\r\nelse\r\ni = MAX_SCSI_TAR;\r\nif (((p_id_string[0] & 0x06) == 0x02)\r\n|| ((p_id_string[0] & 0x06) == 0x04))\r\nmatch = p_id_string[1] & (unsigned char)0x1F;\r\nelse\r\nmatch = 7;\r\nwhile (i > 0) {\r\ni--;\r\nif (FPT_scamInfo[match].state == ID_UNUSED) {\r\nfor (k = 0; k < ID_STRING_LENGTH; k++) {\r\nFPT_scamInfo[match].id_string[k] =\r\np_id_string[k];\r\n}\r\nFPT_scamInfo[match].state = ID_ASSIGNED;\r\nif (FPT_BL_Card[p_card].pNvRamInfo == NULL)\r\nFPT_BL_Card[p_card].globalFlags |=\r\nF_UPDATE_EEPROM;\r\nreturn match;\r\n}\r\nmatch--;\r\nif (match == 0xFF) {\r\nif (p_id_string[0] & BIT(5))\r\nmatch = 7;\r\nelse\r\nmatch = MAX_SCSI_TAR - 1;\r\n}\r\n}\r\nif (p_id_string[0] & BIT(7)) {\r\nreturn CLR_PRIORITY;\r\n}\r\nif (p_id_string[0] & BIT(5))\r\ni = 8;\r\nelse\r\ni = MAX_SCSI_TAR;\r\nif (((p_id_string[0] & 0x06) == 0x02)\r\n|| ((p_id_string[0] & 0x06) == 0x04))\r\nmatch = p_id_string[1] & (unsigned char)0x1F;\r\nelse\r\nmatch = 7;\r\nwhile (i > 0) {\r\ni--;\r\nif (FPT_scamInfo[match].state == ID_UNASSIGNED) {\r\nfor (k = 0; k < ID_STRING_LENGTH; k++) {\r\nFPT_scamInfo[match].id_string[k] =\r\np_id_string[k];\r\n}\r\nFPT_scamInfo[match].id_string[0] |= BIT(7);\r\nFPT_scamInfo[match].state = ID_ASSIGNED;\r\nif (FPT_BL_Card[p_card].pNvRamInfo == NULL)\r\nFPT_BL_Card[p_card].globalFlags |=\r\nF_UPDATE_EEPROM;\r\nreturn match;\r\n}\r\nmatch--;\r\nif (match == 0xFF) {\r\nif (p_id_string[0] & BIT(5))\r\nmatch = 7;\r\nelse\r\nmatch = MAX_SCSI_TAR - 1;\r\n}\r\n}\r\nreturn NO_ID_AVAIL;\r\n}\r\nstatic void FPT_scsavdi(unsigned char p_card, u32 p_port)\r\n{\r\nunsigned char i, k, max_id;\r\nunsigned short ee_data, sum_data;\r\nsum_data = 0x0000;\r\nfor (i = 1; i < EE_SCAMBASE / 2; i++) {\r\nsum_data += FPT_utilEERead(p_port, i);\r\n}\r\nFPT_utilEEWriteOnOff(p_port, 1);\r\nif (RD_HARPOON(p_port + hp_page_ctrl) & NARROW_SCSI_CARD)\r\nmax_id = 0x08;\r\nelse\r\nmax_id = 0x10;\r\nfor (i = 0; i < max_id; i++) {\r\nfor (k = 0; k < ID_STRING_LENGTH; k += 2) {\r\nee_data = FPT_scamInfo[i].id_string[k + 1];\r\nee_data <<= 8;\r\nee_data |= FPT_scamInfo[i].id_string[k];\r\nsum_data += ee_data;\r\nFPT_utilEEWrite(p_port, ee_data,\r\n(unsigned short)((EE_SCAMBASE / 2) +\r\n(unsigned short)(i *\r\n((unsigned short)ID_STRING_LENGTH / 2)) + (unsigned short)(k / 2)));\r\n}\r\n}\r\nFPT_utilEEWrite(p_port, sum_data, EEPROM_CHECK_SUM / 2);\r\nFPT_utilEEWriteOnOff(p_port, 0);\r\n}\r\nstatic void FPT_XbowInit(u32 port, unsigned char ScamFlg)\r\n{\r\nunsigned char i;\r\ni = RD_HARPOON(port + hp_page_ctrl);\r\nWR_HARPOON(port + hp_page_ctrl, (unsigned char)(i | G_INT_DISABLE));\r\nWR_HARPOON(port + hp_scsireset, 0x00);\r\nWR_HARPOON(port + hp_portctrl_1, HOST_MODE8);\r\nWR_HARPOON(port + hp_scsireset, (DMA_RESET | HPSCSI_RESET | PROG_RESET |\r\nFIFO_CLR));\r\nWR_HARPOON(port + hp_scsireset, SCSI_INI);\r\nWR_HARPOON(port + hp_clkctrl_0, CLKCTRL_DEFAULT);\r\nWR_HARPOON(port + hp_scsisig, 0x00);\r\nWR_HARPOON(port + hp_scsictrl_0, ENA_SCAM_SEL);\r\nWRW_HARPOON((port + hp_intstat), CLR_ALL_INT);\r\nFPT_default_intena = RESET | RSEL | PROG_HLT | TIMEOUT |\r\nBUS_FREE | XFER_CNT_0 | AUTO_INT;\r\nif ((ScamFlg & SCAM_ENABLED) && (ScamFlg & SCAM_LEVEL2))\r\nFPT_default_intena |= SCAM_SEL;\r\nWRW_HARPOON((port + hp_intena), FPT_default_intena);\r\nWR_HARPOON(port + hp_seltimeout, TO_290ms);\r\nif (RD_HARPOON(port + hp_page_ctrl) & NARROW_SCSI_CARD)\r\nWR_HARPOON(port + hp_addstat, SCSI_MODE8);\r\nWR_HARPOON(port + hp_page_ctrl, i);\r\n}\r\nstatic void FPT_BusMasterInit(u32 p_port)\r\n{\r\nWR_HARPOON(p_port + hp_sys_ctrl, DRVR_RST);\r\nWR_HARPOON(p_port + hp_sys_ctrl, 0x00);\r\nWR_HARPOON(p_port + hp_host_blk_cnt, XFER_BLK64);\r\nWR_HARPOON(p_port + hp_bm_ctrl, (BMCTRL_DEFAULT));\r\nWR_HARPOON(p_port + hp_ee_ctrl, (SCSI_TERM_ENA_H));\r\nRD_HARPOON(p_port + hp_int_status);\r\nWR_HARPOON(p_port + hp_int_mask, (INT_CMD_COMPL | SCSI_INTERRUPT));\r\nWR_HARPOON(p_port + hp_page_ctrl, (RD_HARPOON(p_port + hp_page_ctrl) &\r\n~SCATTER_EN));\r\n}\r\nstatic void FPT_DiagEEPROM(u32 p_port)\r\n{\r\nunsigned short index, temp, max_wd_cnt;\r\nif (RD_HARPOON(p_port + hp_page_ctrl) & NARROW_SCSI_CARD)\r\nmax_wd_cnt = EEPROM_WD_CNT;\r\nelse\r\nmax_wd_cnt = EEPROM_WD_CNT * 2;\r\ntemp = FPT_utilEERead(p_port, FW_SIGNATURE / 2);\r\nif (temp == 0x4641) {\r\nfor (index = 2; index < max_wd_cnt; index++) {\r\ntemp += FPT_utilEERead(p_port, index);\r\n}\r\nif (temp == FPT_utilEERead(p_port, EEPROM_CHECK_SUM / 2)) {\r\nreturn;\r\n}\r\n}\r\nFPT_utilEEWriteOnOff(p_port, (unsigned char)1);\r\nfor (index = 0; index < max_wd_cnt; index++) {\r\nFPT_utilEEWrite(p_port, 0x0000, index);\r\n}\r\ntemp = 0;\r\nFPT_utilEEWrite(p_port, 0x4641, FW_SIGNATURE / 2);\r\ntemp += 0x4641;\r\nFPT_utilEEWrite(p_port, 0x3920, MODEL_NUMB_0 / 2);\r\ntemp += 0x3920;\r\nFPT_utilEEWrite(p_port, 0x3033, MODEL_NUMB_2 / 2);\r\ntemp += 0x3033;\r\nFPT_utilEEWrite(p_port, 0x2020, MODEL_NUMB_4 / 2);\r\ntemp += 0x2020;\r\nFPT_utilEEWrite(p_port, 0x70D3, SYSTEM_CONFIG / 2);\r\ntemp += 0x70D3;\r\nFPT_utilEEWrite(p_port, 0x0010, BIOS_CONFIG / 2);\r\ntemp += 0x0010;\r\nFPT_utilEEWrite(p_port, 0x0003, SCAM_CONFIG / 2);\r\ntemp += 0x0003;\r\nFPT_utilEEWrite(p_port, 0x0007, ADAPTER_SCSI_ID / 2);\r\ntemp += 0x0007;\r\nFPT_utilEEWrite(p_port, 0x0000, IGNORE_B_SCAN / 2);\r\ntemp += 0x0000;\r\nFPT_utilEEWrite(p_port, 0x0000, SEND_START_ENA / 2);\r\ntemp += 0x0000;\r\nFPT_utilEEWrite(p_port, 0x0000, DEVICE_ENABLE / 2);\r\ntemp += 0x0000;\r\nFPT_utilEEWrite(p_port, 0x4242, SYNC_RATE_TBL01 / 2);\r\ntemp += 0x4242;\r\nFPT_utilEEWrite(p_port, 0x4242, SYNC_RATE_TBL23 / 2);\r\ntemp += 0x4242;\r\nFPT_utilEEWrite(p_port, 0x4242, SYNC_RATE_TBL45 / 2);\r\ntemp += 0x4242;\r\nFPT_utilEEWrite(p_port, 0x4242, SYNC_RATE_TBL67 / 2);\r\ntemp += 0x4242;\r\nFPT_utilEEWrite(p_port, 0x4242, SYNC_RATE_TBL89 / 2);\r\ntemp += 0x4242;\r\nFPT_utilEEWrite(p_port, 0x4242, SYNC_RATE_TBLab / 2);\r\ntemp += 0x4242;\r\nFPT_utilEEWrite(p_port, 0x4242, SYNC_RATE_TBLcd / 2);\r\ntemp += 0x4242;\r\nFPT_utilEEWrite(p_port, 0x4242, SYNC_RATE_TBLef / 2);\r\ntemp += 0x4242;\r\nFPT_utilEEWrite(p_port, 0x6C46, 64 / 2);\r\ntemp += 0x6C46;\r\nFPT_utilEEWrite(p_port, 0x7361, 66 / 2);\r\ntemp += 0x7361;\r\nFPT_utilEEWrite(p_port, 0x5068, 68 / 2);\r\ntemp += 0x5068;\r\nFPT_utilEEWrite(p_port, 0x696F, 70 / 2);\r\ntemp += 0x696F;\r\nFPT_utilEEWrite(p_port, 0x746E, 72 / 2);\r\ntemp += 0x746E;\r\nFPT_utilEEWrite(p_port, 0x4C20, 74 / 2);\r\ntemp += 0x4C20;\r\nFPT_utilEEWrite(p_port, 0x2054, 76 / 2);\r\ntemp += 0x2054;\r\nFPT_utilEEWrite(p_port, 0x2020, 78 / 2);\r\ntemp += 0x2020;\r\nindex = ((EE_SCAMBASE / 2) + (7 * 16));\r\nFPT_utilEEWrite(p_port, (0x0700 + TYPE_CODE0), index);\r\ntemp += (0x0700 + TYPE_CODE0);\r\nindex++;\r\nFPT_utilEEWrite(p_port, 0x5542, index);\r\ntemp += 0x5542;\r\nindex++;\r\nFPT_utilEEWrite(p_port, 0x4C53, index);\r\ntemp += 0x4C53;\r\nindex++;\r\nFPT_utilEEWrite(p_port, 0x474F, index);\r\ntemp += 0x474F;\r\nindex++;\r\nFPT_utilEEWrite(p_port, 0x4349, index);\r\ntemp += 0x4349;\r\nindex++;\r\nFPT_utilEEWrite(p_port, 0x5442, index);\r\ntemp += 0x5442;\r\nindex++;\r\nFPT_utilEEWrite(p_port, 0x202D, index);\r\ntemp += 0x202D;\r\nindex++;\r\nFPT_utilEEWrite(p_port, 0x3339, index);\r\ntemp += 0x3339;\r\nindex++;\r\nFPT_utilEEWrite(p_port, 0x2030, index);\r\ntemp += 0x2030;\r\nindex++;\r\nFPT_utilEEWrite(p_port, 0x5453, index);\r\ntemp += 0x5453;\r\nindex++;\r\nFPT_utilEEWrite(p_port, 0x5645, index);\r\ntemp += 0x5645;\r\nindex++;\r\nFPT_utilEEWrite(p_port, 0x2045, index);\r\ntemp += 0x2045;\r\nindex++;\r\nFPT_utilEEWrite(p_port, 0x202F, index);\r\ntemp += 0x202F;\r\nindex++;\r\nFPT_utilEEWrite(p_port, 0x4F4A, index);\r\ntemp += 0x4F4A;\r\nindex++;\r\nFPT_utilEEWrite(p_port, 0x204E, index);\r\ntemp += 0x204E;\r\nindex++;\r\nFPT_utilEEWrite(p_port, 0x3539, index);\r\ntemp += 0x3539;\r\nFPT_utilEEWrite(p_port, temp, EEPROM_CHECK_SUM / 2);\r\nFPT_utilEEWriteOnOff(p_port, (unsigned char)0);\r\n}\r\nstatic void FPT_queueSearchSelect(struct sccb_card *pCurrCard,\r\nunsigned char p_card)\r\n{\r\nunsigned char scan_ptr, lun;\r\nstruct sccb_mgr_tar_info *currTar_Info;\r\nstruct sccb *pOldSccb;\r\nscan_ptr = pCurrCard->scanIndex;\r\ndo {\r\ncurrTar_Info = &FPT_sccbMgrTbl[p_card][scan_ptr];\r\nif ((pCurrCard->globalFlags & F_CONLUN_IO) &&\r\n((currTar_Info->TarStatus & TAR_TAG_Q_MASK) !=\r\nTAG_Q_TRYING)) {\r\nif (currTar_Info->TarSelQ_Cnt != 0) {\r\nscan_ptr++;\r\nif (scan_ptr == MAX_SCSI_TAR)\r\nscan_ptr = 0;\r\nfor (lun = 0; lun < MAX_LUN; lun++) {\r\nif (currTar_Info->TarLUNBusy[lun] == 0) {\r\npCurrCard->currentSCCB =\r\ncurrTar_Info->TarSelQ_Head;\r\npOldSccb = NULL;\r\nwhile ((pCurrCard->\r\ncurrentSCCB != NULL)\r\n&& (lun !=\r\npCurrCard->\r\ncurrentSCCB->Lun)) {\r\npOldSccb =\r\npCurrCard->\r\ncurrentSCCB;\r\npCurrCard->currentSCCB =\r\n(struct sccb\r\n*)(pCurrCard->\r\ncurrentSCCB)->\r\nSccb_forwardlink;\r\n}\r\nif (pCurrCard->currentSCCB ==\r\nNULL)\r\ncontinue;\r\nif (pOldSccb != NULL) {\r\npOldSccb->\r\nSccb_forwardlink =\r\n(struct sccb\r\n*)(pCurrCard->\r\ncurrentSCCB)->\r\nSccb_forwardlink;\r\npOldSccb->\r\nSccb_backlink =\r\n(struct sccb\r\n*)(pCurrCard->\r\ncurrentSCCB)->\r\nSccb_backlink;\r\ncurrTar_Info->\r\nTarSelQ_Cnt--;\r\n} else {\r\ncurrTar_Info->\r\nTarSelQ_Head =\r\n(struct sccb\r\n*)(pCurrCard->\r\ncurrentSCCB)->\r\nSccb_forwardlink;\r\nif (currTar_Info->\r\nTarSelQ_Head ==\r\nNULL) {\r\ncurrTar_Info->\r\nTarSelQ_Tail\r\n= NULL;\r\ncurrTar_Info->\r\nTarSelQ_Cnt\r\n= 0;\r\n} else {\r\ncurrTar_Info->\r\nTarSelQ_Cnt--;\r\ncurrTar_Info->\r\nTarSelQ_Head->\r\nSccb_backlink\r\n=\r\n(struct sccb\r\n*)NULL;\r\n}\r\n}\r\npCurrCard->scanIndex = scan_ptr;\r\npCurrCard->globalFlags |=\r\nF_NEW_SCCB_CMD;\r\nbreak;\r\n}\r\n}\r\n}\r\nelse {\r\nscan_ptr++;\r\nif (scan_ptr == MAX_SCSI_TAR) {\r\nscan_ptr = 0;\r\n}\r\n}\r\n} else {\r\nif ((currTar_Info->TarSelQ_Cnt != 0) &&\r\n(currTar_Info->TarLUNBusy[0] == 0)) {\r\npCurrCard->currentSCCB =\r\ncurrTar_Info->TarSelQ_Head;\r\ncurrTar_Info->TarSelQ_Head =\r\n(struct sccb *)(pCurrCard->currentSCCB)->\r\nSccb_forwardlink;\r\nif (currTar_Info->TarSelQ_Head == NULL) {\r\ncurrTar_Info->TarSelQ_Tail = NULL;\r\ncurrTar_Info->TarSelQ_Cnt = 0;\r\n} else {\r\ncurrTar_Info->TarSelQ_Cnt--;\r\ncurrTar_Info->TarSelQ_Head->\r\nSccb_backlink = (struct sccb *)NULL;\r\n}\r\nscan_ptr++;\r\nif (scan_ptr == MAX_SCSI_TAR)\r\nscan_ptr = 0;\r\npCurrCard->scanIndex = scan_ptr;\r\npCurrCard->globalFlags |= F_NEW_SCCB_CMD;\r\nbreak;\r\n}\r\nelse {\r\nscan_ptr++;\r\nif (scan_ptr == MAX_SCSI_TAR) {\r\nscan_ptr = 0;\r\n}\r\n}\r\n}\r\n} while (scan_ptr != pCurrCard->scanIndex);\r\n}\r\nstatic void FPT_queueSelectFail(struct sccb_card *pCurrCard,\r\nunsigned char p_card)\r\n{\r\nunsigned char thisTarg;\r\nstruct sccb_mgr_tar_info *currTar_Info;\r\nif (pCurrCard->currentSCCB != NULL) {\r\nthisTarg =\r\n(unsigned char)(((struct sccb *)(pCurrCard->currentSCCB))->\r\nTargID);\r\ncurrTar_Info = &FPT_sccbMgrTbl[p_card][thisTarg];\r\npCurrCard->currentSCCB->Sccb_backlink = (struct sccb *)NULL;\r\npCurrCard->currentSCCB->Sccb_forwardlink =\r\ncurrTar_Info->TarSelQ_Head;\r\nif (currTar_Info->TarSelQ_Cnt == 0) {\r\ncurrTar_Info->TarSelQ_Tail = pCurrCard->currentSCCB;\r\n}\r\nelse {\r\ncurrTar_Info->TarSelQ_Head->Sccb_backlink =\r\npCurrCard->currentSCCB;\r\n}\r\ncurrTar_Info->TarSelQ_Head = pCurrCard->currentSCCB;\r\npCurrCard->currentSCCB = NULL;\r\ncurrTar_Info->TarSelQ_Cnt++;\r\n}\r\n}\r\nstatic void FPT_queueCmdComplete(struct sccb_card *pCurrCard,\r\nstruct sccb *p_sccb, unsigned char p_card)\r\n{\r\nunsigned char i, SCSIcmd;\r\nCALL_BK_FN callback;\r\nstruct sccb_mgr_tar_info *currTar_Info;\r\nSCSIcmd = p_sccb->Cdb[0];\r\nif (!(p_sccb->Sccb_XferState & F_ALL_XFERRED)) {\r\nif ((p_sccb->\r\nControlByte & (SCCB_DATA_XFER_OUT | SCCB_DATA_XFER_IN))\r\n&& (p_sccb->HostStatus == SCCB_COMPLETE)\r\n&& (p_sccb->TargetStatus != SSCHECK))\r\nif ((SCSIcmd == SCSI_READ) ||\r\n(SCSIcmd == SCSI_WRITE) ||\r\n(SCSIcmd == SCSI_READ_EXTENDED) ||\r\n(SCSIcmd == SCSI_WRITE_EXTENDED) ||\r\n(SCSIcmd == SCSI_WRITE_AND_VERIFY) ||\r\n(SCSIcmd == SCSI_START_STOP_UNIT) ||\r\n(pCurrCard->globalFlags & F_NO_FILTER)\r\n)\r\np_sccb->HostStatus = SCCB_DATA_UNDER_RUN;\r\n}\r\nif (p_sccb->SccbStatus == SCCB_IN_PROCESS) {\r\nif (p_sccb->HostStatus || p_sccb->TargetStatus)\r\np_sccb->SccbStatus = SCCB_ERROR;\r\nelse\r\np_sccb->SccbStatus = SCCB_SUCCESS;\r\n}\r\nif (p_sccb->Sccb_XferState & F_AUTO_SENSE) {\r\np_sccb->CdbLength = p_sccb->Save_CdbLen;\r\nfor (i = 0; i < 6; i++) {\r\np_sccb->Cdb[i] = p_sccb->Save_Cdb[i];\r\n}\r\n}\r\nif ((p_sccb->OperationCode == RESIDUAL_SG_COMMAND) ||\r\n(p_sccb->OperationCode == RESIDUAL_COMMAND)) {\r\nFPT_utilUpdateResidual(p_sccb);\r\n}\r\npCurrCard->cmdCounter--;\r\nif (!pCurrCard->cmdCounter) {\r\nif (pCurrCard->globalFlags & F_GREEN_PC) {\r\nWR_HARPOON(pCurrCard->ioPort + hp_clkctrl_0,\r\n(PWR_DWN | CLKCTRL_DEFAULT));\r\nWR_HARPOON(pCurrCard->ioPort + hp_sys_ctrl, STOP_CLK);\r\n}\r\nWR_HARPOON(pCurrCard->ioPort + hp_semaphore,\r\n(RD_HARPOON(pCurrCard->ioPort + hp_semaphore) &\r\n~SCCB_MGR_ACTIVE));\r\n}\r\nif (pCurrCard->discQCount != 0) {\r\ncurrTar_Info = &FPT_sccbMgrTbl[p_card][p_sccb->TargID];\r\nif (((pCurrCard->globalFlags & F_CONLUN_IO) &&\r\n((currTar_Info->TarStatus & TAR_TAG_Q_MASK) !=\r\nTAG_Q_TRYING))) {\r\npCurrCard->discQCount--;\r\npCurrCard->discQ_Tbl[currTar_Info->\r\nLunDiscQ_Idx[p_sccb->Lun]] = NULL;\r\n} else {\r\nif (p_sccb->Sccb_tag) {\r\npCurrCard->discQCount--;\r\npCurrCard->discQ_Tbl[p_sccb->Sccb_tag] = NULL;\r\n} else {\r\npCurrCard->discQCount--;\r\npCurrCard->discQ_Tbl[currTar_Info->\r\nLunDiscQ_Idx[0]] = NULL;\r\n}\r\n}\r\n}\r\ncallback = (CALL_BK_FN) p_sccb->SccbCallback;\r\ncallback(p_sccb);\r\npCurrCard->globalFlags |= F_NEW_SCCB_CMD;\r\npCurrCard->currentSCCB = NULL;\r\n}\r\nstatic void FPT_queueDisconnect(struct sccb *p_sccb, unsigned char p_card)\r\n{\r\nstruct sccb_mgr_tar_info *currTar_Info;\r\ncurrTar_Info = &FPT_sccbMgrTbl[p_card][p_sccb->TargID];\r\nif (((FPT_BL_Card[p_card].globalFlags & F_CONLUN_IO) &&\r\n((currTar_Info->TarStatus & TAR_TAG_Q_MASK) != TAG_Q_TRYING))) {\r\nFPT_BL_Card[p_card].discQ_Tbl[currTar_Info->\r\nLunDiscQ_Idx[p_sccb->Lun]] =\r\np_sccb;\r\n} else {\r\nif (p_sccb->Sccb_tag) {\r\nFPT_BL_Card[p_card].discQ_Tbl[p_sccb->Sccb_tag] =\r\np_sccb;\r\nFPT_sccbMgrTbl[p_card][p_sccb->TargID].TarLUNBusy[0] =\r\n0;\r\nFPT_sccbMgrTbl[p_card][p_sccb->TargID].TarTagQ_Cnt++;\r\n} else {\r\nFPT_BL_Card[p_card].discQ_Tbl[currTar_Info->\r\nLunDiscQ_Idx[0]] = p_sccb;\r\n}\r\n}\r\nFPT_BL_Card[p_card].currentSCCB = NULL;\r\n}\r\nstatic void FPT_queueFlushSccb(unsigned char p_card, unsigned char error_code)\r\n{\r\nunsigned char qtag, thisTarg;\r\nstruct sccb *currSCCB;\r\nstruct sccb_mgr_tar_info *currTar_Info;\r\ncurrSCCB = FPT_BL_Card[p_card].currentSCCB;\r\nif (currSCCB != NULL) {\r\nthisTarg = (unsigned char)currSCCB->TargID;\r\ncurrTar_Info = &FPT_sccbMgrTbl[p_card][thisTarg];\r\nfor (qtag = 0; qtag < QUEUE_DEPTH; qtag++) {\r\nif (FPT_BL_Card[p_card].discQ_Tbl[qtag] &&\r\n(FPT_BL_Card[p_card].discQ_Tbl[qtag]->TargID ==\r\nthisTarg)) {\r\nFPT_BL_Card[p_card].discQ_Tbl[qtag]->\r\nHostStatus = (unsigned char)error_code;\r\nFPT_queueCmdComplete(&FPT_BL_Card[p_card],\r\nFPT_BL_Card[p_card].\r\ndiscQ_Tbl[qtag], p_card);\r\nFPT_BL_Card[p_card].discQ_Tbl[qtag] = NULL;\r\ncurrTar_Info->TarTagQ_Cnt--;\r\n}\r\n}\r\n}\r\n}\r\nstatic void FPT_queueFlushTargSccb(unsigned char p_card, unsigned char thisTarg,\r\nunsigned char error_code)\r\n{\r\nunsigned char qtag;\r\nstruct sccb_mgr_tar_info *currTar_Info;\r\ncurrTar_Info = &FPT_sccbMgrTbl[p_card][thisTarg];\r\nfor (qtag = 0; qtag < QUEUE_DEPTH; qtag++) {\r\nif (FPT_BL_Card[p_card].discQ_Tbl[qtag] &&\r\n(FPT_BL_Card[p_card].discQ_Tbl[qtag]->TargID == thisTarg)) {\r\nFPT_BL_Card[p_card].discQ_Tbl[qtag]->HostStatus =\r\n(unsigned char)error_code;\r\nFPT_queueCmdComplete(&FPT_BL_Card[p_card],\r\nFPT_BL_Card[p_card].\r\ndiscQ_Tbl[qtag], p_card);\r\nFPT_BL_Card[p_card].discQ_Tbl[qtag] = NULL;\r\ncurrTar_Info->TarTagQ_Cnt--;\r\n}\r\n}\r\n}\r\nstatic void FPT_queueAddSccb(struct sccb *p_SCCB, unsigned char p_card)\r\n{\r\nstruct sccb_mgr_tar_info *currTar_Info;\r\ncurrTar_Info = &FPT_sccbMgrTbl[p_card][p_SCCB->TargID];\r\np_SCCB->Sccb_forwardlink = NULL;\r\np_SCCB->Sccb_backlink = currTar_Info->TarSelQ_Tail;\r\nif (currTar_Info->TarSelQ_Cnt == 0) {\r\ncurrTar_Info->TarSelQ_Head = p_SCCB;\r\n}\r\nelse {\r\ncurrTar_Info->TarSelQ_Tail->Sccb_forwardlink = p_SCCB;\r\n}\r\ncurrTar_Info->TarSelQ_Tail = p_SCCB;\r\ncurrTar_Info->TarSelQ_Cnt++;\r\n}\r\nstatic unsigned char FPT_queueFindSccb(struct sccb *p_SCCB,\r\nunsigned char p_card)\r\n{\r\nstruct sccb *q_ptr;\r\nstruct sccb_mgr_tar_info *currTar_Info;\r\ncurrTar_Info = &FPT_sccbMgrTbl[p_card][p_SCCB->TargID];\r\nq_ptr = currTar_Info->TarSelQ_Head;\r\nwhile (q_ptr != NULL) {\r\nif (q_ptr == p_SCCB) {\r\nif (currTar_Info->TarSelQ_Head == q_ptr) {\r\ncurrTar_Info->TarSelQ_Head =\r\nq_ptr->Sccb_forwardlink;\r\n}\r\nif (currTar_Info->TarSelQ_Tail == q_ptr) {\r\ncurrTar_Info->TarSelQ_Tail =\r\nq_ptr->Sccb_backlink;\r\n}\r\nif (q_ptr->Sccb_forwardlink != NULL) {\r\nq_ptr->Sccb_forwardlink->Sccb_backlink =\r\nq_ptr->Sccb_backlink;\r\n}\r\nif (q_ptr->Sccb_backlink != NULL) {\r\nq_ptr->Sccb_backlink->Sccb_forwardlink =\r\nq_ptr->Sccb_forwardlink;\r\n}\r\ncurrTar_Info->TarSelQ_Cnt--;\r\nreturn 1;\r\n}\r\nelse {\r\nq_ptr = q_ptr->Sccb_forwardlink;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic void FPT_utilUpdateResidual(struct sccb *p_SCCB)\r\n{\r\nunsigned long partial_cnt;\r\nunsigned int sg_index;\r\nstruct blogic_sg_seg *segp;\r\nif (p_SCCB->Sccb_XferState & F_ALL_XFERRED) {\r\np_SCCB->DataLength = 0x0000;\r\n}\r\nelse if (p_SCCB->Sccb_XferState & F_SG_XFER) {\r\npartial_cnt = 0x0000;\r\nsg_index = p_SCCB->Sccb_sgseg;\r\nif (p_SCCB->Sccb_SGoffset) {\r\npartial_cnt = p_SCCB->Sccb_SGoffset;\r\nsg_index++;\r\n}\r\nwhile (((unsigned long)sg_index *\r\n(unsigned long)SG_ELEMENT_SIZE) < p_SCCB->DataLength) {\r\nsegp = (struct blogic_sg_seg *)(p_SCCB->DataPointer) +\r\n(sg_index * 2);\r\npartial_cnt += segp->segbytes;\r\nsg_index++;\r\n}\r\np_SCCB->DataLength = partial_cnt;\r\n}\r\nelse {\r\np_SCCB->DataLength -= p_SCCB->Sccb_ATC;\r\n}\r\n}\r\nstatic void FPT_Wait1Second(u32 p_port)\r\n{\r\nunsigned char i;\r\nfor (i = 0; i < 4; i++) {\r\nFPT_Wait(p_port, TO_250ms);\r\nif ((RD_HARPOON(p_port + hp_scsictrl_0) & SCSI_RST))\r\nbreak;\r\nif ((RDW_HARPOON((p_port + hp_intstat)) & SCAM_SEL))\r\nbreak;\r\n}\r\n}\r\nstatic void FPT_Wait(u32 p_port, unsigned char p_delay)\r\n{\r\nunsigned char old_timer;\r\nunsigned char green_flag;\r\nold_timer = RD_HARPOON(p_port + hp_seltimeout);\r\ngreen_flag = RD_HARPOON(p_port + hp_clkctrl_0);\r\nWR_HARPOON(p_port + hp_clkctrl_0, CLKCTRL_DEFAULT);\r\nWR_HARPOON(p_port + hp_seltimeout, p_delay);\r\nWRW_HARPOON((p_port + hp_intstat), TIMEOUT);\r\nWRW_HARPOON((p_port + hp_intena), (FPT_default_intena & ~TIMEOUT));\r\nWR_HARPOON(p_port + hp_portctrl_0,\r\n(RD_HARPOON(p_port + hp_portctrl_0) | START_TO));\r\nwhile (!(RDW_HARPOON((p_port + hp_intstat)) & TIMEOUT)) {\r\nif ((RD_HARPOON(p_port + hp_scsictrl_0) & SCSI_RST))\r\nbreak;\r\nif ((RDW_HARPOON((p_port + hp_intstat)) & SCAM_SEL))\r\nbreak;\r\n}\r\nWR_HARPOON(p_port + hp_portctrl_0,\r\n(RD_HARPOON(p_port + hp_portctrl_0) & ~START_TO));\r\nWRW_HARPOON((p_port + hp_intstat), TIMEOUT);\r\nWRW_HARPOON((p_port + hp_intena), FPT_default_intena);\r\nWR_HARPOON(p_port + hp_clkctrl_0, green_flag);\r\nWR_HARPOON(p_port + hp_seltimeout, old_timer);\r\n}\r\nstatic void FPT_utilEEWriteOnOff(u32 p_port, unsigned char p_mode)\r\n{\r\nunsigned char ee_value;\r\nee_value =\r\n(unsigned char)(RD_HARPOON(p_port + hp_ee_ctrl) &\r\n(EXT_ARB_ACK | SCSI_TERM_ENA_H));\r\nif (p_mode)\r\nFPT_utilEESendCmdAddr(p_port, EWEN, EWEN_ADDR);\r\nelse\r\nFPT_utilEESendCmdAddr(p_port, EWDS, EWDS_ADDR);\r\nWR_HARPOON(p_port + hp_ee_ctrl, (ee_value | SEE_MS));\r\nWR_HARPOON(p_port + hp_ee_ctrl, ee_value);\r\n}\r\nstatic void FPT_utilEEWrite(u32 p_port, unsigned short ee_data,\r\nunsigned short ee_addr)\r\n{\r\nunsigned char ee_value;\r\nunsigned short i;\r\nee_value =\r\n(unsigned\r\nchar)((RD_HARPOON(p_port + hp_ee_ctrl) &\r\n(EXT_ARB_ACK | SCSI_TERM_ENA_H)) | (SEE_MS | SEE_CS));\r\nFPT_utilEESendCmdAddr(p_port, EE_WRITE, ee_addr);\r\nee_value |= (SEE_MS + SEE_CS);\r\nfor (i = 0x8000; i != 0; i >>= 1) {\r\nif (i & ee_data)\r\nee_value |= SEE_DO;\r\nelse\r\nee_value &= ~SEE_DO;\r\nWR_HARPOON(p_port + hp_ee_ctrl, ee_value);\r\nWR_HARPOON(p_port + hp_ee_ctrl, ee_value);\r\nee_value |= SEE_CLK;\r\nWR_HARPOON(p_port + hp_ee_ctrl, ee_value);\r\nWR_HARPOON(p_port + hp_ee_ctrl, ee_value);\r\nee_value &= ~SEE_CLK;\r\nWR_HARPOON(p_port + hp_ee_ctrl, ee_value);\r\nWR_HARPOON(p_port + hp_ee_ctrl, ee_value);\r\n}\r\nee_value &= (EXT_ARB_ACK | SCSI_TERM_ENA_H);\r\nWR_HARPOON(p_port + hp_ee_ctrl, (ee_value | SEE_MS));\r\nFPT_Wait(p_port, TO_10ms);\r\nWR_HARPOON(p_port + hp_ee_ctrl, (ee_value | SEE_MS | SEE_CS));\r\nWR_HARPOON(p_port + hp_ee_ctrl, (ee_value | SEE_MS));\r\nWR_HARPOON(p_port + hp_ee_ctrl, ee_value);\r\n}\r\nstatic unsigned short FPT_utilEERead(u32 p_port,\r\nunsigned short ee_addr)\r\n{\r\nunsigned short i, ee_data1, ee_data2;\r\ni = 0;\r\nee_data1 = FPT_utilEEReadOrg(p_port, ee_addr);\r\ndo {\r\nee_data2 = FPT_utilEEReadOrg(p_port, ee_addr);\r\nif (ee_data1 == ee_data2)\r\nreturn ee_data1;\r\nee_data1 = ee_data2;\r\ni++;\r\n} while (i < 4);\r\nreturn ee_data1;\r\n}\r\nstatic unsigned short FPT_utilEEReadOrg(u32 p_port, unsigned short ee_addr)\r\n{\r\nunsigned char ee_value;\r\nunsigned short i, ee_data;\r\nee_value =\r\n(unsigned\r\nchar)((RD_HARPOON(p_port + hp_ee_ctrl) &\r\n(EXT_ARB_ACK | SCSI_TERM_ENA_H)) | (SEE_MS | SEE_CS));\r\nFPT_utilEESendCmdAddr(p_port, EE_READ, ee_addr);\r\nee_value |= (SEE_MS + SEE_CS);\r\nee_data = 0;\r\nfor (i = 1; i <= 16; i++) {\r\nee_value |= SEE_CLK;\r\nWR_HARPOON(p_port + hp_ee_ctrl, ee_value);\r\nWR_HARPOON(p_port + hp_ee_ctrl, ee_value);\r\nee_value &= ~SEE_CLK;\r\nWR_HARPOON(p_port + hp_ee_ctrl, ee_value);\r\nWR_HARPOON(p_port + hp_ee_ctrl, ee_value);\r\nee_data <<= 1;\r\nif (RD_HARPOON(p_port + hp_ee_ctrl) & SEE_DI)\r\nee_data |= 1;\r\n}\r\nee_value &= ~(SEE_MS + SEE_CS);\r\nWR_HARPOON(p_port + hp_ee_ctrl, (ee_value | SEE_MS));\r\nWR_HARPOON(p_port + hp_ee_ctrl, ee_value);\r\nreturn ee_data;\r\n}\r\nstatic void FPT_utilEESendCmdAddr(u32 p_port, unsigned char ee_cmd,\r\nunsigned short ee_addr)\r\n{\r\nunsigned char ee_value;\r\nunsigned char narrow_flg;\r\nunsigned short i;\r\nnarrow_flg =\r\n(unsigned char)(RD_HARPOON(p_port + hp_page_ctrl) &\r\nNARROW_SCSI_CARD);\r\nee_value = SEE_MS;\r\nWR_HARPOON(p_port + hp_ee_ctrl, ee_value);\r\nee_value |= SEE_CS;\r\nWR_HARPOON(p_port + hp_ee_ctrl, ee_value);\r\nfor (i = 0x04; i != 0; i >>= 1) {\r\nif (i & ee_cmd)\r\nee_value |= SEE_DO;\r\nelse\r\nee_value &= ~SEE_DO;\r\nWR_HARPOON(p_port + hp_ee_ctrl, ee_value);\r\nWR_HARPOON(p_port + hp_ee_ctrl, ee_value);\r\nee_value |= SEE_CLK;\r\nWR_HARPOON(p_port + hp_ee_ctrl, ee_value);\r\nWR_HARPOON(p_port + hp_ee_ctrl, ee_value);\r\nee_value &= ~SEE_CLK;\r\nWR_HARPOON(p_port + hp_ee_ctrl, ee_value);\r\nWR_HARPOON(p_port + hp_ee_ctrl, ee_value);\r\n}\r\nif (narrow_flg)\r\ni = 0x0080;\r\nelse\r\ni = 0x0200;\r\nwhile (i != 0) {\r\nif (i & ee_addr)\r\nee_value |= SEE_DO;\r\nelse\r\nee_value &= ~SEE_DO;\r\nWR_HARPOON(p_port + hp_ee_ctrl, ee_value);\r\nWR_HARPOON(p_port + hp_ee_ctrl, ee_value);\r\nee_value |= SEE_CLK;\r\nWR_HARPOON(p_port + hp_ee_ctrl, ee_value);\r\nWR_HARPOON(p_port + hp_ee_ctrl, ee_value);\r\nee_value &= ~SEE_CLK;\r\nWR_HARPOON(p_port + hp_ee_ctrl, ee_value);\r\nWR_HARPOON(p_port + hp_ee_ctrl, ee_value);\r\ni >>= 1;\r\n}\r\n}\r\nstatic unsigned short FPT_CalcCrc16(unsigned char buffer[])\r\n{\r\nunsigned short crc = 0;\r\nint i, j;\r\nunsigned short ch;\r\nfor (i = 0; i < ID_STRING_LENGTH; i++) {\r\nch = (unsigned short)buffer[i];\r\nfor (j = 0; j < 8; j++) {\r\nif ((crc ^ ch) & 1)\r\ncrc = (crc >> 1) ^ CRCMASK;\r\nelse\r\ncrc >>= 1;\r\nch >>= 1;\r\n}\r\n}\r\nreturn crc;\r\n}\r\nstatic unsigned char FPT_CalcLrc(unsigned char buffer[])\r\n{\r\nint i;\r\nunsigned char lrc;\r\nlrc = 0;\r\nfor (i = 0; i < ID_STRING_LENGTH; i++)\r\nlrc ^= buffer[i];\r\nreturn lrc;\r\n}\r\nstatic inline unsigned char\r\nFlashPoint__ProbeHostAdapter(struct fpoint_info *FlashPointInfo)\r\n{\r\nreturn FlashPoint_ProbeHostAdapter((struct sccb_mgr_info *)\r\nFlashPointInfo);\r\n}\r\nstatic inline void *\r\nFlashPoint__HardwareResetHostAdapter(struct fpoint_info *FlashPointInfo)\r\n{\r\nreturn FlashPoint_HardwareResetHostAdapter((struct sccb_mgr_info *)\r\nFlashPointInfo);\r\n}\r\nstatic inline void\r\nFlashPoint__ReleaseHostAdapter(void *CardHandle)\r\n{\r\nFlashPoint_ReleaseHostAdapter(CardHandle);\r\n}\r\nstatic inline void\r\nFlashPoint__StartCCB(void *CardHandle, struct blogic_ccb *CCB)\r\n{\r\nFlashPoint_StartCCB(CardHandle, (struct sccb *)CCB);\r\n}\r\nstatic inline void\r\nFlashPoint__AbortCCB(void *CardHandle, struct blogic_ccb *CCB)\r\n{\r\nFlashPoint_AbortCCB(CardHandle, (struct sccb *)CCB);\r\n}\r\nstatic inline bool\r\nFlashPoint__InterruptPending(void *CardHandle)\r\n{\r\nreturn FlashPoint_InterruptPending(CardHandle);\r\n}\r\nstatic inline int\r\nFlashPoint__HandleInterrupt(void *CardHandle)\r\n{\r\nreturn FlashPoint_HandleInterrupt(CardHandle);\r\n}
