static void\r\ncris_console_write(struct console *co, const char *s, unsigned int count)\r\n{\r\nstruct uart_cris_port *up;\r\nint i;\r\nreg_ser_r_stat_din stat;\r\nreg_ser_rw_tr_dma_en tr_dma_en, old;\r\nup = etraxfs_uart_ports[co->index];\r\nif (!up)\r\nreturn;\r\ntr_dma_en = old = REG_RD(ser, up->regi_ser, rw_tr_dma_en);\r\nif (tr_dma_en.en == regk_ser_yes) {\r\ntr_dma_en.en = regk_ser_no;\r\nREG_WR(ser, up->regi_ser, rw_tr_dma_en, tr_dma_en);\r\n}\r\nfor (i = 0; i < count; i++) {\r\nif (s[i] == '\n') {\r\ndo {\r\nstat = REG_RD(ser, up->regi_ser, r_stat_din);\r\n} while (!stat.tr_rdy);\r\nREG_WR_INT(ser, up->regi_ser, rw_dout, '\r');\r\n}\r\ndo {\r\nstat = REG_RD(ser, up->regi_ser, r_stat_din);\r\n} while (!stat.tr_rdy);\r\nREG_WR_INT(ser, up->regi_ser, rw_dout, s[i]);\r\n}\r\nif (tr_dma_en.en != old.en)\r\nREG_WR(ser, up->regi_ser, rw_tr_dma_en, old);\r\n}\r\nstatic int __init\r\ncris_console_setup(struct console *co, char *options)\r\n{\r\nstruct uart_port *port;\r\nint baud = 115200;\r\nint bits = 8;\r\nint parity = 'n';\r\nint flow = 'n';\r\nif (co->index < 0 || co->index >= UART_NR)\r\nco->index = 0;\r\nport = &etraxfs_uart_ports[co->index]->port;\r\nconsole_port = port;\r\nco->flags |= CON_CONSDEV;\r\nif (options)\r\nuart_parse_options(options, &baud, &parity, &bits, &flow);\r\nconsole_baud = baud;\r\ncris_serial_port_init(port, co->index);\r\nuart_set_options(port, co, baud, parity, bits, flow);\r\nreturn 0;\r\n}\r\nstatic inline int crisv32_serial_get_rts(struct uart_cris_port *up)\r\n{\r\nvoid __iomem *regi_ser = up->regi_ser;\r\nreg_ser_r_stat_din rstat = REG_RD(ser, regi_ser, r_stat_din);\r\nreturn !(rstat.rts_n == regk_ser_active);\r\n}\r\nstatic inline void crisv32_serial_set_rts(struct uart_cris_port *up,\r\nint set, int force)\r\n{\r\nvoid __iomem *regi_ser = up->regi_ser;\r\nunsigned long flags;\r\nreg_ser_rw_rec_ctrl rec_ctrl;\r\nlocal_irq_save(flags);\r\nrec_ctrl = REG_RD(ser, regi_ser, rw_rec_ctrl);\r\nif (set)\r\nrec_ctrl.rts_n = regk_ser_active;\r\nelse\r\nrec_ctrl.rts_n = regk_ser_inactive;\r\nREG_WR(ser, regi_ser, rw_rec_ctrl, rec_ctrl);\r\nlocal_irq_restore(flags);\r\n}\r\nstatic inline int crisv32_serial_get_cts(struct uart_cris_port *up)\r\n{\r\nvoid __iomem *regi_ser = up->regi_ser;\r\nreg_ser_r_stat_din rstat = REG_RD(ser, regi_ser, r_stat_din);\r\nreturn (rstat.cts_n == regk_ser_active);\r\n}\r\nstatic void etraxfs_uart_send_xchar(struct uart_port *port, char ch)\r\n{\r\nstruct uart_cris_port *up = (struct uart_cris_port *)port;\r\nreg_ser_rw_dout dout = { .data = ch };\r\nreg_ser_rw_ack_intr ack_intr = { .tr_rdy = regk_ser_yes };\r\nreg_ser_r_stat_din rstat;\r\nreg_ser_rw_tr_ctrl prev_tr_ctrl, tr_ctrl;\r\nvoid __iomem *regi_ser = up->regi_ser;\r\nunsigned long flags;\r\nspin_lock_irqsave(&port->lock, flags);\r\ndo {\r\nspin_unlock_irqrestore(&port->lock, flags);\r\nspin_lock_irqsave(&port->lock, flags);\r\nprev_tr_ctrl = tr_ctrl = REG_RD(ser, regi_ser, rw_tr_ctrl);\r\nrstat = REG_RD(ser, regi_ser, r_stat_din);\r\n} while (!rstat.tr_rdy);\r\nREG_WR(ser, regi_ser, rw_ack_intr, ack_intr);\r\ntr_ctrl.stop = 0;\r\nREG_WR(ser, regi_ser, rw_tr_ctrl, tr_ctrl);\r\nREG_WR(ser, regi_ser, rw_dout, dout);\r\nup->port.icount.tx++;\r\nrstat = REG_RD(ser, up->regi_ser, r_stat_din);\r\nif (rstat.xoff_detect) {\r\nreg_ser_rw_xoff_clr xoff_clr = { .clr = 1 };\r\nreg_ser_rw_tr_dma_en tr_dma_en;\r\nREG_WR(ser, regi_ser, rw_xoff_clr, xoff_clr);\r\ntr_dma_en = REG_RD(ser, regi_ser, rw_tr_dma_en);\r\nprev_tr_ctrl.stop = 1;\r\ntr_dma_en.en = 0;\r\nREG_WR(ser, regi_ser, rw_tr_dma_en, tr_dma_en);\r\n}\r\nREG_WR(ser, regi_ser, rw_tr_ctrl, prev_tr_ctrl);\r\nspin_unlock_irqrestore(&port->lock, flags);\r\n}\r\nstatic void etraxfs_uart_start_tx(struct uart_port *port)\r\n{\r\nstruct uart_cris_port *up = (struct uart_cris_port *)port;\r\nif (up->write_ongoing)\r\nreturn;\r\nup->write_ongoing = 1;\r\netraxfs_uart_start_tx_bottom(port);\r\n}\r\nstatic inline void etraxfs_uart_start_tx_bottom(struct uart_port *port)\r\n{\r\nstruct uart_cris_port *up = (struct uart_cris_port *)port;\r\nvoid __iomem *regi_ser = up->regi_ser;\r\nreg_ser_rw_tr_ctrl tr_ctrl;\r\nreg_ser_rw_intr_mask intr_mask;\r\ntr_ctrl = REG_RD(ser, regi_ser, rw_tr_ctrl);\r\ntr_ctrl.stop = regk_ser_no;\r\nREG_WR(ser, regi_ser, rw_tr_ctrl, tr_ctrl);\r\nintr_mask = REG_RD(ser, regi_ser, rw_intr_mask);\r\nintr_mask.tr_rdy = regk_ser_yes;\r\nREG_WR(ser, regi_ser, rw_intr_mask, intr_mask);\r\n}\r\nstatic void etraxfs_uart_stop_tx(struct uart_port *port)\r\n{\r\nstruct uart_cris_port *up = (struct uart_cris_port *)port;\r\nvoid __iomem *regi_ser = up->regi_ser;\r\nreg_ser_rw_tr_ctrl tr_ctrl;\r\nreg_ser_rw_intr_mask intr_mask;\r\nreg_ser_rw_tr_dma_en tr_dma_en = {0};\r\nreg_ser_rw_xoff_clr xoff_clr = {0};\r\nintr_mask = REG_RD(ser, regi_ser, rw_intr_mask);\r\nintr_mask.tr_rdy = regk_ser_no;\r\nREG_WR(ser, regi_ser, rw_intr_mask, intr_mask);\r\ntr_ctrl = REG_RD(ser, regi_ser, rw_tr_ctrl);\r\ntr_ctrl.stop = 1;\r\nREG_WR(ser, regi_ser, rw_tr_ctrl, tr_ctrl);\r\nxoff_clr.clr = 1;\r\nREG_WR(ser, regi_ser, rw_xoff_clr, xoff_clr);\r\ntr_dma_en.en = 0;\r\nREG_WR(ser, regi_ser, rw_tr_dma_en, tr_dma_en);\r\nup->write_ongoing = 0;\r\n}\r\nstatic void etraxfs_uart_stop_rx(struct uart_port *port)\r\n{\r\nstruct uart_cris_port *up = (struct uart_cris_port *)port;\r\nvoid __iomem *regi_ser = up->regi_ser;\r\nreg_ser_rw_rec_ctrl rec_ctrl = REG_RD(ser, regi_ser, rw_rec_ctrl);\r\nrec_ctrl.en = regk_ser_no;\r\nREG_WR(ser, regi_ser, rw_rec_ctrl, rec_ctrl);\r\n}\r\nstatic unsigned int etraxfs_uart_tx_empty(struct uart_port *port)\r\n{\r\nstruct uart_cris_port *up = (struct uart_cris_port *)port;\r\nunsigned long flags;\r\nunsigned int ret;\r\nreg_ser_r_stat_din rstat = {0};\r\nspin_lock_irqsave(&up->port.lock, flags);\r\nrstat = REG_RD(ser, up->regi_ser, r_stat_din);\r\nret = rstat.tr_empty ? TIOCSER_TEMT : 0;\r\nspin_unlock_irqrestore(&up->port.lock, flags);\r\nreturn ret;\r\n}\r\nstatic unsigned int etraxfs_uart_get_mctrl(struct uart_port *port)\r\n{\r\nstruct uart_cris_port *up = (struct uart_cris_port *)port;\r\nunsigned int ret;\r\nret = 0;\r\nif (crisv32_serial_get_rts(up))\r\nret |= TIOCM_RTS;\r\nif (crisv32_serial_get_cts(up))\r\nret |= TIOCM_CTS;\r\nreturn mctrl_gpio_get(up->gpios, &ret);\r\n}\r\nstatic void etraxfs_uart_set_mctrl(struct uart_port *port, unsigned int mctrl)\r\n{\r\nstruct uart_cris_port *up = (struct uart_cris_port *)port;\r\ncrisv32_serial_set_rts(up, mctrl & TIOCM_RTS ? 1 : 0, 0);\r\nmctrl_gpio_set(up->gpios, mctrl);\r\n}\r\nstatic void etraxfs_uart_break_ctl(struct uart_port *port, int break_state)\r\n{\r\nstruct uart_cris_port *up = (struct uart_cris_port *)port;\r\nunsigned long flags;\r\nreg_ser_rw_tr_ctrl tr_ctrl;\r\nreg_ser_rw_tr_dma_en tr_dma_en;\r\nreg_ser_rw_intr_mask intr_mask;\r\nspin_lock_irqsave(&up->port.lock, flags);\r\ntr_ctrl = REG_RD(ser, up->regi_ser, rw_tr_ctrl);\r\ntr_dma_en = REG_RD(ser, up->regi_ser, rw_tr_dma_en);\r\nintr_mask = REG_RD(ser, up->regi_ser, rw_intr_mask);\r\nif (break_state != 0) {\r\nintr_mask.tr_rdy = regk_ser_no;\r\ntr_dma_en.en = 0;\r\ntr_ctrl.stop = 1;\r\ntr_ctrl.txd = 0;\r\n} else {\r\nintr_mask.tr_rdy = regk_ser_yes;\r\ntr_ctrl.stop = 0;\r\ntr_ctrl.txd = 1;\r\n}\r\nREG_WR(ser, up->regi_ser, rw_tr_ctrl, tr_ctrl);\r\nREG_WR(ser, up->regi_ser, rw_tr_dma_en, tr_dma_en);\r\nREG_WR(ser, up->regi_ser, rw_intr_mask, intr_mask);\r\nspin_unlock_irqrestore(&up->port.lock, flags);\r\n}\r\nstatic void\r\ntransmit_chars_no_dma(struct uart_cris_port *up)\r\n{\r\nint max_count;\r\nstruct circ_buf *xmit = &up->port.state->xmit;\r\nvoid __iomem *regi_ser = up->regi_ser;\r\nreg_ser_r_stat_din rstat;\r\nreg_ser_rw_ack_intr ack_intr = { .tr_rdy = regk_ser_yes };\r\nif (uart_circ_empty(xmit) || uart_tx_stopped(&up->port)) {\r\nreg_ser_rw_intr_mask intr_mask;\r\nintr_mask = REG_RD(ser, regi_ser, rw_intr_mask);\r\nintr_mask.tr_rdy = 0;\r\nintr_mask.tr_empty = 0;\r\nREG_WR(ser, regi_ser, rw_intr_mask, intr_mask);\r\nup->write_ongoing = 0;\r\nreturn;\r\n}\r\nmax_count = 64;\r\ndo {\r\nreg_ser_rw_dout dout = { .data = xmit->buf[xmit->tail] };\r\nREG_WR(ser, regi_ser, rw_dout, dout);\r\nREG_WR(ser, regi_ser, rw_ack_intr, ack_intr);\r\nxmit->tail = (xmit->tail + 1) & (UART_XMIT_SIZE-1);\r\nup->port.icount.tx++;\r\nif (xmit->head == xmit->tail)\r\nbreak;\r\nrstat = REG_RD(ser, regi_ser, r_stat_din);\r\n} while ((--max_count > 0) && rstat.tr_rdy);\r\nif (uart_circ_chars_pending(xmit) < WAKEUP_CHARS)\r\nuart_write_wakeup(&up->port);\r\n}\r\nstatic void receive_chars_no_dma(struct uart_cris_port *up)\r\n{\r\nreg_ser_rs_stat_din stat_din;\r\nreg_ser_r_stat_din rstat;\r\nstruct tty_port *port;\r\nstruct uart_icount *icount;\r\nint max_count = 16;\r\nchar flag;\r\nreg_ser_rw_ack_intr ack_intr = { 0 };\r\nrstat = REG_RD(ser, up->regi_ser, r_stat_din);\r\nicount = &up->port.icount;\r\nport = &up->port.state->port;\r\ndo {\r\nstat_din = REG_RD(ser, up->regi_ser, rs_stat_din);\r\nflag = TTY_NORMAL;\r\nack_intr.dav = 1;\r\nREG_WR(ser, up->regi_ser, rw_ack_intr, ack_intr);\r\nicount->rx++;\r\nif (stat_din.framing_err | stat_din.par_err | stat_din.orun) {\r\nif (stat_din.data == 0x00 &&\r\nstat_din.framing_err) {\r\nflag = TTY_BREAK;\r\nicount->brk++;\r\n} else if (stat_din.par_err) {\r\nflag = TTY_PARITY;\r\nicount->parity++;\r\n} else if (stat_din.orun) {\r\nflag = TTY_OVERRUN;\r\nicount->overrun++;\r\n} else if (stat_din.framing_err) {\r\nflag = TTY_FRAME;\r\nicount->frame++;\r\n}\r\n}\r\nif (!tty_insert_flip_char(port, stat_din.data, flag))\r\npanic("%s: No tty buffer space", __func__);\r\nrstat = REG_RD(ser, up->regi_ser, r_stat_din);\r\n} while (rstat.dav && (max_count-- > 0));\r\nspin_unlock(&up->port.lock);\r\ntty_flip_buffer_push(port);\r\nspin_lock(&up->port.lock);\r\n}\r\nstatic irqreturn_t\r\nser_interrupt(int irq, void *dev_id)\r\n{\r\nstruct uart_cris_port *up = (struct uart_cris_port *)dev_id;\r\nvoid __iomem *regi_ser;\r\nint handled = 0;\r\nspin_lock(&up->port.lock);\r\nregi_ser = up->regi_ser;\r\nif (regi_ser) {\r\nreg_ser_r_masked_intr masked_intr;\r\nmasked_intr = REG_RD(ser, regi_ser, r_masked_intr);\r\nif (masked_intr.dav) {\r\nreceive_chars_no_dma(up);\r\nhandled = 1;\r\n}\r\nif (masked_intr.tr_rdy) {\r\ntransmit_chars_no_dma(up);\r\nhandled = 1;\r\n}\r\n}\r\nspin_unlock(&up->port.lock);\r\nreturn IRQ_RETVAL(handled);\r\n}\r\nstatic int etraxfs_uart_get_poll_char(struct uart_port *port)\r\n{\r\nreg_ser_rs_stat_din stat;\r\nreg_ser_rw_ack_intr ack_intr = { 0 };\r\nstruct uart_cris_port *up = (struct uart_cris_port *)port;\r\ndo {\r\nstat = REG_RD(ser, up->regi_ser, rs_stat_din);\r\n} while (!stat.dav);\r\nack_intr.dav = 1;\r\nREG_WR(ser, up->regi_ser, rw_ack_intr, ack_intr);\r\nreturn stat.data;\r\n}\r\nstatic void etraxfs_uart_put_poll_char(struct uart_port *port,\r\nunsigned char c)\r\n{\r\nreg_ser_r_stat_din stat;\r\nstruct uart_cris_port *up = (struct uart_cris_port *)port;\r\ndo {\r\nstat = REG_RD(ser, up->regi_ser, r_stat_din);\r\n} while (!stat.tr_rdy);\r\nREG_WR_INT(ser, up->regi_ser, rw_dout, c);\r\n}\r\nstatic int etraxfs_uart_startup(struct uart_port *port)\r\n{\r\nstruct uart_cris_port *up = (struct uart_cris_port *)port;\r\nunsigned long flags;\r\nreg_ser_rw_intr_mask ser_intr_mask = {0};\r\nser_intr_mask.dav = regk_ser_yes;\r\nif (request_irq(etraxfs_uart_ports[port->line]->irq, ser_interrupt,\r\n0, DRV_NAME, etraxfs_uart_ports[port->line]))\r\npanic("irq ser%d", port->line);\r\nspin_lock_irqsave(&up->port.lock, flags);\r\nREG_WR(ser, up->regi_ser, rw_intr_mask, ser_intr_mask);\r\netraxfs_uart_set_mctrl(&up->port, up->port.mctrl);\r\nspin_unlock_irqrestore(&up->port.lock, flags);\r\nreturn 0;\r\n}\r\nstatic void etraxfs_uart_shutdown(struct uart_port *port)\r\n{\r\nstruct uart_cris_port *up = (struct uart_cris_port *)port;\r\nunsigned long flags;\r\nspin_lock_irqsave(&up->port.lock, flags);\r\netraxfs_uart_stop_tx(port);\r\netraxfs_uart_stop_rx(port);\r\nfree_irq(etraxfs_uart_ports[port->line]->irq,\r\netraxfs_uart_ports[port->line]);\r\netraxfs_uart_set_mctrl(&up->port, up->port.mctrl);\r\nspin_unlock_irqrestore(&up->port.lock, flags);\r\n}\r\nstatic void\r\netraxfs_uart_set_termios(struct uart_port *port, struct ktermios *termios,\r\nstruct ktermios *old)\r\n{\r\nstruct uart_cris_port *up = (struct uart_cris_port *)port;\r\nunsigned long flags;\r\nreg_ser_rw_xoff xoff;\r\nreg_ser_rw_xoff_clr xoff_clr = {0};\r\nreg_ser_rw_tr_ctrl tx_ctrl = {0};\r\nreg_ser_rw_tr_dma_en tx_dma_en = {0};\r\nreg_ser_rw_rec_ctrl rx_ctrl = {0};\r\nreg_ser_rw_tr_baud_div tx_baud_div = {0};\r\nreg_ser_rw_rec_baud_div rx_baud_div = {0};\r\nint baud;\r\nif (old &&\r\ntermios->c_cflag == old->c_cflag &&\r\ntermios->c_iflag == old->c_iflag)\r\nreturn;\r\ntx_ctrl.base_freq = regk_ser_f29_493;\r\ntx_ctrl.en = 0;\r\ntx_ctrl.stop = 0;\r\ntx_ctrl.auto_rts = regk_ser_no;\r\ntx_ctrl.txd = 1;\r\ntx_ctrl.auto_cts = 0;\r\nrx_ctrl.dma_err = regk_ser_stop;\r\nrx_ctrl.sampling = regk_ser_majority;\r\nrx_ctrl.timeout = 1;\r\nrx_ctrl.rts_n = regk_ser_inactive;\r\ntx_ctrl.data_bits = regk_ser_bits8;\r\nrx_ctrl.data_bits = regk_ser_bits8;\r\ntx_ctrl.par = regk_ser_even;\r\nrx_ctrl.par = regk_ser_even;\r\ntx_ctrl.par_en = regk_ser_no;\r\nrx_ctrl.par_en = regk_ser_no;\r\ntx_ctrl.stop_bits = regk_ser_bits1;\r\nif ((port != console_port) || old)\r\nbaud = uart_get_baud_rate(port, termios, old, 0,\r\nport->uartclk / 8);\r\nelse\r\nbaud = console_baud;\r\ntx_baud_div.div = 29493000 / (8 * baud);\r\nrx_baud_div.div = tx_baud_div.div;\r\nrx_ctrl.base_freq = tx_ctrl.base_freq;\r\nif ((termios->c_cflag & CSIZE) == CS7) {\r\ntx_ctrl.data_bits = regk_ser_bits7;\r\nrx_ctrl.data_bits = regk_ser_bits7;\r\n}\r\nif (termios->c_cflag & CSTOPB) {\r\ntx_ctrl.stop_bits = regk_ser_bits2;\r\n}\r\nif (termios->c_cflag & PARENB) {\r\ntx_ctrl.par_en = regk_ser_yes;\r\nrx_ctrl.par_en = regk_ser_yes;\r\n}\r\nif (termios->c_cflag & CMSPAR) {\r\nif (termios->c_cflag & PARODD) {\r\ntx_ctrl.par = regk_ser_mark;\r\nrx_ctrl.par = regk_ser_mark;\r\n} else {\r\ntx_ctrl.par = regk_ser_space;\r\nrx_ctrl.par = regk_ser_space;\r\n}\r\n} else {\r\nif (termios->c_cflag & PARODD) {\r\ntx_ctrl.par = regk_ser_odd;\r\nrx_ctrl.par = regk_ser_odd;\r\n}\r\n}\r\nif (termios->c_cflag & CRTSCTS) {\r\ntx_ctrl.auto_cts = regk_ser_yes;\r\n}\r\ntx_ctrl.en = regk_ser_yes;\r\nrx_ctrl.en = regk_ser_yes;\r\nspin_lock_irqsave(&port->lock, flags);\r\ntx_dma_en.en = 0;\r\nREG_WR(ser, up->regi_ser, rw_tr_dma_en, tx_dma_en);\r\nuart_update_timeout(port, termios->c_cflag, port->uartclk/8);\r\nMODIFY_REG(up->regi_ser, rw_rec_baud_div, rx_baud_div);\r\nMODIFY_REG(up->regi_ser, rw_rec_ctrl, rx_ctrl);\r\nMODIFY_REG(up->regi_ser, rw_tr_baud_div, tx_baud_div);\r\nMODIFY_REG(up->regi_ser, rw_tr_ctrl, tx_ctrl);\r\ntx_dma_en.en = 0;\r\nREG_WR(ser, up->regi_ser, rw_tr_dma_en, tx_dma_en);\r\nxoff = REG_RD(ser, up->regi_ser, rw_xoff);\r\nif (up->port.state && up->port.state->port.tty &&\r\n(up->port.state->port.tty->termios.c_iflag & IXON)) {\r\nxoff.chr = STOP_CHAR(up->port.state->port.tty);\r\nxoff.automatic = regk_ser_yes;\r\n} else\r\nxoff.automatic = regk_ser_no;\r\nMODIFY_REG(up->regi_ser, rw_xoff, xoff);\r\nxoff_clr.clr = 1;\r\nREG_WR(ser, up->regi_ser, rw_xoff_clr, xoff_clr);\r\netraxfs_uart_set_mctrl(&up->port, up->port.mctrl);\r\nspin_unlock_irqrestore(&up->port.lock, flags);\r\n}\r\nstatic const char *\r\netraxfs_uart_type(struct uart_port *port)\r\n{\r\nreturn "CRISv32";\r\n}\r\nstatic void etraxfs_uart_release_port(struct uart_port *port)\r\n{\r\n}\r\nstatic int etraxfs_uart_request_port(struct uart_port *port)\r\n{\r\nreturn 0;\r\n}\r\nstatic void etraxfs_uart_config_port(struct uart_port *port, int flags)\r\n{\r\nstruct uart_cris_port *up = (struct uart_cris_port *)port;\r\nup->port.type = PORT_CRIS;\r\n}\r\nstatic void cris_serial_port_init(struct uart_port *port, int line)\r\n{\r\nstruct uart_cris_port *up = (struct uart_cris_port *)port;\r\nif (up->initialized)\r\nreturn;\r\nup->initialized = 1;\r\nport->line = line;\r\nspin_lock_init(&port->lock);\r\nport->ops = &etraxfs_uart_pops;\r\nport->irq = up->irq;\r\nport->iobase = (unsigned long) up->regi_ser;\r\nport->uartclk = 29493000;\r\nport->fifosize = 255;\r\nport->flags = UPF_BOOT_AUTOCONF;\r\n}\r\nstatic int etraxfs_uart_probe(struct platform_device *pdev)\r\n{\r\nstruct device_node *np = pdev->dev.of_node;\r\nstruct uart_cris_port *up;\r\nint dev_id;\r\nif (!np)\r\nreturn -ENODEV;\r\ndev_id = of_alias_get_id(np, "serial");\r\nif (dev_id < 0)\r\ndev_id = 0;\r\nif (dev_id >= UART_NR)\r\nreturn -EINVAL;\r\nif (etraxfs_uart_ports[dev_id])\r\nreturn -EBUSY;\r\nup = devm_kzalloc(&pdev->dev, sizeof(struct uart_cris_port),\r\nGFP_KERNEL);\r\nif (!up)\r\nreturn -ENOMEM;\r\nup->irq = irq_of_parse_and_map(np, 0);\r\nup->regi_ser = of_iomap(np, 0);\r\nup->port.dev = &pdev->dev;\r\nup->gpios = mctrl_gpio_init_noauto(&pdev->dev, 0);\r\nif (IS_ERR(up->gpios))\r\nreturn PTR_ERR(up->gpios);\r\ncris_serial_port_init(&up->port, dev_id);\r\netraxfs_uart_ports[dev_id] = up;\r\nplatform_set_drvdata(pdev, &up->port);\r\nuart_add_one_port(&etraxfs_uart_driver, &up->port);\r\nreturn 0;\r\n}\r\nstatic int etraxfs_uart_remove(struct platform_device *pdev)\r\n{\r\nstruct uart_port *port;\r\nport = platform_get_drvdata(pdev);\r\nuart_remove_one_port(&etraxfs_uart_driver, port);\r\netraxfs_uart_ports[port->line] = NULL;\r\nreturn 0;\r\n}\r\nstatic int __init etraxfs_uart_init(void)\r\n{\r\nint ret;\r\nret = uart_register_driver(&etraxfs_uart_driver);\r\nif (ret)\r\nreturn ret;\r\nret = platform_driver_register(&etraxfs_uart_platform_driver);\r\nif (ret)\r\nuart_unregister_driver(&etraxfs_uart_driver);\r\nreturn ret;\r\n}\r\nstatic void __exit etraxfs_uart_exit(void)\r\n{\r\nplatform_driver_unregister(&etraxfs_uart_platform_driver);\r\nuart_unregister_driver(&etraxfs_uart_driver);\r\n}
