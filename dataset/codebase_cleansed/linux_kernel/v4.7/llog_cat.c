static int llog_cat_id2handle(const struct lu_env *env,\r\nstruct llog_handle *cathandle,\r\nstruct llog_handle **res,\r\nstruct llog_logid *logid)\r\n{\r\nstruct llog_handle *loghandle;\r\nint rc = 0;\r\nif (!cathandle)\r\nreturn -EBADF;\r\ndown_write(&cathandle->lgh_lock);\r\nlist_for_each_entry(loghandle, &cathandle->u.chd.chd_head,\r\nu.phd.phd_entry) {\r\nstruct llog_logid *cgl = &loghandle->lgh_id;\r\nif (ostid_id(&cgl->lgl_oi) == ostid_id(&logid->lgl_oi) &&\r\nostid_seq(&cgl->lgl_oi) == ostid_seq(&logid->lgl_oi)) {\r\nif (cgl->lgl_ogen != logid->lgl_ogen) {\r\nCERROR("%s: log "DOSTID" generation %x != %x\n",\r\nloghandle->lgh_ctxt->loc_obd->obd_name,\r\nPOSTID(&logid->lgl_oi), cgl->lgl_ogen,\r\nlogid->lgl_ogen);\r\ncontinue;\r\n}\r\nloghandle->u.phd.phd_cat_handle = cathandle;\r\nup_write(&cathandle->lgh_lock);\r\nrc = 0;\r\ngoto out;\r\n}\r\n}\r\nup_write(&cathandle->lgh_lock);\r\nrc = llog_open(env, cathandle->lgh_ctxt, &loghandle, logid, NULL,\r\nLLOG_OPEN_EXISTS);\r\nif (rc < 0) {\r\nCERROR("%s: error opening log id "DOSTID":%x: rc = %d\n",\r\ncathandle->lgh_ctxt->loc_obd->obd_name,\r\nPOSTID(&logid->lgl_oi), logid->lgl_ogen, rc);\r\nreturn rc;\r\n}\r\nrc = llog_init_handle(env, loghandle, LLOG_F_IS_PLAIN, NULL);\r\nif (rc < 0) {\r\nllog_close(env, loghandle);\r\nloghandle = NULL;\r\nreturn rc;\r\n}\r\ndown_write(&cathandle->lgh_lock);\r\nlist_add(&loghandle->u.phd.phd_entry, &cathandle->u.chd.chd_head);\r\nup_write(&cathandle->lgh_lock);\r\nloghandle->u.phd.phd_cat_handle = cathandle;\r\nloghandle->u.phd.phd_cookie.lgc_lgl = cathandle->lgh_id;\r\nloghandle->u.phd.phd_cookie.lgc_index =\r\nloghandle->lgh_hdr->llh_cat_idx;\r\nout:\r\nllog_handle_get(loghandle);\r\n*res = loghandle;\r\nreturn 0;\r\n}\r\nint llog_cat_close(const struct lu_env *env, struct llog_handle *cathandle)\r\n{\r\nstruct llog_handle *loghandle, *n;\r\nint rc;\r\nlist_for_each_entry_safe(loghandle, n, &cathandle->u.chd.chd_head,\r\nu.phd.phd_entry) {\r\nlist_del_init(&loghandle->u.phd.phd_entry);\r\nllog_close(env, loghandle);\r\n}\r\nif (cathandle->lgh_ctxt->loc_handle == cathandle)\r\ncathandle->lgh_ctxt->loc_handle = NULL;\r\nrc = llog_close(env, cathandle);\r\nreturn rc;\r\n}\r\nstatic int llog_cat_process_cb(const struct lu_env *env,\r\nstruct llog_handle *cat_llh,\r\nstruct llog_rec_hdr *rec, void *data)\r\n{\r\nstruct llog_process_data *d = data;\r\nstruct llog_logid_rec *lir = (struct llog_logid_rec *)rec;\r\nstruct llog_handle *llh;\r\nint rc;\r\nif (rec->lrh_type != LLOG_LOGID_MAGIC) {\r\nCERROR("invalid record in catalog\n");\r\nreturn -EINVAL;\r\n}\r\nCDEBUG(D_HA, "processing log "DOSTID":%x at index %u of catalog "\r\nDOSTID"\n", POSTID(&lir->lid_id.lgl_oi), lir->lid_id.lgl_ogen,\r\nrec->lrh_index, POSTID(&cat_llh->lgh_id.lgl_oi));\r\nrc = llog_cat_id2handle(env, cat_llh, &llh, &lir->lid_id);\r\nif (rc) {\r\nCERROR("%s: cannot find handle for llog "DOSTID": %d\n",\r\ncat_llh->lgh_ctxt->loc_obd->obd_name,\r\nPOSTID(&lir->lid_id.lgl_oi), rc);\r\nreturn rc;\r\n}\r\nif (rec->lrh_index < d->lpd_startcat)\r\nrc = 0;\r\nelse if (d->lpd_startidx > 0) {\r\nstruct llog_process_cat_data cd;\r\ncd.lpcd_first_idx = d->lpd_startidx;\r\ncd.lpcd_last_idx = 0;\r\nrc = llog_process_or_fork(env, llh, d->lpd_cb, d->lpd_data,\r\n&cd, false);\r\nd->lpd_startidx = 0;\r\n} else {\r\nrc = llog_process_or_fork(env, llh, d->lpd_cb, d->lpd_data,\r\nNULL, false);\r\n}\r\nllog_handle_put(llh);\r\nreturn rc;\r\n}\r\nstatic int llog_cat_process_or_fork(const struct lu_env *env,\r\nstruct llog_handle *cat_llh,\r\nllog_cb_t cb, void *data, int startcat,\r\nint startidx, bool fork)\r\n{\r\nstruct llog_process_data d;\r\nstruct llog_log_hdr *llh = cat_llh->lgh_hdr;\r\nint rc;\r\nLASSERT(llh->llh_flags & LLOG_F_IS_CAT);\r\nd.lpd_data = data;\r\nd.lpd_cb = cb;\r\nd.lpd_startcat = startcat;\r\nd.lpd_startidx = startidx;\r\nif (llh->llh_cat_idx > cat_llh->lgh_last_idx) {\r\nstruct llog_process_cat_data cd;\r\nCWARN("catlog "DOSTID" crosses index zero\n",\r\nPOSTID(&cat_llh->lgh_id.lgl_oi));\r\ncd.lpcd_first_idx = llh->llh_cat_idx;\r\ncd.lpcd_last_idx = 0;\r\nrc = llog_process_or_fork(env, cat_llh, llog_cat_process_cb,\r\n&d, &cd, fork);\r\nif (rc != 0)\r\nreturn rc;\r\ncd.lpcd_first_idx = 0;\r\ncd.lpcd_last_idx = cat_llh->lgh_last_idx;\r\nrc = llog_process_or_fork(env, cat_llh, llog_cat_process_cb,\r\n&d, &cd, fork);\r\n} else {\r\nrc = llog_process_or_fork(env, cat_llh, llog_cat_process_cb,\r\n&d, NULL, fork);\r\n}\r\nreturn rc;\r\n}\r\nint llog_cat_process(const struct lu_env *env, struct llog_handle *cat_llh,\r\nllog_cb_t cb, void *data, int startcat, int startidx)\r\n{\r\nreturn llog_cat_process_or_fork(env, cat_llh, cb, data, startcat,\r\nstartidx, false);\r\n}
