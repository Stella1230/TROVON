static int is_rndis(struct usb_interface_descriptor *desc)\r\n{\r\nreturn (desc->bInterfaceClass == USB_CLASS_COMM &&\r\ndesc->bInterfaceSubClass == 2 &&\r\ndesc->bInterfaceProtocol == 0xff);\r\n}\r\nstatic int is_activesync(struct usb_interface_descriptor *desc)\r\n{\r\nreturn (desc->bInterfaceClass == USB_CLASS_MISC &&\r\ndesc->bInterfaceSubClass == 1 &&\r\ndesc->bInterfaceProtocol == 1);\r\n}\r\nstatic int is_wireless_rndis(struct usb_interface_descriptor *desc)\r\n{\r\nreturn (desc->bInterfaceClass == USB_CLASS_WIRELESS_CONTROLLER &&\r\ndesc->bInterfaceSubClass == 1 &&\r\ndesc->bInterfaceProtocol == 3);\r\n}\r\nstatic void usbnet_cdc_update_filter(struct usbnet *dev)\r\n{\r\nstruct cdc_state *info = (void *) &dev->data;\r\nstruct usb_interface *intf = info->control;\r\nstruct net_device *net = dev->net;\r\nu16 cdc_filter = USB_CDC_PACKET_TYPE_DIRECTED\r\n| USB_CDC_PACKET_TYPE_BROADCAST;\r\nif (net->flags & IFF_PROMISC)\r\ncdc_filter |= USB_CDC_PACKET_TYPE_PROMISCUOUS;\r\nif (!netdev_mc_empty(net) || (net->flags & IFF_ALLMULTI))\r\ncdc_filter |= USB_CDC_PACKET_TYPE_ALL_MULTICAST;\r\nusb_control_msg(dev->udev,\r\nusb_sndctrlpipe(dev->udev, 0),\r\nUSB_CDC_SET_ETHERNET_PACKET_FILTER,\r\nUSB_TYPE_CLASS | USB_RECIP_INTERFACE,\r\ncdc_filter,\r\nintf->cur_altsetting->desc.bInterfaceNumber,\r\nNULL,\r\n0,\r\nUSB_CTRL_SET_TIMEOUT\r\n);\r\n}\r\nint usbnet_generic_cdc_bind(struct usbnet *dev, struct usb_interface *intf)\r\n{\r\nu8 *buf = intf->cur_altsetting->extra;\r\nint len = intf->cur_altsetting->extralen;\r\nstruct usb_interface_descriptor *d;\r\nstruct cdc_state *info = (void *) &dev->data;\r\nint status;\r\nint rndis;\r\nbool android_rndis_quirk = false;\r\nstruct usb_driver *driver = driver_of(intf);\r\nstruct usb_cdc_parsed_header header;\r\nif (sizeof(dev->data) < sizeof(*info))\r\nreturn -EDOM;\r\nif (len == 0 && dev->udev->actconfig->extralen) {\r\nbuf = dev->udev->actconfig->extra;\r\nlen = dev->udev->actconfig->extralen;\r\ndev_dbg(&intf->dev, "CDC descriptors on config\n");\r\n}\r\nif (len == 0) {\r\nstruct usb_host_endpoint *hep;\r\nhep = intf->cur_altsetting->endpoint;\r\nif (hep) {\r\nbuf = hep->extra;\r\nlen = hep->extralen;\r\n}\r\nif (len)\r\ndev_dbg(&intf->dev,\r\n"CDC descriptors on endpoint\n");\r\n}\r\nrndis = (is_rndis(&intf->cur_altsetting->desc) ||\r\nis_activesync(&intf->cur_altsetting->desc) ||\r\nis_wireless_rndis(&intf->cur_altsetting->desc));\r\nmemset(info, 0, sizeof(*info));\r\ninfo->control = intf;\r\ncdc_parse_cdc_header(&header, intf, buf, len);\r\ninfo->u = header.usb_cdc_union_desc;\r\ninfo->header = header.usb_cdc_header_desc;\r\ninfo->ether = header.usb_cdc_ether_desc;\r\nif (!info->u) {\r\nif (rndis)\r\ngoto skip;\r\nelse\r\ngoto bad_desc;\r\n}\r\ninfo->control = usb_ifnum_to_if(dev->udev,\r\ninfo->u->bMasterInterface0);\r\ninfo->data = usb_ifnum_to_if(dev->udev,\r\ninfo->u->bSlaveInterface0);\r\nif (!info->control || !info->data) {\r\ndev_dbg(&intf->dev,\r\n"master #%u/%p slave #%u/%p\n",\r\ninfo->u->bMasterInterface0,\r\ninfo->control,\r\ninfo->u->bSlaveInterface0,\r\ninfo->data);\r\nif (rndis) {\r\nandroid_rndis_quirk = true;\r\ngoto skip;\r\n}\r\ngoto bad_desc;\r\n}\r\nif (info->control != intf) {\r\ndev_dbg(&intf->dev, "bogus CDC Union\n");\r\nif (info->data == intf) {\r\ninfo->data = info->control;\r\ninfo->control = intf;\r\n} else\r\ngoto bad_desc;\r\n}\r\nif (info->control == info->data)\r\ngoto skip;\r\nd = &info->data->cur_altsetting->desc;\r\nif (d->bInterfaceClass != USB_CLASS_CDC_DATA) {\r\ndev_dbg(&intf->dev, "slave class %u\n",\r\nd->bInterfaceClass);\r\ngoto bad_desc;\r\n}\r\nskip:\r\nif ( rndis &&\r\nheader.usb_cdc_acm_descriptor &&\r\nheader.usb_cdc_acm_descriptor->bmCapabilities) {\r\ndev_dbg(&intf->dev,\r\n"ACM capabilities %02x, not really RNDIS?\n",\r\nheader.usb_cdc_acm_descriptor->bmCapabilities);\r\ngoto bad_desc;\r\n}\r\nif (header.usb_cdc_ether_desc) {\r\ndev->hard_mtu = le16_to_cpu(info->ether->wMaxSegmentSize);\r\n}\r\nif (header.usb_cdc_mdlm_desc &&\r\nmemcmp(header.usb_cdc_mdlm_desc->bGUID, mbm_guid, 16)) {\r\ndev_dbg(&intf->dev, "GUID doesn't match\n");\r\ngoto bad_desc;\r\n}\r\nif (header.usb_cdc_mdlm_detail_desc &&\r\nheader.usb_cdc_mdlm_detail_desc->bLength <\r\n(sizeof(struct usb_cdc_mdlm_detail_desc) + 1)) {\r\ndev_dbg(&intf->dev, "Descriptor too short\n");\r\ngoto bad_desc;\r\n}\r\nif (rndis && (!info->u || android_rndis_quirk)) {\r\ninfo->control = usb_ifnum_to_if(dev->udev, 0);\r\ninfo->data = usb_ifnum_to_if(dev->udev, 1);\r\nif (!info->control || !info->data || info->control != intf) {\r\ndev_dbg(&intf->dev,\r\n"rndis: master #0/%p slave #1/%p\n",\r\ninfo->control,\r\ninfo->data);\r\ngoto bad_desc;\r\n}\r\n} else if (!info->header || (!rndis && !info->ether)) {\r\ndev_dbg(&intf->dev, "missing cdc %s%s%sdescriptor\n",\r\ninfo->header ? "" : "header ",\r\ninfo->u ? "" : "union ",\r\ninfo->ether ? "" : "ether ");\r\ngoto bad_desc;\r\n}\r\nif (info->data != info->control) {\r\nstatus = usb_driver_claim_interface(driver, info->data, dev);\r\nif (status < 0)\r\nreturn status;\r\n}\r\nstatus = usbnet_get_endpoints(dev, info->data);\r\nif (status < 0) {\r\nusb_set_intfdata(info->data, NULL);\r\nif (info->data != info->control)\r\nusb_driver_release_interface(driver, info->data);\r\nreturn status;\r\n}\r\nif (info->data != info->control)\r\ndev->status = NULL;\r\nif (info->control->cur_altsetting->desc.bNumEndpoints == 1) {\r\nstruct usb_endpoint_descriptor *desc;\r\ndev->status = &info->control->cur_altsetting->endpoint [0];\r\ndesc = &dev->status->desc;\r\nif (!usb_endpoint_is_int_in(desc) ||\r\n(le16_to_cpu(desc->wMaxPacketSize)\r\n< sizeof(struct usb_cdc_notification)) ||\r\n!desc->bInterval) {\r\ndev_dbg(&intf->dev, "bad notification endpoint\n");\r\ndev->status = NULL;\r\n}\r\n}\r\nif (rndis && !dev->status) {\r\ndev_dbg(&intf->dev, "missing RNDIS status endpoint\n");\r\nusb_set_intfdata(info->data, NULL);\r\nusb_driver_release_interface(driver, info->data);\r\nreturn -ENODEV;\r\n}\r\nusbnet_cdc_update_filter(dev);\r\nreturn 0;\r\nbad_desc:\r\ndev_info(&dev->udev->dev, "bad CDC descriptors\n");\r\nreturn -ENODEV;\r\n}\r\nvoid usbnet_cdc_unbind(struct usbnet *dev, struct usb_interface *intf)\r\n{\r\nstruct cdc_state *info = (void *) &dev->data;\r\nstruct usb_driver *driver = driver_of(intf);\r\nif (info->data == info->control)\r\nreturn;\r\nif (intf == info->control && info->data) {\r\nusb_set_intfdata(info->data, NULL);\r\nusb_driver_release_interface(driver, info->data);\r\ninfo->data = NULL;\r\n}\r\nelse if (intf == info->data && info->control) {\r\nusb_set_intfdata(info->control, NULL);\r\nusb_driver_release_interface(driver, info->control);\r\ninfo->control = NULL;\r\n}\r\n}\r\nstatic void dumpspeed(struct usbnet *dev, __le32 *speeds)\r\n{\r\nnetif_info(dev, timer, dev->net,\r\n"link speeds: %u kbps up, %u kbps down\n",\r\n__le32_to_cpu(speeds[0]) / 1000,\r\n__le32_to_cpu(speeds[1]) / 1000);\r\n}\r\nvoid usbnet_cdc_status(struct usbnet *dev, struct urb *urb)\r\n{\r\nstruct usb_cdc_notification *event;\r\nif (urb->actual_length < sizeof(*event))\r\nreturn;\r\nif (test_and_clear_bit(EVENT_STS_SPLIT, &dev->flags)) {\r\ndumpspeed(dev, (__le32 *) urb->transfer_buffer);\r\nreturn;\r\n}\r\nevent = urb->transfer_buffer;\r\nswitch (event->bNotificationType) {\r\ncase USB_CDC_NOTIFY_NETWORK_CONNECTION:\r\nnetif_dbg(dev, timer, dev->net, "CDC: carrier %s\n",\r\nevent->wValue ? "on" : "off");\r\nusbnet_link_change(dev, !!event->wValue, 0);\r\nbreak;\r\ncase USB_CDC_NOTIFY_SPEED_CHANGE:\r\nnetif_dbg(dev, timer, dev->net, "CDC: speed change (len %d)\n",\r\nurb->actual_length);\r\nif (urb->actual_length != (sizeof(*event) + 8))\r\nset_bit(EVENT_STS_SPLIT, &dev->flags);\r\nelse\r\ndumpspeed(dev, (__le32 *) &event[1]);\r\nbreak;\r\ndefault:\r\nnetdev_err(dev->net, "CDC: unexpected notification %02x!\n",\r\nevent->bNotificationType);\r\nbreak;\r\n}\r\n}\r\nint usbnet_cdc_bind(struct usbnet *dev, struct usb_interface *intf)\r\n{\r\nint status;\r\nstruct cdc_state *info = (void *) &dev->data;\r\nBUILD_BUG_ON((sizeof(((struct usbnet *)0)->data)\r\n< sizeof(struct cdc_state)));\r\nstatus = usbnet_generic_cdc_bind(dev, intf);\r\nif (status < 0)\r\nreturn status;\r\nstatus = usbnet_get_ethernet_addr(dev, info->ether->iMACAddress);\r\nif (status < 0) {\r\nusb_set_intfdata(info->data, NULL);\r\nusb_driver_release_interface(driver_of(intf), info->data);\r\nreturn status;\r\n}\r\nreturn 0;\r\n}
