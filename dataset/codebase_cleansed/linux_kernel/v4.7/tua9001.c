static int tua9001_init(struct dvb_frontend *fe)\r\n{\r\nstruct tua9001_dev *dev = fe->tuner_priv;\r\nstruct i2c_client *client = dev->client;\r\nint ret, i;\r\nstatic const struct tua9001_reg_val data[] = {\r\n{0x1e, 0x6512},\r\n{0x25, 0xb888},\r\n{0x39, 0x5460},\r\n{0x3b, 0x00c0},\r\n{0x3a, 0xf000},\r\n{0x08, 0x0000},\r\n{0x32, 0x0030},\r\n{0x41, 0x703a},\r\n{0x40, 0x1c78},\r\n{0x2c, 0x1c00},\r\n{0x36, 0xc013},\r\n{0x37, 0x6f18},\r\n{0x27, 0x0008},\r\n{0x2a, 0x0001},\r\n{0x34, 0x0a40},\r\n};\r\ndev_dbg(&client->dev, "\n");\r\nif (fe->callback) {\r\nret = fe->callback(client->adapter,\r\nDVB_FRONTEND_COMPONENT_TUNER,\r\nTUA9001_CMD_RESETN, 0);\r\nif (ret)\r\ngoto err;\r\n}\r\nfor (i = 0; i < ARRAY_SIZE(data); i++) {\r\nret = regmap_write(dev->regmap, data[i].reg, data[i].val);\r\nif (ret)\r\ngoto err;\r\n}\r\nreturn 0;\r\nerr:\r\ndev_dbg(&client->dev, "failed=%d\n", ret);\r\nreturn ret;\r\n}\r\nstatic int tua9001_sleep(struct dvb_frontend *fe)\r\n{\r\nstruct tua9001_dev *dev = fe->tuner_priv;\r\nstruct i2c_client *client = dev->client;\r\nint ret;\r\ndev_dbg(&client->dev, "\n");\r\nif (fe->callback) {\r\nret = fe->callback(client->adapter,\r\nDVB_FRONTEND_COMPONENT_TUNER,\r\nTUA9001_CMD_RESETN, 1);\r\nif (ret)\r\ngoto err;\r\n}\r\nreturn 0;\r\nerr:\r\ndev_dbg(&client->dev, "failed=%d\n", ret);\r\nreturn ret;\r\n}\r\nstatic int tua9001_set_params(struct dvb_frontend *fe)\r\n{\r\nstruct tua9001_dev *dev = fe->tuner_priv;\r\nstruct i2c_client *client = dev->client;\r\nstruct dtv_frontend_properties *c = &fe->dtv_property_cache;\r\nint ret, i;\r\nu16 val;\r\nstruct tua9001_reg_val data[2];\r\ndev_dbg(&client->dev,\r\n"delivery_system=%u frequency=%u bandwidth_hz=%u\n",\r\nc->delivery_system, c->frequency, c->bandwidth_hz);\r\nswitch (c->delivery_system) {\r\ncase SYS_DVBT:\r\nswitch (c->bandwidth_hz) {\r\ncase 8000000:\r\nval = 0x0000;\r\nbreak;\r\ncase 7000000:\r\nval = 0x1000;\r\nbreak;\r\ncase 6000000:\r\nval = 0x2000;\r\nbreak;\r\ncase 5000000:\r\nval = 0x3000;\r\nbreak;\r\ndefault:\r\nret = -EINVAL;\r\ngoto err;\r\n}\r\nbreak;\r\ndefault:\r\nret = -EINVAL;\r\ngoto err;\r\n}\r\ndata[0].reg = 0x04;\r\ndata[0].val = val;\r\ndata[1].reg = 0x1f;\r\ndata[1].val = div_u64((u64) (c->frequency - 150000000) * 48, 1000000);\r\nif (fe->callback) {\r\nret = fe->callback(client->adapter,\r\nDVB_FRONTEND_COMPONENT_TUNER,\r\nTUA9001_CMD_RXEN, 0);\r\nif (ret)\r\ngoto err;\r\n}\r\nfor (i = 0; i < ARRAY_SIZE(data); i++) {\r\nret = regmap_write(dev->regmap, data[i].reg, data[i].val);\r\nif (ret)\r\ngoto err;\r\n}\r\nif (fe->callback) {\r\nret = fe->callback(client->adapter,\r\nDVB_FRONTEND_COMPONENT_TUNER,\r\nTUA9001_CMD_RXEN, 1);\r\nif (ret)\r\ngoto err;\r\n}\r\nreturn 0;\r\nerr:\r\ndev_dbg(&client->dev, "failed=%d\n", ret);\r\nreturn ret;\r\n}\r\nstatic int tua9001_get_if_frequency(struct dvb_frontend *fe, u32 *frequency)\r\n{\r\nstruct tua9001_dev *dev = fe->tuner_priv;\r\nstruct i2c_client *client = dev->client;\r\ndev_dbg(&client->dev, "\n");\r\n*frequency = 0;\r\nreturn 0;\r\n}\r\nstatic int tua9001_probe(struct i2c_client *client,\r\nconst struct i2c_device_id *id)\r\n{\r\nstruct tua9001_dev *dev;\r\nstruct tua9001_platform_data *pdata = client->dev.platform_data;\r\nstruct dvb_frontend *fe = pdata->dvb_frontend;\r\nint ret;\r\nstatic const struct regmap_config regmap_config = {\r\n.reg_bits = 8,\r\n.val_bits = 16,\r\n};\r\ndev = kzalloc(sizeof(*dev), GFP_KERNEL);\r\nif (!dev) {\r\nret = -ENOMEM;\r\ngoto err;\r\n}\r\ndev->fe = pdata->dvb_frontend;\r\ndev->client = client;\r\ndev->regmap = devm_regmap_init_i2c(client, &regmap_config);\r\nif (IS_ERR(dev->regmap)) {\r\nret = PTR_ERR(dev->regmap);\r\ngoto err_kfree;\r\n}\r\nif (fe->callback) {\r\nret = fe->callback(client->adapter,\r\nDVB_FRONTEND_COMPONENT_TUNER,\r\nTUA9001_CMD_CEN, 1);\r\nif (ret)\r\ngoto err_kfree;\r\nret = fe->callback(client->adapter,\r\nDVB_FRONTEND_COMPONENT_TUNER,\r\nTUA9001_CMD_RXEN, 0);\r\nif (ret)\r\ngoto err_kfree;\r\nret = fe->callback(client->adapter,\r\nDVB_FRONTEND_COMPONENT_TUNER,\r\nTUA9001_CMD_RESETN, 1);\r\nif (ret)\r\ngoto err_kfree;\r\n}\r\nfe->tuner_priv = dev;\r\nmemcpy(&fe->ops.tuner_ops, &tua9001_tuner_ops,\r\nsizeof(struct dvb_tuner_ops));\r\ni2c_set_clientdata(client, dev);\r\ndev_info(&client->dev, "Infineon TUA9001 successfully attached\n");\r\nreturn 0;\r\nerr_kfree:\r\nkfree(dev);\r\nerr:\r\ndev_dbg(&client->dev, "failed=%d\n", ret);\r\nreturn ret;\r\n}\r\nstatic int tua9001_remove(struct i2c_client *client)\r\n{\r\nstruct tua9001_dev *dev = i2c_get_clientdata(client);\r\nstruct dvb_frontend *fe = dev->fe;\r\nint ret;\r\ndev_dbg(&client->dev, "\n");\r\nif (fe->callback) {\r\nret = fe->callback(client->adapter,\r\nDVB_FRONTEND_COMPONENT_TUNER,\r\nTUA9001_CMD_CEN, 0);\r\nif (ret)\r\ngoto err_kfree;\r\n}\r\nkfree(dev);\r\nreturn 0;\r\nerr_kfree:\r\nkfree(dev);\r\ndev_dbg(&client->dev, "failed=%d\n", ret);\r\nreturn ret;\r\n}
