static int stfsm_mx25_en_32bit_addr_seq(struct stfsm_seq *seq)\r\n{\r\nseq->seq_opc[0] = (SEQ_OPC_PADS_1 |\r\nSEQ_OPC_CYCLES(8) |\r\nSEQ_OPC_OPCODE(SPINOR_OP_EN4B) |\r\nSEQ_OPC_CSDEASSERT);\r\nseq->seq[0] = STFSM_INST_CMD1;\r\nseq->seq[1] = STFSM_INST_WAIT;\r\nseq->seq[2] = STFSM_INST_STOP;\r\nseq->seq_cfg = (SEQ_CFG_PADS_1 |\r\nSEQ_CFG_ERASE |\r\nSEQ_CFG_READNOTWRITE |\r\nSEQ_CFG_CSDEASSERT |\r\nSEQ_CFG_STARTSEQ);\r\nreturn 0;\r\n}\r\nstatic int stfsm_n25q_en_32bit_addr_seq(struct stfsm_seq *seq)\r\n{\r\nseq->seq_opc[0] = (SEQ_OPC_PADS_1 | SEQ_OPC_CYCLES(8) |\r\nSEQ_OPC_OPCODE(SPINOR_OP_EN4B));\r\nseq->seq_opc[1] = (SEQ_OPC_PADS_1 | SEQ_OPC_CYCLES(8) |\r\nSEQ_OPC_OPCODE(SPINOR_OP_WREN) |\r\nSEQ_OPC_CSDEASSERT);\r\nseq->seq[0] = STFSM_INST_CMD2;\r\nseq->seq[1] = STFSM_INST_CMD1;\r\nseq->seq[2] = STFSM_INST_WAIT;\r\nseq->seq[3] = STFSM_INST_STOP;\r\nseq->seq_cfg = (SEQ_CFG_PADS_1 |\r\nSEQ_CFG_ERASE |\r\nSEQ_CFG_READNOTWRITE |\r\nSEQ_CFG_CSDEASSERT |\r\nSEQ_CFG_STARTSEQ);\r\nreturn 0;\r\n}\r\nstatic inline int stfsm_is_idle(struct stfsm *fsm)\r\n{\r\nreturn readl(fsm->base + SPI_FAST_SEQ_STA) & 0x10;\r\n}\r\nstatic inline uint32_t stfsm_fifo_available(struct stfsm *fsm)\r\n{\r\nreturn (readl(fsm->base + SPI_FAST_SEQ_STA) >> 5) & 0x7f;\r\n}\r\nstatic inline void stfsm_load_seq(struct stfsm *fsm,\r\nconst struct stfsm_seq *seq)\r\n{\r\nvoid __iomem *dst = fsm->base + SPI_FAST_SEQ_TRANSFER_SIZE;\r\nconst uint32_t *src = (const uint32_t *)seq;\r\nint words = sizeof(*seq) / sizeof(*src);\r\nBUG_ON(!stfsm_is_idle(fsm));\r\nwhile (words--) {\r\nwritel(*src, dst);\r\nsrc++;\r\ndst += 4;\r\n}\r\n}\r\nstatic void stfsm_wait_seq(struct stfsm *fsm)\r\n{\r\nunsigned long deadline;\r\nint timeout = 0;\r\ndeadline = jiffies + msecs_to_jiffies(STFSM_MAX_WAIT_SEQ_MS);\r\nwhile (!timeout) {\r\nif (time_after_eq(jiffies, deadline))\r\ntimeout = 1;\r\nif (stfsm_is_idle(fsm))\r\nreturn;\r\ncond_resched();\r\n}\r\ndev_err(fsm->dev, "timeout on sequence completion\n");\r\n}\r\nstatic void stfsm_read_fifo(struct stfsm *fsm, uint32_t *buf, uint32_t size)\r\n{\r\nuint32_t remaining = size >> 2;\r\nuint32_t avail;\r\nuint32_t words;\r\ndev_dbg(fsm->dev, "Reading %d bytes from FIFO\n", size);\r\nBUG_ON((((uintptr_t)buf) & 0x3) || (size & 0x3));\r\nwhile (remaining) {\r\nfor (;;) {\r\navail = stfsm_fifo_available(fsm);\r\nif (avail)\r\nbreak;\r\nudelay(1);\r\n}\r\nwords = min(avail, remaining);\r\nremaining -= words;\r\nreadsl(fsm->base + SPI_FAST_SEQ_DATA_REG, buf, words);\r\nbuf += words;\r\n}\r\n}\r\nstatic void stfsm_clear_fifo(struct stfsm *fsm)\r\n{\r\nconst struct stfsm_seq *seq = &stfsm_seq_load_fifo_byte;\r\nuint32_t words, i;\r\nwords = stfsm_fifo_available(fsm);\r\nif (words) {\r\nfor (i = 0; i < words; i++)\r\nreadl(fsm->base + SPI_FAST_SEQ_DATA_REG);\r\ndev_dbg(fsm->dev, "cleared %d words from FIFO\n", words);\r\n}\r\nfor (i = 0, words = 0; i < 4 && !words; i++) {\r\nstfsm_load_seq(fsm, seq);\r\nstfsm_wait_seq(fsm);\r\nwords = stfsm_fifo_available(fsm);\r\n}\r\nif (words != 1) {\r\ndev_err(fsm->dev, "failed to clear bytes from the data FIFO\n");\r\nreturn;\r\n}\r\nreadl(fsm->base + SPI_FAST_SEQ_DATA_REG);\r\ndev_dbg(fsm->dev, "cleared %d byte(s) from the data FIFO\n", 4 - i);\r\n}\r\nstatic int stfsm_write_fifo(struct stfsm *fsm, const uint32_t *buf,\r\nuint32_t size)\r\n{\r\nuint32_t words = size >> 2;\r\ndev_dbg(fsm->dev, "writing %d bytes to FIFO\n", size);\r\nBUG_ON((((uintptr_t)buf) & 0x3) || (size & 0x3));\r\nwritesl(fsm->base + SPI_FAST_SEQ_DATA_REG, buf, words);\r\nreturn size;\r\n}\r\nstatic int stfsm_enter_32bit_addr(struct stfsm *fsm, int enter)\r\n{\r\nstruct stfsm_seq *seq = &fsm->stfsm_seq_en_32bit_addr;\r\nuint32_t cmd = enter ? SPINOR_OP_EN4B : SPINOR_OP_EX4B;\r\nseq->seq_opc[0] = (SEQ_OPC_PADS_1 |\r\nSEQ_OPC_CYCLES(8) |\r\nSEQ_OPC_OPCODE(cmd) |\r\nSEQ_OPC_CSDEASSERT);\r\nstfsm_load_seq(fsm, seq);\r\nstfsm_wait_seq(fsm);\r\nreturn 0;\r\n}\r\nstatic uint8_t stfsm_wait_busy(struct stfsm *fsm)\r\n{\r\nstruct stfsm_seq *seq = &stfsm_seq_read_status_fifo;\r\nunsigned long deadline;\r\nuint32_t status;\r\nint timeout = 0;\r\nseq->seq_opc[0] = (SEQ_OPC_PADS_1 |\r\nSEQ_OPC_CYCLES(8) |\r\nSEQ_OPC_OPCODE(SPINOR_OP_RDSR));\r\nstfsm_load_seq(fsm, seq);\r\ndeadline = jiffies + FLASH_MAX_BUSY_WAIT;\r\nwhile (!timeout) {\r\nif (time_after_eq(jiffies, deadline))\r\ntimeout = 1;\r\nstfsm_wait_seq(fsm);\r\nstfsm_read_fifo(fsm, &status, 4);\r\nif ((status & FLASH_STATUS_BUSY) == 0)\r\nreturn 0;\r\nif ((fsm->configuration & CFG_S25FL_CHECK_ERROR_FLAGS) &&\r\n((status & S25FL_STATUS_P_ERR) ||\r\n(status & S25FL_STATUS_E_ERR)))\r\nreturn (uint8_t)(status & 0xff);\r\nif (!timeout)\r\nwritel(seq->seq_cfg, fsm->base + SPI_FAST_SEQ_CFG);\r\ncond_resched();\r\n}\r\ndev_err(fsm->dev, "timeout on wait_busy\n");\r\nreturn FLASH_STATUS_TIMEOUT;\r\n}\r\nstatic int stfsm_read_status(struct stfsm *fsm, uint8_t cmd,\r\nuint8_t *data, int bytes)\r\n{\r\nstruct stfsm_seq *seq = &stfsm_seq_read_status_fifo;\r\nuint32_t tmp;\r\nuint8_t *t = (uint8_t *)&tmp;\r\nint i;\r\ndev_dbg(fsm->dev, "read 'status' register [0x%02x], %d byte(s)\n",\r\ncmd, bytes);\r\nBUG_ON(bytes != 1 && bytes != 2);\r\nseq->seq_opc[0] = (SEQ_OPC_PADS_1 | SEQ_OPC_CYCLES(8) |\r\nSEQ_OPC_OPCODE(cmd)),\r\nstfsm_load_seq(fsm, seq);\r\nstfsm_read_fifo(fsm, &tmp, 4);\r\nfor (i = 0; i < bytes; i++)\r\ndata[i] = t[i];\r\nstfsm_wait_seq(fsm);\r\nreturn 0;\r\n}\r\nstatic int stfsm_write_status(struct stfsm *fsm, uint8_t cmd,\r\nuint16_t data, int bytes, int wait_busy)\r\n{\r\nstruct stfsm_seq *seq = &stfsm_seq_write_status;\r\ndev_dbg(fsm->dev,\r\n"write 'status' register [0x%02x], %d byte(s), 0x%04x\n"\r\n" %s wait-busy\n", cmd, bytes, data, wait_busy ? "with" : "no");\r\nBUG_ON(bytes != 1 && bytes != 2);\r\nseq->seq_opc[1] = (SEQ_OPC_PADS_1 | SEQ_OPC_CYCLES(8) |\r\nSEQ_OPC_OPCODE(cmd));\r\nseq->status = (uint32_t)data | STA_PADS_1 | STA_CSDEASSERT;\r\nseq->seq[2] = (bytes == 1) ? STFSM_INST_STA_WR1 : STFSM_INST_STA_WR1_2;\r\nstfsm_load_seq(fsm, seq);\r\nstfsm_wait_seq(fsm);\r\nif (wait_busy)\r\nstfsm_wait_busy(fsm);\r\nreturn 0;\r\n}\r\nstatic bool stfsm_can_handle_soc_reset(struct stfsm *fsm)\r\n{\r\nif (fsm->reset_signal && fsm->info->flags & FLASH_FLAG_RESET)\r\nreturn true;\r\nif (fsm->reset_por)\r\nreturn true;\r\nreturn false;\r\n}\r\nstatic void stfsm_prepare_erasesec_seq(struct stfsm *fsm,\r\nstruct stfsm_seq *seq)\r\n{\r\nint addr1_cycles = fsm->info->flags & FLASH_FLAG_32BIT_ADDR ? 16 : 8;\r\nseq->addr_cfg = (ADR_CFG_CYCLES_ADD1(addr1_cycles) |\r\nADR_CFG_PADS_1_ADD1 |\r\nADR_CFG_CYCLES_ADD2(16) |\r\nADR_CFG_PADS_1_ADD2 |\r\nADR_CFG_CSDEASSERT_ADD2);\r\n}\r\nstatic struct seq_rw_config *\r\nstfsm_search_seq_rw_configs(struct stfsm *fsm,\r\nstruct seq_rw_config cfgs[])\r\n{\r\nstruct seq_rw_config *config;\r\nint flags = fsm->info->flags;\r\nfor (config = cfgs; config->cmd != 0; config++)\r\nif ((config->flags & flags) == config->flags)\r\nreturn config;\r\nreturn NULL;\r\n}\r\nstatic void stfsm_prepare_rw_seq(struct stfsm *fsm,\r\nstruct stfsm_seq *seq,\r\nstruct seq_rw_config *cfg)\r\n{\r\nint addr1_cycles, addr2_cycles;\r\nint i = 0;\r\nmemset(seq, 0, sizeof(*seq));\r\nseq->seq_opc[i++] = (SEQ_OPC_PADS_1 |\r\nSEQ_OPC_CYCLES(8) |\r\nSEQ_OPC_OPCODE(cfg->cmd));\r\nif (cfg->write)\r\nseq->seq_opc[i++] = (SEQ_OPC_PADS_1 |\r\nSEQ_OPC_CYCLES(8) |\r\nSEQ_OPC_OPCODE(SPINOR_OP_WREN) |\r\nSEQ_OPC_CSDEASSERT);\r\naddr1_cycles = (fsm->info->flags & FLASH_FLAG_32BIT_ADDR) ? 16 : 8;\r\naddr1_cycles /= cfg->addr_pads;\r\naddr2_cycles = 16 / cfg->addr_pads;\r\nseq->addr_cfg = ((addr1_cycles & 0x3f) << 0 |\r\n(cfg->addr_pads - 1) << 6 |\r\n(addr2_cycles & 0x3f) << 16 |\r\n((cfg->addr_pads - 1) << 22));\r\nseq->seq_cfg = ((cfg->data_pads - 1) << 16 |\r\nSEQ_CFG_STARTSEQ |\r\nSEQ_CFG_CSDEASSERT);\r\nif (!cfg->write)\r\nseq->seq_cfg |= SEQ_CFG_READNOTWRITE;\r\nseq->mode = ((cfg->mode_data & 0xff) << 0 |\r\n(cfg->mode_cycles & 0x3f) << 16 |\r\n(cfg->addr_pads - 1) << 22);\r\nseq->dummy = ((cfg->dummy_cycles & 0x3f) << 16 |\r\n(cfg->addr_pads - 1) << 22);\r\ni = 0;\r\nif (cfg->write)\r\nseq->seq[i++] = STFSM_INST_CMD2;\r\nseq->seq[i++] = STFSM_INST_CMD1;\r\nseq->seq[i++] = STFSM_INST_ADD1;\r\nseq->seq[i++] = STFSM_INST_ADD2;\r\nif (cfg->mode_cycles)\r\nseq->seq[i++] = STFSM_INST_MODE;\r\nif (cfg->dummy_cycles)\r\nseq->seq[i++] = STFSM_INST_DUMMY;\r\nseq->seq[i++] =\r\ncfg->write ? STFSM_INST_DATA_WRITE : STFSM_INST_DATA_READ;\r\nseq->seq[i++] = STFSM_INST_STOP;\r\n}\r\nstatic int stfsm_search_prepare_rw_seq(struct stfsm *fsm,\r\nstruct stfsm_seq *seq,\r\nstruct seq_rw_config *cfgs)\r\n{\r\nstruct seq_rw_config *config;\r\nconfig = stfsm_search_seq_rw_configs(fsm, cfgs);\r\nif (!config) {\r\ndev_err(fsm->dev, "failed to find suitable config\n");\r\nreturn -EINVAL;\r\n}\r\nstfsm_prepare_rw_seq(fsm, seq, config);\r\nreturn 0;\r\n}\r\nstatic int stfsm_prepare_rwe_seqs_default(struct stfsm *fsm)\r\n{\r\nuint32_t flags = fsm->info->flags;\r\nint ret;\r\nret = stfsm_search_prepare_rw_seq(fsm, &fsm->stfsm_seq_read,\r\ndefault_read_configs);\r\nif (ret) {\r\ndev_err(fsm->dev,\r\n"failed to prep READ sequence with flags [0x%08x]\n",\r\nflags);\r\nreturn ret;\r\n}\r\nret = stfsm_search_prepare_rw_seq(fsm, &fsm->stfsm_seq_write,\r\ndefault_write_configs);\r\nif (ret) {\r\ndev_err(fsm->dev,\r\n"failed to prep WRITE sequence with flags [0x%08x]\n",\r\nflags);\r\nreturn ret;\r\n}\r\nstfsm_prepare_erasesec_seq(fsm, &stfsm_seq_erase_sector);\r\nreturn 0;\r\n}\r\nstatic int stfsm_mx25_config(struct stfsm *fsm)\r\n{\r\nuint32_t flags = fsm->info->flags;\r\nuint32_t data_pads;\r\nuint8_t sta;\r\nint ret;\r\nbool soc_reset;\r\nret = stfsm_prepare_rwe_seqs_default(fsm);\r\nif (ret)\r\nreturn ret;\r\nif (flags & FLASH_FLAG_32BIT_ADDR) {\r\nstfsm_mx25_en_32bit_addr_seq(&fsm->stfsm_seq_en_32bit_addr);\r\nsoc_reset = stfsm_can_handle_soc_reset(fsm);\r\nif (soc_reset || !fsm->booted_from_spi)\r\nstfsm_enter_32bit_addr(fsm, 1);\r\nelse\r\nfsm->configuration = (CFG_READ_TOGGLE_32BIT_ADDR |\r\nCFG_WRITE_TOGGLE_32BIT_ADDR |\r\nCFG_ERASESEC_TOGGLE_32BIT_ADDR);\r\n}\r\nstfsm_read_status(fsm, SPINOR_OP_RDSR, &sta, 1);\r\ndata_pads = ((fsm->stfsm_seq_read.seq_cfg >> 16) & 0x3) + 1;\r\nif (data_pads == 4) {\r\nif (!(sta & MX25_STATUS_QE)) {\r\nsta |= MX25_STATUS_QE;\r\nstfsm_write_status(fsm, SPINOR_OP_WRSR, sta, 1, 1);\r\n}\r\n} else {\r\nif (sta & MX25_STATUS_QE) {\r\nsta &= ~MX25_STATUS_QE;\r\nstfsm_write_status(fsm, SPINOR_OP_WRSR, sta, 1, 1);\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int stfsm_n25q_config(struct stfsm *fsm)\r\n{\r\nuint32_t flags = fsm->info->flags;\r\nuint8_t vcr;\r\nint ret = 0;\r\nbool soc_reset;\r\nif (flags & FLASH_FLAG_32BIT_ADDR)\r\nret = stfsm_search_prepare_rw_seq(fsm, &fsm->stfsm_seq_read,\r\nn25q_read4_configs);\r\nelse\r\nret = stfsm_search_prepare_rw_seq(fsm, &fsm->stfsm_seq_read,\r\nn25q_read3_configs);\r\nif (ret) {\r\ndev_err(fsm->dev,\r\n"failed to prepare READ sequence with flags [0x%08x]\n",\r\nflags);\r\nreturn ret;\r\n}\r\nret = stfsm_search_prepare_rw_seq(fsm, &fsm->stfsm_seq_write,\r\ndefault_write_configs);\r\nif (ret) {\r\ndev_err(fsm->dev,\r\n"preparing WRITE sequence using flags [0x%08x] failed\n",\r\nflags);\r\nreturn ret;\r\n}\r\nstfsm_prepare_erasesec_seq(fsm, &stfsm_seq_erase_sector);\r\nif (flags & FLASH_FLAG_32BIT_ADDR) {\r\nstfsm_n25q_en_32bit_addr_seq(&fsm->stfsm_seq_en_32bit_addr);\r\nsoc_reset = stfsm_can_handle_soc_reset(fsm);\r\nif (soc_reset || !fsm->booted_from_spi) {\r\nstfsm_enter_32bit_addr(fsm, 1);\r\n} else {\r\nfsm->configuration = (CFG_WRITE_TOGGLE_32BIT_ADDR |\r\nCFG_ERASESEC_TOGGLE_32BIT_ADDR);\r\n}\r\n}\r\nvcr = (N25Q_VCR_DUMMY_CYCLES(8) | N25Q_VCR_XIP_DISABLED |\r\nN25Q_VCR_WRAP_CONT);\r\nstfsm_write_status(fsm, N25Q_CMD_WRVCR, vcr, 1, 0);\r\nreturn 0;\r\n}\r\nstatic void stfsm_s25fl_prepare_erasesec_seq_32(struct stfsm_seq *seq)\r\n{\r\nseq->seq_opc[1] = (SEQ_OPC_PADS_1 |\r\nSEQ_OPC_CYCLES(8) |\r\nSEQ_OPC_OPCODE(S25FL_CMD_SE4));\r\nseq->addr_cfg = (ADR_CFG_CYCLES_ADD1(16) |\r\nADR_CFG_PADS_1_ADD1 |\r\nADR_CFG_CYCLES_ADD2(16) |\r\nADR_CFG_PADS_1_ADD2 |\r\nADR_CFG_CSDEASSERT_ADD2);\r\n}\r\nstatic void stfsm_s25fl_read_dyb(struct stfsm *fsm, uint32_t offs, uint8_t *dby)\r\n{\r\nuint32_t tmp;\r\nstruct stfsm_seq seq = {\r\n.data_size = TRANSFER_SIZE(4),\r\n.seq_opc[0] = (SEQ_OPC_PADS_1 |\r\nSEQ_OPC_CYCLES(8) |\r\nSEQ_OPC_OPCODE(S25FL_CMD_DYBRD)),\r\n.addr_cfg = (ADR_CFG_CYCLES_ADD1(16) |\r\nADR_CFG_PADS_1_ADD1 |\r\nADR_CFG_CYCLES_ADD2(16) |\r\nADR_CFG_PADS_1_ADD2),\r\n.addr1 = (offs >> 16) & 0xffff,\r\n.addr2 = offs & 0xffff,\r\n.seq = {\r\nSTFSM_INST_CMD1,\r\nSTFSM_INST_ADD1,\r\nSTFSM_INST_ADD2,\r\nSTFSM_INST_DATA_READ,\r\nSTFSM_INST_STOP,\r\n},\r\n.seq_cfg = (SEQ_CFG_PADS_1 |\r\nSEQ_CFG_READNOTWRITE |\r\nSEQ_CFG_CSDEASSERT |\r\nSEQ_CFG_STARTSEQ),\r\n};\r\nstfsm_load_seq(fsm, &seq);\r\nstfsm_read_fifo(fsm, &tmp, 4);\r\n*dby = (uint8_t)(tmp >> 24);\r\nstfsm_wait_seq(fsm);\r\n}\r\nstatic void stfsm_s25fl_write_dyb(struct stfsm *fsm, uint32_t offs, uint8_t dby)\r\n{\r\nstruct stfsm_seq seq = {\r\n.seq_opc[0] = (SEQ_OPC_PADS_1 | SEQ_OPC_CYCLES(8) |\r\nSEQ_OPC_OPCODE(SPINOR_OP_WREN) |\r\nSEQ_OPC_CSDEASSERT),\r\n.seq_opc[1] = (SEQ_OPC_PADS_1 | SEQ_OPC_CYCLES(8) |\r\nSEQ_OPC_OPCODE(S25FL_CMD_DYBWR)),\r\n.addr_cfg = (ADR_CFG_CYCLES_ADD1(16) |\r\nADR_CFG_PADS_1_ADD1 |\r\nADR_CFG_CYCLES_ADD2(16) |\r\nADR_CFG_PADS_1_ADD2),\r\n.status = (uint32_t)dby | STA_PADS_1 | STA_CSDEASSERT,\r\n.addr1 = (offs >> 16) & 0xffff,\r\n.addr2 = offs & 0xffff,\r\n.seq = {\r\nSTFSM_INST_CMD1,\r\nSTFSM_INST_CMD2,\r\nSTFSM_INST_ADD1,\r\nSTFSM_INST_ADD2,\r\nSTFSM_INST_STA_WR1,\r\nSTFSM_INST_STOP,\r\n},\r\n.seq_cfg = (SEQ_CFG_PADS_1 |\r\nSEQ_CFG_READNOTWRITE |\r\nSEQ_CFG_CSDEASSERT |\r\nSEQ_CFG_STARTSEQ),\r\n};\r\nstfsm_load_seq(fsm, &seq);\r\nstfsm_wait_seq(fsm);\r\nstfsm_wait_busy(fsm);\r\n}\r\nstatic int stfsm_s25fl_clear_status_reg(struct stfsm *fsm)\r\n{\r\nstruct stfsm_seq seq = {\r\n.seq_opc[0] = (SEQ_OPC_PADS_1 |\r\nSEQ_OPC_CYCLES(8) |\r\nSEQ_OPC_OPCODE(S25FL_CMD_CLSR) |\r\nSEQ_OPC_CSDEASSERT),\r\n.seq_opc[1] = (SEQ_OPC_PADS_1 |\r\nSEQ_OPC_CYCLES(8) |\r\nSEQ_OPC_OPCODE(SPINOR_OP_WRDI) |\r\nSEQ_OPC_CSDEASSERT),\r\n.seq = {\r\nSTFSM_INST_CMD1,\r\nSTFSM_INST_CMD2,\r\nSTFSM_INST_WAIT,\r\nSTFSM_INST_STOP,\r\n},\r\n.seq_cfg = (SEQ_CFG_PADS_1 |\r\nSEQ_CFG_ERASE |\r\nSEQ_CFG_READNOTWRITE |\r\nSEQ_CFG_CSDEASSERT |\r\nSEQ_CFG_STARTSEQ),\r\n};\r\nstfsm_load_seq(fsm, &seq);\r\nstfsm_wait_seq(fsm);\r\nreturn 0;\r\n}\r\nstatic int stfsm_s25fl_config(struct stfsm *fsm)\r\n{\r\nstruct flash_info *info = fsm->info;\r\nuint32_t flags = info->flags;\r\nuint32_t data_pads;\r\nuint32_t offs;\r\nuint16_t sta_wr;\r\nuint8_t sr1, cr1, dyb;\r\nint update_sr = 0;\r\nint ret;\r\nif (flags & FLASH_FLAG_32BIT_ADDR) {\r\nret = stfsm_search_prepare_rw_seq(fsm, &fsm->stfsm_seq_read,\r\nstfsm_s25fl_read4_configs);\r\nif (ret)\r\nreturn ret;\r\nret = stfsm_search_prepare_rw_seq(fsm, &fsm->stfsm_seq_write,\r\nstfsm_s25fl_write4_configs);\r\nif (ret)\r\nreturn ret;\r\nstfsm_s25fl_prepare_erasesec_seq_32(&stfsm_seq_erase_sector);\r\n} else {\r\nret = stfsm_prepare_rwe_seqs_default(fsm);\r\nif (ret)\r\nreturn ret;\r\n}\r\nif (flags & FLASH_FLAG_DYB_LOCKING) {\r\noffs = 0;\r\nfor (offs = 0; offs < info->sector_size * info->n_sectors;) {\r\nstfsm_s25fl_read_dyb(fsm, offs, &dyb);\r\nif (dyb == 0x00)\r\nstfsm_s25fl_write_dyb(fsm, offs, 0xff);\r\nif ((offs < info->sector_size * 2) ||\r\n(offs >= (info->sector_size - info->n_sectors * 4)))\r\noffs += 0x1000;\r\nelse\r\noffs += 0x10000;\r\n}\r\n}\r\nstfsm_read_status(fsm, SPINOR_OP_RDSR2, &cr1, 1);\r\ndata_pads = ((fsm->stfsm_seq_read.seq_cfg >> 16) & 0x3) + 1;\r\nif (data_pads == 4) {\r\nif (!(cr1 & STFSM_S25FL_CONFIG_QE)) {\r\ncr1 |= STFSM_S25FL_CONFIG_QE;\r\nupdate_sr = 1;\r\n}\r\n} else {\r\nif (cr1 & STFSM_S25FL_CONFIG_QE) {\r\ncr1 &= ~STFSM_S25FL_CONFIG_QE;\r\nupdate_sr = 1;\r\n}\r\n}\r\nif (update_sr) {\r\nstfsm_read_status(fsm, SPINOR_OP_RDSR, &sr1, 1);\r\nsta_wr = ((uint16_t)cr1 << 8) | sr1;\r\nstfsm_write_status(fsm, SPINOR_OP_WRSR, sta_wr, 2, 1);\r\n}\r\nfsm->configuration |= CFG_S25FL_CHECK_ERROR_FLAGS;\r\nreturn 0;\r\n}\r\nstatic int stfsm_w25q_config(struct stfsm *fsm)\r\n{\r\nuint32_t data_pads;\r\nuint8_t sr1, sr2;\r\nuint16_t sr_wr;\r\nint update_sr = 0;\r\nint ret;\r\nret = stfsm_prepare_rwe_seqs_default(fsm);\r\nif (ret)\r\nreturn ret;\r\nstfsm_read_status(fsm, SPINOR_OP_RDSR2, &sr2, 1);\r\ndata_pads = ((fsm->stfsm_seq_read.seq_cfg >> 16) & 0x3) + 1;\r\nif (data_pads == 4) {\r\nif (!(sr2 & W25Q_STATUS_QE)) {\r\nsr2 |= W25Q_STATUS_QE;\r\nupdate_sr = 1;\r\n}\r\n} else {\r\nif (sr2 & W25Q_STATUS_QE) {\r\nsr2 &= ~W25Q_STATUS_QE;\r\nupdate_sr = 1;\r\n}\r\n}\r\nif (update_sr) {\r\nstfsm_read_status(fsm, SPINOR_OP_RDSR, &sr1, 1);\r\nsr_wr = ((uint16_t)sr2 << 8) | sr1;\r\nstfsm_write_status(fsm, SPINOR_OP_WRSR, sr_wr, 2, 1);\r\n}\r\nreturn 0;\r\n}\r\nstatic int stfsm_read(struct stfsm *fsm, uint8_t *buf, uint32_t size,\r\nuint32_t offset)\r\n{\r\nstruct stfsm_seq *seq = &fsm->stfsm_seq_read;\r\nuint32_t data_pads;\r\nuint32_t read_mask;\r\nuint32_t size_ub;\r\nuint32_t size_lb;\r\nuint32_t size_mop;\r\nuint32_t tmp[4];\r\nuint32_t page_buf[FLASH_PAGESIZE_32];\r\nuint8_t *p;\r\ndev_dbg(fsm->dev, "reading %d bytes from 0x%08x\n", size, offset);\r\nif (fsm->configuration & CFG_READ_TOGGLE_32BIT_ADDR)\r\nstfsm_enter_32bit_addr(fsm, 1);\r\ndata_pads = ((seq->seq_cfg >> 16) & 0x3) + 1;\r\nread_mask = (data_pads << 2) - 1;\r\np = ((uintptr_t)buf & 0x3) ? (uint8_t *)page_buf : buf;\r\nsize_ub = (size + read_mask) & ~read_mask;\r\nsize_lb = size & ~read_mask;\r\nsize_mop = size & read_mask;\r\nseq->data_size = TRANSFER_SIZE(size_ub);\r\nseq->addr1 = (offset >> 16) & 0xffff;\r\nseq->addr2 = offset & 0xffff;\r\nstfsm_load_seq(fsm, seq);\r\nif (size_lb)\r\nstfsm_read_fifo(fsm, (uint32_t *)p, size_lb);\r\nif (size_mop) {\r\nstfsm_read_fifo(fsm, tmp, read_mask + 1);\r\nmemcpy(p + size_lb, &tmp, size_mop);\r\n}\r\nif ((uintptr_t)buf & 0x3)\r\nmemcpy(buf, page_buf, size);\r\nstfsm_wait_seq(fsm);\r\nstfsm_clear_fifo(fsm);\r\nif (fsm->configuration & CFG_READ_TOGGLE_32BIT_ADDR)\r\nstfsm_enter_32bit_addr(fsm, 0);\r\nreturn 0;\r\n}\r\nstatic int stfsm_write(struct stfsm *fsm, const uint8_t *buf,\r\nuint32_t size, uint32_t offset)\r\n{\r\nstruct stfsm_seq *seq = &fsm->stfsm_seq_write;\r\nuint32_t data_pads;\r\nuint32_t write_mask;\r\nuint32_t size_ub;\r\nuint32_t size_lb;\r\nuint32_t size_mop;\r\nuint32_t tmp[4];\r\nuint32_t i;\r\nuint32_t page_buf[FLASH_PAGESIZE_32];\r\nuint8_t *t = (uint8_t *)&tmp;\r\nconst uint8_t *p;\r\nint ret;\r\ndev_dbg(fsm->dev, "writing %d bytes to 0x%08x\n", size, offset);\r\nif (fsm->configuration & CFG_WRITE_TOGGLE_32BIT_ADDR)\r\nstfsm_enter_32bit_addr(fsm, 1);\r\ndata_pads = ((seq->seq_cfg >> 16) & 0x3) + 1;\r\nwrite_mask = (data_pads << 2) - 1;\r\nif ((uintptr_t)buf & 0x3) {\r\nmemcpy(page_buf, buf, size);\r\np = (uint8_t *)page_buf;\r\n} else {\r\np = buf;\r\n}\r\nsize_ub = (size + write_mask) & ~write_mask;\r\nsize_lb = size & ~write_mask;\r\nsize_mop = size & write_mask;\r\nseq->data_size = TRANSFER_SIZE(size_ub);\r\nseq->addr1 = (offset >> 16) & 0xffff;\r\nseq->addr2 = offset & 0xffff;\r\nwritel(0x00040000, fsm->base + SPI_FAST_SEQ_CFG);\r\nif (fsm->fifo_dir_delay == 0)\r\nreadl(fsm->base + SPI_FAST_SEQ_CFG);\r\nelse\r\nudelay(fsm->fifo_dir_delay);\r\nif (size_lb) {\r\nstfsm_write_fifo(fsm, (uint32_t *)p, size_lb);\r\np += size_lb;\r\n}\r\nif (size_mop) {\r\nmemset(t, 0xff, write_mask + 1);\r\nfor (i = 0; i < size_mop; i++)\r\nt[i] = *p++;\r\nstfsm_write_fifo(fsm, tmp, write_mask + 1);\r\n}\r\nstfsm_load_seq(fsm, seq);\r\nstfsm_wait_seq(fsm);\r\nret = stfsm_wait_busy(fsm);\r\nif (ret && fsm->configuration & CFG_S25FL_CHECK_ERROR_FLAGS)\r\nstfsm_s25fl_clear_status_reg(fsm);\r\nif (fsm->configuration & CFG_WRITE_TOGGLE_32BIT_ADDR)\r\nstfsm_enter_32bit_addr(fsm, 0);\r\nreturn 0;\r\n}\r\nstatic int stfsm_mtd_read(struct mtd_info *mtd, loff_t from, size_t len,\r\nsize_t *retlen, u_char *buf)\r\n{\r\nstruct stfsm *fsm = dev_get_drvdata(mtd->dev.parent);\r\nuint32_t bytes;\r\ndev_dbg(fsm->dev, "%s from 0x%08x, len %zd\n",\r\n__func__, (u32)from, len);\r\nmutex_lock(&fsm->lock);\r\nwhile (len > 0) {\r\nbytes = min_t(size_t, len, FLASH_PAGESIZE);\r\nstfsm_read(fsm, buf, bytes, from);\r\nbuf += bytes;\r\nfrom += bytes;\r\nlen -= bytes;\r\n*retlen += bytes;\r\n}\r\nmutex_unlock(&fsm->lock);\r\nreturn 0;\r\n}\r\nstatic int stfsm_erase_sector(struct stfsm *fsm, uint32_t offset)\r\n{\r\nstruct stfsm_seq *seq = &stfsm_seq_erase_sector;\r\nint ret;\r\ndev_dbg(fsm->dev, "erasing sector at 0x%08x\n", offset);\r\nif (fsm->configuration & CFG_ERASESEC_TOGGLE_32BIT_ADDR)\r\nstfsm_enter_32bit_addr(fsm, 1);\r\nseq->addr1 = (offset >> 16) & 0xffff;\r\nseq->addr2 = offset & 0xffff;\r\nstfsm_load_seq(fsm, seq);\r\nstfsm_wait_seq(fsm);\r\nret = stfsm_wait_busy(fsm);\r\nif (ret && fsm->configuration & CFG_S25FL_CHECK_ERROR_FLAGS)\r\nstfsm_s25fl_clear_status_reg(fsm);\r\nif (fsm->configuration & CFG_ERASESEC_TOGGLE_32BIT_ADDR)\r\nstfsm_enter_32bit_addr(fsm, 0);\r\nreturn ret;\r\n}\r\nstatic int stfsm_erase_chip(struct stfsm *fsm)\r\n{\r\nconst struct stfsm_seq *seq = &stfsm_seq_erase_chip;\r\ndev_dbg(fsm->dev, "erasing chip\n");\r\nstfsm_load_seq(fsm, seq);\r\nstfsm_wait_seq(fsm);\r\nreturn stfsm_wait_busy(fsm);\r\n}\r\nstatic int stfsm_mtd_write(struct mtd_info *mtd, loff_t to, size_t len,\r\nsize_t *retlen, const u_char *buf)\r\n{\r\nstruct stfsm *fsm = dev_get_drvdata(mtd->dev.parent);\r\nu32 page_offs;\r\nu32 bytes;\r\nuint8_t *b = (uint8_t *)buf;\r\nint ret = 0;\r\ndev_dbg(fsm->dev, "%s to 0x%08x, len %zd\n", __func__, (u32)to, len);\r\npage_offs = to % FLASH_PAGESIZE;\r\nmutex_lock(&fsm->lock);\r\nwhile (len) {\r\nbytes = min_t(size_t, FLASH_PAGESIZE - page_offs, len);\r\nret = stfsm_write(fsm, b, bytes, to);\r\nif (ret)\r\ngoto out1;\r\nb += bytes;\r\nlen -= bytes;\r\nto += bytes;\r\npage_offs = 0;\r\n*retlen += bytes;\r\n}\r\nout1:\r\nmutex_unlock(&fsm->lock);\r\nreturn ret;\r\n}\r\nstatic int stfsm_mtd_erase(struct mtd_info *mtd, struct erase_info *instr)\r\n{\r\nstruct stfsm *fsm = dev_get_drvdata(mtd->dev.parent);\r\nu32 addr, len;\r\nint ret;\r\ndev_dbg(fsm->dev, "%s at 0x%llx, len %lld\n", __func__,\r\n(long long)instr->addr, (long long)instr->len);\r\naddr = instr->addr;\r\nlen = instr->len;\r\nmutex_lock(&fsm->lock);\r\nif (len == mtd->size) {\r\nret = stfsm_erase_chip(fsm);\r\nif (ret)\r\ngoto out1;\r\n} else {\r\nwhile (len) {\r\nret = stfsm_erase_sector(fsm, addr);\r\nif (ret)\r\ngoto out1;\r\naddr += mtd->erasesize;\r\nlen -= mtd->erasesize;\r\n}\r\n}\r\nmutex_unlock(&fsm->lock);\r\ninstr->state = MTD_ERASE_DONE;\r\nmtd_erase_callback(instr);\r\nreturn 0;\r\nout1:\r\ninstr->state = MTD_ERASE_FAILED;\r\nmutex_unlock(&fsm->lock);\r\nreturn ret;\r\n}\r\nstatic void stfsm_read_jedec(struct stfsm *fsm, uint8_t *jedec)\r\n{\r\nconst struct stfsm_seq *seq = &stfsm_seq_read_jedec;\r\nuint32_t tmp[2];\r\nstfsm_load_seq(fsm, seq);\r\nstfsm_read_fifo(fsm, tmp, 8);\r\nmemcpy(jedec, tmp, 5);\r\nstfsm_wait_seq(fsm);\r\n}\r\nstatic struct flash_info *stfsm_jedec_probe(struct stfsm *fsm)\r\n{\r\nstruct flash_info *info;\r\nu16 ext_jedec;\r\nu32 jedec;\r\nu8 id[5];\r\nstfsm_read_jedec(fsm, id);\r\njedec = id[0] << 16 | id[1] << 8 | id[2];\r\next_jedec = id[3] << 8 | id[4];\r\ndev_dbg(fsm->dev, "JEDEC = 0x%08x [%02x %02x %02x %02x %02x]\n",\r\njedec, id[0], id[1], id[2], id[3], id[4]);\r\nfor (info = flash_types; info->name; info++) {\r\nif (info->jedec_id == jedec) {\r\nif (info->ext_id && info->ext_id != ext_jedec)\r\ncontinue;\r\nreturn info;\r\n}\r\n}\r\ndev_err(fsm->dev, "Unrecognized JEDEC id %06x\n", jedec);\r\nreturn NULL;\r\n}\r\nstatic int stfsm_set_mode(struct stfsm *fsm, uint32_t mode)\r\n{\r\nint ret, timeout = 10;\r\nwhile (--timeout) {\r\nret = readl(fsm->base + SPI_STA_MODE_CHANGE);\r\nif (ret & 0x1)\r\nbreak;\r\nudelay(1);\r\n}\r\nif (!timeout)\r\nreturn -EBUSY;\r\nwritel(mode, fsm->base + SPI_MODESELECT);\r\nreturn 0;\r\n}\r\nstatic void stfsm_set_freq(struct stfsm *fsm, uint32_t spi_freq)\r\n{\r\nuint32_t emi_freq;\r\nuint32_t clk_div;\r\nemi_freq = clk_get_rate(fsm->clk);\r\nclk_div = 2 * DIV_ROUND_UP(emi_freq, 2 * spi_freq);\r\nif (clk_div < 2)\r\nclk_div = 2;\r\nelse if (clk_div > 128)\r\nclk_div = 128;\r\nif (clk_div <= 4)\r\nfsm->fifo_dir_delay = 0;\r\nelse if (clk_div <= 10)\r\nfsm->fifo_dir_delay = 1;\r\nelse\r\nfsm->fifo_dir_delay = DIV_ROUND_UP(clk_div, 10);\r\ndev_dbg(fsm->dev, "emi_clk = %uHZ, spi_freq = %uHZ, clk_div = %u\n",\r\nemi_freq, spi_freq, clk_div);\r\nwritel(clk_div, fsm->base + SPI_CLOCKDIV);\r\n}\r\nstatic int stfsm_init(struct stfsm *fsm)\r\n{\r\nint ret;\r\nwritel(SEQ_CFG_SWRESET, fsm->base + SPI_FAST_SEQ_CFG);\r\nudelay(1);\r\nwritel(0, fsm->base + SPI_FAST_SEQ_CFG);\r\nstfsm_set_freq(fsm, STFSM_FLASH_SAFE_FREQ);\r\nret = stfsm_set_mode(fsm, SPI_MODESELECT_FSM);\r\nif (ret)\r\nreturn ret;\r\nwritel(SPI_CFG_DEVICE_ST |\r\nSPI_CFG_DEFAULT_MIN_CS_HIGH |\r\nSPI_CFG_DEFAULT_CS_SETUPHOLD |\r\nSPI_CFG_DEFAULT_DATA_HOLD,\r\nfsm->base + SPI_CONFIGDATA);\r\nwritel(STFSM_DEFAULT_WR_TIME, fsm->base + SPI_STATUS_WR_TIME_REG);\r\nwritel(0x00000001, fsm->base + SPI_PROGRAM_ERASE_TIME);\r\nstfsm_clear_fifo(fsm);\r\nreturn 0;\r\n}\r\nstatic void stfsm_fetch_platform_configs(struct platform_device *pdev)\r\n{\r\nstruct stfsm *fsm = platform_get_drvdata(pdev);\r\nstruct device_node *np = pdev->dev.of_node;\r\nstruct regmap *regmap;\r\nuint32_t boot_device_reg;\r\nuint32_t boot_device_spi;\r\nuint32_t boot_device;\r\nint ret;\r\nfsm->booted_from_spi = true;\r\nregmap = syscon_regmap_lookup_by_phandle(np, "st,syscfg");\r\nif (IS_ERR(regmap))\r\ngoto boot_device_fail;\r\nfsm->reset_signal = of_property_read_bool(np, "st,reset-signal");\r\nfsm->reset_por = of_property_read_bool(np, "st,reset-por");\r\nret = of_property_read_u32(np, "st,boot-device-reg", &boot_device_reg);\r\nif (ret)\r\ngoto boot_device_fail;\r\nret = of_property_read_u32(np, "st,boot-device-spi", &boot_device_spi);\r\nif (ret)\r\ngoto boot_device_fail;\r\nret = regmap_read(regmap, boot_device_reg, &boot_device);\r\nif (ret)\r\ngoto boot_device_fail;\r\nif (boot_device != boot_device_spi)\r\nfsm->booted_from_spi = false;\r\nreturn;\r\nboot_device_fail:\r\ndev_warn(&pdev->dev,\r\n"failed to fetch boot device, assuming boot from SPI\n");\r\n}\r\nstatic int stfsm_probe(struct platform_device *pdev)\r\n{\r\nstruct device_node *np = pdev->dev.of_node;\r\nstruct flash_info *info;\r\nstruct resource *res;\r\nstruct stfsm *fsm;\r\nint ret;\r\nif (!np) {\r\ndev_err(&pdev->dev, "No DT found\n");\r\nreturn -EINVAL;\r\n}\r\nfsm = devm_kzalloc(&pdev->dev, sizeof(*fsm), GFP_KERNEL);\r\nif (!fsm)\r\nreturn -ENOMEM;\r\nfsm->dev = &pdev->dev;\r\nplatform_set_drvdata(pdev, fsm);\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nif (!res) {\r\ndev_err(&pdev->dev, "Resource not found\n");\r\nreturn -ENODEV;\r\n}\r\nfsm->base = devm_ioremap_resource(&pdev->dev, res);\r\nif (IS_ERR(fsm->base)) {\r\ndev_err(&pdev->dev,\r\n"Failed to reserve memory region %pR\n", res);\r\nreturn PTR_ERR(fsm->base);\r\n}\r\nfsm->clk = devm_clk_get(&pdev->dev, NULL);\r\nif (IS_ERR(fsm->clk)) {\r\ndev_err(fsm->dev, "Couldn't find EMI clock.\n");\r\nreturn PTR_ERR(fsm->clk);\r\n}\r\nret = clk_prepare_enable(fsm->clk);\r\nif (ret) {\r\ndev_err(fsm->dev, "Failed to enable EMI clock.\n");\r\nreturn ret;\r\n}\r\nmutex_init(&fsm->lock);\r\nret = stfsm_init(fsm);\r\nif (ret) {\r\ndev_err(&pdev->dev, "Failed to initialise FSM Controller\n");\r\nreturn ret;\r\n}\r\nstfsm_fetch_platform_configs(pdev);\r\ninfo = stfsm_jedec_probe(fsm);\r\nif (!info)\r\nreturn -ENODEV;\r\nfsm->info = info;\r\nif (info->sector_size * info->n_sectors > 0x1000000)\r\ninfo->flags |= FLASH_FLAG_32BIT_ADDR;\r\nif (info->config) {\r\nret = info->config(fsm);\r\nif (ret)\r\nreturn ret;\r\n} else {\r\nret = stfsm_prepare_rwe_seqs_default(fsm);\r\nif (ret)\r\nreturn ret;\r\n}\r\nfsm->mtd.name = info->name;\r\nfsm->mtd.dev.parent = &pdev->dev;\r\nmtd_set_of_node(&fsm->mtd, np);\r\nfsm->mtd.type = MTD_NORFLASH;\r\nfsm->mtd.writesize = 4;\r\nfsm->mtd.writebufsize = fsm->mtd.writesize;\r\nfsm->mtd.flags = MTD_CAP_NORFLASH;\r\nfsm->mtd.size = info->sector_size * info->n_sectors;\r\nfsm->mtd.erasesize = info->sector_size;\r\nfsm->mtd._read = stfsm_mtd_read;\r\nfsm->mtd._write = stfsm_mtd_write;\r\nfsm->mtd._erase = stfsm_mtd_erase;\r\ndev_info(&pdev->dev,\r\n"Found serial flash device: %s\n"\r\n" size = %llx (%lldMiB) erasesize = 0x%08x (%uKiB)\n",\r\ninfo->name,\r\n(long long)fsm->mtd.size, (long long)(fsm->mtd.size >> 20),\r\nfsm->mtd.erasesize, (fsm->mtd.erasesize >> 10));\r\nreturn mtd_device_register(&fsm->mtd, NULL, 0);\r\n}\r\nstatic int stfsm_remove(struct platform_device *pdev)\r\n{\r\nstruct stfsm *fsm = platform_get_drvdata(pdev);\r\nreturn mtd_device_unregister(&fsm->mtd);\r\n}\r\nstatic int stfsmfsm_suspend(struct device *dev)\r\n{\r\nstruct stfsm *fsm = dev_get_drvdata(dev);\r\nclk_disable_unprepare(fsm->clk);\r\nreturn 0;\r\n}\r\nstatic int stfsmfsm_resume(struct device *dev)\r\n{\r\nstruct stfsm *fsm = dev_get_drvdata(dev);\r\nclk_prepare_enable(fsm->clk);\r\nreturn 0;\r\n}
