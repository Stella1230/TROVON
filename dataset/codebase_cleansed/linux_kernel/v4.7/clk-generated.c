static int clk_generated_enable(struct clk_hw *hw)\r\n{\r\nstruct clk_generated *gck = to_clk_generated(hw);\r\nunsigned long flags;\r\npr_debug("GCLK: %s, gckdiv = %d, parent id = %d\n",\r\n__func__, gck->gckdiv, gck->parent_id);\r\nspin_lock_irqsave(gck->lock, flags);\r\nregmap_write(gck->regmap, AT91_PMC_PCR,\r\n(gck->id & AT91_PMC_PCR_PID_MASK));\r\nregmap_update_bits(gck->regmap, AT91_PMC_PCR,\r\nAT91_PMC_PCR_GCKDIV_MASK | AT91_PMC_PCR_GCKCSS_MASK |\r\nAT91_PMC_PCR_CMD | AT91_PMC_PCR_GCKEN,\r\nAT91_PMC_PCR_GCKCSS(gck->parent_id) |\r\nAT91_PMC_PCR_CMD |\r\nAT91_PMC_PCR_GCKDIV(gck->gckdiv) |\r\nAT91_PMC_PCR_GCKEN);\r\nspin_unlock_irqrestore(gck->lock, flags);\r\nreturn 0;\r\n}\r\nstatic void clk_generated_disable(struct clk_hw *hw)\r\n{\r\nstruct clk_generated *gck = to_clk_generated(hw);\r\nunsigned long flags;\r\nspin_lock_irqsave(gck->lock, flags);\r\nregmap_write(gck->regmap, AT91_PMC_PCR,\r\n(gck->id & AT91_PMC_PCR_PID_MASK));\r\nregmap_update_bits(gck->regmap, AT91_PMC_PCR,\r\nAT91_PMC_PCR_CMD | AT91_PMC_PCR_GCKEN,\r\nAT91_PMC_PCR_CMD);\r\nspin_unlock_irqrestore(gck->lock, flags);\r\n}\r\nstatic int clk_generated_is_enabled(struct clk_hw *hw)\r\n{\r\nstruct clk_generated *gck = to_clk_generated(hw);\r\nunsigned long flags;\r\nunsigned int status;\r\nspin_lock_irqsave(gck->lock, flags);\r\nregmap_write(gck->regmap, AT91_PMC_PCR,\r\n(gck->id & AT91_PMC_PCR_PID_MASK));\r\nregmap_read(gck->regmap, AT91_PMC_PCR, &status);\r\nspin_unlock_irqrestore(gck->lock, flags);\r\nreturn status & AT91_PMC_PCR_GCKEN ? 1 : 0;\r\n}\r\nstatic unsigned long\r\nclk_generated_recalc_rate(struct clk_hw *hw,\r\nunsigned long parent_rate)\r\n{\r\nstruct clk_generated *gck = to_clk_generated(hw);\r\nreturn DIV_ROUND_CLOSEST(parent_rate, gck->gckdiv + 1);\r\n}\r\nstatic int clk_generated_determine_rate(struct clk_hw *hw,\r\nstruct clk_rate_request *req)\r\n{\r\nstruct clk_generated *gck = to_clk_generated(hw);\r\nstruct clk_hw *parent = NULL;\r\nlong best_rate = -EINVAL;\r\nunsigned long tmp_rate, min_rate;\r\nint best_diff = -1;\r\nint tmp_diff;\r\nint i;\r\nfor (i = 0; i < clk_hw_get_num_parents(hw); i++) {\r\nu32 div;\r\nunsigned long parent_rate;\r\nparent = clk_hw_get_parent_by_index(hw, i);\r\nif (!parent)\r\ncontinue;\r\nparent_rate = clk_hw_get_rate(parent);\r\nmin_rate = DIV_ROUND_CLOSEST(parent_rate, GENERATED_MAX_DIV + 1);\r\nif (!parent_rate ||\r\n(gck->range.max && min_rate > gck->range.max))\r\ncontinue;\r\nfor (div = 1; div < GENERATED_MAX_DIV + 2; div++) {\r\ntmp_rate = DIV_ROUND_CLOSEST(parent_rate, div);\r\ntmp_diff = abs(req->rate - tmp_rate);\r\nif (best_diff < 0 || best_diff > tmp_diff) {\r\nbest_rate = tmp_rate;\r\nbest_diff = tmp_diff;\r\nreq->best_parent_rate = parent_rate;\r\nreq->best_parent_hw = parent;\r\n}\r\nif (!best_diff || tmp_rate < req->rate)\r\nbreak;\r\n}\r\nif (!best_diff)\r\nbreak;\r\n}\r\npr_debug("GCLK: %s, best_rate = %ld, parent clk: %s @ %ld\n",\r\n__func__, best_rate,\r\n__clk_get_name((req->best_parent_hw)->clk),\r\nreq->best_parent_rate);\r\nif (best_rate < 0)\r\nreturn best_rate;\r\nreq->rate = best_rate;\r\nreturn 0;\r\n}\r\nstatic int clk_generated_set_parent(struct clk_hw *hw, u8 index)\r\n{\r\nstruct clk_generated *gck = to_clk_generated(hw);\r\nif (index >= clk_hw_get_num_parents(hw))\r\nreturn -EINVAL;\r\ngck->parent_id = index;\r\nreturn 0;\r\n}\r\nstatic u8 clk_generated_get_parent(struct clk_hw *hw)\r\n{\r\nstruct clk_generated *gck = to_clk_generated(hw);\r\nreturn gck->parent_id;\r\n}\r\nstatic int clk_generated_set_rate(struct clk_hw *hw,\r\nunsigned long rate,\r\nunsigned long parent_rate)\r\n{\r\nstruct clk_generated *gck = to_clk_generated(hw);\r\nu32 div;\r\nif (!rate)\r\nreturn -EINVAL;\r\nif (gck->range.max && rate > gck->range.max)\r\nreturn -EINVAL;\r\ndiv = DIV_ROUND_CLOSEST(parent_rate, rate);\r\nif (div > GENERATED_MAX_DIV + 1 || !div)\r\nreturn -EINVAL;\r\ngck->gckdiv = div - 1;\r\nreturn 0;\r\n}\r\nstatic void clk_generated_startup(struct clk_generated *gck)\r\n{\r\nu32 tmp;\r\nunsigned long flags;\r\nspin_lock_irqsave(gck->lock, flags);\r\nregmap_write(gck->regmap, AT91_PMC_PCR,\r\n(gck->id & AT91_PMC_PCR_PID_MASK));\r\nregmap_read(gck->regmap, AT91_PMC_PCR, &tmp);\r\nspin_unlock_irqrestore(gck->lock, flags);\r\ngck->parent_id = (tmp & AT91_PMC_PCR_GCKCSS_MASK)\r\n>> AT91_PMC_PCR_GCKCSS_OFFSET;\r\ngck->gckdiv = (tmp & AT91_PMC_PCR_GCKDIV_MASK)\r\n>> AT91_PMC_PCR_GCKDIV_OFFSET;\r\n}\r\nstatic struct clk * __init\r\nat91_clk_register_generated(struct regmap *regmap, spinlock_t *lock, const char\r\n*name, const char **parent_names, u8 num_parents,\r\nu8 id, const struct clk_range *range)\r\n{\r\nstruct clk_generated *gck;\r\nstruct clk *clk = NULL;\r\nstruct clk_init_data init;\r\ngck = kzalloc(sizeof(*gck), GFP_KERNEL);\r\nif (!gck)\r\nreturn ERR_PTR(-ENOMEM);\r\ninit.name = name;\r\ninit.ops = &generated_ops;\r\ninit.parent_names = parent_names;\r\ninit.num_parents = num_parents;\r\ninit.flags = CLK_SET_RATE_GATE | CLK_SET_PARENT_GATE;\r\ngck->id = id;\r\ngck->hw.init = &init;\r\ngck->regmap = regmap;\r\ngck->lock = lock;\r\ngck->range = *range;\r\nclk = clk_register(NULL, &gck->hw);\r\nif (IS_ERR(clk))\r\nkfree(gck);\r\nelse\r\nclk_generated_startup(gck);\r\nreturn clk;\r\n}\r\nvoid __init of_sama5d2_clk_generated_setup(struct device_node *np)\r\n{\r\nint num;\r\nu32 id;\r\nconst char *name;\r\nstruct clk *clk;\r\nunsigned int num_parents;\r\nconst char *parent_names[GENERATED_SOURCE_MAX];\r\nstruct device_node *gcknp;\r\nstruct clk_range range = CLK_RANGE(0, 0);\r\nstruct regmap *regmap;\r\nnum_parents = of_clk_get_parent_count(np);\r\nif (num_parents == 0 || num_parents > GENERATED_SOURCE_MAX)\r\nreturn;\r\nof_clk_parent_fill(np, parent_names, num_parents);\r\nnum = of_get_child_count(np);\r\nif (!num || num > PERIPHERAL_MAX)\r\nreturn;\r\nregmap = syscon_node_to_regmap(of_get_parent(np));\r\nif (IS_ERR(regmap))\r\nreturn;\r\nfor_each_child_of_node(np, gcknp) {\r\nif (of_property_read_u32(gcknp, "reg", &id))\r\ncontinue;\r\nif (id < PERIPHERAL_ID_MIN || id >= PERIPHERAL_MAX)\r\ncontinue;\r\nif (of_property_read_string(np, "clock-output-names", &name))\r\nname = gcknp->name;\r\nof_at91_get_clk_range(gcknp, "atmel,clk-output-range",\r\n&range);\r\nclk = at91_clk_register_generated(regmap, &pmc_pcr_lock, name,\r\nparent_names, num_parents,\r\nid, &range);\r\nif (IS_ERR(clk))\r\ncontinue;\r\nof_clk_add_provider(gcknp, of_clk_src_simple_get, clk);\r\n}\r\n}
