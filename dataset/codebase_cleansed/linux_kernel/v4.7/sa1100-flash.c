static void sa1100_set_vpp(struct map_info *map, int on)\r\n{\r\nstruct sa_subdev_info *subdev = container_of(map, struct sa_subdev_info, map);\r\nunsigned long flags;\r\nspin_lock_irqsave(&sa1100_vpp_lock, flags);\r\nif (on) {\r\nif (++sa1100_vpp_refcnt == 1)\r\nsubdev->plat->set_vpp(1);\r\n} else {\r\nif (--sa1100_vpp_refcnt == 0)\r\nsubdev->plat->set_vpp(0);\r\n}\r\nspin_unlock_irqrestore(&sa1100_vpp_lock, flags);\r\n}\r\nstatic void sa1100_destroy_subdev(struct sa_subdev_info *subdev)\r\n{\r\nif (subdev->mtd)\r\nmap_destroy(subdev->mtd);\r\nif (subdev->map.virt)\r\niounmap(subdev->map.virt);\r\nrelease_mem_region(subdev->map.phys, subdev->map.size);\r\n}\r\nstatic int sa1100_probe_subdev(struct sa_subdev_info *subdev, struct resource *res)\r\n{\r\nunsigned long phys;\r\nunsigned int size;\r\nint ret;\r\nphys = res->start;\r\nsize = res->end - phys + 1;\r\nswitch (phys) {\r\ndefault:\r\nprintk(KERN_WARNING "SA1100 flash: unknown base address "\r\n"0x%08lx, assuming CS0\n", phys);\r\ncase SA1100_CS0_PHYS:\r\nsubdev->map.bankwidth = (MSC0 & MSC_RBW) ? 2 : 4;\r\nbreak;\r\ncase SA1100_CS1_PHYS:\r\nsubdev->map.bankwidth = ((MSC0 >> 16) & MSC_RBW) ? 2 : 4;\r\nbreak;\r\n}\r\nif (!request_mem_region(phys, size, subdev->name)) {\r\nret = -EBUSY;\r\ngoto out;\r\n}\r\nif (subdev->plat->set_vpp)\r\nsubdev->map.set_vpp = sa1100_set_vpp;\r\nsubdev->map.phys = phys;\r\nsubdev->map.size = size;\r\nsubdev->map.virt = ioremap(phys, size);\r\nif (!subdev->map.virt) {\r\nret = -ENOMEM;\r\ngoto err;\r\n}\r\nsimple_map_init(&subdev->map);\r\nsubdev->mtd = do_map_probe(subdev->plat->map_name, &subdev->map);\r\nif (subdev->mtd == NULL) {\r\nret = -ENXIO;\r\ngoto err;\r\n}\r\nprintk(KERN_INFO "SA1100 flash: CFI device at 0x%08lx, %uMiB, %d-bit\n",\r\nphys, (unsigned)(subdev->mtd->size >> 20),\r\nsubdev->map.bankwidth * 8);\r\nreturn 0;\r\nerr:\r\nsa1100_destroy_subdev(subdev);\r\nout:\r\nreturn ret;\r\n}\r\nstatic void sa1100_destroy(struct sa_info *info, struct flash_platform_data *plat)\r\n{\r\nint i;\r\nif (info->mtd) {\r\nmtd_device_unregister(info->mtd);\r\nif (info->mtd != info->subdev[0].mtd)\r\nmtd_concat_destroy(info->mtd);\r\n}\r\nfor (i = info->num_subdev - 1; i >= 0; i--)\r\nsa1100_destroy_subdev(&info->subdev[i]);\r\nkfree(info);\r\nif (plat->exit)\r\nplat->exit();\r\n}\r\nstatic struct sa_info *sa1100_setup_mtd(struct platform_device *pdev,\r\nstruct flash_platform_data *plat)\r\n{\r\nstruct sa_info *info;\r\nint nr, size, i, ret = 0;\r\nfor (nr = 0; ; nr++)\r\nif (!platform_get_resource(pdev, IORESOURCE_MEM, nr))\r\nbreak;\r\nif (nr == 0) {\r\nret = -ENODEV;\r\ngoto out;\r\n}\r\nsize = sizeof(struct sa_info) + sizeof(struct sa_subdev_info) * nr;\r\ninfo = kzalloc(size, GFP_KERNEL);\r\nif (!info) {\r\nret = -ENOMEM;\r\ngoto out;\r\n}\r\nif (plat->init) {\r\nret = plat->init();\r\nif (ret)\r\ngoto err;\r\n}\r\nfor (i = 0; i < nr; i++) {\r\nstruct sa_subdev_info *subdev = &info->subdev[i];\r\nstruct resource *res;\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, i);\r\nif (!res)\r\nbreak;\r\nsubdev->map.name = subdev->name;\r\nsprintf(subdev->name, "%s-%d", plat->name, i);\r\nsubdev->plat = plat;\r\nret = sa1100_probe_subdev(subdev, res);\r\nif (ret)\r\nbreak;\r\n}\r\ninfo->num_subdev = i;\r\nif (ret != 0 && !(ret == -ENXIO && info->num_subdev > 0))\r\ngoto err;\r\nif (info->num_subdev == 1) {\r\nstrcpy(info->subdev[0].name, plat->name);\r\ninfo->mtd = info->subdev[0].mtd;\r\nret = 0;\r\n} else if (info->num_subdev > 1) {\r\nstruct mtd_info *cdev[nr];\r\nfor (i = 0; i < info->num_subdev; i++)\r\ncdev[i] = info->subdev[i].mtd;\r\ninfo->mtd = mtd_concat_create(cdev, info->num_subdev,\r\nplat->name);\r\nif (info->mtd == NULL)\r\nret = -ENXIO;\r\n}\r\ninfo->mtd->dev.parent = &pdev->dev;\r\nif (ret == 0)\r\nreturn info;\r\nerr:\r\nsa1100_destroy(info, plat);\r\nout:\r\nreturn ERR_PTR(ret);\r\n}\r\nstatic int sa1100_mtd_probe(struct platform_device *pdev)\r\n{\r\nstruct flash_platform_data *plat = dev_get_platdata(&pdev->dev);\r\nstruct sa_info *info;\r\nint err;\r\nif (!plat)\r\nreturn -ENODEV;\r\ninfo = sa1100_setup_mtd(pdev, plat);\r\nif (IS_ERR(info)) {\r\nerr = PTR_ERR(info);\r\ngoto out;\r\n}\r\nmtd_device_parse_register(info->mtd, part_probes, NULL, plat->parts,\r\nplat->nr_parts);\r\nplatform_set_drvdata(pdev, info);\r\nerr = 0;\r\nout:\r\nreturn err;\r\n}\r\nstatic int sa1100_mtd_remove(struct platform_device *pdev)\r\n{\r\nstruct sa_info *info = platform_get_drvdata(pdev);\r\nstruct flash_platform_data *plat = dev_get_platdata(&pdev->dev);\r\nsa1100_destroy(info, plat);\r\nreturn 0;\r\n}
