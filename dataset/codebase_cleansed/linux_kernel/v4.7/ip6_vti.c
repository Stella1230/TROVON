static u32 HASH(const struct in6_addr *addr1, const struct in6_addr *addr2)\r\n{\r\nu32 hash = ipv6_addr_hash(addr1) ^ ipv6_addr_hash(addr2);\r\nreturn hash_32(hash, HASH_SIZE_SHIFT);\r\n}\r\nstatic struct ip6_tnl *\r\nvti6_tnl_lookup(struct net *net, const struct in6_addr *remote,\r\nconst struct in6_addr *local)\r\n{\r\nunsigned int hash = HASH(remote, local);\r\nstruct ip6_tnl *t;\r\nstruct vti6_net *ip6n = net_generic(net, vti6_net_id);\r\nstruct in6_addr any;\r\nfor_each_vti6_tunnel_rcu(ip6n->tnls_r_l[hash]) {\r\nif (ipv6_addr_equal(local, &t->parms.laddr) &&\r\nipv6_addr_equal(remote, &t->parms.raddr) &&\r\n(t->dev->flags & IFF_UP))\r\nreturn t;\r\n}\r\nmemset(&any, 0, sizeof(any));\r\nhash = HASH(&any, local);\r\nfor_each_vti6_tunnel_rcu(ip6n->tnls_r_l[hash]) {\r\nif (ipv6_addr_equal(local, &t->parms.laddr) &&\r\n(t->dev->flags & IFF_UP))\r\nreturn t;\r\n}\r\nhash = HASH(remote, &any);\r\nfor_each_vti6_tunnel_rcu(ip6n->tnls_r_l[hash]) {\r\nif (ipv6_addr_equal(remote, &t->parms.raddr) &&\r\n(t->dev->flags & IFF_UP))\r\nreturn t;\r\n}\r\nt = rcu_dereference(ip6n->tnls_wc[0]);\r\nif (t && (t->dev->flags & IFF_UP))\r\nreturn t;\r\nreturn NULL;\r\n}\r\nstatic struct ip6_tnl __rcu **\r\nvti6_tnl_bucket(struct vti6_net *ip6n, const struct __ip6_tnl_parm *p)\r\n{\r\nconst struct in6_addr *remote = &p->raddr;\r\nconst struct in6_addr *local = &p->laddr;\r\nunsigned int h = 0;\r\nint prio = 0;\r\nif (!ipv6_addr_any(remote) || !ipv6_addr_any(local)) {\r\nprio = 1;\r\nh = HASH(remote, local);\r\n}\r\nreturn &ip6n->tnls[prio][h];\r\n}\r\nstatic void\r\nvti6_tnl_link(struct vti6_net *ip6n, struct ip6_tnl *t)\r\n{\r\nstruct ip6_tnl __rcu **tp = vti6_tnl_bucket(ip6n, &t->parms);\r\nrcu_assign_pointer(t->next , rtnl_dereference(*tp));\r\nrcu_assign_pointer(*tp, t);\r\n}\r\nstatic void\r\nvti6_tnl_unlink(struct vti6_net *ip6n, struct ip6_tnl *t)\r\n{\r\nstruct ip6_tnl __rcu **tp;\r\nstruct ip6_tnl *iter;\r\nfor (tp = vti6_tnl_bucket(ip6n, &t->parms);\r\n(iter = rtnl_dereference(*tp)) != NULL;\r\ntp = &iter->next) {\r\nif (t == iter) {\r\nrcu_assign_pointer(*tp, t->next);\r\nbreak;\r\n}\r\n}\r\n}\r\nstatic void vti6_dev_free(struct net_device *dev)\r\n{\r\nfree_percpu(dev->tstats);\r\nfree_netdev(dev);\r\n}\r\nstatic int vti6_tnl_create2(struct net_device *dev)\r\n{\r\nstruct ip6_tnl *t = netdev_priv(dev);\r\nstruct net *net = dev_net(dev);\r\nstruct vti6_net *ip6n = net_generic(net, vti6_net_id);\r\nint err;\r\nerr = register_netdevice(dev);\r\nif (err < 0)\r\ngoto out;\r\nstrcpy(t->parms.name, dev->name);\r\ndev->rtnl_link_ops = &vti6_link_ops;\r\ndev_hold(dev);\r\nvti6_tnl_link(ip6n, t);\r\nreturn 0;\r\nout:\r\nreturn err;\r\n}\r\nstatic struct ip6_tnl *vti6_tnl_create(struct net *net, struct __ip6_tnl_parm *p)\r\n{\r\nstruct net_device *dev;\r\nstruct ip6_tnl *t;\r\nchar name[IFNAMSIZ];\r\nint err;\r\nif (p->name[0])\r\nstrlcpy(name, p->name, IFNAMSIZ);\r\nelse\r\nsprintf(name, "ip6_vti%%d");\r\ndev = alloc_netdev(sizeof(*t), name, NET_NAME_UNKNOWN, vti6_dev_setup);\r\nif (!dev)\r\ngoto failed;\r\ndev_net_set(dev, net);\r\nt = netdev_priv(dev);\r\nt->parms = *p;\r\nt->net = dev_net(dev);\r\nerr = vti6_tnl_create2(dev);\r\nif (err < 0)\r\ngoto failed_free;\r\nreturn t;\r\nfailed_free:\r\nvti6_dev_free(dev);\r\nfailed:\r\nreturn NULL;\r\n}\r\nstatic struct ip6_tnl *vti6_locate(struct net *net, struct __ip6_tnl_parm *p,\r\nint create)\r\n{\r\nconst struct in6_addr *remote = &p->raddr;\r\nconst struct in6_addr *local = &p->laddr;\r\nstruct ip6_tnl __rcu **tp;\r\nstruct ip6_tnl *t;\r\nstruct vti6_net *ip6n = net_generic(net, vti6_net_id);\r\nfor (tp = vti6_tnl_bucket(ip6n, p);\r\n(t = rtnl_dereference(*tp)) != NULL;\r\ntp = &t->next) {\r\nif (ipv6_addr_equal(local, &t->parms.laddr) &&\r\nipv6_addr_equal(remote, &t->parms.raddr)) {\r\nif (create)\r\nreturn NULL;\r\nreturn t;\r\n}\r\n}\r\nif (!create)\r\nreturn NULL;\r\nreturn vti6_tnl_create(net, p);\r\n}\r\nstatic void vti6_dev_uninit(struct net_device *dev)\r\n{\r\nstruct ip6_tnl *t = netdev_priv(dev);\r\nstruct vti6_net *ip6n = net_generic(t->net, vti6_net_id);\r\nif (dev == ip6n->fb_tnl_dev)\r\nRCU_INIT_POINTER(ip6n->tnls_wc[0], NULL);\r\nelse\r\nvti6_tnl_unlink(ip6n, t);\r\ndev_put(dev);\r\n}\r\nstatic int vti6_rcv(struct sk_buff *skb)\r\n{\r\nstruct ip6_tnl *t;\r\nconst struct ipv6hdr *ipv6h = ipv6_hdr(skb);\r\nrcu_read_lock();\r\nt = vti6_tnl_lookup(dev_net(skb->dev), &ipv6h->saddr, &ipv6h->daddr);\r\nif (t) {\r\nif (t->parms.proto != IPPROTO_IPV6 && t->parms.proto != 0) {\r\nrcu_read_unlock();\r\ngoto discard;\r\n}\r\nif (!xfrm6_policy_check(NULL, XFRM_POLICY_IN, skb)) {\r\nrcu_read_unlock();\r\nreturn 0;\r\n}\r\nif (!ip6_tnl_rcv_ctl(t, &ipv6h->daddr, &ipv6h->saddr)) {\r\nt->dev->stats.rx_dropped++;\r\nrcu_read_unlock();\r\ngoto discard;\r\n}\r\nXFRM_TUNNEL_SKB_CB(skb)->tunnel.ip6 = t;\r\nrcu_read_unlock();\r\nreturn xfrm6_rcv(skb);\r\n}\r\nrcu_read_unlock();\r\nreturn -EINVAL;\r\ndiscard:\r\nkfree_skb(skb);\r\nreturn 0;\r\n}\r\nstatic int vti6_rcv_cb(struct sk_buff *skb, int err)\r\n{\r\nunsigned short family;\r\nstruct net_device *dev;\r\nstruct pcpu_sw_netstats *tstats;\r\nstruct xfrm_state *x;\r\nstruct ip6_tnl *t = XFRM_TUNNEL_SKB_CB(skb)->tunnel.ip6;\r\nu32 orig_mark = skb->mark;\r\nint ret;\r\nif (!t)\r\nreturn 1;\r\ndev = t->dev;\r\nif (err) {\r\ndev->stats.rx_errors++;\r\ndev->stats.rx_dropped++;\r\nreturn 0;\r\n}\r\nx = xfrm_input_state(skb);\r\nfamily = x->inner_mode->afinfo->family;\r\nskb->mark = be32_to_cpu(t->parms.i_key);\r\nret = xfrm_policy_check(NULL, XFRM_POLICY_IN, skb, family);\r\nskb->mark = orig_mark;\r\nif (!ret)\r\nreturn -EPERM;\r\nskb_scrub_packet(skb, !net_eq(t->net, dev_net(skb->dev)));\r\nskb->dev = dev;\r\ntstats = this_cpu_ptr(dev->tstats);\r\nu64_stats_update_begin(&tstats->syncp);\r\ntstats->rx_packets++;\r\ntstats->rx_bytes += skb->len;\r\nu64_stats_update_end(&tstats->syncp);\r\nreturn 0;\r\n}\r\nstatic inline bool\r\nvti6_addr_conflict(const struct ip6_tnl *t, const struct ipv6hdr *hdr)\r\n{\r\nreturn ipv6_addr_equal(&t->parms.raddr, &hdr->saddr);\r\n}\r\nstatic bool vti6_state_check(const struct xfrm_state *x,\r\nconst struct in6_addr *dst,\r\nconst struct in6_addr *src)\r\n{\r\nxfrm_address_t *daddr = (xfrm_address_t *)dst;\r\nxfrm_address_t *saddr = (xfrm_address_t *)src;\r\nif (!x || x->props.mode != XFRM_MODE_TUNNEL ||\r\nx->props.family != AF_INET6)\r\nreturn false;\r\nif (ipv6_addr_any(dst))\r\nreturn xfrm_addr_equal(saddr, &x->props.saddr, AF_INET6);\r\nif (!xfrm_state_addr_check(x, daddr, saddr, AF_INET6))\r\nreturn false;\r\nreturn true;\r\n}\r\nstatic int\r\nvti6_xmit(struct sk_buff *skb, struct net_device *dev, struct flowi *fl)\r\n{\r\nstruct ip6_tnl *t = netdev_priv(dev);\r\nstruct net_device_stats *stats = &t->dev->stats;\r\nstruct dst_entry *dst = skb_dst(skb);\r\nstruct net_device *tdev;\r\nstruct xfrm_state *x;\r\nint err = -1;\r\nint mtu;\r\nif (!dst)\r\ngoto tx_err_link_failure;\r\ndst_hold(dst);\r\ndst = xfrm_lookup(t->net, dst, fl, NULL, 0);\r\nif (IS_ERR(dst)) {\r\nerr = PTR_ERR(dst);\r\ndst = NULL;\r\ngoto tx_err_link_failure;\r\n}\r\nx = dst->xfrm;\r\nif (!vti6_state_check(x, &t->parms.raddr, &t->parms.laddr))\r\ngoto tx_err_link_failure;\r\nif (!ip6_tnl_xmit_ctl(t, (const struct in6_addr *)&x->props.saddr,\r\n(const struct in6_addr *)&x->id.daddr))\r\ngoto tx_err_link_failure;\r\ntdev = dst->dev;\r\nif (tdev == dev) {\r\nstats->collisions++;\r\nnet_warn_ratelimited("%s: Local routing loop detected!\n",\r\nt->parms.name);\r\ngoto tx_err_dst_release;\r\n}\r\nskb_scrub_packet(skb, !net_eq(t->net, dev_net(dev)));\r\nskb_dst_set(skb, dst);\r\nskb->dev = skb_dst(skb)->dev;\r\nmtu = dst_mtu(dst);\r\nif (!skb->ignore_df && skb->len > mtu) {\r\nskb_dst(skb)->ops->update_pmtu(dst, NULL, skb, mtu);\r\nif (skb->protocol == htons(ETH_P_IPV6))\r\nicmpv6_send(skb, ICMPV6_PKT_TOOBIG, 0, mtu);\r\nelse\r\nicmp_send(skb, ICMP_DEST_UNREACH, ICMP_FRAG_NEEDED,\r\nhtonl(mtu));\r\nreturn -EMSGSIZE;\r\n}\r\nerr = dst_output(t->net, skb->sk, skb);\r\nif (net_xmit_eval(err) == 0) {\r\nstruct pcpu_sw_netstats *tstats = this_cpu_ptr(dev->tstats);\r\nu64_stats_update_begin(&tstats->syncp);\r\ntstats->tx_bytes += skb->len;\r\ntstats->tx_packets++;\r\nu64_stats_update_end(&tstats->syncp);\r\n} else {\r\nstats->tx_errors++;\r\nstats->tx_aborted_errors++;\r\n}\r\nreturn 0;\r\ntx_err_link_failure:\r\nstats->tx_carrier_errors++;\r\ndst_link_failure(skb);\r\ntx_err_dst_release:\r\ndst_release(dst);\r\nreturn err;\r\n}\r\nstatic netdev_tx_t\r\nvti6_tnl_xmit(struct sk_buff *skb, struct net_device *dev)\r\n{\r\nstruct ip6_tnl *t = netdev_priv(dev);\r\nstruct net_device_stats *stats = &t->dev->stats;\r\nstruct ipv6hdr *ipv6h;\r\nstruct flowi fl;\r\nint ret;\r\nmemset(&fl, 0, sizeof(fl));\r\nswitch (skb->protocol) {\r\ncase htons(ETH_P_IPV6):\r\nipv6h = ipv6_hdr(skb);\r\nif ((t->parms.proto != IPPROTO_IPV6 && t->parms.proto != 0) ||\r\nvti6_addr_conflict(t, ipv6h))\r\ngoto tx_err;\r\nxfrm_decode_session(skb, &fl, AF_INET6);\r\nmemset(IP6CB(skb), 0, sizeof(*IP6CB(skb)));\r\nbreak;\r\ncase htons(ETH_P_IP):\r\nxfrm_decode_session(skb, &fl, AF_INET);\r\nmemset(IPCB(skb), 0, sizeof(*IPCB(skb)));\r\nbreak;\r\ndefault:\r\ngoto tx_err;\r\n}\r\nfl.flowi_mark = be32_to_cpu(t->parms.o_key);\r\nret = vti6_xmit(skb, dev, &fl);\r\nif (ret < 0)\r\ngoto tx_err;\r\nreturn NETDEV_TX_OK;\r\ntx_err:\r\nstats->tx_errors++;\r\nstats->tx_dropped++;\r\nkfree_skb(skb);\r\nreturn NETDEV_TX_OK;\r\n}\r\nstatic int vti6_err(struct sk_buff *skb, struct inet6_skb_parm *opt,\r\nu8 type, u8 code, int offset, __be32 info)\r\n{\r\n__be32 spi;\r\n__u32 mark;\r\nstruct xfrm_state *x;\r\nstruct ip6_tnl *t;\r\nstruct ip_esp_hdr *esph;\r\nstruct ip_auth_hdr *ah;\r\nstruct ip_comp_hdr *ipch;\r\nstruct net *net = dev_net(skb->dev);\r\nconst struct ipv6hdr *iph = (const struct ipv6hdr *)skb->data;\r\nint protocol = iph->nexthdr;\r\nt = vti6_tnl_lookup(dev_net(skb->dev), &iph->daddr, &iph->saddr);\r\nif (!t)\r\nreturn -1;\r\nmark = be32_to_cpu(t->parms.o_key);\r\nswitch (protocol) {\r\ncase IPPROTO_ESP:\r\nesph = (struct ip_esp_hdr *)(skb->data + offset);\r\nspi = esph->spi;\r\nbreak;\r\ncase IPPROTO_AH:\r\nah = (struct ip_auth_hdr *)(skb->data + offset);\r\nspi = ah->spi;\r\nbreak;\r\ncase IPPROTO_COMP:\r\nipch = (struct ip_comp_hdr *)(skb->data + offset);\r\nspi = htonl(ntohs(ipch->cpi));\r\nbreak;\r\ndefault:\r\nreturn 0;\r\n}\r\nif (type != ICMPV6_PKT_TOOBIG &&\r\ntype != NDISC_REDIRECT)\r\nreturn 0;\r\nx = xfrm_state_lookup(net, mark, (const xfrm_address_t *)&iph->daddr,\r\nspi, protocol, AF_INET6);\r\nif (!x)\r\nreturn 0;\r\nif (type == NDISC_REDIRECT)\r\nip6_redirect(skb, net, skb->dev->ifindex, 0);\r\nelse\r\nip6_update_pmtu(skb, net, info, 0, 0);\r\nxfrm_state_put(x);\r\nreturn 0;\r\n}\r\nstatic void vti6_link_config(struct ip6_tnl *t)\r\n{\r\nstruct net_device *dev = t->dev;\r\nstruct __ip6_tnl_parm *p = &t->parms;\r\nmemcpy(dev->dev_addr, &p->laddr, sizeof(struct in6_addr));\r\nmemcpy(dev->broadcast, &p->raddr, sizeof(struct in6_addr));\r\np->flags &= ~(IP6_TNL_F_CAP_XMIT | IP6_TNL_F_CAP_RCV |\r\nIP6_TNL_F_CAP_PER_PACKET);\r\np->flags |= ip6_tnl_get_cap(t, &p->laddr, &p->raddr);\r\nif (p->flags & IP6_TNL_F_CAP_XMIT && p->flags & IP6_TNL_F_CAP_RCV)\r\ndev->flags |= IFF_POINTOPOINT;\r\nelse\r\ndev->flags &= ~IFF_POINTOPOINT;\r\n}\r\nstatic int\r\nvti6_tnl_change(struct ip6_tnl *t, const struct __ip6_tnl_parm *p)\r\n{\r\nt->parms.laddr = p->laddr;\r\nt->parms.raddr = p->raddr;\r\nt->parms.link = p->link;\r\nt->parms.i_key = p->i_key;\r\nt->parms.o_key = p->o_key;\r\nt->parms.proto = p->proto;\r\ndst_cache_reset(&t->dst_cache);\r\nvti6_link_config(t);\r\nreturn 0;\r\n}\r\nstatic int vti6_update(struct ip6_tnl *t, struct __ip6_tnl_parm *p)\r\n{\r\nstruct net *net = dev_net(t->dev);\r\nstruct vti6_net *ip6n = net_generic(net, vti6_net_id);\r\nint err;\r\nvti6_tnl_unlink(ip6n, t);\r\nsynchronize_net();\r\nerr = vti6_tnl_change(t, p);\r\nvti6_tnl_link(ip6n, t);\r\nnetdev_state_change(t->dev);\r\nreturn err;\r\n}\r\nstatic void\r\nvti6_parm_from_user(struct __ip6_tnl_parm *p, const struct ip6_tnl_parm2 *u)\r\n{\r\np->laddr = u->laddr;\r\np->raddr = u->raddr;\r\np->link = u->link;\r\np->i_key = u->i_key;\r\np->o_key = u->o_key;\r\np->proto = u->proto;\r\nmemcpy(p->name, u->name, sizeof(u->name));\r\n}\r\nstatic void\r\nvti6_parm_to_user(struct ip6_tnl_parm2 *u, const struct __ip6_tnl_parm *p)\r\n{\r\nu->laddr = p->laddr;\r\nu->raddr = p->raddr;\r\nu->link = p->link;\r\nu->i_key = p->i_key;\r\nu->o_key = p->o_key;\r\nu->proto = p->proto;\r\nmemcpy(u->name, p->name, sizeof(u->name));\r\n}\r\nstatic int\r\nvti6_ioctl(struct net_device *dev, struct ifreq *ifr, int cmd)\r\n{\r\nint err = 0;\r\nstruct ip6_tnl_parm2 p;\r\nstruct __ip6_tnl_parm p1;\r\nstruct ip6_tnl *t = NULL;\r\nstruct net *net = dev_net(dev);\r\nstruct vti6_net *ip6n = net_generic(net, vti6_net_id);\r\nswitch (cmd) {\r\ncase SIOCGETTUNNEL:\r\nif (dev == ip6n->fb_tnl_dev) {\r\nif (copy_from_user(&p, ifr->ifr_ifru.ifru_data, sizeof(p))) {\r\nerr = -EFAULT;\r\nbreak;\r\n}\r\nvti6_parm_from_user(&p1, &p);\r\nt = vti6_locate(net, &p1, 0);\r\n} else {\r\nmemset(&p, 0, sizeof(p));\r\n}\r\nif (!t)\r\nt = netdev_priv(dev);\r\nvti6_parm_to_user(&p, &t->parms);\r\nif (copy_to_user(ifr->ifr_ifru.ifru_data, &p, sizeof(p)))\r\nerr = -EFAULT;\r\nbreak;\r\ncase SIOCADDTUNNEL:\r\ncase SIOCCHGTUNNEL:\r\nerr = -EPERM;\r\nif (!ns_capable(net->user_ns, CAP_NET_ADMIN))\r\nbreak;\r\nerr = -EFAULT;\r\nif (copy_from_user(&p, ifr->ifr_ifru.ifru_data, sizeof(p)))\r\nbreak;\r\nerr = -EINVAL;\r\nif (p.proto != IPPROTO_IPV6 && p.proto != 0)\r\nbreak;\r\nvti6_parm_from_user(&p1, &p);\r\nt = vti6_locate(net, &p1, cmd == SIOCADDTUNNEL);\r\nif (dev != ip6n->fb_tnl_dev && cmd == SIOCCHGTUNNEL) {\r\nif (t) {\r\nif (t->dev != dev) {\r\nerr = -EEXIST;\r\nbreak;\r\n}\r\n} else\r\nt = netdev_priv(dev);\r\nerr = vti6_update(t, &p1);\r\n}\r\nif (t) {\r\nerr = 0;\r\nvti6_parm_to_user(&p, &t->parms);\r\nif (copy_to_user(ifr->ifr_ifru.ifru_data, &p, sizeof(p)))\r\nerr = -EFAULT;\r\n} else\r\nerr = (cmd == SIOCADDTUNNEL ? -ENOBUFS : -ENOENT);\r\nbreak;\r\ncase SIOCDELTUNNEL:\r\nerr = -EPERM;\r\nif (!ns_capable(net->user_ns, CAP_NET_ADMIN))\r\nbreak;\r\nif (dev == ip6n->fb_tnl_dev) {\r\nerr = -EFAULT;\r\nif (copy_from_user(&p, ifr->ifr_ifru.ifru_data, sizeof(p)))\r\nbreak;\r\nerr = -ENOENT;\r\nvti6_parm_from_user(&p1, &p);\r\nt = vti6_locate(net, &p1, 0);\r\nif (!t)\r\nbreak;\r\nerr = -EPERM;\r\nif (t->dev == ip6n->fb_tnl_dev)\r\nbreak;\r\ndev = t->dev;\r\n}\r\nerr = 0;\r\nunregister_netdevice(dev);\r\nbreak;\r\ndefault:\r\nerr = -EINVAL;\r\n}\r\nreturn err;\r\n}\r\nstatic int vti6_change_mtu(struct net_device *dev, int new_mtu)\r\n{\r\nif (new_mtu < IPV6_MIN_MTU)\r\nreturn -EINVAL;\r\ndev->mtu = new_mtu;\r\nreturn 0;\r\n}\r\nstatic void vti6_dev_setup(struct net_device *dev)\r\n{\r\ndev->netdev_ops = &vti6_netdev_ops;\r\ndev->destructor = vti6_dev_free;\r\ndev->type = ARPHRD_TUNNEL6;\r\ndev->hard_header_len = LL_MAX_HEADER + sizeof(struct ipv6hdr);\r\ndev->mtu = ETH_DATA_LEN;\r\ndev->flags |= IFF_NOARP;\r\ndev->addr_len = sizeof(struct in6_addr);\r\nnetif_keep_dst(dev);\r\n}\r\nstatic inline int vti6_dev_init_gen(struct net_device *dev)\r\n{\r\nstruct ip6_tnl *t = netdev_priv(dev);\r\nt->dev = dev;\r\nt->net = dev_net(dev);\r\ndev->tstats = netdev_alloc_pcpu_stats(struct pcpu_sw_netstats);\r\nif (!dev->tstats)\r\nreturn -ENOMEM;\r\nreturn 0;\r\n}\r\nstatic int vti6_dev_init(struct net_device *dev)\r\n{\r\nstruct ip6_tnl *t = netdev_priv(dev);\r\nint err = vti6_dev_init_gen(dev);\r\nif (err)\r\nreturn err;\r\nvti6_link_config(t);\r\nreturn 0;\r\n}\r\nstatic int __net_init vti6_fb_tnl_dev_init(struct net_device *dev)\r\n{\r\nstruct ip6_tnl *t = netdev_priv(dev);\r\nstruct net *net = dev_net(dev);\r\nstruct vti6_net *ip6n = net_generic(net, vti6_net_id);\r\nt->parms.proto = IPPROTO_IPV6;\r\ndev_hold(dev);\r\nrcu_assign_pointer(ip6n->tnls_wc[0], t);\r\nreturn 0;\r\n}\r\nstatic int vti6_validate(struct nlattr *tb[], struct nlattr *data[])\r\n{\r\nreturn 0;\r\n}\r\nstatic void vti6_netlink_parms(struct nlattr *data[],\r\nstruct __ip6_tnl_parm *parms)\r\n{\r\nmemset(parms, 0, sizeof(*parms));\r\nif (!data)\r\nreturn;\r\nif (data[IFLA_VTI_LINK])\r\nparms->link = nla_get_u32(data[IFLA_VTI_LINK]);\r\nif (data[IFLA_VTI_LOCAL])\r\nparms->laddr = nla_get_in6_addr(data[IFLA_VTI_LOCAL]);\r\nif (data[IFLA_VTI_REMOTE])\r\nparms->raddr = nla_get_in6_addr(data[IFLA_VTI_REMOTE]);\r\nif (data[IFLA_VTI_IKEY])\r\nparms->i_key = nla_get_be32(data[IFLA_VTI_IKEY]);\r\nif (data[IFLA_VTI_OKEY])\r\nparms->o_key = nla_get_be32(data[IFLA_VTI_OKEY]);\r\n}\r\nstatic int vti6_newlink(struct net *src_net, struct net_device *dev,\r\nstruct nlattr *tb[], struct nlattr *data[])\r\n{\r\nstruct net *net = dev_net(dev);\r\nstruct ip6_tnl *nt;\r\nnt = netdev_priv(dev);\r\nvti6_netlink_parms(data, &nt->parms);\r\nnt->parms.proto = IPPROTO_IPV6;\r\nif (vti6_locate(net, &nt->parms, 0))\r\nreturn -EEXIST;\r\nreturn vti6_tnl_create2(dev);\r\n}\r\nstatic void vti6_dellink(struct net_device *dev, struct list_head *head)\r\n{\r\nstruct net *net = dev_net(dev);\r\nstruct vti6_net *ip6n = net_generic(net, vti6_net_id);\r\nif (dev != ip6n->fb_tnl_dev)\r\nunregister_netdevice_queue(dev, head);\r\n}\r\nstatic int vti6_changelink(struct net_device *dev, struct nlattr *tb[],\r\nstruct nlattr *data[])\r\n{\r\nstruct ip6_tnl *t;\r\nstruct __ip6_tnl_parm p;\r\nstruct net *net = dev_net(dev);\r\nstruct vti6_net *ip6n = net_generic(net, vti6_net_id);\r\nif (dev == ip6n->fb_tnl_dev)\r\nreturn -EINVAL;\r\nvti6_netlink_parms(data, &p);\r\nt = vti6_locate(net, &p, 0);\r\nif (t) {\r\nif (t->dev != dev)\r\nreturn -EEXIST;\r\n} else\r\nt = netdev_priv(dev);\r\nreturn vti6_update(t, &p);\r\n}\r\nstatic size_t vti6_get_size(const struct net_device *dev)\r\n{\r\nreturn\r\nnla_total_size(4) +\r\nnla_total_size(sizeof(struct in6_addr)) +\r\nnla_total_size(sizeof(struct in6_addr)) +\r\nnla_total_size(4) +\r\nnla_total_size(4) +\r\n0;\r\n}\r\nstatic int vti6_fill_info(struct sk_buff *skb, const struct net_device *dev)\r\n{\r\nstruct ip6_tnl *tunnel = netdev_priv(dev);\r\nstruct __ip6_tnl_parm *parm = &tunnel->parms;\r\nif (nla_put_u32(skb, IFLA_VTI_LINK, parm->link) ||\r\nnla_put_in6_addr(skb, IFLA_VTI_LOCAL, &parm->laddr) ||\r\nnla_put_in6_addr(skb, IFLA_VTI_REMOTE, &parm->raddr) ||\r\nnla_put_be32(skb, IFLA_VTI_IKEY, parm->i_key) ||\r\nnla_put_be32(skb, IFLA_VTI_OKEY, parm->o_key))\r\ngoto nla_put_failure;\r\nreturn 0;\r\nnla_put_failure:\r\nreturn -EMSGSIZE;\r\n}\r\nstatic void __net_exit vti6_destroy_tunnels(struct vti6_net *ip6n)\r\n{\r\nint h;\r\nstruct ip6_tnl *t;\r\nLIST_HEAD(list);\r\nfor (h = 0; h < HASH_SIZE; h++) {\r\nt = rtnl_dereference(ip6n->tnls_r_l[h]);\r\nwhile (t) {\r\nunregister_netdevice_queue(t->dev, &list);\r\nt = rtnl_dereference(t->next);\r\n}\r\n}\r\nt = rtnl_dereference(ip6n->tnls_wc[0]);\r\nunregister_netdevice_queue(t->dev, &list);\r\nunregister_netdevice_many(&list);\r\n}\r\nstatic int __net_init vti6_init_net(struct net *net)\r\n{\r\nstruct vti6_net *ip6n = net_generic(net, vti6_net_id);\r\nstruct ip6_tnl *t = NULL;\r\nint err;\r\nip6n->tnls[0] = ip6n->tnls_wc;\r\nip6n->tnls[1] = ip6n->tnls_r_l;\r\nerr = -ENOMEM;\r\nip6n->fb_tnl_dev = alloc_netdev(sizeof(struct ip6_tnl), "ip6_vti0",\r\nNET_NAME_UNKNOWN, vti6_dev_setup);\r\nif (!ip6n->fb_tnl_dev)\r\ngoto err_alloc_dev;\r\ndev_net_set(ip6n->fb_tnl_dev, net);\r\nip6n->fb_tnl_dev->rtnl_link_ops = &vti6_link_ops;\r\nerr = vti6_fb_tnl_dev_init(ip6n->fb_tnl_dev);\r\nif (err < 0)\r\ngoto err_register;\r\nerr = register_netdev(ip6n->fb_tnl_dev);\r\nif (err < 0)\r\ngoto err_register;\r\nt = netdev_priv(ip6n->fb_tnl_dev);\r\nstrcpy(t->parms.name, ip6n->fb_tnl_dev->name);\r\nreturn 0;\r\nerr_register:\r\nvti6_dev_free(ip6n->fb_tnl_dev);\r\nerr_alloc_dev:\r\nreturn err;\r\n}\r\nstatic void __net_exit vti6_exit_net(struct net *net)\r\n{\r\nstruct vti6_net *ip6n = net_generic(net, vti6_net_id);\r\nrtnl_lock();\r\nvti6_destroy_tunnels(ip6n);\r\nrtnl_unlock();\r\n}\r\nstatic int __init vti6_tunnel_init(void)\r\n{\r\nconst char *msg;\r\nint err;\r\nmsg = "tunnel device";\r\nerr = register_pernet_device(&vti6_net_ops);\r\nif (err < 0)\r\ngoto pernet_dev_failed;\r\nmsg = "tunnel protocols";\r\nerr = xfrm6_protocol_register(&vti_esp6_protocol, IPPROTO_ESP);\r\nif (err < 0)\r\ngoto xfrm_proto_esp_failed;\r\nerr = xfrm6_protocol_register(&vti_ah6_protocol, IPPROTO_AH);\r\nif (err < 0)\r\ngoto xfrm_proto_ah_failed;\r\nerr = xfrm6_protocol_register(&vti_ipcomp6_protocol, IPPROTO_COMP);\r\nif (err < 0)\r\ngoto xfrm_proto_comp_failed;\r\nmsg = "netlink interface";\r\nerr = rtnl_link_register(&vti6_link_ops);\r\nif (err < 0)\r\ngoto rtnl_link_failed;\r\nreturn 0;\r\nrtnl_link_failed:\r\nxfrm6_protocol_deregister(&vti_ipcomp6_protocol, IPPROTO_COMP);\r\nxfrm_proto_comp_failed:\r\nxfrm6_protocol_deregister(&vti_ah6_protocol, IPPROTO_AH);\r\nxfrm_proto_ah_failed:\r\nxfrm6_protocol_deregister(&vti_esp6_protocol, IPPROTO_ESP);\r\nxfrm_proto_esp_failed:\r\nunregister_pernet_device(&vti6_net_ops);\r\npernet_dev_failed:\r\npr_err("vti6 init: failed to register %s\n", msg);\r\nreturn err;\r\n}\r\nstatic void __exit vti6_tunnel_cleanup(void)\r\n{\r\nrtnl_link_unregister(&vti6_link_ops);\r\nxfrm6_protocol_deregister(&vti_ipcomp6_protocol, IPPROTO_COMP);\r\nxfrm6_protocol_deregister(&vti_ah6_protocol, IPPROTO_AH);\r\nxfrm6_protocol_deregister(&vti_esp6_protocol, IPPROTO_ESP);\r\nunregister_pernet_device(&vti6_net_ops);\r\n}
