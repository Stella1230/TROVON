static inline void lp5521_wait_opmode_done(void)\r\n{\r\nusleep_range(200, 300);\r\n}\r\nstatic inline void lp5521_wait_enable_done(void)\r\n{\r\nusleep_range(500, 600);\r\n}\r\nstatic void lp5521_set_led_current(struct lp55xx_led *led, u8 led_current)\r\n{\r\nled->led_current = led_current;\r\nlp55xx_write(led->chip, LP5521_REG_LED_CURRENT_BASE + led->chan_nr,\r\nled_current);\r\n}\r\nstatic void lp5521_load_engine(struct lp55xx_chip *chip)\r\n{\r\nenum lp55xx_engine_index idx = chip->engine_idx;\r\nu8 mask[] = {\r\n[LP55XX_ENGINE_1] = LP5521_MODE_R_M,\r\n[LP55XX_ENGINE_2] = LP5521_MODE_G_M,\r\n[LP55XX_ENGINE_3] = LP5521_MODE_B_M,\r\n};\r\nu8 val[] = {\r\n[LP55XX_ENGINE_1] = LP5521_LOAD_R,\r\n[LP55XX_ENGINE_2] = LP5521_LOAD_G,\r\n[LP55XX_ENGINE_3] = LP5521_LOAD_B,\r\n};\r\nlp55xx_update_bits(chip, LP5521_REG_OP_MODE, mask[idx], val[idx]);\r\nlp5521_wait_opmode_done();\r\n}\r\nstatic void lp5521_stop_all_engines(struct lp55xx_chip *chip)\r\n{\r\nlp55xx_write(chip, LP5521_REG_OP_MODE, 0);\r\nlp5521_wait_opmode_done();\r\n}\r\nstatic void lp5521_stop_engine(struct lp55xx_chip *chip)\r\n{\r\nenum lp55xx_engine_index idx = chip->engine_idx;\r\nu8 mask[] = {\r\n[LP55XX_ENGINE_1] = LP5521_MODE_R_M,\r\n[LP55XX_ENGINE_2] = LP5521_MODE_G_M,\r\n[LP55XX_ENGINE_3] = LP5521_MODE_B_M,\r\n};\r\nlp55xx_update_bits(chip, LP5521_REG_OP_MODE, mask[idx], 0);\r\nlp5521_wait_opmode_done();\r\n}\r\nstatic void lp5521_run_engine(struct lp55xx_chip *chip, bool start)\r\n{\r\nint ret;\r\nu8 mode;\r\nu8 exec;\r\nif (!start) {\r\nlp5521_stop_engine(chip);\r\nlp55xx_write(chip, LP5521_REG_OP_MODE, LP5521_CMD_DIRECT);\r\nlp5521_wait_opmode_done();\r\nreturn;\r\n}\r\nret = lp55xx_read(chip, LP5521_REG_OP_MODE, &mode);\r\nif (ret)\r\nreturn;\r\nret = lp55xx_read(chip, LP5521_REG_ENABLE, &exec);\r\nif (ret)\r\nreturn;\r\nif (LP5521_R_IS_LOADING(mode)) {\r\nmode = (mode & ~LP5521_MODE_R_M) | LP5521_RUN_R;\r\nexec = (exec & ~LP5521_EXEC_R_M) | LP5521_RUN_R;\r\n}\r\nif (LP5521_G_IS_LOADING(mode)) {\r\nmode = (mode & ~LP5521_MODE_G_M) | LP5521_RUN_G;\r\nexec = (exec & ~LP5521_EXEC_G_M) | LP5521_RUN_G;\r\n}\r\nif (LP5521_B_IS_LOADING(mode)) {\r\nmode = (mode & ~LP5521_MODE_B_M) | LP5521_RUN_B;\r\nexec = (exec & ~LP5521_EXEC_B_M) | LP5521_RUN_B;\r\n}\r\nlp55xx_write(chip, LP5521_REG_OP_MODE, mode);\r\nlp5521_wait_opmode_done();\r\nlp55xx_update_bits(chip, LP5521_REG_ENABLE, LP5521_EXEC_M, exec);\r\nlp5521_wait_enable_done();\r\n}\r\nstatic int lp5521_update_program_memory(struct lp55xx_chip *chip,\r\nconst u8 *data, size_t size)\r\n{\r\nenum lp55xx_engine_index idx = chip->engine_idx;\r\nu8 pattern[LP5521_PROGRAM_LENGTH] = {0};\r\nu8 addr[] = {\r\n[LP55XX_ENGINE_1] = LP5521_REG_R_PROG_MEM,\r\n[LP55XX_ENGINE_2] = LP5521_REG_G_PROG_MEM,\r\n[LP55XX_ENGINE_3] = LP5521_REG_B_PROG_MEM,\r\n};\r\nunsigned cmd;\r\nchar c[3];\r\nint nrchars;\r\nint ret;\r\nint offset = 0;\r\nint i = 0;\r\nwhile ((offset < size - 1) && (i < LP5521_PROGRAM_LENGTH)) {\r\nret = sscanf(data + offset, "%2s%n ", c, &nrchars);\r\nif (ret != 1)\r\ngoto err;\r\nret = sscanf(c, "%2x", &cmd);\r\nif (ret != 1)\r\ngoto err;\r\npattern[i] = (u8)cmd;\r\noffset += nrchars;\r\ni++;\r\n}\r\nif (i % 2)\r\ngoto err;\r\nfor (i = 0; i < LP5521_PROGRAM_LENGTH; i++) {\r\nret = lp55xx_write(chip, addr[idx] + i, pattern[i]);\r\nif (ret)\r\nreturn -EINVAL;\r\n}\r\nreturn size;\r\nerr:\r\ndev_err(&chip->cl->dev, "wrong pattern format\n");\r\nreturn -EINVAL;\r\n}\r\nstatic void lp5521_firmware_loaded(struct lp55xx_chip *chip)\r\n{\r\nconst struct firmware *fw = chip->fw;\r\nif (fw->size > LP5521_PROGRAM_LENGTH) {\r\ndev_err(&chip->cl->dev, "firmware data size overflow: %zu\n",\r\nfw->size);\r\nreturn;\r\n}\r\nlp5521_load_engine(chip);\r\nlp5521_update_program_memory(chip, fw->data, fw->size);\r\n}\r\nstatic int lp5521_post_init_device(struct lp55xx_chip *chip)\r\n{\r\nint ret;\r\nu8 val;\r\nret = lp55xx_read(chip, LP5521_REG_R_CURRENT, &val);\r\nif (ret) {\r\ndev_err(&chip->cl->dev, "error in resetting chip\n");\r\nreturn ret;\r\n}\r\nif (val != LP5521_REG_R_CURR_DEFAULT) {\r\ndev_err(&chip->cl->dev,\r\n"unexpected data in register (expected 0x%x got 0x%x)\n",\r\nLP5521_REG_R_CURR_DEFAULT, val);\r\nret = -EINVAL;\r\nreturn ret;\r\n}\r\nusleep_range(10000, 20000);\r\nret = lp55xx_write(chip, LP5521_REG_OP_MODE, LP5521_CMD_DIRECT);\r\nval = LP5521_DEFAULT_CFG;\r\nif (!lp55xx_is_extclk_used(chip))\r\nval |= LP5521_CLK_INT;\r\nret = lp55xx_write(chip, LP5521_REG_CONFIG, val);\r\nif (ret)\r\nreturn ret;\r\nlp55xx_write(chip, LP5521_REG_R_PWM, 0);\r\nlp55xx_write(chip, LP5521_REG_G_PWM, 0);\r\nlp55xx_write(chip, LP5521_REG_B_PWM, 0);\r\nret = lp55xx_write(chip, LP5521_REG_ENABLE, LP5521_ENABLE_RUN_PROGRAM);\r\nif (ret)\r\nreturn ret;\r\nlp5521_wait_enable_done();\r\nreturn 0;\r\n}\r\nstatic int lp5521_run_selftest(struct lp55xx_chip *chip, char *buf)\r\n{\r\nstruct lp55xx_platform_data *pdata = chip->pdata;\r\nint ret;\r\nu8 status;\r\nret = lp55xx_read(chip, LP5521_REG_STATUS, &status);\r\nif (ret < 0)\r\nreturn ret;\r\nif (pdata->clock_mode != LP55XX_CLOCK_EXT)\r\nreturn 0;\r\nif ((status & LP5521_EXT_CLK_USED) == 0)\r\nreturn -EIO;\r\nreturn 0;\r\n}\r\nstatic int lp5521_led_brightness(struct lp55xx_led *led)\r\n{\r\nstruct lp55xx_chip *chip = led->chip;\r\nint ret;\r\nmutex_lock(&chip->lock);\r\nret = lp55xx_write(chip, LP5521_REG_LED_PWM_BASE + led->chan_nr,\r\nled->brightness);\r\nmutex_unlock(&chip->lock);\r\nreturn ret;\r\n}\r\nstatic ssize_t show_engine_mode(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf, int nr)\r\n{\r\nstruct lp55xx_led *led = i2c_get_clientdata(to_i2c_client(dev));\r\nstruct lp55xx_chip *chip = led->chip;\r\nenum lp55xx_engine_mode mode = chip->engines[nr - 1].mode;\r\nswitch (mode) {\r\ncase LP55XX_ENGINE_RUN:\r\nreturn sprintf(buf, "run\n");\r\ncase LP55XX_ENGINE_LOAD:\r\nreturn sprintf(buf, "load\n");\r\ncase LP55XX_ENGINE_DISABLED:\r\ndefault:\r\nreturn sprintf(buf, "disabled\n");\r\n}\r\n}\r\nstatic ssize_t store_engine_mode(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t len, int nr)\r\n{\r\nstruct lp55xx_led *led = i2c_get_clientdata(to_i2c_client(dev));\r\nstruct lp55xx_chip *chip = led->chip;\r\nstruct lp55xx_engine *engine = &chip->engines[nr - 1];\r\nmutex_lock(&chip->lock);\r\nchip->engine_idx = nr;\r\nif (!strncmp(buf, "run", 3)) {\r\nlp5521_run_engine(chip, true);\r\nengine->mode = LP55XX_ENGINE_RUN;\r\n} else if (!strncmp(buf, "load", 4)) {\r\nlp5521_stop_engine(chip);\r\nlp5521_load_engine(chip);\r\nengine->mode = LP55XX_ENGINE_LOAD;\r\n} else if (!strncmp(buf, "disabled", 8)) {\r\nlp5521_stop_engine(chip);\r\nengine->mode = LP55XX_ENGINE_DISABLED;\r\n}\r\nmutex_unlock(&chip->lock);\r\nreturn len;\r\n}\r\nstatic ssize_t store_engine_load(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t len, int nr)\r\n{\r\nstruct lp55xx_led *led = i2c_get_clientdata(to_i2c_client(dev));\r\nstruct lp55xx_chip *chip = led->chip;\r\nint ret;\r\nmutex_lock(&chip->lock);\r\nchip->engine_idx = nr;\r\nlp5521_load_engine(chip);\r\nret = lp5521_update_program_memory(chip, buf, len);\r\nmutex_unlock(&chip->lock);\r\nreturn ret;\r\n}\r\nstatic ssize_t lp5521_selftest(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct lp55xx_led *led = i2c_get_clientdata(to_i2c_client(dev));\r\nstruct lp55xx_chip *chip = led->chip;\r\nint ret;\r\nmutex_lock(&chip->lock);\r\nret = lp5521_run_selftest(chip, buf);\r\nmutex_unlock(&chip->lock);\r\nreturn scnprintf(buf, PAGE_SIZE, "%s\n", ret ? "FAIL" : "OK");\r\n}\r\nstatic int lp5521_probe(struct i2c_client *client,\r\nconst struct i2c_device_id *id)\r\n{\r\nint ret;\r\nstruct lp55xx_chip *chip;\r\nstruct lp55xx_led *led;\r\nstruct lp55xx_platform_data *pdata = dev_get_platdata(&client->dev);\r\nstruct device_node *np = client->dev.of_node;\r\nif (!pdata) {\r\nif (np) {\r\npdata = lp55xx_of_populate_pdata(&client->dev, np);\r\nif (IS_ERR(pdata))\r\nreturn PTR_ERR(pdata);\r\n} else {\r\ndev_err(&client->dev, "no platform data\n");\r\nreturn -EINVAL;\r\n}\r\n}\r\nchip = devm_kzalloc(&client->dev, sizeof(*chip), GFP_KERNEL);\r\nif (!chip)\r\nreturn -ENOMEM;\r\nled = devm_kzalloc(&client->dev,\r\nsizeof(*led) * pdata->num_channels, GFP_KERNEL);\r\nif (!led)\r\nreturn -ENOMEM;\r\nchip->cl = client;\r\nchip->pdata = pdata;\r\nchip->cfg = &lp5521_cfg;\r\nmutex_init(&chip->lock);\r\ni2c_set_clientdata(client, led);\r\nret = lp55xx_init_device(chip);\r\nif (ret)\r\ngoto err_init;\r\ndev_info(&client->dev, "%s programmable led chip found\n", id->name);\r\nret = lp55xx_register_leds(led, chip);\r\nif (ret)\r\ngoto err_register_leds;\r\nret = lp55xx_register_sysfs(chip);\r\nif (ret) {\r\ndev_err(&client->dev, "registering sysfs failed\n");\r\ngoto err_register_sysfs;\r\n}\r\nreturn 0;\r\nerr_register_sysfs:\r\nlp55xx_unregister_leds(led, chip);\r\nerr_register_leds:\r\nlp55xx_deinit_device(chip);\r\nerr_init:\r\nreturn ret;\r\n}\r\nstatic int lp5521_remove(struct i2c_client *client)\r\n{\r\nstruct lp55xx_led *led = i2c_get_clientdata(client);\r\nstruct lp55xx_chip *chip = led->chip;\r\nlp5521_stop_all_engines(chip);\r\nlp55xx_unregister_sysfs(chip);\r\nlp55xx_unregister_leds(led, chip);\r\nlp55xx_deinit_device(chip);\r\nreturn 0;\r\n}
