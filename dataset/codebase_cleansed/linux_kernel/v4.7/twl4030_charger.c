static inline int ac_available(struct iio_channel *channel_vac)\r\n{\r\nint val, err;\r\nif (!channel_vac)\r\nreturn 0;\r\nerr = iio_read_channel_processed(channel_vac, &val);\r\nif (err < 0)\r\nreturn 0;\r\nreturn val > 4500;\r\n}\r\nstatic int twl4030_clear_set(u8 mod_no, u8 clear, u8 set, u8 reg)\r\n{\r\nu8 val = 0;\r\nint ret;\r\nret = twl_i2c_read_u8(mod_no, &val, reg);\r\nif (ret)\r\nreturn ret;\r\nval &= ~clear;\r\nval |= set;\r\nreturn twl_i2c_write_u8(mod_no, val, reg);\r\n}\r\nstatic int twl4030_bci_read(u8 reg, u8 *val)\r\n{\r\nreturn twl_i2c_read_u8(TWL_MODULE_MAIN_CHARGE, val, reg);\r\n}\r\nstatic int twl4030_clear_set_boot_bci(u8 clear, u8 set)\r\n{\r\nreturn twl4030_clear_set(TWL_MODULE_PM_MASTER, clear,\r\nTWL4030_CONFIG_DONE | TWL4030_BCIAUTOWEN | set,\r\nTWL4030_PM_MASTER_BOOT_BCI);\r\n}\r\nstatic int twl4030bci_read_adc_val(u8 reg)\r\n{\r\nint ret, temp;\r\nu8 val;\r\nret = twl4030_bci_read(reg + 1, &val);\r\nif (ret)\r\nreturn ret;\r\ntemp = (int)(val & 0x03) << 8;\r\nret = twl4030_bci_read(reg, &val);\r\nif (ret)\r\nreturn ret;\r\nreturn temp | val;\r\n}\r\nstatic int twl4030_is_battery_present(struct twl4030_bci *bci)\r\n{\r\nint ret;\r\nu8 val = 0;\r\nret = twl_i2c_read_u8(TWL_MODULE_MAIN_CHARGE, &val, TWL4030_BCIMFSTS3);\r\nif (ret)\r\nreturn ret;\r\nif (val & TWL4030_BATSTSMCHG)\r\nreturn 0;\r\nret = twl_i2c_read_u8(TWL4030_MODULE_PRECHARGE, &val,\r\nTWL4030_BCIMFSTS1);\r\nif (ret)\r\nreturn ret;\r\nif (val & TWL4030_BATSTSPCHG)\r\nreturn 0;\r\nreturn -ENODEV;\r\n}\r\nstatic int regval2ua(int regval, bool cgain)\r\n{\r\nif (cgain)\r\nreturn (regval * 16618 - 8500 * 1000) / 5;\r\nelse\r\nreturn (regval * 16618 - 8500 * 1000) / 10;\r\n}\r\nstatic int ua2regval(int ua, bool cgain)\r\n{\r\nint ret;\r\nif (cgain)\r\nua /= 2;\r\nret = (ua * 10 + 8500 * 1000) / 16618;\r\nif (ret < 512)\r\nret = 512;\r\nreturn ret;\r\n}\r\nstatic int twl4030_charger_update_current(struct twl4030_bci *bci)\r\n{\r\nint status;\r\nint cur;\r\nunsigned reg, cur_reg;\r\nu8 bcictl1, oldreg, fullreg;\r\nbool cgain = false;\r\nu8 boot_bci;\r\nif (ac_available(bci->channel_vac)) {\r\ncur = bci->ac_cur;\r\nbci->ac_is_active = true;\r\n} else {\r\ncur = bci->usb_cur;\r\nbci->ac_is_active = false;\r\nif (cur > bci->usb_cur_target) {\r\ncur = bci->usb_cur_target;\r\nbci->usb_cur = cur;\r\n}\r\nif (cur < bci->usb_cur_target)\r\nschedule_delayed_work(&bci->current_worker, USB_CUR_DELAY);\r\n}\r\nif (bci->ichg_eoc >= 200000)\r\ncgain = true;\r\nif (bci->ichg_lo >= 400000)\r\ncgain = true;\r\nif (bci->ichg_hi >= 820000)\r\ncgain = true;\r\nif (cur > 852000)\r\ncgain = true;\r\nstatus = twl4030_bci_read(TWL4030_BCICTL1, &bcictl1);\r\nif (status < 0)\r\nreturn status;\r\nif (twl_i2c_read_u8(TWL_MODULE_PM_MASTER, &boot_bci,\r\nTWL4030_PM_MASTER_BOOT_BCI) < 0)\r\nboot_bci = 0;\r\nboot_bci &= 7;\r\nif ((!!cgain) != !!(bcictl1 & TWL4030_CGAIN))\r\ntwl4030_clear_set_boot_bci(boot_bci, 0);\r\nreg = ua2regval(bci->ichg_eoc, cgain);\r\nif (reg > 0x278)\r\nreg = 0x278;\r\nif (reg < 0x200)\r\nreg = 0x200;\r\nreg = (reg >> 3) & 0xf;\r\nfullreg = reg << 4;\r\nreg = ua2regval(bci->ichg_lo, cgain);\r\nif (reg > 0x2F0)\r\nreg = 0x2F0;\r\nif (reg < 0x200)\r\nreg = 0x200;\r\nreg = (reg >> 4) & 0xf;\r\nfullreg |= reg;\r\nstatus = twl4030_bci_read(TWL4030_BCIMFTH8, &oldreg);\r\nif (status < 0)\r\nreturn status;\r\nif (oldreg != fullreg) {\r\nstatus = twl_i2c_write_u8(TWL_MODULE_MAIN_CHARGE, 0xF4,\r\nTWL4030_BCIMFKEY);\r\nif (status < 0)\r\nreturn status;\r\ntwl_i2c_write_u8(TWL_MODULE_MAIN_CHARGE,\r\nfullreg, TWL4030_BCIMFTH8);\r\n}\r\nreg = ua2regval(bci->ichg_hi, cgain);\r\nif (reg > 0x3E0)\r\nreg = 0x3E0;\r\nif (reg < 0x200)\r\nreg = 0x200;\r\nfullreg = (reg >> 5) & 0xF;\r\nfullreg <<= 4;\r\nstatus = twl4030_bci_read(TWL4030_BCIMFTH9, &oldreg);\r\nif (status < 0)\r\nreturn status;\r\nif ((oldreg & 0xF0) != fullreg) {\r\nfullreg |= (oldreg & 0x0F);\r\nstatus = twl_i2c_write_u8(TWL_MODULE_MAIN_CHARGE, 0xE7,\r\nTWL4030_BCIMFKEY);\r\nif (status < 0)\r\nreturn status;\r\ntwl_i2c_write_u8(TWL_MODULE_MAIN_CHARGE,\r\nfullreg, TWL4030_BCIMFTH9);\r\n}\r\nreg = ua2regval(cur, cgain);\r\nif (reg > 0x3ff)\r\nreg = 0x3ff;\r\nstatus = twl4030_bci_read(TWL4030_BCIIREF1, &oldreg);\r\nif (status < 0)\r\nreturn status;\r\ncur_reg = oldreg;\r\nstatus = twl4030_bci_read(TWL4030_BCIIREF2, &oldreg);\r\nif (status < 0)\r\nreturn status;\r\ncur_reg |= oldreg << 8;\r\nif (reg != oldreg) {\r\nstatus = twl_i2c_write_u8(TWL_MODULE_MAIN_CHARGE, 0xE7,\r\nTWL4030_BCIMFKEY);\r\nif (status < 0)\r\nreturn status;\r\nstatus = twl_i2c_write_u8(TWL_MODULE_MAIN_CHARGE,\r\n(reg & 0x100) ? 3 : 2,\r\nTWL4030_BCIIREF2);\r\nif (status < 0)\r\nreturn status;\r\nstatus = twl_i2c_write_u8(TWL_MODULE_MAIN_CHARGE, 0xE7,\r\nTWL4030_BCIMFKEY);\r\nif (status < 0)\r\nreturn status;\r\nstatus = twl_i2c_write_u8(TWL_MODULE_MAIN_CHARGE,\r\nreg & 0xff,\r\nTWL4030_BCIIREF1);\r\n}\r\nif ((!!cgain) != !!(bcictl1 & TWL4030_CGAIN)) {\r\nbcictl1 ^= TWL4030_CGAIN;\r\ntwl_i2c_write_u8(TWL_MODULE_MAIN_CHARGE,\r\nbcictl1, TWL4030_BCICTL1);\r\ntwl4030_clear_set_boot_bci(0, boot_bci);\r\n}\r\nreturn 0;\r\n}\r\nstatic void twl4030_current_worker(struct work_struct *data)\r\n{\r\nint v, curr;\r\nint res;\r\nstruct twl4030_bci *bci = container_of(data, struct twl4030_bci,\r\ncurrent_worker.work);\r\nres = twl4030bci_read_adc_val(TWL4030_BCIVBUS);\r\nif (res < 0)\r\nv = 0;\r\nelse\r\nv = res * 6843;\r\ncurr = twl4030_charger_get_current();\r\ndev_dbg(bci->dev, "v=%d cur=%d limit=%d target=%d\n", v, curr,\r\nbci->usb_cur, bci->usb_cur_target);\r\nif (v < USB_MIN_VOLT) {\r\nbci->usb_cur -= USB_CUR_STEP;\r\nbci->usb_cur_target = bci->usb_cur;\r\n} else if (bci->usb_cur >= bci->usb_cur_target ||\r\nbci->usb_cur + USB_CUR_STEP > USB_MAX_CURRENT) {\r\nreturn;\r\n} else {\r\nbci->usb_cur += USB_CUR_STEP;\r\nschedule_delayed_work(&bci->current_worker, USB_CUR_DELAY);\r\n}\r\ntwl4030_charger_update_current(bci);\r\n}\r\nstatic int twl4030_charger_enable_usb(struct twl4030_bci *bci, bool enable)\r\n{\r\nint ret;\r\nif (bci->usb_mode == CHARGE_OFF)\r\nenable = false;\r\nif (enable && !IS_ERR_OR_NULL(bci->transceiver)) {\r\ntwl4030_charger_update_current(bci);\r\nif (!bci->usb_enabled) {\r\npm_runtime_get_sync(bci->transceiver->dev);\r\nbci->usb_enabled = 1;\r\n}\r\nif (bci->usb_mode == CHARGE_AUTO)\r\nret = twl4030_clear_set_boot_bci(0, TWL4030_BCIAUTOUSB);\r\nret = twl4030_clear_set(TWL_MODULE_MAIN_CHARGE, 0,\r\nTWL4030_USBFASTMCHG, TWL4030_BCIMFSTS4);\r\nif (bci->usb_mode == CHARGE_LINEAR) {\r\ntwl4030_clear_set_boot_bci(TWL4030_BCIAUTOAC|TWL4030_CVENAC, 0);\r\nret = twl_i2c_write_u8(TWL_MODULE_MAIN_CHARGE, 0x33,\r\nTWL4030_BCIWDKEY);\r\nret = twl_i2c_write_u8(TWL_MODULE_MAIN_CHARGE, 0x2a,\r\nTWL4030_BCIMDKEY);\r\nret = twl_i2c_write_u8(TWL_MODULE_MAIN_CHARGE, 0x26,\r\nTWL4030_BCIMDKEY);\r\nret = twl_i2c_write_u8(TWL_MODULE_MAIN_CHARGE, 0xf3,\r\nTWL4030_BCIWDKEY);\r\nret = twl_i2c_write_u8(TWL_MODULE_MAIN_CHARGE, 0x9c,\r\nTWL4030_BCIMFKEY);\r\nret = twl_i2c_write_u8(TWL_MODULE_MAIN_CHARGE, 0xf0,\r\nTWL4030_BCIMFEN3);\r\n}\r\n} else {\r\nret = twl4030_clear_set_boot_bci(TWL4030_BCIAUTOUSB, 0);\r\nret |= twl_i2c_write_u8(TWL_MODULE_MAIN_CHARGE, 0x2a,\r\nTWL4030_BCIMDKEY);\r\nif (bci->usb_enabled) {\r\npm_runtime_mark_last_busy(bci->transceiver->dev);\r\npm_runtime_put_autosuspend(bci->transceiver->dev);\r\nbci->usb_enabled = 0;\r\n}\r\nbci->usb_cur = 0;\r\n}\r\nreturn ret;\r\n}\r\nstatic int twl4030_charger_enable_ac(struct twl4030_bci *bci, bool enable)\r\n{\r\nint ret;\r\nif (bci->ac_mode == CHARGE_OFF)\r\nenable = false;\r\nif (enable)\r\nret = twl4030_clear_set_boot_bci(0, TWL4030_BCIAUTOAC);\r\nelse\r\nret = twl4030_clear_set_boot_bci(TWL4030_BCIAUTOAC, 0);\r\nreturn ret;\r\n}\r\nstatic int twl4030_charger_enable_backup(int uvolt, int uamp)\r\n{\r\nint ret;\r\nu8 flags;\r\nif (uvolt < 2500000 ||\r\nuamp < 25) {\r\nret = twl4030_clear_set(TWL_MODULE_PM_RECEIVER,\r\nTWL4030_BBCHEN, 0, TWL4030_BB_CFG);\r\nreturn ret;\r\n}\r\nflags = TWL4030_BBCHEN;\r\nif (uvolt >= 3200000)\r\nflags |= TWL4030_BBSEL_3V2;\r\nelse if (uvolt >= 3100000)\r\nflags |= TWL4030_BBSEL_3V1;\r\nelse if (uvolt >= 3000000)\r\nflags |= TWL4030_BBSEL_3V0;\r\nelse\r\nflags |= TWL4030_BBSEL_2V5;\r\nif (uamp >= 1000)\r\nflags |= TWL4030_BBISEL_1000uA;\r\nelse if (uamp >= 500)\r\nflags |= TWL4030_BBISEL_500uA;\r\nelse if (uamp >= 150)\r\nflags |= TWL4030_BBISEL_150uA;\r\nelse\r\nflags |= TWL4030_BBISEL_25uA;\r\nret = twl4030_clear_set(TWL_MODULE_PM_RECEIVER,\r\nTWL4030_BBSEL_MASK | TWL4030_BBISEL_MASK,\r\nflags,\r\nTWL4030_BB_CFG);\r\nreturn ret;\r\n}\r\nstatic irqreturn_t twl4030_charger_interrupt(int irq, void *arg)\r\n{\r\nstruct twl4030_bci *bci = arg;\r\ndev_dbg(bci->dev, "CHG_PRES irq\n");\r\nbci->ac_cur = 500000;\r\ntwl4030_charger_update_current(bci);\r\npower_supply_changed(bci->ac);\r\npower_supply_changed(bci->usb);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic irqreturn_t twl4030_bci_interrupt(int irq, void *arg)\r\n{\r\nstruct twl4030_bci *bci = arg;\r\nu8 irqs1, irqs2;\r\nint ret;\r\nret = twl_i2c_read_u8(TWL4030_MODULE_INTERRUPTS, &irqs1,\r\nTWL4030_INTERRUPTS_BCIISR1A);\r\nif (ret < 0)\r\nreturn IRQ_HANDLED;\r\nret = twl_i2c_read_u8(TWL4030_MODULE_INTERRUPTS, &irqs2,\r\nTWL4030_INTERRUPTS_BCIISR2A);\r\nif (ret < 0)\r\nreturn IRQ_HANDLED;\r\ndev_dbg(bci->dev, "BCI irq %02x %02x\n", irqs2, irqs1);\r\nif (irqs1 & (TWL4030_ICHGLOW | TWL4030_ICHGEOC)) {\r\npower_supply_changed(bci->ac);\r\npower_supply_changed(bci->usb);\r\n}\r\ntwl4030_charger_update_current(bci);\r\nif (irqs1 & (TWL4030_TBATOR2 | TWL4030_TBATOR1))\r\ndev_warn(bci->dev, "battery temperature out of range\n");\r\nif (irqs1 & TWL4030_BATSTS)\r\ndev_crit(bci->dev, "battery disconnected\n");\r\nif (irqs2 & TWL4030_VBATOV)\r\ndev_crit(bci->dev, "VBAT overvoltage\n");\r\nif (irqs2 & TWL4030_VBUSOV)\r\ndev_crit(bci->dev, "VBUS overvoltage\n");\r\nif (irqs2 & TWL4030_ACCHGOV)\r\ndev_crit(bci->dev, "Ac charger overvoltage\n");\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic ssize_t\r\ntwl4030_bci_max_current_store(struct device *dev, struct device_attribute *attr,\r\nconst char *buf, size_t n)\r\n{\r\nstruct twl4030_bci *bci = dev_get_drvdata(dev->parent);\r\nint cur = 0;\r\nint status = 0;\r\nstatus = kstrtoint(buf, 10, &cur);\r\nif (status)\r\nreturn status;\r\nif (cur < 0)\r\nreturn -EINVAL;\r\nif (dev == &bci->ac->dev)\r\nbci->ac_cur = cur;\r\nelse\r\nbci->usb_cur_target = cur;\r\ntwl4030_charger_update_current(bci);\r\nreturn n;\r\n}\r\nstatic ssize_t twl4030_bci_max_current_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nint status = 0;\r\nint cur = -1;\r\nu8 bcictl1;\r\nstruct twl4030_bci *bci = dev_get_drvdata(dev->parent);\r\nif (dev == &bci->ac->dev) {\r\nif (!bci->ac_is_active)\r\ncur = bci->ac_cur;\r\n} else {\r\nif (bci->ac_is_active)\r\ncur = bci->usb_cur_target;\r\n}\r\nif (cur < 0) {\r\ncur = twl4030bci_read_adc_val(TWL4030_BCIIREF1);\r\nif (cur < 0)\r\nreturn cur;\r\nstatus = twl4030_bci_read(TWL4030_BCICTL1, &bcictl1);\r\nif (status < 0)\r\nreturn status;\r\ncur = regval2ua(cur, bcictl1 & TWL4030_CGAIN);\r\n}\r\nreturn scnprintf(buf, PAGE_SIZE, "%u\n", cur);\r\n}\r\nstatic void twl4030_bci_usb_work(struct work_struct *data)\r\n{\r\nstruct twl4030_bci *bci = container_of(data, struct twl4030_bci, work);\r\nswitch (bci->event) {\r\ncase USB_EVENT_VBUS:\r\ncase USB_EVENT_CHARGER:\r\ntwl4030_charger_enable_usb(bci, true);\r\nbreak;\r\ncase USB_EVENT_NONE:\r\ntwl4030_charger_enable_usb(bci, false);\r\nbreak;\r\n}\r\n}\r\nstatic int twl4030_bci_usb_ncb(struct notifier_block *nb, unsigned long val,\r\nvoid *priv)\r\n{\r\nstruct twl4030_bci *bci = container_of(nb, struct twl4030_bci, usb_nb);\r\ndev_dbg(bci->dev, "OTG notify %lu\n", val);\r\nif (allow_usb)\r\nbci->usb_cur_target = 500000;\r\nelse\r\nbci->usb_cur_target = 100000;\r\nbci->event = val;\r\nschedule_work(&bci->work);\r\nreturn NOTIFY_OK;\r\n}\r\nstatic ssize_t\r\ntwl4030_bci_mode_store(struct device *dev, struct device_attribute *attr,\r\nconst char *buf, size_t n)\r\n{\r\nstruct twl4030_bci *bci = dev_get_drvdata(dev->parent);\r\nint mode;\r\nint status;\r\nif (sysfs_streq(buf, modes[0]))\r\nmode = 0;\r\nelse if (sysfs_streq(buf, modes[1]))\r\nmode = 1;\r\nelse if (sysfs_streq(buf, modes[2]))\r\nmode = 2;\r\nelse\r\nreturn -EINVAL;\r\nif (dev == &bci->ac->dev) {\r\nif (mode == 2)\r\nreturn -EINVAL;\r\ntwl4030_charger_enable_ac(bci, false);\r\nbci->ac_mode = mode;\r\nstatus = twl4030_charger_enable_ac(bci, true);\r\n} else {\r\ntwl4030_charger_enable_usb(bci, false);\r\nbci->usb_mode = mode;\r\nstatus = twl4030_charger_enable_usb(bci, true);\r\n}\r\nreturn (status == 0) ? n : status;\r\n}\r\nstatic ssize_t\r\ntwl4030_bci_mode_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct twl4030_bci *bci = dev_get_drvdata(dev->parent);\r\nint len = 0;\r\nint i;\r\nint mode = bci->usb_mode;\r\nif (dev == &bci->ac->dev)\r\nmode = bci->ac_mode;\r\nfor (i = 0; i < ARRAY_SIZE(modes); i++)\r\nif (mode == i)\r\nlen += snprintf(buf+len, PAGE_SIZE-len,\r\n"[%s] ", modes[i]);\r\nelse\r\nlen += snprintf(buf+len, PAGE_SIZE-len,\r\n"%s ", modes[i]);\r\nbuf[len-1] = '\n';\r\nreturn len;\r\n}\r\nstatic int twl4030_charger_get_current(void)\r\n{\r\nint curr;\r\nint ret;\r\nu8 bcictl1;\r\ncurr = twl4030bci_read_adc_val(TWL4030_BCIICHG);\r\nif (curr < 0)\r\nreturn curr;\r\nret = twl4030_bci_read(TWL4030_BCICTL1, &bcictl1);\r\nif (ret)\r\nreturn ret;\r\nreturn regval2ua(curr, bcictl1 & TWL4030_CGAIN);\r\n}\r\nstatic int twl4030bci_state(struct twl4030_bci *bci)\r\n{\r\nint ret;\r\nu8 state;\r\nret = twl4030_bci_read(TWL4030_BCIMSTATEC, &state);\r\nif (ret) {\r\npr_err("twl4030_bci: error reading BCIMSTATEC\n");\r\nreturn ret;\r\n}\r\ndev_dbg(bci->dev, "state: %02x\n", state);\r\nreturn state;\r\n}\r\nstatic int twl4030_bci_state_to_status(int state)\r\n{\r\nstate &= TWL4030_MSTATEC_MASK;\r\nif (TWL4030_MSTATEC_QUICK1 <= state && state <= TWL4030_MSTATEC_QUICK7)\r\nreturn POWER_SUPPLY_STATUS_CHARGING;\r\nelse if (TWL4030_MSTATEC_COMPLETE1 <= state &&\r\nstate <= TWL4030_MSTATEC_COMPLETE4)\r\nreturn POWER_SUPPLY_STATUS_FULL;\r\nelse\r\nreturn POWER_SUPPLY_STATUS_NOT_CHARGING;\r\n}\r\nstatic int twl4030_bci_get_property(struct power_supply *psy,\r\nenum power_supply_property psp,\r\nunion power_supply_propval *val)\r\n{\r\nstruct twl4030_bci *bci = dev_get_drvdata(psy->dev.parent);\r\nint is_charging;\r\nint state;\r\nint ret;\r\nstate = twl4030bci_state(bci);\r\nif (state < 0)\r\nreturn state;\r\nif (psy->desc->type == POWER_SUPPLY_TYPE_USB)\r\nis_charging = state & TWL4030_MSTATEC_USB;\r\nelse\r\nis_charging = state & TWL4030_MSTATEC_AC;\r\nif (!is_charging) {\r\nu8 s;\r\ntwl4030_bci_read(TWL4030_BCIMDEN, &s);\r\nif (psy->desc->type == POWER_SUPPLY_TYPE_USB)\r\nis_charging = s & 1;\r\nelse\r\nis_charging = s & 2;\r\nif (is_charging)\r\nstate = TWL4030_MSTATEC_QUICK1;\r\n}\r\nswitch (psp) {\r\ncase POWER_SUPPLY_PROP_STATUS:\r\nif (is_charging)\r\nval->intval = twl4030_bci_state_to_status(state);\r\nelse\r\nval->intval = POWER_SUPPLY_STATUS_NOT_CHARGING;\r\nbreak;\r\ncase POWER_SUPPLY_PROP_VOLTAGE_NOW:\r\nif (!is_charging)\r\nreturn -ENODATA;\r\nif (psy->desc->type == POWER_SUPPLY_TYPE_USB) {\r\nret = twl4030bci_read_adc_val(TWL4030_BCIVBUS);\r\nif (ret < 0)\r\nreturn ret;\r\nval->intval = ret * 6843;\r\n} else {\r\nret = twl4030bci_read_adc_val(TWL4030_BCIVAC);\r\nif (ret < 0)\r\nreturn ret;\r\nval->intval = ret * 9775;\r\n}\r\nbreak;\r\ncase POWER_SUPPLY_PROP_CURRENT_NOW:\r\nif (!is_charging)\r\nreturn -ENODATA;\r\nret = twl4030_charger_get_current();\r\nif (ret < 0)\r\nreturn ret;\r\nval->intval = ret;\r\nbreak;\r\ncase POWER_SUPPLY_PROP_ONLINE:\r\nval->intval = is_charging &&\r\ntwl4030_bci_state_to_status(state) !=\r\nPOWER_SUPPLY_STATUS_NOT_CHARGING;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic const struct twl4030_bci_platform_data *\r\ntwl4030_bci_parse_dt(struct device *dev)\r\n{\r\nstruct device_node *np = dev->of_node;\r\nstruct twl4030_bci_platform_data *pdata;\r\nu32 num;\r\nif (!np)\r\nreturn NULL;\r\npdata = devm_kzalloc(dev, sizeof(*pdata), GFP_KERNEL);\r\nif (!pdata)\r\nreturn pdata;\r\nif (of_property_read_u32(np, "ti,bb-uvolt", &num) == 0)\r\npdata->bb_uvolt = num;\r\nif (of_property_read_u32(np, "ti,bb-uamp", &num) == 0)\r\npdata->bb_uamp = num;\r\nreturn pdata;\r\n}\r\nstatic inline const struct twl4030_bci_platform_data *\r\ntwl4030_bci_parse_dt(struct device *dev)\r\n{\r\nreturn NULL;\r\n}\r\nstatic int twl4030_bci_probe(struct platform_device *pdev)\r\n{\r\nstruct twl4030_bci *bci;\r\nconst struct twl4030_bci_platform_data *pdata = pdev->dev.platform_data;\r\nint ret;\r\nu32 reg;\r\nbci = devm_kzalloc(&pdev->dev, sizeof(*bci), GFP_KERNEL);\r\nif (bci == NULL)\r\nreturn -ENOMEM;\r\nif (!pdata)\r\npdata = twl4030_bci_parse_dt(&pdev->dev);\r\nbci->ichg_eoc = 80100;\r\nbci->ichg_lo = 241000;\r\nbci->ichg_hi = 500000;\r\nbci->ac_cur = 500000;\r\nif (allow_usb)\r\nbci->usb_cur_target = 500000;\r\nelse\r\nbci->usb_cur_target = 100000;\r\nbci->usb_mode = CHARGE_AUTO;\r\nbci->ac_mode = CHARGE_AUTO;\r\nbci->dev = &pdev->dev;\r\nbci->irq_chg = platform_get_irq(pdev, 0);\r\nbci->irq_bci = platform_get_irq(pdev, 1);\r\nret = twl4030_is_battery_present(bci);\r\nif (ret) {\r\ndev_crit(&pdev->dev, "Battery was not detected:%d\n", ret);\r\nreturn ret;\r\n}\r\nplatform_set_drvdata(pdev, bci);\r\nbci->ac = devm_power_supply_register(&pdev->dev, &twl4030_bci_ac_desc,\r\nNULL);\r\nif (IS_ERR(bci->ac)) {\r\nret = PTR_ERR(bci->ac);\r\ndev_err(&pdev->dev, "failed to register ac: %d\n", ret);\r\nreturn ret;\r\n}\r\nbci->usb = devm_power_supply_register(&pdev->dev, &twl4030_bci_usb_desc,\r\nNULL);\r\nif (IS_ERR(bci->usb)) {\r\nret = PTR_ERR(bci->usb);\r\ndev_err(&pdev->dev, "failed to register usb: %d\n", ret);\r\nreturn ret;\r\n}\r\nret = devm_request_threaded_irq(&pdev->dev, bci->irq_chg, NULL,\r\ntwl4030_charger_interrupt, IRQF_ONESHOT, pdev->name,\r\nbci);\r\nif (ret < 0) {\r\ndev_err(&pdev->dev, "could not request irq %d, status %d\n",\r\nbci->irq_chg, ret);\r\nreturn ret;\r\n}\r\nret = devm_request_threaded_irq(&pdev->dev, bci->irq_bci, NULL,\r\ntwl4030_bci_interrupt, IRQF_ONESHOT, pdev->name, bci);\r\nif (ret < 0) {\r\ndev_err(&pdev->dev, "could not request irq %d, status %d\n",\r\nbci->irq_bci, ret);\r\nreturn ret;\r\n}\r\nbci->channel_vac = iio_channel_get(&pdev->dev, "vac");\r\nif (IS_ERR(bci->channel_vac)) {\r\nbci->channel_vac = NULL;\r\ndev_warn(&pdev->dev, "could not request vac iio channel");\r\n}\r\nINIT_WORK(&bci->work, twl4030_bci_usb_work);\r\nINIT_DELAYED_WORK(&bci->current_worker, twl4030_current_worker);\r\nbci->usb_nb.notifier_call = twl4030_bci_usb_ncb;\r\nif (bci->dev->of_node) {\r\nstruct device_node *phynode;\r\nphynode = of_find_compatible_node(bci->dev->of_node->parent,\r\nNULL, "ti,twl4030-usb");\r\nif (phynode)\r\nbci->transceiver = devm_usb_get_phy_by_node(\r\nbci->dev, phynode, &bci->usb_nb);\r\n}\r\nreg = ~(u32)(TWL4030_ICHGLOW | TWL4030_ICHGEOC | TWL4030_TBATOR2 |\r\nTWL4030_TBATOR1 | TWL4030_BATSTS);\r\nret = twl_i2c_write_u8(TWL4030_MODULE_INTERRUPTS, reg,\r\nTWL4030_INTERRUPTS_BCIIMR1A);\r\nif (ret < 0) {\r\ndev_err(&pdev->dev, "failed to unmask interrupts: %d\n", ret);\r\ngoto fail;\r\n}\r\nreg = ~(u32)(TWL4030_VBATOV | TWL4030_VBUSOV | TWL4030_ACCHGOV);\r\nret = twl_i2c_write_u8(TWL4030_MODULE_INTERRUPTS, reg,\r\nTWL4030_INTERRUPTS_BCIIMR2A);\r\nif (ret < 0)\r\ndev_warn(&pdev->dev, "failed to unmask interrupts: %d\n", ret);\r\ntwl4030_charger_update_current(bci);\r\nif (device_create_file(&bci->usb->dev, &dev_attr_max_current))\r\ndev_warn(&pdev->dev, "could not create sysfs file\n");\r\nif (device_create_file(&bci->usb->dev, &dev_attr_mode))\r\ndev_warn(&pdev->dev, "could not create sysfs file\n");\r\nif (device_create_file(&bci->ac->dev, &dev_attr_mode))\r\ndev_warn(&pdev->dev, "could not create sysfs file\n");\r\nif (device_create_file(&bci->ac->dev, &dev_attr_max_current))\r\ndev_warn(&pdev->dev, "could not create sysfs file\n");\r\ntwl4030_charger_enable_ac(bci, true);\r\nif (!IS_ERR_OR_NULL(bci->transceiver))\r\ntwl4030_bci_usb_ncb(&bci->usb_nb,\r\nbci->transceiver->last_event,\r\nNULL);\r\nelse\r\ntwl4030_charger_enable_usb(bci, false);\r\nif (pdata)\r\ntwl4030_charger_enable_backup(pdata->bb_uvolt,\r\npdata->bb_uamp);\r\nelse\r\ntwl4030_charger_enable_backup(0, 0);\r\nreturn 0;\r\nfail:\r\niio_channel_release(bci->channel_vac);\r\nreturn ret;\r\n}\r\nstatic int __exit twl4030_bci_remove(struct platform_device *pdev)\r\n{\r\nstruct twl4030_bci *bci = platform_get_drvdata(pdev);\r\ntwl4030_charger_enable_ac(bci, false);\r\ntwl4030_charger_enable_usb(bci, false);\r\ntwl4030_charger_enable_backup(0, 0);\r\niio_channel_release(bci->channel_vac);\r\ndevice_remove_file(&bci->usb->dev, &dev_attr_max_current);\r\ndevice_remove_file(&bci->usb->dev, &dev_attr_mode);\r\ndevice_remove_file(&bci->ac->dev, &dev_attr_max_current);\r\ndevice_remove_file(&bci->ac->dev, &dev_attr_mode);\r\ntwl_i2c_write_u8(TWL4030_MODULE_INTERRUPTS, 0xff,\r\nTWL4030_INTERRUPTS_BCIIMR1A);\r\ntwl_i2c_write_u8(TWL4030_MODULE_INTERRUPTS, 0xff,\r\nTWL4030_INTERRUPTS_BCIIMR2A);\r\nreturn 0;\r\n}
