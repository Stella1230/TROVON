static void bcm47xxpart_add_part(struct mtd_partition *part, const char *name,\r\nu64 offset, uint32_t mask_flags)\r\n{\r\npart->name = name;\r\npart->offset = offset;\r\npart->mask_flags = mask_flags;\r\n}\r\nstatic const char *bcm47xxpart_trx_data_part_name(struct mtd_info *master,\r\nsize_t offset)\r\n{\r\nuint32_t buf;\r\nsize_t bytes_read;\r\nint err;\r\nerr = mtd_read(master, offset, sizeof(buf), &bytes_read,\r\n(uint8_t *)&buf);\r\nif (err && !mtd_is_bitflip(err)) {\r\npr_err("mtd_read error while parsing (offset: 0x%X): %d\n",\r\noffset, err);\r\ngoto out_default;\r\n}\r\nif (buf == UBI_EC_MAGIC)\r\nreturn "ubi";\r\nout_default:\r\nreturn "rootfs";\r\n}\r\nstatic int bcm47xxpart_parse(struct mtd_info *master,\r\nconst struct mtd_partition **pparts,\r\nstruct mtd_part_parser_data *data)\r\n{\r\nstruct mtd_partition *parts;\r\nuint8_t i, curr_part = 0;\r\nuint32_t *buf;\r\nsize_t bytes_read;\r\nuint32_t offset;\r\nuint32_t blocksize = master->erasesize;\r\nstruct trx_header *trx;\r\nint trx_part = -1;\r\nint last_trx_part = -1;\r\nint possible_nvram_sizes[] = { 0x8000, 0xF000, 0x10000, };\r\nint err;\r\nif (blocksize < 0x1000)\r\nblocksize = 0x1000;\r\nparts = kzalloc(sizeof(struct mtd_partition) * BCM47XXPART_MAX_PARTS,\r\nGFP_KERNEL);\r\nif (!parts)\r\nreturn -ENOMEM;\r\nbuf = kzalloc(BCM47XXPART_BYTES_TO_READ, GFP_KERNEL);\r\nif (!buf) {\r\nkfree(parts);\r\nreturn -ENOMEM;\r\n}\r\nfor (offset = 0; offset <= master->size - blocksize;\r\noffset += blocksize) {\r\nif (config_enabled(CONFIG_BCM47XX) && offset >= 0x2000000)\r\nbreak;\r\nif (curr_part >= BCM47XXPART_MAX_PARTS) {\r\npr_warn("Reached maximum number of partitions, scanning stopped!\n");\r\nbreak;\r\n}\r\nerr = mtd_read(master, offset, BCM47XXPART_BYTES_TO_READ,\r\n&bytes_read, (uint8_t *)buf);\r\nif (err && !mtd_is_bitflip(err)) {\r\npr_err("mtd_read error while parsing (offset: 0x%X): %d\n",\r\noffset, err);\r\ncontinue;\r\n}\r\nif ((buf[0x4e0 / 4] == CFE_MAGIC && buf[0x4e4 / 4] == CFE_MAGIC) ||\r\n(buf[0x400 / 4] == NVRAM_HEADER)) {\r\nbcm47xxpart_add_part(&parts[curr_part++], "boot",\r\noffset, MTD_WRITEABLE);\r\ncontinue;\r\n}\r\nif (buf[0x100 / 4] == BOARD_DATA_MAGIC) {\r\nbcm47xxpart_add_part(&parts[curr_part++], "board_data",\r\noffset, MTD_WRITEABLE);\r\ncontinue;\r\n}\r\nif (buf[0x000 / 4] == FACTORY_MAGIC) {\r\nbcm47xxpart_add_part(&parts[curr_part++], "factory",\r\noffset, MTD_WRITEABLE);\r\ncontinue;\r\n}\r\nif (buf[0x000 / 4] == POT_MAGIC1 &&\r\n(buf[0x004 / 4] & 0xFFFF) == POT_MAGIC2) {\r\nbcm47xxpart_add_part(&parts[curr_part++], "POT", offset,\r\nMTD_WRITEABLE);\r\ncontinue;\r\n}\r\nif (buf[0x010 / 4] == ML_MAGIC1 &&\r\nbuf[0x014 / 4] == ML_MAGIC2) {\r\nbcm47xxpart_add_part(&parts[curr_part++], "ML", offset,\r\nMTD_WRITEABLE);\r\ncontinue;\r\n}\r\nif (buf[0x000 / 4] == TRX_MAGIC) {\r\nif (BCM47XXPART_MAX_PARTS - curr_part < 4) {\r\npr_warn("Not enough partitions left to register trx, scanning stopped!\n");\r\nbreak;\r\n}\r\ntrx = (struct trx_header *)buf;\r\ntrx_part = curr_part;\r\nbcm47xxpart_add_part(&parts[curr_part++], "firmware",\r\noffset, 0);\r\ni = 0;\r\nif (trx->offset[2]) {\r\nbcm47xxpart_add_part(&parts[curr_part++],\r\n"loader",\r\noffset + trx->offset[i],\r\n0);\r\ni++;\r\n}\r\nif (trx->offset[i]) {\r\nbcm47xxpart_add_part(&parts[curr_part++],\r\n"linux",\r\noffset + trx->offset[i],\r\n0);\r\ni++;\r\n}\r\nif (trx->offset[i]) {\r\nconst char *name;\r\nname = bcm47xxpart_trx_data_part_name(master, offset + trx->offset[i]);\r\nbcm47xxpart_add_part(&parts[curr_part++],\r\nname,\r\noffset + trx->offset[i],\r\n0);\r\ni++;\r\n}\r\nlast_trx_part = curr_part - 1;\r\noffset = rounddown(offset + trx->length, blocksize);\r\ncontinue;\r\n}\r\nif (le32_to_cpu(buf[0x000 / 4]) == SQUASHFS_MAGIC ||\r\nbuf[0x000 / 4] == SHSQ_MAGIC) {\r\nbcm47xxpart_add_part(&parts[curr_part++], "rootfs",\r\noffset, 0);\r\ncontinue;\r\n}\r\nif (offset != master->size - blocksize &&\r\nbuf[0x000 / 4] == NVRAM_HEADER) {\r\nbcm47xxpart_add_part(&parts[curr_part++], "nvram",\r\noffset, 0);\r\ncontinue;\r\n}\r\nerr = mtd_read(master, offset + 0x8000, 0x4, &bytes_read,\r\n(uint8_t *)buf);\r\nif (err && !mtd_is_bitflip(err)) {\r\npr_err("mtd_read error while parsing (offset: 0x%X): %d\n",\r\noffset, err);\r\ncontinue;\r\n}\r\nif (buf[0x000 / 4] == BOARD_DATA_MAGIC2) {\r\nbcm47xxpart_add_part(&parts[curr_part++], "board_data",\r\noffset, MTD_WRITEABLE);\r\ncontinue;\r\n}\r\n}\r\nfor (i = 0; i < ARRAY_SIZE(possible_nvram_sizes); i++) {\r\nif (curr_part >= BCM47XXPART_MAX_PARTS) {\r\npr_warn("Reached maximum number of partitions, scanning stopped!\n");\r\nbreak;\r\n}\r\noffset = master->size - possible_nvram_sizes[i];\r\nerr = mtd_read(master, offset, 0x4, &bytes_read,\r\n(uint8_t *)buf);\r\nif (err && !mtd_is_bitflip(err)) {\r\npr_err("mtd_read error while reading (offset 0x%X): %d\n",\r\noffset, err);\r\ncontinue;\r\n}\r\nif (buf[0] == NVRAM_HEADER) {\r\nbcm47xxpart_add_part(&parts[curr_part++], "nvram",\r\nmaster->size - blocksize, 0);\r\nbreak;\r\n}\r\n}\r\nkfree(buf);\r\nfor (i = 0; i < curr_part; i++) {\r\nu64 next_part_offset = (i < curr_part - 1) ?\r\nparts[i + 1].offset : master->size;\r\nparts[i].size = next_part_offset - parts[i].offset;\r\nif (i == last_trx_part && trx_part >= 0)\r\nparts[trx_part].size = next_part_offset -\r\nparts[trx_part].offset;\r\n}\r\n*pparts = parts;\r\nreturn curr_part;\r\n}
