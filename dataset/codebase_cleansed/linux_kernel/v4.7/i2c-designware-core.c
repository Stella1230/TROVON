static u32 dw_readl(struct dw_i2c_dev *dev, int offset)\r\n{\r\nu32 value;\r\nif (dev->accessor_flags & ACCESS_16BIT)\r\nvalue = readw_relaxed(dev->base + offset) |\r\n(readw_relaxed(dev->base + offset + 2) << 16);\r\nelse\r\nvalue = readl_relaxed(dev->base + offset);\r\nif (dev->accessor_flags & ACCESS_SWAP)\r\nreturn swab32(value);\r\nelse\r\nreturn value;\r\n}\r\nstatic void dw_writel(struct dw_i2c_dev *dev, u32 b, int offset)\r\n{\r\nif (dev->accessor_flags & ACCESS_SWAP)\r\nb = swab32(b);\r\nif (dev->accessor_flags & ACCESS_16BIT) {\r\nwritew_relaxed((u16)b, dev->base + offset);\r\nwritew_relaxed((u16)(b >> 16), dev->base + offset + 2);\r\n} else {\r\nwritel_relaxed(b, dev->base + offset);\r\n}\r\n}\r\nstatic u32\r\ni2c_dw_scl_hcnt(u32 ic_clk, u32 tSYMBOL, u32 tf, int cond, int offset)\r\n{\r\nif (cond)\r\nreturn (ic_clk * tSYMBOL + 500000) / 1000000 - 8 + offset;\r\nelse\r\nreturn (ic_clk * (tSYMBOL + tf) + 500000) / 1000000\r\n- 3 + offset;\r\n}\r\nstatic u32 i2c_dw_scl_lcnt(u32 ic_clk, u32 tLOW, u32 tf, int offset)\r\n{\r\nreturn ((ic_clk * (tLOW + tf) + 500000) / 1000000) - 1 + offset;\r\n}\r\nstatic void __i2c_dw_enable(struct dw_i2c_dev *dev, bool enable)\r\n{\r\nint timeout = 100;\r\ndo {\r\ndw_writel(dev, enable, DW_IC_ENABLE);\r\nif ((dw_readl(dev, DW_IC_ENABLE_STATUS) & 1) == enable)\r\nreturn;\r\nusleep_range(25, 250);\r\n} while (timeout--);\r\ndev_warn(dev->dev, "timeout in %sabling adapter\n",\r\nenable ? "en" : "dis");\r\n}\r\nstatic unsigned long i2c_dw_clk_rate(struct dw_i2c_dev *dev)\r\n{\r\nif (WARN_ON_ONCE(!dev->get_clk_rate_khz))\r\nreturn 0;\r\nreturn dev->get_clk_rate_khz(dev);\r\n}\r\nint i2c_dw_init(struct dw_i2c_dev *dev)\r\n{\r\nu32 hcnt, lcnt;\r\nu32 reg;\r\nu32 sda_falling_time, scl_falling_time;\r\nint ret;\r\nif (dev->acquire_lock) {\r\nret = dev->acquire_lock(dev);\r\nif (ret) {\r\ndev_err(dev->dev, "couldn't acquire bus ownership\n");\r\nreturn ret;\r\n}\r\n}\r\nreg = dw_readl(dev, DW_IC_COMP_TYPE);\r\nif (reg == ___constant_swab32(DW_IC_COMP_TYPE_VALUE)) {\r\ndev->accessor_flags |= ACCESS_SWAP;\r\n} else if (reg == (DW_IC_COMP_TYPE_VALUE & 0x0000ffff)) {\r\ndev->accessor_flags |= ACCESS_16BIT;\r\n} else if (reg != DW_IC_COMP_TYPE_VALUE) {\r\ndev_err(dev->dev, "Unknown Synopsys component type: "\r\n"0x%08x\n", reg);\r\nif (dev->release_lock)\r\ndev->release_lock(dev);\r\nreturn -ENODEV;\r\n}\r\n__i2c_dw_enable(dev, false);\r\nsda_falling_time = dev->sda_falling_time ?: 300;\r\nscl_falling_time = dev->scl_falling_time ?: 300;\r\nif (dev->ss_hcnt && dev->ss_lcnt) {\r\nhcnt = dev->ss_hcnt;\r\nlcnt = dev->ss_lcnt;\r\n} else {\r\nhcnt = i2c_dw_scl_hcnt(i2c_dw_clk_rate(dev),\r\n4000,\r\nsda_falling_time,\r\n0,\r\n0);\r\nlcnt = i2c_dw_scl_lcnt(i2c_dw_clk_rate(dev),\r\n4700,\r\nscl_falling_time,\r\n0);\r\n}\r\ndw_writel(dev, hcnt, DW_IC_SS_SCL_HCNT);\r\ndw_writel(dev, lcnt, DW_IC_SS_SCL_LCNT);\r\ndev_dbg(dev->dev, "Standard-mode HCNT:LCNT = %d:%d\n", hcnt, lcnt);\r\nif (dev->fs_hcnt && dev->fs_lcnt) {\r\nhcnt = dev->fs_hcnt;\r\nlcnt = dev->fs_lcnt;\r\n} else {\r\nhcnt = i2c_dw_scl_hcnt(i2c_dw_clk_rate(dev),\r\n600,\r\nsda_falling_time,\r\n0,\r\n0);\r\nlcnt = i2c_dw_scl_lcnt(i2c_dw_clk_rate(dev),\r\n1300,\r\nscl_falling_time,\r\n0);\r\n}\r\ndw_writel(dev, hcnt, DW_IC_FS_SCL_HCNT);\r\ndw_writel(dev, lcnt, DW_IC_FS_SCL_LCNT);\r\ndev_dbg(dev->dev, "Fast-mode HCNT:LCNT = %d:%d\n", hcnt, lcnt);\r\nif (dev->sda_hold_time) {\r\nreg = dw_readl(dev, DW_IC_COMP_VERSION);\r\nif (reg >= DW_IC_SDA_HOLD_MIN_VERS)\r\ndw_writel(dev, dev->sda_hold_time, DW_IC_SDA_HOLD);\r\nelse\r\ndev_warn(dev->dev,\r\n"Hardware too old to adjust SDA hold time.");\r\n}\r\ndw_writel(dev, dev->tx_fifo_depth / 2, DW_IC_TX_TL);\r\ndw_writel(dev, 0, DW_IC_RX_TL);\r\ndw_writel(dev, dev->master_cfg , DW_IC_CON);\r\nif (dev->release_lock)\r\ndev->release_lock(dev);\r\nreturn 0;\r\n}\r\nstatic int i2c_dw_wait_bus_not_busy(struct dw_i2c_dev *dev)\r\n{\r\nint timeout = TIMEOUT;\r\nwhile (dw_readl(dev, DW_IC_STATUS) & DW_IC_STATUS_ACTIVITY) {\r\nif (timeout <= 0) {\r\ndev_warn(dev->dev, "timeout waiting for bus ready\n");\r\nreturn -ETIMEDOUT;\r\n}\r\ntimeout--;\r\nusleep_range(1000, 1100);\r\n}\r\nreturn 0;\r\n}\r\nstatic void i2c_dw_xfer_init(struct dw_i2c_dev *dev)\r\n{\r\nstruct i2c_msg *msgs = dev->msgs;\r\nu32 ic_con, ic_tar = 0;\r\n__i2c_dw_enable(dev, false);\r\nic_con = dw_readl(dev, DW_IC_CON);\r\nif (msgs[dev->msg_write_idx].flags & I2C_M_TEN) {\r\nic_con |= DW_IC_CON_10BITADDR_MASTER;\r\nic_tar = DW_IC_TAR_10BITADDR_MASTER;\r\n} else {\r\nic_con &= ~DW_IC_CON_10BITADDR_MASTER;\r\n}\r\ndw_writel(dev, ic_con, DW_IC_CON);\r\ndw_writel(dev, msgs[dev->msg_write_idx].addr | ic_tar, DW_IC_TAR);\r\ni2c_dw_disable_int(dev);\r\n__i2c_dw_enable(dev, true);\r\ndw_readl(dev, DW_IC_CLR_INTR);\r\ndw_writel(dev, DW_IC_INTR_DEFAULT_MASK, DW_IC_INTR_MASK);\r\n}\r\nstatic void\r\ni2c_dw_xfer_msg(struct dw_i2c_dev *dev)\r\n{\r\nstruct i2c_msg *msgs = dev->msgs;\r\nu32 intr_mask;\r\nint tx_limit, rx_limit;\r\nu32 addr = msgs[dev->msg_write_idx].addr;\r\nu32 buf_len = dev->tx_buf_len;\r\nu8 *buf = dev->tx_buf;\r\nbool need_restart = false;\r\nintr_mask = DW_IC_INTR_DEFAULT_MASK;\r\nfor (; dev->msg_write_idx < dev->msgs_num; dev->msg_write_idx++) {\r\nif (msgs[dev->msg_write_idx].addr != addr) {\r\ndev_err(dev->dev,\r\n"%s: invalid target address\n", __func__);\r\ndev->msg_err = -EINVAL;\r\nbreak;\r\n}\r\nif (msgs[dev->msg_write_idx].len == 0) {\r\ndev_err(dev->dev,\r\n"%s: invalid message length\n", __func__);\r\ndev->msg_err = -EINVAL;\r\nbreak;\r\n}\r\nif (!(dev->status & STATUS_WRITE_IN_PROGRESS)) {\r\nbuf = msgs[dev->msg_write_idx].buf;\r\nbuf_len = msgs[dev->msg_write_idx].len;\r\nif ((dev->master_cfg & DW_IC_CON_RESTART_EN) &&\r\n(dev->msg_write_idx > 0))\r\nneed_restart = true;\r\n}\r\ntx_limit = dev->tx_fifo_depth - dw_readl(dev, DW_IC_TXFLR);\r\nrx_limit = dev->rx_fifo_depth - dw_readl(dev, DW_IC_RXFLR);\r\nwhile (buf_len > 0 && tx_limit > 0 && rx_limit > 0) {\r\nu32 cmd = 0;\r\nif (dev->msg_write_idx == dev->msgs_num - 1 &&\r\nbuf_len == 1)\r\ncmd |= BIT(9);\r\nif (need_restart) {\r\ncmd |= BIT(10);\r\nneed_restart = false;\r\n}\r\nif (msgs[dev->msg_write_idx].flags & I2C_M_RD) {\r\nif (rx_limit - dev->rx_outstanding <= 0)\r\nbreak;\r\ndw_writel(dev, cmd | 0x100, DW_IC_DATA_CMD);\r\nrx_limit--;\r\ndev->rx_outstanding++;\r\n} else\r\ndw_writel(dev, cmd | *buf++, DW_IC_DATA_CMD);\r\ntx_limit--; buf_len--;\r\n}\r\ndev->tx_buf = buf;\r\ndev->tx_buf_len = buf_len;\r\nif (buf_len > 0) {\r\ndev->status |= STATUS_WRITE_IN_PROGRESS;\r\nbreak;\r\n} else\r\ndev->status &= ~STATUS_WRITE_IN_PROGRESS;\r\n}\r\nif (dev->msg_write_idx == dev->msgs_num)\r\nintr_mask &= ~DW_IC_INTR_TX_EMPTY;\r\nif (dev->msg_err)\r\nintr_mask = 0;\r\ndw_writel(dev, intr_mask, DW_IC_INTR_MASK);\r\n}\r\nstatic void\r\ni2c_dw_read(struct dw_i2c_dev *dev)\r\n{\r\nstruct i2c_msg *msgs = dev->msgs;\r\nint rx_valid;\r\nfor (; dev->msg_read_idx < dev->msgs_num; dev->msg_read_idx++) {\r\nu32 len;\r\nu8 *buf;\r\nif (!(msgs[dev->msg_read_idx].flags & I2C_M_RD))\r\ncontinue;\r\nif (!(dev->status & STATUS_READ_IN_PROGRESS)) {\r\nlen = msgs[dev->msg_read_idx].len;\r\nbuf = msgs[dev->msg_read_idx].buf;\r\n} else {\r\nlen = dev->rx_buf_len;\r\nbuf = dev->rx_buf;\r\n}\r\nrx_valid = dw_readl(dev, DW_IC_RXFLR);\r\nfor (; len > 0 && rx_valid > 0; len--, rx_valid--) {\r\n*buf++ = dw_readl(dev, DW_IC_DATA_CMD);\r\ndev->rx_outstanding--;\r\n}\r\nif (len > 0) {\r\ndev->status |= STATUS_READ_IN_PROGRESS;\r\ndev->rx_buf_len = len;\r\ndev->rx_buf = buf;\r\nreturn;\r\n} else\r\ndev->status &= ~STATUS_READ_IN_PROGRESS;\r\n}\r\n}\r\nstatic int i2c_dw_handle_tx_abort(struct dw_i2c_dev *dev)\r\n{\r\nunsigned long abort_source = dev->abort_source;\r\nint i;\r\nif (abort_source & DW_IC_TX_ABRT_NOACK) {\r\nfor_each_set_bit(i, &abort_source, ARRAY_SIZE(abort_sources))\r\ndev_dbg(dev->dev,\r\n"%s: %s\n", __func__, abort_sources[i]);\r\nreturn -EREMOTEIO;\r\n}\r\nfor_each_set_bit(i, &abort_source, ARRAY_SIZE(abort_sources))\r\ndev_err(dev->dev, "%s: %s\n", __func__, abort_sources[i]);\r\nif (abort_source & DW_IC_TX_ARB_LOST)\r\nreturn -EAGAIN;\r\nelse if (abort_source & DW_IC_TX_ABRT_GCALL_READ)\r\nreturn -EINVAL;\r\nelse\r\nreturn -EIO;\r\n}\r\nstatic int\r\ni2c_dw_xfer(struct i2c_adapter *adap, struct i2c_msg msgs[], int num)\r\n{\r\nstruct dw_i2c_dev *dev = i2c_get_adapdata(adap);\r\nint ret;\r\ndev_dbg(dev->dev, "%s: msgs: %d\n", __func__, num);\r\npm_runtime_get_sync(dev->dev);\r\nreinit_completion(&dev->cmd_complete);\r\ndev->msgs = msgs;\r\ndev->msgs_num = num;\r\ndev->cmd_err = 0;\r\ndev->msg_write_idx = 0;\r\ndev->msg_read_idx = 0;\r\ndev->msg_err = 0;\r\ndev->status = STATUS_IDLE;\r\ndev->abort_source = 0;\r\ndev->rx_outstanding = 0;\r\nif (dev->acquire_lock) {\r\nret = dev->acquire_lock(dev);\r\nif (ret) {\r\ndev_err(dev->dev, "couldn't acquire bus ownership\n");\r\ngoto done_nolock;\r\n}\r\n}\r\nret = i2c_dw_wait_bus_not_busy(dev);\r\nif (ret < 0)\r\ngoto done;\r\ni2c_dw_xfer_init(dev);\r\nif (!wait_for_completion_timeout(&dev->cmd_complete, HZ)) {\r\ndev_err(dev->dev, "controller timed out\n");\r\ni2c_dw_init(dev);\r\nret = -ETIMEDOUT;\r\ngoto done;\r\n}\r\n__i2c_dw_enable(dev, false);\r\nif (dev->msg_err) {\r\nret = dev->msg_err;\r\ngoto done;\r\n}\r\nif (likely(!dev->cmd_err)) {\r\nret = num;\r\ngoto done;\r\n}\r\nif (dev->cmd_err == DW_IC_ERR_TX_ABRT) {\r\nret = i2c_dw_handle_tx_abort(dev);\r\ngoto done;\r\n}\r\nret = -EIO;\r\ndone:\r\nif (dev->release_lock)\r\ndev->release_lock(dev);\r\ndone_nolock:\r\npm_runtime_mark_last_busy(dev->dev);\r\npm_runtime_put_autosuspend(dev->dev);\r\nreturn ret;\r\n}\r\nstatic u32 i2c_dw_func(struct i2c_adapter *adap)\r\n{\r\nstruct dw_i2c_dev *dev = i2c_get_adapdata(adap);\r\nreturn dev->functionality;\r\n}\r\nstatic u32 i2c_dw_read_clear_intrbits(struct dw_i2c_dev *dev)\r\n{\r\nu32 stat;\r\nstat = dw_readl(dev, DW_IC_INTR_STAT);\r\nif (stat & DW_IC_INTR_RX_UNDER)\r\ndw_readl(dev, DW_IC_CLR_RX_UNDER);\r\nif (stat & DW_IC_INTR_RX_OVER)\r\ndw_readl(dev, DW_IC_CLR_RX_OVER);\r\nif (stat & DW_IC_INTR_TX_OVER)\r\ndw_readl(dev, DW_IC_CLR_TX_OVER);\r\nif (stat & DW_IC_INTR_RD_REQ)\r\ndw_readl(dev, DW_IC_CLR_RD_REQ);\r\nif (stat & DW_IC_INTR_TX_ABRT) {\r\ndev->abort_source = dw_readl(dev, DW_IC_TX_ABRT_SOURCE);\r\ndw_readl(dev, DW_IC_CLR_TX_ABRT);\r\n}\r\nif (stat & DW_IC_INTR_RX_DONE)\r\ndw_readl(dev, DW_IC_CLR_RX_DONE);\r\nif (stat & DW_IC_INTR_ACTIVITY)\r\ndw_readl(dev, DW_IC_CLR_ACTIVITY);\r\nif (stat & DW_IC_INTR_STOP_DET)\r\ndw_readl(dev, DW_IC_CLR_STOP_DET);\r\nif (stat & DW_IC_INTR_START_DET)\r\ndw_readl(dev, DW_IC_CLR_START_DET);\r\nif (stat & DW_IC_INTR_GEN_CALL)\r\ndw_readl(dev, DW_IC_CLR_GEN_CALL);\r\nreturn stat;\r\n}\r\nstatic irqreturn_t i2c_dw_isr(int this_irq, void *dev_id)\r\n{\r\nstruct dw_i2c_dev *dev = dev_id;\r\nu32 stat, enabled;\r\nenabled = dw_readl(dev, DW_IC_ENABLE);\r\nstat = dw_readl(dev, DW_IC_RAW_INTR_STAT);\r\ndev_dbg(dev->dev, "%s: enabled=%#x stat=%#x\n", __func__, enabled, stat);\r\nif (!enabled || !(stat & ~DW_IC_INTR_ACTIVITY))\r\nreturn IRQ_NONE;\r\nstat = i2c_dw_read_clear_intrbits(dev);\r\nif (stat & DW_IC_INTR_TX_ABRT) {\r\ndev->cmd_err |= DW_IC_ERR_TX_ABRT;\r\ndev->status = STATUS_IDLE;\r\ndw_writel(dev, 0, DW_IC_INTR_MASK);\r\ngoto tx_aborted;\r\n}\r\nif (stat & DW_IC_INTR_RX_FULL)\r\ni2c_dw_read(dev);\r\nif (stat & DW_IC_INTR_TX_EMPTY)\r\ni2c_dw_xfer_msg(dev);\r\ntx_aborted:\r\nif ((stat & (DW_IC_INTR_TX_ABRT | DW_IC_INTR_STOP_DET)) || dev->msg_err)\r\ncomplete(&dev->cmd_complete);\r\nelse if (unlikely(dev->accessor_flags & ACCESS_INTR_MASK)) {\r\nstat = dw_readl(dev, DW_IC_INTR_MASK);\r\ni2c_dw_disable_int(dev);\r\ndw_writel(dev, stat, DW_IC_INTR_MASK);\r\n}\r\nreturn IRQ_HANDLED;\r\n}\r\nvoid i2c_dw_disable(struct dw_i2c_dev *dev)\r\n{\r\n__i2c_dw_enable(dev, false);\r\ndw_writel(dev, 0, DW_IC_INTR_MASK);\r\ndw_readl(dev, DW_IC_CLR_INTR);\r\n}\r\nvoid i2c_dw_disable_int(struct dw_i2c_dev *dev)\r\n{\r\ndw_writel(dev, 0, DW_IC_INTR_MASK);\r\n}\r\nu32 i2c_dw_read_comp_param(struct dw_i2c_dev *dev)\r\n{\r\nreturn dw_readl(dev, DW_IC_COMP_PARAM_1);\r\n}\r\nint i2c_dw_probe(struct dw_i2c_dev *dev)\r\n{\r\nstruct i2c_adapter *adap = &dev->adapter;\r\nint r;\r\ninit_completion(&dev->cmd_complete);\r\nr = i2c_dw_init(dev);\r\nif (r)\r\nreturn r;\r\nsnprintf(adap->name, sizeof(adap->name),\r\n"Synopsys DesignWare I2C adapter");\r\nadap->retries = 3;\r\nadap->algo = &i2c_dw_algo;\r\nadap->dev.parent = dev->dev;\r\ni2c_set_adapdata(adap, dev);\r\ni2c_dw_disable_int(dev);\r\nr = devm_request_irq(dev->dev, dev->irq, i2c_dw_isr,\r\nIRQF_SHARED | IRQF_COND_SUSPEND,\r\ndev_name(dev->dev), dev);\r\nif (r) {\r\ndev_err(dev->dev, "failure requesting irq %i: %d\n",\r\ndev->irq, r);\r\nreturn r;\r\n}\r\npm_runtime_get_noresume(dev->dev);\r\nr = i2c_add_numbered_adapter(adap);\r\nif (r)\r\ndev_err(dev->dev, "failure adding adapter: %d\n", r);\r\npm_runtime_put_noidle(dev->dev);\r\nreturn r;\r\n}
