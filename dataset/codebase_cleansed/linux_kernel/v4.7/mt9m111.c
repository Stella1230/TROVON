static const struct mt9m111_datafmt *mt9m111_find_datafmt(struct mt9m111 *mt9m111,\r\nu32 code)\r\n{\r\nint i;\r\nfor (i = 0; i < ARRAY_SIZE(mt9m111_colour_fmts); i++)\r\nif (mt9m111_colour_fmts[i].code == code)\r\nreturn mt9m111_colour_fmts + i;\r\nreturn mt9m111->fmt;\r\n}\r\nstatic struct mt9m111 *to_mt9m111(const struct i2c_client *client)\r\n{\r\nreturn container_of(i2c_get_clientdata(client), struct mt9m111, subdev);\r\n}\r\nstatic int reg_page_map_set(struct i2c_client *client, const u16 reg)\r\n{\r\nint ret;\r\nu16 page;\r\nstruct mt9m111 *mt9m111 = to_mt9m111(client);\r\npage = (reg >> 8);\r\nif (page == mt9m111->lastpage)\r\nreturn 0;\r\nif (page > 2)\r\nreturn -EINVAL;\r\nret = i2c_smbus_write_word_swapped(client, MT9M111_PAGE_MAP, page);\r\nif (!ret)\r\nmt9m111->lastpage = page;\r\nreturn ret;\r\n}\r\nstatic int mt9m111_reg_read(struct i2c_client *client, const u16 reg)\r\n{\r\nint ret;\r\nret = reg_page_map_set(client, reg);\r\nif (!ret)\r\nret = i2c_smbus_read_word_swapped(client, reg & 0xff);\r\ndev_dbg(&client->dev, "read reg.%03x -> %04x\n", reg, ret);\r\nreturn ret;\r\n}\r\nstatic int mt9m111_reg_write(struct i2c_client *client, const u16 reg,\r\nconst u16 data)\r\n{\r\nint ret;\r\nret = reg_page_map_set(client, reg);\r\nif (!ret)\r\nret = i2c_smbus_write_word_swapped(client, reg & 0xff, data);\r\ndev_dbg(&client->dev, "write reg.%03x = %04x -> %d\n", reg, data, ret);\r\nreturn ret;\r\n}\r\nstatic int mt9m111_reg_set(struct i2c_client *client, const u16 reg,\r\nconst u16 data)\r\n{\r\nint ret;\r\nret = mt9m111_reg_read(client, reg);\r\nif (ret >= 0)\r\nret = mt9m111_reg_write(client, reg, ret | data);\r\nreturn ret;\r\n}\r\nstatic int mt9m111_reg_clear(struct i2c_client *client, const u16 reg,\r\nconst u16 data)\r\n{\r\nint ret;\r\nret = mt9m111_reg_read(client, reg);\r\nif (ret >= 0)\r\nret = mt9m111_reg_write(client, reg, ret & ~data);\r\nreturn ret;\r\n}\r\nstatic int mt9m111_reg_mask(struct i2c_client *client, const u16 reg,\r\nconst u16 data, const u16 mask)\r\n{\r\nint ret;\r\nret = mt9m111_reg_read(client, reg);\r\nif (ret >= 0)\r\nret = mt9m111_reg_write(client, reg, (ret & ~mask) | data);\r\nreturn ret;\r\n}\r\nstatic int mt9m111_set_context(struct mt9m111 *mt9m111,\r\nstruct mt9m111_context *ctx)\r\n{\r\nstruct i2c_client *client = v4l2_get_subdevdata(&mt9m111->subdev);\r\nreturn reg_write(CONTEXT_CONTROL, ctx->control);\r\n}\r\nstatic int mt9m111_setup_rect_ctx(struct mt9m111 *mt9m111,\r\nstruct mt9m111_context *ctx, struct v4l2_rect *rect,\r\nunsigned int width, unsigned int height)\r\n{\r\nstruct i2c_client *client = v4l2_get_subdevdata(&mt9m111->subdev);\r\nint ret = mt9m111_reg_write(client, ctx->reducer_xzoom, rect->width);\r\nif (!ret)\r\nret = mt9m111_reg_write(client, ctx->reducer_yzoom, rect->height);\r\nif (!ret)\r\nret = mt9m111_reg_write(client, ctx->reducer_xsize, width);\r\nif (!ret)\r\nret = mt9m111_reg_write(client, ctx->reducer_ysize, height);\r\nreturn ret;\r\n}\r\nstatic int mt9m111_setup_geometry(struct mt9m111 *mt9m111, struct v4l2_rect *rect,\r\nint width, int height, u32 code)\r\n{\r\nstruct i2c_client *client = v4l2_get_subdevdata(&mt9m111->subdev);\r\nint ret;\r\nret = reg_write(COLUMN_START, rect->left);\r\nif (!ret)\r\nret = reg_write(ROW_START, rect->top);\r\nif (!ret)\r\nret = reg_write(WINDOW_WIDTH, rect->width);\r\nif (!ret)\r\nret = reg_write(WINDOW_HEIGHT, rect->height);\r\nif (code != MEDIA_BUS_FMT_SBGGR10_2X8_PADHI_LE) {\r\nif (!ret)\r\nret = mt9m111_setup_rect_ctx(mt9m111, &context_b,\r\nrect, width, height);\r\nif (!ret)\r\nret = mt9m111_setup_rect_ctx(mt9m111, &context_a,\r\nrect, width, height);\r\n}\r\ndev_dbg(&client->dev, "%s(%x): %ux%u@%u:%u -> %ux%u = %d\n",\r\n__func__, code, rect->width, rect->height, rect->left, rect->top,\r\nwidth, height, ret);\r\nreturn ret;\r\n}\r\nstatic int mt9m111_enable(struct mt9m111 *mt9m111)\r\n{\r\nstruct i2c_client *client = v4l2_get_subdevdata(&mt9m111->subdev);\r\nreturn reg_write(RESET, MT9M111_RESET_CHIP_ENABLE);\r\n}\r\nstatic int mt9m111_reset(struct mt9m111 *mt9m111)\r\n{\r\nstruct i2c_client *client = v4l2_get_subdevdata(&mt9m111->subdev);\r\nint ret;\r\nret = reg_set(RESET, MT9M111_RESET_RESET_MODE);\r\nif (!ret)\r\nret = reg_set(RESET, MT9M111_RESET_RESET_SOC);\r\nif (!ret)\r\nret = reg_clear(RESET, MT9M111_RESET_RESET_MODE\r\n| MT9M111_RESET_RESET_SOC);\r\nreturn ret;\r\n}\r\nstatic int mt9m111_s_crop(struct v4l2_subdev *sd, const struct v4l2_crop *a)\r\n{\r\nstruct v4l2_rect rect = a->c;\r\nstruct mt9m111 *mt9m111 = container_of(sd, struct mt9m111, subdev);\r\nint width, height;\r\nint ret;\r\nif (a->type != V4L2_BUF_TYPE_VIDEO_CAPTURE)\r\nreturn -EINVAL;\r\nif (mt9m111->fmt->code == MEDIA_BUS_FMT_SBGGR8_1X8 ||\r\nmt9m111->fmt->code == MEDIA_BUS_FMT_SBGGR10_2X8_PADHI_LE) {\r\nrect.width = ALIGN(rect.width, 2);\r\nrect.height = ALIGN(rect.height, 2);\r\n}\r\nsoc_camera_limit_side(&rect.left, &rect.width,\r\nMT9M111_MIN_DARK_COLS, 2, MT9M111_MAX_WIDTH);\r\nsoc_camera_limit_side(&rect.top, &rect.height,\r\nMT9M111_MIN_DARK_ROWS, 2, MT9M111_MAX_HEIGHT);\r\nwidth = min(mt9m111->width, rect.width);\r\nheight = min(mt9m111->height, rect.height);\r\nret = mt9m111_setup_geometry(mt9m111, &rect, width, height, mt9m111->fmt->code);\r\nif (!ret) {\r\nmt9m111->rect = rect;\r\nmt9m111->width = width;\r\nmt9m111->height = height;\r\n}\r\nreturn ret;\r\n}\r\nstatic int mt9m111_g_crop(struct v4l2_subdev *sd, struct v4l2_crop *a)\r\n{\r\nstruct mt9m111 *mt9m111 = container_of(sd, struct mt9m111, subdev);\r\na->c = mt9m111->rect;\r\na->type = V4L2_BUF_TYPE_VIDEO_CAPTURE;\r\nreturn 0;\r\n}\r\nstatic int mt9m111_cropcap(struct v4l2_subdev *sd, struct v4l2_cropcap *a)\r\n{\r\nif (a->type != V4L2_BUF_TYPE_VIDEO_CAPTURE)\r\nreturn -EINVAL;\r\na->bounds.left = MT9M111_MIN_DARK_COLS;\r\na->bounds.top = MT9M111_MIN_DARK_ROWS;\r\na->bounds.width = MT9M111_MAX_WIDTH;\r\na->bounds.height = MT9M111_MAX_HEIGHT;\r\na->defrect = a->bounds;\r\na->pixelaspect.numerator = 1;\r\na->pixelaspect.denominator = 1;\r\nreturn 0;\r\n}\r\nstatic int mt9m111_get_fmt(struct v4l2_subdev *sd,\r\nstruct v4l2_subdev_pad_config *cfg,\r\nstruct v4l2_subdev_format *format)\r\n{\r\nstruct v4l2_mbus_framefmt *mf = &format->format;\r\nstruct mt9m111 *mt9m111 = container_of(sd, struct mt9m111, subdev);\r\nif (format->pad)\r\nreturn -EINVAL;\r\nmf->width = mt9m111->width;\r\nmf->height = mt9m111->height;\r\nmf->code = mt9m111->fmt->code;\r\nmf->colorspace = mt9m111->fmt->colorspace;\r\nmf->field = V4L2_FIELD_NONE;\r\nreturn 0;\r\n}\r\nstatic int mt9m111_set_pixfmt(struct mt9m111 *mt9m111,\r\nu32 code)\r\n{\r\nstruct i2c_client *client = v4l2_get_subdevdata(&mt9m111->subdev);\r\nu16 data_outfmt2, mask_outfmt2 = MT9M111_OUTFMT_PROCESSED_BAYER |\r\nMT9M111_OUTFMT_BYPASS_IFP | MT9M111_OUTFMT_RGB |\r\nMT9M111_OUTFMT_RGB565 | MT9M111_OUTFMT_RGB555 |\r\nMT9M111_OUTFMT_RGB444x | MT9M111_OUTFMT_RGBx444 |\r\nMT9M111_OUTFMT_SWAP_YCbCr_C_Y_RGB_EVEN |\r\nMT9M111_OUTFMT_SWAP_YCbCr_Cb_Cr_RGB_R_B;\r\nint ret;\r\nswitch (code) {\r\ncase MEDIA_BUS_FMT_SBGGR8_1X8:\r\ndata_outfmt2 = MT9M111_OUTFMT_PROCESSED_BAYER |\r\nMT9M111_OUTFMT_RGB;\r\nbreak;\r\ncase MEDIA_BUS_FMT_SBGGR10_2X8_PADHI_LE:\r\ndata_outfmt2 = MT9M111_OUTFMT_BYPASS_IFP | MT9M111_OUTFMT_RGB;\r\nbreak;\r\ncase MEDIA_BUS_FMT_RGB555_2X8_PADHI_LE:\r\ndata_outfmt2 = MT9M111_OUTFMT_RGB | MT9M111_OUTFMT_RGB555 |\r\nMT9M111_OUTFMT_SWAP_YCbCr_C_Y_RGB_EVEN;\r\nbreak;\r\ncase MEDIA_BUS_FMT_RGB555_2X8_PADHI_BE:\r\ndata_outfmt2 = MT9M111_OUTFMT_RGB | MT9M111_OUTFMT_RGB555;\r\nbreak;\r\ncase MEDIA_BUS_FMT_RGB565_2X8_LE:\r\ndata_outfmt2 = MT9M111_OUTFMT_RGB | MT9M111_OUTFMT_RGB565 |\r\nMT9M111_OUTFMT_SWAP_YCbCr_C_Y_RGB_EVEN;\r\nbreak;\r\ncase MEDIA_BUS_FMT_RGB565_2X8_BE:\r\ndata_outfmt2 = MT9M111_OUTFMT_RGB | MT9M111_OUTFMT_RGB565;\r\nbreak;\r\ncase MEDIA_BUS_FMT_BGR565_2X8_BE:\r\ndata_outfmt2 = MT9M111_OUTFMT_RGB | MT9M111_OUTFMT_RGB565 |\r\nMT9M111_OUTFMT_SWAP_YCbCr_Cb_Cr_RGB_R_B;\r\nbreak;\r\ncase MEDIA_BUS_FMT_BGR565_2X8_LE:\r\ndata_outfmt2 = MT9M111_OUTFMT_RGB | MT9M111_OUTFMT_RGB565 |\r\nMT9M111_OUTFMT_SWAP_YCbCr_C_Y_RGB_EVEN |\r\nMT9M111_OUTFMT_SWAP_YCbCr_Cb_Cr_RGB_R_B;\r\nbreak;\r\ncase MEDIA_BUS_FMT_UYVY8_2X8:\r\ndata_outfmt2 = 0;\r\nbreak;\r\ncase MEDIA_BUS_FMT_VYUY8_2X8:\r\ndata_outfmt2 = MT9M111_OUTFMT_SWAP_YCbCr_Cb_Cr_RGB_R_B;\r\nbreak;\r\ncase MEDIA_BUS_FMT_YUYV8_2X8:\r\ndata_outfmt2 = MT9M111_OUTFMT_SWAP_YCbCr_C_Y_RGB_EVEN;\r\nbreak;\r\ncase MEDIA_BUS_FMT_YVYU8_2X8:\r\ndata_outfmt2 = MT9M111_OUTFMT_SWAP_YCbCr_C_Y_RGB_EVEN |\r\nMT9M111_OUTFMT_SWAP_YCbCr_Cb_Cr_RGB_R_B;\r\nbreak;\r\ndefault:\r\ndev_err(&client->dev, "Pixel format not handled: %x\n", code);\r\nreturn -EINVAL;\r\n}\r\nret = mt9m111_reg_mask(client, context_a.output_fmt_ctrl2,\r\ndata_outfmt2, mask_outfmt2);\r\nif (!ret)\r\nret = mt9m111_reg_mask(client, context_b.output_fmt_ctrl2,\r\ndata_outfmt2, mask_outfmt2);\r\nreturn ret;\r\n}\r\nstatic int mt9m111_set_fmt(struct v4l2_subdev *sd,\r\nstruct v4l2_subdev_pad_config *cfg,\r\nstruct v4l2_subdev_format *format)\r\n{\r\nstruct v4l2_mbus_framefmt *mf = &format->format;\r\nstruct i2c_client *client = v4l2_get_subdevdata(sd);\r\nstruct mt9m111 *mt9m111 = container_of(sd, struct mt9m111, subdev);\r\nconst struct mt9m111_datafmt *fmt;\r\nstruct v4l2_rect *rect = &mt9m111->rect;\r\nbool bayer;\r\nint ret;\r\nif (format->pad)\r\nreturn -EINVAL;\r\nfmt = mt9m111_find_datafmt(mt9m111, mf->code);\r\nbayer = fmt->code == MEDIA_BUS_FMT_SBGGR8_1X8 ||\r\nfmt->code == MEDIA_BUS_FMT_SBGGR10_2X8_PADHI_LE;\r\nif (bayer) {\r\nrect->width = ALIGN(rect->width, 2);\r\nrect->height = ALIGN(rect->height, 2);\r\n}\r\nif (fmt->code == MEDIA_BUS_FMT_SBGGR10_2X8_PADHI_LE) {\r\nmf->width = rect->width;\r\nmf->height = rect->height;\r\n} else {\r\nif (mf->width > rect->width)\r\nmf->width = rect->width;\r\nif (mf->height > rect->height)\r\nmf->height = rect->height;\r\n}\r\ndev_dbg(&client->dev, "%s(): %ux%u, code=%x\n", __func__,\r\nmf->width, mf->height, fmt->code);\r\nmf->code = fmt->code;\r\nmf->colorspace = fmt->colorspace;\r\nif (format->which == V4L2_SUBDEV_FORMAT_TRY) {\r\ncfg->try_fmt = *mf;\r\nreturn 0;\r\n}\r\nret = mt9m111_setup_geometry(mt9m111, rect, mf->width, mf->height, mf->code);\r\nif (!ret)\r\nret = mt9m111_set_pixfmt(mt9m111, mf->code);\r\nif (!ret) {\r\nmt9m111->width = mf->width;\r\nmt9m111->height = mf->height;\r\nmt9m111->fmt = fmt;\r\n}\r\nreturn ret;\r\n}\r\nstatic int mt9m111_g_register(struct v4l2_subdev *sd,\r\nstruct v4l2_dbg_register *reg)\r\n{\r\nstruct i2c_client *client = v4l2_get_subdevdata(sd);\r\nint val;\r\nif (reg->reg > 0x2ff)\r\nreturn -EINVAL;\r\nval = mt9m111_reg_read(client, reg->reg);\r\nreg->size = 2;\r\nreg->val = (u64)val;\r\nif (reg->val > 0xffff)\r\nreturn -EIO;\r\nreturn 0;\r\n}\r\nstatic int mt9m111_s_register(struct v4l2_subdev *sd,\r\nconst struct v4l2_dbg_register *reg)\r\n{\r\nstruct i2c_client *client = v4l2_get_subdevdata(sd);\r\nif (reg->reg > 0x2ff)\r\nreturn -EINVAL;\r\nif (mt9m111_reg_write(client, reg->reg, reg->val) < 0)\r\nreturn -EIO;\r\nreturn 0;\r\n}\r\nstatic int mt9m111_set_flip(struct mt9m111 *mt9m111, int flip, int mask)\r\n{\r\nstruct i2c_client *client = v4l2_get_subdevdata(&mt9m111->subdev);\r\nint ret;\r\nif (flip)\r\nret = mt9m111_reg_set(client, mt9m111->ctx->read_mode, mask);\r\nelse\r\nret = mt9m111_reg_clear(client, mt9m111->ctx->read_mode, mask);\r\nreturn ret;\r\n}\r\nstatic int mt9m111_get_global_gain(struct mt9m111 *mt9m111)\r\n{\r\nstruct i2c_client *client = v4l2_get_subdevdata(&mt9m111->subdev);\r\nint data;\r\ndata = reg_read(GLOBAL_GAIN);\r\nif (data >= 0)\r\nreturn (data & 0x2f) * (1 << ((data >> 10) & 1)) *\r\n(1 << ((data >> 9) & 1));\r\nreturn data;\r\n}\r\nstatic int mt9m111_set_global_gain(struct mt9m111 *mt9m111, int gain)\r\n{\r\nstruct i2c_client *client = v4l2_get_subdevdata(&mt9m111->subdev);\r\nu16 val;\r\nif (gain > 63 * 2 * 2)\r\nreturn -EINVAL;\r\nif ((gain >= 64 * 2) && (gain < 63 * 2 * 2))\r\nval = (1 << 10) | (1 << 9) | (gain / 4);\r\nelse if ((gain >= 64) && (gain < 64 * 2))\r\nval = (1 << 9) | (gain / 2);\r\nelse\r\nval = gain;\r\nreturn reg_write(GLOBAL_GAIN, val);\r\n}\r\nstatic int mt9m111_set_autoexposure(struct mt9m111 *mt9m111, int val)\r\n{\r\nstruct i2c_client *client = v4l2_get_subdevdata(&mt9m111->subdev);\r\nif (val == V4L2_EXPOSURE_AUTO)\r\nreturn reg_set(OPER_MODE_CTRL, MT9M111_OPMODE_AUTOEXPO_EN);\r\nreturn reg_clear(OPER_MODE_CTRL, MT9M111_OPMODE_AUTOEXPO_EN);\r\n}\r\nstatic int mt9m111_set_autowhitebalance(struct mt9m111 *mt9m111, int on)\r\n{\r\nstruct i2c_client *client = v4l2_get_subdevdata(&mt9m111->subdev);\r\nif (on)\r\nreturn reg_set(OPER_MODE_CTRL, MT9M111_OPMODE_AUTOWHITEBAL_EN);\r\nreturn reg_clear(OPER_MODE_CTRL, MT9M111_OPMODE_AUTOWHITEBAL_EN);\r\n}\r\nstatic int mt9m111_s_ctrl(struct v4l2_ctrl *ctrl)\r\n{\r\nstruct mt9m111 *mt9m111 = container_of(ctrl->handler,\r\nstruct mt9m111, hdl);\r\nswitch (ctrl->id) {\r\ncase V4L2_CID_VFLIP:\r\nreturn mt9m111_set_flip(mt9m111, ctrl->val,\r\nMT9M111_RMB_MIRROR_ROWS);\r\ncase V4L2_CID_HFLIP:\r\nreturn mt9m111_set_flip(mt9m111, ctrl->val,\r\nMT9M111_RMB_MIRROR_COLS);\r\ncase V4L2_CID_GAIN:\r\nreturn mt9m111_set_global_gain(mt9m111, ctrl->val);\r\ncase V4L2_CID_EXPOSURE_AUTO:\r\nreturn mt9m111_set_autoexposure(mt9m111, ctrl->val);\r\ncase V4L2_CID_AUTO_WHITE_BALANCE:\r\nreturn mt9m111_set_autowhitebalance(mt9m111, ctrl->val);\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int mt9m111_suspend(struct mt9m111 *mt9m111)\r\n{\r\nstruct i2c_client *client = v4l2_get_subdevdata(&mt9m111->subdev);\r\nint ret;\r\nv4l2_ctrl_s_ctrl(mt9m111->gain, mt9m111_get_global_gain(mt9m111));\r\nret = reg_set(RESET, MT9M111_RESET_RESET_MODE);\r\nif (!ret)\r\nret = reg_set(RESET, MT9M111_RESET_RESET_SOC |\r\nMT9M111_RESET_OUTPUT_DISABLE |\r\nMT9M111_RESET_ANALOG_STANDBY);\r\nif (!ret)\r\nret = reg_clear(RESET, MT9M111_RESET_CHIP_ENABLE);\r\nreturn ret;\r\n}\r\nstatic void mt9m111_restore_state(struct mt9m111 *mt9m111)\r\n{\r\nmt9m111_set_context(mt9m111, mt9m111->ctx);\r\nmt9m111_set_pixfmt(mt9m111, mt9m111->fmt->code);\r\nmt9m111_setup_geometry(mt9m111, &mt9m111->rect,\r\nmt9m111->width, mt9m111->height, mt9m111->fmt->code);\r\nv4l2_ctrl_handler_setup(&mt9m111->hdl);\r\n}\r\nstatic int mt9m111_resume(struct mt9m111 *mt9m111)\r\n{\r\nint ret = mt9m111_enable(mt9m111);\r\nif (!ret)\r\nret = mt9m111_reset(mt9m111);\r\nif (!ret)\r\nmt9m111_restore_state(mt9m111);\r\nreturn ret;\r\n}\r\nstatic int mt9m111_init(struct mt9m111 *mt9m111)\r\n{\r\nstruct i2c_client *client = v4l2_get_subdevdata(&mt9m111->subdev);\r\nint ret;\r\nret = mt9m111_enable(mt9m111);\r\nif (!ret)\r\nret = mt9m111_reset(mt9m111);\r\nif (!ret)\r\nret = mt9m111_set_context(mt9m111, mt9m111->ctx);\r\nif (ret)\r\ndev_err(&client->dev, "mt9m111 init failed: %d\n", ret);\r\nreturn ret;\r\n}\r\nstatic int mt9m111_power_on(struct mt9m111 *mt9m111)\r\n{\r\nstruct i2c_client *client = v4l2_get_subdevdata(&mt9m111->subdev);\r\nstruct soc_camera_subdev_desc *ssdd = soc_camera_i2c_to_desc(client);\r\nint ret;\r\nret = soc_camera_power_on(&client->dev, ssdd, mt9m111->clk);\r\nif (ret < 0)\r\nreturn ret;\r\nret = mt9m111_resume(mt9m111);\r\nif (ret < 0) {\r\ndev_err(&client->dev, "Failed to resume the sensor: %d\n", ret);\r\nsoc_camera_power_off(&client->dev, ssdd, mt9m111->clk);\r\n}\r\nreturn ret;\r\n}\r\nstatic void mt9m111_power_off(struct mt9m111 *mt9m111)\r\n{\r\nstruct i2c_client *client = v4l2_get_subdevdata(&mt9m111->subdev);\r\nstruct soc_camera_subdev_desc *ssdd = soc_camera_i2c_to_desc(client);\r\nmt9m111_suspend(mt9m111);\r\nsoc_camera_power_off(&client->dev, ssdd, mt9m111->clk);\r\n}\r\nstatic int mt9m111_s_power(struct v4l2_subdev *sd, int on)\r\n{\r\nstruct mt9m111 *mt9m111 = container_of(sd, struct mt9m111, subdev);\r\nint ret = 0;\r\nmutex_lock(&mt9m111->power_lock);\r\nif (mt9m111->power_count == !on) {\r\nif (on)\r\nret = mt9m111_power_on(mt9m111);\r\nelse\r\nmt9m111_power_off(mt9m111);\r\n}\r\nif (!ret) {\r\nmt9m111->power_count += on ? 1 : -1;\r\nWARN_ON(mt9m111->power_count < 0);\r\n}\r\nmutex_unlock(&mt9m111->power_lock);\r\nreturn ret;\r\n}\r\nstatic int mt9m111_enum_mbus_code(struct v4l2_subdev *sd,\r\nstruct v4l2_subdev_pad_config *cfg,\r\nstruct v4l2_subdev_mbus_code_enum *code)\r\n{\r\nif (code->pad || code->index >= ARRAY_SIZE(mt9m111_colour_fmts))\r\nreturn -EINVAL;\r\ncode->code = mt9m111_colour_fmts[code->index].code;\r\nreturn 0;\r\n}\r\nstatic int mt9m111_g_mbus_config(struct v4l2_subdev *sd,\r\nstruct v4l2_mbus_config *cfg)\r\n{\r\nstruct i2c_client *client = v4l2_get_subdevdata(sd);\r\nstruct soc_camera_subdev_desc *ssdd = soc_camera_i2c_to_desc(client);\r\ncfg->flags = V4L2_MBUS_MASTER | V4L2_MBUS_PCLK_SAMPLE_RISING |\r\nV4L2_MBUS_HSYNC_ACTIVE_HIGH | V4L2_MBUS_VSYNC_ACTIVE_HIGH |\r\nV4L2_MBUS_DATA_ACTIVE_HIGH;\r\ncfg->type = V4L2_MBUS_PARALLEL;\r\ncfg->flags = soc_camera_apply_board_flags(ssdd, cfg);\r\nreturn 0;\r\n}\r\nstatic int mt9m111_video_probe(struct i2c_client *client)\r\n{\r\nstruct mt9m111 *mt9m111 = to_mt9m111(client);\r\ns32 data;\r\nint ret;\r\nret = mt9m111_s_power(&mt9m111->subdev, 1);\r\nif (ret < 0)\r\nreturn ret;\r\ndata = reg_read(CHIP_VERSION);\r\nswitch (data) {\r\ncase 0x143a:\r\ndev_info(&client->dev,\r\n"Detected a MT9M111/MT9M131 chip ID %x\n", data);\r\nbreak;\r\ncase 0x148c:\r\ndev_info(&client->dev, "Detected a MT9M112 chip ID %x\n", data);\r\nbreak;\r\ndefault:\r\ndev_err(&client->dev,\r\n"No MT9M111/MT9M112/MT9M131 chip detected register read %x\n",\r\ndata);\r\nret = -ENODEV;\r\ngoto done;\r\n}\r\nret = mt9m111_init(mt9m111);\r\nif (ret)\r\ngoto done;\r\nret = v4l2_ctrl_handler_setup(&mt9m111->hdl);\r\ndone:\r\nmt9m111_s_power(&mt9m111->subdev, 0);\r\nreturn ret;\r\n}\r\nstatic int mt9m111_probe(struct i2c_client *client,\r\nconst struct i2c_device_id *did)\r\n{\r\nstruct mt9m111 *mt9m111;\r\nstruct i2c_adapter *adapter = to_i2c_adapter(client->dev.parent);\r\nstruct soc_camera_subdev_desc *ssdd = soc_camera_i2c_to_desc(client);\r\nint ret;\r\nif (client->dev.of_node) {\r\nssdd = devm_kzalloc(&client->dev, sizeof(*ssdd), GFP_KERNEL);\r\nif (!ssdd)\r\nreturn -ENOMEM;\r\nclient->dev.platform_data = ssdd;\r\n}\r\nif (!ssdd) {\r\ndev_err(&client->dev, "mt9m111: driver needs platform data\n");\r\nreturn -EINVAL;\r\n}\r\nif (!i2c_check_functionality(adapter, I2C_FUNC_SMBUS_WORD_DATA)) {\r\ndev_warn(&adapter->dev,\r\n"I2C-Adapter doesn't support I2C_FUNC_SMBUS_WORD\n");\r\nreturn -EIO;\r\n}\r\nmt9m111 = devm_kzalloc(&client->dev, sizeof(struct mt9m111), GFP_KERNEL);\r\nif (!mt9m111)\r\nreturn -ENOMEM;\r\nmt9m111->clk = v4l2_clk_get(&client->dev, "mclk");\r\nif (IS_ERR(mt9m111->clk))\r\nreturn -EPROBE_DEFER;\r\nmt9m111->ctx = &context_b;\r\nv4l2_i2c_subdev_init(&mt9m111->subdev, client, &mt9m111_subdev_ops);\r\nv4l2_ctrl_handler_init(&mt9m111->hdl, 5);\r\nv4l2_ctrl_new_std(&mt9m111->hdl, &mt9m111_ctrl_ops,\r\nV4L2_CID_VFLIP, 0, 1, 1, 0);\r\nv4l2_ctrl_new_std(&mt9m111->hdl, &mt9m111_ctrl_ops,\r\nV4L2_CID_HFLIP, 0, 1, 1, 0);\r\nv4l2_ctrl_new_std(&mt9m111->hdl, &mt9m111_ctrl_ops,\r\nV4L2_CID_AUTO_WHITE_BALANCE, 0, 1, 1, 1);\r\nmt9m111->gain = v4l2_ctrl_new_std(&mt9m111->hdl, &mt9m111_ctrl_ops,\r\nV4L2_CID_GAIN, 0, 63 * 2 * 2, 1, 32);\r\nv4l2_ctrl_new_std_menu(&mt9m111->hdl,\r\n&mt9m111_ctrl_ops, V4L2_CID_EXPOSURE_AUTO, 1, 0,\r\nV4L2_EXPOSURE_AUTO);\r\nmt9m111->subdev.ctrl_handler = &mt9m111->hdl;\r\nif (mt9m111->hdl.error) {\r\nret = mt9m111->hdl.error;\r\ngoto out_clkput;\r\n}\r\nmt9m111->rect.left = MT9M111_MIN_DARK_COLS;\r\nmt9m111->rect.top = MT9M111_MIN_DARK_ROWS;\r\nmt9m111->rect.width = MT9M111_MAX_WIDTH;\r\nmt9m111->rect.height = MT9M111_MAX_HEIGHT;\r\nmt9m111->fmt = &mt9m111_colour_fmts[0];\r\nmt9m111->lastpage = -1;\r\nmutex_init(&mt9m111->power_lock);\r\nret = soc_camera_power_init(&client->dev, ssdd);\r\nif (ret < 0)\r\ngoto out_hdlfree;\r\nret = mt9m111_video_probe(client);\r\nif (ret < 0)\r\ngoto out_hdlfree;\r\nmt9m111->subdev.dev = &client->dev;\r\nret = v4l2_async_register_subdev(&mt9m111->subdev);\r\nif (ret < 0)\r\ngoto out_hdlfree;\r\nreturn 0;\r\nout_hdlfree:\r\nv4l2_ctrl_handler_free(&mt9m111->hdl);\r\nout_clkput:\r\nv4l2_clk_put(mt9m111->clk);\r\nreturn ret;\r\n}\r\nstatic int mt9m111_remove(struct i2c_client *client)\r\n{\r\nstruct mt9m111 *mt9m111 = to_mt9m111(client);\r\nv4l2_async_unregister_subdev(&mt9m111->subdev);\r\nv4l2_clk_put(mt9m111->clk);\r\nv4l2_ctrl_handler_free(&mt9m111->hdl);\r\nreturn 0;\r\n}
