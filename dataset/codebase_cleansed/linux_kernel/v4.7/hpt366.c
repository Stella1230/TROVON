static bool check_in_drive_list(ide_drive_t *drive, const char **list)\r\n{\r\nreturn match_string(list, -1, (char *)&drive->id[ATA_ID_PROD]) >= 0;\r\n}\r\nstatic struct hpt_info *hpt3xx_get_info(struct device *dev)\r\n{\r\nstruct ide_host *host = dev_get_drvdata(dev);\r\nstruct hpt_info *info = (struct hpt_info *)host->host_priv;\r\nreturn dev == host->dev[1] ? info + 1 : info;\r\n}\r\nstatic u8 hpt3xx_udma_filter(ide_drive_t *drive)\r\n{\r\nide_hwif_t *hwif = drive->hwif;\r\nstruct hpt_info *info = hpt3xx_get_info(hwif->dev);\r\nu8 mask = hwif->ultra_mask;\r\nswitch (info->chip_type) {\r\ncase HPT36x:\r\nif (!HPT366_ALLOW_ATA66_4 ||\r\ncheck_in_drive_list(drive, bad_ata66_4))\r\nmask = ATA_UDMA3;\r\nif (!HPT366_ALLOW_ATA66_3 ||\r\ncheck_in_drive_list(drive, bad_ata66_3))\r\nmask = ATA_UDMA2;\r\nbreak;\r\ncase HPT370:\r\nif (!HPT370_ALLOW_ATA100_5 ||\r\ncheck_in_drive_list(drive, bad_ata100_5))\r\nmask = ATA_UDMA4;\r\nbreak;\r\ncase HPT370A:\r\nif (!HPT370_ALLOW_ATA100_5 ||\r\ncheck_in_drive_list(drive, bad_ata100_5))\r\nreturn ATA_UDMA4;\r\ncase HPT372 :\r\ncase HPT372A:\r\ncase HPT372N:\r\ncase HPT374 :\r\nif (ata_id_is_sata(drive->id))\r\nmask &= ~0x0e;\r\ndefault:\r\nreturn mask;\r\n}\r\nreturn check_in_drive_list(drive, bad_ata33) ? 0x00 : mask;\r\n}\r\nstatic u8 hpt3xx_mdma_filter(ide_drive_t *drive)\r\n{\r\nide_hwif_t *hwif = drive->hwif;\r\nstruct hpt_info *info = hpt3xx_get_info(hwif->dev);\r\nswitch (info->chip_type) {\r\ncase HPT372 :\r\ncase HPT372A:\r\ncase HPT372N:\r\ncase HPT374 :\r\nif (ata_id_is_sata(drive->id))\r\nreturn 0x00;\r\ndefault:\r\nreturn 0x07;\r\n}\r\n}\r\nstatic u32 get_speed_setting(u8 speed, struct hpt_info *info)\r\n{\r\nint i;\r\nfor (i = 0; i < ARRAY_SIZE(xfer_speeds) - 1; i++)\r\nif (xfer_speeds[i] == speed)\r\nbreak;\r\nreturn info->timings->clock_table[info->clock][i];\r\n}\r\nstatic void hpt3xx_set_mode(ide_hwif_t *hwif, ide_drive_t *drive)\r\n{\r\nstruct pci_dev *dev = to_pci_dev(hwif->dev);\r\nstruct hpt_info *info = hpt3xx_get_info(hwif->dev);\r\nstruct hpt_timings *t = info->timings;\r\nu8 itr_addr = 0x40 + (drive->dn * 4);\r\nu32 old_itr = 0;\r\nconst u8 speed = drive->dma_mode;\r\nu32 new_itr = get_speed_setting(speed, info);\r\nu32 itr_mask = speed < XFER_MW_DMA_0 ? t->pio_mask :\r\n(speed < XFER_UDMA_0 ? t->dma_mask :\r\nt->ultra_mask);\r\npci_read_config_dword(dev, itr_addr, &old_itr);\r\nnew_itr = (old_itr & ~itr_mask) | (new_itr & itr_mask);\r\nnew_itr &= ~0xc0000000;\r\npci_write_config_dword(dev, itr_addr, new_itr);\r\n}\r\nstatic void hpt3xx_set_pio_mode(ide_hwif_t *hwif, ide_drive_t *drive)\r\n{\r\ndrive->dma_mode = drive->pio_mode;\r\nhpt3xx_set_mode(hwif, drive);\r\n}\r\nstatic void hpt3xx_maskproc(ide_drive_t *drive, int mask)\r\n{\r\nide_hwif_t *hwif = drive->hwif;\r\nstruct pci_dev *dev = to_pci_dev(hwif->dev);\r\nstruct hpt_info *info = hpt3xx_get_info(hwif->dev);\r\nif ((drive->dev_flags & IDE_DFLAG_NIEN_QUIRK) == 0)\r\nreturn;\r\nif (info->chip_type >= HPT370) {\r\nu8 scr1 = 0;\r\npci_read_config_byte(dev, 0x5a, &scr1);\r\nif (((scr1 & 0x10) >> 4) != mask) {\r\nif (mask)\r\nscr1 |= 0x10;\r\nelse\r\nscr1 &= ~0x10;\r\npci_write_config_byte(dev, 0x5a, scr1);\r\n}\r\n} else if (mask)\r\ndisable_irq(hwif->irq);\r\nelse\r\nenable_irq(hwif->irq);\r\n}\r\nstatic void hpt366_dma_lost_irq(ide_drive_t *drive)\r\n{\r\nstruct pci_dev *dev = to_pci_dev(drive->hwif->dev);\r\nu8 mcr1 = 0, mcr3 = 0, scr1 = 0;\r\npci_read_config_byte(dev, 0x50, &mcr1);\r\npci_read_config_byte(dev, 0x52, &mcr3);\r\npci_read_config_byte(dev, 0x5a, &scr1);\r\nprintk("%s: (%s) mcr1=0x%02x, mcr3=0x%02x, scr1=0x%02x\n",\r\ndrive->name, __func__, mcr1, mcr3, scr1);\r\nif (scr1 & 0x10)\r\npci_write_config_byte(dev, 0x5a, scr1 & ~0x10);\r\nide_dma_lost_irq(drive);\r\n}\r\nstatic void hpt370_clear_engine(ide_drive_t *drive)\r\n{\r\nide_hwif_t *hwif = drive->hwif;\r\nstruct pci_dev *dev = to_pci_dev(hwif->dev);\r\npci_write_config_byte(dev, hwif->select_data, 0x37);\r\nudelay(10);\r\n}\r\nstatic void hpt370_irq_timeout(ide_drive_t *drive)\r\n{\r\nide_hwif_t *hwif = drive->hwif;\r\nstruct pci_dev *dev = to_pci_dev(hwif->dev);\r\nu16 bfifo = 0;\r\nu8 dma_cmd;\r\npci_read_config_word(dev, hwif->select_data + 2, &bfifo);\r\nprintk(KERN_DEBUG "%s: %d bytes in FIFO\n", drive->name, bfifo & 0x1ff);\r\ndma_cmd = inb(hwif->dma_base + ATA_DMA_CMD);\r\noutb(dma_cmd & ~ATA_DMA_START, hwif->dma_base + ATA_DMA_CMD);\r\nhpt370_clear_engine(drive);\r\n}\r\nstatic void hpt370_dma_start(ide_drive_t *drive)\r\n{\r\n#ifdef HPT_RESET_STATE_ENGINE\r\nhpt370_clear_engine(drive);\r\n#endif\r\nide_dma_start(drive);\r\n}\r\nstatic int hpt370_dma_end(ide_drive_t *drive)\r\n{\r\nide_hwif_t *hwif = drive->hwif;\r\nu8 dma_stat = inb(hwif->dma_base + ATA_DMA_STATUS);\r\nif (dma_stat & ATA_DMA_ACTIVE) {\r\nudelay(20);\r\ndma_stat = inb(hwif->dma_base + ATA_DMA_STATUS);\r\nif (dma_stat & ATA_DMA_ACTIVE)\r\nhpt370_irq_timeout(drive);\r\n}\r\nreturn ide_dma_end(drive);\r\n}\r\nstatic int hpt374_dma_test_irq(ide_drive_t *drive)\r\n{\r\nide_hwif_t *hwif = drive->hwif;\r\nstruct pci_dev *dev = to_pci_dev(hwif->dev);\r\nu16 bfifo = 0;\r\nu8 dma_stat;\r\npci_read_config_word(dev, hwif->select_data + 2, &bfifo);\r\nif (bfifo & 0x1FF) {\r\nreturn 0;\r\n}\r\ndma_stat = inb(hwif->dma_base + ATA_DMA_STATUS);\r\nif (dma_stat & ATA_DMA_INTR)\r\nreturn 1;\r\nreturn 0;\r\n}\r\nstatic int hpt374_dma_end(ide_drive_t *drive)\r\n{\r\nide_hwif_t *hwif = drive->hwif;\r\nstruct pci_dev *dev = to_pci_dev(hwif->dev);\r\nu8 mcr = 0, mcr_addr = hwif->select_data;\r\nu8 bwsr = 0, mask = hwif->channel ? 0x02 : 0x01;\r\npci_read_config_byte(dev, 0x6a, &bwsr);\r\npci_read_config_byte(dev, mcr_addr, &mcr);\r\nif (bwsr & mask)\r\npci_write_config_byte(dev, mcr_addr, mcr | 0x30);\r\nreturn ide_dma_end(drive);\r\n}\r\nstatic void hpt3xxn_set_clock(ide_hwif_t *hwif, u8 mode)\r\n{\r\nunsigned long base = hwif->extra_base;\r\nu8 scr2 = inb(base + 0x6b);\r\nif ((scr2 & 0x7f) == mode)\r\nreturn;\r\noutb(0x80, base + 0x63);\r\noutb(0x80, base + 0x67);\r\noutb(mode, base + 0x6b);\r\noutb(0xc0, base + 0x69);\r\noutb(inb(base + 0x60) | 0x32, base + 0x60);\r\noutb(inb(base + 0x64) | 0x32, base + 0x64);\r\noutb(0x00, base + 0x69);\r\noutb(0x00, base + 0x63);\r\noutb(0x00, base + 0x67);\r\n}\r\nstatic void hpt3xxn_rw_disk(ide_drive_t *drive, struct request *rq)\r\n{\r\nhpt3xxn_set_clock(drive->hwif, rq_data_dir(rq) ? 0x21 : 0x23);\r\n}\r\nstatic int hpt37x_calibrate_dpll(struct pci_dev *dev, u16 f_low, u16 f_high)\r\n{\r\nu32 dpll = (f_high << 16) | f_low | 0x100;\r\nu8 scr2;\r\nint i;\r\npci_write_config_dword(dev, 0x5c, dpll);\r\nfor(i = 0; i < 0x5000; ++i) {\r\nudelay(50);\r\npci_read_config_byte(dev, 0x5b, &scr2);\r\nif (scr2 & 0x80)\r\nbreak;\r\n}\r\nfor(i = 0; i < 0x1000; ++i) {\r\npci_read_config_byte(dev, 0x5b, &scr2);\r\nif(!(scr2 & 0x80))\r\nreturn 0;\r\n}\r\npci_read_config_dword (dev, 0x5c, &dpll);\r\npci_write_config_dword(dev, 0x5c, (dpll & ~0x100));\r\nreturn 1;\r\n}\r\nstatic void hpt3xx_disable_fast_irq(struct pci_dev *dev, u8 mcr_addr)\r\n{\r\nstruct ide_host *host = pci_get_drvdata(dev);\r\nstruct hpt_info *info = host->host_priv + (&dev->dev == host->dev[1]);\r\nu8 chip_type = info->chip_type;\r\nu8 new_mcr, old_mcr = 0;\r\npci_read_config_byte(dev, mcr_addr + 1, &old_mcr);\r\nif (chip_type >= HPT374)\r\nnew_mcr = old_mcr & ~0x07;\r\nelse if (chip_type >= HPT370) {\r\nnew_mcr = old_mcr;\r\nnew_mcr &= ~0x02;\r\n#ifdef HPT_DELAY_INTERRUPT\r\nnew_mcr &= ~0x01;\r\n#else\r\nnew_mcr |= 0x01;\r\n#endif\r\n} else\r\nnew_mcr = old_mcr & ~0x80;\r\nif (new_mcr != old_mcr)\r\npci_write_config_byte(dev, mcr_addr + 1, new_mcr);\r\n}\r\nstatic int init_chipset_hpt366(struct pci_dev *dev)\r\n{\r\nunsigned long io_base = pci_resource_start(dev, 4);\r\nstruct hpt_info *info = hpt3xx_get_info(&dev->dev);\r\nconst char *name = DRV_NAME;\r\nu8 pci_clk, dpll_clk = 0;\r\nu8 chip_type;\r\nenum ata_clock clock;\r\nchip_type = info->chip_type;\r\npci_write_config_byte(dev, PCI_CACHE_LINE_SIZE, (L1_CACHE_BYTES / 4));\r\npci_write_config_byte(dev, PCI_LATENCY_TIMER, 0x78);\r\npci_write_config_byte(dev, PCI_MIN_GNT, 0x08);\r\npci_write_config_byte(dev, PCI_MAX_LAT, 0x08);\r\nif (chip_type >= HPT370) {\r\nu8 scr1 = 0;\r\nu16 f_cnt = 0;\r\nu32 temp = 0;\r\npci_read_config_byte(dev, 0x5a, &scr1);\r\nif (scr1 & 0x10)\r\npci_write_config_byte(dev, 0x5a, scr1 & ~0x10);\r\nif (chip_type == HPT372A)\r\noutb(0x0e, io_base + 0x9c);\r\npci_write_config_byte(dev, 0x5b, 0x23);\r\nif (chip_type == HPT374 && (PCI_FUNC(dev->devfn) & 1)) {\r\nstruct pci_dev *dev1 = pci_get_slot(dev->bus,\r\ndev->devfn - 1);\r\nunsigned long io_base = pci_resource_start(dev1, 4);\r\ntemp = inl(io_base + 0x90);\r\npci_dev_put(dev1);\r\n} else\r\ntemp = inl(io_base + 0x90);\r\nif ((temp & 0xFFFFF000) != 0xABCDE000) {\r\nint i;\r\nprintk(KERN_WARNING "%s %s: no clock data saved by "\r\n"BIOS\n", name, pci_name(dev));\r\nfor (temp = i = 0; i < 128; i++) {\r\npci_read_config_word(dev, 0x78, &f_cnt);\r\ntemp += f_cnt & 0x1ff;\r\nmdelay(1);\r\n}\r\nf_cnt = temp / 128;\r\n} else\r\nf_cnt = temp & 0x1ff;\r\ndpll_clk = info->dpll_clk;\r\npci_clk = (f_cnt * dpll_clk) / 192;\r\nif (pci_clk < 40)\r\npci_clk = 33;\r\nelse if(pci_clk < 45)\r\npci_clk = 40;\r\nelse if(pci_clk < 55)\r\npci_clk = 50;\r\nelse\r\npci_clk = 66;\r\nprintk(KERN_INFO "%s %s: DPLL base: %d MHz, f_CNT: %d, "\r\n"assuming %d MHz PCI\n", name, pci_name(dev),\r\ndpll_clk, f_cnt, pci_clk);\r\n} else {\r\nu32 itr1 = 0;\r\npci_read_config_dword(dev, 0x40, &itr1);\r\nswitch((itr1 >> 8) & 0x07) {\r\ncase 0x09:\r\npci_clk = 40;\r\nbreak;\r\ncase 0x05:\r\npci_clk = 25;\r\nbreak;\r\ncase 0x07:\r\ndefault:\r\npci_clk = 33;\r\nbreak;\r\n}\r\n}\r\nswitch (pci_clk) {\r\ncase 25:\r\nclock = ATA_CLOCK_25MHZ;\r\nbreak;\r\ncase 33:\r\ndefault:\r\nclock = ATA_CLOCK_33MHZ;\r\nbreak;\r\ncase 40:\r\nclock = ATA_CLOCK_40MHZ;\r\nbreak;\r\ncase 50:\r\nclock = ATA_CLOCK_50MHZ;\r\nbreak;\r\ncase 66:\r\nclock = ATA_CLOCK_66MHZ;\r\nbreak;\r\n}\r\nif (chip_type >= HPT374 || info->timings->clock_table[clock] == NULL) {\r\nu16 f_low, delta = pci_clk < 50 ? 2 : 4;\r\nint adjust;\r\nif (info->udma_mask == ATA_UDMA6) {\r\ndpll_clk = 66;\r\nclock = ATA_CLOCK_66MHZ;\r\n} else if (dpll_clk) {\r\ndpll_clk = 50;\r\nclock = ATA_CLOCK_50MHZ;\r\n}\r\nif (info->timings->clock_table[clock] == NULL) {\r\nprintk(KERN_ERR "%s %s: unknown bus timing!\n",\r\nname, pci_name(dev));\r\nreturn -EIO;\r\n}\r\npci_write_config_byte(dev, 0x5b, 0x21);\r\nf_low = (pci_clk * 48) / dpll_clk;\r\nfor (adjust = 0; adjust < 8; adjust++) {\r\nif(hpt37x_calibrate_dpll(dev, f_low, f_low + delta))\r\nbreak;\r\nif (adjust & 1)\r\nf_low -= adjust >> 1;\r\nelse\r\nf_low += adjust >> 1;\r\n}\r\nif (adjust == 8) {\r\nprintk(KERN_ERR "%s %s: DPLL did not stabilize!\n",\r\nname, pci_name(dev));\r\nreturn -EIO;\r\n}\r\nprintk(KERN_INFO "%s %s: using %d MHz DPLL clock\n",\r\nname, pci_name(dev), dpll_clk);\r\n} else {\r\ndpll_clk = 0;\r\nprintk(KERN_INFO "%s %s: using %d MHz PCI clock\n",\r\nname, pci_name(dev), pci_clk);\r\n}\r\ninfo->dpll_clk = dpll_clk;\r\ninfo->pci_clk = pci_clk;\r\ninfo->clock = clock;\r\nif (chip_type >= HPT370) {\r\nu8 mcr1, mcr4;\r\npci_read_config_byte (dev, 0x50, &mcr1);\r\npci_read_config_byte (dev, 0x54, &mcr4);\r\npci_write_config_byte(dev, 0x50, (mcr1 | 0x32));\r\npci_write_config_byte(dev, 0x54, (mcr4 | 0x32));\r\nudelay(100);\r\n}\r\nif (chip_type == HPT371N && clock == ATA_CLOCK_66MHZ)\r\noutb(inb(io_base + 0x9c) | 0x04, io_base + 0x9c);\r\nhpt3xx_disable_fast_irq(dev, 0x50);\r\nhpt3xx_disable_fast_irq(dev, 0x54);\r\nreturn 0;\r\n}\r\nstatic u8 hpt3xx_cable_detect(ide_hwif_t *hwif)\r\n{\r\nstruct pci_dev *dev = to_pci_dev(hwif->dev);\r\nstruct hpt_info *info = hpt3xx_get_info(hwif->dev);\r\nu8 chip_type = info->chip_type;\r\nu8 scr1 = 0, ata66 = hwif->channel ? 0x01 : 0x02;\r\nif (chip_type == HPT374 && (PCI_FUNC(dev->devfn) & 1)) {\r\nu8 mcr_addr = hwif->select_data + 2;\r\nu16 mcr;\r\npci_read_config_word(dev, mcr_addr, &mcr);\r\npci_write_config_word(dev, mcr_addr, mcr | 0x8000);\r\nudelay(10);\r\npci_read_config_byte(dev, 0x5a, &scr1);\r\npci_write_config_word(dev, mcr_addr, mcr);\r\n} else if (chip_type >= HPT370) {\r\nu8 scr2 = 0;\r\npci_read_config_byte(dev, 0x5b, &scr2);\r\npci_write_config_byte(dev, 0x5b, scr2 & ~1);\r\nudelay(10);\r\npci_read_config_byte(dev, 0x5a, &scr1);\r\npci_write_config_byte(dev, 0x5b, scr2);\r\n} else\r\npci_read_config_byte(dev, 0x5a, &scr1);\r\nreturn (scr1 & ata66) ? ATA_CBL_PATA40 : ATA_CBL_PATA80;\r\n}\r\nstatic void init_hwif_hpt366(ide_hwif_t *hwif)\r\n{\r\nstruct hpt_info *info = hpt3xx_get_info(hwif->dev);\r\nu8 chip_type = info->chip_type;\r\nhwif->select_data = hwif->channel ? 0x54 : 0x50;\r\nif (chip_type >= HPT372N && info->dpll_clk && info->pci_clk < 66) {\r\nhwif->host->host_flags |= IDE_HFLAG_SERIALIZE;\r\nhwif->rw_disk = &hpt3xxn_rw_disk;\r\n}\r\n}\r\nstatic int init_dma_hpt366(ide_hwif_t *hwif,\r\nconst struct ide_port_info *d)\r\n{\r\nstruct pci_dev *dev = to_pci_dev(hwif->dev);\r\nunsigned long flags, base = ide_pci_dma_base(hwif, d);\r\nu8 dma_old, dma_new, masterdma = 0, slavedma = 0;\r\nif (base == 0)\r\nreturn -1;\r\nhwif->dma_base = base;\r\nif (ide_pci_check_simplex(hwif, d) < 0)\r\nreturn -1;\r\nif (ide_pci_set_master(dev, d->name) < 0)\r\nreturn -1;\r\ndma_old = inb(base + 2);\r\nlocal_irq_save(flags);\r\ndma_new = dma_old;\r\npci_read_config_byte(dev, hwif->channel ? 0x4b : 0x43, &masterdma);\r\npci_read_config_byte(dev, hwif->channel ? 0x4f : 0x47, &slavedma);\r\nif (masterdma & 0x30) dma_new |= 0x20;\r\nif ( slavedma & 0x30) dma_new |= 0x40;\r\nif (dma_new != dma_old)\r\noutb(dma_new, base + 2);\r\nlocal_irq_restore(flags);\r\nprintk(KERN_INFO " %s: BM-DMA at 0x%04lx-0x%04lx\n",\r\nhwif->name, base, base + 7);\r\nhwif->extra_base = base + (hwif->channel ? 8 : 16);\r\nif (ide_allocate_dma_engine(hwif))\r\nreturn -1;\r\nreturn 0;\r\n}\r\nstatic void hpt374_init(struct pci_dev *dev, struct pci_dev *dev2)\r\n{\r\nif (dev2->irq != dev->irq) {\r\ndev2->irq = dev->irq;\r\nprintk(KERN_INFO DRV_NAME " %s: PCI config space interrupt "\r\n"fixed\n", pci_name(dev2));\r\n}\r\n}\r\nstatic void hpt371_init(struct pci_dev *dev)\r\n{\r\nu8 mcr1 = 0;\r\npci_read_config_byte(dev, 0x50, &mcr1);\r\nif (mcr1 & 0x04)\r\npci_write_config_byte(dev, 0x50, mcr1 & ~0x04);\r\n}\r\nstatic int hpt36x_init(struct pci_dev *dev, struct pci_dev *dev2)\r\n{\r\nu8 mcr1 = 0, pin1 = 0, pin2 = 0;\r\npci_read_config_byte(dev, 0x50, &mcr1);\r\nif (mcr1 & 0x30)\r\npci_write_config_byte(dev, 0x50, mcr1 | 0x30);\r\npci_read_config_byte(dev, PCI_INTERRUPT_PIN, &pin1);\r\npci_read_config_byte(dev2, PCI_INTERRUPT_PIN, &pin2);\r\nif (pin1 != pin2 && dev->irq == dev2->irq) {\r\nprintk(KERN_INFO DRV_NAME " %s: onboard version of chipset, "\r\n"pin1=%d pin2=%d\n", pci_name(dev), pin1, pin2);\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}\r\nstatic int hpt366_init_one(struct pci_dev *dev, const struct pci_device_id *id)\r\n{\r\nconst struct hpt_info *info = NULL;\r\nstruct hpt_info *dyn_info;\r\nstruct pci_dev *dev2 = NULL;\r\nstruct ide_port_info d;\r\nu8 idx = id->driver_data;\r\nu8 rev = dev->revision;\r\nint ret;\r\nif ((idx == 0 || idx == 4) && (PCI_FUNC(dev->devfn) & 1))\r\nreturn -ENODEV;\r\nswitch (idx) {\r\ncase 0:\r\nif (rev < 3)\r\ninfo = &hpt36x;\r\nelse {\r\nswitch (min_t(u8, rev, 6)) {\r\ncase 3: info = &hpt370; break;\r\ncase 4: info = &hpt370a; break;\r\ncase 5: info = &hpt372; break;\r\ncase 6: info = &hpt372n; break;\r\n}\r\nidx++;\r\n}\r\nbreak;\r\ncase 1:\r\ninfo = (rev > 1) ? &hpt372n : &hpt372a;\r\nbreak;\r\ncase 2:\r\ninfo = (rev > 1) ? &hpt302n : &hpt302;\r\nbreak;\r\ncase 3:\r\nhpt371_init(dev);\r\ninfo = (rev > 1) ? &hpt371n : &hpt371;\r\nbreak;\r\ncase 4:\r\ninfo = &hpt374;\r\nbreak;\r\ncase 5:\r\ninfo = &hpt372n;\r\nbreak;\r\n}\r\nprintk(KERN_INFO DRV_NAME ": %s chipset detected\n", info->chip_name);\r\nd = hpt366_chipsets[min_t(u8, idx, 1)];\r\nd.udma_mask = info->udma_mask;\r\nif (info == &hpt370 || info == &hpt370a)\r\nd.dma_ops = &hpt370_dma_ops;\r\nif (info == &hpt36x || info == &hpt374)\r\ndev2 = pci_get_slot(dev->bus, dev->devfn + 1);\r\ndyn_info = kzalloc(sizeof(*dyn_info) * (dev2 ? 2 : 1), GFP_KERNEL);\r\nif (dyn_info == NULL) {\r\nprintk(KERN_ERR "%s %s: out of memory!\n",\r\nd.name, pci_name(dev));\r\npci_dev_put(dev2);\r\nreturn -ENOMEM;\r\n}\r\nmemcpy(dyn_info, info, sizeof(*dyn_info));\r\nif (dev2) {\r\nmemcpy(dyn_info + 1, info, sizeof(*dyn_info));\r\nif (info == &hpt374)\r\nhpt374_init(dev, dev2);\r\nelse {\r\nif (hpt36x_init(dev, dev2))\r\nd.host_flags &= ~IDE_HFLAG_NON_BOOTABLE;\r\n}\r\nret = ide_pci_init_two(dev, dev2, &d, dyn_info);\r\nif (ret < 0) {\r\npci_dev_put(dev2);\r\nkfree(dyn_info);\r\n}\r\nreturn ret;\r\n}\r\nret = ide_pci_init_one(dev, &d, dyn_info);\r\nif (ret < 0)\r\nkfree(dyn_info);\r\nreturn ret;\r\n}\r\nstatic void hpt366_remove(struct pci_dev *dev)\r\n{\r\nstruct ide_host *host = pci_get_drvdata(dev);\r\nstruct ide_info *info = host->host_priv;\r\nstruct pci_dev *dev2 = host->dev[1] ? to_pci_dev(host->dev[1]) : NULL;\r\nide_pci_remove(dev);\r\npci_dev_put(dev2);\r\nkfree(info);\r\n}\r\nstatic int __init hpt366_ide_init(void)\r\n{\r\nreturn ide_pci_register_driver(&hpt366_pci_driver);\r\n}\r\nstatic void __exit hpt366_ide_exit(void)\r\n{\r\npci_unregister_driver(&hpt366_pci_driver);\r\n}
