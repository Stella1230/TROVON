int npe_running(struct npe *npe)\r\n{\r\nreturn (__raw_readl(&npe->regs->exec_status_cmd) & STAT_RUN) != 0;\r\n}\r\nstatic void npe_cmd_write(struct npe *npe, u32 addr, int cmd, u32 data)\r\n{\r\n__raw_writel(data, &npe->regs->exec_data);\r\n__raw_writel(addr, &npe->regs->exec_addr);\r\n__raw_writel(cmd, &npe->regs->exec_status_cmd);\r\n}\r\nstatic u32 npe_cmd_read(struct npe *npe, u32 addr, int cmd)\r\n{\r\n__raw_writel(addr, &npe->regs->exec_addr);\r\n__raw_writel(cmd, &npe->regs->exec_status_cmd);\r\n__raw_readl(&npe->regs->exec_data);\r\n__raw_readl(&npe->regs->exec_data);\r\nreturn __raw_readl(&npe->regs->exec_data);\r\n}\r\nstatic void npe_clear_active(struct npe *npe, u32 reg)\r\n{\r\nu32 val = npe_cmd_read(npe, reg, CMD_RD_ECS_REG);\r\nnpe_cmd_write(npe, reg, CMD_WR_ECS_REG, val & ~ECS_REG_0_ACTIVE);\r\n}\r\nstatic void npe_start(struct npe *npe)\r\n{\r\nnpe_clear_active(npe, ECS_PRI_1_CTXT_REG_0);\r\nnpe_clear_active(npe, ECS_PRI_2_CTXT_REG_0);\r\nnpe_clear_active(npe, ECS_DBG_CTXT_REG_0);\r\n__raw_writel(CMD_NPE_CLR_PIPE, &npe->regs->exec_status_cmd);\r\n__raw_writel(CMD_NPE_START, &npe->regs->exec_status_cmd);\r\n}\r\nstatic void npe_stop(struct npe *npe)\r\n{\r\n__raw_writel(CMD_NPE_STOP, &npe->regs->exec_status_cmd);\r\n__raw_writel(CMD_NPE_CLR_PIPE, &npe->regs->exec_status_cmd);\r\n}\r\nstatic int __must_check npe_debug_instr(struct npe *npe, u32 instr, u32 ctx,\r\nu32 ldur)\r\n{\r\nu32 wc;\r\nint i;\r\nnpe_cmd_write(npe, ECS_DBG_CTXT_REG_0, CMD_WR_ECS_REG,\r\nECS_REG_0_ACTIVE | (ldur << ECS_REG_0_LDUR_BITS));\r\nnpe_cmd_write(npe, ECS_DBG_CTXT_REG_1, CMD_WR_ECS_REG,\r\n(ctx << ECS_REG_1_CCTXT_BITS) |\r\n(ctx << ECS_REG_1_SELCTXT_BITS));\r\n__raw_writel(CMD_NPE_CLR_PIPE, &npe->regs->exec_status_cmd);\r\nnpe_cmd_write(npe, ECS_INSTRUCT_REG, CMD_WR_ECS_REG, instr);\r\nwc = __raw_readl(&npe->regs->watch_count);\r\n__raw_writel(CMD_NPE_STEP, &npe->regs->exec_status_cmd);\r\nfor (i = 0; i < MAX_RETRIES; i++) {\r\nif (wc != __raw_readl(&npe->regs->watch_count))\r\nreturn 0;\r\nudelay(1);\r\n}\r\nprint_npe(KERN_ERR, npe, "reset: npe_debug_instr(): timeout\n");\r\nreturn -ETIMEDOUT;\r\n}\r\nstatic int __must_check npe_logical_reg_write8(struct npe *npe, u32 addr,\r\nu8 val, u32 ctx)\r\n{\r\nu32 instr = INSTR_WR_REG_BYTE |\r\naddr << 9 |\r\n(val & 0x1F) << 4 |\r\n(val & ~0x1F) << (18 - 5);\r\nreturn npe_debug_instr(npe, instr, ctx, 1);\r\n}\r\nstatic int __must_check npe_logical_reg_write16(struct npe *npe, u32 addr,\r\nu16 val, u32 ctx)\r\n{\r\nu32 instr = INSTR_WR_REG_SHORT |\r\naddr << 9 |\r\n(val & 0x1F) << 4 |\r\n(val & ~0x1F) << (18 - 5);\r\nreturn npe_debug_instr(npe, instr, ctx, 1);\r\n}\r\nstatic int __must_check npe_logical_reg_write32(struct npe *npe, u32 addr,\r\nu32 val, u32 ctx)\r\n{\r\nif (npe_logical_reg_write16(npe, addr, val >> 16, ctx))\r\nreturn -ETIMEDOUT;\r\nreturn npe_logical_reg_write16(npe, addr + 2, val & 0xFFFF, ctx);\r\n}\r\nstatic int npe_reset(struct npe *npe)\r\n{\r\nu32 val, ctl, exec_count, ctx_reg2;\r\nint i;\r\nctl = (__raw_readl(&npe->regs->messaging_control) | 0x3F000000) &\r\n0x3F3FFFFF;\r\n__raw_writel(ctl & 0x3F00FFFF, &npe->regs->messaging_control);\r\nexec_count = __raw_readl(&npe->regs->exec_count);\r\n__raw_writel(0, &npe->regs->exec_count);\r\nctx_reg2 = npe_cmd_read(npe, ECS_DBG_CTXT_REG_2, CMD_RD_ECS_REG);\r\nnpe_cmd_write(npe, ECS_DBG_CTXT_REG_2, CMD_WR_ECS_REG, ctx_reg2 |\r\nECS_DBG_REG_2_IF | ECS_DBG_REG_2_IE);\r\nwhile (__raw_readl(&npe->regs->watchpoint_fifo) & WFIFO_VALID)\r\n;\r\nwhile (__raw_readl(&npe->regs->messaging_status) & MSGSTAT_OFNE)\r\nprint_npe(KERN_DEBUG, npe, "npe_reset: read FIFO = 0x%X\n",\r\n__raw_readl(&npe->regs->in_out_fifo));\r\nwhile (__raw_readl(&npe->regs->messaging_status) & MSGSTAT_IFNE)\r\nif (npe_debug_instr(npe, INSTR_RD_FIFO, 0, 0))\r\nreturn -ETIMEDOUT;\r\n__raw_writel(RESET_MBOX_STAT, &npe->regs->mailbox_status);\r\nif (npe_debug_instr(npe, INSTR_RESET_MBOX, 0, 0))\r\nreturn -ETIMEDOUT;\r\nfor (val = 0; val < NPE_PHYS_REG; val++) {\r\nif (npe_logical_reg_write16(npe, NPE_REGMAP, val >> 1, 0))\r\nreturn -ETIMEDOUT;\r\nif (npe_logical_reg_write32(npe, (val & 1) * 4, 0, 0))\r\nreturn -ETIMEDOUT;\r\n}\r\nval = npe_cmd_read(npe, ECS_BG_CTXT_REG_0, CMD_RD_ECS_REG);\r\nval &= ~ECS_REG_0_NEXTPC_MASK;\r\nval |= (0 << 16) & ECS_REG_0_NEXTPC_MASK;\r\nnpe_cmd_write(npe, ECS_BG_CTXT_REG_0, CMD_WR_ECS_REG, val);\r\nfor (i = 0; i < 16; i++) {\r\nif (i) {\r\nif (npe_logical_reg_write8(npe, NPE_STEVT, 0x80, i))\r\nreturn -ETIMEDOUT;\r\nif (npe_logical_reg_write16(npe, NPE_STARTPC, 0, i))\r\nreturn -ETIMEDOUT;\r\n}\r\nif (npe_logical_reg_write16(npe, NPE_REGMAP, 0x820, i))\r\nreturn -ETIMEDOUT;\r\nif (npe_logical_reg_write8(npe, NPE_CINDEX, 0, i))\r\nreturn -ETIMEDOUT;\r\n}\r\nnpe_cmd_write(npe, ECS_DBG_CTXT_REG_0, CMD_WR_ECS_REG, 0);\r\n__raw_writel(CMD_NPE_CLR_PIPE, &npe->regs->exec_status_cmd);\r\n__raw_writel(exec_count, &npe->regs->exec_count);\r\nnpe_cmd_write(npe, ECS_DBG_CTXT_REG_2, CMD_WR_ECS_REG, ctx_reg2);\r\nfor (val = 0; val < ARRAY_SIZE(ecs_reset); val++)\r\nnpe_cmd_write(npe, ecs_reset[val].reg, CMD_WR_ECS_REG,\r\necs_reset[val].val);\r\n__raw_writel(CMD_CLR_PROFILE_CNT, &npe->regs->exec_status_cmd);\r\n__raw_writel(0, &npe->regs->exec_count);\r\n__raw_writel(0, &npe->regs->action_points[0]);\r\n__raw_writel(0, &npe->regs->action_points[1]);\r\n__raw_writel(0, &npe->regs->action_points[2]);\r\n__raw_writel(0, &npe->regs->action_points[3]);\r\n__raw_writel(0, &npe->regs->watch_count);\r\nval = ixp4xx_read_feature_bits();\r\nixp4xx_write_feature_bits(val &\r\n~(IXP4XX_FEATURE_RESET_NPEA << npe->id));\r\nixp4xx_write_feature_bits(val |\r\n(IXP4XX_FEATURE_RESET_NPEA << npe->id));\r\nfor (i = 0; i < MAX_RETRIES; i++) {\r\nif (ixp4xx_read_feature_bits() &\r\n(IXP4XX_FEATURE_RESET_NPEA << npe->id))\r\nbreak;\r\nudelay(1);\r\n}\r\nif (i == MAX_RETRIES)\r\nreturn -ETIMEDOUT;\r\nnpe_stop(npe);\r\n__raw_writel(ctl, &npe->regs->messaging_control);\r\nreturn 0;\r\n}\r\nint npe_send_message(struct npe *npe, const void *msg, const char *what)\r\n{\r\nconst u32 *send = msg;\r\nint cycles = 0;\r\ndebug_msg(npe, "Trying to send message %s [%08X:%08X]\n",\r\nwhat, send[0], send[1]);\r\nif (__raw_readl(&npe->regs->messaging_status) & MSGSTAT_IFNE) {\r\ndebug_msg(npe, "NPE input FIFO not empty\n");\r\nreturn -EIO;\r\n}\r\n__raw_writel(send[0], &npe->regs->in_out_fifo);\r\nif (!(__raw_readl(&npe->regs->messaging_status) & MSGSTAT_IFNF)) {\r\ndebug_msg(npe, "NPE input FIFO full\n");\r\nreturn -EIO;\r\n}\r\n__raw_writel(send[1], &npe->regs->in_out_fifo);\r\nwhile ((cycles < MAX_RETRIES) &&\r\n(__raw_readl(&npe->regs->messaging_status) & MSGSTAT_IFNE)) {\r\nudelay(1);\r\ncycles++;\r\n}\r\nif (cycles == MAX_RETRIES) {\r\ndebug_msg(npe, "Timeout sending message\n");\r\nreturn -ETIMEDOUT;\r\n}\r\n#if DEBUG_MSG > 1\r\ndebug_msg(npe, "Sending a message took %i cycles\n", cycles);\r\n#endif\r\nreturn 0;\r\n}\r\nint npe_recv_message(struct npe *npe, void *msg, const char *what)\r\n{\r\nu32 *recv = msg;\r\nint cycles = 0, cnt = 0;\r\ndebug_msg(npe, "Trying to receive message %s\n", what);\r\nwhile (cycles < MAX_RETRIES) {\r\nif (__raw_readl(&npe->regs->messaging_status) & MSGSTAT_OFNE) {\r\nrecv[cnt++] = __raw_readl(&npe->regs->in_out_fifo);\r\nif (cnt == 2)\r\nbreak;\r\n} else {\r\nudelay(1);\r\ncycles++;\r\n}\r\n}\r\nswitch(cnt) {\r\ncase 1:\r\ndebug_msg(npe, "Received [%08X]\n", recv[0]);\r\nbreak;\r\ncase 2:\r\ndebug_msg(npe, "Received [%08X:%08X]\n", recv[0], recv[1]);\r\nbreak;\r\n}\r\nif (cycles == MAX_RETRIES) {\r\ndebug_msg(npe, "Timeout waiting for message\n");\r\nreturn -ETIMEDOUT;\r\n}\r\n#if DEBUG_MSG > 1\r\ndebug_msg(npe, "Receiving a message took %i cycles\n", cycles);\r\n#endif\r\nreturn 0;\r\n}\r\nint npe_send_recv_message(struct npe *npe, void *msg, const char *what)\r\n{\r\nint result;\r\nu32 *send = msg, recv[2];\r\nif ((result = npe_send_message(npe, msg, what)) != 0)\r\nreturn result;\r\nif ((result = npe_recv_message(npe, recv, what)) != 0)\r\nreturn result;\r\nif ((recv[0] != send[0]) || (recv[1] != send[1])) {\r\ndebug_msg(npe, "Message %s: unexpected message received\n",\r\nwhat);\r\nreturn -EIO;\r\n}\r\nreturn 0;\r\n}\r\nint npe_load_firmware(struct npe *npe, const char *name, struct device *dev)\r\n{\r\nconst struct firmware *fw_entry;\r\nstruct dl_block {\r\nu32 type;\r\nu32 offset;\r\n} *blk;\r\nstruct dl_image {\r\nu32 magic;\r\nu32 id;\r\nu32 size;\r\nunion {\r\nu32 data[0];\r\nstruct dl_block blocks[0];\r\n};\r\n} *image;\r\nstruct dl_codeblock {\r\nu32 npe_addr;\r\nu32 size;\r\nu32 data[0];\r\n} *cb;\r\nint i, j, err, data_size, instr_size, blocks, table_end;\r\nu32 cmd;\r\nif ((err = request_firmware(&fw_entry, name, dev)) != 0)\r\nreturn err;\r\nerr = -EINVAL;\r\nif (fw_entry->size < sizeof(struct dl_image)) {\r\nprint_npe(KERN_ERR, npe, "incomplete firmware file\n");\r\ngoto err;\r\n}\r\nimage = (struct dl_image*)fw_entry->data;\r\n#if DEBUG_FW\r\nprint_npe(KERN_DEBUG, npe, "firmware: %08X %08X %08X (0x%X bytes)\n",\r\nimage->magic, image->id, image->size, image->size * 4);\r\n#endif\r\nif (image->magic == swab32(FW_MAGIC)) {\r\nimage->id = swab32(image->id);\r\nimage->size = swab32(image->size);\r\n} else if (image->magic != FW_MAGIC) {\r\nprint_npe(KERN_ERR, npe, "bad firmware file magic: 0x%X\n",\r\nimage->magic);\r\ngoto err;\r\n}\r\nif ((image->size * 4 + sizeof(struct dl_image)) != fw_entry->size) {\r\nprint_npe(KERN_ERR, npe,\r\n"inconsistent size of firmware file\n");\r\ngoto err;\r\n}\r\nif (((image->id >> 24) & 0xF ) != npe->id) {\r\nprint_npe(KERN_ERR, npe, "firmware file NPE ID mismatch\n");\r\ngoto err;\r\n}\r\nif (image->magic == swab32(FW_MAGIC))\r\nfor (i = 0; i < image->size; i++)\r\nimage->data[i] = swab32(image->data[i]);\r\nif (cpu_is_ixp42x() && ((image->id >> 28) & 0xF )) {\r\nprint_npe(KERN_INFO, npe, "IXP43x/IXP46x firmware ignored on "\r\n"IXP42x\n");\r\ngoto err;\r\n}\r\nif (npe_running(npe)) {\r\nprint_npe(KERN_INFO, npe, "unable to load firmware, NPE is "\r\n"already running\n");\r\nerr = -EBUSY;\r\ngoto err;\r\n}\r\n#if 0\r\nnpe_stop(npe);\r\nnpe_reset(npe);\r\n#endif\r\nprint_npe(KERN_INFO, npe, "firmware functionality 0x%X, "\r\n"revision 0x%X:%X\n", (image->id >> 16) & 0xFF,\r\n(image->id >> 8) & 0xFF, image->id & 0xFF);\r\nif (cpu_is_ixp42x()) {\r\nif (!npe->id)\r\ninstr_size = NPE_A_42X_INSTR_SIZE;\r\nelse\r\ninstr_size = NPE_B_AND_C_42X_INSTR_SIZE;\r\ndata_size = NPE_42X_DATA_SIZE;\r\n} else {\r\ninstr_size = NPE_46X_INSTR_SIZE;\r\ndata_size = NPE_46X_DATA_SIZE;\r\n}\r\nfor (blocks = 0; blocks * sizeof(struct dl_block) / 4 < image->size;\r\nblocks++)\r\nif (image->blocks[blocks].type == FW_BLOCK_TYPE_EOF)\r\nbreak;\r\nif (blocks * sizeof(struct dl_block) / 4 >= image->size) {\r\nprint_npe(KERN_INFO, npe, "firmware EOF block marker not "\r\n"found\n");\r\ngoto err;\r\n}\r\n#if DEBUG_FW\r\nprint_npe(KERN_DEBUG, npe, "%i firmware blocks found\n", blocks);\r\n#endif\r\ntable_end = blocks * sizeof(struct dl_block) / 4 + 1 ;\r\nfor (i = 0, blk = image->blocks; i < blocks; i++, blk++) {\r\nif (blk->offset > image->size - sizeof(struct dl_codeblock) / 4\r\n|| blk->offset < table_end) {\r\nprint_npe(KERN_INFO, npe, "invalid offset 0x%X of "\r\n"firmware block #%i\n", blk->offset, i);\r\ngoto err;\r\n}\r\ncb = (struct dl_codeblock*)&image->data[blk->offset];\r\nif (blk->type == FW_BLOCK_TYPE_INSTR) {\r\nif (cb->npe_addr + cb->size > instr_size)\r\ngoto too_big;\r\ncmd = CMD_WR_INS_MEM;\r\n} else if (blk->type == FW_BLOCK_TYPE_DATA) {\r\nif (cb->npe_addr + cb->size > data_size)\r\ngoto too_big;\r\ncmd = CMD_WR_DATA_MEM;\r\n} else {\r\nprint_npe(KERN_INFO, npe, "invalid firmware block #%i "\r\n"type 0x%X\n", i, blk->type);\r\ngoto err;\r\n}\r\nif (blk->offset + sizeof(*cb) / 4 + cb->size > image->size) {\r\nprint_npe(KERN_INFO, npe, "firmware block #%i doesn't "\r\n"fit in firmware image: type %c, start 0x%X,"\r\n" length 0x%X\n", i,\r\nblk->type == FW_BLOCK_TYPE_INSTR ? 'I' : 'D',\r\ncb->npe_addr, cb->size);\r\ngoto err;\r\n}\r\nfor (j = 0; j < cb->size; j++)\r\nnpe_cmd_write(npe, cb->npe_addr + j, cmd, cb->data[j]);\r\n}\r\nnpe_start(npe);\r\nif (!npe_running(npe))\r\nprint_npe(KERN_ERR, npe, "unable to start\n");\r\nrelease_firmware(fw_entry);\r\nreturn 0;\r\ntoo_big:\r\nprint_npe(KERN_INFO, npe, "firmware block #%i doesn't fit in NPE "\r\n"memory: type %c, start 0x%X, length 0x%X\n", i,\r\nblk->type == FW_BLOCK_TYPE_INSTR ? 'I' : 'D',\r\ncb->npe_addr, cb->size);\r\nerr:\r\nrelease_firmware(fw_entry);\r\nreturn err;\r\n}\r\nstruct npe *npe_request(unsigned id)\r\n{\r\nif (id < NPE_COUNT)\r\nif (npe_tab[id].valid)\r\nif (try_module_get(THIS_MODULE))\r\nreturn &npe_tab[id];\r\nreturn NULL;\r\n}\r\nvoid npe_release(struct npe *npe)\r\n{\r\nmodule_put(THIS_MODULE);\r\n}\r\nstatic int __init npe_init_module(void)\r\n{\r\nint i, found = 0;\r\nfor (i = 0; i < NPE_COUNT; i++) {\r\nstruct npe *npe = &npe_tab[i];\r\nif (!(ixp4xx_read_feature_bits() &\r\n(IXP4XX_FEATURE_RESET_NPEA << i)))\r\ncontinue;\r\nif (!(npe->mem_res = request_mem_region(npe->regs_phys,\r\nREGS_SIZE,\r\nnpe_name(npe)))) {\r\nprint_npe(KERN_ERR, npe,\r\n"failed to request memory region\n");\r\ncontinue;\r\n}\r\nif (npe_reset(npe))\r\ncontinue;\r\nnpe->valid = 1;\r\nfound++;\r\n}\r\nif (!found)\r\nreturn -ENODEV;\r\nreturn 0;\r\n}\r\nstatic void __exit npe_cleanup_module(void)\r\n{\r\nint i;\r\nfor (i = 0; i < NPE_COUNT; i++)\r\nif (npe_tab[i].mem_res) {\r\nnpe_reset(&npe_tab[i]);\r\nrelease_resource(npe_tab[i].mem_res);\r\n}\r\n}
