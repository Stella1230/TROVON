static void tb_dump_hop(struct tb_port *port, struct tb_regs_hop *hop)\r\n{\r\ntb_port_info(port, " Hop through port %d to hop %d (%s)\n",\r\nhop->out_port, hop->next_hop,\r\nhop->enable ? "enabled" : "disabled");\r\ntb_port_info(port, " Weight: %d Priority: %d Credits: %d Drop: %d\n",\r\nhop->weight, hop->priority,\r\nhop->initial_credits, hop->drop_packages);\r\ntb_port_info(port, " Counter enabled: %d Counter index: %d\n",\r\nhop->counter_enable, hop->counter);\r\ntb_port_info(port, " Flow Control (In/Eg): %d/%d Shared Buffer (In/Eg): %d/%d\n",\r\nhop->ingress_fc, hop->egress_fc,\r\nhop->ingress_shared_buffer, hop->egress_shared_buffer);\r\ntb_port_info(port, " Unknown1: %#x Unknown2: %#x Unknown3: %#x\n",\r\nhop->unknown1, hop->unknown2, hop->unknown3);\r\n}\r\nstruct tb_path *tb_path_alloc(struct tb *tb, int num_hops)\r\n{\r\nstruct tb_path *path = kzalloc(sizeof(*path), GFP_KERNEL);\r\nif (!path)\r\nreturn NULL;\r\npath->hops = kcalloc(num_hops, sizeof(*path->hops), GFP_KERNEL);\r\nif (!path->hops) {\r\nkfree(path);\r\nreturn NULL;\r\n}\r\npath->tb = tb;\r\npath->path_length = num_hops;\r\nreturn path;\r\n}\r\nvoid tb_path_free(struct tb_path *path)\r\n{\r\nif (path->activated) {\r\ntb_WARN(path->tb, "trying to free an activated path\n")\r\nreturn;\r\n}\r\nkfree(path->hops);\r\nkfree(path);\r\n}\r\nstatic void __tb_path_deallocate_nfc(struct tb_path *path, int first_hop)\r\n{\r\nint i, res;\r\nfor (i = first_hop; i < path->path_length; i++) {\r\nres = tb_port_add_nfc_credits(path->hops[i].in_port,\r\n-path->nfc_credits);\r\nif (res)\r\ntb_port_warn(path->hops[i].in_port,\r\n"nfc credits deallocation failed for hop %d\n",\r\ni);\r\n}\r\n}\r\nstatic void __tb_path_deactivate_hops(struct tb_path *path, int first_hop)\r\n{\r\nint i, res;\r\nstruct tb_regs_hop hop = { };\r\nfor (i = first_hop; i < path->path_length; i++) {\r\nres = tb_port_write(path->hops[i].in_port, &hop, TB_CFG_HOPS,\r\n2 * path->hops[i].in_hop_index, 2);\r\nif (res)\r\ntb_port_warn(path->hops[i].in_port,\r\n"hop deactivation failed for hop %d, index %d\n",\r\ni, path->hops[i].in_hop_index);\r\n}\r\n}\r\nvoid tb_path_deactivate(struct tb_path *path)\r\n{\r\nif (!path->activated) {\r\ntb_WARN(path->tb, "trying to deactivate an inactive path\n");\r\nreturn;\r\n}\r\ntb_info(path->tb,\r\n"deactivating path from %llx:%x to %llx:%x\n",\r\ntb_route(path->hops[0].in_port->sw),\r\npath->hops[0].in_port->port,\r\ntb_route(path->hops[path->path_length - 1].out_port->sw),\r\npath->hops[path->path_length - 1].out_port->port);\r\n__tb_path_deactivate_hops(path, 0);\r\n__tb_path_deallocate_nfc(path, 0);\r\npath->activated = false;\r\n}\r\nint tb_path_activate(struct tb_path *path)\r\n{\r\nint i, res;\r\nenum tb_path_port out_mask, in_mask;\r\nif (path->activated) {\r\ntb_WARN(path->tb, "trying to activate already activated path\n");\r\nreturn -EINVAL;\r\n}\r\ntb_info(path->tb,\r\n"activating path from %llx:%x to %llx:%x\n",\r\ntb_route(path->hops[0].in_port->sw),\r\npath->hops[0].in_port->port,\r\ntb_route(path->hops[path->path_length - 1].out_port->sw),\r\npath->hops[path->path_length - 1].out_port->port);\r\nfor (i = path->path_length - 1; i >= 0; i--) {\r\nif (path->hops[i].in_counter_index == -1)\r\ncontinue;\r\nres = tb_port_clear_counter(path->hops[i].in_port,\r\npath->hops[i].in_counter_index);\r\nif (res)\r\ngoto err;\r\n}\r\nfor (i = path->path_length - 1; i >= 0; i--) {\r\nres = tb_port_add_nfc_credits(path->hops[i].in_port,\r\npath->nfc_credits);\r\nif (res) {\r\n__tb_path_deallocate_nfc(path, i);\r\ngoto err;\r\n}\r\n}\r\nfor (i = path->path_length - 1; i >= 0; i--) {\r\nstruct tb_regs_hop hop = { 0 };\r\nres = tb_port_write(path->hops[i].in_port, &hop, TB_CFG_HOPS,\r\n2 * path->hops[i].in_hop_index, 2);\r\nif (res) {\r\n__tb_path_deactivate_hops(path, i);\r\n__tb_path_deallocate_nfc(path, 0);\r\ngoto err;\r\n}\r\nhop.next_hop = path->hops[i].next_hop_index;\r\nhop.out_port = path->hops[i].out_port->port;\r\nhop.initial_credits = (i == path->path_length - 1) ? 16 : 7;\r\nhop.unknown1 = 0;\r\nhop.enable = 1;\r\nout_mask = (i == path->path_length - 1) ?\r\nTB_PATH_DESTINATION : TB_PATH_INTERNAL;\r\nin_mask = (i == 0) ? TB_PATH_SOURCE : TB_PATH_INTERNAL;\r\nhop.weight = path->weight;\r\nhop.unknown2 = 0;\r\nhop.priority = path->priority;\r\nhop.drop_packages = path->drop_packages;\r\nhop.counter = path->hops[i].in_counter_index;\r\nhop.counter_enable = path->hops[i].in_counter_index != -1;\r\nhop.ingress_fc = path->ingress_fc_enable & in_mask;\r\nhop.egress_fc = path->egress_fc_enable & out_mask;\r\nhop.ingress_shared_buffer = path->ingress_shared_buffer\r\n& in_mask;\r\nhop.egress_shared_buffer = path->egress_shared_buffer\r\n& out_mask;\r\nhop.unknown3 = 0;\r\ntb_port_info(path->hops[i].in_port, "Writing hop %d, index %d",\r\ni, path->hops[i].in_hop_index);\r\ntb_dump_hop(path->hops[i].in_port, &hop);\r\nres = tb_port_write(path->hops[i].in_port, &hop, TB_CFG_HOPS,\r\n2 * path->hops[i].in_hop_index, 2);\r\nif (res) {\r\n__tb_path_deactivate_hops(path, i);\r\n__tb_path_deallocate_nfc(path, 0);\r\ngoto err;\r\n}\r\n}\r\npath->activated = true;\r\ntb_info(path->tb, "path activation complete\n");\r\nreturn 0;\r\nerr:\r\ntb_WARN(path->tb, "path activation failed\n");\r\nreturn res;\r\n}\r\nbool tb_path_is_invalid(struct tb_path *path)\r\n{\r\nint i = 0;\r\nfor (i = 0; i < path->path_length; i++) {\r\nif (path->hops[i].in_port->sw->is_unplugged)\r\nreturn true;\r\nif (path->hops[i].out_port->sw->is_unplugged)\r\nreturn true;\r\n}\r\nreturn false;\r\n}
