static inline u32 gpt_readl(void __iomem *base, u32 offset, u32 gpt_id)\r\n{\r\nreturn readl(base + 0x20 * gpt_id + offset);\r\n}\r\nstatic inline void gpt_writel(void __iomem *base, u32 value, u32 offset,\r\nu32 gpt_id)\r\n{\r\nwritel(value, base + 0x20 * gpt_id + offset);\r\n}\r\nstatic cycle_t notrace\r\npistachio_clocksource_read_cycles(struct clocksource *cs)\r\n{\r\nstruct pistachio_clocksource *pcs = to_pistachio_clocksource(cs);\r\nu32 counter, overflw;\r\nunsigned long flags;\r\nraw_spin_lock_irqsave(&pcs->lock, flags);\r\noverflw = gpt_readl(pcs->base, TIMER_CURRENT_OVERFLOW_VALUE, 0);\r\ncounter = gpt_readl(pcs->base, TIMER_CURRENT_VALUE, 0);\r\nraw_spin_unlock_irqrestore(&pcs->lock, flags);\r\nreturn (cycle_t)~counter;\r\n}\r\nstatic u64 notrace pistachio_read_sched_clock(void)\r\n{\r\nreturn pistachio_clocksource_read_cycles(&pcs_gpt.cs);\r\n}\r\nstatic void pistachio_clksrc_set_mode(struct clocksource *cs, int timeridx,\r\nint enable)\r\n{\r\nstruct pistachio_clocksource *pcs = to_pistachio_clocksource(cs);\r\nu32 val;\r\nval = gpt_readl(pcs->base, TIMER_CFG, timeridx);\r\nif (enable)\r\nval |= TIMER_ME_LOCAL;\r\nelse\r\nval &= ~TIMER_ME_LOCAL;\r\ngpt_writel(pcs->base, val, TIMER_CFG, timeridx);\r\n}\r\nstatic void pistachio_clksrc_enable(struct clocksource *cs, int timeridx)\r\n{\r\nstruct pistachio_clocksource *pcs = to_pistachio_clocksource(cs);\r\npistachio_clksrc_set_mode(cs, timeridx, false);\r\ngpt_writel(pcs->base, RELOAD_VALUE, TIMER_RELOAD_VALUE, timeridx);\r\npistachio_clksrc_set_mode(cs, timeridx, true);\r\n}\r\nstatic void pistachio_clksrc_disable(struct clocksource *cs, int timeridx)\r\n{\r\npistachio_clksrc_set_mode(cs, timeridx, false);\r\n}\r\nstatic int pistachio_clocksource_enable(struct clocksource *cs)\r\n{\r\npistachio_clksrc_enable(cs, 0);\r\nreturn 0;\r\n}\r\nstatic void pistachio_clocksource_disable(struct clocksource *cs)\r\n{\r\npistachio_clksrc_disable(cs, 0);\r\n}\r\nstatic void __init pistachio_clksrc_of_init(struct device_node *node)\r\n{\r\nstruct clk *sys_clk, *fast_clk;\r\nstruct regmap *periph_regs;\r\nunsigned long rate;\r\nint ret;\r\npcs_gpt.base = of_iomap(node, 0);\r\nif (!pcs_gpt.base) {\r\npr_err("cannot iomap\n");\r\nreturn;\r\n}\r\nperiph_regs = syscon_regmap_lookup_by_phandle(node, "img,cr-periph");\r\nif (IS_ERR(periph_regs)) {\r\npr_err("cannot get peripheral regmap (%ld)\n",\r\nPTR_ERR(periph_regs));\r\nreturn;\r\n}\r\nret = regmap_update_bits(periph_regs, PERIP_TIMER_CONTROL,\r\n0xf, 0x0);\r\nif (ret)\r\nreturn;\r\nsys_clk = of_clk_get_by_name(node, "sys");\r\nif (IS_ERR(sys_clk)) {\r\npr_err("clock get failed (%ld)\n", PTR_ERR(sys_clk));\r\nreturn;\r\n}\r\nfast_clk = of_clk_get_by_name(node, "fast");\r\nif (IS_ERR(fast_clk)) {\r\npr_err("clock get failed (%lu)\n", PTR_ERR(fast_clk));\r\nreturn;\r\n}\r\nret = clk_prepare_enable(sys_clk);\r\nif (ret < 0) {\r\npr_err("failed to enable clock (%d)\n", ret);\r\nreturn;\r\n}\r\nret = clk_prepare_enable(fast_clk);\r\nif (ret < 0) {\r\npr_err("failed to enable clock (%d)\n", ret);\r\nclk_disable_unprepare(sys_clk);\r\nreturn;\r\n}\r\nrate = clk_get_rate(fast_clk);\r\ngpt_writel(&pcs_gpt.base, 0, TIMER_IRQ_MASK, 0);\r\ngpt_writel(&pcs_gpt.base, 0, TIMER_IRQ_MASK, 1);\r\ngpt_writel(&pcs_gpt.base, 0, TIMER_IRQ_MASK, 2);\r\ngpt_writel(&pcs_gpt.base, 0, TIMER_IRQ_MASK, 3);\r\nwritel(TIMER_ME_GLOBAL, pcs_gpt.base);\r\nraw_spin_lock_init(&pcs_gpt.lock);\r\nsched_clock_register(pistachio_read_sched_clock, 32, rate);\r\nclocksource_register_hz(&pcs_gpt.cs, rate);\r\n}
