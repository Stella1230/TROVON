void imx_gpc_set_arm_power_up_timing(u32 sw2iso, u32 sw)\r\n{\r\nwritel_relaxed((sw2iso << GPC_PGC_SW2ISO_SHIFT) |\r\n(sw << GPC_PGC_SW_SHIFT), gpc_base + GPC_PGC_CPU_PUPSCR);\r\n}\r\nvoid imx_gpc_set_arm_power_down_timing(u32 sw2iso, u32 sw)\r\n{\r\nwritel_relaxed((sw2iso << GPC_PGC_SW2ISO_SHIFT) |\r\n(sw << GPC_PGC_SW_SHIFT), gpc_base + GPC_PGC_CPU_PDNSCR);\r\n}\r\nvoid imx_gpc_set_arm_power_in_lpm(bool power_off)\r\n{\r\nwritel_relaxed(power_off, gpc_base + GPC_PGC_CPU_PDN);\r\n}\r\nvoid imx_gpc_pre_suspend(bool arm_power_off)\r\n{\r\nvoid __iomem *reg_imr1 = gpc_base + GPC_IMR1;\r\nint i;\r\nif (arm_power_off)\r\nimx_gpc_set_arm_power_in_lpm(arm_power_off);\r\nfor (i = 0; i < IMR_NUM; i++) {\r\ngpc_saved_imrs[i] = readl_relaxed(reg_imr1 + i * 4);\r\nwritel_relaxed(~gpc_wake_irqs[i], reg_imr1 + i * 4);\r\n}\r\n}\r\nvoid imx_gpc_post_resume(void)\r\n{\r\nvoid __iomem *reg_imr1 = gpc_base + GPC_IMR1;\r\nint i;\r\nimx_gpc_set_arm_power_in_lpm(false);\r\nfor (i = 0; i < IMR_NUM; i++)\r\nwritel_relaxed(gpc_saved_imrs[i], reg_imr1 + i * 4);\r\n}\r\nstatic int imx_gpc_irq_set_wake(struct irq_data *d, unsigned int on)\r\n{\r\nunsigned int idx = d->hwirq / 32;\r\nu32 mask;\r\nmask = 1 << d->hwirq % 32;\r\ngpc_wake_irqs[idx] = on ? gpc_wake_irqs[idx] | mask :\r\ngpc_wake_irqs[idx] & ~mask;\r\nreturn 0;\r\n}\r\nvoid imx_gpc_mask_all(void)\r\n{\r\nvoid __iomem *reg_imr1 = gpc_base + GPC_IMR1;\r\nint i;\r\nfor (i = 0; i < IMR_NUM; i++) {\r\ngpc_saved_imrs[i] = readl_relaxed(reg_imr1 + i * 4);\r\nwritel_relaxed(~0, reg_imr1 + i * 4);\r\n}\r\n}\r\nvoid imx_gpc_restore_all(void)\r\n{\r\nvoid __iomem *reg_imr1 = gpc_base + GPC_IMR1;\r\nint i;\r\nfor (i = 0; i < IMR_NUM; i++)\r\nwritel_relaxed(gpc_saved_imrs[i], reg_imr1 + i * 4);\r\n}\r\nvoid imx_gpc_hwirq_unmask(unsigned int hwirq)\r\n{\r\nvoid __iomem *reg;\r\nu32 val;\r\nreg = gpc_base + GPC_IMR1 + hwirq / 32 * 4;\r\nval = readl_relaxed(reg);\r\nval &= ~(1 << hwirq % 32);\r\nwritel_relaxed(val, reg);\r\n}\r\nvoid imx_gpc_hwirq_mask(unsigned int hwirq)\r\n{\r\nvoid __iomem *reg;\r\nu32 val;\r\nreg = gpc_base + GPC_IMR1 + hwirq / 32 * 4;\r\nval = readl_relaxed(reg);\r\nval |= 1 << (hwirq % 32);\r\nwritel_relaxed(val, reg);\r\n}\r\nstatic void imx_gpc_irq_unmask(struct irq_data *d)\r\n{\r\nimx_gpc_hwirq_unmask(d->hwirq);\r\nirq_chip_unmask_parent(d);\r\n}\r\nstatic void imx_gpc_irq_mask(struct irq_data *d)\r\n{\r\nimx_gpc_hwirq_mask(d->hwirq);\r\nirq_chip_mask_parent(d);\r\n}\r\nstatic int imx_gpc_domain_translate(struct irq_domain *d,\r\nstruct irq_fwspec *fwspec,\r\nunsigned long *hwirq,\r\nunsigned int *type)\r\n{\r\nif (is_of_node(fwspec->fwnode)) {\r\nif (fwspec->param_count != 3)\r\nreturn -EINVAL;\r\nif (fwspec->param[0] != 0)\r\nreturn -EINVAL;\r\n*hwirq = fwspec->param[1];\r\n*type = fwspec->param[2];\r\nreturn 0;\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int imx_gpc_domain_alloc(struct irq_domain *domain,\r\nunsigned int irq,\r\nunsigned int nr_irqs, void *data)\r\n{\r\nstruct irq_fwspec *fwspec = data;\r\nstruct irq_fwspec parent_fwspec;\r\nirq_hw_number_t hwirq;\r\nint i;\r\nif (fwspec->param_count != 3)\r\nreturn -EINVAL;\r\nif (fwspec->param[0] != 0)\r\nreturn -EINVAL;\r\nhwirq = fwspec->param[1];\r\nif (hwirq >= GPC_MAX_IRQS)\r\nreturn -EINVAL;\r\nfor (i = 0; i < nr_irqs; i++)\r\nirq_domain_set_hwirq_and_chip(domain, irq + i, hwirq + i,\r\n&imx_gpc_chip, NULL);\r\nparent_fwspec = *fwspec;\r\nparent_fwspec.fwnode = domain->parent->fwnode;\r\nreturn irq_domain_alloc_irqs_parent(domain, irq, nr_irqs,\r\n&parent_fwspec);\r\n}\r\nstatic int __init imx_gpc_init(struct device_node *node,\r\nstruct device_node *parent)\r\n{\r\nstruct irq_domain *parent_domain, *domain;\r\nint i;\r\nif (!parent) {\r\npr_err("%s: no parent, giving up\n", node->full_name);\r\nreturn -ENODEV;\r\n}\r\nparent_domain = irq_find_host(parent);\r\nif (!parent_domain) {\r\npr_err("%s: unable to obtain parent domain\n", node->full_name);\r\nreturn -ENXIO;\r\n}\r\ngpc_base = of_iomap(node, 0);\r\nif (WARN_ON(!gpc_base))\r\nreturn -ENOMEM;\r\ndomain = irq_domain_add_hierarchy(parent_domain, 0, GPC_MAX_IRQS,\r\nnode, &imx_gpc_domain_ops,\r\nNULL);\r\nif (!domain) {\r\niounmap(gpc_base);\r\nreturn -ENOMEM;\r\n}\r\nfor (i = 0; i < IMR_NUM; i++)\r\nwritel_relaxed(~0, gpc_base + GPC_IMR1 + i * 4);\r\nreturn 0;\r\n}\r\nvoid __init imx_gpc_check_dt(void)\r\n{\r\nstruct device_node *np;\r\nnp = of_find_compatible_node(NULL, NULL, "fsl,imx6q-gpc");\r\nif (WARN_ON(!np))\r\nreturn;\r\nif (WARN_ON(!of_find_property(np, "interrupt-controller", NULL))) {\r\npr_warn("Outdated DT detected, suspend/resume will NOT work\n");\r\ngpc_base = of_iomap(np, 0);\r\n}\r\n}\r\nstatic void _imx6q_pm_pu_power_off(struct generic_pm_domain *genpd)\r\n{\r\nint iso, iso2sw;\r\nu32 val;\r\nval = readl_relaxed(gpc_base + GPC_PGC_GPU_PDNSCR);\r\niso = val & 0x3f;\r\niso2sw = (val >> 8) & 0x3f;\r\nwritel_relaxed(0x1, gpc_base + GPC_PGC_GPU_PDN);\r\nval = readl_relaxed(gpc_base + GPC_CNTR);\r\nval |= GPU_VPU_PDN_REQ;\r\nwritel_relaxed(val, gpc_base + GPC_CNTR);\r\nndelay((iso + iso2sw) * 1000 / 66);\r\n}\r\nstatic int imx6q_pm_pu_power_off(struct generic_pm_domain *genpd)\r\n{\r\nstruct pu_domain *pu = container_of(genpd, struct pu_domain, base);\r\n_imx6q_pm_pu_power_off(genpd);\r\nif (pu->reg)\r\nregulator_disable(pu->reg);\r\nreturn 0;\r\n}\r\nstatic int imx6q_pm_pu_power_on(struct generic_pm_domain *genpd)\r\n{\r\nstruct pu_domain *pu = container_of(genpd, struct pu_domain, base);\r\nint i, ret, sw, sw2iso;\r\nu32 val;\r\nif (pu->reg)\r\nret = regulator_enable(pu->reg);\r\nif (pu->reg && ret) {\r\npr_err("%s: failed to enable regulator: %d\n", __func__, ret);\r\nreturn ret;\r\n}\r\nfor (i = 0; i < pu->num_clks; i++)\r\nclk_prepare_enable(pu->clk[i]);\r\nwritel_relaxed(0x1, gpc_base + GPC_PGC_GPU_PDN);\r\nval = readl_relaxed(gpc_base + GPC_PGC_GPU_PUPSCR);\r\nsw = val & 0x3f;\r\nsw2iso = (val >> 8) & 0x3f;\r\nval = readl_relaxed(gpc_base + GPC_CNTR);\r\nval |= GPU_VPU_PUP_REQ;\r\nwritel_relaxed(val, gpc_base + GPC_CNTR);\r\nndelay((sw + sw2iso) * 1000 / 66);\r\nfor (i = 0; i < pu->num_clks; i++)\r\nclk_disable_unprepare(pu->clk[i]);\r\nreturn 0;\r\n}\r\nstatic int imx_gpc_genpd_init(struct device *dev, struct regulator *pu_reg)\r\n{\r\nstruct clk *clk;\r\nint i;\r\nimx6q_pu_domain.reg = pu_reg;\r\nfor (i = 0; ; i++) {\r\nclk = of_clk_get(dev->of_node, i);\r\nif (IS_ERR(clk))\r\nbreak;\r\nif (i >= GPC_CLK_MAX) {\r\ndev_err(dev, "more than %d clocks\n", GPC_CLK_MAX);\r\ngoto clk_err;\r\n}\r\nimx6q_pu_domain.clk[i] = clk;\r\n}\r\nimx6q_pu_domain.num_clks = i;\r\nimx6q_pm_pu_power_on(&imx6q_pu_domain.base);\r\nif (!IS_ENABLED(CONFIG_PM_GENERIC_DOMAINS))\r\nreturn 0;\r\npm_genpd_init(&imx6q_pu_domain.base, NULL, false);\r\nreturn of_genpd_add_provider_onecell(dev->of_node,\r\n&imx_gpc_onecell_data);\r\nclk_err:\r\nwhile (i--)\r\nclk_put(imx6q_pu_domain.clk[i]);\r\nreturn -EINVAL;\r\n}\r\nstatic int imx_gpc_probe(struct platform_device *pdev)\r\n{\r\nstruct regulator *pu_reg;\r\nint ret;\r\nif (!of_property_read_bool(pdev->dev.of_node, "#power-domain-cells"))\r\nreturn 0;\r\npu_reg = devm_regulator_get_optional(&pdev->dev, "pu");\r\nif (PTR_ERR(pu_reg) == -ENODEV)\r\npu_reg = NULL;\r\nif (IS_ERR(pu_reg)) {\r\nret = PTR_ERR(pu_reg);\r\ndev_err(&pdev->dev, "failed to get pu regulator: %d\n", ret);\r\nreturn ret;\r\n}\r\nreturn imx_gpc_genpd_init(&pdev->dev, pu_reg);\r\n}\r\nstatic int __init imx_pgc_init(void)\r\n{\r\nreturn platform_driver_register(&imx_gpc_driver);\r\n}
