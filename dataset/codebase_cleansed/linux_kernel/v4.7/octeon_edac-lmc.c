static void octeon_lmc_edac_poll(struct mem_ctl_info *mci)\r\n{\r\nunion cvmx_lmcx_mem_cfg0 cfg0;\r\nbool do_clear = false;\r\nchar msg[64];\r\ncfg0.u64 = cvmx_read_csr(CVMX_LMCX_MEM_CFG0(mci->mc_idx));\r\nif (cfg0.s.sec_err || cfg0.s.ded_err) {\r\nunion cvmx_lmcx_fadr fadr;\r\nfadr.u64 = cvmx_read_csr(CVMX_LMCX_FADR(mci->mc_idx));\r\nsnprintf(msg, sizeof(msg),\r\n"DIMM %d rank %d bank %d row %d col %d",\r\nfadr.cn30xx.fdimm, fadr.cn30xx.fbunk,\r\nfadr.cn30xx.fbank, fadr.cn30xx.frow, fadr.cn30xx.fcol);\r\n}\r\nif (cfg0.s.sec_err) {\r\nedac_mc_handle_error(HW_EVENT_ERR_CORRECTED, mci, 1, 0, 0, 0,\r\n-1, -1, -1, msg, "");\r\ncfg0.s.sec_err = -1;\r\ndo_clear = true;\r\n}\r\nif (cfg0.s.ded_err) {\r\nedac_mc_handle_error(HW_EVENT_ERR_UNCORRECTED, mci, 1, 0, 0, 0,\r\n-1, -1, -1, msg, "");\r\ncfg0.s.ded_err = -1;\r\ndo_clear = true;\r\n}\r\nif (do_clear)\r\ncvmx_write_csr(CVMX_LMCX_MEM_CFG0(mci->mc_idx), cfg0.u64);\r\n}\r\nstatic void octeon_lmc_edac_poll_o2(struct mem_ctl_info *mci)\r\n{\r\nstruct octeon_lmc_pvt *pvt = mci->pvt_info;\r\nunion cvmx_lmcx_int int_reg;\r\nbool do_clear = false;\r\nchar msg[64];\r\nif (!pvt->inject)\r\nint_reg.u64 = cvmx_read_csr(CVMX_LMCX_INT(mci->mc_idx));\r\nelse {\r\nif (pvt->error_type == 1)\r\nint_reg.s.sec_err = 1;\r\nif (pvt->error_type == 2)\r\nint_reg.s.ded_err = 1;\r\n}\r\nif (int_reg.s.sec_err || int_reg.s.ded_err) {\r\nunion cvmx_lmcx_fadr fadr;\r\nif (likely(!pvt->inject))\r\nfadr.u64 = cvmx_read_csr(CVMX_LMCX_FADR(mci->mc_idx));\r\nelse {\r\nfadr.cn61xx.fdimm = pvt->dimm;\r\nfadr.cn61xx.fbunk = pvt->rank;\r\nfadr.cn61xx.fbank = pvt->bank;\r\nfadr.cn61xx.frow = pvt->row;\r\nfadr.cn61xx.fcol = pvt->col;\r\n}\r\nsnprintf(msg, sizeof(msg),\r\n"DIMM %d rank %d bank %d row %d col %d",\r\nfadr.cn61xx.fdimm, fadr.cn61xx.fbunk,\r\nfadr.cn61xx.fbank, fadr.cn61xx.frow, fadr.cn61xx.fcol);\r\n}\r\nif (int_reg.s.sec_err) {\r\nedac_mc_handle_error(HW_EVENT_ERR_CORRECTED, mci, 1, 0, 0, 0,\r\n-1, -1, -1, msg, "");\r\nint_reg.s.sec_err = -1;\r\ndo_clear = true;\r\n}\r\nif (int_reg.s.ded_err) {\r\nedac_mc_handle_error(HW_EVENT_ERR_UNCORRECTED, mci, 1, 0, 0, 0,\r\n-1, -1, -1, msg, "");\r\nint_reg.s.ded_err = -1;\r\ndo_clear = true;\r\n}\r\nif (do_clear) {\r\nif (likely(!pvt->inject))\r\ncvmx_write_csr(CVMX_LMCX_INT(mci->mc_idx), int_reg.u64);\r\nelse\r\npvt->inject = 0;\r\n}\r\n}\r\nstatic ssize_t octeon_mc_inject_error_type_store(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *data,\r\nsize_t count)\r\n{\r\nstruct mem_ctl_info *mci = to_mci(dev);\r\nstruct octeon_lmc_pvt *pvt = mci->pvt_info;\r\nif (!strncmp(data, "single", 6))\r\npvt->error_type = 1;\r\nelse if (!strncmp(data, "double", 6))\r\npvt->error_type = 2;\r\nreturn count;\r\n}\r\nstatic ssize_t octeon_mc_inject_error_type_show(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *data)\r\n{\r\nstruct mem_ctl_info *mci = to_mci(dev);\r\nstruct octeon_lmc_pvt *pvt = mci->pvt_info;\r\nif (pvt->error_type == 1)\r\nreturn sprintf(data, "single");\r\nelse if (pvt->error_type == 2)\r\nreturn sprintf(data, "double");\r\nreturn 0;\r\n}\r\nstatic int octeon_lmc_edac_probe(struct platform_device *pdev)\r\n{\r\nstruct mem_ctl_info *mci;\r\nstruct edac_mc_layer layers[1];\r\nint mc = pdev->id;\r\nopstate_init();\r\nlayers[0].type = EDAC_MC_LAYER_CHANNEL;\r\nlayers[0].size = 1;\r\nlayers[0].is_virt_csrow = false;\r\nif (OCTEON_IS_OCTEON1PLUS()) {\r\nunion cvmx_lmcx_mem_cfg0 cfg0;\r\ncfg0.u64 = cvmx_read_csr(CVMX_LMCX_MEM_CFG0(0));\r\nif (!cfg0.s.ecc_ena) {\r\ndev_info(&pdev->dev, "Disabled (ECC not enabled)\n");\r\nreturn 0;\r\n}\r\nmci = edac_mc_alloc(mc, ARRAY_SIZE(layers), layers, sizeof(struct octeon_lmc_pvt));\r\nif (!mci)\r\nreturn -ENXIO;\r\nmci->pdev = &pdev->dev;\r\nmci->dev_name = dev_name(&pdev->dev);\r\nmci->mod_name = "octeon-lmc";\r\nmci->ctl_name = "octeon-lmc-err";\r\nmci->edac_check = octeon_lmc_edac_poll;\r\nif (edac_mc_add_mc_with_groups(mci, octeon_dev_groups)) {\r\ndev_err(&pdev->dev, "edac_mc_add_mc() failed\n");\r\nedac_mc_free(mci);\r\nreturn -ENXIO;\r\n}\r\ncfg0.u64 = cvmx_read_csr(CVMX_LMCX_MEM_CFG0(mc));\r\ncfg0.s.intr_ded_ena = 0;\r\ncfg0.s.intr_sec_ena = 0;\r\ncvmx_write_csr(CVMX_LMCX_MEM_CFG0(mc), cfg0.u64);\r\n} else {\r\nunion cvmx_lmcx_int_en en;\r\nunion cvmx_lmcx_config config;\r\nconfig.u64 = cvmx_read_csr(CVMX_LMCX_CONFIG(0));\r\nif (!config.s.ecc_ena) {\r\ndev_info(&pdev->dev, "Disabled (ECC not enabled)\n");\r\nreturn 0;\r\n}\r\nmci = edac_mc_alloc(mc, ARRAY_SIZE(layers), layers, sizeof(struct octeon_lmc_pvt));\r\nif (!mci)\r\nreturn -ENXIO;\r\nmci->pdev = &pdev->dev;\r\nmci->dev_name = dev_name(&pdev->dev);\r\nmci->mod_name = "octeon-lmc";\r\nmci->ctl_name = "co_lmc_err";\r\nmci->edac_check = octeon_lmc_edac_poll_o2;\r\nif (edac_mc_add_mc_with_groups(mci, octeon_dev_groups)) {\r\ndev_err(&pdev->dev, "edac_mc_add_mc() failed\n");\r\nedac_mc_free(mci);\r\nreturn -ENXIO;\r\n}\r\nen.u64 = cvmx_read_csr(CVMX_LMCX_MEM_CFG0(mc));\r\nen.s.intr_ded_ena = 0;\r\nen.s.intr_sec_ena = 0;\r\ncvmx_write_csr(CVMX_LMCX_MEM_CFG0(mc), en.u64);\r\n}\r\nplatform_set_drvdata(pdev, mci);\r\nreturn 0;\r\n}\r\nstatic int octeon_lmc_edac_remove(struct platform_device *pdev)\r\n{\r\nstruct mem_ctl_info *mci = platform_get_drvdata(pdev);\r\nedac_mc_del_mc(&pdev->dev);\r\nedac_mc_free(mci);\r\nreturn 0;\r\n}
