static int quadfs_pll_enable(struct clk_hw *hw)\r\n{\r\nstruct st_clk_quadfs_pll *pll = to_quadfs_pll(hw);\r\nunsigned long flags = 0, timeout = jiffies + msecs_to_jiffies(10);\r\nif (pll->lock)\r\nspin_lock_irqsave(pll->lock, flags);\r\nif (pll->data->reset_present)\r\nCLKGEN_WRITE(pll, nreset, 1);\r\nif (pll->data->bwfilter_present)\r\nCLKGEN_WRITE(pll, ref_bw, PLL_BW_GOODREF);\r\nCLKGEN_WRITE(pll, ndiv, pll->ndiv);\r\nCLKGEN_WRITE(pll, npda, !pll->data->powerup_polarity);\r\nif (pll->lock)\r\nspin_unlock_irqrestore(pll->lock, flags);\r\nif (pll->data->lockstatus_present)\r\nwhile (!CLKGEN_READ(pll, lock_status)) {\r\nif (time_after(jiffies, timeout))\r\nreturn -ETIMEDOUT;\r\ncpu_relax();\r\n}\r\nreturn 0;\r\n}\r\nstatic void quadfs_pll_disable(struct clk_hw *hw)\r\n{\r\nstruct st_clk_quadfs_pll *pll = to_quadfs_pll(hw);\r\nunsigned long flags = 0;\r\nif (pll->lock)\r\nspin_lock_irqsave(pll->lock, flags);\r\nCLKGEN_WRITE(pll, npda, pll->data->powerup_polarity);\r\nif (pll->data->reset_present)\r\nCLKGEN_WRITE(pll, nreset, 0);\r\nif (pll->lock)\r\nspin_unlock_irqrestore(pll->lock, flags);\r\n}\r\nstatic int quadfs_pll_is_enabled(struct clk_hw *hw)\r\n{\r\nstruct st_clk_quadfs_pll *pll = to_quadfs_pll(hw);\r\nu32 npda = CLKGEN_READ(pll, npda);\r\nreturn pll->data->powerup_polarity ? !npda : !!npda;\r\n}\r\nstatic int clk_fs660c32_vco_get_rate(unsigned long input, struct stm_fs *fs,\r\nunsigned long *rate)\r\n{\r\nunsigned long nd = fs->ndiv + 16;\r\n*rate = input * nd;\r\nreturn 0;\r\n}\r\nstatic unsigned long quadfs_pll_fs660c32_recalc_rate(struct clk_hw *hw,\r\nunsigned long parent_rate)\r\n{\r\nstruct st_clk_quadfs_pll *pll = to_quadfs_pll(hw);\r\nunsigned long rate = 0;\r\nstruct stm_fs params;\r\nparams.ndiv = CLKGEN_READ(pll, ndiv);\r\nif (clk_fs660c32_vco_get_rate(parent_rate, &params, &rate))\r\npr_err("%s:%s error calculating rate\n",\r\nclk_hw_get_name(hw), __func__);\r\npll->ndiv = params.ndiv;\r\nreturn rate;\r\n}\r\nstatic int clk_fs660c32_vco_get_params(unsigned long input,\r\nunsigned long output, struct stm_fs *fs)\r\n{\r\nunsigned long pdiv = 1, n;\r\nif (output < 384000000 || output > 660000000)\r\nreturn -EINVAL;\r\nif (input > 40000000)\r\nreturn -EINVAL;\r\ninput /= 1000;\r\noutput /= 1000;\r\nn = output * pdiv / input;\r\nif (n < 16)\r\nn = 16;\r\nfs->ndiv = n - 16;\r\nreturn 0;\r\n}\r\nstatic long quadfs_pll_fs660c32_round_rate(struct clk_hw *hw,\r\nunsigned long rate,\r\nunsigned long *prate)\r\n{\r\nstruct stm_fs params;\r\nif (clk_fs660c32_vco_get_params(*prate, rate, &params))\r\nreturn rate;\r\nclk_fs660c32_vco_get_rate(*prate, &params, &rate);\r\npr_debug("%s: %s new rate %ld [ndiv=%u]\n",\r\n__func__, clk_hw_get_name(hw),\r\nrate, (unsigned int)params.ndiv);\r\nreturn rate;\r\n}\r\nstatic int quadfs_pll_fs660c32_set_rate(struct clk_hw *hw, unsigned long rate,\r\nunsigned long parent_rate)\r\n{\r\nstruct st_clk_quadfs_pll *pll = to_quadfs_pll(hw);\r\nstruct stm_fs params;\r\nlong hwrate = 0;\r\nunsigned long flags = 0;\r\nint ret;\r\nif (!rate || !parent_rate)\r\nreturn -EINVAL;\r\nret = clk_fs660c32_vco_get_params(parent_rate, rate, &params);\r\nif (ret)\r\nreturn ret;\r\nclk_fs660c32_vco_get_rate(parent_rate, &params, &hwrate);\r\npr_debug("%s: %s new rate %ld [ndiv=0x%x]\n",\r\n__func__, clk_hw_get_name(hw),\r\nhwrate, (unsigned int)params.ndiv);\r\nif (!hwrate)\r\nreturn -EINVAL;\r\npll->ndiv = params.ndiv;\r\nif (pll->lock)\r\nspin_lock_irqsave(pll->lock, flags);\r\nCLKGEN_WRITE(pll, ndiv, pll->ndiv);\r\nif (pll->lock)\r\nspin_unlock_irqrestore(pll->lock, flags);\r\nreturn 0;\r\n}\r\nstatic struct clk * __init st_clk_register_quadfs_pll(\r\nconst char *name, const char *parent_name,\r\nstruct clkgen_quadfs_data *quadfs, void __iomem *reg,\r\nspinlock_t *lock)\r\n{\r\nstruct st_clk_quadfs_pll *pll;\r\nstruct clk *clk;\r\nstruct clk_init_data init;\r\nif (WARN_ON(!name || !parent_name))\r\nreturn ERR_PTR(-EINVAL);\r\npll = kzalloc(sizeof(*pll), GFP_KERNEL);\r\nif (!pll)\r\nreturn ERR_PTR(-ENOMEM);\r\ninit.name = name;\r\ninit.ops = quadfs->pll_ops;\r\ninit.flags = CLK_IS_BASIC | CLK_GET_RATE_NOCACHE;\r\ninit.parent_names = &parent_name;\r\ninit.num_parents = 1;\r\npll->data = quadfs;\r\npll->regs_base = reg;\r\npll->lock = lock;\r\npll->hw.init = &init;\r\nclk = clk_register(NULL, &pll->hw);\r\nif (IS_ERR(clk))\r\nkfree(pll);\r\nreturn clk;\r\n}\r\nstatic void quadfs_fsynth_program_enable(struct st_clk_quadfs_fsynth *fs)\r\n{\r\nCLKGEN_WRITE(fs, en[fs->chan], 1);\r\nCLKGEN_WRITE(fs, en[fs->chan], 0);\r\n}\r\nstatic void quadfs_fsynth_program_rate(struct st_clk_quadfs_fsynth *fs)\r\n{\r\nunsigned long flags = 0;\r\nCLKGEN_WRITE(fs, en[fs->chan], 0);\r\nCLKGEN_WRITE(fs, mdiv[fs->chan], fs->md);\r\nCLKGEN_WRITE(fs, pe[fs->chan], fs->pe);\r\nCLKGEN_WRITE(fs, sdiv[fs->chan], fs->sdiv);\r\nif (fs->lock)\r\nspin_lock_irqsave(fs->lock, flags);\r\nif (fs->data->nsdiv_present)\r\nCLKGEN_WRITE(fs, nsdiv[fs->chan], fs->nsdiv);\r\nif (fs->lock)\r\nspin_unlock_irqrestore(fs->lock, flags);\r\n}\r\nstatic int quadfs_fsynth_enable(struct clk_hw *hw)\r\n{\r\nstruct st_clk_quadfs_fsynth *fs = to_quadfs_fsynth(hw);\r\nunsigned long flags = 0;\r\npr_debug("%s: %s\n", __func__, clk_hw_get_name(hw));\r\nquadfs_fsynth_program_rate(fs);\r\nif (fs->lock)\r\nspin_lock_irqsave(fs->lock, flags);\r\nCLKGEN_WRITE(fs, nsb[fs->chan], !fs->data->standby_polarity);\r\nif (fs->data->nrst_present)\r\nCLKGEN_WRITE(fs, nrst[fs->chan], 0);\r\nif (fs->lock)\r\nspin_unlock_irqrestore(fs->lock, flags);\r\nquadfs_fsynth_program_enable(fs);\r\nreturn 0;\r\n}\r\nstatic void quadfs_fsynth_disable(struct clk_hw *hw)\r\n{\r\nstruct st_clk_quadfs_fsynth *fs = to_quadfs_fsynth(hw);\r\nunsigned long flags = 0;\r\npr_debug("%s: %s\n", __func__, clk_hw_get_name(hw));\r\nif (fs->lock)\r\nspin_lock_irqsave(fs->lock, flags);\r\nCLKGEN_WRITE(fs, nsb[fs->chan], fs->data->standby_polarity);\r\nif (fs->lock)\r\nspin_unlock_irqrestore(fs->lock, flags);\r\n}\r\nstatic int quadfs_fsynth_is_enabled(struct clk_hw *hw)\r\n{\r\nstruct st_clk_quadfs_fsynth *fs = to_quadfs_fsynth(hw);\r\nu32 nsb = CLKGEN_READ(fs, nsb[fs->chan]);\r\npr_debug("%s: %s enable bit = 0x%x\n",\r\n__func__, clk_hw_get_name(hw), nsb);\r\nreturn fs->data->standby_polarity ? !nsb : !!nsb;\r\n}\r\nstatic int clk_fs216c65_get_rate(unsigned long input, const struct stm_fs *fs,\r\nunsigned long *rate)\r\n{\r\nuint64_t res;\r\nunsigned long ns;\r\nunsigned long nd = 8;\r\nunsigned long s;\r\nlong m;\r\nm = fs->mdiv - 32;\r\ns = 1 << (fs->sdiv + 1);\r\nns = (fs->nsdiv ? 1 : 3);\r\nres = (uint64_t)(s * ns * P15 * (uint64_t)(m + 33));\r\nres = res - (s * ns * fs->pe);\r\n*rate = div64_u64(P15 * nd * input * 32, res);\r\nreturn 0;\r\n}\r\nstatic int clk_fs432c65_get_rate(unsigned long input, const struct stm_fs *fs,\r\nunsigned long *rate)\r\n{\r\nuint64_t res;\r\nunsigned long nd = 16;\r\nlong m;\r\nunsigned long sd;\r\nunsigned long ns;\r\nm = fs->mdiv - 32;\r\nsd = 1 << (fs->sdiv + 1);\r\nns = (fs->nsdiv ? 1 : 3);\r\nres = (uint64_t)(sd * ns * P15 * (uint64_t)(m + 33));\r\nres = res - (sd * ns * fs->pe);\r\n*rate = div64_u64(P15 * nd * input * 32, res);\r\nreturn 0;\r\n}\r\nstatic int clk_fs660c32_dig_get_rate(unsigned long input,\r\nconst struct stm_fs *fs, unsigned long *rate)\r\n{\r\nunsigned long s = (1 << fs->sdiv);\r\nunsigned long ns;\r\nuint64_t res;\r\nns = (fs->nsdiv == 1) ? 1 : 3;\r\nres = (P20 * (32 + fs->mdiv) + 32 * fs->pe) * s * ns;\r\n*rate = (unsigned long)div64_u64(input * P20 * 32, res);\r\nreturn 0;\r\n}\r\nstatic int quadfs_fsynt_get_hw_value_for_recalc(struct st_clk_quadfs_fsynth *fs,\r\nstruct stm_fs *params)\r\n{\r\nparams->mdiv = CLKGEN_READ(fs, mdiv[fs->chan]);\r\nparams->pe = CLKGEN_READ(fs, pe[fs->chan]);\r\nparams->sdiv = CLKGEN_READ(fs, sdiv[fs->chan]);\r\nif (fs->data->nsdiv_present)\r\nparams->nsdiv = CLKGEN_READ(fs, nsdiv[fs->chan]);\r\nelse\r\nparams->nsdiv = 1;\r\nif (!params->mdiv && !params->pe && !params->sdiv)\r\nreturn 1;\r\nfs->md = params->mdiv;\r\nfs->pe = params->pe;\r\nfs->sdiv = params->sdiv;\r\nfs->nsdiv = params->nsdiv;\r\nreturn 0;\r\n}\r\nstatic long quadfs_find_best_rate(struct clk_hw *hw, unsigned long drate,\r\nunsigned long prate, struct stm_fs *params)\r\n{\r\nstruct st_clk_quadfs_fsynth *fs = to_quadfs_fsynth(hw);\r\nint (*clk_fs_get_rate)(unsigned long ,\r\nconst struct stm_fs *, unsigned long *);\r\nstruct stm_fs prev_params;\r\nunsigned long prev_rate, rate = 0;\r\nunsigned long diff_rate, prev_diff_rate = ~0;\r\nint index;\r\nclk_fs_get_rate = fs->data->get_rate;\r\nfor (index = 0; index < fs->data->rtbl_cnt; index++) {\r\nprev_rate = rate;\r\n*params = fs->data->rtbl[index];\r\nprev_params = *params;\r\nclk_fs_get_rate(prate, &fs->data->rtbl[index], &rate);\r\ndiff_rate = abs(drate - rate);\r\nif (diff_rate > prev_diff_rate) {\r\nrate = prev_rate;\r\n*params = prev_params;\r\nbreak;\r\n}\r\nprev_diff_rate = diff_rate;\r\nif (drate == rate)\r\nreturn rate;\r\n}\r\nif (index == fs->data->rtbl_cnt)\r\n*params = prev_params;\r\nreturn rate;\r\n}\r\nstatic unsigned long quadfs_recalc_rate(struct clk_hw *hw,\r\nunsigned long parent_rate)\r\n{\r\nstruct st_clk_quadfs_fsynth *fs = to_quadfs_fsynth(hw);\r\nunsigned long rate = 0;\r\nstruct stm_fs params;\r\nint (*clk_fs_get_rate)(unsigned long ,\r\nconst struct stm_fs *, unsigned long *);\r\nclk_fs_get_rate = fs->data->get_rate;\r\nif (quadfs_fsynt_get_hw_value_for_recalc(fs, &params))\r\nreturn 0;\r\nif (clk_fs_get_rate(parent_rate, &params, &rate)) {\r\npr_err("%s:%s error calculating rate\n",\r\nclk_hw_get_name(hw), __func__);\r\n}\r\npr_debug("%s:%s rate %lu\n", clk_hw_get_name(hw), __func__, rate);\r\nreturn rate;\r\n}\r\nstatic long quadfs_round_rate(struct clk_hw *hw, unsigned long rate,\r\nunsigned long *prate)\r\n{\r\nstruct stm_fs params;\r\nrate = quadfs_find_best_rate(hw, rate, *prate, &params);\r\npr_debug("%s: %s new rate %ld [sdiv=0x%x,md=0x%x,pe=0x%x,nsdiv3=%u]\n",\r\n__func__, clk_hw_get_name(hw),\r\nrate, (unsigned int)params.sdiv, (unsigned int)params.mdiv,\r\n(unsigned int)params.pe, (unsigned int)params.nsdiv);\r\nreturn rate;\r\n}\r\nstatic void quadfs_program_and_enable(struct st_clk_quadfs_fsynth *fs,\r\nstruct stm_fs *params)\r\n{\r\nfs->md = params->mdiv;\r\nfs->pe = params->pe;\r\nfs->sdiv = params->sdiv;\r\nfs->nsdiv = params->nsdiv;\r\nquadfs_fsynth_program_rate(fs);\r\nquadfs_fsynth_program_enable(fs);\r\n}\r\nstatic int quadfs_set_rate(struct clk_hw *hw, unsigned long rate,\r\nunsigned long parent_rate)\r\n{\r\nstruct st_clk_quadfs_fsynth *fs = to_quadfs_fsynth(hw);\r\nstruct stm_fs params;\r\nlong hwrate;\r\nint uninitialized_var(i);\r\nif (!rate || !parent_rate)\r\nreturn -EINVAL;\r\nmemset(&params, 0, sizeof(struct stm_fs));\r\nhwrate = quadfs_find_best_rate(hw, rate, parent_rate, &params);\r\nif (!hwrate)\r\nreturn -EINVAL;\r\nquadfs_program_and_enable(fs, &params);\r\nreturn 0;\r\n}\r\nstatic struct clk * __init st_clk_register_quadfs_fsynth(\r\nconst char *name, const char *parent_name,\r\nstruct clkgen_quadfs_data *quadfs, void __iomem *reg, u32 chan,\r\nspinlock_t *lock)\r\n{\r\nstruct st_clk_quadfs_fsynth *fs;\r\nstruct clk *clk;\r\nstruct clk_init_data init;\r\nif (WARN_ON(!name || !parent_name))\r\nreturn ERR_PTR(-EINVAL);\r\nfs = kzalloc(sizeof(*fs), GFP_KERNEL);\r\nif (!fs)\r\nreturn ERR_PTR(-ENOMEM);\r\ninit.name = name;\r\ninit.ops = &st_quadfs_ops;\r\ninit.flags = CLK_GET_RATE_NOCACHE | CLK_IS_BASIC;\r\ninit.parent_names = &parent_name;\r\ninit.num_parents = 1;\r\nfs->data = quadfs;\r\nfs->regs_base = reg;\r\nfs->chan = chan;\r\nfs->lock = lock;\r\nfs->hw.init = &init;\r\nclk = clk_register(NULL, &fs->hw);\r\nif (IS_ERR(clk))\r\nkfree(fs);\r\nreturn clk;\r\n}\r\nstatic void __init st_of_create_quadfs_fsynths(\r\nstruct device_node *np, const char *pll_name,\r\nstruct clkgen_quadfs_data *quadfs, void __iomem *reg,\r\nspinlock_t *lock)\r\n{\r\nstruct clk_onecell_data *clk_data;\r\nint fschan;\r\nclk_data = kzalloc(sizeof(*clk_data), GFP_KERNEL);\r\nif (!clk_data)\r\nreturn;\r\nclk_data->clk_num = QUADFS_MAX_CHAN;\r\nclk_data->clks = kzalloc(QUADFS_MAX_CHAN * sizeof(struct clk *),\r\nGFP_KERNEL);\r\nif (!clk_data->clks) {\r\nkfree(clk_data);\r\nreturn;\r\n}\r\nfor (fschan = 0; fschan < QUADFS_MAX_CHAN; fschan++) {\r\nstruct clk *clk;\r\nconst char *clk_name;\r\nif (of_property_read_string_index(np, "clock-output-names",\r\nfschan, &clk_name)) {\r\nbreak;\r\n}\r\nif (*clk_name == '\0')\r\ncontinue;\r\nclk = st_clk_register_quadfs_fsynth(clk_name, pll_name,\r\nquadfs, reg, fschan, lock);\r\nif (!IS_ERR(clk)) {\r\nclk_data->clks[fschan] = clk;\r\npr_debug("%s: parent %s rate %u\n",\r\n__clk_get_name(clk),\r\n__clk_get_name(clk_get_parent(clk)),\r\n(unsigned int)clk_get_rate(clk));\r\n}\r\n}\r\nof_clk_add_provider(np, of_clk_src_onecell_get, clk_data);\r\n}\r\nstatic void __init st_of_quadfs_setup(struct device_node *np)\r\n{\r\nconst struct of_device_id *match;\r\nstruct clk *clk;\r\nconst char *pll_name, *clk_parent_name;\r\nvoid __iomem *reg;\r\nspinlock_t *lock;\r\nmatch = of_match_node(quadfs_of_match, np);\r\nif (WARN_ON(!match))\r\nreturn;\r\nreg = of_iomap(np, 0);\r\nif (!reg)\r\nreturn;\r\nclk_parent_name = of_clk_get_parent_name(np, 0);\r\nif (!clk_parent_name)\r\nreturn;\r\npll_name = kasprintf(GFP_KERNEL, "%s.pll", np->name);\r\nif (!pll_name)\r\nreturn;\r\nlock = kzalloc(sizeof(*lock), GFP_KERNEL);\r\nif (!lock)\r\ngoto err_exit;\r\nspin_lock_init(lock);\r\nclk = st_clk_register_quadfs_pll(pll_name, clk_parent_name,\r\n(struct clkgen_quadfs_data *) match->data, reg, lock);\r\nif (IS_ERR(clk))\r\ngoto err_exit;\r\nelse\r\npr_debug("%s: parent %s rate %u\n",\r\n__clk_get_name(clk),\r\n__clk_get_name(clk_get_parent(clk)),\r\n(unsigned int)clk_get_rate(clk));\r\nst_of_create_quadfs_fsynths(np, pll_name,\r\n(struct clkgen_quadfs_data *)match->data,\r\nreg, lock);\r\nerr_exit:\r\nkfree(pll_name);\r\n}
