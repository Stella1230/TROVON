static inline u32 isif_read(void __iomem *base_addr, u32 offset)\r\n{\r\nreturn readl(base_addr + offset);\r\n}\r\nstatic inline void isif_write(void __iomem *base_addr, u32 val, u32 offset)\r\n{\r\nwritel(val, base_addr + offset);\r\n}\r\nstatic inline u32 isif_merge(void __iomem *base_addr, u32 mask, u32 val,\r\nu32 offset)\r\n{\r\nu32 new_val = (isif_read(base_addr, offset) & ~mask) | (val & mask);\r\nisif_write(base_addr, new_val, offset);\r\nreturn new_val;\r\n}\r\nstatic void isif_enable_output_to_sdram(struct vpfe_isif_device *isif, int en)\r\n{\r\nisif_merge(isif->isif_cfg.base_addr, ISIF_SYNCEN_WEN_MASK,\r\nen << ISIF_SYNCEN_WEN_SHIFT, SYNCEN);\r\n}\r\nstatic inline void\r\nisif_regw_lin_tbl(struct vpfe_isif_device *isif, u32 val, u32 offset, int i)\r\n{\r\nif (!i)\r\nwritel(val, isif->isif_cfg.linear_tbl0_addr + offset);\r\nelse\r\nwritel(val, isif->isif_cfg.linear_tbl1_addr + offset);\r\n}\r\nstatic void isif_disable_all_modules(struct vpfe_isif_device *isif)\r\n{\r\nisif_write(isif->isif_cfg.base_addr, 0, CLAMPCFG);\r\nisif_write(isif->isif_cfg.base_addr, 0, DFCCTL);\r\nisif_write(isif->isif_cfg.base_addr, 0, CSCCTL);\r\nisif_write(isif->isif_cfg.base_addr, 0, LINCFG0);\r\n}\r\nstatic void isif_enable(struct vpfe_isif_device *isif, int en)\r\n{\r\nif (!en)\r\nisif_disable_all_modules(isif);\r\nmsleep(100);\r\nisif_merge(isif->isif_cfg.base_addr, ISIF_SYNCEN_VDHDEN_MASK,\r\nen, SYNCEN);\r\n}\r\nenum v4l2_field vpfe_isif_get_fid(struct vpfe_device *vpfe_dev)\r\n{\r\nstruct vpfe_isif_device *isif = &vpfe_dev->vpfe_isif;\r\nu32 field_status;\r\nfield_status = isif_read(isif->isif_cfg.base_addr, MODESET);\r\nfield_status = (field_status >> DM365_ISIF_MDFS_OFFSET) &\r\nDM365_ISIF_MDFS_MASK;\r\nreturn field_status;\r\n}\r\nstatic int\r\nisif_set_pixel_format(struct vpfe_isif_device *isif, unsigned int pixfmt)\r\n{\r\nif (isif->formats[ISIF_PAD_SINK].code == MEDIA_BUS_FMT_SGRBG12_1X12) {\r\nif (pixfmt == V4L2_PIX_FMT_SBGGR16)\r\nisif->isif_cfg.data_pack = ISIF_PACK_16BIT;\r\nelse if ((pixfmt == V4L2_PIX_FMT_SGRBG10DPCM8) ||\r\n(pixfmt == V4L2_PIX_FMT_SGRBG10ALAW8))\r\nisif->isif_cfg.data_pack = ISIF_PACK_8BIT;\r\nelse\r\nreturn -EINVAL;\r\nisif->isif_cfg.bayer.pix_fmt = ISIF_PIXFMT_RAW;\r\nisif->isif_cfg.bayer.v4l2_pix_fmt = pixfmt;\r\n} else {\r\nif (pixfmt == V4L2_PIX_FMT_YUYV)\r\nisif->isif_cfg.ycbcr.pix_order = ISIF_PIXORDER_YCBYCR;\r\nelse if (pixfmt == V4L2_PIX_FMT_UYVY)\r\nisif->isif_cfg.ycbcr.pix_order = ISIF_PIXORDER_CBYCRY;\r\nelse\r\nreturn -EINVAL;\r\nisif->isif_cfg.data_pack = ISIF_PACK_8BIT;\r\nisif->isif_cfg.ycbcr.v4l2_pix_fmt = pixfmt;\r\n}\r\nreturn 0;\r\n}\r\nstatic int\r\nisif_set_frame_format(struct vpfe_isif_device *isif,\r\nenum isif_frmfmt frm_fmt)\r\n{\r\nif (isif->formats[ISIF_PAD_SINK].code == MEDIA_BUS_FMT_SGRBG12_1X12)\r\nisif->isif_cfg.bayer.frm_fmt = frm_fmt;\r\nelse\r\nisif->isif_cfg.ycbcr.frm_fmt = frm_fmt;\r\nreturn 0;\r\n}\r\nstatic int isif_set_image_window(struct vpfe_isif_device *isif)\r\n{\r\nstruct v4l2_rect *win = &isif->crop;\r\nif (isif->formats[ISIF_PAD_SINK].code == MEDIA_BUS_FMT_SGRBG12_1X12) {\r\nisif->isif_cfg.bayer.win.top = win->top;\r\nisif->isif_cfg.bayer.win.left = win->left;\r\nisif->isif_cfg.bayer.win.width = win->width;\r\nisif->isif_cfg.bayer.win.height = win->height;\r\nreturn 0;\r\n}\r\nisif->isif_cfg.ycbcr.win.top = win->top;\r\nisif->isif_cfg.ycbcr.win.left = win->left;\r\nisif->isif_cfg.ycbcr.win.width = win->width;\r\nisif->isif_cfg.ycbcr.win.height = win->height;\r\nreturn 0;\r\n}\r\nstatic int\r\nisif_set_buftype(struct vpfe_isif_device *isif, enum isif_buftype buf_type)\r\n{\r\nif (isif->formats[ISIF_PAD_SINK].code == MEDIA_BUS_FMT_SGRBG12_1X12)\r\nisif->isif_cfg.bayer.buf_type = buf_type;\r\nelse\r\nisif->isif_cfg.ycbcr.buf_type = buf_type;\r\nreturn 0;\r\n}\r\nstatic int\r\nisif_config_format(struct vpfe_device *vpfe_dev, unsigned int pad)\r\n{\r\nstruct vpfe_isif_device *vpfe_isif = &vpfe_dev->vpfe_isif;\r\nenum isif_frmfmt frm_fmt = ISIF_FRMFMT_INTERLACED;\r\nstruct v4l2_pix_format format;\r\nint ret = 0;\r\nv4l2_fill_pix_format(&format, &vpfe_dev->vpfe_isif.formats[pad]);\r\nmbus_to_pix(&vpfe_dev->vpfe_isif.formats[pad], &format);\r\nif (isif_set_pixel_format(vpfe_isif, format.pixelformat) < 0) {\r\nv4l2_err(&vpfe_dev->v4l2_dev,\r\n"Failed to set pixel format in isif\n");\r\nreturn -EINVAL;\r\n}\r\nvpfe_isif->crop.left = 0;\r\nvpfe_isif->crop.top = 0;\r\nvpfe_isif->crop.width = format.width;\r\nvpfe_isif->crop.height = format.height;\r\nisif_set_image_window(vpfe_isif);\r\nswitch (vpfe_dev->vpfe_isif.formats[pad].field) {\r\ncase V4L2_FIELD_INTERLACED:\r\nret = isif_set_buftype(vpfe_isif, ISIF_BUFTYPE_FLD_INTERLEAVED);\r\nbreak;\r\ncase V4L2_FIELD_NONE:\r\nfrm_fmt = ISIF_FRMFMT_PROGRESSIVE;\r\nbreak;\r\ncase V4L2_FIELD_SEQ_TB:\r\nret = isif_set_buftype(vpfe_isif, ISIF_BUFTYPE_FLD_SEPARATED);\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nif (!ret)\r\nret = isif_set_frame_format(vpfe_isif, frm_fmt);\r\nreturn ret;\r\n}\r\nstatic void\r\nisif_try_format(struct vpfe_isif_device *isif,\r\nstruct v4l2_subdev_pad_config *cfg,\r\nstruct v4l2_subdev_format *fmt)\r\n{\r\nunsigned int width = fmt->format.width;\r\nunsigned int height = fmt->format.height;\r\nunsigned int i;\r\nfor (i = 0; i < ARRAY_SIZE(isif_fmts); i++) {\r\nif (fmt->format.code == isif_fmts[i])\r\nbreak;\r\n}\r\nif (i >= ARRAY_SIZE(isif_fmts))\r\nfmt->format.code = MEDIA_BUS_FMT_YUYV8_2X8;\r\nfmt->format.width = clamp_t(u32, width, 32, MAX_WIDTH);\r\nfmt->format.height = clamp_t(u32, height, 32, MAX_HEIGHT);\r\nif (fmt->pad == ISIF_PAD_SOURCE)\r\nfmt->format.width &= ~15;\r\n}\r\nvoid vpfe_isif_buffer_isr(struct vpfe_isif_device *isif)\r\n{\r\nstruct vpfe_device *vpfe_dev = to_vpfe_device(isif);\r\nstruct vpfe_video_device *video = &isif->video_out;\r\nenum v4l2_field field;\r\nint fid;\r\nif (!video->started)\r\nreturn;\r\nfield = video->fmt.fmt.pix.field;\r\nif (field == V4L2_FIELD_NONE) {\r\nif (video->cur_frm != video->next_frm)\r\nvpfe_video_process_buffer_complete(video);\r\nreturn;\r\n}\r\nfid = vpfe_isif_get_fid(vpfe_dev);\r\nvideo->field_id ^= 1;\r\nif (fid == video->field_id) {\r\nif (fid == 0) {\r\nif (video->cur_frm != video->next_frm)\r\nvpfe_video_process_buffer_complete(video);\r\nif (field == V4L2_FIELD_SEQ_TB)\r\nvpfe_video_schedule_bottom_field(video);\r\nreturn;\r\n}\r\nspin_lock(&video->dma_queue_lock);\r\nif (!list_empty(&video->dma_queue) &&\r\nvideo->cur_frm == video->next_frm)\r\nvpfe_video_schedule_next_buffer(video);\r\nspin_unlock(&video->dma_queue_lock);\r\n} else if (fid == 0) {\r\nvideo->field_id = fid;\r\n}\r\n}\r\nvoid vpfe_isif_vidint1_isr(struct vpfe_isif_device *isif)\r\n{\r\nstruct vpfe_video_device *video = &isif->video_out;\r\nif (!video->started)\r\nreturn;\r\nspin_lock(&video->dma_queue_lock);\r\nif (video->fmt.fmt.pix.field == V4L2_FIELD_NONE &&\r\n!list_empty(&video->dma_queue) && video->cur_frm == video->next_frm)\r\nvpfe_video_schedule_next_buffer(video);\r\nspin_unlock(&video->dma_queue_lock);\r\n}\r\nstatic int isif_video_queue(struct vpfe_device *vpfe_dev, unsigned long addr)\r\n{\r\nstruct vpfe_isif_device *isif = &vpfe_dev->vpfe_isif;\r\nisif_write(isif->isif_cfg.base_addr, (addr >> 21) &\r\nISIF_CADU_BITS, CADU);\r\nisif_write(isif->isif_cfg.base_addr, (addr >> 5) &\r\nISIF_CADL_BITS, CADL);\r\nreturn 0;\r\n}\r\nstatic int isif_get_params(struct v4l2_subdev *sd, void *params)\r\n{\r\nstruct vpfe_isif_device *isif = v4l2_get_subdevdata(sd);\r\nif (isif->formats[ISIF_PAD_SINK].code != MEDIA_BUS_FMT_SGRBG12_1X12)\r\nreturn -EINVAL;\r\nmemcpy(params, &isif->isif_cfg.bayer.config_params,\r\nsizeof(isif->isif_cfg.bayer.config_params));\r\nreturn 0;\r\n}\r\nstatic int isif_validate_df_csc_params(struct vpfe_isif_df_csc *df_csc)\r\n{\r\nstruct vpfe_isif_color_space_conv *csc;\r\nint err = -EINVAL;\r\nint i;\r\nif (!df_csc->df_or_csc) {\r\ncsc = &df_csc->csc;\r\nif (csc->en) {\r\nfor (i = 0; i < VPFE_ISIF_CSC_NUM_COEFF; i++)\r\nif (csc->coeff[i].integer >\r\nISIF_CSC_COEF_INTEG_MASK ||\r\ncsc->coeff[i].decimal >\r\nISIF_CSC_COEF_DECIMAL_MASK) {\r\npr_err("Invalid CSC coefficients\n");\r\nreturn err;\r\n}\r\n}\r\n}\r\nif (df_csc->start_pix > ISIF_DF_CSC_SPH_MASK) {\r\npr_err("Invalid df_csc start pix value\n");\r\nreturn err;\r\n}\r\nif (df_csc->num_pixels > ISIF_DF_NUMPIX) {\r\npr_err("Invalid df_csc num pixels value\n");\r\nreturn err;\r\n}\r\nif (df_csc->start_line > ISIF_DF_CSC_LNH_MASK) {\r\npr_err("Invalid df_csc start_line value\n");\r\nreturn err;\r\n}\r\nif (df_csc->num_lines > ISIF_DF_NUMLINES) {\r\npr_err("Invalid df_csc num_lines value\n");\r\nreturn err;\r\n}\r\nreturn 0;\r\n}\r\nstatic int isif_validate_dfc_params(struct vpfe_isif_dfc *dfc)\r\n{\r\nint err = -EINVAL;\r\nint i;\r\nif (!dfc->en)\r\nreturn 0;\r\nif (dfc->corr_whole_line > 1) {\r\npr_err("Invalid corr_whole_line value\n");\r\nreturn err;\r\n}\r\nif (dfc->def_level_shift > DM365_ISIF_MAX_VDFLSFT) {\r\npr_err("Invalid def_level_shift value\n");\r\nreturn err;\r\n}\r\nif (dfc->def_sat_level > DM365_ISIF_MAX_VDFSLV) {\r\npr_err("Invalid def_sat_level value\n");\r\nreturn err;\r\n}\r\nif (!dfc->num_vdefects ||\r\ndfc->num_vdefects > VPFE_ISIF_VDFC_TABLE_SIZE) {\r\npr_err("Invalid num_vdefects value\n");\r\nreturn err;\r\n}\r\nfor (i = 0; i < VPFE_ISIF_VDFC_TABLE_SIZE; i++) {\r\nif (dfc->table[i].pos_vert > DM365_ISIF_MAX_DFCMEM0) {\r\npr_err("Invalid pos_vert value\n");\r\nreturn err;\r\n}\r\nif (dfc->table[i].pos_horz > DM365_ISIF_MAX_DFCMEM1) {\r\npr_err("Invalid pos_horz value\n");\r\nreturn err;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int isif_validate_bclamp_params(struct vpfe_isif_black_clamp *bclamp)\r\n{\r\nint err = -EINVAL;\r\nif (bclamp->dc_offset > DM365_ISIF_MAX_CLDC) {\r\npr_err("Invalid bclamp dc_offset value\n");\r\nreturn err;\r\n}\r\nif (!bclamp->en)\r\nreturn 0;\r\nif (bclamp->horz.clamp_pix_limit > 1) {\r\npr_err("Invalid bclamp horz clamp_pix_limit value\n");\r\nreturn err;\r\n}\r\nif (bclamp->horz.win_count_calc < 1 ||\r\nbclamp->horz.win_count_calc > 32) {\r\npr_err("Invalid bclamp horz win_count_calc value\n");\r\nreturn err;\r\n}\r\nif (bclamp->horz.win_start_h_calc > DM365_ISIF_MAX_CLHSH) {\r\npr_err("Invalid bclamp win_start_v_calc value\n");\r\nreturn err;\r\n}\r\nif (bclamp->horz.win_start_v_calc > DM365_ISIF_MAX_CLHSV) {\r\npr_err("Invalid bclamp win_start_v_calc value\n");\r\nreturn err;\r\n}\r\nif (bclamp->vert.reset_clamp_val > DM365_ISIF_MAX_CLVRV) {\r\npr_err("Invalid bclamp reset_clamp_val value\n");\r\nreturn err;\r\n}\r\nif (bclamp->vert.ob_v_sz_calc > DM365_ISIF_MAX_HEIGHT_BLACK_REGION) {\r\npr_err("Invalid bclamp ob_v_sz_calc value\n");\r\nreturn err;\r\n}\r\nif (bclamp->vert.ob_start_h > DM365_ISIF_MAX_CLVSH) {\r\npr_err("Invalid bclamp ob_start_h value\n");\r\nreturn err;\r\n}\r\nif (bclamp->vert.ob_start_v > DM365_ISIF_MAX_CLVSV) {\r\npr_err("Invalid bclamp ob_start_h value\n");\r\nreturn err;\r\n}\r\nreturn 0;\r\n}\r\nstatic int\r\nisif_validate_raw_params(struct vpfe_isif_raw_config *params)\r\n{\r\nint ret;\r\nret = isif_validate_df_csc_params(&params->df_csc);\r\nif (ret)\r\nreturn ret;\r\nret = isif_validate_dfc_params(&params->dfc);\r\nif (ret)\r\nreturn ret;\r\nret = isif_validate_bclamp_params(&params->bclamp);\r\nreturn ret;\r\n}\r\nstatic int isif_set_params(struct v4l2_subdev *sd, void *params)\r\n{\r\nstruct vpfe_isif_device *isif = v4l2_get_subdevdata(sd);\r\nstruct vpfe_isif_raw_config isif_raw_params;\r\nint ret = -EINVAL;\r\nif (isif->formats[ISIF_PAD_SINK].code != MEDIA_BUS_FMT_SGRBG12_1X12)\r\nreturn ret;\r\nmemcpy(&isif_raw_params, params, sizeof(isif_raw_params));\r\nif (!isif_validate_raw_params(&isif_raw_params)) {\r\nmemcpy(&isif->isif_cfg.bayer.config_params, &isif_raw_params,\r\nsizeof(isif_raw_params));\r\nret = 0;\r\n}\r\nreturn ret;\r\n}\r\nstatic long isif_ioctl(struct v4l2_subdev *sd, unsigned int cmd, void *arg)\r\n{\r\nswitch (cmd) {\r\ncase VIDIOC_VPFE_ISIF_S_RAW_PARAMS:\r\nreturn isif_set_params(sd, arg);\r\ncase VIDIOC_VPFE_ISIF_G_RAW_PARAMS:\r\nreturn isif_get_params(sd, arg);\r\ndefault:\r\nreturn -ENOIOCTLCMD;\r\n}\r\n}\r\nstatic void isif_config_gain_offset(struct vpfe_isif_device *isif)\r\n{\r\nstruct vpfe_isif_gain_offsets_adj *gain_off_ptr =\r\n&isif->isif_cfg.bayer.config_params.gain_offset;\r\nvoid __iomem *base = isif->isif_cfg.base_addr;\r\nu32 val;\r\nval = ((gain_off_ptr->gain_sdram_en & 1) << GAIN_SDRAM_EN_SHIFT) |\r\n((gain_off_ptr->gain_ipipe_en & 1) << GAIN_IPIPE_EN_SHIFT) |\r\n((gain_off_ptr->gain_h3a_en & 1) << GAIN_H3A_EN_SHIFT) |\r\n((gain_off_ptr->offset_sdram_en & 1) << OFST_SDRAM_EN_SHIFT) |\r\n((gain_off_ptr->offset_ipipe_en & 1) << OFST_IPIPE_EN_SHIFT) |\r\n((gain_off_ptr->offset_h3a_en & 1) << OFST_H3A_EN_SHIFT);\r\nisif_merge(base, GAIN_OFFSET_EN_MASK, val, CGAMMAWD);\r\nisif_write(base, isif->isif_cfg.isif_gain_params.cr_gain, CRGAIN);\r\nisif_write(base, isif->isif_cfg.isif_gain_params.cgr_gain, CGRGAIN);\r\nisif_write(base, isif->isif_cfg.isif_gain_params.cgb_gain, CGBGAIN);\r\nisif_write(base, isif->isif_cfg.isif_gain_params.cb_gain, CBGAIN);\r\nisif_write(base, isif->isif_cfg.isif_gain_params.offset & OFFSET_MASK,\r\nCOFSTA);\r\n}\r\nstatic void isif_config_bclamp(struct vpfe_isif_device *isif,\r\nstruct vpfe_isif_black_clamp *bc)\r\n{\r\nu32 val;\r\nval = bc->dc_offset & ISIF_BC_DCOFFSET_MASK;\r\nisif_write(isif->isif_cfg.base_addr, val, CLDCOFST);\r\nif (!bc->en)\r\nreturn;\r\nval = (bc->bc_mode_color & ISIF_BC_MODE_COLOR_MASK) <<\r\nISIF_BC_MODE_COLOR_SHIFT;\r\nval = val | 1 | ((bc->horz.mode & ISIF_HORZ_BC_MODE_MASK) <<\r\nISIF_HORZ_BC_MODE_SHIFT);\r\nisif_write(isif->isif_cfg.base_addr, val, CLAMPCFG);\r\nif (bc->horz.mode != VPFE_ISIF_HORZ_BC_DISABLE) {\r\nval = (bc->horz.win_count_calc & ISIF_HORZ_BC_WIN_COUNT_MASK) |\r\n((bc->horz.base_win_sel_calc & 1) <<\r\nISIF_HORZ_BC_WIN_SEL_SHIFT) |\r\n((bc->horz.clamp_pix_limit & 1) <<\r\nISIF_HORZ_BC_PIX_LIMIT_SHIFT) |\r\n((bc->horz.win_h_sz_calc &\r\nISIF_HORZ_BC_WIN_H_SIZE_MASK) <<\r\nISIF_HORZ_BC_WIN_H_SIZE_SHIFT) |\r\n((bc->horz.win_v_sz_calc &\r\nISIF_HORZ_BC_WIN_V_SIZE_MASK) <<\r\nISIF_HORZ_BC_WIN_V_SIZE_SHIFT);\r\nisif_write(isif->isif_cfg.base_addr, val, CLHWIN0);\r\nval = bc->horz.win_start_h_calc & ISIF_HORZ_BC_WIN_START_H_MASK;\r\nisif_write(isif->isif_cfg.base_addr, val, CLHWIN1);\r\nval = bc->horz.win_start_v_calc & ISIF_HORZ_BC_WIN_START_V_MASK;\r\nisif_write(isif->isif_cfg.base_addr, val, CLHWIN2);\r\n}\r\nval = bc->vert.ob_h_sz_calc & ISIF_VERT_BC_OB_H_SZ_MASK;\r\nval |= (bc->vert.reset_val_sel & ISIF_VERT_BC_RST_VAL_SEL_MASK) <<\r\nISIF_VERT_BC_RST_VAL_SEL_SHIFT;\r\nval |= bc->vert.line_ave_coef << ISIF_VERT_BC_LINE_AVE_COEF_SHIFT;\r\nisif_write(isif->isif_cfg.base_addr, val, CLVWIN0);\r\nif (bc->vert.reset_val_sel == VPFE_ISIF_VERT_BC_USE_CONFIG_CLAMP_VAL) {\r\nval = bc->vert.reset_clamp_val & ISIF_VERT_BC_RST_VAL_MASK;\r\nisif_write(isif->isif_cfg.base_addr, val, CLVRV);\r\n}\r\nval = bc->vert.ob_start_h & ISIF_VERT_BC_OB_START_HORZ_MASK;\r\nisif_write(isif->isif_cfg.base_addr, val, CLVWIN1);\r\nval = bc->vert.ob_start_v & ISIF_VERT_BC_OB_START_VERT_MASK;\r\nisif_write(isif->isif_cfg.base_addr, val, CLVWIN2);\r\nval = bc->vert.ob_v_sz_calc & ISIF_VERT_BC_OB_VERT_SZ_MASK;\r\nisif_write(isif->isif_cfg.base_addr, val, CLVWIN3);\r\nval = bc->vert_start_sub & ISIF_BC_VERT_START_SUB_V_MASK;\r\nisif_write(isif->isif_cfg.base_addr, val, CLSV);\r\n}\r\nstatic void\r\nisif_setwin(struct vpfe_isif_device *isif, struct v4l2_rect *image_win,\r\nenum isif_frmfmt frm_fmt, int ppc, int mode)\r\n{\r\nint horz_nr_pixels;\r\nint vert_nr_lines;\r\nint horz_start;\r\nint vert_start;\r\nint mid_img;\r\nhorz_start = image_win->left << (ppc - 1);\r\nhorz_nr_pixels = (image_win->width << (ppc - 1)) - 1;\r\nisif_write(isif->isif_cfg.base_addr,\r\nhorz_start & START_PX_HOR_MASK, SPH);\r\nisif_write(isif->isif_cfg.base_addr,\r\nhorz_nr_pixels & NUM_PX_HOR_MASK, LNH);\r\nvert_start = image_win->top;\r\nif (frm_fmt == ISIF_FRMFMT_INTERLACED) {\r\nvert_nr_lines = (image_win->height >> 1) - 1;\r\nvert_start >>= 1;\r\nvert_start += 1;\r\n} else {\r\nvert_start += 1;\r\nvert_nr_lines = image_win->height - 1;\r\nmid_img = vert_start + (image_win->height / 2);\r\nisif_write(isif->isif_cfg.base_addr, mid_img, VDINT1);\r\n}\r\nif (!mode)\r\nisif_write(isif->isif_cfg.base_addr, 0, VDINT0);\r\nelse\r\nisif_write(isif->isif_cfg.base_addr, vert_nr_lines, VDINT0);\r\nisif_write(isif->isif_cfg.base_addr,\r\nvert_start & START_VER_ONE_MASK, SLV0);\r\nisif_write(isif->isif_cfg.base_addr,\r\nvert_start & START_VER_TWO_MASK, SLV1);\r\nisif_write(isif->isif_cfg.base_addr,\r\nvert_nr_lines & NUM_LINES_VER, LNV);\r\n}\r\nstatic void\r\nisif_config_dfc(struct vpfe_isif_device *isif, struct vpfe_isif_dfc *vdfc)\r\n{\r\n#define DFC_WRITE_WAIT_COUNT 1000\r\nu32 count = DFC_WRITE_WAIT_COUNT;\r\nu32 val;\r\nint i;\r\nif (!vdfc->en)\r\nreturn;\r\nval = (vdfc->corr_mode & ISIF_VDFC_CORR_MOD_MASK) <<\r\nISIF_VDFC_CORR_MOD_SHIFT;\r\nif (vdfc->corr_whole_line)\r\nval |= 1 << ISIF_VDFC_CORR_WHOLE_LN_SHIFT;\r\nval |= (vdfc->def_level_shift & ISIF_VDFC_LEVEL_SHFT_MASK) <<\r\nISIF_VDFC_LEVEL_SHFT_SHIFT;\r\nisif_write(isif->isif_cfg.base_addr, val, DFCCTL);\r\nval = vdfc->def_sat_level & ISIF_VDFC_SAT_LEVEL_MASK;\r\nisif_write(isif->isif_cfg.base_addr, val, VDFSATLV);\r\nisif_write(isif->isif_cfg.base_addr, vdfc->table[0].pos_vert &\r\nISIF_VDFC_POS_MASK, DFCMEM0);\r\nisif_write(isif->isif_cfg.base_addr, vdfc->table[0].pos_horz &\r\nISIF_VDFC_POS_MASK, DFCMEM1);\r\nif (vdfc->corr_mode == VPFE_ISIF_VDFC_NORMAL ||\r\nvdfc->corr_mode == VPFE_ISIF_VDFC_HORZ_INTERPOL_IF_SAT) {\r\nisif_write(isif->isif_cfg.base_addr,\r\nvdfc->table[0].level_at_pos, DFCMEM2);\r\nisif_write(isif->isif_cfg.base_addr,\r\nvdfc->table[0].level_up_pixels, DFCMEM3);\r\nisif_write(isif->isif_cfg.base_addr,\r\nvdfc->table[0].level_low_pixels, DFCMEM4);\r\n}\r\nval = isif_read(isif->isif_cfg.base_addr, DFCMEMCTL);\r\nval |= 1 << ISIF_DFCMEMCTL_DFCMARST_SHIFT;\r\nval |= 1;\r\nisif_write(isif->isif_cfg.base_addr, val, DFCMEMCTL);\r\nwhile (count && (isif_read(isif->isif_cfg.base_addr, DFCMEMCTL) & 0x01))\r\ncount--;\r\nval = isif_read(isif->isif_cfg.base_addr, DFCMEMCTL);\r\nif (!count) {\r\npr_debug("defect table write timeout !!\n");\r\nreturn;\r\n}\r\nfor (i = 1; i < vdfc->num_vdefects; i++) {\r\nisif_write(isif->isif_cfg.base_addr, vdfc->table[i].pos_vert &\r\nISIF_VDFC_POS_MASK, DFCMEM0);\r\nisif_write(isif->isif_cfg.base_addr, vdfc->table[i].pos_horz &\r\nISIF_VDFC_POS_MASK, DFCMEM1);\r\nif (vdfc->corr_mode == VPFE_ISIF_VDFC_NORMAL ||\r\nvdfc->corr_mode == VPFE_ISIF_VDFC_HORZ_INTERPOL_IF_SAT) {\r\nisif_write(isif->isif_cfg.base_addr,\r\nvdfc->table[i].level_at_pos, DFCMEM2);\r\nisif_write(isif->isif_cfg.base_addr,\r\nvdfc->table[i].level_up_pixels, DFCMEM3);\r\nisif_write(isif->isif_cfg.base_addr,\r\nvdfc->table[i].level_low_pixels, DFCMEM4);\r\n}\r\nval = isif_read(isif->isif_cfg.base_addr, DFCMEMCTL);\r\nval &= ~(1 << ISIF_DFCMEMCTL_DFCMARST_SHIFT);\r\nval |= 1;\r\nisif_write(isif->isif_cfg.base_addr, val, DFCMEMCTL);\r\ncount = DFC_WRITE_WAIT_COUNT;\r\nwhile (count && (isif_read(isif->isif_cfg.base_addr,\r\nDFCMEMCTL) & 0x01))\r\ncount--;\r\nval = isif_read(isif->isif_cfg.base_addr, DFCMEMCTL);\r\nif (!count) {\r\npr_debug("defect table write timeout !!\n");\r\nreturn;\r\n}\r\n}\r\nif (vdfc->num_vdefects < VPFE_ISIF_VDFC_TABLE_SIZE) {\r\nisif_write(isif->isif_cfg.base_addr, 0, DFCMEM0);\r\nisif_write(isif->isif_cfg.base_addr,\r\nDM365_ISIF_MAX_DFCMEM1, DFCMEM1);\r\nisif_write(isif->isif_cfg.base_addr,\r\nDM365_ISIF_DFCMWR_MEMORY_WRITE, DFCMEMCTL);\r\n}\r\nisif_merge(isif->isif_cfg.base_addr, (1 << ISIF_VDFC_EN_SHIFT),\r\n(1 << ISIF_VDFC_EN_SHIFT), DFCCTL);\r\nisif_merge(isif->isif_cfg.base_addr, (1 << ISIF_VDFC_EN_SHIFT),\r\n(0 << ISIF_VDFC_EN_SHIFT), DFCCTL);\r\nisif_write(isif->isif_cfg.base_addr, 0x6, DFCMEMCTL);\r\nfor (i = 0; i < vdfc->num_vdefects; i++) {\r\ncount = DFC_WRITE_WAIT_COUNT;\r\nwhile (count &&\r\n(isif_read(isif->isif_cfg.base_addr, DFCMEMCTL) & 0x2))\r\ncount--;\r\nval = isif_read(isif->isif_cfg.base_addr, DFCMEMCTL);\r\nif (!count) {\r\npr_debug("defect table write timeout !!\n");\r\nreturn;\r\n}\r\nisif_write(isif->isif_cfg.base_addr,\r\nDM365_ISIF_DFCMRD_MEMORY_READ, DFCMEMCTL);\r\n}\r\n}\r\nstatic void\r\nisif_config_csc(struct vpfe_isif_device *isif, struct vpfe_isif_df_csc *df_csc)\r\n{\r\nu32 val1;\r\nu32 val2;\r\nu32 i;\r\nif (!df_csc->csc.en) {\r\nisif_write(isif->isif_cfg.base_addr, 0, CSCCTL);\r\nreturn;\r\n}\r\nval1 = 0;\r\nfor (i = 0; i < VPFE_ISIF_CSC_NUM_COEFF; i++) {\r\nif ((i % 2) == 0) {\r\nval1 = ((df_csc->csc.coeff[i].integer &\r\nISIF_CSC_COEF_INTEG_MASK) <<\r\nISIF_CSC_COEF_INTEG_SHIFT) |\r\n((df_csc->csc.coeff[i].decimal &\r\nISIF_CSC_COEF_DECIMAL_MASK));\r\n} else {\r\nval2 = ((df_csc->csc.coeff[i].integer &\r\nISIF_CSC_COEF_INTEG_MASK) <<\r\nISIF_CSC_COEF_INTEG_SHIFT) |\r\n((df_csc->csc.coeff[i].decimal &\r\nISIF_CSC_COEF_DECIMAL_MASK));\r\nval2 <<= ISIF_CSCM_MSB_SHIFT;\r\nval2 |= val1;\r\nisif_write(isif->isif_cfg.base_addr, val2,\r\n(CSCM0 + ((i-1) << 1)));\r\n}\r\n}\r\nisif_write(isif->isif_cfg.base_addr, df_csc->start_pix &\r\nISIF_DF_CSC_SPH_MASK, FMTSPH);\r\nisif_write(isif->isif_cfg.base_addr, df_csc->num_pixels &\r\nISIF_DF_CSC_SPH_MASK, FMTLNH);\r\nisif_write(isif->isif_cfg.base_addr, df_csc->start_line &\r\nISIF_DF_CSC_SPH_MASK, FMTSLV);\r\nisif_write(isif->isif_cfg.base_addr, df_csc->num_lines &\r\nISIF_DF_CSC_SPH_MASK, FMTLNV);\r\nisif_write(isif->isif_cfg.base_addr, 1, CSCCTL);\r\n}\r\nstatic void\r\nisif_config_linearization(struct vpfe_isif_device *isif,\r\nstruct vpfe_isif_linearize *linearize)\r\n{\r\nu32 val;\r\nu32 i;\r\nif (!linearize->en) {\r\nisif_write(isif->isif_cfg.base_addr, 0, LINCFG0);\r\nreturn;\r\n}\r\nval = (linearize->corr_shft & ISIF_LIN_CORRSFT_MASK) <<\r\nISIF_LIN_CORRSFT_SHIFT;\r\nval |= 1;\r\nisif_write(isif->isif_cfg.base_addr, val, LINCFG0);\r\nval = (linearize->scale_fact.integer & 1) <<\r\nISIF_LIN_SCALE_FACT_INTEG_SHIFT;\r\nval |= linearize->scale_fact.decimal & ISIF_LIN_SCALE_FACT_DECIMAL_MASK;\r\nisif_write(isif->isif_cfg.base_addr, val, LINCFG1);\r\nfor (i = 0; i < VPFE_ISIF_LINEAR_TAB_SIZE; i++) {\r\nval = linearize->table[i] & ISIF_LIN_ENTRY_MASK;\r\nif (i%2)\r\nisif_regw_lin_tbl(isif, val, ((i >> 1) << 2), 1);\r\nelse\r\nisif_regw_lin_tbl(isif, val, ((i >> 1) << 2), 0);\r\n}\r\n}\r\nstatic void\r\nisif_config_culling(struct vpfe_isif_device *isif, struct vpfe_isif_cul *cul)\r\n{\r\nu32 val;\r\nval = cul->hcpat_even << CULL_PAT_EVEN_LINE_SHIFT;\r\nval |= cul->hcpat_odd;\r\nisif_write(isif->isif_cfg.base_addr, val, CULH);\r\nisif_write(isif->isif_cfg.base_addr, cul->vcpat, CULV);\r\nisif_merge(isif->isif_cfg.base_addr, ISIF_LPF_MASK << ISIF_LPF_SHIFT,\r\ncul->en_lpf << ISIF_LPF_SHIFT, MODESET);\r\n}\r\nstatic int isif_get_pix_fmt(u32 mbus_code)\r\n{\r\nswitch (mbus_code) {\r\ncase MEDIA_BUS_FMT_SGRBG10_ALAW8_1X8:\r\ncase MEDIA_BUS_FMT_SGRBG10_DPCM8_1X8:\r\ncase MEDIA_BUS_FMT_SGRBG12_1X12:\r\nreturn ISIF_PIXFMT_RAW;\r\ncase MEDIA_BUS_FMT_YUYV8_2X8:\r\ncase MEDIA_BUS_FMT_UYVY8_2X8:\r\ncase MEDIA_BUS_FMT_YUYV10_2X10:\r\ncase MEDIA_BUS_FMT_Y8_1X8:\r\nreturn ISIF_PIXFMT_YCBCR_8BIT;\r\ncase MEDIA_BUS_FMT_YUYV8_1X16:\r\ncase MEDIA_BUS_FMT_YUYV10_1X20:\r\nreturn ISIF_PIXFMT_YCBCR_16BIT;\r\ndefault:\r\nbreak;\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int isif_config_raw(struct v4l2_subdev *sd, int mode)\r\n{\r\nstruct vpfe_isif_device *isif = v4l2_get_subdevdata(sd);\r\nstruct isif_params_raw *params = &isif->isif_cfg.bayer;\r\nstruct vpfe_isif_raw_config *module_params =\r\n&isif->isif_cfg.bayer.config_params;\r\nstruct v4l2_mbus_framefmt *format;\r\nint pix_fmt;\r\nu32 val;\r\nformat = &isif->formats[ISIF_PAD_SINK];\r\nisif_write(isif->isif_cfg.base_addr, 0, REC656IF);\r\nval = ISIF_YCINSWP_RAW | ISIF_CCDCFG_FIDMD_LATCH_VSYNC |\r\nISIF_CCDCFG_WENLOG_AND | ISIF_CCDCFG_TRGSEL_WEN |\r\nISIF_CCDCFG_EXTRG_DISABLE | (isif->isif_cfg.data_pack &\r\nISIF_DATA_PACK_MASK);\r\nisif_write(isif->isif_cfg.base_addr, val, CCDCFG);\r\npix_fmt = isif_get_pix_fmt(format->code);\r\nif (pix_fmt < 0) {\r\npr_debug("Invalid pix_fmt(input mode)\n");\r\nreturn -EINVAL;\r\n}\r\nval = ISIF_VDHDOUT_INPUT | ((params->vd_pol & ISIF_VD_POL_MASK) <<\r\nISIF_VD_POL_SHIFT) | ((params->hd_pol & ISIF_HD_POL_MASK) <<\r\nISIF_HD_POL_SHIFT) | ((params->fid_pol & ISIF_FID_POL_MASK) <<\r\nISIF_FID_POL_SHIFT) | ((ISIF_DATAPOL_NORMAL &\r\nISIF_DATAPOL_MASK) << ISIF_DATAPOL_SHIFT) | ((ISIF_EXWEN_DISABLE &\r\nISIF_EXWEN_MASK) << ISIF_EXWEN_SHIFT) | ((params->frm_fmt &\r\nISIF_FRM_FMT_MASK) << ISIF_FRM_FMT_SHIFT) | ((pix_fmt &\r\nISIF_INPUT_MASK) << ISIF_INPUT_SHIFT);\r\nif (format->code == MEDIA_BUS_FMT_SGRBG12_1X12)\r\nval |= ((VPFE_ISIF_NO_SHIFT &\r\nISIF_DATASFT_MASK) << ISIF_DATASFT_SHIFT);\r\nisif_write(isif->isif_cfg.base_addr, val, MODESET);\r\nval = (params->cfa_pat & ISIF_GAMMAWD_CFA_MASK) <<\r\nISIF_GAMMAWD_CFA_SHIFT;\r\nif (params->v4l2_pix_fmt == V4L2_PIX_FMT_SGRBG10ALAW8)\r\nval = val | ISIF_ALAW_ENABLE;\r\nval = val | ((params->data_msb & ISIF_ALAW_GAMA_WD_MASK) <<\r\nISIF_ALAW_GAMA_WD_SHIFT);\r\nisif_write(isif->isif_cfg.base_addr, val, CGAMMAWD);\r\nif (params->v4l2_pix_fmt == V4L2_PIX_FMT_SGRBG10DPCM8) {\r\nval = 1 << ISIF_DPCM_EN_SHIFT;\r\nval |= (params->dpcm_predictor &\r\nISIF_DPCM_PREDICTOR_MASK) << ISIF_DPCM_PREDICTOR_SHIFT;\r\n}\r\nisif_write(isif->isif_cfg.base_addr, val, MISC);\r\nisif_config_gain_offset(isif);\r\nif (format->code == MEDIA_BUS_FMT_SGRBG12_1X12)\r\nval = isif_sgrbg_pattern;\r\nelse\r\nval = isif_srggb_pattern;\r\nisif_write(isif->isif_cfg.base_addr, val, CCOLP);\r\nval = (params->horz_flip_en & ISIF_HSIZE_FLIP_MASK) <<\r\nISIF_HSIZE_FLIP_SHIFT;\r\nif (isif->isif_cfg.data_pack == ISIF_PACK_8BIT)\r\nval |= ((params->win.width + 31) >> 5) & ISIF_LINEOFST_MASK;\r\nelse if (isif->isif_cfg.data_pack == ISIF_PACK_12BIT)\r\nval |= ((((params->win.width + (params->win.width >> 2)) +\r\n31) >> 5) & ISIF_LINEOFST_MASK);\r\nelse\r\nval |= (((params->win.width * 2) + 31) >> 5) &\r\nISIF_LINEOFST_MASK;\r\nisif_write(isif->isif_cfg.base_addr, val, HSIZE);\r\nif (params->frm_fmt == ISIF_FRMFMT_INTERLACED) {\r\nif (params->image_invert_en)\r\nisif_write(isif->isif_cfg.base_addr,\r\nISIF_INTERLACE_INVERSE_MODE, SDOFST);\r\nelse\r\nisif_write(isif->isif_cfg.base_addr,\r\nISIF_INTERLACE_NON_INVERSE_MODE, SDOFST);\r\n} else if (params->frm_fmt == ISIF_FRMFMT_PROGRESSIVE) {\r\nif (params->image_invert_en)\r\nisif_write(isif->isif_cfg.base_addr,\r\nISIF_PROGRESSIVE_INVERSE_MODE, SDOFST);\r\nelse\r\nisif_write(isif->isif_cfg.base_addr,\r\nISIF_PROGRESSIVE_NON_INVERSE_MODE, SDOFST);\r\n}\r\nisif_setwin(isif, &params->win, params->frm_fmt, 1, mode);\r\nisif_config_bclamp(isif, &module_params->bclamp);\r\nisif_config_dfc(isif, &module_params->dfc);\r\nif (!module_params->df_csc.df_or_csc)\r\nisif_config_csc(isif, &module_params->df_csc);\r\nisif_config_linearization(isif, &module_params->linearize);\r\nisif_config_culling(isif, &module_params->culling);\r\nval = module_params->horz_offset & ISIF_DATA_H_OFFSET_MASK;\r\nisif_write(isif->isif_cfg.base_addr, val, DATAHOFST);\r\nval = module_params->vert_offset & ISIF_DATA_V_OFFSET_MASK;\r\nisif_write(isif->isif_cfg.base_addr, val, DATAVOFST);\r\nreturn 0;\r\n}\r\nstatic int isif_config_ycbcr(struct v4l2_subdev *sd, int mode)\r\n{\r\nstruct vpfe_isif_device *isif = v4l2_get_subdevdata(sd);\r\nstruct isif_ycbcr_config *params = &isif->isif_cfg.ycbcr;\r\nstruct v4l2_mbus_framefmt *format;\r\nint pix_fmt;\r\nu32 modeset;\r\nu32 ccdcfg;\r\nformat = &isif->formats[ISIF_PAD_SINK];\r\nccdcfg = 0;\r\nmodeset = 0;\r\npix_fmt = isif_get_pix_fmt(format->code);\r\nif (pix_fmt < 0) {\r\npr_debug("Invalid pix_fmt(input mode)\n");\r\nreturn -EINVAL;\r\n}\r\nmodeset = modeset | ((pix_fmt & ISIF_INPUT_MASK) <<\r\nISIF_INPUT_SHIFT) | ((params->frm_fmt & ISIF_FRM_FMT_MASK) <<\r\nISIF_FRM_FMT_SHIFT) | (((params->fid_pol &\r\nISIF_FID_POL_MASK) << ISIF_FID_POL_SHIFT)) |\r\n(((params->hd_pol & ISIF_HD_POL_MASK) << ISIF_HD_POL_SHIFT)) |\r\n(((params->vd_pol & ISIF_VD_POL_MASK) << ISIF_VD_POL_SHIFT));\r\nswitch (format->code) {\r\ncase MEDIA_BUS_FMT_YUYV8_2X8:\r\ncase MEDIA_BUS_FMT_UYVY8_2X8:\r\nif (pix_fmt != ISIF_PIXFMT_YCBCR_8BIT) {\r\npr_debug("Invalid pix_fmt(input mode)\n");\r\nreturn -EINVAL;\r\n}\r\nmodeset |= ((VPFE_PINPOL_NEGATIVE & ISIF_VD_POL_MASK) <<\r\nISIF_VD_POL_SHIFT);\r\nisif_write(isif->isif_cfg.base_addr, 3, REC656IF);\r\nccdcfg = ccdcfg | ISIF_PACK_8BIT | ISIF_YCINSWP_YCBCR;\r\nbreak;\r\ncase MEDIA_BUS_FMT_YUYV10_2X10:\r\nif (pix_fmt != ISIF_PIXFMT_YCBCR_8BIT) {\r\npr_debug("Invalid pix_fmt(input mode)\n");\r\nreturn -EINVAL;\r\n}\r\nisif_write(isif->isif_cfg.base_addr, 3, REC656IF);\r\nccdcfg = ccdcfg | ISIF_PACK_8BIT | ISIF_YCINSWP_YCBCR |\r\nISIF_BW656_ENABLE;\r\nbreak;\r\ncase MEDIA_BUS_FMT_YUYV10_1X20:\r\nif (pix_fmt != ISIF_PIXFMT_YCBCR_16BIT) {\r\npr_debug("Invalid pix_fmt(input mode)\n");\r\nreturn -EINVAL;\r\n}\r\nisif_write(isif->isif_cfg.base_addr, 3, REC656IF);\r\nbreak;\r\ncase MEDIA_BUS_FMT_Y8_1X8:\r\nccdcfg |= ISIF_PACK_8BIT;\r\nccdcfg |= ISIF_YCINSWP_YCBCR;\r\nif (pix_fmt != ISIF_PIXFMT_YCBCR_8BIT) {\r\npr_debug("Invalid pix_fmt(input mode)\n");\r\nreturn -EINVAL;\r\n}\r\nbreak;\r\ncase MEDIA_BUS_FMT_YUYV8_1X16:\r\nif (pix_fmt != ISIF_PIXFMT_YCBCR_16BIT) {\r\npr_debug("Invalid pix_fmt(input mode)\n");\r\nreturn -EINVAL;\r\n}\r\nbreak;\r\ndefault:\r\npr_debug("Invalid interface type\n");\r\nreturn -EINVAL;\r\n}\r\nisif_write(isif->isif_cfg.base_addr, modeset, MODESET);\r\nccdcfg |= (params->pix_order & ISIF_PIX_ORDER_MASK) <<\r\nISIF_PIX_ORDER_SHIFT;\r\nisif_write(isif->isif_cfg.base_addr, ccdcfg, CCDCFG);\r\nif (format->code == MEDIA_BUS_FMT_YUYV10_1X20 ||\r\nformat->code == MEDIA_BUS_FMT_YUYV8_1X16)\r\nisif_setwin(isif, &params->win, params->frm_fmt, 1, mode);\r\nelse\r\nisif_setwin(isif, &params->win, params->frm_fmt, 2, mode);\r\nisif_write(isif->isif_cfg.base_addr,\r\n((((params->win.width * 2) + 31) &\r\nDM365_ISIF_HSIZE_MASK) >> 5), HSIZE);\r\nif (params->frm_fmt == ISIF_FRMFMT_INTERLACED &&\r\nparams->buf_type == ISIF_BUFTYPE_FLD_INTERLEAVED)\r\nisif_write(isif->isif_cfg.base_addr,\r\nDM365_ISIF_SDOFST_2_LINES, SDOFST);\r\nreturn 0;\r\n}\r\nstatic int isif_configure(struct v4l2_subdev *sd, int mode)\r\n{\r\nstruct vpfe_isif_device *isif = v4l2_get_subdevdata(sd);\r\nstruct v4l2_mbus_framefmt *format;\r\nformat = &isif->formats[ISIF_PAD_SINK];\r\nswitch (format->code) {\r\ncase MEDIA_BUS_FMT_SGRBG10_ALAW8_1X8:\r\ncase MEDIA_BUS_FMT_SGRBG10_DPCM8_1X8:\r\ncase MEDIA_BUS_FMT_SGRBG12_1X12:\r\nreturn isif_config_raw(sd, mode);\r\ncase MEDIA_BUS_FMT_YUYV8_2X8:\r\ncase MEDIA_BUS_FMT_UYVY8_2X8:\r\ncase MEDIA_BUS_FMT_YUYV10_2X10:\r\ncase MEDIA_BUS_FMT_Y8_1X8:\r\ncase MEDIA_BUS_FMT_YUYV8_1X16:\r\ncase MEDIA_BUS_FMT_YUYV10_1X20:\r\nreturn isif_config_ycbcr(sd, mode);\r\ndefault:\r\nbreak;\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int isif_set_stream(struct v4l2_subdev *sd, int enable)\r\n{\r\nstruct vpfe_isif_device *isif = v4l2_get_subdevdata(sd);\r\nint ret;\r\nif (enable) {\r\nret = isif_configure(sd,\r\n(isif->output == ISIF_OUTPUT_MEMORY) ? 0 : 1);\r\nif (ret)\r\nreturn ret;\r\nif (isif->output == ISIF_OUTPUT_MEMORY)\r\nisif_enable_output_to_sdram(isif, 1);\r\nisif_enable(isif, 1);\r\n} else {\r\nisif_enable(isif, 0);\r\nisif_enable_output_to_sdram(isif, 0);\r\n}\r\nreturn 0;\r\n}\r\nstatic struct v4l2_mbus_framefmt *\r\n__isif_get_format(struct vpfe_isif_device *isif,\r\nstruct v4l2_subdev_pad_config *cfg, unsigned int pad,\r\nenum v4l2_subdev_format_whence which)\r\n{\r\nif (which == V4L2_SUBDEV_FORMAT_TRY) {\r\nstruct v4l2_subdev_format fmt;\r\nfmt.pad = pad;\r\nfmt.which = which;\r\nreturn v4l2_subdev_get_try_format(&isif->subdev, cfg, pad);\r\n}\r\nreturn &isif->formats[pad];\r\n}\r\nstatic int\r\nisif_set_format(struct v4l2_subdev *sd, struct v4l2_subdev_pad_config *cfg,\r\nstruct v4l2_subdev_format *fmt)\r\n{\r\nstruct vpfe_isif_device *isif = v4l2_get_subdevdata(sd);\r\nstruct vpfe_device *vpfe_dev = to_vpfe_device(isif);\r\nstruct v4l2_mbus_framefmt *format;\r\nformat = __isif_get_format(isif, cfg, fmt->pad, fmt->which);\r\nif (format == NULL)\r\nreturn -EINVAL;\r\nisif_try_format(isif, cfg, fmt);\r\nmemcpy(format, &fmt->format, sizeof(*format));\r\nif (fmt->which == V4L2_SUBDEV_FORMAT_TRY)\r\nreturn 0;\r\nif (fmt->pad == ISIF_PAD_SOURCE)\r\nreturn isif_config_format(vpfe_dev, fmt->pad);\r\nreturn 0;\r\n}\r\nstatic int\r\nisif_get_format(struct v4l2_subdev *sd, struct v4l2_subdev_pad_config *cfg,\r\nstruct v4l2_subdev_format *fmt)\r\n{\r\nstruct vpfe_isif_device *vpfe_isif = v4l2_get_subdevdata(sd);\r\nstruct v4l2_mbus_framefmt *format;\r\nformat = __isif_get_format(vpfe_isif, cfg, fmt->pad, fmt->which);\r\nif (format == NULL)\r\nreturn -EINVAL;\r\nmemcpy(&fmt->format, format, sizeof(fmt->format));\r\nreturn 0;\r\n}\r\nstatic int\r\nisif_enum_frame_size(struct v4l2_subdev *sd, struct v4l2_subdev_pad_config *cfg,\r\nstruct v4l2_subdev_frame_size_enum *fse)\r\n{\r\nstruct vpfe_isif_device *isif = v4l2_get_subdevdata(sd);\r\nstruct v4l2_subdev_format format;\r\nif (fse->index != 0)\r\nreturn -EINVAL;\r\nformat.pad = fse->pad;\r\nformat.format.code = fse->code;\r\nformat.format.width = 1;\r\nformat.format.height = 1;\r\nformat.which = fse->which;\r\nisif_try_format(isif, cfg, &format);\r\nfse->min_width = format.format.width;\r\nfse->min_height = format.format.height;\r\nif (format.format.code != fse->code)\r\nreturn -EINVAL;\r\nformat.pad = fse->pad;\r\nformat.format.code = fse->code;\r\nformat.format.width = -1;\r\nformat.format.height = -1;\r\nformat.which = fse->which;\r\nisif_try_format(isif, cfg, &format);\r\nfse->max_width = format.format.width;\r\nfse->max_height = format.format.height;\r\nreturn 0;\r\n}\r\nstatic int\r\nisif_enum_mbus_code(struct v4l2_subdev *sd, struct v4l2_subdev_pad_config *cfg,\r\nstruct v4l2_subdev_mbus_code_enum *code)\r\n{\r\nswitch (code->pad) {\r\ncase ISIF_PAD_SINK:\r\ncase ISIF_PAD_SOURCE:\r\nif (code->index >= ARRAY_SIZE(isif_fmts))\r\nreturn -EINVAL;\r\ncode->code = isif_fmts[code->index];\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int\r\nisif_pad_set_selection(struct v4l2_subdev *sd,\r\nstruct v4l2_subdev_pad_config *cfg,\r\nstruct v4l2_subdev_selection *sel)\r\n{\r\nstruct vpfe_isif_device *vpfe_isif = v4l2_get_subdevdata(sd);\r\nstruct v4l2_mbus_framefmt *format;\r\nif (sel->pad != ISIF_PAD_SINK || sel->target != V4L2_SEL_TGT_CROP)\r\nreturn -EINVAL;\r\nformat = __isif_get_format(vpfe_isif, cfg, sel->pad, sel->which);\r\nif (format == NULL)\r\nreturn -EINVAL;\r\nif (sel->r.top < 0 || sel->r.left < 0 ||\r\n(sel->r.left + sel->r.width >\r\nvpfe_isif->formats[ISIF_PAD_SINK].width) ||\r\n(sel->r.top + sel->r.height >\r\nvpfe_isif->formats[ISIF_PAD_SINK].height)) {\r\nsel->r.left = 0;\r\nsel->r.top = 0;\r\nsel->r.width = format->width;\r\nsel->r.height = format->height;\r\n}\r\nsel->r.width = (sel->r.width + 15) & ~0xf;\r\nvpfe_isif->crop = sel->r;\r\nif (sel->which == V4L2_SUBDEV_FORMAT_ACTIVE) {\r\nisif_set_image_window(vpfe_isif);\r\n} else {\r\nstruct v4l2_rect *rect;\r\nrect = v4l2_subdev_get_try_crop(sd, cfg, ISIF_PAD_SINK);\r\nmemcpy(rect, &vpfe_isif->crop, sizeof(*rect));\r\n}\r\nreturn 0;\r\n}\r\nstatic int\r\nisif_pad_get_selection(struct v4l2_subdev *sd,\r\nstruct v4l2_subdev_pad_config *cfg,\r\nstruct v4l2_subdev_selection *sel)\r\n{\r\nstruct vpfe_isif_device *vpfe_isif = v4l2_get_subdevdata(sd);\r\nif (sel->pad != ISIF_PAD_SINK || sel->target != V4L2_SEL_TGT_CROP)\r\nreturn -EINVAL;\r\nif (sel->which == V4L2_SUBDEV_FORMAT_TRY) {\r\nstruct v4l2_rect *rect;\r\nrect = v4l2_subdev_get_try_crop(sd, cfg, ISIF_PAD_SINK);\r\nmemcpy(&sel->r, rect, sizeof(*rect));\r\n} else {\r\nsel->r = vpfe_isif->crop;\r\n}\r\nreturn 0;\r\n}\r\nstatic int\r\nisif_init_formats(struct v4l2_subdev *sd,\r\nstruct v4l2_subdev_fh *fh)\r\n{\r\nstruct v4l2_subdev_format format;\r\nstruct v4l2_subdev_selection sel;\r\nmemset(&format, 0, sizeof(format));\r\nformat.pad = ISIF_PAD_SINK;\r\nformat.which = V4L2_SUBDEV_FORMAT_TRY;\r\nformat.format.code = MEDIA_BUS_FMT_SGRBG12_1X12;\r\nformat.format.width = MAX_WIDTH;\r\nformat.format.height = MAX_HEIGHT;\r\nisif_set_format(sd, fh->pad, &format);\r\nmemset(&format, 0, sizeof(format));\r\nformat.pad = ISIF_PAD_SOURCE;\r\nformat.which = V4L2_SUBDEV_FORMAT_TRY;\r\nformat.format.code = MEDIA_BUS_FMT_SGRBG12_1X12;\r\nformat.format.width = MAX_WIDTH;\r\nformat.format.height = MAX_HEIGHT;\r\nisif_set_format(sd, fh->pad, &format);\r\nmemset(&sel, 0, sizeof(sel));\r\nsel.pad = ISIF_PAD_SINK;\r\nsel.which = V4L2_SUBDEV_FORMAT_TRY;\r\nsel.target = V4L2_SEL_TGT_CROP;\r\nsel.r.width = MAX_WIDTH;\r\nsel.r.height = MAX_HEIGHT;\r\nisif_pad_set_selection(sd, fh->pad, &sel);\r\nreturn 0;\r\n}\r\nstatic int\r\nisif_link_setup(struct media_entity *entity, const struct media_pad *local,\r\nconst struct media_pad *remote, u32 flags)\r\n{\r\nstruct v4l2_subdev *sd = media_entity_to_v4l2_subdev(entity);\r\nstruct vpfe_isif_device *isif = v4l2_get_subdevdata(sd);\r\nunsigned int index = local->index;\r\nif (is_media_entity_v4l2_subdev(remote->entity))\r\nindex |= 2 << 16;\r\nswitch (index) {\r\ncase ISIF_PAD_SINK | 2 << 16:\r\nif (!(flags & MEDIA_LNK_FL_ENABLED)) {\r\nisif->input = ISIF_INPUT_NONE;\r\nbreak;\r\n}\r\nif (isif->input != ISIF_INPUT_NONE)\r\nreturn -EBUSY;\r\nisif->input = ISIF_INPUT_PARALLEL;\r\nbreak;\r\ncase ISIF_PAD_SOURCE:\r\nif (flags & MEDIA_LNK_FL_ENABLED)\r\nisif->output = ISIF_OUTPUT_MEMORY;\r\nelse\r\nisif->output = ISIF_OUTPUT_NONE;\r\nbreak;\r\ncase ISIF_PAD_SOURCE | 2 << 16:\r\nif (flags & MEDIA_LNK_FL_ENABLED)\r\nisif->output = ISIF_OUTPUT_IPIPEIF;\r\nelse\r\nisif->output = ISIF_OUTPUT_NONE;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nvoid vpfe_isif_unregister_entities(struct vpfe_isif_device *isif)\r\n{\r\nvpfe_video_unregister(&isif->video_out);\r\nv4l2_device_unregister_subdev(&isif->subdev);\r\nmedia_entity_cleanup(&isif->subdev.entity);\r\n}\r\nstatic void isif_restore_defaults(struct vpfe_isif_device *isif)\r\n{\r\nenum vpss_ccdc_source_sel source = VPSS_CCDCIN;\r\nint i;\r\nmemset(&isif->isif_cfg.bayer.config_params, 0,\r\nsizeof(struct vpfe_isif_raw_config));\r\nisif->isif_cfg.bayer.config_params.linearize.corr_shft =\r\nVPFE_ISIF_NO_SHIFT;\r\nisif->isif_cfg.bayer.config_params.linearize.scale_fact.integer = 1;\r\nisif->isif_cfg.bayer.config_params.culling.hcpat_odd =\r\nISIF_CULLING_HCAPT_ODD;\r\nisif->isif_cfg.bayer.config_params.culling.hcpat_even =\r\nISIF_CULLING_HCAPT_EVEN;\r\nisif->isif_cfg.bayer.config_params.culling.vcpat = ISIF_CULLING_VCAPT;\r\nvpss_enable_clock(VPSS_CCDC_CLOCK, 1);\r\nvpss_enable_clock(VPSS_IPIPEIF_CLOCK, 1);\r\nvpss_enable_clock(VPSS_BL_CLOCK, 1);\r\nfor (i = 0; i <= 0x1f8; i += 4)\r\nisif_write(isif->isif_cfg.base_addr, 0, i);\r\nisif_write(isif->isif_cfg.base_addr, 0xffff, CULH);\r\nisif_write(isif->isif_cfg.base_addr, 0xff, CULV);\r\nisif_config_gain_offset(isif);\r\nvpss_select_ccdc_source(source);\r\n}\r\nint vpfe_isif_register_entities(struct vpfe_isif_device *isif,\r\nstruct v4l2_device *vdev)\r\n{\r\nstruct vpfe_device *vpfe_dev = to_vpfe_device(isif);\r\nunsigned int flags;\r\nint ret;\r\nret = v4l2_device_register_subdev(vdev, &isif->subdev);\r\nif (ret < 0)\r\nreturn ret;\r\nisif_restore_defaults(isif);\r\nret = vpfe_video_register(&isif->video_out, vdev);\r\nif (ret) {\r\npr_err("Failed to register isif video out device\n");\r\ngoto out_video_register;\r\n}\r\nisif->video_out.vpfe_dev = vpfe_dev;\r\nflags = 0;\r\nret = media_create_pad_link(&isif->subdev.entity, 1,\r\n&isif->video_out.video_dev.entity,\r\n0, flags);\r\nif (ret < 0)\r\ngoto out_create_link;\r\nreturn 0;\r\nout_create_link:\r\nvpfe_video_unregister(&isif->video_out);\r\nout_video_register:\r\nv4l2_device_unregister_subdev(&isif->subdev);\r\nreturn ret;\r\n}\r\nstatic int vpfe_isif_s_ctrl(struct v4l2_ctrl *ctrl)\r\n{\r\nstruct vpfe_isif_device *isif =\r\ncontainer_of(ctrl->handler, struct vpfe_isif_device, ctrls);\r\nstruct isif_oper_config *config = &isif->isif_cfg;\r\nswitch (ctrl->id) {\r\ncase VPFE_CID_DPCM_PREDICTOR:\r\nconfig->bayer.dpcm_predictor = ctrl->val;\r\nbreak;\r\ncase VPFE_ISIF_CID_CRGAIN:\r\nconfig->isif_gain_params.cr_gain = ctrl->val;\r\nbreak;\r\ncase VPFE_ISIF_CID_CGRGAIN:\r\nconfig->isif_gain_params.cgr_gain = ctrl->val;\r\nbreak;\r\ncase VPFE_ISIF_CID_CGBGAIN:\r\nconfig->isif_gain_params.cgb_gain = ctrl->val;\r\nbreak;\r\ncase VPFE_ISIF_CID_CBGAIN:\r\nconfig->isif_gain_params.cb_gain = ctrl->val;\r\nbreak;\r\ncase VPFE_ISIF_CID_GAIN_OFFSET:\r\nconfig->isif_gain_params.offset = ctrl->val;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic void isif_remove(struct vpfe_isif_device *isif,\r\nstruct platform_device *pdev)\r\n{\r\nstruct resource *res;\r\nint i = 0;\r\niounmap(isif->isif_cfg.base_addr);\r\niounmap(isif->isif_cfg.linear_tbl0_addr);\r\niounmap(isif->isif_cfg.linear_tbl1_addr);\r\nwhile (i < 3) {\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, i);\r\nif (res)\r\nrelease_mem_region(res->start,\r\nresource_size(res));\r\ni++;\r\n}\r\n}\r\nstatic void isif_config_defaults(struct vpfe_isif_device *isif)\r\n{\r\nisif->isif_cfg.ycbcr.v4l2_pix_fmt = V4L2_PIX_FMT_UYVY;\r\nisif->isif_cfg.ycbcr.pix_fmt = ISIF_PIXFMT_YCBCR_8BIT;\r\nisif->isif_cfg.ycbcr.frm_fmt = ISIF_FRMFMT_INTERLACED;\r\nisif->isif_cfg.ycbcr.fid_pol = VPFE_PINPOL_POSITIVE;\r\nisif->isif_cfg.ycbcr.vd_pol = VPFE_PINPOL_POSITIVE;\r\nisif->isif_cfg.ycbcr.hd_pol = VPFE_PINPOL_POSITIVE;\r\nisif->isif_cfg.ycbcr.pix_order = ISIF_PIXORDER_CBYCRY;\r\nisif->isif_cfg.ycbcr.buf_type = ISIF_BUFTYPE_FLD_INTERLEAVED;\r\nisif->isif_cfg.bayer.v4l2_pix_fmt = V4L2_PIX_FMT_SGRBG10ALAW8;\r\nisif->isif_cfg.bayer.pix_fmt = ISIF_PIXFMT_RAW;\r\nisif->isif_cfg.bayer.frm_fmt = ISIF_FRMFMT_PROGRESSIVE;\r\nisif->isif_cfg.bayer.fid_pol = VPFE_PINPOL_POSITIVE;\r\nisif->isif_cfg.bayer.vd_pol = VPFE_PINPOL_POSITIVE;\r\nisif->isif_cfg.bayer.hd_pol = VPFE_PINPOL_POSITIVE;\r\nisif->isif_cfg.bayer.cfa_pat = ISIF_CFA_PAT_MOSAIC;\r\nisif->isif_cfg.bayer.data_msb = ISIF_BIT_MSB_11;\r\nisif->isif_cfg.data_pack = ISIF_PACK_8BIT;\r\n}\r\nint vpfe_isif_init(struct vpfe_isif_device *isif, struct platform_device *pdev)\r\n{\r\nstruct v4l2_subdev *sd = &isif->subdev;\r\nstruct media_pad *pads = &isif->pads[0];\r\nstruct media_entity *me = &sd->entity;\r\nstatic resource_size_t res_len;\r\nstruct resource *res;\r\nvoid __iomem *addr;\r\nint status;\r\nint i = 0;\r\nwhile (i < 3) {\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, i);\r\nif (!res) {\r\nstatus = -ENOENT;\r\ngoto fail_nobase_res;\r\n}\r\nres_len = resource_size(res);\r\nres = request_mem_region(res->start, res_len, res->name);\r\nif (!res) {\r\nstatus = -EBUSY;\r\ngoto fail_nobase_res;\r\n}\r\naddr = ioremap_nocache(res->start, res_len);\r\nif (!addr) {\r\nstatus = -EBUSY;\r\ngoto fail_base_iomap;\r\n}\r\nswitch (i) {\r\ncase 0:\r\nisif->isif_cfg.base_addr = addr;\r\nbreak;\r\ncase 1:\r\nisif->isif_cfg.linear_tbl0_addr = addr;\r\nbreak;\r\ndefault:\r\nisif->isif_cfg.linear_tbl1_addr = addr;\r\nbreak;\r\n}\r\ni++;\r\n}\r\ndavinci_cfg_reg(DM365_VIN_CAM_WEN);\r\ndavinci_cfg_reg(DM365_VIN_CAM_VD);\r\ndavinci_cfg_reg(DM365_VIN_CAM_HD);\r\ndavinci_cfg_reg(DM365_VIN_YIN4_7_EN);\r\ndavinci_cfg_reg(DM365_VIN_YIN0_3_EN);\r\nisif->video_out.ops = &isif_video_ops;\r\nv4l2_subdev_init(sd, &isif_v4l2_ops);\r\nsd->internal_ops = &isif_v4l2_internal_ops;\r\nstrlcpy(sd->name, "DAVINCI ISIF", sizeof(sd->name));\r\nsd->grp_id = 1 << 16;\r\nv4l2_set_subdevdata(sd, isif);\r\nsd->flags |= V4L2_SUBDEV_FL_HAS_EVENTS | V4L2_SUBDEV_FL_HAS_DEVNODE;\r\npads[ISIF_PAD_SINK].flags = MEDIA_PAD_FL_SINK;\r\npads[ISIF_PAD_SOURCE].flags = MEDIA_PAD_FL_SOURCE;\r\nisif->input = ISIF_INPUT_NONE;\r\nisif->output = ISIF_OUTPUT_NONE;\r\nme->ops = &isif_media_ops;\r\nstatus = media_entity_pads_init(me, ISIF_PADS_NUM, pads);\r\nif (status)\r\ngoto isif_fail;\r\nisif->video_out.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;\r\nstatus = vpfe_video_init(&isif->video_out, "ISIF");\r\nif (status) {\r\npr_err("Failed to init isif-out video device\n");\r\ngoto isif_fail;\r\n}\r\nv4l2_ctrl_handler_init(&isif->ctrls, 6);\r\nv4l2_ctrl_new_custom(&isif->ctrls, &vpfe_isif_crgain, NULL);\r\nv4l2_ctrl_new_custom(&isif->ctrls, &vpfe_isif_cgrgain, NULL);\r\nv4l2_ctrl_new_custom(&isif->ctrls, &vpfe_isif_cgbgain, NULL);\r\nv4l2_ctrl_new_custom(&isif->ctrls, &vpfe_isif_cbgain, NULL);\r\nv4l2_ctrl_new_custom(&isif->ctrls, &vpfe_isif_gain_offset, NULL);\r\nv4l2_ctrl_new_custom(&isif->ctrls, &vpfe_isif_dpcm_pred, NULL);\r\nv4l2_ctrl_handler_setup(&isif->ctrls);\r\nsd->ctrl_handler = &isif->ctrls;\r\nisif_config_defaults(isif);\r\nreturn 0;\r\nfail_base_iomap:\r\nrelease_mem_region(res->start, res_len);\r\ni--;\r\nfail_nobase_res:\r\nif (isif->isif_cfg.base_addr)\r\niounmap(isif->isif_cfg.base_addr);\r\nif (isif->isif_cfg.linear_tbl0_addr)\r\niounmap(isif->isif_cfg.linear_tbl0_addr);\r\nwhile (i >= 0) {\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, i);\r\nrelease_mem_region(res->start, res_len);\r\ni--;\r\n}\r\nreturn status;\r\nisif_fail:\r\nv4l2_ctrl_handler_free(&isif->ctrls);\r\nisif_remove(isif, pdev);\r\nreturn status;\r\n}\r\nvoid\r\nvpfe_isif_cleanup(struct vpfe_isif_device *isif, struct platform_device *pdev)\r\n{\r\nisif_remove(isif, pdev);\r\n}
