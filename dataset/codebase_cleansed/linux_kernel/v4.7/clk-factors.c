static unsigned long clk_factors_recalc_rate(struct clk_hw *hw,\r\nunsigned long parent_rate)\r\n{\r\nu8 n = 1, k = 0, p = 0, m = 0;\r\nu32 reg;\r\nunsigned long rate;\r\nstruct clk_factors *factors = to_clk_factors(hw);\r\nconst struct clk_factors_config *config = factors->config;\r\nreg = readl(factors->reg);\r\nif (config->nwidth != SUNXI_FACTORS_NOT_APPLICABLE)\r\nn = FACTOR_GET(config->nshift, config->nwidth, reg);\r\nif (config->kwidth != SUNXI_FACTORS_NOT_APPLICABLE)\r\nk = FACTOR_GET(config->kshift, config->kwidth, reg);\r\nif (config->mwidth != SUNXI_FACTORS_NOT_APPLICABLE)\r\nm = FACTOR_GET(config->mshift, config->mwidth, reg);\r\nif (config->pwidth != SUNXI_FACTORS_NOT_APPLICABLE)\r\np = FACTOR_GET(config->pshift, config->pwidth, reg);\r\nif (factors->recalc) {\r\nstruct factors_request factors_req = {\r\n.parent_rate = parent_rate,\r\n.n = n,\r\n.k = k,\r\n.m = m,\r\n.p = p,\r\n};\r\nif (factors->mux)\r\nfactors_req.parent_index =\r\n(reg >> factors->mux->shift) &\r\nfactors->mux->mask;\r\nfactors->recalc(&factors_req);\r\nreturn factors_req.rate;\r\n}\r\nrate = (parent_rate * (n + config->n_start) * (k + 1) >> p) / (m + 1);\r\nreturn rate;\r\n}\r\nstatic int clk_factors_determine_rate(struct clk_hw *hw,\r\nstruct clk_rate_request *req)\r\n{\r\nstruct clk_factors *factors = to_clk_factors(hw);\r\nstruct clk_hw *parent, *best_parent = NULL;\r\nint i, num_parents;\r\nunsigned long parent_rate, best = 0, child_rate, best_child_rate = 0;\r\nnum_parents = clk_hw_get_num_parents(hw);\r\nfor (i = 0; i < num_parents; i++) {\r\nstruct factors_request factors_req = {\r\n.rate = req->rate,\r\n.parent_index = i,\r\n};\r\nparent = clk_hw_get_parent_by_index(hw, i);\r\nif (!parent)\r\ncontinue;\r\nif (clk_hw_get_flags(hw) & CLK_SET_RATE_PARENT)\r\nparent_rate = clk_hw_round_rate(parent, req->rate);\r\nelse\r\nparent_rate = clk_hw_get_rate(parent);\r\nfactors_req.parent_rate = parent_rate;\r\nfactors->get_factors(&factors_req);\r\nchild_rate = factors_req.rate;\r\nif (child_rate <= req->rate && child_rate > best_child_rate) {\r\nbest_parent = parent;\r\nbest = parent_rate;\r\nbest_child_rate = child_rate;\r\n}\r\n}\r\nif (!best_parent)\r\nreturn -EINVAL;\r\nreq->best_parent_hw = best_parent;\r\nreq->best_parent_rate = best;\r\nreq->rate = best_child_rate;\r\nreturn 0;\r\n}\r\nstatic int clk_factors_set_rate(struct clk_hw *hw, unsigned long rate,\r\nunsigned long parent_rate)\r\n{\r\nstruct factors_request req = {\r\n.rate = rate,\r\n.parent_rate = parent_rate,\r\n};\r\nu32 reg;\r\nstruct clk_factors *factors = to_clk_factors(hw);\r\nconst struct clk_factors_config *config = factors->config;\r\nunsigned long flags = 0;\r\nfactors->get_factors(&req);\r\nif (factors->lock)\r\nspin_lock_irqsave(factors->lock, flags);\r\nreg = readl(factors->reg);\r\nreg = FACTOR_SET(config->nshift, config->nwidth, reg, req.n);\r\nreg = FACTOR_SET(config->kshift, config->kwidth, reg, req.k);\r\nreg = FACTOR_SET(config->mshift, config->mwidth, reg, req.m);\r\nreg = FACTOR_SET(config->pshift, config->pwidth, reg, req.p);\r\nwritel(reg, factors->reg);\r\n__delay((rate >> 20) * 500 / 2);\r\nif (factors->lock)\r\nspin_unlock_irqrestore(factors->lock, flags);\r\nreturn 0;\r\n}\r\nstruct clk *sunxi_factors_register(struct device_node *node,\r\nconst struct factors_data *data,\r\nspinlock_t *lock,\r\nvoid __iomem *reg)\r\n{\r\nstruct clk *clk;\r\nstruct clk_factors *factors;\r\nstruct clk_gate *gate = NULL;\r\nstruct clk_mux *mux = NULL;\r\nstruct clk_hw *gate_hw = NULL;\r\nstruct clk_hw *mux_hw = NULL;\r\nconst char *clk_name = node->name;\r\nconst char *parents[FACTORS_MAX_PARENTS];\r\nint ret, i = 0;\r\ni = of_clk_parent_fill(node, parents, FACTORS_MAX_PARENTS);\r\nif (data->name)\r\nclk_name = data->name;\r\nelse\r\nof_property_read_string(node, "clock-output-names", &clk_name);\r\nfactors = kzalloc(sizeof(struct clk_factors), GFP_KERNEL);\r\nif (!factors)\r\ngoto err_factors;\r\nfactors->reg = reg;\r\nfactors->config = data->table;\r\nfactors->get_factors = data->getter;\r\nfactors->recalc = data->recalc;\r\nfactors->lock = lock;\r\nif (data->enable) {\r\ngate = kzalloc(sizeof(struct clk_gate), GFP_KERNEL);\r\nif (!gate)\r\ngoto err_gate;\r\nfactors->gate = gate;\r\ngate->reg = reg;\r\ngate->bit_idx = data->enable;\r\ngate->lock = factors->lock;\r\ngate_hw = &gate->hw;\r\n}\r\nif (data->mux) {\r\nmux = kzalloc(sizeof(struct clk_mux), GFP_KERNEL);\r\nif (!mux)\r\ngoto err_mux;\r\nfactors->mux = mux;\r\nmux->reg = reg;\r\nmux->shift = data->mux;\r\nmux->mask = data->muxmask;\r\nmux->lock = factors->lock;\r\nmux_hw = &mux->hw;\r\n}\r\nclk = clk_register_composite(NULL, clk_name,\r\nparents, i,\r\nmux_hw, &clk_mux_ops,\r\n&factors->hw, &clk_factors_ops,\r\ngate_hw, &clk_gate_ops, 0);\r\nif (IS_ERR(clk))\r\ngoto err_register;\r\nret = of_clk_add_provider(node, of_clk_src_simple_get, clk);\r\nif (ret)\r\ngoto err_provider;\r\nreturn clk;\r\nerr_provider:\r\nclk_unregister(clk);\r\nerr_register:\r\nkfree(mux);\r\nerr_mux:\r\nkfree(gate);\r\nerr_gate:\r\nkfree(factors);\r\nerr_factors:\r\nreturn NULL;\r\n}\r\nvoid sunxi_factors_unregister(struct device_node *node, struct clk *clk)\r\n{\r\nstruct clk_hw *hw = __clk_get_hw(clk);\r\nstruct clk_factors *factors;\r\nconst char *name;\r\nif (!hw)\r\nreturn;\r\nfactors = to_clk_factors(hw);\r\nname = clk_hw_get_name(hw);\r\nof_clk_del_provider(node);\r\nclk_unregister(clk);\r\nkfree(factors->mux);\r\nkfree(factors->gate);\r\nkfree(factors);\r\n}
