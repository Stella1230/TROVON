static int dac_volume_info(struct snd_kcontrol *ctl,\r\nstruct snd_ctl_elem_info *info)\r\n{\r\nstruct oxygen *chip = ctl->private_data;\r\ninfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;\r\ninfo->count = chip->model.dac_channels_mixer;\r\ninfo->value.integer.min = chip->model.dac_volume_min;\r\ninfo->value.integer.max = chip->model.dac_volume_max;\r\nreturn 0;\r\n}\r\nstatic int dac_volume_get(struct snd_kcontrol *ctl,\r\nstruct snd_ctl_elem_value *value)\r\n{\r\nstruct oxygen *chip = ctl->private_data;\r\nunsigned int i;\r\nmutex_lock(&chip->mutex);\r\nfor (i = 0; i < chip->model.dac_channels_mixer; ++i)\r\nvalue->value.integer.value[i] = chip->dac_volume[i];\r\nmutex_unlock(&chip->mutex);\r\nreturn 0;\r\n}\r\nstatic int dac_volume_put(struct snd_kcontrol *ctl,\r\nstruct snd_ctl_elem_value *value)\r\n{\r\nstruct oxygen *chip = ctl->private_data;\r\nunsigned int i;\r\nint changed;\r\nchanged = 0;\r\nmutex_lock(&chip->mutex);\r\nfor (i = 0; i < chip->model.dac_channels_mixer; ++i)\r\nif (value->value.integer.value[i] != chip->dac_volume[i]) {\r\nchip->dac_volume[i] = value->value.integer.value[i];\r\nchanged = 1;\r\n}\r\nif (changed)\r\nchip->model.update_dac_volume(chip);\r\nmutex_unlock(&chip->mutex);\r\nreturn changed;\r\n}\r\nstatic int dac_mute_get(struct snd_kcontrol *ctl,\r\nstruct snd_ctl_elem_value *value)\r\n{\r\nstruct oxygen *chip = ctl->private_data;\r\nmutex_lock(&chip->mutex);\r\nvalue->value.integer.value[0] = !chip->dac_mute;\r\nmutex_unlock(&chip->mutex);\r\nreturn 0;\r\n}\r\nstatic int dac_mute_put(struct snd_kcontrol *ctl,\r\nstruct snd_ctl_elem_value *value)\r\n{\r\nstruct oxygen *chip = ctl->private_data;\r\nint changed;\r\nmutex_lock(&chip->mutex);\r\nchanged = (!value->value.integer.value[0]) != chip->dac_mute;\r\nif (changed) {\r\nchip->dac_mute = !value->value.integer.value[0];\r\nchip->model.update_dac_mute(chip);\r\n}\r\nmutex_unlock(&chip->mutex);\r\nreturn changed;\r\n}\r\nstatic unsigned int upmix_item_count(struct oxygen *chip)\r\n{\r\nif (chip->model.dac_channels_pcm < 8)\r\nreturn 2;\r\nelse if (chip->model.update_center_lfe_mix)\r\nreturn 5;\r\nelse\r\nreturn 3;\r\n}\r\nstatic int upmix_info(struct snd_kcontrol *ctl, struct snd_ctl_elem_info *info)\r\n{\r\nstatic const char *const names[5] = {\r\n"Front",\r\n"Front+Surround",\r\n"Front+Surround+Back",\r\n"Front+Surround+Center/LFE",\r\n"Front+Surround+Center/LFE+Back",\r\n};\r\nstruct oxygen *chip = ctl->private_data;\r\nunsigned int count = upmix_item_count(chip);\r\nreturn snd_ctl_enum_info(info, 1, count, names);\r\n}\r\nstatic int upmix_get(struct snd_kcontrol *ctl, struct snd_ctl_elem_value *value)\r\n{\r\nstruct oxygen *chip = ctl->private_data;\r\nmutex_lock(&chip->mutex);\r\nvalue->value.enumerated.item[0] = chip->dac_routing;\r\nmutex_unlock(&chip->mutex);\r\nreturn 0;\r\n}\r\nvoid oxygen_update_dac_routing(struct oxygen *chip)\r\n{\r\nstatic const unsigned int reg_values[5] = {\r\n(0 << OXYGEN_PLAY_DAC0_SOURCE_SHIFT) |\r\n(1 << OXYGEN_PLAY_DAC1_SOURCE_SHIFT) |\r\n(2 << OXYGEN_PLAY_DAC2_SOURCE_SHIFT) |\r\n(3 << OXYGEN_PLAY_DAC3_SOURCE_SHIFT),\r\n(0 << OXYGEN_PLAY_DAC0_SOURCE_SHIFT) |\r\n(0 << OXYGEN_PLAY_DAC1_SOURCE_SHIFT) |\r\n(2 << OXYGEN_PLAY_DAC2_SOURCE_SHIFT) |\r\n(3 << OXYGEN_PLAY_DAC3_SOURCE_SHIFT),\r\n(0 << OXYGEN_PLAY_DAC0_SOURCE_SHIFT) |\r\n(0 << OXYGEN_PLAY_DAC1_SOURCE_SHIFT) |\r\n(2 << OXYGEN_PLAY_DAC2_SOURCE_SHIFT) |\r\n(0 << OXYGEN_PLAY_DAC3_SOURCE_SHIFT),\r\n(0 << OXYGEN_PLAY_DAC0_SOURCE_SHIFT) |\r\n(0 << OXYGEN_PLAY_DAC1_SOURCE_SHIFT) |\r\n(0 << OXYGEN_PLAY_DAC2_SOURCE_SHIFT) |\r\n(3 << OXYGEN_PLAY_DAC3_SOURCE_SHIFT),\r\n(0 << OXYGEN_PLAY_DAC0_SOURCE_SHIFT) |\r\n(0 << OXYGEN_PLAY_DAC1_SOURCE_SHIFT) |\r\n(0 << OXYGEN_PLAY_DAC2_SOURCE_SHIFT) |\r\n(0 << OXYGEN_PLAY_DAC3_SOURCE_SHIFT),\r\n};\r\nu8 channels;\r\nunsigned int reg_value;\r\nchannels = oxygen_read8(chip, OXYGEN_PLAY_CHANNELS) &\r\nOXYGEN_PLAY_CHANNELS_MASK;\r\nif (channels == OXYGEN_PLAY_CHANNELS_2)\r\nreg_value = reg_values[chip->dac_routing];\r\nelse if (channels == OXYGEN_PLAY_CHANNELS_8)\r\nreg_value = (0 << OXYGEN_PLAY_DAC0_SOURCE_SHIFT) |\r\n(3 << OXYGEN_PLAY_DAC1_SOURCE_SHIFT) |\r\n(2 << OXYGEN_PLAY_DAC2_SOURCE_SHIFT) |\r\n(1 << OXYGEN_PLAY_DAC3_SOURCE_SHIFT);\r\nelse\r\nreg_value = (0 << OXYGEN_PLAY_DAC0_SOURCE_SHIFT) |\r\n(1 << OXYGEN_PLAY_DAC1_SOURCE_SHIFT) |\r\n(2 << OXYGEN_PLAY_DAC2_SOURCE_SHIFT) |\r\n(3 << OXYGEN_PLAY_DAC3_SOURCE_SHIFT);\r\nif (chip->model.adjust_dac_routing)\r\nreg_value = chip->model.adjust_dac_routing(chip, reg_value);\r\noxygen_write16_masked(chip, OXYGEN_PLAY_ROUTING, reg_value,\r\nOXYGEN_PLAY_DAC0_SOURCE_MASK |\r\nOXYGEN_PLAY_DAC1_SOURCE_MASK |\r\nOXYGEN_PLAY_DAC2_SOURCE_MASK |\r\nOXYGEN_PLAY_DAC3_SOURCE_MASK);\r\nif (chip->model.update_center_lfe_mix)\r\nchip->model.update_center_lfe_mix(chip, chip->dac_routing > 2);\r\n}\r\nstatic int upmix_put(struct snd_kcontrol *ctl, struct snd_ctl_elem_value *value)\r\n{\r\nstruct oxygen *chip = ctl->private_data;\r\nunsigned int count = upmix_item_count(chip);\r\nint changed;\r\nif (value->value.enumerated.item[0] >= count)\r\nreturn -EINVAL;\r\nmutex_lock(&chip->mutex);\r\nchanged = value->value.enumerated.item[0] != chip->dac_routing;\r\nif (changed) {\r\nchip->dac_routing = value->value.enumerated.item[0];\r\noxygen_update_dac_routing(chip);\r\n}\r\nmutex_unlock(&chip->mutex);\r\nreturn changed;\r\n}\r\nstatic int spdif_switch_get(struct snd_kcontrol *ctl,\r\nstruct snd_ctl_elem_value *value)\r\n{\r\nstruct oxygen *chip = ctl->private_data;\r\nmutex_lock(&chip->mutex);\r\nvalue->value.integer.value[0] = chip->spdif_playback_enable;\r\nmutex_unlock(&chip->mutex);\r\nreturn 0;\r\n}\r\nstatic unsigned int oxygen_spdif_rate(unsigned int oxygen_rate)\r\n{\r\nswitch (oxygen_rate) {\r\ncase OXYGEN_RATE_32000:\r\nreturn IEC958_AES3_CON_FS_32000 << OXYGEN_SPDIF_CS_RATE_SHIFT;\r\ncase OXYGEN_RATE_44100:\r\nreturn IEC958_AES3_CON_FS_44100 << OXYGEN_SPDIF_CS_RATE_SHIFT;\r\ndefault:\r\nreturn IEC958_AES3_CON_FS_48000 << OXYGEN_SPDIF_CS_RATE_SHIFT;\r\ncase OXYGEN_RATE_64000:\r\nreturn 0xb << OXYGEN_SPDIF_CS_RATE_SHIFT;\r\ncase OXYGEN_RATE_88200:\r\nreturn IEC958_AES3_CON_FS_88200 << OXYGEN_SPDIF_CS_RATE_SHIFT;\r\ncase OXYGEN_RATE_96000:\r\nreturn IEC958_AES3_CON_FS_96000 << OXYGEN_SPDIF_CS_RATE_SHIFT;\r\ncase OXYGEN_RATE_176400:\r\nreturn IEC958_AES3_CON_FS_176400 << OXYGEN_SPDIF_CS_RATE_SHIFT;\r\ncase OXYGEN_RATE_192000:\r\nreturn IEC958_AES3_CON_FS_192000 << OXYGEN_SPDIF_CS_RATE_SHIFT;\r\n}\r\n}\r\nvoid oxygen_update_spdif_source(struct oxygen *chip)\r\n{\r\nu32 old_control, new_control;\r\nu16 old_routing, new_routing;\r\nunsigned int oxygen_rate;\r\nold_control = oxygen_read32(chip, OXYGEN_SPDIF_CONTROL);\r\nold_routing = oxygen_read16(chip, OXYGEN_PLAY_ROUTING);\r\nif (chip->pcm_active & (1 << PCM_SPDIF)) {\r\nnew_control = old_control | OXYGEN_SPDIF_OUT_ENABLE;\r\nnew_routing = (old_routing & ~OXYGEN_PLAY_SPDIF_MASK)\r\n| OXYGEN_PLAY_SPDIF_SPDIF;\r\noxygen_rate = (old_control >> OXYGEN_SPDIF_OUT_RATE_SHIFT)\r\n& OXYGEN_I2S_RATE_MASK;\r\n} else if ((chip->pcm_active & (1 << PCM_MULTICH)) &&\r\nchip->spdif_playback_enable) {\r\nnew_routing = (old_routing & ~OXYGEN_PLAY_SPDIF_MASK)\r\n| OXYGEN_PLAY_SPDIF_MULTICH_01;\r\noxygen_rate = oxygen_read16(chip, OXYGEN_I2S_MULTICH_FORMAT)\r\n& OXYGEN_I2S_RATE_MASK;\r\nnew_control = (old_control & ~OXYGEN_SPDIF_OUT_RATE_MASK) |\r\n(oxygen_rate << OXYGEN_SPDIF_OUT_RATE_SHIFT) |\r\nOXYGEN_SPDIF_OUT_ENABLE;\r\n} else {\r\nnew_control = old_control & ~OXYGEN_SPDIF_OUT_ENABLE;\r\nnew_routing = old_routing;\r\noxygen_rate = OXYGEN_RATE_44100;\r\n}\r\nif (old_routing != new_routing) {\r\noxygen_write32(chip, OXYGEN_SPDIF_CONTROL,\r\nnew_control & ~OXYGEN_SPDIF_OUT_ENABLE);\r\noxygen_write16(chip, OXYGEN_PLAY_ROUTING, new_routing);\r\n}\r\nif (new_control & OXYGEN_SPDIF_OUT_ENABLE)\r\noxygen_write32(chip, OXYGEN_SPDIF_OUTPUT_BITS,\r\noxygen_spdif_rate(oxygen_rate) |\r\n((chip->pcm_active & (1 << PCM_SPDIF)) ?\r\nchip->spdif_pcm_bits : chip->spdif_bits));\r\noxygen_write32(chip, OXYGEN_SPDIF_CONTROL, new_control);\r\n}\r\nstatic int spdif_switch_put(struct snd_kcontrol *ctl,\r\nstruct snd_ctl_elem_value *value)\r\n{\r\nstruct oxygen *chip = ctl->private_data;\r\nint changed;\r\nmutex_lock(&chip->mutex);\r\nchanged = value->value.integer.value[0] != chip->spdif_playback_enable;\r\nif (changed) {\r\nchip->spdif_playback_enable = !!value->value.integer.value[0];\r\nspin_lock_irq(&chip->reg_lock);\r\noxygen_update_spdif_source(chip);\r\nspin_unlock_irq(&chip->reg_lock);\r\n}\r\nmutex_unlock(&chip->mutex);\r\nreturn changed;\r\n}\r\nstatic int spdif_info(struct snd_kcontrol *ctl, struct snd_ctl_elem_info *info)\r\n{\r\ninfo->type = SNDRV_CTL_ELEM_TYPE_IEC958;\r\ninfo->count = 1;\r\nreturn 0;\r\n}\r\nstatic void oxygen_to_iec958(u32 bits, struct snd_ctl_elem_value *value)\r\n{\r\nvalue->value.iec958.status[0] =\r\nbits & (OXYGEN_SPDIF_NONAUDIO | OXYGEN_SPDIF_C |\r\nOXYGEN_SPDIF_PREEMPHASIS);\r\nvalue->value.iec958.status[1] =\r\nbits >> OXYGEN_SPDIF_CATEGORY_SHIFT;\r\n}\r\nstatic u32 iec958_to_oxygen(struct snd_ctl_elem_value *value)\r\n{\r\nu32 bits;\r\nbits = value->value.iec958.status[0] &\r\n(OXYGEN_SPDIF_NONAUDIO | OXYGEN_SPDIF_C |\r\nOXYGEN_SPDIF_PREEMPHASIS);\r\nbits |= value->value.iec958.status[1] << OXYGEN_SPDIF_CATEGORY_SHIFT;\r\nif (bits & OXYGEN_SPDIF_NONAUDIO)\r\nbits |= OXYGEN_SPDIF_V;\r\nreturn bits;\r\n}\r\nstatic inline void write_spdif_bits(struct oxygen *chip, u32 bits)\r\n{\r\noxygen_write32_masked(chip, OXYGEN_SPDIF_OUTPUT_BITS, bits,\r\nOXYGEN_SPDIF_NONAUDIO |\r\nOXYGEN_SPDIF_C |\r\nOXYGEN_SPDIF_PREEMPHASIS |\r\nOXYGEN_SPDIF_CATEGORY_MASK |\r\nOXYGEN_SPDIF_ORIGINAL |\r\nOXYGEN_SPDIF_V);\r\n}\r\nstatic int spdif_default_get(struct snd_kcontrol *ctl,\r\nstruct snd_ctl_elem_value *value)\r\n{\r\nstruct oxygen *chip = ctl->private_data;\r\nmutex_lock(&chip->mutex);\r\noxygen_to_iec958(chip->spdif_bits, value);\r\nmutex_unlock(&chip->mutex);\r\nreturn 0;\r\n}\r\nstatic int spdif_default_put(struct snd_kcontrol *ctl,\r\nstruct snd_ctl_elem_value *value)\r\n{\r\nstruct oxygen *chip = ctl->private_data;\r\nu32 new_bits;\r\nint changed;\r\nnew_bits = iec958_to_oxygen(value);\r\nmutex_lock(&chip->mutex);\r\nchanged = new_bits != chip->spdif_bits;\r\nif (changed) {\r\nchip->spdif_bits = new_bits;\r\nif (!(chip->pcm_active & (1 << PCM_SPDIF)))\r\nwrite_spdif_bits(chip, new_bits);\r\n}\r\nmutex_unlock(&chip->mutex);\r\nreturn changed;\r\n}\r\nstatic int spdif_mask_get(struct snd_kcontrol *ctl,\r\nstruct snd_ctl_elem_value *value)\r\n{\r\nvalue->value.iec958.status[0] = IEC958_AES0_NONAUDIO |\r\nIEC958_AES0_CON_NOT_COPYRIGHT | IEC958_AES0_CON_EMPHASIS;\r\nvalue->value.iec958.status[1] =\r\nIEC958_AES1_CON_CATEGORY | IEC958_AES1_CON_ORIGINAL;\r\nreturn 0;\r\n}\r\nstatic int spdif_pcm_get(struct snd_kcontrol *ctl,\r\nstruct snd_ctl_elem_value *value)\r\n{\r\nstruct oxygen *chip = ctl->private_data;\r\nmutex_lock(&chip->mutex);\r\noxygen_to_iec958(chip->spdif_pcm_bits, value);\r\nmutex_unlock(&chip->mutex);\r\nreturn 0;\r\n}\r\nstatic int spdif_pcm_put(struct snd_kcontrol *ctl,\r\nstruct snd_ctl_elem_value *value)\r\n{\r\nstruct oxygen *chip = ctl->private_data;\r\nu32 new_bits;\r\nint changed;\r\nnew_bits = iec958_to_oxygen(value);\r\nmutex_lock(&chip->mutex);\r\nchanged = new_bits != chip->spdif_pcm_bits;\r\nif (changed) {\r\nchip->spdif_pcm_bits = new_bits;\r\nif (chip->pcm_active & (1 << PCM_SPDIF))\r\nwrite_spdif_bits(chip, new_bits);\r\n}\r\nmutex_unlock(&chip->mutex);\r\nreturn changed;\r\n}\r\nstatic int spdif_input_mask_get(struct snd_kcontrol *ctl,\r\nstruct snd_ctl_elem_value *value)\r\n{\r\nvalue->value.iec958.status[0] = 0xff;\r\nvalue->value.iec958.status[1] = 0xff;\r\nvalue->value.iec958.status[2] = 0xff;\r\nvalue->value.iec958.status[3] = 0xff;\r\nreturn 0;\r\n}\r\nstatic int spdif_input_default_get(struct snd_kcontrol *ctl,\r\nstruct snd_ctl_elem_value *value)\r\n{\r\nstruct oxygen *chip = ctl->private_data;\r\nu32 bits;\r\nbits = oxygen_read32(chip, OXYGEN_SPDIF_INPUT_BITS);\r\nvalue->value.iec958.status[0] = bits;\r\nvalue->value.iec958.status[1] = bits >> 8;\r\nvalue->value.iec958.status[2] = bits >> 16;\r\nvalue->value.iec958.status[3] = bits >> 24;\r\nreturn 0;\r\n}\r\nstatic int spdif_bit_switch_get(struct snd_kcontrol *ctl,\r\nstruct snd_ctl_elem_value *value)\r\n{\r\nstruct oxygen *chip = ctl->private_data;\r\nu32 bit = ctl->private_value;\r\nvalue->value.integer.value[0] =\r\n!!(oxygen_read32(chip, OXYGEN_SPDIF_CONTROL) & bit);\r\nreturn 0;\r\n}\r\nstatic int spdif_bit_switch_put(struct snd_kcontrol *ctl,\r\nstruct snd_ctl_elem_value *value)\r\n{\r\nstruct oxygen *chip = ctl->private_data;\r\nu32 bit = ctl->private_value;\r\nu32 oldreg, newreg;\r\nint changed;\r\nspin_lock_irq(&chip->reg_lock);\r\noldreg = oxygen_read32(chip, OXYGEN_SPDIF_CONTROL);\r\nif (value->value.integer.value[0])\r\nnewreg = oldreg | bit;\r\nelse\r\nnewreg = oldreg & ~bit;\r\nchanged = newreg != oldreg;\r\nif (changed)\r\noxygen_write32(chip, OXYGEN_SPDIF_CONTROL, newreg);\r\nspin_unlock_irq(&chip->reg_lock);\r\nreturn changed;\r\n}\r\nstatic int monitor_volume_info(struct snd_kcontrol *ctl,\r\nstruct snd_ctl_elem_info *info)\r\n{\r\ninfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;\r\ninfo->count = 1;\r\ninfo->value.integer.min = 0;\r\ninfo->value.integer.max = 1;\r\nreturn 0;\r\n}\r\nstatic int monitor_get(struct snd_kcontrol *ctl,\r\nstruct snd_ctl_elem_value *value)\r\n{\r\nstruct oxygen *chip = ctl->private_data;\r\nu8 bit = ctl->private_value;\r\nint invert = ctl->private_value & (1 << 8);\r\nvalue->value.integer.value[0] =\r\n!!invert ^ !!(oxygen_read8(chip, OXYGEN_ADC_MONITOR) & bit);\r\nreturn 0;\r\n}\r\nstatic int monitor_put(struct snd_kcontrol *ctl,\r\nstruct snd_ctl_elem_value *value)\r\n{\r\nstruct oxygen *chip = ctl->private_data;\r\nu8 bit = ctl->private_value;\r\nint invert = ctl->private_value & (1 << 8);\r\nu8 oldreg, newreg;\r\nint changed;\r\nspin_lock_irq(&chip->reg_lock);\r\noldreg = oxygen_read8(chip, OXYGEN_ADC_MONITOR);\r\nif ((!!value->value.integer.value[0] ^ !!invert) != 0)\r\nnewreg = oldreg | bit;\r\nelse\r\nnewreg = oldreg & ~bit;\r\nchanged = newreg != oldreg;\r\nif (changed)\r\noxygen_write8(chip, OXYGEN_ADC_MONITOR, newreg);\r\nspin_unlock_irq(&chip->reg_lock);\r\nreturn changed;\r\n}\r\nstatic int ac97_switch_get(struct snd_kcontrol *ctl,\r\nstruct snd_ctl_elem_value *value)\r\n{\r\nstruct oxygen *chip = ctl->private_data;\r\nunsigned int codec = (ctl->private_value >> 24) & 1;\r\nunsigned int index = ctl->private_value & 0xff;\r\nunsigned int bitnr = (ctl->private_value >> 8) & 0xff;\r\nint invert = ctl->private_value & (1 << 16);\r\nu16 reg;\r\nmutex_lock(&chip->mutex);\r\nreg = oxygen_read_ac97(chip, codec, index);\r\nmutex_unlock(&chip->mutex);\r\nif (!(reg & (1 << bitnr)) ^ !invert)\r\nvalue->value.integer.value[0] = 1;\r\nelse\r\nvalue->value.integer.value[0] = 0;\r\nreturn 0;\r\n}\r\nstatic void mute_ac97_ctl(struct oxygen *chip, unsigned int control)\r\n{\r\nunsigned int priv_idx;\r\nu16 value;\r\nif (!chip->controls[control])\r\nreturn;\r\npriv_idx = chip->controls[control]->private_value & 0xff;\r\nvalue = oxygen_read_ac97(chip, 0, priv_idx);\r\nif (!(value & 0x8000)) {\r\noxygen_write_ac97(chip, 0, priv_idx, value | 0x8000);\r\nif (chip->model.ac97_switch)\r\nchip->model.ac97_switch(chip, priv_idx, 0x8000);\r\nsnd_ctl_notify(chip->card, SNDRV_CTL_EVENT_MASK_VALUE,\r\n&chip->controls[control]->id);\r\n}\r\n}\r\nstatic int ac97_switch_put(struct snd_kcontrol *ctl,\r\nstruct snd_ctl_elem_value *value)\r\n{\r\nstruct oxygen *chip = ctl->private_data;\r\nunsigned int codec = (ctl->private_value >> 24) & 1;\r\nunsigned int index = ctl->private_value & 0xff;\r\nunsigned int bitnr = (ctl->private_value >> 8) & 0xff;\r\nint invert = ctl->private_value & (1 << 16);\r\nu16 oldreg, newreg;\r\nint change;\r\nmutex_lock(&chip->mutex);\r\noldreg = oxygen_read_ac97(chip, codec, index);\r\nnewreg = oldreg;\r\nif (!value->value.integer.value[0] ^ !invert)\r\nnewreg |= 1 << bitnr;\r\nelse\r\nnewreg &= ~(1 << bitnr);\r\nchange = newreg != oldreg;\r\nif (change) {\r\noxygen_write_ac97(chip, codec, index, newreg);\r\nif (codec == 0 && chip->model.ac97_switch)\r\nchip->model.ac97_switch(chip, index, newreg & 0x8000);\r\nif (index == AC97_LINE) {\r\noxygen_write_ac97_masked(chip, 0, CM9780_GPIO_STATUS,\r\nnewreg & 0x8000 ?\r\nCM9780_GPO0 : 0, CM9780_GPO0);\r\nif (!(newreg & 0x8000)) {\r\nmute_ac97_ctl(chip, CONTROL_MIC_CAPTURE_SWITCH);\r\nmute_ac97_ctl(chip, CONTROL_CD_CAPTURE_SWITCH);\r\nmute_ac97_ctl(chip, CONTROL_AUX_CAPTURE_SWITCH);\r\n}\r\n} else if ((index == AC97_MIC || index == AC97_CD ||\r\nindex == AC97_VIDEO || index == AC97_AUX) &&\r\nbitnr == 15 && !(newreg & 0x8000)) {\r\nmute_ac97_ctl(chip, CONTROL_LINE_CAPTURE_SWITCH);\r\noxygen_write_ac97_masked(chip, 0, CM9780_GPIO_STATUS,\r\nCM9780_GPO0, CM9780_GPO0);\r\n}\r\n}\r\nmutex_unlock(&chip->mutex);\r\nreturn change;\r\n}\r\nstatic int ac97_volume_info(struct snd_kcontrol *ctl,\r\nstruct snd_ctl_elem_info *info)\r\n{\r\nint stereo = (ctl->private_value >> 16) & 1;\r\ninfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;\r\ninfo->count = stereo ? 2 : 1;\r\ninfo->value.integer.min = 0;\r\ninfo->value.integer.max = 0x1f;\r\nreturn 0;\r\n}\r\nstatic int ac97_volume_get(struct snd_kcontrol *ctl,\r\nstruct snd_ctl_elem_value *value)\r\n{\r\nstruct oxygen *chip = ctl->private_data;\r\nunsigned int codec = (ctl->private_value >> 24) & 1;\r\nint stereo = (ctl->private_value >> 16) & 1;\r\nunsigned int index = ctl->private_value & 0xff;\r\nu16 reg;\r\nmutex_lock(&chip->mutex);\r\nreg = oxygen_read_ac97(chip, codec, index);\r\nmutex_unlock(&chip->mutex);\r\nif (!stereo) {\r\nvalue->value.integer.value[0] = 31 - (reg & 0x1f);\r\n} else {\r\nvalue->value.integer.value[0] = 31 - ((reg >> 8) & 0x1f);\r\nvalue->value.integer.value[1] = 31 - (reg & 0x1f);\r\n}\r\nreturn 0;\r\n}\r\nstatic int ac97_volume_put(struct snd_kcontrol *ctl,\r\nstruct snd_ctl_elem_value *value)\r\n{\r\nstruct oxygen *chip = ctl->private_data;\r\nunsigned int codec = (ctl->private_value >> 24) & 1;\r\nint stereo = (ctl->private_value >> 16) & 1;\r\nunsigned int index = ctl->private_value & 0xff;\r\nu16 oldreg, newreg;\r\nint change;\r\nmutex_lock(&chip->mutex);\r\noldreg = oxygen_read_ac97(chip, codec, index);\r\nif (!stereo) {\r\nnewreg = oldreg & ~0x1f;\r\nnewreg |= 31 - (value->value.integer.value[0] & 0x1f);\r\n} else {\r\nnewreg = oldreg & ~0x1f1f;\r\nnewreg |= (31 - (value->value.integer.value[0] & 0x1f)) << 8;\r\nnewreg |= 31 - (value->value.integer.value[1] & 0x1f);\r\n}\r\nchange = newreg != oldreg;\r\nif (change)\r\noxygen_write_ac97(chip, codec, index, newreg);\r\nmutex_unlock(&chip->mutex);\r\nreturn change;\r\n}\r\nstatic int mic_fmic_source_info(struct snd_kcontrol *ctl,\r\nstruct snd_ctl_elem_info *info)\r\n{\r\nstatic const char *const names[] = { "Mic Jack", "Front Panel" };\r\nreturn snd_ctl_enum_info(info, 1, 2, names);\r\n}\r\nstatic int mic_fmic_source_get(struct snd_kcontrol *ctl,\r\nstruct snd_ctl_elem_value *value)\r\n{\r\nstruct oxygen *chip = ctl->private_data;\r\nmutex_lock(&chip->mutex);\r\nvalue->value.enumerated.item[0] =\r\n!!(oxygen_read_ac97(chip, 0, CM9780_JACK) & CM9780_FMIC2MIC);\r\nmutex_unlock(&chip->mutex);\r\nreturn 0;\r\n}\r\nstatic int mic_fmic_source_put(struct snd_kcontrol *ctl,\r\nstruct snd_ctl_elem_value *value)\r\n{\r\nstruct oxygen *chip = ctl->private_data;\r\nu16 oldreg, newreg;\r\nint change;\r\nmutex_lock(&chip->mutex);\r\noldreg = oxygen_read_ac97(chip, 0, CM9780_JACK);\r\nif (value->value.enumerated.item[0])\r\nnewreg = oldreg | CM9780_FMIC2MIC;\r\nelse\r\nnewreg = oldreg & ~CM9780_FMIC2MIC;\r\nchange = newreg != oldreg;\r\nif (change)\r\noxygen_write_ac97(chip, 0, CM9780_JACK, newreg);\r\nmutex_unlock(&chip->mutex);\r\nreturn change;\r\n}\r\nstatic int ac97_fp_rec_volume_info(struct snd_kcontrol *ctl,\r\nstruct snd_ctl_elem_info *info)\r\n{\r\ninfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;\r\ninfo->count = 2;\r\ninfo->value.integer.min = 0;\r\ninfo->value.integer.max = 7;\r\nreturn 0;\r\n}\r\nstatic int ac97_fp_rec_volume_get(struct snd_kcontrol *ctl,\r\nstruct snd_ctl_elem_value *value)\r\n{\r\nstruct oxygen *chip = ctl->private_data;\r\nu16 reg;\r\nmutex_lock(&chip->mutex);\r\nreg = oxygen_read_ac97(chip, 1, AC97_REC_GAIN);\r\nmutex_unlock(&chip->mutex);\r\nvalue->value.integer.value[0] = reg & 7;\r\nvalue->value.integer.value[1] = (reg >> 8) & 7;\r\nreturn 0;\r\n}\r\nstatic int ac97_fp_rec_volume_put(struct snd_kcontrol *ctl,\r\nstruct snd_ctl_elem_value *value)\r\n{\r\nstruct oxygen *chip = ctl->private_data;\r\nu16 oldreg, newreg;\r\nint change;\r\nmutex_lock(&chip->mutex);\r\noldreg = oxygen_read_ac97(chip, 1, AC97_REC_GAIN);\r\nnewreg = oldreg & ~0x0707;\r\nnewreg = newreg | (value->value.integer.value[0] & 7);\r\nnewreg = newreg | ((value->value.integer.value[0] & 7) << 8);\r\nchange = newreg != oldreg;\r\nif (change)\r\noxygen_write_ac97(chip, 1, AC97_REC_GAIN, newreg);\r\nmutex_unlock(&chip->mutex);\r\nreturn change;\r\n}\r\nstatic void oxygen_any_ctl_free(struct snd_kcontrol *ctl)\r\n{\r\nstruct oxygen *chip = ctl->private_data;\r\nunsigned int i;\r\nfor (i = 0; i < ARRAY_SIZE(chip->controls); ++i)\r\nchip->controls[i] = NULL;\r\n}\r\nstatic int add_controls(struct oxygen *chip,\r\nconst struct snd_kcontrol_new controls[],\r\nunsigned int count)\r\n{\r\nstatic const char *const known_ctl_names[CONTROL_COUNT] = {\r\n[CONTROL_SPDIF_PCM] =\r\nSNDRV_CTL_NAME_IEC958("", PLAYBACK, PCM_STREAM),\r\n[CONTROL_SPDIF_INPUT_BITS] =\r\nSNDRV_CTL_NAME_IEC958("", CAPTURE, DEFAULT),\r\n[CONTROL_MIC_CAPTURE_SWITCH] = "Mic Capture Switch",\r\n[CONTROL_LINE_CAPTURE_SWITCH] = "Line Capture Switch",\r\n[CONTROL_CD_CAPTURE_SWITCH] = "CD Capture Switch",\r\n[CONTROL_AUX_CAPTURE_SWITCH] = "Aux Capture Switch",\r\n};\r\nunsigned int i, j;\r\nstruct snd_kcontrol_new template;\r\nstruct snd_kcontrol *ctl;\r\nint err;\r\nfor (i = 0; i < count; ++i) {\r\ntemplate = controls[i];\r\nif (chip->model.control_filter) {\r\nerr = chip->model.control_filter(&template);\r\nif (err < 0)\r\nreturn err;\r\nif (err == 1)\r\ncontinue;\r\n}\r\nif (!strcmp(template.name, "Stereo Upmixing") &&\r\nchip->model.dac_channels_pcm == 2)\r\ncontinue;\r\nif (!strcmp(template.name, "Mic Source Capture Enum") &&\r\n!(chip->model.device_config & AC97_FMIC_SWITCH))\r\ncontinue;\r\nif (!strncmp(template.name, "CD Capture ", 11) &&\r\n!(chip->model.device_config & AC97_CD_INPUT))\r\ncontinue;\r\nif (!strcmp(template.name, "Master Playback Volume") &&\r\nchip->model.dac_tlv) {\r\ntemplate.tlv.p = chip->model.dac_tlv;\r\ntemplate.access |= SNDRV_CTL_ELEM_ACCESS_TLV_READ;\r\n}\r\nctl = snd_ctl_new1(&template, chip);\r\nif (!ctl)\r\nreturn -ENOMEM;\r\nerr = snd_ctl_add(chip->card, ctl);\r\nif (err < 0)\r\nreturn err;\r\nfor (j = 0; j < CONTROL_COUNT; ++j)\r\nif (!strcmp(ctl->id.name, known_ctl_names[j])) {\r\nchip->controls[j] = ctl;\r\nctl->private_free = oxygen_any_ctl_free;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nint oxygen_mixer_init(struct oxygen *chip)\r\n{\r\nunsigned int i;\r\nint err;\r\nerr = add_controls(chip, controls, ARRAY_SIZE(controls));\r\nif (err < 0)\r\nreturn err;\r\nif (chip->model.device_config & PLAYBACK_1_TO_SPDIF) {\r\nerr = add_controls(chip, spdif_output_controls,\r\nARRAY_SIZE(spdif_output_controls));\r\nif (err < 0)\r\nreturn err;\r\n}\r\nif (chip->model.device_config & CAPTURE_1_FROM_SPDIF) {\r\nerr = add_controls(chip, spdif_input_controls,\r\nARRAY_SIZE(spdif_input_controls));\r\nif (err < 0)\r\nreturn err;\r\n}\r\nfor (i = 0; i < ARRAY_SIZE(monitor_controls); ++i) {\r\nif (!(chip->model.device_config & monitor_controls[i].pcm_dev))\r\ncontinue;\r\nerr = add_controls(chip, monitor_controls[i].controls,\r\nARRAY_SIZE(monitor_controls[i].controls));\r\nif (err < 0)\r\nreturn err;\r\n}\r\nif (chip->has_ac97_0) {\r\nerr = add_controls(chip, ac97_controls,\r\nARRAY_SIZE(ac97_controls));\r\nif (err < 0)\r\nreturn err;\r\n}\r\nif (chip->has_ac97_1) {\r\nerr = add_controls(chip, ac97_fp_controls,\r\nARRAY_SIZE(ac97_fp_controls));\r\nif (err < 0)\r\nreturn err;\r\n}\r\nreturn chip->model.mixer_init ? chip->model.mixer_init(chip) : 0;\r\n}
