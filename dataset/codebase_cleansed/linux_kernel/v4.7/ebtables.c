static void ebt_standard_compat_from_user(void *dst, const void *src)\r\n{\r\nint v = *(compat_int_t *)src;\r\nif (v >= 0)\r\nv += xt_compat_calc_jump(NFPROTO_BRIDGE, v);\r\nmemcpy(dst, &v, sizeof(v));\r\n}\r\nstatic int ebt_standard_compat_to_user(void __user *dst, const void *src)\r\n{\r\ncompat_int_t cv = *(int *)src;\r\nif (cv >= 0)\r\ncv -= xt_compat_calc_jump(NFPROTO_BRIDGE, cv);\r\nreturn copy_to_user(dst, &cv, sizeof(cv)) ? -EFAULT : 0;\r\n}\r\nstatic inline int\r\nebt_do_watcher(const struct ebt_entry_watcher *w, struct sk_buff *skb,\r\nstruct xt_action_param *par)\r\n{\r\npar->target = w->u.watcher;\r\npar->targinfo = w->data;\r\nw->u.watcher->target(skb, par);\r\nreturn 0;\r\n}\r\nstatic inline int\r\nebt_do_match(struct ebt_entry_match *m, const struct sk_buff *skb,\r\nstruct xt_action_param *par)\r\n{\r\npar->match = m->u.match;\r\npar->matchinfo = m->data;\r\nreturn m->u.match->match(skb, par) ? EBT_MATCH : EBT_NOMATCH;\r\n}\r\nstatic inline int\r\nebt_dev_check(const char *entry, const struct net_device *device)\r\n{\r\nint i = 0;\r\nconst char *devname;\r\nif (*entry == '\0')\r\nreturn 0;\r\nif (!device)\r\nreturn 1;\r\ndevname = device->name;\r\nwhile (entry[i] != '\0' && entry[i] != 1 && entry[i] == devname[i])\r\ni++;\r\nreturn devname[i] != entry[i] && entry[i] != 1;\r\n}\r\nstatic inline int\r\nebt_basic_match(const struct ebt_entry *e, const struct sk_buff *skb,\r\nconst struct net_device *in, const struct net_device *out)\r\n{\r\nconst struct ethhdr *h = eth_hdr(skb);\r\nconst struct net_bridge_port *p;\r\n__be16 ethproto;\r\nint verdict, i;\r\nif (skb_vlan_tag_present(skb))\r\nethproto = htons(ETH_P_8021Q);\r\nelse\r\nethproto = h->h_proto;\r\nif (e->bitmask & EBT_802_3) {\r\nif (FWINV2(eth_proto_is_802_3(ethproto), EBT_IPROTO))\r\nreturn 1;\r\n} else if (!(e->bitmask & EBT_NOPROTO) &&\r\nFWINV2(e->ethproto != ethproto, EBT_IPROTO))\r\nreturn 1;\r\nif (FWINV2(ebt_dev_check(e->in, in), EBT_IIN))\r\nreturn 1;\r\nif (FWINV2(ebt_dev_check(e->out, out), EBT_IOUT))\r\nreturn 1;\r\nif (in && (p = br_port_get_rcu(in)) != NULL &&\r\nFWINV2(ebt_dev_check(e->logical_in, p->br->dev), EBT_ILOGICALIN))\r\nreturn 1;\r\nif (out && (p = br_port_get_rcu(out)) != NULL &&\r\nFWINV2(ebt_dev_check(e->logical_out, p->br->dev), EBT_ILOGICALOUT))\r\nreturn 1;\r\nif (e->bitmask & EBT_SOURCEMAC) {\r\nverdict = 0;\r\nfor (i = 0; i < 6; i++)\r\nverdict |= (h->h_source[i] ^ e->sourcemac[i]) &\r\ne->sourcemsk[i];\r\nif (FWINV2(verdict != 0, EBT_ISOURCE))\r\nreturn 1;\r\n}\r\nif (e->bitmask & EBT_DESTMAC) {\r\nverdict = 0;\r\nfor (i = 0; i < 6; i++)\r\nverdict |= (h->h_dest[i] ^ e->destmac[i]) &\r\ne->destmsk[i];\r\nif (FWINV2(verdict != 0, EBT_IDEST))\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}\r\nstatic inline\r\nstruct ebt_entry *ebt_next_entry(const struct ebt_entry *entry)\r\n{\r\nreturn (void *)entry + entry->next_offset;\r\n}\r\nunsigned int ebt_do_table(struct sk_buff *skb,\r\nconst struct nf_hook_state *state,\r\nstruct ebt_table *table)\r\n{\r\nunsigned int hook = state->hook;\r\nint i, nentries;\r\nstruct ebt_entry *point;\r\nstruct ebt_counter *counter_base, *cb_base;\r\nconst struct ebt_entry_target *t;\r\nint verdict, sp = 0;\r\nstruct ebt_chainstack *cs;\r\nstruct ebt_entries *chaininfo;\r\nconst char *base;\r\nconst struct ebt_table_info *private;\r\nstruct xt_action_param acpar;\r\nacpar.family = NFPROTO_BRIDGE;\r\nacpar.net = state->net;\r\nacpar.in = state->in;\r\nacpar.out = state->out;\r\nacpar.hotdrop = false;\r\nacpar.hooknum = hook;\r\nread_lock_bh(&table->lock);\r\nprivate = table->private;\r\ncb_base = COUNTER_BASE(private->counters, private->nentries,\r\nsmp_processor_id());\r\nif (private->chainstack)\r\ncs = private->chainstack[smp_processor_id()];\r\nelse\r\ncs = NULL;\r\nchaininfo = private->hook_entry[hook];\r\nnentries = private->hook_entry[hook]->nentries;\r\npoint = (struct ebt_entry *)(private->hook_entry[hook]->data);\r\ncounter_base = cb_base + private->hook_entry[hook]->counter_offset;\r\nbase = private->entries;\r\ni = 0;\r\nwhile (i < nentries) {\r\nif (ebt_basic_match(point, skb, state->in, state->out))\r\ngoto letscontinue;\r\nif (EBT_MATCH_ITERATE(point, ebt_do_match, skb, &acpar) != 0)\r\ngoto letscontinue;\r\nif (acpar.hotdrop) {\r\nread_unlock_bh(&table->lock);\r\nreturn NF_DROP;\r\n}\r\n(*(counter_base + i)).pcnt++;\r\n(*(counter_base + i)).bcnt += skb->len;\r\nEBT_WATCHER_ITERATE(point, ebt_do_watcher, skb, &acpar);\r\nt = (struct ebt_entry_target *)\r\n(((char *)point) + point->target_offset);\r\nif (!t->u.target->target)\r\nverdict = ((struct ebt_standard_target *)t)->verdict;\r\nelse {\r\nacpar.target = t->u.target;\r\nacpar.targinfo = t->data;\r\nverdict = t->u.target->target(skb, &acpar);\r\n}\r\nif (verdict == EBT_ACCEPT) {\r\nread_unlock_bh(&table->lock);\r\nreturn NF_ACCEPT;\r\n}\r\nif (verdict == EBT_DROP) {\r\nread_unlock_bh(&table->lock);\r\nreturn NF_DROP;\r\n}\r\nif (verdict == EBT_RETURN) {\r\nletsreturn:\r\n#ifdef CONFIG_NETFILTER_DEBUG\r\nif (sp == 0) {\r\nBUGPRINT("RETURN on base chain");\r\ngoto letscontinue;\r\n}\r\n#endif\r\nsp--;\r\ni = cs[sp].n;\r\nchaininfo = cs[sp].chaininfo;\r\nnentries = chaininfo->nentries;\r\npoint = cs[sp].e;\r\ncounter_base = cb_base +\r\nchaininfo->counter_offset;\r\ncontinue;\r\n}\r\nif (verdict == EBT_CONTINUE)\r\ngoto letscontinue;\r\n#ifdef CONFIG_NETFILTER_DEBUG\r\nif (verdict < 0) {\r\nBUGPRINT("bogus standard verdict\n");\r\nread_unlock_bh(&table->lock);\r\nreturn NF_DROP;\r\n}\r\n#endif\r\ncs[sp].n = i + 1;\r\ncs[sp].chaininfo = chaininfo;\r\ncs[sp].e = ebt_next_entry(point);\r\ni = 0;\r\nchaininfo = (struct ebt_entries *) (base + verdict);\r\n#ifdef CONFIG_NETFILTER_DEBUG\r\nif (chaininfo->distinguisher) {\r\nBUGPRINT("jump to non-chain\n");\r\nread_unlock_bh(&table->lock);\r\nreturn NF_DROP;\r\n}\r\n#endif\r\nnentries = chaininfo->nentries;\r\npoint = (struct ebt_entry *)chaininfo->data;\r\ncounter_base = cb_base + chaininfo->counter_offset;\r\nsp++;\r\ncontinue;\r\nletscontinue:\r\npoint = ebt_next_entry(point);\r\ni++;\r\n}\r\nif (chaininfo->policy == EBT_RETURN)\r\ngoto letsreturn;\r\nif (chaininfo->policy == EBT_ACCEPT) {\r\nread_unlock_bh(&table->lock);\r\nreturn NF_ACCEPT;\r\n}\r\nread_unlock_bh(&table->lock);\r\nreturn NF_DROP;\r\n}\r\nstatic inline void *\r\nfind_inlist_lock_noload(struct list_head *head, const char *name, int *error,\r\nstruct mutex *mutex)\r\n{\r\nstruct {\r\nstruct list_head list;\r\nchar name[EBT_FUNCTION_MAXNAMELEN];\r\n} *e;\r\nmutex_lock(mutex);\r\nlist_for_each_entry(e, head, list) {\r\nif (strcmp(e->name, name) == 0)\r\nreturn e;\r\n}\r\n*error = -ENOENT;\r\nmutex_unlock(mutex);\r\nreturn NULL;\r\n}\r\nstatic void *\r\nfind_inlist_lock(struct list_head *head, const char *name, const char *prefix,\r\nint *error, struct mutex *mutex)\r\n{\r\nreturn try_then_request_module(\r\nfind_inlist_lock_noload(head, name, error, mutex),\r\n"%s%s", prefix, name);\r\n}\r\nstatic inline struct ebt_table *\r\nfind_table_lock(struct net *net, const char *name, int *error,\r\nstruct mutex *mutex)\r\n{\r\nreturn find_inlist_lock(&net->xt.tables[NFPROTO_BRIDGE], name,\r\n"ebtable_", error, mutex);\r\n}\r\nstatic inline int\r\nebt_check_match(struct ebt_entry_match *m, struct xt_mtchk_param *par,\r\nunsigned int *cnt)\r\n{\r\nconst struct ebt_entry *e = par->entryinfo;\r\nstruct xt_match *match;\r\nsize_t left = ((char *)e + e->watchers_offset) - (char *)m;\r\nint ret;\r\nif (left < sizeof(struct ebt_entry_match) ||\r\nleft - sizeof(struct ebt_entry_match) < m->match_size)\r\nreturn -EINVAL;\r\nmatch = xt_find_match(NFPROTO_BRIDGE, m->u.name, 0);\r\nif (IS_ERR(match) || match->family != NFPROTO_BRIDGE) {\r\nrequest_module("ebt_%s", m->u.name);\r\nmatch = xt_find_match(NFPROTO_BRIDGE, m->u.name, 0);\r\n}\r\nif (IS_ERR(match))\r\nreturn PTR_ERR(match);\r\nm->u.match = match;\r\npar->match = match;\r\npar->matchinfo = m->data;\r\nret = xt_check_match(par, m->match_size,\r\ne->ethproto, e->invflags & EBT_IPROTO);\r\nif (ret < 0) {\r\nmodule_put(match->me);\r\nreturn ret;\r\n}\r\n(*cnt)++;\r\nreturn 0;\r\n}\r\nstatic inline int\r\nebt_check_watcher(struct ebt_entry_watcher *w, struct xt_tgchk_param *par,\r\nunsigned int *cnt)\r\n{\r\nconst struct ebt_entry *e = par->entryinfo;\r\nstruct xt_target *watcher;\r\nsize_t left = ((char *)e + e->target_offset) - (char *)w;\r\nint ret;\r\nif (left < sizeof(struct ebt_entry_watcher) ||\r\nleft - sizeof(struct ebt_entry_watcher) < w->watcher_size)\r\nreturn -EINVAL;\r\nwatcher = xt_request_find_target(NFPROTO_BRIDGE, w->u.name, 0);\r\nif (IS_ERR(watcher))\r\nreturn PTR_ERR(watcher);\r\nw->u.watcher = watcher;\r\npar->target = watcher;\r\npar->targinfo = w->data;\r\nret = xt_check_target(par, w->watcher_size,\r\ne->ethproto, e->invflags & EBT_IPROTO);\r\nif (ret < 0) {\r\nmodule_put(watcher->me);\r\nreturn ret;\r\n}\r\n(*cnt)++;\r\nreturn 0;\r\n}\r\nstatic int ebt_verify_pointers(const struct ebt_replace *repl,\r\nstruct ebt_table_info *newinfo)\r\n{\r\nunsigned int limit = repl->entries_size;\r\nunsigned int valid_hooks = repl->valid_hooks;\r\nunsigned int offset = 0;\r\nint i;\r\nfor (i = 0; i < NF_BR_NUMHOOKS; i++)\r\nnewinfo->hook_entry[i] = NULL;\r\nnewinfo->entries_size = repl->entries_size;\r\nnewinfo->nentries = repl->nentries;\r\nwhile (offset < limit) {\r\nsize_t left = limit - offset;\r\nstruct ebt_entry *e = (void *)newinfo->entries + offset;\r\nif (left < sizeof(unsigned int))\r\nbreak;\r\nfor (i = 0; i < NF_BR_NUMHOOKS; i++) {\r\nif ((valid_hooks & (1 << i)) == 0)\r\ncontinue;\r\nif ((char __user *)repl->hook_entry[i] ==\r\nrepl->entries + offset)\r\nbreak;\r\n}\r\nif (i != NF_BR_NUMHOOKS || !(e->bitmask & EBT_ENTRY_OR_ENTRIES)) {\r\nif (e->bitmask != 0) {\r\nBUGPRINT("EBT_ENTRY_OR_ENTRIES shouldn't be set "\r\n"in distinguisher\n");\r\nreturn -EINVAL;\r\n}\r\nif (i != NF_BR_NUMHOOKS)\r\nnewinfo->hook_entry[i] = (struct ebt_entries *)e;\r\nif (left < sizeof(struct ebt_entries))\r\nbreak;\r\noffset += sizeof(struct ebt_entries);\r\n} else {\r\nif (left < sizeof(struct ebt_entry))\r\nbreak;\r\nif (left < e->next_offset)\r\nbreak;\r\nif (e->next_offset < sizeof(struct ebt_entry))\r\nreturn -EINVAL;\r\noffset += e->next_offset;\r\n}\r\n}\r\nif (offset != limit) {\r\nBUGPRINT("entries_size too small\n");\r\nreturn -EINVAL;\r\n}\r\nfor (i = 0; i < NF_BR_NUMHOOKS; i++) {\r\nif (!newinfo->hook_entry[i] &&\r\n(valid_hooks & (1 << i))) {\r\nBUGPRINT("Valid hook without chain\n");\r\nreturn -EINVAL;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic inline int\r\nebt_check_entry_size_and_hooks(const struct ebt_entry *e,\r\nconst struct ebt_table_info *newinfo,\r\nunsigned int *n, unsigned int *cnt,\r\nunsigned int *totalcnt, unsigned int *udc_cnt)\r\n{\r\nint i;\r\nfor (i = 0; i < NF_BR_NUMHOOKS; i++) {\r\nif ((void *)e == (void *)newinfo->hook_entry[i])\r\nbreak;\r\n}\r\nif (i != NF_BR_NUMHOOKS || !e->bitmask) {\r\nif (*n != *cnt) {\r\nBUGPRINT("nentries does not equal the nr of entries "\r\n"in the chain\n");\r\nreturn -EINVAL;\r\n}\r\nif (((struct ebt_entries *)e)->policy != EBT_DROP &&\r\n((struct ebt_entries *)e)->policy != EBT_ACCEPT) {\r\nif (i != NF_BR_NUMHOOKS ||\r\n((struct ebt_entries *)e)->policy != EBT_RETURN) {\r\nBUGPRINT("bad policy\n");\r\nreturn -EINVAL;\r\n}\r\n}\r\nif (i == NF_BR_NUMHOOKS)\r\n(*udc_cnt)++;\r\nif (((struct ebt_entries *)e)->counter_offset != *totalcnt) {\r\nBUGPRINT("counter_offset != totalcnt");\r\nreturn -EINVAL;\r\n}\r\n*n = ((struct ebt_entries *)e)->nentries;\r\n*cnt = 0;\r\nreturn 0;\r\n}\r\nif (sizeof(struct ebt_entry) > e->watchers_offset ||\r\ne->watchers_offset > e->target_offset ||\r\ne->target_offset >= e->next_offset) {\r\nBUGPRINT("entry offsets not in right order\n");\r\nreturn -EINVAL;\r\n}\r\nif (e->next_offset - e->target_offset < sizeof(struct ebt_entry_target)) {\r\nBUGPRINT("target size too small\n");\r\nreturn -EINVAL;\r\n}\r\n(*cnt)++;\r\n(*totalcnt)++;\r\nreturn 0;\r\n}\r\nstatic inline int\r\nebt_get_udc_positions(struct ebt_entry *e, struct ebt_table_info *newinfo,\r\nunsigned int *n, struct ebt_cl_stack *udc)\r\n{\r\nint i;\r\nif (e->bitmask)\r\nreturn 0;\r\nfor (i = 0; i < NF_BR_NUMHOOKS; i++) {\r\nif (newinfo->hook_entry[i] == (struct ebt_entries *)e)\r\nbreak;\r\n}\r\nif (i != NF_BR_NUMHOOKS)\r\nreturn 0;\r\nudc[*n].cs.chaininfo = (struct ebt_entries *)e;\r\nudc[*n].cs.n = 0;\r\nudc[*n].hookmask = 0;\r\n(*n)++;\r\nreturn 0;\r\n}\r\nstatic inline int\r\nebt_cleanup_match(struct ebt_entry_match *m, struct net *net, unsigned int *i)\r\n{\r\nstruct xt_mtdtor_param par;\r\nif (i && (*i)-- == 0)\r\nreturn 1;\r\npar.net = net;\r\npar.match = m->u.match;\r\npar.matchinfo = m->data;\r\npar.family = NFPROTO_BRIDGE;\r\nif (par.match->destroy != NULL)\r\npar.match->destroy(&par);\r\nmodule_put(par.match->me);\r\nreturn 0;\r\n}\r\nstatic inline int\r\nebt_cleanup_watcher(struct ebt_entry_watcher *w, struct net *net, unsigned int *i)\r\n{\r\nstruct xt_tgdtor_param par;\r\nif (i && (*i)-- == 0)\r\nreturn 1;\r\npar.net = net;\r\npar.target = w->u.watcher;\r\npar.targinfo = w->data;\r\npar.family = NFPROTO_BRIDGE;\r\nif (par.target->destroy != NULL)\r\npar.target->destroy(&par);\r\nmodule_put(par.target->me);\r\nreturn 0;\r\n}\r\nstatic inline int\r\nebt_cleanup_entry(struct ebt_entry *e, struct net *net, unsigned int *cnt)\r\n{\r\nstruct xt_tgdtor_param par;\r\nstruct ebt_entry_target *t;\r\nif (e->bitmask == 0)\r\nreturn 0;\r\nif (cnt && (*cnt)-- == 0)\r\nreturn 1;\r\nEBT_WATCHER_ITERATE(e, ebt_cleanup_watcher, net, NULL);\r\nEBT_MATCH_ITERATE(e, ebt_cleanup_match, net, NULL);\r\nt = (struct ebt_entry_target *)(((char *)e) + e->target_offset);\r\npar.net = net;\r\npar.target = t->u.target;\r\npar.targinfo = t->data;\r\npar.family = NFPROTO_BRIDGE;\r\nif (par.target->destroy != NULL)\r\npar.target->destroy(&par);\r\nmodule_put(par.target->me);\r\nreturn 0;\r\n}\r\nstatic inline int\r\nebt_check_entry(struct ebt_entry *e, struct net *net,\r\nconst struct ebt_table_info *newinfo,\r\nconst char *name, unsigned int *cnt,\r\nstruct ebt_cl_stack *cl_s, unsigned int udc_cnt)\r\n{\r\nstruct ebt_entry_target *t;\r\nstruct xt_target *target;\r\nunsigned int i, j, hook = 0, hookmask = 0;\r\nsize_t gap;\r\nint ret;\r\nstruct xt_mtchk_param mtpar;\r\nstruct xt_tgchk_param tgpar;\r\nif (e->bitmask == 0)\r\nreturn 0;\r\nif (e->bitmask & ~EBT_F_MASK) {\r\nBUGPRINT("Unknown flag for bitmask\n");\r\nreturn -EINVAL;\r\n}\r\nif (e->invflags & ~EBT_INV_MASK) {\r\nBUGPRINT("Unknown flag for inv bitmask\n");\r\nreturn -EINVAL;\r\n}\r\nif ((e->bitmask & EBT_NOPROTO) && (e->bitmask & EBT_802_3)) {\r\nBUGPRINT("NOPROTO & 802_3 not allowed\n");\r\nreturn -EINVAL;\r\n}\r\nfor (i = 0; i < NF_BR_NUMHOOKS; i++) {\r\nif (!newinfo->hook_entry[i])\r\ncontinue;\r\nif ((char *)newinfo->hook_entry[i] < (char *)e)\r\nhook = i;\r\nelse\r\nbreak;\r\n}\r\nif (i < NF_BR_NUMHOOKS)\r\nhookmask = (1 << hook) | (1 << NF_BR_NUMHOOKS);\r\nelse {\r\nfor (i = 0; i < udc_cnt; i++)\r\nif ((char *)(cl_s[i].cs.chaininfo) > (char *)e)\r\nbreak;\r\nif (i == 0)\r\nhookmask = (1 << hook) | (1 << NF_BR_NUMHOOKS);\r\nelse\r\nhookmask = cl_s[i - 1].hookmask;\r\n}\r\ni = 0;\r\nmtpar.net = tgpar.net = net;\r\nmtpar.table = tgpar.table = name;\r\nmtpar.entryinfo = tgpar.entryinfo = e;\r\nmtpar.hook_mask = tgpar.hook_mask = hookmask;\r\nmtpar.family = tgpar.family = NFPROTO_BRIDGE;\r\nret = EBT_MATCH_ITERATE(e, ebt_check_match, &mtpar, &i);\r\nif (ret != 0)\r\ngoto cleanup_matches;\r\nj = 0;\r\nret = EBT_WATCHER_ITERATE(e, ebt_check_watcher, &tgpar, &j);\r\nif (ret != 0)\r\ngoto cleanup_watchers;\r\nt = (struct ebt_entry_target *)(((char *)e) + e->target_offset);\r\ngap = e->next_offset - e->target_offset;\r\ntarget = xt_request_find_target(NFPROTO_BRIDGE, t->u.name, 0);\r\nif (IS_ERR(target)) {\r\nret = PTR_ERR(target);\r\ngoto cleanup_watchers;\r\n}\r\nt->u.target = target;\r\nif (t->u.target == &ebt_standard_target) {\r\nif (gap < sizeof(struct ebt_standard_target)) {\r\nBUGPRINT("Standard target size too big\n");\r\nret = -EFAULT;\r\ngoto cleanup_watchers;\r\n}\r\nif (((struct ebt_standard_target *)t)->verdict <\r\n-NUM_STANDARD_TARGETS) {\r\nBUGPRINT("Invalid standard target\n");\r\nret = -EFAULT;\r\ngoto cleanup_watchers;\r\n}\r\n} else if (t->target_size > gap - sizeof(struct ebt_entry_target)) {\r\nmodule_put(t->u.target->me);\r\nret = -EFAULT;\r\ngoto cleanup_watchers;\r\n}\r\ntgpar.target = target;\r\ntgpar.targinfo = t->data;\r\nret = xt_check_target(&tgpar, t->target_size,\r\ne->ethproto, e->invflags & EBT_IPROTO);\r\nif (ret < 0) {\r\nmodule_put(target->me);\r\ngoto cleanup_watchers;\r\n}\r\n(*cnt)++;\r\nreturn 0;\r\ncleanup_watchers:\r\nEBT_WATCHER_ITERATE(e, ebt_cleanup_watcher, net, &j);\r\ncleanup_matches:\r\nEBT_MATCH_ITERATE(e, ebt_cleanup_match, net, &i);\r\nreturn ret;\r\n}\r\nstatic int check_chainloops(const struct ebt_entries *chain, struct ebt_cl_stack *cl_s,\r\nunsigned int udc_cnt, unsigned int hooknr, char *base)\r\n{\r\nint i, chain_nr = -1, pos = 0, nentries = chain->nentries, verdict;\r\nconst struct ebt_entry *e = (struct ebt_entry *)chain->data;\r\nconst struct ebt_entry_target *t;\r\nwhile (pos < nentries || chain_nr != -1) {\r\nif (pos == nentries) {\r\ne = cl_s[chain_nr].cs.e;\r\nif (cl_s[chain_nr].from != -1)\r\nnentries =\r\ncl_s[cl_s[chain_nr].from].cs.chaininfo->nentries;\r\nelse\r\nnentries = chain->nentries;\r\npos = cl_s[chain_nr].cs.n;\r\ncl_s[chain_nr].cs.n = 0;\r\nchain_nr = cl_s[chain_nr].from;\r\nif (pos == nentries)\r\ncontinue;\r\n}\r\nt = (struct ebt_entry_target *)\r\n(((char *)e) + e->target_offset);\r\nif (strcmp(t->u.name, EBT_STANDARD_TARGET))\r\ngoto letscontinue;\r\nif (e->target_offset + sizeof(struct ebt_standard_target) >\r\ne->next_offset) {\r\nBUGPRINT("Standard target size too big\n");\r\nreturn -1;\r\n}\r\nverdict = ((struct ebt_standard_target *)t)->verdict;\r\nif (verdict >= 0) {\r\nstruct ebt_entries *hlp2 =\r\n(struct ebt_entries *)(base + verdict);\r\nfor (i = 0; i < udc_cnt; i++)\r\nif (hlp2 == cl_s[i].cs.chaininfo)\r\nbreak;\r\nif (i == udc_cnt) {\r\nBUGPRINT("bad destination\n");\r\nreturn -1;\r\n}\r\nif (cl_s[i].cs.n) {\r\nBUGPRINT("loop\n");\r\nreturn -1;\r\n}\r\nif (cl_s[i].hookmask & (1 << hooknr))\r\ngoto letscontinue;\r\ncl_s[i].cs.n = pos + 1;\r\npos = 0;\r\ncl_s[i].cs.e = ebt_next_entry(e);\r\ne = (struct ebt_entry *)(hlp2->data);\r\nnentries = hlp2->nentries;\r\ncl_s[i].from = chain_nr;\r\nchain_nr = i;\r\ncl_s[i].hookmask |= (1 << hooknr);\r\ncontinue;\r\n}\r\nletscontinue:\r\ne = ebt_next_entry(e);\r\npos++;\r\n}\r\nreturn 0;\r\n}\r\nstatic int translate_table(struct net *net, const char *name,\r\nstruct ebt_table_info *newinfo)\r\n{\r\nunsigned int i, j, k, udc_cnt;\r\nint ret;\r\nstruct ebt_cl_stack *cl_s = NULL;\r\ni = 0;\r\nwhile (i < NF_BR_NUMHOOKS && !newinfo->hook_entry[i])\r\ni++;\r\nif (i == NF_BR_NUMHOOKS) {\r\nBUGPRINT("No valid hooks specified\n");\r\nreturn -EINVAL;\r\n}\r\nif (newinfo->hook_entry[i] != (struct ebt_entries *)newinfo->entries) {\r\nBUGPRINT("Chains don't start at beginning\n");\r\nreturn -EINVAL;\r\n}\r\nfor (j = i + 1; j < NF_BR_NUMHOOKS; j++) {\r\nif (!newinfo->hook_entry[j])\r\ncontinue;\r\nif (newinfo->hook_entry[j] <= newinfo->hook_entry[i]) {\r\nBUGPRINT("Hook order must be followed\n");\r\nreturn -EINVAL;\r\n}\r\ni = j;\r\n}\r\ni = 0;\r\nj = 0;\r\nk = 0;\r\nudc_cnt = 0;\r\nret = EBT_ENTRY_ITERATE(newinfo->entries, newinfo->entries_size,\r\nebt_check_entry_size_and_hooks, newinfo,\r\n&i, &j, &k, &udc_cnt);\r\nif (ret != 0)\r\nreturn ret;\r\nif (i != j) {\r\nBUGPRINT("nentries does not equal the nr of entries in the "\r\n"(last) chain\n");\r\nreturn -EINVAL;\r\n}\r\nif (k != newinfo->nentries) {\r\nBUGPRINT("Total nentries is wrong\n");\r\nreturn -EINVAL;\r\n}\r\nif (udc_cnt) {\r\nnewinfo->chainstack =\r\nvmalloc(nr_cpu_ids * sizeof(*(newinfo->chainstack)));\r\nif (!newinfo->chainstack)\r\nreturn -ENOMEM;\r\nfor_each_possible_cpu(i) {\r\nnewinfo->chainstack[i] =\r\nvmalloc(udc_cnt * sizeof(*(newinfo->chainstack[0])));\r\nif (!newinfo->chainstack[i]) {\r\nwhile (i)\r\nvfree(newinfo->chainstack[--i]);\r\nvfree(newinfo->chainstack);\r\nnewinfo->chainstack = NULL;\r\nreturn -ENOMEM;\r\n}\r\n}\r\ncl_s = vmalloc(udc_cnt * sizeof(*cl_s));\r\nif (!cl_s)\r\nreturn -ENOMEM;\r\ni = 0;\r\nEBT_ENTRY_ITERATE(newinfo->entries, newinfo->entries_size,\r\nebt_get_udc_positions, newinfo, &i, cl_s);\r\nif (i != udc_cnt) {\r\nBUGPRINT("i != udc_cnt\n");\r\nvfree(cl_s);\r\nreturn -EFAULT;\r\n}\r\n}\r\nfor (i = 0; i < NF_BR_NUMHOOKS; i++)\r\nif (newinfo->hook_entry[i])\r\nif (check_chainloops(newinfo->hook_entry[i],\r\ncl_s, udc_cnt, i, newinfo->entries)) {\r\nvfree(cl_s);\r\nreturn -EINVAL;\r\n}\r\ni = 0;\r\nret = EBT_ENTRY_ITERATE(newinfo->entries, newinfo->entries_size,\r\nebt_check_entry, net, newinfo, name, &i, cl_s, udc_cnt);\r\nif (ret != 0) {\r\nEBT_ENTRY_ITERATE(newinfo->entries, newinfo->entries_size,\r\nebt_cleanup_entry, net, &i);\r\n}\r\nvfree(cl_s);\r\nreturn ret;\r\n}\r\nstatic void get_counters(const struct ebt_counter *oldcounters,\r\nstruct ebt_counter *counters, unsigned int nentries)\r\n{\r\nint i, cpu;\r\nstruct ebt_counter *counter_base;\r\nmemcpy(counters, oldcounters,\r\nsizeof(struct ebt_counter) * nentries);\r\nfor_each_possible_cpu(cpu) {\r\nif (cpu == 0)\r\ncontinue;\r\ncounter_base = COUNTER_BASE(oldcounters, nentries, cpu);\r\nfor (i = 0; i < nentries; i++) {\r\ncounters[i].pcnt += counter_base[i].pcnt;\r\ncounters[i].bcnt += counter_base[i].bcnt;\r\n}\r\n}\r\n}\r\nstatic int do_replace_finish(struct net *net, struct ebt_replace *repl,\r\nstruct ebt_table_info *newinfo)\r\n{\r\nint ret, i;\r\nstruct ebt_counter *counterstmp = NULL;\r\nstruct ebt_table_info *table;\r\nstruct ebt_table *t;\r\nif (repl->num_counters) {\r\nunsigned long size = repl->num_counters * sizeof(*counterstmp);\r\ncounterstmp = vmalloc(size);\r\nif (!counterstmp)\r\nreturn -ENOMEM;\r\n}\r\nnewinfo->chainstack = NULL;\r\nret = ebt_verify_pointers(repl, newinfo);\r\nif (ret != 0)\r\ngoto free_counterstmp;\r\nret = translate_table(net, repl->name, newinfo);\r\nif (ret != 0)\r\ngoto free_counterstmp;\r\nt = find_table_lock(net, repl->name, &ret, &ebt_mutex);\r\nif (!t) {\r\nret = -ENOENT;\r\ngoto free_iterate;\r\n}\r\nif (t->check && (ret = t->check(newinfo, repl->valid_hooks)))\r\ngoto free_unlock;\r\nif (repl->num_counters && repl->num_counters != t->private->nentries) {\r\nBUGPRINT("Wrong nr. of counters requested\n");\r\nret = -EINVAL;\r\ngoto free_unlock;\r\n}\r\ntable = t->private;\r\nif (!table->nentries && newinfo->nentries && !try_module_get(t->me)) {\r\nret = -ENOENT;\r\ngoto free_unlock;\r\n} else if (table->nentries && !newinfo->nentries)\r\nmodule_put(t->me);\r\nwrite_lock_bh(&t->lock);\r\nif (repl->num_counters)\r\nget_counters(t->private->counters, counterstmp,\r\nt->private->nentries);\r\nt->private = newinfo;\r\nwrite_unlock_bh(&t->lock);\r\nmutex_unlock(&ebt_mutex);\r\nif (repl->num_counters &&\r\ncopy_to_user(repl->counters, counterstmp,\r\nrepl->num_counters * sizeof(struct ebt_counter))) {\r\nnet_warn_ratelimited("ebtables: counters copy to user failed while replacing table\n");\r\n}\r\nEBT_ENTRY_ITERATE(table->entries, table->entries_size,\r\nebt_cleanup_entry, net, NULL);\r\nvfree(table->entries);\r\nif (table->chainstack) {\r\nfor_each_possible_cpu(i)\r\nvfree(table->chainstack[i]);\r\nvfree(table->chainstack);\r\n}\r\nvfree(table);\r\nvfree(counterstmp);\r\n#ifdef CONFIG_AUDIT\r\nif (audit_enabled) {\r\nstruct audit_buffer *ab;\r\nab = audit_log_start(current->audit_context, GFP_KERNEL,\r\nAUDIT_NETFILTER_CFG);\r\nif (ab) {\r\naudit_log_format(ab, "table=%s family=%u entries=%u",\r\nrepl->name, AF_BRIDGE, repl->nentries);\r\naudit_log_end(ab);\r\n}\r\n}\r\n#endif\r\nreturn ret;\r\nfree_unlock:\r\nmutex_unlock(&ebt_mutex);\r\nfree_iterate:\r\nEBT_ENTRY_ITERATE(newinfo->entries, newinfo->entries_size,\r\nebt_cleanup_entry, net, NULL);\r\nfree_counterstmp:\r\nvfree(counterstmp);\r\nif (newinfo->chainstack) {\r\nfor_each_possible_cpu(i)\r\nvfree(newinfo->chainstack[i]);\r\nvfree(newinfo->chainstack);\r\n}\r\nreturn ret;\r\n}\r\nstatic int do_replace(struct net *net, const void __user *user,\r\nunsigned int len)\r\n{\r\nint ret, countersize;\r\nstruct ebt_table_info *newinfo;\r\nstruct ebt_replace tmp;\r\nif (copy_from_user(&tmp, user, sizeof(tmp)) != 0)\r\nreturn -EFAULT;\r\nif (len != sizeof(tmp) + tmp.entries_size) {\r\nBUGPRINT("Wrong len argument\n");\r\nreturn -EINVAL;\r\n}\r\nif (tmp.entries_size == 0) {\r\nBUGPRINT("Entries_size never zero\n");\r\nreturn -EINVAL;\r\n}\r\nif (tmp.nentries >= ((INT_MAX - sizeof(struct ebt_table_info)) /\r\nNR_CPUS - SMP_CACHE_BYTES) / sizeof(struct ebt_counter))\r\nreturn -ENOMEM;\r\nif (tmp.num_counters >= INT_MAX / sizeof(struct ebt_counter))\r\nreturn -ENOMEM;\r\ntmp.name[sizeof(tmp.name) - 1] = 0;\r\ncountersize = COUNTER_OFFSET(tmp.nentries) * nr_cpu_ids;\r\nnewinfo = vmalloc(sizeof(*newinfo) + countersize);\r\nif (!newinfo)\r\nreturn -ENOMEM;\r\nif (countersize)\r\nmemset(newinfo->counters, 0, countersize);\r\nnewinfo->entries = vmalloc(tmp.entries_size);\r\nif (!newinfo->entries) {\r\nret = -ENOMEM;\r\ngoto free_newinfo;\r\n}\r\nif (copy_from_user(\r\nnewinfo->entries, tmp.entries, tmp.entries_size) != 0) {\r\nBUGPRINT("Couldn't copy entries from userspace\n");\r\nret = -EFAULT;\r\ngoto free_entries;\r\n}\r\nret = do_replace_finish(net, &tmp, newinfo);\r\nif (ret == 0)\r\nreturn ret;\r\nfree_entries:\r\nvfree(newinfo->entries);\r\nfree_newinfo:\r\nvfree(newinfo);\r\nreturn ret;\r\n}\r\nstruct ebt_table *\r\nebt_register_table(struct net *net, const struct ebt_table *input_table)\r\n{\r\nstruct ebt_table_info *newinfo;\r\nstruct ebt_table *t, *table;\r\nstruct ebt_replace_kernel *repl;\r\nint ret, i, countersize;\r\nvoid *p;\r\nif (input_table == NULL || (repl = input_table->table) == NULL ||\r\nrepl->entries == NULL || repl->entries_size == 0 ||\r\nrepl->counters != NULL || input_table->private != NULL) {\r\nBUGPRINT("Bad table data for ebt_register_table!!!\n");\r\nreturn ERR_PTR(-EINVAL);\r\n}\r\ntable = kmemdup(input_table, sizeof(struct ebt_table), GFP_KERNEL);\r\nif (!table) {\r\nret = -ENOMEM;\r\ngoto out;\r\n}\r\ncountersize = COUNTER_OFFSET(repl->nentries) * nr_cpu_ids;\r\nnewinfo = vmalloc(sizeof(*newinfo) + countersize);\r\nret = -ENOMEM;\r\nif (!newinfo)\r\ngoto free_table;\r\np = vmalloc(repl->entries_size);\r\nif (!p)\r\ngoto free_newinfo;\r\nmemcpy(p, repl->entries, repl->entries_size);\r\nnewinfo->entries = p;\r\nnewinfo->entries_size = repl->entries_size;\r\nnewinfo->nentries = repl->nentries;\r\nif (countersize)\r\nmemset(newinfo->counters, 0, countersize);\r\nnewinfo->chainstack = NULL;\r\nfor (i = 0; i < NF_BR_NUMHOOKS; i++) {\r\nif ((repl->valid_hooks & (1 << i)) == 0)\r\nnewinfo->hook_entry[i] = NULL;\r\nelse\r\nnewinfo->hook_entry[i] = p +\r\n((char *)repl->hook_entry[i] - repl->entries);\r\n}\r\nret = translate_table(net, repl->name, newinfo);\r\nif (ret != 0) {\r\nBUGPRINT("Translate_table failed\n");\r\ngoto free_chainstack;\r\n}\r\nif (table->check && table->check(newinfo, table->valid_hooks)) {\r\nBUGPRINT("The table doesn't like its own initial data, lol\n");\r\nret = -EINVAL;\r\ngoto free_chainstack;\r\n}\r\ntable->private = newinfo;\r\nrwlock_init(&table->lock);\r\nmutex_lock(&ebt_mutex);\r\nlist_for_each_entry(t, &net->xt.tables[NFPROTO_BRIDGE], list) {\r\nif (strcmp(t->name, table->name) == 0) {\r\nret = -EEXIST;\r\nBUGPRINT("Table name already exists\n");\r\ngoto free_unlock;\r\n}\r\n}\r\nif (newinfo->nentries && !try_module_get(table->me)) {\r\nret = -ENOENT;\r\ngoto free_unlock;\r\n}\r\nlist_add(&table->list, &net->xt.tables[NFPROTO_BRIDGE]);\r\nmutex_unlock(&ebt_mutex);\r\nreturn table;\r\nfree_unlock:\r\nmutex_unlock(&ebt_mutex);\r\nfree_chainstack:\r\nif (newinfo->chainstack) {\r\nfor_each_possible_cpu(i)\r\nvfree(newinfo->chainstack[i]);\r\nvfree(newinfo->chainstack);\r\n}\r\nvfree(newinfo->entries);\r\nfree_newinfo:\r\nvfree(newinfo);\r\nfree_table:\r\nkfree(table);\r\nout:\r\nreturn ERR_PTR(ret);\r\n}\r\nvoid ebt_unregister_table(struct net *net, struct ebt_table *table)\r\n{\r\nint i;\r\nif (!table) {\r\nBUGPRINT("Request to unregister NULL table!!!\n");\r\nreturn;\r\n}\r\nmutex_lock(&ebt_mutex);\r\nlist_del(&table->list);\r\nmutex_unlock(&ebt_mutex);\r\nEBT_ENTRY_ITERATE(table->private->entries, table->private->entries_size,\r\nebt_cleanup_entry, net, NULL);\r\nif (table->private->nentries)\r\nmodule_put(table->me);\r\nvfree(table->private->entries);\r\nif (table->private->chainstack) {\r\nfor_each_possible_cpu(i)\r\nvfree(table->private->chainstack[i]);\r\nvfree(table->private->chainstack);\r\n}\r\nvfree(table->private);\r\nkfree(table);\r\n}\r\nstatic int do_update_counters(struct net *net, const char *name,\r\nstruct ebt_counter __user *counters,\r\nunsigned int num_counters,\r\nconst void __user *user, unsigned int len)\r\n{\r\nint i, ret;\r\nstruct ebt_counter *tmp;\r\nstruct ebt_table *t;\r\nif (num_counters == 0)\r\nreturn -EINVAL;\r\ntmp = vmalloc(num_counters * sizeof(*tmp));\r\nif (!tmp)\r\nreturn -ENOMEM;\r\nt = find_table_lock(net, name, &ret, &ebt_mutex);\r\nif (!t)\r\ngoto free_tmp;\r\nif (num_counters != t->private->nentries) {\r\nBUGPRINT("Wrong nr of counters\n");\r\nret = -EINVAL;\r\ngoto unlock_mutex;\r\n}\r\nif (copy_from_user(tmp, counters, num_counters * sizeof(*counters))) {\r\nret = -EFAULT;\r\ngoto unlock_mutex;\r\n}\r\nwrite_lock_bh(&t->lock);\r\nfor (i = 0; i < num_counters; i++) {\r\nt->private->counters[i].pcnt += tmp[i].pcnt;\r\nt->private->counters[i].bcnt += tmp[i].bcnt;\r\n}\r\nwrite_unlock_bh(&t->lock);\r\nret = 0;\r\nunlock_mutex:\r\nmutex_unlock(&ebt_mutex);\r\nfree_tmp:\r\nvfree(tmp);\r\nreturn ret;\r\n}\r\nstatic int update_counters(struct net *net, const void __user *user,\r\nunsigned int len)\r\n{\r\nstruct ebt_replace hlp;\r\nif (copy_from_user(&hlp, user, sizeof(hlp)))\r\nreturn -EFAULT;\r\nif (len != sizeof(hlp) + hlp.num_counters * sizeof(struct ebt_counter))\r\nreturn -EINVAL;\r\nreturn do_update_counters(net, hlp.name, hlp.counters,\r\nhlp.num_counters, user, len);\r\n}\r\nstatic inline int ebt_make_matchname(const struct ebt_entry_match *m,\r\nconst char *base, char __user *ubase)\r\n{\r\nchar __user *hlp = ubase + ((char *)m - base);\r\nchar name[EBT_FUNCTION_MAXNAMELEN] = {};\r\nstrlcpy(name, m->u.match->name, sizeof(name));\r\nif (copy_to_user(hlp, name, EBT_FUNCTION_MAXNAMELEN))\r\nreturn -EFAULT;\r\nreturn 0;\r\n}\r\nstatic inline int ebt_make_watchername(const struct ebt_entry_watcher *w,\r\nconst char *base, char __user *ubase)\r\n{\r\nchar __user *hlp = ubase + ((char *)w - base);\r\nchar name[EBT_FUNCTION_MAXNAMELEN] = {};\r\nstrlcpy(name, w->u.watcher->name, sizeof(name));\r\nif (copy_to_user(hlp, name, EBT_FUNCTION_MAXNAMELEN))\r\nreturn -EFAULT;\r\nreturn 0;\r\n}\r\nstatic inline int ebt_make_names(struct ebt_entry *e, const char *base,\r\nchar __user *ubase)\r\n{\r\nint ret;\r\nchar __user *hlp;\r\nconst struct ebt_entry_target *t;\r\nchar name[EBT_FUNCTION_MAXNAMELEN] = {};\r\nif (e->bitmask == 0)\r\nreturn 0;\r\nhlp = ubase + (((char *)e + e->target_offset) - base);\r\nt = (struct ebt_entry_target *)(((char *)e) + e->target_offset);\r\nret = EBT_MATCH_ITERATE(e, ebt_make_matchname, base, ubase);\r\nif (ret != 0)\r\nreturn ret;\r\nret = EBT_WATCHER_ITERATE(e, ebt_make_watchername, base, ubase);\r\nif (ret != 0)\r\nreturn ret;\r\nstrlcpy(name, t->u.target->name, sizeof(name));\r\nif (copy_to_user(hlp, name, EBT_FUNCTION_MAXNAMELEN))\r\nreturn -EFAULT;\r\nreturn 0;\r\n}\r\nstatic int copy_counters_to_user(struct ebt_table *t,\r\nconst struct ebt_counter *oldcounters,\r\nvoid __user *user, unsigned int num_counters,\r\nunsigned int nentries)\r\n{\r\nstruct ebt_counter *counterstmp;\r\nint ret = 0;\r\nif (num_counters == 0)\r\nreturn 0;\r\nif (num_counters != nentries) {\r\nBUGPRINT("Num_counters wrong\n");\r\nreturn -EINVAL;\r\n}\r\ncounterstmp = vmalloc(nentries * sizeof(*counterstmp));\r\nif (!counterstmp)\r\nreturn -ENOMEM;\r\nwrite_lock_bh(&t->lock);\r\nget_counters(oldcounters, counterstmp, nentries);\r\nwrite_unlock_bh(&t->lock);\r\nif (copy_to_user(user, counterstmp,\r\nnentries * sizeof(struct ebt_counter)))\r\nret = -EFAULT;\r\nvfree(counterstmp);\r\nreturn ret;\r\n}\r\nstatic int copy_everything_to_user(struct ebt_table *t, void __user *user,\r\nconst int *len, int cmd)\r\n{\r\nstruct ebt_replace tmp;\r\nconst struct ebt_counter *oldcounters;\r\nunsigned int entries_size, nentries;\r\nint ret;\r\nchar *entries;\r\nif (cmd == EBT_SO_GET_ENTRIES) {\r\nentries_size = t->private->entries_size;\r\nnentries = t->private->nentries;\r\nentries = t->private->entries;\r\noldcounters = t->private->counters;\r\n} else {\r\nentries_size = t->table->entries_size;\r\nnentries = t->table->nentries;\r\nentries = t->table->entries;\r\noldcounters = t->table->counters;\r\n}\r\nif (copy_from_user(&tmp, user, sizeof(tmp)))\r\nreturn -EFAULT;\r\nif (*len != sizeof(struct ebt_replace) + entries_size +\r\n(tmp.num_counters ? nentries * sizeof(struct ebt_counter) : 0))\r\nreturn -EINVAL;\r\nif (tmp.nentries != nentries) {\r\nBUGPRINT("Nentries wrong\n");\r\nreturn -EINVAL;\r\n}\r\nif (tmp.entries_size != entries_size) {\r\nBUGPRINT("Wrong size\n");\r\nreturn -EINVAL;\r\n}\r\nret = copy_counters_to_user(t, oldcounters, tmp.counters,\r\ntmp.num_counters, nentries);\r\nif (ret)\r\nreturn ret;\r\nif (copy_to_user(tmp.entries, entries, entries_size)) {\r\nBUGPRINT("Couldn't copy entries to userspace\n");\r\nreturn -EFAULT;\r\n}\r\nreturn EBT_ENTRY_ITERATE(entries, entries_size,\r\nebt_make_names, entries, tmp.entries);\r\n}\r\nstatic int do_ebt_set_ctl(struct sock *sk,\r\nint cmd, void __user *user, unsigned int len)\r\n{\r\nint ret;\r\nstruct net *net = sock_net(sk);\r\nif (!ns_capable(net->user_ns, CAP_NET_ADMIN))\r\nreturn -EPERM;\r\nswitch (cmd) {\r\ncase EBT_SO_SET_ENTRIES:\r\nret = do_replace(net, user, len);\r\nbreak;\r\ncase EBT_SO_SET_COUNTERS:\r\nret = update_counters(net, user, len);\r\nbreak;\r\ndefault:\r\nret = -EINVAL;\r\n}\r\nreturn ret;\r\n}\r\nstatic int do_ebt_get_ctl(struct sock *sk, int cmd, void __user *user, int *len)\r\n{\r\nint ret;\r\nstruct ebt_replace tmp;\r\nstruct ebt_table *t;\r\nstruct net *net = sock_net(sk);\r\nif (!ns_capable(net->user_ns, CAP_NET_ADMIN))\r\nreturn -EPERM;\r\nif (copy_from_user(&tmp, user, sizeof(tmp)))\r\nreturn -EFAULT;\r\ntmp.name[sizeof(tmp.name) - 1] = '\0';\r\nt = find_table_lock(net, tmp.name, &ret, &ebt_mutex);\r\nif (!t)\r\nreturn ret;\r\nswitch (cmd) {\r\ncase EBT_SO_GET_INFO:\r\ncase EBT_SO_GET_INIT_INFO:\r\nif (*len != sizeof(struct ebt_replace)) {\r\nret = -EINVAL;\r\nmutex_unlock(&ebt_mutex);\r\nbreak;\r\n}\r\nif (cmd == EBT_SO_GET_INFO) {\r\ntmp.nentries = t->private->nentries;\r\ntmp.entries_size = t->private->entries_size;\r\ntmp.valid_hooks = t->valid_hooks;\r\n} else {\r\ntmp.nentries = t->table->nentries;\r\ntmp.entries_size = t->table->entries_size;\r\ntmp.valid_hooks = t->table->valid_hooks;\r\n}\r\nmutex_unlock(&ebt_mutex);\r\nif (copy_to_user(user, &tmp, *len) != 0) {\r\nBUGPRINT("c2u Didn't work\n");\r\nret = -EFAULT;\r\nbreak;\r\n}\r\nret = 0;\r\nbreak;\r\ncase EBT_SO_GET_ENTRIES:\r\ncase EBT_SO_GET_INIT_ENTRIES:\r\nret = copy_everything_to_user(t, user, len, cmd);\r\nmutex_unlock(&ebt_mutex);\r\nbreak;\r\ndefault:\r\nmutex_unlock(&ebt_mutex);\r\nret = -EINVAL;\r\n}\r\nreturn ret;\r\n}\r\nstatic int ebt_compat_entry_padsize(void)\r\n{\r\nBUILD_BUG_ON(XT_ALIGN(sizeof(struct ebt_entry_match)) <\r\nCOMPAT_XT_ALIGN(sizeof(struct compat_ebt_entry_mwt)));\r\nreturn (int) XT_ALIGN(sizeof(struct ebt_entry_match)) -\r\nCOMPAT_XT_ALIGN(sizeof(struct compat_ebt_entry_mwt));\r\n}\r\nstatic int ebt_compat_match_offset(const struct xt_match *match,\r\nunsigned int userlen)\r\n{\r\nif (unlikely(match->matchsize == -1))\r\nreturn XT_ALIGN(userlen) - COMPAT_XT_ALIGN(userlen);\r\nreturn xt_compat_match_offset(match);\r\n}\r\nstatic int compat_match_to_user(struct ebt_entry_match *m, void __user **dstptr,\r\nunsigned int *size)\r\n{\r\nconst struct xt_match *match = m->u.match;\r\nstruct compat_ebt_entry_mwt __user *cm = *dstptr;\r\nint off = ebt_compat_match_offset(match, m->match_size);\r\ncompat_uint_t msize = m->match_size - off;\r\nBUG_ON(off >= m->match_size);\r\nif (copy_to_user(cm->u.name, match->name,\r\nstrlen(match->name) + 1) || put_user(msize, &cm->match_size))\r\nreturn -EFAULT;\r\nif (match->compat_to_user) {\r\nif (match->compat_to_user(cm->data, m->data))\r\nreturn -EFAULT;\r\n} else if (copy_to_user(cm->data, m->data, msize))\r\nreturn -EFAULT;\r\n*size -= ebt_compat_entry_padsize() + off;\r\n*dstptr = cm->data;\r\n*dstptr += msize;\r\nreturn 0;\r\n}\r\nstatic int compat_target_to_user(struct ebt_entry_target *t,\r\nvoid __user **dstptr,\r\nunsigned int *size)\r\n{\r\nconst struct xt_target *target = t->u.target;\r\nstruct compat_ebt_entry_mwt __user *cm = *dstptr;\r\nint off = xt_compat_target_offset(target);\r\ncompat_uint_t tsize = t->target_size - off;\r\nBUG_ON(off >= t->target_size);\r\nif (copy_to_user(cm->u.name, target->name,\r\nstrlen(target->name) + 1) || put_user(tsize, &cm->match_size))\r\nreturn -EFAULT;\r\nif (target->compat_to_user) {\r\nif (target->compat_to_user(cm->data, t->data))\r\nreturn -EFAULT;\r\n} else if (copy_to_user(cm->data, t->data, tsize))\r\nreturn -EFAULT;\r\n*size -= ebt_compat_entry_padsize() + off;\r\n*dstptr = cm->data;\r\n*dstptr += tsize;\r\nreturn 0;\r\n}\r\nstatic int compat_watcher_to_user(struct ebt_entry_watcher *w,\r\nvoid __user **dstptr,\r\nunsigned int *size)\r\n{\r\nreturn compat_target_to_user((struct ebt_entry_target *)w,\r\ndstptr, size);\r\n}\r\nstatic int compat_copy_entry_to_user(struct ebt_entry *e, void __user **dstptr,\r\nunsigned int *size)\r\n{\r\nstruct ebt_entry_target *t;\r\nstruct ebt_entry __user *ce;\r\nu32 watchers_offset, target_offset, next_offset;\r\ncompat_uint_t origsize;\r\nint ret;\r\nif (e->bitmask == 0) {\r\nif (*size < sizeof(struct ebt_entries))\r\nreturn -EINVAL;\r\nif (copy_to_user(*dstptr, e, sizeof(struct ebt_entries)))\r\nreturn -EFAULT;\r\n*dstptr += sizeof(struct ebt_entries);\r\n*size -= sizeof(struct ebt_entries);\r\nreturn 0;\r\n}\r\nif (*size < sizeof(*ce))\r\nreturn -EINVAL;\r\nce = (struct ebt_entry __user *)*dstptr;\r\nif (copy_to_user(ce, e, sizeof(*ce)))\r\nreturn -EFAULT;\r\norigsize = *size;\r\n*dstptr += sizeof(*ce);\r\nret = EBT_MATCH_ITERATE(e, compat_match_to_user, dstptr, size);\r\nif (ret)\r\nreturn ret;\r\nwatchers_offset = e->watchers_offset - (origsize - *size);\r\nret = EBT_WATCHER_ITERATE(e, compat_watcher_to_user, dstptr, size);\r\nif (ret)\r\nreturn ret;\r\ntarget_offset = e->target_offset - (origsize - *size);\r\nt = (struct ebt_entry_target *) ((char *) e + e->target_offset);\r\nret = compat_target_to_user(t, dstptr, size);\r\nif (ret)\r\nreturn ret;\r\nnext_offset = e->next_offset - (origsize - *size);\r\nif (put_user(watchers_offset, &ce->watchers_offset) ||\r\nput_user(target_offset, &ce->target_offset) ||\r\nput_user(next_offset, &ce->next_offset))\r\nreturn -EFAULT;\r\n*size -= sizeof(*ce);\r\nreturn 0;\r\n}\r\nstatic int compat_calc_match(struct ebt_entry_match *m, int *off)\r\n{\r\n*off += ebt_compat_match_offset(m->u.match, m->match_size);\r\n*off += ebt_compat_entry_padsize();\r\nreturn 0;\r\n}\r\nstatic int compat_calc_watcher(struct ebt_entry_watcher *w, int *off)\r\n{\r\n*off += xt_compat_target_offset(w->u.watcher);\r\n*off += ebt_compat_entry_padsize();\r\nreturn 0;\r\n}\r\nstatic int compat_calc_entry(const struct ebt_entry *e,\r\nconst struct ebt_table_info *info,\r\nconst void *base,\r\nstruct compat_ebt_replace *newinfo)\r\n{\r\nconst struct ebt_entry_target *t;\r\nunsigned int entry_offset;\r\nint off, ret, i;\r\nif (e->bitmask == 0)\r\nreturn 0;\r\noff = 0;\r\nentry_offset = (void *)e - base;\r\nEBT_MATCH_ITERATE(e, compat_calc_match, &off);\r\nEBT_WATCHER_ITERATE(e, compat_calc_watcher, &off);\r\nt = (const struct ebt_entry_target *) ((char *) e + e->target_offset);\r\noff += xt_compat_target_offset(t->u.target);\r\noff += ebt_compat_entry_padsize();\r\nnewinfo->entries_size -= off;\r\nret = xt_compat_add_offset(NFPROTO_BRIDGE, entry_offset, off);\r\nif (ret)\r\nreturn ret;\r\nfor (i = 0; i < NF_BR_NUMHOOKS; i++) {\r\nconst void *hookptr = info->hook_entry[i];\r\nif (info->hook_entry[i] &&\r\n(e < (struct ebt_entry *)(base - hookptr))) {\r\nnewinfo->hook_entry[i] -= off;\r\npr_debug("0x%08X -> 0x%08X\n",\r\nnewinfo->hook_entry[i] + off,\r\nnewinfo->hook_entry[i]);\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int compat_table_info(const struct ebt_table_info *info,\r\nstruct compat_ebt_replace *newinfo)\r\n{\r\nunsigned int size = info->entries_size;\r\nconst void *entries = info->entries;\r\nnewinfo->entries_size = size;\r\nxt_compat_init_offsets(NFPROTO_BRIDGE, info->nentries);\r\nreturn EBT_ENTRY_ITERATE(entries, size, compat_calc_entry, info,\r\nentries, newinfo);\r\n}\r\nstatic int compat_copy_everything_to_user(struct ebt_table *t,\r\nvoid __user *user, int *len, int cmd)\r\n{\r\nstruct compat_ebt_replace repl, tmp;\r\nstruct ebt_counter *oldcounters;\r\nstruct ebt_table_info tinfo;\r\nint ret;\r\nvoid __user *pos;\r\nmemset(&tinfo, 0, sizeof(tinfo));\r\nif (cmd == EBT_SO_GET_ENTRIES) {\r\ntinfo.entries_size = t->private->entries_size;\r\ntinfo.nentries = t->private->nentries;\r\ntinfo.entries = t->private->entries;\r\noldcounters = t->private->counters;\r\n} else {\r\ntinfo.entries_size = t->table->entries_size;\r\ntinfo.nentries = t->table->nentries;\r\ntinfo.entries = t->table->entries;\r\noldcounters = t->table->counters;\r\n}\r\nif (copy_from_user(&tmp, user, sizeof(tmp)))\r\nreturn -EFAULT;\r\nif (tmp.nentries != tinfo.nentries ||\r\n(tmp.num_counters && tmp.num_counters != tinfo.nentries))\r\nreturn -EINVAL;\r\nmemcpy(&repl, &tmp, sizeof(repl));\r\nif (cmd == EBT_SO_GET_ENTRIES)\r\nret = compat_table_info(t->private, &repl);\r\nelse\r\nret = compat_table_info(&tinfo, &repl);\r\nif (ret)\r\nreturn ret;\r\nif (*len != sizeof(tmp) + repl.entries_size +\r\n(tmp.num_counters? tinfo.nentries * sizeof(struct ebt_counter): 0)) {\r\npr_err("wrong size: *len %d, entries_size %u, replsz %d\n",\r\n*len, tinfo.entries_size, repl.entries_size);\r\nreturn -EINVAL;\r\n}\r\nret = copy_counters_to_user(t, oldcounters, compat_ptr(tmp.counters),\r\ntmp.num_counters, tinfo.nentries);\r\nif (ret)\r\nreturn ret;\r\npos = compat_ptr(tmp.entries);\r\nreturn EBT_ENTRY_ITERATE(tinfo.entries, tinfo.entries_size,\r\ncompat_copy_entry_to_user, &pos, &tmp.entries_size);\r\n}\r\nstatic int ebt_buf_count(struct ebt_entries_buf_state *state, unsigned int sz)\r\n{\r\nstate->buf_kern_offset += sz;\r\nreturn state->buf_kern_offset >= sz ? 0 : -EINVAL;\r\n}\r\nstatic int ebt_buf_add(struct ebt_entries_buf_state *state,\r\nvoid *data, unsigned int sz)\r\n{\r\nif (state->buf_kern_start == NULL)\r\ngoto count_only;\r\nBUG_ON(state->buf_kern_offset + sz > state->buf_kern_len);\r\nmemcpy(state->buf_kern_start + state->buf_kern_offset, data, sz);\r\ncount_only:\r\nstate->buf_user_offset += sz;\r\nreturn ebt_buf_count(state, sz);\r\n}\r\nstatic int ebt_buf_add_pad(struct ebt_entries_buf_state *state, unsigned int sz)\r\n{\r\nchar *b = state->buf_kern_start;\r\nBUG_ON(b && state->buf_kern_offset > state->buf_kern_len);\r\nif (b != NULL && sz > 0)\r\nmemset(b + state->buf_kern_offset, 0, sz);\r\nreturn ebt_buf_count(state, sz);\r\n}\r\nstatic int compat_mtw_from_user(struct compat_ebt_entry_mwt *mwt,\r\nenum compat_mwt compat_mwt,\r\nstruct ebt_entries_buf_state *state,\r\nconst unsigned char *base)\r\n{\r\nchar name[EBT_FUNCTION_MAXNAMELEN];\r\nstruct xt_match *match;\r\nstruct xt_target *wt;\r\nvoid *dst = NULL;\r\nint off, pad = 0;\r\nunsigned int size_kern, match_size = mwt->match_size;\r\nstrlcpy(name, mwt->u.name, sizeof(name));\r\nif (state->buf_kern_start)\r\ndst = state->buf_kern_start + state->buf_kern_offset;\r\nswitch (compat_mwt) {\r\ncase EBT_COMPAT_MATCH:\r\nmatch = xt_request_find_match(NFPROTO_BRIDGE, name, 0);\r\nif (IS_ERR(match))\r\nreturn PTR_ERR(match);\r\noff = ebt_compat_match_offset(match, match_size);\r\nif (dst) {\r\nif (match->compat_from_user)\r\nmatch->compat_from_user(dst, mwt->data);\r\nelse\r\nmemcpy(dst, mwt->data, match_size);\r\n}\r\nsize_kern = match->matchsize;\r\nif (unlikely(size_kern == -1))\r\nsize_kern = match_size;\r\nmodule_put(match->me);\r\nbreak;\r\ncase EBT_COMPAT_WATCHER:\r\ncase EBT_COMPAT_TARGET:\r\nwt = xt_request_find_target(NFPROTO_BRIDGE, name, 0);\r\nif (IS_ERR(wt))\r\nreturn PTR_ERR(wt);\r\noff = xt_compat_target_offset(wt);\r\nif (dst) {\r\nif (wt->compat_from_user)\r\nwt->compat_from_user(dst, mwt->data);\r\nelse\r\nmemcpy(dst, mwt->data, match_size);\r\n}\r\nsize_kern = wt->targetsize;\r\nmodule_put(wt->me);\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nstate->buf_kern_offset += match_size + off;\r\nstate->buf_user_offset += match_size;\r\npad = XT_ALIGN(size_kern) - size_kern;\r\nif (pad > 0 && dst) {\r\nBUG_ON(state->buf_kern_len <= pad);\r\nBUG_ON(state->buf_kern_offset - (match_size + off) + size_kern > state->buf_kern_len - pad);\r\nmemset(dst + size_kern, 0, pad);\r\n}\r\nreturn off + match_size;\r\n}\r\nstatic int ebt_size_mwt(struct compat_ebt_entry_mwt *match32,\r\nunsigned int size_left, enum compat_mwt type,\r\nstruct ebt_entries_buf_state *state, const void *base)\r\n{\r\nint growth = 0;\r\nchar *buf;\r\nif (size_left == 0)\r\nreturn 0;\r\nbuf = (char *) match32;\r\nwhile (size_left >= sizeof(*match32)) {\r\nstruct ebt_entry_match *match_kern;\r\nint ret;\r\nmatch_kern = (struct ebt_entry_match *) state->buf_kern_start;\r\nif (match_kern) {\r\nchar *tmp;\r\ntmp = state->buf_kern_start + state->buf_kern_offset;\r\nmatch_kern = (struct ebt_entry_match *) tmp;\r\n}\r\nret = ebt_buf_add(state, buf, sizeof(*match32));\r\nif (ret < 0)\r\nreturn ret;\r\nsize_left -= sizeof(*match32);\r\nret = ebt_buf_add_pad(state, ebt_compat_entry_padsize());\r\nif (ret < 0)\r\nreturn ret;\r\nif (match32->match_size > size_left)\r\nreturn -EINVAL;\r\nsize_left -= match32->match_size;\r\nret = compat_mtw_from_user(match32, type, state, base);\r\nif (ret < 0)\r\nreturn ret;\r\nBUG_ON(ret < match32->match_size);\r\ngrowth += ret - match32->match_size;\r\ngrowth += ebt_compat_entry_padsize();\r\nbuf += sizeof(*match32);\r\nbuf += match32->match_size;\r\nif (match_kern)\r\nmatch_kern->match_size = ret;\r\nWARN_ON(type == EBT_COMPAT_TARGET && size_left);\r\nmatch32 = (struct compat_ebt_entry_mwt *) buf;\r\n}\r\nreturn growth;\r\n}\r\nstatic int size_entry_mwt(struct ebt_entry *entry, const unsigned char *base,\r\nunsigned int *total,\r\nstruct ebt_entries_buf_state *state)\r\n{\r\nunsigned int i, j, startoff, new_offset = 0;\r\nunsigned int offsets[4];\r\nunsigned int *offsets_update = NULL;\r\nint ret;\r\nchar *buf_start;\r\nif (*total < sizeof(struct ebt_entries))\r\nreturn -EINVAL;\r\nif (!entry->bitmask) {\r\n*total -= sizeof(struct ebt_entries);\r\nreturn ebt_buf_add(state, entry, sizeof(struct ebt_entries));\r\n}\r\nif (*total < sizeof(*entry) || entry->next_offset < sizeof(*entry))\r\nreturn -EINVAL;\r\nstartoff = state->buf_user_offset;\r\nret = ebt_buf_add(state, entry,\r\noffsetof(struct ebt_entry, watchers_offset));\r\nif (ret < 0)\r\nreturn ret;\r\noffsets[0] = sizeof(struct ebt_entry);\r\nmemcpy(&offsets[1], &entry->watchers_offset,\r\nsizeof(offsets) - sizeof(offsets[0]));\r\nif (state->buf_kern_start) {\r\nbuf_start = state->buf_kern_start + state->buf_kern_offset;\r\noffsets_update = (unsigned int *) buf_start;\r\n}\r\nret = ebt_buf_add(state, &offsets[1],\r\nsizeof(offsets) - sizeof(offsets[0]));\r\nif (ret < 0)\r\nreturn ret;\r\nbuf_start = (char *) entry;\r\nfor (i = 0, j = 1 ; j < 4 ; j++, i++) {\r\nstruct compat_ebt_entry_mwt *match32;\r\nunsigned int size;\r\nchar *buf = buf_start;\r\nbuf = buf_start + offsets[i];\r\nif (offsets[i] > offsets[j])\r\nreturn -EINVAL;\r\nmatch32 = (struct compat_ebt_entry_mwt *) buf;\r\nsize = offsets[j] - offsets[i];\r\nret = ebt_size_mwt(match32, size, i, state, base);\r\nif (ret < 0)\r\nreturn ret;\r\nnew_offset += ret;\r\nif (offsets_update && new_offset) {\r\npr_debug("change offset %d to %d\n",\r\noffsets_update[i], offsets[j] + new_offset);\r\noffsets_update[i] = offsets[j] + new_offset;\r\n}\r\n}\r\nif (state->buf_kern_start == NULL) {\r\nunsigned int offset = buf_start - (char *) base;\r\nret = xt_compat_add_offset(NFPROTO_BRIDGE, offset, new_offset);\r\nif (ret < 0)\r\nreturn ret;\r\n}\r\nstartoff = state->buf_user_offset - startoff;\r\nBUG_ON(*total < startoff);\r\n*total -= startoff;\r\nreturn 0;\r\n}\r\nstatic int compat_copy_entries(unsigned char *data, unsigned int size_user,\r\nstruct ebt_entries_buf_state *state)\r\n{\r\nunsigned int size_remaining = size_user;\r\nint ret;\r\nret = EBT_ENTRY_ITERATE(data, size_user, size_entry_mwt, data,\r\n&size_remaining, state);\r\nif (ret < 0)\r\nreturn ret;\r\nWARN_ON(size_remaining);\r\nreturn state->buf_kern_offset;\r\n}\r\nstatic int compat_copy_ebt_replace_from_user(struct ebt_replace *repl,\r\nvoid __user *user, unsigned int len)\r\n{\r\nstruct compat_ebt_replace tmp;\r\nint i;\r\nif (len < sizeof(tmp))\r\nreturn -EINVAL;\r\nif (copy_from_user(&tmp, user, sizeof(tmp)))\r\nreturn -EFAULT;\r\nif (len != sizeof(tmp) + tmp.entries_size)\r\nreturn -EINVAL;\r\nif (tmp.entries_size == 0)\r\nreturn -EINVAL;\r\nif (tmp.nentries >= ((INT_MAX - sizeof(struct ebt_table_info)) /\r\nNR_CPUS - SMP_CACHE_BYTES) / sizeof(struct ebt_counter))\r\nreturn -ENOMEM;\r\nif (tmp.num_counters >= INT_MAX / sizeof(struct ebt_counter))\r\nreturn -ENOMEM;\r\nmemcpy(repl, &tmp, offsetof(struct ebt_replace, hook_entry));\r\nfor (i = 0; i < NF_BR_NUMHOOKS; i++)\r\nrepl->hook_entry[i] = compat_ptr(tmp.hook_entry[i]);\r\nrepl->num_counters = tmp.num_counters;\r\nrepl->counters = compat_ptr(tmp.counters);\r\nrepl->entries = compat_ptr(tmp.entries);\r\nreturn 0;\r\n}\r\nstatic int compat_do_replace(struct net *net, void __user *user,\r\nunsigned int len)\r\n{\r\nint ret, i, countersize, size64;\r\nstruct ebt_table_info *newinfo;\r\nstruct ebt_replace tmp;\r\nstruct ebt_entries_buf_state state;\r\nvoid *entries_tmp;\r\nret = compat_copy_ebt_replace_from_user(&tmp, user, len);\r\nif (ret) {\r\nif (ret == -EINVAL && do_replace(net, user, len) == 0)\r\nret = 0;\r\nreturn ret;\r\n}\r\ncountersize = COUNTER_OFFSET(tmp.nentries) * nr_cpu_ids;\r\nnewinfo = vmalloc(sizeof(*newinfo) + countersize);\r\nif (!newinfo)\r\nreturn -ENOMEM;\r\nif (countersize)\r\nmemset(newinfo->counters, 0, countersize);\r\nmemset(&state, 0, sizeof(state));\r\nnewinfo->entries = vmalloc(tmp.entries_size);\r\nif (!newinfo->entries) {\r\nret = -ENOMEM;\r\ngoto free_newinfo;\r\n}\r\nif (copy_from_user(\r\nnewinfo->entries, tmp.entries, tmp.entries_size) != 0) {\r\nret = -EFAULT;\r\ngoto free_entries;\r\n}\r\nentries_tmp = newinfo->entries;\r\nxt_compat_lock(NFPROTO_BRIDGE);\r\nxt_compat_init_offsets(NFPROTO_BRIDGE, tmp.nentries);\r\nret = compat_copy_entries(entries_tmp, tmp.entries_size, &state);\r\nif (ret < 0)\r\ngoto out_unlock;\r\npr_debug("tmp.entries_size %d, kern off %d, user off %d delta %d\n",\r\ntmp.entries_size, state.buf_kern_offset, state.buf_user_offset,\r\nxt_compat_calc_jump(NFPROTO_BRIDGE, tmp.entries_size));\r\nsize64 = ret;\r\nnewinfo->entries = vmalloc(size64);\r\nif (!newinfo->entries) {\r\nvfree(entries_tmp);\r\nret = -ENOMEM;\r\ngoto out_unlock;\r\n}\r\nmemset(&state, 0, sizeof(state));\r\nstate.buf_kern_start = newinfo->entries;\r\nstate.buf_kern_len = size64;\r\nret = compat_copy_entries(entries_tmp, tmp.entries_size, &state);\r\nBUG_ON(ret < 0);\r\nvfree(entries_tmp);\r\ntmp.entries_size = size64;\r\nfor (i = 0; i < NF_BR_NUMHOOKS; i++) {\r\nchar __user *usrptr;\r\nif (tmp.hook_entry[i]) {\r\nunsigned int delta;\r\nusrptr = (char __user *) tmp.hook_entry[i];\r\ndelta = usrptr - tmp.entries;\r\nusrptr += xt_compat_calc_jump(NFPROTO_BRIDGE, delta);\r\ntmp.hook_entry[i] = (struct ebt_entries __user *)usrptr;\r\n}\r\n}\r\nxt_compat_flush_offsets(NFPROTO_BRIDGE);\r\nxt_compat_unlock(NFPROTO_BRIDGE);\r\nret = do_replace_finish(net, &tmp, newinfo);\r\nif (ret == 0)\r\nreturn ret;\r\nfree_entries:\r\nvfree(newinfo->entries);\r\nfree_newinfo:\r\nvfree(newinfo);\r\nreturn ret;\r\nout_unlock:\r\nxt_compat_flush_offsets(NFPROTO_BRIDGE);\r\nxt_compat_unlock(NFPROTO_BRIDGE);\r\ngoto free_entries;\r\n}\r\nstatic int compat_update_counters(struct net *net, void __user *user,\r\nunsigned int len)\r\n{\r\nstruct compat_ebt_replace hlp;\r\nif (copy_from_user(&hlp, user, sizeof(hlp)))\r\nreturn -EFAULT;\r\nif (len != sizeof(hlp) + hlp.num_counters * sizeof(struct ebt_counter))\r\nreturn update_counters(net, user, len);\r\nreturn do_update_counters(net, hlp.name, compat_ptr(hlp.counters),\r\nhlp.num_counters, user, len);\r\n}\r\nstatic int compat_do_ebt_set_ctl(struct sock *sk,\r\nint cmd, void __user *user, unsigned int len)\r\n{\r\nint ret;\r\nstruct net *net = sock_net(sk);\r\nif (!ns_capable(net->user_ns, CAP_NET_ADMIN))\r\nreturn -EPERM;\r\nswitch (cmd) {\r\ncase EBT_SO_SET_ENTRIES:\r\nret = compat_do_replace(net, user, len);\r\nbreak;\r\ncase EBT_SO_SET_COUNTERS:\r\nret = compat_update_counters(net, user, len);\r\nbreak;\r\ndefault:\r\nret = -EINVAL;\r\n}\r\nreturn ret;\r\n}\r\nstatic int compat_do_ebt_get_ctl(struct sock *sk, int cmd,\r\nvoid __user *user, int *len)\r\n{\r\nint ret;\r\nstruct compat_ebt_replace tmp;\r\nstruct ebt_table *t;\r\nstruct net *net = sock_net(sk);\r\nif (!ns_capable(net->user_ns, CAP_NET_ADMIN))\r\nreturn -EPERM;\r\nif ((cmd == EBT_SO_GET_INFO ||\r\ncmd == EBT_SO_GET_INIT_INFO) && *len != sizeof(tmp))\r\nreturn do_ebt_get_ctl(sk, cmd, user, len);\r\nif (copy_from_user(&tmp, user, sizeof(tmp)))\r\nreturn -EFAULT;\r\ntmp.name[sizeof(tmp.name) - 1] = '\0';\r\nt = find_table_lock(net, tmp.name, &ret, &ebt_mutex);\r\nif (!t)\r\nreturn ret;\r\nxt_compat_lock(NFPROTO_BRIDGE);\r\nswitch (cmd) {\r\ncase EBT_SO_GET_INFO:\r\ntmp.nentries = t->private->nentries;\r\nret = compat_table_info(t->private, &tmp);\r\nif (ret)\r\ngoto out;\r\ntmp.valid_hooks = t->valid_hooks;\r\nif (copy_to_user(user, &tmp, *len) != 0) {\r\nret = -EFAULT;\r\nbreak;\r\n}\r\nret = 0;\r\nbreak;\r\ncase EBT_SO_GET_INIT_INFO:\r\ntmp.nentries = t->table->nentries;\r\ntmp.entries_size = t->table->entries_size;\r\ntmp.valid_hooks = t->table->valid_hooks;\r\nif (copy_to_user(user, &tmp, *len) != 0) {\r\nret = -EFAULT;\r\nbreak;\r\n}\r\nret = 0;\r\nbreak;\r\ncase EBT_SO_GET_ENTRIES:\r\ncase EBT_SO_GET_INIT_ENTRIES:\r\nif (copy_everything_to_user(t, user, len, cmd) == 0)\r\nret = 0;\r\nelse\r\nret = compat_copy_everything_to_user(t, user, len, cmd);\r\nbreak;\r\ndefault:\r\nret = -EINVAL;\r\n}\r\nout:\r\nxt_compat_flush_offsets(NFPROTO_BRIDGE);\r\nxt_compat_unlock(NFPROTO_BRIDGE);\r\nmutex_unlock(&ebt_mutex);\r\nreturn ret;\r\n}\r\nstatic int __init ebtables_init(void)\r\n{\r\nint ret;\r\nret = xt_register_target(&ebt_standard_target);\r\nif (ret < 0)\r\nreturn ret;\r\nret = nf_register_sockopt(&ebt_sockopts);\r\nif (ret < 0) {\r\nxt_unregister_target(&ebt_standard_target);\r\nreturn ret;\r\n}\r\nprintk(KERN_INFO "Ebtables v2.0 registered\n");\r\nreturn 0;\r\n}\r\nstatic void __exit ebtables_fini(void)\r\n{\r\nnf_unregister_sockopt(&ebt_sockopts);\r\nxt_unregister_target(&ebt_standard_target);\r\nprintk(KERN_INFO "Ebtables v2.0 unregistered\n");\r\n}
