static void cdns_i2c_clear_bus_hold(struct cdns_i2c *id)\r\n{\r\nu32 reg = cdns_i2c_readreg(CDNS_I2C_CR_OFFSET);\r\nif (reg & CDNS_I2C_CR_HOLD)\r\ncdns_i2c_writereg(reg & ~CDNS_I2C_CR_HOLD, CDNS_I2C_CR_OFFSET);\r\n}\r\nstatic inline bool cdns_is_holdquirk(struct cdns_i2c *id, bool hold_wrkaround)\r\n{\r\nreturn (hold_wrkaround &&\r\n(id->curr_recv_count == CDNS_I2C_FIFO_DEPTH + 1));\r\n}\r\nstatic irqreturn_t cdns_i2c_isr(int irq, void *ptr)\r\n{\r\nunsigned int isr_status, avail_bytes, updatetx;\r\nunsigned int bytes_to_send;\r\nbool hold_quirk;\r\nstruct cdns_i2c *id = ptr;\r\nint done_flag = 0;\r\nirqreturn_t status = IRQ_NONE;\r\nisr_status = cdns_i2c_readreg(CDNS_I2C_ISR_OFFSET);\r\ncdns_i2c_writereg(isr_status, CDNS_I2C_ISR_OFFSET);\r\nif (isr_status & (CDNS_I2C_IXR_NACK | CDNS_I2C_IXR_ARB_LOST)) {\r\ndone_flag = 1;\r\nstatus = IRQ_HANDLED;\r\n}\r\nupdatetx = 0;\r\nif (id->recv_count > id->curr_recv_count)\r\nupdatetx = 1;\r\nhold_quirk = (id->quirks & CDNS_I2C_BROKEN_HOLD_BIT) && updatetx;\r\nif (id->p_recv_buf &&\r\n((isr_status & CDNS_I2C_IXR_COMP) ||\r\n(isr_status & CDNS_I2C_IXR_DATA))) {\r\nwhile (cdns_i2c_readreg(CDNS_I2C_SR_OFFSET) &\r\nCDNS_I2C_SR_RXDV) {\r\nif ((id->recv_count < CDNS_I2C_FIFO_DEPTH) &&\r\n!id->bus_hold_flag)\r\ncdns_i2c_clear_bus_hold(id);\r\n*(id->p_recv_buf)++ =\r\ncdns_i2c_readreg(CDNS_I2C_DATA_OFFSET);\r\nid->recv_count--;\r\nid->curr_recv_count--;\r\nif (cdns_is_holdquirk(id, hold_quirk))\r\nbreak;\r\n}\r\nif (cdns_is_holdquirk(id, hold_quirk)) {\r\nwhile (cdns_i2c_readreg(CDNS_I2C_XFER_SIZE_OFFSET) !=\r\n(id->curr_recv_count - CDNS_I2C_FIFO_DEPTH))\r\n;\r\nif (((int)(id->recv_count) - CDNS_I2C_FIFO_DEPTH) >\r\nCDNS_I2C_TRANSFER_SIZE) {\r\ncdns_i2c_writereg(CDNS_I2C_TRANSFER_SIZE,\r\nCDNS_I2C_XFER_SIZE_OFFSET);\r\nid->curr_recv_count = CDNS_I2C_TRANSFER_SIZE +\r\nCDNS_I2C_FIFO_DEPTH;\r\n} else {\r\ncdns_i2c_writereg(id->recv_count -\r\nCDNS_I2C_FIFO_DEPTH,\r\nCDNS_I2C_XFER_SIZE_OFFSET);\r\nid->curr_recv_count = id->recv_count;\r\n}\r\n} else if (id->recv_count && !hold_quirk &&\r\n!id->curr_recv_count) {\r\ncdns_i2c_writereg(id->p_msg->addr & CDNS_I2C_ADDR_MASK,\r\nCDNS_I2C_ADDR_OFFSET);\r\nif (id->recv_count > CDNS_I2C_TRANSFER_SIZE) {\r\ncdns_i2c_writereg(CDNS_I2C_TRANSFER_SIZE,\r\nCDNS_I2C_XFER_SIZE_OFFSET);\r\nid->curr_recv_count = CDNS_I2C_TRANSFER_SIZE;\r\n} else {\r\ncdns_i2c_writereg(id->recv_count,\r\nCDNS_I2C_XFER_SIZE_OFFSET);\r\nid->curr_recv_count = id->recv_count;\r\n}\r\n}\r\nif ((isr_status & CDNS_I2C_IXR_COMP) && !id->recv_count) {\r\nif (!id->bus_hold_flag)\r\ncdns_i2c_clear_bus_hold(id);\r\ndone_flag = 1;\r\n}\r\nstatus = IRQ_HANDLED;\r\n}\r\nif ((isr_status & CDNS_I2C_IXR_COMP) && !id->p_recv_buf) {\r\nif (id->send_count) {\r\navail_bytes = CDNS_I2C_FIFO_DEPTH -\r\ncdns_i2c_readreg(CDNS_I2C_XFER_SIZE_OFFSET);\r\nif (id->send_count > avail_bytes)\r\nbytes_to_send = avail_bytes;\r\nelse\r\nbytes_to_send = id->send_count;\r\nwhile (bytes_to_send--) {\r\ncdns_i2c_writereg(\r\n(*(id->p_send_buf)++),\r\nCDNS_I2C_DATA_OFFSET);\r\nid->send_count--;\r\n}\r\n} else {\r\ndone_flag = 1;\r\n}\r\nif (!id->send_count && !id->bus_hold_flag)\r\ncdns_i2c_clear_bus_hold(id);\r\nstatus = IRQ_HANDLED;\r\n}\r\nid->err_status = isr_status & CDNS_I2C_IXR_ERR_INTR_MASK;\r\nif (id->err_status)\r\nstatus = IRQ_HANDLED;\r\nif (done_flag)\r\ncomplete(&id->xfer_done);\r\nreturn status;\r\n}\r\nstatic void cdns_i2c_mrecv(struct cdns_i2c *id)\r\n{\r\nunsigned int ctrl_reg;\r\nunsigned int isr_status;\r\nid->p_recv_buf = id->p_msg->buf;\r\nid->recv_count = id->p_msg->len;\r\nctrl_reg = cdns_i2c_readreg(CDNS_I2C_CR_OFFSET);\r\nctrl_reg |= CDNS_I2C_CR_RW | CDNS_I2C_CR_CLR_FIFO;\r\nif (id->p_msg->flags & I2C_M_RECV_LEN)\r\nid->recv_count = I2C_SMBUS_BLOCK_MAX + 1;\r\nid->curr_recv_count = id->recv_count;\r\nif (id->recv_count > CDNS_I2C_FIFO_DEPTH)\r\nctrl_reg |= CDNS_I2C_CR_HOLD;\r\ncdns_i2c_writereg(ctrl_reg, CDNS_I2C_CR_OFFSET);\r\nisr_status = cdns_i2c_readreg(CDNS_I2C_ISR_OFFSET);\r\ncdns_i2c_writereg(isr_status, CDNS_I2C_ISR_OFFSET);\r\nif (id->recv_count > CDNS_I2C_TRANSFER_SIZE) {\r\ncdns_i2c_writereg(CDNS_I2C_TRANSFER_SIZE,\r\nCDNS_I2C_XFER_SIZE_OFFSET);\r\nid->curr_recv_count = CDNS_I2C_TRANSFER_SIZE;\r\n} else {\r\ncdns_i2c_writereg(id->recv_count, CDNS_I2C_XFER_SIZE_OFFSET);\r\n}\r\nif (!id->bus_hold_flag &&\r\n((id->p_msg->flags & I2C_M_RECV_LEN) != I2C_M_RECV_LEN) &&\r\n(id->recv_count <= CDNS_I2C_FIFO_DEPTH))\r\ncdns_i2c_clear_bus_hold(id);\r\ncdns_i2c_writereg(id->p_msg->addr & CDNS_I2C_ADDR_MASK,\r\nCDNS_I2C_ADDR_OFFSET);\r\ncdns_i2c_writereg(CDNS_I2C_ENABLED_INTR_MASK, CDNS_I2C_IER_OFFSET);\r\n}\r\nstatic void cdns_i2c_msend(struct cdns_i2c *id)\r\n{\r\nunsigned int avail_bytes;\r\nunsigned int bytes_to_send;\r\nunsigned int ctrl_reg;\r\nunsigned int isr_status;\r\nid->p_recv_buf = NULL;\r\nid->p_send_buf = id->p_msg->buf;\r\nid->send_count = id->p_msg->len;\r\nctrl_reg = cdns_i2c_readreg(CDNS_I2C_CR_OFFSET);\r\nctrl_reg &= ~CDNS_I2C_CR_RW;\r\nctrl_reg |= CDNS_I2C_CR_CLR_FIFO;\r\nif (id->send_count > CDNS_I2C_FIFO_DEPTH)\r\nctrl_reg |= CDNS_I2C_CR_HOLD;\r\ncdns_i2c_writereg(ctrl_reg, CDNS_I2C_CR_OFFSET);\r\nisr_status = cdns_i2c_readreg(CDNS_I2C_ISR_OFFSET);\r\ncdns_i2c_writereg(isr_status, CDNS_I2C_ISR_OFFSET);\r\navail_bytes = CDNS_I2C_FIFO_DEPTH -\r\ncdns_i2c_readreg(CDNS_I2C_XFER_SIZE_OFFSET);\r\nif (id->send_count > avail_bytes)\r\nbytes_to_send = avail_bytes;\r\nelse\r\nbytes_to_send = id->send_count;\r\nwhile (bytes_to_send--) {\r\ncdns_i2c_writereg((*(id->p_send_buf)++), CDNS_I2C_DATA_OFFSET);\r\nid->send_count--;\r\n}\r\nif (!id->bus_hold_flag && !id->send_count)\r\ncdns_i2c_clear_bus_hold(id);\r\ncdns_i2c_writereg(id->p_msg->addr & CDNS_I2C_ADDR_MASK,\r\nCDNS_I2C_ADDR_OFFSET);\r\ncdns_i2c_writereg(CDNS_I2C_ENABLED_INTR_MASK, CDNS_I2C_IER_OFFSET);\r\n}\r\nstatic void cdns_i2c_master_reset(struct i2c_adapter *adap)\r\n{\r\nstruct cdns_i2c *id = adap->algo_data;\r\nu32 regval;\r\ncdns_i2c_writereg(CDNS_I2C_IXR_ALL_INTR_MASK, CDNS_I2C_IDR_OFFSET);\r\nregval = cdns_i2c_readreg(CDNS_I2C_CR_OFFSET);\r\nregval &= ~CDNS_I2C_CR_HOLD;\r\nregval |= CDNS_I2C_CR_CLR_FIFO;\r\ncdns_i2c_writereg(regval, CDNS_I2C_CR_OFFSET);\r\ncdns_i2c_writereg(0, CDNS_I2C_XFER_SIZE_OFFSET);\r\nregval = cdns_i2c_readreg(CDNS_I2C_ISR_OFFSET);\r\ncdns_i2c_writereg(regval, CDNS_I2C_ISR_OFFSET);\r\nregval = cdns_i2c_readreg(CDNS_I2C_SR_OFFSET);\r\ncdns_i2c_writereg(regval, CDNS_I2C_SR_OFFSET);\r\n}\r\nstatic int cdns_i2c_process_msg(struct cdns_i2c *id, struct i2c_msg *msg,\r\nstruct i2c_adapter *adap)\r\n{\r\nunsigned long time_left;\r\nu32 reg;\r\nid->p_msg = msg;\r\nid->err_status = 0;\r\nreinit_completion(&id->xfer_done);\r\nreg = cdns_i2c_readreg(CDNS_I2C_CR_OFFSET);\r\nif (msg->flags & I2C_M_TEN) {\r\nif (reg & CDNS_I2C_CR_NEA)\r\ncdns_i2c_writereg(reg & ~CDNS_I2C_CR_NEA,\r\nCDNS_I2C_CR_OFFSET);\r\n} else {\r\nif (!(reg & CDNS_I2C_CR_NEA))\r\ncdns_i2c_writereg(reg | CDNS_I2C_CR_NEA,\r\nCDNS_I2C_CR_OFFSET);\r\n}\r\nif (msg->flags & I2C_M_RD)\r\ncdns_i2c_mrecv(id);\r\nelse\r\ncdns_i2c_msend(id);\r\ntime_left = wait_for_completion_timeout(&id->xfer_done, adap->timeout);\r\nif (time_left == 0) {\r\ncdns_i2c_master_reset(adap);\r\ndev_err(id->adap.dev.parent,\r\n"timeout waiting on completion\n");\r\nreturn -ETIMEDOUT;\r\n}\r\ncdns_i2c_writereg(CDNS_I2C_IXR_ALL_INTR_MASK,\r\nCDNS_I2C_IDR_OFFSET);\r\nif (id->err_status & CDNS_I2C_IXR_ARB_LOST)\r\nreturn -EAGAIN;\r\nreturn 0;\r\n}\r\nstatic int cdns_i2c_master_xfer(struct i2c_adapter *adap, struct i2c_msg *msgs,\r\nint num)\r\n{\r\nint ret, count;\r\nu32 reg;\r\nstruct cdns_i2c *id = adap->algo_data;\r\nbool hold_quirk;\r\nret = pm_runtime_get_sync(id->dev);\r\nif (ret < 0)\r\nreturn ret;\r\nif (cdns_i2c_readreg(CDNS_I2C_SR_OFFSET) & CDNS_I2C_SR_BA) {\r\nret = -EAGAIN;\r\ngoto out;\r\n}\r\nhold_quirk = !!(id->quirks & CDNS_I2C_BROKEN_HOLD_BIT);\r\nif (num > 1) {\r\nfor (count = 0; (count < num - 1 && hold_quirk); count++) {\r\nif (msgs[count].flags & I2C_M_RD) {\r\ndev_warn(adap->dev.parent,\r\n"Can't do repeated start after a receive message\n");\r\nret = -EOPNOTSUPP;\r\ngoto out;\r\n}\r\n}\r\nid->bus_hold_flag = 1;\r\nreg = cdns_i2c_readreg(CDNS_I2C_CR_OFFSET);\r\nreg |= CDNS_I2C_CR_HOLD;\r\ncdns_i2c_writereg(reg, CDNS_I2C_CR_OFFSET);\r\n} else {\r\nid->bus_hold_flag = 0;\r\n}\r\nfor (count = 0; count < num; count++, msgs++) {\r\nif (count == (num - 1))\r\nid->bus_hold_flag = 0;\r\nret = cdns_i2c_process_msg(id, msgs, adap);\r\nif (ret)\r\ngoto out;\r\nif (id->err_status) {\r\ncdns_i2c_master_reset(adap);\r\nif (id->err_status & CDNS_I2C_IXR_NACK) {\r\nret = -ENXIO;\r\ngoto out;\r\n}\r\nret = -EIO;\r\ngoto out;\r\n}\r\n}\r\nret = num;\r\nout:\r\npm_runtime_mark_last_busy(id->dev);\r\npm_runtime_put_autosuspend(id->dev);\r\nreturn ret;\r\n}\r\nstatic u32 cdns_i2c_func(struct i2c_adapter *adap)\r\n{\r\nreturn I2C_FUNC_I2C | I2C_FUNC_10BIT_ADDR |\r\n(I2C_FUNC_SMBUS_EMUL & ~I2C_FUNC_SMBUS_QUICK) |\r\nI2C_FUNC_SMBUS_BLOCK_DATA;\r\n}\r\nstatic int cdns_i2c_calc_divs(unsigned long *f, unsigned long input_clk,\r\nunsigned int *a, unsigned int *b)\r\n{\r\nunsigned long fscl = *f, best_fscl = *f, actual_fscl, temp;\r\nunsigned int div_a, div_b, calc_div_a = 0, calc_div_b = 0;\r\nunsigned int last_error, current_error;\r\ntemp = input_clk / (22 * fscl);\r\nif (!temp || (temp > (CDNS_I2C_DIVA_MAX * CDNS_I2C_DIVB_MAX)))\r\nreturn -EINVAL;\r\nlast_error = -1;\r\nfor (div_a = 0; div_a < CDNS_I2C_DIVA_MAX; div_a++) {\r\ndiv_b = DIV_ROUND_UP(input_clk, 22 * fscl * (div_a + 1));\r\nif ((div_b < 1) || (div_b > CDNS_I2C_DIVB_MAX))\r\ncontinue;\r\ndiv_b--;\r\nactual_fscl = input_clk / (22 * (div_a + 1) * (div_b + 1));\r\nif (actual_fscl > fscl)\r\ncontinue;\r\ncurrent_error = ((actual_fscl > fscl) ? (actual_fscl - fscl) :\r\n(fscl - actual_fscl));\r\nif (last_error > current_error) {\r\ncalc_div_a = div_a;\r\ncalc_div_b = div_b;\r\nbest_fscl = actual_fscl;\r\nlast_error = current_error;\r\n}\r\n}\r\n*a = calc_div_a;\r\n*b = calc_div_b;\r\n*f = best_fscl;\r\nreturn 0;\r\n}\r\nstatic int cdns_i2c_setclk(unsigned long clk_in, struct cdns_i2c *id)\r\n{\r\nunsigned int div_a, div_b;\r\nunsigned int ctrl_reg;\r\nint ret = 0;\r\nunsigned long fscl = id->i2c_clk;\r\nret = cdns_i2c_calc_divs(&fscl, clk_in, &div_a, &div_b);\r\nif (ret)\r\nreturn ret;\r\nctrl_reg = cdns_i2c_readreg(CDNS_I2C_CR_OFFSET);\r\nctrl_reg &= ~(CDNS_I2C_CR_DIVA_MASK | CDNS_I2C_CR_DIVB_MASK);\r\nctrl_reg |= ((div_a << CDNS_I2C_CR_DIVA_SHIFT) |\r\n(div_b << CDNS_I2C_CR_DIVB_SHIFT));\r\ncdns_i2c_writereg(ctrl_reg, CDNS_I2C_CR_OFFSET);\r\nreturn 0;\r\n}\r\nstatic int cdns_i2c_clk_notifier_cb(struct notifier_block *nb, unsigned long\r\nevent, void *data)\r\n{\r\nstruct clk_notifier_data *ndata = data;\r\nstruct cdns_i2c *id = to_cdns_i2c(nb);\r\nif (pm_runtime_suspended(id->dev))\r\nreturn NOTIFY_OK;\r\nswitch (event) {\r\ncase PRE_RATE_CHANGE:\r\n{\r\nunsigned long input_clk = ndata->new_rate;\r\nunsigned long fscl = id->i2c_clk;\r\nunsigned int div_a, div_b;\r\nint ret;\r\nret = cdns_i2c_calc_divs(&fscl, input_clk, &div_a, &div_b);\r\nif (ret) {\r\ndev_warn(id->adap.dev.parent,\r\n"clock rate change rejected\n");\r\nreturn NOTIFY_STOP;\r\n}\r\nif (ndata->new_rate > ndata->old_rate)\r\ncdns_i2c_setclk(ndata->new_rate, id);\r\nreturn NOTIFY_OK;\r\n}\r\ncase POST_RATE_CHANGE:\r\nid->input_clk = ndata->new_rate;\r\nif (ndata->new_rate < ndata->old_rate)\r\ncdns_i2c_setclk(ndata->new_rate, id);\r\nreturn NOTIFY_OK;\r\ncase ABORT_RATE_CHANGE:\r\nif (ndata->new_rate > ndata->old_rate)\r\ncdns_i2c_setclk(ndata->old_rate, id);\r\nreturn NOTIFY_OK;\r\ndefault:\r\nreturn NOTIFY_DONE;\r\n}\r\n}\r\nstatic int __maybe_unused cdns_i2c_runtime_suspend(struct device *dev)\r\n{\r\nstruct platform_device *pdev = to_platform_device(dev);\r\nstruct cdns_i2c *xi2c = platform_get_drvdata(pdev);\r\nclk_disable(xi2c->clk);\r\nreturn 0;\r\n}\r\nstatic int __maybe_unused cdns_i2c_runtime_resume(struct device *dev)\r\n{\r\nstruct platform_device *pdev = to_platform_device(dev);\r\nstruct cdns_i2c *xi2c = platform_get_drvdata(pdev);\r\nint ret;\r\nret = clk_enable(xi2c->clk);\r\nif (ret) {\r\ndev_err(dev, "Cannot enable clock.\n");\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic int cdns_i2c_probe(struct platform_device *pdev)\r\n{\r\nstruct resource *r_mem;\r\nstruct cdns_i2c *id;\r\nint ret;\r\nconst struct of_device_id *match;\r\nid = devm_kzalloc(&pdev->dev, sizeof(*id), GFP_KERNEL);\r\nif (!id)\r\nreturn -ENOMEM;\r\nid->dev = &pdev->dev;\r\nplatform_set_drvdata(pdev, id);\r\nmatch = of_match_node(cdns_i2c_of_match, pdev->dev.of_node);\r\nif (match && match->data) {\r\nconst struct cdns_platform_data *data = match->data;\r\nid->quirks = data->quirks;\r\n}\r\nr_mem = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nid->membase = devm_ioremap_resource(&pdev->dev, r_mem);\r\nif (IS_ERR(id->membase))\r\nreturn PTR_ERR(id->membase);\r\nid->irq = platform_get_irq(pdev, 0);\r\nid->adap.owner = THIS_MODULE;\r\nid->adap.dev.of_node = pdev->dev.of_node;\r\nid->adap.algo = &cdns_i2c_algo;\r\nid->adap.timeout = CDNS_I2C_TIMEOUT;\r\nid->adap.retries = 3;\r\nid->adap.algo_data = id;\r\nid->adap.dev.parent = &pdev->dev;\r\ninit_completion(&id->xfer_done);\r\nsnprintf(id->adap.name, sizeof(id->adap.name),\r\n"Cadence I2C at %08lx", (unsigned long)r_mem->start);\r\nid->clk = devm_clk_get(&pdev->dev, NULL);\r\nif (IS_ERR(id->clk)) {\r\ndev_err(&pdev->dev, "input clock not found.\n");\r\nreturn PTR_ERR(id->clk);\r\n}\r\nret = clk_prepare_enable(id->clk);\r\nif (ret)\r\ndev_err(&pdev->dev, "Unable to enable clock.\n");\r\npm_runtime_enable(id->dev);\r\npm_runtime_set_autosuspend_delay(id->dev, CNDS_I2C_PM_TIMEOUT);\r\npm_runtime_use_autosuspend(id->dev);\r\npm_runtime_set_active(id->dev);\r\nid->clk_rate_change_nb.notifier_call = cdns_i2c_clk_notifier_cb;\r\nif (clk_notifier_register(id->clk, &id->clk_rate_change_nb))\r\ndev_warn(&pdev->dev, "Unable to register clock notifier.\n");\r\nid->input_clk = clk_get_rate(id->clk);\r\nret = of_property_read_u32(pdev->dev.of_node, "clock-frequency",\r\n&id->i2c_clk);\r\nif (ret || (id->i2c_clk > CDNS_I2C_SPEED_MAX))\r\nid->i2c_clk = CDNS_I2C_SPEED_DEFAULT;\r\ncdns_i2c_writereg(CDNS_I2C_CR_ACK_EN | CDNS_I2C_CR_NEA | CDNS_I2C_CR_MS,\r\nCDNS_I2C_CR_OFFSET);\r\nret = cdns_i2c_setclk(id->input_clk, id);\r\nif (ret) {\r\ndev_err(&pdev->dev, "invalid SCL clock: %u Hz\n", id->i2c_clk);\r\nret = -EINVAL;\r\ngoto err_clk_dis;\r\n}\r\nret = devm_request_irq(&pdev->dev, id->irq, cdns_i2c_isr, 0,\r\nDRIVER_NAME, id);\r\nif (ret) {\r\ndev_err(&pdev->dev, "cannot get irq %d\n", id->irq);\r\ngoto err_clk_dis;\r\n}\r\nret = i2c_add_adapter(&id->adap);\r\nif (ret < 0) {\r\ndev_err(&pdev->dev, "reg adap failed: %d\n", ret);\r\ngoto err_clk_dis;\r\n}\r\ncdns_i2c_writereg(CDNS_I2C_TIMEOUT_MAX, CDNS_I2C_TIME_OUT_OFFSET);\r\ndev_info(&pdev->dev, "%u kHz mmio %08lx irq %d\n",\r\nid->i2c_clk / 1000, (unsigned long)r_mem->start, id->irq);\r\nreturn 0;\r\nerr_clk_dis:\r\nclk_disable_unprepare(id->clk);\r\npm_runtime_set_suspended(&pdev->dev);\r\npm_runtime_disable(&pdev->dev);\r\nreturn ret;\r\n}\r\nstatic int cdns_i2c_remove(struct platform_device *pdev)\r\n{\r\nstruct cdns_i2c *id = platform_get_drvdata(pdev);\r\ni2c_del_adapter(&id->adap);\r\nclk_notifier_unregister(id->clk, &id->clk_rate_change_nb);\r\nclk_disable_unprepare(id->clk);\r\npm_runtime_disable(&pdev->dev);\r\nreturn 0;\r\n}
