static inline s32 nfhd_read_write(u32 major, u32 minor, u32 rwflag, u32 recno,\r\nu32 count, u32 buf)\r\n{\r\nreturn nf_call(nfhd_id + NFHD_READ_WRITE, major, minor, rwflag, recno,\r\ncount, buf);\r\n}\r\nstatic inline s32 nfhd_get_capacity(u32 major, u32 minor, u32 *blocks,\r\nu32 *blocksize)\r\n{\r\nreturn nf_call(nfhd_id + NFHD_GET_CAPACITY, major, minor,\r\nvirt_to_phys(blocks), virt_to_phys(blocksize));\r\n}\r\nstatic blk_qc_t nfhd_make_request(struct request_queue *queue, struct bio *bio)\r\n{\r\nstruct nfhd_device *dev = queue->queuedata;\r\nstruct bio_vec bvec;\r\nstruct bvec_iter iter;\r\nint dir, len, shift;\r\nsector_t sec = bio->bi_iter.bi_sector;\r\ndir = bio_data_dir(bio);\r\nshift = dev->bshift;\r\nbio_for_each_segment(bvec, bio, iter) {\r\nlen = bvec.bv_len;\r\nlen >>= 9;\r\nnfhd_read_write(dev->id, 0, dir, sec >> shift, len >> shift,\r\nbvec_to_phys(&bvec));\r\nsec += len;\r\n}\r\nbio_endio(bio);\r\nreturn BLK_QC_T_NONE;\r\n}\r\nstatic int nfhd_getgeo(struct block_device *bdev, struct hd_geometry *geo)\r\n{\r\nstruct nfhd_device *dev = bdev->bd_disk->private_data;\r\ngeo->cylinders = dev->blocks >> (6 - dev->bshift);\r\ngeo->heads = 4;\r\ngeo->sectors = 16;\r\nreturn 0;\r\n}\r\nstatic int __init nfhd_init_one(int id, u32 blocks, u32 bsize)\r\n{\r\nstruct nfhd_device *dev;\r\nint dev_id = id - NFHD_DEV_OFFSET;\r\npr_info("nfhd%u: found device with %u blocks (%u bytes)\n", dev_id,\r\nblocks, bsize);\r\nif (bsize < 512 || (bsize & (bsize - 1))) {\r\npr_warn("nfhd%u: invalid block size\n", dev_id);\r\nreturn -EINVAL;\r\n}\r\ndev = kmalloc(sizeof(struct nfhd_device), GFP_KERNEL);\r\nif (!dev)\r\ngoto out;\r\ndev->id = id;\r\ndev->blocks = blocks;\r\ndev->bsize = bsize;\r\ndev->bshift = ffs(bsize) - 10;\r\ndev->queue = blk_alloc_queue(GFP_KERNEL);\r\nif (dev->queue == NULL)\r\ngoto free_dev;\r\ndev->queue->queuedata = dev;\r\nblk_queue_make_request(dev->queue, nfhd_make_request);\r\nblk_queue_logical_block_size(dev->queue, bsize);\r\ndev->disk = alloc_disk(16);\r\nif (!dev->disk)\r\ngoto free_queue;\r\ndev->disk->major = major_num;\r\ndev->disk->first_minor = dev_id * 16;\r\ndev->disk->fops = &nfhd_ops;\r\ndev->disk->private_data = dev;\r\nsprintf(dev->disk->disk_name, "nfhd%u", dev_id);\r\nset_capacity(dev->disk, (sector_t)blocks * (bsize / 512));\r\ndev->disk->queue = dev->queue;\r\nadd_disk(dev->disk);\r\nlist_add_tail(&dev->list, &nfhd_list);\r\nreturn 0;\r\nfree_queue:\r\nblk_cleanup_queue(dev->queue);\r\nfree_dev:\r\nkfree(dev);\r\nout:\r\nreturn -ENOMEM;\r\n}\r\nstatic int __init nfhd_init(void)\r\n{\r\nu32 blocks, bsize;\r\nint i;\r\nnfhd_id = nf_get_id("XHDI");\r\nif (!nfhd_id)\r\nreturn -ENODEV;\r\nmajor_num = register_blkdev(major_num, "nfhd");\r\nif (major_num <= 0) {\r\npr_warn("nfhd: unable to get major number\n");\r\nreturn major_num;\r\n}\r\nfor (i = NFHD_DEV_OFFSET; i < 24; i++) {\r\nif (nfhd_get_capacity(i, 0, &blocks, &bsize))\r\ncontinue;\r\nnfhd_init_one(i, blocks, bsize);\r\n}\r\nreturn 0;\r\n}\r\nstatic void __exit nfhd_exit(void)\r\n{\r\nstruct nfhd_device *dev, *next;\r\nlist_for_each_entry_safe(dev, next, &nfhd_list, list) {\r\nlist_del(&dev->list);\r\ndel_gendisk(dev->disk);\r\nput_disk(dev->disk);\r\nblk_cleanup_queue(dev->queue);\r\nkfree(dev);\r\n}\r\nunregister_blkdev(major_num, "nfhd");\r\n}
