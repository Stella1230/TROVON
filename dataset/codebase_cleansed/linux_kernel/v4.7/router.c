int\r\nlnet_peer_buffer_credits(lnet_ni_t *ni)\r\n{\r\nif (ni->ni_peerrtrcredits > 0)\r\nreturn ni->ni_peerrtrcredits;\r\nif (peer_buffer_credits > 0)\r\nreturn peer_buffer_credits;\r\nreturn ni->ni_peertxcredits;\r\n}\r\nint\r\nlnet_peers_start_down(void)\r\n{\r\nreturn check_routers_before_use;\r\n}\r\nvoid\r\nlnet_notify_locked(lnet_peer_t *lp, int notifylnd, int alive,\r\nunsigned long when)\r\n{\r\nif (time_before(when, lp->lp_timestamp)) {\r\nCDEBUG(D_NET, "Out of date\n");\r\nreturn;\r\n}\r\nlp->lp_timestamp = when;\r\nlp->lp_ping_deadline = 0;\r\nif (lp->lp_alive_count &&\r\n(!lp->lp_alive) == (!alive)) {\r\nCDEBUG(D_NET, "Old news\n");\r\nreturn;\r\n}\r\nlp->lp_alive_count++;\r\nlp->lp_alive = !(!alive);\r\nlp->lp_notify = 1;\r\nlp->lp_notifylnd |= notifylnd;\r\nif (lp->lp_alive)\r\nlp->lp_ping_feats = LNET_PING_FEAT_INVAL;\r\nCDEBUG(D_NET, "set %s %d\n", libcfs_nid2str(lp->lp_nid), alive);\r\n}\r\nstatic void\r\nlnet_ni_notify_locked(lnet_ni_t *ni, lnet_peer_t *lp)\r\n{\r\nint alive;\r\nint notifylnd;\r\nif (lp->lp_notifying || !ni)\r\nreturn;\r\nlp->lp_notifying = 1;\r\nwhile (lp->lp_notify) {\r\nalive = lp->lp_alive;\r\nnotifylnd = lp->lp_notifylnd;\r\nlp->lp_notifylnd = 0;\r\nlp->lp_notify = 0;\r\nif (notifylnd && ni->ni_lnd->lnd_notify) {\r\nlnet_net_unlock(lp->lp_cpt);\r\nni->ni_lnd->lnd_notify(ni, lp->lp_nid, alive);\r\nlnet_net_lock(lp->lp_cpt);\r\n}\r\n}\r\nlp->lp_notifying = 0;\r\n}\r\nstatic void\r\nlnet_rtr_addref_locked(lnet_peer_t *lp)\r\n{\r\nLASSERT(lp->lp_refcount > 0);\r\nLASSERT(lp->lp_rtr_refcount >= 0);\r\nlp->lp_rtr_refcount++;\r\nif (lp->lp_rtr_refcount == 1) {\r\nstruct list_head *pos;\r\nlist_for_each_prev(pos, &the_lnet.ln_routers) {\r\nlnet_peer_t *rtr = list_entry(pos, lnet_peer_t,\r\nlp_rtr_list);\r\nif (rtr->lp_nid < lp->lp_nid)\r\nbreak;\r\n}\r\nlist_add(&lp->lp_rtr_list, pos);\r\nlnet_peer_addref_locked(lp);\r\nthe_lnet.ln_routers_version++;\r\n}\r\n}\r\nstatic void\r\nlnet_rtr_decref_locked(lnet_peer_t *lp)\r\n{\r\nLASSERT(lp->lp_refcount > 0);\r\nLASSERT(lp->lp_rtr_refcount > 0);\r\nlp->lp_rtr_refcount--;\r\nif (!lp->lp_rtr_refcount) {\r\nLASSERT(list_empty(&lp->lp_routes));\r\nif (lp->lp_rcd) {\r\nlist_add(&lp->lp_rcd->rcd_list,\r\n&the_lnet.ln_rcd_deathrow);\r\nlp->lp_rcd = NULL;\r\n}\r\nlist_del(&lp->lp_rtr_list);\r\nlnet_peer_decref_locked(lp);\r\nthe_lnet.ln_routers_version++;\r\n}\r\n}\r\nlnet_remotenet_t *\r\nlnet_find_net_locked(__u32 net)\r\n{\r\nlnet_remotenet_t *rnet;\r\nstruct list_head *tmp;\r\nstruct list_head *rn_list;\r\nLASSERT(!the_lnet.ln_shutdown);\r\nrn_list = lnet_net2rnethash(net);\r\nlist_for_each(tmp, rn_list) {\r\nrnet = list_entry(tmp, lnet_remotenet_t, lrn_list);\r\nif (rnet->lrn_net == net)\r\nreturn rnet;\r\n}\r\nreturn NULL;\r\n}\r\nstatic void lnet_shuffle_seed(void)\r\n{\r\nstatic int seeded;\r\n__u32 lnd_type, seed[2];\r\nstruct timespec64 ts;\r\nlnet_ni_t *ni;\r\nstruct list_head *tmp;\r\nif (seeded)\r\nreturn;\r\ncfs_get_random_bytes(seed, sizeof(seed));\r\nlist_for_each(tmp, &the_lnet.ln_nis) {\r\nni = list_entry(tmp, lnet_ni_t, ni_list);\r\nlnd_type = LNET_NETTYP(LNET_NIDNET(ni->ni_nid));\r\nif (lnd_type != LOLND)\r\nseed[0] ^= (LNET_NIDADDR(ni->ni_nid) | lnd_type);\r\n}\r\nktime_get_ts64(&ts);\r\ncfs_srand(ts.tv_sec ^ seed[0], ts.tv_nsec ^ seed[1]);\r\nseeded = 1;\r\n}\r\nstatic void\r\nlnet_add_route_to_rnet(lnet_remotenet_t *rnet, lnet_route_t *route)\r\n{\r\nunsigned int len = 0;\r\nunsigned int offset = 0;\r\nstruct list_head *e;\r\nlnet_shuffle_seed();\r\nlist_for_each(e, &rnet->lrn_routes) {\r\nlen++;\r\n}\r\noffset = cfs_rand() % (len + 1);\r\nlist_for_each(e, &rnet->lrn_routes) {\r\nif (!offset)\r\nbreak;\r\noffset--;\r\n}\r\nlist_add(&route->lr_list, e);\r\nlist_add(&route->lr_gwlist, &route->lr_gateway->lp_routes);\r\nthe_lnet.ln_remote_nets_version++;\r\nlnet_rtr_addref_locked(route->lr_gateway);\r\n}\r\nint\r\nlnet_add_route(__u32 net, __u32 hops, lnet_nid_t gateway,\r\nunsigned int priority)\r\n{\r\nstruct list_head *e;\r\nlnet_remotenet_t *rnet;\r\nlnet_remotenet_t *rnet2;\r\nlnet_route_t *route;\r\nlnet_ni_t *ni;\r\nint add_route;\r\nint rc;\r\nCDEBUG(D_NET, "Add route: net %s hops %d priority %u gw %s\n",\r\nlibcfs_net2str(net), hops, priority, libcfs_nid2str(gateway));\r\nif (gateway == LNET_NID_ANY ||\r\nLNET_NETTYP(LNET_NIDNET(gateway)) == LOLND ||\r\nnet == LNET_NIDNET(LNET_NID_ANY) ||\r\nLNET_NETTYP(net) == LOLND ||\r\nLNET_NIDNET(gateway) == net ||\r\n(hops != LNET_UNDEFINED_HOPS && (hops < 1 || hops > 255)))\r\nreturn -EINVAL;\r\nif (lnet_islocalnet(net))\r\nreturn -EEXIST;\r\nLIBCFS_ALLOC(route, sizeof(*route));\r\nLIBCFS_ALLOC(rnet, sizeof(*rnet));\r\nif (!route || !rnet) {\r\nCERROR("Out of memory creating route %s %d %s\n",\r\nlibcfs_net2str(net), hops, libcfs_nid2str(gateway));\r\nif (route)\r\nLIBCFS_FREE(route, sizeof(*route));\r\nif (rnet)\r\nLIBCFS_FREE(rnet, sizeof(*rnet));\r\nreturn -ENOMEM;\r\n}\r\nINIT_LIST_HEAD(&rnet->lrn_routes);\r\nrnet->lrn_net = net;\r\nroute->lr_hops = hops;\r\nroute->lr_net = net;\r\nroute->lr_priority = priority;\r\nlnet_net_lock(LNET_LOCK_EX);\r\nrc = lnet_nid2peer_locked(&route->lr_gateway, gateway, LNET_LOCK_EX);\r\nif (rc) {\r\nlnet_net_unlock(LNET_LOCK_EX);\r\nLIBCFS_FREE(route, sizeof(*route));\r\nLIBCFS_FREE(rnet, sizeof(*rnet));\r\nif (rc == -EHOSTUNREACH)\r\nreturn rc;\r\nCERROR("Error %d creating route %s %d %s\n", rc,\r\nlibcfs_net2str(net), hops,\r\nlibcfs_nid2str(gateway));\r\nreturn rc;\r\n}\r\nLASSERT(!the_lnet.ln_shutdown);\r\nrnet2 = lnet_find_net_locked(net);\r\nif (!rnet2) {\r\nlist_add_tail(&rnet->lrn_list, lnet_net2rnethash(net));\r\nrnet2 = rnet;\r\n}\r\nadd_route = 1;\r\nlist_for_each(e, &rnet2->lrn_routes) {\r\nlnet_route_t *route2 = list_entry(e, lnet_route_t, lr_list);\r\nif (route2->lr_gateway == route->lr_gateway) {\r\nadd_route = 0;\r\nbreak;\r\n}\r\nLASSERT(route2->lr_gateway->lp_nid != gateway);\r\n}\r\nif (add_route) {\r\nlnet_peer_addref_locked(route->lr_gateway);\r\nlnet_add_route_to_rnet(rnet2, route);\r\nni = route->lr_gateway->lp_ni;\r\nlnet_net_unlock(LNET_LOCK_EX);\r\nif (ni->ni_lnd->lnd_notify)\r\nni->ni_lnd->lnd_notify(ni, gateway, 1);\r\nlnet_net_lock(LNET_LOCK_EX);\r\n}\r\nlnet_peer_decref_locked(route->lr_gateway);\r\nlnet_net_unlock(LNET_LOCK_EX);\r\nrc = 0;\r\nif (!add_route) {\r\nrc = -EEXIST;\r\nLIBCFS_FREE(route, sizeof(*route));\r\n}\r\nif (rnet != rnet2)\r\nLIBCFS_FREE(rnet, sizeof(*rnet));\r\nwake_up(&the_lnet.ln_rc_waitq);\r\nreturn rc;\r\n}\r\nint\r\nlnet_check_routes(void)\r\n{\r\nlnet_remotenet_t *rnet;\r\nlnet_route_t *route;\r\nlnet_route_t *route2;\r\nstruct list_head *e1;\r\nstruct list_head *e2;\r\nint cpt;\r\nstruct list_head *rn_list;\r\nint i;\r\ncpt = lnet_net_lock_current();\r\nfor (i = 0; i < LNET_REMOTE_NETS_HASH_SIZE; i++) {\r\nrn_list = &the_lnet.ln_remote_nets_hash[i];\r\nlist_for_each(e1, rn_list) {\r\nrnet = list_entry(e1, lnet_remotenet_t, lrn_list);\r\nroute2 = NULL;\r\nlist_for_each(e2, &rnet->lrn_routes) {\r\nlnet_nid_t nid1;\r\nlnet_nid_t nid2;\r\nint net;\r\nroute = list_entry(e2, lnet_route_t, lr_list);\r\nif (!route2) {\r\nroute2 = route;\r\ncontinue;\r\n}\r\nif (route->lr_gateway->lp_ni ==\r\nroute2->lr_gateway->lp_ni)\r\ncontinue;\r\nnid1 = route->lr_gateway->lp_nid;\r\nnid2 = route2->lr_gateway->lp_nid;\r\nnet = rnet->lrn_net;\r\nlnet_net_unlock(cpt);\r\nCERROR("Routes to %s via %s and %s not supported\n",\r\nlibcfs_net2str(net),\r\nlibcfs_nid2str(nid1),\r\nlibcfs_nid2str(nid2));\r\nreturn -EINVAL;\r\n}\r\n}\r\n}\r\nlnet_net_unlock(cpt);\r\nreturn 0;\r\n}\r\nint\r\nlnet_del_route(__u32 net, lnet_nid_t gw_nid)\r\n{\r\nstruct lnet_peer *gateway;\r\nlnet_remotenet_t *rnet;\r\nlnet_route_t *route;\r\nstruct list_head *e1;\r\nstruct list_head *e2;\r\nint rc = -ENOENT;\r\nstruct list_head *rn_list;\r\nint idx = 0;\r\nCDEBUG(D_NET, "Del route: net %s : gw %s\n",\r\nlibcfs_net2str(net), libcfs_nid2str(gw_nid));\r\nlnet_net_lock(LNET_LOCK_EX);\r\nif (net == LNET_NIDNET(LNET_NID_ANY))\r\nrn_list = &the_lnet.ln_remote_nets_hash[0];\r\nelse\r\nrn_list = lnet_net2rnethash(net);\r\nagain:\r\nlist_for_each(e1, rn_list) {\r\nrnet = list_entry(e1, lnet_remotenet_t, lrn_list);\r\nif (!(net == LNET_NIDNET(LNET_NID_ANY) ||\r\nnet == rnet->lrn_net))\r\ncontinue;\r\nlist_for_each(e2, &rnet->lrn_routes) {\r\nroute = list_entry(e2, lnet_route_t, lr_list);\r\ngateway = route->lr_gateway;\r\nif (!(gw_nid == LNET_NID_ANY ||\r\ngw_nid == gateway->lp_nid))\r\ncontinue;\r\nlist_del(&route->lr_list);\r\nlist_del(&route->lr_gwlist);\r\nthe_lnet.ln_remote_nets_version++;\r\nif (list_empty(&rnet->lrn_routes))\r\nlist_del(&rnet->lrn_list);\r\nelse\r\nrnet = NULL;\r\nlnet_rtr_decref_locked(gateway);\r\nlnet_peer_decref_locked(gateway);\r\nlnet_net_unlock(LNET_LOCK_EX);\r\nLIBCFS_FREE(route, sizeof(*route));\r\nif (rnet)\r\nLIBCFS_FREE(rnet, sizeof(*rnet));\r\nrc = 0;\r\nlnet_net_lock(LNET_LOCK_EX);\r\ngoto again;\r\n}\r\n}\r\nif (net == LNET_NIDNET(LNET_NID_ANY) &&\r\n++idx < LNET_REMOTE_NETS_HASH_SIZE) {\r\nrn_list = &the_lnet.ln_remote_nets_hash[idx];\r\ngoto again;\r\n}\r\nlnet_net_unlock(LNET_LOCK_EX);\r\nreturn rc;\r\n}\r\nvoid\r\nlnet_destroy_routes(void)\r\n{\r\nlnet_del_route(LNET_NIDNET(LNET_NID_ANY), LNET_NID_ANY);\r\n}\r\nint lnet_get_rtr_pool_cfg(int idx, struct lnet_ioctl_pool_cfg *pool_cfg)\r\n{\r\nint i, rc = -ENOENT, j;\r\nif (!the_lnet.ln_rtrpools)\r\nreturn rc;\r\nfor (i = 0; i < LNET_NRBPOOLS; i++) {\r\nlnet_rtrbufpool_t *rbp;\r\nlnet_net_lock(LNET_LOCK_EX);\r\ncfs_percpt_for_each(rbp, j, the_lnet.ln_rtrpools) {\r\nif (i++ != idx)\r\ncontinue;\r\npool_cfg->pl_pools[i].pl_npages = rbp[i].rbp_npages;\r\npool_cfg->pl_pools[i].pl_nbuffers = rbp[i].rbp_nbuffers;\r\npool_cfg->pl_pools[i].pl_credits = rbp[i].rbp_credits;\r\npool_cfg->pl_pools[i].pl_mincredits = rbp[i].rbp_mincredits;\r\nrc = 0;\r\nbreak;\r\n}\r\nlnet_net_unlock(LNET_LOCK_EX);\r\n}\r\nlnet_net_lock(LNET_LOCK_EX);\r\npool_cfg->pl_routing = the_lnet.ln_routing;\r\nlnet_net_unlock(LNET_LOCK_EX);\r\nreturn rc;\r\n}\r\nint\r\nlnet_get_route(int idx, __u32 *net, __u32 *hops,\r\nlnet_nid_t *gateway, __u32 *alive, __u32 *priority)\r\n{\r\nstruct list_head *e1;\r\nstruct list_head *e2;\r\nlnet_remotenet_t *rnet;\r\nlnet_route_t *route;\r\nint cpt;\r\nint i;\r\nstruct list_head *rn_list;\r\ncpt = lnet_net_lock_current();\r\nfor (i = 0; i < LNET_REMOTE_NETS_HASH_SIZE; i++) {\r\nrn_list = &the_lnet.ln_remote_nets_hash[i];\r\nlist_for_each(e1, rn_list) {\r\nrnet = list_entry(e1, lnet_remotenet_t, lrn_list);\r\nlist_for_each(e2, &rnet->lrn_routes) {\r\nroute = list_entry(e2, lnet_route_t, lr_list);\r\nif (!idx--) {\r\n*net = rnet->lrn_net;\r\n*hops = route->lr_hops;\r\n*priority = route->lr_priority;\r\n*gateway = route->lr_gateway->lp_nid;\r\n*alive = lnet_is_route_alive(route);\r\nlnet_net_unlock(cpt);\r\nreturn 0;\r\n}\r\n}\r\n}\r\n}\r\nlnet_net_unlock(cpt);\r\nreturn -ENOENT;\r\n}\r\nvoid\r\nlnet_swap_pinginfo(lnet_ping_info_t *info)\r\n{\r\nint i;\r\nlnet_ni_status_t *stat;\r\n__swab32s(&info->pi_magic);\r\n__swab32s(&info->pi_features);\r\n__swab32s(&info->pi_pid);\r\n__swab32s(&info->pi_nnis);\r\nfor (i = 0; i < info->pi_nnis && i < LNET_MAX_RTR_NIS; i++) {\r\nstat = &info->pi_ni[i];\r\n__swab64s(&stat->ns_nid);\r\n__swab32s(&stat->ns_status);\r\n}\r\n}\r\nstatic void\r\nlnet_parse_rc_info(lnet_rc_data_t *rcd)\r\n{\r\nlnet_ping_info_t *info = rcd->rcd_pinginfo;\r\nstruct lnet_peer *gw = rcd->rcd_gateway;\r\nlnet_route_t *rte;\r\nif (!gw->lp_alive)\r\nreturn;\r\nif (info->pi_magic == __swab32(LNET_PROTO_PING_MAGIC))\r\nlnet_swap_pinginfo(info);\r\nif (info->pi_magic != LNET_PROTO_PING_MAGIC) {\r\nCDEBUG(D_NET, "%s: Unexpected magic %08x\n",\r\nlibcfs_nid2str(gw->lp_nid), info->pi_magic);\r\ngw->lp_ping_feats = LNET_PING_FEAT_INVAL;\r\nreturn;\r\n}\r\ngw->lp_ping_feats = info->pi_features;\r\nif (!(gw->lp_ping_feats & LNET_PING_FEAT_MASK)) {\r\nCDEBUG(D_NET, "%s: Unexpected features 0x%x\n",\r\nlibcfs_nid2str(gw->lp_nid), gw->lp_ping_feats);\r\nreturn;\r\n}\r\nif (!(gw->lp_ping_feats & LNET_PING_FEAT_NI_STATUS))\r\nreturn;\r\nlist_for_each_entry(rte, &gw->lp_routes, lr_gwlist) {\r\nint down = 0;\r\nint up = 0;\r\nint i;\r\nif (gw->lp_ping_feats & LNET_PING_FEAT_RTE_DISABLED) {\r\nrte->lr_downis = 1;\r\ncontinue;\r\n}\r\nfor (i = 0; i < info->pi_nnis && i < LNET_MAX_RTR_NIS; i++) {\r\nlnet_ni_status_t *stat = &info->pi_ni[i];\r\nlnet_nid_t nid = stat->ns_nid;\r\nif (nid == LNET_NID_ANY) {\r\nCDEBUG(D_NET, "%s: unexpected LNET_NID_ANY\n",\r\nlibcfs_nid2str(gw->lp_nid));\r\ngw->lp_ping_feats = LNET_PING_FEAT_INVAL;\r\nreturn;\r\n}\r\nif (LNET_NETTYP(LNET_NIDNET(nid)) == LOLND)\r\ncontinue;\r\nif (stat->ns_status == LNET_NI_STATUS_DOWN) {\r\ndown++;\r\ncontinue;\r\n}\r\nif (stat->ns_status == LNET_NI_STATUS_UP) {\r\nif (LNET_NIDNET(nid) == rte->lr_net) {\r\nup = 1;\r\nbreak;\r\n}\r\ncontinue;\r\n}\r\nCDEBUG(D_NET, "%s: Unexpected status 0x%x\n",\r\nlibcfs_nid2str(gw->lp_nid), stat->ns_status);\r\ngw->lp_ping_feats = LNET_PING_FEAT_INVAL;\r\nreturn;\r\n}\r\nif (up) {\r\nrte->lr_downis = 0;\r\ncontinue;\r\n}\r\nif (!down && rte->lr_hops == 1)\r\ndown = 1;\r\nrte->lr_downis = down;\r\n}\r\n}\r\nstatic void\r\nlnet_router_checker_event(lnet_event_t *event)\r\n{\r\nlnet_rc_data_t *rcd = event->md.user_ptr;\r\nstruct lnet_peer *lp;\r\nLASSERT(rcd);\r\nif (event->unlinked) {\r\nLNetInvalidateHandle(&rcd->rcd_mdh);\r\nreturn;\r\n}\r\nLASSERT(event->type == LNET_EVENT_SEND ||\r\nevent->type == LNET_EVENT_REPLY);\r\nlp = rcd->rcd_gateway;\r\nLASSERT(lp);\r\nlnet_net_lock(lp->lp_cpt);\r\nif (!lnet_isrouter(lp) || lp->lp_rcd != rcd) {\r\ngoto out;\r\n}\r\nif (event->type == LNET_EVENT_SEND) {\r\nlp->lp_ping_notsent = 0;\r\nif (!event->status)\r\ngoto out;\r\n}\r\nlnet_notify_locked(lp, 1, !event->status, cfs_time_current());\r\nif (avoid_asym_router_failure && !event->status)\r\nlnet_parse_rc_info(rcd);\r\nout:\r\nlnet_net_unlock(lp->lp_cpt);\r\n}\r\nstatic void\r\nlnet_wait_known_routerstate(void)\r\n{\r\nlnet_peer_t *rtr;\r\nstruct list_head *entry;\r\nint all_known;\r\nLASSERT(the_lnet.ln_rc_state == LNET_RC_STATE_RUNNING);\r\nfor (;;) {\r\nint cpt = lnet_net_lock_current();\r\nall_known = 1;\r\nlist_for_each(entry, &the_lnet.ln_routers) {\r\nrtr = list_entry(entry, lnet_peer_t, lp_rtr_list);\r\nif (!rtr->lp_alive_count) {\r\nall_known = 0;\r\nbreak;\r\n}\r\n}\r\nlnet_net_unlock(cpt);\r\nif (all_known)\r\nreturn;\r\nset_current_state(TASK_UNINTERRUPTIBLE);\r\nschedule_timeout(cfs_time_seconds(1));\r\n}\r\n}\r\nvoid\r\nlnet_router_ni_update_locked(lnet_peer_t *gw, __u32 net)\r\n{\r\nlnet_route_t *rte;\r\nif ((gw->lp_ping_feats & LNET_PING_FEAT_NI_STATUS)) {\r\nlist_for_each_entry(rte, &gw->lp_routes, lr_gwlist) {\r\nif (rte->lr_net == net) {\r\nrte->lr_downis = 0;\r\nbreak;\r\n}\r\n}\r\n}\r\n}\r\nstatic void\r\nlnet_update_ni_status_locked(void)\r\n{\r\nlnet_ni_t *ni;\r\ntime64_t now;\r\nint timeout;\r\nLASSERT(the_lnet.ln_routing);\r\ntimeout = router_ping_timeout +\r\nmax(live_router_check_interval, dead_router_check_interval);\r\nnow = ktime_get_real_seconds();\r\nlist_for_each_entry(ni, &the_lnet.ln_nis, ni_list) {\r\nif (ni->ni_lnd->lnd_type == LOLND)\r\ncontinue;\r\nif (now < ni->ni_last_alive + timeout)\r\ncontinue;\r\nlnet_ni_lock(ni);\r\nif (now < ni->ni_last_alive + timeout) {\r\nlnet_ni_unlock(ni);\r\ncontinue;\r\n}\r\nLASSERT(ni->ni_status);\r\nif (ni->ni_status->ns_status != LNET_NI_STATUS_DOWN) {\r\nCDEBUG(D_NET, "NI(%s:%d) status changed to down\n",\r\nlibcfs_nid2str(ni->ni_nid), timeout);\r\nni->ni_status->ns_status = LNET_NI_STATUS_DOWN;\r\n}\r\nlnet_ni_unlock(ni);\r\n}\r\n}\r\nstatic void\r\nlnet_destroy_rc_data(lnet_rc_data_t *rcd)\r\n{\r\nLASSERT(list_empty(&rcd->rcd_list));\r\nLASSERT(LNetHandleIsInvalid(rcd->rcd_mdh));\r\nif (rcd->rcd_gateway) {\r\nint cpt = rcd->rcd_gateway->lp_cpt;\r\nlnet_net_lock(cpt);\r\nlnet_peer_decref_locked(rcd->rcd_gateway);\r\nlnet_net_unlock(cpt);\r\n}\r\nif (rcd->rcd_pinginfo)\r\nLIBCFS_FREE(rcd->rcd_pinginfo, LNET_PINGINFO_SIZE);\r\nLIBCFS_FREE(rcd, sizeof(*rcd));\r\n}\r\nstatic lnet_rc_data_t *\r\nlnet_create_rc_data_locked(lnet_peer_t *gateway)\r\n{\r\nlnet_rc_data_t *rcd = NULL;\r\nlnet_ping_info_t *pi;\r\nint rc;\r\nint i;\r\nlnet_net_unlock(gateway->lp_cpt);\r\nLIBCFS_ALLOC(rcd, sizeof(*rcd));\r\nif (!rcd)\r\ngoto out;\r\nLNetInvalidateHandle(&rcd->rcd_mdh);\r\nINIT_LIST_HEAD(&rcd->rcd_list);\r\nLIBCFS_ALLOC(pi, LNET_PINGINFO_SIZE);\r\nif (!pi)\r\ngoto out;\r\nfor (i = 0; i < LNET_MAX_RTR_NIS; i++) {\r\npi->pi_ni[i].ns_nid = LNET_NID_ANY;\r\npi->pi_ni[i].ns_status = LNET_NI_STATUS_INVALID;\r\n}\r\nrcd->rcd_pinginfo = pi;\r\nLASSERT(!LNetHandleIsInvalid(the_lnet.ln_rc_eqh));\r\nrc = LNetMDBind((lnet_md_t){.start = pi,\r\n.user_ptr = rcd,\r\n.length = LNET_PINGINFO_SIZE,\r\n.threshold = LNET_MD_THRESH_INF,\r\n.options = LNET_MD_TRUNCATE,\r\n.eq_handle = the_lnet.ln_rc_eqh},\r\nLNET_UNLINK,\r\n&rcd->rcd_mdh);\r\nif (rc < 0) {\r\nCERROR("Can't bind MD: %d\n", rc);\r\ngoto out;\r\n}\r\nLASSERT(!rc);\r\nlnet_net_lock(gateway->lp_cpt);\r\nif (!lnet_isrouter(gateway) || gateway->lp_rcd) {\r\nlnet_net_unlock(gateway->lp_cpt);\r\ngoto out;\r\n}\r\nlnet_peer_addref_locked(gateway);\r\nrcd->rcd_gateway = gateway;\r\ngateway->lp_rcd = rcd;\r\ngateway->lp_ping_notsent = 0;\r\nreturn rcd;\r\nout:\r\nif (rcd) {\r\nif (!LNetHandleIsInvalid(rcd->rcd_mdh)) {\r\nrc = LNetMDUnlink(rcd->rcd_mdh);\r\nLASSERT(!rc);\r\n}\r\nlnet_destroy_rc_data(rcd);\r\n}\r\nlnet_net_lock(gateway->lp_cpt);\r\nreturn gateway->lp_rcd;\r\n}\r\nstatic int\r\nlnet_router_check_interval(lnet_peer_t *rtr)\r\n{\r\nint secs;\r\nsecs = rtr->lp_alive ? live_router_check_interval :\r\ndead_router_check_interval;\r\nif (secs < 0)\r\nsecs = 0;\r\nreturn secs;\r\n}\r\nstatic void\r\nlnet_ping_router_locked(lnet_peer_t *rtr)\r\n{\r\nlnet_rc_data_t *rcd = NULL;\r\nunsigned long now = cfs_time_current();\r\nint secs;\r\nlnet_peer_addref_locked(rtr);\r\nif (rtr->lp_ping_deadline &&\r\ncfs_time_after(now, rtr->lp_ping_deadline))\r\nlnet_notify_locked(rtr, 1, 0, now);\r\nlnet_ni_notify_locked(rtr->lp_ni, rtr);\r\nif (!lnet_isrouter(rtr) ||\r\nthe_lnet.ln_rc_state != LNET_RC_STATE_RUNNING) {\r\nlnet_peer_decref_locked(rtr);\r\nreturn;\r\n}\r\nrcd = rtr->lp_rcd ?\r\nrtr->lp_rcd : lnet_create_rc_data_locked(rtr);\r\nif (!rcd)\r\nreturn;\r\nsecs = lnet_router_check_interval(rtr);\r\nCDEBUG(D_NET,\r\n"rtr %s %d: deadline %lu ping_notsent %d alive %d alive_count %d lp_ping_timestamp %lu\n",\r\nlibcfs_nid2str(rtr->lp_nid), secs,\r\nrtr->lp_ping_deadline, rtr->lp_ping_notsent,\r\nrtr->lp_alive, rtr->lp_alive_count, rtr->lp_ping_timestamp);\r\nif (secs && !rtr->lp_ping_notsent &&\r\ncfs_time_after(now, cfs_time_add(rtr->lp_ping_timestamp,\r\ncfs_time_seconds(secs)))) {\r\nint rc;\r\nlnet_process_id_t id;\r\nlnet_handle_md_t mdh;\r\nid.nid = rtr->lp_nid;\r\nid.pid = LNET_PID_LUSTRE;\r\nCDEBUG(D_NET, "Check: %s\n", libcfs_id2str(id));\r\nrtr->lp_ping_notsent = 1;\r\nrtr->lp_ping_timestamp = now;\r\nmdh = rcd->rcd_mdh;\r\nif (!rtr->lp_ping_deadline) {\r\nrtr->lp_ping_deadline =\r\ncfs_time_shift(router_ping_timeout);\r\n}\r\nlnet_net_unlock(rtr->lp_cpt);\r\nrc = LNetGet(LNET_NID_ANY, mdh, id, LNET_RESERVED_PORTAL,\r\nLNET_PROTO_PING_MATCHBITS, 0);\r\nlnet_net_lock(rtr->lp_cpt);\r\nif (rc)\r\nrtr->lp_ping_notsent = 0;\r\n}\r\nlnet_peer_decref_locked(rtr);\r\n}\r\nint\r\nlnet_router_checker_start(void)\r\n{\r\nstruct task_struct *task;\r\nint rc;\r\nint eqsz = 0;\r\nLASSERT(the_lnet.ln_rc_state == LNET_RC_STATE_SHUTDOWN);\r\nif (check_routers_before_use &&\r\ndead_router_check_interval <= 0) {\r\nLCONSOLE_ERROR_MSG(0x10a, "'dead_router_check_interval' must be set if 'check_routers_before_use' is set\n");\r\nreturn -EINVAL;\r\n}\r\nsema_init(&the_lnet.ln_rc_signal, 0);\r\nrc = LNetEQAlloc(0, lnet_router_checker_event, &the_lnet.ln_rc_eqh);\r\nif (rc) {\r\nCERROR("Can't allocate EQ(%d): %d\n", eqsz, rc);\r\nreturn -ENOMEM;\r\n}\r\nthe_lnet.ln_rc_state = LNET_RC_STATE_RUNNING;\r\ntask = kthread_run(lnet_router_checker, NULL, "router_checker");\r\nif (IS_ERR(task)) {\r\nrc = PTR_ERR(task);\r\nCERROR("Can't start router checker thread: %d\n", rc);\r\ndown(&the_lnet.ln_rc_signal);\r\nrc = LNetEQFree(the_lnet.ln_rc_eqh);\r\nLASSERT(!rc);\r\nthe_lnet.ln_rc_state = LNET_RC_STATE_SHUTDOWN;\r\nreturn -ENOMEM;\r\n}\r\nif (check_routers_before_use) {\r\nlnet_wait_known_routerstate();\r\n}\r\nreturn 0;\r\n}\r\nvoid\r\nlnet_router_checker_stop(void)\r\n{\r\nint rc;\r\nif (the_lnet.ln_rc_state == LNET_RC_STATE_SHUTDOWN)\r\nreturn;\r\nLASSERT(the_lnet.ln_rc_state == LNET_RC_STATE_RUNNING);\r\nthe_lnet.ln_rc_state = LNET_RC_STATE_STOPPING;\r\nwake_up(&the_lnet.ln_rc_waitq);\r\ndown(&the_lnet.ln_rc_signal);\r\nLASSERT(the_lnet.ln_rc_state == LNET_RC_STATE_SHUTDOWN);\r\nrc = LNetEQFree(the_lnet.ln_rc_eqh);\r\nLASSERT(!rc);\r\n}\r\nstatic void\r\nlnet_prune_rc_data(int wait_unlink)\r\n{\r\nlnet_rc_data_t *rcd;\r\nlnet_rc_data_t *tmp;\r\nlnet_peer_t *lp;\r\nstruct list_head head;\r\nint i = 2;\r\nif (likely(the_lnet.ln_rc_state == LNET_RC_STATE_RUNNING &&\r\nlist_empty(&the_lnet.ln_rcd_deathrow) &&\r\nlist_empty(&the_lnet.ln_rcd_zombie)))\r\nreturn;\r\nINIT_LIST_HEAD(&head);\r\nlnet_net_lock(LNET_LOCK_EX);\r\nif (the_lnet.ln_rc_state != LNET_RC_STATE_RUNNING) {\r\nlist_for_each_entry(lp, &the_lnet.ln_routers,\r\nlp_rtr_list) {\r\nif (!lp->lp_rcd)\r\ncontinue;\r\nLASSERT(list_empty(&lp->lp_rcd->rcd_list));\r\nlist_add(&lp->lp_rcd->rcd_list,\r\n&the_lnet.ln_rcd_deathrow);\r\nlp->lp_rcd = NULL;\r\n}\r\n}\r\nlist_splice_init(&the_lnet.ln_rcd_deathrow, &head);\r\nif (!list_empty(&head)) {\r\nlnet_net_unlock(LNET_LOCK_EX);\r\nlist_for_each_entry(rcd, &head, rcd_list)\r\nLNetMDUnlink(rcd->rcd_mdh);\r\nlnet_net_lock(LNET_LOCK_EX);\r\n}\r\nlist_splice_init(&head, &the_lnet.ln_rcd_zombie);\r\nwhile (!list_empty(&the_lnet.ln_rcd_zombie)) {\r\nlist_for_each_entry_safe(rcd, tmp, &the_lnet.ln_rcd_zombie,\r\nrcd_list) {\r\nif (LNetHandleIsInvalid(rcd->rcd_mdh))\r\nlist_move(&rcd->rcd_list, &head);\r\n}\r\nwait_unlink = wait_unlink &&\r\n!list_empty(&the_lnet.ln_rcd_zombie);\r\nlnet_net_unlock(LNET_LOCK_EX);\r\nwhile (!list_empty(&head)) {\r\nrcd = list_entry(head.next,\r\nlnet_rc_data_t, rcd_list);\r\nlist_del_init(&rcd->rcd_list);\r\nlnet_destroy_rc_data(rcd);\r\n}\r\nif (!wait_unlink)\r\nreturn;\r\ni++;\r\nCDEBUG(((i & (-i)) == i) ? D_WARNING : D_NET,\r\n"Waiting for rc buffers to unlink\n");\r\nset_current_state(TASK_UNINTERRUPTIBLE);\r\nschedule_timeout(cfs_time_seconds(1) / 4);\r\nlnet_net_lock(LNET_LOCK_EX);\r\n}\r\nlnet_net_unlock(LNET_LOCK_EX);\r\n}\r\nstatic inline bool\r\nlnet_router_checker_active(void)\r\n{\r\nif (the_lnet.ln_rc_state != LNET_RC_STATE_RUNNING)\r\nreturn true;\r\nif (the_lnet.ln_routing)\r\nreturn true;\r\nreturn !list_empty(&the_lnet.ln_routers) &&\r\n(live_router_check_interval > 0 ||\r\ndead_router_check_interval > 0);\r\n}\r\nstatic int\r\nlnet_router_checker(void *arg)\r\n{\r\nlnet_peer_t *rtr;\r\nstruct list_head *entry;\r\ncfs_block_allsigs();\r\nwhile (the_lnet.ln_rc_state == LNET_RC_STATE_RUNNING) {\r\n__u64 version;\r\nint cpt;\r\nint cpt2;\r\ncpt = lnet_net_lock_current();\r\nrescan:\r\nversion = the_lnet.ln_routers_version;\r\nlist_for_each(entry, &the_lnet.ln_routers) {\r\nrtr = list_entry(entry, lnet_peer_t, lp_rtr_list);\r\ncpt2 = lnet_cpt_of_nid_locked(rtr->lp_nid);\r\nif (cpt != cpt2) {\r\nlnet_net_unlock(cpt);\r\ncpt = cpt2;\r\nlnet_net_lock(cpt);\r\nif (version != the_lnet.ln_routers_version)\r\ngoto rescan;\r\n}\r\nlnet_ping_router_locked(rtr);\r\nif (version != the_lnet.ln_routers_version) {\r\ngoto rescan;\r\n}\r\n}\r\nif (the_lnet.ln_routing)\r\nlnet_update_ni_status_locked();\r\nlnet_net_unlock(cpt);\r\nlnet_prune_rc_data(0);\r\nif (!lnet_router_checker_active())\r\nwait_event_interruptible(the_lnet.ln_rc_waitq,\r\nlnet_router_checker_active());\r\nelse\r\nwait_event_interruptible_timeout(the_lnet.ln_rc_waitq,\r\nfalse,\r\ncfs_time_seconds(1));\r\n}\r\nlnet_prune_rc_data(1);\r\nthe_lnet.ln_rc_state = LNET_RC_STATE_SHUTDOWN;\r\nup(&the_lnet.ln_rc_signal);\r\nreturn 0;\r\n}\r\nvoid\r\nlnet_destroy_rtrbuf(lnet_rtrbuf_t *rb, int npages)\r\n{\r\nint sz = offsetof(lnet_rtrbuf_t, rb_kiov[npages]);\r\nwhile (--npages >= 0)\r\n__free_page(rb->rb_kiov[npages].kiov_page);\r\nLIBCFS_FREE(rb, sz);\r\n}\r\nstatic lnet_rtrbuf_t *\r\nlnet_new_rtrbuf(lnet_rtrbufpool_t *rbp, int cpt)\r\n{\r\nint npages = rbp->rbp_npages;\r\nint sz = offsetof(lnet_rtrbuf_t, rb_kiov[npages]);\r\nstruct page *page;\r\nlnet_rtrbuf_t *rb;\r\nint i;\r\nLIBCFS_CPT_ALLOC(rb, lnet_cpt_table(), cpt, sz);\r\nif (!rb)\r\nreturn NULL;\r\nrb->rb_pool = rbp;\r\nfor (i = 0; i < npages; i++) {\r\npage = alloc_pages_node(\r\ncfs_cpt_spread_node(lnet_cpt_table(), cpt),\r\nGFP_KERNEL | __GFP_ZERO, 0);\r\nif (!page) {\r\nwhile (--i >= 0)\r\n__free_page(rb->rb_kiov[i].kiov_page);\r\nLIBCFS_FREE(rb, sz);\r\nreturn NULL;\r\n}\r\nrb->rb_kiov[i].kiov_len = PAGE_SIZE;\r\nrb->rb_kiov[i].kiov_offset = 0;\r\nrb->rb_kiov[i].kiov_page = page;\r\n}\r\nreturn rb;\r\n}\r\nstatic void\r\nlnet_rtrpool_free_bufs(lnet_rtrbufpool_t *rbp, int cpt)\r\n{\r\nint npages = rbp->rbp_npages;\r\nstruct list_head tmp;\r\nlnet_rtrbuf_t *rb;\r\nlnet_rtrbuf_t *temp;\r\nif (!rbp->rbp_nbuffers)\r\nreturn;\r\nINIT_LIST_HEAD(&tmp);\r\nlnet_net_lock(cpt);\r\nlnet_drop_routed_msgs_locked(&rbp->rbp_msgs, cpt);\r\nlist_splice_init(&rbp->rbp_bufs, &tmp);\r\nrbp->rbp_req_nbuffers = 0;\r\nrbp->rbp_nbuffers = 0;\r\nrbp->rbp_credits = 0;\r\nrbp->rbp_mincredits = 0;\r\nlnet_net_unlock(cpt);\r\nlist_for_each_entry_safe(rb, temp, &tmp, rb_list) {\r\nlist_del(&rb->rb_list);\r\nlnet_destroy_rtrbuf(rb, npages);\r\n}\r\n}\r\nstatic int\r\nlnet_rtrpool_adjust_bufs(lnet_rtrbufpool_t *rbp, int nbufs, int cpt)\r\n{\r\nstruct list_head rb_list;\r\nlnet_rtrbuf_t *rb;\r\nint num_rb;\r\nint num_buffers = 0;\r\nint old_req_nbufs;\r\nint npages = rbp->rbp_npages;\r\nlnet_net_lock(cpt);\r\nnum_rb = nbufs - rbp->rbp_nbuffers;\r\nif (nbufs <= rbp->rbp_req_nbuffers || num_rb <= 0) {\r\nrbp->rbp_req_nbuffers = nbufs;\r\nlnet_net_unlock(cpt);\r\nreturn 0;\r\n}\r\nold_req_nbufs = rbp->rbp_req_nbuffers;\r\nrbp->rbp_req_nbuffers = nbufs;\r\nlnet_net_unlock(cpt);\r\nINIT_LIST_HEAD(&rb_list);\r\nwhile (num_rb-- > 0) {\r\nrb = lnet_new_rtrbuf(rbp, cpt);\r\nif (!rb) {\r\nCERROR("Failed to allocate %d route bufs of %d pages\n",\r\nnbufs, npages);\r\nlnet_net_lock(cpt);\r\nrbp->rbp_req_nbuffers = old_req_nbufs;\r\nlnet_net_unlock(cpt);\r\ngoto failed;\r\n}\r\nlist_add(&rb->rb_list, &rb_list);\r\nnum_buffers++;\r\n}\r\nlnet_net_lock(cpt);\r\nlist_splice_tail(&rb_list, &rbp->rbp_bufs);\r\nrbp->rbp_nbuffers += num_buffers;\r\nrbp->rbp_credits += num_buffers;\r\nrbp->rbp_mincredits = rbp->rbp_credits;\r\nwhile (!list_empty(&rbp->rbp_bufs) &&\r\n!list_empty(&rbp->rbp_msgs))\r\nlnet_schedule_blocked_locked(rbp);\r\nlnet_net_unlock(cpt);\r\nreturn 0;\r\nfailed:\r\nwhile (!list_empty(&rb_list)) {\r\nrb = list_entry(rb_list.next, lnet_rtrbuf_t, rb_list);\r\nlist_del(&rb->rb_list);\r\nlnet_destroy_rtrbuf(rb, npages);\r\n}\r\nreturn -ENOMEM;\r\n}\r\nstatic void\r\nlnet_rtrpool_init(lnet_rtrbufpool_t *rbp, int npages)\r\n{\r\nINIT_LIST_HEAD(&rbp->rbp_msgs);\r\nINIT_LIST_HEAD(&rbp->rbp_bufs);\r\nrbp->rbp_npages = npages;\r\nrbp->rbp_credits = 0;\r\nrbp->rbp_mincredits = 0;\r\n}\r\nvoid\r\nlnet_rtrpools_free(int keep_pools)\r\n{\r\nlnet_rtrbufpool_t *rtrp;\r\nint i;\r\nif (!the_lnet.ln_rtrpools)\r\nreturn;\r\ncfs_percpt_for_each(rtrp, i, the_lnet.ln_rtrpools) {\r\nlnet_rtrpool_free_bufs(&rtrp[LNET_TINY_BUF_IDX], i);\r\nlnet_rtrpool_free_bufs(&rtrp[LNET_SMALL_BUF_IDX], i);\r\nlnet_rtrpool_free_bufs(&rtrp[LNET_LARGE_BUF_IDX], i);\r\n}\r\nif (!keep_pools) {\r\ncfs_percpt_free(the_lnet.ln_rtrpools);\r\nthe_lnet.ln_rtrpools = NULL;\r\n}\r\n}\r\nstatic int\r\nlnet_nrb_tiny_calculate(void)\r\n{\r\nint nrbs = LNET_NRB_TINY;\r\nif (tiny_router_buffers < 0) {\r\nLCONSOLE_ERROR_MSG(0x10c,\r\n"tiny_router_buffers=%d invalid when routing enabled\n",\r\ntiny_router_buffers);\r\nreturn -EINVAL;\r\n}\r\nif (tiny_router_buffers > 0)\r\nnrbs = tiny_router_buffers;\r\nnrbs /= LNET_CPT_NUMBER;\r\nreturn max(nrbs, LNET_NRB_TINY_MIN);\r\n}\r\nstatic int\r\nlnet_nrb_small_calculate(void)\r\n{\r\nint nrbs = LNET_NRB_SMALL;\r\nif (small_router_buffers < 0) {\r\nLCONSOLE_ERROR_MSG(0x10c,\r\n"small_router_buffers=%d invalid when routing enabled\n",\r\nsmall_router_buffers);\r\nreturn -EINVAL;\r\n}\r\nif (small_router_buffers > 0)\r\nnrbs = small_router_buffers;\r\nnrbs /= LNET_CPT_NUMBER;\r\nreturn max(nrbs, LNET_NRB_SMALL_MIN);\r\n}\r\nstatic int\r\nlnet_nrb_large_calculate(void)\r\n{\r\nint nrbs = LNET_NRB_LARGE;\r\nif (large_router_buffers < 0) {\r\nLCONSOLE_ERROR_MSG(0x10c,\r\n"large_router_buffers=%d invalid when routing enabled\n",\r\nlarge_router_buffers);\r\nreturn -EINVAL;\r\n}\r\nif (large_router_buffers > 0)\r\nnrbs = large_router_buffers;\r\nnrbs /= LNET_CPT_NUMBER;\r\nreturn max(nrbs, LNET_NRB_LARGE_MIN);\r\n}\r\nint\r\nlnet_rtrpools_alloc(int im_a_router)\r\n{\r\nlnet_rtrbufpool_t *rtrp;\r\nint nrb_tiny;\r\nint nrb_small;\r\nint nrb_large;\r\nint rc;\r\nint i;\r\nif (!strcmp(forwarding, "")) {\r\nif (!im_a_router)\r\nreturn 0;\r\n} else if (!strcmp(forwarding, "disabled")) {\r\nreturn 0;\r\n} else if (!strcmp(forwarding, "enabled")) {\r\n} else {\r\nLCONSOLE_ERROR_MSG(0x10b, "'forwarding' not set to either 'enabled' or 'disabled'\n");\r\nreturn -EINVAL;\r\n}\r\nnrb_tiny = lnet_nrb_tiny_calculate();\r\nif (nrb_tiny < 0)\r\nreturn -EINVAL;\r\nnrb_small = lnet_nrb_small_calculate();\r\nif (nrb_small < 0)\r\nreturn -EINVAL;\r\nnrb_large = lnet_nrb_large_calculate();\r\nif (nrb_large < 0)\r\nreturn -EINVAL;\r\nthe_lnet.ln_rtrpools = cfs_percpt_alloc(lnet_cpt_table(),\r\nLNET_NRBPOOLS *\r\nsizeof(lnet_rtrbufpool_t));\r\nif (!the_lnet.ln_rtrpools) {\r\nLCONSOLE_ERROR_MSG(0x10c,\r\n"Failed to initialize router buffe pool\n");\r\nreturn -ENOMEM;\r\n}\r\ncfs_percpt_for_each(rtrp, i, the_lnet.ln_rtrpools) {\r\nlnet_rtrpool_init(&rtrp[LNET_TINY_BUF_IDX], 0);\r\nrc = lnet_rtrpool_adjust_bufs(&rtrp[LNET_TINY_BUF_IDX],\r\nnrb_tiny, i);\r\nif (rc)\r\ngoto failed;\r\nlnet_rtrpool_init(&rtrp[LNET_SMALL_BUF_IDX],\r\nLNET_NRB_SMALL_PAGES);\r\nrc = lnet_rtrpool_adjust_bufs(&rtrp[LNET_SMALL_BUF_IDX],\r\nnrb_small, i);\r\nif (rc)\r\ngoto failed;\r\nlnet_rtrpool_init(&rtrp[LNET_LARGE_BUF_IDX],\r\nLNET_NRB_LARGE_PAGES);\r\nrc = lnet_rtrpool_adjust_bufs(&rtrp[LNET_LARGE_BUF_IDX],\r\nnrb_large, i);\r\nif (rc)\r\ngoto failed;\r\n}\r\nlnet_net_lock(LNET_LOCK_EX);\r\nthe_lnet.ln_routing = 1;\r\nlnet_net_unlock(LNET_LOCK_EX);\r\nreturn 0;\r\nfailed:\r\nlnet_rtrpools_free(0);\r\nreturn rc;\r\n}\r\nstatic int\r\nlnet_rtrpools_adjust_helper(int tiny, int small, int large)\r\n{\r\nint nrb = 0;\r\nint rc = 0;\r\nint i;\r\nlnet_rtrbufpool_t *rtrp;\r\nif (tiny >= 0) {\r\ntiny_router_buffers = tiny;\r\nnrb = lnet_nrb_tiny_calculate();\r\ncfs_percpt_for_each(rtrp, i, the_lnet.ln_rtrpools) {\r\nrc = lnet_rtrpool_adjust_bufs(&rtrp[LNET_TINY_BUF_IDX],\r\nnrb, i);\r\nif (rc)\r\nreturn rc;\r\n}\r\n}\r\nif (small >= 0) {\r\nsmall_router_buffers = small;\r\nnrb = lnet_nrb_small_calculate();\r\ncfs_percpt_for_each(rtrp, i, the_lnet.ln_rtrpools) {\r\nrc = lnet_rtrpool_adjust_bufs(&rtrp[LNET_SMALL_BUF_IDX],\r\nnrb, i);\r\nif (rc)\r\nreturn rc;\r\n}\r\n}\r\nif (large >= 0) {\r\nlarge_router_buffers = large;\r\nnrb = lnet_nrb_large_calculate();\r\ncfs_percpt_for_each(rtrp, i, the_lnet.ln_rtrpools) {\r\nrc = lnet_rtrpool_adjust_bufs(&rtrp[LNET_LARGE_BUF_IDX],\r\nnrb, i);\r\nif (rc)\r\nreturn rc;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nint\r\nlnet_rtrpools_adjust(int tiny, int small, int large)\r\n{\r\nif (!the_lnet.ln_routing)\r\nreturn 0;\r\nreturn lnet_rtrpools_adjust_helper(tiny, small, large);\r\n}\r\nint\r\nlnet_rtrpools_enable(void)\r\n{\r\nint rc;\r\nif (the_lnet.ln_routing)\r\nreturn 0;\r\nif (!the_lnet.ln_rtrpools)\r\nreturn lnet_rtrpools_alloc(1);\r\nrc = lnet_rtrpools_adjust_helper(0, 0, 0);\r\nif (rc)\r\nreturn rc;\r\nlnet_net_lock(LNET_LOCK_EX);\r\nthe_lnet.ln_routing = 1;\r\nthe_lnet.ln_ping_info->pi_features &= ~LNET_PING_FEAT_RTE_DISABLED;\r\nlnet_net_unlock(LNET_LOCK_EX);\r\nreturn 0;\r\n}\r\nvoid\r\nlnet_rtrpools_disable(void)\r\n{\r\nif (!the_lnet.ln_routing)\r\nreturn;\r\nlnet_net_lock(LNET_LOCK_EX);\r\nthe_lnet.ln_routing = 0;\r\nthe_lnet.ln_ping_info->pi_features |= LNET_PING_FEAT_RTE_DISABLED;\r\ntiny_router_buffers = 0;\r\nsmall_router_buffers = 0;\r\nlarge_router_buffers = 0;\r\nlnet_net_unlock(LNET_LOCK_EX);\r\nlnet_rtrpools_free(1);\r\n}\r\nint\r\nlnet_notify(lnet_ni_t *ni, lnet_nid_t nid, int alive, unsigned long when)\r\n{\r\nstruct lnet_peer *lp = NULL;\r\nunsigned long now = cfs_time_current();\r\nint cpt = lnet_cpt_of_nid(nid);\r\nLASSERT(!in_interrupt());\r\nCDEBUG(D_NET, "%s notifying %s: %s\n",\r\n!ni ? "userspace" : libcfs_nid2str(ni->ni_nid),\r\nlibcfs_nid2str(nid),\r\nalive ? "up" : "down");\r\nif (ni &&\r\nLNET_NIDNET(ni->ni_nid) != LNET_NIDNET(nid)) {\r\nCWARN("Ignoring notification of %s %s by %s (different net)\n",\r\nlibcfs_nid2str(nid), alive ? "birth" : "death",\r\nlibcfs_nid2str(ni->ni_nid));\r\nreturn -EINVAL;\r\n}\r\nif (cfs_time_after(when, now)) {\r\nCWARN("Ignoring prediction from %s of %s %s %ld seconds in the future\n",\r\n!ni ? "userspace" : libcfs_nid2str(ni->ni_nid),\r\nlibcfs_nid2str(nid), alive ? "up" : "down",\r\ncfs_duration_sec(cfs_time_sub(when, now)));\r\nreturn -EINVAL;\r\n}\r\nif (ni && !alive &&\r\n!auto_down) {\r\nCDEBUG(D_NET, "Auto-down disabled\n");\r\nreturn 0;\r\n}\r\nlnet_net_lock(cpt);\r\nif (the_lnet.ln_shutdown) {\r\nlnet_net_unlock(cpt);\r\nreturn -ESHUTDOWN;\r\n}\r\nlp = lnet_find_peer_locked(the_lnet.ln_peer_tables[cpt], nid);\r\nif (!lp) {\r\nlnet_net_unlock(cpt);\r\nCDEBUG(D_NET, "%s not found\n", libcfs_nid2str(nid));\r\nreturn 0;\r\n}\r\nif (ni && !alive && when < lp->lp_last_alive)\r\nwhen = lp->lp_last_alive;\r\nlnet_notify_locked(lp, !ni, alive, when);\r\nif (ni)\r\nlnet_ni_notify_locked(ni, lp);\r\nlnet_peer_decref_locked(lp);\r\nlnet_net_unlock(cpt);\r\nreturn 0;\r\n}
