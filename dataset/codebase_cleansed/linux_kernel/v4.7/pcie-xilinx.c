static inline u32 pcie_read(struct xilinx_pcie_port *port, u32 reg)\r\n{\r\nreturn readl(port->reg_base + reg);\r\n}\r\nstatic inline void pcie_write(struct xilinx_pcie_port *port, u32 val, u32 reg)\r\n{\r\nwritel(val, port->reg_base + reg);\r\n}\r\nstatic inline bool xilinx_pcie_link_is_up(struct xilinx_pcie_port *port)\r\n{\r\nreturn (pcie_read(port, XILINX_PCIE_REG_PSCR) &\r\nXILINX_PCIE_REG_PSCR_LNKUP) ? 1 : 0;\r\n}\r\nstatic void xilinx_pcie_clear_err_interrupts(struct xilinx_pcie_port *port)\r\n{\r\nunsigned long val = pcie_read(port, XILINX_PCIE_REG_RPEFR);\r\nif (val & XILINX_PCIE_RPEFR_ERR_VALID) {\r\ndev_dbg(port->dev, "Requester ID %lu\n",\r\nval & XILINX_PCIE_RPEFR_REQ_ID);\r\npcie_write(port, XILINX_PCIE_RPEFR_ALL_MASK,\r\nXILINX_PCIE_REG_RPEFR);\r\n}\r\n}\r\nstatic bool xilinx_pcie_valid_device(struct pci_bus *bus, unsigned int devfn)\r\n{\r\nstruct xilinx_pcie_port *port = bus->sysdata;\r\nif (bus->number != port->root_busno)\r\nif (!xilinx_pcie_link_is_up(port))\r\nreturn false;\r\nif (bus->number == port->root_busno && devfn > 0)\r\nreturn false;\r\nif (bus->primary == port->root_busno && devfn > 0)\r\nreturn false;\r\nreturn true;\r\n}\r\nstatic void __iomem *xilinx_pcie_map_bus(struct pci_bus *bus,\r\nunsigned int devfn, int where)\r\n{\r\nstruct xilinx_pcie_port *port = bus->sysdata;\r\nint relbus;\r\nif (!xilinx_pcie_valid_device(bus, devfn))\r\nreturn NULL;\r\nrelbus = (bus->number << ECAM_BUS_NUM_SHIFT) |\r\n(devfn << ECAM_DEV_NUM_SHIFT);\r\nreturn port->reg_base + relbus + where;\r\n}\r\nstatic void xilinx_pcie_destroy_msi(unsigned int irq)\r\n{\r\nstruct msi_desc *msi;\r\nstruct xilinx_pcie_port *port;\r\nif (!test_bit(irq, msi_irq_in_use)) {\r\nmsi = irq_get_msi_desc(irq);\r\nport = msi_desc_to_pci_sysdata(msi);\r\ndev_err(port->dev, "Trying to free unused MSI#%d\n", irq);\r\n} else {\r\nclear_bit(irq, msi_irq_in_use);\r\n}\r\n}\r\nstatic int xilinx_pcie_assign_msi(struct xilinx_pcie_port *port)\r\n{\r\nint pos;\r\npos = find_first_zero_bit(msi_irq_in_use, XILINX_NUM_MSI_IRQS);\r\nif (pos < XILINX_NUM_MSI_IRQS)\r\nset_bit(pos, msi_irq_in_use);\r\nelse\r\nreturn -ENOSPC;\r\nreturn pos;\r\n}\r\nstatic void xilinx_msi_teardown_irq(struct msi_controller *chip,\r\nunsigned int irq)\r\n{\r\nxilinx_pcie_destroy_msi(irq);\r\n}\r\nstatic int xilinx_pcie_msi_setup_irq(struct msi_controller *chip,\r\nstruct pci_dev *pdev,\r\nstruct msi_desc *desc)\r\n{\r\nstruct xilinx_pcie_port *port = pdev->bus->sysdata;\r\nunsigned int irq;\r\nint hwirq;\r\nstruct msi_msg msg;\r\nphys_addr_t msg_addr;\r\nhwirq = xilinx_pcie_assign_msi(port);\r\nif (hwirq < 0)\r\nreturn hwirq;\r\nirq = irq_create_mapping(port->irq_domain, hwirq);\r\nif (!irq)\r\nreturn -EINVAL;\r\nirq_set_msi_desc(irq, desc);\r\nmsg_addr = virt_to_phys((void *)port->msi_pages);\r\nmsg.address_hi = 0;\r\nmsg.address_lo = msg_addr;\r\nmsg.data = irq;\r\npci_write_msi_msg(irq, &msg);\r\nreturn 0;\r\n}\r\nstatic int xilinx_pcie_msi_map(struct irq_domain *domain, unsigned int irq,\r\nirq_hw_number_t hwirq)\r\n{\r\nirq_set_chip_and_handler(irq, &xilinx_msi_irq_chip, handle_simple_irq);\r\nirq_set_chip_data(irq, domain->host_data);\r\nreturn 0;\r\n}\r\nstatic void xilinx_pcie_enable_msi(struct xilinx_pcie_port *port)\r\n{\r\nphys_addr_t msg_addr;\r\nport->msi_pages = __get_free_pages(GFP_KERNEL, 0);\r\nmsg_addr = virt_to_phys((void *)port->msi_pages);\r\npcie_write(port, 0x0, XILINX_PCIE_REG_MSIBASE1);\r\npcie_write(port, msg_addr, XILINX_PCIE_REG_MSIBASE2);\r\n}\r\nstatic int xilinx_pcie_intx_map(struct irq_domain *domain, unsigned int irq,\r\nirq_hw_number_t hwirq)\r\n{\r\nirq_set_chip_and_handler(irq, &dummy_irq_chip, handle_simple_irq);\r\nirq_set_chip_data(irq, domain->host_data);\r\nreturn 0;\r\n}\r\nstatic irqreturn_t xilinx_pcie_intr_handler(int irq, void *data)\r\n{\r\nstruct xilinx_pcie_port *port = (struct xilinx_pcie_port *)data;\r\nu32 val, mask, status, msi_data;\r\nval = pcie_read(port, XILINX_PCIE_REG_IDR);\r\nmask = pcie_read(port, XILINX_PCIE_REG_IMR);\r\nstatus = val & mask;\r\nif (!status)\r\nreturn IRQ_NONE;\r\nif (status & XILINX_PCIE_INTR_LINK_DOWN)\r\ndev_warn(port->dev, "Link Down\n");\r\nif (status & XILINX_PCIE_INTR_ECRC_ERR)\r\ndev_warn(port->dev, "ECRC failed\n");\r\nif (status & XILINX_PCIE_INTR_STR_ERR)\r\ndev_warn(port->dev, "Streaming error\n");\r\nif (status & XILINX_PCIE_INTR_HOT_RESET)\r\ndev_info(port->dev, "Hot reset\n");\r\nif (status & XILINX_PCIE_INTR_CFG_TIMEOUT)\r\ndev_warn(port->dev, "ECAM access timeout\n");\r\nif (status & XILINX_PCIE_INTR_CORRECTABLE) {\r\ndev_warn(port->dev, "Correctable error message\n");\r\nxilinx_pcie_clear_err_interrupts(port);\r\n}\r\nif (status & XILINX_PCIE_INTR_NONFATAL) {\r\ndev_warn(port->dev, "Non fatal error message\n");\r\nxilinx_pcie_clear_err_interrupts(port);\r\n}\r\nif (status & XILINX_PCIE_INTR_FATAL) {\r\ndev_warn(port->dev, "Fatal error message\n");\r\nxilinx_pcie_clear_err_interrupts(port);\r\n}\r\nif (status & XILINX_PCIE_INTR_INTX) {\r\nval = pcie_read(port, XILINX_PCIE_REG_RPIFR1);\r\nif (!(val & XILINX_PCIE_RPIFR1_INTR_VALID)) {\r\ndev_warn(port->dev, "RP Intr FIFO1 read error\n");\r\nreturn IRQ_HANDLED;\r\n}\r\nif (!(val & XILINX_PCIE_RPIFR1_MSI_INTR)) {\r\npcie_write(port, XILINX_PCIE_RPIFR1_ALL_MASK,\r\nXILINX_PCIE_REG_RPIFR1);\r\nval = ((val & XILINX_PCIE_RPIFR1_INTR_MASK) >>\r\nXILINX_PCIE_RPIFR1_INTR_SHIFT) + 1;\r\ngeneric_handle_irq(irq_find_mapping(port->irq_domain,\r\nval));\r\n}\r\n}\r\nif (status & XILINX_PCIE_INTR_MSI) {\r\nval = pcie_read(port, XILINX_PCIE_REG_RPIFR1);\r\nif (!(val & XILINX_PCIE_RPIFR1_INTR_VALID)) {\r\ndev_warn(port->dev, "RP Intr FIFO1 read error\n");\r\nreturn IRQ_HANDLED;\r\n}\r\nif (val & XILINX_PCIE_RPIFR1_MSI_INTR) {\r\nmsi_data = pcie_read(port, XILINX_PCIE_REG_RPIFR2) &\r\nXILINX_PCIE_RPIFR2_MSG_DATA;\r\npcie_write(port, XILINX_PCIE_RPIFR1_ALL_MASK,\r\nXILINX_PCIE_REG_RPIFR1);\r\nif (IS_ENABLED(CONFIG_PCI_MSI)) {\r\ngeneric_handle_irq(msi_data);\r\n}\r\n}\r\n}\r\nif (status & XILINX_PCIE_INTR_SLV_UNSUPP)\r\ndev_warn(port->dev, "Slave unsupported request\n");\r\nif (status & XILINX_PCIE_INTR_SLV_UNEXP)\r\ndev_warn(port->dev, "Slave unexpected completion\n");\r\nif (status & XILINX_PCIE_INTR_SLV_COMPL)\r\ndev_warn(port->dev, "Slave completion timeout\n");\r\nif (status & XILINX_PCIE_INTR_SLV_ERRP)\r\ndev_warn(port->dev, "Slave Error Poison\n");\r\nif (status & XILINX_PCIE_INTR_SLV_CMPABT)\r\ndev_warn(port->dev, "Slave Completer Abort\n");\r\nif (status & XILINX_PCIE_INTR_SLV_ILLBUR)\r\ndev_warn(port->dev, "Slave Illegal Burst\n");\r\nif (status & XILINX_PCIE_INTR_MST_DECERR)\r\ndev_warn(port->dev, "Master decode error\n");\r\nif (status & XILINX_PCIE_INTR_MST_SLVERR)\r\ndev_warn(port->dev, "Master slave error\n");\r\nif (status & XILINX_PCIE_INTR_MST_ERRP)\r\ndev_warn(port->dev, "Master error poison\n");\r\npcie_write(port, status, XILINX_PCIE_REG_IDR);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void xilinx_pcie_free_irq_domain(struct xilinx_pcie_port *port)\r\n{\r\nint i;\r\nu32 irq, num_irqs;\r\nif (IS_ENABLED(CONFIG_PCI_MSI)) {\r\nfree_pages(port->msi_pages, 0);\r\nnum_irqs = XILINX_NUM_MSI_IRQS;\r\n} else {\r\nnum_irqs = 4;\r\n}\r\nfor (i = 0; i < num_irqs; i++) {\r\nirq = irq_find_mapping(port->irq_domain, i);\r\nif (irq > 0)\r\nirq_dispose_mapping(irq);\r\n}\r\nirq_domain_remove(port->irq_domain);\r\n}\r\nstatic int xilinx_pcie_init_irq_domain(struct xilinx_pcie_port *port)\r\n{\r\nstruct device *dev = port->dev;\r\nstruct device_node *node = dev->of_node;\r\nstruct device_node *pcie_intc_node;\r\npcie_intc_node = of_get_next_child(node, NULL);\r\nif (!pcie_intc_node) {\r\ndev_err(dev, "No PCIe Intc node found\n");\r\nreturn PTR_ERR(pcie_intc_node);\r\n}\r\nport->irq_domain = irq_domain_add_linear(pcie_intc_node, 4,\r\n&intx_domain_ops,\r\nport);\r\nif (!port->irq_domain) {\r\ndev_err(dev, "Failed to get a INTx IRQ domain\n");\r\nreturn PTR_ERR(port->irq_domain);\r\n}\r\nif (IS_ENABLED(CONFIG_PCI_MSI)) {\r\nport->irq_domain = irq_domain_add_linear(node,\r\nXILINX_NUM_MSI_IRQS,\r\n&msi_domain_ops,\r\n&xilinx_pcie_msi_chip);\r\nif (!port->irq_domain) {\r\ndev_err(dev, "Failed to get a MSI IRQ domain\n");\r\nreturn PTR_ERR(port->irq_domain);\r\n}\r\nxilinx_pcie_enable_msi(port);\r\n}\r\nreturn 0;\r\n}\r\nstatic void xilinx_pcie_init_port(struct xilinx_pcie_port *port)\r\n{\r\nif (xilinx_pcie_link_is_up(port))\r\ndev_info(port->dev, "PCIe Link is UP\n");\r\nelse\r\ndev_info(port->dev, "PCIe Link is DOWN\n");\r\npcie_write(port, ~XILINX_PCIE_IDR_ALL_MASK,\r\nXILINX_PCIE_REG_IMR);\r\npcie_write(port, pcie_read(port, XILINX_PCIE_REG_IDR) &\r\nXILINX_PCIE_IMR_ALL_MASK,\r\nXILINX_PCIE_REG_IDR);\r\npcie_write(port, XILINX_PCIE_IMR_ALL_MASK, XILINX_PCIE_REG_IMR);\r\npcie_write(port, pcie_read(port, XILINX_PCIE_REG_RPSC) |\r\nXILINX_PCIE_REG_RPSC_BEN,\r\nXILINX_PCIE_REG_RPSC);\r\n}\r\nstatic int xilinx_pcie_parse_dt(struct xilinx_pcie_port *port)\r\n{\r\nstruct device *dev = port->dev;\r\nstruct device_node *node = dev->of_node;\r\nstruct resource regs;\r\nconst char *type;\r\nint err;\r\ntype = of_get_property(node, "device_type", NULL);\r\nif (!type || strcmp(type, "pci")) {\r\ndev_err(dev, "invalid \"device_type\" %s\n", type);\r\nreturn -EINVAL;\r\n}\r\nerr = of_address_to_resource(node, 0, &regs);\r\nif (err) {\r\ndev_err(dev, "missing \"reg\" property\n");\r\nreturn err;\r\n}\r\nport->reg_base = devm_ioremap_resource(dev, &regs);\r\nif (IS_ERR(port->reg_base))\r\nreturn PTR_ERR(port->reg_base);\r\nport->irq = irq_of_parse_and_map(node, 0);\r\nerr = devm_request_irq(dev, port->irq, xilinx_pcie_intr_handler,\r\nIRQF_SHARED | IRQF_NO_THREAD,\r\n"xilinx-pcie", port);\r\nif (err) {\r\ndev_err(dev, "unable to request irq %d\n", port->irq);\r\nreturn err;\r\n}\r\nreturn 0;\r\n}\r\nstatic int xilinx_pcie_probe(struct platform_device *pdev)\r\n{\r\nstruct xilinx_pcie_port *port;\r\nstruct device *dev = &pdev->dev;\r\nstruct pci_bus *bus;\r\nint err;\r\nresource_size_t iobase = 0;\r\nLIST_HEAD(res);\r\nif (!dev->of_node)\r\nreturn -ENODEV;\r\nport = devm_kzalloc(dev, sizeof(*port), GFP_KERNEL);\r\nif (!port)\r\nreturn -ENOMEM;\r\nport->dev = dev;\r\nerr = xilinx_pcie_parse_dt(port);\r\nif (err) {\r\ndev_err(dev, "Parsing DT failed\n");\r\nreturn err;\r\n}\r\nxilinx_pcie_init_port(port);\r\nerr = xilinx_pcie_init_irq_domain(port);\r\nif (err) {\r\ndev_err(dev, "Failed creating IRQ Domain\n");\r\nreturn err;\r\n}\r\nerr = of_pci_get_host_bridge_resources(dev->of_node, 0, 0xff, &res,\r\n&iobase);\r\nif (err) {\r\ndev_err(dev, "Getting bridge resources failed\n");\r\nreturn err;\r\n}\r\nbus = pci_create_root_bus(&pdev->dev, 0,\r\n&xilinx_pcie_ops, port, &res);\r\nif (!bus)\r\nreturn -ENOMEM;\r\n#ifdef CONFIG_PCI_MSI\r\nxilinx_pcie_msi_chip.dev = port->dev;\r\nbus->msi = &xilinx_pcie_msi_chip;\r\n#endif\r\npci_scan_child_bus(bus);\r\npci_assign_unassigned_bus_resources(bus);\r\n#ifndef CONFIG_MICROBLAZE\r\npci_fixup_irqs(pci_common_swizzle, of_irq_parse_and_map_pci);\r\n#endif\r\npci_bus_add_devices(bus);\r\nplatform_set_drvdata(pdev, port);\r\nreturn 0;\r\n}\r\nstatic int xilinx_pcie_remove(struct platform_device *pdev)\r\n{\r\nstruct xilinx_pcie_port *port = platform_get_drvdata(pdev);\r\nxilinx_pcie_free_irq_domain(port);\r\nreturn 0;\r\n}
