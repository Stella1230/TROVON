static inline void mei_me_set_pm_domain(struct mei_device *dev) {}\r\nstatic inline void mei_me_unset_pm_domain(struct mei_device *dev) {}\r\nstatic bool mei_me_quirk_probe(struct pci_dev *pdev,\r\nconst struct mei_cfg *cfg)\r\n{\r\nif (cfg->quirk_probe && cfg->quirk_probe(pdev)) {\r\ndev_info(&pdev->dev, "Device doesn't have valid ME Interface\n");\r\nreturn false;\r\n}\r\nreturn true;\r\n}\r\nstatic int mei_me_probe(struct pci_dev *pdev, const struct pci_device_id *ent)\r\n{\r\nconst struct mei_cfg *cfg = (struct mei_cfg *)(ent->driver_data);\r\nstruct mei_device *dev;\r\nstruct mei_me_hw *hw;\r\nunsigned int irqflags;\r\nint err;\r\nif (!mei_me_quirk_probe(pdev, cfg))\r\nreturn -ENODEV;\r\nerr = pci_enable_device(pdev);\r\nif (err) {\r\ndev_err(&pdev->dev, "failed to enable pci device.\n");\r\ngoto end;\r\n}\r\npci_set_master(pdev);\r\nerr = pci_request_regions(pdev, KBUILD_MODNAME);\r\nif (err) {\r\ndev_err(&pdev->dev, "failed to get pci regions.\n");\r\ngoto disable_device;\r\n}\r\nif (dma_set_mask(&pdev->dev, DMA_BIT_MASK(64)) ||\r\ndma_set_coherent_mask(&pdev->dev, DMA_BIT_MASK(64))) {\r\nerr = dma_set_mask(&pdev->dev, DMA_BIT_MASK(32));\r\nif (err)\r\nerr = dma_set_coherent_mask(&pdev->dev,\r\nDMA_BIT_MASK(32));\r\n}\r\nif (err) {\r\ndev_err(&pdev->dev, "No usable DMA configuration, aborting\n");\r\ngoto release_regions;\r\n}\r\ndev = mei_me_dev_init(pdev, cfg);\r\nif (!dev) {\r\nerr = -ENOMEM;\r\ngoto release_regions;\r\n}\r\nhw = to_me_hw(dev);\r\nhw->mem_addr = pci_iomap(pdev, 0, 0);\r\nif (!hw->mem_addr) {\r\ndev_err(&pdev->dev, "mapping I/O device memory failure.\n");\r\nerr = -ENOMEM;\r\ngoto free_device;\r\n}\r\npci_enable_msi(pdev);\r\nirqflags = pci_dev_msi_enabled(pdev) ? IRQF_ONESHOT : IRQF_SHARED;\r\nerr = request_threaded_irq(pdev->irq,\r\nmei_me_irq_quick_handler,\r\nmei_me_irq_thread_handler,\r\nirqflags, KBUILD_MODNAME, dev);\r\nif (err) {\r\ndev_err(&pdev->dev, "request_threaded_irq failure. irq = %d\n",\r\npdev->irq);\r\ngoto disable_msi;\r\n}\r\nif (mei_start(dev)) {\r\ndev_err(&pdev->dev, "init hw failure.\n");\r\nerr = -ENODEV;\r\ngoto release_irq;\r\n}\r\npm_runtime_set_autosuspend_delay(&pdev->dev, MEI_ME_RPM_TIMEOUT);\r\npm_runtime_use_autosuspend(&pdev->dev);\r\nerr = mei_register(dev, &pdev->dev);\r\nif (err)\r\ngoto stop;\r\npci_set_drvdata(pdev, dev);\r\nschedule_delayed_work(&dev->timer_work, HZ);\r\nif (!pci_dev_run_wake(pdev))\r\nmei_me_set_pm_domain(dev);\r\nif (mei_pg_is_enabled(dev))\r\npm_runtime_put_noidle(&pdev->dev);\r\ndev_dbg(&pdev->dev, "initialization successful.\n");\r\nreturn 0;\r\nstop:\r\nmei_stop(dev);\r\nrelease_irq:\r\nmei_cancel_work(dev);\r\nmei_disable_interrupts(dev);\r\nfree_irq(pdev->irq, dev);\r\ndisable_msi:\r\npci_disable_msi(pdev);\r\npci_iounmap(pdev, hw->mem_addr);\r\nfree_device:\r\nkfree(dev);\r\nrelease_regions:\r\npci_release_regions(pdev);\r\ndisable_device:\r\npci_disable_device(pdev);\r\nend:\r\ndev_err(&pdev->dev, "initialization failed.\n");\r\nreturn err;\r\n}\r\nstatic void mei_me_remove(struct pci_dev *pdev)\r\n{\r\nstruct mei_device *dev;\r\nstruct mei_me_hw *hw;\r\ndev = pci_get_drvdata(pdev);\r\nif (!dev)\r\nreturn;\r\nif (mei_pg_is_enabled(dev))\r\npm_runtime_get_noresume(&pdev->dev);\r\nhw = to_me_hw(dev);\r\ndev_dbg(&pdev->dev, "stop\n");\r\nmei_stop(dev);\r\nif (!pci_dev_run_wake(pdev))\r\nmei_me_unset_pm_domain(dev);\r\nmei_disable_interrupts(dev);\r\nfree_irq(pdev->irq, dev);\r\npci_disable_msi(pdev);\r\nif (hw->mem_addr)\r\npci_iounmap(pdev, hw->mem_addr);\r\nmei_deregister(dev);\r\nkfree(dev);\r\npci_release_regions(pdev);\r\npci_disable_device(pdev);\r\n}\r\nstatic int mei_me_pci_suspend(struct device *device)\r\n{\r\nstruct pci_dev *pdev = to_pci_dev(device);\r\nstruct mei_device *dev = pci_get_drvdata(pdev);\r\nif (!dev)\r\nreturn -ENODEV;\r\ndev_dbg(&pdev->dev, "suspend\n");\r\nmei_stop(dev);\r\nmei_disable_interrupts(dev);\r\nfree_irq(pdev->irq, dev);\r\npci_disable_msi(pdev);\r\nreturn 0;\r\n}\r\nstatic int mei_me_pci_resume(struct device *device)\r\n{\r\nstruct pci_dev *pdev = to_pci_dev(device);\r\nstruct mei_device *dev;\r\nunsigned int irqflags;\r\nint err;\r\ndev = pci_get_drvdata(pdev);\r\nif (!dev)\r\nreturn -ENODEV;\r\npci_enable_msi(pdev);\r\nirqflags = pci_dev_msi_enabled(pdev) ? IRQF_ONESHOT : IRQF_SHARED;\r\nerr = request_threaded_irq(pdev->irq,\r\nmei_me_irq_quick_handler,\r\nmei_me_irq_thread_handler,\r\nirqflags, KBUILD_MODNAME, dev);\r\nif (err) {\r\ndev_err(&pdev->dev, "request_threaded_irq failed: irq = %d.\n",\r\npdev->irq);\r\nreturn err;\r\n}\r\nerr = mei_restart(dev);\r\nif (err)\r\nreturn err;\r\nschedule_delayed_work(&dev->timer_work, HZ);\r\nreturn 0;\r\n}\r\nstatic int mei_me_pm_runtime_idle(struct device *device)\r\n{\r\nstruct pci_dev *pdev = to_pci_dev(device);\r\nstruct mei_device *dev;\r\ndev_dbg(&pdev->dev, "rpm: me: runtime_idle\n");\r\ndev = pci_get_drvdata(pdev);\r\nif (!dev)\r\nreturn -ENODEV;\r\nif (mei_write_is_idle(dev))\r\npm_runtime_autosuspend(device);\r\nreturn -EBUSY;\r\n}\r\nstatic int mei_me_pm_runtime_suspend(struct device *device)\r\n{\r\nstruct pci_dev *pdev = to_pci_dev(device);\r\nstruct mei_device *dev;\r\nint ret;\r\ndev_dbg(&pdev->dev, "rpm: me: runtime suspend\n");\r\ndev = pci_get_drvdata(pdev);\r\nif (!dev)\r\nreturn -ENODEV;\r\nmutex_lock(&dev->device_lock);\r\nif (mei_write_is_idle(dev))\r\nret = mei_me_pg_enter_sync(dev);\r\nelse\r\nret = -EAGAIN;\r\nmutex_unlock(&dev->device_lock);\r\ndev_dbg(&pdev->dev, "rpm: me: runtime suspend ret=%d\n", ret);\r\nreturn ret;\r\n}\r\nstatic int mei_me_pm_runtime_resume(struct device *device)\r\n{\r\nstruct pci_dev *pdev = to_pci_dev(device);\r\nstruct mei_device *dev;\r\nint ret;\r\ndev_dbg(&pdev->dev, "rpm: me: runtime resume\n");\r\ndev = pci_get_drvdata(pdev);\r\nif (!dev)\r\nreturn -ENODEV;\r\nmutex_lock(&dev->device_lock);\r\nret = mei_me_pg_exit_sync(dev);\r\nmutex_unlock(&dev->device_lock);\r\ndev_dbg(&pdev->dev, "rpm: me: runtime resume ret = %d\n", ret);\r\nreturn ret;\r\n}\r\nstatic inline void mei_me_set_pm_domain(struct mei_device *dev)\r\n{\r\nstruct pci_dev *pdev = to_pci_dev(dev->dev);\r\nif (pdev->dev.bus && pdev->dev.bus->pm) {\r\ndev->pg_domain.ops = *pdev->dev.bus->pm;\r\ndev->pg_domain.ops.runtime_suspend = mei_me_pm_runtime_suspend;\r\ndev->pg_domain.ops.runtime_resume = mei_me_pm_runtime_resume;\r\ndev->pg_domain.ops.runtime_idle = mei_me_pm_runtime_idle;\r\ndev_pm_domain_set(&pdev->dev, &dev->pg_domain);\r\n}\r\n}\r\nstatic inline void mei_me_unset_pm_domain(struct mei_device *dev)\r\n{\r\ndev_pm_domain_set(dev->dev, NULL);\r\n}
