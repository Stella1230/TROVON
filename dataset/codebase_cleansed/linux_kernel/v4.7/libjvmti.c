static jvmtiError\r\ndo_get_line_numbers(jvmtiEnv *jvmti, void *pc, jmethodID m, jint bci,\r\njvmti_line_info_t *tab, jint *nr)\r\n{\r\njint i, lines = 0;\r\njint nr_lines = 0;\r\njvmtiLineNumberEntry *loc_tab = NULL;\r\njvmtiError ret;\r\nret = (*jvmti)->GetLineNumberTable(jvmti, m, &nr_lines, &loc_tab);\r\nif (ret != JVMTI_ERROR_NONE)\r\nreturn ret;\r\nfor (i = 0; i < nr_lines; i++) {\r\nif (loc_tab[i].start_location < bci) {\r\ntab[lines].pc = (unsigned long)pc;\r\ntab[lines].line_number = loc_tab[i].line_number;\r\ntab[lines].discrim = 0;\r\nlines++;\r\n} else {\r\nbreak;\r\n}\r\n}\r\n(*jvmti)->Deallocate(jvmti, (unsigned char *)loc_tab);\r\n*nr = lines;\r\nreturn JVMTI_ERROR_NONE;\r\n}\r\nstatic jvmtiError\r\nget_line_numbers(jvmtiEnv *jvmti, const void *compile_info, jvmti_line_info_t **tab, int *nr_lines)\r\n{\r\nconst jvmtiCompiledMethodLoadRecordHeader *hdr;\r\njvmtiCompiledMethodLoadInlineRecord *rec;\r\njvmtiLineNumberEntry *lne = NULL;\r\nPCStackInfo *c;\r\njint nr, ret;\r\nint nr_total = 0;\r\nint i, lines_total = 0;\r\nif (!(tab && nr_lines))\r\nreturn JVMTI_ERROR_NULL_POINTER;\r\nfor (hdr = compile_info; hdr != NULL; hdr = hdr->next) {\r\nif (hdr->kind == JVMTI_CMLR_INLINE_INFO) {\r\nrec = (jvmtiCompiledMethodLoadInlineRecord *)hdr;\r\nfor (i = 0; i < rec->numpcs; i++) {\r\nc = rec->pcinfo + i;\r\nnr = 0;\r\nret = (*jvmti)->GetLineNumberTable(jvmti, c->methods[0], &nr, &lne);\r\nif (ret == JVMTI_ERROR_NONE) {\r\n(*jvmti)->Deallocate(jvmti, (unsigned char *)lne);\r\nnr_total += (int)nr;\r\n}\r\n}\r\n}\r\n}\r\nif (nr_total == 0)\r\nreturn JVMTI_ERROR_NOT_FOUND;\r\n*tab = malloc(nr_total * sizeof(**tab));\r\nif (!*tab)\r\nreturn JVMTI_ERROR_OUT_OF_MEMORY;\r\nfor (hdr = compile_info; hdr != NULL; hdr = hdr->next) {\r\nif (hdr->kind == JVMTI_CMLR_INLINE_INFO) {\r\nrec = (jvmtiCompiledMethodLoadInlineRecord *)hdr;\r\nfor (i = 0; i < rec->numpcs; i++) {\r\nc = rec->pcinfo + i;\r\nnr = 0;\r\nret = do_get_line_numbers(jvmti, c->pc,\r\nc->methods[0],\r\nc->bcis[0],\r\n*tab + lines_total,\r\n&nr);\r\nif (ret == JVMTI_ERROR_NONE)\r\nlines_total += nr;\r\n}\r\n}\r\n}\r\n*nr_lines = lines_total;\r\nreturn JVMTI_ERROR_NONE;\r\n}\r\nstatic void JNICALL\r\ncompiled_method_load_cb(jvmtiEnv *jvmti,\r\njmethodID method,\r\njint code_size,\r\nvoid const *code_addr,\r\njint map_length,\r\njvmtiAddrLocationMap const *map,\r\nconst void *compile_info)\r\n{\r\njvmti_line_info_t *line_tab = NULL;\r\njclass decl_class;\r\nchar *class_sign = NULL;\r\nchar *func_name = NULL;\r\nchar *func_sign = NULL;\r\nchar *file_name= NULL;\r\nchar fn[PATH_MAX];\r\nuint64_t addr = (uint64_t)(uintptr_t)code_addr;\r\njvmtiError ret;\r\nint nr_lines = 0;\r\nsize_t len;\r\nret = (*jvmti)->GetMethodDeclaringClass(jvmti, method,\r\n&decl_class);\r\nif (ret != JVMTI_ERROR_NONE) {\r\nwarnx("jvmti: cannot get declaring class");\r\nreturn;\r\n}\r\nif (has_line_numbers && map && map_length) {\r\nret = get_line_numbers(jvmti, compile_info, &line_tab, &nr_lines);\r\nif (ret != JVMTI_ERROR_NONE) {\r\nwarnx("jvmti: cannot get line table for method");\r\nnr_lines = 0;\r\n}\r\n}\r\nret = (*jvmti)->GetSourceFileName(jvmti, decl_class, &file_name);\r\nif (ret != JVMTI_ERROR_NONE) {\r\nwarnx("jvmti: cannot get source filename ret=%d", ret);\r\ngoto error;\r\n}\r\nret = (*jvmti)->GetClassSignature(jvmti, decl_class,\r\n&class_sign, NULL);\r\nif (ret != JVMTI_ERROR_NONE) {\r\nwarnx("jvmti: getclassignature failed");\r\ngoto error;\r\n}\r\nret = (*jvmti)->GetMethodName(jvmti, method, &func_name,\r\n&func_sign, NULL);\r\nif (ret != JVMTI_ERROR_NONE) {\r\nwarnx("jvmti: failed getmethodname");\r\ngoto error;\r\n}\r\nif (*class_sign == 'L') {\r\nint j, i = 0;\r\nchar *p = strrchr(class_sign, '/');\r\nif (p) {\r\nfor (i = 0; i < (p - class_sign); i++)\r\nfn[i] = class_sign[i+1];\r\n}\r\nfor (j = 0; i < (PATH_MAX - 1) && file_name && j < strlen(file_name); j++, i++)\r\nfn[i] = file_name[j];\r\nfn[i] = '\0';\r\n} else {\r\nstrcpy(fn, file_name);\r\n}\r\nif (jvmti_write_debug_info(jvmti_agent, addr, fn, line_tab, nr_lines))\r\nwarnx("jvmti: write_debug_info() failed");\r\nlen = strlen(func_name) + strlen(class_sign) + strlen(func_sign) + 2;\r\n{\r\nchar str[len];\r\nsnprintf(str, len, "%s%s%s", class_sign, func_name, func_sign);\r\nif (jvmti_write_code(jvmti_agent, str, addr, code_addr, code_size))\r\nwarnx("jvmti: write_code() failed");\r\n}\r\nerror:\r\n(*jvmti)->Deallocate(jvmti, (unsigned char *)func_name);\r\n(*jvmti)->Deallocate(jvmti, (unsigned char *)func_sign);\r\n(*jvmti)->Deallocate(jvmti, (unsigned char *)class_sign);\r\n(*jvmti)->Deallocate(jvmti, (unsigned char *)file_name);\r\nfree(line_tab);\r\n}\r\nstatic void JNICALL\r\ncode_generated_cb(jvmtiEnv *jvmti,\r\nchar const *name,\r\nvoid const *code_addr,\r\njint code_size)\r\n{\r\nuint64_t addr = (uint64_t)(unsigned long)code_addr;\r\nint ret;\r\nret = jvmti_write_code(jvmti_agent, name, addr, code_addr, code_size);\r\nif (ret)\r\nwarnx("jvmti: write_code() failed for code_generated");\r\n}\r\nJNIEXPORT jint JNICALL\r\nAgent_OnLoad(JavaVM *jvm, char *options, void *reserved __unused)\r\n{\r\njvmtiEventCallbacks cb;\r\njvmtiCapabilities caps1;\r\njvmtiJlocationFormat format;\r\njvmtiEnv *jvmti = NULL;\r\njint ret;\r\njvmti_agent = jvmti_open();\r\nif (!jvmti_agent) {\r\nwarnx("jvmti: open_agent failed");\r\nreturn -1;\r\n}\r\nret = (*jvm)->GetEnv(jvm, (void *)&jvmti, JVMTI_VERSION_1);\r\nif (ret != JNI_OK) {\r\nwarnx("jvmti: jvmti version 1 not supported");\r\nreturn -1;\r\n}\r\nmemset(&caps1, 0, sizeof(caps1));\r\ncaps1.can_generate_compiled_method_load_events = 1;\r\nret = (*jvmti)->AddCapabilities(jvmti, &caps1);\r\nif (ret != JVMTI_ERROR_NONE) {\r\nwarnx("jvmti: acquire compiled_method capability failed");\r\nreturn -1;\r\n}\r\nret = (*jvmti)->GetJLocationFormat(jvmti, &format);\r\nif (ret == JVMTI_ERROR_NONE && format == JVMTI_JLOCATION_JVMBCI) {\r\nmemset(&caps1, 0, sizeof(caps1));\r\ncaps1.can_get_line_numbers = 1;\r\ncaps1.can_get_source_file_name = 1;\r\nret = (*jvmti)->AddCapabilities(jvmti, &caps1);\r\nif (ret == JVMTI_ERROR_NONE)\r\nhas_line_numbers = 1;\r\n}\r\nmemset(&cb, 0, sizeof(cb));\r\ncb.CompiledMethodLoad = compiled_method_load_cb;\r\ncb.DynamicCodeGenerated = code_generated_cb;\r\nret = (*jvmti)->SetEventCallbacks(jvmti, &cb, sizeof(cb));\r\nif (ret != JVMTI_ERROR_NONE) {\r\nwarnx("jvmti: cannot set event callbacks");\r\nreturn -1;\r\n}\r\nret = (*jvmti)->SetEventNotificationMode(jvmti, JVMTI_ENABLE,\r\nJVMTI_EVENT_COMPILED_METHOD_LOAD, NULL);\r\nif (ret != JVMTI_ERROR_NONE) {\r\nwarnx("jvmti: setnotification failed for method_load");\r\nreturn -1;\r\n}\r\nret = (*jvmti)->SetEventNotificationMode(jvmti, JVMTI_ENABLE,\r\nJVMTI_EVENT_DYNAMIC_CODE_GENERATED, NULL);\r\nif (ret != JVMTI_ERROR_NONE) {\r\nwarnx("jvmti: setnotification failed on code_generated");\r\nreturn -1;\r\n}\r\nreturn 0;\r\n}\r\nJNIEXPORT void JNICALL\r\nAgent_OnUnload(JavaVM *jvm __unused)\r\n{\r\nint ret;\r\nret = jvmti_close(jvmti_agent);\r\nif (ret)\r\nerrx(1, "Error: op_close_agent()");\r\n}
