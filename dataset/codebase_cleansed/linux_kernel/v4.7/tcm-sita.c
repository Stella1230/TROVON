static void free_slots(unsigned long pos, uint16_t w, uint16_t h,\r\nunsigned long *map, uint16_t stride)\r\n{\r\nint i;\r\nfor (i = 0; i < h; i++, pos += stride)\r\nbitmap_clear(map, pos, w);\r\n}\r\nstatic int r2l_b2t_1d(uint16_t w, unsigned long *pos, unsigned long *map,\r\nsize_t num_bits)\r\n{\r\nunsigned long search_count = 0;\r\nunsigned long bit;\r\nbool area_found = false;\r\n*pos = num_bits - w;\r\nwhile (search_count < num_bits) {\r\nbit = find_next_bit(map, num_bits, *pos);\r\nif (bit - *pos >= w) {\r\nbitmap_set(map, *pos, w);\r\narea_found = true;\r\nbreak;\r\n}\r\nsearch_count = num_bits - bit + w;\r\n*pos = bit - w;\r\n}\r\nreturn (area_found) ? 0 : -ENOMEM;\r\n}\r\nstatic int l2r_t2b(uint16_t w, uint16_t h, uint16_t a, int16_t offset,\r\nunsigned long *pos, unsigned long slot_bytes,\r\nunsigned long *map, size_t num_bits, size_t slot_stride)\r\n{\r\nint i;\r\nunsigned long index;\r\nbool area_free;\r\nunsigned long slots_per_band = PAGE_SIZE / slot_bytes;\r\nunsigned long bit_offset = (offset > 0) ? offset / slot_bytes : 0;\r\nunsigned long curr_bit = bit_offset;\r\na = (offset > 0) ? 0 : a - 1;\r\nwhile (curr_bit < num_bits) {\r\n*pos = bitmap_find_next_zero_area(map, num_bits, curr_bit, w,\r\na);\r\nif (bit_offset > 0 && (*pos % slots_per_band != bit_offset)) {\r\ncurr_bit = ALIGN(*pos, slots_per_band) + bit_offset;\r\ncontinue;\r\n}\r\nif ((*pos % slot_stride) + w > slot_stride) {\r\ncurr_bit = ALIGN(*pos, slot_stride) + bit_offset;\r\ncontinue;\r\n}\r\nif ((*pos + slot_stride * h) > num_bits)\r\nbreak;\r\nbitmap_clear(mask, 0, slot_stride);\r\nbitmap_set(mask, (*pos % BITS_PER_LONG), w);\r\narea_free = true;\r\nfor (i = 1; i < h; i++) {\r\nindex = *pos / BITS_PER_LONG + i * 8;\r\nif (bitmap_intersects(&map[index], mask,\r\n(*pos % BITS_PER_LONG) + w)) {\r\narea_free = false;\r\nbreak;\r\n}\r\n}\r\nif (area_free)\r\nbreak;\r\nif (bit_offset > 0)\r\ncurr_bit = ALIGN(*pos, slots_per_band) + bit_offset;\r\nelse\r\ncurr_bit = *pos + a + 1;\r\n}\r\nif (area_free) {\r\nfor (i = 0, index = *pos; i < h; i++, index += slot_stride)\r\nbitmap_set(map, index, w);\r\n}\r\nreturn (area_free) ? 0 : -ENOMEM;\r\n}\r\nstatic s32 sita_reserve_1d(struct tcm *tcm, u32 num_slots,\r\nstruct tcm_area *area)\r\n{\r\nunsigned long pos;\r\nint ret;\r\nspin_lock(&(tcm->lock));\r\nret = r2l_b2t_1d(num_slots, &pos, tcm->bitmap, tcm->map_size);\r\nif (!ret) {\r\narea->p0.x = pos % tcm->width;\r\narea->p0.y = pos / tcm->width;\r\narea->p1.x = (pos + num_slots - 1) % tcm->width;\r\narea->p1.y = (pos + num_slots - 1) / tcm->width;\r\n}\r\nspin_unlock(&(tcm->lock));\r\nreturn ret;\r\n}\r\nstatic s32 sita_reserve_2d(struct tcm *tcm, u16 h, u16 w, u16 align,\r\nint16_t offset, uint16_t slot_bytes,\r\nstruct tcm_area *area)\r\n{\r\nunsigned long pos;\r\nint ret;\r\nspin_lock(&(tcm->lock));\r\nret = l2r_t2b(w, h, align, offset, &pos, slot_bytes, tcm->bitmap,\r\ntcm->map_size, tcm->width);\r\nif (!ret) {\r\narea->p0.x = pos % tcm->width;\r\narea->p0.y = pos / tcm->width;\r\narea->p1.x = area->p0.x + w - 1;\r\narea->p1.y = area->p0.y + h - 1;\r\n}\r\nspin_unlock(&(tcm->lock));\r\nreturn ret;\r\n}\r\nstatic void sita_deinit(struct tcm *tcm)\r\n{\r\nkfree(tcm);\r\n}\r\nstatic s32 sita_free(struct tcm *tcm, struct tcm_area *area)\r\n{\r\nunsigned long pos;\r\nuint16_t w, h;\r\npos = area->p0.x + area->p0.y * tcm->width;\r\nif (area->is2d) {\r\nw = area->p1.x - area->p0.x + 1;\r\nh = area->p1.y - area->p0.y + 1;\r\n} else {\r\nw = area->p1.x + area->p1.y * tcm->width - pos + 1;\r\nh = 1;\r\n}\r\nspin_lock(&(tcm->lock));\r\nfree_slots(pos, w, h, tcm->bitmap, tcm->width);\r\nspin_unlock(&(tcm->lock));\r\nreturn 0;\r\n}\r\nstruct tcm *sita_init(u16 width, u16 height)\r\n{\r\nstruct tcm *tcm;\r\nsize_t map_size = BITS_TO_LONGS(width*height) * sizeof(unsigned long);\r\nif (width == 0 || height == 0)\r\nreturn NULL;\r\ntcm = kzalloc(sizeof(*tcm) + map_size, GFP_KERNEL);\r\nif (!tcm)\r\ngoto error;\r\ntcm->height = height;\r\ntcm->width = width;\r\ntcm->reserve_2d = sita_reserve_2d;\r\ntcm->reserve_1d = sita_reserve_1d;\r\ntcm->free = sita_free;\r\ntcm->deinit = sita_deinit;\r\nspin_lock_init(&tcm->lock);\r\ntcm->bitmap = (unsigned long *)(tcm + 1);\r\nbitmap_clear(tcm->bitmap, 0, width*height);\r\ntcm->map_size = width*height;\r\nreturn tcm;\r\nerror:\r\nkfree(tcm);\r\nreturn NULL;\r\n}
