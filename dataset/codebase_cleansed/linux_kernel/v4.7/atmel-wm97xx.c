static irqreturn_t atmel_wm97xx_channel_b_interrupt(int irq, void *dev_id)\r\n{\r\nstruct atmel_wm97xx *atmel_wm97xx = dev_id;\r\nstruct wm97xx *wm = atmel_wm97xx->wm;\r\nint status = ac97c_readl(atmel_wm97xx, CBSR);\r\nirqreturn_t retval = IRQ_NONE;\r\nif (status & AC97C_OVRUN) {\r\ndev_dbg(&wm->touch_dev->dev, "AC97C overrun\n");\r\nac97c_readl(atmel_wm97xx, CBRHR);\r\nretval = IRQ_HANDLED;\r\n} else if (status & AC97C_RXRDY) {\r\nu16 data;\r\nu16 value;\r\nu16 source;\r\nu16 pen_down;\r\ndata = ac97c_readl(atmel_wm97xx, CBRHR);\r\nvalue = data & 0x0fff;\r\nsource = data & WM97XX_ADCSEL_MASK;\r\npen_down = (data & WM97XX_PEN_DOWN) >> 8;\r\nif (source == WM97XX_ADCSEL_X)\r\natmel_wm97xx->x = value;\r\nif (source == WM97XX_ADCSEL_Y)\r\natmel_wm97xx->y = value;\r\nif (!pressure && source == WM97XX_ADCSEL_Y) {\r\ninput_report_abs(wm->input_dev, ABS_X, atmel_wm97xx->x);\r\ninput_report_abs(wm->input_dev, ABS_Y, atmel_wm97xx->y);\r\ninput_report_key(wm->input_dev, BTN_TOUCH, pen_down);\r\ninput_sync(wm->input_dev);\r\n} else if (pressure && source == WM97XX_ADCSEL_PRES) {\r\ninput_report_abs(wm->input_dev, ABS_X, atmel_wm97xx->x);\r\ninput_report_abs(wm->input_dev, ABS_Y, atmel_wm97xx->y);\r\ninput_report_abs(wm->input_dev, ABS_PRESSURE, value);\r\ninput_report_key(wm->input_dev, BTN_TOUCH, value);\r\ninput_sync(wm->input_dev);\r\n}\r\nretval = IRQ_HANDLED;\r\n}\r\nreturn retval;\r\n}\r\nstatic void atmel_wm97xx_acc_pen_up(struct wm97xx *wm)\r\n{\r\nstruct atmel_wm97xx *atmel_wm97xx = platform_get_drvdata(wm->touch_dev);\r\nstruct input_dev *input_dev = wm->input_dev;\r\nint pen_down = gpio_get_value(atmel_wm97xx->gpio_pen);\r\nif (pen_down != 0) {\r\nmod_timer(&atmel_wm97xx->pen_timer,\r\njiffies + msecs_to_jiffies(1));\r\n} else {\r\nif (pressure)\r\ninput_report_abs(input_dev, ABS_PRESSURE, 0);\r\ninput_report_key(input_dev, BTN_TOUCH, 0);\r\ninput_sync(input_dev);\r\n}\r\n}\r\nstatic void atmel_wm97xx_pen_timer(unsigned long data)\r\n{\r\natmel_wm97xx_acc_pen_up((struct wm97xx *)data);\r\n}\r\nstatic int atmel_wm97xx_acc_startup(struct wm97xx *wm)\r\n{\r\nstruct atmel_wm97xx *atmel_wm97xx = platform_get_drvdata(wm->touch_dev);\r\nint idx = 0;\r\nif (wm->ac97 == NULL)\r\nreturn -ENODEV;\r\nfor (idx = 0; idx < ARRAY_SIZE(cinfo); idx++) {\r\nif (wm->id != cinfo[idx].id)\r\ncontinue;\r\nsp_idx = idx;\r\nif (cont_rate <= cinfo[idx].speed)\r\nbreak;\r\n}\r\nwm->acc_rate = cinfo[sp_idx].code;\r\nwm->acc_slot = ac97_touch_slot;\r\ndev_info(&wm->touch_dev->dev, "atmel accelerated touchscreen driver, "\r\n"%d samples/sec\n", cinfo[sp_idx].speed);\r\nif (pen_int) {\r\nunsigned long reg;\r\nwm->pen_irq = atmel_wm97xx->gpio_irq;\r\nswitch (wm->id) {\r\ncase WM9712_ID2:\r\ncase WM9713_ID2:\r\nwm97xx_config_gpio(wm, WM97XX_GPIO_13, WM97XX_GPIO_IN,\r\nWM97XX_GPIO_POL_HIGH,\r\nWM97XX_GPIO_STICKY,\r\nWM97XX_GPIO_WAKE);\r\nwm97xx_config_gpio(wm, WM97XX_GPIO_3, WM97XX_GPIO_OUT,\r\nWM97XX_GPIO_POL_HIGH,\r\nWM97XX_GPIO_NOTSTICKY,\r\nWM97XX_GPIO_NOWAKE);\r\ncase WM9705_ID2:\r\nreg = ac97c_readl(atmel_wm97xx, ICA);\r\nreg &= ~AC97C_CH_MASK(wm->acc_slot);\r\nreg |= AC97C_CH_ASSIGN(wm->acc_slot, B);\r\nac97c_writel(atmel_wm97xx, ICA, reg);\r\nac97c_writel(atmel_wm97xx, CBMR, AC97C_CMR_CENA\r\n| AC97C_CMR_CEM_BIG\r\n| AC97C_CMR_SIZE_16\r\n| AC97C_OVRUN\r\n| AC97C_RXRDY);\r\nac97c_readl(atmel_wm97xx, CBRHR);\r\nac97c_writel(atmel_wm97xx, IER, AC97C_INT_CBEVT);\r\nbreak;\r\ndefault:\r\ndev_err(&wm->touch_dev->dev, "pen down irq not "\r\n"supported on this device\n");\r\npen_int = 0;\r\nbreak;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic void atmel_wm97xx_acc_shutdown(struct wm97xx *wm)\r\n{\r\nif (pen_int) {\r\nstruct atmel_wm97xx *atmel_wm97xx =\r\nplatform_get_drvdata(wm->touch_dev);\r\nunsigned long ica;\r\nswitch (wm->id & 0xffff) {\r\ncase WM9705_ID2:\r\ncase WM9712_ID2:\r\ncase WM9713_ID2:\r\nica = ac97c_readl(atmel_wm97xx, ICA);\r\nica &= ~AC97C_CH_MASK(wm->acc_slot);\r\nac97c_writel(atmel_wm97xx, ICA, ica);\r\nac97c_writel(atmel_wm97xx, IDR, AC97C_INT_CBEVT);\r\nac97c_writel(atmel_wm97xx, CBMR, 0);\r\nwm->pen_irq = 0;\r\nbreak;\r\ndefault:\r\ndev_err(&wm->touch_dev->dev, "unknown codec\n");\r\nbreak;\r\n}\r\n}\r\n}\r\nstatic void atmel_wm97xx_irq_enable(struct wm97xx *wm, int enable)\r\n{\r\n}\r\nstatic int __init atmel_wm97xx_probe(struct platform_device *pdev)\r\n{\r\nstruct wm97xx *wm = platform_get_drvdata(pdev);\r\nstruct atmel_wm97xx *atmel_wm97xx;\r\nint ret;\r\natmel_wm97xx = kzalloc(sizeof(struct atmel_wm97xx), GFP_KERNEL);\r\nif (!atmel_wm97xx) {\r\ndev_dbg(&pdev->dev, "out of memory\n");\r\nreturn -ENOMEM;\r\n}\r\natmel_wm97xx->wm = wm;\r\natmel_wm97xx->regs = (void *)ATMEL_WM97XX_AC97C_IOMEM;\r\natmel_wm97xx->ac97c_irq = ATMEL_WM97XX_AC97C_IRQ;\r\natmel_wm97xx->gpio_pen = atmel_gpio_line;\r\natmel_wm97xx->gpio_irq = gpio_to_irq(atmel_wm97xx->gpio_pen);\r\nsetup_timer(&atmel_wm97xx->pen_timer, atmel_wm97xx_pen_timer,\r\n(unsigned long)wm);\r\nret = request_irq(atmel_wm97xx->ac97c_irq,\r\natmel_wm97xx_channel_b_interrupt,\r\nIRQF_SHARED, "atmel-wm97xx-ch-b", atmel_wm97xx);\r\nif (ret) {\r\ndev_dbg(&pdev->dev, "could not request ac97c irq\n");\r\ngoto err;\r\n}\r\nplatform_set_drvdata(pdev, atmel_wm97xx);\r\nret = wm97xx_register_mach_ops(wm, &atmel_mach_ops);\r\nif (ret)\r\ngoto err_irq;\r\nreturn ret;\r\nerr_irq:\r\nfree_irq(atmel_wm97xx->ac97c_irq, atmel_wm97xx);\r\nerr:\r\nkfree(atmel_wm97xx);\r\nreturn ret;\r\n}\r\nstatic int __exit atmel_wm97xx_remove(struct platform_device *pdev)\r\n{\r\nstruct atmel_wm97xx *atmel_wm97xx = platform_get_drvdata(pdev);\r\nstruct wm97xx *wm = atmel_wm97xx->wm;\r\nac97c_writel(atmel_wm97xx, IDR, AC97C_INT_CBEVT);\r\nfree_irq(atmel_wm97xx->ac97c_irq, atmel_wm97xx);\r\ndel_timer_sync(&atmel_wm97xx->pen_timer);\r\nwm97xx_unregister_mach_ops(wm);\r\nkfree(atmel_wm97xx);\r\nreturn 0;\r\n}\r\nstatic int atmel_wm97xx_suspend(struct device *dev)\r\n{\r\nstruct platform_device *pdev = to_platform_device(dev);\r\nstruct atmel_wm97xx *atmel_wm97xx = platform_get_drvdata(pdev);\r\nac97c_writel(atmel_wm97xx, IDR, AC97C_INT_CBEVT);\r\ndisable_irq(atmel_wm97xx->gpio_irq);\r\ndel_timer_sync(&atmel_wm97xx->pen_timer);\r\nreturn 0;\r\n}\r\nstatic int atmel_wm97xx_resume(struct device *dev)\r\n{\r\nstruct platform_device *pdev = to_platform_device(dev);\r\nstruct atmel_wm97xx *atmel_wm97xx = platform_get_drvdata(pdev);\r\nstruct wm97xx *wm = atmel_wm97xx->wm;\r\nif (wm->input_dev->users) {\r\nenable_irq(atmel_wm97xx->gpio_irq);\r\nac97c_writel(atmel_wm97xx, IER, AC97C_INT_CBEVT);\r\n}\r\nreturn 0;\r\n}
