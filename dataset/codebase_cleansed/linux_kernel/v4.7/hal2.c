static inline u32 hal2_read(u32 *reg)\r\n{\r\nreturn __raw_readl(reg);\r\n}\r\nstatic inline void hal2_write(u32 val, u32 *reg)\r\n{\r\n__raw_writel(val, reg);\r\n}\r\nstatic u32 hal2_i_read32(struct snd_hal2 *hal2, u16 addr)\r\n{\r\nu32 ret;\r\nstruct hal2_ctl_regs *regs = hal2->ctl_regs;\r\nhal2_write(H2_READ_ADDR(addr), &regs->iar);\r\nH2_INDIRECT_WAIT(regs);\r\nret = hal2_read(&regs->idr0) & 0xffff;\r\nhal2_write(H2_READ_ADDR(addr) | 0x1, &regs->iar);\r\nH2_INDIRECT_WAIT(regs);\r\nret |= (hal2_read(&regs->idr0) & 0xffff) << 16;\r\nreturn ret;\r\n}\r\nstatic void hal2_i_write16(struct snd_hal2 *hal2, u16 addr, u16 val)\r\n{\r\nstruct hal2_ctl_regs *regs = hal2->ctl_regs;\r\nhal2_write(val, &regs->idr0);\r\nhal2_write(0, &regs->idr1);\r\nhal2_write(0, &regs->idr2);\r\nhal2_write(0, &regs->idr3);\r\nhal2_write(H2_WRITE_ADDR(addr), &regs->iar);\r\nH2_INDIRECT_WAIT(regs);\r\n}\r\nstatic void hal2_i_write32(struct snd_hal2 *hal2, u16 addr, u32 val)\r\n{\r\nstruct hal2_ctl_regs *regs = hal2->ctl_regs;\r\nhal2_write(val & 0xffff, &regs->idr0);\r\nhal2_write(val >> 16, &regs->idr1);\r\nhal2_write(0, &regs->idr2);\r\nhal2_write(0, &regs->idr3);\r\nhal2_write(H2_WRITE_ADDR(addr), &regs->iar);\r\nH2_INDIRECT_WAIT(regs);\r\n}\r\nstatic void hal2_i_setbit16(struct snd_hal2 *hal2, u16 addr, u16 bit)\r\n{\r\nstruct hal2_ctl_regs *regs = hal2->ctl_regs;\r\nhal2_write(H2_READ_ADDR(addr), &regs->iar);\r\nH2_INDIRECT_WAIT(regs);\r\nhal2_write((hal2_read(&regs->idr0) & 0xffff) | bit, &regs->idr0);\r\nhal2_write(0, &regs->idr1);\r\nhal2_write(0, &regs->idr2);\r\nhal2_write(0, &regs->idr3);\r\nhal2_write(H2_WRITE_ADDR(addr), &regs->iar);\r\nH2_INDIRECT_WAIT(regs);\r\n}\r\nstatic void hal2_i_clearbit16(struct snd_hal2 *hal2, u16 addr, u16 bit)\r\n{\r\nstruct hal2_ctl_regs *regs = hal2->ctl_regs;\r\nhal2_write(H2_READ_ADDR(addr), &regs->iar);\r\nH2_INDIRECT_WAIT(regs);\r\nhal2_write((hal2_read(&regs->idr0) & 0xffff) & ~bit, &regs->idr0);\r\nhal2_write(0, &regs->idr1);\r\nhal2_write(0, &regs->idr2);\r\nhal2_write(0, &regs->idr3);\r\nhal2_write(H2_WRITE_ADDR(addr), &regs->iar);\r\nH2_INDIRECT_WAIT(regs);\r\n}\r\nstatic int hal2_gain_info(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_info *uinfo)\r\n{\r\nuinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;\r\nuinfo->count = 2;\r\nuinfo->value.integer.min = 0;\r\nswitch ((int)kcontrol->private_value) {\r\ncase H2_MIX_OUTPUT_ATT:\r\nuinfo->value.integer.max = 31;\r\nbreak;\r\ncase H2_MIX_INPUT_GAIN:\r\nuinfo->value.integer.max = 15;\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic int hal2_gain_get(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_hal2 *hal2 = snd_kcontrol_chip(kcontrol);\r\nu32 tmp;\r\nint l, r;\r\nswitch ((int)kcontrol->private_value) {\r\ncase H2_MIX_OUTPUT_ATT:\r\ntmp = hal2_i_read32(hal2, H2I_DAC_C2);\r\nif (tmp & H2I_C2_MUTE) {\r\nl = 0;\r\nr = 0;\r\n} else {\r\nl = 31 - ((tmp >> H2I_C2_L_ATT_SHIFT) & 31);\r\nr = 31 - ((tmp >> H2I_C2_R_ATT_SHIFT) & 31);\r\n}\r\nbreak;\r\ncase H2_MIX_INPUT_GAIN:\r\ntmp = hal2_i_read32(hal2, H2I_ADC_C2);\r\nl = (tmp >> H2I_C2_L_GAIN_SHIFT) & 15;\r\nr = (tmp >> H2I_C2_R_GAIN_SHIFT) & 15;\r\nbreak;\r\n}\r\nucontrol->value.integer.value[0] = l;\r\nucontrol->value.integer.value[1] = r;\r\nreturn 0;\r\n}\r\nstatic int hal2_gain_put(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_hal2 *hal2 = snd_kcontrol_chip(kcontrol);\r\nu32 old, new;\r\nint l, r;\r\nl = ucontrol->value.integer.value[0];\r\nr = ucontrol->value.integer.value[1];\r\nswitch ((int)kcontrol->private_value) {\r\ncase H2_MIX_OUTPUT_ATT:\r\nold = hal2_i_read32(hal2, H2I_DAC_C2);\r\nnew = old & ~(H2I_C2_L_ATT_M | H2I_C2_R_ATT_M | H2I_C2_MUTE);\r\nif (l | r) {\r\nl = 31 - l;\r\nr = 31 - r;\r\nnew |= (l << H2I_C2_L_ATT_SHIFT);\r\nnew |= (r << H2I_C2_R_ATT_SHIFT);\r\n} else\r\nnew |= H2I_C2_L_ATT_M | H2I_C2_R_ATT_M | H2I_C2_MUTE;\r\nhal2_i_write32(hal2, H2I_DAC_C2, new);\r\nbreak;\r\ncase H2_MIX_INPUT_GAIN:\r\nold = hal2_i_read32(hal2, H2I_ADC_C2);\r\nnew = old & ~(H2I_C2_L_GAIN_M | H2I_C2_R_GAIN_M);\r\nnew |= (l << H2I_C2_L_GAIN_SHIFT);\r\nnew |= (r << H2I_C2_R_GAIN_SHIFT);\r\nhal2_i_write32(hal2, H2I_ADC_C2, new);\r\nbreak;\r\n}\r\nreturn old != new;\r\n}\r\nstatic int hal2_mixer_create(struct snd_hal2 *hal2)\r\n{\r\nint err;\r\nhal2_i_write32(hal2, H2I_DAC_C2,\r\nH2I_C2_L_ATT_M | H2I_C2_R_ATT_M | H2I_C2_MUTE);\r\nhal2_i_write32(hal2, H2I_ADC_C2, 0);\r\nerr = snd_ctl_add(hal2->card,\r\nsnd_ctl_new1(&hal2_ctrl_headphone, hal2));\r\nif (err < 0)\r\nreturn err;\r\nerr = snd_ctl_add(hal2->card,\r\nsnd_ctl_new1(&hal2_ctrl_mic, hal2));\r\nif (err < 0)\r\nreturn err;\r\nreturn 0;\r\n}\r\nstatic irqreturn_t hal2_interrupt(int irq, void *dev_id)\r\n{\r\nstruct snd_hal2 *hal2 = dev_id;\r\nirqreturn_t ret = IRQ_NONE;\r\nif (hal2->dac.pbus.pbus->pbdma_ctrl & HPC3_PDMACTRL_INT) {\r\nsnd_pcm_period_elapsed(hal2->dac.substream);\r\nret = IRQ_HANDLED;\r\n}\r\nif (hal2->adc.pbus.pbus->pbdma_ctrl & HPC3_PDMACTRL_INT) {\r\nsnd_pcm_period_elapsed(hal2->adc.substream);\r\nret = IRQ_HANDLED;\r\n}\r\nreturn ret;\r\n}\r\nstatic int hal2_compute_rate(struct hal2_codec *codec, unsigned int rate)\r\n{\r\nunsigned short mod;\r\nif (44100 % rate < 48000 % rate) {\r\nmod = 4 * 44100 / rate;\r\ncodec->master = 44100;\r\n} else {\r\nmod = 4 * 48000 / rate;\r\ncodec->master = 48000;\r\n}\r\ncodec->inc = 4;\r\ncodec->mod = mod;\r\nrate = 4 * codec->master / mod;\r\nreturn rate;\r\n}\r\nstatic void hal2_set_dac_rate(struct snd_hal2 *hal2)\r\n{\r\nunsigned int master = hal2->dac.master;\r\nint inc = hal2->dac.inc;\r\nint mod = hal2->dac.mod;\r\nhal2_i_write16(hal2, H2I_BRES1_C1, (master == 44100) ? 1 : 0);\r\nhal2_i_write32(hal2, H2I_BRES1_C2,\r\n((0xffff & (inc - mod - 1)) << 16) | inc);\r\n}\r\nstatic void hal2_set_adc_rate(struct snd_hal2 *hal2)\r\n{\r\nunsigned int master = hal2->adc.master;\r\nint inc = hal2->adc.inc;\r\nint mod = hal2->adc.mod;\r\nhal2_i_write16(hal2, H2I_BRES2_C1, (master == 44100) ? 1 : 0);\r\nhal2_i_write32(hal2, H2I_BRES2_C2,\r\n((0xffff & (inc - mod - 1)) << 16) | inc);\r\n}\r\nstatic void hal2_setup_dac(struct snd_hal2 *hal2)\r\n{\r\nunsigned int fifobeg, fifoend, highwater, sample_size;\r\nstruct hal2_pbus *pbus = &hal2->dac.pbus;\r\nsample_size = 2 * hal2->dac.voices;\r\nhighwater = (sample_size * 2) >> 1;\r\nfifobeg = 0;\r\nfifoend = (sample_size * 4) >> 3;\r\npbus->ctrl = HPC3_PDMACTRL_RT | HPC3_PDMACTRL_LD |\r\n(highwater << 8) | (fifobeg << 16) | (fifoend << 24);\r\npbus->pbus->pbdma_ctrl = HPC3_PDMACTRL_LD;\r\nhal2_i_clearbit16(hal2, H2I_DMA_PORT_EN, H2I_DMA_PORT_EN_CODECTX);\r\nhal2_set_dac_rate(hal2);\r\nhal2_i_clearbit16(hal2, H2I_DMA_END, H2I_DMA_END_CODECTX);\r\nhal2_i_setbit16(hal2, H2I_DMA_DRV, (1 << pbus->pbusnr));\r\nhal2_i_write16(hal2, H2I_DAC_C1, (pbus->pbusnr << H2I_C1_DMA_SHIFT)\r\n| (1 << H2I_C1_CLKID_SHIFT)\r\n| (hal2->dac.voices << H2I_C1_DATAT_SHIFT));\r\n}\r\nstatic void hal2_setup_adc(struct snd_hal2 *hal2)\r\n{\r\nunsigned int fifobeg, fifoend, highwater, sample_size;\r\nstruct hal2_pbus *pbus = &hal2->adc.pbus;\r\nsample_size = 2 * hal2->adc.voices;\r\nhighwater = (sample_size * 2) >> 1;\r\nfifobeg = (4 * 4) >> 3;\r\nfifoend = (4 * 4 + sample_size * 4) >> 3;\r\npbus->ctrl = HPC3_PDMACTRL_RT | HPC3_PDMACTRL_RCV | HPC3_PDMACTRL_LD |\r\n(highwater << 8) | (fifobeg << 16) | (fifoend << 24);\r\npbus->pbus->pbdma_ctrl = HPC3_PDMACTRL_LD;\r\nhal2_i_clearbit16(hal2, H2I_DMA_PORT_EN, H2I_DMA_PORT_EN_CODECR);\r\nhal2_set_adc_rate(hal2);\r\nhal2_i_clearbit16(hal2, H2I_DMA_END, H2I_DMA_END_CODECR);\r\nhal2_i_setbit16(hal2, H2I_DMA_DRV, (1 << pbus->pbusnr));\r\nhal2_i_write16(hal2, H2I_ADC_C1, (pbus->pbusnr << H2I_C1_DMA_SHIFT)\r\n| (2 << H2I_C1_CLKID_SHIFT)\r\n| (hal2->adc.voices << H2I_C1_DATAT_SHIFT));\r\n}\r\nstatic void hal2_start_dac(struct snd_hal2 *hal2)\r\n{\r\nstruct hal2_pbus *pbus = &hal2->dac.pbus;\r\npbus->pbus->pbdma_dptr = hal2->dac.desc_dma;\r\npbus->pbus->pbdma_ctrl = pbus->ctrl | HPC3_PDMACTRL_ACT;\r\nhal2_i_setbit16(hal2, H2I_DMA_PORT_EN, H2I_DMA_PORT_EN_CODECTX);\r\n}\r\nstatic void hal2_start_adc(struct snd_hal2 *hal2)\r\n{\r\nstruct hal2_pbus *pbus = &hal2->adc.pbus;\r\npbus->pbus->pbdma_dptr = hal2->adc.desc_dma;\r\npbus->pbus->pbdma_ctrl = pbus->ctrl | HPC3_PDMACTRL_ACT;\r\nhal2_i_setbit16(hal2, H2I_DMA_PORT_EN, H2I_DMA_PORT_EN_CODECR);\r\n}\r\nstatic inline void hal2_stop_dac(struct snd_hal2 *hal2)\r\n{\r\nhal2->dac.pbus.pbus->pbdma_ctrl = HPC3_PDMACTRL_LD;\r\n}\r\nstatic inline void hal2_stop_adc(struct snd_hal2 *hal2)\r\n{\r\nhal2->adc.pbus.pbus->pbdma_ctrl = HPC3_PDMACTRL_LD;\r\n}\r\nstatic int hal2_alloc_dmabuf(struct hal2_codec *codec)\r\n{\r\nstruct hal2_desc *desc;\r\ndma_addr_t desc_dma, buffer_dma;\r\nint count = H2_BUF_SIZE / H2_BLOCK_SIZE;\r\nint i;\r\ncodec->buffer = dma_alloc_noncoherent(NULL, H2_BUF_SIZE,\r\n&buffer_dma, GFP_KERNEL);\r\nif (!codec->buffer)\r\nreturn -ENOMEM;\r\ndesc = dma_alloc_noncoherent(NULL, count * sizeof(struct hal2_desc),\r\n&desc_dma, GFP_KERNEL);\r\nif (!desc) {\r\ndma_free_noncoherent(NULL, H2_BUF_SIZE,\r\ncodec->buffer, buffer_dma);\r\nreturn -ENOMEM;\r\n}\r\ncodec->buffer_dma = buffer_dma;\r\ncodec->desc_dma = desc_dma;\r\ncodec->desc = desc;\r\nfor (i = 0; i < count; i++) {\r\ndesc->desc.pbuf = buffer_dma + i * H2_BLOCK_SIZE;\r\ndesc->desc.cntinfo = HPCDMA_XIE | H2_BLOCK_SIZE;\r\ndesc->desc.pnext = (i == count - 1) ?\r\ndesc_dma : desc_dma + (i + 1) * sizeof(struct hal2_desc);\r\ndesc++;\r\n}\r\ndma_cache_sync(NULL, codec->desc, count * sizeof(struct hal2_desc),\r\nDMA_TO_DEVICE);\r\ncodec->desc_count = count;\r\nreturn 0;\r\n}\r\nstatic void hal2_free_dmabuf(struct hal2_codec *codec)\r\n{\r\ndma_free_noncoherent(NULL, codec->desc_count * sizeof(struct hal2_desc),\r\ncodec->desc, codec->desc_dma);\r\ndma_free_noncoherent(NULL, H2_BUF_SIZE, codec->buffer,\r\ncodec->buffer_dma);\r\n}\r\nstatic int hal2_pcm_hw_params(struct snd_pcm_substream *substream,\r\nstruct snd_pcm_hw_params *params)\r\n{\r\nint err;\r\nerr = snd_pcm_lib_malloc_pages(substream, params_buffer_bytes(params));\r\nif (err < 0)\r\nreturn err;\r\nreturn 0;\r\n}\r\nstatic int hal2_pcm_hw_free(struct snd_pcm_substream *substream)\r\n{\r\nreturn snd_pcm_lib_free_pages(substream);\r\n}\r\nstatic int hal2_playback_open(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nstruct snd_hal2 *hal2 = snd_pcm_substream_chip(substream);\r\nint err;\r\nruntime->hw = hal2_pcm_hw;\r\nerr = hal2_alloc_dmabuf(&hal2->dac);\r\nif (err)\r\nreturn err;\r\nreturn 0;\r\n}\r\nstatic int hal2_playback_close(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_hal2 *hal2 = snd_pcm_substream_chip(substream);\r\nhal2_free_dmabuf(&hal2->dac);\r\nreturn 0;\r\n}\r\nstatic int hal2_playback_prepare(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_hal2 *hal2 = snd_pcm_substream_chip(substream);\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nstruct hal2_codec *dac = &hal2->dac;\r\ndac->voices = runtime->channels;\r\ndac->sample_rate = hal2_compute_rate(dac, runtime->rate);\r\nmemset(&dac->pcm_indirect, 0, sizeof(dac->pcm_indirect));\r\ndac->pcm_indirect.hw_buffer_size = H2_BUF_SIZE;\r\ndac->pcm_indirect.sw_buffer_size = snd_pcm_lib_buffer_bytes(substream);\r\ndac->substream = substream;\r\nhal2_setup_dac(hal2);\r\nreturn 0;\r\n}\r\nstatic int hal2_playback_trigger(struct snd_pcm_substream *substream, int cmd)\r\n{\r\nstruct snd_hal2 *hal2 = snd_pcm_substream_chip(substream);\r\nswitch (cmd) {\r\ncase SNDRV_PCM_TRIGGER_START:\r\nhal2->dac.pcm_indirect.hw_io = hal2->dac.buffer_dma;\r\nhal2->dac.pcm_indirect.hw_data = 0;\r\nsubstream->ops->ack(substream);\r\nhal2_start_dac(hal2);\r\nbreak;\r\ncase SNDRV_PCM_TRIGGER_STOP:\r\nhal2_stop_dac(hal2);\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic snd_pcm_uframes_t\r\nhal2_playback_pointer(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_hal2 *hal2 = snd_pcm_substream_chip(substream);\r\nstruct hal2_codec *dac = &hal2->dac;\r\nreturn snd_pcm_indirect_playback_pointer(substream, &dac->pcm_indirect,\r\ndac->pbus.pbus->pbdma_bptr);\r\n}\r\nstatic void hal2_playback_transfer(struct snd_pcm_substream *substream,\r\nstruct snd_pcm_indirect *rec, size_t bytes)\r\n{\r\nstruct snd_hal2 *hal2 = snd_pcm_substream_chip(substream);\r\nunsigned char *buf = hal2->dac.buffer + rec->hw_data;\r\nmemcpy(buf, substream->runtime->dma_area + rec->sw_data, bytes);\r\ndma_cache_sync(NULL, buf, bytes, DMA_TO_DEVICE);\r\n}\r\nstatic int hal2_playback_ack(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_hal2 *hal2 = snd_pcm_substream_chip(substream);\r\nstruct hal2_codec *dac = &hal2->dac;\r\ndac->pcm_indirect.hw_queue_size = H2_BUF_SIZE / 2;\r\nsnd_pcm_indirect_playback_transfer(substream,\r\n&dac->pcm_indirect,\r\nhal2_playback_transfer);\r\nreturn 0;\r\n}\r\nstatic int hal2_capture_open(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nstruct snd_hal2 *hal2 = snd_pcm_substream_chip(substream);\r\nstruct hal2_codec *adc = &hal2->adc;\r\nint err;\r\nruntime->hw = hal2_pcm_hw;\r\nerr = hal2_alloc_dmabuf(adc);\r\nif (err)\r\nreturn err;\r\nreturn 0;\r\n}\r\nstatic int hal2_capture_close(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_hal2 *hal2 = snd_pcm_substream_chip(substream);\r\nhal2_free_dmabuf(&hal2->adc);\r\nreturn 0;\r\n}\r\nstatic int hal2_capture_prepare(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_hal2 *hal2 = snd_pcm_substream_chip(substream);\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nstruct hal2_codec *adc = &hal2->adc;\r\nadc->voices = runtime->channels;\r\nadc->sample_rate = hal2_compute_rate(adc, runtime->rate);\r\nmemset(&adc->pcm_indirect, 0, sizeof(adc->pcm_indirect));\r\nadc->pcm_indirect.hw_buffer_size = H2_BUF_SIZE;\r\nadc->pcm_indirect.hw_queue_size = H2_BUF_SIZE / 2;\r\nadc->pcm_indirect.sw_buffer_size = snd_pcm_lib_buffer_bytes(substream);\r\nadc->substream = substream;\r\nhal2_setup_adc(hal2);\r\nreturn 0;\r\n}\r\nstatic int hal2_capture_trigger(struct snd_pcm_substream *substream, int cmd)\r\n{\r\nstruct snd_hal2 *hal2 = snd_pcm_substream_chip(substream);\r\nswitch (cmd) {\r\ncase SNDRV_PCM_TRIGGER_START:\r\nhal2->adc.pcm_indirect.hw_io = hal2->adc.buffer_dma;\r\nhal2->adc.pcm_indirect.hw_data = 0;\r\nprintk(KERN_DEBUG "buffer_dma %x\n", hal2->adc.buffer_dma);\r\nhal2_start_adc(hal2);\r\nbreak;\r\ncase SNDRV_PCM_TRIGGER_STOP:\r\nhal2_stop_adc(hal2);\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic snd_pcm_uframes_t\r\nhal2_capture_pointer(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_hal2 *hal2 = snd_pcm_substream_chip(substream);\r\nstruct hal2_codec *adc = &hal2->adc;\r\nreturn snd_pcm_indirect_capture_pointer(substream, &adc->pcm_indirect,\r\nadc->pbus.pbus->pbdma_bptr);\r\n}\r\nstatic void hal2_capture_transfer(struct snd_pcm_substream *substream,\r\nstruct snd_pcm_indirect *rec, size_t bytes)\r\n{\r\nstruct snd_hal2 *hal2 = snd_pcm_substream_chip(substream);\r\nunsigned char *buf = hal2->adc.buffer + rec->hw_data;\r\ndma_cache_sync(NULL, buf, bytes, DMA_FROM_DEVICE);\r\nmemcpy(substream->runtime->dma_area + rec->sw_data, buf, bytes);\r\n}\r\nstatic int hal2_capture_ack(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_hal2 *hal2 = snd_pcm_substream_chip(substream);\r\nstruct hal2_codec *adc = &hal2->adc;\r\nsnd_pcm_indirect_capture_transfer(substream,\r\n&adc->pcm_indirect,\r\nhal2_capture_transfer);\r\nreturn 0;\r\n}\r\nstatic int hal2_pcm_create(struct snd_hal2 *hal2)\r\n{\r\nstruct snd_pcm *pcm;\r\nint err;\r\nerr = snd_pcm_new(hal2->card, "SGI HAL2 Audio", 0, 1, 1, &pcm);\r\nif (err < 0)\r\nreturn err;\r\npcm->private_data = hal2;\r\nstrcpy(pcm->name, "SGI HAL2");\r\nsnd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_PLAYBACK,\r\n&hal2_playback_ops);\r\nsnd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_CAPTURE,\r\n&hal2_capture_ops);\r\nsnd_pcm_lib_preallocate_pages_for_all(pcm, SNDRV_DMA_TYPE_CONTINUOUS,\r\nsnd_dma_continuous_data(GFP_KERNEL),\r\n0, 1024 * 1024);\r\nreturn 0;\r\n}\r\nstatic int hal2_dev_free(struct snd_device *device)\r\n{\r\nstruct snd_hal2 *hal2 = device->device_data;\r\nfree_irq(SGI_HPCDMA_IRQ, hal2);\r\nkfree(hal2);\r\nreturn 0;\r\n}\r\nstatic void hal2_init_codec(struct hal2_codec *codec, struct hpc3_regs *hpc3,\r\nint index)\r\n{\r\ncodec->pbus.pbusnr = index;\r\ncodec->pbus.pbus = &hpc3->pbdma[index];\r\n}\r\nstatic int hal2_detect(struct snd_hal2 *hal2)\r\n{\r\nunsigned short board, major, minor;\r\nunsigned short rev;\r\nhal2_write(0, &hal2->ctl_regs->isr);\r\nhal2_write(H2_ISR_GLOBAL_RESET_N | H2_ISR_CODEC_RESET_N,\r\n&hal2->ctl_regs->isr);\r\nhal2_i_write16(hal2, H2I_RELAY_C, H2I_RELAY_C_STATE);\r\nrev = hal2_read(&hal2->ctl_regs->rev);\r\nif (rev & H2_REV_AUDIO_PRESENT)\r\nreturn -ENODEV;\r\nboard = (rev & H2_REV_BOARD_M) >> 12;\r\nmajor = (rev & H2_REV_MAJOR_CHIP_M) >> 4;\r\nminor = (rev & H2_REV_MINOR_CHIP_M);\r\nprintk(KERN_INFO "SGI HAL2 revision %i.%i.%i\n",\r\nboard, major, minor);\r\nreturn 0;\r\n}\r\nstatic int hal2_create(struct snd_card *card, struct snd_hal2 **rchip)\r\n{\r\nstruct snd_hal2 *hal2;\r\nstruct hpc3_regs *hpc3 = hpc3c0;\r\nint err;\r\nhal2 = kzalloc(sizeof(struct snd_hal2), GFP_KERNEL);\r\nif (!hal2)\r\nreturn -ENOMEM;\r\nhal2->card = card;\r\nif (request_irq(SGI_HPCDMA_IRQ, hal2_interrupt, IRQF_SHARED,\r\n"SGI HAL2", hal2)) {\r\nprintk(KERN_ERR "HAL2: Can't get irq %d\n", SGI_HPCDMA_IRQ);\r\nkfree(hal2);\r\nreturn -EAGAIN;\r\n}\r\nhal2->ctl_regs = (struct hal2_ctl_regs *)hpc3->pbus_extregs[0];\r\nhal2->aes_regs = (struct hal2_aes_regs *)hpc3->pbus_extregs[1];\r\nhal2->vol_regs = (struct hal2_vol_regs *)hpc3->pbus_extregs[2];\r\nhal2->syn_regs = (struct hal2_syn_regs *)hpc3->pbus_extregs[3];\r\nif (hal2_detect(hal2) < 0) {\r\nkfree(hal2);\r\nreturn -ENODEV;\r\n}\r\nhal2_init_codec(&hal2->dac, hpc3, 0);\r\nhal2_init_codec(&hal2->adc, hpc3, 1);\r\n#define HAL2_PBUS_DMACFG ((0 << HPC3_DMACFG_D3R_SHIFT) | \\r\n(2 << HPC3_DMACFG_D4R_SHIFT) | \\r\n(2 << HPC3_DMACFG_D5R_SHIFT) | \\r\n(0 << HPC3_DMACFG_D3W_SHIFT) | \\r\n(2 << HPC3_DMACFG_D4W_SHIFT) | \\r\n(2 << HPC3_DMACFG_D5W_SHIFT) | \\r\nHPC3_DMACFG_DS16 | \\r\nHPC3_DMACFG_EVENHI | \\r\nHPC3_DMACFG_RTIME | \\r\n(8 << HPC3_DMACFG_BURST_SHIFT) | \\r\nHPC3_DMACFG_DRQLIVE)\r\nhpc3->pbus_dmacfg[hal2->dac.pbus.pbusnr][0] = 0x8208844;\r\nhpc3->pbus_dmacfg[hal2->adc.pbus.pbusnr][0] = 0x8208844;\r\nerr = snd_device_new(card, SNDRV_DEV_LOWLEVEL, hal2, &hal2_ops);\r\nif (err < 0) {\r\nfree_irq(SGI_HPCDMA_IRQ, hal2);\r\nkfree(hal2);\r\nreturn err;\r\n}\r\n*rchip = hal2;\r\nreturn 0;\r\n}\r\nstatic int hal2_probe(struct platform_device *pdev)\r\n{\r\nstruct snd_card *card;\r\nstruct snd_hal2 *chip;\r\nint err;\r\nerr = snd_card_new(&pdev->dev, index, id, THIS_MODULE, 0, &card);\r\nif (err < 0)\r\nreturn err;\r\nerr = hal2_create(card, &chip);\r\nif (err < 0) {\r\nsnd_card_free(card);\r\nreturn err;\r\n}\r\nerr = hal2_pcm_create(chip);\r\nif (err < 0) {\r\nsnd_card_free(card);\r\nreturn err;\r\n}\r\nerr = hal2_mixer_create(chip);\r\nif (err < 0) {\r\nsnd_card_free(card);\r\nreturn err;\r\n}\r\nstrcpy(card->driver, "SGI HAL2 Audio");\r\nstrcpy(card->shortname, "SGI HAL2 Audio");\r\nsprintf(card->longname, "%s irq %i",\r\ncard->shortname,\r\nSGI_HPCDMA_IRQ);\r\nerr = snd_card_register(card);\r\nif (err < 0) {\r\nsnd_card_free(card);\r\nreturn err;\r\n}\r\nplatform_set_drvdata(pdev, card);\r\nreturn 0;\r\n}\r\nstatic int hal2_remove(struct platform_device *pdev)\r\n{\r\nstruct snd_card *card = platform_get_drvdata(pdev);\r\nsnd_card_free(card);\r\nreturn 0;\r\n}
