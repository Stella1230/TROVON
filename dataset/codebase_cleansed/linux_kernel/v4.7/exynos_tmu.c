static void exynos_report_trigger(struct exynos_tmu_data *p)\r\n{\r\nchar data[10], *envp[] = { data, NULL };\r\nstruct thermal_zone_device *tz = p->tzd;\r\nint temp;\r\nunsigned int i;\r\nif (!tz) {\r\npr_err("No thermal zone device defined\n");\r\nreturn;\r\n}\r\nthermal_zone_device_update(tz);\r\nmutex_lock(&tz->lock);\r\nfor (i = 0; i < of_thermal_get_ntrips(tz); i++) {\r\ntz->ops->get_trip_temp(tz, i, &temp);\r\nif (tz->last_temperature < temp)\r\nbreak;\r\n}\r\nsnprintf(data, sizeof(data), "%u", i);\r\nkobject_uevent_env(&tz->device.kobj, KOBJ_CHANGE, envp);\r\nmutex_unlock(&tz->lock);\r\n}\r\nstatic int temp_to_code(struct exynos_tmu_data *data, u8 temp)\r\n{\r\nstruct exynos_tmu_platform_data *pdata = data->pdata;\r\nint temp_code;\r\nswitch (pdata->cal_type) {\r\ncase TYPE_TWO_POINT_TRIMMING:\r\ntemp_code = (temp - pdata->first_point_trim) *\r\n(data->temp_error2 - data->temp_error1) /\r\n(pdata->second_point_trim - pdata->first_point_trim) +\r\ndata->temp_error1;\r\nbreak;\r\ncase TYPE_ONE_POINT_TRIMMING:\r\ntemp_code = temp + data->temp_error1 - pdata->first_point_trim;\r\nbreak;\r\ndefault:\r\ntemp_code = temp + pdata->default_temp_offset;\r\nbreak;\r\n}\r\nreturn temp_code;\r\n}\r\nstatic int code_to_temp(struct exynos_tmu_data *data, u16 temp_code)\r\n{\r\nstruct exynos_tmu_platform_data *pdata = data->pdata;\r\nint temp;\r\nswitch (pdata->cal_type) {\r\ncase TYPE_TWO_POINT_TRIMMING:\r\ntemp = (temp_code - data->temp_error1) *\r\n(pdata->second_point_trim - pdata->first_point_trim) /\r\n(data->temp_error2 - data->temp_error1) +\r\npdata->first_point_trim;\r\nbreak;\r\ncase TYPE_ONE_POINT_TRIMMING:\r\ntemp = temp_code - data->temp_error1 + pdata->first_point_trim;\r\nbreak;\r\ndefault:\r\ntemp = temp_code - pdata->default_temp_offset;\r\nbreak;\r\n}\r\nreturn temp;\r\n}\r\nstatic void sanitize_temp_error(struct exynos_tmu_data *data, u32 trim_info)\r\n{\r\nstruct exynos_tmu_platform_data *pdata = data->pdata;\r\ndata->temp_error1 = trim_info & EXYNOS_TMU_TEMP_MASK;\r\ndata->temp_error2 = ((trim_info >> EXYNOS_TRIMINFO_85_SHIFT) &\r\nEXYNOS_TMU_TEMP_MASK);\r\nif (!data->temp_error1 ||\r\n(pdata->min_efuse_value > data->temp_error1) ||\r\n(data->temp_error1 > pdata->max_efuse_value))\r\ndata->temp_error1 = pdata->efuse_value & EXYNOS_TMU_TEMP_MASK;\r\nif (!data->temp_error2)\r\ndata->temp_error2 =\r\n(pdata->efuse_value >> EXYNOS_TRIMINFO_85_SHIFT) &\r\nEXYNOS_TMU_TEMP_MASK;\r\n}\r\nstatic u32 get_th_reg(struct exynos_tmu_data *data, u32 threshold, bool falling)\r\n{\r\nstruct thermal_zone_device *tz = data->tzd;\r\nconst struct thermal_trip * const trips =\r\nof_thermal_get_trip_points(tz);\r\nunsigned long temp;\r\nint i;\r\nif (!trips) {\r\npr_err("%s: Cannot get trip points from of-thermal.c!\n",\r\n__func__);\r\nreturn 0;\r\n}\r\nfor (i = 0; i < of_thermal_get_ntrips(tz); i++) {\r\nif (trips[i].type == THERMAL_TRIP_CRITICAL)\r\ncontinue;\r\ntemp = trips[i].temperature / MCELSIUS;\r\nif (falling)\r\ntemp -= (trips[i].hysteresis / MCELSIUS);\r\nelse\r\nthreshold &= ~(0xff << 8 * i);\r\nthreshold |= temp_to_code(data, temp) << 8 * i;\r\n}\r\nreturn threshold;\r\n}\r\nstatic int exynos_tmu_initialize(struct platform_device *pdev)\r\n{\r\nstruct exynos_tmu_data *data = platform_get_drvdata(pdev);\r\nint ret;\r\nif (of_thermal_get_ntrips(data->tzd) > data->ntrip) {\r\ndev_info(&pdev->dev,\r\n"More trip points than supported by this TMU.\n");\r\ndev_info(&pdev->dev,\r\n"%d trip points should be configured in polling mode.\n",\r\n(of_thermal_get_ntrips(data->tzd) - data->ntrip));\r\n}\r\nmutex_lock(&data->lock);\r\nclk_enable(data->clk);\r\nif (!IS_ERR(data->clk_sec))\r\nclk_enable(data->clk_sec);\r\nret = data->tmu_initialize(pdev);\r\nclk_disable(data->clk);\r\nmutex_unlock(&data->lock);\r\nif (!IS_ERR(data->clk_sec))\r\nclk_disable(data->clk_sec);\r\nreturn ret;\r\n}\r\nstatic u32 get_con_reg(struct exynos_tmu_data *data, u32 con)\r\n{\r\nstruct exynos_tmu_platform_data *pdata = data->pdata;\r\nif (data->soc == SOC_ARCH_EXYNOS4412 ||\r\ndata->soc == SOC_ARCH_EXYNOS3250)\r\ncon |= (EXYNOS4412_MUX_ADDR_VALUE << EXYNOS4412_MUX_ADDR_SHIFT);\r\ncon &= ~(EXYNOS_TMU_REF_VOLTAGE_MASK << EXYNOS_TMU_REF_VOLTAGE_SHIFT);\r\ncon |= pdata->reference_voltage << EXYNOS_TMU_REF_VOLTAGE_SHIFT;\r\ncon &= ~(EXYNOS_TMU_BUF_SLOPE_SEL_MASK << EXYNOS_TMU_BUF_SLOPE_SEL_SHIFT);\r\ncon |= (pdata->gain << EXYNOS_TMU_BUF_SLOPE_SEL_SHIFT);\r\nif (pdata->noise_cancel_mode) {\r\ncon &= ~(EXYNOS_TMU_TRIP_MODE_MASK << EXYNOS_TMU_TRIP_MODE_SHIFT);\r\ncon |= (pdata->noise_cancel_mode << EXYNOS_TMU_TRIP_MODE_SHIFT);\r\n}\r\nreturn con;\r\n}\r\nstatic void exynos_tmu_control(struct platform_device *pdev, bool on)\r\n{\r\nstruct exynos_tmu_data *data = platform_get_drvdata(pdev);\r\nmutex_lock(&data->lock);\r\nclk_enable(data->clk);\r\ndata->tmu_control(pdev, on);\r\nclk_disable(data->clk);\r\nmutex_unlock(&data->lock);\r\n}\r\nstatic int exynos4210_tmu_initialize(struct platform_device *pdev)\r\n{\r\nstruct exynos_tmu_data *data = platform_get_drvdata(pdev);\r\nstruct thermal_zone_device *tz = data->tzd;\r\nconst struct thermal_trip * const trips =\r\nof_thermal_get_trip_points(tz);\r\nint ret = 0, threshold_code, i;\r\nunsigned long reference, temp;\r\nunsigned int status;\r\nif (!trips) {\r\npr_err("%s: Cannot get trip points from of-thermal.c!\n",\r\n__func__);\r\nret = -ENODEV;\r\ngoto out;\r\n}\r\nstatus = readb(data->base + EXYNOS_TMU_REG_STATUS);\r\nif (!status) {\r\nret = -EBUSY;\r\ngoto out;\r\n}\r\nsanitize_temp_error(data, readl(data->base + EXYNOS_TMU_REG_TRIMINFO));\r\nreference = trips[0].temperature / MCELSIUS;\r\nthreshold_code = temp_to_code(data, reference);\r\nif (threshold_code < 0) {\r\nret = threshold_code;\r\ngoto out;\r\n}\r\nwriteb(threshold_code, data->base + EXYNOS4210_TMU_REG_THRESHOLD_TEMP);\r\nfor (i = 0; i < of_thermal_get_ntrips(tz); i++) {\r\ntemp = trips[i].temperature / MCELSIUS;\r\nwriteb(temp - reference, data->base +\r\nEXYNOS4210_TMU_REG_TRIG_LEVEL0 + i * 4);\r\n}\r\ndata->tmu_clear_irqs(data);\r\nout:\r\nreturn ret;\r\n}\r\nstatic int exynos4412_tmu_initialize(struct platform_device *pdev)\r\n{\r\nstruct exynos_tmu_data *data = platform_get_drvdata(pdev);\r\nconst struct thermal_trip * const trips =\r\nof_thermal_get_trip_points(data->tzd);\r\nunsigned int status, trim_info, con, ctrl, rising_threshold;\r\nint ret = 0, threshold_code, i;\r\nunsigned long crit_temp = 0;\r\nstatus = readb(data->base + EXYNOS_TMU_REG_STATUS);\r\nif (!status) {\r\nret = -EBUSY;\r\ngoto out;\r\n}\r\nif (data->soc == SOC_ARCH_EXYNOS3250 ||\r\ndata->soc == SOC_ARCH_EXYNOS4412 ||\r\ndata->soc == SOC_ARCH_EXYNOS5250) {\r\nif (data->soc == SOC_ARCH_EXYNOS3250) {\r\nctrl = readl(data->base + EXYNOS_TMU_TRIMINFO_CON1);\r\nctrl |= EXYNOS_TRIMINFO_RELOAD_ENABLE;\r\nwritel(ctrl, data->base + EXYNOS_TMU_TRIMINFO_CON1);\r\n}\r\nctrl = readl(data->base + EXYNOS_TMU_TRIMINFO_CON2);\r\nctrl |= EXYNOS_TRIMINFO_RELOAD_ENABLE;\r\nwritel(ctrl, data->base + EXYNOS_TMU_TRIMINFO_CON2);\r\n}\r\nif (data->soc == SOC_ARCH_EXYNOS5420_TRIMINFO)\r\ntrim_info = readl(data->base_second + EXYNOS_TMU_REG_TRIMINFO);\r\nelse\r\ntrim_info = readl(data->base + EXYNOS_TMU_REG_TRIMINFO);\r\nsanitize_temp_error(data, trim_info);\r\nrising_threshold = readl(data->base + EXYNOS_THD_TEMP_RISE);\r\nrising_threshold = get_th_reg(data, rising_threshold, false);\r\nwritel(rising_threshold, data->base + EXYNOS_THD_TEMP_RISE);\r\nwritel(get_th_reg(data, 0, true), data->base + EXYNOS_THD_TEMP_FALL);\r\ndata->tmu_clear_irqs(data);\r\nfor (i = 0; i < of_thermal_get_ntrips(data->tzd); i++) {\r\nif (trips[i].type == THERMAL_TRIP_CRITICAL) {\r\ncrit_temp = trips[i].temperature;\r\nbreak;\r\n}\r\n}\r\nif (i == of_thermal_get_ntrips(data->tzd)) {\r\npr_err("%s: No CRITICAL trip point defined at of-thermal.c!\n",\r\n__func__);\r\nret = -EINVAL;\r\ngoto out;\r\n}\r\nthreshold_code = temp_to_code(data, crit_temp / MCELSIUS);\r\nrising_threshold &= ~(0xff << 8 * i);\r\nrising_threshold |= threshold_code << 8 * i;\r\nwritel(rising_threshold, data->base + EXYNOS_THD_TEMP_RISE);\r\ncon = readl(data->base + EXYNOS_TMU_REG_CONTROL);\r\ncon |= (1 << EXYNOS_TMU_THERM_TRIP_EN_SHIFT);\r\nwritel(con, data->base + EXYNOS_TMU_REG_CONTROL);\r\nout:\r\nreturn ret;\r\n}\r\nstatic int exynos5433_tmu_initialize(struct platform_device *pdev)\r\n{\r\nstruct exynos_tmu_data *data = platform_get_drvdata(pdev);\r\nstruct exynos_tmu_platform_data *pdata = data->pdata;\r\nstruct thermal_zone_device *tz = data->tzd;\r\nunsigned int status, trim_info;\r\nunsigned int rising_threshold = 0, falling_threshold = 0;\r\nint temp, temp_hist;\r\nint ret = 0, threshold_code, i, sensor_id, cal_type;\r\nstatus = readb(data->base + EXYNOS_TMU_REG_STATUS);\r\nif (!status) {\r\nret = -EBUSY;\r\ngoto out;\r\n}\r\ntrim_info = readl(data->base + EXYNOS_TMU_REG_TRIMINFO);\r\nsanitize_temp_error(data, trim_info);\r\nsensor_id = (trim_info & EXYNOS5433_TRIMINFO_SENSOR_ID_MASK)\r\n>> EXYNOS5433_TRIMINFO_SENSOR_ID_SHIFT;\r\ndev_info(&pdev->dev, "Temperature sensor ID: 0x%x\n", sensor_id);\r\nwritel(trim_info, data->base + EXYNOS_TMU_REG_TRIMINFO);\r\ncal_type = (trim_info & EXYNOS5433_TRIMINFO_CALIB_SEL_MASK)\r\n>> EXYNOS5433_TRIMINFO_CALIB_SEL_SHIFT;\r\nswitch (cal_type) {\r\ncase EXYNOS5433_TRIMINFO_ONE_POINT_TRIMMING:\r\npdata->cal_type = TYPE_ONE_POINT_TRIMMING;\r\nbreak;\r\ncase EXYNOS5433_TRIMINFO_TWO_POINT_TRIMMING:\r\npdata->cal_type = TYPE_TWO_POINT_TRIMMING;\r\nbreak;\r\ndefault:\r\npdata->cal_type = TYPE_ONE_POINT_TRIMMING;\r\nbreak;\r\n}\r\ndev_info(&pdev->dev, "Calibration type is %d-point calibration\n",\r\ncal_type ? 2 : 1);\r\nfor (i = 0; i < of_thermal_get_ntrips(tz); i++) {\r\nint rising_reg_offset, falling_reg_offset;\r\nint j = 0;\r\nswitch (i) {\r\ncase 0:\r\ncase 1:\r\ncase 2:\r\ncase 3:\r\nrising_reg_offset = EXYNOS5433_THD_TEMP_RISE3_0;\r\nfalling_reg_offset = EXYNOS5433_THD_TEMP_FALL3_0;\r\nj = i;\r\nbreak;\r\ncase 4:\r\ncase 5:\r\ncase 6:\r\ncase 7:\r\nrising_reg_offset = EXYNOS5433_THD_TEMP_RISE7_4;\r\nfalling_reg_offset = EXYNOS5433_THD_TEMP_FALL7_4;\r\nj = i - 4;\r\nbreak;\r\ndefault:\r\ncontinue;\r\n}\r\ntz->ops->get_trip_temp(tz, i, &temp);\r\ntemp /= MCELSIUS;\r\nthreshold_code = temp_to_code(data, temp);\r\nrising_threshold = readl(data->base + rising_reg_offset);\r\nrising_threshold |= (threshold_code << j * 8);\r\nwritel(rising_threshold, data->base + rising_reg_offset);\r\ntz->ops->get_trip_hyst(tz, i, &temp_hist);\r\ntemp_hist = temp - (temp_hist / MCELSIUS);\r\nthreshold_code = temp_to_code(data, temp_hist);\r\nfalling_threshold = readl(data->base + falling_reg_offset);\r\nfalling_threshold &= ~(0xff << j * 8);\r\nfalling_threshold |= (threshold_code << j * 8);\r\nwritel(falling_threshold, data->base + falling_reg_offset);\r\n}\r\ndata->tmu_clear_irqs(data);\r\nout:\r\nreturn ret;\r\n}\r\nstatic int exynos5440_tmu_initialize(struct platform_device *pdev)\r\n{\r\nstruct exynos_tmu_data *data = platform_get_drvdata(pdev);\r\nunsigned int trim_info = 0, con, rising_threshold;\r\nint threshold_code;\r\nint crit_temp = 0;\r\nswitch (data->id) {\r\ncase 0:\r\ntrim_info = readl(data->base + EXYNOS5440_EFUSE_SWAP_OFFSET +\r\nEXYNOS5440_TMU_S0_7_TRIM);\r\nbreak;\r\ncase 1:\r\ntrim_info = readl(data->base + EXYNOS5440_TMU_S0_7_TRIM);\r\nbreak;\r\ncase 2:\r\ntrim_info = readl(data->base - EXYNOS5440_EFUSE_SWAP_OFFSET +\r\nEXYNOS5440_TMU_S0_7_TRIM);\r\n}\r\nsanitize_temp_error(data, trim_info);\r\nrising_threshold = readl(data->base + EXYNOS5440_TMU_S0_7_TH0);\r\nrising_threshold = get_th_reg(data, rising_threshold, false);\r\nwritel(rising_threshold, data->base + EXYNOS5440_TMU_S0_7_TH0);\r\nwritel(0, data->base + EXYNOS5440_TMU_S0_7_TH1);\r\ndata->tmu_clear_irqs(data);\r\nif (!data->tzd->ops->get_crit_temp(data->tzd, &crit_temp)) {\r\nthreshold_code = temp_to_code(data, crit_temp / MCELSIUS);\r\nrising_threshold =\r\nthreshold_code << EXYNOS5440_TMU_TH_RISE4_SHIFT;\r\nwritel(rising_threshold, data->base + EXYNOS5440_TMU_S0_7_TH2);\r\ncon = readl(data->base + EXYNOS5440_TMU_S0_7_CTRL);\r\ncon |= (1 << EXYNOS_TMU_THERM_TRIP_EN_SHIFT);\r\nwritel(con, data->base + EXYNOS5440_TMU_S0_7_CTRL);\r\n}\r\nif (!data->id)\r\nwritel(0, data->base_second + EXYNOS5440_TMU_PMIN);\r\nreturn 0;\r\n}\r\nstatic int exynos7_tmu_initialize(struct platform_device *pdev)\r\n{\r\nstruct exynos_tmu_data *data = platform_get_drvdata(pdev);\r\nstruct thermal_zone_device *tz = data->tzd;\r\nstruct exynos_tmu_platform_data *pdata = data->pdata;\r\nunsigned int status, trim_info;\r\nunsigned int rising_threshold = 0, falling_threshold = 0;\r\nint ret = 0, threshold_code, i;\r\nint temp, temp_hist;\r\nunsigned int reg_off, bit_off;\r\nstatus = readb(data->base + EXYNOS_TMU_REG_STATUS);\r\nif (!status) {\r\nret = -EBUSY;\r\ngoto out;\r\n}\r\ntrim_info = readl(data->base + EXYNOS_TMU_REG_TRIMINFO);\r\ndata->temp_error1 = trim_info & EXYNOS7_TMU_TEMP_MASK;\r\nif (!data->temp_error1 ||\r\n(pdata->min_efuse_value > data->temp_error1) ||\r\n(data->temp_error1 > pdata->max_efuse_value))\r\ndata->temp_error1 = pdata->efuse_value & EXYNOS_TMU_TEMP_MASK;\r\nfor (i = (of_thermal_get_ntrips(tz) - 1); i >= 0; i--) {\r\nreg_off = ((7 - i) / 2) * 4;\r\nbit_off = ((8 - i) % 2);\r\ntz->ops->get_trip_temp(tz, i, &temp);\r\ntemp /= MCELSIUS;\r\ntz->ops->get_trip_hyst(tz, i, &temp_hist);\r\ntemp_hist = temp - (temp_hist / MCELSIUS);\r\nthreshold_code = temp_to_code(data, temp);\r\nrising_threshold = readl(data->base +\r\nEXYNOS7_THD_TEMP_RISE7_6 + reg_off);\r\nrising_threshold &= ~(EXYNOS7_TMU_TEMP_MASK << (16 * bit_off));\r\nrising_threshold |= threshold_code << (16 * bit_off);\r\nwritel(rising_threshold,\r\ndata->base + EXYNOS7_THD_TEMP_RISE7_6 + reg_off);\r\nthreshold_code = temp_to_code(data, temp_hist);\r\nfalling_threshold &= ~(EXYNOS7_TMU_TEMP_MASK << (16 * bit_off));\r\nfalling_threshold |= threshold_code << (16 * bit_off);\r\nwritel(falling_threshold,\r\ndata->base + EXYNOS7_THD_TEMP_FALL7_6 + reg_off);\r\n}\r\ndata->tmu_clear_irqs(data);\r\nout:\r\nreturn ret;\r\n}\r\nstatic void exynos4210_tmu_control(struct platform_device *pdev, bool on)\r\n{\r\nstruct exynos_tmu_data *data = platform_get_drvdata(pdev);\r\nstruct thermal_zone_device *tz = data->tzd;\r\nunsigned int con, interrupt_en;\r\ncon = get_con_reg(data, readl(data->base + EXYNOS_TMU_REG_CONTROL));\r\nif (on) {\r\ncon |= (1 << EXYNOS_TMU_CORE_EN_SHIFT);\r\ninterrupt_en =\r\n(of_thermal_is_trip_valid(tz, 3)\r\n<< EXYNOS_TMU_INTEN_RISE3_SHIFT) |\r\n(of_thermal_is_trip_valid(tz, 2)\r\n<< EXYNOS_TMU_INTEN_RISE2_SHIFT) |\r\n(of_thermal_is_trip_valid(tz, 1)\r\n<< EXYNOS_TMU_INTEN_RISE1_SHIFT) |\r\n(of_thermal_is_trip_valid(tz, 0)\r\n<< EXYNOS_TMU_INTEN_RISE0_SHIFT);\r\nif (data->soc != SOC_ARCH_EXYNOS4210)\r\ninterrupt_en |=\r\ninterrupt_en << EXYNOS_TMU_INTEN_FALL0_SHIFT;\r\n} else {\r\ncon &= ~(1 << EXYNOS_TMU_CORE_EN_SHIFT);\r\ninterrupt_en = 0;\r\n}\r\nwritel(interrupt_en, data->base + EXYNOS_TMU_REG_INTEN);\r\nwritel(con, data->base + EXYNOS_TMU_REG_CONTROL);\r\n}\r\nstatic void exynos5433_tmu_control(struct platform_device *pdev, bool on)\r\n{\r\nstruct exynos_tmu_data *data = platform_get_drvdata(pdev);\r\nstruct thermal_zone_device *tz = data->tzd;\r\nunsigned int con, interrupt_en, pd_det_en;\r\ncon = get_con_reg(data, readl(data->base + EXYNOS_TMU_REG_CONTROL));\r\nif (on) {\r\ncon |= (1 << EXYNOS_TMU_CORE_EN_SHIFT);\r\ninterrupt_en =\r\n(of_thermal_is_trip_valid(tz, 7)\r\n<< EXYNOS7_TMU_INTEN_RISE7_SHIFT) |\r\n(of_thermal_is_trip_valid(tz, 6)\r\n<< EXYNOS7_TMU_INTEN_RISE6_SHIFT) |\r\n(of_thermal_is_trip_valid(tz, 5)\r\n<< EXYNOS7_TMU_INTEN_RISE5_SHIFT) |\r\n(of_thermal_is_trip_valid(tz, 4)\r\n<< EXYNOS7_TMU_INTEN_RISE4_SHIFT) |\r\n(of_thermal_is_trip_valid(tz, 3)\r\n<< EXYNOS7_TMU_INTEN_RISE3_SHIFT) |\r\n(of_thermal_is_trip_valid(tz, 2)\r\n<< EXYNOS7_TMU_INTEN_RISE2_SHIFT) |\r\n(of_thermal_is_trip_valid(tz, 1)\r\n<< EXYNOS7_TMU_INTEN_RISE1_SHIFT) |\r\n(of_thermal_is_trip_valid(tz, 0)\r\n<< EXYNOS7_TMU_INTEN_RISE0_SHIFT);\r\ninterrupt_en |=\r\ninterrupt_en << EXYNOS_TMU_INTEN_FALL0_SHIFT;\r\n} else {\r\ncon &= ~(1 << EXYNOS_TMU_CORE_EN_SHIFT);\r\ninterrupt_en = 0;\r\n}\r\npd_det_en = on ? EXYNOS5433_PD_DET_EN : 0;\r\nwritel(pd_det_en, data->base + EXYNOS5433_TMU_PD_DET_EN);\r\nwritel(interrupt_en, data->base + EXYNOS5433_TMU_REG_INTEN);\r\nwritel(con, data->base + EXYNOS_TMU_REG_CONTROL);\r\n}\r\nstatic void exynos5440_tmu_control(struct platform_device *pdev, bool on)\r\n{\r\nstruct exynos_tmu_data *data = platform_get_drvdata(pdev);\r\nstruct thermal_zone_device *tz = data->tzd;\r\nunsigned int con, interrupt_en;\r\ncon = get_con_reg(data, readl(data->base + EXYNOS5440_TMU_S0_7_CTRL));\r\nif (on) {\r\ncon |= (1 << EXYNOS_TMU_CORE_EN_SHIFT);\r\ninterrupt_en =\r\n(of_thermal_is_trip_valid(tz, 3)\r\n<< EXYNOS5440_TMU_INTEN_RISE3_SHIFT) |\r\n(of_thermal_is_trip_valid(tz, 2)\r\n<< EXYNOS5440_TMU_INTEN_RISE2_SHIFT) |\r\n(of_thermal_is_trip_valid(tz, 1)\r\n<< EXYNOS5440_TMU_INTEN_RISE1_SHIFT) |\r\n(of_thermal_is_trip_valid(tz, 0)\r\n<< EXYNOS5440_TMU_INTEN_RISE0_SHIFT);\r\ninterrupt_en |=\r\ninterrupt_en << EXYNOS5440_TMU_INTEN_FALL0_SHIFT;\r\n} else {\r\ncon &= ~(1 << EXYNOS_TMU_CORE_EN_SHIFT);\r\ninterrupt_en = 0;\r\n}\r\nwritel(interrupt_en, data->base + EXYNOS5440_TMU_S0_7_IRQEN);\r\nwritel(con, data->base + EXYNOS5440_TMU_S0_7_CTRL);\r\n}\r\nstatic void exynos7_tmu_control(struct platform_device *pdev, bool on)\r\n{\r\nstruct exynos_tmu_data *data = platform_get_drvdata(pdev);\r\nstruct thermal_zone_device *tz = data->tzd;\r\nunsigned int con, interrupt_en;\r\ncon = get_con_reg(data, readl(data->base + EXYNOS_TMU_REG_CONTROL));\r\nif (on) {\r\ncon |= (1 << EXYNOS_TMU_CORE_EN_SHIFT);\r\ncon |= (1 << EXYNOS7_PD_DET_EN_SHIFT);\r\ninterrupt_en =\r\n(of_thermal_is_trip_valid(tz, 7)\r\n<< EXYNOS7_TMU_INTEN_RISE7_SHIFT) |\r\n(of_thermal_is_trip_valid(tz, 6)\r\n<< EXYNOS7_TMU_INTEN_RISE6_SHIFT) |\r\n(of_thermal_is_trip_valid(tz, 5)\r\n<< EXYNOS7_TMU_INTEN_RISE5_SHIFT) |\r\n(of_thermal_is_trip_valid(tz, 4)\r\n<< EXYNOS7_TMU_INTEN_RISE4_SHIFT) |\r\n(of_thermal_is_trip_valid(tz, 3)\r\n<< EXYNOS7_TMU_INTEN_RISE3_SHIFT) |\r\n(of_thermal_is_trip_valid(tz, 2)\r\n<< EXYNOS7_TMU_INTEN_RISE2_SHIFT) |\r\n(of_thermal_is_trip_valid(tz, 1)\r\n<< EXYNOS7_TMU_INTEN_RISE1_SHIFT) |\r\n(of_thermal_is_trip_valid(tz, 0)\r\n<< EXYNOS7_TMU_INTEN_RISE0_SHIFT);\r\ninterrupt_en |=\r\ninterrupt_en << EXYNOS_TMU_INTEN_FALL0_SHIFT;\r\n} else {\r\ncon &= ~(1 << EXYNOS_TMU_CORE_EN_SHIFT);\r\ncon &= ~(1 << EXYNOS7_PD_DET_EN_SHIFT);\r\ninterrupt_en = 0;\r\n}\r\nwritel(interrupt_en, data->base + EXYNOS7_TMU_REG_INTEN);\r\nwritel(con, data->base + EXYNOS_TMU_REG_CONTROL);\r\n}\r\nstatic int exynos_get_temp(void *p, int *temp)\r\n{\r\nstruct exynos_tmu_data *data = p;\r\nif (!data || !data->tmu_read)\r\nreturn -EINVAL;\r\nmutex_lock(&data->lock);\r\nclk_enable(data->clk);\r\n*temp = code_to_temp(data, data->tmu_read(data)) * MCELSIUS;\r\nclk_disable(data->clk);\r\nmutex_unlock(&data->lock);\r\nreturn 0;\r\n}\r\nstatic u32 get_emul_con_reg(struct exynos_tmu_data *data, unsigned int val,\r\nint temp)\r\n{\r\nif (temp) {\r\ntemp /= MCELSIUS;\r\nif (data->soc != SOC_ARCH_EXYNOS5440) {\r\nval &= ~(EXYNOS_EMUL_TIME_MASK << EXYNOS_EMUL_TIME_SHIFT);\r\nval |= (EXYNOS_EMUL_TIME << EXYNOS_EMUL_TIME_SHIFT);\r\n}\r\nif (data->soc == SOC_ARCH_EXYNOS7) {\r\nval &= ~(EXYNOS7_EMUL_DATA_MASK <<\r\nEXYNOS7_EMUL_DATA_SHIFT);\r\nval |= (temp_to_code(data, temp) <<\r\nEXYNOS7_EMUL_DATA_SHIFT) |\r\nEXYNOS_EMUL_ENABLE;\r\n} else {\r\nval &= ~(EXYNOS_EMUL_DATA_MASK <<\r\nEXYNOS_EMUL_DATA_SHIFT);\r\nval |= (temp_to_code(data, temp) <<\r\nEXYNOS_EMUL_DATA_SHIFT) |\r\nEXYNOS_EMUL_ENABLE;\r\n}\r\n} else {\r\nval &= ~EXYNOS_EMUL_ENABLE;\r\n}\r\nreturn val;\r\n}\r\nstatic void exynos4412_tmu_set_emulation(struct exynos_tmu_data *data,\r\nint temp)\r\n{\r\nunsigned int val;\r\nu32 emul_con;\r\nif (data->soc == SOC_ARCH_EXYNOS5260)\r\nemul_con = EXYNOS5260_EMUL_CON;\r\nelse if (data->soc == SOC_ARCH_EXYNOS5433)\r\nemul_con = EXYNOS5433_TMU_EMUL_CON;\r\nelse if (data->soc == SOC_ARCH_EXYNOS7)\r\nemul_con = EXYNOS7_TMU_REG_EMUL_CON;\r\nelse\r\nemul_con = EXYNOS_EMUL_CON;\r\nval = readl(data->base + emul_con);\r\nval = get_emul_con_reg(data, val, temp);\r\nwritel(val, data->base + emul_con);\r\n}\r\nstatic void exynos5440_tmu_set_emulation(struct exynos_tmu_data *data,\r\nint temp)\r\n{\r\nunsigned int val;\r\nval = readl(data->base + EXYNOS5440_TMU_S0_7_DEBUG);\r\nval = get_emul_con_reg(data, val, temp);\r\nwritel(val, data->base + EXYNOS5440_TMU_S0_7_DEBUG);\r\n}\r\nstatic int exynos_tmu_set_emulation(void *drv_data, int temp)\r\n{\r\nstruct exynos_tmu_data *data = drv_data;\r\nint ret = -EINVAL;\r\nif (data->soc == SOC_ARCH_EXYNOS4210)\r\ngoto out;\r\nif (temp && temp < MCELSIUS)\r\ngoto out;\r\nmutex_lock(&data->lock);\r\nclk_enable(data->clk);\r\ndata->tmu_set_emulation(data, temp);\r\nclk_disable(data->clk);\r\nmutex_unlock(&data->lock);\r\nreturn 0;\r\nout:\r\nreturn ret;\r\n}\r\nstatic int exynos_tmu_set_emulation(void *drv_data, int temp)\r\n{ return -EINVAL; }\r\nstatic int exynos4210_tmu_read(struct exynos_tmu_data *data)\r\n{\r\nint ret = readb(data->base + EXYNOS_TMU_REG_CURRENT_TEMP);\r\nreturn (ret < 75 || ret > 175) ? -ENODATA : ret;\r\n}\r\nstatic int exynos4412_tmu_read(struct exynos_tmu_data *data)\r\n{\r\nreturn readb(data->base + EXYNOS_TMU_REG_CURRENT_TEMP);\r\n}\r\nstatic int exynos5440_tmu_read(struct exynos_tmu_data *data)\r\n{\r\nreturn readb(data->base + EXYNOS5440_TMU_S0_7_TEMP);\r\n}\r\nstatic int exynos7_tmu_read(struct exynos_tmu_data *data)\r\n{\r\nreturn readw(data->base + EXYNOS_TMU_REG_CURRENT_TEMP) &\r\nEXYNOS7_TMU_TEMP_MASK;\r\n}\r\nstatic void exynos_tmu_work(struct work_struct *work)\r\n{\r\nstruct exynos_tmu_data *data = container_of(work,\r\nstruct exynos_tmu_data, irq_work);\r\nunsigned int val_type;\r\nif (!IS_ERR(data->clk_sec))\r\nclk_enable(data->clk_sec);\r\nif (data->soc == SOC_ARCH_EXYNOS5440) {\r\nval_type = readl(data->base_second + EXYNOS5440_TMU_IRQ_STATUS);\r\nif (!((val_type >> data->id) & 0x1))\r\ngoto out;\r\n}\r\nif (!IS_ERR(data->clk_sec))\r\nclk_disable(data->clk_sec);\r\nexynos_report_trigger(data);\r\nmutex_lock(&data->lock);\r\nclk_enable(data->clk);\r\ndata->tmu_clear_irqs(data);\r\nclk_disable(data->clk);\r\nmutex_unlock(&data->lock);\r\nout:\r\nenable_irq(data->irq);\r\n}\r\nstatic void exynos4210_tmu_clear_irqs(struct exynos_tmu_data *data)\r\n{\r\nunsigned int val_irq;\r\nu32 tmu_intstat, tmu_intclear;\r\nif (data->soc == SOC_ARCH_EXYNOS5260) {\r\ntmu_intstat = EXYNOS5260_TMU_REG_INTSTAT;\r\ntmu_intclear = EXYNOS5260_TMU_REG_INTCLEAR;\r\n} else if (data->soc == SOC_ARCH_EXYNOS7) {\r\ntmu_intstat = EXYNOS7_TMU_REG_INTPEND;\r\ntmu_intclear = EXYNOS7_TMU_REG_INTPEND;\r\n} else if (data->soc == SOC_ARCH_EXYNOS5433) {\r\ntmu_intstat = EXYNOS5433_TMU_REG_INTPEND;\r\ntmu_intclear = EXYNOS5433_TMU_REG_INTPEND;\r\n} else {\r\ntmu_intstat = EXYNOS_TMU_REG_INTSTAT;\r\ntmu_intclear = EXYNOS_TMU_REG_INTCLEAR;\r\n}\r\nval_irq = readl(data->base + tmu_intstat);\r\nwritel(val_irq, data->base + tmu_intclear);\r\n}\r\nstatic void exynos5440_tmu_clear_irqs(struct exynos_tmu_data *data)\r\n{\r\nunsigned int val_irq;\r\nval_irq = readl(data->base + EXYNOS5440_TMU_S0_7_IRQ);\r\nwritel(val_irq, data->base + EXYNOS5440_TMU_S0_7_IRQ);\r\n}\r\nstatic irqreturn_t exynos_tmu_irq(int irq, void *id)\r\n{\r\nstruct exynos_tmu_data *data = id;\r\ndisable_irq_nosync(irq);\r\nschedule_work(&data->irq_work);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int exynos_of_get_soc_type(struct device_node *np)\r\n{\r\nif (of_device_is_compatible(np, "samsung,exynos3250-tmu"))\r\nreturn SOC_ARCH_EXYNOS3250;\r\nelse if (of_device_is_compatible(np, "samsung,exynos4210-tmu"))\r\nreturn SOC_ARCH_EXYNOS4210;\r\nelse if (of_device_is_compatible(np, "samsung,exynos4412-tmu"))\r\nreturn SOC_ARCH_EXYNOS4412;\r\nelse if (of_device_is_compatible(np, "samsung,exynos5250-tmu"))\r\nreturn SOC_ARCH_EXYNOS5250;\r\nelse if (of_device_is_compatible(np, "samsung,exynos5260-tmu"))\r\nreturn SOC_ARCH_EXYNOS5260;\r\nelse if (of_device_is_compatible(np, "samsung,exynos5420-tmu"))\r\nreturn SOC_ARCH_EXYNOS5420;\r\nelse if (of_device_is_compatible(np,\r\n"samsung,exynos5420-tmu-ext-triminfo"))\r\nreturn SOC_ARCH_EXYNOS5420_TRIMINFO;\r\nelse if (of_device_is_compatible(np, "samsung,exynos5433-tmu"))\r\nreturn SOC_ARCH_EXYNOS5433;\r\nelse if (of_device_is_compatible(np, "samsung,exynos5440-tmu"))\r\nreturn SOC_ARCH_EXYNOS5440;\r\nelse if (of_device_is_compatible(np, "samsung,exynos7-tmu"))\r\nreturn SOC_ARCH_EXYNOS7;\r\nreturn -EINVAL;\r\n}\r\nstatic int exynos_of_sensor_conf(struct device_node *np,\r\nstruct exynos_tmu_platform_data *pdata)\r\n{\r\nu32 value;\r\nint ret;\r\nof_node_get(np);\r\nret = of_property_read_u32(np, "samsung,tmu_gain", &value);\r\npdata->gain = (u8)value;\r\nof_property_read_u32(np, "samsung,tmu_reference_voltage", &value);\r\npdata->reference_voltage = (u8)value;\r\nof_property_read_u32(np, "samsung,tmu_noise_cancel_mode", &value);\r\npdata->noise_cancel_mode = (u8)value;\r\nof_property_read_u32(np, "samsung,tmu_efuse_value",\r\n&pdata->efuse_value);\r\nof_property_read_u32(np, "samsung,tmu_min_efuse_value",\r\n&pdata->min_efuse_value);\r\nof_property_read_u32(np, "samsung,tmu_max_efuse_value",\r\n&pdata->max_efuse_value);\r\nof_property_read_u32(np, "samsung,tmu_first_point_trim", &value);\r\npdata->first_point_trim = (u8)value;\r\nof_property_read_u32(np, "samsung,tmu_second_point_trim", &value);\r\npdata->second_point_trim = (u8)value;\r\nof_property_read_u32(np, "samsung,tmu_default_temp_offset", &value);\r\npdata->default_temp_offset = (u8)value;\r\nof_property_read_u32(np, "samsung,tmu_cal_type", &pdata->cal_type);\r\nof_property_read_u32(np, "samsung,tmu_cal_mode", &pdata->cal_mode);\r\nof_node_put(np);\r\nreturn 0;\r\n}\r\nstatic int exynos_map_dt_data(struct platform_device *pdev)\r\n{\r\nstruct exynos_tmu_data *data = platform_get_drvdata(pdev);\r\nstruct exynos_tmu_platform_data *pdata;\r\nstruct resource res;\r\nif (!data || !pdev->dev.of_node)\r\nreturn -ENODEV;\r\ndata->id = of_alias_get_id(pdev->dev.of_node, "tmuctrl");\r\nif (data->id < 0)\r\ndata->id = 0;\r\ndata->irq = irq_of_parse_and_map(pdev->dev.of_node, 0);\r\nif (data->irq <= 0) {\r\ndev_err(&pdev->dev, "failed to get IRQ\n");\r\nreturn -ENODEV;\r\n}\r\nif (of_address_to_resource(pdev->dev.of_node, 0, &res)) {\r\ndev_err(&pdev->dev, "failed to get Resource 0\n");\r\nreturn -ENODEV;\r\n}\r\ndata->base = devm_ioremap(&pdev->dev, res.start, resource_size(&res));\r\nif (!data->base) {\r\ndev_err(&pdev->dev, "Failed to ioremap memory\n");\r\nreturn -EADDRNOTAVAIL;\r\n}\r\npdata = devm_kzalloc(&pdev->dev,\r\nsizeof(struct exynos_tmu_platform_data),\r\nGFP_KERNEL);\r\nif (!pdata)\r\nreturn -ENOMEM;\r\nexynos_of_sensor_conf(pdev->dev.of_node, pdata);\r\ndata->pdata = pdata;\r\ndata->soc = exynos_of_get_soc_type(pdev->dev.of_node);\r\nswitch (data->soc) {\r\ncase SOC_ARCH_EXYNOS4210:\r\ndata->tmu_initialize = exynos4210_tmu_initialize;\r\ndata->tmu_control = exynos4210_tmu_control;\r\ndata->tmu_read = exynos4210_tmu_read;\r\ndata->tmu_clear_irqs = exynos4210_tmu_clear_irqs;\r\ndata->ntrip = 4;\r\nbreak;\r\ncase SOC_ARCH_EXYNOS3250:\r\ncase SOC_ARCH_EXYNOS4412:\r\ncase SOC_ARCH_EXYNOS5250:\r\ncase SOC_ARCH_EXYNOS5260:\r\ncase SOC_ARCH_EXYNOS5420:\r\ncase SOC_ARCH_EXYNOS5420_TRIMINFO:\r\ndata->tmu_initialize = exynos4412_tmu_initialize;\r\ndata->tmu_control = exynos4210_tmu_control;\r\ndata->tmu_read = exynos4412_tmu_read;\r\ndata->tmu_set_emulation = exynos4412_tmu_set_emulation;\r\ndata->tmu_clear_irqs = exynos4210_tmu_clear_irqs;\r\ndata->ntrip = 4;\r\nbreak;\r\ncase SOC_ARCH_EXYNOS5433:\r\ndata->tmu_initialize = exynos5433_tmu_initialize;\r\ndata->tmu_control = exynos5433_tmu_control;\r\ndata->tmu_read = exynos4412_tmu_read;\r\ndata->tmu_set_emulation = exynos4412_tmu_set_emulation;\r\ndata->tmu_clear_irqs = exynos4210_tmu_clear_irqs;\r\ndata->ntrip = 8;\r\nbreak;\r\ncase SOC_ARCH_EXYNOS5440:\r\ndata->tmu_initialize = exynos5440_tmu_initialize;\r\ndata->tmu_control = exynos5440_tmu_control;\r\ndata->tmu_read = exynos5440_tmu_read;\r\ndata->tmu_set_emulation = exynos5440_tmu_set_emulation;\r\ndata->tmu_clear_irqs = exynos5440_tmu_clear_irqs;\r\ndata->ntrip = 4;\r\nbreak;\r\ncase SOC_ARCH_EXYNOS7:\r\ndata->tmu_initialize = exynos7_tmu_initialize;\r\ndata->tmu_control = exynos7_tmu_control;\r\ndata->tmu_read = exynos7_tmu_read;\r\ndata->tmu_set_emulation = exynos4412_tmu_set_emulation;\r\ndata->tmu_clear_irqs = exynos4210_tmu_clear_irqs;\r\ndata->ntrip = 8;\r\nbreak;\r\ndefault:\r\ndev_err(&pdev->dev, "Platform not supported\n");\r\nreturn -EINVAL;\r\n}\r\nif (data->soc != SOC_ARCH_EXYNOS5420_TRIMINFO &&\r\ndata->soc != SOC_ARCH_EXYNOS5440)\r\nreturn 0;\r\nif (of_address_to_resource(pdev->dev.of_node, 1, &res)) {\r\ndev_err(&pdev->dev, "failed to get Resource 1\n");\r\nreturn -ENODEV;\r\n}\r\ndata->base_second = devm_ioremap(&pdev->dev, res.start,\r\nresource_size(&res));\r\nif (!data->base_second) {\r\ndev_err(&pdev->dev, "Failed to ioremap memory\n");\r\nreturn -ENOMEM;\r\n}\r\nreturn 0;\r\n}\r\nstatic int exynos_tmu_probe(struct platform_device *pdev)\r\n{\r\nstruct exynos_tmu_data *data;\r\nint ret;\r\ndata = devm_kzalloc(&pdev->dev, sizeof(struct exynos_tmu_data),\r\nGFP_KERNEL);\r\nif (!data)\r\nreturn -ENOMEM;\r\nplatform_set_drvdata(pdev, data);\r\nmutex_init(&data->lock);\r\ndata->regulator = devm_regulator_get_optional(&pdev->dev, "vtmu");\r\nif (!IS_ERR(data->regulator)) {\r\nret = regulator_enable(data->regulator);\r\nif (ret) {\r\ndev_err(&pdev->dev, "failed to enable vtmu\n");\r\nreturn ret;\r\n}\r\n} else {\r\nif (PTR_ERR(data->regulator) == -EPROBE_DEFER)\r\nreturn -EPROBE_DEFER;\r\ndev_info(&pdev->dev, "Regulator node (vtmu) not found\n");\r\n}\r\nret = exynos_map_dt_data(pdev);\r\nif (ret)\r\ngoto err_sensor;\r\nINIT_WORK(&data->irq_work, exynos_tmu_work);\r\ndata->clk = devm_clk_get(&pdev->dev, "tmu_apbif");\r\nif (IS_ERR(data->clk)) {\r\ndev_err(&pdev->dev, "Failed to get clock\n");\r\nret = PTR_ERR(data->clk);\r\ngoto err_sensor;\r\n}\r\ndata->clk_sec = devm_clk_get(&pdev->dev, "tmu_triminfo_apbif");\r\nif (IS_ERR(data->clk_sec)) {\r\nif (data->soc == SOC_ARCH_EXYNOS5420_TRIMINFO) {\r\ndev_err(&pdev->dev, "Failed to get triminfo clock\n");\r\nret = PTR_ERR(data->clk_sec);\r\ngoto err_sensor;\r\n}\r\n} else {\r\nret = clk_prepare(data->clk_sec);\r\nif (ret) {\r\ndev_err(&pdev->dev, "Failed to get clock\n");\r\ngoto err_sensor;\r\n}\r\n}\r\nret = clk_prepare(data->clk);\r\nif (ret) {\r\ndev_err(&pdev->dev, "Failed to get clock\n");\r\ngoto err_clk_sec;\r\n}\r\nswitch (data->soc) {\r\ncase SOC_ARCH_EXYNOS5433:\r\ncase SOC_ARCH_EXYNOS7:\r\ndata->sclk = devm_clk_get(&pdev->dev, "tmu_sclk");\r\nif (IS_ERR(data->sclk)) {\r\ndev_err(&pdev->dev, "Failed to get sclk\n");\r\ngoto err_clk;\r\n} else {\r\nret = clk_prepare_enable(data->sclk);\r\nif (ret) {\r\ndev_err(&pdev->dev, "Failed to enable sclk\n");\r\ngoto err_clk;\r\n}\r\n}\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\ndata->tzd = thermal_zone_of_sensor_register(&pdev->dev, 0, data,\r\n&exynos_sensor_ops);\r\nif (IS_ERR(data->tzd)) {\r\nret = PTR_ERR(data->tzd);\r\ndev_err(&pdev->dev, "Failed to register sensor: %d\n", ret);\r\ngoto err_sclk;\r\n}\r\nret = exynos_tmu_initialize(pdev);\r\nif (ret) {\r\ndev_err(&pdev->dev, "Failed to initialize TMU\n");\r\ngoto err_thermal;\r\n}\r\nret = devm_request_irq(&pdev->dev, data->irq, exynos_tmu_irq,\r\nIRQF_TRIGGER_RISING | IRQF_SHARED, dev_name(&pdev->dev), data);\r\nif (ret) {\r\ndev_err(&pdev->dev, "Failed to request irq: %d\n", data->irq);\r\ngoto err_thermal;\r\n}\r\nexynos_tmu_control(pdev, true);\r\nreturn 0;\r\nerr_thermal:\r\nthermal_zone_of_sensor_unregister(&pdev->dev, data->tzd);\r\nerr_sclk:\r\nclk_disable_unprepare(data->sclk);\r\nerr_clk:\r\nclk_unprepare(data->clk);\r\nerr_clk_sec:\r\nif (!IS_ERR(data->clk_sec))\r\nclk_unprepare(data->clk_sec);\r\nerr_sensor:\r\nif (!IS_ERR(data->regulator))\r\nregulator_disable(data->regulator);\r\nreturn ret;\r\n}\r\nstatic int exynos_tmu_remove(struct platform_device *pdev)\r\n{\r\nstruct exynos_tmu_data *data = platform_get_drvdata(pdev);\r\nstruct thermal_zone_device *tzd = data->tzd;\r\nthermal_zone_of_sensor_unregister(&pdev->dev, tzd);\r\nexynos_tmu_control(pdev, false);\r\nclk_disable_unprepare(data->sclk);\r\nclk_unprepare(data->clk);\r\nif (!IS_ERR(data->clk_sec))\r\nclk_unprepare(data->clk_sec);\r\nif (!IS_ERR(data->regulator))\r\nregulator_disable(data->regulator);\r\nreturn 0;\r\n}\r\nstatic int exynos_tmu_suspend(struct device *dev)\r\n{\r\nexynos_tmu_control(to_platform_device(dev), false);\r\nreturn 0;\r\n}\r\nstatic int exynos_tmu_resume(struct device *dev)\r\n{\r\nstruct platform_device *pdev = to_platform_device(dev);\r\nexynos_tmu_initialize(pdev);\r\nexynos_tmu_control(pdev, true);\r\nreturn 0;\r\n}
