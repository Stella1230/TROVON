int tpm2_pcr_read(struct tpm_chip *chip, int pcr_idx, u8 *res_buf)\r\n{\r\nint rc;\r\nstruct tpm2_cmd cmd;\r\nu8 *buf;\r\nif (pcr_idx >= TPM2_PLATFORM_PCR)\r\nreturn -EINVAL;\r\ncmd.header.in = tpm2_pcrread_header;\r\ncmd.params.pcrread_in.pcr_selects_cnt = cpu_to_be32(1);\r\ncmd.params.pcrread_in.hash_alg = cpu_to_be16(TPM2_ALG_SHA1);\r\ncmd.params.pcrread_in.pcr_select_size = TPM2_PCR_SELECT_MIN;\r\nmemset(cmd.params.pcrread_in.pcr_select, 0,\r\nsizeof(cmd.params.pcrread_in.pcr_select));\r\ncmd.params.pcrread_in.pcr_select[pcr_idx >> 3] = 1 << (pcr_idx & 0x7);\r\nrc = tpm_transmit_cmd(chip, &cmd, sizeof(cmd),\r\n"attempting to read a pcr value");\r\nif (rc == 0) {\r\nbuf = cmd.params.pcrread_out.digest;\r\nmemcpy(res_buf, buf, TPM_DIGEST_SIZE);\r\n}\r\nreturn rc;\r\n}\r\nint tpm2_pcr_extend(struct tpm_chip *chip, int pcr_idx, const u8 *hash)\r\n{\r\nstruct tpm2_cmd cmd;\r\nint rc;\r\ncmd.header.in = tpm2_pcrextend_header;\r\ncmd.params.pcrextend_in.pcr_idx = cpu_to_be32(pcr_idx);\r\ncmd.params.pcrextend_in.auth_area_size =\r\ncpu_to_be32(sizeof(struct tpm2_null_auth_area));\r\ncmd.params.pcrextend_in.auth_area.handle =\r\ncpu_to_be32(TPM2_RS_PW);\r\ncmd.params.pcrextend_in.auth_area.nonce_size = 0;\r\ncmd.params.pcrextend_in.auth_area.attributes = 0;\r\ncmd.params.pcrextend_in.auth_area.auth_size = 0;\r\ncmd.params.pcrextend_in.digest_cnt = cpu_to_be32(1);\r\ncmd.params.pcrextend_in.hash_alg = cpu_to_be16(TPM2_ALG_SHA1);\r\nmemcpy(cmd.params.pcrextend_in.digest, hash, TPM_DIGEST_SIZE);\r\nrc = tpm_transmit_cmd(chip, &cmd, sizeof(cmd),\r\n"attempting extend a PCR value");\r\nreturn rc;\r\n}\r\nint tpm2_get_random(struct tpm_chip *chip, u8 *out, size_t max)\r\n{\r\nstruct tpm2_cmd cmd;\r\nu32 recd;\r\nu32 num_bytes;\r\nint err;\r\nint total = 0;\r\nint retries = 5;\r\nu8 *dest = out;\r\nnum_bytes = min_t(u32, max, sizeof(cmd.params.getrandom_out.buffer));\r\nif (!out || !num_bytes ||\r\nmax > sizeof(cmd.params.getrandom_out.buffer))\r\nreturn -EINVAL;\r\ndo {\r\ncmd.header.in = tpm2_getrandom_header;\r\ncmd.params.getrandom_in.size = cpu_to_be16(num_bytes);\r\nerr = tpm_transmit_cmd(chip, &cmd, sizeof(cmd),\r\n"attempting get random");\r\nif (err)\r\nbreak;\r\nrecd = min_t(u32, be16_to_cpu(cmd.params.getrandom_out.size),\r\nnum_bytes);\r\nmemcpy(dest, cmd.params.getrandom_out.buffer, recd);\r\ndest += recd;\r\ntotal += recd;\r\nnum_bytes -= recd;\r\n} while (retries-- && total < max);\r\nreturn total ? total : -EIO;\r\n}\r\nstatic void tpm2_buf_append_auth(struct tpm_buf *buf, u32 session_handle,\r\nconst u8 *nonce, u16 nonce_len,\r\nu8 attributes,\r\nconst u8 *hmac, u16 hmac_len)\r\n{\r\ntpm_buf_append_u32(buf, 9 + nonce_len + hmac_len);\r\ntpm_buf_append_u32(buf, session_handle);\r\ntpm_buf_append_u16(buf, nonce_len);\r\nif (nonce && nonce_len)\r\ntpm_buf_append(buf, nonce, nonce_len);\r\ntpm_buf_append_u8(buf, attributes);\r\ntpm_buf_append_u16(buf, hmac_len);\r\nif (hmac && hmac_len)\r\ntpm_buf_append(buf, hmac, hmac_len);\r\n}\r\nint tpm2_seal_trusted(struct tpm_chip *chip,\r\nstruct trusted_key_payload *payload,\r\nstruct trusted_key_options *options)\r\n{\r\nunsigned int blob_len;\r\nstruct tpm_buf buf;\r\nu32 hash;\r\nint i;\r\nint rc;\r\nfor (i = 0; i < ARRAY_SIZE(tpm2_hash_map); i++) {\r\nif (options->hash == tpm2_hash_map[i].crypto_id) {\r\nhash = tpm2_hash_map[i].tpm_id;\r\nbreak;\r\n}\r\n}\r\nif (i == ARRAY_SIZE(tpm2_hash_map))\r\nreturn -EINVAL;\r\nrc = tpm_buf_init(&buf, TPM2_ST_SESSIONS, TPM2_CC_CREATE);\r\nif (rc)\r\nreturn rc;\r\ntpm_buf_append_u32(&buf, options->keyhandle);\r\ntpm2_buf_append_auth(&buf, TPM2_RS_PW,\r\nNULL , 0,\r\n0 ,\r\noptions->keyauth ,\r\nTPM_DIGEST_SIZE);\r\ntpm_buf_append_u16(&buf, 4 + TPM_DIGEST_SIZE + payload->key_len + 1);\r\ntpm_buf_append_u16(&buf, TPM_DIGEST_SIZE);\r\ntpm_buf_append(&buf, options->blobauth, TPM_DIGEST_SIZE);\r\ntpm_buf_append_u16(&buf, payload->key_len + 1);\r\ntpm_buf_append(&buf, payload->key, payload->key_len);\r\ntpm_buf_append_u8(&buf, payload->migratable);\r\ntpm_buf_append_u16(&buf, 14 + options->policydigest_len);\r\ntpm_buf_append_u16(&buf, TPM2_ALG_KEYEDHASH);\r\ntpm_buf_append_u16(&buf, hash);\r\nif (options->policydigest_len) {\r\ntpm_buf_append_u32(&buf, 0);\r\ntpm_buf_append_u16(&buf, options->policydigest_len);\r\ntpm_buf_append(&buf, options->policydigest,\r\noptions->policydigest_len);\r\n} else {\r\ntpm_buf_append_u32(&buf, TPM2_OA_USER_WITH_AUTH);\r\ntpm_buf_append_u16(&buf, 0);\r\n}\r\ntpm_buf_append_u16(&buf, TPM2_ALG_NULL);\r\ntpm_buf_append_u16(&buf, 0);\r\ntpm_buf_append_u16(&buf, 0);\r\ntpm_buf_append_u32(&buf, 0);\r\nif (buf.flags & TPM_BUF_OVERFLOW) {\r\nrc = -E2BIG;\r\ngoto out;\r\n}\r\nrc = tpm_transmit_cmd(chip, buf.data, PAGE_SIZE, "sealing data");\r\nif (rc)\r\ngoto out;\r\nblob_len = be32_to_cpup((__be32 *) &buf.data[TPM_HEADER_SIZE]);\r\nif (blob_len > MAX_BLOB_SIZE) {\r\nrc = -E2BIG;\r\ngoto out;\r\n}\r\nmemcpy(payload->blob, &buf.data[TPM_HEADER_SIZE + 4], blob_len);\r\npayload->blob_len = blob_len;\r\nout:\r\ntpm_buf_destroy(&buf);\r\nif (rc > 0) {\r\nif ((rc & TPM2_RC_HASH) == TPM2_RC_HASH)\r\nrc = -EINVAL;\r\nelse\r\nrc = -EPERM;\r\n}\r\nreturn rc;\r\n}\r\nstatic int tpm2_load(struct tpm_chip *chip,\r\nstruct trusted_key_payload *payload,\r\nstruct trusted_key_options *options,\r\nu32 *blob_handle)\r\n{\r\nstruct tpm_buf buf;\r\nunsigned int private_len;\r\nunsigned int public_len;\r\nunsigned int blob_len;\r\nint rc;\r\nprivate_len = be16_to_cpup((__be16 *) &payload->blob[0]);\r\nif (private_len > (payload->blob_len - 2))\r\nreturn -E2BIG;\r\npublic_len = be16_to_cpup((__be16 *) &payload->blob[2 + private_len]);\r\nblob_len = private_len + public_len + 4;\r\nif (blob_len > payload->blob_len)\r\nreturn -E2BIG;\r\nrc = tpm_buf_init(&buf, TPM2_ST_SESSIONS, TPM2_CC_LOAD);\r\nif (rc)\r\nreturn rc;\r\ntpm_buf_append_u32(&buf, options->keyhandle);\r\ntpm2_buf_append_auth(&buf, TPM2_RS_PW,\r\nNULL , 0,\r\n0 ,\r\noptions->keyauth ,\r\nTPM_DIGEST_SIZE);\r\ntpm_buf_append(&buf, payload->blob, blob_len);\r\nif (buf.flags & TPM_BUF_OVERFLOW) {\r\nrc = -E2BIG;\r\ngoto out;\r\n}\r\nrc = tpm_transmit_cmd(chip, buf.data, PAGE_SIZE, "loading blob");\r\nif (!rc)\r\n*blob_handle = be32_to_cpup(\r\n(__be32 *) &buf.data[TPM_HEADER_SIZE]);\r\nout:\r\ntpm_buf_destroy(&buf);\r\nif (rc > 0)\r\nrc = -EPERM;\r\nreturn rc;\r\n}\r\nstatic void tpm2_flush_context(struct tpm_chip *chip, u32 handle)\r\n{\r\nstruct tpm_buf buf;\r\nint rc;\r\nrc = tpm_buf_init(&buf, TPM2_ST_NO_SESSIONS, TPM2_CC_FLUSH_CONTEXT);\r\nif (rc) {\r\ndev_warn(chip->pdev, "0x%08x was not flushed, out of memory\n",\r\nhandle);\r\nreturn;\r\n}\r\ntpm_buf_append_u32(&buf, handle);\r\nrc = tpm_transmit_cmd(chip, buf.data, PAGE_SIZE, "flushing context");\r\nif (rc)\r\ndev_warn(chip->pdev, "0x%08x was not flushed, rc=%d\n", handle,\r\nrc);\r\ntpm_buf_destroy(&buf);\r\n}\r\nstatic int tpm2_unseal(struct tpm_chip *chip,\r\nstruct trusted_key_payload *payload,\r\nstruct trusted_key_options *options,\r\nu32 blob_handle)\r\n{\r\nstruct tpm_buf buf;\r\nu16 data_len;\r\nu8 *data;\r\nint rc;\r\nrc = tpm_buf_init(&buf, TPM2_ST_SESSIONS, TPM2_CC_UNSEAL);\r\nif (rc)\r\nreturn rc;\r\ntpm_buf_append_u32(&buf, blob_handle);\r\ntpm2_buf_append_auth(&buf,\r\noptions->policyhandle ?\r\noptions->policyhandle : TPM2_RS_PW,\r\nNULL , 0,\r\nTPM2_SA_CONTINUE_SESSION,\r\noptions->blobauth ,\r\nTPM_DIGEST_SIZE);\r\nrc = tpm_transmit_cmd(chip, buf.data, PAGE_SIZE, "unsealing");\r\nif (rc > 0)\r\nrc = -EPERM;\r\nif (!rc) {\r\ndata_len = be16_to_cpup(\r\n(__be16 *) &buf.data[TPM_HEADER_SIZE + 4]);\r\ndata = &buf.data[TPM_HEADER_SIZE + 6];\r\nmemcpy(payload->key, data, data_len - 1);\r\npayload->key_len = data_len - 1;\r\npayload->migratable = data[data_len - 1];\r\n}\r\ntpm_buf_destroy(&buf);\r\nreturn rc;\r\n}\r\nint tpm2_unseal_trusted(struct tpm_chip *chip,\r\nstruct trusted_key_payload *payload,\r\nstruct trusted_key_options *options)\r\n{\r\nu32 blob_handle;\r\nint rc;\r\nrc = tpm2_load(chip, payload, options, &blob_handle);\r\nif (rc)\r\nreturn rc;\r\nrc = tpm2_unseal(chip, payload, options, blob_handle);\r\ntpm2_flush_context(chip, blob_handle);\r\nreturn rc;\r\n}\r\nssize_t tpm2_get_tpm_pt(struct tpm_chip *chip, u32 property_id, u32 *value,\r\nconst char *desc)\r\n{\r\nstruct tpm2_cmd cmd;\r\nint rc;\r\ncmd.header.in = tpm2_get_tpm_pt_header;\r\ncmd.params.get_tpm_pt_in.cap_id = cpu_to_be32(TPM2_CAP_TPM_PROPERTIES);\r\ncmd.params.get_tpm_pt_in.property_id = cpu_to_be32(property_id);\r\ncmd.params.get_tpm_pt_in.property_cnt = cpu_to_be32(1);\r\nrc = tpm_transmit_cmd(chip, &cmd, sizeof(cmd), desc);\r\nif (!rc)\r\n*value = cmd.params.get_tpm_pt_out.value;\r\nreturn rc;\r\n}\r\nint tpm2_startup(struct tpm_chip *chip, u16 startup_type)\r\n{\r\nstruct tpm2_cmd cmd;\r\ncmd.header.in = tpm2_startup_header;\r\ncmd.params.startup_in.startup_type = cpu_to_be16(startup_type);\r\nreturn tpm_transmit_cmd(chip, &cmd, sizeof(cmd),\r\n"attempting to start the TPM");\r\n}\r\nvoid tpm2_shutdown(struct tpm_chip *chip, u16 shutdown_type)\r\n{\r\nstruct tpm2_cmd cmd;\r\nint rc;\r\ncmd.header.in = tpm2_shutdown_header;\r\ncmd.params.startup_in.startup_type = cpu_to_be16(shutdown_type);\r\nrc = tpm_transmit_cmd(chip, &cmd, sizeof(cmd), "stopping the TPM");\r\nif (rc < 0)\r\ndev_warn(chip->pdev, "transmit returned %d while stopping the TPM",\r\nrc);\r\n}\r\nunsigned long tpm2_calc_ordinal_duration(struct tpm_chip *chip, u32 ordinal)\r\n{\r\nint index = TPM_UNDEFINED;\r\nint duration = 0;\r\nif (ordinal >= TPM2_CC_FIRST && ordinal <= TPM2_CC_LAST)\r\nindex = tpm2_ordinal_duration[ordinal - TPM2_CC_FIRST];\r\nif (index != TPM_UNDEFINED)\r\nduration = chip->vendor.duration[index];\r\nif (duration <= 0)\r\nduration = 2 * 60 * HZ;\r\nreturn duration;\r\n}\r\nstatic int tpm2_start_selftest(struct tpm_chip *chip, bool full)\r\n{\r\nint rc;\r\nstruct tpm2_cmd cmd;\r\ncmd.header.in = tpm2_selftest_header;\r\ncmd.params.selftest_in.full_test = full;\r\nrc = tpm_transmit_cmd(chip, &cmd, TPM2_SELF_TEST_IN_SIZE,\r\n"continue selftest");\r\nif (rc == TPM2_RC_TESTING) {\r\ndev_warn(chip->pdev, "Got RC_TESTING, ignoring\n");\r\nrc = 0;\r\n}\r\nreturn rc;\r\n}\r\nint tpm2_do_selftest(struct tpm_chip *chip)\r\n{\r\nint rc;\r\nunsigned int loops;\r\nunsigned int delay_msec = 100;\r\nunsigned long duration;\r\nstruct tpm2_cmd cmd;\r\nint i;\r\nduration = tpm2_calc_ordinal_duration(chip, TPM2_CC_SELF_TEST);\r\nloops = jiffies_to_msecs(duration) / delay_msec;\r\nrc = tpm2_start_selftest(chip, true);\r\nif (rc)\r\nreturn rc;\r\nfor (i = 0; i < loops; i++) {\r\ncmd.header.in = tpm2_pcrread_header;\r\ncmd.params.pcrread_in.pcr_selects_cnt = cpu_to_be32(1);\r\ncmd.params.pcrread_in.hash_alg = cpu_to_be16(TPM2_ALG_SHA1);\r\ncmd.params.pcrread_in.pcr_select_size = TPM2_PCR_SELECT_MIN;\r\ncmd.params.pcrread_in.pcr_select[0] = 0x01;\r\ncmd.params.pcrread_in.pcr_select[1] = 0x00;\r\ncmd.params.pcrread_in.pcr_select[2] = 0x00;\r\nrc = tpm_transmit_cmd(chip, (u8 *) &cmd, sizeof(cmd), NULL);\r\nif (rc < 0)\r\nbreak;\r\nrc = be32_to_cpu(cmd.header.out.return_code);\r\nif (rc != TPM2_RC_TESTING)\r\nbreak;\r\nmsleep(delay_msec);\r\n}\r\nreturn rc;\r\n}\r\nint tpm2_gen_interrupt(struct tpm_chip *chip)\r\n{\r\nu32 dummy;\r\nreturn tpm2_get_tpm_pt(chip, 0x100, &dummy,\r\n"attempting to generate an interrupt");\r\n}\r\nint tpm2_probe(struct tpm_chip *chip)\r\n{\r\nstruct tpm2_cmd cmd;\r\nint rc;\r\ncmd.header.in = tpm2_get_tpm_pt_header;\r\ncmd.params.get_tpm_pt_in.cap_id = cpu_to_be32(TPM2_CAP_TPM_PROPERTIES);\r\ncmd.params.get_tpm_pt_in.property_id = cpu_to_be32(0x100);\r\ncmd.params.get_tpm_pt_in.property_cnt = cpu_to_be32(1);\r\nrc = tpm_transmit(chip, (const char *) &cmd, sizeof(cmd));\r\nif (rc < 0)\r\nreturn rc;\r\nelse if (rc < TPM_HEADER_SIZE)\r\nreturn -EFAULT;\r\nif (be16_to_cpu(cmd.header.out.tag) == TPM2_ST_NO_SESSIONS)\r\nchip->flags |= TPM_CHIP_FLAG_TPM2;\r\nreturn 0;\r\n}
