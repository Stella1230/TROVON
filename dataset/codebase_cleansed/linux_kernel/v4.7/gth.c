static void gth_output_set(struct gth_device *gth, int port,\r\nunsigned int config)\r\n{\r\nunsigned long reg = port & 4 ? REG_GTH_GTHOPT1 : REG_GTH_GTHOPT0;\r\nu32 val;\r\nint shift = (port & 3) * 8;\r\nval = ioread32(gth->base + reg);\r\nval &= ~(0xff << shift);\r\nval |= config << shift;\r\niowrite32(val, gth->base + reg);\r\n}\r\nstatic unsigned int gth_output_get(struct gth_device *gth, int port)\r\n{\r\nunsigned long reg = port & 4 ? REG_GTH_GTHOPT1 : REG_GTH_GTHOPT0;\r\nu32 val;\r\nint shift = (port & 3) * 8;\r\nval = ioread32(gth->base + reg);\r\nval &= 0xff << shift;\r\nval >>= shift;\r\nreturn val;\r\n}\r\nstatic void gth_smcfreq_set(struct gth_device *gth, int port,\r\nunsigned int freq)\r\n{\r\nunsigned long reg = REG_GTH_SMCR0 + ((port / 2) * 4);\r\nint shift = (port & 1) * 16;\r\nu32 val;\r\nval = ioread32(gth->base + reg);\r\nval &= ~(0xffff << shift);\r\nval |= freq << shift;\r\niowrite32(val, gth->base + reg);\r\n}\r\nstatic unsigned int gth_smcfreq_get(struct gth_device *gth, int port)\r\n{\r\nunsigned long reg = REG_GTH_SMCR0 + ((port / 2) * 4);\r\nint shift = (port & 1) * 16;\r\nu32 val;\r\nval = ioread32(gth->base + reg);\r\nval &= 0xffff << shift;\r\nval >>= shift;\r\nreturn val;\r\n}\r\nstatic void\r\ngth_master_set(struct gth_device *gth, unsigned int master, int port)\r\n{\r\nunsigned int reg = REG_GTH_SWDEST0 + ((master >> 1) & ~3u);\r\nunsigned int shift = (master & 0x7) * 4;\r\nu32 val;\r\nif (master >= 256) {\r\nreg = REG_GTH_GSWTDEST;\r\nshift = 0;\r\n}\r\nval = ioread32(gth->base + reg);\r\nval &= ~(0xf << shift);\r\nif (port >= 0)\r\nval |= (0x8 | port) << shift;\r\niowrite32(val, gth->base + reg);\r\n}\r\nstatic ssize_t master_attr_show(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct master_attribute *ma =\r\ncontainer_of(attr, struct master_attribute, attr);\r\nstruct gth_device *gth = ma->gth;\r\nsize_t count;\r\nint port;\r\nspin_lock(&gth->gth_lock);\r\nport = gth->master[ma->master];\r\nspin_unlock(&gth->gth_lock);\r\nif (port >= 0)\r\ncount = snprintf(buf, PAGE_SIZE, "%x\n", port);\r\nelse\r\ncount = snprintf(buf, PAGE_SIZE, "disabled\n");\r\nreturn count;\r\n}\r\nstatic ssize_t master_attr_store(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct master_attribute *ma =\r\ncontainer_of(attr, struct master_attribute, attr);\r\nstruct gth_device *gth = ma->gth;\r\nint old_port, port;\r\nif (kstrtoint(buf, 10, &port) < 0)\r\nreturn -EINVAL;\r\nif (port >= TH_POSSIBLE_OUTPUTS || port < -1)\r\nreturn -EINVAL;\r\nspin_lock(&gth->gth_lock);\r\nold_port = gth->master[ma->master];\r\nif (old_port >= 0) {\r\ngth->master[ma->master] = -1;\r\nclear_bit(ma->master, gth->output[old_port].master);\r\nif (gth->output[old_port].output->active)\r\ngth_master_set(gth, ma->master, -1);\r\n}\r\nif (port >= 0) {\r\nif (!gth->output[port].output) {\r\ncount = -ENODEV;\r\ngoto unlock;\r\n}\r\nset_bit(ma->master, gth->output[port].master);\r\nif (gth->output[port].output->active)\r\ngth_master_set(gth, ma->master, port);\r\n}\r\ngth->master[ma->master] = port;\r\nunlock:\r\nspin_unlock(&gth->gth_lock);\r\nreturn count;\r\n}\r\nstatic void\r\ngth_output_parm_set(struct gth_device *gth, int port, unsigned int parm,\r\nunsigned int val)\r\n{\r\nunsigned int config = output_parms[parm].get(gth, port);\r\nunsigned int mask = output_parms[parm].mask;\r\nunsigned int shift = __ffs(mask);\r\nconfig &= ~mask;\r\nconfig |= (val << shift) & mask;\r\noutput_parms[parm].set(gth, port, config);\r\n}\r\nstatic unsigned int\r\ngth_output_parm_get(struct gth_device *gth, int port, unsigned int parm)\r\n{\r\nunsigned int config = output_parms[parm].get(gth, port);\r\nunsigned int mask = output_parms[parm].mask;\r\nunsigned int shift = __ffs(mask);\r\nconfig &= mask;\r\nconfig >>= shift;\r\nreturn config;\r\n}\r\nstatic int intel_th_gth_reset(struct gth_device *gth)\r\n{\r\nu32 scratchpad;\r\nint port, i;\r\nscratchpad = ioread32(gth->base + REG_GTH_SCRPD0);\r\nif (scratchpad & SCRPD_DEBUGGER_IN_USE)\r\nreturn -EBUSY;\r\nscratchpad |= SCRPD_STH_IS_ENABLED | SCRPD_TRIGGER_IS_ENABLED;\r\niowrite32(scratchpad, gth->base + REG_GTH_SCRPD0);\r\nfor (port = 0; port < 8; port++) {\r\nif (gth_output_parm_get(gth, port, TH_OUTPUT_PARM(port)) ==\r\nGTH_NONE)\r\ncontinue;\r\ngth_output_set(gth, port, 0);\r\ngth_smcfreq_set(gth, port, 16);\r\n}\r\niowrite32(0, gth->base + REG_GTH_DESTOVR);\r\nfor (i = 0; i < 33; i++)\r\niowrite32(0, gth->base + REG_GTH_SWDEST0 + i * 4);\r\niowrite32(0, gth->base + REG_GTH_SCR);\r\niowrite32(0xfc, gth->base + REG_GTH_SCR2);\r\nreturn 0;\r\n}\r\nstatic ssize_t output_attr_show(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct output_attribute *oa =\r\ncontainer_of(attr, struct output_attribute, attr);\r\nstruct gth_device *gth = oa->gth;\r\nsize_t count;\r\nspin_lock(&gth->gth_lock);\r\ncount = snprintf(buf, PAGE_SIZE, "%x\n",\r\ngth_output_parm_get(gth, oa->port, oa->parm));\r\nspin_unlock(&gth->gth_lock);\r\nreturn count;\r\n}\r\nstatic ssize_t output_attr_store(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct output_attribute *oa =\r\ncontainer_of(attr, struct output_attribute, attr);\r\nstruct gth_device *gth = oa->gth;\r\nunsigned int config;\r\nif (kstrtouint(buf, 16, &config) < 0)\r\nreturn -EINVAL;\r\nspin_lock(&gth->gth_lock);\r\ngth_output_parm_set(gth, oa->port, oa->parm, config);\r\nspin_unlock(&gth->gth_lock);\r\nreturn count;\r\n}\r\nstatic int intel_th_master_attributes(struct gth_device *gth)\r\n{\r\nstruct master_attribute *master_attrs;\r\nstruct attribute **attrs;\r\nint i, nattrs = TH_CONFIGURABLE_MASTERS + 2;\r\nattrs = devm_kcalloc(gth->dev, nattrs, sizeof(void *), GFP_KERNEL);\r\nif (!attrs)\r\nreturn -ENOMEM;\r\nmaster_attrs = devm_kcalloc(gth->dev, nattrs,\r\nsizeof(struct master_attribute),\r\nGFP_KERNEL);\r\nif (!master_attrs)\r\nreturn -ENOMEM;\r\nfor (i = 0; i < TH_CONFIGURABLE_MASTERS + 1; i++) {\r\nchar *name;\r\nname = devm_kasprintf(gth->dev, GFP_KERNEL, "%d%s", i,\r\ni == TH_CONFIGURABLE_MASTERS ? "+" : "");\r\nif (!name)\r\nreturn -ENOMEM;\r\nmaster_attrs[i].attr.attr.name = name;\r\nmaster_attrs[i].attr.attr.mode = S_IRUGO | S_IWUSR;\r\nmaster_attrs[i].attr.show = master_attr_show;\r\nmaster_attrs[i].attr.store = master_attr_store;\r\nsysfs_attr_init(&master_attrs[i].attr.attr);\r\nattrs[i] = &master_attrs[i].attr.attr;\r\nmaster_attrs[i].gth = gth;\r\nmaster_attrs[i].master = i;\r\n}\r\ngth->master_group.name = "masters";\r\ngth->master_group.attrs = attrs;\r\nreturn sysfs_create_group(&gth->dev->kobj, &gth->master_group);\r\n}\r\nstatic int intel_th_output_attributes(struct gth_device *gth)\r\n{\r\nstruct output_attribute *out_attrs;\r\nstruct attribute **attrs;\r\nint i, j, nouts = TH_POSSIBLE_OUTPUTS;\r\nint nparms = ARRAY_SIZE(output_parms);\r\nint nattrs = nouts * nparms + 1;\r\nattrs = devm_kcalloc(gth->dev, nattrs, sizeof(void *), GFP_KERNEL);\r\nif (!attrs)\r\nreturn -ENOMEM;\r\nout_attrs = devm_kcalloc(gth->dev, nattrs,\r\nsizeof(struct output_attribute),\r\nGFP_KERNEL);\r\nif (!out_attrs)\r\nreturn -ENOMEM;\r\nfor (i = 0; i < nouts; i++) {\r\nfor (j = 0; j < nparms; j++) {\r\nunsigned int idx = i * nparms + j;\r\nchar *name;\r\nname = devm_kasprintf(gth->dev, GFP_KERNEL, "%d_%s", i,\r\noutput_parms[j].name);\r\nif (!name)\r\nreturn -ENOMEM;\r\nout_attrs[idx].attr.attr.name = name;\r\nif (output_parms[j].readable) {\r\nout_attrs[idx].attr.attr.mode |= S_IRUGO;\r\nout_attrs[idx].attr.show = output_attr_show;\r\n}\r\nif (output_parms[j].writable) {\r\nout_attrs[idx].attr.attr.mode |= S_IWUSR;\r\nout_attrs[idx].attr.store = output_attr_store;\r\n}\r\nsysfs_attr_init(&out_attrs[idx].attr.attr);\r\nattrs[idx] = &out_attrs[idx].attr.attr;\r\nout_attrs[idx].gth = gth;\r\nout_attrs[idx].port = i;\r\nout_attrs[idx].parm = j;\r\n}\r\n}\r\ngth->output_group.name = "outputs";\r\ngth->output_group.attrs = attrs;\r\nreturn sysfs_create_group(&gth->dev->kobj, &gth->output_group);\r\n}\r\nstatic void intel_th_gth_disable(struct intel_th_device *thdev,\r\nstruct intel_th_output *output)\r\n{\r\nstruct gth_device *gth = dev_get_drvdata(&thdev->dev);\r\nunsigned long count;\r\nint master;\r\nu32 reg;\r\nspin_lock(&gth->gth_lock);\r\noutput->active = false;\r\nfor_each_set_bit(master, gth->output[output->port].master,\r\nTH_CONFIGURABLE_MASTERS) {\r\ngth_master_set(gth, master, -1);\r\n}\r\nspin_unlock(&gth->gth_lock);\r\niowrite32(0, gth->base + REG_GTH_SCR);\r\niowrite32(0xfd, gth->base + REG_GTH_SCR2);\r\nfor (reg = 0, count = GTH_PLE_WAITLOOP_DEPTH;\r\ncount && !(reg & BIT(output->port)); count--) {\r\nreg = ioread32(gth->base + REG_GTH_STAT);\r\ncpu_relax();\r\n}\r\niowrite32(0xfc, gth->base + REG_GTH_SCR2);\r\nif (!count)\r\ndev_dbg(&thdev->dev, "timeout waiting for GTH[%d] PLE\n",\r\noutput->port);\r\nreg = ioread32(gth->base + REG_GTH_SCRPD0);\r\nreg &= ~output->scratchpad;\r\niowrite32(reg, gth->base + REG_GTH_SCRPD0);\r\n}\r\nstatic void intel_th_gth_enable(struct intel_th_device *thdev,\r\nstruct intel_th_output *output)\r\n{\r\nstruct gth_device *gth = dev_get_drvdata(&thdev->dev);\r\nu32 scr = 0xfc0000, scrpd;\r\nint master;\r\nspin_lock(&gth->gth_lock);\r\nfor_each_set_bit(master, gth->output[output->port].master,\r\nTH_CONFIGURABLE_MASTERS + 1) {\r\ngth_master_set(gth, master, output->port);\r\n}\r\nif (output->multiblock)\r\nscr |= 0xff;\r\noutput->active = true;\r\nspin_unlock(&gth->gth_lock);\r\nscrpd = ioread32(gth->base + REG_GTH_SCRPD0);\r\nscrpd |= output->scratchpad;\r\niowrite32(scrpd, gth->base + REG_GTH_SCRPD0);\r\niowrite32(scr, gth->base + REG_GTH_SCR);\r\niowrite32(0, gth->base + REG_GTH_SCR2);\r\n}\r\nstatic int intel_th_gth_assign(struct intel_th_device *thdev,\r\nstruct intel_th_device *othdev)\r\n{\r\nstruct gth_device *gth = dev_get_drvdata(&thdev->dev);\r\nint i, id;\r\nif (othdev->type != INTEL_TH_OUTPUT)\r\nreturn -EINVAL;\r\nfor (i = 0, id = 0; i < TH_POSSIBLE_OUTPUTS; i++) {\r\nif (gth->output[i].port_type != othdev->output.type)\r\ncontinue;\r\nif (othdev->id == -1 || othdev->id == id)\r\ngoto found;\r\nid++;\r\n}\r\nreturn -ENOENT;\r\nfound:\r\nspin_lock(&gth->gth_lock);\r\nothdev->output.port = i;\r\nothdev->output.active = false;\r\ngth->output[i].output = &othdev->output;\r\nspin_unlock(&gth->gth_lock);\r\nreturn 0;\r\n}\r\nstatic void intel_th_gth_unassign(struct intel_th_device *thdev,\r\nstruct intel_th_device *othdev)\r\n{\r\nstruct gth_device *gth = dev_get_drvdata(&thdev->dev);\r\nint port = othdev->output.port;\r\nspin_lock(&gth->gth_lock);\r\nothdev->output.port = -1;\r\nothdev->output.active = false;\r\ngth->output[port].output = NULL;\r\nspin_unlock(&gth->gth_lock);\r\n}\r\nstatic int\r\nintel_th_gth_set_output(struct intel_th_device *thdev, unsigned int master)\r\n{\r\nstruct gth_device *gth = dev_get_drvdata(&thdev->dev);\r\nint port = 0;\r\nif (master > TH_CONFIGURABLE_MASTERS)\r\nmaster = TH_CONFIGURABLE_MASTERS;\r\nspin_lock(&gth->gth_lock);\r\nif (gth->master[master] == -1) {\r\nset_bit(master, gth->output[port].master);\r\ngth->master[master] = port;\r\n}\r\nspin_unlock(&gth->gth_lock);\r\nreturn 0;\r\n}\r\nstatic int intel_th_gth_probe(struct intel_th_device *thdev)\r\n{\r\nstruct device *dev = &thdev->dev;\r\nstruct gth_device *gth;\r\nstruct resource *res;\r\nvoid __iomem *base;\r\nint i, ret;\r\nres = intel_th_device_get_resource(thdev, IORESOURCE_MEM, 0);\r\nif (!res)\r\nreturn -ENODEV;\r\nbase = devm_ioremap(dev, res->start, resource_size(res));\r\nif (!base)\r\nreturn -ENOMEM;\r\ngth = devm_kzalloc(dev, sizeof(*gth), GFP_KERNEL);\r\nif (!gth)\r\nreturn -ENOMEM;\r\ngth->dev = dev;\r\ngth->base = base;\r\nspin_lock_init(&gth->gth_lock);\r\nret = intel_th_gth_reset(gth);\r\nif (ret)\r\nreturn ret;\r\nfor (i = 0; i < TH_CONFIGURABLE_MASTERS + 1; i++)\r\ngth->master[i] = -1;\r\nfor (i = 0; i < TH_POSSIBLE_OUTPUTS; i++) {\r\ngth->output[i].gth = gth;\r\ngth->output[i].index = i;\r\ngth->output[i].port_type =\r\ngth_output_parm_get(gth, i, TH_OUTPUT_PARM(port));\r\n}\r\nif (intel_th_output_attributes(gth) ||\r\nintel_th_master_attributes(gth)) {\r\npr_warn("Can't initialize sysfs attributes\n");\r\nif (gth->output_group.attrs)\r\nsysfs_remove_group(&gth->dev->kobj, &gth->output_group);\r\nreturn -ENOMEM;\r\n}\r\ndev_set_drvdata(dev, gth);\r\nreturn 0;\r\n}\r\nstatic void intel_th_gth_remove(struct intel_th_device *thdev)\r\n{\r\nstruct gth_device *gth = dev_get_drvdata(&thdev->dev);\r\nsysfs_remove_group(&gth->dev->kobj, &gth->output_group);\r\nsysfs_remove_group(&gth->dev->kobj, &gth->master_group);\r\n}
