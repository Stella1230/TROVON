static inline struct sci_port *\r\nto_sci_port(struct uart_port *uart)\r\n{\r\nreturn container_of(uart, struct sci_port, port);\r\n}\r\nstatic unsigned int sci_serial_in(struct uart_port *p, int offset)\r\n{\r\nconst struct plat_sci_reg *reg = sci_getreg(p, offset);\r\nif (reg->size == 8)\r\nreturn ioread8(p->membase + (reg->offset << p->regshift));\r\nelse if (reg->size == 16)\r\nreturn ioread16(p->membase + (reg->offset << p->regshift));\r\nelse\r\nWARN(1, "Invalid register access\n");\r\nreturn 0;\r\n}\r\nstatic void sci_serial_out(struct uart_port *p, int offset, int value)\r\n{\r\nconst struct plat_sci_reg *reg = sci_getreg(p, offset);\r\nif (reg->size == 8)\r\niowrite8(value, p->membase + (reg->offset << p->regshift));\r\nelse if (reg->size == 16)\r\niowrite16(value, p->membase + (reg->offset << p->regshift));\r\nelse\r\nWARN(1, "Invalid register access\n");\r\n}\r\nstatic int sci_probe_regmap(struct plat_sci_port *cfg)\r\n{\r\nswitch (cfg->type) {\r\ncase PORT_SCI:\r\ncfg->regtype = SCIx_SCI_REGTYPE;\r\nbreak;\r\ncase PORT_IRDA:\r\ncfg->regtype = SCIx_IRDA_REGTYPE;\r\nbreak;\r\ncase PORT_SCIFA:\r\ncfg->regtype = SCIx_SCIFA_REGTYPE;\r\nbreak;\r\ncase PORT_SCIFB:\r\ncfg->regtype = SCIx_SCIFB_REGTYPE;\r\nbreak;\r\ncase PORT_SCIF:\r\ncfg->regtype = SCIx_SH4_SCIF_REGTYPE;\r\nbreak;\r\ncase PORT_HSCIF:\r\ncfg->regtype = SCIx_HSCIF_REGTYPE;\r\nbreak;\r\ndefault:\r\npr_err("Can't probe register map for given port\n");\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic void sci_port_enable(struct sci_port *sci_port)\r\n{\r\nunsigned int i;\r\nif (!sci_port->port.dev)\r\nreturn;\r\npm_runtime_get_sync(sci_port->port.dev);\r\nfor (i = 0; i < SCI_NUM_CLKS; i++) {\r\nclk_prepare_enable(sci_port->clks[i]);\r\nsci_port->clk_rates[i] = clk_get_rate(sci_port->clks[i]);\r\n}\r\nsci_port->port.uartclk = sci_port->clk_rates[SCI_FCK];\r\n}\r\nstatic void sci_port_disable(struct sci_port *sci_port)\r\n{\r\nunsigned int i;\r\nif (!sci_port->port.dev)\r\nreturn;\r\ndel_timer_sync(&sci_port->break_timer);\r\nsci_port->break_flag = 0;\r\nfor (i = SCI_NUM_CLKS; i-- > 0; )\r\nclk_disable_unprepare(sci_port->clks[i]);\r\npm_runtime_put_sync(sci_port->port.dev);\r\n}\r\nstatic inline unsigned long port_rx_irq_mask(struct uart_port *port)\r\n{\r\nreturn SCSCR_RIE | (to_sci_port(port)->cfg->scscr & SCSCR_REIE);\r\n}\r\nstatic void sci_start_tx(struct uart_port *port)\r\n{\r\nstruct sci_port *s = to_sci_port(port);\r\nunsigned short ctrl;\r\n#ifdef CONFIG_SERIAL_SH_SCI_DMA\r\nif (port->type == PORT_SCIFA || port->type == PORT_SCIFB) {\r\nu16 new, scr = serial_port_in(port, SCSCR);\r\nif (s->chan_tx)\r\nnew = scr | SCSCR_TDRQE;\r\nelse\r\nnew = scr & ~SCSCR_TDRQE;\r\nif (new != scr)\r\nserial_port_out(port, SCSCR, new);\r\n}\r\nif (s->chan_tx && !uart_circ_empty(&s->port.state->xmit) &&\r\ndma_submit_error(s->cookie_tx)) {\r\ns->cookie_tx = 0;\r\nschedule_work(&s->work_tx);\r\n}\r\n#endif\r\nif (!s->chan_tx || port->type == PORT_SCIFA || port->type == PORT_SCIFB) {\r\nctrl = serial_port_in(port, SCSCR);\r\nserial_port_out(port, SCSCR, ctrl | SCSCR_TIE);\r\n}\r\n}\r\nstatic void sci_stop_tx(struct uart_port *port)\r\n{\r\nunsigned short ctrl;\r\nctrl = serial_port_in(port, SCSCR);\r\nif (port->type == PORT_SCIFA || port->type == PORT_SCIFB)\r\nctrl &= ~SCSCR_TDRQE;\r\nctrl &= ~SCSCR_TIE;\r\nserial_port_out(port, SCSCR, ctrl);\r\n}\r\nstatic void sci_start_rx(struct uart_port *port)\r\n{\r\nunsigned short ctrl;\r\nctrl = serial_port_in(port, SCSCR) | port_rx_irq_mask(port);\r\nif (port->type == PORT_SCIFA || port->type == PORT_SCIFB)\r\nctrl &= ~SCSCR_RDRQE;\r\nserial_port_out(port, SCSCR, ctrl);\r\n}\r\nstatic void sci_stop_rx(struct uart_port *port)\r\n{\r\nunsigned short ctrl;\r\nctrl = serial_port_in(port, SCSCR);\r\nif (port->type == PORT_SCIFA || port->type == PORT_SCIFB)\r\nctrl &= ~SCSCR_RDRQE;\r\nctrl &= ~port_rx_irq_mask(port);\r\nserial_port_out(port, SCSCR, ctrl);\r\n}\r\nstatic void sci_clear_SCxSR(struct uart_port *port, unsigned int mask)\r\n{\r\nif (port->type == PORT_SCI) {\r\nserial_port_out(port, SCxSR, mask);\r\n} else if (to_sci_port(port)->overrun_mask == SCIFA_ORER) {\r\nserial_port_out(port, SCxSR,\r\nserial_port_in(port, SCxSR) & mask);\r\n} else {\r\nserial_port_out(port, SCxSR, mask & ~(SCIF_FERC | SCIF_PERC));\r\n}\r\n}\r\nstatic int sci_poll_get_char(struct uart_port *port)\r\n{\r\nunsigned short status;\r\nint c;\r\ndo {\r\nstatus = serial_port_in(port, SCxSR);\r\nif (status & SCxSR_ERRORS(port)) {\r\nsci_clear_SCxSR(port, SCxSR_ERROR_CLEAR(port));\r\ncontinue;\r\n}\r\nbreak;\r\n} while (1);\r\nif (!(status & SCxSR_RDxF(port)))\r\nreturn NO_POLL_CHAR;\r\nc = serial_port_in(port, SCxRDR);\r\nserial_port_in(port, SCxSR);\r\nsci_clear_SCxSR(port, SCxSR_RDxF_CLEAR(port));\r\nreturn c;\r\n}\r\nstatic void sci_poll_put_char(struct uart_port *port, unsigned char c)\r\n{\r\nunsigned short status;\r\ndo {\r\nstatus = serial_port_in(port, SCxSR);\r\n} while (!(status & SCxSR_TDxE(port)));\r\nserial_port_out(port, SCxTDR, c);\r\nsci_clear_SCxSR(port, SCxSR_TDxE_CLEAR(port) & ~SCxSR_TEND(port));\r\n}\r\nstatic void sci_init_pins(struct uart_port *port, unsigned int cflag)\r\n{\r\nstruct sci_port *s = to_sci_port(port);\r\nconst struct plat_sci_reg *reg = sci_regmap[s->cfg->regtype] + SCSPTR;\r\nif (s->cfg->ops && s->cfg->ops->init_pins) {\r\ns->cfg->ops->init_pins(port, cflag);\r\nreturn;\r\n}\r\nif (!reg->size)\r\nreturn;\r\nif ((s->cfg->capabilities & SCIx_HAVE_RTSCTS) &&\r\n((!(cflag & CRTSCTS)))) {\r\nunsigned short status;\r\nstatus = serial_port_in(port, SCSPTR);\r\nstatus &= ~SCSPTR_CTSIO;\r\nstatus |= SCSPTR_RTSIO;\r\nserial_port_out(port, SCSPTR, status);\r\n}\r\n}\r\nstatic int sci_txfill(struct uart_port *port)\r\n{\r\nconst struct plat_sci_reg *reg;\r\nreg = sci_getreg(port, SCTFDR);\r\nif (reg->size)\r\nreturn serial_port_in(port, SCTFDR) & ((port->fifosize << 1) - 1);\r\nreg = sci_getreg(port, SCFDR);\r\nif (reg->size)\r\nreturn serial_port_in(port, SCFDR) >> 8;\r\nreturn !(serial_port_in(port, SCxSR) & SCI_TDRE);\r\n}\r\nstatic int sci_txroom(struct uart_port *port)\r\n{\r\nreturn port->fifosize - sci_txfill(port);\r\n}\r\nstatic int sci_rxfill(struct uart_port *port)\r\n{\r\nconst struct plat_sci_reg *reg;\r\nreg = sci_getreg(port, SCRFDR);\r\nif (reg->size)\r\nreturn serial_port_in(port, SCRFDR) & ((port->fifosize << 1) - 1);\r\nreg = sci_getreg(port, SCFDR);\r\nif (reg->size)\r\nreturn serial_port_in(port, SCFDR) & ((port->fifosize << 1) - 1);\r\nreturn (serial_port_in(port, SCxSR) & SCxSR_RDxF(port)) != 0;\r\n}\r\nstatic inline int sci_rxd_in(struct uart_port *port)\r\n{\r\nstruct sci_port *s = to_sci_port(port);\r\nif (s->cfg->port_reg <= 0)\r\nreturn 1;\r\nreturn !!__raw_readb((void __iomem *)(uintptr_t)s->cfg->port_reg);\r\n}\r\nstatic void sci_transmit_chars(struct uart_port *port)\r\n{\r\nstruct circ_buf *xmit = &port->state->xmit;\r\nunsigned int stopped = uart_tx_stopped(port);\r\nunsigned short status;\r\nunsigned short ctrl;\r\nint count;\r\nstatus = serial_port_in(port, SCxSR);\r\nif (!(status & SCxSR_TDxE(port))) {\r\nctrl = serial_port_in(port, SCSCR);\r\nif (uart_circ_empty(xmit))\r\nctrl &= ~SCSCR_TIE;\r\nelse\r\nctrl |= SCSCR_TIE;\r\nserial_port_out(port, SCSCR, ctrl);\r\nreturn;\r\n}\r\ncount = sci_txroom(port);\r\ndo {\r\nunsigned char c;\r\nif (port->x_char) {\r\nc = port->x_char;\r\nport->x_char = 0;\r\n} else if (!uart_circ_empty(xmit) && !stopped) {\r\nc = xmit->buf[xmit->tail];\r\nxmit->tail = (xmit->tail + 1) & (UART_XMIT_SIZE - 1);\r\n} else {\r\nbreak;\r\n}\r\nserial_port_out(port, SCxTDR, c);\r\nport->icount.tx++;\r\n} while (--count > 0);\r\nsci_clear_SCxSR(port, SCxSR_TDxE_CLEAR(port));\r\nif (uart_circ_chars_pending(xmit) < WAKEUP_CHARS)\r\nuart_write_wakeup(port);\r\nif (uart_circ_empty(xmit)) {\r\nsci_stop_tx(port);\r\n} else {\r\nctrl = serial_port_in(port, SCSCR);\r\nif (port->type != PORT_SCI) {\r\nserial_port_in(port, SCxSR);\r\nsci_clear_SCxSR(port, SCxSR_TDxE_CLEAR(port));\r\n}\r\nctrl |= SCSCR_TIE;\r\nserial_port_out(port, SCSCR, ctrl);\r\n}\r\n}\r\nstatic void sci_receive_chars(struct uart_port *port)\r\n{\r\nstruct sci_port *sci_port = to_sci_port(port);\r\nstruct tty_port *tport = &port->state->port;\r\nint i, count, copied = 0;\r\nunsigned short status;\r\nunsigned char flag;\r\nstatus = serial_port_in(port, SCxSR);\r\nif (!(status & SCxSR_RDxF(port)))\r\nreturn;\r\nwhile (1) {\r\ncount = tty_buffer_request_room(tport, sci_rxfill(port));\r\nif (count == 0)\r\nbreak;\r\nif (port->type == PORT_SCI) {\r\nchar c = serial_port_in(port, SCxRDR);\r\nif (uart_handle_sysrq_char(port, c) ||\r\nsci_port->break_flag)\r\ncount = 0;\r\nelse\r\ntty_insert_flip_char(tport, c, TTY_NORMAL);\r\n} else {\r\nfor (i = 0; i < count; i++) {\r\nchar c = serial_port_in(port, SCxRDR);\r\nstatus = serial_port_in(port, SCxSR);\r\n#if defined(CONFIG_CPU_SH3)\r\nif (sci_port->break_flag) {\r\nif ((c == 0) &&\r\n(status & SCxSR_FER(port))) {\r\ncount--; i--;\r\ncontinue;\r\n}\r\ndev_dbg(port->dev, "debounce<%02x>\n", c);\r\nsci_port->break_flag = 0;\r\nif (STEPFN(c)) {\r\ncount--; i--;\r\ncontinue;\r\n}\r\n}\r\n#endif\r\nif (uart_handle_sysrq_char(port, c)) {\r\ncount--; i--;\r\ncontinue;\r\n}\r\nif (status & SCxSR_FER(port)) {\r\nflag = TTY_FRAME;\r\nport->icount.frame++;\r\ndev_notice(port->dev, "frame error\n");\r\n} else if (status & SCxSR_PER(port)) {\r\nflag = TTY_PARITY;\r\nport->icount.parity++;\r\ndev_notice(port->dev, "parity error\n");\r\n} else\r\nflag = TTY_NORMAL;\r\ntty_insert_flip_char(tport, c, flag);\r\n}\r\n}\r\nserial_port_in(port, SCxSR);\r\nsci_clear_SCxSR(port, SCxSR_RDxF_CLEAR(port));\r\ncopied += count;\r\nport->icount.rx += count;\r\n}\r\nif (copied) {\r\ntty_flip_buffer_push(tport);\r\n} else {\r\nserial_port_in(port, SCxSR);\r\nsci_clear_SCxSR(port, SCxSR_RDxF_CLEAR(port));\r\n}\r\n}\r\nstatic inline void sci_schedule_break_timer(struct sci_port *port)\r\n{\r\nmod_timer(&port->break_timer, jiffies + SCI_BREAK_JIFFIES);\r\n}\r\nstatic void sci_break_timer(unsigned long data)\r\n{\r\nstruct sci_port *port = (struct sci_port *)data;\r\nif (sci_rxd_in(&port->port) == 0) {\r\nport->break_flag = 1;\r\nsci_schedule_break_timer(port);\r\n} else if (port->break_flag == 1) {\r\nport->break_flag = 2;\r\nsci_schedule_break_timer(port);\r\n} else\r\nport->break_flag = 0;\r\n}\r\nstatic int sci_handle_errors(struct uart_port *port)\r\n{\r\nint copied = 0;\r\nunsigned short status = serial_port_in(port, SCxSR);\r\nstruct tty_port *tport = &port->state->port;\r\nstruct sci_port *s = to_sci_port(port);\r\nif (status & s->overrun_mask) {\r\nport->icount.overrun++;\r\nif (tty_insert_flip_char(tport, 0, TTY_OVERRUN))\r\ncopied++;\r\ndev_notice(port->dev, "overrun error\n");\r\n}\r\nif (status & SCxSR_FER(port)) {\r\nif (sci_rxd_in(port) == 0) {\r\nstruct sci_port *sci_port = to_sci_port(port);\r\nif (!sci_port->break_flag) {\r\nport->icount.brk++;\r\nsci_port->break_flag = 1;\r\nsci_schedule_break_timer(sci_port);\r\nif (uart_handle_break(port))\r\nreturn 0;\r\ndev_dbg(port->dev, "BREAK detected\n");\r\nif (tty_insert_flip_char(tport, 0, TTY_BREAK))\r\ncopied++;\r\n}\r\n} else {\r\nport->icount.frame++;\r\nif (tty_insert_flip_char(tport, 0, TTY_FRAME))\r\ncopied++;\r\ndev_notice(port->dev, "frame error\n");\r\n}\r\n}\r\nif (status & SCxSR_PER(port)) {\r\nport->icount.parity++;\r\nif (tty_insert_flip_char(tport, 0, TTY_PARITY))\r\ncopied++;\r\ndev_notice(port->dev, "parity error\n");\r\n}\r\nif (copied)\r\ntty_flip_buffer_push(tport);\r\nreturn copied;\r\n}\r\nstatic int sci_handle_fifo_overrun(struct uart_port *port)\r\n{\r\nstruct tty_port *tport = &port->state->port;\r\nstruct sci_port *s = to_sci_port(port);\r\nconst struct plat_sci_reg *reg;\r\nint copied = 0;\r\nu16 status;\r\nreg = sci_getreg(port, s->overrun_reg);\r\nif (!reg->size)\r\nreturn 0;\r\nstatus = serial_port_in(port, s->overrun_reg);\r\nif (status & s->overrun_mask) {\r\nstatus &= ~s->overrun_mask;\r\nserial_port_out(port, s->overrun_reg, status);\r\nport->icount.overrun++;\r\ntty_insert_flip_char(tport, 0, TTY_OVERRUN);\r\ntty_flip_buffer_push(tport);\r\ndev_dbg(port->dev, "overrun error\n");\r\ncopied++;\r\n}\r\nreturn copied;\r\n}\r\nstatic int sci_handle_breaks(struct uart_port *port)\r\n{\r\nint copied = 0;\r\nunsigned short status = serial_port_in(port, SCxSR);\r\nstruct tty_port *tport = &port->state->port;\r\nstruct sci_port *s = to_sci_port(port);\r\nif (uart_handle_break(port))\r\nreturn 0;\r\nif (!s->break_flag && status & SCxSR_BRK(port)) {\r\n#if defined(CONFIG_CPU_SH3)\r\ns->break_flag = 1;\r\n#endif\r\nport->icount.brk++;\r\nif (tty_insert_flip_char(tport, 0, TTY_BREAK))\r\ncopied++;\r\ndev_dbg(port->dev, "BREAK detected\n");\r\n}\r\nif (copied)\r\ntty_flip_buffer_push(tport);\r\ncopied += sci_handle_fifo_overrun(port);\r\nreturn copied;\r\n}\r\nstatic void sci_dma_tx_complete(void *arg)\r\n{\r\nstruct sci_port *s = arg;\r\nstruct uart_port *port = &s->port;\r\nstruct circ_buf *xmit = &port->state->xmit;\r\nunsigned long flags;\r\ndev_dbg(port->dev, "%s(%d)\n", __func__, port->line);\r\nspin_lock_irqsave(&port->lock, flags);\r\nxmit->tail += s->tx_dma_len;\r\nxmit->tail &= UART_XMIT_SIZE - 1;\r\nport->icount.tx += s->tx_dma_len;\r\nif (uart_circ_chars_pending(xmit) < WAKEUP_CHARS)\r\nuart_write_wakeup(port);\r\nif (!uart_circ_empty(xmit)) {\r\ns->cookie_tx = 0;\r\nschedule_work(&s->work_tx);\r\n} else {\r\ns->cookie_tx = -EINVAL;\r\nif (port->type == PORT_SCIFA || port->type == PORT_SCIFB) {\r\nu16 ctrl = serial_port_in(port, SCSCR);\r\nserial_port_out(port, SCSCR, ctrl & ~SCSCR_TIE);\r\n}\r\n}\r\nspin_unlock_irqrestore(&port->lock, flags);\r\n}\r\nstatic int sci_dma_rx_push(struct sci_port *s, void *buf, size_t count)\r\n{\r\nstruct uart_port *port = &s->port;\r\nstruct tty_port *tport = &port->state->port;\r\nint copied;\r\ncopied = tty_insert_flip_string(tport, buf, count);\r\nif (copied < count) {\r\ndev_warn(port->dev, "Rx overrun: dropping %zu bytes\n",\r\ncount - copied);\r\nport->icount.buf_overrun++;\r\n}\r\nport->icount.rx += copied;\r\nreturn copied;\r\n}\r\nstatic int sci_dma_rx_find_active(struct sci_port *s)\r\n{\r\nunsigned int i;\r\nfor (i = 0; i < ARRAY_SIZE(s->cookie_rx); i++)\r\nif (s->active_rx == s->cookie_rx[i])\r\nreturn i;\r\ndev_err(s->port.dev, "%s: Rx cookie %d not found!\n", __func__,\r\ns->active_rx);\r\nreturn -1;\r\n}\r\nstatic void sci_rx_dma_release(struct sci_port *s, bool enable_pio)\r\n{\r\nstruct dma_chan *chan = s->chan_rx;\r\nstruct uart_port *port = &s->port;\r\nunsigned long flags;\r\nspin_lock_irqsave(&port->lock, flags);\r\ns->chan_rx = NULL;\r\ns->cookie_rx[0] = s->cookie_rx[1] = -EINVAL;\r\nspin_unlock_irqrestore(&port->lock, flags);\r\ndmaengine_terminate_all(chan);\r\ndma_free_coherent(chan->device->dev, s->buf_len_rx * 2, s->rx_buf[0],\r\nsg_dma_address(&s->sg_rx[0]));\r\ndma_release_channel(chan);\r\nif (enable_pio)\r\nsci_start_rx(port);\r\n}\r\nstatic void sci_dma_rx_complete(void *arg)\r\n{\r\nstruct sci_port *s = arg;\r\nstruct dma_chan *chan = s->chan_rx;\r\nstruct uart_port *port = &s->port;\r\nstruct dma_async_tx_descriptor *desc;\r\nunsigned long flags;\r\nint active, count = 0;\r\ndev_dbg(port->dev, "%s(%d) active cookie %d\n", __func__, port->line,\r\ns->active_rx);\r\nspin_lock_irqsave(&port->lock, flags);\r\nactive = sci_dma_rx_find_active(s);\r\nif (active >= 0)\r\ncount = sci_dma_rx_push(s, s->rx_buf[active], s->buf_len_rx);\r\nmod_timer(&s->rx_timer, jiffies + s->rx_timeout);\r\nif (count)\r\ntty_flip_buffer_push(&port->state->port);\r\ndesc = dmaengine_prep_slave_sg(s->chan_rx, &s->sg_rx[active], 1,\r\nDMA_DEV_TO_MEM,\r\nDMA_PREP_INTERRUPT | DMA_CTRL_ACK);\r\nif (!desc)\r\ngoto fail;\r\ndesc->callback = sci_dma_rx_complete;\r\ndesc->callback_param = s;\r\ns->cookie_rx[active] = dmaengine_submit(desc);\r\nif (dma_submit_error(s->cookie_rx[active]))\r\ngoto fail;\r\ns->active_rx = s->cookie_rx[!active];\r\ndma_async_issue_pending(chan);\r\ndev_dbg(port->dev, "%s: cookie %d #%d, new active cookie %d\n",\r\n__func__, s->cookie_rx[active], active, s->active_rx);\r\nspin_unlock_irqrestore(&port->lock, flags);\r\nreturn;\r\nfail:\r\nspin_unlock_irqrestore(&port->lock, flags);\r\ndev_warn(port->dev, "Failed submitting Rx DMA descriptor\n");\r\nsci_rx_dma_release(s, true);\r\n}\r\nstatic void sci_tx_dma_release(struct sci_port *s, bool enable_pio)\r\n{\r\nstruct dma_chan *chan = s->chan_tx;\r\nstruct uart_port *port = &s->port;\r\nunsigned long flags;\r\nspin_lock_irqsave(&port->lock, flags);\r\ns->chan_tx = NULL;\r\ns->cookie_tx = -EINVAL;\r\nspin_unlock_irqrestore(&port->lock, flags);\r\ndmaengine_terminate_all(chan);\r\ndma_unmap_single(chan->device->dev, s->tx_dma_addr, UART_XMIT_SIZE,\r\nDMA_TO_DEVICE);\r\ndma_release_channel(chan);\r\nif (enable_pio)\r\nsci_start_tx(port);\r\n}\r\nstatic void sci_submit_rx(struct sci_port *s)\r\n{\r\nstruct dma_chan *chan = s->chan_rx;\r\nint i;\r\nfor (i = 0; i < 2; i++) {\r\nstruct scatterlist *sg = &s->sg_rx[i];\r\nstruct dma_async_tx_descriptor *desc;\r\ndesc = dmaengine_prep_slave_sg(chan,\r\nsg, 1, DMA_DEV_TO_MEM,\r\nDMA_PREP_INTERRUPT | DMA_CTRL_ACK);\r\nif (!desc)\r\ngoto fail;\r\ndesc->callback = sci_dma_rx_complete;\r\ndesc->callback_param = s;\r\ns->cookie_rx[i] = dmaengine_submit(desc);\r\nif (dma_submit_error(s->cookie_rx[i]))\r\ngoto fail;\r\ndev_dbg(s->port.dev, "%s(): cookie %d to #%d\n", __func__,\r\ns->cookie_rx[i], i);\r\n}\r\ns->active_rx = s->cookie_rx[0];\r\ndma_async_issue_pending(chan);\r\nreturn;\r\nfail:\r\nif (i)\r\ndmaengine_terminate_all(chan);\r\nfor (i = 0; i < 2; i++)\r\ns->cookie_rx[i] = -EINVAL;\r\ns->active_rx = -EINVAL;\r\ndev_warn(s->port.dev, "Failed to re-start Rx DMA, using PIO\n");\r\nsci_rx_dma_release(s, true);\r\n}\r\nstatic void work_fn_tx(struct work_struct *work)\r\n{\r\nstruct sci_port *s = container_of(work, struct sci_port, work_tx);\r\nstruct dma_async_tx_descriptor *desc;\r\nstruct dma_chan *chan = s->chan_tx;\r\nstruct uart_port *port = &s->port;\r\nstruct circ_buf *xmit = &port->state->xmit;\r\ndma_addr_t buf;\r\nspin_lock_irq(&port->lock);\r\nbuf = s->tx_dma_addr + (xmit->tail & (UART_XMIT_SIZE - 1));\r\ns->tx_dma_len = min_t(unsigned int,\r\nCIRC_CNT(xmit->head, xmit->tail, UART_XMIT_SIZE),\r\nCIRC_CNT_TO_END(xmit->head, xmit->tail, UART_XMIT_SIZE));\r\nspin_unlock_irq(&port->lock);\r\ndesc = dmaengine_prep_slave_single(chan, buf, s->tx_dma_len,\r\nDMA_MEM_TO_DEV,\r\nDMA_PREP_INTERRUPT | DMA_CTRL_ACK);\r\nif (!desc) {\r\ndev_warn(port->dev, "Failed preparing Tx DMA descriptor\n");\r\nsci_tx_dma_release(s, true);\r\nreturn;\r\n}\r\ndma_sync_single_for_device(chan->device->dev, buf, s->tx_dma_len,\r\nDMA_TO_DEVICE);\r\nspin_lock_irq(&port->lock);\r\ndesc->callback = sci_dma_tx_complete;\r\ndesc->callback_param = s;\r\nspin_unlock_irq(&port->lock);\r\ns->cookie_tx = dmaengine_submit(desc);\r\nif (dma_submit_error(s->cookie_tx)) {\r\ndev_warn(port->dev, "Failed submitting Tx DMA descriptor\n");\r\nsci_tx_dma_release(s, true);\r\nreturn;\r\n}\r\ndev_dbg(port->dev, "%s: %p: %d...%d, cookie %d\n",\r\n__func__, xmit->buf, xmit->tail, xmit->head, s->cookie_tx);\r\ndma_async_issue_pending(chan);\r\n}\r\nstatic void rx_timer_fn(unsigned long arg)\r\n{\r\nstruct sci_port *s = (struct sci_port *)arg;\r\nstruct dma_chan *chan = s->chan_rx;\r\nstruct uart_port *port = &s->port;\r\nstruct dma_tx_state state;\r\nenum dma_status status;\r\nunsigned long flags;\r\nunsigned int read;\r\nint active, count;\r\nu16 scr;\r\nspin_lock_irqsave(&port->lock, flags);\r\ndev_dbg(port->dev, "DMA Rx timed out\n");\r\nactive = sci_dma_rx_find_active(s);\r\nif (active < 0) {\r\nspin_unlock_irqrestore(&port->lock, flags);\r\nreturn;\r\n}\r\nstatus = dmaengine_tx_status(s->chan_rx, s->active_rx, &state);\r\nif (status == DMA_COMPLETE) {\r\ndev_dbg(port->dev, "Cookie %d #%d has already completed\n",\r\ns->active_rx, active);\r\nspin_unlock_irqrestore(&port->lock, flags);\r\nreturn;\r\n}\r\ndmaengine_pause(chan);\r\nstatus = dmaengine_tx_status(s->chan_rx, s->active_rx, &state);\r\nif (status == DMA_COMPLETE) {\r\nspin_unlock_irqrestore(&port->lock, flags);\r\ndev_dbg(port->dev, "Transaction complete after DMA engine was stopped");\r\nreturn;\r\n}\r\ndmaengine_terminate_all(s->chan_rx);\r\nread = sg_dma_len(&s->sg_rx[active]) - state.residue;\r\ndev_dbg(port->dev, "Read %u bytes with cookie %d\n", read,\r\ns->active_rx);\r\nif (read) {\r\ncount = sci_dma_rx_push(s, s->rx_buf[active], read);\r\nif (count)\r\ntty_flip_buffer_push(&port->state->port);\r\n}\r\nif (port->type == PORT_SCIFA || port->type == PORT_SCIFB)\r\nsci_submit_rx(s);\r\nscr = serial_port_in(port, SCSCR);\r\nif (port->type == PORT_SCIFA || port->type == PORT_SCIFB) {\r\nscr &= ~SCSCR_RDRQE;\r\nenable_irq(s->irqs[SCIx_RXI_IRQ]);\r\n}\r\nserial_port_out(port, SCSCR, scr | SCSCR_RIE);\r\nspin_unlock_irqrestore(&port->lock, flags);\r\n}\r\nstatic struct dma_chan *sci_request_dma_chan(struct uart_port *port,\r\nenum dma_transfer_direction dir,\r\nunsigned int id)\r\n{\r\ndma_cap_mask_t mask;\r\nstruct dma_chan *chan;\r\nstruct dma_slave_config cfg;\r\nint ret;\r\ndma_cap_zero(mask);\r\ndma_cap_set(DMA_SLAVE, mask);\r\nchan = dma_request_slave_channel_compat(mask, shdma_chan_filter,\r\n(void *)(unsigned long)id, port->dev,\r\ndir == DMA_MEM_TO_DEV ? "tx" : "rx");\r\nif (!chan) {\r\ndev_warn(port->dev,\r\n"dma_request_slave_channel_compat failed\n");\r\nreturn NULL;\r\n}\r\nmemset(&cfg, 0, sizeof(cfg));\r\ncfg.direction = dir;\r\nif (dir == DMA_MEM_TO_DEV) {\r\ncfg.dst_addr = port->mapbase +\r\n(sci_getreg(port, SCxTDR)->offset << port->regshift);\r\ncfg.dst_addr_width = DMA_SLAVE_BUSWIDTH_1_BYTE;\r\n} else {\r\ncfg.src_addr = port->mapbase +\r\n(sci_getreg(port, SCxRDR)->offset << port->regshift);\r\ncfg.src_addr_width = DMA_SLAVE_BUSWIDTH_1_BYTE;\r\n}\r\nret = dmaengine_slave_config(chan, &cfg);\r\nif (ret) {\r\ndev_warn(port->dev, "dmaengine_slave_config failed %d\n", ret);\r\ndma_release_channel(chan);\r\nreturn NULL;\r\n}\r\nreturn chan;\r\n}\r\nstatic void sci_request_dma(struct uart_port *port)\r\n{\r\nstruct sci_port *s = to_sci_port(port);\r\nstruct dma_chan *chan;\r\ndev_dbg(port->dev, "%s: port %d\n", __func__, port->line);\r\nif (!port->dev->of_node &&\r\n(s->cfg->dma_slave_tx <= 0 || s->cfg->dma_slave_rx <= 0))\r\nreturn;\r\ns->cookie_tx = -EINVAL;\r\nchan = sci_request_dma_chan(port, DMA_MEM_TO_DEV, s->cfg->dma_slave_tx);\r\ndev_dbg(port->dev, "%s: TX: got channel %p\n", __func__, chan);\r\nif (chan) {\r\ns->chan_tx = chan;\r\ns->tx_dma_addr = dma_map_single(chan->device->dev,\r\nport->state->xmit.buf,\r\nUART_XMIT_SIZE,\r\nDMA_TO_DEVICE);\r\nif (dma_mapping_error(chan->device->dev, s->tx_dma_addr)) {\r\ndev_warn(port->dev, "Failed mapping Tx DMA descriptor\n");\r\ndma_release_channel(chan);\r\ns->chan_tx = NULL;\r\n} else {\r\ndev_dbg(port->dev, "%s: mapped %lu@%p to %pad\n",\r\n__func__, UART_XMIT_SIZE,\r\nport->state->xmit.buf, &s->tx_dma_addr);\r\n}\r\nINIT_WORK(&s->work_tx, work_fn_tx);\r\n}\r\nchan = sci_request_dma_chan(port, DMA_DEV_TO_MEM, s->cfg->dma_slave_rx);\r\ndev_dbg(port->dev, "%s: RX: got channel %p\n", __func__, chan);\r\nif (chan) {\r\nunsigned int i;\r\ndma_addr_t dma;\r\nvoid *buf;\r\ns->chan_rx = chan;\r\ns->buf_len_rx = 2 * max_t(size_t, 16, port->fifosize);\r\nbuf = dma_alloc_coherent(chan->device->dev, s->buf_len_rx * 2,\r\n&dma, GFP_KERNEL);\r\nif (!buf) {\r\ndev_warn(port->dev,\r\n"Failed to allocate Rx dma buffer, using PIO\n");\r\ndma_release_channel(chan);\r\ns->chan_rx = NULL;\r\nreturn;\r\n}\r\nfor (i = 0; i < 2; i++) {\r\nstruct scatterlist *sg = &s->sg_rx[i];\r\nsg_init_table(sg, 1);\r\ns->rx_buf[i] = buf;\r\nsg_dma_address(sg) = dma;\r\nsg_dma_len(sg) = s->buf_len_rx;\r\nbuf += s->buf_len_rx;\r\ndma += s->buf_len_rx;\r\n}\r\nsetup_timer(&s->rx_timer, rx_timer_fn, (unsigned long)s);\r\nif (port->type == PORT_SCIFA || port->type == PORT_SCIFB)\r\nsci_submit_rx(s);\r\n}\r\n}\r\nstatic void sci_free_dma(struct uart_port *port)\r\n{\r\nstruct sci_port *s = to_sci_port(port);\r\nif (s->chan_tx)\r\nsci_tx_dma_release(s, false);\r\nif (s->chan_rx)\r\nsci_rx_dma_release(s, false);\r\n}\r\nstatic inline void sci_request_dma(struct uart_port *port)\r\n{\r\n}\r\nstatic inline void sci_free_dma(struct uart_port *port)\r\n{\r\n}\r\nstatic irqreturn_t sci_rx_interrupt(int irq, void *ptr)\r\n{\r\n#ifdef CONFIG_SERIAL_SH_SCI_DMA\r\nstruct uart_port *port = ptr;\r\nstruct sci_port *s = to_sci_port(port);\r\nif (s->chan_rx) {\r\nu16 scr = serial_port_in(port, SCSCR);\r\nu16 ssr = serial_port_in(port, SCxSR);\r\nif (port->type == PORT_SCIFA || port->type == PORT_SCIFB) {\r\ndisable_irq_nosync(irq);\r\nscr |= SCSCR_RDRQE;\r\n} else {\r\nscr &= ~SCSCR_RIE;\r\nsci_submit_rx(s);\r\n}\r\nserial_port_out(port, SCSCR, scr);\r\nserial_port_out(port, SCxSR,\r\nssr & ~(SCIF_DR | SCxSR_RDxF(port)));\r\ndev_dbg(port->dev, "Rx IRQ %lu: setup t-out in %u jiffies\n",\r\njiffies, s->rx_timeout);\r\nmod_timer(&s->rx_timer, jiffies + s->rx_timeout);\r\nreturn IRQ_HANDLED;\r\n}\r\n#endif\r\nsci_receive_chars(ptr);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic irqreturn_t sci_tx_interrupt(int irq, void *ptr)\r\n{\r\nstruct uart_port *port = ptr;\r\nunsigned long flags;\r\nspin_lock_irqsave(&port->lock, flags);\r\nsci_transmit_chars(port);\r\nspin_unlock_irqrestore(&port->lock, flags);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic irqreturn_t sci_er_interrupt(int irq, void *ptr)\r\n{\r\nstruct uart_port *port = ptr;\r\nstruct sci_port *s = to_sci_port(port);\r\nif (port->type == PORT_SCI) {\r\nif (sci_handle_errors(port)) {\r\nserial_port_in(port, SCxSR);\r\nsci_clear_SCxSR(port, SCxSR_RDxF_CLEAR(port));\r\n}\r\n} else {\r\nsci_handle_fifo_overrun(port);\r\nif (!s->chan_rx)\r\nsci_receive_chars(ptr);\r\n}\r\nsci_clear_SCxSR(port, SCxSR_ERROR_CLEAR(port));\r\nif (!s->chan_tx)\r\nsci_tx_interrupt(irq, ptr);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic irqreturn_t sci_br_interrupt(int irq, void *ptr)\r\n{\r\nstruct uart_port *port = ptr;\r\nsci_handle_breaks(port);\r\nsci_clear_SCxSR(port, SCxSR_BREAK_CLEAR(port));\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic irqreturn_t sci_mpxed_interrupt(int irq, void *ptr)\r\n{\r\nunsigned short ssr_status, scr_status, err_enabled, orer_status = 0;\r\nstruct uart_port *port = ptr;\r\nstruct sci_port *s = to_sci_port(port);\r\nirqreturn_t ret = IRQ_NONE;\r\nssr_status = serial_port_in(port, SCxSR);\r\nscr_status = serial_port_in(port, SCSCR);\r\nif (s->overrun_reg == SCxSR)\r\norer_status = ssr_status;\r\nelse {\r\nif (sci_getreg(port, s->overrun_reg)->size)\r\norer_status = serial_port_in(port, s->overrun_reg);\r\n}\r\nerr_enabled = scr_status & port_rx_irq_mask(port);\r\nif ((ssr_status & SCxSR_TDxE(port)) && (scr_status & SCSCR_TIE) &&\r\n!s->chan_tx)\r\nret = sci_tx_interrupt(irq, ptr);\r\nif (((ssr_status & SCxSR_RDxF(port)) || s->chan_rx) &&\r\n(scr_status & SCSCR_RIE))\r\nret = sci_rx_interrupt(irq, ptr);\r\nif ((ssr_status & SCxSR_ERRORS(port)) && err_enabled)\r\nret = sci_er_interrupt(irq, ptr);\r\nif ((ssr_status & SCxSR_BRK(port)) && err_enabled)\r\nret = sci_br_interrupt(irq, ptr);\r\nif (orer_status & s->overrun_mask) {\r\nsci_handle_fifo_overrun(port);\r\nret = IRQ_HANDLED;\r\n}\r\nreturn ret;\r\n}\r\nstatic int sci_request_irq(struct sci_port *port)\r\n{\r\nstruct uart_port *up = &port->port;\r\nint i, j, ret = 0;\r\nfor (i = j = 0; i < SCIx_NR_IRQS; i++, j++) {\r\nconst struct sci_irq_desc *desc;\r\nint irq;\r\nif (SCIx_IRQ_IS_MUXED(port)) {\r\ni = SCIx_MUX_IRQ;\r\nirq = up->irq;\r\n} else {\r\nirq = port->irqs[i];\r\nif (unlikely(irq < 0))\r\ncontinue;\r\n}\r\ndesc = sci_irq_desc + i;\r\nport->irqstr[j] = kasprintf(GFP_KERNEL, "%s:%s",\r\ndev_name(up->dev), desc->desc);\r\nif (!port->irqstr[j])\r\ngoto out_nomem;\r\nret = request_irq(irq, desc->handler, up->irqflags,\r\nport->irqstr[j], port);\r\nif (unlikely(ret)) {\r\ndev_err(up->dev, "Can't allocate %s IRQ\n", desc->desc);\r\ngoto out_noirq;\r\n}\r\n}\r\nreturn 0;\r\nout_noirq:\r\nwhile (--i >= 0)\r\nfree_irq(port->irqs[i], port);\r\nout_nomem:\r\nwhile (--j >= 0)\r\nkfree(port->irqstr[j]);\r\nreturn ret;\r\n}\r\nstatic void sci_free_irq(struct sci_port *port)\r\n{\r\nint i;\r\nfor (i = 0; i < SCIx_NR_IRQS; i++) {\r\nint irq = port->irqs[i];\r\nif (unlikely(irq < 0))\r\ncontinue;\r\nfree_irq(port->irqs[i], port);\r\nkfree(port->irqstr[i]);\r\nif (SCIx_IRQ_IS_MUXED(port)) {\r\nreturn;\r\n}\r\n}\r\n}\r\nstatic unsigned int sci_tx_empty(struct uart_port *port)\r\n{\r\nunsigned short status = serial_port_in(port, SCxSR);\r\nunsigned short in_tx_fifo = sci_txfill(port);\r\nreturn (status & SCxSR_TEND(port)) && !in_tx_fifo ? TIOCSER_TEMT : 0;\r\n}\r\nstatic void sci_set_mctrl(struct uart_port *port, unsigned int mctrl)\r\n{\r\nif (mctrl & TIOCM_LOOP) {\r\nconst struct plat_sci_reg *reg;\r\nreg = sci_getreg(port, SCFCR);\r\nif (reg->size)\r\nserial_port_out(port, SCFCR,\r\nserial_port_in(port, SCFCR) |\r\nSCFCR_LOOP);\r\n}\r\n}\r\nstatic unsigned int sci_get_mctrl(struct uart_port *port)\r\n{\r\nreturn TIOCM_DSR | TIOCM_CAR;\r\n}\r\nstatic void sci_break_ctl(struct uart_port *port, int break_state)\r\n{\r\nstruct sci_port *s = to_sci_port(port);\r\nconst struct plat_sci_reg *reg = sci_regmap[s->cfg->regtype] + SCSPTR;\r\nunsigned short scscr, scsptr;\r\nif (!reg->size) {\r\nreturn;\r\n}\r\nscsptr = serial_port_in(port, SCSPTR);\r\nscscr = serial_port_in(port, SCSCR);\r\nif (break_state == -1) {\r\nscsptr = (scsptr | SCSPTR_SPB2IO) & ~SCSPTR_SPB2DT;\r\nscscr &= ~SCSCR_TE;\r\n} else {\r\nscsptr = (scsptr | SCSPTR_SPB2DT) & ~SCSPTR_SPB2IO;\r\nscscr |= SCSCR_TE;\r\n}\r\nserial_port_out(port, SCSPTR, scsptr);\r\nserial_port_out(port, SCSCR, scscr);\r\n}\r\nstatic int sci_startup(struct uart_port *port)\r\n{\r\nstruct sci_port *s = to_sci_port(port);\r\nunsigned long flags;\r\nint ret;\r\ndev_dbg(port->dev, "%s(%d)\n", __func__, port->line);\r\nret = sci_request_irq(s);\r\nif (unlikely(ret < 0))\r\nreturn ret;\r\nsci_request_dma(port);\r\nspin_lock_irqsave(&port->lock, flags);\r\nsci_start_tx(port);\r\nsci_start_rx(port);\r\nspin_unlock_irqrestore(&port->lock, flags);\r\nreturn 0;\r\n}\r\nstatic void sci_shutdown(struct uart_port *port)\r\n{\r\nstruct sci_port *s = to_sci_port(port);\r\nunsigned long flags;\r\ndev_dbg(port->dev, "%s(%d)\n", __func__, port->line);\r\nspin_lock_irqsave(&port->lock, flags);\r\nsci_stop_rx(port);\r\nsci_stop_tx(port);\r\nspin_unlock_irqrestore(&port->lock, flags);\r\n#ifdef CONFIG_SERIAL_SH_SCI_DMA\r\nif (s->chan_rx) {\r\ndev_dbg(port->dev, "%s(%d) deleting rx_timer\n", __func__,\r\nport->line);\r\ndel_timer_sync(&s->rx_timer);\r\n}\r\n#endif\r\nsci_free_dma(port);\r\nsci_free_irq(s);\r\n}\r\nstatic int sci_sck_calc(struct sci_port *s, unsigned int bps,\r\nunsigned int *srr)\r\n{\r\nunsigned long freq = s->clk_rates[SCI_SCK];\r\nint err, min_err = INT_MAX;\r\nunsigned int sr;\r\nif (s->port.type != PORT_HSCIF)\r\nfreq *= 2;\r\nfor_each_sr(sr, s) {\r\nerr = DIV_ROUND_CLOSEST(freq, sr) - bps;\r\nif (abs(err) >= abs(min_err))\r\ncontinue;\r\nmin_err = err;\r\n*srr = sr - 1;\r\nif (!err)\r\nbreak;\r\n}\r\ndev_dbg(s->port.dev, "SCK: %u%+d bps using SR %u\n", bps, min_err,\r\n*srr + 1);\r\nreturn min_err;\r\n}\r\nstatic int sci_brg_calc(struct sci_port *s, unsigned int bps,\r\nunsigned long freq, unsigned int *dlr,\r\nunsigned int *srr)\r\n{\r\nint err, min_err = INT_MAX;\r\nunsigned int sr, dl;\r\nif (s->port.type != PORT_HSCIF)\r\nfreq *= 2;\r\nfor_each_sr(sr, s) {\r\ndl = DIV_ROUND_CLOSEST(freq, sr * bps);\r\ndl = clamp(dl, 1U, 65535U);\r\nerr = DIV_ROUND_CLOSEST(freq, sr * dl) - bps;\r\nif (abs(err) >= abs(min_err))\r\ncontinue;\r\nmin_err = err;\r\n*dlr = dl;\r\n*srr = sr - 1;\r\nif (!err)\r\nbreak;\r\n}\r\ndev_dbg(s->port.dev, "BRG: %u%+d bps using DL %u SR %u\n", bps,\r\nmin_err, *dlr, *srr + 1);\r\nreturn min_err;\r\n}\r\nstatic int sci_scbrr_calc(struct sci_port *s, unsigned int bps,\r\nunsigned int *brr, unsigned int *srr,\r\nunsigned int *cks)\r\n{\r\nunsigned long freq = s->clk_rates[SCI_FCK];\r\nunsigned int sr, br, prediv, scrate, c;\r\nint err, min_err = INT_MAX;\r\nif (s->port.type != PORT_HSCIF)\r\nfreq *= 2;\r\nfor_each_sr(sr, s) {\r\nfor (c = 0; c <= 3; c++) {\r\nprediv = sr * (1 << (2 * c + 1));\r\nif (bps > UINT_MAX / prediv)\r\nbreak;\r\nscrate = prediv * bps;\r\nbr = DIV_ROUND_CLOSEST(freq, scrate);\r\nbr = clamp(br, 1U, 256U);\r\nerr = DIV_ROUND_CLOSEST(freq, br * prediv) - bps;\r\nif (abs(err) >= abs(min_err))\r\ncontinue;\r\nmin_err = err;\r\n*brr = br - 1;\r\n*srr = sr - 1;\r\n*cks = c;\r\nif (!err)\r\ngoto found;\r\n}\r\n}\r\nfound:\r\ndev_dbg(s->port.dev, "BRR: %u%+d bps using N %u SR %u cks %u\n", bps,\r\nmin_err, *brr, *srr + 1, *cks);\r\nreturn min_err;\r\n}\r\nstatic void sci_reset(struct uart_port *port)\r\n{\r\nconst struct plat_sci_reg *reg;\r\nunsigned int status;\r\ndo {\r\nstatus = serial_port_in(port, SCxSR);\r\n} while (!(status & SCxSR_TEND(port)));\r\nserial_port_out(port, SCSCR, 0x00);\r\nreg = sci_getreg(port, SCFCR);\r\nif (reg->size)\r\nserial_port_out(port, SCFCR, SCFCR_RFRST | SCFCR_TFRST);\r\n}\r\nstatic void sci_set_termios(struct uart_port *port, struct ktermios *termios,\r\nstruct ktermios *old)\r\n{\r\nunsigned int baud, smr_val = SCSMR_ASYNC, scr_val = 0, i;\r\nunsigned int brr = 255, cks = 0, srr = 15, dl = 0, sccks = 0;\r\nunsigned int brr1 = 255, cks1 = 0, srr1 = 15, dl1 = 0;\r\nstruct sci_port *s = to_sci_port(port);\r\nconst struct plat_sci_reg *reg;\r\nint min_err = INT_MAX, err;\r\nunsigned long max_freq = 0;\r\nint best_clk = -1;\r\nif ((termios->c_cflag & CSIZE) == CS7)\r\nsmr_val |= SCSMR_CHR;\r\nif (termios->c_cflag & PARENB)\r\nsmr_val |= SCSMR_PE;\r\nif (termios->c_cflag & PARODD)\r\nsmr_val |= SCSMR_PE | SCSMR_ODD;\r\nif (termios->c_cflag & CSTOPB)\r\nsmr_val |= SCSMR_STOP;\r\nif (!port->uartclk) {\r\nbaud = uart_get_baud_rate(port, termios, old, 0, 115200);\r\ngoto done;\r\n}\r\nfor (i = 0; i < SCI_NUM_CLKS; i++)\r\nmax_freq = max(max_freq, s->clk_rates[i]);\r\nbaud = uart_get_baud_rate(port, termios, old, 0, max_freq / min_sr(s));\r\nif (!baud)\r\ngoto done;\r\nif (s->clk_rates[SCI_SCK] && port->type != PORT_SCIFA &&\r\nport->type != PORT_SCIFB) {\r\nerr = sci_sck_calc(s, baud, &srr1);\r\nif (abs(err) < abs(min_err)) {\r\nbest_clk = SCI_SCK;\r\nscr_val = SCSCR_CKE1;\r\nsccks = SCCKS_CKS;\r\nmin_err = err;\r\nsrr = srr1;\r\nif (!err)\r\ngoto done;\r\n}\r\n}\r\nif (s->clk_rates[SCI_SCIF_CLK] && sci_getreg(port, SCDL)->size) {\r\nerr = sci_brg_calc(s, baud, s->clk_rates[SCI_SCIF_CLK], &dl1,\r\n&srr1);\r\nif (abs(err) < abs(min_err)) {\r\nbest_clk = SCI_SCIF_CLK;\r\nscr_val = SCSCR_CKE1;\r\nsccks = 0;\r\nmin_err = err;\r\ndl = dl1;\r\nsrr = srr1;\r\nif (!err)\r\ngoto done;\r\n}\r\n}\r\nif (s->clk_rates[SCI_BRG_INT] && sci_getreg(port, SCDL)->size) {\r\nerr = sci_brg_calc(s, baud, s->clk_rates[SCI_BRG_INT], &dl1,\r\n&srr1);\r\nif (abs(err) < abs(min_err)) {\r\nbest_clk = SCI_BRG_INT;\r\nscr_val = SCSCR_CKE1;\r\nsccks = SCCKS_XIN;\r\nmin_err = err;\r\ndl = dl1;\r\nsrr = srr1;\r\nif (!min_err)\r\ngoto done;\r\n}\r\n}\r\nerr = sci_scbrr_calc(s, baud, &brr1, &srr1, &cks1);\r\nif (abs(err) < abs(min_err)) {\r\nbest_clk = SCI_FCK;\r\nscr_val = 0;\r\nmin_err = err;\r\nbrr = brr1;\r\nsrr = srr1;\r\ncks = cks1;\r\n}\r\ndone:\r\nif (best_clk >= 0)\r\ndev_dbg(port->dev, "Using clk %pC for %u%+d bps\n",\r\ns->clks[best_clk], baud, min_err);\r\nsci_port_enable(s);\r\nif (best_clk >= 0 && sci_getreg(port, SCCKS)->size) {\r\nserial_port_out(port, SCDL, dl);\r\nserial_port_out(port, SCCKS, sccks);\r\n}\r\nsci_reset(port);\r\nuart_update_timeout(port, termios->c_cflag, baud);\r\nif (best_clk >= 0) {\r\nif (port->type == PORT_SCIFA || port->type == PORT_SCIFB)\r\nswitch (srr + 1) {\r\ncase 5: smr_val |= SCSMR_SRC_5; break;\r\ncase 7: smr_val |= SCSMR_SRC_7; break;\r\ncase 11: smr_val |= SCSMR_SRC_11; break;\r\ncase 13: smr_val |= SCSMR_SRC_13; break;\r\ncase 16: smr_val |= SCSMR_SRC_16; break;\r\ncase 17: smr_val |= SCSMR_SRC_17; break;\r\ncase 19: smr_val |= SCSMR_SRC_19; break;\r\ncase 27: smr_val |= SCSMR_SRC_27; break;\r\n}\r\nsmr_val |= cks;\r\ndev_dbg(port->dev,\r\n"SCR 0x%x SMR 0x%x BRR %u CKS 0x%x DL %u SRR %u\n",\r\nscr_val, smr_val, brr, sccks, dl, srr);\r\nserial_port_out(port, SCSCR, scr_val);\r\nserial_port_out(port, SCSMR, smr_val);\r\nserial_port_out(port, SCBRR, brr);\r\nif (sci_getreg(port, HSSRR)->size)\r\nserial_port_out(port, HSSRR, srr | HSCIF_SRE);\r\nudelay((1000000 + (baud - 1)) / baud);\r\n} else {\r\nscr_val = s->cfg->scscr & (SCSCR_CKE1 | SCSCR_CKE0);\r\nsmr_val |= serial_port_in(port, SCSMR) &\r\n(SCSMR_CKEDG | SCSMR_SRC_MASK | SCSMR_CKS);\r\ndev_dbg(port->dev, "SCR 0x%x SMR 0x%x\n", scr_val, smr_val);\r\nserial_port_out(port, SCSCR, scr_val);\r\nserial_port_out(port, SCSMR, smr_val);\r\n}\r\nsci_init_pins(port, termios->c_cflag);\r\nreg = sci_getreg(port, SCFCR);\r\nif (reg->size) {\r\nunsigned short ctrl = serial_port_in(port, SCFCR);\r\nif (s->cfg->capabilities & SCIx_HAVE_RTSCTS) {\r\nif (termios->c_cflag & CRTSCTS)\r\nctrl |= SCFCR_MCE;\r\nelse\r\nctrl &= ~SCFCR_MCE;\r\n}\r\nctrl &= ~(SCFCR_RFRST | SCFCR_TFRST);\r\nserial_port_out(port, SCFCR, ctrl);\r\n}\r\nscr_val |= s->cfg->scscr & ~(SCSCR_CKE1 | SCSCR_CKE0);\r\ndev_dbg(port->dev, "SCSCR 0x%x\n", scr_val);\r\nserial_port_out(port, SCSCR, scr_val);\r\nif ((srr + 1 == 5) &&\r\n(port->type == PORT_SCIFA || port->type == PORT_SCIFB)) {\r\nudelay(DIV_ROUND_UP(10 * 1000000, baud));\r\n}\r\n#ifdef CONFIG_SERIAL_SH_SCI_DMA\r\nif (s->chan_rx) {\r\nunsigned int bits;\r\nswitch (termios->c_cflag & CSIZE) {\r\ncase CS5:\r\nbits = 7;\r\nbreak;\r\ncase CS6:\r\nbits = 8;\r\nbreak;\r\ncase CS7:\r\nbits = 9;\r\nbreak;\r\ndefault:\r\nbits = 10;\r\nbreak;\r\n}\r\nif (termios->c_cflag & CSTOPB)\r\nbits++;\r\nif (termios->c_cflag & PARENB)\r\nbits++;\r\ns->rx_timeout = DIV_ROUND_UP((s->buf_len_rx * 2 * bits * HZ) /\r\n(baud / 10), 10);\r\ndev_dbg(port->dev, "DMA Rx t-out %ums, tty t-out %u jiffies\n",\r\ns->rx_timeout * 1000 / HZ, port->timeout);\r\nif (s->rx_timeout < msecs_to_jiffies(20))\r\ns->rx_timeout = msecs_to_jiffies(20);\r\n}\r\n#endif\r\nif ((termios->c_cflag & CREAD) != 0)\r\nsci_start_rx(port);\r\nsci_port_disable(s);\r\n}\r\nstatic void sci_pm(struct uart_port *port, unsigned int state,\r\nunsigned int oldstate)\r\n{\r\nstruct sci_port *sci_port = to_sci_port(port);\r\nswitch (state) {\r\ncase UART_PM_STATE_OFF:\r\nsci_port_disable(sci_port);\r\nbreak;\r\ndefault:\r\nsci_port_enable(sci_port);\r\nbreak;\r\n}\r\n}\r\nstatic const char *sci_type(struct uart_port *port)\r\n{\r\nswitch (port->type) {\r\ncase PORT_IRDA:\r\nreturn "irda";\r\ncase PORT_SCI:\r\nreturn "sci";\r\ncase PORT_SCIF:\r\nreturn "scif";\r\ncase PORT_SCIFA:\r\nreturn "scifa";\r\ncase PORT_SCIFB:\r\nreturn "scifb";\r\ncase PORT_HSCIF:\r\nreturn "hscif";\r\n}\r\nreturn NULL;\r\n}\r\nstatic int sci_remap_port(struct uart_port *port)\r\n{\r\nstruct sci_port *sport = to_sci_port(port);\r\nif (port->membase)\r\nreturn 0;\r\nif (port->flags & UPF_IOREMAP) {\r\nport->membase = ioremap_nocache(port->mapbase, sport->reg_size);\r\nif (unlikely(!port->membase)) {\r\ndev_err(port->dev, "can't remap port#%d\n", port->line);\r\nreturn -ENXIO;\r\n}\r\n} else {\r\nport->membase = (void __iomem *)(uintptr_t)port->mapbase;\r\n}\r\nreturn 0;\r\n}\r\nstatic void sci_release_port(struct uart_port *port)\r\n{\r\nstruct sci_port *sport = to_sci_port(port);\r\nif (port->flags & UPF_IOREMAP) {\r\niounmap(port->membase);\r\nport->membase = NULL;\r\n}\r\nrelease_mem_region(port->mapbase, sport->reg_size);\r\n}\r\nstatic int sci_request_port(struct uart_port *port)\r\n{\r\nstruct resource *res;\r\nstruct sci_port *sport = to_sci_port(port);\r\nint ret;\r\nres = request_mem_region(port->mapbase, sport->reg_size,\r\ndev_name(port->dev));\r\nif (unlikely(res == NULL)) {\r\ndev_err(port->dev, "request_mem_region failed.");\r\nreturn -EBUSY;\r\n}\r\nret = sci_remap_port(port);\r\nif (unlikely(ret != 0)) {\r\nrelease_resource(res);\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic void sci_config_port(struct uart_port *port, int flags)\r\n{\r\nif (flags & UART_CONFIG_TYPE) {\r\nstruct sci_port *sport = to_sci_port(port);\r\nport->type = sport->cfg->type;\r\nsci_request_port(port);\r\n}\r\n}\r\nstatic int sci_verify_port(struct uart_port *port, struct serial_struct *ser)\r\n{\r\nif (ser->baud_base < 2400)\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\nstatic int sci_init_clocks(struct sci_port *sci_port, struct device *dev)\r\n{\r\nconst char *clk_names[] = {\r\n[SCI_FCK] = "fck",\r\n[SCI_SCK] = "sck",\r\n[SCI_BRG_INT] = "brg_int",\r\n[SCI_SCIF_CLK] = "scif_clk",\r\n};\r\nstruct clk *clk;\r\nunsigned int i;\r\nif (sci_port->cfg->type == PORT_HSCIF)\r\nclk_names[SCI_SCK] = "hsck";\r\nfor (i = 0; i < SCI_NUM_CLKS; i++) {\r\nclk = devm_clk_get(dev, clk_names[i]);\r\nif (PTR_ERR(clk) == -EPROBE_DEFER)\r\nreturn -EPROBE_DEFER;\r\nif (IS_ERR(clk) && i == SCI_FCK) {\r\nclk = devm_clk_get(dev, "sci_ick");\r\nif (PTR_ERR(clk) == -EPROBE_DEFER)\r\nreturn -EPROBE_DEFER;\r\nif (!IS_ERR(clk))\r\ngoto found;\r\nclk = devm_clk_get(dev, "peripheral_clk");\r\nif (!IS_ERR(clk))\r\ngoto found;\r\ndev_err(dev, "failed to get %s (%ld)\n", clk_names[i],\r\nPTR_ERR(clk));\r\nreturn PTR_ERR(clk);\r\n}\r\nfound:\r\nif (IS_ERR(clk))\r\ndev_dbg(dev, "failed to get %s (%ld)\n", clk_names[i],\r\nPTR_ERR(clk));\r\nelse\r\ndev_dbg(dev, "clk %s is %pC rate %pCr\n", clk_names[i],\r\nclk, clk);\r\nsci_port->clks[i] = IS_ERR(clk) ? NULL : clk;\r\n}\r\nreturn 0;\r\n}\r\nstatic int sci_init_single(struct platform_device *dev,\r\nstruct sci_port *sci_port, unsigned int index,\r\nstruct plat_sci_port *p, bool early)\r\n{\r\nstruct uart_port *port = &sci_port->port;\r\nconst struct resource *res;\r\nunsigned int i;\r\nint ret;\r\nsci_port->cfg = p;\r\nport->ops = &sci_uart_ops;\r\nport->iotype = UPIO_MEM;\r\nport->line = index;\r\nres = platform_get_resource(dev, IORESOURCE_MEM, 0);\r\nif (res == NULL)\r\nreturn -ENOMEM;\r\nport->mapbase = res->start;\r\nsci_port->reg_size = resource_size(res);\r\nfor (i = 0; i < ARRAY_SIZE(sci_port->irqs); ++i)\r\nsci_port->irqs[i] = platform_get_irq(dev, i);\r\nif (sci_port->irqs[0] < 0)\r\nreturn -ENXIO;\r\nif (sci_port->irqs[1] < 0) {\r\nsci_port->irqs[1] = sci_port->irqs[0];\r\nsci_port->irqs[2] = sci_port->irqs[0];\r\nsci_port->irqs[3] = sci_port->irqs[0];\r\n}\r\nif (p->regtype == SCIx_PROBE_REGTYPE) {\r\nret = sci_probe_regmap(p);\r\nif (unlikely(ret))\r\nreturn ret;\r\n}\r\nswitch (p->type) {\r\ncase PORT_SCIFB:\r\nport->fifosize = 256;\r\nsci_port->overrun_reg = SCxSR;\r\nsci_port->overrun_mask = SCIFA_ORER;\r\nsci_port->sampling_rate_mask = SCI_SR_SCIFAB;\r\nbreak;\r\ncase PORT_HSCIF:\r\nport->fifosize = 128;\r\nsci_port->overrun_reg = SCLSR;\r\nsci_port->overrun_mask = SCLSR_ORER;\r\nsci_port->sampling_rate_mask = SCI_SR_RANGE(8, 32);\r\nbreak;\r\ncase PORT_SCIFA:\r\nport->fifosize = 64;\r\nsci_port->overrun_reg = SCxSR;\r\nsci_port->overrun_mask = SCIFA_ORER;\r\nsci_port->sampling_rate_mask = SCI_SR_SCIFAB;\r\nbreak;\r\ncase PORT_SCIF:\r\nport->fifosize = 16;\r\nif (p->regtype == SCIx_SH7705_SCIF_REGTYPE) {\r\nsci_port->overrun_reg = SCxSR;\r\nsci_port->overrun_mask = SCIFA_ORER;\r\nsci_port->sampling_rate_mask = SCI_SR(16);\r\n} else {\r\nsci_port->overrun_reg = SCLSR;\r\nsci_port->overrun_mask = SCLSR_ORER;\r\nsci_port->sampling_rate_mask = SCI_SR(32);\r\n}\r\nbreak;\r\ndefault:\r\nport->fifosize = 1;\r\nsci_port->overrun_reg = SCxSR;\r\nsci_port->overrun_mask = SCI_ORER;\r\nsci_port->sampling_rate_mask = SCI_SR(32);\r\nbreak;\r\n}\r\nif (p->sampling_rate)\r\nsci_port->sampling_rate_mask = SCI_SR(p->sampling_rate);\r\nif (!early) {\r\nret = sci_init_clocks(sci_port, &dev->dev);\r\nif (ret < 0)\r\nreturn ret;\r\nport->dev = &dev->dev;\r\npm_runtime_enable(&dev->dev);\r\n}\r\nsci_port->break_timer.data = (unsigned long)sci_port;\r\nsci_port->break_timer.function = sci_break_timer;\r\ninit_timer(&sci_port->break_timer);\r\nif (p->type == PORT_SCI) {\r\nsci_port->error_mask = SCI_DEFAULT_ERROR_MASK;\r\nsci_port->error_clear = SCI_ERROR_CLEAR;\r\n} else {\r\nsci_port->error_mask = SCIF_DEFAULT_ERROR_MASK;\r\nsci_port->error_clear = SCIF_ERROR_CLEAR;\r\n}\r\nif (sci_port->overrun_reg == SCxSR) {\r\nsci_port->error_mask |= sci_port->overrun_mask;\r\nsci_port->error_clear &= ~sci_port->overrun_mask;\r\n}\r\nport->type = p->type;\r\nport->flags = UPF_FIXED_PORT | p->flags;\r\nport->regshift = p->regshift;\r\nport->irq = sci_port->irqs[SCIx_RXI_IRQ];\r\nport->irqflags = 0;\r\nport->serial_in = sci_serial_in;\r\nport->serial_out = sci_serial_out;\r\nif (p->dma_slave_tx > 0 && p->dma_slave_rx > 0)\r\ndev_dbg(port->dev, "DMA tx %d, rx %d\n",\r\np->dma_slave_tx, p->dma_slave_rx);\r\nreturn 0;\r\n}\r\nstatic void sci_cleanup_single(struct sci_port *port)\r\n{\r\npm_runtime_disable(port->port.dev);\r\n}\r\nstatic void serial_console_putchar(struct uart_port *port, int ch)\r\n{\r\nsci_poll_put_char(port, ch);\r\n}\r\nstatic void serial_console_write(struct console *co, const char *s,\r\nunsigned count)\r\n{\r\nstruct sci_port *sci_port = &sci_ports[co->index];\r\nstruct uart_port *port = &sci_port->port;\r\nunsigned short bits, ctrl, ctrl_temp;\r\nunsigned long flags;\r\nint locked = 1;\r\nlocal_irq_save(flags);\r\n#if defined(SUPPORT_SYSRQ)\r\nif (port->sysrq)\r\nlocked = 0;\r\nelse\r\n#endif\r\nif (oops_in_progress)\r\nlocked = spin_trylock(&port->lock);\r\nelse\r\nspin_lock(&port->lock);\r\nctrl = serial_port_in(port, SCSCR);\r\nctrl_temp = (sci_port->cfg->scscr & ~(SCSCR_CKE1 | SCSCR_CKE0)) |\r\n(ctrl & (SCSCR_CKE1 | SCSCR_CKE0));\r\nserial_port_out(port, SCSCR, ctrl_temp);\r\nuart_console_write(port, s, count, serial_console_putchar);\r\nbits = SCxSR_TDxE(port) | SCxSR_TEND(port);\r\nwhile ((serial_port_in(port, SCxSR) & bits) != bits)\r\ncpu_relax();\r\nserial_port_out(port, SCSCR, ctrl);\r\nif (locked)\r\nspin_unlock(&port->lock);\r\nlocal_irq_restore(flags);\r\n}\r\nstatic int serial_console_setup(struct console *co, char *options)\r\n{\r\nstruct sci_port *sci_port;\r\nstruct uart_port *port;\r\nint baud = 115200;\r\nint bits = 8;\r\nint parity = 'n';\r\nint flow = 'n';\r\nint ret;\r\nif (co->index < 0 || co->index >= SCI_NPORTS)\r\nreturn -ENODEV;\r\nsci_port = &sci_ports[co->index];\r\nport = &sci_port->port;\r\nif (!port->ops)\r\nreturn -ENODEV;\r\nret = sci_remap_port(port);\r\nif (unlikely(ret != 0))\r\nreturn ret;\r\nif (options)\r\nuart_parse_options(options, &baud, &parity, &bits, &flow);\r\nreturn uart_set_options(port, co, baud, parity, bits, flow);\r\n}\r\nstatic int sci_probe_earlyprintk(struct platform_device *pdev)\r\n{\r\nstruct plat_sci_port *cfg = dev_get_platdata(&pdev->dev);\r\nif (early_serial_console.data)\r\nreturn -EEXIST;\r\nearly_serial_console.index = pdev->id;\r\nsci_init_single(pdev, &sci_ports[pdev->id], pdev->id, cfg, true);\r\nserial_console_setup(&early_serial_console, early_serial_buf);\r\nif (!strstr(early_serial_buf, "keep"))\r\nearly_serial_console.flags |= CON_BOOT;\r\nregister_console(&early_serial_console);\r\nreturn 0;\r\n}\r\nstatic inline int sci_probe_earlyprintk(struct platform_device *pdev)\r\n{\r\nreturn -EINVAL;\r\n}\r\nstatic int sci_remove(struct platform_device *dev)\r\n{\r\nstruct sci_port *port = platform_get_drvdata(dev);\r\nuart_remove_one_port(&sci_uart_driver, &port->port);\r\nsci_cleanup_single(port);\r\nreturn 0;\r\n}\r\nstatic struct plat_sci_port *\r\nsci_parse_dt(struct platform_device *pdev, unsigned int *dev_id)\r\n{\r\nstruct device_node *np = pdev->dev.of_node;\r\nconst struct of_device_id *match;\r\nstruct plat_sci_port *p;\r\nint id;\r\nif (!IS_ENABLED(CONFIG_OF) || !np)\r\nreturn NULL;\r\nmatch = of_match_node(of_sci_match, np);\r\nif (!match)\r\nreturn NULL;\r\np = devm_kzalloc(&pdev->dev, sizeof(struct plat_sci_port), GFP_KERNEL);\r\nif (!p)\r\nreturn NULL;\r\nid = of_alias_get_id(np, "serial");\r\nif (id < 0) {\r\ndev_err(&pdev->dev, "failed to get alias id (%d)\n", id);\r\nreturn NULL;\r\n}\r\n*dev_id = id;\r\np->flags = UPF_IOREMAP | UPF_BOOT_AUTOCONF;\r\np->type = SCI_OF_TYPE(match->data);\r\np->regtype = SCI_OF_REGTYPE(match->data);\r\np->scscr = SCSCR_RE | SCSCR_TE;\r\nreturn p;\r\n}\r\nstatic int sci_probe_single(struct platform_device *dev,\r\nunsigned int index,\r\nstruct plat_sci_port *p,\r\nstruct sci_port *sciport)\r\n{\r\nint ret;\r\nif (unlikely(index >= SCI_NPORTS)) {\r\ndev_notice(&dev->dev, "Attempting to register port %d when only %d are available\n",\r\nindex+1, SCI_NPORTS);\r\ndev_notice(&dev->dev, "Consider bumping CONFIG_SERIAL_SH_SCI_NR_UARTS!\n");\r\nreturn -EINVAL;\r\n}\r\nret = sci_init_single(dev, sciport, index, p, false);\r\nif (ret)\r\nreturn ret;\r\nret = uart_add_one_port(&sci_uart_driver, &sciport->port);\r\nif (ret) {\r\nsci_cleanup_single(sciport);\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic int sci_probe(struct platform_device *dev)\r\n{\r\nstruct plat_sci_port *p;\r\nstruct sci_port *sp;\r\nunsigned int dev_id;\r\nint ret;\r\nif (is_early_platform_device(dev))\r\nreturn sci_probe_earlyprintk(dev);\r\nif (dev->dev.of_node) {\r\np = sci_parse_dt(dev, &dev_id);\r\nif (p == NULL)\r\nreturn -EINVAL;\r\n} else {\r\np = dev->dev.platform_data;\r\nif (p == NULL) {\r\ndev_err(&dev->dev, "no platform data supplied\n");\r\nreturn -EINVAL;\r\n}\r\ndev_id = dev->id;\r\n}\r\nsp = &sci_ports[dev_id];\r\nplatform_set_drvdata(dev, sp);\r\nret = sci_probe_single(dev, dev_id, p, sp);\r\nif (ret)\r\nreturn ret;\r\n#ifdef CONFIG_SH_STANDARD_BIOS\r\nsh_bios_gdb_detach();\r\n#endif\r\nreturn 0;\r\n}\r\nstatic __maybe_unused int sci_suspend(struct device *dev)\r\n{\r\nstruct sci_port *sport = dev_get_drvdata(dev);\r\nif (sport)\r\nuart_suspend_port(&sci_uart_driver, &sport->port);\r\nreturn 0;\r\n}\r\nstatic __maybe_unused int sci_resume(struct device *dev)\r\n{\r\nstruct sci_port *sport = dev_get_drvdata(dev);\r\nif (sport)\r\nuart_resume_port(&sci_uart_driver, &sport->port);\r\nreturn 0;\r\n}\r\nstatic int __init sci_init(void)\r\n{\r\nint ret;\r\npr_info("%s\n", banner);\r\nret = uart_register_driver(&sci_uart_driver);\r\nif (likely(ret == 0)) {\r\nret = platform_driver_register(&sci_driver);\r\nif (unlikely(ret))\r\nuart_unregister_driver(&sci_uart_driver);\r\n}\r\nreturn ret;\r\n}\r\nstatic void __exit sci_exit(void)\r\n{\r\nplatform_driver_unregister(&sci_driver);\r\nuart_unregister_driver(&sci_uart_driver);\r\n}\r\nstatic int __init early_console_setup(struct earlycon_device *device,\r\nint type)\r\n{\r\nif (!device->port.membase)\r\nreturn -ENODEV;\r\ndevice->port.serial_in = sci_serial_in;\r\ndevice->port.serial_out = sci_serial_out;\r\ndevice->port.type = type;\r\nmemcpy(&sci_ports[0].port, &device->port, sizeof(struct uart_port));\r\nsci_ports[0].cfg = &port_cfg;\r\nsci_ports[0].cfg->type = type;\r\nsci_probe_regmap(sci_ports[0].cfg);\r\nport_cfg.scscr = sci_serial_in(&sci_ports[0].port, SCSCR) |\r\nSCSCR_RE | SCSCR_TE;\r\nsci_serial_out(&sci_ports[0].port, SCSCR, port_cfg.scscr);\r\ndevice->con->write = serial_console_write;\r\nreturn 0;\r\n}\r\nstatic int __init sci_early_console_setup(struct earlycon_device *device,\r\nconst char *opt)\r\n{\r\nreturn early_console_setup(device, PORT_SCI);\r\n}\r\nstatic int __init scif_early_console_setup(struct earlycon_device *device,\r\nconst char *opt)\r\n{\r\nreturn early_console_setup(device, PORT_SCIF);\r\n}\r\nstatic int __init scifa_early_console_setup(struct earlycon_device *device,\r\nconst char *opt)\r\n{\r\nreturn early_console_setup(device, PORT_SCIFA);\r\n}\r\nstatic int __init scifb_early_console_setup(struct earlycon_device *device,\r\nconst char *opt)\r\n{\r\nreturn early_console_setup(device, PORT_SCIFB);\r\n}\r\nstatic int __init hscif_early_console_setup(struct earlycon_device *device,\r\nconst char *opt)\r\n{\r\nreturn early_console_setup(device, PORT_HSCIF);\r\n}
