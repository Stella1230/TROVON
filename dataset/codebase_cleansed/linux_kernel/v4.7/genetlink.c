void genl_lock(void)\r\n{\r\nmutex_lock(&genl_mutex);\r\n}\r\nvoid genl_unlock(void)\r\n{\r\nmutex_unlock(&genl_mutex);\r\n}\r\nbool lockdep_genl_is_held(void)\r\n{\r\nreturn lockdep_is_held(&genl_mutex);\r\n}\r\nstatic void genl_lock_all(void)\r\n{\r\ndown_write(&cb_lock);\r\ngenl_lock();\r\n}\r\nstatic void genl_unlock_all(void)\r\n{\r\ngenl_unlock();\r\nup_write(&cb_lock);\r\n}\r\nstatic inline unsigned int genl_family_hash(unsigned int id)\r\n{\r\nreturn id & GENL_FAM_TAB_MASK;\r\n}\r\nstatic inline struct list_head *genl_family_chain(unsigned int id)\r\n{\r\nreturn &family_ht[genl_family_hash(id)];\r\n}\r\nstatic struct genl_family *genl_family_find_byid(unsigned int id)\r\n{\r\nstruct genl_family *f;\r\nlist_for_each_entry(f, genl_family_chain(id), family_list)\r\nif (f->id == id)\r\nreturn f;\r\nreturn NULL;\r\n}\r\nstatic struct genl_family *genl_family_find_byname(char *name)\r\n{\r\nstruct genl_family *f;\r\nint i;\r\nfor (i = 0; i < GENL_FAM_TAB_SIZE; i++)\r\nlist_for_each_entry(f, genl_family_chain(i), family_list)\r\nif (strcmp(f->name, name) == 0)\r\nreturn f;\r\nreturn NULL;\r\n}\r\nstatic const struct genl_ops *genl_get_cmd(u8 cmd, struct genl_family *family)\r\n{\r\nint i;\r\nfor (i = 0; i < family->n_ops; i++)\r\nif (family->ops[i].cmd == cmd)\r\nreturn &family->ops[i];\r\nreturn NULL;\r\n}\r\nstatic u16 genl_generate_id(void)\r\n{\r\nstatic u16 id_gen_idx = GENL_MIN_ID;\r\nint i;\r\nfor (i = 0; i <= GENL_MAX_ID - GENL_MIN_ID; i++) {\r\nif (id_gen_idx != GENL_ID_VFS_DQUOT &&\r\nid_gen_idx != GENL_ID_PMCRAID &&\r\n!genl_family_find_byid(id_gen_idx))\r\nreturn id_gen_idx;\r\nif (++id_gen_idx > GENL_MAX_ID)\r\nid_gen_idx = GENL_MIN_ID;\r\n}\r\nreturn 0;\r\n}\r\nstatic int genl_allocate_reserve_groups(int n_groups, int *first_id)\r\n{\r\nunsigned long *new_groups;\r\nint start = 0;\r\nint i;\r\nint id;\r\nbool fits;\r\ndo {\r\nif (start == 0)\r\nid = find_first_zero_bit(mc_groups,\r\nmc_groups_longs *\r\nBITS_PER_LONG);\r\nelse\r\nid = find_next_zero_bit(mc_groups,\r\nmc_groups_longs * BITS_PER_LONG,\r\nstart);\r\nfits = true;\r\nfor (i = id;\r\ni < min_t(int, id + n_groups,\r\nmc_groups_longs * BITS_PER_LONG);\r\ni++) {\r\nif (test_bit(i, mc_groups)) {\r\nstart = i;\r\nfits = false;\r\nbreak;\r\n}\r\n}\r\nif (id + n_groups > mc_groups_longs * BITS_PER_LONG) {\r\nunsigned long new_longs = mc_groups_longs +\r\nBITS_TO_LONGS(n_groups);\r\nsize_t nlen = new_longs * sizeof(unsigned long);\r\nif (mc_groups == &mc_group_start) {\r\nnew_groups = kzalloc(nlen, GFP_KERNEL);\r\nif (!new_groups)\r\nreturn -ENOMEM;\r\nmc_groups = new_groups;\r\n*mc_groups = mc_group_start;\r\n} else {\r\nnew_groups = krealloc(mc_groups, nlen,\r\nGFP_KERNEL);\r\nif (!new_groups)\r\nreturn -ENOMEM;\r\nmc_groups = new_groups;\r\nfor (i = 0; i < BITS_TO_LONGS(n_groups); i++)\r\nmc_groups[mc_groups_longs + i] = 0;\r\n}\r\nmc_groups_longs = new_longs;\r\n}\r\n} while (!fits);\r\nfor (i = id; i < id + n_groups; i++)\r\nset_bit(i, mc_groups);\r\n*first_id = id;\r\nreturn 0;\r\n}\r\nstatic int genl_validate_assign_mc_groups(struct genl_family *family)\r\n{\r\nint first_id;\r\nint n_groups = family->n_mcgrps;\r\nint err = 0, i;\r\nbool groups_allocated = false;\r\nif (!n_groups)\r\nreturn 0;\r\nfor (i = 0; i < n_groups; i++) {\r\nconst struct genl_multicast_group *grp = &family->mcgrps[i];\r\nif (WARN_ON(grp->name[0] == '\0'))\r\nreturn -EINVAL;\r\nif (WARN_ON(memchr(grp->name, '\0', GENL_NAMSIZ) == NULL))\r\nreturn -EINVAL;\r\n}\r\nif (family == &genl_ctrl) {\r\nfirst_id = GENL_ID_CTRL;\r\nBUG_ON(n_groups != 1);\r\n} else if (strcmp(family->name, "NET_DM") == 0) {\r\nfirst_id = 1;\r\nBUG_ON(n_groups != 1);\r\n} else if (family->id == GENL_ID_VFS_DQUOT) {\r\nfirst_id = GENL_ID_VFS_DQUOT;\r\nBUG_ON(n_groups != 1);\r\n} else if (family->id == GENL_ID_PMCRAID) {\r\nfirst_id = GENL_ID_PMCRAID;\r\nBUG_ON(n_groups != 1);\r\n} else {\r\ngroups_allocated = true;\r\nerr = genl_allocate_reserve_groups(n_groups, &first_id);\r\nif (err)\r\nreturn err;\r\n}\r\nfamily->mcgrp_offset = first_id;\r\nif (!init_net.genl_sock)\r\nreturn 0;\r\nif (family->netnsok) {\r\nstruct net *net;\r\nnetlink_table_grab();\r\nrcu_read_lock();\r\nfor_each_net_rcu(net) {\r\nerr = __netlink_change_ngroups(net->genl_sock,\r\nmc_groups_longs * BITS_PER_LONG);\r\nif (err) {\r\nbreak;\r\n}\r\n}\r\nrcu_read_unlock();\r\nnetlink_table_ungrab();\r\n} else {\r\nerr = netlink_change_ngroups(init_net.genl_sock,\r\nmc_groups_longs * BITS_PER_LONG);\r\n}\r\nif (groups_allocated && err) {\r\nfor (i = 0; i < family->n_mcgrps; i++)\r\nclear_bit(family->mcgrp_offset + i, mc_groups);\r\n}\r\nreturn err;\r\n}\r\nstatic void genl_unregister_mc_groups(struct genl_family *family)\r\n{\r\nstruct net *net;\r\nint i;\r\nnetlink_table_grab();\r\nrcu_read_lock();\r\nfor_each_net_rcu(net) {\r\nfor (i = 0; i < family->n_mcgrps; i++)\r\n__netlink_clear_multicast_users(\r\nnet->genl_sock, family->mcgrp_offset + i);\r\n}\r\nrcu_read_unlock();\r\nnetlink_table_ungrab();\r\nfor (i = 0; i < family->n_mcgrps; i++) {\r\nint grp_id = family->mcgrp_offset + i;\r\nif (grp_id != 1)\r\nclear_bit(grp_id, mc_groups);\r\ngenl_ctrl_event(CTRL_CMD_DELMCAST_GRP, family,\r\n&family->mcgrps[i], grp_id);\r\n}\r\n}\r\nstatic int genl_validate_ops(const struct genl_family *family)\r\n{\r\nconst struct genl_ops *ops = family->ops;\r\nunsigned int n_ops = family->n_ops;\r\nint i, j;\r\nif (WARN_ON(n_ops && !ops))\r\nreturn -EINVAL;\r\nif (!n_ops)\r\nreturn 0;\r\nfor (i = 0; i < n_ops; i++) {\r\nif (ops[i].dumpit == NULL && ops[i].doit == NULL)\r\nreturn -EINVAL;\r\nfor (j = i + 1; j < n_ops; j++)\r\nif (ops[i].cmd == ops[j].cmd)\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nint __genl_register_family(struct genl_family *family)\r\n{\r\nint err = -EINVAL, i;\r\nif (family->id && family->id < GENL_MIN_ID)\r\ngoto errout;\r\nif (family->id > GENL_MAX_ID)\r\ngoto errout;\r\nerr = genl_validate_ops(family);\r\nif (err)\r\nreturn err;\r\ngenl_lock_all();\r\nif (genl_family_find_byname(family->name)) {\r\nerr = -EEXIST;\r\ngoto errout_locked;\r\n}\r\nif (family->id == GENL_ID_GENERATE) {\r\nu16 newid = genl_generate_id();\r\nif (!newid) {\r\nerr = -ENOMEM;\r\ngoto errout_locked;\r\n}\r\nfamily->id = newid;\r\n} else if (genl_family_find_byid(family->id)) {\r\nerr = -EEXIST;\r\ngoto errout_locked;\r\n}\r\nif (family->maxattr && !family->parallel_ops) {\r\nfamily->attrbuf = kmalloc((family->maxattr+1) *\r\nsizeof(struct nlattr *), GFP_KERNEL);\r\nif (family->attrbuf == NULL) {\r\nerr = -ENOMEM;\r\ngoto errout_locked;\r\n}\r\n} else\r\nfamily->attrbuf = NULL;\r\nerr = genl_validate_assign_mc_groups(family);\r\nif (err)\r\ngoto errout_locked;\r\nlist_add_tail(&family->family_list, genl_family_chain(family->id));\r\ngenl_unlock_all();\r\ngenl_ctrl_event(CTRL_CMD_NEWFAMILY, family, NULL, 0);\r\nfor (i = 0; i < family->n_mcgrps; i++)\r\ngenl_ctrl_event(CTRL_CMD_NEWMCAST_GRP, family,\r\n&family->mcgrps[i], family->mcgrp_offset + i);\r\nreturn 0;\r\nerrout_locked:\r\ngenl_unlock_all();\r\nerrout:\r\nreturn err;\r\n}\r\nint genl_unregister_family(struct genl_family *family)\r\n{\r\nstruct genl_family *rc;\r\ngenl_lock_all();\r\nlist_for_each_entry(rc, genl_family_chain(family->id), family_list) {\r\nif (family->id != rc->id || strcmp(rc->name, family->name))\r\ncontinue;\r\ngenl_unregister_mc_groups(family);\r\nlist_del(&rc->family_list);\r\nfamily->n_ops = 0;\r\nup_write(&cb_lock);\r\nwait_event(genl_sk_destructing_waitq,\r\natomic_read(&genl_sk_destructing_cnt) == 0);\r\ngenl_unlock();\r\nkfree(family->attrbuf);\r\ngenl_ctrl_event(CTRL_CMD_DELFAMILY, family, NULL, 0);\r\nreturn 0;\r\n}\r\ngenl_unlock_all();\r\nreturn -ENOENT;\r\n}\r\nvoid *genlmsg_put(struct sk_buff *skb, u32 portid, u32 seq,\r\nstruct genl_family *family, int flags, u8 cmd)\r\n{\r\nstruct nlmsghdr *nlh;\r\nstruct genlmsghdr *hdr;\r\nnlh = nlmsg_put(skb, portid, seq, family->id, GENL_HDRLEN +\r\nfamily->hdrsize, flags);\r\nif (nlh == NULL)\r\nreturn NULL;\r\nhdr = nlmsg_data(nlh);\r\nhdr->cmd = cmd;\r\nhdr->version = family->version;\r\nhdr->reserved = 0;\r\nreturn (char *) hdr + GENL_HDRLEN;\r\n}\r\nstatic int genl_lock_start(struct netlink_callback *cb)\r\n{\r\nconst struct genl_ops *ops = cb->data;\r\nint rc = 0;\r\nif (ops->start) {\r\ngenl_lock();\r\nrc = ops->start(cb);\r\ngenl_unlock();\r\n}\r\nreturn rc;\r\n}\r\nstatic int genl_lock_dumpit(struct sk_buff *skb, struct netlink_callback *cb)\r\n{\r\nconst struct genl_ops *ops = cb->data;\r\nint rc;\r\ngenl_lock();\r\nrc = ops->dumpit(skb, cb);\r\ngenl_unlock();\r\nreturn rc;\r\n}\r\nstatic int genl_lock_done(struct netlink_callback *cb)\r\n{\r\nconst struct genl_ops *ops = cb->data;\r\nint rc = 0;\r\nif (ops->done) {\r\ngenl_lock();\r\nrc = ops->done(cb);\r\ngenl_unlock();\r\n}\r\nreturn rc;\r\n}\r\nstatic int genl_family_rcv_msg(struct genl_family *family,\r\nstruct sk_buff *skb,\r\nstruct nlmsghdr *nlh)\r\n{\r\nconst struct genl_ops *ops;\r\nstruct net *net = sock_net(skb->sk);\r\nstruct genl_info info;\r\nstruct genlmsghdr *hdr = nlmsg_data(nlh);\r\nstruct nlattr **attrbuf;\r\nint hdrlen, err;\r\nif (!family->netnsok && !net_eq(net, &init_net))\r\nreturn -ENOENT;\r\nhdrlen = GENL_HDRLEN + family->hdrsize;\r\nif (nlh->nlmsg_len < nlmsg_msg_size(hdrlen))\r\nreturn -EINVAL;\r\nops = genl_get_cmd(hdr->cmd, family);\r\nif (ops == NULL)\r\nreturn -EOPNOTSUPP;\r\nif ((ops->flags & GENL_ADMIN_PERM) &&\r\n!netlink_capable(skb, CAP_NET_ADMIN))\r\nreturn -EPERM;\r\nif ((ops->flags & GENL_UNS_ADMIN_PERM) &&\r\n!netlink_ns_capable(skb, net->user_ns, CAP_NET_ADMIN))\r\nreturn -EPERM;\r\nif ((nlh->nlmsg_flags & NLM_F_DUMP) == NLM_F_DUMP) {\r\nint rc;\r\nif (ops->dumpit == NULL)\r\nreturn -EOPNOTSUPP;\r\nif (!family->parallel_ops) {\r\nstruct netlink_dump_control c = {\r\n.module = family->module,\r\n.data = (void *)ops,\r\n.start = genl_lock_start,\r\n.dump = genl_lock_dumpit,\r\n.done = genl_lock_done,\r\n};\r\ngenl_unlock();\r\nrc = __netlink_dump_start(net->genl_sock, skb, nlh, &c);\r\ngenl_lock();\r\n} else {\r\nstruct netlink_dump_control c = {\r\n.module = family->module,\r\n.start = ops->start,\r\n.dump = ops->dumpit,\r\n.done = ops->done,\r\n};\r\nrc = __netlink_dump_start(net->genl_sock, skb, nlh, &c);\r\n}\r\nreturn rc;\r\n}\r\nif (ops->doit == NULL)\r\nreturn -EOPNOTSUPP;\r\nif (family->maxattr && family->parallel_ops) {\r\nattrbuf = kmalloc((family->maxattr+1) *\r\nsizeof(struct nlattr *), GFP_KERNEL);\r\nif (attrbuf == NULL)\r\nreturn -ENOMEM;\r\n} else\r\nattrbuf = family->attrbuf;\r\nif (attrbuf) {\r\nerr = nlmsg_parse(nlh, hdrlen, attrbuf, family->maxattr,\r\nops->policy);\r\nif (err < 0)\r\ngoto out;\r\n}\r\ninfo.snd_seq = nlh->nlmsg_seq;\r\ninfo.snd_portid = NETLINK_CB(skb).portid;\r\ninfo.nlhdr = nlh;\r\ninfo.genlhdr = nlmsg_data(nlh);\r\ninfo.userhdr = nlmsg_data(nlh) + GENL_HDRLEN;\r\ninfo.attrs = attrbuf;\r\ngenl_info_net_set(&info, net);\r\nmemset(&info.user_ptr, 0, sizeof(info.user_ptr));\r\nif (family->pre_doit) {\r\nerr = family->pre_doit(ops, skb, &info);\r\nif (err)\r\ngoto out;\r\n}\r\nerr = ops->doit(skb, &info);\r\nif (family->post_doit)\r\nfamily->post_doit(ops, skb, &info);\r\nout:\r\nif (family->parallel_ops)\r\nkfree(attrbuf);\r\nreturn err;\r\n}\r\nstatic int genl_rcv_msg(struct sk_buff *skb, struct nlmsghdr *nlh)\r\n{\r\nstruct genl_family *family;\r\nint err;\r\nfamily = genl_family_find_byid(nlh->nlmsg_type);\r\nif (family == NULL)\r\nreturn -ENOENT;\r\nif (!family->parallel_ops)\r\ngenl_lock();\r\nerr = genl_family_rcv_msg(family, skb, nlh);\r\nif (!family->parallel_ops)\r\ngenl_unlock();\r\nreturn err;\r\n}\r\nstatic void genl_rcv(struct sk_buff *skb)\r\n{\r\ndown_read(&cb_lock);\r\nnetlink_rcv_skb(skb, &genl_rcv_msg);\r\nup_read(&cb_lock);\r\n}\r\nstatic int ctrl_fill_info(struct genl_family *family, u32 portid, u32 seq,\r\nu32 flags, struct sk_buff *skb, u8 cmd)\r\n{\r\nvoid *hdr;\r\nhdr = genlmsg_put(skb, portid, seq, &genl_ctrl, flags, cmd);\r\nif (hdr == NULL)\r\nreturn -1;\r\nif (nla_put_string(skb, CTRL_ATTR_FAMILY_NAME, family->name) ||\r\nnla_put_u16(skb, CTRL_ATTR_FAMILY_ID, family->id) ||\r\nnla_put_u32(skb, CTRL_ATTR_VERSION, family->version) ||\r\nnla_put_u32(skb, CTRL_ATTR_HDRSIZE, family->hdrsize) ||\r\nnla_put_u32(skb, CTRL_ATTR_MAXATTR, family->maxattr))\r\ngoto nla_put_failure;\r\nif (family->n_ops) {\r\nstruct nlattr *nla_ops;\r\nint i;\r\nnla_ops = nla_nest_start(skb, CTRL_ATTR_OPS);\r\nif (nla_ops == NULL)\r\ngoto nla_put_failure;\r\nfor (i = 0; i < family->n_ops; i++) {\r\nstruct nlattr *nest;\r\nconst struct genl_ops *ops = &family->ops[i];\r\nu32 op_flags = ops->flags;\r\nif (ops->dumpit)\r\nop_flags |= GENL_CMD_CAP_DUMP;\r\nif (ops->doit)\r\nop_flags |= GENL_CMD_CAP_DO;\r\nif (ops->policy)\r\nop_flags |= GENL_CMD_CAP_HASPOL;\r\nnest = nla_nest_start(skb, i + 1);\r\nif (nest == NULL)\r\ngoto nla_put_failure;\r\nif (nla_put_u32(skb, CTRL_ATTR_OP_ID, ops->cmd) ||\r\nnla_put_u32(skb, CTRL_ATTR_OP_FLAGS, op_flags))\r\ngoto nla_put_failure;\r\nnla_nest_end(skb, nest);\r\n}\r\nnla_nest_end(skb, nla_ops);\r\n}\r\nif (family->n_mcgrps) {\r\nstruct nlattr *nla_grps;\r\nint i;\r\nnla_grps = nla_nest_start(skb, CTRL_ATTR_MCAST_GROUPS);\r\nif (nla_grps == NULL)\r\ngoto nla_put_failure;\r\nfor (i = 0; i < family->n_mcgrps; i++) {\r\nstruct nlattr *nest;\r\nconst struct genl_multicast_group *grp;\r\ngrp = &family->mcgrps[i];\r\nnest = nla_nest_start(skb, i + 1);\r\nif (nest == NULL)\r\ngoto nla_put_failure;\r\nif (nla_put_u32(skb, CTRL_ATTR_MCAST_GRP_ID,\r\nfamily->mcgrp_offset + i) ||\r\nnla_put_string(skb, CTRL_ATTR_MCAST_GRP_NAME,\r\ngrp->name))\r\ngoto nla_put_failure;\r\nnla_nest_end(skb, nest);\r\n}\r\nnla_nest_end(skb, nla_grps);\r\n}\r\ngenlmsg_end(skb, hdr);\r\nreturn 0;\r\nnla_put_failure:\r\ngenlmsg_cancel(skb, hdr);\r\nreturn -EMSGSIZE;\r\n}\r\nstatic int ctrl_fill_mcgrp_info(struct genl_family *family,\r\nconst struct genl_multicast_group *grp,\r\nint grp_id, u32 portid, u32 seq, u32 flags,\r\nstruct sk_buff *skb, u8 cmd)\r\n{\r\nvoid *hdr;\r\nstruct nlattr *nla_grps;\r\nstruct nlattr *nest;\r\nhdr = genlmsg_put(skb, portid, seq, &genl_ctrl, flags, cmd);\r\nif (hdr == NULL)\r\nreturn -1;\r\nif (nla_put_string(skb, CTRL_ATTR_FAMILY_NAME, family->name) ||\r\nnla_put_u16(skb, CTRL_ATTR_FAMILY_ID, family->id))\r\ngoto nla_put_failure;\r\nnla_grps = nla_nest_start(skb, CTRL_ATTR_MCAST_GROUPS);\r\nif (nla_grps == NULL)\r\ngoto nla_put_failure;\r\nnest = nla_nest_start(skb, 1);\r\nif (nest == NULL)\r\ngoto nla_put_failure;\r\nif (nla_put_u32(skb, CTRL_ATTR_MCAST_GRP_ID, grp_id) ||\r\nnla_put_string(skb, CTRL_ATTR_MCAST_GRP_NAME,\r\ngrp->name))\r\ngoto nla_put_failure;\r\nnla_nest_end(skb, nest);\r\nnla_nest_end(skb, nla_grps);\r\ngenlmsg_end(skb, hdr);\r\nreturn 0;\r\nnla_put_failure:\r\ngenlmsg_cancel(skb, hdr);\r\nreturn -EMSGSIZE;\r\n}\r\nstatic int ctrl_dumpfamily(struct sk_buff *skb, struct netlink_callback *cb)\r\n{\r\nint i, n = 0;\r\nstruct genl_family *rt;\r\nstruct net *net = sock_net(skb->sk);\r\nint chains_to_skip = cb->args[0];\r\nint fams_to_skip = cb->args[1];\r\nfor (i = chains_to_skip; i < GENL_FAM_TAB_SIZE; i++) {\r\nn = 0;\r\nlist_for_each_entry(rt, genl_family_chain(i), family_list) {\r\nif (!rt->netnsok && !net_eq(net, &init_net))\r\ncontinue;\r\nif (++n < fams_to_skip)\r\ncontinue;\r\nif (ctrl_fill_info(rt, NETLINK_CB(cb->skb).portid,\r\ncb->nlh->nlmsg_seq, NLM_F_MULTI,\r\nskb, CTRL_CMD_NEWFAMILY) < 0)\r\ngoto errout;\r\n}\r\nfams_to_skip = 0;\r\n}\r\nerrout:\r\ncb->args[0] = i;\r\ncb->args[1] = n;\r\nreturn skb->len;\r\n}\r\nstatic struct sk_buff *ctrl_build_family_msg(struct genl_family *family,\r\nu32 portid, int seq, u8 cmd)\r\n{\r\nstruct sk_buff *skb;\r\nint err;\r\nskb = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);\r\nif (skb == NULL)\r\nreturn ERR_PTR(-ENOBUFS);\r\nerr = ctrl_fill_info(family, portid, seq, 0, skb, cmd);\r\nif (err < 0) {\r\nnlmsg_free(skb);\r\nreturn ERR_PTR(err);\r\n}\r\nreturn skb;\r\n}\r\nstatic struct sk_buff *\r\nctrl_build_mcgrp_msg(struct genl_family *family,\r\nconst struct genl_multicast_group *grp,\r\nint grp_id, u32 portid, int seq, u8 cmd)\r\n{\r\nstruct sk_buff *skb;\r\nint err;\r\nskb = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);\r\nif (skb == NULL)\r\nreturn ERR_PTR(-ENOBUFS);\r\nerr = ctrl_fill_mcgrp_info(family, grp, grp_id, portid,\r\nseq, 0, skb, cmd);\r\nif (err < 0) {\r\nnlmsg_free(skb);\r\nreturn ERR_PTR(err);\r\n}\r\nreturn skb;\r\n}\r\nstatic int ctrl_getfamily(struct sk_buff *skb, struct genl_info *info)\r\n{\r\nstruct sk_buff *msg;\r\nstruct genl_family *res = NULL;\r\nint err = -EINVAL;\r\nif (info->attrs[CTRL_ATTR_FAMILY_ID]) {\r\nu16 id = nla_get_u16(info->attrs[CTRL_ATTR_FAMILY_ID]);\r\nres = genl_family_find_byid(id);\r\nerr = -ENOENT;\r\n}\r\nif (info->attrs[CTRL_ATTR_FAMILY_NAME]) {\r\nchar *name;\r\nname = nla_data(info->attrs[CTRL_ATTR_FAMILY_NAME]);\r\nres = genl_family_find_byname(name);\r\n#ifdef CONFIG_MODULES\r\nif (res == NULL) {\r\ngenl_unlock();\r\nup_read(&cb_lock);\r\nrequest_module("net-pf-%d-proto-%d-family-%s",\r\nPF_NETLINK, NETLINK_GENERIC, name);\r\ndown_read(&cb_lock);\r\ngenl_lock();\r\nres = genl_family_find_byname(name);\r\n}\r\n#endif\r\nerr = -ENOENT;\r\n}\r\nif (res == NULL)\r\nreturn err;\r\nif (!res->netnsok && !net_eq(genl_info_net(info), &init_net)) {\r\nreturn -ENOENT;\r\n}\r\nmsg = ctrl_build_family_msg(res, info->snd_portid, info->snd_seq,\r\nCTRL_CMD_NEWFAMILY);\r\nif (IS_ERR(msg))\r\nreturn PTR_ERR(msg);\r\nreturn genlmsg_reply(msg, info);\r\n}\r\nstatic int genl_ctrl_event(int event, struct genl_family *family,\r\nconst struct genl_multicast_group *grp,\r\nint grp_id)\r\n{\r\nstruct sk_buff *msg;\r\nif (!init_net.genl_sock)\r\nreturn 0;\r\nswitch (event) {\r\ncase CTRL_CMD_NEWFAMILY:\r\ncase CTRL_CMD_DELFAMILY:\r\nWARN_ON(grp);\r\nmsg = ctrl_build_family_msg(family, 0, 0, event);\r\nbreak;\r\ncase CTRL_CMD_NEWMCAST_GRP:\r\ncase CTRL_CMD_DELMCAST_GRP:\r\nBUG_ON(!grp);\r\nmsg = ctrl_build_mcgrp_msg(family, grp, grp_id, 0, 0, event);\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nif (IS_ERR(msg))\r\nreturn PTR_ERR(msg);\r\nif (!family->netnsok) {\r\ngenlmsg_multicast_netns(&genl_ctrl, &init_net, msg, 0,\r\n0, GFP_KERNEL);\r\n} else {\r\nrcu_read_lock();\r\ngenlmsg_multicast_allns(&genl_ctrl, msg, 0,\r\n0, GFP_ATOMIC);\r\nrcu_read_unlock();\r\n}\r\nreturn 0;\r\n}\r\nstatic int genl_bind(struct net *net, int group)\r\n{\r\nint i, err = -ENOENT;\r\ndown_read(&cb_lock);\r\nfor (i = 0; i < GENL_FAM_TAB_SIZE; i++) {\r\nstruct genl_family *f;\r\nlist_for_each_entry(f, genl_family_chain(i), family_list) {\r\nif (group >= f->mcgrp_offset &&\r\ngroup < f->mcgrp_offset + f->n_mcgrps) {\r\nint fam_grp = group - f->mcgrp_offset;\r\nif (!f->netnsok && net != &init_net)\r\nerr = -ENOENT;\r\nelse if (f->mcast_bind)\r\nerr = f->mcast_bind(net, fam_grp);\r\nelse\r\nerr = 0;\r\nbreak;\r\n}\r\n}\r\n}\r\nup_read(&cb_lock);\r\nreturn err;\r\n}\r\nstatic void genl_unbind(struct net *net, int group)\r\n{\r\nint i;\r\ndown_read(&cb_lock);\r\nfor (i = 0; i < GENL_FAM_TAB_SIZE; i++) {\r\nstruct genl_family *f;\r\nlist_for_each_entry(f, genl_family_chain(i), family_list) {\r\nif (group >= f->mcgrp_offset &&\r\ngroup < f->mcgrp_offset + f->n_mcgrps) {\r\nint fam_grp = group - f->mcgrp_offset;\r\nif (f->mcast_unbind)\r\nf->mcast_unbind(net, fam_grp);\r\nbreak;\r\n}\r\n}\r\n}\r\nup_read(&cb_lock);\r\n}\r\nstatic int __net_init genl_pernet_init(struct net *net)\r\n{\r\nstruct netlink_kernel_cfg cfg = {\r\n.input = genl_rcv,\r\n.flags = NL_CFG_F_NONROOT_RECV,\r\n.bind = genl_bind,\r\n.unbind = genl_unbind,\r\n};\r\nnet->genl_sock = netlink_kernel_create(net, NETLINK_GENERIC, &cfg);\r\nif (!net->genl_sock && net_eq(net, &init_net))\r\npanic("GENL: Cannot initialize generic netlink\n");\r\nif (!net->genl_sock)\r\nreturn -ENOMEM;\r\nreturn 0;\r\n}\r\nstatic void __net_exit genl_pernet_exit(struct net *net)\r\n{\r\nnetlink_kernel_release(net->genl_sock);\r\nnet->genl_sock = NULL;\r\n}\r\nstatic int __init genl_init(void)\r\n{\r\nint i, err;\r\nfor (i = 0; i < GENL_FAM_TAB_SIZE; i++)\r\nINIT_LIST_HEAD(&family_ht[i]);\r\nerr = genl_register_family_with_ops_groups(&genl_ctrl, genl_ctrl_ops,\r\ngenl_ctrl_groups);\r\nif (err < 0)\r\ngoto problem;\r\nerr = register_pernet_subsys(&genl_pernet_ops);\r\nif (err)\r\ngoto problem;\r\nreturn 0;\r\nproblem:\r\npanic("GENL: Cannot register controller: %d\n", err);\r\n}\r\nstatic int genlmsg_mcast(struct sk_buff *skb, u32 portid, unsigned long group,\r\ngfp_t flags)\r\n{\r\nstruct sk_buff *tmp;\r\nstruct net *net, *prev = NULL;\r\nint err;\r\nfor_each_net_rcu(net) {\r\nif (prev) {\r\ntmp = skb_clone(skb, flags);\r\nif (!tmp) {\r\nerr = -ENOMEM;\r\ngoto error;\r\n}\r\nerr = nlmsg_multicast(prev->genl_sock, tmp,\r\nportid, group, flags);\r\nif (err)\r\ngoto error;\r\n}\r\nprev = net;\r\n}\r\nreturn nlmsg_multicast(prev->genl_sock, skb, portid, group, flags);\r\nerror:\r\nkfree_skb(skb);\r\nreturn err;\r\n}\r\nint genlmsg_multicast_allns(struct genl_family *family, struct sk_buff *skb,\r\nu32 portid, unsigned int group, gfp_t flags)\r\n{\r\nif (WARN_ON_ONCE(group >= family->n_mcgrps))\r\nreturn -EINVAL;\r\ngroup = family->mcgrp_offset + group;\r\nreturn genlmsg_mcast(skb, portid, group, flags);\r\n}\r\nvoid genl_notify(struct genl_family *family, struct sk_buff *skb,\r\nstruct genl_info *info, u32 group, gfp_t flags)\r\n{\r\nstruct net *net = genl_info_net(info);\r\nstruct sock *sk = net->genl_sock;\r\nint report = 0;\r\nif (info->nlhdr)\r\nreport = nlmsg_report(info->nlhdr);\r\nif (WARN_ON_ONCE(group >= family->n_mcgrps))\r\nreturn;\r\ngroup = family->mcgrp_offset + group;\r\nnlmsg_notify(sk, skb, info->snd_portid, group, report, flags);\r\n}
