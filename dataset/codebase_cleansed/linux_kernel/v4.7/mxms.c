static u8 *\r\nmxms_data(struct nvkm_mxm *mxm)\r\n{\r\nreturn mxm->mxms;\r\n}\r\nu16\r\nmxms_version(struct nvkm_mxm *mxm)\r\n{\r\nu8 *mxms = mxms_data(mxm);\r\nu16 version = (mxms[4] << 8) | mxms[5];\r\nswitch (version ) {\r\ncase 0x0200:\r\ncase 0x0201:\r\ncase 0x0300:\r\nreturn version;\r\ndefault:\r\nbreak;\r\n}\r\nnvkm_debug(&mxm->subdev, "unknown version %d.%d\n", mxms[4], mxms[5]);\r\nreturn 0x0000;\r\n}\r\nu16\r\nmxms_headerlen(struct nvkm_mxm *mxm)\r\n{\r\nreturn 8;\r\n}\r\nu16\r\nmxms_structlen(struct nvkm_mxm *mxm)\r\n{\r\nreturn *(u16 *)&mxms_data(mxm)[6];\r\n}\r\nbool\r\nmxms_checksum(struct nvkm_mxm *mxm)\r\n{\r\nu16 size = mxms_headerlen(mxm) + mxms_structlen(mxm);\r\nu8 *mxms = mxms_data(mxm), sum = 0;\r\nwhile (size--)\r\nsum += *mxms++;\r\nif (sum) {\r\nnvkm_debug(&mxm->subdev, "checksum invalid\n");\r\nreturn false;\r\n}\r\nreturn true;\r\n}\r\nbool\r\nmxms_valid(struct nvkm_mxm *mxm)\r\n{\r\nu8 *mxms = mxms_data(mxm);\r\nif (*(u32 *)mxms != 0x5f4d584d) {\r\nnvkm_debug(&mxm->subdev, "signature invalid\n");\r\nreturn false;\r\n}\r\nif (!mxms_version(mxm) || !mxms_checksum(mxm))\r\nreturn false;\r\nreturn true;\r\n}\r\nbool\r\nmxms_foreach(struct nvkm_mxm *mxm, u8 types,\r\nbool (*exec)(struct nvkm_mxm *, u8 *, void *), void *info)\r\n{\r\nstruct nvkm_subdev *subdev = &mxm->subdev;\r\nu8 *mxms = mxms_data(mxm);\r\nu8 *desc = mxms + mxms_headerlen(mxm);\r\nu8 *fini = desc + mxms_structlen(mxm) - 1;\r\nwhile (desc < fini) {\r\nu8 type = desc[0] & 0x0f;\r\nu8 headerlen = 0;\r\nu8 recordlen = 0;\r\nu8 entries = 0;\r\nswitch (type) {\r\ncase 0:\r\nif (mxms_version(mxm) >= 0x0300)\r\nheaderlen = 8;\r\nelse\r\nheaderlen = 6;\r\nbreak;\r\ncase 1:\r\ncase 2:\r\ncase 3:\r\nheaderlen = 4;\r\nbreak;\r\ncase 4:\r\nheaderlen = 4;\r\nrecordlen = 2;\r\nentries = (ROM32(desc[0]) & 0x01f00000) >> 20;\r\nbreak;\r\ncase 5:\r\nheaderlen = 8;\r\nbreak;\r\ncase 6:\r\nif (mxms_version(mxm) >= 0x0300) {\r\nheaderlen = 4;\r\nrecordlen = 8;\r\nentries = (desc[1] & 0xf0) >> 4;\r\n} else {\r\nheaderlen = 8;\r\n}\r\nbreak;\r\ncase 7:\r\nheaderlen = 8;\r\nrecordlen = 4;\r\nentries = desc[1] & 0x07;\r\nbreak;\r\ndefault:\r\nnvkm_debug(subdev, "unknown descriptor type %d\n", type);\r\nreturn false;\r\n}\r\nif (mxm->subdev.debug >= NV_DBG_DEBUG && (exec == NULL)) {\r\nstatic const char * mxms_desc[] = {\r\n"ODS", "SCCS", "TS", "IPS",\r\n"GSD", "VSS", "BCS", "FCS",\r\n};\r\nu8 *dump = desc;\r\nchar data[32], *ptr;\r\nint i, j;\r\nfor (j = headerlen - 1, ptr = data; j >= 0; j--)\r\nptr += sprintf(ptr, "%02x", dump[j]);\r\ndump += headerlen;\r\nnvkm_debug(subdev, "%4s: %s\n", mxms_desc[type], data);\r\nfor (i = 0; i < entries; i++, dump += recordlen) {\r\nfor (j = recordlen - 1, ptr = data; j >= 0; j--)\r\nptr += sprintf(ptr, "%02x", dump[j]);\r\nnvkm_debug(subdev, " %s\n", data);\r\n}\r\n}\r\nif (types & (1 << type)) {\r\nif (!exec(mxm, desc, info))\r\nreturn false;\r\n}\r\ndesc += headerlen + (entries * recordlen);\r\n}\r\nreturn true;\r\n}\r\nvoid\r\nmxms_output_device(struct nvkm_mxm *mxm, u8 *pdata, struct mxms_odev *desc)\r\n{\r\nu64 data = ROM32(pdata[0]);\r\nif (mxms_version(mxm) >= 0x0300)\r\ndata |= (u64)ROM16(pdata[4]) << 32;\r\ndesc->outp_type = (data & 0x00000000000000f0ULL) >> 4;\r\ndesc->ddc_port = (data & 0x0000000000000f00ULL) >> 8;\r\ndesc->conn_type = (data & 0x000000000001f000ULL) >> 12;\r\ndesc->dig_conn = (data & 0x0000000000780000ULL) >> 19;\r\n}
