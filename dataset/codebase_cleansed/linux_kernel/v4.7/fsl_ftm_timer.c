static inline u32 ftm_readl(void __iomem *addr)\r\n{\r\nif (priv->big_endian)\r\nreturn ioread32be(addr);\r\nelse\r\nreturn ioread32(addr);\r\n}\r\nstatic inline void ftm_writel(u32 val, void __iomem *addr)\r\n{\r\nif (priv->big_endian)\r\niowrite32be(val, addr);\r\nelse\r\niowrite32(val, addr);\r\n}\r\nstatic inline void ftm_counter_enable(void __iomem *base)\r\n{\r\nu32 val;\r\nval = ftm_readl(base + FTM_SC);\r\nval &= ~(FTM_SC_PS_MASK | FTM_SC_CLK_MASK);\r\nval |= priv->ps | FTM_SC_CLK(1);\r\nftm_writel(val, base + FTM_SC);\r\n}\r\nstatic inline void ftm_counter_disable(void __iomem *base)\r\n{\r\nu32 val;\r\nval = ftm_readl(base + FTM_SC);\r\nval &= ~(FTM_SC_PS_MASK | FTM_SC_CLK_MASK);\r\nftm_writel(val, base + FTM_SC);\r\n}\r\nstatic inline void ftm_irq_acknowledge(void __iomem *base)\r\n{\r\nu32 val;\r\nval = ftm_readl(base + FTM_SC);\r\nval &= ~FTM_SC_TOF;\r\nftm_writel(val, base + FTM_SC);\r\n}\r\nstatic inline void ftm_irq_enable(void __iomem *base)\r\n{\r\nu32 val;\r\nval = ftm_readl(base + FTM_SC);\r\nval |= FTM_SC_TOIE;\r\nftm_writel(val, base + FTM_SC);\r\n}\r\nstatic inline void ftm_irq_disable(void __iomem *base)\r\n{\r\nu32 val;\r\nval = ftm_readl(base + FTM_SC);\r\nval &= ~FTM_SC_TOIE;\r\nftm_writel(val, base + FTM_SC);\r\n}\r\nstatic inline void ftm_reset_counter(void __iomem *base)\r\n{\r\nftm_writel(0x00, base + FTM_CNT);\r\n}\r\nstatic u64 notrace ftm_read_sched_clock(void)\r\n{\r\nreturn ftm_readl(priv->clksrc_base + FTM_CNT);\r\n}\r\nstatic int ftm_set_next_event(unsigned long delta,\r\nstruct clock_event_device *unused)\r\n{\r\nftm_counter_disable(priv->clkevt_base);\r\nftm_reset_counter(priv->clkevt_base);\r\nftm_writel(delta - 1, priv->clkevt_base + FTM_MOD);\r\nftm_counter_enable(priv->clkevt_base);\r\nftm_irq_enable(priv->clkevt_base);\r\nreturn 0;\r\n}\r\nstatic int ftm_set_oneshot(struct clock_event_device *evt)\r\n{\r\nftm_counter_disable(priv->clkevt_base);\r\nreturn 0;\r\n}\r\nstatic int ftm_set_periodic(struct clock_event_device *evt)\r\n{\r\nftm_set_next_event(priv->periodic_cyc, evt);\r\nreturn 0;\r\n}\r\nstatic irqreturn_t ftm_evt_interrupt(int irq, void *dev_id)\r\n{\r\nstruct clock_event_device *evt = dev_id;\r\nftm_irq_acknowledge(priv->clkevt_base);\r\nif (likely(clockevent_state_oneshot(evt))) {\r\nftm_irq_disable(priv->clkevt_base);\r\nftm_counter_disable(priv->clkevt_base);\r\n}\r\nevt->event_handler(evt);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int __init ftm_clockevent_init(unsigned long freq, int irq)\r\n{\r\nint err;\r\nftm_writel(0x00, priv->clkevt_base + FTM_CNTIN);\r\nftm_writel(~0u, priv->clkevt_base + FTM_MOD);\r\nftm_reset_counter(priv->clkevt_base);\r\nerr = setup_irq(irq, &ftm_timer_irq);\r\nif (err) {\r\npr_err("ftm: setup irq failed: %d\n", err);\r\nreturn err;\r\n}\r\nftm_clockevent.cpumask = cpumask_of(0);\r\nftm_clockevent.irq = irq;\r\nclockevents_config_and_register(&ftm_clockevent,\r\nfreq / (1 << priv->ps),\r\n1, 0xffff);\r\nftm_counter_enable(priv->clkevt_base);\r\nreturn 0;\r\n}\r\nstatic int __init ftm_clocksource_init(unsigned long freq)\r\n{\r\nint err;\r\nftm_writel(0x00, priv->clksrc_base + FTM_CNTIN);\r\nftm_writel(~0u, priv->clksrc_base + FTM_MOD);\r\nftm_reset_counter(priv->clksrc_base);\r\nsched_clock_register(ftm_read_sched_clock, 16, freq / (1 << priv->ps));\r\nerr = clocksource_mmio_init(priv->clksrc_base + FTM_CNT, "fsl-ftm",\r\nfreq / (1 << priv->ps), 300, 16,\r\nclocksource_mmio_readl_up);\r\nif (err) {\r\npr_err("ftm: init clock source mmio failed: %d\n", err);\r\nreturn err;\r\n}\r\nftm_counter_enable(priv->clksrc_base);\r\nreturn 0;\r\n}\r\nstatic int __init __ftm_clk_init(struct device_node *np, char *cnt_name,\r\nchar *ftm_name)\r\n{\r\nstruct clk *clk;\r\nint err;\r\nclk = of_clk_get_by_name(np, cnt_name);\r\nif (IS_ERR(clk)) {\r\npr_err("ftm: Cannot get \"%s\": %ld\n", cnt_name, PTR_ERR(clk));\r\nreturn PTR_ERR(clk);\r\n}\r\nerr = clk_prepare_enable(clk);\r\nif (err) {\r\npr_err("ftm: clock failed to prepare+enable \"%s\": %d\n",\r\ncnt_name, err);\r\nreturn err;\r\n}\r\nclk = of_clk_get_by_name(np, ftm_name);\r\nif (IS_ERR(clk)) {\r\npr_err("ftm: Cannot get \"%s\": %ld\n", ftm_name, PTR_ERR(clk));\r\nreturn PTR_ERR(clk);\r\n}\r\nerr = clk_prepare_enable(clk);\r\nif (err)\r\npr_err("ftm: clock failed to prepare+enable \"%s\": %d\n",\r\nftm_name, err);\r\nreturn clk_get_rate(clk);\r\n}\r\nstatic unsigned long __init ftm_clk_init(struct device_node *np)\r\n{\r\nunsigned long freq;\r\nfreq = __ftm_clk_init(np, "ftm-evt-counter-en", "ftm-evt");\r\nif (freq <= 0)\r\nreturn 0;\r\nfreq = __ftm_clk_init(np, "ftm-src-counter-en", "ftm-src");\r\nif (freq <= 0)\r\nreturn 0;\r\nreturn freq;\r\n}\r\nstatic int __init ftm_calc_closest_round_cyc(unsigned long freq)\r\n{\r\npriv->ps = 0;\r\ndo {\r\npriv->periodic_cyc = DIV_ROUND_CLOSEST(freq,\r\nHZ * (1 << priv->ps++));\r\n} while (priv->periodic_cyc > 0xFFFF);\r\nif (priv->ps > FTM_PS_MAX) {\r\npr_err("ftm: the prescaler is %lu > %d\n",\r\npriv->ps, FTM_PS_MAX);\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic void __init ftm_timer_init(struct device_node *np)\r\n{\r\nunsigned long freq;\r\nint irq;\r\npriv = kzalloc(sizeof(*priv), GFP_KERNEL);\r\nif (!priv)\r\nreturn;\r\npriv->clkevt_base = of_iomap(np, 0);\r\nif (!priv->clkevt_base) {\r\npr_err("ftm: unable to map event timer registers\n");\r\ngoto err;\r\n}\r\npriv->clksrc_base = of_iomap(np, 1);\r\nif (!priv->clksrc_base) {\r\npr_err("ftm: unable to map source timer registers\n");\r\ngoto err;\r\n}\r\nirq = irq_of_parse_and_map(np, 0);\r\nif (irq <= 0) {\r\npr_err("ftm: unable to get IRQ from DT, %d\n", irq);\r\ngoto err;\r\n}\r\npriv->big_endian = of_property_read_bool(np, "big-endian");\r\nfreq = ftm_clk_init(np);\r\nif (!freq)\r\ngoto err;\r\nif (ftm_calc_closest_round_cyc(freq))\r\ngoto err;\r\nif (ftm_clocksource_init(freq))\r\ngoto err;\r\nif (ftm_clockevent_init(freq, irq))\r\ngoto err;\r\nreturn;\r\nerr:\r\nkfree(priv);\r\n}
