static bool snd_soc_dai_stream_valid(struct snd_soc_dai *dai, int stream)\r\n{\r\nstruct snd_soc_pcm_stream *codec_stream;\r\nif (stream == SNDRV_PCM_STREAM_PLAYBACK)\r\ncodec_stream = &dai->driver->playback;\r\nelse\r\ncodec_stream = &dai->driver->capture;\r\nreturn codec_stream->rates;\r\n}\r\nvoid snd_soc_runtime_activate(struct snd_soc_pcm_runtime *rtd, int stream)\r\n{\r\nstruct snd_soc_dai *cpu_dai = rtd->cpu_dai;\r\nint i;\r\nlockdep_assert_held(&rtd->pcm_mutex);\r\nif (stream == SNDRV_PCM_STREAM_PLAYBACK) {\r\ncpu_dai->playback_active++;\r\nfor (i = 0; i < rtd->num_codecs; i++)\r\nrtd->codec_dais[i]->playback_active++;\r\n} else {\r\ncpu_dai->capture_active++;\r\nfor (i = 0; i < rtd->num_codecs; i++)\r\nrtd->codec_dais[i]->capture_active++;\r\n}\r\ncpu_dai->active++;\r\ncpu_dai->component->active++;\r\nfor (i = 0; i < rtd->num_codecs; i++) {\r\nrtd->codec_dais[i]->active++;\r\nrtd->codec_dais[i]->component->active++;\r\n}\r\n}\r\nvoid snd_soc_runtime_deactivate(struct snd_soc_pcm_runtime *rtd, int stream)\r\n{\r\nstruct snd_soc_dai *cpu_dai = rtd->cpu_dai;\r\nint i;\r\nlockdep_assert_held(&rtd->pcm_mutex);\r\nif (stream == SNDRV_PCM_STREAM_PLAYBACK) {\r\ncpu_dai->playback_active--;\r\nfor (i = 0; i < rtd->num_codecs; i++)\r\nrtd->codec_dais[i]->playback_active--;\r\n} else {\r\ncpu_dai->capture_active--;\r\nfor (i = 0; i < rtd->num_codecs; i++)\r\nrtd->codec_dais[i]->capture_active--;\r\n}\r\ncpu_dai->active--;\r\ncpu_dai->component->active--;\r\nfor (i = 0; i < rtd->num_codecs; i++) {\r\nrtd->codec_dais[i]->component->active--;\r\nrtd->codec_dais[i]->active--;\r\n}\r\n}\r\nbool snd_soc_runtime_ignore_pmdown_time(struct snd_soc_pcm_runtime *rtd)\r\n{\r\nint i;\r\nbool ignore = true;\r\nif (!rtd->pmdown_time || rtd->dai_link->ignore_pmdown_time)\r\nreturn true;\r\nfor (i = 0; i < rtd->num_codecs; i++)\r\nignore &= rtd->codec_dais[i]->component->ignore_pmdown_time;\r\nreturn rtd->cpu_dai->component->ignore_pmdown_time && ignore;\r\n}\r\nint snd_soc_set_runtime_hwparams(struct snd_pcm_substream *substream,\r\nconst struct snd_pcm_hardware *hw)\r\n{\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nruntime->hw.info = hw->info;\r\nruntime->hw.formats = hw->formats;\r\nruntime->hw.period_bytes_min = hw->period_bytes_min;\r\nruntime->hw.period_bytes_max = hw->period_bytes_max;\r\nruntime->hw.periods_min = hw->periods_min;\r\nruntime->hw.periods_max = hw->periods_max;\r\nruntime->hw.buffer_bytes_max = hw->buffer_bytes_max;\r\nruntime->hw.fifo_size = hw->fifo_size;\r\nreturn 0;\r\n}\r\nint dpcm_dapm_stream_event(struct snd_soc_pcm_runtime *fe, int dir,\r\nint event)\r\n{\r\nstruct snd_soc_dpcm *dpcm;\r\nlist_for_each_entry(dpcm, &fe->dpcm[dir].be_clients, list_be) {\r\nstruct snd_soc_pcm_runtime *be = dpcm->be;\r\ndev_dbg(be->dev, "ASoC: BE %s event %d dir %d\n",\r\nbe->dai_link->name, event, dir);\r\nsnd_soc_dapm_stream_event(be, dir, event);\r\n}\r\nsnd_soc_dapm_stream_event(fe, dir, event);\r\nreturn 0;\r\n}\r\nstatic int soc_pcm_apply_symmetry(struct snd_pcm_substream *substream,\r\nstruct snd_soc_dai *soc_dai)\r\n{\r\nstruct snd_soc_pcm_runtime *rtd = substream->private_data;\r\nint ret;\r\nif (soc_dai->rate && (soc_dai->driver->symmetric_rates ||\r\nrtd->dai_link->symmetric_rates)) {\r\ndev_dbg(soc_dai->dev, "ASoC: Symmetry forces %dHz rate\n",\r\nsoc_dai->rate);\r\nret = snd_pcm_hw_constraint_single(substream->runtime,\r\nSNDRV_PCM_HW_PARAM_RATE,\r\nsoc_dai->rate);\r\nif (ret < 0) {\r\ndev_err(soc_dai->dev,\r\n"ASoC: Unable to apply rate constraint: %d\n",\r\nret);\r\nreturn ret;\r\n}\r\n}\r\nif (soc_dai->channels && (soc_dai->driver->symmetric_channels ||\r\nrtd->dai_link->symmetric_channels)) {\r\ndev_dbg(soc_dai->dev, "ASoC: Symmetry forces %d channel(s)\n",\r\nsoc_dai->channels);\r\nret = snd_pcm_hw_constraint_single(substream->runtime,\r\nSNDRV_PCM_HW_PARAM_CHANNELS,\r\nsoc_dai->channels);\r\nif (ret < 0) {\r\ndev_err(soc_dai->dev,\r\n"ASoC: Unable to apply channel symmetry constraint: %d\n",\r\nret);\r\nreturn ret;\r\n}\r\n}\r\nif (soc_dai->sample_bits && (soc_dai->driver->symmetric_samplebits ||\r\nrtd->dai_link->symmetric_samplebits)) {\r\ndev_dbg(soc_dai->dev, "ASoC: Symmetry forces %d sample bits\n",\r\nsoc_dai->sample_bits);\r\nret = snd_pcm_hw_constraint_single(substream->runtime,\r\nSNDRV_PCM_HW_PARAM_SAMPLE_BITS,\r\nsoc_dai->sample_bits);\r\nif (ret < 0) {\r\ndev_err(soc_dai->dev,\r\n"ASoC: Unable to apply sample bits symmetry constraint: %d\n",\r\nret);\r\nreturn ret;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int soc_pcm_params_symmetry(struct snd_pcm_substream *substream,\r\nstruct snd_pcm_hw_params *params)\r\n{\r\nstruct snd_soc_pcm_runtime *rtd = substream->private_data;\r\nstruct snd_soc_dai *cpu_dai = rtd->cpu_dai;\r\nunsigned int rate, channels, sample_bits, symmetry, i;\r\nrate = params_rate(params);\r\nchannels = params_channels(params);\r\nsample_bits = snd_pcm_format_physical_width(params_format(params));\r\nsymmetry = cpu_dai->driver->symmetric_rates ||\r\nrtd->dai_link->symmetric_rates;\r\nfor (i = 0; i < rtd->num_codecs; i++)\r\nsymmetry |= rtd->codec_dais[i]->driver->symmetric_rates;\r\nif (symmetry && cpu_dai->rate && cpu_dai->rate != rate) {\r\ndev_err(rtd->dev, "ASoC: unmatched rate symmetry: %d - %d\n",\r\ncpu_dai->rate, rate);\r\nreturn -EINVAL;\r\n}\r\nsymmetry = cpu_dai->driver->symmetric_channels ||\r\nrtd->dai_link->symmetric_channels;\r\nfor (i = 0; i < rtd->num_codecs; i++)\r\nsymmetry |= rtd->codec_dais[i]->driver->symmetric_channels;\r\nif (symmetry && cpu_dai->channels && cpu_dai->channels != channels) {\r\ndev_err(rtd->dev, "ASoC: unmatched channel symmetry: %d - %d\n",\r\ncpu_dai->channels, channels);\r\nreturn -EINVAL;\r\n}\r\nsymmetry = cpu_dai->driver->symmetric_samplebits ||\r\nrtd->dai_link->symmetric_samplebits;\r\nfor (i = 0; i < rtd->num_codecs; i++)\r\nsymmetry |= rtd->codec_dais[i]->driver->symmetric_samplebits;\r\nif (symmetry && cpu_dai->sample_bits && cpu_dai->sample_bits != sample_bits) {\r\ndev_err(rtd->dev, "ASoC: unmatched sample bits symmetry: %d - %d\n",\r\ncpu_dai->sample_bits, sample_bits);\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic bool soc_pcm_has_symmetry(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_soc_pcm_runtime *rtd = substream->private_data;\r\nstruct snd_soc_dai_driver *cpu_driver = rtd->cpu_dai->driver;\r\nstruct snd_soc_dai_link *link = rtd->dai_link;\r\nunsigned int symmetry, i;\r\nsymmetry = cpu_driver->symmetric_rates || link->symmetric_rates ||\r\ncpu_driver->symmetric_channels || link->symmetric_channels ||\r\ncpu_driver->symmetric_samplebits || link->symmetric_samplebits;\r\nfor (i = 0; i < rtd->num_codecs; i++)\r\nsymmetry = symmetry ||\r\nrtd->codec_dais[i]->driver->symmetric_rates ||\r\nrtd->codec_dais[i]->driver->symmetric_channels ||\r\nrtd->codec_dais[i]->driver->symmetric_samplebits;\r\nreturn symmetry;\r\n}\r\nstatic void soc_pcm_set_msb(struct snd_pcm_substream *substream, int bits)\r\n{\r\nstruct snd_soc_pcm_runtime *rtd = substream->private_data;\r\nint ret;\r\nif (!bits)\r\nreturn;\r\nret = snd_pcm_hw_constraint_msbits(substream->runtime, 0, 0, bits);\r\nif (ret != 0)\r\ndev_warn(rtd->dev, "ASoC: Failed to set MSB %d: %d\n",\r\nbits, ret);\r\n}\r\nstatic void soc_pcm_apply_msb(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_soc_pcm_runtime *rtd = substream->private_data;\r\nstruct snd_soc_dai *cpu_dai = rtd->cpu_dai;\r\nstruct snd_soc_dai *codec_dai;\r\nint i;\r\nunsigned int bits = 0, cpu_bits;\r\nif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {\r\nfor (i = 0; i < rtd->num_codecs; i++) {\r\ncodec_dai = rtd->codec_dais[i];\r\nif (codec_dai->driver->playback.sig_bits == 0) {\r\nbits = 0;\r\nbreak;\r\n}\r\nbits = max(codec_dai->driver->playback.sig_bits, bits);\r\n}\r\ncpu_bits = cpu_dai->driver->playback.sig_bits;\r\n} else {\r\nfor (i = 0; i < rtd->num_codecs; i++) {\r\ncodec_dai = rtd->codec_dais[i];\r\nif (codec_dai->driver->capture.sig_bits == 0) {\r\nbits = 0;\r\nbreak;\r\n}\r\nbits = max(codec_dai->driver->capture.sig_bits, bits);\r\n}\r\ncpu_bits = cpu_dai->driver->capture.sig_bits;\r\n}\r\nsoc_pcm_set_msb(substream, bits);\r\nsoc_pcm_set_msb(substream, cpu_bits);\r\n}\r\nstatic void soc_pcm_init_runtime_hw(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nstruct snd_pcm_hardware *hw = &runtime->hw;\r\nstruct snd_soc_pcm_runtime *rtd = substream->private_data;\r\nstruct snd_soc_dai_driver *cpu_dai_drv = rtd->cpu_dai->driver;\r\nstruct snd_soc_dai_driver *codec_dai_drv;\r\nstruct snd_soc_pcm_stream *codec_stream;\r\nstruct snd_soc_pcm_stream *cpu_stream;\r\nunsigned int chan_min = 0, chan_max = UINT_MAX;\r\nunsigned int rate_min = 0, rate_max = UINT_MAX;\r\nunsigned int rates = UINT_MAX;\r\nu64 formats = ULLONG_MAX;\r\nint i;\r\nif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)\r\ncpu_stream = &cpu_dai_drv->playback;\r\nelse\r\ncpu_stream = &cpu_dai_drv->capture;\r\nfor (i = 0; i < rtd->num_codecs; i++) {\r\nif (!snd_soc_dai_stream_valid(rtd->codec_dais[i],\r\nsubstream->stream))\r\ncontinue;\r\ncodec_dai_drv = rtd->codec_dais[i]->driver;\r\nif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)\r\ncodec_stream = &codec_dai_drv->playback;\r\nelse\r\ncodec_stream = &codec_dai_drv->capture;\r\nchan_min = max(chan_min, codec_stream->channels_min);\r\nchan_max = min(chan_max, codec_stream->channels_max);\r\nrate_min = max(rate_min, codec_stream->rate_min);\r\nrate_max = min_not_zero(rate_max, codec_stream->rate_max);\r\nformats &= codec_stream->formats;\r\nrates = snd_pcm_rate_mask_intersect(codec_stream->rates, rates);\r\n}\r\nif (rtd->num_codecs > 1) {\r\nchan_min = cpu_stream->channels_min;\r\nchan_max = cpu_stream->channels_max;\r\n}\r\nhw->channels_min = max(chan_min, cpu_stream->channels_min);\r\nhw->channels_max = min(chan_max, cpu_stream->channels_max);\r\nif (hw->formats)\r\nhw->formats &= formats & cpu_stream->formats;\r\nelse\r\nhw->formats = formats & cpu_stream->formats;\r\nhw->rates = snd_pcm_rate_mask_intersect(rates, cpu_stream->rates);\r\nsnd_pcm_limit_hw_rates(runtime);\r\nhw->rate_min = max(hw->rate_min, cpu_stream->rate_min);\r\nhw->rate_min = max(hw->rate_min, rate_min);\r\nhw->rate_max = min_not_zero(hw->rate_max, cpu_stream->rate_max);\r\nhw->rate_max = min_not_zero(hw->rate_max, rate_max);\r\n}\r\nstatic int soc_pcm_open(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_soc_pcm_runtime *rtd = substream->private_data;\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nstruct snd_soc_platform *platform = rtd->platform;\r\nstruct snd_soc_dai *cpu_dai = rtd->cpu_dai;\r\nstruct snd_soc_dai *codec_dai;\r\nconst char *codec_dai_name = "multicodec";\r\nint i, ret = 0;\r\npinctrl_pm_select_default_state(cpu_dai->dev);\r\nfor (i = 0; i < rtd->num_codecs; i++)\r\npinctrl_pm_select_default_state(rtd->codec_dais[i]->dev);\r\npm_runtime_get_sync(cpu_dai->dev);\r\nfor (i = 0; i < rtd->num_codecs; i++)\r\npm_runtime_get_sync(rtd->codec_dais[i]->dev);\r\npm_runtime_get_sync(platform->dev);\r\nmutex_lock_nested(&rtd->pcm_mutex, rtd->pcm_subclass);\r\nif (cpu_dai->driver->ops && cpu_dai->driver->ops->startup) {\r\nret = cpu_dai->driver->ops->startup(substream, cpu_dai);\r\nif (ret < 0) {\r\ndev_err(cpu_dai->dev, "ASoC: can't open interface"\r\n" %s: %d\n", cpu_dai->name, ret);\r\ngoto out;\r\n}\r\n}\r\nif (platform->driver->ops && platform->driver->ops->open) {\r\nret = platform->driver->ops->open(substream);\r\nif (ret < 0) {\r\ndev_err(platform->dev, "ASoC: can't open platform"\r\n" %s: %d\n", platform->component.name, ret);\r\ngoto platform_err;\r\n}\r\n}\r\nfor (i = 0; i < rtd->num_codecs; i++) {\r\ncodec_dai = rtd->codec_dais[i];\r\nif (codec_dai->driver->ops && codec_dai->driver->ops->startup) {\r\nret = codec_dai->driver->ops->startup(substream,\r\ncodec_dai);\r\nif (ret < 0) {\r\ndev_err(codec_dai->dev,\r\n"ASoC: can't open codec %s: %d\n",\r\ncodec_dai->name, ret);\r\ngoto codec_dai_err;\r\n}\r\n}\r\nif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)\r\ncodec_dai->tx_mask = 0;\r\nelse\r\ncodec_dai->rx_mask = 0;\r\n}\r\nif (rtd->dai_link->ops && rtd->dai_link->ops->startup) {\r\nret = rtd->dai_link->ops->startup(substream);\r\nif (ret < 0) {\r\npr_err("ASoC: %s startup failed: %d\n",\r\nrtd->dai_link->name, ret);\r\ngoto machine_err;\r\n}\r\n}\r\nif (rtd->dai_link->dynamic || rtd->dai_link->no_pcm)\r\ngoto dynamic;\r\nsoc_pcm_init_runtime_hw(substream);\r\nif (rtd->num_codecs == 1)\r\ncodec_dai_name = rtd->codec_dai->name;\r\nif (soc_pcm_has_symmetry(substream))\r\nruntime->hw.info |= SNDRV_PCM_INFO_JOINT_DUPLEX;\r\nret = -EINVAL;\r\nif (!runtime->hw.rates) {\r\nprintk(KERN_ERR "ASoC: %s <-> %s No matching rates\n",\r\ncodec_dai_name, cpu_dai->name);\r\ngoto config_err;\r\n}\r\nif (!runtime->hw.formats) {\r\nprintk(KERN_ERR "ASoC: %s <-> %s No matching formats\n",\r\ncodec_dai_name, cpu_dai->name);\r\ngoto config_err;\r\n}\r\nif (!runtime->hw.channels_min || !runtime->hw.channels_max ||\r\nruntime->hw.channels_min > runtime->hw.channels_max) {\r\nprintk(KERN_ERR "ASoC: %s <-> %s No matching channels\n",\r\ncodec_dai_name, cpu_dai->name);\r\ngoto config_err;\r\n}\r\nsoc_pcm_apply_msb(substream);\r\nif (cpu_dai->active) {\r\nret = soc_pcm_apply_symmetry(substream, cpu_dai);\r\nif (ret != 0)\r\ngoto config_err;\r\n}\r\nfor (i = 0; i < rtd->num_codecs; i++) {\r\nif (rtd->codec_dais[i]->active) {\r\nret = soc_pcm_apply_symmetry(substream,\r\nrtd->codec_dais[i]);\r\nif (ret != 0)\r\ngoto config_err;\r\n}\r\n}\r\npr_debug("ASoC: %s <-> %s info:\n",\r\ncodec_dai_name, cpu_dai->name);\r\npr_debug("ASoC: rate mask 0x%x\n", runtime->hw.rates);\r\npr_debug("ASoC: min ch %d max ch %d\n", runtime->hw.channels_min,\r\nruntime->hw.channels_max);\r\npr_debug("ASoC: min rate %d max rate %d\n", runtime->hw.rate_min,\r\nruntime->hw.rate_max);\r\ndynamic:\r\nsnd_soc_runtime_activate(rtd, substream->stream);\r\nmutex_unlock(&rtd->pcm_mutex);\r\nreturn 0;\r\nconfig_err:\r\nif (rtd->dai_link->ops && rtd->dai_link->ops->shutdown)\r\nrtd->dai_link->ops->shutdown(substream);\r\nmachine_err:\r\ni = rtd->num_codecs;\r\ncodec_dai_err:\r\nwhile (--i >= 0) {\r\ncodec_dai = rtd->codec_dais[i];\r\nif (codec_dai->driver->ops->shutdown)\r\ncodec_dai->driver->ops->shutdown(substream, codec_dai);\r\n}\r\nif (platform->driver->ops && platform->driver->ops->close)\r\nplatform->driver->ops->close(substream);\r\nplatform_err:\r\nif (cpu_dai->driver->ops->shutdown)\r\ncpu_dai->driver->ops->shutdown(substream, cpu_dai);\r\nout:\r\nmutex_unlock(&rtd->pcm_mutex);\r\npm_runtime_mark_last_busy(platform->dev);\r\npm_runtime_put_autosuspend(platform->dev);\r\nfor (i = 0; i < rtd->num_codecs; i++) {\r\npm_runtime_mark_last_busy(rtd->codec_dais[i]->dev);\r\npm_runtime_put_autosuspend(rtd->codec_dais[i]->dev);\r\n}\r\npm_runtime_mark_last_busy(cpu_dai->dev);\r\npm_runtime_put_autosuspend(cpu_dai->dev);\r\nfor (i = 0; i < rtd->num_codecs; i++) {\r\nif (!rtd->codec_dais[i]->active)\r\npinctrl_pm_select_sleep_state(rtd->codec_dais[i]->dev);\r\n}\r\nif (!cpu_dai->active)\r\npinctrl_pm_select_sleep_state(cpu_dai->dev);\r\nreturn ret;\r\n}\r\nstatic void close_delayed_work(struct work_struct *work)\r\n{\r\nstruct snd_soc_pcm_runtime *rtd =\r\ncontainer_of(work, struct snd_soc_pcm_runtime, delayed_work.work);\r\nstruct snd_soc_dai *codec_dai = rtd->codec_dais[0];\r\nmutex_lock_nested(&rtd->pcm_mutex, rtd->pcm_subclass);\r\ndev_dbg(rtd->dev, "ASoC: pop wq checking: %s status: %s waiting: %s\n",\r\ncodec_dai->driver->playback.stream_name,\r\ncodec_dai->playback_active ? "active" : "inactive",\r\nrtd->pop_wait ? "yes" : "no");\r\nif (rtd->pop_wait == 1) {\r\nrtd->pop_wait = 0;\r\nsnd_soc_dapm_stream_event(rtd, SNDRV_PCM_STREAM_PLAYBACK,\r\nSND_SOC_DAPM_STREAM_STOP);\r\n}\r\nmutex_unlock(&rtd->pcm_mutex);\r\n}\r\nstatic int soc_pcm_close(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_soc_pcm_runtime *rtd = substream->private_data;\r\nstruct snd_soc_platform *platform = rtd->platform;\r\nstruct snd_soc_dai *cpu_dai = rtd->cpu_dai;\r\nstruct snd_soc_dai *codec_dai;\r\nint i;\r\nmutex_lock_nested(&rtd->pcm_mutex, rtd->pcm_subclass);\r\nsnd_soc_runtime_deactivate(rtd, substream->stream);\r\nif (!cpu_dai->active)\r\ncpu_dai->rate = 0;\r\nfor (i = 0; i < rtd->num_codecs; i++) {\r\ncodec_dai = rtd->codec_dais[i];\r\nif (!codec_dai->active)\r\ncodec_dai->rate = 0;\r\n}\r\nsnd_soc_dai_digital_mute(cpu_dai, 1, substream->stream);\r\nif (cpu_dai->driver->ops->shutdown)\r\ncpu_dai->driver->ops->shutdown(substream, cpu_dai);\r\nfor (i = 0; i < rtd->num_codecs; i++) {\r\ncodec_dai = rtd->codec_dais[i];\r\nif (codec_dai->driver->ops->shutdown)\r\ncodec_dai->driver->ops->shutdown(substream, codec_dai);\r\n}\r\nif (rtd->dai_link->ops && rtd->dai_link->ops->shutdown)\r\nrtd->dai_link->ops->shutdown(substream);\r\nif (platform->driver->ops && platform->driver->ops->close)\r\nplatform->driver->ops->close(substream);\r\nif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {\r\nif (snd_soc_runtime_ignore_pmdown_time(rtd)) {\r\nsnd_soc_dapm_stream_event(rtd,\r\nSNDRV_PCM_STREAM_PLAYBACK,\r\nSND_SOC_DAPM_STREAM_STOP);\r\n} else {\r\nrtd->pop_wait = 1;\r\nqueue_delayed_work(system_power_efficient_wq,\r\n&rtd->delayed_work,\r\nmsecs_to_jiffies(rtd->pmdown_time));\r\n}\r\n} else {\r\nsnd_soc_dapm_stream_event(rtd, SNDRV_PCM_STREAM_CAPTURE,\r\nSND_SOC_DAPM_STREAM_STOP);\r\n}\r\nmutex_unlock(&rtd->pcm_mutex);\r\npm_runtime_mark_last_busy(platform->dev);\r\npm_runtime_put_autosuspend(platform->dev);\r\nfor (i = 0; i < rtd->num_codecs; i++) {\r\npm_runtime_mark_last_busy(rtd->codec_dais[i]->dev);\r\npm_runtime_put_autosuspend(rtd->codec_dais[i]->dev);\r\n}\r\npm_runtime_mark_last_busy(cpu_dai->dev);\r\npm_runtime_put_autosuspend(cpu_dai->dev);\r\nfor (i = 0; i < rtd->num_codecs; i++) {\r\nif (!rtd->codec_dais[i]->active)\r\npinctrl_pm_select_sleep_state(rtd->codec_dais[i]->dev);\r\n}\r\nif (!cpu_dai->active)\r\npinctrl_pm_select_sleep_state(cpu_dai->dev);\r\nreturn 0;\r\n}\r\nstatic int soc_pcm_prepare(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_soc_pcm_runtime *rtd = substream->private_data;\r\nstruct snd_soc_platform *platform = rtd->platform;\r\nstruct snd_soc_dai *cpu_dai = rtd->cpu_dai;\r\nstruct snd_soc_dai *codec_dai;\r\nint i, ret = 0;\r\nmutex_lock_nested(&rtd->pcm_mutex, rtd->pcm_subclass);\r\nif (rtd->dai_link->ops && rtd->dai_link->ops->prepare) {\r\nret = rtd->dai_link->ops->prepare(substream);\r\nif (ret < 0) {\r\ndev_err(rtd->card->dev, "ASoC: machine prepare error:"\r\n" %d\n", ret);\r\ngoto out;\r\n}\r\n}\r\nif (platform->driver->ops && platform->driver->ops->prepare) {\r\nret = platform->driver->ops->prepare(substream);\r\nif (ret < 0) {\r\ndev_err(platform->dev, "ASoC: platform prepare error:"\r\n" %d\n", ret);\r\ngoto out;\r\n}\r\n}\r\nfor (i = 0; i < rtd->num_codecs; i++) {\r\ncodec_dai = rtd->codec_dais[i];\r\nif (codec_dai->driver->ops && codec_dai->driver->ops->prepare) {\r\nret = codec_dai->driver->ops->prepare(substream,\r\ncodec_dai);\r\nif (ret < 0) {\r\ndev_err(codec_dai->dev,\r\n"ASoC: codec DAI prepare error: %d\n",\r\nret);\r\ngoto out;\r\n}\r\n}\r\n}\r\nif (cpu_dai->driver->ops && cpu_dai->driver->ops->prepare) {\r\nret = cpu_dai->driver->ops->prepare(substream, cpu_dai);\r\nif (ret < 0) {\r\ndev_err(cpu_dai->dev,\r\n"ASoC: cpu DAI prepare error: %d\n", ret);\r\ngoto out;\r\n}\r\n}\r\nif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK &&\r\nrtd->pop_wait) {\r\nrtd->pop_wait = 0;\r\ncancel_delayed_work(&rtd->delayed_work);\r\n}\r\nsnd_soc_dapm_stream_event(rtd, substream->stream,\r\nSND_SOC_DAPM_STREAM_START);\r\nfor (i = 0; i < rtd->num_codecs; i++)\r\nsnd_soc_dai_digital_mute(rtd->codec_dais[i], 0,\r\nsubstream->stream);\r\nsnd_soc_dai_digital_mute(cpu_dai, 0, substream->stream);\r\nout:\r\nmutex_unlock(&rtd->pcm_mutex);\r\nreturn ret;\r\n}\r\nstatic void soc_pcm_codec_params_fixup(struct snd_pcm_hw_params *params,\r\nunsigned int mask)\r\n{\r\nstruct snd_interval *interval;\r\nint channels = hweight_long(mask);\r\ninterval = hw_param_interval(params, SNDRV_PCM_HW_PARAM_CHANNELS);\r\ninterval->min = channels;\r\ninterval->max = channels;\r\n}\r\nint soc_dai_hw_params(struct snd_pcm_substream *substream,\r\nstruct snd_pcm_hw_params *params,\r\nstruct snd_soc_dai *dai)\r\n{\r\nint ret;\r\nif (dai->driver->ops && dai->driver->ops->hw_params) {\r\nret = dai->driver->ops->hw_params(substream, params, dai);\r\nif (ret < 0) {\r\ndev_err(dai->dev, "ASoC: can't set %s hw params: %d\n",\r\ndai->name, ret);\r\nreturn ret;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int soc_pcm_hw_params(struct snd_pcm_substream *substream,\r\nstruct snd_pcm_hw_params *params)\r\n{\r\nstruct snd_soc_pcm_runtime *rtd = substream->private_data;\r\nstruct snd_soc_platform *platform = rtd->platform;\r\nstruct snd_soc_dai *cpu_dai = rtd->cpu_dai;\r\nint i, ret = 0;\r\nmutex_lock_nested(&rtd->pcm_mutex, rtd->pcm_subclass);\r\nret = soc_pcm_params_symmetry(substream, params);\r\nif (ret)\r\ngoto out;\r\nif (rtd->dai_link->ops && rtd->dai_link->ops->hw_params) {\r\nret = rtd->dai_link->ops->hw_params(substream, params);\r\nif (ret < 0) {\r\ndev_err(rtd->card->dev, "ASoC: machine hw_params"\r\n" failed: %d\n", ret);\r\ngoto out;\r\n}\r\n}\r\nfor (i = 0; i < rtd->num_codecs; i++) {\r\nstruct snd_soc_dai *codec_dai = rtd->codec_dais[i];\r\nstruct snd_pcm_hw_params codec_params;\r\nif (!snd_soc_dai_stream_valid(codec_dai, substream->stream))\r\ncontinue;\r\ncodec_params = *params;\r\nif (codec_dai->tx_mask)\r\nsoc_pcm_codec_params_fixup(&codec_params,\r\ncodec_dai->tx_mask);\r\nif (codec_dai->rx_mask)\r\nsoc_pcm_codec_params_fixup(&codec_params,\r\ncodec_dai->rx_mask);\r\nret = soc_dai_hw_params(substream, &codec_params, codec_dai);\r\nif(ret < 0)\r\ngoto codec_err;\r\ncodec_dai->rate = params_rate(&codec_params);\r\ncodec_dai->channels = params_channels(&codec_params);\r\ncodec_dai->sample_bits = snd_pcm_format_physical_width(\r\nparams_format(&codec_params));\r\n}\r\nret = soc_dai_hw_params(substream, params, cpu_dai);\r\nif (ret < 0)\r\ngoto interface_err;\r\nif (platform->driver->ops && platform->driver->ops->hw_params) {\r\nret = platform->driver->ops->hw_params(substream, params);\r\nif (ret < 0) {\r\ndev_err(platform->dev, "ASoC: %s hw params failed: %d\n",\r\nplatform->component.name, ret);\r\ngoto platform_err;\r\n}\r\n}\r\ncpu_dai->rate = params_rate(params);\r\ncpu_dai->channels = params_channels(params);\r\ncpu_dai->sample_bits =\r\nsnd_pcm_format_physical_width(params_format(params));\r\nout:\r\nmutex_unlock(&rtd->pcm_mutex);\r\nreturn ret;\r\nplatform_err:\r\nif (cpu_dai->driver->ops && cpu_dai->driver->ops->hw_free)\r\ncpu_dai->driver->ops->hw_free(substream, cpu_dai);\r\ninterface_err:\r\ni = rtd->num_codecs;\r\ncodec_err:\r\nwhile (--i >= 0) {\r\nstruct snd_soc_dai *codec_dai = rtd->codec_dais[i];\r\nif (codec_dai->driver->ops && codec_dai->driver->ops->hw_free)\r\ncodec_dai->driver->ops->hw_free(substream, codec_dai);\r\ncodec_dai->rate = 0;\r\n}\r\nif (rtd->dai_link->ops && rtd->dai_link->ops->hw_free)\r\nrtd->dai_link->ops->hw_free(substream);\r\nmutex_unlock(&rtd->pcm_mutex);\r\nreturn ret;\r\n}\r\nstatic int soc_pcm_hw_free(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_soc_pcm_runtime *rtd = substream->private_data;\r\nstruct snd_soc_platform *platform = rtd->platform;\r\nstruct snd_soc_dai *cpu_dai = rtd->cpu_dai;\r\nstruct snd_soc_dai *codec_dai;\r\nbool playback = substream->stream == SNDRV_PCM_STREAM_PLAYBACK;\r\nint i;\r\nmutex_lock_nested(&rtd->pcm_mutex, rtd->pcm_subclass);\r\nif (cpu_dai->active == 1) {\r\ncpu_dai->rate = 0;\r\ncpu_dai->channels = 0;\r\ncpu_dai->sample_bits = 0;\r\n}\r\nfor (i = 0; i < rtd->num_codecs; i++) {\r\ncodec_dai = rtd->codec_dais[i];\r\nif (codec_dai->active == 1) {\r\ncodec_dai->rate = 0;\r\ncodec_dai->channels = 0;\r\ncodec_dai->sample_bits = 0;\r\n}\r\n}\r\nfor (i = 0; i < rtd->num_codecs; i++) {\r\nif ((playback && rtd->codec_dais[i]->playback_active == 1) ||\r\n(!playback && rtd->codec_dais[i]->capture_active == 1))\r\nsnd_soc_dai_digital_mute(rtd->codec_dais[i], 1,\r\nsubstream->stream);\r\n}\r\nif (rtd->dai_link->ops && rtd->dai_link->ops->hw_free)\r\nrtd->dai_link->ops->hw_free(substream);\r\nif (platform->driver->ops && platform->driver->ops->hw_free)\r\nplatform->driver->ops->hw_free(substream);\r\nfor (i = 0; i < rtd->num_codecs; i++) {\r\ncodec_dai = rtd->codec_dais[i];\r\nif (codec_dai->driver->ops && codec_dai->driver->ops->hw_free)\r\ncodec_dai->driver->ops->hw_free(substream, codec_dai);\r\n}\r\nif (cpu_dai->driver->ops && cpu_dai->driver->ops->hw_free)\r\ncpu_dai->driver->ops->hw_free(substream, cpu_dai);\r\nmutex_unlock(&rtd->pcm_mutex);\r\nreturn 0;\r\n}\r\nstatic int soc_pcm_trigger(struct snd_pcm_substream *substream, int cmd)\r\n{\r\nstruct snd_soc_pcm_runtime *rtd = substream->private_data;\r\nstruct snd_soc_platform *platform = rtd->platform;\r\nstruct snd_soc_dai *cpu_dai = rtd->cpu_dai;\r\nstruct snd_soc_dai *codec_dai;\r\nint i, ret;\r\nfor (i = 0; i < rtd->num_codecs; i++) {\r\ncodec_dai = rtd->codec_dais[i];\r\nif (codec_dai->driver->ops && codec_dai->driver->ops->trigger) {\r\nret = codec_dai->driver->ops->trigger(substream,\r\ncmd, codec_dai);\r\nif (ret < 0)\r\nreturn ret;\r\n}\r\n}\r\nif (platform->driver->ops && platform->driver->ops->trigger) {\r\nret = platform->driver->ops->trigger(substream, cmd);\r\nif (ret < 0)\r\nreturn ret;\r\n}\r\nif (cpu_dai->driver->ops && cpu_dai->driver->ops->trigger) {\r\nret = cpu_dai->driver->ops->trigger(substream, cmd, cpu_dai);\r\nif (ret < 0)\r\nreturn ret;\r\n}\r\nif (rtd->dai_link->ops && rtd->dai_link->ops->trigger) {\r\nret = rtd->dai_link->ops->trigger(substream, cmd);\r\nif (ret < 0)\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic int soc_pcm_bespoke_trigger(struct snd_pcm_substream *substream,\r\nint cmd)\r\n{\r\nstruct snd_soc_pcm_runtime *rtd = substream->private_data;\r\nstruct snd_soc_platform *platform = rtd->platform;\r\nstruct snd_soc_dai *cpu_dai = rtd->cpu_dai;\r\nstruct snd_soc_dai *codec_dai;\r\nint i, ret;\r\nfor (i = 0; i < rtd->num_codecs; i++) {\r\ncodec_dai = rtd->codec_dais[i];\r\nif (codec_dai->driver->ops &&\r\ncodec_dai->driver->ops->bespoke_trigger) {\r\nret = codec_dai->driver->ops->bespoke_trigger(substream,\r\ncmd, codec_dai);\r\nif (ret < 0)\r\nreturn ret;\r\n}\r\n}\r\nif (platform->driver->bespoke_trigger) {\r\nret = platform->driver->bespoke_trigger(substream, cmd);\r\nif (ret < 0)\r\nreturn ret;\r\n}\r\nif (cpu_dai->driver->ops && cpu_dai->driver->ops->bespoke_trigger) {\r\nret = cpu_dai->driver->ops->bespoke_trigger(substream, cmd, cpu_dai);\r\nif (ret < 0)\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic snd_pcm_uframes_t soc_pcm_pointer(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_soc_pcm_runtime *rtd = substream->private_data;\r\nstruct snd_soc_platform *platform = rtd->platform;\r\nstruct snd_soc_dai *cpu_dai = rtd->cpu_dai;\r\nstruct snd_soc_dai *codec_dai;\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nsnd_pcm_uframes_t offset = 0;\r\nsnd_pcm_sframes_t delay = 0;\r\nsnd_pcm_sframes_t codec_delay = 0;\r\nint i;\r\nif (platform->driver->ops && platform->driver->ops->pointer)\r\noffset = platform->driver->ops->pointer(substream);\r\nif (cpu_dai->driver->ops && cpu_dai->driver->ops->delay)\r\ndelay += cpu_dai->driver->ops->delay(substream, cpu_dai);\r\nfor (i = 0; i < rtd->num_codecs; i++) {\r\ncodec_dai = rtd->codec_dais[i];\r\nif (codec_dai->driver->ops && codec_dai->driver->ops->delay)\r\ncodec_delay = max(codec_delay,\r\ncodec_dai->driver->ops->delay(substream,\r\ncodec_dai));\r\n}\r\ndelay += codec_delay;\r\nif (platform->driver->delay)\r\ndelay += platform->driver->delay(substream, rtd->codec_dais[0]);\r\nruntime->delay = delay;\r\nreturn offset;\r\n}\r\nstatic int dpcm_be_connect(struct snd_soc_pcm_runtime *fe,\r\nstruct snd_soc_pcm_runtime *be, int stream)\r\n{\r\nstruct snd_soc_dpcm *dpcm;\r\nlist_for_each_entry(dpcm, &fe->dpcm[stream].be_clients, list_be) {\r\nif (dpcm->be == be && dpcm->fe == fe)\r\nreturn 0;\r\n}\r\ndpcm = kzalloc(sizeof(struct snd_soc_dpcm), GFP_KERNEL);\r\nif (!dpcm)\r\nreturn -ENOMEM;\r\ndpcm->be = be;\r\ndpcm->fe = fe;\r\nbe->dpcm[stream].runtime = fe->dpcm[stream].runtime;\r\ndpcm->state = SND_SOC_DPCM_LINK_STATE_NEW;\r\nlist_add(&dpcm->list_be, &fe->dpcm[stream].be_clients);\r\nlist_add(&dpcm->list_fe, &be->dpcm[stream].fe_clients);\r\ndev_dbg(fe->dev, "connected new DPCM %s path %s %s %s\n",\r\nstream ? "capture" : "playback", fe->dai_link->name,\r\nstream ? "<-" : "->", be->dai_link->name);\r\n#ifdef CONFIG_DEBUG_FS\r\nif (fe->debugfs_dpcm_root)\r\ndpcm->debugfs_state = debugfs_create_u32(be->dai_link->name, 0644,\r\nfe->debugfs_dpcm_root, &dpcm->state);\r\n#endif\r\nreturn 1;\r\n}\r\nstatic void dpcm_be_reparent(struct snd_soc_pcm_runtime *fe,\r\nstruct snd_soc_pcm_runtime *be, int stream)\r\n{\r\nstruct snd_soc_dpcm *dpcm;\r\nstruct snd_pcm_substream *fe_substream, *be_substream;\r\nif (!be->dpcm[stream].users)\r\nreturn;\r\nbe_substream = snd_soc_dpcm_get_substream(be, stream);\r\nlist_for_each_entry(dpcm, &be->dpcm[stream].fe_clients, list_fe) {\r\nif (dpcm->fe == fe)\r\ncontinue;\r\ndev_dbg(fe->dev, "reparent %s path %s %s %s\n",\r\nstream ? "capture" : "playback",\r\ndpcm->fe->dai_link->name,\r\nstream ? "<-" : "->", dpcm->be->dai_link->name);\r\nfe_substream = snd_soc_dpcm_get_substream(dpcm->fe, stream);\r\nbe_substream->runtime = fe_substream->runtime;\r\nbreak;\r\n}\r\n}\r\nvoid dpcm_be_disconnect(struct snd_soc_pcm_runtime *fe, int stream)\r\n{\r\nstruct snd_soc_dpcm *dpcm, *d;\r\nlist_for_each_entry_safe(dpcm, d, &fe->dpcm[stream].be_clients, list_be) {\r\ndev_dbg(fe->dev, "ASoC: BE %s disconnect check for %s\n",\r\nstream ? "capture" : "playback",\r\ndpcm->be->dai_link->name);\r\nif (dpcm->state != SND_SOC_DPCM_LINK_STATE_FREE)\r\ncontinue;\r\ndev_dbg(fe->dev, "freed DSP %s path %s %s %s\n",\r\nstream ? "capture" : "playback", fe->dai_link->name,\r\nstream ? "<-" : "->", dpcm->be->dai_link->name);\r\ndpcm_be_reparent(fe, dpcm->be, stream);\r\n#ifdef CONFIG_DEBUG_FS\r\ndebugfs_remove(dpcm->debugfs_state);\r\n#endif\r\nlist_del(&dpcm->list_be);\r\nlist_del(&dpcm->list_fe);\r\nkfree(dpcm);\r\n}\r\n}\r\nstatic struct snd_soc_pcm_runtime *dpcm_get_be(struct snd_soc_card *card,\r\nstruct snd_soc_dapm_widget *widget, int stream)\r\n{\r\nstruct snd_soc_pcm_runtime *be;\r\nint i;\r\nif (stream == SNDRV_PCM_STREAM_PLAYBACK) {\r\nlist_for_each_entry(be, &card->rtd_list, list) {\r\nif (!be->dai_link->no_pcm)\r\ncontinue;\r\nif (be->cpu_dai->playback_widget == widget)\r\nreturn be;\r\nfor (i = 0; i < be->num_codecs; i++) {\r\nstruct snd_soc_dai *dai = be->codec_dais[i];\r\nif (dai->playback_widget == widget)\r\nreturn be;\r\n}\r\n}\r\n} else {\r\nlist_for_each_entry(be, &card->rtd_list, list) {\r\nif (!be->dai_link->no_pcm)\r\ncontinue;\r\nif (be->cpu_dai->capture_widget == widget)\r\nreturn be;\r\nfor (i = 0; i < be->num_codecs; i++) {\r\nstruct snd_soc_dai *dai = be->codec_dais[i];\r\nif (dai->capture_widget == widget)\r\nreturn be;\r\n}\r\n}\r\n}\r\ndev_err(card->dev, "ASoC: can't get %s BE for %s\n",\r\nstream ? "capture" : "playback", widget->name);\r\nreturn NULL;\r\n}\r\nstatic inline struct snd_soc_dapm_widget *\r\ndai_get_widget(struct snd_soc_dai *dai, int stream)\r\n{\r\nif (stream == SNDRV_PCM_STREAM_PLAYBACK)\r\nreturn dai->playback_widget;\r\nelse\r\nreturn dai->capture_widget;\r\n}\r\nstatic int widget_in_list(struct snd_soc_dapm_widget_list *list,\r\nstruct snd_soc_dapm_widget *widget)\r\n{\r\nint i;\r\nfor (i = 0; i < list->num_widgets; i++) {\r\nif (widget == list->widgets[i])\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}\r\nint dpcm_path_get(struct snd_soc_pcm_runtime *fe,\r\nint stream, struct snd_soc_dapm_widget_list **list)\r\n{\r\nstruct snd_soc_dai *cpu_dai = fe->cpu_dai;\r\nint paths;\r\npaths = snd_soc_dapm_dai_get_connected_widgets(cpu_dai, stream, list);\r\ndev_dbg(fe->dev, "ASoC: found %d audio %s paths\n", paths,\r\nstream ? "capture" : "playback");\r\nreturn paths;\r\n}\r\nstatic int dpcm_prune_paths(struct snd_soc_pcm_runtime *fe, int stream,\r\nstruct snd_soc_dapm_widget_list **list_)\r\n{\r\nstruct snd_soc_dpcm *dpcm;\r\nstruct snd_soc_dapm_widget_list *list = *list_;\r\nstruct snd_soc_dapm_widget *widget;\r\nint prune = 0;\r\nlist_for_each_entry(dpcm, &fe->dpcm[stream].be_clients, list_be) {\r\nunsigned int i;\r\nwidget = dai_get_widget(dpcm->be->cpu_dai, stream);\r\nif (widget && widget_in_list(list, widget))\r\ncontinue;\r\nfor (i = 0; i < dpcm->be->num_codecs; i++) {\r\nstruct snd_soc_dai *dai = dpcm->be->codec_dais[i];\r\nwidget = dai_get_widget(dai, stream);\r\nif (widget && widget_in_list(list, widget))\r\ncontinue;\r\n}\r\ndev_dbg(fe->dev, "ASoC: pruning %s BE %s for %s\n",\r\nstream ? "capture" : "playback",\r\ndpcm->be->dai_link->name, fe->dai_link->name);\r\ndpcm->state = SND_SOC_DPCM_LINK_STATE_FREE;\r\ndpcm->be->dpcm[stream].runtime_update = SND_SOC_DPCM_UPDATE_BE;\r\nprune++;\r\n}\r\ndev_dbg(fe->dev, "ASoC: found %d old BE paths for pruning\n", prune);\r\nreturn prune;\r\n}\r\nstatic int dpcm_add_paths(struct snd_soc_pcm_runtime *fe, int stream,\r\nstruct snd_soc_dapm_widget_list **list_)\r\n{\r\nstruct snd_soc_card *card = fe->card;\r\nstruct snd_soc_dapm_widget_list *list = *list_;\r\nstruct snd_soc_pcm_runtime *be;\r\nint i, new = 0, err;\r\nfor (i = 0; i < list->num_widgets; i++) {\r\nswitch (list->widgets[i]->id) {\r\ncase snd_soc_dapm_dai_in:\r\nif (stream != SNDRV_PCM_STREAM_PLAYBACK)\r\ncontinue;\r\nbreak;\r\ncase snd_soc_dapm_dai_out:\r\nif (stream != SNDRV_PCM_STREAM_CAPTURE)\r\ncontinue;\r\nbreak;\r\ndefault:\r\ncontinue;\r\n}\r\nbe = dpcm_get_be(card, list->widgets[i], stream);\r\nif (!be) {\r\ndev_err(fe->dev, "ASoC: no BE found for %s\n",\r\nlist->widgets[i]->name);\r\ncontinue;\r\n}\r\nif (!be->dai_link->no_pcm)\r\ncontinue;\r\nif (!fe->dpcm[stream].runtime && !fe->fe_compr)\r\ncontinue;\r\nerr = dpcm_be_connect(fe, be, stream);\r\nif (err < 0) {\r\ndev_err(fe->dev, "ASoC: can't connect %s\n",\r\nlist->widgets[i]->name);\r\nbreak;\r\n} else if (err == 0)\r\ncontinue;\r\nbe->dpcm[stream].runtime_update = SND_SOC_DPCM_UPDATE_BE;\r\nnew++;\r\n}\r\ndev_dbg(fe->dev, "ASoC: found %d new BE paths\n", new);\r\nreturn new;\r\n}\r\nint dpcm_process_paths(struct snd_soc_pcm_runtime *fe,\r\nint stream, struct snd_soc_dapm_widget_list **list, int new)\r\n{\r\nif (new)\r\nreturn dpcm_add_paths(fe, stream, list);\r\nelse\r\nreturn dpcm_prune_paths(fe, stream, list);\r\n}\r\nvoid dpcm_clear_pending_state(struct snd_soc_pcm_runtime *fe, int stream)\r\n{\r\nstruct snd_soc_dpcm *dpcm;\r\nlist_for_each_entry(dpcm, &fe->dpcm[stream].be_clients, list_be)\r\ndpcm->be->dpcm[stream].runtime_update =\r\nSND_SOC_DPCM_UPDATE_NO;\r\n}\r\nstatic void dpcm_be_dai_startup_unwind(struct snd_soc_pcm_runtime *fe,\r\nint stream)\r\n{\r\nstruct snd_soc_dpcm *dpcm;\r\nlist_for_each_entry(dpcm, &fe->dpcm[stream].be_clients, list_be) {\r\nstruct snd_soc_pcm_runtime *be = dpcm->be;\r\nstruct snd_pcm_substream *be_substream =\r\nsnd_soc_dpcm_get_substream(be, stream);\r\nif (be->dpcm[stream].users == 0)\r\ndev_err(be->dev, "ASoC: no users %s at close - state %d\n",\r\nstream ? "capture" : "playback",\r\nbe->dpcm[stream].state);\r\nif (--be->dpcm[stream].users != 0)\r\ncontinue;\r\nif (be->dpcm[stream].state != SND_SOC_DPCM_STATE_OPEN)\r\ncontinue;\r\nsoc_pcm_close(be_substream);\r\nbe_substream->runtime = NULL;\r\nbe->dpcm[stream].state = SND_SOC_DPCM_STATE_CLOSE;\r\n}\r\n}\r\nint dpcm_be_dai_startup(struct snd_soc_pcm_runtime *fe, int stream)\r\n{\r\nstruct snd_soc_dpcm *dpcm;\r\nint err, count = 0;\r\nlist_for_each_entry(dpcm, &fe->dpcm[stream].be_clients, list_be) {\r\nstruct snd_soc_pcm_runtime *be = dpcm->be;\r\nstruct snd_pcm_substream *be_substream =\r\nsnd_soc_dpcm_get_substream(be, stream);\r\nif (!be_substream) {\r\ndev_err(be->dev, "ASoC: no backend %s stream\n",\r\nstream ? "capture" : "playback");\r\ncontinue;\r\n}\r\nif (!snd_soc_dpcm_be_can_update(fe, be, stream))\r\ncontinue;\r\nif (be->dpcm[stream].users == DPCM_MAX_BE_USERS)\r\ndev_err(be->dev, "ASoC: too many users %s at open %d\n",\r\nstream ? "capture" : "playback",\r\nbe->dpcm[stream].state);\r\nif (be->dpcm[stream].users++ != 0)\r\ncontinue;\r\nif ((be->dpcm[stream].state != SND_SOC_DPCM_STATE_NEW) &&\r\n(be->dpcm[stream].state != SND_SOC_DPCM_STATE_CLOSE))\r\ncontinue;\r\ndev_dbg(be->dev, "ASoC: open %s BE %s\n",\r\nstream ? "capture" : "playback", be->dai_link->name);\r\nbe_substream->runtime = be->dpcm[stream].runtime;\r\nerr = soc_pcm_open(be_substream);\r\nif (err < 0) {\r\ndev_err(be->dev, "ASoC: BE open failed %d\n", err);\r\nbe->dpcm[stream].users--;\r\nif (be->dpcm[stream].users < 0)\r\ndev_err(be->dev, "ASoC: no users %s at unwind %d\n",\r\nstream ? "capture" : "playback",\r\nbe->dpcm[stream].state);\r\nbe->dpcm[stream].state = SND_SOC_DPCM_STATE_CLOSE;\r\ngoto unwind;\r\n}\r\nbe->dpcm[stream].state = SND_SOC_DPCM_STATE_OPEN;\r\ncount++;\r\n}\r\nreturn count;\r\nunwind:\r\nlist_for_each_entry_continue_reverse(dpcm, &fe->dpcm[stream].be_clients, list_be) {\r\nstruct snd_soc_pcm_runtime *be = dpcm->be;\r\nstruct snd_pcm_substream *be_substream =\r\nsnd_soc_dpcm_get_substream(be, stream);\r\nif (!snd_soc_dpcm_be_can_update(fe, be, stream))\r\ncontinue;\r\nif (be->dpcm[stream].users == 0)\r\ndev_err(be->dev, "ASoC: no users %s at close %d\n",\r\nstream ? "capture" : "playback",\r\nbe->dpcm[stream].state);\r\nif (--be->dpcm[stream].users != 0)\r\ncontinue;\r\nif (be->dpcm[stream].state != SND_SOC_DPCM_STATE_OPEN)\r\ncontinue;\r\nsoc_pcm_close(be_substream);\r\nbe_substream->runtime = NULL;\r\nbe->dpcm[stream].state = SND_SOC_DPCM_STATE_CLOSE;\r\n}\r\nreturn err;\r\n}\r\nstatic void dpcm_init_runtime_hw(struct snd_pcm_runtime *runtime,\r\nstruct snd_soc_pcm_stream *stream,\r\nu64 formats)\r\n{\r\nruntime->hw.rate_min = stream->rate_min;\r\nruntime->hw.rate_max = stream->rate_max;\r\nruntime->hw.channels_min = stream->channels_min;\r\nruntime->hw.channels_max = stream->channels_max;\r\nif (runtime->hw.formats)\r\nruntime->hw.formats &= formats & stream->formats;\r\nelse\r\nruntime->hw.formats = formats & stream->formats;\r\nruntime->hw.rates = stream->rates;\r\n}\r\nstatic u64 dpcm_runtime_base_format(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_soc_pcm_runtime *fe = substream->private_data;\r\nstruct snd_soc_dpcm *dpcm;\r\nu64 formats = ULLONG_MAX;\r\nint stream = substream->stream;\r\nif (!fe->dai_link->dpcm_merged_format)\r\nreturn formats;\r\nlist_for_each_entry(dpcm, &fe->dpcm[stream].be_clients, list_be) {\r\nstruct snd_soc_pcm_runtime *be = dpcm->be;\r\nstruct snd_soc_dai_driver *codec_dai_drv;\r\nstruct snd_soc_pcm_stream *codec_stream;\r\nint i;\r\nfor (i = 0; i < be->num_codecs; i++) {\r\ncodec_dai_drv = be->codec_dais[i]->driver;\r\nif (stream == SNDRV_PCM_STREAM_PLAYBACK)\r\ncodec_stream = &codec_dai_drv->playback;\r\nelse\r\ncodec_stream = &codec_dai_drv->capture;\r\nformats &= codec_stream->formats;\r\n}\r\n}\r\nreturn formats;\r\n}\r\nstatic void dpcm_set_fe_runtime(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nstruct snd_soc_pcm_runtime *rtd = substream->private_data;\r\nstruct snd_soc_dai *cpu_dai = rtd->cpu_dai;\r\nstruct snd_soc_dai_driver *cpu_dai_drv = cpu_dai->driver;\r\nu64 format = dpcm_runtime_base_format(substream);\r\nif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)\r\ndpcm_init_runtime_hw(runtime, &cpu_dai_drv->playback, format);\r\nelse\r\ndpcm_init_runtime_hw(runtime, &cpu_dai_drv->capture, format);\r\n}\r\nstatic void dpcm_set_fe_update_state(struct snd_soc_pcm_runtime *fe,\r\nint stream, enum snd_soc_dpcm_update state)\r\n{\r\nstruct snd_pcm_substream *substream =\r\nsnd_soc_dpcm_get_substream(fe, stream);\r\nsnd_pcm_stream_lock_irq(substream);\r\nif (state == SND_SOC_DPCM_UPDATE_NO && fe->dpcm[stream].trigger_pending) {\r\ndpcm_fe_dai_do_trigger(substream,\r\nfe->dpcm[stream].trigger_pending - 1);\r\nfe->dpcm[stream].trigger_pending = 0;\r\n}\r\nfe->dpcm[stream].runtime_update = state;\r\nsnd_pcm_stream_unlock_irq(substream);\r\n}\r\nstatic int dpcm_apply_symmetry(struct snd_pcm_substream *fe_substream,\r\nint stream)\r\n{\r\nstruct snd_soc_dpcm *dpcm;\r\nstruct snd_soc_pcm_runtime *fe = fe_substream->private_data;\r\nstruct snd_soc_dai *fe_cpu_dai = fe->cpu_dai;\r\nint err;\r\nif (soc_pcm_has_symmetry(fe_substream))\r\nfe_substream->runtime->hw.info |= SNDRV_PCM_INFO_JOINT_DUPLEX;\r\nif (fe_cpu_dai->active) {\r\nerr = soc_pcm_apply_symmetry(fe_substream, fe_cpu_dai);\r\nif (err < 0)\r\nreturn err;\r\n}\r\nlist_for_each_entry(dpcm, &fe->dpcm[stream].be_clients, list_be) {\r\nstruct snd_soc_pcm_runtime *be = dpcm->be;\r\nstruct snd_pcm_substream *be_substream =\r\nsnd_soc_dpcm_get_substream(be, stream);\r\nstruct snd_soc_pcm_runtime *rtd = be_substream->private_data;\r\nint i;\r\nif (soc_pcm_has_symmetry(be_substream))\r\nbe_substream->runtime->hw.info |= SNDRV_PCM_INFO_JOINT_DUPLEX;\r\nif (rtd->cpu_dai->active) {\r\nerr = soc_pcm_apply_symmetry(be_substream, rtd->cpu_dai);\r\nif (err < 0)\r\nreturn err;\r\n}\r\nfor (i = 0; i < rtd->num_codecs; i++) {\r\nif (rtd->codec_dais[i]->active) {\r\nerr = soc_pcm_apply_symmetry(be_substream,\r\nrtd->codec_dais[i]);\r\nif (err < 0)\r\nreturn err;\r\n}\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int dpcm_fe_dai_startup(struct snd_pcm_substream *fe_substream)\r\n{\r\nstruct snd_soc_pcm_runtime *fe = fe_substream->private_data;\r\nstruct snd_pcm_runtime *runtime = fe_substream->runtime;\r\nint stream = fe_substream->stream, ret = 0;\r\ndpcm_set_fe_update_state(fe, stream, SND_SOC_DPCM_UPDATE_FE);\r\nret = dpcm_be_dai_startup(fe, fe_substream->stream);\r\nif (ret < 0) {\r\ndev_err(fe->dev,"ASoC: failed to start some BEs %d\n", ret);\r\ngoto be_err;\r\n}\r\ndev_dbg(fe->dev, "ASoC: open FE %s\n", fe->dai_link->name);\r\nret = soc_pcm_open(fe_substream);\r\nif (ret < 0) {\r\ndev_err(fe->dev,"ASoC: failed to start FE %d\n", ret);\r\ngoto unwind;\r\n}\r\nfe->dpcm[stream].state = SND_SOC_DPCM_STATE_OPEN;\r\ndpcm_set_fe_runtime(fe_substream);\r\nsnd_pcm_limit_hw_rates(runtime);\r\nret = dpcm_apply_symmetry(fe_substream, stream);\r\nif (ret < 0) {\r\ndev_err(fe->dev, "ASoC: failed to apply dpcm symmetry %d\n",\r\nret);\r\ngoto unwind;\r\n}\r\ndpcm_set_fe_update_state(fe, stream, SND_SOC_DPCM_UPDATE_NO);\r\nreturn 0;\r\nunwind:\r\ndpcm_be_dai_startup_unwind(fe, fe_substream->stream);\r\nbe_err:\r\ndpcm_set_fe_update_state(fe, stream, SND_SOC_DPCM_UPDATE_NO);\r\nreturn ret;\r\n}\r\nint dpcm_be_dai_shutdown(struct snd_soc_pcm_runtime *fe, int stream)\r\n{\r\nstruct snd_soc_dpcm *dpcm;\r\nlist_for_each_entry(dpcm, &fe->dpcm[stream].be_clients, list_be) {\r\nstruct snd_soc_pcm_runtime *be = dpcm->be;\r\nstruct snd_pcm_substream *be_substream =\r\nsnd_soc_dpcm_get_substream(be, stream);\r\nif (!snd_soc_dpcm_be_can_update(fe, be, stream))\r\ncontinue;\r\nif (be->dpcm[stream].users == 0)\r\ndev_err(be->dev, "ASoC: no users %s at close - state %d\n",\r\nstream ? "capture" : "playback",\r\nbe->dpcm[stream].state);\r\nif (--be->dpcm[stream].users != 0)\r\ncontinue;\r\nif ((be->dpcm[stream].state != SND_SOC_DPCM_STATE_HW_FREE) &&\r\n(be->dpcm[stream].state != SND_SOC_DPCM_STATE_OPEN))\r\ncontinue;\r\ndev_dbg(be->dev, "ASoC: close BE %s\n",\r\ndpcm->fe->dai_link->name);\r\nsoc_pcm_close(be_substream);\r\nbe_substream->runtime = NULL;\r\nbe->dpcm[stream].state = SND_SOC_DPCM_STATE_CLOSE;\r\n}\r\nreturn 0;\r\n}\r\nstatic int dpcm_fe_dai_shutdown(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_soc_pcm_runtime *fe = substream->private_data;\r\nint stream = substream->stream;\r\ndpcm_set_fe_update_state(fe, stream, SND_SOC_DPCM_UPDATE_FE);\r\ndpcm_be_dai_shutdown(fe, substream->stream);\r\ndev_dbg(fe->dev, "ASoC: close FE %s\n", fe->dai_link->name);\r\nsoc_pcm_close(substream);\r\ndpcm_dapm_stream_event(fe, stream, SND_SOC_DAPM_STREAM_STOP);\r\nfe->dpcm[stream].state = SND_SOC_DPCM_STATE_CLOSE;\r\ndpcm_set_fe_update_state(fe, stream, SND_SOC_DPCM_UPDATE_NO);\r\nreturn 0;\r\n}\r\nint dpcm_be_dai_hw_free(struct snd_soc_pcm_runtime *fe, int stream)\r\n{\r\nstruct snd_soc_dpcm *dpcm;\r\nlist_for_each_entry(dpcm, &fe->dpcm[stream].be_clients, list_be) {\r\nstruct snd_soc_pcm_runtime *be = dpcm->be;\r\nstruct snd_pcm_substream *be_substream =\r\nsnd_soc_dpcm_get_substream(be, stream);\r\nif (!snd_soc_dpcm_be_can_update(fe, be, stream))\r\ncontinue;\r\nif (!snd_soc_dpcm_can_be_free_stop(fe, be, stream))\r\ncontinue;\r\nif (be->dpcm[stream].users > 1)\r\ncontinue;\r\nif ((be->dpcm[stream].state != SND_SOC_DPCM_STATE_HW_PARAMS) &&\r\n(be->dpcm[stream].state != SND_SOC_DPCM_STATE_PREPARE) &&\r\n(be->dpcm[stream].state != SND_SOC_DPCM_STATE_HW_FREE) &&\r\n(be->dpcm[stream].state != SND_SOC_DPCM_STATE_PAUSED) &&\r\n(be->dpcm[stream].state != SND_SOC_DPCM_STATE_STOP) &&\r\n(be->dpcm[stream].state != SND_SOC_DPCM_STATE_SUSPEND))\r\ncontinue;\r\ndev_dbg(be->dev, "ASoC: hw_free BE %s\n",\r\ndpcm->fe->dai_link->name);\r\nsoc_pcm_hw_free(be_substream);\r\nbe->dpcm[stream].state = SND_SOC_DPCM_STATE_HW_FREE;\r\n}\r\nreturn 0;\r\n}\r\nstatic int dpcm_fe_dai_hw_free(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_soc_pcm_runtime *fe = substream->private_data;\r\nint err, stream = substream->stream;\r\nmutex_lock_nested(&fe->card->mutex, SND_SOC_CARD_CLASS_RUNTIME);\r\ndpcm_set_fe_update_state(fe, stream, SND_SOC_DPCM_UPDATE_FE);\r\ndev_dbg(fe->dev, "ASoC: hw_free FE %s\n", fe->dai_link->name);\r\nerr = soc_pcm_hw_free(substream);\r\nif (err < 0)\r\ndev_err(fe->dev,"ASoC: hw_free FE %s failed\n",\r\nfe->dai_link->name);\r\nerr = dpcm_be_dai_hw_free(fe, stream);\r\nfe->dpcm[stream].state = SND_SOC_DPCM_STATE_HW_FREE;\r\ndpcm_set_fe_update_state(fe, stream, SND_SOC_DPCM_UPDATE_NO);\r\nmutex_unlock(&fe->card->mutex);\r\nreturn 0;\r\n}\r\nint dpcm_be_dai_hw_params(struct snd_soc_pcm_runtime *fe, int stream)\r\n{\r\nstruct snd_soc_dpcm *dpcm;\r\nint ret;\r\nlist_for_each_entry(dpcm, &fe->dpcm[stream].be_clients, list_be) {\r\nstruct snd_soc_pcm_runtime *be = dpcm->be;\r\nstruct snd_pcm_substream *be_substream =\r\nsnd_soc_dpcm_get_substream(be, stream);\r\nif (!snd_soc_dpcm_be_can_update(fe, be, stream))\r\ncontinue;\r\nmemcpy(&dpcm->hw_params, &fe->dpcm[stream].hw_params,\r\nsizeof(struct snd_pcm_hw_params));\r\nif (be->dai_link->be_hw_params_fixup) {\r\nret = be->dai_link->be_hw_params_fixup(be,\r\n&dpcm->hw_params);\r\nif (ret < 0) {\r\ndev_err(be->dev,\r\n"ASoC: hw_params BE fixup failed %d\n",\r\nret);\r\ngoto unwind;\r\n}\r\n}\r\nif (!snd_soc_dpcm_can_be_params(fe, be, stream))\r\ncontinue;\r\nif ((be->dpcm[stream].state != SND_SOC_DPCM_STATE_OPEN) &&\r\n(be->dpcm[stream].state != SND_SOC_DPCM_STATE_HW_PARAMS) &&\r\n(be->dpcm[stream].state != SND_SOC_DPCM_STATE_HW_FREE))\r\ncontinue;\r\ndev_dbg(be->dev, "ASoC: hw_params BE %s\n",\r\ndpcm->fe->dai_link->name);\r\nret = soc_pcm_hw_params(be_substream, &dpcm->hw_params);\r\nif (ret < 0) {\r\ndev_err(dpcm->be->dev,\r\n"ASoC: hw_params BE failed %d\n", ret);\r\ngoto unwind;\r\n}\r\nbe->dpcm[stream].state = SND_SOC_DPCM_STATE_HW_PARAMS;\r\n}\r\nreturn 0;\r\nunwind:\r\nlist_for_each_entry_continue_reverse(dpcm, &fe->dpcm[stream].be_clients, list_be) {\r\nstruct snd_soc_pcm_runtime *be = dpcm->be;\r\nstruct snd_pcm_substream *be_substream =\r\nsnd_soc_dpcm_get_substream(be, stream);\r\nif (!snd_soc_dpcm_be_can_update(fe, be, stream))\r\ncontinue;\r\nif (!snd_soc_dpcm_can_be_free_stop(fe, be, stream))\r\ncontinue;\r\nif ((be->dpcm[stream].state != SND_SOC_DPCM_STATE_OPEN) &&\r\n(be->dpcm[stream].state != SND_SOC_DPCM_STATE_HW_PARAMS) &&\r\n(be->dpcm[stream].state != SND_SOC_DPCM_STATE_HW_FREE) &&\r\n(be->dpcm[stream].state != SND_SOC_DPCM_STATE_STOP))\r\ncontinue;\r\nsoc_pcm_hw_free(be_substream);\r\n}\r\nreturn ret;\r\n}\r\nstatic int dpcm_fe_dai_hw_params(struct snd_pcm_substream *substream,\r\nstruct snd_pcm_hw_params *params)\r\n{\r\nstruct snd_soc_pcm_runtime *fe = substream->private_data;\r\nint ret, stream = substream->stream;\r\nmutex_lock_nested(&fe->card->mutex, SND_SOC_CARD_CLASS_RUNTIME);\r\ndpcm_set_fe_update_state(fe, stream, SND_SOC_DPCM_UPDATE_FE);\r\nmemcpy(&fe->dpcm[substream->stream].hw_params, params,\r\nsizeof(struct snd_pcm_hw_params));\r\nret = dpcm_be_dai_hw_params(fe, substream->stream);\r\nif (ret < 0) {\r\ndev_err(fe->dev,"ASoC: hw_params BE failed %d\n", ret);\r\ngoto out;\r\n}\r\ndev_dbg(fe->dev, "ASoC: hw_params FE %s rate %d chan %x fmt %d\n",\r\nfe->dai_link->name, params_rate(params),\r\nparams_channels(params), params_format(params));\r\nret = soc_pcm_hw_params(substream, params);\r\nif (ret < 0) {\r\ndev_err(fe->dev,"ASoC: hw_params FE failed %d\n", ret);\r\ndpcm_be_dai_hw_free(fe, stream);\r\n} else\r\nfe->dpcm[stream].state = SND_SOC_DPCM_STATE_HW_PARAMS;\r\nout:\r\ndpcm_set_fe_update_state(fe, stream, SND_SOC_DPCM_UPDATE_NO);\r\nmutex_unlock(&fe->card->mutex);\r\nreturn ret;\r\n}\r\nstatic int dpcm_do_trigger(struct snd_soc_dpcm *dpcm,\r\nstruct snd_pcm_substream *substream, int cmd)\r\n{\r\nint ret;\r\ndev_dbg(dpcm->be->dev, "ASoC: trigger BE %s cmd %d\n",\r\ndpcm->fe->dai_link->name, cmd);\r\nret = soc_pcm_trigger(substream, cmd);\r\nif (ret < 0)\r\ndev_err(dpcm->be->dev,"ASoC: trigger BE failed %d\n", ret);\r\nreturn ret;\r\n}\r\nint dpcm_be_dai_trigger(struct snd_soc_pcm_runtime *fe, int stream,\r\nint cmd)\r\n{\r\nstruct snd_soc_dpcm *dpcm;\r\nint ret = 0;\r\nlist_for_each_entry(dpcm, &fe->dpcm[stream].be_clients, list_be) {\r\nstruct snd_soc_pcm_runtime *be = dpcm->be;\r\nstruct snd_pcm_substream *be_substream =\r\nsnd_soc_dpcm_get_substream(be, stream);\r\nif (!snd_soc_dpcm_be_can_update(fe, be, stream))\r\ncontinue;\r\nswitch (cmd) {\r\ncase SNDRV_PCM_TRIGGER_START:\r\nif ((be->dpcm[stream].state != SND_SOC_DPCM_STATE_PREPARE) &&\r\n(be->dpcm[stream].state != SND_SOC_DPCM_STATE_STOP))\r\ncontinue;\r\nret = dpcm_do_trigger(dpcm, be_substream, cmd);\r\nif (ret)\r\nreturn ret;\r\nbe->dpcm[stream].state = SND_SOC_DPCM_STATE_START;\r\nbreak;\r\ncase SNDRV_PCM_TRIGGER_RESUME:\r\nif ((be->dpcm[stream].state != SND_SOC_DPCM_STATE_SUSPEND))\r\ncontinue;\r\nret = dpcm_do_trigger(dpcm, be_substream, cmd);\r\nif (ret)\r\nreturn ret;\r\nbe->dpcm[stream].state = SND_SOC_DPCM_STATE_START;\r\nbreak;\r\ncase SNDRV_PCM_TRIGGER_PAUSE_RELEASE:\r\nif ((be->dpcm[stream].state != SND_SOC_DPCM_STATE_PAUSED))\r\ncontinue;\r\nret = dpcm_do_trigger(dpcm, be_substream, cmd);\r\nif (ret)\r\nreturn ret;\r\nbe->dpcm[stream].state = SND_SOC_DPCM_STATE_START;\r\nbreak;\r\ncase SNDRV_PCM_TRIGGER_STOP:\r\nif (be->dpcm[stream].state != SND_SOC_DPCM_STATE_START)\r\ncontinue;\r\nif (!snd_soc_dpcm_can_be_free_stop(fe, be, stream))\r\ncontinue;\r\nret = dpcm_do_trigger(dpcm, be_substream, cmd);\r\nif (ret)\r\nreturn ret;\r\nbe->dpcm[stream].state = SND_SOC_DPCM_STATE_STOP;\r\nbreak;\r\ncase SNDRV_PCM_TRIGGER_SUSPEND:\r\nif (be->dpcm[stream].state != SND_SOC_DPCM_STATE_START)\r\ncontinue;\r\nif (!snd_soc_dpcm_can_be_free_stop(fe, be, stream))\r\ncontinue;\r\nret = dpcm_do_trigger(dpcm, be_substream, cmd);\r\nif (ret)\r\nreturn ret;\r\nbe->dpcm[stream].state = SND_SOC_DPCM_STATE_SUSPEND;\r\nbreak;\r\ncase SNDRV_PCM_TRIGGER_PAUSE_PUSH:\r\nif (be->dpcm[stream].state != SND_SOC_DPCM_STATE_START)\r\ncontinue;\r\nif (!snd_soc_dpcm_can_be_free_stop(fe, be, stream))\r\ncontinue;\r\nret = dpcm_do_trigger(dpcm, be_substream, cmd);\r\nif (ret)\r\nreturn ret;\r\nbe->dpcm[stream].state = SND_SOC_DPCM_STATE_PAUSED;\r\nbreak;\r\n}\r\n}\r\nreturn ret;\r\n}\r\nstatic int dpcm_fe_dai_do_trigger(struct snd_pcm_substream *substream, int cmd)\r\n{\r\nstruct snd_soc_pcm_runtime *fe = substream->private_data;\r\nint stream = substream->stream, ret;\r\nenum snd_soc_dpcm_trigger trigger = fe->dai_link->trigger[stream];\r\nfe->dpcm[stream].runtime_update = SND_SOC_DPCM_UPDATE_FE;\r\nswitch (trigger) {\r\ncase SND_SOC_DPCM_TRIGGER_PRE:\r\ndev_dbg(fe->dev, "ASoC: pre trigger FE %s cmd %d\n",\r\nfe->dai_link->name, cmd);\r\nret = soc_pcm_trigger(substream, cmd);\r\nif (ret < 0) {\r\ndev_err(fe->dev,"ASoC: trigger FE failed %d\n", ret);\r\ngoto out;\r\n}\r\nret = dpcm_be_dai_trigger(fe, substream->stream, cmd);\r\nbreak;\r\ncase SND_SOC_DPCM_TRIGGER_POST:\r\nret = dpcm_be_dai_trigger(fe, substream->stream, cmd);\r\nif (ret < 0) {\r\ndev_err(fe->dev,"ASoC: trigger FE failed %d\n", ret);\r\ngoto out;\r\n}\r\ndev_dbg(fe->dev, "ASoC: post trigger FE %s cmd %d\n",\r\nfe->dai_link->name, cmd);\r\nret = soc_pcm_trigger(substream, cmd);\r\nbreak;\r\ncase SND_SOC_DPCM_TRIGGER_BESPOKE:\r\ndev_dbg(fe->dev, "ASoC: bespoke trigger FE %s cmd %d\n",\r\nfe->dai_link->name, cmd);\r\nret = soc_pcm_bespoke_trigger(substream, cmd);\r\nif (ret < 0) {\r\ndev_err(fe->dev,"ASoC: trigger FE failed %d\n", ret);\r\ngoto out;\r\n}\r\nbreak;\r\ndefault:\r\ndev_err(fe->dev, "ASoC: invalid trigger cmd %d for %s\n", cmd,\r\nfe->dai_link->name);\r\nret = -EINVAL;\r\ngoto out;\r\n}\r\nswitch (cmd) {\r\ncase SNDRV_PCM_TRIGGER_START:\r\ncase SNDRV_PCM_TRIGGER_RESUME:\r\ncase SNDRV_PCM_TRIGGER_PAUSE_RELEASE:\r\nfe->dpcm[stream].state = SND_SOC_DPCM_STATE_START;\r\nbreak;\r\ncase SNDRV_PCM_TRIGGER_STOP:\r\ncase SNDRV_PCM_TRIGGER_SUSPEND:\r\ncase SNDRV_PCM_TRIGGER_PAUSE_PUSH:\r\nfe->dpcm[stream].state = SND_SOC_DPCM_STATE_STOP;\r\nbreak;\r\n}\r\nout:\r\nfe->dpcm[stream].runtime_update = SND_SOC_DPCM_UPDATE_NO;\r\nreturn ret;\r\n}\r\nstatic int dpcm_fe_dai_trigger(struct snd_pcm_substream *substream, int cmd)\r\n{\r\nstruct snd_soc_pcm_runtime *fe = substream->private_data;\r\nint stream = substream->stream;\r\nif (fe->dpcm[stream].runtime_update != SND_SOC_DPCM_UPDATE_NO) {\r\nfe->dpcm[stream].trigger_pending = cmd + 1;\r\nreturn 0;\r\n}\r\nreturn dpcm_fe_dai_do_trigger(substream, cmd);\r\n}\r\nint dpcm_be_dai_prepare(struct snd_soc_pcm_runtime *fe, int stream)\r\n{\r\nstruct snd_soc_dpcm *dpcm;\r\nint ret = 0;\r\nlist_for_each_entry(dpcm, &fe->dpcm[stream].be_clients, list_be) {\r\nstruct snd_soc_pcm_runtime *be = dpcm->be;\r\nstruct snd_pcm_substream *be_substream =\r\nsnd_soc_dpcm_get_substream(be, stream);\r\nif (!snd_soc_dpcm_be_can_update(fe, be, stream))\r\ncontinue;\r\nif ((be->dpcm[stream].state != SND_SOC_DPCM_STATE_HW_PARAMS) &&\r\n(be->dpcm[stream].state != SND_SOC_DPCM_STATE_STOP) &&\r\n(be->dpcm[stream].state != SND_SOC_DPCM_STATE_SUSPEND))\r\ncontinue;\r\ndev_dbg(be->dev, "ASoC: prepare BE %s\n",\r\ndpcm->fe->dai_link->name);\r\nret = soc_pcm_prepare(be_substream);\r\nif (ret < 0) {\r\ndev_err(be->dev, "ASoC: backend prepare failed %d\n",\r\nret);\r\nbreak;\r\n}\r\nbe->dpcm[stream].state = SND_SOC_DPCM_STATE_PREPARE;\r\n}\r\nreturn ret;\r\n}\r\nstatic int dpcm_fe_dai_prepare(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_soc_pcm_runtime *fe = substream->private_data;\r\nint stream = substream->stream, ret = 0;\r\nmutex_lock_nested(&fe->card->mutex, SND_SOC_CARD_CLASS_RUNTIME);\r\ndev_dbg(fe->dev, "ASoC: prepare FE %s\n", fe->dai_link->name);\r\ndpcm_set_fe_update_state(fe, stream, SND_SOC_DPCM_UPDATE_FE);\r\nif (list_empty(&fe->dpcm[stream].be_clients)) {\r\ndev_err(fe->dev, "ASoC: no backend DAIs enabled for %s\n",\r\nfe->dai_link->name);\r\nret = -EINVAL;\r\ngoto out;\r\n}\r\nret = dpcm_be_dai_prepare(fe, substream->stream);\r\nif (ret < 0)\r\ngoto out;\r\nret = soc_pcm_prepare(substream);\r\nif (ret < 0) {\r\ndev_err(fe->dev,"ASoC: prepare FE %s failed\n",\r\nfe->dai_link->name);\r\ngoto out;\r\n}\r\ndpcm_dapm_stream_event(fe, stream, SND_SOC_DAPM_STREAM_START);\r\nfe->dpcm[stream].state = SND_SOC_DPCM_STATE_PREPARE;\r\nout:\r\ndpcm_set_fe_update_state(fe, stream, SND_SOC_DPCM_UPDATE_NO);\r\nmutex_unlock(&fe->card->mutex);\r\nreturn ret;\r\n}\r\nstatic int soc_pcm_ioctl(struct snd_pcm_substream *substream,\r\nunsigned int cmd, void *arg)\r\n{\r\nstruct snd_soc_pcm_runtime *rtd = substream->private_data;\r\nstruct snd_soc_platform *platform = rtd->platform;\r\nif (platform->driver->ops && platform->driver->ops->ioctl)\r\nreturn platform->driver->ops->ioctl(substream, cmd, arg);\r\nreturn snd_pcm_lib_ioctl(substream, cmd, arg);\r\n}\r\nstatic int dpcm_run_update_shutdown(struct snd_soc_pcm_runtime *fe, int stream)\r\n{\r\nstruct snd_pcm_substream *substream =\r\nsnd_soc_dpcm_get_substream(fe, stream);\r\nenum snd_soc_dpcm_trigger trigger = fe->dai_link->trigger[stream];\r\nint err;\r\ndev_dbg(fe->dev, "ASoC: runtime %s close on FE %s\n",\r\nstream ? "capture" : "playback", fe->dai_link->name);\r\nif (trigger == SND_SOC_DPCM_TRIGGER_BESPOKE) {\r\ndev_dbg(fe->dev, "ASoC: bespoke trigger FE %s cmd stop\n",\r\nfe->dai_link->name);\r\nerr = soc_pcm_bespoke_trigger(substream, SNDRV_PCM_TRIGGER_STOP);\r\nif (err < 0)\r\ndev_err(fe->dev,"ASoC: trigger FE failed %d\n", err);\r\n} else {\r\ndev_dbg(fe->dev, "ASoC: trigger FE %s cmd stop\n",\r\nfe->dai_link->name);\r\nerr = dpcm_be_dai_trigger(fe, stream, SNDRV_PCM_TRIGGER_STOP);\r\nif (err < 0)\r\ndev_err(fe->dev,"ASoC: trigger FE failed %d\n", err);\r\n}\r\nerr = dpcm_be_dai_hw_free(fe, stream);\r\nif (err < 0)\r\ndev_err(fe->dev,"ASoC: hw_free FE failed %d\n", err);\r\nerr = dpcm_be_dai_shutdown(fe, stream);\r\nif (err < 0)\r\ndev_err(fe->dev,"ASoC: shutdown FE failed %d\n", err);\r\ndpcm_dapm_stream_event(fe, stream, SND_SOC_DAPM_STREAM_NOP);\r\nreturn 0;\r\n}\r\nstatic int dpcm_run_update_startup(struct snd_soc_pcm_runtime *fe, int stream)\r\n{\r\nstruct snd_pcm_substream *substream =\r\nsnd_soc_dpcm_get_substream(fe, stream);\r\nstruct snd_soc_dpcm *dpcm;\r\nenum snd_soc_dpcm_trigger trigger = fe->dai_link->trigger[stream];\r\nint ret;\r\ndev_dbg(fe->dev, "ASoC: runtime %s open on FE %s\n",\r\nstream ? "capture" : "playback", fe->dai_link->name);\r\nif (fe->dpcm[stream].state == SND_SOC_DPCM_STATE_HW_FREE ||\r\nfe->dpcm[stream].state == SND_SOC_DPCM_STATE_CLOSE)\r\nreturn -EINVAL;\r\nret = dpcm_be_dai_startup(fe, stream);\r\nif (ret < 0)\r\ngoto disconnect;\r\nif (fe->dpcm[stream].state == SND_SOC_DPCM_STATE_OPEN)\r\nreturn 0;\r\nret = dpcm_be_dai_hw_params(fe, stream);\r\nif (ret < 0)\r\ngoto close;\r\nif (fe->dpcm[stream].state == SND_SOC_DPCM_STATE_HW_PARAMS)\r\nreturn 0;\r\nret = dpcm_be_dai_prepare(fe, stream);\r\nif (ret < 0)\r\ngoto hw_free;\r\ndpcm_dapm_stream_event(fe, stream, SND_SOC_DAPM_STREAM_NOP);\r\nif (fe->dpcm[stream].state == SND_SOC_DPCM_STATE_PREPARE ||\r\nfe->dpcm[stream].state == SND_SOC_DPCM_STATE_STOP)\r\nreturn 0;\r\nif (trigger == SND_SOC_DPCM_TRIGGER_BESPOKE) {\r\ndev_dbg(fe->dev, "ASoC: bespoke trigger FE %s cmd start\n",\r\nfe->dai_link->name);\r\nret = soc_pcm_bespoke_trigger(substream, SNDRV_PCM_TRIGGER_START);\r\nif (ret < 0) {\r\ndev_err(fe->dev,"ASoC: bespoke trigger FE failed %d\n", ret);\r\ngoto hw_free;\r\n}\r\n} else {\r\ndev_dbg(fe->dev, "ASoC: trigger FE %s cmd start\n",\r\nfe->dai_link->name);\r\nret = dpcm_be_dai_trigger(fe, stream,\r\nSNDRV_PCM_TRIGGER_START);\r\nif (ret < 0) {\r\ndev_err(fe->dev,"ASoC: trigger FE failed %d\n", ret);\r\ngoto hw_free;\r\n}\r\n}\r\nreturn 0;\r\nhw_free:\r\ndpcm_be_dai_hw_free(fe, stream);\r\nclose:\r\ndpcm_be_dai_shutdown(fe, stream);\r\ndisconnect:\r\nlist_for_each_entry(dpcm, &fe->dpcm[stream].be_clients, list_be) {\r\nstruct snd_soc_pcm_runtime *be = dpcm->be;\r\nif (be->dpcm[stream].state != SND_SOC_DPCM_STATE_START)\r\ndpcm->state = SND_SOC_DPCM_LINK_STATE_FREE;\r\n}\r\nreturn ret;\r\n}\r\nstatic int dpcm_run_new_update(struct snd_soc_pcm_runtime *fe, int stream)\r\n{\r\nint ret;\r\ndpcm_set_fe_update_state(fe, stream, SND_SOC_DPCM_UPDATE_BE);\r\nret = dpcm_run_update_startup(fe, stream);\r\nif (ret < 0)\r\ndev_err(fe->dev, "ASoC: failed to startup some BEs\n");\r\ndpcm_set_fe_update_state(fe, stream, SND_SOC_DPCM_UPDATE_NO);\r\nreturn ret;\r\n}\r\nstatic int dpcm_run_old_update(struct snd_soc_pcm_runtime *fe, int stream)\r\n{\r\nint ret;\r\ndpcm_set_fe_update_state(fe, stream, SND_SOC_DPCM_UPDATE_BE);\r\nret = dpcm_run_update_shutdown(fe, stream);\r\nif (ret < 0)\r\ndev_err(fe->dev, "ASoC: failed to shutdown some BEs\n");\r\ndpcm_set_fe_update_state(fe, stream, SND_SOC_DPCM_UPDATE_NO);\r\nreturn ret;\r\n}\r\nint soc_dpcm_runtime_update(struct snd_soc_card *card)\r\n{\r\nstruct snd_soc_pcm_runtime *fe;\r\nint old, new, paths;\r\nmutex_lock_nested(&card->mutex, SND_SOC_CARD_CLASS_RUNTIME);\r\nlist_for_each_entry(fe, &card->rtd_list, list) {\r\nstruct snd_soc_dapm_widget_list *list;\r\nif (!fe->dai_link->dynamic)\r\ncontinue;\r\nif (!fe->cpu_dai->active)\r\ncontinue;\r\ndev_dbg(fe->dev, "ASoC: DPCM runtime update for FE %s\n",\r\nfe->dai_link->name);\r\nif (!fe->cpu_dai->driver->playback.channels_min\r\n|| !fe->codec_dai->driver->playback.channels_min)\r\ngoto capture;\r\nif (!fe->cpu_dai->playback_active\r\n|| !fe->codec_dai->playback_active)\r\ngoto capture;\r\npaths = dpcm_path_get(fe, SNDRV_PCM_STREAM_PLAYBACK, &list);\r\nif (paths < 0) {\r\ndev_warn(fe->dev, "ASoC: %s no valid %s path\n",\r\nfe->dai_link->name, "playback");\r\nmutex_unlock(&card->mutex);\r\nreturn paths;\r\n}\r\nnew = dpcm_process_paths(fe, SNDRV_PCM_STREAM_PLAYBACK, &list, 1);\r\nif (new) {\r\ndpcm_run_new_update(fe, SNDRV_PCM_STREAM_PLAYBACK);\r\ndpcm_clear_pending_state(fe, SNDRV_PCM_STREAM_PLAYBACK);\r\ndpcm_be_disconnect(fe, SNDRV_PCM_STREAM_PLAYBACK);\r\n}\r\nold = dpcm_process_paths(fe, SNDRV_PCM_STREAM_PLAYBACK, &list, 0);\r\nif (old) {\r\ndpcm_run_old_update(fe, SNDRV_PCM_STREAM_PLAYBACK);\r\ndpcm_clear_pending_state(fe, SNDRV_PCM_STREAM_PLAYBACK);\r\ndpcm_be_disconnect(fe, SNDRV_PCM_STREAM_PLAYBACK);\r\n}\r\ndpcm_path_put(&list);\r\ncapture:\r\nif (!fe->cpu_dai->driver->capture.channels_min\r\n|| !fe->codec_dai->driver->capture.channels_min)\r\ncontinue;\r\nif (!fe->cpu_dai->capture_active\r\n|| !fe->codec_dai->capture_active)\r\ncontinue;\r\npaths = dpcm_path_get(fe, SNDRV_PCM_STREAM_CAPTURE, &list);\r\nif (paths < 0) {\r\ndev_warn(fe->dev, "ASoC: %s no valid %s path\n",\r\nfe->dai_link->name, "capture");\r\nmutex_unlock(&card->mutex);\r\nreturn paths;\r\n}\r\nnew = dpcm_process_paths(fe, SNDRV_PCM_STREAM_CAPTURE, &list, 1);\r\nif (new) {\r\ndpcm_run_new_update(fe, SNDRV_PCM_STREAM_CAPTURE);\r\ndpcm_clear_pending_state(fe, SNDRV_PCM_STREAM_CAPTURE);\r\ndpcm_be_disconnect(fe, SNDRV_PCM_STREAM_CAPTURE);\r\n}\r\nold = dpcm_process_paths(fe, SNDRV_PCM_STREAM_CAPTURE, &list, 0);\r\nif (old) {\r\ndpcm_run_old_update(fe, SNDRV_PCM_STREAM_CAPTURE);\r\ndpcm_clear_pending_state(fe, SNDRV_PCM_STREAM_CAPTURE);\r\ndpcm_be_disconnect(fe, SNDRV_PCM_STREAM_CAPTURE);\r\n}\r\ndpcm_path_put(&list);\r\n}\r\nmutex_unlock(&card->mutex);\r\nreturn 0;\r\n}\r\nint soc_dpcm_be_digital_mute(struct snd_soc_pcm_runtime *fe, int mute)\r\n{\r\nstruct snd_soc_dpcm *dpcm;\r\nstruct list_head *clients =\r\n&fe->dpcm[SNDRV_PCM_STREAM_PLAYBACK].be_clients;\r\nlist_for_each_entry(dpcm, clients, list_be) {\r\nstruct snd_soc_pcm_runtime *be = dpcm->be;\r\nint i;\r\nif (be->dai_link->ignore_suspend)\r\ncontinue;\r\nfor (i = 0; i < be->num_codecs; i++) {\r\nstruct snd_soc_dai *dai = be->codec_dais[i];\r\nstruct snd_soc_dai_driver *drv = dai->driver;\r\ndev_dbg(be->dev, "ASoC: BE digital mute %s\n",\r\nbe->dai_link->name);\r\nif (drv->ops && drv->ops->digital_mute &&\r\ndai->playback_active)\r\ndrv->ops->digital_mute(dai, mute);\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int dpcm_fe_dai_open(struct snd_pcm_substream *fe_substream)\r\n{\r\nstruct snd_soc_pcm_runtime *fe = fe_substream->private_data;\r\nstruct snd_soc_dpcm *dpcm;\r\nstruct snd_soc_dapm_widget_list *list;\r\nint ret;\r\nint stream = fe_substream->stream;\r\nmutex_lock_nested(&fe->card->mutex, SND_SOC_CARD_CLASS_RUNTIME);\r\nfe->dpcm[stream].runtime = fe_substream->runtime;\r\nret = dpcm_path_get(fe, stream, &list);\r\nif (ret < 0) {\r\nmutex_unlock(&fe->card->mutex);\r\nreturn ret;\r\n} else if (ret == 0) {\r\ndev_dbg(fe->dev, "ASoC: %s no valid %s route\n",\r\nfe->dai_link->name, stream ? "capture" : "playback");\r\n}\r\ndpcm_process_paths(fe, stream, &list, 1);\r\nret = dpcm_fe_dai_startup(fe_substream);\r\nif (ret < 0) {\r\nlist_for_each_entry(dpcm, &fe->dpcm[stream].be_clients, list_be)\r\ndpcm->state = SND_SOC_DPCM_LINK_STATE_FREE;\r\ndpcm_be_disconnect(fe, stream);\r\nfe->dpcm[stream].runtime = NULL;\r\n}\r\ndpcm_clear_pending_state(fe, stream);\r\ndpcm_path_put(&list);\r\nmutex_unlock(&fe->card->mutex);\r\nreturn ret;\r\n}\r\nstatic int dpcm_fe_dai_close(struct snd_pcm_substream *fe_substream)\r\n{\r\nstruct snd_soc_pcm_runtime *fe = fe_substream->private_data;\r\nstruct snd_soc_dpcm *dpcm;\r\nint stream = fe_substream->stream, ret;\r\nmutex_lock_nested(&fe->card->mutex, SND_SOC_CARD_CLASS_RUNTIME);\r\nret = dpcm_fe_dai_shutdown(fe_substream);\r\nlist_for_each_entry(dpcm, &fe->dpcm[stream].be_clients, list_be)\r\ndpcm->state = SND_SOC_DPCM_LINK_STATE_FREE;\r\ndpcm_be_disconnect(fe, stream);\r\nfe->dpcm[stream].runtime = NULL;\r\nmutex_unlock(&fe->card->mutex);\r\nreturn ret;\r\n}\r\nint soc_new_pcm(struct snd_soc_pcm_runtime *rtd, int num)\r\n{\r\nstruct snd_soc_platform *platform = rtd->platform;\r\nstruct snd_soc_dai *codec_dai;\r\nstruct snd_soc_dai *cpu_dai = rtd->cpu_dai;\r\nstruct snd_pcm *pcm;\r\nchar new_name[64];\r\nint ret = 0, playback = 0, capture = 0;\r\nint i;\r\nif (rtd->dai_link->dynamic || rtd->dai_link->no_pcm) {\r\nplayback = rtd->dai_link->dpcm_playback;\r\ncapture = rtd->dai_link->dpcm_capture;\r\n} else {\r\nfor (i = 0; i < rtd->num_codecs; i++) {\r\ncodec_dai = rtd->codec_dais[i];\r\nif (codec_dai->driver->playback.channels_min)\r\nplayback = 1;\r\nif (codec_dai->driver->capture.channels_min)\r\ncapture = 1;\r\n}\r\ncapture = capture && cpu_dai->driver->capture.channels_min;\r\nplayback = playback && cpu_dai->driver->playback.channels_min;\r\n}\r\nif (rtd->dai_link->playback_only) {\r\nplayback = 1;\r\ncapture = 0;\r\n}\r\nif (rtd->dai_link->capture_only) {\r\nplayback = 0;\r\ncapture = 1;\r\n}\r\nif (rtd->dai_link->no_pcm) {\r\nsnprintf(new_name, sizeof(new_name), "(%s)",\r\nrtd->dai_link->stream_name);\r\nret = snd_pcm_new_internal(rtd->card->snd_card, new_name, num,\r\nplayback, capture, &pcm);\r\n} else {\r\nif (rtd->dai_link->dynamic)\r\nsnprintf(new_name, sizeof(new_name), "%s (*)",\r\nrtd->dai_link->stream_name);\r\nelse\r\nsnprintf(new_name, sizeof(new_name), "%s %s-%d",\r\nrtd->dai_link->stream_name,\r\n(rtd->num_codecs > 1) ?\r\n"multicodec" : rtd->codec_dai->name, num);\r\nret = snd_pcm_new(rtd->card->snd_card, new_name, num, playback,\r\ncapture, &pcm);\r\n}\r\nif (ret < 0) {\r\ndev_err(rtd->card->dev, "ASoC: can't create pcm for %s\n",\r\nrtd->dai_link->name);\r\nreturn ret;\r\n}\r\ndev_dbg(rtd->card->dev, "ASoC: registered pcm #%d %s\n",num, new_name);\r\nINIT_DELAYED_WORK(&rtd->delayed_work, close_delayed_work);\r\npcm->nonatomic = rtd->dai_link->nonatomic;\r\nrtd->pcm = pcm;\r\npcm->private_data = rtd;\r\nif (rtd->dai_link->no_pcm) {\r\nif (playback)\r\npcm->streams[SNDRV_PCM_STREAM_PLAYBACK].substream->private_data = rtd;\r\nif (capture)\r\npcm->streams[SNDRV_PCM_STREAM_CAPTURE].substream->private_data = rtd;\r\ngoto out;\r\n}\r\nif (rtd->dai_link->dynamic) {\r\nrtd->ops.open = dpcm_fe_dai_open;\r\nrtd->ops.hw_params = dpcm_fe_dai_hw_params;\r\nrtd->ops.prepare = dpcm_fe_dai_prepare;\r\nrtd->ops.trigger = dpcm_fe_dai_trigger;\r\nrtd->ops.hw_free = dpcm_fe_dai_hw_free;\r\nrtd->ops.close = dpcm_fe_dai_close;\r\nrtd->ops.pointer = soc_pcm_pointer;\r\nrtd->ops.ioctl = soc_pcm_ioctl;\r\n} else {\r\nrtd->ops.open = soc_pcm_open;\r\nrtd->ops.hw_params = soc_pcm_hw_params;\r\nrtd->ops.prepare = soc_pcm_prepare;\r\nrtd->ops.trigger = soc_pcm_trigger;\r\nrtd->ops.hw_free = soc_pcm_hw_free;\r\nrtd->ops.close = soc_pcm_close;\r\nrtd->ops.pointer = soc_pcm_pointer;\r\nrtd->ops.ioctl = soc_pcm_ioctl;\r\n}\r\nif (platform->driver->ops) {\r\nrtd->ops.ack = platform->driver->ops->ack;\r\nrtd->ops.copy = platform->driver->ops->copy;\r\nrtd->ops.silence = platform->driver->ops->silence;\r\nrtd->ops.page = platform->driver->ops->page;\r\nrtd->ops.mmap = platform->driver->ops->mmap;\r\n}\r\nif (playback)\r\nsnd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_PLAYBACK, &rtd->ops);\r\nif (capture)\r\nsnd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_CAPTURE, &rtd->ops);\r\nif (platform->driver->pcm_new) {\r\nret = platform->driver->pcm_new(rtd);\r\nif (ret < 0) {\r\ndev_err(platform->dev,\r\n"ASoC: pcm constructor failed: %d\n",\r\nret);\r\nreturn ret;\r\n}\r\n}\r\npcm->private_free = platform->driver->pcm_free;\r\nout:\r\ndev_info(rtd->card->dev, "%s <-> %s mapping ok\n",\r\n(rtd->num_codecs > 1) ? "multicodec" : rtd->codec_dai->name,\r\ncpu_dai->name);\r\nreturn ret;\r\n}\r\nint snd_soc_dpcm_fe_can_update(struct snd_soc_pcm_runtime *fe, int stream)\r\n{\r\nif (fe->dpcm[stream].runtime_update == SND_SOC_DPCM_UPDATE_FE)\r\nreturn 1;\r\nreturn 0;\r\n}\r\nint snd_soc_dpcm_be_can_update(struct snd_soc_pcm_runtime *fe,\r\nstruct snd_soc_pcm_runtime *be, int stream)\r\n{\r\nif ((fe->dpcm[stream].runtime_update == SND_SOC_DPCM_UPDATE_FE) ||\r\n((fe->dpcm[stream].runtime_update == SND_SOC_DPCM_UPDATE_BE) &&\r\nbe->dpcm[stream].runtime_update))\r\nreturn 1;\r\nreturn 0;\r\n}\r\nstruct snd_pcm_substream *\r\nsnd_soc_dpcm_get_substream(struct snd_soc_pcm_runtime *be, int stream)\r\n{\r\nreturn be->pcm->streams[stream].substream;\r\n}\r\nenum snd_soc_dpcm_state\r\nsnd_soc_dpcm_be_get_state(struct snd_soc_pcm_runtime *be, int stream)\r\n{\r\nreturn be->dpcm[stream].state;\r\n}\r\nvoid snd_soc_dpcm_be_set_state(struct snd_soc_pcm_runtime *be,\r\nint stream, enum snd_soc_dpcm_state state)\r\n{\r\nbe->dpcm[stream].state = state;\r\n}\r\nint snd_soc_dpcm_can_be_free_stop(struct snd_soc_pcm_runtime *fe,\r\nstruct snd_soc_pcm_runtime *be, int stream)\r\n{\r\nstruct snd_soc_dpcm *dpcm;\r\nint state;\r\nlist_for_each_entry(dpcm, &be->dpcm[stream].fe_clients, list_fe) {\r\nif (dpcm->fe == fe)\r\ncontinue;\r\nstate = dpcm->fe->dpcm[stream].state;\r\nif (state == SND_SOC_DPCM_STATE_START ||\r\nstate == SND_SOC_DPCM_STATE_PAUSED ||\r\nstate == SND_SOC_DPCM_STATE_SUSPEND)\r\nreturn 0;\r\n}\r\nreturn 1;\r\n}\r\nint snd_soc_dpcm_can_be_params(struct snd_soc_pcm_runtime *fe,\r\nstruct snd_soc_pcm_runtime *be, int stream)\r\n{\r\nstruct snd_soc_dpcm *dpcm;\r\nint state;\r\nlist_for_each_entry(dpcm, &be->dpcm[stream].fe_clients, list_fe) {\r\nif (dpcm->fe == fe)\r\ncontinue;\r\nstate = dpcm->fe->dpcm[stream].state;\r\nif (state == SND_SOC_DPCM_STATE_START ||\r\nstate == SND_SOC_DPCM_STATE_PAUSED ||\r\nstate == SND_SOC_DPCM_STATE_SUSPEND ||\r\nstate == SND_SOC_DPCM_STATE_PREPARE)\r\nreturn 0;\r\n}\r\nreturn 1;\r\n}\r\nint snd_soc_platform_trigger(struct snd_pcm_substream *substream,\r\nint cmd, struct snd_soc_platform *platform)\r\n{\r\nif (platform->driver->ops && platform->driver->ops->trigger)\r\nreturn platform->driver->ops->trigger(substream, cmd);\r\nreturn 0;\r\n}\r\nstatic char *dpcm_state_string(enum snd_soc_dpcm_state state)\r\n{\r\nswitch (state) {\r\ncase SND_SOC_DPCM_STATE_NEW:\r\nreturn "new";\r\ncase SND_SOC_DPCM_STATE_OPEN:\r\nreturn "open";\r\ncase SND_SOC_DPCM_STATE_HW_PARAMS:\r\nreturn "hw_params";\r\ncase SND_SOC_DPCM_STATE_PREPARE:\r\nreturn "prepare";\r\ncase SND_SOC_DPCM_STATE_START:\r\nreturn "start";\r\ncase SND_SOC_DPCM_STATE_STOP:\r\nreturn "stop";\r\ncase SND_SOC_DPCM_STATE_SUSPEND:\r\nreturn "suspend";\r\ncase SND_SOC_DPCM_STATE_PAUSED:\r\nreturn "paused";\r\ncase SND_SOC_DPCM_STATE_HW_FREE:\r\nreturn "hw_free";\r\ncase SND_SOC_DPCM_STATE_CLOSE:\r\nreturn "close";\r\n}\r\nreturn "unknown";\r\n}\r\nstatic ssize_t dpcm_show_state(struct snd_soc_pcm_runtime *fe,\r\nint stream, char *buf, size_t size)\r\n{\r\nstruct snd_pcm_hw_params *params = &fe->dpcm[stream].hw_params;\r\nstruct snd_soc_dpcm *dpcm;\r\nssize_t offset = 0;\r\noffset += snprintf(buf + offset, size - offset,\r\n"[%s - %s]\n", fe->dai_link->name,\r\nstream ? "Capture" : "Playback");\r\noffset += snprintf(buf + offset, size - offset, "State: %s\n",\r\ndpcm_state_string(fe->dpcm[stream].state));\r\nif ((fe->dpcm[stream].state >= SND_SOC_DPCM_STATE_HW_PARAMS) &&\r\n(fe->dpcm[stream].state <= SND_SOC_DPCM_STATE_STOP))\r\noffset += snprintf(buf + offset, size - offset,\r\n"Hardware Params: "\r\n"Format = %s, Channels = %d, Rate = %d\n",\r\nsnd_pcm_format_name(params_format(params)),\r\nparams_channels(params),\r\nparams_rate(params));\r\noffset += snprintf(buf + offset, size - offset, "Backends:\n");\r\nif (list_empty(&fe->dpcm[stream].be_clients)) {\r\noffset += snprintf(buf + offset, size - offset,\r\n" No active DSP links\n");\r\ngoto out;\r\n}\r\nlist_for_each_entry(dpcm, &fe->dpcm[stream].be_clients, list_be) {\r\nstruct snd_soc_pcm_runtime *be = dpcm->be;\r\nparams = &dpcm->hw_params;\r\noffset += snprintf(buf + offset, size - offset,\r\n"- %s\n", be->dai_link->name);\r\noffset += snprintf(buf + offset, size - offset,\r\n" State: %s\n",\r\ndpcm_state_string(be->dpcm[stream].state));\r\nif ((be->dpcm[stream].state >= SND_SOC_DPCM_STATE_HW_PARAMS) &&\r\n(be->dpcm[stream].state <= SND_SOC_DPCM_STATE_STOP))\r\noffset += snprintf(buf + offset, size - offset,\r\n" Hardware Params: "\r\n"Format = %s, Channels = %d, Rate = %d\n",\r\nsnd_pcm_format_name(params_format(params)),\r\nparams_channels(params),\r\nparams_rate(params));\r\n}\r\nout:\r\nreturn offset;\r\n}\r\nstatic ssize_t dpcm_state_read_file(struct file *file, char __user *user_buf,\r\nsize_t count, loff_t *ppos)\r\n{\r\nstruct snd_soc_pcm_runtime *fe = file->private_data;\r\nssize_t out_count = PAGE_SIZE, offset = 0, ret = 0;\r\nchar *buf;\r\nbuf = kmalloc(out_count, GFP_KERNEL);\r\nif (!buf)\r\nreturn -ENOMEM;\r\nif (fe->cpu_dai->driver->playback.channels_min)\r\noffset += dpcm_show_state(fe, SNDRV_PCM_STREAM_PLAYBACK,\r\nbuf + offset, out_count - offset);\r\nif (fe->cpu_dai->driver->capture.channels_min)\r\noffset += dpcm_show_state(fe, SNDRV_PCM_STREAM_CAPTURE,\r\nbuf + offset, out_count - offset);\r\nret = simple_read_from_buffer(user_buf, count, ppos, buf, offset);\r\nkfree(buf);\r\nreturn ret;\r\n}\r\nvoid soc_dpcm_debugfs_add(struct snd_soc_pcm_runtime *rtd)\r\n{\r\nif (!rtd->dai_link)\r\nreturn;\r\nif (!rtd->card->debugfs_card_root)\r\nreturn;\r\nrtd->debugfs_dpcm_root = debugfs_create_dir(rtd->dai_link->name,\r\nrtd->card->debugfs_card_root);\r\nif (!rtd->debugfs_dpcm_root) {\r\ndev_dbg(rtd->dev,\r\n"ASoC: Failed to create dpcm debugfs directory %s\n",\r\nrtd->dai_link->name);\r\nreturn;\r\n}\r\nrtd->debugfs_dpcm_state = debugfs_create_file("state", 0444,\r\nrtd->debugfs_dpcm_root,\r\nrtd, &dpcm_state_fops);\r\n}
