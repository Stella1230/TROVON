static const struct xenbus_device_id *\r\nmatch_device(const struct xenbus_device_id *arr, struct xenbus_device *dev)\r\n{\r\nfor (; *arr->devicetype != '\0'; arr++) {\r\nif (!strcmp(arr->devicetype, dev->devicetype))\r\nreturn arr;\r\n}\r\nreturn NULL;\r\n}\r\nint xenbus_match(struct device *_dev, struct device_driver *_drv)\r\n{\r\nstruct xenbus_driver *drv = to_xenbus_driver(_drv);\r\nif (!drv->ids)\r\nreturn 0;\r\nreturn match_device(drv->ids, to_xenbus_device(_dev)) != NULL;\r\n}\r\nstatic void free_otherend_details(struct xenbus_device *dev)\r\n{\r\nkfree(dev->otherend);\r\ndev->otherend = NULL;\r\n}\r\nstatic void free_otherend_watch(struct xenbus_device *dev)\r\n{\r\nif (dev->otherend_watch.node) {\r\nunregister_xenbus_watch(&dev->otherend_watch);\r\nkfree(dev->otherend_watch.node);\r\ndev->otherend_watch.node = NULL;\r\n}\r\n}\r\nstatic int talk_to_otherend(struct xenbus_device *dev)\r\n{\r\nstruct xenbus_driver *drv = to_xenbus_driver(dev->dev.driver);\r\nfree_otherend_watch(dev);\r\nfree_otherend_details(dev);\r\nreturn drv->read_otherend_details(dev);\r\n}\r\nstatic int watch_otherend(struct xenbus_device *dev)\r\n{\r\nstruct xen_bus_type *bus =\r\ncontainer_of(dev->dev.bus, struct xen_bus_type, bus);\r\nreturn xenbus_watch_pathfmt(dev, &dev->otherend_watch,\r\nbus->otherend_changed,\r\n"%s/%s", dev->otherend, "state");\r\n}\r\nint xenbus_read_otherend_details(struct xenbus_device *xendev,\r\nchar *id_node, char *path_node)\r\n{\r\nint err = xenbus_gather(XBT_NIL, xendev->nodename,\r\nid_node, "%i", &xendev->otherend_id,\r\npath_node, NULL, &xendev->otherend,\r\nNULL);\r\nif (err) {\r\nxenbus_dev_fatal(xendev, err,\r\n"reading other end details from %s",\r\nxendev->nodename);\r\nreturn err;\r\n}\r\nif (strlen(xendev->otherend) == 0 ||\r\n!xenbus_exists(XBT_NIL, xendev->otherend, "")) {\r\nxenbus_dev_fatal(xendev, -ENOENT,\r\n"unable to read other end from %s. "\r\n"missing or inaccessible.",\r\nxendev->nodename);\r\nfree_otherend_details(xendev);\r\nreturn -ENOENT;\r\n}\r\nreturn 0;\r\n}\r\nvoid xenbus_otherend_changed(struct xenbus_watch *watch,\r\nconst char **vec, unsigned int len,\r\nint ignore_on_shutdown)\r\n{\r\nstruct xenbus_device *dev =\r\ncontainer_of(watch, struct xenbus_device, otherend_watch);\r\nstruct xenbus_driver *drv = to_xenbus_driver(dev->dev.driver);\r\nenum xenbus_state state;\r\nif (!dev->otherend ||\r\nstrncmp(dev->otherend, vec[XS_WATCH_PATH],\r\nstrlen(dev->otherend))) {\r\ndev_dbg(&dev->dev, "Ignoring watch at %s\n",\r\nvec[XS_WATCH_PATH]);\r\nreturn;\r\n}\r\nstate = xenbus_read_driver_state(dev->otherend);\r\ndev_dbg(&dev->dev, "state is %d, (%s), %s, %s\n",\r\nstate, xenbus_strstate(state), dev->otherend_watch.node,\r\nvec[XS_WATCH_PATH]);\r\nif (system_state > SYSTEM_RUNNING) {\r\nif (ignore_on_shutdown && (state == XenbusStateClosing))\r\nxenbus_frontend_closed(dev);\r\nreturn;\r\n}\r\nif (drv->otherend_changed)\r\ndrv->otherend_changed(dev, state);\r\n}\r\nint xenbus_dev_probe(struct device *_dev)\r\n{\r\nstruct xenbus_device *dev = to_xenbus_device(_dev);\r\nstruct xenbus_driver *drv = to_xenbus_driver(_dev->driver);\r\nconst struct xenbus_device_id *id;\r\nint err;\r\nDPRINTK("%s", dev->nodename);\r\nif (!drv->probe) {\r\nerr = -ENODEV;\r\ngoto fail;\r\n}\r\nid = match_device(drv->ids, dev);\r\nif (!id) {\r\nerr = -ENODEV;\r\ngoto fail;\r\n}\r\nerr = talk_to_otherend(dev);\r\nif (err) {\r\ndev_warn(&dev->dev, "talk_to_otherend on %s failed.\n",\r\ndev->nodename);\r\nreturn err;\r\n}\r\nerr = drv->probe(dev, id);\r\nif (err)\r\ngoto fail;\r\nerr = watch_otherend(dev);\r\nif (err) {\r\ndev_warn(&dev->dev, "watch_otherend on %s failed.\n",\r\ndev->nodename);\r\nreturn err;\r\n}\r\nreturn 0;\r\nfail:\r\nxenbus_dev_error(dev, err, "xenbus_dev_probe on %s", dev->nodename);\r\nxenbus_switch_state(dev, XenbusStateClosed);\r\nreturn err;\r\n}\r\nint xenbus_dev_remove(struct device *_dev)\r\n{\r\nstruct xenbus_device *dev = to_xenbus_device(_dev);\r\nstruct xenbus_driver *drv = to_xenbus_driver(_dev->driver);\r\nDPRINTK("%s", dev->nodename);\r\nfree_otherend_watch(dev);\r\nif (drv->remove)\r\ndrv->remove(dev);\r\nfree_otherend_details(dev);\r\nxenbus_switch_state(dev, XenbusStateClosed);\r\nreturn 0;\r\n}\r\nvoid xenbus_dev_shutdown(struct device *_dev)\r\n{\r\nstruct xenbus_device *dev = to_xenbus_device(_dev);\r\nunsigned long timeout = 5*HZ;\r\nDPRINTK("%s", dev->nodename);\r\nget_device(&dev->dev);\r\nif (dev->state != XenbusStateConnected) {\r\npr_info("%s: %s: %s != Connected, skipping\n",\r\n__func__, dev->nodename, xenbus_strstate(dev->state));\r\ngoto out;\r\n}\r\nxenbus_switch_state(dev, XenbusStateClosing);\r\ntimeout = wait_for_completion_timeout(&dev->down, timeout);\r\nif (!timeout)\r\npr_info("%s: %s timeout closing device\n",\r\n__func__, dev->nodename);\r\nout:\r\nput_device(&dev->dev);\r\n}\r\nint xenbus_register_driver_common(struct xenbus_driver *drv,\r\nstruct xen_bus_type *bus,\r\nstruct module *owner, const char *mod_name)\r\n{\r\ndrv->driver.name = drv->name ? drv->name : drv->ids[0].devicetype;\r\ndrv->driver.bus = &bus->bus;\r\ndrv->driver.owner = owner;\r\ndrv->driver.mod_name = mod_name;\r\nreturn driver_register(&drv->driver);\r\n}\r\nvoid xenbus_unregister_driver(struct xenbus_driver *drv)\r\n{\r\ndriver_unregister(&drv->driver);\r\n}\r\nstatic int cmp_dev(struct device *dev, void *data)\r\n{\r\nstruct xenbus_device *xendev = to_xenbus_device(dev);\r\nstruct xb_find_info *info = data;\r\nif (!strcmp(xendev->nodename, info->nodename)) {\r\ninfo->dev = xendev;\r\nget_device(dev);\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}\r\nstatic struct xenbus_device *xenbus_device_find(const char *nodename,\r\nstruct bus_type *bus)\r\n{\r\nstruct xb_find_info info = { .dev = NULL, .nodename = nodename };\r\nbus_for_each_dev(bus, NULL, &info, cmp_dev);\r\nreturn info.dev;\r\n}\r\nstatic int cleanup_dev(struct device *dev, void *data)\r\n{\r\nstruct xenbus_device *xendev = to_xenbus_device(dev);\r\nstruct xb_find_info *info = data;\r\nint len = strlen(info->nodename);\r\nDPRINTK("%s", info->nodename);\r\nif (strncmp(xendev->nodename, info->nodename, len))\r\nreturn 0;\r\nif ((strlen(xendev->nodename) > len) && (xendev->nodename[len] != '/'))\r\nreturn 0;\r\ninfo->dev = xendev;\r\nget_device(dev);\r\nreturn 1;\r\n}\r\nstatic void xenbus_cleanup_devices(const char *path, struct bus_type *bus)\r\n{\r\nstruct xb_find_info info = { .nodename = path };\r\ndo {\r\ninfo.dev = NULL;\r\nbus_for_each_dev(bus, NULL, &info, cleanup_dev);\r\nif (info.dev) {\r\ndevice_unregister(&info.dev->dev);\r\nput_device(&info.dev->dev);\r\n}\r\n} while (info.dev);\r\n}\r\nstatic void xenbus_dev_release(struct device *dev)\r\n{\r\nif (dev)\r\nkfree(to_xenbus_device(dev));\r\n}\r\nstatic ssize_t nodename_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nreturn sprintf(buf, "%s\n", to_xenbus_device(dev)->nodename);\r\n}\r\nstatic ssize_t devtype_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nreturn sprintf(buf, "%s\n", to_xenbus_device(dev)->devicetype);\r\n}\r\nstatic ssize_t modalias_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nreturn sprintf(buf, "%s:%s\n", dev->bus->name,\r\nto_xenbus_device(dev)->devicetype);\r\n}\r\nint xenbus_probe_node(struct xen_bus_type *bus,\r\nconst char *type,\r\nconst char *nodename)\r\n{\r\nchar devname[XEN_BUS_ID_SIZE];\r\nint err;\r\nstruct xenbus_device *xendev;\r\nsize_t stringlen;\r\nchar *tmpstring;\r\nenum xenbus_state state = xenbus_read_driver_state(nodename);\r\nif (state != XenbusStateInitialising) {\r\nreturn 0;\r\n}\r\nstringlen = strlen(nodename) + 1 + strlen(type) + 1;\r\nxendev = kzalloc(sizeof(*xendev) + stringlen, GFP_KERNEL);\r\nif (!xendev)\r\nreturn -ENOMEM;\r\nxendev->state = XenbusStateInitialising;\r\ntmpstring = (char *)(xendev + 1);\r\nstrcpy(tmpstring, nodename);\r\nxendev->nodename = tmpstring;\r\ntmpstring += strlen(tmpstring) + 1;\r\nstrcpy(tmpstring, type);\r\nxendev->devicetype = tmpstring;\r\ninit_completion(&xendev->down);\r\nxendev->dev.bus = &bus->bus;\r\nxendev->dev.release = xenbus_dev_release;\r\nerr = bus->get_bus_id(devname, xendev->nodename);\r\nif (err)\r\ngoto fail;\r\ndev_set_name(&xendev->dev, "%s", devname);\r\nerr = device_register(&xendev->dev);\r\nif (err)\r\ngoto fail;\r\nreturn 0;\r\nfail:\r\nkfree(xendev);\r\nreturn err;\r\n}\r\nstatic int xenbus_probe_device_type(struct xen_bus_type *bus, const char *type)\r\n{\r\nint err = 0;\r\nchar **dir;\r\nunsigned int dir_n = 0;\r\nint i;\r\ndir = xenbus_directory(XBT_NIL, bus->root, type, &dir_n);\r\nif (IS_ERR(dir))\r\nreturn PTR_ERR(dir);\r\nfor (i = 0; i < dir_n; i++) {\r\nerr = bus->probe(bus, type, dir[i]);\r\nif (err)\r\nbreak;\r\n}\r\nkfree(dir);\r\nreturn err;\r\n}\r\nint xenbus_probe_devices(struct xen_bus_type *bus)\r\n{\r\nint err = 0;\r\nchar **dir;\r\nunsigned int i, dir_n;\r\ndir = xenbus_directory(XBT_NIL, bus->root, "", &dir_n);\r\nif (IS_ERR(dir))\r\nreturn PTR_ERR(dir);\r\nfor (i = 0; i < dir_n; i++) {\r\nerr = xenbus_probe_device_type(bus, dir[i]);\r\nif (err)\r\nbreak;\r\n}\r\nkfree(dir);\r\nreturn err;\r\n}\r\nstatic unsigned int char_count(const char *str, char c)\r\n{\r\nunsigned int i, ret = 0;\r\nfor (i = 0; str[i]; i++)\r\nif (str[i] == c)\r\nret++;\r\nreturn ret;\r\n}\r\nstatic int strsep_len(const char *str, char c, unsigned int len)\r\n{\r\nunsigned int i;\r\nfor (i = 0; str[i]; i++)\r\nif (str[i] == c) {\r\nif (len == 0)\r\nreturn i;\r\nlen--;\r\n}\r\nreturn (len == 0) ? i : -ERANGE;\r\n}\r\nvoid xenbus_dev_changed(const char *node, struct xen_bus_type *bus)\r\n{\r\nint exists, rootlen;\r\nstruct xenbus_device *dev;\r\nchar type[XEN_BUS_ID_SIZE];\r\nconst char *p, *root;\r\nif (char_count(node, '/') < 2)\r\nreturn;\r\nexists = xenbus_exists(XBT_NIL, node, "");\r\nif (!exists) {\r\nxenbus_cleanup_devices(node, &bus->bus);\r\nreturn;\r\n}\r\np = strchr(node, '/') + 1;\r\nsnprintf(type, XEN_BUS_ID_SIZE, "%.*s", (int)strcspn(p, "/"), p);\r\ntype[XEN_BUS_ID_SIZE-1] = '\0';\r\nrootlen = strsep_len(node, '/', bus->levels);\r\nif (rootlen < 0)\r\nreturn;\r\nroot = kasprintf(GFP_KERNEL, "%.*s", rootlen, node);\r\nif (!root)\r\nreturn;\r\ndev = xenbus_device_find(root, &bus->bus);\r\nif (!dev)\r\nxenbus_probe_node(bus, type, root);\r\nelse\r\nput_device(&dev->dev);\r\nkfree(root);\r\n}\r\nint xenbus_dev_suspend(struct device *dev)\r\n{\r\nint err = 0;\r\nstruct xenbus_driver *drv;\r\nstruct xenbus_device *xdev\r\n= container_of(dev, struct xenbus_device, dev);\r\nDPRINTK("%s", xdev->nodename);\r\nif (dev->driver == NULL)\r\nreturn 0;\r\ndrv = to_xenbus_driver(dev->driver);\r\nif (drv->suspend)\r\nerr = drv->suspend(xdev);\r\nif (err)\r\npr_warn("suspend %s failed: %i\n", dev_name(dev), err);\r\nreturn 0;\r\n}\r\nint xenbus_dev_resume(struct device *dev)\r\n{\r\nint err;\r\nstruct xenbus_driver *drv;\r\nstruct xenbus_device *xdev\r\n= container_of(dev, struct xenbus_device, dev);\r\nDPRINTK("%s", xdev->nodename);\r\nif (dev->driver == NULL)\r\nreturn 0;\r\ndrv = to_xenbus_driver(dev->driver);\r\nerr = talk_to_otherend(xdev);\r\nif (err) {\r\npr_warn("resume (talk_to_otherend) %s failed: %i\n",\r\ndev_name(dev), err);\r\nreturn err;\r\n}\r\nxdev->state = XenbusStateInitialising;\r\nif (drv->resume) {\r\nerr = drv->resume(xdev);\r\nif (err) {\r\npr_warn("resume %s failed: %i\n", dev_name(dev), err);\r\nreturn err;\r\n}\r\n}\r\nerr = watch_otherend(xdev);\r\nif (err) {\r\npr_warn("resume (watch_otherend) %s failed: %d.\n",\r\ndev_name(dev), err);\r\nreturn err;\r\n}\r\nreturn 0;\r\n}\r\nint xenbus_dev_cancel(struct device *dev)\r\n{\r\nDPRINTK("cancel");\r\nreturn 0;\r\n}\r\nint register_xenstore_notifier(struct notifier_block *nb)\r\n{\r\nint ret = 0;\r\nif (xenstored_ready > 0)\r\nret = nb->notifier_call(nb, 0, NULL);\r\nelse\r\nblocking_notifier_chain_register(&xenstore_chain, nb);\r\nreturn ret;\r\n}\r\nvoid unregister_xenstore_notifier(struct notifier_block *nb)\r\n{\r\nblocking_notifier_chain_unregister(&xenstore_chain, nb);\r\n}\r\nvoid xenbus_probe(struct work_struct *unused)\r\n{\r\nxenstored_ready = 1;\r\nblocking_notifier_call_chain(&xenstore_chain, 0, NULL);\r\n}\r\nstatic int __init xenbus_probe_initcall(void)\r\n{\r\nif (!xen_domain())\r\nreturn -ENODEV;\r\nif (xen_initial_domain() || xen_hvm_domain())\r\nreturn 0;\r\nxenbus_probe(NULL);\r\nreturn 0;\r\n}\r\nstatic int __init xenstored_local_init(void)\r\n{\r\nint err = 0;\r\nunsigned long page = 0;\r\nstruct evtchn_alloc_unbound alloc_unbound;\r\npage = get_zeroed_page(GFP_KERNEL);\r\nif (!page)\r\ngoto out_err;\r\nxen_store_gfn = xen_start_info->store_mfn = virt_to_gfn((void *)page);\r\nalloc_unbound.dom = DOMID_SELF;\r\nalloc_unbound.remote_dom = DOMID_SELF;\r\nerr = HYPERVISOR_event_channel_op(EVTCHNOP_alloc_unbound,\r\n&alloc_unbound);\r\nif (err == -ENOSYS)\r\ngoto out_err;\r\nBUG_ON(err);\r\nxen_store_evtchn = xen_start_info->store_evtchn =\r\nalloc_unbound.port;\r\nreturn 0;\r\nout_err:\r\nif (page != 0)\r\nfree_page(page);\r\nreturn err;\r\n}\r\nstatic int xenbus_resume_cb(struct notifier_block *nb,\r\nunsigned long action, void *data)\r\n{\r\nint err = 0;\r\nif (xen_hvm_domain()) {\r\nuint64_t v = 0;\r\nerr = hvm_get_parameter(HVM_PARAM_STORE_EVTCHN, &v);\r\nif (!err && v)\r\nxen_store_evtchn = v;\r\nelse\r\npr_warn("Cannot update xenstore event channel: %d\n",\r\nerr);\r\n} else\r\nxen_store_evtchn = xen_start_info->store_evtchn;\r\nreturn err;\r\n}\r\nstatic int __init xenbus_init(void)\r\n{\r\nint err = 0;\r\nuint64_t v = 0;\r\nxen_store_domain_type = XS_UNKNOWN;\r\nif (!xen_domain())\r\nreturn -ENODEV;\r\nxenbus_ring_ops_init();\r\nif (xen_pv_domain())\r\nxen_store_domain_type = XS_PV;\r\nif (xen_hvm_domain())\r\nxen_store_domain_type = XS_HVM;\r\nif (xen_hvm_domain() && xen_initial_domain())\r\nxen_store_domain_type = XS_LOCAL;\r\nif (xen_pv_domain() && !xen_start_info->store_evtchn)\r\nxen_store_domain_type = XS_LOCAL;\r\nif (xen_pv_domain() && xen_start_info->store_evtchn)\r\nxenstored_ready = 1;\r\nswitch (xen_store_domain_type) {\r\ncase XS_LOCAL:\r\nerr = xenstored_local_init();\r\nif (err)\r\ngoto out_error;\r\nxen_store_interface = gfn_to_virt(xen_store_gfn);\r\nbreak;\r\ncase XS_PV:\r\nxen_store_evtchn = xen_start_info->store_evtchn;\r\nxen_store_gfn = xen_start_info->store_mfn;\r\nxen_store_interface = gfn_to_virt(xen_store_gfn);\r\nbreak;\r\ncase XS_HVM:\r\nerr = hvm_get_parameter(HVM_PARAM_STORE_EVTCHN, &v);\r\nif (err)\r\ngoto out_error;\r\nxen_store_evtchn = (int)v;\r\nerr = hvm_get_parameter(HVM_PARAM_STORE_PFN, &v);\r\nif (err)\r\ngoto out_error;\r\nxen_store_gfn = (unsigned long)v;\r\nxen_store_interface =\r\nxen_remap(xen_store_gfn << XEN_PAGE_SHIFT,\r\nXEN_PAGE_SIZE);\r\nbreak;\r\ndefault:\r\npr_warn("Xenstore state unknown\n");\r\nbreak;\r\n}\r\nerr = xs_init();\r\nif (err) {\r\npr_warn("Error initializing xenstore comms: %i\n", err);\r\ngoto out_error;\r\n}\r\nif ((xen_store_domain_type != XS_LOCAL) &&\r\n(xen_store_domain_type != XS_UNKNOWN))\r\nxen_resume_notifier_register(&xenbus_resume_nb);\r\n#ifdef CONFIG_XEN_COMPAT_XENFS\r\nproc_mkdir("xen", NULL);\r\n#endif\r\nout_error:\r\nreturn err;\r\n}
