static void rtc_delayed_write(u32 val, struct armada38x_rtc *rtc, int offset)\r\n{\r\nwritel(val, rtc->regs + offset);\r\nudelay(5);\r\n}\r\nstatic int armada38x_rtc_read_time(struct device *dev, struct rtc_time *tm)\r\n{\r\nstruct armada38x_rtc *rtc = dev_get_drvdata(dev);\r\nunsigned long time, time_check, flags;\r\nspin_lock_irqsave(&rtc->lock, flags);\r\ntime = readl(rtc->regs + RTC_TIME);\r\ntime_check = readl(rtc->regs + RTC_TIME);\r\nif ((time_check - time) > 1)\r\ntime_check = readl(rtc->regs + RTC_TIME);\r\nspin_unlock_irqrestore(&rtc->lock, flags);\r\nrtc_time_to_tm(time_check, tm);\r\nreturn 0;\r\n}\r\nstatic int armada38x_rtc_set_time(struct device *dev, struct rtc_time *tm)\r\n{\r\nstruct armada38x_rtc *rtc = dev_get_drvdata(dev);\r\nint ret = 0;\r\nunsigned long time, flags;\r\nret = rtc_tm_to_time(tm, &time);\r\nif (ret)\r\ngoto out;\r\nspin_lock_irqsave(&rtc->lock, flags);\r\nrtc_delayed_write(time, rtc, RTC_TIME);\r\nrtc_delayed_write(0, rtc, RTC_STATUS);\r\nrtc_delayed_write(0, rtc, RTC_STATUS);\r\nspin_unlock_irqrestore(&rtc->lock, flags);\r\nout:\r\nreturn ret;\r\n}\r\nstatic int armada38x_rtc_read_alarm(struct device *dev, struct rtc_wkalrm *alrm)\r\n{\r\nstruct armada38x_rtc *rtc = dev_get_drvdata(dev);\r\nunsigned long time, flags;\r\nu32 val;\r\nspin_lock_irqsave(&rtc->lock, flags);\r\ntime = readl(rtc->regs + RTC_ALARM1);\r\nval = readl(rtc->regs + RTC_IRQ1_CONF) & RTC_IRQ1_AL_EN;\r\nspin_unlock_irqrestore(&rtc->lock, flags);\r\nalrm->enabled = val ? 1 : 0;\r\nrtc_time_to_tm(time, &alrm->time);\r\nreturn 0;\r\n}\r\nstatic int armada38x_rtc_set_alarm(struct device *dev, struct rtc_wkalrm *alrm)\r\n{\r\nstruct armada38x_rtc *rtc = dev_get_drvdata(dev);\r\nunsigned long time, flags;\r\nint ret = 0;\r\nu32 val;\r\nret = rtc_tm_to_time(&alrm->time, &time);\r\nif (ret)\r\ngoto out;\r\nspin_lock_irqsave(&rtc->lock, flags);\r\nrtc_delayed_write(time, rtc, RTC_ALARM1);\r\nif (alrm->enabled) {\r\nrtc_delayed_write(RTC_IRQ1_AL_EN, rtc, RTC_IRQ1_CONF);\r\nval = readl(rtc->regs_soc + SOC_RTC_INTERRUPT);\r\nwritel(val | SOC_RTC_ALARM1_MASK,\r\nrtc->regs_soc + SOC_RTC_INTERRUPT);\r\n}\r\nspin_unlock_irqrestore(&rtc->lock, flags);\r\nout:\r\nreturn ret;\r\n}\r\nstatic int armada38x_rtc_alarm_irq_enable(struct device *dev,\r\nunsigned int enabled)\r\n{\r\nstruct armada38x_rtc *rtc = dev_get_drvdata(dev);\r\nunsigned long flags;\r\nspin_lock_irqsave(&rtc->lock, flags);\r\nif (enabled)\r\nrtc_delayed_write(RTC_IRQ1_AL_EN, rtc, RTC_IRQ1_CONF);\r\nelse\r\nrtc_delayed_write(0, rtc, RTC_IRQ1_CONF);\r\nspin_unlock_irqrestore(&rtc->lock, flags);\r\nreturn 0;\r\n}\r\nstatic irqreturn_t armada38x_rtc_alarm_irq(int irq, void *data)\r\n{\r\nstruct armada38x_rtc *rtc = data;\r\nu32 val;\r\nint event = RTC_IRQF | RTC_AF;\r\ndev_dbg(&rtc->rtc_dev->dev, "%s:irq(%d)\n", __func__, irq);\r\nspin_lock(&rtc->lock);\r\nval = readl(rtc->regs_soc + SOC_RTC_INTERRUPT);\r\nwritel(val & ~SOC_RTC_ALARM1, rtc->regs_soc + SOC_RTC_INTERRUPT);\r\nval = readl(rtc->regs + RTC_IRQ1_CONF);\r\nrtc_delayed_write(0, rtc, RTC_IRQ1_CONF);\r\nrtc_delayed_write(RTC_STATUS_ALARM1, rtc, RTC_STATUS);\r\nspin_unlock(&rtc->lock);\r\nif (val & RTC_IRQ1_FREQ_EN) {\r\nif (val & RTC_IRQ1_FREQ_1HZ)\r\nevent |= RTC_UF;\r\nelse\r\nevent |= RTC_PF;\r\n}\r\nrtc_update_irq(rtc->rtc_dev, 1, event);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic __init int armada38x_rtc_probe(struct platform_device *pdev)\r\n{\r\nstruct resource *res;\r\nstruct armada38x_rtc *rtc;\r\nint ret;\r\nrtc = devm_kzalloc(&pdev->dev, sizeof(struct armada38x_rtc),\r\nGFP_KERNEL);\r\nif (!rtc)\r\nreturn -ENOMEM;\r\nspin_lock_init(&rtc->lock);\r\nres = platform_get_resource_byname(pdev, IORESOURCE_MEM, "rtc");\r\nrtc->regs = devm_ioremap_resource(&pdev->dev, res);\r\nif (IS_ERR(rtc->regs))\r\nreturn PTR_ERR(rtc->regs);\r\nres = platform_get_resource_byname(pdev, IORESOURCE_MEM, "rtc-soc");\r\nrtc->regs_soc = devm_ioremap_resource(&pdev->dev, res);\r\nif (IS_ERR(rtc->regs_soc))\r\nreturn PTR_ERR(rtc->regs_soc);\r\nrtc->irq = platform_get_irq(pdev, 0);\r\nif (rtc->irq < 0) {\r\ndev_err(&pdev->dev, "no irq\n");\r\nreturn rtc->irq;\r\n}\r\nif (devm_request_irq(&pdev->dev, rtc->irq, armada38x_rtc_alarm_irq,\r\n0, pdev->name, rtc) < 0) {\r\ndev_warn(&pdev->dev, "Interrupt not available.\n");\r\nrtc->irq = -1;\r\narmada38x_rtc_ops.set_alarm = NULL;\r\narmada38x_rtc_ops.alarm_irq_enable = NULL;\r\n}\r\nplatform_set_drvdata(pdev, rtc);\r\nif (rtc->irq != -1)\r\ndevice_init_wakeup(&pdev->dev, 1);\r\nrtc->rtc_dev = devm_rtc_device_register(&pdev->dev, pdev->name,\r\n&armada38x_rtc_ops, THIS_MODULE);\r\nif (IS_ERR(rtc->rtc_dev)) {\r\nret = PTR_ERR(rtc->rtc_dev);\r\ndev_err(&pdev->dev, "Failed to register RTC device: %d\n", ret);\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic int armada38x_rtc_suspend(struct device *dev)\r\n{\r\nif (device_may_wakeup(dev)) {\r\nstruct armada38x_rtc *rtc = dev_get_drvdata(dev);\r\nreturn enable_irq_wake(rtc->irq);\r\n}\r\nreturn 0;\r\n}\r\nstatic int armada38x_rtc_resume(struct device *dev)\r\n{\r\nif (device_may_wakeup(dev)) {\r\nstruct armada38x_rtc *rtc = dev_get_drvdata(dev);\r\nreturn disable_irq_wake(rtc->irq);\r\n}\r\nreturn 0;\r\n}
