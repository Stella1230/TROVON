static bool migrate_one_irq(struct irq_desc *desc)\r\n{\r\nstruct irq_data *d = irq_desc_get_irq_data(desc);\r\nconst struct cpumask *affinity = d->common->affinity;\r\nstruct irq_chip *c;\r\nbool ret = false;\r\nif (irqd_is_per_cpu(d) ||\r\n!cpumask_test_cpu(smp_processor_id(), affinity))\r\nreturn false;\r\nif (cpumask_any_and(affinity, cpu_online_mask) >= nr_cpu_ids) {\r\naffinity = cpu_online_mask;\r\nret = true;\r\n}\r\nc = irq_data_get_irq_chip(d);\r\nif (!c->irq_set_affinity) {\r\npr_debug("IRQ%u: unable to set affinity\n", d->irq);\r\n} else {\r\nint r = irq_do_set_affinity(d, affinity, false);\r\nif (r)\r\npr_warn_ratelimited("IRQ%u: set affinity failed(%d).\n",\r\nd->irq, r);\r\n}\r\nreturn ret;\r\n}\r\nvoid irq_migrate_all_off_this_cpu(void)\r\n{\r\nunsigned int irq;\r\nstruct irq_desc *desc;\r\nunsigned long flags;\r\nlocal_irq_save(flags);\r\nfor_each_active_irq(irq) {\r\nbool affinity_broken;\r\ndesc = irq_to_desc(irq);\r\nraw_spin_lock(&desc->lock);\r\naffinity_broken = migrate_one_irq(desc);\r\nraw_spin_unlock(&desc->lock);\r\nif (affinity_broken)\r\npr_warn_ratelimited("IRQ%u no longer affine to CPU%u\n",\r\nirq, smp_processor_id());\r\n}\r\nlocal_irq_restore(flags);\r\n}
