static void *tpm_bios_measurements_start(struct seq_file *m, loff_t *pos)\r\n{\r\nloff_t i;\r\nstruct tpm_bios_log *log = m->private;\r\nvoid *addr = log->bios_event_log;\r\nvoid *limit = log->bios_event_log_end;\r\nstruct tcpa_event *event;\r\nu32 converted_event_size;\r\nu32 converted_event_type;\r\nfor (i = 0; i < *pos; i++) {\r\nevent = addr;\r\nconverted_event_size =\r\ndo_endian_conversion(event->event_size);\r\nconverted_event_type =\r\ndo_endian_conversion(event->event_type);\r\nif ((addr + sizeof(struct tcpa_event)) < limit) {\r\nif ((converted_event_type == 0) &&\r\n(converted_event_size == 0))\r\nreturn NULL;\r\naddr += (sizeof(struct tcpa_event) +\r\nconverted_event_size);\r\n}\r\n}\r\nif ((addr + sizeof(struct tcpa_event)) >= limit)\r\nreturn NULL;\r\nevent = addr;\r\nconverted_event_size = do_endian_conversion(event->event_size);\r\nconverted_event_type = do_endian_conversion(event->event_type);\r\nif (((converted_event_type == 0) && (converted_event_size == 0))\r\n|| ((addr + sizeof(struct tcpa_event) + converted_event_size)\r\n>= limit))\r\nreturn NULL;\r\nreturn addr;\r\n}\r\nstatic void *tpm_bios_measurements_next(struct seq_file *m, void *v,\r\nloff_t *pos)\r\n{\r\nstruct tcpa_event *event = v;\r\nstruct tpm_bios_log *log = m->private;\r\nvoid *limit = log->bios_event_log_end;\r\nu32 converted_event_size;\r\nu32 converted_event_type;\r\nconverted_event_size = do_endian_conversion(event->event_size);\r\nv += sizeof(struct tcpa_event) + converted_event_size;\r\nif ((v + sizeof(struct tcpa_event)) >= limit)\r\nreturn NULL;\r\nevent = v;\r\nconverted_event_size = do_endian_conversion(event->event_size);\r\nconverted_event_type = do_endian_conversion(event->event_type);\r\nif (((converted_event_type == 0) && (converted_event_size == 0)) ||\r\n((v + sizeof(struct tcpa_event) + converted_event_size) >= limit))\r\nreturn NULL;\r\n(*pos)++;\r\nreturn v;\r\n}\r\nstatic void tpm_bios_measurements_stop(struct seq_file *m, void *v)\r\n{\r\n}\r\nstatic int get_event_name(char *dest, struct tcpa_event *event,\r\nunsigned char * event_entry)\r\n{\r\nconst char *name = "";\r\nchar data[41] = "";\r\nint i, n_len = 0, d_len = 0;\r\nstruct tcpa_pc_event *pc_event;\r\nswitch (do_endian_conversion(event->event_type)) {\r\ncase PREBOOT:\r\ncase POST_CODE:\r\ncase UNUSED:\r\ncase NO_ACTION:\r\ncase SCRTM_CONTENTS:\r\ncase SCRTM_VERSION:\r\ncase CPU_MICROCODE:\r\ncase PLATFORM_CONFIG_FLAGS:\r\ncase TABLE_OF_DEVICES:\r\ncase COMPACT_HASH:\r\ncase IPL:\r\ncase IPL_PARTITION_DATA:\r\ncase NONHOST_CODE:\r\ncase NONHOST_CONFIG:\r\ncase NONHOST_INFO:\r\nname = tcpa_event_type_strings[do_endian_conversion\r\n(event->event_type)];\r\nn_len = strlen(name);\r\nbreak;\r\ncase SEPARATOR:\r\ncase ACTION:\r\nif (MAX_TEXT_EVENT >\r\ndo_endian_conversion(event->event_size)) {\r\nname = event_entry;\r\nn_len = do_endian_conversion(event->event_size);\r\n}\r\nbreak;\r\ncase EVENT_TAG:\r\npc_event = (struct tcpa_pc_event *)event_entry;\r\nswitch (do_endian_conversion(pc_event->event_id)) {\r\ncase SMBIOS:\r\ncase BIS_CERT:\r\ncase CMOS:\r\ncase NVRAM:\r\ncase OPTION_ROM_EXEC:\r\ncase OPTION_ROM_CONFIG:\r\ncase S_CRTM_VERSION:\r\nname = tcpa_pc_event_id_strings[do_endian_conversion\r\n(pc_event->event_id)];\r\nn_len = strlen(name);\r\nbreak;\r\ncase POST_BIOS_ROM:\r\ncase ESCD:\r\ncase OPTION_ROM_MICROCODE:\r\ncase S_CRTM_CONTENTS:\r\ncase POST_CONTENTS:\r\nname = tcpa_pc_event_id_strings[do_endian_conversion\r\n(pc_event->event_id)];\r\nn_len = strlen(name);\r\nfor (i = 0; i < 20; i++)\r\nd_len += sprintf(&data[2*i], "%02x",\r\npc_event->event_data[i]);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\ndefault:\r\nbreak;\r\n}\r\nreturn snprintf(dest, MAX_TEXT_EVENT, "[%.*s%.*s]",\r\nn_len, name, d_len, data);\r\n}\r\nstatic int tpm_binary_bios_measurements_show(struct seq_file *m, void *v)\r\n{\r\nstruct tcpa_event *event = v;\r\nstruct tcpa_event temp_event;\r\nchar *temp_ptr;\r\nint i;\r\nmemcpy(&temp_event, event, sizeof(struct tcpa_event));\r\ntemp_event.pcr_index = do_endian_conversion(event->pcr_index);\r\ntemp_event.event_type = do_endian_conversion(event->event_type);\r\ntemp_event.event_size = do_endian_conversion(event->event_size);\r\ntemp_ptr = (char *) &temp_event;\r\nfor (i = 0; i < (sizeof(struct tcpa_event) - 1) ; i++)\r\nseq_putc(m, temp_ptr[i]);\r\ntemp_ptr = (char *) v;\r\nfor (i = (sizeof(struct tcpa_event) - 1);\r\ni < (sizeof(struct tcpa_event) + temp_event.event_size); i++)\r\nseq_putc(m, temp_ptr[i]);\r\nreturn 0;\r\n}\r\nstatic int tpm_bios_measurements_release(struct inode *inode,\r\nstruct file *file)\r\n{\r\nstruct seq_file *seq = file->private_data;\r\nstruct tpm_bios_log *log = seq->private;\r\nif (log) {\r\nkfree(log->bios_event_log);\r\nkfree(log);\r\n}\r\nreturn seq_release(inode, file);\r\n}\r\nstatic int tpm_ascii_bios_measurements_show(struct seq_file *m, void *v)\r\n{\r\nint len = 0;\r\nchar *eventname;\r\nstruct tcpa_event *event = v;\r\nunsigned char *event_entry =\r\n(unsigned char *)(v + sizeof(struct tcpa_event));\r\neventname = kmalloc(MAX_TEXT_EVENT, GFP_KERNEL);\r\nif (!eventname) {\r\nprintk(KERN_ERR "%s: ERROR - No Memory for event name\n ",\r\n__func__);\r\nreturn -EFAULT;\r\n}\r\nseq_printf(m, "%2d ", do_endian_conversion(event->pcr_index));\r\nseq_printf(m, "%20phN", event->pcr_value);\r\nseq_printf(m, " %02x", do_endian_conversion(event->event_type));\r\nlen += get_event_name(eventname, event, event_entry);\r\nseq_printf(m, " %s\n", eventname);\r\nkfree(eventname);\r\nreturn 0;\r\n}\r\nstatic int tpm_ascii_bios_measurements_open(struct inode *inode,\r\nstruct file *file)\r\n{\r\nint err;\r\nstruct tpm_bios_log *log;\r\nstruct seq_file *seq;\r\nlog = kzalloc(sizeof(struct tpm_bios_log), GFP_KERNEL);\r\nif (!log)\r\nreturn -ENOMEM;\r\nif ((err = read_log(log)))\r\ngoto out_free;\r\nerr = seq_open(file, &tpm_ascii_b_measurments_seqops);\r\nif (!err) {\r\nseq = file->private_data;\r\nseq->private = log;\r\n} else {\r\ngoto out_free;\r\n}\r\nout:\r\nreturn err;\r\nout_free:\r\nkfree(log->bios_event_log);\r\nkfree(log);\r\ngoto out;\r\n}\r\nstatic int tpm_binary_bios_measurements_open(struct inode *inode,\r\nstruct file *file)\r\n{\r\nint err;\r\nstruct tpm_bios_log *log;\r\nstruct seq_file *seq;\r\nlog = kzalloc(sizeof(struct tpm_bios_log), GFP_KERNEL);\r\nif (!log)\r\nreturn -ENOMEM;\r\nif ((err = read_log(log)))\r\ngoto out_free;\r\nerr = seq_open(file, &tpm_binary_b_measurments_seqops);\r\nif (!err) {\r\nseq = file->private_data;\r\nseq->private = log;\r\n} else {\r\ngoto out_free;\r\n}\r\nout:\r\nreturn err;\r\nout_free:\r\nkfree(log->bios_event_log);\r\nkfree(log);\r\ngoto out;\r\n}\r\nstatic int is_bad(void *p)\r\n{\r\nif (!p)\r\nreturn 1;\r\nif (IS_ERR(p) && (PTR_ERR(p) != -ENODEV))\r\nreturn 1;\r\nreturn 0;\r\n}\r\nstruct dentry **tpm_bios_log_setup(char *name)\r\n{\r\nstruct dentry **ret = NULL, *tpm_dir, *bin_file, *ascii_file;\r\ntpm_dir = securityfs_create_dir(name, NULL);\r\nif (is_bad(tpm_dir))\r\ngoto out;\r\nbin_file =\r\nsecurityfs_create_file("binary_bios_measurements",\r\nS_IRUSR | S_IRGRP, tpm_dir, NULL,\r\n&tpm_binary_bios_measurements_ops);\r\nif (is_bad(bin_file))\r\ngoto out_tpm;\r\nascii_file =\r\nsecurityfs_create_file("ascii_bios_measurements",\r\nS_IRUSR | S_IRGRP, tpm_dir, NULL,\r\n&tpm_ascii_bios_measurements_ops);\r\nif (is_bad(ascii_file))\r\ngoto out_bin;\r\nret = kmalloc(3 * sizeof(struct dentry *), GFP_KERNEL);\r\nif (!ret)\r\ngoto out_ascii;\r\nret[0] = ascii_file;\r\nret[1] = bin_file;\r\nret[2] = tpm_dir;\r\nreturn ret;\r\nout_ascii:\r\nsecurityfs_remove(ascii_file);\r\nout_bin:\r\nsecurityfs_remove(bin_file);\r\nout_tpm:\r\nsecurityfs_remove(tpm_dir);\r\nout:\r\nreturn NULL;\r\n}\r\nvoid tpm_bios_log_teardown(struct dentry **lst)\r\n{\r\nint i;\r\nfor (i = 0; i < 3; i++)\r\nsecurityfs_remove(lst[i]);\r\n}
