static struct ipc_message *msg_get_empty(struct sst_generic_ipc *ipc)\r\n{\r\nstruct ipc_message *msg = NULL;\r\nif (!list_empty(&ipc->empty_list)) {\r\nmsg = list_first_entry(&ipc->empty_list, struct ipc_message,\r\nlist);\r\nlist_del(&msg->list);\r\n}\r\nreturn msg;\r\n}\r\nstatic int tx_wait_done(struct sst_generic_ipc *ipc,\r\nstruct ipc_message *msg, void *rx_data)\r\n{\r\nunsigned long flags;\r\nint ret;\r\nret = wait_event_timeout(msg->waitq, msg->complete,\r\nmsecs_to_jiffies(IPC_TIMEOUT_MSECS));\r\nspin_lock_irqsave(&ipc->dsp->spinlock, flags);\r\nif (ret == 0) {\r\nif (ipc->ops.shim_dbg != NULL)\r\nipc->ops.shim_dbg(ipc, "message timeout");\r\nlist_del(&msg->list);\r\nret = -ETIMEDOUT;\r\n} else {\r\nif (msg->rx_size)\r\nmemcpy(rx_data, msg->rx_data, msg->rx_size);\r\nret = msg->errno;\r\n}\r\nlist_add_tail(&msg->list, &ipc->empty_list);\r\nspin_unlock_irqrestore(&ipc->dsp->spinlock, flags);\r\nreturn ret;\r\n}\r\nstatic int ipc_tx_message(struct sst_generic_ipc *ipc, u64 header,\r\nvoid *tx_data, size_t tx_bytes, void *rx_data,\r\nsize_t rx_bytes, int wait)\r\n{\r\nstruct ipc_message *msg;\r\nunsigned long flags;\r\nspin_lock_irqsave(&ipc->dsp->spinlock, flags);\r\nmsg = msg_get_empty(ipc);\r\nif (msg == NULL) {\r\nspin_unlock_irqrestore(&ipc->dsp->spinlock, flags);\r\nreturn -EBUSY;\r\n}\r\nmsg->header = header;\r\nmsg->tx_size = tx_bytes;\r\nmsg->rx_size = rx_bytes;\r\nmsg->wait = wait;\r\nmsg->errno = 0;\r\nmsg->pending = false;\r\nmsg->complete = false;\r\nif ((tx_bytes) && (ipc->ops.tx_data_copy != NULL))\r\nipc->ops.tx_data_copy(msg, tx_data, tx_bytes);\r\nlist_add_tail(&msg->list, &ipc->tx_list);\r\nspin_unlock_irqrestore(&ipc->dsp->spinlock, flags);\r\nqueue_kthread_work(&ipc->kworker, &ipc->kwork);\r\nif (wait)\r\nreturn tx_wait_done(ipc, msg, rx_data);\r\nelse\r\nreturn 0;\r\n}\r\nstatic int msg_empty_list_init(struct sst_generic_ipc *ipc)\r\n{\r\nint i;\r\nipc->msg = kzalloc(sizeof(struct ipc_message) *\r\nIPC_EMPTY_LIST_SIZE, GFP_KERNEL);\r\nif (ipc->msg == NULL)\r\nreturn -ENOMEM;\r\nfor (i = 0; i < IPC_EMPTY_LIST_SIZE; i++) {\r\nipc->msg[i].tx_data = kzalloc(ipc->tx_data_max_size, GFP_KERNEL);\r\nif (ipc->msg[i].tx_data == NULL)\r\ngoto free_mem;\r\nipc->msg[i].rx_data = kzalloc(ipc->rx_data_max_size, GFP_KERNEL);\r\nif (ipc->msg[i].rx_data == NULL) {\r\nkfree(ipc->msg[i].tx_data);\r\ngoto free_mem;\r\n}\r\ninit_waitqueue_head(&ipc->msg[i].waitq);\r\nlist_add(&ipc->msg[i].list, &ipc->empty_list);\r\n}\r\nreturn 0;\r\nfree_mem:\r\nwhile (i > 0) {\r\nkfree(ipc->msg[i-1].tx_data);\r\nkfree(ipc->msg[i-1].rx_data);\r\n--i;\r\n}\r\nkfree(ipc->msg);\r\nreturn -ENOMEM;\r\n}\r\nstatic void ipc_tx_msgs(struct kthread_work *work)\r\n{\r\nstruct sst_generic_ipc *ipc =\r\ncontainer_of(work, struct sst_generic_ipc, kwork);\r\nstruct ipc_message *msg;\r\nunsigned long flags;\r\nspin_lock_irqsave(&ipc->dsp->spinlock, flags);\r\nif (list_empty(&ipc->tx_list) || ipc->pending) {\r\nspin_unlock_irqrestore(&ipc->dsp->spinlock, flags);\r\nreturn;\r\n}\r\nif (ipc->ops.is_dsp_busy && ipc->ops.is_dsp_busy(ipc->dsp)) {\r\ndev_dbg(ipc->dev, "ipc_tx_msgs dsp busy\n");\r\nspin_unlock_irqrestore(&ipc->dsp->spinlock, flags);\r\nreturn;\r\n}\r\nmsg = list_first_entry(&ipc->tx_list, struct ipc_message, list);\r\nlist_move(&msg->list, &ipc->rx_list);\r\nif (ipc->ops.tx_msg != NULL)\r\nipc->ops.tx_msg(ipc, msg);\r\nspin_unlock_irqrestore(&ipc->dsp->spinlock, flags);\r\n}\r\nint sst_ipc_tx_message_wait(struct sst_generic_ipc *ipc, u64 header,\r\nvoid *tx_data, size_t tx_bytes, void *rx_data, size_t rx_bytes)\r\n{\r\nreturn ipc_tx_message(ipc, header, tx_data, tx_bytes,\r\nrx_data, rx_bytes, 1);\r\n}\r\nint sst_ipc_tx_message_nowait(struct sst_generic_ipc *ipc, u64 header,\r\nvoid *tx_data, size_t tx_bytes)\r\n{\r\nreturn ipc_tx_message(ipc, header, tx_data, tx_bytes,\r\nNULL, 0, 0);\r\n}\r\nstruct ipc_message *sst_ipc_reply_find_msg(struct sst_generic_ipc *ipc,\r\nu64 header)\r\n{\r\nstruct ipc_message *msg;\r\nu64 mask;\r\nif (ipc->ops.reply_msg_match != NULL)\r\nheader = ipc->ops.reply_msg_match(header, &mask);\r\nif (list_empty(&ipc->rx_list)) {\r\ndev_err(ipc->dev, "error: rx list empty but received 0x%llx\n",\r\nheader);\r\nreturn NULL;\r\n}\r\nlist_for_each_entry(msg, &ipc->rx_list, list) {\r\nif ((msg->header & mask) == header)\r\nreturn msg;\r\n}\r\nreturn NULL;\r\n}\r\nvoid sst_ipc_tx_msg_reply_complete(struct sst_generic_ipc *ipc,\r\nstruct ipc_message *msg)\r\n{\r\nmsg->complete = true;\r\nif (!msg->wait)\r\nlist_add_tail(&msg->list, &ipc->empty_list);\r\nelse\r\nwake_up(&msg->waitq);\r\n}\r\nvoid sst_ipc_drop_all(struct sst_generic_ipc *ipc)\r\n{\r\nstruct ipc_message *msg, *tmp;\r\nunsigned long flags;\r\nint tx_drop_cnt = 0, rx_drop_cnt = 0;\r\nspin_lock_irqsave(&ipc->dsp->spinlock, flags);\r\nlist_for_each_entry_safe(msg, tmp, &ipc->tx_list, list) {\r\nlist_move(&msg->list, &ipc->empty_list);\r\ntx_drop_cnt++;\r\n}\r\nlist_for_each_entry_safe(msg, tmp, &ipc->rx_list, list) {\r\nlist_move(&msg->list, &ipc->empty_list);\r\nrx_drop_cnt++;\r\n}\r\nspin_unlock_irqrestore(&ipc->dsp->spinlock, flags);\r\nif (tx_drop_cnt || rx_drop_cnt)\r\ndev_err(ipc->dev, "dropped IPC msg RX=%d, TX=%d\n",\r\ntx_drop_cnt, rx_drop_cnt);\r\n}\r\nint sst_ipc_init(struct sst_generic_ipc *ipc)\r\n{\r\nint ret;\r\nINIT_LIST_HEAD(&ipc->tx_list);\r\nINIT_LIST_HEAD(&ipc->rx_list);\r\nINIT_LIST_HEAD(&ipc->empty_list);\r\ninit_waitqueue_head(&ipc->wait_txq);\r\nret = msg_empty_list_init(ipc);\r\nif (ret < 0)\r\nreturn -ENOMEM;\r\ninit_kthread_worker(&ipc->kworker);\r\nipc->tx_thread = kthread_run(kthread_worker_fn,\r\n&ipc->kworker, "%s",\r\ndev_name(ipc->dev));\r\nif (IS_ERR(ipc->tx_thread)) {\r\ndev_err(ipc->dev, "error: failed to create message TX task\n");\r\nret = PTR_ERR(ipc->tx_thread);\r\nkfree(ipc->msg);\r\nreturn ret;\r\n}\r\ninit_kthread_work(&ipc->kwork, ipc_tx_msgs);\r\nreturn 0;\r\n}\r\nvoid sst_ipc_fini(struct sst_generic_ipc *ipc)\r\n{\r\nint i;\r\nif (ipc->tx_thread)\r\nkthread_stop(ipc->tx_thread);\r\nif (ipc->msg) {\r\nfor (i = 0; i < IPC_EMPTY_LIST_SIZE; i++) {\r\nkfree(ipc->msg[i].tx_data);\r\nkfree(ipc->msg[i].rx_data);\r\n}\r\nkfree(ipc->msg);\r\n}\r\n}
