static bool bcm6368_nand_intc_ack(struct brcmnand_soc *soc)\r\n{\r\nstruct bcm6368_nand_soc *priv =\r\ncontainer_of(soc, struct bcm6368_nand_soc, soc);\r\nvoid __iomem *mmio = priv->base + BCM6368_NAND_INT;\r\nu32 val = brcmnand_readl(mmio);\r\nif (val & (BCM6368_CTRL_READY << BCM6368_NAND_STATUS_SHIFT)) {\r\nval &= ~BCM6368_NAND_STATUS_MASK;\r\nval |= BCM6368_CTRL_READY << BCM6368_NAND_STATUS_SHIFT;\r\nbrcmnand_writel(val, mmio);\r\nreturn true;\r\n}\r\nreturn false;\r\n}\r\nstatic void bcm6368_nand_intc_set(struct brcmnand_soc *soc, bool en)\r\n{\r\nstruct bcm6368_nand_soc *priv =\r\ncontainer_of(soc, struct bcm6368_nand_soc, soc);\r\nvoid __iomem *mmio = priv->base + BCM6368_NAND_INT;\r\nu32 val = brcmnand_readl(mmio);\r\nval &= ~BCM6368_NAND_STATUS_MASK;\r\nif (en)\r\nval |= BCM6368_CTRL_READY << BCM6368_NAND_ENABLE_SHIFT;\r\nelse\r\nval &= ~(BCM6368_CTRL_READY << BCM6368_NAND_ENABLE_SHIFT);\r\nbrcmnand_writel(val, mmio);\r\n}\r\nstatic int bcm6368_nand_probe(struct platform_device *pdev)\r\n{\r\nstruct device *dev = &pdev->dev;\r\nstruct bcm6368_nand_soc *priv;\r\nstruct brcmnand_soc *soc;\r\nstruct resource *res;\r\npriv = devm_kzalloc(dev, sizeof(*priv), GFP_KERNEL);\r\nif (!priv)\r\nreturn -ENOMEM;\r\nsoc = &priv->soc;\r\nres = platform_get_resource_byname(pdev,\r\nIORESOURCE_MEM, "nand-int-base");\r\npriv->base = devm_ioremap_resource(dev, res);\r\nif (IS_ERR(priv->base))\r\nreturn PTR_ERR(priv->base);\r\nsoc->ctlrdy_ack = bcm6368_nand_intc_ack;\r\nsoc->ctlrdy_set_enabled = bcm6368_nand_intc_set;\r\nbrcmnand_writel(0, priv->base + BCM6368_NAND_INT);\r\nbrcmnand_writel(BCM6368_NAND_STATUS_MASK,\r\npriv->base + BCM6368_NAND_INT);\r\nreturn brcmnand_probe(pdev, soc);\r\n}
