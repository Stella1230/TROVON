static inline bool is_imx1_pllv1(struct clk_pllv1 *pll)\r\n{\r\nreturn pll->type == IMX_PLLV1_IMX1;\r\n}\r\nstatic inline bool is_imx21_pllv1(struct clk_pllv1 *pll)\r\n{\r\nreturn pll->type == IMX_PLLV1_IMX21;\r\n}\r\nstatic inline bool is_imx27_pllv1(struct clk_pllv1 *pll)\r\n{\r\nreturn pll->type == IMX_PLLV1_IMX27;\r\n}\r\nstatic inline bool mfn_is_negative(struct clk_pllv1 *pll, unsigned int mfn)\r\n{\r\nreturn !is_imx1_pllv1(pll) && !is_imx21_pllv1(pll) && (mfn & MFN_SIGN);\r\n}\r\nstatic unsigned long clk_pllv1_recalc_rate(struct clk_hw *hw,\r\nunsigned long parent_rate)\r\n{\r\nstruct clk_pllv1 *pll = to_clk_pllv1(hw);\r\nunsigned long long ull;\r\nint mfn_abs;\r\nunsigned int mfi, mfn, mfd, pd;\r\nu32 reg;\r\nunsigned long rate;\r\nreg = readl(pll->base);\r\nmfi = (reg >> 10) & 0xf;\r\nmfn = reg & 0x3ff;\r\nmfd = (reg >> 16) & 0x3ff;\r\npd = (reg >> 26) & 0xf;\r\nmfi = mfi <= 5 ? 5 : mfi;\r\nmfn_abs = mfn;\r\nif (mfn_is_negative(pll, mfn)) {\r\nif (is_imx27_pllv1(pll))\r\nmfn_abs = mfn & MFN_MASK;\r\nelse\r\nmfn_abs = BIT(MFN_BITS) - mfn;\r\n}\r\nrate = parent_rate * 2;\r\nrate /= pd + 1;\r\null = (unsigned long long)rate * mfn_abs;\r\ndo_div(ull, mfd + 1);\r\nif (mfn_is_negative(pll, mfn))\r\null = (rate * mfi) - ull;\r\nelse\r\null = (rate * mfi) + ull;\r\nreturn ull;\r\n}\r\nstruct clk *imx_clk_pllv1(enum imx_pllv1_type type, const char *name,\r\nconst char *parent, void __iomem *base)\r\n{\r\nstruct clk_pllv1 *pll;\r\nstruct clk *clk;\r\nstruct clk_init_data init;\r\npll = kmalloc(sizeof(*pll), GFP_KERNEL);\r\nif (!pll)\r\nreturn ERR_PTR(-ENOMEM);\r\npll->base = base;\r\npll->type = type;\r\ninit.name = name;\r\ninit.ops = &clk_pllv1_ops;\r\ninit.flags = 0;\r\ninit.parent_names = &parent;\r\ninit.num_parents = 1;\r\npll->hw.init = &init;\r\nclk = clk_register(NULL, &pll->hw);\r\nif (IS_ERR(clk))\r\nkfree(pll);\r\nreturn clk;\r\n}
