int mmc_send_io_op_cond(struct mmc_host *host, u32 ocr, u32 *rocr)\r\n{\r\nstruct mmc_command cmd = {0};\r\nint i, err = 0;\r\nBUG_ON(!host);\r\ncmd.opcode = SD_IO_SEND_OP_COND;\r\ncmd.arg = ocr;\r\ncmd.flags = MMC_RSP_SPI_R4 | MMC_RSP_R4 | MMC_CMD_BCR;\r\nfor (i = 100; i; i--) {\r\nerr = mmc_wait_for_cmd(host, &cmd, MMC_CMD_RETRIES);\r\nif (err)\r\nbreak;\r\nif (ocr == 0)\r\nbreak;\r\nif (mmc_host_is_spi(host)) {\r\nif (cmd.resp[1] & MMC_CARD_BUSY)\r\nbreak;\r\n} else {\r\nif (cmd.resp[0] & MMC_CARD_BUSY)\r\nbreak;\r\n}\r\nerr = -ETIMEDOUT;\r\nmmc_delay(10);\r\n}\r\nif (rocr)\r\n*rocr = cmd.resp[mmc_host_is_spi(host) ? 1 : 0];\r\nreturn err;\r\n}\r\nstatic int mmc_io_rw_direct_host(struct mmc_host *host, int write, unsigned fn,\r\nunsigned addr, u8 in, u8 *out)\r\n{\r\nstruct mmc_command cmd = {0};\r\nint err;\r\nBUG_ON(!host);\r\nBUG_ON(fn > 7);\r\nif (addr & ~0x1FFFF)\r\nreturn -EINVAL;\r\ncmd.opcode = SD_IO_RW_DIRECT;\r\ncmd.arg = write ? 0x80000000 : 0x00000000;\r\ncmd.arg |= fn << 28;\r\ncmd.arg |= (write && out) ? 0x08000000 : 0x00000000;\r\ncmd.arg |= addr << 9;\r\ncmd.arg |= in;\r\ncmd.flags = MMC_RSP_SPI_R5 | MMC_RSP_R5 | MMC_CMD_AC;\r\nerr = mmc_wait_for_cmd(host, &cmd, 0);\r\nif (err)\r\nreturn err;\r\nif (mmc_host_is_spi(host)) {\r\n} else {\r\nif (cmd.resp[0] & R5_ERROR)\r\nreturn -EIO;\r\nif (cmd.resp[0] & R5_FUNCTION_NUMBER)\r\nreturn -EINVAL;\r\nif (cmd.resp[0] & R5_OUT_OF_RANGE)\r\nreturn -ERANGE;\r\n}\r\nif (out) {\r\nif (mmc_host_is_spi(host))\r\n*out = (cmd.resp[0] >> 8) & 0xFF;\r\nelse\r\n*out = cmd.resp[0] & 0xFF;\r\n}\r\nreturn 0;\r\n}\r\nint mmc_io_rw_direct(struct mmc_card *card, int write, unsigned fn,\r\nunsigned addr, u8 in, u8 *out)\r\n{\r\nBUG_ON(!card);\r\nreturn mmc_io_rw_direct_host(card->host, write, fn, addr, in, out);\r\n}\r\nint mmc_io_rw_extended(struct mmc_card *card, int write, unsigned fn,\r\nunsigned addr, int incr_addr, u8 *buf, unsigned blocks, unsigned blksz)\r\n{\r\nstruct mmc_request mrq = {NULL};\r\nstruct mmc_command cmd = {0};\r\nstruct mmc_data data = {0};\r\nstruct scatterlist sg, *sg_ptr;\r\nstruct sg_table sgtable;\r\nunsigned int nents, left_size, i;\r\nunsigned int seg_size = card->host->max_seg_size;\r\nBUG_ON(!card);\r\nBUG_ON(fn > 7);\r\nWARN_ON(blksz == 0);\r\nif (addr & ~0x1FFFF)\r\nreturn -EINVAL;\r\nmrq.cmd = &cmd;\r\nmrq.data = &data;\r\ncmd.opcode = SD_IO_RW_EXTENDED;\r\ncmd.arg = write ? 0x80000000 : 0x00000000;\r\ncmd.arg |= fn << 28;\r\ncmd.arg |= incr_addr ? 0x04000000 : 0x00000000;\r\ncmd.arg |= addr << 9;\r\nif (blocks == 0)\r\ncmd.arg |= (blksz == 512) ? 0 : blksz;\r\nelse\r\ncmd.arg |= 0x08000000 | blocks;\r\ncmd.flags = MMC_RSP_SPI_R5 | MMC_RSP_R5 | MMC_CMD_ADTC;\r\ndata.blksz = blksz;\r\ndata.blocks = blocks ? blocks : 1;\r\ndata.flags = write ? MMC_DATA_WRITE : MMC_DATA_READ;\r\nleft_size = data.blksz * data.blocks;\r\nnents = (left_size - 1) / seg_size + 1;\r\nif (nents > 1) {\r\nif (sg_alloc_table(&sgtable, nents, GFP_KERNEL))\r\nreturn -ENOMEM;\r\ndata.sg = sgtable.sgl;\r\ndata.sg_len = nents;\r\nfor_each_sg(data.sg, sg_ptr, data.sg_len, i) {\r\nsg_set_page(sg_ptr, virt_to_page(buf + (i * seg_size)),\r\nmin(seg_size, left_size),\r\noffset_in_page(buf + (i * seg_size)));\r\nleft_size = left_size - seg_size;\r\n}\r\n} else {\r\ndata.sg = &sg;\r\ndata.sg_len = 1;\r\nsg_init_one(&sg, buf, left_size);\r\n}\r\nmmc_set_data_timeout(&data, card);\r\nmmc_wait_for_req(card->host, &mrq);\r\nif (nents > 1)\r\nsg_free_table(&sgtable);\r\nif (cmd.error)\r\nreturn cmd.error;\r\nif (data.error)\r\nreturn data.error;\r\nif (mmc_host_is_spi(card->host)) {\r\n} else {\r\nif (cmd.resp[0] & R5_ERROR)\r\nreturn -EIO;\r\nif (cmd.resp[0] & R5_FUNCTION_NUMBER)\r\nreturn -EINVAL;\r\nif (cmd.resp[0] & R5_OUT_OF_RANGE)\r\nreturn -ERANGE;\r\n}\r\nreturn 0;\r\n}\r\nint sdio_reset(struct mmc_host *host)\r\n{\r\nint ret;\r\nu8 abort;\r\nret = mmc_io_rw_direct_host(host, 0, 0, SDIO_CCCR_ABORT, 0, &abort);\r\nif (ret)\r\nabort = 0x08;\r\nelse\r\nabort |= 0x08;\r\nreturn mmc_io_rw_direct_host(host, 1, 0, SDIO_CCCR_ABORT, abort, NULL);\r\n}
