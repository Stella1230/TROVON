struct drm_flip_task *drm_flip_work_allocate_task(void *data, gfp_t flags)\r\n{\r\nstruct drm_flip_task *task;\r\ntask = kzalloc(sizeof(*task), flags);\r\nif (task)\r\ntask->data = data;\r\nreturn task;\r\n}\r\nvoid drm_flip_work_queue_task(struct drm_flip_work *work,\r\nstruct drm_flip_task *task)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&work->lock, flags);\r\nlist_add_tail(&task->node, &work->queued);\r\nspin_unlock_irqrestore(&work->lock, flags);\r\n}\r\nvoid drm_flip_work_queue(struct drm_flip_work *work, void *val)\r\n{\r\nstruct drm_flip_task *task;\r\ntask = drm_flip_work_allocate_task(val,\r\ndrm_can_sleep() ? GFP_KERNEL : GFP_ATOMIC);\r\nif (task) {\r\ndrm_flip_work_queue_task(work, task);\r\n} else {\r\nDRM_ERROR("%s could not allocate task!\n", work->name);\r\nwork->func(work, val);\r\n}\r\n}\r\nvoid drm_flip_work_commit(struct drm_flip_work *work,\r\nstruct workqueue_struct *wq)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&work->lock, flags);\r\nlist_splice_tail(&work->queued, &work->commited);\r\nINIT_LIST_HEAD(&work->queued);\r\nspin_unlock_irqrestore(&work->lock, flags);\r\nqueue_work(wq, &work->worker);\r\n}\r\nstatic void flip_worker(struct work_struct *w)\r\n{\r\nstruct drm_flip_work *work = container_of(w, struct drm_flip_work, worker);\r\nstruct list_head tasks;\r\nunsigned long flags;\r\nwhile (1) {\r\nstruct drm_flip_task *task, *tmp;\r\nINIT_LIST_HEAD(&tasks);\r\nspin_lock_irqsave(&work->lock, flags);\r\nlist_splice_tail(&work->commited, &tasks);\r\nINIT_LIST_HEAD(&work->commited);\r\nspin_unlock_irqrestore(&work->lock, flags);\r\nif (list_empty(&tasks))\r\nbreak;\r\nlist_for_each_entry_safe(task, tmp, &tasks, node) {\r\nwork->func(work, task->data);\r\nkfree(task);\r\n}\r\n}\r\n}\r\nvoid drm_flip_work_init(struct drm_flip_work *work,\r\nconst char *name, drm_flip_func_t func)\r\n{\r\nwork->name = name;\r\nINIT_LIST_HEAD(&work->queued);\r\nINIT_LIST_HEAD(&work->commited);\r\nspin_lock_init(&work->lock);\r\nwork->func = func;\r\nINIT_WORK(&work->worker, flip_worker);\r\n}\r\nvoid drm_flip_work_cleanup(struct drm_flip_work *work)\r\n{\r\nWARN_ON(!list_empty(&work->queued) || !list_empty(&work->commited));\r\n}
