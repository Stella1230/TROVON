void class_handle_hash(struct portals_handle *h,\r\nstruct portals_handle_ops *ops)\r\n{\r\nstruct handle_bucket *bucket;\r\nLASSERT(h);\r\nLASSERT(list_empty(&h->h_link));\r\nspin_lock(&handle_base_lock);\r\nhandle_base += HANDLE_INCR;\r\nif (unlikely(handle_base == 0)) {\r\nCWARN("The universe has been exhausted: cookie wrap-around.\n");\r\nhandle_base += HANDLE_INCR;\r\n}\r\nh->h_cookie = handle_base;\r\nspin_unlock(&handle_base_lock);\r\nh->h_ops = ops;\r\nspin_lock_init(&h->h_lock);\r\nbucket = &handle_hash[h->h_cookie & HANDLE_HASH_MASK];\r\nspin_lock(&bucket->lock);\r\nlist_add_rcu(&h->h_link, &bucket->head);\r\nh->h_in = 1;\r\nspin_unlock(&bucket->lock);\r\nCDEBUG(D_INFO, "added object %p with handle %#llx to hash\n",\r\nh, h->h_cookie);\r\n}\r\nstatic void class_handle_unhash_nolock(struct portals_handle *h)\r\n{\r\nif (list_empty(&h->h_link)) {\r\nCERROR("removing an already-removed handle (%#llx)\n",\r\nh->h_cookie);\r\nreturn;\r\n}\r\nCDEBUG(D_INFO, "removing object %p with handle %#llx from hash\n",\r\nh, h->h_cookie);\r\nspin_lock(&h->h_lock);\r\nif (h->h_in == 0) {\r\nspin_unlock(&h->h_lock);\r\nreturn;\r\n}\r\nh->h_in = 0;\r\nspin_unlock(&h->h_lock);\r\nlist_del_rcu(&h->h_link);\r\n}\r\nvoid class_handle_unhash(struct portals_handle *h)\r\n{\r\nstruct handle_bucket *bucket;\r\nbucket = handle_hash + (h->h_cookie & HANDLE_HASH_MASK);\r\nspin_lock(&bucket->lock);\r\nclass_handle_unhash_nolock(h);\r\nspin_unlock(&bucket->lock);\r\n}\r\nvoid *class_handle2object(__u64 cookie)\r\n{\r\nstruct handle_bucket *bucket;\r\nstruct portals_handle *h;\r\nvoid *retval = NULL;\r\nLASSERT(handle_hash);\r\nbucket = handle_hash + (cookie & HANDLE_HASH_MASK);\r\nrcu_read_lock();\r\nlist_for_each_entry_rcu(h, &bucket->head, h_link) {\r\nif (h->h_cookie != cookie)\r\ncontinue;\r\nspin_lock(&h->h_lock);\r\nif (likely(h->h_in != 0)) {\r\nh->h_ops->hop_addref(h);\r\nretval = h;\r\n}\r\nspin_unlock(&h->h_lock);\r\nbreak;\r\n}\r\nrcu_read_unlock();\r\nreturn retval;\r\n}\r\nvoid class_handle_free_cb(struct rcu_head *rcu)\r\n{\r\nstruct portals_handle *h = RCU2HANDLE(rcu);\r\nvoid *ptr = (void *)(unsigned long)h->h_cookie;\r\nif (h->h_ops->hop_free)\r\nh->h_ops->hop_free(ptr, h->h_size);\r\nelse\r\nkfree(ptr);\r\n}\r\nint class_handle_init(void)\r\n{\r\nstruct handle_bucket *bucket;\r\nstruct timespec64 ts;\r\nint seed[2];\r\nLASSERT(!handle_hash);\r\nhandle_hash = libcfs_kvzalloc(sizeof(*bucket) * HANDLE_HASH_SIZE,\r\nGFP_NOFS);\r\nif (!handle_hash)\r\nreturn -ENOMEM;\r\nspin_lock_init(&handle_base_lock);\r\nfor (bucket = handle_hash + HANDLE_HASH_SIZE - 1; bucket >= handle_hash;\r\nbucket--) {\r\nINIT_LIST_HEAD(&bucket->head);\r\nspin_lock_init(&bucket->lock);\r\n}\r\ncfs_get_random_bytes(seed, sizeof(seed));\r\nktime_get_ts64(&ts);\r\ncfs_srand(ts.tv_sec ^ seed[0], ts.tv_nsec ^ seed[1]);\r\ncfs_get_random_bytes(&handle_base, sizeof(handle_base));\r\nLASSERT(handle_base != 0ULL);\r\nreturn 0;\r\n}\r\nstatic int cleanup_all_handles(void)\r\n{\r\nint rc;\r\nint i;\r\nfor (rc = i = 0; i < HANDLE_HASH_SIZE; i++) {\r\nstruct portals_handle *h;\r\nspin_lock(&handle_hash[i].lock);\r\nlist_for_each_entry_rcu(h, &(handle_hash[i].head), h_link) {\r\nCERROR("force clean handle %#llx addr %p ops %p\n",\r\nh->h_cookie, h, h->h_ops);\r\nclass_handle_unhash_nolock(h);\r\nrc++;\r\n}\r\nspin_unlock(&handle_hash[i].lock);\r\n}\r\nreturn rc;\r\n}\r\nvoid class_handle_cleanup(void)\r\n{\r\nint count;\r\nLASSERT(handle_hash);\r\ncount = cleanup_all_handles();\r\nkvfree(handle_hash);\r\nhandle_hash = NULL;\r\nif (count != 0)\r\nCERROR("handle_count at cleanup: %d\n", count);\r\n}
