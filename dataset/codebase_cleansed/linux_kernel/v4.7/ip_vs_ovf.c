static struct ip_vs_dest *\r\nip_vs_ovf_schedule(struct ip_vs_service *svc, const struct sk_buff *skb,\r\nstruct ip_vs_iphdr *iph)\r\n{\r\nstruct ip_vs_dest *dest, *h = NULL;\r\nint hw = 0, w;\r\nIP_VS_DBG(6, "ip_vs_ovf_schedule(): Scheduling...\n");\r\nlist_for_each_entry_rcu(dest, &svc->destinations, n_list) {\r\nw = atomic_read(&dest->weight);\r\nif ((dest->flags & IP_VS_DEST_F_OVERLOAD) ||\r\natomic_read(&dest->activeconns) > w ||\r\nw == 0)\r\ncontinue;\r\nif (!h || w > hw) {\r\nh = dest;\r\nhw = w;\r\n}\r\n}\r\nif (h) {\r\nIP_VS_DBG_BUF(6, "OVF: server %s:%u active %d w %d\n",\r\nIP_VS_DBG_ADDR(h->af, &h->addr),\r\nntohs(h->port),\r\natomic_read(&h->activeconns),\r\natomic_read(&h->weight));\r\nreturn h;\r\n}\r\nip_vs_scheduler_err(svc, "no destination available");\r\nreturn NULL;\r\n}\r\nstatic int __init ip_vs_ovf_init(void)\r\n{\r\nreturn register_ip_vs_scheduler(&ip_vs_ovf_scheduler);\r\n}\r\nstatic void __exit ip_vs_ovf_cleanup(void)\r\n{\r\nunregister_ip_vs_scheduler(&ip_vs_ovf_scheduler);\r\nsynchronize_rcu();\r\n}
