static enum ib_rate memfree_rate_to_ib(u8 mthca_rate, u8 port_rate)\r\n{\r\nswitch (mthca_rate) {\r\ncase MTHCA_RATE_MEMFREE_EIGHTH:\r\nreturn mult_to_ib_rate(port_rate >> 3);\r\ncase MTHCA_RATE_MEMFREE_QUARTER:\r\nreturn mult_to_ib_rate(port_rate >> 2);\r\ncase MTHCA_RATE_MEMFREE_HALF:\r\nreturn mult_to_ib_rate(port_rate >> 1);\r\ncase MTHCA_RATE_MEMFREE_FULL:\r\ndefault:\r\nreturn mult_to_ib_rate(port_rate);\r\n}\r\n}\r\nstatic enum ib_rate tavor_rate_to_ib(u8 mthca_rate, u8 port_rate)\r\n{\r\nswitch (mthca_rate) {\r\ncase MTHCA_RATE_TAVOR_1X: return IB_RATE_2_5_GBPS;\r\ncase MTHCA_RATE_TAVOR_1X_DDR: return IB_RATE_5_GBPS;\r\ncase MTHCA_RATE_TAVOR_4X: return IB_RATE_10_GBPS;\r\ndefault: return mult_to_ib_rate(port_rate);\r\n}\r\n}\r\nenum ib_rate mthca_rate_to_ib(struct mthca_dev *dev, u8 mthca_rate, u8 port)\r\n{\r\nif (mthca_is_memfree(dev)) {\r\nif (dev->limits.stat_rate_support == 0x3 && mthca_rate)\r\nreturn IB_RATE_2_5_GBPS;\r\nreturn memfree_rate_to_ib(mthca_rate, dev->rate[port - 1]);\r\n} else\r\nreturn tavor_rate_to_ib(mthca_rate, dev->rate[port - 1]);\r\n}\r\nstatic u8 ib_rate_to_memfree(u8 req_rate, u8 cur_rate)\r\n{\r\nif (cur_rate <= req_rate)\r\nreturn 0;\r\nswitch ((cur_rate - 1) / req_rate) {\r\ncase 0: return MTHCA_RATE_MEMFREE_FULL;\r\ncase 1: return MTHCA_RATE_MEMFREE_HALF;\r\ncase 2:\r\ncase 3: return MTHCA_RATE_MEMFREE_QUARTER;\r\ndefault: return MTHCA_RATE_MEMFREE_EIGHTH;\r\n}\r\n}\r\nstatic u8 ib_rate_to_tavor(u8 static_rate)\r\n{\r\nswitch (static_rate) {\r\ncase IB_RATE_2_5_GBPS: return MTHCA_RATE_TAVOR_1X;\r\ncase IB_RATE_5_GBPS: return MTHCA_RATE_TAVOR_1X_DDR;\r\ncase IB_RATE_10_GBPS: return MTHCA_RATE_TAVOR_4X;\r\ndefault: return MTHCA_RATE_TAVOR_FULL;\r\n}\r\n}\r\nu8 mthca_get_rate(struct mthca_dev *dev, int static_rate, u8 port)\r\n{\r\nu8 rate;\r\nif (!static_rate || ib_rate_to_mult(static_rate) >= dev->rate[port - 1])\r\nreturn 0;\r\nif (mthca_is_memfree(dev))\r\nrate = ib_rate_to_memfree(ib_rate_to_mult(static_rate),\r\ndev->rate[port - 1]);\r\nelse\r\nrate = ib_rate_to_tavor(static_rate);\r\nif (!(dev->limits.stat_rate_support & (1 << rate)))\r\nrate = 1;\r\nreturn rate;\r\n}\r\nint mthca_create_ah(struct mthca_dev *dev,\r\nstruct mthca_pd *pd,\r\nstruct ib_ah_attr *ah_attr,\r\nstruct mthca_ah *ah)\r\n{\r\nu32 index = -1;\r\nstruct mthca_av *av = NULL;\r\nah->type = MTHCA_AH_PCI_POOL;\r\nif (mthca_is_memfree(dev)) {\r\nah->av = kmalloc(sizeof *ah->av, GFP_ATOMIC);\r\nif (!ah->av)\r\nreturn -ENOMEM;\r\nah->type = MTHCA_AH_KMALLOC;\r\nav = ah->av;\r\n} else if (!atomic_read(&pd->sqp_count) &&\r\n!(dev->mthca_flags & MTHCA_FLAG_DDR_HIDDEN)) {\r\nindex = mthca_alloc(&dev->av_table.alloc);\r\nif (index == -1)\r\ngoto on_hca_fail;\r\nav = kmalloc(sizeof *av, GFP_ATOMIC);\r\nif (!av)\r\ngoto on_hca_fail;\r\nah->type = MTHCA_AH_ON_HCA;\r\nah->avdma = dev->av_table.ddr_av_base +\r\nindex * MTHCA_AV_SIZE;\r\n}\r\non_hca_fail:\r\nif (ah->type == MTHCA_AH_PCI_POOL) {\r\nah->av = pci_pool_alloc(dev->av_table.pool,\r\nGFP_ATOMIC, &ah->avdma);\r\nif (!ah->av)\r\nreturn -ENOMEM;\r\nav = ah->av;\r\n}\r\nah->key = pd->ntmr.ibmr.lkey;\r\nmemset(av, 0, MTHCA_AV_SIZE);\r\nav->port_pd = cpu_to_be32(pd->pd_num | (ah_attr->port_num << 24));\r\nav->g_slid = ah_attr->src_path_bits;\r\nav->dlid = cpu_to_be16(ah_attr->dlid);\r\nav->msg_sr = (3 << 4) |\r\nmthca_get_rate(dev, ah_attr->static_rate, ah_attr->port_num);\r\nav->sl_tclass_flowlabel = cpu_to_be32(ah_attr->sl << 28);\r\nif (ah_attr->ah_flags & IB_AH_GRH) {\r\nav->g_slid |= 0x80;\r\nav->gid_index = (ah_attr->port_num - 1) * dev->limits.gid_table_len +\r\nah_attr->grh.sgid_index;\r\nav->hop_limit = ah_attr->grh.hop_limit;\r\nav->sl_tclass_flowlabel |=\r\ncpu_to_be32((ah_attr->grh.traffic_class << 20) |\r\nah_attr->grh.flow_label);\r\nmemcpy(av->dgid, ah_attr->grh.dgid.raw, 16);\r\n} else {\r\nav->dgid[3] = cpu_to_be32(2);\r\n}\r\nif (0) {\r\nint j;\r\nmthca_dbg(dev, "Created UDAV at %p/%08lx:\n",\r\nav, (unsigned long) ah->avdma);\r\nfor (j = 0; j < 8; ++j)\r\nprintk(KERN_DEBUG " [%2x] %08x\n",\r\nj * 4, be32_to_cpu(((__be32 *) av)[j]));\r\n}\r\nif (ah->type == MTHCA_AH_ON_HCA) {\r\nmemcpy_toio(dev->av_table.av_map + index * MTHCA_AV_SIZE,\r\nav, MTHCA_AV_SIZE);\r\nkfree(av);\r\n}\r\nreturn 0;\r\n}\r\nint mthca_destroy_ah(struct mthca_dev *dev, struct mthca_ah *ah)\r\n{\r\nswitch (ah->type) {\r\ncase MTHCA_AH_ON_HCA:\r\nmthca_free(&dev->av_table.alloc,\r\n(ah->avdma - dev->av_table.ddr_av_base) /\r\nMTHCA_AV_SIZE);\r\nbreak;\r\ncase MTHCA_AH_PCI_POOL:\r\npci_pool_free(dev->av_table.pool, ah->av, ah->avdma);\r\nbreak;\r\ncase MTHCA_AH_KMALLOC:\r\nkfree(ah->av);\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nint mthca_ah_grh_present(struct mthca_ah *ah)\r\n{\r\nreturn !!(ah->av->g_slid & 0x80);\r\n}\r\nint mthca_read_ah(struct mthca_dev *dev, struct mthca_ah *ah,\r\nstruct ib_ud_header *header)\r\n{\r\nif (ah->type == MTHCA_AH_ON_HCA)\r\nreturn -EINVAL;\r\nheader->lrh.service_level = be32_to_cpu(ah->av->sl_tclass_flowlabel) >> 28;\r\nheader->lrh.destination_lid = ah->av->dlid;\r\nheader->lrh.source_lid = cpu_to_be16(ah->av->g_slid & 0x7f);\r\nif (mthca_ah_grh_present(ah)) {\r\nheader->grh.traffic_class =\r\n(be32_to_cpu(ah->av->sl_tclass_flowlabel) >> 20) & 0xff;\r\nheader->grh.flow_label =\r\nah->av->sl_tclass_flowlabel & cpu_to_be32(0xfffff);\r\nheader->grh.hop_limit = ah->av->hop_limit;\r\nib_get_cached_gid(&dev->ib_dev,\r\nbe32_to_cpu(ah->av->port_pd) >> 24,\r\nah->av->gid_index % dev->limits.gid_table_len,\r\n&header->grh.source_gid, NULL);\r\nmemcpy(header->grh.destination_gid.raw,\r\nah->av->dgid, 16);\r\n}\r\nreturn 0;\r\n}\r\nint mthca_ah_query(struct ib_ah *ibah, struct ib_ah_attr *attr)\r\n{\r\nstruct mthca_ah *ah = to_mah(ibah);\r\nstruct mthca_dev *dev = to_mdev(ibah->device);\r\nif (ah->type == MTHCA_AH_ON_HCA)\r\nreturn -ENOSYS;\r\nmemset(attr, 0, sizeof *attr);\r\nattr->dlid = be16_to_cpu(ah->av->dlid);\r\nattr->sl = be32_to_cpu(ah->av->sl_tclass_flowlabel) >> 28;\r\nattr->port_num = be32_to_cpu(ah->av->port_pd) >> 24;\r\nattr->static_rate = mthca_rate_to_ib(dev, ah->av->msg_sr & 0x7,\r\nattr->port_num);\r\nattr->src_path_bits = ah->av->g_slid & 0x7F;\r\nattr->ah_flags = mthca_ah_grh_present(ah) ? IB_AH_GRH : 0;\r\nif (attr->ah_flags) {\r\nattr->grh.traffic_class =\r\nbe32_to_cpu(ah->av->sl_tclass_flowlabel) >> 20;\r\nattr->grh.flow_label =\r\nbe32_to_cpu(ah->av->sl_tclass_flowlabel) & 0xfffff;\r\nattr->grh.hop_limit = ah->av->hop_limit;\r\nattr->grh.sgid_index = ah->av->gid_index &\r\n(dev->limits.gid_table_len - 1);\r\nmemcpy(attr->grh.dgid.raw, ah->av->dgid, 16);\r\n}\r\nreturn 0;\r\n}\r\nint mthca_init_av_table(struct mthca_dev *dev)\r\n{\r\nint err;\r\nif (mthca_is_memfree(dev))\r\nreturn 0;\r\nerr = mthca_alloc_init(&dev->av_table.alloc,\r\ndev->av_table.num_ddr_avs,\r\ndev->av_table.num_ddr_avs - 1,\r\n0);\r\nif (err)\r\nreturn err;\r\ndev->av_table.pool = pci_pool_create("mthca_av", dev->pdev,\r\nMTHCA_AV_SIZE,\r\nMTHCA_AV_SIZE, 0);\r\nif (!dev->av_table.pool)\r\ngoto out_free_alloc;\r\nif (!(dev->mthca_flags & MTHCA_FLAG_DDR_HIDDEN)) {\r\ndev->av_table.av_map = ioremap(pci_resource_start(dev->pdev, 4) +\r\ndev->av_table.ddr_av_base -\r\ndev->ddr_start,\r\ndev->av_table.num_ddr_avs *\r\nMTHCA_AV_SIZE);\r\nif (!dev->av_table.av_map)\r\ngoto out_free_pool;\r\n} else\r\ndev->av_table.av_map = NULL;\r\nreturn 0;\r\nout_free_pool:\r\npci_pool_destroy(dev->av_table.pool);\r\nout_free_alloc:\r\nmthca_alloc_cleanup(&dev->av_table.alloc);\r\nreturn -ENOMEM;\r\n}\r\nvoid mthca_cleanup_av_table(struct mthca_dev *dev)\r\n{\r\nif (mthca_is_memfree(dev))\r\nreturn;\r\nif (dev->av_table.av_map)\r\niounmap(dev->av_table.av_map);\r\npci_pool_destroy(dev->av_table.pool);\r\nmthca_alloc_cleanup(&dev->av_table.alloc);\r\n}
