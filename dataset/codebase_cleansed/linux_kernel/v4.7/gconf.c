const char *dbg_sym_flags(int val)\r\n{\r\nstatic char buf[256];\r\nbzero(buf, 256);\r\nif (val & SYMBOL_CONST)\r\nstrcat(buf, "const/");\r\nif (val & SYMBOL_CHECK)\r\nstrcat(buf, "check/");\r\nif (val & SYMBOL_CHOICE)\r\nstrcat(buf, "choice/");\r\nif (val & SYMBOL_CHOICEVAL)\r\nstrcat(buf, "choiceval/");\r\nif (val & SYMBOL_VALID)\r\nstrcat(buf, "valid/");\r\nif (val & SYMBOL_OPTIONAL)\r\nstrcat(buf, "optional/");\r\nif (val & SYMBOL_WRITE)\r\nstrcat(buf, "write/");\r\nif (val & SYMBOL_CHANGED)\r\nstrcat(buf, "changed/");\r\nif (val & SYMBOL_AUTO)\r\nstrcat(buf, "auto/");\r\nbuf[strlen(buf) - 1] = '\0';\r\nreturn buf;\r\n}\r\nvoid replace_button_icon(GladeXML * xml, GdkDrawable * window,\r\nGtkStyle * style, gchar * btn_name, gchar ** xpm)\r\n{\r\nGdkPixmap *pixmap;\r\nGdkBitmap *mask;\r\nGtkToolButton *button;\r\nGtkWidget *image;\r\npixmap = gdk_pixmap_create_from_xpm_d(window, &mask,\r\n&style->bg[GTK_STATE_NORMAL],\r\nxpm);\r\nbutton = GTK_TOOL_BUTTON(glade_xml_get_widget(xml, btn_name));\r\nimage = gtk_image_new_from_pixmap(pixmap, mask);\r\ngtk_widget_show(image);\r\ngtk_tool_button_set_icon_widget(button, image);\r\n}\r\nvoid init_main_window(const gchar * glade_file)\r\n{\r\nGladeXML *xml;\r\nGtkWidget *widget;\r\nGtkTextBuffer *txtbuf;\r\nGtkStyle *style;\r\nxml = glade_xml_new(glade_file, "window1", NULL);\r\nif (!xml)\r\ng_error(_("GUI loading failed !\n"));\r\nglade_xml_signal_autoconnect(xml);\r\nmain_wnd = glade_xml_get_widget(xml, "window1");\r\nhpaned = glade_xml_get_widget(xml, "hpaned1");\r\nvpaned = glade_xml_get_widget(xml, "vpaned1");\r\ntree1_w = glade_xml_get_widget(xml, "treeview1");\r\ntree2_w = glade_xml_get_widget(xml, "treeview2");\r\ntext_w = glade_xml_get_widget(xml, "textview3");\r\nback_btn = glade_xml_get_widget(xml, "button1");\r\ngtk_widget_set_sensitive(back_btn, FALSE);\r\nwidget = glade_xml_get_widget(xml, "show_name1");\r\ngtk_check_menu_item_set_active((GtkCheckMenuItem *) widget,\r\nshow_name);\r\nwidget = glade_xml_get_widget(xml, "show_range1");\r\ngtk_check_menu_item_set_active((GtkCheckMenuItem *) widget,\r\nshow_range);\r\nwidget = glade_xml_get_widget(xml, "show_data1");\r\ngtk_check_menu_item_set_active((GtkCheckMenuItem *) widget,\r\nshow_value);\r\nsave_btn = glade_xml_get_widget(xml, "button3");\r\nsave_menu_item = glade_xml_get_widget(xml, "save1");\r\nconf_set_changed_callback(conf_changed);\r\nstyle = gtk_widget_get_style(main_wnd);\r\nwidget = glade_xml_get_widget(xml, "toolbar1");\r\nreplace_button_icon(xml, main_wnd->window, style,\r\n"button4", (gchar **) xpm_single_view);\r\nreplace_button_icon(xml, main_wnd->window, style,\r\n"button5", (gchar **) xpm_split_view);\r\nreplace_button_icon(xml, main_wnd->window, style,\r\n"button6", (gchar **) xpm_tree_view);\r\ntxtbuf = gtk_text_view_get_buffer(GTK_TEXT_VIEW(text_w));\r\ntag1 = gtk_text_buffer_create_tag(txtbuf, "mytag1",\r\n"foreground", "red",\r\n"weight", PANGO_WEIGHT_BOLD,\r\nNULL);\r\ntag2 = gtk_text_buffer_create_tag(txtbuf, "mytag2",\r\nNULL);\r\ngtk_window_set_title(GTK_WINDOW(main_wnd), rootmenu.prompt->text);\r\ngtk_widget_show(main_wnd);\r\n}\r\nvoid init_tree_model(void)\r\n{\r\ngint i;\r\ntree = tree2 = gtk_tree_store_new(COL_NUMBER,\r\nG_TYPE_STRING, G_TYPE_STRING,\r\nG_TYPE_STRING, G_TYPE_STRING,\r\nG_TYPE_STRING, G_TYPE_STRING,\r\nG_TYPE_POINTER, GDK_TYPE_COLOR,\r\nG_TYPE_BOOLEAN, GDK_TYPE_PIXBUF,\r\nG_TYPE_BOOLEAN, G_TYPE_BOOLEAN,\r\nG_TYPE_BOOLEAN, G_TYPE_BOOLEAN,\r\nG_TYPE_BOOLEAN);\r\nmodel2 = GTK_TREE_MODEL(tree2);\r\nfor (parents[0] = NULL, i = 1; i < 256; i++)\r\nparents[i] = (GtkTreeIter *) g_malloc(sizeof(GtkTreeIter));\r\ntree1 = gtk_tree_store_new(COL_NUMBER,\r\nG_TYPE_STRING, G_TYPE_STRING,\r\nG_TYPE_STRING, G_TYPE_STRING,\r\nG_TYPE_STRING, G_TYPE_STRING,\r\nG_TYPE_POINTER, GDK_TYPE_COLOR,\r\nG_TYPE_BOOLEAN, GDK_TYPE_PIXBUF,\r\nG_TYPE_BOOLEAN, G_TYPE_BOOLEAN,\r\nG_TYPE_BOOLEAN, G_TYPE_BOOLEAN,\r\nG_TYPE_BOOLEAN);\r\nmodel1 = GTK_TREE_MODEL(tree1);\r\n}\r\nvoid init_left_tree(void)\r\n{\r\nGtkTreeView *view = GTK_TREE_VIEW(tree1_w);\r\nGtkCellRenderer *renderer;\r\nGtkTreeSelection *sel;\r\nGtkTreeViewColumn *column;\r\ngtk_tree_view_set_model(view, model1);\r\ngtk_tree_view_set_headers_visible(view, TRUE);\r\ngtk_tree_view_set_rules_hint(view, TRUE);\r\ncolumn = gtk_tree_view_column_new();\r\ngtk_tree_view_append_column(view, column);\r\ngtk_tree_view_column_set_title(column, _("Options"));\r\nrenderer = gtk_cell_renderer_toggle_new();\r\ngtk_tree_view_column_pack_start(GTK_TREE_VIEW_COLUMN(column),\r\nrenderer, FALSE);\r\ngtk_tree_view_column_set_attributes(GTK_TREE_VIEW_COLUMN(column),\r\nrenderer,\r\n"active", COL_BTNACT,\r\n"inconsistent", COL_BTNINC,\r\n"visible", COL_BTNVIS,\r\n"radio", COL_BTNRAD, NULL);\r\nrenderer = gtk_cell_renderer_text_new();\r\ngtk_tree_view_column_pack_start(GTK_TREE_VIEW_COLUMN(column),\r\nrenderer, FALSE);\r\ngtk_tree_view_column_set_attributes(GTK_TREE_VIEW_COLUMN(column),\r\nrenderer,\r\n"text", COL_OPTION,\r\n"foreground-gdk",\r\nCOL_COLOR, NULL);\r\nsel = gtk_tree_view_get_selection(view);\r\ngtk_tree_selection_set_mode(sel, GTK_SELECTION_SINGLE);\r\ngtk_widget_realize(tree1_w);\r\n}\r\nvoid init_right_tree(void)\r\n{\r\nGtkTreeView *view = GTK_TREE_VIEW(tree2_w);\r\nGtkCellRenderer *renderer;\r\nGtkTreeSelection *sel;\r\nGtkTreeViewColumn *column;\r\ngint i;\r\ngtk_tree_view_set_model(view, model2);\r\ngtk_tree_view_set_headers_visible(view, TRUE);\r\ngtk_tree_view_set_rules_hint(view, TRUE);\r\ncolumn = gtk_tree_view_column_new();\r\ngtk_tree_view_append_column(view, column);\r\ngtk_tree_view_column_set_title(column, _("Options"));\r\nrenderer = gtk_cell_renderer_pixbuf_new();\r\ngtk_tree_view_column_pack_start(GTK_TREE_VIEW_COLUMN(column),\r\nrenderer, FALSE);\r\ngtk_tree_view_column_set_attributes(GTK_TREE_VIEW_COLUMN(column),\r\nrenderer,\r\n"pixbuf", COL_PIXBUF,\r\n"visible", COL_PIXVIS, NULL);\r\nrenderer = gtk_cell_renderer_toggle_new();\r\ngtk_tree_view_column_pack_start(GTK_TREE_VIEW_COLUMN(column),\r\nrenderer, FALSE);\r\ngtk_tree_view_column_set_attributes(GTK_TREE_VIEW_COLUMN(column),\r\nrenderer,\r\n"active", COL_BTNACT,\r\n"inconsistent", COL_BTNINC,\r\n"visible", COL_BTNVIS,\r\n"radio", COL_BTNRAD, NULL);\r\nrenderer = gtk_cell_renderer_text_new();\r\ngtk_tree_view_column_pack_start(GTK_TREE_VIEW_COLUMN(column),\r\nrenderer, FALSE);\r\ngtk_tree_view_column_set_attributes(GTK_TREE_VIEW_COLUMN(column),\r\nrenderer,\r\n"text", COL_OPTION,\r\n"foreground-gdk",\r\nCOL_COLOR, NULL);\r\nrenderer = gtk_cell_renderer_text_new();\r\ngtk_tree_view_insert_column_with_attributes(view, -1,\r\n_("Name"), renderer,\r\n"text", COL_NAME,\r\n"foreground-gdk",\r\nCOL_COLOR, NULL);\r\nrenderer = gtk_cell_renderer_text_new();\r\ngtk_tree_view_insert_column_with_attributes(view, -1,\r\n"N", renderer,\r\n"text", COL_NO,\r\n"foreground-gdk",\r\nCOL_COLOR, NULL);\r\nrenderer = gtk_cell_renderer_text_new();\r\ngtk_tree_view_insert_column_with_attributes(view, -1,\r\n"M", renderer,\r\n"text", COL_MOD,\r\n"foreground-gdk",\r\nCOL_COLOR, NULL);\r\nrenderer = gtk_cell_renderer_text_new();\r\ngtk_tree_view_insert_column_with_attributes(view, -1,\r\n"Y", renderer,\r\n"text", COL_YES,\r\n"foreground-gdk",\r\nCOL_COLOR, NULL);\r\nrenderer = gtk_cell_renderer_text_new();\r\ngtk_tree_view_insert_column_with_attributes(view, -1,\r\n_("Value"), renderer,\r\n"text", COL_VALUE,\r\n"editable",\r\nCOL_EDIT,\r\n"foreground-gdk",\r\nCOL_COLOR, NULL);\r\ng_signal_connect(G_OBJECT(renderer), "edited",\r\nG_CALLBACK(renderer_edited), NULL);\r\ncolumn = gtk_tree_view_get_column(view, COL_NAME);\r\ngtk_tree_view_column_set_visible(column, show_name);\r\ncolumn = gtk_tree_view_get_column(view, COL_NO);\r\ngtk_tree_view_column_set_visible(column, show_range);\r\ncolumn = gtk_tree_view_get_column(view, COL_MOD);\r\ngtk_tree_view_column_set_visible(column, show_range);\r\ncolumn = gtk_tree_view_get_column(view, COL_YES);\r\ngtk_tree_view_column_set_visible(column, show_range);\r\ncolumn = gtk_tree_view_get_column(view, COL_VALUE);\r\ngtk_tree_view_column_set_visible(column, show_value);\r\nif (resizeable) {\r\nfor (i = 0; i < COL_VALUE; i++) {\r\ncolumn = gtk_tree_view_get_column(view, i);\r\ngtk_tree_view_column_set_resizable(column, TRUE);\r\n}\r\n}\r\nsel = gtk_tree_view_get_selection(view);\r\ngtk_tree_selection_set_mode(sel, GTK_SELECTION_SINGLE);\r\n}\r\nstatic void text_insert_help(struct menu *menu)\r\n{\r\nGtkTextBuffer *buffer;\r\nGtkTextIter start, end;\r\nconst char *prompt = _(menu_get_prompt(menu));\r\nstruct gstr help = str_new();\r\nmenu_get_ext_help(menu, &help);\r\nbuffer = gtk_text_view_get_buffer(GTK_TEXT_VIEW(text_w));\r\ngtk_text_buffer_get_bounds(buffer, &start, &end);\r\ngtk_text_buffer_delete(buffer, &start, &end);\r\ngtk_text_view_set_left_margin(GTK_TEXT_VIEW(text_w), 15);\r\ngtk_text_buffer_get_end_iter(buffer, &end);\r\ngtk_text_buffer_insert_with_tags(buffer, &end, prompt, -1, tag1,\r\nNULL);\r\ngtk_text_buffer_insert_at_cursor(buffer, "\n\n", 2);\r\ngtk_text_buffer_get_end_iter(buffer, &end);\r\ngtk_text_buffer_insert_with_tags(buffer, &end, str_get(&help), -1, tag2,\r\nNULL);\r\nstr_free(&help);\r\n}\r\nstatic void text_insert_msg(const char *title, const char *message)\r\n{\r\nGtkTextBuffer *buffer;\r\nGtkTextIter start, end;\r\nconst char *msg = message;\r\nbuffer = gtk_text_view_get_buffer(GTK_TEXT_VIEW(text_w));\r\ngtk_text_buffer_get_bounds(buffer, &start, &end);\r\ngtk_text_buffer_delete(buffer, &start, &end);\r\ngtk_text_view_set_left_margin(GTK_TEXT_VIEW(text_w), 15);\r\ngtk_text_buffer_get_end_iter(buffer, &end);\r\ngtk_text_buffer_insert_with_tags(buffer, &end, title, -1, tag1,\r\nNULL);\r\ngtk_text_buffer_insert_at_cursor(buffer, "\n\n", 2);\r\ngtk_text_buffer_get_end_iter(buffer, &end);\r\ngtk_text_buffer_insert_with_tags(buffer, &end, msg, -1, tag2,\r\nNULL);\r\n}\r\ngboolean on_window1_delete_event(GtkWidget * widget, GdkEvent * event,\r\ngpointer user_data)\r\n{\r\nGtkWidget *dialog, *label;\r\ngint result;\r\nif (!conf_get_changed())\r\nreturn FALSE;\r\ndialog = gtk_dialog_new_with_buttons(_("Warning !"),\r\nGTK_WINDOW(main_wnd),\r\n(GtkDialogFlags)\r\n(GTK_DIALOG_MODAL |\r\nGTK_DIALOG_DESTROY_WITH_PARENT),\r\nGTK_STOCK_OK,\r\nGTK_RESPONSE_YES,\r\nGTK_STOCK_NO,\r\nGTK_RESPONSE_NO,\r\nGTK_STOCK_CANCEL,\r\nGTK_RESPONSE_CANCEL, NULL);\r\ngtk_dialog_set_default_response(GTK_DIALOG(dialog),\r\nGTK_RESPONSE_CANCEL);\r\nlabel = gtk_label_new(_("\nSave configuration ?\n"));\r\ngtk_container_add(GTK_CONTAINER(GTK_DIALOG(dialog)->vbox), label);\r\ngtk_widget_show(label);\r\nresult = gtk_dialog_run(GTK_DIALOG(dialog));\r\nswitch (result) {\r\ncase GTK_RESPONSE_YES:\r\non_save_activate(NULL, NULL);\r\nreturn FALSE;\r\ncase GTK_RESPONSE_NO:\r\nreturn FALSE;\r\ncase GTK_RESPONSE_CANCEL:\r\ncase GTK_RESPONSE_DELETE_EVENT:\r\ndefault:\r\ngtk_widget_destroy(dialog);\r\nreturn TRUE;\r\n}\r\nreturn FALSE;\r\n}\r\nvoid on_window1_destroy(GtkObject * object, gpointer user_data)\r\n{\r\ngtk_main_quit();\r\n}\r\nvoid\r\non_window1_size_request(GtkWidget * widget,\r\nGtkRequisition * requisition, gpointer user_data)\r\n{\r\nstatic gint old_h;\r\ngint w, h;\r\nif (widget->window == NULL)\r\ngtk_window_get_default_size(GTK_WINDOW(main_wnd), &w, &h);\r\nelse\r\ngdk_window_get_size(widget->window, &w, &h);\r\nif (h == old_h)\r\nreturn;\r\nold_h = h;\r\ngtk_paned_set_position(GTK_PANED(vpaned), 2 * h / 3);\r\n}\r\nstatic void\r\nload_filename(GtkFileSelection * file_selector, gpointer user_data)\r\n{\r\nconst gchar *fn;\r\nfn = gtk_file_selection_get_filename(GTK_FILE_SELECTION\r\n(user_data));\r\nif (conf_read(fn))\r\ntext_insert_msg(_("Error"), _("Unable to load configuration !"));\r\nelse\r\ndisplay_tree(&rootmenu);\r\n}\r\nvoid on_load1_activate(GtkMenuItem * menuitem, gpointer user_data)\r\n{\r\nGtkWidget *fs;\r\nfs = gtk_file_selection_new(_("Load file..."));\r\ng_signal_connect(GTK_OBJECT(GTK_FILE_SELECTION(fs)->ok_button),\r\n"clicked",\r\nG_CALLBACK(load_filename), (gpointer) fs);\r\ng_signal_connect_swapped(GTK_OBJECT\r\n(GTK_FILE_SELECTION(fs)->ok_button),\r\n"clicked", G_CALLBACK(gtk_widget_destroy),\r\n(gpointer) fs);\r\ng_signal_connect_swapped(GTK_OBJECT\r\n(GTK_FILE_SELECTION(fs)->cancel_button),\r\n"clicked", G_CALLBACK(gtk_widget_destroy),\r\n(gpointer) fs);\r\ngtk_widget_show(fs);\r\n}\r\nvoid on_save_activate(GtkMenuItem * menuitem, gpointer user_data)\r\n{\r\nif (conf_write(NULL))\r\ntext_insert_msg(_("Error"), _("Unable to save configuration !"));\r\n}\r\nstatic void\r\nstore_filename(GtkFileSelection * file_selector, gpointer user_data)\r\n{\r\nconst gchar *fn;\r\nfn = gtk_file_selection_get_filename(GTK_FILE_SELECTION\r\n(user_data));\r\nif (conf_write(fn))\r\ntext_insert_msg(_("Error"), _("Unable to save configuration !"));\r\ngtk_widget_destroy(GTK_WIDGET(user_data));\r\n}\r\nvoid on_save_as1_activate(GtkMenuItem * menuitem, gpointer user_data)\r\n{\r\nGtkWidget *fs;\r\nfs = gtk_file_selection_new(_("Save file as..."));\r\ng_signal_connect(GTK_OBJECT(GTK_FILE_SELECTION(fs)->ok_button),\r\n"clicked",\r\nG_CALLBACK(store_filename), (gpointer) fs);\r\ng_signal_connect_swapped(GTK_OBJECT\r\n(GTK_FILE_SELECTION(fs)->ok_button),\r\n"clicked", G_CALLBACK(gtk_widget_destroy),\r\n(gpointer) fs);\r\ng_signal_connect_swapped(GTK_OBJECT\r\n(GTK_FILE_SELECTION(fs)->cancel_button),\r\n"clicked", G_CALLBACK(gtk_widget_destroy),\r\n(gpointer) fs);\r\ngtk_widget_show(fs);\r\n}\r\nvoid on_quit1_activate(GtkMenuItem * menuitem, gpointer user_data)\r\n{\r\nif (!on_window1_delete_event(NULL, NULL, NULL))\r\ngtk_widget_destroy(GTK_WIDGET(main_wnd));\r\n}\r\nvoid on_show_name1_activate(GtkMenuItem * menuitem, gpointer user_data)\r\n{\r\nGtkTreeViewColumn *col;\r\nshow_name = GTK_CHECK_MENU_ITEM(menuitem)->active;\r\ncol = gtk_tree_view_get_column(GTK_TREE_VIEW(tree2_w), COL_NAME);\r\nif (col)\r\ngtk_tree_view_column_set_visible(col, show_name);\r\n}\r\nvoid on_show_range1_activate(GtkMenuItem * menuitem, gpointer user_data)\r\n{\r\nGtkTreeViewColumn *col;\r\nshow_range = GTK_CHECK_MENU_ITEM(menuitem)->active;\r\ncol = gtk_tree_view_get_column(GTK_TREE_VIEW(tree2_w), COL_NO);\r\nif (col)\r\ngtk_tree_view_column_set_visible(col, show_range);\r\ncol = gtk_tree_view_get_column(GTK_TREE_VIEW(tree2_w), COL_MOD);\r\nif (col)\r\ngtk_tree_view_column_set_visible(col, show_range);\r\ncol = gtk_tree_view_get_column(GTK_TREE_VIEW(tree2_w), COL_YES);\r\nif (col)\r\ngtk_tree_view_column_set_visible(col, show_range);\r\n}\r\nvoid on_show_data1_activate(GtkMenuItem * menuitem, gpointer user_data)\r\n{\r\nGtkTreeViewColumn *col;\r\nshow_value = GTK_CHECK_MENU_ITEM(menuitem)->active;\r\ncol = gtk_tree_view_get_column(GTK_TREE_VIEW(tree2_w), COL_VALUE);\r\nif (col)\r\ngtk_tree_view_column_set_visible(col, show_value);\r\n}\r\nvoid\r\non_set_option_mode1_activate(GtkMenuItem *menuitem, gpointer user_data)\r\n{\r\nopt_mode = OPT_NORMAL;\r\ngtk_tree_store_clear(tree2);\r\ndisplay_tree(&rootmenu);\r\n}\r\nvoid\r\non_set_option_mode2_activate(GtkMenuItem *menuitem, gpointer user_data)\r\n{\r\nopt_mode = OPT_ALL;\r\ngtk_tree_store_clear(tree2);\r\ndisplay_tree(&rootmenu);\r\n}\r\nvoid\r\non_set_option_mode3_activate(GtkMenuItem *menuitem, gpointer user_data)\r\n{\r\nopt_mode = OPT_PROMPT;\r\ngtk_tree_store_clear(tree2);\r\ndisplay_tree(&rootmenu);\r\n}\r\nvoid on_introduction1_activate(GtkMenuItem * menuitem, gpointer user_data)\r\n{\r\nGtkWidget *dialog;\r\nconst gchar *intro_text = _(\r\n"Welcome to gkc, the GTK+ graphical configuration tool\n"\r\n"For each option, a blank box indicates the feature is disabled, a\n"\r\n"check indicates it is enabled, and a dot indicates that it is to\n"\r\n"be compiled as a module. Clicking on the box will cycle through the three states.\n"\r\n"\n"\r\n"If you do not see an option (e.g., a device driver) that you\n"\r\n"believe should be present, try turning on Show All Options\n"\r\n"under the Options menu.\n"\r\n"Although there is no cross reference yet to help you figure out\n"\r\n"what other options must be enabled to support the option you\n"\r\n"are interested in, you can still view the help of a grayed-out\n"\r\n"option.\n"\r\n"\n"\r\n"Toggling Show Debug Info under the Options menu will show \n"\r\n"the dependencies, which you can then match by examining other options.");\r\ndialog = gtk_message_dialog_new(GTK_WINDOW(main_wnd),\r\nGTK_DIALOG_DESTROY_WITH_PARENT,\r\nGTK_MESSAGE_INFO,\r\nGTK_BUTTONS_CLOSE, "%s", intro_text);\r\ng_signal_connect_swapped(GTK_OBJECT(dialog), "response",\r\nG_CALLBACK(gtk_widget_destroy),\r\nGTK_OBJECT(dialog));\r\ngtk_widget_show_all(dialog);\r\n}\r\nvoid on_about1_activate(GtkMenuItem * menuitem, gpointer user_data)\r\n{\r\nGtkWidget *dialog;\r\nconst gchar *about_text =\r\n_("gkc is copyright (c) 2002 Romain Lievin <roms@lpg.ticalc.org>.\n"\r\n"Based on the source code from Roman Zippel.\n");\r\ndialog = gtk_message_dialog_new(GTK_WINDOW(main_wnd),\r\nGTK_DIALOG_DESTROY_WITH_PARENT,\r\nGTK_MESSAGE_INFO,\r\nGTK_BUTTONS_CLOSE, "%s", about_text);\r\ng_signal_connect_swapped(GTK_OBJECT(dialog), "response",\r\nG_CALLBACK(gtk_widget_destroy),\r\nGTK_OBJECT(dialog));\r\ngtk_widget_show_all(dialog);\r\n}\r\nvoid on_license1_activate(GtkMenuItem * menuitem, gpointer user_data)\r\n{\r\nGtkWidget *dialog;\r\nconst gchar *license_text =\r\n_("gkc is released under the terms of the GNU GPL v2.\n"\r\n"For more information, please see the source code or\n"\r\n"visit http://www.fsf.org/licenses/licenses.html\n");\r\ndialog = gtk_message_dialog_new(GTK_WINDOW(main_wnd),\r\nGTK_DIALOG_DESTROY_WITH_PARENT,\r\nGTK_MESSAGE_INFO,\r\nGTK_BUTTONS_CLOSE, "%s", license_text);\r\ng_signal_connect_swapped(GTK_OBJECT(dialog), "response",\r\nG_CALLBACK(gtk_widget_destroy),\r\nGTK_OBJECT(dialog));\r\ngtk_widget_show_all(dialog);\r\n}\r\nvoid on_back_clicked(GtkButton * button, gpointer user_data)\r\n{\r\nenum prop_type ptype;\r\ncurrent = current->parent;\r\nptype = current->prompt ? current->prompt->type : P_UNKNOWN;\r\nif (ptype != P_MENU)\r\ncurrent = current->parent;\r\ndisplay_tree_part();\r\nif (current == &rootmenu)\r\ngtk_widget_set_sensitive(back_btn, FALSE);\r\n}\r\nvoid on_load_clicked(GtkButton * button, gpointer user_data)\r\n{\r\non_load1_activate(NULL, user_data);\r\n}\r\nvoid on_single_clicked(GtkButton * button, gpointer user_data)\r\n{\r\nview_mode = SINGLE_VIEW;\r\ngtk_widget_hide(tree1_w);\r\ncurrent = &rootmenu;\r\ndisplay_tree_part();\r\n}\r\nvoid on_split_clicked(GtkButton * button, gpointer user_data)\r\n{\r\ngint w, h;\r\nview_mode = SPLIT_VIEW;\r\ngtk_widget_show(tree1_w);\r\ngtk_window_get_default_size(GTK_WINDOW(main_wnd), &w, &h);\r\ngtk_paned_set_position(GTK_PANED(hpaned), w / 2);\r\nif (tree2)\r\ngtk_tree_store_clear(tree2);\r\ndisplay_list();\r\ngtk_widget_set_sensitive(back_btn, FALSE);\r\n}\r\nvoid on_full_clicked(GtkButton * button, gpointer user_data)\r\n{\r\nview_mode = FULL_VIEW;\r\ngtk_widget_hide(tree1_w);\r\nif (tree2)\r\ngtk_tree_store_clear(tree2);\r\ndisplay_tree(&rootmenu);\r\ngtk_widget_set_sensitive(back_btn, FALSE);\r\n}\r\nvoid on_collapse_clicked(GtkButton * button, gpointer user_data)\r\n{\r\ngtk_tree_view_collapse_all(GTK_TREE_VIEW(tree2_w));\r\n}\r\nvoid on_expand_clicked(GtkButton * button, gpointer user_data)\r\n{\r\ngtk_tree_view_expand_all(GTK_TREE_VIEW(tree2_w));\r\n}\r\nstatic void renderer_edited(GtkCellRendererText * cell,\r\nconst gchar * path_string,\r\nconst gchar * new_text, gpointer user_data)\r\n{\r\nGtkTreePath *path = gtk_tree_path_new_from_string(path_string);\r\nGtkTreeIter iter;\r\nconst char *old_def, *new_def;\r\nstruct menu *menu;\r\nstruct symbol *sym;\r\nif (!gtk_tree_model_get_iter(model2, &iter, path))\r\nreturn;\r\ngtk_tree_model_get(model2, &iter, COL_MENU, &menu, -1);\r\nsym = menu->sym;\r\ngtk_tree_model_get(model2, &iter, COL_VALUE, &old_def, -1);\r\nnew_def = new_text;\r\nsym_set_string_value(sym, new_def);\r\nupdate_tree(&rootmenu, NULL);\r\ngtk_tree_path_free(path);\r\n}\r\nstatic void change_sym_value(struct menu *menu, gint col)\r\n{\r\nstruct symbol *sym = menu->sym;\r\ntristate newval;\r\nif (!sym)\r\nreturn;\r\nif (col == COL_NO)\r\nnewval = no;\r\nelse if (col == COL_MOD)\r\nnewval = mod;\r\nelse if (col == COL_YES)\r\nnewval = yes;\r\nelse\r\nreturn;\r\nswitch (sym_get_type(sym)) {\r\ncase S_BOOLEAN:\r\ncase S_TRISTATE:\r\nif (!sym_tristate_within_range(sym, newval))\r\nnewval = yes;\r\nsym_set_tristate_value(sym, newval);\r\nif (view_mode == FULL_VIEW)\r\nupdate_tree(&rootmenu, NULL);\r\nelse if (view_mode == SPLIT_VIEW) {\r\nupdate_tree(browsed, NULL);\r\ndisplay_list();\r\n}\r\nelse if (view_mode == SINGLE_VIEW)\r\ndisplay_tree_part();\r\nbreak;\r\ncase S_INT:\r\ncase S_HEX:\r\ncase S_STRING:\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nstatic void toggle_sym_value(struct menu *menu)\r\n{\r\nif (!menu->sym)\r\nreturn;\r\nsym_toggle_tristate_value(menu->sym);\r\nif (view_mode == FULL_VIEW)\r\nupdate_tree(&rootmenu, NULL);\r\nelse if (view_mode == SPLIT_VIEW) {\r\nupdate_tree(browsed, NULL);\r\ndisplay_list();\r\n}\r\nelse if (view_mode == SINGLE_VIEW)\r\ndisplay_tree_part();\r\n}\r\nstatic gint column2index(GtkTreeViewColumn * column)\r\n{\r\ngint i;\r\nfor (i = 0; i < COL_NUMBER; i++) {\r\nGtkTreeViewColumn *col;\r\ncol = gtk_tree_view_get_column(GTK_TREE_VIEW(tree2_w), i);\r\nif (col == column)\r\nreturn i;\r\n}\r\nreturn -1;\r\n}\r\ngboolean\r\non_treeview2_button_press_event(GtkWidget * widget,\r\nGdkEventButton * event, gpointer user_data)\r\n{\r\nGtkTreeView *view = GTK_TREE_VIEW(widget);\r\nGtkTreePath *path;\r\nGtkTreeViewColumn *column;\r\nGtkTreeIter iter;\r\nstruct menu *menu;\r\ngint col;\r\n#if GTK_CHECK_VERSION(2,1,4)\r\ngint tx = (gint) event->x;\r\ngint ty = (gint) event->y;\r\ngint cx, cy;\r\ngtk_tree_view_get_path_at_pos(view, tx, ty, &path, &column, &cx,\r\n&cy);\r\n#else\r\ngtk_tree_view_get_cursor(view, &path, &column);\r\n#endif\r\nif (path == NULL)\r\nreturn FALSE;\r\nif (!gtk_tree_model_get_iter(model2, &iter, path))\r\nreturn FALSE;\r\ngtk_tree_model_get(model2, &iter, COL_MENU, &menu, -1);\r\ncol = column2index(column);\r\nif (event->type == GDK_2BUTTON_PRESS) {\r\nenum prop_type ptype;\r\nptype = menu->prompt ? menu->prompt->type : P_UNKNOWN;\r\nif (ptype == P_MENU && view_mode != FULL_VIEW && col == COL_OPTION) {\r\ncurrent = menu;\r\ndisplay_tree_part();\r\ngtk_widget_set_sensitive(back_btn, TRUE);\r\n} else if ((col == COL_OPTION)) {\r\ntoggle_sym_value(menu);\r\ngtk_tree_view_expand_row(view, path, TRUE);\r\n}\r\n} else {\r\nif (col == COL_VALUE) {\r\ntoggle_sym_value(menu);\r\ngtk_tree_view_expand_row(view, path, TRUE);\r\n} else if (col == COL_NO || col == COL_MOD\r\n|| col == COL_YES) {\r\nchange_sym_value(menu, col);\r\ngtk_tree_view_expand_row(view, path, TRUE);\r\n}\r\n}\r\nreturn FALSE;\r\n}\r\ngboolean\r\non_treeview2_key_press_event(GtkWidget * widget,\r\nGdkEventKey * event, gpointer user_data)\r\n{\r\nGtkTreeView *view = GTK_TREE_VIEW(widget);\r\nGtkTreePath *path;\r\nGtkTreeViewColumn *column;\r\nGtkTreeIter iter;\r\nstruct menu *menu;\r\ngint col;\r\ngtk_tree_view_get_cursor(view, &path, &column);\r\nif (path == NULL)\r\nreturn FALSE;\r\nif (event->keyval == GDK_space) {\r\nif (gtk_tree_view_row_expanded(view, path))\r\ngtk_tree_view_collapse_row(view, path);\r\nelse\r\ngtk_tree_view_expand_row(view, path, FALSE);\r\nreturn TRUE;\r\n}\r\nif (event->keyval == GDK_KP_Enter) {\r\n}\r\nif (widget == tree1_w)\r\nreturn FALSE;\r\ngtk_tree_model_get_iter(model2, &iter, path);\r\ngtk_tree_model_get(model2, &iter, COL_MENU, &menu, -1);\r\nif (!strcasecmp(event->string, "n"))\r\ncol = COL_NO;\r\nelse if (!strcasecmp(event->string, "m"))\r\ncol = COL_MOD;\r\nelse if (!strcasecmp(event->string, "y"))\r\ncol = COL_YES;\r\nelse\r\ncol = -1;\r\nchange_sym_value(menu, col);\r\nreturn FALSE;\r\n}\r\nvoid\r\non_treeview2_cursor_changed(GtkTreeView * treeview, gpointer user_data)\r\n{\r\nGtkTreeSelection *selection;\r\nGtkTreeIter iter;\r\nstruct menu *menu;\r\nselection = gtk_tree_view_get_selection(treeview);\r\nif (gtk_tree_selection_get_selected(selection, &model2, &iter)) {\r\ngtk_tree_model_get(model2, &iter, COL_MENU, &menu, -1);\r\ntext_insert_help(menu);\r\n}\r\n}\r\ngboolean\r\non_treeview1_button_press_event(GtkWidget * widget,\r\nGdkEventButton * event, gpointer user_data)\r\n{\r\nGtkTreeView *view = GTK_TREE_VIEW(widget);\r\nGtkTreePath *path;\r\nGtkTreeViewColumn *column;\r\nGtkTreeIter iter;\r\nstruct menu *menu;\r\ngint tx = (gint) event->x;\r\ngint ty = (gint) event->y;\r\ngint cx, cy;\r\ngtk_tree_view_get_path_at_pos(view, tx, ty, &path, &column, &cx,\r\n&cy);\r\nif (path == NULL)\r\nreturn FALSE;\r\ngtk_tree_model_get_iter(model1, &iter, path);\r\ngtk_tree_model_get(model1, &iter, COL_MENU, &menu, -1);\r\nif (event->type == GDK_2BUTTON_PRESS) {\r\ntoggle_sym_value(menu);\r\ncurrent = menu;\r\ndisplay_tree_part();\r\n} else {\r\nbrowsed = menu;\r\ndisplay_tree_part();\r\n}\r\ngtk_widget_realize(tree2_w);\r\ngtk_tree_view_set_cursor(view, path, NULL, FALSE);\r\ngtk_widget_grab_focus(tree2_w);\r\nreturn FALSE;\r\n}\r\nstatic gchar **fill_row(struct menu *menu)\r\n{\r\nstatic gchar *row[COL_NUMBER];\r\nstruct symbol *sym = menu->sym;\r\nconst char *def;\r\nint stype;\r\ntristate val;\r\nenum prop_type ptype;\r\nint i;\r\nfor (i = COL_OPTION; i <= COL_COLOR; i++)\r\ng_free(row[i]);\r\nbzero(row, sizeof(row));\r\nrow[COL_OPTION] =\r\ng_strdup_printf("%s %s", _(menu_get_prompt(menu)),\r\nsym && !sym_has_value(sym) ? "(NEW)" : "");\r\nif (opt_mode == OPT_ALL && !menu_is_visible(menu))\r\nrow[COL_COLOR] = g_strdup("DarkGray");\r\nelse if (opt_mode == OPT_PROMPT &&\r\nmenu_has_prompt(menu) && !menu_is_visible(menu))\r\nrow[COL_COLOR] = g_strdup("DarkGray");\r\nelse\r\nrow[COL_COLOR] = g_strdup("Black");\r\nptype = menu->prompt ? menu->prompt->type : P_UNKNOWN;\r\nswitch (ptype) {\r\ncase P_MENU:\r\nrow[COL_PIXBUF] = (gchar *) xpm_menu;\r\nif (view_mode == SINGLE_VIEW)\r\nrow[COL_PIXVIS] = GINT_TO_POINTER(TRUE);\r\nrow[COL_BTNVIS] = GINT_TO_POINTER(FALSE);\r\nbreak;\r\ncase P_COMMENT:\r\nrow[COL_PIXBUF] = (gchar *) xpm_void;\r\nrow[COL_PIXVIS] = GINT_TO_POINTER(FALSE);\r\nrow[COL_BTNVIS] = GINT_TO_POINTER(FALSE);\r\nbreak;\r\ndefault:\r\nrow[COL_PIXBUF] = (gchar *) xpm_void;\r\nrow[COL_PIXVIS] = GINT_TO_POINTER(FALSE);\r\nrow[COL_BTNVIS] = GINT_TO_POINTER(TRUE);\r\nbreak;\r\n}\r\nif (!sym)\r\nreturn row;\r\nrow[COL_NAME] = g_strdup(sym->name);\r\nsym_calc_value(sym);\r\nsym->flags &= ~SYMBOL_CHANGED;\r\nif (sym_is_choice(sym)) {\r\nstruct menu *child;\r\nstruct symbol *def_sym = sym_get_choice_value(sym);\r\nstruct menu *def_menu = NULL;\r\nrow[COL_BTNVIS] = GINT_TO_POINTER(FALSE);\r\nfor (child = menu->list; child; child = child->next) {\r\nif (menu_is_visible(child)\r\n&& child->sym == def_sym)\r\ndef_menu = child;\r\n}\r\nif (def_menu)\r\nrow[COL_VALUE] =\r\ng_strdup(_(menu_get_prompt(def_menu)));\r\n}\r\nif (sym->flags & SYMBOL_CHOICEVAL)\r\nrow[COL_BTNRAD] = GINT_TO_POINTER(TRUE);\r\nstype = sym_get_type(sym);\r\nswitch (stype) {\r\ncase S_BOOLEAN:\r\nif (GPOINTER_TO_INT(row[COL_PIXVIS]) == FALSE)\r\nrow[COL_BTNVIS] = GINT_TO_POINTER(TRUE);\r\nif (sym_is_choice(sym))\r\nbreak;\r\ncase S_TRISTATE:\r\nval = sym_get_tristate_value(sym);\r\nswitch (val) {\r\ncase no:\r\nrow[COL_NO] = g_strdup("N");\r\nrow[COL_VALUE] = g_strdup("N");\r\nrow[COL_BTNACT] = GINT_TO_POINTER(FALSE);\r\nrow[COL_BTNINC] = GINT_TO_POINTER(FALSE);\r\nbreak;\r\ncase mod:\r\nrow[COL_MOD] = g_strdup("M");\r\nrow[COL_VALUE] = g_strdup("M");\r\nrow[COL_BTNINC] = GINT_TO_POINTER(TRUE);\r\nbreak;\r\ncase yes:\r\nrow[COL_YES] = g_strdup("Y");\r\nrow[COL_VALUE] = g_strdup("Y");\r\nrow[COL_BTNACT] = GINT_TO_POINTER(TRUE);\r\nrow[COL_BTNINC] = GINT_TO_POINTER(FALSE);\r\nbreak;\r\n}\r\nif (val != no && sym_tristate_within_range(sym, no))\r\nrow[COL_NO] = g_strdup("_");\r\nif (val != mod && sym_tristate_within_range(sym, mod))\r\nrow[COL_MOD] = g_strdup("_");\r\nif (val != yes && sym_tristate_within_range(sym, yes))\r\nrow[COL_YES] = g_strdup("_");\r\nbreak;\r\ncase S_INT:\r\ncase S_HEX:\r\ncase S_STRING:\r\ndef = sym_get_string_value(sym);\r\nrow[COL_VALUE] = g_strdup(def);\r\nrow[COL_EDIT] = GINT_TO_POINTER(TRUE);\r\nrow[COL_BTNVIS] = GINT_TO_POINTER(FALSE);\r\nbreak;\r\n}\r\nreturn row;\r\n}\r\nstatic void set_node(GtkTreeIter * node, struct menu *menu, gchar ** row)\r\n{\r\nGdkColor color;\r\ngboolean success;\r\nGdkPixbuf *pix;\r\npix = gdk_pixbuf_new_from_xpm_data((const char **)\r\nrow[COL_PIXBUF]);\r\ngdk_color_parse(row[COL_COLOR], &color);\r\ngdk_colormap_alloc_colors(gdk_colormap_get_system(), &color, 1,\r\nFALSE, FALSE, &success);\r\ngtk_tree_store_set(tree, node,\r\nCOL_OPTION, row[COL_OPTION],\r\nCOL_NAME, row[COL_NAME],\r\nCOL_NO, row[COL_NO],\r\nCOL_MOD, row[COL_MOD],\r\nCOL_YES, row[COL_YES],\r\nCOL_VALUE, row[COL_VALUE],\r\nCOL_MENU, (gpointer) menu,\r\nCOL_COLOR, &color,\r\nCOL_EDIT, GPOINTER_TO_INT(row[COL_EDIT]),\r\nCOL_PIXBUF, pix,\r\nCOL_PIXVIS, GPOINTER_TO_INT(row[COL_PIXVIS]),\r\nCOL_BTNVIS, GPOINTER_TO_INT(row[COL_BTNVIS]),\r\nCOL_BTNACT, GPOINTER_TO_INT(row[COL_BTNACT]),\r\nCOL_BTNINC, GPOINTER_TO_INT(row[COL_BTNINC]),\r\nCOL_BTNRAD, GPOINTER_TO_INT(row[COL_BTNRAD]),\r\n-1);\r\ng_object_unref(pix);\r\n}\r\nstatic void place_node(struct menu *menu, char **row)\r\n{\r\nGtkTreeIter *parent = parents[indent - 1];\r\nGtkTreeIter *node = parents[indent];\r\ngtk_tree_store_append(tree, node, parent);\r\nset_node(node, menu, row);\r\n}\r\nGtkTreeIter *gtktree_iter_find_node(GtkTreeIter * parent,\r\nstruct menu *tofind)\r\n{\r\nGtkTreeIter iter;\r\nGtkTreeIter *child = &iter;\r\ngboolean valid;\r\nGtkTreeIter *ret;\r\nvalid = gtk_tree_model_iter_children(model2, child, parent);\r\nwhile (valid) {\r\nstruct menu *menu;\r\ngtk_tree_model_get(model2, child, 6, &menu, -1);\r\nif (menu == tofind) {\r\nmemcpy(&found, child, sizeof(GtkTreeIter));\r\nreturn &found;\r\n}\r\nret = gtktree_iter_find_node(child, tofind);\r\nif (ret)\r\nreturn ret;\r\nvalid = gtk_tree_model_iter_next(model2, child);\r\n}\r\nreturn NULL;\r\n}\r\nstatic void update_tree(struct menu *src, GtkTreeIter * dst)\r\n{\r\nstruct menu *child1;\r\nGtkTreeIter iter, tmp;\r\nGtkTreeIter *child2 = &iter;\r\ngboolean valid;\r\nGtkTreeIter *sibling;\r\nstruct symbol *sym;\r\nstruct menu *menu1, *menu2;\r\nif (src == &rootmenu)\r\nindent = 1;\r\nvalid = gtk_tree_model_iter_children(model2, child2, dst);\r\nfor (child1 = src->list; child1; child1 = child1->next) {\r\nsym = child1->sym;\r\nreparse:\r\nmenu1 = child1;\r\nif (valid)\r\ngtk_tree_model_get(model2, child2, COL_MENU,\r\n&menu2, -1);\r\nelse\r\nmenu2 = NULL;\r\n#ifdef DEBUG\r\nprintf("%*c%s | %s\n", indent, ' ',\r\nmenu1 ? menu_get_prompt(menu1) : "nil",\r\nmenu2 ? menu_get_prompt(menu2) : "nil");\r\n#endif\r\nif ((opt_mode == OPT_NORMAL && !menu_is_visible(child1)) ||\r\n(opt_mode == OPT_PROMPT && !menu_has_prompt(child1)) ||\r\n(opt_mode == OPT_ALL && !menu_get_prompt(child1))) {\r\nif (gtktree_iter_find_node(dst, menu1) != NULL) {\r\nmemcpy(&tmp, child2, sizeof(GtkTreeIter));\r\nvalid = gtk_tree_model_iter_next(model2,\r\nchild2);\r\ngtk_tree_store_remove(tree2, &tmp);\r\nif (!valid)\r\nreturn;\r\nelse\r\ngoto reparse;\r\n} else\r\ncontinue;\r\n}\r\nif (menu1 != menu2) {\r\nif (gtktree_iter_find_node(dst, menu1) == NULL) {\r\nif (!valid && !menu2)\r\nsibling = NULL;\r\nelse\r\nsibling = child2;\r\ngtk_tree_store_insert_before(tree2,\r\nchild2,\r\ndst, sibling);\r\nset_node(child2, menu1, fill_row(menu1));\r\nif (menu2 == NULL)\r\nvalid = TRUE;\r\n} else {\r\nmemcpy(&tmp, child2, sizeof(GtkTreeIter));\r\nvalid = gtk_tree_model_iter_next(model2,\r\nchild2);\r\ngtk_tree_store_remove(tree2, &tmp);\r\nif (!valid)\r\nreturn;\r\nelse\r\ngoto reparse;\r\n}\r\n} else if (sym && (sym->flags & SYMBOL_CHANGED)) {\r\nset_node(child2, menu1, fill_row(menu1));\r\n}\r\nindent++;\r\nupdate_tree(child1, child2);\r\nindent--;\r\nvalid = gtk_tree_model_iter_next(model2, child2);\r\n}\r\n}\r\nstatic void display_tree(struct menu *menu)\r\n{\r\nstruct symbol *sym;\r\nstruct property *prop;\r\nstruct menu *child;\r\nenum prop_type ptype;\r\nif (menu == &rootmenu) {\r\nindent = 1;\r\ncurrent = &rootmenu;\r\n}\r\nfor (child = menu->list; child; child = child->next) {\r\nprop = child->prompt;\r\nsym = child->sym;\r\nptype = prop ? prop->type : P_UNKNOWN;\r\nif (sym)\r\nsym->flags &= ~SYMBOL_CHANGED;\r\nif ((view_mode == SPLIT_VIEW)\r\n&& !(child->flags & MENU_ROOT) && (tree == tree1))\r\ncontinue;\r\nif ((view_mode == SPLIT_VIEW) && (child->flags & MENU_ROOT)\r\n&& (tree == tree2))\r\ncontinue;\r\nif ((opt_mode == OPT_NORMAL && menu_is_visible(child)) ||\r\n(opt_mode == OPT_PROMPT && menu_has_prompt(child)) ||\r\n(opt_mode == OPT_ALL && menu_get_prompt(child)))\r\nplace_node(child, fill_row(child));\r\n#ifdef DEBUG\r\nprintf("%*c%s: ", indent, ' ', menu_get_prompt(child));\r\nprintf("%s", child->flags & MENU_ROOT ? "rootmenu | " : "");\r\nprintf("%s", prop_get_type_name(ptype));\r\nprintf(" | ");\r\nif (sym) {\r\nprintf("%s", sym_type_name(sym->type));\r\nprintf(" | ");\r\nprintf("%s", dbg_sym_flags(sym->flags));\r\nprintf("\n");\r\n} else\r\nprintf("\n");\r\n#endif\r\nif ((view_mode != FULL_VIEW) && (ptype == P_MENU)\r\n&& (tree == tree2))\r\ncontinue;\r\nif (view_mode == SINGLE_VIEW || view_mode == FULL_VIEW) {\r\ngtk_paned_set_position(GTK_PANED(hpaned), 0);\r\n}\r\nif (((view_mode == SINGLE_VIEW) && (menu->flags & MENU_ROOT))\r\n|| (view_mode == FULL_VIEW)\r\n|| (view_mode == SPLIT_VIEW)) {\r\nindent++;\r\ndisplay_tree(child);\r\nindent--;\r\n}\r\n}\r\n}\r\nstatic void display_tree_part(void)\r\n{\r\nif (tree2)\r\ngtk_tree_store_clear(tree2);\r\nif (view_mode == SINGLE_VIEW)\r\ndisplay_tree(current);\r\nelse if (view_mode == SPLIT_VIEW)\r\ndisplay_tree(browsed);\r\ngtk_tree_view_expand_all(GTK_TREE_VIEW(tree2_w));\r\n}\r\nstatic void display_list(void)\r\n{\r\nif (tree1)\r\ngtk_tree_store_clear(tree1);\r\ntree = tree1;\r\ndisplay_tree(&rootmenu);\r\ngtk_tree_view_expand_all(GTK_TREE_VIEW(tree1_w));\r\ntree = tree2;\r\n}\r\nvoid fixup_rootmenu(struct menu *menu)\r\n{\r\nstruct menu *child;\r\nstatic int menu_cnt = 0;\r\nmenu->flags |= MENU_ROOT;\r\nfor (child = menu->list; child; child = child->next) {\r\nif (child->prompt && child->prompt->type == P_MENU) {\r\nmenu_cnt++;\r\nfixup_rootmenu(child);\r\nmenu_cnt--;\r\n} else if (!menu_cnt)\r\nfixup_rootmenu(child);\r\n}\r\n}\r\nint main(int ac, char *av[])\r\n{\r\nconst char *name;\r\nchar *env;\r\ngchar *glade_file;\r\nbindtextdomain(PACKAGE, LOCALEDIR);\r\nbind_textdomain_codeset(PACKAGE, "UTF-8");\r\ntextdomain(PACKAGE);\r\ngtk_set_locale();\r\ngtk_init(&ac, &av);\r\nglade_init();\r\nenv = getenv(SRCTREE);\r\nif (env)\r\nglade_file = g_strconcat(env, "/scripts/kconfig/gconf.glade", NULL);\r\nelse if (av[0][0] == '/')\r\nglade_file = g_strconcat(av[0], ".glade", NULL);\r\nelse\r\nglade_file = g_strconcat(g_get_current_dir(), "/", av[0], ".glade", NULL);\r\nif (ac > 1 && av[1][0] == '-') {\r\nswitch (av[1][1]) {\r\ncase 'a':\r\nbreak;\r\ncase 's':\r\nconf_set_message_callback(NULL);\r\nbreak;\r\ncase 'h':\r\ncase '?':\r\nprintf("%s [-s] <config>\n", av[0]);\r\nexit(0);\r\n}\r\nname = av[2];\r\n} else\r\nname = av[1];\r\nconf_parse(name);\r\nfixup_rootmenu(&rootmenu);\r\nconf_read(NULL);\r\ninit_main_window(glade_file);\r\ninit_tree_model();\r\ninit_left_tree();\r\ninit_right_tree();\r\nswitch (view_mode) {\r\ncase SINGLE_VIEW:\r\ndisplay_tree_part();\r\nbreak;\r\ncase SPLIT_VIEW:\r\ndisplay_list();\r\nbreak;\r\ncase FULL_VIEW:\r\ndisplay_tree(&rootmenu);\r\nbreak;\r\n}\r\ngtk_main();\r\nreturn 0;\r\n}\r\nstatic void conf_changed(void)\r\n{\r\nbool changed = conf_get_changed();\r\ngtk_widget_set_sensitive(save_btn, changed);\r\ngtk_widget_set_sensitive(save_menu_item, changed);\r\n}
