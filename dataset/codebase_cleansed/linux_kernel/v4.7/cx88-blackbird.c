static void host_setup(struct cx88_core *core)\r\n{\r\ncx_write(MO_GPHST_SOFT_RST, 1);\r\nudelay(100);\r\ncx_write(MO_GPHST_SOFT_RST, 0);\r\nudelay(100);\r\ncx_write(MO_GPHST_WSC, 0x44444444U);\r\ncx_write(MO_GPHST_XFR, 0);\r\ncx_write(MO_GPHST_WDTH, 15);\r\ncx_write(MO_GPHST_HDSHK, 0);\r\ncx_write(MO_GPHST_MUX16, 0x44448888U);\r\ncx_write(MO_GPHST_MODE, 0);\r\n}\r\nstatic int wait_ready_gpio0_bit1(struct cx88_core *core, u32 state)\r\n{\r\nunsigned long timeout = jiffies + msecs_to_jiffies(1);\r\nu32 gpio0,need;\r\nneed = state ? 2 : 0;\r\nfor (;;) {\r\ngpio0 = cx_read(MO_GP0_IO) & 2;\r\nif (need == gpio0)\r\nreturn 0;\r\nif (time_after(jiffies,timeout))\r\nreturn -1;\r\nudelay(1);\r\n}\r\n}\r\nstatic int memory_write(struct cx88_core *core, u32 address, u32 value)\r\n{\r\ncx_writeb(P1_MDATA0, (unsigned int)value);\r\ncx_writeb(P1_MDATA1, (unsigned int)(value >> 8));\r\ncx_writeb(P1_MDATA2, (unsigned int)(value >> 16));\r\ncx_writeb(P1_MDATA3, (unsigned int)(value >> 24));\r\ncx_writeb(P1_MADDR2, (unsigned int)(address >> 16) | 0x40);\r\ncx_writeb(P1_MADDR1, (unsigned int)(address >> 8));\r\ncx_writeb(P1_MADDR0, (unsigned int)address);\r\ncx_read(P1_MDATA0);\r\ncx_read(P1_MADDR0);\r\nreturn wait_ready_gpio0_bit1(core,1);\r\n}\r\nstatic int memory_read(struct cx88_core *core, u32 address, u32 *value)\r\n{\r\nint retval;\r\nu32 val;\r\ncx_writeb(P1_MADDR2, (unsigned int)(address >> 16) & ~0xC0);\r\ncx_writeb(P1_MADDR1, (unsigned int)(address >> 8));\r\ncx_writeb(P1_MADDR0, (unsigned int)address);\r\ncx_read(P1_MADDR0);\r\nretval = wait_ready_gpio0_bit1(core,1);\r\ncx_writeb(P1_MDATA3, 0);\r\nval = (unsigned char)cx_read(P1_MDATA3) << 24;\r\ncx_writeb(P1_MDATA2, 0);\r\nval |= (unsigned char)cx_read(P1_MDATA2) << 16;\r\ncx_writeb(P1_MDATA1, 0);\r\nval |= (unsigned char)cx_read(P1_MDATA1) << 8;\r\ncx_writeb(P1_MDATA0, 0);\r\nval |= (unsigned char)cx_read(P1_MDATA0);\r\n*value = val;\r\nreturn retval;\r\n}\r\nstatic int register_write(struct cx88_core *core, u32 address, u32 value)\r\n{\r\ncx_writeb(P1_RDATA0, (unsigned int)value);\r\ncx_writeb(P1_RDATA1, (unsigned int)(value >> 8));\r\ncx_writeb(P1_RDATA2, (unsigned int)(value >> 16));\r\ncx_writeb(P1_RDATA3, (unsigned int)(value >> 24));\r\ncx_writeb(P1_RADDR0, (unsigned int)address);\r\ncx_writeb(P1_RADDR1, (unsigned int)(address >> 8));\r\ncx_writeb(P1_RRDWR, 1);\r\ncx_read(P1_RDATA0);\r\ncx_read(P1_RADDR0);\r\nreturn wait_ready_gpio0_bit1(core,1);\r\n}\r\nstatic int register_read(struct cx88_core *core, u32 address, u32 *value)\r\n{\r\nint retval;\r\nu32 val;\r\ncx_writeb(P1_RADDR0, (unsigned int)address);\r\ncx_writeb(P1_RADDR1, (unsigned int)(address >> 8));\r\ncx_writeb(P1_RRDWR, 0);\r\ncx_read(P1_RADDR0);\r\nretval = wait_ready_gpio0_bit1(core,1);\r\nval = (unsigned char)cx_read(P1_RDATA0);\r\nval |= (unsigned char)cx_read(P1_RDATA1) << 8;\r\nval |= (unsigned char)cx_read(P1_RDATA2) << 16;\r\nval |= (unsigned char)cx_read(P1_RDATA3) << 24;\r\n*value = val;\r\nreturn retval;\r\n}\r\nstatic int blackbird_mbox_func(void *priv, u32 command, int in, int out, u32 data[CX2341X_MBOX_MAX_DATA])\r\n{\r\nstruct cx8802_dev *dev = priv;\r\nunsigned long timeout;\r\nu32 value, flag, retval;\r\nint i;\r\ndprintk(1,"%s: 0x%X\n", __func__, command);\r\nmemory_read(dev->core, dev->mailbox - 4, &value);\r\nif (value != 0x12345678) {\r\ndprintk(0, "Firmware and/or mailbox pointer not initialized or corrupted\n");\r\nreturn -EIO;\r\n}\r\nmemory_read(dev->core, dev->mailbox, &flag);\r\nif (flag) {\r\ndprintk(0, "ERROR: Mailbox appears to be in use (%x)\n", flag);\r\nreturn -EIO;\r\n}\r\nflag |= 1;\r\nmemory_write(dev->core, dev->mailbox, flag);\r\nmemory_write(dev->core, dev->mailbox + 1, command);\r\nmemory_write(dev->core, dev->mailbox + 3, IVTV_API_STD_TIMEOUT);\r\nfor (i = 0; i < in; i++) {\r\nmemory_write(dev->core, dev->mailbox + 4 + i, data[i]);\r\ndprintk(1, "API Input %d = %d\n", i, data[i]);\r\n}\r\nfor (; i < CX2341X_MBOX_MAX_DATA; i++)\r\nmemory_write(dev->core, dev->mailbox + 4 + i, 0);\r\nflag |= 3;\r\nmemory_write(dev->core, dev->mailbox, flag);\r\ntimeout = jiffies + msecs_to_jiffies(1000);\r\nfor (;;) {\r\nmemory_read(dev->core, dev->mailbox, &flag);\r\nif (0 != (flag & 4))\r\nbreak;\r\nif (time_after(jiffies,timeout)) {\r\ndprintk(0, "ERROR: API Mailbox timeout %x\n", command);\r\nreturn -EIO;\r\n}\r\nudelay(10);\r\n}\r\nfor (i = 0; i < out; i++) {\r\nmemory_read(dev->core, dev->mailbox + 4 + i, data + i);\r\ndprintk(1, "API Output %d = %d\n", i, data[i]);\r\n}\r\nmemory_read(dev->core, dev->mailbox + 2, &retval);\r\ndprintk(1, "API result = %d\n",retval);\r\nflag = 0;\r\nmemory_write(dev->core, dev->mailbox, flag);\r\nreturn retval;\r\n}\r\nstatic int blackbird_api_cmd(struct cx8802_dev *dev, u32 command,\r\nu32 inputcnt, u32 outputcnt, ...)\r\n{\r\nu32 data[CX2341X_MBOX_MAX_DATA];\r\nva_list vargs;\r\nint i, err;\r\nva_start(vargs, outputcnt);\r\nfor (i = 0; i < inputcnt; i++) {\r\ndata[i] = va_arg(vargs, int);\r\n}\r\nerr = blackbird_mbox_func(dev, command, inputcnt, outputcnt, data);\r\nfor (i = 0; i < outputcnt; i++) {\r\nint *vptr = va_arg(vargs, int *);\r\n*vptr = data[i];\r\n}\r\nva_end(vargs);\r\nreturn err;\r\n}\r\nstatic int blackbird_find_mailbox(struct cx8802_dev *dev)\r\n{\r\nu32 signature[4]={0x12345678, 0x34567812, 0x56781234, 0x78123456};\r\nint signaturecnt=0;\r\nu32 value;\r\nint i;\r\nfor (i = 0; i < BLACKBIRD_FIRM_IMAGE_SIZE; i++) {\r\nmemory_read(dev->core, i, &value);\r\nif (value == signature[signaturecnt])\r\nsignaturecnt++;\r\nelse\r\nsignaturecnt = 0;\r\nif (4 == signaturecnt) {\r\ndprintk(1, "Mailbox signature found\n");\r\nreturn i+1;\r\n}\r\n}\r\ndprintk(0, "Mailbox signature values not found!\n");\r\nreturn -EIO;\r\n}\r\nstatic int blackbird_load_firmware(struct cx8802_dev *dev)\r\n{\r\nstatic const unsigned char magic[8] = {\r\n0xa7, 0x0d, 0x00, 0x00, 0x66, 0xbb, 0x55, 0xaa\r\n};\r\nconst struct firmware *firmware;\r\nint i, retval = 0;\r\nu32 value = 0;\r\nu32 checksum = 0;\r\n__le32 *dataptr;\r\nretval = register_write(dev->core, IVTV_REG_VPU, 0xFFFFFFED);\r\nretval |= register_write(dev->core, IVTV_REG_HW_BLOCKS, IVTV_CMD_HW_BLOCKS_RST);\r\nretval |= register_write(dev->core, IVTV_REG_ENC_SDRAM_REFRESH, 0x80000640);\r\nretval |= register_write(dev->core, IVTV_REG_ENC_SDRAM_PRECHARGE, 0x1A);\r\nmsleep(1);\r\nretval |= register_write(dev->core, IVTV_REG_APU, 0);\r\nif (retval < 0)\r\ndprintk(0, "Error with register_write\n");\r\nretval = request_firmware(&firmware, CX2341X_FIRM_ENC_FILENAME,\r\n&dev->pci->dev);\r\nif (retval != 0) {\r\npr_err("Hotplug firmware request failed (%s).\n",\r\nCX2341X_FIRM_ENC_FILENAME);\r\npr_err("Please fix your hotplug setup, the board will not work without firmware loaded!\n");\r\nreturn -EIO;\r\n}\r\nif (firmware->size != BLACKBIRD_FIRM_IMAGE_SIZE) {\r\npr_err("Firmware size mismatch (have %zd, expected %d)\n",\r\nfirmware->size, BLACKBIRD_FIRM_IMAGE_SIZE);\r\nrelease_firmware(firmware);\r\nreturn -EINVAL;\r\n}\r\nif (0 != memcmp(firmware->data, magic, 8)) {\r\npr_err("Firmware magic mismatch, wrong file?\n");\r\nrelease_firmware(firmware);\r\nreturn -EINVAL;\r\n}\r\ndprintk(1,"Loading firmware ...\n");\r\ndataptr = (__le32 *)firmware->data;\r\nfor (i = 0; i < (firmware->size >> 2); i++) {\r\nvalue = le32_to_cpu(*dataptr);\r\nchecksum += ~value;\r\nmemory_write(dev->core, i, value);\r\ndataptr++;\r\n}\r\nfor (i--; i >= 0; i--) {\r\nmemory_read(dev->core, i, &value);\r\nchecksum -= ~value;\r\n}\r\nrelease_firmware(firmware);\r\nif (checksum) {\r\npr_err("Firmware load might have failed (checksum mismatch).\n");\r\nreturn -EIO;\r\n}\r\ndprintk(0, "Firmware upload successful.\n");\r\nretval |= register_write(dev->core, IVTV_REG_HW_BLOCKS, IVTV_CMD_HW_BLOCKS_RST);\r\nretval |= register_read(dev->core, IVTV_REG_SPU, &value);\r\nretval |= register_write(dev->core, IVTV_REG_SPU, value & 0xFFFFFFFE);\r\nmsleep(1);\r\nretval |= register_read(dev->core, IVTV_REG_VPU, &value);\r\nretval |= register_write(dev->core, IVTV_REG_VPU, value & 0xFFFFFFE8);\r\nif (retval < 0)\r\ndprintk(0, "Error with register_write\n");\r\nreturn 0;\r\n}\r\nstatic void blackbird_codec_settings(struct cx8802_dev *dev)\r\n{\r\nstruct cx88_core *core = dev->core;\r\nblackbird_api_cmd(dev, CX2341X_ENC_SET_FRAME_SIZE, 2, 0,\r\ncore->height, core->width);\r\ndev->cxhdl.width = core->width;\r\ndev->cxhdl.height = core->height;\r\ncx2341x_handler_set_50hz(&dev->cxhdl, dev->core->tvnorm & V4L2_STD_625_50);\r\ncx2341x_handler_setup(&dev->cxhdl);\r\n}\r\nstatic int blackbird_initialize_codec(struct cx8802_dev *dev)\r\n{\r\nstruct cx88_core *core = dev->core;\r\nint version;\r\nint retval;\r\ndprintk(1,"Initialize codec\n");\r\nretval = blackbird_api_cmd(dev, CX2341X_ENC_PING_FW, 0, 0);\r\nif (retval < 0) {\r\ncx_write(MO_SRST_IO, 0);\r\ncx_write(MO_SRST_IO, 1);\r\nretval = blackbird_load_firmware(dev);\r\nif (retval < 0)\r\nreturn retval;\r\nretval = blackbird_find_mailbox(dev);\r\nif (retval < 0)\r\nreturn -1;\r\ndev->mailbox = retval;\r\nretval = blackbird_api_cmd(dev, CX2341X_ENC_PING_FW, 0, 0);\r\nif (retval < 0) {\r\ndprintk(0, "ERROR: Firmware ping failed!\n");\r\nreturn -1;\r\n}\r\nretval = blackbird_api_cmd(dev, CX2341X_ENC_GET_VERSION, 0, 1, &version);\r\nif (retval < 0) {\r\ndprintk(0, "ERROR: Firmware get encoder version failed!\n");\r\nreturn -1;\r\n}\r\ndprintk(0, "Firmware version is 0x%08x\n", version);\r\n}\r\ncx_write(MO_PINMUX_IO, 0x88);\r\ncx_clear(MO_INPUT_FORMAT, 0x100);\r\ncx_write(MO_VBOS_CONTROL, 0x84A00);\r\ncx_clear(MO_OUTPUT_FORMAT, 0x0008);\r\nblackbird_codec_settings(dev);\r\nblackbird_api_cmd(dev, CX2341X_ENC_SET_NUM_VSYNC_LINES, 2, 0,\r\nBLACKBIRD_FIELD1_SAA7115,\r\nBLACKBIRD_FIELD2_SAA7115\r\n);\r\nblackbird_api_cmd(dev, CX2341X_ENC_SET_PLACEHOLDER, 12, 0,\r\nBLACKBIRD_CUSTOM_EXTENSION_USR_DATA,\r\n0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);\r\nreturn 0;\r\n}\r\nstatic int blackbird_start_codec(struct cx8802_dev *dev)\r\n{\r\nstruct cx88_core *core = dev->core;\r\nu32 reg;\r\nint i;\r\nint lastchange = -1;\r\nint lastval = 0;\r\nfor (i = 0; (i < 10) && (i < (lastchange + 4)); i++) {\r\nreg = cx_read(AUD_STATUS);\r\ndprintk(1, "AUD_STATUS:%dL: 0x%x\n", i, reg);\r\nif ((reg & 0x0F) != lastval) {\r\nlastval = reg & 0x0F;\r\nlastchange = i;\r\n}\r\nmsleep(100);\r\n}\r\ncx_clear(AUD_VOL_CTL, (1 << 6));\r\nblackbird_api_cmd(dev, CX2341X_ENC_REFRESH_INPUT, 0, 0);\r\nblackbird_api_cmd(dev, CX2341X_ENC_INITIALIZE_INPUT, 0, 0);\r\ncx2341x_handler_set_busy(&dev->cxhdl, 1);\r\nblackbird_api_cmd(dev, CX2341X_ENC_START_CAPTURE, 2, 0,\r\nBLACKBIRD_MPEG_CAPTURE,\r\nBLACKBIRD_RAW_BITS_NONE\r\n);\r\nreturn 0;\r\n}\r\nstatic int blackbird_stop_codec(struct cx8802_dev *dev)\r\n{\r\nblackbird_api_cmd(dev, CX2341X_ENC_STOP_CAPTURE, 3, 0,\r\nBLACKBIRD_END_NOW,\r\nBLACKBIRD_MPEG_CAPTURE,\r\nBLACKBIRD_RAW_BITS_NONE\r\n);\r\ncx2341x_handler_set_busy(&dev->cxhdl, 0);\r\nreturn 0;\r\n}\r\nstatic int queue_setup(struct vb2_queue *q,\r\nunsigned int *num_buffers, unsigned int *num_planes,\r\nunsigned int sizes[], void *alloc_ctxs[])\r\n{\r\nstruct cx8802_dev *dev = q->drv_priv;\r\n*num_planes = 1;\r\ndev->ts_packet_size = 188 * 4;\r\ndev->ts_packet_count = 32;\r\nsizes[0] = dev->ts_packet_size * dev->ts_packet_count;\r\nalloc_ctxs[0] = dev->alloc_ctx;\r\nreturn 0;\r\n}\r\nstatic int buffer_prepare(struct vb2_buffer *vb)\r\n{\r\nstruct vb2_v4l2_buffer *vbuf = to_vb2_v4l2_buffer(vb);\r\nstruct cx8802_dev *dev = vb->vb2_queue->drv_priv;\r\nstruct cx88_buffer *buf = container_of(vbuf, struct cx88_buffer, vb);\r\nreturn cx8802_buf_prepare(vb->vb2_queue, dev, buf);\r\n}\r\nstatic void buffer_finish(struct vb2_buffer *vb)\r\n{\r\nstruct vb2_v4l2_buffer *vbuf = to_vb2_v4l2_buffer(vb);\r\nstruct cx8802_dev *dev = vb->vb2_queue->drv_priv;\r\nstruct cx88_buffer *buf = container_of(vbuf, struct cx88_buffer, vb);\r\nstruct cx88_riscmem *risc = &buf->risc;\r\nif (risc->cpu)\r\npci_free_consistent(dev->pci, risc->size, risc->cpu, risc->dma);\r\nmemset(risc, 0, sizeof(*risc));\r\n}\r\nstatic void buffer_queue(struct vb2_buffer *vb)\r\n{\r\nstruct vb2_v4l2_buffer *vbuf = to_vb2_v4l2_buffer(vb);\r\nstruct cx8802_dev *dev = vb->vb2_queue->drv_priv;\r\nstruct cx88_buffer *buf = container_of(vbuf, struct cx88_buffer, vb);\r\ncx8802_buf_queue(dev, buf);\r\n}\r\nstatic int start_streaming(struct vb2_queue *q, unsigned int count)\r\n{\r\nstruct cx8802_dev *dev = q->drv_priv;\r\nstruct cx88_dmaqueue *dmaq = &dev->mpegq;\r\nstruct cx8802_driver *drv;\r\nstruct cx88_buffer *buf;\r\nunsigned long flags;\r\nint err;\r\ndrv = cx8802_get_driver(dev, CX88_MPEG_BLACKBIRD);\r\nif (!drv) {\r\ndprintk(1, "%s: blackbird driver is not loaded\n", __func__);\r\nerr = -ENODEV;\r\ngoto fail;\r\n}\r\nerr = drv->request_acquire(drv);\r\nif (err != 0) {\r\ndprintk(1, "%s: Unable to acquire hardware, %d\n", __func__, err);\r\ngoto fail;\r\n}\r\nif (blackbird_initialize_codec(dev) < 0) {\r\ndrv->request_release(drv);\r\nerr = -EINVAL;\r\ngoto fail;\r\n}\r\nerr = blackbird_start_codec(dev);\r\nif (err == 0) {\r\nbuf = list_entry(dmaq->active.next, struct cx88_buffer, list);\r\ncx8802_start_dma(dev, dmaq, buf);\r\nreturn 0;\r\n}\r\nfail:\r\nspin_lock_irqsave(&dev->slock, flags);\r\nwhile (!list_empty(&dmaq->active)) {\r\nstruct cx88_buffer *buf = list_entry(dmaq->active.next,\r\nstruct cx88_buffer, list);\r\nlist_del(&buf->list);\r\nvb2_buffer_done(&buf->vb.vb2_buf, VB2_BUF_STATE_QUEUED);\r\n}\r\nspin_unlock_irqrestore(&dev->slock, flags);\r\nreturn err;\r\n}\r\nstatic void stop_streaming(struct vb2_queue *q)\r\n{\r\nstruct cx8802_dev *dev = q->drv_priv;\r\nstruct cx88_dmaqueue *dmaq = &dev->mpegq;\r\nstruct cx8802_driver *drv = NULL;\r\nunsigned long flags;\r\ncx8802_cancel_buffers(dev);\r\nblackbird_stop_codec(dev);\r\ndrv = cx8802_get_driver(dev, CX88_MPEG_BLACKBIRD);\r\nWARN_ON(!drv);\r\nif (drv)\r\ndrv->request_release(drv);\r\nspin_lock_irqsave(&dev->slock, flags);\r\nwhile (!list_empty(&dmaq->active)) {\r\nstruct cx88_buffer *buf = list_entry(dmaq->active.next,\r\nstruct cx88_buffer, list);\r\nlist_del(&buf->list);\r\nvb2_buffer_done(&buf->vb.vb2_buf, VB2_BUF_STATE_ERROR);\r\n}\r\nspin_unlock_irqrestore(&dev->slock, flags);\r\n}\r\nstatic int vidioc_querycap(struct file *file, void *priv,\r\nstruct v4l2_capability *cap)\r\n{\r\nstruct cx8802_dev *dev = video_drvdata(file);\r\nstruct cx88_core *core = dev->core;\r\nstrcpy(cap->driver, "cx88_blackbird");\r\nsprintf(cap->bus_info, "PCI:%s", pci_name(dev->pci));\r\ncx88_querycap(file, core, cap);\r\nreturn 0;\r\n}\r\nstatic int vidioc_enum_fmt_vid_cap (struct file *file, void *priv,\r\nstruct v4l2_fmtdesc *f)\r\n{\r\nif (f->index != 0)\r\nreturn -EINVAL;\r\nstrlcpy(f->description, "MPEG", sizeof(f->description));\r\nf->pixelformat = V4L2_PIX_FMT_MPEG;\r\nf->flags = V4L2_FMT_FLAG_COMPRESSED;\r\nreturn 0;\r\n}\r\nstatic int vidioc_g_fmt_vid_cap(struct file *file, void *priv,\r\nstruct v4l2_format *f)\r\n{\r\nstruct cx8802_dev *dev = video_drvdata(file);\r\nstruct cx88_core *core = dev->core;\r\nf->fmt.pix.pixelformat = V4L2_PIX_FMT_MPEG;\r\nf->fmt.pix.bytesperline = 0;\r\nf->fmt.pix.sizeimage = dev->ts_packet_size * dev->ts_packet_count;\r\nf->fmt.pix.colorspace = V4L2_COLORSPACE_SMPTE170M;\r\nf->fmt.pix.width = core->width;\r\nf->fmt.pix.height = core->height;\r\nf->fmt.pix.field = core->field;\r\nreturn 0;\r\n}\r\nstatic int vidioc_try_fmt_vid_cap(struct file *file, void *priv,\r\nstruct v4l2_format *f)\r\n{\r\nstruct cx8802_dev *dev = video_drvdata(file);\r\nstruct cx88_core *core = dev->core;\r\nunsigned maxw, maxh;\r\nenum v4l2_field field;\r\nf->fmt.pix.pixelformat = V4L2_PIX_FMT_MPEG;\r\nf->fmt.pix.bytesperline = 0;\r\nf->fmt.pix.sizeimage = dev->ts_packet_size * dev->ts_packet_count;\r\nf->fmt.pix.colorspace = V4L2_COLORSPACE_SMPTE170M;\r\nmaxw = norm_maxw(core->tvnorm);\r\nmaxh = norm_maxh(core->tvnorm);\r\nfield = f->fmt.pix.field;\r\nswitch (field) {\r\ncase V4L2_FIELD_TOP:\r\ncase V4L2_FIELD_BOTTOM:\r\ncase V4L2_FIELD_INTERLACED:\r\ncase V4L2_FIELD_SEQ_BT:\r\ncase V4L2_FIELD_SEQ_TB:\r\nbreak;\r\ndefault:\r\nfield = (f->fmt.pix.height > maxh / 2)\r\n? V4L2_FIELD_INTERLACED\r\n: V4L2_FIELD_BOTTOM;\r\nbreak;\r\n}\r\nif (V4L2_FIELD_HAS_T_OR_B(field))\r\nmaxh /= 2;\r\nv4l_bound_align_image(&f->fmt.pix.width, 48, maxw, 2,\r\n&f->fmt.pix.height, 32, maxh, 0, 0);\r\nf->fmt.pix.field = field;\r\nreturn 0;\r\n}\r\nstatic int vidioc_s_fmt_vid_cap(struct file *file, void *priv,\r\nstruct v4l2_format *f)\r\n{\r\nstruct cx8802_dev *dev = video_drvdata(file);\r\nstruct cx88_core *core = dev->core;\r\nif (vb2_is_busy(&dev->vb2_mpegq))\r\nreturn -EBUSY;\r\nif (core->v4ldev && (vb2_is_busy(&core->v4ldev->vb2_vidq) ||\r\nvb2_is_busy(&core->v4ldev->vb2_vbiq)))\r\nreturn -EBUSY;\r\nvidioc_try_fmt_vid_cap(file, priv, f);\r\ncore->width = f->fmt.pix.width;\r\ncore->height = f->fmt.pix.height;\r\ncore->field = f->fmt.pix.field;\r\ncx88_set_scale(core, f->fmt.pix.width, f->fmt.pix.height, f->fmt.pix.field);\r\nblackbird_api_cmd(dev, CX2341X_ENC_SET_FRAME_SIZE, 2, 0,\r\nf->fmt.pix.height, f->fmt.pix.width);\r\nreturn 0;\r\n}\r\nstatic int vidioc_s_frequency (struct file *file, void *priv,\r\nconst struct v4l2_frequency *f)\r\n{\r\nstruct cx8802_dev *dev = video_drvdata(file);\r\nstruct cx88_core *core = dev->core;\r\nbool streaming;\r\nif (unlikely(UNSET == core->board.tuner_type))\r\nreturn -EINVAL;\r\nif (unlikely(f->tuner != 0))\r\nreturn -EINVAL;\r\nstreaming = vb2_start_streaming_called(&dev->vb2_mpegq);\r\nif (streaming)\r\nblackbird_stop_codec(dev);\r\ncx88_set_freq (core,f);\r\nblackbird_initialize_codec(dev);\r\ncx88_set_scale(core, core->width, core->height,\r\ncore->field);\r\nif (streaming)\r\nblackbird_start_codec(dev);\r\nreturn 0;\r\n}\r\nstatic int vidioc_log_status (struct file *file, void *priv)\r\n{\r\nstruct cx8802_dev *dev = video_drvdata(file);\r\nstruct cx88_core *core = dev->core;\r\nchar name[32 + 2];\r\nsnprintf(name, sizeof(name), "%s/2", core->name);\r\ncall_all(core, core, log_status);\r\nv4l2_ctrl_handler_log_status(&dev->cxhdl.hdl, name);\r\nreturn 0;\r\n}\r\nstatic int vidioc_enum_input (struct file *file, void *priv,\r\nstruct v4l2_input *i)\r\n{\r\nstruct cx8802_dev *dev = video_drvdata(file);\r\nstruct cx88_core *core = dev->core;\r\nreturn cx88_enum_input (core,i);\r\n}\r\nstatic int vidioc_g_frequency (struct file *file, void *priv,\r\nstruct v4l2_frequency *f)\r\n{\r\nstruct cx8802_dev *dev = video_drvdata(file);\r\nstruct cx88_core *core = dev->core;\r\nif (unlikely(UNSET == core->board.tuner_type))\r\nreturn -EINVAL;\r\nif (unlikely(f->tuner != 0))\r\nreturn -EINVAL;\r\nf->frequency = core->freq;\r\ncall_all(core, tuner, g_frequency, f);\r\nreturn 0;\r\n}\r\nstatic int vidioc_g_input (struct file *file, void *priv, unsigned int *i)\r\n{\r\nstruct cx8802_dev *dev = video_drvdata(file);\r\nstruct cx88_core *core = dev->core;\r\n*i = core->input;\r\nreturn 0;\r\n}\r\nstatic int vidioc_s_input (struct file *file, void *priv, unsigned int i)\r\n{\r\nstruct cx8802_dev *dev = video_drvdata(file);\r\nstruct cx88_core *core = dev->core;\r\nif (i >= 4)\r\nreturn -EINVAL;\r\nif (0 == INPUT(i).type)\r\nreturn -EINVAL;\r\ncx88_newstation(core);\r\ncx88_video_mux(core,i);\r\nreturn 0;\r\n}\r\nstatic int vidioc_g_tuner (struct file *file, void *priv,\r\nstruct v4l2_tuner *t)\r\n{\r\nstruct cx8802_dev *dev = video_drvdata(file);\r\nstruct cx88_core *core = dev->core;\r\nu32 reg;\r\nif (unlikely(UNSET == core->board.tuner_type))\r\nreturn -EINVAL;\r\nif (0 != t->index)\r\nreturn -EINVAL;\r\nstrcpy(t->name, "Television");\r\nt->capability = V4L2_TUNER_CAP_NORM;\r\nt->rangehigh = 0xffffffffUL;\r\ncall_all(core, tuner, g_tuner, t);\r\ncx88_get_stereo(core ,t);\r\nreg = cx_read(MO_DEVICE_STATUS);\r\nt->signal = (reg & (1<<5)) ? 0xffff : 0x0000;\r\nreturn 0;\r\n}\r\nstatic int vidioc_s_tuner (struct file *file, void *priv,\r\nconst struct v4l2_tuner *t)\r\n{\r\nstruct cx8802_dev *dev = video_drvdata(file);\r\nstruct cx88_core *core = dev->core;\r\nif (UNSET == core->board.tuner_type)\r\nreturn -EINVAL;\r\nif (0 != t->index)\r\nreturn -EINVAL;\r\ncx88_set_stereo(core, t->audmode, 1);\r\nreturn 0;\r\n}\r\nstatic int vidioc_g_std(struct file *file, void *priv, v4l2_std_id *tvnorm)\r\n{\r\nstruct cx8802_dev *dev = video_drvdata(file);\r\nstruct cx88_core *core = dev->core;\r\n*tvnorm = core->tvnorm;\r\nreturn 0;\r\n}\r\nstatic int vidioc_s_std(struct file *file, void *priv, v4l2_std_id id)\r\n{\r\nstruct cx8802_dev *dev = video_drvdata(file);\r\nstruct cx88_core *core = dev->core;\r\nreturn cx88_set_tvnorm(core, id);\r\n}\r\nstatic int cx8802_blackbird_advise_acquire(struct cx8802_driver *drv)\r\n{\r\nstruct cx88_core *core = drv->core;\r\nint err = 0;\r\nswitch (core->boardnr) {\r\ncase CX88_BOARD_HAUPPAUGE_HVR1300:\r\ncx_set(MO_GP0_IO, 0x00000080);\r\nudelay(1000);\r\ncx_clear(MO_GP0_IO, 0x00000080);\r\nudelay(50);\r\ncx_set(MO_GP0_IO, 0x00000080);\r\nudelay(1000);\r\ncx_set(MO_GP0_IO, 0x00000004);\r\nudelay(1000);\r\nbreak;\r\ndefault:\r\nerr = -ENODEV;\r\n}\r\nreturn err;\r\n}\r\nstatic int cx8802_blackbird_advise_release(struct cx8802_driver *drv)\r\n{\r\nstruct cx88_core *core = drv->core;\r\nint err = 0;\r\nswitch (core->boardnr) {\r\ncase CX88_BOARD_HAUPPAUGE_HVR1300:\r\nbreak;\r\ndefault:\r\nerr = -ENODEV;\r\n}\r\nreturn err;\r\n}\r\nstatic void blackbird_unregister_video(struct cx8802_dev *dev)\r\n{\r\nvideo_unregister_device(&dev->mpeg_dev);\r\n}\r\nstatic int blackbird_register_video(struct cx8802_dev *dev)\r\n{\r\nint err;\r\ncx88_vdev_init(dev->core, dev->pci, &dev->mpeg_dev,\r\n&cx8802_mpeg_template, "mpeg");\r\ndev->mpeg_dev.ctrl_handler = &dev->cxhdl.hdl;\r\nvideo_set_drvdata(&dev->mpeg_dev, dev);\r\ndev->mpeg_dev.queue = &dev->vb2_mpegq;\r\nerr = video_register_device(&dev->mpeg_dev, VFL_TYPE_GRABBER, -1);\r\nif (err < 0) {\r\nprintk(KERN_INFO "%s/2: can't register mpeg device\n",\r\ndev->core->name);\r\nreturn err;\r\n}\r\nprintk(KERN_INFO "%s/2: registered device %s [mpeg]\n",\r\ndev->core->name, video_device_node_name(&dev->mpeg_dev));\r\nreturn 0;\r\n}\r\nstatic int cx8802_blackbird_probe(struct cx8802_driver *drv)\r\n{\r\nstruct cx88_core *core = drv->core;\r\nstruct cx8802_dev *dev = core->dvbdev;\r\nstruct vb2_queue *q;\r\nint err;\r\ndprintk( 1, "%s\n", __func__);\r\ndprintk( 1, " ->being probed by Card=%d Name=%s, PCI %02x:%02x\n",\r\ncore->boardnr,\r\ncore->name,\r\ncore->pci_bus,\r\ncore->pci_slot);\r\nerr = -ENODEV;\r\nif (!(core->board.mpeg & CX88_MPEG_BLACKBIRD))\r\ngoto fail_core;\r\ndev->cxhdl.port = CX2341X_PORT_STREAMING;\r\ndev->cxhdl.width = core->width;\r\ndev->cxhdl.height = core->height;\r\ndev->cxhdl.func = blackbird_mbox_func;\r\ndev->cxhdl.priv = dev;\r\nerr = cx2341x_handler_init(&dev->cxhdl, 36);\r\nif (err)\r\ngoto fail_core;\r\nv4l2_ctrl_add_handler(&dev->cxhdl.hdl, &core->video_hdl, NULL);\r\nprintk("%s/2: cx23416 based mpeg encoder (blackbird reference design)\n",\r\ncore->name);\r\nhost_setup(dev->core);\r\nblackbird_initialize_codec(dev);\r\ncx88_set_tvnorm(core,core->tvnorm);\r\ncx88_video_mux(core,0);\r\ncx2341x_handler_set_50hz(&dev->cxhdl, core->height == 576);\r\ncx2341x_handler_setup(&dev->cxhdl);\r\nq = &dev->vb2_mpegq;\r\nq->type = V4L2_BUF_TYPE_VIDEO_CAPTURE;\r\nq->io_modes = VB2_MMAP | VB2_USERPTR | VB2_DMABUF | VB2_READ;\r\nq->gfp_flags = GFP_DMA32;\r\nq->min_buffers_needed = 2;\r\nq->drv_priv = dev;\r\nq->buf_struct_size = sizeof(struct cx88_buffer);\r\nq->ops = &blackbird_qops;\r\nq->mem_ops = &vb2_dma_sg_memops;\r\nq->timestamp_flags = V4L2_BUF_FLAG_TIMESTAMP_MONOTONIC;\r\nq->lock = &core->lock;\r\nerr = vb2_queue_init(q);\r\nif (err < 0)\r\ngoto fail_core;\r\nblackbird_register_video(dev);\r\nreturn 0;\r\nfail_core:\r\nreturn err;\r\n}\r\nstatic int cx8802_blackbird_remove(struct cx8802_driver *drv)\r\n{\r\nstruct cx88_core *core = drv->core;\r\nstruct cx8802_dev *dev = core->dvbdev;\r\nblackbird_unregister_video(drv->core->dvbdev);\r\nv4l2_ctrl_handler_free(&dev->cxhdl.hdl);\r\nreturn 0;\r\n}\r\nstatic int __init blackbird_init(void)\r\n{\r\nprintk(KERN_INFO "cx2388x blackbird driver version %s loaded\n",\r\nCX88_VERSION);\r\nreturn cx8802_register_driver(&cx8802_blackbird_driver);\r\n}\r\nstatic void __exit blackbird_fini(void)\r\n{\r\ncx8802_unregister_driver(&cx8802_blackbird_driver);\r\n}
