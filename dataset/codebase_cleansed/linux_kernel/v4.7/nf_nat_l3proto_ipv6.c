static void nf_nat_ipv6_decode_session(struct sk_buff *skb,\r\nconst struct nf_conn *ct,\r\nenum ip_conntrack_dir dir,\r\nunsigned long statusbit,\r\nstruct flowi *fl)\r\n{\r\nconst struct nf_conntrack_tuple *t = &ct->tuplehash[dir].tuple;\r\nstruct flowi6 *fl6 = &fl->u.ip6;\r\nif (ct->status & statusbit) {\r\nfl6->daddr = t->dst.u3.in6;\r\nif (t->dst.protonum == IPPROTO_TCP ||\r\nt->dst.protonum == IPPROTO_UDP ||\r\nt->dst.protonum == IPPROTO_UDPLITE ||\r\nt->dst.protonum == IPPROTO_DCCP ||\r\nt->dst.protonum == IPPROTO_SCTP)\r\nfl6->fl6_dport = t->dst.u.all;\r\n}\r\nstatusbit ^= IPS_NAT_MASK;\r\nif (ct->status & statusbit) {\r\nfl6->saddr = t->src.u3.in6;\r\nif (t->dst.protonum == IPPROTO_TCP ||\r\nt->dst.protonum == IPPROTO_UDP ||\r\nt->dst.protonum == IPPROTO_UDPLITE ||\r\nt->dst.protonum == IPPROTO_DCCP ||\r\nt->dst.protonum == IPPROTO_SCTP)\r\nfl6->fl6_sport = t->src.u.all;\r\n}\r\n}\r\nstatic bool nf_nat_ipv6_in_range(const struct nf_conntrack_tuple *t,\r\nconst struct nf_nat_range *range)\r\n{\r\nreturn ipv6_addr_cmp(&t->src.u3.in6, &range->min_addr.in6) >= 0 &&\r\nipv6_addr_cmp(&t->src.u3.in6, &range->max_addr.in6) <= 0;\r\n}\r\nstatic u32 nf_nat_ipv6_secure_port(const struct nf_conntrack_tuple *t,\r\n__be16 dport)\r\n{\r\nreturn secure_ipv6_port_ephemeral(t->src.u3.ip6, t->dst.u3.ip6, dport);\r\n}\r\nstatic bool nf_nat_ipv6_manip_pkt(struct sk_buff *skb,\r\nunsigned int iphdroff,\r\nconst struct nf_nat_l4proto *l4proto,\r\nconst struct nf_conntrack_tuple *target,\r\nenum nf_nat_manip_type maniptype)\r\n{\r\nstruct ipv6hdr *ipv6h;\r\n__be16 frag_off;\r\nint hdroff;\r\nu8 nexthdr;\r\nif (!skb_make_writable(skb, iphdroff + sizeof(*ipv6h)))\r\nreturn false;\r\nipv6h = (void *)skb->data + iphdroff;\r\nnexthdr = ipv6h->nexthdr;\r\nhdroff = ipv6_skip_exthdr(skb, iphdroff + sizeof(*ipv6h),\r\n&nexthdr, &frag_off);\r\nif (hdroff < 0)\r\ngoto manip_addr;\r\nif ((frag_off & htons(~0x7)) == 0 &&\r\n!l4proto->manip_pkt(skb, &nf_nat_l3proto_ipv6, iphdroff, hdroff,\r\ntarget, maniptype))\r\nreturn false;\r\nmanip_addr:\r\nif (maniptype == NF_NAT_MANIP_SRC)\r\nipv6h->saddr = target->src.u3.in6;\r\nelse\r\nipv6h->daddr = target->dst.u3.in6;\r\nreturn true;\r\n}\r\nstatic void nf_nat_ipv6_csum_update(struct sk_buff *skb,\r\nunsigned int iphdroff, __sum16 *check,\r\nconst struct nf_conntrack_tuple *t,\r\nenum nf_nat_manip_type maniptype)\r\n{\r\nconst struct ipv6hdr *ipv6h = (struct ipv6hdr *)(skb->data + iphdroff);\r\nconst struct in6_addr *oldip, *newip;\r\nif (maniptype == NF_NAT_MANIP_SRC) {\r\noldip = &ipv6h->saddr;\r\nnewip = &t->src.u3.in6;\r\n} else {\r\noldip = &ipv6h->daddr;\r\nnewip = &t->dst.u3.in6;\r\n}\r\ninet_proto_csum_replace16(check, skb, oldip->s6_addr32,\r\nnewip->s6_addr32, true);\r\n}\r\nstatic void nf_nat_ipv6_csum_recalc(struct sk_buff *skb,\r\nu8 proto, void *data, __sum16 *check,\r\nint datalen, int oldlen)\r\n{\r\nif (skb->ip_summed != CHECKSUM_PARTIAL) {\r\nconst struct ipv6hdr *ipv6h = ipv6_hdr(skb);\r\nskb->ip_summed = CHECKSUM_PARTIAL;\r\nskb->csum_start = skb_headroom(skb) + skb_network_offset(skb) +\r\n(data - (void *)skb->data);\r\nskb->csum_offset = (void *)check - data;\r\n*check = ~csum_ipv6_magic(&ipv6h->saddr, &ipv6h->daddr,\r\ndatalen, proto, 0);\r\n} else\r\ninet_proto_csum_replace2(check, skb,\r\nhtons(oldlen), htons(datalen), true);\r\n}\r\nstatic int nf_nat_ipv6_nlattr_to_range(struct nlattr *tb[],\r\nstruct nf_nat_range *range)\r\n{\r\nif (tb[CTA_NAT_V6_MINIP]) {\r\nnla_memcpy(&range->min_addr.ip6, tb[CTA_NAT_V6_MINIP],\r\nsizeof(struct in6_addr));\r\nrange->flags |= NF_NAT_RANGE_MAP_IPS;\r\n}\r\nif (tb[CTA_NAT_V6_MAXIP])\r\nnla_memcpy(&range->max_addr.ip6, tb[CTA_NAT_V6_MAXIP],\r\nsizeof(struct in6_addr));\r\nelse\r\nrange->max_addr = range->min_addr;\r\nreturn 0;\r\n}\r\nint nf_nat_icmpv6_reply_translation(struct sk_buff *skb,\r\nstruct nf_conn *ct,\r\nenum ip_conntrack_info ctinfo,\r\nunsigned int hooknum,\r\nunsigned int hdrlen)\r\n{\r\nstruct {\r\nstruct icmp6hdr icmp6;\r\nstruct ipv6hdr ip6;\r\n} *inside;\r\nenum ip_conntrack_dir dir = CTINFO2DIR(ctinfo);\r\nenum nf_nat_manip_type manip = HOOK2MANIP(hooknum);\r\nconst struct nf_nat_l4proto *l4proto;\r\nstruct nf_conntrack_tuple target;\r\nunsigned long statusbit;\r\nNF_CT_ASSERT(ctinfo == IP_CT_RELATED || ctinfo == IP_CT_RELATED_REPLY);\r\nif (!skb_make_writable(skb, hdrlen + sizeof(*inside)))\r\nreturn 0;\r\nif (nf_ip6_checksum(skb, hooknum, hdrlen, IPPROTO_ICMPV6))\r\nreturn 0;\r\ninside = (void *)skb->data + hdrlen;\r\nif (inside->icmp6.icmp6_type == NDISC_REDIRECT) {\r\nif ((ct->status & IPS_NAT_DONE_MASK) != IPS_NAT_DONE_MASK)\r\nreturn 0;\r\nif (ct->status & IPS_NAT_MASK)\r\nreturn 0;\r\n}\r\nif (manip == NF_NAT_MANIP_SRC)\r\nstatusbit = IPS_SRC_NAT;\r\nelse\r\nstatusbit = IPS_DST_NAT;\r\nif (dir == IP_CT_DIR_REPLY)\r\nstatusbit ^= IPS_NAT_MASK;\r\nif (!(ct->status & statusbit))\r\nreturn 1;\r\nl4proto = __nf_nat_l4proto_find(NFPROTO_IPV6, inside->ip6.nexthdr);\r\nif (!nf_nat_ipv6_manip_pkt(skb, hdrlen + sizeof(inside->icmp6),\r\nl4proto, &ct->tuplehash[!dir].tuple, !manip))\r\nreturn 0;\r\nif (skb->ip_summed != CHECKSUM_PARTIAL) {\r\nstruct ipv6hdr *ipv6h = ipv6_hdr(skb);\r\ninside = (void *)skb->data + hdrlen;\r\ninside->icmp6.icmp6_cksum = 0;\r\ninside->icmp6.icmp6_cksum =\r\ncsum_ipv6_magic(&ipv6h->saddr, &ipv6h->daddr,\r\nskb->len - hdrlen, IPPROTO_ICMPV6,\r\ncsum_partial(&inside->icmp6,\r\nskb->len - hdrlen, 0));\r\n}\r\nnf_ct_invert_tuplepr(&target, &ct->tuplehash[!dir].tuple);\r\nl4proto = __nf_nat_l4proto_find(NFPROTO_IPV6, IPPROTO_ICMPV6);\r\nif (!nf_nat_ipv6_manip_pkt(skb, 0, l4proto, &target, manip))\r\nreturn 0;\r\nreturn 1;\r\n}\r\nstatic int __init nf_nat_l3proto_ipv6_init(void)\r\n{\r\nint err;\r\nerr = nf_nat_l4proto_register(NFPROTO_IPV6, &nf_nat_l4proto_icmpv6);\r\nif (err < 0)\r\ngoto err1;\r\nerr = nf_nat_l3proto_register(&nf_nat_l3proto_ipv6);\r\nif (err < 0)\r\ngoto err2;\r\nreturn err;\r\nerr2:\r\nnf_nat_l4proto_unregister(NFPROTO_IPV6, &nf_nat_l4proto_icmpv6);\r\nerr1:\r\nreturn err;\r\n}\r\nstatic void __exit nf_nat_l3proto_ipv6_exit(void)\r\n{\r\nnf_nat_l3proto_unregister(&nf_nat_l3proto_ipv6);\r\nnf_nat_l4proto_unregister(NFPROTO_IPV6, &nf_nat_l4proto_icmpv6);\r\n}
