static hpi_handler_func *hpi_lookup_entry_point_function(const struct hpi_pci\r\n*pci_info)\r\n{\r\nint i;\r\nfor (i = 0; asihpi_pci_tbl[i].vendor != 0; i++) {\r\nif (asihpi_pci_tbl[i].vendor != PCI_ANY_ID\r\n&& asihpi_pci_tbl[i].vendor !=\r\npci_info->pci_dev->vendor)\r\ncontinue;\r\nif (asihpi_pci_tbl[i].device != PCI_ANY_ID\r\n&& asihpi_pci_tbl[i].device !=\r\npci_info->pci_dev->device)\r\ncontinue;\r\nif (asihpi_pci_tbl[i].subvendor != PCI_ANY_ID\r\n&& asihpi_pci_tbl[i].subvendor !=\r\npci_info->pci_dev->subsystem_vendor)\r\ncontinue;\r\nif (asihpi_pci_tbl[i].subdevice != PCI_ANY_ID\r\n&& asihpi_pci_tbl[i].subdevice !=\r\npci_info->pci_dev->subsystem_device)\r\ncontinue;\r\nreturn (hpi_handler_func *) asihpi_pci_tbl[i].driver_data;\r\n}\r\nreturn NULL;\r\n}\r\nstatic inline void hw_entry_point(struct hpi_message *phm,\r\nstruct hpi_response *phr)\r\n{\r\nif ((phm->adapter_index < HPI_MAX_ADAPTERS)\r\n&& hpi_entry_points[phm->adapter_index])\r\nhpi_entry_points[phm->adapter_index] (phm, phr);\r\nelse\r\nhpi_init_response(phr, phm->object, phm->function,\r\nHPI_ERROR_PROCESSING_MESSAGE);\r\n}\r\nstatic void subsys_message(struct hpi_message *phm, struct hpi_response *phr,\r\nvoid *h_owner)\r\n{\r\nif (phm->adapter_index != HPI_ADAPTER_INDEX_INVALID)\r\nHPI_DEBUG_LOG(WARNING,\r\n"suspicious adapter index %d in subsys message 0x%x.\n",\r\nphm->adapter_index, phm->function);\r\nswitch (phm->function) {\r\ncase HPI_SUBSYS_GET_VERSION:\r\nhpi_init_response(phr, HPI_OBJ_SUBSYSTEM,\r\nHPI_SUBSYS_GET_VERSION, 0);\r\nphr->u.s.version = HPI_VER >> 8;\r\nphr->u.s.data = HPI_VER;\r\nbreak;\r\ncase HPI_SUBSYS_OPEN:\r\nhpi_init_response(phr, HPI_OBJ_SUBSYSTEM, HPI_SUBSYS_OPEN, 0);\r\nbreak;\r\ncase HPI_SUBSYS_CLOSE:\r\nhpi_init_response(phr, HPI_OBJ_SUBSYSTEM, HPI_SUBSYS_CLOSE,\r\n0);\r\nHPIMSGX__cleanup(HPIMSGX_ALLADAPTERS, h_owner);\r\nbreak;\r\ncase HPI_SUBSYS_DRIVER_LOAD:\r\nhpios_msgxlock_init(&msgx_lock);\r\nmemset(&hpi_entry_points, 0, sizeof(hpi_entry_points));\r\nHPIMSGX__reset(HPIMSGX_ALLADAPTERS);\r\nhpi_init_response(phr, HPI_OBJ_SUBSYSTEM,\r\nHPI_SUBSYS_DRIVER_LOAD, 0);\r\nHPI_COMMON(phm, phr);\r\nbreak;\r\ncase HPI_SUBSYS_DRIVER_UNLOAD:\r\nHPI_COMMON(phm, phr);\r\nHPIMSGX__cleanup(HPIMSGX_ALLADAPTERS, h_owner);\r\nhpi_init_response(phr, HPI_OBJ_SUBSYSTEM,\r\nHPI_SUBSYS_DRIVER_UNLOAD, 0);\r\nreturn;\r\ncase HPI_SUBSYS_GET_NUM_ADAPTERS:\r\ncase HPI_SUBSYS_GET_ADAPTER:\r\nHPI_COMMON(phm, phr);\r\nbreak;\r\ncase HPI_SUBSYS_CREATE_ADAPTER:\r\nHPIMSGX__init(phm, phr);\r\nbreak;\r\ndefault:\r\nhpi_init_response(phr, HPI_OBJ_SUBSYSTEM, phm->function,\r\nHPI_ERROR_INVALID_FUNC);\r\nbreak;\r\n}\r\n}\r\nstatic void adapter_message(struct hpi_message *phm, struct hpi_response *phr,\r\nvoid *h_owner)\r\n{\r\nswitch (phm->function) {\r\ncase HPI_ADAPTER_OPEN:\r\nadapter_open(phm, phr);\r\nbreak;\r\ncase HPI_ADAPTER_CLOSE:\r\nadapter_close(phm, phr);\r\nbreak;\r\ncase HPI_ADAPTER_DELETE:\r\nHPIMSGX__cleanup(phm->adapter_index, h_owner);\r\n{\r\nstruct hpi_message hm;\r\nstruct hpi_response hr;\r\nhpi_init_message_response(&hm, &hr, HPI_OBJ_ADAPTER,\r\nHPI_ADAPTER_CLOSE);\r\nhm.adapter_index = phm->adapter_index;\r\nhw_entry_point(&hm, &hr);\r\n}\r\nhw_entry_point(phm, phr);\r\nbreak;\r\ndefault:\r\nhw_entry_point(phm, phr);\r\nbreak;\r\n}\r\n}\r\nstatic void mixer_message(struct hpi_message *phm, struct hpi_response *phr)\r\n{\r\nswitch (phm->function) {\r\ncase HPI_MIXER_OPEN:\r\nmixer_open(phm, phr);\r\nbreak;\r\ncase HPI_MIXER_CLOSE:\r\nmixer_close(phm, phr);\r\nbreak;\r\ndefault:\r\nhw_entry_point(phm, phr);\r\nbreak;\r\n}\r\n}\r\nstatic void outstream_message(struct hpi_message *phm,\r\nstruct hpi_response *phr, void *h_owner)\r\n{\r\nif (phm->obj_index >= aDAPTER_INFO[phm->adapter_index].num_outstreams) {\r\nhpi_init_response(phr, HPI_OBJ_OSTREAM, phm->function,\r\nHPI_ERROR_INVALID_OBJ_INDEX);\r\nreturn;\r\n}\r\nswitch (phm->function) {\r\ncase HPI_OSTREAM_OPEN:\r\noutstream_open(phm, phr, h_owner);\r\nbreak;\r\ncase HPI_OSTREAM_CLOSE:\r\noutstream_close(phm, phr, h_owner);\r\nbreak;\r\ndefault:\r\nhw_entry_point(phm, phr);\r\nbreak;\r\n}\r\n}\r\nstatic void instream_message(struct hpi_message *phm,\r\nstruct hpi_response *phr, void *h_owner)\r\n{\r\nif (phm->obj_index >= aDAPTER_INFO[phm->adapter_index].num_instreams) {\r\nhpi_init_response(phr, HPI_OBJ_ISTREAM, phm->function,\r\nHPI_ERROR_INVALID_OBJ_INDEX);\r\nreturn;\r\n}\r\nswitch (phm->function) {\r\ncase HPI_ISTREAM_OPEN:\r\ninstream_open(phm, phr, h_owner);\r\nbreak;\r\ncase HPI_ISTREAM_CLOSE:\r\ninstream_close(phm, phr, h_owner);\r\nbreak;\r\ndefault:\r\nhw_entry_point(phm, phr);\r\nbreak;\r\n}\r\n}\r\nvoid hpi_send_recv_ex(struct hpi_message *phm, struct hpi_response *phr,\r\nvoid *h_owner)\r\n{\r\nif (logging_enabled)\r\nHPI_DEBUG_MESSAGE(DEBUG, phm);\r\nif (phm->type != HPI_TYPE_REQUEST) {\r\nhpi_init_response(phr, phm->object, phm->function,\r\nHPI_ERROR_INVALID_TYPE);\r\nreturn;\r\n}\r\nif (phm->adapter_index >= HPI_MAX_ADAPTERS\r\n&& phm->adapter_index != HPIMSGX_ALLADAPTERS) {\r\nhpi_init_response(phr, phm->object, phm->function,\r\nHPI_ERROR_BAD_ADAPTER_NUMBER);\r\nreturn;\r\n}\r\nswitch (phm->object) {\r\ncase HPI_OBJ_SUBSYSTEM:\r\nsubsys_message(phm, phr, h_owner);\r\nbreak;\r\ncase HPI_OBJ_ADAPTER:\r\nadapter_message(phm, phr, h_owner);\r\nbreak;\r\ncase HPI_OBJ_MIXER:\r\nmixer_message(phm, phr);\r\nbreak;\r\ncase HPI_OBJ_OSTREAM:\r\noutstream_message(phm, phr, h_owner);\r\nbreak;\r\ncase HPI_OBJ_ISTREAM:\r\ninstream_message(phm, phr, h_owner);\r\nbreak;\r\ndefault:\r\nhw_entry_point(phm, phr);\r\nbreak;\r\n}\r\nif (logging_enabled)\r\nHPI_DEBUG_RESPONSE(phr);\r\nif (phr->error >= HPI_ERROR_DSP_COMMUNICATION) {\r\nhpi_debug_level_set(HPI_DEBUG_LEVEL_ERROR);\r\nlogging_enabled = 0;\r\n}\r\n}\r\nstatic void adapter_open(struct hpi_message *phm, struct hpi_response *phr)\r\n{\r\nHPI_DEBUG_LOG(VERBOSE, "adapter_open\n");\r\nmemcpy(phr, &rESP_HPI_ADAPTER_OPEN[phm->adapter_index],\r\nsizeof(rESP_HPI_ADAPTER_OPEN[0]));\r\n}\r\nstatic void adapter_close(struct hpi_message *phm, struct hpi_response *phr)\r\n{\r\nHPI_DEBUG_LOG(VERBOSE, "adapter_close\n");\r\nhpi_init_response(phr, HPI_OBJ_ADAPTER, HPI_ADAPTER_CLOSE, 0);\r\n}\r\nstatic void mixer_open(struct hpi_message *phm, struct hpi_response *phr)\r\n{\r\nmemcpy(phr, &rESP_HPI_MIXER_OPEN[phm->adapter_index],\r\nsizeof(rESP_HPI_MIXER_OPEN[0]));\r\n}\r\nstatic void mixer_close(struct hpi_message *phm, struct hpi_response *phr)\r\n{\r\nhpi_init_response(phr, HPI_OBJ_MIXER, HPI_MIXER_CLOSE, 0);\r\n}\r\nstatic void instream_open(struct hpi_message *phm, struct hpi_response *phr,\r\nvoid *h_owner)\r\n{\r\nstruct hpi_message hm;\r\nstruct hpi_response hr;\r\nhpi_init_response(phr, HPI_OBJ_ISTREAM, HPI_ISTREAM_OPEN, 0);\r\nhpios_msgxlock_lock(&msgx_lock);\r\nif (instream_user_open[phm->adapter_index][phm->obj_index].open_flag)\r\nphr->error = HPI_ERROR_OBJ_ALREADY_OPEN;\r\nelse if (rESP_HPI_ISTREAM_OPEN[phm->adapter_index]\r\n[phm->obj_index].h.error)\r\nmemcpy(phr,\r\n&rESP_HPI_ISTREAM_OPEN[phm->adapter_index][phm->\r\nobj_index],\r\nsizeof(rESP_HPI_ISTREAM_OPEN[0][0]));\r\nelse {\r\ninstream_user_open[phm->adapter_index][phm->\r\nobj_index].open_flag = 1;\r\nhpios_msgxlock_unlock(&msgx_lock);\r\nhpi_init_message_response(&hm, &hr, HPI_OBJ_ISTREAM,\r\nHPI_ISTREAM_RESET);\r\nhm.adapter_index = phm->adapter_index;\r\nhm.obj_index = phm->obj_index;\r\nhw_entry_point(&hm, &hr);\r\nhpios_msgxlock_lock(&msgx_lock);\r\nif (hr.error) {\r\ninstream_user_open[phm->adapter_index][phm->\r\nobj_index].open_flag = 0;\r\nphr->error = hr.error;\r\n} else {\r\ninstream_user_open[phm->adapter_index][phm->\r\nobj_index].open_flag = 1;\r\ninstream_user_open[phm->adapter_index][phm->\r\nobj_index].h_owner = h_owner;\r\nmemcpy(phr,\r\n&rESP_HPI_ISTREAM_OPEN[phm->adapter_index]\r\n[phm->obj_index],\r\nsizeof(rESP_HPI_ISTREAM_OPEN[0][0]));\r\n}\r\n}\r\nhpios_msgxlock_unlock(&msgx_lock);\r\n}\r\nstatic void instream_close(struct hpi_message *phm, struct hpi_response *phr,\r\nvoid *h_owner)\r\n{\r\nstruct hpi_message hm;\r\nstruct hpi_response hr;\r\nhpi_init_response(phr, HPI_OBJ_ISTREAM, HPI_ISTREAM_CLOSE, 0);\r\nhpios_msgxlock_lock(&msgx_lock);\r\nif (h_owner ==\r\ninstream_user_open[phm->adapter_index][phm->\r\nobj_index].h_owner) {\r\ninstream_user_open[phm->adapter_index][phm->\r\nobj_index].h_owner = NULL;\r\nhpios_msgxlock_unlock(&msgx_lock);\r\nhpi_init_message_response(&hm, &hr, HPI_OBJ_ISTREAM,\r\nHPI_ISTREAM_RESET);\r\nhm.adapter_index = phm->adapter_index;\r\nhm.obj_index = phm->obj_index;\r\nhw_entry_point(&hm, &hr);\r\nhpios_msgxlock_lock(&msgx_lock);\r\nif (hr.error) {\r\ninstream_user_open[phm->adapter_index][phm->\r\nobj_index].h_owner = h_owner;\r\nphr->error = hr.error;\r\n} else {\r\ninstream_user_open[phm->adapter_index][phm->\r\nobj_index].open_flag = 0;\r\ninstream_user_open[phm->adapter_index][phm->\r\nobj_index].h_owner = NULL;\r\n}\r\n} else {\r\nHPI_DEBUG_LOG(WARNING,\r\n"%p trying to close %d instream %d owned by %p\n",\r\nh_owner, phm->adapter_index, phm->obj_index,\r\ninstream_user_open[phm->adapter_index][phm->\r\nobj_index].h_owner);\r\nphr->error = HPI_ERROR_OBJ_NOT_OPEN;\r\n}\r\nhpios_msgxlock_unlock(&msgx_lock);\r\n}\r\nstatic void outstream_open(struct hpi_message *phm, struct hpi_response *phr,\r\nvoid *h_owner)\r\n{\r\nstruct hpi_message hm;\r\nstruct hpi_response hr;\r\nhpi_init_response(phr, HPI_OBJ_OSTREAM, HPI_OSTREAM_OPEN, 0);\r\nhpios_msgxlock_lock(&msgx_lock);\r\nif (outstream_user_open[phm->adapter_index][phm->obj_index].open_flag)\r\nphr->error = HPI_ERROR_OBJ_ALREADY_OPEN;\r\nelse if (rESP_HPI_OSTREAM_OPEN[phm->adapter_index]\r\n[phm->obj_index].h.error)\r\nmemcpy(phr,\r\n&rESP_HPI_OSTREAM_OPEN[phm->adapter_index][phm->\r\nobj_index],\r\nsizeof(rESP_HPI_OSTREAM_OPEN[0][0]));\r\nelse {\r\noutstream_user_open[phm->adapter_index][phm->\r\nobj_index].open_flag = 1;\r\nhpios_msgxlock_unlock(&msgx_lock);\r\nhpi_init_message_response(&hm, &hr, HPI_OBJ_OSTREAM,\r\nHPI_OSTREAM_RESET);\r\nhm.adapter_index = phm->adapter_index;\r\nhm.obj_index = phm->obj_index;\r\nhw_entry_point(&hm, &hr);\r\nhpios_msgxlock_lock(&msgx_lock);\r\nif (hr.error) {\r\noutstream_user_open[phm->adapter_index][phm->\r\nobj_index].open_flag = 0;\r\nphr->error = hr.error;\r\n} else {\r\noutstream_user_open[phm->adapter_index][phm->\r\nobj_index].open_flag = 1;\r\noutstream_user_open[phm->adapter_index][phm->\r\nobj_index].h_owner = h_owner;\r\nmemcpy(phr,\r\n&rESP_HPI_OSTREAM_OPEN[phm->adapter_index]\r\n[phm->obj_index],\r\nsizeof(rESP_HPI_OSTREAM_OPEN[0][0]));\r\n}\r\n}\r\nhpios_msgxlock_unlock(&msgx_lock);\r\n}\r\nstatic void outstream_close(struct hpi_message *phm, struct hpi_response *phr,\r\nvoid *h_owner)\r\n{\r\nstruct hpi_message hm;\r\nstruct hpi_response hr;\r\nhpi_init_response(phr, HPI_OBJ_OSTREAM, HPI_OSTREAM_CLOSE, 0);\r\nhpios_msgxlock_lock(&msgx_lock);\r\nif (h_owner ==\r\noutstream_user_open[phm->adapter_index][phm->\r\nobj_index].h_owner) {\r\noutstream_user_open[phm->adapter_index][phm->\r\nobj_index].h_owner = NULL;\r\nhpios_msgxlock_unlock(&msgx_lock);\r\nhpi_init_message_response(&hm, &hr, HPI_OBJ_OSTREAM,\r\nHPI_OSTREAM_RESET);\r\nhm.adapter_index = phm->adapter_index;\r\nhm.obj_index = phm->obj_index;\r\nhw_entry_point(&hm, &hr);\r\nhpios_msgxlock_lock(&msgx_lock);\r\nif (hr.error) {\r\noutstream_user_open[phm->adapter_index][phm->\r\nobj_index].h_owner = h_owner;\r\nphr->error = hr.error;\r\n} else {\r\noutstream_user_open[phm->adapter_index][phm->\r\nobj_index].open_flag = 0;\r\noutstream_user_open[phm->adapter_index][phm->\r\nobj_index].h_owner = NULL;\r\n}\r\n} else {\r\nHPI_DEBUG_LOG(WARNING,\r\n"%p trying to close %d outstream %d owned by %p\n",\r\nh_owner, phm->adapter_index, phm->obj_index,\r\noutstream_user_open[phm->adapter_index][phm->\r\nobj_index].h_owner);\r\nphr->error = HPI_ERROR_OBJ_NOT_OPEN;\r\n}\r\nhpios_msgxlock_unlock(&msgx_lock);\r\n}\r\nstatic u16 adapter_prepare(u16 adapter)\r\n{\r\nstruct hpi_message hm;\r\nstruct hpi_response hr;\r\nu16 i;\r\nhpi_init_message_response(&hm, &hr, HPI_OBJ_ADAPTER,\r\nHPI_ADAPTER_OPEN);\r\nhm.adapter_index = adapter;\r\nhw_entry_point(&hm, &hr);\r\nmemcpy(&rESP_HPI_ADAPTER_OPEN[adapter], &hr,\r\nsizeof(rESP_HPI_ADAPTER_OPEN[0]));\r\nif (hr.error)\r\nreturn hr.error;\r\nhpi_init_message_response(&hm, &hr, HPI_OBJ_ADAPTER,\r\nHPI_ADAPTER_GET_INFO);\r\nhm.adapter_index = adapter;\r\nhw_entry_point(&hm, &hr);\r\nif (hr.error)\r\nreturn hr.error;\r\naDAPTER_INFO[adapter].num_outstreams = hr.u.ax.info.num_outstreams;\r\naDAPTER_INFO[adapter].num_instreams = hr.u.ax.info.num_instreams;\r\naDAPTER_INFO[adapter].type = hr.u.ax.info.adapter_type;\r\nfor (i = 0; i < aDAPTER_INFO[adapter].num_outstreams; i++) {\r\nhpi_init_message_response(&hm, &hr, HPI_OBJ_OSTREAM,\r\nHPI_OSTREAM_OPEN);\r\nhm.adapter_index = adapter;\r\nhm.obj_index = i;\r\nhw_entry_point(&hm, &hr);\r\nmemcpy(&rESP_HPI_OSTREAM_OPEN[adapter][i], &hr,\r\nsizeof(rESP_HPI_OSTREAM_OPEN[0][0]));\r\noutstream_user_open[adapter][i].open_flag = 0;\r\noutstream_user_open[adapter][i].h_owner = NULL;\r\n}\r\nfor (i = 0; i < aDAPTER_INFO[adapter].num_instreams; i++) {\r\nhpi_init_message_response(&hm, &hr, HPI_OBJ_ISTREAM,\r\nHPI_ISTREAM_OPEN);\r\nhm.adapter_index = adapter;\r\nhm.obj_index = i;\r\nhw_entry_point(&hm, &hr);\r\nmemcpy(&rESP_HPI_ISTREAM_OPEN[adapter][i], &hr,\r\nsizeof(rESP_HPI_ISTREAM_OPEN[0][0]));\r\ninstream_user_open[adapter][i].open_flag = 0;\r\ninstream_user_open[adapter][i].h_owner = NULL;\r\n}\r\nhpi_init_message_response(&hm, &hr, HPI_OBJ_MIXER, HPI_MIXER_OPEN);\r\nhm.adapter_index = adapter;\r\nhw_entry_point(&hm, &hr);\r\nmemcpy(&rESP_HPI_MIXER_OPEN[adapter], &hr,\r\nsizeof(rESP_HPI_MIXER_OPEN[0]));\r\nreturn 0;\r\n}\r\nstatic void HPIMSGX__reset(u16 adapter_index)\r\n{\r\nint i;\r\nu16 adapter;\r\nstruct hpi_response hr;\r\nif (adapter_index == HPIMSGX_ALLADAPTERS) {\r\nfor (adapter = 0; adapter < HPI_MAX_ADAPTERS; adapter++) {\r\nhpi_init_response(&hr, HPI_OBJ_ADAPTER,\r\nHPI_ADAPTER_OPEN, HPI_ERROR_BAD_ADAPTER);\r\nmemcpy(&rESP_HPI_ADAPTER_OPEN[adapter], &hr,\r\nsizeof(rESP_HPI_ADAPTER_OPEN[adapter]));\r\nhpi_init_response(&hr, HPI_OBJ_MIXER, HPI_MIXER_OPEN,\r\nHPI_ERROR_INVALID_OBJ);\r\nmemcpy(&rESP_HPI_MIXER_OPEN[adapter], &hr,\r\nsizeof(rESP_HPI_MIXER_OPEN[adapter]));\r\nfor (i = 0; i < HPI_MAX_STREAMS; i++) {\r\nhpi_init_response(&hr, HPI_OBJ_OSTREAM,\r\nHPI_OSTREAM_OPEN,\r\nHPI_ERROR_INVALID_OBJ);\r\nmemcpy(&rESP_HPI_OSTREAM_OPEN[adapter][i],\r\n&hr,\r\nsizeof(rESP_HPI_OSTREAM_OPEN[adapter]\r\n[i]));\r\nhpi_init_response(&hr, HPI_OBJ_ISTREAM,\r\nHPI_ISTREAM_OPEN,\r\nHPI_ERROR_INVALID_OBJ);\r\nmemcpy(&rESP_HPI_ISTREAM_OPEN[adapter][i],\r\n&hr,\r\nsizeof(rESP_HPI_ISTREAM_OPEN[adapter]\r\n[i]));\r\n}\r\n}\r\n} else if (adapter_index < HPI_MAX_ADAPTERS) {\r\nrESP_HPI_ADAPTER_OPEN[adapter_index].h.error =\r\nHPI_ERROR_BAD_ADAPTER;\r\nrESP_HPI_MIXER_OPEN[adapter_index].h.error =\r\nHPI_ERROR_INVALID_OBJ;\r\nfor (i = 0; i < HPI_MAX_STREAMS; i++) {\r\nrESP_HPI_OSTREAM_OPEN[adapter_index][i].h.error =\r\nHPI_ERROR_INVALID_OBJ;\r\nrESP_HPI_ISTREAM_OPEN[adapter_index][i].h.error =\r\nHPI_ERROR_INVALID_OBJ;\r\n}\r\n}\r\n}\r\nstatic u16 HPIMSGX__init(struct hpi_message *phm,\r\nstruct hpi_response *phr\r\n)\r\n{\r\nhpi_handler_func *entry_point_func;\r\nstruct hpi_response hr;\r\nhpi_init_response(&hr, phm->object, phm->function,\r\nHPI_ERROR_INVALID_OBJ);\r\nentry_point_func =\r\nhpi_lookup_entry_point_function(phm->u.s.resource.r.pci);\r\nif (entry_point_func) {\r\nHPI_DEBUG_MESSAGE(DEBUG, phm);\r\nentry_point_func(phm, &hr);\r\n} else {\r\nphr->error = HPI_ERROR_PROCESSING_MESSAGE;\r\nreturn phr->error;\r\n}\r\nif (hr.error == 0) {\r\nhpi_entry_points[hr.u.s.adapter_index] = entry_point_func;\r\nHPI_DEBUG_LOG(DEBUG,\r\n"HPI_SUBSYS_CREATE_ADAPTER successful,"\r\n" preparing adapter\n");\r\nadapter_prepare(hr.u.s.adapter_index);\r\n}\r\nmemcpy(phr, &hr, hr.size);\r\nreturn phr->error;\r\n}\r\nstatic void HPIMSGX__cleanup(u16 adapter_index, void *h_owner)\r\n{\r\nint i, adapter, adapter_limit;\r\nif (!h_owner)\r\nreturn;\r\nif (adapter_index == HPIMSGX_ALLADAPTERS) {\r\nadapter = 0;\r\nadapter_limit = HPI_MAX_ADAPTERS;\r\n} else {\r\nadapter = adapter_index;\r\nadapter_limit = adapter + 1;\r\n}\r\nfor (; adapter < adapter_limit; adapter++) {\r\nfor (i = 0; i < HPI_MAX_STREAMS; i++) {\r\nif (h_owner ==\r\noutstream_user_open[adapter][i].h_owner) {\r\nstruct hpi_message hm;\r\nstruct hpi_response hr;\r\nHPI_DEBUG_LOG(DEBUG,\r\n"Close adapter %d ostream %d\n",\r\nadapter, i);\r\nhpi_init_message_response(&hm, &hr,\r\nHPI_OBJ_OSTREAM, HPI_OSTREAM_RESET);\r\nhm.adapter_index = (u16)adapter;\r\nhm.obj_index = (u16)i;\r\nhw_entry_point(&hm, &hr);\r\nhm.function = HPI_OSTREAM_HOSTBUFFER_FREE;\r\nhw_entry_point(&hm, &hr);\r\nhm.function = HPI_OSTREAM_GROUP_RESET;\r\nhw_entry_point(&hm, &hr);\r\noutstream_user_open[adapter][i].open_flag = 0;\r\noutstream_user_open[adapter][i].h_owner =\r\nNULL;\r\n}\r\nif (h_owner == instream_user_open[adapter][i].h_owner) {\r\nstruct hpi_message hm;\r\nstruct hpi_response hr;\r\nHPI_DEBUG_LOG(DEBUG,\r\n"Close adapter %d istream %d\n",\r\nadapter, i);\r\nhpi_init_message_response(&hm, &hr,\r\nHPI_OBJ_ISTREAM, HPI_ISTREAM_RESET);\r\nhm.adapter_index = (u16)adapter;\r\nhm.obj_index = (u16)i;\r\nhw_entry_point(&hm, &hr);\r\nhm.function = HPI_ISTREAM_HOSTBUFFER_FREE;\r\nhw_entry_point(&hm, &hr);\r\nhm.function = HPI_ISTREAM_GROUP_RESET;\r\nhw_entry_point(&hm, &hr);\r\ninstream_user_open[adapter][i].open_flag = 0;\r\ninstream_user_open[adapter][i].h_owner = NULL;\r\n}\r\n}\r\n}\r\n}
