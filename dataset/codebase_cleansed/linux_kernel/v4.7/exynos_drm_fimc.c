static u32 fimc_read(struct fimc_context *ctx, u32 reg)\r\n{\r\nreturn readl(ctx->regs + reg);\r\n}\r\nstatic void fimc_write(struct fimc_context *ctx, u32 val, u32 reg)\r\n{\r\nwritel(val, ctx->regs + reg);\r\n}\r\nstatic void fimc_set_bits(struct fimc_context *ctx, u32 reg, u32 bits)\r\n{\r\nvoid __iomem *r = ctx->regs + reg;\r\nwritel(readl(r) | bits, r);\r\n}\r\nstatic void fimc_clear_bits(struct fimc_context *ctx, u32 reg, u32 bits)\r\n{\r\nvoid __iomem *r = ctx->regs + reg;\r\nwritel(readl(r) & ~bits, r);\r\n}\r\nstatic void fimc_sw_reset(struct fimc_context *ctx)\r\n{\r\nu32 cfg;\r\ncfg = fimc_read(ctx, EXYNOS_CISTATUS);\r\nif (EXYNOS_CISTATUS_GET_ENVID_STATUS(cfg))\r\nfimc_clear_bits(ctx, EXYNOS_MSCTRL, EXYNOS_MSCTRL_ENVID);\r\nfimc_set_bits(ctx, EXYNOS_CISRCFMT, EXYNOS_CISRCFMT_ITU601_8BIT);\r\nfimc_clear_bits(ctx, EXYNOS_CIIMGCPT,\r\nEXYNOS_CIIMGCPT_IMGCPTEN_SC | EXYNOS_CIIMGCPT_IMGCPTEN);\r\nfimc_set_bits(ctx, EXYNOS_CIGCTRL, EXYNOS_CIGCTRL_SWRST);\r\nfimc_clear_bits(ctx, EXYNOS_CIGCTRL, EXYNOS_CIGCTRL_SWRST);\r\nfimc_write(ctx, 0x0, EXYNOS_CIFCNTSEQ);\r\n}\r\nstatic int fimc_set_camblk_fimd0_wb(struct fimc_context *ctx)\r\n{\r\nreturn regmap_update_bits(ctx->sysreg, SYSREG_CAMERA_BLK,\r\nSYSREG_FIMD0WB_DEST_MASK,\r\nctx->id << SYSREG_FIMD0WB_DEST_SHIFT);\r\n}\r\nstatic void fimc_set_type_ctrl(struct fimc_context *ctx, enum fimc_wb wb)\r\n{\r\nu32 cfg;\r\nDRM_DEBUG_KMS("wb[%d]\n", wb);\r\ncfg = fimc_read(ctx, EXYNOS_CIGCTRL);\r\ncfg &= ~(EXYNOS_CIGCTRL_TESTPATTERN_MASK |\r\nEXYNOS_CIGCTRL_SELCAM_ITU_MASK |\r\nEXYNOS_CIGCTRL_SELCAM_MIPI_MASK |\r\nEXYNOS_CIGCTRL_SELCAM_FIMC_MASK |\r\nEXYNOS_CIGCTRL_SELWB_CAMIF_MASK |\r\nEXYNOS_CIGCTRL_SELWRITEBACK_MASK);\r\nswitch (wb) {\r\ncase FIMC_WB_A:\r\ncfg |= (EXYNOS_CIGCTRL_SELWRITEBACK_A |\r\nEXYNOS_CIGCTRL_SELWB_CAMIF_WRITEBACK);\r\nbreak;\r\ncase FIMC_WB_B:\r\ncfg |= (EXYNOS_CIGCTRL_SELWRITEBACK_B |\r\nEXYNOS_CIGCTRL_SELWB_CAMIF_WRITEBACK);\r\nbreak;\r\ncase FIMC_WB_NONE:\r\ndefault:\r\ncfg |= (EXYNOS_CIGCTRL_SELCAM_ITU_A |\r\nEXYNOS_CIGCTRL_SELWRITEBACK_A |\r\nEXYNOS_CIGCTRL_SELCAM_MIPI_A |\r\nEXYNOS_CIGCTRL_SELCAM_FIMC_ITU);\r\nbreak;\r\n}\r\nfimc_write(ctx, cfg, EXYNOS_CIGCTRL);\r\n}\r\nstatic void fimc_handle_jpeg(struct fimc_context *ctx, bool enable)\r\n{\r\nu32 cfg;\r\nDRM_DEBUG_KMS("enable[%d]\n", enable);\r\ncfg = fimc_read(ctx, EXYNOS_CIGCTRL);\r\nif (enable)\r\ncfg |= EXYNOS_CIGCTRL_CAM_JPEG;\r\nelse\r\ncfg &= ~EXYNOS_CIGCTRL_CAM_JPEG;\r\nfimc_write(ctx, cfg, EXYNOS_CIGCTRL);\r\n}\r\nstatic void fimc_mask_irq(struct fimc_context *ctx, bool enable)\r\n{\r\nu32 cfg;\r\nDRM_DEBUG_KMS("enable[%d]\n", enable);\r\ncfg = fimc_read(ctx, EXYNOS_CIGCTRL);\r\nif (enable) {\r\ncfg &= ~EXYNOS_CIGCTRL_IRQ_OVFEN;\r\ncfg |= EXYNOS_CIGCTRL_IRQ_ENABLE | EXYNOS_CIGCTRL_IRQ_LEVEL;\r\n} else\r\ncfg &= ~EXYNOS_CIGCTRL_IRQ_ENABLE;\r\nfimc_write(ctx, cfg, EXYNOS_CIGCTRL);\r\n}\r\nstatic void fimc_clear_irq(struct fimc_context *ctx)\r\n{\r\nfimc_set_bits(ctx, EXYNOS_CIGCTRL, EXYNOS_CIGCTRL_IRQ_CLR);\r\n}\r\nstatic bool fimc_check_ovf(struct fimc_context *ctx)\r\n{\r\nstruct exynos_drm_ippdrv *ippdrv = &ctx->ippdrv;\r\nu32 status, flag;\r\nstatus = fimc_read(ctx, EXYNOS_CISTATUS);\r\nflag = EXYNOS_CISTATUS_OVFIY | EXYNOS_CISTATUS_OVFICB |\r\nEXYNOS_CISTATUS_OVFICR;\r\nDRM_DEBUG_KMS("flag[0x%x]\n", flag);\r\nif (status & flag) {\r\nfimc_set_bits(ctx, EXYNOS_CIWDOFST,\r\nEXYNOS_CIWDOFST_CLROVFIY | EXYNOS_CIWDOFST_CLROVFICB |\r\nEXYNOS_CIWDOFST_CLROVFICR);\r\ndev_err(ippdrv->dev, "occurred overflow at %d, status 0x%x.\n",\r\nctx->id, status);\r\nreturn true;\r\n}\r\nreturn false;\r\n}\r\nstatic bool fimc_check_frame_end(struct fimc_context *ctx)\r\n{\r\nu32 cfg;\r\ncfg = fimc_read(ctx, EXYNOS_CISTATUS);\r\nDRM_DEBUG_KMS("cfg[0x%x]\n", cfg);\r\nif (!(cfg & EXYNOS_CISTATUS_FRAMEEND))\r\nreturn false;\r\ncfg &= ~(EXYNOS_CISTATUS_FRAMEEND);\r\nfimc_write(ctx, cfg, EXYNOS_CISTATUS);\r\nreturn true;\r\n}\r\nstatic int fimc_get_buf_id(struct fimc_context *ctx)\r\n{\r\nu32 cfg;\r\nint frame_cnt, buf_id;\r\ncfg = fimc_read(ctx, EXYNOS_CISTATUS2);\r\nframe_cnt = EXYNOS_CISTATUS2_GET_FRAMECOUNT_BEFORE(cfg);\r\nif (frame_cnt == 0)\r\nframe_cnt = EXYNOS_CISTATUS2_GET_FRAMECOUNT_PRESENT(cfg);\r\nDRM_DEBUG_KMS("present[%d]before[%d]\n",\r\nEXYNOS_CISTATUS2_GET_FRAMECOUNT_PRESENT(cfg),\r\nEXYNOS_CISTATUS2_GET_FRAMECOUNT_BEFORE(cfg));\r\nif (frame_cnt == 0) {\r\nDRM_ERROR("failed to get frame count.\n");\r\nreturn -EIO;\r\n}\r\nbuf_id = frame_cnt - 1;\r\nDRM_DEBUG_KMS("buf_id[%d]\n", buf_id);\r\nreturn buf_id;\r\n}\r\nstatic void fimc_handle_lastend(struct fimc_context *ctx, bool enable)\r\n{\r\nu32 cfg;\r\nDRM_DEBUG_KMS("enable[%d]\n", enable);\r\ncfg = fimc_read(ctx, EXYNOS_CIOCTRL);\r\nif (enable)\r\ncfg |= EXYNOS_CIOCTRL_LASTENDEN;\r\nelse\r\ncfg &= ~EXYNOS_CIOCTRL_LASTENDEN;\r\nfimc_write(ctx, cfg, EXYNOS_CIOCTRL);\r\n}\r\nstatic int fimc_src_set_fmt_order(struct fimc_context *ctx, u32 fmt)\r\n{\r\nstruct exynos_drm_ippdrv *ippdrv = &ctx->ippdrv;\r\nu32 cfg;\r\nDRM_DEBUG_KMS("fmt[0x%x]\n", fmt);\r\ncfg = fimc_read(ctx, EXYNOS_CISCCTRL);\r\ncfg &= ~EXYNOS_CISCCTRL_INRGB_FMT_RGB_MASK;\r\nswitch (fmt) {\r\ncase DRM_FORMAT_RGB565:\r\ncfg |= EXYNOS_CISCCTRL_INRGB_FMT_RGB565;\r\nfimc_write(ctx, cfg, EXYNOS_CISCCTRL);\r\nreturn 0;\r\ncase DRM_FORMAT_RGB888:\r\ncase DRM_FORMAT_XRGB8888:\r\ncfg |= EXYNOS_CISCCTRL_INRGB_FMT_RGB888;\r\nfimc_write(ctx, cfg, EXYNOS_CISCCTRL);\r\nreturn 0;\r\ndefault:\r\nbreak;\r\n}\r\ncfg = fimc_read(ctx, EXYNOS_MSCTRL);\r\ncfg &= ~(EXYNOS_MSCTRL_ORDER2P_SHIFT_MASK |\r\nEXYNOS_MSCTRL_C_INT_IN_2PLANE |\r\nEXYNOS_MSCTRL_ORDER422_YCBYCR);\r\nswitch (fmt) {\r\ncase DRM_FORMAT_YUYV:\r\ncfg |= EXYNOS_MSCTRL_ORDER422_YCBYCR;\r\nbreak;\r\ncase DRM_FORMAT_YVYU:\r\ncfg |= EXYNOS_MSCTRL_ORDER422_YCRYCB;\r\nbreak;\r\ncase DRM_FORMAT_UYVY:\r\ncfg |= EXYNOS_MSCTRL_ORDER422_CBYCRY;\r\nbreak;\r\ncase DRM_FORMAT_VYUY:\r\ncase DRM_FORMAT_YUV444:\r\ncfg |= EXYNOS_MSCTRL_ORDER422_CRYCBY;\r\nbreak;\r\ncase DRM_FORMAT_NV21:\r\ncase DRM_FORMAT_NV61:\r\ncfg |= (EXYNOS_MSCTRL_ORDER2P_LSB_CRCB |\r\nEXYNOS_MSCTRL_C_INT_IN_2PLANE);\r\nbreak;\r\ncase DRM_FORMAT_YUV422:\r\ncase DRM_FORMAT_YUV420:\r\ncase DRM_FORMAT_YVU420:\r\ncfg |= EXYNOS_MSCTRL_C_INT_IN_3PLANE;\r\nbreak;\r\ncase DRM_FORMAT_NV12:\r\ncase DRM_FORMAT_NV16:\r\ncfg |= (EXYNOS_MSCTRL_ORDER2P_LSB_CBCR |\r\nEXYNOS_MSCTRL_C_INT_IN_2PLANE);\r\nbreak;\r\ndefault:\r\ndev_err(ippdrv->dev, "invalid source yuv order 0x%x.\n", fmt);\r\nreturn -EINVAL;\r\n}\r\nfimc_write(ctx, cfg, EXYNOS_MSCTRL);\r\nreturn 0;\r\n}\r\nstatic int fimc_src_set_fmt(struct device *dev, u32 fmt)\r\n{\r\nstruct fimc_context *ctx = get_fimc_context(dev);\r\nstruct exynos_drm_ippdrv *ippdrv = &ctx->ippdrv;\r\nu32 cfg;\r\nDRM_DEBUG_KMS("fmt[0x%x]\n", fmt);\r\ncfg = fimc_read(ctx, EXYNOS_MSCTRL);\r\ncfg &= ~EXYNOS_MSCTRL_INFORMAT_RGB;\r\nswitch (fmt) {\r\ncase DRM_FORMAT_RGB565:\r\ncase DRM_FORMAT_RGB888:\r\ncase DRM_FORMAT_XRGB8888:\r\ncfg |= EXYNOS_MSCTRL_INFORMAT_RGB;\r\nbreak;\r\ncase DRM_FORMAT_YUV444:\r\ncfg |= EXYNOS_MSCTRL_INFORMAT_YCBCR420;\r\nbreak;\r\ncase DRM_FORMAT_YUYV:\r\ncase DRM_FORMAT_YVYU:\r\ncase DRM_FORMAT_UYVY:\r\ncase DRM_FORMAT_VYUY:\r\ncfg |= EXYNOS_MSCTRL_INFORMAT_YCBCR422_1PLANE;\r\nbreak;\r\ncase DRM_FORMAT_NV16:\r\ncase DRM_FORMAT_NV61:\r\ncase DRM_FORMAT_YUV422:\r\ncfg |= EXYNOS_MSCTRL_INFORMAT_YCBCR422;\r\nbreak;\r\ncase DRM_FORMAT_YUV420:\r\ncase DRM_FORMAT_YVU420:\r\ncase DRM_FORMAT_NV12:\r\ncase DRM_FORMAT_NV21:\r\ncfg |= EXYNOS_MSCTRL_INFORMAT_YCBCR420;\r\nbreak;\r\ndefault:\r\ndev_err(ippdrv->dev, "invalid source format 0x%x.\n", fmt);\r\nreturn -EINVAL;\r\n}\r\nfimc_write(ctx, cfg, EXYNOS_MSCTRL);\r\ncfg = fimc_read(ctx, EXYNOS_CIDMAPARAM);\r\ncfg &= ~EXYNOS_CIDMAPARAM_R_MODE_MASK;\r\ncfg |= EXYNOS_CIDMAPARAM_R_MODE_LINEAR;\r\nfimc_write(ctx, cfg, EXYNOS_CIDMAPARAM);\r\nreturn fimc_src_set_fmt_order(ctx, fmt);\r\n}\r\nstatic int fimc_src_set_transf(struct device *dev,\r\nenum drm_exynos_degree degree,\r\nenum drm_exynos_flip flip, bool *swap)\r\n{\r\nstruct fimc_context *ctx = get_fimc_context(dev);\r\nstruct exynos_drm_ippdrv *ippdrv = &ctx->ippdrv;\r\nu32 cfg1, cfg2;\r\nDRM_DEBUG_KMS("degree[%d]flip[0x%x]\n", degree, flip);\r\ncfg1 = fimc_read(ctx, EXYNOS_MSCTRL);\r\ncfg1 &= ~(EXYNOS_MSCTRL_FLIP_X_MIRROR |\r\nEXYNOS_MSCTRL_FLIP_Y_MIRROR);\r\ncfg2 = fimc_read(ctx, EXYNOS_CITRGFMT);\r\ncfg2 &= ~EXYNOS_CITRGFMT_INROT90_CLOCKWISE;\r\nswitch (degree) {\r\ncase EXYNOS_DRM_DEGREE_0:\r\nif (flip & EXYNOS_DRM_FLIP_VERTICAL)\r\ncfg1 |= EXYNOS_MSCTRL_FLIP_X_MIRROR;\r\nif (flip & EXYNOS_DRM_FLIP_HORIZONTAL)\r\ncfg1 |= EXYNOS_MSCTRL_FLIP_Y_MIRROR;\r\nbreak;\r\ncase EXYNOS_DRM_DEGREE_90:\r\ncfg2 |= EXYNOS_CITRGFMT_INROT90_CLOCKWISE;\r\nif (flip & EXYNOS_DRM_FLIP_VERTICAL)\r\ncfg1 |= EXYNOS_MSCTRL_FLIP_X_MIRROR;\r\nif (flip & EXYNOS_DRM_FLIP_HORIZONTAL)\r\ncfg1 |= EXYNOS_MSCTRL_FLIP_Y_MIRROR;\r\nbreak;\r\ncase EXYNOS_DRM_DEGREE_180:\r\ncfg1 |= (EXYNOS_MSCTRL_FLIP_X_MIRROR |\r\nEXYNOS_MSCTRL_FLIP_Y_MIRROR);\r\nif (flip & EXYNOS_DRM_FLIP_VERTICAL)\r\ncfg1 &= ~EXYNOS_MSCTRL_FLIP_X_MIRROR;\r\nif (flip & EXYNOS_DRM_FLIP_HORIZONTAL)\r\ncfg1 &= ~EXYNOS_MSCTRL_FLIP_Y_MIRROR;\r\nbreak;\r\ncase EXYNOS_DRM_DEGREE_270:\r\ncfg1 |= (EXYNOS_MSCTRL_FLIP_X_MIRROR |\r\nEXYNOS_MSCTRL_FLIP_Y_MIRROR);\r\ncfg2 |= EXYNOS_CITRGFMT_INROT90_CLOCKWISE;\r\nif (flip & EXYNOS_DRM_FLIP_VERTICAL)\r\ncfg1 &= ~EXYNOS_MSCTRL_FLIP_X_MIRROR;\r\nif (flip & EXYNOS_DRM_FLIP_HORIZONTAL)\r\ncfg1 &= ~EXYNOS_MSCTRL_FLIP_Y_MIRROR;\r\nbreak;\r\ndefault:\r\ndev_err(ippdrv->dev, "invalid degree value %d.\n", degree);\r\nreturn -EINVAL;\r\n}\r\nfimc_write(ctx, cfg1, EXYNOS_MSCTRL);\r\nfimc_write(ctx, cfg2, EXYNOS_CITRGFMT);\r\n*swap = (cfg2 & EXYNOS_CITRGFMT_INROT90_CLOCKWISE) ? 1 : 0;\r\nreturn 0;\r\n}\r\nstatic int fimc_set_window(struct fimc_context *ctx,\r\nstruct drm_exynos_pos *pos, struct drm_exynos_sz *sz)\r\n{\r\nu32 cfg, h1, h2, v1, v2;\r\nh1 = pos->x;\r\nh2 = sz->hsize - pos->w - pos->x;\r\nv1 = pos->y;\r\nv2 = sz->vsize - pos->h - pos->y;\r\nDRM_DEBUG_KMS("x[%d]y[%d]w[%d]h[%d]hsize[%d]vsize[%d]\n",\r\npos->x, pos->y, pos->w, pos->h, sz->hsize, sz->vsize);\r\nDRM_DEBUG_KMS("h1[%d]h2[%d]v1[%d]v2[%d]\n", h1, h2, v1, v2);\r\ncfg = fimc_read(ctx, EXYNOS_CIWDOFST);\r\ncfg &= ~(EXYNOS_CIWDOFST_WINHOROFST_MASK |\r\nEXYNOS_CIWDOFST_WINVEROFST_MASK);\r\ncfg |= (EXYNOS_CIWDOFST_WINHOROFST(h1) |\r\nEXYNOS_CIWDOFST_WINVEROFST(v1));\r\ncfg |= EXYNOS_CIWDOFST_WINOFSEN;\r\nfimc_write(ctx, cfg, EXYNOS_CIWDOFST);\r\ncfg = (EXYNOS_CIWDOFST2_WINHOROFST2(h2) |\r\nEXYNOS_CIWDOFST2_WINVEROFST2(v2));\r\nfimc_write(ctx, cfg, EXYNOS_CIWDOFST2);\r\nreturn 0;\r\n}\r\nstatic int fimc_src_set_size(struct device *dev, int swap,\r\nstruct drm_exynos_pos *pos, struct drm_exynos_sz *sz)\r\n{\r\nstruct fimc_context *ctx = get_fimc_context(dev);\r\nstruct drm_exynos_pos img_pos = *pos;\r\nstruct drm_exynos_sz img_sz = *sz;\r\nu32 cfg;\r\nDRM_DEBUG_KMS("swap[%d]hsize[%d]vsize[%d]\n",\r\nswap, sz->hsize, sz->vsize);\r\ncfg = (EXYNOS_ORGISIZE_HORIZONTAL(img_sz.hsize) |\r\nEXYNOS_ORGISIZE_VERTICAL(img_sz.vsize));\r\nfimc_write(ctx, cfg, EXYNOS_ORGISIZE);\r\nDRM_DEBUG_KMS("x[%d]y[%d]w[%d]h[%d]\n", pos->x, pos->y, pos->w, pos->h);\r\nif (swap) {\r\nimg_pos.w = pos->h;\r\nimg_pos.h = pos->w;\r\nimg_sz.hsize = sz->vsize;\r\nimg_sz.vsize = sz->hsize;\r\n}\r\ncfg = fimc_read(ctx, EXYNOS_CIREAL_ISIZE);\r\ncfg &= ~(EXYNOS_CIREAL_ISIZE_HEIGHT_MASK |\r\nEXYNOS_CIREAL_ISIZE_WIDTH_MASK);\r\ncfg |= (EXYNOS_CIREAL_ISIZE_WIDTH(img_pos.w) |\r\nEXYNOS_CIREAL_ISIZE_HEIGHT(img_pos.h));\r\nfimc_write(ctx, cfg, EXYNOS_CIREAL_ISIZE);\r\ncfg = (EXYNOS_CISRCFMT_ITU601_8BIT |\r\nEXYNOS_CISRCFMT_SOURCEHSIZE(img_sz.hsize) |\r\nEXYNOS_CISRCFMT_SOURCEVSIZE(img_sz.vsize));\r\nfimc_write(ctx, cfg, EXYNOS_CISRCFMT);\r\ncfg = (EXYNOS_CIIYOFF_HORIZONTAL(img_pos.x) |\r\nEXYNOS_CIIYOFF_VERTICAL(img_pos.y));\r\nfimc_write(ctx, cfg, EXYNOS_CIIYOFF);\r\ncfg = (EXYNOS_CIICBOFF_HORIZONTAL(img_pos.x) |\r\nEXYNOS_CIICBOFF_VERTICAL(img_pos.y));\r\nfimc_write(ctx, cfg, EXYNOS_CIICBOFF);\r\ncfg = (EXYNOS_CIICROFF_HORIZONTAL(img_pos.x) |\r\nEXYNOS_CIICROFF_VERTICAL(img_pos.y));\r\nfimc_write(ctx, cfg, EXYNOS_CIICROFF);\r\nreturn fimc_set_window(ctx, &img_pos, &img_sz);\r\n}\r\nstatic int fimc_src_set_addr(struct device *dev,\r\nstruct drm_exynos_ipp_buf_info *buf_info, u32 buf_id,\r\nenum drm_exynos_ipp_buf_type buf_type)\r\n{\r\nstruct fimc_context *ctx = get_fimc_context(dev);\r\nstruct exynos_drm_ippdrv *ippdrv = &ctx->ippdrv;\r\nstruct drm_exynos_ipp_cmd_node *c_node = ippdrv->c_node;\r\nstruct drm_exynos_ipp_property *property;\r\nstruct drm_exynos_ipp_config *config;\r\nif (!c_node) {\r\nDRM_ERROR("failed to get c_node.\n");\r\nreturn -EINVAL;\r\n}\r\nproperty = &c_node->property;\r\nDRM_DEBUG_KMS("prop_id[%d]buf_id[%d]buf_type[%d]\n",\r\nproperty->prop_id, buf_id, buf_type);\r\nif (buf_id > FIMC_MAX_SRC) {\r\ndev_info(ippdrv->dev, "invalid buf_id %d.\n", buf_id);\r\nreturn -ENOMEM;\r\n}\r\nswitch (buf_type) {\r\ncase IPP_BUF_ENQUEUE:\r\nconfig = &property->config[EXYNOS_DRM_OPS_SRC];\r\nfimc_write(ctx, buf_info->base[EXYNOS_DRM_PLANAR_Y],\r\nEXYNOS_CIIYSA0);\r\nif (config->fmt == DRM_FORMAT_YVU420) {\r\nfimc_write(ctx, buf_info->base[EXYNOS_DRM_PLANAR_CR],\r\nEXYNOS_CIICBSA0);\r\nfimc_write(ctx, buf_info->base[EXYNOS_DRM_PLANAR_CB],\r\nEXYNOS_CIICRSA0);\r\n} else {\r\nfimc_write(ctx, buf_info->base[EXYNOS_DRM_PLANAR_CB],\r\nEXYNOS_CIICBSA0);\r\nfimc_write(ctx, buf_info->base[EXYNOS_DRM_PLANAR_CR],\r\nEXYNOS_CIICRSA0);\r\n}\r\nbreak;\r\ncase IPP_BUF_DEQUEUE:\r\nfimc_write(ctx, 0x0, EXYNOS_CIIYSA0);\r\nfimc_write(ctx, 0x0, EXYNOS_CIICBSA0);\r\nfimc_write(ctx, 0x0, EXYNOS_CIICRSA0);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic int fimc_dst_set_fmt_order(struct fimc_context *ctx, u32 fmt)\r\n{\r\nstruct exynos_drm_ippdrv *ippdrv = &ctx->ippdrv;\r\nu32 cfg;\r\nDRM_DEBUG_KMS("fmt[0x%x]\n", fmt);\r\ncfg = fimc_read(ctx, EXYNOS_CISCCTRL);\r\ncfg &= ~EXYNOS_CISCCTRL_OUTRGB_FMT_RGB_MASK;\r\nswitch (fmt) {\r\ncase DRM_FORMAT_RGB565:\r\ncfg |= EXYNOS_CISCCTRL_OUTRGB_FMT_RGB565;\r\nfimc_write(ctx, cfg, EXYNOS_CISCCTRL);\r\nreturn 0;\r\ncase DRM_FORMAT_RGB888:\r\ncfg |= EXYNOS_CISCCTRL_OUTRGB_FMT_RGB888;\r\nfimc_write(ctx, cfg, EXYNOS_CISCCTRL);\r\nreturn 0;\r\ncase DRM_FORMAT_XRGB8888:\r\ncfg |= (EXYNOS_CISCCTRL_OUTRGB_FMT_RGB888 |\r\nEXYNOS_CISCCTRL_EXTRGB_EXTENSION);\r\nfimc_write(ctx, cfg, EXYNOS_CISCCTRL);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\ncfg = fimc_read(ctx, EXYNOS_CIOCTRL);\r\ncfg &= ~(EXYNOS_CIOCTRL_ORDER2P_MASK |\r\nEXYNOS_CIOCTRL_ORDER422_MASK |\r\nEXYNOS_CIOCTRL_YCBCR_PLANE_MASK);\r\nswitch (fmt) {\r\ncase DRM_FORMAT_XRGB8888:\r\ncfg |= EXYNOS_CIOCTRL_ALPHA_OUT;\r\nbreak;\r\ncase DRM_FORMAT_YUYV:\r\ncfg |= EXYNOS_CIOCTRL_ORDER422_YCBYCR;\r\nbreak;\r\ncase DRM_FORMAT_YVYU:\r\ncfg |= EXYNOS_CIOCTRL_ORDER422_YCRYCB;\r\nbreak;\r\ncase DRM_FORMAT_UYVY:\r\ncfg |= EXYNOS_CIOCTRL_ORDER422_CBYCRY;\r\nbreak;\r\ncase DRM_FORMAT_VYUY:\r\ncfg |= EXYNOS_CIOCTRL_ORDER422_CRYCBY;\r\nbreak;\r\ncase DRM_FORMAT_NV21:\r\ncase DRM_FORMAT_NV61:\r\ncfg |= EXYNOS_CIOCTRL_ORDER2P_LSB_CRCB;\r\ncfg |= EXYNOS_CIOCTRL_YCBCR_2PLANE;\r\nbreak;\r\ncase DRM_FORMAT_YUV422:\r\ncase DRM_FORMAT_YUV420:\r\ncase DRM_FORMAT_YVU420:\r\ncfg |= EXYNOS_CIOCTRL_YCBCR_3PLANE;\r\nbreak;\r\ncase DRM_FORMAT_NV12:\r\ncase DRM_FORMAT_NV16:\r\ncfg |= EXYNOS_CIOCTRL_ORDER2P_LSB_CBCR;\r\ncfg |= EXYNOS_CIOCTRL_YCBCR_2PLANE;\r\nbreak;\r\ndefault:\r\ndev_err(ippdrv->dev, "invalid target yuv order 0x%x.\n", fmt);\r\nreturn -EINVAL;\r\n}\r\nfimc_write(ctx, cfg, EXYNOS_CIOCTRL);\r\nreturn 0;\r\n}\r\nstatic int fimc_dst_set_fmt(struct device *dev, u32 fmt)\r\n{\r\nstruct fimc_context *ctx = get_fimc_context(dev);\r\nstruct exynos_drm_ippdrv *ippdrv = &ctx->ippdrv;\r\nu32 cfg;\r\nDRM_DEBUG_KMS("fmt[0x%x]\n", fmt);\r\ncfg = fimc_read(ctx, EXYNOS_CIEXTEN);\r\nif (fmt == DRM_FORMAT_AYUV) {\r\ncfg |= EXYNOS_CIEXTEN_YUV444_OUT;\r\nfimc_write(ctx, cfg, EXYNOS_CIEXTEN);\r\n} else {\r\ncfg &= ~EXYNOS_CIEXTEN_YUV444_OUT;\r\nfimc_write(ctx, cfg, EXYNOS_CIEXTEN);\r\ncfg = fimc_read(ctx, EXYNOS_CITRGFMT);\r\ncfg &= ~EXYNOS_CITRGFMT_OUTFORMAT_MASK;\r\nswitch (fmt) {\r\ncase DRM_FORMAT_RGB565:\r\ncase DRM_FORMAT_RGB888:\r\ncase DRM_FORMAT_XRGB8888:\r\ncfg |= EXYNOS_CITRGFMT_OUTFORMAT_RGB;\r\nbreak;\r\ncase DRM_FORMAT_YUYV:\r\ncase DRM_FORMAT_YVYU:\r\ncase DRM_FORMAT_UYVY:\r\ncase DRM_FORMAT_VYUY:\r\ncfg |= EXYNOS_CITRGFMT_OUTFORMAT_YCBCR422_1PLANE;\r\nbreak;\r\ncase DRM_FORMAT_NV16:\r\ncase DRM_FORMAT_NV61:\r\ncase DRM_FORMAT_YUV422:\r\ncfg |= EXYNOS_CITRGFMT_OUTFORMAT_YCBCR422;\r\nbreak;\r\ncase DRM_FORMAT_YUV420:\r\ncase DRM_FORMAT_YVU420:\r\ncase DRM_FORMAT_NV12:\r\ncase DRM_FORMAT_NV21:\r\ncfg |= EXYNOS_CITRGFMT_OUTFORMAT_YCBCR420;\r\nbreak;\r\ndefault:\r\ndev_err(ippdrv->dev, "invalid target format 0x%x.\n",\r\nfmt);\r\nreturn -EINVAL;\r\n}\r\nfimc_write(ctx, cfg, EXYNOS_CITRGFMT);\r\n}\r\ncfg = fimc_read(ctx, EXYNOS_CIDMAPARAM);\r\ncfg &= ~EXYNOS_CIDMAPARAM_W_MODE_MASK;\r\ncfg |= EXYNOS_CIDMAPARAM_W_MODE_LINEAR;\r\nfimc_write(ctx, cfg, EXYNOS_CIDMAPARAM);\r\nreturn fimc_dst_set_fmt_order(ctx, fmt);\r\n}\r\nstatic int fimc_dst_set_transf(struct device *dev,\r\nenum drm_exynos_degree degree,\r\nenum drm_exynos_flip flip, bool *swap)\r\n{\r\nstruct fimc_context *ctx = get_fimc_context(dev);\r\nstruct exynos_drm_ippdrv *ippdrv = &ctx->ippdrv;\r\nu32 cfg;\r\nDRM_DEBUG_KMS("degree[%d]flip[0x%x]\n", degree, flip);\r\ncfg = fimc_read(ctx, EXYNOS_CITRGFMT);\r\ncfg &= ~EXYNOS_CITRGFMT_FLIP_MASK;\r\ncfg &= ~EXYNOS_CITRGFMT_OUTROT90_CLOCKWISE;\r\nswitch (degree) {\r\ncase EXYNOS_DRM_DEGREE_0:\r\nif (flip & EXYNOS_DRM_FLIP_VERTICAL)\r\ncfg |= EXYNOS_CITRGFMT_FLIP_X_MIRROR;\r\nif (flip & EXYNOS_DRM_FLIP_HORIZONTAL)\r\ncfg |= EXYNOS_CITRGFMT_FLIP_Y_MIRROR;\r\nbreak;\r\ncase EXYNOS_DRM_DEGREE_90:\r\ncfg |= EXYNOS_CITRGFMT_OUTROT90_CLOCKWISE;\r\nif (flip & EXYNOS_DRM_FLIP_VERTICAL)\r\ncfg |= EXYNOS_CITRGFMT_FLIP_X_MIRROR;\r\nif (flip & EXYNOS_DRM_FLIP_HORIZONTAL)\r\ncfg |= EXYNOS_CITRGFMT_FLIP_Y_MIRROR;\r\nbreak;\r\ncase EXYNOS_DRM_DEGREE_180:\r\ncfg |= (EXYNOS_CITRGFMT_FLIP_X_MIRROR |\r\nEXYNOS_CITRGFMT_FLIP_Y_MIRROR);\r\nif (flip & EXYNOS_DRM_FLIP_VERTICAL)\r\ncfg &= ~EXYNOS_CITRGFMT_FLIP_X_MIRROR;\r\nif (flip & EXYNOS_DRM_FLIP_HORIZONTAL)\r\ncfg &= ~EXYNOS_CITRGFMT_FLIP_Y_MIRROR;\r\nbreak;\r\ncase EXYNOS_DRM_DEGREE_270:\r\ncfg |= (EXYNOS_CITRGFMT_OUTROT90_CLOCKWISE |\r\nEXYNOS_CITRGFMT_FLIP_X_MIRROR |\r\nEXYNOS_CITRGFMT_FLIP_Y_MIRROR);\r\nif (flip & EXYNOS_DRM_FLIP_VERTICAL)\r\ncfg &= ~EXYNOS_CITRGFMT_FLIP_X_MIRROR;\r\nif (flip & EXYNOS_DRM_FLIP_HORIZONTAL)\r\ncfg &= ~EXYNOS_CITRGFMT_FLIP_Y_MIRROR;\r\nbreak;\r\ndefault:\r\ndev_err(ippdrv->dev, "invalid degree value %d.\n", degree);\r\nreturn -EINVAL;\r\n}\r\nfimc_write(ctx, cfg, EXYNOS_CITRGFMT);\r\n*swap = (cfg & EXYNOS_CITRGFMT_OUTROT90_CLOCKWISE) ? 1 : 0;\r\nreturn 0;\r\n}\r\nstatic int fimc_set_prescaler(struct fimc_context *ctx, struct fimc_scaler *sc,\r\nstruct drm_exynos_pos *src, struct drm_exynos_pos *dst)\r\n{\r\nstruct exynos_drm_ippdrv *ippdrv = &ctx->ippdrv;\r\nu32 cfg, cfg_ext, shfactor;\r\nu32 pre_dst_width, pre_dst_height;\r\nu32 hfactor, vfactor;\r\nint ret = 0;\r\nu32 src_w, src_h, dst_w, dst_h;\r\ncfg_ext = fimc_read(ctx, EXYNOS_CITRGFMT);\r\nif (cfg_ext & EXYNOS_CITRGFMT_INROT90_CLOCKWISE) {\r\nsrc_w = src->h;\r\nsrc_h = src->w;\r\n} else {\r\nsrc_w = src->w;\r\nsrc_h = src->h;\r\n}\r\nif (cfg_ext & EXYNOS_CITRGFMT_OUTROT90_CLOCKWISE) {\r\ndst_w = dst->h;\r\ndst_h = dst->w;\r\n} else {\r\ndst_w = dst->w;\r\ndst_h = dst->h;\r\n}\r\nhfactor = fls(src_w / dst_w / 2);\r\nif (hfactor > FIMC_SHFACTOR / 2) {\r\ndev_err(ippdrv->dev, "failed to get ratio horizontal.\n");\r\nreturn -EINVAL;\r\n}\r\nvfactor = fls(src_h / dst_h / 2);\r\nif (vfactor > FIMC_SHFACTOR / 2) {\r\ndev_err(ippdrv->dev, "failed to get ratio vertical.\n");\r\nreturn -EINVAL;\r\n}\r\npre_dst_width = src_w >> hfactor;\r\npre_dst_height = src_h >> vfactor;\r\nDRM_DEBUG_KMS("pre_dst_width[%d]pre_dst_height[%d]\n",\r\npre_dst_width, pre_dst_height);\r\nDRM_DEBUG_KMS("hfactor[%d]vfactor[%d]\n", hfactor, vfactor);\r\nsc->hratio = (src_w << 14) / (dst_w << hfactor);\r\nsc->vratio = (src_h << 14) / (dst_h << vfactor);\r\nsc->up_h = (dst_w >= src_w) ? true : false;\r\nsc->up_v = (dst_h >= src_h) ? true : false;\r\nDRM_DEBUG_KMS("hratio[%d]vratio[%d]up_h[%d]up_v[%d]\n",\r\nsc->hratio, sc->vratio, sc->up_h, sc->up_v);\r\nshfactor = FIMC_SHFACTOR - (hfactor + vfactor);\r\nDRM_DEBUG_KMS("shfactor[%d]\n", shfactor);\r\ncfg = (EXYNOS_CISCPRERATIO_SHFACTOR(shfactor) |\r\nEXYNOS_CISCPRERATIO_PREHORRATIO(1 << hfactor) |\r\nEXYNOS_CISCPRERATIO_PREVERRATIO(1 << vfactor));\r\nfimc_write(ctx, cfg, EXYNOS_CISCPRERATIO);\r\ncfg = (EXYNOS_CISCPREDST_PREDSTWIDTH(pre_dst_width) |\r\nEXYNOS_CISCPREDST_PREDSTHEIGHT(pre_dst_height));\r\nfimc_write(ctx, cfg, EXYNOS_CISCPREDST);\r\nreturn ret;\r\n}\r\nstatic void fimc_set_scaler(struct fimc_context *ctx, struct fimc_scaler *sc)\r\n{\r\nu32 cfg, cfg_ext;\r\nDRM_DEBUG_KMS("range[%d]bypass[%d]up_h[%d]up_v[%d]\n",\r\nsc->range, sc->bypass, sc->up_h, sc->up_v);\r\nDRM_DEBUG_KMS("hratio[%d]vratio[%d]\n",\r\nsc->hratio, sc->vratio);\r\ncfg = fimc_read(ctx, EXYNOS_CISCCTRL);\r\ncfg &= ~(EXYNOS_CISCCTRL_SCALERBYPASS |\r\nEXYNOS_CISCCTRL_SCALEUP_H | EXYNOS_CISCCTRL_SCALEUP_V |\r\nEXYNOS_CISCCTRL_MAIN_V_RATIO_MASK |\r\nEXYNOS_CISCCTRL_MAIN_H_RATIO_MASK |\r\nEXYNOS_CISCCTRL_CSCR2Y_WIDE |\r\nEXYNOS_CISCCTRL_CSCY2R_WIDE);\r\nif (sc->range)\r\ncfg |= (EXYNOS_CISCCTRL_CSCR2Y_WIDE |\r\nEXYNOS_CISCCTRL_CSCY2R_WIDE);\r\nif (sc->bypass)\r\ncfg |= EXYNOS_CISCCTRL_SCALERBYPASS;\r\nif (sc->up_h)\r\ncfg |= EXYNOS_CISCCTRL_SCALEUP_H;\r\nif (sc->up_v)\r\ncfg |= EXYNOS_CISCCTRL_SCALEUP_V;\r\ncfg |= (EXYNOS_CISCCTRL_MAINHORRATIO((sc->hratio >> 6)) |\r\nEXYNOS_CISCCTRL_MAINVERRATIO((sc->vratio >> 6)));\r\nfimc_write(ctx, cfg, EXYNOS_CISCCTRL);\r\ncfg_ext = fimc_read(ctx, EXYNOS_CIEXTEN);\r\ncfg_ext &= ~EXYNOS_CIEXTEN_MAINHORRATIO_EXT_MASK;\r\ncfg_ext &= ~EXYNOS_CIEXTEN_MAINVERRATIO_EXT_MASK;\r\ncfg_ext |= (EXYNOS_CIEXTEN_MAINHORRATIO_EXT(sc->hratio) |\r\nEXYNOS_CIEXTEN_MAINVERRATIO_EXT(sc->vratio));\r\nfimc_write(ctx, cfg_ext, EXYNOS_CIEXTEN);\r\n}\r\nstatic int fimc_dst_set_size(struct device *dev, int swap,\r\nstruct drm_exynos_pos *pos, struct drm_exynos_sz *sz)\r\n{\r\nstruct fimc_context *ctx = get_fimc_context(dev);\r\nstruct drm_exynos_pos img_pos = *pos;\r\nstruct drm_exynos_sz img_sz = *sz;\r\nu32 cfg;\r\nDRM_DEBUG_KMS("swap[%d]hsize[%d]vsize[%d]\n",\r\nswap, sz->hsize, sz->vsize);\r\ncfg = (EXYNOS_ORGOSIZE_HORIZONTAL(img_sz.hsize) |\r\nEXYNOS_ORGOSIZE_VERTICAL(img_sz.vsize));\r\nfimc_write(ctx, cfg, EXYNOS_ORGOSIZE);\r\nDRM_DEBUG_KMS("x[%d]y[%d]w[%d]h[%d]\n", pos->x, pos->y, pos->w, pos->h);\r\ncfg = fimc_read(ctx, EXYNOS_CIGCTRL);\r\ncfg &= ~EXYNOS_CIGCTRL_CSC_MASK;\r\nif (sz->hsize >= FIMC_WIDTH_ITU_709)\r\ncfg |= EXYNOS_CIGCTRL_CSC_ITU709;\r\nelse\r\ncfg |= EXYNOS_CIGCTRL_CSC_ITU601;\r\nfimc_write(ctx, cfg, EXYNOS_CIGCTRL);\r\nif (swap) {\r\nimg_pos.w = pos->h;\r\nimg_pos.h = pos->w;\r\nimg_sz.hsize = sz->vsize;\r\nimg_sz.vsize = sz->hsize;\r\n}\r\ncfg = fimc_read(ctx, EXYNOS_CITRGFMT);\r\ncfg &= ~(EXYNOS_CITRGFMT_TARGETH_MASK |\r\nEXYNOS_CITRGFMT_TARGETV_MASK);\r\ncfg |= (EXYNOS_CITRGFMT_TARGETHSIZE(img_pos.w) |\r\nEXYNOS_CITRGFMT_TARGETVSIZE(img_pos.h));\r\nfimc_write(ctx, cfg, EXYNOS_CITRGFMT);\r\ncfg = EXYNOS_CITAREA_TARGET_AREA(img_pos.w * img_pos.h);\r\nfimc_write(ctx, cfg, EXYNOS_CITAREA);\r\ncfg = (EXYNOS_CIOYOFF_HORIZONTAL(img_pos.x) |\r\nEXYNOS_CIOYOFF_VERTICAL(img_pos.y));\r\nfimc_write(ctx, cfg, EXYNOS_CIOYOFF);\r\ncfg = (EXYNOS_CIOCBOFF_HORIZONTAL(img_pos.x) |\r\nEXYNOS_CIOCBOFF_VERTICAL(img_pos.y));\r\nfimc_write(ctx, cfg, EXYNOS_CIOCBOFF);\r\ncfg = (EXYNOS_CIOCROFF_HORIZONTAL(img_pos.x) |\r\nEXYNOS_CIOCROFF_VERTICAL(img_pos.y));\r\nfimc_write(ctx, cfg, EXYNOS_CIOCROFF);\r\nreturn 0;\r\n}\r\nstatic void fimc_dst_set_buf_seq(struct fimc_context *ctx, u32 buf_id,\r\nenum drm_exynos_ipp_buf_type buf_type)\r\n{\r\nunsigned long flags;\r\nu32 buf_num;\r\nu32 cfg;\r\nDRM_DEBUG_KMS("buf_id[%d]buf_type[%d]\n", buf_id, buf_type);\r\nspin_lock_irqsave(&ctx->lock, flags);\r\ncfg = fimc_read(ctx, EXYNOS_CIFCNTSEQ);\r\nif (buf_type == IPP_BUF_ENQUEUE)\r\ncfg |= (1 << buf_id);\r\nelse\r\ncfg &= ~(1 << buf_id);\r\nfimc_write(ctx, cfg, EXYNOS_CIFCNTSEQ);\r\nbuf_num = hweight32(cfg);\r\nif (buf_type == IPP_BUF_ENQUEUE && buf_num >= FIMC_BUF_START)\r\nfimc_mask_irq(ctx, true);\r\nelse if (buf_type == IPP_BUF_DEQUEUE && buf_num <= FIMC_BUF_STOP)\r\nfimc_mask_irq(ctx, false);\r\nspin_unlock_irqrestore(&ctx->lock, flags);\r\n}\r\nstatic int fimc_dst_set_addr(struct device *dev,\r\nstruct drm_exynos_ipp_buf_info *buf_info, u32 buf_id,\r\nenum drm_exynos_ipp_buf_type buf_type)\r\n{\r\nstruct fimc_context *ctx = get_fimc_context(dev);\r\nstruct exynos_drm_ippdrv *ippdrv = &ctx->ippdrv;\r\nstruct drm_exynos_ipp_cmd_node *c_node = ippdrv->c_node;\r\nstruct drm_exynos_ipp_property *property;\r\nstruct drm_exynos_ipp_config *config;\r\nif (!c_node) {\r\nDRM_ERROR("failed to get c_node.\n");\r\nreturn -EINVAL;\r\n}\r\nproperty = &c_node->property;\r\nDRM_DEBUG_KMS("prop_id[%d]buf_id[%d]buf_type[%d]\n",\r\nproperty->prop_id, buf_id, buf_type);\r\nif (buf_id > FIMC_MAX_DST) {\r\ndev_info(ippdrv->dev, "invalid buf_id %d.\n", buf_id);\r\nreturn -ENOMEM;\r\n}\r\nswitch (buf_type) {\r\ncase IPP_BUF_ENQUEUE:\r\nconfig = &property->config[EXYNOS_DRM_OPS_DST];\r\nfimc_write(ctx, buf_info->base[EXYNOS_DRM_PLANAR_Y],\r\nEXYNOS_CIOYSA(buf_id));\r\nif (config->fmt == DRM_FORMAT_YVU420) {\r\nfimc_write(ctx, buf_info->base[EXYNOS_DRM_PLANAR_CR],\r\nEXYNOS_CIOCBSA(buf_id));\r\nfimc_write(ctx, buf_info->base[EXYNOS_DRM_PLANAR_CB],\r\nEXYNOS_CIOCRSA(buf_id));\r\n} else {\r\nfimc_write(ctx, buf_info->base[EXYNOS_DRM_PLANAR_CB],\r\nEXYNOS_CIOCBSA(buf_id));\r\nfimc_write(ctx, buf_info->base[EXYNOS_DRM_PLANAR_CR],\r\nEXYNOS_CIOCRSA(buf_id));\r\n}\r\nbreak;\r\ncase IPP_BUF_DEQUEUE:\r\nfimc_write(ctx, 0x0, EXYNOS_CIOYSA(buf_id));\r\nfimc_write(ctx, 0x0, EXYNOS_CIOCBSA(buf_id));\r\nfimc_write(ctx, 0x0, EXYNOS_CIOCRSA(buf_id));\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nfimc_dst_set_buf_seq(ctx, buf_id, buf_type);\r\nreturn 0;\r\n}\r\nstatic irqreturn_t fimc_irq_handler(int irq, void *dev_id)\r\n{\r\nstruct fimc_context *ctx = dev_id;\r\nstruct exynos_drm_ippdrv *ippdrv = &ctx->ippdrv;\r\nstruct drm_exynos_ipp_cmd_node *c_node = ippdrv->c_node;\r\nstruct drm_exynos_ipp_event_work *event_work =\r\nc_node->event_work;\r\nint buf_id;\r\nDRM_DEBUG_KMS("fimc id[%d]\n", ctx->id);\r\nfimc_clear_irq(ctx);\r\nif (fimc_check_ovf(ctx))\r\nreturn IRQ_NONE;\r\nif (!fimc_check_frame_end(ctx))\r\nreturn IRQ_NONE;\r\nbuf_id = fimc_get_buf_id(ctx);\r\nif (buf_id < 0)\r\nreturn IRQ_HANDLED;\r\nDRM_DEBUG_KMS("buf_id[%d]\n", buf_id);\r\nfimc_dst_set_buf_seq(ctx, buf_id, IPP_BUF_DEQUEUE);\r\nevent_work->ippdrv = ippdrv;\r\nevent_work->buf_id[EXYNOS_DRM_OPS_DST] = buf_id;\r\nqueue_work(ippdrv->event_workq, &event_work->work);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int fimc_init_prop_list(struct exynos_drm_ippdrv *ippdrv)\r\n{\r\nstruct drm_exynos_ipp_prop_list *prop_list = &ippdrv->prop_list;\r\nprop_list->version = 1;\r\nprop_list->writeback = 1;\r\nprop_list->refresh_min = FIMC_REFRESH_MIN;\r\nprop_list->refresh_max = FIMC_REFRESH_MAX;\r\nprop_list->flip = (1 << EXYNOS_DRM_FLIP_NONE) |\r\n(1 << EXYNOS_DRM_FLIP_VERTICAL) |\r\n(1 << EXYNOS_DRM_FLIP_HORIZONTAL);\r\nprop_list->degree = (1 << EXYNOS_DRM_DEGREE_0) |\r\n(1 << EXYNOS_DRM_DEGREE_90) |\r\n(1 << EXYNOS_DRM_DEGREE_180) |\r\n(1 << EXYNOS_DRM_DEGREE_270);\r\nprop_list->csc = 1;\r\nprop_list->crop = 1;\r\nprop_list->crop_max.hsize = FIMC_CROP_MAX;\r\nprop_list->crop_max.vsize = FIMC_CROP_MAX;\r\nprop_list->crop_min.hsize = FIMC_CROP_MIN;\r\nprop_list->crop_min.vsize = FIMC_CROP_MIN;\r\nprop_list->scale = 1;\r\nprop_list->scale_max.hsize = FIMC_SCALE_MAX;\r\nprop_list->scale_max.vsize = FIMC_SCALE_MAX;\r\nprop_list->scale_min.hsize = FIMC_SCALE_MIN;\r\nprop_list->scale_min.vsize = FIMC_SCALE_MIN;\r\nreturn 0;\r\n}\r\nstatic inline bool fimc_check_drm_flip(enum drm_exynos_flip flip)\r\n{\r\nswitch (flip) {\r\ncase EXYNOS_DRM_FLIP_NONE:\r\ncase EXYNOS_DRM_FLIP_VERTICAL:\r\ncase EXYNOS_DRM_FLIP_HORIZONTAL:\r\ncase EXYNOS_DRM_FLIP_BOTH:\r\nreturn true;\r\ndefault:\r\nDRM_DEBUG_KMS("invalid flip\n");\r\nreturn false;\r\n}\r\n}\r\nstatic int fimc_ippdrv_check_property(struct device *dev,\r\nstruct drm_exynos_ipp_property *property)\r\n{\r\nstruct fimc_context *ctx = get_fimc_context(dev);\r\nstruct exynos_drm_ippdrv *ippdrv = &ctx->ippdrv;\r\nstruct drm_exynos_ipp_prop_list *pp = &ippdrv->prop_list;\r\nstruct drm_exynos_ipp_config *config;\r\nstruct drm_exynos_pos *pos;\r\nstruct drm_exynos_sz *sz;\r\nbool swap;\r\nint i;\r\nfor_each_ipp_ops(i) {\r\nif ((i == EXYNOS_DRM_OPS_SRC) &&\r\n(property->cmd == IPP_CMD_WB))\r\ncontinue;\r\nconfig = &property->config[i];\r\npos = &config->pos;\r\nsz = &config->sz;\r\nif (!fimc_check_drm_flip(config->flip)) {\r\nDRM_ERROR("invalid flip.\n");\r\ngoto err_property;\r\n}\r\nswitch (config->degree) {\r\ncase EXYNOS_DRM_DEGREE_90:\r\ncase EXYNOS_DRM_DEGREE_270:\r\nswap = true;\r\nbreak;\r\ncase EXYNOS_DRM_DEGREE_0:\r\ncase EXYNOS_DRM_DEGREE_180:\r\nswap = false;\r\nbreak;\r\ndefault:\r\nDRM_ERROR("invalid degree.\n");\r\ngoto err_property;\r\n}\r\nif ((pos->x + pos->w > sz->hsize) ||\r\n(pos->y + pos->h > sz->vsize)) {\r\nDRM_ERROR("out of buf bound.\n");\r\ngoto err_property;\r\n}\r\nif ((i == EXYNOS_DRM_OPS_SRC) && (pp->crop)) {\r\nif (swap) {\r\nif ((pos->h < pp->crop_min.hsize) ||\r\n(sz->vsize > pp->crop_max.hsize) ||\r\n(pos->w < pp->crop_min.vsize) ||\r\n(sz->hsize > pp->crop_max.vsize)) {\r\nDRM_ERROR("out of crop size.\n");\r\ngoto err_property;\r\n}\r\n} else {\r\nif ((pos->w < pp->crop_min.hsize) ||\r\n(sz->hsize > pp->crop_max.hsize) ||\r\n(pos->h < pp->crop_min.vsize) ||\r\n(sz->vsize > pp->crop_max.vsize)) {\r\nDRM_ERROR("out of crop size.\n");\r\ngoto err_property;\r\n}\r\n}\r\n}\r\nif ((i == EXYNOS_DRM_OPS_DST) && (pp->scale)) {\r\nif (swap) {\r\nif ((pos->h < pp->scale_min.hsize) ||\r\n(sz->vsize > pp->scale_max.hsize) ||\r\n(pos->w < pp->scale_min.vsize) ||\r\n(sz->hsize > pp->scale_max.vsize)) {\r\nDRM_ERROR("out of scale size.\n");\r\ngoto err_property;\r\n}\r\n} else {\r\nif ((pos->w < pp->scale_min.hsize) ||\r\n(sz->hsize > pp->scale_max.hsize) ||\r\n(pos->h < pp->scale_min.vsize) ||\r\n(sz->vsize > pp->scale_max.vsize)) {\r\nDRM_ERROR("out of scale size.\n");\r\ngoto err_property;\r\n}\r\n}\r\n}\r\n}\r\nreturn 0;\r\nerr_property:\r\nfor_each_ipp_ops(i) {\r\nif ((i == EXYNOS_DRM_OPS_SRC) &&\r\n(property->cmd == IPP_CMD_WB))\r\ncontinue;\r\nconfig = &property->config[i];\r\npos = &config->pos;\r\nsz = &config->sz;\r\nDRM_ERROR("[%s]f[%d]r[%d]pos[%d %d %d %d]sz[%d %d]\n",\r\ni ? "dst" : "src", config->flip, config->degree,\r\npos->x, pos->y, pos->w, pos->h,\r\nsz->hsize, sz->vsize);\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic void fimc_clear_addr(struct fimc_context *ctx)\r\n{\r\nint i;\r\nfor (i = 0; i < FIMC_MAX_SRC; i++) {\r\nfimc_write(ctx, 0, EXYNOS_CIIYSA(i));\r\nfimc_write(ctx, 0, EXYNOS_CIICBSA(i));\r\nfimc_write(ctx, 0, EXYNOS_CIICRSA(i));\r\n}\r\nfor (i = 0; i < FIMC_MAX_DST; i++) {\r\nfimc_write(ctx, 0, EXYNOS_CIOYSA(i));\r\nfimc_write(ctx, 0, EXYNOS_CIOCBSA(i));\r\nfimc_write(ctx, 0, EXYNOS_CIOCRSA(i));\r\n}\r\n}\r\nstatic int fimc_ippdrv_reset(struct device *dev)\r\n{\r\nstruct fimc_context *ctx = get_fimc_context(dev);\r\nfimc_sw_reset(ctx);\r\nmemset(&ctx->sc, 0x0, sizeof(ctx->sc));\r\nfimc_clear_addr(ctx);\r\nreturn 0;\r\n}\r\nstatic int fimc_ippdrv_start(struct device *dev, enum drm_exynos_ipp_cmd cmd)\r\n{\r\nstruct fimc_context *ctx = get_fimc_context(dev);\r\nstruct exynos_drm_ippdrv *ippdrv = &ctx->ippdrv;\r\nstruct drm_exynos_ipp_cmd_node *c_node = ippdrv->c_node;\r\nstruct drm_exynos_ipp_property *property;\r\nstruct drm_exynos_ipp_config *config;\r\nstruct drm_exynos_pos img_pos[EXYNOS_DRM_OPS_MAX];\r\nstruct drm_exynos_ipp_set_wb set_wb;\r\nint ret, i;\r\nu32 cfg0, cfg1;\r\nDRM_DEBUG_KMS("cmd[%d]\n", cmd);\r\nif (!c_node) {\r\nDRM_ERROR("failed to get c_node.\n");\r\nreturn -EINVAL;\r\n}\r\nproperty = &c_node->property;\r\nfimc_mask_irq(ctx, true);\r\nfor_each_ipp_ops(i) {\r\nconfig = &property->config[i];\r\nimg_pos[i] = config->pos;\r\n}\r\nret = fimc_set_prescaler(ctx, &ctx->sc,\r\n&img_pos[EXYNOS_DRM_OPS_SRC],\r\n&img_pos[EXYNOS_DRM_OPS_DST]);\r\nif (ret) {\r\ndev_err(dev, "failed to set precalser.\n");\r\nreturn ret;\r\n}\r\nfimc_handle_jpeg(ctx, false);\r\nfimc_set_scaler(ctx, &ctx->sc);\r\nswitch (cmd) {\r\ncase IPP_CMD_M2M:\r\nfimc_set_type_ctrl(ctx, FIMC_WB_NONE);\r\nfimc_handle_lastend(ctx, false);\r\ncfg0 = fimc_read(ctx, EXYNOS_MSCTRL);\r\ncfg0 &= ~EXYNOS_MSCTRL_INPUT_MASK;\r\ncfg0 |= EXYNOS_MSCTRL_INPUT_MEMORY;\r\nfimc_write(ctx, cfg0, EXYNOS_MSCTRL);\r\nbreak;\r\ncase IPP_CMD_WB:\r\nfimc_set_type_ctrl(ctx, FIMC_WB_A);\r\nfimc_handle_lastend(ctx, true);\r\nret = fimc_set_camblk_fimd0_wb(ctx);\r\nif (ret < 0) {\r\ndev_err(dev, "camblk setup failed.\n");\r\nreturn ret;\r\n}\r\nset_wb.enable = 1;\r\nset_wb.refresh = property->refresh_rate;\r\nexynos_drm_ippnb_send_event(IPP_SET_WRITEBACK, (void *)&set_wb);\r\nbreak;\r\ncase IPP_CMD_OUTPUT:\r\ndefault:\r\nret = -EINVAL;\r\ndev_err(dev, "invalid operations.\n");\r\nreturn ret;\r\n}\r\nfimc_write(ctx, 0x0, EXYNOS_CISTATUS);\r\ncfg0 = fimc_read(ctx, EXYNOS_CIIMGCPT);\r\ncfg0 &= ~EXYNOS_CIIMGCPT_IMGCPTEN_SC;\r\ncfg0 |= EXYNOS_CIIMGCPT_IMGCPTEN_SC;\r\ncfg1 = fimc_read(ctx, EXYNOS_CISCCTRL);\r\ncfg1 &= ~EXYNOS_CISCCTRL_SCAN_MASK;\r\ncfg1 |= (EXYNOS_CISCCTRL_PROGRESSIVE |\r\nEXYNOS_CISCCTRL_SCALERSTART);\r\nfimc_write(ctx, cfg1, EXYNOS_CISCCTRL);\r\ncfg0 |= EXYNOS_CIIMGCPT_IMGCPTEN;\r\nfimc_write(ctx, cfg0, EXYNOS_CIIMGCPT);\r\nfimc_clear_bits(ctx, EXYNOS_CIGCTRL, EXYNOS_CIGCTRL_IRQ_END_DISABLE);\r\nfimc_clear_bits(ctx, EXYNOS_CIOCTRL, EXYNOS_CIOCTRL_WEAVE_MASK);\r\nif (cmd == IPP_CMD_M2M)\r\nfimc_set_bits(ctx, EXYNOS_MSCTRL, EXYNOS_MSCTRL_ENVID);\r\nreturn 0;\r\n}\r\nstatic void fimc_ippdrv_stop(struct device *dev, enum drm_exynos_ipp_cmd cmd)\r\n{\r\nstruct fimc_context *ctx = get_fimc_context(dev);\r\nstruct drm_exynos_ipp_set_wb set_wb = {0, 0};\r\nu32 cfg;\r\nDRM_DEBUG_KMS("cmd[%d]\n", cmd);\r\nswitch (cmd) {\r\ncase IPP_CMD_M2M:\r\ncfg = fimc_read(ctx, EXYNOS_MSCTRL);\r\ncfg &= ~EXYNOS_MSCTRL_INPUT_MASK;\r\ncfg &= ~EXYNOS_MSCTRL_ENVID;\r\nfimc_write(ctx, cfg, EXYNOS_MSCTRL);\r\nbreak;\r\ncase IPP_CMD_WB:\r\nexynos_drm_ippnb_send_event(IPP_SET_WRITEBACK, (void *)&set_wb);\r\nbreak;\r\ncase IPP_CMD_OUTPUT:\r\ndefault:\r\ndev_err(dev, "invalid operations.\n");\r\nbreak;\r\n}\r\nfimc_mask_irq(ctx, false);\r\nfimc_write(ctx, 0x0, EXYNOS_CIFCNTSEQ);\r\nfimc_clear_bits(ctx, EXYNOS_CISCCTRL, EXYNOS_CISCCTRL_SCALERSTART);\r\nfimc_clear_bits(ctx, EXYNOS_CIIMGCPT,\r\nEXYNOS_CIIMGCPT_IMGCPTEN_SC | EXYNOS_CIIMGCPT_IMGCPTEN);\r\nfimc_set_bits(ctx, EXYNOS_CIGCTRL, EXYNOS_CIGCTRL_IRQ_END_DISABLE);\r\n}\r\nstatic void fimc_put_clocks(struct fimc_context *ctx)\r\n{\r\nint i;\r\nfor (i = 0; i < FIMC_CLKS_MAX; i++) {\r\nif (IS_ERR(ctx->clocks[i]))\r\ncontinue;\r\nclk_put(ctx->clocks[i]);\r\nctx->clocks[i] = ERR_PTR(-EINVAL);\r\n}\r\n}\r\nstatic int fimc_setup_clocks(struct fimc_context *ctx)\r\n{\r\nstruct device *fimc_dev = ctx->ippdrv.dev;\r\nstruct device *dev;\r\nint ret, i;\r\nfor (i = 0; i < FIMC_CLKS_MAX; i++)\r\nctx->clocks[i] = ERR_PTR(-EINVAL);\r\nfor (i = 0; i < FIMC_CLKS_MAX; i++) {\r\nif (i == FIMC_CLK_WB_A || i == FIMC_CLK_WB_B)\r\ndev = fimc_dev->parent;\r\nelse\r\ndev = fimc_dev;\r\nctx->clocks[i] = clk_get(dev, fimc_clock_names[i]);\r\nif (IS_ERR(ctx->clocks[i])) {\r\nif (i >= FIMC_CLK_MUX)\r\nbreak;\r\nret = PTR_ERR(ctx->clocks[i]);\r\ndev_err(fimc_dev, "failed to get clock: %s\n",\r\nfimc_clock_names[i]);\r\ngoto e_clk_free;\r\n}\r\n}\r\nif (!IS_ERR(ctx->clocks[FIMC_CLK_PARENT])) {\r\nret = clk_set_parent(ctx->clocks[FIMC_CLK_MUX],\r\nctx->clocks[FIMC_CLK_PARENT]);\r\nif (ret < 0) {\r\ndev_err(fimc_dev, "failed to set parent.\n");\r\ngoto e_clk_free;\r\n}\r\n}\r\nret = clk_set_rate(ctx->clocks[FIMC_CLK_LCLK], ctx->clk_frequency);\r\nif (ret < 0)\r\ngoto e_clk_free;\r\nret = clk_prepare_enable(ctx->clocks[FIMC_CLK_LCLK]);\r\nif (!ret)\r\nreturn ret;\r\ne_clk_free:\r\nfimc_put_clocks(ctx);\r\nreturn ret;\r\n}\r\nstatic int fimc_parse_dt(struct fimc_context *ctx)\r\n{\r\nstruct device_node *node = ctx->ippdrv.dev->of_node;\r\nif (!of_property_read_bool(node, "samsung,lcd-wb"))\r\nreturn -ENODEV;\r\nif (of_property_read_u32(node, "clock-frequency",\r\n&ctx->clk_frequency))\r\nctx->clk_frequency = FIMC_DEFAULT_LCLK_FREQUENCY;\r\nctx->id = of_alias_get_id(node, "fimc");\r\nif (ctx->id < 0) {\r\ndev_err(ctx->ippdrv.dev, "failed to get node alias id.\n");\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int fimc_probe(struct platform_device *pdev)\r\n{\r\nstruct device *dev = &pdev->dev;\r\nstruct fimc_context *ctx;\r\nstruct resource *res;\r\nstruct exynos_drm_ippdrv *ippdrv;\r\nint ret;\r\nif (!dev->of_node) {\r\ndev_err(dev, "device tree node not found.\n");\r\nreturn -ENODEV;\r\n}\r\nctx = devm_kzalloc(dev, sizeof(*ctx), GFP_KERNEL);\r\nif (!ctx)\r\nreturn -ENOMEM;\r\nctx->ippdrv.dev = dev;\r\nret = fimc_parse_dt(ctx);\r\nif (ret < 0)\r\nreturn ret;\r\nctx->sysreg = syscon_regmap_lookup_by_phandle(dev->of_node,\r\n"samsung,sysreg");\r\nif (IS_ERR(ctx->sysreg)) {\r\ndev_err(dev, "syscon regmap lookup failed.\n");\r\nreturn PTR_ERR(ctx->sysreg);\r\n}\r\nctx->regs_res = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nctx->regs = devm_ioremap_resource(dev, ctx->regs_res);\r\nif (IS_ERR(ctx->regs))\r\nreturn PTR_ERR(ctx->regs);\r\nres = platform_get_resource(pdev, IORESOURCE_IRQ, 0);\r\nif (!res) {\r\ndev_err(dev, "failed to request irq resource.\n");\r\nreturn -ENOENT;\r\n}\r\nctx->irq = res->start;\r\nret = devm_request_threaded_irq(dev, ctx->irq, NULL, fimc_irq_handler,\r\nIRQF_ONESHOT, "drm_fimc", ctx);\r\nif (ret < 0) {\r\ndev_err(dev, "failed to request irq.\n");\r\nreturn ret;\r\n}\r\nret = fimc_setup_clocks(ctx);\r\nif (ret < 0)\r\nreturn ret;\r\nippdrv = &ctx->ippdrv;\r\nippdrv->ops[EXYNOS_DRM_OPS_SRC] = &fimc_src_ops;\r\nippdrv->ops[EXYNOS_DRM_OPS_DST] = &fimc_dst_ops;\r\nippdrv->check_property = fimc_ippdrv_check_property;\r\nippdrv->reset = fimc_ippdrv_reset;\r\nippdrv->start = fimc_ippdrv_start;\r\nippdrv->stop = fimc_ippdrv_stop;\r\nret = fimc_init_prop_list(ippdrv);\r\nif (ret < 0) {\r\ndev_err(dev, "failed to init property list.\n");\r\ngoto err_put_clk;\r\n}\r\nDRM_DEBUG_KMS("id[%d]ippdrv[%p]\n", ctx->id, ippdrv);\r\nspin_lock_init(&ctx->lock);\r\nplatform_set_drvdata(pdev, ctx);\r\npm_runtime_enable(dev);\r\nret = exynos_drm_ippdrv_register(ippdrv);\r\nif (ret < 0) {\r\ndev_err(dev, "failed to register drm fimc device.\n");\r\ngoto err_pm_dis;\r\n}\r\ndev_info(dev, "drm fimc registered successfully.\n");\r\nreturn 0;\r\nerr_pm_dis:\r\npm_runtime_disable(dev);\r\nerr_put_clk:\r\nfimc_put_clocks(ctx);\r\nreturn ret;\r\n}\r\nstatic int fimc_remove(struct platform_device *pdev)\r\n{\r\nstruct device *dev = &pdev->dev;\r\nstruct fimc_context *ctx = get_fimc_context(dev);\r\nstruct exynos_drm_ippdrv *ippdrv = &ctx->ippdrv;\r\nexynos_drm_ippdrv_unregister(ippdrv);\r\nfimc_put_clocks(ctx);\r\npm_runtime_set_suspended(dev);\r\npm_runtime_disable(dev);\r\nreturn 0;\r\n}\r\nstatic int fimc_clk_ctrl(struct fimc_context *ctx, bool enable)\r\n{\r\nDRM_DEBUG_KMS("enable[%d]\n", enable);\r\nif (enable) {\r\nclk_prepare_enable(ctx->clocks[FIMC_CLK_GATE]);\r\nclk_prepare_enable(ctx->clocks[FIMC_CLK_WB_A]);\r\nctx->suspended = false;\r\n} else {\r\nclk_disable_unprepare(ctx->clocks[FIMC_CLK_GATE]);\r\nclk_disable_unprepare(ctx->clocks[FIMC_CLK_WB_A]);\r\nctx->suspended = true;\r\n}\r\nreturn 0;\r\n}\r\nstatic int fimc_suspend(struct device *dev)\r\n{\r\nstruct fimc_context *ctx = get_fimc_context(dev);\r\nDRM_DEBUG_KMS("id[%d]\n", ctx->id);\r\nif (pm_runtime_suspended(dev))\r\nreturn 0;\r\nreturn fimc_clk_ctrl(ctx, false);\r\n}\r\nstatic int fimc_resume(struct device *dev)\r\n{\r\nstruct fimc_context *ctx = get_fimc_context(dev);\r\nDRM_DEBUG_KMS("id[%d]\n", ctx->id);\r\nif (!pm_runtime_suspended(dev))\r\nreturn fimc_clk_ctrl(ctx, true);\r\nreturn 0;\r\n}\r\nstatic int fimc_runtime_suspend(struct device *dev)\r\n{\r\nstruct fimc_context *ctx = get_fimc_context(dev);\r\nDRM_DEBUG_KMS("id[%d]\n", ctx->id);\r\nreturn fimc_clk_ctrl(ctx, false);\r\n}\r\nstatic int fimc_runtime_resume(struct device *dev)\r\n{\r\nstruct fimc_context *ctx = get_fimc_context(dev);\r\nDRM_DEBUG_KMS("id[%d]\n", ctx->id);\r\nreturn fimc_clk_ctrl(ctx, true);\r\n}
