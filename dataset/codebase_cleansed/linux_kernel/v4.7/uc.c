int hfi1_make_uc_req(struct rvt_qp *qp, struct hfi1_pkt_state *ps)\r\n{\r\nstruct hfi1_qp_priv *priv = qp->priv;\r\nstruct hfi1_other_headers *ohdr;\r\nstruct rvt_swqe *wqe;\r\nu32 hwords = 5;\r\nu32 bth0 = 0;\r\nu32 len;\r\nu32 pmtu = qp->pmtu;\r\nint middle = 0;\r\nps->s_txreq = get_txreq(ps->dev, qp);\r\nif (IS_ERR(ps->s_txreq))\r\ngoto bail_no_tx;\r\nif (!(ib_rvt_state_ops[qp->state] & RVT_PROCESS_SEND_OK)) {\r\nif (!(ib_rvt_state_ops[qp->state] & RVT_FLUSH_SEND))\r\ngoto bail;\r\nsmp_read_barrier_depends();\r\nif (qp->s_last == ACCESS_ONCE(qp->s_head))\r\ngoto bail;\r\nif (iowait_sdma_pending(&priv->s_iowait)) {\r\nqp->s_flags |= RVT_S_WAIT_DMA;\r\ngoto bail;\r\n}\r\nclear_ahg(qp);\r\nwqe = rvt_get_swqe_ptr(qp, qp->s_last);\r\nhfi1_send_complete(qp, wqe, IB_WC_WR_FLUSH_ERR);\r\ngoto done_free_tx;\r\n}\r\nohdr = &ps->s_txreq->phdr.hdr.u.oth;\r\nif (qp->remote_ah_attr.ah_flags & IB_AH_GRH)\r\nohdr = &ps->s_txreq->phdr.hdr.u.l.oth;\r\nwqe = rvt_get_swqe_ptr(qp, qp->s_cur);\r\nqp->s_wqe = NULL;\r\nswitch (qp->s_state) {\r\ndefault:\r\nif (!(ib_rvt_state_ops[qp->state] &\r\nRVT_PROCESS_NEXT_SEND_OK))\r\ngoto bail;\r\nsmp_read_barrier_depends();\r\nif (qp->s_cur == ACCESS_ONCE(qp->s_head)) {\r\nclear_ahg(qp);\r\ngoto bail;\r\n}\r\nqp->s_psn = wqe->psn;\r\nqp->s_sge.sge = wqe->sg_list[0];\r\nqp->s_sge.sg_list = wqe->sg_list + 1;\r\nqp->s_sge.num_sge = wqe->wr.num_sge;\r\nqp->s_sge.total_len = wqe->length;\r\nlen = wqe->length;\r\nqp->s_len = len;\r\nswitch (wqe->wr.opcode) {\r\ncase IB_WR_SEND:\r\ncase IB_WR_SEND_WITH_IMM:\r\nif (len > pmtu) {\r\nqp->s_state = OP(SEND_FIRST);\r\nlen = pmtu;\r\nbreak;\r\n}\r\nif (wqe->wr.opcode == IB_WR_SEND) {\r\nqp->s_state = OP(SEND_ONLY);\r\n} else {\r\nqp->s_state =\r\nOP(SEND_ONLY_WITH_IMMEDIATE);\r\nohdr->u.imm_data = wqe->wr.ex.imm_data;\r\nhwords += 1;\r\n}\r\nif (wqe->wr.send_flags & IB_SEND_SOLICITED)\r\nbth0 |= IB_BTH_SOLICITED;\r\nqp->s_wqe = wqe;\r\nif (++qp->s_cur >= qp->s_size)\r\nqp->s_cur = 0;\r\nbreak;\r\ncase IB_WR_RDMA_WRITE:\r\ncase IB_WR_RDMA_WRITE_WITH_IMM:\r\nohdr->u.rc.reth.vaddr =\r\ncpu_to_be64(wqe->rdma_wr.remote_addr);\r\nohdr->u.rc.reth.rkey =\r\ncpu_to_be32(wqe->rdma_wr.rkey);\r\nohdr->u.rc.reth.length = cpu_to_be32(len);\r\nhwords += sizeof(struct ib_reth) / 4;\r\nif (len > pmtu) {\r\nqp->s_state = OP(RDMA_WRITE_FIRST);\r\nlen = pmtu;\r\nbreak;\r\n}\r\nif (wqe->wr.opcode == IB_WR_RDMA_WRITE) {\r\nqp->s_state = OP(RDMA_WRITE_ONLY);\r\n} else {\r\nqp->s_state =\r\nOP(RDMA_WRITE_ONLY_WITH_IMMEDIATE);\r\nohdr->u.rc.imm_data = wqe->wr.ex.imm_data;\r\nhwords += 1;\r\nif (wqe->wr.send_flags & IB_SEND_SOLICITED)\r\nbth0 |= IB_BTH_SOLICITED;\r\n}\r\nqp->s_wqe = wqe;\r\nif (++qp->s_cur >= qp->s_size)\r\nqp->s_cur = 0;\r\nbreak;\r\ndefault:\r\ngoto bail;\r\n}\r\nbreak;\r\ncase OP(SEND_FIRST):\r\nqp->s_state = OP(SEND_MIDDLE);\r\ncase OP(SEND_MIDDLE):\r\nlen = qp->s_len;\r\nif (len > pmtu) {\r\nlen = pmtu;\r\nmiddle = HFI1_CAP_IS_KSET(SDMA_AHG);\r\nbreak;\r\n}\r\nif (wqe->wr.opcode == IB_WR_SEND) {\r\nqp->s_state = OP(SEND_LAST);\r\n} else {\r\nqp->s_state = OP(SEND_LAST_WITH_IMMEDIATE);\r\nohdr->u.imm_data = wqe->wr.ex.imm_data;\r\nhwords += 1;\r\n}\r\nif (wqe->wr.send_flags & IB_SEND_SOLICITED)\r\nbth0 |= IB_BTH_SOLICITED;\r\nqp->s_wqe = wqe;\r\nif (++qp->s_cur >= qp->s_size)\r\nqp->s_cur = 0;\r\nbreak;\r\ncase OP(RDMA_WRITE_FIRST):\r\nqp->s_state = OP(RDMA_WRITE_MIDDLE);\r\ncase OP(RDMA_WRITE_MIDDLE):\r\nlen = qp->s_len;\r\nif (len > pmtu) {\r\nlen = pmtu;\r\nmiddle = HFI1_CAP_IS_KSET(SDMA_AHG);\r\nbreak;\r\n}\r\nif (wqe->wr.opcode == IB_WR_RDMA_WRITE) {\r\nqp->s_state = OP(RDMA_WRITE_LAST);\r\n} else {\r\nqp->s_state =\r\nOP(RDMA_WRITE_LAST_WITH_IMMEDIATE);\r\nohdr->u.imm_data = wqe->wr.ex.imm_data;\r\nhwords += 1;\r\nif (wqe->wr.send_flags & IB_SEND_SOLICITED)\r\nbth0 |= IB_BTH_SOLICITED;\r\n}\r\nqp->s_wqe = wqe;\r\nif (++qp->s_cur >= qp->s_size)\r\nqp->s_cur = 0;\r\nbreak;\r\n}\r\nqp->s_len -= len;\r\nqp->s_hdrwords = hwords;\r\nps->s_txreq->sde = priv->s_sde;\r\nqp->s_cur_sge = &qp->s_sge;\r\nqp->s_cur_size = len;\r\nhfi1_make_ruc_header(qp, ohdr, bth0 | (qp->s_state << 24),\r\nmask_psn(qp->s_psn++), middle, ps);\r\nps->s_txreq->hdr_dwords = qp->s_hdrwords + 2;\r\nreturn 1;\r\ndone_free_tx:\r\nhfi1_put_txreq(ps->s_txreq);\r\nps->s_txreq = NULL;\r\nreturn 1;\r\nbail:\r\nhfi1_put_txreq(ps->s_txreq);\r\nbail_no_tx:\r\nps->s_txreq = NULL;\r\nqp->s_flags &= ~RVT_S_BUSY;\r\nqp->s_hdrwords = 0;\r\nreturn 0;\r\n}\r\nvoid hfi1_uc_rcv(struct hfi1_packet *packet)\r\n{\r\nstruct hfi1_ibport *ibp = &packet->rcd->ppd->ibport_data;\r\nstruct hfi1_ib_header *hdr = packet->hdr;\r\nu32 rcv_flags = packet->rcv_flags;\r\nvoid *data = packet->ebuf;\r\nu32 tlen = packet->tlen;\r\nstruct rvt_qp *qp = packet->qp;\r\nstruct hfi1_other_headers *ohdr = packet->ohdr;\r\nu32 bth0, opcode;\r\nu32 hdrsize = packet->hlen;\r\nu32 psn;\r\nu32 pad;\r\nstruct ib_wc wc;\r\nu32 pmtu = qp->pmtu;\r\nstruct ib_reth *reth;\r\nint has_grh = rcv_flags & HFI1_HAS_GRH;\r\nint ret;\r\nu32 bth1;\r\nbth0 = be32_to_cpu(ohdr->bth[0]);\r\nif (hfi1_ruc_check_hdr(ibp, hdr, has_grh, qp, bth0))\r\nreturn;\r\nbth1 = be32_to_cpu(ohdr->bth[1]);\r\nif (unlikely(bth1 & (HFI1_BECN_SMASK | HFI1_FECN_SMASK))) {\r\nif (bth1 & HFI1_BECN_SMASK) {\r\nstruct hfi1_pportdata *ppd = ppd_from_ibp(ibp);\r\nu32 rqpn, lqpn;\r\nu16 rlid = be16_to_cpu(hdr->lrh[3]);\r\nu8 sl, sc5;\r\nlqpn = bth1 & RVT_QPN_MASK;\r\nrqpn = qp->remote_qpn;\r\nsc5 = ibp->sl_to_sc[qp->remote_ah_attr.sl];\r\nsl = ibp->sc_to_sl[sc5];\r\nprocess_becn(ppd, sl, rlid, lqpn, rqpn,\r\nIB_CC_SVCTYPE_UC);\r\n}\r\nif (bth1 & HFI1_FECN_SMASK) {\r\nstruct ib_grh *grh = NULL;\r\nu16 pkey = (u16)be32_to_cpu(ohdr->bth[0]);\r\nu16 slid = be16_to_cpu(hdr->lrh[3]);\r\nu16 dlid = be16_to_cpu(hdr->lrh[1]);\r\nu32 src_qp = qp->remote_qpn;\r\nu8 sc5;\r\nsc5 = ibp->sl_to_sc[qp->remote_ah_attr.sl];\r\nif (has_grh)\r\ngrh = &hdr->u.l.grh;\r\nreturn_cnp(ibp, qp, src_qp, pkey, dlid, slid, sc5,\r\ngrh);\r\n}\r\n}\r\npsn = be32_to_cpu(ohdr->bth[2]);\r\nopcode = (bth0 >> 24) & 0xff;\r\nif (unlikely(cmp_psn(psn, qp->r_psn) != 0)) {\r\nqp->r_psn = psn;\r\ninv:\r\nif (qp->r_state == OP(SEND_FIRST) ||\r\nqp->r_state == OP(SEND_MIDDLE)) {\r\nset_bit(RVT_R_REWIND_SGE, &qp->r_aflags);\r\nqp->r_sge.num_sge = 0;\r\n} else {\r\nrvt_put_ss(&qp->r_sge);\r\n}\r\nqp->r_state = OP(SEND_LAST);\r\nswitch (opcode) {\r\ncase OP(SEND_FIRST):\r\ncase OP(SEND_ONLY):\r\ncase OP(SEND_ONLY_WITH_IMMEDIATE):\r\ngoto send_first;\r\ncase OP(RDMA_WRITE_FIRST):\r\ncase OP(RDMA_WRITE_ONLY):\r\ncase OP(RDMA_WRITE_ONLY_WITH_IMMEDIATE):\r\ngoto rdma_first;\r\ndefault:\r\ngoto drop;\r\n}\r\n}\r\nswitch (qp->r_state) {\r\ncase OP(SEND_FIRST):\r\ncase OP(SEND_MIDDLE):\r\nif (opcode == OP(SEND_MIDDLE) ||\r\nopcode == OP(SEND_LAST) ||\r\nopcode == OP(SEND_LAST_WITH_IMMEDIATE))\r\nbreak;\r\ngoto inv;\r\ncase OP(RDMA_WRITE_FIRST):\r\ncase OP(RDMA_WRITE_MIDDLE):\r\nif (opcode == OP(RDMA_WRITE_MIDDLE) ||\r\nopcode == OP(RDMA_WRITE_LAST) ||\r\nopcode == OP(RDMA_WRITE_LAST_WITH_IMMEDIATE))\r\nbreak;\r\ngoto inv;\r\ndefault:\r\nif (opcode == OP(SEND_FIRST) ||\r\nopcode == OP(SEND_ONLY) ||\r\nopcode == OP(SEND_ONLY_WITH_IMMEDIATE) ||\r\nopcode == OP(RDMA_WRITE_FIRST) ||\r\nopcode == OP(RDMA_WRITE_ONLY) ||\r\nopcode == OP(RDMA_WRITE_ONLY_WITH_IMMEDIATE))\r\nbreak;\r\ngoto inv;\r\n}\r\nif (qp->state == IB_QPS_RTR && !(qp->r_flags & RVT_R_COMM_EST))\r\nqp_comm_est(qp);\r\nswitch (opcode) {\r\ncase OP(SEND_FIRST):\r\ncase OP(SEND_ONLY):\r\ncase OP(SEND_ONLY_WITH_IMMEDIATE):\r\nsend_first:\r\nif (test_and_clear_bit(RVT_R_REWIND_SGE, &qp->r_aflags)) {\r\nqp->r_sge = qp->s_rdma_read_sge;\r\n} else {\r\nret = hfi1_rvt_get_rwqe(qp, 0);\r\nif (ret < 0)\r\ngoto op_err;\r\nif (!ret)\r\ngoto drop;\r\nqp->s_rdma_read_sge = qp->r_sge;\r\n}\r\nqp->r_rcv_len = 0;\r\nif (opcode == OP(SEND_ONLY))\r\ngoto no_immediate_data;\r\nelse if (opcode == OP(SEND_ONLY_WITH_IMMEDIATE))\r\ngoto send_last_imm;\r\ncase OP(SEND_MIDDLE):\r\nif (unlikely(tlen != (hdrsize + pmtu + 4)))\r\ngoto rewind;\r\nqp->r_rcv_len += pmtu;\r\nif (unlikely(qp->r_rcv_len > qp->r_len))\r\ngoto rewind;\r\nhfi1_copy_sge(&qp->r_sge, data, pmtu, 0, 0);\r\nbreak;\r\ncase OP(SEND_LAST_WITH_IMMEDIATE):\r\nsend_last_imm:\r\nwc.ex.imm_data = ohdr->u.imm_data;\r\nwc.wc_flags = IB_WC_WITH_IMM;\r\ngoto send_last;\r\ncase OP(SEND_LAST):\r\nno_immediate_data:\r\nwc.ex.imm_data = 0;\r\nwc.wc_flags = 0;\r\nsend_last:\r\npad = (be32_to_cpu(ohdr->bth[0]) >> 20) & 3;\r\nif (unlikely(tlen < (hdrsize + pad + 4)))\r\ngoto rewind;\r\ntlen -= (hdrsize + pad + 4);\r\nwc.byte_len = tlen + qp->r_rcv_len;\r\nif (unlikely(wc.byte_len > qp->r_len))\r\ngoto rewind;\r\nwc.opcode = IB_WC_RECV;\r\nhfi1_copy_sge(&qp->r_sge, data, tlen, 0, 0);\r\nrvt_put_ss(&qp->s_rdma_read_sge);\r\nlast_imm:\r\nwc.wr_id = qp->r_wr_id;\r\nwc.status = IB_WC_SUCCESS;\r\nwc.qp = &qp->ibqp;\r\nwc.src_qp = qp->remote_qpn;\r\nwc.slid = qp->remote_ah_attr.dlid;\r\nwc.sl = qp->remote_ah_attr.sl;\r\nwc.vendor_err = 0;\r\nwc.pkey_index = 0;\r\nwc.dlid_path_bits = 0;\r\nwc.port_num = 0;\r\nrvt_cq_enter(ibcq_to_rvtcq(qp->ibqp.recv_cq), &wc,\r\n(ohdr->bth[0] &\r\ncpu_to_be32(IB_BTH_SOLICITED)) != 0);\r\nbreak;\r\ncase OP(RDMA_WRITE_FIRST):\r\ncase OP(RDMA_WRITE_ONLY):\r\ncase OP(RDMA_WRITE_ONLY_WITH_IMMEDIATE):\r\nrdma_first:\r\nif (unlikely(!(qp->qp_access_flags &\r\nIB_ACCESS_REMOTE_WRITE))) {\r\ngoto drop;\r\n}\r\nreth = &ohdr->u.rc.reth;\r\nqp->r_len = be32_to_cpu(reth->length);\r\nqp->r_rcv_len = 0;\r\nqp->r_sge.sg_list = NULL;\r\nif (qp->r_len != 0) {\r\nu32 rkey = be32_to_cpu(reth->rkey);\r\nu64 vaddr = be64_to_cpu(reth->vaddr);\r\nint ok;\r\nok = rvt_rkey_ok(qp, &qp->r_sge.sge, qp->r_len,\r\nvaddr, rkey, IB_ACCESS_REMOTE_WRITE);\r\nif (unlikely(!ok))\r\ngoto drop;\r\nqp->r_sge.num_sge = 1;\r\n} else {\r\nqp->r_sge.num_sge = 0;\r\nqp->r_sge.sge.mr = NULL;\r\nqp->r_sge.sge.vaddr = NULL;\r\nqp->r_sge.sge.length = 0;\r\nqp->r_sge.sge.sge_length = 0;\r\n}\r\nif (opcode == OP(RDMA_WRITE_ONLY)) {\r\ngoto rdma_last;\r\n} else if (opcode == OP(RDMA_WRITE_ONLY_WITH_IMMEDIATE)) {\r\nwc.ex.imm_data = ohdr->u.rc.imm_data;\r\ngoto rdma_last_imm;\r\n}\r\ncase OP(RDMA_WRITE_MIDDLE):\r\nif (unlikely(tlen != (hdrsize + pmtu + 4)))\r\ngoto drop;\r\nqp->r_rcv_len += pmtu;\r\nif (unlikely(qp->r_rcv_len > qp->r_len))\r\ngoto drop;\r\nhfi1_copy_sge(&qp->r_sge, data, pmtu, 1, 0);\r\nbreak;\r\ncase OP(RDMA_WRITE_LAST_WITH_IMMEDIATE):\r\nwc.ex.imm_data = ohdr->u.imm_data;\r\nrdma_last_imm:\r\nwc.wc_flags = IB_WC_WITH_IMM;\r\npad = (be32_to_cpu(ohdr->bth[0]) >> 20) & 3;\r\nif (unlikely(tlen < (hdrsize + pad + 4)))\r\ngoto drop;\r\ntlen -= (hdrsize + pad + 4);\r\nif (unlikely(tlen + qp->r_rcv_len != qp->r_len))\r\ngoto drop;\r\nif (test_and_clear_bit(RVT_R_REWIND_SGE, &qp->r_aflags)) {\r\nrvt_put_ss(&qp->s_rdma_read_sge);\r\n} else {\r\nret = hfi1_rvt_get_rwqe(qp, 1);\r\nif (ret < 0)\r\ngoto op_err;\r\nif (!ret)\r\ngoto drop;\r\n}\r\nwc.byte_len = qp->r_len;\r\nwc.opcode = IB_WC_RECV_RDMA_WITH_IMM;\r\nhfi1_copy_sge(&qp->r_sge, data, tlen, 1, 0);\r\nrvt_put_ss(&qp->r_sge);\r\ngoto last_imm;\r\ncase OP(RDMA_WRITE_LAST):\r\nrdma_last:\r\npad = (be32_to_cpu(ohdr->bth[0]) >> 20) & 3;\r\nif (unlikely(tlen < (hdrsize + pad + 4)))\r\ngoto drop;\r\ntlen -= (hdrsize + pad + 4);\r\nif (unlikely(tlen + qp->r_rcv_len != qp->r_len))\r\ngoto drop;\r\nhfi1_copy_sge(&qp->r_sge, data, tlen, 1, 0);\r\nrvt_put_ss(&qp->r_sge);\r\nbreak;\r\ndefault:\r\ngoto drop;\r\n}\r\nqp->r_psn++;\r\nqp->r_state = opcode;\r\nreturn;\r\nrewind:\r\nset_bit(RVT_R_REWIND_SGE, &qp->r_aflags);\r\nqp->r_sge.num_sge = 0;\r\ndrop:\r\nibp->rvp.n_pkt_drops++;\r\nreturn;\r\nop_err:\r\nhfi1_rc_error(qp, IB_WC_LOC_QP_OP_ERR);\r\n}
