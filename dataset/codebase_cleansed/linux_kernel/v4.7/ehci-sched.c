static union ehci_shadow *\r\nperiodic_next_shadow(struct ehci_hcd *ehci, union ehci_shadow *periodic,\r\n__hc32 tag)\r\n{\r\nswitch (hc32_to_cpu(ehci, tag)) {\r\ncase Q_TYPE_QH:\r\nreturn &periodic->qh->qh_next;\r\ncase Q_TYPE_FSTN:\r\nreturn &periodic->fstn->fstn_next;\r\ncase Q_TYPE_ITD:\r\nreturn &periodic->itd->itd_next;\r\ndefault:\r\nreturn &periodic->sitd->sitd_next;\r\n}\r\n}\r\nstatic __hc32 *\r\nshadow_next_periodic(struct ehci_hcd *ehci, union ehci_shadow *periodic,\r\n__hc32 tag)\r\n{\r\nswitch (hc32_to_cpu(ehci, tag)) {\r\ncase Q_TYPE_QH:\r\nreturn &periodic->qh->hw->hw_next;\r\ndefault:\r\nreturn periodic->hw_next;\r\n}\r\n}\r\nstatic void periodic_unlink(struct ehci_hcd *ehci, unsigned frame, void *ptr)\r\n{\r\nunion ehci_shadow *prev_p = &ehci->pshadow[frame];\r\n__hc32 *hw_p = &ehci->periodic[frame];\r\nunion ehci_shadow here = *prev_p;\r\nwhile (here.ptr && here.ptr != ptr) {\r\nprev_p = periodic_next_shadow(ehci, prev_p,\r\nQ_NEXT_TYPE(ehci, *hw_p));\r\nhw_p = shadow_next_periodic(ehci, &here,\r\nQ_NEXT_TYPE(ehci, *hw_p));\r\nhere = *prev_p;\r\n}\r\nif (!here.ptr)\r\nreturn;\r\n*prev_p = *periodic_next_shadow(ehci, &here,\r\nQ_NEXT_TYPE(ehci, *hw_p));\r\nif (!ehci->use_dummy_qh ||\r\n*shadow_next_periodic(ehci, &here, Q_NEXT_TYPE(ehci, *hw_p))\r\n!= EHCI_LIST_END(ehci))\r\n*hw_p = *shadow_next_periodic(ehci, &here,\r\nQ_NEXT_TYPE(ehci, *hw_p));\r\nelse\r\n*hw_p = cpu_to_hc32(ehci, ehci->dummy->qh_dma);\r\n}\r\nstatic struct ehci_tt *find_tt(struct usb_device *udev)\r\n{\r\nstruct usb_tt *utt = udev->tt;\r\nstruct ehci_tt *tt, **tt_index, **ptt;\r\nunsigned port;\r\nbool allocated_index = false;\r\nif (!utt)\r\nreturn NULL;\r\ntt_index = NULL;\r\nif (utt->multi) {\r\ntt_index = utt->hcpriv;\r\nif (!tt_index) {\r\ntt_index = kzalloc(utt->hub->maxchild *\r\nsizeof(*tt_index), GFP_ATOMIC);\r\nif (!tt_index)\r\nreturn ERR_PTR(-ENOMEM);\r\nutt->hcpriv = tt_index;\r\nallocated_index = true;\r\n}\r\nport = udev->ttport - 1;\r\nptt = &tt_index[port];\r\n} else {\r\nport = 0;\r\nptt = (struct ehci_tt **) &utt->hcpriv;\r\n}\r\ntt = *ptt;\r\nif (!tt) {\r\nstruct ehci_hcd *ehci =\r\nhcd_to_ehci(bus_to_hcd(udev->bus));\r\ntt = kzalloc(sizeof(*tt), GFP_ATOMIC);\r\nif (!tt) {\r\nif (allocated_index) {\r\nutt->hcpriv = NULL;\r\nkfree(tt_index);\r\n}\r\nreturn ERR_PTR(-ENOMEM);\r\n}\r\nlist_add_tail(&tt->tt_list, &ehci->tt_list);\r\nINIT_LIST_HEAD(&tt->ps_list);\r\ntt->usb_tt = utt;\r\ntt->tt_port = port;\r\n*ptt = tt;\r\n}\r\nreturn tt;\r\n}\r\nstatic void drop_tt(struct usb_device *udev)\r\n{\r\nstruct usb_tt *utt = udev->tt;\r\nstruct ehci_tt *tt, **tt_index, **ptt;\r\nint cnt, i;\r\nif (!utt || !utt->hcpriv)\r\nreturn;\r\ncnt = 0;\r\nif (utt->multi) {\r\ntt_index = utt->hcpriv;\r\nptt = &tt_index[udev->ttport - 1];\r\nfor (i = 0; i < utt->hub->maxchild; ++i)\r\ncnt += !!tt_index[i];\r\n} else {\r\ntt_index = NULL;\r\nptt = (struct ehci_tt **) &utt->hcpriv;\r\n}\r\ntt = *ptt;\r\nif (!tt || !list_empty(&tt->ps_list))\r\nreturn;\r\nlist_del(&tt->tt_list);\r\n*ptt = NULL;\r\nkfree(tt);\r\nif (cnt == 1) {\r\nutt->hcpriv = NULL;\r\nkfree(tt_index);\r\n}\r\n}\r\nstatic void bandwidth_dbg(struct ehci_hcd *ehci, int sign, char *type,\r\nstruct ehci_per_sched *ps)\r\n{\r\ndev_dbg(&ps->udev->dev,\r\n"ep %02x: %s %s @ %u+%u (%u.%u+%u) [%u/%u us] mask %04x\n",\r\nps->ep->desc.bEndpointAddress,\r\n(sign >= 0 ? "reserve" : "release"), type,\r\n(ps->bw_phase << 3) + ps->phase_uf, ps->bw_uperiod,\r\nps->phase, ps->phase_uf, ps->period,\r\nps->usecs, ps->c_usecs, ps->cs_mask);\r\n}\r\nstatic void reserve_release_intr_bandwidth(struct ehci_hcd *ehci,\r\nstruct ehci_qh *qh, int sign)\r\n{\r\nunsigned start_uf;\r\nunsigned i, j, m;\r\nint usecs = qh->ps.usecs;\r\nint c_usecs = qh->ps.c_usecs;\r\nint tt_usecs = qh->ps.tt_usecs;\r\nstruct ehci_tt *tt;\r\nif (qh->ps.phase == NO_FRAME)\r\nreturn;\r\nstart_uf = qh->ps.bw_phase << 3;\r\nbandwidth_dbg(ehci, sign, "intr", &qh->ps);\r\nif (sign < 0) {\r\nusecs = -usecs;\r\nc_usecs = -c_usecs;\r\ntt_usecs = -tt_usecs;\r\n}\r\nfor (i = start_uf + qh->ps.phase_uf; i < EHCI_BANDWIDTH_SIZE;\r\ni += qh->ps.bw_uperiod)\r\nehci->bandwidth[i] += usecs;\r\nif (qh->ps.c_usecs) {\r\nfor (i = start_uf; i < EHCI_BANDWIDTH_SIZE;\r\ni += qh->ps.bw_uperiod) {\r\nfor ((j = 2, m = 1 << (j+8)); j < 8; (++j, m <<= 1)) {\r\nif (qh->ps.cs_mask & m)\r\nehci->bandwidth[i+j] += c_usecs;\r\n}\r\n}\r\n}\r\nif (tt_usecs) {\r\ntt = find_tt(qh->ps.udev);\r\nif (sign > 0)\r\nlist_add_tail(&qh->ps.ps_list, &tt->ps_list);\r\nelse\r\nlist_del(&qh->ps.ps_list);\r\nfor (i = start_uf >> 3; i < EHCI_BANDWIDTH_FRAMES;\r\ni += qh->ps.bw_period)\r\ntt->bandwidth[i] += tt_usecs;\r\n}\r\n}\r\nstatic void compute_tt_budget(u8 budget_table[EHCI_BANDWIDTH_SIZE],\r\nstruct ehci_tt *tt)\r\n{\r\nstruct ehci_per_sched *ps;\r\nunsigned uframe, uf, x;\r\nu8 *budget_line;\r\nif (!tt)\r\nreturn;\r\nmemset(budget_table, 0, EHCI_BANDWIDTH_SIZE);\r\nlist_for_each_entry(ps, &tt->ps_list, ps_list) {\r\nfor (uframe = ps->bw_phase << 3; uframe < EHCI_BANDWIDTH_SIZE;\r\nuframe += ps->bw_uperiod) {\r\nbudget_line = &budget_table[uframe];\r\nx = ps->tt_usecs;\r\nfor (uf = ps->phase_uf; uf < 8; ++uf) {\r\nx += budget_line[uf];\r\nif (x <= 125) {\r\nbudget_line[uf] = x;\r\nbreak;\r\n}\r\nbudget_line[uf] = 125;\r\nx -= 125;\r\n}\r\n}\r\n}\r\n}\r\nstatic int __maybe_unused same_tt(struct usb_device *dev1,\r\nstruct usb_device *dev2)\r\n{\r\nif (!dev1->tt || !dev2->tt)\r\nreturn 0;\r\nif (dev1->tt != dev2->tt)\r\nreturn 0;\r\nif (dev1->tt->multi)\r\nreturn dev1->ttport == dev2->ttport;\r\nelse\r\nreturn 1;\r\n}\r\nstatic inline unsigned char tt_start_uframe(struct ehci_hcd *ehci, __hc32 mask)\r\n{\r\nunsigned char smask = hc32_to_cpu(ehci, mask) & QH_SMASK;\r\nif (!smask) {\r\nehci_err(ehci, "invalid empty smask!\n");\r\nreturn 7;\r\n}\r\nreturn ffs(smask) - 1;\r\n}\r\nstatic inline void carryover_tt_bandwidth(unsigned short tt_usecs[8])\r\n{\r\nint i;\r\nfor (i = 0; i < 7; i++) {\r\nif (max_tt_usecs[i] < tt_usecs[i]) {\r\ntt_usecs[i+1] += tt_usecs[i] - max_tt_usecs[i];\r\ntt_usecs[i] = max_tt_usecs[i];\r\n}\r\n}\r\n}\r\nstatic int tt_available(\r\nstruct ehci_hcd *ehci,\r\nstruct ehci_per_sched *ps,\r\nstruct ehci_tt *tt,\r\nunsigned frame,\r\nunsigned uframe\r\n)\r\n{\r\nunsigned period = ps->bw_period;\r\nunsigned usecs = ps->tt_usecs;\r\nif ((period == 0) || (uframe >= 7))\r\nreturn 0;\r\nfor (frame &= period - 1; frame < EHCI_BANDWIDTH_FRAMES;\r\nframe += period) {\r\nunsigned i, uf;\r\nunsigned short tt_usecs[8];\r\nif (tt->bandwidth[frame] + usecs > 900)\r\nreturn 0;\r\nuf = frame << 3;\r\nfor (i = 0; i < 8; (++i, ++uf))\r\ntt_usecs[i] = ehci->tt_budget[uf];\r\nif (max_tt_usecs[uframe] <= tt_usecs[uframe])\r\nreturn 0;\r\nif (usecs > 125) {\r\nint ufs = (usecs / 125);\r\nfor (i = uframe; i < (uframe + ufs) && i < 8; i++)\r\nif (tt_usecs[i] > 0)\r\nreturn 0;\r\n}\r\ntt_usecs[uframe] += usecs;\r\ncarryover_tt_bandwidth(tt_usecs);\r\nif (max_tt_usecs[7] < tt_usecs[7])\r\nreturn 0;\r\n}\r\nreturn 1;\r\n}\r\nstatic int tt_no_collision(\r\nstruct ehci_hcd *ehci,\r\nunsigned period,\r\nstruct usb_device *dev,\r\nunsigned frame,\r\nu32 uf_mask\r\n)\r\n{\r\nif (period == 0)\r\nreturn 0;\r\nfor (; frame < ehci->periodic_size; frame += period) {\r\nunion ehci_shadow here;\r\n__hc32 type;\r\nstruct ehci_qh_hw *hw;\r\nhere = ehci->pshadow[frame];\r\ntype = Q_NEXT_TYPE(ehci, ehci->periodic[frame]);\r\nwhile (here.ptr) {\r\nswitch (hc32_to_cpu(ehci, type)) {\r\ncase Q_TYPE_ITD:\r\ntype = Q_NEXT_TYPE(ehci, here.itd->hw_next);\r\nhere = here.itd->itd_next;\r\ncontinue;\r\ncase Q_TYPE_QH:\r\nhw = here.qh->hw;\r\nif (same_tt(dev, here.qh->ps.udev)) {\r\nu32 mask;\r\nmask = hc32_to_cpu(ehci,\r\nhw->hw_info2);\r\nmask |= mask >> 8;\r\nif (mask & uf_mask)\r\nbreak;\r\n}\r\ntype = Q_NEXT_TYPE(ehci, hw->hw_next);\r\nhere = here.qh->qh_next;\r\ncontinue;\r\ncase Q_TYPE_SITD:\r\nif (same_tt(dev, here.sitd->urb->dev)) {\r\nu16 mask;\r\nmask = hc32_to_cpu(ehci, here.sitd\r\n->hw_uframe);\r\nmask |= mask >> 8;\r\nif (mask & uf_mask)\r\nbreak;\r\n}\r\ntype = Q_NEXT_TYPE(ehci, here.sitd->hw_next);\r\nhere = here.sitd->sitd_next;\r\ncontinue;\r\ndefault:\r\nehci_dbg(ehci,\r\n"periodic frame %d bogus type %d\n",\r\nframe, type);\r\n}\r\nreturn 0;\r\n}\r\n}\r\nreturn 1;\r\n}\r\nstatic void enable_periodic(struct ehci_hcd *ehci)\r\n{\r\nif (ehci->periodic_count++)\r\nreturn;\r\nehci->enabled_hrtimer_events &= ~BIT(EHCI_HRTIMER_DISABLE_PERIODIC);\r\nehci_poll_PSS(ehci);\r\nturn_on_io_watchdog(ehci);\r\n}\r\nstatic void disable_periodic(struct ehci_hcd *ehci)\r\n{\r\nif (--ehci->periodic_count)\r\nreturn;\r\nehci_poll_PSS(ehci);\r\n}\r\nstatic void qh_link_periodic(struct ehci_hcd *ehci, struct ehci_qh *qh)\r\n{\r\nunsigned i;\r\nunsigned period = qh->ps.period;\r\ndev_dbg(&qh->ps.udev->dev,\r\n"link qh%d-%04x/%p start %d [%d/%d us]\n",\r\nperiod, hc32_to_cpup(ehci, &qh->hw->hw_info2)\r\n& (QH_CMASK | QH_SMASK),\r\nqh, qh->ps.phase, qh->ps.usecs, qh->ps.c_usecs);\r\nif (period == 0)\r\nperiod = 1;\r\nfor (i = qh->ps.phase; i < ehci->periodic_size; i += period) {\r\nunion ehci_shadow *prev = &ehci->pshadow[i];\r\n__hc32 *hw_p = &ehci->periodic[i];\r\nunion ehci_shadow here = *prev;\r\n__hc32 type = 0;\r\nwhile (here.ptr) {\r\ntype = Q_NEXT_TYPE(ehci, *hw_p);\r\nif (type == cpu_to_hc32(ehci, Q_TYPE_QH))\r\nbreak;\r\nprev = periodic_next_shadow(ehci, prev, type);\r\nhw_p = shadow_next_periodic(ehci, &here, type);\r\nhere = *prev;\r\n}\r\nwhile (here.ptr && qh != here.qh) {\r\nif (qh->ps.period > here.qh->ps.period)\r\nbreak;\r\nprev = &here.qh->qh_next;\r\nhw_p = &here.qh->hw->hw_next;\r\nhere = *prev;\r\n}\r\nif (qh != here.qh) {\r\nqh->qh_next = here;\r\nif (here.qh)\r\nqh->hw->hw_next = *hw_p;\r\nwmb();\r\nprev->qh = qh;\r\n*hw_p = QH_NEXT(ehci, qh->qh_dma);\r\n}\r\n}\r\nqh->qh_state = QH_STATE_LINKED;\r\nqh->xacterrs = 0;\r\nqh->unlink_reason = 0;\r\nehci_to_hcd(ehci)->self.bandwidth_allocated += qh->ps.bw_period\r\n? ((qh->ps.usecs + qh->ps.c_usecs) / qh->ps.bw_period)\r\n: (qh->ps.usecs * 8);\r\nlist_add(&qh->intr_node, &ehci->intr_qh_list);\r\n++ehci->intr_count;\r\nenable_periodic(ehci);\r\n}\r\nstatic void qh_unlink_periodic(struct ehci_hcd *ehci, struct ehci_qh *qh)\r\n{\r\nunsigned i;\r\nunsigned period;\r\nperiod = qh->ps.period ? : 1;\r\nfor (i = qh->ps.phase; i < ehci->periodic_size; i += period)\r\nperiodic_unlink(ehci, i, qh);\r\nehci_to_hcd(ehci)->self.bandwidth_allocated -= qh->ps.bw_period\r\n? ((qh->ps.usecs + qh->ps.c_usecs) / qh->ps.bw_period)\r\n: (qh->ps.usecs * 8);\r\ndev_dbg(&qh->ps.udev->dev,\r\n"unlink qh%d-%04x/%p start %d [%d/%d us]\n",\r\nqh->ps.period,\r\nhc32_to_cpup(ehci, &qh->hw->hw_info2) & (QH_CMASK | QH_SMASK),\r\nqh, qh->ps.phase, qh->ps.usecs, qh->ps.c_usecs);\r\nqh->qh_state = QH_STATE_UNLINK;\r\nqh->qh_next.ptr = NULL;\r\nif (ehci->qh_scan_next == qh)\r\nehci->qh_scan_next = list_entry(qh->intr_node.next,\r\nstruct ehci_qh, intr_node);\r\nlist_del(&qh->intr_node);\r\n}\r\nstatic void cancel_unlink_wait_intr(struct ehci_hcd *ehci, struct ehci_qh *qh)\r\n{\r\nif (qh->qh_state != QH_STATE_LINKED ||\r\nlist_empty(&qh->unlink_node))\r\nreturn;\r\nlist_del_init(&qh->unlink_node);\r\n}\r\nstatic void start_unlink_intr(struct ehci_hcd *ehci, struct ehci_qh *qh)\r\n{\r\nif (qh->qh_state != QH_STATE_LINKED)\r\nreturn;\r\ncancel_unlink_wait_intr(ehci, qh);\r\nqh_unlink_periodic(ehci, qh);\r\nwmb();\r\nqh->unlink_cycle = ehci->intr_unlink_cycle;\r\nlist_add_tail(&qh->unlink_node, &ehci->intr_unlink);\r\nif (ehci->intr_unlinking)\r\n;\r\nelse if (ehci->rh_state < EHCI_RH_RUNNING)\r\nehci_handle_intr_unlinks(ehci);\r\nelse if (ehci->intr_unlink.next == &qh->unlink_node) {\r\nehci_enable_event(ehci, EHCI_HRTIMER_UNLINK_INTR, true);\r\n++ehci->intr_unlink_cycle;\r\n}\r\n}\r\nstatic void start_unlink_intr_wait(struct ehci_hcd *ehci,\r\nstruct ehci_qh *qh)\r\n{\r\nqh->unlink_cycle = ehci->intr_unlink_wait_cycle;\r\nlist_add_tail(&qh->unlink_node, &ehci->intr_unlink_wait);\r\nif (ehci->rh_state < EHCI_RH_RUNNING)\r\nehci_handle_start_intr_unlinks(ehci);\r\nelse if (ehci->intr_unlink_wait.next == &qh->unlink_node) {\r\nehci_enable_event(ehci, EHCI_HRTIMER_START_UNLINK_INTR, true);\r\n++ehci->intr_unlink_wait_cycle;\r\n}\r\n}\r\nstatic void end_unlink_intr(struct ehci_hcd *ehci, struct ehci_qh *qh)\r\n{\r\nstruct ehci_qh_hw *hw = qh->hw;\r\nint rc;\r\nqh->qh_state = QH_STATE_IDLE;\r\nhw->hw_next = EHCI_LIST_END(ehci);\r\nif (!list_empty(&qh->qtd_list))\r\nqh_completions(ehci, qh);\r\nif (!list_empty(&qh->qtd_list) && ehci->rh_state == EHCI_RH_RUNNING) {\r\nrc = qh_schedule(ehci, qh);\r\nif (rc == 0) {\r\nqh_refresh(ehci, qh);\r\nqh_link_periodic(ehci, qh);\r\n}\r\nelse {\r\nehci_err(ehci, "can't reschedule qh %p, err %d\n",\r\nqh, rc);\r\n}\r\n}\r\n--ehci->intr_count;\r\ndisable_periodic(ehci);\r\n}\r\nstatic int check_period(\r\nstruct ehci_hcd *ehci,\r\nunsigned frame,\r\nunsigned uframe,\r\nunsigned uperiod,\r\nunsigned usecs\r\n) {\r\nif (uframe >= 8)\r\nreturn 0;\r\nusecs = ehci->uframe_periodic_max - usecs;\r\nfor (uframe += frame << 3; uframe < EHCI_BANDWIDTH_SIZE;\r\nuframe += uperiod) {\r\nif (ehci->bandwidth[uframe] > usecs)\r\nreturn 0;\r\n}\r\nreturn 1;\r\n}\r\nstatic int check_intr_schedule(\r\nstruct ehci_hcd *ehci,\r\nunsigned frame,\r\nunsigned uframe,\r\nstruct ehci_qh *qh,\r\nunsigned *c_maskp,\r\nstruct ehci_tt *tt\r\n)\r\n{\r\nint retval = -ENOSPC;\r\nu8 mask = 0;\r\nif (qh->ps.c_usecs && uframe >= 6)\r\ngoto done;\r\nif (!check_period(ehci, frame, uframe, qh->ps.bw_uperiod, qh->ps.usecs))\r\ngoto done;\r\nif (!qh->ps.c_usecs) {\r\nretval = 0;\r\n*c_maskp = 0;\r\ngoto done;\r\n}\r\n#ifdef CONFIG_USB_EHCI_TT_NEWSCHED\r\nif (tt_available(ehci, &qh->ps, tt, frame, uframe)) {\r\nunsigned i;\r\nfor (i = uframe+2; i < 8 && i <= uframe+4; i++)\r\nif (!check_period(ehci, frame, i,\r\nqh->ps.bw_uperiod, qh->ps.c_usecs))\r\ngoto done;\r\nelse\r\nmask |= 1 << i;\r\nretval = 0;\r\n*c_maskp = mask;\r\n}\r\n#else\r\nmask = 0x03 << (uframe + qh->gap_uf);\r\n*c_maskp = mask;\r\nmask |= 1 << uframe;\r\nif (tt_no_collision(ehci, qh->ps.bw_period, qh->ps.udev, frame, mask)) {\r\nif (!check_period(ehci, frame, uframe + qh->gap_uf + 1,\r\nqh->ps.bw_uperiod, qh->ps.c_usecs))\r\ngoto done;\r\nif (!check_period(ehci, frame, uframe + qh->gap_uf,\r\nqh->ps.bw_uperiod, qh->ps.c_usecs))\r\ngoto done;\r\nretval = 0;\r\n}\r\n#endif\r\ndone:\r\nreturn retval;\r\n}\r\nstatic int qh_schedule(struct ehci_hcd *ehci, struct ehci_qh *qh)\r\n{\r\nint status = 0;\r\nunsigned uframe;\r\nunsigned c_mask;\r\nstruct ehci_qh_hw *hw = qh->hw;\r\nstruct ehci_tt *tt;\r\nhw->hw_next = EHCI_LIST_END(ehci);\r\nif (qh->ps.phase != NO_FRAME) {\r\nehci_dbg(ehci, "reused qh %p schedule\n", qh);\r\nreturn 0;\r\n}\r\nuframe = 0;\r\nc_mask = 0;\r\ntt = find_tt(qh->ps.udev);\r\nif (IS_ERR(tt)) {\r\nstatus = PTR_ERR(tt);\r\ngoto done;\r\n}\r\ncompute_tt_budget(ehci->tt_budget, tt);\r\nif (qh->ps.bw_period) {\r\nint i;\r\nunsigned frame;\r\nfor (i = qh->ps.bw_period; i > 0; --i) {\r\nframe = ++ehci->random_frame & (qh->ps.bw_period - 1);\r\nfor (uframe = 0; uframe < 8; uframe++) {\r\nstatus = check_intr_schedule(ehci,\r\nframe, uframe, qh, &c_mask, tt);\r\nif (status == 0)\r\ngoto got_it;\r\n}\r\n}\r\n} else {\r\nstatus = check_intr_schedule(ehci, 0, 0, qh, &c_mask, tt);\r\n}\r\nif (status)\r\ngoto done;\r\ngot_it:\r\nqh->ps.phase = (qh->ps.period ? ehci->random_frame &\r\n(qh->ps.period - 1) : 0);\r\nqh->ps.bw_phase = qh->ps.phase & (qh->ps.bw_period - 1);\r\nqh->ps.phase_uf = uframe;\r\nqh->ps.cs_mask = qh->ps.period ?\r\n(c_mask << 8) | (1 << uframe) :\r\nQH_SMASK;\r\nhw->hw_info2 &= cpu_to_hc32(ehci, ~(QH_CMASK | QH_SMASK));\r\nhw->hw_info2 |= cpu_to_hc32(ehci, qh->ps.cs_mask);\r\nreserve_release_intr_bandwidth(ehci, qh, 1);\r\ndone:\r\nreturn status;\r\n}\r\nstatic int intr_submit(\r\nstruct ehci_hcd *ehci,\r\nstruct urb *urb,\r\nstruct list_head *qtd_list,\r\ngfp_t mem_flags\r\n) {\r\nunsigned epnum;\r\nunsigned long flags;\r\nstruct ehci_qh *qh;\r\nint status;\r\nstruct list_head empty;\r\nepnum = urb->ep->desc.bEndpointAddress;\r\nspin_lock_irqsave(&ehci->lock, flags);\r\nif (unlikely(!HCD_HW_ACCESSIBLE(ehci_to_hcd(ehci)))) {\r\nstatus = -ESHUTDOWN;\r\ngoto done_not_linked;\r\n}\r\nstatus = usb_hcd_link_urb_to_ep(ehci_to_hcd(ehci), urb);\r\nif (unlikely(status))\r\ngoto done_not_linked;\r\nINIT_LIST_HEAD(&empty);\r\nqh = qh_append_tds(ehci, urb, &empty, epnum, &urb->ep->hcpriv);\r\nif (qh == NULL) {\r\nstatus = -ENOMEM;\r\ngoto done;\r\n}\r\nif (qh->qh_state == QH_STATE_IDLE) {\r\nstatus = qh_schedule(ehci, qh);\r\nif (status)\r\ngoto done;\r\n}\r\nqh = qh_append_tds(ehci, urb, qtd_list, epnum, &urb->ep->hcpriv);\r\nBUG_ON(qh == NULL);\r\nif (qh->qh_state == QH_STATE_IDLE) {\r\nqh_refresh(ehci, qh);\r\nqh_link_periodic(ehci, qh);\r\n} else {\r\ncancel_unlink_wait_intr(ehci, qh);\r\n}\r\nehci_to_hcd(ehci)->self.bandwidth_int_reqs++;\r\ndone:\r\nif (unlikely(status))\r\nusb_hcd_unlink_urb_from_ep(ehci_to_hcd(ehci), urb);\r\ndone_not_linked:\r\nspin_unlock_irqrestore(&ehci->lock, flags);\r\nif (status)\r\nqtd_list_free(ehci, urb, qtd_list);\r\nreturn status;\r\n}\r\nstatic void scan_intr(struct ehci_hcd *ehci)\r\n{\r\nstruct ehci_qh *qh;\r\nlist_for_each_entry_safe(qh, ehci->qh_scan_next, &ehci->intr_qh_list,\r\nintr_node) {\r\nif (!list_empty(&qh->qtd_list)) {\r\nint temp;\r\ntemp = qh_completions(ehci, qh);\r\nif (unlikely(temp))\r\nstart_unlink_intr(ehci, qh);\r\nelse if (unlikely(list_empty(&qh->qtd_list) &&\r\nqh->qh_state == QH_STATE_LINKED))\r\nstart_unlink_intr_wait(ehci, qh);\r\n}\r\n}\r\n}\r\nstatic struct ehci_iso_stream *\r\niso_stream_alloc(gfp_t mem_flags)\r\n{\r\nstruct ehci_iso_stream *stream;\r\nstream = kzalloc(sizeof(*stream), mem_flags);\r\nif (likely(stream != NULL)) {\r\nINIT_LIST_HEAD(&stream->td_list);\r\nINIT_LIST_HEAD(&stream->free_list);\r\nstream->next_uframe = NO_FRAME;\r\nstream->ps.phase = NO_FRAME;\r\n}\r\nreturn stream;\r\n}\r\nstatic void\r\niso_stream_init(\r\nstruct ehci_hcd *ehci,\r\nstruct ehci_iso_stream *stream,\r\nstruct urb *urb\r\n)\r\n{\r\nstatic const u8 smask_out[] = { 0x01, 0x03, 0x07, 0x0f, 0x1f, 0x3f };\r\nstruct usb_device *dev = urb->dev;\r\nu32 buf1;\r\nunsigned epnum, maxp;\r\nint is_input;\r\nunsigned tmp;\r\nepnum = usb_pipeendpoint(urb->pipe);\r\nis_input = usb_pipein(urb->pipe) ? USB_DIR_IN : 0;\r\nmaxp = usb_endpoint_maxp(&urb->ep->desc);\r\nbuf1 = is_input ? 1 << 11 : 0;\r\nif (dev->speed == USB_SPEED_HIGH) {\r\nunsigned multi = hb_mult(maxp);\r\nstream->highspeed = 1;\r\nmaxp = max_packet(maxp);\r\nbuf1 |= maxp;\r\nmaxp *= multi;\r\nstream->buf0 = cpu_to_hc32(ehci, (epnum << 8) | dev->devnum);\r\nstream->buf1 = cpu_to_hc32(ehci, buf1);\r\nstream->buf2 = cpu_to_hc32(ehci, multi);\r\nstream->ps.usecs = HS_USECS_ISO(maxp);\r\ntmp = min_t(unsigned, EHCI_BANDWIDTH_SIZE,\r\n1 << (urb->ep->desc.bInterval - 1));\r\nstream->ps.bw_uperiod = min_t(unsigned, tmp, urb->interval);\r\nstream->uperiod = urb->interval;\r\nstream->ps.period = urb->interval >> 3;\r\nstream->bandwidth = stream->ps.usecs * 8 /\r\nstream->ps.bw_uperiod;\r\n} else {\r\nu32 addr;\r\nint think_time;\r\nint hs_transfers;\r\naddr = dev->ttport << 24;\r\nif (!ehci_is_TDI(ehci)\r\n|| (dev->tt->hub !=\r\nehci_to_hcd(ehci)->self.root_hub))\r\naddr |= dev->tt->hub->devnum << 16;\r\naddr |= epnum << 8;\r\naddr |= dev->devnum;\r\nstream->ps.usecs = HS_USECS_ISO(maxp);\r\nthink_time = dev->tt ? dev->tt->think_time : 0;\r\nstream->ps.tt_usecs = NS_TO_US(think_time + usb_calc_bus_time(\r\ndev->speed, is_input, 1, maxp));\r\nhs_transfers = max(1u, (maxp + 187) / 188);\r\nif (is_input) {\r\nu32 tmp;\r\naddr |= 1 << 31;\r\nstream->ps.c_usecs = stream->ps.usecs;\r\nstream->ps.usecs = HS_USECS_ISO(1);\r\nstream->ps.cs_mask = 1;\r\ntmp = (1 << (hs_transfers + 2)) - 1;\r\nstream->ps.cs_mask |= tmp << (8 + 2);\r\n} else\r\nstream->ps.cs_mask = smask_out[hs_transfers - 1];\r\ntmp = min_t(unsigned, EHCI_BANDWIDTH_FRAMES,\r\n1 << (urb->ep->desc.bInterval - 1));\r\nstream->ps.bw_period = min_t(unsigned, tmp, urb->interval);\r\nstream->ps.bw_uperiod = stream->ps.bw_period << 3;\r\nstream->ps.period = urb->interval;\r\nstream->uperiod = urb->interval << 3;\r\nstream->bandwidth = (stream->ps.usecs + stream->ps.c_usecs) /\r\nstream->ps.bw_period;\r\nstream->address = cpu_to_hc32(ehci, addr);\r\n}\r\nstream->ps.udev = dev;\r\nstream->ps.ep = urb->ep;\r\nstream->bEndpointAddress = is_input | epnum;\r\nstream->maxp = maxp;\r\n}\r\nstatic struct ehci_iso_stream *\r\niso_stream_find(struct ehci_hcd *ehci, struct urb *urb)\r\n{\r\nunsigned epnum;\r\nstruct ehci_iso_stream *stream;\r\nstruct usb_host_endpoint *ep;\r\nunsigned long flags;\r\nepnum = usb_pipeendpoint (urb->pipe);\r\nif (usb_pipein(urb->pipe))\r\nep = urb->dev->ep_in[epnum];\r\nelse\r\nep = urb->dev->ep_out[epnum];\r\nspin_lock_irqsave(&ehci->lock, flags);\r\nstream = ep->hcpriv;\r\nif (unlikely(stream == NULL)) {\r\nstream = iso_stream_alloc(GFP_ATOMIC);\r\nif (likely(stream != NULL)) {\r\nep->hcpriv = stream;\r\niso_stream_init(ehci, stream, urb);\r\n}\r\n} else if (unlikely(stream->hw != NULL)) {\r\nehci_dbg(ehci, "dev %s ep%d%s, not iso??\n",\r\nurb->dev->devpath, epnum,\r\nusb_pipein(urb->pipe) ? "in" : "out");\r\nstream = NULL;\r\n}\r\nspin_unlock_irqrestore(&ehci->lock, flags);\r\nreturn stream;\r\n}\r\nstatic struct ehci_iso_sched *\r\niso_sched_alloc(unsigned packets, gfp_t mem_flags)\r\n{\r\nstruct ehci_iso_sched *iso_sched;\r\nint size = sizeof(*iso_sched);\r\nsize += packets * sizeof(struct ehci_iso_packet);\r\niso_sched = kzalloc(size, mem_flags);\r\nif (likely(iso_sched != NULL))\r\nINIT_LIST_HEAD(&iso_sched->td_list);\r\nreturn iso_sched;\r\n}\r\nstatic inline void\r\nitd_sched_init(\r\nstruct ehci_hcd *ehci,\r\nstruct ehci_iso_sched *iso_sched,\r\nstruct ehci_iso_stream *stream,\r\nstruct urb *urb\r\n)\r\n{\r\nunsigned i;\r\ndma_addr_t dma = urb->transfer_dma;\r\niso_sched->span = urb->number_of_packets * stream->uperiod;\r\nfor (i = 0; i < urb->number_of_packets; i++) {\r\nstruct ehci_iso_packet *uframe = &iso_sched->packet[i];\r\nunsigned length;\r\ndma_addr_t buf;\r\nu32 trans;\r\nlength = urb->iso_frame_desc[i].length;\r\nbuf = dma + urb->iso_frame_desc[i].offset;\r\ntrans = EHCI_ISOC_ACTIVE;\r\ntrans |= buf & 0x0fff;\r\nif (unlikely(((i + 1) == urb->number_of_packets))\r\n&& !(urb->transfer_flags & URB_NO_INTERRUPT))\r\ntrans |= EHCI_ITD_IOC;\r\ntrans |= length << 16;\r\nuframe->transaction = cpu_to_hc32(ehci, trans);\r\nuframe->bufp = (buf & ~(u64)0x0fff);\r\nbuf += length;\r\nif (unlikely((uframe->bufp != (buf & ~(u64)0x0fff))))\r\nuframe->cross = 1;\r\n}\r\n}\r\nstatic void\r\niso_sched_free(\r\nstruct ehci_iso_stream *stream,\r\nstruct ehci_iso_sched *iso_sched\r\n)\r\n{\r\nif (!iso_sched)\r\nreturn;\r\nlist_splice(&iso_sched->td_list, &stream->free_list);\r\nkfree(iso_sched);\r\n}\r\nstatic int\r\nitd_urb_transaction(\r\nstruct ehci_iso_stream *stream,\r\nstruct ehci_hcd *ehci,\r\nstruct urb *urb,\r\ngfp_t mem_flags\r\n)\r\n{\r\nstruct ehci_itd *itd;\r\ndma_addr_t itd_dma;\r\nint i;\r\nunsigned num_itds;\r\nstruct ehci_iso_sched *sched;\r\nunsigned long flags;\r\nsched = iso_sched_alloc(urb->number_of_packets, mem_flags);\r\nif (unlikely(sched == NULL))\r\nreturn -ENOMEM;\r\nitd_sched_init(ehci, sched, stream, urb);\r\nif (urb->interval < 8)\r\nnum_itds = 1 + (sched->span + 7) / 8;\r\nelse\r\nnum_itds = urb->number_of_packets;\r\nspin_lock_irqsave(&ehci->lock, flags);\r\nfor (i = 0; i < num_itds; i++) {\r\nif (likely(!list_empty(&stream->free_list))) {\r\nitd = list_first_entry(&stream->free_list,\r\nstruct ehci_itd, itd_list);\r\nif (itd->frame == ehci->now_frame)\r\ngoto alloc_itd;\r\nlist_del(&itd->itd_list);\r\nitd_dma = itd->itd_dma;\r\n} else {\r\nalloc_itd:\r\nspin_unlock_irqrestore(&ehci->lock, flags);\r\nitd = dma_pool_alloc(ehci->itd_pool, mem_flags,\r\n&itd_dma);\r\nspin_lock_irqsave(&ehci->lock, flags);\r\nif (!itd) {\r\niso_sched_free(stream, sched);\r\nspin_unlock_irqrestore(&ehci->lock, flags);\r\nreturn -ENOMEM;\r\n}\r\n}\r\nmemset(itd, 0, sizeof(*itd));\r\nitd->itd_dma = itd_dma;\r\nitd->frame = NO_FRAME;\r\nlist_add(&itd->itd_list, &sched->td_list);\r\n}\r\nspin_unlock_irqrestore(&ehci->lock, flags);\r\nurb->hcpriv = sched;\r\nurb->error_count = 0;\r\nreturn 0;\r\n}\r\nstatic void reserve_release_iso_bandwidth(struct ehci_hcd *ehci,\r\nstruct ehci_iso_stream *stream, int sign)\r\n{\r\nunsigned uframe;\r\nunsigned i, j;\r\nunsigned s_mask, c_mask, m;\r\nint usecs = stream->ps.usecs;\r\nint c_usecs = stream->ps.c_usecs;\r\nint tt_usecs = stream->ps.tt_usecs;\r\nstruct ehci_tt *tt;\r\nif (stream->ps.phase == NO_FRAME)\r\nreturn;\r\nuframe = stream->ps.bw_phase << 3;\r\nbandwidth_dbg(ehci, sign, "iso", &stream->ps);\r\nif (sign < 0) {\r\nusecs = -usecs;\r\nc_usecs = -c_usecs;\r\ntt_usecs = -tt_usecs;\r\n}\r\nif (!stream->splits) {\r\nfor (i = uframe + stream->ps.phase_uf; i < EHCI_BANDWIDTH_SIZE;\r\ni += stream->ps.bw_uperiod)\r\nehci->bandwidth[i] += usecs;\r\n} else {\r\ns_mask = stream->ps.cs_mask;\r\nc_mask = s_mask >> 8;\r\nfor (i = uframe; i < EHCI_BANDWIDTH_SIZE;\r\ni += stream->ps.bw_uperiod) {\r\nfor ((j = stream->ps.phase_uf, m = 1 << j); j < 8;\r\n(++j, m <<= 1)) {\r\nif (s_mask & m)\r\nehci->bandwidth[i+j] += usecs;\r\nelse if (c_mask & m)\r\nehci->bandwidth[i+j] += c_usecs;\r\n}\r\n}\r\ntt = find_tt(stream->ps.udev);\r\nif (sign > 0)\r\nlist_add_tail(&stream->ps.ps_list, &tt->ps_list);\r\nelse\r\nlist_del(&stream->ps.ps_list);\r\nfor (i = uframe >> 3; i < EHCI_BANDWIDTH_FRAMES;\r\ni += stream->ps.bw_period)\r\ntt->bandwidth[i] += tt_usecs;\r\n}\r\n}\r\nstatic inline int\r\nitd_slot_ok(\r\nstruct ehci_hcd *ehci,\r\nstruct ehci_iso_stream *stream,\r\nunsigned uframe\r\n)\r\n{\r\nunsigned usecs;\r\nusecs = ehci->uframe_periodic_max - stream->ps.usecs;\r\nfor (uframe &= stream->ps.bw_uperiod - 1; uframe < EHCI_BANDWIDTH_SIZE;\r\nuframe += stream->ps.bw_uperiod) {\r\nif (ehci->bandwidth[uframe] > usecs)\r\nreturn 0;\r\n}\r\nreturn 1;\r\n}\r\nstatic inline int\r\nsitd_slot_ok(\r\nstruct ehci_hcd *ehci,\r\nstruct ehci_iso_stream *stream,\r\nunsigned uframe,\r\nstruct ehci_iso_sched *sched,\r\nstruct ehci_tt *tt\r\n)\r\n{\r\nunsigned mask, tmp;\r\nunsigned frame, uf;\r\nmask = stream->ps.cs_mask << (uframe & 7);\r\nif (((stream->ps.cs_mask & 0xff) << (uframe & 7)) >= (1 << 7))\r\nreturn 0;\r\nif (mask & ~0xffff)\r\nreturn 0;\r\nuframe &= stream->ps.bw_uperiod - 1;\r\nframe = uframe >> 3;\r\n#ifdef CONFIG_USB_EHCI_TT_NEWSCHED\r\nuf = uframe & 7;\r\nif (!tt_available(ehci, &stream->ps, tt, frame, uf))\r\nreturn 0;\r\n#else\r\nif (!tt_no_collision(ehci, stream->ps.bw_period,\r\nstream->ps.udev, frame, mask))\r\nreturn 0;\r\n#endif\r\ndo {\r\nunsigned max_used;\r\nunsigned i;\r\nuf = uframe;\r\nmax_used = ehci->uframe_periodic_max - stream->ps.usecs;\r\nfor (tmp = stream->ps.cs_mask & 0xff; tmp; tmp >>= 1, uf++) {\r\nif (ehci->bandwidth[uf] > max_used)\r\nreturn 0;\r\n}\r\nif (stream->ps.c_usecs) {\r\nmax_used = ehci->uframe_periodic_max -\r\nstream->ps.c_usecs;\r\nuf = uframe & ~7;\r\ntmp = 1 << (2+8);\r\nfor (i = (uframe & 7) + 2; i < 8; (++i, tmp <<= 1)) {\r\nif ((stream->ps.cs_mask & tmp) == 0)\r\ncontinue;\r\nif (ehci->bandwidth[uf+i] > max_used)\r\nreturn 0;\r\n}\r\n}\r\nuframe += stream->ps.bw_uperiod;\r\n} while (uframe < EHCI_BANDWIDTH_SIZE);\r\nstream->ps.cs_mask <<= uframe & 7;\r\nstream->splits = cpu_to_hc32(ehci, stream->ps.cs_mask);\r\nreturn 1;\r\n}\r\nstatic int\r\niso_stream_schedule(\r\nstruct ehci_hcd *ehci,\r\nstruct urb *urb,\r\nstruct ehci_iso_stream *stream\r\n)\r\n{\r\nu32 now, base, next, start, period, span, now2;\r\nu32 wrap = 0, skip = 0;\r\nint status = 0;\r\nunsigned mod = ehci->periodic_size << 3;\r\nstruct ehci_iso_sched *sched = urb->hcpriv;\r\nbool empty = list_empty(&stream->td_list);\r\nbool new_stream = false;\r\nperiod = stream->uperiod;\r\nspan = sched->span;\r\nif (!stream->highspeed)\r\nspan <<= 3;\r\nif (unlikely(empty && !hcd_periodic_completion_in_progress(\r\nehci_to_hcd(ehci), urb->ep))) {\r\nif (stream->ps.phase == NO_FRAME) {\r\nint done = 0;\r\nstruct ehci_tt *tt = find_tt(stream->ps.udev);\r\nif (IS_ERR(tt)) {\r\nstatus = PTR_ERR(tt);\r\ngoto fail;\r\n}\r\ncompute_tt_budget(ehci->tt_budget, tt);\r\nstart = ((-(++ehci->random_frame)) << 3) & (period - 1);\r\nnext = start;\r\nstart += period;\r\ndo {\r\nstart--;\r\nif (stream->highspeed) {\r\nif (itd_slot_ok(ehci, stream, start))\r\ndone = 1;\r\n} else {\r\nif ((start % 8) >= 6)\r\ncontinue;\r\nif (sitd_slot_ok(ehci, stream, start,\r\nsched, tt))\r\ndone = 1;\r\n}\r\n} while (start > next && !done);\r\nif (!done) {\r\nehci_dbg(ehci, "iso sched full %p", urb);\r\nstatus = -ENOSPC;\r\ngoto fail;\r\n}\r\nstream->ps.phase = (start >> 3) &\r\n(stream->ps.period - 1);\r\nstream->ps.bw_phase = stream->ps.phase &\r\n(stream->ps.bw_period - 1);\r\nstream->ps.phase_uf = start & 7;\r\nreserve_release_iso_bandwidth(ehci, stream, 1);\r\n}\r\nelse {\r\nstart = (stream->ps.phase << 3) + stream->ps.phase_uf;\r\n}\r\nstream->next_uframe = start;\r\nnew_stream = true;\r\n}\r\nnow = ehci_read_frame_index(ehci) & (mod - 1);\r\nif (ehci->i_thresh)\r\nnext = now + ehci->i_thresh;\r\nelse\r\nnext = (now + 2 + 7) & ~0x07;\r\nif (ehci->isoc_count == 0)\r\nehci->last_iso_frame = now >> 3;\r\nbase = ehci->last_iso_frame << 3;\r\nnext = (next - base) & (mod - 1);\r\nstart = (stream->next_uframe - base) & (mod - 1);\r\nif (unlikely(new_stream))\r\ngoto do_ASAP;\r\nnow2 = (now - base) & (mod - 1);\r\nif (unlikely(!empty && start < period)) {\r\nehci_dbg(ehci, "request %p would overflow (%u-%u < %u mod %u)\n",\r\nurb, stream->next_uframe, base, period, mod);\r\nstatus = -EFBIG;\r\ngoto fail;\r\n}\r\nif (likely(!empty || start <= now2 + period)) {\r\nif (unlikely(start < next &&\r\n(urb->transfer_flags & URB_ISO_ASAP)))\r\ngoto do_ASAP;\r\nif (likely(start >= now2))\r\ngoto use_start;\r\n} else {\r\nif (urb->transfer_flags & URB_ISO_ASAP)\r\ngoto do_ASAP;\r\nwrap = mod;\r\nnow2 += mod;\r\n}\r\nskip = (now2 - start + period - 1) & -period;\r\nif (skip >= span) {\r\nehci_dbg(ehci, "iso underrun %p (%u+%u < %u) [%u]\n",\r\nurb, start + base, span - period, now2 + base,\r\nbase);\r\nskip = span - period;\r\nif (empty) {\r\nskip = span;\r\nstatus = 1;\r\niso_sched_free(stream, sched);\r\nsched = NULL;\r\n}\r\n}\r\nurb->error_count = skip / period;\r\nif (sched)\r\nsched->first_packet = urb->error_count;\r\ngoto use_start;\r\ndo_ASAP:\r\nstart = next + ((start - next) & (period - 1));\r\nuse_start:\r\nif (unlikely(start + span - period >= mod + wrap)) {\r\nehci_dbg(ehci, "request %p would overflow (%u+%u >= %u)\n",\r\nurb, start, span - period, mod + wrap);\r\nstatus = -EFBIG;\r\ngoto fail;\r\n}\r\nstart += base;\r\nstream->next_uframe = (start + skip) & (mod - 1);\r\nurb->start_frame = start & (mod - 1);\r\nif (!stream->highspeed)\r\nurb->start_frame >>= 3;\r\nreturn status;\r\nfail:\r\niso_sched_free(stream, sched);\r\nurb->hcpriv = NULL;\r\nreturn status;\r\n}\r\nstatic inline void\r\nitd_init(struct ehci_hcd *ehci, struct ehci_iso_stream *stream,\r\nstruct ehci_itd *itd)\r\n{\r\nint i;\r\nitd->hw_next = EHCI_LIST_END(ehci);\r\nitd->hw_bufp[0] = stream->buf0;\r\nitd->hw_bufp[1] = stream->buf1;\r\nitd->hw_bufp[2] = stream->buf2;\r\nfor (i = 0; i < 8; i++)\r\nitd->index[i] = -1;\r\n}\r\nstatic inline void\r\nitd_patch(\r\nstruct ehci_hcd *ehci,\r\nstruct ehci_itd *itd,\r\nstruct ehci_iso_sched *iso_sched,\r\nunsigned index,\r\nu16 uframe\r\n)\r\n{\r\nstruct ehci_iso_packet *uf = &iso_sched->packet[index];\r\nunsigned pg = itd->pg;\r\nuframe &= 0x07;\r\nitd->index[uframe] = index;\r\nitd->hw_transaction[uframe] = uf->transaction;\r\nitd->hw_transaction[uframe] |= cpu_to_hc32(ehci, pg << 12);\r\nitd->hw_bufp[pg] |= cpu_to_hc32(ehci, uf->bufp & ~(u32)0);\r\nitd->hw_bufp_hi[pg] |= cpu_to_hc32(ehci, (u32)(uf->bufp >> 32));\r\nif (unlikely(uf->cross)) {\r\nu64 bufp = uf->bufp + 4096;\r\nitd->pg = ++pg;\r\nitd->hw_bufp[pg] |= cpu_to_hc32(ehci, bufp & ~(u32)0);\r\nitd->hw_bufp_hi[pg] |= cpu_to_hc32(ehci, (u32)(bufp >> 32));\r\n}\r\n}\r\nstatic inline void\r\nitd_link(struct ehci_hcd *ehci, unsigned frame, struct ehci_itd *itd)\r\n{\r\nunion ehci_shadow *prev = &ehci->pshadow[frame];\r\n__hc32 *hw_p = &ehci->periodic[frame];\r\nunion ehci_shadow here = *prev;\r\n__hc32 type = 0;\r\nwhile (here.ptr) {\r\ntype = Q_NEXT_TYPE(ehci, *hw_p);\r\nif (type == cpu_to_hc32(ehci, Q_TYPE_QH))\r\nbreak;\r\nprev = periodic_next_shadow(ehci, prev, type);\r\nhw_p = shadow_next_periodic(ehci, &here, type);\r\nhere = *prev;\r\n}\r\nitd->itd_next = here;\r\nitd->hw_next = *hw_p;\r\nprev->itd = itd;\r\nitd->frame = frame;\r\nwmb();\r\n*hw_p = cpu_to_hc32(ehci, itd->itd_dma | Q_TYPE_ITD);\r\n}\r\nstatic void itd_link_urb(\r\nstruct ehci_hcd *ehci,\r\nstruct urb *urb,\r\nunsigned mod,\r\nstruct ehci_iso_stream *stream\r\n)\r\n{\r\nint packet;\r\nunsigned next_uframe, uframe, frame;\r\nstruct ehci_iso_sched *iso_sched = urb->hcpriv;\r\nstruct ehci_itd *itd;\r\nnext_uframe = stream->next_uframe & (mod - 1);\r\nif (unlikely(list_empty(&stream->td_list)))\r\nehci_to_hcd(ehci)->self.bandwidth_allocated\r\n+= stream->bandwidth;\r\nif (ehci_to_hcd(ehci)->self.bandwidth_isoc_reqs == 0) {\r\nif (ehci->amd_pll_fix == 1)\r\nusb_amd_quirk_pll_disable();\r\n}\r\nehci_to_hcd(ehci)->self.bandwidth_isoc_reqs++;\r\nfor (packet = iso_sched->first_packet, itd = NULL;\r\npacket < urb->number_of_packets;) {\r\nif (itd == NULL) {\r\nitd = list_entry(iso_sched->td_list.next,\r\nstruct ehci_itd, itd_list);\r\nlist_move_tail(&itd->itd_list, &stream->td_list);\r\nitd->stream = stream;\r\nitd->urb = urb;\r\nitd_init(ehci, stream, itd);\r\n}\r\nuframe = next_uframe & 0x07;\r\nframe = next_uframe >> 3;\r\nitd_patch(ehci, itd, iso_sched, packet, uframe);\r\nnext_uframe += stream->uperiod;\r\nnext_uframe &= mod - 1;\r\npacket++;\r\nif (((next_uframe >> 3) != frame)\r\n|| packet == urb->number_of_packets) {\r\nitd_link(ehci, frame & (ehci->periodic_size - 1), itd);\r\nitd = NULL;\r\n}\r\n}\r\nstream->next_uframe = next_uframe;\r\niso_sched_free(stream, iso_sched);\r\nurb->hcpriv = stream;\r\n++ehci->isoc_count;\r\nenable_periodic(ehci);\r\n}\r\nstatic bool itd_complete(struct ehci_hcd *ehci, struct ehci_itd *itd)\r\n{\r\nstruct urb *urb = itd->urb;\r\nstruct usb_iso_packet_descriptor *desc;\r\nu32 t;\r\nunsigned uframe;\r\nint urb_index = -1;\r\nstruct ehci_iso_stream *stream = itd->stream;\r\nstruct usb_device *dev;\r\nbool retval = false;\r\nfor (uframe = 0; uframe < 8; uframe++) {\r\nif (likely(itd->index[uframe] == -1))\r\ncontinue;\r\nurb_index = itd->index[uframe];\r\ndesc = &urb->iso_frame_desc[urb_index];\r\nt = hc32_to_cpup(ehci, &itd->hw_transaction[uframe]);\r\nitd->hw_transaction[uframe] = 0;\r\nif (unlikely(t & ISO_ERRS)) {\r\nurb->error_count++;\r\nif (t & EHCI_ISOC_BUF_ERR)\r\ndesc->status = usb_pipein(urb->pipe)\r\n? -ENOSR\r\n: -ECOMM;\r\nelse if (t & EHCI_ISOC_BABBLE)\r\ndesc->status = -EOVERFLOW;\r\nelse\r\ndesc->status = -EPROTO;\r\nif (!(t & EHCI_ISOC_BABBLE)) {\r\ndesc->actual_length = EHCI_ITD_LENGTH(t);\r\nurb->actual_length += desc->actual_length;\r\n}\r\n} else if (likely((t & EHCI_ISOC_ACTIVE) == 0)) {\r\ndesc->status = 0;\r\ndesc->actual_length = EHCI_ITD_LENGTH(t);\r\nurb->actual_length += desc->actual_length;\r\n} else {\r\nurb->error_count++;\r\n}\r\n}\r\nif (likely((urb_index + 1) != urb->number_of_packets))\r\ngoto done;\r\ndev = urb->dev;\r\nehci_urb_done(ehci, urb, 0);\r\nretval = true;\r\nurb = NULL;\r\n--ehci->isoc_count;\r\ndisable_periodic(ehci);\r\nehci_to_hcd(ehci)->self.bandwidth_isoc_reqs--;\r\nif (ehci_to_hcd(ehci)->self.bandwidth_isoc_reqs == 0) {\r\nif (ehci->amd_pll_fix == 1)\r\nusb_amd_quirk_pll_enable();\r\n}\r\nif (unlikely(list_is_singular(&stream->td_list)))\r\nehci_to_hcd(ehci)->self.bandwidth_allocated\r\n-= stream->bandwidth;\r\ndone:\r\nitd->urb = NULL;\r\nlist_move_tail(&itd->itd_list, &stream->free_list);\r\nif (list_empty(&stream->td_list)) {\r\nlist_splice_tail_init(&stream->free_list,\r\n&ehci->cached_itd_list);\r\nstart_free_itds(ehci);\r\n}\r\nreturn retval;\r\n}\r\nstatic int itd_submit(struct ehci_hcd *ehci, struct urb *urb,\r\ngfp_t mem_flags)\r\n{\r\nint status = -EINVAL;\r\nunsigned long flags;\r\nstruct ehci_iso_stream *stream;\r\nstream = iso_stream_find(ehci, urb);\r\nif (unlikely(stream == NULL)) {\r\nehci_dbg(ehci, "can't get iso stream\n");\r\nreturn -ENOMEM;\r\n}\r\nif (unlikely(urb->interval != stream->uperiod)) {\r\nehci_dbg(ehci, "can't change iso interval %d --> %d\n",\r\nstream->uperiod, urb->interval);\r\ngoto done;\r\n}\r\n#ifdef EHCI_URB_TRACE\r\nehci_dbg(ehci,\r\n"%s %s urb %p ep%d%s len %d, %d pkts %d uframes [%p]\n",\r\n__func__, urb->dev->devpath, urb,\r\nusb_pipeendpoint(urb->pipe),\r\nusb_pipein(urb->pipe) ? "in" : "out",\r\nurb->transfer_buffer_length,\r\nurb->number_of_packets, urb->interval,\r\nstream);\r\n#endif\r\nstatus = itd_urb_transaction(stream, ehci, urb, mem_flags);\r\nif (unlikely(status < 0)) {\r\nehci_dbg(ehci, "can't init itds\n");\r\ngoto done;\r\n}\r\nspin_lock_irqsave(&ehci->lock, flags);\r\nif (unlikely(!HCD_HW_ACCESSIBLE(ehci_to_hcd(ehci)))) {\r\nstatus = -ESHUTDOWN;\r\ngoto done_not_linked;\r\n}\r\nstatus = usb_hcd_link_urb_to_ep(ehci_to_hcd(ehci), urb);\r\nif (unlikely(status))\r\ngoto done_not_linked;\r\nstatus = iso_stream_schedule(ehci, urb, stream);\r\nif (likely(status == 0)) {\r\nitd_link_urb(ehci, urb, ehci->periodic_size << 3, stream);\r\n} else if (status > 0) {\r\nstatus = 0;\r\nehci_urb_done(ehci, urb, 0);\r\n} else {\r\nusb_hcd_unlink_urb_from_ep(ehci_to_hcd(ehci), urb);\r\n}\r\ndone_not_linked:\r\nspin_unlock_irqrestore(&ehci->lock, flags);\r\ndone:\r\nreturn status;\r\n}\r\nstatic inline void\r\nsitd_sched_init(\r\nstruct ehci_hcd *ehci,\r\nstruct ehci_iso_sched *iso_sched,\r\nstruct ehci_iso_stream *stream,\r\nstruct urb *urb\r\n)\r\n{\r\nunsigned i;\r\ndma_addr_t dma = urb->transfer_dma;\r\niso_sched->span = urb->number_of_packets * stream->ps.period;\r\nfor (i = 0; i < urb->number_of_packets; i++) {\r\nstruct ehci_iso_packet *packet = &iso_sched->packet[i];\r\nunsigned length;\r\ndma_addr_t buf;\r\nu32 trans;\r\nlength = urb->iso_frame_desc[i].length & 0x03ff;\r\nbuf = dma + urb->iso_frame_desc[i].offset;\r\ntrans = SITD_STS_ACTIVE;\r\nif (((i + 1) == urb->number_of_packets)\r\n&& !(urb->transfer_flags & URB_NO_INTERRUPT))\r\ntrans |= SITD_IOC;\r\ntrans |= length << 16;\r\npacket->transaction = cpu_to_hc32(ehci, trans);\r\npacket->bufp = buf;\r\npacket->buf1 = (buf + length) & ~0x0fff;\r\nif (packet->buf1 != (buf & ~(u64)0x0fff))\r\npacket->cross = 1;\r\nif (stream->bEndpointAddress & USB_DIR_IN)\r\ncontinue;\r\nlength = (length + 187) / 188;\r\nif (length > 1)\r\nlength |= 1 << 3;\r\npacket->buf1 |= length;\r\n}\r\n}\r\nstatic int\r\nsitd_urb_transaction(\r\nstruct ehci_iso_stream *stream,\r\nstruct ehci_hcd *ehci,\r\nstruct urb *urb,\r\ngfp_t mem_flags\r\n)\r\n{\r\nstruct ehci_sitd *sitd;\r\ndma_addr_t sitd_dma;\r\nint i;\r\nstruct ehci_iso_sched *iso_sched;\r\nunsigned long flags;\r\niso_sched = iso_sched_alloc(urb->number_of_packets, mem_flags);\r\nif (iso_sched == NULL)\r\nreturn -ENOMEM;\r\nsitd_sched_init(ehci, iso_sched, stream, urb);\r\nspin_lock_irqsave(&ehci->lock, flags);\r\nfor (i = 0; i < urb->number_of_packets; i++) {\r\nif (likely(!list_empty(&stream->free_list))) {\r\nsitd = list_first_entry(&stream->free_list,\r\nstruct ehci_sitd, sitd_list);\r\nif (sitd->frame == ehci->now_frame)\r\ngoto alloc_sitd;\r\nlist_del(&sitd->sitd_list);\r\nsitd_dma = sitd->sitd_dma;\r\n} else {\r\nalloc_sitd:\r\nspin_unlock_irqrestore(&ehci->lock, flags);\r\nsitd = dma_pool_alloc(ehci->sitd_pool, mem_flags,\r\n&sitd_dma);\r\nspin_lock_irqsave(&ehci->lock, flags);\r\nif (!sitd) {\r\niso_sched_free(stream, iso_sched);\r\nspin_unlock_irqrestore(&ehci->lock, flags);\r\nreturn -ENOMEM;\r\n}\r\n}\r\nmemset(sitd, 0, sizeof(*sitd));\r\nsitd->sitd_dma = sitd_dma;\r\nsitd->frame = NO_FRAME;\r\nlist_add(&sitd->sitd_list, &iso_sched->td_list);\r\n}\r\nurb->hcpriv = iso_sched;\r\nurb->error_count = 0;\r\nspin_unlock_irqrestore(&ehci->lock, flags);\r\nreturn 0;\r\n}\r\nstatic inline void\r\nsitd_patch(\r\nstruct ehci_hcd *ehci,\r\nstruct ehci_iso_stream *stream,\r\nstruct ehci_sitd *sitd,\r\nstruct ehci_iso_sched *iso_sched,\r\nunsigned index\r\n)\r\n{\r\nstruct ehci_iso_packet *uf = &iso_sched->packet[index];\r\nu64 bufp;\r\nsitd->hw_next = EHCI_LIST_END(ehci);\r\nsitd->hw_fullspeed_ep = stream->address;\r\nsitd->hw_uframe = stream->splits;\r\nsitd->hw_results = uf->transaction;\r\nsitd->hw_backpointer = EHCI_LIST_END(ehci);\r\nbufp = uf->bufp;\r\nsitd->hw_buf[0] = cpu_to_hc32(ehci, bufp);\r\nsitd->hw_buf_hi[0] = cpu_to_hc32(ehci, bufp >> 32);\r\nsitd->hw_buf[1] = cpu_to_hc32(ehci, uf->buf1);\r\nif (uf->cross)\r\nbufp += 4096;\r\nsitd->hw_buf_hi[1] = cpu_to_hc32(ehci, bufp >> 32);\r\nsitd->index = index;\r\n}\r\nstatic inline void\r\nsitd_link(struct ehci_hcd *ehci, unsigned frame, struct ehci_sitd *sitd)\r\n{\r\nsitd->sitd_next = ehci->pshadow[frame];\r\nsitd->hw_next = ehci->periodic[frame];\r\nehci->pshadow[frame].sitd = sitd;\r\nsitd->frame = frame;\r\nwmb();\r\nehci->periodic[frame] = cpu_to_hc32(ehci, sitd->sitd_dma | Q_TYPE_SITD);\r\n}\r\nstatic void sitd_link_urb(\r\nstruct ehci_hcd *ehci,\r\nstruct urb *urb,\r\nunsigned mod,\r\nstruct ehci_iso_stream *stream\r\n)\r\n{\r\nint packet;\r\nunsigned next_uframe;\r\nstruct ehci_iso_sched *sched = urb->hcpriv;\r\nstruct ehci_sitd *sitd;\r\nnext_uframe = stream->next_uframe;\r\nif (list_empty(&stream->td_list))\r\nehci_to_hcd(ehci)->self.bandwidth_allocated\r\n+= stream->bandwidth;\r\nif (ehci_to_hcd(ehci)->self.bandwidth_isoc_reqs == 0) {\r\nif (ehci->amd_pll_fix == 1)\r\nusb_amd_quirk_pll_disable();\r\n}\r\nehci_to_hcd(ehci)->self.bandwidth_isoc_reqs++;\r\nfor (packet = sched->first_packet, sitd = NULL;\r\npacket < urb->number_of_packets;\r\npacket++) {\r\nBUG_ON(list_empty(&sched->td_list));\r\nsitd = list_entry(sched->td_list.next,\r\nstruct ehci_sitd, sitd_list);\r\nlist_move_tail(&sitd->sitd_list, &stream->td_list);\r\nsitd->stream = stream;\r\nsitd->urb = urb;\r\nsitd_patch(ehci, stream, sitd, sched, packet);\r\nsitd_link(ehci, (next_uframe >> 3) & (ehci->periodic_size - 1),\r\nsitd);\r\nnext_uframe += stream->uperiod;\r\n}\r\nstream->next_uframe = next_uframe & (mod - 1);\r\niso_sched_free(stream, sched);\r\nurb->hcpriv = stream;\r\n++ehci->isoc_count;\r\nenable_periodic(ehci);\r\n}\r\nstatic bool sitd_complete(struct ehci_hcd *ehci, struct ehci_sitd *sitd)\r\n{\r\nstruct urb *urb = sitd->urb;\r\nstruct usb_iso_packet_descriptor *desc;\r\nu32 t;\r\nint urb_index;\r\nstruct ehci_iso_stream *stream = sitd->stream;\r\nstruct usb_device *dev;\r\nbool retval = false;\r\nurb_index = sitd->index;\r\ndesc = &urb->iso_frame_desc[urb_index];\r\nt = hc32_to_cpup(ehci, &sitd->hw_results);\r\nif (unlikely(t & SITD_ERRS)) {\r\nurb->error_count++;\r\nif (t & SITD_STS_DBE)\r\ndesc->status = usb_pipein(urb->pipe)\r\n? -ENOSR\r\n: -ECOMM;\r\nelse if (t & SITD_STS_BABBLE)\r\ndesc->status = -EOVERFLOW;\r\nelse\r\ndesc->status = -EPROTO;\r\n} else if (unlikely(t & SITD_STS_ACTIVE)) {\r\nurb->error_count++;\r\n} else {\r\ndesc->status = 0;\r\ndesc->actual_length = desc->length - SITD_LENGTH(t);\r\nurb->actual_length += desc->actual_length;\r\n}\r\nif ((urb_index + 1) != urb->number_of_packets)\r\ngoto done;\r\ndev = urb->dev;\r\nehci_urb_done(ehci, urb, 0);\r\nretval = true;\r\nurb = NULL;\r\n--ehci->isoc_count;\r\ndisable_periodic(ehci);\r\nehci_to_hcd(ehci)->self.bandwidth_isoc_reqs--;\r\nif (ehci_to_hcd(ehci)->self.bandwidth_isoc_reqs == 0) {\r\nif (ehci->amd_pll_fix == 1)\r\nusb_amd_quirk_pll_enable();\r\n}\r\nif (list_is_singular(&stream->td_list))\r\nehci_to_hcd(ehci)->self.bandwidth_allocated\r\n-= stream->bandwidth;\r\ndone:\r\nsitd->urb = NULL;\r\nlist_move_tail(&sitd->sitd_list, &stream->free_list);\r\nif (list_empty(&stream->td_list)) {\r\nlist_splice_tail_init(&stream->free_list,\r\n&ehci->cached_sitd_list);\r\nstart_free_itds(ehci);\r\n}\r\nreturn retval;\r\n}\r\nstatic int sitd_submit(struct ehci_hcd *ehci, struct urb *urb,\r\ngfp_t mem_flags)\r\n{\r\nint status = -EINVAL;\r\nunsigned long flags;\r\nstruct ehci_iso_stream *stream;\r\nstream = iso_stream_find(ehci, urb);\r\nif (stream == NULL) {\r\nehci_dbg(ehci, "can't get iso stream\n");\r\nreturn -ENOMEM;\r\n}\r\nif (urb->interval != stream->ps.period) {\r\nehci_dbg(ehci, "can't change iso interval %d --> %d\n",\r\nstream->ps.period, urb->interval);\r\ngoto done;\r\n}\r\n#ifdef EHCI_URB_TRACE\r\nehci_dbg(ehci,\r\n"submit %p dev%s ep%d%s-iso len %d\n",\r\nurb, urb->dev->devpath,\r\nusb_pipeendpoint(urb->pipe),\r\nusb_pipein(urb->pipe) ? "in" : "out",\r\nurb->transfer_buffer_length);\r\n#endif\r\nstatus = sitd_urb_transaction(stream, ehci, urb, mem_flags);\r\nif (status < 0) {\r\nehci_dbg(ehci, "can't init sitds\n");\r\ngoto done;\r\n}\r\nspin_lock_irqsave(&ehci->lock, flags);\r\nif (unlikely(!HCD_HW_ACCESSIBLE(ehci_to_hcd(ehci)))) {\r\nstatus = -ESHUTDOWN;\r\ngoto done_not_linked;\r\n}\r\nstatus = usb_hcd_link_urb_to_ep(ehci_to_hcd(ehci), urb);\r\nif (unlikely(status))\r\ngoto done_not_linked;\r\nstatus = iso_stream_schedule(ehci, urb, stream);\r\nif (likely(status == 0)) {\r\nsitd_link_urb(ehci, urb, ehci->periodic_size << 3, stream);\r\n} else if (status > 0) {\r\nstatus = 0;\r\nehci_urb_done(ehci, urb, 0);\r\n} else {\r\nusb_hcd_unlink_urb_from_ep(ehci_to_hcd(ehci), urb);\r\n}\r\ndone_not_linked:\r\nspin_unlock_irqrestore(&ehci->lock, flags);\r\ndone:\r\nreturn status;\r\n}\r\nstatic void scan_isoc(struct ehci_hcd *ehci)\r\n{\r\nunsigned uf, now_frame, frame;\r\nunsigned fmask = ehci->periodic_size - 1;\r\nbool modified, live;\r\nunion ehci_shadow q, *q_p;\r\n__hc32 type, *hw_p;\r\nif (ehci->rh_state >= EHCI_RH_RUNNING) {\r\nuf = ehci_read_frame_index(ehci);\r\nnow_frame = (uf >> 3) & fmask;\r\nlive = true;\r\n} else {\r\nnow_frame = (ehci->last_iso_frame - 1) & fmask;\r\nlive = false;\r\n}\r\nehci->now_frame = now_frame;\r\nframe = ehci->last_iso_frame;\r\nrestart:\r\nq_p = &ehci->pshadow[frame];\r\nhw_p = &ehci->periodic[frame];\r\nq.ptr = q_p->ptr;\r\ntype = Q_NEXT_TYPE(ehci, *hw_p);\r\nmodified = false;\r\nwhile (q.ptr != NULL) {\r\nswitch (hc32_to_cpu(ehci, type)) {\r\ncase Q_TYPE_ITD:\r\nif (frame == now_frame && live) {\r\nrmb();\r\nfor (uf = 0; uf < 8; uf++) {\r\nif (q.itd->hw_transaction[uf] &\r\nITD_ACTIVE(ehci))\r\nbreak;\r\n}\r\nif (uf < 8) {\r\nq_p = &q.itd->itd_next;\r\nhw_p = &q.itd->hw_next;\r\ntype = Q_NEXT_TYPE(ehci,\r\nq.itd->hw_next);\r\nq = *q_p;\r\nbreak;\r\n}\r\n}\r\n*q_p = q.itd->itd_next;\r\nif (!ehci->use_dummy_qh ||\r\nq.itd->hw_next != EHCI_LIST_END(ehci))\r\n*hw_p = q.itd->hw_next;\r\nelse\r\n*hw_p = cpu_to_hc32(ehci, ehci->dummy->qh_dma);\r\ntype = Q_NEXT_TYPE(ehci, q.itd->hw_next);\r\nwmb();\r\nmodified = itd_complete(ehci, q.itd);\r\nq = *q_p;\r\nbreak;\r\ncase Q_TYPE_SITD:\r\nif (((frame == now_frame) ||\r\n(((frame + 1) & fmask) == now_frame))\r\n&& live\r\n&& (q.sitd->hw_results & SITD_ACTIVE(ehci))) {\r\nq_p = &q.sitd->sitd_next;\r\nhw_p = &q.sitd->hw_next;\r\ntype = Q_NEXT_TYPE(ehci, q.sitd->hw_next);\r\nq = *q_p;\r\nbreak;\r\n}\r\n*q_p = q.sitd->sitd_next;\r\nif (!ehci->use_dummy_qh ||\r\nq.sitd->hw_next != EHCI_LIST_END(ehci))\r\n*hw_p = q.sitd->hw_next;\r\nelse\r\n*hw_p = cpu_to_hc32(ehci, ehci->dummy->qh_dma);\r\ntype = Q_NEXT_TYPE(ehci, q.sitd->hw_next);\r\nwmb();\r\nmodified = sitd_complete(ehci, q.sitd);\r\nq = *q_p;\r\nbreak;\r\ndefault:\r\nehci_dbg(ehci, "corrupt type %d frame %d shadow %p\n",\r\ntype, frame, q.ptr);\r\ncase Q_TYPE_QH:\r\ncase Q_TYPE_FSTN:\r\nq.ptr = NULL;\r\nbreak;\r\n}\r\nif (unlikely(modified && ehci->isoc_count > 0))\r\ngoto restart;\r\n}\r\nif (frame == now_frame)\r\nreturn;\r\nehci->last_iso_frame = frame;\r\nframe = (frame + 1) & fmask;\r\ngoto restart;\r\n}
