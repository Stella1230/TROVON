static unsigned int numachip1_get_apic_id(unsigned long x)\r\n{\r\nunsigned long value;\r\nunsigned int id = (x >> 24) & 0xff;\r\nif (static_cpu_has(X86_FEATURE_NODEID_MSR)) {\r\nrdmsrl(MSR_FAM10H_NODE_ID, value);\r\nid |= (value << 2) & 0xff00;\r\n}\r\nreturn id;\r\n}\r\nstatic unsigned long numachip1_set_apic_id(unsigned int id)\r\n{\r\nunsigned long x;\r\nx = ((id & 0xffU) << 24);\r\nreturn x;\r\n}\r\nstatic unsigned int numachip2_get_apic_id(unsigned long x)\r\n{\r\nu64 mcfg;\r\nrdmsrl(MSR_FAM10H_MMIO_CONF_BASE, mcfg);\r\nreturn ((mcfg >> (28 - 8)) & 0xfff00) | (x >> 24);\r\n}\r\nstatic unsigned long numachip2_set_apic_id(unsigned int id)\r\n{\r\nreturn id << 24;\r\n}\r\nstatic int numachip_apic_id_valid(int apicid)\r\n{\r\nreturn 1;\r\n}\r\nstatic int numachip_apic_id_registered(void)\r\n{\r\nreturn 1;\r\n}\r\nstatic int numachip_phys_pkg_id(int initial_apic_id, int index_msb)\r\n{\r\nreturn initial_apic_id >> index_msb;\r\n}\r\nstatic void numachip1_apic_icr_write(int apicid, unsigned int val)\r\n{\r\nwrite_lcsr(CSR_G3_EXT_IRQ_GEN, (apicid << 16) | val);\r\n}\r\nstatic void numachip2_apic_icr_write(int apicid, unsigned int val)\r\n{\r\nnumachip2_write32_lcsr(NUMACHIP2_APIC_ICR, (apicid << 12) | val);\r\n}\r\nstatic int numachip_wakeup_secondary(int phys_apicid, unsigned long start_rip)\r\n{\r\nnumachip_apic_icr_write(phys_apicid, APIC_DM_INIT);\r\nnumachip_apic_icr_write(phys_apicid, APIC_DM_STARTUP |\r\n(start_rip >> 12));\r\nreturn 0;\r\n}\r\nstatic void numachip_send_IPI_one(int cpu, int vector)\r\n{\r\nint local_apicid, apicid = per_cpu(x86_cpu_to_apicid, cpu);\r\nunsigned int dmode;\r\npreempt_disable();\r\nlocal_apicid = __this_cpu_read(x86_cpu_to_apicid);\r\nif (!((apicid ^ local_apicid) >> NUMACHIP_LAPIC_BITS)) {\r\nunsigned long flags;\r\nlocal_irq_save(flags);\r\n__default_send_IPI_dest_field(apicid, vector,\r\nAPIC_DEST_PHYSICAL);\r\nlocal_irq_restore(flags);\r\npreempt_enable();\r\nreturn;\r\n}\r\npreempt_enable();\r\ndmode = (vector == NMI_VECTOR) ? APIC_DM_NMI : APIC_DM_FIXED;\r\nnumachip_apic_icr_write(apicid, dmode | vector);\r\n}\r\nstatic void numachip_send_IPI_mask(const struct cpumask *mask, int vector)\r\n{\r\nunsigned int cpu;\r\nfor_each_cpu(cpu, mask)\r\nnumachip_send_IPI_one(cpu, vector);\r\n}\r\nstatic void numachip_send_IPI_mask_allbutself(const struct cpumask *mask,\r\nint vector)\r\n{\r\nunsigned int this_cpu = smp_processor_id();\r\nunsigned int cpu;\r\nfor_each_cpu(cpu, mask) {\r\nif (cpu != this_cpu)\r\nnumachip_send_IPI_one(cpu, vector);\r\n}\r\n}\r\nstatic void numachip_send_IPI_allbutself(int vector)\r\n{\r\nunsigned int this_cpu = smp_processor_id();\r\nunsigned int cpu;\r\nfor_each_online_cpu(cpu) {\r\nif (cpu != this_cpu)\r\nnumachip_send_IPI_one(cpu, vector);\r\n}\r\n}\r\nstatic void numachip_send_IPI_all(int vector)\r\n{\r\nnumachip_send_IPI_mask(cpu_online_mask, vector);\r\n}\r\nstatic void numachip_send_IPI_self(int vector)\r\n{\r\napic_write(APIC_SELF_IPI, vector);\r\n}\r\nstatic int __init numachip1_probe(void)\r\n{\r\nreturn apic == &apic_numachip1;\r\n}\r\nstatic int __init numachip2_probe(void)\r\n{\r\nreturn apic == &apic_numachip2;\r\n}\r\nstatic void fixup_cpu_id(struct cpuinfo_x86 *c, int node)\r\n{\r\nu64 val;\r\nu32 nodes = 1;\r\nthis_cpu_write(cpu_llc_id, node);\r\nif (static_cpu_has(X86_FEATURE_NODEID_MSR)) {\r\nrdmsrl(MSR_FAM10H_NODE_ID, val);\r\nnodes = ((val >> 3) & 7) + 1;\r\n}\r\nc->phys_proc_id = node / nodes;\r\n}\r\nstatic int __init numachip_system_init(void)\r\n{\r\nswitch (numachip_system) {\r\ncase 1:\r\ninit_extra_mapping_uc(NUMACHIP_LCSR_BASE, NUMACHIP_LCSR_SIZE);\r\nnumachip_apic_icr_write = numachip1_apic_icr_write;\r\nbreak;\r\ncase 2:\r\ninit_extra_mapping_uc(NUMACHIP2_LCSR_BASE, NUMACHIP2_LCSR_SIZE);\r\nnumachip_apic_icr_write = numachip2_apic_icr_write;\r\nbreak;\r\ndefault:\r\nreturn 0;\r\n}\r\nx86_cpuinit.fixup_cpu_id = fixup_cpu_id;\r\nx86_init.pci.arch_init = pci_numachip_init;\r\nreturn 0;\r\n}\r\nstatic int numachip1_acpi_madt_oem_check(char *oem_id, char *oem_table_id)\r\n{\r\nif ((strncmp(oem_id, "NUMASC", 6) != 0) ||\r\n(strncmp(oem_table_id, "NCONNECT", 8) != 0))\r\nreturn 0;\r\nnumachip_system = 1;\r\nreturn 1;\r\n}\r\nstatic int numachip2_acpi_madt_oem_check(char *oem_id, char *oem_table_id)\r\n{\r\nif ((strncmp(oem_id, "NUMASC", 6) != 0) ||\r\n(strncmp(oem_table_id, "NCONECT2", 8) != 0))\r\nreturn 0;\r\nnumachip_system = 2;\r\nreturn 1;\r\n}\r\nstatic void numachip_apic_wait_icr_idle(void)\r\n{\r\n}\r\nstatic u32 numachip_safe_apic_wait_icr_idle(void)\r\n{\r\nreturn 0;\r\n}
