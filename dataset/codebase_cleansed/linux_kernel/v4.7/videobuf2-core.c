static int __vb2_buf_mem_alloc(struct vb2_buffer *vb)\r\n{\r\nstruct vb2_queue *q = vb->vb2_queue;\r\nenum dma_data_direction dma_dir =\r\nq->is_output ? DMA_TO_DEVICE : DMA_FROM_DEVICE;\r\nvoid *mem_priv;\r\nint plane;\r\nfor (plane = 0; plane < vb->num_planes; ++plane) {\r\nunsigned long size = PAGE_ALIGN(vb->planes[plane].length);\r\nmem_priv = call_ptr_memop(vb, alloc, q->alloc_ctx[plane],\r\nsize, dma_dir, q->gfp_flags);\r\nif (IS_ERR_OR_NULL(mem_priv))\r\ngoto free;\r\nvb->planes[plane].mem_priv = mem_priv;\r\n}\r\nreturn 0;\r\nfree:\r\nfor (; plane > 0; --plane) {\r\ncall_void_memop(vb, put, vb->planes[plane - 1].mem_priv);\r\nvb->planes[plane - 1].mem_priv = NULL;\r\n}\r\nreturn -ENOMEM;\r\n}\r\nstatic void __vb2_buf_mem_free(struct vb2_buffer *vb)\r\n{\r\nunsigned int plane;\r\nfor (plane = 0; plane < vb->num_planes; ++plane) {\r\ncall_void_memop(vb, put, vb->planes[plane].mem_priv);\r\nvb->planes[plane].mem_priv = NULL;\r\ndprintk(3, "freed plane %d of buffer %d\n", plane, vb->index);\r\n}\r\n}\r\nstatic void __vb2_buf_userptr_put(struct vb2_buffer *vb)\r\n{\r\nunsigned int plane;\r\nfor (plane = 0; plane < vb->num_planes; ++plane) {\r\nif (vb->planes[plane].mem_priv)\r\ncall_void_memop(vb, put_userptr, vb->planes[plane].mem_priv);\r\nvb->planes[plane].mem_priv = NULL;\r\n}\r\n}\r\nstatic void __vb2_plane_dmabuf_put(struct vb2_buffer *vb, struct vb2_plane *p)\r\n{\r\nif (!p->mem_priv)\r\nreturn;\r\nif (p->dbuf_mapped)\r\ncall_void_memop(vb, unmap_dmabuf, p->mem_priv);\r\ncall_void_memop(vb, detach_dmabuf, p->mem_priv);\r\ndma_buf_put(p->dbuf);\r\np->mem_priv = NULL;\r\np->dbuf = NULL;\r\np->dbuf_mapped = 0;\r\n}\r\nstatic void __vb2_buf_dmabuf_put(struct vb2_buffer *vb)\r\n{\r\nunsigned int plane;\r\nfor (plane = 0; plane < vb->num_planes; ++plane)\r\n__vb2_plane_dmabuf_put(vb, &vb->planes[plane]);\r\n}\r\nstatic void __setup_offsets(struct vb2_buffer *vb)\r\n{\r\nstruct vb2_queue *q = vb->vb2_queue;\r\nunsigned int plane;\r\nunsigned long off = 0;\r\nif (vb->index) {\r\nstruct vb2_buffer *prev = q->bufs[vb->index - 1];\r\nstruct vb2_plane *p = &prev->planes[prev->num_planes - 1];\r\noff = PAGE_ALIGN(p->m.offset + p->length);\r\n}\r\nfor (plane = 0; plane < vb->num_planes; ++plane) {\r\nvb->planes[plane].m.offset = off;\r\ndprintk(3, "buffer %d, plane %d offset 0x%08lx\n",\r\nvb->index, plane, off);\r\noff += vb->planes[plane].length;\r\noff = PAGE_ALIGN(off);\r\n}\r\n}\r\nstatic int __vb2_queue_alloc(struct vb2_queue *q, enum vb2_memory memory,\r\nunsigned int num_buffers, unsigned int num_planes,\r\nconst unsigned plane_sizes[VB2_MAX_PLANES])\r\n{\r\nunsigned int buffer, plane;\r\nstruct vb2_buffer *vb;\r\nint ret;\r\nfor (buffer = 0; buffer < num_buffers; ++buffer) {\r\nvb = kzalloc(q->buf_struct_size, GFP_KERNEL);\r\nif (!vb) {\r\ndprintk(1, "memory alloc for buffer struct failed\n");\r\nbreak;\r\n}\r\nvb->state = VB2_BUF_STATE_DEQUEUED;\r\nvb->vb2_queue = q;\r\nvb->num_planes = num_planes;\r\nvb->index = q->num_buffers + buffer;\r\nvb->type = q->type;\r\nvb->memory = memory;\r\nfor (plane = 0; plane < num_planes; ++plane) {\r\nvb->planes[plane].length = plane_sizes[plane];\r\nvb->planes[plane].min_length = plane_sizes[plane];\r\n}\r\nq->bufs[vb->index] = vb;\r\nif (memory == VB2_MEMORY_MMAP) {\r\nret = __vb2_buf_mem_alloc(vb);\r\nif (ret) {\r\ndprintk(1, "failed allocating memory for "\r\n"buffer %d\n", buffer);\r\nq->bufs[vb->index] = NULL;\r\nkfree(vb);\r\nbreak;\r\n}\r\n__setup_offsets(vb);\r\nret = call_vb_qop(vb, buf_init, vb);\r\nif (ret) {\r\ndprintk(1, "buffer %d %p initialization"\r\n" failed\n", buffer, vb);\r\n__vb2_buf_mem_free(vb);\r\nq->bufs[vb->index] = NULL;\r\nkfree(vb);\r\nbreak;\r\n}\r\n}\r\n}\r\ndprintk(1, "allocated %d buffers, %d plane(s) each\n",\r\nbuffer, num_planes);\r\nreturn buffer;\r\n}\r\nstatic void __vb2_free_mem(struct vb2_queue *q, unsigned int buffers)\r\n{\r\nunsigned int buffer;\r\nstruct vb2_buffer *vb;\r\nfor (buffer = q->num_buffers - buffers; buffer < q->num_buffers;\r\n++buffer) {\r\nvb = q->bufs[buffer];\r\nif (!vb)\r\ncontinue;\r\nif (q->memory == VB2_MEMORY_MMAP)\r\n__vb2_buf_mem_free(vb);\r\nelse if (q->memory == VB2_MEMORY_DMABUF)\r\n__vb2_buf_dmabuf_put(vb);\r\nelse\r\n__vb2_buf_userptr_put(vb);\r\n}\r\n}\r\nstatic int __vb2_queue_free(struct vb2_queue *q, unsigned int buffers)\r\n{\r\nunsigned int buffer;\r\nfor (buffer = q->num_buffers - buffers; buffer < q->num_buffers;\r\n++buffer) {\r\nif (q->bufs[buffer] == NULL)\r\ncontinue;\r\nif (q->bufs[buffer]->state == VB2_BUF_STATE_PREPARING) {\r\ndprintk(1, "preparing buffers, cannot free\n");\r\nreturn -EAGAIN;\r\n}\r\n}\r\nfor (buffer = q->num_buffers - buffers; buffer < q->num_buffers;\r\n++buffer) {\r\nstruct vb2_buffer *vb = q->bufs[buffer];\r\nif (vb && vb->planes[0].mem_priv)\r\ncall_void_vb_qop(vb, buf_cleanup, vb);\r\n}\r\n__vb2_free_mem(q, buffers);\r\n#ifdef CONFIG_VIDEO_ADV_DEBUG\r\nif (q->num_buffers) {\r\nbool unbalanced = q->cnt_start_streaming != q->cnt_stop_streaming ||\r\nq->cnt_wait_prepare != q->cnt_wait_finish;\r\nif (unbalanced || debug) {\r\npr_info("vb2: counters for queue %p:%s\n", q,\r\nunbalanced ? " UNBALANCED!" : "");\r\npr_info("vb2: setup: %u start_streaming: %u stop_streaming: %u\n",\r\nq->cnt_queue_setup, q->cnt_start_streaming,\r\nq->cnt_stop_streaming);\r\npr_info("vb2: wait_prepare: %u wait_finish: %u\n",\r\nq->cnt_wait_prepare, q->cnt_wait_finish);\r\n}\r\nq->cnt_queue_setup = 0;\r\nq->cnt_wait_prepare = 0;\r\nq->cnt_wait_finish = 0;\r\nq->cnt_start_streaming = 0;\r\nq->cnt_stop_streaming = 0;\r\n}\r\nfor (buffer = 0; buffer < q->num_buffers; ++buffer) {\r\nstruct vb2_buffer *vb = q->bufs[buffer];\r\nbool unbalanced = vb->cnt_mem_alloc != vb->cnt_mem_put ||\r\nvb->cnt_mem_prepare != vb->cnt_mem_finish ||\r\nvb->cnt_mem_get_userptr != vb->cnt_mem_put_userptr ||\r\nvb->cnt_mem_attach_dmabuf != vb->cnt_mem_detach_dmabuf ||\r\nvb->cnt_mem_map_dmabuf != vb->cnt_mem_unmap_dmabuf ||\r\nvb->cnt_buf_queue != vb->cnt_buf_done ||\r\nvb->cnt_buf_prepare != vb->cnt_buf_finish ||\r\nvb->cnt_buf_init != vb->cnt_buf_cleanup;\r\nif (unbalanced || debug) {\r\npr_info("vb2: counters for queue %p, buffer %d:%s\n",\r\nq, buffer, unbalanced ? " UNBALANCED!" : "");\r\npr_info("vb2: buf_init: %u buf_cleanup: %u buf_prepare: %u buf_finish: %u\n",\r\nvb->cnt_buf_init, vb->cnt_buf_cleanup,\r\nvb->cnt_buf_prepare, vb->cnt_buf_finish);\r\npr_info("vb2: buf_queue: %u buf_done: %u\n",\r\nvb->cnt_buf_queue, vb->cnt_buf_done);\r\npr_info("vb2: alloc: %u put: %u prepare: %u finish: %u mmap: %u\n",\r\nvb->cnt_mem_alloc, vb->cnt_mem_put,\r\nvb->cnt_mem_prepare, vb->cnt_mem_finish,\r\nvb->cnt_mem_mmap);\r\npr_info("vb2: get_userptr: %u put_userptr: %u\n",\r\nvb->cnt_mem_get_userptr, vb->cnt_mem_put_userptr);\r\npr_info("vb2: attach_dmabuf: %u detach_dmabuf: %u map_dmabuf: %u unmap_dmabuf: %u\n",\r\nvb->cnt_mem_attach_dmabuf, vb->cnt_mem_detach_dmabuf,\r\nvb->cnt_mem_map_dmabuf, vb->cnt_mem_unmap_dmabuf);\r\npr_info("vb2: get_dmabuf: %u num_users: %u vaddr: %u cookie: %u\n",\r\nvb->cnt_mem_get_dmabuf,\r\nvb->cnt_mem_num_users,\r\nvb->cnt_mem_vaddr,\r\nvb->cnt_mem_cookie);\r\n}\r\n}\r\n#endif\r\nfor (buffer = q->num_buffers - buffers; buffer < q->num_buffers;\r\n++buffer) {\r\nkfree(q->bufs[buffer]);\r\nq->bufs[buffer] = NULL;\r\n}\r\nq->num_buffers -= buffers;\r\nif (!q->num_buffers) {\r\nq->memory = 0;\r\nINIT_LIST_HEAD(&q->queued_list);\r\n}\r\nreturn 0;\r\n}\r\nbool vb2_buffer_in_use(struct vb2_queue *q, struct vb2_buffer *vb)\r\n{\r\nunsigned int plane;\r\nfor (plane = 0; plane < vb->num_planes; ++plane) {\r\nvoid *mem_priv = vb->planes[plane].mem_priv;\r\nif (mem_priv && call_memop(vb, num_users, mem_priv) > 1)\r\nreturn true;\r\n}\r\nreturn false;\r\n}\r\nstatic bool __buffers_in_use(struct vb2_queue *q)\r\n{\r\nunsigned int buffer;\r\nfor (buffer = 0; buffer < q->num_buffers; ++buffer) {\r\nif (vb2_buffer_in_use(q, q->bufs[buffer]))\r\nreturn true;\r\n}\r\nreturn false;\r\n}\r\nvoid vb2_core_querybuf(struct vb2_queue *q, unsigned int index, void *pb)\r\n{\r\ncall_void_bufop(q, fill_user_buffer, q->bufs[index], pb);\r\n}\r\nstatic int __verify_userptr_ops(struct vb2_queue *q)\r\n{\r\nif (!(q->io_modes & VB2_USERPTR) || !q->mem_ops->get_userptr ||\r\n!q->mem_ops->put_userptr)\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\nstatic int __verify_mmap_ops(struct vb2_queue *q)\r\n{\r\nif (!(q->io_modes & VB2_MMAP) || !q->mem_ops->alloc ||\r\n!q->mem_ops->put || !q->mem_ops->mmap)\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\nstatic int __verify_dmabuf_ops(struct vb2_queue *q)\r\n{\r\nif (!(q->io_modes & VB2_DMABUF) || !q->mem_ops->attach_dmabuf ||\r\n!q->mem_ops->detach_dmabuf || !q->mem_ops->map_dmabuf ||\r\n!q->mem_ops->unmap_dmabuf)\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\nint vb2_verify_memory_type(struct vb2_queue *q,\r\nenum vb2_memory memory, unsigned int type)\r\n{\r\nif (memory != VB2_MEMORY_MMAP && memory != VB2_MEMORY_USERPTR &&\r\nmemory != VB2_MEMORY_DMABUF) {\r\ndprintk(1, "unsupported memory type\n");\r\nreturn -EINVAL;\r\n}\r\nif (type != q->type) {\r\ndprintk(1, "requested type is incorrect\n");\r\nreturn -EINVAL;\r\n}\r\nif (memory == VB2_MEMORY_MMAP && __verify_mmap_ops(q)) {\r\ndprintk(1, "MMAP for current setup unsupported\n");\r\nreturn -EINVAL;\r\n}\r\nif (memory == VB2_MEMORY_USERPTR && __verify_userptr_ops(q)) {\r\ndprintk(1, "USERPTR for current setup unsupported\n");\r\nreturn -EINVAL;\r\n}\r\nif (memory == VB2_MEMORY_DMABUF && __verify_dmabuf_ops(q)) {\r\ndprintk(1, "DMABUF for current setup unsupported\n");\r\nreturn -EINVAL;\r\n}\r\nif (vb2_fileio_is_active(q)) {\r\ndprintk(1, "file io in progress\n");\r\nreturn -EBUSY;\r\n}\r\nreturn 0;\r\n}\r\nint vb2_core_reqbufs(struct vb2_queue *q, enum vb2_memory memory,\r\nunsigned int *count)\r\n{\r\nunsigned int num_buffers, allocated_buffers, num_planes = 0;\r\nunsigned plane_sizes[VB2_MAX_PLANES] = { };\r\nint ret;\r\nif (q->streaming) {\r\ndprintk(1, "streaming active\n");\r\nreturn -EBUSY;\r\n}\r\nif (*count == 0 || q->num_buffers != 0 || q->memory != memory) {\r\nmutex_lock(&q->mmap_lock);\r\nif (q->memory == VB2_MEMORY_MMAP && __buffers_in_use(q)) {\r\nmutex_unlock(&q->mmap_lock);\r\ndprintk(1, "memory in use, cannot free\n");\r\nreturn -EBUSY;\r\n}\r\n__vb2_queue_cancel(q);\r\nret = __vb2_queue_free(q, q->num_buffers);\r\nmutex_unlock(&q->mmap_lock);\r\nif (ret)\r\nreturn ret;\r\nif (*count == 0)\r\nreturn 0;\r\n}\r\nnum_buffers = min_t(unsigned int, *count, VB2_MAX_FRAME);\r\nnum_buffers = max_t(unsigned int, num_buffers, q->min_buffers_needed);\r\nmemset(q->alloc_ctx, 0, sizeof(q->alloc_ctx));\r\nq->memory = memory;\r\nret = call_qop(q, queue_setup, q, &num_buffers, &num_planes,\r\nplane_sizes, q->alloc_ctx);\r\nif (ret)\r\nreturn ret;\r\nallocated_buffers =\r\n__vb2_queue_alloc(q, memory, num_buffers, num_planes, plane_sizes);\r\nif (allocated_buffers == 0) {\r\ndprintk(1, "memory allocation failed\n");\r\nreturn -ENOMEM;\r\n}\r\nif (allocated_buffers < q->min_buffers_needed)\r\nret = -ENOMEM;\r\nif (!ret && allocated_buffers < num_buffers) {\r\nnum_buffers = allocated_buffers;\r\nnum_planes = 0;\r\nret = call_qop(q, queue_setup, q, &num_buffers,\r\n&num_planes, plane_sizes, q->alloc_ctx);\r\nif (!ret && allocated_buffers < num_buffers)\r\nret = -ENOMEM;\r\n}\r\nmutex_lock(&q->mmap_lock);\r\nq->num_buffers = allocated_buffers;\r\nif (ret < 0) {\r\n__vb2_queue_free(q, allocated_buffers);\r\nmutex_unlock(&q->mmap_lock);\r\nreturn ret;\r\n}\r\nmutex_unlock(&q->mmap_lock);\r\n*count = allocated_buffers;\r\nq->waiting_for_buffers = !q->is_output;\r\nreturn 0;\r\n}\r\nint vb2_core_create_bufs(struct vb2_queue *q, enum vb2_memory memory,\r\nunsigned int *count, unsigned requested_planes,\r\nconst unsigned requested_sizes[])\r\n{\r\nunsigned int num_planes = 0, num_buffers, allocated_buffers;\r\nunsigned plane_sizes[VB2_MAX_PLANES] = { };\r\nint ret;\r\nif (q->num_buffers == VB2_MAX_FRAME) {\r\ndprintk(1, "maximum number of buffers already allocated\n");\r\nreturn -ENOBUFS;\r\n}\r\nif (!q->num_buffers) {\r\nmemset(q->alloc_ctx, 0, sizeof(q->alloc_ctx));\r\nq->memory = memory;\r\nq->waiting_for_buffers = !q->is_output;\r\n}\r\nnum_buffers = min(*count, VB2_MAX_FRAME - q->num_buffers);\r\nif (requested_planes && requested_sizes) {\r\nnum_planes = requested_planes;\r\nmemcpy(plane_sizes, requested_sizes, sizeof(plane_sizes));\r\n}\r\nret = call_qop(q, queue_setup, q, &num_buffers,\r\n&num_planes, plane_sizes, q->alloc_ctx);\r\nif (ret)\r\nreturn ret;\r\nallocated_buffers = __vb2_queue_alloc(q, memory, num_buffers,\r\nnum_planes, plane_sizes);\r\nif (allocated_buffers == 0) {\r\ndprintk(1, "memory allocation failed\n");\r\nreturn -ENOMEM;\r\n}\r\nif (allocated_buffers < num_buffers) {\r\nnum_buffers = allocated_buffers;\r\nret = call_qop(q, queue_setup, q, &num_buffers,\r\n&num_planes, plane_sizes, q->alloc_ctx);\r\nif (!ret && allocated_buffers < num_buffers)\r\nret = -ENOMEM;\r\n}\r\nmutex_lock(&q->mmap_lock);\r\nq->num_buffers += allocated_buffers;\r\nif (ret < 0) {\r\n__vb2_queue_free(q, allocated_buffers);\r\nmutex_unlock(&q->mmap_lock);\r\nreturn -ENOMEM;\r\n}\r\nmutex_unlock(&q->mmap_lock);\r\n*count = allocated_buffers;\r\nreturn 0;\r\n}\r\nvoid *vb2_plane_vaddr(struct vb2_buffer *vb, unsigned int plane_no)\r\n{\r\nif (plane_no > vb->num_planes || !vb->planes[plane_no].mem_priv)\r\nreturn NULL;\r\nreturn call_ptr_memop(vb, vaddr, vb->planes[plane_no].mem_priv);\r\n}\r\nvoid *vb2_plane_cookie(struct vb2_buffer *vb, unsigned int plane_no)\r\n{\r\nif (plane_no >= vb->num_planes || !vb->planes[plane_no].mem_priv)\r\nreturn NULL;\r\nreturn call_ptr_memop(vb, cookie, vb->planes[plane_no].mem_priv);\r\n}\r\nvoid vb2_buffer_done(struct vb2_buffer *vb, enum vb2_buffer_state state)\r\n{\r\nstruct vb2_queue *q = vb->vb2_queue;\r\nunsigned long flags;\r\nunsigned int plane;\r\nif (WARN_ON(vb->state != VB2_BUF_STATE_ACTIVE))\r\nreturn;\r\nif (WARN_ON(state != VB2_BUF_STATE_DONE &&\r\nstate != VB2_BUF_STATE_ERROR &&\r\nstate != VB2_BUF_STATE_QUEUED &&\r\nstate != VB2_BUF_STATE_REQUEUEING))\r\nstate = VB2_BUF_STATE_ERROR;\r\n#ifdef CONFIG_VIDEO_ADV_DEBUG\r\nvb->cnt_buf_done++;\r\n#endif\r\ndprintk(4, "done processing on buffer %d, state: %d\n",\r\nvb->index, state);\r\nfor (plane = 0; plane < vb->num_planes; ++plane)\r\ncall_void_memop(vb, finish, vb->planes[plane].mem_priv);\r\nspin_lock_irqsave(&q->done_lock, flags);\r\nif (state == VB2_BUF_STATE_QUEUED ||\r\nstate == VB2_BUF_STATE_REQUEUEING) {\r\nvb->state = VB2_BUF_STATE_QUEUED;\r\n} else {\r\nlist_add_tail(&vb->done_entry, &q->done_list);\r\nvb->state = state;\r\n}\r\natomic_dec(&q->owned_by_drv_count);\r\nspin_unlock_irqrestore(&q->done_lock, flags);\r\ntrace_vb2_buf_done(q, vb);\r\nswitch (state) {\r\ncase VB2_BUF_STATE_QUEUED:\r\nreturn;\r\ncase VB2_BUF_STATE_REQUEUEING:\r\nif (q->start_streaming_called)\r\n__enqueue_in_driver(vb);\r\nreturn;\r\ndefault:\r\nwake_up(&q->done_wq);\r\nbreak;\r\n}\r\n}\r\nvoid vb2_discard_done(struct vb2_queue *q)\r\n{\r\nstruct vb2_buffer *vb;\r\nunsigned long flags;\r\nspin_lock_irqsave(&q->done_lock, flags);\r\nlist_for_each_entry(vb, &q->done_list, done_entry)\r\nvb->state = VB2_BUF_STATE_ERROR;\r\nspin_unlock_irqrestore(&q->done_lock, flags);\r\n}\r\nstatic int __qbuf_mmap(struct vb2_buffer *vb, const void *pb)\r\n{\r\nint ret = 0;\r\nif (pb)\r\nret = call_bufop(vb->vb2_queue, fill_vb2_buffer,\r\nvb, pb, vb->planes);\r\nreturn ret ? ret : call_vb_qop(vb, buf_prepare, vb);\r\n}\r\nstatic int __qbuf_userptr(struct vb2_buffer *vb, const void *pb)\r\n{\r\nstruct vb2_plane planes[VB2_MAX_PLANES];\r\nstruct vb2_queue *q = vb->vb2_queue;\r\nvoid *mem_priv;\r\nunsigned int plane;\r\nint ret = 0;\r\nenum dma_data_direction dma_dir =\r\nq->is_output ? DMA_TO_DEVICE : DMA_FROM_DEVICE;\r\nbool reacquired = vb->planes[0].mem_priv == NULL;\r\nmemset(planes, 0, sizeof(planes[0]) * vb->num_planes);\r\nif (pb)\r\nret = call_bufop(vb->vb2_queue, fill_vb2_buffer,\r\nvb, pb, planes);\r\nif (ret)\r\nreturn ret;\r\nfor (plane = 0; plane < vb->num_planes; ++plane) {\r\nif (vb->planes[plane].m.userptr &&\r\nvb->planes[plane].m.userptr == planes[plane].m.userptr\r\n&& vb->planes[plane].length == planes[plane].length)\r\ncontinue;\r\ndprintk(3, "userspace address for plane %d changed, "\r\n"reacquiring memory\n", plane);\r\nif (planes[plane].length < vb->planes[plane].min_length) {\r\ndprintk(1, "provided buffer size %u is less than "\r\n"setup size %u for plane %d\n",\r\nplanes[plane].length,\r\nvb->planes[plane].min_length,\r\nplane);\r\nret = -EINVAL;\r\ngoto err;\r\n}\r\nif (vb->planes[plane].mem_priv) {\r\nif (!reacquired) {\r\nreacquired = true;\r\ncall_void_vb_qop(vb, buf_cleanup, vb);\r\n}\r\ncall_void_memop(vb, put_userptr, vb->planes[plane].mem_priv);\r\n}\r\nvb->planes[plane].mem_priv = NULL;\r\nvb->planes[plane].bytesused = 0;\r\nvb->planes[plane].length = 0;\r\nvb->planes[plane].m.userptr = 0;\r\nvb->planes[plane].data_offset = 0;\r\nmem_priv = call_ptr_memop(vb, get_userptr, q->alloc_ctx[plane],\r\nplanes[plane].m.userptr,\r\nplanes[plane].length, dma_dir);\r\nif (IS_ERR_OR_NULL(mem_priv)) {\r\ndprintk(1, "failed acquiring userspace "\r\n"memory for plane %d\n", plane);\r\nret = mem_priv ? PTR_ERR(mem_priv) : -EINVAL;\r\ngoto err;\r\n}\r\nvb->planes[plane].mem_priv = mem_priv;\r\n}\r\nfor (plane = 0; plane < vb->num_planes; ++plane) {\r\nvb->planes[plane].bytesused = planes[plane].bytesused;\r\nvb->planes[plane].length = planes[plane].length;\r\nvb->planes[plane].m.userptr = planes[plane].m.userptr;\r\nvb->planes[plane].data_offset = planes[plane].data_offset;\r\n}\r\nif (reacquired) {\r\nret = call_vb_qop(vb, buf_init, vb);\r\nif (ret) {\r\ndprintk(1, "buffer initialization failed\n");\r\ngoto err;\r\n}\r\n}\r\nret = call_vb_qop(vb, buf_prepare, vb);\r\nif (ret) {\r\ndprintk(1, "buffer preparation failed\n");\r\ncall_void_vb_qop(vb, buf_cleanup, vb);\r\ngoto err;\r\n}\r\nreturn 0;\r\nerr:\r\nfor (plane = 0; plane < vb->num_planes; ++plane) {\r\nif (vb->planes[plane].mem_priv)\r\ncall_void_memop(vb, put_userptr,\r\nvb->planes[plane].mem_priv);\r\nvb->planes[plane].mem_priv = NULL;\r\nvb->planes[plane].m.userptr = 0;\r\nvb->planes[plane].length = 0;\r\n}\r\nreturn ret;\r\n}\r\nstatic int __qbuf_dmabuf(struct vb2_buffer *vb, const void *pb)\r\n{\r\nstruct vb2_plane planes[VB2_MAX_PLANES];\r\nstruct vb2_queue *q = vb->vb2_queue;\r\nvoid *mem_priv;\r\nunsigned int plane;\r\nint ret = 0;\r\nenum dma_data_direction dma_dir =\r\nq->is_output ? DMA_TO_DEVICE : DMA_FROM_DEVICE;\r\nbool reacquired = vb->planes[0].mem_priv == NULL;\r\nmemset(planes, 0, sizeof(planes[0]) * vb->num_planes);\r\nif (pb)\r\nret = call_bufop(vb->vb2_queue, fill_vb2_buffer,\r\nvb, pb, planes);\r\nif (ret)\r\nreturn ret;\r\nfor (plane = 0; plane < vb->num_planes; ++plane) {\r\nstruct dma_buf *dbuf = dma_buf_get(planes[plane].m.fd);\r\nif (IS_ERR_OR_NULL(dbuf)) {\r\ndprintk(1, "invalid dmabuf fd for plane %d\n",\r\nplane);\r\nret = -EINVAL;\r\ngoto err;\r\n}\r\nif (planes[plane].length == 0)\r\nplanes[plane].length = dbuf->size;\r\nif (planes[plane].length < vb->planes[plane].min_length) {\r\ndprintk(1, "invalid dmabuf length for plane %d\n",\r\nplane);\r\ndma_buf_put(dbuf);\r\nret = -EINVAL;\r\ngoto err;\r\n}\r\nif (dbuf == vb->planes[plane].dbuf &&\r\nvb->planes[plane].length == planes[plane].length) {\r\ndma_buf_put(dbuf);\r\ncontinue;\r\n}\r\ndprintk(1, "buffer for plane %d changed\n", plane);\r\nif (!reacquired) {\r\nreacquired = true;\r\ncall_void_vb_qop(vb, buf_cleanup, vb);\r\n}\r\n__vb2_plane_dmabuf_put(vb, &vb->planes[plane]);\r\nvb->planes[plane].bytesused = 0;\r\nvb->planes[plane].length = 0;\r\nvb->planes[plane].m.fd = 0;\r\nvb->planes[plane].data_offset = 0;\r\nmem_priv = call_ptr_memop(vb, attach_dmabuf,\r\nq->alloc_ctx[plane], dbuf, planes[plane].length,\r\ndma_dir);\r\nif (IS_ERR(mem_priv)) {\r\ndprintk(1, "failed to attach dmabuf\n");\r\nret = PTR_ERR(mem_priv);\r\ndma_buf_put(dbuf);\r\ngoto err;\r\n}\r\nvb->planes[plane].dbuf = dbuf;\r\nvb->planes[plane].mem_priv = mem_priv;\r\n}\r\nfor (plane = 0; plane < vb->num_planes; ++plane) {\r\nret = call_memop(vb, map_dmabuf, vb->planes[plane].mem_priv);\r\nif (ret) {\r\ndprintk(1, "failed to map dmabuf for plane %d\n",\r\nplane);\r\ngoto err;\r\n}\r\nvb->planes[plane].dbuf_mapped = 1;\r\n}\r\nfor (plane = 0; plane < vb->num_planes; ++plane) {\r\nvb->planes[plane].bytesused = planes[plane].bytesused;\r\nvb->planes[plane].length = planes[plane].length;\r\nvb->planes[plane].m.fd = planes[plane].m.fd;\r\nvb->planes[plane].data_offset = planes[plane].data_offset;\r\n}\r\nif (reacquired) {\r\nret = call_vb_qop(vb, buf_init, vb);\r\nif (ret) {\r\ndprintk(1, "buffer initialization failed\n");\r\ngoto err;\r\n}\r\n}\r\nret = call_vb_qop(vb, buf_prepare, vb);\r\nif (ret) {\r\ndprintk(1, "buffer preparation failed\n");\r\ncall_void_vb_qop(vb, buf_cleanup, vb);\r\ngoto err;\r\n}\r\nreturn 0;\r\nerr:\r\n__vb2_buf_dmabuf_put(vb);\r\nreturn ret;\r\n}\r\nstatic void __enqueue_in_driver(struct vb2_buffer *vb)\r\n{\r\nstruct vb2_queue *q = vb->vb2_queue;\r\nunsigned int plane;\r\nvb->state = VB2_BUF_STATE_ACTIVE;\r\natomic_inc(&q->owned_by_drv_count);\r\ntrace_vb2_buf_queue(q, vb);\r\nfor (plane = 0; plane < vb->num_planes; ++plane)\r\ncall_void_memop(vb, prepare, vb->planes[plane].mem_priv);\r\ncall_void_vb_qop(vb, buf_queue, vb);\r\n}\r\nstatic int __buf_prepare(struct vb2_buffer *vb, const void *pb)\r\n{\r\nstruct vb2_queue *q = vb->vb2_queue;\r\nint ret;\r\nif (q->error) {\r\ndprintk(1, "fatal error occurred on queue\n");\r\nreturn -EIO;\r\n}\r\nvb->state = VB2_BUF_STATE_PREPARING;\r\nswitch (q->memory) {\r\ncase VB2_MEMORY_MMAP:\r\nret = __qbuf_mmap(vb, pb);\r\nbreak;\r\ncase VB2_MEMORY_USERPTR:\r\nret = __qbuf_userptr(vb, pb);\r\nbreak;\r\ncase VB2_MEMORY_DMABUF:\r\nret = __qbuf_dmabuf(vb, pb);\r\nbreak;\r\ndefault:\r\nWARN(1, "Invalid queue type\n");\r\nret = -EINVAL;\r\n}\r\nif (ret)\r\ndprintk(1, "buffer preparation failed: %d\n", ret);\r\nvb->state = ret ? VB2_BUF_STATE_DEQUEUED : VB2_BUF_STATE_PREPARED;\r\nreturn ret;\r\n}\r\nint vb2_core_prepare_buf(struct vb2_queue *q, unsigned int index, void *pb)\r\n{\r\nstruct vb2_buffer *vb;\r\nint ret;\r\nvb = q->bufs[index];\r\nif (vb->state != VB2_BUF_STATE_DEQUEUED) {\r\ndprintk(1, "invalid buffer state %d\n",\r\nvb->state);\r\nreturn -EINVAL;\r\n}\r\nret = __buf_prepare(vb, pb);\r\nif (ret)\r\nreturn ret;\r\ncall_void_bufop(q, fill_user_buffer, vb, pb);\r\ndprintk(1, "prepare of buffer %d succeeded\n", vb->index);\r\nreturn ret;\r\n}\r\nstatic int vb2_start_streaming(struct vb2_queue *q)\r\n{\r\nstruct vb2_buffer *vb;\r\nint ret;\r\nlist_for_each_entry(vb, &q->queued_list, queued_entry)\r\n__enqueue_in_driver(vb);\r\nq->start_streaming_called = 1;\r\nret = call_qop(q, start_streaming, q,\r\natomic_read(&q->owned_by_drv_count));\r\nif (!ret)\r\nreturn 0;\r\nq->start_streaming_called = 0;\r\ndprintk(1, "driver refused to start streaming\n");\r\nif (WARN_ON(atomic_read(&q->owned_by_drv_count))) {\r\nunsigned i;\r\nfor (i = 0; i < q->num_buffers; ++i) {\r\nvb = q->bufs[i];\r\nif (vb->state == VB2_BUF_STATE_ACTIVE)\r\nvb2_buffer_done(vb, VB2_BUF_STATE_QUEUED);\r\n}\r\nWARN_ON(atomic_read(&q->owned_by_drv_count));\r\n}\r\nWARN_ON(!list_empty(&q->done_list));\r\nreturn ret;\r\n}\r\nint vb2_core_qbuf(struct vb2_queue *q, unsigned int index, void *pb)\r\n{\r\nstruct vb2_buffer *vb;\r\nint ret;\r\nvb = q->bufs[index];\r\nswitch (vb->state) {\r\ncase VB2_BUF_STATE_DEQUEUED:\r\nret = __buf_prepare(vb, pb);\r\nif (ret)\r\nreturn ret;\r\nbreak;\r\ncase VB2_BUF_STATE_PREPARED:\r\nbreak;\r\ncase VB2_BUF_STATE_PREPARING:\r\ndprintk(1, "buffer still being prepared\n");\r\nreturn -EINVAL;\r\ndefault:\r\ndprintk(1, "invalid buffer state %d\n", vb->state);\r\nreturn -EINVAL;\r\n}\r\nlist_add_tail(&vb->queued_entry, &q->queued_list);\r\nq->queued_count++;\r\nq->waiting_for_buffers = false;\r\nvb->state = VB2_BUF_STATE_QUEUED;\r\nif (pb)\r\ncall_void_bufop(q, copy_timestamp, vb, pb);\r\ntrace_vb2_qbuf(q, vb);\r\nif (q->start_streaming_called)\r\n__enqueue_in_driver(vb);\r\nif (pb)\r\ncall_void_bufop(q, fill_user_buffer, vb, pb);\r\nif (q->streaming && !q->start_streaming_called &&\r\nq->queued_count >= q->min_buffers_needed) {\r\nret = vb2_start_streaming(q);\r\nif (ret)\r\nreturn ret;\r\n}\r\ndprintk(1, "qbuf of buffer %d succeeded\n", vb->index);\r\nreturn 0;\r\n}\r\nstatic int __vb2_wait_for_done_vb(struct vb2_queue *q, int nonblocking)\r\n{\r\nfor (;;) {\r\nint ret;\r\nif (!q->streaming) {\r\ndprintk(1, "streaming off, will not wait for buffers\n");\r\nreturn -EINVAL;\r\n}\r\nif (q->error) {\r\ndprintk(1, "Queue in error state, will not wait for buffers\n");\r\nreturn -EIO;\r\n}\r\nif (q->last_buffer_dequeued) {\r\ndprintk(3, "last buffer dequeued already, will not wait for buffers\n");\r\nreturn -EPIPE;\r\n}\r\nif (!list_empty(&q->done_list)) {\r\nbreak;\r\n}\r\nif (nonblocking) {\r\ndprintk(1, "nonblocking and no buffers to dequeue, "\r\n"will not wait\n");\r\nreturn -EAGAIN;\r\n}\r\ncall_void_qop(q, wait_prepare, q);\r\ndprintk(3, "will sleep waiting for buffers\n");\r\nret = wait_event_interruptible(q->done_wq,\r\n!list_empty(&q->done_list) || !q->streaming ||\r\nq->error);\r\ncall_void_qop(q, wait_finish, q);\r\nif (ret) {\r\ndprintk(1, "sleep was interrupted\n");\r\nreturn ret;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int __vb2_get_done_vb(struct vb2_queue *q, struct vb2_buffer **vb,\r\nvoid *pb, int nonblocking)\r\n{\r\nunsigned long flags;\r\nint ret;\r\nret = __vb2_wait_for_done_vb(q, nonblocking);\r\nif (ret)\r\nreturn ret;\r\nspin_lock_irqsave(&q->done_lock, flags);\r\n*vb = list_first_entry(&q->done_list, struct vb2_buffer, done_entry);\r\nret = call_bufop(q, verify_planes_array, *vb, pb);\r\nif (!ret)\r\nlist_del(&(*vb)->done_entry);\r\nspin_unlock_irqrestore(&q->done_lock, flags);\r\nreturn ret;\r\n}\r\nint vb2_wait_for_all_buffers(struct vb2_queue *q)\r\n{\r\nif (!q->streaming) {\r\ndprintk(1, "streaming off, will not wait for buffers\n");\r\nreturn -EINVAL;\r\n}\r\nif (q->start_streaming_called)\r\nwait_event(q->done_wq, !atomic_read(&q->owned_by_drv_count));\r\nreturn 0;\r\n}\r\nstatic void __vb2_dqbuf(struct vb2_buffer *vb)\r\n{\r\nstruct vb2_queue *q = vb->vb2_queue;\r\nunsigned int i;\r\nif (vb->state == VB2_BUF_STATE_DEQUEUED)\r\nreturn;\r\nvb->state = VB2_BUF_STATE_DEQUEUED;\r\nif (q->memory == VB2_MEMORY_DMABUF)\r\nfor (i = 0; i < vb->num_planes; ++i) {\r\nif (!vb->planes[i].dbuf_mapped)\r\ncontinue;\r\ncall_void_memop(vb, unmap_dmabuf, vb->planes[i].mem_priv);\r\nvb->planes[i].dbuf_mapped = 0;\r\n}\r\n}\r\nint vb2_core_dqbuf(struct vb2_queue *q, unsigned int *pindex, void *pb,\r\nbool nonblocking)\r\n{\r\nstruct vb2_buffer *vb = NULL;\r\nint ret;\r\nret = __vb2_get_done_vb(q, &vb, pb, nonblocking);\r\nif (ret < 0)\r\nreturn ret;\r\nswitch (vb->state) {\r\ncase VB2_BUF_STATE_DONE:\r\ndprintk(3, "returning done buffer\n");\r\nbreak;\r\ncase VB2_BUF_STATE_ERROR:\r\ndprintk(3, "returning done buffer with errors\n");\r\nbreak;\r\ndefault:\r\ndprintk(1, "invalid buffer state\n");\r\nreturn -EINVAL;\r\n}\r\ncall_void_vb_qop(vb, buf_finish, vb);\r\nif (pindex)\r\n*pindex = vb->index;\r\nif (pb)\r\ncall_void_bufop(q, fill_user_buffer, vb, pb);\r\nlist_del(&vb->queued_entry);\r\nq->queued_count--;\r\ntrace_vb2_dqbuf(q, vb);\r\n__vb2_dqbuf(vb);\r\ndprintk(1, "dqbuf of buffer %d, with state %d\n",\r\nvb->index, vb->state);\r\nreturn 0;\r\n}\r\nstatic void __vb2_queue_cancel(struct vb2_queue *q)\r\n{\r\nunsigned int i;\r\nif (q->start_streaming_called)\r\ncall_void_qop(q, stop_streaming, q);\r\nif (WARN_ON(atomic_read(&q->owned_by_drv_count))) {\r\nfor (i = 0; i < q->num_buffers; ++i)\r\nif (q->bufs[i]->state == VB2_BUF_STATE_ACTIVE)\r\nvb2_buffer_done(q->bufs[i], VB2_BUF_STATE_ERROR);\r\nWARN_ON(atomic_read(&q->owned_by_drv_count));\r\n}\r\nq->streaming = 0;\r\nq->start_streaming_called = 0;\r\nq->queued_count = 0;\r\nq->error = 0;\r\nINIT_LIST_HEAD(&q->queued_list);\r\nINIT_LIST_HEAD(&q->done_list);\r\natomic_set(&q->owned_by_drv_count, 0);\r\nwake_up_all(&q->done_wq);\r\nfor (i = 0; i < q->num_buffers; ++i) {\r\nstruct vb2_buffer *vb = q->bufs[i];\r\nif (vb->state != VB2_BUF_STATE_DEQUEUED) {\r\nvb->state = VB2_BUF_STATE_PREPARED;\r\ncall_void_vb_qop(vb, buf_finish, vb);\r\n}\r\n__vb2_dqbuf(vb);\r\n}\r\n}\r\nint vb2_core_streamon(struct vb2_queue *q, unsigned int type)\r\n{\r\nint ret;\r\nif (type != q->type) {\r\ndprintk(1, "invalid stream type\n");\r\nreturn -EINVAL;\r\n}\r\nif (q->streaming) {\r\ndprintk(3, "already streaming\n");\r\nreturn 0;\r\n}\r\nif (!q->num_buffers) {\r\ndprintk(1, "no buffers have been allocated\n");\r\nreturn -EINVAL;\r\n}\r\nif (q->num_buffers < q->min_buffers_needed) {\r\ndprintk(1, "need at least %u allocated buffers\n",\r\nq->min_buffers_needed);\r\nreturn -EINVAL;\r\n}\r\nif (q->queued_count >= q->min_buffers_needed) {\r\nret = v4l_vb2q_enable_media_source(q);\r\nif (ret)\r\nreturn ret;\r\nret = vb2_start_streaming(q);\r\nif (ret) {\r\n__vb2_queue_cancel(q);\r\nreturn ret;\r\n}\r\n}\r\nq->streaming = 1;\r\ndprintk(3, "successful\n");\r\nreturn 0;\r\n}\r\nvoid vb2_queue_error(struct vb2_queue *q)\r\n{\r\nq->error = 1;\r\nwake_up_all(&q->done_wq);\r\n}\r\nint vb2_core_streamoff(struct vb2_queue *q, unsigned int type)\r\n{\r\nif (type != q->type) {\r\ndprintk(1, "invalid stream type\n");\r\nreturn -EINVAL;\r\n}\r\n__vb2_queue_cancel(q);\r\nq->waiting_for_buffers = !q->is_output;\r\nq->last_buffer_dequeued = false;\r\ndprintk(3, "successful\n");\r\nreturn 0;\r\n}\r\nstatic int __find_plane_by_offset(struct vb2_queue *q, unsigned long off,\r\nunsigned int *_buffer, unsigned int *_plane)\r\n{\r\nstruct vb2_buffer *vb;\r\nunsigned int buffer, plane;\r\nfor (buffer = 0; buffer < q->num_buffers; ++buffer) {\r\nvb = q->bufs[buffer];\r\nfor (plane = 0; plane < vb->num_planes; ++plane) {\r\nif (vb->planes[plane].m.offset == off) {\r\n*_buffer = buffer;\r\n*_plane = plane;\r\nreturn 0;\r\n}\r\n}\r\n}\r\nreturn -EINVAL;\r\n}\r\nint vb2_core_expbuf(struct vb2_queue *q, int *fd, unsigned int type,\r\nunsigned int index, unsigned int plane, unsigned int flags)\r\n{\r\nstruct vb2_buffer *vb = NULL;\r\nstruct vb2_plane *vb_plane;\r\nint ret;\r\nstruct dma_buf *dbuf;\r\nif (q->memory != VB2_MEMORY_MMAP) {\r\ndprintk(1, "queue is not currently set up for mmap\n");\r\nreturn -EINVAL;\r\n}\r\nif (!q->mem_ops->get_dmabuf) {\r\ndprintk(1, "queue does not support DMA buffer exporting\n");\r\nreturn -EINVAL;\r\n}\r\nif (flags & ~(O_CLOEXEC | O_ACCMODE)) {\r\ndprintk(1, "queue does support only O_CLOEXEC and access mode flags\n");\r\nreturn -EINVAL;\r\n}\r\nif (type != q->type) {\r\ndprintk(1, "invalid buffer type\n");\r\nreturn -EINVAL;\r\n}\r\nif (index >= q->num_buffers) {\r\ndprintk(1, "buffer index out of range\n");\r\nreturn -EINVAL;\r\n}\r\nvb = q->bufs[index];\r\nif (plane >= vb->num_planes) {\r\ndprintk(1, "buffer plane out of range\n");\r\nreturn -EINVAL;\r\n}\r\nif (vb2_fileio_is_active(q)) {\r\ndprintk(1, "expbuf: file io in progress\n");\r\nreturn -EBUSY;\r\n}\r\nvb_plane = &vb->planes[plane];\r\ndbuf = call_ptr_memop(vb, get_dmabuf, vb_plane->mem_priv,\r\nflags & O_ACCMODE);\r\nif (IS_ERR_OR_NULL(dbuf)) {\r\ndprintk(1, "failed to export buffer %d, plane %d\n",\r\nindex, plane);\r\nreturn -EINVAL;\r\n}\r\nret = dma_buf_fd(dbuf, flags & ~O_ACCMODE);\r\nif (ret < 0) {\r\ndprintk(3, "buffer %d, plane %d failed to export (%d)\n",\r\nindex, plane, ret);\r\ndma_buf_put(dbuf);\r\nreturn ret;\r\n}\r\ndprintk(3, "buffer %d, plane %d exported as %d descriptor\n",\r\nindex, plane, ret);\r\n*fd = ret;\r\nreturn 0;\r\n}\r\nint vb2_mmap(struct vb2_queue *q, struct vm_area_struct *vma)\r\n{\r\nunsigned long off = vma->vm_pgoff << PAGE_SHIFT;\r\nstruct vb2_buffer *vb;\r\nunsigned int buffer = 0, plane = 0;\r\nint ret;\r\nunsigned long length;\r\nif (q->memory != VB2_MEMORY_MMAP) {\r\ndprintk(1, "queue is not currently set up for mmap\n");\r\nreturn -EINVAL;\r\n}\r\nif (!(vma->vm_flags & VM_SHARED)) {\r\ndprintk(1, "invalid vma flags, VM_SHARED needed\n");\r\nreturn -EINVAL;\r\n}\r\nif (q->is_output) {\r\nif (!(vma->vm_flags & VM_WRITE)) {\r\ndprintk(1, "invalid vma flags, VM_WRITE needed\n");\r\nreturn -EINVAL;\r\n}\r\n} else {\r\nif (!(vma->vm_flags & VM_READ)) {\r\ndprintk(1, "invalid vma flags, VM_READ needed\n");\r\nreturn -EINVAL;\r\n}\r\n}\r\nif (vb2_fileio_is_active(q)) {\r\ndprintk(1, "mmap: file io in progress\n");\r\nreturn -EBUSY;\r\n}\r\nret = __find_plane_by_offset(q, off, &buffer, &plane);\r\nif (ret)\r\nreturn ret;\r\nvb = q->bufs[buffer];\r\nlength = PAGE_ALIGN(vb->planes[plane].length);\r\nif (length < (vma->vm_end - vma->vm_start)) {\r\ndprintk(1,\r\n"MMAP invalid, as it would overflow buffer length\n");\r\nreturn -EINVAL;\r\n}\r\nmutex_lock(&q->mmap_lock);\r\nret = call_memop(vb, mmap, vb->planes[plane].mem_priv, vma);\r\nmutex_unlock(&q->mmap_lock);\r\nif (ret)\r\nreturn ret;\r\ndprintk(3, "buffer %d, plane %d successfully mapped\n", buffer, plane);\r\nreturn 0;\r\n}\r\nunsigned long vb2_get_unmapped_area(struct vb2_queue *q,\r\nunsigned long addr,\r\nunsigned long len,\r\nunsigned long pgoff,\r\nunsigned long flags)\r\n{\r\nunsigned long off = pgoff << PAGE_SHIFT;\r\nstruct vb2_buffer *vb;\r\nunsigned int buffer, plane;\r\nvoid *vaddr;\r\nint ret;\r\nif (q->memory != VB2_MEMORY_MMAP) {\r\ndprintk(1, "queue is not currently set up for mmap\n");\r\nreturn -EINVAL;\r\n}\r\nret = __find_plane_by_offset(q, off, &buffer, &plane);\r\nif (ret)\r\nreturn ret;\r\nvb = q->bufs[buffer];\r\nvaddr = vb2_plane_vaddr(vb, plane);\r\nreturn vaddr ? (unsigned long)vaddr : -EINVAL;\r\n}\r\nint vb2_core_queue_init(struct vb2_queue *q)\r\n{\r\nif (WARN_ON(!q) ||\r\nWARN_ON(!q->ops) ||\r\nWARN_ON(!q->mem_ops) ||\r\nWARN_ON(!q->type) ||\r\nWARN_ON(!q->io_modes) ||\r\nWARN_ON(!q->ops->queue_setup) ||\r\nWARN_ON(!q->ops->buf_queue))\r\nreturn -EINVAL;\r\nINIT_LIST_HEAD(&q->queued_list);\r\nINIT_LIST_HEAD(&q->done_list);\r\nspin_lock_init(&q->done_lock);\r\nmutex_init(&q->mmap_lock);\r\ninit_waitqueue_head(&q->done_wq);\r\nif (q->buf_struct_size == 0)\r\nq->buf_struct_size = sizeof(struct vb2_buffer);\r\nreturn 0;\r\n}\r\nvoid vb2_core_queue_release(struct vb2_queue *q)\r\n{\r\n__vb2_cleanup_fileio(q);\r\n__vb2_queue_cancel(q);\r\nmutex_lock(&q->mmap_lock);\r\n__vb2_queue_free(q, q->num_buffers);\r\nmutex_unlock(&q->mmap_lock);\r\n}\r\nunsigned int vb2_core_poll(struct vb2_queue *q, struct file *file,\r\npoll_table *wait)\r\n{\r\nunsigned long req_events = poll_requested_events(wait);\r\nstruct vb2_buffer *vb = NULL;\r\nunsigned long flags;\r\nif (!q->is_output && !(req_events & (POLLIN | POLLRDNORM)))\r\nreturn 0;\r\nif (q->is_output && !(req_events & (POLLOUT | POLLWRNORM)))\r\nreturn 0;\r\nif (q->num_buffers == 0 && !vb2_fileio_is_active(q)) {\r\nif (!q->is_output && (q->io_modes & VB2_READ) &&\r\n(req_events & (POLLIN | POLLRDNORM))) {\r\nif (__vb2_init_fileio(q, 1))\r\nreturn POLLERR;\r\n}\r\nif (q->is_output && (q->io_modes & VB2_WRITE) &&\r\n(req_events & (POLLOUT | POLLWRNORM))) {\r\nif (__vb2_init_fileio(q, 0))\r\nreturn POLLERR;\r\nreturn POLLOUT | POLLWRNORM;\r\n}\r\n}\r\nif (!vb2_is_streaming(q) || q->error)\r\nreturn POLLERR;\r\nif (q->quirk_poll_must_check_waiting_for_buffers &&\r\nq->waiting_for_buffers && (req_events & (POLLIN | POLLRDNORM)))\r\nreturn POLLERR;\r\nif (q->is_output && q->fileio && q->queued_count < q->num_buffers)\r\nreturn POLLOUT | POLLWRNORM;\r\nif (list_empty(&q->done_list)) {\r\nif (q->last_buffer_dequeued)\r\nreturn POLLIN | POLLRDNORM;\r\npoll_wait(file, &q->done_wq, wait);\r\n}\r\nspin_lock_irqsave(&q->done_lock, flags);\r\nif (!list_empty(&q->done_list))\r\nvb = list_first_entry(&q->done_list, struct vb2_buffer,\r\ndone_entry);\r\nspin_unlock_irqrestore(&q->done_lock, flags);\r\nif (vb && (vb->state == VB2_BUF_STATE_DONE\r\n|| vb->state == VB2_BUF_STATE_ERROR)) {\r\nreturn (q->is_output) ?\r\nPOLLOUT | POLLWRNORM :\r\nPOLLIN | POLLRDNORM;\r\n}\r\nreturn 0;\r\n}\r\nstatic int __vb2_init_fileio(struct vb2_queue *q, int read)\r\n{\r\nstruct vb2_fileio_data *fileio;\r\nint i, ret;\r\nunsigned int count = 0;\r\nif (WARN_ON((read && !(q->io_modes & VB2_READ)) ||\r\n(!read && !(q->io_modes & VB2_WRITE))))\r\nreturn -EINVAL;\r\nif (!q->mem_ops->vaddr)\r\nreturn -EBUSY;\r\nif (q->streaming || q->num_buffers > 0)\r\nreturn -EBUSY;\r\ncount = 1;\r\ndprintk(3, "setting up file io: mode %s, count %d, read_once %d, write_immediately %d\n",\r\n(read) ? "read" : "write", count, q->fileio_read_once,\r\nq->fileio_write_immediately);\r\nfileio = kzalloc(sizeof(*fileio), GFP_KERNEL);\r\nif (fileio == NULL)\r\nreturn -ENOMEM;\r\nfileio->read_once = q->fileio_read_once;\r\nfileio->write_immediately = q->fileio_write_immediately;\r\nfileio->count = count;\r\nfileio->memory = VB2_MEMORY_MMAP;\r\nfileio->type = q->type;\r\nq->fileio = fileio;\r\nret = vb2_core_reqbufs(q, fileio->memory, &fileio->count);\r\nif (ret)\r\ngoto err_kfree;\r\nif (q->bufs[0]->num_planes != 1) {\r\nret = -EBUSY;\r\ngoto err_reqbufs;\r\n}\r\nfor (i = 0; i < q->num_buffers; i++) {\r\nfileio->bufs[i].vaddr = vb2_plane_vaddr(q->bufs[i], 0);\r\nif (fileio->bufs[i].vaddr == NULL) {\r\nret = -EINVAL;\r\ngoto err_reqbufs;\r\n}\r\nfileio->bufs[i].size = vb2_plane_size(q->bufs[i], 0);\r\n}\r\nif (read) {\r\nfor (i = 0; i < q->num_buffers; i++) {\r\nret = vb2_core_qbuf(q, i, NULL);\r\nif (ret)\r\ngoto err_reqbufs;\r\nfileio->bufs[i].queued = 1;\r\n}\r\nfileio->initial_index = q->num_buffers;\r\nfileio->cur_index = q->num_buffers;\r\n}\r\nret = vb2_core_streamon(q, q->type);\r\nif (ret)\r\ngoto err_reqbufs;\r\nreturn ret;\r\nerr_reqbufs:\r\nfileio->count = 0;\r\nvb2_core_reqbufs(q, fileio->memory, &fileio->count);\r\nerr_kfree:\r\nq->fileio = NULL;\r\nkfree(fileio);\r\nreturn ret;\r\n}\r\nstatic int __vb2_cleanup_fileio(struct vb2_queue *q)\r\n{\r\nstruct vb2_fileio_data *fileio = q->fileio;\r\nif (fileio) {\r\nvb2_core_streamoff(q, q->type);\r\nq->fileio = NULL;\r\nfileio->count = 0;\r\nvb2_core_reqbufs(q, fileio->memory, &fileio->count);\r\nkfree(fileio);\r\ndprintk(3, "file io emulator closed\n");\r\n}\r\nreturn 0;\r\n}\r\nstatic size_t __vb2_perform_fileio(struct vb2_queue *q, char __user *data, size_t count,\r\nloff_t *ppos, int nonblock, int read)\r\n{\r\nstruct vb2_fileio_data *fileio;\r\nstruct vb2_fileio_buf *buf;\r\nbool is_multiplanar = q->is_multiplanar;\r\nbool copy_timestamp = !read && q->copy_timestamp;\r\nunsigned index;\r\nint ret;\r\ndprintk(3, "mode %s, offset %ld, count %zd, %sblocking\n",\r\nread ? "read" : "write", (long)*ppos, count,\r\nnonblock ? "non" : "");\r\nif (!data)\r\nreturn -EINVAL;\r\nif (!vb2_fileio_is_active(q)) {\r\nret = __vb2_init_fileio(q, read);\r\ndprintk(3, "vb2_init_fileio result: %d\n", ret);\r\nif (ret)\r\nreturn ret;\r\n}\r\nfileio = q->fileio;\r\nindex = fileio->cur_index;\r\nif (index >= q->num_buffers) {\r\nstruct vb2_buffer *b;\r\nret = vb2_core_dqbuf(q, &index, NULL, nonblock);\r\ndprintk(5, "vb2_dqbuf result: %d\n", ret);\r\nif (ret)\r\nreturn ret;\r\nfileio->dq_count += 1;\r\nfileio->cur_index = index;\r\nbuf = &fileio->bufs[index];\r\nb = q->bufs[index];\r\nbuf->pos = 0;\r\nbuf->queued = 0;\r\nbuf->size = read ? vb2_get_plane_payload(q->bufs[index], 0)\r\n: vb2_plane_size(q->bufs[index], 0);\r\nif (is_multiplanar && read &&\r\nb->planes[0].data_offset < buf->size) {\r\nbuf->pos = b->planes[0].data_offset;\r\nbuf->size -= buf->pos;\r\n}\r\n} else {\r\nbuf = &fileio->bufs[index];\r\n}\r\nif (buf->pos + count > buf->size) {\r\ncount = buf->size - buf->pos;\r\ndprintk(5, "reducing read count: %zd\n", count);\r\n}\r\ndprintk(3, "copying %zd bytes - buffer %d, offset %u\n",\r\ncount, index, buf->pos);\r\nif (read)\r\nret = copy_to_user(data, buf->vaddr + buf->pos, count);\r\nelse\r\nret = copy_from_user(buf->vaddr + buf->pos, data, count);\r\nif (ret) {\r\ndprintk(3, "error copying data\n");\r\nreturn -EFAULT;\r\n}\r\nbuf->pos += count;\r\n*ppos += count;\r\nif (buf->pos == buf->size || (!read && fileio->write_immediately)) {\r\nstruct vb2_buffer *b = q->bufs[index];\r\nif (read && fileio->read_once && fileio->dq_count == 1) {\r\ndprintk(3, "read limit reached\n");\r\nreturn __vb2_cleanup_fileio(q);\r\n}\r\nb->planes[0].bytesused = buf->pos;\r\nif (copy_timestamp)\r\nb->timestamp = ktime_get_ns();\r\nret = vb2_core_qbuf(q, index, NULL);\r\ndprintk(5, "vb2_dbuf result: %d\n", ret);\r\nif (ret)\r\nreturn ret;\r\nbuf->pos = 0;\r\nbuf->queued = 1;\r\nbuf->size = vb2_plane_size(q->bufs[index], 0);\r\nfileio->q_count += 1;\r\nif (fileio->initial_index < q->num_buffers)\r\nfileio->initial_index++;\r\nfileio->cur_index = fileio->initial_index;\r\n}\r\nif (ret == 0)\r\nret = count;\r\nreturn ret;\r\n}\r\nsize_t vb2_read(struct vb2_queue *q, char __user *data, size_t count,\r\nloff_t *ppos, int nonblocking)\r\n{\r\nreturn __vb2_perform_fileio(q, data, count, ppos, nonblocking, 1);\r\n}\r\nsize_t vb2_write(struct vb2_queue *q, const char __user *data, size_t count,\r\nloff_t *ppos, int nonblocking)\r\n{\r\nreturn __vb2_perform_fileio(q, (char __user *) data, count,\r\nppos, nonblocking, 0);\r\n}\r\nstatic int vb2_thread(void *data)\r\n{\r\nstruct vb2_queue *q = data;\r\nstruct vb2_threadio_data *threadio = q->threadio;\r\nbool copy_timestamp = false;\r\nunsigned prequeue = 0;\r\nunsigned index = 0;\r\nint ret = 0;\r\nif (q->is_output) {\r\nprequeue = q->num_buffers;\r\ncopy_timestamp = q->copy_timestamp;\r\n}\r\nset_freezable();\r\nfor (;;) {\r\nstruct vb2_buffer *vb;\r\nif (prequeue) {\r\nvb = q->bufs[index++];\r\nprequeue--;\r\n} else {\r\ncall_void_qop(q, wait_finish, q);\r\nif (!threadio->stop)\r\nret = vb2_core_dqbuf(q, &index, NULL, 0);\r\ncall_void_qop(q, wait_prepare, q);\r\ndprintk(5, "file io: vb2_dqbuf result: %d\n", ret);\r\nif (!ret)\r\nvb = q->bufs[index];\r\n}\r\nif (ret || threadio->stop)\r\nbreak;\r\ntry_to_freeze();\r\nif (vb->state != VB2_BUF_STATE_ERROR)\r\nif (threadio->fnc(vb, threadio->priv))\r\nbreak;\r\ncall_void_qop(q, wait_finish, q);\r\nif (copy_timestamp)\r\nvb->timestamp = ktime_get_ns();;\r\nif (!threadio->stop)\r\nret = vb2_core_qbuf(q, vb->index, NULL);\r\ncall_void_qop(q, wait_prepare, q);\r\nif (ret || threadio->stop)\r\nbreak;\r\n}\r\nwhile (!kthread_should_stop()) {\r\nset_current_state(TASK_INTERRUPTIBLE);\r\nschedule();\r\n}\r\nreturn 0;\r\n}\r\nint vb2_thread_start(struct vb2_queue *q, vb2_thread_fnc fnc, void *priv,\r\nconst char *thread_name)\r\n{\r\nstruct vb2_threadio_data *threadio;\r\nint ret = 0;\r\nif (q->threadio)\r\nreturn -EBUSY;\r\nif (vb2_is_busy(q))\r\nreturn -EBUSY;\r\nif (WARN_ON(q->fileio))\r\nreturn -EBUSY;\r\nthreadio = kzalloc(sizeof(*threadio), GFP_KERNEL);\r\nif (threadio == NULL)\r\nreturn -ENOMEM;\r\nthreadio->fnc = fnc;\r\nthreadio->priv = priv;\r\nret = __vb2_init_fileio(q, !q->is_output);\r\ndprintk(3, "file io: vb2_init_fileio result: %d\n", ret);\r\nif (ret)\r\ngoto nomem;\r\nq->threadio = threadio;\r\nthreadio->thread = kthread_run(vb2_thread, q, "vb2-%s", thread_name);\r\nif (IS_ERR(threadio->thread)) {\r\nret = PTR_ERR(threadio->thread);\r\nthreadio->thread = NULL;\r\ngoto nothread;\r\n}\r\nreturn 0;\r\nnothread:\r\n__vb2_cleanup_fileio(q);\r\nnomem:\r\nkfree(threadio);\r\nreturn ret;\r\n}\r\nint vb2_thread_stop(struct vb2_queue *q)\r\n{\r\nstruct vb2_threadio_data *threadio = q->threadio;\r\nint err;\r\nif (threadio == NULL)\r\nreturn 0;\r\nthreadio->stop = true;\r\nvb2_queue_error(q);\r\nerr = kthread_stop(threadio->thread);\r\n__vb2_cleanup_fileio(q);\r\nthreadio->thread = NULL;\r\nkfree(threadio);\r\nq->threadio = NULL;\r\nreturn err;\r\n}
