static int __init setup_cede_offline(char *str)\r\n{\r\nreturn (kstrtobool(str, &cede_offline_enabled) == 0);\r\n}\r\nenum cpu_state_vals get_cpu_current_state(int cpu)\r\n{\r\nreturn per_cpu(current_state, cpu);\r\n}\r\nvoid set_cpu_current_state(int cpu, enum cpu_state_vals state)\r\n{\r\nper_cpu(current_state, cpu) = state;\r\n}\r\nenum cpu_state_vals get_preferred_offline_state(int cpu)\r\n{\r\nreturn per_cpu(preferred_offline_state, cpu);\r\n}\r\nvoid set_preferred_offline_state(int cpu, enum cpu_state_vals state)\r\n{\r\nper_cpu(preferred_offline_state, cpu) = state;\r\n}\r\nvoid set_default_offline_state(int cpu)\r\n{\r\nper_cpu(preferred_offline_state, cpu) = default_offline_state;\r\n}\r\nstatic void rtas_stop_self(void)\r\n{\r\nstatic struct rtas_args args;\r\nlocal_irq_disable();\r\nBUG_ON(rtas_stop_self_token == RTAS_UNKNOWN_SERVICE);\r\nprintk("cpu %u (hwid %u) Ready to die...\n",\r\nsmp_processor_id(), hard_smp_processor_id());\r\nrtas_call_unlocked(&args, rtas_stop_self_token, 0, 1, NULL);\r\npanic("Alas, I survived.\n");\r\n}\r\nstatic void pseries_mach_cpu_die(void)\r\n{\r\nunsigned int cpu = smp_processor_id();\r\nunsigned int hwcpu = hard_smp_processor_id();\r\nu8 cede_latency_hint = 0;\r\nlocal_irq_disable();\r\nidle_task_exit();\r\nxics_teardown_cpu();\r\nif (get_preferred_offline_state(cpu) == CPU_STATE_INACTIVE) {\r\nset_cpu_current_state(cpu, CPU_STATE_INACTIVE);\r\nif (ppc_md.suspend_disable_cpu)\r\nppc_md.suspend_disable_cpu();\r\ncede_latency_hint = 2;\r\nget_lppaca()->idle = 1;\r\nif (!lppaca_shared_proc(get_lppaca()))\r\nget_lppaca()->donate_dedicated_cpu = 1;\r\nwhile (get_preferred_offline_state(cpu) == CPU_STATE_INACTIVE) {\r\nwhile (!prep_irq_for_idle()) {\r\nlocal_irq_enable();\r\nlocal_irq_disable();\r\n}\r\nextended_cede_processor(cede_latency_hint);\r\n}\r\nlocal_irq_disable();\r\nif (!lppaca_shared_proc(get_lppaca()))\r\nget_lppaca()->donate_dedicated_cpu = 0;\r\nget_lppaca()->idle = 0;\r\nif (get_preferred_offline_state(cpu) == CPU_STATE_ONLINE) {\r\nunregister_slb_shadow(hwcpu);\r\nhard_irq_disable();\r\nstart_secondary_resume();\r\n}\r\n}\r\nWARN_ON(get_preferred_offline_state(cpu) != CPU_STATE_OFFLINE);\r\nset_cpu_current_state(cpu, CPU_STATE_OFFLINE);\r\nunregister_slb_shadow(hwcpu);\r\nrtas_stop_self();\r\nBUG();\r\nfor(;;);\r\n}\r\nstatic int pseries_cpu_disable(void)\r\n{\r\nint cpu = smp_processor_id();\r\nset_cpu_online(cpu, false);\r\nvdso_data->processorCount--;\r\nif (cpu == boot_cpuid)\r\nboot_cpuid = cpumask_any(cpu_online_mask);\r\nxics_migrate_irqs_away();\r\nreturn 0;\r\n}\r\nstatic void pseries_cpu_die(unsigned int cpu)\r\n{\r\nint tries;\r\nint cpu_status = 1;\r\nunsigned int pcpu = get_hard_smp_processor_id(cpu);\r\nif (get_preferred_offline_state(cpu) == CPU_STATE_INACTIVE) {\r\ncpu_status = 1;\r\nfor (tries = 0; tries < 5000; tries++) {\r\nif (get_cpu_current_state(cpu) == CPU_STATE_INACTIVE) {\r\ncpu_status = 0;\r\nbreak;\r\n}\r\nmsleep(1);\r\n}\r\n} else if (get_preferred_offline_state(cpu) == CPU_STATE_OFFLINE) {\r\nfor (tries = 0; tries < 25; tries++) {\r\ncpu_status = smp_query_cpu_stopped(pcpu);\r\nif (cpu_status == QCSS_STOPPED ||\r\ncpu_status == QCSS_HARDWARE_ERROR)\r\nbreak;\r\ncpu_relax();\r\n}\r\n}\r\nif (cpu_status != 0) {\r\nprintk("Querying DEAD? cpu %i (%i) shows %i\n",\r\ncpu, pcpu, cpu_status);\r\n}\r\npaca[cpu].cpu_start = 0;\r\n}\r\nstatic int pseries_add_processor(struct device_node *np)\r\n{\r\nunsigned int cpu;\r\ncpumask_var_t candidate_mask, tmp;\r\nint err = -ENOSPC, len, nthreads, i;\r\nconst __be32 *intserv;\r\nintserv = of_get_property(np, "ibm,ppc-interrupt-server#s", &len);\r\nif (!intserv)\r\nreturn 0;\r\nzalloc_cpumask_var(&candidate_mask, GFP_KERNEL);\r\nzalloc_cpumask_var(&tmp, GFP_KERNEL);\r\nnthreads = len / sizeof(u32);\r\nfor (i = 0; i < nthreads; i++)\r\ncpumask_set_cpu(i, tmp);\r\ncpu_maps_update_begin();\r\nBUG_ON(!cpumask_subset(cpu_present_mask, cpu_possible_mask));\r\ncpumask_xor(candidate_mask, cpu_possible_mask, cpu_present_mask);\r\nif (cpumask_empty(candidate_mask)) {\r\nprintk(KERN_ERR "Cannot add cpu %s; this system configuration"\r\n" supports %d logical cpus.\n", np->full_name,\r\nnum_possible_cpus());\r\ngoto out_unlock;\r\n}\r\nwhile (!cpumask_empty(tmp))\r\nif (cpumask_subset(tmp, candidate_mask))\r\nbreak;\r\nelse\r\ncpumask_shift_left(tmp, tmp, nthreads);\r\nif (cpumask_empty(tmp)) {\r\nprintk(KERN_ERR "Unable to find space in cpu_present_mask for"\r\n" processor %s with %d thread(s)\n", np->name,\r\nnthreads);\r\ngoto out_unlock;\r\n}\r\nfor_each_cpu(cpu, tmp) {\r\nBUG_ON(cpu_present(cpu));\r\nset_cpu_present(cpu, true);\r\nset_hard_smp_processor_id(cpu, be32_to_cpu(*intserv++));\r\n}\r\nerr = 0;\r\nout_unlock:\r\ncpu_maps_update_done();\r\nfree_cpumask_var(candidate_mask);\r\nfree_cpumask_var(tmp);\r\nreturn err;\r\n}\r\nstatic void pseries_remove_processor(struct device_node *np)\r\n{\r\nunsigned int cpu;\r\nint len, nthreads, i;\r\nconst __be32 *intserv;\r\nu32 thread;\r\nintserv = of_get_property(np, "ibm,ppc-interrupt-server#s", &len);\r\nif (!intserv)\r\nreturn;\r\nnthreads = len / sizeof(u32);\r\ncpu_maps_update_begin();\r\nfor (i = 0; i < nthreads; i++) {\r\nthread = be32_to_cpu(intserv[i]);\r\nfor_each_present_cpu(cpu) {\r\nif (get_hard_smp_processor_id(cpu) != thread)\r\ncontinue;\r\nBUG_ON(cpu_online(cpu));\r\nset_cpu_present(cpu, false);\r\nset_hard_smp_processor_id(cpu, -1);\r\nbreak;\r\n}\r\nif (cpu >= nr_cpu_ids)\r\nprintk(KERN_WARNING "Could not find cpu to remove "\r\n"with physical id 0x%x\n", thread);\r\n}\r\ncpu_maps_update_done();\r\n}\r\nstatic int dlpar_online_cpu(struct device_node *dn)\r\n{\r\nint rc = 0;\r\nunsigned int cpu;\r\nint len, nthreads, i;\r\nconst __be32 *intserv;\r\nu32 thread;\r\nintserv = of_get_property(dn, "ibm,ppc-interrupt-server#s", &len);\r\nif (!intserv)\r\nreturn -EINVAL;\r\nnthreads = len / sizeof(u32);\r\ncpu_maps_update_begin();\r\nfor (i = 0; i < nthreads; i++) {\r\nthread = be32_to_cpu(intserv[i]);\r\nfor_each_present_cpu(cpu) {\r\nif (get_hard_smp_processor_id(cpu) != thread)\r\ncontinue;\r\nBUG_ON(get_cpu_current_state(cpu)\r\n!= CPU_STATE_OFFLINE);\r\ncpu_maps_update_done();\r\nrc = device_online(get_cpu_device(cpu));\r\nif (rc)\r\ngoto out;\r\ncpu_maps_update_begin();\r\nbreak;\r\n}\r\nif (cpu == num_possible_cpus())\r\nprintk(KERN_WARNING "Could not find cpu to online "\r\n"with physical id 0x%x\n", thread);\r\n}\r\ncpu_maps_update_done();\r\nout:\r\nreturn rc;\r\n}\r\nstatic bool dlpar_cpu_exists(struct device_node *parent, u32 drc_index)\r\n{\r\nstruct device_node *child = NULL;\r\nu32 my_drc_index;\r\nbool found;\r\nint rc;\r\nfound = false;\r\nfor_each_child_of_node(parent, child) {\r\nrc = of_property_read_u32(child, "ibm,my-drc-index",\r\n&my_drc_index);\r\nif (rc)\r\ncontinue;\r\nif (my_drc_index == drc_index) {\r\nof_node_put(child);\r\nfound = true;\r\nbreak;\r\n}\r\n}\r\nreturn found;\r\n}\r\nstatic bool valid_cpu_drc_index(struct device_node *parent, u32 drc_index)\r\n{\r\nbool found = false;\r\nint rc, index;\r\nindex = 0;\r\nwhile (!found) {\r\nu32 drc;\r\nrc = of_property_read_u32_index(parent, "ibm,drc-indexes",\r\nindex++, &drc);\r\nif (rc)\r\nbreak;\r\nif (drc == drc_index)\r\nfound = true;\r\n}\r\nreturn found;\r\n}\r\nstatic ssize_t dlpar_cpu_add(u32 drc_index)\r\n{\r\nstruct device_node *dn, *parent;\r\nint rc, saved_rc;\r\npr_debug("Attempting to add CPU, drc index: %x\n", drc_index);\r\nparent = of_find_node_by_path("/cpus");\r\nif (!parent) {\r\npr_warn("Failed to find CPU root node \"/cpus\"\n");\r\nreturn -ENODEV;\r\n}\r\nif (dlpar_cpu_exists(parent, drc_index)) {\r\nof_node_put(parent);\r\npr_warn("CPU with drc index %x already exists\n", drc_index);\r\nreturn -EINVAL;\r\n}\r\nif (!valid_cpu_drc_index(parent, drc_index)) {\r\nof_node_put(parent);\r\npr_warn("Cannot find CPU (drc index %x) to add.\n", drc_index);\r\nreturn -EINVAL;\r\n}\r\nrc = dlpar_acquire_drc(drc_index);\r\nif (rc) {\r\npr_warn("Failed to acquire DRC, rc: %d, drc index: %x\n",\r\nrc, drc_index);\r\nof_node_put(parent);\r\nreturn -EINVAL;\r\n}\r\ndn = dlpar_configure_connector(cpu_to_be32(drc_index), parent);\r\nof_node_put(parent);\r\nif (!dn) {\r\npr_warn("Failed call to configure-connector, drc index: %x\n",\r\ndrc_index);\r\ndlpar_release_drc(drc_index);\r\nreturn -EINVAL;\r\n}\r\nrc = dlpar_attach_node(dn);\r\nif (rc) {\r\nsaved_rc = rc;\r\npr_warn("Failed to attach node %s, rc: %d, drc index: %x\n",\r\ndn->name, rc, drc_index);\r\nrc = dlpar_release_drc(drc_index);\r\nif (!rc)\r\ndlpar_free_cc_nodes(dn);\r\nreturn saved_rc;\r\n}\r\nrc = dlpar_online_cpu(dn);\r\nif (rc) {\r\nsaved_rc = rc;\r\npr_warn("Failed to online cpu %s, rc: %d, drc index: %x\n",\r\ndn->name, rc, drc_index);\r\nrc = dlpar_detach_node(dn);\r\nif (!rc)\r\ndlpar_release_drc(drc_index);\r\nreturn saved_rc;\r\n}\r\npr_debug("Successfully added CPU %s, drc index: %x\n", dn->name,\r\ndrc_index);\r\nreturn rc;\r\n}\r\nstatic int dlpar_offline_cpu(struct device_node *dn)\r\n{\r\nint rc = 0;\r\nunsigned int cpu;\r\nint len, nthreads, i;\r\nconst __be32 *intserv;\r\nu32 thread;\r\nintserv = of_get_property(dn, "ibm,ppc-interrupt-server#s", &len);\r\nif (!intserv)\r\nreturn -EINVAL;\r\nnthreads = len / sizeof(u32);\r\ncpu_maps_update_begin();\r\nfor (i = 0; i < nthreads; i++) {\r\nthread = be32_to_cpu(intserv[i]);\r\nfor_each_present_cpu(cpu) {\r\nif (get_hard_smp_processor_id(cpu) != thread)\r\ncontinue;\r\nif (get_cpu_current_state(cpu) == CPU_STATE_OFFLINE)\r\nbreak;\r\nif (get_cpu_current_state(cpu) == CPU_STATE_ONLINE) {\r\nset_preferred_offline_state(cpu,\r\nCPU_STATE_OFFLINE);\r\ncpu_maps_update_done();\r\nrc = device_offline(get_cpu_device(cpu));\r\nif (rc)\r\ngoto out;\r\ncpu_maps_update_begin();\r\nbreak;\r\n}\r\nset_preferred_offline_state(cpu, CPU_STATE_OFFLINE);\r\nBUG_ON(plpar_hcall_norets(H_PROD, thread)\r\n!= H_SUCCESS);\r\n__cpu_die(cpu);\r\nbreak;\r\n}\r\nif (cpu == num_possible_cpus())\r\nprintk(KERN_WARNING "Could not find cpu to offline with physical id 0x%x\n", thread);\r\n}\r\ncpu_maps_update_done();\r\nout:\r\nreturn rc;\r\n}\r\nstatic ssize_t dlpar_cpu_remove(struct device_node *dn, u32 drc_index)\r\n{\r\nint rc;\r\npr_debug("Attemping to remove CPU %s, drc index: %x\n",\r\ndn->name, drc_index);\r\nrc = dlpar_offline_cpu(dn);\r\nif (rc) {\r\npr_warn("Failed to offline CPU %s, rc: %d\n", dn->name, rc);\r\nreturn -EINVAL;\r\n}\r\nrc = dlpar_release_drc(drc_index);\r\nif (rc) {\r\npr_warn("Failed to release drc (%x) for CPU %s, rc: %d\n",\r\ndrc_index, dn->name, rc);\r\ndlpar_online_cpu(dn);\r\nreturn rc;\r\n}\r\nrc = dlpar_detach_node(dn);\r\nif (rc) {\r\nint saved_rc = rc;\r\npr_warn("Failed to detach CPU %s, rc: %d", dn->name, rc);\r\nrc = dlpar_acquire_drc(drc_index);\r\nif (!rc)\r\ndlpar_online_cpu(dn);\r\nreturn saved_rc;\r\n}\r\npr_debug("Successfully removed CPU, drc index: %x\n", drc_index);\r\nreturn 0;\r\n}\r\nstatic struct device_node *cpu_drc_index_to_dn(u32 drc_index)\r\n{\r\nstruct device_node *dn;\r\nu32 my_index;\r\nint rc;\r\nfor_each_node_by_type(dn, "cpu") {\r\nrc = of_property_read_u32(dn, "ibm,my-drc-index", &my_index);\r\nif (rc)\r\ncontinue;\r\nif (my_index == drc_index)\r\nbreak;\r\n}\r\nreturn dn;\r\n}\r\nstatic int dlpar_cpu_remove_by_index(u32 drc_index)\r\n{\r\nstruct device_node *dn;\r\nint rc;\r\ndn = cpu_drc_index_to_dn(drc_index);\r\nif (!dn) {\r\npr_warn("Cannot find CPU (drc index %x) to remove\n",\r\ndrc_index);\r\nreturn -ENODEV;\r\n}\r\nrc = dlpar_cpu_remove(dn, drc_index);\r\nof_node_put(dn);\r\nreturn rc;\r\n}\r\nstatic int find_dlpar_cpus_to_remove(u32 *cpu_drcs, int cpus_to_remove)\r\n{\r\nstruct device_node *dn;\r\nint cpus_found = 0;\r\nint rc;\r\nfor_each_node_by_type(dn, "cpu") {\r\ncpus_found++;\r\nif (cpus_found > cpus_to_remove) {\r\nof_node_put(dn);\r\nbreak;\r\n}\r\nrc = of_property_read_u32(dn, "ibm,my-drc-index",\r\n&cpu_drcs[cpus_found - 1]);\r\nif (rc) {\r\npr_warn("Error occurred getting drc-index for %s\n",\r\ndn->name);\r\nof_node_put(dn);\r\nreturn -1;\r\n}\r\n}\r\nif (cpus_found < cpus_to_remove) {\r\npr_warn("Failed to find enough CPUs (%d of %d) to remove\n",\r\ncpus_found, cpus_to_remove);\r\n} else if (cpus_found == cpus_to_remove) {\r\npr_warn("Cannot remove all CPUs\n");\r\n}\r\nreturn cpus_found;\r\n}\r\nstatic int dlpar_cpu_remove_by_count(u32 cpus_to_remove)\r\n{\r\nu32 *cpu_drcs;\r\nint cpus_found;\r\nint cpus_removed = 0;\r\nint i, rc;\r\npr_debug("Attempting to hot-remove %d CPUs\n", cpus_to_remove);\r\ncpu_drcs = kcalloc(cpus_to_remove, sizeof(*cpu_drcs), GFP_KERNEL);\r\nif (!cpu_drcs)\r\nreturn -EINVAL;\r\ncpus_found = find_dlpar_cpus_to_remove(cpu_drcs, cpus_to_remove);\r\nif (cpus_found <= cpus_to_remove) {\r\nkfree(cpu_drcs);\r\nreturn -EINVAL;\r\n}\r\nfor (i = 0; i < cpus_to_remove; i++) {\r\nrc = dlpar_cpu_remove_by_index(cpu_drcs[i]);\r\nif (rc)\r\nbreak;\r\ncpus_removed++;\r\n}\r\nif (cpus_removed != cpus_to_remove) {\r\npr_warn("CPU hot-remove failed, adding back removed CPUs\n");\r\nfor (i = 0; i < cpus_removed; i++)\r\ndlpar_cpu_add(cpu_drcs[i]);\r\nrc = -EINVAL;\r\n} else {\r\nrc = 0;\r\n}\r\nkfree(cpu_drcs);\r\nreturn rc;\r\n}\r\nstatic int find_dlpar_cpus_to_add(u32 *cpu_drcs, u32 cpus_to_add)\r\n{\r\nstruct device_node *parent;\r\nint cpus_found = 0;\r\nint index, rc;\r\nparent = of_find_node_by_path("/cpus");\r\nif (!parent) {\r\npr_warn("Could not find CPU root node in device tree\n");\r\nkfree(cpu_drcs);\r\nreturn -1;\r\n}\r\nindex = 1;\r\nwhile (cpus_found < cpus_to_add) {\r\nu32 drc;\r\nrc = of_property_read_u32_index(parent, "ibm,drc-indexes",\r\nindex++, &drc);\r\nif (rc)\r\nbreak;\r\nif (dlpar_cpu_exists(parent, drc))\r\ncontinue;\r\ncpu_drcs[cpus_found++] = drc;\r\n}\r\nof_node_put(parent);\r\nreturn cpus_found;\r\n}\r\nstatic int dlpar_cpu_add_by_count(u32 cpus_to_add)\r\n{\r\nu32 *cpu_drcs;\r\nint cpus_added = 0;\r\nint cpus_found;\r\nint i, rc;\r\npr_debug("Attempting to hot-add %d CPUs\n", cpus_to_add);\r\ncpu_drcs = kcalloc(cpus_to_add, sizeof(*cpu_drcs), GFP_KERNEL);\r\nif (!cpu_drcs)\r\nreturn -EINVAL;\r\ncpus_found = find_dlpar_cpus_to_add(cpu_drcs, cpus_to_add);\r\nif (cpus_found < cpus_to_add) {\r\npr_warn("Failed to find enough CPUs (%d of %d) to add\n",\r\ncpus_found, cpus_to_add);\r\nkfree(cpu_drcs);\r\nreturn -EINVAL;\r\n}\r\nfor (i = 0; i < cpus_to_add; i++) {\r\nrc = dlpar_cpu_add(cpu_drcs[i]);\r\nif (rc)\r\nbreak;\r\ncpus_added++;\r\n}\r\nif (cpus_added < cpus_to_add) {\r\npr_warn("CPU hot-add failed, removing any added CPUs\n");\r\nfor (i = 0; i < cpus_added; i++)\r\ndlpar_cpu_remove_by_index(cpu_drcs[i]);\r\nrc = -EINVAL;\r\n} else {\r\nrc = 0;\r\n}\r\nkfree(cpu_drcs);\r\nreturn rc;\r\n}\r\nint dlpar_cpu(struct pseries_hp_errorlog *hp_elog)\r\n{\r\nu32 count, drc_index;\r\nint rc;\r\ncount = hp_elog->_drc_u.drc_count;\r\ndrc_index = hp_elog->_drc_u.drc_index;\r\nlock_device_hotplug();\r\nswitch (hp_elog->action) {\r\ncase PSERIES_HP_ELOG_ACTION_REMOVE:\r\nif (hp_elog->id_type == PSERIES_HP_ELOG_ID_DRC_COUNT)\r\nrc = dlpar_cpu_remove_by_count(count);\r\nelse if (hp_elog->id_type == PSERIES_HP_ELOG_ID_DRC_INDEX)\r\nrc = dlpar_cpu_remove_by_index(drc_index);\r\nelse\r\nrc = -EINVAL;\r\nbreak;\r\ncase PSERIES_HP_ELOG_ACTION_ADD:\r\nif (hp_elog->id_type == PSERIES_HP_ELOG_ID_DRC_COUNT)\r\nrc = dlpar_cpu_add_by_count(count);\r\nelse if (hp_elog->id_type == PSERIES_HP_ELOG_ID_DRC_INDEX)\r\nrc = dlpar_cpu_add(drc_index);\r\nelse\r\nrc = -EINVAL;\r\nbreak;\r\ndefault:\r\npr_err("Invalid action (%d) specified\n", hp_elog->action);\r\nrc = -EINVAL;\r\nbreak;\r\n}\r\nunlock_device_hotplug();\r\nreturn rc;\r\n}\r\nstatic ssize_t dlpar_cpu_probe(const char *buf, size_t count)\r\n{\r\nu32 drc_index;\r\nint rc;\r\nrc = kstrtou32(buf, 0, &drc_index);\r\nif (rc)\r\nreturn -EINVAL;\r\nrc = dlpar_cpu_add(drc_index);\r\nreturn rc ? rc : count;\r\n}\r\nstatic ssize_t dlpar_cpu_release(const char *buf, size_t count)\r\n{\r\nstruct device_node *dn;\r\nu32 drc_index;\r\nint rc;\r\ndn = of_find_node_by_path(buf);\r\nif (!dn)\r\nreturn -EINVAL;\r\nrc = of_property_read_u32(dn, "ibm,my-drc-index", &drc_index);\r\nif (rc) {\r\nof_node_put(dn);\r\nreturn -EINVAL;\r\n}\r\nrc = dlpar_cpu_remove(dn, drc_index);\r\nof_node_put(dn);\r\nreturn rc ? rc : count;\r\n}\r\nstatic int pseries_smp_notifier(struct notifier_block *nb,\r\nunsigned long action, void *data)\r\n{\r\nstruct of_reconfig_data *rd = data;\r\nint err = 0;\r\nswitch (action) {\r\ncase OF_RECONFIG_ATTACH_NODE:\r\nerr = pseries_add_processor(rd->dn);\r\nbreak;\r\ncase OF_RECONFIG_DETACH_NODE:\r\npseries_remove_processor(rd->dn);\r\nbreak;\r\n}\r\nreturn notifier_from_errno(err);\r\n}\r\nstatic int parse_cede_parameters(void)\r\n{\r\nmemset(cede_parameters, 0, CEDE_LATENCY_PARAM_MAX_LENGTH);\r\nreturn rtas_call(rtas_token("ibm,get-system-parameter"), 3, 1,\r\nNULL,\r\nCEDE_LATENCY_TOKEN,\r\n__pa(cede_parameters),\r\nCEDE_LATENCY_PARAM_MAX_LENGTH);\r\n}\r\nstatic int __init pseries_cpu_hotplug_init(void)\r\n{\r\nstruct device_node *np;\r\nconst char *typep;\r\nint cpu;\r\nint qcss_tok;\r\n#ifdef CONFIG_ARCH_CPU_PROBE_RELEASE\r\nppc_md.cpu_probe = dlpar_cpu_probe;\r\nppc_md.cpu_release = dlpar_cpu_release;\r\n#endif\r\nfor_each_node_by_name(np, "interrupt-controller") {\r\ntypep = of_get_property(np, "compatible", NULL);\r\nif (strstr(typep, "open-pic")) {\r\nof_node_put(np);\r\nprintk(KERN_INFO "CPU Hotplug not supported on "\r\n"systems using MPIC\n");\r\nreturn 0;\r\n}\r\n}\r\nrtas_stop_self_token = rtas_token("stop-self");\r\nqcss_tok = rtas_token("query-cpu-stopped-state");\r\nif (rtas_stop_self_token == RTAS_UNKNOWN_SERVICE ||\r\nqcss_tok == RTAS_UNKNOWN_SERVICE) {\r\nprintk(KERN_INFO "CPU Hotplug not supported by firmware "\r\n"- disabling.\n");\r\nreturn 0;\r\n}\r\nppc_md.cpu_die = pseries_mach_cpu_die;\r\nsmp_ops->cpu_disable = pseries_cpu_disable;\r\nsmp_ops->cpu_die = pseries_cpu_die;\r\nif (firmware_has_feature(FW_FEATURE_LPAR)) {\r\nof_reconfig_notifier_register(&pseries_smp_nb);\r\ncpu_maps_update_begin();\r\nif (cede_offline_enabled && parse_cede_parameters() == 0) {\r\ndefault_offline_state = CPU_STATE_INACTIVE;\r\nfor_each_online_cpu(cpu)\r\nset_default_offline_state(cpu);\r\n}\r\ncpu_maps_update_done();\r\n}\r\nreturn 0;\r\n}
