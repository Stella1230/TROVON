void enable_sched_clock_irqtime(void)\r\n{\r\nsched_clock_irqtime = 1;\r\n}\r\nvoid disable_sched_clock_irqtime(void)\r\n{\r\nsched_clock_irqtime = 0;\r\n}\r\nvoid irqtime_account_irq(struct task_struct *curr)\r\n{\r\nunsigned long flags;\r\ns64 delta;\r\nint cpu;\r\nif (!sched_clock_irqtime)\r\nreturn;\r\nlocal_irq_save(flags);\r\ncpu = smp_processor_id();\r\ndelta = sched_clock_cpu(cpu) - __this_cpu_read(irq_start_time);\r\n__this_cpu_add(irq_start_time, delta);\r\nirq_time_write_begin();\r\nif (hardirq_count())\r\n__this_cpu_add(cpu_hardirq_time, delta);\r\nelse if (in_serving_softirq() && curr != this_cpu_ksoftirqd())\r\n__this_cpu_add(cpu_softirq_time, delta);\r\nirq_time_write_end();\r\nlocal_irq_restore(flags);\r\n}\r\nstatic int irqtime_account_hi_update(void)\r\n{\r\nu64 *cpustat = kcpustat_this_cpu->cpustat;\r\nunsigned long flags;\r\nu64 latest_ns;\r\nint ret = 0;\r\nlocal_irq_save(flags);\r\nlatest_ns = this_cpu_read(cpu_hardirq_time);\r\nif (nsecs_to_cputime64(latest_ns) > cpustat[CPUTIME_IRQ])\r\nret = 1;\r\nlocal_irq_restore(flags);\r\nreturn ret;\r\n}\r\nstatic int irqtime_account_si_update(void)\r\n{\r\nu64 *cpustat = kcpustat_this_cpu->cpustat;\r\nunsigned long flags;\r\nu64 latest_ns;\r\nint ret = 0;\r\nlocal_irq_save(flags);\r\nlatest_ns = this_cpu_read(cpu_softirq_time);\r\nif (nsecs_to_cputime64(latest_ns) > cpustat[CPUTIME_SOFTIRQ])\r\nret = 1;\r\nlocal_irq_restore(flags);\r\nreturn ret;\r\n}\r\nstatic inline void task_group_account_field(struct task_struct *p, int index,\r\nu64 tmp)\r\n{\r\n__this_cpu_add(kernel_cpustat.cpustat[index], tmp);\r\ncpuacct_account_field(p, index, tmp);\r\n}\r\nvoid account_user_time(struct task_struct *p, cputime_t cputime,\r\ncputime_t cputime_scaled)\r\n{\r\nint index;\r\np->utime += cputime;\r\np->utimescaled += cputime_scaled;\r\naccount_group_user_time(p, cputime);\r\nindex = (task_nice(p) > 0) ? CPUTIME_NICE : CPUTIME_USER;\r\ntask_group_account_field(p, index, (__force u64) cputime);\r\nacct_account_cputime(p);\r\n}\r\nstatic void account_guest_time(struct task_struct *p, cputime_t cputime,\r\ncputime_t cputime_scaled)\r\n{\r\nu64 *cpustat = kcpustat_this_cpu->cpustat;\r\np->utime += cputime;\r\np->utimescaled += cputime_scaled;\r\naccount_group_user_time(p, cputime);\r\np->gtime += cputime;\r\nif (task_nice(p) > 0) {\r\ncpustat[CPUTIME_NICE] += (__force u64) cputime;\r\ncpustat[CPUTIME_GUEST_NICE] += (__force u64) cputime;\r\n} else {\r\ncpustat[CPUTIME_USER] += (__force u64) cputime;\r\ncpustat[CPUTIME_GUEST] += (__force u64) cputime;\r\n}\r\n}\r\nstatic inline\r\nvoid __account_system_time(struct task_struct *p, cputime_t cputime,\r\ncputime_t cputime_scaled, int index)\r\n{\r\np->stime += cputime;\r\np->stimescaled += cputime_scaled;\r\naccount_group_system_time(p, cputime);\r\ntask_group_account_field(p, index, (__force u64) cputime);\r\nacct_account_cputime(p);\r\n}\r\nvoid account_system_time(struct task_struct *p, int hardirq_offset,\r\ncputime_t cputime, cputime_t cputime_scaled)\r\n{\r\nint index;\r\nif ((p->flags & PF_VCPU) && (irq_count() - hardirq_offset == 0)) {\r\naccount_guest_time(p, cputime, cputime_scaled);\r\nreturn;\r\n}\r\nif (hardirq_count() - hardirq_offset)\r\nindex = CPUTIME_IRQ;\r\nelse if (in_serving_softirq())\r\nindex = CPUTIME_SOFTIRQ;\r\nelse\r\nindex = CPUTIME_SYSTEM;\r\n__account_system_time(p, cputime, cputime_scaled, index);\r\n}\r\nvoid account_steal_time(cputime_t cputime)\r\n{\r\nu64 *cpustat = kcpustat_this_cpu->cpustat;\r\ncpustat[CPUTIME_STEAL] += (__force u64) cputime;\r\n}\r\nvoid account_idle_time(cputime_t cputime)\r\n{\r\nu64 *cpustat = kcpustat_this_cpu->cpustat;\r\nstruct rq *rq = this_rq();\r\nif (atomic_read(&rq->nr_iowait) > 0)\r\ncpustat[CPUTIME_IOWAIT] += (__force u64) cputime;\r\nelse\r\ncpustat[CPUTIME_IDLE] += (__force u64) cputime;\r\n}\r\nstatic __always_inline bool steal_account_process_tick(void)\r\n{\r\n#ifdef CONFIG_PARAVIRT\r\nif (static_key_false(&paravirt_steal_enabled)) {\r\nu64 steal;\r\nunsigned long steal_jiffies;\r\nsteal = paravirt_steal_clock(smp_processor_id());\r\nsteal -= this_rq()->prev_steal_time;\r\nsteal_jiffies = nsecs_to_jiffies(steal);\r\nthis_rq()->prev_steal_time += jiffies_to_nsecs(steal_jiffies);\r\naccount_steal_time(jiffies_to_cputime(steal_jiffies));\r\nreturn steal_jiffies;\r\n}\r\n#endif\r\nreturn false;\r\n}\r\nvoid thread_group_cputime(struct task_struct *tsk, struct task_cputime *times)\r\n{\r\nstruct signal_struct *sig = tsk->signal;\r\ncputime_t utime, stime;\r\nstruct task_struct *t;\r\nunsigned int seq, nextseq;\r\nunsigned long flags;\r\nrcu_read_lock();\r\nnextseq = 0;\r\ndo {\r\nseq = nextseq;\r\nflags = read_seqbegin_or_lock_irqsave(&sig->stats_lock, &seq);\r\ntimes->utime = sig->utime;\r\ntimes->stime = sig->stime;\r\ntimes->sum_exec_runtime = sig->sum_sched_runtime;\r\nfor_each_thread(tsk, t) {\r\ntask_cputime(t, &utime, &stime);\r\ntimes->utime += utime;\r\ntimes->stime += stime;\r\ntimes->sum_exec_runtime += task_sched_runtime(t);\r\n}\r\nnextseq = 1;\r\n} while (need_seqretry(&sig->stats_lock, seq));\r\ndone_seqretry_irqrestore(&sig->stats_lock, seq, flags);\r\nrcu_read_unlock();\r\n}\r\nstatic void irqtime_account_process_tick(struct task_struct *p, int user_tick,\r\nstruct rq *rq, int ticks)\r\n{\r\ncputime_t scaled = cputime_to_scaled(cputime_one_jiffy);\r\nu64 cputime = (__force u64) cputime_one_jiffy;\r\nu64 *cpustat = kcpustat_this_cpu->cpustat;\r\nif (steal_account_process_tick())\r\nreturn;\r\ncputime *= ticks;\r\nscaled *= ticks;\r\nif (irqtime_account_hi_update()) {\r\ncpustat[CPUTIME_IRQ] += cputime;\r\n} else if (irqtime_account_si_update()) {\r\ncpustat[CPUTIME_SOFTIRQ] += cputime;\r\n} else if (this_cpu_ksoftirqd() == p) {\r\n__account_system_time(p, cputime, scaled, CPUTIME_SOFTIRQ);\r\n} else if (user_tick) {\r\naccount_user_time(p, cputime, scaled);\r\n} else if (p == rq->idle) {\r\naccount_idle_time(cputime);\r\n} else if (p->flags & PF_VCPU) {\r\naccount_guest_time(p, cputime, scaled);\r\n} else {\r\n__account_system_time(p, cputime, scaled, CPUTIME_SYSTEM);\r\n}\r\n}\r\nstatic void irqtime_account_idle_ticks(int ticks)\r\n{\r\nstruct rq *rq = this_rq();\r\nirqtime_account_process_tick(current, 0, rq, ticks);\r\n}\r\nstatic inline void irqtime_account_idle_ticks(int ticks) {}\r\nstatic inline void irqtime_account_process_tick(struct task_struct *p, int user_tick,\r\nstruct rq *rq, int nr_ticks) {}\r\nvoid vtime_common_task_switch(struct task_struct *prev)\r\n{\r\nif (is_idle_task(prev))\r\nvtime_account_idle(prev);\r\nelse\r\nvtime_account_system(prev);\r\n#ifdef CONFIG_VIRT_CPU_ACCOUNTING_NATIVE\r\nvtime_account_user(prev);\r\n#endif\r\narch_vtime_task_switch(prev);\r\n}\r\nvoid vtime_common_account_irq_enter(struct task_struct *tsk)\r\n{\r\nif (!in_interrupt()) {\r\nif (context_tracking_in_user()) {\r\nvtime_account_user(tsk);\r\nreturn;\r\n}\r\nif (is_idle_task(tsk)) {\r\nvtime_account_idle(tsk);\r\nreturn;\r\n}\r\n}\r\nvtime_account_system(tsk);\r\n}\r\nvoid task_cputime_adjusted(struct task_struct *p, cputime_t *ut, cputime_t *st)\r\n{\r\n*ut = p->utime;\r\n*st = p->stime;\r\n}\r\nvoid thread_group_cputime_adjusted(struct task_struct *p, cputime_t *ut, cputime_t *st)\r\n{\r\nstruct task_cputime cputime;\r\nthread_group_cputime(p, &cputime);\r\n*ut = cputime.utime;\r\n*st = cputime.stime;\r\n}\r\nvoid account_process_tick(struct task_struct *p, int user_tick)\r\n{\r\ncputime_t one_jiffy_scaled = cputime_to_scaled(cputime_one_jiffy);\r\nstruct rq *rq = this_rq();\r\nif (vtime_accounting_cpu_enabled())\r\nreturn;\r\nif (sched_clock_irqtime) {\r\nirqtime_account_process_tick(p, user_tick, rq, 1);\r\nreturn;\r\n}\r\nif (steal_account_process_tick())\r\nreturn;\r\nif (user_tick)\r\naccount_user_time(p, cputime_one_jiffy, one_jiffy_scaled);\r\nelse if ((p != rq->idle) || (irq_count() != HARDIRQ_OFFSET))\r\naccount_system_time(p, HARDIRQ_OFFSET, cputime_one_jiffy,\r\none_jiffy_scaled);\r\nelse\r\naccount_idle_time(cputime_one_jiffy);\r\n}\r\nvoid account_steal_ticks(unsigned long ticks)\r\n{\r\naccount_steal_time(jiffies_to_cputime(ticks));\r\n}\r\nvoid account_idle_ticks(unsigned long ticks)\r\n{\r\nif (sched_clock_irqtime) {\r\nirqtime_account_idle_ticks(ticks);\r\nreturn;\r\n}\r\naccount_idle_time(jiffies_to_cputime(ticks));\r\n}\r\nstatic cputime_t scale_stime(u64 stime, u64 rtime, u64 total)\r\n{\r\nu64 scaled;\r\nfor (;;) {\r\nif (stime > rtime)\r\nswap(rtime, stime);\r\nif (total >> 32)\r\ngoto drop_precision;\r\nif (!(rtime >> 32))\r\nbreak;\r\nif (stime >> 31)\r\ngoto drop_precision;\r\nstime <<= 1;\r\nrtime >>= 1;\r\ncontinue;\r\ndrop_precision:\r\nrtime >>= 1;\r\ntotal >>= 1;\r\n}\r\nscaled = div_u64((u64) (u32) stime * (u64) (u32) rtime, (u32)total);\r\nreturn (__force cputime_t) scaled;\r\n}\r\nstatic void cputime_adjust(struct task_cputime *curr,\r\nstruct prev_cputime *prev,\r\ncputime_t *ut, cputime_t *st)\r\n{\r\ncputime_t rtime, stime, utime;\r\nunsigned long flags;\r\nraw_spin_lock_irqsave(&prev->lock, flags);\r\nrtime = nsecs_to_cputime(curr->sum_exec_runtime);\r\nif (prev->stime + prev->utime >= rtime)\r\ngoto out;\r\nstime = curr->stime;\r\nutime = curr->utime;\r\nif (utime == 0) {\r\nstime = rtime;\r\ngoto update;\r\n}\r\nif (stime == 0) {\r\nutime = rtime;\r\ngoto update;\r\n}\r\nstime = scale_stime((__force u64)stime, (__force u64)rtime,\r\n(__force u64)(stime + utime));\r\nif (stime < prev->stime)\r\nstime = prev->stime;\r\nutime = rtime - stime;\r\nif (utime < prev->utime) {\r\nutime = prev->utime;\r\nstime = rtime - utime;\r\n}\r\nupdate:\r\nprev->stime = stime;\r\nprev->utime = utime;\r\nout:\r\n*ut = prev->utime;\r\n*st = prev->stime;\r\nraw_spin_unlock_irqrestore(&prev->lock, flags);\r\n}\r\nvoid task_cputime_adjusted(struct task_struct *p, cputime_t *ut, cputime_t *st)\r\n{\r\nstruct task_cputime cputime = {\r\n.sum_exec_runtime = p->se.sum_exec_runtime,\r\n};\r\ntask_cputime(p, &cputime.utime, &cputime.stime);\r\ncputime_adjust(&cputime, &p->prev_cputime, ut, st);\r\n}\r\nvoid thread_group_cputime_adjusted(struct task_struct *p, cputime_t *ut, cputime_t *st)\r\n{\r\nstruct task_cputime cputime;\r\nthread_group_cputime(p, &cputime);\r\ncputime_adjust(&cputime, &p->signal->prev_cputime, ut, st);\r\n}\r\nstatic cputime_t vtime_delta(struct task_struct *tsk)\r\n{\r\nunsigned long now = READ_ONCE(jiffies);\r\nif (time_before(now, (unsigned long)tsk->vtime_snap))\r\nreturn 0;\r\nreturn jiffies_to_cputime(now - tsk->vtime_snap);\r\n}\r\nstatic cputime_t get_vtime_delta(struct task_struct *tsk)\r\n{\r\nunsigned long now = READ_ONCE(jiffies);\r\nunsigned long delta = now - tsk->vtime_snap;\r\nWARN_ON_ONCE(tsk->vtime_snap_whence == VTIME_INACTIVE);\r\ntsk->vtime_snap = now;\r\nreturn jiffies_to_cputime(delta);\r\n}\r\nstatic void __vtime_account_system(struct task_struct *tsk)\r\n{\r\ncputime_t delta_cpu = get_vtime_delta(tsk);\r\naccount_system_time(tsk, irq_count(), delta_cpu, cputime_to_scaled(delta_cpu));\r\n}\r\nvoid vtime_account_system(struct task_struct *tsk)\r\n{\r\nif (!vtime_delta(tsk))\r\nreturn;\r\nwrite_seqcount_begin(&tsk->vtime_seqcount);\r\n__vtime_account_system(tsk);\r\nwrite_seqcount_end(&tsk->vtime_seqcount);\r\n}\r\nvoid vtime_gen_account_irq_exit(struct task_struct *tsk)\r\n{\r\nwrite_seqcount_begin(&tsk->vtime_seqcount);\r\nif (vtime_delta(tsk))\r\n__vtime_account_system(tsk);\r\nif (context_tracking_in_user())\r\ntsk->vtime_snap_whence = VTIME_USER;\r\nwrite_seqcount_end(&tsk->vtime_seqcount);\r\n}\r\nvoid vtime_account_user(struct task_struct *tsk)\r\n{\r\ncputime_t delta_cpu;\r\nwrite_seqcount_begin(&tsk->vtime_seqcount);\r\ntsk->vtime_snap_whence = VTIME_SYS;\r\nif (vtime_delta(tsk)) {\r\ndelta_cpu = get_vtime_delta(tsk);\r\naccount_user_time(tsk, delta_cpu, cputime_to_scaled(delta_cpu));\r\n}\r\nwrite_seqcount_end(&tsk->vtime_seqcount);\r\n}\r\nvoid vtime_user_enter(struct task_struct *tsk)\r\n{\r\nwrite_seqcount_begin(&tsk->vtime_seqcount);\r\nif (vtime_delta(tsk))\r\n__vtime_account_system(tsk);\r\ntsk->vtime_snap_whence = VTIME_USER;\r\nwrite_seqcount_end(&tsk->vtime_seqcount);\r\n}\r\nvoid vtime_guest_enter(struct task_struct *tsk)\r\n{\r\nwrite_seqcount_begin(&tsk->vtime_seqcount);\r\nif (vtime_delta(tsk))\r\n__vtime_account_system(tsk);\r\ncurrent->flags |= PF_VCPU;\r\nwrite_seqcount_end(&tsk->vtime_seqcount);\r\n}\r\nvoid vtime_guest_exit(struct task_struct *tsk)\r\n{\r\nwrite_seqcount_begin(&tsk->vtime_seqcount);\r\n__vtime_account_system(tsk);\r\ncurrent->flags &= ~PF_VCPU;\r\nwrite_seqcount_end(&tsk->vtime_seqcount);\r\n}\r\nvoid vtime_account_idle(struct task_struct *tsk)\r\n{\r\ncputime_t delta_cpu = get_vtime_delta(tsk);\r\naccount_idle_time(delta_cpu);\r\n}\r\nvoid arch_vtime_task_switch(struct task_struct *prev)\r\n{\r\nwrite_seqcount_begin(&prev->vtime_seqcount);\r\nprev->vtime_snap_whence = VTIME_INACTIVE;\r\nwrite_seqcount_end(&prev->vtime_seqcount);\r\nwrite_seqcount_begin(&current->vtime_seqcount);\r\ncurrent->vtime_snap_whence = VTIME_SYS;\r\ncurrent->vtime_snap = jiffies;\r\nwrite_seqcount_end(&current->vtime_seqcount);\r\n}\r\nvoid vtime_init_idle(struct task_struct *t, int cpu)\r\n{\r\nunsigned long flags;\r\nlocal_irq_save(flags);\r\nwrite_seqcount_begin(&t->vtime_seqcount);\r\nt->vtime_snap_whence = VTIME_SYS;\r\nt->vtime_snap = jiffies;\r\nwrite_seqcount_end(&t->vtime_seqcount);\r\nlocal_irq_restore(flags);\r\n}\r\ncputime_t task_gtime(struct task_struct *t)\r\n{\r\nunsigned int seq;\r\ncputime_t gtime;\r\nif (!vtime_accounting_enabled())\r\nreturn t->gtime;\r\ndo {\r\nseq = read_seqcount_begin(&t->vtime_seqcount);\r\ngtime = t->gtime;\r\nif (t->vtime_snap_whence == VTIME_SYS && t->flags & PF_VCPU)\r\ngtime += vtime_delta(t);\r\n} while (read_seqcount_retry(&t->vtime_seqcount, seq));\r\nreturn gtime;\r\n}\r\nstatic void\r\nfetch_task_cputime(struct task_struct *t,\r\ncputime_t *u_dst, cputime_t *s_dst,\r\ncputime_t *u_src, cputime_t *s_src,\r\ncputime_t *udelta, cputime_t *sdelta)\r\n{\r\nunsigned int seq;\r\nunsigned long long delta;\r\ndo {\r\n*udelta = 0;\r\n*sdelta = 0;\r\nseq = read_seqcount_begin(&t->vtime_seqcount);\r\nif (u_dst)\r\n*u_dst = *u_src;\r\nif (s_dst)\r\n*s_dst = *s_src;\r\nif (t->vtime_snap_whence == VTIME_INACTIVE ||\r\nis_idle_task(t))\r\ncontinue;\r\ndelta = vtime_delta(t);\r\nif (t->vtime_snap_whence == VTIME_USER || t->flags & PF_VCPU) {\r\n*udelta = delta;\r\n} else {\r\nif (t->vtime_snap_whence == VTIME_SYS)\r\n*sdelta = delta;\r\n}\r\n} while (read_seqcount_retry(&t->vtime_seqcount, seq));\r\n}\r\nvoid task_cputime(struct task_struct *t, cputime_t *utime, cputime_t *stime)\r\n{\r\ncputime_t udelta, sdelta;\r\nif (!vtime_accounting_enabled()) {\r\nif (utime)\r\n*utime = t->utime;\r\nif (stime)\r\n*stime = t->stime;\r\nreturn;\r\n}\r\nfetch_task_cputime(t, utime, stime, &t->utime,\r\n&t->stime, &udelta, &sdelta);\r\nif (utime)\r\n*utime += udelta;\r\nif (stime)\r\n*stime += sdelta;\r\n}\r\nvoid task_cputime_scaled(struct task_struct *t,\r\ncputime_t *utimescaled, cputime_t *stimescaled)\r\n{\r\ncputime_t udelta, sdelta;\r\nif (!vtime_accounting_enabled()) {\r\nif (utimescaled)\r\n*utimescaled = t->utimescaled;\r\nif (stimescaled)\r\n*stimescaled = t->stimescaled;\r\nreturn;\r\n}\r\nfetch_task_cputime(t, utimescaled, stimescaled,\r\n&t->utimescaled, &t->stimescaled, &udelta, &sdelta);\r\nif (utimescaled)\r\n*utimescaled += cputime_to_scaled(udelta);\r\nif (stimescaled)\r\n*stimescaled += cputime_to_scaled(sdelta);\r\n}
