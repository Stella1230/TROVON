static int tegra_mc_setup_latency_allowance(struct tegra_mc *mc)\r\n{\r\nunsigned long long tick;\r\nunsigned int i;\r\nu32 value;\r\ntick = mc->tick * clk_get_rate(mc->clk);\r\ndo_div(tick, NSEC_PER_SEC);\r\nvalue = readl(mc->regs + MC_EMEM_ARB_CFG);\r\nvalue &= ~MC_EMEM_ARB_CFG_CYCLES_PER_UPDATE_MASK;\r\nvalue |= MC_EMEM_ARB_CFG_CYCLES_PER_UPDATE(tick);\r\nwritel(value, mc->regs + MC_EMEM_ARB_CFG);\r\nfor (i = 0; i < mc->soc->num_clients; i++) {\r\nconst struct tegra_mc_la *la = &mc->soc->clients[i].la;\r\nu32 value;\r\nvalue = readl(mc->regs + la->reg);\r\nvalue &= ~(la->mask << la->shift);\r\nvalue |= (la->def & la->mask) << la->shift;\r\nwritel(value, mc->regs + la->reg);\r\n}\r\nreturn 0;\r\n}\r\nvoid tegra_mc_write_emem_configuration(struct tegra_mc *mc, unsigned long rate)\r\n{\r\nunsigned int i;\r\nstruct tegra_mc_timing *timing = NULL;\r\nfor (i = 0; i < mc->num_timings; i++) {\r\nif (mc->timings[i].rate == rate) {\r\ntiming = &mc->timings[i];\r\nbreak;\r\n}\r\n}\r\nif (!timing) {\r\ndev_err(mc->dev, "no memory timing registered for rate %lu\n",\r\nrate);\r\nreturn;\r\n}\r\nfor (i = 0; i < mc->soc->num_emem_regs; ++i)\r\nmc_writel(mc, timing->emem_data[i], mc->soc->emem_regs[i]);\r\n}\r\nunsigned int tegra_mc_get_emem_device_count(struct tegra_mc *mc)\r\n{\r\nu8 dram_count;\r\ndram_count = mc_readl(mc, MC_EMEM_ADR_CFG);\r\ndram_count &= MC_EMEM_ADR_CFG_EMEM_NUMDEV;\r\ndram_count++;\r\nreturn dram_count;\r\n}\r\nstatic int load_one_timing(struct tegra_mc *mc,\r\nstruct tegra_mc_timing *timing,\r\nstruct device_node *node)\r\n{\r\nint err;\r\nu32 tmp;\r\nerr = of_property_read_u32(node, "clock-frequency", &tmp);\r\nif (err) {\r\ndev_err(mc->dev,\r\n"timing %s: failed to read rate\n", node->name);\r\nreturn err;\r\n}\r\ntiming->rate = tmp;\r\ntiming->emem_data = devm_kcalloc(mc->dev, mc->soc->num_emem_regs,\r\nsizeof(u32), GFP_KERNEL);\r\nif (!timing->emem_data)\r\nreturn -ENOMEM;\r\nerr = of_property_read_u32_array(node, "nvidia,emem-configuration",\r\ntiming->emem_data,\r\nmc->soc->num_emem_regs);\r\nif (err) {\r\ndev_err(mc->dev,\r\n"timing %s: failed to read EMEM configuration\n",\r\nnode->name);\r\nreturn err;\r\n}\r\nreturn 0;\r\n}\r\nstatic int load_timings(struct tegra_mc *mc, struct device_node *node)\r\n{\r\nstruct device_node *child;\r\nstruct tegra_mc_timing *timing;\r\nint child_count = of_get_child_count(node);\r\nint i = 0, err;\r\nmc->timings = devm_kcalloc(mc->dev, child_count, sizeof(*timing),\r\nGFP_KERNEL);\r\nif (!mc->timings)\r\nreturn -ENOMEM;\r\nmc->num_timings = child_count;\r\nfor_each_child_of_node(node, child) {\r\ntiming = &mc->timings[i++];\r\nerr = load_one_timing(mc, timing, child);\r\nif (err)\r\nreturn err;\r\n}\r\nreturn 0;\r\n}\r\nstatic int tegra_mc_setup_timings(struct tegra_mc *mc)\r\n{\r\nstruct device_node *node;\r\nu32 ram_code, node_ram_code;\r\nint err;\r\nram_code = tegra_read_ram_code();\r\nmc->num_timings = 0;\r\nfor_each_child_of_node(mc->dev->of_node, node) {\r\nerr = of_property_read_u32(node, "nvidia,ram-code",\r\n&node_ram_code);\r\nif (err || (node_ram_code != ram_code)) {\r\nof_node_put(node);\r\ncontinue;\r\n}\r\nerr = load_timings(mc, node);\r\nif (err)\r\nreturn err;\r\nof_node_put(node);\r\nbreak;\r\n}\r\nif (mc->num_timings == 0)\r\ndev_warn(mc->dev,\r\n"no memory timings for RAM code %u registered\n",\r\nram_code);\r\nreturn 0;\r\n}\r\nstatic irqreturn_t tegra_mc_irq(int irq, void *data)\r\n{\r\nstruct tegra_mc *mc = data;\r\nunsigned long status, mask;\r\nunsigned int bit;\r\nstatus = mc_readl(mc, MC_INTSTATUS);\r\nmask = mc_readl(mc, MC_INTMASK);\r\nfor_each_set_bit(bit, &status, 32) {\r\nconst char *error = status_names[bit] ?: "unknown";\r\nconst char *client = "unknown", *desc;\r\nconst char *direction, *secure;\r\nphys_addr_t addr = 0;\r\nunsigned int i;\r\nchar perm[7];\r\nu8 id, type;\r\nu32 value;\r\nvalue = mc_readl(mc, MC_ERR_STATUS);\r\n#ifdef CONFIG_PHYS_ADDR_T_64BIT\r\nif (mc->soc->num_address_bits > 32) {\r\naddr = ((value >> MC_ERR_STATUS_ADR_HI_SHIFT) &\r\nMC_ERR_STATUS_ADR_HI_MASK);\r\naddr <<= 32;\r\n}\r\n#endif\r\nif (value & MC_ERR_STATUS_RW)\r\ndirection = "write";\r\nelse\r\ndirection = "read";\r\nif (value & MC_ERR_STATUS_SECURITY)\r\nsecure = "secure ";\r\nelse\r\nsecure = "";\r\nid = value & mc->soc->client_id_mask;\r\nfor (i = 0; i < mc->soc->num_clients; i++) {\r\nif (mc->soc->clients[i].id == id) {\r\nclient = mc->soc->clients[i].name;\r\nbreak;\r\n}\r\n}\r\ntype = (value & MC_ERR_STATUS_TYPE_MASK) >>\r\nMC_ERR_STATUS_TYPE_SHIFT;\r\ndesc = error_names[type];\r\nswitch (value & MC_ERR_STATUS_TYPE_MASK) {\r\ncase MC_ERR_STATUS_TYPE_INVALID_SMMU_PAGE:\r\nperm[0] = ' ';\r\nperm[1] = '[';\r\nif (value & MC_ERR_STATUS_READABLE)\r\nperm[2] = 'R';\r\nelse\r\nperm[2] = '-';\r\nif (value & MC_ERR_STATUS_WRITABLE)\r\nperm[3] = 'W';\r\nelse\r\nperm[3] = '-';\r\nif (value & MC_ERR_STATUS_NONSECURE)\r\nperm[4] = '-';\r\nelse\r\nperm[4] = 'S';\r\nperm[5] = ']';\r\nperm[6] = '\0';\r\nbreak;\r\ndefault:\r\nperm[0] = '\0';\r\nbreak;\r\n}\r\nvalue = mc_readl(mc, MC_ERR_ADR);\r\naddr |= value;\r\ndev_err_ratelimited(mc->dev, "%s: %s%s @%pa: %s (%s%s)\n",\r\nclient, secure, direction, &addr, error,\r\ndesc, perm);\r\n}\r\nmc_writel(mc, status, MC_INTSTATUS);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int tegra_mc_probe(struct platform_device *pdev)\r\n{\r\nconst struct of_device_id *match;\r\nstruct resource *res;\r\nstruct tegra_mc *mc;\r\nu32 value;\r\nint err;\r\nmatch = of_match_node(tegra_mc_of_match, pdev->dev.of_node);\r\nif (!match)\r\nreturn -ENODEV;\r\nmc = devm_kzalloc(&pdev->dev, sizeof(*mc), GFP_KERNEL);\r\nif (!mc)\r\nreturn -ENOMEM;\r\nplatform_set_drvdata(pdev, mc);\r\nmc->soc = match->data;\r\nmc->dev = &pdev->dev;\r\nmc->tick = 30;\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nmc->regs = devm_ioremap_resource(&pdev->dev, res);\r\nif (IS_ERR(mc->regs))\r\nreturn PTR_ERR(mc->regs);\r\nmc->clk = devm_clk_get(&pdev->dev, "mc");\r\nif (IS_ERR(mc->clk)) {\r\ndev_err(&pdev->dev, "failed to get MC clock: %ld\n",\r\nPTR_ERR(mc->clk));\r\nreturn PTR_ERR(mc->clk);\r\n}\r\nerr = tegra_mc_setup_latency_allowance(mc);\r\nif (err < 0) {\r\ndev_err(&pdev->dev, "failed to setup latency allowance: %d\n",\r\nerr);\r\nreturn err;\r\n}\r\nerr = tegra_mc_setup_timings(mc);\r\nif (err < 0) {\r\ndev_err(&pdev->dev, "failed to setup timings: %d\n", err);\r\nreturn err;\r\n}\r\nif (IS_ENABLED(CONFIG_TEGRA_IOMMU_SMMU)) {\r\nmc->smmu = tegra_smmu_probe(&pdev->dev, mc->soc->smmu, mc);\r\nif (IS_ERR(mc->smmu)) {\r\ndev_err(&pdev->dev, "failed to probe SMMU: %ld\n",\r\nPTR_ERR(mc->smmu));\r\nreturn PTR_ERR(mc->smmu);\r\n}\r\n}\r\nmc->irq = platform_get_irq(pdev, 0);\r\nif (mc->irq < 0) {\r\ndev_err(&pdev->dev, "interrupt not specified\n");\r\nreturn mc->irq;\r\n}\r\nerr = devm_request_irq(&pdev->dev, mc->irq, tegra_mc_irq, IRQF_SHARED,\r\ndev_name(&pdev->dev), mc);\r\nif (err < 0) {\r\ndev_err(&pdev->dev, "failed to request IRQ#%u: %d\n", mc->irq,\r\nerr);\r\nreturn err;\r\n}\r\nWARN(!mc->soc->client_id_mask, "Missing client ID mask for this SoC\n");\r\nvalue = MC_INT_DECERR_MTS | MC_INT_SECERR_SEC | MC_INT_DECERR_VPR |\r\nMC_INT_INVALID_APB_ASID_UPDATE | MC_INT_INVALID_SMMU_PAGE |\r\nMC_INT_SECURITY_VIOLATION | MC_INT_DECERR_EMEM;\r\nmc_writel(mc, value, MC_INTMASK);\r\nreturn 0;\r\n}\r\nstatic int tegra_mc_init(void)\r\n{\r\nreturn platform_driver_register(&tegra_mc_driver);\r\n}
