static void marshal_virt_to_resize(struct dk_cxlflash_uvirtual *virt,\r\nstruct dk_cxlflash_resize *resize)\r\n{\r\nresize->hdr = virt->hdr;\r\nresize->context_id = virt->context_id;\r\nresize->rsrc_handle = virt->rsrc_handle;\r\nresize->req_size = virt->lun_size;\r\nresize->last_lba = virt->last_lba;\r\n}\r\nstatic void marshal_clone_to_rele(struct dk_cxlflash_clone *clone,\r\nstruct dk_cxlflash_release *release)\r\n{\r\nrelease->hdr = clone->hdr;\r\nrelease->context_id = clone->context_id_dst;\r\n}\r\nstatic int ba_init(struct ba_lun *ba_lun)\r\n{\r\nstruct ba_lun_info *bali = NULL;\r\nint lun_size_au = 0, i = 0;\r\nint last_word_underflow = 0;\r\nu64 *lam;\r\npr_debug("%s: Initializing LUN: lun_id = %llX, "\r\n"ba_lun->lsize = %lX, ba_lun->au_size = %lX\n",\r\n__func__, ba_lun->lun_id, ba_lun->lsize, ba_lun->au_size);\r\nlun_size_au = ba_lun->lsize / ba_lun->au_size;\r\nif (lun_size_au == 0) {\r\npr_debug("%s: Requested LUN size of 0!\n", __func__);\r\nreturn -EINVAL;\r\n}\r\nbali = kzalloc(sizeof(struct ba_lun_info), GFP_KERNEL);\r\nif (unlikely(!bali)) {\r\npr_err("%s: Failed to allocate lun_info for lun_id %llX\n",\r\n__func__, ba_lun->lun_id);\r\nreturn -ENOMEM;\r\n}\r\nbali->total_aus = lun_size_au;\r\nbali->lun_bmap_size = lun_size_au / BITS_PER_LONG;\r\nif (lun_size_au % BITS_PER_LONG)\r\nbali->lun_bmap_size++;\r\nbali->lun_alloc_map = kzalloc((bali->lun_bmap_size * sizeof(u64)),\r\nGFP_KERNEL);\r\nif (unlikely(!bali->lun_alloc_map)) {\r\npr_err("%s: Failed to allocate lun allocation map: "\r\n"lun_id = %llX\n", __func__, ba_lun->lun_id);\r\nkfree(bali);\r\nreturn -ENOMEM;\r\n}\r\nbali->free_aun_cnt = lun_size_au;\r\nfor (i = 0; i < bali->lun_bmap_size; i++)\r\nbali->lun_alloc_map[i] = 0xFFFFFFFFFFFFFFFFULL;\r\nlast_word_underflow = (bali->lun_bmap_size * BITS_PER_LONG);\r\nlast_word_underflow -= bali->free_aun_cnt;\r\nif (last_word_underflow > 0) {\r\nlam = &bali->lun_alloc_map[bali->lun_bmap_size - 1];\r\nfor (i = (HIBIT - last_word_underflow + 1);\r\ni < BITS_PER_LONG;\r\ni++)\r\nclear_bit(i, (ulong *)lam);\r\n}\r\nbali->free_high_idx = bali->lun_bmap_size;\r\nbali->aun_clone_map = kzalloc((bali->total_aus * sizeof(u8)),\r\nGFP_KERNEL);\r\nif (unlikely(!bali->aun_clone_map)) {\r\npr_err("%s: Failed to allocate clone map: lun_id = %llX\n",\r\n__func__, ba_lun->lun_id);\r\nkfree(bali->lun_alloc_map);\r\nkfree(bali);\r\nreturn -ENOMEM;\r\n}\r\nba_lun->ba_lun_handle = bali;\r\npr_debug("%s: Successfully initialized the LUN: "\r\n"lun_id = %llX, bitmap size = %X, free_aun_cnt = %llX\n",\r\n__func__, ba_lun->lun_id, bali->lun_bmap_size,\r\nbali->free_aun_cnt);\r\nreturn 0;\r\n}\r\nstatic int find_free_range(u32 low,\r\nu32 high,\r\nstruct ba_lun_info *bali, int *bit_word)\r\n{\r\nint i;\r\nu64 bit_pos = -1;\r\nulong *lam, num_bits;\r\nfor (i = low; i < high; i++)\r\nif (bali->lun_alloc_map[i] != 0) {\r\nlam = (ulong *)&bali->lun_alloc_map[i];\r\nnum_bits = (sizeof(*lam) * BITS_PER_BYTE);\r\nbit_pos = find_first_bit(lam, num_bits);\r\npr_devel("%s: Found free bit %llX in LUN "\r\n"map entry %llX at bitmap index = %X\n",\r\n__func__, bit_pos, bali->lun_alloc_map[i],\r\ni);\r\n*bit_word = i;\r\nbali->free_aun_cnt--;\r\nclear_bit(bit_pos, lam);\r\nbreak;\r\n}\r\nreturn bit_pos;\r\n}\r\nstatic u64 ba_alloc(struct ba_lun *ba_lun)\r\n{\r\nu64 bit_pos = -1;\r\nint bit_word = 0;\r\nstruct ba_lun_info *bali = NULL;\r\nbali = ba_lun->ba_lun_handle;\r\npr_debug("%s: Received block allocation request: "\r\n"lun_id = %llX, free_aun_cnt = %llX\n",\r\n__func__, ba_lun->lun_id, bali->free_aun_cnt);\r\nif (bali->free_aun_cnt == 0) {\r\npr_debug("%s: No space left on LUN: lun_id = %llX\n",\r\n__func__, ba_lun->lun_id);\r\nreturn -1ULL;\r\n}\r\nbit_pos = find_free_range(bali->free_curr_idx,\r\nbali->free_high_idx, bali, &bit_word);\r\nif (bit_pos == -1) {\r\nbit_pos = find_free_range(bali->free_low_idx,\r\nbali->free_curr_idx,\r\nbali, &bit_word);\r\nif (bit_pos == -1) {\r\npr_debug("%s: Could not find an allocation unit on LUN:"\r\n" lun_id = %llX\n", __func__, ba_lun->lun_id);\r\nreturn -1ULL;\r\n}\r\n}\r\nif (bit_pos == HIBIT)\r\nbali->free_curr_idx = bit_word + 1;\r\nelse\r\nbali->free_curr_idx = bit_word;\r\npr_debug("%s: Allocating AU number %llX, on lun_id %llX, "\r\n"free_aun_cnt = %llX\n", __func__,\r\n((bit_word * BITS_PER_LONG) + bit_pos), ba_lun->lun_id,\r\nbali->free_aun_cnt);\r\nreturn (u64) ((bit_word * BITS_PER_LONG) + bit_pos);\r\n}\r\nstatic int validate_alloc(struct ba_lun_info *bali, u64 aun)\r\n{\r\nint idx = 0, bit_pos = 0;\r\nidx = aun / BITS_PER_LONG;\r\nbit_pos = aun % BITS_PER_LONG;\r\nif (test_bit(bit_pos, (ulong *)&bali->lun_alloc_map[idx]))\r\nreturn -1;\r\nreturn 0;\r\n}\r\nstatic int ba_free(struct ba_lun *ba_lun, u64 to_free)\r\n{\r\nint idx = 0, bit_pos = 0;\r\nstruct ba_lun_info *bali = NULL;\r\nbali = ba_lun->ba_lun_handle;\r\nif (validate_alloc(bali, to_free)) {\r\npr_debug("%s: The AUN %llX is not allocated on lun_id %llX\n",\r\n__func__, to_free, ba_lun->lun_id);\r\nreturn -1;\r\n}\r\npr_debug("%s: Received a request to free AU %llX on lun_id %llX, "\r\n"free_aun_cnt = %llX\n", __func__, to_free, ba_lun->lun_id,\r\nbali->free_aun_cnt);\r\nif (bali->aun_clone_map[to_free] > 0) {\r\npr_debug("%s: AUN %llX on lun_id %llX has been cloned. Clone "\r\n"count = %X\n", __func__, to_free, ba_lun->lun_id,\r\nbali->aun_clone_map[to_free]);\r\nbali->aun_clone_map[to_free]--;\r\nreturn 0;\r\n}\r\nidx = to_free / BITS_PER_LONG;\r\nbit_pos = to_free % BITS_PER_LONG;\r\nset_bit(bit_pos, (ulong *)&bali->lun_alloc_map[idx]);\r\nbali->free_aun_cnt++;\r\nif (idx < bali->free_low_idx)\r\nbali->free_low_idx = idx;\r\nelse if (idx > bali->free_high_idx)\r\nbali->free_high_idx = idx;\r\npr_debug("%s: Successfully freed AU at bit_pos %X, bit map index %X on "\r\n"lun_id %llX, free_aun_cnt = %llX\n", __func__, bit_pos, idx,\r\nba_lun->lun_id, bali->free_aun_cnt);\r\nreturn 0;\r\n}\r\nstatic int ba_clone(struct ba_lun *ba_lun, u64 to_clone)\r\n{\r\nstruct ba_lun_info *bali = ba_lun->ba_lun_handle;\r\nif (validate_alloc(bali, to_clone)) {\r\npr_debug("%s: AUN %llX is not allocated on lun_id %llX\n",\r\n__func__, to_clone, ba_lun->lun_id);\r\nreturn -1;\r\n}\r\npr_debug("%s: Received a request to clone AUN %llX on lun_id %llX\n",\r\n__func__, to_clone, ba_lun->lun_id);\r\nif (bali->aun_clone_map[to_clone] == MAX_AUN_CLONE_CNT) {\r\npr_debug("%s: AUN %llX on lun_id %llX hit max clones already\n",\r\n__func__, to_clone, ba_lun->lun_id);\r\nreturn -1;\r\n}\r\nbali->aun_clone_map[to_clone]++;\r\nreturn 0;\r\n}\r\nstatic u64 ba_space(struct ba_lun *ba_lun)\r\n{\r\nstruct ba_lun_info *bali = ba_lun->ba_lun_handle;\r\nreturn bali->free_aun_cnt;\r\n}\r\nvoid cxlflash_ba_terminate(struct ba_lun *ba_lun)\r\n{\r\nstruct ba_lun_info *bali = ba_lun->ba_lun_handle;\r\nif (bali) {\r\nkfree(bali->aun_clone_map);\r\nkfree(bali->lun_alloc_map);\r\nkfree(bali);\r\nba_lun->ba_lun_handle = NULL;\r\n}\r\n}\r\nstatic int init_vlun(struct llun_info *lli)\r\n{\r\nint rc = 0;\r\nstruct glun_info *gli = lli->parent;\r\nstruct blka *blka = &gli->blka;\r\nmemset(blka, 0, sizeof(*blka));\r\nmutex_init(&blka->mutex);\r\nblka->ba_lun.lun_id = lli->lun_index;\r\nblka->ba_lun.lsize = gli->max_lba + 1;\r\nblka->ba_lun.lba_size = gli->blk_len;\r\nblka->ba_lun.au_size = MC_CHUNK_SIZE;\r\nblka->nchunk = blka->ba_lun.lsize / MC_CHUNK_SIZE;\r\nrc = ba_init(&blka->ba_lun);\r\nif (unlikely(rc))\r\npr_debug("%s: cannot init block_alloc, rc=%d\n", __func__, rc);\r\npr_debug("%s: returning rc=%d lli=%p\n", __func__, rc, lli);\r\nreturn rc;\r\n}\r\nstatic int write_same16(struct scsi_device *sdev,\r\nu64 lba,\r\nu32 nblks)\r\n{\r\nu8 *cmd_buf = NULL;\r\nu8 *scsi_cmd = NULL;\r\nu8 *sense_buf = NULL;\r\nint rc = 0;\r\nint result = 0;\r\nint ws_limit = SISLITE_MAX_WS_BLOCKS;\r\nu64 offset = lba;\r\nint left = nblks;\r\nu32 to = sdev->request_queue->rq_timeout;\r\nstruct cxlflash_cfg *cfg = (struct cxlflash_cfg *)sdev->host->hostdata;\r\nstruct device *dev = &cfg->dev->dev;\r\ncmd_buf = kzalloc(CMD_BUFSIZE, GFP_KERNEL);\r\nscsi_cmd = kzalloc(MAX_COMMAND_SIZE, GFP_KERNEL);\r\nsense_buf = kzalloc(SCSI_SENSE_BUFFERSIZE, GFP_KERNEL);\r\nif (unlikely(!cmd_buf || !scsi_cmd || !sense_buf)) {\r\nrc = -ENOMEM;\r\ngoto out;\r\n}\r\nwhile (left > 0) {\r\nscsi_cmd[0] = WRITE_SAME_16;\r\nput_unaligned_be64(offset, &scsi_cmd[2]);\r\nput_unaligned_be32(ws_limit < left ? ws_limit : left,\r\n&scsi_cmd[10]);\r\nup_read(&cfg->ioctl_rwsem);\r\nresult = scsi_execute(sdev, scsi_cmd, DMA_TO_DEVICE, cmd_buf,\r\nCMD_BUFSIZE, sense_buf, to, CMD_RETRIES,\r\n0, NULL);\r\ndown_read(&cfg->ioctl_rwsem);\r\nrc = check_state(cfg);\r\nif (rc) {\r\ndev_err(dev, "%s: Failed state! result=0x08%X\n",\r\n__func__, result);\r\nrc = -ENODEV;\r\ngoto out;\r\n}\r\nif (result) {\r\ndev_err_ratelimited(dev, "%s: command failed for "\r\n"offset %lld result=0x%x\n",\r\n__func__, offset, result);\r\nrc = -EIO;\r\ngoto out;\r\n}\r\nleft -= ws_limit;\r\noffset += ws_limit;\r\n}\r\nout:\r\nkfree(cmd_buf);\r\nkfree(scsi_cmd);\r\nkfree(sense_buf);\r\npr_debug("%s: returning rc=%d\n", __func__, rc);\r\nreturn rc;\r\n}\r\nstatic int grow_lxt(struct afu *afu,\r\nstruct scsi_device *sdev,\r\nctx_hndl_t ctxid,\r\nres_hndl_t rhndl,\r\nstruct sisl_rht_entry *rhte,\r\nu64 *new_size)\r\n{\r\nstruct sisl_lxt_entry *lxt = NULL, *lxt_old = NULL;\r\nstruct llun_info *lli = sdev->hostdata;\r\nstruct glun_info *gli = lli->parent;\r\nstruct blka *blka = &gli->blka;\r\nu32 av_size;\r\nu32 ngrps, ngrps_old;\r\nu64 aun;\r\nu64 delta = *new_size - rhte->lxt_cnt;\r\nu64 my_new_size;\r\nint i, rc = 0;\r\nmutex_lock(&blka->mutex);\r\nav_size = ba_space(&blka->ba_lun);\r\nif (unlikely(av_size <= 0)) {\r\npr_debug("%s: ba_space error: av_size %d\n", __func__, av_size);\r\nmutex_unlock(&blka->mutex);\r\nrc = -ENOSPC;\r\ngoto out;\r\n}\r\nif (av_size < delta)\r\ndelta = av_size;\r\nlxt_old = rhte->lxt_start;\r\nngrps_old = LXT_NUM_GROUPS(rhte->lxt_cnt);\r\nngrps = LXT_NUM_GROUPS(rhte->lxt_cnt + delta);\r\nif (ngrps != ngrps_old) {\r\nlxt = kzalloc((sizeof(*lxt) * LXT_GROUP_SIZE * ngrps),\r\nGFP_KERNEL);\r\nif (unlikely(!lxt)) {\r\nmutex_unlock(&blka->mutex);\r\nrc = -ENOMEM;\r\ngoto out;\r\n}\r\nmemcpy(lxt, lxt_old, (sizeof(*lxt) * rhte->lxt_cnt));\r\n} else\r\nlxt = lxt_old;\r\nmy_new_size = rhte->lxt_cnt + delta;\r\nfor (i = rhte->lxt_cnt; i < my_new_size; i++) {\r\naun = ba_alloc(&blka->ba_lun);\r\nif ((aun == -1ULL) || (aun >= blka->nchunk))\r\npr_debug("%s: ba_alloc error: allocated chunk# %llX, "\r\n"max %llX\n", __func__, aun, blka->nchunk - 1);\r\nlxt[i].rlba_base = ((aun << MC_CHUNK_SHIFT) |\r\n(lli->lun_index << LXT_LUNIDX_SHIFT) |\r\n(RHT_PERM_RW << LXT_PERM_SHIFT |\r\nlli->port_sel));\r\n}\r\nmutex_unlock(&blka->mutex);\r\ndma_wmb();\r\nrhte->lxt_start = lxt;\r\ndma_wmb();\r\nrhte->lxt_cnt = my_new_size;\r\ndma_wmb();\r\ncxlflash_afu_sync(afu, ctxid, rhndl, AFU_LW_SYNC);\r\nif (lxt != lxt_old)\r\nkfree(lxt_old);\r\n*new_size = my_new_size;\r\nout:\r\npr_debug("%s: returning rc=%d\n", __func__, rc);\r\nreturn rc;\r\n}\r\nstatic int shrink_lxt(struct afu *afu,\r\nstruct scsi_device *sdev,\r\nres_hndl_t rhndl,\r\nstruct sisl_rht_entry *rhte,\r\nstruct ctx_info *ctxi,\r\nu64 *new_size)\r\n{\r\nstruct sisl_lxt_entry *lxt, *lxt_old;\r\nstruct llun_info *lli = sdev->hostdata;\r\nstruct glun_info *gli = lli->parent;\r\nstruct blka *blka = &gli->blka;\r\nctx_hndl_t ctxid = DECODE_CTXID(ctxi->ctxid);\r\nbool needs_ws = ctxi->rht_needs_ws[rhndl];\r\nbool needs_sync = !ctxi->err_recovery_active;\r\nu32 ngrps, ngrps_old;\r\nu64 aun;\r\nu64 delta = rhte->lxt_cnt - *new_size;\r\nu64 my_new_size;\r\nint i, rc = 0;\r\nlxt_old = rhte->lxt_start;\r\nngrps_old = LXT_NUM_GROUPS(rhte->lxt_cnt);\r\nngrps = LXT_NUM_GROUPS(rhte->lxt_cnt - delta);\r\nif (ngrps != ngrps_old) {\r\nif (ngrps) {\r\nlxt = kzalloc((sizeof(*lxt) * LXT_GROUP_SIZE * ngrps),\r\nGFP_KERNEL);\r\nif (unlikely(!lxt)) {\r\nrc = -ENOMEM;\r\ngoto out;\r\n}\r\nmemcpy(lxt, lxt_old,\r\n(sizeof(*lxt) * (rhte->lxt_cnt - delta)));\r\n} else\r\nlxt = NULL;\r\n} else\r\nlxt = lxt_old;\r\nmy_new_size = rhte->lxt_cnt - delta;\r\nrhte->lxt_cnt = my_new_size;\r\ndma_wmb();\r\nrhte->lxt_start = lxt;\r\ndma_wmb();\r\nif (needs_sync)\r\ncxlflash_afu_sync(afu, ctxid, rhndl, AFU_HW_SYNC);\r\nif (needs_ws) {\r\nctxi->unavail = true;\r\nmutex_unlock(&ctxi->mutex);\r\n}\r\nmutex_lock(&blka->mutex);\r\nfor (i = delta - 1; i >= 0; i--) {\r\naun = (lxt_old[my_new_size + i].rlba_base & SISL_ASTATUS_MASK);\r\naun = (aun >> MC_CHUNK_SHIFT);\r\nif (needs_ws)\r\nwrite_same16(sdev, aun, MC_CHUNK_SIZE);\r\nba_free(&blka->ba_lun, aun);\r\n}\r\nmutex_unlock(&blka->mutex);\r\nif (needs_ws) {\r\nmutex_lock(&ctxi->mutex);\r\nctxi->unavail = false;\r\n}\r\nif (lxt != lxt_old)\r\nkfree(lxt_old);\r\n*new_size = my_new_size;\r\nout:\r\npr_debug("%s: returning rc=%d\n", __func__, rc);\r\nreturn rc;\r\n}\r\nint _cxlflash_vlun_resize(struct scsi_device *sdev,\r\nstruct ctx_info *ctxi,\r\nstruct dk_cxlflash_resize *resize)\r\n{\r\nstruct cxlflash_cfg *cfg = (struct cxlflash_cfg *)sdev->host->hostdata;\r\nstruct llun_info *lli = sdev->hostdata;\r\nstruct glun_info *gli = lli->parent;\r\nstruct afu *afu = cfg->afu;\r\nbool put_ctx = false;\r\nres_hndl_t rhndl = resize->rsrc_handle;\r\nu64 new_size;\r\nu64 nsectors;\r\nu64 ctxid = DECODE_CTXID(resize->context_id),\r\nrctxid = resize->context_id;\r\nstruct sisl_rht_entry *rhte;\r\nint rc = 0;\r\nnsectors = (resize->req_size * CXLFLASH_BLOCK_SIZE) / gli->blk_len;\r\nnew_size = DIV_ROUND_UP(nsectors, MC_CHUNK_SIZE);\r\npr_debug("%s: ctxid=%llu rhndl=0x%llx, req_size=0x%llx,"\r\n"new_size=%llx\n", __func__, ctxid, resize->rsrc_handle,\r\nresize->req_size, new_size);\r\nif (unlikely(gli->mode != MODE_VIRTUAL)) {\r\npr_debug("%s: LUN mode does not support resize! (%d)\n",\r\n__func__, gli->mode);\r\nrc = -EINVAL;\r\ngoto out;\r\n}\r\nif (!ctxi) {\r\nctxi = get_context(cfg, rctxid, lli, CTX_CTRL_ERR_FALLBACK);\r\nif (unlikely(!ctxi)) {\r\npr_debug("%s: Bad context! (%llu)\n", __func__, ctxid);\r\nrc = -EINVAL;\r\ngoto out;\r\n}\r\nput_ctx = true;\r\n}\r\nrhte = get_rhte(ctxi, rhndl, lli);\r\nif (unlikely(!rhte)) {\r\npr_debug("%s: Bad resource handle! (%u)\n", __func__, rhndl);\r\nrc = -EINVAL;\r\ngoto out;\r\n}\r\nif (new_size > rhte->lxt_cnt)\r\nrc = grow_lxt(afu, sdev, ctxid, rhndl, rhte, &new_size);\r\nelse if (new_size < rhte->lxt_cnt)\r\nrc = shrink_lxt(afu, sdev, rhndl, rhte, ctxi, &new_size);\r\nresize->hdr.return_flags = 0;\r\nresize->last_lba = (new_size * MC_CHUNK_SIZE * gli->blk_len);\r\nresize->last_lba /= CXLFLASH_BLOCK_SIZE;\r\nresize->last_lba--;\r\nout:\r\nif (put_ctx)\r\nput_context(ctxi);\r\npr_debug("%s: resized to %lld returning rc=%d\n",\r\n__func__, resize->last_lba, rc);\r\nreturn rc;\r\n}\r\nint cxlflash_vlun_resize(struct scsi_device *sdev,\r\nstruct dk_cxlflash_resize *resize)\r\n{\r\nreturn _cxlflash_vlun_resize(sdev, NULL, resize);\r\n}\r\nvoid cxlflash_restore_luntable(struct cxlflash_cfg *cfg)\r\n{\r\nstruct llun_info *lli, *temp;\r\nu32 chan;\r\nu32 lind;\r\nstruct afu *afu = cfg->afu;\r\nstruct sisl_global_map __iomem *agm = &afu->afu_map->global;\r\nmutex_lock(&global.mutex);\r\nlist_for_each_entry_safe(lli, temp, &cfg->lluns, list) {\r\nif (!lli->in_table)\r\ncontinue;\r\nlind = lli->lun_index;\r\nif (lli->port_sel == BOTH_PORTS) {\r\nwriteq_be(lli->lun_id[0], &agm->fc_port[0][lind]);\r\nwriteq_be(lli->lun_id[1], &agm->fc_port[1][lind]);\r\npr_debug("%s: Virtual LUN on slot %d id0=%llx, "\r\n"id1=%llx\n", __func__, lind,\r\nlli->lun_id[0], lli->lun_id[1]);\r\n} else {\r\nchan = PORT2CHAN(lli->port_sel);\r\nwriteq_be(lli->lun_id[chan], &agm->fc_port[chan][lind]);\r\npr_debug("%s: Virtual LUN on slot %d chan=%d, "\r\n"id=%llx\n", __func__, lind, chan,\r\nlli->lun_id[chan]);\r\n}\r\n}\r\nmutex_unlock(&global.mutex);\r\n}\r\nstatic int init_luntable(struct cxlflash_cfg *cfg, struct llun_info *lli)\r\n{\r\nu32 chan;\r\nu32 lind;\r\nint rc = 0;\r\nstruct afu *afu = cfg->afu;\r\nstruct sisl_global_map __iomem *agm = &afu->afu_map->global;\r\nmutex_lock(&global.mutex);\r\nif (lli->in_table)\r\ngoto out;\r\nif (lli->port_sel == BOTH_PORTS) {\r\nif ((cfg->promote_lun_index == cfg->last_lun_index[0]) ||\r\n(cfg->promote_lun_index == cfg->last_lun_index[1])) {\r\nrc = -ENOSPC;\r\ngoto out;\r\n}\r\nlind = lli->lun_index = cfg->promote_lun_index;\r\nwriteq_be(lli->lun_id[0], &agm->fc_port[0][lind]);\r\nwriteq_be(lli->lun_id[1], &agm->fc_port[1][lind]);\r\ncfg->promote_lun_index++;\r\npr_debug("%s: Virtual LUN on slot %d id0=%llx, id1=%llx\n",\r\n__func__, lind, lli->lun_id[0], lli->lun_id[1]);\r\n} else {\r\nchan = PORT2CHAN(lli->port_sel);\r\nif (cfg->promote_lun_index == cfg->last_lun_index[chan]) {\r\nrc = -ENOSPC;\r\ngoto out;\r\n}\r\nlind = lli->lun_index = cfg->last_lun_index[chan];\r\nwriteq_be(lli->lun_id[chan], &agm->fc_port[chan][lind]);\r\ncfg->last_lun_index[chan]--;\r\npr_debug("%s: Virtual LUN on slot %d chan=%d, id=%llx\n",\r\n__func__, lind, chan, lli->lun_id[chan]);\r\n}\r\nlli->in_table = true;\r\nout:\r\nmutex_unlock(&global.mutex);\r\npr_debug("%s: returning rc=%d\n", __func__, rc);\r\nreturn rc;\r\n}\r\nint cxlflash_disk_virtual_open(struct scsi_device *sdev, void *arg)\r\n{\r\nstruct cxlflash_cfg *cfg = (struct cxlflash_cfg *)sdev->host->hostdata;\r\nstruct device *dev = &cfg->dev->dev;\r\nstruct llun_info *lli = sdev->hostdata;\r\nstruct glun_info *gli = lli->parent;\r\nstruct dk_cxlflash_uvirtual *virt = (struct dk_cxlflash_uvirtual *)arg;\r\nstruct dk_cxlflash_resize resize;\r\nu64 ctxid = DECODE_CTXID(virt->context_id),\r\nrctxid = virt->context_id;\r\nu64 lun_size = virt->lun_size;\r\nu64 last_lba = 0;\r\nu64 rsrc_handle = -1;\r\nint rc = 0;\r\nstruct ctx_info *ctxi = NULL;\r\nstruct sisl_rht_entry *rhte = NULL;\r\npr_debug("%s: ctxid=%llu ls=0x%llx\n", __func__, ctxid, lun_size);\r\nmutex_lock(&gli->mutex);\r\nif (gli->mode == MODE_NONE) {\r\nrc = init_vlun(lli);\r\nif (rc) {\r\ndev_err(dev, "%s: call to init_vlun failed rc=%d!\n",\r\n__func__, rc);\r\nrc = -ENOMEM;\r\ngoto err0;\r\n}\r\n}\r\nrc = cxlflash_lun_attach(gli, MODE_VIRTUAL, true);\r\nif (unlikely(rc)) {\r\ndev_err(dev, "%s: Failed to attach to LUN! (VIRTUAL)\n",\r\n__func__);\r\ngoto err0;\r\n}\r\nmutex_unlock(&gli->mutex);\r\nrc = init_luntable(cfg, lli);\r\nif (rc) {\r\ndev_err(dev, "%s: call to init_luntable failed rc=%d!\n",\r\n__func__, rc);\r\ngoto err1;\r\n}\r\nctxi = get_context(cfg, rctxid, lli, 0);\r\nif (unlikely(!ctxi)) {\r\ndev_err(dev, "%s: Bad context! (%llu)\n", __func__, ctxid);\r\nrc = -EINVAL;\r\ngoto err1;\r\n}\r\nrhte = rhte_checkout(ctxi, lli);\r\nif (unlikely(!rhte)) {\r\ndev_err(dev, "%s: too many opens for this context\n", __func__);\r\nrc = -EMFILE;\r\ngoto err1;\r\n}\r\nrsrc_handle = (rhte - ctxi->rht_start);\r\nrhte->nmask = MC_RHT_NMASK;\r\nrhte->fp = SISL_RHT_FP(0U, ctxi->rht_perms);\r\nmarshal_virt_to_resize(virt, &resize);\r\nresize.rsrc_handle = rsrc_handle;\r\nrc = _cxlflash_vlun_resize(sdev, ctxi, &resize);\r\nif (rc) {\r\ndev_err(dev, "%s: resize failed rc %d\n", __func__, rc);\r\ngoto err2;\r\n}\r\nlast_lba = resize.last_lba;\r\nif (virt->hdr.flags & DK_CXLFLASH_UVIRTUAL_NEED_WRITE_SAME)\r\nctxi->rht_needs_ws[rsrc_handle] = true;\r\nvirt->hdr.return_flags = 0;\r\nvirt->last_lba = last_lba;\r\nvirt->rsrc_handle = rsrc_handle;\r\nif (lli->port_sel == BOTH_PORTS)\r\nvirt->hdr.return_flags |= DK_CXLFLASH_ALL_PORTS_ACTIVE;\r\nout:\r\nif (likely(ctxi))\r\nput_context(ctxi);\r\npr_debug("%s: returning handle 0x%llx rc=%d llba %lld\n",\r\n__func__, rsrc_handle, rc, last_lba);\r\nreturn rc;\r\nerr2:\r\nrhte_checkin(ctxi, rhte);\r\nerr1:\r\ncxlflash_lun_detach(gli);\r\ngoto out;\r\nerr0:\r\ncxlflash_ba_terminate(&gli->blka.ba_lun);\r\nmutex_unlock(&gli->mutex);\r\ngoto out;\r\n}\r\nstatic int clone_lxt(struct afu *afu,\r\nstruct blka *blka,\r\nctx_hndl_t ctxid,\r\nres_hndl_t rhndl,\r\nstruct sisl_rht_entry *rhte,\r\nstruct sisl_rht_entry *rhte_src)\r\n{\r\nstruct sisl_lxt_entry *lxt;\r\nu32 ngrps;\r\nu64 aun;\r\nint i, j;\r\nngrps = LXT_NUM_GROUPS(rhte_src->lxt_cnt);\r\nif (ngrps) {\r\nlxt = kzalloc((sizeof(*lxt) * LXT_GROUP_SIZE * ngrps),\r\nGFP_KERNEL);\r\nif (unlikely(!lxt))\r\nreturn -ENOMEM;\r\nmemcpy(lxt, rhte_src->lxt_start,\r\n(sizeof(*lxt) * rhte_src->lxt_cnt));\r\nmutex_lock(&blka->mutex);\r\nfor (i = 0; i < rhte_src->lxt_cnt; i++) {\r\naun = (lxt[i].rlba_base >> MC_CHUNK_SHIFT);\r\nif (ba_clone(&blka->ba_lun, aun) == -1ULL) {\r\nfor (j = 0; j < i; j++) {\r\naun = (lxt[j].rlba_base >>\r\nMC_CHUNK_SHIFT);\r\nba_free(&blka->ba_lun, aun);\r\n}\r\nmutex_unlock(&blka->mutex);\r\nkfree(lxt);\r\nreturn -EIO;\r\n}\r\n}\r\nmutex_unlock(&blka->mutex);\r\n} else {\r\nlxt = NULL;\r\n}\r\ndma_wmb();\r\nrhte->lxt_start = lxt;\r\ndma_wmb();\r\nrhte->lxt_cnt = rhte_src->lxt_cnt;\r\ndma_wmb();\r\ncxlflash_afu_sync(afu, ctxid, rhndl, AFU_LW_SYNC);\r\npr_debug("%s: returning\n", __func__);\r\nreturn 0;\r\n}\r\nint cxlflash_disk_clone(struct scsi_device *sdev,\r\nstruct dk_cxlflash_clone *clone)\r\n{\r\nstruct cxlflash_cfg *cfg = (struct cxlflash_cfg *)sdev->host->hostdata;\r\nstruct llun_info *lli = sdev->hostdata;\r\nstruct glun_info *gli = lli->parent;\r\nstruct blka *blka = &gli->blka;\r\nstruct afu *afu = cfg->afu;\r\nstruct dk_cxlflash_release release = { { 0 }, 0 };\r\nstruct ctx_info *ctxi_src = NULL,\r\n*ctxi_dst = NULL;\r\nstruct lun_access *lun_access_src, *lun_access_dst;\r\nu32 perms;\r\nu64 ctxid_src = DECODE_CTXID(clone->context_id_src),\r\nctxid_dst = DECODE_CTXID(clone->context_id_dst),\r\nrctxid_src = clone->context_id_src,\r\nrctxid_dst = clone->context_id_dst;\r\nint adap_fd_src = clone->adap_fd_src;\r\nint i, j;\r\nint rc = 0;\r\nbool found;\r\nLIST_HEAD(sidecar);\r\npr_debug("%s: ctxid_src=%llu ctxid_dst=%llu adap_fd_src=%d\n",\r\n__func__, ctxid_src, ctxid_dst, adap_fd_src);\r\nif (unlikely(rctxid_src == rctxid_dst)) {\r\nrc = -EINVAL;\r\ngoto out;\r\n}\r\nif (unlikely(gli->mode != MODE_VIRTUAL)) {\r\nrc = -EINVAL;\r\npr_debug("%s: Clone not supported on physical LUNs! (%d)\n",\r\n__func__, gli->mode);\r\ngoto out;\r\n}\r\nctxi_src = get_context(cfg, rctxid_src, lli, CTX_CTRL_CLONE);\r\nctxi_dst = get_context(cfg, rctxid_dst, lli, 0);\r\nif (unlikely(!ctxi_src || !ctxi_dst)) {\r\npr_debug("%s: Bad context! (%llu,%llu)\n", __func__,\r\nctxid_src, ctxid_dst);\r\nrc = -EINVAL;\r\ngoto out;\r\n}\r\nif (unlikely(adap_fd_src != ctxi_src->lfd)) {\r\npr_debug("%s: Invalid source adapter fd! (%d)\n",\r\n__func__, adap_fd_src);\r\nrc = -EINVAL;\r\ngoto out;\r\n}\r\nfor (i = 0; i < MAX_RHT_PER_CONTEXT; i++)\r\nif (ctxi_dst->rht_start[i].nmask != 0) {\r\nrc = -EINVAL;\r\ngoto out;\r\n}\r\nlist_for_each_entry(lun_access_src, &ctxi_src->luns, list) {\r\nfound = false;\r\nlist_for_each_entry(lun_access_dst, &ctxi_dst->luns, list)\r\nif (lun_access_dst->sdev == lun_access_src->sdev) {\r\nfound = true;\r\nbreak;\r\n}\r\nif (!found) {\r\nlun_access_dst = kzalloc(sizeof(*lun_access_dst),\r\nGFP_KERNEL);\r\nif (unlikely(!lun_access_dst)) {\r\npr_err("%s: Unable to allocate lun_access!\n",\r\n__func__);\r\nrc = -ENOMEM;\r\ngoto out;\r\n}\r\n*lun_access_dst = *lun_access_src;\r\nlist_add(&lun_access_dst->list, &sidecar);\r\n}\r\n}\r\nif (unlikely(!ctxi_src->rht_out)) {\r\npr_debug("%s: Nothing to clone!\n", __func__);\r\ngoto out_success;\r\n}\r\nperms = ctxi_dst->rht_perms;\r\nfor (i = 0; i < MAX_RHT_PER_CONTEXT; i++) {\r\nif (ctxi_src->rht_out == ctxi_dst->rht_out)\r\nbreak;\r\nif (ctxi_src->rht_start[i].nmask == 0)\r\ncontinue;\r\nctxi_dst->rht_out++;\r\nctxi_dst->rht_start[i].nmask = ctxi_src->rht_start[i].nmask;\r\nctxi_dst->rht_start[i].fp =\r\nSISL_RHT_FP_CLONE(ctxi_src->rht_start[i].fp, perms);\r\nctxi_dst->rht_lun[i] = ctxi_src->rht_lun[i];\r\nrc = clone_lxt(afu, blka, ctxid_dst, i,\r\n&ctxi_dst->rht_start[i],\r\n&ctxi_src->rht_start[i]);\r\nif (rc) {\r\nmarshal_clone_to_rele(clone, &release);\r\nfor (j = 0; j < i; j++) {\r\nrelease.rsrc_handle = j;\r\n_cxlflash_disk_release(sdev, ctxi_dst,\r\n&release);\r\n}\r\nrhte_checkin(ctxi_dst, &ctxi_dst->rht_start[i]);\r\ngoto err;\r\n}\r\ncxlflash_lun_attach(gli, gli->mode, false);\r\n}\r\nout_success:\r\nlist_splice(&sidecar, &ctxi_dst->luns);\r\nsys_close(adap_fd_src);\r\nout:\r\nif (ctxi_src)\r\nput_context(ctxi_src);\r\nif (ctxi_dst)\r\nput_context(ctxi_dst);\r\npr_debug("%s: returning rc=%d\n", __func__, rc);\r\nreturn rc;\r\nerr:\r\nlist_for_each_entry_safe(lun_access_src, lun_access_dst, &sidecar, list)\r\nkfree(lun_access_src);\r\ngoto out;\r\n}
