void sst_shim32_write(void __iomem *addr, u32 offset, u32 value)\r\n{\r\nwritel(value, addr + offset);\r\n}\r\nu32 sst_shim32_read(void __iomem *addr, u32 offset)\r\n{\r\nreturn readl(addr + offset);\r\n}\r\nvoid sst_shim32_write64(void __iomem *addr, u32 offset, u64 value)\r\n{\r\nmemcpy_toio(addr + offset, &value, sizeof(value));\r\n}\r\nu64 sst_shim32_read64(void __iomem *addr, u32 offset)\r\n{\r\nu64 val;\r\nmemcpy_fromio(&val, addr + offset, sizeof(val));\r\nreturn val;\r\n}\r\nstatic inline void _sst_memcpy_toio_32(volatile u32 __iomem *dest,\r\nu32 *src, size_t bytes)\r\n{\r\nint i, words = bytes >> 2;\r\nfor (i = 0; i < words; i++)\r\nwritel(src[i], dest + i);\r\n}\r\nstatic inline void _sst_memcpy_fromio_32(u32 *dest,\r\nconst volatile __iomem u32 *src, size_t bytes)\r\n{\r\nint i, words = bytes >> 2;\r\nfor (i = 0; i < words; i++)\r\ndest[i] = readl(src + i);\r\n}\r\nvoid sst_memcpy_toio_32(struct sst_dsp *sst,\r\nvoid __iomem *dest, void *src, size_t bytes)\r\n{\r\n_sst_memcpy_toio_32(dest, src, bytes);\r\n}\r\nvoid sst_memcpy_fromio_32(struct sst_dsp *sst, void *dest,\r\nvoid __iomem *src, size_t bytes)\r\n{\r\n_sst_memcpy_fromio_32(dest, src, bytes);\r\n}\r\nvoid sst_dsp_shim_write(struct sst_dsp *sst, u32 offset, u32 value)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&sst->spinlock, flags);\r\nsst->ops->write(sst->addr.shim, offset, value);\r\nspin_unlock_irqrestore(&sst->spinlock, flags);\r\n}\r\nu32 sst_dsp_shim_read(struct sst_dsp *sst, u32 offset)\r\n{\r\nunsigned long flags;\r\nu32 val;\r\nspin_lock_irqsave(&sst->spinlock, flags);\r\nval = sst->ops->read(sst->addr.shim, offset);\r\nspin_unlock_irqrestore(&sst->spinlock, flags);\r\nreturn val;\r\n}\r\nvoid sst_dsp_shim_write64(struct sst_dsp *sst, u32 offset, u64 value)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&sst->spinlock, flags);\r\nsst->ops->write64(sst->addr.shim, offset, value);\r\nspin_unlock_irqrestore(&sst->spinlock, flags);\r\n}\r\nu64 sst_dsp_shim_read64(struct sst_dsp *sst, u32 offset)\r\n{\r\nunsigned long flags;\r\nu64 val;\r\nspin_lock_irqsave(&sst->spinlock, flags);\r\nval = sst->ops->read64(sst->addr.shim, offset);\r\nspin_unlock_irqrestore(&sst->spinlock, flags);\r\nreturn val;\r\n}\r\nvoid sst_dsp_shim_write_unlocked(struct sst_dsp *sst, u32 offset, u32 value)\r\n{\r\nsst->ops->write(sst->addr.shim, offset, value);\r\n}\r\nu32 sst_dsp_shim_read_unlocked(struct sst_dsp *sst, u32 offset)\r\n{\r\nreturn sst->ops->read(sst->addr.shim, offset);\r\n}\r\nvoid sst_dsp_shim_write64_unlocked(struct sst_dsp *sst, u32 offset, u64 value)\r\n{\r\nsst->ops->write64(sst->addr.shim, offset, value);\r\n}\r\nu64 sst_dsp_shim_read64_unlocked(struct sst_dsp *sst, u32 offset)\r\n{\r\nreturn sst->ops->read64(sst->addr.shim, offset);\r\n}\r\nint sst_dsp_shim_update_bits_unlocked(struct sst_dsp *sst, u32 offset,\r\nu32 mask, u32 value)\r\n{\r\nbool change;\r\nunsigned int old, new;\r\nu32 ret;\r\nret = sst_dsp_shim_read_unlocked(sst, offset);\r\nold = ret;\r\nnew = (old & (~mask)) | (value & mask);\r\nchange = (old != new);\r\nif (change)\r\nsst_dsp_shim_write_unlocked(sst, offset, new);\r\nreturn change;\r\n}\r\nint sst_dsp_shim_update_bits64_unlocked(struct sst_dsp *sst, u32 offset,\r\nu64 mask, u64 value)\r\n{\r\nbool change;\r\nu64 old, new;\r\nold = sst_dsp_shim_read64_unlocked(sst, offset);\r\nnew = (old & (~mask)) | (value & mask);\r\nchange = (old != new);\r\nif (change)\r\nsst_dsp_shim_write64_unlocked(sst, offset, new);\r\nreturn change;\r\n}\r\nvoid sst_dsp_shim_update_bits_forced_unlocked(struct sst_dsp *sst, u32 offset,\r\nu32 mask, u32 value)\r\n{\r\nunsigned int old, new;\r\nu32 ret;\r\nret = sst_dsp_shim_read_unlocked(sst, offset);\r\nold = ret;\r\nnew = (old & (~mask)) | (value & mask);\r\nsst_dsp_shim_write_unlocked(sst, offset, new);\r\n}\r\nint sst_dsp_shim_update_bits(struct sst_dsp *sst, u32 offset,\r\nu32 mask, u32 value)\r\n{\r\nunsigned long flags;\r\nbool change;\r\nspin_lock_irqsave(&sst->spinlock, flags);\r\nchange = sst_dsp_shim_update_bits_unlocked(sst, offset, mask, value);\r\nspin_unlock_irqrestore(&sst->spinlock, flags);\r\nreturn change;\r\n}\r\nint sst_dsp_shim_update_bits64(struct sst_dsp *sst, u32 offset,\r\nu64 mask, u64 value)\r\n{\r\nunsigned long flags;\r\nbool change;\r\nspin_lock_irqsave(&sst->spinlock, flags);\r\nchange = sst_dsp_shim_update_bits64_unlocked(sst, offset, mask, value);\r\nspin_unlock_irqrestore(&sst->spinlock, flags);\r\nreturn change;\r\n}\r\nvoid sst_dsp_shim_update_bits_forced(struct sst_dsp *sst, u32 offset,\r\nu32 mask, u32 value)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&sst->spinlock, flags);\r\nsst_dsp_shim_update_bits_forced_unlocked(sst, offset, mask, value);\r\nspin_unlock_irqrestore(&sst->spinlock, flags);\r\n}\r\nint sst_dsp_register_poll(struct sst_dsp *ctx, u32 offset, u32 mask,\r\nu32 target, u32 timeout, char *operation)\r\n{\r\nint time, ret;\r\nu32 reg;\r\nbool done = false;\r\nfor (time = 0; time < 5; time++) {\r\nif ((sst_dsp_shim_read_unlocked(ctx, offset) & mask) == target) {\r\ndone = true;\r\nbreak;\r\n}\r\nmdelay(1);\r\n}\r\nif (done == false) {\r\ntimeout /= 10;\r\nfor (time = 0; time < timeout; time++) {\r\nif ((sst_dsp_shim_read_unlocked(ctx, offset) & mask) == target)\r\nbreak;\r\nusleep_range(5000, 10000);\r\n}\r\n}\r\nreg = sst_dsp_shim_read_unlocked(ctx, offset);\r\ndev_info(ctx->dev, "FW Poll Status: reg=%#x %s %s\n", reg, operation,\r\n(time < timeout) ? "successful" : "timedout");\r\nret = time < timeout ? 0 : -ETIME;\r\nreturn ret;\r\n}\r\nvoid sst_dsp_dump(struct sst_dsp *sst)\r\n{\r\nif (sst->ops->dump)\r\nsst->ops->dump(sst);\r\n}\r\nvoid sst_dsp_reset(struct sst_dsp *sst)\r\n{\r\nif (sst->ops->reset)\r\nsst->ops->reset(sst);\r\n}\r\nint sst_dsp_boot(struct sst_dsp *sst)\r\n{\r\nif (sst->ops->boot)\r\nsst->ops->boot(sst);\r\nreturn 0;\r\n}\r\nint sst_dsp_wake(struct sst_dsp *sst)\r\n{\r\nif (sst->ops->wake)\r\nreturn sst->ops->wake(sst);\r\nreturn 0;\r\n}\r\nvoid sst_dsp_sleep(struct sst_dsp *sst)\r\n{\r\nif (sst->ops->sleep)\r\nsst->ops->sleep(sst);\r\n}\r\nvoid sst_dsp_stall(struct sst_dsp *sst)\r\n{\r\nif (sst->ops->stall)\r\nsst->ops->stall(sst);\r\n}\r\nvoid sst_dsp_ipc_msg_tx(struct sst_dsp *dsp, u32 msg)\r\n{\r\nsst_dsp_shim_write_unlocked(dsp, SST_IPCX, msg | SST_IPCX_BUSY);\r\ntrace_sst_ipc_msg_tx(msg);\r\n}\r\nu32 sst_dsp_ipc_msg_rx(struct sst_dsp *dsp)\r\n{\r\nu32 msg;\r\nmsg = sst_dsp_shim_read_unlocked(dsp, SST_IPCX);\r\ntrace_sst_ipc_msg_rx(msg);\r\nreturn msg;\r\n}\r\nint sst_dsp_mailbox_init(struct sst_dsp *sst, u32 inbox_offset, size_t inbox_size,\r\nu32 outbox_offset, size_t outbox_size)\r\n{\r\nsst->mailbox.in_base = sst->addr.lpe + inbox_offset;\r\nsst->mailbox.out_base = sst->addr.lpe + outbox_offset;\r\nsst->mailbox.in_size = inbox_size;\r\nsst->mailbox.out_size = outbox_size;\r\nreturn 0;\r\n}\r\nvoid sst_dsp_outbox_write(struct sst_dsp *sst, void *message, size_t bytes)\r\n{\r\nu32 i;\r\ntrace_sst_ipc_outbox_write(bytes);\r\nmemcpy_toio(sst->mailbox.out_base, message, bytes);\r\nfor (i = 0; i < bytes; i += 4)\r\ntrace_sst_ipc_outbox_wdata(i, *(u32 *)(message + i));\r\n}\r\nvoid sst_dsp_outbox_read(struct sst_dsp *sst, void *message, size_t bytes)\r\n{\r\nu32 i;\r\ntrace_sst_ipc_outbox_read(bytes);\r\nmemcpy_fromio(message, sst->mailbox.out_base, bytes);\r\nfor (i = 0; i < bytes; i += 4)\r\ntrace_sst_ipc_outbox_rdata(i, *(u32 *)(message + i));\r\n}\r\nvoid sst_dsp_inbox_write(struct sst_dsp *sst, void *message, size_t bytes)\r\n{\r\nu32 i;\r\ntrace_sst_ipc_inbox_write(bytes);\r\nmemcpy_toio(sst->mailbox.in_base, message, bytes);\r\nfor (i = 0; i < bytes; i += 4)\r\ntrace_sst_ipc_inbox_wdata(i, *(u32 *)(message + i));\r\n}\r\nvoid sst_dsp_inbox_read(struct sst_dsp *sst, void *message, size_t bytes)\r\n{\r\nu32 i;\r\ntrace_sst_ipc_inbox_read(bytes);\r\nmemcpy_fromio(message, sst->mailbox.in_base, bytes);\r\nfor (i = 0; i < bytes; i += 4)\r\ntrace_sst_ipc_inbox_rdata(i, *(u32 *)(message + i));\r\n}\r\nstruct sst_dsp *sst_dsp_new(struct device *dev,\r\nstruct sst_dsp_device *sst_dev, struct sst_pdata *pdata)\r\n{\r\nstruct sst_dsp *sst;\r\nint err;\r\ndev_dbg(dev, "initialising audio DSP id 0x%x\n", pdata->id);\r\nsst = devm_kzalloc(dev, sizeof(*sst), GFP_KERNEL);\r\nif (sst == NULL)\r\nreturn NULL;\r\nspin_lock_init(&sst->spinlock);\r\nmutex_init(&sst->mutex);\r\nsst->dev = dev;\r\nsst->dma_dev = pdata->dma_dev;\r\nsst->thread_context = sst_dev->thread_context;\r\nsst->sst_dev = sst_dev;\r\nsst->id = pdata->id;\r\nsst->irq = pdata->irq;\r\nsst->ops = sst_dev->ops;\r\nsst->pdata = pdata;\r\nINIT_LIST_HEAD(&sst->used_block_list);\r\nINIT_LIST_HEAD(&sst->free_block_list);\r\nINIT_LIST_HEAD(&sst->module_list);\r\nINIT_LIST_HEAD(&sst->fw_list);\r\nINIT_LIST_HEAD(&sst->scratch_block_list);\r\nif (sst->ops->init) {\r\nerr = sst->ops->init(sst, pdata);\r\nif (err < 0)\r\nreturn NULL;\r\n}\r\nerr = request_threaded_irq(sst->irq, sst->ops->irq_handler,\r\nsst_dev->thread, IRQF_SHARED, "AudioDSP", sst);\r\nif (err)\r\ngoto irq_err;\r\nerr = sst_dma_new(sst);\r\nif (err)\r\ndev_warn(dev, "sst_dma_new failed %d\n", err);\r\nreturn sst;\r\nirq_err:\r\nif (sst->ops->free)\r\nsst->ops->free(sst);\r\nreturn NULL;\r\n}\r\nvoid sst_dsp_free(struct sst_dsp *sst)\r\n{\r\nfree_irq(sst->irq, sst);\r\nif (sst->ops->free)\r\nsst->ops->free(sst);\r\nsst_dma_free(sst->dma);\r\n}
