static void dw_hdmi_writel(u32 val, void __iomem *ptr)\r\n{\r\nwriteb_relaxed(val, ptr);\r\nwriteb_relaxed(val >> 8, ptr + 1);\r\nwriteb_relaxed(val >> 16, ptr + 2);\r\nwriteb_relaxed(val >> 24, ptr + 3);\r\n}\r\nstatic void dw_hdmi_reformat_iec958(struct snd_dw_hdmi *dw,\r\nsize_t offset, size_t bytes)\r\n{\r\nu32 *src = dw->buf_src + offset;\r\nu32 *dst = dw->buf_dst + offset;\r\nu32 *end = dw->buf_src + offset + bytes;\r\ndo {\r\nu32 b, sample = *src++;\r\nb = (sample & 8) << (28 - 3);\r\nsample >>= 4;\r\n*dst++ = sample | b;\r\n} while (src < end);\r\n}\r\nstatic u32 parity(u32 sample)\r\n{\r\nsample ^= sample >> 16;\r\nsample ^= sample >> 8;\r\nsample ^= sample >> 4;\r\nsample ^= sample >> 2;\r\nsample ^= sample >> 1;\r\nreturn (sample & 1) << 27;\r\n}\r\nstatic void dw_hdmi_reformat_s24(struct snd_dw_hdmi *dw,\r\nsize_t offset, size_t bytes)\r\n{\r\nu32 *src = dw->buf_src + offset;\r\nu32 *dst = dw->buf_dst + offset;\r\nu32 *end = dw->buf_src + offset + bytes;\r\ndo {\r\nunsigned i;\r\nu8 *cs;\r\ncs = dw->cs[dw->iec_offset++];\r\nif (dw->iec_offset >= 192)\r\ndw->iec_offset = 0;\r\ni = dw->channels;\r\ndo {\r\nu32 sample = *src++;\r\nsample &= ~0xff000000;\r\nsample |= *cs++ << 24;\r\nsample |= parity(sample & ~0xf8000000);\r\n*dst++ = sample;\r\n} while (--i);\r\n} while (src < end);\r\n}\r\nstatic void dw_hdmi_create_cs(struct snd_dw_hdmi *dw,\r\nstruct snd_pcm_runtime *runtime)\r\n{\r\nu8 cs[4];\r\nunsigned ch, i, j;\r\nsnd_pcm_create_iec958_consumer(runtime, cs, sizeof(cs));\r\nmemset(dw->cs, 0, sizeof(dw->cs));\r\nfor (ch = 0; ch < 8; ch++) {\r\ncs[2] &= ~IEC958_AES2_CON_CHANNEL;\r\ncs[2] |= (ch + 1) << 4;\r\nfor (i = 0; i < ARRAY_SIZE(cs); i++) {\r\nunsigned c = cs[i];\r\nfor (j = 0; j < 8; j++, c >>= 1)\r\ndw->cs[i * 8 + j][ch] = (c & 1) << 2;\r\n}\r\n}\r\ndw->cs[0][0] |= BIT(4);\r\n}\r\nstatic void dw_hdmi_start_dma(struct snd_dw_hdmi *dw)\r\n{\r\nvoid __iomem *base = dw->data.base;\r\nunsigned offset = dw->buf_offset;\r\nunsigned period = dw->buf_period;\r\nu32 start, stop;\r\ndw->reformat(dw, offset, period);\r\nwriteb_relaxed(HDMI_IH_AHBDMAAUD_STAT0_ALL,\r\nbase + HDMI_IH_AHBDMAAUD_STAT0);\r\nstart = dw->buf_addr + offset;\r\nstop = start + period - 1;\r\ndw_hdmi_writel(start, base + HDMI_AHB_DMA_STRADDR0);\r\ndw_hdmi_writel(stop, base + HDMI_AHB_DMA_STPADDR0);\r\nwriteb_relaxed((u8)~HDMI_AHB_DMA_MASK_DONE, base + HDMI_AHB_DMA_MASK);\r\nwriteb(HDMI_AHB_DMA_START_START, base + HDMI_AHB_DMA_START);\r\noffset += period;\r\nif (offset >= dw->buf_size)\r\noffset = 0;\r\ndw->buf_offset = offset;\r\n}\r\nstatic void dw_hdmi_stop_dma(struct snd_dw_hdmi *dw)\r\n{\r\nwriteb_relaxed(~0, dw->data.base + HDMI_AHB_DMA_MASK);\r\nwriteb_relaxed(HDMI_AHB_DMA_STOP_STOP, dw->data.base + HDMI_AHB_DMA_STOP);\r\n}\r\nstatic irqreturn_t snd_dw_hdmi_irq(int irq, void *data)\r\n{\r\nstruct snd_dw_hdmi *dw = data;\r\nstruct snd_pcm_substream *substream;\r\nunsigned stat;\r\nstat = readb_relaxed(dw->data.base + HDMI_IH_AHBDMAAUD_STAT0);\r\nif (!stat)\r\nreturn IRQ_NONE;\r\nwriteb_relaxed(stat, dw->data.base + HDMI_IH_AHBDMAAUD_STAT0);\r\nsubstream = dw->substream;\r\nif (stat & HDMI_IH_AHBDMAAUD_STAT0_DONE && substream) {\r\nsnd_pcm_period_elapsed(substream);\r\nspin_lock(&dw->lock);\r\nif (dw->substream)\r\ndw_hdmi_start_dma(dw);\r\nspin_unlock(&dw->lock);\r\n}\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int dw_hdmi_open(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nstruct snd_dw_hdmi *dw = substream->private_data;\r\nvoid __iomem *base = dw->data.base;\r\nint ret;\r\nruntime->hw = dw_hdmi_hw;\r\nret = snd_pcm_hw_constraint_eld(runtime, dw->data.eld);\r\nif (ret < 0)\r\nreturn ret;\r\nret = snd_pcm_limit_hw_rates(runtime);\r\nif (ret < 0)\r\nreturn ret;\r\nret = snd_pcm_hw_constraint_integer(runtime,\r\nSNDRV_PCM_HW_PARAM_PERIODS);\r\nif (ret < 0)\r\nreturn ret;\r\nret = snd_pcm_hw_constraint_minmax(runtime,\r\nSNDRV_PCM_HW_PARAM_BUFFER_SIZE,\r\n0, substream->dma_buffer.bytes);\r\nif (ret < 0)\r\nreturn ret;\r\nwriteb_relaxed(HDMI_AHB_DMA_CONF0_SW_FIFO_RST,\r\nbase + HDMI_AHB_DMA_CONF0);\r\nwriteb_relaxed(~0, base + HDMI_AHB_DMA_POL);\r\nwriteb_relaxed(~0, base + HDMI_AHB_DMA_BUFFPOL);\r\nwriteb_relaxed(~0, base + HDMI_AHB_DMA_MASK);\r\nwriteb_relaxed(~0, base + HDMI_IH_AHBDMAAUD_STAT0);\r\nret = request_irq(dw->data.irq, snd_dw_hdmi_irq, IRQF_SHARED,\r\n"dw-hdmi-audio", dw);\r\nif (ret)\r\nreturn ret;\r\nwriteb_relaxed(HDMI_IH_MUTE_AHBDMAAUD_STAT0_ALL &\r\n~HDMI_IH_MUTE_AHBDMAAUD_STAT0_DONE,\r\nbase + HDMI_IH_MUTE_AHBDMAAUD_STAT0);\r\nreturn 0;\r\n}\r\nstatic int dw_hdmi_close(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_dw_hdmi *dw = substream->private_data;\r\nwriteb_relaxed(HDMI_IH_MUTE_AHBDMAAUD_STAT0_ALL,\r\ndw->data.base + HDMI_IH_MUTE_AHBDMAAUD_STAT0);\r\nfree_irq(dw->data.irq, dw);\r\nreturn 0;\r\n}\r\nstatic int dw_hdmi_hw_free(struct snd_pcm_substream *substream)\r\n{\r\nreturn snd_pcm_lib_free_vmalloc_buffer(substream);\r\n}\r\nstatic int dw_hdmi_hw_params(struct snd_pcm_substream *substream,\r\nstruct snd_pcm_hw_params *params)\r\n{\r\nreturn snd_pcm_lib_alloc_vmalloc_buffer(substream,\r\nparams_buffer_bytes(params));\r\n}\r\nstatic int dw_hdmi_prepare(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nstruct snd_dw_hdmi *dw = substream->private_data;\r\nu8 threshold, conf0, conf1, layout, ca;\r\nswitch (dw->revision) {\r\ncase 0x0a:\r\nconf0 = HDMI_AHB_DMA_CONF0_BURST_MODE |\r\nHDMI_AHB_DMA_CONF0_INCR4;\r\nif (runtime->channels == 2)\r\nthreshold = 126;\r\nelse\r\nthreshold = 124;\r\nbreak;\r\ncase 0x1a:\r\nconf0 = HDMI_AHB_DMA_CONF0_BURST_MODE |\r\nHDMI_AHB_DMA_CONF0_INCR8;\r\nthreshold = 128;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\ndw_hdmi_set_sample_rate(dw->data.hdmi, runtime->rate);\r\nruntime->hw.fifo_size = threshold * 32;\r\nconf0 |= HDMI_AHB_DMA_CONF0_EN_HLOCK;\r\nconf1 = default_hdmi_channel_config[runtime->channels - 2].conf1;\r\nca = default_hdmi_channel_config[runtime->channels - 2].ca;\r\nif (runtime->channels > 2)\r\nlayout = HDMI_FC_AUDSCONF_LAYOUT1;\r\nelse\r\nlayout = HDMI_FC_AUDSCONF_LAYOUT0;\r\nwriteb_relaxed(threshold, dw->data.base + HDMI_AHB_DMA_THRSLD);\r\nwriteb_relaxed(conf0, dw->data.base + HDMI_AHB_DMA_CONF0);\r\nwriteb_relaxed(conf1, dw->data.base + HDMI_AHB_DMA_CONF1);\r\nwriteb_relaxed(layout, dw->data.base + HDMI_FC_AUDSCONF);\r\nwriteb_relaxed(ca, dw->data.base + HDMI_FC_AUDICONF2);\r\nswitch (runtime->format) {\r\ncase SNDRV_PCM_FORMAT_IEC958_SUBFRAME_LE:\r\ndw->reformat = dw_hdmi_reformat_iec958;\r\nbreak;\r\ncase SNDRV_PCM_FORMAT_S24_LE:\r\ndw_hdmi_create_cs(dw, runtime);\r\ndw->reformat = dw_hdmi_reformat_s24;\r\nbreak;\r\n}\r\ndw->iec_offset = 0;\r\ndw->channels = runtime->channels;\r\ndw->buf_src = runtime->dma_area;\r\ndw->buf_dst = substream->dma_buffer.area;\r\ndw->buf_addr = substream->dma_buffer.addr;\r\ndw->buf_period = snd_pcm_lib_period_bytes(substream);\r\ndw->buf_size = snd_pcm_lib_buffer_bytes(substream);\r\nreturn 0;\r\n}\r\nstatic int dw_hdmi_trigger(struct snd_pcm_substream *substream, int cmd)\r\n{\r\nstruct snd_dw_hdmi *dw = substream->private_data;\r\nunsigned long flags;\r\nint ret = 0;\r\nswitch (cmd) {\r\ncase SNDRV_PCM_TRIGGER_START:\r\nspin_lock_irqsave(&dw->lock, flags);\r\ndw->buf_offset = 0;\r\ndw->substream = substream;\r\ndw_hdmi_start_dma(dw);\r\ndw_hdmi_audio_enable(dw->data.hdmi);\r\nspin_unlock_irqrestore(&dw->lock, flags);\r\nsubstream->runtime->delay = substream->runtime->period_size;\r\nbreak;\r\ncase SNDRV_PCM_TRIGGER_STOP:\r\nspin_lock_irqsave(&dw->lock, flags);\r\ndw->substream = NULL;\r\ndw_hdmi_stop_dma(dw);\r\ndw_hdmi_audio_disable(dw->data.hdmi);\r\nspin_unlock_irqrestore(&dw->lock, flags);\r\nbreak;\r\ndefault:\r\nret = -EINVAL;\r\nbreak;\r\n}\r\nreturn ret;\r\n}\r\nstatic snd_pcm_uframes_t dw_hdmi_pointer(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nstruct snd_dw_hdmi *dw = substream->private_data;\r\nreturn bytes_to_frames(runtime, dw->buf_offset);\r\n}\r\nstatic int snd_dw_hdmi_probe(struct platform_device *pdev)\r\n{\r\nconst struct dw_hdmi_audio_data *data = pdev->dev.platform_data;\r\nstruct device *dev = pdev->dev.parent;\r\nstruct snd_dw_hdmi *dw;\r\nstruct snd_card *card;\r\nstruct snd_pcm *pcm;\r\nunsigned revision;\r\nint ret;\r\nwriteb_relaxed(HDMI_IH_MUTE_AHBDMAAUD_STAT0_ALL,\r\ndata->base + HDMI_IH_MUTE_AHBDMAAUD_STAT0);\r\nrevision = readb_relaxed(data->base + HDMI_REVISION_ID);\r\nif (revision != 0x0a && revision != 0x1a) {\r\ndev_err(dev, "dw-hdmi-audio: unknown revision 0x%02x\n",\r\nrevision);\r\nreturn -ENXIO;\r\n}\r\nret = snd_card_new(dev, SNDRV_DEFAULT_IDX1, SNDRV_DEFAULT_STR1,\r\nTHIS_MODULE, sizeof(struct snd_dw_hdmi), &card);\r\nif (ret < 0)\r\nreturn ret;\r\nstrlcpy(card->driver, DRIVER_NAME, sizeof(card->driver));\r\nstrlcpy(card->shortname, "DW-HDMI", sizeof(card->shortname));\r\nsnprintf(card->longname, sizeof(card->longname),\r\n"%s rev 0x%02x, irq %d", card->shortname, revision,\r\ndata->irq);\r\ndw = card->private_data;\r\ndw->card = card;\r\ndw->data = *data;\r\ndw->revision = revision;\r\nspin_lock_init(&dw->lock);\r\nret = snd_pcm_new(card, "DW HDMI", 0, 1, 0, &pcm);\r\nif (ret < 0)\r\ngoto err;\r\ndw->pcm = pcm;\r\npcm->private_data = dw;\r\nstrlcpy(pcm->name, DRIVER_NAME, sizeof(pcm->name));\r\nsnd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_PLAYBACK, &snd_dw_hdmi_ops);\r\nsnd_pcm_lib_preallocate_pages_for_all(pcm, SNDRV_DMA_TYPE_DEV,\r\ndev, 128 * 1024, 1024 * 1024);\r\nret = snd_card_register(card);\r\nif (ret < 0)\r\ngoto err;\r\nplatform_set_drvdata(pdev, dw);\r\nreturn 0;\r\nerr:\r\nsnd_card_free(card);\r\nreturn ret;\r\n}\r\nstatic int snd_dw_hdmi_remove(struct platform_device *pdev)\r\n{\r\nstruct snd_dw_hdmi *dw = platform_get_drvdata(pdev);\r\nsnd_card_free(dw->card);\r\nreturn 0;\r\n}\r\nstatic int snd_dw_hdmi_suspend(struct device *dev)\r\n{\r\nstruct snd_dw_hdmi *dw = dev_get_drvdata(dev);\r\nsnd_power_change_state(dw->card, SNDRV_CTL_POWER_D3cold);\r\nsnd_pcm_suspend_all(dw->pcm);\r\nreturn 0;\r\n}\r\nstatic int snd_dw_hdmi_resume(struct device *dev)\r\n{\r\nstruct snd_dw_hdmi *dw = dev_get_drvdata(dev);\r\nsnd_power_change_state(dw->card, SNDRV_CTL_POWER_D0);\r\nreturn 0;\r\n}
