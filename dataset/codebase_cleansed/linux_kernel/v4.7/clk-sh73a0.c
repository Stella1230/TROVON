static struct clk * __init\r\nsh73a0_cpg_register_clock(struct device_node *np, struct sh73a0_cpg *cpg,\r\nconst char *name)\r\n{\r\nconst struct clk_div_table *table = NULL;\r\nunsigned int shift, reg, width;\r\nconst char *parent_name;\r\nunsigned int mult = 1;\r\nunsigned int div = 1;\r\nif (!strcmp(name, "main")) {\r\nu32 parent_idx = (clk_readl(cpg->reg + CPG_CKSCR) >> 28) & 3;\r\nparent_name = of_clk_get_parent_name(np, parent_idx >> 1);\r\ndiv = (parent_idx & 1) + 1;\r\n} else if (!strncmp(name, "pll", 3)) {\r\nvoid __iomem *enable_reg = cpg->reg;\r\nu32 enable_bit = name[3] - '0';\r\nparent_name = "main";\r\nswitch (enable_bit) {\r\ncase 0:\r\nenable_reg += CPG_PLL0CR;\r\nbreak;\r\ncase 1:\r\nenable_reg += CPG_PLL1CR;\r\nbreak;\r\ncase 2:\r\nenable_reg += CPG_PLL2CR;\r\nbreak;\r\ncase 3:\r\nenable_reg += CPG_PLL3CR;\r\nbreak;\r\ndefault:\r\nreturn ERR_PTR(-EINVAL);\r\n}\r\nif (clk_readl(cpg->reg + CPG_PLLECR) & BIT(enable_bit)) {\r\nmult = ((clk_readl(enable_reg) >> 24) & 0x3f) + 1;\r\nif (enable_bit == 1 || enable_bit == 2)\r\nif (clk_readl(enable_reg) & BIT(20))\r\nmult *= 2;\r\n}\r\n} else if (!strcmp(name, "dsi0phy") || !strcmp(name, "dsi1phy")) {\r\nu32 phy_no = name[3] - '0';\r\nvoid __iomem *dsi_reg = cpg->reg +\r\n(phy_no ? CPG_DSI1PHYCR : CPG_DSI0PHYCR);\r\nparent_name = phy_no ? "dsi1pck" : "dsi0pck";\r\nmult = __raw_readl(dsi_reg);\r\nif (!(mult & 0x8000))\r\nmult = 1;\r\nelse\r\nmult = (mult & 0x3f) + 1;\r\n} else if (!strcmp(name, "z")) {\r\nparent_name = "pll0";\r\ntable = z_div_table;\r\nreg = CPG_FRQCRB;\r\nshift = 24;\r\nwidth = 5;\r\n} else {\r\nstruct div4_clk *c;\r\nfor (c = div4_clks; c->name; c++) {\r\nif (!strcmp(name, c->name)) {\r\nparent_name = c->parent;\r\ntable = div4_div_table;\r\nreg = c->reg;\r\nshift = c->shift;\r\nwidth = 4;\r\nbreak;\r\n}\r\n}\r\nif (!c->name)\r\nreturn ERR_PTR(-EINVAL);\r\n}\r\nif (!table) {\r\nreturn clk_register_fixed_factor(NULL, name, parent_name, 0,\r\nmult, div);\r\n} else {\r\nreturn clk_register_divider_table(NULL, name, parent_name, 0,\r\ncpg->reg + reg, shift, width, 0,\r\ntable, &cpg->lock);\r\n}\r\n}\r\nstatic void __init sh73a0_cpg_clocks_init(struct device_node *np)\r\n{\r\nstruct sh73a0_cpg *cpg;\r\nstruct clk **clks;\r\nunsigned int i;\r\nint num_clks;\r\nnum_clks = of_property_count_strings(np, "clock-output-names");\r\nif (num_clks < 0) {\r\npr_err("%s: failed to count clocks\n", __func__);\r\nreturn;\r\n}\r\ncpg = kzalloc(sizeof(*cpg), GFP_KERNEL);\r\nclks = kcalloc(num_clks, sizeof(*clks), GFP_KERNEL);\r\nif (cpg == NULL || clks == NULL) {\r\nreturn;\r\n}\r\nspin_lock_init(&cpg->lock);\r\ncpg->data.clks = clks;\r\ncpg->data.clk_num = num_clks;\r\ncpg->reg = of_iomap(np, 0);\r\nif (WARN_ON(cpg->reg == NULL))\r\nreturn;\r\nclk_writel(0x108, cpg->reg + CPG_SD0CKCR);\r\nclk_writel(0x108, cpg->reg + CPG_SD1CKCR);\r\nclk_writel(0x108, cpg->reg + CPG_SD2CKCR);\r\nfor (i = 0; i < num_clks; ++i) {\r\nconst char *name;\r\nstruct clk *clk;\r\nof_property_read_string_index(np, "clock-output-names", i,\r\n&name);\r\nclk = sh73a0_cpg_register_clock(np, cpg, name);\r\nif (IS_ERR(clk))\r\npr_err("%s: failed to register %s %s clock (%ld)\n",\r\n__func__, np->name, name, PTR_ERR(clk));\r\nelse\r\ncpg->data.clks[i] = clk;\r\n}\r\nof_clk_add_provider(np, of_clk_src_onecell_get, &cpg->data);\r\n}
