void drbd_md_endio(struct bio *bio)\r\n{\r\nstruct drbd_device *device;\r\ndevice = bio->bi_private;\r\ndevice->md_io.error = bio->bi_error;\r\ndrbd_md_put_buffer(device);\r\ndevice->md_io.done = 1;\r\nwake_up(&device->misc_wait);\r\nbio_put(bio);\r\nif (device->ldev)\r\nput_ldev(device);\r\n}\r\nstatic void drbd_endio_read_sec_final(struct drbd_peer_request *peer_req) __releases(local)\r\n{\r\nunsigned long flags = 0;\r\nstruct drbd_peer_device *peer_device = peer_req->peer_device;\r\nstruct drbd_device *device = peer_device->device;\r\nspin_lock_irqsave(&device->resource->req_lock, flags);\r\ndevice->read_cnt += peer_req->i.size >> 9;\r\nlist_del(&peer_req->w.list);\r\nif (list_empty(&device->read_ee))\r\nwake_up(&device->ee_wait);\r\nif (test_bit(__EE_WAS_ERROR, &peer_req->flags))\r\n__drbd_chk_io_error(device, DRBD_READ_ERROR);\r\nspin_unlock_irqrestore(&device->resource->req_lock, flags);\r\ndrbd_queue_work(&peer_device->connection->sender_work, &peer_req->w);\r\nput_ldev(device);\r\n}\r\nvoid drbd_endio_write_sec_final(struct drbd_peer_request *peer_req) __releases(local)\r\n{\r\nunsigned long flags = 0;\r\nstruct drbd_peer_device *peer_device = peer_req->peer_device;\r\nstruct drbd_device *device = peer_device->device;\r\nstruct drbd_connection *connection = peer_device->connection;\r\nstruct drbd_interval i;\r\nint do_wake;\r\nu64 block_id;\r\nint do_al_complete_io;\r\ni = peer_req->i;\r\ndo_al_complete_io = peer_req->flags & EE_CALL_AL_COMPLETE_IO;\r\nblock_id = peer_req->block_id;\r\npeer_req->flags &= ~EE_CALL_AL_COMPLETE_IO;\r\nspin_lock_irqsave(&device->resource->req_lock, flags);\r\ndevice->writ_cnt += peer_req->i.size >> 9;\r\nlist_move_tail(&peer_req->w.list, &device->done_ee);\r\ndo_wake = list_empty(block_id == ID_SYNCER ? &device->sync_ee : &device->active_ee);\r\nif (peer_req->flags & EE_WAS_ERROR)\r\n__drbd_chk_io_error(device, DRBD_WRITE_ERROR);\r\nif (connection->cstate >= C_WF_REPORT_PARAMS) {\r\nkref_get(&device->kref);\r\nif (!queue_work(connection->ack_sender, &peer_device->send_acks_work))\r\nkref_put(&device->kref, drbd_destroy_device);\r\n}\r\nspin_unlock_irqrestore(&device->resource->req_lock, flags);\r\nif (block_id == ID_SYNCER)\r\ndrbd_rs_complete_io(device, i.sector);\r\nif (do_wake)\r\nwake_up(&device->ee_wait);\r\nif (do_al_complete_io)\r\ndrbd_al_complete_io(device, &i);\r\nput_ldev(device);\r\n}\r\nvoid drbd_peer_request_endio(struct bio *bio)\r\n{\r\nstruct drbd_peer_request *peer_req = bio->bi_private;\r\nstruct drbd_device *device = peer_req->peer_device->device;\r\nint is_write = bio_data_dir(bio) == WRITE;\r\nint is_discard = !!(bio->bi_rw & REQ_DISCARD);\r\nif (bio->bi_error && __ratelimit(&drbd_ratelimit_state))\r\ndrbd_warn(device, "%s: error=%d s=%llus\n",\r\nis_write ? (is_discard ? "discard" : "write")\r\n: "read", bio->bi_error,\r\n(unsigned long long)peer_req->i.sector);\r\nif (bio->bi_error)\r\nset_bit(__EE_WAS_ERROR, &peer_req->flags);\r\nbio_put(bio);\r\nif (atomic_dec_and_test(&peer_req->pending_bios)) {\r\nif (is_write)\r\ndrbd_endio_write_sec_final(peer_req);\r\nelse\r\ndrbd_endio_read_sec_final(peer_req);\r\n}\r\n}\r\nvoid drbd_panic_after_delayed_completion_of_aborted_request(struct drbd_device *device)\r\n{\r\npanic("drbd%u %s/%u potential random memory corruption caused by delayed completion of aborted local request\n",\r\ndevice->minor, device->resource->name, device->vnr);\r\n}\r\nvoid drbd_request_endio(struct bio *bio)\r\n{\r\nunsigned long flags;\r\nstruct drbd_request *req = bio->bi_private;\r\nstruct drbd_device *device = req->device;\r\nstruct bio_and_error m;\r\nenum drbd_req_event what;\r\nif (unlikely(req->rq_state & RQ_LOCAL_ABORTED)) {\r\nif (__ratelimit(&drbd_ratelimit_state))\r\ndrbd_emerg(device, "delayed completion of aborted local request; disk-timeout may be too aggressive\n");\r\nif (!bio->bi_error)\r\ndrbd_panic_after_delayed_completion_of_aborted_request(device);\r\n}\r\nif (unlikely(bio->bi_error)) {\r\nif (bio->bi_rw & REQ_DISCARD)\r\nwhat = (bio->bi_error == -EOPNOTSUPP)\r\n? DISCARD_COMPLETED_NOTSUPP\r\n: DISCARD_COMPLETED_WITH_ERROR;\r\nelse\r\nwhat = (bio_data_dir(bio) == WRITE)\r\n? WRITE_COMPLETED_WITH_ERROR\r\n: (bio_rw(bio) == READ)\r\n? READ_COMPLETED_WITH_ERROR\r\n: READ_AHEAD_COMPLETED_WITH_ERROR;\r\n} else\r\nwhat = COMPLETED_OK;\r\nbio_put(req->private_bio);\r\nreq->private_bio = ERR_PTR(bio->bi_error);\r\nspin_lock_irqsave(&device->resource->req_lock, flags);\r\n__req_mod(req, what, &m);\r\nspin_unlock_irqrestore(&device->resource->req_lock, flags);\r\nput_ldev(device);\r\nif (m.bio)\r\ncomplete_master_bio(device, &m);\r\n}\r\nvoid drbd_csum_ee(struct crypto_ahash *tfm, struct drbd_peer_request *peer_req, void *digest)\r\n{\r\nAHASH_REQUEST_ON_STACK(req, tfm);\r\nstruct scatterlist sg;\r\nstruct page *page = peer_req->pages;\r\nstruct page *tmp;\r\nunsigned len;\r\nahash_request_set_tfm(req, tfm);\r\nahash_request_set_callback(req, 0, NULL, NULL);\r\nsg_init_table(&sg, 1);\r\ncrypto_ahash_init(req);\r\nwhile ((tmp = page_chain_next(page))) {\r\nsg_set_page(&sg, page, PAGE_SIZE, 0);\r\nahash_request_set_crypt(req, &sg, NULL, sg.length);\r\ncrypto_ahash_update(req);\r\npage = tmp;\r\n}\r\nlen = peer_req->i.size & (PAGE_SIZE - 1);\r\nsg_set_page(&sg, page, len ?: PAGE_SIZE, 0);\r\nahash_request_set_crypt(req, &sg, digest, sg.length);\r\ncrypto_ahash_finup(req);\r\nahash_request_zero(req);\r\n}\r\nvoid drbd_csum_bio(struct crypto_ahash *tfm, struct bio *bio, void *digest)\r\n{\r\nAHASH_REQUEST_ON_STACK(req, tfm);\r\nstruct scatterlist sg;\r\nstruct bio_vec bvec;\r\nstruct bvec_iter iter;\r\nahash_request_set_tfm(req, tfm);\r\nahash_request_set_callback(req, 0, NULL, NULL);\r\nsg_init_table(&sg, 1);\r\ncrypto_ahash_init(req);\r\nbio_for_each_segment(bvec, bio, iter) {\r\nsg_set_page(&sg, bvec.bv_page, bvec.bv_len, bvec.bv_offset);\r\nahash_request_set_crypt(req, &sg, NULL, sg.length);\r\ncrypto_ahash_update(req);\r\n}\r\nahash_request_set_crypt(req, NULL, digest, 0);\r\ncrypto_ahash_final(req);\r\nahash_request_zero(req);\r\n}\r\nstatic int w_e_send_csum(struct drbd_work *w, int cancel)\r\n{\r\nstruct drbd_peer_request *peer_req = container_of(w, struct drbd_peer_request, w);\r\nstruct drbd_peer_device *peer_device = peer_req->peer_device;\r\nstruct drbd_device *device = peer_device->device;\r\nint digest_size;\r\nvoid *digest;\r\nint err = 0;\r\nif (unlikely(cancel))\r\ngoto out;\r\nif (unlikely((peer_req->flags & EE_WAS_ERROR) != 0))\r\ngoto out;\r\ndigest_size = crypto_ahash_digestsize(peer_device->connection->csums_tfm);\r\ndigest = kmalloc(digest_size, GFP_NOIO);\r\nif (digest) {\r\nsector_t sector = peer_req->i.sector;\r\nunsigned int size = peer_req->i.size;\r\ndrbd_csum_ee(peer_device->connection->csums_tfm, peer_req, digest);\r\ndrbd_free_peer_req(device, peer_req);\r\npeer_req = NULL;\r\ninc_rs_pending(device);\r\nerr = drbd_send_drequest_csum(peer_device, sector, size,\r\ndigest, digest_size,\r\nP_CSUM_RS_REQUEST);\r\nkfree(digest);\r\n} else {\r\ndrbd_err(device, "kmalloc() of digest failed.\n");\r\nerr = -ENOMEM;\r\n}\r\nout:\r\nif (peer_req)\r\ndrbd_free_peer_req(device, peer_req);\r\nif (unlikely(err))\r\ndrbd_err(device, "drbd_send_drequest(..., csum) failed\n");\r\nreturn err;\r\n}\r\nstatic int read_for_csum(struct drbd_peer_device *peer_device, sector_t sector, int size)\r\n{\r\nstruct drbd_device *device = peer_device->device;\r\nstruct drbd_peer_request *peer_req;\r\nif (!get_ldev(device))\r\nreturn -EIO;\r\npeer_req = drbd_alloc_peer_req(peer_device, ID_SYNCER , sector,\r\nsize, true , GFP_TRY);\r\nif (!peer_req)\r\ngoto defer;\r\npeer_req->w.cb = w_e_send_csum;\r\nspin_lock_irq(&device->resource->req_lock);\r\nlist_add_tail(&peer_req->w.list, &device->read_ee);\r\nspin_unlock_irq(&device->resource->req_lock);\r\natomic_add(size >> 9, &device->rs_sect_ev);\r\nif (drbd_submit_peer_request(device, peer_req, READ, DRBD_FAULT_RS_RD) == 0)\r\nreturn 0;\r\nspin_lock_irq(&device->resource->req_lock);\r\nlist_del(&peer_req->w.list);\r\nspin_unlock_irq(&device->resource->req_lock);\r\ndrbd_free_peer_req(device, peer_req);\r\ndefer:\r\nput_ldev(device);\r\nreturn -EAGAIN;\r\n}\r\nint w_resync_timer(struct drbd_work *w, int cancel)\r\n{\r\nstruct drbd_device *device =\r\ncontainer_of(w, struct drbd_device, resync_work);\r\nswitch (device->state.conn) {\r\ncase C_VERIFY_S:\r\nmake_ov_request(device, cancel);\r\nbreak;\r\ncase C_SYNC_TARGET:\r\nmake_resync_request(device, cancel);\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nvoid resync_timer_fn(unsigned long data)\r\n{\r\nstruct drbd_device *device = (struct drbd_device *) data;\r\ndrbd_queue_work_if_unqueued(\r\n&first_peer_device(device)->connection->sender_work,\r\n&device->resync_work);\r\n}\r\nstatic void fifo_set(struct fifo_buffer *fb, int value)\r\n{\r\nint i;\r\nfor (i = 0; i < fb->size; i++)\r\nfb->values[i] = value;\r\n}\r\nstatic int fifo_push(struct fifo_buffer *fb, int value)\r\n{\r\nint ov;\r\nov = fb->values[fb->head_index];\r\nfb->values[fb->head_index++] = value;\r\nif (fb->head_index >= fb->size)\r\nfb->head_index = 0;\r\nreturn ov;\r\n}\r\nstatic void fifo_add_val(struct fifo_buffer *fb, int value)\r\n{\r\nint i;\r\nfor (i = 0; i < fb->size; i++)\r\nfb->values[i] += value;\r\n}\r\nstruct fifo_buffer *fifo_alloc(int fifo_size)\r\n{\r\nstruct fifo_buffer *fb;\r\nfb = kzalloc(sizeof(struct fifo_buffer) + sizeof(int) * fifo_size, GFP_NOIO);\r\nif (!fb)\r\nreturn NULL;\r\nfb->head_index = 0;\r\nfb->size = fifo_size;\r\nfb->total = 0;\r\nreturn fb;\r\n}\r\nstatic int drbd_rs_controller(struct drbd_device *device, unsigned int sect_in)\r\n{\r\nstruct disk_conf *dc;\r\nunsigned int want;\r\nint req_sect;\r\nint correction;\r\nint cps;\r\nint steps;\r\nint curr_corr;\r\nint max_sect;\r\nstruct fifo_buffer *plan;\r\ndc = rcu_dereference(device->ldev->disk_conf);\r\nplan = rcu_dereference(device->rs_plan_s);\r\nsteps = plan->size;\r\nif (device->rs_in_flight + sect_in == 0) {\r\nwant = ((dc->resync_rate * 2 * SLEEP_TIME) / HZ) * steps;\r\n} else {\r\nwant = dc->c_fill_target ? dc->c_fill_target :\r\nsect_in * dc->c_delay_target * HZ / (SLEEP_TIME * 10);\r\n}\r\ncorrection = want - device->rs_in_flight - plan->total;\r\ncps = correction / steps;\r\nfifo_add_val(plan, cps);\r\nplan->total += cps * steps;\r\ncurr_corr = fifo_push(plan, 0);\r\nplan->total -= curr_corr;\r\nreq_sect = sect_in + curr_corr;\r\nif (req_sect < 0)\r\nreq_sect = 0;\r\nmax_sect = (dc->c_max_rate * 2 * SLEEP_TIME) / HZ;\r\nif (req_sect > max_sect)\r\nreq_sect = max_sect;\r\nreturn req_sect;\r\n}\r\nstatic int drbd_rs_number_requests(struct drbd_device *device)\r\n{\r\nunsigned int sect_in;\r\nint number, mxb;\r\nsect_in = atomic_xchg(&device->rs_sect_in, 0);\r\ndevice->rs_in_flight -= sect_in;\r\nrcu_read_lock();\r\nmxb = drbd_get_max_buffers(device) / 2;\r\nif (rcu_dereference(device->rs_plan_s)->size) {\r\nnumber = drbd_rs_controller(device, sect_in) >> (BM_BLOCK_SHIFT - 9);\r\ndevice->c_sync_rate = number * HZ * (BM_BLOCK_SIZE / 1024) / SLEEP_TIME;\r\n} else {\r\ndevice->c_sync_rate = rcu_dereference(device->ldev->disk_conf)->resync_rate;\r\nnumber = SLEEP_TIME * device->c_sync_rate / ((BM_BLOCK_SIZE / 1024) * HZ);\r\n}\r\nrcu_read_unlock();\r\nif (mxb - device->rs_in_flight/8 < number)\r\nnumber = mxb - device->rs_in_flight/8;\r\nreturn number;\r\n}\r\nstatic int make_resync_request(struct drbd_device *const device, int cancel)\r\n{\r\nstruct drbd_peer_device *const peer_device = first_peer_device(device);\r\nstruct drbd_connection *const connection = peer_device ? peer_device->connection : NULL;\r\nunsigned long bit;\r\nsector_t sector;\r\nconst sector_t capacity = drbd_get_capacity(device->this_bdev);\r\nint max_bio_size;\r\nint number, rollback_i, size;\r\nint align, requeue = 0;\r\nint i = 0;\r\nif (unlikely(cancel))\r\nreturn 0;\r\nif (device->rs_total == 0) {\r\ndrbd_resync_finished(device);\r\nreturn 0;\r\n}\r\nif (!get_ldev(device)) {\r\ndrbd_err(device, "Disk broke down during resync!\n");\r\nreturn 0;\r\n}\r\nmax_bio_size = queue_max_hw_sectors(device->rq_queue) << 9;\r\nnumber = drbd_rs_number_requests(device);\r\nif (number <= 0)\r\ngoto requeue;\r\nfor (i = 0; i < number; i++) {\r\nmutex_lock(&connection->data.mutex);\r\nif (connection->data.socket) {\r\nstruct sock *sk = connection->data.socket->sk;\r\nint queued = sk->sk_wmem_queued;\r\nint sndbuf = sk->sk_sndbuf;\r\nif (queued > sndbuf / 2) {\r\nrequeue = 1;\r\nif (sk->sk_socket)\r\nset_bit(SOCK_NOSPACE, &sk->sk_socket->flags);\r\n}\r\n} else\r\nrequeue = 1;\r\nmutex_unlock(&connection->data.mutex);\r\nif (requeue)\r\ngoto requeue;\r\nnext_sector:\r\nsize = BM_BLOCK_SIZE;\r\nbit = drbd_bm_find_next(device, device->bm_resync_fo);\r\nif (bit == DRBD_END_OF_BITMAP) {\r\ndevice->bm_resync_fo = drbd_bm_bits(device);\r\nput_ldev(device);\r\nreturn 0;\r\n}\r\nsector = BM_BIT_TO_SECT(bit);\r\nif (drbd_try_rs_begin_io(device, sector)) {\r\ndevice->bm_resync_fo = bit;\r\ngoto requeue;\r\n}\r\ndevice->bm_resync_fo = bit + 1;\r\nif (unlikely(drbd_bm_test_bit(device, bit) == 0)) {\r\ndrbd_rs_complete_io(device, sector);\r\ngoto next_sector;\r\n}\r\n#if DRBD_MAX_BIO_SIZE > BM_BLOCK_SIZE\r\nalign = 1;\r\nrollback_i = i;\r\nwhile (i < number) {\r\nif (size + BM_BLOCK_SIZE > max_bio_size)\r\nbreak;\r\nif (sector & ((1<<(align+3))-1))\r\nbreak;\r\nif (((bit+1) & BM_BLOCKS_PER_BM_EXT_MASK) == 0)\r\nbreak;\r\nif (drbd_bm_test_bit(device, bit+1) != 1)\r\nbreak;\r\nbit++;\r\nsize += BM_BLOCK_SIZE;\r\nif ((BM_BLOCK_SIZE << align) <= size)\r\nalign++;\r\ni++;\r\n}\r\nif (size > BM_BLOCK_SIZE)\r\ndevice->bm_resync_fo = bit + 1;\r\n#endif\r\nif (sector + (size>>9) > capacity)\r\nsize = (capacity-sector)<<9;\r\nif (device->use_csums) {\r\nswitch (read_for_csum(peer_device, sector, size)) {\r\ncase -EIO:\r\nput_ldev(device);\r\nreturn -EIO;\r\ncase -EAGAIN:\r\ndrbd_rs_complete_io(device, sector);\r\ndevice->bm_resync_fo = BM_SECT_TO_BIT(sector);\r\ni = rollback_i;\r\ngoto requeue;\r\ncase 0:\r\nbreak;\r\ndefault:\r\nBUG();\r\n}\r\n} else {\r\nint err;\r\ninc_rs_pending(device);\r\nerr = drbd_send_drequest(peer_device, P_RS_DATA_REQUEST,\r\nsector, size, ID_SYNCER);\r\nif (err) {\r\ndrbd_err(device, "drbd_send_drequest() failed, aborting...\n");\r\ndec_rs_pending(device);\r\nput_ldev(device);\r\nreturn err;\r\n}\r\n}\r\n}\r\nif (device->bm_resync_fo >= drbd_bm_bits(device)) {\r\nput_ldev(device);\r\nreturn 0;\r\n}\r\nrequeue:\r\ndevice->rs_in_flight += (i << (BM_BLOCK_SHIFT - 9));\r\nmod_timer(&device->resync_timer, jiffies + SLEEP_TIME);\r\nput_ldev(device);\r\nreturn 0;\r\n}\r\nstatic int make_ov_request(struct drbd_device *device, int cancel)\r\n{\r\nint number, i, size;\r\nsector_t sector;\r\nconst sector_t capacity = drbd_get_capacity(device->this_bdev);\r\nbool stop_sector_reached = false;\r\nif (unlikely(cancel))\r\nreturn 1;\r\nnumber = drbd_rs_number_requests(device);\r\nsector = device->ov_position;\r\nfor (i = 0; i < number; i++) {\r\nif (sector >= capacity)\r\nreturn 1;\r\nstop_sector_reached = i > 0\r\n&& verify_can_do_stop_sector(device)\r\n&& sector >= device->ov_stop_sector;\r\nif (stop_sector_reached)\r\nbreak;\r\nsize = BM_BLOCK_SIZE;\r\nif (drbd_try_rs_begin_io(device, sector)) {\r\ndevice->ov_position = sector;\r\ngoto requeue;\r\n}\r\nif (sector + (size>>9) > capacity)\r\nsize = (capacity-sector)<<9;\r\ninc_rs_pending(device);\r\nif (drbd_send_ov_request(first_peer_device(device), sector, size)) {\r\ndec_rs_pending(device);\r\nreturn 0;\r\n}\r\nsector += BM_SECT_PER_BIT;\r\n}\r\ndevice->ov_position = sector;\r\nrequeue:\r\ndevice->rs_in_flight += (i << (BM_BLOCK_SHIFT - 9));\r\nif (i == 0 || !stop_sector_reached)\r\nmod_timer(&device->resync_timer, jiffies + SLEEP_TIME);\r\nreturn 1;\r\n}\r\nint w_ov_finished(struct drbd_work *w, int cancel)\r\n{\r\nstruct drbd_device_work *dw =\r\ncontainer_of(w, struct drbd_device_work, w);\r\nstruct drbd_device *device = dw->device;\r\nkfree(dw);\r\nov_out_of_sync_print(device);\r\ndrbd_resync_finished(device);\r\nreturn 0;\r\n}\r\nstatic int w_resync_finished(struct drbd_work *w, int cancel)\r\n{\r\nstruct drbd_device_work *dw =\r\ncontainer_of(w, struct drbd_device_work, w);\r\nstruct drbd_device *device = dw->device;\r\nkfree(dw);\r\ndrbd_resync_finished(device);\r\nreturn 0;\r\n}\r\nstatic void ping_peer(struct drbd_device *device)\r\n{\r\nstruct drbd_connection *connection = first_peer_device(device)->connection;\r\nclear_bit(GOT_PING_ACK, &connection->flags);\r\nrequest_ping(connection);\r\nwait_event(connection->ping_wait,\r\ntest_bit(GOT_PING_ACK, &connection->flags) || device->state.conn < C_CONNECTED);\r\n}\r\nint drbd_resync_finished(struct drbd_device *device)\r\n{\r\nunsigned long db, dt, dbdt;\r\nunsigned long n_oos;\r\nunion drbd_state os, ns;\r\nstruct drbd_device_work *dw;\r\nchar *khelper_cmd = NULL;\r\nint verify_done = 0;\r\nif (drbd_rs_del_all(device)) {\r\nschedule_timeout_interruptible(HZ / 10);\r\ndw = kmalloc(sizeof(struct drbd_device_work), GFP_ATOMIC);\r\nif (dw) {\r\ndw->w.cb = w_resync_finished;\r\ndw->device = device;\r\ndrbd_queue_work(&first_peer_device(device)->connection->sender_work,\r\n&dw->w);\r\nreturn 1;\r\n}\r\ndrbd_err(device, "Warn failed to drbd_rs_del_all() and to kmalloc(dw).\n");\r\n}\r\ndt = (jiffies - device->rs_start - device->rs_paused) / HZ;\r\nif (dt <= 0)\r\ndt = 1;\r\ndb = device->rs_total;\r\nif (device->state.conn == C_VERIFY_S || device->state.conn == C_VERIFY_T)\r\ndb -= device->ov_left;\r\ndbdt = Bit2KB(db/dt);\r\ndevice->rs_paused /= HZ;\r\nif (!get_ldev(device))\r\ngoto out;\r\nping_peer(device);\r\nspin_lock_irq(&device->resource->req_lock);\r\nos = drbd_read_state(device);\r\nverify_done = (os.conn == C_VERIFY_S || os.conn == C_VERIFY_T);\r\nif (os.conn <= C_CONNECTED)\r\ngoto out_unlock;\r\nns = os;\r\nns.conn = C_CONNECTED;\r\ndrbd_info(device, "%s done (total %lu sec; paused %lu sec; %lu K/sec)\n",\r\nverify_done ? "Online verify" : "Resync",\r\ndt + device->rs_paused, device->rs_paused, dbdt);\r\nn_oos = drbd_bm_total_weight(device);\r\nif (os.conn == C_VERIFY_S || os.conn == C_VERIFY_T) {\r\nif (n_oos) {\r\ndrbd_alert(device, "Online verify found %lu %dk block out of sync!\n",\r\nn_oos, Bit2KB(1));\r\nkhelper_cmd = "out-of-sync";\r\n}\r\n} else {\r\nD_ASSERT(device, (n_oos - device->rs_failed) == 0);\r\nif (os.conn == C_SYNC_TARGET || os.conn == C_PAUSED_SYNC_T)\r\nkhelper_cmd = "after-resync-target";\r\nif (device->use_csums && device->rs_total) {\r\nconst unsigned long s = device->rs_same_csum;\r\nconst unsigned long t = device->rs_total;\r\nconst int ratio =\r\n(t == 0) ? 0 :\r\n(t < 100000) ? ((s*100)/t) : (s/(t/100));\r\ndrbd_info(device, "%u %% had equal checksums, eliminated: %luK; "\r\n"transferred %luK total %luK\n",\r\nratio,\r\nBit2KB(device->rs_same_csum),\r\nBit2KB(device->rs_total - device->rs_same_csum),\r\nBit2KB(device->rs_total));\r\n}\r\n}\r\nif (device->rs_failed) {\r\ndrbd_info(device, " %lu failed blocks\n", device->rs_failed);\r\nif (os.conn == C_SYNC_TARGET || os.conn == C_PAUSED_SYNC_T) {\r\nns.disk = D_INCONSISTENT;\r\nns.pdsk = D_UP_TO_DATE;\r\n} else {\r\nns.disk = D_UP_TO_DATE;\r\nns.pdsk = D_INCONSISTENT;\r\n}\r\n} else {\r\nns.disk = D_UP_TO_DATE;\r\nns.pdsk = D_UP_TO_DATE;\r\nif (os.conn == C_SYNC_TARGET || os.conn == C_PAUSED_SYNC_T) {\r\nif (device->p_uuid) {\r\nint i;\r\nfor (i = UI_BITMAP ; i <= UI_HISTORY_END ; i++)\r\n_drbd_uuid_set(device, i, device->p_uuid[i]);\r\ndrbd_uuid_set(device, UI_BITMAP, device->ldev->md.uuid[UI_CURRENT]);\r\n_drbd_uuid_set(device, UI_CURRENT, device->p_uuid[UI_CURRENT]);\r\n} else {\r\ndrbd_err(device, "device->p_uuid is NULL! BUG\n");\r\n}\r\n}\r\nif (!(os.conn == C_VERIFY_S || os.conn == C_VERIFY_T)) {\r\ndrbd_uuid_set_bm(device, 0UL);\r\ndrbd_print_uuids(device, "updated UUIDs");\r\nif (device->p_uuid) {\r\nint i;\r\nfor (i = UI_CURRENT ; i <= UI_HISTORY_END ; i++)\r\ndevice->p_uuid[i] = device->ldev->md.uuid[i];\r\n}\r\n}\r\n}\r\n_drbd_set_state(device, ns, CS_VERBOSE, NULL);\r\nout_unlock:\r\nspin_unlock_irq(&device->resource->req_lock);\r\nput_ldev(device);\r\nout:\r\ndevice->rs_total = 0;\r\ndevice->rs_failed = 0;\r\ndevice->rs_paused = 0;\r\nif (verify_done && device->ov_left == 0)\r\ndevice->ov_start_sector = 0;\r\ndrbd_md_sync(device);\r\nif (khelper_cmd)\r\ndrbd_khelper(device, khelper_cmd);\r\nreturn 1;\r\n}\r\nstatic void move_to_net_ee_or_free(struct drbd_device *device, struct drbd_peer_request *peer_req)\r\n{\r\nif (drbd_peer_req_has_active_page(peer_req)) {\r\nint i = (peer_req->i.size + PAGE_SIZE -1) >> PAGE_SHIFT;\r\natomic_add(i, &device->pp_in_use_by_net);\r\natomic_sub(i, &device->pp_in_use);\r\nspin_lock_irq(&device->resource->req_lock);\r\nlist_add_tail(&peer_req->w.list, &device->net_ee);\r\nspin_unlock_irq(&device->resource->req_lock);\r\nwake_up(&drbd_pp_wait);\r\n} else\r\ndrbd_free_peer_req(device, peer_req);\r\n}\r\nint w_e_end_data_req(struct drbd_work *w, int cancel)\r\n{\r\nstruct drbd_peer_request *peer_req = container_of(w, struct drbd_peer_request, w);\r\nstruct drbd_peer_device *peer_device = peer_req->peer_device;\r\nstruct drbd_device *device = peer_device->device;\r\nint err;\r\nif (unlikely(cancel)) {\r\ndrbd_free_peer_req(device, peer_req);\r\ndec_unacked(device);\r\nreturn 0;\r\n}\r\nif (likely((peer_req->flags & EE_WAS_ERROR) == 0)) {\r\nerr = drbd_send_block(peer_device, P_DATA_REPLY, peer_req);\r\n} else {\r\nif (__ratelimit(&drbd_ratelimit_state))\r\ndrbd_err(device, "Sending NegDReply. sector=%llus.\n",\r\n(unsigned long long)peer_req->i.sector);\r\nerr = drbd_send_ack(peer_device, P_NEG_DREPLY, peer_req);\r\n}\r\ndec_unacked(device);\r\nmove_to_net_ee_or_free(device, peer_req);\r\nif (unlikely(err))\r\ndrbd_err(device, "drbd_send_block() failed\n");\r\nreturn err;\r\n}\r\nint w_e_end_rsdata_req(struct drbd_work *w, int cancel)\r\n{\r\nstruct drbd_peer_request *peer_req = container_of(w, struct drbd_peer_request, w);\r\nstruct drbd_peer_device *peer_device = peer_req->peer_device;\r\nstruct drbd_device *device = peer_device->device;\r\nint err;\r\nif (unlikely(cancel)) {\r\ndrbd_free_peer_req(device, peer_req);\r\ndec_unacked(device);\r\nreturn 0;\r\n}\r\nif (get_ldev_if_state(device, D_FAILED)) {\r\ndrbd_rs_complete_io(device, peer_req->i.sector);\r\nput_ldev(device);\r\n}\r\nif (device->state.conn == C_AHEAD) {\r\nerr = drbd_send_ack(peer_device, P_RS_CANCEL, peer_req);\r\n} else if (likely((peer_req->flags & EE_WAS_ERROR) == 0)) {\r\nif (likely(device->state.pdsk >= D_INCONSISTENT)) {\r\ninc_rs_pending(device);\r\nerr = drbd_send_block(peer_device, P_RS_DATA_REPLY, peer_req);\r\n} else {\r\nif (__ratelimit(&drbd_ratelimit_state))\r\ndrbd_err(device, "Not sending RSDataReply, "\r\n"partner DISKLESS!\n");\r\nerr = 0;\r\n}\r\n} else {\r\nif (__ratelimit(&drbd_ratelimit_state))\r\ndrbd_err(device, "Sending NegRSDReply. sector %llus.\n",\r\n(unsigned long long)peer_req->i.sector);\r\nerr = drbd_send_ack(peer_device, P_NEG_RS_DREPLY, peer_req);\r\ndrbd_rs_failed_io(device, peer_req->i.sector, peer_req->i.size);\r\n}\r\ndec_unacked(device);\r\nmove_to_net_ee_or_free(device, peer_req);\r\nif (unlikely(err))\r\ndrbd_err(device, "drbd_send_block() failed\n");\r\nreturn err;\r\n}\r\nint w_e_end_csum_rs_req(struct drbd_work *w, int cancel)\r\n{\r\nstruct drbd_peer_request *peer_req = container_of(w, struct drbd_peer_request, w);\r\nstruct drbd_peer_device *peer_device = peer_req->peer_device;\r\nstruct drbd_device *device = peer_device->device;\r\nstruct digest_info *di;\r\nint digest_size;\r\nvoid *digest = NULL;\r\nint err, eq = 0;\r\nif (unlikely(cancel)) {\r\ndrbd_free_peer_req(device, peer_req);\r\ndec_unacked(device);\r\nreturn 0;\r\n}\r\nif (get_ldev(device)) {\r\ndrbd_rs_complete_io(device, peer_req->i.sector);\r\nput_ldev(device);\r\n}\r\ndi = peer_req->digest;\r\nif (likely((peer_req->flags & EE_WAS_ERROR) == 0)) {\r\nif (peer_device->connection->csums_tfm) {\r\ndigest_size = crypto_ahash_digestsize(peer_device->connection->csums_tfm);\r\nD_ASSERT(device, digest_size == di->digest_size);\r\ndigest = kmalloc(digest_size, GFP_NOIO);\r\n}\r\nif (digest) {\r\ndrbd_csum_ee(peer_device->connection->csums_tfm, peer_req, digest);\r\neq = !memcmp(digest, di->digest, digest_size);\r\nkfree(digest);\r\n}\r\nif (eq) {\r\ndrbd_set_in_sync(device, peer_req->i.sector, peer_req->i.size);\r\ndevice->rs_same_csum += peer_req->i.size >> BM_BLOCK_SHIFT;\r\nerr = drbd_send_ack(peer_device, P_RS_IS_IN_SYNC, peer_req);\r\n} else {\r\ninc_rs_pending(device);\r\npeer_req->block_id = ID_SYNCER;\r\npeer_req->flags &= ~EE_HAS_DIGEST;\r\nkfree(di);\r\nerr = drbd_send_block(peer_device, P_RS_DATA_REPLY, peer_req);\r\n}\r\n} else {\r\nerr = drbd_send_ack(peer_device, P_NEG_RS_DREPLY, peer_req);\r\nif (__ratelimit(&drbd_ratelimit_state))\r\ndrbd_err(device, "Sending NegDReply. I guess it gets messy.\n");\r\n}\r\ndec_unacked(device);\r\nmove_to_net_ee_or_free(device, peer_req);\r\nif (unlikely(err))\r\ndrbd_err(device, "drbd_send_block/ack() failed\n");\r\nreturn err;\r\n}\r\nint w_e_end_ov_req(struct drbd_work *w, int cancel)\r\n{\r\nstruct drbd_peer_request *peer_req = container_of(w, struct drbd_peer_request, w);\r\nstruct drbd_peer_device *peer_device = peer_req->peer_device;\r\nstruct drbd_device *device = peer_device->device;\r\nsector_t sector = peer_req->i.sector;\r\nunsigned int size = peer_req->i.size;\r\nint digest_size;\r\nvoid *digest;\r\nint err = 0;\r\nif (unlikely(cancel))\r\ngoto out;\r\ndigest_size = crypto_ahash_digestsize(peer_device->connection->verify_tfm);\r\ndigest = kmalloc(digest_size, GFP_NOIO);\r\nif (!digest) {\r\nerr = 1;\r\ngoto out;\r\n}\r\nif (likely(!(peer_req->flags & EE_WAS_ERROR)))\r\ndrbd_csum_ee(peer_device->connection->verify_tfm, peer_req, digest);\r\nelse\r\nmemset(digest, 0, digest_size);\r\ndrbd_free_peer_req(device, peer_req);\r\npeer_req = NULL;\r\ninc_rs_pending(device);\r\nerr = drbd_send_drequest_csum(peer_device, sector, size, digest, digest_size, P_OV_REPLY);\r\nif (err)\r\ndec_rs_pending(device);\r\nkfree(digest);\r\nout:\r\nif (peer_req)\r\ndrbd_free_peer_req(device, peer_req);\r\ndec_unacked(device);\r\nreturn err;\r\n}\r\nvoid drbd_ov_out_of_sync_found(struct drbd_device *device, sector_t sector, int size)\r\n{\r\nif (device->ov_last_oos_start + device->ov_last_oos_size == sector) {\r\ndevice->ov_last_oos_size += size>>9;\r\n} else {\r\ndevice->ov_last_oos_start = sector;\r\ndevice->ov_last_oos_size = size>>9;\r\n}\r\ndrbd_set_out_of_sync(device, sector, size);\r\n}\r\nint w_e_end_ov_reply(struct drbd_work *w, int cancel)\r\n{\r\nstruct drbd_peer_request *peer_req = container_of(w, struct drbd_peer_request, w);\r\nstruct drbd_peer_device *peer_device = peer_req->peer_device;\r\nstruct drbd_device *device = peer_device->device;\r\nstruct digest_info *di;\r\nvoid *digest;\r\nsector_t sector = peer_req->i.sector;\r\nunsigned int size = peer_req->i.size;\r\nint digest_size;\r\nint err, eq = 0;\r\nbool stop_sector_reached = false;\r\nif (unlikely(cancel)) {\r\ndrbd_free_peer_req(device, peer_req);\r\ndec_unacked(device);\r\nreturn 0;\r\n}\r\nif (get_ldev(device)) {\r\ndrbd_rs_complete_io(device, peer_req->i.sector);\r\nput_ldev(device);\r\n}\r\ndi = peer_req->digest;\r\nif (likely((peer_req->flags & EE_WAS_ERROR) == 0)) {\r\ndigest_size = crypto_ahash_digestsize(peer_device->connection->verify_tfm);\r\ndigest = kmalloc(digest_size, GFP_NOIO);\r\nif (digest) {\r\ndrbd_csum_ee(peer_device->connection->verify_tfm, peer_req, digest);\r\nD_ASSERT(device, digest_size == di->digest_size);\r\neq = !memcmp(digest, di->digest, digest_size);\r\nkfree(digest);\r\n}\r\n}\r\ndrbd_free_peer_req(device, peer_req);\r\nif (!eq)\r\ndrbd_ov_out_of_sync_found(device, sector, size);\r\nelse\r\nov_out_of_sync_print(device);\r\nerr = drbd_send_ack_ex(peer_device, P_OV_RESULT, sector, size,\r\neq ? ID_IN_SYNC : ID_OUT_OF_SYNC);\r\ndec_unacked(device);\r\n--device->ov_left;\r\nif ((device->ov_left & 0x200) == 0x200)\r\ndrbd_advance_rs_marks(device, device->ov_left);\r\nstop_sector_reached = verify_can_do_stop_sector(device) &&\r\n(sector + (size>>9)) >= device->ov_stop_sector;\r\nif (device->ov_left == 0 || stop_sector_reached) {\r\nov_out_of_sync_print(device);\r\ndrbd_resync_finished(device);\r\n}\r\nreturn err;\r\n}\r\nstatic int drbd_send_barrier(struct drbd_connection *connection)\r\n{\r\nstruct p_barrier *p;\r\nstruct drbd_socket *sock;\r\nsock = &connection->data;\r\np = conn_prepare_command(connection, sock);\r\nif (!p)\r\nreturn -EIO;\r\np->barrier = connection->send.current_epoch_nr;\r\np->pad = 0;\r\nconnection->send.current_epoch_writes = 0;\r\nconnection->send.last_sent_barrier_jif = jiffies;\r\nreturn conn_send_command(connection, sock, P_BARRIER, sizeof(*p), NULL, 0);\r\n}\r\nint w_send_write_hint(struct drbd_work *w, int cancel)\r\n{\r\nstruct drbd_device *device =\r\ncontainer_of(w, struct drbd_device, unplug_work);\r\nstruct drbd_socket *sock;\r\nif (cancel)\r\nreturn 0;\r\nsock = &first_peer_device(device)->connection->data;\r\nif (!drbd_prepare_command(first_peer_device(device), sock))\r\nreturn -EIO;\r\nreturn drbd_send_command(first_peer_device(device), sock, P_UNPLUG_REMOTE, 0, NULL, 0);\r\n}\r\nstatic void re_init_if_first_write(struct drbd_connection *connection, unsigned int epoch)\r\n{\r\nif (!connection->send.seen_any_write_yet) {\r\nconnection->send.seen_any_write_yet = true;\r\nconnection->send.current_epoch_nr = epoch;\r\nconnection->send.current_epoch_writes = 0;\r\nconnection->send.last_sent_barrier_jif = jiffies;\r\n}\r\n}\r\nstatic void maybe_send_barrier(struct drbd_connection *connection, unsigned int epoch)\r\n{\r\nif (!connection->send.seen_any_write_yet)\r\nreturn;\r\nif (connection->send.current_epoch_nr != epoch) {\r\nif (connection->send.current_epoch_writes)\r\ndrbd_send_barrier(connection);\r\nconnection->send.current_epoch_nr = epoch;\r\n}\r\n}\r\nint w_send_out_of_sync(struct drbd_work *w, int cancel)\r\n{\r\nstruct drbd_request *req = container_of(w, struct drbd_request, w);\r\nstruct drbd_device *device = req->device;\r\nstruct drbd_peer_device *const peer_device = first_peer_device(device);\r\nstruct drbd_connection *const connection = peer_device->connection;\r\nint err;\r\nif (unlikely(cancel)) {\r\nreq_mod(req, SEND_CANCELED);\r\nreturn 0;\r\n}\r\nreq->pre_send_jif = jiffies;\r\nmaybe_send_barrier(connection, req->epoch);\r\nerr = drbd_send_out_of_sync(peer_device, req);\r\nreq_mod(req, OOS_HANDED_TO_NETWORK);\r\nreturn err;\r\n}\r\nint w_send_dblock(struct drbd_work *w, int cancel)\r\n{\r\nstruct drbd_request *req = container_of(w, struct drbd_request, w);\r\nstruct drbd_device *device = req->device;\r\nstruct drbd_peer_device *const peer_device = first_peer_device(device);\r\nstruct drbd_connection *connection = peer_device->connection;\r\nint err;\r\nif (unlikely(cancel)) {\r\nreq_mod(req, SEND_CANCELED);\r\nreturn 0;\r\n}\r\nreq->pre_send_jif = jiffies;\r\nre_init_if_first_write(connection, req->epoch);\r\nmaybe_send_barrier(connection, req->epoch);\r\nconnection->send.current_epoch_writes++;\r\nerr = drbd_send_dblock(peer_device, req);\r\nreq_mod(req, err ? SEND_FAILED : HANDED_OVER_TO_NETWORK);\r\nreturn err;\r\n}\r\nint w_send_read_req(struct drbd_work *w, int cancel)\r\n{\r\nstruct drbd_request *req = container_of(w, struct drbd_request, w);\r\nstruct drbd_device *device = req->device;\r\nstruct drbd_peer_device *const peer_device = first_peer_device(device);\r\nstruct drbd_connection *connection = peer_device->connection;\r\nint err;\r\nif (unlikely(cancel)) {\r\nreq_mod(req, SEND_CANCELED);\r\nreturn 0;\r\n}\r\nreq->pre_send_jif = jiffies;\r\nmaybe_send_barrier(connection, req->epoch);\r\nerr = drbd_send_drequest(peer_device, P_DATA_REQUEST, req->i.sector, req->i.size,\r\n(unsigned long)req);\r\nreq_mod(req, err ? SEND_FAILED : HANDED_OVER_TO_NETWORK);\r\nreturn err;\r\n}\r\nint w_restart_disk_io(struct drbd_work *w, int cancel)\r\n{\r\nstruct drbd_request *req = container_of(w, struct drbd_request, w);\r\nstruct drbd_device *device = req->device;\r\nif (bio_data_dir(req->master_bio) == WRITE && req->rq_state & RQ_IN_ACT_LOG)\r\ndrbd_al_begin_io(device, &req->i);\r\ndrbd_req_make_private_bio(req, req->master_bio);\r\nreq->private_bio->bi_bdev = device->ldev->backing_bdev;\r\ngeneric_make_request(req->private_bio);\r\nreturn 0;\r\n}\r\nstatic int _drbd_may_sync_now(struct drbd_device *device)\r\n{\r\nstruct drbd_device *odev = device;\r\nint resync_after;\r\nwhile (1) {\r\nif (!odev->ldev || odev->state.disk == D_DISKLESS)\r\nreturn 1;\r\nrcu_read_lock();\r\nresync_after = rcu_dereference(odev->ldev->disk_conf)->resync_after;\r\nrcu_read_unlock();\r\nif (resync_after == -1)\r\nreturn 1;\r\nodev = minor_to_device(resync_after);\r\nif (!odev)\r\nreturn 1;\r\nif ((odev->state.conn >= C_SYNC_SOURCE &&\r\nodev->state.conn <= C_PAUSED_SYNC_T) ||\r\nodev->state.aftr_isp || odev->state.peer_isp ||\r\nodev->state.user_isp)\r\nreturn 0;\r\n}\r\n}\r\nstatic bool drbd_pause_after(struct drbd_device *device)\r\n{\r\nbool changed = false;\r\nstruct drbd_device *odev;\r\nint i;\r\nrcu_read_lock();\r\nidr_for_each_entry(&drbd_devices, odev, i) {\r\nif (odev->state.conn == C_STANDALONE && odev->state.disk == D_DISKLESS)\r\ncontinue;\r\nif (!_drbd_may_sync_now(odev) &&\r\n_drbd_set_state(_NS(odev, aftr_isp, 1),\r\nCS_HARD, NULL) != SS_NOTHING_TO_DO)\r\nchanged = true;\r\n}\r\nrcu_read_unlock();\r\nreturn changed;\r\n}\r\nstatic bool drbd_resume_next(struct drbd_device *device)\r\n{\r\nbool changed = false;\r\nstruct drbd_device *odev;\r\nint i;\r\nrcu_read_lock();\r\nidr_for_each_entry(&drbd_devices, odev, i) {\r\nif (odev->state.conn == C_STANDALONE && odev->state.disk == D_DISKLESS)\r\ncontinue;\r\nif (odev->state.aftr_isp) {\r\nif (_drbd_may_sync_now(odev) &&\r\n_drbd_set_state(_NS(odev, aftr_isp, 0),\r\nCS_HARD, NULL) != SS_NOTHING_TO_DO)\r\nchanged = true;\r\n}\r\n}\r\nrcu_read_unlock();\r\nreturn changed;\r\n}\r\nvoid resume_next_sg(struct drbd_device *device)\r\n{\r\nlock_all_resources();\r\ndrbd_resume_next(device);\r\nunlock_all_resources();\r\n}\r\nvoid suspend_other_sg(struct drbd_device *device)\r\n{\r\nlock_all_resources();\r\ndrbd_pause_after(device);\r\nunlock_all_resources();\r\n}\r\nenum drbd_ret_code drbd_resync_after_valid(struct drbd_device *device, int o_minor)\r\n{\r\nstruct drbd_device *odev;\r\nint resync_after;\r\nif (o_minor == -1)\r\nreturn NO_ERROR;\r\nif (o_minor < -1 || o_minor > MINORMASK)\r\nreturn ERR_RESYNC_AFTER;\r\nodev = minor_to_device(o_minor);\r\nwhile (1) {\r\nif (odev == device)\r\nreturn ERR_RESYNC_AFTER_CYCLE;\r\nif (!odev || !odev->ldev || odev->state.disk == D_DISKLESS)\r\nreturn NO_ERROR;\r\nrcu_read_lock();\r\nresync_after = rcu_dereference(odev->ldev->disk_conf)->resync_after;\r\nrcu_read_unlock();\r\nif (resync_after == -1)\r\nreturn NO_ERROR;\r\nodev = minor_to_device(resync_after);\r\n}\r\n}\r\nvoid drbd_resync_after_changed(struct drbd_device *device)\r\n{\r\nint changed;\r\ndo {\r\nchanged = drbd_pause_after(device);\r\nchanged |= drbd_resume_next(device);\r\n} while (changed);\r\n}\r\nvoid drbd_rs_controller_reset(struct drbd_device *device)\r\n{\r\nstruct gendisk *disk = device->ldev->backing_bdev->bd_contains->bd_disk;\r\nstruct fifo_buffer *plan;\r\natomic_set(&device->rs_sect_in, 0);\r\natomic_set(&device->rs_sect_ev, 0);\r\ndevice->rs_in_flight = 0;\r\ndevice->rs_last_events =\r\n(int)part_stat_read(&disk->part0, sectors[0]) +\r\n(int)part_stat_read(&disk->part0, sectors[1]);\r\nrcu_read_lock();\r\nplan = rcu_dereference(device->rs_plan_s);\r\nplan->total = 0;\r\nfifo_set(plan, 0);\r\nrcu_read_unlock();\r\n}\r\nvoid start_resync_timer_fn(unsigned long data)\r\n{\r\nstruct drbd_device *device = (struct drbd_device *) data;\r\ndrbd_device_post_work(device, RS_START);\r\n}\r\nstatic void do_start_resync(struct drbd_device *device)\r\n{\r\nif (atomic_read(&device->unacked_cnt) || atomic_read(&device->rs_pending_cnt)) {\r\ndrbd_warn(device, "postponing start_resync ...\n");\r\ndevice->start_resync_timer.expires = jiffies + HZ/10;\r\nadd_timer(&device->start_resync_timer);\r\nreturn;\r\n}\r\ndrbd_start_resync(device, C_SYNC_SOURCE);\r\nclear_bit(AHEAD_TO_SYNC_SOURCE, &device->flags);\r\n}\r\nstatic bool use_checksum_based_resync(struct drbd_connection *connection, struct drbd_device *device)\r\n{\r\nbool csums_after_crash_only;\r\nrcu_read_lock();\r\ncsums_after_crash_only = rcu_dereference(connection->net_conf)->csums_after_crash_only;\r\nrcu_read_unlock();\r\nreturn connection->agreed_pro_version >= 89 &&\r\nconnection->csums_tfm &&\r\n(csums_after_crash_only == 0\r\n|| test_bit(CRASHED_PRIMARY, &device->flags));\r\n}\r\nvoid drbd_start_resync(struct drbd_device *device, enum drbd_conns side)\r\n{\r\nstruct drbd_peer_device *peer_device = first_peer_device(device);\r\nstruct drbd_connection *connection = peer_device ? peer_device->connection : NULL;\r\nunion drbd_state ns;\r\nint r;\r\nif (device->state.conn >= C_SYNC_SOURCE && device->state.conn < C_AHEAD) {\r\ndrbd_err(device, "Resync already running!\n");\r\nreturn;\r\n}\r\nif (!test_bit(B_RS_H_DONE, &device->flags)) {\r\nif (side == C_SYNC_TARGET) {\r\nr = drbd_khelper(device, "before-resync-target");\r\nr = (r >> 8) & 0xff;\r\nif (r > 0) {\r\ndrbd_info(device, "before-resync-target handler returned %d, "\r\n"dropping connection.\n", r);\r\nconn_request_state(connection, NS(conn, C_DISCONNECTING), CS_HARD);\r\nreturn;\r\n}\r\n} else {\r\nr = drbd_khelper(device, "before-resync-source");\r\nr = (r >> 8) & 0xff;\r\nif (r > 0) {\r\nif (r == 3) {\r\ndrbd_info(device, "before-resync-source handler returned %d, "\r\n"ignoring. Old userland tools?", r);\r\n} else {\r\ndrbd_info(device, "before-resync-source handler returned %d, "\r\n"dropping connection.\n", r);\r\nconn_request_state(connection,\r\nNS(conn, C_DISCONNECTING), CS_HARD);\r\nreturn;\r\n}\r\n}\r\n}\r\n}\r\nif (current == connection->worker.task) {\r\nif (!mutex_trylock(device->state_mutex)) {\r\nset_bit(B_RS_H_DONE, &device->flags);\r\ndevice->start_resync_timer.expires = jiffies + HZ/5;\r\nadd_timer(&device->start_resync_timer);\r\nreturn;\r\n}\r\n} else {\r\nmutex_lock(device->state_mutex);\r\n}\r\nlock_all_resources();\r\nclear_bit(B_RS_H_DONE, &device->flags);\r\nif (device->state.conn < C_CONNECTED\r\n|| !get_ldev_if_state(device, D_NEGOTIATING)) {\r\nunlock_all_resources();\r\ngoto out;\r\n}\r\nns = drbd_read_state(device);\r\nns.aftr_isp = !_drbd_may_sync_now(device);\r\nns.conn = side;\r\nif (side == C_SYNC_TARGET)\r\nns.disk = D_INCONSISTENT;\r\nelse\r\nns.pdsk = D_INCONSISTENT;\r\nr = _drbd_set_state(device, ns, CS_VERBOSE, NULL);\r\nns = drbd_read_state(device);\r\nif (ns.conn < C_CONNECTED)\r\nr = SS_UNKNOWN_ERROR;\r\nif (r == SS_SUCCESS) {\r\nunsigned long tw = drbd_bm_total_weight(device);\r\nunsigned long now = jiffies;\r\nint i;\r\ndevice->rs_failed = 0;\r\ndevice->rs_paused = 0;\r\ndevice->rs_same_csum = 0;\r\ndevice->rs_last_sect_ev = 0;\r\ndevice->rs_total = tw;\r\ndevice->rs_start = now;\r\nfor (i = 0; i < DRBD_SYNC_MARKS; i++) {\r\ndevice->rs_mark_left[i] = tw;\r\ndevice->rs_mark_time[i] = now;\r\n}\r\ndrbd_pause_after(device);\r\nspin_lock(&device->al_lock);\r\nlc_reset(device->resync);\r\ndevice->resync_locked = 0;\r\ndevice->resync_wenr = LC_FREE;\r\nspin_unlock(&device->al_lock);\r\n}\r\nunlock_all_resources();\r\nif (r == SS_SUCCESS) {\r\nwake_up(&device->al_wait);\r\ndevice->rs_last_bcast = jiffies - HZ;\r\ndrbd_info(device, "Began resync as %s (will sync %lu KB [%lu bits set]).\n",\r\ndrbd_conn_str(ns.conn),\r\n(unsigned long) device->rs_total << (BM_BLOCK_SHIFT-10),\r\n(unsigned long) device->rs_total);\r\nif (side == C_SYNC_TARGET) {\r\ndevice->bm_resync_fo = 0;\r\ndevice->use_csums = use_checksum_based_resync(connection, device);\r\n} else {\r\ndevice->use_csums = 0;\r\n}\r\nif (side == C_SYNC_SOURCE && connection->agreed_pro_version < 96)\r\ndrbd_gen_and_send_sync_uuid(peer_device);\r\nif (connection->agreed_pro_version < 95 && device->rs_total == 0) {\r\nif (side == C_SYNC_SOURCE) {\r\nstruct net_conf *nc;\r\nint timeo;\r\nrcu_read_lock();\r\nnc = rcu_dereference(connection->net_conf);\r\ntimeo = nc->ping_int * HZ + nc->ping_timeo * HZ / 9;\r\nrcu_read_unlock();\r\nschedule_timeout_interruptible(timeo);\r\n}\r\ndrbd_resync_finished(device);\r\n}\r\ndrbd_rs_controller_reset(device);\r\nif (ns.conn == C_SYNC_TARGET)\r\nmod_timer(&device->resync_timer, jiffies);\r\ndrbd_md_sync(device);\r\n}\r\nput_ldev(device);\r\nout:\r\nmutex_unlock(device->state_mutex);\r\n}\r\nstatic void update_on_disk_bitmap(struct drbd_device *device, bool resync_done)\r\n{\r\nstruct sib_info sib = { .sib_reason = SIB_SYNC_PROGRESS, };\r\ndevice->rs_last_bcast = jiffies;\r\nif (!get_ldev(device))\r\nreturn;\r\ndrbd_bm_write_lazy(device, 0);\r\nif (resync_done && is_sync_state(device->state.conn))\r\ndrbd_resync_finished(device);\r\ndrbd_bcast_event(device, &sib);\r\ndevice->rs_last_bcast = jiffies;\r\nput_ldev(device);\r\n}\r\nstatic void drbd_ldev_destroy(struct drbd_device *device)\r\n{\r\nlc_destroy(device->resync);\r\ndevice->resync = NULL;\r\nlc_destroy(device->act_log);\r\ndevice->act_log = NULL;\r\n__acquire(local);\r\ndrbd_backing_dev_free(device, device->ldev);\r\ndevice->ldev = NULL;\r\n__release(local);\r\nclear_bit(GOING_DISKLESS, &device->flags);\r\nwake_up(&device->misc_wait);\r\n}\r\nstatic void go_diskless(struct drbd_device *device)\r\n{\r\nD_ASSERT(device, device->state.disk == D_FAILED);\r\nif (device->bitmap && device->ldev) {\r\nif (drbd_bitmap_io_from_worker(device, drbd_bm_write,\r\n"detach", BM_LOCKED_TEST_ALLOWED)) {\r\nif (test_bit(WAS_READ_ERROR, &device->flags)) {\r\ndrbd_md_set_flag(device, MDF_FULL_SYNC);\r\ndrbd_md_sync(device);\r\n}\r\n}\r\n}\r\ndrbd_force_state(device, NS(disk, D_DISKLESS));\r\n}\r\nstatic int do_md_sync(struct drbd_device *device)\r\n{\r\ndrbd_warn(device, "md_sync_timer expired! Worker calls drbd_md_sync().\n");\r\ndrbd_md_sync(device);\r\nreturn 0;\r\n}\r\nvoid __update_timing_details(\r\nstruct drbd_thread_timing_details *tdp,\r\nunsigned int *cb_nr,\r\nvoid *cb,\r\nconst char *fn, const unsigned int line)\r\n{\r\nunsigned int i = *cb_nr % DRBD_THREAD_DETAILS_HIST;\r\nstruct drbd_thread_timing_details *td = tdp + i;\r\ntd->start_jif = jiffies;\r\ntd->cb_addr = cb;\r\ntd->caller_fn = fn;\r\ntd->line = line;\r\ntd->cb_nr = *cb_nr;\r\ni = (i+1) % DRBD_THREAD_DETAILS_HIST;\r\ntd = tdp + i;\r\nmemset(td, 0, sizeof(*td));\r\n++(*cb_nr);\r\n}\r\nstatic void do_device_work(struct drbd_device *device, const unsigned long todo)\r\n{\r\nif (test_bit(MD_SYNC, &todo))\r\ndo_md_sync(device);\r\nif (test_bit(RS_DONE, &todo) ||\r\ntest_bit(RS_PROGRESS, &todo))\r\nupdate_on_disk_bitmap(device, test_bit(RS_DONE, &todo));\r\nif (test_bit(GO_DISKLESS, &todo))\r\ngo_diskless(device);\r\nif (test_bit(DESTROY_DISK, &todo))\r\ndrbd_ldev_destroy(device);\r\nif (test_bit(RS_START, &todo))\r\ndo_start_resync(device);\r\n}\r\nstatic unsigned long get_work_bits(unsigned long *flags)\r\n{\r\nunsigned long old, new;\r\ndo {\r\nold = *flags;\r\nnew = old & ~DRBD_DEVICE_WORK_MASK;\r\n} while (cmpxchg(flags, old, new) != old);\r\nreturn old & DRBD_DEVICE_WORK_MASK;\r\n}\r\nstatic void do_unqueued_work(struct drbd_connection *connection)\r\n{\r\nstruct drbd_peer_device *peer_device;\r\nint vnr;\r\nrcu_read_lock();\r\nidr_for_each_entry(&connection->peer_devices, peer_device, vnr) {\r\nstruct drbd_device *device = peer_device->device;\r\nunsigned long todo = get_work_bits(&device->flags);\r\nif (!todo)\r\ncontinue;\r\nkref_get(&device->kref);\r\nrcu_read_unlock();\r\ndo_device_work(device, todo);\r\nkref_put(&device->kref, drbd_destroy_device);\r\nrcu_read_lock();\r\n}\r\nrcu_read_unlock();\r\n}\r\nstatic bool dequeue_work_batch(struct drbd_work_queue *queue, struct list_head *work_list)\r\n{\r\nspin_lock_irq(&queue->q_lock);\r\nlist_splice_tail_init(&queue->q, work_list);\r\nspin_unlock_irq(&queue->q_lock);\r\nreturn !list_empty(work_list);\r\n}\r\nstatic void wait_for_work(struct drbd_connection *connection, struct list_head *work_list)\r\n{\r\nDEFINE_WAIT(wait);\r\nstruct net_conf *nc;\r\nint uncork, cork;\r\ndequeue_work_batch(&connection->sender_work, work_list);\r\nif (!list_empty(work_list))\r\nreturn;\r\nrcu_read_lock();\r\nnc = rcu_dereference(connection->net_conf);\r\nuncork = nc ? nc->tcp_cork : 0;\r\nrcu_read_unlock();\r\nif (uncork) {\r\nmutex_lock(&connection->data.mutex);\r\nif (connection->data.socket)\r\ndrbd_tcp_uncork(connection->data.socket);\r\nmutex_unlock(&connection->data.mutex);\r\n}\r\nfor (;;) {\r\nint send_barrier;\r\nprepare_to_wait(&connection->sender_work.q_wait, &wait, TASK_INTERRUPTIBLE);\r\nspin_lock_irq(&connection->resource->req_lock);\r\nspin_lock(&connection->sender_work.q_lock);\r\nif (!list_empty(&connection->sender_work.q))\r\nlist_splice_tail_init(&connection->sender_work.q, work_list);\r\nspin_unlock(&connection->sender_work.q_lock);\r\nif (!list_empty(work_list) || signal_pending(current)) {\r\nspin_unlock_irq(&connection->resource->req_lock);\r\nbreak;\r\n}\r\nsend_barrier =\r\natomic_read(&connection->current_tle_nr) !=\r\nconnection->send.current_epoch_nr;\r\nspin_unlock_irq(&connection->resource->req_lock);\r\nif (send_barrier)\r\nmaybe_send_barrier(connection,\r\nconnection->send.current_epoch_nr + 1);\r\nif (test_bit(DEVICE_WORK_PENDING, &connection->flags))\r\nbreak;\r\nif (get_t_state(&connection->worker) != RUNNING)\r\nbreak;\r\nschedule();\r\n}\r\nfinish_wait(&connection->sender_work.q_wait, &wait);\r\nrcu_read_lock();\r\nnc = rcu_dereference(connection->net_conf);\r\ncork = nc ? nc->tcp_cork : 0;\r\nrcu_read_unlock();\r\nmutex_lock(&connection->data.mutex);\r\nif (connection->data.socket) {\r\nif (cork)\r\ndrbd_tcp_cork(connection->data.socket);\r\nelse if (!uncork)\r\ndrbd_tcp_uncork(connection->data.socket);\r\n}\r\nmutex_unlock(&connection->data.mutex);\r\n}\r\nint drbd_worker(struct drbd_thread *thi)\r\n{\r\nstruct drbd_connection *connection = thi->connection;\r\nstruct drbd_work *w = NULL;\r\nstruct drbd_peer_device *peer_device;\r\nLIST_HEAD(work_list);\r\nint vnr;\r\nwhile (get_t_state(thi) == RUNNING) {\r\ndrbd_thread_current_set_cpu(thi);\r\nif (list_empty(&work_list)) {\r\nupdate_worker_timing_details(connection, wait_for_work);\r\nwait_for_work(connection, &work_list);\r\n}\r\nif (test_and_clear_bit(DEVICE_WORK_PENDING, &connection->flags)) {\r\nupdate_worker_timing_details(connection, do_unqueued_work);\r\ndo_unqueued_work(connection);\r\n}\r\nif (signal_pending(current)) {\r\nflush_signals(current);\r\nif (get_t_state(thi) == RUNNING) {\r\ndrbd_warn(connection, "Worker got an unexpected signal\n");\r\ncontinue;\r\n}\r\nbreak;\r\n}\r\nif (get_t_state(thi) != RUNNING)\r\nbreak;\r\nif (!list_empty(&work_list)) {\r\nw = list_first_entry(&work_list, struct drbd_work, list);\r\nlist_del_init(&w->list);\r\nupdate_worker_timing_details(connection, w->cb);\r\nif (w->cb(w, connection->cstate < C_WF_REPORT_PARAMS) == 0)\r\ncontinue;\r\nif (connection->cstate >= C_WF_REPORT_PARAMS)\r\nconn_request_state(connection, NS(conn, C_NETWORK_FAILURE), CS_HARD);\r\n}\r\n}\r\ndo {\r\nif (test_and_clear_bit(DEVICE_WORK_PENDING, &connection->flags)) {\r\nupdate_worker_timing_details(connection, do_unqueued_work);\r\ndo_unqueued_work(connection);\r\n}\r\nif (!list_empty(&work_list)) {\r\nw = list_first_entry(&work_list, struct drbd_work, list);\r\nlist_del_init(&w->list);\r\nupdate_worker_timing_details(connection, w->cb);\r\nw->cb(w, 1);\r\n} else\r\ndequeue_work_batch(&connection->sender_work, &work_list);\r\n} while (!list_empty(&work_list) || test_bit(DEVICE_WORK_PENDING, &connection->flags));\r\nrcu_read_lock();\r\nidr_for_each_entry(&connection->peer_devices, peer_device, vnr) {\r\nstruct drbd_device *device = peer_device->device;\r\nD_ASSERT(device, device->state.disk == D_DISKLESS && device->state.conn == C_STANDALONE);\r\nkref_get(&device->kref);\r\nrcu_read_unlock();\r\ndrbd_device_cleanup(device);\r\nkref_put(&device->kref, drbd_destroy_device);\r\nrcu_read_lock();\r\n}\r\nrcu_read_unlock();\r\nreturn 0;\r\n}
