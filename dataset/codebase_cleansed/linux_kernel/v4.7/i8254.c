static void pit_set_gate(struct kvm_pit *pit, int channel, u32 val)\r\n{\r\nstruct kvm_kpit_channel_state *c = &pit->pit_state.channels[channel];\r\nswitch (c->mode) {\r\ndefault:\r\ncase 0:\r\ncase 4:\r\nbreak;\r\ncase 1:\r\ncase 2:\r\ncase 3:\r\ncase 5:\r\nif (c->gate < val)\r\nc->count_load_time = ktime_get();\r\nbreak;\r\n}\r\nc->gate = val;\r\n}\r\nstatic int pit_get_gate(struct kvm_pit *pit, int channel)\r\n{\r\nreturn pit->pit_state.channels[channel].gate;\r\n}\r\nstatic s64 __kpit_elapsed(struct kvm_pit *pit)\r\n{\r\ns64 elapsed;\r\nktime_t remaining;\r\nstruct kvm_kpit_state *ps = &pit->pit_state;\r\nif (!ps->period)\r\nreturn 0;\r\nremaining = hrtimer_get_remaining(&ps->timer);\r\nelapsed = ps->period - ktime_to_ns(remaining);\r\nreturn elapsed;\r\n}\r\nstatic s64 kpit_elapsed(struct kvm_pit *pit, struct kvm_kpit_channel_state *c,\r\nint channel)\r\n{\r\nif (channel == 0)\r\nreturn __kpit_elapsed(pit);\r\nreturn ktime_to_ns(ktime_sub(ktime_get(), c->count_load_time));\r\n}\r\nstatic int pit_get_count(struct kvm_pit *pit, int channel)\r\n{\r\nstruct kvm_kpit_channel_state *c = &pit->pit_state.channels[channel];\r\ns64 d, t;\r\nint counter;\r\nt = kpit_elapsed(pit, c, channel);\r\nd = mul_u64_u32_div(t, KVM_PIT_FREQ, NSEC_PER_SEC);\r\nswitch (c->mode) {\r\ncase 0:\r\ncase 1:\r\ncase 4:\r\ncase 5:\r\ncounter = (c->count - d) & 0xffff;\r\nbreak;\r\ncase 3:\r\ncounter = c->count - (mod_64((2 * d), c->count));\r\nbreak;\r\ndefault:\r\ncounter = c->count - mod_64(d, c->count);\r\nbreak;\r\n}\r\nreturn counter;\r\n}\r\nstatic int pit_get_out(struct kvm_pit *pit, int channel)\r\n{\r\nstruct kvm_kpit_channel_state *c = &pit->pit_state.channels[channel];\r\ns64 d, t;\r\nint out;\r\nt = kpit_elapsed(pit, c, channel);\r\nd = mul_u64_u32_div(t, KVM_PIT_FREQ, NSEC_PER_SEC);\r\nswitch (c->mode) {\r\ndefault:\r\ncase 0:\r\nout = (d >= c->count);\r\nbreak;\r\ncase 1:\r\nout = (d < c->count);\r\nbreak;\r\ncase 2:\r\nout = ((mod_64(d, c->count) == 0) && (d != 0));\r\nbreak;\r\ncase 3:\r\nout = (mod_64(d, c->count) < ((c->count + 1) >> 1));\r\nbreak;\r\ncase 4:\r\ncase 5:\r\nout = (d == c->count);\r\nbreak;\r\n}\r\nreturn out;\r\n}\r\nstatic void pit_latch_count(struct kvm_pit *pit, int channel)\r\n{\r\nstruct kvm_kpit_channel_state *c = &pit->pit_state.channels[channel];\r\nif (!c->count_latched) {\r\nc->latched_count = pit_get_count(pit, channel);\r\nc->count_latched = c->rw_mode;\r\n}\r\n}\r\nstatic void pit_latch_status(struct kvm_pit *pit, int channel)\r\n{\r\nstruct kvm_kpit_channel_state *c = &pit->pit_state.channels[channel];\r\nif (!c->status_latched) {\r\nc->status = ((pit_get_out(pit, channel) << 7) |\r\n(c->rw_mode << 4) |\r\n(c->mode << 1) |\r\nc->bcd);\r\nc->status_latched = 1;\r\n}\r\n}\r\nstatic inline struct kvm_pit *pit_state_to_pit(struct kvm_kpit_state *ps)\r\n{\r\nreturn container_of(ps, struct kvm_pit, pit_state);\r\n}\r\nstatic void kvm_pit_ack_irq(struct kvm_irq_ack_notifier *kian)\r\n{\r\nstruct kvm_kpit_state *ps = container_of(kian, struct kvm_kpit_state,\r\nirq_ack_notifier);\r\nstruct kvm_pit *pit = pit_state_to_pit(ps);\r\natomic_set(&ps->irq_ack, 1);\r\nsmp_mb();\r\nif (atomic_dec_if_positive(&ps->pending) > 0)\r\nqueue_kthread_work(&pit->worker, &pit->expired);\r\n}\r\nvoid __kvm_migrate_pit_timer(struct kvm_vcpu *vcpu)\r\n{\r\nstruct kvm_pit *pit = vcpu->kvm->arch.vpit;\r\nstruct hrtimer *timer;\r\nif (!kvm_vcpu_is_bsp(vcpu) || !pit)\r\nreturn;\r\ntimer = &pit->pit_state.timer;\r\nmutex_lock(&pit->pit_state.lock);\r\nif (hrtimer_cancel(timer))\r\nhrtimer_start_expires(timer, HRTIMER_MODE_ABS);\r\nmutex_unlock(&pit->pit_state.lock);\r\n}\r\nstatic void destroy_pit_timer(struct kvm_pit *pit)\r\n{\r\nhrtimer_cancel(&pit->pit_state.timer);\r\nflush_kthread_work(&pit->expired);\r\n}\r\nstatic void pit_do_work(struct kthread_work *work)\r\n{\r\nstruct kvm_pit *pit = container_of(work, struct kvm_pit, expired);\r\nstruct kvm *kvm = pit->kvm;\r\nstruct kvm_vcpu *vcpu;\r\nint i;\r\nstruct kvm_kpit_state *ps = &pit->pit_state;\r\nif (atomic_read(&ps->reinject) && !atomic_xchg(&ps->irq_ack, 0))\r\nreturn;\r\nkvm_set_irq(kvm, pit->irq_source_id, 0, 1, false);\r\nkvm_set_irq(kvm, pit->irq_source_id, 0, 0, false);\r\nif (atomic_read(&kvm->arch.vapics_in_nmi_mode) > 0)\r\nkvm_for_each_vcpu(i, vcpu, kvm)\r\nkvm_apic_nmi_wd_deliver(vcpu);\r\n}\r\nstatic enum hrtimer_restart pit_timer_fn(struct hrtimer *data)\r\n{\r\nstruct kvm_kpit_state *ps = container_of(data, struct kvm_kpit_state, timer);\r\nstruct kvm_pit *pt = pit_state_to_pit(ps);\r\nif (atomic_read(&ps->reinject))\r\natomic_inc(&ps->pending);\r\nqueue_kthread_work(&pt->worker, &pt->expired);\r\nif (ps->is_periodic) {\r\nhrtimer_add_expires_ns(&ps->timer, ps->period);\r\nreturn HRTIMER_RESTART;\r\n} else\r\nreturn HRTIMER_NORESTART;\r\n}\r\nstatic inline void kvm_pit_reset_reinject(struct kvm_pit *pit)\r\n{\r\natomic_set(&pit->pit_state.pending, 0);\r\natomic_set(&pit->pit_state.irq_ack, 1);\r\n}\r\nvoid kvm_pit_set_reinject(struct kvm_pit *pit, bool reinject)\r\n{\r\nstruct kvm_kpit_state *ps = &pit->pit_state;\r\nstruct kvm *kvm = pit->kvm;\r\nif (atomic_read(&ps->reinject) == reinject)\r\nreturn;\r\nif (reinject) {\r\nkvm_pit_reset_reinject(pit);\r\nkvm_register_irq_ack_notifier(kvm, &ps->irq_ack_notifier);\r\nkvm_register_irq_mask_notifier(kvm, 0, &pit->mask_notifier);\r\n} else {\r\nkvm_unregister_irq_ack_notifier(kvm, &ps->irq_ack_notifier);\r\nkvm_unregister_irq_mask_notifier(kvm, 0, &pit->mask_notifier);\r\n}\r\natomic_set(&ps->reinject, reinject);\r\n}\r\nstatic void create_pit_timer(struct kvm_pit *pit, u32 val, int is_period)\r\n{\r\nstruct kvm_kpit_state *ps = &pit->pit_state;\r\nstruct kvm *kvm = pit->kvm;\r\ns64 interval;\r\nif (!ioapic_in_kernel(kvm) ||\r\nps->flags & KVM_PIT_FLAGS_HPET_LEGACY)\r\nreturn;\r\ninterval = mul_u64_u32_div(val, NSEC_PER_SEC, KVM_PIT_FREQ);\r\npr_debug("create pit timer, interval is %llu nsec\n", interval);\r\nhrtimer_cancel(&ps->timer);\r\nflush_kthread_work(&pit->expired);\r\nps->period = interval;\r\nps->is_periodic = is_period;\r\nkvm_pit_reset_reinject(pit);\r\nif (ps->is_periodic) {\r\ns64 min_period = min_timer_period_us * 1000LL;\r\nif (ps->period < min_period) {\r\npr_info_ratelimited(\r\n"kvm: requested %lld ns "\r\n"i8254 timer period limited to %lld ns\n",\r\nps->period, min_period);\r\nps->period = min_period;\r\n}\r\n}\r\nhrtimer_start(&ps->timer, ktime_add_ns(ktime_get(), interval),\r\nHRTIMER_MODE_ABS);\r\n}\r\nstatic void pit_load_count(struct kvm_pit *pit, int channel, u32 val)\r\n{\r\nstruct kvm_kpit_state *ps = &pit->pit_state;\r\npr_debug("load_count val is %d, channel is %d\n", val, channel);\r\nif (val == 0)\r\nval = 0x10000;\r\nps->channels[channel].count = val;\r\nif (channel != 0) {\r\nps->channels[channel].count_load_time = ktime_get();\r\nreturn;\r\n}\r\nswitch (ps->channels[0].mode) {\r\ncase 0:\r\ncase 1:\r\ncase 4:\r\ncreate_pit_timer(pit, val, 0);\r\nbreak;\r\ncase 2:\r\ncase 3:\r\ncreate_pit_timer(pit, val, 1);\r\nbreak;\r\ndefault:\r\ndestroy_pit_timer(pit);\r\n}\r\n}\r\nvoid kvm_pit_load_count(struct kvm_pit *pit, int channel, u32 val,\r\nint hpet_legacy_start)\r\n{\r\nu8 saved_mode;\r\nWARN_ON_ONCE(!mutex_is_locked(&pit->pit_state.lock));\r\nif (hpet_legacy_start) {\r\nWARN_ON(channel != 0);\r\nsaved_mode = pit->pit_state.channels[0].mode;\r\npit->pit_state.channels[0].mode = 0xff;\r\npit_load_count(pit, channel, val);\r\npit->pit_state.channels[0].mode = saved_mode;\r\n} else {\r\npit_load_count(pit, channel, val);\r\n}\r\n}\r\nstatic inline struct kvm_pit *dev_to_pit(struct kvm_io_device *dev)\r\n{\r\nreturn container_of(dev, struct kvm_pit, dev);\r\n}\r\nstatic inline struct kvm_pit *speaker_to_pit(struct kvm_io_device *dev)\r\n{\r\nreturn container_of(dev, struct kvm_pit, speaker_dev);\r\n}\r\nstatic inline int pit_in_range(gpa_t addr)\r\n{\r\nreturn ((addr >= KVM_PIT_BASE_ADDRESS) &&\r\n(addr < KVM_PIT_BASE_ADDRESS + KVM_PIT_MEM_LENGTH));\r\n}\r\nstatic int pit_ioport_write(struct kvm_vcpu *vcpu,\r\nstruct kvm_io_device *this,\r\ngpa_t addr, int len, const void *data)\r\n{\r\nstruct kvm_pit *pit = dev_to_pit(this);\r\nstruct kvm_kpit_state *pit_state = &pit->pit_state;\r\nint channel, access;\r\nstruct kvm_kpit_channel_state *s;\r\nu32 val = *(u32 *) data;\r\nif (!pit_in_range(addr))\r\nreturn -EOPNOTSUPP;\r\nval &= 0xff;\r\naddr &= KVM_PIT_CHANNEL_MASK;\r\nmutex_lock(&pit_state->lock);\r\nif (val != 0)\r\npr_debug("write addr is 0x%x, len is %d, val is 0x%x\n",\r\n(unsigned int)addr, len, val);\r\nif (addr == 3) {\r\nchannel = val >> 6;\r\nif (channel == 3) {\r\nfor (channel = 0; channel < 3; channel++) {\r\ns = &pit_state->channels[channel];\r\nif (val & (2 << channel)) {\r\nif (!(val & 0x20))\r\npit_latch_count(pit, channel);\r\nif (!(val & 0x10))\r\npit_latch_status(pit, channel);\r\n}\r\n}\r\n} else {\r\ns = &pit_state->channels[channel];\r\naccess = (val >> 4) & KVM_PIT_CHANNEL_MASK;\r\nif (access == 0) {\r\npit_latch_count(pit, channel);\r\n} else {\r\ns->rw_mode = access;\r\ns->read_state = access;\r\ns->write_state = access;\r\ns->mode = (val >> 1) & 7;\r\nif (s->mode > 5)\r\ns->mode -= 4;\r\ns->bcd = val & 1;\r\n}\r\n}\r\n} else {\r\ns = &pit_state->channels[addr];\r\nswitch (s->write_state) {\r\ndefault:\r\ncase RW_STATE_LSB:\r\npit_load_count(pit, addr, val);\r\nbreak;\r\ncase RW_STATE_MSB:\r\npit_load_count(pit, addr, val << 8);\r\nbreak;\r\ncase RW_STATE_WORD0:\r\ns->write_latch = val;\r\ns->write_state = RW_STATE_WORD1;\r\nbreak;\r\ncase RW_STATE_WORD1:\r\npit_load_count(pit, addr, s->write_latch | (val << 8));\r\ns->write_state = RW_STATE_WORD0;\r\nbreak;\r\n}\r\n}\r\nmutex_unlock(&pit_state->lock);\r\nreturn 0;\r\n}\r\nstatic int pit_ioport_read(struct kvm_vcpu *vcpu,\r\nstruct kvm_io_device *this,\r\ngpa_t addr, int len, void *data)\r\n{\r\nstruct kvm_pit *pit = dev_to_pit(this);\r\nstruct kvm_kpit_state *pit_state = &pit->pit_state;\r\nint ret, count;\r\nstruct kvm_kpit_channel_state *s;\r\nif (!pit_in_range(addr))\r\nreturn -EOPNOTSUPP;\r\naddr &= KVM_PIT_CHANNEL_MASK;\r\nif (addr == 3)\r\nreturn 0;\r\ns = &pit_state->channels[addr];\r\nmutex_lock(&pit_state->lock);\r\nif (s->status_latched) {\r\ns->status_latched = 0;\r\nret = s->status;\r\n} else if (s->count_latched) {\r\nswitch (s->count_latched) {\r\ndefault:\r\ncase RW_STATE_LSB:\r\nret = s->latched_count & 0xff;\r\ns->count_latched = 0;\r\nbreak;\r\ncase RW_STATE_MSB:\r\nret = s->latched_count >> 8;\r\ns->count_latched = 0;\r\nbreak;\r\ncase RW_STATE_WORD0:\r\nret = s->latched_count & 0xff;\r\ns->count_latched = RW_STATE_MSB;\r\nbreak;\r\n}\r\n} else {\r\nswitch (s->read_state) {\r\ndefault:\r\ncase RW_STATE_LSB:\r\ncount = pit_get_count(pit, addr);\r\nret = count & 0xff;\r\nbreak;\r\ncase RW_STATE_MSB:\r\ncount = pit_get_count(pit, addr);\r\nret = (count >> 8) & 0xff;\r\nbreak;\r\ncase RW_STATE_WORD0:\r\ncount = pit_get_count(pit, addr);\r\nret = count & 0xff;\r\ns->read_state = RW_STATE_WORD1;\r\nbreak;\r\ncase RW_STATE_WORD1:\r\ncount = pit_get_count(pit, addr);\r\nret = (count >> 8) & 0xff;\r\ns->read_state = RW_STATE_WORD0;\r\nbreak;\r\n}\r\n}\r\nif (len > sizeof(ret))\r\nlen = sizeof(ret);\r\nmemcpy(data, (char *)&ret, len);\r\nmutex_unlock(&pit_state->lock);\r\nreturn 0;\r\n}\r\nstatic int speaker_ioport_write(struct kvm_vcpu *vcpu,\r\nstruct kvm_io_device *this,\r\ngpa_t addr, int len, const void *data)\r\n{\r\nstruct kvm_pit *pit = speaker_to_pit(this);\r\nstruct kvm_kpit_state *pit_state = &pit->pit_state;\r\nu32 val = *(u32 *) data;\r\nif (addr != KVM_SPEAKER_BASE_ADDRESS)\r\nreturn -EOPNOTSUPP;\r\nmutex_lock(&pit_state->lock);\r\npit_state->speaker_data_on = (val >> 1) & 1;\r\npit_set_gate(pit, 2, val & 1);\r\nmutex_unlock(&pit_state->lock);\r\nreturn 0;\r\n}\r\nstatic int speaker_ioport_read(struct kvm_vcpu *vcpu,\r\nstruct kvm_io_device *this,\r\ngpa_t addr, int len, void *data)\r\n{\r\nstruct kvm_pit *pit = speaker_to_pit(this);\r\nstruct kvm_kpit_state *pit_state = &pit->pit_state;\r\nunsigned int refresh_clock;\r\nint ret;\r\nif (addr != KVM_SPEAKER_BASE_ADDRESS)\r\nreturn -EOPNOTSUPP;\r\nrefresh_clock = ((unsigned int)ktime_to_ns(ktime_get()) >> 14) & 1;\r\nmutex_lock(&pit_state->lock);\r\nret = ((pit_state->speaker_data_on << 1) | pit_get_gate(pit, 2) |\r\n(pit_get_out(pit, 2) << 5) | (refresh_clock << 4));\r\nif (len > sizeof(ret))\r\nlen = sizeof(ret);\r\nmemcpy(data, (char *)&ret, len);\r\nmutex_unlock(&pit_state->lock);\r\nreturn 0;\r\n}\r\nstatic void kvm_pit_reset(struct kvm_pit *pit)\r\n{\r\nint i;\r\nstruct kvm_kpit_channel_state *c;\r\npit->pit_state.flags = 0;\r\nfor (i = 0; i < 3; i++) {\r\nc = &pit->pit_state.channels[i];\r\nc->mode = 0xff;\r\nc->gate = (i != 2);\r\npit_load_count(pit, i, 0);\r\n}\r\nkvm_pit_reset_reinject(pit);\r\n}\r\nstatic void pit_mask_notifer(struct kvm_irq_mask_notifier *kimn, bool mask)\r\n{\r\nstruct kvm_pit *pit = container_of(kimn, struct kvm_pit, mask_notifier);\r\nif (!mask)\r\nkvm_pit_reset_reinject(pit);\r\n}\r\nstruct kvm_pit *kvm_create_pit(struct kvm *kvm, u32 flags)\r\n{\r\nstruct kvm_pit *pit;\r\nstruct kvm_kpit_state *pit_state;\r\nstruct pid *pid;\r\npid_t pid_nr;\r\nint ret;\r\npit = kzalloc(sizeof(struct kvm_pit), GFP_KERNEL);\r\nif (!pit)\r\nreturn NULL;\r\npit->irq_source_id = kvm_request_irq_source_id(kvm);\r\nif (pit->irq_source_id < 0)\r\ngoto fail_request;\r\nmutex_init(&pit->pit_state.lock);\r\npid = get_pid(task_tgid(current));\r\npid_nr = pid_vnr(pid);\r\nput_pid(pid);\r\ninit_kthread_worker(&pit->worker);\r\npit->worker_task = kthread_run(kthread_worker_fn, &pit->worker,\r\n"kvm-pit/%d", pid_nr);\r\nif (IS_ERR(pit->worker_task))\r\ngoto fail_kthread;\r\ninit_kthread_work(&pit->expired, pit_do_work);\r\npit->kvm = kvm;\r\npit_state = &pit->pit_state;\r\nhrtimer_init(&pit_state->timer, CLOCK_MONOTONIC, HRTIMER_MODE_ABS);\r\npit_state->timer.function = pit_timer_fn;\r\npit_state->irq_ack_notifier.gsi = 0;\r\npit_state->irq_ack_notifier.irq_acked = kvm_pit_ack_irq;\r\npit->mask_notifier.func = pit_mask_notifer;\r\nkvm_pit_reset(pit);\r\nkvm_pit_set_reinject(pit, true);\r\nkvm_iodevice_init(&pit->dev, &pit_dev_ops);\r\nret = kvm_io_bus_register_dev(kvm, KVM_PIO_BUS, KVM_PIT_BASE_ADDRESS,\r\nKVM_PIT_MEM_LENGTH, &pit->dev);\r\nif (ret < 0)\r\ngoto fail_register_pit;\r\nif (flags & KVM_PIT_SPEAKER_DUMMY) {\r\nkvm_iodevice_init(&pit->speaker_dev, &speaker_dev_ops);\r\nret = kvm_io_bus_register_dev(kvm, KVM_PIO_BUS,\r\nKVM_SPEAKER_BASE_ADDRESS, 4,\r\n&pit->speaker_dev);\r\nif (ret < 0)\r\ngoto fail_register_speaker;\r\n}\r\nreturn pit;\r\nfail_register_speaker:\r\nkvm_io_bus_unregister_dev(kvm, KVM_PIO_BUS, &pit->dev);\r\nfail_register_pit:\r\nkvm_pit_set_reinject(pit, false);\r\nkthread_stop(pit->worker_task);\r\nfail_kthread:\r\nkvm_free_irq_source_id(kvm, pit->irq_source_id);\r\nfail_request:\r\nkfree(pit);\r\nreturn NULL;\r\n}\r\nvoid kvm_free_pit(struct kvm *kvm)\r\n{\r\nstruct kvm_pit *pit = kvm->arch.vpit;\r\nif (pit) {\r\nkvm_io_bus_unregister_dev(kvm, KVM_PIO_BUS, &pit->dev);\r\nkvm_io_bus_unregister_dev(kvm, KVM_PIO_BUS, &pit->speaker_dev);\r\nkvm_pit_set_reinject(pit, false);\r\nhrtimer_cancel(&pit->pit_state.timer);\r\nflush_kthread_work(&pit->expired);\r\nkthread_stop(pit->worker_task);\r\nkvm_free_irq_source_id(kvm, pit->irq_source_id);\r\nkfree(pit);\r\n}\r\n}
