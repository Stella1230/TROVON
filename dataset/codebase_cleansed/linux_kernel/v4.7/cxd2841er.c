static void cxd2841er_i2c_debug(struct cxd2841er_priv *priv,\r\nu8 addr, u8 reg, u8 write,\r\nconst u8 *data, u32 len)\r\n{\r\ndev_dbg(&priv->i2c->dev,\r\n"cxd2841er: I2C %s addr %02x reg 0x%02x size %d\n",\r\n(write == 0 ? "read" : "write"), addr, reg, len);\r\nprint_hex_dump_bytes("cxd2841er: I2C data: ",\r\nDUMP_PREFIX_OFFSET, data, len);\r\n}\r\nstatic int cxd2841er_write_regs(struct cxd2841er_priv *priv,\r\nu8 addr, u8 reg, const u8 *data, u32 len)\r\n{\r\nint ret;\r\nu8 buf[MAX_WRITE_REGSIZE + 1];\r\nu8 i2c_addr = (addr == I2C_SLVX ?\r\npriv->i2c_addr_slvx : priv->i2c_addr_slvt);\r\nstruct i2c_msg msg[1] = {\r\n{\r\n.addr = i2c_addr,\r\n.flags = 0,\r\n.len = len + 1,\r\n.buf = buf,\r\n}\r\n};\r\nif (len + 1 >= sizeof(buf)) {\r\ndev_warn(&priv->i2c->dev,"wr reg=%04x: len=%d is too big!\n",\r\nreg, len + 1);\r\nreturn -E2BIG;\r\n}\r\ncxd2841er_i2c_debug(priv, i2c_addr, reg, 1, data, len);\r\nbuf[0] = reg;\r\nmemcpy(&buf[1], data, len);\r\nret = i2c_transfer(priv->i2c, msg, 1);\r\nif (ret >= 0 && ret != 1)\r\nret = -EIO;\r\nif (ret < 0) {\r\ndev_warn(&priv->i2c->dev,\r\n"%s: i2c wr failed=%d addr=%02x reg=%02x len=%d\n",\r\nKBUILD_MODNAME, ret, i2c_addr, reg, len);\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic int cxd2841er_write_reg(struct cxd2841er_priv *priv,\r\nu8 addr, u8 reg, u8 val)\r\n{\r\nreturn cxd2841er_write_regs(priv, addr, reg, &val, 1);\r\n}\r\nstatic int cxd2841er_read_regs(struct cxd2841er_priv *priv,\r\nu8 addr, u8 reg, u8 *val, u32 len)\r\n{\r\nint ret;\r\nu8 i2c_addr = (addr == I2C_SLVX ?\r\npriv->i2c_addr_slvx : priv->i2c_addr_slvt);\r\nstruct i2c_msg msg[2] = {\r\n{\r\n.addr = i2c_addr,\r\n.flags = 0,\r\n.len = 1,\r\n.buf = &reg,\r\n}, {\r\n.addr = i2c_addr,\r\n.flags = I2C_M_RD,\r\n.len = len,\r\n.buf = val,\r\n}\r\n};\r\nret = i2c_transfer(priv->i2c, &msg[0], 1);\r\nif (ret >= 0 && ret != 1)\r\nret = -EIO;\r\nif (ret < 0) {\r\ndev_warn(&priv->i2c->dev,\r\n"%s: i2c rw failed=%d addr=%02x reg=%02x\n",\r\nKBUILD_MODNAME, ret, i2c_addr, reg);\r\nreturn ret;\r\n}\r\nret = i2c_transfer(priv->i2c, &msg[1], 1);\r\nif (ret >= 0 && ret != 1)\r\nret = -EIO;\r\nif (ret < 0) {\r\ndev_warn(&priv->i2c->dev,\r\n"%s: i2c rd failed=%d addr=%02x reg=%02x\n",\r\nKBUILD_MODNAME, ret, i2c_addr, reg);\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic int cxd2841er_read_reg(struct cxd2841er_priv *priv,\r\nu8 addr, u8 reg, u8 *val)\r\n{\r\nreturn cxd2841er_read_regs(priv, addr, reg, val, 1);\r\n}\r\nstatic int cxd2841er_set_reg_bits(struct cxd2841er_priv *priv,\r\nu8 addr, u8 reg, u8 data, u8 mask)\r\n{\r\nint res;\r\nu8 rdata;\r\nif (mask != 0xff) {\r\nres = cxd2841er_read_reg(priv, addr, reg, &rdata);\r\nif (res)\r\nreturn res;\r\ndata = ((data & mask) | (rdata & (mask ^ 0xFF)));\r\n}\r\nreturn cxd2841er_write_reg(priv, addr, reg, data);\r\n}\r\nstatic int cxd2841er_dvbs2_set_symbol_rate(struct cxd2841er_priv *priv,\r\nu32 symbol_rate)\r\n{\r\nu32 reg_value = 0;\r\nu8 data[3] = {0, 0, 0};\r\ndev_dbg(&priv->i2c->dev, "%s()\n", __func__);\r\nreg_value = DIV_ROUND_CLOSEST(symbol_rate * 16384, 1000);\r\nif ((reg_value == 0) || (reg_value > 0xFFFFF)) {\r\ndev_err(&priv->i2c->dev,\r\n"%s(): reg_value is out of range\n", __func__);\r\nreturn -EINVAL;\r\n}\r\ndata[0] = (u8)((reg_value >> 16) & 0x0F);\r\ndata[1] = (u8)((reg_value >> 8) & 0xFF);\r\ndata[2] = (u8)(reg_value & 0xFF);\r\ncxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0xae);\r\ncxd2841er_write_regs(priv, I2C_SLVT, 0x20, data, 3);\r\nreturn 0;\r\n}\r\nstatic int cxd2841er_sleep_s_to_active_s(struct cxd2841er_priv *priv,\r\nu8 system, u32 symbol_rate)\r\n{\r\nint ret;\r\nu8 data[4] = { 0, 0, 0, 0 };\r\nif (priv->state != STATE_SLEEP_S) {\r\ndev_err(&priv->i2c->dev, "%s(): invalid state %d\n",\r\n__func__, (int)priv->state);\r\nreturn -EINVAL;\r\n}\r\ndev_dbg(&priv->i2c->dev, "%s()\n", __func__);\r\ncxd2841er_set_ts_clock_mode(priv, SYS_DVBS);\r\nif (system == SYS_DVBS) {\r\ndata[0] = 0x0A;\r\n} else if (system == SYS_DVBS2) {\r\ndata[0] = 0x0B;\r\n} else {\r\ndev_err(&priv->i2c->dev, "%s(): invalid delsys %d\n",\r\n__func__, system);\r\nreturn -EINVAL;\r\n}\r\ncxd2841er_write_reg(priv, I2C_SLVX, 0x00, 0x00);\r\ncxd2841er_write_reg(priv, I2C_SLVX, 0x17, data[0]);\r\ndata[0] = 0x00;\r\ncxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x00);\r\ncxd2841er_write_reg(priv, I2C_SLVT, 0x2d, data[0]);\r\ncxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0xae);\r\ncxd2841er_write_reg(priv, I2C_SLVT, 0x30, data[0]);\r\ncxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x00);\r\ncxd2841er_write_reg(priv, I2C_SLVT, 0x2c, 0x01);\r\ncxd2841er_write_reg(priv, I2C_SLVT, 0x31, 0x01);\r\ncxd2841er_write_reg(priv, I2C_SLVT, 0x63, 0x16);\r\ncxd2841er_write_reg(priv, I2C_SLVT, 0x65, 0x3f);\r\ncxd2841er_write_reg(priv, I2C_SLVX, 0x00, 0x00);\r\ncxd2841er_write_reg(priv, I2C_SLVX, 0x18, 0x00);\r\ncxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0xa3);\r\ncxd2841er_write_reg(priv, I2C_SLVT, 0xac, 0x00);\r\ndata[0] = 0x07;\r\ndata[1] = 0x3B;\r\ndata[2] = 0x08;\r\ndata[3] = 0xC5;\r\ncxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0xab);\r\ncxd2841er_write_regs(priv, I2C_SLVT, 0x98, data, 4);\r\ndata[0] = 0x05;\r\ndata[1] = 0x80;\r\ndata[2] = 0x0A;\r\ndata[3] = 0x80;\r\ncxd2841er_write_regs(priv, I2C_SLVT, 0xa8, data, 4);\r\ndata[0] = 0x0C;\r\ndata[1] = 0xCC;\r\ncxd2841er_write_regs(priv, I2C_SLVT, 0xc3, data, 2);\r\nret = cxd2841er_dvbs2_set_symbol_rate(priv, symbol_rate);\r\nif (ret != 0)\r\nreturn ret;\r\ncxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x00);\r\ncxd2841er_write_reg(priv, I2C_SLVT, 0x80, 0x10);\r\ncxd2841er_write_reg(priv, I2C_SLVT, 0x81, 0x00);\r\npriv->state = STATE_ACTIVE_S;\r\nreturn 0;\r\n}\r\nstatic int cxd2841er_retune_active(struct cxd2841er_priv *priv,\r\nstruct dtv_frontend_properties *p)\r\n{\r\ndev_dbg(&priv->i2c->dev, "%s()\n", __func__);\r\nif (priv->state != STATE_ACTIVE_S &&\r\npriv->state != STATE_ACTIVE_TC) {\r\ndev_dbg(&priv->i2c->dev, "%s(): invalid state %d\n",\r\n__func__, priv->state);\r\nreturn -EINVAL;\r\n}\r\ncxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x00);\r\ncxd2841er_write_reg(priv, I2C_SLVT, 0xc3, 0x01);\r\nif (priv->state == STATE_ACTIVE_S)\r\nreturn cxd2841er_dvbs2_set_symbol_rate(\r\npriv, p->symbol_rate / 1000);\r\nelse if (priv->state == STATE_ACTIVE_TC) {\r\nswitch (priv->system) {\r\ncase SYS_DVBT:\r\nreturn cxd2841er_sleep_tc_to_active_t_band(\r\npriv, p->bandwidth_hz);\r\ncase SYS_DVBT2:\r\nreturn cxd2841er_sleep_tc_to_active_t2_band(\r\npriv, p->bandwidth_hz);\r\ncase SYS_DVBC_ANNEX_A:\r\nreturn cxd2841er_sleep_tc_to_active_c_band(\r\npriv, 8000000);\r\n}\r\n}\r\ndev_dbg(&priv->i2c->dev, "%s(): invalid delivery system %d\n",\r\n__func__, priv->system);\r\nreturn -EINVAL;\r\n}\r\nstatic int cxd2841er_active_s_to_sleep_s(struct cxd2841er_priv *priv)\r\n{\r\ndev_dbg(&priv->i2c->dev, "%s()\n", __func__);\r\nif (priv->state != STATE_ACTIVE_S) {\r\ndev_err(&priv->i2c->dev, "%s(): invalid state %d\n",\r\n__func__, priv->state);\r\nreturn -EINVAL;\r\n}\r\ncxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x00);\r\ncxd2841er_write_reg(priv, I2C_SLVT, 0xc3, 0x01);\r\ncxd2841er_write_reg(priv, I2C_SLVT, 0x80, 0x1f);\r\ncxd2841er_write_reg(priv, I2C_SLVT, 0x81, 0xff);\r\ncxd2841er_write_reg(priv, I2C_SLVX, 0x00, 0x00);\r\ncxd2841er_write_reg(priv, I2C_SLVX, 0x18, 0x01);\r\ncxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x00);\r\ncxd2841er_write_reg(priv, I2C_SLVT, 0x31, 0x00);\r\ncxd2841er_write_reg(priv, I2C_SLVT, 0x63, 0x16);\r\ncxd2841er_write_reg(priv, I2C_SLVT, 0x65, 0x27);\r\ncxd2841er_write_reg(priv, I2C_SLVT, 0x69, 0x06);\r\ncxd2841er_write_reg(priv, I2C_SLVT, 0x2c, 0x00);\r\ncxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0xae);\r\ncxd2841er_write_reg(priv, I2C_SLVT, 0x30, 0x00);\r\ncxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x00);\r\ncxd2841er_write_reg(priv, I2C_SLVT, 0x2d, 0x00);\r\npriv->state = STATE_SLEEP_S;\r\nreturn 0;\r\n}\r\nstatic int cxd2841er_sleep_s_to_shutdown(struct cxd2841er_priv *priv)\r\n{\r\ndev_dbg(&priv->i2c->dev, "%s()\n", __func__);\r\nif (priv->state != STATE_SLEEP_S) {\r\ndev_dbg(&priv->i2c->dev, "%s(): invalid demod state %d\n",\r\n__func__, priv->state);\r\nreturn -EINVAL;\r\n}\r\ncxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x00);\r\ncxd2841er_write_reg(priv, I2C_SLVT, 0x80, 0x3f);\r\ncxd2841er_write_reg(priv, I2C_SLVT, 0x9c, 0x00);\r\ncxd2841er_write_reg(priv, I2C_SLVX, 0x00, 0x00);\r\ncxd2841er_write_reg(priv, I2C_SLVX, 0x15, 0x01);\r\ncxd2841er_write_reg(priv, I2C_SLVX, 0x17, 0x01);\r\npriv->state = STATE_SHUTDOWN;\r\nreturn 0;\r\n}\r\nstatic int cxd2841er_sleep_tc_to_shutdown(struct cxd2841er_priv *priv)\r\n{\r\ndev_dbg(&priv->i2c->dev, "%s()\n", __func__);\r\nif (priv->state != STATE_SLEEP_TC) {\r\ndev_dbg(&priv->i2c->dev, "%s(): invalid demod state %d\n",\r\n__func__, priv->state);\r\nreturn -EINVAL;\r\n}\r\ncxd2841er_write_reg(priv, I2C_SLVX, 0x00, 0x00);\r\ncxd2841er_write_reg(priv, I2C_SLVX, 0x15, 0x01);\r\ncxd2841er_write_reg(priv, I2C_SLVX, 0x17, 0x01);\r\npriv->state = STATE_SHUTDOWN;\r\nreturn 0;\r\n}\r\nstatic int cxd2841er_active_t_to_sleep_tc(struct cxd2841er_priv *priv)\r\n{\r\ndev_dbg(&priv->i2c->dev, "%s()\n", __func__);\r\nif (priv->state != STATE_ACTIVE_TC) {\r\ndev_err(&priv->i2c->dev, "%s(): invalid state %d\n",\r\n__func__, priv->state);\r\nreturn -EINVAL;\r\n}\r\ncxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x00);\r\ncxd2841er_write_reg(priv, I2C_SLVT, 0xc3, 0x01);\r\ncxd2841er_write_reg(priv, I2C_SLVT, 0x80, 0x3f);\r\ncxd2841er_write_reg(priv, I2C_SLVT, 0x81, 0xff);\r\ncxd2841er_write_reg(priv, I2C_SLVX, 0x00, 0x00);\r\ncxd2841er_write_reg(priv, I2C_SLVX, 0x18, 0x01);\r\ncxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x00);\r\ncxd2841er_write_reg(priv, I2C_SLVT, 0x43, 0x0a);\r\ncxd2841er_write_reg(priv, I2C_SLVT, 0x41, 0x0a);\r\ncxd2841er_write_reg(priv, I2C_SLVT, 0x30, 0x00);\r\ncxd2841er_write_reg(priv, I2C_SLVT, 0x2f, 0x00);\r\ncxd2841er_write_reg(priv, I2C_SLVT, 0x2c, 0x00);\r\npriv->state = STATE_SLEEP_TC;\r\nreturn 0;\r\n}\r\nstatic int cxd2841er_active_t2_to_sleep_tc(struct cxd2841er_priv *priv)\r\n{\r\ndev_dbg(&priv->i2c->dev, "%s()\n", __func__);\r\nif (priv->state != STATE_ACTIVE_TC) {\r\ndev_err(&priv->i2c->dev, "%s(): invalid state %d\n",\r\n__func__, priv->state);\r\nreturn -EINVAL;\r\n}\r\ncxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x00);\r\ncxd2841er_write_reg(priv, I2C_SLVT, 0xc3, 0x01);\r\ncxd2841er_write_reg(priv, I2C_SLVT, 0x80, 0x3f);\r\ncxd2841er_write_reg(priv, I2C_SLVT, 0x81, 0xff);\r\ncxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x13);\r\ncxd2841er_write_reg(priv, I2C_SLVT, 0x83, 0x40);\r\ncxd2841er_write_reg(priv, I2C_SLVT, 0x86, 0x21);\r\ncxd2841er_set_reg_bits(priv, I2C_SLVT, 0x9e, 0x09, 0x0f);\r\ncxd2841er_write_reg(priv, I2C_SLVT, 0x9f, 0xfb);\r\ncxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x2a);\r\ncxd2841er_set_reg_bits(priv, I2C_SLVT, 0x38, 0x00, 0x0f);\r\ncxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x2b);\r\ncxd2841er_set_reg_bits(priv, I2C_SLVT, 0x11, 0x00, 0x3f);\r\ncxd2841er_write_reg(priv, I2C_SLVX, 0x00, 0x00);\r\ncxd2841er_write_reg(priv, I2C_SLVX, 0x18, 0x01);\r\ncxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x00);\r\ncxd2841er_write_reg(priv, I2C_SLVT, 0x43, 0x0a);\r\ncxd2841er_write_reg(priv, I2C_SLVT, 0x41, 0x0a);\r\ncxd2841er_write_reg(priv, I2C_SLVT, 0x30, 0x00);\r\ncxd2841er_write_reg(priv, I2C_SLVT, 0x2f, 0x00);\r\ncxd2841er_write_reg(priv, I2C_SLVT, 0x2c, 0x00);\r\npriv->state = STATE_SLEEP_TC;\r\nreturn 0;\r\n}\r\nstatic int cxd2841er_active_c_to_sleep_tc(struct cxd2841er_priv *priv)\r\n{\r\ndev_dbg(&priv->i2c->dev, "%s()\n", __func__);\r\nif (priv->state != STATE_ACTIVE_TC) {\r\ndev_err(&priv->i2c->dev, "%s(): invalid state %d\n",\r\n__func__, priv->state);\r\nreturn -EINVAL;\r\n}\r\ncxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x00);\r\ncxd2841er_write_reg(priv, I2C_SLVT, 0xc3, 0x01);\r\ncxd2841er_write_reg(priv, I2C_SLVT, 0x80, 0x3f);\r\ncxd2841er_write_reg(priv, I2C_SLVT, 0x81, 0xff);\r\ncxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x11);\r\ncxd2841er_set_reg_bits(priv, I2C_SLVT, 0xa3, 0x00, 0x1f);\r\ncxd2841er_write_reg(priv, I2C_SLVX, 0x00, 0x00);\r\ncxd2841er_write_reg(priv, I2C_SLVX, 0x18, 0x01);\r\ncxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x00);\r\ncxd2841er_write_reg(priv, I2C_SLVT, 0x43, 0x0a);\r\ncxd2841er_write_reg(priv, I2C_SLVT, 0x41, 0x0a);\r\ncxd2841er_write_reg(priv, I2C_SLVT, 0x30, 0x00);\r\ncxd2841er_write_reg(priv, I2C_SLVT, 0x2f, 0x00);\r\ncxd2841er_write_reg(priv, I2C_SLVT, 0x2c, 0x00);\r\npriv->state = STATE_SLEEP_TC;\r\nreturn 0;\r\n}\r\nstatic int cxd2841er_shutdown_to_sleep_s(struct cxd2841er_priv *priv)\r\n{\r\ndev_dbg(&priv->i2c->dev, "%s()\n", __func__);\r\nif (priv->state != STATE_SHUTDOWN) {\r\ndev_dbg(&priv->i2c->dev, "%s(): invalid demod state %d\n",\r\n__func__, priv->state);\r\nreturn -EINVAL;\r\n}\r\ncxd2841er_write_reg(priv, I2C_SLVX, 0x00, 0x00);\r\ncxd2841er_write_reg(priv, I2C_SLVX, 0x02, 0x00);\r\nusleep_range(3000, 5000);\r\ncxd2841er_write_reg(priv, I2C_SLVX, 0x00, 0x00);\r\ncxd2841er_write_reg(priv, I2C_SLVX, 0x10, 0x01);\r\ncxd2841er_write_reg(priv, I2C_SLVX, 0x14, 0x00);\r\ncxd2841er_write_reg(priv, I2C_SLVX, 0x17, 0x0a);\r\ncxd2841er_write_reg(priv, I2C_SLVX, 0x10, 0x00);\r\nusleep_range(1000, 2000);\r\ncxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x00);\r\ncxd2841er_write_reg(priv, I2C_SLVT, 0x80, 0x1F);\r\ncxd2841er_write_reg(priv, I2C_SLVT, 0x9C, 0x40);\r\ncxd2841er_write_reg(priv, I2C_SLVT, 0x43, 0x0a);\r\ncxd2841er_write_reg(priv, I2C_SLVT, 0x41, 0x0a);\r\ncxd2841er_write_reg(priv, I2C_SLVT, 0x63, 0x16);\r\ncxd2841er_write_reg(priv, I2C_SLVT, 0x65, 0x27);\r\ncxd2841er_write_reg(priv, I2C_SLVT, 0x69, 0x06);\r\npriv->state = STATE_SLEEP_S;\r\nreturn 0;\r\n}\r\nstatic int cxd2841er_shutdown_to_sleep_tc(struct cxd2841er_priv *priv)\r\n{\r\ndev_dbg(&priv->i2c->dev, "%s()\n", __func__);\r\nif (priv->state != STATE_SHUTDOWN) {\r\ndev_dbg(&priv->i2c->dev, "%s(): invalid demod state %d\n",\r\n__func__, priv->state);\r\nreturn -EINVAL;\r\n}\r\ncxd2841er_write_reg(priv, I2C_SLVX, 0x00, 0x00);\r\ncxd2841er_write_reg(priv, I2C_SLVX, 0x02, 0x00);\r\nusleep_range(3000, 5000);\r\ncxd2841er_write_reg(priv, I2C_SLVX, 0x00, 0x00);\r\ncxd2841er_write_reg(priv, I2C_SLVX, 0x10, 0x01);\r\ncxd2841er_write_reg(priv, I2C_SLVX, 0x13, 0x00);\r\ncxd2841er_write_reg(priv, I2C_SLVX, 0x14, 0x00);\r\ncxd2841er_write_reg(priv, I2C_SLVX, 0x10, 0x00);\r\nusleep_range(1000, 2000);\r\ncxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x00);\r\ncxd2841er_write_reg(priv, I2C_SLVT, 0x43, 0x0a);\r\ncxd2841er_write_reg(priv, I2C_SLVT, 0x41, 0x0a);\r\ncxd2841er_write_reg(priv, I2C_SLVT, 0x63, 0x16);\r\ncxd2841er_write_reg(priv, I2C_SLVT, 0x65, 0x27);\r\ncxd2841er_write_reg(priv, I2C_SLVT, 0x69, 0x06);\r\npriv->state = STATE_SLEEP_TC;\r\nreturn 0;\r\n}\r\nstatic int cxd2841er_tune_done(struct cxd2841er_priv *priv)\r\n{\r\ndev_dbg(&priv->i2c->dev, "%s()\n", __func__);\r\ncxd2841er_write_reg(priv, I2C_SLVT, 0, 0);\r\ncxd2841er_write_reg(priv, I2C_SLVT, 0xfe, 0x01);\r\ncxd2841er_write_reg(priv, I2C_SLVT, 0xc3, 0x00);\r\nreturn 0;\r\n}\r\nstatic void cxd2841er_set_ts_clock_mode(struct cxd2841er_priv *priv,\r\nu8 system)\r\n{\r\nu8 serial_ts, ts_rate_ctrl_off, ts_in_off;\r\ndev_dbg(&priv->i2c->dev, "%s()\n", __func__);\r\ncxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x00);\r\ncxd2841er_read_reg(priv, I2C_SLVT, 0xc4, &serial_ts);\r\ncxd2841er_read_reg(priv, I2C_SLVT, 0xd3, &ts_rate_ctrl_off);\r\ncxd2841er_read_reg(priv, I2C_SLVT, 0xde, &ts_in_off);\r\ndev_dbg(&priv->i2c->dev, "%s(): ser_ts=0x%02x rate_ctrl_off=0x%02x in_off=0x%02x\n",\r\n__func__, serial_ts, ts_rate_ctrl_off, ts_in_off);\r\ncxd2841er_write_reg(priv, I2C_SLVT, 0xd9, 0x08);\r\ncxd2841er_set_reg_bits(priv, I2C_SLVT, 0x32, 0x00, 0x01);\r\ncxd2841er_set_reg_bits(priv, I2C_SLVT, 0x33, 0x00, 0x03);\r\ncxd2841er_set_reg_bits(priv, I2C_SLVT, 0x32, 0x01, 0x01);\r\nif (system == SYS_DVBT) {\r\ncxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x10);\r\ncxd2841er_set_reg_bits(priv, I2C_SLVT, 0x66, 0x01, 0x01);\r\n} else if (system == SYS_DVBC_ANNEX_A) {\r\ncxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x40);\r\ncxd2841er_set_reg_bits(priv, I2C_SLVT, 0x66, 0x01, 0x01);\r\n}\r\n}\r\nstatic u8 cxd2841er_chip_id(struct cxd2841er_priv *priv)\r\n{\r\nu8 chip_id;\r\ndev_dbg(&priv->i2c->dev, "%s()\n", __func__);\r\ncxd2841er_write_reg(priv, I2C_SLVT, 0, 0);\r\ncxd2841er_read_reg(priv, I2C_SLVT, 0xfd, &chip_id);\r\nreturn chip_id;\r\n}\r\nstatic int cxd2841er_read_status_s(struct dvb_frontend *fe,\r\nenum fe_status *status)\r\n{\r\nu8 reg = 0;\r\nstruct cxd2841er_priv *priv = fe->demodulator_priv;\r\ndev_dbg(&priv->i2c->dev, "%s()\n", __func__);\r\n*status = 0;\r\nif (priv->state != STATE_ACTIVE_S) {\r\ndev_err(&priv->i2c->dev, "%s(): invalid state %d\n",\r\n__func__, priv->state);\r\nreturn -EINVAL;\r\n}\r\ncxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0xa0);\r\ncxd2841er_read_reg(priv, I2C_SLVT, 0x11, &reg);\r\nif (reg & 0x04) {\r\n*status = FE_HAS_SIGNAL\r\n| FE_HAS_CARRIER\r\n| FE_HAS_VITERBI\r\n| FE_HAS_SYNC\r\n| FE_HAS_LOCK;\r\n}\r\ndev_dbg(&priv->i2c->dev, "%s(): result 0x%x\n", __func__, *status);\r\nreturn 0;\r\n}\r\nstatic int cxd2841er_read_status_t_t2(struct cxd2841er_priv *priv,\r\nu8 *sync, u8 *tslock, u8 *unlock)\r\n{\r\nu8 data = 0;\r\ndev_dbg(&priv->i2c->dev, "%s()\n", __func__);\r\nif (priv->state != STATE_ACTIVE_TC)\r\nreturn -EINVAL;\r\nif (priv->system == SYS_DVBT) {\r\ncxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x10);\r\n} else {\r\ncxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x20);\r\n}\r\ncxd2841er_read_reg(priv, I2C_SLVT, 0x10, &data);\r\nif ((data & 0x07) == 0x07) {\r\ndev_dbg(&priv->i2c->dev,\r\n"%s(): invalid hardware state detected\n", __func__);\r\n*sync = 0;\r\n*tslock = 0;\r\n*unlock = 0;\r\n} else {\r\n*sync = ((data & 0x07) == 0x6 ? 1 : 0);\r\n*tslock = ((data & 0x20) ? 1 : 0);\r\n*unlock = ((data & 0x10) ? 1 : 0);\r\n}\r\nreturn 0;\r\n}\r\nstatic int cxd2841er_read_status_c(struct cxd2841er_priv *priv, u8 *tslock)\r\n{\r\nu8 data;\r\ndev_dbg(&priv->i2c->dev, "%s()\n", __func__);\r\nif (priv->state != STATE_ACTIVE_TC)\r\nreturn -EINVAL;\r\ncxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x40);\r\ncxd2841er_read_reg(priv, I2C_SLVT, 0x88, &data);\r\nif ((data & 0x01) == 0) {\r\n*tslock = 0;\r\n} else {\r\ncxd2841er_read_reg(priv, I2C_SLVT, 0x10, &data);\r\n*tslock = ((data & 0x20) ? 1 : 0);\r\n}\r\nreturn 0;\r\n}\r\nstatic int cxd2841er_read_status_tc(struct dvb_frontend *fe,\r\nenum fe_status *status)\r\n{\r\nint ret = 0;\r\nu8 sync = 0;\r\nu8 tslock = 0;\r\nu8 unlock = 0;\r\nstruct cxd2841er_priv *priv = fe->demodulator_priv;\r\n*status = 0;\r\nif (priv->state == STATE_ACTIVE_TC) {\r\nif (priv->system == SYS_DVBT || priv->system == SYS_DVBT2) {\r\nret = cxd2841er_read_status_t_t2(\r\npriv, &sync, &tslock, &unlock);\r\nif (ret)\r\ngoto done;\r\nif (unlock)\r\ngoto done;\r\nif (sync)\r\n*status = FE_HAS_SIGNAL |\r\nFE_HAS_CARRIER |\r\nFE_HAS_VITERBI |\r\nFE_HAS_SYNC;\r\nif (tslock)\r\n*status |= FE_HAS_LOCK;\r\n} else if (priv->system == SYS_DVBC_ANNEX_A) {\r\nret = cxd2841er_read_status_c(priv, &tslock);\r\nif (ret)\r\ngoto done;\r\nif (tslock)\r\n*status = FE_HAS_SIGNAL |\r\nFE_HAS_CARRIER |\r\nFE_HAS_VITERBI |\r\nFE_HAS_SYNC |\r\nFE_HAS_LOCK;\r\n}\r\n}\r\ndone:\r\ndev_dbg(&priv->i2c->dev, "%s(): status 0x%x\n", __func__, *status);\r\nreturn ret;\r\n}\r\nstatic int cxd2841er_get_carrier_offset_s_s2(struct cxd2841er_priv *priv,\r\nint *offset)\r\n{\r\nu8 data[3];\r\nu8 is_hs_mode;\r\ns32 cfrl_ctrlval;\r\ns32 temp_div, temp_q, temp_r;\r\nif (priv->state != STATE_ACTIVE_S) {\r\ndev_dbg(&priv->i2c->dev, "%s(): invalid state %d\n",\r\n__func__, priv->state);\r\nreturn -EINVAL;\r\n}\r\ncxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0xa0);\r\ncxd2841er_read_reg(priv, I2C_SLVT, 0x10, &data[0]);\r\nif (data[0] & 0x01) {\r\ncxd2841er_read_reg(priv, I2C_SLVT, 0x50, &data[0]);\r\nis_hs_mode = (data[0] & 0x10 ? 1 : 0);\r\n} else {\r\ndev_dbg(&priv->i2c->dev,\r\n"%s(): unable to detect sampling rate mode\n",\r\n__func__);\r\nreturn -EINVAL;\r\n}\r\ncxd2841er_read_regs(priv, I2C_SLVT, 0x45, data, 3);\r\ncfrl_ctrlval = sign_extend32((((u32)data[0] & 0x1F) << 16) |\r\n(((u32)data[1] & 0xFF) << 8) |\r\n((u32)data[2] & 0xFF), 20);\r\ntemp_div = (is_hs_mode ? 1048576 : 1572864);\r\nif (cfrl_ctrlval > 0) {\r\ntemp_q = div_s64_rem(97375LL * cfrl_ctrlval,\r\ntemp_div, &temp_r);\r\n} else {\r\ntemp_q = div_s64_rem(-97375LL * cfrl_ctrlval,\r\ntemp_div, &temp_r);\r\n}\r\nif (temp_r >= temp_div / 2)\r\ntemp_q++;\r\nif (cfrl_ctrlval > 0)\r\ntemp_q *= -1;\r\n*offset = temp_q;\r\nreturn 0;\r\n}\r\nstatic int cxd2841er_get_carrier_offset_t2(struct cxd2841er_priv *priv,\r\nu32 bandwidth, int *offset)\r\n{\r\nu8 data[4];\r\ndev_dbg(&priv->i2c->dev, "%s()\n", __func__);\r\nif (priv->state != STATE_ACTIVE_TC) {\r\ndev_dbg(&priv->i2c->dev, "%s(): invalid state %d\n",\r\n__func__, priv->state);\r\nreturn -EINVAL;\r\n}\r\nif (priv->system != SYS_DVBT2) {\r\ndev_dbg(&priv->i2c->dev, "%s(): invalid delivery system %d\n",\r\n__func__, priv->system);\r\nreturn -EINVAL;\r\n}\r\ncxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x20);\r\ncxd2841er_read_regs(priv, I2C_SLVT, 0x4c, data, sizeof(data));\r\n*offset = -1 * sign_extend32(\r\n((u32)(data[0] & 0x0F) << 24) | ((u32)data[1] << 16) |\r\n((u32)data[2] << 8) | (u32)data[3], 27);\r\nswitch (bandwidth) {\r\ncase 1712000:\r\n*offset /= 582;\r\nbreak;\r\ncase 5000000:\r\ncase 6000000:\r\ncase 7000000:\r\ncase 8000000:\r\n*offset *= (bandwidth / 1000000);\r\n*offset /= 940;\r\nbreak;\r\ndefault:\r\ndev_dbg(&priv->i2c->dev, "%s(): invalid bandwidth %d\n",\r\n__func__, bandwidth);\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int cxd2841er_get_carrier_offset_c(struct cxd2841er_priv *priv,\r\nint *offset)\r\n{\r\nu8 data[2];\r\ndev_dbg(&priv->i2c->dev, "%s()\n", __func__);\r\nif (priv->state != STATE_ACTIVE_TC) {\r\ndev_dbg(&priv->i2c->dev, "%s(): invalid state %d\n",\r\n__func__, priv->state);\r\nreturn -EINVAL;\r\n}\r\nif (priv->system != SYS_DVBC_ANNEX_A) {\r\ndev_dbg(&priv->i2c->dev, "%s(): invalid delivery system %d\n",\r\n__func__, priv->system);\r\nreturn -EINVAL;\r\n}\r\ncxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x40);\r\ncxd2841er_read_regs(priv, I2C_SLVT, 0x15, data, sizeof(data));\r\n*offset = div_s64(41000LL * sign_extend32((((u32)data[0] & 0x3f) << 8)\r\n| (u32)data[1], 13), 16384);\r\nreturn 0;\r\n}\r\nstatic int cxd2841er_read_packet_errors_t(\r\nstruct cxd2841er_priv *priv, u32 *penum)\r\n{\r\nu8 data[3];\r\n*penum = 0;\r\nif (priv->state != STATE_ACTIVE_TC) {\r\ndev_dbg(&priv->i2c->dev, "%s(): invalid state %d\n",\r\n__func__, priv->state);\r\nreturn -EINVAL;\r\n}\r\ncxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x10);\r\ncxd2841er_read_regs(priv, I2C_SLVT, 0xea, data, sizeof(data));\r\nif (data[2] & 0x01)\r\n*penum = ((u32)data[0] << 8) | (u32)data[1];\r\nreturn 0;\r\n}\r\nstatic int cxd2841er_read_packet_errors_t2(\r\nstruct cxd2841er_priv *priv, u32 *penum)\r\n{\r\nu8 data[3];\r\n*penum = 0;\r\nif (priv->state != STATE_ACTIVE_TC) {\r\ndev_dbg(&priv->i2c->dev, "%s(): invalid state %d\n",\r\n__func__, priv->state);\r\nreturn -EINVAL;\r\n}\r\ncxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x24);\r\ncxd2841er_read_regs(priv, I2C_SLVT, 0xfd, data, sizeof(data));\r\nif (data[0] & 0x01)\r\n*penum = ((u32)data[1] << 8) | (u32)data[2];\r\nreturn 0;\r\n}\r\nstatic u32 cxd2841er_mon_read_ber_s(struct cxd2841er_priv *priv)\r\n{\r\nu8 data[11];\r\nu32 bit_error, bit_count;\r\nu32 temp_q, temp_r;\r\ncxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0xa0);\r\ncxd2841er_read_regs(priv, I2C_SLVT, 0x35, data, 11);\r\nif (data[0] & 0x01) {\r\nbit_error = ((u32)(data[1] & 0x3F) << 16) |\r\n((u32)(data[2] & 0xFF) << 8) |\r\n(u32)(data[3] & 0xFF);\r\nbit_count = ((u32)(data[8] & 0x3F) << 16) |\r\n((u32)(data[9] & 0xFF) << 8) |\r\n(u32)(data[10] & 0xFF);\r\nif ((bit_count == 0) || (bit_error > bit_count)) {\r\ndev_dbg(&priv->i2c->dev,\r\n"%s(): invalid bit_error %d, bit_count %d\n",\r\n__func__, bit_error, bit_count);\r\nreturn 0;\r\n}\r\ntemp_q = div_u64_rem(10000000ULL * bit_error,\r\nbit_count, &temp_r);\r\nif (bit_count != 1 && temp_r >= bit_count / 2)\r\ntemp_q++;\r\nreturn temp_q;\r\n}\r\ndev_dbg(&priv->i2c->dev, "%s(): no data available\n", __func__);\r\nreturn 0;\r\n}\r\nstatic u32 cxd2841er_mon_read_ber_s2(struct cxd2841er_priv *priv)\r\n{\r\nu8 data[5];\r\nu32 bit_error, period;\r\nu32 temp_q, temp_r;\r\nu32 result = 0;\r\ncxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0xb2);\r\ncxd2841er_read_regs(priv, I2C_SLVT, 0x30, data, 5);\r\nif (data[0] & 0x01) {\r\nbit_error = ((u32)(data[1] & 0x0F) << 24) |\r\n((u32)(data[2] & 0xFF) << 16) |\r\n((u32)(data[3] & 0xFF) << 8) |\r\n(u32)(data[4] & 0xFF);\r\ncxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0xa0);\r\ncxd2841er_read_reg(priv, I2C_SLVT, 0x7a, data);\r\nperiod = (u32)(1 << (data[0] & 0x0F));\r\nif (period == 0) {\r\ndev_dbg(&priv->i2c->dev,\r\n"%s(): period is 0\n", __func__);\r\nreturn 0;\r\n}\r\nif (bit_error > (period * 64800)) {\r\ndev_dbg(&priv->i2c->dev,\r\n"%s(): invalid bit_err 0x%x period 0x%x\n",\r\n__func__, bit_error, period);\r\nreturn 0;\r\n}\r\ntemp_q = div_u64_rem(12500ULL * bit_error,\r\nperiod * 81, &temp_r);\r\nif (temp_r >= period * 40)\r\ntemp_q++;\r\nresult = temp_q;\r\n} else {\r\ndev_dbg(&priv->i2c->dev,\r\n"%s(): no data available\n", __func__);\r\n}\r\nreturn result;\r\n}\r\nstatic int cxd2841er_read_ber_t2(struct cxd2841er_priv *priv, u32 *ber)\r\n{\r\nu8 data[4];\r\nu32 div, q, r;\r\nu32 bit_err, period_exp, n_ldpc;\r\n*ber = 0;\r\nif (priv->state != STATE_ACTIVE_TC) {\r\ndev_dbg(&priv->i2c->dev,\r\n"%s(): invalid state %d\n", __func__, priv->state);\r\nreturn -EINVAL;\r\n}\r\ncxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x20);\r\ncxd2841er_read_regs(priv, I2C_SLVT, 0x39, data, sizeof(data));\r\nif (!(data[0] & 0x10)) {\r\ndev_dbg(&priv->i2c->dev,\r\n"%s(): no valid BER data\n", __func__);\r\nreturn 0;\r\n}\r\nbit_err = ((u32)(data[0] & 0x0f) << 24) |\r\n((u32)data[1] << 16) |\r\n((u32)data[2] << 8) |\r\n(u32)data[3];\r\ncxd2841er_read_reg(priv, I2C_SLVT, 0x6f, data);\r\nperiod_exp = data[0] & 0x0f;\r\ncxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x22);\r\ncxd2841er_read_reg(priv, I2C_SLVT, 0x5e, data);\r\nn_ldpc = ((data[0] & 0x03) == 0 ? 16200 : 64800);\r\nif (bit_err > ((1U << period_exp) * n_ldpc)) {\r\ndev_dbg(&priv->i2c->dev,\r\n"%s(): invalid BER value\n", __func__);\r\nreturn -EINVAL;\r\n}\r\nif (period_exp >= 4) {\r\ndiv = (1U << (period_exp - 4)) * (n_ldpc / 200);\r\nq = div_u64_rem(3125ULL * bit_err, div, &r);\r\n} else {\r\ndiv = (1U << period_exp) * (n_ldpc / 200);\r\nq = div_u64_rem(50000ULL * bit_err, div, &r);\r\n}\r\n*ber = (r >= div / 2) ? q + 1 : q;\r\nreturn 0;\r\n}\r\nstatic int cxd2841er_read_ber_t(struct cxd2841er_priv *priv, u32 *ber)\r\n{\r\nu8 data[2];\r\nu32 div, q, r;\r\nu32 bit_err, period;\r\n*ber = 0;\r\nif (priv->state != STATE_ACTIVE_TC) {\r\ndev_dbg(&priv->i2c->dev,\r\n"%s(): invalid state %d\n", __func__, priv->state);\r\nreturn -EINVAL;\r\n}\r\ncxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x10);\r\ncxd2841er_read_reg(priv, I2C_SLVT, 0x39, data);\r\nif (!(data[0] & 0x01)) {\r\ndev_dbg(&priv->i2c->dev,\r\n"%s(): no valid BER data\n", __func__);\r\nreturn 0;\r\n}\r\ncxd2841er_read_regs(priv, I2C_SLVT, 0x22, data, sizeof(data));\r\nbit_err = ((u32)data[0] << 8) | (u32)data[1];\r\ncxd2841er_read_reg(priv, I2C_SLVT, 0x6f, data);\r\nperiod = ((data[0] & 0x07) == 0) ? 256 : (4096 << (data[0] & 0x07));\r\ndiv = period / 128;\r\nq = div_u64_rem(78125ULL * bit_err, div, &r);\r\n*ber = (r >= div / 2) ? q + 1 : q;\r\nreturn 0;\r\n}\r\nstatic u32 cxd2841er_dvbs_read_snr(struct cxd2841er_priv *priv, u8 delsys)\r\n{\r\nu8 data[3];\r\nu32 res = 0, value;\r\nint min_index, max_index, index;\r\nstatic const struct cxd2841er_cnr_data *cn_data;\r\ncxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0xa1);\r\ncxd2841er_read_regs(priv, I2C_SLVT, 0x10, data, 3);\r\nif (data[0] & 0x01) {\r\nvalue = ((u32)(data[1] & 0x1F) << 8) | (u32)(data[2] & 0xFF);\r\nmin_index = 0;\r\nif (delsys == SYS_DVBS) {\r\ncn_data = s_cn_data;\r\nmax_index = sizeof(s_cn_data) /\r\nsizeof(s_cn_data[0]) - 1;\r\n} else {\r\ncn_data = s2_cn_data;\r\nmax_index = sizeof(s2_cn_data) /\r\nsizeof(s2_cn_data[0]) - 1;\r\n}\r\nif (value >= cn_data[min_index].value) {\r\nres = cn_data[min_index].cnr_x1000;\r\ngoto done;\r\n}\r\nif (value <= cn_data[max_index].value) {\r\nres = cn_data[max_index].cnr_x1000;\r\ngoto done;\r\n}\r\nwhile ((max_index - min_index) > 1) {\r\nindex = (max_index + min_index) / 2;\r\nif (value == cn_data[index].value) {\r\nres = cn_data[index].cnr_x1000;\r\ngoto done;\r\n} else if (value > cn_data[index].value)\r\nmax_index = index;\r\nelse\r\nmin_index = index;\r\nif ((max_index - min_index) <= 1) {\r\nif (value == cn_data[max_index].value) {\r\nres = cn_data[max_index].cnr_x1000;\r\ngoto done;\r\n} else {\r\nres = cn_data[min_index].cnr_x1000;\r\ngoto done;\r\n}\r\n}\r\n}\r\n} else {\r\ndev_dbg(&priv->i2c->dev,\r\n"%s(): no data available\n", __func__);\r\n}\r\ndone:\r\nreturn res;\r\n}\r\nstatic int cxd2841er_read_snr_t(struct cxd2841er_priv *priv, u32 *snr)\r\n{\r\nu32 reg;\r\nu8 data[2];\r\n*snr = 0;\r\nif (priv->state != STATE_ACTIVE_TC) {\r\ndev_dbg(&priv->i2c->dev,\r\n"%s(): invalid state %d\n", __func__, priv->state);\r\nreturn -EINVAL;\r\n}\r\ncxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x10);\r\ncxd2841er_read_regs(priv, I2C_SLVT, 0x28, data, sizeof(data));\r\nreg = ((u32)data[0] << 8) | (u32)data[1];\r\nif (reg == 0) {\r\ndev_dbg(&priv->i2c->dev,\r\n"%s(): reg value out of range\n", __func__);\r\nreturn 0;\r\n}\r\nif (reg > 4996)\r\nreg = 4996;\r\n*snr = 10000 * ((intlog10(reg) - intlog10(5350 - reg)) >> 24) + 28500;\r\nreturn 0;\r\n}\r\nstatic int cxd2841er_read_snr_t2(struct cxd2841er_priv *priv, u32 *snr)\r\n{\r\nu32 reg;\r\nu8 data[2];\r\n*snr = 0;\r\nif (priv->state != STATE_ACTIVE_TC) {\r\ndev_dbg(&priv->i2c->dev,\r\n"%s(): invalid state %d\n", __func__, priv->state);\r\nreturn -EINVAL;\r\n}\r\ncxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x20);\r\ncxd2841er_read_regs(priv, I2C_SLVT, 0x28, data, sizeof(data));\r\nreg = ((u32)data[0] << 8) | (u32)data[1];\r\nif (reg == 0) {\r\ndev_dbg(&priv->i2c->dev,\r\n"%s(): reg value out of range\n", __func__);\r\nreturn 0;\r\n}\r\nif (reg > 10876)\r\nreg = 10876;\r\n*snr = 10000 * ((intlog10(reg) -\r\nintlog10(12600 - reg)) >> 24) + 32000;\r\nreturn 0;\r\n}\r\nstatic u16 cxd2841er_read_agc_gain_t_t2(struct cxd2841er_priv *priv,\r\nu8 delsys)\r\n{\r\nu8 data[2];\r\ncxd2841er_write_reg(\r\npriv, I2C_SLVT, 0x00, (delsys == SYS_DVBT ? 0x10 : 0x20));\r\ncxd2841er_read_regs(priv, I2C_SLVT, 0x26, data, 2);\r\nreturn ((((u16)data[0] & 0x0F) << 8) | (u16)(data[1] & 0xFF)) << 4;\r\n}\r\nstatic u16 cxd2841er_read_agc_gain_s(struct cxd2841er_priv *priv)\r\n{\r\nu8 data[2];\r\ncxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0xa0);\r\ncxd2841er_read_regs(priv, I2C_SLVT, 0x1f, data, 2);\r\nreturn ((((u16)data[0] & 0x1F) << 8) | (u16)(data[1] & 0xFF)) << 3;\r\n}\r\nstatic int cxd2841er_read_ber(struct dvb_frontend *fe, u32 *ber)\r\n{\r\nstruct dtv_frontend_properties *p = &fe->dtv_property_cache;\r\nstruct cxd2841er_priv *priv = fe->demodulator_priv;\r\ndev_dbg(&priv->i2c->dev, "%s()\n", __func__);\r\n*ber = 0;\r\nswitch (p->delivery_system) {\r\ncase SYS_DVBS:\r\n*ber = cxd2841er_mon_read_ber_s(priv);\r\nbreak;\r\ncase SYS_DVBS2:\r\n*ber = cxd2841er_mon_read_ber_s2(priv);\r\nbreak;\r\ncase SYS_DVBT:\r\nreturn cxd2841er_read_ber_t(priv, ber);\r\ncase SYS_DVBT2:\r\nreturn cxd2841er_read_ber_t2(priv, ber);\r\ndefault:\r\n*ber = 0;\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic int cxd2841er_read_signal_strength(struct dvb_frontend *fe,\r\nu16 *strength)\r\n{\r\nstruct dtv_frontend_properties *p = &fe->dtv_property_cache;\r\nstruct cxd2841er_priv *priv = fe->demodulator_priv;\r\ndev_dbg(&priv->i2c->dev, "%s()\n", __func__);\r\nswitch (p->delivery_system) {\r\ncase SYS_DVBT:\r\ncase SYS_DVBT2:\r\n*strength = 65535 - cxd2841er_read_agc_gain_t_t2(\r\npriv, p->delivery_system);\r\nbreak;\r\ncase SYS_DVBS:\r\ncase SYS_DVBS2:\r\n*strength = 65535 - cxd2841er_read_agc_gain_s(priv);\r\nbreak;\r\ndefault:\r\n*strength = 0;\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic int cxd2841er_read_snr(struct dvb_frontend *fe, u16 *snr)\r\n{\r\nu32 tmp = 0;\r\nstruct dtv_frontend_properties *p = &fe->dtv_property_cache;\r\nstruct cxd2841er_priv *priv = fe->demodulator_priv;\r\ndev_dbg(&priv->i2c->dev, "%s()\n", __func__);\r\nswitch (p->delivery_system) {\r\ncase SYS_DVBT:\r\ncxd2841er_read_snr_t(priv, &tmp);\r\nbreak;\r\ncase SYS_DVBT2:\r\ncxd2841er_read_snr_t2(priv, &tmp);\r\nbreak;\r\ncase SYS_DVBS:\r\ncase SYS_DVBS2:\r\ntmp = cxd2841er_dvbs_read_snr(priv, p->delivery_system);\r\nbreak;\r\ndefault:\r\ndev_dbg(&priv->i2c->dev, "%s(): unknown delivery system %d\n",\r\n__func__, p->delivery_system);\r\nbreak;\r\n}\r\n*snr = tmp & 0xffff;\r\nreturn 0;\r\n}\r\nstatic int cxd2841er_read_ucblocks(struct dvb_frontend *fe, u32 *ucblocks)\r\n{\r\nstruct dtv_frontend_properties *p = &fe->dtv_property_cache;\r\nstruct cxd2841er_priv *priv = fe->demodulator_priv;\r\ndev_dbg(&priv->i2c->dev, "%s()\n", __func__);\r\nswitch (p->delivery_system) {\r\ncase SYS_DVBT:\r\ncxd2841er_read_packet_errors_t(priv, ucblocks);\r\nbreak;\r\ncase SYS_DVBT2:\r\ncxd2841er_read_packet_errors_t2(priv, ucblocks);\r\nbreak;\r\ndefault:\r\n*ucblocks = 0;\r\nbreak;\r\n}\r\ndev_dbg(&priv->i2c->dev, "%s()\n", __func__);\r\nreturn 0;\r\n}\r\nstatic int cxd2841er_dvbt2_set_profile(\r\nstruct cxd2841er_priv *priv, enum cxd2841er_dvbt2_profile_t profile)\r\n{\r\nu8 tune_mode;\r\nu8 seq_not2d_time;\r\ndev_dbg(&priv->i2c->dev, "%s()\n", __func__);\r\nswitch (profile) {\r\ncase DVBT2_PROFILE_BASE:\r\ntune_mode = 0x01;\r\nseq_not2d_time = 12;\r\nbreak;\r\ncase DVBT2_PROFILE_LITE:\r\ntune_mode = 0x05;\r\nseq_not2d_time = 40;\r\nbreak;\r\ncase DVBT2_PROFILE_ANY:\r\ntune_mode = 0x00;\r\nseq_not2d_time = 40;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\ncxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x2e);\r\ncxd2841er_set_reg_bits(priv, I2C_SLVT, 0x10, tune_mode, 0x07);\r\ncxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x2b);\r\ncxd2841er_write_reg(priv, I2C_SLVT, 0x9d, seq_not2d_time);\r\nreturn 0;\r\n}\r\nstatic int cxd2841er_dvbt2_set_plp_config(struct cxd2841er_priv *priv,\r\nu8 is_auto, u8 plp_id)\r\n{\r\nif (is_auto) {\r\ndev_dbg(&priv->i2c->dev,\r\n"%s() using auto PLP selection\n", __func__);\r\n} else {\r\ndev_dbg(&priv->i2c->dev,\r\n"%s() using manual PLP selection, ID %d\n",\r\n__func__, plp_id);\r\n}\r\ncxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x23);\r\nif (!is_auto) {\r\ncxd2841er_write_reg(priv, I2C_SLVT, 0xaf, plp_id);\r\n}\r\ncxd2841er_write_reg(priv, I2C_SLVT, 0xad, (is_auto ? 0x00 : 0x01));\r\nreturn 0;\r\n}\r\nstatic int cxd2841er_sleep_tc_to_active_t2_band(struct cxd2841er_priv *priv,\r\nu32 bandwidth)\r\n{\r\nu32 iffreq;\r\nu8 b20_9f[5];\r\nu8 b10_a6[14];\r\nu8 b10_b6[3];\r\nu8 b10_d7;\r\ndev_dbg(&priv->i2c->dev, "%s()\n", __func__);\r\nswitch (bandwidth) {\r\ncase 8000000:\r\nb20_9f[0] = 0x11;\r\nb20_9f[1] = 0xf0;\r\nb20_9f[2] = 0x00;\r\nb20_9f[3] = 0x00;\r\nb20_9f[4] = 0x00;\r\nb10_a6[0] = 0x26;\r\nb10_a6[1] = 0xaf;\r\nb10_a6[2] = 0x06;\r\nb10_a6[3] = 0xcd;\r\nb10_a6[4] = 0x13;\r\nb10_a6[5] = 0xbb;\r\nb10_a6[6] = 0x28;\r\nb10_a6[7] = 0xba;\r\nb10_a6[8] = 0x23;\r\nb10_a6[9] = 0xa9;\r\nb10_a6[10] = 0x1f;\r\nb10_a6[11] = 0xa8;\r\nb10_a6[12] = 0x2c;\r\nb10_a6[13] = 0xc8;\r\niffreq = MAKE_IFFREQ_CONFIG(4.80);\r\nb10_d7 = 0x00;\r\nbreak;\r\ncase 7000000:\r\nb20_9f[0] = 0x14;\r\nb20_9f[1] = 0x80;\r\nb20_9f[2] = 0x00;\r\nb20_9f[3] = 0x00;\r\nb20_9f[4] = 0x00;\r\nb10_a6[0] = 0x2C;\r\nb10_a6[1] = 0xBD;\r\nb10_a6[2] = 0x02;\r\nb10_a6[3] = 0xCF;\r\nb10_a6[4] = 0x04;\r\nb10_a6[5] = 0xF8;\r\nb10_a6[6] = 0x23;\r\nb10_a6[7] = 0xA6;\r\nb10_a6[8] = 0x29;\r\nb10_a6[9] = 0xB0;\r\nb10_a6[10] = 0x26;\r\nb10_a6[11] = 0xA9;\r\nb10_a6[12] = 0x21;\r\nb10_a6[13] = 0xA5;\r\niffreq = MAKE_IFFREQ_CONFIG(4.2);\r\nb10_d7 = 0x02;\r\nbreak;\r\ncase 6000000:\r\nb20_9f[0] = 0x17;\r\nb20_9f[1] = 0xEA;\r\nb20_9f[2] = 0xAA;\r\nb20_9f[3] = 0xAA;\r\nb20_9f[4] = 0xAA;\r\nb10_a6[0] = 0x27;\r\nb10_a6[1] = 0xA7;\r\nb10_a6[2] = 0x28;\r\nb10_a6[3] = 0xB3;\r\nb10_a6[4] = 0x02;\r\nb10_a6[5] = 0xF0;\r\nb10_a6[6] = 0x01;\r\nb10_a6[7] = 0xE8;\r\nb10_a6[8] = 0x00;\r\nb10_a6[9] = 0xCF;\r\nb10_a6[10] = 0x00;\r\nb10_a6[11] = 0xE6;\r\nb10_a6[12] = 0x23;\r\nb10_a6[13] = 0xA4;\r\niffreq = MAKE_IFFREQ_CONFIG(3.6);\r\nb10_d7 = 0x04;\r\nbreak;\r\ncase 5000000:\r\nb20_9f[0] = 0x1C;\r\nb20_9f[1] = 0xB3;\r\nb20_9f[2] = 0x33;\r\nb20_9f[3] = 0x33;\r\nb20_9f[4] = 0x33;\r\nb10_a6[0] = 0x27;\r\nb10_a6[1] = 0xA7;\r\nb10_a6[2] = 0x28;\r\nb10_a6[3] = 0xB3;\r\nb10_a6[4] = 0x02;\r\nb10_a6[5] = 0xF0;\r\nb10_a6[6] = 0x01;\r\nb10_a6[7] = 0xE8;\r\nb10_a6[8] = 0x00;\r\nb10_a6[9] = 0xCF;\r\nb10_a6[10] = 0x00;\r\nb10_a6[11] = 0xE6;\r\nb10_a6[12] = 0x23;\r\nb10_a6[13] = 0xA4;\r\niffreq = MAKE_IFFREQ_CONFIG(3.6);\r\nb10_d7 = 0x06;\r\nbreak;\r\ncase 1712000:\r\nb20_9f[0] = 0x58;\r\nb20_9f[1] = 0xE2;\r\nb20_9f[2] = 0xAF;\r\nb20_9f[3] = 0xE0;\r\nb20_9f[4] = 0xBC;\r\nb10_a6[0] = 0x25;\r\nb10_a6[1] = 0xA0;\r\nb10_a6[2] = 0x36;\r\nb10_a6[3] = 0x8D;\r\nb10_a6[4] = 0x2E;\r\nb10_a6[5] = 0x94;\r\nb10_a6[6] = 0x28;\r\nb10_a6[7] = 0x9B;\r\nb10_a6[8] = 0x32;\r\nb10_a6[9] = 0x90;\r\nb10_a6[10] = 0x2C;\r\nb10_a6[11] = 0x9D;\r\nb10_a6[12] = 0x29;\r\nb10_a6[13] = 0x99;\r\niffreq = MAKE_IFFREQ_CONFIG(3.5);\r\nb10_d7 = 0x03;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\ncxd2841er_write_reg(priv, I2C_SLVX, 0x00, 0x20);\r\ncxd2841er_write_regs(priv, I2C_SLVT, 0x9f, b20_9f, sizeof(b20_9f));\r\ncxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x27);\r\ncxd2841er_set_reg_bits(\r\npriv, I2C_SLVT, 0x7a,\r\n(bandwidth == 1712000 ? 0x03 : 0x00), 0x0f);\r\ncxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x10);\r\ncxd2841er_write_regs(priv, I2C_SLVT, 0xa6, b10_a6, sizeof(b10_a6));\r\nb10_b6[0] = (u8) ((iffreq >> 16) & 0xff);\r\nb10_b6[1] = (u8)((iffreq >> 8) & 0xff);\r\nb10_b6[2] = (u8)(iffreq & 0xff);\r\ncxd2841er_write_regs(priv, I2C_SLVT, 0xb6, b10_b6, sizeof(b10_b6));\r\ncxd2841er_set_reg_bits(priv, I2C_SLVT, 0xd7, b10_d7, 0x07);\r\nreturn 0;\r\n}\r\nstatic int cxd2841er_sleep_tc_to_active_t_band(\r\nstruct cxd2841er_priv *priv, u32 bandwidth)\r\n{\r\nu8 b13_9c[2] = { 0x01, 0x14 };\r\nu8 bw8mhz_b10_9f[] = { 0x11, 0xF0, 0x00, 0x00, 0x00 };\r\nu8 bw8mhz_b10_a6[] = { 0x26, 0xAF, 0x06, 0xCD, 0x13, 0xBB,\r\n0x28, 0xBA, 0x23, 0xA9, 0x1F, 0xA8, 0x2C, 0xC8 };\r\nu8 bw8mhz_b10_d9[] = { 0x01, 0xE0 };\r\nu8 bw8mhz_b17_38[] = { 0x01, 0x02 };\r\nu8 bw7mhz_b10_9f[] = { 0x14, 0x80, 0x00, 0x00, 0x00 };\r\nu8 bw7mhz_b10_a6[] = { 0x2C, 0xBD, 0x02, 0xCF, 0x04, 0xF8,\r\n0x23, 0xA6, 0x29, 0xB0, 0x26, 0xA9, 0x21, 0xA5 };\r\nu8 bw7mhz_b10_d9[] = { 0x12, 0xF8 };\r\nu8 bw7mhz_b17_38[] = { 0x00, 0x03 };\r\nu8 bw6mhz_b10_9f[] = { 0x17, 0xEA, 0xAA, 0xAA, 0xAA };\r\nu8 bw6mhz_b10_a6[] = { 0x27, 0xA7, 0x28, 0xB3, 0x02, 0xF0,\r\n0x01, 0xE8, 0x00, 0xCF, 0x00, 0xE6, 0x23, 0xA4 };\r\nu8 bw6mhz_b10_d9[] = { 0x1F, 0xDC };\r\nu8 bw6mhz_b17_38[] = { 0x00, 0x03 };\r\nu8 bw5mhz_b10_9f[] = { 0x1C, 0xB3, 0x33, 0x33, 0x33 };\r\nu8 bw5mhz_b10_a6[] = { 0x27, 0xA7, 0x28, 0xB3, 0x02, 0xF0,\r\n0x01, 0xE8, 0x00, 0xCF, 0x00, 0xE6, 0x23, 0xA4 };\r\nu8 bw5mhz_b10_d9[] = { 0x26, 0x3C };\r\nu8 bw5mhz_b17_38[] = { 0x00, 0x03 };\r\nu8 b10_b6[3];\r\nu8 d7val;\r\nu32 iffreq;\r\nu8 *b10_9f;\r\nu8 *b10_a6;\r\nu8 *b10_d9;\r\nu8 *b17_38;\r\ndev_dbg(&priv->i2c->dev, "%s()\n", __func__);\r\ncxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x13);\r\ncxd2841er_write_regs(priv, I2C_SLVT, 0x9c, b13_9c, sizeof(b13_9c));\r\ncxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x10);\r\nswitch (bandwidth) {\r\ncase 8000000:\r\nb10_9f = bw8mhz_b10_9f;\r\nb10_a6 = bw8mhz_b10_a6;\r\nb10_d9 = bw8mhz_b10_d9;\r\nb17_38 = bw8mhz_b17_38;\r\nd7val = 0;\r\niffreq = MAKE_IFFREQ_CONFIG(4.80);\r\nbreak;\r\ncase 7000000:\r\nb10_9f = bw7mhz_b10_9f;\r\nb10_a6 = bw7mhz_b10_a6;\r\nb10_d9 = bw7mhz_b10_d9;\r\nb17_38 = bw7mhz_b17_38;\r\nd7val = 2;\r\niffreq = MAKE_IFFREQ_CONFIG(4.20);\r\nbreak;\r\ncase 6000000:\r\nb10_9f = bw6mhz_b10_9f;\r\nb10_a6 = bw6mhz_b10_a6;\r\nb10_d9 = bw6mhz_b10_d9;\r\nb17_38 = bw6mhz_b17_38;\r\nd7val = 4;\r\niffreq = MAKE_IFFREQ_CONFIG(3.60);\r\nbreak;\r\ncase 5000000:\r\nb10_9f = bw5mhz_b10_9f;\r\nb10_a6 = bw5mhz_b10_a6;\r\nb10_d9 = bw5mhz_b10_d9;\r\nb17_38 = bw5mhz_b17_38;\r\nd7val = 6;\r\niffreq = MAKE_IFFREQ_CONFIG(3.60);\r\nbreak;\r\ndefault:\r\ndev_dbg(&priv->i2c->dev, "%s(): invalid bandwidth %d\n",\r\n__func__, bandwidth);\r\nreturn -EINVAL;\r\n}\r\nb10_b6[0] = (u8) ((iffreq >> 16) & 0xff);\r\nb10_b6[1] = (u8)((iffreq >> 8) & 0xff);\r\nb10_b6[2] = (u8)(iffreq & 0xff);\r\ncxd2841er_write_regs(\r\npriv, I2C_SLVT, 0x9f, b10_9f, sizeof(bw8mhz_b10_9f));\r\ncxd2841er_write_regs(\r\npriv, I2C_SLVT, 0xa6, b10_a6, sizeof(bw8mhz_b10_a6));\r\ncxd2841er_write_regs(priv, I2C_SLVT, 0xb6, b10_b6, sizeof(b10_b6));\r\ncxd2841er_set_reg_bits(priv, I2C_SLVT, 0xd7, d7val, 0x7);\r\ncxd2841er_write_regs(\r\npriv, I2C_SLVT, 0xd9, b10_d9, sizeof(bw8mhz_b10_d9));\r\ncxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x17);\r\ncxd2841er_write_regs(\r\npriv, I2C_SLVT, 0x38, b17_38, sizeof(bw8mhz_b17_38));\r\nreturn 0;\r\n}\r\nstatic int cxd2841er_sleep_tc_to_active_c_band(struct cxd2841er_priv *priv,\r\nu32 bandwidth)\r\n{\r\nu8 bw7_8mhz_b10_a6[] = {\r\n0x2D, 0xC7, 0x04, 0xF4, 0x07, 0xC5, 0x2A, 0xB8,\r\n0x27, 0x9E, 0x27, 0xA4, 0x29, 0xAB };\r\nu8 bw6mhz_b10_a6[] = {\r\n0x27, 0xA7, 0x28, 0xB3, 0x02, 0xF0, 0x01, 0xE8,\r\n0x00, 0xCF, 0x00, 0xE6, 0x23, 0xA4 };\r\nu8 b10_b6[3];\r\nu32 iffreq;\r\ndev_dbg(&priv->i2c->dev, "%s()\n", __func__);\r\ncxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x10);\r\nswitch (bandwidth) {\r\ncase 8000000:\r\ncase 7000000:\r\ncxd2841er_write_regs(\r\npriv, I2C_SLVT, 0xa6,\r\nbw7_8mhz_b10_a6, sizeof(bw7_8mhz_b10_a6));\r\niffreq = MAKE_IFFREQ_CONFIG(4.9);\r\nbreak;\r\ncase 6000000:\r\ncxd2841er_write_regs(\r\npriv, I2C_SLVT, 0xa6,\r\nbw6mhz_b10_a6, sizeof(bw6mhz_b10_a6));\r\niffreq = MAKE_IFFREQ_CONFIG(3.7);\r\nbreak;\r\ndefault:\r\ndev_dbg(&priv->i2c->dev, "%s(): unsupported bandwidth %d\n",\r\n__func__, bandwidth);\r\nreturn -EINVAL;\r\n}\r\nb10_b6[0] = (u8) ((iffreq >> 16) & 0xff);\r\nb10_b6[1] = (u8)((iffreq >> 8) & 0xff);\r\nb10_b6[2] = (u8)(iffreq & 0xff);\r\ncxd2841er_write_regs(priv, I2C_SLVT, 0xb6, b10_b6, sizeof(b10_b6));\r\ncxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x11);\r\nswitch (bandwidth) {\r\ncase 8000000:\r\ncase 7000000:\r\ncxd2841er_set_reg_bits(\r\npriv, I2C_SLVT, 0xa3, 0x00, 0x1f);\r\nbreak;\r\ncase 6000000:\r\ncxd2841er_set_reg_bits(\r\npriv, I2C_SLVT, 0xa3, 0x14, 0x1f);\r\nbreak;\r\n}\r\ncxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x40);\r\nswitch (bandwidth) {\r\ncase 8000000:\r\ncxd2841er_set_reg_bits(\r\npriv, I2C_SLVT, 0x26, 0x0b, 0x0f);\r\ncxd2841er_write_reg(priv, I2C_SLVT, 0x27, 0x3e);\r\nbreak;\r\ncase 7000000:\r\ncxd2841er_set_reg_bits(\r\npriv, I2C_SLVT, 0x26, 0x09, 0x0f);\r\ncxd2841er_write_reg(priv, I2C_SLVT, 0x27, 0xd6);\r\nbreak;\r\ncase 6000000:\r\ncxd2841er_set_reg_bits(\r\npriv, I2C_SLVT, 0x26, 0x08, 0x0f);\r\ncxd2841er_write_reg(priv, I2C_SLVT, 0x27, 0x6e);\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic int cxd2841er_sleep_tc_to_active_t(struct cxd2841er_priv *priv,\r\nu32 bandwidth)\r\n{\r\nu8 data[2] = { 0x09, 0x54 };\r\ndev_dbg(&priv->i2c->dev, "%s()\n", __func__);\r\ncxd2841er_set_ts_clock_mode(priv, SYS_DVBT);\r\ncxd2841er_write_reg(priv, I2C_SLVX, 0x00, 0x00);\r\ncxd2841er_write_reg(priv, I2C_SLVX, 0x17, 0x01);\r\ncxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x00);\r\ncxd2841er_write_reg(priv, I2C_SLVT, 0x2c, 0x01);\r\ncxd2841er_write_reg(priv, I2C_SLVT, 0x2f, 0x00);\r\ncxd2841er_write_reg(priv, I2C_SLVT, 0x30, 0x00);\r\ncxd2841er_write_reg(priv, I2C_SLVT, 0x41, 0x1a);\r\ncxd2841er_write_regs(priv, I2C_SLVT, 0x43, data, 2);\r\ncxd2841er_write_reg(priv, I2C_SLVX, 0x18, 0x00);\r\ncxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x10);\r\ncxd2841er_set_reg_bits(priv, I2C_SLVT, 0xd2, 0x0c, 0x1f);\r\ncxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x11);\r\ncxd2841er_write_reg(priv, I2C_SLVT, 0x6a, 0x50);\r\ncxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x10);\r\ncxd2841er_set_reg_bits(priv, I2C_SLVT, 0xa5, 0x01, 0x01);\r\ncxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x18);\r\ncxd2841er_set_reg_bits(priv, I2C_SLVT, 0x36, 0x40, 0x07);\r\ncxd2841er_set_reg_bits(priv, I2C_SLVT, 0x30, 0x01, 0x01);\r\ncxd2841er_set_reg_bits(priv, I2C_SLVT, 0x31, 0x01, 0x01);\r\ncxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x00);\r\ncxd2841er_set_reg_bits(priv, I2C_SLVT, 0xce, 0x01, 0x01);\r\ncxd2841er_set_reg_bits(priv, I2C_SLVT, 0xcf, 0x01, 0x01);\r\ncxd2841er_sleep_tc_to_active_t_band(priv, bandwidth);\r\ncxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x00);\r\ncxd2841er_write_reg(priv, I2C_SLVT, 0x80, 0x28);\r\ncxd2841er_write_reg(priv, I2C_SLVT, 0x81, 0x00);\r\npriv->state = STATE_ACTIVE_TC;\r\nreturn 0;\r\n}\r\nstatic int cxd2841er_sleep_tc_to_active_t2(struct cxd2841er_priv *priv,\r\nu32 bandwidth)\r\n{\r\nu8 data[2] = { 0x09, 0x54 };\r\ndev_dbg(&priv->i2c->dev, "%s()\n", __func__);\r\ncxd2841er_set_ts_clock_mode(priv, SYS_DVBT2);\r\ncxd2841er_write_reg(priv, I2C_SLVX, 0x00, 0x00);\r\ncxd2841er_write_reg(priv, I2C_SLVX, 0x17, 0x02);\r\ncxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x00);\r\ncxd2841er_write_reg(priv, I2C_SLVT, 0x2c, 0x01);\r\ncxd2841er_write_reg(priv, I2C_SLVT, 0x2f, 0x00);\r\ncxd2841er_write_reg(priv, I2C_SLVT, 0x30, 0x00);\r\ncxd2841er_write_reg(priv, I2C_SLVT, 0x41, 0x1a);\r\ncxd2841er_write_regs(priv, I2C_SLVT, 0x43, data, 2);\r\ncxd2841er_write_reg(priv, I2C_SLVX, 0x18, 0x00);\r\ncxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x10);\r\ncxd2841er_set_reg_bits(priv, I2C_SLVT, 0xd2, 0x0c, 0x1f);\r\ncxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x11);\r\ncxd2841er_write_reg(priv, I2C_SLVT, 0x6a, 0x50);\r\ncxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x10);\r\ncxd2841er_set_reg_bits(priv, I2C_SLVT, 0xa5, 0x01, 0x01);\r\ncxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x20);\r\ncxd2841er_write_reg(priv, I2C_SLVT, 0x8b, 0x3c);\r\ncxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x2b);\r\ncxd2841er_set_reg_bits(priv, I2C_SLVT, 0x76, 0x20, 0x70);\r\ncxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x00);\r\ncxd2841er_set_reg_bits(priv, I2C_SLVT, 0xce, 0x01, 0x01);\r\ncxd2841er_set_reg_bits(priv, I2C_SLVT, 0xcf, 0x01, 0x01);\r\ncxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x13);\r\ncxd2841er_write_reg(priv, I2C_SLVT, 0x83, 0x10);\r\ncxd2841er_write_reg(priv, I2C_SLVT, 0x86, 0x34);\r\ncxd2841er_set_reg_bits(priv, I2C_SLVT, 0x9e, 0x09, 0x0f);\r\ncxd2841er_write_reg(priv, I2C_SLVT, 0x9f, 0xd8);\r\ncxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x2a);\r\ncxd2841er_set_reg_bits(priv, I2C_SLVT, 0x38, 0x04, 0x0f);\r\ncxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x2b);\r\ncxd2841er_set_reg_bits(priv, I2C_SLVT, 0x11, 0x20, 0x3f);\r\ncxd2841er_sleep_tc_to_active_t2_band(priv, bandwidth);\r\ncxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x00);\r\ncxd2841er_write_reg(priv, I2C_SLVT, 0x80, 0x28);\r\ncxd2841er_write_reg(priv, I2C_SLVT, 0x81, 0x00);\r\npriv->state = STATE_ACTIVE_TC;\r\nreturn 0;\r\n}\r\nstatic int cxd2841er_sleep_tc_to_active_c(struct cxd2841er_priv *priv,\r\nu32 bandwidth)\r\n{\r\nu8 data[2] = { 0x09, 0x54 };\r\ndev_dbg(&priv->i2c->dev, "%s()\n", __func__);\r\ncxd2841er_set_ts_clock_mode(priv, SYS_DVBC_ANNEX_A);\r\ncxd2841er_write_reg(priv, I2C_SLVX, 0x00, 0x00);\r\ncxd2841er_write_reg(priv, I2C_SLVX, 0x17, 0x04);\r\ncxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x00);\r\ncxd2841er_write_reg(priv, I2C_SLVT, 0x2c, 0x01);\r\ncxd2841er_write_reg(priv, I2C_SLVT, 0x2f, 0x00);\r\ncxd2841er_write_reg(priv, I2C_SLVT, 0x30, 0x00);\r\ncxd2841er_write_reg(priv, I2C_SLVT, 0x41, 0x1a);\r\ncxd2841er_write_regs(priv, I2C_SLVT, 0x43, data, 2);\r\ncxd2841er_write_reg(priv, I2C_SLVX, 0x18, 0x00);\r\ncxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x10);\r\ncxd2841er_set_reg_bits(priv, I2C_SLVT, 0xd2, 0x09, 0x1f);\r\ncxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x11);\r\ncxd2841er_write_reg(priv, I2C_SLVT, 0x6a, 0x48);\r\ncxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x10);\r\ncxd2841er_set_reg_bits(priv, I2C_SLVT, 0xa5, 0x01, 0x01);\r\ncxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x40);\r\ncxd2841er_set_reg_bits(priv, I2C_SLVT, 0xc3, 0x00, 0x04);\r\ncxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x00);\r\ncxd2841er_set_reg_bits(priv, I2C_SLVT, 0xce, 0x01, 0x01);\r\ncxd2841er_set_reg_bits(priv, I2C_SLVT, 0xcf, 0x01, 0x01);\r\ncxd2841er_sleep_tc_to_active_c_band(priv, 8000000);\r\ncxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x00);\r\ncxd2841er_write_reg(priv, I2C_SLVT, 0x80, 0x28);\r\ncxd2841er_write_reg(priv, I2C_SLVT, 0x81, 0x00);\r\npriv->state = STATE_ACTIVE_TC;\r\nreturn 0;\r\n}\r\nstatic int cxd2841er_get_frontend(struct dvb_frontend *fe,\r\nstruct dtv_frontend_properties *p)\r\n{\r\nenum fe_status status = 0;\r\nu16 strength = 0, snr = 0;\r\nu32 errors = 0, ber = 0;\r\nstruct cxd2841er_priv *priv = fe->demodulator_priv;\r\ndev_dbg(&priv->i2c->dev, "%s()\n", __func__);\r\nif (priv->state == STATE_ACTIVE_S)\r\ncxd2841er_read_status_s(fe, &status);\r\nelse if (priv->state == STATE_ACTIVE_TC)\r\ncxd2841er_read_status_tc(fe, &status);\r\nif (status & FE_HAS_LOCK) {\r\ncxd2841er_read_signal_strength(fe, &strength);\r\np->strength.len = 1;\r\np->strength.stat[0].scale = FE_SCALE_RELATIVE;\r\np->strength.stat[0].uvalue = strength;\r\ncxd2841er_read_snr(fe, &snr);\r\np->cnr.len = 1;\r\np->cnr.stat[0].scale = FE_SCALE_DECIBEL;\r\np->cnr.stat[0].svalue = snr;\r\ncxd2841er_read_ucblocks(fe, &errors);\r\np->block_error.len = 1;\r\np->block_error.stat[0].scale = FE_SCALE_COUNTER;\r\np->block_error.stat[0].uvalue = errors;\r\ncxd2841er_read_ber(fe, &ber);\r\np->post_bit_error.len = 1;\r\np->post_bit_error.stat[0].scale = FE_SCALE_COUNTER;\r\np->post_bit_error.stat[0].uvalue = ber;\r\n} else {\r\np->strength.len = 1;\r\np->strength.stat[0].scale = FE_SCALE_NOT_AVAILABLE;\r\np->cnr.len = 1;\r\np->cnr.stat[0].scale = FE_SCALE_NOT_AVAILABLE;\r\np->block_error.len = 1;\r\np->block_error.stat[0].scale = FE_SCALE_NOT_AVAILABLE;\r\np->post_bit_error.len = 1;\r\np->post_bit_error.stat[0].scale = FE_SCALE_NOT_AVAILABLE;\r\n}\r\nreturn 0;\r\n}\r\nstatic int cxd2841er_set_frontend_s(struct dvb_frontend *fe)\r\n{\r\nint ret = 0, i, timeout, carr_offset;\r\nenum fe_status status;\r\nstruct cxd2841er_priv *priv = fe->demodulator_priv;\r\nstruct dtv_frontend_properties *p = &fe->dtv_property_cache;\r\nu32 symbol_rate = p->symbol_rate/1000;\r\ndev_dbg(&priv->i2c->dev, "%s(): %s frequency=%d symbol_rate=%d\n",\r\n__func__,\r\n(p->delivery_system == SYS_DVBS ? "DVB-S" : "DVB-S2"),\r\np->frequency, symbol_rate);\r\nswitch (priv->state) {\r\ncase STATE_SLEEP_S:\r\nret = cxd2841er_sleep_s_to_active_s(\r\npriv, p->delivery_system, symbol_rate);\r\nbreak;\r\ncase STATE_ACTIVE_S:\r\nret = cxd2841er_retune_active(priv, p);\r\nbreak;\r\ndefault:\r\ndev_dbg(&priv->i2c->dev, "%s(): invalid state %d\n",\r\n__func__, priv->state);\r\nret = -EINVAL;\r\ngoto done;\r\n}\r\nif (ret) {\r\ndev_dbg(&priv->i2c->dev, "%s(): tune failed\n", __func__);\r\ngoto done;\r\n}\r\nif (fe->ops.i2c_gate_ctrl)\r\nfe->ops.i2c_gate_ctrl(fe, 1);\r\nif (fe->ops.tuner_ops.set_params)\r\nfe->ops.tuner_ops.set_params(fe);\r\nif (fe->ops.i2c_gate_ctrl)\r\nfe->ops.i2c_gate_ctrl(fe, 0);\r\ncxd2841er_tune_done(priv);\r\ntimeout = ((3000000 + (symbol_rate - 1)) / symbol_rate) + 150;\r\nfor (i = 0; i < timeout / CXD2841ER_DVBS_POLLING_INVL; i++) {\r\nusleep_range(CXD2841ER_DVBS_POLLING_INVL*1000,\r\n(CXD2841ER_DVBS_POLLING_INVL + 2) * 1000);\r\ncxd2841er_read_status_s(fe, &status);\r\nif (status & FE_HAS_LOCK)\r\nbreak;\r\n}\r\nif (status & FE_HAS_LOCK) {\r\nif (cxd2841er_get_carrier_offset_s_s2(\r\npriv, &carr_offset)) {\r\nret = -EINVAL;\r\ngoto done;\r\n}\r\ndev_dbg(&priv->i2c->dev, "%s(): carrier_offset=%d\n",\r\n__func__, carr_offset);\r\n}\r\ndone:\r\nreturn ret;\r\n}\r\nstatic int cxd2841er_set_frontend_tc(struct dvb_frontend *fe)\r\n{\r\nint ret = 0, timeout;\r\nenum fe_status status;\r\nstruct cxd2841er_priv *priv = fe->demodulator_priv;\r\nstruct dtv_frontend_properties *p = &fe->dtv_property_cache;\r\ndev_dbg(&priv->i2c->dev, "%s()\n", __func__);\r\nif (p->delivery_system == SYS_DVBT) {\r\npriv->system = SYS_DVBT;\r\nswitch (priv->state) {\r\ncase STATE_SLEEP_TC:\r\nret = cxd2841er_sleep_tc_to_active_t(\r\npriv, p->bandwidth_hz);\r\nbreak;\r\ncase STATE_ACTIVE_TC:\r\nret = cxd2841er_retune_active(priv, p);\r\nbreak;\r\ndefault:\r\ndev_dbg(&priv->i2c->dev, "%s(): invalid state %d\n",\r\n__func__, priv->state);\r\nret = -EINVAL;\r\n}\r\n} else if (p->delivery_system == SYS_DVBT2) {\r\npriv->system = SYS_DVBT2;\r\ncxd2841er_dvbt2_set_plp_config(priv,\r\n(int)(p->stream_id > 255), p->stream_id);\r\ncxd2841er_dvbt2_set_profile(priv, DVBT2_PROFILE_BASE);\r\nswitch (priv->state) {\r\ncase STATE_SLEEP_TC:\r\nret = cxd2841er_sleep_tc_to_active_t2(priv,\r\np->bandwidth_hz);\r\nbreak;\r\ncase STATE_ACTIVE_TC:\r\nret = cxd2841er_retune_active(priv, p);\r\nbreak;\r\ndefault:\r\ndev_dbg(&priv->i2c->dev, "%s(): invalid state %d\n",\r\n__func__, priv->state);\r\nret = -EINVAL;\r\n}\r\n} else if (p->delivery_system == SYS_DVBC_ANNEX_A ||\r\np->delivery_system == SYS_DVBC_ANNEX_C) {\r\npriv->system = SYS_DVBC_ANNEX_A;\r\nswitch (priv->state) {\r\ncase STATE_SLEEP_TC:\r\nret = cxd2841er_sleep_tc_to_active_c(\r\npriv, p->bandwidth_hz);\r\nbreak;\r\ncase STATE_ACTIVE_TC:\r\nret = cxd2841er_retune_active(priv, p);\r\nbreak;\r\ndefault:\r\ndev_dbg(&priv->i2c->dev, "%s(): invalid state %d\n",\r\n__func__, priv->state);\r\nret = -EINVAL;\r\n}\r\n} else {\r\ndev_dbg(&priv->i2c->dev,\r\n"%s(): invalid delivery system %d\n",\r\n__func__, p->delivery_system);\r\nret = -EINVAL;\r\n}\r\nif (ret)\r\ngoto done;\r\nif (fe->ops.i2c_gate_ctrl)\r\nfe->ops.i2c_gate_ctrl(fe, 1);\r\nif (fe->ops.tuner_ops.set_params)\r\nfe->ops.tuner_ops.set_params(fe);\r\nif (fe->ops.i2c_gate_ctrl)\r\nfe->ops.i2c_gate_ctrl(fe, 0);\r\ncxd2841er_tune_done(priv);\r\ntimeout = 2500;\r\nwhile (timeout > 0) {\r\nret = cxd2841er_read_status_tc(fe, &status);\r\nif (ret)\r\ngoto done;\r\nif (status & FE_HAS_LOCK)\r\nbreak;\r\nmsleep(20);\r\ntimeout -= 20;\r\n}\r\nif (timeout < 0)\r\ndev_dbg(&priv->i2c->dev,\r\n"%s(): LOCK wait timeout\n", __func__);\r\ndone:\r\nreturn ret;\r\n}\r\nstatic int cxd2841er_tune_s(struct dvb_frontend *fe,\r\nbool re_tune,\r\nunsigned int mode_flags,\r\nunsigned int *delay,\r\nenum fe_status *status)\r\n{\r\nint ret, carrier_offset;\r\nstruct cxd2841er_priv *priv = fe->demodulator_priv;\r\nstruct dtv_frontend_properties *p = &fe->dtv_property_cache;\r\ndev_dbg(&priv->i2c->dev, "%s() re_tune=%d\n", __func__, re_tune);\r\nif (re_tune) {\r\nret = cxd2841er_set_frontend_s(fe);\r\nif (ret)\r\nreturn ret;\r\ncxd2841er_read_status_s(fe, status);\r\nif (*status & FE_HAS_LOCK) {\r\nif (cxd2841er_get_carrier_offset_s_s2(\r\npriv, &carrier_offset))\r\nreturn -EINVAL;\r\np->frequency += carrier_offset;\r\nret = cxd2841er_set_frontend_s(fe);\r\nif (ret)\r\nreturn ret;\r\n}\r\n}\r\n*delay = HZ / 5;\r\nreturn cxd2841er_read_status_s(fe, status);\r\n}\r\nstatic int cxd2841er_tune_tc(struct dvb_frontend *fe,\r\nbool re_tune,\r\nunsigned int mode_flags,\r\nunsigned int *delay,\r\nenum fe_status *status)\r\n{\r\nint ret, carrier_offset;\r\nstruct cxd2841er_priv *priv = fe->demodulator_priv;\r\nstruct dtv_frontend_properties *p = &fe->dtv_property_cache;\r\ndev_dbg(&priv->i2c->dev, "%s(): re_tune %d\n", __func__, re_tune);\r\nif (re_tune) {\r\nret = cxd2841er_set_frontend_tc(fe);\r\nif (ret)\r\nreturn ret;\r\ncxd2841er_read_status_tc(fe, status);\r\nif (*status & FE_HAS_LOCK) {\r\nswitch (priv->system) {\r\ncase SYS_DVBT:\r\ncase SYS_DVBT2:\r\nret = cxd2841er_get_carrier_offset_t2(\r\npriv, p->bandwidth_hz,\r\n&carrier_offset);\r\nbreak;\r\ncase SYS_DVBC_ANNEX_A:\r\nret = cxd2841er_get_carrier_offset_c(\r\npriv, &carrier_offset);\r\nbreak;\r\ndefault:\r\ndev_dbg(&priv->i2c->dev,\r\n"%s(): invalid delivery system %d\n",\r\n__func__, priv->system);\r\nreturn -EINVAL;\r\n}\r\nif (ret)\r\nreturn ret;\r\ndev_dbg(&priv->i2c->dev, "%s(): carrier offset %d\n",\r\n__func__, carrier_offset);\r\np->frequency += carrier_offset;\r\nret = cxd2841er_set_frontend_tc(fe);\r\nif (ret)\r\nreturn ret;\r\n}\r\n}\r\n*delay = HZ / 5;\r\nreturn cxd2841er_read_status_tc(fe, status);\r\n}\r\nstatic int cxd2841er_sleep_s(struct dvb_frontend *fe)\r\n{\r\nstruct cxd2841er_priv *priv = fe->demodulator_priv;\r\ndev_dbg(&priv->i2c->dev, "%s()\n", __func__);\r\ncxd2841er_active_s_to_sleep_s(fe->demodulator_priv);\r\ncxd2841er_sleep_s_to_shutdown(fe->demodulator_priv);\r\nreturn 0;\r\n}\r\nstatic int cxd2841er_sleep_tc(struct dvb_frontend *fe)\r\n{\r\nstruct cxd2841er_priv *priv = fe->demodulator_priv;\r\ndev_dbg(&priv->i2c->dev, "%s()\n", __func__);\r\nif (priv->state == STATE_ACTIVE_TC) {\r\nswitch (priv->system) {\r\ncase SYS_DVBT:\r\ncxd2841er_active_t_to_sleep_tc(priv);\r\nbreak;\r\ncase SYS_DVBT2:\r\ncxd2841er_active_t2_to_sleep_tc(priv);\r\nbreak;\r\ncase SYS_DVBC_ANNEX_A:\r\ncxd2841er_active_c_to_sleep_tc(priv);\r\nbreak;\r\ndefault:\r\ndev_warn(&priv->i2c->dev,\r\n"%s(): unknown delivery system %d\n",\r\n__func__, priv->system);\r\n}\r\n}\r\nif (priv->state != STATE_SLEEP_TC) {\r\ndev_err(&priv->i2c->dev, "%s(): invalid state %d\n",\r\n__func__, priv->state);\r\nreturn -EINVAL;\r\n}\r\ncxd2841er_sleep_tc_to_shutdown(priv);\r\nreturn 0;\r\n}\r\nstatic int cxd2841er_send_burst(struct dvb_frontend *fe,\r\nenum fe_sec_mini_cmd burst)\r\n{\r\nu8 data;\r\nstruct cxd2841er_priv *priv = fe->demodulator_priv;\r\ndev_dbg(&priv->i2c->dev, "%s(): burst mode %s\n", __func__,\r\n(burst == SEC_MINI_A ? "A" : "B"));\r\nif (priv->state != STATE_SLEEP_S &&\r\npriv->state != STATE_ACTIVE_S) {\r\ndev_err(&priv->i2c->dev, "%s(): invalid demod state %d\n",\r\n__func__, priv->state);\r\nreturn -EINVAL;\r\n}\r\ndata = (burst == SEC_MINI_A ? 0 : 1);\r\ncxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0xbb);\r\ncxd2841er_write_reg(priv, I2C_SLVT, 0x34, 0x01);\r\ncxd2841er_write_reg(priv, I2C_SLVT, 0x35, data);\r\nreturn 0;\r\n}\r\nstatic int cxd2841er_set_tone(struct dvb_frontend *fe,\r\nenum fe_sec_tone_mode tone)\r\n{\r\nu8 data;\r\nstruct cxd2841er_priv *priv = fe->demodulator_priv;\r\ndev_dbg(&priv->i2c->dev, "%s(): tone %s\n", __func__,\r\n(tone == SEC_TONE_ON ? "On" : "Off"));\r\nif (priv->state != STATE_SLEEP_S &&\r\npriv->state != STATE_ACTIVE_S) {\r\ndev_err(&priv->i2c->dev, "%s(): invalid demod state %d\n",\r\n__func__, priv->state);\r\nreturn -EINVAL;\r\n}\r\ndata = (tone == SEC_TONE_ON ? 1 : 0);\r\ncxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0xbb);\r\ncxd2841er_write_reg(priv, I2C_SLVT, 0x36, data);\r\nreturn 0;\r\n}\r\nstatic int cxd2841er_send_diseqc_msg(struct dvb_frontend *fe,\r\nstruct dvb_diseqc_master_cmd *cmd)\r\n{\r\nint i;\r\nu8 data[12];\r\nstruct cxd2841er_priv *priv = fe->demodulator_priv;\r\nif (priv->state != STATE_SLEEP_S &&\r\npriv->state != STATE_ACTIVE_S) {\r\ndev_err(&priv->i2c->dev, "%s(): invalid demod state %d\n",\r\n__func__, priv->state);\r\nreturn -EINVAL;\r\n}\r\ndev_dbg(&priv->i2c->dev,\r\n"%s(): cmd->len %d\n", __func__, cmd->msg_len);\r\ncxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0xbb);\r\ncxd2841er_write_reg(priv, I2C_SLVT, 0x33, 0x01);\r\ncxd2841er_write_reg(priv, I2C_SLVT, 0x3d, cmd->msg_len);\r\nmemset(data, 0, sizeof(data));\r\nfor (i = 0; i < cmd->msg_len && i < sizeof(data); i++)\r\ndata[i] = cmd->msg[i];\r\ncxd2841er_write_regs(priv, I2C_SLVT, 0x3e, data, sizeof(data));\r\ncxd2841er_write_reg(priv, I2C_SLVT, 0x37, 1);\r\ncxd2841er_write_reg(priv, I2C_SLVT, 0x38, 0);\r\ncxd2841er_write_reg(priv, I2C_SLVT, 0x32, 0x01);\r\nfor (i = 0; i < 50; i++) {\r\ncxd2841er_read_reg(priv, I2C_SLVT, 0x10, data);\r\nif (!data[0]) {\r\ndev_dbg(&priv->i2c->dev,\r\n"%s(): DiSEqC cmd has been sent\n", __func__);\r\nreturn 0;\r\n}\r\nmsleep(20);\r\n}\r\ndev_dbg(&priv->i2c->dev,\r\n"%s(): DiSEqC cmd transmit timeout\n", __func__);\r\nreturn -ETIMEDOUT;\r\n}\r\nstatic void cxd2841er_release(struct dvb_frontend *fe)\r\n{\r\nstruct cxd2841er_priv *priv = fe->demodulator_priv;\r\ndev_dbg(&priv->i2c->dev, "%s()\n", __func__);\r\nkfree(priv);\r\n}\r\nstatic int cxd2841er_i2c_gate_ctrl(struct dvb_frontend *fe, int enable)\r\n{\r\nstruct cxd2841er_priv *priv = fe->demodulator_priv;\r\ndev_dbg(&priv->i2c->dev, "%s(): enable=%d\n", __func__, enable);\r\ncxd2841er_set_reg_bits(\r\npriv, I2C_SLVX, 0x8, (enable ? 0x01 : 0x00), 0x01);\r\nreturn 0;\r\n}\r\nstatic enum dvbfe_algo cxd2841er_get_algo(struct dvb_frontend *fe)\r\n{\r\nstruct cxd2841er_priv *priv = fe->demodulator_priv;\r\ndev_dbg(&priv->i2c->dev, "%s()\n", __func__);\r\nreturn DVBFE_ALGO_HW;\r\n}\r\nstatic int cxd2841er_init_s(struct dvb_frontend *fe)\r\n{\r\nstruct cxd2841er_priv *priv = fe->demodulator_priv;\r\ndev_dbg(&priv->i2c->dev, "%s()\n", __func__);\r\ncxd2841er_shutdown_to_sleep_s(priv);\r\ncxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0xa0);\r\ncxd2841er_set_reg_bits(priv, I2C_SLVT, 0xb9, 0x01, 0x01);\r\nreturn 0;\r\n}\r\nstatic int cxd2841er_init_tc(struct dvb_frontend *fe)\r\n{\r\nstruct cxd2841er_priv *priv = fe->demodulator_priv;\r\ndev_dbg(&priv->i2c->dev, "%s()\n", __func__);\r\ncxd2841er_shutdown_to_sleep_tc(priv);\r\ncxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x10);\r\ncxd2841er_set_reg_bits(priv, I2C_SLVT, 0xcb, 0x40, 0x40);\r\ncxd2841er_write_reg(priv, I2C_SLVT, 0xcd, 0x50);\r\ncxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x00);\r\ncxd2841er_set_reg_bits(priv, I2C_SLVT, 0xc4, 0x00, 0x80);\r\nreturn 0;\r\n}\r\nstatic struct dvb_frontend *cxd2841er_attach(struct cxd2841er_config *cfg,\r\nstruct i2c_adapter *i2c,\r\nu8 system)\r\n{\r\nu8 chip_id = 0;\r\nconst char *type;\r\nstruct cxd2841er_priv *priv = NULL;\r\npriv = kzalloc(sizeof(struct cxd2841er_priv), GFP_KERNEL);\r\nif (!priv)\r\nreturn NULL;\r\npriv->i2c = i2c;\r\npriv->config = cfg;\r\npriv->i2c_addr_slvx = (cfg->i2c_addr + 4) >> 1;\r\npriv->i2c_addr_slvt = (cfg->i2c_addr) >> 1;\r\nswitch (system) {\r\ncase SYS_DVBS:\r\nmemcpy(&priv->frontend.ops,\r\n&cxd2841er_dvbs_s2_ops,\r\nsizeof(struct dvb_frontend_ops));\r\ntype = "S/S2";\r\nbreak;\r\ncase SYS_DVBT:\r\nmemcpy(&priv->frontend.ops,\r\n&cxd2841er_dvbt_t2_ops,\r\nsizeof(struct dvb_frontend_ops));\r\ntype = "T/T2";\r\nbreak;\r\ncase SYS_DVBC_ANNEX_A:\r\nmemcpy(&priv->frontend.ops,\r\n&cxd2841er_dvbc_ops,\r\nsizeof(struct dvb_frontend_ops));\r\ntype = "C/C2";\r\nbreak;\r\ndefault:\r\nkfree(priv);\r\nreturn NULL;\r\n}\r\npriv->frontend.demodulator_priv = priv;\r\ndev_info(&priv->i2c->dev,\r\n"%s(): attaching CXD2841ER DVB-%s frontend\n",\r\n__func__, type);\r\ndev_info(&priv->i2c->dev,\r\n"%s(): I2C adapter %p SLVX addr %x SLVT addr %x\n",\r\n__func__, priv->i2c,\r\npriv->i2c_addr_slvx, priv->i2c_addr_slvt);\r\nchip_id = cxd2841er_chip_id(priv);\r\nif (chip_id != CXD2841ER_CHIP_ID) {\r\ndev_err(&priv->i2c->dev, "%s(): invalid chip ID 0x%02x\n",\r\n__func__, chip_id);\r\npriv->frontend.demodulator_priv = NULL;\r\nkfree(priv);\r\nreturn NULL;\r\n}\r\ndev_info(&priv->i2c->dev, "%s(): chip ID 0x%02x OK.\n",\r\n__func__, chip_id);\r\nreturn &priv->frontend;\r\n}\r\nstruct dvb_frontend *cxd2841er_attach_s(struct cxd2841er_config *cfg,\r\nstruct i2c_adapter *i2c)\r\n{\r\nreturn cxd2841er_attach(cfg, i2c, SYS_DVBS);\r\n}\r\nstruct dvb_frontend *cxd2841er_attach_t(struct cxd2841er_config *cfg,\r\nstruct i2c_adapter *i2c)\r\n{\r\nreturn cxd2841er_attach(cfg, i2c, SYS_DVBT);\r\n}\r\nstruct dvb_frontend *cxd2841er_attach_c(struct cxd2841er_config *cfg,\r\nstruct i2c_adapter *i2c)\r\n{\r\nreturn cxd2841er_attach(cfg, i2c, SYS_DVBC_ANNEX_A);\r\n}
