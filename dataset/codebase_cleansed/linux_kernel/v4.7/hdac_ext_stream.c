void snd_hdac_ext_stream_init(struct hdac_ext_bus *ebus,\r\nstruct hdac_ext_stream *stream,\r\nint idx, int direction, int tag)\r\n{\r\nstruct hdac_bus *bus = &ebus->bus;\r\nif (ebus->ppcap) {\r\nstream->pphc_addr = ebus->ppcap + AZX_PPHC_BASE +\r\nAZX_PPHC_INTERVAL * idx;\r\nstream->pplc_addr = ebus->ppcap + AZX_PPLC_BASE +\r\nAZX_PPLC_MULTI * ebus->num_streams +\r\nAZX_PPLC_INTERVAL * idx;\r\n}\r\nif (ebus->spbcap) {\r\nstream->spib_addr = ebus->spbcap + AZX_SPB_BASE +\r\nAZX_SPB_INTERVAL * idx +\r\nAZX_SPB_SPIB;\r\nstream->fifo_addr = ebus->spbcap + AZX_SPB_BASE +\r\nAZX_SPB_INTERVAL * idx +\r\nAZX_SPB_MAXFIFO;\r\n}\r\nif (ebus->drsmcap)\r\nstream->dpibr_addr = ebus->drsmcap + AZX_DRSM_BASE +\r\nAZX_DRSM_INTERVAL * idx;\r\nstream->decoupled = false;\r\nsnd_hdac_stream_init(bus, &stream->hstream, idx, direction, tag);\r\n}\r\nint snd_hdac_ext_stream_init_all(struct hdac_ext_bus *ebus, int start_idx,\r\nint num_stream, int dir)\r\n{\r\nint stream_tag = 0;\r\nint i, tag, idx = start_idx;\r\nfor (i = 0; i < num_stream; i++) {\r\nstruct hdac_ext_stream *stream =\r\nkzalloc(sizeof(*stream), GFP_KERNEL);\r\nif (!stream)\r\nreturn -ENOMEM;\r\ntag = ++stream_tag;\r\nsnd_hdac_ext_stream_init(ebus, stream, idx, dir, tag);\r\nidx++;\r\n}\r\nreturn 0;\r\n}\r\nvoid snd_hdac_stream_free_all(struct hdac_ext_bus *ebus)\r\n{\r\nstruct hdac_stream *s, *_s;\r\nstruct hdac_ext_stream *stream;\r\nstruct hdac_bus *bus = ebus_to_hbus(ebus);\r\nlist_for_each_entry_safe(s, _s, &bus->stream_list, list) {\r\nstream = stream_to_hdac_ext_stream(s);\r\nsnd_hdac_ext_stream_decouple(ebus, stream, false);\r\nlist_del(&s->list);\r\nkfree(stream);\r\n}\r\n}\r\nvoid snd_hdac_ext_stream_decouple(struct hdac_ext_bus *ebus,\r\nstruct hdac_ext_stream *stream, bool decouple)\r\n{\r\nstruct hdac_stream *hstream = &stream->hstream;\r\nstruct hdac_bus *bus = &ebus->bus;\r\nspin_lock_irq(&bus->reg_lock);\r\nif (decouple)\r\nsnd_hdac_updatel(ebus->ppcap, AZX_REG_PP_PPCTL, 0,\r\nAZX_PPCTL_PROCEN(hstream->index));\r\nelse\r\nsnd_hdac_updatel(ebus->ppcap, AZX_REG_PP_PPCTL,\r\nAZX_PPCTL_PROCEN(hstream->index), 0);\r\nstream->decoupled = decouple;\r\nspin_unlock_irq(&bus->reg_lock);\r\n}\r\nvoid snd_hdac_ext_link_stream_start(struct hdac_ext_stream *stream)\r\n{\r\nsnd_hdac_updatel(stream->pplc_addr, AZX_REG_PPLCCTL, 0, AZX_PPLCCTL_RUN);\r\n}\r\nvoid snd_hdac_ext_link_stream_clear(struct hdac_ext_stream *stream)\r\n{\r\nsnd_hdac_updatel(stream->pplc_addr, AZX_REG_PPLCCTL, AZX_PPLCCTL_RUN, 0);\r\n}\r\nvoid snd_hdac_ext_link_stream_reset(struct hdac_ext_stream *stream)\r\n{\r\nunsigned char val;\r\nint timeout;\r\nsnd_hdac_ext_link_stream_clear(stream);\r\nsnd_hdac_updatel(stream->pplc_addr, AZX_REG_PPLCCTL, 0, AZX_PPLCCTL_STRST);\r\nudelay(3);\r\ntimeout = 50;\r\ndo {\r\nval = readl(stream->pplc_addr + AZX_REG_PPLCCTL) &\r\nAZX_PPLCCTL_STRST;\r\nif (val)\r\nbreak;\r\nudelay(3);\r\n} while (--timeout);\r\nval &= ~AZX_PPLCCTL_STRST;\r\nwritel(val, stream->pplc_addr + AZX_REG_PPLCCTL);\r\nudelay(3);\r\ntimeout = 50;\r\ndo {\r\nval = readl(stream->pplc_addr + AZX_REG_PPLCCTL) & AZX_PPLCCTL_STRST;\r\nif (!val)\r\nbreak;\r\nudelay(3);\r\n} while (--timeout);\r\n}\r\nint snd_hdac_ext_link_stream_setup(struct hdac_ext_stream *stream, int fmt)\r\n{\r\nstruct hdac_stream *hstream = &stream->hstream;\r\nunsigned int val;\r\nsnd_hdac_ext_link_stream_clear(stream);\r\nval = readl(stream->pplc_addr + AZX_REG_PPLCCTL);\r\nval = (val & ~AZX_PPLCCTL_STRM_MASK) |\r\n(hstream->stream_tag << AZX_PPLCCTL_STRM_SHIFT);\r\nwritel(val, stream->pplc_addr + AZX_REG_PPLCCTL);\r\nwritew(fmt, stream->pplc_addr + AZX_REG_PPLCFMT);\r\nreturn 0;\r\n}\r\nvoid snd_hdac_ext_link_set_stream_id(struct hdac_ext_link *link,\r\nint stream)\r\n{\r\nsnd_hdac_updatew(link->ml_addr, AZX_REG_ML_LOSIDV, (1 << stream), 1 << stream);\r\n}\r\nvoid snd_hdac_ext_link_clear_stream_id(struct hdac_ext_link *link,\r\nint stream)\r\n{\r\nsnd_hdac_updatew(link->ml_addr, AZX_REG_ML_LOSIDV, 0, (1 << stream));\r\n}\r\nstatic struct hdac_ext_stream *\r\nhdac_ext_link_stream_assign(struct hdac_ext_bus *ebus,\r\nstruct snd_pcm_substream *substream)\r\n{\r\nstruct hdac_ext_stream *res = NULL;\r\nstruct hdac_stream *stream = NULL;\r\nstruct hdac_bus *hbus = &ebus->bus;\r\nif (!ebus->ppcap) {\r\ndev_err(hbus->dev, "stream type not supported\n");\r\nreturn NULL;\r\n}\r\nlist_for_each_entry(stream, &hbus->stream_list, list) {\r\nstruct hdac_ext_stream *hstream = container_of(stream,\r\nstruct hdac_ext_stream,\r\nhstream);\r\nif (stream->direction != substream->stream)\r\ncontinue;\r\nif (hstream->decoupled && !hstream->link_locked) {\r\nres = hstream;\r\nbreak;\r\n}\r\nif (!hstream->link_locked) {\r\nsnd_hdac_ext_stream_decouple(ebus, hstream, true);\r\nres = hstream;\r\nbreak;\r\n}\r\n}\r\nif (res) {\r\nspin_lock_irq(&hbus->reg_lock);\r\nres->link_locked = 1;\r\nres->link_substream = substream;\r\nspin_unlock_irq(&hbus->reg_lock);\r\n}\r\nreturn res;\r\n}\r\nstatic struct hdac_ext_stream *\r\nhdac_ext_host_stream_assign(struct hdac_ext_bus *ebus,\r\nstruct snd_pcm_substream *substream)\r\n{\r\nstruct hdac_ext_stream *res = NULL;\r\nstruct hdac_stream *stream = NULL;\r\nstruct hdac_bus *hbus = &ebus->bus;\r\nif (!ebus->ppcap) {\r\ndev_err(hbus->dev, "stream type not supported\n");\r\nreturn NULL;\r\n}\r\nlist_for_each_entry(stream, &hbus->stream_list, list) {\r\nstruct hdac_ext_stream *hstream = container_of(stream,\r\nstruct hdac_ext_stream,\r\nhstream);\r\nif (stream->direction != substream->stream)\r\ncontinue;\r\nif (!stream->opened) {\r\nif (!hstream->decoupled)\r\nsnd_hdac_ext_stream_decouple(ebus, hstream, true);\r\nres = hstream;\r\nbreak;\r\n}\r\n}\r\nif (res) {\r\nspin_lock_irq(&hbus->reg_lock);\r\nres->hstream.opened = 1;\r\nres->hstream.running = 0;\r\nres->hstream.substream = substream;\r\nspin_unlock_irq(&hbus->reg_lock);\r\n}\r\nreturn res;\r\n}\r\nstruct hdac_ext_stream *snd_hdac_ext_stream_assign(struct hdac_ext_bus *ebus,\r\nstruct snd_pcm_substream *substream,\r\nint type)\r\n{\r\nstruct hdac_ext_stream *hstream = NULL;\r\nstruct hdac_stream *stream = NULL;\r\nstruct hdac_bus *hbus = &ebus->bus;\r\nswitch (type) {\r\ncase HDAC_EXT_STREAM_TYPE_COUPLED:\r\nstream = snd_hdac_stream_assign(hbus, substream);\r\nif (stream)\r\nhstream = container_of(stream,\r\nstruct hdac_ext_stream, hstream);\r\nreturn hstream;\r\ncase HDAC_EXT_STREAM_TYPE_HOST:\r\nreturn hdac_ext_host_stream_assign(ebus, substream);\r\ncase HDAC_EXT_STREAM_TYPE_LINK:\r\nreturn hdac_ext_link_stream_assign(ebus, substream);\r\ndefault:\r\nreturn NULL;\r\n}\r\n}\r\nvoid snd_hdac_ext_stream_release(struct hdac_ext_stream *stream, int type)\r\n{\r\nstruct hdac_bus *bus = stream->hstream.bus;\r\nstruct hdac_ext_bus *ebus = hbus_to_ebus(bus);\r\nswitch (type) {\r\ncase HDAC_EXT_STREAM_TYPE_COUPLED:\r\nsnd_hdac_stream_release(&stream->hstream);\r\nbreak;\r\ncase HDAC_EXT_STREAM_TYPE_HOST:\r\nif (stream->decoupled && !stream->link_locked)\r\nsnd_hdac_ext_stream_decouple(ebus, stream, false);\r\nsnd_hdac_stream_release(&stream->hstream);\r\nbreak;\r\ncase HDAC_EXT_STREAM_TYPE_LINK:\r\nif (stream->decoupled && !stream->hstream.opened)\r\nsnd_hdac_ext_stream_decouple(ebus, stream, false);\r\nspin_lock_irq(&bus->reg_lock);\r\nstream->link_locked = 0;\r\nstream->link_substream = NULL;\r\nspin_unlock_irq(&bus->reg_lock);\r\nbreak;\r\ndefault:\r\ndev_dbg(bus->dev, "Invalid type %d\n", type);\r\n}\r\n}\r\nvoid snd_hdac_ext_stream_spbcap_enable(struct hdac_ext_bus *ebus,\r\nbool enable, int index)\r\n{\r\nu32 mask = 0;\r\nu32 register_mask = 0;\r\nstruct hdac_bus *bus = &ebus->bus;\r\nif (!ebus->spbcap) {\r\ndev_err(bus->dev, "Address of SPB capability is NULL");\r\nreturn;\r\n}\r\nmask |= (1 << index);\r\nregister_mask = readl(ebus->spbcap + AZX_REG_SPB_SPBFCCTL);\r\nmask |= register_mask;\r\nif (enable)\r\nsnd_hdac_updatel(ebus->spbcap, AZX_REG_SPB_SPBFCCTL, 0, mask);\r\nelse\r\nsnd_hdac_updatel(ebus->spbcap, AZX_REG_SPB_SPBFCCTL, mask, 0);\r\n}\r\nint snd_hdac_ext_stream_set_spib(struct hdac_ext_bus *ebus,\r\nstruct hdac_ext_stream *stream, u32 value)\r\n{\r\nstruct hdac_bus *bus = &ebus->bus;\r\nif (!ebus->spbcap) {\r\ndev_err(bus->dev, "Address of SPB capability is NULL");\r\nreturn -EINVAL;\r\n}\r\nwritel(value, stream->spib_addr);\r\nreturn 0;\r\n}\r\nint snd_hdac_ext_stream_get_spbmaxfifo(struct hdac_ext_bus *ebus,\r\nstruct hdac_ext_stream *stream)\r\n{\r\nstruct hdac_bus *bus = &ebus->bus;\r\nif (!ebus->spbcap) {\r\ndev_err(bus->dev, "Address of SPB capability is NULL");\r\nreturn -EINVAL;\r\n}\r\nreturn readl(stream->fifo_addr);\r\n}\r\nvoid snd_hdac_ext_stop_streams(struct hdac_ext_bus *ebus)\r\n{\r\nstruct hdac_bus *bus = ebus_to_hbus(ebus);\r\nstruct hdac_stream *stream;\r\nif (bus->chip_init) {\r\nlist_for_each_entry(stream, &bus->stream_list, list)\r\nsnd_hdac_stream_stop(stream);\r\nsnd_hdac_bus_stop_chip(bus);\r\n}\r\n}\r\nvoid snd_hdac_ext_stream_drsm_enable(struct hdac_ext_bus *ebus,\r\nbool enable, int index)\r\n{\r\nu32 mask = 0;\r\nu32 register_mask = 0;\r\nstruct hdac_bus *bus = &ebus->bus;\r\nif (!ebus->drsmcap) {\r\ndev_err(bus->dev, "Address of DRSM capability is NULL");\r\nreturn;\r\n}\r\nmask |= (1 << index);\r\nregister_mask = readl(ebus->drsmcap + AZX_REG_SPB_SPBFCCTL);\r\nmask |= register_mask;\r\nif (enable)\r\nsnd_hdac_updatel(ebus->drsmcap, AZX_REG_DRSM_CTL, 0, mask);\r\nelse\r\nsnd_hdac_updatel(ebus->drsmcap, AZX_REG_DRSM_CTL, mask, 0);\r\n}\r\nint snd_hdac_ext_stream_set_dpibr(struct hdac_ext_bus *ebus,\r\nstruct hdac_ext_stream *stream, u32 value)\r\n{\r\nstruct hdac_bus *bus = &ebus->bus;\r\nif (!ebus->drsmcap) {\r\ndev_err(bus->dev, "Address of DRSM capability is NULL");\r\nreturn -EINVAL;\r\n}\r\nwritel(value, stream->dpibr_addr);\r\nreturn 0;\r\n}\r\nint snd_hdac_ext_stream_set_lpib(struct hdac_ext_stream *stream, u32 value)\r\n{\r\nsnd_hdac_stream_writel(&stream->hstream, SD_LPIB, value);\r\nreturn 0;\r\n}
