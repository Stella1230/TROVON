static void null_cs_control(u32 command)\r\n{\r\npr_debug("pl022: dummy chip select control, CS=0x%x\n", command);\r\n}\r\nstatic void internal_cs_control(struct pl022 *pl022, u32 command)\r\n{\r\nu32 tmp;\r\ntmp = readw(SSP_CSR(pl022->virtbase));\r\nif (command == SSP_CHIP_SELECT)\r\ntmp &= ~BIT(pl022->cur_cs);\r\nelse\r\ntmp |= BIT(pl022->cur_cs);\r\nwritew(tmp, SSP_CSR(pl022->virtbase));\r\n}\r\nstatic void pl022_cs_control(struct pl022 *pl022, u32 command)\r\n{\r\nif (pl022->vendor->internal_cs_ctrl)\r\ninternal_cs_control(pl022, command);\r\nelse if (gpio_is_valid(pl022->cur_cs))\r\ngpio_set_value(pl022->cur_cs, command);\r\nelse\r\npl022->cur_chip->cs_control(command);\r\n}\r\nstatic void giveback(struct pl022 *pl022)\r\n{\r\nstruct spi_transfer *last_transfer;\r\npl022->next_msg_cs_active = false;\r\nlast_transfer = list_last_entry(&pl022->cur_msg->transfers,\r\nstruct spi_transfer, transfer_list);\r\nif (last_transfer->delay_usecs)\r\nudelay(last_transfer->delay_usecs);\r\nif (!last_transfer->cs_change) {\r\nstruct spi_message *next_msg;\r\nnext_msg = spi_get_next_queued_message(pl022->master);\r\nif (next_msg && next_msg->spi != pl022->cur_msg->spi)\r\nnext_msg = NULL;\r\nif (!next_msg || pl022->cur_msg->state == STATE_ERROR)\r\npl022_cs_control(pl022, SSP_CHIP_DESELECT);\r\nelse\r\npl022->next_msg_cs_active = true;\r\n}\r\npl022->cur_msg = NULL;\r\npl022->cur_transfer = NULL;\r\npl022->cur_chip = NULL;\r\nwritew((readw(SSP_CR1(pl022->virtbase)) &\r\n(~SSP_CR1_MASK_SSE)), SSP_CR1(pl022->virtbase));\r\nspi_finalize_current_message(pl022->master);\r\n}\r\nstatic int flush(struct pl022 *pl022)\r\n{\r\nunsigned long limit = loops_per_jiffy << 1;\r\ndev_dbg(&pl022->adev->dev, "flush\n");\r\ndo {\r\nwhile (readw(SSP_SR(pl022->virtbase)) & SSP_SR_MASK_RNE)\r\nreadw(SSP_DR(pl022->virtbase));\r\n} while ((readw(SSP_SR(pl022->virtbase)) & SSP_SR_MASK_BSY) && limit--);\r\npl022->exp_fifo_level = 0;\r\nreturn limit;\r\n}\r\nstatic void restore_state(struct pl022 *pl022)\r\n{\r\nstruct chip_data *chip = pl022->cur_chip;\r\nif (pl022->vendor->extended_cr)\r\nwritel(chip->cr0, SSP_CR0(pl022->virtbase));\r\nelse\r\nwritew(chip->cr0, SSP_CR0(pl022->virtbase));\r\nwritew(chip->cr1, SSP_CR1(pl022->virtbase));\r\nwritew(chip->dmacr, SSP_DMACR(pl022->virtbase));\r\nwritew(chip->cpsr, SSP_CPSR(pl022->virtbase));\r\nwritew(DISABLE_ALL_INTERRUPTS, SSP_IMSC(pl022->virtbase));\r\nwritew(CLEAR_ALL_INTERRUPTS, SSP_ICR(pl022->virtbase));\r\n}\r\nstatic void load_ssp_default_config(struct pl022 *pl022)\r\n{\r\nif (pl022->vendor->pl023) {\r\nwritel(DEFAULT_SSP_REG_CR0_ST_PL023, SSP_CR0(pl022->virtbase));\r\nwritew(DEFAULT_SSP_REG_CR1_ST_PL023, SSP_CR1(pl022->virtbase));\r\n} else if (pl022->vendor->extended_cr) {\r\nwritel(DEFAULT_SSP_REG_CR0_ST, SSP_CR0(pl022->virtbase));\r\nwritew(DEFAULT_SSP_REG_CR1_ST, SSP_CR1(pl022->virtbase));\r\n} else {\r\nwritew(DEFAULT_SSP_REG_CR0, SSP_CR0(pl022->virtbase));\r\nwritew(DEFAULT_SSP_REG_CR1, SSP_CR1(pl022->virtbase));\r\n}\r\nwritew(DEFAULT_SSP_REG_DMACR, SSP_DMACR(pl022->virtbase));\r\nwritew(DEFAULT_SSP_REG_CPSR, SSP_CPSR(pl022->virtbase));\r\nwritew(DISABLE_ALL_INTERRUPTS, SSP_IMSC(pl022->virtbase));\r\nwritew(CLEAR_ALL_INTERRUPTS, SSP_ICR(pl022->virtbase));\r\n}\r\nstatic void readwriter(struct pl022 *pl022)\r\n{\r\ndev_dbg(&pl022->adev->dev,\r\n"%s, rx: %p, rxend: %p, tx: %p, txend: %p\n",\r\n__func__, pl022->rx, pl022->rx_end, pl022->tx, pl022->tx_end);\r\nwhile ((readw(SSP_SR(pl022->virtbase)) & SSP_SR_MASK_RNE)\r\n&& (pl022->rx < pl022->rx_end)) {\r\nswitch (pl022->read) {\r\ncase READING_NULL:\r\nreadw(SSP_DR(pl022->virtbase));\r\nbreak;\r\ncase READING_U8:\r\n*(u8 *) (pl022->rx) =\r\nreadw(SSP_DR(pl022->virtbase)) & 0xFFU;\r\nbreak;\r\ncase READING_U16:\r\n*(u16 *) (pl022->rx) =\r\n(u16) readw(SSP_DR(pl022->virtbase));\r\nbreak;\r\ncase READING_U32:\r\n*(u32 *) (pl022->rx) =\r\nreadl(SSP_DR(pl022->virtbase));\r\nbreak;\r\n}\r\npl022->rx += (pl022->cur_chip->n_bytes);\r\npl022->exp_fifo_level--;\r\n}\r\nwhile ((pl022->exp_fifo_level < pl022->vendor->fifodepth)\r\n&& (pl022->tx < pl022->tx_end)) {\r\nswitch (pl022->write) {\r\ncase WRITING_NULL:\r\nwritew(0x0, SSP_DR(pl022->virtbase));\r\nbreak;\r\ncase WRITING_U8:\r\nwritew(*(u8 *) (pl022->tx), SSP_DR(pl022->virtbase));\r\nbreak;\r\ncase WRITING_U16:\r\nwritew((*(u16 *) (pl022->tx)), SSP_DR(pl022->virtbase));\r\nbreak;\r\ncase WRITING_U32:\r\nwritel(*(u32 *) (pl022->tx), SSP_DR(pl022->virtbase));\r\nbreak;\r\n}\r\npl022->tx += (pl022->cur_chip->n_bytes);\r\npl022->exp_fifo_level++;\r\nwhile ((readw(SSP_SR(pl022->virtbase)) & SSP_SR_MASK_RNE)\r\n&& (pl022->rx < pl022->rx_end)) {\r\nswitch (pl022->read) {\r\ncase READING_NULL:\r\nreadw(SSP_DR(pl022->virtbase));\r\nbreak;\r\ncase READING_U8:\r\n*(u8 *) (pl022->rx) =\r\nreadw(SSP_DR(pl022->virtbase)) & 0xFFU;\r\nbreak;\r\ncase READING_U16:\r\n*(u16 *) (pl022->rx) =\r\n(u16) readw(SSP_DR(pl022->virtbase));\r\nbreak;\r\ncase READING_U32:\r\n*(u32 *) (pl022->rx) =\r\nreadl(SSP_DR(pl022->virtbase));\r\nbreak;\r\n}\r\npl022->rx += (pl022->cur_chip->n_bytes);\r\npl022->exp_fifo_level--;\r\n}\r\n}\r\n}\r\nstatic void *next_transfer(struct pl022 *pl022)\r\n{\r\nstruct spi_message *msg = pl022->cur_msg;\r\nstruct spi_transfer *trans = pl022->cur_transfer;\r\nif (trans->transfer_list.next != &msg->transfers) {\r\npl022->cur_transfer =\r\nlist_entry(trans->transfer_list.next,\r\nstruct spi_transfer, transfer_list);\r\nreturn STATE_RUNNING;\r\n}\r\nreturn STATE_DONE;\r\n}\r\nstatic void unmap_free_dma_scatter(struct pl022 *pl022)\r\n{\r\ndma_unmap_sg(pl022->dma_tx_channel->device->dev, pl022->sgt_tx.sgl,\r\npl022->sgt_tx.nents, DMA_TO_DEVICE);\r\ndma_unmap_sg(pl022->dma_rx_channel->device->dev, pl022->sgt_rx.sgl,\r\npl022->sgt_rx.nents, DMA_FROM_DEVICE);\r\nsg_free_table(&pl022->sgt_rx);\r\nsg_free_table(&pl022->sgt_tx);\r\n}\r\nstatic void dma_callback(void *data)\r\n{\r\nstruct pl022 *pl022 = data;\r\nstruct spi_message *msg = pl022->cur_msg;\r\nBUG_ON(!pl022->sgt_rx.sgl);\r\n#ifdef VERBOSE_DEBUG\r\n{\r\nstruct scatterlist *sg;\r\nunsigned int i;\r\ndma_sync_sg_for_cpu(&pl022->adev->dev,\r\npl022->sgt_rx.sgl,\r\npl022->sgt_rx.nents,\r\nDMA_FROM_DEVICE);\r\nfor_each_sg(pl022->sgt_rx.sgl, sg, pl022->sgt_rx.nents, i) {\r\ndev_dbg(&pl022->adev->dev, "SPI RX SG ENTRY: %d", i);\r\nprint_hex_dump(KERN_ERR, "SPI RX: ",\r\nDUMP_PREFIX_OFFSET,\r\n16,\r\n1,\r\nsg_virt(sg),\r\nsg_dma_len(sg),\r\n1);\r\n}\r\nfor_each_sg(pl022->sgt_tx.sgl, sg, pl022->sgt_tx.nents, i) {\r\ndev_dbg(&pl022->adev->dev, "SPI TX SG ENTRY: %d", i);\r\nprint_hex_dump(KERN_ERR, "SPI TX: ",\r\nDUMP_PREFIX_OFFSET,\r\n16,\r\n1,\r\nsg_virt(sg),\r\nsg_dma_len(sg),\r\n1);\r\n}\r\n}\r\n#endif\r\nunmap_free_dma_scatter(pl022);\r\nmsg->actual_length += pl022->cur_transfer->len;\r\nif (pl022->cur_transfer->cs_change)\r\npl022_cs_control(pl022, SSP_CHIP_DESELECT);\r\nmsg->state = next_transfer(pl022);\r\ntasklet_schedule(&pl022->pump_transfers);\r\n}\r\nstatic void setup_dma_scatter(struct pl022 *pl022,\r\nvoid *buffer,\r\nunsigned int length,\r\nstruct sg_table *sgtab)\r\n{\r\nstruct scatterlist *sg;\r\nint bytesleft = length;\r\nvoid *bufp = buffer;\r\nint mapbytes;\r\nint i;\r\nif (buffer) {\r\nfor_each_sg(sgtab->sgl, sg, sgtab->nents, i) {\r\nif (bytesleft < (PAGE_SIZE - offset_in_page(bufp)))\r\nmapbytes = bytesleft;\r\nelse\r\nmapbytes = PAGE_SIZE - offset_in_page(bufp);\r\nsg_set_page(sg, virt_to_page(bufp),\r\nmapbytes, offset_in_page(bufp));\r\nbufp += mapbytes;\r\nbytesleft -= mapbytes;\r\ndev_dbg(&pl022->adev->dev,\r\n"set RX/TX target page @ %p, %d bytes, %d left\n",\r\nbufp, mapbytes, bytesleft);\r\n}\r\n} else {\r\nfor_each_sg(sgtab->sgl, sg, sgtab->nents, i) {\r\nif (bytesleft < PAGE_SIZE)\r\nmapbytes = bytesleft;\r\nelse\r\nmapbytes = PAGE_SIZE;\r\nsg_set_page(sg, virt_to_page(pl022->dummypage),\r\nmapbytes, 0);\r\nbytesleft -= mapbytes;\r\ndev_dbg(&pl022->adev->dev,\r\n"set RX/TX to dummy page %d bytes, %d left\n",\r\nmapbytes, bytesleft);\r\n}\r\n}\r\nBUG_ON(bytesleft);\r\n}\r\nstatic int configure_dma(struct pl022 *pl022)\r\n{\r\nstruct dma_slave_config rx_conf = {\r\n.src_addr = SSP_DR(pl022->phybase),\r\n.direction = DMA_DEV_TO_MEM,\r\n.device_fc = false,\r\n};\r\nstruct dma_slave_config tx_conf = {\r\n.dst_addr = SSP_DR(pl022->phybase),\r\n.direction = DMA_MEM_TO_DEV,\r\n.device_fc = false,\r\n};\r\nunsigned int pages;\r\nint ret;\r\nint rx_sglen, tx_sglen;\r\nstruct dma_chan *rxchan = pl022->dma_rx_channel;\r\nstruct dma_chan *txchan = pl022->dma_tx_channel;\r\nstruct dma_async_tx_descriptor *rxdesc;\r\nstruct dma_async_tx_descriptor *txdesc;\r\nif (!rxchan || !txchan)\r\nreturn -ENODEV;\r\nswitch (pl022->rx_lev_trig) {\r\ncase SSP_RX_1_OR_MORE_ELEM:\r\nrx_conf.src_maxburst = 1;\r\nbreak;\r\ncase SSP_RX_4_OR_MORE_ELEM:\r\nrx_conf.src_maxburst = 4;\r\nbreak;\r\ncase SSP_RX_8_OR_MORE_ELEM:\r\nrx_conf.src_maxburst = 8;\r\nbreak;\r\ncase SSP_RX_16_OR_MORE_ELEM:\r\nrx_conf.src_maxburst = 16;\r\nbreak;\r\ncase SSP_RX_32_OR_MORE_ELEM:\r\nrx_conf.src_maxburst = 32;\r\nbreak;\r\ndefault:\r\nrx_conf.src_maxburst = pl022->vendor->fifodepth >> 1;\r\nbreak;\r\n}\r\nswitch (pl022->tx_lev_trig) {\r\ncase SSP_TX_1_OR_MORE_EMPTY_LOC:\r\ntx_conf.dst_maxburst = 1;\r\nbreak;\r\ncase SSP_TX_4_OR_MORE_EMPTY_LOC:\r\ntx_conf.dst_maxburst = 4;\r\nbreak;\r\ncase SSP_TX_8_OR_MORE_EMPTY_LOC:\r\ntx_conf.dst_maxburst = 8;\r\nbreak;\r\ncase SSP_TX_16_OR_MORE_EMPTY_LOC:\r\ntx_conf.dst_maxburst = 16;\r\nbreak;\r\ncase SSP_TX_32_OR_MORE_EMPTY_LOC:\r\ntx_conf.dst_maxburst = 32;\r\nbreak;\r\ndefault:\r\ntx_conf.dst_maxburst = pl022->vendor->fifodepth >> 1;\r\nbreak;\r\n}\r\nswitch (pl022->read) {\r\ncase READING_NULL:\r\nrx_conf.src_addr_width = DMA_SLAVE_BUSWIDTH_UNDEFINED;\r\nbreak;\r\ncase READING_U8:\r\nrx_conf.src_addr_width = DMA_SLAVE_BUSWIDTH_1_BYTE;\r\nbreak;\r\ncase READING_U16:\r\nrx_conf.src_addr_width = DMA_SLAVE_BUSWIDTH_2_BYTES;\r\nbreak;\r\ncase READING_U32:\r\nrx_conf.src_addr_width = DMA_SLAVE_BUSWIDTH_4_BYTES;\r\nbreak;\r\n}\r\nswitch (pl022->write) {\r\ncase WRITING_NULL:\r\ntx_conf.dst_addr_width = DMA_SLAVE_BUSWIDTH_UNDEFINED;\r\nbreak;\r\ncase WRITING_U8:\r\ntx_conf.dst_addr_width = DMA_SLAVE_BUSWIDTH_1_BYTE;\r\nbreak;\r\ncase WRITING_U16:\r\ntx_conf.dst_addr_width = DMA_SLAVE_BUSWIDTH_2_BYTES;\r\nbreak;\r\ncase WRITING_U32:\r\ntx_conf.dst_addr_width = DMA_SLAVE_BUSWIDTH_4_BYTES;\r\nbreak;\r\n}\r\nif (rx_conf.src_addr_width == DMA_SLAVE_BUSWIDTH_UNDEFINED)\r\nrx_conf.src_addr_width = tx_conf.dst_addr_width;\r\nif (tx_conf.dst_addr_width == DMA_SLAVE_BUSWIDTH_UNDEFINED)\r\ntx_conf.dst_addr_width = rx_conf.src_addr_width;\r\nBUG_ON(rx_conf.src_addr_width != tx_conf.dst_addr_width);\r\ndmaengine_slave_config(rxchan, &rx_conf);\r\ndmaengine_slave_config(txchan, &tx_conf);\r\npages = DIV_ROUND_UP(pl022->cur_transfer->len, PAGE_SIZE);\r\ndev_dbg(&pl022->adev->dev, "using %d pages for transfer\n", pages);\r\nret = sg_alloc_table(&pl022->sgt_rx, pages, GFP_ATOMIC);\r\nif (ret)\r\ngoto err_alloc_rx_sg;\r\nret = sg_alloc_table(&pl022->sgt_tx, pages, GFP_ATOMIC);\r\nif (ret)\r\ngoto err_alloc_tx_sg;\r\nsetup_dma_scatter(pl022, pl022->rx,\r\npl022->cur_transfer->len, &pl022->sgt_rx);\r\nsetup_dma_scatter(pl022, pl022->tx,\r\npl022->cur_transfer->len, &pl022->sgt_tx);\r\nrx_sglen = dma_map_sg(rxchan->device->dev, pl022->sgt_rx.sgl,\r\npl022->sgt_rx.nents, DMA_FROM_DEVICE);\r\nif (!rx_sglen)\r\ngoto err_rx_sgmap;\r\ntx_sglen = dma_map_sg(txchan->device->dev, pl022->sgt_tx.sgl,\r\npl022->sgt_tx.nents, DMA_TO_DEVICE);\r\nif (!tx_sglen)\r\ngoto err_tx_sgmap;\r\nrxdesc = dmaengine_prep_slave_sg(rxchan,\r\npl022->sgt_rx.sgl,\r\nrx_sglen,\r\nDMA_DEV_TO_MEM,\r\nDMA_PREP_INTERRUPT | DMA_CTRL_ACK);\r\nif (!rxdesc)\r\ngoto err_rxdesc;\r\ntxdesc = dmaengine_prep_slave_sg(txchan,\r\npl022->sgt_tx.sgl,\r\ntx_sglen,\r\nDMA_MEM_TO_DEV,\r\nDMA_PREP_INTERRUPT | DMA_CTRL_ACK);\r\nif (!txdesc)\r\ngoto err_txdesc;\r\nrxdesc->callback = dma_callback;\r\nrxdesc->callback_param = pl022;\r\ndmaengine_submit(rxdesc);\r\ndmaengine_submit(txdesc);\r\ndma_async_issue_pending(rxchan);\r\ndma_async_issue_pending(txchan);\r\npl022->dma_running = true;\r\nreturn 0;\r\nerr_txdesc:\r\ndmaengine_terminate_all(txchan);\r\nerr_rxdesc:\r\ndmaengine_terminate_all(rxchan);\r\ndma_unmap_sg(txchan->device->dev, pl022->sgt_tx.sgl,\r\npl022->sgt_tx.nents, DMA_TO_DEVICE);\r\nerr_tx_sgmap:\r\ndma_unmap_sg(rxchan->device->dev, pl022->sgt_rx.sgl,\r\npl022->sgt_rx.nents, DMA_FROM_DEVICE);\r\nerr_rx_sgmap:\r\nsg_free_table(&pl022->sgt_tx);\r\nerr_alloc_tx_sg:\r\nsg_free_table(&pl022->sgt_rx);\r\nerr_alloc_rx_sg:\r\nreturn -ENOMEM;\r\n}\r\nstatic int pl022_dma_probe(struct pl022 *pl022)\r\n{\r\ndma_cap_mask_t mask;\r\ndma_cap_zero(mask);\r\ndma_cap_set(DMA_SLAVE, mask);\r\npl022->dma_rx_channel = dma_request_channel(mask,\r\npl022->master_info->dma_filter,\r\npl022->master_info->dma_rx_param);\r\nif (!pl022->dma_rx_channel) {\r\ndev_dbg(&pl022->adev->dev, "no RX DMA channel!\n");\r\ngoto err_no_rxchan;\r\n}\r\npl022->dma_tx_channel = dma_request_channel(mask,\r\npl022->master_info->dma_filter,\r\npl022->master_info->dma_tx_param);\r\nif (!pl022->dma_tx_channel) {\r\ndev_dbg(&pl022->adev->dev, "no TX DMA channel!\n");\r\ngoto err_no_txchan;\r\n}\r\npl022->dummypage = kmalloc(PAGE_SIZE, GFP_KERNEL);\r\nif (!pl022->dummypage)\r\ngoto err_no_dummypage;\r\ndev_info(&pl022->adev->dev, "setup for DMA on RX %s, TX %s\n",\r\ndma_chan_name(pl022->dma_rx_channel),\r\ndma_chan_name(pl022->dma_tx_channel));\r\nreturn 0;\r\nerr_no_dummypage:\r\ndma_release_channel(pl022->dma_tx_channel);\r\nerr_no_txchan:\r\ndma_release_channel(pl022->dma_rx_channel);\r\npl022->dma_rx_channel = NULL;\r\nerr_no_rxchan:\r\ndev_err(&pl022->adev->dev,\r\n"Failed to work in dma mode, work without dma!\n");\r\nreturn -ENODEV;\r\n}\r\nstatic int pl022_dma_autoprobe(struct pl022 *pl022)\r\n{\r\nstruct device *dev = &pl022->adev->dev;\r\nstruct dma_chan *chan;\r\nint err;\r\nchan = dma_request_slave_channel_reason(dev, "rx");\r\nif (IS_ERR(chan)) {\r\nerr = PTR_ERR(chan);\r\ngoto err_no_rxchan;\r\n}\r\npl022->dma_rx_channel = chan;\r\nchan = dma_request_slave_channel_reason(dev, "tx");\r\nif (IS_ERR(chan)) {\r\nerr = PTR_ERR(chan);\r\ngoto err_no_txchan;\r\n}\r\npl022->dma_tx_channel = chan;\r\npl022->dummypage = kmalloc(PAGE_SIZE, GFP_KERNEL);\r\nif (!pl022->dummypage) {\r\nerr = -ENOMEM;\r\ngoto err_no_dummypage;\r\n}\r\nreturn 0;\r\nerr_no_dummypage:\r\ndma_release_channel(pl022->dma_tx_channel);\r\npl022->dma_tx_channel = NULL;\r\nerr_no_txchan:\r\ndma_release_channel(pl022->dma_rx_channel);\r\npl022->dma_rx_channel = NULL;\r\nerr_no_rxchan:\r\nreturn err;\r\n}\r\nstatic void terminate_dma(struct pl022 *pl022)\r\n{\r\nstruct dma_chan *rxchan = pl022->dma_rx_channel;\r\nstruct dma_chan *txchan = pl022->dma_tx_channel;\r\ndmaengine_terminate_all(rxchan);\r\ndmaengine_terminate_all(txchan);\r\nunmap_free_dma_scatter(pl022);\r\npl022->dma_running = false;\r\n}\r\nstatic void pl022_dma_remove(struct pl022 *pl022)\r\n{\r\nif (pl022->dma_running)\r\nterminate_dma(pl022);\r\nif (pl022->dma_tx_channel)\r\ndma_release_channel(pl022->dma_tx_channel);\r\nif (pl022->dma_rx_channel)\r\ndma_release_channel(pl022->dma_rx_channel);\r\nkfree(pl022->dummypage);\r\n}\r\nstatic inline int configure_dma(struct pl022 *pl022)\r\n{\r\nreturn -ENODEV;\r\n}\r\nstatic inline int pl022_dma_autoprobe(struct pl022 *pl022)\r\n{\r\nreturn 0;\r\n}\r\nstatic inline int pl022_dma_probe(struct pl022 *pl022)\r\n{\r\nreturn 0;\r\n}\r\nstatic inline void pl022_dma_remove(struct pl022 *pl022)\r\n{\r\n}\r\nstatic irqreturn_t pl022_interrupt_handler(int irq, void *dev_id)\r\n{\r\nstruct pl022 *pl022 = dev_id;\r\nstruct spi_message *msg = pl022->cur_msg;\r\nu16 irq_status = 0;\r\nif (unlikely(!msg)) {\r\ndev_err(&pl022->adev->dev,\r\n"bad message state in interrupt handler");\r\nreturn IRQ_HANDLED;\r\n}\r\nirq_status = readw(SSP_MIS(pl022->virtbase));\r\nif (unlikely(!irq_status))\r\nreturn IRQ_NONE;\r\nif (unlikely(irq_status & SSP_MIS_MASK_RORMIS)) {\r\ndev_err(&pl022->adev->dev, "FIFO overrun\n");\r\nif (readw(SSP_SR(pl022->virtbase)) & SSP_SR_MASK_RFF)\r\ndev_err(&pl022->adev->dev,\r\n"RXFIFO is full\n");\r\nwritew(DISABLE_ALL_INTERRUPTS,\r\nSSP_IMSC(pl022->virtbase));\r\nwritew(CLEAR_ALL_INTERRUPTS, SSP_ICR(pl022->virtbase));\r\nwritew((readw(SSP_CR1(pl022->virtbase)) &\r\n(~SSP_CR1_MASK_SSE)), SSP_CR1(pl022->virtbase));\r\nmsg->state = STATE_ERROR;\r\ntasklet_schedule(&pl022->pump_transfers);\r\nreturn IRQ_HANDLED;\r\n}\r\nreadwriter(pl022);\r\nif (pl022->tx == pl022->tx_end) {\r\nwritew((readw(SSP_IMSC(pl022->virtbase)) &\r\n~SSP_IMSC_MASK_TXIM) | SSP_IMSC_MASK_RXIM,\r\nSSP_IMSC(pl022->virtbase));\r\n}\r\nif (pl022->rx >= pl022->rx_end) {\r\nwritew(DISABLE_ALL_INTERRUPTS,\r\nSSP_IMSC(pl022->virtbase));\r\nwritew(CLEAR_ALL_INTERRUPTS, SSP_ICR(pl022->virtbase));\r\nif (unlikely(pl022->rx > pl022->rx_end)) {\r\ndev_warn(&pl022->adev->dev, "read %u surplus "\r\n"bytes (did you request an odd "\r\n"number of bytes on a 16bit bus?)\n",\r\n(u32) (pl022->rx - pl022->rx_end));\r\n}\r\nmsg->actual_length += pl022->cur_transfer->len;\r\nif (pl022->cur_transfer->cs_change)\r\npl022_cs_control(pl022, SSP_CHIP_DESELECT);\r\nmsg->state = next_transfer(pl022);\r\ntasklet_schedule(&pl022->pump_transfers);\r\nreturn IRQ_HANDLED;\r\n}\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int set_up_next_transfer(struct pl022 *pl022,\r\nstruct spi_transfer *transfer)\r\n{\r\nint residue;\r\nresidue = pl022->cur_transfer->len % pl022->cur_chip->n_bytes;\r\nif (unlikely(residue != 0)) {\r\ndev_err(&pl022->adev->dev,\r\n"message of %u bytes to transmit but the current "\r\n"chip bus has a data width of %u bytes!\n",\r\npl022->cur_transfer->len,\r\npl022->cur_chip->n_bytes);\r\ndev_err(&pl022->adev->dev, "skipping this message\n");\r\nreturn -EIO;\r\n}\r\npl022->tx = (void *)transfer->tx_buf;\r\npl022->tx_end = pl022->tx + pl022->cur_transfer->len;\r\npl022->rx = (void *)transfer->rx_buf;\r\npl022->rx_end = pl022->rx + pl022->cur_transfer->len;\r\npl022->write =\r\npl022->tx ? pl022->cur_chip->write : WRITING_NULL;\r\npl022->read = pl022->rx ? pl022->cur_chip->read : READING_NULL;\r\nreturn 0;\r\n}\r\nstatic void pump_transfers(unsigned long data)\r\n{\r\nstruct pl022 *pl022 = (struct pl022 *) data;\r\nstruct spi_message *message = NULL;\r\nstruct spi_transfer *transfer = NULL;\r\nstruct spi_transfer *previous = NULL;\r\nmessage = pl022->cur_msg;\r\ntransfer = pl022->cur_transfer;\r\nif (message->state == STATE_ERROR) {\r\nmessage->status = -EIO;\r\ngiveback(pl022);\r\nreturn;\r\n}\r\nif (message->state == STATE_DONE) {\r\nmessage->status = 0;\r\ngiveback(pl022);\r\nreturn;\r\n}\r\nif (message->state == STATE_RUNNING) {\r\nprevious = list_entry(transfer->transfer_list.prev,\r\nstruct spi_transfer,\r\ntransfer_list);\r\nif (previous->delay_usecs)\r\nudelay(previous->delay_usecs);\r\nif (previous->cs_change)\r\npl022_cs_control(pl022, SSP_CHIP_SELECT);\r\n} else {\r\nmessage->state = STATE_RUNNING;\r\n}\r\nif (set_up_next_transfer(pl022, transfer)) {\r\nmessage->state = STATE_ERROR;\r\nmessage->status = -EIO;\r\ngiveback(pl022);\r\nreturn;\r\n}\r\nflush(pl022);\r\nif (pl022->cur_chip->enable_dma) {\r\nif (configure_dma(pl022)) {\r\ndev_dbg(&pl022->adev->dev,\r\n"configuration of DMA failed, fall back to interrupt mode\n");\r\ngoto err_config_dma;\r\n}\r\nreturn;\r\n}\r\nerr_config_dma:\r\nwritew(ENABLE_ALL_INTERRUPTS & ~SSP_IMSC_MASK_RXIM, SSP_IMSC(pl022->virtbase));\r\n}\r\nstatic void do_interrupt_dma_transfer(struct pl022 *pl022)\r\n{\r\nu32 irqflags = (u32)(ENABLE_ALL_INTERRUPTS & ~SSP_IMSC_MASK_RXIM);\r\nif (!pl022->next_msg_cs_active)\r\npl022_cs_control(pl022, SSP_CHIP_SELECT);\r\nif (set_up_next_transfer(pl022, pl022->cur_transfer)) {\r\npl022->cur_msg->state = STATE_ERROR;\r\npl022->cur_msg->status = -EIO;\r\ngiveback(pl022);\r\nreturn;\r\n}\r\nif (pl022->cur_chip->enable_dma) {\r\nif (configure_dma(pl022)) {\r\ndev_dbg(&pl022->adev->dev,\r\n"configuration of DMA failed, fall back to interrupt mode\n");\r\ngoto err_config_dma;\r\n}\r\nirqflags = DISABLE_ALL_INTERRUPTS;\r\n}\r\nerr_config_dma:\r\nwritew((readw(SSP_CR1(pl022->virtbase)) | SSP_CR1_MASK_SSE),\r\nSSP_CR1(pl022->virtbase));\r\nwritew(irqflags, SSP_IMSC(pl022->virtbase));\r\n}\r\nstatic void do_polling_transfer(struct pl022 *pl022)\r\n{\r\nstruct spi_message *message = NULL;\r\nstruct spi_transfer *transfer = NULL;\r\nstruct spi_transfer *previous = NULL;\r\nstruct chip_data *chip;\r\nunsigned long time, timeout;\r\nchip = pl022->cur_chip;\r\nmessage = pl022->cur_msg;\r\nwhile (message->state != STATE_DONE) {\r\nif (message->state == STATE_ERROR)\r\nbreak;\r\ntransfer = pl022->cur_transfer;\r\nif (message->state == STATE_RUNNING) {\r\nprevious =\r\nlist_entry(transfer->transfer_list.prev,\r\nstruct spi_transfer, transfer_list);\r\nif (previous->delay_usecs)\r\nudelay(previous->delay_usecs);\r\nif (previous->cs_change)\r\npl022_cs_control(pl022, SSP_CHIP_SELECT);\r\n} else {\r\nmessage->state = STATE_RUNNING;\r\nif (!pl022->next_msg_cs_active)\r\npl022_cs_control(pl022, SSP_CHIP_SELECT);\r\n}\r\nif (set_up_next_transfer(pl022, transfer)) {\r\nmessage->state = STATE_ERROR;\r\nbreak;\r\n}\r\nflush(pl022);\r\nwritew((readw(SSP_CR1(pl022->virtbase)) | SSP_CR1_MASK_SSE),\r\nSSP_CR1(pl022->virtbase));\r\ndev_dbg(&pl022->adev->dev, "polling transfer ongoing ...\n");\r\ntimeout = jiffies + msecs_to_jiffies(SPI_POLLING_TIMEOUT);\r\nwhile (pl022->tx < pl022->tx_end || pl022->rx < pl022->rx_end) {\r\ntime = jiffies;\r\nreadwriter(pl022);\r\nif (time_after(time, timeout)) {\r\ndev_warn(&pl022->adev->dev,\r\n"%s: timeout!\n", __func__);\r\nmessage->state = STATE_ERROR;\r\ngoto out;\r\n}\r\ncpu_relax();\r\n}\r\nmessage->actual_length += pl022->cur_transfer->len;\r\nif (pl022->cur_transfer->cs_change)\r\npl022_cs_control(pl022, SSP_CHIP_DESELECT);\r\nmessage->state = next_transfer(pl022);\r\n}\r\nout:\r\nif (message->state == STATE_DONE)\r\nmessage->status = 0;\r\nelse\r\nmessage->status = -EIO;\r\ngiveback(pl022);\r\nreturn;\r\n}\r\nstatic int pl022_transfer_one_message(struct spi_master *master,\r\nstruct spi_message *msg)\r\n{\r\nstruct pl022 *pl022 = spi_master_get_devdata(master);\r\npl022->cur_msg = msg;\r\nmsg->state = STATE_START;\r\npl022->cur_transfer = list_entry(msg->transfers.next,\r\nstruct spi_transfer, transfer_list);\r\npl022->cur_chip = spi_get_ctldata(msg->spi);\r\npl022->cur_cs = pl022->chipselects[msg->spi->chip_select];\r\nrestore_state(pl022);\r\nflush(pl022);\r\nif (pl022->cur_chip->xfer_type == POLLING_TRANSFER)\r\ndo_polling_transfer(pl022);\r\nelse\r\ndo_interrupt_dma_transfer(pl022);\r\nreturn 0;\r\n}\r\nstatic int pl022_unprepare_transfer_hardware(struct spi_master *master)\r\n{\r\nstruct pl022 *pl022 = spi_master_get_devdata(master);\r\nwritew((readw(SSP_CR1(pl022->virtbase)) &\r\n(~SSP_CR1_MASK_SSE)), SSP_CR1(pl022->virtbase));\r\nreturn 0;\r\n}\r\nstatic int verify_controller_parameters(struct pl022 *pl022,\r\nstruct pl022_config_chip const *chip_info)\r\n{\r\nif ((chip_info->iface < SSP_INTERFACE_MOTOROLA_SPI)\r\n|| (chip_info->iface > SSP_INTERFACE_UNIDIRECTIONAL)) {\r\ndev_err(&pl022->adev->dev,\r\n"interface is configured incorrectly\n");\r\nreturn -EINVAL;\r\n}\r\nif ((chip_info->iface == SSP_INTERFACE_UNIDIRECTIONAL) &&\r\n(!pl022->vendor->unidir)) {\r\ndev_err(&pl022->adev->dev,\r\n"unidirectional mode not supported in this "\r\n"hardware version\n");\r\nreturn -EINVAL;\r\n}\r\nif ((chip_info->hierarchy != SSP_MASTER)\r\n&& (chip_info->hierarchy != SSP_SLAVE)) {\r\ndev_err(&pl022->adev->dev,\r\n"hierarchy is configured incorrectly\n");\r\nreturn -EINVAL;\r\n}\r\nif ((chip_info->com_mode != INTERRUPT_TRANSFER)\r\n&& (chip_info->com_mode != DMA_TRANSFER)\r\n&& (chip_info->com_mode != POLLING_TRANSFER)) {\r\ndev_err(&pl022->adev->dev,\r\n"Communication mode is configured incorrectly\n");\r\nreturn -EINVAL;\r\n}\r\nswitch (chip_info->rx_lev_trig) {\r\ncase SSP_RX_1_OR_MORE_ELEM:\r\ncase SSP_RX_4_OR_MORE_ELEM:\r\ncase SSP_RX_8_OR_MORE_ELEM:\r\nbreak;\r\ncase SSP_RX_16_OR_MORE_ELEM:\r\nif (pl022->vendor->fifodepth < 16) {\r\ndev_err(&pl022->adev->dev,\r\n"RX FIFO Trigger Level is configured incorrectly\n");\r\nreturn -EINVAL;\r\n}\r\nbreak;\r\ncase SSP_RX_32_OR_MORE_ELEM:\r\nif (pl022->vendor->fifodepth < 32) {\r\ndev_err(&pl022->adev->dev,\r\n"RX FIFO Trigger Level is configured incorrectly\n");\r\nreturn -EINVAL;\r\n}\r\nbreak;\r\ndefault:\r\ndev_err(&pl022->adev->dev,\r\n"RX FIFO Trigger Level is configured incorrectly\n");\r\nreturn -EINVAL;\r\n}\r\nswitch (chip_info->tx_lev_trig) {\r\ncase SSP_TX_1_OR_MORE_EMPTY_LOC:\r\ncase SSP_TX_4_OR_MORE_EMPTY_LOC:\r\ncase SSP_TX_8_OR_MORE_EMPTY_LOC:\r\nbreak;\r\ncase SSP_TX_16_OR_MORE_EMPTY_LOC:\r\nif (pl022->vendor->fifodepth < 16) {\r\ndev_err(&pl022->adev->dev,\r\n"TX FIFO Trigger Level is configured incorrectly\n");\r\nreturn -EINVAL;\r\n}\r\nbreak;\r\ncase SSP_TX_32_OR_MORE_EMPTY_LOC:\r\nif (pl022->vendor->fifodepth < 32) {\r\ndev_err(&pl022->adev->dev,\r\n"TX FIFO Trigger Level is configured incorrectly\n");\r\nreturn -EINVAL;\r\n}\r\nbreak;\r\ndefault:\r\ndev_err(&pl022->adev->dev,\r\n"TX FIFO Trigger Level is configured incorrectly\n");\r\nreturn -EINVAL;\r\n}\r\nif (chip_info->iface == SSP_INTERFACE_NATIONAL_MICROWIRE) {\r\nif ((chip_info->ctrl_len < SSP_BITS_4)\r\n|| (chip_info->ctrl_len > SSP_BITS_32)) {\r\ndev_err(&pl022->adev->dev,\r\n"CTRL LEN is configured incorrectly\n");\r\nreturn -EINVAL;\r\n}\r\nif ((chip_info->wait_state != SSP_MWIRE_WAIT_ZERO)\r\n&& (chip_info->wait_state != SSP_MWIRE_WAIT_ONE)) {\r\ndev_err(&pl022->adev->dev,\r\n"Wait State is configured incorrectly\n");\r\nreturn -EINVAL;\r\n}\r\nif (pl022->vendor->extended_cr) {\r\nif ((chip_info->duplex !=\r\nSSP_MICROWIRE_CHANNEL_FULL_DUPLEX)\r\n&& (chip_info->duplex !=\r\nSSP_MICROWIRE_CHANNEL_HALF_DUPLEX)) {\r\ndev_err(&pl022->adev->dev,\r\n"Microwire duplex mode is configured incorrectly\n");\r\nreturn -EINVAL;\r\n}\r\n} else {\r\nif (chip_info->duplex != SSP_MICROWIRE_CHANNEL_FULL_DUPLEX)\r\ndev_err(&pl022->adev->dev,\r\n"Microwire half duplex mode requested,"\r\n" but this is only available in the"\r\n" ST version of PL022\n");\r\nreturn -EINVAL;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic inline u32 spi_rate(u32 rate, u16 cpsdvsr, u16 scr)\r\n{\r\nreturn rate / (cpsdvsr * (1 + scr));\r\n}\r\nstatic int calculate_effective_freq(struct pl022 *pl022, int freq, struct\r\nssp_clock_params * clk_freq)\r\n{\r\nu16 cpsdvsr = CPSDVR_MIN, scr = SCR_MIN;\r\nu32 rate, max_tclk, min_tclk, best_freq = 0, best_cpsdvsr = 0,\r\nbest_scr = 0, tmp, found = 0;\r\nrate = clk_get_rate(pl022->clk);\r\nmax_tclk = spi_rate(rate, CPSDVR_MIN, SCR_MIN);\r\nmin_tclk = spi_rate(rate, CPSDVR_MAX, SCR_MAX);\r\nif (freq > max_tclk)\r\ndev_warn(&pl022->adev->dev,\r\n"Max speed that can be programmed is %d Hz, you requested %d\n",\r\nmax_tclk, freq);\r\nif (freq < min_tclk) {\r\ndev_err(&pl022->adev->dev,\r\n"Requested frequency: %d Hz is less than minimum possible %d Hz\n",\r\nfreq, min_tclk);\r\nreturn -EINVAL;\r\n}\r\nwhile ((cpsdvsr <= CPSDVR_MAX) && !found) {\r\nwhile (scr <= SCR_MAX) {\r\ntmp = spi_rate(rate, cpsdvsr, scr);\r\nif (tmp > freq) {\r\nscr++;\r\ncontinue;\r\n}\r\nif (tmp > best_freq) {\r\nbest_freq = tmp;\r\nbest_cpsdvsr = cpsdvsr;\r\nbest_scr = scr;\r\nif (tmp == freq)\r\nfound = 1;\r\n}\r\nbreak;\r\n}\r\ncpsdvsr += 2;\r\nscr = SCR_MIN;\r\n}\r\nWARN(!best_freq, "pl022: Matching cpsdvsr and scr not found for %d Hz rate \n",\r\nfreq);\r\nclk_freq->cpsdvsr = (u8) (best_cpsdvsr & 0xFF);\r\nclk_freq->scr = (u8) (best_scr & 0xFF);\r\ndev_dbg(&pl022->adev->dev,\r\n"SSP Target Frequency is: %u, Effective Frequency is %u\n",\r\nfreq, best_freq);\r\ndev_dbg(&pl022->adev->dev, "SSP cpsdvsr = %d, scr = %d\n",\r\nclk_freq->cpsdvsr, clk_freq->scr);\r\nreturn 0;\r\n}\r\nstatic int pl022_setup(struct spi_device *spi)\r\n{\r\nstruct pl022_config_chip const *chip_info;\r\nstruct pl022_config_chip chip_info_dt;\r\nstruct chip_data *chip;\r\nstruct ssp_clock_params clk_freq = { .cpsdvsr = 0, .scr = 0};\r\nint status = 0;\r\nstruct pl022 *pl022 = spi_master_get_devdata(spi->master);\r\nunsigned int bits = spi->bits_per_word;\r\nu32 tmp;\r\nstruct device_node *np = spi->dev.of_node;\r\nif (!spi->max_speed_hz)\r\nreturn -EINVAL;\r\nchip = spi_get_ctldata(spi);\r\nif (chip == NULL) {\r\nchip = kzalloc(sizeof(struct chip_data), GFP_KERNEL);\r\nif (!chip)\r\nreturn -ENOMEM;\r\ndev_dbg(&spi->dev,\r\n"allocated memory for controller's runtime state\n");\r\n}\r\nchip_info = spi->controller_data;\r\nif (chip_info == NULL) {\r\nif (np) {\r\nchip_info_dt = pl022_default_chip_info;\r\nchip_info_dt.hierarchy = SSP_MASTER;\r\nof_property_read_u32(np, "pl022,interface",\r\n&chip_info_dt.iface);\r\nof_property_read_u32(np, "pl022,com-mode",\r\n&chip_info_dt.com_mode);\r\nof_property_read_u32(np, "pl022,rx-level-trig",\r\n&chip_info_dt.rx_lev_trig);\r\nof_property_read_u32(np, "pl022,tx-level-trig",\r\n&chip_info_dt.tx_lev_trig);\r\nof_property_read_u32(np, "pl022,ctrl-len",\r\n&chip_info_dt.ctrl_len);\r\nof_property_read_u32(np, "pl022,wait-state",\r\n&chip_info_dt.wait_state);\r\nof_property_read_u32(np, "pl022,duplex",\r\n&chip_info_dt.duplex);\r\nchip_info = &chip_info_dt;\r\n} else {\r\nchip_info = &pl022_default_chip_info;\r\ndev_dbg(&spi->dev,\r\n"using default controller_data settings\n");\r\n}\r\n} else\r\ndev_dbg(&spi->dev,\r\n"using user supplied controller_data settings\n");\r\nif ((0 == chip_info->clk_freq.cpsdvsr)\r\n&& (0 == chip_info->clk_freq.scr)) {\r\nstatus = calculate_effective_freq(pl022,\r\nspi->max_speed_hz,\r\n&clk_freq);\r\nif (status < 0)\r\ngoto err_config_params;\r\n} else {\r\nmemcpy(&clk_freq, &chip_info->clk_freq, sizeof(clk_freq));\r\nif ((clk_freq.cpsdvsr % 2) != 0)\r\nclk_freq.cpsdvsr =\r\nclk_freq.cpsdvsr - 1;\r\n}\r\nif ((clk_freq.cpsdvsr < CPSDVR_MIN)\r\n|| (clk_freq.cpsdvsr > CPSDVR_MAX)) {\r\nstatus = -EINVAL;\r\ndev_err(&spi->dev,\r\n"cpsdvsr is configured incorrectly\n");\r\ngoto err_config_params;\r\n}\r\nstatus = verify_controller_parameters(pl022, chip_info);\r\nif (status) {\r\ndev_err(&spi->dev, "controller data is incorrect");\r\ngoto err_config_params;\r\n}\r\npl022->rx_lev_trig = chip_info->rx_lev_trig;\r\npl022->tx_lev_trig = chip_info->tx_lev_trig;\r\nchip->xfer_type = chip_info->com_mode;\r\nif (!chip_info->cs_control) {\r\nchip->cs_control = null_cs_control;\r\nif (!gpio_is_valid(pl022->chipselects[spi->chip_select]))\r\ndev_warn(&spi->dev,\r\n"invalid chip select\n");\r\n} else\r\nchip->cs_control = chip_info->cs_control;\r\nif ((bits <= 3) || (bits > pl022->vendor->max_bpw)) {\r\nstatus = -ENOTSUPP;\r\ndev_err(&spi->dev, "illegal data size for this controller!\n");\r\ndev_err(&spi->dev, "This controller can only handle 4 <= n <= %d bit words\n",\r\npl022->vendor->max_bpw);\r\ngoto err_config_params;\r\n} else if (bits <= 8) {\r\ndev_dbg(&spi->dev, "4 <= n <=8 bits per word\n");\r\nchip->n_bytes = 1;\r\nchip->read = READING_U8;\r\nchip->write = WRITING_U8;\r\n} else if (bits <= 16) {\r\ndev_dbg(&spi->dev, "9 <= n <= 16 bits per word\n");\r\nchip->n_bytes = 2;\r\nchip->read = READING_U16;\r\nchip->write = WRITING_U16;\r\n} else {\r\ndev_dbg(&spi->dev, "17 <= n <= 32 bits per word\n");\r\nchip->n_bytes = 4;\r\nchip->read = READING_U32;\r\nchip->write = WRITING_U32;\r\n}\r\nchip->cr0 = 0;\r\nchip->cr1 = 0;\r\nchip->dmacr = 0;\r\nchip->cpsr = 0;\r\nif ((chip_info->com_mode == DMA_TRANSFER)\r\n&& ((pl022->master_info)->enable_dma)) {\r\nchip->enable_dma = true;\r\ndev_dbg(&spi->dev, "DMA mode set in controller state\n");\r\nSSP_WRITE_BITS(chip->dmacr, SSP_DMA_ENABLED,\r\nSSP_DMACR_MASK_RXDMAE, 0);\r\nSSP_WRITE_BITS(chip->dmacr, SSP_DMA_ENABLED,\r\nSSP_DMACR_MASK_TXDMAE, 1);\r\n} else {\r\nchip->enable_dma = false;\r\ndev_dbg(&spi->dev, "DMA mode NOT set in controller state\n");\r\nSSP_WRITE_BITS(chip->dmacr, SSP_DMA_DISABLED,\r\nSSP_DMACR_MASK_RXDMAE, 0);\r\nSSP_WRITE_BITS(chip->dmacr, SSP_DMA_DISABLED,\r\nSSP_DMACR_MASK_TXDMAE, 1);\r\n}\r\nchip->cpsr = clk_freq.cpsdvsr;\r\nif (pl022->vendor->extended_cr) {\r\nu32 etx;\r\nif (pl022->vendor->pl023) {\r\nSSP_WRITE_BITS(chip->cr1, chip_info->clkdelay,\r\nSSP_CR1_MASK_FBCLKDEL_ST, 13);\r\n} else {\r\nSSP_WRITE_BITS(chip->cr0, chip_info->duplex,\r\nSSP_CR0_MASK_HALFDUP_ST, 5);\r\nSSP_WRITE_BITS(chip->cr0, chip_info->ctrl_len,\r\nSSP_CR0_MASK_CSS_ST, 16);\r\nSSP_WRITE_BITS(chip->cr0, chip_info->iface,\r\nSSP_CR0_MASK_FRF_ST, 21);\r\nSSP_WRITE_BITS(chip->cr1, chip_info->wait_state,\r\nSSP_CR1_MASK_MWAIT_ST, 6);\r\n}\r\nSSP_WRITE_BITS(chip->cr0, bits - 1,\r\nSSP_CR0_MASK_DSS_ST, 0);\r\nif (spi->mode & SPI_LSB_FIRST) {\r\ntmp = SSP_RX_LSB;\r\netx = SSP_TX_LSB;\r\n} else {\r\ntmp = SSP_RX_MSB;\r\netx = SSP_TX_MSB;\r\n}\r\nSSP_WRITE_BITS(chip->cr1, tmp, SSP_CR1_MASK_RENDN_ST, 4);\r\nSSP_WRITE_BITS(chip->cr1, etx, SSP_CR1_MASK_TENDN_ST, 5);\r\nSSP_WRITE_BITS(chip->cr1, chip_info->rx_lev_trig,\r\nSSP_CR1_MASK_RXIFLSEL_ST, 7);\r\nSSP_WRITE_BITS(chip->cr1, chip_info->tx_lev_trig,\r\nSSP_CR1_MASK_TXIFLSEL_ST, 10);\r\n} else {\r\nSSP_WRITE_BITS(chip->cr0, bits - 1,\r\nSSP_CR0_MASK_DSS, 0);\r\nSSP_WRITE_BITS(chip->cr0, chip_info->iface,\r\nSSP_CR0_MASK_FRF, 4);\r\n}\r\nif (spi->mode & SPI_CPOL)\r\ntmp = SSP_CLK_POL_IDLE_HIGH;\r\nelse\r\ntmp = SSP_CLK_POL_IDLE_LOW;\r\nSSP_WRITE_BITS(chip->cr0, tmp, SSP_CR0_MASK_SPO, 6);\r\nif (spi->mode & SPI_CPHA)\r\ntmp = SSP_CLK_SECOND_EDGE;\r\nelse\r\ntmp = SSP_CLK_FIRST_EDGE;\r\nSSP_WRITE_BITS(chip->cr0, tmp, SSP_CR0_MASK_SPH, 7);\r\nSSP_WRITE_BITS(chip->cr0, clk_freq.scr, SSP_CR0_MASK_SCR, 8);\r\nif (pl022->vendor->loopback) {\r\nif (spi->mode & SPI_LOOP)\r\ntmp = LOOPBACK_ENABLED;\r\nelse\r\ntmp = LOOPBACK_DISABLED;\r\nSSP_WRITE_BITS(chip->cr1, tmp, SSP_CR1_MASK_LBM, 0);\r\n}\r\nSSP_WRITE_BITS(chip->cr1, SSP_DISABLED, SSP_CR1_MASK_SSE, 1);\r\nSSP_WRITE_BITS(chip->cr1, chip_info->hierarchy, SSP_CR1_MASK_MS, 2);\r\nSSP_WRITE_BITS(chip->cr1, chip_info->slave_tx_disable, SSP_CR1_MASK_SOD,\r\n3);\r\nspi_set_ctldata(spi, chip);\r\nreturn status;\r\nerr_config_params:\r\nspi_set_ctldata(spi, NULL);\r\nkfree(chip);\r\nreturn status;\r\n}\r\nstatic void pl022_cleanup(struct spi_device *spi)\r\n{\r\nstruct chip_data *chip = spi_get_ctldata(spi);\r\nspi_set_ctldata(spi, NULL);\r\nkfree(chip);\r\n}\r\nstatic struct pl022_ssp_controller *\r\npl022_platform_data_dt_get(struct device *dev)\r\n{\r\nstruct device_node *np = dev->of_node;\r\nstruct pl022_ssp_controller *pd;\r\nu32 tmp;\r\nif (!np) {\r\ndev_err(dev, "no dt node defined\n");\r\nreturn NULL;\r\n}\r\npd = devm_kzalloc(dev, sizeof(struct pl022_ssp_controller), GFP_KERNEL);\r\nif (!pd)\r\nreturn NULL;\r\npd->bus_id = -1;\r\npd->enable_dma = 1;\r\nof_property_read_u32(np, "num-cs", &tmp);\r\npd->num_chipselect = tmp;\r\nof_property_read_u32(np, "pl022,autosuspend-delay",\r\n&pd->autosuspend_delay);\r\npd->rt = of_property_read_bool(np, "pl022,rt");\r\nreturn pd;\r\n}\r\nstatic int pl022_probe(struct amba_device *adev, const struct amba_id *id)\r\n{\r\nstruct device *dev = &adev->dev;\r\nstruct pl022_ssp_controller *platform_info =\r\ndev_get_platdata(&adev->dev);\r\nstruct spi_master *master;\r\nstruct pl022 *pl022 = NULL;\r\nstruct device_node *np = adev->dev.of_node;\r\nint status = 0, i, num_cs;\r\ndev_info(&adev->dev,\r\n"ARM PL022 driver, device ID: 0x%08x\n", adev->periphid);\r\nif (!platform_info && IS_ENABLED(CONFIG_OF))\r\nplatform_info = pl022_platform_data_dt_get(dev);\r\nif (!platform_info) {\r\ndev_err(dev, "probe: no platform data defined\n");\r\nreturn -ENODEV;\r\n}\r\nif (platform_info->num_chipselect) {\r\nnum_cs = platform_info->num_chipselect;\r\n} else {\r\ndev_err(dev, "probe: no chip select defined\n");\r\nreturn -ENODEV;\r\n}\r\nmaster = spi_alloc_master(dev, sizeof(struct pl022));\r\nif (master == NULL) {\r\ndev_err(&adev->dev, "probe - cannot alloc SPI master\n");\r\nreturn -ENOMEM;\r\n}\r\npl022 = spi_master_get_devdata(master);\r\npl022->master = master;\r\npl022->master_info = platform_info;\r\npl022->adev = adev;\r\npl022->vendor = id->data;\r\npl022->chipselects = devm_kzalloc(dev, num_cs * sizeof(int),\r\nGFP_KERNEL);\r\nif (!pl022->chipselects) {\r\nstatus = -ENOMEM;\r\ngoto err_no_mem;\r\n}\r\nmaster->bus_num = platform_info->bus_id;\r\nmaster->num_chipselect = num_cs;\r\nmaster->cleanup = pl022_cleanup;\r\nmaster->setup = pl022_setup;\r\nmaster->auto_runtime_pm = true;\r\nmaster->transfer_one_message = pl022_transfer_one_message;\r\nmaster->unprepare_transfer_hardware = pl022_unprepare_transfer_hardware;\r\nmaster->rt = platform_info->rt;\r\nmaster->dev.of_node = dev->of_node;\r\nif (platform_info->num_chipselect && platform_info->chipselects) {\r\nfor (i = 0; i < num_cs; i++)\r\npl022->chipselects[i] = platform_info->chipselects[i];\r\n} else if (pl022->vendor->internal_cs_ctrl) {\r\nfor (i = 0; i < num_cs; i++)\r\npl022->chipselects[i] = i;\r\n} else if (IS_ENABLED(CONFIG_OF)) {\r\nfor (i = 0; i < num_cs; i++) {\r\nint cs_gpio = of_get_named_gpio(np, "cs-gpios", i);\r\nif (cs_gpio == -EPROBE_DEFER) {\r\nstatus = -EPROBE_DEFER;\r\ngoto err_no_gpio;\r\n}\r\npl022->chipselects[i] = cs_gpio;\r\nif (gpio_is_valid(cs_gpio)) {\r\nif (devm_gpio_request(dev, cs_gpio, "ssp-pl022"))\r\ndev_err(&adev->dev,\r\n"could not request %d gpio\n",\r\ncs_gpio);\r\nelse if (gpio_direction_output(cs_gpio, 1))\r\ndev_err(&adev->dev,\r\n"could not set gpio %d as output\n",\r\ncs_gpio);\r\n}\r\n}\r\n}\r\nmaster->mode_bits = SPI_CPOL | SPI_CPHA | SPI_CS_HIGH | SPI_LOOP;\r\nif (pl022->vendor->extended_cr)\r\nmaster->mode_bits |= SPI_LSB_FIRST;\r\ndev_dbg(&adev->dev, "BUSNO: %d\n", master->bus_num);\r\nstatus = amba_request_regions(adev, NULL);\r\nif (status)\r\ngoto err_no_ioregion;\r\npl022->phybase = adev->res.start;\r\npl022->virtbase = devm_ioremap(dev, adev->res.start,\r\nresource_size(&adev->res));\r\nif (pl022->virtbase == NULL) {\r\nstatus = -ENOMEM;\r\ngoto err_no_ioremap;\r\n}\r\ndev_info(&adev->dev, "mapped registers from %pa to %p\n",\r\n&adev->res.start, pl022->virtbase);\r\npl022->clk = devm_clk_get(&adev->dev, NULL);\r\nif (IS_ERR(pl022->clk)) {\r\nstatus = PTR_ERR(pl022->clk);\r\ndev_err(&adev->dev, "could not retrieve SSP/SPI bus clock\n");\r\ngoto err_no_clk;\r\n}\r\nstatus = clk_prepare_enable(pl022->clk);\r\nif (status) {\r\ndev_err(&adev->dev, "could not enable SSP/SPI bus clock\n");\r\ngoto err_no_clk_en;\r\n}\r\ntasklet_init(&pl022->pump_transfers, pump_transfers,\r\n(unsigned long)pl022);\r\nwritew((readw(SSP_CR1(pl022->virtbase)) & (~SSP_CR1_MASK_SSE)),\r\nSSP_CR1(pl022->virtbase));\r\nload_ssp_default_config(pl022);\r\nstatus = devm_request_irq(dev, adev->irq[0], pl022_interrupt_handler,\r\n0, "pl022", pl022);\r\nif (status < 0) {\r\ndev_err(&adev->dev, "probe - cannot get IRQ (%d)\n", status);\r\ngoto err_no_irq;\r\n}\r\nstatus = pl022_dma_autoprobe(pl022);\r\nif (status == -EPROBE_DEFER) {\r\ndev_dbg(dev, "deferring probe to get DMA channel\n");\r\ngoto err_no_irq;\r\n}\r\nif (status == 0)\r\nplatform_info->enable_dma = 1;\r\nelse if (platform_info->enable_dma) {\r\nstatus = pl022_dma_probe(pl022);\r\nif (status != 0)\r\nplatform_info->enable_dma = 0;\r\n}\r\namba_set_drvdata(adev, pl022);\r\nstatus = devm_spi_register_master(&adev->dev, master);\r\nif (status != 0) {\r\ndev_err(&adev->dev,\r\n"probe - problem registering spi master\n");\r\ngoto err_spi_register;\r\n}\r\ndev_dbg(dev, "probe succeeded\n");\r\nif (platform_info->autosuspend_delay > 0) {\r\ndev_info(&adev->dev,\r\n"will use autosuspend for runtime pm, delay %dms\n",\r\nplatform_info->autosuspend_delay);\r\npm_runtime_set_autosuspend_delay(dev,\r\nplatform_info->autosuspend_delay);\r\npm_runtime_use_autosuspend(dev);\r\n}\r\npm_runtime_put(dev);\r\nreturn 0;\r\nerr_spi_register:\r\nif (platform_info->enable_dma)\r\npl022_dma_remove(pl022);\r\nerr_no_irq:\r\nclk_disable_unprepare(pl022->clk);\r\nerr_no_clk_en:\r\nerr_no_clk:\r\nerr_no_ioremap:\r\namba_release_regions(adev);\r\nerr_no_ioregion:\r\nerr_no_gpio:\r\nerr_no_mem:\r\nspi_master_put(master);\r\nreturn status;\r\n}\r\nstatic int\r\npl022_remove(struct amba_device *adev)\r\n{\r\nstruct pl022 *pl022 = amba_get_drvdata(adev);\r\nif (!pl022)\r\nreturn 0;\r\npm_runtime_get_noresume(&adev->dev);\r\nload_ssp_default_config(pl022);\r\nif (pl022->master_info->enable_dma)\r\npl022_dma_remove(pl022);\r\nclk_disable_unprepare(pl022->clk);\r\namba_release_regions(adev);\r\ntasklet_disable(&pl022->pump_transfers);\r\nreturn 0;\r\n}\r\nstatic int pl022_suspend(struct device *dev)\r\n{\r\nstruct pl022 *pl022 = dev_get_drvdata(dev);\r\nint ret;\r\nret = spi_master_suspend(pl022->master);\r\nif (ret) {\r\ndev_warn(dev, "cannot suspend master\n");\r\nreturn ret;\r\n}\r\nret = pm_runtime_force_suspend(dev);\r\nif (ret) {\r\nspi_master_resume(pl022->master);\r\nreturn ret;\r\n}\r\npinctrl_pm_select_sleep_state(dev);\r\ndev_dbg(dev, "suspended\n");\r\nreturn 0;\r\n}\r\nstatic int pl022_resume(struct device *dev)\r\n{\r\nstruct pl022 *pl022 = dev_get_drvdata(dev);\r\nint ret;\r\nret = pm_runtime_force_resume(dev);\r\nif (ret)\r\ndev_err(dev, "problem resuming\n");\r\nret = spi_master_resume(pl022->master);\r\nif (ret)\r\ndev_err(dev, "problem starting queue (%d)\n", ret);\r\nelse\r\ndev_dbg(dev, "resumed\n");\r\nreturn ret;\r\n}\r\nstatic int pl022_runtime_suspend(struct device *dev)\r\n{\r\nstruct pl022 *pl022 = dev_get_drvdata(dev);\r\nclk_disable_unprepare(pl022->clk);\r\npinctrl_pm_select_idle_state(dev);\r\nreturn 0;\r\n}\r\nstatic int pl022_runtime_resume(struct device *dev)\r\n{\r\nstruct pl022 *pl022 = dev_get_drvdata(dev);\r\npinctrl_pm_select_default_state(dev);\r\nclk_prepare_enable(pl022->clk);\r\nreturn 0;\r\n}\r\nstatic int __init pl022_init(void)\r\n{\r\nreturn amba_driver_register(&pl022_driver);\r\n}\r\nstatic void __exit pl022_exit(void)\r\n{\r\namba_driver_unregister(&pl022_driver);\r\n}
