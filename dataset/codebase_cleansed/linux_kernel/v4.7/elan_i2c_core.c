static int elan_get_fwinfo(u8 iap_version, u16 *validpage_count,\r\nu16 *signature_address)\r\n{\r\nswitch (iap_version) {\r\ncase 0x00:\r\ncase 0x06:\r\ncase 0x08:\r\n*validpage_count = 512;\r\nbreak;\r\ncase 0x03:\r\ncase 0x07:\r\ncase 0x09:\r\ncase 0x0A:\r\ncase 0x0B:\r\ncase 0x0C:\r\n*validpage_count = 768;\r\nbreak;\r\ncase 0x0D:\r\n*validpage_count = 896;\r\nbreak;\r\ncase 0x0E:\r\n*validpage_count = 640;\r\nbreak;\r\ndefault:\r\n*validpage_count = 0;\r\n*signature_address = 0;\r\nreturn -ENXIO;\r\n}\r\n*signature_address =\r\n(*validpage_count * ETP_FW_PAGE_SIZE) - ETP_FW_SIGNATURE_SIZE;\r\nreturn 0;\r\n}\r\nstatic int elan_enable_power(struct elan_tp_data *data)\r\n{\r\nint repeat = ETP_RETRY_COUNT;\r\nint error;\r\nerror = regulator_enable(data->vcc);\r\nif (error) {\r\ndev_err(&data->client->dev,\r\n"failed to enable regulator: %d\n", error);\r\nreturn error;\r\n}\r\ndo {\r\nerror = data->ops->power_control(data->client, true);\r\nif (error >= 0)\r\nreturn 0;\r\nmsleep(30);\r\n} while (--repeat > 0);\r\ndev_err(&data->client->dev, "failed to enable power: %d\n", error);\r\nreturn error;\r\n}\r\nstatic int elan_disable_power(struct elan_tp_data *data)\r\n{\r\nint repeat = ETP_RETRY_COUNT;\r\nint error;\r\ndo {\r\nerror = data->ops->power_control(data->client, false);\r\nif (!error) {\r\nerror = regulator_disable(data->vcc);\r\nif (error) {\r\ndev_err(&data->client->dev,\r\n"failed to disable regulator: %d\n",\r\nerror);\r\ndata->ops->power_control(data->client, true);\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nmsleep(30);\r\n} while (--repeat > 0);\r\ndev_err(&data->client->dev, "failed to disable power: %d\n", error);\r\nreturn error;\r\n}\r\nstatic int elan_sleep(struct elan_tp_data *data)\r\n{\r\nint repeat = ETP_RETRY_COUNT;\r\nint error;\r\ndo {\r\nerror = data->ops->sleep_control(data->client, true);\r\nif (!error)\r\nreturn 0;\r\nmsleep(30);\r\n} while (--repeat > 0);\r\nreturn error;\r\n}\r\nstatic int __elan_initialize(struct elan_tp_data *data)\r\n{\r\nstruct i2c_client *client = data->client;\r\nint error;\r\nerror = data->ops->initialize(client);\r\nif (error) {\r\ndev_err(&client->dev, "device initialize failed: %d\n", error);\r\nreturn error;\r\n}\r\ndata->mode |= ETP_ENABLE_ABS;\r\nerror = data->ops->set_mode(client, data->mode);\r\nif (error) {\r\ndev_err(&client->dev,\r\n"failed to switch to absolute mode: %d\n", error);\r\nreturn error;\r\n}\r\nerror = data->ops->sleep_control(client, false);\r\nif (error) {\r\ndev_err(&client->dev,\r\n"failed to wake device up: %d\n", error);\r\nreturn error;\r\n}\r\nreturn 0;\r\n}\r\nstatic int elan_initialize(struct elan_tp_data *data)\r\n{\r\nint repeat = ETP_RETRY_COUNT;\r\nint error;\r\ndo {\r\nerror = __elan_initialize(data);\r\nif (!error)\r\nreturn 0;\r\nmsleep(30);\r\n} while (--repeat > 0);\r\nreturn error;\r\n}\r\nstatic int elan_query_device_info(struct elan_tp_data *data)\r\n{\r\nint error;\r\nerror = data->ops->get_product_id(data->client, &data->product_id);\r\nif (error)\r\nreturn error;\r\nerror = data->ops->get_version(data->client, false, &data->fw_version);\r\nif (error)\r\nreturn error;\r\nerror = data->ops->get_checksum(data->client, false,\r\n&data->fw_checksum);\r\nif (error)\r\nreturn error;\r\nerror = data->ops->get_sm_version(data->client, &data->ic_type,\r\n&data->sm_version);\r\nif (error)\r\nreturn error;\r\nerror = data->ops->get_version(data->client, true, &data->iap_version);\r\nif (error)\r\nreturn error;\r\nerror = data->ops->get_pressure_adjustment(data->client,\r\n&data->pressure_adjustment);\r\nif (error)\r\nreturn error;\r\nerror = elan_get_fwinfo(data->iap_version, &data->fw_validpage_count,\r\n&data->fw_signature_address);\r\nif (error)\r\ndev_warn(&data->client->dev,\r\n"unexpected iap version %#04x (ic type: %#04x), firmware update will not work\n",\r\ndata->iap_version, data->ic_type);\r\nreturn 0;\r\n}\r\nstatic unsigned int elan_convert_resolution(u8 val)\r\n{\r\nreturn ((int)(char)val * 10 + 790) * 10 / 254;\r\n}\r\nstatic int elan_query_device_parameters(struct elan_tp_data *data)\r\n{\r\nunsigned int x_traces, y_traces;\r\nu8 hw_x_res, hw_y_res;\r\nint error;\r\nerror = data->ops->get_max(data->client, &data->max_x, &data->max_y);\r\nif (error)\r\nreturn error;\r\nerror = data->ops->get_num_traces(data->client, &x_traces, &y_traces);\r\nif (error)\r\nreturn error;\r\ndata->width_x = data->max_x / x_traces;\r\ndata->width_y = data->max_y / y_traces;\r\nerror = data->ops->get_resolution(data->client, &hw_x_res, &hw_y_res);\r\nif (error)\r\nreturn error;\r\ndata->x_res = elan_convert_resolution(hw_x_res);\r\ndata->y_res = elan_convert_resolution(hw_y_res);\r\nreturn 0;\r\n}\r\nstatic int elan_write_fw_block(struct elan_tp_data *data,\r\nconst u8 *page, u16 checksum, int idx)\r\n{\r\nint retry = ETP_RETRY_COUNT;\r\nint error;\r\ndo {\r\nerror = data->ops->write_fw_block(data->client,\r\npage, checksum, idx);\r\nif (!error)\r\nreturn 0;\r\ndev_dbg(&data->client->dev,\r\n"IAP retrying page %d (error: %d)\n", idx, error);\r\n} while (--retry > 0);\r\nreturn error;\r\n}\r\nstatic int __elan_update_firmware(struct elan_tp_data *data,\r\nconst struct firmware *fw)\r\n{\r\nstruct i2c_client *client = data->client;\r\nstruct device *dev = &client->dev;\r\nint i, j;\r\nint error;\r\nu16 iap_start_addr;\r\nu16 boot_page_count;\r\nu16 sw_checksum = 0, fw_checksum = 0;\r\nerror = data->ops->prepare_fw_update(client);\r\nif (error)\r\nreturn error;\r\niap_start_addr = get_unaligned_le16(&fw->data[ETP_IAP_START_ADDR * 2]);\r\nboot_page_count = (iap_start_addr * 2) / ETP_FW_PAGE_SIZE;\r\nfor (i = boot_page_count; i < data->fw_validpage_count; i++) {\r\nu16 checksum = 0;\r\nconst u8 *page = &fw->data[i * ETP_FW_PAGE_SIZE];\r\nfor (j = 0; j < ETP_FW_PAGE_SIZE; j += 2)\r\nchecksum += ((page[j + 1] << 8) | page[j]);\r\nerror = elan_write_fw_block(data, page, checksum, i);\r\nif (error) {\r\ndev_err(dev, "write page %d fail: %d\n", i, error);\r\nreturn error;\r\n}\r\nsw_checksum += checksum;\r\n}\r\nmsleep(600);\r\nerror = data->ops->finish_fw_update(client, &data->fw_completion);\r\nif (error)\r\nreturn error;\r\nerror = data->ops->get_checksum(client, true, &fw_checksum);\r\nif (error)\r\nreturn error;\r\nif (sw_checksum != fw_checksum) {\r\ndev_err(dev, "checksum diff sw=[%04X], fw=[%04X]\n",\r\nsw_checksum, fw_checksum);\r\nreturn -EIO;\r\n}\r\nreturn 0;\r\n}\r\nstatic int elan_update_firmware(struct elan_tp_data *data,\r\nconst struct firmware *fw)\r\n{\r\nstruct i2c_client *client = data->client;\r\nint retval;\r\ndev_dbg(&client->dev, "Starting firmware update....\n");\r\ndisable_irq(client->irq);\r\ndata->in_fw_update = true;\r\nretval = __elan_update_firmware(data, fw);\r\nif (retval) {\r\ndev_err(&client->dev, "firmware update failed: %d\n", retval);\r\ndata->ops->iap_reset(client);\r\n} else {\r\nelan_initialize(data);\r\nelan_query_device_info(data);\r\n}\r\ndata->in_fw_update = false;\r\nenable_irq(client->irq);\r\nreturn retval;\r\n}\r\nstatic ssize_t elan_sysfs_read_fw_checksum(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nstruct elan_tp_data *data = i2c_get_clientdata(client);\r\nreturn sprintf(buf, "0x%04x\n", data->fw_checksum);\r\n}\r\nstatic ssize_t elan_sysfs_read_product_id(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nstruct elan_tp_data *data = i2c_get_clientdata(client);\r\nreturn sprintf(buf, ETP_PRODUCT_ID_FORMAT_STRING "\n",\r\ndata->product_id);\r\n}\r\nstatic ssize_t elan_sysfs_read_fw_ver(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nstruct elan_tp_data *data = i2c_get_clientdata(client);\r\nreturn sprintf(buf, "%d.0\n", data->fw_version);\r\n}\r\nstatic ssize_t elan_sysfs_read_sm_ver(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nstruct elan_tp_data *data = i2c_get_clientdata(client);\r\nreturn sprintf(buf, "%d.0\n", data->sm_version);\r\n}\r\nstatic ssize_t elan_sysfs_read_iap_ver(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nstruct elan_tp_data *data = i2c_get_clientdata(client);\r\nreturn sprintf(buf, "%d.0\n", data->iap_version);\r\n}\r\nstatic ssize_t elan_sysfs_update_fw(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct elan_tp_data *data = dev_get_drvdata(dev);\r\nconst struct firmware *fw;\r\nchar *fw_name;\r\nint error;\r\nconst u8 *fw_signature;\r\nstatic const u8 signature[] = {0xAA, 0x55, 0xCC, 0x33, 0xFF, 0xFF};\r\nif (data->fw_validpage_count == 0)\r\nreturn -EINVAL;\r\nfw_name = kasprintf(GFP_KERNEL, ETP_FW_NAME, data->product_id);\r\nif (!fw_name) {\r\ndev_err(dev, "failed to allocate memory for firmware name\n");\r\nreturn -ENOMEM;\r\n}\r\ndev_info(dev, "requesting fw '%s'\n", fw_name);\r\nerror = request_firmware(&fw, fw_name, dev);\r\nkfree(fw_name);\r\nif (error) {\r\ndev_err(dev, "failed to request firmware: %d\n", error);\r\nreturn error;\r\n}\r\nfw_signature = &fw->data[data->fw_signature_address];\r\nif (memcmp(fw_signature, signature, sizeof(signature)) != 0) {\r\ndev_err(dev, "signature mismatch (expected %*ph, got %*ph)\n",\r\n(int)sizeof(signature), signature,\r\n(int)sizeof(signature), fw_signature);\r\nerror = -EBADF;\r\ngoto out_release_fw;\r\n}\r\nerror = mutex_lock_interruptible(&data->sysfs_mutex);\r\nif (error)\r\ngoto out_release_fw;\r\nerror = elan_update_firmware(data, fw);\r\nmutex_unlock(&data->sysfs_mutex);\r\nout_release_fw:\r\nrelease_firmware(fw);\r\nreturn error ?: count;\r\n}\r\nstatic ssize_t calibrate_store(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nstruct elan_tp_data *data = i2c_get_clientdata(client);\r\nint tries = 20;\r\nint retval;\r\nint error;\r\nu8 val[3];\r\nretval = mutex_lock_interruptible(&data->sysfs_mutex);\r\nif (retval)\r\nreturn retval;\r\ndisable_irq(client->irq);\r\ndata->mode |= ETP_ENABLE_CALIBRATE;\r\nretval = data->ops->set_mode(client, data->mode);\r\nif (retval) {\r\ndev_err(dev, "failed to enable calibration mode: %d\n",\r\nretval);\r\ngoto out;\r\n}\r\nretval = data->ops->calibrate(client);\r\nif (retval) {\r\ndev_err(dev, "failed to start calibration: %d\n",\r\nretval);\r\ngoto out_disable_calibrate;\r\n}\r\nval[0] = 0xff;\r\ndo {\r\nmsleep(250);\r\nretval = data->ops->calibrate_result(client, val);\r\nif (retval)\r\ndev_err(dev, "failed to check calibration result: %d\n",\r\nretval);\r\nelse if (val[0] == 0)\r\nbreak;\r\n} while (--tries);\r\nif (tries == 0) {\r\ndev_err(dev, "failed to calibrate. Timeout.\n");\r\nretval = -ETIMEDOUT;\r\n}\r\nout_disable_calibrate:\r\ndata->mode &= ~ETP_ENABLE_CALIBRATE;\r\nerror = data->ops->set_mode(data->client, data->mode);\r\nif (error) {\r\ndev_err(dev, "failed to disable calibration mode: %d\n",\r\nerror);\r\nif (!retval)\r\nretval = error;\r\n}\r\nout:\r\nenable_irq(client->irq);\r\nmutex_unlock(&data->sysfs_mutex);\r\nreturn retval ?: count;\r\n}\r\nstatic ssize_t elan_sysfs_read_mode(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nstruct elan_tp_data *data = i2c_get_clientdata(client);\r\nint error;\r\nenum tp_mode mode;\r\nerror = mutex_lock_interruptible(&data->sysfs_mutex);\r\nif (error)\r\nreturn error;\r\nerror = data->ops->iap_get_mode(data->client, &mode);\r\nmutex_unlock(&data->sysfs_mutex);\r\nif (error)\r\nreturn error;\r\nreturn sprintf(buf, "%d\n", (int)mode);\r\n}\r\nstatic ssize_t acquire_store(struct device *dev, struct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nstruct elan_tp_data *data = i2c_get_clientdata(client);\r\nint error;\r\nint retval;\r\nretval = mutex_lock_interruptible(&data->sysfs_mutex);\r\nif (retval)\r\nreturn retval;\r\ndisable_irq(client->irq);\r\ndata->baseline_ready = false;\r\ndata->mode |= ETP_ENABLE_CALIBRATE;\r\nretval = data->ops->set_mode(data->client, data->mode);\r\nif (retval) {\r\ndev_err(dev, "Failed to enable calibration mode to get baseline: %d\n",\r\nretval);\r\ngoto out;\r\n}\r\nmsleep(250);\r\nretval = data->ops->get_baseline_data(data->client, true,\r\n&data->max_baseline);\r\nif (retval) {\r\ndev_err(dev, "Failed to read max baseline form device: %d\n",\r\nretval);\r\ngoto out_disable_calibrate;\r\n}\r\nretval = data->ops->get_baseline_data(data->client, false,\r\n&data->min_baseline);\r\nif (retval) {\r\ndev_err(dev, "Failed to read min baseline form device: %d\n",\r\nretval);\r\ngoto out_disable_calibrate;\r\n}\r\ndata->baseline_ready = true;\r\nout_disable_calibrate:\r\ndata->mode &= ~ETP_ENABLE_CALIBRATE;\r\nerror = data->ops->set_mode(data->client, data->mode);\r\nif (error) {\r\ndev_err(dev, "Failed to disable calibration mode after acquiring baseline: %d\n",\r\nerror);\r\nif (!retval)\r\nretval = error;\r\n}\r\nout:\r\nenable_irq(client->irq);\r\nmutex_unlock(&data->sysfs_mutex);\r\nreturn retval ?: count;\r\n}\r\nstatic ssize_t min_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nstruct elan_tp_data *data = i2c_get_clientdata(client);\r\nint retval;\r\nretval = mutex_lock_interruptible(&data->sysfs_mutex);\r\nif (retval)\r\nreturn retval;\r\nif (!data->baseline_ready) {\r\nretval = -ENODATA;\r\ngoto out;\r\n}\r\nretval = snprintf(buf, PAGE_SIZE, "%d", data->min_baseline);\r\nout:\r\nmutex_unlock(&data->sysfs_mutex);\r\nreturn retval;\r\n}\r\nstatic ssize_t max_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nstruct elan_tp_data *data = i2c_get_clientdata(client);\r\nint retval;\r\nretval = mutex_lock_interruptible(&data->sysfs_mutex);\r\nif (retval)\r\nreturn retval;\r\nif (!data->baseline_ready) {\r\nretval = -ENODATA;\r\ngoto out;\r\n}\r\nretval = snprintf(buf, PAGE_SIZE, "%d", data->max_baseline);\r\nout:\r\nmutex_unlock(&data->sysfs_mutex);\r\nreturn retval;\r\n}\r\nstatic void elan_report_contact(struct elan_tp_data *data,\r\nint contact_num, bool contact_valid,\r\nu8 *finger_data)\r\n{\r\nstruct input_dev *input = data->input;\r\nunsigned int pos_x, pos_y;\r\nunsigned int pressure, mk_x, mk_y;\r\nunsigned int area_x, area_y, major, minor;\r\nunsigned int scaled_pressure;\r\nif (contact_valid) {\r\npos_x = ((finger_data[0] & 0xf0) << 4) |\r\nfinger_data[1];\r\npos_y = ((finger_data[0] & 0x0f) << 8) |\r\nfinger_data[2];\r\nmk_x = (finger_data[3] & 0x0f);\r\nmk_y = (finger_data[3] >> 4);\r\npressure = finger_data[4];\r\nif (pos_x > data->max_x || pos_y > data->max_y) {\r\ndev_dbg(input->dev.parent,\r\n"[%d] x=%d y=%d over max (%d, %d)",\r\ncontact_num, pos_x, pos_y,\r\ndata->max_x, data->max_y);\r\nreturn;\r\n}\r\narea_x = mk_x * (data->width_x - ETP_FWIDTH_REDUCE);\r\narea_y = mk_y * (data->width_y - ETP_FWIDTH_REDUCE);\r\nmajor = max(area_x, area_y);\r\nminor = min(area_x, area_y);\r\nscaled_pressure = pressure + data->pressure_adjustment;\r\nif (scaled_pressure > ETP_MAX_PRESSURE)\r\nscaled_pressure = ETP_MAX_PRESSURE;\r\ninput_mt_slot(input, contact_num);\r\ninput_mt_report_slot_state(input, MT_TOOL_FINGER, true);\r\ninput_report_abs(input, ABS_MT_POSITION_X, pos_x);\r\ninput_report_abs(input, ABS_MT_POSITION_Y, data->max_y - pos_y);\r\ninput_report_abs(input, ABS_MT_PRESSURE, scaled_pressure);\r\ninput_report_abs(input, ABS_TOOL_WIDTH, mk_x);\r\ninput_report_abs(input, ABS_MT_TOUCH_MAJOR, major);\r\ninput_report_abs(input, ABS_MT_TOUCH_MINOR, minor);\r\n} else {\r\ninput_mt_slot(input, contact_num);\r\ninput_mt_report_slot_state(input, MT_TOOL_FINGER, false);\r\n}\r\n}\r\nstatic void elan_report_absolute(struct elan_tp_data *data, u8 *packet)\r\n{\r\nstruct input_dev *input = data->input;\r\nu8 *finger_data = &packet[ETP_FINGER_DATA_OFFSET];\r\nint i;\r\nu8 tp_info = packet[ETP_TOUCH_INFO_OFFSET];\r\nu8 hover_info = packet[ETP_HOVER_INFO_OFFSET];\r\nbool contact_valid, hover_event;\r\nhover_event = hover_info & 0x40;\r\nfor (i = 0; i < ETP_MAX_FINGERS; i++) {\r\ncontact_valid = tp_info & (1U << (3 + i));\r\nelan_report_contact(data, i, contact_valid, finger_data);\r\nif (contact_valid)\r\nfinger_data += ETP_FINGER_DATA_LEN;\r\n}\r\ninput_report_key(input, BTN_LEFT, tp_info & 0x01);\r\ninput_report_abs(input, ABS_DISTANCE, hover_event != 0);\r\ninput_mt_report_pointer_emulation(input, true);\r\ninput_sync(input);\r\n}\r\nstatic irqreturn_t elan_isr(int irq, void *dev_id)\r\n{\r\nstruct elan_tp_data *data = dev_id;\r\nstruct device *dev = &data->client->dev;\r\nint error;\r\nu8 report[ETP_MAX_REPORT_LEN];\r\nif (data->in_fw_update) {\r\ncomplete(&data->fw_completion);\r\ngoto out;\r\n}\r\nerror = data->ops->get_report(data->client, report);\r\nif (error)\r\ngoto out;\r\nif (report[ETP_REPORT_ID_OFFSET] != ETP_REPORT_ID)\r\ndev_err(dev, "invalid report id data (%x)\n",\r\nreport[ETP_REPORT_ID_OFFSET]);\r\nelse\r\nelan_report_absolute(data, report);\r\nout:\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int elan_setup_input_device(struct elan_tp_data *data)\r\n{\r\nstruct device *dev = &data->client->dev;\r\nstruct input_dev *input;\r\nunsigned int max_width = max(data->width_x, data->width_y);\r\nunsigned int min_width = min(data->width_x, data->width_y);\r\nint error;\r\ninput = devm_input_allocate_device(dev);\r\nif (!input)\r\nreturn -ENOMEM;\r\ninput->name = "Elan Touchpad";\r\ninput->id.bustype = BUS_I2C;\r\ninput->id.vendor = ELAN_VENDOR_ID;\r\ninput->id.product = data->product_id;\r\ninput_set_drvdata(input, data);\r\nerror = input_mt_init_slots(input, ETP_MAX_FINGERS,\r\nINPUT_MT_POINTER | INPUT_MT_DROP_UNUSED);\r\nif (error) {\r\ndev_err(dev, "failed to initialize MT slots: %d\n", error);\r\nreturn error;\r\n}\r\n__set_bit(EV_ABS, input->evbit);\r\n__set_bit(INPUT_PROP_POINTER, input->propbit);\r\n__set_bit(INPUT_PROP_BUTTONPAD, input->propbit);\r\n__set_bit(BTN_LEFT, input->keybit);\r\ninput_set_abs_params(input, ABS_X, 0, data->max_x, 0, 0);\r\ninput_set_abs_params(input, ABS_Y, 0, data->max_y, 0, 0);\r\ninput_abs_set_res(input, ABS_X, data->x_res);\r\ninput_abs_set_res(input, ABS_Y, data->y_res);\r\ninput_set_abs_params(input, ABS_PRESSURE, 0, ETP_MAX_PRESSURE, 0, 0);\r\ninput_set_abs_params(input, ABS_TOOL_WIDTH, 0, ETP_FINGER_WIDTH, 0, 0);\r\ninput_set_abs_params(input, ABS_DISTANCE, 0, 1, 0, 0);\r\ninput_set_abs_params(input, ABS_MT_POSITION_X, 0, data->max_x, 0, 0);\r\ninput_set_abs_params(input, ABS_MT_POSITION_Y, 0, data->max_y, 0, 0);\r\ninput_abs_set_res(input, ABS_MT_POSITION_X, data->x_res);\r\ninput_abs_set_res(input, ABS_MT_POSITION_Y, data->y_res);\r\ninput_set_abs_params(input, ABS_MT_PRESSURE, 0,\r\nETP_MAX_PRESSURE, 0, 0);\r\ninput_set_abs_params(input, ABS_MT_TOUCH_MAJOR, 0,\r\nETP_FINGER_WIDTH * max_width, 0, 0);\r\ninput_set_abs_params(input, ABS_MT_TOUCH_MINOR, 0,\r\nETP_FINGER_WIDTH * min_width, 0, 0);\r\ndata->input = input;\r\nreturn 0;\r\n}\r\nstatic void elan_disable_regulator(void *_data)\r\n{\r\nstruct elan_tp_data *data = _data;\r\nregulator_disable(data->vcc);\r\n}\r\nstatic void elan_remove_sysfs_groups(void *_data)\r\n{\r\nstruct elan_tp_data *data = _data;\r\nsysfs_remove_groups(&data->client->dev.kobj, elan_sysfs_groups);\r\n}\r\nstatic int elan_probe(struct i2c_client *client,\r\nconst struct i2c_device_id *dev_id)\r\n{\r\nconst struct elan_transport_ops *transport_ops;\r\nstruct device *dev = &client->dev;\r\nstruct elan_tp_data *data;\r\nunsigned long irqflags;\r\nint error;\r\nif (IS_ENABLED(CONFIG_MOUSE_ELAN_I2C_I2C) &&\r\ni2c_check_functionality(client->adapter, I2C_FUNC_I2C)) {\r\ntransport_ops = &elan_i2c_ops;\r\n} else if (IS_ENABLED(CONFIG_MOUSE_ELAN_I2C_SMBUS) &&\r\ni2c_check_functionality(client->adapter,\r\nI2C_FUNC_SMBUS_BYTE_DATA |\r\nI2C_FUNC_SMBUS_BLOCK_DATA |\r\nI2C_FUNC_SMBUS_I2C_BLOCK)) {\r\ntransport_ops = &elan_smbus_ops;\r\n} else {\r\ndev_err(dev, "not a supported I2C/SMBus adapter\n");\r\nreturn -EIO;\r\n}\r\ndata = devm_kzalloc(&client->dev, sizeof(struct elan_tp_data),\r\nGFP_KERNEL);\r\nif (!data)\r\nreturn -ENOMEM;\r\ni2c_set_clientdata(client, data);\r\ndata->ops = transport_ops;\r\ndata->client = client;\r\ninit_completion(&data->fw_completion);\r\nmutex_init(&data->sysfs_mutex);\r\ndata->vcc = devm_regulator_get(&client->dev, "vcc");\r\nif (IS_ERR(data->vcc)) {\r\nerror = PTR_ERR(data->vcc);\r\nif (error != -EPROBE_DEFER)\r\ndev_err(&client->dev,\r\n"Failed to get 'vcc' regulator: %d\n",\r\nerror);\r\nreturn error;\r\n}\r\nerror = regulator_enable(data->vcc);\r\nif (error) {\r\ndev_err(&client->dev,\r\n"Failed to enable regulator: %d\n", error);\r\nreturn error;\r\n}\r\nerror = devm_add_action(&client->dev,\r\nelan_disable_regulator, data);\r\nif (error) {\r\nregulator_disable(data->vcc);\r\ndev_err(&client->dev,\r\n"Failed to add disable regulator action: %d\n",\r\nerror);\r\nreturn error;\r\n}\r\nerror = elan_initialize(data);\r\nif (error)\r\nreturn error;\r\nerror = elan_query_device_info(data);\r\nif (error)\r\nreturn error;\r\nerror = elan_query_device_parameters(data);\r\nif (error)\r\nreturn error;\r\ndev_dbg(&client->dev,\r\n"Elan Touchpad Information:\n"\r\n" Module product ID: 0x%04x\n"\r\n" Firmware Version: 0x%04x\n"\r\n" Sample Version: 0x%04x\n"\r\n" IAP Version: 0x%04x\n"\r\n" Max ABS X,Y: %d,%d\n"\r\n" Width X,Y: %d,%d\n"\r\n" Resolution X,Y: %d,%d (dots/mm)\n",\r\ndata->product_id,\r\ndata->fw_version,\r\ndata->sm_version,\r\ndata->iap_version,\r\ndata->max_x, data->max_y,\r\ndata->width_x, data->width_y,\r\ndata->x_res, data->y_res);\r\nerror = elan_setup_input_device(data);\r\nif (error)\r\nreturn error;\r\nirqflags = client->dev.of_node ? 0 : IRQF_TRIGGER_FALLING;\r\nerror = devm_request_threaded_irq(&client->dev, client->irq,\r\nNULL, elan_isr,\r\nirqflags | IRQF_ONESHOT,\r\nclient->name, data);\r\nif (error) {\r\ndev_err(&client->dev, "cannot register irq=%d\n", client->irq);\r\nreturn error;\r\n}\r\nerror = sysfs_create_groups(&client->dev.kobj, elan_sysfs_groups);\r\nif (error) {\r\ndev_err(&client->dev, "failed to create sysfs attributes: %d\n",\r\nerror);\r\nreturn error;\r\n}\r\nerror = devm_add_action(&client->dev,\r\nelan_remove_sysfs_groups, data);\r\nif (error) {\r\nelan_remove_sysfs_groups(data);\r\ndev_err(&client->dev,\r\n"Failed to add sysfs cleanup action: %d\n",\r\nerror);\r\nreturn error;\r\n}\r\nerror = input_register_device(data->input);\r\nif (error) {\r\ndev_err(&client->dev, "failed to register input device: %d\n",\r\nerror);\r\nreturn error;\r\n}\r\nif (!client->dev.of_node)\r\ndevice_init_wakeup(&client->dev, true);\r\nreturn 0;\r\n}\r\nstatic int __maybe_unused elan_suspend(struct device *dev)\r\n{\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nstruct elan_tp_data *data = i2c_get_clientdata(client);\r\nint ret;\r\nret = mutex_lock_interruptible(&data->sysfs_mutex);\r\nif (ret)\r\nreturn ret;\r\ndisable_irq(client->irq);\r\nif (device_may_wakeup(dev)) {\r\nret = elan_sleep(data);\r\ndata->irq_wake = (enable_irq_wake(client->irq) == 0);\r\n} else {\r\nret = elan_disable_power(data);\r\n}\r\nmutex_unlock(&data->sysfs_mutex);\r\nreturn ret;\r\n}\r\nstatic int __maybe_unused elan_resume(struct device *dev)\r\n{\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nstruct elan_tp_data *data = i2c_get_clientdata(client);\r\nint error;\r\nif (device_may_wakeup(dev) && data->irq_wake) {\r\ndisable_irq_wake(client->irq);\r\ndata->irq_wake = false;\r\n}\r\nerror = elan_enable_power(data);\r\nif (error) {\r\ndev_err(dev, "power up when resuming failed: %d\n", error);\r\ngoto err;\r\n}\r\nerror = elan_initialize(data);\r\nif (error)\r\ndev_err(dev, "initialize when resuming failed: %d\n", error);\r\nerr:\r\nenable_irq(data->client->irq);\r\nreturn error;\r\n}
