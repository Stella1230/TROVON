bool omap_connector_get_hdmi_mode(struct drm_connector *connector)\r\n{\r\nstruct omap_connector *omap_connector = to_omap_connector(connector);\r\nreturn omap_connector->hdmi_mode;\r\n}\r\nvoid copy_timings_omap_to_drm(struct drm_display_mode *mode,\r\nstruct omap_video_timings *timings)\r\n{\r\nmode->clock = timings->pixelclock / 1000;\r\nmode->hdisplay = timings->x_res;\r\nmode->hsync_start = mode->hdisplay + timings->hfp;\r\nmode->hsync_end = mode->hsync_start + timings->hsw;\r\nmode->htotal = mode->hsync_end + timings->hbp;\r\nmode->vdisplay = timings->y_res;\r\nmode->vsync_start = mode->vdisplay + timings->vfp;\r\nmode->vsync_end = mode->vsync_start + timings->vsw;\r\nmode->vtotal = mode->vsync_end + timings->vbp;\r\nmode->flags = 0;\r\nif (timings->interlace)\r\nmode->flags |= DRM_MODE_FLAG_INTERLACE;\r\nif (timings->double_pixel)\r\nmode->flags |= DRM_MODE_FLAG_DBLCLK;\r\nif (timings->hsync_level == OMAPDSS_SIG_ACTIVE_HIGH)\r\nmode->flags |= DRM_MODE_FLAG_PHSYNC;\r\nelse\r\nmode->flags |= DRM_MODE_FLAG_NHSYNC;\r\nif (timings->vsync_level == OMAPDSS_SIG_ACTIVE_HIGH)\r\nmode->flags |= DRM_MODE_FLAG_PVSYNC;\r\nelse\r\nmode->flags |= DRM_MODE_FLAG_NVSYNC;\r\n}\r\nvoid copy_timings_drm_to_omap(struct omap_video_timings *timings,\r\nstruct drm_display_mode *mode)\r\n{\r\ntimings->pixelclock = mode->clock * 1000;\r\ntimings->x_res = mode->hdisplay;\r\ntimings->hfp = mode->hsync_start - mode->hdisplay;\r\ntimings->hsw = mode->hsync_end - mode->hsync_start;\r\ntimings->hbp = mode->htotal - mode->hsync_end;\r\ntimings->y_res = mode->vdisplay;\r\ntimings->vfp = mode->vsync_start - mode->vdisplay;\r\ntimings->vsw = mode->vsync_end - mode->vsync_start;\r\ntimings->vbp = mode->vtotal - mode->vsync_end;\r\ntimings->interlace = !!(mode->flags & DRM_MODE_FLAG_INTERLACE);\r\ntimings->double_pixel = !!(mode->flags & DRM_MODE_FLAG_DBLCLK);\r\nif (mode->flags & DRM_MODE_FLAG_PHSYNC)\r\ntimings->hsync_level = OMAPDSS_SIG_ACTIVE_HIGH;\r\nelse\r\ntimings->hsync_level = OMAPDSS_SIG_ACTIVE_LOW;\r\nif (mode->flags & DRM_MODE_FLAG_PVSYNC)\r\ntimings->vsync_level = OMAPDSS_SIG_ACTIVE_HIGH;\r\nelse\r\ntimings->vsync_level = OMAPDSS_SIG_ACTIVE_LOW;\r\ntimings->data_pclk_edge = OMAPDSS_DRIVE_SIG_RISING_EDGE;\r\ntimings->de_level = OMAPDSS_SIG_ACTIVE_HIGH;\r\ntimings->sync_pclk_edge = OMAPDSS_DRIVE_SIG_FALLING_EDGE;\r\n}\r\nstatic enum drm_connector_status omap_connector_detect(\r\nstruct drm_connector *connector, bool force)\r\n{\r\nstruct omap_connector *omap_connector = to_omap_connector(connector);\r\nstruct omap_dss_device *dssdev = omap_connector->dssdev;\r\nstruct omap_dss_driver *dssdrv = dssdev->driver;\r\nenum drm_connector_status ret;\r\nif (dssdrv->detect) {\r\nif (dssdrv->detect(dssdev))\r\nret = connector_status_connected;\r\nelse\r\nret = connector_status_disconnected;\r\n} else if (dssdev->type == OMAP_DISPLAY_TYPE_DPI ||\r\ndssdev->type == OMAP_DISPLAY_TYPE_DBI ||\r\ndssdev->type == OMAP_DISPLAY_TYPE_SDI ||\r\ndssdev->type == OMAP_DISPLAY_TYPE_DSI) {\r\nret = connector_status_connected;\r\n} else {\r\nret = connector_status_unknown;\r\n}\r\nVERB("%s: %d (force=%d)", omap_connector->dssdev->name, ret, force);\r\nreturn ret;\r\n}\r\nstatic void omap_connector_destroy(struct drm_connector *connector)\r\n{\r\nstruct omap_connector *omap_connector = to_omap_connector(connector);\r\nstruct omap_dss_device *dssdev = omap_connector->dssdev;\r\nDBG("%s", omap_connector->dssdev->name);\r\ndrm_connector_unregister(connector);\r\ndrm_connector_cleanup(connector);\r\nkfree(omap_connector);\r\nomap_dss_put_device(dssdev);\r\n}\r\nstatic int omap_connector_get_modes(struct drm_connector *connector)\r\n{\r\nstruct omap_connector *omap_connector = to_omap_connector(connector);\r\nstruct omap_dss_device *dssdev = omap_connector->dssdev;\r\nstruct omap_dss_driver *dssdrv = dssdev->driver;\r\nstruct drm_device *dev = connector->dev;\r\nint n = 0;\r\nDBG("%s", omap_connector->dssdev->name);\r\nif (dssdrv->read_edid) {\r\nvoid *edid = kzalloc(MAX_EDID, GFP_KERNEL);\r\nif ((dssdrv->read_edid(dssdev, edid, MAX_EDID) > 0) &&\r\ndrm_edid_is_valid(edid)) {\r\ndrm_mode_connector_update_edid_property(\r\nconnector, edid);\r\nn = drm_add_edid_modes(connector, edid);\r\nomap_connector->hdmi_mode =\r\ndrm_detect_hdmi_monitor(edid);\r\n} else {\r\ndrm_mode_connector_update_edid_property(\r\nconnector, NULL);\r\n}\r\nkfree(edid);\r\n} else {\r\nstruct drm_display_mode *mode = drm_mode_create(dev);\r\nstruct omap_video_timings timings = {0};\r\ndssdrv->get_timings(dssdev, &timings);\r\ncopy_timings_omap_to_drm(mode, &timings);\r\nmode->type = DRM_MODE_TYPE_DRIVER | DRM_MODE_TYPE_PREFERRED;\r\ndrm_mode_set_name(mode);\r\ndrm_mode_probed_add(connector, mode);\r\nn = 1;\r\n}\r\nreturn n;\r\n}\r\nstatic int omap_connector_mode_valid(struct drm_connector *connector,\r\nstruct drm_display_mode *mode)\r\n{\r\nstruct omap_connector *omap_connector = to_omap_connector(connector);\r\nstruct omap_dss_device *dssdev = omap_connector->dssdev;\r\nstruct omap_dss_driver *dssdrv = dssdev->driver;\r\nstruct omap_video_timings timings = {0};\r\nstruct drm_device *dev = connector->dev;\r\nstruct drm_display_mode *new_mode;\r\nint r, ret = MODE_BAD;\r\ncopy_timings_drm_to_omap(&timings, mode);\r\nmode->vrefresh = drm_mode_vrefresh(mode);\r\nif (dssdrv->check_timings) {\r\nr = dssdrv->check_timings(dssdev, &timings);\r\n} else {\r\nstruct omap_video_timings t = {0};\r\ndssdrv->get_timings(dssdev, &t);\r\nif (memcmp(&timings, &t, sizeof(struct omap_video_timings)))\r\nr = -EINVAL;\r\nelse\r\nr = 0;\r\n}\r\nif (!r) {\r\nnew_mode = drm_mode_duplicate(dev, mode);\r\nnew_mode->clock = timings.pixelclock / 1000;\r\nnew_mode->vrefresh = 0;\r\nif (mode->vrefresh == drm_mode_vrefresh(new_mode))\r\nret = MODE_OK;\r\ndrm_mode_destroy(dev, new_mode);\r\n}\r\nDBG("connector: mode %s: "\r\n"%d:\"%s\" %d %d %d %d %d %d %d %d %d %d 0x%x 0x%x",\r\n(ret == MODE_OK) ? "valid" : "invalid",\r\nmode->base.id, mode->name, mode->vrefresh, mode->clock,\r\nmode->hdisplay, mode->hsync_start,\r\nmode->hsync_end, mode->htotal,\r\nmode->vdisplay, mode->vsync_start,\r\nmode->vsync_end, mode->vtotal, mode->type, mode->flags);\r\nreturn ret;\r\n}\r\nstruct drm_encoder *omap_connector_attached_encoder(\r\nstruct drm_connector *connector)\r\n{\r\nstruct omap_connector *omap_connector = to_omap_connector(connector);\r\nreturn omap_connector->encoder;\r\n}\r\nstruct drm_connector *omap_connector_init(struct drm_device *dev,\r\nint connector_type, struct omap_dss_device *dssdev,\r\nstruct drm_encoder *encoder)\r\n{\r\nstruct drm_connector *connector = NULL;\r\nstruct omap_connector *omap_connector;\r\nDBG("%s", dssdev->name);\r\nomap_dss_get_device(dssdev);\r\nomap_connector = kzalloc(sizeof(struct omap_connector), GFP_KERNEL);\r\nif (!omap_connector)\r\ngoto fail;\r\nomap_connector->dssdev = dssdev;\r\nomap_connector->encoder = encoder;\r\nconnector = &omap_connector->base;\r\ndrm_connector_init(dev, connector, &omap_connector_funcs,\r\nconnector_type);\r\ndrm_connector_helper_add(connector, &omap_connector_helper_funcs);\r\n#if 0\r\nif (dssdev->caps & OMAP_DSS_DISPLAY_CAP_HPD)\r\nconnector->polled = 0;\r\nelse\r\n#endif\r\nconnector->polled = DRM_CONNECTOR_POLL_CONNECT |\r\nDRM_CONNECTOR_POLL_DISCONNECT;\r\nconnector->interlace_allowed = 1;\r\nconnector->doublescan_allowed = 0;\r\ndrm_connector_register(connector);\r\nreturn connector;\r\nfail:\r\nif (connector)\r\nomap_connector_destroy(connector);\r\nreturn NULL;\r\n}
