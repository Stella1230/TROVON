uint32_t r600_dma_get_rptr(struct radeon_device *rdev,\r\nstruct radeon_ring *ring)\r\n{\r\nu32 rptr;\r\nif (rdev->wb.enabled)\r\nrptr = rdev->wb.wb[ring->rptr_offs/4];\r\nelse\r\nrptr = RREG32(DMA_RB_RPTR);\r\nreturn (rptr & 0x3fffc) >> 2;\r\n}\r\nuint32_t r600_dma_get_wptr(struct radeon_device *rdev,\r\nstruct radeon_ring *ring)\r\n{\r\nreturn (RREG32(DMA_RB_WPTR) & 0x3fffc) >> 2;\r\n}\r\nvoid r600_dma_set_wptr(struct radeon_device *rdev,\r\nstruct radeon_ring *ring)\r\n{\r\nWREG32(DMA_RB_WPTR, (ring->wptr << 2) & 0x3fffc);\r\n}\r\nvoid r600_dma_stop(struct radeon_device *rdev)\r\n{\r\nu32 rb_cntl = RREG32(DMA_RB_CNTL);\r\nif (rdev->asic->copy.copy_ring_index == R600_RING_TYPE_DMA_INDEX)\r\nradeon_ttm_set_active_vram_size(rdev, rdev->mc.visible_vram_size);\r\nrb_cntl &= ~DMA_RB_ENABLE;\r\nWREG32(DMA_RB_CNTL, rb_cntl);\r\nrdev->ring[R600_RING_TYPE_DMA_INDEX].ready = false;\r\n}\r\nint r600_dma_resume(struct radeon_device *rdev)\r\n{\r\nstruct radeon_ring *ring = &rdev->ring[R600_RING_TYPE_DMA_INDEX];\r\nu32 rb_cntl, dma_cntl, ib_cntl;\r\nu32 rb_bufsz;\r\nint r;\r\nWREG32(DMA_SEM_INCOMPLETE_TIMER_CNTL, 0);\r\nWREG32(DMA_SEM_WAIT_FAIL_TIMER_CNTL, 0);\r\nrb_bufsz = order_base_2(ring->ring_size / 4);\r\nrb_cntl = rb_bufsz << 1;\r\n#ifdef __BIG_ENDIAN\r\nrb_cntl |= DMA_RB_SWAP_ENABLE | DMA_RPTR_WRITEBACK_SWAP_ENABLE;\r\n#endif\r\nWREG32(DMA_RB_CNTL, rb_cntl);\r\nWREG32(DMA_RB_RPTR, 0);\r\nWREG32(DMA_RB_WPTR, 0);\r\nWREG32(DMA_RB_RPTR_ADDR_HI,\r\nupper_32_bits(rdev->wb.gpu_addr + R600_WB_DMA_RPTR_OFFSET) & 0xFF);\r\nWREG32(DMA_RB_RPTR_ADDR_LO,\r\n((rdev->wb.gpu_addr + R600_WB_DMA_RPTR_OFFSET) & 0xFFFFFFFC));\r\nif (rdev->wb.enabled)\r\nrb_cntl |= DMA_RPTR_WRITEBACK_ENABLE;\r\nWREG32(DMA_RB_BASE, ring->gpu_addr >> 8);\r\nib_cntl = DMA_IB_ENABLE;\r\n#ifdef __BIG_ENDIAN\r\nib_cntl |= DMA_IB_SWAP_ENABLE;\r\n#endif\r\nWREG32(DMA_IB_CNTL, ib_cntl);\r\ndma_cntl = RREG32(DMA_CNTL);\r\ndma_cntl &= ~CTXEMPTY_INT_ENABLE;\r\nWREG32(DMA_CNTL, dma_cntl);\r\nif (rdev->family >= CHIP_RV770)\r\nWREG32(DMA_MODE, 1);\r\nring->wptr = 0;\r\nWREG32(DMA_RB_WPTR, ring->wptr << 2);\r\nWREG32(DMA_RB_CNTL, rb_cntl | DMA_RB_ENABLE);\r\nring->ready = true;\r\nr = radeon_ring_test(rdev, R600_RING_TYPE_DMA_INDEX, ring);\r\nif (r) {\r\nring->ready = false;\r\nreturn r;\r\n}\r\nif (rdev->asic->copy.copy_ring_index == R600_RING_TYPE_DMA_INDEX)\r\nradeon_ttm_set_active_vram_size(rdev, rdev->mc.real_vram_size);\r\nreturn 0;\r\n}\r\nvoid r600_dma_fini(struct radeon_device *rdev)\r\n{\r\nr600_dma_stop(rdev);\r\nradeon_ring_fini(rdev, &rdev->ring[R600_RING_TYPE_DMA_INDEX]);\r\n}\r\nbool r600_dma_is_lockup(struct radeon_device *rdev, struct radeon_ring *ring)\r\n{\r\nu32 reset_mask = r600_gpu_check_soft_reset(rdev);\r\nif (!(reset_mask & RADEON_RESET_DMA)) {\r\nradeon_ring_lockup_update(rdev, ring);\r\nreturn false;\r\n}\r\nreturn radeon_ring_test_lockup(rdev, ring);\r\n}\r\nint r600_dma_ring_test(struct radeon_device *rdev,\r\nstruct radeon_ring *ring)\r\n{\r\nunsigned i;\r\nint r;\r\nunsigned index;\r\nu32 tmp;\r\nu64 gpu_addr;\r\nif (ring->idx == R600_RING_TYPE_DMA_INDEX)\r\nindex = R600_WB_DMA_RING_TEST_OFFSET;\r\nelse\r\nindex = CAYMAN_WB_DMA1_RING_TEST_OFFSET;\r\ngpu_addr = rdev->wb.gpu_addr + index;\r\ntmp = 0xCAFEDEAD;\r\nrdev->wb.wb[index/4] = cpu_to_le32(tmp);\r\nr = radeon_ring_lock(rdev, ring, 4);\r\nif (r) {\r\nDRM_ERROR("radeon: dma failed to lock ring %d (%d).\n", ring->idx, r);\r\nreturn r;\r\n}\r\nradeon_ring_write(ring, DMA_PACKET(DMA_PACKET_WRITE, 0, 0, 1));\r\nradeon_ring_write(ring, lower_32_bits(gpu_addr));\r\nradeon_ring_write(ring, upper_32_bits(gpu_addr) & 0xff);\r\nradeon_ring_write(ring, 0xDEADBEEF);\r\nradeon_ring_unlock_commit(rdev, ring, false);\r\nfor (i = 0; i < rdev->usec_timeout; i++) {\r\ntmp = le32_to_cpu(rdev->wb.wb[index/4]);\r\nif (tmp == 0xDEADBEEF)\r\nbreak;\r\nDRM_UDELAY(1);\r\n}\r\nif (i < rdev->usec_timeout) {\r\nDRM_INFO("ring test on %d succeeded in %d usecs\n", ring->idx, i);\r\n} else {\r\nDRM_ERROR("radeon: ring %d test failed (0x%08X)\n",\r\nring->idx, tmp);\r\nr = -EINVAL;\r\n}\r\nreturn r;\r\n}\r\nvoid r600_dma_fence_ring_emit(struct radeon_device *rdev,\r\nstruct radeon_fence *fence)\r\n{\r\nstruct radeon_ring *ring = &rdev->ring[fence->ring];\r\nu64 addr = rdev->fence_drv[fence->ring].gpu_addr;\r\nradeon_ring_write(ring, DMA_PACKET(DMA_PACKET_FENCE, 0, 0, 0));\r\nradeon_ring_write(ring, addr & 0xfffffffc);\r\nradeon_ring_write(ring, (upper_32_bits(addr) & 0xff));\r\nradeon_ring_write(ring, lower_32_bits(fence->seq));\r\nradeon_ring_write(ring, DMA_PACKET(DMA_PACKET_TRAP, 0, 0, 0));\r\n}\r\nbool r600_dma_semaphore_ring_emit(struct radeon_device *rdev,\r\nstruct radeon_ring *ring,\r\nstruct radeon_semaphore *semaphore,\r\nbool emit_wait)\r\n{\r\nu64 addr = semaphore->gpu_addr;\r\nu32 s = emit_wait ? 0 : 1;\r\nradeon_ring_write(ring, DMA_PACKET(DMA_PACKET_SEMAPHORE, 0, s, 0));\r\nradeon_ring_write(ring, addr & 0xfffffffc);\r\nradeon_ring_write(ring, upper_32_bits(addr) & 0xff);\r\nreturn true;\r\n}\r\nint r600_dma_ib_test(struct radeon_device *rdev, struct radeon_ring *ring)\r\n{\r\nstruct radeon_ib ib;\r\nunsigned i;\r\nunsigned index;\r\nint r;\r\nu32 tmp = 0;\r\nu64 gpu_addr;\r\nif (ring->idx == R600_RING_TYPE_DMA_INDEX)\r\nindex = R600_WB_DMA_RING_TEST_OFFSET;\r\nelse\r\nindex = CAYMAN_WB_DMA1_RING_TEST_OFFSET;\r\ngpu_addr = rdev->wb.gpu_addr + index;\r\nr = radeon_ib_get(rdev, ring->idx, &ib, NULL, 256);\r\nif (r) {\r\nDRM_ERROR("radeon: failed to get ib (%d).\n", r);\r\nreturn r;\r\n}\r\nib.ptr[0] = DMA_PACKET(DMA_PACKET_WRITE, 0, 0, 1);\r\nib.ptr[1] = lower_32_bits(gpu_addr);\r\nib.ptr[2] = upper_32_bits(gpu_addr) & 0xff;\r\nib.ptr[3] = 0xDEADBEEF;\r\nib.length_dw = 4;\r\nr = radeon_ib_schedule(rdev, &ib, NULL, false);\r\nif (r) {\r\nradeon_ib_free(rdev, &ib);\r\nDRM_ERROR("radeon: failed to schedule ib (%d).\n", r);\r\nreturn r;\r\n}\r\nr = radeon_fence_wait_timeout(ib.fence, false, usecs_to_jiffies(\r\nRADEON_USEC_IB_TEST_TIMEOUT));\r\nif (r < 0) {\r\nDRM_ERROR("radeon: fence wait failed (%d).\n", r);\r\nreturn r;\r\n} else if (r == 0) {\r\nDRM_ERROR("radeon: fence wait timed out.\n");\r\nreturn -ETIMEDOUT;\r\n}\r\nr = 0;\r\nfor (i = 0; i < rdev->usec_timeout; i++) {\r\ntmp = le32_to_cpu(rdev->wb.wb[index/4]);\r\nif (tmp == 0xDEADBEEF)\r\nbreak;\r\nDRM_UDELAY(1);\r\n}\r\nif (i < rdev->usec_timeout) {\r\nDRM_INFO("ib test on ring %d succeeded in %u usecs\n", ib.fence->ring, i);\r\n} else {\r\nDRM_ERROR("radeon: ib test failed (0x%08X)\n", tmp);\r\nr = -EINVAL;\r\n}\r\nradeon_ib_free(rdev, &ib);\r\nreturn r;\r\n}\r\nvoid r600_dma_ring_ib_execute(struct radeon_device *rdev, struct radeon_ib *ib)\r\n{\r\nstruct radeon_ring *ring = &rdev->ring[ib->ring];\r\nif (rdev->wb.enabled) {\r\nu32 next_rptr = ring->wptr + 4;\r\nwhile ((next_rptr & 7) != 5)\r\nnext_rptr++;\r\nnext_rptr += 3;\r\nradeon_ring_write(ring, DMA_PACKET(DMA_PACKET_WRITE, 0, 0, 1));\r\nradeon_ring_write(ring, ring->next_rptr_gpu_addr & 0xfffffffc);\r\nradeon_ring_write(ring, upper_32_bits(ring->next_rptr_gpu_addr) & 0xff);\r\nradeon_ring_write(ring, next_rptr);\r\n}\r\nwhile ((ring->wptr & 7) != 5)\r\nradeon_ring_write(ring, DMA_PACKET(DMA_PACKET_NOP, 0, 0, 0));\r\nradeon_ring_write(ring, DMA_PACKET(DMA_PACKET_INDIRECT_BUFFER, 0, 0, 0));\r\nradeon_ring_write(ring, (ib->gpu_addr & 0xFFFFFFE0));\r\nradeon_ring_write(ring, (ib->length_dw << 16) | (upper_32_bits(ib->gpu_addr) & 0xFF));\r\n}\r\nstruct radeon_fence *r600_copy_dma(struct radeon_device *rdev,\r\nuint64_t src_offset, uint64_t dst_offset,\r\nunsigned num_gpu_pages,\r\nstruct reservation_object *resv)\r\n{\r\nstruct radeon_fence *fence;\r\nstruct radeon_sync sync;\r\nint ring_index = rdev->asic->copy.dma_ring_index;\r\nstruct radeon_ring *ring = &rdev->ring[ring_index];\r\nu32 size_in_dw, cur_size_in_dw;\r\nint i, num_loops;\r\nint r = 0;\r\nradeon_sync_create(&sync);\r\nsize_in_dw = (num_gpu_pages << RADEON_GPU_PAGE_SHIFT) / 4;\r\nnum_loops = DIV_ROUND_UP(size_in_dw, 0xFFFE);\r\nr = radeon_ring_lock(rdev, ring, num_loops * 4 + 8);\r\nif (r) {\r\nDRM_ERROR("radeon: moving bo (%d).\n", r);\r\nradeon_sync_free(rdev, &sync, NULL);\r\nreturn ERR_PTR(r);\r\n}\r\nradeon_sync_resv(rdev, &sync, resv, false);\r\nradeon_sync_rings(rdev, &sync, ring->idx);\r\nfor (i = 0; i < num_loops; i++) {\r\ncur_size_in_dw = size_in_dw;\r\nif (cur_size_in_dw > 0xFFFE)\r\ncur_size_in_dw = 0xFFFE;\r\nsize_in_dw -= cur_size_in_dw;\r\nradeon_ring_write(ring, DMA_PACKET(DMA_PACKET_COPY, 0, 0, cur_size_in_dw));\r\nradeon_ring_write(ring, dst_offset & 0xfffffffc);\r\nradeon_ring_write(ring, src_offset & 0xfffffffc);\r\nradeon_ring_write(ring, (((upper_32_bits(dst_offset) & 0xff) << 16) |\r\n(upper_32_bits(src_offset) & 0xff)));\r\nsrc_offset += cur_size_in_dw * 4;\r\ndst_offset += cur_size_in_dw * 4;\r\n}\r\nr = radeon_fence_emit(rdev, &fence, ring->idx);\r\nif (r) {\r\nradeon_ring_unlock_undo(rdev, ring);\r\nradeon_sync_free(rdev, &sync, NULL);\r\nreturn ERR_PTR(r);\r\n}\r\nradeon_ring_unlock_commit(rdev, ring, false);\r\nradeon_sync_free(rdev, &sync, fence);\r\nreturn fence;\r\n}
