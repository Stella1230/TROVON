static unsigned __init gen_fdt_mem_array(__be32 *mem_array, unsigned long size)\r\n{\r\nunsigned long size_preio;\r\nunsigned entries;\r\nentries = 1;\r\nmem_array[0] = cpu_to_be32(PHYS_OFFSET);\r\nif (config_enabled(CONFIG_EVA)) {\r\nmem_array[1] = cpu_to_be32(size);\r\n} else {\r\nsize_preio = min_t(unsigned long, size, SZ_256M);\r\nmem_array[1] = cpu_to_be32(size_preio);\r\n}\r\nBUG_ON(entries > MAX_MEM_ARRAY_ENTRIES);\r\nreturn entries;\r\n}\r\nstatic void __init append_memory(void *fdt, int root_off)\r\n{\r\n__be32 mem_array[2 * MAX_MEM_ARRAY_ENTRIES];\r\nunsigned long memsize;\r\nunsigned mem_entries;\r\nint i, err, mem_off;\r\nchar *var, param_name[10], *var_names[] = {\r\n"ememsize", "memsize",\r\n};\r\nmem_off = fdt_path_offset(fdt, "/memory");\r\nif (mem_off >= 0)\r\nreturn;\r\nfor (i = 0; i < ARRAY_SIZE(var_names); i++) {\r\nvar = fw_getenv(var_names[i]);\r\nif (!var)\r\ncontinue;\r\nerr = kstrtoul(var, 0, &physical_memsize);\r\nif (!err)\r\nbreak;\r\npr_warn("Failed to read the '%s' env variable '%s'\n",\r\nvar_names[i], var);\r\n}\r\nif (!physical_memsize) {\r\npr_warn("The bootloader didn't provide memsize: defaulting to 32MB\n");\r\nphysical_memsize = 32 << 20;\r\n}\r\nif (config_enabled(CONFIG_CPU_BIG_ENDIAN)) {\r\nphysical_memsize -= PAGE_SIZE;\r\n}\r\nmemsize = physical_memsize;\r\nfor (i = 0; i < ARRAY_SIZE(var_names); i++) {\r\nsnprintf(param_name, sizeof(param_name), "%s=", var_names[i]);\r\nvar = strstr(arcs_cmdline, param_name);\r\nif (!var)\r\ncontinue;\r\nmemsize = memparse(var + strlen(param_name), NULL);\r\n}\r\nphysical_memsize = max_t(unsigned long, physical_memsize, memsize);\r\nmem_off = fdt_add_subnode(fdt, root_off, "memory");\r\nif (mem_off < 0)\r\npanic("Unable to add memory node to DT: %d", mem_off);\r\nerr = fdt_setprop_string(fdt, mem_off, "device_type", "memory");\r\nif (err)\r\npanic("Unable to set memory node device_type: %d", err);\r\nmem_entries = gen_fdt_mem_array(mem_array, physical_memsize);\r\nerr = fdt_setprop(fdt, mem_off, "reg", mem_array,\r\nmem_entries * 2 * sizeof(mem_array[0]));\r\nif (err)\r\npanic("Unable to set memory regs property: %d", err);\r\nmem_entries = gen_fdt_mem_array(mem_array, memsize);\r\nerr = fdt_setprop(fdt, mem_off, "linux,usable-memory", mem_array,\r\nmem_entries * 2 * sizeof(mem_array[0]));\r\nif (err)\r\npanic("Unable to set linux,usable-memory property: %d", err);\r\n}\r\nvoid __init *malta_dt_shim(void *fdt)\r\n{\r\nint root_off, len, err;\r\nconst char *compat;\r\nif (fdt_check_header(fdt))\r\npanic("Corrupt DT");\r\nerr = fdt_open_into(fdt, fdt_buf, sizeof(fdt_buf));\r\nif (err)\r\npanic("Unable to open FDT: %d", err);\r\nroot_off = fdt_path_offset(fdt_buf, "/");\r\nif (root_off < 0)\r\npanic("No / node in DT");\r\ncompat = fdt_getprop(fdt_buf, root_off, "compatible", &len);\r\nif (!compat)\r\npanic("No root compatible property in DT: %d", len);\r\nif (strncmp(compat, "mti,malta", len))\r\nreturn fdt;\r\nappend_memory(fdt_buf, root_off);\r\nerr = fdt_pack(fdt_buf);\r\nif (err)\r\npanic("Unable to pack FDT: %d\n", err);\r\nreturn fdt_buf;\r\n}
