bool should_failslab(struct kmem_cache *s, gfp_t gfpflags)\r\n{\r\nif (unlikely(s == kmem_cache))\r\nreturn false;\r\nif (gfpflags & __GFP_NOFAIL)\r\nreturn false;\r\nif (failslab.ignore_gfp_reclaim && (gfpflags & __GFP_RECLAIM))\r\nreturn false;\r\nif (failslab.cache_filter && !(s->flags & SLAB_FAILSLAB))\r\nreturn false;\r\nreturn should_fail(&failslab.attr, s->object_size);\r\n}\r\nstatic int __init setup_failslab(char *str)\r\n{\r\nreturn setup_fault_attr(&failslab.attr, str);\r\n}\r\nstatic int __init failslab_debugfs_init(void)\r\n{\r\nstruct dentry *dir;\r\numode_t mode = S_IFREG | S_IRUSR | S_IWUSR;\r\ndir = fault_create_debugfs_attr("failslab", NULL, &failslab.attr);\r\nif (IS_ERR(dir))\r\nreturn PTR_ERR(dir);\r\nif (!debugfs_create_bool("ignore-gfp-wait", mode, dir,\r\n&failslab.ignore_gfp_reclaim))\r\ngoto fail;\r\nif (!debugfs_create_bool("cache-filter", mode, dir,\r\n&failslab.cache_filter))\r\ngoto fail;\r\nreturn 0;\r\nfail:\r\ndebugfs_remove_recursive(dir);\r\nreturn -ENOMEM;\r\n}
