void adf_enable_pf2vf_interrupts(struct adf_accel_dev *accel_dev)\r\n{\r\nstruct adf_accel_pci *pci_info = &accel_dev->accel_pci_dev;\r\nstruct adf_hw_device_data *hw_data = accel_dev->hw_device;\r\nvoid __iomem *pmisc_bar_addr =\r\npci_info->pci_bars[hw_data->get_misc_bar_id(hw_data)].virt_addr;\r\nADF_CSR_WR(pmisc_bar_addr, hw_data->get_vintmsk_offset(0), 0x0);\r\n}\r\nvoid adf_disable_pf2vf_interrupts(struct adf_accel_dev *accel_dev)\r\n{\r\nstruct adf_accel_pci *pci_info = &accel_dev->accel_pci_dev;\r\nstruct adf_hw_device_data *hw_data = accel_dev->hw_device;\r\nvoid __iomem *pmisc_bar_addr =\r\npci_info->pci_bars[hw_data->get_misc_bar_id(hw_data)].virt_addr;\r\nADF_CSR_WR(pmisc_bar_addr, hw_data->get_vintmsk_offset(0), 0x2);\r\n}\r\nvoid adf_enable_vf2pf_interrupts(struct adf_accel_dev *accel_dev,\r\nu32 vf_mask)\r\n{\r\nstruct adf_hw_device_data *hw_data = accel_dev->hw_device;\r\nstruct adf_bar *pmisc =\r\n&GET_BARS(accel_dev)[hw_data->get_misc_bar_id(hw_data)];\r\nvoid __iomem *pmisc_addr = pmisc->virt_addr;\r\nu32 reg;\r\nif (vf_mask & 0xFFFF) {\r\nreg = ADF_CSR_RD(pmisc_addr, ADF_DH895XCC_ERRMSK3);\r\nreg &= ~ADF_DH895XCC_ERRMSK3_VF2PF_L_MASK(vf_mask);\r\nADF_CSR_WR(pmisc_addr, ADF_DH895XCC_ERRMSK3, reg);\r\n}\r\nif (vf_mask >> 16) {\r\nreg = ADF_CSR_RD(pmisc_addr, ADF_DH895XCC_ERRMSK5);\r\nreg &= ~ADF_DH895XCC_ERRMSK5_VF2PF_U_MASK(vf_mask);\r\nADF_CSR_WR(pmisc_addr, ADF_DH895XCC_ERRMSK5, reg);\r\n}\r\n}\r\nvoid adf_disable_vf2pf_interrupts(struct adf_accel_dev *accel_dev, u32 vf_mask)\r\n{\r\nstruct adf_hw_device_data *hw_data = accel_dev->hw_device;\r\nstruct adf_bar *pmisc =\r\n&GET_BARS(accel_dev)[hw_data->get_misc_bar_id(hw_data)];\r\nvoid __iomem *pmisc_addr = pmisc->virt_addr;\r\nu32 reg;\r\nif (vf_mask & 0xFFFF) {\r\nreg = ADF_CSR_RD(pmisc_addr, ADF_DH895XCC_ERRMSK3) |\r\nADF_DH895XCC_ERRMSK3_VF2PF_L_MASK(vf_mask);\r\nADF_CSR_WR(pmisc_addr, ADF_DH895XCC_ERRMSK3, reg);\r\n}\r\nif (vf_mask >> 16) {\r\nreg = ADF_CSR_RD(pmisc_addr, ADF_DH895XCC_ERRMSK5) |\r\nADF_DH895XCC_ERRMSK5_VF2PF_U_MASK(vf_mask);\r\nADF_CSR_WR(pmisc_addr, ADF_DH895XCC_ERRMSK5, reg);\r\n}\r\n}\r\nstatic int __adf_iov_putmsg(struct adf_accel_dev *accel_dev, u32 msg, u8 vf_nr)\r\n{\r\nstruct adf_accel_pci *pci_info = &accel_dev->accel_pci_dev;\r\nstruct adf_hw_device_data *hw_data = accel_dev->hw_device;\r\nvoid __iomem *pmisc_bar_addr =\r\npci_info->pci_bars[hw_data->get_misc_bar_id(hw_data)].virt_addr;\r\nu32 val, pf2vf_offset, count = 0;\r\nu32 local_in_use_mask, local_in_use_pattern;\r\nu32 remote_in_use_mask, remote_in_use_pattern;\r\nstruct mutex *lock;\r\nu32 int_bit;\r\nint ret = 0;\r\nif (accel_dev->is_vf) {\r\npf2vf_offset = hw_data->get_pf2vf_offset(0);\r\nlock = &accel_dev->vf.vf2pf_lock;\r\nlocal_in_use_mask = ADF_VF2PF_IN_USE_BY_VF_MASK;\r\nlocal_in_use_pattern = ADF_VF2PF_IN_USE_BY_VF;\r\nremote_in_use_mask = ADF_PF2VF_IN_USE_BY_PF_MASK;\r\nremote_in_use_pattern = ADF_PF2VF_IN_USE_BY_PF;\r\nint_bit = ADF_VF2PF_INT;\r\n} else {\r\npf2vf_offset = hw_data->get_pf2vf_offset(vf_nr);\r\nlock = &accel_dev->pf.vf_info[vf_nr].pf2vf_lock;\r\nlocal_in_use_mask = ADF_PF2VF_IN_USE_BY_PF_MASK;\r\nlocal_in_use_pattern = ADF_PF2VF_IN_USE_BY_PF;\r\nremote_in_use_mask = ADF_VF2PF_IN_USE_BY_VF_MASK;\r\nremote_in_use_pattern = ADF_VF2PF_IN_USE_BY_VF;\r\nint_bit = ADF_PF2VF_INT;\r\n}\r\nmutex_lock(lock);\r\nval = ADF_CSR_RD(pmisc_bar_addr, pf2vf_offset);\r\nif ((val & remote_in_use_mask) == remote_in_use_pattern) {\r\ndev_dbg(&GET_DEV(accel_dev),\r\n"PF2VF CSR in use by remote function\n");\r\nret = -EBUSY;\r\ngoto out;\r\n}\r\nmsg &= ~local_in_use_mask;\r\nmsg |= local_in_use_pattern;\r\nADF_CSR_WR(pmisc_bar_addr, pf2vf_offset, msg);\r\nmsleep(ADF_IOV_MSG_COLLISION_DETECT_DELAY);\r\nval = ADF_CSR_RD(pmisc_bar_addr, pf2vf_offset);\r\nif ((val & local_in_use_mask) != local_in_use_pattern) {\r\ndev_dbg(&GET_DEV(accel_dev),\r\n"PF2VF CSR in use by remote - collision detected\n");\r\nret = -EBUSY;\r\ngoto out;\r\n}\r\nADF_CSR_WR(pmisc_bar_addr, pf2vf_offset, msg | int_bit);\r\ndo {\r\nmsleep(ADF_IOV_MSG_ACK_DELAY);\r\nval = ADF_CSR_RD(pmisc_bar_addr, pf2vf_offset);\r\n} while ((val & int_bit) && (count++ < ADF_IOV_MSG_ACK_MAX_RETRY));\r\nif (val & int_bit) {\r\ndev_dbg(&GET_DEV(accel_dev), "ACK not received from remote\n");\r\nval &= ~int_bit;\r\nret = -EIO;\r\n}\r\nADF_CSR_WR(pmisc_bar_addr, pf2vf_offset, val & ~local_in_use_mask);\r\nout:\r\nmutex_unlock(lock);\r\nreturn ret;\r\n}\r\nint adf_iov_putmsg(struct adf_accel_dev *accel_dev, u32 msg, u8 vf_nr)\r\n{\r\nu32 count = 0;\r\nint ret;\r\ndo {\r\nret = __adf_iov_putmsg(accel_dev, msg, vf_nr);\r\nif (ret)\r\nmsleep(ADF_IOV_MSG_RETRY_DELAY);\r\n} while (ret && (count++ < ADF_IOV_MSG_MAX_RETRIES));\r\nreturn ret;\r\n}\r\nvoid adf_vf2pf_req_hndl(struct adf_accel_vf_info *vf_info)\r\n{\r\nstruct adf_accel_dev *accel_dev = vf_info->accel_dev;\r\nstruct adf_hw_device_data *hw_data = accel_dev->hw_device;\r\nint bar_id = hw_data->get_misc_bar_id(hw_data);\r\nstruct adf_bar *pmisc = &GET_BARS(accel_dev)[bar_id];\r\nvoid __iomem *pmisc_addr = pmisc->virt_addr;\r\nu32 msg, resp = 0, vf_nr = vf_info->vf_nr;\r\nmsg = ADF_CSR_RD(pmisc_addr, hw_data->get_pf2vf_offset(vf_nr));\r\nmsg &= ~ADF_VF2PF_INT;\r\nADF_CSR_WR(pmisc_addr, hw_data->get_pf2vf_offset(vf_nr), msg);\r\nif (!(msg & ADF_VF2PF_MSGORIGIN_SYSTEM))\r\ngoto err;\r\nswitch ((msg & ADF_VF2PF_MSGTYPE_MASK) >> ADF_VF2PF_MSGTYPE_SHIFT) {\r\ncase ADF_VF2PF_MSGTYPE_COMPAT_VER_REQ:\r\n{\r\nu8 vf_compat_ver = msg >> ADF_VF2PF_COMPAT_VER_REQ_SHIFT;\r\nresp = (ADF_PF2VF_MSGORIGIN_SYSTEM |\r\n(ADF_PF2VF_MSGTYPE_VERSION_RESP <<\r\nADF_PF2VF_MSGTYPE_SHIFT) |\r\n(ADF_PFVF_COMPATIBILITY_VERSION <<\r\nADF_PF2VF_VERSION_RESP_VERS_SHIFT));\r\ndev_dbg(&GET_DEV(accel_dev),\r\n"Compatibility Version Request from VF%d vers=%u\n",\r\nvf_nr + 1, vf_compat_ver);\r\nif (vf_compat_ver < hw_data->min_iov_compat_ver) {\r\ndev_err(&GET_DEV(accel_dev),\r\n"VF (vers %d) incompatible with PF (vers %d)\n",\r\nvf_compat_ver, ADF_PFVF_COMPATIBILITY_VERSION);\r\nresp |= ADF_PF2VF_VF_INCOMPATIBLE <<\r\nADF_PF2VF_VERSION_RESP_RESULT_SHIFT;\r\n} else if (vf_compat_ver > ADF_PFVF_COMPATIBILITY_VERSION) {\r\ndev_err(&GET_DEV(accel_dev),\r\n"VF (vers %d) compat with PF (vers %d) unkn.\n",\r\nvf_compat_ver, ADF_PFVF_COMPATIBILITY_VERSION);\r\nresp |= ADF_PF2VF_VF_COMPAT_UNKNOWN <<\r\nADF_PF2VF_VERSION_RESP_RESULT_SHIFT;\r\n} else {\r\ndev_dbg(&GET_DEV(accel_dev),\r\n"VF (vers %d) compatible with PF (vers %d)\n",\r\nvf_compat_ver, ADF_PFVF_COMPATIBILITY_VERSION);\r\nresp |= ADF_PF2VF_VF_COMPATIBLE <<\r\nADF_PF2VF_VERSION_RESP_RESULT_SHIFT;\r\n}\r\n}\r\nbreak;\r\ncase ADF_VF2PF_MSGTYPE_VERSION_REQ:\r\ndev_dbg(&GET_DEV(accel_dev),\r\n"Legacy VersionRequest received from VF%d 0x%x\n",\r\nvf_nr + 1, msg);\r\nresp = (ADF_PF2VF_MSGORIGIN_SYSTEM |\r\n(ADF_PF2VF_MSGTYPE_VERSION_RESP <<\r\nADF_PF2VF_MSGTYPE_SHIFT) |\r\n(ADF_PFVF_COMPATIBILITY_VERSION <<\r\nADF_PF2VF_VERSION_RESP_VERS_SHIFT));\r\nresp |= ADF_PF2VF_VF_COMPATIBLE <<\r\nADF_PF2VF_VERSION_RESP_RESULT_SHIFT;\r\nresp |= 1 << ADF_PF2VF_MAJORVERSION_SHIFT |\r\n1 << ADF_PF2VF_MINORVERSION_SHIFT;\r\nbreak;\r\ncase ADF_VF2PF_MSGTYPE_INIT:\r\n{\r\ndev_dbg(&GET_DEV(accel_dev),\r\n"Init message received from VF%d 0x%x\n",\r\nvf_nr + 1, msg);\r\nvf_info->init = true;\r\n}\r\nbreak;\r\ncase ADF_VF2PF_MSGTYPE_SHUTDOWN:\r\n{\r\ndev_dbg(&GET_DEV(accel_dev),\r\n"Shutdown message received from VF%d 0x%x\n",\r\nvf_nr + 1, msg);\r\nvf_info->init = false;\r\n}\r\nbreak;\r\ndefault:\r\ngoto err;\r\n}\r\nif (resp && adf_iov_putmsg(accel_dev, resp, vf_nr))\r\ndev_err(&GET_DEV(accel_dev), "Failed to send response to VF\n");\r\nadf_enable_vf2pf_interrupts(accel_dev, (1 << vf_nr));\r\nreturn;\r\nerr:\r\ndev_dbg(&GET_DEV(accel_dev), "Unknown message from VF%d (0x%x);\n",\r\nvf_nr + 1, msg);\r\n}\r\nvoid adf_pf2vf_notify_restarting(struct adf_accel_dev *accel_dev)\r\n{\r\nstruct adf_accel_vf_info *vf;\r\nu32 msg = (ADF_PF2VF_MSGORIGIN_SYSTEM |\r\n(ADF_PF2VF_MSGTYPE_RESTARTING << ADF_PF2VF_MSGTYPE_SHIFT));\r\nint i, num_vfs = pci_num_vf(accel_to_pci_dev(accel_dev));\r\nfor (i = 0, vf = accel_dev->pf.vf_info; i < num_vfs; i++, vf++) {\r\nif (vf->init && adf_iov_putmsg(accel_dev, msg, i))\r\ndev_err(&GET_DEV(accel_dev),\r\n"Failed to send restarting msg to VF%d\n", i);\r\n}\r\n}\r\nstatic int adf_vf2pf_request_version(struct adf_accel_dev *accel_dev)\r\n{\r\nunsigned long timeout = msecs_to_jiffies(ADF_IOV_MSG_RESP_TIMEOUT);\r\nstruct adf_hw_device_data *hw_data = accel_dev->hw_device;\r\nu32 msg = 0;\r\nint ret;\r\nmsg = ADF_VF2PF_MSGORIGIN_SYSTEM;\r\nmsg |= ADF_VF2PF_MSGTYPE_COMPAT_VER_REQ << ADF_VF2PF_MSGTYPE_SHIFT;\r\nmsg |= ADF_PFVF_COMPATIBILITY_VERSION << ADF_VF2PF_COMPAT_VER_REQ_SHIFT;\r\nBUILD_BUG_ON(ADF_PFVF_COMPATIBILITY_VERSION > 255);\r\nret = adf_iov_putmsg(accel_dev, msg, 0);\r\nif (ret) {\r\ndev_err(&GET_DEV(accel_dev),\r\n"Failed to send Compatibility Version Request.\n");\r\nreturn ret;\r\n}\r\nif (!wait_for_completion_timeout(&accel_dev->vf.iov_msg_completion,\r\ntimeout)) {\r\ndev_err(&GET_DEV(accel_dev),\r\n"IOV request/response message timeout expired\n");\r\nreturn -EIO;\r\n}\r\nswitch (accel_dev->vf.compatible) {\r\ncase ADF_PF2VF_VF_COMPATIBLE:\r\nbreak;\r\ncase ADF_PF2VF_VF_COMPAT_UNKNOWN:\r\nif (accel_dev->vf.pf_version >= hw_data->min_iov_compat_ver)\r\nbreak;\r\ncase ADF_PF2VF_VF_INCOMPATIBLE:\r\ndev_err(&GET_DEV(accel_dev),\r\n"PF (vers %d) and VF (vers %d) are not compatible\n",\r\naccel_dev->vf.pf_version,\r\nADF_PFVF_COMPATIBILITY_VERSION);\r\nreturn -EINVAL;\r\ndefault:\r\ndev_err(&GET_DEV(accel_dev),\r\n"Invalid response from PF; assume not compatible\n");\r\nreturn -EINVAL;\r\n}\r\nreturn ret;\r\n}\r\nint adf_enable_vf2pf_comms(struct adf_accel_dev *accel_dev)\r\n{\r\nadf_enable_pf2vf_interrupts(accel_dev);\r\nreturn adf_vf2pf_request_version(accel_dev);\r\n}
