static irqreturn_t mx25_gcq_irq(int irq, void *data)\r\n{\r\nstruct mx25_gcq_priv *priv = data;\r\nu32 stats;\r\nregmap_read(priv->regs, MX25_ADCQ_SR, &stats);\r\nif (stats & MX25_ADCQ_SR_EOQ) {\r\nregmap_update_bits(priv->regs, MX25_ADCQ_MR,\r\nMX25_ADCQ_MR_EOQ_IRQ, MX25_ADCQ_MR_EOQ_IRQ);\r\ncomplete(&priv->completed);\r\n}\r\nregmap_update_bits(priv->regs, MX25_ADCQ_CR, MX25_ADCQ_CR_FQS, 0);\r\nregmap_write(priv->regs, MX25_ADCQ_SR, MX25_ADCQ_SR_FRR |\r\nMX25_ADCQ_SR_FUR | MX25_ADCQ_SR_FOR |\r\nMX25_ADCQ_SR_EOQ | MX25_ADCQ_SR_PD);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int mx25_gcq_get_raw_value(struct device *dev,\r\nstruct iio_chan_spec const *chan,\r\nstruct mx25_gcq_priv *priv,\r\nint *val)\r\n{\r\nlong timeout;\r\nu32 data;\r\nregmap_write(priv->regs, MX25_ADCQ_ITEM_7_0,\r\nMX25_ADCQ_ITEM(0, chan->channel));\r\nregmap_update_bits(priv->regs, MX25_ADCQ_MR, MX25_ADCQ_MR_EOQ_IRQ, 0);\r\nregmap_update_bits(priv->regs, MX25_ADCQ_CR, MX25_ADCQ_CR_FQS,\r\nMX25_ADCQ_CR_FQS);\r\ntimeout = wait_for_completion_interruptible_timeout(\r\n&priv->completed, MX25_GCQ_TIMEOUT);\r\nif (timeout < 0) {\r\ndev_err(dev, "ADC wait for measurement failed\n");\r\nreturn timeout;\r\n} else if (timeout == 0) {\r\ndev_err(dev, "ADC timed out\n");\r\nreturn -ETIMEDOUT;\r\n}\r\nregmap_read(priv->regs, MX25_ADCQ_FIFO, &data);\r\n*val = MX25_ADCQ_FIFO_DATA(data);\r\nreturn IIO_VAL_INT;\r\n}\r\nstatic int mx25_gcq_read_raw(struct iio_dev *indio_dev,\r\nstruct iio_chan_spec const *chan, int *val,\r\nint *val2, long mask)\r\n{\r\nstruct mx25_gcq_priv *priv = iio_priv(indio_dev);\r\nint ret;\r\nswitch (mask) {\r\ncase IIO_CHAN_INFO_RAW:\r\nmutex_lock(&indio_dev->mlock);\r\nret = mx25_gcq_get_raw_value(&indio_dev->dev, chan, priv, val);\r\nmutex_unlock(&indio_dev->mlock);\r\nreturn ret;\r\ncase IIO_CHAN_INFO_SCALE:\r\n*val = priv->channel_vref_mv[chan->channel];\r\n*val2 = 12;\r\nreturn IIO_VAL_FRACTIONAL_LOG2;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\n}\r\nstatic int mx25_gcq_setup_cfgs(struct platform_device *pdev,\r\nstruct mx25_gcq_priv *priv)\r\n{\r\nstruct device_node *np = pdev->dev.of_node;\r\nstruct device_node *child;\r\nstruct device *dev = &pdev->dev;\r\nunsigned int refp_used[4] = {};\r\nint ret, i;\r\nfor (i = 0; i < MX25_NUM_CFGS; ++i)\r\nregmap_write(priv->regs, MX25_ADCQ_CFG(i),\r\nMX25_ADCQ_CFG_YPLL_OFF |\r\nMX25_ADCQ_CFG_XNUR_OFF |\r\nMX25_ADCQ_CFG_XPUL_OFF |\r\nMX25_ADCQ_CFG_REFP_INT |\r\nMX25_ADCQ_CFG_IN(i) |\r\nMX25_ADCQ_CFG_REFN_NGND2);\r\npriv->vref[MX25_ADC_REFP_INT] = NULL;\r\npriv->vref[MX25_ADC_REFP_EXT] =\r\ndevm_regulator_get_optional(&pdev->dev, "vref-ext");\r\npriv->vref[MX25_ADC_REFP_XP] =\r\ndevm_regulator_get_optional(&pdev->dev, "vref-xp");\r\npriv->vref[MX25_ADC_REFP_YP] =\r\ndevm_regulator_get_optional(&pdev->dev, "vref-yp");\r\nfor_each_child_of_node(np, child) {\r\nu32 reg;\r\nu32 refp = MX25_ADCQ_CFG_REFP_INT;\r\nu32 refn = MX25_ADCQ_CFG_REFN_NGND2;\r\nret = of_property_read_u32(child, "reg", &reg);\r\nif (ret) {\r\ndev_err(dev, "Failed to get reg property\n");\r\nreturn ret;\r\n}\r\nif (reg >= MX25_NUM_CFGS) {\r\ndev_err(dev,\r\n"reg value is greater than the number of available configuration registers\n");\r\nreturn -EINVAL;\r\n}\r\nof_property_read_u32(child, "fsl,adc-refp", &refp);\r\nof_property_read_u32(child, "fsl,adc-refn", &refn);\r\nswitch (refp) {\r\ncase MX25_ADC_REFP_EXT:\r\ncase MX25_ADC_REFP_XP:\r\ncase MX25_ADC_REFP_YP:\r\nif (IS_ERR(priv->vref[refp])) {\r\ndev_err(dev, "Error, trying to use external voltage reference without a vref-%s regulator.",\r\nmx25_gcq_refp_names[refp]);\r\nreturn PTR_ERR(priv->vref[refp]);\r\n}\r\npriv->channel_vref_mv[reg] =\r\nregulator_get_voltage(priv->vref[refp]);\r\npriv->channel_vref_mv[reg] /= 1000;\r\nbreak;\r\ncase MX25_ADC_REFP_INT:\r\npriv->channel_vref_mv[reg] = 2500;\r\nbreak;\r\ndefault:\r\ndev_err(dev, "Invalid positive reference %d\n", refp);\r\nreturn -EINVAL;\r\n}\r\n++refp_used[refp];\r\nrefp = MX25_ADCQ_CFG_REFP(refp);\r\nrefn = MX25_ADCQ_CFG_REFN(refn);\r\nif ((refp & MX25_ADCQ_CFG_REFP_MASK) != refp) {\r\ndev_err(dev, "Invalid fsl,adc-refp property value\n");\r\nreturn -EINVAL;\r\n}\r\nif ((refn & MX25_ADCQ_CFG_REFN_MASK) != refn) {\r\ndev_err(dev, "Invalid fsl,adc-refn property value\n");\r\nreturn -EINVAL;\r\n}\r\nregmap_update_bits(priv->regs, MX25_ADCQ_CFG(reg),\r\nMX25_ADCQ_CFG_REFP_MASK |\r\nMX25_ADCQ_CFG_REFN_MASK,\r\nrefp | refn);\r\n}\r\nregmap_update_bits(priv->regs, MX25_ADCQ_CR,\r\nMX25_ADCQ_CR_FRST | MX25_ADCQ_CR_QRST,\r\nMX25_ADCQ_CR_FRST | MX25_ADCQ_CR_QRST);\r\nregmap_write(priv->regs, MX25_ADCQ_CR,\r\nMX25_ADCQ_CR_PDMSK | MX25_ADCQ_CR_QSM_FQS);\r\nfor (i = 0; i != 4; ++i) {\r\nif (!refp_used[i]) {\r\nif (!IS_ERR_OR_NULL(priv->vref[i]))\r\ndevm_regulator_put(priv->vref[i]);\r\npriv->vref[i] = NULL;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int mx25_gcq_probe(struct platform_device *pdev)\r\n{\r\nstruct iio_dev *indio_dev;\r\nstruct mx25_gcq_priv *priv;\r\nstruct mx25_tsadc *tsadc = dev_get_drvdata(pdev->dev.parent);\r\nstruct device *dev = &pdev->dev;\r\nstruct resource *res;\r\nvoid __iomem *mem;\r\nint ret;\r\nint i;\r\nindio_dev = devm_iio_device_alloc(&pdev->dev, sizeof(*priv));\r\nif (!indio_dev)\r\nreturn -ENOMEM;\r\npriv = iio_priv(indio_dev);\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nmem = devm_ioremap_resource(dev, res);\r\nif (IS_ERR(mem))\r\nreturn PTR_ERR(mem);\r\npriv->regs = devm_regmap_init_mmio(dev, mem, &mx25_gcq_regconfig);\r\nif (IS_ERR(priv->regs)) {\r\ndev_err(dev, "Failed to initialize regmap\n");\r\nreturn PTR_ERR(priv->regs);\r\n}\r\ninit_completion(&priv->completed);\r\nret = mx25_gcq_setup_cfgs(pdev, priv);\r\nif (ret)\r\nreturn ret;\r\nfor (i = 0; i != 4; ++i) {\r\nif (!priv->vref[i])\r\ncontinue;\r\nret = regulator_enable(priv->vref[i]);\r\nif (ret)\r\ngoto err_regulator_disable;\r\n}\r\npriv->clk = tsadc->clk;\r\nret = clk_prepare_enable(priv->clk);\r\nif (ret) {\r\ndev_err(dev, "Failed to enable clock\n");\r\ngoto err_vref_disable;\r\n}\r\npriv->irq = platform_get_irq(pdev, 0);\r\nif (priv->irq <= 0) {\r\ndev_err(dev, "Failed to get IRQ\n");\r\nret = priv->irq;\r\nif (!ret)\r\nret = -ENXIO;\r\ngoto err_clk_unprepare;\r\n}\r\nret = request_irq(priv->irq, mx25_gcq_irq, 0, pdev->name, priv);\r\nif (ret) {\r\ndev_err(dev, "Failed requesting IRQ\n");\r\ngoto err_clk_unprepare;\r\n}\r\nindio_dev->dev.parent = &pdev->dev;\r\nindio_dev->channels = mx25_gcq_channels;\r\nindio_dev->num_channels = ARRAY_SIZE(mx25_gcq_channels);\r\nindio_dev->info = &mx25_gcq_iio_info;\r\nindio_dev->name = driver_name;\r\nret = iio_device_register(indio_dev);\r\nif (ret) {\r\ndev_err(dev, "Failed to register iio device\n");\r\ngoto err_irq_free;\r\n}\r\nplatform_set_drvdata(pdev, indio_dev);\r\nreturn 0;\r\nerr_irq_free:\r\nfree_irq(priv->irq, priv);\r\nerr_clk_unprepare:\r\nclk_disable_unprepare(priv->clk);\r\nerr_vref_disable:\r\ni = 4;\r\nerr_regulator_disable:\r\nfor (; i-- > 0;) {\r\nif (priv->vref[i])\r\nregulator_disable(priv->vref[i]);\r\n}\r\nreturn ret;\r\n}\r\nstatic int mx25_gcq_remove(struct platform_device *pdev)\r\n{\r\nstruct iio_dev *indio_dev = platform_get_drvdata(pdev);\r\nstruct mx25_gcq_priv *priv = iio_priv(indio_dev);\r\nint i;\r\niio_device_unregister(indio_dev);\r\nfree_irq(priv->irq, priv);\r\nclk_disable_unprepare(priv->clk);\r\nfor (i = 4; i-- > 0;) {\r\nif (priv->vref[i])\r\nregulator_disable(priv->vref[i]);\r\n}\r\nreturn 0;\r\n}
