static inline struct xtpg_device *to_tpg(struct v4l2_subdev *subdev)\r\n{\r\nreturn container_of(subdev, struct xtpg_device, xvip.subdev);\r\n}\r\nstatic u32 xtpg_get_bayer_phase(unsigned int code)\r\n{\r\nswitch (code) {\r\ncase MEDIA_BUS_FMT_SRGGB8_1X8:\r\nreturn XTPG_BAYER_PHASE_RGGB;\r\ncase MEDIA_BUS_FMT_SGRBG8_1X8:\r\nreturn XTPG_BAYER_PHASE_GRBG;\r\ncase MEDIA_BUS_FMT_SGBRG8_1X8:\r\nreturn XTPG_BAYER_PHASE_GBRG;\r\ncase MEDIA_BUS_FMT_SBGGR8_1X8:\r\nreturn XTPG_BAYER_PHASE_BGGR;\r\ndefault:\r\nreturn XTPG_BAYER_PHASE_OFF;\r\n}\r\n}\r\nstatic void __xtpg_update_pattern_control(struct xtpg_device *xtpg,\r\nbool passthrough, bool pattern)\r\n{\r\nu32 pattern_mask = (1 << (xtpg->pattern->maximum + 1)) - 1;\r\nif (xtpg->npads == 1 || !xtpg->has_input)\r\npassthrough = false;\r\nif (passthrough)\r\npattern_mask &= ~1;\r\nif (pattern)\r\npattern_mask &= 1;\r\n__v4l2_ctrl_modify_range(xtpg->pattern, 0, xtpg->pattern->maximum,\r\npattern_mask, pattern ? 9 : 0);\r\n}\r\nstatic void xtpg_update_pattern_control(struct xtpg_device *xtpg,\r\nbool passthrough, bool pattern)\r\n{\r\nmutex_lock(xtpg->ctrl_handler.lock);\r\n__xtpg_update_pattern_control(xtpg, passthrough, pattern);\r\nmutex_unlock(xtpg->ctrl_handler.lock);\r\n}\r\nstatic int xtpg_s_stream(struct v4l2_subdev *subdev, int enable)\r\n{\r\nstruct xtpg_device *xtpg = to_tpg(subdev);\r\nunsigned int width = xtpg->formats[0].width;\r\nunsigned int height = xtpg->formats[0].height;\r\nbool passthrough;\r\nu32 bayer_phase;\r\nif (!enable) {\r\nxvip_stop(&xtpg->xvip);\r\nif (xtpg->vtc)\r\nxvtc_generator_stop(xtpg->vtc);\r\nxtpg_update_pattern_control(xtpg, true, true);\r\nxtpg->streaming = false;\r\nreturn 0;\r\n}\r\nxvip_set_frame_size(&xtpg->xvip, &xtpg->formats[0]);\r\nif (xtpg->vtc) {\r\nstruct xvtc_config config = {\r\n.hblank_start = width,\r\n.hsync_start = width + 1,\r\n.vblank_start = height,\r\n.vsync_start = height + 1,\r\n};\r\nunsigned int htotal;\r\nunsigned int vtotal;\r\nhtotal = min_t(unsigned int, XVTC_MAX_HSIZE,\r\nv4l2_ctrl_g_ctrl(xtpg->hblank) + width);\r\nvtotal = min_t(unsigned int, XVTC_MAX_VSIZE,\r\nv4l2_ctrl_g_ctrl(xtpg->vblank) + height);\r\nconfig.hsync_end = htotal - 1;\r\nconfig.hsize = htotal;\r\nconfig.vsync_end = vtotal - 1;\r\nconfig.vsize = vtotal;\r\nxvtc_generator_start(xtpg->vtc, &config);\r\n}\r\nmutex_lock(xtpg->ctrl_handler.lock);\r\nxvip_clr_and_set(&xtpg->xvip, XTPG_PATTERN_CONTROL,\r\nXTPG_PATTERN_MASK, xtpg->pattern->cur.val);\r\npassthrough = xtpg->pattern->cur.val == 0;\r\n__xtpg_update_pattern_control(xtpg, passthrough, !passthrough);\r\nxtpg->streaming = true;\r\nmutex_unlock(xtpg->ctrl_handler.lock);\r\nbayer_phase = passthrough ? XTPG_BAYER_PHASE_OFF\r\n: xtpg_get_bayer_phase(xtpg->formats[0].code);\r\nxvip_write(&xtpg->xvip, XTPG_BAYER_PHASE, bayer_phase);\r\nif (xtpg->vtmux_gpio)\r\ngpiod_set_value_cansleep(xtpg->vtmux_gpio, !passthrough);\r\nxvip_start(&xtpg->xvip);\r\nreturn 0;\r\n}\r\nstatic struct v4l2_mbus_framefmt *\r\n__xtpg_get_pad_format(struct xtpg_device *xtpg,\r\nstruct v4l2_subdev_pad_config *cfg,\r\nunsigned int pad, u32 which)\r\n{\r\nswitch (which) {\r\ncase V4L2_SUBDEV_FORMAT_TRY:\r\nreturn v4l2_subdev_get_try_format(&xtpg->xvip.subdev, cfg, pad);\r\ncase V4L2_SUBDEV_FORMAT_ACTIVE:\r\nreturn &xtpg->formats[pad];\r\ndefault:\r\nreturn NULL;\r\n}\r\n}\r\nstatic int xtpg_get_format(struct v4l2_subdev *subdev,\r\nstruct v4l2_subdev_pad_config *cfg,\r\nstruct v4l2_subdev_format *fmt)\r\n{\r\nstruct xtpg_device *xtpg = to_tpg(subdev);\r\nfmt->format = *__xtpg_get_pad_format(xtpg, cfg, fmt->pad, fmt->which);\r\nreturn 0;\r\n}\r\nstatic int xtpg_set_format(struct v4l2_subdev *subdev,\r\nstruct v4l2_subdev_pad_config *cfg,\r\nstruct v4l2_subdev_format *fmt)\r\n{\r\nstruct xtpg_device *xtpg = to_tpg(subdev);\r\nstruct v4l2_mbus_framefmt *__format;\r\nu32 bayer_phase;\r\n__format = __xtpg_get_pad_format(xtpg, cfg, fmt->pad, fmt->which);\r\nif (xtpg->npads == 2 && fmt->pad == 1) {\r\nfmt->format = *__format;\r\nreturn 0;\r\n}\r\nif (xtpg->bayer) {\r\nbayer_phase = xtpg_get_bayer_phase(fmt->format.code);\r\nif (bayer_phase != XTPG_BAYER_PHASE_OFF)\r\n__format->code = fmt->format.code;\r\n}\r\nxvip_set_format_size(__format, fmt);\r\nfmt->format = *__format;\r\nif (xtpg->npads == 2) {\r\n__format = __xtpg_get_pad_format(xtpg, cfg, 1, fmt->which);\r\n*__format = fmt->format;\r\n}\r\nreturn 0;\r\n}\r\nstatic int xtpg_enum_frame_size(struct v4l2_subdev *subdev,\r\nstruct v4l2_subdev_pad_config *cfg,\r\nstruct v4l2_subdev_frame_size_enum *fse)\r\n{\r\nstruct v4l2_mbus_framefmt *format;\r\nformat = v4l2_subdev_get_try_format(subdev, cfg, fse->pad);\r\nif (fse->index || fse->code != format->code)\r\nreturn -EINVAL;\r\nif (fse->pad == 0) {\r\nfse->min_width = XVIP_MIN_WIDTH;\r\nfse->max_width = XVIP_MAX_WIDTH;\r\nfse->min_height = XVIP_MIN_HEIGHT;\r\nfse->max_height = XVIP_MAX_HEIGHT;\r\n} else {\r\nfse->min_width = format->width;\r\nfse->max_width = format->width;\r\nfse->min_height = format->height;\r\nfse->max_height = format->height;\r\n}\r\nreturn 0;\r\n}\r\nstatic int xtpg_open(struct v4l2_subdev *subdev, struct v4l2_subdev_fh *fh)\r\n{\r\nstruct xtpg_device *xtpg = to_tpg(subdev);\r\nstruct v4l2_mbus_framefmt *format;\r\nformat = v4l2_subdev_get_try_format(subdev, fh->pad, 0);\r\n*format = xtpg->default_format;\r\nif (xtpg->npads == 2) {\r\nformat = v4l2_subdev_get_try_format(subdev, fh->pad, 1);\r\n*format = xtpg->default_format;\r\n}\r\nreturn 0;\r\n}\r\nstatic int xtpg_close(struct v4l2_subdev *subdev, struct v4l2_subdev_fh *fh)\r\n{\r\nreturn 0;\r\n}\r\nstatic int xtpg_s_ctrl(struct v4l2_ctrl *ctrl)\r\n{\r\nstruct xtpg_device *xtpg = container_of(ctrl->handler,\r\nstruct xtpg_device,\r\nctrl_handler);\r\nswitch (ctrl->id) {\r\ncase V4L2_CID_TEST_PATTERN:\r\nxvip_clr_and_set(&xtpg->xvip, XTPG_PATTERN_CONTROL,\r\nXTPG_PATTERN_MASK, ctrl->val);\r\nreturn 0;\r\ncase V4L2_CID_XILINX_TPG_CROSS_HAIRS:\r\nxvip_clr_or_set(&xtpg->xvip, XTPG_PATTERN_CONTROL,\r\nXTPG_PATTERN_CONTROL_CROSS_HAIRS, ctrl->val);\r\nreturn 0;\r\ncase V4L2_CID_XILINX_TPG_MOVING_BOX:\r\nxvip_clr_or_set(&xtpg->xvip, XTPG_PATTERN_CONTROL,\r\nXTPG_PATTERN_CONTROL_MOVING_BOX, ctrl->val);\r\nreturn 0;\r\ncase V4L2_CID_XILINX_TPG_COLOR_MASK:\r\nxvip_clr_and_set(&xtpg->xvip, XTPG_PATTERN_CONTROL,\r\nXTPG_PATTERN_CONTROL_COLOR_MASK_MASK,\r\nctrl->val <<\r\nXTPG_PATTERN_CONTROL_COLOR_MASK_SHIFT);\r\nreturn 0;\r\ncase V4L2_CID_XILINX_TPG_STUCK_PIXEL:\r\nxvip_clr_or_set(&xtpg->xvip, XTPG_PATTERN_CONTROL,\r\nXTPG_PATTERN_CONTROL_STUCK_PIXEL, ctrl->val);\r\nreturn 0;\r\ncase V4L2_CID_XILINX_TPG_NOISE:\r\nxvip_clr_or_set(&xtpg->xvip, XTPG_PATTERN_CONTROL,\r\nXTPG_PATTERN_CONTROL_NOISE, ctrl->val);\r\nreturn 0;\r\ncase V4L2_CID_XILINX_TPG_MOTION:\r\nxvip_clr_or_set(&xtpg->xvip, XTPG_PATTERN_CONTROL,\r\nXTPG_PATTERN_CONTROL_MOTION, ctrl->val);\r\nreturn 0;\r\ncase V4L2_CID_XILINX_TPG_MOTION_SPEED:\r\nxvip_write(&xtpg->xvip, XTPG_MOTION_SPEED, ctrl->val);\r\nreturn 0;\r\ncase V4L2_CID_XILINX_TPG_CROSS_HAIR_ROW:\r\nxvip_clr_and_set(&xtpg->xvip, XTPG_CROSS_HAIRS,\r\nXTPG_CROSS_HAIRS_ROW_MASK,\r\nctrl->val << XTPG_CROSS_HAIRS_ROW_SHIFT);\r\nreturn 0;\r\ncase V4L2_CID_XILINX_TPG_CROSS_HAIR_COLUMN:\r\nxvip_clr_and_set(&xtpg->xvip, XTPG_CROSS_HAIRS,\r\nXTPG_CROSS_HAIRS_COLUMN_MASK,\r\nctrl->val << XTPG_CROSS_HAIRS_COLUMN_SHIFT);\r\nreturn 0;\r\ncase V4L2_CID_XILINX_TPG_ZPLATE_HOR_START:\r\nxvip_clr_and_set(&xtpg->xvip, XTPG_ZPLATE_HOR_CONTROL,\r\nXTPG_ZPLATE_START_MASK,\r\nctrl->val << XTPG_ZPLATE_START_SHIFT);\r\nreturn 0;\r\ncase V4L2_CID_XILINX_TPG_ZPLATE_HOR_SPEED:\r\nxvip_clr_and_set(&xtpg->xvip, XTPG_ZPLATE_HOR_CONTROL,\r\nXTPG_ZPLATE_SPEED_MASK,\r\nctrl->val << XTPG_ZPLATE_SPEED_SHIFT);\r\nreturn 0;\r\ncase V4L2_CID_XILINX_TPG_ZPLATE_VER_START:\r\nxvip_clr_and_set(&xtpg->xvip, XTPG_ZPLATE_VER_CONTROL,\r\nXTPG_ZPLATE_START_MASK,\r\nctrl->val << XTPG_ZPLATE_START_SHIFT);\r\nreturn 0;\r\ncase V4L2_CID_XILINX_TPG_ZPLATE_VER_SPEED:\r\nxvip_clr_and_set(&xtpg->xvip, XTPG_ZPLATE_VER_CONTROL,\r\nXTPG_ZPLATE_SPEED_MASK,\r\nctrl->val << XTPG_ZPLATE_SPEED_SHIFT);\r\nreturn 0;\r\ncase V4L2_CID_XILINX_TPG_BOX_SIZE:\r\nxvip_write(&xtpg->xvip, XTPG_BOX_SIZE, ctrl->val);\r\nreturn 0;\r\ncase V4L2_CID_XILINX_TPG_BOX_COLOR:\r\nxvip_write(&xtpg->xvip, XTPG_BOX_COLOR, ctrl->val);\r\nreturn 0;\r\ncase V4L2_CID_XILINX_TPG_STUCK_PIXEL_THRESH:\r\nxvip_write(&xtpg->xvip, XTPG_STUCK_PIXEL_THRESH, ctrl->val);\r\nreturn 0;\r\ncase V4L2_CID_XILINX_TPG_NOISE_GAIN:\r\nxvip_write(&xtpg->xvip, XTPG_NOISE_GAIN, ctrl->val);\r\nreturn 0;\r\n}\r\nreturn 0;\r\n}\r\nstatic int __maybe_unused xtpg_pm_suspend(struct device *dev)\r\n{\r\nstruct xtpg_device *xtpg = dev_get_drvdata(dev);\r\nxvip_suspend(&xtpg->xvip);\r\nreturn 0;\r\n}\r\nstatic int __maybe_unused xtpg_pm_resume(struct device *dev)\r\n{\r\nstruct xtpg_device *xtpg = dev_get_drvdata(dev);\r\nxvip_resume(&xtpg->xvip);\r\nreturn 0;\r\n}\r\nstatic int xtpg_parse_of(struct xtpg_device *xtpg)\r\n{\r\nstruct device *dev = xtpg->xvip.dev;\r\nstruct device_node *node = xtpg->xvip.dev->of_node;\r\nstruct device_node *ports;\r\nstruct device_node *port;\r\nunsigned int nports = 0;\r\nbool has_endpoint = false;\r\nports = of_get_child_by_name(node, "ports");\r\nif (ports == NULL)\r\nports = node;\r\nfor_each_child_of_node(ports, port) {\r\nconst struct xvip_video_format *format;\r\nstruct device_node *endpoint;\r\nif (!port->name || of_node_cmp(port->name, "port"))\r\ncontinue;\r\nformat = xvip_of_get_format(port);\r\nif (IS_ERR(format)) {\r\ndev_err(dev, "invalid format in DT");\r\nof_node_put(port);\r\nreturn PTR_ERR(format);\r\n}\r\nif (!xtpg->vip_format) {\r\nxtpg->vip_format = format;\r\n} else if (xtpg->vip_format != format) {\r\ndev_err(dev, "in/out format mismatch in DT");\r\nof_node_put(port);\r\nreturn -EINVAL;\r\n}\r\nif (nports == 0) {\r\nendpoint = of_get_next_child(port, NULL);\r\nif (endpoint)\r\nhas_endpoint = true;\r\nof_node_put(endpoint);\r\n}\r\nnports++;\r\n}\r\nif (nports != 1 && nports != 2) {\r\ndev_err(dev, "invalid number of ports %u\n", nports);\r\nreturn -EINVAL;\r\n}\r\nxtpg->npads = nports;\r\nif (nports == 2 && has_endpoint)\r\nxtpg->has_input = true;\r\nreturn 0;\r\n}\r\nstatic int xtpg_probe(struct platform_device *pdev)\r\n{\r\nstruct v4l2_subdev *subdev;\r\nstruct xtpg_device *xtpg;\r\nu32 i, bayer_phase;\r\nint ret;\r\nxtpg = devm_kzalloc(&pdev->dev, sizeof(*xtpg), GFP_KERNEL);\r\nif (!xtpg)\r\nreturn -ENOMEM;\r\nxtpg->xvip.dev = &pdev->dev;\r\nret = xtpg_parse_of(xtpg);\r\nif (ret < 0)\r\nreturn ret;\r\nret = xvip_init_resources(&xtpg->xvip);\r\nif (ret < 0)\r\nreturn ret;\r\nxtpg->vtmux_gpio = devm_gpiod_get_optional(&pdev->dev, "timing",\r\nGPIOD_OUT_HIGH);\r\nif (IS_ERR(xtpg->vtmux_gpio)) {\r\nret = PTR_ERR(xtpg->vtmux_gpio);\r\ngoto error_resource;\r\n}\r\nxtpg->vtc = xvtc_of_get(pdev->dev.of_node);\r\nif (IS_ERR(xtpg->vtc)) {\r\nret = PTR_ERR(xtpg->vtc);\r\ngoto error_resource;\r\n}\r\nxvip_reset(&xtpg->xvip);\r\nif (xtpg->npads == 2) {\r\nxtpg->pads[0].flags = MEDIA_PAD_FL_SINK;\r\nxtpg->pads[1].flags = MEDIA_PAD_FL_SOURCE;\r\n} else {\r\nxtpg->pads[0].flags = MEDIA_PAD_FL_SOURCE;\r\n}\r\nxtpg->default_format.code = xtpg->vip_format->code;\r\nxtpg->default_format.field = V4L2_FIELD_NONE;\r\nxtpg->default_format.colorspace = V4L2_COLORSPACE_SRGB;\r\nxvip_get_frame_size(&xtpg->xvip, &xtpg->default_format);\r\nbayer_phase = xtpg_get_bayer_phase(xtpg->vip_format->code);\r\nif (bayer_phase != XTPG_BAYER_PHASE_OFF)\r\nxtpg->bayer = true;\r\nxtpg->formats[0] = xtpg->default_format;\r\nif (xtpg->npads == 2)\r\nxtpg->formats[1] = xtpg->default_format;\r\nsubdev = &xtpg->xvip.subdev;\r\nv4l2_subdev_init(subdev, &xtpg_ops);\r\nsubdev->dev = &pdev->dev;\r\nsubdev->internal_ops = &xtpg_internal_ops;\r\nstrlcpy(subdev->name, dev_name(&pdev->dev), sizeof(subdev->name));\r\nv4l2_set_subdevdata(subdev, xtpg);\r\nsubdev->flags |= V4L2_SUBDEV_FL_HAS_DEVNODE;\r\nsubdev->entity.ops = &xtpg_media_ops;\r\nret = media_entity_pads_init(&subdev->entity, xtpg->npads, xtpg->pads);\r\nif (ret < 0)\r\ngoto error;\r\nv4l2_ctrl_handler_init(&xtpg->ctrl_handler, 3 + ARRAY_SIZE(xtpg_ctrls));\r\nxtpg->vblank = v4l2_ctrl_new_std(&xtpg->ctrl_handler, &xtpg_ctrl_ops,\r\nV4L2_CID_VBLANK, XTPG_MIN_VBLANK,\r\nXTPG_MAX_VBLANK, 1, 100);\r\nxtpg->hblank = v4l2_ctrl_new_std(&xtpg->ctrl_handler, &xtpg_ctrl_ops,\r\nV4L2_CID_HBLANK, XTPG_MIN_HBLANK,\r\nXTPG_MAX_HBLANK, 1, 100);\r\nxtpg->pattern = v4l2_ctrl_new_std_menu_items(&xtpg->ctrl_handler,\r\n&xtpg_ctrl_ops, V4L2_CID_TEST_PATTERN,\r\nARRAY_SIZE(xtpg_pattern_strings) - 1,\r\n1, 9, xtpg_pattern_strings);\r\nfor (i = 0; i < ARRAY_SIZE(xtpg_ctrls); i++)\r\nv4l2_ctrl_new_custom(&xtpg->ctrl_handler, &xtpg_ctrls[i], NULL);\r\nif (xtpg->ctrl_handler.error) {\r\ndev_err(&pdev->dev, "failed to add controls\n");\r\nret = xtpg->ctrl_handler.error;\r\ngoto error;\r\n}\r\nsubdev->ctrl_handler = &xtpg->ctrl_handler;\r\nxtpg_update_pattern_control(xtpg, true, true);\r\nret = v4l2_ctrl_handler_setup(&xtpg->ctrl_handler);\r\nif (ret < 0) {\r\ndev_err(&pdev->dev, "failed to set controls\n");\r\ngoto error;\r\n}\r\nplatform_set_drvdata(pdev, xtpg);\r\nxvip_print_version(&xtpg->xvip);\r\nret = v4l2_async_register_subdev(subdev);\r\nif (ret < 0) {\r\ndev_err(&pdev->dev, "failed to register subdev\n");\r\ngoto error;\r\n}\r\nreturn 0;\r\nerror:\r\nv4l2_ctrl_handler_free(&xtpg->ctrl_handler);\r\nmedia_entity_cleanup(&subdev->entity);\r\nxvtc_put(xtpg->vtc);\r\nerror_resource:\r\nxvip_cleanup_resources(&xtpg->xvip);\r\nreturn ret;\r\n}\r\nstatic int xtpg_remove(struct platform_device *pdev)\r\n{\r\nstruct xtpg_device *xtpg = platform_get_drvdata(pdev);\r\nstruct v4l2_subdev *subdev = &xtpg->xvip.subdev;\r\nv4l2_async_unregister_subdev(subdev);\r\nv4l2_ctrl_handler_free(&xtpg->ctrl_handler);\r\nmedia_entity_cleanup(&subdev->entity);\r\nxvip_cleanup_resources(&xtpg->xvip);\r\nreturn 0;\r\n}
