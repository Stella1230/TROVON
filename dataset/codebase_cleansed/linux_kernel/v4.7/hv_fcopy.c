static void fcopy_poll_wrapper(void *channel)\r\n{\r\nfcopy_transaction.state = HVUTIL_READY;\r\nhv_fcopy_onchannelcallback(channel);\r\n}\r\nstatic void fcopy_timeout_func(struct work_struct *dummy)\r\n{\r\nfcopy_respond_to_host(HV_E_FAIL);\r\nhv_poll_channel(fcopy_transaction.recv_channel, fcopy_poll_wrapper);\r\n}\r\nstatic int fcopy_handle_handshake(u32 version)\r\n{\r\nu32 our_ver = FCOPY_CURRENT_VERSION;\r\nswitch (version) {\r\ncase FCOPY_VERSION_0:\r\ndm_reg_value = version;\r\nbreak;\r\ncase FCOPY_VERSION_1:\r\nif (hvutil_transport_send(hvt, &our_ver, sizeof(our_ver)))\r\nreturn -EFAULT;\r\ndm_reg_value = version;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\npr_debug("FCP: userspace daemon ver. %d registered\n", version);\r\nhv_poll_channel(fcopy_transaction.recv_channel, fcopy_poll_wrapper);\r\nreturn 0;\r\n}\r\nstatic void fcopy_send_data(struct work_struct *dummy)\r\n{\r\nstruct hv_start_fcopy *smsg_out = NULL;\r\nint operation = fcopy_transaction.fcopy_msg->operation;\r\nstruct hv_start_fcopy *smsg_in;\r\nvoid *out_src;\r\nint rc, out_len;\r\nswitch (operation) {\r\ncase START_FILE_COPY:\r\nout_len = sizeof(struct hv_start_fcopy);\r\nsmsg_out = kzalloc(sizeof(*smsg_out), GFP_KERNEL);\r\nif (!smsg_out)\r\nreturn;\r\nsmsg_out->hdr.operation = operation;\r\nsmsg_in = (struct hv_start_fcopy *)fcopy_transaction.fcopy_msg;\r\nutf16s_to_utf8s((wchar_t *)smsg_in->file_name, W_MAX_PATH,\r\nUTF16_LITTLE_ENDIAN,\r\n(__u8 *)&smsg_out->file_name, W_MAX_PATH - 1);\r\nutf16s_to_utf8s((wchar_t *)smsg_in->path_name, W_MAX_PATH,\r\nUTF16_LITTLE_ENDIAN,\r\n(__u8 *)&smsg_out->path_name, W_MAX_PATH - 1);\r\nsmsg_out->copy_flags = smsg_in->copy_flags;\r\nsmsg_out->file_size = smsg_in->file_size;\r\nout_src = smsg_out;\r\nbreak;\r\ndefault:\r\nout_src = fcopy_transaction.fcopy_msg;\r\nout_len = fcopy_transaction.recv_len;\r\nbreak;\r\n}\r\nfcopy_transaction.state = HVUTIL_USERSPACE_REQ;\r\nrc = hvutil_transport_send(hvt, out_src, out_len);\r\nif (rc) {\r\npr_debug("FCP: failed to communicate to the daemon: %d\n", rc);\r\nif (cancel_delayed_work_sync(&fcopy_timeout_work)) {\r\nfcopy_respond_to_host(HV_E_FAIL);\r\nfcopy_transaction.state = HVUTIL_READY;\r\n}\r\n}\r\nkfree(smsg_out);\r\nreturn;\r\n}\r\nstatic void\r\nfcopy_respond_to_host(int error)\r\n{\r\nstruct icmsg_hdr *icmsghdr;\r\nu32 buf_len;\r\nstruct vmbus_channel *channel;\r\nu64 req_id;\r\nbuf_len = fcopy_transaction.recv_len;\r\nchannel = fcopy_transaction.recv_channel;\r\nreq_id = fcopy_transaction.recv_req_id;\r\nicmsghdr = (struct icmsg_hdr *)\r\n&recv_buffer[sizeof(struct vmbuspipe_hdr)];\r\nif (channel->onchannel_callback == NULL)\r\nreturn;\r\nicmsghdr->status = error;\r\nicmsghdr->icflags = ICMSGHDRFLAG_TRANSACTION | ICMSGHDRFLAG_RESPONSE;\r\nvmbus_sendpacket(channel, recv_buffer, buf_len, req_id,\r\nVM_PKT_DATA_INBAND, 0);\r\n}\r\nvoid hv_fcopy_onchannelcallback(void *context)\r\n{\r\nstruct vmbus_channel *channel = context;\r\nu32 recvlen;\r\nu64 requestid;\r\nstruct hv_fcopy_hdr *fcopy_msg;\r\nstruct icmsg_hdr *icmsghdr;\r\nstruct icmsg_negotiate *negop = NULL;\r\nint util_fw_version;\r\nint fcopy_srv_version;\r\nif (fcopy_transaction.state > HVUTIL_READY)\r\nreturn;\r\nvmbus_recvpacket(channel, recv_buffer, PAGE_SIZE * 2, &recvlen,\r\n&requestid);\r\nif (recvlen <= 0)\r\nreturn;\r\nicmsghdr = (struct icmsg_hdr *)&recv_buffer[\r\nsizeof(struct vmbuspipe_hdr)];\r\nif (icmsghdr->icmsgtype == ICMSGTYPE_NEGOTIATE) {\r\nutil_fw_version = UTIL_FW_VERSION;\r\nfcopy_srv_version = WIN8_SRV_VERSION;\r\nvmbus_prep_negotiate_resp(icmsghdr, negop, recv_buffer,\r\nutil_fw_version, fcopy_srv_version);\r\n} else {\r\nfcopy_msg = (struct hv_fcopy_hdr *)&recv_buffer[\r\nsizeof(struct vmbuspipe_hdr) +\r\nsizeof(struct icmsg_hdr)];\r\nfcopy_transaction.recv_len = recvlen;\r\nfcopy_transaction.recv_req_id = requestid;\r\nfcopy_transaction.fcopy_msg = fcopy_msg;\r\nif (fcopy_transaction.state < HVUTIL_READY) {\r\nfcopy_respond_to_host(HV_E_FAIL);\r\nreturn;\r\n}\r\nfcopy_transaction.state = HVUTIL_HOSTMSG_RECEIVED;\r\nschedule_work(&fcopy_send_work);\r\nschedule_delayed_work(&fcopy_timeout_work,\r\nHV_UTIL_TIMEOUT * HZ);\r\nreturn;\r\n}\r\nicmsghdr->icflags = ICMSGHDRFLAG_TRANSACTION | ICMSGHDRFLAG_RESPONSE;\r\nvmbus_sendpacket(channel, recv_buffer, recvlen, requestid,\r\nVM_PKT_DATA_INBAND, 0);\r\n}\r\nstatic int fcopy_on_msg(void *msg, int len)\r\n{\r\nint *val = (int *)msg;\r\nif (len != sizeof(int))\r\nreturn -EINVAL;\r\nif (fcopy_transaction.state == HVUTIL_DEVICE_INIT)\r\nreturn fcopy_handle_handshake(*val);\r\nif (fcopy_transaction.state != HVUTIL_USERSPACE_REQ)\r\nreturn -EINVAL;\r\nif (cancel_delayed_work_sync(&fcopy_timeout_work)) {\r\nfcopy_transaction.state = HVUTIL_USERSPACE_RECV;\r\nfcopy_respond_to_host(*val);\r\nhv_poll_channel(fcopy_transaction.recv_channel,\r\nfcopy_poll_wrapper);\r\n}\r\nreturn 0;\r\n}\r\nstatic void fcopy_on_reset(void)\r\n{\r\nfcopy_transaction.state = HVUTIL_DEVICE_INIT;\r\nif (cancel_delayed_work_sync(&fcopy_timeout_work))\r\nfcopy_respond_to_host(HV_E_FAIL);\r\n}\r\nint hv_fcopy_init(struct hv_util_service *srv)\r\n{\r\nrecv_buffer = srv->recv_buffer;\r\nfcopy_transaction.recv_channel = srv->channel;\r\nfcopy_transaction.state = HVUTIL_DEVICE_INIT;\r\nhvt = hvutil_transport_init(fcopy_devname, 0, 0,\r\nfcopy_on_msg, fcopy_on_reset);\r\nif (!hvt)\r\nreturn -EFAULT;\r\nreturn 0;\r\n}\r\nvoid hv_fcopy_deinit(void)\r\n{\r\nfcopy_transaction.state = HVUTIL_DEVICE_DYING;\r\ncancel_delayed_work_sync(&fcopy_timeout_work);\r\nhvutil_transport_destroy(hvt);\r\n}
