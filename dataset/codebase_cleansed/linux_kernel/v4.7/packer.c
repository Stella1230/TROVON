static u64 value_read(int offset, int size, void *structure)\r\n{\r\nswitch (size) {\r\ncase 1: return *(u8 *) (structure + offset);\r\ncase 2: return be16_to_cpup((__be16 *) (structure + offset));\r\ncase 4: return be32_to_cpup((__be32 *) (structure + offset));\r\ncase 8: return be64_to_cpup((__be64 *) (structure + offset));\r\ndefault:\r\npr_warn("Field size %d bits not handled\n", size * 8);\r\nreturn 0;\r\n}\r\n}\r\nvoid ib_pack(const struct ib_field *desc,\r\nint desc_len,\r\nvoid *structure,\r\nvoid *buf)\r\n{\r\nint i;\r\nfor (i = 0; i < desc_len; ++i) {\r\nif (desc[i].size_bits <= 32) {\r\nint shift;\r\nu32 val;\r\n__be32 mask;\r\n__be32 *addr;\r\nshift = 32 - desc[i].offset_bits - desc[i].size_bits;\r\nif (desc[i].struct_size_bytes)\r\nval = value_read(desc[i].struct_offset_bytes,\r\ndesc[i].struct_size_bytes,\r\nstructure) << shift;\r\nelse\r\nval = 0;\r\nmask = cpu_to_be32(((1ull << desc[i].size_bits) - 1) << shift);\r\naddr = (__be32 *) buf + desc[i].offset_words;\r\n*addr = (*addr & ~mask) | (cpu_to_be32(val) & mask);\r\n} else if (desc[i].size_bits <= 64) {\r\nint shift;\r\nu64 val;\r\n__be64 mask;\r\n__be64 *addr;\r\nshift = 64 - desc[i].offset_bits - desc[i].size_bits;\r\nif (desc[i].struct_size_bytes)\r\nval = value_read(desc[i].struct_offset_bytes,\r\ndesc[i].struct_size_bytes,\r\nstructure) << shift;\r\nelse\r\nval = 0;\r\nmask = cpu_to_be64((~0ull >> (64 - desc[i].size_bits)) << shift);\r\naddr = (__be64 *) ((__be32 *) buf + desc[i].offset_words);\r\n*addr = (*addr & ~mask) | (cpu_to_be64(val) & mask);\r\n} else {\r\nif (desc[i].offset_bits % 8 ||\r\ndesc[i].size_bits % 8) {\r\npr_warn("Structure field %s of size %d bits is not byte-aligned\n",\r\ndesc[i].field_name, desc[i].size_bits);\r\n}\r\nif (desc[i].struct_size_bytes)\r\nmemcpy(buf + desc[i].offset_words * 4 +\r\ndesc[i].offset_bits / 8,\r\nstructure + desc[i].struct_offset_bytes,\r\ndesc[i].size_bits / 8);\r\nelse\r\nmemset(buf + desc[i].offset_words * 4 +\r\ndesc[i].offset_bits / 8,\r\n0,\r\ndesc[i].size_bits / 8);\r\n}\r\n}\r\n}\r\nstatic void value_write(int offset, int size, u64 val, void *structure)\r\n{\r\nswitch (size * 8) {\r\ncase 8: *( u8 *) (structure + offset) = val; break;\r\ncase 16: *(__be16 *) (structure + offset) = cpu_to_be16(val); break;\r\ncase 32: *(__be32 *) (structure + offset) = cpu_to_be32(val); break;\r\ncase 64: *(__be64 *) (structure + offset) = cpu_to_be64(val); break;\r\ndefault:\r\npr_warn("Field size %d bits not handled\n", size * 8);\r\n}\r\n}\r\nvoid ib_unpack(const struct ib_field *desc,\r\nint desc_len,\r\nvoid *buf,\r\nvoid *structure)\r\n{\r\nint i;\r\nfor (i = 0; i < desc_len; ++i) {\r\nif (!desc[i].struct_size_bytes)\r\ncontinue;\r\nif (desc[i].size_bits <= 32) {\r\nint shift;\r\nu32 val;\r\nu32 mask;\r\n__be32 *addr;\r\nshift = 32 - desc[i].offset_bits - desc[i].size_bits;\r\nmask = ((1ull << desc[i].size_bits) - 1) << shift;\r\naddr = (__be32 *) buf + desc[i].offset_words;\r\nval = (be32_to_cpup(addr) & mask) >> shift;\r\nvalue_write(desc[i].struct_offset_bytes,\r\ndesc[i].struct_size_bytes,\r\nval,\r\nstructure);\r\n} else if (desc[i].size_bits <= 64) {\r\nint shift;\r\nu64 val;\r\nu64 mask;\r\n__be64 *addr;\r\nshift = 64 - desc[i].offset_bits - desc[i].size_bits;\r\nmask = (~0ull >> (64 - desc[i].size_bits)) << shift;\r\naddr = (__be64 *) buf + desc[i].offset_words;\r\nval = (be64_to_cpup(addr) & mask) >> shift;\r\nvalue_write(desc[i].struct_offset_bytes,\r\ndesc[i].struct_size_bytes,\r\nval,\r\nstructure);\r\n} else {\r\nif (desc[i].offset_bits % 8 ||\r\ndesc[i].size_bits % 8) {\r\npr_warn("Structure field %s of size %d bits is not byte-aligned\n",\r\ndesc[i].field_name, desc[i].size_bits);\r\n}\r\nmemcpy(structure + desc[i].struct_offset_bytes,\r\nbuf + desc[i].offset_words * 4 +\r\ndesc[i].offset_bits / 8,\r\ndesc[i].size_bits / 8);\r\n}\r\n}\r\n}
