static int lm3642_chip_init(struct lm3642_chip_data *chip)\r\n{\r\nint ret;\r\nstruct lm3642_platform_data *pdata = chip->pdata;\r\nret = regmap_update_bits(chip->regmap, REG_ENABLE, EX_PIN_ENABLE_MASK,\r\npdata->tx_pin);\r\nif (ret < 0)\r\ndev_err(chip->dev, "Failed to update REG_ENABLE Register\n");\r\nreturn ret;\r\n}\r\nstatic int lm3642_control(struct lm3642_chip_data *chip,\r\nu8 brightness, enum lm3642_mode opmode)\r\n{\r\nint ret;\r\nret = regmap_read(chip->regmap, REG_FLAG, &chip->last_flag);\r\nif (ret < 0) {\r\ndev_err(chip->dev, "Failed to read REG_FLAG Register\n");\r\ngoto out;\r\n}\r\nif (chip->last_flag)\r\ndev_info(chip->dev, "Last FLAG is 0x%x\n", chip->last_flag);\r\nif (!brightness)\r\nopmode = MODES_STASNDBY;\r\nswitch (opmode) {\r\ncase MODES_TORCH:\r\nret = regmap_update_bits(chip->regmap, REG_I_CTRL,\r\nTORCH_I_MASK << TORCH_I_SHIFT,\r\n(brightness - 1) << TORCH_I_SHIFT);\r\nif (chip->torch_pin)\r\nopmode |= (TORCH_PIN_EN_MASK << TORCH_PIN_EN_SHIFT);\r\nbreak;\r\ncase MODES_FLASH:\r\nret = regmap_update_bits(chip->regmap, REG_I_CTRL,\r\nFLASH_I_MASK << FLASH_I_SHIFT,\r\n(brightness - 1) << FLASH_I_SHIFT);\r\nif (chip->strobe_pin)\r\nopmode |= (STROBE_PIN_EN_MASK << STROBE_PIN_EN_SHIFT);\r\nbreak;\r\ncase MODES_INDIC:\r\nret = regmap_update_bits(chip->regmap, REG_I_CTRL,\r\nTORCH_I_MASK << TORCH_I_SHIFT,\r\n(brightness - 1) << TORCH_I_SHIFT);\r\nbreak;\r\ncase MODES_STASNDBY:\r\nbreak;\r\ndefault:\r\nreturn ret;\r\n}\r\nif (ret < 0) {\r\ndev_err(chip->dev, "Failed to write REG_I_CTRL Register\n");\r\ngoto out;\r\n}\r\nif (chip->tx_pin)\r\nopmode |= (TX_PIN_EN_MASK << TX_PIN_EN_SHIFT);\r\nret = regmap_update_bits(chip->regmap, REG_ENABLE,\r\nMODE_BITS_MASK << MODE_BITS_SHIFT,\r\nopmode << MODE_BITS_SHIFT);\r\nout:\r\nreturn ret;\r\n}\r\nstatic ssize_t lm3642_torch_pin_store(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t size)\r\n{\r\nssize_t ret;\r\nstruct led_classdev *led_cdev = dev_get_drvdata(dev);\r\nstruct lm3642_chip_data *chip =\r\ncontainer_of(led_cdev, struct lm3642_chip_data, cdev_indicator);\r\nunsigned int state;\r\nret = kstrtouint(buf, 10, &state);\r\nif (ret)\r\ngoto out_strtoint;\r\nif (state != 0)\r\nstate = 0x01 << TORCH_PIN_EN_SHIFT;\r\nchip->torch_pin = state;\r\nret = regmap_update_bits(chip->regmap, REG_ENABLE,\r\nTORCH_PIN_EN_MASK << TORCH_PIN_EN_SHIFT,\r\nstate);\r\nif (ret < 0)\r\ngoto out;\r\nreturn size;\r\nout:\r\ndev_err(chip->dev, "%s:i2c access fail to register\n", __func__);\r\nreturn ret;\r\nout_strtoint:\r\ndev_err(chip->dev, "%s: fail to change str to int\n", __func__);\r\nreturn ret;\r\n}\r\nstatic int lm3642_torch_brightness_set(struct led_classdev *cdev,\r\nenum led_brightness brightness)\r\n{\r\nstruct lm3642_chip_data *chip =\r\ncontainer_of(cdev, struct lm3642_chip_data, cdev_torch);\r\nint ret;\r\nmutex_lock(&chip->lock);\r\nchip->br_torch = brightness;\r\nret = lm3642_control(chip, chip->br_torch, MODES_TORCH);\r\nmutex_unlock(&chip->lock);\r\nreturn ret;\r\n}\r\nstatic ssize_t lm3642_strobe_pin_store(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t size)\r\n{\r\nssize_t ret;\r\nstruct led_classdev *led_cdev = dev_get_drvdata(dev);\r\nstruct lm3642_chip_data *chip =\r\ncontainer_of(led_cdev, struct lm3642_chip_data, cdev_indicator);\r\nunsigned int state;\r\nret = kstrtouint(buf, 10, &state);\r\nif (ret)\r\ngoto out_strtoint;\r\nif (state != 0)\r\nstate = 0x01 << STROBE_PIN_EN_SHIFT;\r\nchip->strobe_pin = state;\r\nret = regmap_update_bits(chip->regmap, REG_ENABLE,\r\nSTROBE_PIN_EN_MASK << STROBE_PIN_EN_SHIFT,\r\nstate);\r\nif (ret < 0)\r\ngoto out;\r\nreturn size;\r\nout:\r\ndev_err(chip->dev, "%s:i2c access fail to register\n", __func__);\r\nreturn ret;\r\nout_strtoint:\r\ndev_err(chip->dev, "%s: fail to change str to int\n", __func__);\r\nreturn ret;\r\n}\r\nstatic int lm3642_strobe_brightness_set(struct led_classdev *cdev,\r\nenum led_brightness brightness)\r\n{\r\nstruct lm3642_chip_data *chip =\r\ncontainer_of(cdev, struct lm3642_chip_data, cdev_flash);\r\nint ret;\r\nmutex_lock(&chip->lock);\r\nchip->br_flash = brightness;\r\nret = lm3642_control(chip, chip->br_flash, MODES_FLASH);\r\nmutex_unlock(&chip->lock);\r\nreturn ret;\r\n}\r\nstatic int lm3642_indicator_brightness_set(struct led_classdev *cdev,\r\nenum led_brightness brightness)\r\n{\r\nstruct lm3642_chip_data *chip =\r\ncontainer_of(cdev, struct lm3642_chip_data, cdev_indicator);\r\nint ret;\r\nmutex_lock(&chip->lock);\r\nchip->br_indicator = brightness;\r\nret = lm3642_control(chip, chip->br_indicator, MODES_INDIC);\r\nmutex_unlock(&chip->lock);\r\nreturn ret;\r\n}\r\nstatic int lm3642_probe(struct i2c_client *client,\r\nconst struct i2c_device_id *id)\r\n{\r\nstruct lm3642_platform_data *pdata = dev_get_platdata(&client->dev);\r\nstruct lm3642_chip_data *chip;\r\nint err;\r\nif (!i2c_check_functionality(client->adapter, I2C_FUNC_I2C)) {\r\ndev_err(&client->dev, "i2c functionality check fail.\n");\r\nreturn -EOPNOTSUPP;\r\n}\r\nif (pdata == NULL) {\r\ndev_err(&client->dev, "needs Platform Data.\n");\r\nreturn -ENODATA;\r\n}\r\nchip = devm_kzalloc(&client->dev,\r\nsizeof(struct lm3642_chip_data), GFP_KERNEL);\r\nif (!chip)\r\nreturn -ENOMEM;\r\nchip->dev = &client->dev;\r\nchip->pdata = pdata;\r\nchip->tx_pin = pdata->tx_pin;\r\nchip->torch_pin = pdata->torch_pin;\r\nchip->strobe_pin = pdata->strobe_pin;\r\nchip->regmap = devm_regmap_init_i2c(client, &lm3642_regmap);\r\nif (IS_ERR(chip->regmap)) {\r\nerr = PTR_ERR(chip->regmap);\r\ndev_err(&client->dev, "Failed to allocate register map: %d\n",\r\nerr);\r\nreturn err;\r\n}\r\nmutex_init(&chip->lock);\r\ni2c_set_clientdata(client, chip);\r\nerr = lm3642_chip_init(chip);\r\nif (err < 0)\r\ngoto err_out;\r\nchip->cdev_flash.name = "flash";\r\nchip->cdev_flash.max_brightness = 16;\r\nchip->cdev_flash.brightness_set_blocking = lm3642_strobe_brightness_set;\r\nchip->cdev_flash.default_trigger = "flash";\r\nchip->cdev_flash.groups = lm3642_flash_groups,\r\nerr = led_classdev_register((struct device *)\r\n&client->dev, &chip->cdev_flash);\r\nif (err < 0) {\r\ndev_err(chip->dev, "failed to register flash\n");\r\ngoto err_out;\r\n}\r\nchip->cdev_torch.name = "torch";\r\nchip->cdev_torch.max_brightness = 8;\r\nchip->cdev_torch.brightness_set_blocking = lm3642_torch_brightness_set;\r\nchip->cdev_torch.default_trigger = "torch";\r\nchip->cdev_torch.groups = lm3642_torch_groups,\r\nerr = led_classdev_register((struct device *)\r\n&client->dev, &chip->cdev_torch);\r\nif (err < 0) {\r\ndev_err(chip->dev, "failed to register torch\n");\r\ngoto err_create_torch_file;\r\n}\r\nchip->cdev_indicator.name = "indicator";\r\nchip->cdev_indicator.max_brightness = 8;\r\nchip->cdev_indicator.brightness_set_blocking =\r\nlm3642_indicator_brightness_set;\r\nerr = led_classdev_register((struct device *)\r\n&client->dev, &chip->cdev_indicator);\r\nif (err < 0) {\r\ndev_err(chip->dev, "failed to register indicator\n");\r\ngoto err_create_indicator_file;\r\n}\r\ndev_info(&client->dev, "LM3642 is initialized\n");\r\nreturn 0;\r\nerr_create_indicator_file:\r\nled_classdev_unregister(&chip->cdev_torch);\r\nerr_create_torch_file:\r\nled_classdev_unregister(&chip->cdev_flash);\r\nerr_out:\r\nreturn err;\r\n}\r\nstatic int lm3642_remove(struct i2c_client *client)\r\n{\r\nstruct lm3642_chip_data *chip = i2c_get_clientdata(client);\r\nled_classdev_unregister(&chip->cdev_indicator);\r\nled_classdev_unregister(&chip->cdev_torch);\r\nled_classdev_unregister(&chip->cdev_flash);\r\nregmap_write(chip->regmap, REG_ENABLE, 0);\r\nreturn 0;\r\n}
