static int pxa_videobuf_setup(struct videobuf_queue *vq, unsigned int *count,\r\nunsigned int *size)\r\n{\r\nstruct soc_camera_device *icd = vq->priv_data;\r\ndev_dbg(icd->parent, "count=%d, size=%d\n", *count, *size);\r\n*size = icd->sizeimage;\r\nif (0 == *count)\r\n*count = 32;\r\nif (*size * *count > vid_limit * 1024 * 1024)\r\n*count = (vid_limit * 1024 * 1024) / *size;\r\nreturn 0;\r\n}\r\nstatic void free_buffer(struct videobuf_queue *vq, struct pxa_buffer *buf)\r\n{\r\nstruct soc_camera_device *icd = vq->priv_data;\r\nstruct videobuf_dmabuf *dma = videobuf_to_dma(&buf->vb);\r\nint i;\r\nBUG_ON(in_interrupt());\r\ndev_dbg(icd->parent, "%s (vb=0x%p) 0x%08lx %d\n", __func__,\r\n&buf->vb, buf->vb.baddr, buf->vb.bsize);\r\nvideobuf_waiton(vq, &buf->vb, 0, 0);\r\nfor (i = 0; i < 3 && buf->descs[i]; i++) {\r\ndmaengine_desc_free(buf->descs[i]);\r\nkfree(buf->sg[i]);\r\nbuf->descs[i] = NULL;\r\nbuf->sg[i] = NULL;\r\nbuf->sg_len[i] = 0;\r\n}\r\nvideobuf_dma_unmap(vq->dev, dma);\r\nvideobuf_dma_free(dma);\r\nbuf->vb.state = VIDEOBUF_NEEDS_INIT;\r\ndev_dbg(icd->parent, "%s end (vb=0x%p) 0x%08lx %d\n", __func__,\r\n&buf->vb, buf->vb.baddr, buf->vb.bsize);\r\n}\r\nstatic void pxa_camera_dma_irq_y(void *data)\r\n{\r\nstruct pxa_camera_dev *pcdev = data;\r\npxa_camera_dma_irq(pcdev, DMA_Y);\r\n}\r\nstatic void pxa_camera_dma_irq_u(void *data)\r\n{\r\nstruct pxa_camera_dev *pcdev = data;\r\npxa_camera_dma_irq(pcdev, DMA_U);\r\n}\r\nstatic void pxa_camera_dma_irq_v(void *data)\r\n{\r\nstruct pxa_camera_dev *pcdev = data;\r\npxa_camera_dma_irq(pcdev, DMA_V);\r\n}\r\nstatic int pxa_init_dma_channel(struct pxa_camera_dev *pcdev,\r\nstruct pxa_buffer *buf,\r\nstruct videobuf_dmabuf *dma, int channel,\r\nint cibr, int size, int offset)\r\n{\r\nstruct dma_chan *dma_chan = pcdev->dma_chans[channel];\r\nstruct scatterlist *sg = buf->sg[channel];\r\nint sglen = buf->sg_len[channel];\r\nstruct dma_async_tx_descriptor *tx;\r\ntx = dmaengine_prep_slave_sg(dma_chan, sg, sglen, DMA_DEV_TO_MEM,\r\nDMA_PREP_INTERRUPT | DMA_CTRL_REUSE);\r\nif (!tx) {\r\ndev_err(pcdev->soc_host.v4l2_dev.dev,\r\n"dmaengine_prep_slave_sg failed\n");\r\ngoto fail;\r\n}\r\ntx->callback_param = pcdev;\r\nswitch (channel) {\r\ncase 0:\r\ntx->callback = pxa_camera_dma_irq_y;\r\nbreak;\r\ncase 1:\r\ntx->callback = pxa_camera_dma_irq_u;\r\nbreak;\r\ncase 2:\r\ntx->callback = pxa_camera_dma_irq_v;\r\nbreak;\r\n}\r\nbuf->descs[channel] = tx;\r\nreturn 0;\r\nfail:\r\nkfree(sg);\r\ndev_dbg(pcdev->soc_host.v4l2_dev.dev,\r\n"%s (vb=0x%p) dma_tx=%p\n",\r\n__func__, &buf->vb, tx);\r\nreturn -ENOMEM;\r\n}\r\nstatic void pxa_videobuf_set_actdma(struct pxa_camera_dev *pcdev,\r\nstruct pxa_buffer *buf)\r\n{\r\nbuf->active_dma = DMA_Y;\r\nif (pcdev->channels == 3)\r\nbuf->active_dma |= DMA_U | DMA_V;\r\n}\r\nstatic int pxa_videobuf_prepare(struct videobuf_queue *vq,\r\nstruct videobuf_buffer *vb, enum v4l2_field field)\r\n{\r\nstruct soc_camera_device *icd = vq->priv_data;\r\nstruct soc_camera_host *ici = to_soc_camera_host(icd->parent);\r\nstruct pxa_camera_dev *pcdev = ici->priv;\r\nstruct device *dev = pcdev->soc_host.v4l2_dev.dev;\r\nstruct pxa_buffer *buf = container_of(vb, struct pxa_buffer, vb);\r\nint ret;\r\nint size_y, size_u = 0, size_v = 0;\r\nsize_t sizes[3];\r\ndev_dbg(dev, "%s (vb=0x%p) 0x%08lx %d\n", __func__,\r\nvb, vb->baddr, vb->bsize);\r\nWARN_ON(!list_empty(&vb->queue));\r\n#ifdef DEBUG\r\nmemset((void *)vb->baddr, 0xaa, vb->bsize);\r\n#endif\r\nBUG_ON(NULL == icd->current_fmt);\r\nbuf->inwork = 1;\r\nif (buf->code != icd->current_fmt->code ||\r\nvb->width != icd->user_width ||\r\nvb->height != icd->user_height ||\r\nvb->field != field) {\r\nbuf->code = icd->current_fmt->code;\r\nvb->width = icd->user_width;\r\nvb->height = icd->user_height;\r\nvb->field = field;\r\nvb->state = VIDEOBUF_NEEDS_INIT;\r\n}\r\nvb->size = icd->sizeimage;\r\nif (0 != vb->baddr && vb->bsize < vb->size) {\r\nret = -EINVAL;\r\ngoto out;\r\n}\r\nif (vb->state == VIDEOBUF_NEEDS_INIT) {\r\nint size = vb->size;\r\nstruct videobuf_dmabuf *dma = videobuf_to_dma(vb);\r\nret = videobuf_iolock(vq, vb, NULL);\r\nif (ret)\r\ngoto out;\r\nif (pcdev->channels == 3) {\r\nsize_y = size / 2;\r\nsize_u = size_v = size / 4;\r\n} else {\r\nsize_y = size;\r\n}\r\nsizes[0] = size_y;\r\nsizes[1] = size_u;\r\nsizes[2] = size_v;\r\nret = sg_split(dma->sglist, dma->sglen, 0, pcdev->channels,\r\nsizes, buf->sg, buf->sg_len, GFP_KERNEL);\r\nif (ret < 0) {\r\ndev_err(dev, "sg_split failed: %d\n", ret);\r\ngoto fail;\r\n}\r\nret = pxa_init_dma_channel(pcdev, buf, dma, 0, CIBR0,\r\nsize_y, 0);\r\nif (ret) {\r\ndev_err(dev, "DMA initialization for Y/RGB failed\n");\r\ngoto fail;\r\n}\r\nif (size_u)\r\nret = pxa_init_dma_channel(pcdev, buf, dma, 1, CIBR1,\r\nsize_u, size_y);\r\nif (ret) {\r\ndev_err(dev, "DMA initialization for U failed\n");\r\ngoto fail;\r\n}\r\nif (size_v)\r\nret = pxa_init_dma_channel(pcdev, buf, dma, 2, CIBR2,\r\nsize_v, size_y + size_u);\r\nif (ret) {\r\ndev_err(dev, "DMA initialization for V failed\n");\r\ngoto fail;\r\n}\r\nvb->state = VIDEOBUF_PREPARED;\r\n}\r\nbuf->inwork = 0;\r\npxa_videobuf_set_actdma(pcdev, buf);\r\nreturn 0;\r\nfail:\r\nfree_buffer(vq, buf);\r\nout:\r\nbuf->inwork = 0;\r\nreturn ret;\r\n}\r\nstatic void pxa_dma_start_channels(struct pxa_camera_dev *pcdev)\r\n{\r\nint i;\r\nstruct pxa_buffer *active;\r\nactive = pcdev->active;\r\nfor (i = 0; i < pcdev->channels; i++) {\r\ndev_dbg(pcdev->soc_host.v4l2_dev.dev,\r\n"%s (channel=%d)\n", __func__, i);\r\ndma_async_issue_pending(pcdev->dma_chans[i]);\r\n}\r\n}\r\nstatic void pxa_dma_stop_channels(struct pxa_camera_dev *pcdev)\r\n{\r\nint i;\r\nfor (i = 0; i < pcdev->channels; i++) {\r\ndev_dbg(pcdev->soc_host.v4l2_dev.dev,\r\n"%s (channel=%d)\n", __func__, i);\r\ndmaengine_terminate_all(pcdev->dma_chans[i]);\r\n}\r\n}\r\nstatic void pxa_dma_add_tail_buf(struct pxa_camera_dev *pcdev,\r\nstruct pxa_buffer *buf)\r\n{\r\nint i;\r\nfor (i = 0; i < pcdev->channels; i++) {\r\nbuf->cookie[i] = dmaengine_submit(buf->descs[i]);\r\ndev_dbg(pcdev->soc_host.v4l2_dev.dev,\r\n"%s (channel=%d) : submit vb=%p cookie=%d\n",\r\n__func__, i, buf, buf->descs[i]->cookie);\r\n}\r\n}\r\nstatic void pxa_camera_start_capture(struct pxa_camera_dev *pcdev)\r\n{\r\nunsigned long cicr0;\r\ndev_dbg(pcdev->soc_host.v4l2_dev.dev, "%s\n", __func__);\r\n__raw_writel(__raw_readl(pcdev->base + CISR), pcdev->base + CISR);\r\ncicr0 = __raw_readl(pcdev->base + CICR0) | CICR0_ENB;\r\ncicr0 &= ~CICR0_EOFM;\r\n__raw_writel(cicr0, pcdev->base + CICR0);\r\n}\r\nstatic void pxa_camera_stop_capture(struct pxa_camera_dev *pcdev)\r\n{\r\nunsigned long cicr0;\r\npxa_dma_stop_channels(pcdev);\r\ncicr0 = __raw_readl(pcdev->base + CICR0) & ~CICR0_ENB;\r\n__raw_writel(cicr0, pcdev->base + CICR0);\r\npcdev->active = NULL;\r\ndev_dbg(pcdev->soc_host.v4l2_dev.dev, "%s\n", __func__);\r\n}\r\nstatic void pxa_videobuf_queue(struct videobuf_queue *vq,\r\nstruct videobuf_buffer *vb)\r\n{\r\nstruct soc_camera_device *icd = vq->priv_data;\r\nstruct soc_camera_host *ici = to_soc_camera_host(icd->parent);\r\nstruct pxa_camera_dev *pcdev = ici->priv;\r\nstruct pxa_buffer *buf = container_of(vb, struct pxa_buffer, vb);\r\ndev_dbg(icd->parent, "%s (vb=0x%p) 0x%08lx %d active=%p\n",\r\n__func__, vb, vb->baddr, vb->bsize, pcdev->active);\r\nlist_add_tail(&vb->queue, &pcdev->capture);\r\nvb->state = VIDEOBUF_ACTIVE;\r\npxa_dma_add_tail_buf(pcdev, buf);\r\nif (!pcdev->active)\r\npxa_camera_start_capture(pcdev);\r\n}\r\nstatic void pxa_videobuf_release(struct videobuf_queue *vq,\r\nstruct videobuf_buffer *vb)\r\n{\r\nstruct pxa_buffer *buf = container_of(vb, struct pxa_buffer, vb);\r\n#ifdef DEBUG\r\nstruct soc_camera_device *icd = vq->priv_data;\r\nstruct device *dev = icd->parent;\r\ndev_dbg(dev, "%s (vb=0x%p) 0x%08lx %d\n", __func__,\r\nvb, vb->baddr, vb->bsize);\r\nswitch (vb->state) {\r\ncase VIDEOBUF_ACTIVE:\r\ndev_dbg(dev, "%s (active)\n", __func__);\r\nbreak;\r\ncase VIDEOBUF_QUEUED:\r\ndev_dbg(dev, "%s (queued)\n", __func__);\r\nbreak;\r\ncase VIDEOBUF_PREPARED:\r\ndev_dbg(dev, "%s (prepared)\n", __func__);\r\nbreak;\r\ndefault:\r\ndev_dbg(dev, "%s (unknown)\n", __func__);\r\nbreak;\r\n}\r\n#endif\r\nfree_buffer(vq, buf);\r\n}\r\nstatic void pxa_camera_wakeup(struct pxa_camera_dev *pcdev,\r\nstruct videobuf_buffer *vb,\r\nstruct pxa_buffer *buf)\r\n{\r\nlist_del_init(&vb->queue);\r\nvb->state = VIDEOBUF_DONE;\r\nv4l2_get_timestamp(&vb->ts);\r\nvb->field_count++;\r\nwake_up(&vb->done);\r\ndev_dbg(pcdev->soc_host.v4l2_dev.dev, "%s dequeud buffer (vb=0x%p)\n",\r\n__func__, vb);\r\nif (list_empty(&pcdev->capture)) {\r\npxa_camera_stop_capture(pcdev);\r\nreturn;\r\n}\r\npcdev->active = list_entry(pcdev->capture.next,\r\nstruct pxa_buffer, vb.queue);\r\n}\r\nstatic void pxa_camera_check_link_miss(struct pxa_camera_dev *pcdev,\r\ndma_cookie_t last_submitted,\r\ndma_cookie_t last_issued)\r\n{\r\nbool is_dma_stopped = last_submitted != last_issued;\r\ndev_dbg(pcdev->soc_host.v4l2_dev.dev,\r\n"%s : top queued buffer=%p, is_dma_stopped=%d\n",\r\n__func__, pcdev->active, is_dma_stopped);\r\nif (pcdev->active && is_dma_stopped)\r\npxa_camera_start_capture(pcdev);\r\n}\r\nstatic void pxa_camera_dma_irq(struct pxa_camera_dev *pcdev,\r\nenum pxa_camera_active_dma act_dma)\r\n{\r\nstruct device *dev = pcdev->soc_host.v4l2_dev.dev;\r\nstruct pxa_buffer *buf, *last_buf;\r\nunsigned long flags;\r\nu32 camera_status, overrun;\r\nint chan;\r\nstruct videobuf_buffer *vb;\r\nenum dma_status last_status;\r\ndma_cookie_t last_issued;\r\nspin_lock_irqsave(&pcdev->lock, flags);\r\ncamera_status = __raw_readl(pcdev->base + CISR);\r\ndev_dbg(dev, "camera dma irq, cisr=0x%x dma=%d\n",\r\ncamera_status, act_dma);\r\noverrun = CISR_IFO_0;\r\nif (pcdev->channels == 3)\r\noverrun |= CISR_IFO_1 | CISR_IFO_2;\r\nif (!pcdev->active)\r\ngoto out;\r\nvb = &pcdev->active->vb;\r\nbuf = container_of(vb, struct pxa_buffer, vb);\r\nWARN_ON(buf->inwork || list_empty(&vb->queue));\r\nswitch (act_dma) {\r\ncase DMA_U:\r\nchan = 1;\r\nbreak;\r\ncase DMA_V:\r\nchan = 2;\r\nbreak;\r\ndefault:\r\nchan = 0;\r\nbreak;\r\n}\r\nlast_buf = list_entry(pcdev->capture.prev,\r\nstruct pxa_buffer, vb.queue);\r\nlast_status = dma_async_is_tx_complete(pcdev->dma_chans[chan],\r\nlast_buf->cookie[chan],\r\nNULL, &last_issued);\r\nif (camera_status & overrun &&\r\nlast_status != DMA_COMPLETE) {\r\ndev_dbg(dev, "FIFO overrun! CISR: %x\n",\r\ncamera_status);\r\npxa_camera_stop_capture(pcdev);\r\nlist_for_each_entry(buf, &pcdev->capture, vb.queue)\r\npxa_dma_add_tail_buf(pcdev, buf);\r\npxa_camera_start_capture(pcdev);\r\ngoto out;\r\n}\r\nbuf->active_dma &= ~act_dma;\r\nif (!buf->active_dma) {\r\npxa_camera_wakeup(pcdev, vb, buf);\r\npxa_camera_check_link_miss(pcdev, last_buf->cookie[chan],\r\nlast_issued);\r\n}\r\nout:\r\nspin_unlock_irqrestore(&pcdev->lock, flags);\r\n}\r\nstatic void pxa_camera_init_videobuf(struct videobuf_queue *q,\r\nstruct soc_camera_device *icd)\r\n{\r\nstruct soc_camera_host *ici = to_soc_camera_host(icd->parent);\r\nstruct pxa_camera_dev *pcdev = ici->priv;\r\nvideobuf_queue_sg_init(q, &pxa_videobuf_ops, NULL, &pcdev->lock,\r\nV4L2_BUF_TYPE_VIDEO_CAPTURE, V4L2_FIELD_NONE,\r\nsizeof(struct pxa_buffer), icd, &ici->host_lock);\r\n}\r\nstatic u32 mclk_get_divisor(struct platform_device *pdev,\r\nstruct pxa_camera_dev *pcdev)\r\n{\r\nunsigned long mclk = pcdev->mclk;\r\nstruct device *dev = &pdev->dev;\r\nu32 div;\r\nunsigned long lcdclk;\r\nlcdclk = clk_get_rate(pcdev->clk);\r\npcdev->ciclk = lcdclk;\r\nif (mclk > lcdclk / 4) {\r\nmclk = lcdclk / 4;\r\ndev_warn(dev, "Limiting master clock to %lu\n", mclk);\r\n}\r\ndiv = (lcdclk + 2 * mclk - 1) / (2 * mclk) - 1;\r\nif (pcdev->platform_flags & PXA_CAMERA_MCLK_EN)\r\npcdev->mclk = lcdclk / (2 * (div + 1));\r\ndev_dbg(dev, "LCD clock %luHz, target freq %luHz, divisor %u\n",\r\nlcdclk, mclk, div);\r\nreturn div;\r\n}\r\nstatic void recalculate_fifo_timeout(struct pxa_camera_dev *pcdev,\r\nunsigned long pclk)\r\n{\r\nu32 ciclk_per_pixel = pcdev->ciclk / pclk + 1;\r\n__raw_writel(ciclk_per_pixel, pcdev->base + CITOR);\r\n}\r\nstatic void pxa_camera_activate(struct pxa_camera_dev *pcdev)\r\n{\r\nu32 cicr4 = 0;\r\n__raw_writel(0x3ff, pcdev->base + CICR0);\r\nif (pcdev->platform_flags & PXA_CAMERA_PCLK_EN)\r\ncicr4 |= CICR4_PCLK_EN;\r\nif (pcdev->platform_flags & PXA_CAMERA_MCLK_EN)\r\ncicr4 |= CICR4_MCLK_EN;\r\nif (pcdev->platform_flags & PXA_CAMERA_PCP)\r\ncicr4 |= CICR4_PCP;\r\nif (pcdev->platform_flags & PXA_CAMERA_HSP)\r\ncicr4 |= CICR4_HSP;\r\nif (pcdev->platform_flags & PXA_CAMERA_VSP)\r\ncicr4 |= CICR4_VSP;\r\n__raw_writel(pcdev->mclk_divisor | cicr4, pcdev->base + CICR4);\r\nif (pcdev->platform_flags & PXA_CAMERA_MCLK_EN)\r\nrecalculate_fifo_timeout(pcdev, pcdev->mclk);\r\nelse\r\nrecalculate_fifo_timeout(pcdev, 13000000);\r\nclk_prepare_enable(pcdev->clk);\r\n}\r\nstatic void pxa_camera_deactivate(struct pxa_camera_dev *pcdev)\r\n{\r\nclk_disable_unprepare(pcdev->clk);\r\n}\r\nstatic void pxa_camera_eof(unsigned long arg)\r\n{\r\nstruct pxa_camera_dev *pcdev = (struct pxa_camera_dev *)arg;\r\nunsigned long cifr;\r\nstruct pxa_buffer *buf;\r\nstruct videobuf_buffer *vb;\r\ndev_dbg(pcdev->soc_host.v4l2_dev.dev,\r\n"Camera interrupt status 0x%x\n",\r\n__raw_readl(pcdev->base + CISR));\r\ncifr = __raw_readl(pcdev->base + CIFR) | CIFR_RESET_F;\r\n__raw_writel(cifr, pcdev->base + CIFR);\r\npcdev->active = list_first_entry(&pcdev->capture,\r\nstruct pxa_buffer, vb.queue);\r\nvb = &pcdev->active->vb;\r\nbuf = container_of(vb, struct pxa_buffer, vb);\r\npxa_videobuf_set_actdma(pcdev, buf);\r\npxa_dma_start_channels(pcdev);\r\n}\r\nstatic irqreturn_t pxa_camera_irq(int irq, void *data)\r\n{\r\nstruct pxa_camera_dev *pcdev = data;\r\nunsigned long status, cicr0;\r\nstatus = __raw_readl(pcdev->base + CISR);\r\ndev_dbg(pcdev->soc_host.v4l2_dev.dev,\r\n"Camera interrupt status 0x%lx\n", status);\r\nif (!status)\r\nreturn IRQ_NONE;\r\n__raw_writel(status, pcdev->base + CISR);\r\nif (status & CISR_EOF) {\r\ncicr0 = __raw_readl(pcdev->base + CICR0) | CICR0_EOFM;\r\n__raw_writel(cicr0, pcdev->base + CICR0);\r\ntasklet_schedule(&pcdev->task_eof);\r\n}\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int pxa_camera_add_device(struct soc_camera_device *icd)\r\n{\r\ndev_info(icd->parent, "PXA Camera driver attached to camera %d\n",\r\nicd->devnum);\r\nreturn 0;\r\n}\r\nstatic void pxa_camera_remove_device(struct soc_camera_device *icd)\r\n{\r\ndev_info(icd->parent, "PXA Camera driver detached from camera %d\n",\r\nicd->devnum);\r\n}\r\nstatic int pxa_camera_clock_start(struct soc_camera_host *ici)\r\n{\r\nstruct pxa_camera_dev *pcdev = ici->priv;\r\npxa_camera_activate(pcdev);\r\nreturn 0;\r\n}\r\nstatic void pxa_camera_clock_stop(struct soc_camera_host *ici)\r\n{\r\nstruct pxa_camera_dev *pcdev = ici->priv;\r\n__raw_writel(0x3ff, pcdev->base + CICR0);\r\npxa_dma_stop_channels(pcdev);\r\npxa_camera_deactivate(pcdev);\r\n}\r\nstatic int test_platform_param(struct pxa_camera_dev *pcdev,\r\nunsigned char buswidth, unsigned long *flags)\r\n{\r\n*flags = (pcdev->platform_flags & PXA_CAMERA_MASTER ?\r\nV4L2_MBUS_MASTER : V4L2_MBUS_SLAVE) |\r\nV4L2_MBUS_HSYNC_ACTIVE_HIGH |\r\nV4L2_MBUS_HSYNC_ACTIVE_LOW |\r\nV4L2_MBUS_VSYNC_ACTIVE_HIGH |\r\nV4L2_MBUS_VSYNC_ACTIVE_LOW |\r\nV4L2_MBUS_DATA_ACTIVE_HIGH |\r\nV4L2_MBUS_PCLK_SAMPLE_RISING |\r\nV4L2_MBUS_PCLK_SAMPLE_FALLING;\r\nif ((1 << (buswidth - 1)) & pcdev->width_flags)\r\nreturn 0;\r\nreturn -EINVAL;\r\n}\r\nstatic void pxa_camera_setup_cicr(struct soc_camera_device *icd,\r\nunsigned long flags, __u32 pixfmt)\r\n{\r\nstruct soc_camera_host *ici = to_soc_camera_host(icd->parent);\r\nstruct pxa_camera_dev *pcdev = ici->priv;\r\nstruct v4l2_subdev *sd = soc_camera_to_subdev(icd);\r\nunsigned long dw, bpp;\r\nu32 cicr0, cicr1, cicr2, cicr3, cicr4 = 0, y_skip_top;\r\nint ret = v4l2_subdev_call(sd, sensor, g_skip_top_lines, &y_skip_top);\r\nif (ret < 0)\r\ny_skip_top = 0;\r\nswitch (icd->current_fmt->host_fmt->bits_per_sample) {\r\ncase 10:\r\ndw = 4;\r\nbpp = 0x40;\r\nbreak;\r\ncase 9:\r\ndw = 3;\r\nbpp = 0x20;\r\nbreak;\r\ndefault:\r\ncase 8:\r\ndw = 2;\r\nbpp = 0;\r\n}\r\nif (pcdev->platform_flags & PXA_CAMERA_PCLK_EN)\r\ncicr4 |= CICR4_PCLK_EN;\r\nif (pcdev->platform_flags & PXA_CAMERA_MCLK_EN)\r\ncicr4 |= CICR4_MCLK_EN;\r\nif (flags & V4L2_MBUS_PCLK_SAMPLE_FALLING)\r\ncicr4 |= CICR4_PCP;\r\nif (flags & V4L2_MBUS_HSYNC_ACTIVE_LOW)\r\ncicr4 |= CICR4_HSP;\r\nif (flags & V4L2_MBUS_VSYNC_ACTIVE_LOW)\r\ncicr4 |= CICR4_VSP;\r\ncicr0 = __raw_readl(pcdev->base + CICR0);\r\nif (cicr0 & CICR0_ENB)\r\n__raw_writel(cicr0 & ~CICR0_ENB, pcdev->base + CICR0);\r\ncicr1 = CICR1_PPL_VAL(icd->user_width - 1) | bpp | dw;\r\nswitch (pixfmt) {\r\ncase V4L2_PIX_FMT_YUV422P:\r\npcdev->channels = 3;\r\ncicr1 |= CICR1_YCBCR_F;\r\ncase V4L2_PIX_FMT_UYVY:\r\ncase V4L2_PIX_FMT_VYUY:\r\ncase V4L2_PIX_FMT_YUYV:\r\ncase V4L2_PIX_FMT_YVYU:\r\ncicr1 |= CICR1_COLOR_SP_VAL(2);\r\nbreak;\r\ncase V4L2_PIX_FMT_RGB555:\r\ncicr1 |= CICR1_RGB_BPP_VAL(1) | CICR1_RGBT_CONV_VAL(2) |\r\nCICR1_TBIT | CICR1_COLOR_SP_VAL(1);\r\nbreak;\r\ncase V4L2_PIX_FMT_RGB565:\r\ncicr1 |= CICR1_COLOR_SP_VAL(1) | CICR1_RGB_BPP_VAL(2);\r\nbreak;\r\n}\r\ncicr2 = 0;\r\ncicr3 = CICR3_LPF_VAL(icd->user_height - 1) |\r\nCICR3_BFW_VAL(min((u32)255, y_skip_top));\r\ncicr4 |= pcdev->mclk_divisor;\r\n__raw_writel(cicr1, pcdev->base + CICR1);\r\n__raw_writel(cicr2, pcdev->base + CICR2);\r\n__raw_writel(cicr3, pcdev->base + CICR3);\r\n__raw_writel(cicr4, pcdev->base + CICR4);\r\ncicr0 = (cicr0 & CICR0_ENB) | (pcdev->platform_flags & PXA_CAMERA_MASTER ?\r\nCICR0_SIM_MP : (CICR0_SL_CAP_EN | CICR0_SIM_SP));\r\ncicr0 |= CICR0_DMAEN | CICR0_IRQ_MASK;\r\n__raw_writel(cicr0, pcdev->base + CICR0);\r\n}\r\nstatic int pxa_camera_set_bus_param(struct soc_camera_device *icd)\r\n{\r\nstruct v4l2_subdev *sd = soc_camera_to_subdev(icd);\r\nstruct soc_camera_host *ici = to_soc_camera_host(icd->parent);\r\nstruct pxa_camera_dev *pcdev = ici->priv;\r\nstruct v4l2_mbus_config cfg = {.type = V4L2_MBUS_PARALLEL,};\r\nu32 pixfmt = icd->current_fmt->host_fmt->fourcc;\r\nunsigned long bus_flags, common_flags;\r\nint ret;\r\nstruct pxa_cam *cam = icd->host_priv;\r\nret = test_platform_param(pcdev, icd->current_fmt->host_fmt->bits_per_sample,\r\n&bus_flags);\r\nif (ret < 0)\r\nreturn ret;\r\nret = v4l2_subdev_call(sd, video, g_mbus_config, &cfg);\r\nif (!ret) {\r\ncommon_flags = soc_mbus_config_compatible(&cfg,\r\nbus_flags);\r\nif (!common_flags) {\r\ndev_warn(icd->parent,\r\n"Flags incompatible: camera 0x%x, host 0x%lx\n",\r\ncfg.flags, bus_flags);\r\nreturn -EINVAL;\r\n}\r\n} else if (ret != -ENOIOCTLCMD) {\r\nreturn ret;\r\n} else {\r\ncommon_flags = bus_flags;\r\n}\r\npcdev->channels = 1;\r\nif ((common_flags & V4L2_MBUS_HSYNC_ACTIVE_HIGH) &&\r\n(common_flags & V4L2_MBUS_HSYNC_ACTIVE_LOW)) {\r\nif (pcdev->platform_flags & PXA_CAMERA_HSP)\r\ncommon_flags &= ~V4L2_MBUS_HSYNC_ACTIVE_HIGH;\r\nelse\r\ncommon_flags &= ~V4L2_MBUS_HSYNC_ACTIVE_LOW;\r\n}\r\nif ((common_flags & V4L2_MBUS_VSYNC_ACTIVE_HIGH) &&\r\n(common_flags & V4L2_MBUS_VSYNC_ACTIVE_LOW)) {\r\nif (pcdev->platform_flags & PXA_CAMERA_VSP)\r\ncommon_flags &= ~V4L2_MBUS_VSYNC_ACTIVE_HIGH;\r\nelse\r\ncommon_flags &= ~V4L2_MBUS_VSYNC_ACTIVE_LOW;\r\n}\r\nif ((common_flags & V4L2_MBUS_PCLK_SAMPLE_RISING) &&\r\n(common_flags & V4L2_MBUS_PCLK_SAMPLE_FALLING)) {\r\nif (pcdev->platform_flags & PXA_CAMERA_PCP)\r\ncommon_flags &= ~V4L2_MBUS_PCLK_SAMPLE_RISING;\r\nelse\r\ncommon_flags &= ~V4L2_MBUS_PCLK_SAMPLE_FALLING;\r\n}\r\ncfg.flags = common_flags;\r\nret = v4l2_subdev_call(sd, video, s_mbus_config, &cfg);\r\nif (ret < 0 && ret != -ENOIOCTLCMD) {\r\ndev_dbg(icd->parent, "camera s_mbus_config(0x%lx) returned %d\n",\r\ncommon_flags, ret);\r\nreturn ret;\r\n}\r\ncam->flags = common_flags;\r\npxa_camera_setup_cicr(icd, common_flags, pixfmt);\r\nreturn 0;\r\n}\r\nstatic int pxa_camera_try_bus_param(struct soc_camera_device *icd,\r\nunsigned char buswidth)\r\n{\r\nstruct v4l2_subdev *sd = soc_camera_to_subdev(icd);\r\nstruct soc_camera_host *ici = to_soc_camera_host(icd->parent);\r\nstruct pxa_camera_dev *pcdev = ici->priv;\r\nstruct v4l2_mbus_config cfg = {.type = V4L2_MBUS_PARALLEL,};\r\nunsigned long bus_flags, common_flags;\r\nint ret = test_platform_param(pcdev, buswidth, &bus_flags);\r\nif (ret < 0)\r\nreturn ret;\r\nret = v4l2_subdev_call(sd, video, g_mbus_config, &cfg);\r\nif (!ret) {\r\ncommon_flags = soc_mbus_config_compatible(&cfg,\r\nbus_flags);\r\nif (!common_flags) {\r\ndev_warn(icd->parent,\r\n"Flags incompatible: camera 0x%x, host 0x%lx\n",\r\ncfg.flags, bus_flags);\r\nreturn -EINVAL;\r\n}\r\n} else if (ret == -ENOIOCTLCMD) {\r\nret = 0;\r\n}\r\nreturn ret;\r\n}\r\nstatic bool pxa_camera_packing_supported(const struct soc_mbus_pixelfmt *fmt)\r\n{\r\nreturn fmt->packing == SOC_MBUS_PACKING_NONE ||\r\n(fmt->bits_per_sample == 8 &&\r\nfmt->packing == SOC_MBUS_PACKING_2X8_PADHI) ||\r\n(fmt->bits_per_sample > 8 &&\r\nfmt->packing == SOC_MBUS_PACKING_EXTEND16);\r\n}\r\nstatic int pxa_camera_get_formats(struct soc_camera_device *icd, unsigned int idx,\r\nstruct soc_camera_format_xlate *xlate)\r\n{\r\nstruct v4l2_subdev *sd = soc_camera_to_subdev(icd);\r\nstruct device *dev = icd->parent;\r\nint formats = 0, ret;\r\nstruct pxa_cam *cam;\r\nstruct v4l2_subdev_mbus_code_enum code = {\r\n.which = V4L2_SUBDEV_FORMAT_ACTIVE,\r\n.index = idx,\r\n};\r\nconst struct soc_mbus_pixelfmt *fmt;\r\nret = v4l2_subdev_call(sd, pad, enum_mbus_code, NULL, &code);\r\nif (ret < 0)\r\nreturn 0;\r\nfmt = soc_mbus_get_fmtdesc(code.code);\r\nif (!fmt) {\r\ndev_err(dev, "Invalid format code #%u: %d\n", idx, code.code);\r\nreturn 0;\r\n}\r\nret = pxa_camera_try_bus_param(icd, fmt->bits_per_sample);\r\nif (ret < 0)\r\nreturn 0;\r\nif (!icd->host_priv) {\r\ncam = kzalloc(sizeof(*cam), GFP_KERNEL);\r\nif (!cam)\r\nreturn -ENOMEM;\r\nicd->host_priv = cam;\r\n} else {\r\ncam = icd->host_priv;\r\n}\r\nswitch (code.code) {\r\ncase MEDIA_BUS_FMT_UYVY8_2X8:\r\nformats++;\r\nif (xlate) {\r\nxlate->host_fmt = &pxa_camera_formats[0];\r\nxlate->code = code.code;\r\nxlate++;\r\ndev_dbg(dev, "Providing format %s using code %d\n",\r\npxa_camera_formats[0].name, code.code);\r\n}\r\ncase MEDIA_BUS_FMT_VYUY8_2X8:\r\ncase MEDIA_BUS_FMT_YUYV8_2X8:\r\ncase MEDIA_BUS_FMT_YVYU8_2X8:\r\ncase MEDIA_BUS_FMT_RGB565_2X8_LE:\r\ncase MEDIA_BUS_FMT_RGB555_2X8_PADHI_LE:\r\nif (xlate)\r\ndev_dbg(dev, "Providing format %s packed\n",\r\nfmt->name);\r\nbreak;\r\ndefault:\r\nif (!pxa_camera_packing_supported(fmt))\r\nreturn 0;\r\nif (xlate)\r\ndev_dbg(dev,\r\n"Providing format %s in pass-through mode\n",\r\nfmt->name);\r\n}\r\nformats++;\r\nif (xlate) {\r\nxlate->host_fmt = fmt;\r\nxlate->code = code.code;\r\nxlate++;\r\n}\r\nreturn formats;\r\n}\r\nstatic void pxa_camera_put_formats(struct soc_camera_device *icd)\r\n{\r\nkfree(icd->host_priv);\r\nicd->host_priv = NULL;\r\n}\r\nstatic int pxa_camera_check_frame(u32 width, u32 height)\r\n{\r\nreturn height < 32 || height > 2048 || width < 48 || width > 2048 ||\r\n(width & 0x01);\r\n}\r\nstatic int pxa_camera_set_crop(struct soc_camera_device *icd,\r\nconst struct v4l2_crop *a)\r\n{\r\nconst struct v4l2_rect *rect = &a->c;\r\nstruct device *dev = icd->parent;\r\nstruct soc_camera_host *ici = to_soc_camera_host(dev);\r\nstruct pxa_camera_dev *pcdev = ici->priv;\r\nstruct v4l2_subdev *sd = soc_camera_to_subdev(icd);\r\nstruct soc_camera_sense sense = {\r\n.master_clock = pcdev->mclk,\r\n.pixel_clock_max = pcdev->ciclk / 4,\r\n};\r\nstruct v4l2_subdev_format fmt = {\r\n.which = V4L2_SUBDEV_FORMAT_ACTIVE,\r\n};\r\nstruct v4l2_mbus_framefmt *mf = &fmt.format;\r\nstruct pxa_cam *cam = icd->host_priv;\r\nu32 fourcc = icd->current_fmt->host_fmt->fourcc;\r\nint ret;\r\nif (pcdev->platform_flags & PXA_CAMERA_PCLK_EN)\r\nicd->sense = &sense;\r\nret = v4l2_subdev_call(sd, video, s_crop, a);\r\nicd->sense = NULL;\r\nif (ret < 0) {\r\ndev_warn(dev, "Failed to crop to %ux%u@%u:%u\n",\r\nrect->width, rect->height, rect->left, rect->top);\r\nreturn ret;\r\n}\r\nret = v4l2_subdev_call(sd, pad, get_fmt, NULL, &fmt);\r\nif (ret < 0)\r\nreturn ret;\r\nif (pxa_camera_check_frame(mf->width, mf->height)) {\r\nv4l_bound_align_image(&mf->width, 48, 2048, 1,\r\n&mf->height, 32, 2048, 0,\r\nfourcc == V4L2_PIX_FMT_YUV422P ? 4 : 0);\r\nret = v4l2_subdev_call(sd, pad, set_fmt, NULL, &fmt);\r\nif (ret < 0)\r\nreturn ret;\r\nif (pxa_camera_check_frame(mf->width, mf->height)) {\r\ndev_warn(icd->parent,\r\n"Inconsistent state. Use S_FMT to repair\n");\r\nreturn -EINVAL;\r\n}\r\n}\r\nif (sense.flags & SOCAM_SENSE_PCLK_CHANGED) {\r\nif (sense.pixel_clock > sense.pixel_clock_max) {\r\ndev_err(dev,\r\n"pixel clock %lu set by the camera too high!",\r\nsense.pixel_clock);\r\nreturn -EIO;\r\n}\r\nrecalculate_fifo_timeout(pcdev, sense.pixel_clock);\r\n}\r\nicd->user_width = mf->width;\r\nicd->user_height = mf->height;\r\npxa_camera_setup_cicr(icd, cam->flags, fourcc);\r\nreturn ret;\r\n}\r\nstatic int pxa_camera_set_fmt(struct soc_camera_device *icd,\r\nstruct v4l2_format *f)\r\n{\r\nstruct device *dev = icd->parent;\r\nstruct soc_camera_host *ici = to_soc_camera_host(dev);\r\nstruct pxa_camera_dev *pcdev = ici->priv;\r\nstruct v4l2_subdev *sd = soc_camera_to_subdev(icd);\r\nconst struct soc_camera_format_xlate *xlate = NULL;\r\nstruct soc_camera_sense sense = {\r\n.master_clock = pcdev->mclk,\r\n.pixel_clock_max = pcdev->ciclk / 4,\r\n};\r\nstruct v4l2_pix_format *pix = &f->fmt.pix;\r\nstruct v4l2_subdev_format format = {\r\n.which = V4L2_SUBDEV_FORMAT_ACTIVE,\r\n};\r\nstruct v4l2_mbus_framefmt *mf = &format.format;\r\nint ret;\r\nxlate = soc_camera_xlate_by_fourcc(icd, pix->pixelformat);\r\nif (!xlate) {\r\ndev_warn(dev, "Format %x not found\n", pix->pixelformat);\r\nreturn -EINVAL;\r\n}\r\nif (pcdev->platform_flags & PXA_CAMERA_PCLK_EN)\r\nicd->sense = &sense;\r\nmf->width = pix->width;\r\nmf->height = pix->height;\r\nmf->field = pix->field;\r\nmf->colorspace = pix->colorspace;\r\nmf->code = xlate->code;\r\nret = v4l2_subdev_call(sd, pad, set_fmt, NULL, &format);\r\nif (mf->code != xlate->code)\r\nreturn -EINVAL;\r\nicd->sense = NULL;\r\nif (ret < 0) {\r\ndev_warn(dev, "Failed to configure for format %x\n",\r\npix->pixelformat);\r\n} else if (pxa_camera_check_frame(mf->width, mf->height)) {\r\ndev_warn(dev,\r\n"Camera driver produced an unsupported frame %dx%d\n",\r\nmf->width, mf->height);\r\nret = -EINVAL;\r\n} else if (sense.flags & SOCAM_SENSE_PCLK_CHANGED) {\r\nif (sense.pixel_clock > sense.pixel_clock_max) {\r\ndev_err(dev,\r\n"pixel clock %lu set by the camera too high!",\r\nsense.pixel_clock);\r\nreturn -EIO;\r\n}\r\nrecalculate_fifo_timeout(pcdev, sense.pixel_clock);\r\n}\r\nif (ret < 0)\r\nreturn ret;\r\npix->width = mf->width;\r\npix->height = mf->height;\r\npix->field = mf->field;\r\npix->colorspace = mf->colorspace;\r\nicd->current_fmt = xlate;\r\nreturn ret;\r\n}\r\nstatic int pxa_camera_try_fmt(struct soc_camera_device *icd,\r\nstruct v4l2_format *f)\r\n{\r\nstruct v4l2_subdev *sd = soc_camera_to_subdev(icd);\r\nconst struct soc_camera_format_xlate *xlate;\r\nstruct v4l2_pix_format *pix = &f->fmt.pix;\r\nstruct v4l2_subdev_pad_config pad_cfg;\r\nstruct v4l2_subdev_format format = {\r\n.which = V4L2_SUBDEV_FORMAT_TRY,\r\n};\r\nstruct v4l2_mbus_framefmt *mf = &format.format;\r\n__u32 pixfmt = pix->pixelformat;\r\nint ret;\r\nxlate = soc_camera_xlate_by_fourcc(icd, pixfmt);\r\nif (!xlate) {\r\ndev_warn(icd->parent, "Format %x not found\n", pixfmt);\r\nreturn -EINVAL;\r\n}\r\nv4l_bound_align_image(&pix->width, 48, 2048, 1,\r\n&pix->height, 32, 2048, 0,\r\npixfmt == V4L2_PIX_FMT_YUV422P ? 4 : 0);\r\nmf->width = pix->width;\r\nmf->height = pix->height;\r\nmf->field = V4L2_FIELD_NONE;\r\nmf->colorspace = pix->colorspace;\r\nmf->code = xlate->code;\r\nret = v4l2_subdev_call(sd, pad, set_fmt, &pad_cfg, &format);\r\nif (ret < 0)\r\nreturn ret;\r\npix->width = mf->width;\r\npix->height = mf->height;\r\npix->colorspace = mf->colorspace;\r\nswitch (mf->field) {\r\ncase V4L2_FIELD_ANY:\r\ncase V4L2_FIELD_NONE:\r\npix->field = V4L2_FIELD_NONE;\r\nbreak;\r\ndefault:\r\ndev_err(icd->parent, "Field type %d unsupported.\n",\r\nmf->field);\r\nreturn -EINVAL;\r\n}\r\nreturn ret;\r\n}\r\nstatic int pxa_camera_reqbufs(struct soc_camera_device *icd,\r\nstruct v4l2_requestbuffers *p)\r\n{\r\nint i;\r\nfor (i = 0; i < p->count; i++) {\r\nstruct pxa_buffer *buf = container_of(icd->vb_vidq.bufs[i],\r\nstruct pxa_buffer, vb);\r\nbuf->inwork = 0;\r\nINIT_LIST_HEAD(&buf->vb.queue);\r\n}\r\nreturn 0;\r\n}\r\nstatic unsigned int pxa_camera_poll(struct file *file, poll_table *pt)\r\n{\r\nstruct soc_camera_device *icd = file->private_data;\r\nstruct pxa_buffer *buf;\r\nbuf = list_entry(icd->vb_vidq.stream.next, struct pxa_buffer,\r\nvb.stream);\r\npoll_wait(file, &buf->vb.done, pt);\r\nif (buf->vb.state == VIDEOBUF_DONE ||\r\nbuf->vb.state == VIDEOBUF_ERROR)\r\nreturn POLLIN|POLLRDNORM;\r\nreturn 0;\r\n}\r\nstatic int pxa_camera_querycap(struct soc_camera_host *ici,\r\nstruct v4l2_capability *cap)\r\n{\r\nstrlcpy(cap->card, pxa_cam_driver_description, sizeof(cap->card));\r\ncap->device_caps = V4L2_CAP_VIDEO_CAPTURE | V4L2_CAP_STREAMING;\r\ncap->capabilities = cap->device_caps | V4L2_CAP_DEVICE_CAPS;\r\nreturn 0;\r\n}\r\nstatic int pxa_camera_suspend(struct device *dev)\r\n{\r\nstruct soc_camera_host *ici = to_soc_camera_host(dev);\r\nstruct pxa_camera_dev *pcdev = ici->priv;\r\nint i = 0, ret = 0;\r\npcdev->save_cicr[i++] = __raw_readl(pcdev->base + CICR0);\r\npcdev->save_cicr[i++] = __raw_readl(pcdev->base + CICR1);\r\npcdev->save_cicr[i++] = __raw_readl(pcdev->base + CICR2);\r\npcdev->save_cicr[i++] = __raw_readl(pcdev->base + CICR3);\r\npcdev->save_cicr[i++] = __raw_readl(pcdev->base + CICR4);\r\nif (pcdev->soc_host.icd) {\r\nstruct v4l2_subdev *sd = soc_camera_to_subdev(pcdev->soc_host.icd);\r\nret = v4l2_subdev_call(sd, core, s_power, 0);\r\nif (ret == -ENOIOCTLCMD)\r\nret = 0;\r\n}\r\nreturn ret;\r\n}\r\nstatic int pxa_camera_resume(struct device *dev)\r\n{\r\nstruct soc_camera_host *ici = to_soc_camera_host(dev);\r\nstruct pxa_camera_dev *pcdev = ici->priv;\r\nint i = 0, ret = 0;\r\n__raw_writel(pcdev->save_cicr[i++] & ~CICR0_ENB, pcdev->base + CICR0);\r\n__raw_writel(pcdev->save_cicr[i++], pcdev->base + CICR1);\r\n__raw_writel(pcdev->save_cicr[i++], pcdev->base + CICR2);\r\n__raw_writel(pcdev->save_cicr[i++], pcdev->base + CICR3);\r\n__raw_writel(pcdev->save_cicr[i++], pcdev->base + CICR4);\r\nif (pcdev->soc_host.icd) {\r\nstruct v4l2_subdev *sd = soc_camera_to_subdev(pcdev->soc_host.icd);\r\nret = v4l2_subdev_call(sd, core, s_power, 1);\r\nif (ret == -ENOIOCTLCMD)\r\nret = 0;\r\n}\r\nif (!ret && pcdev->active)\r\npxa_camera_start_capture(pcdev);\r\nreturn ret;\r\n}\r\nstatic int pxa_camera_pdata_from_dt(struct device *dev,\r\nstruct pxa_camera_dev *pcdev)\r\n{\r\nu32 mclk_rate;\r\nstruct device_node *np = dev->of_node;\r\nstruct v4l2_of_endpoint ep;\r\nint err = of_property_read_u32(np, "clock-frequency",\r\n&mclk_rate);\r\nif (!err) {\r\npcdev->platform_flags |= PXA_CAMERA_MCLK_EN;\r\npcdev->mclk = mclk_rate;\r\n}\r\nnp = of_graph_get_next_endpoint(np, NULL);\r\nif (!np) {\r\ndev_err(dev, "could not find endpoint\n");\r\nreturn -EINVAL;\r\n}\r\nerr = v4l2_of_parse_endpoint(np, &ep);\r\nif (err) {\r\ndev_err(dev, "could not parse endpoint\n");\r\ngoto out;\r\n}\r\nswitch (ep.bus.parallel.bus_width) {\r\ncase 4:\r\npcdev->platform_flags |= PXA_CAMERA_DATAWIDTH_4;\r\nbreak;\r\ncase 5:\r\npcdev->platform_flags |= PXA_CAMERA_DATAWIDTH_5;\r\nbreak;\r\ncase 8:\r\npcdev->platform_flags |= PXA_CAMERA_DATAWIDTH_8;\r\nbreak;\r\ncase 9:\r\npcdev->platform_flags |= PXA_CAMERA_DATAWIDTH_9;\r\nbreak;\r\ncase 10:\r\npcdev->platform_flags |= PXA_CAMERA_DATAWIDTH_10;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nif (ep.bus.parallel.flags & V4L2_MBUS_MASTER)\r\npcdev->platform_flags |= PXA_CAMERA_MASTER;\r\nif (ep.bus.parallel.flags & V4L2_MBUS_HSYNC_ACTIVE_HIGH)\r\npcdev->platform_flags |= PXA_CAMERA_HSP;\r\nif (ep.bus.parallel.flags & V4L2_MBUS_VSYNC_ACTIVE_HIGH)\r\npcdev->platform_flags |= PXA_CAMERA_VSP;\r\nif (ep.bus.parallel.flags & V4L2_MBUS_PCLK_SAMPLE_RISING)\r\npcdev->platform_flags |= PXA_CAMERA_PCLK_EN | PXA_CAMERA_PCP;\r\nif (ep.bus.parallel.flags & V4L2_MBUS_PCLK_SAMPLE_FALLING)\r\npcdev->platform_flags |= PXA_CAMERA_PCLK_EN;\r\nout:\r\nof_node_put(np);\r\nreturn err;\r\n}\r\nstatic int pxa_camera_probe(struct platform_device *pdev)\r\n{\r\nstruct pxa_camera_dev *pcdev;\r\nstruct resource *res;\r\nvoid __iomem *base;\r\nstruct dma_slave_config config = {\r\n.src_addr_width = 0,\r\n.src_maxburst = 8,\r\n.direction = DMA_DEV_TO_MEM,\r\n};\r\ndma_cap_mask_t mask;\r\nstruct pxad_param params;\r\nint irq;\r\nint err = 0, i;\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nirq = platform_get_irq(pdev, 0);\r\nif (!res || irq < 0)\r\nreturn -ENODEV;\r\npcdev = devm_kzalloc(&pdev->dev, sizeof(*pcdev), GFP_KERNEL);\r\nif (!pcdev) {\r\ndev_err(&pdev->dev, "Could not allocate pcdev\n");\r\nreturn -ENOMEM;\r\n}\r\npcdev->clk = devm_clk_get(&pdev->dev, NULL);\r\nif (IS_ERR(pcdev->clk))\r\nreturn PTR_ERR(pcdev->clk);\r\npcdev->res = res;\r\npcdev->pdata = pdev->dev.platform_data;\r\nif (&pdev->dev.of_node && !pcdev->pdata) {\r\nerr = pxa_camera_pdata_from_dt(&pdev->dev, pcdev);\r\n} else {\r\npcdev->platform_flags = pcdev->pdata->flags;\r\npcdev->mclk = pcdev->pdata->mclk_10khz * 10000;\r\n}\r\nif (err < 0)\r\nreturn err;\r\nif (!(pcdev->platform_flags & (PXA_CAMERA_DATAWIDTH_8 |\r\nPXA_CAMERA_DATAWIDTH_9 | PXA_CAMERA_DATAWIDTH_10))) {\r\ndev_warn(&pdev->dev, "WARNING! Platform hasn't set available "\r\n"data widths, using default 10 bit\n");\r\npcdev->platform_flags |= PXA_CAMERA_DATAWIDTH_10;\r\n}\r\nif (pcdev->platform_flags & PXA_CAMERA_DATAWIDTH_8)\r\npcdev->width_flags = 1 << 7;\r\nif (pcdev->platform_flags & PXA_CAMERA_DATAWIDTH_9)\r\npcdev->width_flags |= 1 << 8;\r\nif (pcdev->platform_flags & PXA_CAMERA_DATAWIDTH_10)\r\npcdev->width_flags |= 1 << 9;\r\nif (!pcdev->mclk) {\r\ndev_warn(&pdev->dev,\r\n"mclk == 0! Please, fix your platform data. "\r\n"Using default 20MHz\n");\r\npcdev->mclk = 20000000;\r\n}\r\npcdev->mclk_divisor = mclk_get_divisor(pdev, pcdev);\r\nINIT_LIST_HEAD(&pcdev->capture);\r\nspin_lock_init(&pcdev->lock);\r\nbase = devm_ioremap_resource(&pdev->dev, res);\r\nif (IS_ERR(base))\r\nreturn PTR_ERR(base);\r\npcdev->irq = irq;\r\npcdev->base = base;\r\ndma_cap_zero(mask);\r\ndma_cap_set(DMA_SLAVE, mask);\r\ndma_cap_set(DMA_PRIVATE, mask);\r\nparams.prio = 0;\r\nparams.drcmr = 68;\r\npcdev->dma_chans[0] =\r\ndma_request_slave_channel_compat(mask, pxad_filter_fn,\r\n&params, &pdev->dev, "CI_Y");\r\nif (!pcdev->dma_chans[0]) {\r\ndev_err(&pdev->dev, "Can't request DMA for Y\n");\r\nreturn -ENODEV;\r\n}\r\nparams.drcmr = 69;\r\npcdev->dma_chans[1] =\r\ndma_request_slave_channel_compat(mask, pxad_filter_fn,\r\n&params, &pdev->dev, "CI_U");\r\nif (!pcdev->dma_chans[1]) {\r\ndev_err(&pdev->dev, "Can't request DMA for Y\n");\r\ngoto exit_free_dma_y;\r\n}\r\nparams.drcmr = 70;\r\npcdev->dma_chans[2] =\r\ndma_request_slave_channel_compat(mask, pxad_filter_fn,\r\n&params, &pdev->dev, "CI_V");\r\nif (!pcdev->dma_chans[2]) {\r\ndev_err(&pdev->dev, "Can't request DMA for V\n");\r\ngoto exit_free_dma_u;\r\n}\r\nfor (i = 0; i < 3; i++) {\r\nconfig.src_addr = pcdev->res->start + CIBR0 + i * 8;\r\nerr = dmaengine_slave_config(pcdev->dma_chans[i], &config);\r\nif (err < 0) {\r\ndev_err(&pdev->dev, "dma slave config failed: %d\n",\r\nerr);\r\ngoto exit_free_dma;\r\n}\r\n}\r\nerr = devm_request_irq(&pdev->dev, pcdev->irq, pxa_camera_irq, 0,\r\nPXA_CAM_DRV_NAME, pcdev);\r\nif (err) {\r\ndev_err(&pdev->dev, "Camera interrupt register failed\n");\r\ngoto exit_free_dma;\r\n}\r\npcdev->soc_host.drv_name = PXA_CAM_DRV_NAME;\r\npcdev->soc_host.ops = &pxa_soc_camera_host_ops;\r\npcdev->soc_host.priv = pcdev;\r\npcdev->soc_host.v4l2_dev.dev = &pdev->dev;\r\npcdev->soc_host.nr = pdev->id;\r\ntasklet_init(&pcdev->task_eof, pxa_camera_eof, (unsigned long)pcdev);\r\nerr = soc_camera_host_register(&pcdev->soc_host);\r\nif (err)\r\ngoto exit_free_dma;\r\nreturn 0;\r\nexit_free_dma:\r\ndma_release_channel(pcdev->dma_chans[2]);\r\nexit_free_dma_u:\r\ndma_release_channel(pcdev->dma_chans[1]);\r\nexit_free_dma_y:\r\ndma_release_channel(pcdev->dma_chans[0]);\r\nreturn err;\r\n}\r\nstatic int pxa_camera_remove(struct platform_device *pdev)\r\n{\r\nstruct soc_camera_host *soc_host = to_soc_camera_host(&pdev->dev);\r\nstruct pxa_camera_dev *pcdev = container_of(soc_host,\r\nstruct pxa_camera_dev, soc_host);\r\ndma_release_channel(pcdev->dma_chans[0]);\r\ndma_release_channel(pcdev->dma_chans[1]);\r\ndma_release_channel(pcdev->dma_chans[2]);\r\nsoc_camera_host_unregister(soc_host);\r\ndev_info(&pdev->dev, "PXA Camera driver unloaded\n");\r\nreturn 0;\r\n}
