static int userspace_do_request(struct log_c *lc, const char *uuid,\r\nint request_type, char *data, size_t data_size,\r\nchar *rdata, size_t *rdata_size)\r\n{\r\nint r;\r\nretry:\r\nr = dm_consult_userspace(uuid, lc->luid, request_type, data,\r\ndata_size, rdata, rdata_size);\r\nif (r != -ESRCH)\r\nreturn r;\r\nDMERR(" Userspace log server not found.");\r\nwhile (1) {\r\nset_current_state(TASK_INTERRUPTIBLE);\r\nschedule_timeout(2*HZ);\r\nDMWARN("Attempting to contact userspace log server...");\r\nr = dm_consult_userspace(uuid, lc->luid, DM_ULOG_CTR,\r\nlc->usr_argv_str,\r\nstrlen(lc->usr_argv_str) + 1,\r\nNULL, NULL);\r\nif (!r)\r\nbreak;\r\n}\r\nDMINFO("Reconnected to userspace log server... DM_ULOG_CTR complete");\r\nr = dm_consult_userspace(uuid, lc->luid, DM_ULOG_RESUME, NULL,\r\n0, NULL, NULL);\r\nif (!r)\r\ngoto retry;\r\nDMERR("Error trying to resume userspace log: %d", r);\r\nreturn -ESRCH;\r\n}\r\nstatic int build_constructor_string(struct dm_target *ti,\r\nunsigned argc, char **argv,\r\nchar **ctr_str)\r\n{\r\nint i, str_size;\r\nchar *str = NULL;\r\n*ctr_str = NULL;\r\nfor (i = 0, str_size = 0; i < argc; i++)\r\nstr_size += strlen(argv[i]) + 1;\r\nstr_size += 20;\r\nstr = kzalloc(str_size, GFP_KERNEL);\r\nif (!str) {\r\nDMWARN("Unable to allocate memory for constructor string");\r\nreturn -ENOMEM;\r\n}\r\nstr_size = sprintf(str, "%llu", (unsigned long long)ti->len);\r\nfor (i = 0; i < argc; i++)\r\nstr_size += sprintf(str + str_size, " %s", argv[i]);\r\n*ctr_str = str;\r\nreturn str_size;\r\n}\r\nstatic void do_flush(struct work_struct *work)\r\n{\r\nint r;\r\nstruct log_c *lc = container_of(work, struct log_c, flush_log_work.work);\r\natomic_set(&lc->sched_flush, 0);\r\nr = userspace_do_request(lc, lc->uuid, DM_ULOG_FLUSH, NULL, 0, NULL, NULL);\r\nif (r)\r\ndm_table_event(lc->ti->table);\r\n}\r\nstatic int userspace_ctr(struct dm_dirty_log *log, struct dm_target *ti,\r\nunsigned argc, char **argv)\r\n{\r\nint r = 0;\r\nint str_size;\r\nchar *ctr_str = NULL;\r\nstruct log_c *lc = NULL;\r\nuint64_t rdata;\r\nsize_t rdata_size = sizeof(rdata);\r\nchar *devices_rdata = NULL;\r\nsize_t devices_rdata_size = DM_NAME_LEN;\r\nif (argc < 3) {\r\nDMWARN("Too few arguments to userspace dirty log");\r\nreturn -EINVAL;\r\n}\r\nlc = kzalloc(sizeof(*lc), GFP_KERNEL);\r\nif (!lc) {\r\nDMWARN("Unable to allocate userspace log context.");\r\nreturn -ENOMEM;\r\n}\r\nlc->luid = (unsigned long)lc;\r\nlc->ti = ti;\r\nif (strlen(argv[0]) > (DM_UUID_LEN - 1)) {\r\nDMWARN("UUID argument too long.");\r\nkfree(lc);\r\nreturn -EINVAL;\r\n}\r\nlc->usr_argc = argc;\r\nstrncpy(lc->uuid, argv[0], DM_UUID_LEN);\r\nargc--;\r\nargv++;\r\nspin_lock_init(&lc->flush_lock);\r\nINIT_LIST_HEAD(&lc->mark_list);\r\nINIT_LIST_HEAD(&lc->clear_list);\r\nif (!strcasecmp(argv[0], "integrated_flush")) {\r\nlc->integrated_flush = 1;\r\nargc--;\r\nargv++;\r\n}\r\nstr_size = build_constructor_string(ti, argc, argv, &ctr_str);\r\nif (str_size < 0) {\r\nkfree(lc);\r\nreturn str_size;\r\n}\r\ndevices_rdata = kzalloc(devices_rdata_size, GFP_KERNEL);\r\nif (!devices_rdata) {\r\nDMERR("Failed to allocate memory for device information");\r\nr = -ENOMEM;\r\ngoto out;\r\n}\r\nlc->flush_entry_pool = mempool_create_slab_pool(FLUSH_ENTRY_POOL_SIZE,\r\n_flush_entry_cache);\r\nif (!lc->flush_entry_pool) {\r\nDMERR("Failed to create flush_entry_pool");\r\nr = -ENOMEM;\r\ngoto out;\r\n}\r\nr = dm_consult_userspace(lc->uuid, lc->luid, DM_ULOG_CTR,\r\nctr_str, str_size,\r\ndevices_rdata, &devices_rdata_size);\r\nif (r < 0) {\r\nif (r == -ESRCH)\r\nDMERR("Userspace log server not found");\r\nelse\r\nDMERR("Userspace log server failed to create log");\r\ngoto out;\r\n}\r\nrdata_size = sizeof(rdata);\r\nr = dm_consult_userspace(lc->uuid, lc->luid, DM_ULOG_GET_REGION_SIZE,\r\nNULL, 0, (char *)&rdata, &rdata_size);\r\nif (r) {\r\nDMERR("Failed to get region size of dirty log");\r\ngoto out;\r\n}\r\nlc->region_size = (uint32_t)rdata;\r\nlc->region_count = dm_sector_div_up(ti->len, lc->region_size);\r\nif (devices_rdata_size) {\r\nif (devices_rdata[devices_rdata_size - 1] != '\0') {\r\nDMERR("DM_ULOG_CTR device return string not properly terminated");\r\nr = -EINVAL;\r\ngoto out;\r\n}\r\nr = dm_get_device(ti, devices_rdata,\r\ndm_table_get_mode(ti->table), &lc->log_dev);\r\nif (r)\r\nDMERR("Failed to register %s with device-mapper",\r\ndevices_rdata);\r\n}\r\nif (lc->integrated_flush) {\r\nlc->dmlog_wq = alloc_workqueue("dmlogd", WQ_MEM_RECLAIM, 0);\r\nif (!lc->dmlog_wq) {\r\nDMERR("couldn't start dmlogd");\r\nr = -ENOMEM;\r\ngoto out;\r\n}\r\nINIT_DELAYED_WORK(&lc->flush_log_work, do_flush);\r\natomic_set(&lc->sched_flush, 0);\r\n}\r\nout:\r\nkfree(devices_rdata);\r\nif (r) {\r\nmempool_destroy(lc->flush_entry_pool);\r\nkfree(lc);\r\nkfree(ctr_str);\r\n} else {\r\nlc->usr_argv_str = ctr_str;\r\nlog->context = lc;\r\n}\r\nreturn r;\r\n}\r\nstatic void userspace_dtr(struct dm_dirty_log *log)\r\n{\r\nstruct log_c *lc = log->context;\r\nif (lc->integrated_flush) {\r\nif (atomic_read(&lc->sched_flush))\r\nflush_delayed_work(&lc->flush_log_work);\r\ndestroy_workqueue(lc->dmlog_wq);\r\n}\r\n(void) dm_consult_userspace(lc->uuid, lc->luid, DM_ULOG_DTR,\r\nNULL, 0, NULL, NULL);\r\nif (lc->log_dev)\r\ndm_put_device(lc->ti, lc->log_dev);\r\nmempool_destroy(lc->flush_entry_pool);\r\nkfree(lc->usr_argv_str);\r\nkfree(lc);\r\nreturn;\r\n}\r\nstatic int userspace_presuspend(struct dm_dirty_log *log)\r\n{\r\nint r;\r\nstruct log_c *lc = log->context;\r\nr = dm_consult_userspace(lc->uuid, lc->luid, DM_ULOG_PRESUSPEND,\r\nNULL, 0, NULL, NULL);\r\nreturn r;\r\n}\r\nstatic int userspace_postsuspend(struct dm_dirty_log *log)\r\n{\r\nint r;\r\nstruct log_c *lc = log->context;\r\nif (lc->integrated_flush && atomic_read(&lc->sched_flush))\r\nflush_delayed_work(&lc->flush_log_work);\r\nr = dm_consult_userspace(lc->uuid, lc->luid, DM_ULOG_POSTSUSPEND,\r\nNULL, 0, NULL, NULL);\r\nreturn r;\r\n}\r\nstatic int userspace_resume(struct dm_dirty_log *log)\r\n{\r\nint r;\r\nstruct log_c *lc = log->context;\r\nlc->in_sync_hint = 0;\r\nr = dm_consult_userspace(lc->uuid, lc->luid, DM_ULOG_RESUME,\r\nNULL, 0, NULL, NULL);\r\nreturn r;\r\n}\r\nstatic uint32_t userspace_get_region_size(struct dm_dirty_log *log)\r\n{\r\nstruct log_c *lc = log->context;\r\nreturn lc->region_size;\r\n}\r\nstatic int userspace_is_clean(struct dm_dirty_log *log, region_t region)\r\n{\r\nint r;\r\nuint64_t region64 = (uint64_t)region;\r\nint64_t is_clean;\r\nsize_t rdata_size;\r\nstruct log_c *lc = log->context;\r\nrdata_size = sizeof(is_clean);\r\nr = userspace_do_request(lc, lc->uuid, DM_ULOG_IS_CLEAN,\r\n(char *)&region64, sizeof(region64),\r\n(char *)&is_clean, &rdata_size);\r\nreturn (r) ? 0 : (int)is_clean;\r\n}\r\nstatic int userspace_in_sync(struct dm_dirty_log *log, region_t region,\r\nint can_block)\r\n{\r\nint r;\r\nuint64_t region64 = region;\r\nint64_t in_sync;\r\nsize_t rdata_size;\r\nstruct log_c *lc = log->context;\r\nif (!can_block)\r\nreturn -EWOULDBLOCK;\r\nrdata_size = sizeof(in_sync);\r\nr = userspace_do_request(lc, lc->uuid, DM_ULOG_IN_SYNC,\r\n(char *)&region64, sizeof(region64),\r\n(char *)&in_sync, &rdata_size);\r\nreturn (r) ? 0 : (int)in_sync;\r\n}\r\nstatic int flush_one_by_one(struct log_c *lc, struct list_head *flush_list)\r\n{\r\nint r = 0;\r\nstruct dm_dirty_log_flush_entry *fe;\r\nlist_for_each_entry(fe, flush_list, list) {\r\nr = userspace_do_request(lc, lc->uuid, fe->type,\r\n(char *)&fe->region,\r\nsizeof(fe->region),\r\nNULL, NULL);\r\nif (r)\r\nbreak;\r\n}\r\nreturn r;\r\n}\r\nstatic int flush_by_group(struct log_c *lc, struct list_head *flush_list,\r\nint flush_with_payload)\r\n{\r\nint r = 0;\r\nint count;\r\nuint32_t type = 0;\r\nstruct dm_dirty_log_flush_entry *fe, *tmp_fe;\r\nLIST_HEAD(tmp_list);\r\nuint64_t group[MAX_FLUSH_GROUP_COUNT];\r\nwhile (!list_empty(flush_list)) {\r\ncount = 0;\r\nlist_for_each_entry_safe(fe, tmp_fe, flush_list, list) {\r\ngroup[count] = fe->region;\r\ncount++;\r\nlist_move(&fe->list, &tmp_list);\r\ntype = fe->type;\r\nif (count >= MAX_FLUSH_GROUP_COUNT)\r\nbreak;\r\n}\r\nif (flush_with_payload) {\r\nr = userspace_do_request(lc, lc->uuid, DM_ULOG_FLUSH,\r\n(char *)(group),\r\ncount * sizeof(uint64_t),\r\nNULL, NULL);\r\nif (r)\r\nbreak;\r\n} else {\r\nr = userspace_do_request(lc, lc->uuid, type,\r\n(char *)(group),\r\ncount * sizeof(uint64_t),\r\nNULL, NULL);\r\nif (r) {\r\nlist_splice_init(&tmp_list, flush_list);\r\nr = flush_one_by_one(lc, flush_list);\r\nbreak;\r\n}\r\n}\r\n}\r\nlist_splice_init(&tmp_list, flush_list);\r\nreturn r;\r\n}\r\nstatic int userspace_flush(struct dm_dirty_log *log)\r\n{\r\nint r = 0;\r\nunsigned long flags;\r\nstruct log_c *lc = log->context;\r\nLIST_HEAD(mark_list);\r\nLIST_HEAD(clear_list);\r\nint mark_list_is_empty;\r\nint clear_list_is_empty;\r\nstruct dm_dirty_log_flush_entry *fe, *tmp_fe;\r\nmempool_t *flush_entry_pool = lc->flush_entry_pool;\r\nspin_lock_irqsave(&lc->flush_lock, flags);\r\nlist_splice_init(&lc->mark_list, &mark_list);\r\nlist_splice_init(&lc->clear_list, &clear_list);\r\nspin_unlock_irqrestore(&lc->flush_lock, flags);\r\nmark_list_is_empty = list_empty(&mark_list);\r\nclear_list_is_empty = list_empty(&clear_list);\r\nif (mark_list_is_empty && clear_list_is_empty)\r\nreturn 0;\r\nr = flush_by_group(lc, &clear_list, 0);\r\nif (r)\r\ngoto out;\r\nif (!lc->integrated_flush) {\r\nr = flush_by_group(lc, &mark_list, 0);\r\nif (r)\r\ngoto out;\r\nr = userspace_do_request(lc, lc->uuid, DM_ULOG_FLUSH,\r\nNULL, 0, NULL, NULL);\r\ngoto out;\r\n}\r\nr = flush_by_group(lc, &mark_list, 1);\r\nif (r)\r\ngoto out;\r\nif (mark_list_is_empty && !atomic_read(&lc->sched_flush)) {\r\nqueue_delayed_work(lc->dmlog_wq, &lc->flush_log_work, 3 * HZ);\r\natomic_set(&lc->sched_flush, 1);\r\n} else {\r\ncancel_delayed_work(&lc->flush_log_work);\r\natomic_set(&lc->sched_flush, 0);\r\n}\r\nout:\r\nlist_for_each_entry_safe(fe, tmp_fe, &mark_list, list) {\r\nlist_del(&fe->list);\r\nmempool_free(fe, flush_entry_pool);\r\n}\r\nlist_for_each_entry_safe(fe, tmp_fe, &clear_list, list) {\r\nlist_del(&fe->list);\r\nmempool_free(fe, flush_entry_pool);\r\n}\r\nif (r)\r\ndm_table_event(lc->ti->table);\r\nreturn r;\r\n}\r\nstatic void userspace_mark_region(struct dm_dirty_log *log, region_t region)\r\n{\r\nunsigned long flags;\r\nstruct log_c *lc = log->context;\r\nstruct dm_dirty_log_flush_entry *fe;\r\nfe = mempool_alloc(lc->flush_entry_pool, GFP_NOIO);\r\nBUG_ON(!fe);\r\nspin_lock_irqsave(&lc->flush_lock, flags);\r\nfe->type = DM_ULOG_MARK_REGION;\r\nfe->region = region;\r\nlist_add(&fe->list, &lc->mark_list);\r\nspin_unlock_irqrestore(&lc->flush_lock, flags);\r\nreturn;\r\n}\r\nstatic void userspace_clear_region(struct dm_dirty_log *log, region_t region)\r\n{\r\nunsigned long flags;\r\nstruct log_c *lc = log->context;\r\nstruct dm_dirty_log_flush_entry *fe;\r\nfe = mempool_alloc(lc->flush_entry_pool, GFP_ATOMIC);\r\nif (!fe) {\r\nDMERR("Failed to allocate memory to clear region.");\r\nreturn;\r\n}\r\nspin_lock_irqsave(&lc->flush_lock, flags);\r\nfe->type = DM_ULOG_CLEAR_REGION;\r\nfe->region = region;\r\nlist_add(&fe->list, &lc->clear_list);\r\nspin_unlock_irqrestore(&lc->flush_lock, flags);\r\nreturn;\r\n}\r\nstatic int userspace_get_resync_work(struct dm_dirty_log *log, region_t *region)\r\n{\r\nint r;\r\nsize_t rdata_size;\r\nstruct log_c *lc = log->context;\r\nstruct {\r\nint64_t i;\r\nregion_t r;\r\n} pkg;\r\nif (lc->in_sync_hint >= lc->region_count)\r\nreturn 0;\r\nrdata_size = sizeof(pkg);\r\nr = userspace_do_request(lc, lc->uuid, DM_ULOG_GET_RESYNC_WORK,\r\nNULL, 0, (char *)&pkg, &rdata_size);\r\n*region = pkg.r;\r\nreturn (r) ? r : (int)pkg.i;\r\n}\r\nstatic void userspace_set_region_sync(struct dm_dirty_log *log,\r\nregion_t region, int in_sync)\r\n{\r\nstruct log_c *lc = log->context;\r\nstruct {\r\nregion_t r;\r\nint64_t i;\r\n} pkg;\r\npkg.r = region;\r\npkg.i = (int64_t)in_sync;\r\n(void) userspace_do_request(lc, lc->uuid, DM_ULOG_SET_REGION_SYNC,\r\n(char *)&pkg, sizeof(pkg), NULL, NULL);\r\nreturn;\r\n}\r\nstatic region_t userspace_get_sync_count(struct dm_dirty_log *log)\r\n{\r\nint r;\r\nsize_t rdata_size;\r\nuint64_t sync_count;\r\nstruct log_c *lc = log->context;\r\nrdata_size = sizeof(sync_count);\r\nr = userspace_do_request(lc, lc->uuid, DM_ULOG_GET_SYNC_COUNT,\r\nNULL, 0, (char *)&sync_count, &rdata_size);\r\nif (r)\r\nreturn 0;\r\nif (sync_count >= lc->region_count)\r\nlc->in_sync_hint = lc->region_count;\r\nreturn (region_t)sync_count;\r\n}\r\nstatic int userspace_status(struct dm_dirty_log *log, status_type_t status_type,\r\nchar *result, unsigned maxlen)\r\n{\r\nint r = 0;\r\nchar *table_args;\r\nsize_t sz = (size_t)maxlen;\r\nstruct log_c *lc = log->context;\r\nswitch (status_type) {\r\ncase STATUSTYPE_INFO:\r\nr = userspace_do_request(lc, lc->uuid, DM_ULOG_STATUS_INFO,\r\nNULL, 0, result, &sz);\r\nif (r) {\r\nsz = 0;\r\nDMEMIT("%s 1 COM_FAILURE", log->type->name);\r\n}\r\nbreak;\r\ncase STATUSTYPE_TABLE:\r\nsz = 0;\r\ntable_args = strchr(lc->usr_argv_str, ' ');\r\nBUG_ON(!table_args);\r\ntable_args++;\r\nDMEMIT("%s %u %s ", log->type->name, lc->usr_argc, lc->uuid);\r\nif (lc->integrated_flush)\r\nDMEMIT("integrated_flush ");\r\nDMEMIT("%s ", table_args);\r\nbreak;\r\n}\r\nreturn (r) ? 0 : (int)sz;\r\n}\r\nstatic int userspace_is_remote_recovering(struct dm_dirty_log *log,\r\nregion_t region)\r\n{\r\nint r;\r\nuint64_t region64 = region;\r\nstruct log_c *lc = log->context;\r\nstatic unsigned long limit;\r\nstruct {\r\nint64_t is_recovering;\r\nuint64_t in_sync_hint;\r\n} pkg;\r\nsize_t rdata_size = sizeof(pkg);\r\nif (region < lc->in_sync_hint)\r\nreturn 0;\r\nelse if (time_after(limit, jiffies))\r\nreturn 1;\r\nlimit = jiffies + (HZ / 4);\r\nr = userspace_do_request(lc, lc->uuid, DM_ULOG_IS_REMOTE_RECOVERING,\r\n(char *)&region64, sizeof(region64),\r\n(char *)&pkg, &rdata_size);\r\nif (r)\r\nreturn 1;\r\nlc->in_sync_hint = pkg.in_sync_hint;\r\nreturn (int)pkg.is_recovering;\r\n}\r\nstatic int __init userspace_dirty_log_init(void)\r\n{\r\nint r = 0;\r\n_flush_entry_cache = KMEM_CACHE(dm_dirty_log_flush_entry, 0);\r\nif (!_flush_entry_cache) {\r\nDMWARN("Unable to create flush_entry_cache: No memory.");\r\nreturn -ENOMEM;\r\n}\r\nr = dm_ulog_tfr_init();\r\nif (r) {\r\nDMWARN("Unable to initialize userspace log communications");\r\nkmem_cache_destroy(_flush_entry_cache);\r\nreturn r;\r\n}\r\nr = dm_dirty_log_type_register(&_userspace_type);\r\nif (r) {\r\nDMWARN("Couldn't register userspace dirty log type");\r\ndm_ulog_tfr_exit();\r\nkmem_cache_destroy(_flush_entry_cache);\r\nreturn r;\r\n}\r\nDMINFO("version " DM_LOG_USERSPACE_VSN " loaded");\r\nreturn 0;\r\n}\r\nstatic void __exit userspace_dirty_log_exit(void)\r\n{\r\ndm_dirty_log_type_unregister(&_userspace_type);\r\ndm_ulog_tfr_exit();\r\nkmem_cache_destroy(_flush_entry_cache);\r\nDMINFO("version " DM_LOG_USERSPACE_VSN " unloaded");\r\nreturn;\r\n}
