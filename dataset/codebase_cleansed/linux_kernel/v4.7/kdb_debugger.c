int kdb_common_init_state(struct kgdb_state *ks)\r\n{\r\nkdb_initial_cpu = atomic_read(&kgdb_active);\r\nkdb_current_task = kgdb_info[ks->cpu].task;\r\nkdb_current_regs = kgdb_info[ks->cpu].debuggerinfo;\r\nreturn 0;\r\n}\r\nint kdb_common_deinit_state(void)\r\n{\r\nkdb_initial_cpu = -1;\r\nkdb_current_task = NULL;\r\nkdb_current_regs = NULL;\r\nreturn 0;\r\n}\r\nint kdb_stub(struct kgdb_state *ks)\r\n{\r\nint error = 0;\r\nkdb_bp_t *bp;\r\nunsigned long addr = kgdb_arch_pc(ks->ex_vector, ks->linux_regs);\r\nkdb_reason_t reason = KDB_REASON_OOPS;\r\nkdb_dbtrap_t db_result = KDB_DB_NOBPT;\r\nint i;\r\nkdb_ks = ks;\r\nif (KDB_STATE(REENTRY)) {\r\nreason = KDB_REASON_SWITCH;\r\nKDB_STATE_CLEAR(REENTRY);\r\naddr = instruction_pointer(ks->linux_regs);\r\n}\r\nks->pass_exception = 0;\r\nif (atomic_read(&kgdb_setting_breakpoint))\r\nreason = KDB_REASON_KEYBOARD;\r\nif (ks->err_code == KDB_REASON_SYSTEM_NMI && ks->signo == SIGTRAP)\r\nreason = KDB_REASON_SYSTEM_NMI;\r\nelse if (in_nmi())\r\nreason = KDB_REASON_NMI;\r\nfor (i = 0, bp = kdb_breakpoints; i < KDB_MAXBPT; i++, bp++) {\r\nif ((bp->bp_enabled) && (bp->bp_addr == addr)) {\r\nreason = KDB_REASON_BREAK;\r\ndb_result = KDB_DB_BPT;\r\nif (addr != instruction_pointer(ks->linux_regs))\r\nkgdb_arch_set_pc(ks->linux_regs, addr);\r\nbreak;\r\n}\r\n}\r\nif (reason == KDB_REASON_BREAK || reason == KDB_REASON_SWITCH) {\r\nfor (i = 0, bp = kdb_breakpoints; i < KDB_MAXBPT; i++, bp++) {\r\nif (bp->bp_free)\r\ncontinue;\r\nif (bp->bp_addr == addr) {\r\nbp->bp_delay = 1;\r\nbp->bp_delayed = 1;\r\nreason = KDB_REASON_BREAK;\r\ndb_result = KDB_DB_BPT;\r\nKDB_STATE_SET(SSBPT);\r\nbreak;\r\n}\r\n}\r\n}\r\nif (reason != KDB_REASON_BREAK && ks->ex_vector == 0 &&\r\nks->signo == SIGTRAP) {\r\nreason = KDB_REASON_SSTEP;\r\ndb_result = KDB_DB_BPT;\r\n}\r\nKDB_STATE_CLEAR(KGDB_TRANS);\r\nkdb_common_init_state(ks);\r\nkdb_bp_remove();\r\nKDB_STATE_CLEAR(DOING_SS);\r\nKDB_STATE_SET(PAGER);\r\nfor_each_present_cpu(i) {\r\nif (!cpu_online(i)) {\r\nkgdb_info[i].debuggerinfo = NULL;\r\nkgdb_info[i].task = NULL;\r\n}\r\n}\r\nif (ks->err_code == DIE_OOPS || reason == KDB_REASON_OOPS) {\r\nks->pass_exception = 1;\r\nKDB_FLAG_SET(CATASTROPHIC);\r\n}\r\nfor_each_online_cpu(i)\r\nif (!kgdb_info[i].enter_kgdb)\r\nKDB_FLAG_SET(CATASTROPHIC);\r\nif (KDB_STATE(SSBPT) && reason == KDB_REASON_SSTEP) {\r\nKDB_STATE_CLEAR(SSBPT);\r\nKDB_STATE_CLEAR(DOING_SS);\r\n} else {\r\nerror = kdb_main_loop(KDB_REASON_ENTER, reason,\r\nks->err_code, db_result, ks->linux_regs);\r\n}\r\nkdb_common_deinit_state();\r\nKDB_STATE_CLEAR(PAGER);\r\nkdbnearsym_cleanup();\r\nif (error == KDB_CMD_KGDB) {\r\nif (KDB_STATE(DOING_KGDB))\r\nKDB_STATE_CLEAR(DOING_KGDB);\r\nreturn DBG_PASS_EVENT;\r\n}\r\nkdb_bp_install(ks->linux_regs);\r\ndbg_activate_sw_breakpoints();\r\nif (KDB_STATE(DOING_SS))\r\ngdbstub_state(ks, "s");\r\nelse\r\ngdbstub_state(ks, "c");\r\nKDB_FLAG_CLEAR(CATASTROPHIC);\r\nkgdb_info[ks->cpu].ret_state = gdbstub_state(ks, "e");\r\nif (ks->pass_exception)\r\nkgdb_info[ks->cpu].ret_state = 1;\r\nif (error == KDB_CMD_CPU) {\r\nKDB_STATE_SET(REENTRY);\r\nkgdb_single_step = 0;\r\ndbg_deactivate_sw_breakpoints();\r\nreturn DBG_SWITCH_CPU_EVENT;\r\n}\r\nreturn kgdb_info[ks->cpu].ret_state;\r\n}\r\nvoid kdb_gdb_state_pass(char *buf)\r\n{\r\ngdbstub_state(kdb_ks, buf);\r\n}
