static void audit_free_lsm_field(struct audit_field *f)\r\n{\r\nswitch (f->type) {\r\ncase AUDIT_SUBJ_USER:\r\ncase AUDIT_SUBJ_ROLE:\r\ncase AUDIT_SUBJ_TYPE:\r\ncase AUDIT_SUBJ_SEN:\r\ncase AUDIT_SUBJ_CLR:\r\ncase AUDIT_OBJ_USER:\r\ncase AUDIT_OBJ_ROLE:\r\ncase AUDIT_OBJ_TYPE:\r\ncase AUDIT_OBJ_LEV_LOW:\r\ncase AUDIT_OBJ_LEV_HIGH:\r\nkfree(f->lsm_str);\r\nsecurity_audit_rule_free(f->lsm_rule);\r\n}\r\n}\r\nstatic inline void audit_free_rule(struct audit_entry *e)\r\n{\r\nint i;\r\nstruct audit_krule *erule = &e->rule;\r\nif (erule->watch)\r\naudit_put_watch(erule->watch);\r\nif (erule->fields)\r\nfor (i = 0; i < erule->field_count; i++)\r\naudit_free_lsm_field(&erule->fields[i]);\r\nkfree(erule->fields);\r\nkfree(erule->filterkey);\r\nkfree(e);\r\n}\r\nvoid audit_free_rule_rcu(struct rcu_head *head)\r\n{\r\nstruct audit_entry *e = container_of(head, struct audit_entry, rcu);\r\naudit_free_rule(e);\r\n}\r\nstatic inline struct audit_entry *audit_init_entry(u32 field_count)\r\n{\r\nstruct audit_entry *entry;\r\nstruct audit_field *fields;\r\nentry = kzalloc(sizeof(*entry), GFP_KERNEL);\r\nif (unlikely(!entry))\r\nreturn NULL;\r\nfields = kcalloc(field_count, sizeof(*fields), GFP_KERNEL);\r\nif (unlikely(!fields)) {\r\nkfree(entry);\r\nreturn NULL;\r\n}\r\nentry->rule.fields = fields;\r\nreturn entry;\r\n}\r\nchar *audit_unpack_string(void **bufp, size_t *remain, size_t len)\r\n{\r\nchar *str;\r\nif (!*bufp || (len == 0) || (len > *remain))\r\nreturn ERR_PTR(-EINVAL);\r\nif (len > PATH_MAX)\r\nreturn ERR_PTR(-ENAMETOOLONG);\r\nstr = kmalloc(len + 1, GFP_KERNEL);\r\nif (unlikely(!str))\r\nreturn ERR_PTR(-ENOMEM);\r\nmemcpy(str, *bufp, len);\r\nstr[len] = 0;\r\n*bufp += len;\r\n*remain -= len;\r\nreturn str;\r\n}\r\nstatic inline int audit_to_inode(struct audit_krule *krule,\r\nstruct audit_field *f)\r\n{\r\nif (krule->listnr != AUDIT_FILTER_EXIT ||\r\nkrule->inode_f || krule->watch || krule->tree ||\r\n(f->op != Audit_equal && f->op != Audit_not_equal))\r\nreturn -EINVAL;\r\nkrule->inode_f = f;\r\nreturn 0;\r\n}\r\nint __init audit_register_class(int class, unsigned *list)\r\n{\r\n__u32 *p = kcalloc(AUDIT_BITMASK_SIZE, sizeof(__u32), GFP_KERNEL);\r\nif (!p)\r\nreturn -ENOMEM;\r\nwhile (*list != ~0U) {\r\nunsigned n = *list++;\r\nif (n >= AUDIT_BITMASK_SIZE * 32 - AUDIT_SYSCALL_CLASSES) {\r\nkfree(p);\r\nreturn -EINVAL;\r\n}\r\np[AUDIT_WORD(n)] |= AUDIT_BIT(n);\r\n}\r\nif (class >= AUDIT_SYSCALL_CLASSES || classes[class]) {\r\nkfree(p);\r\nreturn -EINVAL;\r\n}\r\nclasses[class] = p;\r\nreturn 0;\r\n}\r\nint audit_match_class(int class, unsigned syscall)\r\n{\r\nif (unlikely(syscall >= AUDIT_BITMASK_SIZE * 32))\r\nreturn 0;\r\nif (unlikely(class >= AUDIT_SYSCALL_CLASSES || !classes[class]))\r\nreturn 0;\r\nreturn classes[class][AUDIT_WORD(syscall)] & AUDIT_BIT(syscall);\r\n}\r\nstatic inline int audit_match_class_bits(int class, u32 *mask)\r\n{\r\nint i;\r\nif (classes[class]) {\r\nfor (i = 0; i < AUDIT_BITMASK_SIZE; i++)\r\nif (mask[i] & classes[class][i])\r\nreturn 0;\r\n}\r\nreturn 1;\r\n}\r\nstatic int audit_match_signal(struct audit_entry *entry)\r\n{\r\nstruct audit_field *arch = entry->rule.arch_f;\r\nif (!arch) {\r\nreturn (audit_match_class_bits(AUDIT_CLASS_SIGNAL,\r\nentry->rule.mask) &&\r\naudit_match_class_bits(AUDIT_CLASS_SIGNAL_32,\r\nentry->rule.mask));\r\n}\r\nswitch(audit_classify_arch(arch->val)) {\r\ncase 0:\r\nreturn (audit_match_class_bits(AUDIT_CLASS_SIGNAL,\r\nentry->rule.mask));\r\ncase 1:\r\nreturn (audit_match_class_bits(AUDIT_CLASS_SIGNAL_32,\r\nentry->rule.mask));\r\ndefault:\r\nreturn 1;\r\n}\r\n}\r\nstatic inline struct audit_entry *audit_to_entry_common(struct audit_rule_data *rule)\r\n{\r\nunsigned listnr;\r\nstruct audit_entry *entry;\r\nint i, err;\r\nerr = -EINVAL;\r\nlistnr = rule->flags & ~AUDIT_FILTER_PREPEND;\r\nswitch(listnr) {\r\ndefault:\r\ngoto exit_err;\r\n#ifdef CONFIG_AUDITSYSCALL\r\ncase AUDIT_FILTER_ENTRY:\r\nif (rule->action == AUDIT_ALWAYS)\r\ngoto exit_err;\r\ncase AUDIT_FILTER_EXIT:\r\ncase AUDIT_FILTER_TASK:\r\n#endif\r\ncase AUDIT_FILTER_USER:\r\ncase AUDIT_FILTER_TYPE:\r\n;\r\n}\r\nif (unlikely(rule->action == AUDIT_POSSIBLE)) {\r\npr_err("AUDIT_POSSIBLE is deprecated\n");\r\ngoto exit_err;\r\n}\r\nif (rule->action != AUDIT_NEVER && rule->action != AUDIT_ALWAYS)\r\ngoto exit_err;\r\nif (rule->field_count > AUDIT_MAX_FIELDS)\r\ngoto exit_err;\r\nerr = -ENOMEM;\r\nentry = audit_init_entry(rule->field_count);\r\nif (!entry)\r\ngoto exit_err;\r\nentry->rule.flags = rule->flags & AUDIT_FILTER_PREPEND;\r\nentry->rule.listnr = listnr;\r\nentry->rule.action = rule->action;\r\nentry->rule.field_count = rule->field_count;\r\nfor (i = 0; i < AUDIT_BITMASK_SIZE; i++)\r\nentry->rule.mask[i] = rule->mask[i];\r\nfor (i = 0; i < AUDIT_SYSCALL_CLASSES; i++) {\r\nint bit = AUDIT_BITMASK_SIZE * 32 - i - 1;\r\n__u32 *p = &entry->rule.mask[AUDIT_WORD(bit)];\r\n__u32 *class;\r\nif (!(*p & AUDIT_BIT(bit)))\r\ncontinue;\r\n*p &= ~AUDIT_BIT(bit);\r\nclass = classes[i];\r\nif (class) {\r\nint j;\r\nfor (j = 0; j < AUDIT_BITMASK_SIZE; j++)\r\nentry->rule.mask[j] |= class[j];\r\n}\r\n}\r\nreturn entry;\r\nexit_err:\r\nreturn ERR_PTR(err);\r\n}\r\nstatic u32 audit_to_op(u32 op)\r\n{\r\nu32 n;\r\nfor (n = Audit_equal; n < Audit_bad && audit_ops[n] != op; n++)\r\n;\r\nreturn n;\r\n}\r\nstatic int audit_field_valid(struct audit_entry *entry, struct audit_field *f)\r\n{\r\nswitch(f->type) {\r\ncase AUDIT_MSGTYPE:\r\nif (entry->rule.listnr != AUDIT_FILTER_TYPE &&\r\nentry->rule.listnr != AUDIT_FILTER_USER)\r\nreturn -EINVAL;\r\nbreak;\r\n};\r\nswitch(f->type) {\r\ndefault:\r\nreturn -EINVAL;\r\ncase AUDIT_UID:\r\ncase AUDIT_EUID:\r\ncase AUDIT_SUID:\r\ncase AUDIT_FSUID:\r\ncase AUDIT_LOGINUID:\r\ncase AUDIT_OBJ_UID:\r\ncase AUDIT_GID:\r\ncase AUDIT_EGID:\r\ncase AUDIT_SGID:\r\ncase AUDIT_FSGID:\r\ncase AUDIT_OBJ_GID:\r\ncase AUDIT_PID:\r\ncase AUDIT_PERS:\r\ncase AUDIT_MSGTYPE:\r\ncase AUDIT_PPID:\r\ncase AUDIT_DEVMAJOR:\r\ncase AUDIT_DEVMINOR:\r\ncase AUDIT_EXIT:\r\ncase AUDIT_SUCCESS:\r\ncase AUDIT_INODE:\r\nif (f->op == Audit_bitmask || f->op == Audit_bittest)\r\nreturn -EINVAL;\r\nbreak;\r\ncase AUDIT_ARG0:\r\ncase AUDIT_ARG1:\r\ncase AUDIT_ARG2:\r\ncase AUDIT_ARG3:\r\ncase AUDIT_SUBJ_USER:\r\ncase AUDIT_SUBJ_ROLE:\r\ncase AUDIT_SUBJ_TYPE:\r\ncase AUDIT_SUBJ_SEN:\r\ncase AUDIT_SUBJ_CLR:\r\ncase AUDIT_OBJ_USER:\r\ncase AUDIT_OBJ_ROLE:\r\ncase AUDIT_OBJ_TYPE:\r\ncase AUDIT_OBJ_LEV_LOW:\r\ncase AUDIT_OBJ_LEV_HIGH:\r\ncase AUDIT_WATCH:\r\ncase AUDIT_DIR:\r\ncase AUDIT_FILTERKEY:\r\nbreak;\r\ncase AUDIT_LOGINUID_SET:\r\nif ((f->val != 0) && (f->val != 1))\r\nreturn -EINVAL;\r\ncase AUDIT_ARCH:\r\nif (f->op != Audit_not_equal && f->op != Audit_equal)\r\nreturn -EINVAL;\r\nbreak;\r\ncase AUDIT_PERM:\r\nif (f->val & ~15)\r\nreturn -EINVAL;\r\nbreak;\r\ncase AUDIT_FILETYPE:\r\nif (f->val & ~S_IFMT)\r\nreturn -EINVAL;\r\nbreak;\r\ncase AUDIT_FIELD_COMPARE:\r\nif (f->val > AUDIT_MAX_FIELD_COMPARE)\r\nreturn -EINVAL;\r\nbreak;\r\ncase AUDIT_EXE:\r\nif (f->op != Audit_equal)\r\nreturn -EINVAL;\r\nif (entry->rule.listnr != AUDIT_FILTER_EXIT)\r\nreturn -EINVAL;\r\nbreak;\r\n};\r\nreturn 0;\r\n}\r\nstatic struct audit_entry *audit_data_to_entry(struct audit_rule_data *data,\r\nsize_t datasz)\r\n{\r\nint err = 0;\r\nstruct audit_entry *entry;\r\nvoid *bufp;\r\nsize_t remain = datasz - sizeof(struct audit_rule_data);\r\nint i;\r\nchar *str;\r\nstruct audit_fsnotify_mark *audit_mark;\r\nentry = audit_to_entry_common(data);\r\nif (IS_ERR(entry))\r\ngoto exit_nofree;\r\nbufp = data->buf;\r\nfor (i = 0; i < data->field_count; i++) {\r\nstruct audit_field *f = &entry->rule.fields[i];\r\nerr = -EINVAL;\r\nf->op = audit_to_op(data->fieldflags[i]);\r\nif (f->op == Audit_bad)\r\ngoto exit_free;\r\nf->type = data->fields[i];\r\nf->val = data->values[i];\r\nif ((f->type == AUDIT_LOGINUID) && (f->val == AUDIT_UID_UNSET)) {\r\nf->type = AUDIT_LOGINUID_SET;\r\nf->val = 0;\r\nentry->rule.pflags |= AUDIT_LOGINUID_LEGACY;\r\n}\r\nerr = audit_field_valid(entry, f);\r\nif (err)\r\ngoto exit_free;\r\nerr = -EINVAL;\r\nswitch (f->type) {\r\ncase AUDIT_LOGINUID:\r\ncase AUDIT_UID:\r\ncase AUDIT_EUID:\r\ncase AUDIT_SUID:\r\ncase AUDIT_FSUID:\r\ncase AUDIT_OBJ_UID:\r\nf->uid = make_kuid(current_user_ns(), f->val);\r\nif (!uid_valid(f->uid))\r\ngoto exit_free;\r\nbreak;\r\ncase AUDIT_GID:\r\ncase AUDIT_EGID:\r\ncase AUDIT_SGID:\r\ncase AUDIT_FSGID:\r\ncase AUDIT_OBJ_GID:\r\nf->gid = make_kgid(current_user_ns(), f->val);\r\nif (!gid_valid(f->gid))\r\ngoto exit_free;\r\nbreak;\r\ncase AUDIT_ARCH:\r\nentry->rule.arch_f = f;\r\nbreak;\r\ncase AUDIT_SUBJ_USER:\r\ncase AUDIT_SUBJ_ROLE:\r\ncase AUDIT_SUBJ_TYPE:\r\ncase AUDIT_SUBJ_SEN:\r\ncase AUDIT_SUBJ_CLR:\r\ncase AUDIT_OBJ_USER:\r\ncase AUDIT_OBJ_ROLE:\r\ncase AUDIT_OBJ_TYPE:\r\ncase AUDIT_OBJ_LEV_LOW:\r\ncase AUDIT_OBJ_LEV_HIGH:\r\nstr = audit_unpack_string(&bufp, &remain, f->val);\r\nif (IS_ERR(str))\r\ngoto exit_free;\r\nentry->rule.buflen += f->val;\r\nerr = security_audit_rule_init(f->type, f->op, str,\r\n(void **)&f->lsm_rule);\r\nif (err == -EINVAL) {\r\npr_warn("audit rule for LSM \'%s\' is invalid\n",\r\nstr);\r\nerr = 0;\r\n}\r\nif (err) {\r\nkfree(str);\r\ngoto exit_free;\r\n} else\r\nf->lsm_str = str;\r\nbreak;\r\ncase AUDIT_WATCH:\r\nstr = audit_unpack_string(&bufp, &remain, f->val);\r\nif (IS_ERR(str))\r\ngoto exit_free;\r\nentry->rule.buflen += f->val;\r\nerr = audit_to_watch(&entry->rule, str, f->val, f->op);\r\nif (err) {\r\nkfree(str);\r\ngoto exit_free;\r\n}\r\nbreak;\r\ncase AUDIT_DIR:\r\nstr = audit_unpack_string(&bufp, &remain, f->val);\r\nif (IS_ERR(str))\r\ngoto exit_free;\r\nentry->rule.buflen += f->val;\r\nerr = audit_make_tree(&entry->rule, str, f->op);\r\nkfree(str);\r\nif (err)\r\ngoto exit_free;\r\nbreak;\r\ncase AUDIT_INODE:\r\nerr = audit_to_inode(&entry->rule, f);\r\nif (err)\r\ngoto exit_free;\r\nbreak;\r\ncase AUDIT_FILTERKEY:\r\nif (entry->rule.filterkey || f->val > AUDIT_MAX_KEY_LEN)\r\ngoto exit_free;\r\nstr = audit_unpack_string(&bufp, &remain, f->val);\r\nif (IS_ERR(str))\r\ngoto exit_free;\r\nentry->rule.buflen += f->val;\r\nentry->rule.filterkey = str;\r\nbreak;\r\ncase AUDIT_EXE:\r\nif (entry->rule.exe || f->val > PATH_MAX)\r\ngoto exit_free;\r\nstr = audit_unpack_string(&bufp, &remain, f->val);\r\nif (IS_ERR(str)) {\r\nerr = PTR_ERR(str);\r\ngoto exit_free;\r\n}\r\nentry->rule.buflen += f->val;\r\naudit_mark = audit_alloc_mark(&entry->rule, str, f->val);\r\nif (IS_ERR(audit_mark)) {\r\nkfree(str);\r\nerr = PTR_ERR(audit_mark);\r\ngoto exit_free;\r\n}\r\nentry->rule.exe = audit_mark;\r\nbreak;\r\n}\r\n}\r\nif (entry->rule.inode_f && entry->rule.inode_f->op == Audit_not_equal)\r\nentry->rule.inode_f = NULL;\r\nexit_nofree:\r\nreturn entry;\r\nexit_free:\r\nif (entry->rule.tree)\r\naudit_put_tree(entry->rule.tree);\r\nif (entry->rule.exe)\r\naudit_remove_mark(entry->rule.exe);\r\naudit_free_rule(entry);\r\nreturn ERR_PTR(err);\r\n}\r\nstatic inline size_t audit_pack_string(void **bufp, const char *str)\r\n{\r\nsize_t len = strlen(str);\r\nmemcpy(*bufp, str, len);\r\n*bufp += len;\r\nreturn len;\r\n}\r\nstatic struct audit_rule_data *audit_krule_to_data(struct audit_krule *krule)\r\n{\r\nstruct audit_rule_data *data;\r\nvoid *bufp;\r\nint i;\r\ndata = kmalloc(sizeof(*data) + krule->buflen, GFP_KERNEL);\r\nif (unlikely(!data))\r\nreturn NULL;\r\nmemset(data, 0, sizeof(*data));\r\ndata->flags = krule->flags | krule->listnr;\r\ndata->action = krule->action;\r\ndata->field_count = krule->field_count;\r\nbufp = data->buf;\r\nfor (i = 0; i < data->field_count; i++) {\r\nstruct audit_field *f = &krule->fields[i];\r\ndata->fields[i] = f->type;\r\ndata->fieldflags[i] = audit_ops[f->op];\r\nswitch(f->type) {\r\ncase AUDIT_SUBJ_USER:\r\ncase AUDIT_SUBJ_ROLE:\r\ncase AUDIT_SUBJ_TYPE:\r\ncase AUDIT_SUBJ_SEN:\r\ncase AUDIT_SUBJ_CLR:\r\ncase AUDIT_OBJ_USER:\r\ncase AUDIT_OBJ_ROLE:\r\ncase AUDIT_OBJ_TYPE:\r\ncase AUDIT_OBJ_LEV_LOW:\r\ncase AUDIT_OBJ_LEV_HIGH:\r\ndata->buflen += data->values[i] =\r\naudit_pack_string(&bufp, f->lsm_str);\r\nbreak;\r\ncase AUDIT_WATCH:\r\ndata->buflen += data->values[i] =\r\naudit_pack_string(&bufp,\r\naudit_watch_path(krule->watch));\r\nbreak;\r\ncase AUDIT_DIR:\r\ndata->buflen += data->values[i] =\r\naudit_pack_string(&bufp,\r\naudit_tree_path(krule->tree));\r\nbreak;\r\ncase AUDIT_FILTERKEY:\r\ndata->buflen += data->values[i] =\r\naudit_pack_string(&bufp, krule->filterkey);\r\nbreak;\r\ncase AUDIT_EXE:\r\ndata->buflen += data->values[i] =\r\naudit_pack_string(&bufp, audit_mark_path(krule->exe));\r\nbreak;\r\ncase AUDIT_LOGINUID_SET:\r\nif (krule->pflags & AUDIT_LOGINUID_LEGACY && !f->val) {\r\ndata->fields[i] = AUDIT_LOGINUID;\r\ndata->values[i] = AUDIT_UID_UNSET;\r\nbreak;\r\n}\r\ndefault:\r\ndata->values[i] = f->val;\r\n}\r\n}\r\nfor (i = 0; i < AUDIT_BITMASK_SIZE; i++) data->mask[i] = krule->mask[i];\r\nreturn data;\r\n}\r\nstatic int audit_compare_rule(struct audit_krule *a, struct audit_krule *b)\r\n{\r\nint i;\r\nif (a->flags != b->flags ||\r\na->pflags != b->pflags ||\r\na->listnr != b->listnr ||\r\na->action != b->action ||\r\na->field_count != b->field_count)\r\nreturn 1;\r\nfor (i = 0; i < a->field_count; i++) {\r\nif (a->fields[i].type != b->fields[i].type ||\r\na->fields[i].op != b->fields[i].op)\r\nreturn 1;\r\nswitch(a->fields[i].type) {\r\ncase AUDIT_SUBJ_USER:\r\ncase AUDIT_SUBJ_ROLE:\r\ncase AUDIT_SUBJ_TYPE:\r\ncase AUDIT_SUBJ_SEN:\r\ncase AUDIT_SUBJ_CLR:\r\ncase AUDIT_OBJ_USER:\r\ncase AUDIT_OBJ_ROLE:\r\ncase AUDIT_OBJ_TYPE:\r\ncase AUDIT_OBJ_LEV_LOW:\r\ncase AUDIT_OBJ_LEV_HIGH:\r\nif (strcmp(a->fields[i].lsm_str, b->fields[i].lsm_str))\r\nreturn 1;\r\nbreak;\r\ncase AUDIT_WATCH:\r\nif (strcmp(audit_watch_path(a->watch),\r\naudit_watch_path(b->watch)))\r\nreturn 1;\r\nbreak;\r\ncase AUDIT_DIR:\r\nif (strcmp(audit_tree_path(a->tree),\r\naudit_tree_path(b->tree)))\r\nreturn 1;\r\nbreak;\r\ncase AUDIT_FILTERKEY:\r\nif (strcmp(a->filterkey, b->filterkey))\r\nreturn 1;\r\nbreak;\r\ncase AUDIT_EXE:\r\nif (strcmp(audit_mark_path(a->exe),\r\naudit_mark_path(b->exe)))\r\nreturn 1;\r\nbreak;\r\ncase AUDIT_UID:\r\ncase AUDIT_EUID:\r\ncase AUDIT_SUID:\r\ncase AUDIT_FSUID:\r\ncase AUDIT_LOGINUID:\r\ncase AUDIT_OBJ_UID:\r\nif (!uid_eq(a->fields[i].uid, b->fields[i].uid))\r\nreturn 1;\r\nbreak;\r\ncase AUDIT_GID:\r\ncase AUDIT_EGID:\r\ncase AUDIT_SGID:\r\ncase AUDIT_FSGID:\r\ncase AUDIT_OBJ_GID:\r\nif (!gid_eq(a->fields[i].gid, b->fields[i].gid))\r\nreturn 1;\r\nbreak;\r\ndefault:\r\nif (a->fields[i].val != b->fields[i].val)\r\nreturn 1;\r\n}\r\n}\r\nfor (i = 0; i < AUDIT_BITMASK_SIZE; i++)\r\nif (a->mask[i] != b->mask[i])\r\nreturn 1;\r\nreturn 0;\r\n}\r\nstatic inline int audit_dupe_lsm_field(struct audit_field *df,\r\nstruct audit_field *sf)\r\n{\r\nint ret = 0;\r\nchar *lsm_str;\r\nlsm_str = kstrdup(sf->lsm_str, GFP_KERNEL);\r\nif (unlikely(!lsm_str))\r\nreturn -ENOMEM;\r\ndf->lsm_str = lsm_str;\r\nret = security_audit_rule_init(df->type, df->op, df->lsm_str,\r\n(void **)&df->lsm_rule);\r\nif (ret == -EINVAL) {\r\npr_warn("audit rule for LSM \'%s\' is invalid\n",\r\ndf->lsm_str);\r\nret = 0;\r\n}\r\nreturn ret;\r\n}\r\nstruct audit_entry *audit_dupe_rule(struct audit_krule *old)\r\n{\r\nu32 fcount = old->field_count;\r\nstruct audit_entry *entry;\r\nstruct audit_krule *new;\r\nchar *fk;\r\nint i, err = 0;\r\nentry = audit_init_entry(fcount);\r\nif (unlikely(!entry))\r\nreturn ERR_PTR(-ENOMEM);\r\nnew = &entry->rule;\r\nnew->flags = old->flags;\r\nnew->pflags = old->pflags;\r\nnew->listnr = old->listnr;\r\nnew->action = old->action;\r\nfor (i = 0; i < AUDIT_BITMASK_SIZE; i++)\r\nnew->mask[i] = old->mask[i];\r\nnew->prio = old->prio;\r\nnew->buflen = old->buflen;\r\nnew->inode_f = old->inode_f;\r\nnew->field_count = old->field_count;\r\nnew->tree = old->tree;\r\nmemcpy(new->fields, old->fields, sizeof(struct audit_field) * fcount);\r\nfor (i = 0; i < fcount; i++) {\r\nswitch (new->fields[i].type) {\r\ncase AUDIT_SUBJ_USER:\r\ncase AUDIT_SUBJ_ROLE:\r\ncase AUDIT_SUBJ_TYPE:\r\ncase AUDIT_SUBJ_SEN:\r\ncase AUDIT_SUBJ_CLR:\r\ncase AUDIT_OBJ_USER:\r\ncase AUDIT_OBJ_ROLE:\r\ncase AUDIT_OBJ_TYPE:\r\ncase AUDIT_OBJ_LEV_LOW:\r\ncase AUDIT_OBJ_LEV_HIGH:\r\nerr = audit_dupe_lsm_field(&new->fields[i],\r\n&old->fields[i]);\r\nbreak;\r\ncase AUDIT_FILTERKEY:\r\nfk = kstrdup(old->filterkey, GFP_KERNEL);\r\nif (unlikely(!fk))\r\nerr = -ENOMEM;\r\nelse\r\nnew->filterkey = fk;\r\nbreak;\r\ncase AUDIT_EXE:\r\nerr = audit_dupe_exe(new, old);\r\nbreak;\r\n}\r\nif (err) {\r\nif (new->exe)\r\naudit_remove_mark(new->exe);\r\naudit_free_rule(entry);\r\nreturn ERR_PTR(err);\r\n}\r\n}\r\nif (old->watch) {\r\naudit_get_watch(old->watch);\r\nnew->watch = old->watch;\r\n}\r\nreturn entry;\r\n}\r\nstatic struct audit_entry *audit_find_rule(struct audit_entry *entry,\r\nstruct list_head **p)\r\n{\r\nstruct audit_entry *e, *found = NULL;\r\nstruct list_head *list;\r\nint h;\r\nif (entry->rule.inode_f) {\r\nh = audit_hash_ino(entry->rule.inode_f->val);\r\n*p = list = &audit_inode_hash[h];\r\n} else if (entry->rule.watch) {\r\nfor (h = 0; h < AUDIT_INODE_BUCKETS; h++) {\r\nlist = &audit_inode_hash[h];\r\nlist_for_each_entry(e, list, list)\r\nif (!audit_compare_rule(&entry->rule, &e->rule)) {\r\nfound = e;\r\ngoto out;\r\n}\r\n}\r\ngoto out;\r\n} else {\r\n*p = list = &audit_filter_list[entry->rule.listnr];\r\n}\r\nlist_for_each_entry(e, list, list)\r\nif (!audit_compare_rule(&entry->rule, &e->rule)) {\r\nfound = e;\r\ngoto out;\r\n}\r\nout:\r\nreturn found;\r\n}\r\nstatic inline int audit_add_rule(struct audit_entry *entry)\r\n{\r\nstruct audit_entry *e;\r\nstruct audit_watch *watch = entry->rule.watch;\r\nstruct audit_tree *tree = entry->rule.tree;\r\nstruct list_head *list;\r\nint err = 0;\r\n#ifdef CONFIG_AUDITSYSCALL\r\nint dont_count = 0;\r\nif (entry->rule.listnr == AUDIT_FILTER_USER ||\r\nentry->rule.listnr == AUDIT_FILTER_TYPE)\r\ndont_count = 1;\r\n#endif\r\nmutex_lock(&audit_filter_mutex);\r\ne = audit_find_rule(entry, &list);\r\nif (e) {\r\nmutex_unlock(&audit_filter_mutex);\r\nerr = -EEXIST;\r\nif (tree)\r\naudit_put_tree(tree);\r\nreturn err;\r\n}\r\nif (watch) {\r\nerr = audit_add_watch(&entry->rule, &list);\r\nif (err) {\r\nmutex_unlock(&audit_filter_mutex);\r\nif (tree)\r\naudit_put_tree(tree);\r\nreturn err;\r\n}\r\n}\r\nif (tree) {\r\nerr = audit_add_tree_rule(&entry->rule);\r\nif (err) {\r\nmutex_unlock(&audit_filter_mutex);\r\nreturn err;\r\n}\r\n}\r\nentry->rule.prio = ~0ULL;\r\nif (entry->rule.listnr == AUDIT_FILTER_EXIT) {\r\nif (entry->rule.flags & AUDIT_FILTER_PREPEND)\r\nentry->rule.prio = ++prio_high;\r\nelse\r\nentry->rule.prio = --prio_low;\r\n}\r\nif (entry->rule.flags & AUDIT_FILTER_PREPEND) {\r\nlist_add(&entry->rule.list,\r\n&audit_rules_list[entry->rule.listnr]);\r\nlist_add_rcu(&entry->list, list);\r\nentry->rule.flags &= ~AUDIT_FILTER_PREPEND;\r\n} else {\r\nlist_add_tail(&entry->rule.list,\r\n&audit_rules_list[entry->rule.listnr]);\r\nlist_add_tail_rcu(&entry->list, list);\r\n}\r\n#ifdef CONFIG_AUDITSYSCALL\r\nif (!dont_count)\r\naudit_n_rules++;\r\nif (!audit_match_signal(entry))\r\naudit_signals++;\r\n#endif\r\nmutex_unlock(&audit_filter_mutex);\r\nreturn err;\r\n}\r\nint audit_del_rule(struct audit_entry *entry)\r\n{\r\nstruct audit_entry *e;\r\nstruct audit_tree *tree = entry->rule.tree;\r\nstruct list_head *list;\r\nint ret = 0;\r\n#ifdef CONFIG_AUDITSYSCALL\r\nint dont_count = 0;\r\nif (entry->rule.listnr == AUDIT_FILTER_USER ||\r\nentry->rule.listnr == AUDIT_FILTER_TYPE)\r\ndont_count = 1;\r\n#endif\r\nmutex_lock(&audit_filter_mutex);\r\ne = audit_find_rule(entry, &list);\r\nif (!e) {\r\nret = -ENOENT;\r\ngoto out;\r\n}\r\nif (e->rule.watch)\r\naudit_remove_watch_rule(&e->rule);\r\nif (e->rule.tree)\r\naudit_remove_tree_rule(&e->rule);\r\nif (e->rule.exe)\r\naudit_remove_mark_rule(&e->rule);\r\n#ifdef CONFIG_AUDITSYSCALL\r\nif (!dont_count)\r\naudit_n_rules--;\r\nif (!audit_match_signal(entry))\r\naudit_signals--;\r\n#endif\r\nlist_del_rcu(&e->list);\r\nlist_del(&e->rule.list);\r\ncall_rcu(&e->rcu, audit_free_rule_rcu);\r\nout:\r\nmutex_unlock(&audit_filter_mutex);\r\nif (tree)\r\naudit_put_tree(tree);\r\nreturn ret;\r\n}\r\nstatic void audit_list_rules(__u32 portid, int seq, struct sk_buff_head *q)\r\n{\r\nstruct sk_buff *skb;\r\nstruct audit_krule *r;\r\nint i;\r\nfor (i=0; i<AUDIT_NR_FILTERS; i++) {\r\nlist_for_each_entry(r, &audit_rules_list[i], list) {\r\nstruct audit_rule_data *data;\r\ndata = audit_krule_to_data(r);\r\nif (unlikely(!data))\r\nbreak;\r\nskb = audit_make_reply(portid, seq, AUDIT_LIST_RULES,\r\n0, 1, data,\r\nsizeof(*data) + data->buflen);\r\nif (skb)\r\nskb_queue_tail(q, skb);\r\nkfree(data);\r\n}\r\n}\r\nskb = audit_make_reply(portid, seq, AUDIT_LIST_RULES, 1, 1, NULL, 0);\r\nif (skb)\r\nskb_queue_tail(q, skb);\r\n}\r\nstatic void audit_log_rule_change(char *action, struct audit_krule *rule, int res)\r\n{\r\nstruct audit_buffer *ab;\r\nuid_t loginuid = from_kuid(&init_user_ns, audit_get_loginuid(current));\r\nunsigned int sessionid = audit_get_sessionid(current);\r\nif (!audit_enabled)\r\nreturn;\r\nab = audit_log_start(NULL, GFP_KERNEL, AUDIT_CONFIG_CHANGE);\r\nif (!ab)\r\nreturn;\r\naudit_log_format(ab, "auid=%u ses=%u" ,loginuid, sessionid);\r\naudit_log_task_context(ab);\r\naudit_log_format(ab, " op=");\r\naudit_log_string(ab, action);\r\naudit_log_key(ab, rule->filterkey);\r\naudit_log_format(ab, " list=%d res=%d", rule->listnr, res);\r\naudit_log_end(ab);\r\n}\r\nint audit_rule_change(int type, __u32 portid, int seq, void *data,\r\nsize_t datasz)\r\n{\r\nint err = 0;\r\nstruct audit_entry *entry;\r\nentry = audit_data_to_entry(data, datasz);\r\nif (IS_ERR(entry))\r\nreturn PTR_ERR(entry);\r\nswitch (type) {\r\ncase AUDIT_ADD_RULE:\r\nerr = audit_add_rule(entry);\r\naudit_log_rule_change("add_rule", &entry->rule, !err);\r\nbreak;\r\ncase AUDIT_DEL_RULE:\r\nerr = audit_del_rule(entry);\r\naudit_log_rule_change("remove_rule", &entry->rule, !err);\r\nbreak;\r\ndefault:\r\nerr = -EINVAL;\r\nWARN_ON(1);\r\n}\r\nif (err || type == AUDIT_DEL_RULE) {\r\nif (entry->rule.exe)\r\naudit_remove_mark(entry->rule.exe);\r\naudit_free_rule(entry);\r\n}\r\nreturn err;\r\n}\r\nint audit_list_rules_send(struct sk_buff *request_skb, int seq)\r\n{\r\nu32 portid = NETLINK_CB(request_skb).portid;\r\nstruct net *net = sock_net(NETLINK_CB(request_skb).sk);\r\nstruct task_struct *tsk;\r\nstruct audit_netlink_list *dest;\r\nint err = 0;\r\ndest = kmalloc(sizeof(struct audit_netlink_list), GFP_KERNEL);\r\nif (!dest)\r\nreturn -ENOMEM;\r\ndest->net = get_net(net);\r\ndest->portid = portid;\r\nskb_queue_head_init(&dest->q);\r\nmutex_lock(&audit_filter_mutex);\r\naudit_list_rules(portid, seq, &dest->q);\r\nmutex_unlock(&audit_filter_mutex);\r\ntsk = kthread_run(audit_send_list, dest, "audit_send_list");\r\nif (IS_ERR(tsk)) {\r\nskb_queue_purge(&dest->q);\r\nkfree(dest);\r\nerr = PTR_ERR(tsk);\r\n}\r\nreturn err;\r\n}\r\nint audit_comparator(u32 left, u32 op, u32 right)\r\n{\r\nswitch (op) {\r\ncase Audit_equal:\r\nreturn (left == right);\r\ncase Audit_not_equal:\r\nreturn (left != right);\r\ncase Audit_lt:\r\nreturn (left < right);\r\ncase Audit_le:\r\nreturn (left <= right);\r\ncase Audit_gt:\r\nreturn (left > right);\r\ncase Audit_ge:\r\nreturn (left >= right);\r\ncase Audit_bitmask:\r\nreturn (left & right);\r\ncase Audit_bittest:\r\nreturn ((left & right) == right);\r\ndefault:\r\nBUG();\r\nreturn 0;\r\n}\r\n}\r\nint audit_uid_comparator(kuid_t left, u32 op, kuid_t right)\r\n{\r\nswitch (op) {\r\ncase Audit_equal:\r\nreturn uid_eq(left, right);\r\ncase Audit_not_equal:\r\nreturn !uid_eq(left, right);\r\ncase Audit_lt:\r\nreturn uid_lt(left, right);\r\ncase Audit_le:\r\nreturn uid_lte(left, right);\r\ncase Audit_gt:\r\nreturn uid_gt(left, right);\r\ncase Audit_ge:\r\nreturn uid_gte(left, right);\r\ncase Audit_bitmask:\r\ncase Audit_bittest:\r\ndefault:\r\nBUG();\r\nreturn 0;\r\n}\r\n}\r\nint audit_gid_comparator(kgid_t left, u32 op, kgid_t right)\r\n{\r\nswitch (op) {\r\ncase Audit_equal:\r\nreturn gid_eq(left, right);\r\ncase Audit_not_equal:\r\nreturn !gid_eq(left, right);\r\ncase Audit_lt:\r\nreturn gid_lt(left, right);\r\ncase Audit_le:\r\nreturn gid_lte(left, right);\r\ncase Audit_gt:\r\nreturn gid_gt(left, right);\r\ncase Audit_ge:\r\nreturn gid_gte(left, right);\r\ncase Audit_bitmask:\r\ncase Audit_bittest:\r\ndefault:\r\nBUG();\r\nreturn 0;\r\n}\r\n}\r\nint parent_len(const char *path)\r\n{\r\nint plen;\r\nconst char *p;\r\nplen = strlen(path);\r\nif (plen == 0)\r\nreturn plen;\r\np = path + plen - 1;\r\nwhile ((*p == '/') && (p > path))\r\np--;\r\nwhile ((*p != '/') && (p > path))\r\np--;\r\nif (*p == '/')\r\np++;\r\nreturn p - path;\r\n}\r\nint audit_compare_dname_path(const char *dname, const char *path, int parentlen)\r\n{\r\nint dlen, pathlen;\r\nconst char *p;\r\ndlen = strlen(dname);\r\npathlen = strlen(path);\r\nif (pathlen < dlen)\r\nreturn 1;\r\nparentlen = parentlen == AUDIT_NAME_FULL ? parent_len(path) : parentlen;\r\nif (pathlen - parentlen != dlen)\r\nreturn 1;\r\np = path + parentlen;\r\nreturn strncmp(p, dname, dlen);\r\n}\r\nstatic int audit_filter_user_rules(struct audit_krule *rule, int type,\r\nenum audit_state *state)\r\n{\r\nint i;\r\nfor (i = 0; i < rule->field_count; i++) {\r\nstruct audit_field *f = &rule->fields[i];\r\npid_t pid;\r\nint result = 0;\r\nu32 sid;\r\nswitch (f->type) {\r\ncase AUDIT_PID:\r\npid = task_pid_nr(current);\r\nresult = audit_comparator(pid, f->op, f->val);\r\nbreak;\r\ncase AUDIT_UID:\r\nresult = audit_uid_comparator(current_uid(), f->op, f->uid);\r\nbreak;\r\ncase AUDIT_GID:\r\nresult = audit_gid_comparator(current_gid(), f->op, f->gid);\r\nbreak;\r\ncase AUDIT_LOGINUID:\r\nresult = audit_uid_comparator(audit_get_loginuid(current),\r\nf->op, f->uid);\r\nbreak;\r\ncase AUDIT_LOGINUID_SET:\r\nresult = audit_comparator(audit_loginuid_set(current),\r\nf->op, f->val);\r\nbreak;\r\ncase AUDIT_MSGTYPE:\r\nresult = audit_comparator(type, f->op, f->val);\r\nbreak;\r\ncase AUDIT_SUBJ_USER:\r\ncase AUDIT_SUBJ_ROLE:\r\ncase AUDIT_SUBJ_TYPE:\r\ncase AUDIT_SUBJ_SEN:\r\ncase AUDIT_SUBJ_CLR:\r\nif (f->lsm_rule) {\r\nsecurity_task_getsecid(current, &sid);\r\nresult = security_audit_rule_match(sid,\r\nf->type,\r\nf->op,\r\nf->lsm_rule,\r\nNULL);\r\n}\r\nbreak;\r\n}\r\nif (!result)\r\nreturn 0;\r\n}\r\nswitch (rule->action) {\r\ncase AUDIT_NEVER: *state = AUDIT_DISABLED; break;\r\ncase AUDIT_ALWAYS: *state = AUDIT_RECORD_CONTEXT; break;\r\n}\r\nreturn 1;\r\n}\r\nint audit_filter_user(int type)\r\n{\r\nenum audit_state state = AUDIT_DISABLED;\r\nstruct audit_entry *e;\r\nint rc, ret;\r\nret = 1;\r\nrcu_read_lock();\r\nlist_for_each_entry_rcu(e, &audit_filter_list[AUDIT_FILTER_USER], list) {\r\nrc = audit_filter_user_rules(&e->rule, type, &state);\r\nif (rc) {\r\nif (rc > 0 && state == AUDIT_DISABLED)\r\nret = 0;\r\nbreak;\r\n}\r\n}\r\nrcu_read_unlock();\r\nreturn ret;\r\n}\r\nint audit_filter_type(int type)\r\n{\r\nstruct audit_entry *e;\r\nint result = 0;\r\nrcu_read_lock();\r\nif (list_empty(&audit_filter_list[AUDIT_FILTER_TYPE]))\r\ngoto unlock_and_return;\r\nlist_for_each_entry_rcu(e, &audit_filter_list[AUDIT_FILTER_TYPE],\r\nlist) {\r\nint i;\r\nfor (i = 0; i < e->rule.field_count; i++) {\r\nstruct audit_field *f = &e->rule.fields[i];\r\nif (f->type == AUDIT_MSGTYPE) {\r\nresult = audit_comparator(type, f->op, f->val);\r\nif (!result)\r\nbreak;\r\n}\r\n}\r\nif (result)\r\ngoto unlock_and_return;\r\n}\r\nunlock_and_return:\r\nrcu_read_unlock();\r\nreturn result;\r\n}\r\nstatic int update_lsm_rule(struct audit_krule *r)\r\n{\r\nstruct audit_entry *entry = container_of(r, struct audit_entry, rule);\r\nstruct audit_entry *nentry;\r\nint err = 0;\r\nif (!security_audit_rule_known(r))\r\nreturn 0;\r\nnentry = audit_dupe_rule(r);\r\nif (entry->rule.exe)\r\naudit_remove_mark(entry->rule.exe);\r\nif (IS_ERR(nentry)) {\r\nerr = PTR_ERR(nentry);\r\naudit_panic("error updating LSM filters");\r\nif (r->watch)\r\nlist_del(&r->rlist);\r\nlist_del_rcu(&entry->list);\r\nlist_del(&r->list);\r\n} else {\r\nif (r->watch || r->tree)\r\nlist_replace_init(&r->rlist, &nentry->rule.rlist);\r\nlist_replace_rcu(&entry->list, &nentry->list);\r\nlist_replace(&r->list, &nentry->rule.list);\r\n}\r\ncall_rcu(&entry->rcu, audit_free_rule_rcu);\r\nreturn err;\r\n}\r\nint audit_update_lsm_rules(void)\r\n{\r\nstruct audit_krule *r, *n;\r\nint i, err = 0;\r\nmutex_lock(&audit_filter_mutex);\r\nfor (i = 0; i < AUDIT_NR_FILTERS; i++) {\r\nlist_for_each_entry_safe(r, n, &audit_rules_list[i], list) {\r\nint res = update_lsm_rule(r);\r\nif (!err)\r\nerr = res;\r\n}\r\n}\r\nmutex_unlock(&audit_filter_mutex);\r\nreturn err;\r\n}
