void __quota_error(struct super_block *sb, const char *func,\r\nconst char *fmt, ...)\r\n{\r\nif (printk_ratelimit()) {\r\nva_list args;\r\nstruct va_format vaf;\r\nva_start(args, fmt);\r\nvaf.fmt = fmt;\r\nvaf.va = &args;\r\nprintk(KERN_ERR "Quota error (device %s): %s: %pV\n",\r\nsb->s_id, func, &vaf);\r\nva_end(args);\r\n}\r\n}\r\nint register_quota_format(struct quota_format_type *fmt)\r\n{\r\nspin_lock(&dq_list_lock);\r\nfmt->qf_next = quota_formats;\r\nquota_formats = fmt;\r\nspin_unlock(&dq_list_lock);\r\nreturn 0;\r\n}\r\nvoid unregister_quota_format(struct quota_format_type *fmt)\r\n{\r\nstruct quota_format_type **actqf;\r\nspin_lock(&dq_list_lock);\r\nfor (actqf = &quota_formats; *actqf && *actqf != fmt;\r\nactqf = &(*actqf)->qf_next)\r\n;\r\nif (*actqf)\r\n*actqf = (*actqf)->qf_next;\r\nspin_unlock(&dq_list_lock);\r\n}\r\nstatic struct quota_format_type *find_quota_format(int id)\r\n{\r\nstruct quota_format_type *actqf;\r\nspin_lock(&dq_list_lock);\r\nfor (actqf = quota_formats; actqf && actqf->qf_fmt_id != id;\r\nactqf = actqf->qf_next)\r\n;\r\nif (!actqf || !try_module_get(actqf->qf_owner)) {\r\nint qm;\r\nspin_unlock(&dq_list_lock);\r\nfor (qm = 0; module_names[qm].qm_fmt_id &&\r\nmodule_names[qm].qm_fmt_id != id; qm++)\r\n;\r\nif (!module_names[qm].qm_fmt_id ||\r\nrequest_module(module_names[qm].qm_mod_name))\r\nreturn NULL;\r\nspin_lock(&dq_list_lock);\r\nfor (actqf = quota_formats; actqf && actqf->qf_fmt_id != id;\r\nactqf = actqf->qf_next)\r\n;\r\nif (actqf && !try_module_get(actqf->qf_owner))\r\nactqf = NULL;\r\n}\r\nspin_unlock(&dq_list_lock);\r\nreturn actqf;\r\n}\r\nstatic void put_quota_format(struct quota_format_type *fmt)\r\n{\r\nmodule_put(fmt->qf_owner);\r\n}\r\nstatic inline unsigned int\r\nhashfn(const struct super_block *sb, struct kqid qid)\r\n{\r\nunsigned int id = from_kqid(&init_user_ns, qid);\r\nint type = qid.type;\r\nunsigned long tmp;\r\ntmp = (((unsigned long)sb>>L1_CACHE_SHIFT) ^ id) * (MAXQUOTAS - type);\r\nreturn (tmp + (tmp >> dq_hash_bits)) & dq_hash_mask;\r\n}\r\nstatic inline void insert_dquot_hash(struct dquot *dquot)\r\n{\r\nstruct hlist_head *head;\r\nhead = dquot_hash + hashfn(dquot->dq_sb, dquot->dq_id);\r\nhlist_add_head(&dquot->dq_hash, head);\r\n}\r\nstatic inline void remove_dquot_hash(struct dquot *dquot)\r\n{\r\nhlist_del_init(&dquot->dq_hash);\r\n}\r\nstatic struct dquot *find_dquot(unsigned int hashent, struct super_block *sb,\r\nstruct kqid qid)\r\n{\r\nstruct hlist_node *node;\r\nstruct dquot *dquot;\r\nhlist_for_each (node, dquot_hash+hashent) {\r\ndquot = hlist_entry(node, struct dquot, dq_hash);\r\nif (dquot->dq_sb == sb && qid_eq(dquot->dq_id, qid))\r\nreturn dquot;\r\n}\r\nreturn NULL;\r\n}\r\nstatic inline void put_dquot_last(struct dquot *dquot)\r\n{\r\nlist_add_tail(&dquot->dq_free, &free_dquots);\r\ndqstats_inc(DQST_FREE_DQUOTS);\r\n}\r\nstatic inline void remove_free_dquot(struct dquot *dquot)\r\n{\r\nif (list_empty(&dquot->dq_free))\r\nreturn;\r\nlist_del_init(&dquot->dq_free);\r\ndqstats_dec(DQST_FREE_DQUOTS);\r\n}\r\nstatic inline void put_inuse(struct dquot *dquot)\r\n{\r\nlist_add_tail(&dquot->dq_inuse, &inuse_list);\r\ndqstats_inc(DQST_ALLOC_DQUOTS);\r\n}\r\nstatic inline void remove_inuse(struct dquot *dquot)\r\n{\r\ndqstats_dec(DQST_ALLOC_DQUOTS);\r\nlist_del(&dquot->dq_inuse);\r\n}\r\nstatic void wait_on_dquot(struct dquot *dquot)\r\n{\r\nmutex_lock(&dquot->dq_lock);\r\nmutex_unlock(&dquot->dq_lock);\r\n}\r\nstatic inline int dquot_dirty(struct dquot *dquot)\r\n{\r\nreturn test_bit(DQ_MOD_B, &dquot->dq_flags);\r\n}\r\nstatic inline int mark_dquot_dirty(struct dquot *dquot)\r\n{\r\nreturn dquot->dq_sb->dq_op->mark_dirty(dquot);\r\n}\r\nint dquot_mark_dquot_dirty(struct dquot *dquot)\r\n{\r\nint ret = 1;\r\nif (test_bit(DQ_MOD_B, &dquot->dq_flags))\r\nreturn 1;\r\nspin_lock(&dq_list_lock);\r\nif (!test_and_set_bit(DQ_MOD_B, &dquot->dq_flags)) {\r\nlist_add(&dquot->dq_dirty, &sb_dqopt(dquot->dq_sb)->\r\ninfo[dquot->dq_id.type].dqi_dirty_list);\r\nret = 0;\r\n}\r\nspin_unlock(&dq_list_lock);\r\nreturn ret;\r\n}\r\nstatic inline int mark_all_dquot_dirty(struct dquot * const *dquot)\r\n{\r\nint ret, err, cnt;\r\nret = err = 0;\r\nfor (cnt = 0; cnt < MAXQUOTAS; cnt++) {\r\nif (dquot[cnt])\r\nret = mark_dquot_dirty(dquot[cnt]);\r\nif (!err)\r\nerr = ret;\r\n}\r\nreturn err;\r\n}\r\nstatic inline void dqput_all(struct dquot **dquot)\r\n{\r\nunsigned int cnt;\r\nfor (cnt = 0; cnt < MAXQUOTAS; cnt++)\r\ndqput(dquot[cnt]);\r\n}\r\nstatic inline int clear_dquot_dirty(struct dquot *dquot)\r\n{\r\nif (!test_and_clear_bit(DQ_MOD_B, &dquot->dq_flags))\r\nreturn 0;\r\nlist_del_init(&dquot->dq_dirty);\r\nreturn 1;\r\n}\r\nvoid mark_info_dirty(struct super_block *sb, int type)\r\n{\r\nset_bit(DQF_INFO_DIRTY_B, &sb_dqopt(sb)->info[type].dqi_flags);\r\n}\r\nint dquot_acquire(struct dquot *dquot)\r\n{\r\nint ret = 0, ret2 = 0;\r\nstruct quota_info *dqopt = sb_dqopt(dquot->dq_sb);\r\nmutex_lock(&dquot->dq_lock);\r\nmutex_lock(&dqopt->dqio_mutex);\r\nif (!test_bit(DQ_READ_B, &dquot->dq_flags))\r\nret = dqopt->ops[dquot->dq_id.type]->read_dqblk(dquot);\r\nif (ret < 0)\r\ngoto out_iolock;\r\nsmp_mb__before_atomic();\r\nset_bit(DQ_READ_B, &dquot->dq_flags);\r\nif (!test_bit(DQ_ACTIVE_B, &dquot->dq_flags) && !dquot->dq_off) {\r\nret = dqopt->ops[dquot->dq_id.type]->commit_dqblk(dquot);\r\nif (info_dirty(&dqopt->info[dquot->dq_id.type])) {\r\nret2 = dqopt->ops[dquot->dq_id.type]->write_file_info(\r\ndquot->dq_sb, dquot->dq_id.type);\r\n}\r\nif (ret < 0)\r\ngoto out_iolock;\r\nif (ret2 < 0) {\r\nret = ret2;\r\ngoto out_iolock;\r\n}\r\n}\r\nsmp_mb__before_atomic();\r\nset_bit(DQ_ACTIVE_B, &dquot->dq_flags);\r\nout_iolock:\r\nmutex_unlock(&dqopt->dqio_mutex);\r\nmutex_unlock(&dquot->dq_lock);\r\nreturn ret;\r\n}\r\nint dquot_commit(struct dquot *dquot)\r\n{\r\nint ret = 0;\r\nstruct quota_info *dqopt = sb_dqopt(dquot->dq_sb);\r\nmutex_lock(&dqopt->dqio_mutex);\r\nspin_lock(&dq_list_lock);\r\nif (!clear_dquot_dirty(dquot)) {\r\nspin_unlock(&dq_list_lock);\r\ngoto out_sem;\r\n}\r\nspin_unlock(&dq_list_lock);\r\nif (test_bit(DQ_ACTIVE_B, &dquot->dq_flags))\r\nret = dqopt->ops[dquot->dq_id.type]->commit_dqblk(dquot);\r\nelse\r\nret = -EIO;\r\nout_sem:\r\nmutex_unlock(&dqopt->dqio_mutex);\r\nreturn ret;\r\n}\r\nint dquot_release(struct dquot *dquot)\r\n{\r\nint ret = 0, ret2 = 0;\r\nstruct quota_info *dqopt = sb_dqopt(dquot->dq_sb);\r\nmutex_lock(&dquot->dq_lock);\r\nif (atomic_read(&dquot->dq_count) > 1)\r\ngoto out_dqlock;\r\nmutex_lock(&dqopt->dqio_mutex);\r\nif (dqopt->ops[dquot->dq_id.type]->release_dqblk) {\r\nret = dqopt->ops[dquot->dq_id.type]->release_dqblk(dquot);\r\nif (info_dirty(&dqopt->info[dquot->dq_id.type])) {\r\nret2 = dqopt->ops[dquot->dq_id.type]->write_file_info(\r\ndquot->dq_sb, dquot->dq_id.type);\r\n}\r\nif (ret >= 0)\r\nret = ret2;\r\n}\r\nclear_bit(DQ_ACTIVE_B, &dquot->dq_flags);\r\nmutex_unlock(&dqopt->dqio_mutex);\r\nout_dqlock:\r\nmutex_unlock(&dquot->dq_lock);\r\nreturn ret;\r\n}\r\nvoid dquot_destroy(struct dquot *dquot)\r\n{\r\nkmem_cache_free(dquot_cachep, dquot);\r\n}\r\nstatic inline void do_destroy_dquot(struct dquot *dquot)\r\n{\r\ndquot->dq_sb->dq_op->destroy_dquot(dquot);\r\n}\r\nstatic void invalidate_dquots(struct super_block *sb, int type)\r\n{\r\nstruct dquot *dquot, *tmp;\r\nrestart:\r\nspin_lock(&dq_list_lock);\r\nlist_for_each_entry_safe(dquot, tmp, &inuse_list, dq_inuse) {\r\nif (dquot->dq_sb != sb)\r\ncontinue;\r\nif (dquot->dq_id.type != type)\r\ncontinue;\r\nif (atomic_read(&dquot->dq_count)) {\r\nDEFINE_WAIT(wait);\r\ndqgrab(dquot);\r\nprepare_to_wait(&dquot->dq_wait_unused, &wait,\r\nTASK_UNINTERRUPTIBLE);\r\nspin_unlock(&dq_list_lock);\r\nif (atomic_read(&dquot->dq_count) > 1)\r\nschedule();\r\nfinish_wait(&dquot->dq_wait_unused, &wait);\r\ndqput(dquot);\r\ngoto restart;\r\n}\r\nremove_dquot_hash(dquot);\r\nremove_free_dquot(dquot);\r\nremove_inuse(dquot);\r\ndo_destroy_dquot(dquot);\r\n}\r\nspin_unlock(&dq_list_lock);\r\n}\r\nint dquot_scan_active(struct super_block *sb,\r\nint (*fn)(struct dquot *dquot, unsigned long priv),\r\nunsigned long priv)\r\n{\r\nstruct dquot *dquot, *old_dquot = NULL;\r\nint ret = 0;\r\nmutex_lock(&sb_dqopt(sb)->dqonoff_mutex);\r\nspin_lock(&dq_list_lock);\r\nlist_for_each_entry(dquot, &inuse_list, dq_inuse) {\r\nif (!test_bit(DQ_ACTIVE_B, &dquot->dq_flags))\r\ncontinue;\r\nif (dquot->dq_sb != sb)\r\ncontinue;\r\natomic_inc(&dquot->dq_count);\r\nspin_unlock(&dq_list_lock);\r\ndqstats_inc(DQST_LOOKUPS);\r\ndqput(old_dquot);\r\nold_dquot = dquot;\r\nwait_on_dquot(dquot);\r\nif (test_bit(DQ_ACTIVE_B, &dquot->dq_flags)) {\r\nret = fn(dquot, priv);\r\nif (ret < 0)\r\ngoto out;\r\n}\r\nspin_lock(&dq_list_lock);\r\n}\r\nspin_unlock(&dq_list_lock);\r\nout:\r\ndqput(old_dquot);\r\nmutex_unlock(&sb_dqopt(sb)->dqonoff_mutex);\r\nreturn ret;\r\n}\r\nint dquot_writeback_dquots(struct super_block *sb, int type)\r\n{\r\nstruct list_head *dirty;\r\nstruct dquot *dquot;\r\nstruct quota_info *dqopt = sb_dqopt(sb);\r\nint cnt;\r\nint err, ret = 0;\r\nmutex_lock(&dqopt->dqonoff_mutex);\r\nfor (cnt = 0; cnt < MAXQUOTAS; cnt++) {\r\nif (type != -1 && cnt != type)\r\ncontinue;\r\nif (!sb_has_quota_active(sb, cnt))\r\ncontinue;\r\nspin_lock(&dq_list_lock);\r\ndirty = &dqopt->info[cnt].dqi_dirty_list;\r\nwhile (!list_empty(dirty)) {\r\ndquot = list_first_entry(dirty, struct dquot,\r\ndq_dirty);\r\nif (!test_bit(DQ_ACTIVE_B, &dquot->dq_flags)) {\r\nclear_dquot_dirty(dquot);\r\ncontinue;\r\n}\r\ndqgrab(dquot);\r\nspin_unlock(&dq_list_lock);\r\ndqstats_inc(DQST_LOOKUPS);\r\nerr = sb->dq_op->write_dquot(dquot);\r\nif (!ret && err)\r\nret = err;\r\ndqput(dquot);\r\nspin_lock(&dq_list_lock);\r\n}\r\nspin_unlock(&dq_list_lock);\r\n}\r\nfor (cnt = 0; cnt < MAXQUOTAS; cnt++)\r\nif ((cnt == type || type == -1) && sb_has_quota_active(sb, cnt)\r\n&& info_dirty(&dqopt->info[cnt]))\r\nsb->dq_op->write_info(sb, cnt);\r\ndqstats_inc(DQST_SYNCS);\r\nmutex_unlock(&dqopt->dqonoff_mutex);\r\nreturn ret;\r\n}\r\nint dquot_quota_sync(struct super_block *sb, int type)\r\n{\r\nstruct quota_info *dqopt = sb_dqopt(sb);\r\nint cnt;\r\nint ret;\r\nret = dquot_writeback_dquots(sb, type);\r\nif (ret)\r\nreturn ret;\r\nif (dqopt->flags & DQUOT_QUOTA_SYS_FILE)\r\nreturn 0;\r\nif (sb->s_op->sync_fs)\r\nsb->s_op->sync_fs(sb, 1);\r\nsync_blockdev(sb->s_bdev);\r\nmutex_lock(&dqopt->dqonoff_mutex);\r\nfor (cnt = 0; cnt < MAXQUOTAS; cnt++) {\r\nif (type != -1 && cnt != type)\r\ncontinue;\r\nif (!sb_has_quota_active(sb, cnt))\r\ncontinue;\r\ninode_lock(dqopt->files[cnt]);\r\ntruncate_inode_pages(&dqopt->files[cnt]->i_data, 0);\r\ninode_unlock(dqopt->files[cnt]);\r\n}\r\nmutex_unlock(&dqopt->dqonoff_mutex);\r\nreturn 0;\r\n}\r\nstatic unsigned long\r\ndqcache_shrink_scan(struct shrinker *shrink, struct shrink_control *sc)\r\n{\r\nstruct list_head *head;\r\nstruct dquot *dquot;\r\nunsigned long freed = 0;\r\nspin_lock(&dq_list_lock);\r\nhead = free_dquots.prev;\r\nwhile (head != &free_dquots && sc->nr_to_scan) {\r\ndquot = list_entry(head, struct dquot, dq_free);\r\nremove_dquot_hash(dquot);\r\nremove_free_dquot(dquot);\r\nremove_inuse(dquot);\r\ndo_destroy_dquot(dquot);\r\nsc->nr_to_scan--;\r\nfreed++;\r\nhead = free_dquots.prev;\r\n}\r\nspin_unlock(&dq_list_lock);\r\nreturn freed;\r\n}\r\nstatic unsigned long\r\ndqcache_shrink_count(struct shrinker *shrink, struct shrink_control *sc)\r\n{\r\nreturn vfs_pressure_ratio(\r\npercpu_counter_read_positive(&dqstats.counter[DQST_FREE_DQUOTS]));\r\n}\r\nvoid dqput(struct dquot *dquot)\r\n{\r\nint ret;\r\nif (!dquot)\r\nreturn;\r\n#ifdef CONFIG_QUOTA_DEBUG\r\nif (!atomic_read(&dquot->dq_count)) {\r\nquota_error(dquot->dq_sb, "trying to free free dquot of %s %d",\r\nquotatypes[dquot->dq_id.type],\r\nfrom_kqid(&init_user_ns, dquot->dq_id));\r\nBUG();\r\n}\r\n#endif\r\ndqstats_inc(DQST_DROPS);\r\nwe_slept:\r\nspin_lock(&dq_list_lock);\r\nif (atomic_read(&dquot->dq_count) > 1) {\r\natomic_dec(&dquot->dq_count);\r\nif (!sb_has_quota_active(dquot->dq_sb, dquot->dq_id.type) &&\r\natomic_read(&dquot->dq_count) == 1)\r\nwake_up(&dquot->dq_wait_unused);\r\nspin_unlock(&dq_list_lock);\r\nreturn;\r\n}\r\nif (test_bit(DQ_ACTIVE_B, &dquot->dq_flags) && dquot_dirty(dquot)) {\r\nspin_unlock(&dq_list_lock);\r\nret = dquot->dq_sb->dq_op->write_dquot(dquot);\r\nif (ret < 0) {\r\nquota_error(dquot->dq_sb, "Can't write quota structure"\r\n" (error %d). Quota may get out of sync!",\r\nret);\r\nspin_lock(&dq_list_lock);\r\nclear_dquot_dirty(dquot);\r\nspin_unlock(&dq_list_lock);\r\n}\r\ngoto we_slept;\r\n}\r\nclear_dquot_dirty(dquot);\r\nif (test_bit(DQ_ACTIVE_B, &dquot->dq_flags)) {\r\nspin_unlock(&dq_list_lock);\r\ndquot->dq_sb->dq_op->release_dquot(dquot);\r\ngoto we_slept;\r\n}\r\natomic_dec(&dquot->dq_count);\r\n#ifdef CONFIG_QUOTA_DEBUG\r\nBUG_ON(!list_empty(&dquot->dq_free));\r\n#endif\r\nput_dquot_last(dquot);\r\nspin_unlock(&dq_list_lock);\r\n}\r\nstruct dquot *dquot_alloc(struct super_block *sb, int type)\r\n{\r\nreturn kmem_cache_zalloc(dquot_cachep, GFP_NOFS);\r\n}\r\nstatic struct dquot *get_empty_dquot(struct super_block *sb, int type)\r\n{\r\nstruct dquot *dquot;\r\ndquot = sb->dq_op->alloc_dquot(sb, type);\r\nif(!dquot)\r\nreturn NULL;\r\nmutex_init(&dquot->dq_lock);\r\nINIT_LIST_HEAD(&dquot->dq_free);\r\nINIT_LIST_HEAD(&dquot->dq_inuse);\r\nINIT_HLIST_NODE(&dquot->dq_hash);\r\nINIT_LIST_HEAD(&dquot->dq_dirty);\r\ninit_waitqueue_head(&dquot->dq_wait_unused);\r\ndquot->dq_sb = sb;\r\ndquot->dq_id = make_kqid_invalid(type);\r\natomic_set(&dquot->dq_count, 1);\r\nreturn dquot;\r\n}\r\nstruct dquot *dqget(struct super_block *sb, struct kqid qid)\r\n{\r\nunsigned int hashent = hashfn(sb, qid);\r\nstruct dquot *dquot, *empty = NULL;\r\nif (!sb_has_quota_active(sb, qid.type))\r\nreturn ERR_PTR(-ESRCH);\r\nwe_slept:\r\nspin_lock(&dq_list_lock);\r\nspin_lock(&dq_state_lock);\r\nif (!sb_has_quota_active(sb, qid.type)) {\r\nspin_unlock(&dq_state_lock);\r\nspin_unlock(&dq_list_lock);\r\ndquot = ERR_PTR(-ESRCH);\r\ngoto out;\r\n}\r\nspin_unlock(&dq_state_lock);\r\ndquot = find_dquot(hashent, sb, qid);\r\nif (!dquot) {\r\nif (!empty) {\r\nspin_unlock(&dq_list_lock);\r\nempty = get_empty_dquot(sb, qid.type);\r\nif (!empty)\r\nschedule();\r\ngoto we_slept;\r\n}\r\ndquot = empty;\r\nempty = NULL;\r\ndquot->dq_id = qid;\r\nput_inuse(dquot);\r\ninsert_dquot_hash(dquot);\r\nspin_unlock(&dq_list_lock);\r\ndqstats_inc(DQST_LOOKUPS);\r\n} else {\r\nif (!atomic_read(&dquot->dq_count))\r\nremove_free_dquot(dquot);\r\natomic_inc(&dquot->dq_count);\r\nspin_unlock(&dq_list_lock);\r\ndqstats_inc(DQST_CACHE_HITS);\r\ndqstats_inc(DQST_LOOKUPS);\r\n}\r\nwait_on_dquot(dquot);\r\nif (!test_bit(DQ_ACTIVE_B, &dquot->dq_flags)) {\r\nint err;\r\nerr = sb->dq_op->acquire_dquot(dquot);\r\nif (err < 0) {\r\ndqput(dquot);\r\ndquot = ERR_PTR(err);\r\ngoto out;\r\n}\r\n}\r\nsmp_rmb();\r\n#ifdef CONFIG_QUOTA_DEBUG\r\nBUG_ON(!dquot->dq_sb);\r\n#endif\r\nout:\r\nif (empty)\r\ndo_destroy_dquot(empty);\r\nreturn dquot;\r\n}\r\nstatic inline struct dquot **i_dquot(struct inode *inode)\r\n{\r\nreturn inode->i_sb->s_op->get_dquots(inode);\r\n}\r\nstatic int dqinit_needed(struct inode *inode, int type)\r\n{\r\nstruct dquot * const *dquots;\r\nint cnt;\r\nif (IS_NOQUOTA(inode))\r\nreturn 0;\r\ndquots = i_dquot(inode);\r\nif (type != -1)\r\nreturn !dquots[type];\r\nfor (cnt = 0; cnt < MAXQUOTAS; cnt++)\r\nif (!dquots[cnt])\r\nreturn 1;\r\nreturn 0;\r\n}\r\nstatic void add_dquot_ref(struct super_block *sb, int type)\r\n{\r\nstruct inode *inode, *old_inode = NULL;\r\n#ifdef CONFIG_QUOTA_DEBUG\r\nint reserved = 0;\r\n#endif\r\nspin_lock(&sb->s_inode_list_lock);\r\nlist_for_each_entry(inode, &sb->s_inodes, i_sb_list) {\r\nspin_lock(&inode->i_lock);\r\nif ((inode->i_state & (I_FREEING|I_WILL_FREE|I_NEW)) ||\r\n!atomic_read(&inode->i_writecount) ||\r\n!dqinit_needed(inode, type)) {\r\nspin_unlock(&inode->i_lock);\r\ncontinue;\r\n}\r\n__iget(inode);\r\nspin_unlock(&inode->i_lock);\r\nspin_unlock(&sb->s_inode_list_lock);\r\n#ifdef CONFIG_QUOTA_DEBUG\r\nif (unlikely(inode_get_rsv_space(inode) > 0))\r\nreserved = 1;\r\n#endif\r\niput(old_inode);\r\n__dquot_initialize(inode, type);\r\nold_inode = inode;\r\nspin_lock(&sb->s_inode_list_lock);\r\n}\r\nspin_unlock(&sb->s_inode_list_lock);\r\niput(old_inode);\r\n#ifdef CONFIG_QUOTA_DEBUG\r\nif (reserved) {\r\nquota_error(sb, "Writes happened before quota was turned on "\r\n"thus quota information is probably inconsistent. "\r\n"Please run quotacheck(8)");\r\n}\r\n#endif\r\n}\r\nstatic void remove_inode_dquot_ref(struct inode *inode, int type,\r\nstruct list_head *tofree_head)\r\n{\r\nstruct dquot **dquots = i_dquot(inode);\r\nstruct dquot *dquot = dquots[type];\r\nif (!dquot)\r\nreturn;\r\ndquots[type] = NULL;\r\nif (list_empty(&dquot->dq_free)) {\r\nspin_lock(&dq_list_lock);\r\nlist_add(&dquot->dq_free, tofree_head);\r\nspin_unlock(&dq_list_lock);\r\n} else {\r\ndqput(dquot);\r\n}\r\n}\r\nstatic void put_dquot_list(struct list_head *tofree_head)\r\n{\r\nstruct list_head *act_head;\r\nstruct dquot *dquot;\r\nact_head = tofree_head->next;\r\nwhile (act_head != tofree_head) {\r\ndquot = list_entry(act_head, struct dquot, dq_free);\r\nact_head = act_head->next;\r\nlist_del_init(&dquot->dq_free);\r\ndqput(dquot);\r\n}\r\n}\r\nstatic void remove_dquot_ref(struct super_block *sb, int type,\r\nstruct list_head *tofree_head)\r\n{\r\nstruct inode *inode;\r\nint reserved = 0;\r\nspin_lock(&sb->s_inode_list_lock);\r\nlist_for_each_entry(inode, &sb->s_inodes, i_sb_list) {\r\nspin_lock(&dq_data_lock);\r\nif (!IS_NOQUOTA(inode)) {\r\nif (unlikely(inode_get_rsv_space(inode) > 0))\r\nreserved = 1;\r\nremove_inode_dquot_ref(inode, type, tofree_head);\r\n}\r\nspin_unlock(&dq_data_lock);\r\n}\r\nspin_unlock(&sb->s_inode_list_lock);\r\n#ifdef CONFIG_QUOTA_DEBUG\r\nif (reserved) {\r\nprintk(KERN_WARNING "VFS (%s): Writes happened after quota"\r\n" was disabled thus quota information is probably "\r\n"inconsistent. Please run quotacheck(8).\n", sb->s_id);\r\n}\r\n#endif\r\n}\r\nstatic void drop_dquot_ref(struct super_block *sb, int type)\r\n{\r\nLIST_HEAD(tofree_head);\r\nif (sb->dq_op) {\r\nremove_dquot_ref(sb, type, &tofree_head);\r\nsynchronize_srcu(&dquot_srcu);\r\nput_dquot_list(&tofree_head);\r\n}\r\n}\r\nstatic inline void dquot_incr_inodes(struct dquot *dquot, qsize_t number)\r\n{\r\ndquot->dq_dqb.dqb_curinodes += number;\r\n}\r\nstatic inline void dquot_incr_space(struct dquot *dquot, qsize_t number)\r\n{\r\ndquot->dq_dqb.dqb_curspace += number;\r\n}\r\nstatic inline void dquot_resv_space(struct dquot *dquot, qsize_t number)\r\n{\r\ndquot->dq_dqb.dqb_rsvspace += number;\r\n}\r\nstatic void dquot_claim_reserved_space(struct dquot *dquot, qsize_t number)\r\n{\r\nif (dquot->dq_dqb.dqb_rsvspace < number) {\r\nWARN_ON_ONCE(1);\r\nnumber = dquot->dq_dqb.dqb_rsvspace;\r\n}\r\ndquot->dq_dqb.dqb_curspace += number;\r\ndquot->dq_dqb.dqb_rsvspace -= number;\r\n}\r\nstatic void dquot_reclaim_reserved_space(struct dquot *dquot, qsize_t number)\r\n{\r\nif (WARN_ON_ONCE(dquot->dq_dqb.dqb_curspace < number))\r\nnumber = dquot->dq_dqb.dqb_curspace;\r\ndquot->dq_dqb.dqb_rsvspace += number;\r\ndquot->dq_dqb.dqb_curspace -= number;\r\n}\r\nstatic inline\r\nvoid dquot_free_reserved_space(struct dquot *dquot, qsize_t number)\r\n{\r\nif (dquot->dq_dqb.dqb_rsvspace >= number)\r\ndquot->dq_dqb.dqb_rsvspace -= number;\r\nelse {\r\nWARN_ON_ONCE(1);\r\ndquot->dq_dqb.dqb_rsvspace = 0;\r\n}\r\n}\r\nstatic void dquot_decr_inodes(struct dquot *dquot, qsize_t number)\r\n{\r\nif (sb_dqopt(dquot->dq_sb)->flags & DQUOT_NEGATIVE_USAGE ||\r\ndquot->dq_dqb.dqb_curinodes >= number)\r\ndquot->dq_dqb.dqb_curinodes -= number;\r\nelse\r\ndquot->dq_dqb.dqb_curinodes = 0;\r\nif (dquot->dq_dqb.dqb_curinodes <= dquot->dq_dqb.dqb_isoftlimit)\r\ndquot->dq_dqb.dqb_itime = (time_t) 0;\r\nclear_bit(DQ_INODES_B, &dquot->dq_flags);\r\n}\r\nstatic void dquot_decr_space(struct dquot *dquot, qsize_t number)\r\n{\r\nif (sb_dqopt(dquot->dq_sb)->flags & DQUOT_NEGATIVE_USAGE ||\r\ndquot->dq_dqb.dqb_curspace >= number)\r\ndquot->dq_dqb.dqb_curspace -= number;\r\nelse\r\ndquot->dq_dqb.dqb_curspace = 0;\r\nif (dquot->dq_dqb.dqb_curspace <= dquot->dq_dqb.dqb_bsoftlimit)\r\ndquot->dq_dqb.dqb_btime = (time_t) 0;\r\nclear_bit(DQ_BLKS_B, &dquot->dq_flags);\r\n}\r\nstatic int warning_issued(struct dquot *dquot, const int warntype)\r\n{\r\nint flag = (warntype == QUOTA_NL_BHARDWARN ||\r\nwarntype == QUOTA_NL_BSOFTLONGWARN) ? DQ_BLKS_B :\r\n((warntype == QUOTA_NL_IHARDWARN ||\r\nwarntype == QUOTA_NL_ISOFTLONGWARN) ? DQ_INODES_B : 0);\r\nif (!flag)\r\nreturn 0;\r\nreturn test_and_set_bit(flag, &dquot->dq_flags);\r\n}\r\nstatic int need_print_warning(struct dquot_warn *warn)\r\n{\r\nif (!flag_print_warnings)\r\nreturn 0;\r\nswitch (warn->w_dq_id.type) {\r\ncase USRQUOTA:\r\nreturn uid_eq(current_fsuid(), warn->w_dq_id.uid);\r\ncase GRPQUOTA:\r\nreturn in_group_p(warn->w_dq_id.gid);\r\ncase PRJQUOTA:\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}\r\nstatic void print_warning(struct dquot_warn *warn)\r\n{\r\nchar *msg = NULL;\r\nstruct tty_struct *tty;\r\nint warntype = warn->w_type;\r\nif (warntype == QUOTA_NL_IHARDBELOW ||\r\nwarntype == QUOTA_NL_ISOFTBELOW ||\r\nwarntype == QUOTA_NL_BHARDBELOW ||\r\nwarntype == QUOTA_NL_BSOFTBELOW || !need_print_warning(warn))\r\nreturn;\r\ntty = get_current_tty();\r\nif (!tty)\r\nreturn;\r\ntty_write_message(tty, warn->w_sb->s_id);\r\nif (warntype == QUOTA_NL_ISOFTWARN || warntype == QUOTA_NL_BSOFTWARN)\r\ntty_write_message(tty, ": warning, ");\r\nelse\r\ntty_write_message(tty, ": write failed, ");\r\ntty_write_message(tty, quotatypes[warn->w_dq_id.type]);\r\nswitch (warntype) {\r\ncase QUOTA_NL_IHARDWARN:\r\nmsg = " file limit reached.\r\n";\r\nbreak;\r\ncase QUOTA_NL_ISOFTLONGWARN:\r\nmsg = " file quota exceeded too long.\r\n";\r\nbreak;\r\ncase QUOTA_NL_ISOFTWARN:\r\nmsg = " file quota exceeded.\r\n";\r\nbreak;\r\ncase QUOTA_NL_BHARDWARN:\r\nmsg = " block limit reached.\r\n";\r\nbreak;\r\ncase QUOTA_NL_BSOFTLONGWARN:\r\nmsg = " block quota exceeded too long.\r\n";\r\nbreak;\r\ncase QUOTA_NL_BSOFTWARN:\r\nmsg = " block quota exceeded.\r\n";\r\nbreak;\r\n}\r\ntty_write_message(tty, msg);\r\ntty_kref_put(tty);\r\n}\r\nstatic void prepare_warning(struct dquot_warn *warn, struct dquot *dquot,\r\nint warntype)\r\n{\r\nif (warning_issued(dquot, warntype))\r\nreturn;\r\nwarn->w_type = warntype;\r\nwarn->w_sb = dquot->dq_sb;\r\nwarn->w_dq_id = dquot->dq_id;\r\n}\r\nstatic void flush_warnings(struct dquot_warn *warn)\r\n{\r\nint i;\r\nfor (i = 0; i < MAXQUOTAS; i++) {\r\nif (warn[i].w_type == QUOTA_NL_NOWARN)\r\ncontinue;\r\n#ifdef CONFIG_PRINT_QUOTA_WARNING\r\nprint_warning(&warn[i]);\r\n#endif\r\nquota_send_warning(warn[i].w_dq_id,\r\nwarn[i].w_sb->s_dev, warn[i].w_type);\r\n}\r\n}\r\nstatic int ignore_hardlimit(struct dquot *dquot)\r\n{\r\nstruct mem_dqinfo *info = &sb_dqopt(dquot->dq_sb)->info[dquot->dq_id.type];\r\nreturn capable(CAP_SYS_RESOURCE) &&\r\n(info->dqi_format->qf_fmt_id != QFMT_VFS_OLD ||\r\n!(info->dqi_flags & DQF_ROOT_SQUASH));\r\n}\r\nstatic int check_idq(struct dquot *dquot, qsize_t inodes,\r\nstruct dquot_warn *warn)\r\n{\r\nqsize_t newinodes = dquot->dq_dqb.dqb_curinodes + inodes;\r\nif (!sb_has_quota_limits_enabled(dquot->dq_sb, dquot->dq_id.type) ||\r\ntest_bit(DQ_FAKE_B, &dquot->dq_flags))\r\nreturn 0;\r\nif (dquot->dq_dqb.dqb_ihardlimit &&\r\nnewinodes > dquot->dq_dqb.dqb_ihardlimit &&\r\n!ignore_hardlimit(dquot)) {\r\nprepare_warning(warn, dquot, QUOTA_NL_IHARDWARN);\r\nreturn -EDQUOT;\r\n}\r\nif (dquot->dq_dqb.dqb_isoftlimit &&\r\nnewinodes > dquot->dq_dqb.dqb_isoftlimit &&\r\ndquot->dq_dqb.dqb_itime &&\r\nget_seconds() >= dquot->dq_dqb.dqb_itime &&\r\n!ignore_hardlimit(dquot)) {\r\nprepare_warning(warn, dquot, QUOTA_NL_ISOFTLONGWARN);\r\nreturn -EDQUOT;\r\n}\r\nif (dquot->dq_dqb.dqb_isoftlimit &&\r\nnewinodes > dquot->dq_dqb.dqb_isoftlimit &&\r\ndquot->dq_dqb.dqb_itime == 0) {\r\nprepare_warning(warn, dquot, QUOTA_NL_ISOFTWARN);\r\ndquot->dq_dqb.dqb_itime = get_seconds() +\r\nsb_dqopt(dquot->dq_sb)->info[dquot->dq_id.type].dqi_igrace;\r\n}\r\nreturn 0;\r\n}\r\nstatic int check_bdq(struct dquot *dquot, qsize_t space, int prealloc,\r\nstruct dquot_warn *warn)\r\n{\r\nqsize_t tspace;\r\nstruct super_block *sb = dquot->dq_sb;\r\nif (!sb_has_quota_limits_enabled(sb, dquot->dq_id.type) ||\r\ntest_bit(DQ_FAKE_B, &dquot->dq_flags))\r\nreturn 0;\r\ntspace = dquot->dq_dqb.dqb_curspace + dquot->dq_dqb.dqb_rsvspace\r\n+ space;\r\nif (dquot->dq_dqb.dqb_bhardlimit &&\r\ntspace > dquot->dq_dqb.dqb_bhardlimit &&\r\n!ignore_hardlimit(dquot)) {\r\nif (!prealloc)\r\nprepare_warning(warn, dquot, QUOTA_NL_BHARDWARN);\r\nreturn -EDQUOT;\r\n}\r\nif (dquot->dq_dqb.dqb_bsoftlimit &&\r\ntspace > dquot->dq_dqb.dqb_bsoftlimit &&\r\ndquot->dq_dqb.dqb_btime &&\r\nget_seconds() >= dquot->dq_dqb.dqb_btime &&\r\n!ignore_hardlimit(dquot)) {\r\nif (!prealloc)\r\nprepare_warning(warn, dquot, QUOTA_NL_BSOFTLONGWARN);\r\nreturn -EDQUOT;\r\n}\r\nif (dquot->dq_dqb.dqb_bsoftlimit &&\r\ntspace > dquot->dq_dqb.dqb_bsoftlimit &&\r\ndquot->dq_dqb.dqb_btime == 0) {\r\nif (!prealloc) {\r\nprepare_warning(warn, dquot, QUOTA_NL_BSOFTWARN);\r\ndquot->dq_dqb.dqb_btime = get_seconds() +\r\nsb_dqopt(sb)->info[dquot->dq_id.type].dqi_bgrace;\r\n}\r\nelse\r\nreturn -EDQUOT;\r\n}\r\nreturn 0;\r\n}\r\nstatic int info_idq_free(struct dquot *dquot, qsize_t inodes)\r\n{\r\nqsize_t newinodes;\r\nif (test_bit(DQ_FAKE_B, &dquot->dq_flags) ||\r\ndquot->dq_dqb.dqb_curinodes <= dquot->dq_dqb.dqb_isoftlimit ||\r\n!sb_has_quota_limits_enabled(dquot->dq_sb, dquot->dq_id.type))\r\nreturn QUOTA_NL_NOWARN;\r\nnewinodes = dquot->dq_dqb.dqb_curinodes - inodes;\r\nif (newinodes <= dquot->dq_dqb.dqb_isoftlimit)\r\nreturn QUOTA_NL_ISOFTBELOW;\r\nif (dquot->dq_dqb.dqb_curinodes >= dquot->dq_dqb.dqb_ihardlimit &&\r\nnewinodes < dquot->dq_dqb.dqb_ihardlimit)\r\nreturn QUOTA_NL_IHARDBELOW;\r\nreturn QUOTA_NL_NOWARN;\r\n}\r\nstatic int info_bdq_free(struct dquot *dquot, qsize_t space)\r\n{\r\nif (test_bit(DQ_FAKE_B, &dquot->dq_flags) ||\r\ndquot->dq_dqb.dqb_curspace <= dquot->dq_dqb.dqb_bsoftlimit)\r\nreturn QUOTA_NL_NOWARN;\r\nif (dquot->dq_dqb.dqb_curspace - space <= dquot->dq_dqb.dqb_bsoftlimit)\r\nreturn QUOTA_NL_BSOFTBELOW;\r\nif (dquot->dq_dqb.dqb_curspace >= dquot->dq_dqb.dqb_bhardlimit &&\r\ndquot->dq_dqb.dqb_curspace - space < dquot->dq_dqb.dqb_bhardlimit)\r\nreturn QUOTA_NL_BHARDBELOW;\r\nreturn QUOTA_NL_NOWARN;\r\n}\r\nstatic int dquot_active(const struct inode *inode)\r\n{\r\nstruct super_block *sb = inode->i_sb;\r\nif (IS_NOQUOTA(inode))\r\nreturn 0;\r\nreturn sb_any_quota_loaded(sb) & ~sb_any_quota_suspended(sb);\r\n}\r\nstatic int __dquot_initialize(struct inode *inode, int type)\r\n{\r\nint cnt, init_needed = 0;\r\nstruct dquot **dquots, *got[MAXQUOTAS] = {};\r\nstruct super_block *sb = inode->i_sb;\r\nqsize_t rsv;\r\nint ret = 0;\r\nif (!dquot_active(inode))\r\nreturn 0;\r\ndquots = i_dquot(inode);\r\nfor (cnt = 0; cnt < MAXQUOTAS; cnt++) {\r\nstruct kqid qid;\r\nkprojid_t projid;\r\nint rc;\r\nstruct dquot *dquot;\r\nif (type != -1 && cnt != type)\r\ncontinue;\r\nif (dquots[cnt])\r\ncontinue;\r\nif (!sb_has_quota_active(sb, cnt))\r\ncontinue;\r\ninit_needed = 1;\r\nswitch (cnt) {\r\ncase USRQUOTA:\r\nqid = make_kqid_uid(inode->i_uid);\r\nbreak;\r\ncase GRPQUOTA:\r\nqid = make_kqid_gid(inode->i_gid);\r\nbreak;\r\ncase PRJQUOTA:\r\nrc = inode->i_sb->dq_op->get_projid(inode, &projid);\r\nif (rc)\r\ncontinue;\r\nqid = make_kqid_projid(projid);\r\nbreak;\r\n}\r\ndquot = dqget(sb, qid);\r\nif (IS_ERR(dquot)) {\r\nif (PTR_ERR(dquot) != -ESRCH) {\r\nret = PTR_ERR(dquot);\r\ngoto out_put;\r\n}\r\ndquot = NULL;\r\n}\r\ngot[cnt] = dquot;\r\n}\r\nif (!init_needed)\r\nreturn 0;\r\nspin_lock(&dq_data_lock);\r\nif (IS_NOQUOTA(inode))\r\ngoto out_lock;\r\nfor (cnt = 0; cnt < MAXQUOTAS; cnt++) {\r\nif (type != -1 && cnt != type)\r\ncontinue;\r\nif (!sb_has_quota_active(sb, cnt))\r\ncontinue;\r\nif (!got[cnt])\r\ncontinue;\r\nif (!dquots[cnt]) {\r\ndquots[cnt] = got[cnt];\r\ngot[cnt] = NULL;\r\nrsv = inode_get_rsv_space(inode);\r\nif (unlikely(rsv))\r\ndquot_resv_space(dquots[cnt], rsv);\r\n}\r\n}\r\nout_lock:\r\nspin_unlock(&dq_data_lock);\r\nout_put:\r\ndqput_all(got);\r\nreturn ret;\r\n}\r\nint dquot_initialize(struct inode *inode)\r\n{\r\nreturn __dquot_initialize(inode, -1);\r\n}\r\nstatic void __dquot_drop(struct inode *inode)\r\n{\r\nint cnt;\r\nstruct dquot **dquots = i_dquot(inode);\r\nstruct dquot *put[MAXQUOTAS];\r\nspin_lock(&dq_data_lock);\r\nfor (cnt = 0; cnt < MAXQUOTAS; cnt++) {\r\nput[cnt] = dquots[cnt];\r\ndquots[cnt] = NULL;\r\n}\r\nspin_unlock(&dq_data_lock);\r\ndqput_all(put);\r\n}\r\nvoid dquot_drop(struct inode *inode)\r\n{\r\nstruct dquot * const *dquots;\r\nint cnt;\r\nif (IS_NOQUOTA(inode))\r\nreturn;\r\ndquots = i_dquot(inode);\r\nfor (cnt = 0; cnt < MAXQUOTAS; cnt++) {\r\nif (dquots[cnt])\r\nbreak;\r\n}\r\nif (cnt < MAXQUOTAS)\r\n__dquot_drop(inode);\r\n}\r\nstatic qsize_t *inode_reserved_space(struct inode * inode)\r\n{\r\nBUG_ON(!inode->i_sb->dq_op->get_reserved_space);\r\nreturn inode->i_sb->dq_op->get_reserved_space(inode);\r\n}\r\nvoid inode_add_rsv_space(struct inode *inode, qsize_t number)\r\n{\r\nspin_lock(&inode->i_lock);\r\n*inode_reserved_space(inode) += number;\r\nspin_unlock(&inode->i_lock);\r\n}\r\nvoid inode_claim_rsv_space(struct inode *inode, qsize_t number)\r\n{\r\nspin_lock(&inode->i_lock);\r\n*inode_reserved_space(inode) -= number;\r\n__inode_add_bytes(inode, number);\r\nspin_unlock(&inode->i_lock);\r\n}\r\nvoid inode_reclaim_rsv_space(struct inode *inode, qsize_t number)\r\n{\r\nspin_lock(&inode->i_lock);\r\n*inode_reserved_space(inode) += number;\r\n__inode_sub_bytes(inode, number);\r\nspin_unlock(&inode->i_lock);\r\n}\r\nvoid inode_sub_rsv_space(struct inode *inode, qsize_t number)\r\n{\r\nspin_lock(&inode->i_lock);\r\n*inode_reserved_space(inode) -= number;\r\nspin_unlock(&inode->i_lock);\r\n}\r\nstatic qsize_t inode_get_rsv_space(struct inode *inode)\r\n{\r\nqsize_t ret;\r\nif (!inode->i_sb->dq_op->get_reserved_space)\r\nreturn 0;\r\nspin_lock(&inode->i_lock);\r\nret = *inode_reserved_space(inode);\r\nspin_unlock(&inode->i_lock);\r\nreturn ret;\r\n}\r\nstatic void inode_incr_space(struct inode *inode, qsize_t number,\r\nint reserve)\r\n{\r\nif (reserve)\r\ninode_add_rsv_space(inode, number);\r\nelse\r\ninode_add_bytes(inode, number);\r\n}\r\nstatic void inode_decr_space(struct inode *inode, qsize_t number, int reserve)\r\n{\r\nif (reserve)\r\ninode_sub_rsv_space(inode, number);\r\nelse\r\ninode_sub_bytes(inode, number);\r\n}\r\nint __dquot_alloc_space(struct inode *inode, qsize_t number, int flags)\r\n{\r\nint cnt, ret = 0, index;\r\nstruct dquot_warn warn[MAXQUOTAS];\r\nint reserve = flags & DQUOT_SPACE_RESERVE;\r\nstruct dquot **dquots;\r\nif (!dquot_active(inode)) {\r\ninode_incr_space(inode, number, reserve);\r\ngoto out;\r\n}\r\nfor (cnt = 0; cnt < MAXQUOTAS; cnt++)\r\nwarn[cnt].w_type = QUOTA_NL_NOWARN;\r\ndquots = i_dquot(inode);\r\nindex = srcu_read_lock(&dquot_srcu);\r\nspin_lock(&dq_data_lock);\r\nfor (cnt = 0; cnt < MAXQUOTAS; cnt++) {\r\nif (!dquots[cnt])\r\ncontinue;\r\nret = check_bdq(dquots[cnt], number,\r\n!(flags & DQUOT_SPACE_WARN), &warn[cnt]);\r\nif (ret && !(flags & DQUOT_SPACE_NOFAIL)) {\r\nspin_unlock(&dq_data_lock);\r\ngoto out_flush_warn;\r\n}\r\n}\r\nfor (cnt = 0; cnt < MAXQUOTAS; cnt++) {\r\nif (!dquots[cnt])\r\ncontinue;\r\nif (reserve)\r\ndquot_resv_space(dquots[cnt], number);\r\nelse\r\ndquot_incr_space(dquots[cnt], number);\r\n}\r\ninode_incr_space(inode, number, reserve);\r\nspin_unlock(&dq_data_lock);\r\nif (reserve)\r\ngoto out_flush_warn;\r\nmark_all_dquot_dirty(dquots);\r\nout_flush_warn:\r\nsrcu_read_unlock(&dquot_srcu, index);\r\nflush_warnings(warn);\r\nout:\r\nreturn ret;\r\n}\r\nint dquot_alloc_inode(struct inode *inode)\r\n{\r\nint cnt, ret = 0, index;\r\nstruct dquot_warn warn[MAXQUOTAS];\r\nstruct dquot * const *dquots;\r\nif (!dquot_active(inode))\r\nreturn 0;\r\nfor (cnt = 0; cnt < MAXQUOTAS; cnt++)\r\nwarn[cnt].w_type = QUOTA_NL_NOWARN;\r\ndquots = i_dquot(inode);\r\nindex = srcu_read_lock(&dquot_srcu);\r\nspin_lock(&dq_data_lock);\r\nfor (cnt = 0; cnt < MAXQUOTAS; cnt++) {\r\nif (!dquots[cnt])\r\ncontinue;\r\nret = check_idq(dquots[cnt], 1, &warn[cnt]);\r\nif (ret)\r\ngoto warn_put_all;\r\n}\r\nfor (cnt = 0; cnt < MAXQUOTAS; cnt++) {\r\nif (!dquots[cnt])\r\ncontinue;\r\ndquot_incr_inodes(dquots[cnt], 1);\r\n}\r\nwarn_put_all:\r\nspin_unlock(&dq_data_lock);\r\nif (ret == 0)\r\nmark_all_dquot_dirty(dquots);\r\nsrcu_read_unlock(&dquot_srcu, index);\r\nflush_warnings(warn);\r\nreturn ret;\r\n}\r\nint dquot_claim_space_nodirty(struct inode *inode, qsize_t number)\r\n{\r\nstruct dquot **dquots;\r\nint cnt, index;\r\nif (!dquot_active(inode)) {\r\ninode_claim_rsv_space(inode, number);\r\nreturn 0;\r\n}\r\ndquots = i_dquot(inode);\r\nindex = srcu_read_lock(&dquot_srcu);\r\nspin_lock(&dq_data_lock);\r\nfor (cnt = 0; cnt < MAXQUOTAS; cnt++) {\r\nif (dquots[cnt])\r\ndquot_claim_reserved_space(dquots[cnt], number);\r\n}\r\ninode_claim_rsv_space(inode, number);\r\nspin_unlock(&dq_data_lock);\r\nmark_all_dquot_dirty(dquots);\r\nsrcu_read_unlock(&dquot_srcu, index);\r\nreturn 0;\r\n}\r\nvoid dquot_reclaim_space_nodirty(struct inode *inode, qsize_t number)\r\n{\r\nstruct dquot **dquots;\r\nint cnt, index;\r\nif (!dquot_active(inode)) {\r\ninode_reclaim_rsv_space(inode, number);\r\nreturn;\r\n}\r\ndquots = i_dquot(inode);\r\nindex = srcu_read_lock(&dquot_srcu);\r\nspin_lock(&dq_data_lock);\r\nfor (cnt = 0; cnt < MAXQUOTAS; cnt++) {\r\nif (dquots[cnt])\r\ndquot_reclaim_reserved_space(dquots[cnt], number);\r\n}\r\ninode_reclaim_rsv_space(inode, number);\r\nspin_unlock(&dq_data_lock);\r\nmark_all_dquot_dirty(dquots);\r\nsrcu_read_unlock(&dquot_srcu, index);\r\nreturn;\r\n}\r\nvoid __dquot_free_space(struct inode *inode, qsize_t number, int flags)\r\n{\r\nunsigned int cnt;\r\nstruct dquot_warn warn[MAXQUOTAS];\r\nstruct dquot **dquots;\r\nint reserve = flags & DQUOT_SPACE_RESERVE, index;\r\nif (!dquot_active(inode)) {\r\ninode_decr_space(inode, number, reserve);\r\nreturn;\r\n}\r\ndquots = i_dquot(inode);\r\nindex = srcu_read_lock(&dquot_srcu);\r\nspin_lock(&dq_data_lock);\r\nfor (cnt = 0; cnt < MAXQUOTAS; cnt++) {\r\nint wtype;\r\nwarn[cnt].w_type = QUOTA_NL_NOWARN;\r\nif (!dquots[cnt])\r\ncontinue;\r\nwtype = info_bdq_free(dquots[cnt], number);\r\nif (wtype != QUOTA_NL_NOWARN)\r\nprepare_warning(&warn[cnt], dquots[cnt], wtype);\r\nif (reserve)\r\ndquot_free_reserved_space(dquots[cnt], number);\r\nelse\r\ndquot_decr_space(dquots[cnt], number);\r\n}\r\ninode_decr_space(inode, number, reserve);\r\nspin_unlock(&dq_data_lock);\r\nif (reserve)\r\ngoto out_unlock;\r\nmark_all_dquot_dirty(dquots);\r\nout_unlock:\r\nsrcu_read_unlock(&dquot_srcu, index);\r\nflush_warnings(warn);\r\n}\r\nvoid dquot_free_inode(struct inode *inode)\r\n{\r\nunsigned int cnt;\r\nstruct dquot_warn warn[MAXQUOTAS];\r\nstruct dquot * const *dquots;\r\nint index;\r\nif (!dquot_active(inode))\r\nreturn;\r\ndquots = i_dquot(inode);\r\nindex = srcu_read_lock(&dquot_srcu);\r\nspin_lock(&dq_data_lock);\r\nfor (cnt = 0; cnt < MAXQUOTAS; cnt++) {\r\nint wtype;\r\nwarn[cnt].w_type = QUOTA_NL_NOWARN;\r\nif (!dquots[cnt])\r\ncontinue;\r\nwtype = info_idq_free(dquots[cnt], 1);\r\nif (wtype != QUOTA_NL_NOWARN)\r\nprepare_warning(&warn[cnt], dquots[cnt], wtype);\r\ndquot_decr_inodes(dquots[cnt], 1);\r\n}\r\nspin_unlock(&dq_data_lock);\r\nmark_all_dquot_dirty(dquots);\r\nsrcu_read_unlock(&dquot_srcu, index);\r\nflush_warnings(warn);\r\n}\r\nint __dquot_transfer(struct inode *inode, struct dquot **transfer_to)\r\n{\r\nqsize_t space, cur_space;\r\nqsize_t rsv_space = 0;\r\nstruct dquot *transfer_from[MAXQUOTAS] = {};\r\nint cnt, ret = 0;\r\nchar is_valid[MAXQUOTAS] = {};\r\nstruct dquot_warn warn_to[MAXQUOTAS];\r\nstruct dquot_warn warn_from_inodes[MAXQUOTAS];\r\nstruct dquot_warn warn_from_space[MAXQUOTAS];\r\nif (IS_NOQUOTA(inode))\r\nreturn 0;\r\nfor (cnt = 0; cnt < MAXQUOTAS; cnt++) {\r\nwarn_to[cnt].w_type = QUOTA_NL_NOWARN;\r\nwarn_from_inodes[cnt].w_type = QUOTA_NL_NOWARN;\r\nwarn_from_space[cnt].w_type = QUOTA_NL_NOWARN;\r\n}\r\nspin_lock(&dq_data_lock);\r\nif (IS_NOQUOTA(inode)) {\r\nspin_unlock(&dq_data_lock);\r\nreturn 0;\r\n}\r\ncur_space = inode_get_bytes(inode);\r\nrsv_space = inode_get_rsv_space(inode);\r\nspace = cur_space + rsv_space;\r\nfor (cnt = 0; cnt < MAXQUOTAS; cnt++) {\r\nif (!transfer_to[cnt])\r\ncontinue;\r\nif (!sb_has_quota_active(inode->i_sb, cnt))\r\ncontinue;\r\nis_valid[cnt] = 1;\r\ntransfer_from[cnt] = i_dquot(inode)[cnt];\r\nret = check_idq(transfer_to[cnt], 1, &warn_to[cnt]);\r\nif (ret)\r\ngoto over_quota;\r\nret = check_bdq(transfer_to[cnt], space, 0, &warn_to[cnt]);\r\nif (ret)\r\ngoto over_quota;\r\n}\r\nfor (cnt = 0; cnt < MAXQUOTAS; cnt++) {\r\nif (!is_valid[cnt])\r\ncontinue;\r\nif (transfer_from[cnt]) {\r\nint wtype;\r\nwtype = info_idq_free(transfer_from[cnt], 1);\r\nif (wtype != QUOTA_NL_NOWARN)\r\nprepare_warning(&warn_from_inodes[cnt],\r\ntransfer_from[cnt], wtype);\r\nwtype = info_bdq_free(transfer_from[cnt], space);\r\nif (wtype != QUOTA_NL_NOWARN)\r\nprepare_warning(&warn_from_space[cnt],\r\ntransfer_from[cnt], wtype);\r\ndquot_decr_inodes(transfer_from[cnt], 1);\r\ndquot_decr_space(transfer_from[cnt], cur_space);\r\ndquot_free_reserved_space(transfer_from[cnt],\r\nrsv_space);\r\n}\r\ndquot_incr_inodes(transfer_to[cnt], 1);\r\ndquot_incr_space(transfer_to[cnt], cur_space);\r\ndquot_resv_space(transfer_to[cnt], rsv_space);\r\ni_dquot(inode)[cnt] = transfer_to[cnt];\r\n}\r\nspin_unlock(&dq_data_lock);\r\nmark_all_dquot_dirty(transfer_from);\r\nmark_all_dquot_dirty(transfer_to);\r\nflush_warnings(warn_to);\r\nflush_warnings(warn_from_inodes);\r\nflush_warnings(warn_from_space);\r\nfor (cnt = 0; cnt < MAXQUOTAS; cnt++)\r\nif (is_valid[cnt])\r\ntransfer_to[cnt] = transfer_from[cnt];\r\nreturn 0;\r\nover_quota:\r\nspin_unlock(&dq_data_lock);\r\nflush_warnings(warn_to);\r\nreturn ret;\r\n}\r\nint dquot_transfer(struct inode *inode, struct iattr *iattr)\r\n{\r\nstruct dquot *transfer_to[MAXQUOTAS] = {};\r\nstruct dquot *dquot;\r\nstruct super_block *sb = inode->i_sb;\r\nint ret;\r\nif (!dquot_active(inode))\r\nreturn 0;\r\nif (iattr->ia_valid & ATTR_UID && !uid_eq(iattr->ia_uid, inode->i_uid)){\r\ndquot = dqget(sb, make_kqid_uid(iattr->ia_uid));\r\nif (IS_ERR(dquot)) {\r\nif (PTR_ERR(dquot) != -ESRCH) {\r\nret = PTR_ERR(dquot);\r\ngoto out_put;\r\n}\r\ndquot = NULL;\r\n}\r\ntransfer_to[USRQUOTA] = dquot;\r\n}\r\nif (iattr->ia_valid & ATTR_GID && !gid_eq(iattr->ia_gid, inode->i_gid)){\r\ndquot = dqget(sb, make_kqid_gid(iattr->ia_gid));\r\nif (IS_ERR(dquot)) {\r\nif (PTR_ERR(dquot) != -ESRCH) {\r\nret = PTR_ERR(dquot);\r\ngoto out_put;\r\n}\r\ndquot = NULL;\r\n}\r\ntransfer_to[GRPQUOTA] = dquot;\r\n}\r\nret = __dquot_transfer(inode, transfer_to);\r\nout_put:\r\ndqput_all(transfer_to);\r\nreturn ret;\r\n}\r\nint dquot_commit_info(struct super_block *sb, int type)\r\n{\r\nint ret;\r\nstruct quota_info *dqopt = sb_dqopt(sb);\r\nmutex_lock(&dqopt->dqio_mutex);\r\nret = dqopt->ops[type]->write_file_info(sb, type);\r\nmutex_unlock(&dqopt->dqio_mutex);\r\nreturn ret;\r\n}\r\nint dquot_get_next_id(struct super_block *sb, struct kqid *qid)\r\n{\r\nstruct quota_info *dqopt = sb_dqopt(sb);\r\nint err;\r\nmutex_lock(&dqopt->dqonoff_mutex);\r\nif (!sb_has_quota_active(sb, qid->type)) {\r\nerr = -ESRCH;\r\ngoto out;\r\n}\r\nif (!dqopt->ops[qid->type]->get_next_id) {\r\nerr = -ENOSYS;\r\ngoto out;\r\n}\r\nmutex_lock(&dqopt->dqio_mutex);\r\nerr = dqopt->ops[qid->type]->get_next_id(sb, qid);\r\nmutex_unlock(&dqopt->dqio_mutex);\r\nout:\r\nmutex_unlock(&dqopt->dqonoff_mutex);\r\nreturn err;\r\n}\r\nint dquot_file_open(struct inode *inode, struct file *file)\r\n{\r\nint error;\r\nerror = generic_file_open(inode, file);\r\nif (!error && (file->f_mode & FMODE_WRITE))\r\ndquot_initialize(inode);\r\nreturn error;\r\n}\r\nint dquot_disable(struct super_block *sb, int type, unsigned int flags)\r\n{\r\nint cnt, ret = 0;\r\nstruct quota_info *dqopt = sb_dqopt(sb);\r\nstruct inode *toputinode[MAXQUOTAS];\r\nif ((flags & DQUOT_USAGE_ENABLED && !(flags & DQUOT_LIMITS_ENABLED))\r\n|| (flags & DQUOT_SUSPENDED && flags & (DQUOT_LIMITS_ENABLED |\r\nDQUOT_USAGE_ENABLED)))\r\nreturn -EINVAL;\r\nmutex_lock(&dqopt->dqonoff_mutex);\r\nif (!sb_any_quota_loaded(sb)) {\r\nmutex_unlock(&dqopt->dqonoff_mutex);\r\nreturn 0;\r\n}\r\nfor (cnt = 0; cnt < MAXQUOTAS; cnt++) {\r\ntoputinode[cnt] = NULL;\r\nif (type != -1 && cnt != type)\r\ncontinue;\r\nif (!sb_has_quota_loaded(sb, cnt))\r\ncontinue;\r\nif (flags & DQUOT_SUSPENDED) {\r\nspin_lock(&dq_state_lock);\r\ndqopt->flags |=\r\ndquot_state_flag(DQUOT_SUSPENDED, cnt);\r\nspin_unlock(&dq_state_lock);\r\n} else {\r\nspin_lock(&dq_state_lock);\r\ndqopt->flags &= ~dquot_state_flag(flags, cnt);\r\nif (!sb_has_quota_loaded(sb, cnt) &&\r\nsb_has_quota_suspended(sb, cnt)) {\r\ndqopt->flags &= ~dquot_state_flag(\r\nDQUOT_SUSPENDED, cnt);\r\nspin_unlock(&dq_state_lock);\r\niput(dqopt->files[cnt]);\r\ndqopt->files[cnt] = NULL;\r\ncontinue;\r\n}\r\nspin_unlock(&dq_state_lock);\r\n}\r\nif (sb_has_quota_loaded(sb, cnt) && !(flags & DQUOT_SUSPENDED))\r\ncontinue;\r\ndrop_dquot_ref(sb, cnt);\r\ninvalidate_dquots(sb, cnt);\r\nif (info_dirty(&dqopt->info[cnt]))\r\nsb->dq_op->write_info(sb, cnt);\r\nif (dqopt->ops[cnt]->free_file_info)\r\ndqopt->ops[cnt]->free_file_info(sb, cnt);\r\nput_quota_format(dqopt->info[cnt].dqi_format);\r\ntoputinode[cnt] = dqopt->files[cnt];\r\nif (!sb_has_quota_loaded(sb, cnt))\r\ndqopt->files[cnt] = NULL;\r\ndqopt->info[cnt].dqi_flags = 0;\r\ndqopt->info[cnt].dqi_igrace = 0;\r\ndqopt->info[cnt].dqi_bgrace = 0;\r\ndqopt->ops[cnt] = NULL;\r\n}\r\nmutex_unlock(&dqopt->dqonoff_mutex);\r\nif (dqopt->flags & DQUOT_QUOTA_SYS_FILE)\r\ngoto put_inodes;\r\nif (sb->s_op->sync_fs)\r\nsb->s_op->sync_fs(sb, 1);\r\nsync_blockdev(sb->s_bdev);\r\nfor (cnt = 0; cnt < MAXQUOTAS; cnt++)\r\nif (toputinode[cnt]) {\r\nmutex_lock(&dqopt->dqonoff_mutex);\r\nif (!sb_has_quota_loaded(sb, cnt)) {\r\ninode_lock(toputinode[cnt]);\r\ntoputinode[cnt]->i_flags &= ~(S_IMMUTABLE |\r\nS_NOATIME | S_NOQUOTA);\r\ntruncate_inode_pages(&toputinode[cnt]->i_data,\r\n0);\r\ninode_unlock(toputinode[cnt]);\r\nmark_inode_dirty_sync(toputinode[cnt]);\r\n}\r\nmutex_unlock(&dqopt->dqonoff_mutex);\r\n}\r\nif (sb->s_bdev)\r\ninvalidate_bdev(sb->s_bdev);\r\nput_inodes:\r\nfor (cnt = 0; cnt < MAXQUOTAS; cnt++)\r\nif (toputinode[cnt]) {\r\nif (!(flags & DQUOT_SUSPENDED))\r\niput(toputinode[cnt]);\r\nelse if (!toputinode[cnt]->i_nlink)\r\nret = -EBUSY;\r\n}\r\nreturn ret;\r\n}\r\nint dquot_quota_off(struct super_block *sb, int type)\r\n{\r\nreturn dquot_disable(sb, type,\r\nDQUOT_USAGE_ENABLED | DQUOT_LIMITS_ENABLED);\r\n}\r\nstatic int vfs_load_quota_inode(struct inode *inode, int type, int format_id,\r\nunsigned int flags)\r\n{\r\nstruct quota_format_type *fmt = find_quota_format(format_id);\r\nstruct super_block *sb = inode->i_sb;\r\nstruct quota_info *dqopt = sb_dqopt(sb);\r\nint error;\r\nint oldflags = -1;\r\nif (!fmt)\r\nreturn -ESRCH;\r\nif (!S_ISREG(inode->i_mode)) {\r\nerror = -EACCES;\r\ngoto out_fmt;\r\n}\r\nif (IS_RDONLY(inode)) {\r\nerror = -EROFS;\r\ngoto out_fmt;\r\n}\r\nif (!sb->s_op->quota_write || !sb->s_op->quota_read ||\r\n(type == PRJQUOTA && sb->dq_op->get_projid == NULL)) {\r\nerror = -EINVAL;\r\ngoto out_fmt;\r\n}\r\nif (!(flags & DQUOT_USAGE_ENABLED)) {\r\nerror = -EINVAL;\r\ngoto out_fmt;\r\n}\r\nif (!(dqopt->flags & DQUOT_QUOTA_SYS_FILE)) {\r\nsync_filesystem(sb);\r\ninvalidate_bdev(sb->s_bdev);\r\n}\r\nmutex_lock(&dqopt->dqonoff_mutex);\r\nif (sb_has_quota_loaded(sb, type)) {\r\nerror = -EBUSY;\r\ngoto out_lock;\r\n}\r\nif (!(dqopt->flags & DQUOT_QUOTA_SYS_FILE)) {\r\ninode_lock(inode);\r\noldflags = inode->i_flags & (S_NOATIME | S_IMMUTABLE |\r\nS_NOQUOTA);\r\ninode->i_flags |= S_NOQUOTA | S_NOATIME | S_IMMUTABLE;\r\ninode_unlock(inode);\r\n__dquot_drop(inode);\r\n}\r\nerror = -EIO;\r\ndqopt->files[type] = igrab(inode);\r\nif (!dqopt->files[type])\r\ngoto out_lock;\r\nerror = -EINVAL;\r\nif (!fmt->qf_ops->check_quota_file(sb, type))\r\ngoto out_file_init;\r\ndqopt->ops[type] = fmt->qf_ops;\r\ndqopt->info[type].dqi_format = fmt;\r\ndqopt->info[type].dqi_fmt_id = format_id;\r\nINIT_LIST_HEAD(&dqopt->info[type].dqi_dirty_list);\r\nmutex_lock(&dqopt->dqio_mutex);\r\nerror = dqopt->ops[type]->read_file_info(sb, type);\r\nif (error < 0) {\r\nmutex_unlock(&dqopt->dqio_mutex);\r\ngoto out_file_init;\r\n}\r\nif (dqopt->flags & DQUOT_QUOTA_SYS_FILE)\r\ndqopt->info[type].dqi_flags |= DQF_SYS_FILE;\r\nmutex_unlock(&dqopt->dqio_mutex);\r\nspin_lock(&dq_state_lock);\r\ndqopt->flags |= dquot_state_flag(flags, type);\r\nspin_unlock(&dq_state_lock);\r\nadd_dquot_ref(sb, type);\r\nmutex_unlock(&dqopt->dqonoff_mutex);\r\nreturn 0;\r\nout_file_init:\r\ndqopt->files[type] = NULL;\r\niput(inode);\r\nout_lock:\r\nif (oldflags != -1) {\r\ninode_lock(inode);\r\ninode->i_flags &= ~(S_NOATIME | S_NOQUOTA | S_IMMUTABLE);\r\ninode->i_flags |= oldflags;\r\ninode_unlock(inode);\r\n}\r\nmutex_unlock(&dqopt->dqonoff_mutex);\r\nout_fmt:\r\nput_quota_format(fmt);\r\nreturn error;\r\n}\r\nint dquot_resume(struct super_block *sb, int type)\r\n{\r\nstruct quota_info *dqopt = sb_dqopt(sb);\r\nstruct inode *inode;\r\nint ret = 0, cnt;\r\nunsigned int flags;\r\nfor (cnt = 0; cnt < MAXQUOTAS; cnt++) {\r\nif (type != -1 && cnt != type)\r\ncontinue;\r\nmutex_lock(&dqopt->dqonoff_mutex);\r\nif (!sb_has_quota_suspended(sb, cnt)) {\r\nmutex_unlock(&dqopt->dqonoff_mutex);\r\ncontinue;\r\n}\r\ninode = dqopt->files[cnt];\r\ndqopt->files[cnt] = NULL;\r\nspin_lock(&dq_state_lock);\r\nflags = dqopt->flags & dquot_state_flag(DQUOT_USAGE_ENABLED |\r\nDQUOT_LIMITS_ENABLED,\r\ncnt);\r\ndqopt->flags &= ~dquot_state_flag(DQUOT_STATE_FLAGS, cnt);\r\nspin_unlock(&dq_state_lock);\r\nmutex_unlock(&dqopt->dqonoff_mutex);\r\nflags = dquot_generic_flag(flags, cnt);\r\nret = vfs_load_quota_inode(inode, cnt,\r\ndqopt->info[cnt].dqi_fmt_id, flags);\r\niput(inode);\r\n}\r\nreturn ret;\r\n}\r\nint dquot_quota_on(struct super_block *sb, int type, int format_id,\r\nstruct path *path)\r\n{\r\nint error = security_quota_on(path->dentry);\r\nif (error)\r\nreturn error;\r\nif (path->dentry->d_sb != sb)\r\nerror = -EXDEV;\r\nelse\r\nerror = vfs_load_quota_inode(d_inode(path->dentry), type,\r\nformat_id, DQUOT_USAGE_ENABLED |\r\nDQUOT_LIMITS_ENABLED);\r\nreturn error;\r\n}\r\nint dquot_enable(struct inode *inode, int type, int format_id,\r\nunsigned int flags)\r\n{\r\nint ret = 0;\r\nstruct super_block *sb = inode->i_sb;\r\nstruct quota_info *dqopt = sb_dqopt(sb);\r\nBUG_ON(flags & DQUOT_SUSPENDED);\r\nif (!flags)\r\nreturn 0;\r\nif (sb_has_quota_loaded(sb, type)) {\r\nmutex_lock(&dqopt->dqonoff_mutex);\r\nif (!sb_has_quota_loaded(sb, type)) {\r\nmutex_unlock(&dqopt->dqonoff_mutex);\r\ngoto load_quota;\r\n}\r\nif (flags & DQUOT_USAGE_ENABLED &&\r\nsb_has_quota_usage_enabled(sb, type)) {\r\nret = -EBUSY;\r\ngoto out_lock;\r\n}\r\nif (flags & DQUOT_LIMITS_ENABLED &&\r\nsb_has_quota_limits_enabled(sb, type)) {\r\nret = -EBUSY;\r\ngoto out_lock;\r\n}\r\nspin_lock(&dq_state_lock);\r\nsb_dqopt(sb)->flags |= dquot_state_flag(flags, type);\r\nspin_unlock(&dq_state_lock);\r\nout_lock:\r\nmutex_unlock(&dqopt->dqonoff_mutex);\r\nreturn ret;\r\n}\r\nload_quota:\r\nreturn vfs_load_quota_inode(inode, type, format_id, flags);\r\n}\r\nint dquot_quota_on_mount(struct super_block *sb, char *qf_name,\r\nint format_id, int type)\r\n{\r\nstruct dentry *dentry;\r\nint error;\r\ndentry = lookup_one_len_unlocked(qf_name, sb->s_root, strlen(qf_name));\r\nif (IS_ERR(dentry))\r\nreturn PTR_ERR(dentry);\r\nif (d_really_is_negative(dentry)) {\r\nerror = -ENOENT;\r\ngoto out;\r\n}\r\nerror = security_quota_on(dentry);\r\nif (!error)\r\nerror = vfs_load_quota_inode(d_inode(dentry), type, format_id,\r\nDQUOT_USAGE_ENABLED | DQUOT_LIMITS_ENABLED);\r\nout:\r\ndput(dentry);\r\nreturn error;\r\n}\r\nstatic int dquot_quota_enable(struct super_block *sb, unsigned int flags)\r\n{\r\nint ret;\r\nint type;\r\nstruct quota_info *dqopt = sb_dqopt(sb);\r\nif (!(dqopt->flags & DQUOT_QUOTA_SYS_FILE))\r\nreturn -ENOSYS;\r\nflags &= ~(FS_QUOTA_UDQ_ACCT | FS_QUOTA_GDQ_ACCT | FS_QUOTA_PDQ_ACCT);\r\nif (!flags)\r\nreturn -EINVAL;\r\nfor (type = 0; type < MAXQUOTAS; type++) {\r\nif (!(flags & qtype_enforce_flag(type)))\r\ncontinue;\r\nif (!sb_has_quota_usage_enabled(sb, type))\r\nreturn -EINVAL;\r\nret = dquot_enable(dqopt->files[type], type,\r\ndqopt->info[type].dqi_fmt_id,\r\nDQUOT_LIMITS_ENABLED);\r\nif (ret < 0)\r\ngoto out_err;\r\n}\r\nreturn 0;\r\nout_err:\r\nfor (type--; type >= 0; type--) {\r\nif (flags & qtype_enforce_flag(type))\r\ndquot_disable(sb, type, DQUOT_LIMITS_ENABLED);\r\n}\r\nif (ret == -EBUSY)\r\nret = -EEXIST;\r\nreturn ret;\r\n}\r\nstatic int dquot_quota_disable(struct super_block *sb, unsigned int flags)\r\n{\r\nint ret;\r\nint type;\r\nstruct quota_info *dqopt = sb_dqopt(sb);\r\nif (!(dqopt->flags & DQUOT_QUOTA_SYS_FILE))\r\nreturn -ENOSYS;\r\nif (flags &\r\n(FS_QUOTA_UDQ_ACCT | FS_QUOTA_GDQ_ACCT | FS_QUOTA_PDQ_ACCT))\r\nreturn -EOPNOTSUPP;\r\nfor (type = 0; type < MAXQUOTAS; type++)\r\nif (!sb_has_quota_limits_enabled(sb, type))\r\nflags &= ~qtype_enforce_flag(type);\r\nif (!flags)\r\nreturn -EEXIST;\r\nfor (type = 0; type < MAXQUOTAS; type++) {\r\nif (flags & qtype_enforce_flag(type)) {\r\nret = dquot_disable(sb, type, DQUOT_LIMITS_ENABLED);\r\nif (ret < 0)\r\ngoto out_err;\r\n}\r\n}\r\nreturn 0;\r\nout_err:\r\nfor (type--; type >= 0; type--) {\r\nif (flags & qtype_enforce_flag(type))\r\ndquot_enable(dqopt->files[type], type,\r\ndqopt->info[type].dqi_fmt_id,\r\nDQUOT_LIMITS_ENABLED);\r\n}\r\nreturn ret;\r\n}\r\nstatic void do_get_dqblk(struct dquot *dquot, struct qc_dqblk *di)\r\n{\r\nstruct mem_dqblk *dm = &dquot->dq_dqb;\r\nmemset(di, 0, sizeof(*di));\r\nspin_lock(&dq_data_lock);\r\ndi->d_spc_hardlimit = dm->dqb_bhardlimit;\r\ndi->d_spc_softlimit = dm->dqb_bsoftlimit;\r\ndi->d_ino_hardlimit = dm->dqb_ihardlimit;\r\ndi->d_ino_softlimit = dm->dqb_isoftlimit;\r\ndi->d_space = dm->dqb_curspace + dm->dqb_rsvspace;\r\ndi->d_ino_count = dm->dqb_curinodes;\r\ndi->d_spc_timer = dm->dqb_btime;\r\ndi->d_ino_timer = dm->dqb_itime;\r\nspin_unlock(&dq_data_lock);\r\n}\r\nint dquot_get_dqblk(struct super_block *sb, struct kqid qid,\r\nstruct qc_dqblk *di)\r\n{\r\nstruct dquot *dquot;\r\ndquot = dqget(sb, qid);\r\nif (IS_ERR(dquot))\r\nreturn PTR_ERR(dquot);\r\ndo_get_dqblk(dquot, di);\r\ndqput(dquot);\r\nreturn 0;\r\n}\r\nint dquot_get_next_dqblk(struct super_block *sb, struct kqid *qid,\r\nstruct qc_dqblk *di)\r\n{\r\nstruct dquot *dquot;\r\nint err;\r\nif (!sb->dq_op->get_next_id)\r\nreturn -ENOSYS;\r\nerr = sb->dq_op->get_next_id(sb, qid);\r\nif (err < 0)\r\nreturn err;\r\ndquot = dqget(sb, *qid);\r\nif (IS_ERR(dquot))\r\nreturn PTR_ERR(dquot);\r\ndo_get_dqblk(dquot, di);\r\ndqput(dquot);\r\nreturn 0;\r\n}\r\nstatic int do_set_dqblk(struct dquot *dquot, struct qc_dqblk *di)\r\n{\r\nstruct mem_dqblk *dm = &dquot->dq_dqb;\r\nint check_blim = 0, check_ilim = 0;\r\nstruct mem_dqinfo *dqi = &sb_dqopt(dquot->dq_sb)->info[dquot->dq_id.type];\r\nif (di->d_fieldmask & ~VFS_QC_MASK)\r\nreturn -EINVAL;\r\nif (((di->d_fieldmask & QC_SPC_SOFT) &&\r\ndi->d_spc_softlimit > dqi->dqi_max_spc_limit) ||\r\n((di->d_fieldmask & QC_SPC_HARD) &&\r\ndi->d_spc_hardlimit > dqi->dqi_max_spc_limit) ||\r\n((di->d_fieldmask & QC_INO_SOFT) &&\r\n(di->d_ino_softlimit > dqi->dqi_max_ino_limit)) ||\r\n((di->d_fieldmask & QC_INO_HARD) &&\r\n(di->d_ino_hardlimit > dqi->dqi_max_ino_limit)))\r\nreturn -ERANGE;\r\nspin_lock(&dq_data_lock);\r\nif (di->d_fieldmask & QC_SPACE) {\r\ndm->dqb_curspace = di->d_space - dm->dqb_rsvspace;\r\ncheck_blim = 1;\r\nset_bit(DQ_LASTSET_B + QIF_SPACE_B, &dquot->dq_flags);\r\n}\r\nif (di->d_fieldmask & QC_SPC_SOFT)\r\ndm->dqb_bsoftlimit = di->d_spc_softlimit;\r\nif (di->d_fieldmask & QC_SPC_HARD)\r\ndm->dqb_bhardlimit = di->d_spc_hardlimit;\r\nif (di->d_fieldmask & (QC_SPC_SOFT | QC_SPC_HARD)) {\r\ncheck_blim = 1;\r\nset_bit(DQ_LASTSET_B + QIF_BLIMITS_B, &dquot->dq_flags);\r\n}\r\nif (di->d_fieldmask & QC_INO_COUNT) {\r\ndm->dqb_curinodes = di->d_ino_count;\r\ncheck_ilim = 1;\r\nset_bit(DQ_LASTSET_B + QIF_INODES_B, &dquot->dq_flags);\r\n}\r\nif (di->d_fieldmask & QC_INO_SOFT)\r\ndm->dqb_isoftlimit = di->d_ino_softlimit;\r\nif (di->d_fieldmask & QC_INO_HARD)\r\ndm->dqb_ihardlimit = di->d_ino_hardlimit;\r\nif (di->d_fieldmask & (QC_INO_SOFT | QC_INO_HARD)) {\r\ncheck_ilim = 1;\r\nset_bit(DQ_LASTSET_B + QIF_ILIMITS_B, &dquot->dq_flags);\r\n}\r\nif (di->d_fieldmask & QC_SPC_TIMER) {\r\ndm->dqb_btime = di->d_spc_timer;\r\ncheck_blim = 1;\r\nset_bit(DQ_LASTSET_B + QIF_BTIME_B, &dquot->dq_flags);\r\n}\r\nif (di->d_fieldmask & QC_INO_TIMER) {\r\ndm->dqb_itime = di->d_ino_timer;\r\ncheck_ilim = 1;\r\nset_bit(DQ_LASTSET_B + QIF_ITIME_B, &dquot->dq_flags);\r\n}\r\nif (check_blim) {\r\nif (!dm->dqb_bsoftlimit ||\r\ndm->dqb_curspace < dm->dqb_bsoftlimit) {\r\ndm->dqb_btime = 0;\r\nclear_bit(DQ_BLKS_B, &dquot->dq_flags);\r\n} else if (!(di->d_fieldmask & QC_SPC_TIMER))\r\ndm->dqb_btime = get_seconds() + dqi->dqi_bgrace;\r\n}\r\nif (check_ilim) {\r\nif (!dm->dqb_isoftlimit ||\r\ndm->dqb_curinodes < dm->dqb_isoftlimit) {\r\ndm->dqb_itime = 0;\r\nclear_bit(DQ_INODES_B, &dquot->dq_flags);\r\n} else if (!(di->d_fieldmask & QC_INO_TIMER))\r\ndm->dqb_itime = get_seconds() + dqi->dqi_igrace;\r\n}\r\nif (dm->dqb_bhardlimit || dm->dqb_bsoftlimit || dm->dqb_ihardlimit ||\r\ndm->dqb_isoftlimit)\r\nclear_bit(DQ_FAKE_B, &dquot->dq_flags);\r\nelse\r\nset_bit(DQ_FAKE_B, &dquot->dq_flags);\r\nspin_unlock(&dq_data_lock);\r\nmark_dquot_dirty(dquot);\r\nreturn 0;\r\n}\r\nint dquot_set_dqblk(struct super_block *sb, struct kqid qid,\r\nstruct qc_dqblk *di)\r\n{\r\nstruct dquot *dquot;\r\nint rc;\r\ndquot = dqget(sb, qid);\r\nif (IS_ERR(dquot)) {\r\nrc = PTR_ERR(dquot);\r\ngoto out;\r\n}\r\nrc = do_set_dqblk(dquot, di);\r\ndqput(dquot);\r\nout:\r\nreturn rc;\r\n}\r\nint dquot_get_state(struct super_block *sb, struct qc_state *state)\r\n{\r\nstruct mem_dqinfo *mi;\r\nstruct qc_type_state *tstate;\r\nstruct quota_info *dqopt = sb_dqopt(sb);\r\nint type;\r\nmutex_lock(&sb_dqopt(sb)->dqonoff_mutex);\r\nmemset(state, 0, sizeof(*state));\r\nfor (type = 0; type < MAXQUOTAS; type++) {\r\nif (!sb_has_quota_active(sb, type))\r\ncontinue;\r\ntstate = state->s_state + type;\r\nmi = sb_dqopt(sb)->info + type;\r\ntstate->flags = QCI_ACCT_ENABLED;\r\nspin_lock(&dq_data_lock);\r\nif (mi->dqi_flags & DQF_SYS_FILE)\r\ntstate->flags |= QCI_SYSFILE;\r\nif (mi->dqi_flags & DQF_ROOT_SQUASH)\r\ntstate->flags |= QCI_ROOT_SQUASH;\r\nif (sb_has_quota_limits_enabled(sb, type))\r\ntstate->flags |= QCI_LIMITS_ENFORCED;\r\ntstate->spc_timelimit = mi->dqi_bgrace;\r\ntstate->ino_timelimit = mi->dqi_igrace;\r\ntstate->ino = dqopt->files[type]->i_ino;\r\ntstate->blocks = dqopt->files[type]->i_blocks;\r\ntstate->nextents = 1;\r\nspin_unlock(&dq_data_lock);\r\n}\r\nmutex_unlock(&sb_dqopt(sb)->dqonoff_mutex);\r\nreturn 0;\r\n}\r\nint dquot_set_dqinfo(struct super_block *sb, int type, struct qc_info *ii)\r\n{\r\nstruct mem_dqinfo *mi;\r\nint err = 0;\r\nif ((ii->i_fieldmask & QC_WARNS_MASK) ||\r\n(ii->i_fieldmask & QC_RT_SPC_TIMER))\r\nreturn -EINVAL;\r\nmutex_lock(&sb_dqopt(sb)->dqonoff_mutex);\r\nif (!sb_has_quota_active(sb, type)) {\r\nerr = -ESRCH;\r\ngoto out;\r\n}\r\nmi = sb_dqopt(sb)->info + type;\r\nif (ii->i_fieldmask & QC_FLAGS) {\r\nif ((ii->i_flags & QCI_ROOT_SQUASH &&\r\nmi->dqi_format->qf_fmt_id != QFMT_VFS_OLD)) {\r\nerr = -EINVAL;\r\ngoto out;\r\n}\r\n}\r\nspin_lock(&dq_data_lock);\r\nif (ii->i_fieldmask & QC_SPC_TIMER)\r\nmi->dqi_bgrace = ii->i_spc_timelimit;\r\nif (ii->i_fieldmask & QC_INO_TIMER)\r\nmi->dqi_igrace = ii->i_ino_timelimit;\r\nif (ii->i_fieldmask & QC_FLAGS) {\r\nif (ii->i_flags & QCI_ROOT_SQUASH)\r\nmi->dqi_flags |= DQF_ROOT_SQUASH;\r\nelse\r\nmi->dqi_flags &= ~DQF_ROOT_SQUASH;\r\n}\r\nspin_unlock(&dq_data_lock);\r\nmark_info_dirty(sb, type);\r\nsb->dq_op->write_info(sb, type);\r\nout:\r\nmutex_unlock(&sb_dqopt(sb)->dqonoff_mutex);\r\nreturn err;\r\n}\r\nstatic int do_proc_dqstats(struct ctl_table *table, int write,\r\nvoid __user *buffer, size_t *lenp, loff_t *ppos)\r\n{\r\nunsigned int type = (int *)table->data - dqstats.stat;\r\ndqstats.stat[type] =\r\npercpu_counter_sum_positive(&dqstats.counter[type]);\r\nreturn proc_dointvec(table, write, buffer, lenp, ppos);\r\n}\r\nstatic int __init dquot_init(void)\r\n{\r\nint i, ret;\r\nunsigned long nr_hash, order;\r\nprintk(KERN_NOTICE "VFS: Disk quotas %s\n", __DQUOT_VERSION__);\r\nregister_sysctl_table(sys_table);\r\ndquot_cachep = kmem_cache_create("dquot",\r\nsizeof(struct dquot), sizeof(unsigned long) * 4,\r\n(SLAB_HWCACHE_ALIGN|SLAB_RECLAIM_ACCOUNT|\r\nSLAB_MEM_SPREAD|SLAB_PANIC),\r\nNULL);\r\norder = 0;\r\ndquot_hash = (struct hlist_head *)__get_free_pages(GFP_ATOMIC, order);\r\nif (!dquot_hash)\r\npanic("Cannot create dquot hash table");\r\nfor (i = 0; i < _DQST_DQSTAT_LAST; i++) {\r\nret = percpu_counter_init(&dqstats.counter[i], 0, GFP_KERNEL);\r\nif (ret)\r\npanic("Cannot create dquot stat counters");\r\n}\r\nnr_hash = (1UL << order) * PAGE_SIZE / sizeof(struct hlist_head);\r\ndq_hash_bits = 0;\r\ndo {\r\ndq_hash_bits++;\r\n} while (nr_hash >> dq_hash_bits);\r\ndq_hash_bits--;\r\nnr_hash = 1UL << dq_hash_bits;\r\ndq_hash_mask = nr_hash - 1;\r\nfor (i = 0; i < nr_hash; i++)\r\nINIT_HLIST_HEAD(dquot_hash + i);\r\npr_info("VFS: Dquot-cache hash table entries: %ld (order %ld,"\r\n" %ld bytes)\n", nr_hash, order, (PAGE_SIZE << order));\r\nregister_shrinker(&dqcache_shrinker);\r\nreturn 0;\r\n}
