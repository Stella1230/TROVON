static inline void async_done_continue(struct aead_request *req, int err,\r\nint (*cont)(struct aead_request *))\r\n{\r\nif (!err)\r\nerr = cont(req);\r\nif (err != -EINPROGRESS && err != -EBUSY)\r\naead_request_complete(req, err);\r\n}\r\nstatic void chacha_iv(u8 *iv, struct aead_request *req, u32 icb)\r\n{\r\nstruct chachapoly_ctx *ctx = crypto_aead_ctx(crypto_aead_reqtfm(req));\r\n__le32 leicb = cpu_to_le32(icb);\r\nmemcpy(iv, &leicb, sizeof(leicb));\r\nmemcpy(iv + sizeof(leicb), ctx->salt, ctx->saltlen);\r\nmemcpy(iv + sizeof(leicb) + ctx->saltlen, req->iv,\r\nCHACHA20_IV_SIZE - sizeof(leicb) - ctx->saltlen);\r\n}\r\nstatic int poly_verify_tag(struct aead_request *req)\r\n{\r\nstruct chachapoly_req_ctx *rctx = aead_request_ctx(req);\r\nu8 tag[sizeof(rctx->tag)];\r\nscatterwalk_map_and_copy(tag, req->src,\r\nreq->assoclen + rctx->cryptlen,\r\nsizeof(tag), 0);\r\nif (crypto_memneq(tag, rctx->tag, sizeof(tag)))\r\nreturn -EBADMSG;\r\nreturn 0;\r\n}\r\nstatic int poly_copy_tag(struct aead_request *req)\r\n{\r\nstruct chachapoly_req_ctx *rctx = aead_request_ctx(req);\r\nscatterwalk_map_and_copy(rctx->tag, req->dst,\r\nreq->assoclen + rctx->cryptlen,\r\nsizeof(rctx->tag), 1);\r\nreturn 0;\r\n}\r\nstatic void chacha_decrypt_done(struct crypto_async_request *areq, int err)\r\n{\r\nasync_done_continue(areq->data, err, poly_verify_tag);\r\n}\r\nstatic int chacha_decrypt(struct aead_request *req)\r\n{\r\nstruct chachapoly_ctx *ctx = crypto_aead_ctx(crypto_aead_reqtfm(req));\r\nstruct chachapoly_req_ctx *rctx = aead_request_ctx(req);\r\nstruct chacha_req *creq = &rctx->u.chacha;\r\nstruct scatterlist *src, *dst;\r\nint err;\r\nif (rctx->cryptlen == 0)\r\ngoto skip;\r\nchacha_iv(creq->iv, req, 1);\r\nsg_init_table(rctx->src, 2);\r\nsrc = scatterwalk_ffwd(rctx->src, req->src, req->assoclen);\r\ndst = src;\r\nif (req->src != req->dst) {\r\nsg_init_table(rctx->dst, 2);\r\ndst = scatterwalk_ffwd(rctx->dst, req->dst, req->assoclen);\r\n}\r\nablkcipher_request_set_callback(&creq->req, aead_request_flags(req),\r\nchacha_decrypt_done, req);\r\nablkcipher_request_set_tfm(&creq->req, ctx->chacha);\r\nablkcipher_request_set_crypt(&creq->req, src, dst,\r\nrctx->cryptlen, creq->iv);\r\nerr = crypto_ablkcipher_decrypt(&creq->req);\r\nif (err)\r\nreturn err;\r\nskip:\r\nreturn poly_verify_tag(req);\r\n}\r\nstatic int poly_tail_continue(struct aead_request *req)\r\n{\r\nstruct chachapoly_req_ctx *rctx = aead_request_ctx(req);\r\nif (rctx->cryptlen == req->cryptlen)\r\nreturn poly_copy_tag(req);\r\nreturn chacha_decrypt(req);\r\n}\r\nstatic void poly_tail_done(struct crypto_async_request *areq, int err)\r\n{\r\nasync_done_continue(areq->data, err, poly_tail_continue);\r\n}\r\nstatic int poly_tail(struct aead_request *req)\r\n{\r\nstruct crypto_aead *tfm = crypto_aead_reqtfm(req);\r\nstruct chachapoly_ctx *ctx = crypto_aead_ctx(tfm);\r\nstruct chachapoly_req_ctx *rctx = aead_request_ctx(req);\r\nstruct poly_req *preq = &rctx->u.poly;\r\n__le64 len;\r\nint err;\r\nsg_init_table(preq->src, 1);\r\nlen = cpu_to_le64(rctx->assoclen);\r\nmemcpy(&preq->tail.assoclen, &len, sizeof(len));\r\nlen = cpu_to_le64(rctx->cryptlen);\r\nmemcpy(&preq->tail.cryptlen, &len, sizeof(len));\r\nsg_set_buf(preq->src, &preq->tail, sizeof(preq->tail));\r\nahash_request_set_callback(&preq->req, aead_request_flags(req),\r\npoly_tail_done, req);\r\nahash_request_set_tfm(&preq->req, ctx->poly);\r\nahash_request_set_crypt(&preq->req, preq->src,\r\nrctx->tag, sizeof(preq->tail));\r\nerr = crypto_ahash_finup(&preq->req);\r\nif (err)\r\nreturn err;\r\nreturn poly_tail_continue(req);\r\n}\r\nstatic void poly_cipherpad_done(struct crypto_async_request *areq, int err)\r\n{\r\nasync_done_continue(areq->data, err, poly_tail);\r\n}\r\nstatic int poly_cipherpad(struct aead_request *req)\r\n{\r\nstruct chachapoly_ctx *ctx = crypto_aead_ctx(crypto_aead_reqtfm(req));\r\nstruct chachapoly_req_ctx *rctx = aead_request_ctx(req);\r\nstruct poly_req *preq = &rctx->u.poly;\r\nunsigned int padlen, bs = POLY1305_BLOCK_SIZE;\r\nint err;\r\npadlen = (bs - (rctx->cryptlen % bs)) % bs;\r\nmemset(preq->pad, 0, sizeof(preq->pad));\r\nsg_init_table(preq->src, 1);\r\nsg_set_buf(preq->src, &preq->pad, padlen);\r\nahash_request_set_callback(&preq->req, aead_request_flags(req),\r\npoly_cipherpad_done, req);\r\nahash_request_set_tfm(&preq->req, ctx->poly);\r\nahash_request_set_crypt(&preq->req, preq->src, NULL, padlen);\r\nerr = crypto_ahash_update(&preq->req);\r\nif (err)\r\nreturn err;\r\nreturn poly_tail(req);\r\n}\r\nstatic void poly_cipher_done(struct crypto_async_request *areq, int err)\r\n{\r\nasync_done_continue(areq->data, err, poly_cipherpad);\r\n}\r\nstatic int poly_cipher(struct aead_request *req)\r\n{\r\nstruct chachapoly_ctx *ctx = crypto_aead_ctx(crypto_aead_reqtfm(req));\r\nstruct chachapoly_req_ctx *rctx = aead_request_ctx(req);\r\nstruct poly_req *preq = &rctx->u.poly;\r\nstruct scatterlist *crypt = req->src;\r\nint err;\r\nif (rctx->cryptlen == req->cryptlen)\r\ncrypt = req->dst;\r\nsg_init_table(rctx->src, 2);\r\ncrypt = scatterwalk_ffwd(rctx->src, crypt, req->assoclen);\r\nahash_request_set_callback(&preq->req, aead_request_flags(req),\r\npoly_cipher_done, req);\r\nahash_request_set_tfm(&preq->req, ctx->poly);\r\nahash_request_set_crypt(&preq->req, crypt, NULL, rctx->cryptlen);\r\nerr = crypto_ahash_update(&preq->req);\r\nif (err)\r\nreturn err;\r\nreturn poly_cipherpad(req);\r\n}\r\nstatic void poly_adpad_done(struct crypto_async_request *areq, int err)\r\n{\r\nasync_done_continue(areq->data, err, poly_cipher);\r\n}\r\nstatic int poly_adpad(struct aead_request *req)\r\n{\r\nstruct chachapoly_ctx *ctx = crypto_aead_ctx(crypto_aead_reqtfm(req));\r\nstruct chachapoly_req_ctx *rctx = aead_request_ctx(req);\r\nstruct poly_req *preq = &rctx->u.poly;\r\nunsigned int padlen, bs = POLY1305_BLOCK_SIZE;\r\nint err;\r\npadlen = (bs - (rctx->assoclen % bs)) % bs;\r\nmemset(preq->pad, 0, sizeof(preq->pad));\r\nsg_init_table(preq->src, 1);\r\nsg_set_buf(preq->src, preq->pad, padlen);\r\nahash_request_set_callback(&preq->req, aead_request_flags(req),\r\npoly_adpad_done, req);\r\nahash_request_set_tfm(&preq->req, ctx->poly);\r\nahash_request_set_crypt(&preq->req, preq->src, NULL, padlen);\r\nerr = crypto_ahash_update(&preq->req);\r\nif (err)\r\nreturn err;\r\nreturn poly_cipher(req);\r\n}\r\nstatic void poly_ad_done(struct crypto_async_request *areq, int err)\r\n{\r\nasync_done_continue(areq->data, err, poly_adpad);\r\n}\r\nstatic int poly_ad(struct aead_request *req)\r\n{\r\nstruct chachapoly_ctx *ctx = crypto_aead_ctx(crypto_aead_reqtfm(req));\r\nstruct chachapoly_req_ctx *rctx = aead_request_ctx(req);\r\nstruct poly_req *preq = &rctx->u.poly;\r\nint err;\r\nahash_request_set_callback(&preq->req, aead_request_flags(req),\r\npoly_ad_done, req);\r\nahash_request_set_tfm(&preq->req, ctx->poly);\r\nahash_request_set_crypt(&preq->req, req->src, NULL, rctx->assoclen);\r\nerr = crypto_ahash_update(&preq->req);\r\nif (err)\r\nreturn err;\r\nreturn poly_adpad(req);\r\n}\r\nstatic void poly_setkey_done(struct crypto_async_request *areq, int err)\r\n{\r\nasync_done_continue(areq->data, err, poly_ad);\r\n}\r\nstatic int poly_setkey(struct aead_request *req)\r\n{\r\nstruct chachapoly_ctx *ctx = crypto_aead_ctx(crypto_aead_reqtfm(req));\r\nstruct chachapoly_req_ctx *rctx = aead_request_ctx(req);\r\nstruct poly_req *preq = &rctx->u.poly;\r\nint err;\r\nsg_init_table(preq->src, 1);\r\nsg_set_buf(preq->src, rctx->key, sizeof(rctx->key));\r\nahash_request_set_callback(&preq->req, aead_request_flags(req),\r\npoly_setkey_done, req);\r\nahash_request_set_tfm(&preq->req, ctx->poly);\r\nahash_request_set_crypt(&preq->req, preq->src, NULL, sizeof(rctx->key));\r\nerr = crypto_ahash_update(&preq->req);\r\nif (err)\r\nreturn err;\r\nreturn poly_ad(req);\r\n}\r\nstatic void poly_init_done(struct crypto_async_request *areq, int err)\r\n{\r\nasync_done_continue(areq->data, err, poly_setkey);\r\n}\r\nstatic int poly_init(struct aead_request *req)\r\n{\r\nstruct chachapoly_ctx *ctx = crypto_aead_ctx(crypto_aead_reqtfm(req));\r\nstruct chachapoly_req_ctx *rctx = aead_request_ctx(req);\r\nstruct poly_req *preq = &rctx->u.poly;\r\nint err;\r\nahash_request_set_callback(&preq->req, aead_request_flags(req),\r\npoly_init_done, req);\r\nahash_request_set_tfm(&preq->req, ctx->poly);\r\nerr = crypto_ahash_init(&preq->req);\r\nif (err)\r\nreturn err;\r\nreturn poly_setkey(req);\r\n}\r\nstatic void poly_genkey_done(struct crypto_async_request *areq, int err)\r\n{\r\nasync_done_continue(areq->data, err, poly_init);\r\n}\r\nstatic int poly_genkey(struct aead_request *req)\r\n{\r\nstruct crypto_aead *tfm = crypto_aead_reqtfm(req);\r\nstruct chachapoly_ctx *ctx = crypto_aead_ctx(tfm);\r\nstruct chachapoly_req_ctx *rctx = aead_request_ctx(req);\r\nstruct chacha_req *creq = &rctx->u.chacha;\r\nint err;\r\nrctx->assoclen = req->assoclen;\r\nif (crypto_aead_ivsize(tfm) == 8) {\r\nif (rctx->assoclen < 8)\r\nreturn -EINVAL;\r\nrctx->assoclen -= 8;\r\n}\r\nsg_init_table(creq->src, 1);\r\nmemset(rctx->key, 0, sizeof(rctx->key));\r\nsg_set_buf(creq->src, rctx->key, sizeof(rctx->key));\r\nchacha_iv(creq->iv, req, 0);\r\nablkcipher_request_set_callback(&creq->req, aead_request_flags(req),\r\npoly_genkey_done, req);\r\nablkcipher_request_set_tfm(&creq->req, ctx->chacha);\r\nablkcipher_request_set_crypt(&creq->req, creq->src, creq->src,\r\nPOLY1305_KEY_SIZE, creq->iv);\r\nerr = crypto_ablkcipher_decrypt(&creq->req);\r\nif (err)\r\nreturn err;\r\nreturn poly_init(req);\r\n}\r\nstatic void chacha_encrypt_done(struct crypto_async_request *areq, int err)\r\n{\r\nasync_done_continue(areq->data, err, poly_genkey);\r\n}\r\nstatic int chacha_encrypt(struct aead_request *req)\r\n{\r\nstruct chachapoly_ctx *ctx = crypto_aead_ctx(crypto_aead_reqtfm(req));\r\nstruct chachapoly_req_ctx *rctx = aead_request_ctx(req);\r\nstruct chacha_req *creq = &rctx->u.chacha;\r\nstruct scatterlist *src, *dst;\r\nint err;\r\nif (req->cryptlen == 0)\r\ngoto skip;\r\nchacha_iv(creq->iv, req, 1);\r\nsg_init_table(rctx->src, 2);\r\nsrc = scatterwalk_ffwd(rctx->src, req->src, req->assoclen);\r\ndst = src;\r\nif (req->src != req->dst) {\r\nsg_init_table(rctx->dst, 2);\r\ndst = scatterwalk_ffwd(rctx->dst, req->dst, req->assoclen);\r\n}\r\nablkcipher_request_set_callback(&creq->req, aead_request_flags(req),\r\nchacha_encrypt_done, req);\r\nablkcipher_request_set_tfm(&creq->req, ctx->chacha);\r\nablkcipher_request_set_crypt(&creq->req, src, dst,\r\nreq->cryptlen, creq->iv);\r\nerr = crypto_ablkcipher_encrypt(&creq->req);\r\nif (err)\r\nreturn err;\r\nskip:\r\nreturn poly_genkey(req);\r\n}\r\nstatic int chachapoly_encrypt(struct aead_request *req)\r\n{\r\nstruct chachapoly_req_ctx *rctx = aead_request_ctx(req);\r\nrctx->cryptlen = req->cryptlen;\r\nreturn chacha_encrypt(req);\r\n}\r\nstatic int chachapoly_decrypt(struct aead_request *req)\r\n{\r\nstruct chachapoly_req_ctx *rctx = aead_request_ctx(req);\r\nrctx->cryptlen = req->cryptlen - POLY1305_DIGEST_SIZE;\r\nreturn poly_genkey(req);\r\n}\r\nstatic int chachapoly_setkey(struct crypto_aead *aead, const u8 *key,\r\nunsigned int keylen)\r\n{\r\nstruct chachapoly_ctx *ctx = crypto_aead_ctx(aead);\r\nint err;\r\nif (keylen != ctx->saltlen + CHACHA20_KEY_SIZE)\r\nreturn -EINVAL;\r\nkeylen -= ctx->saltlen;\r\nmemcpy(ctx->salt, key + keylen, ctx->saltlen);\r\ncrypto_ablkcipher_clear_flags(ctx->chacha, CRYPTO_TFM_REQ_MASK);\r\ncrypto_ablkcipher_set_flags(ctx->chacha, crypto_aead_get_flags(aead) &\r\nCRYPTO_TFM_REQ_MASK);\r\nerr = crypto_ablkcipher_setkey(ctx->chacha, key, keylen);\r\ncrypto_aead_set_flags(aead, crypto_ablkcipher_get_flags(ctx->chacha) &\r\nCRYPTO_TFM_RES_MASK);\r\nreturn err;\r\n}\r\nstatic int chachapoly_setauthsize(struct crypto_aead *tfm,\r\nunsigned int authsize)\r\n{\r\nif (authsize != POLY1305_DIGEST_SIZE)\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\nstatic int chachapoly_init(struct crypto_aead *tfm)\r\n{\r\nstruct aead_instance *inst = aead_alg_instance(tfm);\r\nstruct chachapoly_instance_ctx *ictx = aead_instance_ctx(inst);\r\nstruct chachapoly_ctx *ctx = crypto_aead_ctx(tfm);\r\nstruct crypto_ablkcipher *chacha;\r\nstruct crypto_ahash *poly;\r\nunsigned long align;\r\npoly = crypto_spawn_ahash(&ictx->poly);\r\nif (IS_ERR(poly))\r\nreturn PTR_ERR(poly);\r\nchacha = crypto_spawn_skcipher(&ictx->chacha);\r\nif (IS_ERR(chacha)) {\r\ncrypto_free_ahash(poly);\r\nreturn PTR_ERR(chacha);\r\n}\r\nctx->chacha = chacha;\r\nctx->poly = poly;\r\nctx->saltlen = ictx->saltlen;\r\nalign = crypto_aead_alignmask(tfm);\r\nalign &= ~(crypto_tfm_ctx_alignment() - 1);\r\ncrypto_aead_set_reqsize(\r\ntfm,\r\nalign + offsetof(struct chachapoly_req_ctx, u) +\r\nmax(offsetof(struct chacha_req, req) +\r\nsizeof(struct ablkcipher_request) +\r\ncrypto_ablkcipher_reqsize(chacha),\r\noffsetof(struct poly_req, req) +\r\nsizeof(struct ahash_request) +\r\ncrypto_ahash_reqsize(poly)));\r\nreturn 0;\r\n}\r\nstatic void chachapoly_exit(struct crypto_aead *tfm)\r\n{\r\nstruct chachapoly_ctx *ctx = crypto_aead_ctx(tfm);\r\ncrypto_free_ahash(ctx->poly);\r\ncrypto_free_ablkcipher(ctx->chacha);\r\n}\r\nstatic void chachapoly_free(struct aead_instance *inst)\r\n{\r\nstruct chachapoly_instance_ctx *ctx = aead_instance_ctx(inst);\r\ncrypto_drop_skcipher(&ctx->chacha);\r\ncrypto_drop_ahash(&ctx->poly);\r\nkfree(inst);\r\n}\r\nstatic int chachapoly_create(struct crypto_template *tmpl, struct rtattr **tb,\r\nconst char *name, unsigned int ivsize)\r\n{\r\nstruct crypto_attr_type *algt;\r\nstruct aead_instance *inst;\r\nstruct crypto_alg *chacha;\r\nstruct crypto_alg *poly;\r\nstruct hash_alg_common *poly_hash;\r\nstruct chachapoly_instance_ctx *ctx;\r\nconst char *chacha_name, *poly_name;\r\nint err;\r\nif (ivsize > CHACHAPOLY_IV_SIZE)\r\nreturn -EINVAL;\r\nalgt = crypto_get_attr_type(tb);\r\nif (IS_ERR(algt))\r\nreturn PTR_ERR(algt);\r\nif ((algt->type ^ CRYPTO_ALG_TYPE_AEAD) & algt->mask)\r\nreturn -EINVAL;\r\nchacha_name = crypto_attr_alg_name(tb[1]);\r\nif (IS_ERR(chacha_name))\r\nreturn PTR_ERR(chacha_name);\r\npoly_name = crypto_attr_alg_name(tb[2]);\r\nif (IS_ERR(poly_name))\r\nreturn PTR_ERR(poly_name);\r\npoly = crypto_find_alg(poly_name, &crypto_ahash_type,\r\nCRYPTO_ALG_TYPE_HASH,\r\nCRYPTO_ALG_TYPE_AHASH_MASK);\r\nif (IS_ERR(poly))\r\nreturn PTR_ERR(poly);\r\nerr = -ENOMEM;\r\ninst = kzalloc(sizeof(*inst) + sizeof(*ctx), GFP_KERNEL);\r\nif (!inst)\r\ngoto out_put_poly;\r\nctx = aead_instance_ctx(inst);\r\nctx->saltlen = CHACHAPOLY_IV_SIZE - ivsize;\r\npoly_hash = __crypto_hash_alg_common(poly);\r\nerr = crypto_init_ahash_spawn(&ctx->poly, poly_hash,\r\naead_crypto_instance(inst));\r\nif (err)\r\ngoto err_free_inst;\r\ncrypto_set_skcipher_spawn(&ctx->chacha, aead_crypto_instance(inst));\r\nerr = crypto_grab_skcipher(&ctx->chacha, chacha_name, 0,\r\ncrypto_requires_sync(algt->type,\r\nalgt->mask));\r\nif (err)\r\ngoto err_drop_poly;\r\nchacha = crypto_skcipher_spawn_alg(&ctx->chacha);\r\nerr = -EINVAL;\r\nif (chacha->cra_ablkcipher.ivsize != CHACHA20_IV_SIZE)\r\ngoto out_drop_chacha;\r\nif (chacha->cra_blocksize != 1)\r\ngoto out_drop_chacha;\r\nerr = -ENAMETOOLONG;\r\nif (snprintf(inst->alg.base.cra_name, CRYPTO_MAX_ALG_NAME,\r\n"%s(%s,%s)", name, chacha_name,\r\npoly_name) >= CRYPTO_MAX_ALG_NAME)\r\ngoto out_drop_chacha;\r\nif (snprintf(inst->alg.base.cra_driver_name, CRYPTO_MAX_ALG_NAME,\r\n"%s(%s,%s)", name, chacha->cra_driver_name,\r\npoly->cra_driver_name) >= CRYPTO_MAX_ALG_NAME)\r\ngoto out_drop_chacha;\r\ninst->alg.base.cra_flags = (chacha->cra_flags | poly->cra_flags) &\r\nCRYPTO_ALG_ASYNC;\r\ninst->alg.base.cra_priority = (chacha->cra_priority +\r\npoly->cra_priority) / 2;\r\ninst->alg.base.cra_blocksize = 1;\r\ninst->alg.base.cra_alignmask = chacha->cra_alignmask |\r\npoly->cra_alignmask;\r\ninst->alg.base.cra_ctxsize = sizeof(struct chachapoly_ctx) +\r\nctx->saltlen;\r\ninst->alg.ivsize = ivsize;\r\ninst->alg.maxauthsize = POLY1305_DIGEST_SIZE;\r\ninst->alg.init = chachapoly_init;\r\ninst->alg.exit = chachapoly_exit;\r\ninst->alg.encrypt = chachapoly_encrypt;\r\ninst->alg.decrypt = chachapoly_decrypt;\r\ninst->alg.setkey = chachapoly_setkey;\r\ninst->alg.setauthsize = chachapoly_setauthsize;\r\ninst->free = chachapoly_free;\r\nerr = aead_register_instance(tmpl, inst);\r\nif (err)\r\ngoto out_drop_chacha;\r\nout_put_poly:\r\ncrypto_mod_put(poly);\r\nreturn err;\r\nout_drop_chacha:\r\ncrypto_drop_skcipher(&ctx->chacha);\r\nerr_drop_poly:\r\ncrypto_drop_ahash(&ctx->poly);\r\nerr_free_inst:\r\nkfree(inst);\r\ngoto out_put_poly;\r\n}\r\nstatic int rfc7539_create(struct crypto_template *tmpl, struct rtattr **tb)\r\n{\r\nreturn chachapoly_create(tmpl, tb, "rfc7539", 12);\r\n}\r\nstatic int rfc7539esp_create(struct crypto_template *tmpl, struct rtattr **tb)\r\n{\r\nreturn chachapoly_create(tmpl, tb, "rfc7539esp", 8);\r\n}\r\nstatic int __init chacha20poly1305_module_init(void)\r\n{\r\nint err;\r\nerr = crypto_register_template(&rfc7539_tmpl);\r\nif (err)\r\nreturn err;\r\nerr = crypto_register_template(&rfc7539esp_tmpl);\r\nif (err)\r\ncrypto_unregister_template(&rfc7539_tmpl);\r\nreturn err;\r\n}\r\nstatic void __exit chacha20poly1305_module_exit(void)\r\n{\r\ncrypto_unregister_template(&rfc7539esp_tmpl);\r\ncrypto_unregister_template(&rfc7539_tmpl);\r\n}
