static int ext4_inode_has_encryption_context(struct inode *inode)\r\n{\r\nint res = ext4_xattr_get(inode, EXT4_XATTR_INDEX_ENCRYPTION,\r\nEXT4_XATTR_NAME_ENCRYPTION_CONTEXT, NULL, 0);\r\nreturn (res > 0);\r\n}\r\nstatic int ext4_is_encryption_context_consistent_with_policy(\r\nstruct inode *inode, const struct ext4_encryption_policy *policy)\r\n{\r\nstruct ext4_encryption_context ctx;\r\nint res = ext4_xattr_get(inode, EXT4_XATTR_INDEX_ENCRYPTION,\r\nEXT4_XATTR_NAME_ENCRYPTION_CONTEXT, &ctx,\r\nsizeof(ctx));\r\nif (res != sizeof(ctx))\r\nreturn 0;\r\nreturn (memcmp(ctx.master_key_descriptor, policy->master_key_descriptor,\r\nEXT4_KEY_DESCRIPTOR_SIZE) == 0 &&\r\n(ctx.flags ==\r\npolicy->flags) &&\r\n(ctx.contents_encryption_mode ==\r\npolicy->contents_encryption_mode) &&\r\n(ctx.filenames_encryption_mode ==\r\npolicy->filenames_encryption_mode));\r\n}\r\nstatic int ext4_create_encryption_context_from_policy(\r\nstruct inode *inode, const struct ext4_encryption_policy *policy)\r\n{\r\nstruct ext4_encryption_context ctx;\r\nhandle_t *handle;\r\nint res, res2;\r\nres = ext4_convert_inline_data(inode);\r\nif (res)\r\nreturn res;\r\nctx.format = EXT4_ENCRYPTION_CONTEXT_FORMAT_V1;\r\nmemcpy(ctx.master_key_descriptor, policy->master_key_descriptor,\r\nEXT4_KEY_DESCRIPTOR_SIZE);\r\nif (!ext4_valid_contents_enc_mode(policy->contents_encryption_mode)) {\r\nprintk(KERN_WARNING\r\n"%s: Invalid contents encryption mode %d\n", __func__,\r\npolicy->contents_encryption_mode);\r\nreturn -EINVAL;\r\n}\r\nif (!ext4_valid_filenames_enc_mode(policy->filenames_encryption_mode)) {\r\nprintk(KERN_WARNING\r\n"%s: Invalid filenames encryption mode %d\n", __func__,\r\npolicy->filenames_encryption_mode);\r\nreturn -EINVAL;\r\n}\r\nif (policy->flags & ~EXT4_POLICY_FLAGS_VALID)\r\nreturn -EINVAL;\r\nctx.contents_encryption_mode = policy->contents_encryption_mode;\r\nctx.filenames_encryption_mode = policy->filenames_encryption_mode;\r\nctx.flags = policy->flags;\r\nBUILD_BUG_ON(sizeof(ctx.nonce) != EXT4_KEY_DERIVATION_NONCE_SIZE);\r\nget_random_bytes(ctx.nonce, EXT4_KEY_DERIVATION_NONCE_SIZE);\r\nhandle = ext4_journal_start(inode, EXT4_HT_MISC,\r\next4_jbd2_credits_xattr(inode));\r\nif (IS_ERR(handle))\r\nreturn PTR_ERR(handle);\r\nres = ext4_xattr_set(inode, EXT4_XATTR_INDEX_ENCRYPTION,\r\nEXT4_XATTR_NAME_ENCRYPTION_CONTEXT, &ctx,\r\nsizeof(ctx), 0);\r\nif (!res) {\r\next4_set_inode_flag(inode, EXT4_INODE_ENCRYPT);\r\nres = ext4_mark_inode_dirty(handle, inode);\r\nif (res)\r\nEXT4_ERROR_INODE(inode, "Failed to mark inode dirty");\r\n}\r\nres2 = ext4_journal_stop(handle);\r\nif (!res)\r\nres = res2;\r\nreturn res;\r\n}\r\nint ext4_process_policy(const struct ext4_encryption_policy *policy,\r\nstruct inode *inode)\r\n{\r\nif (policy->version != 0)\r\nreturn -EINVAL;\r\nif (!ext4_inode_has_encryption_context(inode)) {\r\nif (!S_ISDIR(inode->i_mode))\r\nreturn -EINVAL;\r\nif (!ext4_empty_dir(inode))\r\nreturn -ENOTEMPTY;\r\nreturn ext4_create_encryption_context_from_policy(inode,\r\npolicy);\r\n}\r\nif (ext4_is_encryption_context_consistent_with_policy(inode, policy))\r\nreturn 0;\r\nprintk(KERN_WARNING "%s: Policy inconsistent with encryption context\n",\r\n__func__);\r\nreturn -EINVAL;\r\n}\r\nint ext4_get_policy(struct inode *inode, struct ext4_encryption_policy *policy)\r\n{\r\nstruct ext4_encryption_context ctx;\r\nint res = ext4_xattr_get(inode, EXT4_XATTR_INDEX_ENCRYPTION,\r\nEXT4_XATTR_NAME_ENCRYPTION_CONTEXT,\r\n&ctx, sizeof(ctx));\r\nif (res != sizeof(ctx))\r\nreturn -ENOENT;\r\nif (ctx.format != EXT4_ENCRYPTION_CONTEXT_FORMAT_V1)\r\nreturn -EINVAL;\r\npolicy->version = 0;\r\npolicy->contents_encryption_mode = ctx.contents_encryption_mode;\r\npolicy->filenames_encryption_mode = ctx.filenames_encryption_mode;\r\npolicy->flags = ctx.flags;\r\nmemcpy(&policy->master_key_descriptor, ctx.master_key_descriptor,\r\nEXT4_KEY_DESCRIPTOR_SIZE);\r\nreturn 0;\r\n}\r\nint ext4_is_child_context_consistent_with_parent(struct inode *parent,\r\nstruct inode *child)\r\n{\r\nstruct ext4_crypt_info *parent_ci, *child_ci;\r\nint res;\r\nif ((parent == NULL) || (child == NULL)) {\r\npr_err("parent %p child %p\n", parent, child);\r\nWARN_ON(1);\r\nreturn 0;\r\n}\r\nif (!ext4_encrypted_inode(parent))\r\nreturn 1;\r\nif (!ext4_encrypted_inode(child))\r\nreturn 0;\r\nres = ext4_get_encryption_info(parent);\r\nif (res)\r\nreturn 0;\r\nres = ext4_get_encryption_info(child);\r\nif (res)\r\nreturn 0;\r\nparent_ci = EXT4_I(parent)->i_crypt_info;\r\nchild_ci = EXT4_I(child)->i_crypt_info;\r\nif (!parent_ci && !child_ci)\r\nreturn 1;\r\nif (!parent_ci || !child_ci)\r\nreturn 0;\r\nreturn (memcmp(parent_ci->ci_master_key,\r\nchild_ci->ci_master_key,\r\nEXT4_KEY_DESCRIPTOR_SIZE) == 0 &&\r\n(parent_ci->ci_data_mode == child_ci->ci_data_mode) &&\r\n(parent_ci->ci_filename_mode == child_ci->ci_filename_mode) &&\r\n(parent_ci->ci_flags == child_ci->ci_flags));\r\n}\r\nint ext4_inherit_context(struct inode *parent, struct inode *child)\r\n{\r\nstruct ext4_encryption_context ctx;\r\nstruct ext4_crypt_info *ci;\r\nint res;\r\nres = ext4_get_encryption_info(parent);\r\nif (res < 0)\r\nreturn res;\r\nci = EXT4_I(parent)->i_crypt_info;\r\nif (ci == NULL)\r\nreturn -ENOKEY;\r\nctx.format = EXT4_ENCRYPTION_CONTEXT_FORMAT_V1;\r\nif (DUMMY_ENCRYPTION_ENABLED(EXT4_SB(parent->i_sb))) {\r\nctx.contents_encryption_mode = EXT4_ENCRYPTION_MODE_AES_256_XTS;\r\nctx.filenames_encryption_mode =\r\nEXT4_ENCRYPTION_MODE_AES_256_CTS;\r\nctx.flags = 0;\r\nmemset(ctx.master_key_descriptor, 0x42,\r\nEXT4_KEY_DESCRIPTOR_SIZE);\r\nres = 0;\r\n} else {\r\nctx.contents_encryption_mode = ci->ci_data_mode;\r\nctx.filenames_encryption_mode = ci->ci_filename_mode;\r\nctx.flags = ci->ci_flags;\r\nmemcpy(ctx.master_key_descriptor, ci->ci_master_key,\r\nEXT4_KEY_DESCRIPTOR_SIZE);\r\n}\r\nget_random_bytes(ctx.nonce, EXT4_KEY_DERIVATION_NONCE_SIZE);\r\nres = ext4_xattr_set(child, EXT4_XATTR_INDEX_ENCRYPTION,\r\nEXT4_XATTR_NAME_ENCRYPTION_CONTEXT, &ctx,\r\nsizeof(ctx), 0);\r\nif (!res) {\r\next4_set_inode_flag(child, EXT4_INODE_ENCRYPT);\r\next4_clear_inode_state(child, EXT4_STATE_MAY_INLINE_DATA);\r\nres = ext4_get_encryption_info(child);\r\n}\r\nreturn res;\r\n}
