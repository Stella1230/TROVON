void rtl92e_dm_init(struct net_device *dev)\r\n{\r\nstruct r8192_priv *priv = rtllib_priv(dev);\r\npriv->DM_Type = DM_Type_ByDriver;\r\npriv->undecorated_smoothed_pwdb = -1;\r\n_rtl92e_dm_init_dynamic_tx_power(dev);\r\nrtl92e_init_adaptive_rate(dev);\r\n_rtl92e_dm_dig_init(dev);\r\nrtl92e_dm_init_edca_turbo(dev);\r\n_rtl92e_dm_init_bandwidth_autoswitch(dev);\r\n_rtl92e_dm_init_fsync(dev);\r\n_rtl92e_dm_init_rx_path_selection(dev);\r\n_rtl92e_dm_init_cts_to_self(dev);\r\nif (IS_HARDWARE_TYPE_8192SE(dev))\r\n_rtl92e_dm_init_wa_broadcom_iot(dev);\r\nINIT_DELAYED_WORK_RSL(&priv->gpio_change_rf_wq,\r\n(void *)_rtl92e_dm_check_rf_ctrl_gpio, dev);\r\n}\r\nvoid rtl92e_dm_deinit(struct net_device *dev)\r\n{\r\n_rtl92e_dm_deinit_fsync(dev);\r\n}\r\nvoid rtl92e_dm_watchdog(struct net_device *dev)\r\n{\r\nstruct r8192_priv *priv = rtllib_priv(dev);\r\nif (priv->being_init_adapter)\r\nreturn;\r\n_rtl92e_dm_check_ac_dc_power(dev);\r\n_rtl92e_dm_check_txrateandretrycount(dev);\r\n_rtl92e_dm_check_edca_turbo(dev);\r\n_rtl92e_dm_check_rate_adaptive(dev);\r\n_rtl92e_dm_dynamic_tx_power(dev);\r\n_rtl92e_dm_check_tx_power_tracking(dev);\r\n_rtl92e_dm_ctrl_initgain_byrssi(dev);\r\n_rtl92e_dm_bandwidth_autoswitch(dev);\r\n_rtl92e_dm_check_rx_path_selection(dev);\r\n_rtl92e_dm_check_fsync(dev);\r\n_rtl92e_dm_send_rssi_to_fw(dev);\r\n_rtl92e_dm_cts_to_self(dev);\r\n}\r\nstatic void _rtl92e_dm_check_ac_dc_power(struct net_device *dev)\r\n{\r\nstruct r8192_priv *priv = rtllib_priv(dev);\r\nstatic char *ac_dc_script = "/etc/acpi/wireless-rtl-ac-dc-power.sh";\r\nchar *argv[] = {ac_dc_script, DRV_NAME, NULL};\r\nstatic char *envp[] = {"HOME=/",\r\n"TERM=linux",\r\n"PATH=/usr/bin:/bin",\r\nNULL};\r\nif (priv->ResetProgress == RESET_TYPE_SILENT) {\r\nRT_TRACE((COMP_INIT | COMP_POWER | COMP_RF),\r\n"GPIOChangeRFWorkItemCallBack(): Silent Reset!!!!!!!\n");\r\nreturn;\r\n}\r\nif (priv->rtllib->state != RTLLIB_LINKED)\r\nreturn;\r\ncall_usermodehelper(ac_dc_script, argv, envp, UMH_WAIT_PROC);\r\nreturn;\r\n}\r\nvoid rtl92e_init_adaptive_rate(struct net_device *dev)\r\n{\r\nstruct r8192_priv *priv = rtllib_priv(dev);\r\nstruct rate_adaptive *pra = &priv->rate_adaptive;\r\npra->ratr_state = DM_RATR_STA_MAX;\r\npra->high2low_rssi_thresh_for_ra = RateAdaptiveTH_High;\r\npra->low2high_rssi_thresh_for_ra20M = RateAdaptiveTH_Low_20M+5;\r\npra->low2high_rssi_thresh_for_ra40M = RateAdaptiveTH_Low_40M+5;\r\npra->high_rssi_thresh_for_ra = RateAdaptiveTH_High+5;\r\npra->low_rssi_thresh_for_ra20M = RateAdaptiveTH_Low_20M;\r\npra->low_rssi_thresh_for_ra40M = RateAdaptiveTH_Low_40M;\r\nif (priv->CustomerID == RT_CID_819x_Netcore)\r\npra->ping_rssi_enable = 1;\r\nelse\r\npra->ping_rssi_enable = 0;\r\npra->ping_rssi_thresh_for_ra = 15;\r\nif (priv->rf_type == RF_2T4R) {\r\npra->upper_rssi_threshold_ratr = 0x8f0f0000;\r\npra->middle_rssi_threshold_ratr = 0x8f0ff000;\r\npra->low_rssi_threshold_ratr = 0x8f0ff001;\r\npra->low_rssi_threshold_ratr_40M = 0x8f0ff005;\r\npra->low_rssi_threshold_ratr_20M = 0x8f0ff001;\r\npra->ping_rssi_ratr = 0x0000000d;\r\n} else if (priv->rf_type == RF_1T2R) {\r\npra->upper_rssi_threshold_ratr = 0x000fc000;\r\npra->middle_rssi_threshold_ratr = 0x000ff000;\r\npra->low_rssi_threshold_ratr = 0x000ff001;\r\npra->low_rssi_threshold_ratr_40M = 0x000ff005;\r\npra->low_rssi_threshold_ratr_20M = 0x000ff001;\r\npra->ping_rssi_ratr = 0x0000000d;\r\n}\r\n}\r\nstatic void _rtl92e_dm_check_rate_adaptive(struct net_device *dev)\r\n{\r\nstruct r8192_priv *priv = rtllib_priv(dev);\r\nstruct rt_hi_throughput *pHTInfo = priv->rtllib->pHTInfo;\r\nstruct rate_adaptive *pra = &priv->rate_adaptive;\r\nu32 currentRATR, targetRATR = 0;\r\nu32 LowRSSIThreshForRA = 0, HighRSSIThreshForRA = 0;\r\nbool bshort_gi_enabled = false;\r\nstatic u8 ping_rssi_state;\r\nif (!priv->up) {\r\nRT_TRACE(COMP_RATE,\r\n"<---- _rtl92e_dm_check_rate_adaptive(): driver is going to unload\n");\r\nreturn;\r\n}\r\nif (pra->rate_adaptive_disabled)\r\nreturn;\r\nif (!(priv->rtllib->mode == WIRELESS_MODE_N_24G ||\r\npriv->rtllib->mode == WIRELESS_MODE_N_5G))\r\nreturn;\r\nif (priv->rtllib->state == RTLLIB_LINKED) {\r\nbshort_gi_enabled = (pHTInfo->bCurTxBW40MHz &&\r\npHTInfo->bCurShortGI40MHz) ||\r\n(!pHTInfo->bCurTxBW40MHz &&\r\npHTInfo->bCurShortGI20MHz);\r\npra->upper_rssi_threshold_ratr =\r\n(pra->upper_rssi_threshold_ratr & (~BIT31)) |\r\n((bshort_gi_enabled) ? BIT31 : 0);\r\npra->middle_rssi_threshold_ratr =\r\n(pra->middle_rssi_threshold_ratr & (~BIT31)) |\r\n((bshort_gi_enabled) ? BIT31 : 0);\r\nif (priv->CurrentChannelBW != HT_CHANNEL_WIDTH_20) {\r\npra->low_rssi_threshold_ratr =\r\n(pra->low_rssi_threshold_ratr_40M & (~BIT31)) |\r\n((bshort_gi_enabled) ? BIT31 : 0);\r\n} else {\r\npra->low_rssi_threshold_ratr =\r\n(pra->low_rssi_threshold_ratr_20M & (~BIT31)) |\r\n((bshort_gi_enabled) ? BIT31 : 0);\r\n}\r\npra->ping_rssi_ratr =\r\n(pra->ping_rssi_ratr & (~BIT31)) |\r\n((bshort_gi_enabled) ? BIT31 : 0);\r\nif (pra->ratr_state == DM_RATR_STA_HIGH) {\r\nHighRSSIThreshForRA = pra->high2low_rssi_thresh_for_ra;\r\nLowRSSIThreshForRA = (priv->CurrentChannelBW != HT_CHANNEL_WIDTH_20) ?\r\n(pra->low_rssi_thresh_for_ra40M) : (pra->low_rssi_thresh_for_ra20M);\r\n} else if (pra->ratr_state == DM_RATR_STA_LOW) {\r\nHighRSSIThreshForRA = pra->high_rssi_thresh_for_ra;\r\nLowRSSIThreshForRA = (priv->CurrentChannelBW != HT_CHANNEL_WIDTH_20) ?\r\n(pra->low2high_rssi_thresh_for_ra40M) : (pra->low2high_rssi_thresh_for_ra20M);\r\n} else {\r\nHighRSSIThreshForRA = pra->high_rssi_thresh_for_ra;\r\nLowRSSIThreshForRA = (priv->CurrentChannelBW != HT_CHANNEL_WIDTH_20) ?\r\n(pra->low_rssi_thresh_for_ra40M) : (pra->low_rssi_thresh_for_ra20M);\r\n}\r\nif (priv->undecorated_smoothed_pwdb >=\r\n(long)HighRSSIThreshForRA) {\r\npra->ratr_state = DM_RATR_STA_HIGH;\r\ntargetRATR = pra->upper_rssi_threshold_ratr;\r\n} else if (priv->undecorated_smoothed_pwdb >=\r\n(long)LowRSSIThreshForRA) {\r\npra->ratr_state = DM_RATR_STA_MIDDLE;\r\ntargetRATR = pra->middle_rssi_threshold_ratr;\r\n} else {\r\npra->ratr_state = DM_RATR_STA_LOW;\r\ntargetRATR = pra->low_rssi_threshold_ratr;\r\n}\r\nif (pra->ping_rssi_enable) {\r\nif (priv->undecorated_smoothed_pwdb <\r\n(long)(pra->ping_rssi_thresh_for_ra+5)) {\r\nif ((priv->undecorated_smoothed_pwdb <\r\n(long)pra->ping_rssi_thresh_for_ra) ||\r\nping_rssi_state) {\r\npra->ratr_state = DM_RATR_STA_LOW;\r\ntargetRATR = pra->ping_rssi_ratr;\r\nping_rssi_state = 1;\r\n}\r\n} else {\r\nping_rssi_state = 0;\r\n}\r\n}\r\nif (priv->rtllib->GetHalfNmodeSupportByAPsHandler(dev))\r\ntargetRATR &= 0xf00fffff;\r\ncurrentRATR = rtl92e_readl(dev, RATR0);\r\nif (targetRATR != currentRATR) {\r\nu32 ratr_value;\r\nratr_value = targetRATR;\r\nRT_TRACE(COMP_RATE,\r\n"currentRATR = %x, targetRATR = %x\n",\r\ncurrentRATR, targetRATR);\r\nif (priv->rf_type == RF_1T2R)\r\nratr_value &= ~(RATE_ALL_OFDM_2SS);\r\nrtl92e_writel(dev, RATR0, ratr_value);\r\nrtl92e_writeb(dev, UFWP, 1);\r\npra->last_ratr = targetRATR;\r\n}\r\n} else {\r\npra->ratr_state = DM_RATR_STA_MAX;\r\n}\r\n}\r\nstatic void _rtl92e_dm_init_bandwidth_autoswitch(struct net_device *dev)\r\n{\r\nstruct r8192_priv *priv = rtllib_priv(dev);\r\npriv->rtllib->bandwidth_auto_switch.threshold_20Mhzto40Mhz = BW_AUTO_SWITCH_LOW_HIGH;\r\npriv->rtllib->bandwidth_auto_switch.threshold_40Mhzto20Mhz = BW_AUTO_SWITCH_HIGH_LOW;\r\npriv->rtllib->bandwidth_auto_switch.bforced_tx20Mhz = false;\r\npriv->rtllib->bandwidth_auto_switch.bautoswitch_enable = false;\r\n}\r\nstatic void _rtl92e_dm_bandwidth_autoswitch(struct net_device *dev)\r\n{\r\nstruct r8192_priv *priv = rtllib_priv(dev);\r\nif (priv->CurrentChannelBW == HT_CHANNEL_WIDTH_20 ||\r\n!priv->rtllib->bandwidth_auto_switch.bautoswitch_enable)\r\nreturn;\r\nif (priv->rtllib->bandwidth_auto_switch.bforced_tx20Mhz == false) {\r\nif (priv->undecorated_smoothed_pwdb <=\r\npriv->rtllib->bandwidth_auto_switch.threshold_40Mhzto20Mhz)\r\npriv->rtllib->bandwidth_auto_switch.bforced_tx20Mhz = true;\r\n} else {\r\nif (priv->undecorated_smoothed_pwdb >=\r\npriv->rtllib->bandwidth_auto_switch.threshold_20Mhzto40Mhz)\r\npriv->rtllib->bandwidth_auto_switch.bforced_tx20Mhz = false;\r\n}\r\n}\r\nstatic void _rtl92e_dm_tx_update_tssi_weak_signal(struct net_device *dev,\r\nu8 RF_Type)\r\n{\r\nstruct r8192_priv *p = rtllib_priv(dev);\r\nif (RF_Type == RF_2T4R) {\r\nif ((p->rfa_txpowertrackingindex > 0) &&\r\n(p->rfc_txpowertrackingindex > 0)) {\r\np->rfa_txpowertrackingindex--;\r\nif (p->rfa_txpowertrackingindex_real > 4) {\r\np->rfa_txpowertrackingindex_real--;\r\nrtl92e_set_bb_reg(dev, rOFDM0_XATxIQImbalance,\r\nbMaskDWord,\r\ndm_tx_bb_gain[p->rfa_txpowertrackingindex_real]);\r\n}\r\np->rfc_txpowertrackingindex--;\r\nif (p->rfc_txpowertrackingindex_real > 4) {\r\np->rfc_txpowertrackingindex_real--;\r\nrtl92e_set_bb_reg(dev,\r\nrOFDM0_XCTxIQImbalance,\r\nbMaskDWord,\r\ndm_tx_bb_gain[p->rfc_txpowertrackingindex_real]);\r\n}\r\n} else {\r\nrtl92e_set_bb_reg(dev, rOFDM0_XATxIQImbalance,\r\nbMaskDWord,\r\ndm_tx_bb_gain[4]);\r\nrtl92e_set_bb_reg(dev,\r\nrOFDM0_XCTxIQImbalance,\r\nbMaskDWord, dm_tx_bb_gain[4]);\r\n}\r\n} else {\r\nif (p->rfa_txpowertrackingindex > 0) {\r\np->rfa_txpowertrackingindex--;\r\nif (p->rfa_txpowertrackingindex_real > 4) {\r\np->rfa_txpowertrackingindex_real--;\r\nrtl92e_set_bb_reg(dev,\r\nrOFDM0_XATxIQImbalance,\r\nbMaskDWord,\r\ndm_tx_bb_gain[p->rfa_txpowertrackingindex_real]);\r\n}\r\n} else {\r\nrtl92e_set_bb_reg(dev, rOFDM0_XATxIQImbalance,\r\nbMaskDWord, dm_tx_bb_gain[4]);\r\n}\r\n}\r\n}\r\nstatic void _rtl92e_dm_tx_update_tssi_strong_signal(struct net_device *dev,\r\nu8 RF_Type)\r\n{\r\nstruct r8192_priv *p = rtllib_priv(dev);\r\nif (RF_Type == RF_2T4R) {\r\nif ((p->rfa_txpowertrackingindex < TxBBGainTableLength - 1) &&\r\n(p->rfc_txpowertrackingindex < TxBBGainTableLength - 1)) {\r\np->rfa_txpowertrackingindex++;\r\np->rfa_txpowertrackingindex_real++;\r\nrtl92e_set_bb_reg(dev, rOFDM0_XATxIQImbalance,\r\nbMaskDWord,\r\ndm_tx_bb_gain[p->rfa_txpowertrackingindex_real]);\r\np->rfc_txpowertrackingindex++;\r\np->rfc_txpowertrackingindex_real++;\r\nrtl92e_set_bb_reg(dev, rOFDM0_XCTxIQImbalance,\r\nbMaskDWord,\r\ndm_tx_bb_gain[p->rfc_txpowertrackingindex_real]);\r\n} else {\r\nrtl92e_set_bb_reg(dev, rOFDM0_XATxIQImbalance,\r\nbMaskDWord,\r\ndm_tx_bb_gain[TxBBGainTableLength - 1]);\r\nrtl92e_set_bb_reg(dev, rOFDM0_XCTxIQImbalance,\r\nbMaskDWord,\r\ndm_tx_bb_gain[TxBBGainTableLength - 1]);\r\n}\r\n} else {\r\nif (p->rfa_txpowertrackingindex < (TxBBGainTableLength - 1)) {\r\np->rfa_txpowertrackingindex++;\r\np->rfa_txpowertrackingindex_real++;\r\nrtl92e_set_bb_reg(dev, rOFDM0_XATxIQImbalance,\r\nbMaskDWord,\r\ndm_tx_bb_gain[p->rfa_txpowertrackingindex_real]);\r\n} else {\r\nrtl92e_set_bb_reg(dev, rOFDM0_XATxIQImbalance,\r\nbMaskDWord,\r\ndm_tx_bb_gain[TxBBGainTableLength - 1]);\r\n}\r\n}\r\n}\r\nstatic void _rtl92e_dm_tx_power_tracking_callback_tssi(struct net_device *dev)\r\n{\r\nstruct r8192_priv *priv = rtllib_priv(dev);\r\nbool bHighpowerstate, viviflag = false;\r\nstruct dcmd_txcmd tx_cmd;\r\nu8 powerlevelOFDM24G;\r\nint i = 0, j = 0, k = 0;\r\nu8 RF_Type, tmp_report[5] = {0, 0, 0, 0, 0};\r\nu32 Value;\r\nu8 Pwr_Flag;\r\nu16 Avg_TSSI_Meas, TSSI_13dBm, Avg_TSSI_Meas_from_driver = 0;\r\nu32 delta = 0;\r\nRT_TRACE(COMP_POWER_TRACKING, "%s()\n", __func__);\r\nrtl92e_writeb(dev, Pw_Track_Flag, 0);\r\nrtl92e_writeb(dev, FW_Busy_Flag, 0);\r\npriv->rtllib->bdynamic_txpower_enable = false;\r\nbHighpowerstate = priv->bDynamicTxHighPower;\r\npowerlevelOFDM24G = (u8)(priv->Pwr_Track>>24);\r\nRF_Type = priv->rf_type;\r\nValue = (RF_Type<<8) | powerlevelOFDM24G;\r\nRT_TRACE(COMP_POWER_TRACKING, "powerlevelOFDM24G = %x\n",\r\npowerlevelOFDM24G);\r\nfor (j = 0; j <= 30; j++) {\r\ntx_cmd.Op = TXCMD_SET_TX_PWR_TRACKING;\r\ntx_cmd.Length = 4;\r\ntx_cmd.Value = Value;\r\nrtl92e_send_cmd_pkt(dev, DESC_PACKET_TYPE_NORMAL, (u8 *)&tx_cmd,\r\nsizeof(struct dcmd_txcmd));\r\nmdelay(1);\r\nfor (i = 0; i <= 30; i++) {\r\nPwr_Flag = rtl92e_readb(dev, Pw_Track_Flag);\r\nif (Pwr_Flag == 0) {\r\nmdelay(1);\r\nif (priv->bResetInProgress) {\r\nRT_TRACE(COMP_POWER_TRACKING,\r\n"we are in silent reset progress, so return\n");\r\nrtl92e_writeb(dev, Pw_Track_Flag, 0);\r\nrtl92e_writeb(dev, FW_Busy_Flag, 0);\r\nreturn;\r\n}\r\nif (priv->rtllib->eRFPowerState != eRfOn) {\r\nRT_TRACE(COMP_POWER_TRACKING,\r\n"we are in power save, so return\n");\r\nrtl92e_writeb(dev, Pw_Track_Flag, 0);\r\nrtl92e_writeb(dev, FW_Busy_Flag, 0);\r\nreturn;\r\n}\r\ncontinue;\r\n}\r\nAvg_TSSI_Meas = rtl92e_readw(dev, Tssi_Mea_Value);\r\nif (Avg_TSSI_Meas == 0) {\r\nrtl92e_writeb(dev, Pw_Track_Flag, 0);\r\nrtl92e_writeb(dev, FW_Busy_Flag, 0);\r\nreturn;\r\n}\r\nfor (k = 0; k < 5; k++) {\r\nif (k != 4)\r\ntmp_report[k] = rtl92e_readb(dev,\r\nTssi_Report_Value1+k);\r\nelse\r\ntmp_report[k] = rtl92e_readb(dev,\r\nTssi_Report_Value2);\r\nRT_TRACE(COMP_POWER_TRACKING,\r\n"TSSI_report_value = %d\n",\r\ntmp_report[k]);\r\nif (tmp_report[k] <= 20) {\r\nviviflag = true;\r\nbreak;\r\n}\r\n}\r\nif (viviflag) {\r\nrtl92e_writeb(dev, Pw_Track_Flag, 0);\r\nviviflag = false;\r\nRT_TRACE(COMP_POWER_TRACKING,\r\n"we filted this data\n");\r\nfor (k = 0; k < 5; k++)\r\ntmp_report[k] = 0;\r\nbreak;\r\n}\r\nfor (k = 0; k < 5; k++)\r\nAvg_TSSI_Meas_from_driver += tmp_report[k];\r\nAvg_TSSI_Meas_from_driver *= 100 / 5;\r\nRT_TRACE(COMP_POWER_TRACKING,\r\n"Avg_TSSI_Meas_from_driver = %d\n",\r\nAvg_TSSI_Meas_from_driver);\r\nTSSI_13dBm = priv->TSSI_13dBm;\r\nRT_TRACE(COMP_POWER_TRACKING, "TSSI_13dBm = %d\n",\r\nTSSI_13dBm);\r\nif (Avg_TSSI_Meas_from_driver > TSSI_13dBm)\r\ndelta = Avg_TSSI_Meas_from_driver - TSSI_13dBm;\r\nelse\r\ndelta = TSSI_13dBm - Avg_TSSI_Meas_from_driver;\r\nif (delta <= E_FOR_TX_POWER_TRACK) {\r\npriv->rtllib->bdynamic_txpower_enable = true;\r\nrtl92e_writeb(dev, Pw_Track_Flag, 0);\r\nrtl92e_writeb(dev, FW_Busy_Flag, 0);\r\nRT_TRACE(COMP_POWER_TRACKING,\r\n"tx power track is done\n");\r\nRT_TRACE(COMP_POWER_TRACKING,\r\n"priv->rfa_txpowertrackingindex = %d\n",\r\npriv->rfa_txpowertrackingindex);\r\nRT_TRACE(COMP_POWER_TRACKING,\r\n"priv->rfa_txpowertrackingindex_real = %d\n",\r\npriv->rfa_txpowertrackingindex_real);\r\nRT_TRACE(COMP_POWER_TRACKING,\r\n"priv->CCKPresentAttentuation_difference = %d\n",\r\npriv->CCKPresentAttentuation_difference);\r\nRT_TRACE(COMP_POWER_TRACKING,\r\n"priv->CCKPresentAttentuation = %d\n",\r\npriv->CCKPresentAttentuation);\r\nreturn;\r\n}\r\nif (Avg_TSSI_Meas_from_driver < TSSI_13dBm - E_FOR_TX_POWER_TRACK)\r\n_rtl92e_dm_tx_update_tssi_weak_signal(dev,\r\nRF_Type);\r\nelse\r\n_rtl92e_dm_tx_update_tssi_strong_signal(dev, RF_Type);\r\nif (RF_Type == RF_2T4R) {\r\npriv->CCKPresentAttentuation_difference\r\n= priv->rfa_txpowertrackingindex - priv->rfa_txpowertracking_default;\r\n} else {\r\npriv->CCKPresentAttentuation_difference\r\n= priv->rfa_txpowertrackingindex_real - priv->rfa_txpowertracking_default;\r\n}\r\nif (priv->CurrentChannelBW == HT_CHANNEL_WIDTH_20)\r\npriv->CCKPresentAttentuation =\r\npriv->CCKPresentAttentuation_20Mdefault +\r\npriv->CCKPresentAttentuation_difference;\r\nelse\r\npriv->CCKPresentAttentuation =\r\npriv->CCKPresentAttentuation_40Mdefault +\r\npriv->CCKPresentAttentuation_difference;\r\nif (priv->CCKPresentAttentuation > (CCKTxBBGainTableLength-1))\r\npriv->CCKPresentAttentuation = CCKTxBBGainTableLength-1;\r\nif (priv->CCKPresentAttentuation < 0)\r\npriv->CCKPresentAttentuation = 0;\r\nif (priv->CCKPresentAttentuation > -1 &&\r\npriv->CCKPresentAttentuation < CCKTxBBGainTableLength) {\r\nif (priv->rtllib->current_network.channel == 14 &&\r\n!priv->bcck_in_ch14) {\r\npriv->bcck_in_ch14 = true;\r\nrtl92e_dm_cck_txpower_adjust(dev, priv->bcck_in_ch14);\r\n} else if (priv->rtllib->current_network.channel != 14 && priv->bcck_in_ch14) {\r\npriv->bcck_in_ch14 = false;\r\nrtl92e_dm_cck_txpower_adjust(dev, priv->bcck_in_ch14);\r\n} else\r\nrtl92e_dm_cck_txpower_adjust(dev, priv->bcck_in_ch14);\r\n}\r\nRT_TRACE(COMP_POWER_TRACKING,\r\n"priv->rfa_txpowertrackingindex = %d\n",\r\npriv->rfa_txpowertrackingindex);\r\nRT_TRACE(COMP_POWER_TRACKING,\r\n"priv->rfa_txpowertrackingindex_real = %d\n",\r\npriv->rfa_txpowertrackingindex_real);\r\nRT_TRACE(COMP_POWER_TRACKING,\r\n"priv->CCKPresentAttentuation_difference = %d\n",\r\npriv->CCKPresentAttentuation_difference);\r\nRT_TRACE(COMP_POWER_TRACKING,\r\n"priv->CCKPresentAttentuation = %d\n",\r\npriv->CCKPresentAttentuation);\r\nif (priv->CCKPresentAttentuation_difference <= -12 ||\r\npriv->CCKPresentAttentuation_difference >= 24) {\r\npriv->rtllib->bdynamic_txpower_enable = true;\r\nrtl92e_writeb(dev, Pw_Track_Flag, 0);\r\nrtl92e_writeb(dev, FW_Busy_Flag, 0);\r\nRT_TRACE(COMP_POWER_TRACKING,\r\n"tx power track--->limited\n");\r\nreturn;\r\n}\r\nrtl92e_writeb(dev, Pw_Track_Flag, 0);\r\nAvg_TSSI_Meas_from_driver = 0;\r\nfor (k = 0; k < 5; k++)\r\ntmp_report[k] = 0;\r\nbreak;\r\n}\r\nrtl92e_writeb(dev, FW_Busy_Flag, 0);\r\n}\r\npriv->rtllib->bdynamic_txpower_enable = true;\r\nrtl92e_writeb(dev, Pw_Track_Flag, 0);\r\n}\r\nstatic void _rtl92e_dm_tx_power_tracking_cb_thermal(struct net_device *dev)\r\n{\r\n#define ThermalMeterVal 9\r\nstruct r8192_priv *priv = rtllib_priv(dev);\r\nu32 tmpRegA, TempCCk;\r\nu8 tmpOFDMindex, tmpCCKindex, tmpCCK20Mindex, tmpCCK40Mindex, tmpval;\r\nint i = 0, CCKSwingNeedUpdate = 0;\r\nif (!priv->btxpower_trackingInit) {\r\ntmpRegA = rtl92e_get_bb_reg(dev, rOFDM0_XATxIQImbalance,\r\nbMaskDWord);\r\nfor (i = 0; i < OFDM_Table_Length; i++) {\r\nif (tmpRegA == OFDMSwingTable[i]) {\r\npriv->OFDM_index[0] = (u8)i;\r\nRT_TRACE(COMP_POWER_TRACKING,\r\n"Initial reg0x%x = 0x%x, OFDM_index = 0x%x\n",\r\nrOFDM0_XATxIQImbalance, tmpRegA,\r\npriv->OFDM_index[0]);\r\n}\r\n}\r\nTempCCk = rtl92e_get_bb_reg(dev, rCCK0_TxFilter1, bMaskByte2);\r\nfor (i = 0; i < CCK_Table_length; i++) {\r\nif (TempCCk == (u32)CCKSwingTable_Ch1_Ch13[i][0]) {\r\npriv->CCK_index = (u8) i;\r\nRT_TRACE(COMP_POWER_TRACKING,\r\n"Initial reg0x%x = 0x%x, CCK_index = 0x%x\n",\r\nrCCK0_TxFilter1, TempCCk,\r\npriv->CCK_index);\r\nbreak;\r\n}\r\n}\r\npriv->btxpower_trackingInit = true;\r\nreturn;\r\n}\r\ntmpRegA = rtl92e_get_rf_reg(dev, RF90_PATH_A, 0x12, 0x078);\r\nRT_TRACE(COMP_POWER_TRACKING, "Readback ThermalMeterA = %d\n", tmpRegA);\r\nif (tmpRegA < 3 || tmpRegA > 13)\r\nreturn;\r\nif (tmpRegA >= 12)\r\ntmpRegA = 12;\r\nRT_TRACE(COMP_POWER_TRACKING, "Valid ThermalMeterA = %d\n", tmpRegA);\r\npriv->ThermalMeter[0] = ThermalMeterVal;\r\npriv->ThermalMeter[1] = ThermalMeterVal;\r\nif (priv->ThermalMeter[0] >= (u8)tmpRegA) {\r\ntmpOFDMindex = tmpCCK20Mindex = 6+(priv->ThermalMeter[0] -\r\n(u8)tmpRegA);\r\ntmpCCK40Mindex = tmpCCK20Mindex - 6;\r\nif (tmpOFDMindex >= OFDM_Table_Length)\r\ntmpOFDMindex = OFDM_Table_Length-1;\r\nif (tmpCCK20Mindex >= CCK_Table_length)\r\ntmpCCK20Mindex = CCK_Table_length-1;\r\nif (tmpCCK40Mindex >= CCK_Table_length)\r\ntmpCCK40Mindex = CCK_Table_length-1;\r\n} else {\r\ntmpval = ((u8)tmpRegA - priv->ThermalMeter[0]);\r\nif (tmpval >= 6)\r\ntmpOFDMindex = tmpCCK20Mindex = 0;\r\nelse\r\ntmpOFDMindex = tmpCCK20Mindex = 6 - tmpval;\r\ntmpCCK40Mindex = 0;\r\n}\r\nif (priv->CurrentChannelBW != HT_CHANNEL_WIDTH_20)\r\ntmpCCKindex = tmpCCK40Mindex;\r\nelse\r\ntmpCCKindex = tmpCCK20Mindex;\r\npriv->Record_CCK_20Mindex = tmpCCK20Mindex;\r\npriv->Record_CCK_40Mindex = tmpCCK40Mindex;\r\nRT_TRACE(COMP_POWER_TRACKING,\r\n"Record_CCK_20Mindex / Record_CCK_40Mindex = %d / %d.\n",\r\npriv->Record_CCK_20Mindex, priv->Record_CCK_40Mindex);\r\nif (priv->rtllib->current_network.channel == 14 &&\r\n!priv->bcck_in_ch14) {\r\npriv->bcck_in_ch14 = true;\r\nCCKSwingNeedUpdate = 1;\r\n} else if (priv->rtllib->current_network.channel != 14 &&\r\npriv->bcck_in_ch14) {\r\npriv->bcck_in_ch14 = false;\r\nCCKSwingNeedUpdate = 1;\r\n}\r\nif (priv->CCK_index != tmpCCKindex) {\r\npriv->CCK_index = tmpCCKindex;\r\nCCKSwingNeedUpdate = 1;\r\n}\r\nif (CCKSwingNeedUpdate)\r\nrtl92e_dm_cck_txpower_adjust(dev, priv->bcck_in_ch14);\r\nif (priv->OFDM_index[0] != tmpOFDMindex) {\r\npriv->OFDM_index[0] = tmpOFDMindex;\r\nrtl92e_set_bb_reg(dev, rOFDM0_XATxIQImbalance, bMaskDWord,\r\nOFDMSwingTable[priv->OFDM_index[0]]);\r\nRT_TRACE(COMP_POWER_TRACKING, "Update OFDMSwing[%d] = 0x%x\n",\r\npriv->OFDM_index[0],\r\nOFDMSwingTable[priv->OFDM_index[0]]);\r\n}\r\npriv->txpower_count = 0;\r\n}\r\nvoid rtl92e_dm_txpower_tracking_wq(void *data)\r\n{\r\nstruct r8192_priv *priv = container_of_dwork_rsl(data,\r\nstruct r8192_priv, txpower_tracking_wq);\r\nstruct net_device *dev = priv->rtllib->dev;\r\nif (priv->IC_Cut >= IC_VersionCut_D)\r\n_rtl92e_dm_tx_power_tracking_callback_tssi(dev);\r\nelse\r\n_rtl92e_dm_tx_power_tracking_cb_thermal(dev);\r\n}\r\nstatic void _rtl92e_dm_initialize_tx_power_tracking_tssi(struct net_device *dev)\r\n{\r\nstruct r8192_priv *priv = rtllib_priv(dev);\r\npriv->btxpower_tracking = true;\r\npriv->txpower_count = 0;\r\npriv->btxpower_trackingInit = false;\r\n}\r\nstatic void _rtl92e_dm_init_tx_power_tracking_thermal(struct net_device *dev)\r\n{\r\nstruct r8192_priv *priv = rtllib_priv(dev);\r\nif (priv->rtllib->FwRWRF)\r\npriv->btxpower_tracking = true;\r\nelse\r\npriv->btxpower_tracking = false;\r\npriv->txpower_count = 0;\r\npriv->btxpower_trackingInit = false;\r\nRT_TRACE(COMP_POWER_TRACKING, "pMgntInfo->bTXPowerTracking = %d\n",\r\npriv->btxpower_tracking);\r\n}\r\nvoid rtl92e_dm_init_txpower_tracking(struct net_device *dev)\r\n{\r\nstruct r8192_priv *priv = rtllib_priv(dev);\r\nif (priv->IC_Cut >= IC_VersionCut_D)\r\n_rtl92e_dm_initialize_tx_power_tracking_tssi(dev);\r\nelse\r\n_rtl92e_dm_init_tx_power_tracking_thermal(dev);\r\n}\r\nstatic void _rtl92e_dm_check_tx_power_tracking_tssi(struct net_device *dev)\r\n{\r\nstruct r8192_priv *priv = rtllib_priv(dev);\r\nstatic u32 tx_power_track_counter;\r\nRT_TRACE(COMP_POWER_TRACKING, "%s()\n", __func__);\r\nif (rtl92e_readb(dev, 0x11e) == 1)\r\nreturn;\r\nif (!priv->btxpower_tracking)\r\nreturn;\r\ntx_power_track_counter++;\r\nif (tx_power_track_counter >= 180) {\r\nschedule_delayed_work(&priv->txpower_tracking_wq, 0);\r\ntx_power_track_counter = 0;\r\n}\r\n}\r\nstatic void _rtl92e_dm_check_tx_power_tracking_thermal(struct net_device *dev)\r\n{\r\nstruct r8192_priv *priv = rtllib_priv(dev);\r\nstatic u8 TM_Trigger;\r\nu8 TxPowerCheckCnt = 0;\r\nif (IS_HARDWARE_TYPE_8192SE(dev))\r\nTxPowerCheckCnt = 5;\r\nelse\r\nTxPowerCheckCnt = 2;\r\nif (!priv->btxpower_tracking)\r\nreturn;\r\nif (priv->txpower_count <= TxPowerCheckCnt) {\r\npriv->txpower_count++;\r\nreturn;\r\n}\r\nif (!TM_Trigger) {\r\nrtl92e_set_rf_reg(dev, RF90_PATH_A, 0x02, bMask12Bits, 0x4d);\r\nrtl92e_set_rf_reg(dev, RF90_PATH_A, 0x02, bMask12Bits, 0x4f);\r\nrtl92e_set_rf_reg(dev, RF90_PATH_A, 0x02, bMask12Bits, 0x4d);\r\nrtl92e_set_rf_reg(dev, RF90_PATH_A, 0x02, bMask12Bits, 0x4f);\r\nTM_Trigger = 1;\r\nreturn;\r\n}\r\nnetdev_info(dev, "===============>Schedule TxPowerTrackingWorkItem\n");\r\nschedule_delayed_work(&priv->txpower_tracking_wq, 0);\r\nTM_Trigger = 0;\r\n}\r\nstatic void _rtl92e_dm_check_tx_power_tracking(struct net_device *dev)\r\n{\r\nstruct r8192_priv *priv = rtllib_priv(dev);\r\nif (priv->IC_Cut >= IC_VersionCut_D)\r\n_rtl92e_dm_check_tx_power_tracking_tssi(dev);\r\nelse\r\n_rtl92e_dm_check_tx_power_tracking_thermal(dev);\r\n}\r\nstatic void _rtl92e_dm_cck_tx_power_adjust_tssi(struct net_device *dev,\r\nbool bInCH14)\r\n{\r\nu32 TempVal;\r\nstruct r8192_priv *priv = rtllib_priv(dev);\r\nu8 attenuation = (u8)priv->CCKPresentAttentuation;\r\nTempVal = 0;\r\nif (!bInCH14) {\r\nTempVal = (u32)(dm_cck_tx_bb_gain[attenuation][0] +\r\n(dm_cck_tx_bb_gain[attenuation][1] << 8));\r\nrtl92e_set_bb_reg(dev, rCCK0_TxFilter1, bMaskHWord, TempVal);\r\nTempVal = (u32)((dm_cck_tx_bb_gain[attenuation][2]) +\r\n(dm_cck_tx_bb_gain[attenuation][3] << 8) +\r\n(dm_cck_tx_bb_gain[attenuation][4] << 16)+\r\n(dm_cck_tx_bb_gain[attenuation][5] << 24));\r\nrtl92e_set_bb_reg(dev, rCCK0_TxFilter2, bMaskDWord, TempVal);\r\nTempVal = (u32)(dm_cck_tx_bb_gain[attenuation][6] +\r\n(dm_cck_tx_bb_gain[attenuation][7] << 8));\r\nrtl92e_set_bb_reg(dev, rCCK0_DebugPort, bMaskLWord, TempVal);\r\n} else {\r\nTempVal = (u32)((dm_cck_tx_bb_gain_ch14[attenuation][0]) +\r\n(dm_cck_tx_bb_gain_ch14[attenuation][1] << 8));\r\nrtl92e_set_bb_reg(dev, rCCK0_TxFilter1, bMaskHWord, TempVal);\r\nTempVal = (u32)((dm_cck_tx_bb_gain_ch14[attenuation][2]) +\r\n(dm_cck_tx_bb_gain_ch14[attenuation][3] << 8) +\r\n(dm_cck_tx_bb_gain_ch14[attenuation][4] << 16)+\r\n(dm_cck_tx_bb_gain_ch14[attenuation][5] << 24));\r\nrtl92e_set_bb_reg(dev, rCCK0_TxFilter2, bMaskDWord, TempVal);\r\nTempVal = (u32)((dm_cck_tx_bb_gain_ch14[attenuation][6]) +\r\n(dm_cck_tx_bb_gain_ch14[attenuation][7] << 8));\r\nrtl92e_set_bb_reg(dev, rCCK0_DebugPort, bMaskLWord, TempVal);\r\n}\r\n}\r\nstatic void _rtl92e_dm_cck_tx_power_adjust_thermal_meter(struct net_device *dev,\r\nbool bInCH14)\r\n{\r\nu32 TempVal;\r\nstruct r8192_priv *priv = rtllib_priv(dev);\r\nTempVal = 0;\r\nif (!bInCH14) {\r\nTempVal = CCKSwingTable_Ch1_Ch13[priv->CCK_index][0] +\r\n(CCKSwingTable_Ch1_Ch13[priv->CCK_index][1] << 8);\r\nrtl92e_set_bb_reg(dev, rCCK0_TxFilter1, bMaskHWord, TempVal);\r\nRT_TRACE(COMP_POWER_TRACKING,\r\n"CCK not chnl 14, reg 0x%x = 0x%x\n", rCCK0_TxFilter1,\r\nTempVal);\r\nTempVal = CCKSwingTable_Ch1_Ch13[priv->CCK_index][2] +\r\n(CCKSwingTable_Ch1_Ch13[priv->CCK_index][3] << 8) +\r\n(CCKSwingTable_Ch1_Ch13[priv->CCK_index][4] << 16)+\r\n(CCKSwingTable_Ch1_Ch13[priv->CCK_index][5] << 24);\r\nrtl92e_set_bb_reg(dev, rCCK0_TxFilter2, bMaskDWord, TempVal);\r\nRT_TRACE(COMP_POWER_TRACKING,\r\n"CCK not chnl 14, reg 0x%x = 0x%x\n", rCCK0_TxFilter2,\r\nTempVal);\r\nTempVal = CCKSwingTable_Ch1_Ch13[priv->CCK_index][6] +\r\n(CCKSwingTable_Ch1_Ch13[priv->CCK_index][7] << 8);\r\nrtl92e_set_bb_reg(dev, rCCK0_DebugPort, bMaskLWord, TempVal);\r\nRT_TRACE(COMP_POWER_TRACKING,\r\n"CCK not chnl 14, reg 0x%x = 0x%x\n", rCCK0_DebugPort,\r\nTempVal);\r\n} else {\r\nTempVal = CCKSwingTable_Ch14[priv->CCK_index][0] +\r\n(CCKSwingTable_Ch14[priv->CCK_index][1] << 8);\r\nrtl92e_set_bb_reg(dev, rCCK0_TxFilter1, bMaskHWord, TempVal);\r\nRT_TRACE(COMP_POWER_TRACKING, "CCK chnl 14, reg 0x%x = 0x%x\n",\r\nrCCK0_TxFilter1, TempVal);\r\nTempVal = CCKSwingTable_Ch14[priv->CCK_index][2] +\r\n(CCKSwingTable_Ch14[priv->CCK_index][3] << 8) +\r\n(CCKSwingTable_Ch14[priv->CCK_index][4] << 16)+\r\n(CCKSwingTable_Ch14[priv->CCK_index][5] << 24);\r\nrtl92e_set_bb_reg(dev, rCCK0_TxFilter2, bMaskDWord, TempVal);\r\nRT_TRACE(COMP_POWER_TRACKING, "CCK chnl 14, reg 0x%x = 0x%x\n",\r\nrCCK0_TxFilter2, TempVal);\r\nTempVal = CCKSwingTable_Ch14[priv->CCK_index][6] +\r\n(CCKSwingTable_Ch14[priv->CCK_index][7]<<8);\r\nrtl92e_set_bb_reg(dev, rCCK0_DebugPort, bMaskLWord, TempVal);\r\nRT_TRACE(COMP_POWER_TRACKING, "CCK chnl 14, reg 0x%x = 0x%x\n",\r\nrCCK0_DebugPort, TempVal);\r\n}\r\n}\r\nvoid rtl92e_dm_cck_txpower_adjust(struct net_device *dev, bool binch14)\r\n{\r\nstruct r8192_priv *priv = rtllib_priv(dev);\r\nif (priv->IC_Cut >= IC_VersionCut_D)\r\n_rtl92e_dm_cck_tx_power_adjust_tssi(dev, binch14);\r\nelse\r\n_rtl92e_dm_cck_tx_power_adjust_thermal_meter(dev, binch14);\r\n}\r\nstatic void _rtl92e_dm_tx_power_reset_recovery(struct net_device *dev)\r\n{\r\nstruct r8192_priv *priv = rtllib_priv(dev);\r\nRT_TRACE(COMP_POWER_TRACKING, "Start Reset Recovery ==>\n");\r\nrtl92e_set_bb_reg(dev, rOFDM0_XATxIQImbalance, bMaskDWord,\r\ndm_tx_bb_gain[priv->rfa_txpowertrackingindex]);\r\nRT_TRACE(COMP_POWER_TRACKING, "Reset Recovery: Fill in 0xc80 is %08x\n",\r\ndm_tx_bb_gain[priv->rfa_txpowertrackingindex]);\r\nRT_TRACE(COMP_POWER_TRACKING,\r\n"Reset Recovery: Fill in RFA_txPowerTrackingIndex is %x\n",\r\npriv->rfa_txpowertrackingindex);\r\nRT_TRACE(COMP_POWER_TRACKING,\r\n"Reset Recovery : RF A I/Q Amplify Gain is %d\n",\r\ndm_tx_bb_gain_idx_to_amplify(priv->rfa_txpowertrackingindex));\r\nRT_TRACE(COMP_POWER_TRACKING,\r\n"Reset Recovery: CCK Attenuation is %d dB\n",\r\npriv->CCKPresentAttentuation);\r\nrtl92e_dm_cck_txpower_adjust(dev, priv->bcck_in_ch14);\r\nrtl92e_set_bb_reg(dev, rOFDM0_XCTxIQImbalance, bMaskDWord,\r\ndm_tx_bb_gain[priv->rfc_txpowertrackingindex]);\r\nRT_TRACE(COMP_POWER_TRACKING, "Reset Recovery: Fill in 0xc90 is %08x\n",\r\ndm_tx_bb_gain[priv->rfc_txpowertrackingindex]);\r\nRT_TRACE(COMP_POWER_TRACKING,\r\n"Reset Recovery: Fill in RFC_txPowerTrackingIndex is %x\n",\r\npriv->rfc_txpowertrackingindex);\r\nRT_TRACE(COMP_POWER_TRACKING,\r\n"Reset Recovery : RF C I/Q Amplify Gain is %d\n",\r\ndm_tx_bb_gain_idx_to_amplify(priv->rfc_txpowertrackingindex));\r\n}\r\nvoid rtl92e_dm_restore_state(struct net_device *dev)\r\n{\r\nstruct r8192_priv *priv = rtllib_priv(dev);\r\nu32 reg_ratr = priv->rate_adaptive.last_ratr;\r\nu32 ratr_value;\r\nif (!priv->up) {\r\nRT_TRACE(COMP_RATE,\r\n"<---- rtl92e_dm_restore_state(): driver is going to unload\n");\r\nreturn;\r\n}\r\nif (priv->rate_adaptive.rate_adaptive_disabled)\r\nreturn;\r\nif (!(priv->rtllib->mode == WIRELESS_MODE_N_24G ||\r\npriv->rtllib->mode == WIRELESS_MODE_N_5G))\r\nreturn;\r\nratr_value = reg_ratr;\r\nif (priv->rf_type == RF_1T2R)\r\nratr_value &= ~(RATE_ALL_OFDM_2SS);\r\nrtl92e_writel(dev, RATR0, ratr_value);\r\nrtl92e_writeb(dev, UFWP, 1);\r\nif (priv->btxpower_trackingInit && priv->btxpower_tracking)\r\n_rtl92e_dm_tx_power_reset_recovery(dev);\r\n_rtl92e_dm_bb_initialgain_restore(dev);\r\n}\r\nstatic void _rtl92e_dm_bb_initialgain_restore(struct net_device *dev)\r\n{\r\nstruct r8192_priv *priv = rtllib_priv(dev);\r\nu32 bit_mask = 0x7f;\r\nif (dm_digtable.dig_algorithm == DIG_ALGO_BY_RSSI)\r\nreturn;\r\nrtl92e_set_bb_reg(dev, UFWP, bMaskByte1, 0x8);\r\nrtl92e_set_bb_reg(dev, rOFDM0_XAAGCCore1, bit_mask,\r\n(u32)priv->initgain_backup.xaagccore1);\r\nrtl92e_set_bb_reg(dev, rOFDM0_XBAGCCore1, bit_mask,\r\n(u32)priv->initgain_backup.xbagccore1);\r\nrtl92e_set_bb_reg(dev, rOFDM0_XCAGCCore1, bit_mask,\r\n(u32)priv->initgain_backup.xcagccore1);\r\nrtl92e_set_bb_reg(dev, rOFDM0_XDAGCCore1, bit_mask,\r\n(u32)priv->initgain_backup.xdagccore1);\r\nbit_mask = bMaskByte2;\r\nrtl92e_set_bb_reg(dev, rCCK0_CCA, bit_mask,\r\n(u32)priv->initgain_backup.cca);\r\nRT_TRACE(COMP_DIG, "dm_BBInitialGainRestore 0xc50 is %x\n",\r\npriv->initgain_backup.xaagccore1);\r\nRT_TRACE(COMP_DIG, "dm_BBInitialGainRestore 0xc58 is %x\n",\r\npriv->initgain_backup.xbagccore1);\r\nRT_TRACE(COMP_DIG, "dm_BBInitialGainRestore 0xc60 is %x\n",\r\npriv->initgain_backup.xcagccore1);\r\nRT_TRACE(COMP_DIG, "dm_BBInitialGainRestore 0xc68 is %x\n",\r\npriv->initgain_backup.xdagccore1);\r\nRT_TRACE(COMP_DIG, "dm_BBInitialGainRestore 0xa0a is %x\n",\r\npriv->initgain_backup.cca);\r\nrtl92e_set_bb_reg(dev, UFWP, bMaskByte1, 0x1);\r\n}\r\nvoid rtl92e_dm_backup_state(struct net_device *dev)\r\n{\r\nstruct r8192_priv *priv = rtllib_priv(dev);\r\nu32 bit_mask = bMaskByte0;\r\npriv->bswitch_fsync = false;\r\npriv->bfsync_processing = false;\r\nif (dm_digtable.dig_algorithm == DIG_ALGO_BY_RSSI)\r\nreturn;\r\nrtl92e_set_bb_reg(dev, UFWP, bMaskByte1, 0x8);\r\npriv->initgain_backup.xaagccore1 = (u8)rtl92e_get_bb_reg(dev, rOFDM0_XAAGCCore1, bit_mask);\r\npriv->initgain_backup.xbagccore1 = (u8)rtl92e_get_bb_reg(dev, rOFDM0_XBAGCCore1, bit_mask);\r\npriv->initgain_backup.xcagccore1 = (u8)rtl92e_get_bb_reg(dev, rOFDM0_XCAGCCore1, bit_mask);\r\npriv->initgain_backup.xdagccore1 = (u8)rtl92e_get_bb_reg(dev, rOFDM0_XDAGCCore1, bit_mask);\r\nbit_mask = bMaskByte2;\r\npriv->initgain_backup.cca = (u8)rtl92e_get_bb_reg(dev, rCCK0_CCA, bit_mask);\r\nRT_TRACE(COMP_DIG, "BBInitialGainBackup 0xc50 is %x\n",\r\npriv->initgain_backup.xaagccore1);\r\nRT_TRACE(COMP_DIG, "BBInitialGainBackup 0xc58 is %x\n",\r\npriv->initgain_backup.xbagccore1);\r\nRT_TRACE(COMP_DIG, "BBInitialGainBackup 0xc60 is %x\n",\r\npriv->initgain_backup.xcagccore1);\r\nRT_TRACE(COMP_DIG, "BBInitialGainBackup 0xc68 is %x\n",\r\npriv->initgain_backup.xdagccore1);\r\nRT_TRACE(COMP_DIG, "BBInitialGainBackup 0xa0a is %x\n",\r\npriv->initgain_backup.cca);\r\n}\r\nstatic void _rtl92e_dm_dig_init(struct net_device *dev)\r\n{\r\nstruct r8192_priv *priv = rtllib_priv(dev);\r\ndm_digtable.dig_enable_flag = true;\r\ndm_digtable.dig_algorithm = DIG_ALGO_BY_RSSI;\r\ndm_digtable.dig_algorithm_switch = 0;\r\ndm_digtable.dig_state = DM_STA_DIG_MAX;\r\ndm_digtable.dig_highpwr_state = DM_STA_DIG_MAX;\r\ndm_digtable.CurSTAConnectState = DIG_STA_DISCONNECT;\r\ndm_digtable.PreSTAConnectState = DIG_STA_DISCONNECT;\r\ndm_digtable.rssi_low_thresh = DM_DIG_THRESH_LOW;\r\ndm_digtable.rssi_high_thresh = DM_DIG_THRESH_HIGH;\r\ndm_digtable.rssi_high_power_lowthresh = DM_DIG_HIGH_PWR_THRESH_LOW;\r\ndm_digtable.rssi_high_power_highthresh = DM_DIG_HIGH_PWR_THRESH_HIGH;\r\ndm_digtable.rssi_val = 50;\r\ndm_digtable.backoff_val = DM_DIG_BACKOFF;\r\ndm_digtable.rx_gain_range_max = DM_DIG_MAX;\r\nif (priv->CustomerID == RT_CID_819x_Netcore)\r\ndm_digtable.rx_gain_range_min = DM_DIG_MIN_Netcore;\r\nelse\r\ndm_digtable.rx_gain_range_min = DM_DIG_MIN;\r\n}\r\nstatic void _rtl92e_dm_ctrl_initgain_byrssi(struct net_device *dev)\r\n{\r\nif (dm_digtable.dig_enable_flag == false)\r\nreturn;\r\nif (dm_digtable.dig_algorithm == DIG_ALGO_BY_FALSE_ALARM)\r\n_rtl92e_dm_ctrl_initgain_byrssi_false_alarm(dev);\r\nelse if (dm_digtable.dig_algorithm == DIG_ALGO_BY_RSSI)\r\n_rtl92e_dm_ctrl_initgain_byrssi_driver(dev);\r\nelse\r\nreturn;\r\n}\r\nstatic void _rtl92e_dm_ctrl_initgain_byrssi_driver(struct net_device *dev)\r\n{\r\nstruct r8192_priv *priv = rtllib_priv(dev);\r\nu8 i;\r\nstatic u8 fw_dig;\r\nif (dm_digtable.dig_enable_flag == false)\r\nreturn;\r\nif (dm_digtable.dig_algorithm_switch)\r\nfw_dig = 0;\r\nif (fw_dig <= 3) {\r\nfor (i = 0; i < 3; i++)\r\nrtl92e_set_bb_reg(dev, UFWP, bMaskByte1, 0x8);\r\nfw_dig++;\r\ndm_digtable.dig_state = DM_STA_DIG_OFF;\r\n}\r\nif (priv->rtllib->state == RTLLIB_LINKED)\r\ndm_digtable.CurSTAConnectState = DIG_STA_CONNECT;\r\nelse\r\ndm_digtable.CurSTAConnectState = DIG_STA_DISCONNECT;\r\ndm_digtable.rssi_val = priv->undecorated_smoothed_pwdb;\r\n_rtl92e_dm_initial_gain(dev);\r\n_rtl92e_dm_pd_th(dev);\r\n_rtl92e_dm_cs_ratio(dev);\r\nif (dm_digtable.dig_algorithm_switch)\r\ndm_digtable.dig_algorithm_switch = 0;\r\ndm_digtable.PreSTAConnectState = dm_digtable.CurSTAConnectState;\r\n}\r\nstatic void _rtl92e_dm_ctrl_initgain_byrssi_false_alarm(struct net_device *dev)\r\n{\r\nstruct r8192_priv *priv = rtllib_priv(dev);\r\nstatic u32 reset_cnt;\r\nu8 i;\r\nif (dm_digtable.dig_enable_flag == false)\r\nreturn;\r\nif (dm_digtable.dig_algorithm_switch) {\r\ndm_digtable.dig_state = DM_STA_DIG_MAX;\r\nfor (i = 0; i < 3; i++)\r\nrtl92e_set_bb_reg(dev, UFWP, bMaskByte1, 0x1);\r\ndm_digtable.dig_algorithm_switch = 0;\r\n}\r\nif (priv->rtllib->state != RTLLIB_LINKED)\r\nreturn;\r\nif ((priv->undecorated_smoothed_pwdb > dm_digtable.rssi_low_thresh) &&\r\n(priv->undecorated_smoothed_pwdb < dm_digtable.rssi_high_thresh))\r\nreturn;\r\nif (priv->undecorated_smoothed_pwdb <= dm_digtable.rssi_low_thresh) {\r\nif (dm_digtable.dig_state == DM_STA_DIG_OFF &&\r\n(priv->reset_count == reset_cnt))\r\nreturn;\r\nreset_cnt = priv->reset_count;\r\ndm_digtable.dig_highpwr_state = DM_STA_DIG_MAX;\r\ndm_digtable.dig_state = DM_STA_DIG_OFF;\r\nrtl92e_set_bb_reg(dev, UFWP, bMaskByte1, 0x8);\r\nrtl92e_writeb(dev, rOFDM0_XAAGCCore1, 0x17);\r\nrtl92e_writeb(dev, rOFDM0_XBAGCCore1, 0x17);\r\nrtl92e_writeb(dev, rOFDM0_XCAGCCore1, 0x17);\r\nrtl92e_writeb(dev, rOFDM0_XDAGCCore1, 0x17);\r\nif (priv->CurrentChannelBW != HT_CHANNEL_WIDTH_20)\r\nrtl92e_writeb(dev, (rOFDM0_XATxAFE+3), 0x00);\r\nelse\r\nrtl92e_writeb(dev, rOFDM0_RxDetector1, 0x42);\r\nrtl92e_writeb(dev, 0xa0a, 0x08);\r\nreturn;\r\n}\r\nif (priv->undecorated_smoothed_pwdb >= dm_digtable.rssi_high_thresh) {\r\nu8 reset_flag = 0;\r\nif (dm_digtable.dig_state == DM_STA_DIG_ON &&\r\n(priv->reset_count == reset_cnt)) {\r\n_rtl92e_dm_ctrl_initgain_byrssi_highpwr(dev);\r\nreturn;\r\n}\r\nif (priv->reset_count != reset_cnt)\r\nreset_flag = 1;\r\nreset_cnt = priv->reset_count;\r\ndm_digtable.dig_state = DM_STA_DIG_ON;\r\nif (reset_flag == 1) {\r\nrtl92e_writeb(dev, rOFDM0_XAAGCCore1, 0x2c);\r\nrtl92e_writeb(dev, rOFDM0_XBAGCCore1, 0x2c);\r\nrtl92e_writeb(dev, rOFDM0_XCAGCCore1, 0x2c);\r\nrtl92e_writeb(dev, rOFDM0_XDAGCCore1, 0x2c);\r\n} else {\r\nrtl92e_writeb(dev, rOFDM0_XAAGCCore1, 0x20);\r\nrtl92e_writeb(dev, rOFDM0_XBAGCCore1, 0x20);\r\nrtl92e_writeb(dev, rOFDM0_XCAGCCore1, 0x20);\r\nrtl92e_writeb(dev, rOFDM0_XDAGCCore1, 0x20);\r\n}\r\nif (priv->CurrentChannelBW != HT_CHANNEL_WIDTH_20)\r\nrtl92e_writeb(dev, (rOFDM0_XATxAFE+3), 0x20);\r\nelse\r\nrtl92e_writeb(dev, rOFDM0_RxDetector1, 0x44);\r\nrtl92e_writeb(dev, 0xa0a, 0xcd);\r\nrtl92e_set_bb_reg(dev, UFWP, bMaskByte1, 0x1);\r\n}\r\n_rtl92e_dm_ctrl_initgain_byrssi_highpwr(dev);\r\n}\r\nstatic void _rtl92e_dm_ctrl_initgain_byrssi_highpwr(struct net_device *dev)\r\n{\r\nstruct r8192_priv *priv = rtllib_priv(dev);\r\nstatic u32 reset_cnt_highpwr;\r\nif ((priv->undecorated_smoothed_pwdb >\r\ndm_digtable.rssi_high_power_lowthresh) &&\r\n(priv->undecorated_smoothed_pwdb <\r\ndm_digtable.rssi_high_power_highthresh))\r\nreturn;\r\nif (priv->undecorated_smoothed_pwdb >=\r\ndm_digtable.rssi_high_power_highthresh) {\r\nif (dm_digtable.dig_highpwr_state == DM_STA_DIG_ON &&\r\n(priv->reset_count == reset_cnt_highpwr))\r\nreturn;\r\ndm_digtable.dig_highpwr_state = DM_STA_DIG_ON;\r\nif (priv->CurrentChannelBW != HT_CHANNEL_WIDTH_20)\r\nrtl92e_writeb(dev, (rOFDM0_XATxAFE+3), 0x10);\r\nelse\r\nrtl92e_writeb(dev, rOFDM0_RxDetector1, 0x43);\r\n} else {\r\nif (dm_digtable.dig_highpwr_state == DM_STA_DIG_OFF &&\r\n(priv->reset_count == reset_cnt_highpwr))\r\nreturn;\r\ndm_digtable.dig_highpwr_state = DM_STA_DIG_OFF;\r\nif ((priv->undecorated_smoothed_pwdb <\r\ndm_digtable.rssi_high_power_lowthresh) &&\r\n(priv->undecorated_smoothed_pwdb >=\r\ndm_digtable.rssi_high_thresh)) {\r\nif (priv->CurrentChannelBW != HT_CHANNEL_WIDTH_20)\r\nrtl92e_writeb(dev, (rOFDM0_XATxAFE+3), 0x20);\r\nelse\r\nrtl92e_writeb(dev, rOFDM0_RxDetector1, 0x44);\r\n}\r\n}\r\nreset_cnt_highpwr = priv->reset_count;\r\n}\r\nstatic void _rtl92e_dm_initial_gain(struct net_device *dev)\r\n{\r\nstruct r8192_priv *priv = rtllib_priv(dev);\r\nu8 initial_gain = 0;\r\nstatic u8 initialized, force_write;\r\nstatic u32 reset_cnt;\r\nif (dm_digtable.dig_algorithm_switch) {\r\ninitialized = 0;\r\nreset_cnt = 0;\r\n}\r\nif (rtllib_act_scanning(priv->rtllib, true) == true) {\r\nforce_write = 1;\r\nreturn;\r\n}\r\nif (dm_digtable.PreSTAConnectState == dm_digtable.CurSTAConnectState) {\r\nif (dm_digtable.CurSTAConnectState == DIG_STA_CONNECT) {\r\nlong gain_range = dm_digtable.rssi_val + 10 -\r\ndm_digtable.backoff_val;\r\ngain_range = clamp_t(long, gain_range,\r\ndm_digtable.rx_gain_range_min,\r\ndm_digtable.rx_gain_range_max);\r\ndm_digtable.cur_ig_value = gain_range;\r\n} else {\r\nif (dm_digtable.cur_ig_value == 0)\r\ndm_digtable.cur_ig_value = priv->DefaultInitialGain[0];\r\nelse\r\ndm_digtable.cur_ig_value = dm_digtable.pre_ig_value;\r\n}\r\n} else {\r\ndm_digtable.cur_ig_value = priv->DefaultInitialGain[0];\r\ndm_digtable.pre_ig_value = 0;\r\n}\r\nif (priv->reset_count != reset_cnt) {\r\nforce_write = 1;\r\nreset_cnt = priv->reset_count;\r\n}\r\nif (dm_digtable.pre_ig_value != rtl92e_readb(dev, rOFDM0_XAAGCCore1))\r\nforce_write = 1;\r\nif ((dm_digtable.pre_ig_value != dm_digtable.cur_ig_value)\r\n|| !initialized || force_write) {\r\ninitial_gain = (u8)dm_digtable.cur_ig_value;\r\nrtl92e_writeb(dev, rOFDM0_XAAGCCore1, initial_gain);\r\nrtl92e_writeb(dev, rOFDM0_XBAGCCore1, initial_gain);\r\nrtl92e_writeb(dev, rOFDM0_XCAGCCore1, initial_gain);\r\nrtl92e_writeb(dev, rOFDM0_XDAGCCore1, initial_gain);\r\ndm_digtable.pre_ig_value = dm_digtable.cur_ig_value;\r\ninitialized = 1;\r\nforce_write = 0;\r\n}\r\n}\r\nstatic void _rtl92e_dm_pd_th(struct net_device *dev)\r\n{\r\nstruct r8192_priv *priv = rtllib_priv(dev);\r\nstatic u8 initialized, force_write;\r\nstatic u32 reset_cnt;\r\nif (dm_digtable.dig_algorithm_switch) {\r\ninitialized = 0;\r\nreset_cnt = 0;\r\n}\r\nif (dm_digtable.PreSTAConnectState == dm_digtable.CurSTAConnectState) {\r\nif (dm_digtable.CurSTAConnectState == DIG_STA_CONNECT) {\r\nif (dm_digtable.rssi_val >=\r\ndm_digtable.rssi_high_power_highthresh)\r\ndm_digtable.curpd_thstate =\r\nDIG_PD_AT_HIGH_POWER;\r\nelse if (dm_digtable.rssi_val <=\r\ndm_digtable.rssi_low_thresh)\r\ndm_digtable.curpd_thstate =\r\nDIG_PD_AT_LOW_POWER;\r\nelse if ((dm_digtable.rssi_val >=\r\ndm_digtable.rssi_high_thresh) &&\r\n(dm_digtable.rssi_val <\r\ndm_digtable.rssi_high_power_lowthresh))\r\ndm_digtable.curpd_thstate =\r\nDIG_PD_AT_NORMAL_POWER;\r\nelse\r\ndm_digtable.curpd_thstate =\r\ndm_digtable.prepd_thstate;\r\n} else {\r\ndm_digtable.curpd_thstate = DIG_PD_AT_LOW_POWER;\r\n}\r\n} else {\r\ndm_digtable.curpd_thstate = DIG_PD_AT_LOW_POWER;\r\n}\r\nif (priv->reset_count != reset_cnt) {\r\nforce_write = 1;\r\nreset_cnt = priv->reset_count;\r\n}\r\nif ((dm_digtable.prepd_thstate != dm_digtable.curpd_thstate) ||\r\n(initialized <= 3) || force_write) {\r\nif (dm_digtable.curpd_thstate == DIG_PD_AT_LOW_POWER) {\r\nif (priv->CurrentChannelBW != HT_CHANNEL_WIDTH_20)\r\nrtl92e_writeb(dev, (rOFDM0_XATxAFE+3), 0x00);\r\nelse\r\nrtl92e_writeb(dev, rOFDM0_RxDetector1, 0x42);\r\n} else if (dm_digtable.curpd_thstate ==\r\nDIG_PD_AT_NORMAL_POWER) {\r\nif (priv->CurrentChannelBW != HT_CHANNEL_WIDTH_20)\r\nrtl92e_writeb(dev, (rOFDM0_XATxAFE+3), 0x20);\r\nelse\r\nrtl92e_writeb(dev, rOFDM0_RxDetector1, 0x44);\r\n} else if (dm_digtable.curpd_thstate == DIG_PD_AT_HIGH_POWER) {\r\nif (priv->CurrentChannelBW != HT_CHANNEL_WIDTH_20)\r\nrtl92e_writeb(dev, (rOFDM0_XATxAFE+3), 0x10);\r\nelse\r\nrtl92e_writeb(dev, rOFDM0_RxDetector1, 0x43);\r\n}\r\ndm_digtable.prepd_thstate = dm_digtable.curpd_thstate;\r\nif (initialized <= 3)\r\ninitialized++;\r\nforce_write = 0;\r\n}\r\n}\r\nstatic void _rtl92e_dm_cs_ratio(struct net_device *dev)\r\n{\r\nstruct r8192_priv *priv = rtllib_priv(dev);\r\nstatic u8 initialized, force_write;\r\nstatic u32 reset_cnt;\r\nif (dm_digtable.dig_algorithm_switch) {\r\ninitialized = 0;\r\nreset_cnt = 0;\r\n}\r\nif (dm_digtable.PreSTAConnectState == dm_digtable.CurSTAConnectState) {\r\nif (dm_digtable.CurSTAConnectState == DIG_STA_CONNECT) {\r\nif (dm_digtable.rssi_val <= dm_digtable.rssi_low_thresh)\r\ndm_digtable.curcs_ratio_state = DIG_CS_RATIO_LOWER;\r\nelse if (dm_digtable.rssi_val >= dm_digtable.rssi_high_thresh)\r\ndm_digtable.curcs_ratio_state = DIG_CS_RATIO_HIGHER;\r\nelse\r\ndm_digtable.curcs_ratio_state = dm_digtable.precs_ratio_state;\r\n} else {\r\ndm_digtable.curcs_ratio_state = DIG_CS_RATIO_LOWER;\r\n}\r\n} else {\r\ndm_digtable.curcs_ratio_state = DIG_CS_RATIO_LOWER;\r\n}\r\nif (priv->reset_count != reset_cnt) {\r\nforce_write = 1;\r\nreset_cnt = priv->reset_count;\r\n}\r\nif ((dm_digtable.precs_ratio_state != dm_digtable.curcs_ratio_state) ||\r\n!initialized || force_write) {\r\nif (dm_digtable.curcs_ratio_state == DIG_CS_RATIO_LOWER)\r\nrtl92e_writeb(dev, 0xa0a, 0x08);\r\nelse if (dm_digtable.curcs_ratio_state == DIG_CS_RATIO_HIGHER)\r\nrtl92e_writeb(dev, 0xa0a, 0xcd);\r\ndm_digtable.precs_ratio_state = dm_digtable.curcs_ratio_state;\r\ninitialized = 1;\r\nforce_write = 0;\r\n}\r\n}\r\nvoid rtl92e_dm_init_edca_turbo(struct net_device *dev)\r\n{\r\nstruct r8192_priv *priv = rtllib_priv(dev);\r\npriv->bcurrent_turbo_EDCA = false;\r\npriv->rtllib->bis_any_nonbepkts = false;\r\npriv->bis_cur_rdlstate = false;\r\n}\r\nstatic void _rtl92e_dm_check_edca_turbo(struct net_device *dev)\r\n{\r\nstruct r8192_priv *priv = rtllib_priv(dev);\r\nstruct rt_hi_throughput *pHTInfo = priv->rtllib->pHTInfo;\r\nstatic unsigned long lastTxOkCnt;\r\nstatic unsigned long lastRxOkCnt;\r\nunsigned long curTxOkCnt = 0;\r\nunsigned long curRxOkCnt = 0;\r\nif (priv->rtllib->iw_mode == IW_MODE_ADHOC)\r\ngoto dm_CheckEdcaTurbo_EXIT;\r\nif (priv->rtllib->state != RTLLIB_LINKED)\r\ngoto dm_CheckEdcaTurbo_EXIT;\r\nif (priv->rtllib->pHTInfo->IOTAction & HT_IOT_ACT_DISABLE_EDCA_TURBO)\r\ngoto dm_CheckEdcaTurbo_EXIT;\r\n{\r\nu8 *peername[11] = {\r\n"unknown", "realtek_90", "realtek_92se", "broadcom",\r\n"ralink", "atheros", "cisco", "marvell", "92u_softap",\r\n"self_softap"\r\n};\r\nstatic int wb_tmp;\r\nif (wb_tmp == 0) {\r\nnetdev_info(dev,\r\n"%s():iot peer is %s, bssid: %pM\n",\r\n__func__, peername[pHTInfo->IOTPeer],\r\npriv->rtllib->current_network.bssid);\r\nwb_tmp = 1;\r\n}\r\n}\r\nif (!priv->rtllib->bis_any_nonbepkts) {\r\ncurTxOkCnt = priv->stats.txbytesunicast - lastTxOkCnt;\r\ncurRxOkCnt = priv->stats.rxbytesunicast - lastRxOkCnt;\r\nif (pHTInfo->IOTAction & HT_IOT_ACT_EDCA_BIAS_ON_RX) {\r\nif (curTxOkCnt > 4*curRxOkCnt) {\r\nif (priv->bis_cur_rdlstate ||\r\n!priv->bcurrent_turbo_EDCA) {\r\nrtl92e_writel(dev, EDCAPARA_BE,\r\nedca_setting_UL[pHTInfo->IOTPeer]);\r\npriv->bis_cur_rdlstate = false;\r\n}\r\n} else {\r\nif (!priv->bis_cur_rdlstate ||\r\n!priv->bcurrent_turbo_EDCA) {\r\nif (priv->rtllib->mode == WIRELESS_MODE_G)\r\nrtl92e_writel(dev, EDCAPARA_BE,\r\nedca_setting_DL_GMode[pHTInfo->IOTPeer]);\r\nelse\r\nrtl92e_writel(dev, EDCAPARA_BE,\r\nedca_setting_DL[pHTInfo->IOTPeer]);\r\npriv->bis_cur_rdlstate = true;\r\n}\r\n}\r\npriv->bcurrent_turbo_EDCA = true;\r\n} else {\r\nif (curRxOkCnt > 4*curTxOkCnt) {\r\nif (!priv->bis_cur_rdlstate ||\r\n!priv->bcurrent_turbo_EDCA) {\r\nif (priv->rtllib->mode == WIRELESS_MODE_G)\r\nrtl92e_writel(dev, EDCAPARA_BE,\r\nedca_setting_DL_GMode[pHTInfo->IOTPeer]);\r\nelse\r\nrtl92e_writel(dev, EDCAPARA_BE,\r\nedca_setting_DL[pHTInfo->IOTPeer]);\r\npriv->bis_cur_rdlstate = true;\r\n}\r\n} else {\r\nif (priv->bis_cur_rdlstate ||\r\n!priv->bcurrent_turbo_EDCA) {\r\nrtl92e_writel(dev, EDCAPARA_BE,\r\nedca_setting_UL[pHTInfo->IOTPeer]);\r\npriv->bis_cur_rdlstate = false;\r\n}\r\n}\r\npriv->bcurrent_turbo_EDCA = true;\r\n}\r\n} else {\r\nif (priv->bcurrent_turbo_EDCA) {\r\nu8 tmp = AC0_BE;\r\npriv->rtllib->SetHwRegHandler(dev, HW_VAR_AC_PARAM,\r\n(u8 *)(&tmp));\r\npriv->bcurrent_turbo_EDCA = false;\r\n}\r\n}\r\ndm_CheckEdcaTurbo_EXIT:\r\npriv->rtllib->bis_any_nonbepkts = false;\r\nlastTxOkCnt = priv->stats.txbytesunicast;\r\nlastRxOkCnt = priv->stats.rxbytesunicast;\r\n}\r\nstatic void _rtl92e_dm_init_cts_to_self(struct net_device *dev)\r\n{\r\nstruct r8192_priv *priv = rtllib_priv((struct net_device *)dev);\r\npriv->rtllib->bCTSToSelfEnable = true;\r\n}\r\nstatic void _rtl92e_dm_cts_to_self(struct net_device *dev)\r\n{\r\nstruct r8192_priv *priv = rtllib_priv((struct net_device *)dev);\r\nstruct rt_hi_throughput *pHTInfo = priv->rtllib->pHTInfo;\r\nstatic unsigned long lastTxOkCnt;\r\nstatic unsigned long lastRxOkCnt;\r\nunsigned long curTxOkCnt = 0;\r\nunsigned long curRxOkCnt = 0;\r\nif (priv->rtllib->bCTSToSelfEnable != true) {\r\npHTInfo->IOTAction &= ~HT_IOT_ACT_FORCED_CTS2SELF;\r\nreturn;\r\n}\r\nif (pHTInfo->IOTPeer == HT_IOT_PEER_BROADCOM) {\r\ncurTxOkCnt = priv->stats.txbytesunicast - lastTxOkCnt;\r\ncurRxOkCnt = priv->stats.rxbytesunicast - lastRxOkCnt;\r\nif (curRxOkCnt > 4*curTxOkCnt)\r\npHTInfo->IOTAction &= ~HT_IOT_ACT_FORCED_CTS2SELF;\r\nelse\r\npHTInfo->IOTAction |= HT_IOT_ACT_FORCED_CTS2SELF;\r\nlastTxOkCnt = priv->stats.txbytesunicast;\r\nlastRxOkCnt = priv->stats.rxbytesunicast;\r\n}\r\n}\r\nstatic void _rtl92e_dm_init_wa_broadcom_iot(struct net_device *dev)\r\n{\r\nstruct r8192_priv *priv = rtllib_priv((struct net_device *)dev);\r\nstruct rt_hi_throughput *pHTInfo = priv->rtllib->pHTInfo;\r\npHTInfo->bWAIotBroadcom = false;\r\npHTInfo->WAIotTH = WAIotTHVal;\r\n}\r\nstatic void _rtl92e_dm_check_rf_ctrl_gpio(void *data)\r\n{\r\nstruct r8192_priv *priv = container_of_dwork_rsl(data,\r\nstruct r8192_priv, gpio_change_rf_wq);\r\nstruct net_device *dev = priv->rtllib->dev;\r\nu8 tmp1byte;\r\nenum rt_rf_power_state eRfPowerStateToSet;\r\nbool bActuallySet = false;\r\nchar *argv[3];\r\nstatic char *RadioPowerPath = "/etc/acpi/events/RadioPower.sh";\r\nstatic char *envp[] = {"HOME=/", "TERM=linux", "PATH=/usr/bin:/bin",\r\nNULL};\r\nbActuallySet = false;\r\nif ((priv->up_first_time == 1) || (priv->being_init_adapter))\r\nreturn;\r\nif (priv->bfirst_after_down) {\r\npriv->bfirst_after_down = true;\r\nreturn;\r\n}\r\ntmp1byte = rtl92e_readb(dev, GPI);\r\neRfPowerStateToSet = (tmp1byte&BIT1) ? eRfOn : eRfOff;\r\nif (priv->bHwRadioOff && (eRfPowerStateToSet == eRfOn)) {\r\nRT_TRACE(COMP_RF, "gpiochangeRF - HW Radio ON\n");\r\nnetdev_info(dev, "gpiochangeRF - HW Radio ON\n");\r\npriv->bHwRadioOff = false;\r\nbActuallySet = true;\r\n} else if (!priv->bHwRadioOff && (eRfPowerStateToSet == eRfOff)) {\r\nRT_TRACE(COMP_RF, "gpiochangeRF - HW Radio OFF\n");\r\nnetdev_info(dev, "gpiochangeRF - HW Radio OFF\n");\r\npriv->bHwRadioOff = true;\r\nbActuallySet = true;\r\n}\r\nif (bActuallySet) {\r\nmdelay(1000);\r\npriv->bHwRfOffAction = 1;\r\nrtl92e_set_rf_state(dev, eRfPowerStateToSet, RF_CHANGE_BY_HW);\r\nif (priv->bHwRadioOff)\r\nargv[1] = "RFOFF";\r\nelse\r\nargv[1] = "RFON";\r\nargv[0] = RadioPowerPath;\r\nargv[2] = NULL;\r\ncall_usermodehelper(RadioPowerPath, argv, envp, UMH_WAIT_PROC);\r\n}\r\n}\r\nvoid rtl92e_dm_rf_pathcheck_wq(void *data)\r\n{\r\nstruct r8192_priv *priv = container_of_dwork_rsl(data,\r\nstruct r8192_priv,\r\nrfpath_check_wq);\r\nstruct net_device *dev = priv->rtllib->dev;\r\nu8 rfpath, i;\r\nrfpath = rtl92e_readb(dev, 0xc04);\r\nfor (i = 0; i < RF90_PATH_MAX; i++) {\r\nif (rfpath & (0x01<<i))\r\npriv->brfpath_rxenable[i] = true;\r\nelse\r\npriv->brfpath_rxenable[i] = false;\r\n}\r\nif (!DM_RxPathSelTable.Enable)\r\nreturn;\r\n_rtl92e_dm_rx_path_sel_byrssi(dev);\r\n}\r\nstatic void _rtl92e_dm_init_rx_path_selection(struct net_device *dev)\r\n{\r\nu8 i;\r\nstruct r8192_priv *priv = rtllib_priv(dev);\r\nDM_RxPathSelTable.Enable = 1;\r\nDM_RxPathSelTable.SS_TH_low = RxPathSelection_SS_TH_low;\r\nDM_RxPathSelTable.diff_TH = RxPathSelection_diff_TH;\r\nif (priv->CustomerID == RT_CID_819x_Netcore)\r\nDM_RxPathSelTable.cck_method = CCK_Rx_Version_2;\r\nelse\r\nDM_RxPathSelTable.cck_method = CCK_Rx_Version_1;\r\nDM_RxPathSelTable.disabledRF = 0;\r\nfor (i = 0; i < 4; i++) {\r\nDM_RxPathSelTable.rf_rssi[i] = 50;\r\nDM_RxPathSelTable.cck_pwdb_sta[i] = -64;\r\nDM_RxPathSelTable.rf_enable_rssi_th[i] = 100;\r\n}\r\n}\r\nstatic void _rtl92e_dm_rx_path_sel_byrssi(struct net_device *dev)\r\n{\r\nstruct r8192_priv *priv = rtllib_priv(dev);\r\nu8 i, max_rssi_index = 0, min_rssi_index = 0;\r\nu8 sec_rssi_index = 0, rf_num = 0;\r\nu8 tmp_max_rssi = 0, tmp_min_rssi = 0, tmp_sec_rssi = 0;\r\nu8 cck_default_Rx = 0x2;\r\nu8 cck_optional_Rx = 0x3;\r\nlong tmp_cck_max_pwdb = 0, tmp_cck_min_pwdb = 0, tmp_cck_sec_pwdb = 0;\r\nu8 cck_rx_ver2_max_index = 0, cck_rx_ver2_min_index = 0;\r\nu8 cck_rx_ver2_sec_index = 0;\r\nu8 cur_rf_rssi;\r\nlong cur_cck_pwdb;\r\nstatic u8 disabled_rf_cnt, cck_Rx_Path_initialized;\r\nu8 update_cck_rx_path;\r\nif (priv->rf_type != RF_2T4R)\r\nreturn;\r\nif (!cck_Rx_Path_initialized) {\r\nDM_RxPathSelTable.cck_Rx_path = (rtl92e_readb(dev, 0xa07)&0xf);\r\ncck_Rx_Path_initialized = 1;\r\n}\r\nDM_RxPathSelTable.disabledRF = 0xf;\r\nDM_RxPathSelTable.disabledRF &= ~(rtl92e_readb(dev, 0xc04));\r\nif (priv->rtllib->mode == WIRELESS_MODE_B)\r\nDM_RxPathSelTable.cck_method = CCK_Rx_Version_2;\r\nfor (i = 0; i < RF90_PATH_MAX; i++) {\r\nDM_RxPathSelTable.rf_rssi[i] = priv->stats.rx_rssi_percentage[i];\r\nif (priv->brfpath_rxenable[i]) {\r\nrf_num++;\r\ncur_rf_rssi = DM_RxPathSelTable.rf_rssi[i];\r\nif (rf_num == 1) {\r\nmax_rssi_index = min_rssi_index = sec_rssi_index = i;\r\ntmp_max_rssi = tmp_min_rssi = tmp_sec_rssi = cur_rf_rssi;\r\n} else if (rf_num == 2) {\r\nif (cur_rf_rssi >= tmp_max_rssi) {\r\ntmp_max_rssi = cur_rf_rssi;\r\nmax_rssi_index = i;\r\n} else {\r\ntmp_sec_rssi = tmp_min_rssi = cur_rf_rssi;\r\nsec_rssi_index = min_rssi_index = i;\r\n}\r\n} else {\r\nif (cur_rf_rssi > tmp_max_rssi) {\r\ntmp_sec_rssi = tmp_max_rssi;\r\nsec_rssi_index = max_rssi_index;\r\ntmp_max_rssi = cur_rf_rssi;\r\nmax_rssi_index = i;\r\n} else if (cur_rf_rssi == tmp_max_rssi) {\r\ntmp_sec_rssi = cur_rf_rssi;\r\nsec_rssi_index = i;\r\n} else if ((cur_rf_rssi < tmp_max_rssi) &&\r\n(cur_rf_rssi > tmp_sec_rssi)) {\r\ntmp_sec_rssi = cur_rf_rssi;\r\nsec_rssi_index = i;\r\n} else if (cur_rf_rssi == tmp_sec_rssi) {\r\nif (tmp_sec_rssi == tmp_min_rssi) {\r\ntmp_sec_rssi = cur_rf_rssi;\r\nsec_rssi_index = i;\r\n}\r\n} else if ((cur_rf_rssi < tmp_sec_rssi) &&\r\n(cur_rf_rssi > tmp_min_rssi)) {\r\n;\r\n} else if (cur_rf_rssi == tmp_min_rssi) {\r\nif (tmp_sec_rssi == tmp_min_rssi) {\r\ntmp_min_rssi = cur_rf_rssi;\r\nmin_rssi_index = i;\r\n}\r\n} else if (cur_rf_rssi < tmp_min_rssi) {\r\ntmp_min_rssi = cur_rf_rssi;\r\nmin_rssi_index = i;\r\n}\r\n}\r\n}\r\n}\r\nrf_num = 0;\r\nif (DM_RxPathSelTable.cck_method == CCK_Rx_Version_2) {\r\nfor (i = 0; i < RF90_PATH_MAX; i++) {\r\nif (priv->brfpath_rxenable[i]) {\r\nrf_num++;\r\ncur_cck_pwdb =\r\nDM_RxPathSelTable.cck_pwdb_sta[i];\r\nif (rf_num == 1) {\r\ncck_rx_ver2_max_index = i;\r\ncck_rx_ver2_min_index = i;\r\ncck_rx_ver2_sec_index = i;\r\ntmp_cck_max_pwdb = cur_cck_pwdb;\r\ntmp_cck_min_pwdb = cur_cck_pwdb;\r\ntmp_cck_sec_pwdb = cur_cck_pwdb;\r\n} else if (rf_num == 2) {\r\nif (cur_cck_pwdb >= tmp_cck_max_pwdb) {\r\ntmp_cck_max_pwdb = cur_cck_pwdb;\r\ncck_rx_ver2_max_index = i;\r\n} else {\r\ntmp_cck_sec_pwdb = cur_cck_pwdb;\r\ntmp_cck_min_pwdb = cur_cck_pwdb;\r\ncck_rx_ver2_sec_index = i;\r\ncck_rx_ver2_min_index = i;\r\n}\r\n} else {\r\nif (cur_cck_pwdb > tmp_cck_max_pwdb) {\r\ntmp_cck_sec_pwdb =\r\ntmp_cck_max_pwdb;\r\ncck_rx_ver2_sec_index =\r\ncck_rx_ver2_max_index;\r\ntmp_cck_max_pwdb = cur_cck_pwdb;\r\ncck_rx_ver2_max_index = i;\r\n} else if (cur_cck_pwdb ==\r\ntmp_cck_max_pwdb) {\r\ntmp_cck_sec_pwdb = cur_cck_pwdb;\r\ncck_rx_ver2_sec_index = i;\r\n} else if (PWDB_IN_RANGE) {\r\ntmp_cck_sec_pwdb = cur_cck_pwdb;\r\ncck_rx_ver2_sec_index = i;\r\n} else if (cur_cck_pwdb ==\r\ntmp_cck_sec_pwdb) {\r\nif (tmp_cck_sec_pwdb ==\r\ntmp_cck_min_pwdb) {\r\ntmp_cck_sec_pwdb =\r\ncur_cck_pwdb;\r\ncck_rx_ver2_sec_index =\r\ni;\r\n}\r\n} else if ((cur_cck_pwdb < tmp_cck_sec_pwdb) &&\r\n(cur_cck_pwdb > tmp_cck_min_pwdb)) {\r\n;\r\n} else if (cur_cck_pwdb == tmp_cck_min_pwdb) {\r\nif (tmp_cck_sec_pwdb == tmp_cck_min_pwdb) {\r\ntmp_cck_min_pwdb = cur_cck_pwdb;\r\ncck_rx_ver2_min_index = i;\r\n}\r\n} else if (cur_cck_pwdb < tmp_cck_min_pwdb) {\r\ntmp_cck_min_pwdb = cur_cck_pwdb;\r\ncck_rx_ver2_min_index = i;\r\n}\r\n}\r\n}\r\n}\r\n}\r\nupdate_cck_rx_path = 0;\r\nif (DM_RxPathSelTable.cck_method == CCK_Rx_Version_2) {\r\ncck_default_Rx = cck_rx_ver2_max_index;\r\ncck_optional_Rx = cck_rx_ver2_sec_index;\r\nif (tmp_cck_max_pwdb != -64)\r\nupdate_cck_rx_path = 1;\r\n}\r\nif (tmp_min_rssi < DM_RxPathSelTable.SS_TH_low && disabled_rf_cnt < 2) {\r\nif ((tmp_max_rssi - tmp_min_rssi) >=\r\nDM_RxPathSelTable.diff_TH) {\r\nDM_RxPathSelTable.rf_enable_rssi_th[min_rssi_index] =\r\ntmp_max_rssi+5;\r\nrtl92e_set_bb_reg(dev, rOFDM0_TRxPathEnable,\r\n0x1<<min_rssi_index, 0x0);\r\nrtl92e_set_bb_reg(dev, rOFDM1_TRxPathEnable,\r\n0x1<<min_rssi_index, 0x0);\r\ndisabled_rf_cnt++;\r\n}\r\nif (DM_RxPathSelTable.cck_method == CCK_Rx_Version_1) {\r\ncck_default_Rx = max_rssi_index;\r\ncck_optional_Rx = sec_rssi_index;\r\nif (tmp_max_rssi)\r\nupdate_cck_rx_path = 1;\r\n}\r\n}\r\nif (update_cck_rx_path) {\r\nDM_RxPathSelTable.cck_Rx_path = (cck_default_Rx<<2) |\r\n(cck_optional_Rx);\r\nrtl92e_set_bb_reg(dev, rCCK0_AFESetting, 0x0f000000,\r\nDM_RxPathSelTable.cck_Rx_path);\r\n}\r\nif (DM_RxPathSelTable.disabledRF) {\r\nfor (i = 0; i < 4; i++) {\r\nif ((DM_RxPathSelTable.disabledRF>>i) & 0x1) {\r\nif (tmp_max_rssi >=\r\nDM_RxPathSelTable.rf_enable_rssi_th[i]) {\r\nrtl92e_set_bb_reg(dev,\r\nrOFDM0_TRxPathEnable,\r\n0x1 << i, 0x1);\r\nrtl92e_set_bb_reg(dev,\r\nrOFDM1_TRxPathEnable,\r\n0x1 << i, 0x1);\r\nDM_RxPathSelTable.rf_enable_rssi_th[i]\r\n= 100;\r\ndisabled_rf_cnt--;\r\n}\r\n}\r\n}\r\n}\r\n}\r\nstatic void _rtl92e_dm_check_rx_path_selection(struct net_device *dev)\r\n{\r\nstruct r8192_priv *priv = rtllib_priv(dev);\r\nschedule_delayed_work(&priv->rfpath_check_wq, 0);\r\n}\r\nstatic void _rtl92e_dm_init_fsync(struct net_device *dev)\r\n{\r\nstruct r8192_priv *priv = rtllib_priv(dev);\r\npriv->rtllib->fsync_time_interval = 500;\r\npriv->rtllib->fsync_rate_bitmap = 0x0f000800;\r\npriv->rtllib->fsync_rssi_threshold = 30;\r\npriv->rtllib->bfsync_enable = false;\r\npriv->rtllib->fsync_multiple_timeinterval = 3;\r\npriv->rtllib->fsync_firstdiff_ratethreshold = 100;\r\npriv->rtllib->fsync_seconddiff_ratethreshold = 200;\r\npriv->rtllib->fsync_state = Default_Fsync;\r\npriv->framesyncMonitor = 1;\r\nsetup_timer(&priv->fsync_timer, _rtl92e_dm_fsync_timer_callback,\r\n(unsigned long)dev);\r\n}\r\nstatic void _rtl92e_dm_deinit_fsync(struct net_device *dev)\r\n{\r\nstruct r8192_priv *priv = rtllib_priv(dev);\r\ndel_timer_sync(&priv->fsync_timer);\r\n}\r\nstatic void _rtl92e_dm_fsync_timer_callback(unsigned long data)\r\n{\r\nstruct net_device *dev = (struct net_device *)data;\r\nstruct r8192_priv *priv = rtllib_priv((struct net_device *)data);\r\nu32 rate_index, rate_count = 0, rate_count_diff = 0;\r\nbool bSwitchFromCountDiff = false;\r\nbool bDoubleTimeInterval = false;\r\nif (priv->rtllib->state == RTLLIB_LINKED &&\r\npriv->rtllib->bfsync_enable &&\r\n(priv->rtllib->pHTInfo->IOTAction & HT_IOT_ACT_CDD_FSYNC)) {\r\nu32 rate_bitmap;\r\nfor (rate_index = 0; rate_index <= 27; rate_index++) {\r\nrate_bitmap = 1 << rate_index;\r\nif (priv->rtllib->fsync_rate_bitmap & rate_bitmap)\r\nrate_count +=\r\npriv->stats.received_rate_histogram[1]\r\n[rate_index];\r\n}\r\nif (rate_count < priv->rate_record)\r\nrate_count_diff = 0xffffffff - rate_count +\r\npriv->rate_record;\r\nelse\r\nrate_count_diff = rate_count - priv->rate_record;\r\nif (rate_count_diff < priv->rateCountDiffRecord) {\r\nu32 DiffNum = priv->rateCountDiffRecord -\r\nrate_count_diff;\r\nif (DiffNum >=\r\npriv->rtllib->fsync_seconddiff_ratethreshold)\r\npriv->ContinueDiffCount++;\r\nelse\r\npriv->ContinueDiffCount = 0;\r\nif (priv->ContinueDiffCount >= 2) {\r\nbSwitchFromCountDiff = true;\r\npriv->ContinueDiffCount = 0;\r\n}\r\n} else {\r\npriv->ContinueDiffCount = 0;\r\n}\r\nif (rate_count_diff <=\r\npriv->rtllib->fsync_firstdiff_ratethreshold) {\r\nbSwitchFromCountDiff = true;\r\npriv->ContinueDiffCount = 0;\r\n}\r\npriv->rate_record = rate_count;\r\npriv->rateCountDiffRecord = rate_count_diff;\r\nRT_TRACE(COMP_HALDM,\r\n"rateRecord %d rateCount %d, rateCountdiff %d bSwitchFsync %d\n",\r\npriv->rate_record, rate_count, rate_count_diff,\r\npriv->bswitch_fsync);\r\nif (priv->undecorated_smoothed_pwdb >\r\npriv->rtllib->fsync_rssi_threshold &&\r\nbSwitchFromCountDiff) {\r\nbDoubleTimeInterval = true;\r\npriv->bswitch_fsync = !priv->bswitch_fsync;\r\nif (priv->bswitch_fsync) {\r\nrtl92e_writeb(dev, 0xC36, 0x1c);\r\nrtl92e_writeb(dev, 0xC3e, 0x90);\r\n} else {\r\nrtl92e_writeb(dev, 0xC36, 0x5c);\r\nrtl92e_writeb(dev, 0xC3e, 0x96);\r\n}\r\n} else if (priv->undecorated_smoothed_pwdb <=\r\npriv->rtllib->fsync_rssi_threshold) {\r\nif (priv->bswitch_fsync) {\r\npriv->bswitch_fsync = false;\r\nrtl92e_writeb(dev, 0xC36, 0x5c);\r\nrtl92e_writeb(dev, 0xC3e, 0x96);\r\n}\r\n}\r\nif (bDoubleTimeInterval) {\r\nif (timer_pending(&priv->fsync_timer))\r\ndel_timer_sync(&priv->fsync_timer);\r\npriv->fsync_timer.expires = jiffies +\r\nmsecs_to_jiffies(priv->rtllib->fsync_time_interval *\r\npriv->rtllib->fsync_multiple_timeinterval);\r\nadd_timer(&priv->fsync_timer);\r\n} else {\r\nif (timer_pending(&priv->fsync_timer))\r\ndel_timer_sync(&priv->fsync_timer);\r\npriv->fsync_timer.expires = jiffies +\r\nmsecs_to_jiffies(priv->rtllib->fsync_time_interval);\r\nadd_timer(&priv->fsync_timer);\r\n}\r\n} else {\r\nif (priv->bswitch_fsync) {\r\npriv->bswitch_fsync = false;\r\nrtl92e_writeb(dev, 0xC36, 0x5c);\r\nrtl92e_writeb(dev, 0xC3e, 0x96);\r\n}\r\npriv->ContinueDiffCount = 0;\r\nrtl92e_writel(dev, rOFDM0_RxDetector2, 0x465c52cd);\r\n}\r\nRT_TRACE(COMP_HALDM, "ContinueDiffCount %d\n", priv->ContinueDiffCount);\r\nRT_TRACE(COMP_HALDM,\r\n"rateRecord %d rateCount %d, rateCountdiff %d bSwitchFsync %d\n",\r\npriv->rate_record, rate_count, rate_count_diff,\r\npriv->bswitch_fsync);\r\n}\r\nstatic void _rtl92e_dm_start_hw_fsync(struct net_device *dev)\r\n{\r\nu8 rf_timing = 0x77;\r\nstruct r8192_priv *priv = rtllib_priv(dev);\r\nRT_TRACE(COMP_HALDM, "%s\n", __func__);\r\nrtl92e_writel(dev, rOFDM0_RxDetector2, 0x465c12cf);\r\npriv->rtllib->SetHwRegHandler(dev, HW_VAR_RF_TIMING,\r\n(u8 *)(&rf_timing));\r\nrtl92e_writeb(dev, 0xc3b, 0x41);\r\n}\r\nstatic void _rtl92e_dm_end_hw_fsync(struct net_device *dev)\r\n{\r\nu8 rf_timing = 0xaa;\r\nstruct r8192_priv *priv = rtllib_priv(dev);\r\nRT_TRACE(COMP_HALDM, "%s\n", __func__);\r\nrtl92e_writel(dev, rOFDM0_RxDetector2, 0x465c52cd);\r\npriv->rtllib->SetHwRegHandler(dev, HW_VAR_RF_TIMING, (u8 *)\r\n(&rf_timing));\r\nrtl92e_writeb(dev, 0xc3b, 0x49);\r\n}\r\nstatic void _rtl92e_dm_end_sw_fsync(struct net_device *dev)\r\n{\r\nstruct r8192_priv *priv = rtllib_priv(dev);\r\nRT_TRACE(COMP_HALDM, "%s\n", __func__);\r\ndel_timer_sync(&(priv->fsync_timer));\r\nif (priv->bswitch_fsync) {\r\npriv->bswitch_fsync = false;\r\nrtl92e_writeb(dev, 0xC36, 0x5c);\r\nrtl92e_writeb(dev, 0xC3e, 0x96);\r\n}\r\npriv->ContinueDiffCount = 0;\r\nrtl92e_writel(dev, rOFDM0_RxDetector2, 0x465c52cd);\r\n}\r\nstatic void _rtl92e_dm_start_sw_fsync(struct net_device *dev)\r\n{\r\nstruct r8192_priv *priv = rtllib_priv(dev);\r\nu32 rateIndex;\r\nu32 rateBitmap;\r\nRT_TRACE(COMP_HALDM, "%s\n", __func__);\r\npriv->rate_record = 0;\r\npriv->ContinueDiffCount = 0;\r\npriv->rateCountDiffRecord = 0;\r\npriv->bswitch_fsync = false;\r\nif (priv->rtllib->mode == WIRELESS_MODE_N_24G) {\r\npriv->rtllib->fsync_firstdiff_ratethreshold = 600;\r\npriv->rtllib->fsync_seconddiff_ratethreshold = 0xffff;\r\n} else {\r\npriv->rtllib->fsync_firstdiff_ratethreshold = 200;\r\npriv->rtllib->fsync_seconddiff_ratethreshold = 200;\r\n}\r\nfor (rateIndex = 0; rateIndex <= 27; rateIndex++) {\r\nrateBitmap = 1 << rateIndex;\r\nif (priv->rtllib->fsync_rate_bitmap & rateBitmap)\r\npriv->rate_record +=\r\npriv->stats.received_rate_histogram[1]\r\n[rateIndex];\r\n}\r\nif (timer_pending(&priv->fsync_timer))\r\ndel_timer_sync(&priv->fsync_timer);\r\npriv->fsync_timer.expires = jiffies +\r\nmsecs_to_jiffies(priv->rtllib->fsync_time_interval);\r\nadd_timer(&priv->fsync_timer);\r\nrtl92e_writel(dev, rOFDM0_RxDetector2, 0x465c12cd);\r\n}\r\nstatic void _rtl92e_dm_check_fsync(struct net_device *dev)\r\n{\r\n#define RegC38_Default 0\r\n#define RegC38_NonFsync_Other_AP 1\r\n#define RegC38_Fsync_AP_BCM 2\r\nstruct r8192_priv *priv = rtllib_priv(dev);\r\nstatic u8 reg_c38_State = RegC38_Default;\r\nstatic u32 reset_cnt;\r\nRT_TRACE(COMP_HALDM,\r\n"RSSI %d TimeInterval %d MultipleTimeInterval %d\n",\r\npriv->rtllib->fsync_rssi_threshold,\r\npriv->rtllib->fsync_time_interval,\r\npriv->rtllib->fsync_multiple_timeinterval);\r\nRT_TRACE(COMP_HALDM,\r\n"RateBitmap 0x%x FirstDiffRateThreshold %d SecondDiffRateThreshold %d\n",\r\npriv->rtllib->fsync_rate_bitmap,\r\npriv->rtllib->fsync_firstdiff_ratethreshold,\r\npriv->rtllib->fsync_seconddiff_ratethreshold);\r\nif (priv->rtllib->state == RTLLIB_LINKED &&\r\npriv->rtllib->pHTInfo->IOTPeer == HT_IOT_PEER_BROADCOM) {\r\nif (priv->rtllib->bfsync_enable == 0) {\r\nswitch (priv->rtllib->fsync_state) {\r\ncase Default_Fsync:\r\n_rtl92e_dm_start_hw_fsync(dev);\r\npriv->rtllib->fsync_state = HW_Fsync;\r\nbreak;\r\ncase SW_Fsync:\r\n_rtl92e_dm_end_sw_fsync(dev);\r\n_rtl92e_dm_start_hw_fsync(dev);\r\npriv->rtllib->fsync_state = HW_Fsync;\r\nbreak;\r\ncase HW_Fsync:\r\ndefault:\r\nbreak;\r\n}\r\n} else {\r\nswitch (priv->rtllib->fsync_state) {\r\ncase Default_Fsync:\r\n_rtl92e_dm_start_sw_fsync(dev);\r\npriv->rtllib->fsync_state = SW_Fsync;\r\nbreak;\r\ncase HW_Fsync:\r\n_rtl92e_dm_end_hw_fsync(dev);\r\n_rtl92e_dm_start_sw_fsync(dev);\r\npriv->rtllib->fsync_state = SW_Fsync;\r\nbreak;\r\ncase SW_Fsync:\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nif (priv->framesyncMonitor) {\r\nif (reg_c38_State != RegC38_Fsync_AP_BCM) {\r\nrtl92e_writeb(dev, rOFDM0_RxDetector3, 0x95);\r\nreg_c38_State = RegC38_Fsync_AP_BCM;\r\n}\r\n}\r\n} else {\r\nswitch (priv->rtllib->fsync_state) {\r\ncase HW_Fsync:\r\n_rtl92e_dm_end_hw_fsync(dev);\r\npriv->rtllib->fsync_state = Default_Fsync;\r\nbreak;\r\ncase SW_Fsync:\r\n_rtl92e_dm_end_sw_fsync(dev);\r\npriv->rtllib->fsync_state = Default_Fsync;\r\nbreak;\r\ncase Default_Fsync:\r\ndefault:\r\nbreak;\r\n}\r\nif (priv->framesyncMonitor) {\r\nif (priv->rtllib->state == RTLLIB_LINKED) {\r\nif (priv->undecorated_smoothed_pwdb <=\r\nRegC38_TH) {\r\nif (reg_c38_State !=\r\nRegC38_NonFsync_Other_AP) {\r\nrtl92e_writeb(dev,\r\nrOFDM0_RxDetector3,\r\n0x90);\r\nreg_c38_State =\r\nRegC38_NonFsync_Other_AP;\r\n}\r\n} else if (priv->undecorated_smoothed_pwdb >=\r\n(RegC38_TH+5)) {\r\nif (reg_c38_State) {\r\nrtl92e_writeb(dev,\r\nrOFDM0_RxDetector3,\r\npriv->framesync);\r\nreg_c38_State = RegC38_Default;\r\n}\r\n}\r\n} else {\r\nif (reg_c38_State) {\r\nrtl92e_writeb(dev, rOFDM0_RxDetector3,\r\npriv->framesync);\r\nreg_c38_State = RegC38_Default;\r\n}\r\n}\r\n}\r\n}\r\nif (priv->framesyncMonitor) {\r\nif (priv->reset_count != reset_cnt) {\r\nrtl92e_writeb(dev, rOFDM0_RxDetector3,\r\npriv->framesync);\r\nreg_c38_State = RegC38_Default;\r\nreset_cnt = priv->reset_count;\r\n}\r\n} else {\r\nif (reg_c38_State) {\r\nrtl92e_writeb(dev, rOFDM0_RxDetector3,\r\npriv->framesync);\r\nreg_c38_State = RegC38_Default;\r\n}\r\n}\r\n}\r\nstatic void _rtl92e_dm_init_dynamic_tx_power(struct net_device *dev)\r\n{\r\nstruct r8192_priv *priv = rtllib_priv(dev);\r\npriv->rtllib->bdynamic_txpower_enable = true;\r\npriv->bLastDTPFlag_High = false;\r\npriv->bLastDTPFlag_Low = false;\r\npriv->bDynamicTxHighPower = false;\r\npriv->bDynamicTxLowPower = false;\r\n}\r\nstatic void _rtl92e_dm_dynamic_tx_power(struct net_device *dev)\r\n{\r\nstruct r8192_priv *priv = rtllib_priv(dev);\r\nunsigned int txhipower_threshhold = 0;\r\nunsigned int txlowpower_threshold = 0;\r\nif (priv->rtllib->bdynamic_txpower_enable != true) {\r\npriv->bDynamicTxHighPower = false;\r\npriv->bDynamicTxLowPower = false;\r\nreturn;\r\n}\r\nif ((priv->rtllib->pHTInfo->IOTPeer == HT_IOT_PEER_ATHEROS) &&\r\n(priv->rtllib->mode == IEEE_G)) {\r\ntxhipower_threshhold = TX_POWER_ATHEROAP_THRESH_HIGH;\r\ntxlowpower_threshold = TX_POWER_ATHEROAP_THRESH_LOW;\r\n} else {\r\ntxhipower_threshhold = TX_POWER_NEAR_FIELD_THRESH_HIGH;\r\ntxlowpower_threshold = TX_POWER_NEAR_FIELD_THRESH_LOW;\r\n}\r\nRT_TRACE(COMP_TXAGC, "priv->undecorated_smoothed_pwdb = %ld\n",\r\npriv->undecorated_smoothed_pwdb);\r\nif (priv->rtllib->state == RTLLIB_LINKED) {\r\nif (priv->undecorated_smoothed_pwdb >= txhipower_threshhold) {\r\npriv->bDynamicTxHighPower = true;\r\npriv->bDynamicTxLowPower = false;\r\n} else {\r\nif (priv->undecorated_smoothed_pwdb <\r\ntxlowpower_threshold && priv->bDynamicTxHighPower)\r\npriv->bDynamicTxHighPower = false;\r\nif (priv->undecorated_smoothed_pwdb < 35)\r\npriv->bDynamicTxLowPower = true;\r\nelse if (priv->undecorated_smoothed_pwdb >= 40)\r\npriv->bDynamicTxLowPower = false;\r\n}\r\n} else {\r\npriv->bDynamicTxHighPower = false;\r\npriv->bDynamicTxLowPower = false;\r\n}\r\nif ((priv->bDynamicTxHighPower != priv->bLastDTPFlag_High) ||\r\n(priv->bDynamicTxLowPower != priv->bLastDTPFlag_Low)) {\r\nRT_TRACE(COMP_TXAGC, "SetTxPowerLevel8190() channel = %d\n",\r\npriv->rtllib->current_network.channel);\r\nrtl92e_set_tx_power(dev, priv->rtllib->current_network.channel);\r\n}\r\npriv->bLastDTPFlag_High = priv->bDynamicTxHighPower;\r\npriv->bLastDTPFlag_Low = priv->bDynamicTxLowPower;\r\n}\r\nstatic void _rtl92e_dm_check_txrateandretrycount(struct net_device *dev)\r\n{\r\nstruct r8192_priv *priv = rtllib_priv(dev);\r\nstruct rtllib_device *ieee = priv->rtllib;\r\nieee->softmac_stats.CurrentShowTxate = rtl92e_readb(dev,\r\nCurrent_Tx_Rate_Reg);\r\nieee->softmac_stats.last_packet_rate = rtl92e_readb(dev,\r\nInitial_Tx_Rate_Reg);\r\nieee->softmac_stats.txretrycount = rtl92e_readl(dev,\r\nTx_Retry_Count_Reg);\r\n}\r\nstatic void _rtl92e_dm_send_rssi_to_fw(struct net_device *dev)\r\n{\r\nstruct r8192_priv *priv = rtllib_priv(dev);\r\nrtl92e_writeb(dev, DRIVER_RSSI, (u8)priv->undecorated_smoothed_pwdb);\r\n}
