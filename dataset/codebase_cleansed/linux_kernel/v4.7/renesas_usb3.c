static void usb3_write(struct renesas_usb3 *usb3, u32 data, u32 offs)\r\n{\r\niowrite32(data, usb3->reg + offs);\r\n}\r\nstatic u32 usb3_read(struct renesas_usb3 *usb3, u32 offs)\r\n{\r\nreturn ioread32(usb3->reg + offs);\r\n}\r\nstatic void usb3_set_bit(struct renesas_usb3 *usb3, u32 bits, u32 offs)\r\n{\r\nu32 val = usb3_read(usb3, offs);\r\nval |= bits;\r\nusb3_write(usb3, val, offs);\r\n}\r\nstatic void usb3_clear_bit(struct renesas_usb3 *usb3, u32 bits, u32 offs)\r\n{\r\nu32 val = usb3_read(usb3, offs);\r\nval &= ~bits;\r\nusb3_write(usb3, val, offs);\r\n}\r\nstatic int usb3_wait(struct renesas_usb3 *usb3, u32 reg, u32 mask,\r\nu32 expected)\r\n{\r\nint i;\r\nfor (i = 0; i < USB3_WAIT_US; i++) {\r\nif ((usb3_read(usb3, reg) & mask) == expected)\r\nreturn 0;\r\nudelay(1);\r\n}\r\ndev_dbg(usb3_to_dev(usb3), "%s: timed out (%8x, %08x, %08x)\n",\r\n__func__, reg, mask, expected);\r\nreturn -EBUSY;\r\n}\r\nstatic void usb3_enable_irq_1(struct renesas_usb3 *usb3, u32 bits)\r\n{\r\nusb3_set_bit(usb3, bits, USB3_USB_INT_ENA_1);\r\n}\r\nstatic void usb3_disable_irq_1(struct renesas_usb3 *usb3, u32 bits)\r\n{\r\nusb3_clear_bit(usb3, bits, USB3_USB_INT_ENA_1);\r\n}\r\nstatic void usb3_enable_pipe_irq(struct renesas_usb3 *usb3, int num)\r\n{\r\nusb3_set_bit(usb3, USB_INT_2_PIPE(num), USB3_USB_INT_ENA_2);\r\n}\r\nstatic void usb3_disable_pipe_irq(struct renesas_usb3 *usb3, int num)\r\n{\r\nusb3_clear_bit(usb3, USB_INT_2_PIPE(num), USB3_USB_INT_ENA_2);\r\n}\r\nstatic void usb3_init_axi_bridge(struct renesas_usb3 *usb3)\r\n{\r\nusb3_write(usb3, ~0, USB3_DMA_INT_STA);\r\nusb3_write(usb3, 0, USB3_DMA_INT_ENA);\r\nusb3_set_bit(usb3, AXI_INT_DMAINT | AXI_INT_EPCINT, USB3_AXI_INT_ENA);\r\n}\r\nstatic void usb3_init_epc_registers(struct renesas_usb3 *usb3)\r\n{\r\nusb3_set_bit(usb3, DRD_CON_PERI_CON, USB3_DRD_CON);\r\nusb3_write(usb3, ~0, USB3_USB_INT_STA_1);\r\nusb3_enable_irq_1(usb3, USB_INT_1_VBUS_CNG);\r\n}\r\nstatic bool usb3_wakeup_usb2_phy(struct renesas_usb3 *usb3)\r\n{\r\nif (!(usb3_read(usb3, USB3_USB20_CON) & USB20_CON_B2_SUSPEND))\r\nreturn true;\r\nusb3_clear_bit(usb3, USB20_CON_B2_SUSPEND, USB3_USB20_CON);\r\nusb3_enable_irq_1(usb3, USB_INT_1_B2_RSUM);\r\nreturn false;\r\n}\r\nstatic void usb3_usb2_pullup(struct renesas_usb3 *usb3, int pullup)\r\n{\r\nu32 bits = USB20_CON_B2_PUE | USB20_CON_B2_CONNECT;\r\nif (usb3->softconnect && pullup)\r\nusb3_set_bit(usb3, bits, USB3_USB20_CON);\r\nelse\r\nusb3_clear_bit(usb3, bits, USB3_USB20_CON);\r\n}\r\nstatic void usb3_set_test_mode(struct renesas_usb3 *usb3)\r\n{\r\nu32 val = usb3_read(usb3, USB3_USB20_CON);\r\nval &= ~USB20_CON_B2_TSTMOD_MASK;\r\nval |= USB20_CON_B2_TSTMOD(usb3->test_mode);\r\nusb3_write(usb3, val | USB20_CON_B2_TSTMOD_EN, USB3_USB20_CON);\r\nif (!usb3->test_mode)\r\nusb3_clear_bit(usb3, USB20_CON_B2_TSTMOD_EN, USB3_USB20_CON);\r\n}\r\nstatic void usb3_start_usb2_connection(struct renesas_usb3 *usb3)\r\n{\r\nusb3->disabled_count++;\r\nusb3_set_bit(usb3, USB_COM_CON_EP0_EN, USB3_USB_COM_CON);\r\nusb3_set_bit(usb3, USB_COM_CON_SPD_MODE, USB3_USB_COM_CON);\r\nusb3_usb2_pullup(usb3, 1);\r\n}\r\nstatic int usb3_is_usb3_phy_in_u3(struct renesas_usb3 *usb3)\r\n{\r\nreturn usb3_read(usb3, USB3_USB30_CON) & USB30_CON_POW_SEL_IN_U3;\r\n}\r\nstatic bool usb3_wakeup_usb3_phy(struct renesas_usb3 *usb3)\r\n{\r\nif (!usb3_is_usb3_phy_in_u3(usb3))\r\nreturn true;\r\nusb3_set_bit(usb3, USB30_CON_B3_PLLWAKE, USB3_USB30_CON);\r\nusb3_enable_irq_1(usb3, USB_INT_1_B3_PLLWKUP);\r\nreturn false;\r\n}\r\nstatic u16 usb3_feature_get_un_enabled(struct renesas_usb3 *usb3)\r\n{\r\nu32 mask_u2 = SSIFCMD_UDIR_U2 | SSIFCMD_UREQ_U2;\r\nu32 mask_u1 = SSIFCMD_UDIR_U1 | SSIFCMD_UREQ_U1;\r\nu32 val = usb3_read(usb3, USB3_SSIFCMD);\r\nu16 ret = 0;\r\nif (!(val & mask_u2))\r\nret |= 1 << USB_DEV_STAT_U2_ENABLED;\r\nif (!(val & mask_u1))\r\nret |= 1 << USB_DEV_STAT_U1_ENABLED;\r\nreturn ret;\r\n}\r\nstatic void usb3_feature_u2_enable(struct renesas_usb3 *usb3, bool enable)\r\n{\r\nu32 bits = SSIFCMD_UDIR_U2 | SSIFCMD_UREQ_U2;\r\nif (enable)\r\nusb3_clear_bit(usb3, bits, USB3_SSIFCMD);\r\nelse\r\nusb3_set_bit(usb3, bits, USB3_SSIFCMD);\r\n}\r\nstatic void usb3_feature_u1_enable(struct renesas_usb3 *usb3, bool enable)\r\n{\r\nu32 bits = SSIFCMD_UDIR_U1 | SSIFCMD_UREQ_U1;\r\nif (enable)\r\nusb3_clear_bit(usb3, bits, USB3_SSIFCMD);\r\nelse\r\nusb3_set_bit(usb3, bits, USB3_SSIFCMD);\r\n}\r\nstatic void usb3_start_operation_for_usb3(struct renesas_usb3 *usb3)\r\n{\r\nusb3_set_bit(usb3, USB_COM_CON_EP0_EN, USB3_USB_COM_CON);\r\nusb3_clear_bit(usb3, USB_COM_CON_SPD_MODE, USB3_USB_COM_CON);\r\nusb3_set_bit(usb3, USB30_CON_B3_CONNECT, USB3_USB30_CON);\r\n}\r\nstatic void usb3_start_usb3_connection(struct renesas_usb3 *usb3)\r\n{\r\nusb3_start_operation_for_usb3(usb3);\r\nusb3_set_bit(usb3, USB_COM_CON_RX_DETECTION, USB3_USB_COM_CON);\r\nusb3_enable_irq_1(usb3, USB_INT_1_B3_LUPSUCS | USB_INT_1_B3_DISABLE |\r\nUSB_INT_1_SPEED);\r\n}\r\nstatic void usb3_stop_usb3_connection(struct renesas_usb3 *usb3)\r\n{\r\nusb3_clear_bit(usb3, USB30_CON_B3_CONNECT, USB3_USB30_CON);\r\n}\r\nstatic void usb3_transition_to_default_state(struct renesas_usb3 *usb3,\r\nbool is_usb3)\r\n{\r\nusb3_set_bit(usb3, USB_INT_2_PIPE(0), USB3_USB_INT_ENA_2);\r\nusb3_write(usb3, P0_INT_ALL_BITS, USB3_P0_INT_STA);\r\nusb3_set_bit(usb3, P0_INT_ALL_BITS, USB3_P0_INT_ENA);\r\nif (is_usb3)\r\nusb3_enable_irq_1(usb3, USB_INT_1_B3_WRMRST |\r\nUSB_INT_1_B3_HOTRST);\r\nelse\r\nusb3_enable_irq_1(usb3, USB_INT_1_B2_SPND |\r\nUSB_INT_1_B2_L1SPND | USB_INT_1_B2_USBRST);\r\n}\r\nstatic void usb3_connect(struct renesas_usb3 *usb3)\r\n{\r\nif (usb3_wakeup_usb3_phy(usb3))\r\nusb3_start_usb3_connection(usb3);\r\n}\r\nstatic void usb3_reset_epc(struct renesas_usb3 *usb3)\r\n{\r\nusb3_clear_bit(usb3, USB_COM_CON_CONF, USB3_USB_COM_CON);\r\nusb3_clear_bit(usb3, USB_COM_CON_EP0_EN, USB3_USB_COM_CON);\r\nusb3_set_bit(usb3, USB_COM_CON_PIPE_CLR, USB3_USB_COM_CON);\r\nusb3->test_mode = 0;\r\nusb3_set_test_mode(usb3);\r\n}\r\nstatic void usb3_disconnect(struct renesas_usb3 *usb3)\r\n{\r\nusb3->disabled_count = 0;\r\nusb3_usb2_pullup(usb3, 0);\r\nusb3_clear_bit(usb3, USB30_CON_B3_CONNECT, USB3_USB30_CON);\r\nusb3_reset_epc(usb3);\r\nif (usb3->driver)\r\nusb3->driver->disconnect(&usb3->gadget);\r\n}\r\nstatic void usb3_check_vbus(struct renesas_usb3 *usb3)\r\n{\r\nif (usb3->workaround_for_vbus) {\r\nusb3_connect(usb3);\r\n} else {\r\nif (usb3_read(usb3, USB3_USB_STA) & USB_STA_VBUS_STA)\r\nusb3_connect(usb3);\r\nelse\r\nusb3_disconnect(usb3);\r\n}\r\n}\r\nstatic void renesas_usb3_init_controller(struct renesas_usb3 *usb3)\r\n{\r\nusb3_init_axi_bridge(usb3);\r\nusb3_init_epc_registers(usb3);\r\nusb3_check_vbus(usb3);\r\n}\r\nstatic void renesas_usb3_stop_controller(struct renesas_usb3 *usb3)\r\n{\r\nusb3_disconnect(usb3);\r\nusb3_write(usb3, 0, USB3_P0_INT_ENA);\r\nusb3_write(usb3, 0, USB3_PN_INT_ENA);\r\nusb3_write(usb3, 0, USB3_USB_INT_ENA_1);\r\nusb3_write(usb3, 0, USB3_USB_INT_ENA_2);\r\nusb3_write(usb3, 0, USB3_AXI_INT_ENA);\r\n}\r\nstatic void usb3_irq_epc_int_1_pll_wakeup(struct renesas_usb3 *usb3)\r\n{\r\nusb3_disable_irq_1(usb3, USB_INT_1_B3_PLLWKUP);\r\nusb3_clear_bit(usb3, USB30_CON_B3_PLLWAKE, USB3_USB30_CON);\r\nusb3_start_usb3_connection(usb3);\r\n}\r\nstatic void usb3_irq_epc_int_1_linkup_success(struct renesas_usb3 *usb3)\r\n{\r\nusb3_transition_to_default_state(usb3, true);\r\n}\r\nstatic void usb3_irq_epc_int_1_resume(struct renesas_usb3 *usb3)\r\n{\r\nusb3_disable_irq_1(usb3, USB_INT_1_B2_RSUM);\r\nusb3_start_usb2_connection(usb3);\r\nusb3_transition_to_default_state(usb3, false);\r\n}\r\nstatic void usb3_irq_epc_int_1_disable(struct renesas_usb3 *usb3)\r\n{\r\nusb3_stop_usb3_connection(usb3);\r\nif (usb3_wakeup_usb2_phy(usb3))\r\nusb3_irq_epc_int_1_resume(usb3);\r\n}\r\nstatic void usb3_irq_epc_int_1_bus_reset(struct renesas_usb3 *usb3)\r\n{\r\nusb3_reset_epc(usb3);\r\nif (usb3->disabled_count < 3)\r\nusb3_start_usb3_connection(usb3);\r\nelse\r\nusb3_start_usb2_connection(usb3);\r\n}\r\nstatic void usb3_irq_epc_int_1_vbus_change(struct renesas_usb3 *usb3)\r\n{\r\nusb3_check_vbus(usb3);\r\n}\r\nstatic void usb3_irq_epc_int_1_hot_reset(struct renesas_usb3 *usb3)\r\n{\r\nusb3_reset_epc(usb3);\r\nusb3_set_bit(usb3, USB_COM_CON_EP0_EN, USB3_USB_COM_CON);\r\nusb3_set_bit(usb3, USB30_CON_B3_HOTRST_CMP, USB3_USB30_CON);\r\n}\r\nstatic void usb3_irq_epc_int_1_warm_reset(struct renesas_usb3 *usb3)\r\n{\r\nusb3_reset_epc(usb3);\r\nusb3_set_bit(usb3, USB_COM_CON_EP0_EN, USB3_USB_COM_CON);\r\nusb3_start_operation_for_usb3(usb3);\r\nusb3_enable_irq_1(usb3, USB_INT_1_SPEED);\r\n}\r\nstatic void usb3_irq_epc_int_1_speed(struct renesas_usb3 *usb3)\r\n{\r\nu32 speed = usb3_read(usb3, USB3_USB_STA) & USB_STA_SPEED_MASK;\r\nswitch (speed) {\r\ncase USB_STA_SPEED_SS:\r\nusb3->gadget.speed = USB_SPEED_SUPER;\r\nbreak;\r\ncase USB_STA_SPEED_HS:\r\nusb3->gadget.speed = USB_SPEED_HIGH;\r\nbreak;\r\ncase USB_STA_SPEED_FS:\r\nusb3->gadget.speed = USB_SPEED_FULL;\r\nbreak;\r\ndefault:\r\nusb3->gadget.speed = USB_SPEED_UNKNOWN;\r\nbreak;\r\n}\r\n}\r\nstatic void usb3_irq_epc_int_1(struct renesas_usb3 *usb3, u32 int_sta_1)\r\n{\r\nif (int_sta_1 & USB_INT_1_B3_PLLWKUP)\r\nusb3_irq_epc_int_1_pll_wakeup(usb3);\r\nif (int_sta_1 & USB_INT_1_B3_LUPSUCS)\r\nusb3_irq_epc_int_1_linkup_success(usb3);\r\nif (int_sta_1 & USB_INT_1_B3_HOTRST)\r\nusb3_irq_epc_int_1_hot_reset(usb3);\r\nif (int_sta_1 & USB_INT_1_B3_WRMRST)\r\nusb3_irq_epc_int_1_warm_reset(usb3);\r\nif (int_sta_1 & USB_INT_1_B3_DISABLE)\r\nusb3_irq_epc_int_1_disable(usb3);\r\nif (int_sta_1 & USB_INT_1_B2_USBRST)\r\nusb3_irq_epc_int_1_bus_reset(usb3);\r\nif (int_sta_1 & USB_INT_1_B2_RSUM)\r\nusb3_irq_epc_int_1_resume(usb3);\r\nif (int_sta_1 & USB_INT_1_SPEED)\r\nusb3_irq_epc_int_1_speed(usb3);\r\nif (int_sta_1 & USB_INT_1_VBUS_CNG)\r\nusb3_irq_epc_int_1_vbus_change(usb3);\r\n}\r\nstatic struct renesas_usb3_request *__usb3_get_request(struct renesas_usb3_ep\r\n*usb3_ep)\r\n{\r\nreturn list_first_entry_or_null(&usb3_ep->queue,\r\nstruct renesas_usb3_request, queue);\r\n}\r\nstatic struct renesas_usb3_request *usb3_get_request(struct renesas_usb3_ep\r\n*usb3_ep)\r\n{\r\nstruct renesas_usb3 *usb3 = usb3_ep_to_usb3(usb3_ep);\r\nstruct renesas_usb3_request *usb3_req;\r\nunsigned long flags;\r\nspin_lock_irqsave(&usb3->lock, flags);\r\nusb3_req = __usb3_get_request(usb3_ep);\r\nspin_unlock_irqrestore(&usb3->lock, flags);\r\nreturn usb3_req;\r\n}\r\nstatic void usb3_request_done(struct renesas_usb3_ep *usb3_ep,\r\nstruct renesas_usb3_request *usb3_req, int status)\r\n{\r\nstruct renesas_usb3 *usb3 = usb3_ep_to_usb3(usb3_ep);\r\nunsigned long flags;\r\ndev_dbg(usb3_to_dev(usb3), "giveback: ep%2d, %u, %u, %d\n",\r\nusb3_ep->num, usb3_req->req.length, usb3_req->req.actual,\r\nstatus);\r\nusb3_req->req.status = status;\r\nspin_lock_irqsave(&usb3->lock, flags);\r\nusb3_ep->started = false;\r\nlist_del_init(&usb3_req->queue);\r\nspin_unlock_irqrestore(&usb3->lock, flags);\r\nusb_gadget_giveback_request(&usb3_ep->ep, &usb3_req->req);\r\n}\r\nstatic void usb3_irq_epc_pipe0_status_end(struct renesas_usb3 *usb3)\r\n{\r\nstruct renesas_usb3_ep *usb3_ep = usb3_get_ep(usb3, 0);\r\nstruct renesas_usb3_request *usb3_req = usb3_get_request(usb3_ep);\r\nif (usb3_req)\r\nusb3_request_done(usb3_ep, usb3_req, 0);\r\nif (usb3->test_mode)\r\nusb3_set_test_mode(usb3);\r\n}\r\nstatic void usb3_get_setup_data(struct renesas_usb3 *usb3,\r\nstruct usb_ctrlrequest *ctrl)\r\n{\r\nstruct renesas_usb3_ep *usb3_ep = usb3_get_ep(usb3, 0);\r\nu32 *data = (u32 *)ctrl;\r\n*data++ = usb3_read(usb3, USB3_STUP_DAT_0);\r\n*data = usb3_read(usb3, USB3_STUP_DAT_1);\r\nusb3_ep->dir_in = !!(ctrl->bRequestType & USB_DIR_IN);\r\n}\r\nstatic void usb3_set_p0_con_update_res(struct renesas_usb3 *usb3, u32 res)\r\n{\r\nu32 val = usb3_read(usb3, USB3_P0_CON);\r\nval &= ~(P0_CON_ST_RES_MASK | P0_CON_OT_RES_MASK | P0_CON_IN_RES_MASK);\r\nval |= res | P0_CON_RES_WEN;\r\nusb3_write(usb3, val, USB3_P0_CON);\r\n}\r\nstatic void usb3_set_p0_con_for_ctrl_read_data(struct renesas_usb3 *usb3)\r\n{\r\nusb3_set_p0_con_update_res(usb3, P0_CON_ST_RES_FORCE_NRDY |\r\nP0_CON_OT_RES_FORCE_STALL |\r\nP0_CON_IN_RES_NORMAL);\r\n}\r\nstatic void usb3_set_p0_con_for_ctrl_read_status(struct renesas_usb3 *usb3)\r\n{\r\nusb3_set_p0_con_update_res(usb3, P0_CON_ST_RES_NORMAL |\r\nP0_CON_OT_RES_FORCE_STALL |\r\nP0_CON_IN_RES_NORMAL);\r\n}\r\nstatic void usb3_set_p0_con_for_ctrl_write_data(struct renesas_usb3 *usb3)\r\n{\r\nusb3_set_p0_con_update_res(usb3, P0_CON_ST_RES_FORCE_NRDY |\r\nP0_CON_OT_RES_NORMAL |\r\nP0_CON_IN_RES_FORCE_STALL);\r\n}\r\nstatic void usb3_set_p0_con_for_ctrl_write_status(struct renesas_usb3 *usb3)\r\n{\r\nusb3_set_p0_con_update_res(usb3, P0_CON_ST_RES_NORMAL |\r\nP0_CON_OT_RES_NORMAL |\r\nP0_CON_IN_RES_FORCE_STALL);\r\n}\r\nstatic void usb3_set_p0_con_for_no_data(struct renesas_usb3 *usb3)\r\n{\r\nusb3_set_p0_con_update_res(usb3, P0_CON_ST_RES_NORMAL |\r\nP0_CON_OT_RES_FORCE_STALL |\r\nP0_CON_IN_RES_FORCE_STALL);\r\n}\r\nstatic void usb3_set_p0_con_stall(struct renesas_usb3 *usb3)\r\n{\r\nusb3_set_p0_con_update_res(usb3, P0_CON_ST_RES_FORCE_STALL |\r\nP0_CON_OT_RES_FORCE_STALL |\r\nP0_CON_IN_RES_FORCE_STALL);\r\n}\r\nstatic void usb3_set_p0_con_stop(struct renesas_usb3 *usb3)\r\n{\r\nusb3_set_p0_con_update_res(usb3, P0_CON_ST_RES_FORCE_NRDY |\r\nP0_CON_OT_RES_FORCE_NRDY |\r\nP0_CON_IN_RES_FORCE_NRDY);\r\n}\r\nstatic int usb3_pn_change(struct renesas_usb3 *usb3, int num)\r\n{\r\nif (num == 0 || num > usb3->num_usb3_eps)\r\nreturn -ENXIO;\r\nusb3_write(usb3, num, USB3_PIPE_COM);\r\nreturn 0;\r\n}\r\nstatic void usb3_set_pn_con_update_res(struct renesas_usb3 *usb3, u32 res)\r\n{\r\nu32 val = usb3_read(usb3, USB3_PN_CON);\r\nval &= ~PN_CON_RES_MASK;\r\nval |= res & PN_CON_RES_MASK;\r\nval |= PN_CON_RES_WEN;\r\nusb3_write(usb3, val, USB3_PN_CON);\r\n}\r\nstatic void usb3_pn_start(struct renesas_usb3 *usb3)\r\n{\r\nusb3_set_pn_con_update_res(usb3, PN_CON_RES_NORMAL);\r\n}\r\nstatic void usb3_pn_stop(struct renesas_usb3 *usb3)\r\n{\r\nusb3_set_pn_con_update_res(usb3, PN_CON_RES_FORCE_NRDY);\r\n}\r\nstatic void usb3_pn_stall(struct renesas_usb3 *usb3)\r\n{\r\nusb3_set_pn_con_update_res(usb3, PN_CON_RES_FORCE_STALL);\r\n}\r\nstatic int usb3_pn_con_clear(struct renesas_usb3 *usb3)\r\n{\r\nusb3_set_bit(usb3, PN_CON_CLR, USB3_PN_CON);\r\nreturn usb3_wait(usb3, USB3_PN_CON, PN_CON_CLR, 0);\r\n}\r\nstatic bool usb3_is_transfer_complete(struct renesas_usb3_ep *usb3_ep,\r\nstruct renesas_usb3_request *usb3_req)\r\n{\r\nstruct usb_request *req = &usb3_req->req;\r\nif ((!req->zero && req->actual == req->length) ||\r\n(req->actual % usb3_ep->ep.maxpacket) || (req->length == 0))\r\nreturn true;\r\nelse\r\nreturn false;\r\n}\r\nstatic int usb3_wait_pipe_status(struct renesas_usb3_ep *usb3_ep, u32 mask)\r\n{\r\nstruct renesas_usb3 *usb3 = usb3_ep_to_usb3(usb3_ep);\r\nu32 sta_reg = usb3_ep->num ? USB3_PN_STA : USB3_P0_STA;\r\nreturn usb3_wait(usb3, sta_reg, mask, mask);\r\n}\r\nstatic void usb3_set_px_con_send(struct renesas_usb3_ep *usb3_ep, int bytes,\r\nbool last)\r\n{\r\nstruct renesas_usb3 *usb3 = usb3_ep_to_usb3(usb3_ep);\r\nu32 con_reg = usb3_ep->num ? USB3_PN_CON : USB3_P0_CON;\r\nu32 val = usb3_read(usb3, con_reg);\r\nval |= PX_CON_SEND | PX_CON_BYTE_EN_BYTES(bytes);\r\nval |= (usb3_ep->num && last) ? PN_CON_LAST : 0;\r\nusb3_write(usb3, val, con_reg);\r\n}\r\nstatic int usb3_write_pipe(struct renesas_usb3_ep *usb3_ep,\r\nstruct renesas_usb3_request *usb3_req,\r\nu32 fifo_reg)\r\n{\r\nstruct renesas_usb3 *usb3 = usb3_ep_to_usb3(usb3_ep);\r\nint i;\r\nint len = min_t(unsigned, usb3_req->req.length - usb3_req->req.actual,\r\nusb3_ep->ep.maxpacket);\r\nu8 *buf = usb3_req->req.buf + usb3_req->req.actual;\r\nu32 tmp = 0;\r\nbool is_last;\r\nif (usb3_wait_pipe_status(usb3_ep, PX_STA_BUFSTS) < 0)\r\nreturn -EBUSY;\r\nusb3_req->req.actual += len;\r\nif (len >= 4) {\r\niowrite32_rep(usb3->reg + fifo_reg, buf, len / 4);\r\nbuf += (len / 4) * 4;\r\nlen %= 4;\r\n}\r\nif (len) {\r\nfor (i = 0; i < len; i++)\r\ntmp |= buf[i] << (8 * i);\r\nusb3_write(usb3, tmp, fifo_reg);\r\n}\r\nis_last = usb3_is_transfer_complete(usb3_ep, usb3_req);\r\nusb3_set_px_con_send(usb3_ep, len, is_last);\r\nreturn is_last ? 0 : -EAGAIN;\r\n}\r\nstatic u32 usb3_get_received_length(struct renesas_usb3_ep *usb3_ep)\r\n{\r\nstruct renesas_usb3 *usb3 = usb3_ep_to_usb3(usb3_ep);\r\nu32 lng_reg = usb3_ep->num ? USB3_PN_LNG : USB3_P0_LNG;\r\nreturn usb3_read(usb3, lng_reg);\r\n}\r\nstatic int usb3_read_pipe(struct renesas_usb3_ep *usb3_ep,\r\nstruct renesas_usb3_request *usb3_req, u32 fifo_reg)\r\n{\r\nstruct renesas_usb3 *usb3 = usb3_ep_to_usb3(usb3_ep);\r\nint i;\r\nint len = min_t(unsigned, usb3_req->req.length - usb3_req->req.actual,\r\nusb3_get_received_length(usb3_ep));\r\nu8 *buf = usb3_req->req.buf + usb3_req->req.actual;\r\nu32 tmp = 0;\r\nif (!len)\r\nreturn 0;\r\nusb3_req->req.actual += len;\r\nif (len >= 4) {\r\nioread32_rep(usb3->reg + fifo_reg, buf, len / 4);\r\nbuf += (len / 4) * 4;\r\nlen %= 4;\r\n}\r\nif (len) {\r\ntmp = usb3_read(usb3, fifo_reg);\r\nfor (i = 0; i < len; i++)\r\nbuf[i] = (tmp >> (8 * i)) & 0xff;\r\n}\r\nreturn usb3_is_transfer_complete(usb3_ep, usb3_req) ? 0 : -EAGAIN;\r\n}\r\nstatic void usb3_set_status_stage(struct renesas_usb3_ep *usb3_ep,\r\nstruct renesas_usb3_request *usb3_req)\r\n{\r\nstruct renesas_usb3 *usb3 = usb3_ep_to_usb3(usb3_ep);\r\nif (usb3_ep->dir_in) {\r\nusb3_set_p0_con_for_ctrl_read_status(usb3);\r\n} else {\r\nif (!usb3_req->req.length)\r\nusb3_set_p0_con_for_no_data(usb3);\r\nelse\r\nusb3_set_p0_con_for_ctrl_write_status(usb3);\r\n}\r\n}\r\nstatic void usb3_p0_xfer(struct renesas_usb3_ep *usb3_ep,\r\nstruct renesas_usb3_request *usb3_req)\r\n{\r\nint ret = -EAGAIN;\r\nif (usb3_ep->dir_in)\r\nret = usb3_write_pipe(usb3_ep, usb3_req, USB3_P0_WRITE);\r\nelse\r\nret = usb3_read_pipe(usb3_ep, usb3_req, USB3_P0_READ);\r\nif (!ret)\r\nusb3_set_status_stage(usb3_ep, usb3_req);\r\n}\r\nstatic void usb3_start_pipe0(struct renesas_usb3_ep *usb3_ep,\r\nstruct renesas_usb3_request *usb3_req)\r\n{\r\nstruct renesas_usb3 *usb3 = usb3_ep_to_usb3(usb3_ep);\r\nif (usb3_ep->started)\r\nreturn;\r\nusb3_ep->started = true;\r\nif (usb3_ep->dir_in) {\r\nusb3_set_bit(usb3, P0_MOD_DIR, USB3_P0_MOD);\r\nusb3_set_p0_con_for_ctrl_read_data(usb3);\r\n} else {\r\nusb3_clear_bit(usb3, P0_MOD_DIR, USB3_P0_MOD);\r\nusb3_set_p0_con_for_ctrl_write_data(usb3);\r\n}\r\nusb3_p0_xfer(usb3_ep, usb3_req);\r\n}\r\nstatic void usb3_start_pipen(struct renesas_usb3_ep *usb3_ep,\r\nstruct renesas_usb3_request *usb3_req)\r\n{\r\nstruct renesas_usb3 *usb3 = usb3_ep_to_usb3(usb3_ep);\r\nstruct renesas_usb3_request *usb3_req_first = usb3_get_request(usb3_ep);\r\nunsigned long flags;\r\nint ret = -EAGAIN;\r\nu32 enable_bits = 0;\r\nif (usb3_ep->halt || usb3_ep->started)\r\nreturn;\r\nif (usb3_req != usb3_req_first)\r\nreturn;\r\nspin_lock_irqsave(&usb3->lock, flags);\r\nif (usb3_pn_change(usb3, usb3_ep->num) < 0)\r\ngoto out;\r\nusb3_ep->started = true;\r\nusb3_pn_start(usb3);\r\nif (usb3_ep->dir_in) {\r\nret = usb3_write_pipe(usb3_ep, usb3_req, USB3_PN_WRITE);\r\nenable_bits |= PN_INT_LSTTR;\r\n}\r\nif (ret < 0)\r\nenable_bits |= PN_INT_BFRDY;\r\nif (enable_bits) {\r\nusb3_set_bit(usb3, enable_bits, USB3_PN_INT_ENA);\r\nusb3_enable_pipe_irq(usb3, usb3_ep->num);\r\n}\r\nout:\r\nspin_unlock_irqrestore(&usb3->lock, flags);\r\n}\r\nstatic int renesas_usb3_ep_queue(struct usb_ep *_ep, struct usb_request *_req,\r\ngfp_t gfp_flags)\r\n{\r\nstruct renesas_usb3_ep *usb3_ep = usb_ep_to_usb3_ep(_ep);\r\nstruct renesas_usb3_request *usb3_req = usb_req_to_usb3_req(_req);\r\nstruct renesas_usb3 *usb3 = usb3_ep_to_usb3(usb3_ep);\r\nunsigned long flags;\r\ndev_dbg(usb3_to_dev(usb3), "ep_queue: ep%2d, %u\n", usb3_ep->num,\r\n_req->length);\r\n_req->status = -EINPROGRESS;\r\n_req->actual = 0;\r\nspin_lock_irqsave(&usb3->lock, flags);\r\nlist_add_tail(&usb3_req->queue, &usb3_ep->queue);\r\nspin_unlock_irqrestore(&usb3->lock, flags);\r\nif (!usb3_ep->num)\r\nusb3_start_pipe0(usb3_ep, usb3_req);\r\nelse\r\nusb3_start_pipen(usb3_ep, usb3_req);\r\nreturn 0;\r\n}\r\nstatic void usb3_set_device_address(struct renesas_usb3 *usb3, u16 addr)\r\n{\r\nusb3_set_bit(usb3, USB_COM_CON_DEV_ADDR(addr), USB3_USB_COM_CON);\r\n}\r\nstatic bool usb3_std_req_set_address(struct renesas_usb3 *usb3,\r\nstruct usb_ctrlrequest *ctrl)\r\n{\r\nif (ctrl->wValue >= 128)\r\nreturn true;\r\nusb3_set_device_address(usb3, ctrl->wValue);\r\nusb3_set_p0_con_for_no_data(usb3);\r\nreturn false;\r\n}\r\nstatic void usb3_pipe0_internal_xfer(struct renesas_usb3 *usb3,\r\nvoid *tx_data, size_t len,\r\nvoid (*complete)(struct usb_ep *ep,\r\nstruct usb_request *req))\r\n{\r\nstruct renesas_usb3_ep *usb3_ep = usb3_get_ep(usb3, 0);\r\nif (tx_data)\r\nmemcpy(usb3->ep0_buf, tx_data,\r\nmin_t(size_t, len, USB3_EP0_BUF_SIZE));\r\nusb3->ep0_req->buf = &usb3->ep0_buf;\r\nusb3->ep0_req->length = len;\r\nusb3->ep0_req->complete = complete;\r\nrenesas_usb3_ep_queue(&usb3_ep->ep, usb3->ep0_req, GFP_ATOMIC);\r\n}\r\nstatic void usb3_pipe0_get_status_completion(struct usb_ep *ep,\r\nstruct usb_request *req)\r\n{\r\n}\r\nstatic bool usb3_std_req_get_status(struct renesas_usb3 *usb3,\r\nstruct usb_ctrlrequest *ctrl)\r\n{\r\nbool stall = false;\r\nstruct renesas_usb3_ep *usb3_ep;\r\nint num;\r\nu16 status = 0;\r\nswitch (ctrl->bRequestType & USB_RECIP_MASK) {\r\ncase USB_RECIP_DEVICE:\r\nif (usb3->gadget.is_selfpowered)\r\nstatus |= 1 << USB_DEVICE_SELF_POWERED;\r\nif (usb3->gadget.speed == USB_SPEED_SUPER)\r\nstatus |= usb3_feature_get_un_enabled(usb3);\r\nbreak;\r\ncase USB_RECIP_INTERFACE:\r\nbreak;\r\ncase USB_RECIP_ENDPOINT:\r\nnum = le16_to_cpu(ctrl->wIndex) & USB_ENDPOINT_NUMBER_MASK;\r\nusb3_ep = usb3_get_ep(usb3, num);\r\nif (usb3_ep->halt)\r\nstatus |= 1 << USB_ENDPOINT_HALT;\r\nbreak;\r\ndefault:\r\nstall = true;\r\nbreak;\r\n}\r\nif (!stall) {\r\nstatus = cpu_to_le16(status);\r\ndev_dbg(usb3_to_dev(usb3), "get_status: req = %p\n",\r\nusb_req_to_usb3_req(usb3->ep0_req));\r\nusb3_pipe0_internal_xfer(usb3, &status, sizeof(status),\r\nusb3_pipe0_get_status_completion);\r\n}\r\nreturn stall;\r\n}\r\nstatic bool usb3_std_req_feature_device(struct renesas_usb3 *usb3,\r\nstruct usb_ctrlrequest *ctrl, bool set)\r\n{\r\nbool stall = true;\r\nu16 w_value = le16_to_cpu(ctrl->wValue);\r\nswitch (w_value) {\r\ncase USB_DEVICE_TEST_MODE:\r\nif (!set)\r\nbreak;\r\nusb3->test_mode = le16_to_cpu(ctrl->wIndex) >> 8;\r\nstall = false;\r\nbreak;\r\ncase USB_DEVICE_U1_ENABLE:\r\ncase USB_DEVICE_U2_ENABLE:\r\nif (usb3->gadget.speed != USB_SPEED_SUPER)\r\nbreak;\r\nif (w_value == USB_DEVICE_U1_ENABLE)\r\nusb3_feature_u1_enable(usb3, set);\r\nif (w_value == USB_DEVICE_U2_ENABLE)\r\nusb3_feature_u2_enable(usb3, set);\r\nstall = false;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nreturn stall;\r\n}\r\nstatic int usb3_set_halt_p0(struct renesas_usb3_ep *usb3_ep, bool halt)\r\n{\r\nstruct renesas_usb3 *usb3 = usb3_ep_to_usb3(usb3_ep);\r\nif (unlikely(usb3_ep->num))\r\nreturn -EINVAL;\r\nusb3_ep->halt = halt;\r\nif (halt)\r\nusb3_set_p0_con_stall(usb3);\r\nelse\r\nusb3_set_p0_con_stop(usb3);\r\nreturn 0;\r\n}\r\nstatic int usb3_set_halt_pn(struct renesas_usb3_ep *usb3_ep, bool halt,\r\nbool is_clear_feature)\r\n{\r\nstruct renesas_usb3 *usb3 = usb3_ep_to_usb3(usb3_ep);\r\nunsigned long flags;\r\nspin_lock_irqsave(&usb3->lock, flags);\r\nif (!usb3_pn_change(usb3, usb3_ep->num)) {\r\nusb3_ep->halt = halt;\r\nif (halt) {\r\nusb3_pn_stall(usb3);\r\n} else if (!is_clear_feature || !usb3_ep->wedge) {\r\nusb3_pn_con_clear(usb3);\r\nusb3_set_bit(usb3, PN_CON_EN, USB3_PN_CON);\r\nusb3_pn_stop(usb3);\r\n}\r\n}\r\nspin_unlock_irqrestore(&usb3->lock, flags);\r\nreturn 0;\r\n}\r\nstatic int usb3_set_halt(struct renesas_usb3_ep *usb3_ep, bool halt,\r\nbool is_clear_feature)\r\n{\r\nint ret = 0;\r\nif (halt && usb3_ep->started)\r\nreturn -EAGAIN;\r\nif (usb3_ep->num)\r\nret = usb3_set_halt_pn(usb3_ep, halt, is_clear_feature);\r\nelse\r\nret = usb3_set_halt_p0(usb3_ep, halt);\r\nreturn ret;\r\n}\r\nstatic bool usb3_std_req_feature_endpoint(struct renesas_usb3 *usb3,\r\nstruct usb_ctrlrequest *ctrl,\r\nbool set)\r\n{\r\nint num = le16_to_cpu(ctrl->wIndex) & USB_ENDPOINT_NUMBER_MASK;\r\nstruct renesas_usb3_ep *usb3_ep;\r\nstruct renesas_usb3_request *usb3_req;\r\nif (le16_to_cpu(ctrl->wValue) != USB_ENDPOINT_HALT)\r\nreturn true;\r\nusb3_ep = usb3_get_ep(usb3, num);\r\nusb3_set_halt(usb3_ep, set, true);\r\nif (!set) {\r\nusb3_ep->started = false;\r\nusb3_req = usb3_get_request(usb3_ep);\r\nif (usb3_req)\r\nusb3_start_pipen(usb3_ep, usb3_req);\r\n}\r\nreturn false;\r\n}\r\nstatic bool usb3_std_req_feature(struct renesas_usb3 *usb3,\r\nstruct usb_ctrlrequest *ctrl, bool set)\r\n{\r\nbool stall = false;\r\nswitch (ctrl->bRequestType & USB_RECIP_MASK) {\r\ncase USB_RECIP_DEVICE:\r\nstall = usb3_std_req_feature_device(usb3, ctrl, set);\r\nbreak;\r\ncase USB_RECIP_INTERFACE:\r\nbreak;\r\ncase USB_RECIP_ENDPOINT:\r\nstall = usb3_std_req_feature_endpoint(usb3, ctrl, set);\r\nbreak;\r\ndefault:\r\nstall = true;\r\nbreak;\r\n}\r\nif (!stall)\r\nusb3_set_p0_con_for_no_data(usb3);\r\nreturn stall;\r\n}\r\nstatic void usb3_pipe0_set_sel_completion(struct usb_ep *ep,\r\nstruct usb_request *req)\r\n{\r\n}\r\nstatic bool usb3_std_req_set_sel(struct renesas_usb3 *usb3,\r\nstruct usb_ctrlrequest *ctrl)\r\n{\r\nu16 w_length = le16_to_cpu(ctrl->wLength);\r\nif (w_length != 6)\r\nreturn true;\r\ndev_dbg(usb3_to_dev(usb3), "set_sel: req = %p\n",\r\nusb_req_to_usb3_req(usb3->ep0_req));\r\nusb3_pipe0_internal_xfer(usb3, NULL, 6, usb3_pipe0_set_sel_completion);\r\nreturn false;\r\n}\r\nstatic bool usb3_std_req_set_configuration(struct renesas_usb3 *usb3,\r\nstruct usb_ctrlrequest *ctrl)\r\n{\r\nif (ctrl->wValue > 0)\r\nusb3_set_bit(usb3, USB_COM_CON_CONF, USB3_USB_COM_CON);\r\nelse\r\nusb3_clear_bit(usb3, USB_COM_CON_CONF, USB3_USB_COM_CON);\r\nreturn false;\r\n}\r\nstatic bool usb3_handle_standard_request(struct renesas_usb3 *usb3,\r\nstruct usb_ctrlrequest *ctrl)\r\n{\r\nbool ret = false;\r\nbool stall = false;\r\nif ((ctrl->bRequestType & USB_TYPE_MASK) == USB_TYPE_STANDARD) {\r\nswitch (ctrl->bRequest) {\r\ncase USB_REQ_SET_ADDRESS:\r\nstall = usb3_std_req_set_address(usb3, ctrl);\r\nret = true;\r\nbreak;\r\ncase USB_REQ_GET_STATUS:\r\nstall = usb3_std_req_get_status(usb3, ctrl);\r\nret = true;\r\nbreak;\r\ncase USB_REQ_CLEAR_FEATURE:\r\nstall = usb3_std_req_feature(usb3, ctrl, false);\r\nret = true;\r\nbreak;\r\ncase USB_REQ_SET_FEATURE:\r\nstall = usb3_std_req_feature(usb3, ctrl, true);\r\nret = true;\r\nbreak;\r\ncase USB_REQ_SET_SEL:\r\nstall = usb3_std_req_set_sel(usb3, ctrl);\r\nret = true;\r\nbreak;\r\ncase USB_REQ_SET_ISOCH_DELAY:\r\nstall = true;\r\nret = true;\r\nbreak;\r\ncase USB_REQ_SET_CONFIGURATION:\r\nusb3_std_req_set_configuration(usb3, ctrl);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nif (stall)\r\nusb3_set_p0_con_stall(usb3);\r\nreturn ret;\r\n}\r\nstatic int usb3_p0_con_clear_buffer(struct renesas_usb3 *usb3)\r\n{\r\nusb3_set_bit(usb3, P0_CON_BCLR, USB3_P0_CON);\r\nreturn usb3_wait(usb3, USB3_P0_CON, P0_CON_BCLR, 0);\r\n}\r\nstatic void usb3_irq_epc_pipe0_setup(struct renesas_usb3 *usb3)\r\n{\r\nstruct usb_ctrlrequest ctrl;\r\nstruct renesas_usb3_ep *usb3_ep = usb3_get_ep(usb3, 0);\r\nif (usb3_ep->started)\r\nusb3_request_done(usb3_ep, usb3_get_request(usb3_ep),\r\n-ECONNRESET);\r\nusb3_p0_con_clear_buffer(usb3);\r\nusb3_get_setup_data(usb3, &ctrl);\r\nif (!usb3_handle_standard_request(usb3, &ctrl))\r\nif (usb3->driver->setup(&usb3->gadget, &ctrl) < 0)\r\nusb3_set_p0_con_stall(usb3);\r\n}\r\nstatic void usb3_irq_epc_pipe0_bfrdy(struct renesas_usb3 *usb3)\r\n{\r\nstruct renesas_usb3_ep *usb3_ep = usb3_get_ep(usb3, 0);\r\nstruct renesas_usb3_request *usb3_req = usb3_get_request(usb3_ep);\r\nif (!usb3_req)\r\nreturn;\r\nusb3_p0_xfer(usb3_ep, usb3_req);\r\n}\r\nstatic void usb3_irq_epc_pipe0(struct renesas_usb3 *usb3)\r\n{\r\nu32 p0_int_sta = usb3_read(usb3, USB3_P0_INT_STA);\r\np0_int_sta &= usb3_read(usb3, USB3_P0_INT_ENA);\r\nusb3_write(usb3, p0_int_sta, USB3_P0_INT_STA);\r\nif (p0_int_sta & P0_INT_STSED)\r\nusb3_irq_epc_pipe0_status_end(usb3);\r\nif (p0_int_sta & P0_INT_SETUP)\r\nusb3_irq_epc_pipe0_setup(usb3);\r\nif (p0_int_sta & P0_INT_BFRDY)\r\nusb3_irq_epc_pipe0_bfrdy(usb3);\r\n}\r\nstatic void usb3_request_done_pipen(struct renesas_usb3 *usb3,\r\nstruct renesas_usb3_ep *usb3_ep,\r\nstruct renesas_usb3_request *usb3_req,\r\nint status)\r\n{\r\nusb3_pn_stop(usb3);\r\nusb3_disable_pipe_irq(usb3, usb3_ep->num);\r\nusb3_request_done(usb3_ep, usb3_req, status);\r\nusb3_req = usb3_get_request(usb3_ep);\r\nif (usb3_req)\r\nusb3_start_pipen(usb3_ep, usb3_req);\r\n}\r\nstatic void usb3_irq_epc_pipen_lsttr(struct renesas_usb3 *usb3, int num)\r\n{\r\nstruct renesas_usb3_ep *usb3_ep = usb3_get_ep(usb3, num);\r\nstruct renesas_usb3_request *usb3_req = usb3_get_request(usb3_ep);\r\nif (!usb3_req)\r\nreturn;\r\nif (usb3_ep->dir_in) {\r\ndev_dbg(usb3_to_dev(usb3), "%s: len = %u, actual = %u\n",\r\n__func__, usb3_req->req.length, usb3_req->req.actual);\r\nusb3_request_done_pipen(usb3, usb3_ep, usb3_req, 0);\r\n}\r\n}\r\nstatic void usb3_irq_epc_pipen_bfrdy(struct renesas_usb3 *usb3, int num)\r\n{\r\nstruct renesas_usb3_ep *usb3_ep = usb3_get_ep(usb3, num);\r\nstruct renesas_usb3_request *usb3_req = usb3_get_request(usb3_ep);\r\nif (!usb3_req)\r\nreturn;\r\nif (usb3_ep->dir_in) {\r\nif (!usb3_write_pipe(usb3_ep, usb3_req, USB3_PN_WRITE))\r\nusb3_clear_bit(usb3, PN_INT_BFRDY, USB3_PN_INT_ENA);\r\n} else {\r\nif (!usb3_read_pipe(usb3_ep, usb3_req, USB3_PN_READ))\r\nusb3_request_done_pipen(usb3, usb3_ep, usb3_req, 0);\r\n}\r\n}\r\nstatic void usb3_irq_epc_pipen(struct renesas_usb3 *usb3, int num)\r\n{\r\nu32 pn_int_sta;\r\nif (usb3_pn_change(usb3, num) < 0)\r\nreturn;\r\npn_int_sta = usb3_read(usb3, USB3_PN_INT_STA);\r\npn_int_sta &= usb3_read(usb3, USB3_PN_INT_ENA);\r\nusb3_write(usb3, pn_int_sta, USB3_PN_INT_STA);\r\nif (pn_int_sta & PN_INT_LSTTR)\r\nusb3_irq_epc_pipen_lsttr(usb3, num);\r\nif (pn_int_sta & PN_INT_BFRDY)\r\nusb3_irq_epc_pipen_bfrdy(usb3, num);\r\n}\r\nstatic void usb3_irq_epc_int_2(struct renesas_usb3 *usb3, u32 int_sta_2)\r\n{\r\nint i;\r\nfor (i = 0; i < usb3->num_usb3_eps; i++) {\r\nif (int_sta_2 & USB_INT_2_PIPE(i)) {\r\nif (!i)\r\nusb3_irq_epc_pipe0(usb3);\r\nelse\r\nusb3_irq_epc_pipen(usb3, i);\r\n}\r\n}\r\n}\r\nstatic void usb3_irq_epc(struct renesas_usb3 *usb3)\r\n{\r\nu32 int_sta_1 = usb3_read(usb3, USB3_USB_INT_STA_1);\r\nu32 int_sta_2 = usb3_read(usb3, USB3_USB_INT_STA_2);\r\nint_sta_1 &= usb3_read(usb3, USB3_USB_INT_ENA_1);\r\nif (int_sta_1) {\r\nusb3_write(usb3, int_sta_1, USB3_USB_INT_STA_1);\r\nusb3_irq_epc_int_1(usb3, int_sta_1);\r\n}\r\nint_sta_2 &= usb3_read(usb3, USB3_USB_INT_ENA_2);\r\nif (int_sta_2)\r\nusb3_irq_epc_int_2(usb3, int_sta_2);\r\n}\r\nstatic irqreturn_t renesas_usb3_irq(int irq, void *_usb3)\r\n{\r\nstruct renesas_usb3 *usb3 = _usb3;\r\nirqreturn_t ret = IRQ_NONE;\r\nu32 axi_int_sta = usb3_read(usb3, USB3_AXI_INT_STA);\r\nif (axi_int_sta & AXI_INT_EPCINT) {\r\nusb3_irq_epc(usb3);\r\nret = IRQ_HANDLED;\r\n}\r\nreturn ret;\r\n}\r\nstatic void usb3_write_pn_mod(struct renesas_usb3_ep *usb3_ep,\r\nconst struct usb_endpoint_descriptor *desc)\r\n{\r\nstruct renesas_usb3 *usb3 = usb3_ep_to_usb3(usb3_ep);\r\nu32 val = 0;\r\nval |= usb3_ep->dir_in ? PN_MOD_DIR : 0;\r\nval |= PN_MOD_TYPE(usb_endpoint_type(desc));\r\nval |= PN_MOD_EPNUM(usb_endpoint_num(desc));\r\nusb3_write(usb3, val, USB3_PN_MOD);\r\n}\r\nstatic u32 usb3_calc_ramarea(int ram_size)\r\n{\r\nWARN_ON(ram_size > SZ_16K);\r\nif (ram_size <= SZ_1K)\r\nreturn PN_RAMMAP_RAMAREA_1KB;\r\nelse if (ram_size <= SZ_2K)\r\nreturn PN_RAMMAP_RAMAREA_2KB;\r\nelse if (ram_size <= SZ_4K)\r\nreturn PN_RAMMAP_RAMAREA_4KB;\r\nelse if (ram_size <= SZ_8K)\r\nreturn PN_RAMMAP_RAMAREA_8KB;\r\nelse\r\nreturn PN_RAMMAP_RAMAREA_16KB;\r\n}\r\nstatic u32 usb3_calc_rammap_val(struct renesas_usb3_ep *usb3_ep,\r\nconst struct usb_endpoint_descriptor *desc)\r\n{\r\nreturn usb3_ep->rammap_val | PN_RAMMAP_MPKT(usb_endpoint_maxp(desc));\r\n}\r\nstatic int usb3_enable_pipe_n(struct renesas_usb3_ep *usb3_ep,\r\nconst struct usb_endpoint_descriptor *desc)\r\n{\r\nstruct renesas_usb3 *usb3 = usb3_ep_to_usb3(usb3_ep);\r\nunsigned long flags;\r\nusb3_ep->dir_in = usb_endpoint_dir_in(desc);\r\nspin_lock_irqsave(&usb3->lock, flags);\r\nif (!usb3_pn_change(usb3, usb3_ep->num)) {\r\nusb3_write_pn_mod(usb3_ep, desc);\r\nusb3_write(usb3, usb3_calc_rammap_val(usb3_ep, desc),\r\nUSB3_PN_RAMMAP);\r\nusb3_pn_con_clear(usb3);\r\nusb3_set_bit(usb3, PN_CON_EN, USB3_PN_CON);\r\n}\r\nspin_unlock_irqrestore(&usb3->lock, flags);\r\nreturn 0;\r\n}\r\nstatic int usb3_disable_pipe_n(struct renesas_usb3_ep *usb3_ep)\r\n{\r\nstruct renesas_usb3 *usb3 = usb3_ep_to_usb3(usb3_ep);\r\nunsigned long flags;\r\nusb3_ep->halt = false;\r\nspin_lock_irqsave(&usb3->lock, flags);\r\nif (!usb3_pn_change(usb3, usb3_ep->num)) {\r\nusb3_write(usb3, 0, USB3_PN_RAMMAP);\r\nusb3_clear_bit(usb3, PN_CON_EN, USB3_PN_CON);\r\n}\r\nspin_unlock_irqrestore(&usb3->lock, flags);\r\nreturn 0;\r\n}\r\nstatic int renesas_usb3_ep_enable(struct usb_ep *_ep,\r\nconst struct usb_endpoint_descriptor *desc)\r\n{\r\nstruct renesas_usb3_ep *usb3_ep = usb_ep_to_usb3_ep(_ep);\r\nreturn usb3_enable_pipe_n(usb3_ep, desc);\r\n}\r\nstatic int renesas_usb3_ep_disable(struct usb_ep *_ep)\r\n{\r\nstruct renesas_usb3_ep *usb3_ep = usb_ep_to_usb3_ep(_ep);\r\nstruct renesas_usb3_request *usb3_req;\r\ndo {\r\nusb3_req = usb3_get_request(usb3_ep);\r\nif (!usb3_req)\r\nbreak;\r\nusb3_request_done(usb3_ep, usb3_req, -ESHUTDOWN);\r\n} while (1);\r\nreturn usb3_disable_pipe_n(usb3_ep);\r\n}\r\nstatic struct usb_request *__renesas_usb3_ep_alloc_request(gfp_t gfp_flags)\r\n{\r\nstruct renesas_usb3_request *usb3_req;\r\nusb3_req = kzalloc(sizeof(struct renesas_usb3_request), gfp_flags);\r\nif (!usb3_req)\r\nreturn NULL;\r\nINIT_LIST_HEAD(&usb3_req->queue);\r\nreturn &usb3_req->req;\r\n}\r\nstatic void __renesas_usb3_ep_free_request(struct usb_request *_req)\r\n{\r\nstruct renesas_usb3_request *usb3_req = usb_req_to_usb3_req(_req);\r\nkfree(usb3_req);\r\n}\r\nstatic struct usb_request *renesas_usb3_ep_alloc_request(struct usb_ep *_ep,\r\ngfp_t gfp_flags)\r\n{\r\nreturn __renesas_usb3_ep_alloc_request(gfp_flags);\r\n}\r\nstatic void renesas_usb3_ep_free_request(struct usb_ep *_ep,\r\nstruct usb_request *_req)\r\n{\r\n__renesas_usb3_ep_free_request(_req);\r\n}\r\nstatic int renesas_usb3_ep_dequeue(struct usb_ep *_ep, struct usb_request *_req)\r\n{\r\nstruct renesas_usb3_ep *usb3_ep = usb_ep_to_usb3_ep(_ep);\r\nstruct renesas_usb3_request *usb3_req = usb_req_to_usb3_req(_req);\r\nstruct renesas_usb3 *usb3 = usb3_ep_to_usb3(usb3_ep);\r\ndev_dbg(usb3_to_dev(usb3), "ep_dequeue: ep%2d, %u\n", usb3_ep->num,\r\n_req->length);\r\nusb3_request_done_pipen(usb3, usb3_ep, usb3_req, -ECONNRESET);\r\nreturn 0;\r\n}\r\nstatic int renesas_usb3_ep_set_halt(struct usb_ep *_ep, int value)\r\n{\r\nreturn usb3_set_halt(usb_ep_to_usb3_ep(_ep), !!value, false);\r\n}\r\nstatic int renesas_usb3_ep_set_wedge(struct usb_ep *_ep)\r\n{\r\nstruct renesas_usb3_ep *usb3_ep = usb_ep_to_usb3_ep(_ep);\r\nusb3_ep->wedge = true;\r\nreturn usb3_set_halt(usb3_ep, true, false);\r\n}\r\nstatic void renesas_usb3_ep_fifo_flush(struct usb_ep *_ep)\r\n{\r\nstruct renesas_usb3_ep *usb3_ep = usb_ep_to_usb3_ep(_ep);\r\nstruct renesas_usb3 *usb3 = usb3_ep_to_usb3(usb3_ep);\r\nunsigned long flags;\r\nif (usb3_ep->num) {\r\nspin_lock_irqsave(&usb3->lock, flags);\r\nif (!usb3_pn_change(usb3, usb3_ep->num)) {\r\nusb3_pn_con_clear(usb3);\r\nusb3_set_bit(usb3, PN_CON_EN, USB3_PN_CON);\r\n}\r\nspin_unlock_irqrestore(&usb3->lock, flags);\r\n} else {\r\nusb3_p0_con_clear_buffer(usb3);\r\n}\r\n}\r\nstatic int renesas_usb3_start(struct usb_gadget *gadget,\r\nstruct usb_gadget_driver *driver)\r\n{\r\nstruct renesas_usb3 *usb3;\r\nif (!driver || driver->max_speed < USB_SPEED_FULL ||\r\n!driver->setup)\r\nreturn -EINVAL;\r\nusb3 = gadget_to_renesas_usb3(gadget);\r\nusb3->driver = driver;\r\nrenesas_usb3_init_controller(usb3);\r\nreturn 0;\r\n}\r\nstatic int renesas_usb3_stop(struct usb_gadget *gadget)\r\n{\r\nstruct renesas_usb3 *usb3 = gadget_to_renesas_usb3(gadget);\r\nunsigned long flags;\r\nspin_lock_irqsave(&usb3->lock, flags);\r\nusb3->softconnect = false;\r\nusb3->gadget.speed = USB_SPEED_UNKNOWN;\r\nusb3->driver = NULL;\r\nrenesas_usb3_stop_controller(usb3);\r\nspin_unlock_irqrestore(&usb3->lock, flags);\r\nreturn 0;\r\n}\r\nstatic int renesas_usb3_get_frame(struct usb_gadget *_gadget)\r\n{\r\nreturn -EOPNOTSUPP;\r\n}\r\nstatic int renesas_usb3_pullup(struct usb_gadget *gadget, int is_on)\r\n{\r\nstruct renesas_usb3 *usb3 = gadget_to_renesas_usb3(gadget);\r\nusb3->softconnect = !!is_on;\r\nreturn 0;\r\n}\r\nstatic int renesas_usb3_set_selfpowered(struct usb_gadget *gadget, int is_self)\r\n{\r\ngadget->is_selfpowered = !!is_self;\r\nreturn 0;\r\n}\r\nstatic int renesas_usb3_remove(struct platform_device *pdev)\r\n{\r\nstruct renesas_usb3 *usb3 = platform_get_drvdata(pdev);\r\npm_runtime_put(&pdev->dev);\r\npm_runtime_disable(&pdev->dev);\r\nusb_del_gadget_udc(&usb3->gadget);\r\n__renesas_usb3_ep_free_request(usb3->ep0_req);\r\nreturn 0;\r\n}\r\nstatic int renesas_usb3_init_ep(struct renesas_usb3 *usb3, struct device *dev,\r\nconst struct renesas_usb3_priv *priv)\r\n{\r\nstruct renesas_usb3_ep *usb3_ep;\r\nint i;\r\nusb3->num_usb3_eps = priv->ramsize_per_ramif * priv->num_ramif * 2 /\r\npriv->ramsize_per_pipe + 1;\r\nif (usb3->num_usb3_eps > USB3_MAX_NUM_PIPES)\r\nusb3->num_usb3_eps = USB3_MAX_NUM_PIPES;\r\nusb3->usb3_ep = devm_kzalloc(dev, sizeof(*usb3_ep) * usb3->num_usb3_eps,\r\nGFP_KERNEL);\r\nif (!usb3->usb3_ep)\r\nreturn -ENOMEM;\r\ndev_dbg(dev, "%s: num_usb3_eps = %d\n", __func__, usb3->num_usb3_eps);\r\nusb3_for_each_ep(usb3_ep, usb3, i) {\r\nsnprintf(usb3_ep->ep_name, sizeof(usb3_ep->ep_name), "ep%d", i);\r\nusb3_ep->usb3 = usb3;\r\nusb3_ep->num = i;\r\nusb3_ep->ep.name = usb3_ep->ep_name;\r\nusb3_ep->ep.ops = &renesas_usb3_ep_ops;\r\nINIT_LIST_HEAD(&usb3_ep->queue);\r\nINIT_LIST_HEAD(&usb3_ep->ep.ep_list);\r\nif (!i) {\r\nusb3->gadget.ep0 = &usb3_ep->ep;\r\nusb_ep_set_maxpacket_limit(&usb3_ep->ep,\r\nUSB3_EP0_HSFS_MAX_PACKET_SIZE);\r\nusb3_ep->ep.caps.type_control = true;\r\nusb3_ep->ep.caps.dir_in = true;\r\nusb3_ep->ep.caps.dir_out = true;\r\ncontinue;\r\n}\r\nusb_ep_set_maxpacket_limit(&usb3_ep->ep, ~0);\r\nlist_add_tail(&usb3_ep->ep.ep_list, &usb3->gadget.ep_list);\r\nusb3_ep->ep.caps.type_bulk = true;\r\nusb3_ep->ep.caps.type_int = true;\r\nif (i & 1)\r\nusb3_ep->ep.caps.dir_in = true;\r\nelse\r\nusb3_ep->ep.caps.dir_out = true;\r\n}\r\nreturn 0;\r\n}\r\nstatic void renesas_usb3_init_ram(struct renesas_usb3 *usb3, struct device *dev,\r\nconst struct renesas_usb3_priv *priv)\r\n{\r\nstruct renesas_usb3_ep *usb3_ep;\r\nint i;\r\nu32 ramif[2], basead[2];\r\nu32 *cur_ramif, *cur_basead;\r\nu32 val;\r\nmemset(ramif, 0, sizeof(ramif));\r\nmemset(basead, 0, sizeof(basead));\r\nusb3_for_each_ep(usb3_ep, usb3, i) {\r\nif (!i)\r\ncontinue;\r\nif (usb3_ep->ep.caps.dir_in) {\r\ncur_ramif = &ramif[0];\r\ncur_basead = &basead[0];\r\n} else {\r\ncur_ramif = &ramif[1];\r\ncur_basead = &basead[1];\r\n}\r\nif (*cur_basead > priv->ramsize_per_ramif)\r\ncontinue;\r\nval = PN_RAMMAP_RAMIF(*cur_ramif);\r\nval |= usb3_calc_ramarea(priv->ramsize_per_pipe);\r\nval |= PN_RAMMAP_BASEAD(*cur_basead);\r\nusb3_ep->rammap_val = val;\r\ndev_dbg(dev, "ep%2d: val = %08x, ramif = %d, base = %x\n",\r\ni, val, *cur_ramif, *cur_basead);\r\nif (*cur_ramif + 1 == priv->num_ramif) {\r\n*cur_ramif = 0;\r\n*cur_basead += priv->ramsize_per_pipe;\r\n} else {\r\n(*cur_ramif)++;\r\n}\r\n}\r\n}\r\nstatic int renesas_usb3_probe(struct platform_device *pdev)\r\n{\r\nstruct renesas_usb3 *usb3;\r\nstruct resource *res;\r\nconst struct of_device_id *match;\r\nint irq, ret;\r\nconst struct renesas_usb3_priv *priv;\r\nmatch = of_match_node(usb3_of_match, pdev->dev.of_node);\r\nif (!match)\r\nreturn -ENODEV;\r\npriv = match->data;\r\nirq = platform_get_irq(pdev, 0);\r\nif (irq < 0)\r\nreturn -ENODEV;\r\nusb3 = devm_kzalloc(&pdev->dev, sizeof(*usb3), GFP_KERNEL);\r\nif (!usb3)\r\nreturn -ENOMEM;\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nusb3->reg = devm_ioremap_resource(&pdev->dev, res);\r\nif (IS_ERR(usb3->reg))\r\nreturn PTR_ERR(usb3->reg);\r\nplatform_set_drvdata(pdev, usb3);\r\nspin_lock_init(&usb3->lock);\r\nusb3->gadget.ops = &renesas_usb3_gadget_ops;\r\nusb3->gadget.name = udc_name;\r\nusb3->gadget.max_speed = USB_SPEED_SUPER;\r\nINIT_LIST_HEAD(&usb3->gadget.ep_list);\r\nret = renesas_usb3_init_ep(usb3, &pdev->dev, priv);\r\nif (ret < 0)\r\nreturn ret;\r\nrenesas_usb3_init_ram(usb3, &pdev->dev, priv);\r\nret = devm_request_irq(&pdev->dev, irq, renesas_usb3_irq, 0,\r\ndev_name(&pdev->dev), usb3);\r\nif (ret < 0)\r\nreturn ret;\r\nusb3->ep0_req = __renesas_usb3_ep_alloc_request(GFP_KERNEL);\r\nif (!usb3->ep0_req)\r\nreturn -ENOMEM;\r\nret = usb_add_gadget_udc(&pdev->dev, &usb3->gadget);\r\nif (ret < 0)\r\ngoto err_add_udc;\r\nusb3->workaround_for_vbus = priv->workaround_for_vbus;\r\npm_runtime_enable(&pdev->dev);\r\npm_runtime_get_sync(&pdev->dev);\r\ndev_info(&pdev->dev, "probed\n");\r\nreturn 0;\r\nerr_add_udc:\r\n__renesas_usb3_ep_free_request(usb3->ep0_req);\r\nreturn ret;\r\n}
