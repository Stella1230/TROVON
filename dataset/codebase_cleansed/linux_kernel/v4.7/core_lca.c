static int\r\nmk_conf_addr(struct pci_bus *pbus, unsigned int device_fn, int where,\r\nunsigned long *pci_addr)\r\n{\r\nunsigned long addr;\r\nu8 bus = pbus->number;\r\nif (bus == 0) {\r\nint device = device_fn >> 3;\r\nint func = device_fn & 0x7;\r\nif (device > 12) {\r\nreturn -1;\r\n}\r\n*(vulp)LCA_IOC_CONF = 0;\r\naddr = (1 << (11 + device)) | (func << 8) | where;\r\n} else {\r\n*(vulp)LCA_IOC_CONF = 1;\r\naddr = (bus << 16) | (device_fn << 8) | where;\r\n}\r\n*pci_addr = addr;\r\nreturn 0;\r\n}\r\nstatic unsigned int\r\nconf_read(unsigned long addr)\r\n{\r\nunsigned long flags, code, stat0;\r\nunsigned int value;\r\nlocal_irq_save(flags);\r\nstat0 = *(vulp)LCA_IOC_STAT0;\r\n*(vulp)LCA_IOC_STAT0 = stat0;\r\nmb();\r\nvalue = *(vuip)addr;\r\ndraina();\r\nstat0 = *(vulp)LCA_IOC_STAT0;\r\nif (stat0 & LCA_IOC_STAT0_ERR) {\r\ncode = ((stat0 >> LCA_IOC_STAT0_CODE_SHIFT)\r\n& LCA_IOC_STAT0_CODE_MASK);\r\nif (code != 1) {\r\nprintk("lca.c:conf_read: got stat0=%lx\n", stat0);\r\n}\r\n*(vulp)LCA_IOC_STAT0 = stat0;\r\nmb();\r\nwrmces(0x7);\r\nvalue = 0xffffffff;\r\n}\r\nlocal_irq_restore(flags);\r\nreturn value;\r\n}\r\nstatic void\r\nconf_write(unsigned long addr, unsigned int value)\r\n{\r\nunsigned long flags, code, stat0;\r\nlocal_irq_save(flags);\r\nstat0 = *(vulp)LCA_IOC_STAT0;\r\n*(vulp)LCA_IOC_STAT0 = stat0;\r\nmb();\r\n*(vuip)addr = value;\r\ndraina();\r\nstat0 = *(vulp)LCA_IOC_STAT0;\r\nif (stat0 & LCA_IOC_STAT0_ERR) {\r\ncode = ((stat0 >> LCA_IOC_STAT0_CODE_SHIFT)\r\n& LCA_IOC_STAT0_CODE_MASK);\r\nif (code != 1) {\r\nprintk("lca.c:conf_write: got stat0=%lx\n", stat0);\r\n}\r\n*(vulp)LCA_IOC_STAT0 = stat0;\r\nmb();\r\nwrmces(0x7);\r\n}\r\nlocal_irq_restore(flags);\r\n}\r\nstatic int\r\nlca_read_config(struct pci_bus *bus, unsigned int devfn, int where,\r\nint size, u32 *value)\r\n{\r\nunsigned long addr, pci_addr;\r\nlong mask;\r\nint shift;\r\nif (mk_conf_addr(bus, devfn, where, &pci_addr))\r\nreturn PCIBIOS_DEVICE_NOT_FOUND;\r\nshift = (where & 3) * 8;\r\nmask = (size - 1) * 8;\r\naddr = (pci_addr << 5) + mask + LCA_CONF;\r\n*value = conf_read(addr) >> (shift);\r\nreturn PCIBIOS_SUCCESSFUL;\r\n}\r\nstatic int\r\nlca_write_config(struct pci_bus *bus, unsigned int devfn, int where, int size,\r\nu32 value)\r\n{\r\nunsigned long addr, pci_addr;\r\nlong mask;\r\nif (mk_conf_addr(bus, devfn, where, &pci_addr))\r\nreturn PCIBIOS_DEVICE_NOT_FOUND;\r\nmask = (size - 1) * 8;\r\naddr = (pci_addr << 5) + mask + LCA_CONF;\r\nconf_write(addr, value << ((where & 3) * 8));\r\nreturn PCIBIOS_SUCCESSFUL;\r\n}\r\nvoid\r\nlca_pci_tbi(struct pci_controller *hose, dma_addr_t start, dma_addr_t end)\r\n{\r\nwmb();\r\n*(vulp)LCA_IOC_TBIA = 0;\r\nmb();\r\n}\r\nvoid __init\r\nlca_init_arch(void)\r\n{\r\nstruct pci_controller *hose;\r\npci_isa_hose = hose = alloc_pci_controller();\r\nhose->io_space = &ioport_resource;\r\nhose->mem_space = &iomem_resource;\r\nhose->index = 0;\r\nhose->sparse_mem_base = LCA_SPARSE_MEM - IDENT_ADDR;\r\nhose->dense_mem_base = LCA_DENSE_MEM - IDENT_ADDR;\r\nhose->sparse_io_base = LCA_IO - IDENT_ADDR;\r\nhose->dense_io_base = 0;\r\nhose->sg_isa = iommu_arena_new(hose, 0x00800000, 0x00800000, 0);\r\nhose->sg_pci = NULL;\r\n__direct_map_base = 0x40000000;\r\n__direct_map_size = 0x40000000;\r\n*(vulp)LCA_IOC_W_BASE0 = hose->sg_isa->dma_base | (3UL << 32);\r\n*(vulp)LCA_IOC_W_MASK0 = (hose->sg_isa->size - 1) & 0xfff00000;\r\n*(vulp)LCA_IOC_T_BASE0 = virt_to_phys(hose->sg_isa->ptes);\r\n*(vulp)LCA_IOC_W_BASE1 = __direct_map_base | (2UL << 32);\r\n*(vulp)LCA_IOC_W_MASK1 = (__direct_map_size - 1) & 0xfff00000;\r\n*(vulp)LCA_IOC_T_BASE1 = 0;\r\n*(vulp)LCA_IOC_TB_ENA = 0x80;\r\nlca_pci_tbi(hose, 0, -1);\r\n*(vulp)LCA_IOC_PAR_DIS = 1UL<<5;\r\nif (alpha_using_srm)\r\nsrm_hae = 0x80000000UL;\r\n}\r\nstatic void\r\nmem_error(unsigned long esr, unsigned long ear)\r\n{\r\nprintk(" %s %s error to %s occurred at address %x\n",\r\n((esr & ESR_CEE) ? "Correctable" :\r\n(esr & ESR_UEE) ? "Uncorrectable" : "A"),\r\n(esr & ESR_WRE) ? "write" : "read",\r\n(esr & ESR_SOR) ? "memory" : "b-cache",\r\n(unsigned) (ear & 0x1ffffff8));\r\nif (esr & ESR_CTE) {\r\nprintk(" A b-cache tag parity error was detected.\n");\r\n}\r\nif (esr & ESR_MSE) {\r\nprintk(" Several other correctable errors occurred.\n");\r\n}\r\nif (esr & ESR_MHE) {\r\nprintk(" Several other uncorrectable errors occurred.\n");\r\n}\r\nif (esr & ESR_NXM) {\r\nprintk(" Attempted to access non-existent memory.\n");\r\n}\r\n}\r\nstatic void\r\nioc_error(__u32 stat0, __u32 stat1)\r\n{\r\nstatic const char * const pci_cmd[] = {\r\n"Interrupt Acknowledge", "Special", "I/O Read", "I/O Write",\r\n"Rsvd 1", "Rsvd 2", "Memory Read", "Memory Write", "Rsvd3",\r\n"Rsvd4", "Configuration Read", "Configuration Write",\r\n"Memory Read Multiple", "Dual Address", "Memory Read Line",\r\n"Memory Write and Invalidate"\r\n};\r\nstatic const char * const err_name[] = {\r\n"exceeded retry limit", "no device", "bad data parity",\r\n"target abort", "bad address parity", "page table read error",\r\n"invalid page", "data error"\r\n};\r\nunsigned code = (stat0 & IOC_CODE) >> IOC_CODE_SHIFT;\r\nunsigned cmd = (stat0 & IOC_CMD) >> IOC_CMD_SHIFT;\r\nprintk(" %s initiated PCI %s cycle to address %x"\r\n" failed due to %s.\n",\r\ncode > 3 ? "PCI" : "CPU", pci_cmd[cmd], stat1, err_name[code]);\r\nif (code == 5 || code == 6) {\r\nprintk(" (Error occurred at PCI memory address %x.)\n",\r\n(stat0 & ~IOC_P_NBR));\r\n}\r\nif (stat0 & IOC_LOST) {\r\nprintk(" Other PCI errors occurred simultaneously.\n");\r\n}\r\n}\r\nvoid\r\nlca_machine_check(unsigned long vector, unsigned long la_ptr)\r\n{\r\nconst char * reason;\r\nunion el_lca el;\r\nel.c = (struct el_common *) la_ptr;\r\nwrmces(rdmces());\r\nprintk(KERN_CRIT "LCA machine check: vector=%#lx pc=%#lx code=%#x\n",\r\nvector, get_irq_regs()->pc, (unsigned int) el.c->code);\r\nswitch ((unsigned int) el.c->code) {\r\ncase MCHK_K_TPERR: reason = "tag parity error"; break;\r\ncase MCHK_K_TCPERR: reason = "tag control parity error"; break;\r\ncase MCHK_K_HERR: reason = "access to non-existent memory"; break;\r\ncase MCHK_K_ECC_C: reason = "correctable ECC error"; break;\r\ncase MCHK_K_ECC_NC: reason = "non-correctable ECC error"; break;\r\ncase MCHK_K_CACKSOFT: reason = "MCHK_K_CACKSOFT"; break;\r\ncase MCHK_K_BUGCHECK: reason = "illegal exception in PAL mode"; break;\r\ncase MCHK_K_OS_BUGCHECK: reason = "callsys in kernel mode"; break;\r\ncase MCHK_K_DCPERR: reason = "d-cache parity error"; break;\r\ncase MCHK_K_ICPERR: reason = "i-cache parity error"; break;\r\ncase MCHK_K_SIO_SERR: reason = "SIO SERR occurred on PCI bus"; break;\r\ncase MCHK_K_SIO_IOCHK: reason = "SIO IOCHK occurred on ISA bus"; break;\r\ncase MCHK_K_DCSR: reason = "MCHK_K_DCSR"; break;\r\ncase MCHK_K_UNKNOWN:\r\ndefault: reason = "unknown"; break;\r\n}\r\nswitch (el.c->size) {\r\ncase sizeof(struct el_lca_mcheck_short):\r\nprintk(KERN_CRIT\r\n" Reason: %s (short frame%s, dc_stat=%#lx):\n",\r\nreason, el.c->retry ? ", retryable" : "",\r\nel.s->dc_stat);\r\nif (el.s->esr & ESR_EAV) {\r\nmem_error(el.s->esr, el.s->ear);\r\n}\r\nif (el.s->ioc_stat0 & IOC_ERR) {\r\nioc_error(el.s->ioc_stat0, el.s->ioc_stat1);\r\n}\r\nbreak;\r\ncase sizeof(struct el_lca_mcheck_long):\r\nprintk(KERN_CRIT " Reason: %s (long frame%s):\n",\r\nreason, el.c->retry ? ", retryable" : "");\r\nprintk(KERN_CRIT\r\n" reason: %#lx exc_addr: %#lx dc_stat: %#lx\n",\r\nel.l->pt[0], el.l->exc_addr, el.l->dc_stat);\r\nprintk(KERN_CRIT " car: %#lx\n", el.l->car);\r\nif (el.l->esr & ESR_EAV) {\r\nmem_error(el.l->esr, el.l->ear);\r\n}\r\nif (el.l->ioc_stat0 & IOC_ERR) {\r\nioc_error(el.l->ioc_stat0, el.l->ioc_stat1);\r\n}\r\nbreak;\r\ndefault:\r\nprintk(KERN_CRIT " Unknown errorlog size %d\n", el.c->size);\r\n}\r\n#ifdef CONFIG_VERBOSE_MCHECK\r\nif (alpha_verbose_mcheck > 1) {\r\nunsigned long * ptr = (unsigned long *) la_ptr;\r\nlong i;\r\nfor (i = 0; i < el.c->size / sizeof(long); i += 2) {\r\nprintk(KERN_CRIT " +%8lx %016lx %016lx\n",\r\ni*sizeof(long), ptr[i], ptr[i+1]);\r\n}\r\n}\r\n#endif\r\n}\r\nvoid\r\nlca_clock_print(void)\r\n{\r\nlong pmr_reg;\r\npmr_reg = LCA_READ_PMR;\r\nprintk("Status of clock control:\n");\r\nprintk("\tPrimary clock divisor\t0x%lx\n", LCA_GET_PRIMARY(pmr_reg));\r\nprintk("\tOverride clock divisor\t0x%lx\n", LCA_GET_OVERRIDE(pmr_reg));\r\nprintk("\tInterrupt override is %s\n",\r\n(pmr_reg & LCA_PMR_INTO) ? "on" : "off");\r\nprintk("\tDMA override is %s\n",\r\n(pmr_reg & LCA_PMR_DMAO) ? "on" : "off");\r\n}\r\nint\r\nlca_get_clock(void)\r\n{\r\nlong pmr_reg;\r\npmr_reg = LCA_READ_PMR;\r\nreturn(LCA_GET_PRIMARY(pmr_reg));\r\n}\r\nvoid\r\nlca_clock_fiddle(int divisor)\r\n{\r\nlong pmr_reg;\r\npmr_reg = LCA_READ_PMR;\r\nLCA_SET_PRIMARY_CLOCK(pmr_reg, divisor);\r\nLCA_WRITE_PMR(pmr_reg);\r\nmb();\r\n}
