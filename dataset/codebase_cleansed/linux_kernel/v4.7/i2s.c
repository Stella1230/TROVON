static inline bool is_secondary(struct i2s_dai *i2s)\r\n{\r\nreturn i2s->pri_dai ? true : false;\r\n}\r\nstatic inline bool is_slave(struct i2s_dai *i2s)\r\n{\r\nu32 mod = readl(i2s->addr + I2SMOD);\r\nreturn (mod & (1 << i2s->variant_regs->mss_off)) ? true : false;\r\n}\r\nstatic inline bool tx_active(struct i2s_dai *i2s)\r\n{\r\nu32 active;\r\nif (!i2s)\r\nreturn false;\r\nactive = readl(i2s->addr + I2SCON);\r\nif (is_secondary(i2s))\r\nactive &= CON_TXSDMA_ACTIVE;\r\nelse\r\nactive &= CON_TXDMA_ACTIVE;\r\nreturn active ? true : false;\r\n}\r\nstatic inline struct i2s_dai *get_other_dai(struct i2s_dai *i2s)\r\n{\r\nreturn i2s->pri_dai ? : i2s->sec_dai;\r\n}\r\nstatic inline bool other_tx_active(struct i2s_dai *i2s)\r\n{\r\nstruct i2s_dai *other = get_other_dai(i2s);\r\nreturn tx_active(other);\r\n}\r\nstatic inline bool any_tx_active(struct i2s_dai *i2s)\r\n{\r\nreturn tx_active(i2s) || other_tx_active(i2s);\r\n}\r\nstatic inline bool rx_active(struct i2s_dai *i2s)\r\n{\r\nu32 active;\r\nif (!i2s)\r\nreturn false;\r\nactive = readl(i2s->addr + I2SCON) & CON_RXDMA_ACTIVE;\r\nreturn active ? true : false;\r\n}\r\nstatic inline bool other_rx_active(struct i2s_dai *i2s)\r\n{\r\nstruct i2s_dai *other = get_other_dai(i2s);\r\nreturn rx_active(other);\r\n}\r\nstatic inline bool any_rx_active(struct i2s_dai *i2s)\r\n{\r\nreturn rx_active(i2s) || other_rx_active(i2s);\r\n}\r\nstatic inline bool other_active(struct i2s_dai *i2s)\r\n{\r\nreturn other_rx_active(i2s) || other_tx_active(i2s);\r\n}\r\nstatic inline bool this_active(struct i2s_dai *i2s)\r\n{\r\nreturn tx_active(i2s) || rx_active(i2s);\r\n}\r\nstatic inline bool any_active(struct i2s_dai *i2s)\r\n{\r\nreturn this_active(i2s) || other_active(i2s);\r\n}\r\nstatic inline struct i2s_dai *to_info(struct snd_soc_dai *dai)\r\n{\r\nreturn snd_soc_dai_get_drvdata(dai);\r\n}\r\nstatic inline bool is_opened(struct i2s_dai *i2s)\r\n{\r\nif (i2s && (i2s->mode & DAI_OPENED))\r\nreturn true;\r\nelse\r\nreturn false;\r\n}\r\nstatic inline bool is_manager(struct i2s_dai *i2s)\r\n{\r\nif (is_opened(i2s) && (i2s->mode & DAI_MANAGER))\r\nreturn true;\r\nelse\r\nreturn false;\r\n}\r\nstatic inline unsigned get_rfs(struct i2s_dai *i2s)\r\n{\r\nu32 rfs;\r\nrfs = readl(i2s->addr + I2SMOD) >> i2s->variant_regs->rfs_off;\r\nrfs &= i2s->variant_regs->rfs_mask;\r\nswitch (rfs) {\r\ncase 7: return 192;\r\ncase 6: return 96;\r\ncase 5: return 128;\r\ncase 4: return 64;\r\ncase 3: return 768;\r\ncase 2: return 384;\r\ncase 1: return 512;\r\ndefault: return 256;\r\n}\r\n}\r\nstatic inline void set_rfs(struct i2s_dai *i2s, unsigned rfs)\r\n{\r\nu32 mod = readl(i2s->addr + I2SMOD);\r\nint rfs_shift = i2s->variant_regs->rfs_off;\r\nmod &= ~(i2s->variant_regs->rfs_mask << rfs_shift);\r\nswitch (rfs) {\r\ncase 192:\r\nmod |= (EXYNOS7_MOD_RCLK_192FS << rfs_shift);\r\nbreak;\r\ncase 96:\r\nmod |= (EXYNOS7_MOD_RCLK_96FS << rfs_shift);\r\nbreak;\r\ncase 128:\r\nmod |= (EXYNOS7_MOD_RCLK_128FS << rfs_shift);\r\nbreak;\r\ncase 64:\r\nmod |= (EXYNOS7_MOD_RCLK_64FS << rfs_shift);\r\nbreak;\r\ncase 768:\r\nmod |= (MOD_RCLK_768FS << rfs_shift);\r\nbreak;\r\ncase 512:\r\nmod |= (MOD_RCLK_512FS << rfs_shift);\r\nbreak;\r\ncase 384:\r\nmod |= (MOD_RCLK_384FS << rfs_shift);\r\nbreak;\r\ndefault:\r\nmod |= (MOD_RCLK_256FS << rfs_shift);\r\nbreak;\r\n}\r\nwritel(mod, i2s->addr + I2SMOD);\r\n}\r\nstatic inline unsigned get_bfs(struct i2s_dai *i2s)\r\n{\r\nu32 bfs;\r\nbfs = readl(i2s->addr + I2SMOD) >> i2s->variant_regs->bfs_off;\r\nbfs &= i2s->variant_regs->bfs_mask;\r\nswitch (bfs) {\r\ncase 8: return 256;\r\ncase 7: return 192;\r\ncase 6: return 128;\r\ncase 5: return 96;\r\ncase 4: return 64;\r\ncase 3: return 24;\r\ncase 2: return 16;\r\ncase 1: return 48;\r\ndefault: return 32;\r\n}\r\n}\r\nstatic inline void set_bfs(struct i2s_dai *i2s, unsigned bfs)\r\n{\r\nu32 mod = readl(i2s->addr + I2SMOD);\r\nint tdm = i2s->quirks & QUIRK_SUPPORTS_TDM;\r\nint bfs_shift = i2s->variant_regs->bfs_off;\r\nif (!tdm && bfs > 48) {\r\ndev_err(&i2s->pdev->dev, "Unsupported BCLK divider\n");\r\nreturn;\r\n}\r\nmod &= ~(i2s->variant_regs->bfs_mask << bfs_shift);\r\nswitch (bfs) {\r\ncase 48:\r\nmod |= (MOD_BCLK_48FS << bfs_shift);\r\nbreak;\r\ncase 32:\r\nmod |= (MOD_BCLK_32FS << bfs_shift);\r\nbreak;\r\ncase 24:\r\nmod |= (MOD_BCLK_24FS << bfs_shift);\r\nbreak;\r\ncase 16:\r\nmod |= (MOD_BCLK_16FS << bfs_shift);\r\nbreak;\r\ncase 64:\r\nmod |= (EXYNOS5420_MOD_BCLK_64FS << bfs_shift);\r\nbreak;\r\ncase 96:\r\nmod |= (EXYNOS5420_MOD_BCLK_96FS << bfs_shift);\r\nbreak;\r\ncase 128:\r\nmod |= (EXYNOS5420_MOD_BCLK_128FS << bfs_shift);\r\nbreak;\r\ncase 192:\r\nmod |= (EXYNOS5420_MOD_BCLK_192FS << bfs_shift);\r\nbreak;\r\ncase 256:\r\nmod |= (EXYNOS5420_MOD_BCLK_256FS << bfs_shift);\r\nbreak;\r\ndefault:\r\ndev_err(&i2s->pdev->dev, "Wrong BCLK Divider!\n");\r\nreturn;\r\n}\r\nwritel(mod, i2s->addr + I2SMOD);\r\n}\r\nstatic inline int get_blc(struct i2s_dai *i2s)\r\n{\r\nint blc = readl(i2s->addr + I2SMOD);\r\nblc = (blc >> 13) & 0x3;\r\nswitch (blc) {\r\ncase 2: return 24;\r\ncase 1: return 8;\r\ndefault: return 16;\r\n}\r\n}\r\nstatic void i2s_txctrl(struct i2s_dai *i2s, int on)\r\n{\r\nvoid __iomem *addr = i2s->addr;\r\nint txr_off = i2s->variant_regs->txr_off;\r\nu32 con = readl(addr + I2SCON);\r\nu32 mod = readl(addr + I2SMOD) & ~(3 << txr_off);\r\nif (on) {\r\ncon |= CON_ACTIVE;\r\ncon &= ~CON_TXCH_PAUSE;\r\nif (is_secondary(i2s)) {\r\ncon |= CON_TXSDMA_ACTIVE;\r\ncon &= ~CON_TXSDMA_PAUSE;\r\n} else {\r\ncon |= CON_TXDMA_ACTIVE;\r\ncon &= ~CON_TXDMA_PAUSE;\r\n}\r\nif (any_rx_active(i2s))\r\nmod |= 2 << txr_off;\r\nelse\r\nmod |= 0 << txr_off;\r\n} else {\r\nif (is_secondary(i2s)) {\r\ncon |= CON_TXSDMA_PAUSE;\r\ncon &= ~CON_TXSDMA_ACTIVE;\r\n} else {\r\ncon |= CON_TXDMA_PAUSE;\r\ncon &= ~CON_TXDMA_ACTIVE;\r\n}\r\nif (other_tx_active(i2s)) {\r\nwritel(con, addr + I2SCON);\r\nreturn;\r\n}\r\ncon |= CON_TXCH_PAUSE;\r\nif (any_rx_active(i2s))\r\nmod |= 1 << txr_off;\r\nelse\r\ncon &= ~CON_ACTIVE;\r\n}\r\nwritel(mod, addr + I2SMOD);\r\nwritel(con, addr + I2SCON);\r\n}\r\nstatic void i2s_rxctrl(struct i2s_dai *i2s, int on)\r\n{\r\nvoid __iomem *addr = i2s->addr;\r\nint txr_off = i2s->variant_regs->txr_off;\r\nu32 con = readl(addr + I2SCON);\r\nu32 mod = readl(addr + I2SMOD) & ~(3 << txr_off);\r\nif (on) {\r\ncon |= CON_RXDMA_ACTIVE | CON_ACTIVE;\r\ncon &= ~(CON_RXDMA_PAUSE | CON_RXCH_PAUSE);\r\nif (any_tx_active(i2s))\r\nmod |= 2 << txr_off;\r\nelse\r\nmod |= 1 << txr_off;\r\n} else {\r\ncon |= CON_RXDMA_PAUSE | CON_RXCH_PAUSE;\r\ncon &= ~CON_RXDMA_ACTIVE;\r\nif (any_tx_active(i2s))\r\nmod |= 0 << txr_off;\r\nelse\r\ncon &= ~CON_ACTIVE;\r\n}\r\nwritel(mod, addr + I2SMOD);\r\nwritel(con, addr + I2SCON);\r\n}\r\nstatic inline void i2s_fifo(struct i2s_dai *i2s, u32 flush)\r\n{\r\nvoid __iomem *fic;\r\nu32 val;\r\nif (!i2s)\r\nreturn;\r\nif (is_secondary(i2s))\r\nfic = i2s->addr + I2SFICS;\r\nelse\r\nfic = i2s->addr + I2SFIC;\r\nwritel(readl(fic) | flush, fic);\r\nval = msecs_to_loops(1) / 1000;\r\nwhile (--val)\r\ncpu_relax();\r\nwritel(readl(fic) & ~flush, fic);\r\n}\r\nstatic int i2s_set_sysclk(struct snd_soc_dai *dai,\r\nint clk_id, unsigned int rfs, int dir)\r\n{\r\nstruct i2s_dai *i2s = to_info(dai);\r\nstruct i2s_dai *other = get_other_dai(i2s);\r\nconst struct samsung_i2s_variant_regs *i2s_regs = i2s->variant_regs;\r\nunsigned int cdcon_mask = 1 << i2s_regs->cdclkcon_off;\r\nunsigned int rsrc_mask = 1 << i2s_regs->rclksrc_off;\r\nu32 mod, mask, val = 0;\r\nunsigned long flags;\r\nspin_lock_irqsave(i2s->lock, flags);\r\nmod = readl(i2s->addr + I2SMOD);\r\nspin_unlock_irqrestore(i2s->lock, flags);\r\nswitch (clk_id) {\r\ncase SAMSUNG_I2S_OPCLK:\r\nmask = MOD_OPCLK_MASK;\r\nval = dir;\r\nbreak;\r\ncase SAMSUNG_I2S_CDCLK:\r\nmask = 1 << i2s_regs->cdclkcon_off;\r\nif (dir == SND_SOC_CLOCK_IN)\r\nrfs = 0;\r\nif ((rfs && other && other->rfs && (other->rfs != rfs)) ||\r\n(any_active(i2s) &&\r\n(((dir == SND_SOC_CLOCK_IN)\r\n&& !(mod & cdcon_mask)) ||\r\n((dir == SND_SOC_CLOCK_OUT)\r\n&& (mod & cdcon_mask))))) {\r\ndev_err(&i2s->pdev->dev,\r\n"%s:%d Other DAI busy\n", __func__, __LINE__);\r\nreturn -EAGAIN;\r\n}\r\nif (dir == SND_SOC_CLOCK_IN)\r\nval = 1 << i2s_regs->cdclkcon_off;\r\ni2s->rfs = rfs;\r\nbreak;\r\ncase SAMSUNG_I2S_RCLKSRC_0:\r\ncase SAMSUNG_I2S_RCLKSRC_1:\r\nmask = 1 << i2s_regs->rclksrc_off;\r\nif ((i2s->quirks & QUIRK_NO_MUXPSR)\r\n|| (clk_id == SAMSUNG_I2S_RCLKSRC_0))\r\nclk_id = 0;\r\nelse\r\nclk_id = 1;\r\nif (!any_active(i2s)) {\r\nif (i2s->op_clk && !IS_ERR(i2s->op_clk)) {\r\nif ((clk_id && !(mod & rsrc_mask)) ||\r\n(!clk_id && (mod & rsrc_mask))) {\r\nclk_disable_unprepare(i2s->op_clk);\r\nclk_put(i2s->op_clk);\r\n} else {\r\ni2s->rclk_srcrate =\r\nclk_get_rate(i2s->op_clk);\r\nreturn 0;\r\n}\r\n}\r\nif (clk_id)\r\ni2s->op_clk = clk_get(&i2s->pdev->dev,\r\n"i2s_opclk1");\r\nelse\r\ni2s->op_clk = clk_get(&i2s->pdev->dev,\r\n"i2s_opclk0");\r\nif (WARN_ON(IS_ERR(i2s->op_clk)))\r\nreturn PTR_ERR(i2s->op_clk);\r\nclk_prepare_enable(i2s->op_clk);\r\ni2s->rclk_srcrate = clk_get_rate(i2s->op_clk);\r\nif (other) {\r\nother->op_clk = i2s->op_clk;\r\nother->rclk_srcrate = i2s->rclk_srcrate;\r\n}\r\n} else if ((!clk_id && (mod & rsrc_mask))\r\n|| (clk_id && !(mod & rsrc_mask))) {\r\ndev_err(&i2s->pdev->dev,\r\n"%s:%d Other DAI busy\n", __func__, __LINE__);\r\nreturn -EAGAIN;\r\n} else {\r\ni2s->op_clk = other->op_clk;\r\ni2s->rclk_srcrate = other->rclk_srcrate;\r\nreturn 0;\r\n}\r\nif (clk_id == 1)\r\nval = 1 << i2s_regs->rclksrc_off;\r\nbreak;\r\ndefault:\r\ndev_err(&i2s->pdev->dev, "We don't serve that!\n");\r\nreturn -EINVAL;\r\n}\r\nspin_lock_irqsave(i2s->lock, flags);\r\nmod = readl(i2s->addr + I2SMOD);\r\nmod = (mod & ~mask) | val;\r\nwritel(mod, i2s->addr + I2SMOD);\r\nspin_unlock_irqrestore(i2s->lock, flags);\r\nreturn 0;\r\n}\r\nstatic int i2s_set_fmt(struct snd_soc_dai *dai,\r\nunsigned int fmt)\r\n{\r\nstruct i2s_dai *i2s = to_info(dai);\r\nint lrp_shift, sdf_shift, sdf_mask, lrp_rlow, mod_slave;\r\nu32 mod, tmp = 0;\r\nunsigned long flags;\r\nlrp_shift = i2s->variant_regs->lrp_off;\r\nsdf_shift = i2s->variant_regs->sdf_off;\r\nmod_slave = 1 << i2s->variant_regs->mss_off;\r\nsdf_mask = MOD_SDF_MASK << sdf_shift;\r\nlrp_rlow = MOD_LR_RLOW << lrp_shift;\r\nswitch (fmt & SND_SOC_DAIFMT_FORMAT_MASK) {\r\ncase SND_SOC_DAIFMT_RIGHT_J:\r\ntmp |= lrp_rlow;\r\ntmp |= (MOD_SDF_MSB << sdf_shift);\r\nbreak;\r\ncase SND_SOC_DAIFMT_LEFT_J:\r\ntmp |= lrp_rlow;\r\ntmp |= (MOD_SDF_LSB << sdf_shift);\r\nbreak;\r\ncase SND_SOC_DAIFMT_I2S:\r\ntmp |= (MOD_SDF_IIS << sdf_shift);\r\nbreak;\r\ndefault:\r\ndev_err(&i2s->pdev->dev, "Format not supported\n");\r\nreturn -EINVAL;\r\n}\r\nswitch (fmt & SND_SOC_DAIFMT_INV_MASK) {\r\ncase SND_SOC_DAIFMT_NB_NF:\r\nbreak;\r\ncase SND_SOC_DAIFMT_NB_IF:\r\nif (tmp & lrp_rlow)\r\ntmp &= ~lrp_rlow;\r\nelse\r\ntmp |= lrp_rlow;\r\nbreak;\r\ndefault:\r\ndev_err(&i2s->pdev->dev, "Polarity not supported\n");\r\nreturn -EINVAL;\r\n}\r\nswitch (fmt & SND_SOC_DAIFMT_MASTER_MASK) {\r\ncase SND_SOC_DAIFMT_CBM_CFM:\r\ntmp |= mod_slave;\r\nbreak;\r\ncase SND_SOC_DAIFMT_CBS_CFS:\r\nif (i2s->rclk_srcrate == 0)\r\ni2s_set_sysclk(dai, SAMSUNG_I2S_RCLKSRC_0,\r\n0, SND_SOC_CLOCK_IN);\r\nbreak;\r\ndefault:\r\ndev_err(&i2s->pdev->dev, "master/slave format not supported\n");\r\nreturn -EINVAL;\r\n}\r\nspin_lock_irqsave(i2s->lock, flags);\r\nmod = readl(i2s->addr + I2SMOD);\r\nif (any_active(i2s) &&\r\n((mod & (sdf_mask | lrp_rlow | mod_slave)) != tmp)) {\r\nspin_unlock_irqrestore(i2s->lock, flags);\r\ndev_err(&i2s->pdev->dev,\r\n"%s:%d Other DAI busy\n", __func__, __LINE__);\r\nreturn -EAGAIN;\r\n}\r\nmod &= ~(sdf_mask | lrp_rlow | mod_slave);\r\nmod |= tmp;\r\nwritel(mod, i2s->addr + I2SMOD);\r\nspin_unlock_irqrestore(i2s->lock, flags);\r\nreturn 0;\r\n}\r\nstatic int i2s_hw_params(struct snd_pcm_substream *substream,\r\nstruct snd_pcm_hw_params *params, struct snd_soc_dai *dai)\r\n{\r\nstruct i2s_dai *i2s = to_info(dai);\r\nu32 mod, mask = 0, val = 0;\r\nunsigned long flags;\r\nif (!is_secondary(i2s))\r\nmask |= (MOD_DC2_EN | MOD_DC1_EN);\r\nswitch (params_channels(params)) {\r\ncase 6:\r\nval |= MOD_DC2_EN;\r\ncase 4:\r\nval |= MOD_DC1_EN;\r\nbreak;\r\ncase 2:\r\nif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)\r\ni2s->dma_playback.dma_size = 4;\r\nelse\r\ni2s->dma_capture.dma_size = 4;\r\nbreak;\r\ncase 1:\r\nif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)\r\ni2s->dma_playback.dma_size = 2;\r\nelse\r\ni2s->dma_capture.dma_size = 2;\r\nbreak;\r\ndefault:\r\ndev_err(&i2s->pdev->dev, "%d channels not supported\n",\r\nparams_channels(params));\r\nreturn -EINVAL;\r\n}\r\nif (is_secondary(i2s))\r\nmask |= MOD_BLCS_MASK;\r\nelse\r\nmask |= MOD_BLCP_MASK;\r\nif (is_manager(i2s))\r\nmask |= MOD_BLC_MASK;\r\nswitch (params_width(params)) {\r\ncase 8:\r\nif (is_secondary(i2s))\r\nval |= MOD_BLCS_8BIT;\r\nelse\r\nval |= MOD_BLCP_8BIT;\r\nif (is_manager(i2s))\r\nval |= MOD_BLC_8BIT;\r\nbreak;\r\ncase 16:\r\nif (is_secondary(i2s))\r\nval |= MOD_BLCS_16BIT;\r\nelse\r\nval |= MOD_BLCP_16BIT;\r\nif (is_manager(i2s))\r\nval |= MOD_BLC_16BIT;\r\nbreak;\r\ncase 24:\r\nif (is_secondary(i2s))\r\nval |= MOD_BLCS_24BIT;\r\nelse\r\nval |= MOD_BLCP_24BIT;\r\nif (is_manager(i2s))\r\nval |= MOD_BLC_24BIT;\r\nbreak;\r\ndefault:\r\ndev_err(&i2s->pdev->dev, "Format(%d) not supported\n",\r\nparams_format(params));\r\nreturn -EINVAL;\r\n}\r\nspin_lock_irqsave(i2s->lock, flags);\r\nmod = readl(i2s->addr + I2SMOD);\r\nmod = (mod & ~mask) | val;\r\nwritel(mod, i2s->addr + I2SMOD);\r\nspin_unlock_irqrestore(i2s->lock, flags);\r\nsamsung_asoc_init_dma_data(dai, &i2s->dma_playback, &i2s->dma_capture);\r\ni2s->frmclk = params_rate(params);\r\nreturn 0;\r\n}\r\nstatic int i2s_startup(struct snd_pcm_substream *substream,\r\nstruct snd_soc_dai *dai)\r\n{\r\nstruct i2s_dai *i2s = to_info(dai);\r\nstruct i2s_dai *other = get_other_dai(i2s);\r\nunsigned long flags;\r\nspin_lock_irqsave(&lock, flags);\r\ni2s->mode |= DAI_OPENED;\r\nif (is_manager(other))\r\ni2s->mode &= ~DAI_MANAGER;\r\nelse\r\ni2s->mode |= DAI_MANAGER;\r\nif (!any_active(i2s) && (i2s->quirks & QUIRK_NEED_RSTCLR))\r\nwritel(CON_RSTCLR, i2s->addr + I2SCON);\r\nspin_unlock_irqrestore(&lock, flags);\r\nreturn 0;\r\n}\r\nstatic void i2s_shutdown(struct snd_pcm_substream *substream,\r\nstruct snd_soc_dai *dai)\r\n{\r\nstruct i2s_dai *i2s = to_info(dai);\r\nstruct i2s_dai *other = get_other_dai(i2s);\r\nunsigned long flags;\r\nspin_lock_irqsave(&lock, flags);\r\ni2s->mode &= ~DAI_OPENED;\r\ni2s->mode &= ~DAI_MANAGER;\r\nif (is_opened(other))\r\nother->mode |= DAI_MANAGER;\r\ni2s->rfs = 0;\r\ni2s->bfs = 0;\r\nspin_unlock_irqrestore(&lock, flags);\r\n}\r\nstatic int config_setup(struct i2s_dai *i2s)\r\n{\r\nstruct i2s_dai *other = get_other_dai(i2s);\r\nunsigned rfs, bfs, blc;\r\nu32 psr;\r\nblc = get_blc(i2s);\r\nbfs = i2s->bfs;\r\nif (!bfs && other)\r\nbfs = other->bfs;\r\nif (!bfs)\r\nbfs = blc * 2;\r\nrfs = i2s->rfs;\r\nif (!rfs && other)\r\nrfs = other->rfs;\r\nif ((rfs == 256 || rfs == 512) && (blc == 24)) {\r\ndev_err(&i2s->pdev->dev,\r\n"%d-RFS not supported for 24-blc\n", rfs);\r\nreturn -EINVAL;\r\n}\r\nif (!rfs) {\r\nif (bfs == 16 || bfs == 32)\r\nrfs = 256;\r\nelse\r\nrfs = 384;\r\n}\r\nif (any_active(i2s) && (get_rfs(i2s) != rfs || get_bfs(i2s) != bfs)) {\r\ndev_err(&i2s->pdev->dev,\r\n"%s:%d Other DAI busy\n", __func__, __LINE__);\r\nreturn -EAGAIN;\r\n}\r\nset_bfs(i2s, bfs);\r\nset_rfs(i2s, rfs);\r\nif (is_slave(i2s))\r\nreturn 0;\r\nif (!(i2s->quirks & QUIRK_NO_MUXPSR)) {\r\npsr = i2s->rclk_srcrate / i2s->frmclk / rfs;\r\nwritel(((psr - 1) << 8) | PSR_PSREN, i2s->addr + I2SPSR);\r\ndev_dbg(&i2s->pdev->dev,\r\n"RCLK_SRC=%luHz PSR=%u, RCLK=%dfs, BCLK=%dfs\n",\r\ni2s->rclk_srcrate, psr, rfs, bfs);\r\n}\r\nreturn 0;\r\n}\r\nstatic int i2s_trigger(struct snd_pcm_substream *substream,\r\nint cmd, struct snd_soc_dai *dai)\r\n{\r\nint capture = (substream->stream == SNDRV_PCM_STREAM_CAPTURE);\r\nstruct snd_soc_pcm_runtime *rtd = substream->private_data;\r\nstruct i2s_dai *i2s = to_info(rtd->cpu_dai);\r\nunsigned long flags;\r\nswitch (cmd) {\r\ncase SNDRV_PCM_TRIGGER_START:\r\ncase SNDRV_PCM_TRIGGER_RESUME:\r\ncase SNDRV_PCM_TRIGGER_PAUSE_RELEASE:\r\nspin_lock_irqsave(i2s->lock, flags);\r\nif (config_setup(i2s)) {\r\nspin_unlock_irqrestore(i2s->lock, flags);\r\nreturn -EINVAL;\r\n}\r\nif (capture)\r\ni2s_rxctrl(i2s, 1);\r\nelse\r\ni2s_txctrl(i2s, 1);\r\nspin_unlock_irqrestore(i2s->lock, flags);\r\nbreak;\r\ncase SNDRV_PCM_TRIGGER_STOP:\r\ncase SNDRV_PCM_TRIGGER_SUSPEND:\r\ncase SNDRV_PCM_TRIGGER_PAUSE_PUSH:\r\nspin_lock_irqsave(i2s->lock, flags);\r\nif (capture) {\r\ni2s_rxctrl(i2s, 0);\r\ni2s_fifo(i2s, FIC_RXFLUSH);\r\n} else {\r\ni2s_txctrl(i2s, 0);\r\ni2s_fifo(i2s, FIC_TXFLUSH);\r\n}\r\nspin_unlock_irqrestore(i2s->lock, flags);\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic int i2s_set_clkdiv(struct snd_soc_dai *dai,\r\nint div_id, int div)\r\n{\r\nstruct i2s_dai *i2s = to_info(dai);\r\nstruct i2s_dai *other = get_other_dai(i2s);\r\nswitch (div_id) {\r\ncase SAMSUNG_I2S_DIV_BCLK:\r\nif ((any_active(i2s) && div && (get_bfs(i2s) != div))\r\n|| (other && other->bfs && (other->bfs != div))) {\r\ndev_err(&i2s->pdev->dev,\r\n"%s:%d Other DAI busy\n", __func__, __LINE__);\r\nreturn -EAGAIN;\r\n}\r\ni2s->bfs = div;\r\nbreak;\r\ndefault:\r\ndev_err(&i2s->pdev->dev,\r\n"Invalid clock divider(%d)\n", div_id);\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic snd_pcm_sframes_t\r\ni2s_delay(struct snd_pcm_substream *substream, struct snd_soc_dai *dai)\r\n{\r\nstruct i2s_dai *i2s = to_info(dai);\r\nu32 reg = readl(i2s->addr + I2SFIC);\r\nsnd_pcm_sframes_t delay;\r\nconst struct samsung_i2s_variant_regs *i2s_regs = i2s->variant_regs;\r\nif (substream->stream == SNDRV_PCM_STREAM_CAPTURE)\r\ndelay = FIC_RXCOUNT(reg);\r\nelse if (is_secondary(i2s))\r\ndelay = FICS_TXCOUNT(readl(i2s->addr + I2SFICS));\r\nelse\r\ndelay = (reg >> i2s_regs->ftx0cnt_off) & 0x7f;\r\nreturn delay;\r\n}\r\nstatic int i2s_suspend(struct snd_soc_dai *dai)\r\n{\r\nstruct i2s_dai *i2s = to_info(dai);\r\ni2s->suspend_i2smod = readl(i2s->addr + I2SMOD);\r\ni2s->suspend_i2scon = readl(i2s->addr + I2SCON);\r\ni2s->suspend_i2spsr = readl(i2s->addr + I2SPSR);\r\nreturn 0;\r\n}\r\nstatic int i2s_resume(struct snd_soc_dai *dai)\r\n{\r\nstruct i2s_dai *i2s = to_info(dai);\r\nwritel(i2s->suspend_i2scon, i2s->addr + I2SCON);\r\nwritel(i2s->suspend_i2smod, i2s->addr + I2SMOD);\r\nwritel(i2s->suspend_i2spsr, i2s->addr + I2SPSR);\r\nreturn 0;\r\n}\r\nstatic int samsung_i2s_dai_probe(struct snd_soc_dai *dai)\r\n{\r\nstruct i2s_dai *i2s = to_info(dai);\r\nstruct i2s_dai *other = get_other_dai(i2s);\r\nunsigned long flags;\r\nif (is_secondary(i2s)) {\r\nsamsung_asoc_init_dma_data(dai, &other->sec_dai->dma_playback,\r\nNULL);\r\n} else {\r\nsamsung_asoc_init_dma_data(dai, &i2s->dma_playback,\r\n&i2s->dma_capture);\r\nif (i2s->quirks & QUIRK_NEED_RSTCLR)\r\nwritel(CON_RSTCLR, i2s->addr + I2SCON);\r\nif (i2s->quirks & QUIRK_SUPPORTS_IDMA)\r\nidma_reg_addr_init(i2s->addr,\r\ni2s->sec_dai->idma_playback.dma_addr);\r\n}\r\ni2s->rfs = 0;\r\ni2s->bfs = 0;\r\ni2s->rclk_srcrate = 0;\r\nspin_lock_irqsave(i2s->lock, flags);\r\ni2s_txctrl(i2s, 0);\r\ni2s_rxctrl(i2s, 0);\r\ni2s_fifo(i2s, FIC_TXFLUSH);\r\ni2s_fifo(other, FIC_TXFLUSH);\r\ni2s_fifo(i2s, FIC_RXFLUSH);\r\nspin_unlock_irqrestore(i2s->lock, flags);\r\nif (!is_opened(other))\r\ni2s_set_sysclk(dai, SAMSUNG_I2S_CDCLK,\r\n0, SND_SOC_CLOCK_IN);\r\nreturn 0;\r\n}\r\nstatic int samsung_i2s_dai_remove(struct snd_soc_dai *dai)\r\n{\r\nstruct i2s_dai *i2s = snd_soc_dai_get_drvdata(dai);\r\nif (!is_secondary(i2s)) {\r\nif (i2s->quirks & QUIRK_NEED_RSTCLR) {\r\nspin_lock(i2s->lock);\r\nwritel(0, i2s->addr + I2SCON);\r\nspin_unlock(i2s->lock);\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic struct i2s_dai *i2s_alloc_dai(struct platform_device *pdev, bool sec)\r\n{\r\nstruct i2s_dai *i2s;\r\nint ret;\r\ni2s = devm_kzalloc(&pdev->dev, sizeof(struct i2s_dai), GFP_KERNEL);\r\nif (i2s == NULL)\r\nreturn NULL;\r\ni2s->pdev = pdev;\r\ni2s->pri_dai = NULL;\r\ni2s->sec_dai = NULL;\r\ni2s->i2s_dai_drv.symmetric_rates = 1;\r\ni2s->i2s_dai_drv.probe = samsung_i2s_dai_probe;\r\ni2s->i2s_dai_drv.remove = samsung_i2s_dai_remove;\r\ni2s->i2s_dai_drv.ops = &samsung_i2s_dai_ops;\r\ni2s->i2s_dai_drv.suspend = i2s_suspend;\r\ni2s->i2s_dai_drv.resume = i2s_resume;\r\ni2s->i2s_dai_drv.playback.channels_min = 1;\r\ni2s->i2s_dai_drv.playback.channels_max = 2;\r\ni2s->i2s_dai_drv.playback.rates = SAMSUNG_I2S_RATES;\r\ni2s->i2s_dai_drv.playback.formats = SAMSUNG_I2S_FMTS;\r\nif (!sec) {\r\ni2s->i2s_dai_drv.capture.channels_min = 1;\r\ni2s->i2s_dai_drv.capture.channels_max = 2;\r\ni2s->i2s_dai_drv.capture.rates = SAMSUNG_I2S_RATES;\r\ni2s->i2s_dai_drv.capture.formats = SAMSUNG_I2S_FMTS;\r\ndev_set_drvdata(&i2s->pdev->dev, i2s);\r\n} else {\r\ni2s->pdev = platform_device_alloc("samsung-i2s-sec", -1);\r\nif (!i2s->pdev)\r\nreturn NULL;\r\ni2s->pdev->dev.parent = &pdev->dev;\r\nplatform_set_drvdata(i2s->pdev, i2s);\r\nret = platform_device_add(i2s->pdev);\r\nif (ret < 0)\r\nreturn NULL;\r\n}\r\nreturn i2s;\r\n}\r\nstatic inline const struct samsung_i2s_dai_data *samsung_i2s_get_driver_data(\r\nstruct platform_device *pdev)\r\n{\r\nif (IS_ENABLED(CONFIG_OF) && pdev->dev.of_node) {\r\nconst struct of_device_id *match;\r\nmatch = of_match_node(exynos_i2s_match, pdev->dev.of_node);\r\nreturn match ? match->data : NULL;\r\n} else {\r\nreturn (struct samsung_i2s_dai_data *)\r\nplatform_get_device_id(pdev)->driver_data;\r\n}\r\n}\r\nstatic int i2s_runtime_suspend(struct device *dev)\r\n{\r\nstruct i2s_dai *i2s = dev_get_drvdata(dev);\r\nclk_disable_unprepare(i2s->clk);\r\nreturn 0;\r\n}\r\nstatic int i2s_runtime_resume(struct device *dev)\r\n{\r\nstruct i2s_dai *i2s = dev_get_drvdata(dev);\r\nclk_prepare_enable(i2s->clk);\r\nreturn 0;\r\n}\r\nstatic void i2s_unregister_clocks(struct i2s_dai *i2s)\r\n{\r\nint i;\r\nfor (i = 0; i < i2s->clk_data.clk_num; i++) {\r\nif (!IS_ERR(i2s->clk_table[i]))\r\nclk_unregister(i2s->clk_table[i]);\r\n}\r\n}\r\nstatic void i2s_unregister_clock_provider(struct platform_device *pdev)\r\n{\r\nstruct i2s_dai *i2s = dev_get_drvdata(&pdev->dev);\r\nof_clk_del_provider(pdev->dev.of_node);\r\ni2s_unregister_clocks(i2s);\r\n}\r\nstatic int i2s_register_clock_provider(struct platform_device *pdev)\r\n{\r\nstruct device *dev = &pdev->dev;\r\nstruct i2s_dai *i2s = dev_get_drvdata(dev);\r\nconst char *clk_name[2] = { "i2s_opclk0", "i2s_opclk1" };\r\nconst char *p_names[2] = { NULL };\r\nconst struct samsung_i2s_variant_regs *reg_info = i2s->variant_regs;\r\nstruct clk *rclksrc;\r\nint ret, i;\r\nif (!of_find_property(dev->of_node, "#clock-cells", NULL))\r\nreturn 0;\r\nfor (i = 0; i < ARRAY_SIZE(p_names); i++) {\r\nrclksrc = clk_get(dev, clk_name[i]);\r\nif (IS_ERR(rclksrc))\r\ncontinue;\r\np_names[i] = __clk_get_name(rclksrc);\r\nclk_put(rclksrc);\r\n}\r\nif (!(i2s->quirks & QUIRK_NO_MUXPSR)) {\r\nu32 val = readl(i2s->addr + I2SPSR);\r\nwritel(val | PSR_PSREN, i2s->addr + I2SPSR);\r\ni2s->clk_table[CLK_I2S_RCLK_SRC] = clk_register_mux(NULL,\r\n"i2s_rclksrc", p_names, ARRAY_SIZE(p_names),\r\nCLK_SET_RATE_NO_REPARENT | CLK_SET_RATE_PARENT,\r\ni2s->addr + I2SMOD, reg_info->rclksrc_off,\r\n1, 0, i2s->lock);\r\ni2s->clk_table[CLK_I2S_RCLK_PSR] = clk_register_divider(NULL,\r\n"i2s_presc", "i2s_rclksrc",\r\nCLK_SET_RATE_PARENT,\r\ni2s->addr + I2SPSR, 8, 6, 0, i2s->lock);\r\np_names[0] = "i2s_presc";\r\ni2s->clk_data.clk_num = 2;\r\n}\r\nof_property_read_string_index(dev->of_node,\r\n"clock-output-names", 0, &clk_name[0]);\r\ni2s->clk_table[CLK_I2S_CDCLK] = clk_register_gate(NULL, clk_name[0],\r\np_names[0], CLK_SET_RATE_PARENT,\r\ni2s->addr + I2SMOD, reg_info->cdclkcon_off,\r\nCLK_GATE_SET_TO_DISABLE, i2s->lock);\r\ni2s->clk_data.clk_num += 1;\r\ni2s->clk_data.clks = i2s->clk_table;\r\nret = of_clk_add_provider(dev->of_node, of_clk_src_onecell_get,\r\n&i2s->clk_data);\r\nif (ret < 0) {\r\ndev_err(dev, "failed to add clock provider: %d\n", ret);\r\ni2s_unregister_clocks(i2s);\r\n}\r\nreturn ret;\r\n}\r\nstatic int samsung_i2s_probe(struct platform_device *pdev)\r\n{\r\nstruct i2s_dai *pri_dai, *sec_dai = NULL;\r\nstruct s3c_audio_pdata *i2s_pdata = pdev->dev.platform_data;\r\nstruct samsung_i2s *i2s_cfg = NULL;\r\nstruct resource *res;\r\nu32 regs_base, quirks = 0, idma_addr = 0;\r\nstruct device_node *np = pdev->dev.of_node;\r\nconst struct samsung_i2s_dai_data *i2s_dai_data;\r\nint ret;\r\ni2s_dai_data = samsung_i2s_get_driver_data(pdev);\r\nif (i2s_dai_data->dai_type == TYPE_SEC) {\r\nsec_dai = dev_get_drvdata(&pdev->dev);\r\nif (!sec_dai) {\r\ndev_err(&pdev->dev, "Unable to get drvdata\n");\r\nreturn -EFAULT;\r\n}\r\nret = devm_snd_soc_register_component(&sec_dai->pdev->dev,\r\n&samsung_i2s_component,\r\n&sec_dai->i2s_dai_drv, 1);\r\nif (ret != 0)\r\nreturn ret;\r\nreturn samsung_asoc_dma_platform_register(&pdev->dev,\r\nsec_dai->filter);\r\n}\r\npri_dai = i2s_alloc_dai(pdev, false);\r\nif (!pri_dai) {\r\ndev_err(&pdev->dev, "Unable to alloc I2S_pri\n");\r\nreturn -ENOMEM;\r\n}\r\nspin_lock_init(&pri_dai->spinlock);\r\npri_dai->lock = &pri_dai->spinlock;\r\nif (!np) {\r\nif (i2s_pdata == NULL) {\r\ndev_err(&pdev->dev, "Can't work without s3c_audio_pdata\n");\r\nreturn -EINVAL;\r\n}\r\npri_dai->dma_playback.slave = i2s_pdata->dma_playback;\r\npri_dai->dma_capture.slave = i2s_pdata->dma_capture;\r\npri_dai->filter = i2s_pdata->dma_filter;\r\nif (&i2s_pdata->type)\r\ni2s_cfg = &i2s_pdata->type.i2s;\r\nif (i2s_cfg) {\r\nquirks = i2s_cfg->quirks;\r\nidma_addr = i2s_cfg->idma_addr;\r\n}\r\n} else {\r\nquirks = i2s_dai_data->quirks;\r\nif (of_property_read_u32(np, "samsung,idma-addr",\r\n&idma_addr)) {\r\nif (quirks & QUIRK_SUPPORTS_IDMA) {\r\ndev_info(&pdev->dev, "idma address is not"\\r\n"specified");\r\n}\r\n}\r\n}\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\npri_dai->addr = devm_ioremap_resource(&pdev->dev, res);\r\nif (IS_ERR(pri_dai->addr))\r\nreturn PTR_ERR(pri_dai->addr);\r\nregs_base = res->start;\r\npri_dai->clk = devm_clk_get(&pdev->dev, "iis");\r\nif (IS_ERR(pri_dai->clk)) {\r\ndev_err(&pdev->dev, "Failed to get iis clock\n");\r\nreturn PTR_ERR(pri_dai->clk);\r\n}\r\nret = clk_prepare_enable(pri_dai->clk);\r\nif (ret != 0) {\r\ndev_err(&pdev->dev, "failed to enable clock: %d\n", ret);\r\nreturn ret;\r\n}\r\npri_dai->dma_playback.dma_addr = regs_base + I2STXD;\r\npri_dai->dma_capture.dma_addr = regs_base + I2SRXD;\r\npri_dai->dma_playback.ch_name = "tx";\r\npri_dai->dma_capture.ch_name = "rx";\r\npri_dai->dma_playback.dma_size = 4;\r\npri_dai->dma_capture.dma_size = 4;\r\npri_dai->quirks = quirks;\r\npri_dai->variant_regs = i2s_dai_data->i2s_variant_regs;\r\nif (quirks & QUIRK_PRI_6CHAN)\r\npri_dai->i2s_dai_drv.playback.channels_max = 6;\r\nif (quirks & QUIRK_SEC_DAI) {\r\nsec_dai = i2s_alloc_dai(pdev, true);\r\nif (!sec_dai) {\r\ndev_err(&pdev->dev, "Unable to alloc I2S_sec\n");\r\nreturn -ENOMEM;\r\n}\r\nsec_dai->lock = &pri_dai->spinlock;\r\nsec_dai->variant_regs = pri_dai->variant_regs;\r\nsec_dai->dma_playback.dma_addr = regs_base + I2STXDS;\r\nsec_dai->dma_playback.ch_name = "tx-sec";\r\nif (!np) {\r\nsec_dai->dma_playback.slave = i2s_pdata->dma_play_sec;\r\nsec_dai->filter = i2s_pdata->dma_filter;\r\n}\r\nsec_dai->dma_playback.dma_size = 4;\r\nsec_dai->addr = pri_dai->addr;\r\nsec_dai->clk = pri_dai->clk;\r\nsec_dai->quirks = quirks;\r\nsec_dai->idma_playback.dma_addr = idma_addr;\r\nsec_dai->pri_dai = pri_dai;\r\npri_dai->sec_dai = sec_dai;\r\n}\r\nif (i2s_pdata && i2s_pdata->cfg_gpio && i2s_pdata->cfg_gpio(pdev)) {\r\ndev_err(&pdev->dev, "Unable to configure gpio\n");\r\nreturn -EINVAL;\r\n}\r\ndevm_snd_soc_register_component(&pri_dai->pdev->dev,\r\n&samsung_i2s_component,\r\n&pri_dai->i2s_dai_drv, 1);\r\npm_runtime_enable(&pdev->dev);\r\nret = samsung_asoc_dma_platform_register(&pdev->dev, pri_dai->filter);\r\nif (ret != 0)\r\nreturn ret;\r\nreturn i2s_register_clock_provider(pdev);\r\n}\r\nstatic int samsung_i2s_remove(struct platform_device *pdev)\r\n{\r\nstruct i2s_dai *i2s, *other;\r\ni2s = dev_get_drvdata(&pdev->dev);\r\nother = get_other_dai(i2s);\r\nif (other) {\r\nother->pri_dai = NULL;\r\nother->sec_dai = NULL;\r\n} else {\r\npm_runtime_disable(&pdev->dev);\r\n}\r\nif (!is_secondary(i2s)) {\r\ni2s_unregister_clock_provider(pdev);\r\nclk_disable_unprepare(i2s->clk);\r\n}\r\ni2s->pri_dai = NULL;\r\ni2s->sec_dai = NULL;\r\nreturn 0;\r\n}
