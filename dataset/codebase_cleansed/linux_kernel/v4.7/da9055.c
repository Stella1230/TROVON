static int da9055_get_alc_data(struct snd_soc_codec *codec, u8 reg_val)\r\n{\r\nint mid_data, top_data;\r\nint sum = 0;\r\nu8 iteration;\r\nfor (iteration = 0; iteration < DA9055_ALC_AVG_ITERATIONS;\r\niteration++) {\r\nsnd_soc_write(codec, DA9055_ALC_CIC_OP_LVL_CTRL, reg_val);\r\nsnd_soc_write(codec, DA9055_ALC_CIC_OP_LVL_CTRL,\r\nreg_val | DA9055_ALC_DATA_MIDDLE);\r\nmid_data = snd_soc_read(codec, DA9055_ALC_CIC_OP_LVL_DATA);\r\nsnd_soc_write(codec, DA9055_ALC_CIC_OP_LVL_CTRL,\r\nreg_val | DA9055_ALC_DATA_TOP);\r\ntop_data = snd_soc_read(codec, DA9055_ALC_CIC_OP_LVL_DATA);\r\nsum += ((mid_data << 8) | (top_data << 16));\r\n}\r\nreturn sum / DA9055_ALC_AVG_ITERATIONS;\r\n}\r\nstatic int da9055_put_alc_sw(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_soc_codec *codec = snd_soc_kcontrol_codec(kcontrol);\r\nu8 reg_val, adc_left, adc_right, mic_left, mic_right;\r\nint avg_left_data, avg_right_data, offset_l, offset_r;\r\nif (ucontrol->value.integer.value[0]) {\r\nmic_left = snd_soc_read(codec, DA9055_MIC_L_CTRL);\r\nmic_right = snd_soc_read(codec, DA9055_MIC_R_CTRL);\r\nsnd_soc_update_bits(codec, DA9055_MIC_L_CTRL,\r\nDA9055_MIC_L_MUTE_EN, DA9055_MIC_L_MUTE_EN);\r\nsnd_soc_update_bits(codec, DA9055_MIC_R_CTRL,\r\nDA9055_MIC_R_MUTE_EN, DA9055_MIC_R_MUTE_EN);\r\nadc_left = snd_soc_read(codec, DA9055_ADC_L_CTRL);\r\nadc_right = snd_soc_read(codec, DA9055_ADC_R_CTRL);\r\nsnd_soc_update_bits(codec, DA9055_ADC_L_CTRL,\r\nDA9055_ADC_L_EN, DA9055_ADC_L_EN);\r\nsnd_soc_update_bits(codec, DA9055_ADC_R_CTRL,\r\nDA9055_ADC_R_EN, DA9055_ADC_R_EN);\r\navg_left_data = da9055_get_alc_data(codec,\r\nDA9055_ALC_CIC_OP_CHANNEL_LEFT);\r\navg_right_data = da9055_get_alc_data(codec,\r\nDA9055_ALC_CIC_OP_CHANNEL_RIGHT);\r\noffset_l = -avg_left_data;\r\noffset_r = -avg_right_data;\r\nreg_val = (offset_l & DA9055_ALC_OFFSET_15_8) >> 8;\r\nsnd_soc_write(codec, DA9055_ALC_OFFSET_OP2M_L, reg_val);\r\nreg_val = (offset_l & DA9055_ALC_OFFSET_17_16) >> 16;\r\nsnd_soc_write(codec, DA9055_ALC_OFFSET_OP2U_L, reg_val);\r\nreg_val = (offset_r & DA9055_ALC_OFFSET_15_8) >> 8;\r\nsnd_soc_write(codec, DA9055_ALC_OFFSET_OP2M_R, reg_val);\r\nreg_val = (offset_r & DA9055_ALC_OFFSET_17_16) >> 16;\r\nsnd_soc_write(codec, DA9055_ALC_OFFSET_OP2U_R, reg_val);\r\nsnd_soc_write(codec, DA9055_ADC_L_CTRL, adc_left);\r\nsnd_soc_write(codec, DA9055_ADC_R_CTRL, adc_right);\r\nsnd_soc_write(codec, DA9055_MIC_L_CTRL, mic_left);\r\nsnd_soc_write(codec, DA9055_MIC_R_CTRL, mic_right);\r\n}\r\nreturn snd_soc_put_volsw(kcontrol, ucontrol);\r\n}\r\nstatic bool da9055_volatile_register(struct device *dev,\r\nunsigned int reg)\r\n{\r\nswitch (reg) {\r\ncase DA9055_STATUS1:\r\ncase DA9055_PLL_STATUS:\r\ncase DA9055_AUX_L_GAIN_STATUS:\r\ncase DA9055_AUX_R_GAIN_STATUS:\r\ncase DA9055_MIC_L_GAIN_STATUS:\r\ncase DA9055_MIC_R_GAIN_STATUS:\r\ncase DA9055_MIXIN_L_GAIN_STATUS:\r\ncase DA9055_MIXIN_R_GAIN_STATUS:\r\ncase DA9055_ADC_L_GAIN_STATUS:\r\ncase DA9055_ADC_R_GAIN_STATUS:\r\ncase DA9055_DAC_L_GAIN_STATUS:\r\ncase DA9055_DAC_R_GAIN_STATUS:\r\ncase DA9055_HP_L_GAIN_STATUS:\r\ncase DA9055_HP_R_GAIN_STATUS:\r\ncase DA9055_LINE_GAIN_STATUS:\r\ncase DA9055_ALC_CIC_OP_LVL_DATA:\r\nreturn 1;\r\ndefault:\r\nreturn 0;\r\n}\r\n}\r\nstatic int da9055_hw_params(struct snd_pcm_substream *substream,\r\nstruct snd_pcm_hw_params *params,\r\nstruct snd_soc_dai *dai)\r\n{\r\nstruct snd_soc_codec *codec = dai->codec;\r\nstruct da9055_priv *da9055 = snd_soc_codec_get_drvdata(codec);\r\nu8 aif_ctrl, fs;\r\nu32 sysclk;\r\nswitch (params_width(params)) {\r\ncase 16:\r\naif_ctrl = DA9055_AIF_WORD_S16_LE;\r\nbreak;\r\ncase 20:\r\naif_ctrl = DA9055_AIF_WORD_S20_3LE;\r\nbreak;\r\ncase 24:\r\naif_ctrl = DA9055_AIF_WORD_S24_LE;\r\nbreak;\r\ncase 32:\r\naif_ctrl = DA9055_AIF_WORD_S32_LE;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nsnd_soc_update_bits(codec, DA9055_AIF_CTRL, DA9055_AIF_WORD_LENGTH_MASK,\r\naif_ctrl);\r\nswitch (params_rate(params)) {\r\ncase 8000:\r\nfs = DA9055_SR_8000;\r\nsysclk = 3072000;\r\nbreak;\r\ncase 11025:\r\nfs = DA9055_SR_11025;\r\nsysclk = 2822400;\r\nbreak;\r\ncase 12000:\r\nfs = DA9055_SR_12000;\r\nsysclk = 3072000;\r\nbreak;\r\ncase 16000:\r\nfs = DA9055_SR_16000;\r\nsysclk = 3072000;\r\nbreak;\r\ncase 22050:\r\nfs = DA9055_SR_22050;\r\nsysclk = 2822400;\r\nbreak;\r\ncase 32000:\r\nfs = DA9055_SR_32000;\r\nsysclk = 3072000;\r\nbreak;\r\ncase 44100:\r\nfs = DA9055_SR_44100;\r\nsysclk = 2822400;\r\nbreak;\r\ncase 48000:\r\nfs = DA9055_SR_48000;\r\nsysclk = 3072000;\r\nbreak;\r\ncase 88200:\r\nfs = DA9055_SR_88200;\r\nsysclk = 2822400;\r\nbreak;\r\ncase 96000:\r\nfs = DA9055_SR_96000;\r\nsysclk = 3072000;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nif (da9055->mclk_rate) {\r\nsnd_soc_write(codec, DA9055_SR, fs);\r\n} else {\r\nsnd_soc_write(codec, DA9055_SR, DA9055_SR_48000);\r\n}\r\nif (da9055->mclk_rate && (da9055->mclk_rate != sysclk)) {\r\nif (!da9055->master) {\r\nsnd_soc_update_bits(codec, DA9055_PLL_CTRL,\r\nDA9055_PLL_EN | DA9055_PLL_SRM_EN,\r\nDA9055_PLL_EN | DA9055_PLL_SRM_EN);\r\n} else {\r\nsnd_soc_update_bits(codec, DA9055_PLL_CTRL,\r\nDA9055_PLL_EN, DA9055_PLL_EN);\r\n}\r\n} else {\r\nsnd_soc_update_bits(codec, DA9055_PLL_CTRL, DA9055_PLL_EN, 0);\r\n}\r\nreturn 0;\r\n}\r\nstatic int da9055_set_dai_fmt(struct snd_soc_dai *codec_dai, unsigned int fmt)\r\n{\r\nstruct snd_soc_codec *codec = codec_dai->codec;\r\nstruct da9055_priv *da9055 = snd_soc_codec_get_drvdata(codec);\r\nu8 aif_clk_mode, aif_ctrl, mode;\r\nswitch (fmt & SND_SOC_DAIFMT_MASTER_MASK) {\r\ncase SND_SOC_DAIFMT_CBM_CFM:\r\nmode = 1;\r\naif_clk_mode = DA9055_AIF_CLK_EN_MASTER_MODE;\r\nbreak;\r\ncase SND_SOC_DAIFMT_CBS_CFS:\r\nmode = 0;\r\naif_clk_mode = DA9055_AIF_CLK_EN_SLAVE_MODE;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nif ((snd_soc_read(codec, DA9055_PLL_CTRL) & DA9055_PLL_EN) &&\r\n(da9055->master != mode))\r\nreturn -EINVAL;\r\nda9055->master = mode;\r\nswitch (fmt & SND_SOC_DAIFMT_FORMAT_MASK) {\r\ncase SND_SOC_DAIFMT_I2S:\r\naif_ctrl = DA9055_AIF_FORMAT_I2S_MODE;\r\nbreak;\r\ncase SND_SOC_DAIFMT_LEFT_J:\r\naif_ctrl = DA9055_AIF_FORMAT_LEFT_J;\r\nbreak;\r\ncase SND_SOC_DAIFMT_RIGHT_J:\r\naif_ctrl = DA9055_AIF_FORMAT_RIGHT_J;\r\nbreak;\r\ncase SND_SOC_DAIFMT_DSP_A:\r\naif_ctrl = DA9055_AIF_FORMAT_DSP;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\naif_clk_mode |= DA9055_AIF_BCLKS_PER_WCLK_32;\r\nsnd_soc_update_bits(codec, DA9055_AIF_CLK_MODE,\r\n(DA9055_AIF_CLK_MODE_MASK | DA9055_AIF_BCLK_MASK),\r\naif_clk_mode);\r\nsnd_soc_update_bits(codec, DA9055_AIF_CTRL, DA9055_AIF_FORMAT_MASK,\r\naif_ctrl);\r\nreturn 0;\r\n}\r\nstatic int da9055_mute(struct snd_soc_dai *dai, int mute)\r\n{\r\nstruct snd_soc_codec *codec = dai->codec;\r\nif (mute) {\r\nsnd_soc_update_bits(codec, DA9055_DAC_L_CTRL,\r\nDA9055_DAC_L_MUTE_EN, DA9055_DAC_L_MUTE_EN);\r\nsnd_soc_update_bits(codec, DA9055_DAC_R_CTRL,\r\nDA9055_DAC_R_MUTE_EN, DA9055_DAC_R_MUTE_EN);\r\n} else {\r\nsnd_soc_update_bits(codec, DA9055_DAC_L_CTRL,\r\nDA9055_DAC_L_MUTE_EN, 0);\r\nsnd_soc_update_bits(codec, DA9055_DAC_R_CTRL,\r\nDA9055_DAC_R_MUTE_EN, 0);\r\n}\r\nreturn 0;\r\n}\r\nstatic int da9055_set_dai_sysclk(struct snd_soc_dai *codec_dai,\r\nint clk_id, unsigned int freq, int dir)\r\n{\r\nstruct snd_soc_codec *codec = codec_dai->codec;\r\nstruct da9055_priv *da9055 = snd_soc_codec_get_drvdata(codec);\r\nswitch (clk_id) {\r\ncase DA9055_CLKSRC_MCLK:\r\nswitch (freq) {\r\ncase 11289600:\r\ncase 12000000:\r\ncase 12288000:\r\ncase 13000000:\r\ncase 13500000:\r\ncase 14400000:\r\ncase 19200000:\r\ncase 19680000:\r\ncase 19800000:\r\nda9055->mclk_rate = freq;\r\nreturn 0;\r\ndefault:\r\ndev_err(codec_dai->dev, "Unsupported MCLK value %d\n",\r\nfreq);\r\nreturn -EINVAL;\r\n}\r\nbreak;\r\ndefault:\r\ndev_err(codec_dai->dev, "Unknown clock source %d\n", clk_id);\r\nreturn -EINVAL;\r\n}\r\n}\r\nstatic int da9055_set_dai_pll(struct snd_soc_dai *codec_dai, int pll_id,\r\nint source, unsigned int fref, unsigned int fout)\r\n{\r\nstruct snd_soc_codec *codec = codec_dai->codec;\r\nstruct da9055_priv *da9055 = snd_soc_codec_get_drvdata(codec);\r\nu8 pll_frac_top, pll_frac_bot, pll_integer, cnt;\r\nsnd_soc_update_bits(codec, DA9055_PLL_CTRL, DA9055_PLL_EN, 0);\r\nif (!da9055->master && (fout != 2822400))\r\ngoto pll_err;\r\nfor (cnt = 0; cnt < ARRAY_SIZE(da9055_pll_div); cnt++) {\r\nif ((fref == da9055_pll_div[cnt].fref) &&\r\n(da9055->master == da9055_pll_div[cnt].mode) &&\r\n(fout == da9055_pll_div[cnt].fout)) {\r\npll_frac_top = da9055_pll_div[cnt].frac_top;\r\npll_frac_bot = da9055_pll_div[cnt].frac_bot;\r\npll_integer = da9055_pll_div[cnt].integer;\r\nbreak;\r\n}\r\n}\r\nif (cnt >= ARRAY_SIZE(da9055_pll_div))\r\ngoto pll_err;\r\nsnd_soc_write(codec, DA9055_PLL_FRAC_TOP, pll_frac_top);\r\nsnd_soc_write(codec, DA9055_PLL_FRAC_BOT, pll_frac_bot);\r\nsnd_soc_write(codec, DA9055_PLL_INTEGER, pll_integer);\r\nreturn 0;\r\npll_err:\r\ndev_err(codec_dai->dev, "Error in setting up PLL\n");\r\nreturn -EINVAL;\r\n}\r\nstatic int da9055_set_bias_level(struct snd_soc_codec *codec,\r\nenum snd_soc_bias_level level)\r\n{\r\nswitch (level) {\r\ncase SND_SOC_BIAS_ON:\r\ncase SND_SOC_BIAS_PREPARE:\r\nbreak;\r\ncase SND_SOC_BIAS_STANDBY:\r\nif (snd_soc_codec_get_bias_level(codec) == SND_SOC_BIAS_OFF) {\r\nsnd_soc_update_bits(codec, DA9055_REFERENCES,\r\nDA9055_VMID_EN | DA9055_BIAS_EN,\r\nDA9055_VMID_EN | DA9055_BIAS_EN);\r\n}\r\nbreak;\r\ncase SND_SOC_BIAS_OFF:\r\nsnd_soc_update_bits(codec, DA9055_REFERENCES,\r\nDA9055_VMID_EN | DA9055_BIAS_EN, 0);\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic int da9055_probe(struct snd_soc_codec *codec)\r\n{\r\nstruct da9055_priv *da9055 = snd_soc_codec_get_drvdata(codec);\r\nsnd_soc_update_bits(codec, DA9055_AUX_L_CTRL,\r\nDA9055_GAIN_RAMPING_EN, DA9055_GAIN_RAMPING_EN);\r\nsnd_soc_update_bits(codec, DA9055_AUX_R_CTRL,\r\nDA9055_GAIN_RAMPING_EN, DA9055_GAIN_RAMPING_EN);\r\nsnd_soc_update_bits(codec, DA9055_MIXIN_L_CTRL,\r\nDA9055_GAIN_RAMPING_EN, DA9055_GAIN_RAMPING_EN);\r\nsnd_soc_update_bits(codec, DA9055_MIXIN_R_CTRL,\r\nDA9055_GAIN_RAMPING_EN, DA9055_GAIN_RAMPING_EN);\r\nsnd_soc_update_bits(codec, DA9055_ADC_L_CTRL,\r\nDA9055_GAIN_RAMPING_EN, DA9055_GAIN_RAMPING_EN);\r\nsnd_soc_update_bits(codec, DA9055_ADC_R_CTRL,\r\nDA9055_GAIN_RAMPING_EN, DA9055_GAIN_RAMPING_EN);\r\nsnd_soc_update_bits(codec, DA9055_DAC_L_CTRL,\r\nDA9055_GAIN_RAMPING_EN, DA9055_GAIN_RAMPING_EN);\r\nsnd_soc_update_bits(codec, DA9055_DAC_R_CTRL,\r\nDA9055_GAIN_RAMPING_EN, DA9055_GAIN_RAMPING_EN);\r\nsnd_soc_update_bits(codec, DA9055_HP_L_CTRL,\r\nDA9055_GAIN_RAMPING_EN, DA9055_GAIN_RAMPING_EN);\r\nsnd_soc_update_bits(codec, DA9055_HP_R_CTRL,\r\nDA9055_GAIN_RAMPING_EN, DA9055_GAIN_RAMPING_EN);\r\nsnd_soc_update_bits(codec, DA9055_LINE_CTRL,\r\nDA9055_GAIN_RAMPING_EN, DA9055_GAIN_RAMPING_EN);\r\nsnd_soc_update_bits(codec, DA9055_MIXIN_L_CTRL,\r\nDA9055_MIXIN_L_MIX_EN, DA9055_MIXIN_L_MIX_EN);\r\nsnd_soc_update_bits(codec, DA9055_MIXIN_R_CTRL,\r\nDA9055_MIXIN_R_MIX_EN, DA9055_MIXIN_R_MIX_EN);\r\nsnd_soc_update_bits(codec, DA9055_MIXOUT_L_CTRL,\r\nDA9055_MIXOUT_L_MIX_EN, DA9055_MIXOUT_L_MIX_EN);\r\nsnd_soc_update_bits(codec, DA9055_MIXOUT_R_CTRL,\r\nDA9055_MIXOUT_R_MIX_EN, DA9055_MIXOUT_R_MIX_EN);\r\nsnd_soc_write(codec, DA9055_PLL_CTRL, DA9055_PLL_INDIV_10_20_MHZ);\r\nif (da9055->pdata) {\r\nif (da9055->pdata->micbias_source) {\r\nsnd_soc_update_bits(codec, DA9055_MIXIN_R_SELECT,\r\nDA9055_MICBIAS2_EN,\r\nDA9055_MICBIAS2_EN);\r\n} else {\r\nsnd_soc_update_bits(codec, DA9055_MIXIN_R_SELECT,\r\nDA9055_MICBIAS2_EN, 0);\r\n}\r\nswitch (da9055->pdata->micbias) {\r\ncase DA9055_MICBIAS_2_2V:\r\ncase DA9055_MICBIAS_2_1V:\r\ncase DA9055_MICBIAS_1_8V:\r\ncase DA9055_MICBIAS_1_6V:\r\nsnd_soc_update_bits(codec, DA9055_MIC_CONFIG,\r\nDA9055_MICBIAS_LEVEL_MASK,\r\n(da9055->pdata->micbias) << 4);\r\nbreak;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int da9055_i2c_probe(struct i2c_client *i2c,\r\nconst struct i2c_device_id *id)\r\n{\r\nstruct da9055_priv *da9055;\r\nstruct da9055_platform_data *pdata = dev_get_platdata(&i2c->dev);\r\nint ret;\r\nda9055 = devm_kzalloc(&i2c->dev, sizeof(struct da9055_priv),\r\nGFP_KERNEL);\r\nif (!da9055)\r\nreturn -ENOMEM;\r\nif (pdata)\r\nda9055->pdata = pdata;\r\ni2c_set_clientdata(i2c, da9055);\r\nda9055->regmap = devm_regmap_init_i2c(i2c, &da9055_regmap_config);\r\nif (IS_ERR(da9055->regmap)) {\r\nret = PTR_ERR(da9055->regmap);\r\ndev_err(&i2c->dev, "regmap_init() failed: %d\n", ret);\r\nreturn ret;\r\n}\r\nret = snd_soc_register_codec(&i2c->dev,\r\n&soc_codec_dev_da9055, &da9055_dai, 1);\r\nif (ret < 0) {\r\ndev_err(&i2c->dev, "Failed to register da9055 codec: %d\n",\r\nret);\r\n}\r\nreturn ret;\r\n}\r\nstatic int da9055_remove(struct i2c_client *client)\r\n{\r\nsnd_soc_unregister_codec(&client->dev);\r\nreturn 0;\r\n}
