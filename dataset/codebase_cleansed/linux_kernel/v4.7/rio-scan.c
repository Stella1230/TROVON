static u16 rio_destid_alloc(struct rio_net *net)\r\n{\r\nint destid;\r\nstruct rio_id_table *idtab = (struct rio_id_table *)net->enum_data;\r\nspin_lock(&idtab->lock);\r\ndestid = find_first_zero_bit(idtab->table, idtab->max);\r\nif (destid < idtab->max) {\r\nset_bit(destid, idtab->table);\r\ndestid += idtab->start;\r\n} else\r\ndestid = RIO_INVALID_DESTID;\r\nspin_unlock(&idtab->lock);\r\nreturn (u16)destid;\r\n}\r\nstatic int rio_destid_reserve(struct rio_net *net, u16 destid)\r\n{\r\nint oldbit;\r\nstruct rio_id_table *idtab = (struct rio_id_table *)net->enum_data;\r\ndestid -= idtab->start;\r\nspin_lock(&idtab->lock);\r\noldbit = test_and_set_bit(destid, idtab->table);\r\nspin_unlock(&idtab->lock);\r\nreturn oldbit;\r\n}\r\nstatic void rio_destid_free(struct rio_net *net, u16 destid)\r\n{\r\nstruct rio_id_table *idtab = (struct rio_id_table *)net->enum_data;\r\ndestid -= idtab->start;\r\nspin_lock(&idtab->lock);\r\nclear_bit(destid, idtab->table);\r\nspin_unlock(&idtab->lock);\r\n}\r\nstatic u16 rio_destid_first(struct rio_net *net)\r\n{\r\nint destid;\r\nstruct rio_id_table *idtab = (struct rio_id_table *)net->enum_data;\r\nspin_lock(&idtab->lock);\r\ndestid = find_first_bit(idtab->table, idtab->max);\r\nif (destid >= idtab->max)\r\ndestid = RIO_INVALID_DESTID;\r\nelse\r\ndestid += idtab->start;\r\nspin_unlock(&idtab->lock);\r\nreturn (u16)destid;\r\n}\r\nstatic u16 rio_destid_next(struct rio_net *net, u16 from)\r\n{\r\nint destid;\r\nstruct rio_id_table *idtab = (struct rio_id_table *)net->enum_data;\r\nspin_lock(&idtab->lock);\r\ndestid = find_next_bit(idtab->table, idtab->max, from);\r\nif (destid >= idtab->max)\r\ndestid = RIO_INVALID_DESTID;\r\nelse\r\ndestid += idtab->start;\r\nspin_unlock(&idtab->lock);\r\nreturn (u16)destid;\r\n}\r\nstatic u16 rio_get_device_id(struct rio_mport *port, u16 destid, u8 hopcount)\r\n{\r\nu32 result;\r\nrio_mport_read_config_32(port, destid, hopcount, RIO_DID_CSR, &result);\r\nreturn RIO_GET_DID(port->sys_size, result);\r\n}\r\nstatic void rio_set_device_id(struct rio_mport *port, u16 destid, u8 hopcount, u16 did)\r\n{\r\nrio_mport_write_config_32(port, destid, hopcount, RIO_DID_CSR,\r\nRIO_SET_DID(port->sys_size, did));\r\n}\r\nstatic int rio_clear_locks(struct rio_net *net)\r\n{\r\nstruct rio_mport *port = net->hport;\r\nstruct rio_dev *rdev;\r\nu32 result;\r\nint ret = 0;\r\nrio_local_write_config_32(port, RIO_HOST_DID_LOCK_CSR,\r\nport->host_deviceid);\r\nrio_local_read_config_32(port, RIO_HOST_DID_LOCK_CSR, &result);\r\nif ((result & 0xffff) != 0xffff) {\r\nprintk(KERN_INFO\r\n"RIO: badness when releasing host lock on master port, result %8.8x\n",\r\nresult);\r\nret = -EINVAL;\r\n}\r\nlist_for_each_entry(rdev, &net->devices, net_list) {\r\nrio_write_config_32(rdev, RIO_HOST_DID_LOCK_CSR,\r\nport->host_deviceid);\r\nrio_read_config_32(rdev, RIO_HOST_DID_LOCK_CSR, &result);\r\nif ((result & 0xffff) != 0xffff) {\r\nprintk(KERN_INFO\r\n"RIO: badness when releasing host lock on vid %4.4x did %4.4x\n",\r\nrdev->vid, rdev->did);\r\nret = -EINVAL;\r\n}\r\nrio_read_config_32(rdev,\r\nrdev->phys_efptr + RIO_PORT_GEN_CTL_CSR,\r\n&result);\r\nresult |= RIO_PORT_GEN_DISCOVERED | RIO_PORT_GEN_MASTER;\r\nrio_write_config_32(rdev,\r\nrdev->phys_efptr + RIO_PORT_GEN_CTL_CSR,\r\nresult);\r\n}\r\nreturn ret;\r\n}\r\nstatic int rio_enum_host(struct rio_mport *port)\r\n{\r\nu32 result;\r\nrio_local_write_config_32(port, RIO_HOST_DID_LOCK_CSR,\r\nport->host_deviceid);\r\nrio_local_read_config_32(port, RIO_HOST_DID_LOCK_CSR, &result);\r\nif ((result & 0xffff) != port->host_deviceid)\r\nreturn -1;\r\nrio_local_set_device_id(port, port->host_deviceid);\r\nreturn 0;\r\n}\r\nstatic int rio_device_has_destid(struct rio_mport *port, int src_ops,\r\nint dst_ops)\r\n{\r\nu32 mask = RIO_OPS_READ | RIO_OPS_WRITE | RIO_OPS_ATOMIC_TST_SWP | RIO_OPS_ATOMIC_INC | RIO_OPS_ATOMIC_DEC | RIO_OPS_ATOMIC_SET | RIO_OPS_ATOMIC_CLR;\r\nreturn !!((src_ops | dst_ops) & mask);\r\n}\r\nstatic void rio_release_dev(struct device *dev)\r\n{\r\nstruct rio_dev *rdev;\r\nrdev = to_rio_dev(dev);\r\nkfree(rdev);\r\n}\r\nstatic int rio_is_switch(struct rio_dev *rdev)\r\n{\r\nif (rdev->pef & RIO_PEF_SWITCH)\r\nreturn 1;\r\nreturn 0;\r\n}\r\nstatic struct rio_dev *rio_setup_device(struct rio_net *net,\r\nstruct rio_mport *port, u16 destid,\r\nu8 hopcount, int do_enum)\r\n{\r\nint ret = 0;\r\nstruct rio_dev *rdev;\r\nstruct rio_switch *rswitch = NULL;\r\nint result, rdid;\r\nsize_t size;\r\nu32 swpinfo = 0;\r\nsize = sizeof(struct rio_dev);\r\nif (rio_mport_read_config_32(port, destid, hopcount,\r\nRIO_PEF_CAR, &result))\r\nreturn NULL;\r\nif (result & (RIO_PEF_SWITCH | RIO_PEF_MULTIPORT)) {\r\nrio_mport_read_config_32(port, destid, hopcount,\r\nRIO_SWP_INFO_CAR, &swpinfo);\r\nif (result & RIO_PEF_SWITCH) {\r\nsize += (RIO_GET_TOTAL_PORTS(swpinfo) *\r\nsizeof(rswitch->nextdev[0])) + sizeof(*rswitch);\r\n}\r\n}\r\nrdev = kzalloc(size, GFP_KERNEL);\r\nif (!rdev)\r\nreturn NULL;\r\nrdev->net = net;\r\nrdev->pef = result;\r\nrdev->swpinfo = swpinfo;\r\nrio_mport_read_config_32(port, destid, hopcount, RIO_DEV_ID_CAR,\r\n&result);\r\nrdev->did = result >> 16;\r\nrdev->vid = result & 0xffff;\r\nrio_mport_read_config_32(port, destid, hopcount, RIO_DEV_INFO_CAR,\r\n&rdev->device_rev);\r\nrio_mport_read_config_32(port, destid, hopcount, RIO_ASM_ID_CAR,\r\n&result);\r\nrdev->asm_did = result >> 16;\r\nrdev->asm_vid = result & 0xffff;\r\nrio_mport_read_config_32(port, destid, hopcount, RIO_ASM_INFO_CAR,\r\n&result);\r\nrdev->asm_rev = result >> 16;\r\nif (rdev->pef & RIO_PEF_EXT_FEATURES) {\r\nrdev->efptr = result & 0xffff;\r\nrdev->phys_efptr = rio_mport_get_physefb(port, 0, destid,\r\nhopcount);\r\nrdev->em_efptr = rio_mport_get_feature(port, 0, destid,\r\nhopcount, RIO_EFB_ERR_MGMNT);\r\n}\r\nrio_mport_read_config_32(port, destid, hopcount, RIO_SRC_OPS_CAR,\r\n&rdev->src_ops);\r\nrio_mport_read_config_32(port, destid, hopcount, RIO_DST_OPS_CAR,\r\n&rdev->dst_ops);\r\nif (do_enum) {\r\nif (next_comptag >= 0x10000) {\r\npr_err("RIO: Component Tag Counter Overflow\n");\r\ngoto cleanup;\r\n}\r\nrio_mport_write_config_32(port, destid, hopcount,\r\nRIO_COMPONENT_TAG_CSR, next_comptag);\r\nrdev->comp_tag = next_comptag++;\r\nrdev->do_enum = true;\r\n} else {\r\nrio_mport_read_config_32(port, destid, hopcount,\r\nRIO_COMPONENT_TAG_CSR,\r\n&rdev->comp_tag);\r\n}\r\nif (rio_device_has_destid(port, rdev->src_ops, rdev->dst_ops)) {\r\nif (do_enum) {\r\nrio_set_device_id(port, destid, hopcount, next_destid);\r\nrdev->destid = next_destid;\r\nnext_destid = rio_destid_alloc(net);\r\n} else\r\nrdev->destid = rio_get_device_id(port, destid, hopcount);\r\nrdev->hopcount = 0xff;\r\n} else {\r\nrdev->destid = destid;\r\nrdev->hopcount = hopcount;\r\n}\r\nif (rio_is_switch(rdev)) {\r\nrswitch = rdev->rswitch;\r\nrswitch->port_ok = 0;\r\nspin_lock_init(&rswitch->lock);\r\nrswitch->route_table = kzalloc(sizeof(u8)*\r\nRIO_MAX_ROUTE_ENTRIES(port->sys_size),\r\nGFP_KERNEL);\r\nif (!rswitch->route_table)\r\ngoto cleanup;\r\nfor (rdid = 0; rdid < RIO_MAX_ROUTE_ENTRIES(port->sys_size);\r\nrdid++)\r\nrswitch->route_table[rdid] = RIO_INVALID_ROUTE;\r\ndev_set_name(&rdev->dev, "%02x:s:%04x", rdev->net->id,\r\nrdev->comp_tag & RIO_CTAG_UDEVID);\r\nif (do_enum)\r\nrio_route_clr_table(rdev, RIO_GLOBAL_TABLE, 0);\r\n} else {\r\nif (do_enum)\r\nrio_enable_rx_tx_port(port, 0, destid, hopcount, 0);\r\ndev_set_name(&rdev->dev, "%02x:e:%04x", rdev->net->id,\r\nrdev->comp_tag & RIO_CTAG_UDEVID);\r\n}\r\nrdev->dev.parent = &net->dev;\r\nrio_attach_device(rdev);\r\nrdev->dev.release = rio_release_dev;\r\nrdev->dma_mask = DMA_BIT_MASK(32);\r\nrdev->dev.dma_mask = &rdev->dma_mask;\r\nrdev->dev.coherent_dma_mask = DMA_BIT_MASK(32);\r\nif (rdev->dst_ops & RIO_DST_OPS_DOORBELL)\r\nrio_init_dbell_res(&rdev->riores[RIO_DOORBELL_RESOURCE],\r\n0, 0xffff);\r\nret = rio_add_device(rdev);\r\nif (ret)\r\ngoto cleanup;\r\nrio_dev_get(rdev);\r\nreturn rdev;\r\ncleanup:\r\nif (rswitch)\r\nkfree(rswitch->route_table);\r\nkfree(rdev);\r\nreturn NULL;\r\n}\r\nstatic int\r\nrio_sport_is_active(struct rio_mport *port, u16 destid, u8 hopcount, int sport)\r\n{\r\nu32 result = 0;\r\nu32 ext_ftr_ptr;\r\next_ftr_ptr = rio_mport_get_efb(port, 0, destid, hopcount, 0);\r\nwhile (ext_ftr_ptr) {\r\nrio_mport_read_config_32(port, destid, hopcount,\r\next_ftr_ptr, &result);\r\nresult = RIO_GET_BLOCK_ID(result);\r\nif ((result == RIO_EFB_SER_EP_FREE_ID) ||\r\n(result == RIO_EFB_SER_EP_FREE_ID_V13P) ||\r\n(result == RIO_EFB_SER_EP_FREC_ID))\r\nbreak;\r\next_ftr_ptr = rio_mport_get_efb(port, 0, destid, hopcount,\r\next_ftr_ptr);\r\n}\r\nif (ext_ftr_ptr)\r\nrio_mport_read_config_32(port, destid, hopcount,\r\next_ftr_ptr +\r\nRIO_PORT_N_ERR_STS_CSR(sport),\r\n&result);\r\nreturn result & RIO_PORT_N_ERR_STS_PORT_OK;\r\n}\r\nstatic u16 rio_get_host_deviceid_lock(struct rio_mport *port, u8 hopcount)\r\n{\r\nu32 result;\r\nrio_mport_read_config_32(port, RIO_ANY_DESTID(port->sys_size), hopcount,\r\nRIO_HOST_DID_LOCK_CSR, &result);\r\nreturn (u16) (result & 0xffff);\r\n}\r\nstatic int rio_enum_peer(struct rio_net *net, struct rio_mport *port,\r\nu8 hopcount, struct rio_dev *prev, int prev_port)\r\n{\r\nstruct rio_dev *rdev;\r\nu32 regval;\r\nint tmp;\r\nif (rio_mport_chk_dev_access(port,\r\nRIO_ANY_DESTID(port->sys_size), hopcount)) {\r\npr_debug("RIO: device access check failed\n");\r\nreturn -1;\r\n}\r\nif (rio_get_host_deviceid_lock(port, hopcount) == port->host_deviceid) {\r\npr_debug("RIO: PE already discovered by this host\n");\r\nrio_mport_read_config_32(port, RIO_ANY_DESTID(port->sys_size),\r\nhopcount, RIO_COMPONENT_TAG_CSR, &regval);\r\nif (regval) {\r\nrdev = rio_get_comptag((regval & 0xffff), NULL);\r\nif (rdev && prev && rio_is_switch(prev)) {\r\npr_debug("RIO: redundant path to %s\n",\r\nrio_name(rdev));\r\nprev->rswitch->nextdev[prev_port] = rdev;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nrio_mport_write_config_32(port, RIO_ANY_DESTID(port->sys_size),\r\nhopcount,\r\nRIO_HOST_DID_LOCK_CSR, port->host_deviceid);\r\nwhile ((tmp = rio_get_host_deviceid_lock(port, hopcount))\r\n< port->host_deviceid) {\r\nmdelay(1);\r\nrio_mport_write_config_32(port, RIO_ANY_DESTID(port->sys_size),\r\nhopcount,\r\nRIO_HOST_DID_LOCK_CSR,\r\nport->host_deviceid);\r\n}\r\nif (rio_get_host_deviceid_lock(port, hopcount) > port->host_deviceid) {\r\npr_debug(\r\n"RIO: PE locked by a higher priority host...retreating\n");\r\nreturn -1;\r\n}\r\nrdev = rio_setup_device(net, port, RIO_ANY_DESTID(port->sys_size),\r\nhopcount, 1);\r\nif (rdev) {\r\nrdev->prev = prev;\r\nif (prev && rio_is_switch(prev))\r\nprev->rswitch->nextdev[prev_port] = rdev;\r\n} else\r\nreturn -1;\r\nif (rio_is_switch(rdev)) {\r\nint sw_destid;\r\nint cur_destid;\r\nint sw_inport;\r\nu16 destid;\r\nint port_num;\r\nsw_inport = RIO_GET_PORT_NUM(rdev->swpinfo);\r\nrio_route_add_entry(rdev, RIO_GLOBAL_TABLE,\r\nport->host_deviceid, sw_inport, 0);\r\nrdev->rswitch->route_table[port->host_deviceid] = sw_inport;\r\ndestid = rio_destid_first(net);\r\nwhile (destid != RIO_INVALID_DESTID && destid < next_destid) {\r\nif (destid != port->host_deviceid) {\r\nrio_route_add_entry(rdev, RIO_GLOBAL_TABLE,\r\ndestid, sw_inport, 0);\r\nrdev->rswitch->route_table[destid] = sw_inport;\r\n}\r\ndestid = rio_destid_next(net, destid + 1);\r\n}\r\npr_debug(\r\n"RIO: found %s (vid %4.4x did %4.4x) with %d ports\n",\r\nrio_name(rdev), rdev->vid, rdev->did,\r\nRIO_GET_TOTAL_PORTS(rdev->swpinfo));\r\nsw_destid = next_destid;\r\nfor (port_num = 0;\r\nport_num < RIO_GET_TOTAL_PORTS(rdev->swpinfo);\r\nport_num++) {\r\nif (sw_inport == port_num) {\r\nrio_enable_rx_tx_port(port, 0,\r\nRIO_ANY_DESTID(port->sys_size),\r\nhopcount, port_num);\r\nrdev->rswitch->port_ok |= (1 << port_num);\r\ncontinue;\r\n}\r\ncur_destid = next_destid;\r\nif (rio_sport_is_active\r\n(port, RIO_ANY_DESTID(port->sys_size), hopcount,\r\nport_num)) {\r\npr_debug(\r\n"RIO: scanning device on port %d\n",\r\nport_num);\r\nrio_enable_rx_tx_port(port, 0,\r\nRIO_ANY_DESTID(port->sys_size),\r\nhopcount, port_num);\r\nrdev->rswitch->port_ok |= (1 << port_num);\r\nrio_route_add_entry(rdev, RIO_GLOBAL_TABLE,\r\nRIO_ANY_DESTID(port->sys_size),\r\nport_num, 0);\r\nif (rio_enum_peer(net, port, hopcount + 1,\r\nrdev, port_num) < 0)\r\nreturn -1;\r\ndestid = rio_destid_next(net, cur_destid + 1);\r\nif (destid != RIO_INVALID_DESTID) {\r\nfor (destid = cur_destid;\r\ndestid < next_destid;) {\r\nif (destid != port->host_deviceid) {\r\nrio_route_add_entry(rdev,\r\nRIO_GLOBAL_TABLE,\r\ndestid,\r\nport_num,\r\n0);\r\nrdev->rswitch->\r\nroute_table[destid] =\r\nport_num;\r\n}\r\ndestid = rio_destid_next(net,\r\ndestid + 1);\r\n}\r\n}\r\n} else {\r\nif (rdev->em_efptr)\r\nrio_set_port_lockout(rdev, port_num, 1);\r\nrdev->rswitch->port_ok &= ~(1 << port_num);\r\n}\r\n}\r\nif ((rdev->src_ops & RIO_SRC_OPS_PORT_WRITE) &&\r\n(rdev->em_efptr)) {\r\nrio_write_config_32(rdev,\r\nrdev->em_efptr + RIO_EM_PW_TGT_DEVID,\r\n(port->host_deviceid << 16) |\r\n(port->sys_size << 15));\r\n}\r\nrio_init_em(rdev);\r\nif (next_destid == sw_destid)\r\nnext_destid = rio_destid_alloc(net);\r\nrdev->destid = sw_destid;\r\n} else\r\npr_debug("RIO: found %s (vid %4.4x did %4.4x)\n",\r\nrio_name(rdev), rdev->vid, rdev->did);\r\nreturn 0;\r\n}\r\nstatic int rio_enum_complete(struct rio_mport *port)\r\n{\r\nu32 regval;\r\nrio_local_read_config_32(port, port->phys_efptr + RIO_PORT_GEN_CTL_CSR,\r\n&regval);\r\nreturn (regval & RIO_PORT_GEN_DISCOVERED) ? 1 : 0;\r\n}\r\nstatic int\r\nrio_disc_peer(struct rio_net *net, struct rio_mport *port, u16 destid,\r\nu8 hopcount, struct rio_dev *prev, int prev_port)\r\n{\r\nu8 port_num, route_port;\r\nstruct rio_dev *rdev;\r\nu16 ndestid;\r\nif ((rdev = rio_setup_device(net, port, destid, hopcount, 0))) {\r\nrdev->prev = prev;\r\nif (prev && rio_is_switch(prev))\r\nprev->rswitch->nextdev[prev_port] = rdev;\r\n} else\r\nreturn -1;\r\nif (rio_is_switch(rdev)) {\r\nrdev->destid = destid;\r\npr_debug(\r\n"RIO: found %s (vid %4.4x did %4.4x) with %d ports\n",\r\nrio_name(rdev), rdev->vid, rdev->did,\r\nRIO_GET_TOTAL_PORTS(rdev->swpinfo));\r\nfor (port_num = 0;\r\nport_num < RIO_GET_TOTAL_PORTS(rdev->swpinfo);\r\nport_num++) {\r\nif (RIO_GET_PORT_NUM(rdev->swpinfo) == port_num)\r\ncontinue;\r\nif (rio_sport_is_active\r\n(port, destid, hopcount, port_num)) {\r\npr_debug(\r\n"RIO: scanning device on port %d\n",\r\nport_num);\r\nrio_lock_device(port, destid, hopcount, 1000);\r\nfor (ndestid = 0;\r\nndestid < RIO_ANY_DESTID(port->sys_size);\r\nndestid++) {\r\nrio_route_get_entry(rdev,\r\nRIO_GLOBAL_TABLE,\r\nndestid,\r\n&route_port, 0);\r\nif (route_port == port_num)\r\nbreak;\r\n}\r\nif (ndestid == RIO_ANY_DESTID(port->sys_size))\r\ncontinue;\r\nrio_unlock_device(port, destid, hopcount);\r\nif (rio_disc_peer(net, port, ndestid,\r\nhopcount + 1, rdev, port_num) < 0)\r\nreturn -1;\r\n}\r\n}\r\n} else\r\npr_debug("RIO: found %s (vid %4.4x did %4.4x)\n",\r\nrio_name(rdev), rdev->vid, rdev->did);\r\nreturn 0;\r\n}\r\nstatic int rio_mport_is_active(struct rio_mport *port)\r\n{\r\nu32 result = 0;\r\nu32 ext_ftr_ptr;\r\nint *entry = rio_mport_phys_table;\r\ndo {\r\nif ((ext_ftr_ptr =\r\nrio_mport_get_feature(port, 1, 0, 0, *entry)))\r\nbreak;\r\n} while (*++entry >= 0);\r\nif (ext_ftr_ptr)\r\nrio_local_read_config_32(port,\r\next_ftr_ptr +\r\nRIO_PORT_N_ERR_STS_CSR(port->index),\r\n&result);\r\nreturn result & RIO_PORT_N_ERR_STS_PORT_OK;\r\n}\r\nstatic void rio_scan_release_net(struct rio_net *net)\r\n{\r\npr_debug("RIO-SCAN: %s: net_%d\n", __func__, net->id);\r\nkfree(net->enum_data);\r\n}\r\nstatic void rio_scan_release_dev(struct device *dev)\r\n{\r\nstruct rio_net *net;\r\nnet = to_rio_net(dev);\r\npr_debug("RIO-SCAN: %s: net_%d\n", __func__, net->id);\r\nkfree(net);\r\n}\r\nstatic struct rio_net *rio_scan_alloc_net(struct rio_mport *mport,\r\nint do_enum, u16 start)\r\n{\r\nstruct rio_net *net;\r\nnet = rio_alloc_net(mport);\r\nif (net && do_enum) {\r\nstruct rio_id_table *idtab;\r\nsize_t size;\r\nsize = sizeof(struct rio_id_table) +\r\nBITS_TO_LONGS(\r\nRIO_MAX_ROUTE_ENTRIES(mport->sys_size)\r\n) * sizeof(long);\r\nidtab = kzalloc(size, GFP_KERNEL);\r\nif (idtab == NULL) {\r\npr_err("RIO: failed to allocate destID table\n");\r\nrio_free_net(net);\r\nnet = NULL;\r\n} else {\r\nnet->enum_data = idtab;\r\nnet->release = rio_scan_release_net;\r\nidtab->start = start;\r\nidtab->max = RIO_MAX_ROUTE_ENTRIES(mport->sys_size);\r\nspin_lock_init(&idtab->lock);\r\n}\r\n}\r\nif (net) {\r\nnet->id = mport->id;\r\nnet->hport = mport;\r\ndev_set_name(&net->dev, "rnet_%d", net->id);\r\nnet->dev.parent = &mport->dev;\r\nnet->dev.release = rio_scan_release_dev;\r\nrio_add_net(net);\r\n}\r\nreturn net;\r\n}\r\nstatic void rio_update_route_tables(struct rio_net *net)\r\n{\r\nstruct rio_dev *rdev, *swrdev;\r\nstruct rio_switch *rswitch;\r\nu8 sport;\r\nu16 destid;\r\nlist_for_each_entry(rdev, &net->devices, net_list) {\r\ndestid = rdev->destid;\r\nlist_for_each_entry(rswitch, &net->switches, node) {\r\nif (rio_is_switch(rdev) && (rdev->rswitch == rswitch))\r\ncontinue;\r\nif (RIO_INVALID_ROUTE == rswitch->route_table[destid]) {\r\nswrdev = sw_to_rio_dev(rswitch);\r\nif (swrdev->destid == destid)\r\ncontinue;\r\nsport = RIO_GET_PORT_NUM(swrdev->swpinfo);\r\nrio_route_add_entry(swrdev, RIO_GLOBAL_TABLE,\r\ndestid, sport, 0);\r\nrswitch->route_table[destid] = sport;\r\n}\r\n}\r\n}\r\n}\r\nstatic void rio_init_em(struct rio_dev *rdev)\r\n{\r\nif (rio_is_switch(rdev) && (rdev->em_efptr) &&\r\nrdev->rswitch->ops && rdev->rswitch->ops->em_init) {\r\nrdev->rswitch->ops->em_init(rdev);\r\n}\r\n}\r\nstatic int rio_enum_mport(struct rio_mport *mport, u32 flags)\r\n{\r\nstruct rio_net *net = NULL;\r\nint rc = 0;\r\nprintk(KERN_INFO "RIO: enumerate master port %d, %s\n", mport->id,\r\nmport->name);\r\nif (mport->nnode.next || mport->nnode.prev)\r\nreturn -EBUSY;\r\nif (rio_enum_host(mport) < 0) {\r\nprintk(KERN_INFO\r\n"RIO: master port %d device has been enumerated by a remote host\n",\r\nmport->id);\r\nrc = -EBUSY;\r\ngoto out;\r\n}\r\nif (rio_mport_is_active(mport)) {\r\nnet = rio_scan_alloc_net(mport, 1, 0);\r\nif (!net) {\r\nprintk(KERN_ERR "RIO: failed to allocate new net\n");\r\nrc = -ENOMEM;\r\ngoto out;\r\n}\r\nrio_destid_reserve(net, mport->host_deviceid);\r\nrio_enable_rx_tx_port(mport, 1, 0, 0, 0);\r\nrio_local_write_config_32(mport, RIO_COMPONENT_TAG_CSR,\r\nnext_comptag++);\r\nnext_destid = rio_destid_alloc(net);\r\nif (rio_enum_peer(net, mport, 0, NULL, 0) < 0) {\r\nprintk(KERN_INFO\r\n"RIO: master port %d device has lost enumeration to a remote host\n",\r\nmport->id);\r\nrio_clear_locks(net);\r\nrc = -EBUSY;\r\ngoto out;\r\n}\r\nrio_destid_free(net, next_destid);\r\nrio_update_route_tables(net);\r\nrio_clear_locks(net);\r\nrio_pw_enable(mport, 1);\r\n} else {\r\nprintk(KERN_INFO "RIO: master port %d link inactive\n",\r\nmport->id);\r\nrc = -EINVAL;\r\n}\r\nout:\r\nreturn rc;\r\n}\r\nstatic void rio_build_route_tables(struct rio_net *net)\r\n{\r\nstruct rio_switch *rswitch;\r\nstruct rio_dev *rdev;\r\nint i;\r\nu8 sport;\r\nlist_for_each_entry(rswitch, &net->switches, node) {\r\nrdev = sw_to_rio_dev(rswitch);\r\nrio_lock_device(net->hport, rdev->destid,\r\nrdev->hopcount, 1000);\r\nfor (i = 0;\r\ni < RIO_MAX_ROUTE_ENTRIES(net->hport->sys_size);\r\ni++) {\r\nif (rio_route_get_entry(rdev, RIO_GLOBAL_TABLE,\r\ni, &sport, 0) < 0)\r\ncontinue;\r\nrswitch->route_table[i] = sport;\r\n}\r\nrio_unlock_device(net->hport, rdev->destid, rdev->hopcount);\r\n}\r\n}\r\nstatic int rio_disc_mport(struct rio_mport *mport, u32 flags)\r\n{\r\nstruct rio_net *net = NULL;\r\nunsigned long to_end;\r\nprintk(KERN_INFO "RIO: discover master port %d, %s\n", mport->id,\r\nmport->name);\r\nif (rio_mport_is_active(mport)) {\r\nif (rio_enum_complete(mport))\r\ngoto enum_done;\r\nelse if (flags & RIO_SCAN_ENUM_NO_WAIT)\r\nreturn -EAGAIN;\r\npr_debug("RIO: wait for enumeration to complete...\n");\r\nto_end = jiffies + CONFIG_RAPIDIO_DISC_TIMEOUT * HZ;\r\nwhile (time_before(jiffies, to_end)) {\r\nif (rio_enum_complete(mport))\r\ngoto enum_done;\r\nmsleep(10);\r\n}\r\npr_debug("RIO: discovery timeout on mport %d %s\n",\r\nmport->id, mport->name);\r\ngoto bail;\r\nenum_done:\r\npr_debug("RIO: ... enumeration done\n");\r\nnet = rio_scan_alloc_net(mport, 0, 0);\r\nif (!net) {\r\nprintk(KERN_ERR "RIO: Failed to allocate new net\n");\r\ngoto bail;\r\n}\r\nrio_local_read_config_32(mport, RIO_DID_CSR,\r\n&mport->host_deviceid);\r\nmport->host_deviceid = RIO_GET_DID(mport->sys_size,\r\nmport->host_deviceid);\r\nif (rio_disc_peer(net, mport, RIO_ANY_DESTID(mport->sys_size),\r\n0, NULL, 0) < 0) {\r\nprintk(KERN_INFO\r\n"RIO: master port %d device has failed discovery\n",\r\nmport->id);\r\ngoto bail;\r\n}\r\nrio_build_route_tables(net);\r\n}\r\nreturn 0;\r\nbail:\r\nreturn -EBUSY;\r\n}\r\nstatic int __init rio_basic_attach(void)\r\n{\r\nif (rio_register_scan(RIO_MPORT_ANY, &rio_scan_ops))\r\nreturn -EIO;\r\nif (scan)\r\nrio_init_mports();\r\nreturn 0;\r\n}
