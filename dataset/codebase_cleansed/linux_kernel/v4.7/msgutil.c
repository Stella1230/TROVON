static struct msg_msg *alloc_msg(size_t len)\r\n{\r\nstruct msg_msg *msg;\r\nstruct msg_msgseg **pseg;\r\nsize_t alen;\r\nalen = min(len, DATALEN_MSG);\r\nmsg = kmalloc(sizeof(*msg) + alen, GFP_KERNEL);\r\nif (msg == NULL)\r\nreturn NULL;\r\nmsg->next = NULL;\r\nmsg->security = NULL;\r\nlen -= alen;\r\npseg = &msg->next;\r\nwhile (len > 0) {\r\nstruct msg_msgseg *seg;\r\nalen = min(len, DATALEN_SEG);\r\nseg = kmalloc(sizeof(*seg) + alen, GFP_KERNEL);\r\nif (seg == NULL)\r\ngoto out_err;\r\n*pseg = seg;\r\nseg->next = NULL;\r\npseg = &seg->next;\r\nlen -= alen;\r\n}\r\nreturn msg;\r\nout_err:\r\nfree_msg(msg);\r\nreturn NULL;\r\n}\r\nstruct msg_msg *load_msg(const void __user *src, size_t len)\r\n{\r\nstruct msg_msg *msg;\r\nstruct msg_msgseg *seg;\r\nint err = -EFAULT;\r\nsize_t alen;\r\nmsg = alloc_msg(len);\r\nif (msg == NULL)\r\nreturn ERR_PTR(-ENOMEM);\r\nalen = min(len, DATALEN_MSG);\r\nif (copy_from_user(msg + 1, src, alen))\r\ngoto out_err;\r\nfor (seg = msg->next; seg != NULL; seg = seg->next) {\r\nlen -= alen;\r\nsrc = (char __user *)src + alen;\r\nalen = min(len, DATALEN_SEG);\r\nif (copy_from_user(seg + 1, src, alen))\r\ngoto out_err;\r\n}\r\nerr = security_msg_msg_alloc(msg);\r\nif (err)\r\ngoto out_err;\r\nreturn msg;\r\nout_err:\r\nfree_msg(msg);\r\nreturn ERR_PTR(err);\r\n}\r\nstruct msg_msg *copy_msg(struct msg_msg *src, struct msg_msg *dst)\r\n{\r\nstruct msg_msgseg *dst_pseg, *src_pseg;\r\nsize_t len = src->m_ts;\r\nsize_t alen;\r\nif (src->m_ts > dst->m_ts)\r\nreturn ERR_PTR(-EINVAL);\r\nalen = min(len, DATALEN_MSG);\r\nmemcpy(dst + 1, src + 1, alen);\r\nfor (dst_pseg = dst->next, src_pseg = src->next;\r\nsrc_pseg != NULL;\r\ndst_pseg = dst_pseg->next, src_pseg = src_pseg->next) {\r\nlen -= alen;\r\nalen = min(len, DATALEN_SEG);\r\nmemcpy(dst_pseg + 1, src_pseg + 1, alen);\r\n}\r\ndst->m_type = src->m_type;\r\ndst->m_ts = src->m_ts;\r\nreturn dst;\r\n}\r\nstruct msg_msg *copy_msg(struct msg_msg *src, struct msg_msg *dst)\r\n{\r\nreturn ERR_PTR(-ENOSYS);\r\n}\r\nint store_msg(void __user *dest, struct msg_msg *msg, size_t len)\r\n{\r\nsize_t alen;\r\nstruct msg_msgseg *seg;\r\nalen = min(len, DATALEN_MSG);\r\nif (copy_to_user(dest, msg + 1, alen))\r\nreturn -1;\r\nfor (seg = msg->next; seg != NULL; seg = seg->next) {\r\nlen -= alen;\r\ndest = (char __user *)dest + alen;\r\nalen = min(len, DATALEN_SEG);\r\nif (copy_to_user(dest, seg + 1, alen))\r\nreturn -1;\r\n}\r\nreturn 0;\r\n}\r\nvoid free_msg(struct msg_msg *msg)\r\n{\r\nstruct msg_msgseg *seg;\r\nsecurity_msg_msg_free(msg);\r\nseg = msg->next;\r\nkfree(msg);\r\nwhile (seg != NULL) {\r\nstruct msg_msgseg *tmp = seg->next;\r\nkfree(seg);\r\nseg = tmp;\r\n}\r\n}
