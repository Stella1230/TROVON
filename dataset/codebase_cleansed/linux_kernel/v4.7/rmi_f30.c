static int rmi_f30_read_control_parameters(struct rmi_function *fn,\r\nstruct f30_data *f30)\r\n{\r\nstruct rmi_device *rmi_dev = fn->rmi_dev;\r\nint error = 0;\r\nerror = rmi_read_block(rmi_dev, fn->fd.control_base_addr,\r\nf30->ctrl_regs, f30->ctrl_regs_size);\r\nif (error) {\r\ndev_err(&rmi_dev->dev, "%s : Could not read control registers at 0x%x error (%d)\n",\r\n__func__, fn->fd.control_base_addr, error);\r\nreturn error;\r\n}\r\nreturn 0;\r\n}\r\nstatic int rmi_f30_attention(struct rmi_function *fn, unsigned long *irq_bits)\r\n{\r\nstruct f30_data *f30 = dev_get_drvdata(&fn->dev);\r\nstruct rmi_device *rmi_dev = fn->rmi_dev;\r\nint retval;\r\nint gpiled = 0;\r\nint value = 0;\r\nint i;\r\nint reg_num;\r\nif (!f30->input)\r\nreturn 0;\r\nif (rmi_dev->xport->attn_data) {\r\nmemcpy(f30->data_regs, rmi_dev->xport->attn_data,\r\nf30->register_count);\r\nrmi_dev->xport->attn_data += f30->register_count;\r\nrmi_dev->xport->attn_size -= f30->register_count;\r\n} else {\r\nretval = rmi_read_block(rmi_dev, fn->fd.data_base_addr,\r\nf30->data_regs, f30->register_count);\r\nif (retval) {\r\ndev_err(&fn->dev, "%s: Failed to read F30 data registers.\n",\r\n__func__);\r\nreturn retval;\r\n}\r\n}\r\nfor (reg_num = 0; reg_num < f30->register_count; ++reg_num) {\r\nfor (i = 0; gpiled < f30->gpioled_count && i < 8; ++i,\r\n++gpiled) {\r\nif (f30->gpioled_key_map[gpiled] != 0) {\r\nvalue = (((f30->data_regs[reg_num] >> i) & 0x01)\r\n== 0);\r\nrmi_dbg(RMI_DEBUG_FN, &fn->dev,\r\n"%s: call input report key (0x%04x) value (0x%02x)",\r\n__func__,\r\nf30->gpioled_key_map[gpiled], value);\r\ninput_report_key(f30->input,\r\nf30->gpioled_key_map[gpiled],\r\nvalue);\r\n}\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int rmi_f30_register_device(struct rmi_function *fn)\r\n{\r\nint i;\r\nstruct rmi_device *rmi_dev = fn->rmi_dev;\r\nstruct rmi_driver_data *drv_data = dev_get_drvdata(&rmi_dev->dev);\r\nstruct f30_data *f30 = dev_get_drvdata(&fn->dev);\r\nstruct input_dev *input_dev;\r\nint button_count = 0;\r\ninput_dev = drv_data->input;\r\nif (!input_dev) {\r\ndev_info(&fn->dev, "F30: no input device found, ignoring.\n");\r\nreturn -EINVAL;\r\n}\r\nf30->input = input_dev;\r\nset_bit(EV_KEY, input_dev->evbit);\r\ninput_dev->keycode = f30->gpioled_key_map;\r\ninput_dev->keycodesize = sizeof(u16);\r\ninput_dev->keycodemax = f30->gpioled_count;\r\nfor (i = 0; i < f30->gpioled_count; i++) {\r\nif (f30->gpioled_key_map[i] != 0) {\r\ninput_set_capability(input_dev, EV_KEY,\r\nf30->gpioled_key_map[i]);\r\nbutton_count++;\r\n}\r\n}\r\nif (button_count == 1)\r\n__set_bit(INPUT_PROP_BUTTONPAD, input_dev->propbit);\r\nreturn 0;\r\n}\r\nstatic int rmi_f30_config(struct rmi_function *fn)\r\n{\r\nstruct f30_data *f30 = dev_get_drvdata(&fn->dev);\r\nstruct rmi_driver *drv = fn->rmi_dev->driver;\r\nconst struct rmi_device_platform_data *pdata =\r\nrmi_get_platform_data(fn->rmi_dev);\r\nint error;\r\nif (pdata->f30_data && pdata->f30_data->disable) {\r\ndrv->clear_irq_bits(fn->rmi_dev, fn->irq_mask);\r\n} else {\r\nerror = rmi_write_block(fn->rmi_dev, fn->fd.control_base_addr,\r\nf30->ctrl_regs, f30->ctrl_regs_size);\r\nif (error) {\r\ndev_err(&fn->rmi_dev->dev,\r\n"%s : Could not write control registers at 0x%x error (%d)\n",\r\n__func__, fn->fd.control_base_addr, error);\r\nreturn error;\r\n}\r\ndrv->set_irq_bits(fn->rmi_dev, fn->irq_mask);\r\n}\r\nreturn 0;\r\n}\r\nstatic inline void rmi_f30_set_ctrl_data(struct rmi_f30_ctrl_data *ctrl,\r\nint *ctrl_addr, int len, u8 **reg)\r\n{\r\nctrl->address = *ctrl_addr;\r\nctrl->length = len;\r\nctrl->regs = *reg;\r\n*ctrl_addr += len;\r\n*reg += len;\r\n}\r\nstatic inline bool rmi_f30_is_valid_button(int button,\r\nstruct rmi_f30_ctrl_data *ctrl)\r\n{\r\nint byte_position = button >> 3;\r\nint bit_position = button & 0x07;\r\nreturn !(ctrl[2].regs[byte_position] & BIT(bit_position)) &&\r\n(ctrl[3].regs[byte_position] & BIT(bit_position));\r\n}\r\nstatic inline int rmi_f30_initialize(struct rmi_function *fn)\r\n{\r\nstruct f30_data *f30;\r\nstruct rmi_device *rmi_dev = fn->rmi_dev;\r\nconst struct rmi_device_platform_data *pdata;\r\nint retval = 0;\r\nint control_address;\r\nint i;\r\nint button;\r\nu8 buf[RMI_F30_QUERY_SIZE];\r\nu8 *ctrl_reg;\r\nu8 *map_memory;\r\nf30 = devm_kzalloc(&fn->dev, sizeof(struct f30_data),\r\nGFP_KERNEL);\r\nif (!f30)\r\nreturn -ENOMEM;\r\ndev_set_drvdata(&fn->dev, f30);\r\nretval = rmi_read_block(fn->rmi_dev, fn->fd.query_base_addr, buf,\r\nRMI_F30_QUERY_SIZE);\r\nif (retval) {\r\ndev_err(&fn->dev, "Failed to read query register.\n");\r\nreturn retval;\r\n}\r\nf30->has_extended_pattern = buf[0] & RMI_F30_EXTENDED_PATTERNS;\r\nf30->has_mappable_buttons = buf[0] & RMI_F30_HAS_MAPPABLE_BUTTONS;\r\nf30->has_led = buf[0] & RMI_F30_HAS_LED;\r\nf30->has_gpio = buf[0] & RMI_F30_HAS_GPIO;\r\nf30->has_haptic = buf[0] & RMI_F30_HAS_HAPTIC;\r\nf30->has_gpio_driver_control = buf[0] & RMI_F30_HAS_GPIO_DRV_CTL;\r\nf30->has_mech_mouse_btns = buf[0] & RMI_F30_HAS_MECH_MOUSE_BTNS;\r\nf30->gpioled_count = buf[1] & RMI_F30_GPIO_LED_COUNT;\r\nf30->register_count = (f30->gpioled_count + 7) >> 3;\r\ncontrol_address = fn->fd.control_base_addr;\r\nctrl_reg = f30->ctrl_regs;\r\nif (f30->has_gpio && f30->has_led)\r\nrmi_f30_set_ctrl_data(&f30->ctrl[0], &control_address,\r\nf30->register_count, &ctrl_reg);\r\nrmi_f30_set_ctrl_data(&f30->ctrl[1], &control_address, sizeof(u8),\r\n&ctrl_reg);\r\nif (f30->has_gpio) {\r\nrmi_f30_set_ctrl_data(&f30->ctrl[2], &control_address,\r\nf30->register_count, &ctrl_reg);\r\nrmi_f30_set_ctrl_data(&f30->ctrl[3], &control_address,\r\nf30->register_count, &ctrl_reg);\r\n}\r\nif (f30->has_led) {\r\nint ctrl5_len;\r\nrmi_f30_set_ctrl_data(&f30->ctrl[4], &control_address,\r\nf30->register_count, &ctrl_reg);\r\nif (f30->has_extended_pattern)\r\nctrl5_len = 6;\r\nelse\r\nctrl5_len = 2;\r\nrmi_f30_set_ctrl_data(&f30->ctrl[5], &control_address,\r\nctrl5_len, &ctrl_reg);\r\n}\r\nif (f30->has_led || f30->has_gpio_driver_control) {\r\nrmi_f30_set_ctrl_data(&f30->ctrl[6], &control_address,\r\nf30->gpioled_count, &ctrl_reg);\r\n}\r\nif (f30->has_mappable_buttons) {\r\nrmi_f30_set_ctrl_data(&f30->ctrl[7], &control_address,\r\nf30->gpioled_count, &ctrl_reg);\r\n}\r\nif (f30->has_haptic) {\r\nrmi_f30_set_ctrl_data(&f30->ctrl[8], &control_address,\r\nf30->register_count, &ctrl_reg);\r\nrmi_f30_set_ctrl_data(&f30->ctrl[9], &control_address,\r\nsizeof(u8), &ctrl_reg);\r\n}\r\nif (f30->has_mech_mouse_btns)\r\nrmi_f30_set_ctrl_data(&f30->ctrl[10], &control_address,\r\nsizeof(u8), &ctrl_reg);\r\nf30->ctrl_regs_size = ctrl_reg - f30->ctrl_regs\r\n?: RMI_F30_CTRL_REGS_MAX_SIZE;\r\nretval = rmi_f30_read_control_parameters(fn, f30);\r\nif (retval < 0) {\r\ndev_err(&fn->dev,\r\n"Failed to initialize F19 control params.\n");\r\nreturn retval;\r\n}\r\nmap_memory = devm_kzalloc(&fn->dev,\r\n(f30->gpioled_count * (sizeof(u16))),\r\nGFP_KERNEL);\r\nif (!map_memory) {\r\ndev_err(&fn->dev, "Failed to allocate gpioled map memory.\n");\r\nreturn -ENOMEM;\r\n}\r\nf30->gpioled_key_map = (u16 *)map_memory;\r\npdata = rmi_get_platform_data(rmi_dev);\r\nif (pdata && f30->has_gpio) {\r\nbutton = BTN_LEFT;\r\nfor (i = 0; i < f30->gpioled_count; i++) {\r\nif (rmi_f30_is_valid_button(i, f30->ctrl)) {\r\nf30->gpioled_key_map[i] = button++;\r\nif (pdata->f30_data &&\r\npdata->f30_data->buttonpad)\r\nbreak;\r\n}\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int rmi_f30_probe(struct rmi_function *fn)\r\n{\r\nint rc;\r\nconst struct rmi_device_platform_data *pdata =\r\nrmi_get_platform_data(fn->rmi_dev);\r\nif (pdata->f30_data && pdata->f30_data->disable)\r\nreturn 0;\r\nrc = rmi_f30_initialize(fn);\r\nif (rc < 0)\r\ngoto error_exit;\r\nrc = rmi_f30_register_device(fn);\r\nif (rc < 0)\r\ngoto error_exit;\r\nreturn 0;\r\nerror_exit:\r\nreturn rc;\r\n}
