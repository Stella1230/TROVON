const struct bond_option *bond_opt_get_by_name(const char *name)\r\n{\r\nconst struct bond_option *opt;\r\nint option;\r\nfor (option = 0; option < BOND_OPT_LAST; option++) {\r\nopt = bond_opt_get(option);\r\nif (opt && !strcmp(opt->name, name))\r\nreturn opt;\r\n}\r\nreturn NULL;\r\n}\r\nconst struct bond_opt_value *bond_opt_get_val(unsigned int option, u64 val)\r\n{\r\nconst struct bond_option *opt;\r\nint i;\r\nopt = bond_opt_get(option);\r\nif (WARN_ON(!opt))\r\nreturn NULL;\r\nfor (i = 0; opt->values && opt->values[i].string; i++)\r\nif (opt->values[i].value == val)\r\nreturn &opt->values[i];\r\nreturn NULL;\r\n}\r\nstatic const struct bond_opt_value *bond_opt_get_flags(const struct bond_option *opt,\r\nu32 flagmask)\r\n{\r\nint i;\r\nfor (i = 0; opt->values && opt->values[i].string; i++)\r\nif (opt->values[i].flags & flagmask)\r\nreturn &opt->values[i];\r\nreturn NULL;\r\n}\r\nstatic bool bond_opt_check_range(const struct bond_option *opt, u64 val)\r\n{\r\nconst struct bond_opt_value *minval, *maxval;\r\nminval = bond_opt_get_flags(opt, BOND_VALFLAG_MIN);\r\nmaxval = bond_opt_get_flags(opt, BOND_VALFLAG_MAX);\r\nif (!maxval || (minval && val < minval->value) || val > maxval->value)\r\nreturn false;\r\nreturn true;\r\n}\r\nconst struct bond_opt_value *bond_opt_parse(const struct bond_option *opt,\r\nstruct bond_opt_value *val)\r\n{\r\nchar *p, valstr[BOND_OPT_MAX_NAMELEN + 1] = { 0, };\r\nconst struct bond_opt_value *tbl;\r\nconst struct bond_opt_value *ret = NULL;\r\nbool checkval;\r\nint i, rv;\r\nif (opt->flags & BOND_OPTFLAG_RAWVAL)\r\nreturn val;\r\ntbl = opt->values;\r\nif (!tbl)\r\ngoto out;\r\ncheckval = val->value != ULLONG_MAX;\r\nif (!checkval) {\r\nif (!val->string)\r\ngoto out;\r\np = strchr(val->string, '\n');\r\nif (p)\r\n*p = '\0';\r\nfor (p = val->string; *p; p++)\r\nif (!(isdigit(*p) || isspace(*p)))\r\nbreak;\r\nif (*p) {\r\nrv = sscanf(val->string, "%32s", valstr);\r\n} else {\r\nrv = sscanf(val->string, "%llu", &val->value);\r\ncheckval = true;\r\n}\r\nif (!rv)\r\ngoto out;\r\n}\r\nfor (i = 0; tbl[i].string; i++) {\r\nif (checkval) {\r\nif (val->value == tbl[i].value)\r\nret = &tbl[i];\r\n} else {\r\nif (!strcmp(valstr, "default") &&\r\n(tbl[i].flags & BOND_VALFLAG_DEFAULT))\r\nret = &tbl[i];\r\nif (!strcmp(valstr, tbl[i].string))\r\nret = &tbl[i];\r\n}\r\nif (ret)\r\ngoto out;\r\n}\r\nif (checkval && bond_opt_check_range(opt, val->value))\r\nret = val;\r\nout:\r\nreturn ret;\r\n}\r\nstatic int bond_opt_check_deps(struct bonding *bond,\r\nconst struct bond_option *opt)\r\n{\r\nstruct bond_params *params = &bond->params;\r\nif (test_bit(params->mode, &opt->unsuppmodes))\r\nreturn -EACCES;\r\nif ((opt->flags & BOND_OPTFLAG_NOSLAVES) && bond_has_slaves(bond))\r\nreturn -ENOTEMPTY;\r\nif ((opt->flags & BOND_OPTFLAG_IFDOWN) && (bond->dev->flags & IFF_UP))\r\nreturn -EBUSY;\r\nreturn 0;\r\n}\r\nstatic void bond_opt_dep_print(struct bonding *bond,\r\nconst struct bond_option *opt)\r\n{\r\nconst struct bond_opt_value *modeval;\r\nstruct bond_params *params;\r\nparams = &bond->params;\r\nmodeval = bond_opt_get_val(BOND_OPT_MODE, params->mode);\r\nif (test_bit(params->mode, &opt->unsuppmodes))\r\nnetdev_err(bond->dev, "option %s: mode dependency failed, not supported in mode %s(%llu)\n",\r\nopt->name, modeval->string, modeval->value);\r\n}\r\nstatic void bond_opt_error_interpret(struct bonding *bond,\r\nconst struct bond_option *opt,\r\nint error, const struct bond_opt_value *val)\r\n{\r\nconst struct bond_opt_value *minval, *maxval;\r\nchar *p;\r\nswitch (error) {\r\ncase -EINVAL:\r\nif (val) {\r\nif (val->string) {\r\np = strchr(val->string, '\n');\r\nif (p)\r\n*p = '\0';\r\nnetdev_err(bond->dev, "option %s: invalid value (%s)\n",\r\nopt->name, val->string);\r\n} else {\r\nnetdev_err(bond->dev, "option %s: invalid value (%llu)\n",\r\nopt->name, val->value);\r\n}\r\n}\r\nminval = bond_opt_get_flags(opt, BOND_VALFLAG_MIN);\r\nmaxval = bond_opt_get_flags(opt, BOND_VALFLAG_MAX);\r\nif (!maxval)\r\nbreak;\r\nnetdev_err(bond->dev, "option %s: allowed values %llu - %llu\n",\r\nopt->name, minval ? minval->value : 0, maxval->value);\r\nbreak;\r\ncase -EACCES:\r\nbond_opt_dep_print(bond, opt);\r\nbreak;\r\ncase -ENOTEMPTY:\r\nnetdev_err(bond->dev, "option %s: unable to set because the bond device has slaves\n",\r\nopt->name);\r\nbreak;\r\ncase -EBUSY:\r\nnetdev_err(bond->dev, "option %s: unable to set because the bond device is up\n",\r\nopt->name);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nint __bond_opt_set(struct bonding *bond,\r\nunsigned int option, struct bond_opt_value *val)\r\n{\r\nconst struct bond_opt_value *retval = NULL;\r\nconst struct bond_option *opt;\r\nint ret = -ENOENT;\r\nASSERT_RTNL();\r\nopt = bond_opt_get(option);\r\nif (WARN_ON(!val) || WARN_ON(!opt))\r\ngoto out;\r\nret = bond_opt_check_deps(bond, opt);\r\nif (ret)\r\ngoto out;\r\nretval = bond_opt_parse(opt, val);\r\nif (!retval) {\r\nret = -EINVAL;\r\ngoto out;\r\n}\r\nret = opt->set(bond, retval);\r\nout:\r\nif (ret)\r\nbond_opt_error_interpret(bond, opt, ret, val);\r\nelse if (bond->dev->reg_state == NETREG_REGISTERED)\r\ncall_netdevice_notifiers(NETDEV_CHANGEINFODATA, bond->dev);\r\nreturn ret;\r\n}\r\nint bond_opt_tryset_rtnl(struct bonding *bond, unsigned int option, char *buf)\r\n{\r\nstruct bond_opt_value optval;\r\nint ret;\r\nif (!rtnl_trylock())\r\nreturn restart_syscall();\r\nbond_opt_initstr(&optval, buf);\r\nret = __bond_opt_set(bond, option, &optval);\r\nrtnl_unlock();\r\nreturn ret;\r\n}\r\nconst struct bond_option *bond_opt_get(unsigned int option)\r\n{\r\nif (!BOND_OPT_VALID(option))\r\nreturn NULL;\r\nreturn &bond_opts[option];\r\n}\r\nstatic int bond_option_mode_set(struct bonding *bond,\r\nconst struct bond_opt_value *newval)\r\n{\r\nif (!bond_mode_uses_arp(newval->value) && bond->params.arp_interval) {\r\nnetdev_info(bond->dev, "%s mode is incompatible with arp monitoring, start mii monitoring\n",\r\nnewval->string);\r\nbond->params.arp_interval = 0;\r\nbond->params.miimon = BOND_DEFAULT_MIIMON;\r\nnetdev_info(bond->dev, "Setting MII monitoring interval to %d\n",\r\nbond->params.miimon);\r\n}\r\nbond->params.arp_validate = BOND_ARP_VALIDATE_NONE;\r\nbond->params.mode = newval->value;\r\nreturn 0;\r\n}\r\nstatic int bond_option_active_slave_set(struct bonding *bond,\r\nconst struct bond_opt_value *newval)\r\n{\r\nchar ifname[IFNAMSIZ] = { 0, };\r\nstruct net_device *slave_dev;\r\nint ret = 0;\r\nsscanf(newval->string, "%15s", ifname);\r\nif (!strlen(ifname) || newval->string[0] == '\n') {\r\nslave_dev = NULL;\r\n} else {\r\nslave_dev = __dev_get_by_name(dev_net(bond->dev), ifname);\r\nif (!slave_dev)\r\nreturn -ENODEV;\r\n}\r\nif (slave_dev) {\r\nif (!netif_is_bond_slave(slave_dev)) {\r\nnetdev_err(bond->dev, "Device %s is not bonding slave\n",\r\nslave_dev->name);\r\nreturn -EINVAL;\r\n}\r\nif (bond->dev != netdev_master_upper_dev_get(slave_dev)) {\r\nnetdev_err(bond->dev, "Device %s is not our slave\n",\r\nslave_dev->name);\r\nreturn -EINVAL;\r\n}\r\n}\r\nblock_netpoll_tx();\r\nif (!slave_dev) {\r\nnetdev_info(bond->dev, "Clearing current active slave\n");\r\nRCU_INIT_POINTER(bond->curr_active_slave, NULL);\r\nbond_select_active_slave(bond);\r\n} else {\r\nstruct slave *old_active = rtnl_dereference(bond->curr_active_slave);\r\nstruct slave *new_active = bond_slave_get_rtnl(slave_dev);\r\nBUG_ON(!new_active);\r\nif (new_active == old_active) {\r\nnetdev_info(bond->dev, "%s is already the current active slave\n",\r\nnew_active->dev->name);\r\n} else {\r\nif (old_active && (new_active->link == BOND_LINK_UP) &&\r\nbond_slave_is_up(new_active)) {\r\nnetdev_info(bond->dev, "Setting %s as active slave\n",\r\nnew_active->dev->name);\r\nbond_change_active_slave(bond, new_active);\r\n} else {\r\nnetdev_err(bond->dev, "Could not set %s as active slave; either %s is down or the link is down\n",\r\nnew_active->dev->name,\r\nnew_active->dev->name);\r\nret = -EINVAL;\r\n}\r\n}\r\n}\r\nunblock_netpoll_tx();\r\nreturn ret;\r\n}\r\nstatic int bond_option_miimon_set(struct bonding *bond,\r\nconst struct bond_opt_value *newval)\r\n{\r\nnetdev_info(bond->dev, "Setting MII monitoring interval to %llu\n",\r\nnewval->value);\r\nbond->params.miimon = newval->value;\r\nif (bond->params.updelay)\r\nnetdev_info(bond->dev, "Note: Updating updelay (to %d) since it is a multiple of the miimon value\n",\r\nbond->params.updelay * bond->params.miimon);\r\nif (bond->params.downdelay)\r\nnetdev_info(bond->dev, "Note: Updating downdelay (to %d) since it is a multiple of the miimon value\n",\r\nbond->params.downdelay * bond->params.miimon);\r\nif (newval->value && bond->params.arp_interval) {\r\nnetdev_info(bond->dev, "MII monitoring cannot be used with ARP monitoring - disabling ARP monitoring...\n");\r\nbond->params.arp_interval = 0;\r\nif (bond->params.arp_validate)\r\nbond->params.arp_validate = BOND_ARP_VALIDATE_NONE;\r\n}\r\nif (bond->dev->flags & IFF_UP) {\r\nif (!newval->value) {\r\ncancel_delayed_work_sync(&bond->mii_work);\r\n} else {\r\ncancel_delayed_work_sync(&bond->arp_work);\r\nqueue_delayed_work(bond->wq, &bond->mii_work, 0);\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int bond_option_updelay_set(struct bonding *bond,\r\nconst struct bond_opt_value *newval)\r\n{\r\nint value = newval->value;\r\nif (!bond->params.miimon) {\r\nnetdev_err(bond->dev, "Unable to set up delay as MII monitoring is disabled\n");\r\nreturn -EPERM;\r\n}\r\nif ((value % bond->params.miimon) != 0) {\r\nnetdev_warn(bond->dev, "up delay (%d) is not a multiple of miimon (%d), updelay rounded to %d ms\n",\r\nvalue, bond->params.miimon,\r\n(value / bond->params.miimon) *\r\nbond->params.miimon);\r\n}\r\nbond->params.updelay = value / bond->params.miimon;\r\nnetdev_info(bond->dev, "Setting up delay to %d\n",\r\nbond->params.updelay * bond->params.miimon);\r\nreturn 0;\r\n}\r\nstatic int bond_option_downdelay_set(struct bonding *bond,\r\nconst struct bond_opt_value *newval)\r\n{\r\nint value = newval->value;\r\nif (!bond->params.miimon) {\r\nnetdev_err(bond->dev, "Unable to set down delay as MII monitoring is disabled\n");\r\nreturn -EPERM;\r\n}\r\nif ((value % bond->params.miimon) != 0) {\r\nnetdev_warn(bond->dev, "down delay (%d) is not a multiple of miimon (%d), delay rounded to %d ms\n",\r\nvalue, bond->params.miimon,\r\n(value / bond->params.miimon) *\r\nbond->params.miimon);\r\n}\r\nbond->params.downdelay = value / bond->params.miimon;\r\nnetdev_info(bond->dev, "Setting down delay to %d\n",\r\nbond->params.downdelay * bond->params.miimon);\r\nreturn 0;\r\n}\r\nstatic int bond_option_use_carrier_set(struct bonding *bond,\r\nconst struct bond_opt_value *newval)\r\n{\r\nnetdev_info(bond->dev, "Setting use_carrier to %llu\n",\r\nnewval->value);\r\nbond->params.use_carrier = newval->value;\r\nreturn 0;\r\n}\r\nstatic int bond_option_arp_interval_set(struct bonding *bond,\r\nconst struct bond_opt_value *newval)\r\n{\r\nnetdev_info(bond->dev, "Setting ARP monitoring interval to %llu\n",\r\nnewval->value);\r\nbond->params.arp_interval = newval->value;\r\nif (newval->value) {\r\nif (bond->params.miimon) {\r\nnetdev_info(bond->dev, "ARP monitoring cannot be used with MII monitoring. Disabling MII monitoring\n");\r\nbond->params.miimon = 0;\r\n}\r\nif (!bond->params.arp_targets[0])\r\nnetdev_info(bond->dev, "ARP monitoring has been set up, but no ARP targets have been specified\n");\r\n}\r\nif (bond->dev->flags & IFF_UP) {\r\nif (!newval->value) {\r\nif (bond->params.arp_validate)\r\nbond->recv_probe = NULL;\r\ncancel_delayed_work_sync(&bond->arp_work);\r\n} else {\r\nbond->recv_probe = bond_arp_rcv;\r\ncancel_delayed_work_sync(&bond->mii_work);\r\nqueue_delayed_work(bond->wq, &bond->arp_work, 0);\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic void _bond_options_arp_ip_target_set(struct bonding *bond, int slot,\r\n__be32 target,\r\nunsigned long last_rx)\r\n{\r\n__be32 *targets = bond->params.arp_targets;\r\nstruct list_head *iter;\r\nstruct slave *slave;\r\nif (slot >= 0 && slot < BOND_MAX_ARP_TARGETS) {\r\nbond_for_each_slave(bond, slave, iter)\r\nslave->target_last_arp_rx[slot] = last_rx;\r\ntargets[slot] = target;\r\n}\r\n}\r\nstatic int _bond_option_arp_ip_target_add(struct bonding *bond, __be32 target)\r\n{\r\n__be32 *targets = bond->params.arp_targets;\r\nint ind;\r\nif (!bond_is_ip_target_ok(target)) {\r\nnetdev_err(bond->dev, "invalid ARP target %pI4 specified for addition\n",\r\n&target);\r\nreturn -EINVAL;\r\n}\r\nif (bond_get_targets_ip(targets, target) != -1) {\r\nnetdev_err(bond->dev, "ARP target %pI4 is already present\n",\r\n&target);\r\nreturn -EINVAL;\r\n}\r\nind = bond_get_targets_ip(targets, 0);\r\nif (ind == -1) {\r\nnetdev_err(bond->dev, "ARP target table is full!\n");\r\nreturn -EINVAL;\r\n}\r\nnetdev_info(bond->dev, "Adding ARP target %pI4\n", &target);\r\n_bond_options_arp_ip_target_set(bond, ind, target, jiffies);\r\nreturn 0;\r\n}\r\nstatic int bond_option_arp_ip_target_add(struct bonding *bond, __be32 target)\r\n{\r\nreturn _bond_option_arp_ip_target_add(bond, target);\r\n}\r\nstatic int bond_option_arp_ip_target_rem(struct bonding *bond, __be32 target)\r\n{\r\n__be32 *targets = bond->params.arp_targets;\r\nstruct list_head *iter;\r\nstruct slave *slave;\r\nunsigned long *targets_rx;\r\nint ind, i;\r\nif (!bond_is_ip_target_ok(target)) {\r\nnetdev_err(bond->dev, "invalid ARP target %pI4 specified for removal\n",\r\n&target);\r\nreturn -EINVAL;\r\n}\r\nind = bond_get_targets_ip(targets, target);\r\nif (ind == -1) {\r\nnetdev_err(bond->dev, "unable to remove nonexistent ARP target %pI4\n",\r\n&target);\r\nreturn -EINVAL;\r\n}\r\nif (ind == 0 && !targets[1] && bond->params.arp_interval)\r\nnetdev_warn(bond->dev, "Removing last arp target with arp_interval on\n");\r\nnetdev_info(bond->dev, "Removing ARP target %pI4\n", &target);\r\nbond_for_each_slave(bond, slave, iter) {\r\ntargets_rx = slave->target_last_arp_rx;\r\nfor (i = ind; (i < BOND_MAX_ARP_TARGETS-1) && targets[i+1]; i++)\r\ntargets_rx[i] = targets_rx[i+1];\r\ntargets_rx[i] = 0;\r\n}\r\nfor (i = ind; (i < BOND_MAX_ARP_TARGETS-1) && targets[i+1]; i++)\r\ntargets[i] = targets[i+1];\r\ntargets[i] = 0;\r\nreturn 0;\r\n}\r\nvoid bond_option_arp_ip_targets_clear(struct bonding *bond)\r\n{\r\nint i;\r\nfor (i = 0; i < BOND_MAX_ARP_TARGETS; i++)\r\n_bond_options_arp_ip_target_set(bond, i, 0, 0);\r\n}\r\nstatic int bond_option_arp_ip_targets_set(struct bonding *bond,\r\nconst struct bond_opt_value *newval)\r\n{\r\nint ret = -EPERM;\r\n__be32 target;\r\nif (newval->string) {\r\nif (!in4_pton(newval->string+1, -1, (u8 *)&target, -1, NULL)) {\r\nnetdev_err(bond->dev, "invalid ARP target %pI4 specified\n",\r\n&target);\r\nreturn ret;\r\n}\r\nif (newval->string[0] == '+')\r\nret = bond_option_arp_ip_target_add(bond, target);\r\nelse if (newval->string[0] == '-')\r\nret = bond_option_arp_ip_target_rem(bond, target);\r\nelse\r\nnetdev_err(bond->dev, "no command found in arp_ip_targets file - use +<addr> or -<addr>\n");\r\n} else {\r\ntarget = newval->value;\r\nret = bond_option_arp_ip_target_add(bond, target);\r\n}\r\nreturn ret;\r\n}\r\nstatic int bond_option_arp_validate_set(struct bonding *bond,\r\nconst struct bond_opt_value *newval)\r\n{\r\nnetdev_info(bond->dev, "Setting arp_validate to %s (%llu)\n",\r\nnewval->string, newval->value);\r\nif (bond->dev->flags & IFF_UP) {\r\nif (!newval->value)\r\nbond->recv_probe = NULL;\r\nelse if (bond->params.arp_interval)\r\nbond->recv_probe = bond_arp_rcv;\r\n}\r\nbond->params.arp_validate = newval->value;\r\nreturn 0;\r\n}\r\nstatic int bond_option_arp_all_targets_set(struct bonding *bond,\r\nconst struct bond_opt_value *newval)\r\n{\r\nnetdev_info(bond->dev, "Setting arp_all_targets to %s (%llu)\n",\r\nnewval->string, newval->value);\r\nbond->params.arp_all_targets = newval->value;\r\nreturn 0;\r\n}\r\nstatic int bond_option_primary_set(struct bonding *bond,\r\nconst struct bond_opt_value *newval)\r\n{\r\nchar *p, *primary = newval->string;\r\nstruct list_head *iter;\r\nstruct slave *slave;\r\nblock_netpoll_tx();\r\np = strchr(primary, '\n');\r\nif (p)\r\n*p = '\0';\r\nif (!strlen(primary)) {\r\nnetdev_info(bond->dev, "Setting primary slave to None\n");\r\nRCU_INIT_POINTER(bond->primary_slave, NULL);\r\nmemset(bond->params.primary, 0, sizeof(bond->params.primary));\r\nbond_select_active_slave(bond);\r\ngoto out;\r\n}\r\nbond_for_each_slave(bond, slave, iter) {\r\nif (strncmp(slave->dev->name, primary, IFNAMSIZ) == 0) {\r\nnetdev_info(bond->dev, "Setting %s as primary slave\n",\r\nslave->dev->name);\r\nrcu_assign_pointer(bond->primary_slave, slave);\r\nstrcpy(bond->params.primary, slave->dev->name);\r\nbond_select_active_slave(bond);\r\ngoto out;\r\n}\r\n}\r\nif (rtnl_dereference(bond->primary_slave)) {\r\nnetdev_info(bond->dev, "Setting primary slave to None\n");\r\nRCU_INIT_POINTER(bond->primary_slave, NULL);\r\nbond_select_active_slave(bond);\r\n}\r\nstrncpy(bond->params.primary, primary, IFNAMSIZ);\r\nbond->params.primary[IFNAMSIZ - 1] = 0;\r\nnetdev_info(bond->dev, "Recording %s as primary, but it has not been enslaved to %s yet\n",\r\nprimary, bond->dev->name);\r\nout:\r\nunblock_netpoll_tx();\r\nreturn 0;\r\n}\r\nstatic int bond_option_primary_reselect_set(struct bonding *bond,\r\nconst struct bond_opt_value *newval)\r\n{\r\nnetdev_info(bond->dev, "Setting primary_reselect to %s (%llu)\n",\r\nnewval->string, newval->value);\r\nbond->params.primary_reselect = newval->value;\r\nblock_netpoll_tx();\r\nbond_select_active_slave(bond);\r\nunblock_netpoll_tx();\r\nreturn 0;\r\n}\r\nstatic int bond_option_fail_over_mac_set(struct bonding *bond,\r\nconst struct bond_opt_value *newval)\r\n{\r\nnetdev_info(bond->dev, "Setting fail_over_mac to %s (%llu)\n",\r\nnewval->string, newval->value);\r\nbond->params.fail_over_mac = newval->value;\r\nreturn 0;\r\n}\r\nstatic int bond_option_xmit_hash_policy_set(struct bonding *bond,\r\nconst struct bond_opt_value *newval)\r\n{\r\nnetdev_info(bond->dev, "Setting xmit hash policy to %s (%llu)\n",\r\nnewval->string, newval->value);\r\nbond->params.xmit_policy = newval->value;\r\nreturn 0;\r\n}\r\nstatic int bond_option_resend_igmp_set(struct bonding *bond,\r\nconst struct bond_opt_value *newval)\r\n{\r\nnetdev_info(bond->dev, "Setting resend_igmp to %llu\n",\r\nnewval->value);\r\nbond->params.resend_igmp = newval->value;\r\nreturn 0;\r\n}\r\nstatic int bond_option_num_peer_notif_set(struct bonding *bond,\r\nconst struct bond_opt_value *newval)\r\n{\r\nbond->params.num_peer_notif = newval->value;\r\nreturn 0;\r\n}\r\nstatic int bond_option_all_slaves_active_set(struct bonding *bond,\r\nconst struct bond_opt_value *newval)\r\n{\r\nstruct list_head *iter;\r\nstruct slave *slave;\r\nif (newval->value == bond->params.all_slaves_active)\r\nreturn 0;\r\nbond->params.all_slaves_active = newval->value;\r\nbond_for_each_slave(bond, slave, iter) {\r\nif (!bond_is_active_slave(slave)) {\r\nif (newval->value)\r\nslave->inactive = 0;\r\nelse\r\nslave->inactive = 1;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int bond_option_min_links_set(struct bonding *bond,\r\nconst struct bond_opt_value *newval)\r\n{\r\nnetdev_info(bond->dev, "Setting min links value to %llu\n",\r\nnewval->value);\r\nbond->params.min_links = newval->value;\r\nbond_set_carrier(bond);\r\nreturn 0;\r\n}\r\nstatic int bond_option_lp_interval_set(struct bonding *bond,\r\nconst struct bond_opt_value *newval)\r\n{\r\nbond->params.lp_interval = newval->value;\r\nreturn 0;\r\n}\r\nstatic int bond_option_pps_set(struct bonding *bond,\r\nconst struct bond_opt_value *newval)\r\n{\r\nbond->params.packets_per_slave = newval->value;\r\nif (newval->value > 0) {\r\nbond->params.reciprocal_packets_per_slave =\r\nreciprocal_value(newval->value);\r\n} else {\r\nbond->params.reciprocal_packets_per_slave =\r\n(struct reciprocal_value) { 0 };\r\n}\r\nreturn 0;\r\n}\r\nstatic int bond_option_lacp_rate_set(struct bonding *bond,\r\nconst struct bond_opt_value *newval)\r\n{\r\nnetdev_info(bond->dev, "Setting LACP rate to %s (%llu)\n",\r\nnewval->string, newval->value);\r\nbond->params.lacp_fast = newval->value;\r\nbond_3ad_update_lacp_rate(bond);\r\nreturn 0;\r\n}\r\nstatic int bond_option_ad_select_set(struct bonding *bond,\r\nconst struct bond_opt_value *newval)\r\n{\r\nnetdev_info(bond->dev, "Setting ad_select to %s (%llu)\n",\r\nnewval->string, newval->value);\r\nbond->params.ad_select = newval->value;\r\nreturn 0;\r\n}\r\nstatic int bond_option_queue_id_set(struct bonding *bond,\r\nconst struct bond_opt_value *newval)\r\n{\r\nstruct slave *slave, *update_slave;\r\nstruct net_device *sdev;\r\nstruct list_head *iter;\r\nchar *delim;\r\nint ret = 0;\r\nu16 qid;\r\ndelim = strchr(newval->string, ':');\r\nif (!delim)\r\ngoto err_no_cmd;\r\n*delim = '\0';\r\nif (sscanf(++delim, "%hd\n", &qid) != 1)\r\ngoto err_no_cmd;\r\nif (!dev_valid_name(newval->string) ||\r\nqid > bond->dev->real_num_tx_queues)\r\ngoto err_no_cmd;\r\nsdev = __dev_get_by_name(dev_net(bond->dev), newval->string);\r\nif (!sdev)\r\ngoto err_no_cmd;\r\nupdate_slave = NULL;\r\nbond_for_each_slave(bond, slave, iter) {\r\nif (sdev == slave->dev)\r\nupdate_slave = slave;\r\nelse if (qid && qid == slave->queue_id) {\r\ngoto err_no_cmd;\r\n}\r\n}\r\nif (!update_slave)\r\ngoto err_no_cmd;\r\nupdate_slave->queue_id = qid;\r\nout:\r\nreturn ret;\r\nerr_no_cmd:\r\nnetdev_info(bond->dev, "invalid input for queue_id set\n");\r\nret = -EPERM;\r\ngoto out;\r\n}\r\nstatic int bond_option_slaves_set(struct bonding *bond,\r\nconst struct bond_opt_value *newval)\r\n{\r\nchar command[IFNAMSIZ + 1] = { 0, };\r\nstruct net_device *dev;\r\nchar *ifname;\r\nint ret;\r\nsscanf(newval->string, "%16s", command);\r\nifname = command + 1;\r\nif ((strlen(command) <= 1) ||\r\n!dev_valid_name(ifname))\r\ngoto err_no_cmd;\r\ndev = __dev_get_by_name(dev_net(bond->dev), ifname);\r\nif (!dev) {\r\nnetdev_info(bond->dev, "interface %s does not exist!\n",\r\nifname);\r\nret = -ENODEV;\r\ngoto out;\r\n}\r\nswitch (command[0]) {\r\ncase '+':\r\nnetdev_info(bond->dev, "Adding slave %s\n", dev->name);\r\nret = bond_enslave(bond->dev, dev);\r\nbreak;\r\ncase '-':\r\nnetdev_info(bond->dev, "Removing slave %s\n", dev->name);\r\nret = bond_release(bond->dev, dev);\r\nbreak;\r\ndefault:\r\ngoto err_no_cmd;\r\n}\r\nout:\r\nreturn ret;\r\nerr_no_cmd:\r\nnetdev_err(bond->dev, "no command found in slaves file - use +ifname or -ifname\n");\r\nret = -EPERM;\r\ngoto out;\r\n}\r\nstatic int bond_option_tlb_dynamic_lb_set(struct bonding *bond,\r\nconst struct bond_opt_value *newval)\r\n{\r\nnetdev_info(bond->dev, "Setting dynamic-lb to %s (%llu)\n",\r\nnewval->string, newval->value);\r\nbond->params.tlb_dynamic_lb = newval->value;\r\nreturn 0;\r\n}\r\nstatic int bond_option_ad_actor_sys_prio_set(struct bonding *bond,\r\nconst struct bond_opt_value *newval)\r\n{\r\nnetdev_info(bond->dev, "Setting ad_actor_sys_prio to %llu\n",\r\nnewval->value);\r\nbond->params.ad_actor_sys_prio = newval->value;\r\nbond_3ad_update_ad_actor_settings(bond);\r\nreturn 0;\r\n}\r\nstatic int bond_option_ad_actor_system_set(struct bonding *bond,\r\nconst struct bond_opt_value *newval)\r\n{\r\nu8 macaddr[ETH_ALEN];\r\nu8 *mac;\r\nint i;\r\nif (newval->string) {\r\ni = sscanf(newval->string, "%hhx:%hhx:%hhx:%hhx:%hhx:%hhx",\r\n&macaddr[0], &macaddr[1], &macaddr[2],\r\n&macaddr[3], &macaddr[4], &macaddr[5]);\r\nif (i != ETH_ALEN)\r\ngoto err;\r\nmac = macaddr;\r\n} else {\r\nmac = (u8 *)&newval->value;\r\n}\r\nif (!is_valid_ether_addr(mac))\r\ngoto err;\r\nnetdev_info(bond->dev, "Setting ad_actor_system to %pM\n", mac);\r\nether_addr_copy(bond->params.ad_actor_system, mac);\r\nbond_3ad_update_ad_actor_settings(bond);\r\nreturn 0;\r\nerr:\r\nnetdev_err(bond->dev, "Invalid MAC address.\n");\r\nreturn -EINVAL;\r\n}\r\nstatic int bond_option_ad_user_port_key_set(struct bonding *bond,\r\nconst struct bond_opt_value *newval)\r\n{\r\nnetdev_info(bond->dev, "Setting ad_user_port_key to %llu\n",\r\nnewval->value);\r\nbond->params.ad_user_port_key = newval->value;\r\nreturn 0;\r\n}
