static irqreturn_t sun4i_ps2_interrupt(int irq, void *dev_id)\r\n{\r\nstruct sun4i_ps2data *drvdata = dev_id;\r\nu32 intr_status;\r\nu32 fifo_status;\r\nunsigned char byte;\r\nunsigned int rxflags = 0;\r\nu32 rval;\r\nspin_lock(&drvdata->lock);\r\nintr_status = readl(drvdata->reg_base + PS2_REG_LSTS);\r\nfifo_status = readl(drvdata->reg_base + PS2_REG_FSTS);\r\nif (intr_status & PS2_LINE_ERROR_BIT) {\r\nrxflags = (intr_status & PS2_LINE_ERROR_BIT) ? SERIO_FRAME : 0;\r\nrxflags |= (intr_status & PS2_LSTS_PARERR) ? SERIO_PARITY : 0;\r\nrxflags |= (intr_status & PS2_LSTS_PARERR) ? SERIO_TIMEOUT : 0;\r\nrval = PS2_LSTS_TXTDO | PS2_LSTS_STOPERR | PS2_LSTS_ACKERR |\r\nPS2_LSTS_PARERR | PS2_LSTS_RXTDO;\r\nwritel(rval, drvdata->reg_base + PS2_REG_LSTS);\r\n}\r\nif (fifo_status & PS2_FIFO_ERROR_BIT) {\r\nrval = PS2_FSTS_TXUF | PS2_FSTS_TXOF | PS2_FSTS_TXRDY |\r\nPS2_FSTS_RXUF | PS2_FSTS_RXOF | PS2_FSTS_RXRDY;\r\nwritel(rval, drvdata->reg_base + PS2_REG_FSTS);\r\n}\r\nrval = (fifo_status >> 16) & 0x3;\r\nwhile (rval--) {\r\nbyte = readl(drvdata->reg_base + PS2_REG_DATA) & 0xff;\r\nserio_interrupt(drvdata->serio, byte, rxflags);\r\n}\r\nwritel(intr_status, drvdata->reg_base + PS2_REG_LSTS);\r\nwritel(fifo_status, drvdata->reg_base + PS2_REG_FSTS);\r\nspin_unlock(&drvdata->lock);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int sun4i_ps2_open(struct serio *serio)\r\n{\r\nstruct sun4i_ps2data *drvdata = serio->port_data;\r\nu32 src_clk = 0;\r\nu32 clk_scdf;\r\nu32 clk_pcdf;\r\nu32 rval;\r\nunsigned long flags;\r\nrval = PS2_LCTL_STOPERREN | PS2_LCTL_ACKERREN\r\n| PS2_LCTL_PARERREN | PS2_LCTL_RXDTOEN;\r\nwritel(rval, drvdata->reg_base + PS2_REG_LCTL);\r\nrval = PS2_FCTL_TXRST | PS2_FCTL_RXRST | PS2_FCTL_TXUFIEN\r\n| PS2_FCTL_TXOFIEN | PS2_FCTL_RXUFIEN\r\n| PS2_FCTL_RXOFIEN | PS2_FCTL_RXRDYIEN;\r\nwritel(rval, drvdata->reg_base + PS2_REG_FCTL);\r\nsrc_clk = clk_get_rate(drvdata->clk);\r\nclk_scdf = src_clk / PS2_SAMPLE_CLK - 1;\r\nclk_pcdf = PS2_SAMPLE_CLK / PS2_SCLK - 1;\r\nrval = (clk_scdf << 8) | clk_pcdf;\r\nwritel(rval, drvdata->reg_base + PS2_REG_CLKDR);\r\nrval = PS2_GCTL_RESET | PS2_GCTL_INTEN | PS2_GCTL_MASTER\r\n| PS2_GCTL_BUSEN;\r\nspin_lock_irqsave(&drvdata->lock, flags);\r\nwritel(rval, drvdata->reg_base + PS2_REG_GCTL);\r\nspin_unlock_irqrestore(&drvdata->lock, flags);\r\nreturn 0;\r\n}\r\nstatic void sun4i_ps2_close(struct serio *serio)\r\n{\r\nstruct sun4i_ps2data *drvdata = serio->port_data;\r\nu32 rval;\r\nrval = readl(drvdata->reg_base + PS2_REG_GCTL);\r\nwritel(rval & ~(PS2_GCTL_INTEN), drvdata->reg_base + PS2_REG_GCTL);\r\nsynchronize_irq(drvdata->irq);\r\n}\r\nstatic int sun4i_ps2_write(struct serio *serio, unsigned char val)\r\n{\r\nunsigned long expire = jiffies + msecs_to_jiffies(10000);\r\nstruct sun4i_ps2data *drvdata = serio->port_data;\r\ndo {\r\nif (readl(drvdata->reg_base + PS2_REG_FSTS) & PS2_FSTS_TXRDY) {\r\nwritel(val, drvdata->reg_base + PS2_REG_DATA);\r\nreturn 0;\r\n}\r\n} while (time_before(jiffies, expire));\r\nreturn SERIO_TIMEOUT;\r\n}\r\nstatic int sun4i_ps2_probe(struct platform_device *pdev)\r\n{\r\nstruct resource *res;\r\nstruct sun4i_ps2data *drvdata;\r\nstruct serio *serio;\r\nstruct device *dev = &pdev->dev;\r\nunsigned int irq;\r\nint error;\r\ndrvdata = kzalloc(sizeof(struct sun4i_ps2data), GFP_KERNEL);\r\nserio = kzalloc(sizeof(struct serio), GFP_KERNEL);\r\nif (!drvdata || !serio) {\r\nerror = -ENOMEM;\r\ngoto err_free_mem;\r\n}\r\nspin_lock_init(&drvdata->lock);\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nif (!res) {\r\ndev_err(dev, "failed to locate registers\n");\r\nerror = -ENXIO;\r\ngoto err_free_mem;\r\n}\r\ndrvdata->reg_base = ioremap(res->start, resource_size(res));\r\nif (!drvdata->reg_base) {\r\ndev_err(dev, "failed to map registers\n");\r\nerror = -ENOMEM;\r\ngoto err_free_mem;\r\n}\r\ndrvdata->clk = clk_get(dev, NULL);\r\nif (IS_ERR(drvdata->clk)) {\r\nerror = PTR_ERR(drvdata->clk);\r\ndev_err(dev, "couldn't get clock %d\n", error);\r\ngoto err_ioremap;\r\n}\r\nerror = clk_prepare_enable(drvdata->clk);\r\nif (error) {\r\ndev_err(dev, "failed to enable clock %d\n", error);\r\ngoto err_clk;\r\n}\r\nserio->id.type = SERIO_8042;\r\nserio->write = sun4i_ps2_write;\r\nserio->open = sun4i_ps2_open;\r\nserio->close = sun4i_ps2_close;\r\nserio->port_data = drvdata;\r\nserio->dev.parent = dev;\r\nstrlcpy(serio->name, dev_name(dev), sizeof(serio->name));\r\nstrlcpy(serio->phys, dev_name(dev), sizeof(serio->phys));\r\nwritel(0, drvdata->reg_base + PS2_REG_GCTL);\r\nirq = platform_get_irq(pdev, 0);\r\nif (!irq) {\r\ndev_err(dev, "no IRQ found\n");\r\nerror = -ENXIO;\r\ngoto err_disable_clk;\r\n}\r\ndrvdata->irq = irq;\r\ndrvdata->serio = serio;\r\ndrvdata->dev = dev;\r\nerror = request_irq(drvdata->irq, sun4i_ps2_interrupt, 0,\r\nDRIVER_NAME, drvdata);\r\nif (error) {\r\ndev_err(drvdata->dev, "failed to allocate interrupt %d: %d\n",\r\ndrvdata->irq, error);\r\ngoto err_disable_clk;\r\n}\r\nserio_register_port(serio);\r\nplatform_set_drvdata(pdev, drvdata);\r\nreturn 0;\r\nerr_disable_clk:\r\nclk_disable_unprepare(drvdata->clk);\r\nerr_clk:\r\nclk_put(drvdata->clk);\r\nerr_ioremap:\r\niounmap(drvdata->reg_base);\r\nerr_free_mem:\r\nkfree(serio);\r\nkfree(drvdata);\r\nreturn error;\r\n}\r\nstatic int sun4i_ps2_remove(struct platform_device *pdev)\r\n{\r\nstruct sun4i_ps2data *drvdata = platform_get_drvdata(pdev);\r\nserio_unregister_port(drvdata->serio);\r\nfree_irq(drvdata->irq, drvdata);\r\nclk_disable_unprepare(drvdata->clk);\r\nclk_put(drvdata->clk);\r\niounmap(drvdata->reg_base);\r\nkfree(drvdata);\r\nreturn 0;\r\n}
