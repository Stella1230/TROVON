static struct csio_lnode *\r\ncsio_ln_lookup_by_portid(struct csio_hw *hw, uint8_t portid)\r\n{\r\nstruct csio_lnode *ln = hw->rln;\r\nstruct list_head *tmp;\r\nlist_for_each(tmp, &hw->sln_head) {\r\nln = (struct csio_lnode *) tmp;\r\nif (ln->portid == portid)\r\nreturn ln;\r\n}\r\nreturn NULL;\r\n}\r\nstatic struct csio_lnode *\r\ncsio_ln_lookup_by_vnpi(struct csio_hw *hw, uint32_t vnp_id)\r\n{\r\nstruct list_head *tmp1, *tmp2;\r\nstruct csio_lnode *sln = NULL, *cln = NULL;\r\nif (list_empty(&hw->sln_head)) {\r\nCSIO_INC_STATS(hw, n_lnlkup_miss);\r\nreturn NULL;\r\n}\r\nlist_for_each(tmp1, &hw->sln_head) {\r\nsln = (struct csio_lnode *) tmp1;\r\nif (sln->vnp_flowid == vnp_id)\r\nreturn sln;\r\nif (list_empty(&sln->cln_head))\r\ncontinue;\r\nlist_for_each(tmp2, &sln->cln_head) {\r\ncln = (struct csio_lnode *) tmp2;\r\nif (cln->vnp_flowid == vnp_id)\r\nreturn cln;\r\n}\r\n}\r\nCSIO_INC_STATS(hw, n_lnlkup_miss);\r\nreturn NULL;\r\n}\r\nstruct csio_lnode *\r\ncsio_lnode_lookup_by_wwpn(struct csio_hw *hw, uint8_t *wwpn)\r\n{\r\nstruct list_head *tmp1, *tmp2;\r\nstruct csio_lnode *sln = NULL, *cln = NULL;\r\nif (list_empty(&hw->sln_head)) {\r\nCSIO_INC_STATS(hw, n_lnlkup_miss);\r\nreturn NULL;\r\n}\r\nlist_for_each(tmp1, &hw->sln_head) {\r\nsln = (struct csio_lnode *) tmp1;\r\nif (!memcmp(csio_ln_wwpn(sln), wwpn, 8))\r\nreturn sln;\r\nif (list_empty(&sln->cln_head))\r\ncontinue;\r\nlist_for_each(tmp2, &sln->cln_head) {\r\ncln = (struct csio_lnode *) tmp2;\r\nif (!memcmp(csio_ln_wwpn(cln), wwpn, 8))\r\nreturn cln;\r\n}\r\n}\r\nreturn NULL;\r\n}\r\nstatic void\r\ncsio_fill_ct_iu(void *buf, uint8_t type, uint8_t sub_type, uint16_t op)\r\n{\r\nstruct fc_ct_hdr *cmd = (struct fc_ct_hdr *)buf;\r\ncmd->ct_rev = FC_CT_REV;\r\ncmd->ct_fs_type = type;\r\ncmd->ct_fs_subtype = sub_type;\r\ncmd->ct_cmd = htons(op);\r\n}\r\nstatic int\r\ncsio_hostname(uint8_t *buf, size_t buf_len)\r\n{\r\nif (snprintf(buf, buf_len, "%s", init_utsname()->nodename) > 0)\r\nreturn 0;\r\nreturn -1;\r\n}\r\nstatic int\r\ncsio_osname(uint8_t *buf, size_t buf_len)\r\n{\r\nif (snprintf(buf, buf_len, "%s %s %s",\r\ninit_utsname()->sysname,\r\ninit_utsname()->release,\r\ninit_utsname()->version) > 0)\r\nreturn 0;\r\nreturn -1;\r\n}\r\nstatic inline void\r\ncsio_append_attrib(uint8_t **ptr, uint16_t type, uint8_t *val, uint16_t len)\r\n{\r\nstruct fc_fdmi_attr_entry *ae = (struct fc_fdmi_attr_entry *)*ptr;\r\nae->type = htons(type);\r\nlen += 4;\r\nlen = (len + 3) & ~3;\r\nae->len = htons(len);\r\nmemcpy(ae->value, val, len);\r\n*ptr += len;\r\n}\r\nstatic void\r\ncsio_ln_fdmi_done(struct csio_hw *hw, struct csio_ioreq *fdmi_req)\r\n{\r\nvoid *cmd;\r\nstruct csio_lnode *ln = fdmi_req->lnode;\r\nif (fdmi_req->wr_status != FW_SUCCESS) {\r\ncsio_ln_dbg(ln, "WR error:%x in processing fdmi rpa cmd\n",\r\nfdmi_req->wr_status);\r\nCSIO_INC_STATS(ln, n_fdmi_err);\r\n}\r\ncmd = fdmi_req->dma_buf.vaddr;\r\nif (ntohs(csio_ct_rsp(cmd)) != FC_FS_ACC) {\r\ncsio_ln_dbg(ln, "fdmi rpa cmd rejected reason %x expl %x\n",\r\ncsio_ct_reason(cmd), csio_ct_expl(cmd));\r\n}\r\n}\r\nstatic void\r\ncsio_ln_fdmi_rhba_cbfn(struct csio_hw *hw, struct csio_ioreq *fdmi_req)\r\n{\r\nvoid *cmd;\r\nuint8_t *pld;\r\nuint32_t len = 0;\r\n__be32 val;\r\n__be16 mfs;\r\nuint32_t numattrs = 0;\r\nstruct csio_lnode *ln = fdmi_req->lnode;\r\nstruct fs_fdmi_attrs *attrib_blk;\r\nstruct fc_fdmi_port_name *port_name;\r\nuint8_t buf[64];\r\nuint8_t *fc4_type;\r\nif (fdmi_req->wr_status != FW_SUCCESS) {\r\ncsio_ln_dbg(ln, "WR error:%x in processing fdmi rhba cmd\n",\r\nfdmi_req->wr_status);\r\nCSIO_INC_STATS(ln, n_fdmi_err);\r\n}\r\ncmd = fdmi_req->dma_buf.vaddr;\r\nif (ntohs(csio_ct_rsp(cmd)) != FC_FS_ACC) {\r\ncsio_ln_dbg(ln, "fdmi rhba cmd rejected reason %x expl %x\n",\r\ncsio_ct_reason(cmd), csio_ct_expl(cmd));\r\n}\r\nif (!csio_is_rnode_ready(fdmi_req->rnode)) {\r\nCSIO_INC_STATS(ln, n_fdmi_err);\r\nreturn;\r\n}\r\nmemset(cmd, 0, FC_CT_HDR_LEN);\r\ncsio_fill_ct_iu(cmd, FC_FST_MGMT, FC_FDMI_SUBTYPE, FC_FDMI_RPA);\r\npld = (uint8_t *)csio_ct_get_pld(cmd);\r\nport_name = (struct fc_fdmi_port_name *)pld;\r\nmemcpy(&port_name->portname, csio_ln_wwpn(ln), 8);\r\npld += sizeof(*port_name);\r\nattrib_blk = (struct fs_fdmi_attrs *)pld;\r\nattrib_blk->numattrs = 0;\r\nlen += sizeof(attrib_blk->numattrs);\r\npld += sizeof(attrib_blk->numattrs);\r\nfc4_type = &buf[0];\r\nmemset(fc4_type, 0, FC_FDMI_PORT_ATTR_FC4TYPES_LEN);\r\nfc4_type[2] = 1;\r\nfc4_type[7] = 1;\r\ncsio_append_attrib(&pld, FC_FDMI_PORT_ATTR_FC4TYPES,\r\nfc4_type, FC_FDMI_PORT_ATTR_FC4TYPES_LEN);\r\nnumattrs++;\r\nval = htonl(FC_PORTSPEED_1GBIT | FC_PORTSPEED_10GBIT);\r\ncsio_append_attrib(&pld, FC_FDMI_PORT_ATTR_SUPPORTEDSPEED,\r\n(uint8_t *)&val,\r\nFC_FDMI_PORT_ATTR_SUPPORTEDSPEED_LEN);\r\nnumattrs++;\r\nif (hw->pport[ln->portid].link_speed == FW_PORT_CAP_SPEED_1G)\r\nval = htonl(FC_PORTSPEED_1GBIT);\r\nelse if (hw->pport[ln->portid].link_speed == FW_PORT_CAP_SPEED_10G)\r\nval = htonl(FC_PORTSPEED_10GBIT);\r\nelse\r\nval = htonl(CSIO_HBA_PORTSPEED_UNKNOWN);\r\ncsio_append_attrib(&pld, FC_FDMI_PORT_ATTR_CURRENTPORTSPEED,\r\n(uint8_t *)&val,\r\nFC_FDMI_PORT_ATTR_CURRENTPORTSPEED_LEN);\r\nnumattrs++;\r\nmfs = ln->ln_sparm.csp.sp_bb_data;\r\ncsio_append_attrib(&pld, FC_FDMI_PORT_ATTR_MAXFRAMESIZE,\r\n(uint8_t *)&mfs, FC_FDMI_PORT_ATTR_MAXFRAMESIZE_LEN);\r\nnumattrs++;\r\nstrcpy(buf, "csiostor");\r\ncsio_append_attrib(&pld, FC_FDMI_PORT_ATTR_OSDEVICENAME, buf,\r\n(uint16_t)strlen(buf));\r\nnumattrs++;\r\nif (!csio_hostname(buf, sizeof(buf))) {\r\ncsio_append_attrib(&pld, FC_FDMI_PORT_ATTR_HOSTNAME,\r\nbuf, (uint16_t)strlen(buf));\r\nnumattrs++;\r\n}\r\nattrib_blk->numattrs = htonl(numattrs);\r\nlen = (uint32_t)(pld - (uint8_t *)cmd);\r\nspin_lock_irq(&hw->lock);\r\nif (csio_ln_mgmt_submit_req(fdmi_req, csio_ln_fdmi_done,\r\nFCOE_CT, &fdmi_req->dma_buf, len)) {\r\nCSIO_INC_STATS(ln, n_fdmi_err);\r\ncsio_ln_dbg(ln, "Failed to issue fdmi rpa req\n");\r\n}\r\nspin_unlock_irq(&hw->lock);\r\n}\r\nstatic void\r\ncsio_ln_fdmi_dprt_cbfn(struct csio_hw *hw, struct csio_ioreq *fdmi_req)\r\n{\r\nvoid *cmd;\r\nuint8_t *pld;\r\nuint32_t len = 0;\r\nuint32_t numattrs = 0;\r\n__be32 maxpayload = htonl(65536);\r\nstruct fc_fdmi_hba_identifier *hbaid;\r\nstruct csio_lnode *ln = fdmi_req->lnode;\r\nstruct fc_fdmi_rpl *reg_pl;\r\nstruct fs_fdmi_attrs *attrib_blk;\r\nuint8_t buf[64];\r\nif (fdmi_req->wr_status != FW_SUCCESS) {\r\ncsio_ln_dbg(ln, "WR error:%x in processing fdmi dprt cmd\n",\r\nfdmi_req->wr_status);\r\nCSIO_INC_STATS(ln, n_fdmi_err);\r\n}\r\nif (!csio_is_rnode_ready(fdmi_req->rnode)) {\r\nCSIO_INC_STATS(ln, n_fdmi_err);\r\nreturn;\r\n}\r\ncmd = fdmi_req->dma_buf.vaddr;\r\nif (ntohs(csio_ct_rsp(cmd)) != FC_FS_ACC) {\r\ncsio_ln_dbg(ln, "fdmi dprt cmd rejected reason %x expl %x\n",\r\ncsio_ct_reason(cmd), csio_ct_expl(cmd));\r\n}\r\nmemset(cmd, 0, FC_CT_HDR_LEN);\r\ncsio_fill_ct_iu(cmd, FC_FST_MGMT, FC_FDMI_SUBTYPE, FC_FDMI_RHBA);\r\nlen = FC_CT_HDR_LEN;\r\npld = (uint8_t *)csio_ct_get_pld(cmd);\r\nhbaid = (struct fc_fdmi_hba_identifier *)pld;\r\nmemcpy(&hbaid->id, csio_ln_wwpn(ln), 8);\r\npld += sizeof(*hbaid);\r\nreg_pl = (struct fc_fdmi_rpl *)pld;\r\nreg_pl->numport = htonl(1);\r\nmemcpy(&reg_pl->port[0].portname, csio_ln_wwpn(ln), 8);\r\npld += sizeof(*reg_pl);\r\nattrib_blk = (struct fs_fdmi_attrs *)pld;\r\nattrib_blk->numattrs = 0;\r\nlen += sizeof(attrib_blk->numattrs);\r\npld += sizeof(attrib_blk->numattrs);\r\ncsio_append_attrib(&pld, FC_FDMI_HBA_ATTR_NODENAME, csio_ln_wwnn(ln),\r\nFC_FDMI_HBA_ATTR_NODENAME_LEN);\r\nnumattrs++;\r\nmemset(buf, 0, sizeof(buf));\r\nstrcpy(buf, "Chelsio Communications");\r\ncsio_append_attrib(&pld, FC_FDMI_HBA_ATTR_MANUFACTURER, buf,\r\n(uint16_t)strlen(buf));\r\nnumattrs++;\r\ncsio_append_attrib(&pld, FC_FDMI_HBA_ATTR_SERIALNUMBER,\r\nhw->vpd.sn, (uint16_t)sizeof(hw->vpd.sn));\r\nnumattrs++;\r\ncsio_append_attrib(&pld, FC_FDMI_HBA_ATTR_MODEL, hw->vpd.id,\r\n(uint16_t)sizeof(hw->vpd.id));\r\nnumattrs++;\r\ncsio_append_attrib(&pld, FC_FDMI_HBA_ATTR_MODELDESCRIPTION,\r\nhw->model_desc, (uint16_t)strlen(hw->model_desc));\r\nnumattrs++;\r\ncsio_append_attrib(&pld, FC_FDMI_HBA_ATTR_HARDWAREVERSION,\r\nhw->hw_ver, (uint16_t)sizeof(hw->hw_ver));\r\nnumattrs++;\r\ncsio_append_attrib(&pld, FC_FDMI_HBA_ATTR_FIRMWAREVERSION,\r\nhw->fwrev_str, (uint16_t)strlen(hw->fwrev_str));\r\nnumattrs++;\r\nif (!csio_osname(buf, sizeof(buf))) {\r\ncsio_append_attrib(&pld, FC_FDMI_HBA_ATTR_OSNAMEVERSION,\r\nbuf, (uint16_t)strlen(buf));\r\nnumattrs++;\r\n}\r\ncsio_append_attrib(&pld, FC_FDMI_HBA_ATTR_MAXCTPAYLOAD,\r\n(uint8_t *)&maxpayload,\r\nFC_FDMI_HBA_ATTR_MAXCTPAYLOAD_LEN);\r\nlen = (uint32_t)(pld - (uint8_t *)cmd);\r\nnumattrs++;\r\nattrib_blk->numattrs = htonl(numattrs);\r\nspin_lock_irq(&hw->lock);\r\nif (csio_ln_mgmt_submit_req(fdmi_req, csio_ln_fdmi_rhba_cbfn,\r\nFCOE_CT, &fdmi_req->dma_buf, len)) {\r\nCSIO_INC_STATS(ln, n_fdmi_err);\r\ncsio_ln_dbg(ln, "Failed to issue fdmi rhba req\n");\r\n}\r\nspin_unlock_irq(&hw->lock);\r\n}\r\nstatic void\r\ncsio_ln_fdmi_dhba_cbfn(struct csio_hw *hw, struct csio_ioreq *fdmi_req)\r\n{\r\nstruct csio_lnode *ln = fdmi_req->lnode;\r\nvoid *cmd;\r\nstruct fc_fdmi_port_name *port_name;\r\nuint32_t len;\r\nif (fdmi_req->wr_status != FW_SUCCESS) {\r\ncsio_ln_dbg(ln, "WR error:%x in processing fdmi dhba cmd\n",\r\nfdmi_req->wr_status);\r\nCSIO_INC_STATS(ln, n_fdmi_err);\r\n}\r\nif (!csio_is_rnode_ready(fdmi_req->rnode)) {\r\nCSIO_INC_STATS(ln, n_fdmi_err);\r\nreturn;\r\n}\r\ncmd = fdmi_req->dma_buf.vaddr;\r\nif (ntohs(csio_ct_rsp(cmd)) != FC_FS_ACC) {\r\ncsio_ln_dbg(ln, "fdmi dhba cmd rejected reason %x expl %x\n",\r\ncsio_ct_reason(cmd), csio_ct_expl(cmd));\r\n}\r\nmemset(cmd, 0, FC_CT_HDR_LEN);\r\ncsio_fill_ct_iu(cmd, FC_FST_MGMT, FC_FDMI_SUBTYPE, FC_FDMI_DPRT);\r\nlen = FC_CT_HDR_LEN;\r\nport_name = (struct fc_fdmi_port_name *)csio_ct_get_pld(cmd);\r\nmemcpy(&port_name->portname, csio_ln_wwpn(ln), 8);\r\nlen += sizeof(*port_name);\r\nspin_lock_irq(&hw->lock);\r\nif (csio_ln_mgmt_submit_req(fdmi_req, csio_ln_fdmi_dprt_cbfn,\r\nFCOE_CT, &fdmi_req->dma_buf, len)) {\r\nCSIO_INC_STATS(ln, n_fdmi_err);\r\ncsio_ln_dbg(ln, "Failed to issue fdmi dprt req\n");\r\n}\r\nspin_unlock_irq(&hw->lock);\r\n}\r\nint\r\ncsio_ln_fdmi_start(struct csio_lnode *ln, void *context)\r\n{\r\nstruct csio_ioreq *fdmi_req;\r\nstruct csio_rnode *fdmi_rn = (struct csio_rnode *)context;\r\nvoid *cmd;\r\nstruct fc_fdmi_hba_identifier *hbaid;\r\nuint32_t len;\r\nif (!(ln->flags & CSIO_LNF_FDMI_ENABLE))\r\nreturn -EPROTONOSUPPORT;\r\nif (!csio_is_rnode_ready(fdmi_rn))\r\nCSIO_INC_STATS(ln, n_fdmi_err);\r\nfdmi_req = ln->mgmt_req;\r\nfdmi_req->lnode = ln;\r\nfdmi_req->rnode = fdmi_rn;\r\ncmd = fdmi_req->dma_buf.vaddr;\r\nmemset(cmd, 0, FC_CT_HDR_LEN);\r\ncsio_fill_ct_iu(cmd, FC_FST_MGMT, FC_FDMI_SUBTYPE, FC_FDMI_DHBA);\r\nlen = FC_CT_HDR_LEN;\r\nhbaid = (struct fc_fdmi_hba_identifier *)csio_ct_get_pld(cmd);\r\nmemcpy(&hbaid->id, csio_ln_wwpn(ln), 8);\r\nlen += sizeof(*hbaid);\r\nif (csio_ln_mgmt_submit_req(fdmi_req, csio_ln_fdmi_dhba_cbfn,\r\nFCOE_CT, &fdmi_req->dma_buf, len)) {\r\nCSIO_INC_STATS(ln, n_fdmi_err);\r\ncsio_ln_dbg(ln, "Failed to issue fdmi dhba req\n");\r\n}\r\nreturn 0;\r\n}\r\nstatic void\r\ncsio_ln_vnp_read_cbfn(struct csio_hw *hw, struct csio_mb *mbp)\r\n{\r\nstruct csio_lnode *ln = ((struct csio_lnode *)mbp->priv);\r\nstruct fw_fcoe_vnp_cmd *rsp = (struct fw_fcoe_vnp_cmd *)(mbp->mb);\r\nstruct fc_els_csp *csp;\r\nstruct fc_els_cssp *clsp;\r\nenum fw_retval retval;\r\n__be32 nport_id;\r\nretval = FW_CMD_RETVAL_G(ntohl(rsp->alloc_to_len16));\r\nif (retval != FW_SUCCESS) {\r\ncsio_err(hw, "FCOE VNP read cmd returned error:0x%x\n", retval);\r\nmempool_free(mbp, hw->mb_mempool);\r\nreturn;\r\n}\r\nspin_lock_irq(&hw->lock);\r\nmemcpy(ln->mac, rsp->vnport_mac, sizeof(ln->mac));\r\nmemcpy(&nport_id, &rsp->vnport_mac[3], sizeof(uint8_t)*3);\r\nln->nport_id = ntohl(nport_id);\r\nln->nport_id = ln->nport_id >> 8;\r\nmemcpy(csio_ln_wwnn(ln), rsp->vnport_wwnn, 8);\r\nmemcpy(csio_ln_wwpn(ln), rsp->vnport_wwpn, 8);\r\ncsp = (struct fc_els_csp *)rsp->cmn_srv_parms;\r\nln->ln_sparm.csp.sp_hi_ver = csp->sp_hi_ver;\r\nln->ln_sparm.csp.sp_lo_ver = csp->sp_lo_ver;\r\nln->ln_sparm.csp.sp_bb_cred = csp->sp_bb_cred;\r\nln->ln_sparm.csp.sp_features = csp->sp_features;\r\nln->ln_sparm.csp.sp_bb_data = csp->sp_bb_data;\r\nln->ln_sparm.csp.sp_r_a_tov = csp->sp_r_a_tov;\r\nln->ln_sparm.csp.sp_e_d_tov = csp->sp_e_d_tov;\r\nclsp = (struct fc_els_cssp *)rsp->clsp_word_0_1;\r\nln->ln_sparm.clsp[2].cp_class = clsp->cp_class;\r\nln->ln_sparm.clsp[2].cp_init = clsp->cp_init;\r\nln->ln_sparm.clsp[2].cp_recip = clsp->cp_recip;\r\nln->ln_sparm.clsp[2].cp_rdfs = clsp->cp_rdfs;\r\nspin_unlock_irq(&hw->lock);\r\nmempool_free(mbp, hw->mb_mempool);\r\ncsio_lnode_async_event(ln, CSIO_LN_FC_ATTRIB_UPDATE);\r\n}\r\nstatic int\r\ncsio_ln_vnp_read(struct csio_lnode *ln,\r\nvoid (*cbfn) (struct csio_hw *, struct csio_mb *))\r\n{\r\nstruct csio_hw *hw = ln->hwp;\r\nstruct csio_mb *mbp;\r\nmbp = mempool_alloc(hw->mb_mempool, GFP_ATOMIC);\r\nif (!mbp) {\r\nCSIO_INC_STATS(hw, n_err_nomem);\r\nreturn -ENOMEM;\r\n}\r\ncsio_fcoe_vnp_read_init_mb(ln, mbp,\r\nCSIO_MB_DEFAULT_TMO,\r\nln->fcf_flowid,\r\nln->vnp_flowid,\r\ncbfn);\r\nif (csio_mb_issue(hw, mbp)) {\r\ncsio_err(hw, "Failed to issue mbox FCoE VNP command\n");\r\nmempool_free(mbp, hw->mb_mempool);\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int\r\ncsio_fcoe_enable_link(struct csio_lnode *ln, bool enable)\r\n{\r\nstruct csio_hw *hw = ln->hwp;\r\nstruct csio_mb *mbp;\r\nenum fw_retval retval;\r\nuint8_t portid;\r\nuint8_t sub_op;\r\nstruct fw_fcoe_link_cmd *lcmd;\r\nint i;\r\nmbp = mempool_alloc(hw->mb_mempool, GFP_ATOMIC);\r\nif (!mbp) {\r\nCSIO_INC_STATS(hw, n_err_nomem);\r\nreturn -ENOMEM;\r\n}\r\nportid = ln->portid;\r\nsub_op = enable ? FCOE_LINK_UP : FCOE_LINK_DOWN;\r\ncsio_dbg(hw, "bringing FCOE LINK %s on Port:%d\n",\r\nsub_op ? "UP" : "DOWN", portid);\r\ncsio_write_fcoe_link_cond_init_mb(ln, mbp, CSIO_MB_DEFAULT_TMO,\r\nportid, sub_op, 0, 0, 0, NULL);\r\nif (csio_mb_issue(hw, mbp)) {\r\ncsio_err(hw, "failed to issue FCOE LINK cmd on port[%d]\n",\r\nportid);\r\nmempool_free(mbp, hw->mb_mempool);\r\nreturn -EINVAL;\r\n}\r\nretval = csio_mb_fw_retval(mbp);\r\nif (retval != FW_SUCCESS) {\r\ncsio_err(hw,\r\n"FCOE LINK %s cmd on port[%d] failed with "\r\n"ret:x%x\n", sub_op ? "UP" : "DOWN", portid, retval);\r\nmempool_free(mbp, hw->mb_mempool);\r\nreturn -EINVAL;\r\n}\r\nif (!enable)\r\ngoto out;\r\nlcmd = (struct fw_fcoe_link_cmd *)mbp->mb;\r\nmemcpy(csio_ln_wwnn(ln), lcmd->vnport_wwnn, 8);\r\nmemcpy(csio_ln_wwpn(ln), lcmd->vnport_wwpn, 8);\r\nfor (i = 0; i < CSIO_MAX_PPORTS; i++)\r\nif (hw->pport[i].portid == portid)\r\nmemcpy(hw->pport[i].mac, lcmd->phy_mac, 6);\r\nout:\r\nmempool_free(mbp, hw->mb_mempool);\r\nreturn 0;\r\n}\r\nstatic void\r\ncsio_ln_read_fcf_cbfn(struct csio_hw *hw, struct csio_mb *mbp)\r\n{\r\nstruct csio_lnode *ln = (struct csio_lnode *)mbp->priv;\r\nstruct csio_fcf_info *fcf_info;\r\nstruct fw_fcoe_fcf_cmd *rsp =\r\n(struct fw_fcoe_fcf_cmd *)(mbp->mb);\r\nenum fw_retval retval;\r\nretval = FW_CMD_RETVAL_G(ntohl(rsp->retval_len16));\r\nif (retval != FW_SUCCESS) {\r\ncsio_ln_err(ln, "FCOE FCF cmd failed with ret x%x\n",\r\nretval);\r\nmempool_free(mbp, hw->mb_mempool);\r\nreturn;\r\n}\r\nspin_lock_irq(&hw->lock);\r\nfcf_info = ln->fcfinfo;\r\nfcf_info->priority = FW_FCOE_FCF_CMD_PRIORITY_GET(\r\nntohs(rsp->priority_pkd));\r\nfcf_info->vf_id = ntohs(rsp->vf_id);\r\nfcf_info->vlan_id = rsp->vlan_id;\r\nfcf_info->max_fcoe_size = ntohs(rsp->max_fcoe_size);\r\nfcf_info->fka_adv = be32_to_cpu(rsp->fka_adv);\r\nfcf_info->fcfi = FW_FCOE_FCF_CMD_FCFI_GET(ntohl(rsp->op_to_fcfi));\r\nfcf_info->fpma = FW_FCOE_FCF_CMD_FPMA_GET(rsp->fpma_to_portid);\r\nfcf_info->spma = FW_FCOE_FCF_CMD_SPMA_GET(rsp->fpma_to_portid);\r\nfcf_info->login = FW_FCOE_FCF_CMD_LOGIN_GET(rsp->fpma_to_portid);\r\nfcf_info->portid = FW_FCOE_FCF_CMD_PORTID_GET(rsp->fpma_to_portid);\r\nmemcpy(fcf_info->fc_map, rsp->fc_map, sizeof(fcf_info->fc_map));\r\nmemcpy(fcf_info->mac, rsp->mac, sizeof(fcf_info->mac));\r\nmemcpy(fcf_info->name_id, rsp->name_id, sizeof(fcf_info->name_id));\r\nmemcpy(fcf_info->fabric, rsp->fabric, sizeof(fcf_info->fabric));\r\nmemcpy(fcf_info->spma_mac, rsp->spma_mac, sizeof(fcf_info->spma_mac));\r\nspin_unlock_irq(&hw->lock);\r\nmempool_free(mbp, hw->mb_mempool);\r\n}\r\nstatic int\r\ncsio_ln_read_fcf_entry(struct csio_lnode *ln,\r\nvoid (*cbfn) (struct csio_hw *, struct csio_mb *))\r\n{\r\nstruct csio_hw *hw = ln->hwp;\r\nstruct csio_mb *mbp;\r\nmbp = mempool_alloc(hw->mb_mempool, GFP_ATOMIC);\r\nif (!mbp) {\r\nCSIO_INC_STATS(hw, n_err_nomem);\r\nreturn -ENOMEM;\r\n}\r\ncsio_fcoe_read_fcf_init_mb(ln, mbp, CSIO_MB_DEFAULT_TMO,\r\nln->portid, ln->fcf_flowid, cbfn);\r\nif (csio_mb_issue(hw, mbp)) {\r\ncsio_err(hw, "failed to issue FCOE FCF cmd\n");\r\nmempool_free(mbp, hw->mb_mempool);\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic void\r\ncsio_handle_link_up(struct csio_hw *hw, uint8_t portid, uint32_t fcfi,\r\nuint32_t vnpi)\r\n{\r\nstruct csio_lnode *ln = NULL;\r\nln = csio_ln_lookup_by_vnpi(hw, vnpi);\r\nif (!ln) {\r\nln = csio_ln_lookup_by_portid(hw, portid);\r\nif (!ln) {\r\ncsio_err(hw, "failed to lookup fcoe lnode on port:%d\n",\r\nportid);\r\nCSIO_DB_ASSERT(0);\r\nreturn;\r\n}\r\nif (ln->vnp_flowid != CSIO_INVALID_IDX) {\r\nspin_unlock_irq(&hw->lock);\r\ncsio_lnode_alloc(hw);\r\nspin_lock_irq(&hw->lock);\r\nif (!ln) {\r\ncsio_err(hw,\r\n"failed to allocate fcoe lnode"\r\n"for port:%d vnpi:x%x\n",\r\nportid, vnpi);\r\nCSIO_DB_ASSERT(0);\r\nreturn;\r\n}\r\nln->portid = portid;\r\n}\r\nln->vnp_flowid = vnpi;\r\nln->dev_num &= ~0xFFFF;\r\nln->dev_num |= vnpi;\r\n}\r\nln->fcf_flowid = fcfi;\r\ncsio_info(hw, "Port:%d - FCOE LINK UP\n", portid);\r\nCSIO_INC_STATS(ln, n_link_up);\r\ncsio_post_event(&ln->sm, CSIO_LNE_LINKUP);\r\n}\r\nstatic void\r\ncsio_post_event_rns(struct csio_lnode *ln, enum csio_rn_ev evt)\r\n{\r\nstruct csio_rnode *rnhead = (struct csio_rnode *) &ln->rnhead;\r\nstruct list_head *tmp, *next;\r\nstruct csio_rnode *rn;\r\nlist_for_each_safe(tmp, next, &rnhead->sm.sm_list) {\r\nrn = (struct csio_rnode *) tmp;\r\ncsio_post_event(&rn->sm, evt);\r\n}\r\n}\r\nstatic void\r\ncsio_cleanup_rns(struct csio_lnode *ln)\r\n{\r\nstruct csio_rnode *rnhead = (struct csio_rnode *) &ln->rnhead;\r\nstruct list_head *tmp, *next_rn;\r\nstruct csio_rnode *rn;\r\nlist_for_each_safe(tmp, next_rn, &rnhead->sm.sm_list) {\r\nrn = (struct csio_rnode *) tmp;\r\ncsio_put_rnode(ln, rn);\r\n}\r\n}\r\nstatic void\r\ncsio_post_event_lns(struct csio_lnode *ln, enum csio_ln_ev evt)\r\n{\r\nstruct list_head *tmp;\r\nstruct csio_lnode *cln, *sln;\r\nif (csio_is_npiv_ln(ln)) {\r\ncsio_post_event(&ln->sm, evt);\r\nreturn;\r\n}\r\nsln = ln;\r\nlist_for_each(tmp, &sln->cln_head) {\r\ncln = (struct csio_lnode *) tmp;\r\ncsio_post_event(&cln->sm, evt);\r\n}\r\ncsio_post_event(&ln->sm, evt);\r\n}\r\nstatic void\r\ncsio_ln_down(struct csio_lnode *ln)\r\n{\r\ncsio_post_event_lns(ln, CSIO_LNE_LINK_DOWN);\r\n}\r\nstatic void\r\ncsio_handle_link_down(struct csio_hw *hw, uint8_t portid, uint32_t fcfi,\r\nuint32_t vnpi)\r\n{\r\nstruct csio_fcf_info *fp;\r\nstruct csio_lnode *ln;\r\nln = csio_ln_lookup_by_vnpi(hw, vnpi);\r\nif (ln) {\r\nfp = ln->fcfinfo;\r\nCSIO_INC_STATS(ln, n_link_down);\r\nif (!csio_is_lnode_ready(ln)) {\r\ncsio_ln_warn(ln,\r\n"warn: FCOE link is already in offline "\r\n"Ignoring Fcoe linkdown event on portid %d\n",\r\nportid);\r\nCSIO_INC_STATS(ln, n_evt_drop);\r\nreturn;\r\n}\r\nif (fp->portid != portid) {\r\ncsio_ln_warn(ln,\r\n"warn: FCOE linkdown recv with "\r\n"invalid port %d\n", portid);\r\nCSIO_INC_STATS(ln, n_evt_drop);\r\nreturn;\r\n}\r\nif (ln->fcf_flowid != fcfi) {\r\ncsio_ln_warn(ln,\r\n"warn: FCOE linkdown recv with "\r\n"invalid fcfi x%x\n", fcfi);\r\nCSIO_INC_STATS(ln, n_evt_drop);\r\nreturn;\r\n}\r\ncsio_info(hw, "Port:%d - FCOE LINK DOWN\n", portid);\r\ncsio_ln_down(ln);\r\nreturn;\r\n} else {\r\ncsio_warn(hw,\r\n"warn: FCOE linkdown recv with invalid vnpi x%x\n",\r\nvnpi);\r\nCSIO_INC_STATS(hw, n_evt_drop);\r\n}\r\n}\r\nint\r\ncsio_is_lnode_ready(struct csio_lnode *ln)\r\n{\r\nreturn (csio_get_state(ln) == ((csio_sm_state_t)csio_lns_ready));\r\n}\r\nstatic void\r\ncsio_lns_uninit(struct csio_lnode *ln, enum csio_ln_ev evt)\r\n{\r\nstruct csio_hw *hw = csio_lnode_to_hw(ln);\r\nstruct csio_lnode *rln = hw->rln;\r\nint rv;\r\nCSIO_INC_STATS(ln, n_evt_sm[evt]);\r\nswitch (evt) {\r\ncase CSIO_LNE_LINKUP:\r\ncsio_set_state(&ln->sm, csio_lns_online);\r\nif (csio_is_phys_ln(ln)) {\r\nrv = csio_ln_read_fcf_entry(ln,\r\ncsio_ln_read_fcf_cbfn);\r\nif (rv != 0) {\r\nCSIO_INC_STATS(ln, n_err);\r\nbreak;\r\n}\r\nlist_add_tail(&ln->fcfinfo->list, &rln->fcf_lsthead);\r\n}\r\nrv = csio_ln_vnp_read(ln, csio_ln_vnp_read_cbfn);\r\nif (rv != 0) {\r\nCSIO_INC_STATS(ln, n_err);\r\n}\r\nbreak;\r\ncase CSIO_LNE_DOWN_LINK:\r\nbreak;\r\ndefault:\r\ncsio_ln_dbg(ln,\r\n"unexp ln event %d recv from did:x%x in "\r\n"ln state[uninit].\n", evt, ln->nport_id);\r\nCSIO_INC_STATS(ln, n_evt_unexp);\r\nbreak;\r\n}\r\n}\r\nstatic void\r\ncsio_lns_online(struct csio_lnode *ln, enum csio_ln_ev evt)\r\n{\r\nstruct csio_hw *hw = csio_lnode_to_hw(ln);\r\nCSIO_INC_STATS(ln, n_evt_sm[evt]);\r\nswitch (evt) {\r\ncase CSIO_LNE_LINKUP:\r\ncsio_ln_warn(ln,\r\n"warn: FCOE link is up already "\r\n"Ignoring linkup on port:%d\n", ln->portid);\r\nCSIO_INC_STATS(ln, n_evt_drop);\r\nbreak;\r\ncase CSIO_LNE_FAB_INIT_DONE:\r\ncsio_set_state(&ln->sm, csio_lns_ready);\r\nspin_unlock_irq(&hw->lock);\r\ncsio_lnode_async_event(ln, CSIO_LN_FC_LINKUP);\r\nspin_lock_irq(&hw->lock);\r\nbreak;\r\ncase CSIO_LNE_LINK_DOWN:\r\ncase CSIO_LNE_DOWN_LINK:\r\ncsio_set_state(&ln->sm, csio_lns_uninit);\r\nif (csio_is_phys_ln(ln)) {\r\nlist_del_init(&ln->fcfinfo->list);\r\n}\r\nbreak;\r\ndefault:\r\ncsio_ln_dbg(ln,\r\n"unexp ln event %d recv from did:x%x in "\r\n"ln state[uninit].\n", evt, ln->nport_id);\r\nCSIO_INC_STATS(ln, n_evt_unexp);\r\nbreak;\r\n}\r\n}\r\nstatic void\r\ncsio_lns_ready(struct csio_lnode *ln, enum csio_ln_ev evt)\r\n{\r\nstruct csio_hw *hw = csio_lnode_to_hw(ln);\r\nCSIO_INC_STATS(ln, n_evt_sm[evt]);\r\nswitch (evt) {\r\ncase CSIO_LNE_FAB_INIT_DONE:\r\ncsio_ln_dbg(ln,\r\n"ignoring event %d recv from did x%x"\r\n"in ln state[ready].\n", evt, ln->nport_id);\r\nCSIO_INC_STATS(ln, n_evt_drop);\r\nbreak;\r\ncase CSIO_LNE_LINK_DOWN:\r\ncsio_set_state(&ln->sm, csio_lns_offline);\r\ncsio_post_event_rns(ln, CSIO_RNFE_DOWN);\r\nspin_unlock_irq(&hw->lock);\r\ncsio_lnode_async_event(ln, CSIO_LN_FC_LINKDOWN);\r\nspin_lock_irq(&hw->lock);\r\nif (csio_is_phys_ln(ln)) {\r\nlist_del_init(&ln->fcfinfo->list);\r\n}\r\nbreak;\r\ncase CSIO_LNE_DOWN_LINK:\r\ncsio_set_state(&ln->sm, csio_lns_offline);\r\ncsio_post_event_rns(ln, CSIO_RNFE_DOWN);\r\nspin_unlock_irq(&hw->lock);\r\ncsio_lnode_async_event(ln, CSIO_LN_FC_LINKDOWN);\r\nspin_lock_irq(&hw->lock);\r\nif (csio_is_phys_ln(ln)) {\r\nlist_del_init(&ln->fcfinfo->list);\r\n}\r\nbreak;\r\ncase CSIO_LNE_CLOSE:\r\ncsio_set_state(&ln->sm, csio_lns_uninit);\r\ncsio_post_event_rns(ln, CSIO_RNFE_CLOSE);\r\nbreak;\r\ncase CSIO_LNE_LOGO:\r\ncsio_set_state(&ln->sm, csio_lns_offline);\r\ncsio_post_event_rns(ln, CSIO_RNFE_DOWN);\r\nbreak;\r\ndefault:\r\ncsio_ln_dbg(ln,\r\n"unexp ln event %d recv from did:x%x in "\r\n"ln state[uninit].\n", evt, ln->nport_id);\r\nCSIO_INC_STATS(ln, n_evt_unexp);\r\nCSIO_DB_ASSERT(0);\r\nbreak;\r\n}\r\n}\r\nstatic void\r\ncsio_lns_offline(struct csio_lnode *ln, enum csio_ln_ev evt)\r\n{\r\nstruct csio_hw *hw = csio_lnode_to_hw(ln);\r\nstruct csio_lnode *rln = hw->rln;\r\nint rv;\r\nCSIO_INC_STATS(ln, n_evt_sm[evt]);\r\nswitch (evt) {\r\ncase CSIO_LNE_LINKUP:\r\ncsio_set_state(&ln->sm, csio_lns_online);\r\nif (csio_is_phys_ln(ln)) {\r\nrv = csio_ln_read_fcf_entry(ln,\r\ncsio_ln_read_fcf_cbfn);\r\nif (rv != 0) {\r\nCSIO_INC_STATS(ln, n_err);\r\nbreak;\r\n}\r\nlist_add_tail(&ln->fcfinfo->list, &rln->fcf_lsthead);\r\n}\r\nrv = csio_ln_vnp_read(ln, csio_ln_vnp_read_cbfn);\r\nif (rv != 0) {\r\nCSIO_INC_STATS(ln, n_err);\r\n}\r\nbreak;\r\ncase CSIO_LNE_LINK_DOWN:\r\ncase CSIO_LNE_DOWN_LINK:\r\ncase CSIO_LNE_LOGO:\r\ncsio_ln_dbg(ln,\r\n"ignoring event %d recv from did x%x"\r\n"in ln state[offline].\n", evt, ln->nport_id);\r\nCSIO_INC_STATS(ln, n_evt_drop);\r\nbreak;\r\ncase CSIO_LNE_CLOSE:\r\ncsio_set_state(&ln->sm, csio_lns_uninit);\r\ncsio_post_event_rns(ln, CSIO_RNFE_CLOSE);\r\nbreak;\r\ndefault:\r\ncsio_ln_dbg(ln,\r\n"unexp ln event %d recv from did:x%x in "\r\n"ln state[offline]\n", evt, ln->nport_id);\r\nCSIO_INC_STATS(ln, n_evt_unexp);\r\nCSIO_DB_ASSERT(0);\r\nbreak;\r\n}\r\n}\r\nstatic void\r\ncsio_free_fcfinfo(struct kref *kref)\r\n{\r\nstruct csio_fcf_info *fcfinfo = container_of(kref,\r\nstruct csio_fcf_info, kref);\r\nkfree(fcfinfo);\r\n}\r\nvoid\r\ncsio_lnode_state_to_str(struct csio_lnode *ln, int8_t *str)\r\n{\r\nif (csio_get_state(ln) == ((csio_sm_state_t)csio_lns_uninit)) {\r\nstrcpy(str, "UNINIT");\r\nreturn;\r\n}\r\nif (csio_get_state(ln) == ((csio_sm_state_t)csio_lns_ready)) {\r\nstrcpy(str, "READY");\r\nreturn;\r\n}\r\nif (csio_get_state(ln) == ((csio_sm_state_t)csio_lns_offline)) {\r\nstrcpy(str, "OFFLINE");\r\nreturn;\r\n}\r\nstrcpy(str, "UNKNOWN");\r\n}\r\nint\r\ncsio_get_phy_port_stats(struct csio_hw *hw, uint8_t portid,\r\nstruct fw_fcoe_port_stats *port_stats)\r\n{\r\nstruct csio_mb *mbp;\r\nstruct fw_fcoe_port_cmd_params portparams;\r\nenum fw_retval retval;\r\nint idx;\r\nmbp = mempool_alloc(hw->mb_mempool, GFP_ATOMIC);\r\nif (!mbp) {\r\ncsio_err(hw, "FCoE FCF PARAMS command out of memory!\n");\r\nreturn -EINVAL;\r\n}\r\nportparams.portid = portid;\r\nfor (idx = 1; idx <= 3; idx++) {\r\nportparams.idx = (idx-1)*6 + 1;\r\nportparams.nstats = 6;\r\nif (idx == 3)\r\nportparams.nstats = 4;\r\ncsio_fcoe_read_portparams_init_mb(hw, mbp, CSIO_MB_DEFAULT_TMO,\r\n&portparams, NULL);\r\nif (csio_mb_issue(hw, mbp)) {\r\ncsio_err(hw, "Issue of FCoE port params failed!\n");\r\nmempool_free(mbp, hw->mb_mempool);\r\nreturn -EINVAL;\r\n}\r\ncsio_mb_process_portparams_rsp(hw, mbp, &retval,\r\n&portparams, port_stats);\r\n}\r\nmempool_free(mbp, hw->mb_mempool);\r\nreturn 0;\r\n}\r\nstatic void\r\ncsio_ln_mgmt_wr_handler(struct csio_hw *hw, void *wr, uint32_t len)\r\n{\r\nstruct csio_mgmtm *mgmtm = csio_hw_to_mgmtm(hw);\r\nstruct csio_ioreq *io_req = NULL;\r\nstruct fw_fcoe_els_ct_wr *wr_cmd;\r\nwr_cmd = (struct fw_fcoe_els_ct_wr *) wr;\r\nif (len < sizeof(struct fw_fcoe_els_ct_wr)) {\r\ncsio_err(mgmtm->hw,\r\n"Invalid ELS CT WR length recvd, len:%x\n", len);\r\nmgmtm->stats.n_err++;\r\nreturn;\r\n}\r\nio_req = (struct csio_ioreq *) ((uintptr_t) wr_cmd->cookie);\r\nio_req->wr_status = csio_wr_status(wr_cmd);\r\nspin_lock_irq(&hw->lock);\r\nif (csio_mgmt_req_lookup(mgmtm, io_req) != 0) {\r\ncsio_err(mgmtm->hw,\r\n"Error- Invalid IO handle recv in WR. handle: %p\n",\r\nio_req);\r\nmgmtm->stats.n_err++;\r\nspin_unlock_irq(&hw->lock);\r\nreturn;\r\n}\r\nmgmtm = csio_hw_to_mgmtm(hw);\r\nlist_del_init(&io_req->sm.sm_list);\r\nmgmtm->stats.n_active--;\r\nspin_unlock_irq(&hw->lock);\r\nif (io_req->io_cbfn)\r\nio_req->io_cbfn(hw, io_req);\r\n}\r\nvoid\r\ncsio_fcoe_fwevt_handler(struct csio_hw *hw, __u8 cpl_op, __be64 *cmd)\r\n{\r\nstruct csio_lnode *ln;\r\nstruct csio_rnode *rn;\r\nuint8_t portid, opcode = *(uint8_t *)cmd;\r\nstruct fw_fcoe_link_cmd *lcmd;\r\nstruct fw_wr_hdr *wr;\r\nstruct fw_rdev_wr *rdev_wr;\r\nenum fw_fcoe_link_status lstatus;\r\nuint32_t fcfi, rdev_flowid, vnpi;\r\nenum csio_ln_ev evt;\r\nif (cpl_op == CPL_FW6_MSG && opcode == FW_FCOE_LINK_CMD) {\r\nlcmd = (struct fw_fcoe_link_cmd *)cmd;\r\nlstatus = lcmd->lstatus;\r\nportid = FW_FCOE_LINK_CMD_PORTID_GET(\r\nntohl(lcmd->op_to_portid));\r\nfcfi = FW_FCOE_LINK_CMD_FCFI_GET(ntohl(lcmd->sub_opcode_fcfi));\r\nvnpi = FW_FCOE_LINK_CMD_VNPI_GET(ntohl(lcmd->vnpi_pkd));\r\nif (lstatus == FCOE_LINKUP) {\r\nspin_lock_irq(&hw->lock);\r\ncsio_handle_link_up(hw, portid, fcfi, vnpi);\r\nspin_unlock_irq(&hw->lock);\r\n} else if (lstatus == FCOE_LINKDOWN) {\r\nspin_lock_irq(&hw->lock);\r\ncsio_handle_link_down(hw, portid, fcfi, vnpi);\r\nspin_unlock_irq(&hw->lock);\r\n} else {\r\ncsio_warn(hw, "Unexpected FCOE LINK status:0x%x\n",\r\nlcmd->lstatus);\r\nCSIO_INC_STATS(hw, n_cpl_unexp);\r\n}\r\n} else if (cpl_op == CPL_FW6_PLD) {\r\nwr = (struct fw_wr_hdr *) (cmd + 4);\r\nif (FW_WR_OP_G(be32_to_cpu(wr->hi))\r\n== FW_RDEV_WR) {\r\nrdev_wr = (struct fw_rdev_wr *) (cmd + 4);\r\nrdev_flowid = FW_RDEV_WR_FLOWID_GET(\r\nntohl(rdev_wr->alloc_to_len16));\r\nvnpi = FW_RDEV_WR_ASSOC_FLOWID_GET(\r\nntohl(rdev_wr->flags_to_assoc_flowid));\r\ncsio_dbg(hw,\r\n"FW_RDEV_WR: flowid:x%x ev_cause:x%x "\r\n"vnpi:0x%x\n", rdev_flowid,\r\nrdev_wr->event_cause, vnpi);\r\nif (rdev_wr->protocol != PROT_FCOE) {\r\ncsio_err(hw,\r\n"FW_RDEV_WR: invalid proto:x%x "\r\n"received with flowid:x%x\n",\r\nrdev_wr->protocol,\r\nrdev_flowid);\r\nCSIO_INC_STATS(hw, n_evt_drop);\r\nreturn;\r\n}\r\nspin_lock_irq(&hw->lock);\r\nln = csio_ln_lookup_by_vnpi(hw, vnpi);\r\nif (!ln) {\r\ncsio_err(hw,\r\n"FW_DEV_WR: invalid vnpi:x%x received "\r\n"with flowid:x%x\n", vnpi, rdev_flowid);\r\nCSIO_INC_STATS(hw, n_evt_drop);\r\ngoto out_pld;\r\n}\r\nrn = csio_confirm_rnode(ln, rdev_flowid,\r\n&rdev_wr->u.fcoe_rdev);\r\nif (!rn) {\r\ncsio_ln_dbg(ln,\r\n"Failed to confirm rnode "\r\n"for flowid:x%x\n", rdev_flowid);\r\nCSIO_INC_STATS(hw, n_evt_drop);\r\ngoto out_pld;\r\n}\r\nln->prev_evt = ln->cur_evt;\r\nln->cur_evt = rdev_wr->event_cause;\r\nCSIO_INC_STATS(ln, n_evt_fw[rdev_wr->event_cause]);\r\nevt = CSIO_FWE_TO_LNE(rdev_wr->event_cause);\r\nif (evt) {\r\ncsio_ln_dbg(ln,\r\n"Posting event to lnode event:%d "\r\n"cause:%d flowid:x%x\n", evt,\r\nrdev_wr->event_cause, rdev_flowid);\r\ncsio_post_event(&ln->sm, evt);\r\n}\r\ncsio_rnode_fwevt_handler(rn, rdev_wr->event_cause);\r\nout_pld:\r\nspin_unlock_irq(&hw->lock);\r\nreturn;\r\n} else {\r\ncsio_warn(hw, "unexpected WR op(0x%x) recv\n",\r\nFW_WR_OP_G(be32_to_cpu((wr->hi))));\r\nCSIO_INC_STATS(hw, n_cpl_unexp);\r\n}\r\n} else if (cpl_op == CPL_FW6_MSG) {\r\nwr = (struct fw_wr_hdr *) (cmd);\r\nif (FW_WR_OP_G(be32_to_cpu(wr->hi)) == FW_FCOE_ELS_CT_WR) {\r\ncsio_ln_mgmt_wr_handler(hw, wr,\r\nsizeof(struct fw_fcoe_els_ct_wr));\r\n} else {\r\ncsio_warn(hw, "unexpected WR op(0x%x) recv\n",\r\nFW_WR_OP_G(be32_to_cpu((wr->hi))));\r\nCSIO_INC_STATS(hw, n_cpl_unexp);\r\n}\r\n} else {\r\ncsio_warn(hw, "unexpected CPL op(0x%x) recv\n", opcode);\r\nCSIO_INC_STATS(hw, n_cpl_unexp);\r\n}\r\n}\r\nint\r\ncsio_lnode_start(struct csio_lnode *ln)\r\n{\r\nint rv = 0;\r\nif (csio_is_phys_ln(ln) && !(ln->flags & CSIO_LNF_LINK_ENABLE)) {\r\nrv = csio_fcoe_enable_link(ln, 1);\r\nln->flags |= CSIO_LNF_LINK_ENABLE;\r\n}\r\nreturn rv;\r\n}\r\nvoid\r\ncsio_lnode_stop(struct csio_lnode *ln)\r\n{\r\ncsio_post_event_lns(ln, CSIO_LNE_DOWN_LINK);\r\nif (csio_is_phys_ln(ln) && (ln->flags & CSIO_LNF_LINK_ENABLE)) {\r\ncsio_fcoe_enable_link(ln, 0);\r\nln->flags &= ~CSIO_LNF_LINK_ENABLE;\r\n}\r\ncsio_ln_dbg(ln, "stopping ln :%p\n", ln);\r\n}\r\nvoid\r\ncsio_lnode_close(struct csio_lnode *ln)\r\n{\r\ncsio_post_event_lns(ln, CSIO_LNE_CLOSE);\r\nif (csio_is_phys_ln(ln))\r\nln->vnp_flowid = CSIO_INVALID_IDX;\r\ncsio_ln_dbg(ln, "closed ln :%p\n", ln);\r\n}\r\nstatic int\r\ncsio_ln_prep_ecwr(struct csio_ioreq *io_req, uint32_t wr_len,\r\nuint32_t immd_len, uint8_t sub_op, uint32_t sid,\r\nuint32_t did, uint32_t flow_id, uint8_t *fw_wr)\r\n{\r\nstruct fw_fcoe_els_ct_wr *wr;\r\n__be32 port_id;\r\nwr = (struct fw_fcoe_els_ct_wr *)fw_wr;\r\nwr->op_immdlen = cpu_to_be32(FW_WR_OP_V(FW_FCOE_ELS_CT_WR) |\r\nFW_FCOE_ELS_CT_WR_IMMDLEN(immd_len));\r\nwr_len = DIV_ROUND_UP(wr_len, 16);\r\nwr->flowid_len16 = cpu_to_be32(FW_WR_FLOWID_V(flow_id) |\r\nFW_WR_LEN16_V(wr_len));\r\nwr->els_ct_type = sub_op;\r\nwr->ctl_pri = 0;\r\nwr->cp_en_class = 0;\r\nwr->cookie = io_req->fw_handle;\r\nwr->iqid = cpu_to_be16(csio_q_physiqid(\r\nio_req->lnode->hwp, io_req->iq_idx));\r\nwr->fl_to_sp = FW_FCOE_ELS_CT_WR_SP(1);\r\nwr->tmo_val = (uint8_t) io_req->tmo;\r\nport_id = htonl(sid);\r\nmemcpy(wr->l_id, PORT_ID_PTR(port_id), 3);\r\nport_id = htonl(did);\r\nmemcpy(wr->r_id, PORT_ID_PTR(port_id), 3);\r\nwr->rsp_dmalen = cpu_to_be32(io_req->dma_buf.len);\r\nwr->rsp_dmaaddr = cpu_to_be64(io_req->dma_buf.paddr);\r\nreturn 0;\r\n}\r\nstatic int\r\ncsio_ln_mgmt_submit_wr(struct csio_mgmtm *mgmtm, struct csio_ioreq *io_req,\r\nuint8_t sub_op, struct csio_dma_buf *pld,\r\nuint32_t pld_len)\r\n{\r\nstruct csio_wr_pair wrp;\r\nstruct csio_lnode *ln = io_req->lnode;\r\nstruct csio_rnode *rn = io_req->rnode;\r\nstruct csio_hw *hw = mgmtm->hw;\r\nuint8_t fw_wr[64];\r\nstruct ulptx_sgl dsgl;\r\nuint32_t wr_size = 0;\r\nuint8_t im_len = 0;\r\nuint32_t wr_off = 0;\r\nint ret = 0;\r\nwr_size = sizeof(struct fw_fcoe_els_ct_wr);\r\nif (pld_len < 256) {\r\nwr_size += ALIGN(pld_len, 8);\r\nim_len = (uint8_t)pld_len;\r\n} else\r\nwr_size += sizeof(struct ulptx_sgl);\r\nwr_size = ALIGN(wr_size, 16);\r\nret = csio_wr_get(hw, mgmtm->eq_idx, wr_size, &wrp);\r\nif (ret != 0) {\r\ncsio_err(hw, "Failed to get WR for ec_req %p ret:%d\n",\r\nio_req, ret);\r\nreturn ret;\r\n}\r\ncsio_ln_prep_ecwr(io_req, wr_size, im_len, sub_op,\r\nln->nport_id, rn->nport_id,\r\ncsio_rn_flowid(rn),\r\n&fw_wr[0]);\r\ncsio_wr_copy_to_wrp(&fw_wr[0], &wrp, wr_off,\r\nsizeof(struct fw_fcoe_els_ct_wr));\r\nwr_off += sizeof(struct fw_fcoe_els_ct_wr);\r\nif (im_len)\r\ncsio_wr_copy_to_wrp(pld->vaddr, &wrp, wr_off, im_len);\r\nelse {\r\ndsgl.cmd_nsge = htonl(ULPTX_CMD_V(ULP_TX_SC_DSGL) |\r\nULPTX_MORE_F | ULPTX_NSGE_V(1));\r\ndsgl.len0 = cpu_to_be32(pld_len);\r\ndsgl.addr0 = cpu_to_be64(pld->paddr);\r\ncsio_wr_copy_to_wrp(&dsgl, &wrp, ALIGN(wr_off, 8),\r\nsizeof(struct ulptx_sgl));\r\n}\r\ncsio_wr_issue(mgmtm->hw, mgmtm->eq_idx, false);\r\nreturn ret;\r\n}\r\nstatic int\r\ncsio_ln_mgmt_submit_req(struct csio_ioreq *io_req,\r\nvoid (*io_cbfn) (struct csio_hw *, struct csio_ioreq *),\r\nenum fcoe_cmn_type req_type, struct csio_dma_buf *pld,\r\nuint32_t pld_len)\r\n{\r\nstruct csio_hw *hw = csio_lnode_to_hw(io_req->lnode);\r\nstruct csio_mgmtm *mgmtm = csio_hw_to_mgmtm(hw);\r\nint rv;\r\nio_req->io_cbfn = io_cbfn;\r\nio_req->fw_handle = (uintptr_t) (io_req);\r\nio_req->eq_idx = mgmtm->eq_idx;\r\nio_req->iq_idx = mgmtm->iq_idx;\r\nrv = csio_ln_mgmt_submit_wr(mgmtm, io_req, req_type, pld, pld_len);\r\nif (rv == 0) {\r\nlist_add_tail(&io_req->sm.sm_list, &mgmtm->active_q);\r\nmgmtm->stats.n_active++;\r\n}\r\nreturn rv;\r\n}\r\nstatic int\r\ncsio_ln_fdmi_init(struct csio_lnode *ln)\r\n{\r\nstruct csio_hw *hw = csio_lnode_to_hw(ln);\r\nstruct csio_dma_buf *dma_buf;\r\nln->mgmt_req = kzalloc(sizeof(struct csio_ioreq), GFP_KERNEL);\r\nif (!ln->mgmt_req) {\r\ncsio_ln_err(ln, "Failed to alloc ioreq for FDMI\n");\r\nCSIO_INC_STATS(hw, n_err_nomem);\r\nreturn -ENOMEM;\r\n}\r\ndma_buf = &ln->mgmt_req->dma_buf;\r\ndma_buf->len = 2048;\r\ndma_buf->vaddr = pci_alloc_consistent(hw->pdev, dma_buf->len,\r\n&dma_buf->paddr);\r\nif (!dma_buf->vaddr) {\r\ncsio_err(hw, "Failed to alloc DMA buffer for FDMI!\n");\r\nkfree(ln->mgmt_req);\r\nln->mgmt_req = NULL;\r\nreturn -ENOMEM;\r\n}\r\nln->flags |= CSIO_LNF_FDMI_ENABLE;\r\nreturn 0;\r\n}\r\nstatic int\r\ncsio_ln_fdmi_exit(struct csio_lnode *ln)\r\n{\r\nstruct csio_dma_buf *dma_buf;\r\nstruct csio_hw *hw = csio_lnode_to_hw(ln);\r\nif (!ln->mgmt_req)\r\nreturn 0;\r\ndma_buf = &ln->mgmt_req->dma_buf;\r\nif (dma_buf->vaddr)\r\npci_free_consistent(hw->pdev, dma_buf->len, dma_buf->vaddr,\r\ndma_buf->paddr);\r\nkfree(ln->mgmt_req);\r\nreturn 0;\r\n}\r\nint\r\ncsio_scan_done(struct csio_lnode *ln, unsigned long ticks,\r\nunsigned long time, unsigned long max_scan_ticks,\r\nunsigned long delta_scan_ticks)\r\n{\r\nint rv = 0;\r\nif (time >= max_scan_ticks)\r\nreturn 1;\r\nif (!ln->tgt_scan_tick)\r\nln->tgt_scan_tick = ticks;\r\nif (((ticks - ln->tgt_scan_tick) >= delta_scan_ticks)) {\r\nif (!ln->last_scan_ntgts)\r\nln->last_scan_ntgts = ln->n_scsi_tgts;\r\nelse {\r\nif (ln->last_scan_ntgts == ln->n_scsi_tgts)\r\nreturn 1;\r\nln->last_scan_ntgts = ln->n_scsi_tgts;\r\n}\r\nln->tgt_scan_tick = ticks;\r\n}\r\nreturn rv;\r\n}\r\nvoid\r\ncsio_notify_lnodes(struct csio_hw *hw, enum csio_ln_notify note)\r\n{\r\nstruct list_head *tmp;\r\nstruct csio_lnode *ln;\r\ncsio_dbg(hw, "Notifying all nodes of event %d\n", note);\r\nlist_for_each(tmp, &hw->sln_head) {\r\nln = (struct csio_lnode *) tmp;\r\nswitch (note) {\r\ncase CSIO_LN_NOTIFY_HWREADY:\r\ncsio_lnode_start(ln);\r\nbreak;\r\ncase CSIO_LN_NOTIFY_HWRESET:\r\ncase CSIO_LN_NOTIFY_HWREMOVE:\r\ncsio_lnode_close(ln);\r\nbreak;\r\ncase CSIO_LN_NOTIFY_HWSTOP:\r\ncsio_lnode_stop(ln);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\n}\r\nvoid\r\ncsio_disable_lnodes(struct csio_hw *hw, uint8_t portid, bool disable)\r\n{\r\nstruct list_head *tmp;\r\nstruct csio_lnode *ln;\r\ncsio_dbg(hw, "Notifying event to all nodes of port:%d\n", portid);\r\nlist_for_each(tmp, &hw->sln_head) {\r\nln = (struct csio_lnode *) tmp;\r\nif (ln->portid != portid)\r\ncontinue;\r\nif (disable)\r\ncsio_lnode_stop(ln);\r\nelse\r\ncsio_lnode_start(ln);\r\n}\r\n}\r\nstatic int\r\ncsio_ln_init(struct csio_lnode *ln)\r\n{\r\nint rv = -EINVAL;\r\nstruct csio_lnode *rln, *pln;\r\nstruct csio_hw *hw = csio_lnode_to_hw(ln);\r\ncsio_init_state(&ln->sm, csio_lns_uninit);\r\nln->vnp_flowid = CSIO_INVALID_IDX;\r\nln->fcf_flowid = CSIO_INVALID_IDX;\r\nif (csio_is_root_ln(ln)) {\r\nln->fcfinfo = kzalloc(sizeof(struct csio_fcf_info), GFP_KERNEL);\r\nif (!ln->fcfinfo) {\r\ncsio_ln_err(ln, "Failed to alloc FCF record\n");\r\nCSIO_INC_STATS(hw, n_err_nomem);\r\ngoto err;\r\n}\r\nINIT_LIST_HEAD(&ln->fcf_lsthead);\r\nkref_init(&ln->fcfinfo->kref);\r\nif (csio_fdmi_enable && csio_ln_fdmi_init(ln))\r\ngoto err;\r\n} else {\r\nrln = csio_root_lnode(ln);\r\nif (csio_is_npiv_ln(ln)) {\r\npln = csio_parent_lnode(ln);\r\nkref_get(&pln->fcfinfo->kref);\r\nln->fcfinfo = pln->fcfinfo;\r\n} else {\r\nln->fcfinfo = kzalloc(sizeof(struct csio_fcf_info),\r\nGFP_KERNEL);\r\nif (!ln->fcfinfo) {\r\ncsio_ln_err(ln, "Failed to alloc FCF info\n");\r\nCSIO_INC_STATS(hw, n_err_nomem);\r\ngoto err;\r\n}\r\nkref_init(&ln->fcfinfo->kref);\r\nif (csio_fdmi_enable && csio_ln_fdmi_init(ln))\r\ngoto err;\r\n}\r\n}\r\nreturn 0;\r\nerr:\r\nreturn rv;\r\n}\r\nstatic void\r\ncsio_ln_exit(struct csio_lnode *ln)\r\n{\r\nstruct csio_lnode *pln;\r\ncsio_cleanup_rns(ln);\r\nif (csio_is_npiv_ln(ln)) {\r\npln = csio_parent_lnode(ln);\r\nkref_put(&pln->fcfinfo->kref, csio_free_fcfinfo);\r\n} else {\r\nkref_put(&ln->fcfinfo->kref, csio_free_fcfinfo);\r\nif (csio_fdmi_enable)\r\ncsio_ln_fdmi_exit(ln);\r\n}\r\nln->fcfinfo = NULL;\r\n}\r\nint\r\ncsio_lnode_init(struct csio_lnode *ln, struct csio_hw *hw,\r\nstruct csio_lnode *pln)\r\n{\r\nint rv = -EINVAL;\r\ncsio_lnode_to_hw(ln) = hw;\r\nif (pln)\r\nln->pln = pln;\r\nelse\r\nln->pln = NULL;\r\nln->n_scsi_tgts = 0;\r\nln->last_scan_ntgts = 0;\r\nln->tgt_scan_tick = 0;\r\nINIT_LIST_HEAD(&ln->rnhead);\r\nINIT_LIST_HEAD(&ln->cln_head);\r\nln->params.log_level = hw->params.log_level;\r\nif (csio_ln_init(ln))\r\ngoto err;\r\nspin_lock_irq(&hw->lock);\r\nlist_add_tail(&ln->sm.sm_list, pln ? &pln->cln_head : &hw->sln_head);\r\nif (pln)\r\npln->num_vports++;\r\nspin_unlock_irq(&hw->lock);\r\nhw->num_lns++;\r\nreturn 0;\r\nerr:\r\ncsio_lnode_to_hw(ln) = NULL;\r\nreturn rv;\r\n}\r\nvoid\r\ncsio_lnode_exit(struct csio_lnode *ln)\r\n{\r\nstruct csio_hw *hw = csio_lnode_to_hw(ln);\r\ncsio_ln_exit(ln);\r\nspin_lock_irq(&hw->lock);\r\nlist_del_init(&ln->sm.sm_list);\r\nif (ln->pln)\r\nln->pln->num_vports--;\r\nif (list_empty(&hw->sln_head))\r\nhw->rln = NULL;\r\nelse\r\nhw->rln = (struct csio_lnode *)csio_list_next(&hw->sln_head);\r\nspin_unlock_irq(&hw->lock);\r\ncsio_lnode_to_hw(ln) = NULL;\r\nhw->num_lns--;\r\n}
