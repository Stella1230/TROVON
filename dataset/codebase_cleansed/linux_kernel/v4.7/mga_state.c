static void mga_emit_clip_rect(drm_mga_private_t *dev_priv,\r\nstruct drm_clip_rect *box)\r\n{\r\ndrm_mga_sarea_t *sarea_priv = dev_priv->sarea_priv;\r\ndrm_mga_context_regs_t *ctx = &sarea_priv->context_state;\r\nunsigned int pitch = dev_priv->front_pitch;\r\nDMA_LOCALS;\r\nBEGIN_DMA(2);\r\nif (dev_priv->chipset >= MGA_CARD_TYPE_G400) {\r\nDMA_BLOCK(MGA_DWGCTL, ctx->dwgctl,\r\nMGA_LEN + MGA_EXEC, 0x80000000,\r\nMGA_DWGCTL, ctx->dwgctl,\r\nMGA_LEN + MGA_EXEC, 0x80000000);\r\n}\r\nDMA_BLOCK(MGA_DMAPAD, 0x00000000,\r\nMGA_CXBNDRY, ((box->x2 - 1) << 16) | box->x1,\r\nMGA_YTOP, box->y1 * pitch, MGA_YBOT, (box->y2 - 1) * pitch);\r\nADVANCE_DMA();\r\n}\r\nstatic __inline__ void mga_g200_emit_context(drm_mga_private_t *dev_priv)\r\n{\r\ndrm_mga_sarea_t *sarea_priv = dev_priv->sarea_priv;\r\ndrm_mga_context_regs_t *ctx = &sarea_priv->context_state;\r\nDMA_LOCALS;\r\nBEGIN_DMA(3);\r\nDMA_BLOCK(MGA_DSTORG, ctx->dstorg,\r\nMGA_MACCESS, ctx->maccess,\r\nMGA_PLNWT, ctx->plnwt, MGA_DWGCTL, ctx->dwgctl);\r\nDMA_BLOCK(MGA_ALPHACTRL, ctx->alphactrl,\r\nMGA_FOGCOL, ctx->fogcolor,\r\nMGA_WFLAG, ctx->wflag, MGA_ZORG, dev_priv->depth_offset);\r\nDMA_BLOCK(MGA_FCOL, ctx->fcol,\r\nMGA_DMAPAD, 0x00000000,\r\nMGA_DMAPAD, 0x00000000, MGA_DMAPAD, 0x00000000);\r\nADVANCE_DMA();\r\n}\r\nstatic __inline__ void mga_g400_emit_context(drm_mga_private_t *dev_priv)\r\n{\r\ndrm_mga_sarea_t *sarea_priv = dev_priv->sarea_priv;\r\ndrm_mga_context_regs_t *ctx = &sarea_priv->context_state;\r\nDMA_LOCALS;\r\nBEGIN_DMA(4);\r\nDMA_BLOCK(MGA_DSTORG, ctx->dstorg,\r\nMGA_MACCESS, ctx->maccess,\r\nMGA_PLNWT, ctx->plnwt, MGA_DWGCTL, ctx->dwgctl);\r\nDMA_BLOCK(MGA_ALPHACTRL, ctx->alphactrl,\r\nMGA_FOGCOL, ctx->fogcolor,\r\nMGA_WFLAG, ctx->wflag, MGA_ZORG, dev_priv->depth_offset);\r\nDMA_BLOCK(MGA_WFLAG1, ctx->wflag,\r\nMGA_TDUALSTAGE0, ctx->tdualstage0,\r\nMGA_TDUALSTAGE1, ctx->tdualstage1, MGA_FCOL, ctx->fcol);\r\nDMA_BLOCK(MGA_STENCIL, ctx->stencil,\r\nMGA_STENCILCTL, ctx->stencilctl,\r\nMGA_DMAPAD, 0x00000000, MGA_DMAPAD, 0x00000000);\r\nADVANCE_DMA();\r\n}\r\nstatic __inline__ void mga_g200_emit_tex0(drm_mga_private_t *dev_priv)\r\n{\r\ndrm_mga_sarea_t *sarea_priv = dev_priv->sarea_priv;\r\ndrm_mga_texture_regs_t *tex = &sarea_priv->tex_state[0];\r\nDMA_LOCALS;\r\nBEGIN_DMA(4);\r\nDMA_BLOCK(MGA_TEXCTL2, tex->texctl2,\r\nMGA_TEXCTL, tex->texctl,\r\nMGA_TEXFILTER, tex->texfilter,\r\nMGA_TEXBORDERCOL, tex->texbordercol);\r\nDMA_BLOCK(MGA_TEXORG, tex->texorg,\r\nMGA_TEXORG1, tex->texorg1,\r\nMGA_TEXORG2, tex->texorg2, MGA_TEXORG3, tex->texorg3);\r\nDMA_BLOCK(MGA_TEXORG4, tex->texorg4,\r\nMGA_TEXWIDTH, tex->texwidth,\r\nMGA_TEXHEIGHT, tex->texheight, MGA_WR24, tex->texwidth);\r\nDMA_BLOCK(MGA_WR34, tex->texheight,\r\nMGA_TEXTRANS, 0x0000ffff,\r\nMGA_TEXTRANSHIGH, 0x0000ffff, MGA_DMAPAD, 0x00000000);\r\nADVANCE_DMA();\r\n}\r\nstatic __inline__ void mga_g400_emit_tex0(drm_mga_private_t *dev_priv)\r\n{\r\ndrm_mga_sarea_t *sarea_priv = dev_priv->sarea_priv;\r\ndrm_mga_texture_regs_t *tex = &sarea_priv->tex_state[0];\r\nDMA_LOCALS;\r\nBEGIN_DMA(6);\r\nDMA_BLOCK(MGA_TEXCTL2, tex->texctl2 | MGA_G400_TC2_MAGIC,\r\nMGA_TEXCTL, tex->texctl,\r\nMGA_TEXFILTER, tex->texfilter,\r\nMGA_TEXBORDERCOL, tex->texbordercol);\r\nDMA_BLOCK(MGA_TEXORG, tex->texorg,\r\nMGA_TEXORG1, tex->texorg1,\r\nMGA_TEXORG2, tex->texorg2, MGA_TEXORG3, tex->texorg3);\r\nDMA_BLOCK(MGA_TEXORG4, tex->texorg4,\r\nMGA_TEXWIDTH, tex->texwidth,\r\nMGA_TEXHEIGHT, tex->texheight, MGA_WR49, 0x00000000);\r\nDMA_BLOCK(MGA_WR57, 0x00000000,\r\nMGA_WR53, 0x00000000,\r\nMGA_WR61, 0x00000000, MGA_WR52, MGA_G400_WR_MAGIC);\r\nDMA_BLOCK(MGA_WR60, MGA_G400_WR_MAGIC,\r\nMGA_WR54, tex->texwidth | MGA_G400_WR_MAGIC,\r\nMGA_WR62, tex->texheight | MGA_G400_WR_MAGIC,\r\nMGA_DMAPAD, 0x00000000);\r\nDMA_BLOCK(MGA_DMAPAD, 0x00000000,\r\nMGA_DMAPAD, 0x00000000,\r\nMGA_TEXTRANS, 0x0000ffff, MGA_TEXTRANSHIGH, 0x0000ffff);\r\nADVANCE_DMA();\r\n}\r\nstatic __inline__ void mga_g400_emit_tex1(drm_mga_private_t *dev_priv)\r\n{\r\ndrm_mga_sarea_t *sarea_priv = dev_priv->sarea_priv;\r\ndrm_mga_texture_regs_t *tex = &sarea_priv->tex_state[1];\r\nDMA_LOCALS;\r\nBEGIN_DMA(5);\r\nDMA_BLOCK(MGA_TEXCTL2, (tex->texctl2 |\r\nMGA_MAP1_ENABLE |\r\nMGA_G400_TC2_MAGIC),\r\nMGA_TEXCTL, tex->texctl,\r\nMGA_TEXFILTER, tex->texfilter,\r\nMGA_TEXBORDERCOL, tex->texbordercol);\r\nDMA_BLOCK(MGA_TEXORG, tex->texorg,\r\nMGA_TEXORG1, tex->texorg1,\r\nMGA_TEXORG2, tex->texorg2, MGA_TEXORG3, tex->texorg3);\r\nDMA_BLOCK(MGA_TEXORG4, tex->texorg4,\r\nMGA_TEXWIDTH, tex->texwidth,\r\nMGA_TEXHEIGHT, tex->texheight, MGA_WR49, 0x00000000);\r\nDMA_BLOCK(MGA_WR57, 0x00000000,\r\nMGA_WR53, 0x00000000,\r\nMGA_WR61, 0x00000000,\r\nMGA_WR52, tex->texwidth | MGA_G400_WR_MAGIC);\r\nDMA_BLOCK(MGA_WR60, tex->texheight | MGA_G400_WR_MAGIC,\r\nMGA_TEXTRANS, 0x0000ffff,\r\nMGA_TEXTRANSHIGH, 0x0000ffff,\r\nMGA_TEXCTL2, tex->texctl2 | MGA_G400_TC2_MAGIC);\r\nADVANCE_DMA();\r\n}\r\nstatic __inline__ void mga_g200_emit_pipe(drm_mga_private_t *dev_priv)\r\n{\r\ndrm_mga_sarea_t *sarea_priv = dev_priv->sarea_priv;\r\nunsigned int pipe = sarea_priv->warp_pipe;\r\nDMA_LOCALS;\r\nBEGIN_DMA(3);\r\nDMA_BLOCK(MGA_WIADDR, MGA_WMODE_SUSPEND,\r\nMGA_WVRTXSZ, 0x00000007,\r\nMGA_WFLAG, 0x00000000, MGA_WR24, 0x00000000);\r\nDMA_BLOCK(MGA_WR25, 0x00000100,\r\nMGA_WR34, 0x00000000,\r\nMGA_WR42, 0x0000ffff, MGA_WR60, 0x0000ffff);\r\nDMA_BLOCK(MGA_DMAPAD, 0xffffffff,\r\nMGA_DMAPAD, 0xffffffff,\r\nMGA_DMAPAD, 0xffffffff,\r\nMGA_WIADDR, (dev_priv->warp_pipe_phys[pipe] |\r\nMGA_WMODE_START | dev_priv->wagp_enable));\r\nADVANCE_DMA();\r\n}\r\nstatic __inline__ void mga_g400_emit_pipe(drm_mga_private_t *dev_priv)\r\n{\r\ndrm_mga_sarea_t *sarea_priv = dev_priv->sarea_priv;\r\nunsigned int pipe = sarea_priv->warp_pipe;\r\nDMA_LOCALS;\r\nBEGIN_DMA(10);\r\nDMA_BLOCK(MGA_WIADDR2, MGA_WMODE_SUSPEND,\r\nMGA_DMAPAD, 0x00000000,\r\nMGA_DMAPAD, 0x00000000, MGA_DMAPAD, 0x00000000);\r\nif (pipe & MGA_T2) {\r\nDMA_BLOCK(MGA_WVRTXSZ, 0x00001e09,\r\nMGA_DMAPAD, 0x00000000,\r\nMGA_DMAPAD, 0x00000000, MGA_DMAPAD, 0x00000000);\r\nDMA_BLOCK(MGA_WACCEPTSEQ, 0x00000000,\r\nMGA_WACCEPTSEQ, 0x00000000,\r\nMGA_WACCEPTSEQ, 0x00000000,\r\nMGA_WACCEPTSEQ, 0x1e000000);\r\n} else {\r\nif (dev_priv->warp_pipe & MGA_T2) {\r\nDMA_BLOCK(MGA_YDST, 0x00000000,\r\nMGA_FXLEFT, 0x00000000,\r\nMGA_FXRIGHT, 0x00000001,\r\nMGA_DWGCTL, MGA_DWGCTL_FLUSH);\r\nDMA_BLOCK(MGA_LEN + MGA_EXEC, 0x00000001,\r\nMGA_DWGSYNC, 0x00007000,\r\nMGA_TEXCTL2, MGA_G400_TC2_MAGIC,\r\nMGA_LEN + MGA_EXEC, 0x00000000);\r\nDMA_BLOCK(MGA_TEXCTL2, (MGA_DUALTEX |\r\nMGA_G400_TC2_MAGIC),\r\nMGA_LEN + MGA_EXEC, 0x00000000,\r\nMGA_TEXCTL2, MGA_G400_TC2_MAGIC,\r\nMGA_DMAPAD, 0x00000000);\r\n}\r\nDMA_BLOCK(MGA_WVRTXSZ, 0x00001807,\r\nMGA_DMAPAD, 0x00000000,\r\nMGA_DMAPAD, 0x00000000, MGA_DMAPAD, 0x00000000);\r\nDMA_BLOCK(MGA_WACCEPTSEQ, 0x00000000,\r\nMGA_WACCEPTSEQ, 0x00000000,\r\nMGA_WACCEPTSEQ, 0x00000000,\r\nMGA_WACCEPTSEQ, 0x18000000);\r\n}\r\nDMA_BLOCK(MGA_WFLAG, 0x00000000,\r\nMGA_WFLAG1, 0x00000000,\r\nMGA_WR56, MGA_G400_WR56_MAGIC, MGA_DMAPAD, 0x00000000);\r\nDMA_BLOCK(MGA_WR49, 0x00000000,\r\nMGA_WR57, 0x00000000,\r\nMGA_WR53, 0x00000000,\r\nMGA_WR61, 0x00000000);\r\nDMA_BLOCK(MGA_WR54, MGA_G400_WR_MAGIC,\r\nMGA_WR62, MGA_G400_WR_MAGIC,\r\nMGA_WR52, MGA_G400_WR_MAGIC,\r\nMGA_WR60, MGA_G400_WR_MAGIC);\r\nDMA_BLOCK(MGA_DMAPAD, 0xffffffff,\r\nMGA_DMAPAD, 0xffffffff,\r\nMGA_DMAPAD, 0xffffffff,\r\nMGA_WIADDR2, (dev_priv->warp_pipe_phys[pipe] |\r\nMGA_WMODE_START | dev_priv->wagp_enable));\r\nADVANCE_DMA();\r\n}\r\nstatic void mga_g200_emit_state(drm_mga_private_t *dev_priv)\r\n{\r\ndrm_mga_sarea_t *sarea_priv = dev_priv->sarea_priv;\r\nunsigned int dirty = sarea_priv->dirty;\r\nif (sarea_priv->warp_pipe != dev_priv->warp_pipe) {\r\nmga_g200_emit_pipe(dev_priv);\r\ndev_priv->warp_pipe = sarea_priv->warp_pipe;\r\n}\r\nif (dirty & MGA_UPLOAD_CONTEXT) {\r\nmga_g200_emit_context(dev_priv);\r\nsarea_priv->dirty &= ~MGA_UPLOAD_CONTEXT;\r\n}\r\nif (dirty & MGA_UPLOAD_TEX0) {\r\nmga_g200_emit_tex0(dev_priv);\r\nsarea_priv->dirty &= ~MGA_UPLOAD_TEX0;\r\n}\r\n}\r\nstatic void mga_g400_emit_state(drm_mga_private_t *dev_priv)\r\n{\r\ndrm_mga_sarea_t *sarea_priv = dev_priv->sarea_priv;\r\nunsigned int dirty = sarea_priv->dirty;\r\nint multitex = sarea_priv->warp_pipe & MGA_T2;\r\nif (sarea_priv->warp_pipe != dev_priv->warp_pipe) {\r\nmga_g400_emit_pipe(dev_priv);\r\ndev_priv->warp_pipe = sarea_priv->warp_pipe;\r\n}\r\nif (dirty & MGA_UPLOAD_CONTEXT) {\r\nmga_g400_emit_context(dev_priv);\r\nsarea_priv->dirty &= ~MGA_UPLOAD_CONTEXT;\r\n}\r\nif (dirty & MGA_UPLOAD_TEX0) {\r\nmga_g400_emit_tex0(dev_priv);\r\nsarea_priv->dirty &= ~MGA_UPLOAD_TEX0;\r\n}\r\nif ((dirty & MGA_UPLOAD_TEX1) && multitex) {\r\nmga_g400_emit_tex1(dev_priv);\r\nsarea_priv->dirty &= ~MGA_UPLOAD_TEX1;\r\n}\r\n}\r\nstatic int mga_verify_context(drm_mga_private_t *dev_priv)\r\n{\r\ndrm_mga_sarea_t *sarea_priv = dev_priv->sarea_priv;\r\ndrm_mga_context_regs_t *ctx = &sarea_priv->context_state;\r\nif (ctx->dstorg != dev_priv->front_offset &&\r\nctx->dstorg != dev_priv->back_offset) {\r\nDRM_ERROR("*** bad DSTORG: %x (front %x, back %x)\n\n",\r\nctx->dstorg, dev_priv->front_offset,\r\ndev_priv->back_offset);\r\nctx->dstorg = 0;\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int mga_verify_tex(drm_mga_private_t *dev_priv, int unit)\r\n{\r\ndrm_mga_sarea_t *sarea_priv = dev_priv->sarea_priv;\r\ndrm_mga_texture_regs_t *tex = &sarea_priv->tex_state[unit];\r\nunsigned int org;\r\norg = tex->texorg & (MGA_TEXORGMAP_MASK | MGA_TEXORGACC_MASK);\r\nif (org == (MGA_TEXORGMAP_SYSMEM | MGA_TEXORGACC_PCI)) {\r\nDRM_ERROR("*** bad TEXORG: 0x%x, unit %d\n", tex->texorg, unit);\r\ntex->texorg = 0;\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int mga_verify_state(drm_mga_private_t *dev_priv)\r\n{\r\ndrm_mga_sarea_t *sarea_priv = dev_priv->sarea_priv;\r\nunsigned int dirty = sarea_priv->dirty;\r\nint ret = 0;\r\nif (sarea_priv->nbox > MGA_NR_SAREA_CLIPRECTS)\r\nsarea_priv->nbox = MGA_NR_SAREA_CLIPRECTS;\r\nif (dirty & MGA_UPLOAD_CONTEXT)\r\nret |= mga_verify_context(dev_priv);\r\nif (dirty & MGA_UPLOAD_TEX0)\r\nret |= mga_verify_tex(dev_priv, 0);\r\nif (dev_priv->chipset >= MGA_CARD_TYPE_G400) {\r\nif (dirty & MGA_UPLOAD_TEX1)\r\nret |= mga_verify_tex(dev_priv, 1);\r\nif (dirty & MGA_UPLOAD_PIPE)\r\nret |= (sarea_priv->warp_pipe > MGA_MAX_G400_PIPES);\r\n} else {\r\nif (dirty & MGA_UPLOAD_PIPE)\r\nret |= (sarea_priv->warp_pipe > MGA_MAX_G200_PIPES);\r\n}\r\nreturn (ret == 0);\r\n}\r\nstatic int mga_verify_iload(drm_mga_private_t *dev_priv,\r\nunsigned int dstorg, unsigned int length)\r\n{\r\nif (dstorg < dev_priv->texture_offset ||\r\ndstorg + length > (dev_priv->texture_offset +\r\ndev_priv->texture_size)) {\r\nDRM_ERROR("*** bad iload DSTORG: 0x%x\n", dstorg);\r\nreturn -EINVAL;\r\n}\r\nif (length & MGA_ILOAD_MASK) {\r\nDRM_ERROR("*** bad iload length: 0x%x\n",\r\nlength & MGA_ILOAD_MASK);\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int mga_verify_blit(drm_mga_private_t *dev_priv,\r\nunsigned int srcorg, unsigned int dstorg)\r\n{\r\nif ((srcorg & 0x3) == (MGA_SRCACC_PCI | MGA_SRCMAP_SYSMEM) ||\r\n(dstorg & 0x3) == (MGA_SRCACC_PCI | MGA_SRCMAP_SYSMEM)) {\r\nDRM_ERROR("*** bad blit: src=0x%x dst=0x%x\n", srcorg, dstorg);\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic void mga_dma_dispatch_clear(struct drm_device *dev, drm_mga_clear_t *clear)\r\n{\r\ndrm_mga_private_t *dev_priv = dev->dev_private;\r\ndrm_mga_sarea_t *sarea_priv = dev_priv->sarea_priv;\r\ndrm_mga_context_regs_t *ctx = &sarea_priv->context_state;\r\nstruct drm_clip_rect *pbox = sarea_priv->boxes;\r\nint nbox = sarea_priv->nbox;\r\nint i;\r\nDMA_LOCALS;\r\nDRM_DEBUG("\n");\r\nBEGIN_DMA(1);\r\nDMA_BLOCK(MGA_DMAPAD, 0x00000000,\r\nMGA_DMAPAD, 0x00000000,\r\nMGA_DWGSYNC, 0x00007100, MGA_DWGSYNC, 0x00007000);\r\nADVANCE_DMA();\r\nfor (i = 0; i < nbox; i++) {\r\nstruct drm_clip_rect *box = &pbox[i];\r\nu32 height = box->y2 - box->y1;\r\nDRM_DEBUG(" from=%d,%d to=%d,%d\n",\r\nbox->x1, box->y1, box->x2, box->y2);\r\nif (clear->flags & MGA_FRONT) {\r\nBEGIN_DMA(2);\r\nDMA_BLOCK(MGA_DMAPAD, 0x00000000,\r\nMGA_PLNWT, clear->color_mask,\r\nMGA_YDSTLEN, (box->y1 << 16) | height,\r\nMGA_FXBNDRY, (box->x2 << 16) | box->x1);\r\nDMA_BLOCK(MGA_DMAPAD, 0x00000000,\r\nMGA_FCOL, clear->clear_color,\r\nMGA_DSTORG, dev_priv->front_offset,\r\nMGA_DWGCTL + MGA_EXEC, dev_priv->clear_cmd);\r\nADVANCE_DMA();\r\n}\r\nif (clear->flags & MGA_BACK) {\r\nBEGIN_DMA(2);\r\nDMA_BLOCK(MGA_DMAPAD, 0x00000000,\r\nMGA_PLNWT, clear->color_mask,\r\nMGA_YDSTLEN, (box->y1 << 16) | height,\r\nMGA_FXBNDRY, (box->x2 << 16) | box->x1);\r\nDMA_BLOCK(MGA_DMAPAD, 0x00000000,\r\nMGA_FCOL, clear->clear_color,\r\nMGA_DSTORG, dev_priv->back_offset,\r\nMGA_DWGCTL + MGA_EXEC, dev_priv->clear_cmd);\r\nADVANCE_DMA();\r\n}\r\nif (clear->flags & MGA_DEPTH) {\r\nBEGIN_DMA(2);\r\nDMA_BLOCK(MGA_DMAPAD, 0x00000000,\r\nMGA_PLNWT, clear->depth_mask,\r\nMGA_YDSTLEN, (box->y1 << 16) | height,\r\nMGA_FXBNDRY, (box->x2 << 16) | box->x1);\r\nDMA_BLOCK(MGA_DMAPAD, 0x00000000,\r\nMGA_FCOL, clear->clear_depth,\r\nMGA_DSTORG, dev_priv->depth_offset,\r\nMGA_DWGCTL + MGA_EXEC, dev_priv->clear_cmd);\r\nADVANCE_DMA();\r\n}\r\n}\r\nBEGIN_DMA(1);\r\nDMA_BLOCK(MGA_DMAPAD, 0x00000000,\r\nMGA_DMAPAD, 0x00000000,\r\nMGA_PLNWT, ctx->plnwt, MGA_DWGCTL, ctx->dwgctl);\r\nADVANCE_DMA();\r\nFLUSH_DMA();\r\n}\r\nstatic void mga_dma_dispatch_swap(struct drm_device *dev)\r\n{\r\ndrm_mga_private_t *dev_priv = dev->dev_private;\r\ndrm_mga_sarea_t *sarea_priv = dev_priv->sarea_priv;\r\ndrm_mga_context_regs_t *ctx = &sarea_priv->context_state;\r\nstruct drm_clip_rect *pbox = sarea_priv->boxes;\r\nint nbox = sarea_priv->nbox;\r\nint i;\r\nDMA_LOCALS;\r\nDRM_DEBUG("\n");\r\nsarea_priv->last_frame.head = dev_priv->prim.tail;\r\nsarea_priv->last_frame.wrap = dev_priv->prim.last_wrap;\r\nBEGIN_DMA(4 + nbox);\r\nDMA_BLOCK(MGA_DMAPAD, 0x00000000,\r\nMGA_DMAPAD, 0x00000000,\r\nMGA_DWGSYNC, 0x00007100, MGA_DWGSYNC, 0x00007000);\r\nDMA_BLOCK(MGA_DSTORG, dev_priv->front_offset,\r\nMGA_MACCESS, dev_priv->maccess,\r\nMGA_SRCORG, dev_priv->back_offset,\r\nMGA_AR5, dev_priv->front_pitch);\r\nDMA_BLOCK(MGA_DMAPAD, 0x00000000,\r\nMGA_DMAPAD, 0x00000000,\r\nMGA_PLNWT, 0xffffffff, MGA_DWGCTL, MGA_DWGCTL_COPY);\r\nfor (i = 0; i < nbox; i++) {\r\nstruct drm_clip_rect *box = &pbox[i];\r\nu32 height = box->y2 - box->y1;\r\nu32 start = box->y1 * dev_priv->front_pitch;\r\nDRM_DEBUG(" from=%d,%d to=%d,%d\n",\r\nbox->x1, box->y1, box->x2, box->y2);\r\nDMA_BLOCK(MGA_AR0, start + box->x2 - 1,\r\nMGA_AR3, start + box->x1,\r\nMGA_FXBNDRY, ((box->x2 - 1) << 16) | box->x1,\r\nMGA_YDSTLEN + MGA_EXEC, (box->y1 << 16) | height);\r\n}\r\nDMA_BLOCK(MGA_DMAPAD, 0x00000000,\r\nMGA_PLNWT, ctx->plnwt,\r\nMGA_SRCORG, dev_priv->front_offset, MGA_DWGCTL, ctx->dwgctl);\r\nADVANCE_DMA();\r\nFLUSH_DMA();\r\nDRM_DEBUG("... done.\n");\r\n}\r\nstatic void mga_dma_dispatch_vertex(struct drm_device *dev, struct drm_buf *buf)\r\n{\r\ndrm_mga_private_t *dev_priv = dev->dev_private;\r\ndrm_mga_buf_priv_t *buf_priv = buf->dev_private;\r\ndrm_mga_sarea_t *sarea_priv = dev_priv->sarea_priv;\r\nu32 address = (u32) buf->bus_address;\r\nu32 length = (u32) buf->used;\r\nint i = 0;\r\nDMA_LOCALS;\r\nDRM_DEBUG("buf=%d used=%d\n", buf->idx, buf->used);\r\nif (buf->used) {\r\nbuf_priv->dispatched = 1;\r\nMGA_EMIT_STATE(dev_priv, sarea_priv->dirty);\r\ndo {\r\nif (i < sarea_priv->nbox) {\r\nmga_emit_clip_rect(dev_priv,\r\n&sarea_priv->boxes[i]);\r\n}\r\nBEGIN_DMA(1);\r\nDMA_BLOCK(MGA_DMAPAD, 0x00000000,\r\nMGA_DMAPAD, 0x00000000,\r\nMGA_SECADDRESS, (address |\r\nMGA_DMA_VERTEX),\r\nMGA_SECEND, ((address + length) |\r\ndev_priv->dma_access));\r\nADVANCE_DMA();\r\n} while (++i < sarea_priv->nbox);\r\n}\r\nif (buf_priv->discard) {\r\nAGE_BUFFER(buf_priv);\r\nbuf->pending = 0;\r\nbuf->used = 0;\r\nbuf_priv->dispatched = 0;\r\nmga_freelist_put(dev, buf);\r\n}\r\nFLUSH_DMA();\r\n}\r\nstatic void mga_dma_dispatch_indices(struct drm_device *dev, struct drm_buf *buf,\r\nunsigned int start, unsigned int end)\r\n{\r\ndrm_mga_private_t *dev_priv = dev->dev_private;\r\ndrm_mga_buf_priv_t *buf_priv = buf->dev_private;\r\ndrm_mga_sarea_t *sarea_priv = dev_priv->sarea_priv;\r\nu32 address = (u32) buf->bus_address;\r\nint i = 0;\r\nDMA_LOCALS;\r\nDRM_DEBUG("buf=%d start=%d end=%d\n", buf->idx, start, end);\r\nif (start != end) {\r\nbuf_priv->dispatched = 1;\r\nMGA_EMIT_STATE(dev_priv, sarea_priv->dirty);\r\ndo {\r\nif (i < sarea_priv->nbox) {\r\nmga_emit_clip_rect(dev_priv,\r\n&sarea_priv->boxes[i]);\r\n}\r\nBEGIN_DMA(1);\r\nDMA_BLOCK(MGA_DMAPAD, 0x00000000,\r\nMGA_DMAPAD, 0x00000000,\r\nMGA_SETUPADDRESS, address + start,\r\nMGA_SETUPEND, ((address + end) |\r\ndev_priv->dma_access));\r\nADVANCE_DMA();\r\n} while (++i < sarea_priv->nbox);\r\n}\r\nif (buf_priv->discard) {\r\nAGE_BUFFER(buf_priv);\r\nbuf->pending = 0;\r\nbuf->used = 0;\r\nbuf_priv->dispatched = 0;\r\nmga_freelist_put(dev, buf);\r\n}\r\nFLUSH_DMA();\r\n}\r\nstatic void mga_dma_dispatch_iload(struct drm_device *dev, struct drm_buf *buf,\r\nunsigned int dstorg, unsigned int length)\r\n{\r\ndrm_mga_private_t *dev_priv = dev->dev_private;\r\ndrm_mga_buf_priv_t *buf_priv = buf->dev_private;\r\ndrm_mga_context_regs_t *ctx = &dev_priv->sarea_priv->context_state;\r\nu32 srcorg =\r\nbuf->bus_address | dev_priv->dma_access | MGA_SRCMAP_SYSMEM;\r\nu32 y2;\r\nDMA_LOCALS;\r\nDRM_DEBUG("buf=%d used=%d\n", buf->idx, buf->used);\r\ny2 = length / 64;\r\nBEGIN_DMA(5);\r\nDMA_BLOCK(MGA_DMAPAD, 0x00000000,\r\nMGA_DMAPAD, 0x00000000,\r\nMGA_DWGSYNC, 0x00007100, MGA_DWGSYNC, 0x00007000);\r\nDMA_BLOCK(MGA_DSTORG, dstorg,\r\nMGA_MACCESS, 0x00000000, MGA_SRCORG, srcorg, MGA_AR5, 64);\r\nDMA_BLOCK(MGA_PITCH, 64,\r\nMGA_PLNWT, 0xffffffff,\r\nMGA_DMAPAD, 0x00000000, MGA_DWGCTL, MGA_DWGCTL_COPY);\r\nDMA_BLOCK(MGA_AR0, 63,\r\nMGA_AR3, 0,\r\nMGA_FXBNDRY, (63 << 16) | 0, MGA_YDSTLEN + MGA_EXEC, y2);\r\nDMA_BLOCK(MGA_PLNWT, ctx->plnwt,\r\nMGA_SRCORG, dev_priv->front_offset,\r\nMGA_PITCH, dev_priv->front_pitch, MGA_DWGSYNC, 0x00007000);\r\nADVANCE_DMA();\r\nAGE_BUFFER(buf_priv);\r\nbuf->pending = 0;\r\nbuf->used = 0;\r\nbuf_priv->dispatched = 0;\r\nmga_freelist_put(dev, buf);\r\nFLUSH_DMA();\r\n}\r\nstatic void mga_dma_dispatch_blit(struct drm_device *dev, drm_mga_blit_t *blit)\r\n{\r\ndrm_mga_private_t *dev_priv = dev->dev_private;\r\ndrm_mga_sarea_t *sarea_priv = dev_priv->sarea_priv;\r\ndrm_mga_context_regs_t *ctx = &sarea_priv->context_state;\r\nstruct drm_clip_rect *pbox = sarea_priv->boxes;\r\nint nbox = sarea_priv->nbox;\r\nu32 scandir = 0, i;\r\nDMA_LOCALS;\r\nDRM_DEBUG("\n");\r\nBEGIN_DMA(4 + nbox);\r\nDMA_BLOCK(MGA_DMAPAD, 0x00000000,\r\nMGA_DMAPAD, 0x00000000,\r\nMGA_DWGSYNC, 0x00007100, MGA_DWGSYNC, 0x00007000);\r\nDMA_BLOCK(MGA_DWGCTL, MGA_DWGCTL_COPY,\r\nMGA_PLNWT, blit->planemask,\r\nMGA_SRCORG, blit->srcorg, MGA_DSTORG, blit->dstorg);\r\nDMA_BLOCK(MGA_SGN, scandir,\r\nMGA_MACCESS, dev_priv->maccess,\r\nMGA_AR5, blit->ydir * blit->src_pitch,\r\nMGA_PITCH, blit->dst_pitch);\r\nfor (i = 0; i < nbox; i++) {\r\nint srcx = pbox[i].x1 + blit->delta_sx;\r\nint srcy = pbox[i].y1 + blit->delta_sy;\r\nint dstx = pbox[i].x1 + blit->delta_dx;\r\nint dsty = pbox[i].y1 + blit->delta_dy;\r\nint h = pbox[i].y2 - pbox[i].y1;\r\nint w = pbox[i].x2 - pbox[i].x1 - 1;\r\nint start;\r\nif (blit->ydir == -1)\r\nsrcy = blit->height - srcy - 1;\r\nstart = srcy * blit->src_pitch + srcx;\r\nDMA_BLOCK(MGA_AR0, start + w,\r\nMGA_AR3, start,\r\nMGA_FXBNDRY, ((dstx + w) << 16) | (dstx & 0xffff),\r\nMGA_YDSTLEN + MGA_EXEC, (dsty << 16) | h);\r\n}\r\nDMA_BLOCK(MGA_DMAPAD, 0x00000000,\r\nMGA_PLNWT, ctx->plnwt,\r\nMGA_PITCH, dev_priv->front_pitch, MGA_DWGCTL, ctx->dwgctl);\r\nADVANCE_DMA();\r\n}\r\nstatic int mga_dma_clear(struct drm_device *dev, void *data, struct drm_file *file_priv)\r\n{\r\ndrm_mga_private_t *dev_priv = dev->dev_private;\r\ndrm_mga_sarea_t *sarea_priv = dev_priv->sarea_priv;\r\ndrm_mga_clear_t *clear = data;\r\nLOCK_TEST_WITH_RETURN(dev, file_priv);\r\nif (sarea_priv->nbox > MGA_NR_SAREA_CLIPRECTS)\r\nsarea_priv->nbox = MGA_NR_SAREA_CLIPRECTS;\r\nWRAP_TEST_WITH_RETURN(dev_priv);\r\nmga_dma_dispatch_clear(dev, clear);\r\ndev_priv->sarea_priv->dirty |= MGA_UPLOAD_CONTEXT;\r\nreturn 0;\r\n}\r\nstatic int mga_dma_swap(struct drm_device *dev, void *data, struct drm_file *file_priv)\r\n{\r\ndrm_mga_private_t *dev_priv = dev->dev_private;\r\ndrm_mga_sarea_t *sarea_priv = dev_priv->sarea_priv;\r\nLOCK_TEST_WITH_RETURN(dev, file_priv);\r\nif (sarea_priv->nbox > MGA_NR_SAREA_CLIPRECTS)\r\nsarea_priv->nbox = MGA_NR_SAREA_CLIPRECTS;\r\nWRAP_TEST_WITH_RETURN(dev_priv);\r\nmga_dma_dispatch_swap(dev);\r\ndev_priv->sarea_priv->dirty |= MGA_UPLOAD_CONTEXT;\r\nreturn 0;\r\n}\r\nstatic int mga_dma_vertex(struct drm_device *dev, void *data, struct drm_file *file_priv)\r\n{\r\ndrm_mga_private_t *dev_priv = dev->dev_private;\r\nstruct drm_device_dma *dma = dev->dma;\r\nstruct drm_buf *buf;\r\ndrm_mga_buf_priv_t *buf_priv;\r\ndrm_mga_vertex_t *vertex = data;\r\nLOCK_TEST_WITH_RETURN(dev, file_priv);\r\nif (vertex->idx < 0 || vertex->idx > dma->buf_count)\r\nreturn -EINVAL;\r\nbuf = dma->buflist[vertex->idx];\r\nbuf_priv = buf->dev_private;\r\nbuf->used = vertex->used;\r\nbuf_priv->discard = vertex->discard;\r\nif (!mga_verify_state(dev_priv)) {\r\nif (vertex->discard) {\r\nif (buf_priv->dispatched == 1)\r\nAGE_BUFFER(buf_priv);\r\nbuf_priv->dispatched = 0;\r\nmga_freelist_put(dev, buf);\r\n}\r\nreturn -EINVAL;\r\n}\r\nWRAP_TEST_WITH_RETURN(dev_priv);\r\nmga_dma_dispatch_vertex(dev, buf);\r\nreturn 0;\r\n}\r\nstatic int mga_dma_indices(struct drm_device *dev, void *data, struct drm_file *file_priv)\r\n{\r\ndrm_mga_private_t *dev_priv = dev->dev_private;\r\nstruct drm_device_dma *dma = dev->dma;\r\nstruct drm_buf *buf;\r\ndrm_mga_buf_priv_t *buf_priv;\r\ndrm_mga_indices_t *indices = data;\r\nLOCK_TEST_WITH_RETURN(dev, file_priv);\r\nif (indices->idx < 0 || indices->idx > dma->buf_count)\r\nreturn -EINVAL;\r\nbuf = dma->buflist[indices->idx];\r\nbuf_priv = buf->dev_private;\r\nbuf_priv->discard = indices->discard;\r\nif (!mga_verify_state(dev_priv)) {\r\nif (indices->discard) {\r\nif (buf_priv->dispatched == 1)\r\nAGE_BUFFER(buf_priv);\r\nbuf_priv->dispatched = 0;\r\nmga_freelist_put(dev, buf);\r\n}\r\nreturn -EINVAL;\r\n}\r\nWRAP_TEST_WITH_RETURN(dev_priv);\r\nmga_dma_dispatch_indices(dev, buf, indices->start, indices->end);\r\nreturn 0;\r\n}\r\nstatic int mga_dma_iload(struct drm_device *dev, void *data, struct drm_file *file_priv)\r\n{\r\nstruct drm_device_dma *dma = dev->dma;\r\ndrm_mga_private_t *dev_priv = dev->dev_private;\r\nstruct drm_buf *buf;\r\ndrm_mga_buf_priv_t *buf_priv;\r\ndrm_mga_iload_t *iload = data;\r\nDRM_DEBUG("\n");\r\nLOCK_TEST_WITH_RETURN(dev, file_priv);\r\n#if 0\r\nif (mga_do_wait_for_idle(dev_priv) < 0) {\r\nif (MGA_DMA_DEBUG)\r\nDRM_INFO("-EBUSY\n");\r\nreturn -EBUSY;\r\n}\r\n#endif\r\nif (iload->idx < 0 || iload->idx > dma->buf_count)\r\nreturn -EINVAL;\r\nbuf = dma->buflist[iload->idx];\r\nbuf_priv = buf->dev_private;\r\nif (mga_verify_iload(dev_priv, iload->dstorg, iload->length)) {\r\nmga_freelist_put(dev, buf);\r\nreturn -EINVAL;\r\n}\r\nWRAP_TEST_WITH_RETURN(dev_priv);\r\nmga_dma_dispatch_iload(dev, buf, iload->dstorg, iload->length);\r\ndev_priv->sarea_priv->dirty |= MGA_UPLOAD_CONTEXT;\r\nreturn 0;\r\n}\r\nstatic int mga_dma_blit(struct drm_device *dev, void *data, struct drm_file *file_priv)\r\n{\r\ndrm_mga_private_t *dev_priv = dev->dev_private;\r\ndrm_mga_sarea_t *sarea_priv = dev_priv->sarea_priv;\r\ndrm_mga_blit_t *blit = data;\r\nDRM_DEBUG("\n");\r\nLOCK_TEST_WITH_RETURN(dev, file_priv);\r\nif (sarea_priv->nbox > MGA_NR_SAREA_CLIPRECTS)\r\nsarea_priv->nbox = MGA_NR_SAREA_CLIPRECTS;\r\nif (mga_verify_blit(dev_priv, blit->srcorg, blit->dstorg))\r\nreturn -EINVAL;\r\nWRAP_TEST_WITH_RETURN(dev_priv);\r\nmga_dma_dispatch_blit(dev, blit);\r\ndev_priv->sarea_priv->dirty |= MGA_UPLOAD_CONTEXT;\r\nreturn 0;\r\n}\r\nstatic int mga_getparam(struct drm_device *dev, void *data, struct drm_file *file_priv)\r\n{\r\ndrm_mga_private_t *dev_priv = dev->dev_private;\r\ndrm_mga_getparam_t *param = data;\r\nint value;\r\nif (!dev_priv) {\r\nDRM_ERROR("called with no initialization\n");\r\nreturn -EINVAL;\r\n}\r\nDRM_DEBUG("pid=%d\n", DRM_CURRENTPID);\r\nswitch (param->param) {\r\ncase MGA_PARAM_IRQ_NR:\r\nvalue = dev->pdev->irq;\r\nbreak;\r\ncase MGA_PARAM_CARD_TYPE:\r\nvalue = dev_priv->chipset;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nif (copy_to_user(param->value, &value, sizeof(int))) {\r\nDRM_ERROR("copy_to_user\n");\r\nreturn -EFAULT;\r\n}\r\nreturn 0;\r\n}\r\nstatic int mga_set_fence(struct drm_device *dev, void *data, struct drm_file *file_priv)\r\n{\r\ndrm_mga_private_t *dev_priv = dev->dev_private;\r\nu32 *fence = data;\r\nDMA_LOCALS;\r\nif (!dev_priv) {\r\nDRM_ERROR("called with no initialization\n");\r\nreturn -EINVAL;\r\n}\r\nDRM_DEBUG("pid=%d\n", DRM_CURRENTPID);\r\n*fence = dev_priv->next_fence_to_post;\r\ndev_priv->next_fence_to_post++;\r\nBEGIN_DMA(1);\r\nDMA_BLOCK(MGA_DMAPAD, 0x00000000,\r\nMGA_DMAPAD, 0x00000000,\r\nMGA_DMAPAD, 0x00000000, MGA_SOFTRAP, 0x00000000);\r\nADVANCE_DMA();\r\nreturn 0;\r\n}\r\nstatic int mga_wait_fence(struct drm_device *dev, void *data, struct drm_file *\r\nfile_priv)\r\n{\r\ndrm_mga_private_t *dev_priv = dev->dev_private;\r\nu32 *fence = data;\r\nif (!dev_priv) {\r\nDRM_ERROR("called with no initialization\n");\r\nreturn -EINVAL;\r\n}\r\nDRM_DEBUG("pid=%d\n", DRM_CURRENTPID);\r\nmga_driver_fence_wait(dev, fence);\r\nreturn 0;\r\n}
