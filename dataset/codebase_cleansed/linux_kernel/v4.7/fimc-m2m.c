static unsigned int get_m2m_fmt_flags(unsigned int stream_type)\r\n{\r\nif (stream_type == V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE)\r\nreturn FMT_FLAGS_M2M_IN;\r\nelse\r\nreturn FMT_FLAGS_M2M_OUT;\r\n}\r\nvoid fimc_m2m_job_finish(struct fimc_ctx *ctx, int vb_state)\r\n{\r\nstruct vb2_v4l2_buffer *src_vb, *dst_vb;\r\nif (!ctx || !ctx->fh.m2m_ctx)\r\nreturn;\r\nsrc_vb = v4l2_m2m_src_buf_remove(ctx->fh.m2m_ctx);\r\ndst_vb = v4l2_m2m_dst_buf_remove(ctx->fh.m2m_ctx);\r\nif (src_vb && dst_vb) {\r\nv4l2_m2m_buf_done(src_vb, vb_state);\r\nv4l2_m2m_buf_done(dst_vb, vb_state);\r\nv4l2_m2m_job_finish(ctx->fimc_dev->m2m.m2m_dev,\r\nctx->fh.m2m_ctx);\r\n}\r\n}\r\nstatic int fimc_m2m_shutdown(struct fimc_ctx *ctx)\r\n{\r\nstruct fimc_dev *fimc = ctx->fimc_dev;\r\nint ret;\r\nif (!fimc_m2m_pending(fimc))\r\nreturn 0;\r\nfimc_ctx_state_set(FIMC_CTX_SHUT, ctx);\r\nret = wait_event_timeout(fimc->irq_queue,\r\n!fimc_ctx_state_is_set(FIMC_CTX_SHUT, ctx),\r\nFIMC_SHUTDOWN_TIMEOUT);\r\nreturn ret == 0 ? -ETIMEDOUT : ret;\r\n}\r\nstatic int start_streaming(struct vb2_queue *q, unsigned int count)\r\n{\r\nstruct fimc_ctx *ctx = q->drv_priv;\r\nint ret;\r\nret = pm_runtime_get_sync(&ctx->fimc_dev->pdev->dev);\r\nreturn ret > 0 ? 0 : ret;\r\n}\r\nstatic void stop_streaming(struct vb2_queue *q)\r\n{\r\nstruct fimc_ctx *ctx = q->drv_priv;\r\nint ret;\r\nret = fimc_m2m_shutdown(ctx);\r\nif (ret == -ETIMEDOUT)\r\nfimc_m2m_job_finish(ctx, VB2_BUF_STATE_ERROR);\r\npm_runtime_put(&ctx->fimc_dev->pdev->dev);\r\n}\r\nstatic void fimc_device_run(void *priv)\r\n{\r\nstruct vb2_v4l2_buffer *src_vb, *dst_vb;\r\nstruct fimc_ctx *ctx = priv;\r\nstruct fimc_frame *sf, *df;\r\nstruct fimc_dev *fimc;\r\nunsigned long flags;\r\nint ret;\r\nif (WARN(!ctx, "Null context\n"))\r\nreturn;\r\nfimc = ctx->fimc_dev;\r\nspin_lock_irqsave(&fimc->slock, flags);\r\nset_bit(ST_M2M_PEND, &fimc->state);\r\nsf = &ctx->s_frame;\r\ndf = &ctx->d_frame;\r\nif (ctx->state & FIMC_PARAMS) {\r\nfimc_prepare_dma_offset(ctx, sf);\r\nfimc_prepare_dma_offset(ctx, df);\r\n}\r\nsrc_vb = v4l2_m2m_next_src_buf(ctx->fh.m2m_ctx);\r\nret = fimc_prepare_addr(ctx, &src_vb->vb2_buf, sf, &sf->paddr);\r\nif (ret)\r\ngoto dma_unlock;\r\ndst_vb = v4l2_m2m_next_dst_buf(ctx->fh.m2m_ctx);\r\nret = fimc_prepare_addr(ctx, &dst_vb->vb2_buf, df, &df->paddr);\r\nif (ret)\r\ngoto dma_unlock;\r\ndst_vb->vb2_buf.timestamp = src_vb->vb2_buf.timestamp;\r\ndst_vb->flags &= ~V4L2_BUF_FLAG_TSTAMP_SRC_MASK;\r\ndst_vb->flags |=\r\nsrc_vb->flags & V4L2_BUF_FLAG_TSTAMP_SRC_MASK;\r\nif (fimc->m2m.ctx != ctx) {\r\nctx->state |= FIMC_PARAMS;\r\nfimc->m2m.ctx = ctx;\r\n}\r\nif (ctx->state & FIMC_PARAMS) {\r\nfimc_set_yuv_order(ctx);\r\nfimc_hw_set_input_path(ctx);\r\nfimc_hw_set_in_dma(ctx);\r\nret = fimc_set_scaler_info(ctx);\r\nif (ret)\r\ngoto dma_unlock;\r\nfimc_hw_set_prescaler(ctx);\r\nfimc_hw_set_mainscaler(ctx);\r\nfimc_hw_set_target_format(ctx);\r\nfimc_hw_set_rotation(ctx);\r\nfimc_hw_set_effect(ctx);\r\nfimc_hw_set_out_dma(ctx);\r\nif (fimc->drv_data->alpha_color)\r\nfimc_hw_set_rgb_alpha(ctx);\r\nfimc_hw_set_output_path(ctx);\r\n}\r\nfimc_hw_set_input_addr(fimc, &sf->paddr);\r\nfimc_hw_set_output_addr(fimc, &df->paddr, -1);\r\nfimc_activate_capture(ctx);\r\nctx->state &= (FIMC_CTX_M2M | FIMC_CTX_CAP);\r\nfimc_hw_activate_input_dma(fimc, true);\r\ndma_unlock:\r\nspin_unlock_irqrestore(&fimc->slock, flags);\r\n}\r\nstatic void fimc_job_abort(void *priv)\r\n{\r\nfimc_m2m_shutdown(priv);\r\n}\r\nstatic int fimc_queue_setup(struct vb2_queue *vq,\r\nunsigned int *num_buffers, unsigned int *num_planes,\r\nunsigned int sizes[], void *allocators[])\r\n{\r\nstruct fimc_ctx *ctx = vb2_get_drv_priv(vq);\r\nstruct fimc_frame *f;\r\nint i;\r\nf = ctx_get_frame(ctx, vq->type);\r\nif (IS_ERR(f))\r\nreturn PTR_ERR(f);\r\nif (!f->fmt)\r\nreturn -EINVAL;\r\n*num_planes = f->fmt->memplanes;\r\nfor (i = 0; i < f->fmt->memplanes; i++) {\r\nsizes[i] = f->payload[i];\r\nallocators[i] = ctx->fimc_dev->alloc_ctx;\r\n}\r\nreturn 0;\r\n}\r\nstatic int fimc_buf_prepare(struct vb2_buffer *vb)\r\n{\r\nstruct fimc_ctx *ctx = vb2_get_drv_priv(vb->vb2_queue);\r\nstruct fimc_frame *frame;\r\nint i;\r\nframe = ctx_get_frame(ctx, vb->vb2_queue->type);\r\nif (IS_ERR(frame))\r\nreturn PTR_ERR(frame);\r\nfor (i = 0; i < frame->fmt->memplanes; i++)\r\nvb2_set_plane_payload(vb, i, frame->payload[i]);\r\nreturn 0;\r\n}\r\nstatic void fimc_buf_queue(struct vb2_buffer *vb)\r\n{\r\nstruct vb2_v4l2_buffer *vbuf = to_vb2_v4l2_buffer(vb);\r\nstruct fimc_ctx *ctx = vb2_get_drv_priv(vb->vb2_queue);\r\nv4l2_m2m_buf_queue(ctx->fh.m2m_ctx, vbuf);\r\n}\r\nstatic int fimc_m2m_querycap(struct file *file, void *fh,\r\nstruct v4l2_capability *cap)\r\n{\r\nstruct fimc_dev *fimc = video_drvdata(file);\r\nunsigned int caps;\r\ncaps = V4L2_CAP_STREAMING | V4L2_CAP_VIDEO_M2M_MPLANE |\r\nV4L2_CAP_VIDEO_CAPTURE_MPLANE | V4L2_CAP_VIDEO_OUTPUT_MPLANE;\r\n__fimc_vidioc_querycap(&fimc->pdev->dev, cap, caps);\r\nreturn 0;\r\n}\r\nstatic int fimc_m2m_enum_fmt_mplane(struct file *file, void *priv,\r\nstruct v4l2_fmtdesc *f)\r\n{\r\nstruct fimc_fmt *fmt;\r\nfmt = fimc_find_format(NULL, NULL, get_m2m_fmt_flags(f->type),\r\nf->index);\r\nif (!fmt)\r\nreturn -EINVAL;\r\nstrncpy(f->description, fmt->name, sizeof(f->description) - 1);\r\nf->pixelformat = fmt->fourcc;\r\nreturn 0;\r\n}\r\nstatic int fimc_m2m_g_fmt_mplane(struct file *file, void *fh,\r\nstruct v4l2_format *f)\r\n{\r\nstruct fimc_ctx *ctx = fh_to_ctx(fh);\r\nstruct fimc_frame *frame = ctx_get_frame(ctx, f->type);\r\nif (IS_ERR(frame))\r\nreturn PTR_ERR(frame);\r\n__fimc_get_format(frame, f);\r\nreturn 0;\r\n}\r\nstatic int fimc_try_fmt_mplane(struct fimc_ctx *ctx, struct v4l2_format *f)\r\n{\r\nstruct fimc_dev *fimc = ctx->fimc_dev;\r\nconst struct fimc_variant *variant = fimc->variant;\r\nstruct v4l2_pix_format_mplane *pix = &f->fmt.pix_mp;\r\nstruct fimc_fmt *fmt;\r\nu32 max_w, mod_x, mod_y;\r\nif (!IS_M2M(f->type))\r\nreturn -EINVAL;\r\nfmt = fimc_find_format(&pix->pixelformat, NULL,\r\nget_m2m_fmt_flags(f->type), 0);\r\nif (WARN(fmt == NULL, "Pixel format lookup failed"))\r\nreturn -EINVAL;\r\nif (pix->field == V4L2_FIELD_ANY)\r\npix->field = V4L2_FIELD_NONE;\r\nelse if (pix->field != V4L2_FIELD_NONE)\r\nreturn -EINVAL;\r\nif (f->type == V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE) {\r\nmax_w = variant->pix_limit->scaler_dis_w;\r\nmod_x = ffs(variant->min_inp_pixsize) - 1;\r\n} else {\r\nmax_w = variant->pix_limit->out_rot_dis_w;\r\nmod_x = ffs(variant->min_out_pixsize) - 1;\r\n}\r\nif (tiled_fmt(fmt)) {\r\nmod_x = 6;\r\nmod_y = 5;\r\n} else {\r\nif (variant->min_vsize_align == 1)\r\nmod_y = fimc_fmt_is_rgb(fmt->color) ? 0 : 1;\r\nelse\r\nmod_y = ffs(variant->min_vsize_align) - 1;\r\n}\r\nv4l_bound_align_image(&pix->width, 16, max_w, mod_x,\r\n&pix->height, 8, variant->pix_limit->scaler_dis_w, mod_y, 0);\r\nfimc_adjust_mplane_format(fmt, pix->width, pix->height, &f->fmt.pix_mp);\r\nreturn 0;\r\n}\r\nstatic int fimc_m2m_try_fmt_mplane(struct file *file, void *fh,\r\nstruct v4l2_format *f)\r\n{\r\nstruct fimc_ctx *ctx = fh_to_ctx(fh);\r\nreturn fimc_try_fmt_mplane(ctx, f);\r\n}\r\nstatic void __set_frame_format(struct fimc_frame *frame, struct fimc_fmt *fmt,\r\nstruct v4l2_pix_format_mplane *pixm)\r\n{\r\nint i;\r\nfor (i = 0; i < fmt->memplanes; i++) {\r\nframe->bytesperline[i] = pixm->plane_fmt[i].bytesperline;\r\nframe->payload[i] = pixm->plane_fmt[i].sizeimage;\r\n}\r\nframe->f_width = pixm->width;\r\nframe->f_height = pixm->height;\r\nframe->o_width = pixm->width;\r\nframe->o_height = pixm->height;\r\nframe->width = pixm->width;\r\nframe->height = pixm->height;\r\nframe->offs_h = 0;\r\nframe->offs_v = 0;\r\nframe->fmt = fmt;\r\n}\r\nstatic int fimc_m2m_s_fmt_mplane(struct file *file, void *fh,\r\nstruct v4l2_format *f)\r\n{\r\nstruct fimc_ctx *ctx = fh_to_ctx(fh);\r\nstruct fimc_dev *fimc = ctx->fimc_dev;\r\nstruct fimc_fmt *fmt;\r\nstruct vb2_queue *vq;\r\nstruct fimc_frame *frame;\r\nint ret;\r\nret = fimc_try_fmt_mplane(ctx, f);\r\nif (ret)\r\nreturn ret;\r\nvq = v4l2_m2m_get_vq(ctx->fh.m2m_ctx, f->type);\r\nif (vb2_is_busy(vq)) {\r\nv4l2_err(&fimc->m2m.vfd, "queue (%d) busy\n", f->type);\r\nreturn -EBUSY;\r\n}\r\nif (f->type == V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE)\r\nframe = &ctx->s_frame;\r\nelse\r\nframe = &ctx->d_frame;\r\nfmt = fimc_find_format(&f->fmt.pix_mp.pixelformat, NULL,\r\nget_m2m_fmt_flags(f->type), 0);\r\nif (!fmt)\r\nreturn -EINVAL;\r\n__set_frame_format(frame, fmt, &f->fmt.pix_mp);\r\nfimc_alpha_ctrl_update(ctx);\r\nreturn 0;\r\n}\r\nstatic int fimc_m2m_cropcap(struct file *file, void *fh,\r\nstruct v4l2_cropcap *cr)\r\n{\r\nstruct fimc_ctx *ctx = fh_to_ctx(fh);\r\nstruct fimc_frame *frame;\r\nframe = ctx_get_frame(ctx, cr->type);\r\nif (IS_ERR(frame))\r\nreturn PTR_ERR(frame);\r\ncr->bounds.left = 0;\r\ncr->bounds.top = 0;\r\ncr->bounds.width = frame->o_width;\r\ncr->bounds.height = frame->o_height;\r\ncr->defrect = cr->bounds;\r\nreturn 0;\r\n}\r\nstatic int fimc_m2m_g_crop(struct file *file, void *fh, struct v4l2_crop *cr)\r\n{\r\nstruct fimc_ctx *ctx = fh_to_ctx(fh);\r\nstruct fimc_frame *frame;\r\nframe = ctx_get_frame(ctx, cr->type);\r\nif (IS_ERR(frame))\r\nreturn PTR_ERR(frame);\r\ncr->c.left = frame->offs_h;\r\ncr->c.top = frame->offs_v;\r\ncr->c.width = frame->width;\r\ncr->c.height = frame->height;\r\nreturn 0;\r\n}\r\nstatic int fimc_m2m_try_crop(struct fimc_ctx *ctx, struct v4l2_crop *cr)\r\n{\r\nstruct fimc_dev *fimc = ctx->fimc_dev;\r\nstruct fimc_frame *f;\r\nu32 min_size, halign, depth = 0;\r\nint i;\r\nif (cr->c.top < 0 || cr->c.left < 0) {\r\nv4l2_err(&fimc->m2m.vfd,\r\n"doesn't support negative values for top & left\n");\r\nreturn -EINVAL;\r\n}\r\nif (cr->type == V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE)\r\nf = &ctx->d_frame;\r\nelse if (cr->type == V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE)\r\nf = &ctx->s_frame;\r\nelse\r\nreturn -EINVAL;\r\nmin_size = (f == &ctx->s_frame) ?\r\nfimc->variant->min_inp_pixsize : fimc->variant->min_out_pixsize;\r\nif (fimc->variant->min_vsize_align == 1)\r\nhalign = fimc_fmt_is_rgb(f->fmt->color) ? 0 : 1;\r\nelse\r\nhalign = ffs(fimc->variant->min_vsize_align) - 1;\r\nfor (i = 0; i < f->fmt->memplanes; i++)\r\ndepth += f->fmt->depth[i];\r\nv4l_bound_align_image(&cr->c.width, min_size, f->o_width,\r\nffs(min_size) - 1,\r\n&cr->c.height, min_size, f->o_height,\r\nhalign, 64/(ALIGN(depth, 8)));\r\nif (cr->c.left + cr->c.width > f->o_width)\r\ncr->c.left = f->o_width - cr->c.width;\r\nif (cr->c.top + cr->c.height > f->o_height)\r\ncr->c.top = f->o_height - cr->c.height;\r\ncr->c.left = round_down(cr->c.left, min_size);\r\ncr->c.top = round_down(cr->c.top, fimc->variant->hor_offs_align);\r\ndbg("l:%d, t:%d, w:%d, h:%d, f_w: %d, f_h: %d",\r\ncr->c.left, cr->c.top, cr->c.width, cr->c.height,\r\nf->f_width, f->f_height);\r\nreturn 0;\r\n}\r\nstatic int fimc_m2m_s_crop(struct file *file, void *fh, const struct v4l2_crop *crop)\r\n{\r\nstruct fimc_ctx *ctx = fh_to_ctx(fh);\r\nstruct fimc_dev *fimc = ctx->fimc_dev;\r\nstruct v4l2_crop cr = *crop;\r\nstruct fimc_frame *f;\r\nint ret;\r\nret = fimc_m2m_try_crop(ctx, &cr);\r\nif (ret)\r\nreturn ret;\r\nf = (cr.type == V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE) ?\r\n&ctx->s_frame : &ctx->d_frame;\r\nif (cr.type == V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE) {\r\nret = fimc_check_scaler_ratio(ctx, cr.c.width,\r\ncr.c.height, ctx->d_frame.width,\r\nctx->d_frame.height, ctx->rotation);\r\n} else {\r\nret = fimc_check_scaler_ratio(ctx, ctx->s_frame.width,\r\nctx->s_frame.height, cr.c.width,\r\ncr.c.height, ctx->rotation);\r\n}\r\nif (ret) {\r\nv4l2_err(&fimc->m2m.vfd, "Out of scaler range\n");\r\nreturn -EINVAL;\r\n}\r\nf->offs_h = cr.c.left;\r\nf->offs_v = cr.c.top;\r\nf->width = cr.c.width;\r\nf->height = cr.c.height;\r\nfimc_ctx_state_set(FIMC_PARAMS, ctx);\r\nreturn 0;\r\n}\r\nstatic int queue_init(void *priv, struct vb2_queue *src_vq,\r\nstruct vb2_queue *dst_vq)\r\n{\r\nstruct fimc_ctx *ctx = priv;\r\nint ret;\r\nsrc_vq->type = V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE;\r\nsrc_vq->io_modes = VB2_MMAP | VB2_USERPTR | VB2_DMABUF;\r\nsrc_vq->drv_priv = ctx;\r\nsrc_vq->ops = &fimc_qops;\r\nsrc_vq->mem_ops = &vb2_dma_contig_memops;\r\nsrc_vq->buf_struct_size = sizeof(struct v4l2_m2m_buffer);\r\nsrc_vq->timestamp_flags = V4L2_BUF_FLAG_TIMESTAMP_COPY;\r\nsrc_vq->lock = &ctx->fimc_dev->lock;\r\nret = vb2_queue_init(src_vq);\r\nif (ret)\r\nreturn ret;\r\ndst_vq->type = V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE;\r\ndst_vq->io_modes = VB2_MMAP | VB2_USERPTR | VB2_DMABUF;\r\ndst_vq->drv_priv = ctx;\r\ndst_vq->ops = &fimc_qops;\r\ndst_vq->mem_ops = &vb2_dma_contig_memops;\r\ndst_vq->buf_struct_size = sizeof(struct v4l2_m2m_buffer);\r\ndst_vq->timestamp_flags = V4L2_BUF_FLAG_TIMESTAMP_COPY;\r\ndst_vq->lock = &ctx->fimc_dev->lock;\r\nreturn vb2_queue_init(dst_vq);\r\n}\r\nstatic int fimc_m2m_set_default_format(struct fimc_ctx *ctx)\r\n{\r\nstruct v4l2_pix_format_mplane pixm = {\r\n.pixelformat = V4L2_PIX_FMT_RGB32,\r\n.width = 800,\r\n.height = 600,\r\n.plane_fmt[0] = {\r\n.bytesperline = 800 * 4,\r\n.sizeimage = 800 * 4 * 600,\r\n},\r\n};\r\nstruct fimc_fmt *fmt;\r\nfmt = fimc_find_format(&pixm.pixelformat, NULL, FMT_FLAGS_M2M, 0);\r\nif (!fmt)\r\nreturn -EINVAL;\r\n__set_frame_format(&ctx->s_frame, fmt, &pixm);\r\n__set_frame_format(&ctx->d_frame, fmt, &pixm);\r\nreturn 0;\r\n}\r\nstatic int fimc_m2m_open(struct file *file)\r\n{\r\nstruct fimc_dev *fimc = video_drvdata(file);\r\nstruct fimc_ctx *ctx;\r\nint ret = -EBUSY;\r\npr_debug("pid: %d, state: %#lx\n", task_pid_nr(current), fimc->state);\r\nif (mutex_lock_interruptible(&fimc->lock))\r\nreturn -ERESTARTSYS;\r\nif (test_bit(ST_CAPT_BUSY, &fimc->state))\r\ngoto unlock;\r\nctx = kzalloc(sizeof(*ctx), GFP_KERNEL);\r\nif (!ctx) {\r\nret = -ENOMEM;\r\ngoto unlock;\r\n}\r\nv4l2_fh_init(&ctx->fh, &fimc->m2m.vfd);\r\nctx->fimc_dev = fimc;\r\nctx->s_frame.fmt = fimc_get_format(0);\r\nctx->d_frame.fmt = fimc_get_format(0);\r\nret = fimc_ctrls_create(ctx);\r\nif (ret)\r\ngoto error_fh;\r\nctx->fh.ctrl_handler = &ctx->ctrls.handler;\r\nfile->private_data = &ctx->fh;\r\nv4l2_fh_add(&ctx->fh);\r\nctx->state = FIMC_CTX_M2M;\r\nctx->flags = 0;\r\nctx->in_path = FIMC_IO_DMA;\r\nctx->out_path = FIMC_IO_DMA;\r\nctx->scaler.enabled = 1;\r\nctx->fh.m2m_ctx = v4l2_m2m_ctx_init(fimc->m2m.m2m_dev, ctx, queue_init);\r\nif (IS_ERR(ctx->fh.m2m_ctx)) {\r\nret = PTR_ERR(ctx->fh.m2m_ctx);\r\ngoto error_c;\r\n}\r\nif (fimc->m2m.refcnt++ == 0)\r\nset_bit(ST_M2M_RUN, &fimc->state);\r\nret = fimc_m2m_set_default_format(ctx);\r\nif (ret < 0)\r\ngoto error_m2m_ctx;\r\nmutex_unlock(&fimc->lock);\r\nreturn 0;\r\nerror_m2m_ctx:\r\nv4l2_m2m_ctx_release(ctx->fh.m2m_ctx);\r\nerror_c:\r\nfimc_ctrls_delete(ctx);\r\nerror_fh:\r\nv4l2_fh_del(&ctx->fh);\r\nv4l2_fh_exit(&ctx->fh);\r\nkfree(ctx);\r\nunlock:\r\nmutex_unlock(&fimc->lock);\r\nreturn ret;\r\n}\r\nstatic int fimc_m2m_release(struct file *file)\r\n{\r\nstruct fimc_ctx *ctx = fh_to_ctx(file->private_data);\r\nstruct fimc_dev *fimc = ctx->fimc_dev;\r\ndbg("pid: %d, state: 0x%lx, refcnt= %d",\r\ntask_pid_nr(current), fimc->state, fimc->m2m.refcnt);\r\nmutex_lock(&fimc->lock);\r\nv4l2_m2m_ctx_release(ctx->fh.m2m_ctx);\r\nfimc_ctrls_delete(ctx);\r\nv4l2_fh_del(&ctx->fh);\r\nv4l2_fh_exit(&ctx->fh);\r\nif (--fimc->m2m.refcnt <= 0)\r\nclear_bit(ST_M2M_RUN, &fimc->state);\r\nkfree(ctx);\r\nmutex_unlock(&fimc->lock);\r\nreturn 0;\r\n}\r\nint fimc_register_m2m_device(struct fimc_dev *fimc,\r\nstruct v4l2_device *v4l2_dev)\r\n{\r\nstruct video_device *vfd = &fimc->m2m.vfd;\r\nint ret;\r\nfimc->v4l2_dev = v4l2_dev;\r\nmemset(vfd, 0, sizeof(*vfd));\r\nvfd->fops = &fimc_m2m_fops;\r\nvfd->ioctl_ops = &fimc_m2m_ioctl_ops;\r\nvfd->v4l2_dev = v4l2_dev;\r\nvfd->minor = -1;\r\nvfd->release = video_device_release_empty;\r\nvfd->lock = &fimc->lock;\r\nvfd->vfl_dir = VFL_DIR_M2M;\r\nsnprintf(vfd->name, sizeof(vfd->name), "fimc.%d.m2m", fimc->id);\r\nvideo_set_drvdata(vfd, fimc);\r\nfimc->m2m.m2m_dev = v4l2_m2m_init(&m2m_ops);\r\nif (IS_ERR(fimc->m2m.m2m_dev)) {\r\nv4l2_err(v4l2_dev, "failed to initialize v4l2-m2m device\n");\r\nreturn PTR_ERR(fimc->m2m.m2m_dev);\r\n}\r\nret = media_entity_pads_init(&vfd->entity, 0, NULL);\r\nif (ret)\r\ngoto err_me;\r\nret = video_register_device(vfd, VFL_TYPE_GRABBER, -1);\r\nif (ret)\r\ngoto err_vd;\r\nv4l2_info(v4l2_dev, "Registered %s as /dev/%s\n",\r\nvfd->name, video_device_node_name(vfd));\r\nreturn 0;\r\nerr_vd:\r\nmedia_entity_cleanup(&vfd->entity);\r\nerr_me:\r\nv4l2_m2m_release(fimc->m2m.m2m_dev);\r\nreturn ret;\r\n}\r\nvoid fimc_unregister_m2m_device(struct fimc_dev *fimc)\r\n{\r\nif (!fimc)\r\nreturn;\r\nif (fimc->m2m.m2m_dev)\r\nv4l2_m2m_release(fimc->m2m.m2m_dev);\r\nif (video_is_registered(&fimc->m2m.vfd)) {\r\nvideo_unregister_device(&fimc->m2m.vfd);\r\nmedia_entity_cleanup(&fimc->m2m.vfd.entity);\r\n}\r\n}
