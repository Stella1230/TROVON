static inline int is_imx27_cspi(struct spi_imx_data *d)\r\n{\r\nreturn d->devtype_data->devtype == IMX27_CSPI;\r\n}\r\nstatic inline int is_imx35_cspi(struct spi_imx_data *d)\r\n{\r\nreturn d->devtype_data->devtype == IMX35_CSPI;\r\n}\r\nstatic inline int is_imx51_ecspi(struct spi_imx_data *d)\r\n{\r\nreturn d->devtype_data->devtype == IMX51_ECSPI;\r\n}\r\nstatic inline unsigned spi_imx_get_fifosize(struct spi_imx_data *d)\r\n{\r\nreturn is_imx51_ecspi(d) ? 64 : 8;\r\n}\r\nstatic unsigned int spi_imx_clkdiv_1(unsigned int fin,\r\nunsigned int fspi, unsigned int max)\r\n{\r\nint i;\r\nfor (i = 2; i < max; i++)\r\nif (fspi * mxc_clkdivs[i] >= fin)\r\nreturn i;\r\nreturn max;\r\n}\r\nstatic unsigned int spi_imx_clkdiv_2(unsigned int fin,\r\nunsigned int fspi)\r\n{\r\nint i, div = 4;\r\nfor (i = 0; i < 7; i++) {\r\nif (fspi * div >= fin)\r\nreturn i;\r\ndiv <<= 1;\r\n}\r\nreturn 7;\r\n}\r\nstatic int spi_imx_bytes_per_word(const int bpw)\r\n{\r\nreturn DIV_ROUND_UP(bpw, BITS_PER_BYTE);\r\n}\r\nstatic bool spi_imx_can_dma(struct spi_master *master, struct spi_device *spi,\r\nstruct spi_transfer *transfer)\r\n{\r\nstruct spi_imx_data *spi_imx = spi_master_get_devdata(master);\r\nunsigned int bpw;\r\nif (!master->dma_rx)\r\nreturn false;\r\nif (!transfer)\r\nreturn false;\r\nbpw = transfer->bits_per_word;\r\nif (!bpw)\r\nbpw = spi->bits_per_word;\r\nbpw = spi_imx_bytes_per_word(bpw);\r\nif (bpw != 1 && bpw != 2 && bpw != 4)\r\nreturn false;\r\nif (transfer->len < spi_imx->wml * bpw)\r\nreturn false;\r\nif (transfer->len % (spi_imx->wml * bpw))\r\nreturn false;\r\nreturn true;\r\n}\r\nstatic unsigned int mx51_ecspi_clkdiv(struct spi_imx_data *spi_imx,\r\nunsigned int fspi, unsigned int *fres)\r\n{\r\nunsigned int pre, post;\r\nunsigned int fin = spi_imx->spi_clk;\r\nif (unlikely(fspi > fin))\r\nreturn 0;\r\npost = fls(fin) - fls(fspi);\r\nif (fin > fspi << post)\r\npost++;\r\npost = max(4U, post) - 4;\r\nif (unlikely(post > 0xf)) {\r\ndev_err(spi_imx->dev, "cannot set clock freq: %u (base freq: %u)\n",\r\nfspi, fin);\r\nreturn 0xff;\r\n}\r\npre = DIV_ROUND_UP(fin, fspi << post) - 1;\r\ndev_dbg(spi_imx->dev, "%s: fin: %u, fspi: %u, post: %u, pre: %u\n",\r\n__func__, fin, fspi, post, pre);\r\n*fres = (fin / (pre + 1)) >> post;\r\nreturn (pre << MX51_ECSPI_CTRL_PREDIV_OFFSET) |\r\n(post << MX51_ECSPI_CTRL_POSTDIV_OFFSET);\r\n}\r\nstatic void __maybe_unused mx51_ecspi_intctrl(struct spi_imx_data *spi_imx, int enable)\r\n{\r\nunsigned val = 0;\r\nif (enable & MXC_INT_TE)\r\nval |= MX51_ECSPI_INT_TEEN;\r\nif (enable & MXC_INT_RR)\r\nval |= MX51_ECSPI_INT_RREN;\r\nwritel(val, spi_imx->base + MX51_ECSPI_INT);\r\n}\r\nstatic void __maybe_unused mx51_ecspi_trigger(struct spi_imx_data *spi_imx)\r\n{\r\nu32 reg;\r\nreg = readl(spi_imx->base + MX51_ECSPI_CTRL);\r\nreg |= MX51_ECSPI_CTRL_XCH;\r\nwritel(reg, spi_imx->base + MX51_ECSPI_CTRL);\r\n}\r\nstatic int __maybe_unused mx51_ecspi_config(struct spi_imx_data *spi_imx,\r\nstruct spi_imx_config *config)\r\n{\r\nu32 ctrl = MX51_ECSPI_CTRL_ENABLE;\r\nu32 clk = config->speed_hz, delay, reg;\r\nu32 cfg = readl(spi_imx->base + MX51_ECSPI_CONFIG);\r\nctrl |= MX51_ECSPI_CTRL_MODE_MASK;\r\nctrl |= mx51_ecspi_clkdiv(spi_imx, config->speed_hz, &clk);\r\nspi_imx->spi_bus_clk = clk;\r\nctrl |= MX51_ECSPI_CTRL_CS(config->cs);\r\nctrl |= (config->bpw - 1) << MX51_ECSPI_CTRL_BL_OFFSET;\r\ncfg |= MX51_ECSPI_CONFIG_SBBCTRL(config->cs);\r\nif (config->mode & SPI_CPHA)\r\ncfg |= MX51_ECSPI_CONFIG_SCLKPHA(config->cs);\r\nelse\r\ncfg &= ~MX51_ECSPI_CONFIG_SCLKPHA(config->cs);\r\nif (config->mode & SPI_CPOL) {\r\ncfg |= MX51_ECSPI_CONFIG_SCLKPOL(config->cs);\r\ncfg |= MX51_ECSPI_CONFIG_SCLKCTL(config->cs);\r\n} else {\r\ncfg &= ~MX51_ECSPI_CONFIG_SCLKPOL(config->cs);\r\ncfg &= ~MX51_ECSPI_CONFIG_SCLKCTL(config->cs);\r\n}\r\nif (config->mode & SPI_CS_HIGH)\r\ncfg |= MX51_ECSPI_CONFIG_SSBPOL(config->cs);\r\nelse\r\ncfg &= ~MX51_ECSPI_CONFIG_SSBPOL(config->cs);\r\nif (spi_imx->usedma)\r\nctrl |= MX51_ECSPI_CTRL_SMC;\r\nwritel(ctrl, spi_imx->base + MX51_ECSPI_CTRL);\r\nreg = readl(spi_imx->base + MX51_ECSPI_TESTREG);\r\nif (config->mode & SPI_LOOP)\r\nreg |= MX51_ECSPI_TESTREG_LBC;\r\nelse\r\nreg &= ~MX51_ECSPI_TESTREG_LBC;\r\nwritel(reg, spi_imx->base + MX51_ECSPI_TESTREG);\r\nwritel(cfg, spi_imx->base + MX51_ECSPI_CONFIG);\r\ndelay = (2 * 1000000) / clk;\r\nif (likely(delay < 10))\r\nudelay(delay);\r\nelse\r\nusleep_range(delay, delay + 10);\r\nwritel(MX51_ECSPI_DMA_RX_WML(spi_imx->wml) |\r\nMX51_ECSPI_DMA_TX_WML(spi_imx->wml) |\r\nMX51_ECSPI_DMA_RXT_WML(spi_imx->wml) |\r\nMX51_ECSPI_DMA_TEDEN | MX51_ECSPI_DMA_RXDEN |\r\nMX51_ECSPI_DMA_RXTDEN, spi_imx->base + MX51_ECSPI_DMA);\r\nreturn 0;\r\n}\r\nstatic int __maybe_unused mx51_ecspi_rx_available(struct spi_imx_data *spi_imx)\r\n{\r\nreturn readl(spi_imx->base + MX51_ECSPI_STAT) & MX51_ECSPI_STAT_RR;\r\n}\r\nstatic void __maybe_unused mx51_ecspi_reset(struct spi_imx_data *spi_imx)\r\n{\r\nwhile (mx51_ecspi_rx_available(spi_imx))\r\nreadl(spi_imx->base + MXC_CSPIRXDATA);\r\n}\r\nstatic void __maybe_unused mx31_intctrl(struct spi_imx_data *spi_imx, int enable)\r\n{\r\nunsigned int val = 0;\r\nif (enable & MXC_INT_TE)\r\nval |= MX31_INTREG_TEEN;\r\nif (enable & MXC_INT_RR)\r\nval |= MX31_INTREG_RREN;\r\nwritel(val, spi_imx->base + MXC_CSPIINT);\r\n}\r\nstatic void __maybe_unused mx31_trigger(struct spi_imx_data *spi_imx)\r\n{\r\nunsigned int reg;\r\nreg = readl(spi_imx->base + MXC_CSPICTRL);\r\nreg |= MX31_CSPICTRL_XCH;\r\nwritel(reg, spi_imx->base + MXC_CSPICTRL);\r\n}\r\nstatic int __maybe_unused mx31_config(struct spi_imx_data *spi_imx,\r\nstruct spi_imx_config *config)\r\n{\r\nunsigned int reg = MX31_CSPICTRL_ENABLE | MX31_CSPICTRL_MASTER;\r\nint cs = spi_imx->chipselect[config->cs];\r\nreg |= spi_imx_clkdiv_2(spi_imx->spi_clk, config->speed_hz) <<\r\nMX31_CSPICTRL_DR_SHIFT;\r\nif (is_imx35_cspi(spi_imx)) {\r\nreg |= (config->bpw - 1) << MX35_CSPICTRL_BL_SHIFT;\r\nreg |= MX31_CSPICTRL_SSCTL;\r\n} else {\r\nreg |= (config->bpw - 1) << MX31_CSPICTRL_BC_SHIFT;\r\n}\r\nif (config->mode & SPI_CPHA)\r\nreg |= MX31_CSPICTRL_PHA;\r\nif (config->mode & SPI_CPOL)\r\nreg |= MX31_CSPICTRL_POL;\r\nif (config->mode & SPI_CS_HIGH)\r\nreg |= MX31_CSPICTRL_SSPOL;\r\nif (cs < 0)\r\nreg |= (cs + 32) <<\r\n(is_imx35_cspi(spi_imx) ? MX35_CSPICTRL_CS_SHIFT :\r\nMX31_CSPICTRL_CS_SHIFT);\r\nwritel(reg, spi_imx->base + MXC_CSPICTRL);\r\nreturn 0;\r\n}\r\nstatic int __maybe_unused mx31_rx_available(struct spi_imx_data *spi_imx)\r\n{\r\nreturn readl(spi_imx->base + MX31_CSPISTATUS) & MX31_STATUS_RR;\r\n}\r\nstatic void __maybe_unused mx31_reset(struct spi_imx_data *spi_imx)\r\n{\r\nwhile (readl(spi_imx->base + MX31_CSPISTATUS) & MX31_STATUS_RR)\r\nreadl(spi_imx->base + MXC_CSPIRXDATA);\r\n}\r\nstatic void __maybe_unused mx21_intctrl(struct spi_imx_data *spi_imx, int enable)\r\n{\r\nunsigned int val = 0;\r\nif (enable & MXC_INT_TE)\r\nval |= MX21_INTREG_TEEN;\r\nif (enable & MXC_INT_RR)\r\nval |= MX21_INTREG_RREN;\r\nwritel(val, spi_imx->base + MXC_CSPIINT);\r\n}\r\nstatic void __maybe_unused mx21_trigger(struct spi_imx_data *spi_imx)\r\n{\r\nunsigned int reg;\r\nreg = readl(spi_imx->base + MXC_CSPICTRL);\r\nreg |= MX21_CSPICTRL_XCH;\r\nwritel(reg, spi_imx->base + MXC_CSPICTRL);\r\n}\r\nstatic int __maybe_unused mx21_config(struct spi_imx_data *spi_imx,\r\nstruct spi_imx_config *config)\r\n{\r\nunsigned int reg = MX21_CSPICTRL_ENABLE | MX21_CSPICTRL_MASTER;\r\nint cs = spi_imx->chipselect[config->cs];\r\nunsigned int max = is_imx27_cspi(spi_imx) ? 16 : 18;\r\nreg |= spi_imx_clkdiv_1(spi_imx->spi_clk, config->speed_hz, max) <<\r\nMX21_CSPICTRL_DR_SHIFT;\r\nreg |= config->bpw - 1;\r\nif (config->mode & SPI_CPHA)\r\nreg |= MX21_CSPICTRL_PHA;\r\nif (config->mode & SPI_CPOL)\r\nreg |= MX21_CSPICTRL_POL;\r\nif (config->mode & SPI_CS_HIGH)\r\nreg |= MX21_CSPICTRL_SSPOL;\r\nif (cs < 0)\r\nreg |= (cs + 32) << MX21_CSPICTRL_CS_SHIFT;\r\nwritel(reg, spi_imx->base + MXC_CSPICTRL);\r\nreturn 0;\r\n}\r\nstatic int __maybe_unused mx21_rx_available(struct spi_imx_data *spi_imx)\r\n{\r\nreturn readl(spi_imx->base + MXC_CSPIINT) & MX21_INTREG_RR;\r\n}\r\nstatic void __maybe_unused mx21_reset(struct spi_imx_data *spi_imx)\r\n{\r\nwritel(1, spi_imx->base + MXC_RESET);\r\n}\r\nstatic void __maybe_unused mx1_intctrl(struct spi_imx_data *spi_imx, int enable)\r\n{\r\nunsigned int val = 0;\r\nif (enable & MXC_INT_TE)\r\nval |= MX1_INTREG_TEEN;\r\nif (enable & MXC_INT_RR)\r\nval |= MX1_INTREG_RREN;\r\nwritel(val, spi_imx->base + MXC_CSPIINT);\r\n}\r\nstatic void __maybe_unused mx1_trigger(struct spi_imx_data *spi_imx)\r\n{\r\nunsigned int reg;\r\nreg = readl(spi_imx->base + MXC_CSPICTRL);\r\nreg |= MX1_CSPICTRL_XCH;\r\nwritel(reg, spi_imx->base + MXC_CSPICTRL);\r\n}\r\nstatic int __maybe_unused mx1_config(struct spi_imx_data *spi_imx,\r\nstruct spi_imx_config *config)\r\n{\r\nunsigned int reg = MX1_CSPICTRL_ENABLE | MX1_CSPICTRL_MASTER;\r\nreg |= spi_imx_clkdiv_2(spi_imx->spi_clk, config->speed_hz) <<\r\nMX1_CSPICTRL_DR_SHIFT;\r\nreg |= config->bpw - 1;\r\nif (config->mode & SPI_CPHA)\r\nreg |= MX1_CSPICTRL_PHA;\r\nif (config->mode & SPI_CPOL)\r\nreg |= MX1_CSPICTRL_POL;\r\nwritel(reg, spi_imx->base + MXC_CSPICTRL);\r\nreturn 0;\r\n}\r\nstatic int __maybe_unused mx1_rx_available(struct spi_imx_data *spi_imx)\r\n{\r\nreturn readl(spi_imx->base + MXC_CSPIINT) & MX1_INTREG_RR;\r\n}\r\nstatic void __maybe_unused mx1_reset(struct spi_imx_data *spi_imx)\r\n{\r\nwritel(1, spi_imx->base + MXC_RESET);\r\n}\r\nstatic void spi_imx_chipselect(struct spi_device *spi, int is_active)\r\n{\r\nstruct spi_imx_data *spi_imx = spi_master_get_devdata(spi->master);\r\nint gpio = spi_imx->chipselect[spi->chip_select];\r\nint active = is_active != BITBANG_CS_INACTIVE;\r\nint dev_is_lowactive = !(spi->mode & SPI_CS_HIGH);\r\nif (!gpio_is_valid(gpio))\r\nreturn;\r\ngpio_set_value(gpio, dev_is_lowactive ^ active);\r\n}\r\nstatic void spi_imx_push(struct spi_imx_data *spi_imx)\r\n{\r\nwhile (spi_imx->txfifo < spi_imx_get_fifosize(spi_imx)) {\r\nif (!spi_imx->count)\r\nbreak;\r\nspi_imx->tx(spi_imx);\r\nspi_imx->txfifo++;\r\n}\r\nspi_imx->devtype_data->trigger(spi_imx);\r\n}\r\nstatic irqreturn_t spi_imx_isr(int irq, void *dev_id)\r\n{\r\nstruct spi_imx_data *spi_imx = dev_id;\r\nwhile (spi_imx->devtype_data->rx_available(spi_imx)) {\r\nspi_imx->rx(spi_imx);\r\nspi_imx->txfifo--;\r\n}\r\nif (spi_imx->count) {\r\nspi_imx_push(spi_imx);\r\nreturn IRQ_HANDLED;\r\n}\r\nif (spi_imx->txfifo) {\r\nspi_imx->devtype_data->intctrl(\r\nspi_imx, MXC_INT_RR);\r\nreturn IRQ_HANDLED;\r\n}\r\nspi_imx->devtype_data->intctrl(spi_imx, 0);\r\ncomplete(&spi_imx->xfer_done);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int spi_imx_dma_configure(struct spi_master *master,\r\nint bytes_per_word)\r\n{\r\nint ret;\r\nenum dma_slave_buswidth buswidth;\r\nstruct dma_slave_config rx = {}, tx = {};\r\nstruct spi_imx_data *spi_imx = spi_master_get_devdata(master);\r\nif (bytes_per_word == spi_imx->bytes_per_word)\r\nreturn 0;\r\nswitch (bytes_per_word) {\r\ncase 4:\r\nbuswidth = DMA_SLAVE_BUSWIDTH_4_BYTES;\r\nbreak;\r\ncase 2:\r\nbuswidth = DMA_SLAVE_BUSWIDTH_2_BYTES;\r\nbreak;\r\ncase 1:\r\nbuswidth = DMA_SLAVE_BUSWIDTH_1_BYTE;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\ntx.direction = DMA_MEM_TO_DEV;\r\ntx.dst_addr = spi_imx->base_phys + MXC_CSPITXDATA;\r\ntx.dst_addr_width = buswidth;\r\ntx.dst_maxburst = spi_imx->wml;\r\nret = dmaengine_slave_config(master->dma_tx, &tx);\r\nif (ret) {\r\ndev_err(spi_imx->dev, "TX dma configuration failed with %d\n", ret);\r\nreturn ret;\r\n}\r\nrx.direction = DMA_DEV_TO_MEM;\r\nrx.src_addr = spi_imx->base_phys + MXC_CSPIRXDATA;\r\nrx.src_addr_width = buswidth;\r\nrx.src_maxburst = spi_imx->wml;\r\nret = dmaengine_slave_config(master->dma_rx, &rx);\r\nif (ret) {\r\ndev_err(spi_imx->dev, "RX dma configuration failed with %d\n", ret);\r\nreturn ret;\r\n}\r\nspi_imx->bytes_per_word = bytes_per_word;\r\nreturn 0;\r\n}\r\nstatic int spi_imx_setupxfer(struct spi_device *spi,\r\nstruct spi_transfer *t)\r\n{\r\nstruct spi_imx_data *spi_imx = spi_master_get_devdata(spi->master);\r\nstruct spi_imx_config config;\r\nint ret;\r\nconfig.bpw = t ? t->bits_per_word : spi->bits_per_word;\r\nconfig.speed_hz = t ? t->speed_hz : spi->max_speed_hz;\r\nconfig.mode = spi->mode;\r\nconfig.cs = spi->chip_select;\r\nif (!config.speed_hz)\r\nconfig.speed_hz = spi->max_speed_hz;\r\nif (!config.bpw)\r\nconfig.bpw = spi->bits_per_word;\r\nif (config.bpw <= 8) {\r\nspi_imx->rx = spi_imx_buf_rx_u8;\r\nspi_imx->tx = spi_imx_buf_tx_u8;\r\n} else if (config.bpw <= 16) {\r\nspi_imx->rx = spi_imx_buf_rx_u16;\r\nspi_imx->tx = spi_imx_buf_tx_u16;\r\n} else {\r\nspi_imx->rx = spi_imx_buf_rx_u32;\r\nspi_imx->tx = spi_imx_buf_tx_u32;\r\n}\r\nif (spi_imx_can_dma(spi_imx->bitbang.master, spi, t))\r\nspi_imx->usedma = 1;\r\nelse\r\nspi_imx->usedma = 0;\r\nif (spi_imx->usedma) {\r\nret = spi_imx_dma_configure(spi->master,\r\nspi_imx_bytes_per_word(config.bpw));\r\nif (ret)\r\nreturn ret;\r\n}\r\nspi_imx->devtype_data->config(spi_imx, &config);\r\nreturn 0;\r\n}\r\nstatic void spi_imx_sdma_exit(struct spi_imx_data *spi_imx)\r\n{\r\nstruct spi_master *master = spi_imx->bitbang.master;\r\nif (master->dma_rx) {\r\ndma_release_channel(master->dma_rx);\r\nmaster->dma_rx = NULL;\r\n}\r\nif (master->dma_tx) {\r\ndma_release_channel(master->dma_tx);\r\nmaster->dma_tx = NULL;\r\n}\r\n}\r\nstatic int spi_imx_sdma_init(struct device *dev, struct spi_imx_data *spi_imx,\r\nstruct spi_master *master)\r\n{\r\nint ret;\r\nif (of_machine_is_compatible("fsl,imx6dl"))\r\nreturn 0;\r\nspi_imx->wml = spi_imx_get_fifosize(spi_imx) / 2;\r\nmaster->dma_tx = dma_request_slave_channel_reason(dev, "tx");\r\nif (IS_ERR(master->dma_tx)) {\r\nret = PTR_ERR(master->dma_tx);\r\ndev_dbg(dev, "can't get the TX DMA channel, error %d!\n", ret);\r\nmaster->dma_tx = NULL;\r\ngoto err;\r\n}\r\nmaster->dma_rx = dma_request_slave_channel_reason(dev, "rx");\r\nif (IS_ERR(master->dma_rx)) {\r\nret = PTR_ERR(master->dma_rx);\r\ndev_dbg(dev, "can't get the RX DMA channel, error %d\n", ret);\r\nmaster->dma_rx = NULL;\r\ngoto err;\r\n}\r\nspi_imx_dma_configure(master, 1);\r\ninit_completion(&spi_imx->dma_rx_completion);\r\ninit_completion(&spi_imx->dma_tx_completion);\r\nmaster->can_dma = spi_imx_can_dma;\r\nmaster->max_dma_len = MAX_SDMA_BD_BYTES;\r\nspi_imx->bitbang.master->flags = SPI_MASTER_MUST_RX |\r\nSPI_MASTER_MUST_TX;\r\nreturn 0;\r\nerr:\r\nspi_imx_sdma_exit(spi_imx);\r\nreturn ret;\r\n}\r\nstatic void spi_imx_dma_rx_callback(void *cookie)\r\n{\r\nstruct spi_imx_data *spi_imx = (struct spi_imx_data *)cookie;\r\ncomplete(&spi_imx->dma_rx_completion);\r\n}\r\nstatic void spi_imx_dma_tx_callback(void *cookie)\r\n{\r\nstruct spi_imx_data *spi_imx = (struct spi_imx_data *)cookie;\r\ncomplete(&spi_imx->dma_tx_completion);\r\n}\r\nstatic int spi_imx_calculate_timeout(struct spi_imx_data *spi_imx, int size)\r\n{\r\nunsigned long timeout = 0;\r\ntimeout = (8 + 4) * size / spi_imx->spi_bus_clk;\r\ntimeout += 1;\r\nreturn msecs_to_jiffies(2 * timeout * MSEC_PER_SEC);\r\n}\r\nstatic int spi_imx_dma_transfer(struct spi_imx_data *spi_imx,\r\nstruct spi_transfer *transfer)\r\n{\r\nstruct dma_async_tx_descriptor *desc_tx, *desc_rx;\r\nunsigned long transfer_timeout;\r\nunsigned long timeout;\r\nstruct spi_master *master = spi_imx->bitbang.master;\r\nstruct sg_table *tx = &transfer->tx_sg, *rx = &transfer->rx_sg;\r\ndesc_rx = dmaengine_prep_slave_sg(master->dma_rx,\r\nrx->sgl, rx->nents, DMA_DEV_TO_MEM,\r\nDMA_PREP_INTERRUPT | DMA_CTRL_ACK);\r\nif (!desc_rx)\r\nreturn -EINVAL;\r\ndesc_rx->callback = spi_imx_dma_rx_callback;\r\ndesc_rx->callback_param = (void *)spi_imx;\r\ndmaengine_submit(desc_rx);\r\nreinit_completion(&spi_imx->dma_rx_completion);\r\ndma_async_issue_pending(master->dma_rx);\r\ndesc_tx = dmaengine_prep_slave_sg(master->dma_tx,\r\ntx->sgl, tx->nents, DMA_MEM_TO_DEV,\r\nDMA_PREP_INTERRUPT | DMA_CTRL_ACK);\r\nif (!desc_tx) {\r\ndmaengine_terminate_all(master->dma_tx);\r\nreturn -EINVAL;\r\n}\r\ndesc_tx->callback = spi_imx_dma_tx_callback;\r\ndesc_tx->callback_param = (void *)spi_imx;\r\ndmaengine_submit(desc_tx);\r\nreinit_completion(&spi_imx->dma_tx_completion);\r\ndma_async_issue_pending(master->dma_tx);\r\ntransfer_timeout = spi_imx_calculate_timeout(spi_imx, transfer->len);\r\ntimeout = wait_for_completion_timeout(&spi_imx->dma_tx_completion,\r\ntransfer_timeout);\r\nif (!timeout) {\r\ndev_err(spi_imx->dev, "I/O Error in DMA TX\n");\r\ndmaengine_terminate_all(master->dma_tx);\r\ndmaengine_terminate_all(master->dma_rx);\r\nreturn -ETIMEDOUT;\r\n}\r\ntimeout = wait_for_completion_timeout(&spi_imx->dma_rx_completion,\r\ntransfer_timeout);\r\nif (!timeout) {\r\ndev_err(&master->dev, "I/O Error in DMA RX\n");\r\nspi_imx->devtype_data->reset(spi_imx);\r\ndmaengine_terminate_all(master->dma_rx);\r\nreturn -ETIMEDOUT;\r\n}\r\nreturn transfer->len;\r\n}\r\nstatic int spi_imx_pio_transfer(struct spi_device *spi,\r\nstruct spi_transfer *transfer)\r\n{\r\nstruct spi_imx_data *spi_imx = spi_master_get_devdata(spi->master);\r\nspi_imx->tx_buf = transfer->tx_buf;\r\nspi_imx->rx_buf = transfer->rx_buf;\r\nspi_imx->count = transfer->len;\r\nspi_imx->txfifo = 0;\r\nreinit_completion(&spi_imx->xfer_done);\r\nspi_imx_push(spi_imx);\r\nspi_imx->devtype_data->intctrl(spi_imx, MXC_INT_TE);\r\nwait_for_completion(&spi_imx->xfer_done);\r\nreturn transfer->len;\r\n}\r\nstatic int spi_imx_transfer(struct spi_device *spi,\r\nstruct spi_transfer *transfer)\r\n{\r\nstruct spi_imx_data *spi_imx = spi_master_get_devdata(spi->master);\r\nif (spi_imx->usedma)\r\nreturn spi_imx_dma_transfer(spi_imx, transfer);\r\nelse\r\nreturn spi_imx_pio_transfer(spi, transfer);\r\n}\r\nstatic int spi_imx_setup(struct spi_device *spi)\r\n{\r\nstruct spi_imx_data *spi_imx = spi_master_get_devdata(spi->master);\r\nint gpio = spi_imx->chipselect[spi->chip_select];\r\ndev_dbg(&spi->dev, "%s: mode %d, %u bpw, %d hz\n", __func__,\r\nspi->mode, spi->bits_per_word, spi->max_speed_hz);\r\nif (gpio_is_valid(gpio))\r\ngpio_direction_output(gpio, spi->mode & SPI_CS_HIGH ? 0 : 1);\r\nspi_imx_chipselect(spi, BITBANG_CS_INACTIVE);\r\nreturn 0;\r\n}\r\nstatic void spi_imx_cleanup(struct spi_device *spi)\r\n{\r\n}\r\nstatic int\r\nspi_imx_prepare_message(struct spi_master *master, struct spi_message *msg)\r\n{\r\nstruct spi_imx_data *spi_imx = spi_master_get_devdata(master);\r\nint ret;\r\nret = clk_enable(spi_imx->clk_per);\r\nif (ret)\r\nreturn ret;\r\nret = clk_enable(spi_imx->clk_ipg);\r\nif (ret) {\r\nclk_disable(spi_imx->clk_per);\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic int\r\nspi_imx_unprepare_message(struct spi_master *master, struct spi_message *msg)\r\n{\r\nstruct spi_imx_data *spi_imx = spi_master_get_devdata(master);\r\nclk_disable(spi_imx->clk_ipg);\r\nclk_disable(spi_imx->clk_per);\r\nreturn 0;\r\n}\r\nstatic int spi_imx_probe(struct platform_device *pdev)\r\n{\r\nstruct device_node *np = pdev->dev.of_node;\r\nconst struct of_device_id *of_id =\r\nof_match_device(spi_imx_dt_ids, &pdev->dev);\r\nstruct spi_imx_master *mxc_platform_info =\r\ndev_get_platdata(&pdev->dev);\r\nstruct spi_master *master;\r\nstruct spi_imx_data *spi_imx;\r\nstruct resource *res;\r\nint i, ret, num_cs, irq;\r\nif (!np && !mxc_platform_info) {\r\ndev_err(&pdev->dev, "can't get the platform data\n");\r\nreturn -EINVAL;\r\n}\r\nret = of_property_read_u32(np, "fsl,spi-num-chipselects", &num_cs);\r\nif (ret < 0) {\r\nif (mxc_platform_info)\r\nnum_cs = mxc_platform_info->num_chipselect;\r\nelse\r\nreturn ret;\r\n}\r\nmaster = spi_alloc_master(&pdev->dev,\r\nsizeof(struct spi_imx_data) + sizeof(int) * num_cs);\r\nif (!master)\r\nreturn -ENOMEM;\r\nplatform_set_drvdata(pdev, master);\r\nmaster->bits_per_word_mask = SPI_BPW_RANGE_MASK(1, 32);\r\nmaster->bus_num = pdev->id;\r\nmaster->num_chipselect = num_cs;\r\nspi_imx = spi_master_get_devdata(master);\r\nspi_imx->bitbang.master = master;\r\nspi_imx->dev = &pdev->dev;\r\nspi_imx->devtype_data = of_id ? of_id->data :\r\n(struct spi_imx_devtype_data *)pdev->id_entry->driver_data;\r\nfor (i = 0; i < master->num_chipselect; i++) {\r\nint cs_gpio = of_get_named_gpio(np, "cs-gpios", i);\r\nif (!gpio_is_valid(cs_gpio) && mxc_platform_info)\r\ncs_gpio = mxc_platform_info->chipselect[i];\r\nspi_imx->chipselect[i] = cs_gpio;\r\nif (!gpio_is_valid(cs_gpio))\r\ncontinue;\r\nret = devm_gpio_request(&pdev->dev, spi_imx->chipselect[i],\r\nDRIVER_NAME);\r\nif (ret) {\r\ndev_err(&pdev->dev, "can't get cs gpios\n");\r\ngoto out_master_put;\r\n}\r\n}\r\nspi_imx->bitbang.chipselect = spi_imx_chipselect;\r\nspi_imx->bitbang.setup_transfer = spi_imx_setupxfer;\r\nspi_imx->bitbang.txrx_bufs = spi_imx_transfer;\r\nspi_imx->bitbang.master->setup = spi_imx_setup;\r\nspi_imx->bitbang.master->cleanup = spi_imx_cleanup;\r\nspi_imx->bitbang.master->prepare_message = spi_imx_prepare_message;\r\nspi_imx->bitbang.master->unprepare_message = spi_imx_unprepare_message;\r\nspi_imx->bitbang.master->mode_bits = SPI_CPOL | SPI_CPHA | SPI_CS_HIGH;\r\nif (is_imx51_ecspi(spi_imx))\r\nspi_imx->bitbang.master->mode_bits |= SPI_LOOP;\r\ninit_completion(&spi_imx->xfer_done);\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nspi_imx->base = devm_ioremap_resource(&pdev->dev, res);\r\nif (IS_ERR(spi_imx->base)) {\r\nret = PTR_ERR(spi_imx->base);\r\ngoto out_master_put;\r\n}\r\nspi_imx->base_phys = res->start;\r\nirq = platform_get_irq(pdev, 0);\r\nif (irq < 0) {\r\nret = irq;\r\ngoto out_master_put;\r\n}\r\nret = devm_request_irq(&pdev->dev, irq, spi_imx_isr, 0,\r\ndev_name(&pdev->dev), spi_imx);\r\nif (ret) {\r\ndev_err(&pdev->dev, "can't get irq%d: %d\n", irq, ret);\r\ngoto out_master_put;\r\n}\r\nspi_imx->clk_ipg = devm_clk_get(&pdev->dev, "ipg");\r\nif (IS_ERR(spi_imx->clk_ipg)) {\r\nret = PTR_ERR(spi_imx->clk_ipg);\r\ngoto out_master_put;\r\n}\r\nspi_imx->clk_per = devm_clk_get(&pdev->dev, "per");\r\nif (IS_ERR(spi_imx->clk_per)) {\r\nret = PTR_ERR(spi_imx->clk_per);\r\ngoto out_master_put;\r\n}\r\nret = clk_prepare_enable(spi_imx->clk_per);\r\nif (ret)\r\ngoto out_master_put;\r\nret = clk_prepare_enable(spi_imx->clk_ipg);\r\nif (ret)\r\ngoto out_put_per;\r\nspi_imx->spi_clk = clk_get_rate(spi_imx->clk_per);\r\nif (is_imx51_ecspi(spi_imx)) {\r\nret = spi_imx_sdma_init(&pdev->dev, spi_imx, master);\r\nif (ret == -EPROBE_DEFER)\r\ngoto out_clk_put;\r\nif (ret < 0)\r\ndev_err(&pdev->dev, "dma setup error %d, use pio\n",\r\nret);\r\n}\r\nspi_imx->devtype_data->reset(spi_imx);\r\nspi_imx->devtype_data->intctrl(spi_imx, 0);\r\nmaster->dev.of_node = pdev->dev.of_node;\r\nret = spi_bitbang_start(&spi_imx->bitbang);\r\nif (ret) {\r\ndev_err(&pdev->dev, "bitbang start failed with %d\n", ret);\r\ngoto out_clk_put;\r\n}\r\ndev_info(&pdev->dev, "probed\n");\r\nclk_disable(spi_imx->clk_ipg);\r\nclk_disable(spi_imx->clk_per);\r\nreturn ret;\r\nout_clk_put:\r\nclk_disable_unprepare(spi_imx->clk_ipg);\r\nout_put_per:\r\nclk_disable_unprepare(spi_imx->clk_per);\r\nout_master_put:\r\nspi_master_put(master);\r\nreturn ret;\r\n}\r\nstatic int spi_imx_remove(struct platform_device *pdev)\r\n{\r\nstruct spi_master *master = platform_get_drvdata(pdev);\r\nstruct spi_imx_data *spi_imx = spi_master_get_devdata(master);\r\nspi_bitbang_stop(&spi_imx->bitbang);\r\nwritel(0, spi_imx->base + MXC_CSPICTRL);\r\nclk_unprepare(spi_imx->clk_ipg);\r\nclk_unprepare(spi_imx->clk_per);\r\nspi_imx_sdma_exit(spi_imx);\r\nspi_master_put(master);\r\nreturn 0;\r\n}
