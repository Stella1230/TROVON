int pci_add_dynid(struct pci_driver *drv,\r\nunsigned int vendor, unsigned int device,\r\nunsigned int subvendor, unsigned int subdevice,\r\nunsigned int class, unsigned int class_mask,\r\nunsigned long driver_data)\r\n{\r\nstruct pci_dynid *dynid;\r\ndynid = kzalloc(sizeof(*dynid), GFP_KERNEL);\r\nif (!dynid)\r\nreturn -ENOMEM;\r\ndynid->id.vendor = vendor;\r\ndynid->id.device = device;\r\ndynid->id.subvendor = subvendor;\r\ndynid->id.subdevice = subdevice;\r\ndynid->id.class = class;\r\ndynid->id.class_mask = class_mask;\r\ndynid->id.driver_data = driver_data;\r\nspin_lock(&drv->dynids.lock);\r\nlist_add_tail(&dynid->node, &drv->dynids.list);\r\nspin_unlock(&drv->dynids.lock);\r\nreturn driver_attach(&drv->driver);\r\n}\r\nstatic void pci_free_dynids(struct pci_driver *drv)\r\n{\r\nstruct pci_dynid *dynid, *n;\r\nspin_lock(&drv->dynids.lock);\r\nlist_for_each_entry_safe(dynid, n, &drv->dynids.list, node) {\r\nlist_del(&dynid->node);\r\nkfree(dynid);\r\n}\r\nspin_unlock(&drv->dynids.lock);\r\n}\r\nstatic ssize_t store_new_id(struct device_driver *driver, const char *buf,\r\nsize_t count)\r\n{\r\nstruct pci_driver *pdrv = to_pci_driver(driver);\r\nconst struct pci_device_id *ids = pdrv->id_table;\r\n__u32 vendor, device, subvendor = PCI_ANY_ID,\r\nsubdevice = PCI_ANY_ID, class = 0, class_mask = 0;\r\nunsigned long driver_data = 0;\r\nint fields = 0;\r\nint retval = 0;\r\nfields = sscanf(buf, "%x %x %x %x %x %x %lx",\r\n&vendor, &device, &subvendor, &subdevice,\r\n&class, &class_mask, &driver_data);\r\nif (fields < 2)\r\nreturn -EINVAL;\r\nif (fields != 7) {\r\nstruct pci_dev *pdev = kzalloc(sizeof(*pdev), GFP_KERNEL);\r\nif (!pdev)\r\nreturn -ENOMEM;\r\npdev->vendor = vendor;\r\npdev->device = device;\r\npdev->subsystem_vendor = subvendor;\r\npdev->subsystem_device = subdevice;\r\npdev->class = class;\r\nif (pci_match_id(pdrv->id_table, pdev))\r\nretval = -EEXIST;\r\nkfree(pdev);\r\nif (retval)\r\nreturn retval;\r\n}\r\nif (ids) {\r\nretval = -EINVAL;\r\nwhile (ids->vendor || ids->subvendor || ids->class_mask) {\r\nif (driver_data == ids->driver_data) {\r\nretval = 0;\r\nbreak;\r\n}\r\nids++;\r\n}\r\nif (retval)\r\nreturn retval;\r\n}\r\nretval = pci_add_dynid(pdrv, vendor, device, subvendor, subdevice,\r\nclass, class_mask, driver_data);\r\nif (retval)\r\nreturn retval;\r\nreturn count;\r\n}\r\nstatic ssize_t store_remove_id(struct device_driver *driver, const char *buf,\r\nsize_t count)\r\n{\r\nstruct pci_dynid *dynid, *n;\r\nstruct pci_driver *pdrv = to_pci_driver(driver);\r\n__u32 vendor, device, subvendor = PCI_ANY_ID,\r\nsubdevice = PCI_ANY_ID, class = 0, class_mask = 0;\r\nint fields = 0;\r\nsize_t retval = -ENODEV;\r\nfields = sscanf(buf, "%x %x %x %x %x %x",\r\n&vendor, &device, &subvendor, &subdevice,\r\n&class, &class_mask);\r\nif (fields < 2)\r\nreturn -EINVAL;\r\nspin_lock(&pdrv->dynids.lock);\r\nlist_for_each_entry_safe(dynid, n, &pdrv->dynids.list, node) {\r\nstruct pci_device_id *id = &dynid->id;\r\nif ((id->vendor == vendor) &&\r\n(id->device == device) &&\r\n(subvendor == PCI_ANY_ID || id->subvendor == subvendor) &&\r\n(subdevice == PCI_ANY_ID || id->subdevice == subdevice) &&\r\n!((id->class ^ class) & class_mask)) {\r\nlist_del(&dynid->node);\r\nkfree(dynid);\r\nretval = count;\r\nbreak;\r\n}\r\n}\r\nspin_unlock(&pdrv->dynids.lock);\r\nreturn retval;\r\n}\r\nconst struct pci_device_id *pci_match_id(const struct pci_device_id *ids,\r\nstruct pci_dev *dev)\r\n{\r\nif (ids) {\r\nwhile (ids->vendor || ids->subvendor || ids->class_mask) {\r\nif (pci_match_one_device(ids, dev))\r\nreturn ids;\r\nids++;\r\n}\r\n}\r\nreturn NULL;\r\n}\r\nstatic const struct pci_device_id *pci_match_device(struct pci_driver *drv,\r\nstruct pci_dev *dev)\r\n{\r\nstruct pci_dynid *dynid;\r\nconst struct pci_device_id *found_id = NULL;\r\nif (dev->driver_override && strcmp(dev->driver_override, drv->name))\r\nreturn NULL;\r\nspin_lock(&drv->dynids.lock);\r\nlist_for_each_entry(dynid, &drv->dynids.list, node) {\r\nif (pci_match_one_device(&dynid->id, dev)) {\r\nfound_id = &dynid->id;\r\nbreak;\r\n}\r\n}\r\nspin_unlock(&drv->dynids.lock);\r\nif (!found_id)\r\nfound_id = pci_match_id(drv->id_table, dev);\r\nif (!found_id && dev->driver_override)\r\nfound_id = &pci_device_id_any;\r\nreturn found_id;\r\n}\r\nstatic long local_pci_probe(void *_ddi)\r\n{\r\nstruct drv_dev_and_id *ddi = _ddi;\r\nstruct pci_dev *pci_dev = ddi->dev;\r\nstruct pci_driver *pci_drv = ddi->drv;\r\nstruct device *dev = &pci_dev->dev;\r\nint rc;\r\npm_runtime_get_sync(dev);\r\npci_dev->driver = pci_drv;\r\nrc = pci_drv->probe(pci_dev, ddi->id);\r\nif (!rc)\r\nreturn rc;\r\nif (rc < 0) {\r\npci_dev->driver = NULL;\r\npm_runtime_put_sync(dev);\r\nreturn rc;\r\n}\r\ndev_warn(dev, "Driver probe function unexpectedly returned %d\n", rc);\r\nreturn 0;\r\n}\r\nstatic int pci_call_probe(struct pci_driver *drv, struct pci_dev *dev,\r\nconst struct pci_device_id *id)\r\n{\r\nint error, node;\r\nstruct drv_dev_and_id ddi = { drv, dev, id };\r\nnode = dev_to_node(&dev->dev);\r\nif (node >= 0 && node != numa_node_id()) {\r\nint cpu;\r\nget_online_cpus();\r\ncpu = cpumask_any_and(cpumask_of_node(node), cpu_online_mask);\r\nif (cpu < nr_cpu_ids)\r\nerror = work_on_cpu(cpu, local_pci_probe, &ddi);\r\nelse\r\nerror = local_pci_probe(&ddi);\r\nput_online_cpus();\r\n} else\r\nerror = local_pci_probe(&ddi);\r\nreturn error;\r\n}\r\nstatic int __pci_device_probe(struct pci_driver *drv, struct pci_dev *pci_dev)\r\n{\r\nconst struct pci_device_id *id;\r\nint error = 0;\r\nif (!pci_dev->driver && drv->probe) {\r\nerror = -ENODEV;\r\nid = pci_match_device(drv, pci_dev);\r\nif (id)\r\nerror = pci_call_probe(drv, pci_dev, id);\r\nif (error >= 0)\r\nerror = 0;\r\n}\r\nreturn error;\r\n}\r\nint __weak pcibios_alloc_irq(struct pci_dev *dev)\r\n{\r\nreturn 0;\r\n}\r\nvoid __weak pcibios_free_irq(struct pci_dev *dev)\r\n{\r\n}\r\nstatic int pci_device_probe(struct device *dev)\r\n{\r\nint error;\r\nstruct pci_dev *pci_dev = to_pci_dev(dev);\r\nstruct pci_driver *drv = to_pci_driver(dev->driver);\r\nerror = pcibios_alloc_irq(pci_dev);\r\nif (error < 0)\r\nreturn error;\r\npci_dev_get(pci_dev);\r\nerror = __pci_device_probe(drv, pci_dev);\r\nif (error) {\r\npcibios_free_irq(pci_dev);\r\npci_dev_put(pci_dev);\r\n}\r\nreturn error;\r\n}\r\nstatic int pci_device_remove(struct device *dev)\r\n{\r\nstruct pci_dev *pci_dev = to_pci_dev(dev);\r\nstruct pci_driver *drv = pci_dev->driver;\r\nif (drv) {\r\nif (drv->remove) {\r\npm_runtime_get_sync(dev);\r\ndrv->remove(pci_dev);\r\npm_runtime_put_noidle(dev);\r\n}\r\npcibios_free_irq(pci_dev);\r\npci_dev->driver = NULL;\r\n}\r\npm_runtime_put_sync(dev);\r\nif (pci_dev->current_state == PCI_D0)\r\npci_dev->current_state = PCI_UNKNOWN;\r\npci_dev_put(pci_dev);\r\nreturn 0;\r\n}\r\nstatic void pci_device_shutdown(struct device *dev)\r\n{\r\nstruct pci_dev *pci_dev = to_pci_dev(dev);\r\nstruct pci_driver *drv = pci_dev->driver;\r\npm_runtime_resume(dev);\r\nif (drv && drv->shutdown)\r\ndrv->shutdown(pci_dev);\r\npci_msi_shutdown(pci_dev);\r\npci_msix_shutdown(pci_dev);\r\n#ifdef CONFIG_KEXEC_CORE\r\nif (kexec_in_progress && (pci_dev->current_state <= PCI_D3hot))\r\npci_clear_master(pci_dev);\r\n#endif\r\n}\r\nstatic int pci_restore_standard_config(struct pci_dev *pci_dev)\r\n{\r\npci_update_current_state(pci_dev, PCI_UNKNOWN);\r\nif (pci_dev->current_state != PCI_D0) {\r\nint error = pci_set_power_state(pci_dev, PCI_D0);\r\nif (error)\r\nreturn error;\r\n}\r\npci_restore_state(pci_dev);\r\nreturn 0;\r\n}\r\nstatic void pci_pm_default_resume_early(struct pci_dev *pci_dev)\r\n{\r\npci_power_up(pci_dev);\r\npci_restore_state(pci_dev);\r\npci_fixup_device(pci_fixup_resume_early, pci_dev);\r\n}\r\nstatic void pci_pm_set_unknown_state(struct pci_dev *pci_dev)\r\n{\r\nif (pci_dev->current_state == PCI_D0)\r\npci_dev->current_state = PCI_UNKNOWN;\r\n}\r\nstatic int pci_pm_reenable_device(struct pci_dev *pci_dev)\r\n{\r\nint retval;\r\nretval = pci_reenable_device(pci_dev);\r\nif (pci_dev->is_busmaster)\r\npci_set_master(pci_dev);\r\nreturn retval;\r\n}\r\nstatic int pci_legacy_suspend(struct device *dev, pm_message_t state)\r\n{\r\nstruct pci_dev *pci_dev = to_pci_dev(dev);\r\nstruct pci_driver *drv = pci_dev->driver;\r\nif (drv && drv->suspend) {\r\npci_power_t prev = pci_dev->current_state;\r\nint error;\r\nerror = drv->suspend(pci_dev, state);\r\nsuspend_report_result(drv->suspend, error);\r\nif (error)\r\nreturn error;\r\nif (!pci_dev->state_saved && pci_dev->current_state != PCI_D0\r\n&& pci_dev->current_state != PCI_UNKNOWN) {\r\nWARN_ONCE(pci_dev->current_state != prev,\r\n"PCI PM: Device state not saved by %pF\n",\r\ndrv->suspend);\r\n}\r\n}\r\npci_fixup_device(pci_fixup_suspend, pci_dev);\r\nreturn 0;\r\n}\r\nstatic int pci_legacy_suspend_late(struct device *dev, pm_message_t state)\r\n{\r\nstruct pci_dev *pci_dev = to_pci_dev(dev);\r\nstruct pci_driver *drv = pci_dev->driver;\r\nif (drv && drv->suspend_late) {\r\npci_power_t prev = pci_dev->current_state;\r\nint error;\r\nerror = drv->suspend_late(pci_dev, state);\r\nsuspend_report_result(drv->suspend_late, error);\r\nif (error)\r\nreturn error;\r\nif (!pci_dev->state_saved && pci_dev->current_state != PCI_D0\r\n&& pci_dev->current_state != PCI_UNKNOWN) {\r\nWARN_ONCE(pci_dev->current_state != prev,\r\n"PCI PM: Device state not saved by %pF\n",\r\ndrv->suspend_late);\r\ngoto Fixup;\r\n}\r\n}\r\nif (!pci_dev->state_saved)\r\npci_save_state(pci_dev);\r\npci_pm_set_unknown_state(pci_dev);\r\nFixup:\r\npci_fixup_device(pci_fixup_suspend_late, pci_dev);\r\nreturn 0;\r\n}\r\nstatic int pci_legacy_resume_early(struct device *dev)\r\n{\r\nstruct pci_dev *pci_dev = to_pci_dev(dev);\r\nstruct pci_driver *drv = pci_dev->driver;\r\nreturn drv && drv->resume_early ?\r\ndrv->resume_early(pci_dev) : 0;\r\n}\r\nstatic int pci_legacy_resume(struct device *dev)\r\n{\r\nstruct pci_dev *pci_dev = to_pci_dev(dev);\r\nstruct pci_driver *drv = pci_dev->driver;\r\npci_fixup_device(pci_fixup_resume, pci_dev);\r\nreturn drv && drv->resume ?\r\ndrv->resume(pci_dev) : pci_pm_reenable_device(pci_dev);\r\n}\r\nstatic void pci_pm_default_resume(struct pci_dev *pci_dev)\r\n{\r\npci_fixup_device(pci_fixup_resume, pci_dev);\r\nif (!pci_has_subordinate(pci_dev))\r\npci_enable_wake(pci_dev, PCI_D0, false);\r\n}\r\nstatic void pci_pm_default_suspend(struct pci_dev *pci_dev)\r\n{\r\nif (!pci_has_subordinate(pci_dev))\r\npci_disable_enabled_device(pci_dev);\r\n}\r\nstatic bool pci_has_legacy_pm_support(struct pci_dev *pci_dev)\r\n{\r\nstruct pci_driver *drv = pci_dev->driver;\r\nbool ret = drv && (drv->suspend || drv->suspend_late || drv->resume\r\n|| drv->resume_early);\r\nWARN(ret && drv->driver.pm, "driver %s device %04x:%04x\n",\r\ndrv->name, pci_dev->vendor, pci_dev->device);\r\nreturn ret;\r\n}\r\nstatic int pci_pm_prepare(struct device *dev)\r\n{\r\nstruct device_driver *drv = dev->driver;\r\nif (dev->power.ignore_children)\r\npm_runtime_resume(dev);\r\nif (drv && drv->pm && drv->pm->prepare) {\r\nint error = drv->pm->prepare(dev);\r\nif (error)\r\nreturn error;\r\n}\r\nreturn pci_dev_keep_suspended(to_pci_dev(dev));\r\n}\r\nstatic void pci_pm_complete(struct device *dev)\r\n{\r\npci_dev_complete_resume(to_pci_dev(dev));\r\npm_complete_with_resume_check(dev);\r\n}\r\nstatic int pci_pm_suspend(struct device *dev)\r\n{\r\nstruct pci_dev *pci_dev = to_pci_dev(dev);\r\nconst struct dev_pm_ops *pm = dev->driver ? dev->driver->pm : NULL;\r\nif (pci_has_legacy_pm_support(pci_dev))\r\nreturn pci_legacy_suspend(dev, PMSG_SUSPEND);\r\nif (!pm) {\r\npci_pm_default_suspend(pci_dev);\r\ngoto Fixup;\r\n}\r\npm_runtime_resume(dev);\r\npci_dev->state_saved = false;\r\nif (pm->suspend) {\r\npci_power_t prev = pci_dev->current_state;\r\nint error;\r\nerror = pm->suspend(dev);\r\nsuspend_report_result(pm->suspend, error);\r\nif (error)\r\nreturn error;\r\nif (!pci_dev->state_saved && pci_dev->current_state != PCI_D0\r\n&& pci_dev->current_state != PCI_UNKNOWN) {\r\nWARN_ONCE(pci_dev->current_state != prev,\r\n"PCI PM: State of device not saved by %pF\n",\r\npm->suspend);\r\n}\r\n}\r\nFixup:\r\npci_fixup_device(pci_fixup_suspend, pci_dev);\r\nreturn 0;\r\n}\r\nstatic int pci_pm_suspend_noirq(struct device *dev)\r\n{\r\nstruct pci_dev *pci_dev = to_pci_dev(dev);\r\nconst struct dev_pm_ops *pm = dev->driver ? dev->driver->pm : NULL;\r\nif (pci_has_legacy_pm_support(pci_dev))\r\nreturn pci_legacy_suspend_late(dev, PMSG_SUSPEND);\r\nif (!pm) {\r\npci_save_state(pci_dev);\r\ngoto Fixup;\r\n}\r\nif (pm->suspend_noirq) {\r\npci_power_t prev = pci_dev->current_state;\r\nint error;\r\nerror = pm->suspend_noirq(dev);\r\nsuspend_report_result(pm->suspend_noirq, error);\r\nif (error)\r\nreturn error;\r\nif (!pci_dev->state_saved && pci_dev->current_state != PCI_D0\r\n&& pci_dev->current_state != PCI_UNKNOWN) {\r\nWARN_ONCE(pci_dev->current_state != prev,\r\n"PCI PM: State of device not saved by %pF\n",\r\npm->suspend_noirq);\r\ngoto Fixup;\r\n}\r\n}\r\nif (!pci_dev->state_saved) {\r\npci_save_state(pci_dev);\r\nif (!pci_has_subordinate(pci_dev))\r\npci_prepare_to_sleep(pci_dev);\r\n}\r\npci_pm_set_unknown_state(pci_dev);\r\nif (pci_dev->class == PCI_CLASS_SERIAL_USB_EHCI)\r\npci_write_config_word(pci_dev, PCI_COMMAND, 0);\r\nFixup:\r\npci_fixup_device(pci_fixup_suspend_late, pci_dev);\r\nreturn 0;\r\n}\r\nstatic int pci_pm_resume_noirq(struct device *dev)\r\n{\r\nstruct pci_dev *pci_dev = to_pci_dev(dev);\r\nstruct device_driver *drv = dev->driver;\r\nint error = 0;\r\npci_pm_default_resume_early(pci_dev);\r\nif (pci_has_legacy_pm_support(pci_dev))\r\nreturn pci_legacy_resume_early(dev);\r\nif (drv && drv->pm && drv->pm->resume_noirq)\r\nerror = drv->pm->resume_noirq(dev);\r\nreturn error;\r\n}\r\nstatic int pci_pm_resume(struct device *dev)\r\n{\r\nstruct pci_dev *pci_dev = to_pci_dev(dev);\r\nconst struct dev_pm_ops *pm = dev->driver ? dev->driver->pm : NULL;\r\nint error = 0;\r\nif (pci_dev->state_saved)\r\npci_restore_standard_config(pci_dev);\r\nif (pci_has_legacy_pm_support(pci_dev))\r\nreturn pci_legacy_resume(dev);\r\npci_pm_default_resume(pci_dev);\r\nif (pm) {\r\nif (pm->resume)\r\nerror = pm->resume(dev);\r\n} else {\r\npci_pm_reenable_device(pci_dev);\r\n}\r\nreturn error;\r\n}\r\nstatic int pci_pm_freeze(struct device *dev)\r\n{\r\nstruct pci_dev *pci_dev = to_pci_dev(dev);\r\nconst struct dev_pm_ops *pm = dev->driver ? dev->driver->pm : NULL;\r\nif (pci_has_legacy_pm_support(pci_dev))\r\nreturn pci_legacy_suspend(dev, PMSG_FREEZE);\r\nif (!pm) {\r\npci_pm_default_suspend(pci_dev);\r\nreturn 0;\r\n}\r\npm_runtime_resume(dev);\r\npci_dev->state_saved = false;\r\nif (pm->freeze) {\r\nint error;\r\nerror = pm->freeze(dev);\r\nsuspend_report_result(pm->freeze, error);\r\nif (error)\r\nreturn error;\r\n}\r\nif (pcibios_pm_ops.freeze)\r\nreturn pcibios_pm_ops.freeze(dev);\r\nreturn 0;\r\n}\r\nstatic int pci_pm_freeze_noirq(struct device *dev)\r\n{\r\nstruct pci_dev *pci_dev = to_pci_dev(dev);\r\nstruct device_driver *drv = dev->driver;\r\nif (pci_has_legacy_pm_support(pci_dev))\r\nreturn pci_legacy_suspend_late(dev, PMSG_FREEZE);\r\nif (drv && drv->pm && drv->pm->freeze_noirq) {\r\nint error;\r\nerror = drv->pm->freeze_noirq(dev);\r\nsuspend_report_result(drv->pm->freeze_noirq, error);\r\nif (error)\r\nreturn error;\r\n}\r\nif (!pci_dev->state_saved)\r\npci_save_state(pci_dev);\r\npci_pm_set_unknown_state(pci_dev);\r\nif (pcibios_pm_ops.freeze_noirq)\r\nreturn pcibios_pm_ops.freeze_noirq(dev);\r\nreturn 0;\r\n}\r\nstatic int pci_pm_thaw_noirq(struct device *dev)\r\n{\r\nstruct pci_dev *pci_dev = to_pci_dev(dev);\r\nstruct device_driver *drv = dev->driver;\r\nint error = 0;\r\nif (pcibios_pm_ops.thaw_noirq) {\r\nerror = pcibios_pm_ops.thaw_noirq(dev);\r\nif (error)\r\nreturn error;\r\n}\r\nif (pci_has_legacy_pm_support(pci_dev))\r\nreturn pci_legacy_resume_early(dev);\r\npci_update_current_state(pci_dev, PCI_D0);\r\nif (drv && drv->pm && drv->pm->thaw_noirq)\r\nerror = drv->pm->thaw_noirq(dev);\r\nreturn error;\r\n}\r\nstatic int pci_pm_thaw(struct device *dev)\r\n{\r\nstruct pci_dev *pci_dev = to_pci_dev(dev);\r\nconst struct dev_pm_ops *pm = dev->driver ? dev->driver->pm : NULL;\r\nint error = 0;\r\nif (pcibios_pm_ops.thaw) {\r\nerror = pcibios_pm_ops.thaw(dev);\r\nif (error)\r\nreturn error;\r\n}\r\nif (pci_has_legacy_pm_support(pci_dev))\r\nreturn pci_legacy_resume(dev);\r\nif (pm) {\r\nif (pm->thaw)\r\nerror = pm->thaw(dev);\r\n} else {\r\npci_pm_reenable_device(pci_dev);\r\n}\r\npci_dev->state_saved = false;\r\nreturn error;\r\n}\r\nstatic int pci_pm_poweroff(struct device *dev)\r\n{\r\nstruct pci_dev *pci_dev = to_pci_dev(dev);\r\nconst struct dev_pm_ops *pm = dev->driver ? dev->driver->pm : NULL;\r\nif (pci_has_legacy_pm_support(pci_dev))\r\nreturn pci_legacy_suspend(dev, PMSG_HIBERNATE);\r\nif (!pm) {\r\npci_pm_default_suspend(pci_dev);\r\ngoto Fixup;\r\n}\r\npm_runtime_resume(dev);\r\npci_dev->state_saved = false;\r\nif (pm->poweroff) {\r\nint error;\r\nerror = pm->poweroff(dev);\r\nsuspend_report_result(pm->poweroff, error);\r\nif (error)\r\nreturn error;\r\n}\r\nFixup:\r\npci_fixup_device(pci_fixup_suspend, pci_dev);\r\nif (pcibios_pm_ops.poweroff)\r\nreturn pcibios_pm_ops.poweroff(dev);\r\nreturn 0;\r\n}\r\nstatic int pci_pm_poweroff_noirq(struct device *dev)\r\n{\r\nstruct pci_dev *pci_dev = to_pci_dev(dev);\r\nstruct device_driver *drv = dev->driver;\r\nif (pci_has_legacy_pm_support(to_pci_dev(dev)))\r\nreturn pci_legacy_suspend_late(dev, PMSG_HIBERNATE);\r\nif (!drv || !drv->pm) {\r\npci_fixup_device(pci_fixup_suspend_late, pci_dev);\r\nreturn 0;\r\n}\r\nif (drv->pm->poweroff_noirq) {\r\nint error;\r\nerror = drv->pm->poweroff_noirq(dev);\r\nsuspend_report_result(drv->pm->poweroff_noirq, error);\r\nif (error)\r\nreturn error;\r\n}\r\nif (!pci_dev->state_saved && !pci_has_subordinate(pci_dev))\r\npci_prepare_to_sleep(pci_dev);\r\nif (pci_dev->class == PCI_CLASS_SERIAL_USB_EHCI)\r\npci_write_config_word(pci_dev, PCI_COMMAND, 0);\r\npci_fixup_device(pci_fixup_suspend_late, pci_dev);\r\nif (pcibios_pm_ops.poweroff_noirq)\r\nreturn pcibios_pm_ops.poweroff_noirq(dev);\r\nreturn 0;\r\n}\r\nstatic int pci_pm_restore_noirq(struct device *dev)\r\n{\r\nstruct pci_dev *pci_dev = to_pci_dev(dev);\r\nstruct device_driver *drv = dev->driver;\r\nint error = 0;\r\nif (pcibios_pm_ops.restore_noirq) {\r\nerror = pcibios_pm_ops.restore_noirq(dev);\r\nif (error)\r\nreturn error;\r\n}\r\npci_pm_default_resume_early(pci_dev);\r\nif (pci_has_legacy_pm_support(pci_dev))\r\nreturn pci_legacy_resume_early(dev);\r\nif (drv && drv->pm && drv->pm->restore_noirq)\r\nerror = drv->pm->restore_noirq(dev);\r\nreturn error;\r\n}\r\nstatic int pci_pm_restore(struct device *dev)\r\n{\r\nstruct pci_dev *pci_dev = to_pci_dev(dev);\r\nconst struct dev_pm_ops *pm = dev->driver ? dev->driver->pm : NULL;\r\nint error = 0;\r\nif (pcibios_pm_ops.restore) {\r\nerror = pcibios_pm_ops.restore(dev);\r\nif (error)\r\nreturn error;\r\n}\r\nif (pci_dev->state_saved)\r\npci_restore_standard_config(pci_dev);\r\nif (pci_has_legacy_pm_support(pci_dev))\r\nreturn pci_legacy_resume(dev);\r\npci_pm_default_resume(pci_dev);\r\nif (pm) {\r\nif (pm->restore)\r\nerror = pm->restore(dev);\r\n} else {\r\npci_pm_reenable_device(pci_dev);\r\n}\r\nreturn error;\r\n}\r\nstatic int pci_pm_runtime_suspend(struct device *dev)\r\n{\r\nstruct pci_dev *pci_dev = to_pci_dev(dev);\r\nconst struct dev_pm_ops *pm = dev->driver ? dev->driver->pm : NULL;\r\npci_power_t prev = pci_dev->current_state;\r\nint error;\r\nif (!pci_dev->driver)\r\nreturn 0;\r\nif (!pm || !pm->runtime_suspend)\r\nreturn -ENOSYS;\r\npci_dev->state_saved = false;\r\npci_dev->no_d3cold = false;\r\nerror = pm->runtime_suspend(dev);\r\nif (error) {\r\nif (error == -EBUSY || error == -EAGAIN)\r\ndev_dbg(dev, "can't suspend now (%pf returned %d)\n",\r\npm->runtime_suspend, error);\r\nelse\r\ndev_err(dev, "can't suspend (%pf returned %d)\n",\r\npm->runtime_suspend, error);\r\nreturn error;\r\n}\r\nif (!pci_dev->d3cold_allowed)\r\npci_dev->no_d3cold = true;\r\npci_fixup_device(pci_fixup_suspend, pci_dev);\r\nif (!pci_dev->state_saved && pci_dev->current_state != PCI_D0\r\n&& pci_dev->current_state != PCI_UNKNOWN) {\r\nWARN_ONCE(pci_dev->current_state != prev,\r\n"PCI PM: State of device not saved by %pF\n",\r\npm->runtime_suspend);\r\nreturn 0;\r\n}\r\nif (!pci_dev->state_saved) {\r\npci_save_state(pci_dev);\r\npci_finish_runtime_suspend(pci_dev);\r\n}\r\nreturn 0;\r\n}\r\nstatic int pci_pm_runtime_resume(struct device *dev)\r\n{\r\nint rc;\r\nstruct pci_dev *pci_dev = to_pci_dev(dev);\r\nconst struct dev_pm_ops *pm = dev->driver ? dev->driver->pm : NULL;\r\nif (!pci_dev->driver)\r\nreturn 0;\r\nif (!pm || !pm->runtime_resume)\r\nreturn -ENOSYS;\r\npci_restore_standard_config(pci_dev);\r\npci_fixup_device(pci_fixup_resume_early, pci_dev);\r\n__pci_enable_wake(pci_dev, PCI_D0, true, false);\r\npci_fixup_device(pci_fixup_resume, pci_dev);\r\nrc = pm->runtime_resume(dev);\r\npci_dev->runtime_d3cold = false;\r\nreturn rc;\r\n}\r\nstatic int pci_pm_runtime_idle(struct device *dev)\r\n{\r\nstruct pci_dev *pci_dev = to_pci_dev(dev);\r\nconst struct dev_pm_ops *pm = dev->driver ? dev->driver->pm : NULL;\r\nint ret = 0;\r\nif (!pci_dev->driver)\r\nreturn 0;\r\nif (!pm)\r\nreturn -ENOSYS;\r\nif (pm->runtime_idle)\r\nret = pm->runtime_idle(dev);\r\nreturn ret;\r\n}\r\nint __pci_register_driver(struct pci_driver *drv, struct module *owner,\r\nconst char *mod_name)\r\n{\r\ndrv->driver.name = drv->name;\r\ndrv->driver.bus = &pci_bus_type;\r\ndrv->driver.owner = owner;\r\ndrv->driver.mod_name = mod_name;\r\nspin_lock_init(&drv->dynids.lock);\r\nINIT_LIST_HEAD(&drv->dynids.list);\r\nreturn driver_register(&drv->driver);\r\n}\r\nvoid pci_unregister_driver(struct pci_driver *drv)\r\n{\r\ndriver_unregister(&drv->driver);\r\npci_free_dynids(drv);\r\n}\r\nstruct pci_driver *pci_dev_driver(const struct pci_dev *dev)\r\n{\r\nif (dev->driver)\r\nreturn dev->driver;\r\nelse {\r\nint i;\r\nfor (i = 0; i <= PCI_ROM_RESOURCE; i++)\r\nif (dev->resource[i].flags & IORESOURCE_BUSY)\r\nreturn &pci_compat_driver;\r\n}\r\nreturn NULL;\r\n}\r\nstatic int pci_bus_match(struct device *dev, struct device_driver *drv)\r\n{\r\nstruct pci_dev *pci_dev = to_pci_dev(dev);\r\nstruct pci_driver *pci_drv;\r\nconst struct pci_device_id *found_id;\r\nif (!pci_dev->match_driver)\r\nreturn 0;\r\npci_drv = to_pci_driver(drv);\r\nfound_id = pci_match_device(pci_drv, pci_dev);\r\nif (found_id)\r\nreturn 1;\r\nreturn 0;\r\n}\r\nstruct pci_dev *pci_dev_get(struct pci_dev *dev)\r\n{\r\nif (dev)\r\nget_device(&dev->dev);\r\nreturn dev;\r\n}\r\nvoid pci_dev_put(struct pci_dev *dev)\r\n{\r\nif (dev)\r\nput_device(&dev->dev);\r\n}\r\nstatic int pci_uevent(struct device *dev, struct kobj_uevent_env *env)\r\n{\r\nstruct pci_dev *pdev;\r\nif (!dev)\r\nreturn -ENODEV;\r\npdev = to_pci_dev(dev);\r\nif (add_uevent_var(env, "PCI_CLASS=%04X", pdev->class))\r\nreturn -ENOMEM;\r\nif (add_uevent_var(env, "PCI_ID=%04X:%04X", pdev->vendor, pdev->device))\r\nreturn -ENOMEM;\r\nif (add_uevent_var(env, "PCI_SUBSYS_ID=%04X:%04X", pdev->subsystem_vendor,\r\npdev->subsystem_device))\r\nreturn -ENOMEM;\r\nif (add_uevent_var(env, "PCI_SLOT_NAME=%s", pci_name(pdev)))\r\nreturn -ENOMEM;\r\nif (add_uevent_var(env, "MODALIAS=pci:v%08Xd%08Xsv%08Xsd%08Xbc%02Xsc%02Xi%02X",\r\npdev->vendor, pdev->device,\r\npdev->subsystem_vendor, pdev->subsystem_device,\r\n(u8)(pdev->class >> 16), (u8)(pdev->class >> 8),\r\n(u8)(pdev->class)))\r\nreturn -ENOMEM;\r\nreturn 0;\r\n}\r\nstatic int __init pci_driver_init(void)\r\n{\r\nreturn bus_register(&pci_bus_type);\r\n}
