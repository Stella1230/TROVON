static int mpsc_open(void)\r\n{\r\nchr1 = in_le32((u32 *)(mpsc_base + MPSC_CHR_1)) & 0x00ff0000;\r\nchr2 = in_le32((u32 *)(mpsc_base + MPSC_CHR_2)) & ~(MPSC_CHR_2_TA\r\n| MPSC_CHR_2_TCS | MPSC_CHR_2_RA | MPSC_CHR_2_CRD\r\n| MPSC_CHR_2_EH);\r\nout_le32((u32 *)(mpsc_base + MPSC_CHR_4), MPSC_CHR_4_Z);\r\nout_le32((u32 *)(mpsc_base + MPSC_CHR_5),\r\nMPSC_CHR_5_CTL1_INTR | MPSC_CHR_5_CTL1_VALID);\r\nout_le32((u32 *)(mpsc_base + MPSC_CHR_2), chr2 | MPSC_CHR_2_EH);\r\nreturn 0;\r\n}\r\nstatic void mpsc_putc(unsigned char c)\r\n{\r\nwhile (in_le32((u32 *)(mpsc_base + MPSC_CHR_2)) & MPSC_CHR_2_TCS);\r\nout_le32((u32 *)(mpsc_base + MPSC_CHR_1), chr1 | c);\r\nout_le32((u32 *)(mpsc_base + MPSC_CHR_2), chr2 | MPSC_CHR_2_TCS);\r\n}\r\nstatic unsigned char mpsc_getc(void)\r\n{\r\nu32 cause = 0;\r\nunsigned char c;\r\nwhile (!(cause & MPSC_INTR_CAUSE_RCC))\r\ncause = in_le32((u32 *)(mpscintr_base + MPSC_INTR_CAUSE));\r\nc = in_8((u8 *)(mpsc_base + MPSC_CHR_10 + 2));\r\nout_8((u8 *)(mpsc_base + MPSC_CHR_10 + 2), c);\r\nout_le32((u32 *)(mpscintr_base + MPSC_INTR_CAUSE),\r\ncause & ~MPSC_INTR_CAUSE_RCC);\r\nreturn c;\r\n}\r\nstatic u8 mpsc_tstc(void)\r\n{\r\nreturn (u8)((in_le32((u32 *)(mpscintr_base + MPSC_INTR_CAUSE))\r\n& MPSC_INTR_CAUSE_RCC) != 0);\r\n}\r\nstatic void mpsc_stop_dma(volatile char *sdma_base)\r\n{\r\nout_le32((u32 *)(mpsc_base + MPSC_CHR_2),MPSC_CHR_2_TA | MPSC_CHR_2_RA);\r\nout_le32((u32 *)(sdma_base + SDMA_SDCM), SDMA_SDCM_AR | SDMA_SDCM_AT);\r\nwhile ((in_le32((u32 *)(sdma_base + SDMA_SDCM))\r\n& (SDMA_SDCM_AR | SDMA_SDCM_AT)) != 0)\r\nudelay(100);\r\n}\r\nstatic volatile char *mpsc_get_virtreg_of_phandle(void *devp, char *prop)\r\n{\r\nvoid *v;\r\nint n;\r\nn = getprop(devp, prop, &v, sizeof(v));\r\nif (n != sizeof(v))\r\ngoto err_out;\r\ndevp = find_node_by_linuxphandle((u32)v);\r\nif (devp == NULL)\r\ngoto err_out;\r\nn = getprop(devp, "virtual-reg", &v, sizeof(v));\r\nif (n == sizeof(v))\r\nreturn v;\r\nerr_out:\r\nreturn NULL;\r\n}\r\nint mpsc_console_init(void *devp, struct serial_console_data *scdp)\r\n{\r\nvoid *v;\r\nint n, reg_set;\r\nvolatile char *sdma_base;\r\nn = getprop(devp, "virtual-reg", &v, sizeof(v));\r\nif (n != sizeof(v))\r\ngoto err_out;\r\nmpsc_base = v;\r\nsdma_base = mpsc_get_virtreg_of_phandle(devp, "sdma");\r\nif (sdma_base == NULL)\r\ngoto err_out;\r\nmpscintr_base = mpsc_get_virtreg_of_phandle(devp, "mpscintr");\r\nif (mpscintr_base == NULL)\r\ngoto err_out;\r\nn = getprop(devp, "cell-index", &v, sizeof(v));\r\nif (n != sizeof(v))\r\ngoto err_out;\r\nreg_set = (int)v;\r\nmpscintr_base += (reg_set == 0) ? 0x4 : 0xc;\r\nout_le32((u32 *)(mpscintr_base + MPSC_INTR_CAUSE), 0);\r\nout_le32((u32 *)(mpscintr_base + MPSC_INTR_CAUSE), 0);\r\nout_le32((u32 *)(mpscintr_base + MPSC_INTR_MASK), 0);\r\nout_le32((u32 *)(mpscintr_base + MPSC_INTR_MASK), 0);\r\nmpsc_stop_dma(sdma_base);\r\nscdp->open = mpsc_open;\r\nscdp->putc = mpsc_putc;\r\nscdp->getc = mpsc_getc;\r\nscdp->tstc = mpsc_tstc;\r\nscdp->close = NULL;\r\nreturn 0;\r\nerr_out:\r\nreturn -1;\r\n}
