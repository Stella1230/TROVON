static void init_input_buf(const char *buf, unsigned long long size)\r\n{\r\ninput_buf = buf;\r\ninput_buf_siz = size;\r\ninput_buf_ptr = 0;\r\n}\r\nconst char *pevent_get_input_buf(void)\r\n{\r\nreturn input_buf;\r\n}\r\nunsigned long long pevent_get_input_buf_ptr(void)\r\n{\r\nreturn input_buf_ptr;\r\n}\r\nvoid pevent_buffer_init(const char *buf, unsigned long long size)\r\n{\r\ninit_input_buf(buf, size);\r\n}\r\nvoid breakpoint(void)\r\n{\r\nstatic int x;\r\nx++;\r\n}\r\nstruct print_arg *alloc_arg(void)\r\n{\r\nreturn calloc(1, sizeof(struct print_arg));\r\n}\r\nstatic int cmdline_cmp(const void *a, const void *b)\r\n{\r\nconst struct cmdline *ca = a;\r\nconst struct cmdline *cb = b;\r\nif (ca->pid < cb->pid)\r\nreturn -1;\r\nif (ca->pid > cb->pid)\r\nreturn 1;\r\nreturn 0;\r\n}\r\nstatic int cmdline_init(struct pevent *pevent)\r\n{\r\nstruct cmdline_list *cmdlist = pevent->cmdlist;\r\nstruct cmdline_list *item;\r\nstruct cmdline *cmdlines;\r\nint i;\r\ncmdlines = malloc(sizeof(*cmdlines) * pevent->cmdline_count);\r\nif (!cmdlines)\r\nreturn -1;\r\ni = 0;\r\nwhile (cmdlist) {\r\ncmdlines[i].pid = cmdlist->pid;\r\ncmdlines[i].comm = cmdlist->comm;\r\ni++;\r\nitem = cmdlist;\r\ncmdlist = cmdlist->next;\r\nfree(item);\r\n}\r\nqsort(cmdlines, pevent->cmdline_count, sizeof(*cmdlines), cmdline_cmp);\r\npevent->cmdlines = cmdlines;\r\npevent->cmdlist = NULL;\r\nreturn 0;\r\n}\r\nstatic const char *find_cmdline(struct pevent *pevent, int pid)\r\n{\r\nconst struct cmdline *comm;\r\nstruct cmdline key;\r\nif (!pid)\r\nreturn "<idle>";\r\nif (!pevent->cmdlines && cmdline_init(pevent))\r\nreturn "<not enough memory for cmdlines!>";\r\nkey.pid = pid;\r\ncomm = bsearch(&key, pevent->cmdlines, pevent->cmdline_count,\r\nsizeof(*pevent->cmdlines), cmdline_cmp);\r\nif (comm)\r\nreturn comm->comm;\r\nreturn "<...>";\r\n}\r\nint pevent_pid_is_registered(struct pevent *pevent, int pid)\r\n{\r\nconst struct cmdline *comm;\r\nstruct cmdline key;\r\nif (!pid)\r\nreturn 1;\r\nif (!pevent->cmdlines && cmdline_init(pevent))\r\nreturn 0;\r\nkey.pid = pid;\r\ncomm = bsearch(&key, pevent->cmdlines, pevent->cmdline_count,\r\nsizeof(*pevent->cmdlines), cmdline_cmp);\r\nif (comm)\r\nreturn 1;\r\nreturn 0;\r\n}\r\nstatic int add_new_comm(struct pevent *pevent, const char *comm, int pid)\r\n{\r\nstruct cmdline *cmdlines = pevent->cmdlines;\r\nconst struct cmdline *cmdline;\r\nstruct cmdline key;\r\nif (!pid)\r\nreturn 0;\r\nkey.pid = pid;\r\ncmdline = bsearch(&key, pevent->cmdlines, pevent->cmdline_count,\r\nsizeof(*pevent->cmdlines), cmdline_cmp);\r\nif (cmdline) {\r\nerrno = EEXIST;\r\nreturn -1;\r\n}\r\ncmdlines = realloc(cmdlines, sizeof(*cmdlines) * (pevent->cmdline_count + 1));\r\nif (!cmdlines) {\r\nerrno = ENOMEM;\r\nreturn -1;\r\n}\r\ncmdlines[pevent->cmdline_count].comm = strdup(comm);\r\nif (!cmdlines[pevent->cmdline_count].comm) {\r\nfree(cmdlines);\r\nerrno = ENOMEM;\r\nreturn -1;\r\n}\r\ncmdlines[pevent->cmdline_count].pid = pid;\r\nif (cmdlines[pevent->cmdline_count].comm)\r\npevent->cmdline_count++;\r\nqsort(cmdlines, pevent->cmdline_count, sizeof(*cmdlines), cmdline_cmp);\r\npevent->cmdlines = cmdlines;\r\nreturn 0;\r\n}\r\nint pevent_register_comm(struct pevent *pevent, const char *comm, int pid)\r\n{\r\nstruct cmdline_list *item;\r\nif (pevent->cmdlines)\r\nreturn add_new_comm(pevent, comm, pid);\r\nitem = malloc(sizeof(*item));\r\nif (!item)\r\nreturn -1;\r\nif (comm)\r\nitem->comm = strdup(comm);\r\nelse\r\nitem->comm = strdup("<...>");\r\nif (!item->comm) {\r\nfree(item);\r\nreturn -1;\r\n}\r\nitem->pid = pid;\r\nitem->next = pevent->cmdlist;\r\npevent->cmdlist = item;\r\npevent->cmdline_count++;\r\nreturn 0;\r\n}\r\nint pevent_register_trace_clock(struct pevent *pevent, const char *trace_clock)\r\n{\r\npevent->trace_clock = strdup(trace_clock);\r\nif (!pevent->trace_clock) {\r\nerrno = ENOMEM;\r\nreturn -1;\r\n}\r\nreturn 0;\r\n}\r\nstatic int func_cmp(const void *a, const void *b)\r\n{\r\nconst struct func_map *fa = a;\r\nconst struct func_map *fb = b;\r\nif (fa->addr < fb->addr)\r\nreturn -1;\r\nif (fa->addr > fb->addr)\r\nreturn 1;\r\nreturn 0;\r\n}\r\nstatic int func_bcmp(const void *a, const void *b)\r\n{\r\nconst struct func_map *fa = a;\r\nconst struct func_map *fb = b;\r\nif ((fa->addr == fb->addr) ||\r\n(fa->addr > fb->addr &&\r\nfa->addr < (fb+1)->addr))\r\nreturn 0;\r\nif (fa->addr < fb->addr)\r\nreturn -1;\r\nreturn 1;\r\n}\r\nstatic int func_map_init(struct pevent *pevent)\r\n{\r\nstruct func_list *funclist;\r\nstruct func_list *item;\r\nstruct func_map *func_map;\r\nint i;\r\nfunc_map = malloc(sizeof(*func_map) * (pevent->func_count + 1));\r\nif (!func_map)\r\nreturn -1;\r\nfunclist = pevent->funclist;\r\ni = 0;\r\nwhile (funclist) {\r\nfunc_map[i].func = funclist->func;\r\nfunc_map[i].addr = funclist->addr;\r\nfunc_map[i].mod = funclist->mod;\r\ni++;\r\nitem = funclist;\r\nfunclist = funclist->next;\r\nfree(item);\r\n}\r\nqsort(func_map, pevent->func_count, sizeof(*func_map), func_cmp);\r\nfunc_map[pevent->func_count].func = NULL;\r\nfunc_map[pevent->func_count].addr = 0;\r\nfunc_map[pevent->func_count].mod = NULL;\r\npevent->func_map = func_map;\r\npevent->funclist = NULL;\r\nreturn 0;\r\n}\r\nstatic struct func_map *\r\n__find_func(struct pevent *pevent, unsigned long long addr)\r\n{\r\nstruct func_map *func;\r\nstruct func_map key;\r\nif (!pevent->func_map)\r\nfunc_map_init(pevent);\r\nkey.addr = addr;\r\nfunc = bsearch(&key, pevent->func_map, pevent->func_count,\r\nsizeof(*pevent->func_map), func_bcmp);\r\nreturn func;\r\n}\r\nint pevent_set_function_resolver(struct pevent *pevent,\r\npevent_func_resolver_t *func, void *priv)\r\n{\r\nstruct func_resolver *resolver = malloc(sizeof(*resolver));\r\nif (resolver == NULL)\r\nreturn -1;\r\nresolver->func = func;\r\nresolver->priv = priv;\r\nfree(pevent->func_resolver);\r\npevent->func_resolver = resolver;\r\nreturn 0;\r\n}\r\nvoid pevent_reset_function_resolver(struct pevent *pevent)\r\n{\r\nfree(pevent->func_resolver);\r\npevent->func_resolver = NULL;\r\n}\r\nstatic struct func_map *\r\nfind_func(struct pevent *pevent, unsigned long long addr)\r\n{\r\nstruct func_map *map;\r\nif (!pevent->func_resolver)\r\nreturn __find_func(pevent, addr);\r\nmap = &pevent->func_resolver->map;\r\nmap->mod = NULL;\r\nmap->addr = addr;\r\nmap->func = pevent->func_resolver->func(pevent->func_resolver->priv,\r\n&map->addr, &map->mod);\r\nif (map->func == NULL)\r\nreturn NULL;\r\nreturn map;\r\n}\r\nconst char *pevent_find_function(struct pevent *pevent, unsigned long long addr)\r\n{\r\nstruct func_map *map;\r\nmap = find_func(pevent, addr);\r\nif (!map)\r\nreturn NULL;\r\nreturn map->func;\r\n}\r\nunsigned long long\r\npevent_find_function_address(struct pevent *pevent, unsigned long long addr)\r\n{\r\nstruct func_map *map;\r\nmap = find_func(pevent, addr);\r\nif (!map)\r\nreturn 0;\r\nreturn map->addr;\r\n}\r\nint pevent_register_function(struct pevent *pevent, char *func,\r\nunsigned long long addr, char *mod)\r\n{\r\nstruct func_list *item = malloc(sizeof(*item));\r\nif (!item)\r\nreturn -1;\r\nitem->next = pevent->funclist;\r\nitem->func = strdup(func);\r\nif (!item->func)\r\ngoto out_free;\r\nif (mod) {\r\nitem->mod = strdup(mod);\r\nif (!item->mod)\r\ngoto out_free_func;\r\n} else\r\nitem->mod = NULL;\r\nitem->addr = addr;\r\npevent->funclist = item;\r\npevent->func_count++;\r\nreturn 0;\r\nout_free_func:\r\nfree(item->func);\r\nitem->func = NULL;\r\nout_free:\r\nfree(item);\r\nerrno = ENOMEM;\r\nreturn -1;\r\n}\r\nvoid pevent_print_funcs(struct pevent *pevent)\r\n{\r\nint i;\r\nif (!pevent->func_map)\r\nfunc_map_init(pevent);\r\nfor (i = 0; i < (int)pevent->func_count; i++) {\r\nprintf("%016llx %s",\r\npevent->func_map[i].addr,\r\npevent->func_map[i].func);\r\nif (pevent->func_map[i].mod)\r\nprintf(" [%s]\n", pevent->func_map[i].mod);\r\nelse\r\nprintf("\n");\r\n}\r\n}\r\nstatic int printk_cmp(const void *a, const void *b)\r\n{\r\nconst struct printk_map *pa = a;\r\nconst struct printk_map *pb = b;\r\nif (pa->addr < pb->addr)\r\nreturn -1;\r\nif (pa->addr > pb->addr)\r\nreturn 1;\r\nreturn 0;\r\n}\r\nstatic int printk_map_init(struct pevent *pevent)\r\n{\r\nstruct printk_list *printklist;\r\nstruct printk_list *item;\r\nstruct printk_map *printk_map;\r\nint i;\r\nprintk_map = malloc(sizeof(*printk_map) * (pevent->printk_count + 1));\r\nif (!printk_map)\r\nreturn -1;\r\nprintklist = pevent->printklist;\r\ni = 0;\r\nwhile (printklist) {\r\nprintk_map[i].printk = printklist->printk;\r\nprintk_map[i].addr = printklist->addr;\r\ni++;\r\nitem = printklist;\r\nprintklist = printklist->next;\r\nfree(item);\r\n}\r\nqsort(printk_map, pevent->printk_count, sizeof(*printk_map), printk_cmp);\r\npevent->printk_map = printk_map;\r\npevent->printklist = NULL;\r\nreturn 0;\r\n}\r\nstatic struct printk_map *\r\nfind_printk(struct pevent *pevent, unsigned long long addr)\r\n{\r\nstruct printk_map *printk;\r\nstruct printk_map key;\r\nif (!pevent->printk_map && printk_map_init(pevent))\r\nreturn NULL;\r\nkey.addr = addr;\r\nprintk = bsearch(&key, pevent->printk_map, pevent->printk_count,\r\nsizeof(*pevent->printk_map), printk_cmp);\r\nreturn printk;\r\n}\r\nint pevent_register_print_string(struct pevent *pevent, const char *fmt,\r\nunsigned long long addr)\r\n{\r\nstruct printk_list *item = malloc(sizeof(*item));\r\nchar *p;\r\nif (!item)\r\nreturn -1;\r\nitem->next = pevent->printklist;\r\nitem->addr = addr;\r\nif (fmt[0] == '"')\r\nfmt++;\r\nitem->printk = strdup(fmt);\r\nif (!item->printk)\r\ngoto out_free;\r\np = item->printk + strlen(item->printk) - 1;\r\nif (*p == '"')\r\n*p = 0;\r\np -= 2;\r\nif (strcmp(p, "\\n") == 0)\r\n*p = 0;\r\npevent->printklist = item;\r\npevent->printk_count++;\r\nreturn 0;\r\nout_free:\r\nfree(item);\r\nerrno = ENOMEM;\r\nreturn -1;\r\n}\r\nvoid pevent_print_printk(struct pevent *pevent)\r\n{\r\nint i;\r\nif (!pevent->printk_map)\r\nprintk_map_init(pevent);\r\nfor (i = 0; i < (int)pevent->printk_count; i++) {\r\nprintf("%016llx %s\n",\r\npevent->printk_map[i].addr,\r\npevent->printk_map[i].printk);\r\n}\r\n}\r\nstatic struct event_format *alloc_event(void)\r\n{\r\nreturn calloc(1, sizeof(struct event_format));\r\n}\r\nstatic int add_event(struct pevent *pevent, struct event_format *event)\r\n{\r\nint i;\r\nstruct event_format **events = realloc(pevent->events, sizeof(event) *\r\n(pevent->nr_events + 1));\r\nif (!events)\r\nreturn -1;\r\npevent->events = events;\r\nfor (i = 0; i < pevent->nr_events; i++) {\r\nif (pevent->events[i]->id > event->id)\r\nbreak;\r\n}\r\nif (i < pevent->nr_events)\r\nmemmove(&pevent->events[i + 1],\r\n&pevent->events[i],\r\nsizeof(event) * (pevent->nr_events - i));\r\npevent->events[i] = event;\r\npevent->nr_events++;\r\nevent->pevent = pevent;\r\nreturn 0;\r\n}\r\nstatic int event_item_type(enum event_type type)\r\n{\r\nswitch (type) {\r\ncase EVENT_ITEM ... EVENT_SQUOTE:\r\nreturn 1;\r\ncase EVENT_ERROR ... EVENT_DELIM:\r\ndefault:\r\nreturn 0;\r\n}\r\n}\r\nstatic void free_flag_sym(struct print_flag_sym *fsym)\r\n{\r\nstruct print_flag_sym *next;\r\nwhile (fsym) {\r\nnext = fsym->next;\r\nfree(fsym->value);\r\nfree(fsym->str);\r\nfree(fsym);\r\nfsym = next;\r\n}\r\n}\r\nstatic void free_arg(struct print_arg *arg)\r\n{\r\nstruct print_arg *farg;\r\nif (!arg)\r\nreturn;\r\nswitch (arg->type) {\r\ncase PRINT_ATOM:\r\nfree(arg->atom.atom);\r\nbreak;\r\ncase PRINT_FIELD:\r\nfree(arg->field.name);\r\nbreak;\r\ncase PRINT_FLAGS:\r\nfree_arg(arg->flags.field);\r\nfree(arg->flags.delim);\r\nfree_flag_sym(arg->flags.flags);\r\nbreak;\r\ncase PRINT_SYMBOL:\r\nfree_arg(arg->symbol.field);\r\nfree_flag_sym(arg->symbol.symbols);\r\nbreak;\r\ncase PRINT_HEX:\r\nfree_arg(arg->hex.field);\r\nfree_arg(arg->hex.size);\r\nbreak;\r\ncase PRINT_INT_ARRAY:\r\nfree_arg(arg->int_array.field);\r\nfree_arg(arg->int_array.count);\r\nfree_arg(arg->int_array.el_size);\r\nbreak;\r\ncase PRINT_TYPE:\r\nfree(arg->typecast.type);\r\nfree_arg(arg->typecast.item);\r\nbreak;\r\ncase PRINT_STRING:\r\ncase PRINT_BSTRING:\r\nfree(arg->string.string);\r\nbreak;\r\ncase PRINT_BITMASK:\r\nfree(arg->bitmask.bitmask);\r\nbreak;\r\ncase PRINT_DYNAMIC_ARRAY:\r\ncase PRINT_DYNAMIC_ARRAY_LEN:\r\nfree(arg->dynarray.index);\r\nbreak;\r\ncase PRINT_OP:\r\nfree(arg->op.op);\r\nfree_arg(arg->op.left);\r\nfree_arg(arg->op.right);\r\nbreak;\r\ncase PRINT_FUNC:\r\nwhile (arg->func.args) {\r\nfarg = arg->func.args;\r\narg->func.args = farg->next;\r\nfree_arg(farg);\r\n}\r\nbreak;\r\ncase PRINT_NULL:\r\ndefault:\r\nbreak;\r\n}\r\nfree(arg);\r\n}\r\nstatic enum event_type get_type(int ch)\r\n{\r\nif (ch == '\n')\r\nreturn EVENT_NEWLINE;\r\nif (isspace(ch))\r\nreturn EVENT_SPACE;\r\nif (isalnum(ch) || ch == '_')\r\nreturn EVENT_ITEM;\r\nif (ch == '\'')\r\nreturn EVENT_SQUOTE;\r\nif (ch == '"')\r\nreturn EVENT_DQUOTE;\r\nif (!isprint(ch))\r\nreturn EVENT_NONE;\r\nif (ch == '(' || ch == ')' || ch == ',')\r\nreturn EVENT_DELIM;\r\nreturn EVENT_OP;\r\n}\r\nstatic int __read_char(void)\r\n{\r\nif (input_buf_ptr >= input_buf_siz)\r\nreturn -1;\r\nreturn input_buf[input_buf_ptr++];\r\n}\r\nstatic int __peek_char(void)\r\n{\r\nif (input_buf_ptr >= input_buf_siz)\r\nreturn -1;\r\nreturn input_buf[input_buf_ptr];\r\n}\r\nint pevent_peek_char(void)\r\n{\r\nreturn __peek_char();\r\n}\r\nstatic int extend_token(char **tok, char *buf, int size)\r\n{\r\nchar *newtok = realloc(*tok, size);\r\nif (!newtok) {\r\nfree(*tok);\r\n*tok = NULL;\r\nreturn -1;\r\n}\r\nif (!*tok)\r\nstrcpy(newtok, buf);\r\nelse\r\nstrcat(newtok, buf);\r\n*tok = newtok;\r\nreturn 0;\r\n}\r\nstatic enum event_type __read_token(char **tok)\r\n{\r\nchar buf[BUFSIZ];\r\nint ch, last_ch, quote_ch, next_ch;\r\nint i = 0;\r\nint tok_size = 0;\r\nenum event_type type;\r\n*tok = NULL;\r\nch = __read_char();\r\nif (ch < 0)\r\nreturn EVENT_NONE;\r\ntype = get_type(ch);\r\nif (type == EVENT_NONE)\r\nreturn type;\r\nbuf[i++] = ch;\r\nswitch (type) {\r\ncase EVENT_NEWLINE:\r\ncase EVENT_DELIM:\r\nif (asprintf(tok, "%c", ch) < 0)\r\nreturn EVENT_ERROR;\r\nreturn type;\r\ncase EVENT_OP:\r\nswitch (ch) {\r\ncase '-':\r\nnext_ch = __peek_char();\r\nif (next_ch == '>') {\r\nbuf[i++] = __read_char();\r\nbreak;\r\n}\r\ncase '+':\r\ncase '|':\r\ncase '&':\r\ncase '>':\r\ncase '<':\r\nlast_ch = ch;\r\nch = __peek_char();\r\nif (ch != last_ch)\r\ngoto test_equal;\r\nbuf[i++] = __read_char();\r\nswitch (last_ch) {\r\ncase '>':\r\ncase '<':\r\ngoto test_equal;\r\ndefault:\r\nbreak;\r\n}\r\nbreak;\r\ncase '!':\r\ncase '=':\r\ngoto test_equal;\r\ndefault:\r\nbreak;\r\n}\r\nbuf[i] = 0;\r\n*tok = strdup(buf);\r\nreturn type;\r\ntest_equal:\r\nch = __peek_char();\r\nif (ch == '=')\r\nbuf[i++] = __read_char();\r\ngoto out;\r\ncase EVENT_DQUOTE:\r\ncase EVENT_SQUOTE:\r\ni--;\r\nquote_ch = ch;\r\nlast_ch = 0;\r\nconcat:\r\ndo {\r\nif (i == (BUFSIZ - 1)) {\r\nbuf[i] = 0;\r\ntok_size += BUFSIZ;\r\nif (extend_token(tok, buf, tok_size) < 0)\r\nreturn EVENT_NONE;\r\ni = 0;\r\n}\r\nlast_ch = ch;\r\nch = __read_char();\r\nbuf[i++] = ch;\r\nif (ch == '\\' && last_ch == '\\')\r\nlast_ch = 0;\r\n} while (ch != quote_ch || last_ch == '\\');\r\ni--;\r\nif (type == EVENT_DQUOTE) {\r\nunsigned long long save_input_buf_ptr = input_buf_ptr;\r\ndo {\r\nch = __read_char();\r\n} while (isspace(ch));\r\nif (ch == '"')\r\ngoto concat;\r\ninput_buf_ptr = save_input_buf_ptr;\r\n}\r\ngoto out;\r\ncase EVENT_ERROR ... EVENT_SPACE:\r\ncase EVENT_ITEM:\r\ndefault:\r\nbreak;\r\n}\r\nwhile (get_type(__peek_char()) == type) {\r\nif (i == (BUFSIZ - 1)) {\r\nbuf[i] = 0;\r\ntok_size += BUFSIZ;\r\nif (extend_token(tok, buf, tok_size) < 0)\r\nreturn EVENT_NONE;\r\ni = 0;\r\n}\r\nch = __read_char();\r\nbuf[i++] = ch;\r\n}\r\nout:\r\nbuf[i] = 0;\r\nif (extend_token(tok, buf, tok_size + i + 1) < 0)\r\nreturn EVENT_NONE;\r\nif (type == EVENT_ITEM) {\r\nif (strcmp(*tok, "LOCAL_PR_FMT") == 0) {\r\nfree(*tok);\r\n*tok = NULL;\r\nreturn force_token("\"\%s\" ", tok);\r\n} else if (strcmp(*tok, "STA_PR_FMT") == 0) {\r\nfree(*tok);\r\n*tok = NULL;\r\nreturn force_token("\" sta:%pM\" ", tok);\r\n} else if (strcmp(*tok, "VIF_PR_FMT") == 0) {\r\nfree(*tok);\r\n*tok = NULL;\r\nreturn force_token("\" vif:%p(%d)\" ", tok);\r\n}\r\n}\r\nreturn type;\r\n}\r\nstatic enum event_type force_token(const char *str, char **tok)\r\n{\r\nconst char *save_input_buf;\r\nunsigned long long save_input_buf_ptr;\r\nunsigned long long save_input_buf_siz;\r\nenum event_type type;\r\nsave_input_buf = input_buf;\r\nsave_input_buf_ptr = input_buf_ptr;\r\nsave_input_buf_siz = input_buf_siz;\r\ninit_input_buf(str, strlen(str));\r\ntype = __read_token(tok);\r\ninput_buf = save_input_buf;\r\ninput_buf_ptr = save_input_buf_ptr;\r\ninput_buf_siz = save_input_buf_siz;\r\nreturn type;\r\n}\r\nstatic void free_token(char *tok)\r\n{\r\nif (tok)\r\nfree(tok);\r\n}\r\nstatic enum event_type read_token(char **tok)\r\n{\r\nenum event_type type;\r\nfor (;;) {\r\ntype = __read_token(tok);\r\nif (type != EVENT_SPACE)\r\nreturn type;\r\nfree_token(*tok);\r\n}\r\n*tok = NULL;\r\nreturn EVENT_NONE;\r\n}\r\nenum event_type pevent_read_token(char **tok)\r\n{\r\nreturn read_token(tok);\r\n}\r\nvoid pevent_free_token(char *token)\r\n{\r\nfree_token(token);\r\n}\r\nstatic enum event_type read_token_item(char **tok)\r\n{\r\nenum event_type type;\r\nfor (;;) {\r\ntype = __read_token(tok);\r\nif (type != EVENT_SPACE && type != EVENT_NEWLINE)\r\nreturn type;\r\nfree_token(*tok);\r\n*tok = NULL;\r\n}\r\n*tok = NULL;\r\nreturn EVENT_NONE;\r\n}\r\nstatic int test_type(enum event_type type, enum event_type expect)\r\n{\r\nif (type != expect) {\r\ndo_warning("Error: expected type %d but read %d",\r\nexpect, type);\r\nreturn -1;\r\n}\r\nreturn 0;\r\n}\r\nstatic int test_type_token(enum event_type type, const char *token,\r\nenum event_type expect, const char *expect_tok)\r\n{\r\nif (type != expect) {\r\ndo_warning("Error: expected type %d but read %d",\r\nexpect, type);\r\nreturn -1;\r\n}\r\nif (strcmp(token, expect_tok) != 0) {\r\ndo_warning("Error: expected '%s' but read '%s'",\r\nexpect_tok, token);\r\nreturn -1;\r\n}\r\nreturn 0;\r\n}\r\nstatic int __read_expect_type(enum event_type expect, char **tok, int newline_ok)\r\n{\r\nenum event_type type;\r\nif (newline_ok)\r\ntype = read_token(tok);\r\nelse\r\ntype = read_token_item(tok);\r\nreturn test_type(type, expect);\r\n}\r\nstatic int read_expect_type(enum event_type expect, char **tok)\r\n{\r\nreturn __read_expect_type(expect, tok, 1);\r\n}\r\nstatic int __read_expected(enum event_type expect, const char *str,\r\nint newline_ok)\r\n{\r\nenum event_type type;\r\nchar *token;\r\nint ret;\r\nif (newline_ok)\r\ntype = read_token(&token);\r\nelse\r\ntype = read_token_item(&token);\r\nret = test_type_token(type, token, expect, str);\r\nfree_token(token);\r\nreturn ret;\r\n}\r\nstatic int read_expected(enum event_type expect, const char *str)\r\n{\r\nreturn __read_expected(expect, str, 1);\r\n}\r\nstatic int read_expected_item(enum event_type expect, const char *str)\r\n{\r\nreturn __read_expected(expect, str, 0);\r\n}\r\nstatic char *event_read_name(void)\r\n{\r\nchar *token;\r\nif (read_expected(EVENT_ITEM, "name") < 0)\r\nreturn NULL;\r\nif (read_expected(EVENT_OP, ":") < 0)\r\nreturn NULL;\r\nif (read_expect_type(EVENT_ITEM, &token) < 0)\r\ngoto fail;\r\nreturn token;\r\nfail:\r\nfree_token(token);\r\nreturn NULL;\r\n}\r\nstatic int event_read_id(void)\r\n{\r\nchar *token;\r\nint id;\r\nif (read_expected_item(EVENT_ITEM, "ID") < 0)\r\nreturn -1;\r\nif (read_expected(EVENT_OP, ":") < 0)\r\nreturn -1;\r\nif (read_expect_type(EVENT_ITEM, &token) < 0)\r\ngoto fail;\r\nid = strtoul(token, NULL, 0);\r\nfree_token(token);\r\nreturn id;\r\nfail:\r\nfree_token(token);\r\nreturn -1;\r\n}\r\nstatic int field_is_string(struct format_field *field)\r\n{\r\nif ((field->flags & FIELD_IS_ARRAY) &&\r\n(strstr(field->type, "char") || strstr(field->type, "u8") ||\r\nstrstr(field->type, "s8")))\r\nreturn 1;\r\nreturn 0;\r\n}\r\nstatic int field_is_dynamic(struct format_field *field)\r\n{\r\nif (strncmp(field->type, "__data_loc", 10) == 0)\r\nreturn 1;\r\nreturn 0;\r\n}\r\nstatic int field_is_long(struct format_field *field)\r\n{\r\nif (strstr(field->type, "long"))\r\nreturn 1;\r\nreturn 0;\r\n}\r\nstatic unsigned int type_size(const char *name)\r\n{\r\nstatic struct {\r\nconst char *type;\r\nunsigned int size;\r\n} table[] = {\r\n{ "u8", 1 },\r\n{ "u16", 2 },\r\n{ "u32", 4 },\r\n{ "u64", 8 },\r\n{ "s8", 1 },\r\n{ "s16", 2 },\r\n{ "s32", 4 },\r\n{ "s64", 8 },\r\n{ "char", 1 },\r\n{ },\r\n};\r\nint i;\r\nfor (i = 0; table[i].type; i++) {\r\nif (!strcmp(table[i].type, name))\r\nreturn table[i].size;\r\n}\r\nreturn 0;\r\n}\r\nstatic int event_read_fields(struct event_format *event, struct format_field **fields)\r\n{\r\nstruct format_field *field = NULL;\r\nenum event_type type;\r\nchar *token;\r\nchar *last_token;\r\nint count = 0;\r\ndo {\r\nunsigned int size_dynamic = 0;\r\ntype = read_token(&token);\r\nif (type == EVENT_NEWLINE) {\r\nfree_token(token);\r\nreturn count;\r\n}\r\ncount++;\r\nif (test_type_token(type, token, EVENT_ITEM, "field"))\r\ngoto fail;\r\nfree_token(token);\r\ntype = read_token(&token);\r\nif (event->flags & EVENT_FL_ISFTRACE &&\r\ntype == EVENT_ITEM && strcmp(token, "special") == 0) {\r\nfree_token(token);\r\ntype = read_token(&token);\r\n}\r\nif (test_type_token(type, token, EVENT_OP, ":") < 0)\r\ngoto fail;\r\nfree_token(token);\r\nif (read_expect_type(EVENT_ITEM, &token) < 0)\r\ngoto fail;\r\nlast_token = token;\r\nfield = calloc(1, sizeof(*field));\r\nif (!field)\r\ngoto fail;\r\nfield->event = event;\r\nfor (;;) {\r\ntype = read_token(&token);\r\nif (type == EVENT_ITEM ||\r\n(type == EVENT_OP && strcmp(token, "*") == 0) ||\r\n(event->flags & EVENT_FL_ISFTRACE &&\r\ntype == EVENT_OP && strcmp(token, ".") == 0)) {\r\nif (strcmp(token, "*") == 0)\r\nfield->flags |= FIELD_IS_POINTER;\r\nif (field->type) {\r\nchar *new_type;\r\nnew_type = realloc(field->type,\r\nstrlen(field->type) +\r\nstrlen(last_token) + 2);\r\nif (!new_type) {\r\nfree(last_token);\r\ngoto fail;\r\n}\r\nfield->type = new_type;\r\nstrcat(field->type, " ");\r\nstrcat(field->type, last_token);\r\nfree(last_token);\r\n} else\r\nfield->type = last_token;\r\nlast_token = token;\r\ncontinue;\r\n}\r\nbreak;\r\n}\r\nif (!field->type) {\r\ndo_warning_event(event, "%s: no type found", __func__);\r\ngoto fail;\r\n}\r\nfield->name = field->alias = last_token;\r\nif (test_type(type, EVENT_OP))\r\ngoto fail;\r\nif (strcmp(token, "[") == 0) {\r\nenum event_type last_type = type;\r\nchar *brackets = token;\r\nchar *new_brackets;\r\nint len;\r\nfield->flags |= FIELD_IS_ARRAY;\r\ntype = read_token(&token);\r\nif (type == EVENT_ITEM)\r\nfield->arraylen = strtoul(token, NULL, 0);\r\nelse\r\nfield->arraylen = 0;\r\nwhile (strcmp(token, "]") != 0) {\r\nif (last_type == EVENT_ITEM &&\r\ntype == EVENT_ITEM)\r\nlen = 2;\r\nelse\r\nlen = 1;\r\nlast_type = type;\r\nnew_brackets = realloc(brackets,\r\nstrlen(brackets) +\r\nstrlen(token) + len);\r\nif (!new_brackets) {\r\nfree(brackets);\r\ngoto fail;\r\n}\r\nbrackets = new_brackets;\r\nif (len == 2)\r\nstrcat(brackets, " ");\r\nstrcat(brackets, token);\r\nfield->arraylen = strtoul(token, NULL, 0);\r\nfree_token(token);\r\ntype = read_token(&token);\r\nif (type == EVENT_NONE) {\r\ndo_warning_event(event, "failed to find token");\r\ngoto fail;\r\n}\r\n}\r\nfree_token(token);\r\nnew_brackets = realloc(brackets, strlen(brackets) + 2);\r\nif (!new_brackets) {\r\nfree(brackets);\r\ngoto fail;\r\n}\r\nbrackets = new_brackets;\r\nstrcat(brackets, "]");\r\ntype = read_token(&token);\r\nif (type == EVENT_ITEM) {\r\nchar *new_type;\r\nnew_type = realloc(field->type,\r\nstrlen(field->type) +\r\nstrlen(field->name) +\r\nstrlen(brackets) + 2);\r\nif (!new_type) {\r\nfree(brackets);\r\ngoto fail;\r\n}\r\nfield->type = new_type;\r\nstrcat(field->type, " ");\r\nstrcat(field->type, field->name);\r\nsize_dynamic = type_size(field->name);\r\nfree_token(field->name);\r\nstrcat(field->type, brackets);\r\nfield->name = field->alias = token;\r\ntype = read_token(&token);\r\n} else {\r\nchar *new_type;\r\nnew_type = realloc(field->type,\r\nstrlen(field->type) +\r\nstrlen(brackets) + 1);\r\nif (!new_type) {\r\nfree(brackets);\r\ngoto fail;\r\n}\r\nfield->type = new_type;\r\nstrcat(field->type, brackets);\r\n}\r\nfree(brackets);\r\n}\r\nif (field_is_string(field))\r\nfield->flags |= FIELD_IS_STRING;\r\nif (field_is_dynamic(field))\r\nfield->flags |= FIELD_IS_DYNAMIC;\r\nif (field_is_long(field))\r\nfield->flags |= FIELD_IS_LONG;\r\nif (test_type_token(type, token, EVENT_OP, ";"))\r\ngoto fail;\r\nfree_token(token);\r\nif (read_expected(EVENT_ITEM, "offset") < 0)\r\ngoto fail_expect;\r\nif (read_expected(EVENT_OP, ":") < 0)\r\ngoto fail_expect;\r\nif (read_expect_type(EVENT_ITEM, &token))\r\ngoto fail;\r\nfield->offset = strtoul(token, NULL, 0);\r\nfree_token(token);\r\nif (read_expected(EVENT_OP, ";") < 0)\r\ngoto fail_expect;\r\nif (read_expected(EVENT_ITEM, "size") < 0)\r\ngoto fail_expect;\r\nif (read_expected(EVENT_OP, ":") < 0)\r\ngoto fail_expect;\r\nif (read_expect_type(EVENT_ITEM, &token))\r\ngoto fail;\r\nfield->size = strtoul(token, NULL, 0);\r\nfree_token(token);\r\nif (read_expected(EVENT_OP, ";") < 0)\r\ngoto fail_expect;\r\ntype = read_token(&token);\r\nif (type != EVENT_NEWLINE) {\r\nif (test_type_token(type, token, EVENT_ITEM, "signed"))\r\ngoto fail;\r\nfree_token(token);\r\nif (read_expected(EVENT_OP, ":") < 0)\r\ngoto fail_expect;\r\nif (read_expect_type(EVENT_ITEM, &token))\r\ngoto fail;\r\nif (strtoul(token, NULL, 0))\r\nfield->flags |= FIELD_IS_SIGNED;\r\nfree_token(token);\r\nif (read_expected(EVENT_OP, ";") < 0)\r\ngoto fail_expect;\r\nif (read_expect_type(EVENT_NEWLINE, &token))\r\ngoto fail;\r\n}\r\nfree_token(token);\r\nif (field->flags & FIELD_IS_ARRAY) {\r\nif (field->arraylen)\r\nfield->elementsize = field->size / field->arraylen;\r\nelse if (field->flags & FIELD_IS_DYNAMIC)\r\nfield->elementsize = size_dynamic;\r\nelse if (field->flags & FIELD_IS_STRING)\r\nfield->elementsize = 1;\r\nelse if (field->flags & FIELD_IS_LONG)\r\nfield->elementsize = event->pevent ?\r\nevent->pevent->long_size :\r\nsizeof(long);\r\n} else\r\nfield->elementsize = field->size;\r\n*fields = field;\r\nfields = &field->next;\r\n} while (1);\r\nreturn 0;\r\nfail:\r\nfree_token(token);\r\nfail_expect:\r\nif (field) {\r\nfree(field->type);\r\nfree(field->name);\r\nfree(field);\r\n}\r\nreturn -1;\r\n}\r\nstatic int event_read_format(struct event_format *event)\r\n{\r\nchar *token;\r\nint ret;\r\nif (read_expected_item(EVENT_ITEM, "format") < 0)\r\nreturn -1;\r\nif (read_expected(EVENT_OP, ":") < 0)\r\nreturn -1;\r\nif (read_expect_type(EVENT_NEWLINE, &token))\r\ngoto fail;\r\nfree_token(token);\r\nret = event_read_fields(event, &event->format.common_fields);\r\nif (ret < 0)\r\nreturn ret;\r\nevent->format.nr_common = ret;\r\nret = event_read_fields(event, &event->format.fields);\r\nif (ret < 0)\r\nreturn ret;\r\nevent->format.nr_fields = ret;\r\nreturn 0;\r\nfail:\r\nfree_token(token);\r\nreturn -1;\r\n}\r\nstatic enum event_type\r\nprocess_arg(struct event_format *event, struct print_arg *arg, char **tok)\r\n{\r\nenum event_type type;\r\nchar *token;\r\ntype = read_token(&token);\r\n*tok = token;\r\nreturn process_arg_token(event, arg, tok, type);\r\n}\r\nstatic enum event_type\r\nprocess_field_arg(struct event_format *event, struct print_arg *arg, char **tok)\r\n{\r\nenum event_type type;\r\ntype = process_arg(event, arg, tok);\r\nwhile (type == EVENT_OP) {\r\ntype = process_op(event, arg, tok);\r\n}\r\nreturn type;\r\n}\r\nstatic enum event_type\r\nprocess_cond(struct event_format *event, struct print_arg *top, char **tok)\r\n{\r\nstruct print_arg *arg, *left, *right;\r\nenum event_type type;\r\nchar *token = NULL;\r\narg = alloc_arg();\r\nleft = alloc_arg();\r\nright = alloc_arg();\r\nif (!arg || !left || !right) {\r\ndo_warning_event(event, "%s: not enough memory!", __func__);\r\nfree_arg(left);\r\nfree_arg(right);\r\ngoto out_free;\r\n}\r\narg->type = PRINT_OP;\r\narg->op.left = left;\r\narg->op.right = right;\r\n*tok = NULL;\r\ntype = process_arg(event, left, &token);\r\nagain:\r\nif (type == EVENT_ERROR)\r\ngoto out_free;\r\nif (type == EVENT_OP && strcmp(token, ":") != 0) {\r\ntype = process_op(event, left, &token);\r\ngoto again;\r\n}\r\nif (test_type_token(type, token, EVENT_OP, ":"))\r\ngoto out_free;\r\narg->op.op = token;\r\ntype = process_arg(event, right, &token);\r\ntop->op.right = arg;\r\n*tok = token;\r\nreturn type;\r\nout_free:\r\ntop->op.right = NULL;\r\nfree_token(token);\r\nfree_arg(arg);\r\nreturn EVENT_ERROR;\r\n}\r\nstatic enum event_type\r\nprocess_array(struct event_format *event, struct print_arg *top, char **tok)\r\n{\r\nstruct print_arg *arg;\r\nenum event_type type;\r\nchar *token = NULL;\r\narg = alloc_arg();\r\nif (!arg) {\r\ndo_warning_event(event, "%s: not enough memory!", __func__);\r\n*tok = NULL;\r\nreturn EVENT_ERROR;\r\n}\r\n*tok = NULL;\r\ntype = process_arg(event, arg, &token);\r\nif (test_type_token(type, token, EVENT_OP, "]"))\r\ngoto out_free;\r\ntop->op.right = arg;\r\nfree_token(token);\r\ntype = read_token_item(&token);\r\n*tok = token;\r\nreturn type;\r\nout_free:\r\nfree_token(token);\r\nfree_arg(arg);\r\nreturn EVENT_ERROR;\r\n}\r\nstatic int get_op_prio(char *op)\r\n{\r\nif (!op[1]) {\r\nswitch (op[0]) {\r\ncase '~':\r\ncase '!':\r\nreturn 4;\r\ncase '*':\r\ncase '/':\r\ncase '%':\r\nreturn 6;\r\ncase '+':\r\ncase '-':\r\nreturn 7;\r\ncase '<':\r\ncase '>':\r\nreturn 9;\r\ncase '&':\r\nreturn 11;\r\ncase '^':\r\nreturn 12;\r\ncase '|':\r\nreturn 13;\r\ncase '?':\r\nreturn 16;\r\ndefault:\r\ndo_warning("unknown op '%c'", op[0]);\r\nreturn -1;\r\n}\r\n} else {\r\nif (strcmp(op, "++") == 0 ||\r\nstrcmp(op, "--") == 0) {\r\nreturn 3;\r\n} else if (strcmp(op, ">>") == 0 ||\r\nstrcmp(op, "<<") == 0) {\r\nreturn 8;\r\n} else if (strcmp(op, ">=") == 0 ||\r\nstrcmp(op, "<=") == 0) {\r\nreturn 9;\r\n} else if (strcmp(op, "==") == 0 ||\r\nstrcmp(op, "!=") == 0) {\r\nreturn 10;\r\n} else if (strcmp(op, "&&") == 0) {\r\nreturn 14;\r\n} else if (strcmp(op, "||") == 0) {\r\nreturn 15;\r\n} else {\r\ndo_warning("unknown op '%s'", op);\r\nreturn -1;\r\n}\r\n}\r\n}\r\nstatic int set_op_prio(struct print_arg *arg)\r\n{\r\nif (!arg->op.left || arg->op.left->type == PRINT_NULL)\r\narg->op.prio = 0;\r\nelse\r\narg->op.prio = get_op_prio(arg->op.op);\r\nreturn arg->op.prio;\r\n}\r\nstatic enum event_type\r\nprocess_op(struct event_format *event, struct print_arg *arg, char **tok)\r\n{\r\nstruct print_arg *left, *right = NULL;\r\nenum event_type type;\r\nchar *token;\r\ntoken = *tok;\r\nif (arg->type == PRINT_OP && !arg->op.left) {\r\nif (token[1]) {\r\ndo_warning_event(event, "bad op token %s", token);\r\ngoto out_free;\r\n}\r\nswitch (token[0]) {\r\ncase '~':\r\ncase '!':\r\ncase '+':\r\ncase '-':\r\nbreak;\r\ndefault:\r\ndo_warning_event(event, "bad op token %s", token);\r\ngoto out_free;\r\n}\r\nleft = alloc_arg();\r\nif (!left)\r\ngoto out_warn_free;\r\nleft->type = PRINT_NULL;\r\narg->op.left = left;\r\nright = alloc_arg();\r\nif (!right)\r\ngoto out_warn_free;\r\narg->op.right = right;\r\n*tok = NULL;\r\ntype = process_arg(event, right, tok);\r\n} else if (strcmp(token, "?") == 0) {\r\nleft = alloc_arg();\r\nif (!left)\r\ngoto out_warn_free;\r\n*left = *arg;\r\narg->type = PRINT_OP;\r\narg->op.op = token;\r\narg->op.left = left;\r\narg->op.prio = 0;\r\ntype = process_cond(event, arg, tok);\r\n} else if (strcmp(token, ">>") == 0 ||\r\nstrcmp(token, "<<") == 0 ||\r\nstrcmp(token, "&") == 0 ||\r\nstrcmp(token, "|") == 0 ||\r\nstrcmp(token, "&&") == 0 ||\r\nstrcmp(token, "||") == 0 ||\r\nstrcmp(token, "-") == 0 ||\r\nstrcmp(token, "+") == 0 ||\r\nstrcmp(token, "*") == 0 ||\r\nstrcmp(token, "^") == 0 ||\r\nstrcmp(token, "/") == 0 ||\r\nstrcmp(token, "%") == 0 ||\r\nstrcmp(token, "<") == 0 ||\r\nstrcmp(token, ">") == 0 ||\r\nstrcmp(token, "<=") == 0 ||\r\nstrcmp(token, ">=") == 0 ||\r\nstrcmp(token, "==") == 0 ||\r\nstrcmp(token, "!=") == 0) {\r\nleft = alloc_arg();\r\nif (!left)\r\ngoto out_warn_free;\r\n*left = *arg;\r\narg->type = PRINT_OP;\r\narg->op.op = token;\r\narg->op.left = left;\r\narg->op.right = NULL;\r\nif (set_op_prio(arg) == -1) {\r\nevent->flags |= EVENT_FL_FAILED;\r\narg->op.op = NULL;\r\ngoto out_free;\r\n}\r\ntype = read_token_item(&token);\r\n*tok = token;\r\nif ((strcmp(arg->op.op, "*") == 0) &&\r\ntype == EVENT_DELIM && (strcmp(token, ")") == 0)) {\r\nchar *new_atom;\r\nif (left->type != PRINT_ATOM) {\r\ndo_warning_event(event, "bad pointer type");\r\ngoto out_free;\r\n}\r\nnew_atom = realloc(left->atom.atom,\r\nstrlen(left->atom.atom) + 3);\r\nif (!new_atom)\r\ngoto out_warn_free;\r\nleft->atom.atom = new_atom;\r\nstrcat(left->atom.atom, " *");\r\nfree(arg->op.op);\r\n*arg = *left;\r\nfree(left);\r\nreturn type;\r\n}\r\nright = alloc_arg();\r\nif (!right)\r\ngoto out_warn_free;\r\ntype = process_arg_token(event, right, tok, type);\r\nif (type == EVENT_ERROR) {\r\nfree_arg(right);\r\ntoken = NULL;\r\ngoto out_free;\r\n}\r\nif (right->type == PRINT_OP &&\r\nget_op_prio(arg->op.op) < get_op_prio(right->op.op)) {\r\nstruct print_arg tmp;\r\narg->op.right = right->op.left;\r\ntmp = *arg;\r\n*arg = *right;\r\n*right = tmp;\r\narg->op.left = right;\r\n} else {\r\narg->op.right = right;\r\n}\r\n} else if (strcmp(token, "[") == 0) {\r\nleft = alloc_arg();\r\nif (!left)\r\ngoto out_warn_free;\r\n*left = *arg;\r\narg->type = PRINT_OP;\r\narg->op.op = token;\r\narg->op.left = left;\r\narg->op.prio = 0;\r\ntype = process_array(event, arg, tok);\r\n} else {\r\ndo_warning_event(event, "unknown op '%s'", token);\r\nevent->flags |= EVENT_FL_FAILED;\r\ngoto out_free;\r\n}\r\nif (type == EVENT_OP && strcmp(*tok, ":") != 0) {\r\nint prio;\r\nprio = get_op_prio(*tok);\r\nif (prio > arg->op.prio)\r\nreturn process_op(event, arg, tok);\r\nreturn process_op(event, right, tok);\r\n}\r\nreturn type;\r\nout_warn_free:\r\ndo_warning_event(event, "%s: not enough memory!", __func__);\r\nout_free:\r\nfree_token(token);\r\n*tok = NULL;\r\nreturn EVENT_ERROR;\r\n}\r\nstatic enum event_type\r\nprocess_entry(struct event_format *event __maybe_unused, struct print_arg *arg,\r\nchar **tok)\r\n{\r\nenum event_type type;\r\nchar *field;\r\nchar *token;\r\nif (read_expected(EVENT_OP, "->") < 0)\r\ngoto out_err;\r\nif (read_expect_type(EVENT_ITEM, &token) < 0)\r\ngoto out_free;\r\nfield = token;\r\narg->type = PRINT_FIELD;\r\narg->field.name = field;\r\nif (is_flag_field) {\r\narg->field.field = pevent_find_any_field(event, arg->field.name);\r\narg->field.field->flags |= FIELD_IS_FLAG;\r\nis_flag_field = 0;\r\n} else if (is_symbolic_field) {\r\narg->field.field = pevent_find_any_field(event, arg->field.name);\r\narg->field.field->flags |= FIELD_IS_SYMBOLIC;\r\nis_symbolic_field = 0;\r\n}\r\ntype = read_token(&token);\r\n*tok = token;\r\nreturn type;\r\nout_free:\r\nfree_token(token);\r\nout_err:\r\n*tok = NULL;\r\nreturn EVENT_ERROR;\r\n}\r\nstatic int alloc_and_process_delim(struct event_format *event, char *next_token,\r\nstruct print_arg **print_arg)\r\n{\r\nstruct print_arg *field;\r\nenum event_type type;\r\nchar *token;\r\nint ret = 0;\r\nfield = alloc_arg();\r\nif (!field) {\r\ndo_warning_event(event, "%s: not enough memory!", __func__);\r\nerrno = ENOMEM;\r\nreturn -1;\r\n}\r\ntype = process_arg(event, field, &token);\r\nif (test_type_token(type, token, EVENT_DELIM, next_token)) {\r\nerrno = EINVAL;\r\nret = -1;\r\nfree_arg(field);\r\ngoto out_free_token;\r\n}\r\n*print_arg = field;\r\nout_free_token:\r\nfree_token(token);\r\nreturn ret;\r\n}\r\nstatic unsigned long long\r\neval_type_str(unsigned long long val, const char *type, int pointer)\r\n{\r\nint sign = 0;\r\nchar *ref;\r\nint len;\r\nlen = strlen(type);\r\nif (pointer) {\r\nif (type[len-1] != '*') {\r\ndo_warning("pointer expected with non pointer type");\r\nreturn val;\r\n}\r\nref = malloc(len);\r\nif (!ref) {\r\ndo_warning("%s: not enough memory!", __func__);\r\nreturn val;\r\n}\r\nmemcpy(ref, type, len);\r\nref[len - 2] = 0;\r\nval = eval_type_str(val, ref, 0);\r\nfree(ref);\r\nreturn val;\r\n}\r\nif (type[len - 1] == '*')\r\nreturn val;\r\nif (strncmp(type, "struct", 6) == 0)\r\nreturn val;\r\nif (strcmp(type, "u8") == 0)\r\nreturn val & 0xff;\r\nif (strcmp(type, "u16") == 0)\r\nreturn val & 0xffff;\r\nif (strcmp(type, "u32") == 0)\r\nreturn val & 0xffffffff;\r\nif (strcmp(type, "u64") == 0 ||\r\nstrcmp(type, "s64"))\r\nreturn val;\r\nif (strcmp(type, "s8") == 0)\r\nreturn (unsigned long long)(char)val & 0xff;\r\nif (strcmp(type, "s16") == 0)\r\nreturn (unsigned long long)(short)val & 0xffff;\r\nif (strcmp(type, "s32") == 0)\r\nreturn (unsigned long long)(int)val & 0xffffffff;\r\nif (strncmp(type, "unsigned ", 9) == 0) {\r\nsign = 0;\r\ntype += 9;\r\n}\r\nif (strcmp(type, "char") == 0) {\r\nif (sign)\r\nreturn (unsigned long long)(char)val & 0xff;\r\nelse\r\nreturn val & 0xff;\r\n}\r\nif (strcmp(type, "short") == 0) {\r\nif (sign)\r\nreturn (unsigned long long)(short)val & 0xffff;\r\nelse\r\nreturn val & 0xffff;\r\n}\r\nif (strcmp(type, "int") == 0) {\r\nif (sign)\r\nreturn (unsigned long long)(int)val & 0xffffffff;\r\nelse\r\nreturn val & 0xffffffff;\r\n}\r\nreturn val;\r\n}\r\nstatic unsigned long long\r\neval_type(unsigned long long val, struct print_arg *arg, int pointer)\r\n{\r\nif (arg->type != PRINT_TYPE) {\r\ndo_warning("expected type argument");\r\nreturn 0;\r\n}\r\nreturn eval_type_str(val, arg->typecast.type, pointer);\r\n}\r\nstatic int arg_num_eval(struct print_arg *arg, long long *val)\r\n{\r\nlong long left, right;\r\nint ret = 1;\r\nswitch (arg->type) {\r\ncase PRINT_ATOM:\r\n*val = strtoll(arg->atom.atom, NULL, 0);\r\nbreak;\r\ncase PRINT_TYPE:\r\nret = arg_num_eval(arg->typecast.item, val);\r\nif (!ret)\r\nbreak;\r\n*val = eval_type(*val, arg, 0);\r\nbreak;\r\ncase PRINT_OP:\r\nswitch (arg->op.op[0]) {\r\ncase '|':\r\nret = arg_num_eval(arg->op.left, &left);\r\nif (!ret)\r\nbreak;\r\nret = arg_num_eval(arg->op.right, &right);\r\nif (!ret)\r\nbreak;\r\nif (arg->op.op[1])\r\n*val = left || right;\r\nelse\r\n*val = left | right;\r\nbreak;\r\ncase '&':\r\nret = arg_num_eval(arg->op.left, &left);\r\nif (!ret)\r\nbreak;\r\nret = arg_num_eval(arg->op.right, &right);\r\nif (!ret)\r\nbreak;\r\nif (arg->op.op[1])\r\n*val = left && right;\r\nelse\r\n*val = left & right;\r\nbreak;\r\ncase '<':\r\nret = arg_num_eval(arg->op.left, &left);\r\nif (!ret)\r\nbreak;\r\nret = arg_num_eval(arg->op.right, &right);\r\nif (!ret)\r\nbreak;\r\nswitch (arg->op.op[1]) {\r\ncase 0:\r\n*val = left < right;\r\nbreak;\r\ncase '<':\r\n*val = left << right;\r\nbreak;\r\ncase '=':\r\n*val = left <= right;\r\nbreak;\r\ndefault:\r\ndo_warning("unknown op '%s'", arg->op.op);\r\nret = 0;\r\n}\r\nbreak;\r\ncase '>':\r\nret = arg_num_eval(arg->op.left, &left);\r\nif (!ret)\r\nbreak;\r\nret = arg_num_eval(arg->op.right, &right);\r\nif (!ret)\r\nbreak;\r\nswitch (arg->op.op[1]) {\r\ncase 0:\r\n*val = left > right;\r\nbreak;\r\ncase '>':\r\n*val = left >> right;\r\nbreak;\r\ncase '=':\r\n*val = left >= right;\r\nbreak;\r\ndefault:\r\ndo_warning("unknown op '%s'", arg->op.op);\r\nret = 0;\r\n}\r\nbreak;\r\ncase '=':\r\nret = arg_num_eval(arg->op.left, &left);\r\nif (!ret)\r\nbreak;\r\nret = arg_num_eval(arg->op.right, &right);\r\nif (!ret)\r\nbreak;\r\nif (arg->op.op[1] != '=') {\r\ndo_warning("unknown op '%s'", arg->op.op);\r\nret = 0;\r\n} else\r\n*val = left == right;\r\nbreak;\r\ncase '!':\r\nret = arg_num_eval(arg->op.left, &left);\r\nif (!ret)\r\nbreak;\r\nret = arg_num_eval(arg->op.right, &right);\r\nif (!ret)\r\nbreak;\r\nswitch (arg->op.op[1]) {\r\ncase '=':\r\n*val = left != right;\r\nbreak;\r\ndefault:\r\ndo_warning("unknown op '%s'", arg->op.op);\r\nret = 0;\r\n}\r\nbreak;\r\ncase '-':\r\nif (arg->op.left->type == PRINT_NULL)\r\nleft = 0;\r\nelse\r\nret = arg_num_eval(arg->op.left, &left);\r\nif (!ret)\r\nbreak;\r\nret = arg_num_eval(arg->op.right, &right);\r\nif (!ret)\r\nbreak;\r\n*val = left - right;\r\nbreak;\r\ncase '+':\r\nif (arg->op.left->type == PRINT_NULL)\r\nleft = 0;\r\nelse\r\nret = arg_num_eval(arg->op.left, &left);\r\nif (!ret)\r\nbreak;\r\nret = arg_num_eval(arg->op.right, &right);\r\nif (!ret)\r\nbreak;\r\n*val = left + right;\r\nbreak;\r\ncase '~':\r\nret = arg_num_eval(arg->op.right, &right);\r\nif (!ret)\r\nbreak;\r\n*val = ~right;\r\nbreak;\r\ndefault:\r\ndo_warning("unknown op '%s'", arg->op.op);\r\nret = 0;\r\n}\r\nbreak;\r\ncase PRINT_NULL:\r\ncase PRINT_FIELD ... PRINT_SYMBOL:\r\ncase PRINT_STRING:\r\ncase PRINT_BSTRING:\r\ncase PRINT_BITMASK:\r\ndefault:\r\ndo_warning("invalid eval type %d", arg->type);\r\nret = 0;\r\n}\r\nreturn ret;\r\n}\r\nstatic char *arg_eval (struct print_arg *arg)\r\n{\r\nlong long val;\r\nstatic char buf[20];\r\nswitch (arg->type) {\r\ncase PRINT_ATOM:\r\nreturn arg->atom.atom;\r\ncase PRINT_TYPE:\r\nreturn arg_eval(arg->typecast.item);\r\ncase PRINT_OP:\r\nif (!arg_num_eval(arg, &val))\r\nbreak;\r\nsprintf(buf, "%lld", val);\r\nreturn buf;\r\ncase PRINT_NULL:\r\ncase PRINT_FIELD ... PRINT_SYMBOL:\r\ncase PRINT_STRING:\r\ncase PRINT_BSTRING:\r\ncase PRINT_BITMASK:\r\ndefault:\r\ndo_warning("invalid eval type %d", arg->type);\r\nbreak;\r\n}\r\nreturn NULL;\r\n}\r\nstatic enum event_type\r\nprocess_fields(struct event_format *event, struct print_flag_sym **list, char **tok)\r\n{\r\nenum event_type type;\r\nstruct print_arg *arg = NULL;\r\nstruct print_flag_sym *field;\r\nchar *token = *tok;\r\nchar *value;\r\ndo {\r\nfree_token(token);\r\ntype = read_token_item(&token);\r\nif (test_type_token(type, token, EVENT_OP, "{"))\r\nbreak;\r\narg = alloc_arg();\r\nif (!arg)\r\ngoto out_free;\r\nfree_token(token);\r\ntype = process_arg(event, arg, &token);\r\nif (type == EVENT_OP)\r\ntype = process_op(event, arg, &token);\r\nif (type == EVENT_ERROR)\r\ngoto out_free;\r\nif (test_type_token(type, token, EVENT_DELIM, ","))\r\ngoto out_free;\r\nfield = calloc(1, sizeof(*field));\r\nif (!field)\r\ngoto out_free;\r\nvalue = arg_eval(arg);\r\nif (value == NULL)\r\ngoto out_free_field;\r\nfield->value = strdup(value);\r\nif (field->value == NULL)\r\ngoto out_free_field;\r\nfree_arg(arg);\r\narg = alloc_arg();\r\nif (!arg)\r\ngoto out_free;\r\nfree_token(token);\r\ntype = process_arg(event, arg, &token);\r\nif (test_type_token(type, token, EVENT_OP, "}"))\r\ngoto out_free_field;\r\nvalue = arg_eval(arg);\r\nif (value == NULL)\r\ngoto out_free_field;\r\nfield->str = strdup(value);\r\nif (field->str == NULL)\r\ngoto out_free_field;\r\nfree_arg(arg);\r\narg = NULL;\r\n*list = field;\r\nlist = &field->next;\r\nfree_token(token);\r\ntype = read_token_item(&token);\r\n} while (type == EVENT_DELIM && strcmp(token, ",") == 0);\r\n*tok = token;\r\nreturn type;\r\nout_free_field:\r\nfree_flag_sym(field);\r\nout_free:\r\nfree_arg(arg);\r\nfree_token(token);\r\n*tok = NULL;\r\nreturn EVENT_ERROR;\r\n}\r\nstatic enum event_type\r\nprocess_flags(struct event_format *event, struct print_arg *arg, char **tok)\r\n{\r\nstruct print_arg *field;\r\nenum event_type type;\r\nchar *token = NULL;\r\nmemset(arg, 0, sizeof(*arg));\r\narg->type = PRINT_FLAGS;\r\nfield = alloc_arg();\r\nif (!field) {\r\ndo_warning_event(event, "%s: not enough memory!", __func__);\r\ngoto out_free;\r\n}\r\ntype = process_field_arg(event, field, &token);\r\nwhile (type == EVENT_OP)\r\ntype = process_op(event, field, &token);\r\nif (test_type_token(type, token, EVENT_DELIM, ","))\r\ngoto out_free_field;\r\nfree_token(token);\r\narg->flags.field = field;\r\ntype = read_token_item(&token);\r\nif (event_item_type(type)) {\r\narg->flags.delim = token;\r\ntype = read_token_item(&token);\r\n}\r\nif (test_type_token(type, token, EVENT_DELIM, ","))\r\ngoto out_free;\r\ntype = process_fields(event, &arg->flags.flags, &token);\r\nif (test_type_token(type, token, EVENT_DELIM, ")"))\r\ngoto out_free;\r\nfree_token(token);\r\ntype = read_token_item(tok);\r\nreturn type;\r\nout_free_field:\r\nfree_arg(field);\r\nout_free:\r\nfree_token(token);\r\n*tok = NULL;\r\nreturn EVENT_ERROR;\r\n}\r\nstatic enum event_type\r\nprocess_symbols(struct event_format *event, struct print_arg *arg, char **tok)\r\n{\r\nstruct print_arg *field;\r\nenum event_type type;\r\nchar *token = NULL;\r\nmemset(arg, 0, sizeof(*arg));\r\narg->type = PRINT_SYMBOL;\r\nfield = alloc_arg();\r\nif (!field) {\r\ndo_warning_event(event, "%s: not enough memory!", __func__);\r\ngoto out_free;\r\n}\r\ntype = process_field_arg(event, field, &token);\r\nif (test_type_token(type, token, EVENT_DELIM, ","))\r\ngoto out_free_field;\r\narg->symbol.field = field;\r\ntype = process_fields(event, &arg->symbol.symbols, &token);\r\nif (test_type_token(type, token, EVENT_DELIM, ")"))\r\ngoto out_free;\r\nfree_token(token);\r\ntype = read_token_item(tok);\r\nreturn type;\r\nout_free_field:\r\nfree_arg(field);\r\nout_free:\r\nfree_token(token);\r\n*tok = NULL;\r\nreturn EVENT_ERROR;\r\n}\r\nstatic enum event_type\r\nprocess_hex(struct event_format *event, struct print_arg *arg, char **tok)\r\n{\r\nmemset(arg, 0, sizeof(*arg));\r\narg->type = PRINT_HEX;\r\nif (alloc_and_process_delim(event, ",", &arg->hex.field))\r\ngoto out;\r\nif (alloc_and_process_delim(event, ")", &arg->hex.size))\r\ngoto free_field;\r\nreturn read_token_item(tok);\r\nfree_field:\r\nfree_arg(arg->hex.field);\r\narg->hex.field = NULL;\r\nout:\r\n*tok = NULL;\r\nreturn EVENT_ERROR;\r\n}\r\nstatic enum event_type\r\nprocess_int_array(struct event_format *event, struct print_arg *arg, char **tok)\r\n{\r\nmemset(arg, 0, sizeof(*arg));\r\narg->type = PRINT_INT_ARRAY;\r\nif (alloc_and_process_delim(event, ",", &arg->int_array.field))\r\ngoto out;\r\nif (alloc_and_process_delim(event, ",", &arg->int_array.count))\r\ngoto free_field;\r\nif (alloc_and_process_delim(event, ")", &arg->int_array.el_size))\r\ngoto free_size;\r\nreturn read_token_item(tok);\r\nfree_size:\r\nfree_arg(arg->int_array.count);\r\narg->int_array.count = NULL;\r\nfree_field:\r\nfree_arg(arg->int_array.field);\r\narg->int_array.field = NULL;\r\nout:\r\n*tok = NULL;\r\nreturn EVENT_ERROR;\r\n}\r\nstatic enum event_type\r\nprocess_dynamic_array(struct event_format *event, struct print_arg *arg, char **tok)\r\n{\r\nstruct format_field *field;\r\nenum event_type type;\r\nchar *token;\r\nmemset(arg, 0, sizeof(*arg));\r\narg->type = PRINT_DYNAMIC_ARRAY;\r\ntype = read_token(&token);\r\n*tok = token;\r\nif (type != EVENT_ITEM)\r\ngoto out_free;\r\nfield = pevent_find_field(event, token);\r\nif (!field)\r\ngoto out_free;\r\narg->dynarray.field = field;\r\narg->dynarray.index = 0;\r\nif (read_expected(EVENT_DELIM, ")") < 0)\r\ngoto out_free;\r\nfree_token(token);\r\ntype = read_token_item(&token);\r\n*tok = token;\r\nif (type != EVENT_OP || strcmp(token, "[") != 0)\r\nreturn type;\r\nfree_token(token);\r\narg = alloc_arg();\r\nif (!arg) {\r\ndo_warning_event(event, "%s: not enough memory!", __func__);\r\n*tok = NULL;\r\nreturn EVENT_ERROR;\r\n}\r\ntype = process_arg(event, arg, &token);\r\nif (type == EVENT_ERROR)\r\ngoto out_free_arg;\r\nif (!test_type_token(type, token, EVENT_OP, "]"))\r\ngoto out_free_arg;\r\nfree_token(token);\r\ntype = read_token_item(tok);\r\nreturn type;\r\nout_free_arg:\r\nfree_arg(arg);\r\nout_free:\r\nfree_token(token);\r\n*tok = NULL;\r\nreturn EVENT_ERROR;\r\n}\r\nstatic enum event_type\r\nprocess_dynamic_array_len(struct event_format *event, struct print_arg *arg,\r\nchar **tok)\r\n{\r\nstruct format_field *field;\r\nenum event_type type;\r\nchar *token;\r\nif (read_expect_type(EVENT_ITEM, &token) < 0)\r\ngoto out_free;\r\narg->type = PRINT_DYNAMIC_ARRAY_LEN;\r\nfield = pevent_find_field(event, token);\r\nif (!field)\r\ngoto out_free;\r\narg->dynarray.field = field;\r\narg->dynarray.index = 0;\r\nif (read_expected(EVENT_DELIM, ")") < 0)\r\ngoto out_err;\r\ntype = read_token(&token);\r\n*tok = token;\r\nreturn type;\r\nout_free:\r\nfree_token(token);\r\nout_err:\r\n*tok = NULL;\r\nreturn EVENT_ERROR;\r\n}\r\nstatic enum event_type\r\nprocess_paren(struct event_format *event, struct print_arg *arg, char **tok)\r\n{\r\nstruct print_arg *item_arg;\r\nenum event_type type;\r\nchar *token;\r\ntype = process_arg(event, arg, &token);\r\nif (type == EVENT_ERROR)\r\ngoto out_free;\r\nif (type == EVENT_OP)\r\ntype = process_op(event, arg, &token);\r\nif (type == EVENT_ERROR)\r\ngoto out_free;\r\nif (test_type_token(type, token, EVENT_DELIM, ")"))\r\ngoto out_free;\r\nfree_token(token);\r\ntype = read_token_item(&token);\r\nif (event_item_type(type) ||\r\n(type == EVENT_DELIM && strcmp(token, "(") == 0)) {\r\nif (arg->type != PRINT_ATOM) {\r\ndo_warning_event(event, "previous needed to be PRINT_ATOM");\r\ngoto out_free;\r\n}\r\nitem_arg = alloc_arg();\r\nif (!item_arg) {\r\ndo_warning_event(event, "%s: not enough memory!",\r\n__func__);\r\ngoto out_free;\r\n}\r\narg->type = PRINT_TYPE;\r\narg->typecast.type = arg->atom.atom;\r\narg->typecast.item = item_arg;\r\ntype = process_arg_token(event, item_arg, &token, type);\r\n}\r\n*tok = token;\r\nreturn type;\r\nout_free:\r\nfree_token(token);\r\n*tok = NULL;\r\nreturn EVENT_ERROR;\r\n}\r\nstatic enum event_type\r\nprocess_str(struct event_format *event __maybe_unused, struct print_arg *arg,\r\nchar **tok)\r\n{\r\nenum event_type type;\r\nchar *token;\r\nif (read_expect_type(EVENT_ITEM, &token) < 0)\r\ngoto out_free;\r\narg->type = PRINT_STRING;\r\narg->string.string = token;\r\narg->string.offset = -1;\r\nif (read_expected(EVENT_DELIM, ")") < 0)\r\ngoto out_err;\r\ntype = read_token(&token);\r\n*tok = token;\r\nreturn type;\r\nout_free:\r\nfree_token(token);\r\nout_err:\r\n*tok = NULL;\r\nreturn EVENT_ERROR;\r\n}\r\nstatic enum event_type\r\nprocess_bitmask(struct event_format *event __maybe_unused, struct print_arg *arg,\r\nchar **tok)\r\n{\r\nenum event_type type;\r\nchar *token;\r\nif (read_expect_type(EVENT_ITEM, &token) < 0)\r\ngoto out_free;\r\narg->type = PRINT_BITMASK;\r\narg->bitmask.bitmask = token;\r\narg->bitmask.offset = -1;\r\nif (read_expected(EVENT_DELIM, ")") < 0)\r\ngoto out_err;\r\ntype = read_token(&token);\r\n*tok = token;\r\nreturn type;\r\nout_free:\r\nfree_token(token);\r\nout_err:\r\n*tok = NULL;\r\nreturn EVENT_ERROR;\r\n}\r\nstatic struct pevent_function_handler *\r\nfind_func_handler(struct pevent *pevent, char *func_name)\r\n{\r\nstruct pevent_function_handler *func;\r\nif (!pevent)\r\nreturn NULL;\r\nfor (func = pevent->func_handlers; func; func = func->next) {\r\nif (strcmp(func->name, func_name) == 0)\r\nbreak;\r\n}\r\nreturn func;\r\n}\r\nstatic void remove_func_handler(struct pevent *pevent, char *func_name)\r\n{\r\nstruct pevent_function_handler *func;\r\nstruct pevent_function_handler **next;\r\nnext = &pevent->func_handlers;\r\nwhile ((func = *next)) {\r\nif (strcmp(func->name, func_name) == 0) {\r\n*next = func->next;\r\nfree_func_handle(func);\r\nbreak;\r\n}\r\nnext = &func->next;\r\n}\r\n}\r\nstatic enum event_type\r\nprocess_func_handler(struct event_format *event, struct pevent_function_handler *func,\r\nstruct print_arg *arg, char **tok)\r\n{\r\nstruct print_arg **next_arg;\r\nstruct print_arg *farg;\r\nenum event_type type;\r\nchar *token;\r\nint i;\r\narg->type = PRINT_FUNC;\r\narg->func.func = func;\r\n*tok = NULL;\r\nnext_arg = &(arg->func.args);\r\nfor (i = 0; i < func->nr_args; i++) {\r\nfarg = alloc_arg();\r\nif (!farg) {\r\ndo_warning_event(event, "%s: not enough memory!",\r\n__func__);\r\nreturn EVENT_ERROR;\r\n}\r\ntype = process_arg(event, farg, &token);\r\nif (i < (func->nr_args - 1)) {\r\nif (type != EVENT_DELIM || strcmp(token, ",") != 0) {\r\ndo_warning_event(event,\r\n"Error: function '%s()' expects %d arguments but event %s only uses %d",\r\nfunc->name, func->nr_args,\r\nevent->name, i + 1);\r\ngoto err;\r\n}\r\n} else {\r\nif (type != EVENT_DELIM || strcmp(token, ")") != 0) {\r\ndo_warning_event(event,\r\n"Error: function '%s()' only expects %d arguments but event %s has more",\r\nfunc->name, func->nr_args, event->name);\r\ngoto err;\r\n}\r\n}\r\n*next_arg = farg;\r\nnext_arg = &(farg->next);\r\nfree_token(token);\r\n}\r\ntype = read_token(&token);\r\n*tok = token;\r\nreturn type;\r\nerr:\r\nfree_arg(farg);\r\nfree_token(token);\r\nreturn EVENT_ERROR;\r\n}\r\nstatic enum event_type\r\nprocess_function(struct event_format *event, struct print_arg *arg,\r\nchar *token, char **tok)\r\n{\r\nstruct pevent_function_handler *func;\r\nif (strcmp(token, "__print_flags") == 0) {\r\nfree_token(token);\r\nis_flag_field = 1;\r\nreturn process_flags(event, arg, tok);\r\n}\r\nif (strcmp(token, "__print_symbolic") == 0) {\r\nfree_token(token);\r\nis_symbolic_field = 1;\r\nreturn process_symbols(event, arg, tok);\r\n}\r\nif (strcmp(token, "__print_hex") == 0) {\r\nfree_token(token);\r\nreturn process_hex(event, arg, tok);\r\n}\r\nif (strcmp(token, "__print_array") == 0) {\r\nfree_token(token);\r\nreturn process_int_array(event, arg, tok);\r\n}\r\nif (strcmp(token, "__get_str") == 0) {\r\nfree_token(token);\r\nreturn process_str(event, arg, tok);\r\n}\r\nif (strcmp(token, "__get_bitmask") == 0) {\r\nfree_token(token);\r\nreturn process_bitmask(event, arg, tok);\r\n}\r\nif (strcmp(token, "__get_dynamic_array") == 0) {\r\nfree_token(token);\r\nreturn process_dynamic_array(event, arg, tok);\r\n}\r\nif (strcmp(token, "__get_dynamic_array_len") == 0) {\r\nfree_token(token);\r\nreturn process_dynamic_array_len(event, arg, tok);\r\n}\r\nfunc = find_func_handler(event->pevent, token);\r\nif (func) {\r\nfree_token(token);\r\nreturn process_func_handler(event, func, arg, tok);\r\n}\r\ndo_warning_event(event, "function %s not defined", token);\r\nfree_token(token);\r\nreturn EVENT_ERROR;\r\n}\r\nstatic enum event_type\r\nprocess_arg_token(struct event_format *event, struct print_arg *arg,\r\nchar **tok, enum event_type type)\r\n{\r\nchar *token;\r\nchar *atom;\r\ntoken = *tok;\r\nswitch (type) {\r\ncase EVENT_ITEM:\r\nif (strcmp(token, "REC") == 0) {\r\nfree_token(token);\r\ntype = process_entry(event, arg, &token);\r\nbreak;\r\n}\r\natom = token;\r\ntype = read_token_item(&token);\r\nif (type == EVENT_DELIM && strcmp(token, "(") == 0) {\r\nfree_token(token);\r\ntoken = NULL;\r\ntype = process_function(event, arg, atom, &token);\r\nbreak;\r\n}\r\nwhile (type == EVENT_ITEM) {\r\nchar *new_atom;\r\nnew_atom = realloc(atom,\r\nstrlen(atom) + strlen(token) + 2);\r\nif (!new_atom) {\r\nfree(atom);\r\n*tok = NULL;\r\nfree_token(token);\r\nreturn EVENT_ERROR;\r\n}\r\natom = new_atom;\r\nstrcat(atom, " ");\r\nstrcat(atom, token);\r\nfree_token(token);\r\ntype = read_token_item(&token);\r\n}\r\narg->type = PRINT_ATOM;\r\narg->atom.atom = atom;\r\nbreak;\r\ncase EVENT_DQUOTE:\r\ncase EVENT_SQUOTE:\r\narg->type = PRINT_ATOM;\r\narg->atom.atom = token;\r\ntype = read_token_item(&token);\r\nbreak;\r\ncase EVENT_DELIM:\r\nif (strcmp(token, "(") == 0) {\r\nfree_token(token);\r\ntype = process_paren(event, arg, &token);\r\nbreak;\r\n}\r\ncase EVENT_OP:\r\narg->type = PRINT_OP;\r\narg->op.op = token;\r\narg->op.left = NULL;\r\ntype = process_op(event, arg, &token);\r\nif (type == EVENT_ERROR)\r\narg->op.op = NULL;\r\nbreak;\r\ncase EVENT_ERROR ... EVENT_NEWLINE:\r\ndefault:\r\ndo_warning_event(event, "unexpected type %d", type);\r\nreturn EVENT_ERROR;\r\n}\r\n*tok = token;\r\nreturn type;\r\n}\r\nstatic int event_read_print_args(struct event_format *event, struct print_arg **list)\r\n{\r\nenum event_type type = EVENT_ERROR;\r\nstruct print_arg *arg;\r\nchar *token;\r\nint args = 0;\r\ndo {\r\nif (type == EVENT_NEWLINE) {\r\ntype = read_token_item(&token);\r\ncontinue;\r\n}\r\narg = alloc_arg();\r\nif (!arg) {\r\ndo_warning_event(event, "%s: not enough memory!",\r\n__func__);\r\nreturn -1;\r\n}\r\ntype = process_arg(event, arg, &token);\r\nif (type == EVENT_ERROR) {\r\nfree_token(token);\r\nfree_arg(arg);\r\nreturn -1;\r\n}\r\n*list = arg;\r\nargs++;\r\nif (type == EVENT_OP) {\r\ntype = process_op(event, arg, &token);\r\nfree_token(token);\r\nif (type == EVENT_ERROR) {\r\n*list = NULL;\r\nfree_arg(arg);\r\nreturn -1;\r\n}\r\nlist = &arg->next;\r\ncontinue;\r\n}\r\nif (type == EVENT_DELIM && strcmp(token, ",") == 0) {\r\nfree_token(token);\r\n*list = arg;\r\nlist = &arg->next;\r\ncontinue;\r\n}\r\nbreak;\r\n} while (type != EVENT_NONE);\r\nif (type != EVENT_NONE && type != EVENT_ERROR)\r\nfree_token(token);\r\nreturn args;\r\n}\r\nstatic int event_read_print(struct event_format *event)\r\n{\r\nenum event_type type;\r\nchar *token;\r\nint ret;\r\nif (read_expected_item(EVENT_ITEM, "print") < 0)\r\nreturn -1;\r\nif (read_expected(EVENT_ITEM, "fmt") < 0)\r\nreturn -1;\r\nif (read_expected(EVENT_OP, ":") < 0)\r\nreturn -1;\r\nif (read_expect_type(EVENT_DQUOTE, &token) < 0)\r\ngoto fail;\r\nconcat:\r\nevent->print_fmt.format = token;\r\nevent->print_fmt.args = NULL;\r\ntype = read_token_item(&token);\r\nif (type == EVENT_NONE)\r\nreturn 0;\r\nif (type == EVENT_DQUOTE) {\r\nchar *cat;\r\nif (asprintf(&cat, "%s%s", event->print_fmt.format, token) < 0)\r\ngoto fail;\r\nfree_token(token);\r\nfree_token(event->print_fmt.format);\r\nevent->print_fmt.format = NULL;\r\ntoken = cat;\r\ngoto concat;\r\n}\r\nif (test_type_token(type, token, EVENT_DELIM, ","))\r\ngoto fail;\r\nfree_token(token);\r\nret = event_read_print_args(event, &event->print_fmt.args);\r\nif (ret < 0)\r\nreturn -1;\r\nreturn ret;\r\nfail:\r\nfree_token(token);\r\nreturn -1;\r\n}\r\nstruct format_field *\r\npevent_find_common_field(struct event_format *event, const char *name)\r\n{\r\nstruct format_field *format;\r\nfor (format = event->format.common_fields;\r\nformat; format = format->next) {\r\nif (strcmp(format->name, name) == 0)\r\nbreak;\r\n}\r\nreturn format;\r\n}\r\nstruct format_field *\r\npevent_find_field(struct event_format *event, const char *name)\r\n{\r\nstruct format_field *format;\r\nfor (format = event->format.fields;\r\nformat; format = format->next) {\r\nif (strcmp(format->name, name) == 0)\r\nbreak;\r\n}\r\nreturn format;\r\n}\r\nstruct format_field *\r\npevent_find_any_field(struct event_format *event, const char *name)\r\n{\r\nstruct format_field *format;\r\nformat = pevent_find_common_field(event, name);\r\nif (format)\r\nreturn format;\r\nreturn pevent_find_field(event, name);\r\n}\r\nunsigned long long pevent_read_number(struct pevent *pevent,\r\nconst void *ptr, int size)\r\n{\r\nswitch (size) {\r\ncase 1:\r\nreturn *(unsigned char *)ptr;\r\ncase 2:\r\nreturn data2host2(pevent, ptr);\r\ncase 4:\r\nreturn data2host4(pevent, ptr);\r\ncase 8:\r\nreturn data2host8(pevent, ptr);\r\ndefault:\r\nreturn 0;\r\n}\r\n}\r\nint pevent_read_number_field(struct format_field *field, const void *data,\r\nunsigned long long *value)\r\n{\r\nif (!field)\r\nreturn -1;\r\nswitch (field->size) {\r\ncase 1:\r\ncase 2:\r\ncase 4:\r\ncase 8:\r\n*value = pevent_read_number(field->event->pevent,\r\ndata + field->offset, field->size);\r\nreturn 0;\r\ndefault:\r\nreturn -1;\r\n}\r\n}\r\nstatic int get_common_info(struct pevent *pevent,\r\nconst char *type, int *offset, int *size)\r\n{\r\nstruct event_format *event;\r\nstruct format_field *field;\r\nif (!pevent->events) {\r\ndo_warning("no event_list!");\r\nreturn -1;\r\n}\r\nevent = pevent->events[0];\r\nfield = pevent_find_common_field(event, type);\r\nif (!field)\r\nreturn -1;\r\n*offset = field->offset;\r\n*size = field->size;\r\nreturn 0;\r\n}\r\nstatic int __parse_common(struct pevent *pevent, void *data,\r\nint *size, int *offset, const char *name)\r\n{\r\nint ret;\r\nif (!*size) {\r\nret = get_common_info(pevent, name, offset, size);\r\nif (ret < 0)\r\nreturn ret;\r\n}\r\nreturn pevent_read_number(pevent, data + *offset, *size);\r\n}\r\nstatic int trace_parse_common_type(struct pevent *pevent, void *data)\r\n{\r\nreturn __parse_common(pevent, data,\r\n&pevent->type_size, &pevent->type_offset,\r\n"common_type");\r\n}\r\nstatic int parse_common_pid(struct pevent *pevent, void *data)\r\n{\r\nreturn __parse_common(pevent, data,\r\n&pevent->pid_size, &pevent->pid_offset,\r\n"common_pid");\r\n}\r\nstatic int parse_common_pc(struct pevent *pevent, void *data)\r\n{\r\nreturn __parse_common(pevent, data,\r\n&pevent->pc_size, &pevent->pc_offset,\r\n"common_preempt_count");\r\n}\r\nstatic int parse_common_flags(struct pevent *pevent, void *data)\r\n{\r\nreturn __parse_common(pevent, data,\r\n&pevent->flags_size, &pevent->flags_offset,\r\n"common_flags");\r\n}\r\nstatic int parse_common_lock_depth(struct pevent *pevent, void *data)\r\n{\r\nreturn __parse_common(pevent, data,\r\n&pevent->ld_size, &pevent->ld_offset,\r\n"common_lock_depth");\r\n}\r\nstatic int parse_common_migrate_disable(struct pevent *pevent, void *data)\r\n{\r\nreturn __parse_common(pevent, data,\r\n&pevent->ld_size, &pevent->ld_offset,\r\n"common_migrate_disable");\r\n}\r\nstruct event_format *pevent_find_event(struct pevent *pevent, int id)\r\n{\r\nstruct event_format **eventptr;\r\nstruct event_format key;\r\nstruct event_format *pkey = &key;\r\nif (pevent->last_event && pevent->last_event->id == id)\r\nreturn pevent->last_event;\r\nkey.id = id;\r\neventptr = bsearch(&pkey, pevent->events, pevent->nr_events,\r\nsizeof(*pevent->events), events_id_cmp);\r\nif (eventptr) {\r\npevent->last_event = *eventptr;\r\nreturn *eventptr;\r\n}\r\nreturn NULL;\r\n}\r\nstruct event_format *\r\npevent_find_event_by_name(struct pevent *pevent,\r\nconst char *sys, const char *name)\r\n{\r\nstruct event_format *event;\r\nint i;\r\nif (pevent->last_event &&\r\nstrcmp(pevent->last_event->name, name) == 0 &&\r\n(!sys || strcmp(pevent->last_event->system, sys) == 0))\r\nreturn pevent->last_event;\r\nfor (i = 0; i < pevent->nr_events; i++) {\r\nevent = pevent->events[i];\r\nif (strcmp(event->name, name) == 0) {\r\nif (!sys)\r\nbreak;\r\nif (strcmp(event->system, sys) == 0)\r\nbreak;\r\n}\r\n}\r\nif (i == pevent->nr_events)\r\nevent = NULL;\r\npevent->last_event = event;\r\nreturn event;\r\n}\r\nstatic unsigned long long\r\neval_num_arg(void *data, int size, struct event_format *event, struct print_arg *arg)\r\n{\r\nstruct pevent *pevent = event->pevent;\r\nunsigned long long val = 0;\r\nunsigned long long left, right;\r\nstruct print_arg *typearg = NULL;\r\nstruct print_arg *larg;\r\nunsigned long offset;\r\nunsigned int field_size;\r\nswitch (arg->type) {\r\ncase PRINT_NULL:\r\nreturn 0;\r\ncase PRINT_ATOM:\r\nreturn strtoull(arg->atom.atom, NULL, 0);\r\ncase PRINT_FIELD:\r\nif (!arg->field.field) {\r\narg->field.field = pevent_find_any_field(event, arg->field.name);\r\nif (!arg->field.field)\r\ngoto out_warning_field;\r\n}\r\nval = pevent_read_number(pevent, data + arg->field.field->offset,\r\narg->field.field->size);\r\nbreak;\r\ncase PRINT_FLAGS:\r\ncase PRINT_SYMBOL:\r\ncase PRINT_INT_ARRAY:\r\ncase PRINT_HEX:\r\nbreak;\r\ncase PRINT_TYPE:\r\nval = eval_num_arg(data, size, event, arg->typecast.item);\r\nreturn eval_type(val, arg, 0);\r\ncase PRINT_STRING:\r\ncase PRINT_BSTRING:\r\ncase PRINT_BITMASK:\r\nreturn 0;\r\ncase PRINT_FUNC: {\r\nstruct trace_seq s;\r\ntrace_seq_init(&s);\r\nval = process_defined_func(&s, data, size, event, arg);\r\ntrace_seq_destroy(&s);\r\nreturn val;\r\n}\r\ncase PRINT_OP:\r\nif (strcmp(arg->op.op, "[") == 0) {\r\nright = eval_num_arg(data, size, event, arg->op.right);\r\nlarg = arg->op.left;\r\nwhile (larg->type == PRINT_TYPE) {\r\nif (!typearg)\r\ntypearg = larg;\r\nlarg = larg->typecast.item;\r\n}\r\nfield_size = pevent->long_size;\r\nswitch (larg->type) {\r\ncase PRINT_DYNAMIC_ARRAY:\r\noffset = pevent_read_number(pevent,\r\ndata + larg->dynarray.field->offset,\r\nlarg->dynarray.field->size);\r\nif (larg->dynarray.field->elementsize)\r\nfield_size = larg->dynarray.field->elementsize;\r\noffset &= 0xffff;\r\noffset += right;\r\nbreak;\r\ncase PRINT_FIELD:\r\nif (!larg->field.field) {\r\nlarg->field.field =\r\npevent_find_any_field(event, larg->field.name);\r\nif (!larg->field.field) {\r\narg = larg;\r\ngoto out_warning_field;\r\n}\r\n}\r\nfield_size = larg->field.field->elementsize;\r\noffset = larg->field.field->offset +\r\nright * larg->field.field->elementsize;\r\nbreak;\r\ndefault:\r\ngoto default_op;\r\n}\r\nval = pevent_read_number(pevent,\r\ndata + offset, field_size);\r\nif (typearg)\r\nval = eval_type(val, typearg, 1);\r\nbreak;\r\n} else if (strcmp(arg->op.op, "?") == 0) {\r\nleft = eval_num_arg(data, size, event, arg->op.left);\r\narg = arg->op.right;\r\nif (left)\r\nval = eval_num_arg(data, size, event, arg->op.left);\r\nelse\r\nval = eval_num_arg(data, size, event, arg->op.right);\r\nbreak;\r\n}\r\ndefault_op:\r\nleft = eval_num_arg(data, size, event, arg->op.left);\r\nright = eval_num_arg(data, size, event, arg->op.right);\r\nswitch (arg->op.op[0]) {\r\ncase '!':\r\nswitch (arg->op.op[1]) {\r\ncase 0:\r\nval = !right;\r\nbreak;\r\ncase '=':\r\nval = left != right;\r\nbreak;\r\ndefault:\r\ngoto out_warning_op;\r\n}\r\nbreak;\r\ncase '~':\r\nval = ~right;\r\nbreak;\r\ncase '|':\r\nif (arg->op.op[1])\r\nval = left || right;\r\nelse\r\nval = left | right;\r\nbreak;\r\ncase '&':\r\nif (arg->op.op[1])\r\nval = left && right;\r\nelse\r\nval = left & right;\r\nbreak;\r\ncase '<':\r\nswitch (arg->op.op[1]) {\r\ncase 0:\r\nval = left < right;\r\nbreak;\r\ncase '<':\r\nval = left << right;\r\nbreak;\r\ncase '=':\r\nval = left <= right;\r\nbreak;\r\ndefault:\r\ngoto out_warning_op;\r\n}\r\nbreak;\r\ncase '>':\r\nswitch (arg->op.op[1]) {\r\ncase 0:\r\nval = left > right;\r\nbreak;\r\ncase '>':\r\nval = left >> right;\r\nbreak;\r\ncase '=':\r\nval = left >= right;\r\nbreak;\r\ndefault:\r\ngoto out_warning_op;\r\n}\r\nbreak;\r\ncase '=':\r\nif (arg->op.op[1] != '=')\r\ngoto out_warning_op;\r\nval = left == right;\r\nbreak;\r\ncase '-':\r\nval = left - right;\r\nbreak;\r\ncase '+':\r\nval = left + right;\r\nbreak;\r\ncase '/':\r\nval = left / right;\r\nbreak;\r\ncase '%':\r\nval = left % right;\r\nbreak;\r\ncase '*':\r\nval = left * right;\r\nbreak;\r\ndefault:\r\ngoto out_warning_op;\r\n}\r\nbreak;\r\ncase PRINT_DYNAMIC_ARRAY_LEN:\r\noffset = pevent_read_number(pevent,\r\ndata + arg->dynarray.field->offset,\r\narg->dynarray.field->size);\r\nval = (unsigned long long)(offset >> 16);\r\nbreak;\r\ncase PRINT_DYNAMIC_ARRAY:\r\noffset = pevent_read_number(pevent,\r\ndata + arg->dynarray.field->offset,\r\narg->dynarray.field->size);\r\noffset &= 0xffff;\r\nval = (unsigned long long)((unsigned long)data + offset);\r\nbreak;\r\ndefault:\r\nreturn 0;\r\n}\r\nreturn val;\r\nout_warning_op:\r\ndo_warning_event(event, "%s: unknown op '%s'", __func__, arg->op.op);\r\nreturn 0;\r\nout_warning_field:\r\ndo_warning_event(event, "%s: field %s not found",\r\n__func__, arg->field.name);\r\nreturn 0;\r\n}\r\nstatic long long eval_flag(const char *flag)\r\n{\r\nint i;\r\nif (isdigit(flag[0]))\r\nreturn strtoull(flag, NULL, 0);\r\nfor (i = 0; i < (int)(sizeof(flags)/sizeof(flags[0])); i++)\r\nif (strcmp(flags[i].name, flag) == 0)\r\nreturn flags[i].value;\r\nreturn -1LL;\r\n}\r\nstatic void print_str_to_seq(struct trace_seq *s, const char *format,\r\nint len_arg, const char *str)\r\n{\r\nif (len_arg >= 0)\r\ntrace_seq_printf(s, format, len_arg, str);\r\nelse\r\ntrace_seq_printf(s, format, str);\r\n}\r\nstatic void print_bitmask_to_seq(struct pevent *pevent,\r\nstruct trace_seq *s, const char *format,\r\nint len_arg, const void *data, int size)\r\n{\r\nint nr_bits = size * 8;\r\nint str_size = (nr_bits + 3) / 4;\r\nint len = 0;\r\nchar buf[3];\r\nchar *str;\r\nint index;\r\nint i;\r\nstr_size += (nr_bits - 1) / 32;\r\nstr = malloc(str_size + 1);\r\nif (!str) {\r\ndo_warning("%s: not enough memory!", __func__);\r\nreturn;\r\n}\r\nstr[str_size] = 0;\r\nfor (i = str_size - 2; i >= 0; i -= 2) {\r\nif (pevent->file_bigendian)\r\nindex = size - (len + 1);\r\nelse\r\nindex = len;\r\nsnprintf(buf, 3, "%02x", *((unsigned char *)data + index));\r\nmemcpy(str + i, buf, 2);\r\nlen++;\r\nif (!(len & 3) && i > 0) {\r\ni--;\r\nstr[i] = ',';\r\n}\r\n}\r\nif (len_arg >= 0)\r\ntrace_seq_printf(s, format, len_arg, str);\r\nelse\r\ntrace_seq_printf(s, format, str);\r\nfree(str);\r\n}\r\nstatic void print_str_arg(struct trace_seq *s, void *data, int size,\r\nstruct event_format *event, const char *format,\r\nint len_arg, struct print_arg *arg)\r\n{\r\nstruct pevent *pevent = event->pevent;\r\nstruct print_flag_sym *flag;\r\nstruct format_field *field;\r\nstruct printk_map *printk;\r\nlong long val, fval;\r\nunsigned long long addr;\r\nchar *str;\r\nunsigned char *hex;\r\nint print;\r\nint i, len;\r\nswitch (arg->type) {\r\ncase PRINT_NULL:\r\nreturn;\r\ncase PRINT_ATOM:\r\nprint_str_to_seq(s, format, len_arg, arg->atom.atom);\r\nreturn;\r\ncase PRINT_FIELD:\r\nfield = arg->field.field;\r\nif (!field) {\r\nfield = pevent_find_any_field(event, arg->field.name);\r\nif (!field) {\r\nstr = arg->field.name;\r\ngoto out_warning_field;\r\n}\r\narg->field.field = field;\r\n}\r\nlen = field->size ? : size - field->offset;\r\nif (!(field->flags & FIELD_IS_ARRAY) &&\r\nfield->size == pevent->long_size) {\r\naddr = (pevent->long_size == 8) ?\r\n*(unsigned long long *)(data + field->offset) :\r\n(unsigned long long)*(unsigned int *)(data + field->offset);\r\nprintk = find_printk(pevent, addr);\r\nif (printk)\r\ntrace_seq_puts(s, printk->printk);\r\nelse\r\ntrace_seq_printf(s, "%llx", addr);\r\nbreak;\r\n}\r\nstr = malloc(len + 1);\r\nif (!str) {\r\ndo_warning_event(event, "%s: not enough memory!",\r\n__func__);\r\nreturn;\r\n}\r\nmemcpy(str, data + field->offset, len);\r\nstr[len] = 0;\r\nprint_str_to_seq(s, format, len_arg, str);\r\nfree(str);\r\nbreak;\r\ncase PRINT_FLAGS:\r\nval = eval_num_arg(data, size, event, arg->flags.field);\r\nprint = 0;\r\nfor (flag = arg->flags.flags; flag; flag = flag->next) {\r\nfval = eval_flag(flag->value);\r\nif (!val && fval < 0) {\r\nprint_str_to_seq(s, format, len_arg, flag->str);\r\nbreak;\r\n}\r\nif (fval > 0 && (val & fval) == fval) {\r\nif (print && arg->flags.delim)\r\ntrace_seq_puts(s, arg->flags.delim);\r\nprint_str_to_seq(s, format, len_arg, flag->str);\r\nprint = 1;\r\nval &= ~fval;\r\n}\r\n}\r\nbreak;\r\ncase PRINT_SYMBOL:\r\nval = eval_num_arg(data, size, event, arg->symbol.field);\r\nfor (flag = arg->symbol.symbols; flag; flag = flag->next) {\r\nfval = eval_flag(flag->value);\r\nif (val == fval) {\r\nprint_str_to_seq(s, format, len_arg, flag->str);\r\nbreak;\r\n}\r\n}\r\nbreak;\r\ncase PRINT_HEX:\r\nif (arg->hex.field->type == PRINT_DYNAMIC_ARRAY) {\r\nunsigned long offset;\r\noffset = pevent_read_number(pevent,\r\ndata + arg->hex.field->dynarray.field->offset,\r\narg->hex.field->dynarray.field->size);\r\nhex = data + (offset & 0xffff);\r\n} else {\r\nfield = arg->hex.field->field.field;\r\nif (!field) {\r\nstr = arg->hex.field->field.name;\r\nfield = pevent_find_any_field(event, str);\r\nif (!field)\r\ngoto out_warning_field;\r\narg->hex.field->field.field = field;\r\n}\r\nhex = data + field->offset;\r\n}\r\nlen = eval_num_arg(data, size, event, arg->hex.size);\r\nfor (i = 0; i < len; i++) {\r\nif (i)\r\ntrace_seq_putc(s, ' ');\r\ntrace_seq_printf(s, "%02x", hex[i]);\r\n}\r\nbreak;\r\ncase PRINT_INT_ARRAY: {\r\nvoid *num;\r\nint el_size;\r\nif (arg->int_array.field->type == PRINT_DYNAMIC_ARRAY) {\r\nunsigned long offset;\r\nstruct format_field *field =\r\narg->int_array.field->dynarray.field;\r\noffset = pevent_read_number(pevent,\r\ndata + field->offset,\r\nfield->size);\r\nnum = data + (offset & 0xffff);\r\n} else {\r\nfield = arg->int_array.field->field.field;\r\nif (!field) {\r\nstr = arg->int_array.field->field.name;\r\nfield = pevent_find_any_field(event, str);\r\nif (!field)\r\ngoto out_warning_field;\r\narg->int_array.field->field.field = field;\r\n}\r\nnum = data + field->offset;\r\n}\r\nlen = eval_num_arg(data, size, event, arg->int_array.count);\r\nel_size = eval_num_arg(data, size, event,\r\narg->int_array.el_size);\r\nfor (i = 0; i < len; i++) {\r\nif (i)\r\ntrace_seq_putc(s, ' ');\r\nif (el_size == 1) {\r\ntrace_seq_printf(s, "%u", *(uint8_t *)num);\r\n} else if (el_size == 2) {\r\ntrace_seq_printf(s, "%u", *(uint16_t *)num);\r\n} else if (el_size == 4) {\r\ntrace_seq_printf(s, "%u", *(uint32_t *)num);\r\n} else if (el_size == 8) {\r\ntrace_seq_printf(s, "%"PRIu64, *(uint64_t *)num);\r\n} else {\r\ntrace_seq_printf(s, "BAD SIZE:%d 0x%x",\r\nel_size, *(uint8_t *)num);\r\nel_size = 1;\r\n}\r\nnum += el_size;\r\n}\r\nbreak;\r\n}\r\ncase PRINT_TYPE:\r\nbreak;\r\ncase PRINT_STRING: {\r\nint str_offset;\r\nif (arg->string.offset == -1) {\r\nstruct format_field *f;\r\nf = pevent_find_any_field(event, arg->string.string);\r\narg->string.offset = f->offset;\r\n}\r\nstr_offset = data2host4(pevent, data + arg->string.offset);\r\nstr_offset &= 0xffff;\r\nprint_str_to_seq(s, format, len_arg, ((char *)data) + str_offset);\r\nbreak;\r\n}\r\ncase PRINT_BSTRING:\r\nprint_str_to_seq(s, format, len_arg, arg->string.string);\r\nbreak;\r\ncase PRINT_BITMASK: {\r\nint bitmask_offset;\r\nint bitmask_size;\r\nif (arg->bitmask.offset == -1) {\r\nstruct format_field *f;\r\nf = pevent_find_any_field(event, arg->bitmask.bitmask);\r\narg->bitmask.offset = f->offset;\r\n}\r\nbitmask_offset = data2host4(pevent, data + arg->bitmask.offset);\r\nbitmask_size = bitmask_offset >> 16;\r\nbitmask_offset &= 0xffff;\r\nprint_bitmask_to_seq(pevent, s, format, len_arg,\r\ndata + bitmask_offset, bitmask_size);\r\nbreak;\r\n}\r\ncase PRINT_OP:\r\nif (arg->op.op[0] != '?')\r\nreturn;\r\nval = eval_num_arg(data, size, event, arg->op.left);\r\nif (val)\r\nprint_str_arg(s, data, size, event,\r\nformat, len_arg, arg->op.right->op.left);\r\nelse\r\nprint_str_arg(s, data, size, event,\r\nformat, len_arg, arg->op.right->op.right);\r\nbreak;\r\ncase PRINT_FUNC:\r\nprocess_defined_func(s, data, size, event, arg);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nreturn;\r\nout_warning_field:\r\ndo_warning_event(event, "%s: field %s not found",\r\n__func__, arg->field.name);\r\n}\r\nstatic unsigned long long\r\nprocess_defined_func(struct trace_seq *s, void *data, int size,\r\nstruct event_format *event, struct print_arg *arg)\r\n{\r\nstruct pevent_function_handler *func_handle = arg->func.func;\r\nstruct pevent_func_params *param;\r\nunsigned long long *args;\r\nunsigned long long ret;\r\nstruct print_arg *farg;\r\nstruct trace_seq str;\r\nstruct save_str {\r\nstruct save_str *next;\r\nchar *str;\r\n} *strings = NULL, *string;\r\nint i;\r\nif (!func_handle->nr_args) {\r\nret = (*func_handle->func)(s, NULL);\r\ngoto out;\r\n}\r\nfarg = arg->func.args;\r\nparam = func_handle->params;\r\nret = ULLONG_MAX;\r\nargs = malloc(sizeof(*args) * func_handle->nr_args);\r\nif (!args)\r\ngoto out;\r\nfor (i = 0; i < func_handle->nr_args; i++) {\r\nswitch (param->type) {\r\ncase PEVENT_FUNC_ARG_INT:\r\ncase PEVENT_FUNC_ARG_LONG:\r\ncase PEVENT_FUNC_ARG_PTR:\r\nargs[i] = eval_num_arg(data, size, event, farg);\r\nbreak;\r\ncase PEVENT_FUNC_ARG_STRING:\r\ntrace_seq_init(&str);\r\nprint_str_arg(&str, data, size, event, "%s", -1, farg);\r\ntrace_seq_terminate(&str);\r\nstring = malloc(sizeof(*string));\r\nif (!string) {\r\ndo_warning_event(event, "%s(%d): malloc str",\r\n__func__, __LINE__);\r\ngoto out_free;\r\n}\r\nstring->next = strings;\r\nstring->str = strdup(str.buffer);\r\nif (!string->str) {\r\nfree(string);\r\ndo_warning_event(event, "%s(%d): malloc str",\r\n__func__, __LINE__);\r\ngoto out_free;\r\n}\r\nargs[i] = (uintptr_t)string->str;\r\nstrings = string;\r\ntrace_seq_destroy(&str);\r\nbreak;\r\ndefault:\r\ndo_warning_event(event, "Unexpected end of arguments\n");\r\ngoto out_free;\r\n}\r\nfarg = farg->next;\r\nparam = param->next;\r\n}\r\nret = (*func_handle->func)(s, args);\r\nout_free:\r\nfree(args);\r\nwhile (strings) {\r\nstring = strings;\r\nstrings = string->next;\r\nfree(string->str);\r\nfree(string);\r\n}\r\nout:\r\nreturn ret;\r\n}\r\nstatic void free_args(struct print_arg *args)\r\n{\r\nstruct print_arg *next;\r\nwhile (args) {\r\nnext = args->next;\r\nfree_arg(args);\r\nargs = next;\r\n}\r\n}\r\nstatic struct print_arg *make_bprint_args(char *fmt, void *data, int size, struct event_format *event)\r\n{\r\nstruct pevent *pevent = event->pevent;\r\nstruct format_field *field, *ip_field;\r\nstruct print_arg *args, *arg, **next;\r\nunsigned long long ip, val;\r\nchar *ptr;\r\nvoid *bptr;\r\nint vsize;\r\nfield = pevent->bprint_buf_field;\r\nip_field = pevent->bprint_ip_field;\r\nif (!field) {\r\nfield = pevent_find_field(event, "buf");\r\nif (!field) {\r\ndo_warning_event(event, "can't find buffer field for binary printk");\r\nreturn NULL;\r\n}\r\nip_field = pevent_find_field(event, "ip");\r\nif (!ip_field) {\r\ndo_warning_event(event, "can't find ip field for binary printk");\r\nreturn NULL;\r\n}\r\npevent->bprint_buf_field = field;\r\npevent->bprint_ip_field = ip_field;\r\n}\r\nip = pevent_read_number(pevent, data + ip_field->offset, ip_field->size);\r\nargs = alloc_arg();\r\nif (!args) {\r\ndo_warning_event(event, "%s(%d): not enough memory!",\r\n__func__, __LINE__);\r\nreturn NULL;\r\n}\r\narg = args;\r\narg->next = NULL;\r\nnext = &arg->next;\r\narg->type = PRINT_ATOM;\r\nif (asprintf(&arg->atom.atom, "%lld", ip) < 0)\r\ngoto out_free;\r\nfor (ptr = fmt + 5, bptr = data + field->offset;\r\nbptr < data + size && *ptr; ptr++) {\r\nint ls = 0;\r\nif (*ptr == '%') {\r\nprocess_again:\r\nptr++;\r\nswitch (*ptr) {\r\ncase '%':\r\nbreak;\r\ncase 'l':\r\nls++;\r\ngoto process_again;\r\ncase 'L':\r\nls = 2;\r\ngoto process_again;\r\ncase '0' ... '9':\r\ngoto process_again;\r\ncase '.':\r\ngoto process_again;\r\ncase 'z':\r\ncase 'Z':\r\nls = 1;\r\ngoto process_again;\r\ncase 'p':\r\nls = 1;\r\ncase 'd':\r\ncase 'u':\r\ncase 'x':\r\ncase 'i':\r\nswitch (ls) {\r\ncase 0:\r\nvsize = 4;\r\nbreak;\r\ncase 1:\r\nvsize = pevent->long_size;\r\nbreak;\r\ncase 2:\r\nvsize = 8;\r\nbreak;\r\ndefault:\r\nvsize = ls;\r\nbreak;\r\n}\r\ncase '*':\r\nif (*ptr == '*')\r\nvsize = 4;\r\nbptr = (void *)(((unsigned long)bptr + 3) &\r\n~3);\r\nval = pevent_read_number(pevent, bptr, vsize);\r\nbptr += vsize;\r\narg = alloc_arg();\r\nif (!arg) {\r\ndo_warning_event(event, "%s(%d): not enough memory!",\r\n__func__, __LINE__);\r\ngoto out_free;\r\n}\r\narg->next = NULL;\r\narg->type = PRINT_ATOM;\r\nif (asprintf(&arg->atom.atom, "%lld", val) < 0) {\r\nfree(arg);\r\ngoto out_free;\r\n}\r\n*next = arg;\r\nnext = &arg->next;\r\nif (*ptr == '*')\r\ngoto process_again;\r\nbreak;\r\ncase 's':\r\narg = alloc_arg();\r\nif (!arg) {\r\ndo_warning_event(event, "%s(%d): not enough memory!",\r\n__func__, __LINE__);\r\ngoto out_free;\r\n}\r\narg->next = NULL;\r\narg->type = PRINT_BSTRING;\r\narg->string.string = strdup(bptr);\r\nif (!arg->string.string)\r\ngoto out_free;\r\nbptr += strlen(bptr) + 1;\r\n*next = arg;\r\nnext = &arg->next;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\n}\r\nreturn args;\r\nout_free:\r\nfree_args(args);\r\nreturn NULL;\r\n}\r\nstatic char *\r\nget_bprint_format(void *data, int size __maybe_unused,\r\nstruct event_format *event)\r\n{\r\nstruct pevent *pevent = event->pevent;\r\nunsigned long long addr;\r\nstruct format_field *field;\r\nstruct printk_map *printk;\r\nchar *format;\r\nfield = pevent->bprint_fmt_field;\r\nif (!field) {\r\nfield = pevent_find_field(event, "fmt");\r\nif (!field) {\r\ndo_warning_event(event, "can't find format field for binary printk");\r\nreturn NULL;\r\n}\r\npevent->bprint_fmt_field = field;\r\n}\r\naddr = pevent_read_number(pevent, data + field->offset, field->size);\r\nprintk = find_printk(pevent, addr);\r\nif (!printk) {\r\nif (asprintf(&format, "%%pf: (NO FORMAT FOUND at %llx)\n", addr) < 0)\r\nreturn NULL;\r\nreturn format;\r\n}\r\nif (asprintf(&format, "%s: %s", "%pf", printk->printk) < 0)\r\nreturn NULL;\r\nreturn format;\r\n}\r\nstatic void print_mac_arg(struct trace_seq *s, int mac, void *data, int size,\r\nstruct event_format *event, struct print_arg *arg)\r\n{\r\nunsigned char *buf;\r\nconst char *fmt = "%.2x:%.2x:%.2x:%.2x:%.2x:%.2x";\r\nif (arg->type == PRINT_FUNC) {\r\nprocess_defined_func(s, data, size, event, arg);\r\nreturn;\r\n}\r\nif (arg->type != PRINT_FIELD) {\r\ntrace_seq_printf(s, "ARG TYPE NOT FIELD BUT %d",\r\narg->type);\r\nreturn;\r\n}\r\nif (mac == 'm')\r\nfmt = "%.2x%.2x%.2x%.2x%.2x%.2x";\r\nif (!arg->field.field) {\r\narg->field.field =\r\npevent_find_any_field(event, arg->field.name);\r\nif (!arg->field.field) {\r\ndo_warning_event(event, "%s: field %s not found",\r\n__func__, arg->field.name);\r\nreturn;\r\n}\r\n}\r\nif (arg->field.field->size != 6) {\r\ntrace_seq_printf(s, "INVALIDMAC");\r\nreturn;\r\n}\r\nbuf = data + arg->field.field->offset;\r\ntrace_seq_printf(s, fmt, buf[0], buf[1], buf[2], buf[3], buf[4], buf[5]);\r\n}\r\nstatic void print_ip4_addr(struct trace_seq *s, char i, unsigned char *buf)\r\n{\r\nconst char *fmt;\r\nif (i == 'i')\r\nfmt = "%03d.%03d.%03d.%03d";\r\nelse\r\nfmt = "%d.%d.%d.%d";\r\ntrace_seq_printf(s, fmt, buf[0], buf[1], buf[2], buf[3]);\r\n}\r\nstatic inline bool ipv6_addr_v4mapped(const struct in6_addr *a)\r\n{\r\nreturn ((unsigned long)(a->s6_addr32[0] | a->s6_addr32[1]) |\r\n(unsigned long)(a->s6_addr32[2] ^ htonl(0x0000ffff))) == 0UL;\r\n}\r\nstatic inline bool ipv6_addr_is_isatap(const struct in6_addr *addr)\r\n{\r\nreturn (addr->s6_addr32[2] | htonl(0x02000000)) == htonl(0x02005EFE);\r\n}\r\nstatic void print_ip6c_addr(struct trace_seq *s, unsigned char *addr)\r\n{\r\nint i, j, range;\r\nunsigned char zerolength[8];\r\nint longest = 1;\r\nint colonpos = -1;\r\nuint16_t word;\r\nuint8_t hi, lo;\r\nbool needcolon = false;\r\nbool useIPv4;\r\nstruct in6_addr in6;\r\nmemcpy(&in6, addr, sizeof(struct in6_addr));\r\nuseIPv4 = ipv6_addr_v4mapped(&in6) || ipv6_addr_is_isatap(&in6);\r\nmemset(zerolength, 0, sizeof(zerolength));\r\nif (useIPv4)\r\nrange = 6;\r\nelse\r\nrange = 8;\r\nfor (i = 0; i < range; i++) {\r\nfor (j = i; j < range; j++) {\r\nif (in6.s6_addr16[j] != 0)\r\nbreak;\r\nzerolength[i]++;\r\n}\r\n}\r\nfor (i = 0; i < range; i++) {\r\nif (zerolength[i] > longest) {\r\nlongest = zerolength[i];\r\ncolonpos = i;\r\n}\r\n}\r\nif (longest == 1)\r\ncolonpos = -1;\r\nfor (i = 0; i < range; i++) {\r\nif (i == colonpos) {\r\nif (needcolon || i == 0)\r\ntrace_seq_printf(s, ":");\r\ntrace_seq_printf(s, ":");\r\nneedcolon = false;\r\ni += longest - 1;\r\ncontinue;\r\n}\r\nif (needcolon) {\r\ntrace_seq_printf(s, ":");\r\nneedcolon = false;\r\n}\r\nword = ntohs(in6.s6_addr16[i]);\r\nhi = word >> 8;\r\nlo = word & 0xff;\r\nif (hi)\r\ntrace_seq_printf(s, "%x%02x", hi, lo);\r\nelse\r\ntrace_seq_printf(s, "%x", lo);\r\nneedcolon = true;\r\n}\r\nif (useIPv4) {\r\nif (needcolon)\r\ntrace_seq_printf(s, ":");\r\nprint_ip4_addr(s, 'I', &in6.s6_addr[12]);\r\n}\r\nreturn;\r\n}\r\nstatic void print_ip6_addr(struct trace_seq *s, char i, unsigned char *buf)\r\n{\r\nint j;\r\nfor (j = 0; j < 16; j += 2) {\r\ntrace_seq_printf(s, "%02x%02x", buf[j], buf[j+1]);\r\nif (i == 'I' && j < 14)\r\ntrace_seq_printf(s, ":");\r\n}\r\n}\r\nstatic int print_ipv4_arg(struct trace_seq *s, const char *ptr, char i,\r\nvoid *data, int size, struct event_format *event,\r\nstruct print_arg *arg)\r\n{\r\nunsigned char *buf;\r\nif (arg->type == PRINT_FUNC) {\r\nprocess_defined_func(s, data, size, event, arg);\r\nreturn 0;\r\n}\r\nif (arg->type != PRINT_FIELD) {\r\ntrace_seq_printf(s, "ARG TYPE NOT FIELD BUT %d", arg->type);\r\nreturn 0;\r\n}\r\nif (!arg->field.field) {\r\narg->field.field =\r\npevent_find_any_field(event, arg->field.name);\r\nif (!arg->field.field) {\r\ndo_warning("%s: field %s not found",\r\n__func__, arg->field.name);\r\nreturn 0;\r\n}\r\n}\r\nbuf = data + arg->field.field->offset;\r\nif (arg->field.field->size != 4) {\r\ntrace_seq_printf(s, "INVALIDIPv4");\r\nreturn 0;\r\n}\r\nprint_ip4_addr(s, i, buf);\r\nreturn 0;\r\n}\r\nstatic int print_ipv6_arg(struct trace_seq *s, const char *ptr, char i,\r\nvoid *data, int size, struct event_format *event,\r\nstruct print_arg *arg)\r\n{\r\nchar have_c = 0;\r\nunsigned char *buf;\r\nint rc = 0;\r\nif (i == 'I' && *ptr == 'c') {\r\nhave_c = 1;\r\nptr++;\r\nrc++;\r\n}\r\nif (arg->type == PRINT_FUNC) {\r\nprocess_defined_func(s, data, size, event, arg);\r\nreturn rc;\r\n}\r\nif (arg->type != PRINT_FIELD) {\r\ntrace_seq_printf(s, "ARG TYPE NOT FIELD BUT %d", arg->type);\r\nreturn rc;\r\n}\r\nif (!arg->field.field) {\r\narg->field.field =\r\npevent_find_any_field(event, arg->field.name);\r\nif (!arg->field.field) {\r\ndo_warning("%s: field %s not found",\r\n__func__, arg->field.name);\r\nreturn rc;\r\n}\r\n}\r\nbuf = data + arg->field.field->offset;\r\nif (arg->field.field->size != 16) {\r\ntrace_seq_printf(s, "INVALIDIPv6");\r\nreturn rc;\r\n}\r\nif (have_c)\r\nprint_ip6c_addr(s, buf);\r\nelse\r\nprint_ip6_addr(s, i, buf);\r\nreturn rc;\r\n}\r\nstatic int print_ipsa_arg(struct trace_seq *s, const char *ptr, char i,\r\nvoid *data, int size, struct event_format *event,\r\nstruct print_arg *arg)\r\n{\r\nchar have_c = 0, have_p = 0;\r\nunsigned char *buf;\r\nstruct sockaddr_storage *sa;\r\nint rc = 0;\r\nif (i == 'I') {\r\nif (*ptr == 'p') {\r\nhave_p = 1;\r\nptr++;\r\nrc++;\r\n}\r\nif (*ptr == 'c') {\r\nhave_c = 1;\r\nptr++;\r\nrc++;\r\n}\r\n}\r\nif (arg->type == PRINT_FUNC) {\r\nprocess_defined_func(s, data, size, event, arg);\r\nreturn rc;\r\n}\r\nif (arg->type != PRINT_FIELD) {\r\ntrace_seq_printf(s, "ARG TYPE NOT FIELD BUT %d", arg->type);\r\nreturn rc;\r\n}\r\nif (!arg->field.field) {\r\narg->field.field =\r\npevent_find_any_field(event, arg->field.name);\r\nif (!arg->field.field) {\r\ndo_warning("%s: field %s not found",\r\n__func__, arg->field.name);\r\nreturn rc;\r\n}\r\n}\r\nsa = (struct sockaddr_storage *) (data + arg->field.field->offset);\r\nif (sa->ss_family == AF_INET) {\r\nstruct sockaddr_in *sa4 = (struct sockaddr_in *) sa;\r\nif (arg->field.field->size < sizeof(struct sockaddr_in)) {\r\ntrace_seq_printf(s, "INVALIDIPv4");\r\nreturn rc;\r\n}\r\nprint_ip4_addr(s, i, (unsigned char *) &sa4->sin_addr);\r\nif (have_p)\r\ntrace_seq_printf(s, ":%d", ntohs(sa4->sin_port));\r\n} else if (sa->ss_family == AF_INET6) {\r\nstruct sockaddr_in6 *sa6 = (struct sockaddr_in6 *) sa;\r\nif (arg->field.field->size < sizeof(struct sockaddr_in6)) {\r\ntrace_seq_printf(s, "INVALIDIPv6");\r\nreturn rc;\r\n}\r\nif (have_p)\r\ntrace_seq_printf(s, "[");\r\nbuf = (unsigned char *) &sa6->sin6_addr;\r\nif (have_c)\r\nprint_ip6c_addr(s, buf);\r\nelse\r\nprint_ip6_addr(s, i, buf);\r\nif (have_p)\r\ntrace_seq_printf(s, "]:%d", ntohs(sa6->sin6_port));\r\n}\r\nreturn rc;\r\n}\r\nstatic int print_ip_arg(struct trace_seq *s, const char *ptr,\r\nvoid *data, int size, struct event_format *event,\r\nstruct print_arg *arg)\r\n{\r\nchar i = *ptr;\r\nchar ver;\r\nint rc = 0;\r\nptr++;\r\nrc++;\r\nver = *ptr;\r\nptr++;\r\nrc++;\r\nswitch (ver) {\r\ncase '4':\r\nrc += print_ipv4_arg(s, ptr, i, data, size, event, arg);\r\nbreak;\r\ncase '6':\r\nrc += print_ipv6_arg(s, ptr, i, data, size, event, arg);\r\nbreak;\r\ncase 'S':\r\nrc += print_ipsa_arg(s, ptr, i, data, size, event, arg);\r\nbreak;\r\ndefault:\r\nreturn 0;\r\n}\r\nreturn rc;\r\n}\r\nstatic int is_printable_array(char *p, unsigned int len)\r\n{\r\nunsigned int i;\r\nfor (i = 0; i < len && p[i]; i++)\r\nif (!isprint(p[i]) && !isspace(p[i]))\r\nreturn 0;\r\nreturn 1;\r\n}\r\nvoid pevent_print_field(struct trace_seq *s, void *data,\r\nstruct format_field *field)\r\n{\r\nunsigned long long val;\r\nunsigned int offset, len, i;\r\nstruct pevent *pevent = field->event->pevent;\r\nif (field->flags & FIELD_IS_ARRAY) {\r\noffset = field->offset;\r\nlen = field->size;\r\nif (field->flags & FIELD_IS_DYNAMIC) {\r\nval = pevent_read_number(pevent, data + offset, len);\r\noffset = val;\r\nlen = offset >> 16;\r\noffset &= 0xffff;\r\n}\r\nif (field->flags & FIELD_IS_STRING &&\r\nis_printable_array(data + offset, len)) {\r\ntrace_seq_printf(s, "%s", (char *)data + offset);\r\n} else {\r\ntrace_seq_puts(s, "ARRAY[");\r\nfor (i = 0; i < len; i++) {\r\nif (i)\r\ntrace_seq_puts(s, ", ");\r\ntrace_seq_printf(s, "%02x",\r\n*((unsigned char *)data + offset + i));\r\n}\r\ntrace_seq_putc(s, ']');\r\nfield->flags &= ~FIELD_IS_STRING;\r\n}\r\n} else {\r\nval = pevent_read_number(pevent, data + field->offset,\r\nfield->size);\r\nif (field->flags & FIELD_IS_POINTER) {\r\ntrace_seq_printf(s, "0x%llx", val);\r\n} else if (field->flags & FIELD_IS_SIGNED) {\r\nswitch (field->size) {\r\ncase 4:\r\nif (field->flags & FIELD_IS_LONG)\r\ntrace_seq_printf(s, "0x%x", (int)val);\r\nelse\r\ntrace_seq_printf(s, "%d", (int)val);\r\nbreak;\r\ncase 2:\r\ntrace_seq_printf(s, "%2d", (short)val);\r\nbreak;\r\ncase 1:\r\ntrace_seq_printf(s, "%1d", (char)val);\r\nbreak;\r\ndefault:\r\ntrace_seq_printf(s, "%lld", val);\r\n}\r\n} else {\r\nif (field->flags & FIELD_IS_LONG)\r\ntrace_seq_printf(s, "0x%llx", val);\r\nelse\r\ntrace_seq_printf(s, "%llu", val);\r\n}\r\n}\r\n}\r\nvoid pevent_print_fields(struct trace_seq *s, void *data,\r\nint size __maybe_unused, struct event_format *event)\r\n{\r\nstruct format_field *field;\r\nfield = event->format.fields;\r\nwhile (field) {\r\ntrace_seq_printf(s, " %s=", field->name);\r\npevent_print_field(s, data, field);\r\nfield = field->next;\r\n}\r\n}\r\nstatic void pretty_print(struct trace_seq *s, void *data, int size, struct event_format *event)\r\n{\r\nstruct pevent *pevent = event->pevent;\r\nstruct print_fmt *print_fmt = &event->print_fmt;\r\nstruct print_arg *arg = print_fmt->args;\r\nstruct print_arg *args = NULL;\r\nconst char *ptr = print_fmt->format;\r\nunsigned long long val;\r\nstruct func_map *func;\r\nconst char *saveptr;\r\nstruct trace_seq p;\r\nchar *bprint_fmt = NULL;\r\nchar format[32];\r\nint show_func;\r\nint len_as_arg;\r\nint len_arg;\r\nint len;\r\nint ls;\r\nif (event->flags & EVENT_FL_FAILED) {\r\ntrace_seq_printf(s, "[FAILED TO PARSE]");\r\npevent_print_fields(s, data, size, event);\r\nreturn;\r\n}\r\nif (event->flags & EVENT_FL_ISBPRINT) {\r\nbprint_fmt = get_bprint_format(data, size, event);\r\nargs = make_bprint_args(bprint_fmt, data, size, event);\r\narg = args;\r\nptr = bprint_fmt;\r\n}\r\nfor (; *ptr; ptr++) {\r\nls = 0;\r\nif (*ptr == '\\') {\r\nptr++;\r\nswitch (*ptr) {\r\ncase 'n':\r\ntrace_seq_putc(s, '\n');\r\nbreak;\r\ncase 't':\r\ntrace_seq_putc(s, '\t');\r\nbreak;\r\ncase 'r':\r\ntrace_seq_putc(s, '\r');\r\nbreak;\r\ncase '\\':\r\ntrace_seq_putc(s, '\\');\r\nbreak;\r\ndefault:\r\ntrace_seq_putc(s, *ptr);\r\nbreak;\r\n}\r\n} else if (*ptr == '%') {\r\nsaveptr = ptr;\r\nshow_func = 0;\r\nlen_as_arg = 0;\r\ncont_process:\r\nptr++;\r\nswitch (*ptr) {\r\ncase '%':\r\ntrace_seq_putc(s, '%');\r\nbreak;\r\ncase '#':\r\ngoto cont_process;\r\ncase 'h':\r\nls--;\r\ngoto cont_process;\r\ncase 'l':\r\nls++;\r\ngoto cont_process;\r\ncase 'L':\r\nls = 2;\r\ngoto cont_process;\r\ncase '*':\r\nif (!arg) {\r\ndo_warning_event(event, "no argument match");\r\nevent->flags |= EVENT_FL_FAILED;\r\ngoto out_failed;\r\n}\r\nlen_arg = eval_num_arg(data, size, event, arg);\r\nlen_as_arg = 1;\r\narg = arg->next;\r\ngoto cont_process;\r\ncase '.':\r\ncase 'z':\r\ncase 'Z':\r\ncase '0' ... '9':\r\ncase '-':\r\ngoto cont_process;\r\ncase 'p':\r\nif (pevent->long_size == 4)\r\nls = 1;\r\nelse\r\nls = 2;\r\nif (*(ptr+1) == 'F' || *(ptr+1) == 'f' ||\r\n*(ptr+1) == 'S' || *(ptr+1) == 's') {\r\nptr++;\r\nshow_func = *ptr;\r\n} else if (*(ptr+1) == 'M' || *(ptr+1) == 'm') {\r\nprint_mac_arg(s, *(ptr+1), data, size, event, arg);\r\nptr++;\r\narg = arg->next;\r\nbreak;\r\n} else if (*(ptr+1) == 'I' || *(ptr+1) == 'i') {\r\nint n;\r\nn = print_ip_arg(s, ptr+1, data, size, event, arg);\r\nif (n > 0) {\r\nptr += n;\r\narg = arg->next;\r\nbreak;\r\n}\r\n}\r\ncase 'd':\r\ncase 'i':\r\ncase 'x':\r\ncase 'X':\r\ncase 'u':\r\nif (!arg) {\r\ndo_warning_event(event, "no argument match");\r\nevent->flags |= EVENT_FL_FAILED;\r\ngoto out_failed;\r\n}\r\nlen = ((unsigned long)ptr + 1) -\r\n(unsigned long)saveptr;\r\nif (len > 31) {\r\ndo_warning_event(event, "bad format!");\r\nevent->flags |= EVENT_FL_FAILED;\r\nlen = 31;\r\n}\r\nmemcpy(format, saveptr, len);\r\nformat[len] = 0;\r\nval = eval_num_arg(data, size, event, arg);\r\narg = arg->next;\r\nif (show_func) {\r\nfunc = find_func(pevent, val);\r\nif (func) {\r\ntrace_seq_puts(s, func->func);\r\nif (show_func == 'F')\r\ntrace_seq_printf(s,\r\n"+0x%llx",\r\nval - func->addr);\r\nbreak;\r\n}\r\n}\r\nif (pevent->long_size == 8 && ls == 1 &&\r\nsizeof(long) != 8) {\r\nchar *p;\r\nif (ls == 1 && (p = strchr(format, 'l')))\r\nmemmove(p+1, p, strlen(p)+1);\r\nelse if (strcmp(format, "%p") == 0)\r\nstrcpy(format, "0x%llx");\r\nls = 2;\r\n}\r\nswitch (ls) {\r\ncase -2:\r\nif (len_as_arg)\r\ntrace_seq_printf(s, format, len_arg, (char)val);\r\nelse\r\ntrace_seq_printf(s, format, (char)val);\r\nbreak;\r\ncase -1:\r\nif (len_as_arg)\r\ntrace_seq_printf(s, format, len_arg, (short)val);\r\nelse\r\ntrace_seq_printf(s, format, (short)val);\r\nbreak;\r\ncase 0:\r\nif (len_as_arg)\r\ntrace_seq_printf(s, format, len_arg, (int)val);\r\nelse\r\ntrace_seq_printf(s, format, (int)val);\r\nbreak;\r\ncase 1:\r\nif (len_as_arg)\r\ntrace_seq_printf(s, format, len_arg, (long)val);\r\nelse\r\ntrace_seq_printf(s, format, (long)val);\r\nbreak;\r\ncase 2:\r\nif (len_as_arg)\r\ntrace_seq_printf(s, format, len_arg,\r\n(long long)val);\r\nelse\r\ntrace_seq_printf(s, format, (long long)val);\r\nbreak;\r\ndefault:\r\ndo_warning_event(event, "bad count (%d)", ls);\r\nevent->flags |= EVENT_FL_FAILED;\r\n}\r\nbreak;\r\ncase 's':\r\nif (!arg) {\r\ndo_warning_event(event, "no matching argument");\r\nevent->flags |= EVENT_FL_FAILED;\r\ngoto out_failed;\r\n}\r\nlen = ((unsigned long)ptr + 1) -\r\n(unsigned long)saveptr;\r\nif (len > 31) {\r\ndo_warning_event(event, "bad format!");\r\nevent->flags |= EVENT_FL_FAILED;\r\nlen = 31;\r\n}\r\nmemcpy(format, saveptr, len);\r\nformat[len] = 0;\r\nif (!len_as_arg)\r\nlen_arg = -1;\r\ntrace_seq_init(&p);\r\nprint_str_arg(&p, data, size, event,\r\nformat, len_arg, arg);\r\ntrace_seq_terminate(&p);\r\ntrace_seq_puts(s, p.buffer);\r\ntrace_seq_destroy(&p);\r\narg = arg->next;\r\nbreak;\r\ndefault:\r\ntrace_seq_printf(s, ">%c<", *ptr);\r\n}\r\n} else\r\ntrace_seq_putc(s, *ptr);\r\n}\r\nif (event->flags & EVENT_FL_FAILED) {\r\nout_failed:\r\ntrace_seq_printf(s, "[FAILED TO PARSE]");\r\n}\r\nif (args) {\r\nfree_args(args);\r\nfree(bprint_fmt);\r\n}\r\n}\r\nvoid pevent_data_lat_fmt(struct pevent *pevent,\r\nstruct trace_seq *s, struct pevent_record *record)\r\n{\r\nstatic int check_lock_depth = 1;\r\nstatic int check_migrate_disable = 1;\r\nstatic int lock_depth_exists;\r\nstatic int migrate_disable_exists;\r\nunsigned int lat_flags;\r\nunsigned int pc;\r\nint lock_depth;\r\nint migrate_disable;\r\nint hardirq;\r\nint softirq;\r\nvoid *data = record->data;\r\nlat_flags = parse_common_flags(pevent, data);\r\npc = parse_common_pc(pevent, data);\r\nif (lock_depth_exists)\r\nlock_depth = parse_common_lock_depth(pevent, data);\r\nelse if (check_lock_depth) {\r\nlock_depth = parse_common_lock_depth(pevent, data);\r\nif (lock_depth < 0)\r\ncheck_lock_depth = 0;\r\nelse\r\nlock_depth_exists = 1;\r\n}\r\nif (migrate_disable_exists)\r\nmigrate_disable = parse_common_migrate_disable(pevent, data);\r\nelse if (check_migrate_disable) {\r\nmigrate_disable = parse_common_migrate_disable(pevent, data);\r\nif (migrate_disable < 0)\r\ncheck_migrate_disable = 0;\r\nelse\r\nmigrate_disable_exists = 1;\r\n}\r\nhardirq = lat_flags & TRACE_FLAG_HARDIRQ;\r\nsoftirq = lat_flags & TRACE_FLAG_SOFTIRQ;\r\ntrace_seq_printf(s, "%c%c%c",\r\n(lat_flags & TRACE_FLAG_IRQS_OFF) ? 'd' :\r\n(lat_flags & TRACE_FLAG_IRQS_NOSUPPORT) ?\r\n'X' : '.',\r\n(lat_flags & TRACE_FLAG_NEED_RESCHED) ?\r\n'N' : '.',\r\n(hardirq && softirq) ? 'H' :\r\nhardirq ? 'h' : softirq ? 's' : '.');\r\nif (pc)\r\ntrace_seq_printf(s, "%x", pc);\r\nelse\r\ntrace_seq_putc(s, '.');\r\nif (migrate_disable_exists) {\r\nif (migrate_disable < 0)\r\ntrace_seq_putc(s, '.');\r\nelse\r\ntrace_seq_printf(s, "%d", migrate_disable);\r\n}\r\nif (lock_depth_exists) {\r\nif (lock_depth < 0)\r\ntrace_seq_putc(s, '.');\r\nelse\r\ntrace_seq_printf(s, "%d", lock_depth);\r\n}\r\ntrace_seq_terminate(s);\r\n}\r\nint pevent_data_type(struct pevent *pevent, struct pevent_record *rec)\r\n{\r\nreturn trace_parse_common_type(pevent, rec->data);\r\n}\r\nstruct event_format *pevent_data_event_from_type(struct pevent *pevent, int type)\r\n{\r\nreturn pevent_find_event(pevent, type);\r\n}\r\nint pevent_data_pid(struct pevent *pevent, struct pevent_record *rec)\r\n{\r\nreturn parse_common_pid(pevent, rec->data);\r\n}\r\nconst char *pevent_data_comm_from_pid(struct pevent *pevent, int pid)\r\n{\r\nconst char *comm;\r\ncomm = find_cmdline(pevent, pid);\r\nreturn comm;\r\n}\r\nstatic struct cmdline *\r\npid_from_cmdlist(struct pevent *pevent, const char *comm, struct cmdline *next)\r\n{\r\nstruct cmdline_list *cmdlist = (struct cmdline_list *)next;\r\nif (cmdlist)\r\ncmdlist = cmdlist->next;\r\nelse\r\ncmdlist = pevent->cmdlist;\r\nwhile (cmdlist && strcmp(cmdlist->comm, comm) != 0)\r\ncmdlist = cmdlist->next;\r\nreturn (struct cmdline *)cmdlist;\r\n}\r\nstruct cmdline *pevent_data_pid_from_comm(struct pevent *pevent, const char *comm,\r\nstruct cmdline *next)\r\n{\r\nstruct cmdline *cmdline;\r\nif (!pevent->cmdlines)\r\nreturn pid_from_cmdlist(pevent, comm, next);\r\nif (next) {\r\nif (next < pevent->cmdlines ||\r\nnext >= pevent->cmdlines + pevent->cmdline_count)\r\nnext = NULL;\r\nelse\r\ncmdline = next++;\r\n}\r\nif (!next)\r\ncmdline = pevent->cmdlines;\r\nwhile (cmdline < pevent->cmdlines + pevent->cmdline_count) {\r\nif (strcmp(cmdline->comm, comm) == 0)\r\nreturn cmdline;\r\ncmdline++;\r\n}\r\nreturn NULL;\r\n}\r\nint pevent_cmdline_pid(struct pevent *pevent, struct cmdline *cmdline)\r\n{\r\nstruct cmdline_list *cmdlist = (struct cmdline_list *)cmdline;\r\nif (!cmdline)\r\nreturn -1;\r\nif (!pevent->cmdlines ||\r\ncmdline < pevent->cmdlines ||\r\ncmdline >= pevent->cmdlines + pevent->cmdline_count)\r\nreturn cmdlist->pid;\r\nreturn cmdline->pid;\r\n}\r\nvoid pevent_event_info(struct trace_seq *s, struct event_format *event,\r\nstruct pevent_record *record)\r\n{\r\nint print_pretty = 1;\r\nif (event->pevent->print_raw || (event->flags & EVENT_FL_PRINTRAW))\r\npevent_print_fields(s, record->data, record->size, event);\r\nelse {\r\nif (event->handler && !(event->flags & EVENT_FL_NOHANDLE))\r\nprint_pretty = event->handler(s, record, event,\r\nevent->context);\r\nif (print_pretty)\r\npretty_print(s, record->data, record->size, event);\r\n}\r\ntrace_seq_terminate(s);\r\n}\r\nstatic bool is_timestamp_in_us(char *trace_clock, bool use_trace_clock)\r\n{\r\nif (!use_trace_clock)\r\nreturn true;\r\nif (!strcmp(trace_clock, "local") || !strcmp(trace_clock, "global")\r\n|| !strcmp(trace_clock, "uptime") || !strcmp(trace_clock, "perf"))\r\nreturn true;\r\nreturn false;\r\n}\r\nstruct event_format *\r\npevent_find_event_by_record(struct pevent *pevent, struct pevent_record *record)\r\n{\r\nint type;\r\nif (record->size < 0) {\r\ndo_warning("ug! negative record size %d", record->size);\r\nreturn NULL;\r\n}\r\ntype = trace_parse_common_type(pevent, record->data);\r\nreturn pevent_find_event(pevent, type);\r\n}\r\nvoid pevent_print_event_task(struct pevent *pevent, struct trace_seq *s,\r\nstruct event_format *event,\r\nstruct pevent_record *record)\r\n{\r\nvoid *data = record->data;\r\nconst char *comm;\r\nint pid;\r\npid = parse_common_pid(pevent, data);\r\ncomm = find_cmdline(pevent, pid);\r\nif (pevent->latency_format) {\r\ntrace_seq_printf(s, "%8.8s-%-5d %3d",\r\ncomm, pid, record->cpu);\r\n} else\r\ntrace_seq_printf(s, "%16s-%-5d [%03d]", comm, pid, record->cpu);\r\n}\r\nvoid pevent_print_event_time(struct pevent *pevent, struct trace_seq *s,\r\nstruct event_format *event,\r\nstruct pevent_record *record,\r\nbool use_trace_clock)\r\n{\r\nunsigned long secs;\r\nunsigned long usecs;\r\nunsigned long nsecs;\r\nint p;\r\nbool use_usec_format;\r\nuse_usec_format = is_timestamp_in_us(pevent->trace_clock,\r\nuse_trace_clock);\r\nif (use_usec_format) {\r\nsecs = record->ts / NSECS_PER_SEC;\r\nnsecs = record->ts - secs * NSECS_PER_SEC;\r\n}\r\nif (pevent->latency_format) {\r\npevent_data_lat_fmt(pevent, s, record);\r\n}\r\nif (use_usec_format) {\r\nif (pevent->flags & PEVENT_NSEC_OUTPUT) {\r\nusecs = nsecs;\r\np = 9;\r\n} else {\r\nusecs = (nsecs + 500) / NSECS_PER_USEC;\r\nif (usecs >= 1000000) {\r\nusecs -= 1000000;\r\nsecs++;\r\n}\r\np = 6;\r\n}\r\ntrace_seq_printf(s, " %5lu.%0*lu:", secs, p, usecs);\r\n} else\r\ntrace_seq_printf(s, " %12llu:", record->ts);\r\n}\r\nvoid pevent_print_event_data(struct pevent *pevent, struct trace_seq *s,\r\nstruct event_format *event,\r\nstruct pevent_record *record)\r\n{\r\nstatic const char *spaces = " ";\r\nint len;\r\ntrace_seq_printf(s, " %s: ", event->name);\r\nlen = strlen(event->name);\r\nif (len < 20)\r\ntrace_seq_printf(s, "%.*s", 20 - len, spaces);\r\npevent_event_info(s, event, record);\r\n}\r\nvoid pevent_print_event(struct pevent *pevent, struct trace_seq *s,\r\nstruct pevent_record *record, bool use_trace_clock)\r\n{\r\nstruct event_format *event;\r\nevent = pevent_find_event_by_record(pevent, record);\r\nif (!event) {\r\ndo_warning("ug! no event found for type %d",\r\ntrace_parse_common_type(pevent, record->data));\r\nreturn;\r\n}\r\npevent_print_event_task(pevent, s, event, record);\r\npevent_print_event_time(pevent, s, event, record, use_trace_clock);\r\npevent_print_event_data(pevent, s, event, record);\r\n}\r\nstatic int events_id_cmp(const void *a, const void *b)\r\n{\r\nstruct event_format * const * ea = a;\r\nstruct event_format * const * eb = b;\r\nif ((*ea)->id < (*eb)->id)\r\nreturn -1;\r\nif ((*ea)->id > (*eb)->id)\r\nreturn 1;\r\nreturn 0;\r\n}\r\nstatic int events_name_cmp(const void *a, const void *b)\r\n{\r\nstruct event_format * const * ea = a;\r\nstruct event_format * const * eb = b;\r\nint res;\r\nres = strcmp((*ea)->name, (*eb)->name);\r\nif (res)\r\nreturn res;\r\nres = strcmp((*ea)->system, (*eb)->system);\r\nif (res)\r\nreturn res;\r\nreturn events_id_cmp(a, b);\r\n}\r\nstatic int events_system_cmp(const void *a, const void *b)\r\n{\r\nstruct event_format * const * ea = a;\r\nstruct event_format * const * eb = b;\r\nint res;\r\nres = strcmp((*ea)->system, (*eb)->system);\r\nif (res)\r\nreturn res;\r\nres = strcmp((*ea)->name, (*eb)->name);\r\nif (res)\r\nreturn res;\r\nreturn events_id_cmp(a, b);\r\n}\r\nstruct event_format **pevent_list_events(struct pevent *pevent, enum event_sort_type sort_type)\r\n{\r\nstruct event_format **events;\r\nint (*sort)(const void *a, const void *b);\r\nevents = pevent->sort_events;\r\nif (events && pevent->last_type == sort_type)\r\nreturn events;\r\nif (!events) {\r\nevents = malloc(sizeof(*events) * (pevent->nr_events + 1));\r\nif (!events)\r\nreturn NULL;\r\nmemcpy(events, pevent->events, sizeof(*events) * pevent->nr_events);\r\nevents[pevent->nr_events] = NULL;\r\npevent->sort_events = events;\r\nif (sort_type == EVENT_SORT_ID) {\r\npevent->last_type = sort_type;\r\nreturn events;\r\n}\r\n}\r\nswitch (sort_type) {\r\ncase EVENT_SORT_ID:\r\nsort = events_id_cmp;\r\nbreak;\r\ncase EVENT_SORT_NAME:\r\nsort = events_name_cmp;\r\nbreak;\r\ncase EVENT_SORT_SYSTEM:\r\nsort = events_system_cmp;\r\nbreak;\r\ndefault:\r\nreturn events;\r\n}\r\nqsort(events, pevent->nr_events, sizeof(*events), sort);\r\npevent->last_type = sort_type;\r\nreturn events;\r\n}\r\nstatic struct format_field **\r\nget_event_fields(const char *type, const char *name,\r\nint count, struct format_field *list)\r\n{\r\nstruct format_field **fields;\r\nstruct format_field *field;\r\nint i = 0;\r\nfields = malloc(sizeof(*fields) * (count + 1));\r\nif (!fields)\r\nreturn NULL;\r\nfor (field = list; field; field = field->next) {\r\nfields[i++] = field;\r\nif (i == count + 1) {\r\ndo_warning("event %s has more %s fields than specified",\r\nname, type);\r\ni--;\r\nbreak;\r\n}\r\n}\r\nif (i != count)\r\ndo_warning("event %s has less %s fields than specified",\r\nname, type);\r\nfields[i] = NULL;\r\nreturn fields;\r\n}\r\nstruct format_field **pevent_event_common_fields(struct event_format *event)\r\n{\r\nreturn get_event_fields("common", event->name,\r\nevent->format.nr_common,\r\nevent->format.common_fields);\r\n}\r\nstruct format_field **pevent_event_fields(struct event_format *event)\r\n{\r\nreturn get_event_fields("event", event->name,\r\nevent->format.nr_fields,\r\nevent->format.fields);\r\n}\r\nstatic void print_fields(struct trace_seq *s, struct print_flag_sym *field)\r\n{\r\ntrace_seq_printf(s, "{ %s, %s }", field->value, field->str);\r\nif (field->next) {\r\ntrace_seq_puts(s, ", ");\r\nprint_fields(s, field->next);\r\n}\r\n}\r\nstatic void print_args(struct print_arg *args)\r\n{\r\nint print_paren = 1;\r\nstruct trace_seq s;\r\nswitch (args->type) {\r\ncase PRINT_NULL:\r\nprintf("null");\r\nbreak;\r\ncase PRINT_ATOM:\r\nprintf("%s", args->atom.atom);\r\nbreak;\r\ncase PRINT_FIELD:\r\nprintf("REC->%s", args->field.name);\r\nbreak;\r\ncase PRINT_FLAGS:\r\nprintf("__print_flags(");\r\nprint_args(args->flags.field);\r\nprintf(", %s, ", args->flags.delim);\r\ntrace_seq_init(&s);\r\nprint_fields(&s, args->flags.flags);\r\ntrace_seq_do_printf(&s);\r\ntrace_seq_destroy(&s);\r\nprintf(")");\r\nbreak;\r\ncase PRINT_SYMBOL:\r\nprintf("__print_symbolic(");\r\nprint_args(args->symbol.field);\r\nprintf(", ");\r\ntrace_seq_init(&s);\r\nprint_fields(&s, args->symbol.symbols);\r\ntrace_seq_do_printf(&s);\r\ntrace_seq_destroy(&s);\r\nprintf(")");\r\nbreak;\r\ncase PRINT_HEX:\r\nprintf("__print_hex(");\r\nprint_args(args->hex.field);\r\nprintf(", ");\r\nprint_args(args->hex.size);\r\nprintf(")");\r\nbreak;\r\ncase PRINT_INT_ARRAY:\r\nprintf("__print_array(");\r\nprint_args(args->int_array.field);\r\nprintf(", ");\r\nprint_args(args->int_array.count);\r\nprintf(", ");\r\nprint_args(args->int_array.el_size);\r\nprintf(")");\r\nbreak;\r\ncase PRINT_STRING:\r\ncase PRINT_BSTRING:\r\nprintf("__get_str(%s)", args->string.string);\r\nbreak;\r\ncase PRINT_BITMASK:\r\nprintf("__get_bitmask(%s)", args->bitmask.bitmask);\r\nbreak;\r\ncase PRINT_TYPE:\r\nprintf("(%s)", args->typecast.type);\r\nprint_args(args->typecast.item);\r\nbreak;\r\ncase PRINT_OP:\r\nif (strcmp(args->op.op, ":") == 0)\r\nprint_paren = 0;\r\nif (print_paren)\r\nprintf("(");\r\nprint_args(args->op.left);\r\nprintf(" %s ", args->op.op);\r\nprint_args(args->op.right);\r\nif (print_paren)\r\nprintf(")");\r\nbreak;\r\ndefault:\r\nreturn;\r\n}\r\nif (args->next) {\r\nprintf("\n");\r\nprint_args(args->next);\r\n}\r\n}\r\nstatic void parse_header_field(const char *field,\r\nint *offset, int *size, int mandatory)\r\n{\r\nunsigned long long save_input_buf_ptr;\r\nunsigned long long save_input_buf_siz;\r\nchar *token;\r\nint type;\r\nsave_input_buf_ptr = input_buf_ptr;\r\nsave_input_buf_siz = input_buf_siz;\r\nif (read_expected(EVENT_ITEM, "field") < 0)\r\nreturn;\r\nif (read_expected(EVENT_OP, ":") < 0)\r\nreturn;\r\nif (read_expect_type(EVENT_ITEM, &token) < 0)\r\ngoto fail;\r\nfree_token(token);\r\nif (mandatory) {\r\nif (read_expected(EVENT_ITEM, field) < 0)\r\nreturn;\r\n} else {\r\nif (read_expect_type(EVENT_ITEM, &token) < 0)\r\ngoto fail;\r\nif (strcmp(token, field) != 0)\r\ngoto discard;\r\nfree_token(token);\r\n}\r\nif (read_expected(EVENT_OP, ";") < 0)\r\nreturn;\r\nif (read_expected(EVENT_ITEM, "offset") < 0)\r\nreturn;\r\nif (read_expected(EVENT_OP, ":") < 0)\r\nreturn;\r\nif (read_expect_type(EVENT_ITEM, &token) < 0)\r\ngoto fail;\r\n*offset = atoi(token);\r\nfree_token(token);\r\nif (read_expected(EVENT_OP, ";") < 0)\r\nreturn;\r\nif (read_expected(EVENT_ITEM, "size") < 0)\r\nreturn;\r\nif (read_expected(EVENT_OP, ":") < 0)\r\nreturn;\r\nif (read_expect_type(EVENT_ITEM, &token) < 0)\r\ngoto fail;\r\n*size = atoi(token);\r\nfree_token(token);\r\nif (read_expected(EVENT_OP, ";") < 0)\r\nreturn;\r\ntype = read_token(&token);\r\nif (type != EVENT_NEWLINE) {\r\nif (type != EVENT_ITEM)\r\ngoto fail;\r\nif (strcmp(token, "signed") != 0)\r\ngoto fail;\r\nfree_token(token);\r\nif (read_expected(EVENT_OP, ":") < 0)\r\nreturn;\r\nif (read_expect_type(EVENT_ITEM, &token))\r\ngoto fail;\r\nfree_token(token);\r\nif (read_expected(EVENT_OP, ";") < 0)\r\nreturn;\r\nif (read_expect_type(EVENT_NEWLINE, &token))\r\ngoto fail;\r\n}\r\nfail:\r\nfree_token(token);\r\nreturn;\r\ndiscard:\r\ninput_buf_ptr = save_input_buf_ptr;\r\ninput_buf_siz = save_input_buf_siz;\r\n*offset = 0;\r\n*size = 0;\r\nfree_token(token);\r\n}\r\nint pevent_parse_header_page(struct pevent *pevent, char *buf, unsigned long size,\r\nint long_size)\r\n{\r\nint ignore;\r\nif (!size) {\r\npevent->header_page_ts_size = sizeof(long long);\r\npevent->header_page_size_size = long_size;\r\npevent->header_page_data_offset = sizeof(long long) + long_size;\r\npevent->old_format = 1;\r\nreturn -1;\r\n}\r\ninit_input_buf(buf, size);\r\nparse_header_field("timestamp", &pevent->header_page_ts_offset,\r\n&pevent->header_page_ts_size, 1);\r\nparse_header_field("commit", &pevent->header_page_size_offset,\r\n&pevent->header_page_size_size, 1);\r\nparse_header_field("overwrite", &pevent->header_page_overwrite,\r\n&ignore, 0);\r\nparse_header_field("data", &pevent->header_page_data_offset,\r\n&pevent->header_page_data_size, 1);\r\nreturn 0;\r\n}\r\nstatic int event_matches(struct event_format *event,\r\nint id, const char *sys_name,\r\nconst char *event_name)\r\n{\r\nif (id >= 0 && id != event->id)\r\nreturn 0;\r\nif (event_name && (strcmp(event_name, event->name) != 0))\r\nreturn 0;\r\nif (sys_name && (strcmp(sys_name, event->system) != 0))\r\nreturn 0;\r\nreturn 1;\r\n}\r\nstatic void free_handler(struct event_handler *handle)\r\n{\r\nfree((void *)handle->sys_name);\r\nfree((void *)handle->event_name);\r\nfree(handle);\r\n}\r\nstatic int find_event_handle(struct pevent *pevent, struct event_format *event)\r\n{\r\nstruct event_handler *handle, **next;\r\nfor (next = &pevent->handlers; *next;\r\nnext = &(*next)->next) {\r\nhandle = *next;\r\nif (event_matches(event, handle->id,\r\nhandle->sys_name,\r\nhandle->event_name))\r\nbreak;\r\n}\r\nif (!(*next))\r\nreturn 0;\r\npr_stat("overriding event (%d) %s:%s with new print handler",\r\nevent->id, event->system, event->name);\r\nevent->handler = handle->func;\r\nevent->context = handle->context;\r\n*next = handle->next;\r\nfree_handler(handle);\r\nreturn 1;\r\n}\r\nenum pevent_errno __pevent_parse_format(struct event_format **eventp,\r\nstruct pevent *pevent, const char *buf,\r\nunsigned long size, const char *sys)\r\n{\r\nstruct event_format *event;\r\nint ret;\r\ninit_input_buf(buf, size);\r\n*eventp = event = alloc_event();\r\nif (!event)\r\nreturn PEVENT_ERRNO__MEM_ALLOC_FAILED;\r\nevent->name = event_read_name();\r\nif (!event->name) {\r\nret = PEVENT_ERRNO__MEM_ALLOC_FAILED;\r\ngoto event_alloc_failed;\r\n}\r\nif (strcmp(sys, "ftrace") == 0) {\r\nevent->flags |= EVENT_FL_ISFTRACE;\r\nif (strcmp(event->name, "bprint") == 0)\r\nevent->flags |= EVENT_FL_ISBPRINT;\r\n}\r\nevent->id = event_read_id();\r\nif (event->id < 0) {\r\nret = PEVENT_ERRNO__READ_ID_FAILED;\r\ngoto event_alloc_failed;\r\n}\r\nevent->system = strdup(sys);\r\nif (!event->system) {\r\nret = PEVENT_ERRNO__MEM_ALLOC_FAILED;\r\ngoto event_alloc_failed;\r\n}\r\nevent->pevent = pevent;\r\nret = event_read_format(event);\r\nif (ret < 0) {\r\nret = PEVENT_ERRNO__READ_FORMAT_FAILED;\r\ngoto event_parse_failed;\r\n}\r\nif (pevent && find_event_handle(pevent, event))\r\nshow_warning = 0;\r\nret = event_read_print(event);\r\nshow_warning = 1;\r\nif (ret < 0) {\r\nret = PEVENT_ERRNO__READ_PRINT_FAILED;\r\ngoto event_parse_failed;\r\n}\r\nif (!ret && (event->flags & EVENT_FL_ISFTRACE)) {\r\nstruct format_field *field;\r\nstruct print_arg *arg, **list;\r\nlist = &event->print_fmt.args;\r\nfor (field = event->format.fields; field; field = field->next) {\r\narg = alloc_arg();\r\nif (!arg) {\r\nevent->flags |= EVENT_FL_FAILED;\r\nreturn PEVENT_ERRNO__OLD_FTRACE_ARG_FAILED;\r\n}\r\narg->type = PRINT_FIELD;\r\narg->field.name = strdup(field->name);\r\nif (!arg->field.name) {\r\nevent->flags |= EVENT_FL_FAILED;\r\nfree_arg(arg);\r\nreturn PEVENT_ERRNO__OLD_FTRACE_ARG_FAILED;\r\n}\r\narg->field.field = field;\r\n*list = arg;\r\nlist = &arg->next;\r\n}\r\nreturn 0;\r\n}\r\nreturn 0;\r\nevent_parse_failed:\r\nevent->flags |= EVENT_FL_FAILED;\r\nreturn ret;\r\nevent_alloc_failed:\r\nfree(event->system);\r\nfree(event->name);\r\nfree(event);\r\n*eventp = NULL;\r\nreturn ret;\r\n}\r\nstatic enum pevent_errno\r\n__pevent_parse_event(struct pevent *pevent,\r\nstruct event_format **eventp,\r\nconst char *buf, unsigned long size,\r\nconst char *sys)\r\n{\r\nint ret = __pevent_parse_format(eventp, pevent, buf, size, sys);\r\nstruct event_format *event = *eventp;\r\nif (event == NULL)\r\nreturn ret;\r\nif (pevent && add_event(pevent, event)) {\r\nret = PEVENT_ERRNO__MEM_ALLOC_FAILED;\r\ngoto event_add_failed;\r\n}\r\n#define PRINT_ARGS 0\r\nif (PRINT_ARGS && event->print_fmt.args)\r\nprint_args(event->print_fmt.args);\r\nreturn 0;\r\nevent_add_failed:\r\npevent_free_format(event);\r\nreturn ret;\r\n}\r\nenum pevent_errno pevent_parse_format(struct pevent *pevent,\r\nstruct event_format **eventp,\r\nconst char *buf,\r\nunsigned long size, const char *sys)\r\n{\r\nreturn __pevent_parse_event(pevent, eventp, buf, size, sys);\r\n}\r\nenum pevent_errno pevent_parse_event(struct pevent *pevent, const char *buf,\r\nunsigned long size, const char *sys)\r\n{\r\nstruct event_format *event = NULL;\r\nreturn __pevent_parse_event(pevent, &event, buf, size, sys);\r\n}\r\nint pevent_strerror(struct pevent *pevent __maybe_unused,\r\nenum pevent_errno errnum, char *buf, size_t buflen)\r\n{\r\nint idx;\r\nconst char *msg;\r\nif (errnum >= 0) {\r\nmsg = strerror_r(errnum, buf, buflen);\r\nif (msg != buf) {\r\nsize_t len = strlen(msg);\r\nmemcpy(buf, msg, min(buflen - 1, len));\r\n*(buf + min(buflen - 1, len)) = '\0';\r\n}\r\nreturn 0;\r\n}\r\nif (errnum <= __PEVENT_ERRNO__START ||\r\nerrnum >= __PEVENT_ERRNO__END)\r\nreturn -1;\r\nidx = errnum - __PEVENT_ERRNO__START - 1;\r\nmsg = pevent_error_str[idx];\r\nsnprintf(buf, buflen, "%s", msg);\r\nreturn 0;\r\n}\r\nint get_field_val(struct trace_seq *s, struct format_field *field,\r\nconst char *name, struct pevent_record *record,\r\nunsigned long long *val, int err)\r\n{\r\nif (!field) {\r\nif (err)\r\ntrace_seq_printf(s, "<CANT FIND FIELD %s>", name);\r\nreturn -1;\r\n}\r\nif (pevent_read_number_field(field, record->data, val)) {\r\nif (err)\r\ntrace_seq_printf(s, " %s=INVALID", name);\r\nreturn -1;\r\n}\r\nreturn 0;\r\n}\r\nvoid *pevent_get_field_raw(struct trace_seq *s, struct event_format *event,\r\nconst char *name, struct pevent_record *record,\r\nint *len, int err)\r\n{\r\nstruct format_field *field;\r\nvoid *data = record->data;\r\nunsigned offset;\r\nint dummy;\r\nif (!event)\r\nreturn NULL;\r\nfield = pevent_find_field(event, name);\r\nif (!field) {\r\nif (err)\r\ntrace_seq_printf(s, "<CANT FIND FIELD %s>", name);\r\nreturn NULL;\r\n}\r\nif (!len)\r\nlen = &dummy;\r\noffset = field->offset;\r\nif (field->flags & FIELD_IS_DYNAMIC) {\r\noffset = pevent_read_number(event->pevent,\r\ndata + offset, field->size);\r\n*len = offset >> 16;\r\noffset &= 0xffff;\r\n} else\r\n*len = field->size;\r\nreturn data + offset;\r\n}\r\nint pevent_get_field_val(struct trace_seq *s, struct event_format *event,\r\nconst char *name, struct pevent_record *record,\r\nunsigned long long *val, int err)\r\n{\r\nstruct format_field *field;\r\nif (!event)\r\nreturn -1;\r\nfield = pevent_find_field(event, name);\r\nreturn get_field_val(s, field, name, record, val, err);\r\n}\r\nint pevent_get_common_field_val(struct trace_seq *s, struct event_format *event,\r\nconst char *name, struct pevent_record *record,\r\nunsigned long long *val, int err)\r\n{\r\nstruct format_field *field;\r\nif (!event)\r\nreturn -1;\r\nfield = pevent_find_common_field(event, name);\r\nreturn get_field_val(s, field, name, record, val, err);\r\n}\r\nint pevent_get_any_field_val(struct trace_seq *s, struct event_format *event,\r\nconst char *name, struct pevent_record *record,\r\nunsigned long long *val, int err)\r\n{\r\nstruct format_field *field;\r\nif (!event)\r\nreturn -1;\r\nfield = pevent_find_any_field(event, name);\r\nreturn get_field_val(s, field, name, record, val, err);\r\n}\r\nint pevent_print_num_field(struct trace_seq *s, const char *fmt,\r\nstruct event_format *event, const char *name,\r\nstruct pevent_record *record, int err)\r\n{\r\nstruct format_field *field = pevent_find_field(event, name);\r\nunsigned long long val;\r\nif (!field)\r\ngoto failed;\r\nif (pevent_read_number_field(field, record->data, &val))\r\ngoto failed;\r\nreturn trace_seq_printf(s, fmt, val);\r\nfailed:\r\nif (err)\r\ntrace_seq_printf(s, "CAN'T FIND FIELD \"%s\"", name);\r\nreturn -1;\r\n}\r\nint pevent_print_func_field(struct trace_seq *s, const char *fmt,\r\nstruct event_format *event, const char *name,\r\nstruct pevent_record *record, int err)\r\n{\r\nstruct format_field *field = pevent_find_field(event, name);\r\nstruct pevent *pevent = event->pevent;\r\nunsigned long long val;\r\nstruct func_map *func;\r\nchar tmp[128];\r\nif (!field)\r\ngoto failed;\r\nif (pevent_read_number_field(field, record->data, &val))\r\ngoto failed;\r\nfunc = find_func(pevent, val);\r\nif (func)\r\nsnprintf(tmp, 128, "%s/0x%llx", func->func, func->addr - val);\r\nelse\r\nsprintf(tmp, "0x%08llx", val);\r\nreturn trace_seq_printf(s, fmt, tmp);\r\nfailed:\r\nif (err)\r\ntrace_seq_printf(s, "CAN'T FIND FIELD \"%s\"", name);\r\nreturn -1;\r\n}\r\nstatic void free_func_handle(struct pevent_function_handler *func)\r\n{\r\nstruct pevent_func_params *params;\r\nfree(func->name);\r\nwhile (func->params) {\r\nparams = func->params;\r\nfunc->params = params->next;\r\nfree(params);\r\n}\r\nfree(func);\r\n}\r\nint pevent_register_print_function(struct pevent *pevent,\r\npevent_func_handler func,\r\nenum pevent_func_arg_type ret_type,\r\nchar *name, ...)\r\n{\r\nstruct pevent_function_handler *func_handle;\r\nstruct pevent_func_params **next_param;\r\nstruct pevent_func_params *param;\r\nenum pevent_func_arg_type type;\r\nva_list ap;\r\nint ret;\r\nfunc_handle = find_func_handler(pevent, name);\r\nif (func_handle) {\r\npr_stat("override of function helper '%s'", name);\r\nremove_func_handler(pevent, name);\r\n}\r\nfunc_handle = calloc(1, sizeof(*func_handle));\r\nif (!func_handle) {\r\ndo_warning("Failed to allocate function handler");\r\nreturn PEVENT_ERRNO__MEM_ALLOC_FAILED;\r\n}\r\nfunc_handle->ret_type = ret_type;\r\nfunc_handle->name = strdup(name);\r\nfunc_handle->func = func;\r\nif (!func_handle->name) {\r\ndo_warning("Failed to allocate function name");\r\nfree(func_handle);\r\nreturn PEVENT_ERRNO__MEM_ALLOC_FAILED;\r\n}\r\nnext_param = &(func_handle->params);\r\nva_start(ap, name);\r\nfor (;;) {\r\ntype = va_arg(ap, enum pevent_func_arg_type);\r\nif (type == PEVENT_FUNC_ARG_VOID)\r\nbreak;\r\nif (type >= PEVENT_FUNC_ARG_MAX_TYPES) {\r\ndo_warning("Invalid argument type %d", type);\r\nret = PEVENT_ERRNO__INVALID_ARG_TYPE;\r\ngoto out_free;\r\n}\r\nparam = malloc(sizeof(*param));\r\nif (!param) {\r\ndo_warning("Failed to allocate function param");\r\nret = PEVENT_ERRNO__MEM_ALLOC_FAILED;\r\ngoto out_free;\r\n}\r\nparam->type = type;\r\nparam->next = NULL;\r\n*next_param = param;\r\nnext_param = &(param->next);\r\nfunc_handle->nr_args++;\r\n}\r\nva_end(ap);\r\nfunc_handle->next = pevent->func_handlers;\r\npevent->func_handlers = func_handle;\r\nreturn 0;\r\nout_free:\r\nva_end(ap);\r\nfree_func_handle(func_handle);\r\nreturn ret;\r\n}\r\nint pevent_unregister_print_function(struct pevent *pevent,\r\npevent_func_handler func, char *name)\r\n{\r\nstruct pevent_function_handler *func_handle;\r\nfunc_handle = find_func_handler(pevent, name);\r\nif (func_handle && func_handle->func == func) {\r\nremove_func_handler(pevent, name);\r\nreturn 0;\r\n}\r\nreturn -1;\r\n}\r\nstatic struct event_format *pevent_search_event(struct pevent *pevent, int id,\r\nconst char *sys_name,\r\nconst char *event_name)\r\n{\r\nstruct event_format *event;\r\nif (id >= 0) {\r\nevent = pevent_find_event(pevent, id);\r\nif (!event)\r\nreturn NULL;\r\nif (event_name && (strcmp(event_name, event->name) != 0))\r\nreturn NULL;\r\nif (sys_name && (strcmp(sys_name, event->system) != 0))\r\nreturn NULL;\r\n} else {\r\nevent = pevent_find_event_by_name(pevent, sys_name, event_name);\r\nif (!event)\r\nreturn NULL;\r\n}\r\nreturn event;\r\n}\r\nint pevent_register_event_handler(struct pevent *pevent, int id,\r\nconst char *sys_name, const char *event_name,\r\npevent_event_handler_func func, void *context)\r\n{\r\nstruct event_format *event;\r\nstruct event_handler *handle;\r\nevent = pevent_search_event(pevent, id, sys_name, event_name);\r\nif (event == NULL)\r\ngoto not_found;\r\npr_stat("overriding event (%d) %s:%s with new print handler",\r\nevent->id, event->system, event->name);\r\nevent->handler = func;\r\nevent->context = context;\r\nreturn 0;\r\nnot_found:\r\nhandle = calloc(1, sizeof(*handle));\r\nif (!handle) {\r\ndo_warning("Failed to allocate event handler");\r\nreturn PEVENT_ERRNO__MEM_ALLOC_FAILED;\r\n}\r\nhandle->id = id;\r\nif (event_name)\r\nhandle->event_name = strdup(event_name);\r\nif (sys_name)\r\nhandle->sys_name = strdup(sys_name);\r\nif ((event_name && !handle->event_name) ||\r\n(sys_name && !handle->sys_name)) {\r\ndo_warning("Failed to allocate event/sys name");\r\nfree((void *)handle->event_name);\r\nfree((void *)handle->sys_name);\r\nfree(handle);\r\nreturn PEVENT_ERRNO__MEM_ALLOC_FAILED;\r\n}\r\nhandle->func = func;\r\nhandle->next = pevent->handlers;\r\npevent->handlers = handle;\r\nhandle->context = context;\r\nreturn -1;\r\n}\r\nstatic int handle_matches(struct event_handler *handler, int id,\r\nconst char *sys_name, const char *event_name,\r\npevent_event_handler_func func, void *context)\r\n{\r\nif (id >= 0 && id != handler->id)\r\nreturn 0;\r\nif (event_name && (strcmp(event_name, handler->event_name) != 0))\r\nreturn 0;\r\nif (sys_name && (strcmp(sys_name, handler->sys_name) != 0))\r\nreturn 0;\r\nif (func != handler->func || context != handler->context)\r\nreturn 0;\r\nreturn 1;\r\n}\r\nint pevent_unregister_event_handler(struct pevent *pevent, int id,\r\nconst char *sys_name, const char *event_name,\r\npevent_event_handler_func func, void *context)\r\n{\r\nstruct event_format *event;\r\nstruct event_handler *handle;\r\nstruct event_handler **next;\r\nevent = pevent_search_event(pevent, id, sys_name, event_name);\r\nif (event == NULL)\r\ngoto not_found;\r\nif (event->handler == func && event->context == context) {\r\npr_stat("removing override handler for event (%d) %s:%s. Going back to default handler.",\r\nevent->id, event->system, event->name);\r\nevent->handler = NULL;\r\nevent->context = NULL;\r\nreturn 0;\r\n}\r\nnot_found:\r\nfor (next = &pevent->handlers; *next; next = &(*next)->next) {\r\nhandle = *next;\r\nif (handle_matches(handle, id, sys_name, event_name,\r\nfunc, context))\r\nbreak;\r\n}\r\nif (!(*next))\r\nreturn -1;\r\n*next = handle->next;\r\nfree_handler(handle);\r\nreturn 0;\r\n}\r\nstruct pevent *pevent_alloc(void)\r\n{\r\nstruct pevent *pevent = calloc(1, sizeof(*pevent));\r\nif (pevent)\r\npevent->ref_count = 1;\r\nreturn pevent;\r\n}\r\nvoid pevent_ref(struct pevent *pevent)\r\n{\r\npevent->ref_count++;\r\n}\r\nvoid pevent_free_format_field(struct format_field *field)\r\n{\r\nfree(field->type);\r\nif (field->alias != field->name)\r\nfree(field->alias);\r\nfree(field->name);\r\nfree(field);\r\n}\r\nstatic void free_format_fields(struct format_field *field)\r\n{\r\nstruct format_field *next;\r\nwhile (field) {\r\nnext = field->next;\r\npevent_free_format_field(field);\r\nfield = next;\r\n}\r\n}\r\nstatic void free_formats(struct format *format)\r\n{\r\nfree_format_fields(format->common_fields);\r\nfree_format_fields(format->fields);\r\n}\r\nvoid pevent_free_format(struct event_format *event)\r\n{\r\nfree(event->name);\r\nfree(event->system);\r\nfree_formats(&event->format);\r\nfree(event->print_fmt.format);\r\nfree_args(event->print_fmt.args);\r\nfree(event);\r\n}\r\nvoid pevent_free(struct pevent *pevent)\r\n{\r\nstruct cmdline_list *cmdlist, *cmdnext;\r\nstruct func_list *funclist, *funcnext;\r\nstruct printk_list *printklist, *printknext;\r\nstruct pevent_function_handler *func_handler;\r\nstruct event_handler *handle;\r\nint i;\r\nif (!pevent)\r\nreturn;\r\ncmdlist = pevent->cmdlist;\r\nfunclist = pevent->funclist;\r\nprintklist = pevent->printklist;\r\npevent->ref_count--;\r\nif (pevent->ref_count)\r\nreturn;\r\nif (pevent->cmdlines) {\r\nfor (i = 0; i < pevent->cmdline_count; i++)\r\nfree(pevent->cmdlines[i].comm);\r\nfree(pevent->cmdlines);\r\n}\r\nwhile (cmdlist) {\r\ncmdnext = cmdlist->next;\r\nfree(cmdlist->comm);\r\nfree(cmdlist);\r\ncmdlist = cmdnext;\r\n}\r\nif (pevent->func_map) {\r\nfor (i = 0; i < (int)pevent->func_count; i++) {\r\nfree(pevent->func_map[i].func);\r\nfree(pevent->func_map[i].mod);\r\n}\r\nfree(pevent->func_map);\r\n}\r\nwhile (funclist) {\r\nfuncnext = funclist->next;\r\nfree(funclist->func);\r\nfree(funclist->mod);\r\nfree(funclist);\r\nfunclist = funcnext;\r\n}\r\nwhile (pevent->func_handlers) {\r\nfunc_handler = pevent->func_handlers;\r\npevent->func_handlers = func_handler->next;\r\nfree_func_handle(func_handler);\r\n}\r\nif (pevent->printk_map) {\r\nfor (i = 0; i < (int)pevent->printk_count; i++)\r\nfree(pevent->printk_map[i].printk);\r\nfree(pevent->printk_map);\r\n}\r\nwhile (printklist) {\r\nprintknext = printklist->next;\r\nfree(printklist->printk);\r\nfree(printklist);\r\nprintklist = printknext;\r\n}\r\nfor (i = 0; i < pevent->nr_events; i++)\r\npevent_free_format(pevent->events[i]);\r\nwhile (pevent->handlers) {\r\nhandle = pevent->handlers;\r\npevent->handlers = handle->next;\r\nfree_handler(handle);\r\n}\r\nfree(pevent->trace_clock);\r\nfree(pevent->events);\r\nfree(pevent->sort_events);\r\nfree(pevent->func_resolver);\r\nfree(pevent);\r\n}\r\nvoid pevent_unref(struct pevent *pevent)\r\n{\r\npevent_free(pevent);\r\n}
