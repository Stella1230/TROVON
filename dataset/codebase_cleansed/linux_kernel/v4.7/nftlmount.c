static int find_boot_record(struct NFTLrecord *nftl)\r\n{\r\nstruct nftl_uci1 h1;\r\nunsigned int block, boot_record_count = 0;\r\nsize_t retlen;\r\nu8 buf[SECTORSIZE];\r\nstruct NFTLMediaHeader *mh = &nftl->MediaHdr;\r\nstruct mtd_info *mtd = nftl->mbd.mtd;\r\nunsigned int i;\r\nnftl->EraseSize = nftl->mbd.mtd->erasesize;\r\nnftl->nb_blocks = (u32)nftl->mbd.mtd->size / nftl->EraseSize;\r\nnftl->MediaUnit = BLOCK_NIL;\r\nnftl->SpareMediaUnit = BLOCK_NIL;\r\nfor (block = 0; block < nftl->nb_blocks; block++) {\r\nint ret;\r\nret = mtd_read(mtd, block * nftl->EraseSize, SECTORSIZE,\r\n&retlen, buf);\r\nif (retlen != SECTORSIZE) {\r\nstatic int warncount = 5;\r\nif (warncount) {\r\nprintk(KERN_WARNING "Block read at 0x%x of mtd%d failed: %d\n",\r\nblock * nftl->EraseSize, nftl->mbd.mtd->index, ret);\r\nif (!--warncount)\r\nprintk(KERN_WARNING "Further failures for this block will not be printed\n");\r\n}\r\ncontinue;\r\n}\r\nif (retlen < 6 || memcmp(buf, "ANAND", 6)) {\r\n#if 0\r\nprintk(KERN_DEBUG "ANAND header not found at 0x%x in mtd%d\n",\r\nblock * nftl->EraseSize, nftl->mbd.mtd->index);\r\n#endif\r\ncontinue;\r\n}\r\nret = nftl_read_oob(mtd, block * nftl->EraseSize +\r\nSECTORSIZE + 8, 8, &retlen,\r\n(char *)&h1);\r\nif (ret < 0) {\r\nprintk(KERN_WARNING "ANAND header found at 0x%x in mtd%d, but OOB data read failed (err %d)\n",\r\nblock * nftl->EraseSize, nftl->mbd.mtd->index, ret);\r\ncontinue;\r\n}\r\n#if 0\r\nif (le16_to_cpu(h1.EraseMark | h1.EraseMark1) != ERASE_MARK) {\r\nprintk(KERN_NOTICE "ANAND header found at 0x%x in mtd%d, but erase mark not present (0x%04x,0x%04x instead)\n",\r\nblock * nftl->EraseSize, nftl->mbd.mtd->index,\r\nle16_to_cpu(h1.EraseMark), le16_to_cpu(h1.EraseMark1));\r\ncontinue;\r\n}\r\nret = mtd->read(mtd, block * nftl->EraseSize, SECTORSIZE,\r\n&retlen, buf);\r\nif (ret < 0) {\r\nprintk(KERN_NOTICE "ANAND header found at 0x%x in mtd%d, but ECC read failed (err %d)\n",\r\nblock * nftl->EraseSize, nftl->mbd.mtd->index, ret);\r\ncontinue;\r\n}\r\nif (memcmp(buf, "ANAND", 6)) {\r\nprintk(KERN_NOTICE "ANAND header found at 0x%x in mtd%d, but went away on reread!\n",\r\nblock * nftl->EraseSize, nftl->mbd.mtd->index);\r\nprintk(KERN_NOTICE "New data are: %02x %02x %02x %02x %02x %02x\n",\r\nbuf[0], buf[1], buf[2], buf[3], buf[4], buf[5]);\r\ncontinue;\r\n}\r\n#endif\r\nif (boot_record_count) {\r\nif (memcmp(mh, buf, sizeof(struct NFTLMediaHeader))) {\r\nprintk(KERN_NOTICE "NFTL Media Headers at 0x%x and 0x%x disagree.\n",\r\nnftl->MediaUnit * nftl->EraseSize, block * nftl->EraseSize);\r\nif (boot_record_count < 2) {\r\nreturn -1;\r\n}\r\ncontinue;\r\n}\r\nif (boot_record_count == 1)\r\nnftl->SpareMediaUnit = block;\r\nnftl->ReplUnitTable[block] = BLOCK_RESERVED;\r\nboot_record_count++;\r\ncontinue;\r\n}\r\nmemcpy(mh, buf, sizeof(struct NFTLMediaHeader));\r\n#if 0\r\nThe new DiskOnChip driver scans the MediaHeader itself, and presents a virtual\r\nerasesize based on UnitSizeFactor. So the erasesize we read from the mtd\r\ndevice is already correct.\r\nif (mh->UnitSizeFactor == 0) {\r\nprintk(KERN_NOTICE "NFTL: UnitSizeFactor 0x00 detected. This violates the spec but we think we know what it means...\n");\r\n} else if (mh->UnitSizeFactor < 0xfc) {\r\nprintk(KERN_NOTICE "Sorry, we don't support UnitSizeFactor 0x%02x\n",\r\nmh->UnitSizeFactor);\r\nreturn -1;\r\n} else if (mh->UnitSizeFactor != 0xff) {\r\nprintk(KERN_NOTICE "WARNING: Support for NFTL with UnitSizeFactor 0x%02x is experimental\n",\r\nmh->UnitSizeFactor);\r\nnftl->EraseSize = nftl->mbd.mtd->erasesize << (0xff - mh->UnitSizeFactor);\r\nnftl->nb_blocks = (u32)nftl->mbd.mtd->size / nftl->EraseSize;\r\n}\r\n#endif\r\nnftl->nb_boot_blocks = le16_to_cpu(mh->FirstPhysicalEUN);\r\nif ((nftl->nb_boot_blocks + 2) >= nftl->nb_blocks) {\r\nprintk(KERN_NOTICE "NFTL Media Header sanity check failed:\n");\r\nprintk(KERN_NOTICE "nb_boot_blocks (%d) + 2 > nb_blocks (%d)\n",\r\nnftl->nb_boot_blocks, nftl->nb_blocks);\r\nreturn -1;\r\n}\r\nnftl->numvunits = le32_to_cpu(mh->FormattedSize) / nftl->EraseSize;\r\nif (nftl->numvunits > (nftl->nb_blocks - nftl->nb_boot_blocks - 2)) {\r\nprintk(KERN_NOTICE "NFTL Media Header sanity check failed:\n");\r\nprintk(KERN_NOTICE "numvunits (%d) > nb_blocks (%d) - nb_boot_blocks(%d) - 2\n",\r\nnftl->numvunits, nftl->nb_blocks, nftl->nb_boot_blocks);\r\nreturn -1;\r\n}\r\nnftl->mbd.size = nftl->numvunits * (nftl->EraseSize / SECTORSIZE);\r\nnftl->nb_blocks = le16_to_cpu(mh->NumEraseUnits) + le16_to_cpu(mh->FirstPhysicalEUN);\r\nnftl->lastEUN = nftl->nb_blocks - 1;\r\nnftl->EUNtable = kmalloc(nftl->nb_blocks * sizeof(u16), GFP_KERNEL);\r\nif (!nftl->EUNtable) {\r\nprintk(KERN_NOTICE "NFTL: allocation of EUNtable failed\n");\r\nreturn -ENOMEM;\r\n}\r\nnftl->ReplUnitTable = kmalloc(nftl->nb_blocks * sizeof(u16), GFP_KERNEL);\r\nif (!nftl->ReplUnitTable) {\r\nkfree(nftl->EUNtable);\r\nprintk(KERN_NOTICE "NFTL: allocation of ReplUnitTable failed\n");\r\nreturn -ENOMEM;\r\n}\r\nfor (i = 0; i < nftl->nb_boot_blocks; i++)\r\nnftl->ReplUnitTable[i] = BLOCK_RESERVED;\r\nfor (; i < nftl->nb_blocks; i++) {\r\nnftl->ReplUnitTable[i] = BLOCK_NOTEXPLORED;\r\n}\r\nnftl->ReplUnitTable[block] = BLOCK_RESERVED;\r\nfor (i = 0; i < nftl->nb_blocks; i++) {\r\n#if 0\r\nThe new DiskOnChip driver already scanned the bad block table. Just query it.\r\nif ((i & (SECTORSIZE - 1)) == 0) {\r\nret = mtd->read(nftl->mbd.mtd,\r\nblock * nftl->EraseSize + i +\r\nSECTORSIZE, SECTORSIZE,\r\n&retlen, buf);\r\nif (ret < 0) {\r\nprintk(KERN_NOTICE "Read of bad sector table failed (err %d)\n",\r\nret);\r\nkfree(nftl->ReplUnitTable);\r\nkfree(nftl->EUNtable);\r\nreturn -1;\r\n}\r\n}\r\nif (buf[i & (SECTORSIZE - 1)] != 0xff)\r\nnftl->ReplUnitTable[i] = BLOCK_RESERVED;\r\n#endif\r\nif (mtd_block_isbad(nftl->mbd.mtd,\r\ni * nftl->EraseSize))\r\nnftl->ReplUnitTable[i] = BLOCK_RESERVED;\r\n}\r\nnftl->MediaUnit = block;\r\nboot_record_count++;\r\n}\r\nreturn boot_record_count?0:-1;\r\n}\r\nstatic int memcmpb(void *a, int c, int n)\r\n{\r\nint i;\r\nfor (i = 0; i < n; i++) {\r\nif (c != ((unsigned char *)a)[i])\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}\r\nstatic int check_free_sectors(struct NFTLrecord *nftl, unsigned int address, int len,\r\nint check_oob)\r\n{\r\nu8 buf[SECTORSIZE + nftl->mbd.mtd->oobsize];\r\nstruct mtd_info *mtd = nftl->mbd.mtd;\r\nsize_t retlen;\r\nint i;\r\nfor (i = 0; i < len; i += SECTORSIZE) {\r\nif (mtd_read(mtd, address, SECTORSIZE, &retlen, buf))\r\nreturn -1;\r\nif (memcmpb(buf, 0xff, SECTORSIZE) != 0)\r\nreturn -1;\r\nif (check_oob) {\r\nif(nftl_read_oob(mtd, address, mtd->oobsize,\r\n&retlen, &buf[SECTORSIZE]) < 0)\r\nreturn -1;\r\nif (memcmpb(buf + SECTORSIZE, 0xff, mtd->oobsize) != 0)\r\nreturn -1;\r\n}\r\naddress += SECTORSIZE;\r\n}\r\nreturn 0;\r\n}\r\nint NFTL_formatblock(struct NFTLrecord *nftl, int block)\r\n{\r\nsize_t retlen;\r\nunsigned int nb_erases, erase_mark;\r\nstruct nftl_uci1 uci;\r\nstruct erase_info *instr = &nftl->instr;\r\nstruct mtd_info *mtd = nftl->mbd.mtd;\r\nif (nftl_read_oob(mtd, block * nftl->EraseSize + SECTORSIZE + 8,\r\n8, &retlen, (char *)&uci) < 0)\r\ngoto default_uci1;\r\nerase_mark = le16_to_cpu ((uci.EraseMark | uci.EraseMark1));\r\nif (erase_mark != ERASE_MARK) {\r\ndefault_uci1:\r\nuci.EraseMark = cpu_to_le16(ERASE_MARK);\r\nuci.EraseMark1 = cpu_to_le16(ERASE_MARK);\r\nuci.WearInfo = cpu_to_le32(0);\r\n}\r\nmemset(instr, 0, sizeof(struct erase_info));\r\ninstr->mtd = nftl->mbd.mtd;\r\ninstr->addr = block * nftl->EraseSize;\r\ninstr->len = nftl->EraseSize;\r\nmtd_erase(mtd, instr);\r\nif (instr->state == MTD_ERASE_FAILED) {\r\nprintk("Error while formatting block %d\n", block);\r\ngoto fail;\r\n}\r\nnb_erases = le32_to_cpu(uci.WearInfo);\r\nnb_erases++;\r\nif (nb_erases == 0)\r\nnb_erases = 1;\r\nif (check_free_sectors(nftl, instr->addr, nftl->EraseSize, 1) != 0)\r\ngoto fail;\r\nuci.WearInfo = le32_to_cpu(nb_erases);\r\nif (nftl_write_oob(mtd, block * nftl->EraseSize + SECTORSIZE +\r\n8, 8, &retlen, (char *)&uci) < 0)\r\ngoto fail;\r\nreturn 0;\r\nfail:\r\nmtd_block_markbad(nftl->mbd.mtd, instr->addr);\r\nreturn -1;\r\n}\r\nstatic void check_sectors_in_chain(struct NFTLrecord *nftl, unsigned int first_block)\r\n{\r\nstruct mtd_info *mtd = nftl->mbd.mtd;\r\nunsigned int block, i, status;\r\nstruct nftl_bci bci;\r\nint sectors_per_block;\r\nsize_t retlen;\r\nsectors_per_block = nftl->EraseSize / SECTORSIZE;\r\nblock = first_block;\r\nfor (;;) {\r\nfor (i = 0; i < sectors_per_block; i++) {\r\nif (nftl_read_oob(mtd,\r\nblock * nftl->EraseSize + i * SECTORSIZE,\r\n8, &retlen, (char *)&bci) < 0)\r\nstatus = SECTOR_IGNORE;\r\nelse\r\nstatus = bci.Status | bci.Status1;\r\nswitch(status) {\r\ncase SECTOR_FREE:\r\nif (memcmpb(&bci, 0xff, 8) != 0 ||\r\ncheck_free_sectors(nftl, block * nftl->EraseSize + i * SECTORSIZE,\r\nSECTORSIZE, 0) != 0) {\r\nprintk("Incorrect free sector %d in block %d: "\r\n"marking it as ignored\n",\r\ni, block);\r\nbci.Status = SECTOR_IGNORE;\r\nbci.Status1 = SECTOR_IGNORE;\r\nnftl_write_oob(mtd, block *\r\nnftl->EraseSize +\r\ni * SECTORSIZE, 8,\r\n&retlen, (char *)&bci);\r\n}\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nblock = nftl->ReplUnitTable[block];\r\nif (!(block == BLOCK_NIL || block < nftl->nb_blocks))\r\nprintk("incorrect ReplUnitTable[] : %d\n", block);\r\nif (block == BLOCK_NIL || block >= nftl->nb_blocks)\r\nbreak;\r\n}\r\n}\r\nstatic int calc_chain_length(struct NFTLrecord *nftl, unsigned int first_block)\r\n{\r\nunsigned int length = 0, block = first_block;\r\nfor (;;) {\r\nlength++;\r\nif (length >= nftl->nb_blocks) {\r\nprintk("nftl: length too long %d !\n", length);\r\nbreak;\r\n}\r\nblock = nftl->ReplUnitTable[block];\r\nif (!(block == BLOCK_NIL || block < nftl->nb_blocks))\r\nprintk("incorrect ReplUnitTable[] : %d\n", block);\r\nif (block == BLOCK_NIL || block >= nftl->nb_blocks)\r\nbreak;\r\n}\r\nreturn length;\r\n}\r\nstatic void format_chain(struct NFTLrecord *nftl, unsigned int first_block)\r\n{\r\nunsigned int block = first_block, block1;\r\nprintk("Formatting chain at block %d\n", first_block);\r\nfor (;;) {\r\nblock1 = nftl->ReplUnitTable[block];\r\nprintk("Formatting block %d\n", block);\r\nif (NFTL_formatblock(nftl, block) < 0) {\r\nnftl->ReplUnitTable[block] = BLOCK_RESERVED;\r\n} else {\r\nnftl->ReplUnitTable[block] = BLOCK_FREE;\r\n}\r\nblock = block1;\r\nif (!(block == BLOCK_NIL || block < nftl->nb_blocks))\r\nprintk("incorrect ReplUnitTable[] : %d\n", block);\r\nif (block == BLOCK_NIL || block >= nftl->nb_blocks)\r\nbreak;\r\n}\r\n}\r\nstatic int check_and_mark_free_block(struct NFTLrecord *nftl, int block)\r\n{\r\nstruct mtd_info *mtd = nftl->mbd.mtd;\r\nstruct nftl_uci1 h1;\r\nunsigned int erase_mark;\r\nsize_t retlen;\r\nif (nftl_read_oob(mtd, block * nftl->EraseSize + SECTORSIZE + 8, 8,\r\n&retlen, (char *)&h1) < 0)\r\nreturn -1;\r\nerase_mark = le16_to_cpu ((h1.EraseMark | h1.EraseMark1));\r\nif (erase_mark != ERASE_MARK) {\r\nif (check_free_sectors (nftl, block * nftl->EraseSize, nftl->EraseSize, 1) != 0)\r\nreturn -1;\r\nh1.EraseMark = cpu_to_le16(ERASE_MARK);\r\nh1.EraseMark1 = cpu_to_le16(ERASE_MARK);\r\nh1.WearInfo = cpu_to_le32(0);\r\nif (nftl_write_oob(mtd,\r\nblock * nftl->EraseSize + SECTORSIZE + 8, 8,\r\n&retlen, (char *)&h1) < 0)\r\nreturn -1;\r\n} else {\r\n#if 0\r\nfor (i = 0; i < nftl->EraseSize; i += SECTORSIZE) {\r\nif (check_free_sectors (nftl, block * nftl->EraseSize + i,\r\nSECTORSIZE, 0) != 0)\r\nreturn -1;\r\nif (nftl_read_oob(mtd, block * nftl->EraseSize + i,\r\n16, &retlen, buf) < 0)\r\nreturn -1;\r\nif (i == SECTORSIZE) {\r\nif (memcmpb(buf, 0xff, 8))\r\nreturn -1;\r\n} else {\r\nif (memcmpb(buf, 0xff, 16))\r\nreturn -1;\r\n}\r\n}\r\n#endif\r\n}\r\nreturn 0;\r\n}\r\nstatic int get_fold_mark(struct NFTLrecord *nftl, unsigned int block)\r\n{\r\nstruct mtd_info *mtd = nftl->mbd.mtd;\r\nstruct nftl_uci2 uci;\r\nsize_t retlen;\r\nif (nftl_read_oob(mtd, block * nftl->EraseSize + 2 * SECTORSIZE + 8,\r\n8, &retlen, (char *)&uci) < 0)\r\nreturn 0;\r\nreturn le16_to_cpu((uci.FoldMark | uci.FoldMark1));\r\n}\r\nint NFTL_mount(struct NFTLrecord *s)\r\n{\r\nint i;\r\nunsigned int first_logical_block, logical_block, rep_block, nb_erases, erase_mark;\r\nunsigned int block, first_block, is_first_block;\r\nint chain_length, do_format_chain;\r\nstruct nftl_uci0 h0;\r\nstruct nftl_uci1 h1;\r\nstruct mtd_info *mtd = s->mbd.mtd;\r\nsize_t retlen;\r\nif (find_boot_record(s) < 0) {\r\nprintk("Could not find valid boot record\n");\r\nreturn -1;\r\n}\r\nfor (i = 0; i < s->nb_blocks; i++) {\r\ns->EUNtable[i] = BLOCK_NIL;\r\n}\r\nfirst_logical_block = 0;\r\nfor (first_block = 0; first_block < s->nb_blocks; first_block++) {\r\nif (s->ReplUnitTable[first_block] == BLOCK_NOTEXPLORED) {\r\nblock = first_block;\r\nchain_length = 0;\r\ndo_format_chain = 0;\r\nfor (;;) {\r\nif (nftl_read_oob(mtd,\r\nblock * s->EraseSize + 8, 8,\r\n&retlen, (char *)&h0) < 0 ||\r\nnftl_read_oob(mtd,\r\nblock * s->EraseSize +\r\nSECTORSIZE + 8, 8,\r\n&retlen, (char *)&h1) < 0) {\r\ns->ReplUnitTable[block] = BLOCK_NIL;\r\ndo_format_chain = 1;\r\nbreak;\r\n}\r\nlogical_block = le16_to_cpu ((h0.VirtUnitNum | h0.SpareVirtUnitNum));\r\nrep_block = le16_to_cpu ((h0.ReplUnitNum | h0.SpareReplUnitNum));\r\nnb_erases = le32_to_cpu (h1.WearInfo);\r\nerase_mark = le16_to_cpu ((h1.EraseMark | h1.EraseMark1));\r\nis_first_block = !(logical_block >> 15);\r\nlogical_block = logical_block & 0x7fff;\r\nif (erase_mark != ERASE_MARK || logical_block >= s->nb_blocks) {\r\nif (chain_length == 0) {\r\nif (check_and_mark_free_block(s, block) < 0) {\r\nprintk("Formatting block %d\n", block);\r\nif (NFTL_formatblock(s, block) < 0) {\r\ns->ReplUnitTable[block] = BLOCK_RESERVED;\r\n} else {\r\ns->ReplUnitTable[block] = BLOCK_FREE;\r\n}\r\n} else {\r\ns->ReplUnitTable[block] = BLOCK_FREE;\r\n}\r\ngoto examine_ReplUnitTable;\r\n} else {\r\nprintk("Block %d: free but referenced in chain %d\n",\r\nblock, first_block);\r\ns->ReplUnitTable[block] = BLOCK_NIL;\r\ndo_format_chain = 1;\r\nbreak;\r\n}\r\n}\r\nif (chain_length == 0) {\r\nif (!is_first_block)\r\ngoto examine_ReplUnitTable;\r\nfirst_logical_block = logical_block;\r\n} else {\r\nif (logical_block != first_logical_block) {\r\nprintk("Block %d: incorrect logical block: %d expected: %d\n",\r\nblock, logical_block, first_logical_block);\r\ndo_format_chain = 1;\r\n}\r\nif (is_first_block) {\r\nif (get_fold_mark(s, block) != FOLD_MARK_IN_PROGRESS ||\r\nrep_block != 0xffff) {\r\nprintk("Block %d: incorrectly marked as first block in chain\n",\r\nblock);\r\ndo_format_chain = 1;\r\n} else {\r\nprintk("Block %d: folding in progress - ignoring first block flag\n",\r\nblock);\r\n}\r\n}\r\n}\r\nchain_length++;\r\nif (rep_block == 0xffff) {\r\ns->ReplUnitTable[block] = BLOCK_NIL;\r\nbreak;\r\n} else if (rep_block >= s->nb_blocks) {\r\nprintk("Block %d: referencing invalid block %d\n",\r\nblock, rep_block);\r\ndo_format_chain = 1;\r\ns->ReplUnitTable[block] = BLOCK_NIL;\r\nbreak;\r\n} else if (s->ReplUnitTable[rep_block] != BLOCK_NOTEXPLORED) {\r\nif (s->ReplUnitTable[rep_block] == BLOCK_NIL &&\r\ns->EUNtable[first_logical_block] == rep_block &&\r\nget_fold_mark(s, first_block) == FOLD_MARK_IN_PROGRESS) {\r\nprintk("Block %d: folding in progress - ignoring first block flag\n",\r\nrep_block);\r\ns->ReplUnitTable[block] = rep_block;\r\ns->EUNtable[first_logical_block] = BLOCK_NIL;\r\n} else {\r\nprintk("Block %d: referencing block %d already in another chain\n",\r\nblock, rep_block);\r\ndo_format_chain = 1;\r\ns->ReplUnitTable[block] = BLOCK_NIL;\r\n}\r\nbreak;\r\n} else {\r\ns->ReplUnitTable[block] = rep_block;\r\nblock = rep_block;\r\n}\r\n}\r\nif (do_format_chain) {\r\nformat_chain(s, first_block);\r\n} else {\r\nunsigned int first_block1, chain_to_format, chain_length1;\r\nint fold_mark;\r\nfold_mark = get_fold_mark(s, first_block);\r\nif (fold_mark == 0) {\r\nprintk("Could read foldmark at block %d\n", first_block);\r\nformat_chain(s, first_block);\r\n} else {\r\nif (fold_mark == FOLD_MARK_IN_PROGRESS)\r\ncheck_sectors_in_chain(s, first_block);\r\nfirst_block1 = s->EUNtable[first_logical_block];\r\nif (first_block1 != BLOCK_NIL) {\r\nchain_length1 = calc_chain_length(s, first_block1);\r\nprintk("Two chains at blocks %d (len=%d) and %d (len=%d)\n",\r\nfirst_block1, chain_length1, first_block, chain_length);\r\nif (chain_length >= chain_length1) {\r\nchain_to_format = first_block1;\r\ns->EUNtable[first_logical_block] = first_block;\r\n} else {\r\nchain_to_format = first_block;\r\n}\r\nformat_chain(s, chain_to_format);\r\n} else {\r\ns->EUNtable[first_logical_block] = first_block;\r\n}\r\n}\r\n}\r\n}\r\nexamine_ReplUnitTable:;\r\n}\r\ns->numfreeEUNs = 0;\r\ns->LastFreeEUN = le16_to_cpu(s->MediaHdr.FirstPhysicalEUN);\r\nfor (block = 0; block < s->nb_blocks; block++) {\r\nif (s->ReplUnitTable[block] == BLOCK_NOTEXPLORED) {\r\nprintk("Unreferenced block %d, formatting it\n", block);\r\nif (NFTL_formatblock(s, block) < 0)\r\ns->ReplUnitTable[block] = BLOCK_RESERVED;\r\nelse\r\ns->ReplUnitTable[block] = BLOCK_FREE;\r\n}\r\nif (s->ReplUnitTable[block] == BLOCK_FREE) {\r\ns->numfreeEUNs++;\r\ns->LastFreeEUN = block;\r\n}\r\n}\r\nreturn 0;\r\n}
