static int Ti3026_calcclock(const struct matrox_fb_info *minfo,\r\nunsigned int freq, unsigned int fmax, int *in,\r\nint *feed, int *post)\r\n{\r\nunsigned int fvco;\r\nunsigned int lin, lfeed, lpost;\r\nDBG(__func__)\r\nfvco = PLL_calcclock(minfo, freq, fmax, &lin, &lfeed, &lpost);\r\nfvco >>= (*post = lpost);\r\n*in = 64 - lin;\r\n*feed = 64 - lfeed;\r\nreturn fvco;\r\n}\r\nstatic int Ti3026_setpclk(struct matrox_fb_info *minfo, int clk)\r\n{\r\nunsigned int f_pll;\r\nunsigned int pixfeed, pixin, pixpost;\r\nstruct matrox_hw_state *hw = &minfo->hw;\r\nDBG(__func__)\r\nf_pll = Ti3026_calcclock(minfo, clk, minfo->max_pixel_clock, &pixin, &pixfeed, &pixpost);\r\nhw->DACclk[0] = pixin | 0xC0;\r\nhw->DACclk[1] = pixfeed;\r\nhw->DACclk[2] = pixpost | 0xB0;\r\n{\r\nunsigned int loopfeed, loopin, looppost, loopdiv, z;\r\nunsigned int Bpp;\r\nBpp = minfo->curr.final_bppShift;\r\nif (minfo->fbcon.var.bits_per_pixel == 24) {\r\nloopfeed = 3;\r\nloopin = 3 * 32 / Bpp;\r\n} else {\r\nloopfeed = 4;\r\nloopin = 4 * 32 / Bpp;\r\n}\r\nz = (110000 * loopin) / (f_pll * loopfeed);\r\nloopdiv = 0;\r\nif (z < 2)\r\nlooppost = 0;\r\nelse if (z < 4)\r\nlooppost = 1;\r\nelse if (z < 8)\r\nlooppost = 2;\r\nelse {\r\nlooppost = 3;\r\nloopdiv = z/16;\r\n}\r\nif (minfo->fbcon.var.bits_per_pixel == 24) {\r\nhw->DACclk[3] = ((65 - loopin) & 0x3F) | 0xC0;\r\nhw->DACclk[4] = (65 - loopfeed) | 0x80;\r\nif (minfo->accel.ramdac_rev > 0x20) {\r\nif (isInterleave(minfo))\r\nhw->DACreg[POS3026_XLATCHCTRL] = TVP3026B_XLATCHCTRL_8_3;\r\nelse {\r\nhw->DACclk[4] &= ~0xC0;\r\nhw->DACreg[POS3026_XLATCHCTRL] = TVP3026B_XLATCHCTRL_4_3;\r\n}\r\n} else {\r\nif (isInterleave(minfo))\r\n;\r\nelse {\r\nhw->DACclk[4] ^= 0xC0;\r\nhw->DACreg[POS3026_XLATCHCTRL] = TVP3026A_XLATCHCTRL_4_3;\r\n}\r\n}\r\nhw->DACclk[5] = looppost | 0xF8;\r\nif (minfo->devflags.mga_24bpp_fix)\r\nhw->DACclk[5] ^= 0x40;\r\n} else {\r\nhw->DACclk[3] = ((65 - loopin) & 0x3F) | 0xC0;\r\nhw->DACclk[4] = 65 - loopfeed;\r\nhw->DACclk[5] = looppost | 0xF0;\r\n}\r\nhw->DACreg[POS3026_XMEMPLLCTRL] = loopdiv | TVP3026_XMEMPLLCTRL_MCLK_MCLKPLL | TVP3026_XMEMPLLCTRL_RCLK_LOOPPLL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int Ti3026_init(struct matrox_fb_info *minfo, struct my_timming *m)\r\n{\r\nu_int8_t muxctrl = isInterleave(minfo) ? TVP3026_XMUXCTRL_MEMORY_64BIT : TVP3026_XMUXCTRL_MEMORY_32BIT;\r\nstruct matrox_hw_state *hw = &minfo->hw;\r\nDBG(__func__)\r\nmemcpy(hw->DACreg, MGADACbpp32, sizeof(hw->DACreg));\r\nswitch (minfo->fbcon.var.bits_per_pixel) {\r\ncase 4: hw->DACreg[POS3026_XLATCHCTRL] = TVP3026_XLATCHCTRL_16_1;\r\nhw->DACreg[POS3026_XTRUECOLORCTRL] = TVP3026_XTRUECOLORCTRL_PSEUDOCOLOR;\r\nhw->DACreg[POS3026_XMUXCTRL] = muxctrl | TVP3026_XMUXCTRL_PIXEL_4BIT;\r\nhw->DACreg[POS3026_XCLKCTRL] = TVP3026_XCLKCTRL_SRC_PLL | TVP3026_XCLKCTRL_DIV8;\r\nhw->DACreg[POS3026_XMISCCTRL] = TVP3026_XMISCCTRL_DAC_PUP | TVP3026_XMISCCTRL_DAC_8BIT | TVP3026_XMISCCTRL_PSEL_DIS | TVP3026_XMISCCTRL_PSEL_LOW;\r\nbreak;\r\ncase 8: hw->DACreg[POS3026_XLATCHCTRL] = TVP3026_XLATCHCTRL_8_1;\r\nhw->DACreg[POS3026_XTRUECOLORCTRL] = TVP3026_XTRUECOLORCTRL_PSEUDOCOLOR;\r\nhw->DACreg[POS3026_XMUXCTRL] = muxctrl | TVP3026_XMUXCTRL_PIXEL_8BIT;\r\nhw->DACreg[POS3026_XCLKCTRL] = TVP3026_XCLKCTRL_SRC_PLL | TVP3026_XCLKCTRL_DIV4;\r\nhw->DACreg[POS3026_XMISCCTRL] = TVP3026_XMISCCTRL_DAC_PUP | TVP3026_XMISCCTRL_DAC_8BIT | TVP3026_XMISCCTRL_PSEL_DIS | TVP3026_XMISCCTRL_PSEL_LOW;\r\nbreak;\r\ncase 16:\r\nhw->DACreg[POS3026_XTRUECOLORCTRL] = (minfo->fbcon.var.green.length == 5) ? (TVP3026_XTRUECOLORCTRL_DIRECTCOLOR | TVP3026_XTRUECOLORCTRL_ORGB_1555) : (TVP3026_XTRUECOLORCTRL_DIRECTCOLOR | TVP3026_XTRUECOLORCTRL_RGB_565);\r\nhw->DACreg[POS3026_XMUXCTRL] = muxctrl | TVP3026_XMUXCTRL_PIXEL_16BIT;\r\nhw->DACreg[POS3026_XCLKCTRL] = TVP3026_XCLKCTRL_SRC_PLL | TVP3026_XCLKCTRL_DIV2;\r\nbreak;\r\ncase 24:\r\nhw->DACreg[POS3026_XTRUECOLORCTRL] = TVP3026_XTRUECOLORCTRL_DIRECTCOLOR | TVP3026_XTRUECOLORCTRL_RGB_888;\r\nhw->DACreg[POS3026_XMUXCTRL] = muxctrl | TVP3026_XMUXCTRL_PIXEL_32BIT;\r\nhw->DACreg[POS3026_XCLKCTRL] = TVP3026_XCLKCTRL_SRC_PLL | TVP3026_XCLKCTRL_DIV4;\r\nbreak;\r\ncase 32:\r\nhw->DACreg[POS3026_XMUXCTRL] = muxctrl | TVP3026_XMUXCTRL_PIXEL_32BIT;\r\nbreak;\r\ndefault:\r\nreturn 1;\r\n}\r\nif (matroxfb_vgaHWinit(minfo, m)) return 1;\r\nhw->MiscOutReg = 0xCB;\r\nif (m->sync & FB_SYNC_HOR_HIGH_ACT)\r\nhw->DACreg[POS3026_XGENCTRL] |= TVP3026_XGENCTRL_HSYNC_NEG;\r\nif (m->sync & FB_SYNC_VERT_HIGH_ACT)\r\nhw->DACreg[POS3026_XGENCTRL] |= TVP3026_XGENCTRL_VSYNC_NEG;\r\nif (m->sync & FB_SYNC_ON_GREEN)\r\nhw->DACreg[POS3026_XGENCTRL] |= TVP3026_XGENCTRL_SYNC_ON_GREEN;\r\nif (minfo->video.len < 0x400000)\r\nhw->CRTCEXT[3] |= 0x08;\r\nelse if (minfo->video.len > 0x400000)\r\nhw->CRTCEXT[3] |= 0x10;\r\nif (m->interlaced) {\r\nhw->DACreg[POS3026_XCURCTRL] |= TVP3026_XCURCTRL_INTERLACED;\r\n}\r\nif (m->HTotal >= 1536)\r\nhw->DACreg[POS3026_XCURCTRL] |= TVP3026_XCURCTRL_BLANK4096;\r\nhw->MXoptionReg &= ~0x00001000;\r\nif (isInterleave(minfo)) hw->MXoptionReg |= 0x00001000;\r\nTi3026_setpclk(minfo, m->pixclock);\r\nreturn 0;\r\n}\r\nstatic void ti3026_setMCLK(struct matrox_fb_info *minfo, int fout)\r\n{\r\nunsigned int f_pll;\r\nunsigned int pclk_m, pclk_n, pclk_p;\r\nunsigned int mclk_m, mclk_n, mclk_p;\r\nunsigned int rfhcnt, mclk_ctl;\r\nint tmout;\r\nDBG(__func__)\r\nf_pll = Ti3026_calcclock(minfo, fout, minfo->max_pixel_clock, &mclk_n, &mclk_m, &mclk_p);\r\noutTi3026(minfo, TVP3026_XPLLADDR, 0xFC);\r\npclk_n = inTi3026(minfo, TVP3026_XPIXPLLDATA);\r\noutTi3026(minfo, TVP3026_XPLLADDR, 0xFD);\r\npclk_m = inTi3026(minfo, TVP3026_XPIXPLLDATA);\r\noutTi3026(minfo, TVP3026_XPLLADDR, 0xFE);\r\npclk_p = inTi3026(minfo, TVP3026_XPIXPLLDATA);\r\noutTi3026(minfo, TVP3026_XPLLADDR, 0xFE);\r\noutTi3026(minfo, TVP3026_XPIXPLLDATA, 0x00);\r\noutTi3026(minfo, TVP3026_XPLLADDR, 0xFC);\r\noutTi3026(minfo, TVP3026_XPIXPLLDATA, mclk_n | 0xC0);\r\noutTi3026(minfo, TVP3026_XPIXPLLDATA, mclk_m);\r\noutTi3026(minfo, TVP3026_XPIXPLLDATA, mclk_p | 0xB0);\r\nfor (tmout = 500000; tmout; tmout--) {\r\nif (inTi3026(minfo, TVP3026_XPIXPLLDATA) & 0x40)\r\nbreak;\r\nudelay(10);\r\n}\r\nif (!tmout)\r\nprintk(KERN_ERR "matroxfb: Temporary pixel PLL not locked after 5 secs\n");\r\nmclk_ctl = inTi3026(minfo, TVP3026_XMEMPLLCTRL);\r\noutTi3026(minfo, TVP3026_XMEMPLLCTRL, mclk_ctl & 0xE7);\r\noutTi3026(minfo, TVP3026_XMEMPLLCTRL, (mclk_ctl & 0xE7) | TVP3026_XMEMPLLCTRL_STROBEMKC4);\r\noutTi3026(minfo, TVP3026_XPLLADDR, 0xFB);\r\noutTi3026(minfo, TVP3026_XMEMPLLDATA, 0x00);\r\noutTi3026(minfo, TVP3026_XPLLADDR, 0xF3);\r\noutTi3026(minfo, TVP3026_XMEMPLLDATA, mclk_n | 0xC0);\r\noutTi3026(minfo, TVP3026_XMEMPLLDATA, mclk_m);\r\noutTi3026(minfo, TVP3026_XMEMPLLDATA, mclk_p | 0xB0);\r\nfor (tmout = 500000; tmout; tmout--) {\r\nif (inTi3026(minfo, TVP3026_XMEMPLLDATA) & 0x40)\r\nbreak;\r\nudelay(10);\r\n}\r\nif (!tmout)\r\nprintk(KERN_ERR "matroxfb: Memory PLL not locked after 5 secs\n");\r\nf_pll = f_pll * 333 / (10000 << mclk_p);\r\nif (isMilleniumII(minfo)) {\r\nrfhcnt = (f_pll - 128) / 256;\r\nif (rfhcnt > 15)\r\nrfhcnt = 15;\r\n} else {\r\nrfhcnt = (f_pll - 64) / 128;\r\nif (rfhcnt > 15)\r\nrfhcnt = 0;\r\n}\r\nminfo->hw.MXoptionReg = (minfo->hw.MXoptionReg & ~0x000F0000) | (rfhcnt << 16);\r\npci_write_config_dword(minfo->pcidev, PCI_OPTION_REG, minfo->hw.MXoptionReg);\r\noutTi3026(minfo, TVP3026_XMEMPLLCTRL, (mclk_ctl & 0xE7) | TVP3026_XMEMPLLCTRL_MCLK_MCLKPLL);\r\noutTi3026(minfo, TVP3026_XMEMPLLCTRL, (mclk_ctl ) | TVP3026_XMEMPLLCTRL_MCLK_MCLKPLL | TVP3026_XMEMPLLCTRL_STROBEMKC4);\r\noutTi3026(minfo, TVP3026_XPLLADDR, 0xFE);\r\noutTi3026(minfo, TVP3026_XPIXPLLDATA, 0x00);\r\noutTi3026(minfo, TVP3026_XPLLADDR, 0xFC);\r\noutTi3026(minfo, TVP3026_XPIXPLLDATA, pclk_n);\r\noutTi3026(minfo, TVP3026_XPIXPLLDATA, pclk_m);\r\noutTi3026(minfo, TVP3026_XPIXPLLDATA, pclk_p);\r\nfor (tmout = 500000; tmout; tmout--) {\r\nif (inTi3026(minfo, TVP3026_XPIXPLLDATA) & 0x40)\r\nbreak;\r\nudelay(10);\r\n}\r\nif (!tmout)\r\nprintk(KERN_ERR "matroxfb: Pixel PLL not locked after 5 secs\n");\r\n}\r\nstatic void ti3026_ramdac_init(struct matrox_fb_info *minfo)\r\n{\r\nDBG(__func__)\r\nminfo->features.pll.vco_freq_min = 110000;\r\nminfo->features.pll.ref_freq = 114545;\r\nminfo->features.pll.feed_div_min = 2;\r\nminfo->features.pll.feed_div_max = 24;\r\nminfo->features.pll.in_div_min = 2;\r\nminfo->features.pll.in_div_max = 63;\r\nminfo->features.pll.post_shift_max = 3;\r\nif (minfo->devflags.noinit)\r\nreturn;\r\nti3026_setMCLK(minfo, 60000);\r\n}\r\nstatic void Ti3026_restore(struct matrox_fb_info *minfo)\r\n{\r\nint i;\r\nunsigned char progdac[6];\r\nstruct matrox_hw_state *hw = &minfo->hw;\r\nCRITFLAGS\r\nDBG(__func__)\r\n#ifdef DEBUG\r\ndprintk(KERN_INFO "EXTVGA regs: ");\r\nfor (i = 0; i < 6; i++)\r\ndprintk("%02X:", hw->CRTCEXT[i]);\r\ndprintk("\n");\r\n#endif\r\nCRITBEGIN\r\npci_write_config_dword(minfo->pcidev, PCI_OPTION_REG, hw->MXoptionReg);\r\nCRITEND\r\nmatroxfb_vgaHWrestore(minfo);\r\nCRITBEGIN\r\nminfo->crtc1.panpos = -1;\r\nfor (i = 0; i < 6; i++)\r\nmga_setr(M_EXTVGA_INDEX, i, hw->CRTCEXT[i]);\r\nfor (i = 0; i < 21; i++) {\r\noutTi3026(minfo, DACseq[i], hw->DACreg[i]);\r\n}\r\noutTi3026(minfo, TVP3026_XPLLADDR, 0x00);\r\nprogdac[0] = inTi3026(minfo, TVP3026_XPIXPLLDATA);\r\nprogdac[3] = inTi3026(minfo, TVP3026_XLOOPPLLDATA);\r\noutTi3026(minfo, TVP3026_XPLLADDR, 0x15);\r\nprogdac[1] = inTi3026(minfo, TVP3026_XPIXPLLDATA);\r\nprogdac[4] = inTi3026(minfo, TVP3026_XLOOPPLLDATA);\r\noutTi3026(minfo, TVP3026_XPLLADDR, 0x2A);\r\nprogdac[2] = inTi3026(minfo, TVP3026_XPIXPLLDATA);\r\nprogdac[5] = inTi3026(minfo, TVP3026_XLOOPPLLDATA);\r\nCRITEND\r\nif (memcmp(hw->DACclk, progdac, 6)) {\r\nCRITBEGIN\r\noutTi3026(minfo, TVP3026_XCLKCTRL, hw->DACreg[POS3026_XCLKCTRL]);\r\noutTi3026(minfo, TVP3026_XPLLADDR, 0x2A);\r\noutTi3026(minfo, TVP3026_XLOOPPLLDATA, 0);\r\noutTi3026(minfo, TVP3026_XPIXPLLDATA, 0);\r\noutTi3026(minfo, TVP3026_XPLLADDR, 0x00);\r\nfor (i = 0; i < 3; i++)\r\noutTi3026(minfo, TVP3026_XPIXPLLDATA, hw->DACclk[i]);\r\nif (hw->MiscOutReg & 0x08) {\r\nint tmout;\r\noutTi3026(minfo, TVP3026_XPLLADDR, 0x3F);\r\nfor (tmout = 500000; tmout; --tmout) {\r\nif (inTi3026(minfo, TVP3026_XPIXPLLDATA) & 0x40)\r\nbreak;\r\nudelay(10);\r\n}\r\nCRITEND\r\nif (!tmout)\r\nprintk(KERN_ERR "matroxfb: Pixel PLL not locked after 5 secs\n");\r\nelse\r\ndprintk(KERN_INFO "PixelPLL: %d\n", 500000-tmout);\r\nCRITBEGIN\r\n}\r\noutTi3026(minfo, TVP3026_XMEMPLLCTRL, hw->DACreg[POS3026_XMEMPLLCTRL]);\r\noutTi3026(minfo, TVP3026_XPLLADDR, 0x00);\r\nfor (i = 3; i < 6; i++)\r\noutTi3026(minfo, TVP3026_XLOOPPLLDATA, hw->DACclk[i]);\r\nCRITEND\r\nif ((hw->MiscOutReg & 0x08) && ((hw->DACclk[5] & 0x80) == 0x80)) {\r\nint tmout;\r\nCRITBEGIN\r\noutTi3026(minfo, TVP3026_XPLLADDR, 0x3F);\r\nfor (tmout = 500000; tmout; --tmout) {\r\nif (inTi3026(minfo, TVP3026_XLOOPPLLDATA) & 0x40)\r\nbreak;\r\nudelay(10);\r\n}\r\nCRITEND\r\nif (!tmout)\r\nprintk(KERN_ERR "matroxfb: Loop PLL not locked after 5 secs\n");\r\nelse\r\ndprintk(KERN_INFO "LoopPLL: %d\n", 500000-tmout);\r\n}\r\n}\r\n#ifdef DEBUG\r\ndprintk(KERN_DEBUG "3026DACregs ");\r\nfor (i = 0; i < 21; i++) {\r\ndprintk("R%02X=%02X ", DACseq[i], hw->DACreg[i]);\r\nif ((i & 0x7) == 0x7) dprintk(KERN_DEBUG "continuing... ");\r\n}\r\ndprintk(KERN_DEBUG "DACclk ");\r\nfor (i = 0; i < 6; i++)\r\ndprintk("C%02X=%02X ", i, hw->DACclk[i]);\r\ndprintk("\n");\r\n#endif\r\n}\r\nstatic void Ti3026_reset(struct matrox_fb_info *minfo)\r\n{\r\nDBG(__func__)\r\nti3026_ramdac_init(minfo);\r\n}\r\nstatic int Ti3026_preinit(struct matrox_fb_info *minfo)\r\n{\r\nstatic const int vxres_mill2[] = { 512, 640, 768, 800, 832, 960,\r\n1024, 1152, 1280, 1600, 1664, 1920,\r\n2048, 0};\r\nstatic const int vxres_mill1[] = { 640, 768, 800, 960,\r\n1024, 1152, 1280, 1600, 1920,\r\n2048, 0};\r\nstruct matrox_hw_state *hw = &minfo->hw;\r\nDBG(__func__)\r\nminfo->millenium = 1;\r\nminfo->milleniumII = (minfo->pcidev->device != PCI_DEVICE_ID_MATROX_MIL);\r\nminfo->capable.cfb4 = 1;\r\nminfo->capable.text = 1;\r\nminfo->capable.vxres = isMilleniumII(minfo) ? vxres_mill2 : vxres_mill1;\r\nminfo->outputs[0].data = minfo;\r\nminfo->outputs[0].output = &ti3026_output;\r\nminfo->outputs[0].src = minfo->outputs[0].default_src;\r\nminfo->outputs[0].mode = MATROXFB_OUTPUT_MODE_MONITOR;\r\nif (minfo->devflags.noinit)\r\nreturn 0;\r\nhw->MXoptionReg &= 0xC0000100;\r\nhw->MXoptionReg |= 0x002C0000;\r\nif (minfo->devflags.novga)\r\nhw->MXoptionReg &= ~0x00000100;\r\nif (minfo->devflags.nobios)\r\nhw->MXoptionReg &= ~0x40000000;\r\nif (minfo->devflags.nopciretry)\r\nhw->MXoptionReg |= 0x20000000;\r\npci_write_config_dword(minfo->pcidev, PCI_OPTION_REG, hw->MXoptionReg);\r\nminfo->accel.ramdac_rev = inTi3026(minfo, TVP3026_XSILICONREV);\r\noutTi3026(minfo, TVP3026_XCLKCTRL, TVP3026_XCLKCTRL_SRC_CLK0VGA | TVP3026_XCLKCTRL_CLKSTOPPED);\r\noutTi3026(minfo, TVP3026_XTRUECOLORCTRL, TVP3026_XTRUECOLORCTRL_PSEUDOCOLOR);\r\noutTi3026(minfo, TVP3026_XMUXCTRL, TVP3026_XMUXCTRL_VGA);\r\noutTi3026(minfo, TVP3026_XPLLADDR, 0x2A);\r\noutTi3026(minfo, TVP3026_XLOOPPLLDATA, 0x00);\r\noutTi3026(minfo, TVP3026_XPIXPLLDATA, 0x00);\r\nmga_outb(M_MISC_REG, 0x67);\r\noutTi3026(minfo, TVP3026_XMEMPLLCTRL, TVP3026_XMEMPLLCTRL_STROBEMKC4 | TVP3026_XMEMPLLCTRL_MCLK_MCLKPLL);\r\nmga_outl(M_RESET, 1);\r\nudelay(250);\r\nmga_outl(M_RESET, 0);\r\nudelay(250);\r\nmga_outl(M_MACCESS, 0x00008000);\r\nudelay(10);\r\nreturn 0;\r\n}
