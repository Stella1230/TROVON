static void etm_event_read(struct perf_event *event) {}\r\nstatic int etm_event_init(struct perf_event *event)\r\n{\r\nif (event->attr.type != etm_pmu.type)\r\nreturn -ENOENT;\r\nreturn 0;\r\n}\r\nstatic void free_event_data(struct work_struct *work)\r\n{\r\nint cpu;\r\ncpumask_t *mask;\r\nstruct etm_event_data *event_data;\r\nstruct coresight_device *sink;\r\nevent_data = container_of(work, struct etm_event_data, work);\r\nmask = &event_data->mask;\r\nif (event_data->snk_config) {\r\ncpu = cpumask_first(mask);\r\nsink = coresight_get_sink(event_data->path[cpu]);\r\nif (sink_ops(sink)->free_buffer)\r\nsink_ops(sink)->free_buffer(event_data->snk_config);\r\n}\r\nfor_each_cpu(cpu, mask) {\r\nif (event_data->path[cpu])\r\ncoresight_release_path(event_data->path[cpu]);\r\n}\r\nkfree(event_data->path);\r\nkfree(event_data);\r\n}\r\nstatic void *alloc_event_data(int cpu)\r\n{\r\nint size;\r\ncpumask_t *mask;\r\nstruct etm_event_data *event_data;\r\nevent_data = kzalloc(sizeof(struct etm_event_data), GFP_KERNEL);\r\nif (!event_data)\r\nreturn NULL;\r\nget_online_cpus();\r\nsize = num_online_cpus();\r\nmask = &event_data->mask;\r\nif (cpu != -1)\r\ncpumask_set_cpu(cpu, mask);\r\nelse\r\ncpumask_copy(mask, cpu_online_mask);\r\nput_online_cpus();\r\nevent_data->path = kcalloc(size,\r\nsizeof(struct list_head *), GFP_KERNEL);\r\nif (!event_data->path) {\r\nkfree(event_data);\r\nreturn NULL;\r\n}\r\nreturn event_data;\r\n}\r\nstatic void etm_free_aux(void *data)\r\n{\r\nstruct etm_event_data *event_data = data;\r\nschedule_work(&event_data->work);\r\n}\r\nstatic void *etm_setup_aux(int event_cpu, void **pages,\r\nint nr_pages, bool overwrite)\r\n{\r\nint cpu;\r\ncpumask_t *mask;\r\nstruct coresight_device *sink;\r\nstruct etm_event_data *event_data = NULL;\r\nevent_data = alloc_event_data(event_cpu);\r\nif (!event_data)\r\nreturn NULL;\r\nINIT_WORK(&event_data->work, free_event_data);\r\nmask = &event_data->mask;\r\nfor_each_cpu(cpu, mask) {\r\nstruct coresight_device *csdev;\r\ncsdev = per_cpu(csdev_src, cpu);\r\nif (!csdev)\r\ngoto err;\r\nevent_data->path[cpu] = coresight_build_path(csdev);\r\nif (!event_data->path[cpu])\r\ngoto err;\r\n}\r\ncpu = cpumask_first(mask);\r\nsink = coresight_get_sink(event_data->path[cpu]);\r\nif (!sink)\r\ngoto err;\r\nif (!sink_ops(sink)->alloc_buffer)\r\ngoto err;\r\nevent_data->snk_config =\r\nsink_ops(sink)->alloc_buffer(sink, cpu, pages,\r\nnr_pages, overwrite);\r\nif (!event_data->snk_config)\r\ngoto err;\r\nout:\r\nreturn event_data;\r\nerr:\r\netm_free_aux(event_data);\r\nevent_data = NULL;\r\ngoto out;\r\n}\r\nstatic void etm_event_start(struct perf_event *event, int flags)\r\n{\r\nint cpu = smp_processor_id();\r\nstruct etm_event_data *event_data;\r\nstruct perf_output_handle *handle = this_cpu_ptr(&ctx_handle);\r\nstruct coresight_device *sink, *csdev = per_cpu(csdev_src, cpu);\r\nif (!csdev)\r\ngoto fail;\r\nevent_data = perf_aux_output_begin(handle, event);\r\nif (!event_data)\r\ngoto fail;\r\nsink = coresight_get_sink(event_data->path[cpu]);\r\nif (WARN_ON_ONCE(!sink || !sink_ops(sink)->set_buffer))\r\ngoto fail_end_stop;\r\nif (sink_ops(sink)->set_buffer(sink, handle,\r\nevent_data->snk_config))\r\ngoto fail_end_stop;\r\nif (coresight_enable_path(event_data->path[cpu], CS_MODE_PERF))\r\ngoto fail_end_stop;\r\nevent->hw.state = 0;\r\nif (source_ops(csdev)->enable(csdev, &event->attr, CS_MODE_PERF))\r\ngoto fail_end_stop;\r\nout:\r\nreturn;\r\nfail_end_stop:\r\nperf_aux_output_end(handle, 0, true);\r\nfail:\r\nevent->hw.state = PERF_HES_STOPPED;\r\ngoto out;\r\n}\r\nstatic void etm_event_stop(struct perf_event *event, int mode)\r\n{\r\nbool lost;\r\nint cpu = smp_processor_id();\r\nunsigned long size;\r\nstruct coresight_device *sink, *csdev = per_cpu(csdev_src, cpu);\r\nstruct perf_output_handle *handle = this_cpu_ptr(&ctx_handle);\r\nstruct etm_event_data *event_data = perf_get_aux(handle);\r\nif (event->hw.state == PERF_HES_STOPPED)\r\nreturn;\r\nif (!csdev)\r\nreturn;\r\nsink = coresight_get_sink(event_data->path[cpu]);\r\nif (!sink)\r\nreturn;\r\nsource_ops(csdev)->disable(csdev);\r\nevent->hw.state = PERF_HES_STOPPED;\r\nif (mode & PERF_EF_UPDATE) {\r\nif (WARN_ON_ONCE(handle->event != event))\r\nreturn;\r\nif (!sink_ops(sink)->update_buffer)\r\nreturn;\r\nsink_ops(sink)->update_buffer(sink, handle,\r\nevent_data->snk_config);\r\nif (!sink_ops(sink)->reset_buffer)\r\nreturn;\r\nsize = sink_ops(sink)->reset_buffer(sink, handle,\r\nevent_data->snk_config,\r\n&lost);\r\nperf_aux_output_end(handle, size, lost);\r\n}\r\ncoresight_disable_path(event_data->path[cpu]);\r\n}\r\nstatic int etm_event_add(struct perf_event *event, int mode)\r\n{\r\nint ret = 0;\r\nstruct hw_perf_event *hwc = &event->hw;\r\nif (mode & PERF_EF_START) {\r\netm_event_start(event, 0);\r\nif (hwc->state & PERF_HES_STOPPED)\r\nret = -EINVAL;\r\n} else {\r\nhwc->state = PERF_HES_STOPPED;\r\n}\r\nreturn ret;\r\n}\r\nstatic void etm_event_del(struct perf_event *event, int mode)\r\n{\r\netm_event_stop(event, PERF_EF_UPDATE);\r\n}\r\nint etm_perf_symlink(struct coresight_device *csdev, bool link)\r\n{\r\nchar entry[sizeof("cpu9999999")];\r\nint ret = 0, cpu = source_ops(csdev)->cpu_id(csdev);\r\nstruct device *pmu_dev = etm_pmu.dev;\r\nstruct device *cs_dev = &csdev->dev;\r\nsprintf(entry, "cpu%d", cpu);\r\nif (!etm_perf_up)\r\nreturn -EPROBE_DEFER;\r\nif (link) {\r\nret = sysfs_create_link(&pmu_dev->kobj, &cs_dev->kobj, entry);\r\nif (ret)\r\nreturn ret;\r\nper_cpu(csdev_src, cpu) = csdev;\r\n} else {\r\nsysfs_remove_link(&pmu_dev->kobj, entry);\r\nper_cpu(csdev_src, cpu) = NULL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int __init etm_perf_init(void)\r\n{\r\nint ret;\r\netm_pmu.capabilities = PERF_PMU_CAP_EXCLUSIVE;\r\netm_pmu.attr_groups = etm_pmu_attr_groups;\r\netm_pmu.task_ctx_nr = perf_sw_context;\r\netm_pmu.read = etm_event_read;\r\netm_pmu.event_init = etm_event_init;\r\netm_pmu.setup_aux = etm_setup_aux;\r\netm_pmu.free_aux = etm_free_aux;\r\netm_pmu.start = etm_event_start;\r\netm_pmu.stop = etm_event_stop;\r\netm_pmu.add = etm_event_add;\r\netm_pmu.del = etm_event_del;\r\nret = perf_pmu_register(&etm_pmu, CORESIGHT_ETM_PMU_NAME, -1);\r\nif (ret == 0)\r\netm_perf_up = true;\r\nreturn ret;\r\n}
