static int\r\npt3_demod_write(struct pt3_adapter *adap, const struct reg_val *data, int num)\r\n{\r\nstruct i2c_msg msg;\r\nint i, ret;\r\nret = 0;\r\nmsg.addr = adap->i2c_demod->addr;\r\nmsg.flags = 0;\r\nmsg.len = 2;\r\nfor (i = 0; i < num; i++) {\r\nmsg.buf = (u8 *)&data[i];\r\nret = i2c_transfer(adap->i2c_demod->adapter, &msg, 1);\r\nif (ret == 0)\r\nret = -EREMOTE;\r\nif (ret < 0)\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic inline void pt3_lnb_ctrl(struct pt3_board *pt3, bool on)\r\n{\r\niowrite32((on ? 0x0f : 0x0c), pt3->regs[0] + REG_SYSTEM_W);\r\n}\r\nstatic inline struct pt3_adapter *pt3_find_adapter(struct dvb_frontend *fe)\r\n{\r\nstruct pt3_board *pt3;\r\nint i;\r\nif (one_adapter) {\r\npt3 = fe->dvb->priv;\r\nfor (i = 0; i < PT3_NUM_FE; i++)\r\nif (pt3->adaps[i]->fe == fe)\r\nreturn pt3->adaps[i];\r\n}\r\nreturn container_of(fe->dvb, struct pt3_adapter, dvb_adap);\r\n}\r\nstatic int\r\npt3_set_tuner_power(struct pt3_board *pt3, bool tuner_on, bool amp_on)\r\n{\r\nstruct reg_val rv = { 0x1e, 0x99 };\r\nif (tuner_on)\r\nrv.val |= 0x40;\r\nif (amp_on)\r\nrv.val |= 0x04;\r\nreturn pt3_demod_write(pt3->adaps[PT3_NUM_FE - 1], &rv, 1);\r\n}\r\nstatic int pt3_set_lna(struct dvb_frontend *fe)\r\n{\r\nstruct pt3_adapter *adap;\r\nstruct pt3_board *pt3;\r\nu32 val;\r\nint ret;\r\nadap = pt3_find_adapter(fe);\r\nval = fe->dtv_property_cache.lna;\r\nif (val == LNA_AUTO || val == adap->cur_lna)\r\nreturn 0;\r\npt3 = adap->dvb_adap.priv;\r\nif (mutex_lock_interruptible(&pt3->lock))\r\nreturn -ERESTARTSYS;\r\nif (val)\r\npt3->lna_on_cnt++;\r\nelse\r\npt3->lna_on_cnt--;\r\nif (val && pt3->lna_on_cnt <= 1) {\r\npt3->lna_on_cnt = 1;\r\nret = pt3_set_tuner_power(pt3, true, true);\r\n} else if (!val && pt3->lna_on_cnt <= 0) {\r\npt3->lna_on_cnt = 0;\r\nret = pt3_set_tuner_power(pt3, true, false);\r\n} else\r\nret = 0;\r\nmutex_unlock(&pt3->lock);\r\nadap->cur_lna = (val != 0);\r\nreturn ret;\r\n}\r\nstatic int pt3_set_voltage(struct dvb_frontend *fe, enum fe_sec_voltage volt)\r\n{\r\nstruct pt3_adapter *adap;\r\nstruct pt3_board *pt3;\r\nbool on;\r\nadap = pt3_find_adapter(fe);\r\non = (volt != SEC_VOLTAGE_OFF);\r\nif (on == adap->cur_lnb)\r\nreturn 0;\r\nadap->cur_lnb = on;\r\npt3 = adap->dvb_adap.priv;\r\nif (mutex_lock_interruptible(&pt3->lock))\r\nreturn -ERESTARTSYS;\r\nif (on)\r\npt3->lnb_on_cnt++;\r\nelse\r\npt3->lnb_on_cnt--;\r\nif (on && pt3->lnb_on_cnt <= 1) {\r\npt3->lnb_on_cnt = 1;\r\npt3_lnb_ctrl(pt3, true);\r\n} else if (!on && pt3->lnb_on_cnt <= 0) {\r\npt3->lnb_on_cnt = 0;\r\npt3_lnb_ctrl(pt3, false);\r\n}\r\nmutex_unlock(&pt3->lock);\r\nreturn 0;\r\n}\r\nstatic int pt3_fe_init(struct pt3_board *pt3)\r\n{\r\nint i, ret;\r\nstruct dvb_frontend *fe;\r\npt3_i2c_reset(pt3);\r\nret = pt3_init_all_demods(pt3);\r\nif (ret < 0) {\r\ndev_warn(&pt3->pdev->dev, "Failed to init demod chips\n");\r\nreturn ret;\r\n}\r\nfor (i = 0; i < PT3_NUM_FE; i++) {\r\nfe = pt3->adaps[i]->fe;\r\nif (fe->ops.delsys[0] == SYS_ISDBS)\r\nret = pt3_demod_write(pt3->adaps[i],\r\ninit0_sat, ARRAY_SIZE(init0_sat));\r\nelse\r\nret = pt3_demod_write(pt3->adaps[i],\r\ninit0_ter, ARRAY_SIZE(init0_ter));\r\nif (ret < 0) {\r\ndev_warn(&pt3->pdev->dev,\r\n"demod[%d] failed in init sequence0\n", i);\r\nreturn ret;\r\n}\r\nret = fe->ops.init(fe);\r\nif (ret < 0)\r\nreturn ret;\r\n}\r\nusleep_range(2000, 4000);\r\nret = pt3_set_tuner_power(pt3, true, false);\r\nif (ret < 0) {\r\ndev_warn(&pt3->pdev->dev, "Failed to control tuner module\n");\r\nreturn ret;\r\n}\r\nfor (i = 0; i < PT3_NUM_FE; i++) {\r\nfe = pt3->adaps[i]->fe;\r\nif (fe->ops.delsys[0] == SYS_ISDBS)\r\nret = pt3_demod_write(pt3->adaps[i],\r\ncfg_sat, ARRAY_SIZE(cfg_sat));\r\nelse\r\nret = pt3_demod_write(pt3->adaps[i],\r\ncfg_ter, ARRAY_SIZE(cfg_ter));\r\nif (ret < 0) {\r\ndev_warn(&pt3->pdev->dev,\r\n"demod[%d] failed in init sequence1\n", i);\r\nreturn ret;\r\n}\r\n}\r\nusleep_range(4000, 6000);\r\nfor (i = 0; i < PT3_NUM_FE; i++) {\r\nfe = pt3->adaps[i]->fe;\r\nif (fe->ops.delsys[0] != SYS_ISDBS)\r\ncontinue;\r\nret = fe->ops.tuner_ops.init(fe);\r\nif (ret < 0) {\r\ndev_warn(&pt3->pdev->dev,\r\n"Failed to init SAT-tuner[%d]\n", i);\r\nreturn ret;\r\n}\r\n}\r\nret = pt3_init_all_mxl301rf(pt3);\r\nif (ret < 0) {\r\ndev_warn(&pt3->pdev->dev, "Failed to init TERR-tuners\n");\r\nreturn ret;\r\n}\r\nret = pt3_set_tuner_power(pt3, true, true);\r\nif (ret < 0) {\r\ndev_warn(&pt3->pdev->dev, "Failed to control tuner module\n");\r\nreturn ret;\r\n}\r\nfor (i = 0; i < PT3_NUM_FE; i++) {\r\nfe = pt3->adaps[i]->fe;\r\nret = 0;\r\nif (fe->ops.delsys[0] == SYS_ISDBT)\r\nret = fe->ops.tuner_ops.init(fe);\r\nif (ret == 0 && fe->dtv_property_cache.frequency == 0) {\r\nfe->dtv_property_cache.frequency =\r\nadap_conf[i].init_freq;\r\nret = fe->ops.tuner_ops.set_params(fe);\r\n}\r\nif (ret < 0) {\r\ndev_warn(&pt3->pdev->dev,\r\n"Failed in initial tuning of tuner[%d]\n", i);\r\nreturn ret;\r\n}\r\n}\r\nfor (i = 0; i < PT3_NUM_FE; i++) {\r\nfe = pt3->adaps[i]->fe;\r\nif (fe->ops.tuner_ops.sleep)\r\nret = fe->ops.tuner_ops.sleep(fe);\r\nif (ret < 0)\r\nbreak;\r\nif (fe->ops.sleep)\r\nret = fe->ops.sleep(fe);\r\nif (ret < 0)\r\nbreak;\r\nif (fe->ops.delsys[0] == SYS_ISDBS)\r\nfe->ops.set_voltage = &pt3_set_voltage;\r\nelse\r\nfe->ops.set_lna = &pt3_set_lna;\r\n}\r\nif (i < PT3_NUM_FE) {\r\ndev_warn(&pt3->pdev->dev, "FE[%d] failed to standby\n", i);\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic int pt3_attach_fe(struct pt3_board *pt3, int i)\r\n{\r\nstruct i2c_board_info info;\r\nstruct tc90522_config cfg;\r\nstruct i2c_client *cl;\r\nstruct dvb_adapter *dvb_adap;\r\nint ret;\r\ninfo = adap_conf[i].demod_info;\r\ncfg = adap_conf[i].demod_cfg;\r\ncfg.tuner_i2c = NULL;\r\ninfo.platform_data = &cfg;\r\nret = -ENODEV;\r\nrequest_module("tc90522");\r\ncl = i2c_new_device(&pt3->i2c_adap, &info);\r\nif (!cl || !cl->dev.driver)\r\nreturn -ENODEV;\r\npt3->adaps[i]->i2c_demod = cl;\r\nif (!try_module_get(cl->dev.driver->owner))\r\ngoto err_demod_i2c_unregister_device;\r\nif (!strncmp(cl->name, TC90522_I2C_DEV_SAT,\r\nstrlen(TC90522_I2C_DEV_SAT))) {\r\nstruct qm1d1c0042_config tcfg;\r\ntcfg = adap_conf[i].tuner_cfg.qm1d1c0042;\r\ntcfg.fe = cfg.fe;\r\ninfo = adap_conf[i].tuner_info;\r\ninfo.platform_data = &tcfg;\r\nrequest_module("qm1d1c0042");\r\ncl = i2c_new_device(cfg.tuner_i2c, &info);\r\n} else {\r\nstruct mxl301rf_config tcfg;\r\ntcfg = adap_conf[i].tuner_cfg.mxl301rf;\r\ntcfg.fe = cfg.fe;\r\ninfo = adap_conf[i].tuner_info;\r\ninfo.platform_data = &tcfg;\r\nrequest_module("mxl301rf");\r\ncl = i2c_new_device(cfg.tuner_i2c, &info);\r\n}\r\nif (!cl || !cl->dev.driver)\r\ngoto err_demod_module_put;\r\npt3->adaps[i]->i2c_tuner = cl;\r\nif (!try_module_get(cl->dev.driver->owner))\r\ngoto err_tuner_i2c_unregister_device;\r\ndvb_adap = &pt3->adaps[one_adapter ? 0 : i]->dvb_adap;\r\nret = dvb_register_frontend(dvb_adap, cfg.fe);\r\nif (ret < 0)\r\ngoto err_tuner_module_put;\r\npt3->adaps[i]->fe = cfg.fe;\r\nreturn 0;\r\nerr_tuner_module_put:\r\nmodule_put(pt3->adaps[i]->i2c_tuner->dev.driver->owner);\r\nerr_tuner_i2c_unregister_device:\r\ni2c_unregister_device(pt3->adaps[i]->i2c_tuner);\r\nerr_demod_module_put:\r\nmodule_put(pt3->adaps[i]->i2c_demod->dev.driver->owner);\r\nerr_demod_i2c_unregister_device:\r\ni2c_unregister_device(pt3->adaps[i]->i2c_demod);\r\nreturn ret;\r\n}\r\nstatic int pt3_fetch_thread(void *data)\r\n{\r\nstruct pt3_adapter *adap = data;\r\nktime_t delay;\r\nbool was_frozen;\r\n#define PT3_INITIAL_BUF_DROPS 4\r\n#define PT3_FETCH_DELAY 10\r\n#define PT3_FETCH_DELAY_DELTA 2\r\npt3_init_dmabuf(adap);\r\nadap->num_discard = PT3_INITIAL_BUF_DROPS;\r\ndev_dbg(adap->dvb_adap.device, "PT3: [%s] started\n",\r\nadap->thread->comm);\r\nset_freezable();\r\nwhile (!kthread_freezable_should_stop(&was_frozen)) {\r\nif (was_frozen)\r\nadap->num_discard = PT3_INITIAL_BUF_DROPS;\r\npt3_proc_dma(adap);\r\ndelay = ktime_set(0, PT3_FETCH_DELAY * NSEC_PER_MSEC);\r\nset_current_state(TASK_UNINTERRUPTIBLE);\r\nfreezable_schedule_hrtimeout_range(&delay,\r\nPT3_FETCH_DELAY_DELTA * NSEC_PER_MSEC,\r\nHRTIMER_MODE_REL);\r\n}\r\ndev_dbg(adap->dvb_adap.device, "PT3: [%s] exited\n",\r\nadap->thread->comm);\r\nadap->thread = NULL;\r\nreturn 0;\r\n}\r\nstatic int pt3_start_streaming(struct pt3_adapter *adap)\r\n{\r\nstruct task_struct *thread;\r\nthread = kthread_run(pt3_fetch_thread, adap, "pt3-ad%i-dmx%i",\r\nadap->dvb_adap.num, adap->dmxdev.dvbdev->id);\r\nif (IS_ERR(thread)) {\r\nint ret = PTR_ERR(thread);\r\ndev_warn(adap->dvb_adap.device,\r\n"PT3 (adap:%d, dmx:%d): failed to start kthread\n",\r\nadap->dvb_adap.num, adap->dmxdev.dvbdev->id);\r\nreturn ret;\r\n}\r\nadap->thread = thread;\r\nreturn pt3_start_dma(adap);\r\n}\r\nstatic int pt3_stop_streaming(struct pt3_adapter *adap)\r\n{\r\nint ret;\r\nret = pt3_stop_dma(adap);\r\nif (ret)\r\ndev_warn(adap->dvb_adap.device,\r\n"PT3: failed to stop streaming of adap:%d/FE:%d\n",\r\nadap->dvb_adap.num, adap->fe->id);\r\nret = kthread_stop(adap->thread);\r\nreturn ret;\r\n}\r\nstatic int pt3_start_feed(struct dvb_demux_feed *feed)\r\n{\r\nstruct pt3_adapter *adap;\r\nif (signal_pending(current))\r\nreturn -EINTR;\r\nadap = container_of(feed->demux, struct pt3_adapter, demux);\r\nadap->num_feeds++;\r\nif (adap->thread)\r\nreturn 0;\r\nif (adap->num_feeds != 1) {\r\ndev_warn(adap->dvb_adap.device,\r\n"%s: unmatched start/stop_feed in adap:%i/dmx:%i\n",\r\n__func__, adap->dvb_adap.num, adap->dmxdev.dvbdev->id);\r\nadap->num_feeds = 1;\r\n}\r\nreturn pt3_start_streaming(adap);\r\n}\r\nstatic int pt3_stop_feed(struct dvb_demux_feed *feed)\r\n{\r\nstruct pt3_adapter *adap;\r\nadap = container_of(feed->demux, struct pt3_adapter, demux);\r\nadap->num_feeds--;\r\nif (adap->num_feeds > 0 || !adap->thread)\r\nreturn 0;\r\nadap->num_feeds = 0;\r\nreturn pt3_stop_streaming(adap);\r\n}\r\nstatic int pt3_alloc_adapter(struct pt3_board *pt3, int index)\r\n{\r\nint ret;\r\nstruct pt3_adapter *adap;\r\nstruct dvb_adapter *da;\r\nadap = kzalloc(sizeof(*adap), GFP_KERNEL);\r\nif (!adap)\r\nreturn -ENOMEM;\r\npt3->adaps[index] = adap;\r\nadap->adap_idx = index;\r\nif (index == 0 || !one_adapter) {\r\nret = dvb_register_adapter(&adap->dvb_adap, "PT3 DVB",\r\nTHIS_MODULE, &pt3->pdev->dev, adapter_nr);\r\nif (ret < 0) {\r\ndev_err(&pt3->pdev->dev,\r\n"failed to register adapter dev\n");\r\ngoto err_mem;\r\n}\r\nda = &adap->dvb_adap;\r\n} else\r\nda = &pt3->adaps[0]->dvb_adap;\r\nadap->dvb_adap.priv = pt3;\r\nadap->demux.dmx.capabilities = DMX_TS_FILTERING | DMX_SECTION_FILTERING;\r\nadap->demux.priv = adap;\r\nadap->demux.feednum = 256;\r\nadap->demux.filternum = 256;\r\nadap->demux.start_feed = pt3_start_feed;\r\nadap->demux.stop_feed = pt3_stop_feed;\r\nret = dvb_dmx_init(&adap->demux);\r\nif (ret < 0) {\r\ndev_err(&pt3->pdev->dev, "failed to init dmx dev\n");\r\ngoto err_adap;\r\n}\r\nadap->dmxdev.filternum = 256;\r\nadap->dmxdev.demux = &adap->demux.dmx;\r\nret = dvb_dmxdev_init(&adap->dmxdev, da);\r\nif (ret < 0) {\r\ndev_err(&pt3->pdev->dev, "failed to init dmxdev\n");\r\ngoto err_demux;\r\n}\r\nret = pt3_alloc_dmabuf(adap);\r\nif (ret) {\r\ndev_err(&pt3->pdev->dev, "failed to alloc DMA buffers\n");\r\ngoto err_dmabuf;\r\n}\r\nreturn 0;\r\nerr_dmabuf:\r\npt3_free_dmabuf(adap);\r\ndvb_dmxdev_release(&adap->dmxdev);\r\nerr_demux:\r\ndvb_dmx_release(&adap->demux);\r\nerr_adap:\r\nif (index == 0 || !one_adapter)\r\ndvb_unregister_adapter(da);\r\nerr_mem:\r\nkfree(adap);\r\npt3->adaps[index] = NULL;\r\nreturn ret;\r\n}\r\nstatic void pt3_cleanup_adapter(struct pt3_board *pt3, int index)\r\n{\r\nstruct pt3_adapter *adap;\r\nstruct dmx_demux *dmx;\r\nadap = pt3->adaps[index];\r\nif (adap == NULL)\r\nreturn;\r\nif (adap->thread)\r\npt3_stop_streaming(adap);\r\ndmx = &adap->demux.dmx;\r\ndmx->close(dmx);\r\nif (adap->fe) {\r\nadap->fe->callback = NULL;\r\nif (adap->fe->frontend_priv)\r\ndvb_unregister_frontend(adap->fe);\r\nif (adap->i2c_tuner) {\r\nmodule_put(adap->i2c_tuner->dev.driver->owner);\r\ni2c_unregister_device(adap->i2c_tuner);\r\n}\r\nif (adap->i2c_demod) {\r\nmodule_put(adap->i2c_demod->dev.driver->owner);\r\ni2c_unregister_device(adap->i2c_demod);\r\n}\r\n}\r\npt3_free_dmabuf(adap);\r\ndvb_dmxdev_release(&adap->dmxdev);\r\ndvb_dmx_release(&adap->demux);\r\nif (index == 0 || !one_adapter)\r\ndvb_unregister_adapter(&adap->dvb_adap);\r\nkfree(adap);\r\npt3->adaps[index] = NULL;\r\n}\r\nstatic int pt3_suspend(struct device *dev)\r\n{\r\nstruct pci_dev *pdev = to_pci_dev(dev);\r\nstruct pt3_board *pt3 = pci_get_drvdata(pdev);\r\nint i;\r\nstruct pt3_adapter *adap;\r\nfor (i = 0; i < PT3_NUM_FE; i++) {\r\nadap = pt3->adaps[i];\r\nif (adap->num_feeds > 0)\r\npt3_stop_dma(adap);\r\ndvb_frontend_suspend(adap->fe);\r\npt3_free_dmabuf(adap);\r\n}\r\npt3_lnb_ctrl(pt3, false);\r\npt3_set_tuner_power(pt3, false, false);\r\nreturn 0;\r\n}\r\nstatic int pt3_resume(struct device *dev)\r\n{\r\nstruct pci_dev *pdev = to_pci_dev(dev);\r\nstruct pt3_board *pt3 = pci_get_drvdata(pdev);\r\nint i, ret;\r\nstruct pt3_adapter *adap;\r\nret = pt3_fe_init(pt3);\r\nif (ret)\r\nreturn ret;\r\nif (pt3->lna_on_cnt > 0)\r\npt3_set_tuner_power(pt3, true, true);\r\nif (pt3->lnb_on_cnt > 0)\r\npt3_lnb_ctrl(pt3, true);\r\nfor (i = 0; i < PT3_NUM_FE; i++) {\r\nadap = pt3->adaps[i];\r\ndvb_frontend_resume(adap->fe);\r\nret = pt3_alloc_dmabuf(adap);\r\nif (ret) {\r\ndev_err(&pt3->pdev->dev, "failed to alloc DMA bufs\n");\r\ncontinue;\r\n}\r\nif (adap->num_feeds > 0)\r\npt3_start_dma(adap);\r\n}\r\nreturn 0;\r\n}\r\nstatic void pt3_remove(struct pci_dev *pdev)\r\n{\r\nstruct pt3_board *pt3;\r\nint i;\r\npt3 = pci_get_drvdata(pdev);\r\nfor (i = PT3_NUM_FE - 1; i >= 0; i--)\r\npt3_cleanup_adapter(pt3, i);\r\ni2c_del_adapter(&pt3->i2c_adap);\r\nkfree(pt3->i2c_buf);\r\npci_iounmap(pt3->pdev, pt3->regs[0]);\r\npci_iounmap(pt3->pdev, pt3->regs[1]);\r\npci_release_regions(pdev);\r\npci_disable_device(pdev);\r\nkfree(pt3);\r\n}\r\nstatic int pt3_probe(struct pci_dev *pdev, const struct pci_device_id *ent)\r\n{\r\nu8 rev;\r\nu32 ver;\r\nint i, ret;\r\nstruct pt3_board *pt3;\r\nstruct i2c_adapter *i2c;\r\nif (pci_read_config_byte(pdev, PCI_REVISION_ID, &rev) || rev != 1)\r\nreturn -ENODEV;\r\nret = pci_enable_device(pdev);\r\nif (ret < 0)\r\nreturn -ENODEV;\r\npci_set_master(pdev);\r\nret = pci_request_regions(pdev, DRV_NAME);\r\nif (ret < 0)\r\ngoto err_disable_device;\r\nret = dma_set_mask(&pdev->dev, DMA_BIT_MASK(64));\r\nif (ret == 0)\r\ndma_set_coherent_mask(&pdev->dev, DMA_BIT_MASK(64));\r\nelse {\r\nret = dma_set_mask(&pdev->dev, DMA_BIT_MASK(32));\r\nif (ret == 0)\r\ndma_set_coherent_mask(&pdev->dev, DMA_BIT_MASK(32));\r\nelse {\r\ndev_err(&pdev->dev, "Failed to set DMA mask\n");\r\ngoto err_release_regions;\r\n}\r\ndev_info(&pdev->dev, "Use 32bit DMA\n");\r\n}\r\npt3 = kzalloc(sizeof(*pt3), GFP_KERNEL);\r\nif (!pt3) {\r\nret = -ENOMEM;\r\ngoto err_release_regions;\r\n}\r\npci_set_drvdata(pdev, pt3);\r\npt3->pdev = pdev;\r\nmutex_init(&pt3->lock);\r\npt3->regs[0] = pci_ioremap_bar(pdev, 0);\r\npt3->regs[1] = pci_ioremap_bar(pdev, 2);\r\nif (pt3->regs[0] == NULL || pt3->regs[1] == NULL) {\r\ndev_err(&pdev->dev, "Failed to ioremap\n");\r\nret = -ENOMEM;\r\ngoto err_kfree;\r\n}\r\nver = ioread32(pt3->regs[0] + REG_VERSION);\r\nif ((ver >> 16) != 0x0301) {\r\ndev_warn(&pdev->dev, "PT%d, I/F-ver.:%d not supported\n",\r\nver >> 24, (ver & 0x00ff0000) >> 16);\r\nret = -ENODEV;\r\ngoto err_iounmap;\r\n}\r\npt3->num_bufs = clamp_val(num_bufs, MIN_DATA_BUFS, MAX_DATA_BUFS);\r\npt3->i2c_buf = kmalloc(sizeof(*pt3->i2c_buf), GFP_KERNEL);\r\nif (pt3->i2c_buf == NULL) {\r\nret = -ENOMEM;\r\ngoto err_iounmap;\r\n}\r\ni2c = &pt3->i2c_adap;\r\ni2c->owner = THIS_MODULE;\r\ni2c->algo = &pt3_i2c_algo;\r\ni2c->algo_data = NULL;\r\ni2c->dev.parent = &pdev->dev;\r\nstrlcpy(i2c->name, DRV_NAME, sizeof(i2c->name));\r\ni2c_set_adapdata(i2c, pt3);\r\nret = i2c_add_adapter(i2c);\r\nif (ret < 0) {\r\ndev_err(&pdev->dev, "Failed to add i2c adapter\n");\r\ngoto err_i2cbuf;\r\n}\r\nfor (i = 0; i < PT3_NUM_FE; i++) {\r\nret = pt3_alloc_adapter(pt3, i);\r\nif (ret < 0)\r\nbreak;\r\nret = pt3_attach_fe(pt3, i);\r\nif (ret < 0)\r\nbreak;\r\n}\r\nif (i < PT3_NUM_FE) {\r\ndev_err(&pdev->dev, "Failed to create FE%d\n", i);\r\ngoto err_cleanup_adapters;\r\n}\r\nret = pt3_fe_init(pt3);\r\nif (ret < 0) {\r\ndev_err(&pdev->dev, "Failed to init frontends\n");\r\ni = PT3_NUM_FE - 1;\r\ngoto err_cleanup_adapters;\r\n}\r\ndev_info(&pdev->dev,\r\n"successfully init'ed PT%d (fw:0x%02x, I/F:0x%02x)\n",\r\nver >> 24, (ver >> 8) & 0xff, (ver >> 16) & 0xff);\r\nreturn 0;\r\nerr_cleanup_adapters:\r\nwhile (i >= 0)\r\npt3_cleanup_adapter(pt3, i--);\r\ni2c_del_adapter(i2c);\r\nerr_i2cbuf:\r\nkfree(pt3->i2c_buf);\r\nerr_iounmap:\r\nif (pt3->regs[0])\r\npci_iounmap(pdev, pt3->regs[0]);\r\nif (pt3->regs[1])\r\npci_iounmap(pdev, pt3->regs[1]);\r\nerr_kfree:\r\nkfree(pt3);\r\nerr_release_regions:\r\npci_release_regions(pdev);\r\nerr_disable_device:\r\npci_disable_device(pdev);\r\nreturn ret;\r\n}
