static struct deinterlace_q_data *get_q_data(enum v4l2_buf_type type)\r\n{\r\nswitch (type) {\r\ncase V4L2_BUF_TYPE_VIDEO_OUTPUT:\r\nreturn &q_data[V4L2_M2M_SRC];\r\ncase V4L2_BUF_TYPE_VIDEO_CAPTURE:\r\nreturn &q_data[V4L2_M2M_DST];\r\ndefault:\r\nBUG();\r\n}\r\nreturn NULL;\r\n}\r\nstatic struct deinterlace_fmt *find_format(struct v4l2_format *f)\r\n{\r\nstruct deinterlace_fmt *fmt;\r\nunsigned int k;\r\nfor (k = 0; k < NUM_FORMATS; k++) {\r\nfmt = &formats[k];\r\nif ((fmt->types & f->type) &&\r\n(fmt->fourcc == f->fmt.pix.pixelformat))\r\nbreak;\r\n}\r\nif (k == NUM_FORMATS)\r\nreturn NULL;\r\nreturn &formats[k];\r\n}\r\nstatic int deinterlace_job_ready(void *priv)\r\n{\r\nstruct deinterlace_ctx *ctx = priv;\r\nstruct deinterlace_dev *pcdev = ctx->dev;\r\nif ((v4l2_m2m_num_src_bufs_ready(ctx->m2m_ctx) > 0)\r\n&& (v4l2_m2m_num_dst_bufs_ready(ctx->m2m_ctx) > 0)\r\n&& (atomic_read(&ctx->dev->busy) == 0)) {\r\ndprintk(pcdev, "Task ready\n");\r\nreturn 1;\r\n}\r\ndprintk(pcdev, "Task not ready to run\n");\r\nreturn 0;\r\n}\r\nstatic void deinterlace_job_abort(void *priv)\r\n{\r\nstruct deinterlace_ctx *ctx = priv;\r\nstruct deinterlace_dev *pcdev = ctx->dev;\r\nctx->aborting = 1;\r\ndprintk(pcdev, "Aborting task\n");\r\nv4l2_m2m_job_finish(pcdev->m2m_dev, ctx->m2m_ctx);\r\n}\r\nstatic void deinterlace_lock(void *priv)\r\n{\r\nstruct deinterlace_ctx *ctx = priv;\r\nstruct deinterlace_dev *pcdev = ctx->dev;\r\nmutex_lock(&pcdev->dev_mutex);\r\n}\r\nstatic void deinterlace_unlock(void *priv)\r\n{\r\nstruct deinterlace_ctx *ctx = priv;\r\nstruct deinterlace_dev *pcdev = ctx->dev;\r\nmutex_unlock(&pcdev->dev_mutex);\r\n}\r\nstatic void dma_callback(void *data)\r\n{\r\nstruct deinterlace_ctx *curr_ctx = data;\r\nstruct deinterlace_dev *pcdev = curr_ctx->dev;\r\nstruct vb2_v4l2_buffer *src_vb, *dst_vb;\r\natomic_set(&pcdev->busy, 0);\r\nsrc_vb = v4l2_m2m_src_buf_remove(curr_ctx->m2m_ctx);\r\ndst_vb = v4l2_m2m_dst_buf_remove(curr_ctx->m2m_ctx);\r\ndst_vb->vb2_buf.timestamp = src_vb->vb2_buf.timestamp;\r\ndst_vb->flags &= ~V4L2_BUF_FLAG_TSTAMP_SRC_MASK;\r\ndst_vb->flags |=\r\nsrc_vb->flags & V4L2_BUF_FLAG_TSTAMP_SRC_MASK;\r\ndst_vb->timecode = src_vb->timecode;\r\nv4l2_m2m_buf_done(src_vb, VB2_BUF_STATE_DONE);\r\nv4l2_m2m_buf_done(dst_vb, VB2_BUF_STATE_DONE);\r\nv4l2_m2m_job_finish(pcdev->m2m_dev, curr_ctx->m2m_ctx);\r\ndprintk(pcdev, "dma transfers completed.\n");\r\n}\r\nstatic void deinterlace_issue_dma(struct deinterlace_ctx *ctx, int op,\r\nint do_callback)\r\n{\r\nstruct deinterlace_q_data *s_q_data;\r\nstruct vb2_v4l2_buffer *src_buf, *dst_buf;\r\nstruct deinterlace_dev *pcdev = ctx->dev;\r\nstruct dma_chan *chan = pcdev->dma_chan;\r\nstruct dma_device *dmadev = chan->device;\r\nstruct dma_async_tx_descriptor *tx;\r\nunsigned int s_width, s_height;\r\nunsigned int s_size;\r\ndma_addr_t p_in, p_out;\r\nenum dma_ctrl_flags flags;\r\nsrc_buf = v4l2_m2m_next_src_buf(ctx->m2m_ctx);\r\ndst_buf = v4l2_m2m_next_dst_buf(ctx->m2m_ctx);\r\ns_q_data = get_q_data(V4L2_BUF_TYPE_VIDEO_OUTPUT);\r\ns_width = s_q_data->width;\r\ns_height = s_q_data->height;\r\ns_size = s_width * s_height;\r\np_in = (dma_addr_t)vb2_dma_contig_plane_dma_addr(&src_buf->vb2_buf, 0);\r\np_out = (dma_addr_t)vb2_dma_contig_plane_dma_addr(&dst_buf->vb2_buf,\r\n0);\r\nif (!p_in || !p_out) {\r\nv4l2_err(&pcdev->v4l2_dev,\r\n"Acquiring kernel pointers to buffers failed\n");\r\nreturn;\r\n}\r\nswitch (op) {\r\ncase YUV420_DMA_Y_ODD:\r\nctx->xt->numf = s_height / 2;\r\nctx->xt->sgl[0].size = s_width;\r\nctx->xt->sgl[0].icg = s_width;\r\nctx->xt->src_start = p_in;\r\nctx->xt->dst_start = p_out;\r\nbreak;\r\ncase YUV420_DMA_Y_EVEN:\r\nctx->xt->numf = s_height / 2;\r\nctx->xt->sgl[0].size = s_width;\r\nctx->xt->sgl[0].icg = s_width;\r\nctx->xt->src_start = p_in + s_size / 2;\r\nctx->xt->dst_start = p_out + s_width;\r\nbreak;\r\ncase YUV420_DMA_U_ODD:\r\nctx->xt->numf = s_height / 4;\r\nctx->xt->sgl[0].size = s_width / 2;\r\nctx->xt->sgl[0].icg = s_width / 2;\r\nctx->xt->src_start = p_in + s_size;\r\nctx->xt->dst_start = p_out + s_size;\r\nbreak;\r\ncase YUV420_DMA_U_EVEN:\r\nctx->xt->numf = s_height / 4;\r\nctx->xt->sgl[0].size = s_width / 2;\r\nctx->xt->sgl[0].icg = s_width / 2;\r\nctx->xt->src_start = p_in + (9 * s_size) / 8;\r\nctx->xt->dst_start = p_out + s_size + s_width / 2;\r\nbreak;\r\ncase YUV420_DMA_V_ODD:\r\nctx->xt->numf = s_height / 4;\r\nctx->xt->sgl[0].size = s_width / 2;\r\nctx->xt->sgl[0].icg = s_width / 2;\r\nctx->xt->src_start = p_in + (5 * s_size) / 4;\r\nctx->xt->dst_start = p_out + (5 * s_size) / 4;\r\nbreak;\r\ncase YUV420_DMA_V_EVEN:\r\nctx->xt->numf = s_height / 4;\r\nctx->xt->sgl[0].size = s_width / 2;\r\nctx->xt->sgl[0].icg = s_width / 2;\r\nctx->xt->src_start = p_in + (11 * s_size) / 8;\r\nctx->xt->dst_start = p_out + (5 * s_size) / 4 + s_width / 2;\r\nbreak;\r\ncase YUV420_DMA_Y_ODD_DOUBLING:\r\nctx->xt->numf = s_height / 2;\r\nctx->xt->sgl[0].size = s_width;\r\nctx->xt->sgl[0].icg = s_width;\r\nctx->xt->src_start = p_in;\r\nctx->xt->dst_start = p_out + s_width;\r\nbreak;\r\ncase YUV420_DMA_U_ODD_DOUBLING:\r\nctx->xt->numf = s_height / 4;\r\nctx->xt->sgl[0].size = s_width / 2;\r\nctx->xt->sgl[0].icg = s_width / 2;\r\nctx->xt->src_start = p_in + s_size;\r\nctx->xt->dst_start = p_out + s_size + s_width / 2;\r\nbreak;\r\ncase YUV420_DMA_V_ODD_DOUBLING:\r\nctx->xt->numf = s_height / 4;\r\nctx->xt->sgl[0].size = s_width / 2;\r\nctx->xt->sgl[0].icg = s_width / 2;\r\nctx->xt->src_start = p_in + (5 * s_size) / 4;\r\nctx->xt->dst_start = p_out + (5 * s_size) / 4 + s_width / 2;\r\nbreak;\r\ncase YUYV_DMA_ODD:\r\nctx->xt->numf = s_height / 2;\r\nctx->xt->sgl[0].size = s_width * 2;\r\nctx->xt->sgl[0].icg = s_width * 2;\r\nctx->xt->src_start = p_in;\r\nctx->xt->dst_start = p_out;\r\nbreak;\r\ncase YUYV_DMA_EVEN:\r\nctx->xt->numf = s_height / 2;\r\nctx->xt->sgl[0].size = s_width * 2;\r\nctx->xt->sgl[0].icg = s_width * 2;\r\nctx->xt->src_start = p_in + s_size;\r\nctx->xt->dst_start = p_out + s_width * 2;\r\nbreak;\r\ncase YUYV_DMA_EVEN_DOUBLING:\r\ndefault:\r\nctx->xt->numf = s_height / 2;\r\nctx->xt->sgl[0].size = s_width * 2;\r\nctx->xt->sgl[0].icg = s_width * 2;\r\nctx->xt->src_start = p_in;\r\nctx->xt->dst_start = p_out + s_width * 2;\r\nbreak;\r\n}\r\nctx->xt->frame_size = 1;\r\nctx->xt->dir = DMA_MEM_TO_MEM;\r\nctx->xt->src_sgl = false;\r\nctx->xt->dst_sgl = true;\r\nflags = DMA_CTRL_ACK | DMA_PREP_INTERRUPT;\r\ntx = dmadev->device_prep_interleaved_dma(chan, ctx->xt, flags);\r\nif (tx == NULL) {\r\nv4l2_warn(&pcdev->v4l2_dev, "DMA interleaved prep error\n");\r\nreturn;\r\n}\r\nif (do_callback) {\r\ntx->callback = dma_callback;\r\ntx->callback_param = ctx;\r\n}\r\nctx->cookie = dmaengine_submit(tx);\r\nif (dma_submit_error(ctx->cookie)) {\r\nv4l2_warn(&pcdev->v4l2_dev,\r\n"DMA submit error %d with src=0x%x dst=0x%x len=0x%x\n",\r\nctx->cookie, (unsigned)p_in, (unsigned)p_out,\r\ns_size * 3/2);\r\nreturn;\r\n}\r\ndma_async_issue_pending(chan);\r\n}\r\nstatic void deinterlace_device_run(void *priv)\r\n{\r\nstruct deinterlace_ctx *ctx = priv;\r\nstruct deinterlace_q_data *dst_q_data;\r\natomic_set(&ctx->dev->busy, 1);\r\ndprintk(ctx->dev, "%s: DMA try issue.\n", __func__);\r\ndst_q_data = get_q_data(V4L2_BUF_TYPE_VIDEO_CAPTURE);\r\nswitch (dst_q_data->fmt->fourcc) {\r\ncase V4L2_PIX_FMT_YUV420:\r\nswitch (dst_q_data->field) {\r\ncase V4L2_FIELD_INTERLACED_TB:\r\ncase V4L2_FIELD_INTERLACED_BT:\r\ndprintk(ctx->dev, "%s: yuv420 interlaced tb.\n",\r\n__func__);\r\ndeinterlace_issue_dma(ctx, YUV420_DMA_Y_ODD, 0);\r\ndeinterlace_issue_dma(ctx, YUV420_DMA_Y_EVEN, 0);\r\ndeinterlace_issue_dma(ctx, YUV420_DMA_U_ODD, 0);\r\ndeinterlace_issue_dma(ctx, YUV420_DMA_U_EVEN, 0);\r\ndeinterlace_issue_dma(ctx, YUV420_DMA_V_ODD, 0);\r\ndeinterlace_issue_dma(ctx, YUV420_DMA_V_EVEN, 1);\r\nbreak;\r\ncase V4L2_FIELD_NONE:\r\ndefault:\r\ndprintk(ctx->dev, "%s: yuv420 interlaced line doubling.\n",\r\n__func__);\r\ndeinterlace_issue_dma(ctx, YUV420_DMA_Y_ODD, 0);\r\ndeinterlace_issue_dma(ctx, YUV420_DMA_Y_ODD_DOUBLING, 0);\r\ndeinterlace_issue_dma(ctx, YUV420_DMA_U_ODD, 0);\r\ndeinterlace_issue_dma(ctx, YUV420_DMA_U_ODD_DOUBLING, 0);\r\ndeinterlace_issue_dma(ctx, YUV420_DMA_V_ODD, 0);\r\ndeinterlace_issue_dma(ctx, YUV420_DMA_V_ODD_DOUBLING, 1);\r\nbreak;\r\n}\r\nbreak;\r\ncase V4L2_PIX_FMT_YUYV:\r\ndefault:\r\nswitch (dst_q_data->field) {\r\ncase V4L2_FIELD_INTERLACED_TB:\r\ncase V4L2_FIELD_INTERLACED_BT:\r\ndprintk(ctx->dev, "%s: yuyv interlaced_tb.\n",\r\n__func__);\r\ndeinterlace_issue_dma(ctx, YUYV_DMA_ODD, 0);\r\ndeinterlace_issue_dma(ctx, YUYV_DMA_EVEN, 1);\r\nbreak;\r\ncase V4L2_FIELD_NONE:\r\ndefault:\r\ndprintk(ctx->dev, "%s: yuyv interlaced line doubling.\n",\r\n__func__);\r\ndeinterlace_issue_dma(ctx, YUYV_DMA_ODD, 0);\r\ndeinterlace_issue_dma(ctx, YUYV_DMA_EVEN_DOUBLING, 1);\r\nbreak;\r\n}\r\nbreak;\r\n}\r\ndprintk(ctx->dev, "%s: DMA issue done.\n", __func__);\r\n}\r\nstatic int vidioc_querycap(struct file *file, void *priv,\r\nstruct v4l2_capability *cap)\r\n{\r\nstrlcpy(cap->driver, MEM2MEM_NAME, sizeof(cap->driver));\r\nstrlcpy(cap->card, MEM2MEM_NAME, sizeof(cap->card));\r\nstrlcpy(cap->bus_info, MEM2MEM_NAME, sizeof(cap->card));\r\ncap->device_caps = V4L2_CAP_VIDEO_CAPTURE | V4L2_CAP_VIDEO_OUTPUT |\r\nV4L2_CAP_VIDEO_M2M | V4L2_CAP_STREAMING;\r\ncap->capabilities = cap->device_caps | V4L2_CAP_DEVICE_CAPS;\r\nreturn 0;\r\n}\r\nstatic int enum_fmt(struct v4l2_fmtdesc *f, u32 type)\r\n{\r\nint i, num;\r\nstruct deinterlace_fmt *fmt;\r\nnum = 0;\r\nfor (i = 0; i < NUM_FORMATS; ++i) {\r\nif (formats[i].types & type) {\r\nif (num == f->index)\r\nbreak;\r\n++num;\r\n}\r\n}\r\nif (i < NUM_FORMATS) {\r\nfmt = &formats[i];\r\nstrlcpy(f->description, fmt->name, sizeof(f->description));\r\nf->pixelformat = fmt->fourcc;\r\nreturn 0;\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int vidioc_enum_fmt_vid_cap(struct file *file, void *priv,\r\nstruct v4l2_fmtdesc *f)\r\n{\r\nreturn enum_fmt(f, MEM2MEM_CAPTURE);\r\n}\r\nstatic int vidioc_enum_fmt_vid_out(struct file *file, void *priv,\r\nstruct v4l2_fmtdesc *f)\r\n{\r\nreturn enum_fmt(f, MEM2MEM_OUTPUT);\r\n}\r\nstatic int vidioc_g_fmt(struct deinterlace_ctx *ctx, struct v4l2_format *f)\r\n{\r\nstruct vb2_queue *vq;\r\nstruct deinterlace_q_data *q_data;\r\nvq = v4l2_m2m_get_vq(ctx->m2m_ctx, f->type);\r\nif (!vq)\r\nreturn -EINVAL;\r\nq_data = get_q_data(f->type);\r\nf->fmt.pix.width = q_data->width;\r\nf->fmt.pix.height = q_data->height;\r\nf->fmt.pix.field = q_data->field;\r\nf->fmt.pix.pixelformat = q_data->fmt->fourcc;\r\nswitch (q_data->fmt->fourcc) {\r\ncase V4L2_PIX_FMT_YUV420:\r\nf->fmt.pix.bytesperline = q_data->width * 3 / 2;\r\nbreak;\r\ncase V4L2_PIX_FMT_YUYV:\r\ndefault:\r\nf->fmt.pix.bytesperline = q_data->width * 2;\r\n}\r\nf->fmt.pix.sizeimage = q_data->sizeimage;\r\nf->fmt.pix.colorspace = ctx->colorspace;\r\nreturn 0;\r\n}\r\nstatic int vidioc_g_fmt_vid_out(struct file *file, void *priv,\r\nstruct v4l2_format *f)\r\n{\r\nreturn vidioc_g_fmt(priv, f);\r\n}\r\nstatic int vidioc_g_fmt_vid_cap(struct file *file, void *priv,\r\nstruct v4l2_format *f)\r\n{\r\nreturn vidioc_g_fmt(priv, f);\r\n}\r\nstatic int vidioc_try_fmt(struct v4l2_format *f, struct deinterlace_fmt *fmt)\r\n{\r\nswitch (f->fmt.pix.pixelformat) {\r\ncase V4L2_PIX_FMT_YUV420:\r\nf->fmt.pix.bytesperline = f->fmt.pix.width * 3 / 2;\r\nbreak;\r\ncase V4L2_PIX_FMT_YUYV:\r\ndefault:\r\nf->fmt.pix.bytesperline = f->fmt.pix.width * 2;\r\n}\r\nf->fmt.pix.sizeimage = f->fmt.pix.height * f->fmt.pix.bytesperline;\r\nreturn 0;\r\n}\r\nstatic int vidioc_try_fmt_vid_cap(struct file *file, void *priv,\r\nstruct v4l2_format *f)\r\n{\r\nstruct deinterlace_fmt *fmt;\r\nstruct deinterlace_ctx *ctx = priv;\r\nfmt = find_format(f);\r\nif (!fmt || !(fmt->types & MEM2MEM_CAPTURE))\r\nf->fmt.pix.pixelformat = V4L2_PIX_FMT_YUV420;\r\nf->fmt.pix.colorspace = ctx->colorspace;\r\nif (f->fmt.pix.field != V4L2_FIELD_INTERLACED_TB &&\r\nf->fmt.pix.field != V4L2_FIELD_INTERLACED_BT &&\r\nf->fmt.pix.field != V4L2_FIELD_NONE)\r\nf->fmt.pix.field = V4L2_FIELD_INTERLACED_TB;\r\nreturn vidioc_try_fmt(f, fmt);\r\n}\r\nstatic int vidioc_try_fmt_vid_out(struct file *file, void *priv,\r\nstruct v4l2_format *f)\r\n{\r\nstruct deinterlace_fmt *fmt;\r\nfmt = find_format(f);\r\nif (!fmt || !(fmt->types & MEM2MEM_OUTPUT))\r\nf->fmt.pix.pixelformat = V4L2_PIX_FMT_YUV420;\r\nif (!f->fmt.pix.colorspace)\r\nf->fmt.pix.colorspace = V4L2_COLORSPACE_REC709;\r\nif (f->fmt.pix.field != V4L2_FIELD_SEQ_TB &&\r\nf->fmt.pix.field != V4L2_FIELD_SEQ_BT)\r\nf->fmt.pix.field = V4L2_FIELD_SEQ_TB;\r\nreturn vidioc_try_fmt(f, fmt);\r\n}\r\nstatic int vidioc_s_fmt(struct deinterlace_ctx *ctx, struct v4l2_format *f)\r\n{\r\nstruct deinterlace_q_data *q_data;\r\nstruct vb2_queue *vq;\r\nvq = v4l2_m2m_get_vq(ctx->m2m_ctx, f->type);\r\nif (!vq)\r\nreturn -EINVAL;\r\nq_data = get_q_data(f->type);\r\nif (!q_data)\r\nreturn -EINVAL;\r\nif (vb2_is_busy(vq)) {\r\nv4l2_err(&ctx->dev->v4l2_dev, "%s queue busy\n", __func__);\r\nreturn -EBUSY;\r\n}\r\nq_data->fmt = find_format(f);\r\nif (!q_data->fmt) {\r\nv4l2_err(&ctx->dev->v4l2_dev,\r\n"Couldn't set format type %d, wxh: %dx%d. fmt: %d, field: %d\n",\r\nf->type, f->fmt.pix.width, f->fmt.pix.height,\r\nf->fmt.pix.pixelformat, f->fmt.pix.field);\r\nreturn -EINVAL;\r\n}\r\nq_data->width = f->fmt.pix.width;\r\nq_data->height = f->fmt.pix.height;\r\nq_data->field = f->fmt.pix.field;\r\nswitch (f->fmt.pix.pixelformat) {\r\ncase V4L2_PIX_FMT_YUV420:\r\nf->fmt.pix.bytesperline = f->fmt.pix.width * 3 / 2;\r\nq_data->sizeimage = (q_data->width * q_data->height * 3) / 2;\r\nbreak;\r\ncase V4L2_PIX_FMT_YUYV:\r\ndefault:\r\nf->fmt.pix.bytesperline = f->fmt.pix.width * 2;\r\nq_data->sizeimage = q_data->width * q_data->height * 2;\r\n}\r\ndprintk(ctx->dev,\r\n"Setting format for type %d, wxh: %dx%d, fmt: %d, field: %d\n",\r\nf->type, q_data->width, q_data->height, q_data->fmt->fourcc,\r\nq_data->field);\r\nreturn 0;\r\n}\r\nstatic int vidioc_s_fmt_vid_cap(struct file *file, void *priv,\r\nstruct v4l2_format *f)\r\n{\r\nint ret;\r\nret = vidioc_try_fmt_vid_cap(file, priv, f);\r\nif (ret)\r\nreturn ret;\r\nreturn vidioc_s_fmt(priv, f);\r\n}\r\nstatic int vidioc_s_fmt_vid_out(struct file *file, void *priv,\r\nstruct v4l2_format *f)\r\n{\r\nstruct deinterlace_ctx *ctx = priv;\r\nint ret;\r\nret = vidioc_try_fmt_vid_out(file, priv, f);\r\nif (ret)\r\nreturn ret;\r\nret = vidioc_s_fmt(priv, f);\r\nif (!ret)\r\nctx->colorspace = f->fmt.pix.colorspace;\r\nreturn ret;\r\n}\r\nstatic int vidioc_reqbufs(struct file *file, void *priv,\r\nstruct v4l2_requestbuffers *reqbufs)\r\n{\r\nstruct deinterlace_ctx *ctx = priv;\r\nreturn v4l2_m2m_reqbufs(file, ctx->m2m_ctx, reqbufs);\r\n}\r\nstatic int vidioc_querybuf(struct file *file, void *priv,\r\nstruct v4l2_buffer *buf)\r\n{\r\nstruct deinterlace_ctx *ctx = priv;\r\nreturn v4l2_m2m_querybuf(file, ctx->m2m_ctx, buf);\r\n}\r\nstatic int vidioc_qbuf(struct file *file, void *priv, struct v4l2_buffer *buf)\r\n{\r\nstruct deinterlace_ctx *ctx = priv;\r\nreturn v4l2_m2m_qbuf(file, ctx->m2m_ctx, buf);\r\n}\r\nstatic int vidioc_dqbuf(struct file *file, void *priv, struct v4l2_buffer *buf)\r\n{\r\nstruct deinterlace_ctx *ctx = priv;\r\nreturn v4l2_m2m_dqbuf(file, ctx->m2m_ctx, buf);\r\n}\r\nstatic int vidioc_streamon(struct file *file, void *priv,\r\nenum v4l2_buf_type type)\r\n{\r\nstruct deinterlace_q_data *s_q_data, *d_q_data;\r\nstruct deinterlace_ctx *ctx = priv;\r\ns_q_data = get_q_data(V4L2_BUF_TYPE_VIDEO_OUTPUT);\r\nd_q_data = get_q_data(V4L2_BUF_TYPE_VIDEO_CAPTURE);\r\nif (s_q_data->fmt->fourcc != d_q_data->fmt->fourcc) {\r\nv4l2_err(&ctx->dev->v4l2_dev,\r\n"src and dst formats don't match.\n");\r\nreturn -EINVAL;\r\n}\r\nswitch (s_q_data->field) {\r\ncase V4L2_FIELD_SEQ_BT:\r\nif (d_q_data->field != V4L2_FIELD_NONE &&\r\nd_q_data->field != V4L2_FIELD_INTERLACED_BT) {\r\nv4l2_err(&ctx->dev->v4l2_dev,\r\n"src and dst field conversion [(%d)->(%d)] not supported.\n",\r\ns_q_data->field, d_q_data->field);\r\nreturn -EINVAL;\r\n}\r\nbreak;\r\ncase V4L2_FIELD_SEQ_TB:\r\nif (d_q_data->field != V4L2_FIELD_NONE &&\r\nd_q_data->field != V4L2_FIELD_INTERLACED_TB) {\r\nv4l2_err(&ctx->dev->v4l2_dev,\r\n"src and dst field conversion [(%d)->(%d)] not supported.\n",\r\ns_q_data->field, d_q_data->field);\r\nreturn -EINVAL;\r\n}\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn v4l2_m2m_streamon(file, ctx->m2m_ctx, type);\r\n}\r\nstatic int vidioc_streamoff(struct file *file, void *priv,\r\nenum v4l2_buf_type type)\r\n{\r\nstruct deinterlace_ctx *ctx = priv;\r\nreturn v4l2_m2m_streamoff(file, ctx->m2m_ctx, type);\r\n}\r\nstatic int deinterlace_queue_setup(struct vb2_queue *vq,\r\nunsigned int *nbuffers, unsigned int *nplanes,\r\nunsigned int sizes[], void *alloc_ctxs[])\r\n{\r\nstruct deinterlace_ctx *ctx = vb2_get_drv_priv(vq);\r\nstruct deinterlace_q_data *q_data;\r\nunsigned int size, count = *nbuffers;\r\nq_data = get_q_data(vq->type);\r\nswitch (q_data->fmt->fourcc) {\r\ncase V4L2_PIX_FMT_YUV420:\r\nsize = q_data->width * q_data->height * 3 / 2;\r\nbreak;\r\ncase V4L2_PIX_FMT_YUYV:\r\ndefault:\r\nsize = q_data->width * q_data->height * 2;\r\n}\r\n*nplanes = 1;\r\n*nbuffers = count;\r\nsizes[0] = size;\r\nalloc_ctxs[0] = ctx->dev->alloc_ctx;\r\ndprintk(ctx->dev, "get %d buffer(s) of size %d each.\n", count, size);\r\nreturn 0;\r\n}\r\nstatic int deinterlace_buf_prepare(struct vb2_buffer *vb)\r\n{\r\nstruct deinterlace_ctx *ctx = vb2_get_drv_priv(vb->vb2_queue);\r\nstruct deinterlace_q_data *q_data;\r\ndprintk(ctx->dev, "type: %d\n", vb->vb2_queue->type);\r\nq_data = get_q_data(vb->vb2_queue->type);\r\nif (vb2_plane_size(vb, 0) < q_data->sizeimage) {\r\ndprintk(ctx->dev, "%s data will not fit into plane (%lu < %lu)\n",\r\n__func__, vb2_plane_size(vb, 0), (long)q_data->sizeimage);\r\nreturn -EINVAL;\r\n}\r\nvb2_set_plane_payload(vb, 0, q_data->sizeimage);\r\nreturn 0;\r\n}\r\nstatic void deinterlace_buf_queue(struct vb2_buffer *vb)\r\n{\r\nstruct vb2_v4l2_buffer *vbuf = to_vb2_v4l2_buffer(vb);\r\nstruct deinterlace_ctx *ctx = vb2_get_drv_priv(vb->vb2_queue);\r\nv4l2_m2m_buf_queue(ctx->m2m_ctx, vbuf);\r\n}\r\nstatic int queue_init(void *priv, struct vb2_queue *src_vq,\r\nstruct vb2_queue *dst_vq)\r\n{\r\nstruct deinterlace_ctx *ctx = priv;\r\nint ret;\r\nsrc_vq->type = V4L2_BUF_TYPE_VIDEO_OUTPUT;\r\nsrc_vq->io_modes = VB2_MMAP | VB2_USERPTR;\r\nsrc_vq->drv_priv = ctx;\r\nsrc_vq->buf_struct_size = sizeof(struct v4l2_m2m_buffer);\r\nsrc_vq->ops = &deinterlace_qops;\r\nsrc_vq->mem_ops = &vb2_dma_contig_memops;\r\nsrc_vq->timestamp_flags = V4L2_BUF_FLAG_TIMESTAMP_COPY;\r\nq_data[V4L2_M2M_SRC].fmt = &formats[0];\r\nq_data[V4L2_M2M_SRC].width = 640;\r\nq_data[V4L2_M2M_SRC].height = 480;\r\nq_data[V4L2_M2M_SRC].sizeimage = (640 * 480 * 3) / 2;\r\nq_data[V4L2_M2M_SRC].field = V4L2_FIELD_SEQ_TB;\r\nret = vb2_queue_init(src_vq);\r\nif (ret)\r\nreturn ret;\r\ndst_vq->type = V4L2_BUF_TYPE_VIDEO_CAPTURE;\r\ndst_vq->io_modes = VB2_MMAP | VB2_USERPTR;\r\ndst_vq->drv_priv = ctx;\r\ndst_vq->buf_struct_size = sizeof(struct v4l2_m2m_buffer);\r\ndst_vq->ops = &deinterlace_qops;\r\ndst_vq->mem_ops = &vb2_dma_contig_memops;\r\ndst_vq->timestamp_flags = V4L2_BUF_FLAG_TIMESTAMP_COPY;\r\nq_data[V4L2_M2M_DST].fmt = &formats[0];\r\nq_data[V4L2_M2M_DST].width = 640;\r\nq_data[V4L2_M2M_DST].height = 480;\r\nq_data[V4L2_M2M_DST].sizeimage = (640 * 480 * 3) / 2;\r\nq_data[V4L2_M2M_SRC].field = V4L2_FIELD_INTERLACED_TB;\r\nreturn vb2_queue_init(dst_vq);\r\n}\r\nstatic int deinterlace_open(struct file *file)\r\n{\r\nstruct deinterlace_dev *pcdev = video_drvdata(file);\r\nstruct deinterlace_ctx *ctx = NULL;\r\nctx = kzalloc(sizeof *ctx, GFP_KERNEL);\r\nif (!ctx)\r\nreturn -ENOMEM;\r\nfile->private_data = ctx;\r\nctx->dev = pcdev;\r\nctx->m2m_ctx = v4l2_m2m_ctx_init(pcdev->m2m_dev, ctx, &queue_init);\r\nif (IS_ERR(ctx->m2m_ctx)) {\r\nint ret = PTR_ERR(ctx->m2m_ctx);\r\nkfree(ctx);\r\nreturn ret;\r\n}\r\nctx->xt = kzalloc(sizeof(struct dma_interleaved_template) +\r\nsizeof(struct data_chunk), GFP_KERNEL);\r\nif (!ctx->xt) {\r\nkfree(ctx);\r\nreturn -ENOMEM;\r\n}\r\nctx->colorspace = V4L2_COLORSPACE_REC709;\r\ndprintk(pcdev, "Created instance %p, m2m_ctx: %p\n", ctx, ctx->m2m_ctx);\r\nreturn 0;\r\n}\r\nstatic int deinterlace_release(struct file *file)\r\n{\r\nstruct deinterlace_dev *pcdev = video_drvdata(file);\r\nstruct deinterlace_ctx *ctx = file->private_data;\r\ndprintk(pcdev, "Releasing instance %p\n", ctx);\r\nv4l2_m2m_ctx_release(ctx->m2m_ctx);\r\nkfree(ctx->xt);\r\nkfree(ctx);\r\nreturn 0;\r\n}\r\nstatic unsigned int deinterlace_poll(struct file *file,\r\nstruct poll_table_struct *wait)\r\n{\r\nstruct deinterlace_ctx *ctx = file->private_data;\r\nint ret;\r\ndeinterlace_lock(ctx);\r\nret = v4l2_m2m_poll(file, ctx->m2m_ctx, wait);\r\ndeinterlace_unlock(ctx);\r\nreturn ret;\r\n}\r\nstatic int deinterlace_mmap(struct file *file, struct vm_area_struct *vma)\r\n{\r\nstruct deinterlace_ctx *ctx = file->private_data;\r\nreturn v4l2_m2m_mmap(file, ctx->m2m_ctx, vma);\r\n}\r\nstatic int deinterlace_probe(struct platform_device *pdev)\r\n{\r\nstruct deinterlace_dev *pcdev;\r\nstruct video_device *vfd;\r\ndma_cap_mask_t mask;\r\nint ret = 0;\r\npcdev = devm_kzalloc(&pdev->dev, sizeof(*pcdev), GFP_KERNEL);\r\nif (!pcdev)\r\nreturn -ENOMEM;\r\nspin_lock_init(&pcdev->irqlock);\r\ndma_cap_zero(mask);\r\ndma_cap_set(DMA_INTERLEAVE, mask);\r\npcdev->dma_chan = dma_request_channel(mask, NULL, pcdev);\r\nif (!pcdev->dma_chan)\r\nreturn -ENODEV;\r\nif (!dma_has_cap(DMA_INTERLEAVE, pcdev->dma_chan->device->cap_mask)) {\r\nv4l2_err(&pcdev->v4l2_dev, "DMA does not support INTERLEAVE\n");\r\ngoto rel_dma;\r\n}\r\nret = v4l2_device_register(&pdev->dev, &pcdev->v4l2_dev);\r\nif (ret)\r\ngoto rel_dma;\r\natomic_set(&pcdev->busy, 0);\r\nmutex_init(&pcdev->dev_mutex);\r\nvfd = &pcdev->vfd;\r\n*vfd = deinterlace_videodev;\r\nvfd->lock = &pcdev->dev_mutex;\r\nvfd->v4l2_dev = &pcdev->v4l2_dev;\r\nret = video_register_device(vfd, VFL_TYPE_GRABBER, 0);\r\nif (ret) {\r\nv4l2_err(&pcdev->v4l2_dev, "Failed to register video device\n");\r\ngoto unreg_dev;\r\n}\r\nvideo_set_drvdata(vfd, pcdev);\r\nsnprintf(vfd->name, sizeof(vfd->name), "%s", deinterlace_videodev.name);\r\nv4l2_info(&pcdev->v4l2_dev, MEM2MEM_TEST_MODULE_NAME\r\n" Device registered as /dev/video%d\n", vfd->num);\r\nplatform_set_drvdata(pdev, pcdev);\r\npcdev->alloc_ctx = vb2_dma_contig_init_ctx(&pdev->dev);\r\nif (IS_ERR(pcdev->alloc_ctx)) {\r\nv4l2_err(&pcdev->v4l2_dev, "Failed to alloc vb2 context\n");\r\nret = PTR_ERR(pcdev->alloc_ctx);\r\ngoto err_ctx;\r\n}\r\npcdev->m2m_dev = v4l2_m2m_init(&m2m_ops);\r\nif (IS_ERR(pcdev->m2m_dev)) {\r\nv4l2_err(&pcdev->v4l2_dev, "Failed to init mem2mem device\n");\r\nret = PTR_ERR(pcdev->m2m_dev);\r\ngoto err_m2m;\r\n}\r\nreturn 0;\r\nerr_m2m:\r\nvideo_unregister_device(&pcdev->vfd);\r\nerr_ctx:\r\nvb2_dma_contig_cleanup_ctx(pcdev->alloc_ctx);\r\nunreg_dev:\r\nv4l2_device_unregister(&pcdev->v4l2_dev);\r\nrel_dma:\r\ndma_release_channel(pcdev->dma_chan);\r\nreturn ret;\r\n}\r\nstatic int deinterlace_remove(struct platform_device *pdev)\r\n{\r\nstruct deinterlace_dev *pcdev = platform_get_drvdata(pdev);\r\nv4l2_info(&pcdev->v4l2_dev, "Removing " MEM2MEM_TEST_MODULE_NAME);\r\nv4l2_m2m_release(pcdev->m2m_dev);\r\nvideo_unregister_device(&pcdev->vfd);\r\nv4l2_device_unregister(&pcdev->v4l2_dev);\r\nvb2_dma_contig_cleanup_ctx(pcdev->alloc_ctx);\r\ndma_release_channel(pcdev->dma_chan);\r\nreturn 0;\r\n}
