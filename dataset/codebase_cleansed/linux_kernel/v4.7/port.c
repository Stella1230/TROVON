static ssize_t connect_type_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct usb_port *port_dev = to_usb_port(dev);\r\nchar *result;\r\nswitch (port_dev->connect_type) {\r\ncase USB_PORT_CONNECT_TYPE_HOT_PLUG:\r\nresult = "hotplug";\r\nbreak;\r\ncase USB_PORT_CONNECT_TYPE_HARD_WIRED:\r\nresult = "hardwired";\r\nbreak;\r\ncase USB_PORT_NOT_USED:\r\nresult = "not used";\r\nbreak;\r\ndefault:\r\nresult = "unknown";\r\nbreak;\r\n}\r\nreturn sprintf(buf, "%s\n", result);\r\n}\r\nstatic ssize_t usb3_lpm_permit_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct usb_port *port_dev = to_usb_port(dev);\r\nconst char *p;\r\nif (port_dev->usb3_lpm_u1_permit) {\r\nif (port_dev->usb3_lpm_u2_permit)\r\np = "u1_u2";\r\nelse\r\np = "u1";\r\n} else {\r\nif (port_dev->usb3_lpm_u2_permit)\r\np = "u2";\r\nelse\r\np = "0";\r\n}\r\nreturn sprintf(buf, "%s\n", p);\r\n}\r\nstatic ssize_t usb3_lpm_permit_store(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct usb_port *port_dev = to_usb_port(dev);\r\nstruct usb_device *udev = port_dev->child;\r\nstruct usb_hcd *hcd;\r\nif (!strncmp(buf, "u1_u2", 5)) {\r\nport_dev->usb3_lpm_u1_permit = 1;\r\nport_dev->usb3_lpm_u2_permit = 1;\r\n} else if (!strncmp(buf, "u1", 2)) {\r\nport_dev->usb3_lpm_u1_permit = 1;\r\nport_dev->usb3_lpm_u2_permit = 0;\r\n} else if (!strncmp(buf, "u2", 2)) {\r\nport_dev->usb3_lpm_u1_permit = 0;\r\nport_dev->usb3_lpm_u2_permit = 1;\r\n} else if (!strncmp(buf, "0", 1)) {\r\nport_dev->usb3_lpm_u1_permit = 0;\r\nport_dev->usb3_lpm_u2_permit = 0;\r\n} else\r\nreturn -EINVAL;\r\nif (udev) {\r\nhcd = bus_to_hcd(udev->bus);\r\nif (!hcd)\r\nreturn -EINVAL;\r\nusb_lock_device(udev);\r\nmutex_lock(hcd->bandwidth_mutex);\r\nif (!usb_disable_lpm(udev))\r\nusb_enable_lpm(udev);\r\nmutex_unlock(hcd->bandwidth_mutex);\r\nusb_unlock_device(udev);\r\n}\r\nreturn count;\r\n}\r\nstatic void usb_port_device_release(struct device *dev)\r\n{\r\nstruct usb_port *port_dev = to_usb_port(dev);\r\nkfree(port_dev->req);\r\nkfree(port_dev);\r\n}\r\nstatic int usb_port_runtime_resume(struct device *dev)\r\n{\r\nstruct usb_port *port_dev = to_usb_port(dev);\r\nstruct usb_device *hdev = to_usb_device(dev->parent->parent);\r\nstruct usb_interface *intf = to_usb_interface(dev->parent);\r\nstruct usb_hub *hub = usb_hub_to_struct_hub(hdev);\r\nstruct usb_device *udev = port_dev->child;\r\nstruct usb_port *peer = port_dev->peer;\r\nint port1 = port_dev->portnum;\r\nint retval;\r\nif (!hub)\r\nreturn -EINVAL;\r\nif (hub->in_reset) {\r\nset_bit(port1, hub->power_bits);\r\nreturn 0;\r\n}\r\nif (!port_dev->is_superspeed && peer)\r\npm_runtime_get_sync(&peer->dev);\r\nusb_autopm_get_interface(intf);\r\nretval = usb_hub_set_port_power(hdev, hub, port1, true);\r\nmsleep(hub_power_on_good_delay(hub));\r\nif (udev && !retval) {\r\nif (hub_port_debounce_be_connected(hub, port1) < 0) {\r\ndev_dbg(&port_dev->dev, "reconnect timeout\n");\r\nif (hub_is_superspeed(hdev))\r\nset_bit(port1, hub->warm_reset_bits);\r\n}\r\nif (!test_and_set_bit(port1, hub->child_usage_bits)) {\r\npm_runtime_get_noresume(&port_dev->dev);\r\npm_request_resume(&udev->dev);\r\n}\r\n}\r\nusb_autopm_put_interface(intf);\r\nreturn retval;\r\n}\r\nstatic int usb_port_runtime_suspend(struct device *dev)\r\n{\r\nstruct usb_port *port_dev = to_usb_port(dev);\r\nstruct usb_device *hdev = to_usb_device(dev->parent->parent);\r\nstruct usb_interface *intf = to_usb_interface(dev->parent);\r\nstruct usb_hub *hub = usb_hub_to_struct_hub(hdev);\r\nstruct usb_port *peer = port_dev->peer;\r\nint port1 = port_dev->portnum;\r\nint retval;\r\nif (!hub)\r\nreturn -EINVAL;\r\nif (hub->in_reset)\r\nreturn -EBUSY;\r\nif (dev_pm_qos_flags(&port_dev->dev, PM_QOS_FLAG_NO_POWER_OFF)\r\n== PM_QOS_FLAGS_ALL)\r\nreturn -EAGAIN;\r\nif (usb_port_block_power_off)\r\nreturn -EBUSY;\r\nusb_autopm_get_interface(intf);\r\nretval = usb_hub_set_port_power(hdev, hub, port1, false);\r\nusb_clear_port_feature(hdev, port1, USB_PORT_FEAT_C_CONNECTION);\r\nif (!port_dev->is_superspeed)\r\nusb_clear_port_feature(hdev, port1, USB_PORT_FEAT_C_ENABLE);\r\nusb_autopm_put_interface(intf);\r\nif (!port_dev->is_superspeed && peer)\r\npm_runtime_put(&peer->dev);\r\nreturn retval;\r\n}\r\nstatic int link_peers(struct usb_port *left, struct usb_port *right)\r\n{\r\nstruct usb_port *ss_port, *hs_port;\r\nint rc;\r\nif (left->peer == right && right->peer == left)\r\nreturn 0;\r\nif (left->peer || right->peer) {\r\nstruct usb_port *lpeer = left->peer;\r\nstruct usb_port *rpeer = right->peer;\r\nchar *method;\r\nif (left->location && left->location == right->location)\r\nmethod = "location";\r\nelse\r\nmethod = "default";\r\npr_debug("usb: failed to peer %s and %s by %s (%s:%s) (%s:%s)\n",\r\ndev_name(&left->dev), dev_name(&right->dev), method,\r\ndev_name(&left->dev),\r\nlpeer ? dev_name(&lpeer->dev) : "none",\r\ndev_name(&right->dev),\r\nrpeer ? dev_name(&rpeer->dev) : "none");\r\nreturn -EBUSY;\r\n}\r\nrc = sysfs_create_link(&left->dev.kobj, &right->dev.kobj, "peer");\r\nif (rc)\r\nreturn rc;\r\nrc = sysfs_create_link(&right->dev.kobj, &left->dev.kobj, "peer");\r\nif (rc) {\r\nsysfs_remove_link(&left->dev.kobj, "peer");\r\nreturn rc;\r\n}\r\nif (left->is_superspeed) {\r\nss_port = left;\r\nWARN_ON(right->is_superspeed);\r\nhs_port = right;\r\n} else {\r\nss_port = right;\r\nWARN_ON(!right->is_superspeed);\r\nhs_port = left;\r\n}\r\npm_runtime_get_sync(&hs_port->dev);\r\nleft->peer = right;\r\nright->peer = left;\r\npm_runtime_get_sync(&ss_port->dev);\r\npm_runtime_put(&hs_port->dev);\r\nreturn 0;\r\n}\r\nstatic void link_peers_report(struct usb_port *left, struct usb_port *right)\r\n{\r\nint rc;\r\nrc = link_peers(left, right);\r\nif (rc == 0) {\r\ndev_dbg(&left->dev, "peered to %s\n", dev_name(&right->dev));\r\n} else {\r\ndev_dbg(&left->dev, "failed to peer to %s (%d)\n",\r\ndev_name(&right->dev), rc);\r\npr_warn_once("usb: port power management may be unreliable\n");\r\nusb_port_block_power_off = 1;\r\n}\r\n}\r\nstatic void unlink_peers(struct usb_port *left, struct usb_port *right)\r\n{\r\nstruct usb_port *ss_port, *hs_port;\r\nWARN(right->peer != left || left->peer != right,\r\n"%s and %s are not peers?\n",\r\ndev_name(&left->dev), dev_name(&right->dev));\r\nif (left->is_superspeed) {\r\nss_port = left;\r\nhs_port = right;\r\n} else {\r\nss_port = right;\r\nhs_port = left;\r\n}\r\npm_runtime_get_sync(&hs_port->dev);\r\nsysfs_remove_link(&left->dev.kobj, "peer");\r\nright->peer = NULL;\r\nsysfs_remove_link(&right->dev.kobj, "peer");\r\nleft->peer = NULL;\r\npm_runtime_put(&ss_port->dev);\r\npm_runtime_put(&hs_port->dev);\r\n}\r\nstatic int match_location(struct usb_device *peer_hdev, void *p)\r\n{\r\nint port1;\r\nstruct usb_hcd *hcd, *peer_hcd;\r\nstruct usb_port *port_dev = p, *peer;\r\nstruct usb_hub *peer_hub = usb_hub_to_struct_hub(peer_hdev);\r\nstruct usb_device *hdev = to_usb_device(port_dev->dev.parent->parent);\r\nif (!peer_hub)\r\nreturn 0;\r\nhcd = bus_to_hcd(hdev->bus);\r\npeer_hcd = bus_to_hcd(peer_hdev->bus);\r\nif (peer_hcd != hcd->shared_hcd)\r\nreturn 0;\r\nfor (port1 = 1; port1 <= peer_hdev->maxchild; port1++) {\r\npeer = peer_hub->ports[port1 - 1];\r\nif (peer && peer->location == port_dev->location) {\r\nlink_peers_report(port_dev, peer);\r\nreturn 1;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic void find_and_link_peer(struct usb_hub *hub, int port1)\r\n{\r\nstruct usb_port *port_dev = hub->ports[port1 - 1], *peer;\r\nstruct usb_device *hdev = hub->hdev;\r\nstruct usb_device *peer_hdev;\r\nstruct usb_hub *peer_hub;\r\nif (port_dev->location) {\r\nusb_for_each_dev(port_dev, match_location);\r\nreturn;\r\n} else if (!hdev->parent) {\r\nstruct usb_hcd *hcd = bus_to_hcd(hdev->bus);\r\nstruct usb_hcd *peer_hcd = hcd->shared_hcd;\r\nif (!peer_hcd)\r\nreturn;\r\npeer_hdev = peer_hcd->self.root_hub;\r\n} else {\r\nstruct usb_port *upstream;\r\nstruct usb_device *parent = hdev->parent;\r\nstruct usb_hub *parent_hub = usb_hub_to_struct_hub(parent);\r\nif (!parent_hub)\r\nreturn;\r\nupstream = parent_hub->ports[hdev->portnum - 1];\r\nif (!upstream || !upstream->peer)\r\nreturn;\r\npeer_hdev = upstream->peer->child;\r\n}\r\npeer_hub = usb_hub_to_struct_hub(peer_hdev);\r\nif (!peer_hub || port1 > peer_hdev->maxchild)\r\nreturn;\r\npeer = peer_hub->ports[port1 - 1];\r\nif (peer && peer->location == 0)\r\nlink_peers_report(port_dev, peer);\r\n}\r\nint usb_hub_create_port_device(struct usb_hub *hub, int port1)\r\n{\r\nstruct usb_port *port_dev;\r\nstruct usb_device *hdev = hub->hdev;\r\nint retval;\r\nport_dev = kzalloc(sizeof(*port_dev), GFP_KERNEL);\r\nif (!port_dev)\r\nreturn -ENOMEM;\r\nport_dev->req = kzalloc(sizeof(*(port_dev->req)), GFP_KERNEL);\r\nif (!port_dev->req) {\r\nkfree(port_dev);\r\nreturn -ENOMEM;\r\n}\r\nhub->ports[port1 - 1] = port_dev;\r\nport_dev->portnum = port1;\r\nset_bit(port1, hub->power_bits);\r\nport_dev->dev.parent = hub->intfdev;\r\nif (hub_is_superspeed(hdev)) {\r\nport_dev->usb3_lpm_u1_permit = 1;\r\nport_dev->usb3_lpm_u2_permit = 1;\r\nport_dev->dev.groups = port_dev_usb3_group;\r\n} else\r\nport_dev->dev.groups = port_dev_group;\r\nport_dev->dev.type = &usb_port_device_type;\r\nport_dev->dev.driver = &usb_port_driver;\r\nif (hub_is_superspeed(hub->hdev))\r\nport_dev->is_superspeed = 1;\r\ndev_set_name(&port_dev->dev, "%s-port%d", dev_name(&hub->hdev->dev),\r\nport1);\r\nmutex_init(&port_dev->status_lock);\r\nretval = device_register(&port_dev->dev);\r\nif (retval) {\r\nput_device(&port_dev->dev);\r\nreturn retval;\r\n}\r\nretval = dev_pm_qos_add_request(&port_dev->dev, port_dev->req,\r\nDEV_PM_QOS_FLAGS, PM_QOS_FLAG_NO_POWER_OFF);\r\nif (retval < 0) {\r\ndevice_unregister(&port_dev->dev);\r\nreturn retval;\r\n}\r\nfind_and_link_peer(hub, port1);\r\npm_runtime_set_active(&port_dev->dev);\r\npm_runtime_get_noresume(&port_dev->dev);\r\npm_runtime_enable(&port_dev->dev);\r\ndevice_enable_async_suspend(&port_dev->dev);\r\nif (!hub_is_port_power_switchable(hub))\r\nreturn 0;\r\nretval = dev_pm_qos_expose_flags(&port_dev->dev,\r\nPM_QOS_FLAG_NO_POWER_OFF);\r\nif (retval < 0) {\r\ndev_warn(&port_dev->dev, "failed to expose pm_qos_no_poweroff\n");\r\nreturn 0;\r\n}\r\nretval = dev_pm_qos_remove_request(port_dev->req);\r\nif (retval >= 0) {\r\nkfree(port_dev->req);\r\nport_dev->req = NULL;\r\n}\r\nreturn 0;\r\n}\r\nvoid usb_hub_remove_port_device(struct usb_hub *hub, int port1)\r\n{\r\nstruct usb_port *port_dev = hub->ports[port1 - 1];\r\nstruct usb_port *peer;\r\npeer = port_dev->peer;\r\nif (peer)\r\nunlink_peers(port_dev, peer);\r\ndevice_unregister(&port_dev->dev);\r\n}
