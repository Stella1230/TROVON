static int mt312_read(struct mt312_state *state, const enum mt312_reg_addr reg,\r\nu8 *buf, const size_t count)\r\n{\r\nint ret;\r\nstruct i2c_msg msg[2];\r\nu8 regbuf[1] = { reg };\r\nmsg[0].addr = state->config->demod_address;\r\nmsg[0].flags = 0;\r\nmsg[0].buf = regbuf;\r\nmsg[0].len = 1;\r\nmsg[1].addr = state->config->demod_address;\r\nmsg[1].flags = I2C_M_RD;\r\nmsg[1].buf = buf;\r\nmsg[1].len = count;\r\nret = i2c_transfer(state->i2c, msg, 2);\r\nif (ret != 2) {\r\nprintk(KERN_DEBUG "%s: ret == %d\n", __func__, ret);\r\nreturn -EREMOTEIO;\r\n}\r\nif (debug) {\r\nint i;\r\ndprintk("R(%d):", reg & 0x7f);\r\nfor (i = 0; i < count; i++)\r\nprintk(KERN_CONT " %02x", buf[i]);\r\nprintk("\n");\r\n}\r\nreturn 0;\r\n}\r\nstatic int mt312_write(struct mt312_state *state, const enum mt312_reg_addr reg,\r\nconst u8 *src, const size_t count)\r\n{\r\nint ret;\r\nu8 buf[MAX_XFER_SIZE];\r\nstruct i2c_msg msg;\r\nif (1 + count > sizeof(buf)) {\r\nprintk(KERN_WARNING\r\n"mt312: write: len=%zu is too big!\n", count);\r\nreturn -EINVAL;\r\n}\r\nif (debug) {\r\nint i;\r\ndprintk("W(%d):", reg & 0x7f);\r\nfor (i = 0; i < count; i++)\r\nprintk(KERN_CONT " %02x", src[i]);\r\nprintk("\n");\r\n}\r\nbuf[0] = reg;\r\nmemcpy(&buf[1], src, count);\r\nmsg.addr = state->config->demod_address;\r\nmsg.flags = 0;\r\nmsg.buf = buf;\r\nmsg.len = count + 1;\r\nret = i2c_transfer(state->i2c, &msg, 1);\r\nif (ret != 1) {\r\ndprintk("%s: ret == %d\n", __func__, ret);\r\nreturn -EREMOTEIO;\r\n}\r\nreturn 0;\r\n}\r\nstatic inline int mt312_readreg(struct mt312_state *state,\r\nconst enum mt312_reg_addr reg, u8 *val)\r\n{\r\nreturn mt312_read(state, reg, val, 1);\r\n}\r\nstatic inline int mt312_writereg(struct mt312_state *state,\r\nconst enum mt312_reg_addr reg, const u8 val)\r\n{\r\nreturn mt312_write(state, reg, &val, 1);\r\n}\r\nstatic inline u32 mt312_div(u32 a, u32 b)\r\n{\r\nreturn (a + (b / 2)) / b;\r\n}\r\nstatic int mt312_reset(struct mt312_state *state, const u8 full)\r\n{\r\nreturn mt312_writereg(state, RESET, full ? 0x80 : 0x40);\r\n}\r\nstatic int mt312_get_inversion(struct mt312_state *state,\r\nenum fe_spectral_inversion *i)\r\n{\r\nint ret;\r\nu8 vit_mode;\r\nret = mt312_readreg(state, VIT_MODE, &vit_mode);\r\nif (ret < 0)\r\nreturn ret;\r\nif (vit_mode & 0x80)\r\n*i = (vit_mode & 0x40) ? INVERSION_ON : INVERSION_OFF;\r\nreturn 0;\r\n}\r\nstatic int mt312_get_symbol_rate(struct mt312_state *state, u32 *sr)\r\n{\r\nint ret;\r\nu8 sym_rate_h;\r\nu8 dec_ratio;\r\nu16 sym_rat_op;\r\nu16 monitor;\r\nu8 buf[2];\r\nret = mt312_readreg(state, SYM_RATE_H, &sym_rate_h);\r\nif (ret < 0)\r\nreturn ret;\r\nif (sym_rate_h & 0x80) {\r\nret = mt312_writereg(state, MON_CTRL, 0x03);\r\nif (ret < 0)\r\nreturn ret;\r\nret = mt312_read(state, MONITOR_H, buf, sizeof(buf));\r\nif (ret < 0)\r\nreturn ret;\r\nmonitor = (buf[0] << 8) | buf[1];\r\ndprintk("sr(auto) = %u\n",\r\nmt312_div(monitor * 15625, 4));\r\n} else {\r\nret = mt312_writereg(state, MON_CTRL, 0x05);\r\nif (ret < 0)\r\nreturn ret;\r\nret = mt312_read(state, MONITOR_H, buf, sizeof(buf));\r\nif (ret < 0)\r\nreturn ret;\r\ndec_ratio = ((buf[0] >> 5) & 0x07) * 32;\r\nret = mt312_read(state, SYM_RAT_OP_H, buf, sizeof(buf));\r\nif (ret < 0)\r\nreturn ret;\r\nsym_rat_op = (buf[0] << 8) | buf[1];\r\ndprintk("sym_rat_op=%d dec_ratio=%d\n",\r\nsym_rat_op, dec_ratio);\r\ndprintk("*sr(manual) = %lu\n",\r\n(((state->xtal * 8192) / (sym_rat_op + 8192)) *\r\n2) - dec_ratio);\r\n}\r\nreturn 0;\r\n}\r\nstatic int mt312_get_code_rate(struct mt312_state *state, enum fe_code_rate *cr)\r\n{\r\nconst enum fe_code_rate fec_tab[8] =\r\n{ FEC_1_2, FEC_2_3, FEC_3_4, FEC_5_6, FEC_6_7, FEC_7_8,\r\nFEC_AUTO, FEC_AUTO };\r\nint ret;\r\nu8 fec_status;\r\nret = mt312_readreg(state, FEC_STATUS, &fec_status);\r\nif (ret < 0)\r\nreturn ret;\r\n*cr = fec_tab[(fec_status >> 4) & 0x07];\r\nreturn 0;\r\n}\r\nstatic int mt312_initfe(struct dvb_frontend *fe)\r\n{\r\nstruct mt312_state *state = fe->demodulator_priv;\r\nint ret;\r\nu8 buf[2];\r\nret = mt312_writereg(state, CONFIG,\r\n(state->freq_mult == 6 ? 0x88 : 0x8c));\r\nif (ret < 0)\r\nreturn ret;\r\nudelay(150);\r\nret = mt312_reset(state, 1);\r\nif (ret < 0)\r\nreturn ret;\r\n{\r\nu8 buf_def[8] = { 0x14, 0x12, 0x03, 0x02,\r\n0x01, 0x00, 0x00, 0x00 };\r\nret = mt312_write(state, VIT_SETUP, buf_def, sizeof(buf_def));\r\nif (ret < 0)\r\nreturn ret;\r\n}\r\nswitch (state->id) {\r\ncase ID_ZL10313:\r\nret = mt312_writereg(state, GPP_CTRL, 0x80);\r\nif (ret < 0)\r\nreturn ret;\r\nbuf[0] = 0x80;\r\nbuf[1] = 0xB0;\r\nret = mt312_write(state, HW_CTRL, buf, 2);\r\nif (ret < 0)\r\nreturn ret;\r\nret = mt312_writereg(state, HW_CTRL, 0x00);\r\nif (ret < 0)\r\nreturn ret;\r\nret = mt312_writereg(state, MPEG_CTRL, 0x00);\r\nif (ret < 0)\r\nreturn ret;\r\nbreak;\r\n}\r\nbuf[0] = mt312_div(state->xtal * state->freq_mult * 2, 1000000);\r\nbuf[1] = mt312_div(state->xtal, 22000 * 4);\r\nret = mt312_write(state, SYS_CLK, buf, sizeof(buf));\r\nif (ret < 0)\r\nreturn ret;\r\nret = mt312_writereg(state, SNR_THS_HIGH, 0x32);\r\nif (ret < 0)\r\nreturn ret;\r\nswitch (state->id) {\r\ncase ID_ZL10313:\r\nbuf[0] = 0x33;\r\nbreak;\r\ndefault:\r\nbuf[0] = 0x53;\r\nbreak;\r\n}\r\nret = mt312_writereg(state, OP_CTRL, buf[0]);\r\nif (ret < 0)\r\nreturn ret;\r\nbuf[0] = 0x8c;\r\nbuf[1] = 0x98;\r\nret = mt312_write(state, TS_SW_LIM_L, buf, sizeof(buf));\r\nif (ret < 0)\r\nreturn ret;\r\nret = mt312_writereg(state, CS_SW_LIM, 0x69);\r\nif (ret < 0)\r\nreturn ret;\r\nreturn 0;\r\n}\r\nstatic int mt312_send_master_cmd(struct dvb_frontend *fe,\r\nstruct dvb_diseqc_master_cmd *c)\r\n{\r\nstruct mt312_state *state = fe->demodulator_priv;\r\nint ret;\r\nu8 diseqc_mode;\r\nif ((c->msg_len == 0) || (c->msg_len > sizeof(c->msg)))\r\nreturn -EINVAL;\r\nret = mt312_readreg(state, DISEQC_MODE, &diseqc_mode);\r\nif (ret < 0)\r\nreturn ret;\r\nret = mt312_write(state, (0x80 | DISEQC_INSTR), c->msg, c->msg_len);\r\nif (ret < 0)\r\nreturn ret;\r\nret = mt312_writereg(state, DISEQC_MODE,\r\n(diseqc_mode & 0x40) | ((c->msg_len - 1) << 3)\r\n| 0x04);\r\nif (ret < 0)\r\nreturn ret;\r\nmsleep(100);\r\nif (c->msg[0] & 0x02) {\r\nret = mt312_writereg(state, DISEQC_MODE, (diseqc_mode & 0x40));\r\nif (ret < 0)\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic int mt312_send_burst(struct dvb_frontend *fe,\r\nconst enum fe_sec_mini_cmd c)\r\n{\r\nstruct mt312_state *state = fe->demodulator_priv;\r\nconst u8 mini_tab[2] = { 0x02, 0x03 };\r\nint ret;\r\nu8 diseqc_mode;\r\nif (c > SEC_MINI_B)\r\nreturn -EINVAL;\r\nret = mt312_readreg(state, DISEQC_MODE, &diseqc_mode);\r\nif (ret < 0)\r\nreturn ret;\r\nret = mt312_writereg(state, DISEQC_MODE,\r\n(diseqc_mode & 0x40) | mini_tab[c]);\r\nif (ret < 0)\r\nreturn ret;\r\nreturn 0;\r\n}\r\nstatic int mt312_set_tone(struct dvb_frontend *fe,\r\nconst enum fe_sec_tone_mode t)\r\n{\r\nstruct mt312_state *state = fe->demodulator_priv;\r\nconst u8 tone_tab[2] = { 0x01, 0x00 };\r\nint ret;\r\nu8 diseqc_mode;\r\nif (t > SEC_TONE_OFF)\r\nreturn -EINVAL;\r\nret = mt312_readreg(state, DISEQC_MODE, &diseqc_mode);\r\nif (ret < 0)\r\nreturn ret;\r\nret = mt312_writereg(state, DISEQC_MODE,\r\n(diseqc_mode & 0x40) | tone_tab[t]);\r\nif (ret < 0)\r\nreturn ret;\r\nreturn 0;\r\n}\r\nstatic int mt312_set_voltage(struct dvb_frontend *fe,\r\nconst enum fe_sec_voltage v)\r\n{\r\nstruct mt312_state *state = fe->demodulator_priv;\r\nconst u8 volt_tab[3] = { 0x00, 0x40, 0x00 };\r\nu8 val;\r\nif (v > SEC_VOLTAGE_OFF)\r\nreturn -EINVAL;\r\nval = volt_tab[v];\r\nif (state->config->voltage_inverted)\r\nval ^= 0x40;\r\nreturn mt312_writereg(state, DISEQC_MODE, val);\r\n}\r\nstatic int mt312_read_status(struct dvb_frontend *fe, enum fe_status *s)\r\n{\r\nstruct mt312_state *state = fe->demodulator_priv;\r\nint ret;\r\nu8 status[3];\r\n*s = 0;\r\nret = mt312_read(state, QPSK_STAT_H, status, sizeof(status));\r\nif (ret < 0)\r\nreturn ret;\r\ndprintk("QPSK_STAT_H: 0x%02x, QPSK_STAT_L: 0x%02x,"\r\n" FEC_STATUS: 0x%02x\n", status[0], status[1], status[2]);\r\nif (status[0] & 0xc0)\r\n*s |= FE_HAS_SIGNAL;\r\nif (status[0] & 0x04)\r\n*s |= FE_HAS_CARRIER;\r\nif (status[2] & 0x02)\r\n*s |= FE_HAS_VITERBI;\r\nif (status[2] & 0x04)\r\n*s |= FE_HAS_SYNC;\r\nif (status[0] & 0x01)\r\n*s |= FE_HAS_LOCK;\r\nreturn 0;\r\n}\r\nstatic int mt312_read_ber(struct dvb_frontend *fe, u32 *ber)\r\n{\r\nstruct mt312_state *state = fe->demodulator_priv;\r\nint ret;\r\nu8 buf[3];\r\nret = mt312_read(state, RS_BERCNT_H, buf, 3);\r\nif (ret < 0)\r\nreturn ret;\r\n*ber = ((buf[0] << 16) | (buf[1] << 8) | buf[2]) * 64;\r\nreturn 0;\r\n}\r\nstatic int mt312_read_signal_strength(struct dvb_frontend *fe,\r\nu16 *signal_strength)\r\n{\r\nstruct mt312_state *state = fe->demodulator_priv;\r\nint ret;\r\nu8 buf[3];\r\nu16 agc;\r\ns16 err_db;\r\nret = mt312_read(state, AGC_H, buf, sizeof(buf));\r\nif (ret < 0)\r\nreturn ret;\r\nagc = (buf[0] << 6) | (buf[1] >> 2);\r\nerr_db = (s16) (((buf[1] & 0x03) << 14) | buf[2] << 6) >> 6;\r\n*signal_strength = agc;\r\ndprintk("agc=%08x err_db=%hd\n", agc, err_db);\r\nreturn 0;\r\n}\r\nstatic int mt312_read_snr(struct dvb_frontend *fe, u16 *snr)\r\n{\r\nstruct mt312_state *state = fe->demodulator_priv;\r\nint ret;\r\nu8 buf[2];\r\nret = mt312_read(state, M_SNR_H, buf, sizeof(buf));\r\nif (ret < 0)\r\nreturn ret;\r\n*snr = 0xFFFF - ((((buf[0] & 0x7f) << 8) | buf[1]) << 1);\r\nreturn 0;\r\n}\r\nstatic int mt312_read_ucblocks(struct dvb_frontend *fe, u32 *ubc)\r\n{\r\nstruct mt312_state *state = fe->demodulator_priv;\r\nint ret;\r\nu8 buf[2];\r\nret = mt312_read(state, RS_UBC_H, buf, sizeof(buf));\r\nif (ret < 0)\r\nreturn ret;\r\n*ubc = (buf[0] << 8) | buf[1];\r\nreturn 0;\r\n}\r\nstatic int mt312_set_frontend(struct dvb_frontend *fe)\r\n{\r\nstruct dtv_frontend_properties *p = &fe->dtv_property_cache;\r\nstruct mt312_state *state = fe->demodulator_priv;\r\nint ret;\r\nu8 buf[5], config_val;\r\nu16 sr;\r\nconst u8 fec_tab[10] =\r\n{ 0x00, 0x01, 0x02, 0x04, 0x3f, 0x08, 0x10, 0x20, 0x3f, 0x3f };\r\nconst u8 inv_tab[3] = { 0x00, 0x40, 0x80 };\r\ndprintk("%s: Freq %d\n", __func__, p->frequency);\r\nif ((p->frequency < fe->ops.info.frequency_min)\r\n|| (p->frequency > fe->ops.info.frequency_max))\r\nreturn -EINVAL;\r\nif (((int)p->inversion < INVERSION_OFF)\r\n|| (p->inversion > INVERSION_ON))\r\nreturn -EINVAL;\r\nif ((p->symbol_rate < fe->ops.info.symbol_rate_min)\r\n|| (p->symbol_rate > fe->ops.info.symbol_rate_max))\r\nreturn -EINVAL;\r\nif (((int)p->fec_inner < FEC_NONE)\r\n|| (p->fec_inner > FEC_AUTO))\r\nreturn -EINVAL;\r\nif ((p->fec_inner == FEC_4_5)\r\n|| (p->fec_inner == FEC_8_9))\r\nreturn -EINVAL;\r\nswitch (state->id) {\r\ncase ID_VP310:\r\nret = mt312_readreg(state, CONFIG, &config_val);\r\nif (ret < 0)\r\nreturn ret;\r\nif (p->symbol_rate >= 30000000) {\r\nif (state->freq_mult == 6) {\r\nstate->freq_mult = 9;\r\nret = mt312_initfe(fe);\r\nif (ret < 0)\r\nreturn ret;\r\n}\r\n} else {\r\nif (state->freq_mult == 9) {\r\nstate->freq_mult = 6;\r\nret = mt312_initfe(fe);\r\nif (ret < 0)\r\nreturn ret;\r\n}\r\n}\r\nbreak;\r\ncase ID_MT312:\r\ncase ID_ZL10313:\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nif (fe->ops.tuner_ops.set_params) {\r\nfe->ops.tuner_ops.set_params(fe);\r\nif (fe->ops.i2c_gate_ctrl)\r\nfe->ops.i2c_gate_ctrl(fe, 0);\r\n}\r\nsr = mt312_div(p->symbol_rate * 4, 15625);\r\nbuf[0] = (sr >> 8) & 0x3f;\r\nbuf[1] = (sr >> 0) & 0xff;\r\nbuf[2] = inv_tab[p->inversion] | fec_tab[p->fec_inner];\r\nbuf[3] = 0x40;\r\nif (p->symbol_rate < 10000000)\r\nbuf[3] |= 0x04;\r\nbuf[4] = 0x01;\r\nret = mt312_write(state, SYM_RATE_H, buf, sizeof(buf));\r\nif (ret < 0)\r\nreturn ret;\r\nmt312_reset(state, 0);\r\nreturn 0;\r\n}\r\nstatic int mt312_get_frontend(struct dvb_frontend *fe,\r\nstruct dtv_frontend_properties *p)\r\n{\r\nstruct mt312_state *state = fe->demodulator_priv;\r\nint ret;\r\nret = mt312_get_inversion(state, &p->inversion);\r\nif (ret < 0)\r\nreturn ret;\r\nret = mt312_get_symbol_rate(state, &p->symbol_rate);\r\nif (ret < 0)\r\nreturn ret;\r\nret = mt312_get_code_rate(state, &p->fec_inner);\r\nif (ret < 0)\r\nreturn ret;\r\nreturn 0;\r\n}\r\nstatic int mt312_i2c_gate_ctrl(struct dvb_frontend *fe, int enable)\r\n{\r\nstruct mt312_state *state = fe->demodulator_priv;\r\nu8 val = 0x00;\r\nint ret;\r\nswitch (state->id) {\r\ncase ID_ZL10313:\r\nret = mt312_readreg(state, GPP_CTRL, &val);\r\nif (ret < 0)\r\ngoto error;\r\nval &= 0x80;\r\nbreak;\r\n}\r\nif (enable)\r\nval |= 0x40;\r\nelse\r\nval &= ~0x40;\r\nret = mt312_writereg(state, GPP_CTRL, val);\r\nerror:\r\nreturn ret;\r\n}\r\nstatic int mt312_sleep(struct dvb_frontend *fe)\r\n{\r\nstruct mt312_state *state = fe->demodulator_priv;\r\nint ret;\r\nu8 config;\r\nret = mt312_reset(state, 1);\r\nif (ret < 0)\r\nreturn ret;\r\nif (state->id == ID_ZL10313) {\r\nret = mt312_writereg(state, GPP_CTRL, 0x00);\r\nif (ret < 0)\r\nreturn ret;\r\nret = mt312_writereg(state, HW_CTRL, 0x0d);\r\nif (ret < 0)\r\nreturn ret;\r\n}\r\nret = mt312_readreg(state, CONFIG, &config);\r\nif (ret < 0)\r\nreturn ret;\r\nret = mt312_writereg(state, CONFIG, config & 0x7f);\r\nif (ret < 0)\r\nreturn ret;\r\nreturn 0;\r\n}\r\nstatic int mt312_get_tune_settings(struct dvb_frontend *fe,\r\nstruct dvb_frontend_tune_settings *fesettings)\r\n{\r\nfesettings->min_delay_ms = 50;\r\nfesettings->step_size = 0;\r\nfesettings->max_drift = 0;\r\nreturn 0;\r\n}\r\nstatic void mt312_release(struct dvb_frontend *fe)\r\n{\r\nstruct mt312_state *state = fe->demodulator_priv;\r\nkfree(state);\r\n}\r\nstruct dvb_frontend *mt312_attach(const struct mt312_config *config,\r\nstruct i2c_adapter *i2c)\r\n{\r\nstruct mt312_state *state = NULL;\r\nstate = kzalloc(sizeof(struct mt312_state), GFP_KERNEL);\r\nif (state == NULL)\r\ngoto error;\r\nstate->config = config;\r\nstate->i2c = i2c;\r\nif (mt312_readreg(state, ID, &state->id) < 0)\r\ngoto error;\r\nmemcpy(&state->frontend.ops, &mt312_ops,\r\nsizeof(struct dvb_frontend_ops));\r\nstate->frontend.demodulator_priv = state;\r\nswitch (state->id) {\r\ncase ID_VP310:\r\nstrcpy(state->frontend.ops.info.name, "Zarlink VP310 DVB-S");\r\nstate->xtal = MT312_PLL_CLK;\r\nstate->freq_mult = 9;\r\nbreak;\r\ncase ID_MT312:\r\nstrcpy(state->frontend.ops.info.name, "Zarlink MT312 DVB-S");\r\nstate->xtal = MT312_PLL_CLK;\r\nstate->freq_mult = 6;\r\nbreak;\r\ncase ID_ZL10313:\r\nstrcpy(state->frontend.ops.info.name, "Zarlink ZL10313 DVB-S");\r\nstate->xtal = MT312_PLL_CLK_10_111;\r\nstate->freq_mult = 9;\r\nbreak;\r\ndefault:\r\nprintk(KERN_WARNING "Only Zarlink VP310/MT312/ZL10313"\r\n" are supported chips.\n");\r\ngoto error;\r\n}\r\nreturn &state->frontend;\r\nerror:\r\nkfree(state);\r\nreturn NULL;\r\n}
