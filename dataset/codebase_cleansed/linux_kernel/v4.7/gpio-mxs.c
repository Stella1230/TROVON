static inline int is_imx23_gpio(struct mxs_gpio_port *port)\r\n{\r\nreturn port->devid == IMX23_GPIO;\r\n}\r\nstatic inline int is_imx28_gpio(struct mxs_gpio_port *port)\r\n{\r\nreturn port->devid == IMX28_GPIO;\r\n}\r\nstatic int mxs_gpio_set_irq_type(struct irq_data *d, unsigned int type)\r\n{\r\nu32 val;\r\nu32 pin_mask = 1 << d->hwirq;\r\nstruct irq_chip_generic *gc = irq_data_get_irq_chip_data(d);\r\nstruct mxs_gpio_port *port = gc->private;\r\nvoid __iomem *pin_addr;\r\nint edge;\r\nport->both_edges &= ~pin_mask;\r\nswitch (type) {\r\ncase IRQ_TYPE_EDGE_BOTH:\r\nval = gpio_get_value(port->gc.base + d->hwirq);\r\nif (val)\r\nedge = GPIO_INT_FALL_EDGE;\r\nelse\r\nedge = GPIO_INT_RISE_EDGE;\r\nport->both_edges |= pin_mask;\r\nbreak;\r\ncase IRQ_TYPE_EDGE_RISING:\r\nedge = GPIO_INT_RISE_EDGE;\r\nbreak;\r\ncase IRQ_TYPE_EDGE_FALLING:\r\nedge = GPIO_INT_FALL_EDGE;\r\nbreak;\r\ncase IRQ_TYPE_LEVEL_LOW:\r\nedge = GPIO_INT_LOW_LEV;\r\nbreak;\r\ncase IRQ_TYPE_LEVEL_HIGH:\r\nedge = GPIO_INT_HIGH_LEV;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\npin_addr = port->base + PINCTRL_IRQLEV(port);\r\nif (edge & GPIO_INT_LEV_MASK)\r\nwritel(pin_mask, pin_addr + MXS_SET);\r\nelse\r\nwritel(pin_mask, pin_addr + MXS_CLR);\r\npin_addr = port->base + PINCTRL_IRQPOL(port);\r\nif (edge & GPIO_INT_POL_MASK)\r\nwritel(pin_mask, pin_addr + MXS_SET);\r\nelse\r\nwritel(pin_mask, pin_addr + MXS_CLR);\r\nwritel(pin_mask,\r\nport->base + PINCTRL_IRQSTAT(port) + MXS_CLR);\r\nreturn 0;\r\n}\r\nstatic void mxs_flip_edge(struct mxs_gpio_port *port, u32 gpio)\r\n{\r\nu32 bit, val, edge;\r\nvoid __iomem *pin_addr;\r\nbit = 1 << gpio;\r\npin_addr = port->base + PINCTRL_IRQPOL(port);\r\nval = readl(pin_addr);\r\nedge = val & bit;\r\nif (edge)\r\nwritel(bit, pin_addr + MXS_CLR);\r\nelse\r\nwritel(bit, pin_addr + MXS_SET);\r\n}\r\nstatic void mxs_gpio_irq_handler(struct irq_desc *desc)\r\n{\r\nu32 irq_stat;\r\nstruct mxs_gpio_port *port = irq_desc_get_handler_data(desc);\r\ndesc->irq_data.chip->irq_ack(&desc->irq_data);\r\nirq_stat = readl(port->base + PINCTRL_IRQSTAT(port)) &\r\nreadl(port->base + PINCTRL_IRQEN(port));\r\nwhile (irq_stat != 0) {\r\nint irqoffset = fls(irq_stat) - 1;\r\nif (port->both_edges & (1 << irqoffset))\r\nmxs_flip_edge(port, irqoffset);\r\ngeneric_handle_irq(irq_find_mapping(port->domain, irqoffset));\r\nirq_stat &= ~(1 << irqoffset);\r\n}\r\n}\r\nstatic int mxs_gpio_set_wake_irq(struct irq_data *d, unsigned int enable)\r\n{\r\nstruct irq_chip_generic *gc = irq_data_get_irq_chip_data(d);\r\nstruct mxs_gpio_port *port = gc->private;\r\nif (enable)\r\nenable_irq_wake(port->irq);\r\nelse\r\ndisable_irq_wake(port->irq);\r\nreturn 0;\r\n}\r\nstatic int __init mxs_gpio_init_gc(struct mxs_gpio_port *port, int irq_base)\r\n{\r\nstruct irq_chip_generic *gc;\r\nstruct irq_chip_type *ct;\r\ngc = irq_alloc_generic_chip("gpio-mxs", 1, irq_base,\r\nport->base, handle_level_irq);\r\nif (!gc)\r\nreturn -ENOMEM;\r\ngc->private = port;\r\nct = gc->chip_types;\r\nct->chip.irq_ack = irq_gc_ack_set_bit;\r\nct->chip.irq_mask = irq_gc_mask_clr_bit;\r\nct->chip.irq_unmask = irq_gc_mask_set_bit;\r\nct->chip.irq_set_type = mxs_gpio_set_irq_type;\r\nct->chip.irq_set_wake = mxs_gpio_set_wake_irq;\r\nct->regs.ack = PINCTRL_IRQSTAT(port) + MXS_CLR;\r\nct->regs.mask = PINCTRL_IRQEN(port);\r\nirq_setup_generic_chip(gc, IRQ_MSK(32), IRQ_GC_INIT_NESTED_LOCK,\r\nIRQ_NOREQUEST, 0);\r\nreturn 0;\r\n}\r\nstatic int mxs_gpio_to_irq(struct gpio_chip *gc, unsigned offset)\r\n{\r\nstruct mxs_gpio_port *port = gpiochip_get_data(gc);\r\nreturn irq_find_mapping(port->domain, offset);\r\n}\r\nstatic int mxs_gpio_get_direction(struct gpio_chip *gc, unsigned offset)\r\n{\r\nstruct mxs_gpio_port *port = gpiochip_get_data(gc);\r\nu32 mask = 1 << offset;\r\nu32 dir;\r\ndir = readl(port->base + PINCTRL_DOE(port));\r\nreturn !(dir & mask);\r\n}\r\nstatic int mxs_gpio_probe(struct platform_device *pdev)\r\n{\r\nconst struct of_device_id *of_id =\r\nof_match_device(mxs_gpio_dt_ids, &pdev->dev);\r\nstruct device_node *np = pdev->dev.of_node;\r\nstruct device_node *parent;\r\nstatic void __iomem *base;\r\nstruct mxs_gpio_port *port;\r\nint irq_base;\r\nint err;\r\nport = devm_kzalloc(&pdev->dev, sizeof(*port), GFP_KERNEL);\r\nif (!port)\r\nreturn -ENOMEM;\r\nport->id = of_alias_get_id(np, "gpio");\r\nif (port->id < 0)\r\nreturn port->id;\r\nport->devid = (enum mxs_gpio_id) of_id->data;\r\nport->irq = platform_get_irq(pdev, 0);\r\nif (port->irq < 0)\r\nreturn port->irq;\r\nif (!base) {\r\nparent = of_get_parent(np);\r\nbase = of_iomap(parent, 0);\r\nof_node_put(parent);\r\nif (!base)\r\nreturn -EADDRNOTAVAIL;\r\n}\r\nport->base = base;\r\nwritel(~0U, port->base + PINCTRL_PIN2IRQ(port));\r\nwritel(0, port->base + PINCTRL_IRQEN(port));\r\nwritel(~0U, port->base + PINCTRL_IRQSTAT(port) + MXS_CLR);\r\nirq_base = irq_alloc_descs(-1, 0, 32, numa_node_id());\r\nif (irq_base < 0)\r\nreturn irq_base;\r\nport->domain = irq_domain_add_legacy(np, 32, irq_base, 0,\r\n&irq_domain_simple_ops, NULL);\r\nif (!port->domain) {\r\nerr = -ENODEV;\r\ngoto out_irqdesc_free;\r\n}\r\nerr = mxs_gpio_init_gc(port, irq_base);\r\nif (err < 0)\r\ngoto out_irqdomain_remove;\r\nirq_set_chained_handler_and_data(port->irq, mxs_gpio_irq_handler,\r\nport);\r\nerr = bgpio_init(&port->gc, &pdev->dev, 4,\r\nport->base + PINCTRL_DIN(port),\r\nport->base + PINCTRL_DOUT(port) + MXS_SET,\r\nport->base + PINCTRL_DOUT(port) + MXS_CLR,\r\nport->base + PINCTRL_DOE(port), NULL, 0);\r\nif (err)\r\ngoto out_irqdomain_remove;\r\nport->gc.to_irq = mxs_gpio_to_irq;\r\nport->gc.get_direction = mxs_gpio_get_direction;\r\nport->gc.base = port->id * 32;\r\nerr = gpiochip_add_data(&port->gc, port);\r\nif (err)\r\ngoto out_irqdomain_remove;\r\nreturn 0;\r\nout_irqdomain_remove:\r\nirq_domain_remove(port->domain);\r\nout_irqdesc_free:\r\nirq_free_descs(irq_base, 32);\r\nreturn err;\r\n}\r\nstatic int __init mxs_gpio_init(void)\r\n{\r\nreturn platform_driver_register(&mxs_gpio_driver);\r\n}
