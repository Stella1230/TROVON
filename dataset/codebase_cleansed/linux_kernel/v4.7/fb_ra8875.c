static int write_spi(struct fbtft_par *par, void *buf, size_t len)\r\n{\r\nstruct spi_transfer t = {\r\n.tx_buf = buf,\r\n.len = len,\r\n.speed_hz = 1000000,\r\n};\r\nstruct spi_message m;\r\nfbtft_par_dbg_hex(DEBUG_WRITE, par, par->info->device, u8, buf, len,\r\n"%s(len=%d): ", __func__, len);\r\nif (!par->spi) {\r\ndev_err(par->info->device,\r\n"%s: par->spi is unexpectedly NULL\n", __func__);\r\nreturn -1;\r\n}\r\nspi_message_init(&m);\r\nif (par->txbuf.dma && buf == par->txbuf.buf) {\r\nt.tx_dma = par->txbuf.dma;\r\nm.is_dma_mapped = 1;\r\n}\r\nspi_message_add_tail(&t, &m);\r\nreturn spi_sync(par->spi, &m);\r\n}\r\nstatic int init_display(struct fbtft_par *par)\r\n{\r\ngpio_set_value(par->gpio.dc, 1);\r\nfbtft_par_dbg(DEBUG_INIT_DISPLAY, par,\r\n"%s()\n", __func__);\r\nfbtft_par_dbg(DEBUG_INIT_DISPLAY, par,\r\n"display size %dx%d\n",\r\npar->info->var.xres,\r\npar->info->var.yres);\r\npar->fbtftops.reset(par);\r\nif ((par->info->var.xres == 320) && (par->info->var.yres == 240)) {\r\nwrite_reg(par, 0x88, 0x0A);\r\nwrite_reg(par, 0x89, 0x02);\r\nmdelay(10);\r\nwrite_reg(par, 0x10, 0x0C);\r\nwrite_reg(par, 0x04, 0x03);\r\nmdelay(1);\r\nwrite_reg(par, 0x14, 0x27);\r\nwrite_reg(par, 0x15, 0x00);\r\nwrite_reg(par, 0x16, 0x05);\r\nwrite_reg(par, 0x17, 0x04);\r\nwrite_reg(par, 0x18, 0x03);\r\nwrite_reg(par, 0x19, 0xEF);\r\nwrite_reg(par, 0x1A, 0x00);\r\nwrite_reg(par, 0x1B, 0x05);\r\nwrite_reg(par, 0x1C, 0x00);\r\nwrite_reg(par, 0x1D, 0x0E);\r\nwrite_reg(par, 0x1E, 0x00);\r\nwrite_reg(par, 0x1F, 0x02);\r\n} else if ((par->info->var.xres == 480) &&\r\n(par->info->var.yres == 272)) {\r\nwrite_reg(par, 0x88, 0x0A);\r\nwrite_reg(par, 0x89, 0x02);\r\nmdelay(10);\r\nwrite_reg(par, 0x10, 0x0C);\r\nwrite_reg(par, 0x04, 0x82);\r\nmdelay(1);\r\nwrite_reg(par, 0x14, 0x3B);\r\nwrite_reg(par, 0x15, 0x00);\r\nwrite_reg(par, 0x16, 0x01);\r\nwrite_reg(par, 0x17, 0x00);\r\nwrite_reg(par, 0x18, 0x05);\r\nwrite_reg(par, 0x19, 0x0F);\r\nwrite_reg(par, 0x1A, 0x01);\r\nwrite_reg(par, 0x1B, 0x02);\r\nwrite_reg(par, 0x1C, 0x00);\r\nwrite_reg(par, 0x1D, 0x07);\r\nwrite_reg(par, 0x1E, 0x00);\r\nwrite_reg(par, 0x1F, 0x09);\r\n} else if ((par->info->var.xres == 640) &&\r\n(par->info->var.yres == 480)) {\r\nwrite_reg(par, 0x88, 0x0B);\r\nwrite_reg(par, 0x89, 0x02);\r\nmdelay(10);\r\nwrite_reg(par, 0x10, 0x0C);\r\nwrite_reg(par, 0x04, 0x01);\r\nmdelay(1);\r\nwrite_reg(par, 0x14, 0x4F);\r\nwrite_reg(par, 0x15, 0x05);\r\nwrite_reg(par, 0x16, 0x0F);\r\nwrite_reg(par, 0x17, 0x01);\r\nwrite_reg(par, 0x18, 0x00);\r\nwrite_reg(par, 0x19, 0xDF);\r\nwrite_reg(par, 0x1A, 0x01);\r\nwrite_reg(par, 0x1B, 0x0A);\r\nwrite_reg(par, 0x1C, 0x00);\r\nwrite_reg(par, 0x1D, 0x0E);\r\nwrite_reg(par, 0x1E, 0x00);\r\nwrite_reg(par, 0x1F, 0x01);\r\n} else if ((par->info->var.xres == 800) &&\r\n(par->info->var.yres == 480)) {\r\nwrite_reg(par, 0x88, 0x0B);\r\nwrite_reg(par, 0x89, 0x02);\r\nmdelay(10);\r\nwrite_reg(par, 0x10, 0x0C);\r\nwrite_reg(par, 0x04, 0x81);\r\nmdelay(1);\r\nwrite_reg(par, 0x14, 0x63);\r\nwrite_reg(par, 0x15, 0x03);\r\nwrite_reg(par, 0x16, 0x03);\r\nwrite_reg(par, 0x17, 0x02);\r\nwrite_reg(par, 0x18, 0x00);\r\nwrite_reg(par, 0x19, 0xDF);\r\nwrite_reg(par, 0x1A, 0x01);\r\nwrite_reg(par, 0x1B, 0x14);\r\nwrite_reg(par, 0x1C, 0x00);\r\nwrite_reg(par, 0x1D, 0x06);\r\nwrite_reg(par, 0x1E, 0x00);\r\nwrite_reg(par, 0x1F, 0x01);\r\n} else {\r\ndev_err(par->info->device, "display size is not supported!!");\r\nreturn -1;\r\n}\r\nwrite_reg(par, 0x8a, 0x81);\r\nwrite_reg(par, 0x8b, 0xFF);\r\nmdelay(10);\r\nwrite_reg(par, 0x01, 0x80);\r\nmdelay(10);\r\nreturn 0;\r\n}\r\nstatic void set_addr_win(struct fbtft_par *par, int xs, int ys, int xe, int ye)\r\n{\r\nwrite_reg(par, 0x30, xs & 0x00FF);\r\nwrite_reg(par, 0x31, (xs & 0xFF00) >> 8);\r\nwrite_reg(par, 0x32, ys & 0x00FF);\r\nwrite_reg(par, 0x33, (ys & 0xFF00) >> 8);\r\nwrite_reg(par, 0x34, (xs + xe) & 0x00FF);\r\nwrite_reg(par, 0x35, ((xs + xe) & 0xFF00) >> 8);\r\nwrite_reg(par, 0x36, (ys + ye) & 0x00FF);\r\nwrite_reg(par, 0x37, ((ys + ye) & 0xFF00) >> 8);\r\nwrite_reg(par, 0x46, xs & 0xff);\r\nwrite_reg(par, 0x47, (xs >> 8) & 0x03);\r\nwrite_reg(par, 0x48, ys & 0xff);\r\nwrite_reg(par, 0x49, (ys >> 8) & 0x01);\r\nwrite_reg(par, 0x02);\r\n}\r\nstatic void write_reg8_bus8(struct fbtft_par *par, int len, ...)\r\n{\r\nva_list args;\r\nint i, ret;\r\nu8 *buf = par->buf;\r\npar->fbtftops.write = write_spi;\r\nif (unlikely(par->debug & DEBUG_WRITE_REGISTER)) {\r\nva_start(args, len);\r\nfor (i = 0; i < len; i++)\r\nbuf[i] = (u8)va_arg(args, unsigned int);\r\nva_end(args);\r\nfbtft_par_dbg_hex(DEBUG_WRITE_REGISTER, par, par->info->device,\r\nu8, buf, len, "%s: ", __func__);\r\n}\r\nva_start(args, len);\r\n*buf++ = 0x80;\r\n*buf = (u8)va_arg(args, unsigned int);\r\nret = par->fbtftops.write(par, par->buf, 2);\r\nif (ret < 0) {\r\nva_end(args);\r\ndev_err(par->info->device, "write() failed and returned %dn",\r\nret);\r\nreturn;\r\n}\r\nlen--;\r\nudelay(100);\r\nif (len) {\r\nbuf = (u8 *)par->buf;\r\n*buf++ = 0x00;\r\ni = len;\r\nwhile (i--)\r\n*buf++ = (u8)va_arg(args, unsigned int);\r\nret = par->fbtftops.write(par, par->buf, len + 1);\r\nif (ret < 0) {\r\nva_end(args);\r\ndev_err(par->info->device,\r\n"write() failed and returned %dn", ret);\r\nreturn;\r\n}\r\n}\r\nva_end(args);\r\npar->fbtftops.write = fbtft_write_spi;\r\nudelay(100);\r\n}\r\nstatic int write_vmem16_bus8(struct fbtft_par *par, size_t offset, size_t len)\r\n{\r\nu16 *vmem16;\r\nu16 *txbuf16 = par->txbuf.buf;\r\nsize_t remain;\r\nsize_t to_copy;\r\nsize_t tx_array_size;\r\nint i;\r\nint ret = 0;\r\nsize_t startbyte_size = 0;\r\nfbtft_par_dbg(DEBUG_WRITE_VMEM, par, "%s(offset=%zu, len=%zu)\n",\r\n__func__, offset, len);\r\nremain = len / 2;\r\nvmem16 = (u16 *)(par->info->screen_buffer + offset);\r\ntx_array_size = par->txbuf.len / 2;\r\ntxbuf16 = par->txbuf.buf + 1;\r\ntx_array_size -= 2;\r\n*(u8 *)(par->txbuf.buf) = 0x00;\r\nstartbyte_size = 1;\r\nwhile (remain) {\r\nto_copy = min(tx_array_size, remain);\r\ndev_dbg(par->info->device, " to_copy=%zu, remain=%zu\n",\r\nto_copy, remain - to_copy);\r\nfor (i = 0; i < to_copy; i++)\r\ntxbuf16[i] = cpu_to_be16(vmem16[i]);\r\nvmem16 = vmem16 + to_copy;\r\nret = par->fbtftops.write(par, par->txbuf.buf,\r\nstartbyte_size + to_copy * 2);\r\nif (ret < 0)\r\nreturn ret;\r\nremain -= to_copy;\r\n}\r\nreturn ret;\r\n}
