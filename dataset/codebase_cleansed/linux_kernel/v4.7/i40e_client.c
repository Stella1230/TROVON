static\r\nenum i40e_vsi_type i40e_client_type_to_vsi_type(enum i40e_client_type type)\r\n{\r\nswitch (type) {\r\ncase I40E_CLIENT_IWARP:\r\nreturn I40E_VSI_IWARP;\r\ncase I40E_CLIENT_VMDQ2:\r\nreturn I40E_VSI_VMDQ2;\r\ndefault:\r\npr_err("i40e: Client type unknown\n");\r\nreturn I40E_VSI_TYPE_UNKNOWN;\r\n}\r\n}\r\nstatic\r\nint i40e_client_get_params(struct i40e_vsi *vsi, struct i40e_params *params)\r\n{\r\nstruct i40e_dcbx_config *dcb_cfg = &vsi->back->hw.local_dcbx_config;\r\nint i = 0;\r\nfor (i = 0; i < I40E_MAX_USER_PRIORITY; i++) {\r\nu8 tc = dcb_cfg->etscfg.prioritytable[i];\r\nu16 qs_handle;\r\nif (!(vsi->tc_config.enabled_tc & BIT(tc)))\r\ntc = 0;\r\nqs_handle = le16_to_cpu(vsi->info.qs_handle[tc]);\r\nparams->qos.prio_qos[i].tc = tc;\r\nparams->qos.prio_qos[i].qs_handle = qs_handle;\r\nif (qs_handle == I40E_AQ_VSI_QS_HANDLE_INVALID) {\r\ndev_err(&vsi->back->pdev->dev, "Invalid queue set handle for TC = %d, vsi id = %d\n",\r\ntc, vsi->id);\r\nreturn -EINVAL;\r\n}\r\n}\r\nparams->mtu = vsi->netdev->mtu;\r\nreturn 0;\r\n}\r\nvoid\r\ni40e_notify_client_of_vf_msg(struct i40e_vsi *vsi, u32 vf_id, u8 *msg, u16 len)\r\n{\r\nstruct i40e_client_instance *cdev;\r\nif (!vsi)\r\nreturn;\r\nmutex_lock(&i40e_client_instance_mutex);\r\nlist_for_each_entry(cdev, &i40e_client_instances, list) {\r\nif (cdev->lan_info.pf == vsi->back) {\r\nif (!cdev->client ||\r\n!cdev->client->ops ||\r\n!cdev->client->ops->virtchnl_receive) {\r\ndev_dbg(&vsi->back->pdev->dev,\r\n"Cannot locate client instance virtual channel receive routine\n");\r\ncontinue;\r\n}\r\ncdev->client->ops->virtchnl_receive(&cdev->lan_info,\r\ncdev->client,\r\nvf_id, msg, len);\r\n}\r\n}\r\nmutex_unlock(&i40e_client_instance_mutex);\r\n}\r\nvoid i40e_notify_client_of_l2_param_changes(struct i40e_vsi *vsi)\r\n{\r\nstruct i40e_client_instance *cdev;\r\nstruct i40e_params params;\r\nif (!vsi)\r\nreturn;\r\nmemset(&params, 0, sizeof(params));\r\ni40e_client_get_params(vsi, &params);\r\nmutex_lock(&i40e_client_instance_mutex);\r\nlist_for_each_entry(cdev, &i40e_client_instances, list) {\r\nif (cdev->lan_info.pf == vsi->back) {\r\nif (!cdev->client ||\r\n!cdev->client->ops ||\r\n!cdev->client->ops->l2_param_change) {\r\ndev_dbg(&vsi->back->pdev->dev,\r\n"Cannot locate client instance l2_param_change routine\n");\r\ncontinue;\r\n}\r\ncdev->lan_info.params = params;\r\ncdev->client->ops->l2_param_change(&cdev->lan_info,\r\ncdev->client,\r\n&params);\r\n}\r\n}\r\nmutex_unlock(&i40e_client_instance_mutex);\r\n}\r\nvoid i40e_notify_client_of_netdev_open(struct i40e_vsi *vsi)\r\n{\r\nstruct i40e_client_instance *cdev;\r\nif (!vsi)\r\nreturn;\r\nmutex_lock(&i40e_client_instance_mutex);\r\nlist_for_each_entry(cdev, &i40e_client_instances, list) {\r\nif (cdev->lan_info.netdev == vsi->netdev) {\r\nif (!cdev->client ||\r\n!cdev->client->ops || !cdev->client->ops->open) {\r\ndev_dbg(&vsi->back->pdev->dev,\r\n"Cannot locate client instance open routine\n");\r\ncontinue;\r\n}\r\ncdev->client->ops->open(&cdev->lan_info, cdev->client);\r\n}\r\n}\r\nmutex_unlock(&i40e_client_instance_mutex);\r\n}\r\nstatic void i40e_client_release_qvlist(struct i40e_info *ldev)\r\n{\r\nstruct i40e_qvlist_info *qvlist_info = ldev->qvlist_info;\r\nu32 i;\r\nif (!ldev->qvlist_info)\r\nreturn;\r\nfor (i = 0; i < qvlist_info->num_vectors; i++) {\r\nstruct i40e_pf *pf = ldev->pf;\r\nstruct i40e_qv_info *qv_info;\r\nu32 reg_idx;\r\nqv_info = &qvlist_info->qv_info[i];\r\nif (!qv_info)\r\ncontinue;\r\nreg_idx = I40E_PFINT_LNKLSTN(qv_info->v_idx - 1);\r\nwr32(&pf->hw, reg_idx, I40E_PFINT_LNKLSTN_FIRSTQ_INDX_MASK);\r\n}\r\nkfree(ldev->qvlist_info);\r\nldev->qvlist_info = NULL;\r\n}\r\nvoid i40e_notify_client_of_netdev_close(struct i40e_vsi *vsi, bool reset)\r\n{\r\nstruct i40e_client_instance *cdev;\r\nif (!vsi)\r\nreturn;\r\nmutex_lock(&i40e_client_instance_mutex);\r\nlist_for_each_entry(cdev, &i40e_client_instances, list) {\r\nif (cdev->lan_info.netdev == vsi->netdev) {\r\nif (!cdev->client ||\r\n!cdev->client->ops || !cdev->client->ops->close) {\r\ndev_dbg(&vsi->back->pdev->dev,\r\n"Cannot locate client instance close routine\n");\r\ncontinue;\r\n}\r\ncdev->client->ops->close(&cdev->lan_info, cdev->client,\r\nreset);\r\ni40e_client_release_qvlist(&cdev->lan_info);\r\n}\r\n}\r\nmutex_unlock(&i40e_client_instance_mutex);\r\n}\r\nvoid i40e_notify_client_of_vf_reset(struct i40e_pf *pf, u32 vf_id)\r\n{\r\nstruct i40e_client_instance *cdev;\r\nif (!pf)\r\nreturn;\r\nmutex_lock(&i40e_client_instance_mutex);\r\nlist_for_each_entry(cdev, &i40e_client_instances, list) {\r\nif (cdev->lan_info.pf == pf) {\r\nif (!cdev->client ||\r\n!cdev->client->ops ||\r\n!cdev->client->ops->vf_reset) {\r\ndev_dbg(&pf->pdev->dev,\r\n"Cannot locate client instance VF reset routine\n");\r\ncontinue;\r\n}\r\ncdev->client->ops->vf_reset(&cdev->lan_info,\r\ncdev->client, vf_id);\r\n}\r\n}\r\nmutex_unlock(&i40e_client_instance_mutex);\r\n}\r\nvoid i40e_notify_client_of_vf_enable(struct i40e_pf *pf, u32 num_vfs)\r\n{\r\nstruct i40e_client_instance *cdev;\r\nif (!pf)\r\nreturn;\r\nmutex_lock(&i40e_client_instance_mutex);\r\nlist_for_each_entry(cdev, &i40e_client_instances, list) {\r\nif (cdev->lan_info.pf == pf) {\r\nif (!cdev->client ||\r\n!cdev->client->ops ||\r\n!cdev->client->ops->vf_enable) {\r\ndev_dbg(&pf->pdev->dev,\r\n"Cannot locate client instance VF enable routine\n");\r\ncontinue;\r\n}\r\ncdev->client->ops->vf_enable(&cdev->lan_info,\r\ncdev->client, num_vfs);\r\n}\r\n}\r\nmutex_unlock(&i40e_client_instance_mutex);\r\n}\r\nint i40e_vf_client_capable(struct i40e_pf *pf, u32 vf_id,\r\nenum i40e_client_type type)\r\n{\r\nstruct i40e_client_instance *cdev;\r\nint capable = false;\r\nif (!pf)\r\nreturn false;\r\nmutex_lock(&i40e_client_instance_mutex);\r\nlist_for_each_entry(cdev, &i40e_client_instances, list) {\r\nif (cdev->lan_info.pf == pf) {\r\nif (!cdev->client ||\r\n!cdev->client->ops ||\r\n!cdev->client->ops->vf_capable ||\r\n!(cdev->client->type == type)) {\r\ndev_dbg(&pf->pdev->dev,\r\n"Cannot locate client instance VF capability routine\n");\r\ncontinue;\r\n}\r\ncapable = cdev->client->ops->vf_capable(&cdev->lan_info,\r\ncdev->client,\r\nvf_id);\r\nbreak;\r\n}\r\n}\r\nmutex_unlock(&i40e_client_instance_mutex);\r\nreturn capable;\r\n}\r\nstruct i40e_vsi *i40e_vsi_lookup(struct i40e_pf *pf,\r\nenum i40e_vsi_type type,\r\nstruct i40e_vsi *start_vsi)\r\n{\r\nstruct i40e_vsi *vsi;\r\nint i = 0;\r\nif (start_vsi) {\r\nfor (i = 0; i < pf->num_alloc_vsi; i++) {\r\nvsi = pf->vsi[i];\r\nif (vsi == start_vsi)\r\nbreak;\r\n}\r\n}\r\nfor (; i < pf->num_alloc_vsi; i++) {\r\nvsi = pf->vsi[i];\r\nif (vsi && vsi->type == type)\r\nreturn vsi;\r\n}\r\nreturn NULL;\r\n}\r\nstatic\r\nstruct i40e_client_instance *i40e_client_add_instance(struct i40e_pf *pf,\r\nstruct i40e_client *client)\r\n{\r\nstruct i40e_client_instance *cdev;\r\nstruct netdev_hw_addr *mac = NULL;\r\nstruct i40e_vsi *vsi = pf->vsi[pf->lan_vsi];\r\nmutex_lock(&i40e_client_instance_mutex);\r\nlist_for_each_entry(cdev, &i40e_client_instances, list) {\r\nif ((cdev->lan_info.pf == pf) && (cdev->client == client)) {\r\ncdev = NULL;\r\ngoto out;\r\n}\r\n}\r\ncdev = kzalloc(sizeof(*cdev), GFP_KERNEL);\r\nif (!cdev)\r\ngoto out;\r\ncdev->lan_info.pf = (void *)pf;\r\ncdev->lan_info.netdev = vsi->netdev;\r\ncdev->lan_info.pcidev = pf->pdev;\r\ncdev->lan_info.fid = pf->hw.pf_id;\r\ncdev->lan_info.ftype = I40E_CLIENT_FTYPE_PF;\r\ncdev->lan_info.hw_addr = pf->hw.hw_addr;\r\ncdev->lan_info.ops = &i40e_lan_ops;\r\ncdev->lan_info.version.major = I40E_CLIENT_VERSION_MAJOR;\r\ncdev->lan_info.version.minor = I40E_CLIENT_VERSION_MINOR;\r\ncdev->lan_info.version.build = I40E_CLIENT_VERSION_BUILD;\r\ncdev->lan_info.fw_maj_ver = pf->hw.aq.fw_maj_ver;\r\ncdev->lan_info.fw_min_ver = pf->hw.aq.fw_min_ver;\r\ncdev->lan_info.fw_build = pf->hw.aq.fw_build;\r\nset_bit(__I40E_CLIENT_INSTANCE_NONE, &cdev->state);\r\nif (i40e_client_get_params(vsi, &cdev->lan_info.params)) {\r\nkfree(cdev);\r\ncdev = NULL;\r\ngoto out;\r\n}\r\ncdev->lan_info.msix_count = pf->num_iwarp_msix;\r\ncdev->lan_info.msix_entries = &pf->msix_entries[pf->iwarp_base_vector];\r\nmac = list_first_entry(&cdev->lan_info.netdev->dev_addrs.list,\r\nstruct netdev_hw_addr, list);\r\nif (mac)\r\nether_addr_copy(cdev->lan_info.lanmac, mac->addr);\r\nelse\r\ndev_err(&pf->pdev->dev, "MAC address list is empty!\n");\r\ncdev->client = client;\r\nINIT_LIST_HEAD(&cdev->list);\r\nlist_add(&cdev->list, &i40e_client_instances);\r\nout:\r\nmutex_unlock(&i40e_client_instance_mutex);\r\nreturn cdev;\r\n}\r\nstatic\r\nint i40e_client_del_instance(struct i40e_pf *pf, struct i40e_client *client)\r\n{\r\nstruct i40e_client_instance *cdev, *tmp;\r\nint ret = -ENODEV;\r\nmutex_lock(&i40e_client_instance_mutex);\r\nlist_for_each_entry_safe(cdev, tmp, &i40e_client_instances, list) {\r\nif ((cdev->lan_info.pf != pf) || (cdev->client != client))\r\ncontinue;\r\ndev_info(&pf->pdev->dev, "Deleted instance of Client %s, of dev %d bus=0x%02x func=0x%02x)\n",\r\nclient->name, pf->hw.pf_id,\r\npf->hw.bus.device, pf->hw.bus.func);\r\nlist_del(&cdev->list);\r\nkfree(cdev);\r\nret = 0;\r\nbreak;\r\n}\r\nmutex_unlock(&i40e_client_instance_mutex);\r\nreturn ret;\r\n}\r\nvoid i40e_client_subtask(struct i40e_pf *pf)\r\n{\r\nstruct i40e_client_instance *cdev;\r\nstruct i40e_client *client;\r\nint ret = 0;\r\nif (!(pf->flags & I40E_FLAG_SERVICE_CLIENT_REQUESTED))\r\nreturn;\r\npf->flags &= ~I40E_FLAG_SERVICE_CLIENT_REQUESTED;\r\nif (test_bit(__I40E_DOWN, &pf->state) ||\r\ntest_bit(__I40E_CONFIG_BUSY, &pf->state))\r\nreturn;\r\nmutex_lock(&i40e_client_mutex);\r\nlist_for_each_entry(client, &i40e_clients, list) {\r\nif (!test_bit(__I40E_CLIENT_REGISTERED, &client->state))\r\ncontinue;\r\nif (!(client->flags & I40E_CLIENT_FLAGS_LAUNCH_ON_PROBE)) {\r\nif (test_bit(__I40E_DOWN, &pf->vsi[pf->lan_vsi]->state))\r\ncontinue;\r\n}\r\ncdev = i40e_client_add_instance(pf, client);\r\nif (!cdev)\r\ncontinue;\r\natomic_inc(&client->ref_cnt);\r\ndev_info(&pf->pdev->dev, "Added instance of Client %s to PF%d bus=0x%02x func=0x%02x\n",\r\nclient->name, pf->hw.pf_id,\r\npf->hw.bus.device, pf->hw.bus.func);\r\natomic_inc(&cdev->ref_cnt);\r\nif (client->ops && client->ops->open)\r\nret = client->ops->open(&cdev->lan_info, client);\r\natomic_dec(&cdev->ref_cnt);\r\nif (!ret) {\r\nset_bit(__I40E_CLIENT_INSTANCE_OPENED, &cdev->state);\r\n} else {\r\ni40e_client_del_instance(pf, client);\r\natomic_dec(&client->ref_cnt);\r\ncontinue;\r\n}\r\n}\r\nmutex_unlock(&i40e_client_mutex);\r\n}\r\nint i40e_lan_add_device(struct i40e_pf *pf)\r\n{\r\nstruct i40e_device *ldev;\r\nint ret = 0;\r\nmutex_lock(&i40e_device_mutex);\r\nlist_for_each_entry(ldev, &i40e_devices, list) {\r\nif (ldev->pf == pf) {\r\nret = -EEXIST;\r\ngoto out;\r\n}\r\n}\r\nldev = kzalloc(sizeof(*ldev), GFP_KERNEL);\r\nif (!ldev) {\r\nret = -ENOMEM;\r\ngoto out;\r\n}\r\nldev->pf = pf;\r\nINIT_LIST_HEAD(&ldev->list);\r\nlist_add(&ldev->list, &i40e_devices);\r\ndev_info(&pf->pdev->dev, "Added LAN device PF%d bus=0x%02x func=0x%02x\n",\r\npf->hw.pf_id, pf->hw.bus.device, pf->hw.bus.func);\r\npf->flags |= I40E_FLAG_SERVICE_CLIENT_REQUESTED;\r\ni40e_service_event_schedule(pf);\r\nout:\r\nmutex_unlock(&i40e_device_mutex);\r\nreturn ret;\r\n}\r\nint i40e_lan_del_device(struct i40e_pf *pf)\r\n{\r\nstruct i40e_device *ldev, *tmp;\r\nint ret = -ENODEV;\r\nmutex_lock(&i40e_device_mutex);\r\nlist_for_each_entry_safe(ldev, tmp, &i40e_devices, list) {\r\nif (ldev->pf == pf) {\r\ndev_info(&pf->pdev->dev, "Deleted LAN device PF%d bus=0x%02x func=0x%02x\n",\r\npf->hw.pf_id, pf->hw.bus.device,\r\npf->hw.bus.func);\r\nlist_del(&ldev->list);\r\nkfree(ldev);\r\nret = 0;\r\nbreak;\r\n}\r\n}\r\nmutex_unlock(&i40e_device_mutex);\r\nreturn ret;\r\n}\r\nstatic int i40e_client_release(struct i40e_client *client)\r\n{\r\nstruct i40e_client_instance *cdev, *tmp;\r\nstruct i40e_pf *pf = NULL;\r\nint ret = 0;\r\nLIST_HEAD(cdevs_tmp);\r\nmutex_lock(&i40e_client_instance_mutex);\r\nlist_for_each_entry_safe(cdev, tmp, &i40e_client_instances, list) {\r\nif (strncmp(cdev->client->name, client->name,\r\nI40E_CLIENT_STR_LENGTH))\r\ncontinue;\r\nif (test_bit(__I40E_CLIENT_INSTANCE_OPENED, &cdev->state)) {\r\nif (atomic_read(&cdev->ref_cnt) > 0) {\r\nret = I40E_ERR_NOT_READY;\r\ngoto out;\r\n}\r\npf = (struct i40e_pf *)cdev->lan_info.pf;\r\nif (client->ops && client->ops->close)\r\nclient->ops->close(&cdev->lan_info, client,\r\nfalse);\r\ni40e_client_release_qvlist(&cdev->lan_info);\r\nclear_bit(__I40E_CLIENT_INSTANCE_OPENED, &cdev->state);\r\ndev_warn(&pf->pdev->dev,\r\n"Client %s instance for PF id %d closed\n",\r\nclient->name, pf->hw.pf_id);\r\n}\r\nlist_del(&cdev->list);\r\nlist_add(&cdev->list, &cdevs_tmp);\r\natomic_dec(&client->ref_cnt);\r\ndev_info(&pf->pdev->dev, "Deleted client instance of Client %s\n",\r\nclient->name);\r\n}\r\nout:\r\nmutex_unlock(&i40e_client_instance_mutex);\r\nlist_for_each_entry_safe(cdev, tmp, &cdevs_tmp, list) {\r\nkfree(cdev);\r\n}\r\nreturn ret;\r\n}\r\nstatic int i40e_client_prepare(struct i40e_client *client)\r\n{\r\nstruct i40e_device *ldev;\r\nstruct i40e_pf *pf;\r\nint ret = 0;\r\nmutex_lock(&i40e_device_mutex);\r\nlist_for_each_entry(ldev, &i40e_devices, list) {\r\npf = ldev->pf;\r\npf->flags |= I40E_FLAG_SERVICE_CLIENT_REQUESTED;\r\ni40e_service_event_schedule(pf);\r\n}\r\nmutex_unlock(&i40e_device_mutex);\r\nreturn ret;\r\n}\r\nstatic int i40e_client_virtchnl_send(struct i40e_info *ldev,\r\nstruct i40e_client *client,\r\nu32 vf_id, u8 *msg, u16 len)\r\n{\r\nstruct i40e_pf *pf = ldev->pf;\r\nstruct i40e_hw *hw = &pf->hw;\r\ni40e_status err;\r\nerr = i40e_aq_send_msg_to_vf(hw, vf_id, I40E_VIRTCHNL_OP_IWARP,\r\n0, msg, len, NULL);\r\nif (err)\r\ndev_err(&pf->pdev->dev, "Unable to send iWarp message to VF, error %d, aq status %d\n",\r\nerr, hw->aq.asq_last_status);\r\nreturn err;\r\n}\r\nstatic int i40e_client_setup_qvlist(struct i40e_info *ldev,\r\nstruct i40e_client *client,\r\nstruct i40e_qvlist_info *qvlist_info)\r\n{\r\nstruct i40e_pf *pf = ldev->pf;\r\nstruct i40e_hw *hw = &pf->hw;\r\nstruct i40e_qv_info *qv_info;\r\nu32 v_idx, i, reg_idx, reg;\r\nu32 size;\r\nsize = sizeof(struct i40e_qvlist_info) +\r\n(sizeof(struct i40e_qv_info) * (qvlist_info->num_vectors - 1));\r\nldev->qvlist_info = kzalloc(size, GFP_KERNEL);\r\nldev->qvlist_info->num_vectors = qvlist_info->num_vectors;\r\nfor (i = 0; i < qvlist_info->num_vectors; i++) {\r\nqv_info = &qvlist_info->qv_info[i];\r\nif (!qv_info)\r\ncontinue;\r\nv_idx = qv_info->v_idx;\r\nif ((v_idx >= (pf->iwarp_base_vector + pf->num_iwarp_msix)) ||\r\n(v_idx < pf->iwarp_base_vector))\r\ngoto err;\r\nldev->qvlist_info->qv_info[i] = *qv_info;\r\nreg_idx = I40E_PFINT_LNKLSTN(v_idx - 1);\r\nif (qv_info->ceq_idx == I40E_QUEUE_INVALID_IDX) {\r\nwr32(hw, reg_idx, I40E_PFINT_LNKLSTN_FIRSTQ_INDX_MASK);\r\n} else {\r\nreg = (qv_info->ceq_idx &\r\nI40E_PFINT_LNKLSTN_FIRSTQ_INDX_MASK) |\r\n(I40E_QUEUE_TYPE_PE_CEQ <<\r\nI40E_PFINT_LNKLSTN_FIRSTQ_TYPE_SHIFT);\r\nwr32(hw, reg_idx, reg);\r\nreg = (I40E_PFINT_CEQCTL_CAUSE_ENA_MASK |\r\n(v_idx << I40E_PFINT_CEQCTL_MSIX_INDX_SHIFT) |\r\n(qv_info->itr_idx <<\r\nI40E_PFINT_CEQCTL_ITR_INDX_SHIFT) |\r\n(I40E_QUEUE_END_OF_LIST <<\r\nI40E_PFINT_CEQCTL_NEXTQ_INDX_SHIFT));\r\nwr32(hw, I40E_PFINT_CEQCTL(qv_info->ceq_idx), reg);\r\n}\r\nif (qv_info->aeq_idx != I40E_QUEUE_INVALID_IDX) {\r\nreg = (I40E_PFINT_AEQCTL_CAUSE_ENA_MASK |\r\n(v_idx << I40E_PFINT_AEQCTL_MSIX_INDX_SHIFT) |\r\n(qv_info->itr_idx <<\r\nI40E_PFINT_AEQCTL_ITR_INDX_SHIFT));\r\nwr32(hw, I40E_PFINT_AEQCTL, reg);\r\n}\r\n}\r\nreturn 0;\r\nerr:\r\nkfree(ldev->qvlist_info);\r\nldev->qvlist_info = NULL;\r\nreturn -EINVAL;\r\n}\r\nstatic void i40e_client_request_reset(struct i40e_info *ldev,\r\nstruct i40e_client *client,\r\nu32 reset_level)\r\n{\r\nstruct i40e_pf *pf = ldev->pf;\r\nswitch (reset_level) {\r\ncase I40E_CLIENT_RESET_LEVEL_PF:\r\nset_bit(__I40E_PF_RESET_REQUESTED, &pf->state);\r\nbreak;\r\ncase I40E_CLIENT_RESET_LEVEL_CORE:\r\nset_bit(__I40E_PF_RESET_REQUESTED, &pf->state);\r\nbreak;\r\ndefault:\r\ndev_warn(&pf->pdev->dev,\r\n"Client %s instance for PF id %d request an unsupported reset: %d.\n",\r\nclient->name, pf->hw.pf_id, reset_level);\r\nbreak;\r\n}\r\ni40e_service_event_schedule(pf);\r\n}\r\nstatic int i40e_client_update_vsi_ctxt(struct i40e_info *ldev,\r\nstruct i40e_client *client,\r\nbool is_vf, u32 vf_id,\r\nu32 flag, u32 valid_flag)\r\n{\r\nstruct i40e_pf *pf = ldev->pf;\r\nstruct i40e_vsi *vsi = pf->vsi[pf->lan_vsi];\r\nstruct i40e_vsi_context ctxt;\r\nbool update = true;\r\ni40e_status err;\r\nif (is_vf)\r\nreturn -EINVAL;\r\nctxt.seid = pf->main_vsi_seid;\r\nctxt.pf_num = pf->hw.pf_id;\r\nerr = i40e_aq_get_vsi_params(&pf->hw, &ctxt, NULL);\r\nctxt.flags = I40E_AQ_VSI_TYPE_PF;\r\nif (err) {\r\ndev_info(&pf->pdev->dev,\r\n"couldn't get PF vsi config, err %s aq_err %s\n",\r\ni40e_stat_str(&pf->hw, err),\r\ni40e_aq_str(&pf->hw,\r\npf->hw.aq.asq_last_status));\r\nreturn -ENOENT;\r\n}\r\nif ((valid_flag & I40E_CLIENT_VSI_FLAG_TCP_PACKET_ENABLE) &&\r\n(flag & I40E_CLIENT_VSI_FLAG_TCP_PACKET_ENABLE)) {\r\nctxt.info.valid_sections =\r\ncpu_to_le16(I40E_AQ_VSI_PROP_QUEUE_OPT_VALID);\r\nctxt.info.queueing_opt_flags |= I40E_AQ_VSI_QUE_OPT_TCP_ENA;\r\n} else if ((valid_flag & I40E_CLIENT_VSI_FLAG_TCP_PACKET_ENABLE) &&\r\n!(flag & I40E_CLIENT_VSI_FLAG_TCP_PACKET_ENABLE)) {\r\nctxt.info.valid_sections =\r\ncpu_to_le16(I40E_AQ_VSI_PROP_QUEUE_OPT_VALID);\r\nctxt.info.queueing_opt_flags &= ~I40E_AQ_VSI_QUE_OPT_TCP_ENA;\r\n} else {\r\nupdate = false;\r\ndev_warn(&pf->pdev->dev,\r\n"Client %s instance for PF id %d request an unsupported Config: %x.\n",\r\nclient->name, pf->hw.pf_id, flag);\r\n}\r\nif (update) {\r\nerr = i40e_aq_update_vsi_params(&vsi->back->hw, &ctxt, NULL);\r\nif (err) {\r\ndev_info(&pf->pdev->dev,\r\n"update VSI ctxt for PE failed, err %s aq_err %s\n",\r\ni40e_stat_str(&pf->hw, err),\r\ni40e_aq_str(&pf->hw,\r\npf->hw.aq.asq_last_status));\r\n}\r\n}\r\nreturn err;\r\n}\r\nint i40e_register_client(struct i40e_client *client)\r\n{\r\nint ret = 0;\r\nenum i40e_vsi_type vsi_type;\r\nif (!client) {\r\nret = -EIO;\r\ngoto out;\r\n}\r\nif (strlen(client->name) == 0) {\r\npr_info("i40e: Failed to register client with no name\n");\r\nret = -EIO;\r\ngoto out;\r\n}\r\nmutex_lock(&i40e_client_mutex);\r\nif (i40e_client_is_registered(client)) {\r\npr_info("i40e: Client %s has already been registered!\n",\r\nclient->name);\r\nmutex_unlock(&i40e_client_mutex);\r\nret = -EEXIST;\r\ngoto out;\r\n}\r\nif ((client->version.major != I40E_CLIENT_VERSION_MAJOR) ||\r\n(client->version.minor != I40E_CLIENT_VERSION_MINOR)) {\r\npr_info("i40e: Failed to register client %s due to mismatched client interface version\n",\r\nclient->name);\r\npr_info("Client is using version: %02d.%02d.%02d while LAN driver supports %s\n",\r\nclient->version.major, client->version.minor,\r\nclient->version.build,\r\ni40e_client_interface_version_str);\r\nmutex_unlock(&i40e_client_mutex);\r\nret = -EIO;\r\ngoto out;\r\n}\r\nvsi_type = i40e_client_type_to_vsi_type(client->type);\r\nif (vsi_type == I40E_VSI_TYPE_UNKNOWN) {\r\npr_info("i40e: Failed to register client %s due to unknown client type %d\n",\r\nclient->name, client->type);\r\nmutex_unlock(&i40e_client_mutex);\r\nret = -EIO;\r\ngoto out;\r\n}\r\nlist_add(&client->list, &i40e_clients);\r\nset_bit(__I40E_CLIENT_REGISTERED, &client->state);\r\nmutex_unlock(&i40e_client_mutex);\r\nif (i40e_client_prepare(client)) {\r\nret = -EIO;\r\ngoto out;\r\n}\r\npr_info("i40e: Registered client %s with return code %d\n",\r\nclient->name, ret);\r\nout:\r\nreturn ret;\r\n}\r\nint i40e_unregister_client(struct i40e_client *client)\r\n{\r\nint ret = 0;\r\nif (!client || i40e_client_release(client)) {\r\nret = -EIO;\r\ngoto out;\r\n}\r\nmutex_lock(&i40e_client_mutex);\r\nif (!i40e_client_is_registered(client)) {\r\npr_info("i40e: Client %s has not been registered\n",\r\nclient->name);\r\nmutex_unlock(&i40e_client_mutex);\r\nret = -ENODEV;\r\ngoto out;\r\n}\r\nif (atomic_read(&client->ref_cnt) == 0) {\r\nclear_bit(__I40E_CLIENT_REGISTERED, &client->state);\r\nlist_del(&client->list);\r\npr_info("i40e: Unregistered client %s with return code %d\n",\r\nclient->name, ret);\r\n} else {\r\nret = I40E_ERR_NOT_READY;\r\npr_err("i40e: Client %s failed unregister - client has open instances\n",\r\nclient->name);\r\n}\r\nmutex_unlock(&i40e_client_mutex);\r\nout:\r\nreturn ret;\r\n}
