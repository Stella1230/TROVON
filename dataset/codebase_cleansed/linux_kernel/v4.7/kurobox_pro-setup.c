static int __init kurobox_pro_pci_map_irq(const struct pci_dev *dev, u8 slot,\r\nu8 pin)\r\n{\r\nint irq;\r\nirq = orion5x_pci_map_irq(dev, slot, pin);\r\nif (irq != -1)\r\nreturn irq;\r\nreturn -1;\r\n}\r\nstatic int __init kurobox_pro_pci_init(void)\r\n{\r\nif (machine_is_kurobox_pro()) {\r\norion5x_pci_disable();\r\npci_common_init(&kurobox_pro_pci);\r\n}\r\nreturn 0;\r\n}\r\nstatic int kurobox_pro_miconread(unsigned char *buf, int count)\r\n{\r\nint i;\r\nint timeout;\r\nfor (i = 0; i < count; i++) {\r\ntimeout = 10;\r\nwhile (!(readl(UART1_REG(LSR)) & UART_LSR_DR)) {\r\nif (--timeout == 0)\r\nbreak;\r\nudelay(1000);\r\n}\r\nif (timeout == 0)\r\nbreak;\r\nbuf[i] = readl(UART1_REG(RX));\r\n}\r\nreturn i;\r\n}\r\nstatic int kurobox_pro_miconwrite(const unsigned char *buf, int count)\r\n{\r\nint i = 0;\r\nwhile (count--) {\r\nwhile (!(readl(UART1_REG(LSR)) & UART_LSR_THRE))\r\nbarrier();\r\nwritel(buf[i++], UART1_REG(TX));\r\n}\r\nreturn 0;\r\n}\r\nstatic int kurobox_pro_miconsend(const unsigned char *data, int count)\r\n{\r\nint i;\r\nunsigned char checksum = 0;\r\nunsigned char recv_buf[40];\r\nunsigned char send_buf[40];\r\nunsigned char correct_ack[3];\r\nint retry = 2;\r\nfor (i = 0; i < count; i++)\r\nchecksum -= data[i];\r\ndo {\r\nkurobox_pro_miconwrite(data, count);\r\nkurobox_pro_miconwrite(&checksum, 1);\r\nif (kurobox_pro_miconread(recv_buf, sizeof(recv_buf)) <= 3) {\r\nprintk(KERN_ERR ">%s: receive failed.\n", __func__);\r\nmemset(&send_buf, 0xff, sizeof(send_buf));\r\nkurobox_pro_miconwrite(send_buf, sizeof(send_buf));\r\nmdelay(100);\r\nkurobox_pro_miconread(recv_buf, sizeof(recv_buf));\r\n} else {\r\ncorrect_ack[0] = 0x01;\r\ncorrect_ack[1] = data[1];\r\ncorrect_ack[2] = 0x00;\r\nif ((recv_buf[0] + recv_buf[1] + recv_buf[2] +\r\nrecv_buf[3]) & 0xFF) {\r\nprintk(KERN_ERR ">%s: Checksum Error : "\r\n"Received data[%02x, %02x, %02x, %02x]"\r\n"\n", __func__, recv_buf[0],\r\nrecv_buf[1], recv_buf[2], recv_buf[3]);\r\n} else {\r\nif (correct_ack[0] == recv_buf[0] &&\r\ncorrect_ack[1] == recv_buf[1] &&\r\ncorrect_ack[2] == recv_buf[2]) {\r\nmdelay(10);\r\nreturn 0;\r\n}\r\n}\r\nprintk(KERN_ERR ">%s: Error : NAK or Illegal Data "\r\n"Received\n", __func__);\r\n}\r\n} while (retry--);\r\nmdelay(10);\r\nreturn -1;\r\n}\r\nstatic void kurobox_pro_power_off(void)\r\n{\r\nconst unsigned char watchdogkill[] = {0x01, 0x35, 0x00};\r\nconst unsigned char shutdownwait[] = {0x00, 0x0c};\r\nconst unsigned char poweroff[] = {0x00, 0x06};\r\nconst unsigned divisor = ((orion5x_tclk + (8 * 38400)) / (16 * 38400));\r\npr_info("%s: triggering power-off...\n", __func__);\r\nwritel(0x83, UART1_REG(LCR));\r\nwritel(divisor & 0xff, UART1_REG(DLL));\r\nwritel((divisor >> 8) & 0xff, UART1_REG(DLM));\r\nwritel(0x1b, UART1_REG(LCR));\r\nwritel(0x00, UART1_REG(IER));\r\nwritel(0x07, UART1_REG(FCR));\r\nwritel(0x00, UART1_REG(MCR));\r\nkurobox_pro_miconsend(watchdogkill, sizeof(watchdogkill)) ;\r\nkurobox_pro_miconsend(shutdownwait, sizeof(shutdownwait)) ;\r\nkurobox_pro_miconsend(poweroff, sizeof(poweroff));\r\n}\r\nstatic void __init kurobox_pro_init(void)\r\n{\r\norion5x_init();\r\norion5x_mpp_conf(kurobox_pro_mpp_modes);\r\norion5x_ehci0_init();\r\norion5x_ehci1_init();\r\norion5x_eth_init(&kurobox_pro_eth_data);\r\norion5x_i2c_init();\r\norion5x_sata_init(&kurobox_pro_sata_data);\r\norion5x_uart0_init();\r\norion5x_uart1_init();\r\norion5x_xor_init();\r\nmvebu_mbus_add_window_by_id(ORION_MBUS_DEVBUS_BOOT_TARGET,\r\nORION_MBUS_DEVBUS_BOOT_ATTR,\r\nKUROBOX_PRO_NOR_BOOT_BASE,\r\nKUROBOX_PRO_NOR_BOOT_SIZE);\r\nplatform_device_register(&kurobox_pro_nor_flash);\r\nif (machine_is_kurobox_pro()) {\r\nmvebu_mbus_add_window_by_id(ORION_MBUS_DEVBUS_TARGET(0),\r\nORION_MBUS_DEVBUS_ATTR(0),\r\nKUROBOX_PRO_NAND_BASE,\r\nKUROBOX_PRO_NAND_SIZE);\r\nplatform_device_register(&kurobox_pro_nand_flash);\r\n}\r\ni2c_register_board_info(0, &kurobox_pro_i2c_rtc, 1);\r\npm_power_off = kurobox_pro_power_off;\r\n}
