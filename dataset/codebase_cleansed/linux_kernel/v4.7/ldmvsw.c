static void vsw_get_drvinfo(struct net_device *dev,\r\nstruct ethtool_drvinfo *info)\r\n{\r\nstrlcpy(info->driver, DRV_MODULE_NAME, sizeof(info->driver));\r\nstrlcpy(info->version, DRV_MODULE_VERSION, sizeof(info->version));\r\n}\r\nstatic u32 vsw_get_msglevel(struct net_device *dev)\r\n{\r\nstruct vnet_port *port = netdev_priv(dev);\r\nreturn port->vp->msg_enable;\r\n}\r\nstatic void vsw_set_msglevel(struct net_device *dev, u32 value)\r\n{\r\nstruct vnet_port *port = netdev_priv(dev);\r\nport->vp->msg_enable = value;\r\n}\r\nstatic struct vnet_port *vsw_tx_port_find(struct sk_buff *skb,\r\nstruct net_device *dev)\r\n{\r\nstruct vnet_port *port = netdev_priv(dev);\r\nreturn port;\r\n}\r\nstatic u16 vsw_select_queue(struct net_device *dev, struct sk_buff *skb,\r\nvoid *accel_priv, select_queue_fallback_t fallback)\r\n{\r\nstruct vnet_port *port = netdev_priv(dev);\r\nif (!port)\r\nreturn 0;\r\nreturn port->q_index;\r\n}\r\nstatic int vsw_start_xmit(struct sk_buff *skb, struct net_device *dev)\r\n{\r\nreturn sunvnet_start_xmit_common(skb, dev, vsw_tx_port_find);\r\n}\r\nstatic void vsw_set_rx_mode(struct net_device *dev)\r\n{\r\nstruct vnet_port *port = netdev_priv(dev);\r\nreturn sunvnet_set_rx_mode_common(dev, port->vp);\r\n}\r\nstatic void vsw_poll_controller(struct net_device *dev)\r\n{\r\nstruct vnet_port *port = netdev_priv(dev);\r\nreturn sunvnet_poll_controller_common(dev, port->vp);\r\n}\r\nstatic struct vnet *vsw_get_vnet(struct mdesc_handle *hp,\r\nu64 port_node,\r\nu64 *handle)\r\n{\r\nstruct vnet *vp;\r\nstruct vnet *iter;\r\nconst u64 *local_mac = NULL;\r\nconst u64 *cfghandle = NULL;\r\nu64 a;\r\nmdesc_for_each_arc(a, hp, port_node, MDESC_ARC_TYPE_BACK) {\r\nu64 target = mdesc_arc_target(hp, a);\r\nconst char *name;\r\nname = mdesc_get_property(hp, target, "name", NULL);\r\nif (!name || strcmp(name, "virtual-network-switch"))\r\ncontinue;\r\nlocal_mac = mdesc_get_property(hp, target,\r\nlocal_mac_prop, NULL);\r\ncfghandle = mdesc_get_property(hp, target,\r\ncfg_handle_prop, NULL);\r\nbreak;\r\n}\r\nif (!local_mac || !cfghandle)\r\nreturn ERR_PTR(-ENODEV);\r\nvp = NULL;\r\nmutex_lock(&vnet_list_mutex);\r\nlist_for_each_entry(iter, &vnet_list, list) {\r\nif (iter->local_mac == *local_mac) {\r\nvp = iter;\r\nbreak;\r\n}\r\n}\r\nif (!vp) {\r\nvp = kzalloc(sizeof(*vp), GFP_KERNEL);\r\nif (unlikely(!vp)) {\r\nmutex_unlock(&vnet_list_mutex);\r\nreturn ERR_PTR(-ENOMEM);\r\n}\r\nspin_lock_init(&vp->lock);\r\nINIT_LIST_HEAD(&vp->port_list);\r\nINIT_LIST_HEAD(&vp->list);\r\nvp->local_mac = *local_mac;\r\nlist_add(&vp->list, &vnet_list);\r\n}\r\nmutex_unlock(&vnet_list_mutex);\r\n*handle = (u64)*cfghandle;\r\nreturn vp;\r\n}\r\nstatic struct net_device *vsw_alloc_netdev(u8 hwaddr[],\r\nstruct vio_dev *vdev,\r\nu64 handle,\r\nu64 port_id)\r\n{\r\nstruct net_device *dev;\r\nstruct vnet_port *port;\r\nint i;\r\ndev = alloc_etherdev_mqs(sizeof(*port), VNET_MAX_TXQS, 1);\r\nif (!dev)\r\nreturn ERR_PTR(-ENOMEM);\r\ndev->needed_headroom = VNET_PACKET_SKIP + 8;\r\ndev->needed_tailroom = 8;\r\nfor (i = 0; i < ETH_ALEN; i++) {\r\ndev->dev_addr[i] = hwaddr[i];\r\ndev->perm_addr[i] = dev->dev_addr[i];\r\n}\r\nsprintf(dev->name, "vif%d.%d", (int)handle, (int)port_id);\r\ndev->netdev_ops = &vsw_ops;\r\ndev->ethtool_ops = &vsw_ethtool_ops;\r\ndev->watchdog_timeo = VSW_TX_TIMEOUT;\r\ndev->hw_features = NETIF_F_TSO | NETIF_F_GSO | NETIF_F_GSO_SOFTWARE |\r\nNETIF_F_HW_CSUM | NETIF_F_SG;\r\ndev->features = dev->hw_features;\r\nSET_NETDEV_DEV(dev, &vdev->dev);\r\nreturn dev;\r\n}\r\nstatic void print_version(void)\r\n{\r\nprintk_once(KERN_INFO "%s", version);\r\n}\r\nstatic int vsw_port_probe(struct vio_dev *vdev, const struct vio_device_id *id)\r\n{\r\nstruct mdesc_handle *hp;\r\nstruct vnet_port *port;\r\nunsigned long flags;\r\nstruct vnet *vp;\r\nstruct net_device *dev;\r\nconst u64 *rmac;\r\nint len, i, err;\r\nconst u64 *port_id;\r\nu64 handle;\r\nprint_version();\r\nhp = mdesc_grab();\r\nrmac = mdesc_get_property(hp, vdev->mp, remote_macaddr_prop, &len);\r\nerr = -ENODEV;\r\nif (!rmac) {\r\npr_err("Port lacks %s property\n", remote_macaddr_prop);\r\nmdesc_release(hp);\r\nreturn err;\r\n}\r\nport_id = mdesc_get_property(hp, vdev->mp, id_prop, NULL);\r\nerr = -ENODEV;\r\nif (!port_id) {\r\npr_err("Port lacks %s property\n", id_prop);\r\nmdesc_release(hp);\r\nreturn err;\r\n}\r\nvp = vsw_get_vnet(hp, vdev->mp, &handle);\r\nif (unlikely(IS_ERR(vp))) {\r\nerr = PTR_ERR(vp);\r\npr_err("Failed to get vnet for vsw-port\n");\r\nmdesc_release(hp);\r\nreturn err;\r\n}\r\nmdesc_release(hp);\r\ndev = vsw_alloc_netdev(vsw_port_hwaddr, vdev, handle, *port_id);\r\nif (IS_ERR(dev)) {\r\nerr = PTR_ERR(dev);\r\npr_err("Failed to alloc netdev for vsw-port\n");\r\nreturn err;\r\n}\r\nport = netdev_priv(dev);\r\nINIT_LIST_HEAD(&port->list);\r\nfor (i = 0; i < ETH_ALEN; i++)\r\nport->raddr[i] = (*rmac >> (5 - i) * 8) & 0xff;\r\nport->vp = vp;\r\nport->dev = dev;\r\nport->switch_port = 1;\r\nport->tso = true;\r\nport->tsolen = 0;\r\nport->vsw = 1;\r\nerr = vio_driver_init(&port->vio, vdev, VDEV_NETWORK,\r\nvsw_versions, ARRAY_SIZE(vsw_versions),\r\n&vsw_vio_ops, dev->name);\r\nif (err)\r\ngoto err_out_free_dev;\r\nerr = vio_ldc_alloc(&port->vio, &vsw_ldc_cfg, port);\r\nif (err)\r\ngoto err_out_free_dev;\r\ndev_set_drvdata(&vdev->dev, port);\r\nnetif_napi_add(dev, &port->napi, sunvnet_poll_common,\r\nNAPI_POLL_WEIGHT);\r\nspin_lock_irqsave(&vp->lock, flags);\r\nlist_add_rcu(&port->list, &vp->port_list);\r\nspin_unlock_irqrestore(&vp->lock, flags);\r\nsetup_timer(&port->clean_timer, sunvnet_clean_timer_expire_common,\r\n(unsigned long)port);\r\nerr = register_netdev(dev);\r\nif (err) {\r\npr_err("Cannot register net device, aborting\n");\r\ngoto err_out_del_timer;\r\n}\r\nspin_lock_irqsave(&vp->lock, flags);\r\nsunvnet_port_add_txq_common(port);\r\nspin_unlock_irqrestore(&vp->lock, flags);\r\nnapi_enable(&port->napi);\r\nvio_port_up(&port->vio);\r\nnetdev_info(dev, "LDOM vsw-port %pM\n", dev->dev_addr);\r\npr_info("%s: PORT ( remote-mac %pM%s )\n", dev->name,\r\nport->raddr, " switch-port");\r\nreturn 0;\r\nerr_out_del_timer:\r\ndel_timer_sync(&port->clean_timer);\r\nlist_del_rcu(&port->list);\r\nsynchronize_rcu();\r\nnetif_napi_del(&port->napi);\r\ndev_set_drvdata(&vdev->dev, NULL);\r\nvio_ldc_free(&port->vio);\r\nerr_out_free_dev:\r\nfree_netdev(dev);\r\nreturn err;\r\n}\r\nstatic int vsw_port_remove(struct vio_dev *vdev)\r\n{\r\nstruct vnet_port *port = dev_get_drvdata(&vdev->dev);\r\nunsigned long flags;\r\nif (port) {\r\ndel_timer_sync(&port->vio.timer);\r\nnapi_disable(&port->napi);\r\nlist_del_rcu(&port->list);\r\nsynchronize_rcu();\r\ndel_timer_sync(&port->clean_timer);\r\nspin_lock_irqsave(&port->vp->lock, flags);\r\nsunvnet_port_rm_txq_common(port);\r\nspin_unlock_irqrestore(&port->vp->lock, flags);\r\nnetif_napi_del(&port->napi);\r\nsunvnet_port_free_tx_bufs_common(port);\r\nvio_ldc_free(&port->vio);\r\ndev_set_drvdata(&vdev->dev, NULL);\r\nunregister_netdev(port->dev);\r\nfree_netdev(port->dev);\r\n}\r\nreturn 0;\r\n}\r\nstatic void vsw_cleanup(void)\r\n{\r\nstruct vnet *vp;\r\nmutex_lock(&vnet_list_mutex);\r\nwhile (!list_empty(&vnet_list)) {\r\nvp = list_first_entry(&vnet_list, struct vnet, list);\r\nlist_del(&vp->list);\r\nif (!list_empty(&vp->port_list))\r\npr_err("Ports not removed by VIO subsystem!\n");\r\nkfree(vp);\r\n}\r\nmutex_unlock(&vnet_list_mutex);\r\n}\r\nstatic int __init vsw_init(void)\r\n{\r\nreturn vio_register_driver(&vsw_port_driver);\r\n}\r\nstatic void __exit vsw_exit(void)\r\n{\r\nvio_unregister_driver(&vsw_port_driver);\r\nvsw_cleanup();\r\n}
