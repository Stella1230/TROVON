static struct ccid_operations *ccid_by_number(const u8 id)\r\n{\r\nint i;\r\nfor (i = 0; i < ARRAY_SIZE(ccids); i++)\r\nif (ccids[i]->ccid_id == id)\r\nreturn ccids[i];\r\nreturn NULL;\r\n}\r\nbool ccid_support_check(u8 const *ccid_array, u8 array_len)\r\n{\r\nwhile (array_len > 0)\r\nif (ccid_by_number(ccid_array[--array_len]) == NULL)\r\nreturn false;\r\nreturn true;\r\n}\r\nint ccid_get_builtin_ccids(u8 **ccid_array, u8 *array_len)\r\n{\r\n*ccid_array = kmalloc(ARRAY_SIZE(ccids), gfp_any());\r\nif (*ccid_array == NULL)\r\nreturn -ENOBUFS;\r\nfor (*array_len = 0; *array_len < ARRAY_SIZE(ccids); *array_len += 1)\r\n(*ccid_array)[*array_len] = ccids[*array_len]->ccid_id;\r\nreturn 0;\r\n}\r\nint ccid_getsockopt_builtin_ccids(struct sock *sk, int len,\r\nchar __user *optval, int __user *optlen)\r\n{\r\nu8 *ccid_array, array_len;\r\nint err = 0;\r\nif (ccid_get_builtin_ccids(&ccid_array, &array_len))\r\nreturn -ENOBUFS;\r\nif (put_user(array_len, optlen))\r\nerr = -EFAULT;\r\nelse if (len > 0 && copy_to_user(optval, ccid_array,\r\nlen > array_len ? array_len : len))\r\nerr = -EFAULT;\r\nkfree(ccid_array);\r\nreturn err;\r\n}\r\nstatic struct kmem_cache *ccid_kmem_cache_create(int obj_size, char *slab_name_fmt, const char *fmt,...)\r\n{\r\nstruct kmem_cache *slab;\r\nva_list args;\r\nva_start(args, fmt);\r\nvsnprintf(slab_name_fmt, CCID_SLAB_NAME_LENGTH, fmt, args);\r\nva_end(args);\r\nslab = kmem_cache_create(slab_name_fmt, sizeof(struct ccid) + obj_size, 0,\r\nSLAB_HWCACHE_ALIGN, NULL);\r\nreturn slab;\r\n}\r\nstatic void ccid_kmem_cache_destroy(struct kmem_cache *slab)\r\n{\r\nkmem_cache_destroy(slab);\r\n}\r\nstatic int __init ccid_activate(struct ccid_operations *ccid_ops)\r\n{\r\nint err = -ENOBUFS;\r\nccid_ops->ccid_hc_rx_slab =\r\nccid_kmem_cache_create(ccid_ops->ccid_hc_rx_obj_size,\r\nccid_ops->ccid_hc_rx_slab_name,\r\n"ccid%u_hc_rx_sock",\r\nccid_ops->ccid_id);\r\nif (ccid_ops->ccid_hc_rx_slab == NULL)\r\ngoto out;\r\nccid_ops->ccid_hc_tx_slab =\r\nccid_kmem_cache_create(ccid_ops->ccid_hc_tx_obj_size,\r\nccid_ops->ccid_hc_tx_slab_name,\r\n"ccid%u_hc_tx_sock",\r\nccid_ops->ccid_id);\r\nif (ccid_ops->ccid_hc_tx_slab == NULL)\r\ngoto out_free_rx_slab;\r\npr_info("DCCP: Activated CCID %d (%s)\n",\r\nccid_ops->ccid_id, ccid_ops->ccid_name);\r\nerr = 0;\r\nout:\r\nreturn err;\r\nout_free_rx_slab:\r\nccid_kmem_cache_destroy(ccid_ops->ccid_hc_rx_slab);\r\nccid_ops->ccid_hc_rx_slab = NULL;\r\ngoto out;\r\n}\r\nstatic void ccid_deactivate(struct ccid_operations *ccid_ops)\r\n{\r\nccid_kmem_cache_destroy(ccid_ops->ccid_hc_tx_slab);\r\nccid_ops->ccid_hc_tx_slab = NULL;\r\nccid_kmem_cache_destroy(ccid_ops->ccid_hc_rx_slab);\r\nccid_ops->ccid_hc_rx_slab = NULL;\r\npr_info("DCCP: Deactivated CCID %d (%s)\n",\r\nccid_ops->ccid_id, ccid_ops->ccid_name);\r\n}\r\nstruct ccid *ccid_new(const u8 id, struct sock *sk, bool rx)\r\n{\r\nstruct ccid_operations *ccid_ops = ccid_by_number(id);\r\nstruct ccid *ccid = NULL;\r\nif (ccid_ops == NULL)\r\ngoto out;\r\nccid = kmem_cache_alloc(rx ? ccid_ops->ccid_hc_rx_slab :\r\nccid_ops->ccid_hc_tx_slab, gfp_any());\r\nif (ccid == NULL)\r\ngoto out;\r\nccid->ccid_ops = ccid_ops;\r\nif (rx) {\r\nmemset(ccid + 1, 0, ccid_ops->ccid_hc_rx_obj_size);\r\nif (ccid->ccid_ops->ccid_hc_rx_init != NULL &&\r\nccid->ccid_ops->ccid_hc_rx_init(ccid, sk) != 0)\r\ngoto out_free_ccid;\r\n} else {\r\nmemset(ccid + 1, 0, ccid_ops->ccid_hc_tx_obj_size);\r\nif (ccid->ccid_ops->ccid_hc_tx_init != NULL &&\r\nccid->ccid_ops->ccid_hc_tx_init(ccid, sk) != 0)\r\ngoto out_free_ccid;\r\n}\r\nout:\r\nreturn ccid;\r\nout_free_ccid:\r\nkmem_cache_free(rx ? ccid_ops->ccid_hc_rx_slab :\r\nccid_ops->ccid_hc_tx_slab, ccid);\r\nccid = NULL;\r\ngoto out;\r\n}\r\nvoid ccid_hc_rx_delete(struct ccid *ccid, struct sock *sk)\r\n{\r\nif (ccid != NULL) {\r\nif (ccid->ccid_ops->ccid_hc_rx_exit != NULL)\r\nccid->ccid_ops->ccid_hc_rx_exit(sk);\r\nkmem_cache_free(ccid->ccid_ops->ccid_hc_rx_slab, ccid);\r\n}\r\n}\r\nvoid ccid_hc_tx_delete(struct ccid *ccid, struct sock *sk)\r\n{\r\nif (ccid != NULL) {\r\nif (ccid->ccid_ops->ccid_hc_tx_exit != NULL)\r\nccid->ccid_ops->ccid_hc_tx_exit(sk);\r\nkmem_cache_free(ccid->ccid_ops->ccid_hc_tx_slab, ccid);\r\n}\r\n}\r\nint __init ccid_initialize_builtins(void)\r\n{\r\nint i, err = tfrc_lib_init();\r\nif (err)\r\nreturn err;\r\nfor (i = 0; i < ARRAY_SIZE(ccids); i++) {\r\nerr = ccid_activate(ccids[i]);\r\nif (err)\r\ngoto unwind_registrations;\r\n}\r\nreturn 0;\r\nunwind_registrations:\r\nwhile(--i >= 0)\r\nccid_deactivate(ccids[i]);\r\ntfrc_lib_exit();\r\nreturn err;\r\n}\r\nvoid ccid_cleanup_builtins(void)\r\n{\r\nint i;\r\nfor (i = 0; i < ARRAY_SIZE(ccids); i++)\r\nccid_deactivate(ccids[i]);\r\ntfrc_lib_exit();\r\n}
