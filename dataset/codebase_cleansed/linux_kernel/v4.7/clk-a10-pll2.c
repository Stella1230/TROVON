static void __init sun4i_pll2_setup(struct device_node *node,\r\nint post_div_offset)\r\n{\r\nconst char *clk_name = node->name, *parent;\r\nstruct clk **clks, *base_clk, *prediv_clk;\r\nstruct clk_onecell_data *clk_data;\r\nstruct clk_multiplier *mult;\r\nstruct clk_gate *gate;\r\nvoid __iomem *reg;\r\nu32 val;\r\nreg = of_io_request_and_map(node, 0, of_node_full_name(node));\r\nif (IS_ERR(reg))\r\nreturn;\r\nclk_data = kzalloc(sizeof(*clk_data), GFP_KERNEL);\r\nif (!clk_data)\r\ngoto err_unmap;\r\nclks = kcalloc(SUN4I_PLL2_OUTPUTS, sizeof(struct clk *), GFP_KERNEL);\r\nif (!clks)\r\ngoto err_free_data;\r\nparent = of_clk_get_parent_name(node, 0);\r\nprediv_clk = clk_register_divider(NULL, "pll2-prediv",\r\nparent, 0, reg,\r\nSUN4I_PLL2_PRE_DIV_SHIFT,\r\nSUN4I_PLL2_PRE_DIV_WIDTH,\r\nCLK_DIVIDER_ONE_BASED | CLK_DIVIDER_ALLOW_ZERO,\r\n&sun4i_a10_pll2_lock);\r\nif (!prediv_clk) {\r\npr_err("Couldn't register the prediv clock\n");\r\ngoto err_free_array;\r\n}\r\ngate = kzalloc(sizeof(struct clk_gate), GFP_KERNEL);\r\nif (!gate)\r\ngoto err_unregister_prediv;\r\ngate->reg = reg;\r\ngate->bit_idx = SUN4I_PLL2_ENABLE;\r\ngate->lock = &sun4i_a10_pll2_lock;\r\nmult = kzalloc(sizeof(struct clk_multiplier), GFP_KERNEL);\r\nif (!mult)\r\ngoto err_free_gate;\r\nmult->reg = reg;\r\nmult->shift = SUN4I_PLL2_N_SHIFT;\r\nmult->width = 7;\r\nmult->flags = CLK_MULTIPLIER_ZERO_BYPASS |\r\nCLK_MULTIPLIER_ROUND_CLOSEST;\r\nmult->lock = &sun4i_a10_pll2_lock;\r\nparent = __clk_get_name(prediv_clk);\r\nbase_clk = clk_register_composite(NULL, "pll2-base",\r\n&parent, 1,\r\nNULL, NULL,\r\n&mult->hw, &clk_multiplier_ops,\r\n&gate->hw, &clk_gate_ops,\r\nCLK_SET_RATE_PARENT);\r\nif (!base_clk) {\r\npr_err("Couldn't register the base multiplier clock\n");\r\ngoto err_free_multiplier;\r\n}\r\nparent = __clk_get_name(base_clk);\r\nval = readl(reg);\r\nval &= ~(SUN4I_PLL2_POST_DIV_MASK << SUN4I_PLL2_POST_DIV_SHIFT);\r\nval |= (SUN4I_PLL2_POST_DIV_VALUE - post_div_offset) << SUN4I_PLL2_POST_DIV_SHIFT;\r\nwritel(val, reg);\r\nof_property_read_string_index(node, "clock-output-names",\r\nSUN4I_A10_PLL2_1X, &clk_name);\r\nclks[SUN4I_A10_PLL2_1X] = clk_register_fixed_factor(NULL, clk_name,\r\nparent,\r\nCLK_SET_RATE_PARENT,\r\n1,\r\nSUN4I_PLL2_POST_DIV_VALUE);\r\nWARN_ON(IS_ERR(clks[SUN4I_A10_PLL2_1X]));\r\nof_property_read_string_index(node, "clock-output-names",\r\nSUN4I_A10_PLL2_2X, &clk_name);\r\nclks[SUN4I_A10_PLL2_2X] = clk_register_fixed_factor(NULL, clk_name,\r\nparent,\r\nCLK_SET_RATE_PARENT,\r\n1, 2);\r\nWARN_ON(IS_ERR(clks[SUN4I_A10_PLL2_2X]));\r\nof_property_read_string_index(node, "clock-output-names",\r\nSUN4I_A10_PLL2_4X, &clk_name);\r\nclks[SUN4I_A10_PLL2_4X] = clk_register_fixed_factor(NULL, clk_name,\r\nparent,\r\nCLK_SET_RATE_PARENT,\r\n1, 1);\r\nWARN_ON(IS_ERR(clks[SUN4I_A10_PLL2_4X]));\r\nof_property_read_string_index(node, "clock-output-names",\r\nSUN4I_A10_PLL2_8X, &clk_name);\r\nclks[SUN4I_A10_PLL2_8X] = clk_register_fixed_factor(NULL, clk_name,\r\nparent,\r\nCLK_SET_RATE_PARENT,\r\n2, 1);\r\nWARN_ON(IS_ERR(clks[SUN4I_A10_PLL2_8X]));\r\nclk_data->clks = clks;\r\nclk_data->clk_num = SUN4I_PLL2_OUTPUTS;\r\nof_clk_add_provider(node, of_clk_src_onecell_get, clk_data);\r\nreturn;\r\nerr_free_multiplier:\r\nkfree(mult);\r\nerr_free_gate:\r\nkfree(gate);\r\nerr_unregister_prediv:\r\nclk_unregister_divider(prediv_clk);\r\nerr_free_array:\r\nkfree(clks);\r\nerr_free_data:\r\nkfree(clk_data);\r\nerr_unmap:\r\niounmap(reg);\r\n}\r\nstatic void __init sun4i_a10_pll2_setup(struct device_node *node)\r\n{\r\nsun4i_pll2_setup(node, 0);\r\n}\r\nstatic void __init sun5i_a13_pll2_setup(struct device_node *node)\r\n{\r\nsun4i_pll2_setup(node, 1);\r\n}
