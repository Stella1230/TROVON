void jffs2_garbage_collect_trigger(struct jffs2_sb_info *c)\r\n{\r\nassert_spin_locked(&c->erase_completion_lock);\r\nif (c->gc_task && jffs2_thread_should_wake(c))\r\nsend_sig(SIGHUP, c->gc_task, 1);\r\n}\r\nint jffs2_start_garbage_collect_thread(struct jffs2_sb_info *c)\r\n{\r\nstruct task_struct *tsk;\r\nint ret = 0;\r\nBUG_ON(c->gc_task);\r\ninit_completion(&c->gc_thread_start);\r\ninit_completion(&c->gc_thread_exit);\r\ntsk = kthread_run(jffs2_garbage_collect_thread, c, "jffs2_gcd_mtd%d", c->mtd->index);\r\nif (IS_ERR(tsk)) {\r\npr_warn("fork failed for JFFS2 garbage collect thread: %ld\n",\r\n-PTR_ERR(tsk));\r\ncomplete(&c->gc_thread_exit);\r\nret = PTR_ERR(tsk);\r\n} else {\r\njffs2_dbg(1, "Garbage collect thread is pid %d\n", tsk->pid);\r\nwait_for_completion(&c->gc_thread_start);\r\nret = tsk->pid;\r\n}\r\nreturn ret;\r\n}\r\nvoid jffs2_stop_garbage_collect_thread(struct jffs2_sb_info *c)\r\n{\r\nint wait = 0;\r\nspin_lock(&c->erase_completion_lock);\r\nif (c->gc_task) {\r\njffs2_dbg(1, "Killing GC task %d\n", c->gc_task->pid);\r\nsend_sig(SIGKILL, c->gc_task, 1);\r\nwait = 1;\r\n}\r\nspin_unlock(&c->erase_completion_lock);\r\nif (wait)\r\nwait_for_completion(&c->gc_thread_exit);\r\n}\r\nstatic int jffs2_garbage_collect_thread(void *_c)\r\n{\r\nstruct jffs2_sb_info *c = _c;\r\nsigset_t hupmask;\r\nsiginitset(&hupmask, sigmask(SIGHUP));\r\nallow_signal(SIGKILL);\r\nallow_signal(SIGSTOP);\r\nallow_signal(SIGHUP);\r\nc->gc_task = current;\r\ncomplete(&c->gc_thread_start);\r\nset_user_nice(current, 10);\r\nset_freezable();\r\nfor (;;) {\r\nsigprocmask(SIG_UNBLOCK, &hupmask, NULL);\r\nagain:\r\nspin_lock(&c->erase_completion_lock);\r\nif (!jffs2_thread_should_wake(c)) {\r\nset_current_state (TASK_INTERRUPTIBLE);\r\nspin_unlock(&c->erase_completion_lock);\r\njffs2_dbg(1, "%s(): sleeping...\n", __func__);\r\nschedule();\r\n} else {\r\nspin_unlock(&c->erase_completion_lock);\r\n}\r\nschedule_timeout_interruptible(msecs_to_jiffies(50));\r\nif (kthread_should_stop()) {\r\njffs2_dbg(1, "%s(): kthread_stop() called\n", __func__);\r\ngoto die;\r\n}\r\nwhile (signal_pending(current) || freezing(current)) {\r\nunsigned long signr;\r\nif (try_to_freeze())\r\ngoto again;\r\nsignr = kernel_dequeue_signal(NULL);\r\nswitch(signr) {\r\ncase SIGSTOP:\r\njffs2_dbg(1, "%s(): SIGSTOP received\n",\r\n__func__);\r\nkernel_signal_stop();\r\nbreak;\r\ncase SIGKILL:\r\njffs2_dbg(1, "%s(): SIGKILL received\n",\r\n__func__);\r\ngoto die;\r\ncase SIGHUP:\r\njffs2_dbg(1, "%s(): SIGHUP received\n",\r\n__func__);\r\nbreak;\r\ndefault:\r\njffs2_dbg(1, "%s(): signal %ld received\n",\r\n__func__, signr);\r\n}\r\n}\r\nsigprocmask(SIG_BLOCK, &hupmask, NULL);\r\njffs2_dbg(1, "%s(): pass\n", __func__);\r\nif (jffs2_garbage_collect_pass(c) == -ENOSPC) {\r\npr_notice("No space for garbage collection. Aborting GC thread\n");\r\ngoto die;\r\n}\r\n}\r\ndie:\r\nspin_lock(&c->erase_completion_lock);\r\nc->gc_task = NULL;\r\nspin_unlock(&c->erase_completion_lock);\r\ncomplete_and_exit(&c->gc_thread_exit, 0);\r\n}
