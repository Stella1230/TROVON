int\r\nnv50_sor_power(NV50_DISP_MTHD_V1)\r\n{\r\nstruct nvkm_device *device = disp->base.engine.subdev.device;\r\nunion {\r\nstruct nv50_disp_sor_pwr_v0 v0;\r\n} *args = data;\r\nconst u32 soff = outp->or * 0x800;\r\nu32 stat;\r\nint ret = -ENOSYS;\r\nnvif_ioctl(object, "disp sor pwr size %d\n", size);\r\nif (!(ret = nvif_unpack(ret, &data, &size, args->v0, 0, 0, false))) {\r\nnvif_ioctl(object, "disp sor pwr vers %d state %d\n",\r\nargs->v0.version, args->v0.state);\r\nstat = !!args->v0.state;\r\n} else\r\nreturn ret;\r\nnvkm_msec(device, 2000,\r\nif (!(nvkm_rd32(device, 0x61c004 + soff) & 0x80000000))\r\nbreak;\r\n);\r\nnvkm_mask(device, 0x61c004 + soff, 0x80000001, 0x80000000 | stat);\r\nnvkm_msec(device, 2000,\r\nif (!(nvkm_rd32(device, 0x61c004 + soff) & 0x80000000))\r\nbreak;\r\n);\r\nnvkm_msec(device, 2000,\r\nif (!(nvkm_rd32(device, 0x61c030 + soff) & 0x10000000))\r\nbreak;\r\n);\r\nreturn 0;\r\n}\r\nint\r\nnv50_sor_output_new(struct nvkm_disp *disp, int index,\r\nstruct dcb_output *dcbE, struct nvkm_output **poutp)\r\n{\r\nreturn nvkm_output_new_(&nv50_sor_output_func, disp,\r\nindex, dcbE, poutp);\r\n}
