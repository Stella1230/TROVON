static void\r\ntape_std_assign_timeout(unsigned long data)\r\n{\r\nstruct tape_request * request;\r\nstruct tape_device * device;\r\nint rc;\r\nrequest = (struct tape_request *) data;\r\ndevice = request->device;\r\nBUG_ON(!device);\r\nDBF_EVENT(3, "%08x: Assignment timeout. Device busy.\n",\r\ndevice->cdev_id);\r\nrc = tape_cancel_io(device, request);\r\nif(rc)\r\nDBF_EVENT(3, "(%08x): Assign timeout: Cancel failed with rc = "\r\n"%i\n", device->cdev_id, rc);\r\n}\r\nint\r\ntape_std_assign(struct tape_device *device)\r\n{\r\nint rc;\r\nstruct timer_list timeout;\r\nstruct tape_request *request;\r\nrequest = tape_alloc_request(2, 11);\r\nif (IS_ERR(request))\r\nreturn PTR_ERR(request);\r\nrequest->op = TO_ASSIGN;\r\ntape_ccw_cc(request->cpaddr, ASSIGN, 11, request->cpdata);\r\ntape_ccw_end(request->cpaddr + 1, NOP, 0, NULL);\r\ninit_timer_on_stack(&timeout);\r\ntimeout.function = tape_std_assign_timeout;\r\ntimeout.data = (unsigned long) request;\r\ntimeout.expires = jiffies + 2 * HZ;\r\nadd_timer(&timeout);\r\nrc = tape_do_io_interruptible(device, request);\r\ndel_timer_sync(&timeout);\r\ndestroy_timer_on_stack(&timeout);\r\nif (rc != 0) {\r\nDBF_EVENT(3, "%08x: assign failed - device might be busy\n",\r\ndevice->cdev_id);\r\n} else {\r\nDBF_EVENT(3, "%08x: Tape assigned\n", device->cdev_id);\r\n}\r\ntape_free_request(request);\r\nreturn rc;\r\n}\r\nint\r\ntape_std_unassign (struct tape_device *device)\r\n{\r\nint rc;\r\nstruct tape_request *request;\r\nif (device->tape_state == TS_NOT_OPER) {\r\nDBF_EVENT(3, "(%08x): Can't unassign device\n",\r\ndevice->cdev_id);\r\nreturn -EIO;\r\n}\r\nrequest = tape_alloc_request(2, 11);\r\nif (IS_ERR(request))\r\nreturn PTR_ERR(request);\r\nrequest->op = TO_UNASSIGN;\r\ntape_ccw_cc(request->cpaddr, UNASSIGN, 11, request->cpdata);\r\ntape_ccw_end(request->cpaddr + 1, NOP, 0, NULL);\r\nif ((rc = tape_do_io(device, request)) != 0) {\r\nDBF_EVENT(3, "%08x: Unassign failed\n", device->cdev_id);\r\n} else {\r\nDBF_EVENT(3, "%08x: Tape unassigned\n", device->cdev_id);\r\n}\r\ntape_free_request(request);\r\nreturn rc;\r\n}\r\nint\r\ntape_std_display(struct tape_device *device, struct display_struct *disp)\r\n{\r\nstruct tape_request *request;\r\nint rc;\r\nrequest = tape_alloc_request(2, 17);\r\nif (IS_ERR(request)) {\r\nDBF_EVENT(3, "TAPE: load display failed\n");\r\nreturn PTR_ERR(request);\r\n}\r\nrequest->op = TO_DIS;\r\n*(unsigned char *) request->cpdata = disp->cntrl;\r\nDBF_EVENT(5, "TAPE: display cntrl=%04x\n", disp->cntrl);\r\nmemcpy(((unsigned char *) request->cpdata) + 1, disp->message1, 8);\r\nmemcpy(((unsigned char *) request->cpdata) + 9, disp->message2, 8);\r\nASCEBC(((unsigned char*) request->cpdata) + 1, 16);\r\ntape_ccw_cc(request->cpaddr, LOAD_DISPLAY, 17, request->cpdata);\r\ntape_ccw_end(request->cpaddr + 1, NOP, 0, NULL);\r\nrc = tape_do_io_interruptible(device, request);\r\ntape_free_request(request);\r\nreturn rc;\r\n}\r\nint\r\ntape_std_read_block_id(struct tape_device *device, __u64 *id)\r\n{\r\nstruct tape_request *request;\r\nint rc;\r\nrequest = tape_alloc_request(3, 8);\r\nif (IS_ERR(request))\r\nreturn PTR_ERR(request);\r\nrequest->op = TO_RBI;\r\ntape_ccw_cc(request->cpaddr, MODE_SET_DB, 1, device->modeset_byte);\r\ntape_ccw_cc(request->cpaddr + 1, READ_BLOCK_ID, 8, request->cpdata);\r\ntape_ccw_end(request->cpaddr + 2, NOP, 0, NULL);\r\nrc = tape_do_io(device, request);\r\nif (rc == 0)\r\n*id = *(__u64 *) request->cpdata;\r\ntape_free_request(request);\r\nreturn rc;\r\n}\r\nint\r\ntape_std_terminate_write(struct tape_device *device)\r\n{\r\nint rc;\r\nif(device->required_tapemarks == 0)\r\nreturn 0;\r\nDBF_LH(5, "tape%d: terminate write %dxEOF\n", device->first_minor,\r\ndevice->required_tapemarks);\r\nrc = tape_mtop(device, MTWEOF, device->required_tapemarks);\r\nif (rc)\r\nreturn rc;\r\ndevice->required_tapemarks = 0;\r\nreturn tape_mtop(device, MTBSR, 1);\r\n}\r\nint\r\ntape_std_mtload(struct tape_device *device, int count)\r\n{\r\nreturn wait_event_interruptible(device->state_change_wq,\r\n(device->medium_state == MS_LOADED));\r\n}\r\nint\r\ntape_std_mtsetblk(struct tape_device *device, int count)\r\n{\r\nstruct idal_buffer *new;\r\nDBF_LH(6, "tape_std_mtsetblk(%d)\n", count);\r\nif (count <= 0) {\r\ndevice->char_data.block_size = 0;\r\nreturn 0;\r\n}\r\nif (device->char_data.idal_buf != NULL &&\r\ndevice->char_data.idal_buf->size == count)\r\nreturn 0;\r\nif (count > MAX_BLOCKSIZE) {\r\nDBF_EVENT(3, "Invalid block size (%d > %d) given.\n",\r\ncount, MAX_BLOCKSIZE);\r\nreturn -EINVAL;\r\n}\r\nnew = idal_buffer_alloc(count, 0);\r\nif (IS_ERR(new))\r\nreturn -ENOMEM;\r\nif (device->char_data.idal_buf != NULL)\r\nidal_buffer_free(device->char_data.idal_buf);\r\ndevice->char_data.idal_buf = new;\r\ndevice->char_data.block_size = count;\r\nDBF_LH(6, "new blocksize is %d\n", device->char_data.block_size);\r\nreturn 0;\r\n}\r\nint\r\ntape_std_mtreset(struct tape_device *device, int count)\r\n{\r\nDBF_EVENT(6, "TCHAR:devreset:\n");\r\ndevice->char_data.block_size = 0;\r\nreturn 0;\r\n}\r\nint\r\ntape_std_mtfsf(struct tape_device *device, int mt_count)\r\n{\r\nstruct tape_request *request;\r\nstruct ccw1 *ccw;\r\nrequest = tape_alloc_request(mt_count + 2, 0);\r\nif (IS_ERR(request))\r\nreturn PTR_ERR(request);\r\nrequest->op = TO_FSF;\r\nccw = tape_ccw_cc(request->cpaddr, MODE_SET_DB, 1,\r\ndevice->modeset_byte);\r\nccw = tape_ccw_repeat(ccw, FORSPACEFILE, mt_count);\r\nccw = tape_ccw_end(ccw, NOP, 0, NULL);\r\nreturn tape_do_io_free(device, request);\r\n}\r\nint\r\ntape_std_mtfsr(struct tape_device *device, int mt_count)\r\n{\r\nstruct tape_request *request;\r\nstruct ccw1 *ccw;\r\nint rc;\r\nrequest = tape_alloc_request(mt_count + 2, 0);\r\nif (IS_ERR(request))\r\nreturn PTR_ERR(request);\r\nrequest->op = TO_FSB;\r\nccw = tape_ccw_cc(request->cpaddr, MODE_SET_DB, 1,\r\ndevice->modeset_byte);\r\nccw = tape_ccw_repeat(ccw, FORSPACEBLOCK, mt_count);\r\nccw = tape_ccw_end(ccw, NOP, 0, NULL);\r\nrc = tape_do_io(device, request);\r\nif (rc == 0 && request->rescnt > 0) {\r\nDBF_LH(3, "FSR over tapemark\n");\r\nrc = 1;\r\n}\r\ntape_free_request(request);\r\nreturn rc;\r\n}\r\nint\r\ntape_std_mtbsr(struct tape_device *device, int mt_count)\r\n{\r\nstruct tape_request *request;\r\nstruct ccw1 *ccw;\r\nint rc;\r\nrequest = tape_alloc_request(mt_count + 2, 0);\r\nif (IS_ERR(request))\r\nreturn PTR_ERR(request);\r\nrequest->op = TO_BSB;\r\nccw = tape_ccw_cc(request->cpaddr, MODE_SET_DB, 1,\r\ndevice->modeset_byte);\r\nccw = tape_ccw_repeat(ccw, BACKSPACEBLOCK, mt_count);\r\nccw = tape_ccw_end(ccw, NOP, 0, NULL);\r\nrc = tape_do_io(device, request);\r\nif (rc == 0 && request->rescnt > 0) {\r\nDBF_LH(3, "BSR over tapemark\n");\r\nrc = 1;\r\n}\r\ntape_free_request(request);\r\nreturn rc;\r\n}\r\nint\r\ntape_std_mtweof(struct tape_device *device, int mt_count)\r\n{\r\nstruct tape_request *request;\r\nstruct ccw1 *ccw;\r\nrequest = tape_alloc_request(mt_count + 2, 0);\r\nif (IS_ERR(request))\r\nreturn PTR_ERR(request);\r\nrequest->op = TO_WTM;\r\nccw = tape_ccw_cc(request->cpaddr, MODE_SET_DB, 1,\r\ndevice->modeset_byte);\r\nccw = tape_ccw_repeat(ccw, WRITETAPEMARK, mt_count);\r\nccw = tape_ccw_end(ccw, NOP, 0, NULL);\r\nreturn tape_do_io_free(device, request);\r\n}\r\nint\r\ntape_std_mtbsfm(struct tape_device *device, int mt_count)\r\n{\r\nstruct tape_request *request;\r\nstruct ccw1 *ccw;\r\nrequest = tape_alloc_request(mt_count + 2, 0);\r\nif (IS_ERR(request))\r\nreturn PTR_ERR(request);\r\nrequest->op = TO_BSF;\r\nccw = tape_ccw_cc(request->cpaddr, MODE_SET_DB, 1,\r\ndevice->modeset_byte);\r\nccw = tape_ccw_repeat(ccw, BACKSPACEFILE, mt_count);\r\nccw = tape_ccw_end(ccw, NOP, 0, NULL);\r\nreturn tape_do_io_free(device, request);\r\n}\r\nint\r\ntape_std_mtbsf(struct tape_device *device, int mt_count)\r\n{\r\nstruct tape_request *request;\r\nstruct ccw1 *ccw;\r\nint rc;\r\nrequest = tape_alloc_request(mt_count + 2, 0);\r\nif (IS_ERR(request))\r\nreturn PTR_ERR(request);\r\nrequest->op = TO_BSF;\r\nccw = tape_ccw_cc(request->cpaddr, MODE_SET_DB, 1,\r\ndevice->modeset_byte);\r\nccw = tape_ccw_repeat(ccw, BACKSPACEFILE, mt_count);\r\nccw = tape_ccw_end(ccw, NOP, 0, NULL);\r\nrc = tape_do_io_free(device, request);\r\nif (rc == 0) {\r\nrc = tape_mtop(device, MTFSR, 1);\r\nif (rc > 0)\r\nrc = 0;\r\n}\r\nreturn rc;\r\n}\r\nint\r\ntape_std_mtfsfm(struct tape_device *device, int mt_count)\r\n{\r\nstruct tape_request *request;\r\nstruct ccw1 *ccw;\r\nint rc;\r\nrequest = tape_alloc_request(mt_count + 2, 0);\r\nif (IS_ERR(request))\r\nreturn PTR_ERR(request);\r\nrequest->op = TO_FSF;\r\nccw = tape_ccw_cc(request->cpaddr, MODE_SET_DB, 1,\r\ndevice->modeset_byte);\r\nccw = tape_ccw_repeat(ccw, FORSPACEFILE, mt_count);\r\nccw = tape_ccw_end(ccw, NOP, 0, NULL);\r\nrc = tape_do_io_free(device, request);\r\nif (rc == 0) {\r\nrc = tape_mtop(device, MTBSR, 1);\r\nif (rc > 0)\r\nrc = 0;\r\n}\r\nreturn rc;\r\n}\r\nint\r\ntape_std_mtrew(struct tape_device *device, int mt_count)\r\n{\r\nstruct tape_request *request;\r\nrequest = tape_alloc_request(3, 0);\r\nif (IS_ERR(request))\r\nreturn PTR_ERR(request);\r\nrequest->op = TO_REW;\r\ntape_ccw_cc(request->cpaddr, MODE_SET_DB, 1,\r\ndevice->modeset_byte);\r\ntape_ccw_cc(request->cpaddr + 1, REWIND, 0, NULL);\r\ntape_ccw_end(request->cpaddr + 2, NOP, 0, NULL);\r\nreturn tape_do_io_free(device, request);\r\n}\r\nint\r\ntape_std_mtoffl(struct tape_device *device, int mt_count)\r\n{\r\nstruct tape_request *request;\r\nrequest = tape_alloc_request(3, 0);\r\nif (IS_ERR(request))\r\nreturn PTR_ERR(request);\r\nrequest->op = TO_RUN;\r\ntape_ccw_cc(request->cpaddr, MODE_SET_DB, 1, device->modeset_byte);\r\ntape_ccw_cc(request->cpaddr + 1, REWIND_UNLOAD, 0, NULL);\r\ntape_ccw_end(request->cpaddr + 2, NOP, 0, NULL);\r\nreturn tape_do_io_free(device, request);\r\n}\r\nint\r\ntape_std_mtnop(struct tape_device *device, int mt_count)\r\n{\r\nstruct tape_request *request;\r\nrequest = tape_alloc_request(2, 0);\r\nif (IS_ERR(request))\r\nreturn PTR_ERR(request);\r\nrequest->op = TO_NOP;\r\ntape_ccw_cc(request->cpaddr, MODE_SET_DB, 1, device->modeset_byte);\r\ntape_ccw_end(request->cpaddr + 1, NOP, 0, NULL);\r\nreturn tape_do_io_free(device, request);\r\n}\r\nint\r\ntape_std_mteom(struct tape_device *device, int mt_count)\r\n{\r\nint rc;\r\nif ((rc = tape_mtop(device, MTREW, 1)) < 0)\r\nreturn rc;\r\ndo {\r\nif ((rc = tape_mtop(device, MTFSF, 1)) < 0)\r\nreturn rc;\r\nif ((rc = tape_mtop(device, MTFSR, 1)) < 0)\r\nreturn rc;\r\n} while (rc == 0);\r\nreturn tape_mtop(device, MTBSR, 1);\r\n}\r\nint\r\ntape_std_mtreten(struct tape_device *device, int mt_count)\r\n{\r\nstruct tape_request *request;\r\nrequest = tape_alloc_request(4, 0);\r\nif (IS_ERR(request))\r\nreturn PTR_ERR(request);\r\nrequest->op = TO_FSF;\r\ntape_ccw_cc(request->cpaddr, MODE_SET_DB, 1, device->modeset_byte);\r\ntape_ccw_cc(request->cpaddr + 1,FORSPACEFILE, 0, NULL);\r\ntape_ccw_cc(request->cpaddr + 2, NOP, 0, NULL);\r\ntape_ccw_end(request->cpaddr + 3, CCW_CMD_TIC, 0, request->cpaddr);\r\ntape_do_io_interruptible(device, request);\r\ntape_free_request(request);\r\nreturn tape_mtop(device, MTREW, 1);\r\n}\r\nint\r\ntape_std_mterase(struct tape_device *device, int mt_count)\r\n{\r\nstruct tape_request *request;\r\nrequest = tape_alloc_request(6, 0);\r\nif (IS_ERR(request))\r\nreturn PTR_ERR(request);\r\nrequest->op = TO_DSE;\r\ntape_ccw_cc(request->cpaddr, MODE_SET_DB, 1, device->modeset_byte);\r\ntape_ccw_cc(request->cpaddr + 1, REWIND, 0, NULL);\r\ntape_ccw_cc(request->cpaddr + 2, ERASE_GAP, 0, NULL);\r\ntape_ccw_cc(request->cpaddr + 3, DATA_SEC_ERASE, 0, NULL);\r\ntape_ccw_cc(request->cpaddr + 4, REWIND, 0, NULL);\r\ntape_ccw_end(request->cpaddr + 5, NOP, 0, NULL);\r\nreturn tape_do_io_free(device, request);\r\n}\r\nint\r\ntape_std_mtunload(struct tape_device *device, int mt_count)\r\n{\r\nreturn tape_mtop(device, MTOFFL, mt_count);\r\n}\r\nint\r\ntape_std_mtcompression(struct tape_device *device, int mt_count)\r\n{\r\nstruct tape_request *request;\r\nif (mt_count < 0 || mt_count > 1) {\r\nDBF_EXCEPTION(6, "xcom parm\n");\r\nreturn -EINVAL;\r\n}\r\nrequest = tape_alloc_request(2, 0);\r\nif (IS_ERR(request))\r\nreturn PTR_ERR(request);\r\nrequest->op = TO_NOP;\r\nif (mt_count == 0)\r\n*device->modeset_byte &= ~0x08;\r\nelse\r\n*device->modeset_byte |= 0x08;\r\ntape_ccw_cc(request->cpaddr, MODE_SET_DB, 1, device->modeset_byte);\r\ntape_ccw_end(request->cpaddr + 1, NOP, 0, NULL);\r\nreturn tape_do_io_free(device, request);\r\n}\r\nstruct tape_request *\r\ntape_std_read_block(struct tape_device *device, size_t count)\r\n{\r\nstruct tape_request *request;\r\nrequest = tape_alloc_request(4, 0);\r\nif (IS_ERR(request)) {\r\nDBF_EXCEPTION(6, "xrbl fail");\r\nreturn request;\r\n}\r\nrequest->op = TO_RFO;\r\ntape_ccw_cc(request->cpaddr, MODE_SET_DB, 1, device->modeset_byte);\r\ntape_ccw_end_idal(request->cpaddr + 1, READ_FORWARD,\r\ndevice->char_data.idal_buf);\r\nDBF_EVENT(6, "xrbl ccwg\n");\r\nreturn request;\r\n}\r\nvoid\r\ntape_std_read_backward(struct tape_device *device, struct tape_request *request)\r\n{\r\nrequest->op = TO_RBA;\r\ntape_ccw_cc(request->cpaddr, MODE_SET_DB, 1, device->modeset_byte);\r\ntape_ccw_cc_idal(request->cpaddr + 1, READ_BACKWARD,\r\ndevice->char_data.idal_buf);\r\ntape_ccw_cc(request->cpaddr + 2, FORSPACEBLOCK, 0, NULL);\r\ntape_ccw_end(request->cpaddr + 3, NOP, 0, NULL);\r\nDBF_EVENT(6, "xrop ccwg");}\r\nstruct tape_request *\r\ntape_std_write_block(struct tape_device *device, size_t count)\r\n{\r\nstruct tape_request *request;\r\nrequest = tape_alloc_request(2, 0);\r\nif (IS_ERR(request)) {\r\nDBF_EXCEPTION(6, "xwbl fail\n");\r\nreturn request;\r\n}\r\nrequest->op = TO_WRI;\r\ntape_ccw_cc(request->cpaddr, MODE_SET_DB, 1, device->modeset_byte);\r\ntape_ccw_end_idal(request->cpaddr + 1, WRITE_CMD,\r\ndevice->char_data.idal_buf);\r\nDBF_EVENT(6, "xwbl ccwg\n");\r\nreturn request;\r\n}\r\nvoid\r\ntape_std_process_eov(struct tape_device *device)\r\n{\r\nif (tape_mtop(device, MTBSR, 1) == 0 &&\r\ntape_mtop(device, MTWEOF, 1) == 0) {\r\ntape_mtop(device, MTBSR, 1);\r\n}\r\n}
