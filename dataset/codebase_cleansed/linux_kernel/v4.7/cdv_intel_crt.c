static void cdv_intel_crt_dpms(struct drm_encoder *encoder, int mode)\r\n{\r\nstruct drm_device *dev = encoder->dev;\r\nu32 temp, reg;\r\nreg = ADPA;\r\ntemp = REG_READ(reg);\r\ntemp &= ~(ADPA_HSYNC_CNTL_DISABLE | ADPA_VSYNC_CNTL_DISABLE);\r\ntemp &= ~ADPA_DAC_ENABLE;\r\nswitch (mode) {\r\ncase DRM_MODE_DPMS_ON:\r\ntemp |= ADPA_DAC_ENABLE;\r\nbreak;\r\ncase DRM_MODE_DPMS_STANDBY:\r\ntemp |= ADPA_DAC_ENABLE | ADPA_HSYNC_CNTL_DISABLE;\r\nbreak;\r\ncase DRM_MODE_DPMS_SUSPEND:\r\ntemp |= ADPA_DAC_ENABLE | ADPA_VSYNC_CNTL_DISABLE;\r\nbreak;\r\ncase DRM_MODE_DPMS_OFF:\r\ntemp |= ADPA_HSYNC_CNTL_DISABLE | ADPA_VSYNC_CNTL_DISABLE;\r\nbreak;\r\n}\r\nREG_WRITE(reg, temp);\r\n}\r\nstatic int cdv_intel_crt_mode_valid(struct drm_connector *connector,\r\nstruct drm_display_mode *mode)\r\n{\r\nif (mode->flags & DRM_MODE_FLAG_DBLSCAN)\r\nreturn MODE_NO_DBLESCAN;\r\nif (mode->clock < 20000)\r\nreturn MODE_CLOCK_LOW;\r\nif (mode->clock > 355000)\r\nreturn MODE_CLOCK_HIGH;\r\nreturn MODE_OK;\r\n}\r\nstatic void cdv_intel_crt_mode_set(struct drm_encoder *encoder,\r\nstruct drm_display_mode *mode,\r\nstruct drm_display_mode *adjusted_mode)\r\n{\r\nstruct drm_device *dev = encoder->dev;\r\nstruct drm_crtc *crtc = encoder->crtc;\r\nstruct gma_crtc *gma_crtc = to_gma_crtc(crtc);\r\nint dpll_md_reg;\r\nu32 adpa, dpll_md;\r\nu32 adpa_reg;\r\nif (gma_crtc->pipe == 0)\r\ndpll_md_reg = DPLL_A_MD;\r\nelse\r\ndpll_md_reg = DPLL_B_MD;\r\nadpa_reg = ADPA;\r\n{\r\ndpll_md = REG_READ(dpll_md_reg);\r\nREG_WRITE(dpll_md_reg,\r\ndpll_md & ~DPLL_MD_UDI_MULTIPLIER_MASK);\r\n}\r\nadpa = 0;\r\nif (adjusted_mode->flags & DRM_MODE_FLAG_PHSYNC)\r\nadpa |= ADPA_HSYNC_ACTIVE_HIGH;\r\nif (adjusted_mode->flags & DRM_MODE_FLAG_PVSYNC)\r\nadpa |= ADPA_VSYNC_ACTIVE_HIGH;\r\nif (gma_crtc->pipe == 0)\r\nadpa |= ADPA_PIPE_A_SELECT;\r\nelse\r\nadpa |= ADPA_PIPE_B_SELECT;\r\nREG_WRITE(adpa_reg, adpa);\r\n}\r\nstatic bool cdv_intel_crt_detect_hotplug(struct drm_connector *connector,\r\nbool force)\r\n{\r\nstruct drm_device *dev = connector->dev;\r\nu32 hotplug_en;\r\nint i, tries = 0, ret = false;\r\nu32 orig;\r\ntries = 2;\r\norig = hotplug_en = REG_READ(PORT_HOTPLUG_EN);\r\nhotplug_en &= ~(CRT_HOTPLUG_DETECT_MASK);\r\nhotplug_en |= CRT_HOTPLUG_FORCE_DETECT;\r\nhotplug_en |= CRT_HOTPLUG_ACTIVATION_PERIOD_64;\r\nhotplug_en |= CRT_HOTPLUG_VOLTAGE_COMPARE_50;\r\nfor (i = 0; i < tries ; i++) {\r\nunsigned long timeout;\r\nREG_WRITE(PORT_HOTPLUG_EN, hotplug_en);\r\ntimeout = jiffies + msecs_to_jiffies(1000);\r\ndo {\r\nif (!(REG_READ(PORT_HOTPLUG_EN) &\r\nCRT_HOTPLUG_FORCE_DETECT))\r\nbreak;\r\nmsleep(1);\r\n} while (time_after(timeout, jiffies));\r\n}\r\nif ((REG_READ(PORT_HOTPLUG_STAT) & CRT_HOTPLUG_MONITOR_MASK) !=\r\nCRT_HOTPLUG_MONITOR_NONE)\r\nret = true;\r\nREG_WRITE(PORT_HOTPLUG_STAT, CRT_HOTPLUG_INT_STATUS);\r\nREG_WRITE(PORT_HOTPLUG_EN, orig);\r\nreturn ret;\r\n}\r\nstatic enum drm_connector_status cdv_intel_crt_detect(\r\nstruct drm_connector *connector, bool force)\r\n{\r\nif (cdv_intel_crt_detect_hotplug(connector, force))\r\nreturn connector_status_connected;\r\nelse\r\nreturn connector_status_disconnected;\r\n}\r\nstatic void cdv_intel_crt_destroy(struct drm_connector *connector)\r\n{\r\nstruct gma_encoder *gma_encoder = gma_attached_encoder(connector);\r\npsb_intel_i2c_destroy(gma_encoder->ddc_bus);\r\ndrm_connector_unregister(connector);\r\ndrm_connector_cleanup(connector);\r\nkfree(connector);\r\n}\r\nstatic int cdv_intel_crt_get_modes(struct drm_connector *connector)\r\n{\r\nstruct gma_encoder *gma_encoder = gma_attached_encoder(connector);\r\nreturn psb_intel_ddc_get_modes(connector,\r\n&gma_encoder->ddc_bus->adapter);\r\n}\r\nstatic int cdv_intel_crt_set_property(struct drm_connector *connector,\r\nstruct drm_property *property,\r\nuint64_t value)\r\n{\r\nreturn 0;\r\n}\r\nstatic void cdv_intel_crt_enc_destroy(struct drm_encoder *encoder)\r\n{\r\ndrm_encoder_cleanup(encoder);\r\n}\r\nvoid cdv_intel_crt_init(struct drm_device *dev,\r\nstruct psb_intel_mode_device *mode_dev)\r\n{\r\nstruct gma_connector *gma_connector;\r\nstruct gma_encoder *gma_encoder;\r\nstruct drm_connector *connector;\r\nstruct drm_encoder *encoder;\r\nu32 i2c_reg;\r\ngma_encoder = kzalloc(sizeof(struct gma_encoder), GFP_KERNEL);\r\nif (!gma_encoder)\r\nreturn;\r\ngma_connector = kzalloc(sizeof(struct gma_connector), GFP_KERNEL);\r\nif (!gma_connector)\r\ngoto failed_connector;\r\nconnector = &gma_connector->base;\r\nconnector->polled = DRM_CONNECTOR_POLL_HPD;\r\ndrm_connector_init(dev, connector,\r\n&cdv_intel_crt_connector_funcs, DRM_MODE_CONNECTOR_VGA);\r\nencoder = &gma_encoder->base;\r\ndrm_encoder_init(dev, encoder,\r\n&cdv_intel_crt_enc_funcs, DRM_MODE_ENCODER_DAC, NULL);\r\ngma_connector_attach_encoder(gma_connector, gma_encoder);\r\ni2c_reg = GPIOA;\r\ngma_encoder->ddc_bus = psb_intel_i2c_create(dev,\r\ni2c_reg, "CRTDDC_A");\r\nif (!gma_encoder->ddc_bus) {\r\ndev_printk(KERN_ERR, &dev->pdev->dev, "DDC bus registration "\r\n"failed.\n");\r\ngoto failed_ddc;\r\n}\r\ngma_encoder->type = INTEL_OUTPUT_ANALOG;\r\nconnector->interlace_allowed = 0;\r\nconnector->doublescan_allowed = 0;\r\ndrm_encoder_helper_add(encoder, &cdv_intel_crt_helper_funcs);\r\ndrm_connector_helper_add(connector,\r\n&cdv_intel_crt_connector_helper_funcs);\r\ndrm_connector_register(connector);\r\nreturn;\r\nfailed_ddc:\r\ndrm_encoder_cleanup(&gma_encoder->base);\r\ndrm_connector_cleanup(&gma_connector->base);\r\nkfree(gma_connector);\r\nfailed_connector:\r\nkfree(gma_encoder);\r\nreturn;\r\n}
