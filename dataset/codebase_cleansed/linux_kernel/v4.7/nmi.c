static void s390_handle_damage(void)\r\n{\r\nsmp_send_stop();\r\ndisabled_wait((unsigned long) __builtin_return_address(0));\r\nwhile (1);\r\n}\r\nvoid s390_handle_mcck(void)\r\n{\r\nunsigned long flags;\r\nstruct mcck_struct mcck;\r\nlocal_irq_save(flags);\r\nlocal_mcck_disable();\r\nmcck = *this_cpu_ptr(&cpu_mcck);\r\nmemset(this_cpu_ptr(&cpu_mcck), 0, sizeof(mcck));\r\nclear_cpu_flag(CIF_MCCK_PENDING);\r\nlocal_mcck_enable();\r\nlocal_irq_restore(flags);\r\nif (mcck.channel_report)\r\ncrw_handle_channel_report();\r\nif (mcck.warning) {\r\nstatic int mchchk_wng_posted = 0;\r\n__ctl_clear_bit(14, 24);\r\nif (xchg(&mchchk_wng_posted, 1) == 0)\r\nkill_cad_pid(SIGPWR, 1);\r\n}\r\nif (mcck.etr_queue)\r\netr_queue_work();\r\nif (mcck.stp_queue)\r\nstp_queue_work();\r\nif (mcck.kill_task) {\r\nlocal_irq_enable();\r\nprintk(KERN_EMERG "mcck: Terminating task because of machine "\r\n"malfunction (code 0x%016lx).\n", mcck.mcck_code);\r\nprintk(KERN_EMERG "mcck: task: %s, pid: %d.\n",\r\ncurrent->comm, current->pid);\r\ndo_exit(SIGSEGV);\r\n}\r\n}\r\nstatic int notrace s390_validate_registers(union mci mci)\r\n{\r\nint kill_task;\r\nu64 zero;\r\nvoid *fpt_save_area, *fpt_creg_save_area;\r\nkill_task = 0;\r\nzero = 0;\r\nif (!mci.gr) {\r\nkill_task = 1;\r\n}\r\nif (!mci.fp) {\r\nkill_task = 1;\r\n}\r\nfpt_save_area = &S390_lowcore.floating_pt_save_area;\r\nfpt_creg_save_area = &S390_lowcore.fpt_creg_save_area;\r\nif (!mci.fc) {\r\nasm volatile("lfpc 0(%0)" : : "a" (&zero), "m" (zero));\r\nkill_task = 1;\r\n} else\r\nasm volatile("lfpc 0(%0)" : : "a" (fpt_creg_save_area));\r\nif (!MACHINE_HAS_VX) {\r\nasm volatile(\r\n" ld 0,0(%0)\n"\r\n" ld 1,8(%0)\n"\r\n" ld 2,16(%0)\n"\r\n" ld 3,24(%0)\n"\r\n" ld 4,32(%0)\n"\r\n" ld 5,40(%0)\n"\r\n" ld 6,48(%0)\n"\r\n" ld 7,56(%0)\n"\r\n" ld 8,64(%0)\n"\r\n" ld 9,72(%0)\n"\r\n" ld 10,80(%0)\n"\r\n" ld 11,88(%0)\n"\r\n" ld 12,96(%0)\n"\r\n" ld 13,104(%0)\n"\r\n" ld 14,112(%0)\n"\r\n" ld 15,120(%0)\n"\r\n: : "a" (fpt_save_area));\r\n} else {\r\nunion ctlreg0 cr0;\r\nif (!mci.vr) {\r\nkill_task = 1;\r\n}\r\ncr0.val = S390_lowcore.cregs_save_area[0];\r\ncr0.afp = cr0.vx = 1;\r\n__ctl_load(cr0.val, 0, 0);\r\nasm volatile(\r\n" la 1,%0\n"\r\n" .word 0xe70f,0x1000,0x0036\n"\r\n" .word 0xe70f,0x1100,0x0c36\n"\r\n: : "Q" (*(struct vx_array *)\r\n&S390_lowcore.vector_save_area) : "1");\r\n__ctl_load(S390_lowcore.cregs_save_area[0], 0, 0);\r\n}\r\nasm volatile(\r\n" lam 0,15,0(%0)"\r\n: : "a" (&S390_lowcore.access_regs_save_area));\r\nif (!mci.ar) {\r\nkill_task = 1;\r\n}\r\nif (!mci.cr) {\r\ns390_handle_damage();\r\n} else {\r\nasm volatile(\r\n" lctlg 0,15,0(%0)"\r\n: : "a" (&S390_lowcore.cregs_save_area));\r\n}\r\nif (!mci.pr)\r\nasm volatile(\r\n" sr 0,0\n"\r\n" sckpf"\r\n: : : "0", "cc");\r\nelse\r\nasm volatile(\r\n" l 0,0(%0)\n"\r\n" sckpf"\r\n: : "a" (&S390_lowcore.tod_progreg_save_area)\r\n: "0", "cc");\r\nset_clock_comparator(S390_lowcore.clock_comparator);\r\nif (!mci.wp)\r\ns390_handle_damage();\r\nif (!mci.ms || !mci.pm || !mci.ia)\r\nkill_task = 1;\r\nreturn kill_task;\r\n}\r\nvoid notrace s390_do_machine_check(struct pt_regs *regs)\r\n{\r\nstatic int ipd_count;\r\nstatic DEFINE_SPINLOCK(ipd_lock);\r\nstatic unsigned long long last_ipd;\r\nstruct mcck_struct *mcck;\r\nunsigned long long tmp;\r\nunion mci mci;\r\nint umode;\r\nnmi_enter();\r\ninc_irq_stat(NMI_NMI);\r\nmci.val = S390_lowcore.mcck_interruption_code;\r\nmcck = this_cpu_ptr(&cpu_mcck);\r\numode = user_mode(regs);\r\nif (mci.sd) {\r\ns390_handle_damage();\r\n}\r\nif (mci.pd) {\r\nif (mci.b) {\r\nu64 z_mcic, o_mcic, t_mcic;\r\nz_mcic = (1ULL<<63 | 1ULL<<59 | 1ULL<<29);\r\no_mcic = (1ULL<<43 | 1ULL<<42 | 1ULL<<41 | 1ULL<<40 |\r\n1ULL<<36 | 1ULL<<35 | 1ULL<<34 | 1ULL<<32 |\r\n1ULL<<30 | 1ULL<<21 | 1ULL<<20 | 1ULL<<17 |\r\n1ULL<<16);\r\nt_mcic = mci.val;\r\nif (((t_mcic & z_mcic) != 0) ||\r\n((t_mcic & o_mcic) != o_mcic)) {\r\ns390_handle_damage();\r\n}\r\nspin_lock(&ipd_lock);\r\ntmp = get_tod_clock();\r\nif (((tmp - last_ipd) >> 12) < MAX_IPD_TIME)\r\nipd_count++;\r\nelse\r\nipd_count = 1;\r\nlast_ipd = tmp;\r\nif (ipd_count == MAX_IPD_COUNT)\r\ns390_handle_damage();\r\nspin_unlock(&ipd_lock);\r\n} else {\r\ns390_handle_damage();\r\n}\r\n}\r\nif (s390_validate_registers(mci)) {\r\nif (umode) {\r\nmcck->kill_task = 1;\r\nmcck->mcck_code = mci.val;\r\nset_cpu_flag(CIF_MCCK_PENDING);\r\n} else {\r\ns390_handle_damage();\r\n}\r\n}\r\nif (mci.cd) {\r\ns390_handle_damage();\r\n}\r\nif (mci.ed && mci.ec) {\r\nif (S390_lowcore.external_damage_code & (1U << ED_ETR_SYNC))\r\nmcck->etr_queue |= etr_sync_check();\r\nif (S390_lowcore.external_damage_code & (1U << ED_ETR_SWITCH))\r\nmcck->etr_queue |= etr_switch_to_local();\r\nif (S390_lowcore.external_damage_code & (1U << ED_STP_SYNC))\r\nmcck->stp_queue |= stp_sync_check();\r\nif (S390_lowcore.external_damage_code & (1U << ED_STP_ISLAND))\r\nmcck->stp_queue |= stp_island_check();\r\nif (mcck->etr_queue || mcck->stp_queue)\r\nset_cpu_flag(CIF_MCCK_PENDING);\r\n}\r\nif (mci.se)\r\ns390_handle_damage();\r\nif (mci.ke)\r\ns390_handle_damage();\r\nif (mci.ds && mci.fa)\r\ns390_handle_damage();\r\nif (mci.cp) {\r\nmcck->channel_report = 1;\r\nset_cpu_flag(CIF_MCCK_PENDING);\r\n}\r\nif (mci.w) {\r\nmcck->warning = 1;\r\nset_cpu_flag(CIF_MCCK_PENDING);\r\n}\r\nnmi_exit();\r\n}\r\nstatic int __init machine_check_init(void)\r\n{\r\nctl_set_bit(14, 25);\r\nctl_set_bit(14, 27);\r\nctl_set_bit(14, 24);\r\nreturn 0;\r\n}
