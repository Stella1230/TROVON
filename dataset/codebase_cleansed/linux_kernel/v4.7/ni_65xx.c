static unsigned int ni_65xx_num_ports(struct comedi_device *dev)\r\n{\r\nconst struct ni_65xx_board *board = dev->board_ptr;\r\nreturn board->num_dio_ports + board->num_di_ports + board->num_do_ports;\r\n}\r\nstatic void ni_65xx_disable_input_filters(struct comedi_device *dev)\r\n{\r\nunsigned int num_ports = ni_65xx_num_ports(dev);\r\nint i;\r\nfor (i = 0; i < num_ports; ++i)\r\nwriteb(0x00, dev->mmio + NI_65XX_FILTER_ENA(i));\r\nwritel(0x00000000, dev->mmio + NI_65XX_FILTER_REG);\r\n}\r\nstatic void ni_65xx_update_edge_detection(struct comedi_device *dev,\r\nunsigned int base_chan,\r\nunsigned int rising,\r\nunsigned int falling)\r\n{\r\nunsigned int num_ports = ni_65xx_num_ports(dev);\r\nunsigned int port;\r\nif (base_chan >= NI_65XX_PORT_TO_CHAN(num_ports))\r\nreturn;\r\nfor (port = NI_65XX_CHAN_TO_PORT(base_chan); port < num_ports; port++) {\r\nint bitshift = (int)(NI_65XX_PORT_TO_CHAN(port) - base_chan);\r\nunsigned int port_mask, port_rising, port_falling;\r\nif (bitshift >= 32)\r\nbreak;\r\nif (bitshift >= 0) {\r\nport_mask = ~0U >> bitshift;\r\nport_rising = rising >> bitshift;\r\nport_falling = falling >> bitshift;\r\n} else {\r\nport_mask = ~0U << -bitshift;\r\nport_rising = rising << -bitshift;\r\nport_falling = falling << -bitshift;\r\n}\r\nif (port_mask & 0xff) {\r\nif (~port_mask & 0xff) {\r\nport_rising |=\r\nreadb(dev->mmio +\r\nNI_65XX_RISE_EDGE_ENA_REG(port)) &\r\n~port_mask;\r\nport_falling |=\r\nreadb(dev->mmio +\r\nNI_65XX_FALL_EDGE_ENA_REG(port)) &\r\n~port_mask;\r\n}\r\nwriteb(port_rising & 0xff,\r\ndev->mmio + NI_65XX_RISE_EDGE_ENA_REG(port));\r\nwriteb(port_falling & 0xff,\r\ndev->mmio + NI_65XX_FALL_EDGE_ENA_REG(port));\r\n}\r\n}\r\n}\r\nstatic void ni_65xx_disable_edge_detection(struct comedi_device *dev)\r\n{\r\nni_65xx_update_edge_detection(dev, 0, 0, 0);\r\nni_65xx_update_edge_detection(dev, 32, 0, 0);\r\nni_65xx_update_edge_detection(dev, 64, 0, 0);\r\n}\r\nstatic int ni_65xx_dio_insn_config(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_insn *insn,\r\nunsigned int *data)\r\n{\r\nunsigned long base_port = (unsigned long)s->private;\r\nunsigned int chan = CR_CHAN(insn->chanspec);\r\nunsigned int chan_mask = NI_65XX_CHAN_TO_MASK(chan);\r\nunsigned port = base_port + NI_65XX_CHAN_TO_PORT(chan);\r\nunsigned int interval;\r\nunsigned int val;\r\nswitch (data[0]) {\r\ncase INSN_CONFIG_FILTER:\r\ninterval = (data[1] + 100) / 200;\r\nif (interval > 0xfffff)\r\ninterval = 0xfffff;\r\ndata[1] = interval * 200;\r\nval = readb(dev->mmio + NI_65XX_FILTER_ENA(port));\r\nif (interval) {\r\nwritel(interval, dev->mmio + NI_65XX_FILTER_REG);\r\nval |= chan_mask;\r\n} else {\r\nval &= ~chan_mask;\r\n}\r\nwriteb(val, dev->mmio + NI_65XX_FILTER_ENA(port));\r\nbreak;\r\ncase INSN_CONFIG_DIO_OUTPUT:\r\nif (s->type != COMEDI_SUBD_DIO)\r\nreturn -EINVAL;\r\nwriteb(NI_65XX_IO_SEL_OUTPUT,\r\ndev->mmio + NI_65XX_IO_SEL_REG(port));\r\nbreak;\r\ncase INSN_CONFIG_DIO_INPUT:\r\nif (s->type != COMEDI_SUBD_DIO)\r\nreturn -EINVAL;\r\nwriteb(NI_65XX_IO_SEL_INPUT,\r\ndev->mmio + NI_65XX_IO_SEL_REG(port));\r\nbreak;\r\ncase INSN_CONFIG_DIO_QUERY:\r\nif (s->type != COMEDI_SUBD_DIO)\r\nreturn -EINVAL;\r\nval = readb(dev->mmio + NI_65XX_IO_SEL_REG(port));\r\ndata[1] = (val == NI_65XX_IO_SEL_INPUT) ? COMEDI_INPUT\r\n: COMEDI_OUTPUT;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn insn->n;\r\n}\r\nstatic int ni_65xx_dio_insn_bits(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_insn *insn,\r\nunsigned int *data)\r\n{\r\nunsigned long base_port = (unsigned long)s->private;\r\nunsigned int base_chan = CR_CHAN(insn->chanspec);\r\nint last_port_offset = NI_65XX_CHAN_TO_PORT(s->n_chan - 1);\r\nunsigned read_bits = 0;\r\nint port_offset;\r\nfor (port_offset = NI_65XX_CHAN_TO_PORT(base_chan);\r\nport_offset <= last_port_offset; port_offset++) {\r\nunsigned port = base_port + port_offset;\r\nint base_port_channel = NI_65XX_PORT_TO_CHAN(port_offset);\r\nunsigned port_mask, port_data, bits;\r\nint bitshift = base_port_channel - base_chan;\r\nif (bitshift >= 32)\r\nbreak;\r\nport_mask = data[0];\r\nport_data = data[1];\r\nif (bitshift > 0) {\r\nport_mask >>= bitshift;\r\nport_data >>= bitshift;\r\n} else {\r\nport_mask <<= -bitshift;\r\nport_data <<= -bitshift;\r\n}\r\nport_mask &= 0xff;\r\nport_data &= 0xff;\r\nif (port_mask) {\r\nbits = readb(dev->mmio + NI_65XX_IO_DATA_REG(port));\r\nbits ^= s->io_bits;\r\nbits &= ~port_mask;\r\nbits |= (port_data & port_mask);\r\nbits ^= s->io_bits;\r\nwriteb(bits, dev->mmio + NI_65XX_IO_DATA_REG(port));\r\n}\r\nbits = readb(dev->mmio + NI_65XX_IO_DATA_REG(port));\r\nbits ^= s->io_bits;\r\nif (bitshift > 0)\r\nbits <<= bitshift;\r\nelse\r\nbits >>= -bitshift;\r\nread_bits |= bits;\r\n}\r\ndata[1] = read_bits;\r\nreturn insn->n;\r\n}\r\nstatic irqreturn_t ni_65xx_interrupt(int irq, void *d)\r\n{\r\nstruct comedi_device *dev = d;\r\nstruct comedi_subdevice *s = dev->read_subdev;\r\nunsigned int status;\r\nstatus = readb(dev->mmio + NI_65XX_STATUS_REG);\r\nif ((status & NI_65XX_STATUS_INT) == 0)\r\nreturn IRQ_NONE;\r\nif ((status & NI_65XX_STATUS_EDGE_INT) == 0)\r\nreturn IRQ_NONE;\r\nwriteb(NI_65XX_CLR_EDGE_INT | NI_65XX_CLR_OVERFLOW_INT,\r\ndev->mmio + NI_65XX_CLR_REG);\r\ncomedi_buf_write_samples(s, &s->state, 1);\r\ncomedi_handle_events(dev, s);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int ni_65xx_intr_cmdtest(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_cmd *cmd)\r\n{\r\nint err = 0;\r\nerr |= comedi_check_trigger_src(&cmd->start_src, TRIG_NOW);\r\nerr |= comedi_check_trigger_src(&cmd->scan_begin_src, TRIG_OTHER);\r\nerr |= comedi_check_trigger_src(&cmd->convert_src, TRIG_FOLLOW);\r\nerr |= comedi_check_trigger_src(&cmd->scan_end_src, TRIG_COUNT);\r\nerr |= comedi_check_trigger_src(&cmd->stop_src, TRIG_COUNT);\r\nif (err)\r\nreturn 1;\r\nerr |= comedi_check_trigger_arg_is(&cmd->start_arg, 0);\r\nerr |= comedi_check_trigger_arg_is(&cmd->scan_begin_arg, 0);\r\nerr |= comedi_check_trigger_arg_is(&cmd->convert_arg, 0);\r\nerr |= comedi_check_trigger_arg_is(&cmd->scan_end_arg,\r\ncmd->chanlist_len);\r\nerr |= comedi_check_trigger_arg_is(&cmd->stop_arg, 0);\r\nif (err)\r\nreturn 3;\r\nreturn 0;\r\n}\r\nstatic int ni_65xx_intr_cmd(struct comedi_device *dev,\r\nstruct comedi_subdevice *s)\r\n{\r\nwriteb(NI_65XX_CLR_EDGE_INT | NI_65XX_CLR_OVERFLOW_INT,\r\ndev->mmio + NI_65XX_CLR_REG);\r\nwriteb(NI_65XX_CTRL_FALL_EDGE_ENA | NI_65XX_CTRL_RISE_EDGE_ENA |\r\nNI_65XX_CTRL_INT_ENA | NI_65XX_CTRL_EDGE_ENA,\r\ndev->mmio + NI_65XX_CTRL_REG);\r\nreturn 0;\r\n}\r\nstatic int ni_65xx_intr_cancel(struct comedi_device *dev,\r\nstruct comedi_subdevice *s)\r\n{\r\nwriteb(0x00, dev->mmio + NI_65XX_CTRL_REG);\r\nreturn 0;\r\n}\r\nstatic int ni_65xx_intr_insn_bits(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_insn *insn,\r\nunsigned int *data)\r\n{\r\ndata[1] = 0;\r\nreturn insn->n;\r\n}\r\nstatic int ni_65xx_intr_insn_config(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_insn *insn,\r\nunsigned int *data)\r\n{\r\nswitch (data[0]) {\r\ncase INSN_CONFIG_CHANGE_NOTIFY:\r\nif (insn->n != 3)\r\nreturn -EINVAL;\r\nni_65xx_update_edge_detection(dev, 0, data[1], data[2]);\r\nni_65xx_update_edge_detection(dev, 32, 0, 0);\r\nni_65xx_update_edge_detection(dev, 64, 0, 0);\r\nbreak;\r\ncase INSN_CONFIG_DIGITAL_TRIG:\r\nif (data[1] != 0)\r\nreturn -EINVAL;\r\nswitch (data[2]) {\r\ncase COMEDI_DIGITAL_TRIG_DISABLE:\r\nni_65xx_disable_edge_detection(dev);\r\nbreak;\r\ncase COMEDI_DIGITAL_TRIG_ENABLE_EDGES:\r\nni_65xx_update_edge_detection(dev, data[3],\r\ndata[4], data[5]);\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn insn->n;\r\n}\r\nstatic int ni_65xx_mite_init(struct pci_dev *pcidev)\r\n{\r\nvoid __iomem *mite_base;\r\nu32 main_phys_addr;\r\nmite_base = pci_ioremap_bar(pcidev, 0);\r\nif (!mite_base)\r\nreturn -ENOMEM;\r\nmain_phys_addr = pci_resource_start(pcidev, 1);\r\nwritel(main_phys_addr | WENAB, mite_base + MITE_IODWBSR);\r\niounmap(mite_base);\r\nreturn 0;\r\n}\r\nstatic int ni_65xx_auto_attach(struct comedi_device *dev,\r\nunsigned long context)\r\n{\r\nstruct pci_dev *pcidev = comedi_to_pci_dev(dev);\r\nconst struct ni_65xx_board *board = NULL;\r\nstruct comedi_subdevice *s;\r\nunsigned i;\r\nint ret;\r\nif (context < ARRAY_SIZE(ni_65xx_boards))\r\nboard = &ni_65xx_boards[context];\r\nif (!board)\r\nreturn -ENODEV;\r\ndev->board_ptr = board;\r\ndev->board_name = board->name;\r\nret = comedi_pci_enable(dev);\r\nif (ret)\r\nreturn ret;\r\nret = ni_65xx_mite_init(pcidev);\r\nif (ret)\r\nreturn ret;\r\ndev->mmio = pci_ioremap_bar(pcidev, 1);\r\nif (!dev->mmio)\r\nreturn -ENOMEM;\r\nwriteb(NI_65XX_CLR_EDGE_INT | NI_65XX_CLR_OVERFLOW_INT,\r\ndev->mmio + NI_65XX_CLR_REG);\r\nwriteb(0x00, dev->mmio + NI_65XX_CTRL_REG);\r\nif (pcidev->irq) {\r\nret = request_irq(pcidev->irq, ni_65xx_interrupt, IRQF_SHARED,\r\ndev->board_name, dev);\r\nif (ret == 0)\r\ndev->irq = pcidev->irq;\r\n}\r\ndev_info(dev->class_dev, "board: %s, ID=0x%02x", dev->board_name,\r\nreadb(dev->mmio + NI_65XX_ID_REG));\r\nret = comedi_alloc_subdevices(dev, 4);\r\nif (ret)\r\nreturn ret;\r\ns = &dev->subdevices[0];\r\nif (board->num_di_ports) {\r\ns->type = COMEDI_SUBD_DI;\r\ns->subdev_flags = SDF_READABLE;\r\ns->n_chan = NI_65XX_PORT_TO_CHAN(board->num_di_ports);\r\ns->maxdata = 1;\r\ns->range_table = &range_digital;\r\ns->insn_bits = ni_65xx_dio_insn_bits;\r\ns->insn_config = ni_65xx_dio_insn_config;\r\ns->private = (void *)0;\r\n} else {\r\ns->type = COMEDI_SUBD_UNUSED;\r\n}\r\ns = &dev->subdevices[1];\r\nif (board->num_do_ports) {\r\ns->type = COMEDI_SUBD_DO;\r\ns->subdev_flags = SDF_WRITABLE;\r\ns->n_chan = NI_65XX_PORT_TO_CHAN(board->num_do_ports);\r\ns->maxdata = 1;\r\ns->range_table = &range_digital;\r\ns->insn_bits = ni_65xx_dio_insn_bits;\r\ns->private = (void *)(unsigned long)board->num_di_ports;\r\nif (ni_65xx_legacy_invert_outputs && board->legacy_invert)\r\ns->io_bits = 0xff;\r\nfor (i = 0; i < board->num_do_ports; ++i) {\r\nwriteb(s->io_bits,\r\ndev->mmio +\r\nNI_65XX_IO_DATA_REG(board->num_di_ports + i));\r\n}\r\n} else {\r\ns->type = COMEDI_SUBD_UNUSED;\r\n}\r\ns = &dev->subdevices[2];\r\nif (board->num_dio_ports) {\r\ns->type = COMEDI_SUBD_DIO;\r\ns->subdev_flags = SDF_READABLE | SDF_WRITABLE;\r\ns->n_chan = NI_65XX_PORT_TO_CHAN(board->num_dio_ports);\r\ns->maxdata = 1;\r\ns->range_table = &range_digital;\r\ns->insn_bits = ni_65xx_dio_insn_bits;\r\ns->insn_config = ni_65xx_dio_insn_config;\r\ns->private = (void *)0;\r\nfor (i = 0; i < board->num_dio_ports; ++i) {\r\nwriteb(NI_65XX_IO_SEL_INPUT,\r\ndev->mmio + NI_65XX_IO_SEL_REG(i));\r\n}\r\n} else {\r\ns->type = COMEDI_SUBD_UNUSED;\r\n}\r\ns = &dev->subdevices[3];\r\ns->type = COMEDI_SUBD_DI;\r\ns->subdev_flags = SDF_READABLE;\r\ns->n_chan = 1;\r\ns->maxdata = 1;\r\ns->range_table = &range_digital;\r\ns->insn_bits = ni_65xx_intr_insn_bits;\r\nif (dev->irq) {\r\ndev->read_subdev = s;\r\ns->subdev_flags |= SDF_CMD_READ;\r\ns->len_chanlist = 1;\r\ns->insn_config = ni_65xx_intr_insn_config;\r\ns->do_cmdtest = ni_65xx_intr_cmdtest;\r\ns->do_cmd = ni_65xx_intr_cmd;\r\ns->cancel = ni_65xx_intr_cancel;\r\n}\r\nni_65xx_disable_input_filters(dev);\r\nni_65xx_disable_edge_detection(dev);\r\nreturn 0;\r\n}\r\nstatic void ni_65xx_detach(struct comedi_device *dev)\r\n{\r\nif (dev->mmio)\r\nwriteb(0x00, dev->mmio + NI_65XX_CTRL_REG);\r\ncomedi_pci_detach(dev);\r\n}\r\nstatic int ni_65xx_pci_probe(struct pci_dev *dev,\r\nconst struct pci_device_id *id)\r\n{\r\nreturn comedi_pci_auto_config(dev, &ni_65xx_driver, id->driver_data);\r\n}
