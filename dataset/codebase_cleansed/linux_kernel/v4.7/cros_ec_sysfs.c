static ssize_t show_ec_reboot(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nint count = 0;\r\ncount += scnprintf(buf + count, PAGE_SIZE - count,\r\n"ro|rw|cancel|cold|disable-jump|hibernate");\r\ncount += scnprintf(buf + count, PAGE_SIZE - count,\r\n" [at-shutdown]\n");\r\nreturn count;\r\n}\r\nstatic ssize_t store_ec_reboot(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstatic const struct {\r\nconst char * const str;\r\nuint8_t cmd;\r\nuint8_t flags;\r\n} words[] = {\r\n{"cancel", EC_REBOOT_CANCEL, 0},\r\n{"ro", EC_REBOOT_JUMP_RO, 0},\r\n{"rw", EC_REBOOT_JUMP_RW, 0},\r\n{"cold", EC_REBOOT_COLD, 0},\r\n{"disable-jump", EC_REBOOT_DISABLE_JUMP, 0},\r\n{"hibernate", EC_REBOOT_HIBERNATE, 0},\r\n{"at-shutdown", -1, EC_REBOOT_FLAG_ON_AP_SHUTDOWN},\r\n};\r\nstruct cros_ec_command *msg;\r\nstruct ec_params_reboot_ec *param;\r\nint got_cmd = 0, offset = 0;\r\nint i;\r\nint ret;\r\nstruct cros_ec_dev *ec = container_of(dev,\r\nstruct cros_ec_dev, class_dev);\r\nmsg = kmalloc(sizeof(*msg) + sizeof(*param), GFP_KERNEL);\r\nif (!msg)\r\nreturn -ENOMEM;\r\nparam = (struct ec_params_reboot_ec *)msg->data;\r\nparam->flags = 0;\r\nwhile (1) {\r\nwhile (buf[offset] && isspace(buf[offset]))\r\noffset++;\r\nif (!buf[offset])\r\nbreak;\r\nfor (i = 0; i < ARRAY_SIZE(words); i++) {\r\nif (!strncasecmp(words[i].str, buf+offset,\r\nstrlen(words[i].str))) {\r\nif (words[i].flags) {\r\nparam->flags |= words[i].flags;\r\n} else {\r\nparam->cmd = words[i].cmd;\r\ngot_cmd = 1;\r\n}\r\nbreak;\r\n}\r\n}\r\nwhile (buf[offset] && !isspace(buf[offset]))\r\noffset++;\r\n}\r\nif (!got_cmd) {\r\ncount = -EINVAL;\r\ngoto exit;\r\n}\r\nmsg->version = 0;\r\nmsg->command = EC_CMD_REBOOT_EC + ec->cmd_offset;\r\nmsg->outsize = sizeof(*param);\r\nmsg->insize = 0;\r\nret = cros_ec_cmd_xfer(ec->ec_dev, msg);\r\nif (ret < 0) {\r\ncount = ret;\r\ngoto exit;\r\n}\r\nif (msg->result != EC_RES_SUCCESS) {\r\ndev_dbg(ec->dev, "EC result %d\n", msg->result);\r\ncount = -EINVAL;\r\n}\r\nexit:\r\nkfree(msg);\r\nreturn count;\r\n}\r\nstatic ssize_t show_ec_version(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstatic const char * const image_names[] = {"unknown", "RO", "RW"};\r\nstruct ec_response_get_version *r_ver;\r\nstruct ec_response_get_chip_info *r_chip;\r\nstruct ec_response_board_version *r_board;\r\nstruct cros_ec_command *msg;\r\nint ret;\r\nint count = 0;\r\nstruct cros_ec_dev *ec = container_of(dev,\r\nstruct cros_ec_dev, class_dev);\r\nmsg = kmalloc(sizeof(*msg) + EC_HOST_PARAM_SIZE, GFP_KERNEL);\r\nif (!msg)\r\nreturn -ENOMEM;\r\nmsg->version = 0;\r\nmsg->command = EC_CMD_GET_VERSION + ec->cmd_offset;\r\nmsg->insize = sizeof(*r_ver);\r\nmsg->outsize = 0;\r\nret = cros_ec_cmd_xfer(ec->ec_dev, msg);\r\nif (ret < 0) {\r\ncount = ret;\r\ngoto exit;\r\n}\r\nif (msg->result != EC_RES_SUCCESS) {\r\ncount = scnprintf(buf, PAGE_SIZE,\r\n"ERROR: EC returned %d\n", msg->result);\r\ngoto exit;\r\n}\r\nr_ver = (struct ec_response_get_version *)msg->data;\r\nr_ver->version_string_ro[sizeof(r_ver->version_string_ro) - 1] = '\0';\r\nr_ver->version_string_rw[sizeof(r_ver->version_string_rw) - 1] = '\0';\r\ncount += scnprintf(buf + count, PAGE_SIZE - count,\r\n"RO version: %s\n", r_ver->version_string_ro);\r\ncount += scnprintf(buf + count, PAGE_SIZE - count,\r\n"RW version: %s\n", r_ver->version_string_rw);\r\ncount += scnprintf(buf + count, PAGE_SIZE - count,\r\n"Firmware copy: %s\n",\r\n(r_ver->current_image < ARRAY_SIZE(image_names) ?\r\nimage_names[r_ver->current_image] : "?"));\r\nmsg->command = EC_CMD_GET_BUILD_INFO + ec->cmd_offset;\r\nmsg->insize = EC_HOST_PARAM_SIZE;\r\nret = cros_ec_cmd_xfer(ec->ec_dev, msg);\r\nif (ret < 0)\r\ncount += scnprintf(buf + count, PAGE_SIZE - count,\r\n"Build info: XFER ERROR %d\n", ret);\r\nelse if (msg->result != EC_RES_SUCCESS)\r\ncount += scnprintf(buf + count, PAGE_SIZE - count,\r\n"Build info: EC error %d\n", msg->result);\r\nelse {\r\nmsg->data[sizeof(msg->data) - 1] = '\0';\r\ncount += scnprintf(buf + count, PAGE_SIZE - count,\r\n"Build info: %s\n", msg->data);\r\n}\r\nmsg->command = EC_CMD_GET_CHIP_INFO + ec->cmd_offset;\r\nmsg->insize = sizeof(*r_chip);\r\nret = cros_ec_cmd_xfer(ec->ec_dev, msg);\r\nif (ret < 0)\r\ncount += scnprintf(buf + count, PAGE_SIZE - count,\r\n"Chip info: XFER ERROR %d\n", ret);\r\nelse if (msg->result != EC_RES_SUCCESS)\r\ncount += scnprintf(buf + count, PAGE_SIZE - count,\r\n"Chip info: EC error %d\n", msg->result);\r\nelse {\r\nr_chip = (struct ec_response_get_chip_info *)msg->data;\r\nr_chip->vendor[sizeof(r_chip->vendor) - 1] = '\0';\r\nr_chip->name[sizeof(r_chip->name) - 1] = '\0';\r\nr_chip->revision[sizeof(r_chip->revision) - 1] = '\0';\r\ncount += scnprintf(buf + count, PAGE_SIZE - count,\r\n"Chip vendor: %s\n", r_chip->vendor);\r\ncount += scnprintf(buf + count, PAGE_SIZE - count,\r\n"Chip name: %s\n", r_chip->name);\r\ncount += scnprintf(buf + count, PAGE_SIZE - count,\r\n"Chip revision: %s\n", r_chip->revision);\r\n}\r\nmsg->command = EC_CMD_GET_BOARD_VERSION + ec->cmd_offset;\r\nmsg->insize = sizeof(*r_board);\r\nret = cros_ec_cmd_xfer(ec->ec_dev, msg);\r\nif (ret < 0)\r\ncount += scnprintf(buf + count, PAGE_SIZE - count,\r\n"Board version: XFER ERROR %d\n", ret);\r\nelse if (msg->result != EC_RES_SUCCESS)\r\ncount += scnprintf(buf + count, PAGE_SIZE - count,\r\n"Board version: EC error %d\n", msg->result);\r\nelse {\r\nr_board = (struct ec_response_board_version *)msg->data;\r\ncount += scnprintf(buf + count, PAGE_SIZE - count,\r\n"Board version: %d\n",\r\nr_board->board_version);\r\n}\r\nexit:\r\nkfree(msg);\r\nreturn count;\r\n}\r\nstatic ssize_t show_ec_flashinfo(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct ec_response_flash_info *resp;\r\nstruct cros_ec_command *msg;\r\nint ret;\r\nstruct cros_ec_dev *ec = container_of(dev,\r\nstruct cros_ec_dev, class_dev);\r\nmsg = kmalloc(sizeof(*msg) + sizeof(*resp), GFP_KERNEL);\r\nif (!msg)\r\nreturn -ENOMEM;\r\nmsg->version = 0;\r\nmsg->command = EC_CMD_FLASH_INFO + ec->cmd_offset;\r\nmsg->insize = sizeof(*resp);\r\nmsg->outsize = 0;\r\nret = cros_ec_cmd_xfer(ec->ec_dev, msg);\r\nif (ret < 0)\r\ngoto exit;\r\nif (msg->result != EC_RES_SUCCESS) {\r\nret = scnprintf(buf, PAGE_SIZE,\r\n"ERROR: EC returned %d\n", msg->result);\r\ngoto exit;\r\n}\r\nresp = (struct ec_response_flash_info *)msg->data;\r\nret = scnprintf(buf, PAGE_SIZE,\r\n"FlashSize %d\nWriteSize %d\n"\r\n"EraseSize %d\nProtectSize %d\n",\r\nresp->flash_size, resp->write_block_size,\r\nresp->erase_block_size, resp->protect_block_size);\r\nexit:\r\nkfree(msg);\r\nreturn ret;\r\n}
