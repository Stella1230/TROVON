static void rk3288_set_to_rgmii(struct rk_priv_data *bsp_priv,\r\nint tx_delay, int rx_delay)\r\n{\r\nstruct device *dev = &bsp_priv->pdev->dev;\r\nif (IS_ERR(bsp_priv->grf)) {\r\ndev_err(dev, "Missing rockchip,grf property\n");\r\nreturn;\r\n}\r\nregmap_write(bsp_priv->grf, RK3288_GRF_SOC_CON1,\r\nRK3288_GMAC_PHY_INTF_SEL_RGMII |\r\nRK3288_GMAC_RMII_MODE_CLR);\r\nregmap_write(bsp_priv->grf, RK3288_GRF_SOC_CON3,\r\nRK3288_GMAC_RXCLK_DLY_ENABLE |\r\nRK3288_GMAC_TXCLK_DLY_ENABLE |\r\nRK3288_GMAC_CLK_RX_DL_CFG(rx_delay) |\r\nRK3288_GMAC_CLK_TX_DL_CFG(tx_delay));\r\n}\r\nstatic void rk3288_set_to_rmii(struct rk_priv_data *bsp_priv)\r\n{\r\nstruct device *dev = &bsp_priv->pdev->dev;\r\nif (IS_ERR(bsp_priv->grf)) {\r\ndev_err(dev, "Missing rockchip,grf property\n");\r\nreturn;\r\n}\r\nregmap_write(bsp_priv->grf, RK3288_GRF_SOC_CON1,\r\nRK3288_GMAC_PHY_INTF_SEL_RMII | RK3288_GMAC_RMII_MODE);\r\n}\r\nstatic void rk3288_set_rgmii_speed(struct rk_priv_data *bsp_priv, int speed)\r\n{\r\nstruct device *dev = &bsp_priv->pdev->dev;\r\nif (IS_ERR(bsp_priv->grf)) {\r\ndev_err(dev, "Missing rockchip,grf property\n");\r\nreturn;\r\n}\r\nif (speed == 10)\r\nregmap_write(bsp_priv->grf, RK3288_GRF_SOC_CON1,\r\nRK3288_GMAC_CLK_2_5M);\r\nelse if (speed == 100)\r\nregmap_write(bsp_priv->grf, RK3288_GRF_SOC_CON1,\r\nRK3288_GMAC_CLK_25M);\r\nelse if (speed == 1000)\r\nregmap_write(bsp_priv->grf, RK3288_GRF_SOC_CON1,\r\nRK3288_GMAC_CLK_125M);\r\nelse\r\ndev_err(dev, "unknown speed value for RGMII! speed=%d", speed);\r\n}\r\nstatic void rk3288_set_rmii_speed(struct rk_priv_data *bsp_priv, int speed)\r\n{\r\nstruct device *dev = &bsp_priv->pdev->dev;\r\nif (IS_ERR(bsp_priv->grf)) {\r\ndev_err(dev, "Missing rockchip,grf property\n");\r\nreturn;\r\n}\r\nif (speed == 10) {\r\nregmap_write(bsp_priv->grf, RK3288_GRF_SOC_CON1,\r\nRK3288_GMAC_RMII_CLK_2_5M |\r\nRK3288_GMAC_SPEED_10M);\r\n} else if (speed == 100) {\r\nregmap_write(bsp_priv->grf, RK3288_GRF_SOC_CON1,\r\nRK3288_GMAC_RMII_CLK_25M |\r\nRK3288_GMAC_SPEED_100M);\r\n} else {\r\ndev_err(dev, "unknown speed value for RMII! speed=%d", speed);\r\n}\r\n}\r\nstatic void rk3368_set_to_rgmii(struct rk_priv_data *bsp_priv,\r\nint tx_delay, int rx_delay)\r\n{\r\nstruct device *dev = &bsp_priv->pdev->dev;\r\nif (IS_ERR(bsp_priv->grf)) {\r\ndev_err(dev, "%s: Missing rockchip,grf property\n", __func__);\r\nreturn;\r\n}\r\nregmap_write(bsp_priv->grf, RK3368_GRF_SOC_CON15,\r\nRK3368_GMAC_PHY_INTF_SEL_RGMII |\r\nRK3368_GMAC_RMII_MODE_CLR);\r\nregmap_write(bsp_priv->grf, RK3368_GRF_SOC_CON16,\r\nRK3368_GMAC_RXCLK_DLY_ENABLE |\r\nRK3368_GMAC_TXCLK_DLY_ENABLE |\r\nRK3368_GMAC_CLK_RX_DL_CFG(rx_delay) |\r\nRK3368_GMAC_CLK_TX_DL_CFG(tx_delay));\r\n}\r\nstatic void rk3368_set_to_rmii(struct rk_priv_data *bsp_priv)\r\n{\r\nstruct device *dev = &bsp_priv->pdev->dev;\r\nif (IS_ERR(bsp_priv->grf)) {\r\ndev_err(dev, "%s: Missing rockchip,grf property\n", __func__);\r\nreturn;\r\n}\r\nregmap_write(bsp_priv->grf, RK3368_GRF_SOC_CON15,\r\nRK3368_GMAC_PHY_INTF_SEL_RMII | RK3368_GMAC_RMII_MODE);\r\n}\r\nstatic void rk3368_set_rgmii_speed(struct rk_priv_data *bsp_priv, int speed)\r\n{\r\nstruct device *dev = &bsp_priv->pdev->dev;\r\nif (IS_ERR(bsp_priv->grf)) {\r\ndev_err(dev, "%s: Missing rockchip,grf property\n", __func__);\r\nreturn;\r\n}\r\nif (speed == 10)\r\nregmap_write(bsp_priv->grf, RK3368_GRF_SOC_CON15,\r\nRK3368_GMAC_CLK_2_5M);\r\nelse if (speed == 100)\r\nregmap_write(bsp_priv->grf, RK3368_GRF_SOC_CON15,\r\nRK3368_GMAC_CLK_25M);\r\nelse if (speed == 1000)\r\nregmap_write(bsp_priv->grf, RK3368_GRF_SOC_CON15,\r\nRK3368_GMAC_CLK_125M);\r\nelse\r\ndev_err(dev, "unknown speed value for RGMII! speed=%d", speed);\r\n}\r\nstatic void rk3368_set_rmii_speed(struct rk_priv_data *bsp_priv, int speed)\r\n{\r\nstruct device *dev = &bsp_priv->pdev->dev;\r\nif (IS_ERR(bsp_priv->grf)) {\r\ndev_err(dev, "%s: Missing rockchip,grf property\n", __func__);\r\nreturn;\r\n}\r\nif (speed == 10) {\r\nregmap_write(bsp_priv->grf, RK3368_GRF_SOC_CON15,\r\nRK3368_GMAC_RMII_CLK_2_5M |\r\nRK3368_GMAC_SPEED_10M);\r\n} else if (speed == 100) {\r\nregmap_write(bsp_priv->grf, RK3368_GRF_SOC_CON15,\r\nRK3368_GMAC_RMII_CLK_25M |\r\nRK3368_GMAC_SPEED_100M);\r\n} else {\r\ndev_err(dev, "unknown speed value for RMII! speed=%d", speed);\r\n}\r\n}\r\nstatic int gmac_clk_init(struct rk_priv_data *bsp_priv)\r\n{\r\nstruct device *dev = &bsp_priv->pdev->dev;\r\nbsp_priv->clk_enabled = false;\r\nbsp_priv->mac_clk_rx = devm_clk_get(dev, "mac_clk_rx");\r\nif (IS_ERR(bsp_priv->mac_clk_rx))\r\ndev_err(dev, "cannot get clock %s\n",\r\n"mac_clk_rx");\r\nbsp_priv->mac_clk_tx = devm_clk_get(dev, "mac_clk_tx");\r\nif (IS_ERR(bsp_priv->mac_clk_tx))\r\ndev_err(dev, "cannot get clock %s\n",\r\n"mac_clk_tx");\r\nbsp_priv->aclk_mac = devm_clk_get(dev, "aclk_mac");\r\nif (IS_ERR(bsp_priv->aclk_mac))\r\ndev_err(dev, "cannot get clock %s\n",\r\n"aclk_mac");\r\nbsp_priv->pclk_mac = devm_clk_get(dev, "pclk_mac");\r\nif (IS_ERR(bsp_priv->pclk_mac))\r\ndev_err(dev, "cannot get clock %s\n",\r\n"pclk_mac");\r\nbsp_priv->clk_mac = devm_clk_get(dev, "stmmaceth");\r\nif (IS_ERR(bsp_priv->clk_mac))\r\ndev_err(dev, "cannot get clock %s\n",\r\n"stmmaceth");\r\nif (bsp_priv->phy_iface == PHY_INTERFACE_MODE_RMII) {\r\nbsp_priv->clk_mac_ref = devm_clk_get(dev, "clk_mac_ref");\r\nif (IS_ERR(bsp_priv->clk_mac_ref))\r\ndev_err(dev, "cannot get clock %s\n",\r\n"clk_mac_ref");\r\nif (!bsp_priv->clock_input) {\r\nbsp_priv->clk_mac_refout =\r\ndevm_clk_get(dev, "clk_mac_refout");\r\nif (IS_ERR(bsp_priv->clk_mac_refout))\r\ndev_err(dev, "cannot get clock %s\n",\r\n"clk_mac_refout");\r\n}\r\n}\r\nif (bsp_priv->clock_input) {\r\ndev_info(dev, "clock input from PHY\n");\r\n} else {\r\nif (bsp_priv->phy_iface == PHY_INTERFACE_MODE_RMII)\r\nclk_set_rate(bsp_priv->clk_mac, 50000000);\r\n}\r\nreturn 0;\r\n}\r\nstatic int gmac_clk_enable(struct rk_priv_data *bsp_priv, bool enable)\r\n{\r\nint phy_iface = bsp_priv->phy_iface;\r\nif (enable) {\r\nif (!bsp_priv->clk_enabled) {\r\nif (phy_iface == PHY_INTERFACE_MODE_RMII) {\r\nif (!IS_ERR(bsp_priv->mac_clk_rx))\r\nclk_prepare_enable(\r\nbsp_priv->mac_clk_rx);\r\nif (!IS_ERR(bsp_priv->clk_mac_ref))\r\nclk_prepare_enable(\r\nbsp_priv->clk_mac_ref);\r\nif (!IS_ERR(bsp_priv->clk_mac_refout))\r\nclk_prepare_enable(\r\nbsp_priv->clk_mac_refout);\r\n}\r\nif (!IS_ERR(bsp_priv->aclk_mac))\r\nclk_prepare_enable(bsp_priv->aclk_mac);\r\nif (!IS_ERR(bsp_priv->pclk_mac))\r\nclk_prepare_enable(bsp_priv->pclk_mac);\r\nif (!IS_ERR(bsp_priv->mac_clk_tx))\r\nclk_prepare_enable(bsp_priv->mac_clk_tx);\r\nmdelay(5);\r\nbsp_priv->clk_enabled = true;\r\n}\r\n} else {\r\nif (bsp_priv->clk_enabled) {\r\nif (phy_iface == PHY_INTERFACE_MODE_RMII) {\r\nif (!IS_ERR(bsp_priv->mac_clk_rx))\r\nclk_disable_unprepare(\r\nbsp_priv->mac_clk_rx);\r\nif (!IS_ERR(bsp_priv->clk_mac_ref))\r\nclk_disable_unprepare(\r\nbsp_priv->clk_mac_ref);\r\nif (!IS_ERR(bsp_priv->clk_mac_refout))\r\nclk_disable_unprepare(\r\nbsp_priv->clk_mac_refout);\r\n}\r\nif (!IS_ERR(bsp_priv->aclk_mac))\r\nclk_disable_unprepare(bsp_priv->aclk_mac);\r\nif (!IS_ERR(bsp_priv->pclk_mac))\r\nclk_disable_unprepare(bsp_priv->pclk_mac);\r\nif (!IS_ERR(bsp_priv->mac_clk_tx))\r\nclk_disable_unprepare(bsp_priv->mac_clk_tx);\r\nbsp_priv->clk_enabled = false;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int phy_power_on(struct rk_priv_data *bsp_priv, bool enable)\r\n{\r\nstruct regulator *ldo = bsp_priv->regulator;\r\nint ret;\r\nstruct device *dev = &bsp_priv->pdev->dev;\r\nif (!ldo) {\r\ndev_err(dev, "no regulator found\n");\r\nreturn -1;\r\n}\r\nif (enable) {\r\nret = regulator_enable(ldo);\r\nif (ret)\r\ndev_err(dev, "fail to enable phy-supply\n");\r\n} else {\r\nret = regulator_disable(ldo);\r\nif (ret)\r\ndev_err(dev, "fail to disable phy-supply\n");\r\n}\r\nreturn 0;\r\n}\r\nstatic struct rk_priv_data *rk_gmac_setup(struct platform_device *pdev,\r\nconst struct rk_gmac_ops *ops)\r\n{\r\nstruct rk_priv_data *bsp_priv;\r\nstruct device *dev = &pdev->dev;\r\nint ret;\r\nconst char *strings = NULL;\r\nint value;\r\nbsp_priv = devm_kzalloc(dev, sizeof(*bsp_priv), GFP_KERNEL);\r\nif (!bsp_priv)\r\nreturn ERR_PTR(-ENOMEM);\r\nbsp_priv->phy_iface = of_get_phy_mode(dev->of_node);\r\nbsp_priv->ops = ops;\r\nbsp_priv->regulator = devm_regulator_get_optional(dev, "phy");\r\nif (IS_ERR(bsp_priv->regulator)) {\r\nif (PTR_ERR(bsp_priv->regulator) == -EPROBE_DEFER) {\r\ndev_err(dev, "phy regulator is not available yet, deferred probing\n");\r\nreturn ERR_PTR(-EPROBE_DEFER);\r\n}\r\ndev_err(dev, "no regulator found\n");\r\nbsp_priv->regulator = NULL;\r\n}\r\nret = of_property_read_string(dev->of_node, "clock_in_out", &strings);\r\nif (ret) {\r\ndev_err(dev, "Can not read property: clock_in_out.\n");\r\nbsp_priv->clock_input = true;\r\n} else {\r\ndev_info(dev, "clock input or output? (%s).\n",\r\nstrings);\r\nif (!strcmp(strings, "input"))\r\nbsp_priv->clock_input = true;\r\nelse\r\nbsp_priv->clock_input = false;\r\n}\r\nret = of_property_read_u32(dev->of_node, "tx_delay", &value);\r\nif (ret) {\r\nbsp_priv->tx_delay = 0x30;\r\ndev_err(dev, "Can not read property: tx_delay.");\r\ndev_err(dev, "set tx_delay to 0x%x\n",\r\nbsp_priv->tx_delay);\r\n} else {\r\ndev_info(dev, "TX delay(0x%x).\n", value);\r\nbsp_priv->tx_delay = value;\r\n}\r\nret = of_property_read_u32(dev->of_node, "rx_delay", &value);\r\nif (ret) {\r\nbsp_priv->rx_delay = 0x10;\r\ndev_err(dev, "Can not read property: rx_delay.");\r\ndev_err(dev, "set rx_delay to 0x%x\n",\r\nbsp_priv->rx_delay);\r\n} else {\r\ndev_info(dev, "RX delay(0x%x).\n", value);\r\nbsp_priv->rx_delay = value;\r\n}\r\nbsp_priv->grf = syscon_regmap_lookup_by_phandle(dev->of_node,\r\n"rockchip,grf");\r\nbsp_priv->pdev = pdev;\r\nif (bsp_priv->phy_iface == PHY_INTERFACE_MODE_RGMII) {\r\ndev_info(dev, "init for RGMII\n");\r\nbsp_priv->ops->set_to_rgmii(bsp_priv, bsp_priv->tx_delay,\r\nbsp_priv->rx_delay);\r\n} else if (bsp_priv->phy_iface == PHY_INTERFACE_MODE_RMII) {\r\ndev_info(dev, "init for RMII\n");\r\nbsp_priv->ops->set_to_rmii(bsp_priv);\r\n} else {\r\ndev_err(dev, "NO interface defined!\n");\r\n}\r\ngmac_clk_init(bsp_priv);\r\nreturn bsp_priv;\r\n}\r\nstatic int rk_gmac_init(struct platform_device *pdev, void *priv)\r\n{\r\nstruct rk_priv_data *bsp_priv = priv;\r\nint ret;\r\nret = phy_power_on(bsp_priv, true);\r\nif (ret)\r\nreturn ret;\r\nret = gmac_clk_enable(bsp_priv, true);\r\nif (ret)\r\nreturn ret;\r\nreturn 0;\r\n}\r\nstatic void rk_gmac_exit(struct platform_device *pdev, void *priv)\r\n{\r\nstruct rk_priv_data *gmac = priv;\r\nphy_power_on(gmac, false);\r\ngmac_clk_enable(gmac, false);\r\n}\r\nstatic void rk_fix_speed(void *priv, unsigned int speed)\r\n{\r\nstruct rk_priv_data *bsp_priv = priv;\r\nstruct device *dev = &bsp_priv->pdev->dev;\r\nif (bsp_priv->phy_iface == PHY_INTERFACE_MODE_RGMII)\r\nbsp_priv->ops->set_rgmii_speed(bsp_priv, speed);\r\nelse if (bsp_priv->phy_iface == PHY_INTERFACE_MODE_RMII)\r\nbsp_priv->ops->set_rmii_speed(bsp_priv, speed);\r\nelse\r\ndev_err(dev, "unsupported interface %d", bsp_priv->phy_iface);\r\n}\r\nstatic int rk_gmac_probe(struct platform_device *pdev)\r\n{\r\nstruct plat_stmmacenet_data *plat_dat;\r\nstruct stmmac_resources stmmac_res;\r\nconst struct rk_gmac_ops *data;\r\nint ret;\r\ndata = of_device_get_match_data(&pdev->dev);\r\nif (!data) {\r\ndev_err(&pdev->dev, "no of match data provided\n");\r\nreturn -EINVAL;\r\n}\r\nret = stmmac_get_platform_resources(pdev, &stmmac_res);\r\nif (ret)\r\nreturn ret;\r\nplat_dat = stmmac_probe_config_dt(pdev, &stmmac_res.mac);\r\nif (IS_ERR(plat_dat))\r\nreturn PTR_ERR(plat_dat);\r\nplat_dat->has_gmac = true;\r\nplat_dat->init = rk_gmac_init;\r\nplat_dat->exit = rk_gmac_exit;\r\nplat_dat->fix_mac_speed = rk_fix_speed;\r\nplat_dat->bsp_priv = rk_gmac_setup(pdev, data);\r\nif (IS_ERR(plat_dat->bsp_priv))\r\nreturn PTR_ERR(plat_dat->bsp_priv);\r\nret = rk_gmac_init(pdev, plat_dat->bsp_priv);\r\nif (ret)\r\nreturn ret;\r\nreturn stmmac_dvr_probe(&pdev->dev, plat_dat, &stmmac_res);\r\n}
