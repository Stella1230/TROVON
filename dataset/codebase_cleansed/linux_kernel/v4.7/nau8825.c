static bool nau8825_readable_reg(struct device *dev, unsigned int reg)\r\n{\r\nswitch (reg) {\r\ncase NAU8825_REG_ENA_CTRL ... NAU8825_REG_FLL_VCO_RSV:\r\ncase NAU8825_REG_HSD_CTRL ... NAU8825_REG_JACK_DET_CTRL:\r\ncase NAU8825_REG_INTERRUPT_MASK ... NAU8825_REG_KEYDET_CTRL:\r\ncase NAU8825_REG_VDET_THRESHOLD_1 ... NAU8825_REG_DACR_CTRL:\r\ncase NAU8825_REG_ADC_DRC_KNEE_IP12 ... NAU8825_REG_ADC_DRC_ATKDCY:\r\ncase NAU8825_REG_DAC_DRC_KNEE_IP12 ... NAU8825_REG_DAC_DRC_ATKDCY:\r\ncase NAU8825_REG_IMM_MODE_CTRL ... NAU8825_REG_IMM_RMS_R:\r\ncase NAU8825_REG_CLASSG_CTRL ... NAU8825_REG_OPT_EFUSE_CTRL:\r\ncase NAU8825_REG_MISC_CTRL:\r\ncase NAU8825_REG_I2C_DEVICE_ID ... NAU8825_REG_SARDOUT_RAM_STATUS:\r\ncase NAU8825_REG_BIAS_ADJ:\r\ncase NAU8825_REG_TRIM_SETTINGS ... NAU8825_REG_ANALOG_CONTROL_2:\r\ncase NAU8825_REG_ANALOG_ADC_1 ... NAU8825_REG_MIC_BIAS:\r\ncase NAU8825_REG_BOOST ... NAU8825_REG_FEPGA:\r\ncase NAU8825_REG_POWER_UP_CONTROL ... NAU8825_REG_GENERAL_STATUS:\r\nreturn true;\r\ndefault:\r\nreturn false;\r\n}\r\n}\r\nstatic bool nau8825_writeable_reg(struct device *dev, unsigned int reg)\r\n{\r\nswitch (reg) {\r\ncase NAU8825_REG_RESET ... NAU8825_REG_FLL_VCO_RSV:\r\ncase NAU8825_REG_HSD_CTRL ... NAU8825_REG_JACK_DET_CTRL:\r\ncase NAU8825_REG_INTERRUPT_MASK:\r\ncase NAU8825_REG_INT_CLR_KEY_STATUS ... NAU8825_REG_KEYDET_CTRL:\r\ncase NAU8825_REG_VDET_THRESHOLD_1 ... NAU8825_REG_DACR_CTRL:\r\ncase NAU8825_REG_ADC_DRC_KNEE_IP12 ... NAU8825_REG_ADC_DRC_ATKDCY:\r\ncase NAU8825_REG_DAC_DRC_KNEE_IP12 ... NAU8825_REG_DAC_DRC_ATKDCY:\r\ncase NAU8825_REG_IMM_MODE_CTRL:\r\ncase NAU8825_REG_CLASSG_CTRL ... NAU8825_REG_OPT_EFUSE_CTRL:\r\ncase NAU8825_REG_MISC_CTRL:\r\ncase NAU8825_REG_BIAS_ADJ:\r\ncase NAU8825_REG_TRIM_SETTINGS ... NAU8825_REG_ANALOG_CONTROL_2:\r\ncase NAU8825_REG_ANALOG_ADC_1 ... NAU8825_REG_MIC_BIAS:\r\ncase NAU8825_REG_BOOST ... NAU8825_REG_FEPGA:\r\ncase NAU8825_REG_POWER_UP_CONTROL ... NAU8825_REG_CHARGE_PUMP:\r\nreturn true;\r\ndefault:\r\nreturn false;\r\n}\r\n}\r\nstatic bool nau8825_volatile_reg(struct device *dev, unsigned int reg)\r\n{\r\nswitch (reg) {\r\ncase NAU8825_REG_RESET:\r\ncase NAU8825_REG_IRQ_STATUS:\r\ncase NAU8825_REG_INT_CLR_KEY_STATUS:\r\ncase NAU8825_REG_IMM_RMS_L:\r\ncase NAU8825_REG_IMM_RMS_R:\r\ncase NAU8825_REG_I2C_DEVICE_ID:\r\ncase NAU8825_REG_SARDOUT_RAM_STATUS:\r\ncase NAU8825_REG_CHARGE_PUMP_INPUT_READ:\r\ncase NAU8825_REG_GENERAL_STATUS:\r\nreturn true;\r\ndefault:\r\nreturn false;\r\n}\r\n}\r\nstatic int nau8825_pump_event(struct snd_soc_dapm_widget *w,\r\nstruct snd_kcontrol *kcontrol, int event)\r\n{\r\nstruct snd_soc_codec *codec = snd_soc_dapm_to_codec(w->dapm);\r\nstruct nau8825 *nau8825 = snd_soc_codec_get_drvdata(codec);\r\nswitch (event) {\r\ncase SND_SOC_DAPM_POST_PMU:\r\nmsleep(10);\r\nregmap_update_bits(nau8825->regmap, NAU8825_REG_CHARGE_PUMP,\r\nNAU8825_JAMNODCLOW, NAU8825_JAMNODCLOW);\r\nbreak;\r\ncase SND_SOC_DAPM_PRE_PMD:\r\nregmap_update_bits(nau8825->regmap, NAU8825_REG_CHARGE_PUMP,\r\nNAU8825_JAMNODCLOW, 0);\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int nau8825_output_dac_event(struct snd_soc_dapm_widget *w,\r\nstruct snd_kcontrol *kcontrol, int event)\r\n{\r\nstruct snd_soc_codec *codec = snd_soc_dapm_to_codec(w->dapm);\r\nstruct nau8825 *nau8825 = snd_soc_codec_get_drvdata(codec);\r\nswitch (event) {\r\ncase SND_SOC_DAPM_PRE_PMU:\r\nregmap_update_bits(nau8825->regmap, NAU8825_REG_BIAS_ADJ,\r\nNAU8825_BIAS_TESTDAC_EN, 0);\r\nbreak;\r\ncase SND_SOC_DAPM_POST_PMD:\r\nregmap_update_bits(nau8825->regmap, NAU8825_REG_BIAS_ADJ,\r\nNAU8825_BIAS_TESTDAC_EN, NAU8825_BIAS_TESTDAC_EN);\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int nau8825_hw_params(struct snd_pcm_substream *substream,\r\nstruct snd_pcm_hw_params *params,\r\nstruct snd_soc_dai *dai)\r\n{\r\nstruct snd_soc_codec *codec = dai->codec;\r\nstruct nau8825 *nau8825 = snd_soc_codec_get_drvdata(codec);\r\nunsigned int val_len = 0;\r\nswitch (params_width(params)) {\r\ncase 16:\r\nval_len |= NAU8825_I2S_DL_16;\r\nbreak;\r\ncase 20:\r\nval_len |= NAU8825_I2S_DL_20;\r\nbreak;\r\ncase 24:\r\nval_len |= NAU8825_I2S_DL_24;\r\nbreak;\r\ncase 32:\r\nval_len |= NAU8825_I2S_DL_32;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nregmap_update_bits(nau8825->regmap, NAU8825_REG_I2S_PCM_CTRL1,\r\nNAU8825_I2S_DL_MASK, val_len);\r\nreturn 0;\r\n}\r\nstatic int nau8825_set_dai_fmt(struct snd_soc_dai *codec_dai, unsigned int fmt)\r\n{\r\nstruct snd_soc_codec *codec = codec_dai->codec;\r\nstruct nau8825 *nau8825 = snd_soc_codec_get_drvdata(codec);\r\nunsigned int ctrl1_val = 0, ctrl2_val = 0;\r\nswitch (fmt & SND_SOC_DAIFMT_MASTER_MASK) {\r\ncase SND_SOC_DAIFMT_CBM_CFM:\r\nctrl2_val |= NAU8825_I2S_MS_MASTER;\r\nbreak;\r\ncase SND_SOC_DAIFMT_CBS_CFS:\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nswitch (fmt & SND_SOC_DAIFMT_INV_MASK) {\r\ncase SND_SOC_DAIFMT_NB_NF:\r\nbreak;\r\ncase SND_SOC_DAIFMT_IB_NF:\r\nctrl1_val |= NAU8825_I2S_BP_INV;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nswitch (fmt & SND_SOC_DAIFMT_FORMAT_MASK) {\r\ncase SND_SOC_DAIFMT_I2S:\r\nctrl1_val |= NAU8825_I2S_DF_I2S;\r\nbreak;\r\ncase SND_SOC_DAIFMT_LEFT_J:\r\nctrl1_val |= NAU8825_I2S_DF_LEFT;\r\nbreak;\r\ncase SND_SOC_DAIFMT_RIGHT_J:\r\nctrl1_val |= NAU8825_I2S_DF_RIGTH;\r\nbreak;\r\ncase SND_SOC_DAIFMT_DSP_A:\r\nctrl1_val |= NAU8825_I2S_DF_PCM_AB;\r\nbreak;\r\ncase SND_SOC_DAIFMT_DSP_B:\r\nctrl1_val |= NAU8825_I2S_DF_PCM_AB;\r\nctrl1_val |= NAU8825_I2S_PCMB_EN;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nregmap_update_bits(nau8825->regmap, NAU8825_REG_I2S_PCM_CTRL1,\r\nNAU8825_I2S_DL_MASK | NAU8825_I2S_DF_MASK |\r\nNAU8825_I2S_BP_MASK | NAU8825_I2S_PCMB_MASK,\r\nctrl1_val);\r\nregmap_update_bits(nau8825->regmap, NAU8825_REG_I2S_PCM_CTRL2,\r\nNAU8825_I2S_MS_MASK, ctrl2_val);\r\nreturn 0;\r\n}\r\nint nau8825_enable_jack_detect(struct snd_soc_codec *codec,\r\nstruct snd_soc_jack *jack)\r\n{\r\nstruct nau8825 *nau8825 = snd_soc_codec_get_drvdata(codec);\r\nstruct regmap *regmap = nau8825->regmap;\r\nnau8825->jack = jack;\r\nregmap_update_bits(regmap, NAU8825_REG_HSD_CTRL,\r\nNAU8825_HSD_AUTO_MODE | NAU8825_SPKR_DWN1R | NAU8825_SPKR_DWN1L,\r\nNAU8825_HSD_AUTO_MODE | NAU8825_SPKR_DWN1R | NAU8825_SPKR_DWN1L);\r\nregmap_update_bits(regmap, NAU8825_REG_INTERRUPT_MASK,\r\nNAU8825_IRQ_HEADSET_COMPLETE_EN | NAU8825_IRQ_EJECT_EN, 0);\r\nreturn 0;\r\n}\r\nstatic bool nau8825_is_jack_inserted(struct regmap *regmap)\r\n{\r\nint status;\r\nregmap_read(regmap, NAU8825_REG_I2C_DEVICE_ID, &status);\r\nreturn !(status & NAU8825_GPIO2JD1);\r\n}\r\nstatic void nau8825_restart_jack_detection(struct regmap *regmap)\r\n{\r\nregmap_update_bits(regmap, NAU8825_REG_I2S_PCM_CTRL2,\r\nNAU8825_I2S_MS_MASK, NAU8825_I2S_MS_MASTER);\r\nregmap_update_bits(regmap, NAU8825_REG_I2S_PCM_CTRL2,\r\nNAU8825_I2S_MS_MASK, NAU8825_I2S_MS_SLAVE);\r\nregmap_update_bits(regmap, NAU8825_REG_JACK_DET_CTRL,\r\nNAU8825_JACK_DET_RESTART, NAU8825_JACK_DET_RESTART);\r\nregmap_update_bits(regmap, NAU8825_REG_JACK_DET_CTRL,\r\nNAU8825_JACK_DET_RESTART, 0);\r\n}\r\nstatic void nau8825_eject_jack(struct nau8825 *nau8825)\r\n{\r\nstruct snd_soc_dapm_context *dapm = nau8825->dapm;\r\nstruct regmap *regmap = nau8825->regmap;\r\nsnd_soc_dapm_disable_pin(dapm, "SAR");\r\nsnd_soc_dapm_disable_pin(dapm, "MICBIAS");\r\nregmap_update_bits(regmap, NAU8825_REG_MIC_BIAS,\r\nNAU8825_MICBIAS_JKSLV | NAU8825_MICBIAS_JKR2, 0);\r\nregmap_update_bits(regmap, NAU8825_REG_HSD_CTRL, 0xf, 0xf);\r\nsnd_soc_dapm_sync(dapm);\r\n}\r\nstatic int nau8825_button_decode(int value)\r\n{\r\nint buttons = 0;\r\nif (value & BIT(0))\r\nbuttons |= SND_JACK_BTN_0;\r\nif (value & BIT(1))\r\nbuttons |= SND_JACK_BTN_1;\r\nif (value & BIT(2))\r\nbuttons |= SND_JACK_BTN_2;\r\nif (value & BIT(3))\r\nbuttons |= SND_JACK_BTN_3;\r\nif (value & BIT(4))\r\nbuttons |= SND_JACK_BTN_4;\r\nif (value & BIT(5))\r\nbuttons |= SND_JACK_BTN_5;\r\nreturn buttons;\r\n}\r\nstatic int nau8825_jack_insert(struct nau8825 *nau8825)\r\n{\r\nstruct regmap *regmap = nau8825->regmap;\r\nstruct snd_soc_dapm_context *dapm = nau8825->dapm;\r\nint jack_status_reg, mic_detected;\r\nint type = 0;\r\nregmap_read(regmap, NAU8825_REG_GENERAL_STATUS, &jack_status_reg);\r\nmic_detected = (jack_status_reg >> 10) & 3;\r\nswitch (mic_detected) {\r\ncase 0:\r\ntype = SND_JACK_HEADPHONE;\r\nbreak;\r\ncase 1:\r\ndev_dbg(nau8825->dev, "OMTP (micgnd1) mic connected\n");\r\ntype = SND_JACK_HEADSET;\r\nregmap_update_bits(regmap, NAU8825_REG_HSD_CTRL, 3 << 2,\r\n1 << 2);\r\nregmap_update_bits(regmap, NAU8825_REG_MIC_BIAS,\r\nNAU8825_MICBIAS_JKSLV | NAU8825_MICBIAS_JKR2,\r\nNAU8825_MICBIAS_JKR2);\r\nregmap_update_bits(regmap, NAU8825_REG_SAR_CTRL,\r\nNAU8825_SAR_INPUT_MASK,\r\nNAU8825_SAR_INPUT_JKR2);\r\nsnd_soc_dapm_force_enable_pin(dapm, "MICBIAS");\r\nsnd_soc_dapm_force_enable_pin(dapm, "SAR");\r\nsnd_soc_dapm_sync(dapm);\r\nbreak;\r\ncase 2:\r\ncase 3:\r\ndev_dbg(nau8825->dev, "CTIA (micgnd2) mic connected\n");\r\ntype = SND_JACK_HEADSET;\r\nregmap_update_bits(regmap, NAU8825_REG_HSD_CTRL, 3 << 2,\r\n2 << 2);\r\nregmap_update_bits(regmap, NAU8825_REG_MIC_BIAS,\r\nNAU8825_MICBIAS_JKSLV | NAU8825_MICBIAS_JKR2,\r\nNAU8825_MICBIAS_JKSLV);\r\nregmap_update_bits(regmap, NAU8825_REG_SAR_CTRL,\r\nNAU8825_SAR_INPUT_MASK,\r\nNAU8825_SAR_INPUT_JKSLV);\r\nsnd_soc_dapm_force_enable_pin(dapm, "MICBIAS");\r\nsnd_soc_dapm_force_enable_pin(dapm, "SAR");\r\nsnd_soc_dapm_sync(dapm);\r\nbreak;\r\n}\r\nreturn type;\r\n}\r\nstatic irqreturn_t nau8825_interrupt(int irq, void *data)\r\n{\r\nstruct nau8825 *nau8825 = (struct nau8825 *)data;\r\nstruct regmap *regmap = nau8825->regmap;\r\nint active_irq, clear_irq = 0, event = 0, event_mask = 0;\r\nif (regmap_read(regmap, NAU8825_REG_IRQ_STATUS, &active_irq)) {\r\ndev_err(nau8825->dev, "failed to read irq status\n");\r\nreturn IRQ_NONE;\r\n}\r\nif ((active_irq & NAU8825_JACK_EJECTION_IRQ_MASK) ==\r\nNAU8825_JACK_EJECTION_DETECTED) {\r\nnau8825_eject_jack(nau8825);\r\nevent_mask |= SND_JACK_HEADSET;\r\nclear_irq = NAU8825_JACK_EJECTION_IRQ_MASK;\r\n} else if (active_irq & NAU8825_KEY_SHORT_PRESS_IRQ) {\r\nint key_status;\r\nregmap_read(regmap, NAU8825_REG_INT_CLR_KEY_STATUS,\r\n&key_status);\r\nnau8825->button_pressed = nau8825_button_decode(\r\nkey_status >> 8);\r\nevent |= nau8825->button_pressed;\r\nevent_mask |= NAU8825_BUTTONS;\r\nclear_irq = NAU8825_KEY_SHORT_PRESS_IRQ;\r\n} else if (active_irq & NAU8825_KEY_RELEASE_IRQ) {\r\nevent_mask = NAU8825_BUTTONS;\r\nclear_irq = NAU8825_KEY_RELEASE_IRQ;\r\n} else if (active_irq & NAU8825_HEADSET_COMPLETION_IRQ) {\r\nif (nau8825_is_jack_inserted(regmap)) {\r\nevent |= nau8825_jack_insert(nau8825);\r\n} else {\r\ndev_warn(nau8825->dev, "Headset completion IRQ fired but no headset connected\n");\r\nnau8825_eject_jack(nau8825);\r\n}\r\nevent_mask |= SND_JACK_HEADSET;\r\nclear_irq = NAU8825_HEADSET_COMPLETION_IRQ;\r\n}\r\nif (!clear_irq)\r\nclear_irq = active_irq;\r\nregmap_write(regmap, NAU8825_REG_INT_CLR_KEY_STATUS, clear_irq);\r\nif (event_mask)\r\nsnd_soc_jack_report(nau8825->jack, event, event_mask);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void nau8825_setup_buttons(struct nau8825 *nau8825)\r\n{\r\nstruct regmap *regmap = nau8825->regmap;\r\nregmap_update_bits(regmap, NAU8825_REG_SAR_CTRL,\r\nNAU8825_SAR_TRACKING_GAIN_MASK,\r\nnau8825->sar_voltage << NAU8825_SAR_TRACKING_GAIN_SFT);\r\nregmap_update_bits(regmap, NAU8825_REG_SAR_CTRL,\r\nNAU8825_SAR_COMPARE_TIME_MASK,\r\nnau8825->sar_compare_time << NAU8825_SAR_COMPARE_TIME_SFT);\r\nregmap_update_bits(regmap, NAU8825_REG_SAR_CTRL,\r\nNAU8825_SAR_SAMPLING_TIME_MASK,\r\nnau8825->sar_sampling_time << NAU8825_SAR_SAMPLING_TIME_SFT);\r\nregmap_update_bits(regmap, NAU8825_REG_KEYDET_CTRL,\r\nNAU8825_KEYDET_LEVELS_NR_MASK,\r\n(nau8825->sar_threshold_num - 1) << NAU8825_KEYDET_LEVELS_NR_SFT);\r\nregmap_update_bits(regmap, NAU8825_REG_KEYDET_CTRL,\r\nNAU8825_KEYDET_HYSTERESIS_MASK,\r\nnau8825->sar_hysteresis << NAU8825_KEYDET_HYSTERESIS_SFT);\r\nregmap_update_bits(regmap, NAU8825_REG_KEYDET_CTRL,\r\nNAU8825_KEYDET_SHORTKEY_DEBOUNCE_MASK,\r\nnau8825->key_debounce << NAU8825_KEYDET_SHORTKEY_DEBOUNCE_SFT);\r\nregmap_write(regmap, NAU8825_REG_VDET_THRESHOLD_1,\r\n(nau8825->sar_threshold[0] << 8) | nau8825->sar_threshold[1]);\r\nregmap_write(regmap, NAU8825_REG_VDET_THRESHOLD_2,\r\n(nau8825->sar_threshold[2] << 8) | nau8825->sar_threshold[3]);\r\nregmap_write(regmap, NAU8825_REG_VDET_THRESHOLD_3,\r\n(nau8825->sar_threshold[4] << 8) | nau8825->sar_threshold[5]);\r\nregmap_write(regmap, NAU8825_REG_VDET_THRESHOLD_4,\r\n(nau8825->sar_threshold[6] << 8) | nau8825->sar_threshold[7]);\r\nregmap_update_bits(regmap, NAU8825_REG_INTERRUPT_MASK,\r\nNAU8825_IRQ_KEY_SHORT_PRESS_EN | NAU8825_IRQ_KEY_RELEASE_EN,\r\n0);\r\n}\r\nstatic void nau8825_init_regs(struct nau8825 *nau8825)\r\n{\r\nstruct regmap *regmap = nau8825->regmap;\r\nregmap_write(regmap, NAU8825_REG_IIC_ADDR_SET, 0x0001);\r\nregmap_update_bits(nau8825->regmap, NAU8825_REG_BIAS_ADJ,\r\nNAU8825_BIAS_VMID, NAU8825_BIAS_VMID);\r\nregmap_update_bits(nau8825->regmap, NAU8825_REG_BOOST,\r\nNAU8825_GLOBAL_BIAS_EN, NAU8825_GLOBAL_BIAS_EN);\r\nregmap_update_bits(regmap, NAU8825_REG_BIAS_ADJ,\r\nNAU8825_BIAS_VMID_SEL_MASK,\r\nnau8825->vref_impedance << NAU8825_BIAS_VMID_SEL_SFT);\r\nregmap_update_bits(regmap, NAU8825_REG_BOOST,\r\nNAU8825_PRECHARGE_DIS | NAU8825_HP_BOOST_DIS |\r\nNAU8825_HP_BOOST_G_DIS | NAU8825_SHORT_SHUTDOWN_EN,\r\nNAU8825_PRECHARGE_DIS | NAU8825_HP_BOOST_DIS |\r\nNAU8825_HP_BOOST_G_DIS | NAU8825_SHORT_SHUTDOWN_EN);\r\nregmap_update_bits(regmap, NAU8825_REG_GPIO12_CTRL,\r\nNAU8825_JKDET_OUTPUT_EN,\r\nnau8825->jkdet_enable ? 0 : NAU8825_JKDET_OUTPUT_EN);\r\nregmap_update_bits(regmap, NAU8825_REG_GPIO12_CTRL,\r\nNAU8825_JKDET_PULL_EN,\r\nnau8825->jkdet_pull_enable ? 0 : NAU8825_JKDET_PULL_EN);\r\nregmap_update_bits(regmap, NAU8825_REG_GPIO12_CTRL,\r\nNAU8825_JKDET_PULL_UP,\r\nnau8825->jkdet_pull_up ? NAU8825_JKDET_PULL_UP : 0);\r\nregmap_update_bits(regmap, NAU8825_REG_JACK_DET_CTRL,\r\nNAU8825_JACK_POLARITY,\r\nnau8825->jkdet_polarity ? 0 : NAU8825_JACK_POLARITY);\r\nregmap_update_bits(regmap, NAU8825_REG_JACK_DET_CTRL,\r\nNAU8825_JACK_INSERT_DEBOUNCE_MASK,\r\nnau8825->jack_insert_debounce << NAU8825_JACK_INSERT_DEBOUNCE_SFT);\r\nregmap_update_bits(regmap, NAU8825_REG_JACK_DET_CTRL,\r\nNAU8825_JACK_EJECT_DEBOUNCE_MASK,\r\nnau8825->jack_eject_debounce << NAU8825_JACK_EJECT_DEBOUNCE_SFT);\r\nregmap_update_bits(regmap, NAU8825_REG_INTERRUPT_MASK, 0x7ff, 0x7ff);\r\nregmap_update_bits(regmap, NAU8825_REG_MIC_BIAS,\r\nNAU8825_MICBIAS_VOLTAGE_MASK, nau8825->micbias_voltage);\r\nif (nau8825->sar_threshold_num)\r\nnau8825_setup_buttons(nau8825);\r\nregmap_update_bits(regmap, NAU8825_REG_ADC_RATE,\r\nNAU8825_ADC_SYNC_DOWN_MASK, NAU8825_ADC_SYNC_DOWN_128);\r\nregmap_update_bits(regmap, NAU8825_REG_DAC_CTRL1,\r\nNAU8825_DAC_OVERSAMPLE_MASK, NAU8825_DAC_OVERSAMPLE_128);\r\nregmap_update_bits(regmap, NAU8825_REG_CHARGE_PUMP,\r\nNAU8825_POWER_DOWN_DACR | NAU8825_POWER_DOWN_DACL,\r\nNAU8825_POWER_DOWN_DACR | NAU8825_POWER_DOWN_DACL);\r\nregmap_update_bits(nau8825->regmap, NAU8825_REG_BIAS_ADJ,\r\nNAU8825_BIAS_TESTDAC_EN, NAU8825_BIAS_TESTDAC_EN);\r\nregmap_update_bits(regmap, NAU8825_REG_DAC_CTRL1,\r\nNAU8825_DAC_CLIP_OFF, NAU8825_DAC_CLIP_OFF);\r\nregmap_update_bits(regmap, NAU8825_REG_ANALOG_CONTROL_2,\r\nNAU8825_HP_NON_CLASSG_CURRENT_2xADJ |\r\nNAU8825_DAC_CAPACITOR_MSB | NAU8825_DAC_CAPACITOR_LSB,\r\nNAU8825_HP_NON_CLASSG_CURRENT_2xADJ |\r\nNAU8825_DAC_CAPACITOR_MSB | NAU8825_DAC_CAPACITOR_LSB);\r\nregmap_update_bits(regmap, NAU8825_REG_CLASSG_CTRL,\r\nNAU8825_CLASSG_TIMER_MASK,\r\n0x20 << NAU8825_CLASSG_TIMER_SFT);\r\nregmap_update_bits(regmap, NAU8825_REG_RDAC,\r\nNAU8825_RDAC_CLK_DELAY_MASK | NAU8825_RDAC_VREF_MASK,\r\n(0x2 << NAU8825_RDAC_CLK_DELAY_SFT) |\r\n(0x3 << NAU8825_RDAC_VREF_SFT));\r\n}\r\nstatic int nau8825_codec_probe(struct snd_soc_codec *codec)\r\n{\r\nstruct nau8825 *nau8825 = snd_soc_codec_get_drvdata(codec);\r\nstruct snd_soc_dapm_context *dapm = snd_soc_codec_get_dapm(codec);\r\nnau8825->dapm = dapm;\r\nsnd_soc_dapm_force_enable_pin(dapm, "DDACR");\r\nsnd_soc_dapm_sync(dapm);\r\nregmap_write(nau8825->regmap, NAU8825_REG_INTERRUPT_DIS_CTRL, 0);\r\nnau8825_restart_jack_detection(nau8825->regmap);\r\nreturn 0;\r\n}\r\nstatic int nau8825_calc_fll_param(unsigned int fll_in, unsigned int fs,\r\nstruct nau8825_fll *fll_param)\r\n{\r\nu64 fvco;\r\nunsigned int fref, i;\r\nfor (i = 0; i < ARRAY_SIZE(fll_pre_scalar); i++) {\r\nfref = fll_in / fll_pre_scalar[i].param;\r\nif (fref <= NAU_FREF_MAX)\r\nbreak;\r\n}\r\nif (i == ARRAY_SIZE(fll_pre_scalar))\r\nreturn -EINVAL;\r\nfll_param->clk_ref_div = fll_pre_scalar[i].val;\r\nfor (i = 0; i < ARRAY_SIZE(fll_ratio); i++) {\r\nif (fref >= fll_ratio[i].param)\r\nbreak;\r\n}\r\nif (i == ARRAY_SIZE(fll_ratio))\r\nreturn -EINVAL;\r\nfll_param->ratio = fll_ratio[i].val;\r\nfor (i = 0; i < ARRAY_SIZE(mclk_src_scaling); i++) {\r\nfvco = 256 * fs * 2 * mclk_src_scaling[i].param;\r\nif (NAU_FVCO_MIN < fvco && fvco < NAU_FVCO_MAX)\r\nbreak;\r\n}\r\nif (i == ARRAY_SIZE(mclk_src_scaling))\r\nreturn -EINVAL;\r\nfll_param->mclk_src = mclk_src_scaling[i].val;\r\nfvco = div_u64(fvco << 16, fref * fll_param->ratio);\r\nfll_param->fll_int = (fvco >> 16) & 0x3FF;\r\nfll_param->fll_frac = fvco & 0xFFFF;\r\nreturn 0;\r\n}\r\nstatic void nau8825_fll_apply(struct nau8825 *nau8825,\r\nstruct nau8825_fll *fll_param)\r\n{\r\nregmap_update_bits(nau8825->regmap, NAU8825_REG_CLK_DIVIDER,\r\nNAU8825_CLK_MCLK_SRC_MASK, fll_param->mclk_src);\r\nregmap_update_bits(nau8825->regmap, NAU8825_REG_FLL1,\r\nNAU8825_FLL_RATIO_MASK, fll_param->ratio);\r\nregmap_write(nau8825->regmap, NAU8825_REG_FLL2, fll_param->fll_frac);\r\nregmap_update_bits(nau8825->regmap, NAU8825_REG_FLL3,\r\nNAU8825_FLL_INTEGER_MASK, fll_param->fll_int);\r\nregmap_update_bits(nau8825->regmap, NAU8825_REG_FLL4,\r\nNAU8825_FLL_REF_DIV_MASK, fll_param->clk_ref_div);\r\nregmap_update_bits(nau8825->regmap, NAU8825_REG_FLL5,\r\nNAU8825_FLL_FILTER_SW_MASK, 0x0000);\r\nregmap_update_bits(nau8825->regmap, NAU8825_REG_FLL6,\r\nNAU8825_SDM_EN_MASK, NAU8825_SDM_EN);\r\n}\r\nstatic int nau8825_set_pll(struct snd_soc_codec *codec, int pll_id, int source,\r\nunsigned int freq_in, unsigned int freq_out)\r\n{\r\nstruct nau8825 *nau8825 = snd_soc_codec_get_drvdata(codec);\r\nstruct nau8825_fll fll_param;\r\nint ret, fs;\r\nfs = freq_out / 256;\r\nret = nau8825_calc_fll_param(freq_in, fs, &fll_param);\r\nif (ret < 0) {\r\ndev_err(codec->dev, "Unsupported input clock %d\n", freq_in);\r\nreturn ret;\r\n}\r\ndev_dbg(codec->dev, "mclk_src=%x ratio=%x fll_frac=%x fll_int=%x clk_ref_div=%x\n",\r\nfll_param.mclk_src, fll_param.ratio, fll_param.fll_frac,\r\nfll_param.fll_int, fll_param.clk_ref_div);\r\nnau8825_fll_apply(nau8825, &fll_param);\r\nmdelay(2);\r\nregmap_update_bits(nau8825->regmap, NAU8825_REG_CLK_DIVIDER,\r\nNAU8825_CLK_SRC_MASK, NAU8825_CLK_SRC_VCO);\r\nreturn 0;\r\n}\r\nstatic int nau8825_configure_sysclk(struct nau8825 *nau8825, int clk_id,\r\nunsigned int freq)\r\n{\r\nstruct regmap *regmap = nau8825->regmap;\r\nint ret;\r\nswitch (clk_id) {\r\ncase NAU8825_CLK_MCLK:\r\nregmap_update_bits(regmap, NAU8825_REG_CLK_DIVIDER,\r\nNAU8825_CLK_SRC_MASK, NAU8825_CLK_SRC_MCLK);\r\nregmap_update_bits(regmap, NAU8825_REG_FLL6, NAU8825_DCO_EN, 0);\r\nif (!nau8825->mclk)\r\nbreak;\r\nif (!nau8825->mclk_freq) {\r\nret = clk_prepare_enable(nau8825->mclk);\r\nif (ret) {\r\ndev_err(nau8825->dev, "Unable to prepare codec mclk\n");\r\nreturn ret;\r\n}\r\n}\r\nif (nau8825->mclk_freq != freq) {\r\nnau8825->mclk_freq = freq;\r\nfreq = clk_round_rate(nau8825->mclk, freq);\r\nret = clk_set_rate(nau8825->mclk, freq);\r\nif (ret) {\r\ndev_err(nau8825->dev, "Unable to set mclk rate\n");\r\nreturn ret;\r\n}\r\n}\r\nbreak;\r\ncase NAU8825_CLK_INTERNAL:\r\nregmap_update_bits(regmap, NAU8825_REG_FLL6, NAU8825_DCO_EN,\r\nNAU8825_DCO_EN);\r\nregmap_update_bits(regmap, NAU8825_REG_CLK_DIVIDER,\r\nNAU8825_CLK_SRC_MASK, NAU8825_CLK_SRC_VCO);\r\nif (nau8825->mclk_freq) {\r\nclk_disable_unprepare(nau8825->mclk);\r\nnau8825->mclk_freq = 0;\r\n}\r\nbreak;\r\ndefault:\r\ndev_err(nau8825->dev, "Invalid clock id (%d)\n", clk_id);\r\nreturn -EINVAL;\r\n}\r\ndev_dbg(nau8825->dev, "Sysclk is %dHz and clock id is %d\n", freq,\r\nclk_id);\r\nreturn 0;\r\n}\r\nstatic int nau8825_set_sysclk(struct snd_soc_codec *codec, int clk_id,\r\nint source, unsigned int freq, int dir)\r\n{\r\nstruct nau8825 *nau8825 = snd_soc_codec_get_drvdata(codec);\r\nreturn nau8825_configure_sysclk(nau8825, clk_id, freq);\r\n}\r\nstatic int nau8825_set_bias_level(struct snd_soc_codec *codec,\r\nenum snd_soc_bias_level level)\r\n{\r\nstruct nau8825 *nau8825 = snd_soc_codec_get_drvdata(codec);\r\nint ret;\r\nswitch (level) {\r\ncase SND_SOC_BIAS_ON:\r\nbreak;\r\ncase SND_SOC_BIAS_PREPARE:\r\nbreak;\r\ncase SND_SOC_BIAS_STANDBY:\r\nif (snd_soc_codec_get_bias_level(codec) == SND_SOC_BIAS_OFF) {\r\nif (nau8825->mclk_freq) {\r\nret = clk_prepare_enable(nau8825->mclk);\r\nif (ret) {\r\ndev_err(nau8825->dev, "Unable to prepare codec mclk\n");\r\nreturn ret;\r\n}\r\n}\r\n}\r\nbreak;\r\ncase SND_SOC_BIAS_OFF:\r\nif (nau8825->mclk_freq)\r\nclk_disable_unprepare(nau8825->mclk);\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic int nau8825_suspend(struct snd_soc_codec *codec)\r\n{\r\nstruct nau8825 *nau8825 = snd_soc_codec_get_drvdata(codec);\r\ndisable_irq(nau8825->irq);\r\nregcache_cache_only(nau8825->regmap, true);\r\nregcache_mark_dirty(nau8825->regmap);\r\nreturn 0;\r\n}\r\nstatic int nau8825_resume(struct snd_soc_codec *codec)\r\n{\r\nstruct nau8825 *nau8825 = snd_soc_codec_get_drvdata(codec);\r\nregcache_cache_only(nau8825->regmap, false);\r\nregcache_sync(nau8825->regmap);\r\nif (!nau8825_is_jack_inserted(nau8825->regmap)) {\r\nnau8825_eject_jack(nau8825);\r\nsnd_soc_jack_report(nau8825->jack, 0, SND_JACK_HEADSET);\r\n}\r\nenable_irq(nau8825->irq);\r\nnau8825_restart_jack_detection(nau8825->regmap);\r\nreturn 0;\r\n}\r\nstatic void nau8825_reset_chip(struct regmap *regmap)\r\n{\r\nregmap_write(regmap, NAU8825_REG_RESET, 0x00);\r\nregmap_write(regmap, NAU8825_REG_RESET, 0x00);\r\n}\r\nstatic void nau8825_print_device_properties(struct nau8825 *nau8825)\r\n{\r\nint i;\r\nstruct device *dev = nau8825->dev;\r\ndev_dbg(dev, "jkdet-enable: %d\n", nau8825->jkdet_enable);\r\ndev_dbg(dev, "jkdet-pull-enable: %d\n", nau8825->jkdet_pull_enable);\r\ndev_dbg(dev, "jkdet-pull-up: %d\n", nau8825->jkdet_pull_up);\r\ndev_dbg(dev, "jkdet-polarity: %d\n", nau8825->jkdet_polarity);\r\ndev_dbg(dev, "micbias-voltage: %d\n", nau8825->micbias_voltage);\r\ndev_dbg(dev, "vref-impedance: %d\n", nau8825->vref_impedance);\r\ndev_dbg(dev, "sar-threshold-num: %d\n", nau8825->sar_threshold_num);\r\nfor (i = 0; i < nau8825->sar_threshold_num; i++)\r\ndev_dbg(dev, "sar-threshold[%d]=%d\n", i,\r\nnau8825->sar_threshold[i]);\r\ndev_dbg(dev, "sar-hysteresis: %d\n", nau8825->sar_hysteresis);\r\ndev_dbg(dev, "sar-voltage: %d\n", nau8825->sar_voltage);\r\ndev_dbg(dev, "sar-compare-time: %d\n", nau8825->sar_compare_time);\r\ndev_dbg(dev, "sar-sampling-time: %d\n", nau8825->sar_sampling_time);\r\ndev_dbg(dev, "short-key-debounce: %d\n", nau8825->key_debounce);\r\ndev_dbg(dev, "jack-insert-debounce: %d\n",\r\nnau8825->jack_insert_debounce);\r\ndev_dbg(dev, "jack-eject-debounce: %d\n",\r\nnau8825->jack_eject_debounce);\r\n}\r\nstatic int nau8825_read_device_properties(struct device *dev,\r\nstruct nau8825 *nau8825) {\r\nnau8825->jkdet_enable = device_property_read_bool(dev,\r\n"nuvoton,jkdet-enable");\r\nnau8825->jkdet_pull_enable = device_property_read_bool(dev,\r\n"nuvoton,jkdet-pull-enable");\r\nnau8825->jkdet_pull_up = device_property_read_bool(dev,\r\n"nuvoton,jkdet-pull-up");\r\ndevice_property_read_u32(dev, "nuvoton,jkdet-polarity",\r\n&nau8825->jkdet_polarity);\r\ndevice_property_read_u32(dev, "nuvoton,micbias-voltage",\r\n&nau8825->micbias_voltage);\r\ndevice_property_read_u32(dev, "nuvoton,vref-impedance",\r\n&nau8825->vref_impedance);\r\ndevice_property_read_u32(dev, "nuvoton,sar-threshold-num",\r\n&nau8825->sar_threshold_num);\r\ndevice_property_read_u32_array(dev, "nuvoton,sar-threshold",\r\nnau8825->sar_threshold, nau8825->sar_threshold_num);\r\ndevice_property_read_u32(dev, "nuvoton,sar-hysteresis",\r\n&nau8825->sar_hysteresis);\r\ndevice_property_read_u32(dev, "nuvoton,sar-voltage",\r\n&nau8825->sar_voltage);\r\ndevice_property_read_u32(dev, "nuvoton,sar-compare-time",\r\n&nau8825->sar_compare_time);\r\ndevice_property_read_u32(dev, "nuvoton,sar-sampling-time",\r\n&nau8825->sar_sampling_time);\r\ndevice_property_read_u32(dev, "nuvoton,short-key-debounce",\r\n&nau8825->key_debounce);\r\ndevice_property_read_u32(dev, "nuvoton,jack-insert-debounce",\r\n&nau8825->jack_insert_debounce);\r\ndevice_property_read_u32(dev, "nuvoton,jack-eject-debounce",\r\n&nau8825->jack_eject_debounce);\r\nnau8825->mclk = devm_clk_get(dev, "mclk");\r\nif (PTR_ERR(nau8825->mclk) == -EPROBE_DEFER) {\r\nreturn -EPROBE_DEFER;\r\n} else if (PTR_ERR(nau8825->mclk) == -ENOENT) {\r\nnau8825->mclk = NULL;\r\ndev_info(dev, "No 'mclk' clock found, assume MCLK is managed externally");\r\n} else if (IS_ERR(nau8825->mclk)) {\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int nau8825_setup_irq(struct nau8825 *nau8825)\r\n{\r\nstruct regmap *regmap = nau8825->regmap;\r\nint ret;\r\nregmap_update_bits(regmap, NAU8825_REG_INTERRUPT_MASK,\r\nNAU8825_IRQ_OUTPUT_EN, NAU8825_IRQ_OUTPUT_EN);\r\nnau8825_configure_sysclk(nau8825, NAU8825_CLK_INTERNAL, 0);\r\nregmap_update_bits(regmap, NAU8825_REG_ENA_CTRL,\r\nNAU8825_ENABLE_DACR, NAU8825_ENABLE_DACR);\r\nret = devm_request_threaded_irq(nau8825->dev, nau8825->irq, NULL,\r\nnau8825_interrupt, IRQF_TRIGGER_LOW | IRQF_ONESHOT,\r\n"nau8825", nau8825);\r\nif (ret) {\r\ndev_err(nau8825->dev, "Cannot request irq %d (%d)\n",\r\nnau8825->irq, ret);\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic int nau8825_i2c_probe(struct i2c_client *i2c,\r\nconst struct i2c_device_id *id)\r\n{\r\nstruct device *dev = &i2c->dev;\r\nstruct nau8825 *nau8825 = dev_get_platdata(&i2c->dev);\r\nint ret, value;\r\nif (!nau8825) {\r\nnau8825 = devm_kzalloc(dev, sizeof(*nau8825), GFP_KERNEL);\r\nif (!nau8825)\r\nreturn -ENOMEM;\r\nret = nau8825_read_device_properties(dev, nau8825);\r\nif (ret)\r\nreturn ret;\r\n}\r\ni2c_set_clientdata(i2c, nau8825);\r\nnau8825->regmap = devm_regmap_init_i2c(i2c, &nau8825_regmap_config);\r\nif (IS_ERR(nau8825->regmap))\r\nreturn PTR_ERR(nau8825->regmap);\r\nnau8825->dev = dev;\r\nnau8825->irq = i2c->irq;\r\nnau8825_print_device_properties(nau8825);\r\nnau8825_reset_chip(nau8825->regmap);\r\nret = regmap_read(nau8825->regmap, NAU8825_REG_I2C_DEVICE_ID, &value);\r\nif (ret < 0) {\r\ndev_err(dev, "Failed to read device id from the NAU8825: %d\n",\r\nret);\r\nreturn ret;\r\n}\r\nif ((value & NAU8825_SOFTWARE_ID_MASK) !=\r\nNAU8825_SOFTWARE_ID_NAU8825) {\r\ndev_err(dev, "Not a NAU8825 chip\n");\r\nreturn -ENODEV;\r\n}\r\nnau8825_init_regs(nau8825);\r\nif (i2c->irq)\r\nnau8825_setup_irq(nau8825);\r\nreturn snd_soc_register_codec(&i2c->dev, &nau8825_codec_driver,\r\n&nau8825_dai, 1);\r\n}\r\nstatic int nau8825_i2c_remove(struct i2c_client *client)\r\n{\r\nsnd_soc_unregister_codec(&client->dev);\r\nreturn 0;\r\n}
