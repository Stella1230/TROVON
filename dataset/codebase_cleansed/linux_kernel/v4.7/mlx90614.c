static s32 mlx90614_write_word(const struct i2c_client *client, u8 command,\r\nu16 value)\r\n{\r\nunion i2c_smbus_data data;\r\ns32 ret;\r\ndev_dbg(&client->dev, "Writing 0x%x to address 0x%x", value, command);\r\ndata.word = 0x0000;\r\nret = i2c_smbus_xfer(client->adapter, client->addr,\r\nclient->flags | I2C_CLIENT_PEC,\r\nI2C_SMBUS_WRITE, command,\r\nI2C_SMBUS_WORD_DATA, &data);\r\nif (ret < 0)\r\nreturn ret;\r\nmsleep(MLX90614_TIMING_EEPROM);\r\ndata.word = value;\r\nret = i2c_smbus_xfer(client->adapter, client->addr,\r\nclient->flags | I2C_CLIENT_PEC,\r\nI2C_SMBUS_WRITE, command,\r\nI2C_SMBUS_WORD_DATA, &data);\r\nmsleep(MLX90614_TIMING_EEPROM);\r\nreturn ret;\r\n}\r\nstatic inline s32 mlx90614_iir_search(const struct i2c_client *client,\r\nint value)\r\n{\r\nint i;\r\ns32 ret;\r\nfor (i = 0; i < ARRAY_SIZE(mlx90614_iir_values); ++i) {\r\nif (value == mlx90614_iir_values[i])\r\nbreak;\r\n}\r\nif (i == ARRAY_SIZE(mlx90614_iir_values))\r\nreturn -EINVAL;\r\nret = i2c_smbus_read_word_data(client, MLX90614_CONFIG);\r\nif (ret < 0)\r\nreturn ret;\r\nret &= ~MLX90614_CONFIG_FIR_MASK;\r\nret |= MLX90614_CONST_FIR << MLX90614_CONFIG_FIR_SHIFT;\r\nret &= ~MLX90614_CONFIG_IIR_MASK;\r\nret |= i << MLX90614_CONFIG_IIR_SHIFT;\r\nret = mlx90614_write_word(client, MLX90614_CONFIG, ret);\r\nreturn ret;\r\n}\r\nstatic int mlx90614_power_get(struct mlx90614_data *data, bool startup)\r\n{\r\nunsigned long now;\r\nif (!data->wakeup_gpio)\r\nreturn 0;\r\npm_runtime_get_sync(&data->client->dev);\r\nif (startup) {\r\nnow = jiffies;\r\nif (time_before(now, data->ready_timestamp) &&\r\nmsleep_interruptible(jiffies_to_msecs(\r\ndata->ready_timestamp - now)) != 0) {\r\npm_runtime_put_autosuspend(&data->client->dev);\r\nreturn -EINTR;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic void mlx90614_power_put(struct mlx90614_data *data)\r\n{\r\nif (!data->wakeup_gpio)\r\nreturn;\r\npm_runtime_mark_last_busy(&data->client->dev);\r\npm_runtime_put_autosuspend(&data->client->dev);\r\n}\r\nstatic inline int mlx90614_power_get(struct mlx90614_data *data, bool startup)\r\n{\r\nreturn 0;\r\n}\r\nstatic inline void mlx90614_power_put(struct mlx90614_data *data)\r\n{\r\n}\r\nstatic int mlx90614_read_raw(struct iio_dev *indio_dev,\r\nstruct iio_chan_spec const *channel, int *val,\r\nint *val2, long mask)\r\n{\r\nstruct mlx90614_data *data = iio_priv(indio_dev);\r\nu8 cmd;\r\ns32 ret;\r\nswitch (mask) {\r\ncase IIO_CHAN_INFO_RAW:\r\nswitch (channel->channel2) {\r\ncase IIO_MOD_TEMP_AMBIENT:\r\ncmd = MLX90614_TA;\r\nbreak;\r\ncase IIO_MOD_TEMP_OBJECT:\r\nswitch (channel->channel) {\r\ncase 0:\r\ncmd = MLX90614_TOBJ1;\r\nbreak;\r\ncase 1:\r\ncmd = MLX90614_TOBJ2;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nret = mlx90614_power_get(data, true);\r\nif (ret < 0)\r\nreturn ret;\r\nret = i2c_smbus_read_word_data(data->client, cmd);\r\nmlx90614_power_put(data);\r\nif (ret < 0)\r\nreturn ret;\r\nif (ret & 0x8000)\r\nreturn -EIO;\r\n*val = ret;\r\nreturn IIO_VAL_INT;\r\ncase IIO_CHAN_INFO_OFFSET:\r\n*val = MLX90614_CONST_OFFSET_DEC;\r\n*val2 = MLX90614_CONST_OFFSET_REM;\r\nreturn IIO_VAL_INT_PLUS_MICRO;\r\ncase IIO_CHAN_INFO_SCALE:\r\n*val = MLX90614_CONST_SCALE;\r\nreturn IIO_VAL_INT;\r\ncase IIO_CHAN_INFO_CALIBEMISSIVITY:\r\nmlx90614_power_get(data, false);\r\nmutex_lock(&data->lock);\r\nret = i2c_smbus_read_word_data(data->client,\r\nMLX90614_EMISSIVITY);\r\nmutex_unlock(&data->lock);\r\nmlx90614_power_put(data);\r\nif (ret < 0)\r\nreturn ret;\r\nif (ret == MLX90614_CONST_RAW_EMISSIVITY_MAX) {\r\n*val = 1;\r\n*val2 = 0;\r\n} else {\r\n*val = 0;\r\n*val2 = ret * MLX90614_CONST_EMISSIVITY_RESOLUTION;\r\n}\r\nreturn IIO_VAL_INT_PLUS_NANO;\r\ncase IIO_CHAN_INFO_LOW_PASS_FILTER_3DB_FREQUENCY:\r\nmlx90614_power_get(data, false);\r\nmutex_lock(&data->lock);\r\nret = i2c_smbus_read_word_data(data->client, MLX90614_CONFIG);\r\nmutex_unlock(&data->lock);\r\nmlx90614_power_put(data);\r\nif (ret < 0)\r\nreturn ret;\r\n*val = mlx90614_iir_values[ret & MLX90614_CONFIG_IIR_MASK] / 100;\r\n*val2 = (mlx90614_iir_values[ret & MLX90614_CONFIG_IIR_MASK] % 100) *\r\n10000;\r\nreturn IIO_VAL_INT_PLUS_MICRO;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\n}\r\nstatic int mlx90614_write_raw(struct iio_dev *indio_dev,\r\nstruct iio_chan_spec const *channel, int val,\r\nint val2, long mask)\r\n{\r\nstruct mlx90614_data *data = iio_priv(indio_dev);\r\ns32 ret;\r\nswitch (mask) {\r\ncase IIO_CHAN_INFO_CALIBEMISSIVITY:\r\nif (val < 0 || val2 < 0 || val > 1 || (val == 1 && val2 != 0))\r\nreturn -EINVAL;\r\nval = val * MLX90614_CONST_RAW_EMISSIVITY_MAX +\r\nval2 / MLX90614_CONST_EMISSIVITY_RESOLUTION;\r\nmlx90614_power_get(data, false);\r\nmutex_lock(&data->lock);\r\nret = mlx90614_write_word(data->client, MLX90614_EMISSIVITY,\r\nval);\r\nmutex_unlock(&data->lock);\r\nmlx90614_power_put(data);\r\nreturn ret;\r\ncase IIO_CHAN_INFO_LOW_PASS_FILTER_3DB_FREQUENCY:\r\nif (val < 0 || val2 < 0)\r\nreturn -EINVAL;\r\nmlx90614_power_get(data, false);\r\nmutex_lock(&data->lock);\r\nret = mlx90614_iir_search(data->client,\r\nval * 100 + val2 / 10000);\r\nmutex_unlock(&data->lock);\r\nmlx90614_power_put(data);\r\nreturn ret;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\n}\r\nstatic int mlx90614_write_raw_get_fmt(struct iio_dev *indio_dev,\r\nstruct iio_chan_spec const *channel,\r\nlong mask)\r\n{\r\nswitch (mask) {\r\ncase IIO_CHAN_INFO_CALIBEMISSIVITY:\r\nreturn IIO_VAL_INT_PLUS_NANO;\r\ncase IIO_CHAN_INFO_LOW_PASS_FILTER_3DB_FREQUENCY:\r\nreturn IIO_VAL_INT_PLUS_MICRO;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\n}\r\nstatic int mlx90614_sleep(struct mlx90614_data *data)\r\n{\r\ns32 ret;\r\nif (!data->wakeup_gpio) {\r\ndev_dbg(&data->client->dev, "Sleep disabled");\r\nreturn -ENOSYS;\r\n}\r\ndev_dbg(&data->client->dev, "Requesting sleep");\r\nmutex_lock(&data->lock);\r\nret = i2c_smbus_xfer(data->client->adapter, data->client->addr,\r\ndata->client->flags | I2C_CLIENT_PEC,\r\nI2C_SMBUS_WRITE, MLX90614_OP_SLEEP,\r\nI2C_SMBUS_BYTE, NULL);\r\nmutex_unlock(&data->lock);\r\nreturn ret;\r\n}\r\nstatic int mlx90614_wakeup(struct mlx90614_data *data)\r\n{\r\nif (!data->wakeup_gpio) {\r\ndev_dbg(&data->client->dev, "Wake-up disabled");\r\nreturn -ENOSYS;\r\n}\r\ndev_dbg(&data->client->dev, "Requesting wake-up");\r\ni2c_lock_adapter(data->client->adapter);\r\ngpiod_direction_output(data->wakeup_gpio, 0);\r\nmsleep(MLX90614_TIMING_WAKEUP);\r\ngpiod_direction_input(data->wakeup_gpio);\r\ni2c_unlock_adapter(data->client->adapter);\r\ndata->ready_timestamp = jiffies +\r\nmsecs_to_jiffies(MLX90614_TIMING_STARTUP);\r\ni2c_smbus_read_word_data(data->client, MLX90614_CONFIG);\r\nreturn 0;\r\n}\r\nstatic struct gpio_desc *mlx90614_probe_wakeup(struct i2c_client *client)\r\n{\r\nstruct gpio_desc *gpio;\r\nif (!i2c_check_functionality(client->adapter,\r\nI2C_FUNC_SMBUS_WRITE_BYTE)) {\r\ndev_info(&client->dev,\r\n"i2c adapter does not support SMBUS_WRITE_BYTE, sleep disabled");\r\nreturn NULL;\r\n}\r\ngpio = devm_gpiod_get_optional(&client->dev, "wakeup", GPIOD_IN);\r\nif (IS_ERR(gpio)) {\r\ndev_warn(&client->dev,\r\n"gpio acquisition failed with error %ld, sleep disabled",\r\nPTR_ERR(gpio));\r\nreturn NULL;\r\n} else if (!gpio) {\r\ndev_info(&client->dev,\r\n"wakeup-gpio not found, sleep disabled");\r\n}\r\nreturn gpio;\r\n}\r\nstatic inline int mlx90614_sleep(struct mlx90614_data *data)\r\n{\r\nreturn -ENOSYS;\r\n}\r\nstatic inline int mlx90614_wakeup(struct mlx90614_data *data)\r\n{\r\nreturn -ENOSYS;\r\n}\r\nstatic inline struct gpio_desc *mlx90614_probe_wakeup(struct i2c_client *client)\r\n{\r\nreturn NULL;\r\n}\r\nstatic int mlx90614_probe_num_ir_sensors(struct i2c_client *client)\r\n{\r\ns32 ret;\r\nret = i2c_smbus_read_word_data(client, MLX90614_CONFIG);\r\nif (ret < 0)\r\nreturn ret;\r\nreturn (ret & MLX90614_CONFIG_DUAL_MASK) ? 1 : 0;\r\n}\r\nstatic int mlx90614_probe(struct i2c_client *client,\r\nconst struct i2c_device_id *id)\r\n{\r\nstruct iio_dev *indio_dev;\r\nstruct mlx90614_data *data;\r\nint ret;\r\nif (!i2c_check_functionality(client->adapter, I2C_FUNC_SMBUS_WORD_DATA))\r\nreturn -EOPNOTSUPP;\r\nindio_dev = devm_iio_device_alloc(&client->dev, sizeof(*data));\r\nif (!indio_dev)\r\nreturn -ENOMEM;\r\ndata = iio_priv(indio_dev);\r\ni2c_set_clientdata(client, indio_dev);\r\ndata->client = client;\r\nmutex_init(&data->lock);\r\ndata->wakeup_gpio = mlx90614_probe_wakeup(client);\r\nmlx90614_wakeup(data);\r\nindio_dev->dev.parent = &client->dev;\r\nindio_dev->name = id->name;\r\nindio_dev->modes = INDIO_DIRECT_MODE;\r\nindio_dev->info = &mlx90614_info;\r\nret = mlx90614_probe_num_ir_sensors(client);\r\nswitch (ret) {\r\ncase 0:\r\ndev_dbg(&client->dev, "Found single sensor");\r\nindio_dev->channels = mlx90614_channels;\r\nindio_dev->num_channels = 2;\r\nbreak;\r\ncase 1:\r\ndev_dbg(&client->dev, "Found dual sensor");\r\nindio_dev->channels = mlx90614_channels;\r\nindio_dev->num_channels = 3;\r\nbreak;\r\ndefault:\r\nreturn ret;\r\n}\r\nif (data->wakeup_gpio) {\r\npm_runtime_set_autosuspend_delay(&client->dev,\r\nMLX90614_AUTOSLEEP_DELAY);\r\npm_runtime_use_autosuspend(&client->dev);\r\npm_runtime_set_active(&client->dev);\r\npm_runtime_enable(&client->dev);\r\n}\r\nreturn iio_device_register(indio_dev);\r\n}\r\nstatic int mlx90614_remove(struct i2c_client *client)\r\n{\r\nstruct iio_dev *indio_dev = i2c_get_clientdata(client);\r\nstruct mlx90614_data *data = iio_priv(indio_dev);\r\niio_device_unregister(indio_dev);\r\nif (data->wakeup_gpio) {\r\npm_runtime_disable(&client->dev);\r\nif (!pm_runtime_status_suspended(&client->dev))\r\nmlx90614_sleep(data);\r\npm_runtime_set_suspended(&client->dev);\r\n}\r\nreturn 0;\r\n}\r\nstatic int mlx90614_pm_suspend(struct device *dev)\r\n{\r\nstruct iio_dev *indio_dev = i2c_get_clientdata(to_i2c_client(dev));\r\nstruct mlx90614_data *data = iio_priv(indio_dev);\r\nif (data->wakeup_gpio && pm_runtime_active(dev))\r\nreturn mlx90614_sleep(data);\r\nreturn 0;\r\n}\r\nstatic int mlx90614_pm_resume(struct device *dev)\r\n{\r\nstruct iio_dev *indio_dev = i2c_get_clientdata(to_i2c_client(dev));\r\nstruct mlx90614_data *data = iio_priv(indio_dev);\r\nint err;\r\nif (data->wakeup_gpio) {\r\nerr = mlx90614_wakeup(data);\r\nif (err < 0)\r\nreturn err;\r\npm_runtime_disable(dev);\r\npm_runtime_set_active(dev);\r\npm_runtime_enable(dev);\r\n}\r\nreturn 0;\r\n}\r\nstatic int mlx90614_pm_runtime_suspend(struct device *dev)\r\n{\r\nstruct iio_dev *indio_dev = i2c_get_clientdata(to_i2c_client(dev));\r\nstruct mlx90614_data *data = iio_priv(indio_dev);\r\nreturn mlx90614_sleep(data);\r\n}\r\nstatic int mlx90614_pm_runtime_resume(struct device *dev)\r\n{\r\nstruct iio_dev *indio_dev = i2c_get_clientdata(to_i2c_client(dev));\r\nstruct mlx90614_data *data = iio_priv(indio_dev);\r\nreturn mlx90614_wakeup(data);\r\n}
