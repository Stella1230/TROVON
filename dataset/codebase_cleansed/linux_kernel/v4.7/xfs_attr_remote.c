int\r\nxfs_attr3_rmt_blocks(\r\nstruct xfs_mount *mp,\r\nint attrlen)\r\n{\r\nif (xfs_sb_version_hascrc(&mp->m_sb)) {\r\nint buflen = XFS_ATTR3_RMT_BUF_SPACE(mp, mp->m_sb.sb_blocksize);\r\nreturn (attrlen + buflen - 1) / buflen;\r\n}\r\nreturn XFS_B_TO_FSB(mp, attrlen);\r\n}\r\nstatic bool\r\nxfs_attr3_rmt_hdr_ok(\r\nvoid *ptr,\r\nxfs_ino_t ino,\r\nuint32_t offset,\r\nuint32_t size,\r\nxfs_daddr_t bno)\r\n{\r\nstruct xfs_attr3_rmt_hdr *rmt = ptr;\r\nif (bno != be64_to_cpu(rmt->rm_blkno))\r\nreturn false;\r\nif (offset != be32_to_cpu(rmt->rm_offset))\r\nreturn false;\r\nif (size != be32_to_cpu(rmt->rm_bytes))\r\nreturn false;\r\nif (ino != be64_to_cpu(rmt->rm_owner))\r\nreturn false;\r\nreturn true;\r\n}\r\nstatic bool\r\nxfs_attr3_rmt_verify(\r\nstruct xfs_mount *mp,\r\nvoid *ptr,\r\nint fsbsize,\r\nxfs_daddr_t bno)\r\n{\r\nstruct xfs_attr3_rmt_hdr *rmt = ptr;\r\nif (!xfs_sb_version_hascrc(&mp->m_sb))\r\nreturn false;\r\nif (rmt->rm_magic != cpu_to_be32(XFS_ATTR3_RMT_MAGIC))\r\nreturn false;\r\nif (!uuid_equal(&rmt->rm_uuid, &mp->m_sb.sb_meta_uuid))\r\nreturn false;\r\nif (be64_to_cpu(rmt->rm_blkno) != bno)\r\nreturn false;\r\nif (be32_to_cpu(rmt->rm_bytes) > fsbsize - sizeof(*rmt))\r\nreturn false;\r\nif (be32_to_cpu(rmt->rm_offset) +\r\nbe32_to_cpu(rmt->rm_bytes) > XFS_XATTR_SIZE_MAX)\r\nreturn false;\r\nif (rmt->rm_owner == 0)\r\nreturn false;\r\nreturn true;\r\n}\r\nstatic void\r\nxfs_attr3_rmt_read_verify(\r\nstruct xfs_buf *bp)\r\n{\r\nstruct xfs_mount *mp = bp->b_target->bt_mount;\r\nchar *ptr;\r\nint len;\r\nxfs_daddr_t bno;\r\nint blksize = mp->m_attr_geo->blksize;\r\nif (!xfs_sb_version_hascrc(&mp->m_sb))\r\nreturn;\r\nptr = bp->b_addr;\r\nbno = bp->b_bn;\r\nlen = BBTOB(bp->b_length);\r\nASSERT(len >= blksize);\r\nwhile (len > 0) {\r\nif (!xfs_verify_cksum(ptr, blksize, XFS_ATTR3_RMT_CRC_OFF)) {\r\nxfs_buf_ioerror(bp, -EFSBADCRC);\r\nbreak;\r\n}\r\nif (!xfs_attr3_rmt_verify(mp, ptr, blksize, bno)) {\r\nxfs_buf_ioerror(bp, -EFSCORRUPTED);\r\nbreak;\r\n}\r\nlen -= blksize;\r\nptr += blksize;\r\nbno += BTOBB(blksize);\r\n}\r\nif (bp->b_error)\r\nxfs_verifier_error(bp);\r\nelse\r\nASSERT(len == 0);\r\n}\r\nstatic void\r\nxfs_attr3_rmt_write_verify(\r\nstruct xfs_buf *bp)\r\n{\r\nstruct xfs_mount *mp = bp->b_target->bt_mount;\r\nint blksize = mp->m_attr_geo->blksize;\r\nchar *ptr;\r\nint len;\r\nxfs_daddr_t bno;\r\nif (!xfs_sb_version_hascrc(&mp->m_sb))\r\nreturn;\r\nptr = bp->b_addr;\r\nbno = bp->b_bn;\r\nlen = BBTOB(bp->b_length);\r\nASSERT(len >= blksize);\r\nwhile (len > 0) {\r\nstruct xfs_attr3_rmt_hdr *rmt = (struct xfs_attr3_rmt_hdr *)ptr;\r\nif (!xfs_attr3_rmt_verify(mp, ptr, blksize, bno)) {\r\nxfs_buf_ioerror(bp, -EFSCORRUPTED);\r\nxfs_verifier_error(bp);\r\nreturn;\r\n}\r\nif (rmt->rm_lsn != cpu_to_be64(NULLCOMMITLSN)) {\r\nxfs_buf_ioerror(bp, -EFSCORRUPTED);\r\nxfs_verifier_error(bp);\r\nreturn;\r\n}\r\nxfs_update_cksum(ptr, blksize, XFS_ATTR3_RMT_CRC_OFF);\r\nlen -= blksize;\r\nptr += blksize;\r\nbno += BTOBB(blksize);\r\n}\r\nASSERT(len == 0);\r\n}\r\nSTATIC int\r\nxfs_attr3_rmt_hdr_set(\r\nstruct xfs_mount *mp,\r\nvoid *ptr,\r\nxfs_ino_t ino,\r\nuint32_t offset,\r\nuint32_t size,\r\nxfs_daddr_t bno)\r\n{\r\nstruct xfs_attr3_rmt_hdr *rmt = ptr;\r\nif (!xfs_sb_version_hascrc(&mp->m_sb))\r\nreturn 0;\r\nrmt->rm_magic = cpu_to_be32(XFS_ATTR3_RMT_MAGIC);\r\nrmt->rm_offset = cpu_to_be32(offset);\r\nrmt->rm_bytes = cpu_to_be32(size);\r\nuuid_copy(&rmt->rm_uuid, &mp->m_sb.sb_meta_uuid);\r\nrmt->rm_owner = cpu_to_be64(ino);\r\nrmt->rm_blkno = cpu_to_be64(bno);\r\nrmt->rm_lsn = cpu_to_be64(NULLCOMMITLSN);\r\nreturn sizeof(struct xfs_attr3_rmt_hdr);\r\n}\r\nSTATIC int\r\nxfs_attr_rmtval_copyout(\r\nstruct xfs_mount *mp,\r\nstruct xfs_buf *bp,\r\nxfs_ino_t ino,\r\nint *offset,\r\nint *valuelen,\r\n__uint8_t **dst)\r\n{\r\nchar *src = bp->b_addr;\r\nxfs_daddr_t bno = bp->b_bn;\r\nint len = BBTOB(bp->b_length);\r\nint blksize = mp->m_attr_geo->blksize;\r\nASSERT(len >= blksize);\r\nwhile (len > 0 && *valuelen > 0) {\r\nint hdr_size = 0;\r\nint byte_cnt = XFS_ATTR3_RMT_BUF_SPACE(mp, blksize);\r\nbyte_cnt = min(*valuelen, byte_cnt);\r\nif (xfs_sb_version_hascrc(&mp->m_sb)) {\r\nif (!xfs_attr3_rmt_hdr_ok(src, ino, *offset,\r\nbyte_cnt, bno)) {\r\nxfs_alert(mp,\r\n"remote attribute header mismatch bno/off/len/owner (0x%llx/0x%x/Ox%x/0x%llx)",\r\nbno, *offset, byte_cnt, ino);\r\nreturn -EFSCORRUPTED;\r\n}\r\nhdr_size = sizeof(struct xfs_attr3_rmt_hdr);\r\n}\r\nmemcpy(*dst, src + hdr_size, byte_cnt);\r\nlen -= blksize;\r\nsrc += blksize;\r\nbno += BTOBB(blksize);\r\n*valuelen -= byte_cnt;\r\n*dst += byte_cnt;\r\n*offset += byte_cnt;\r\n}\r\nreturn 0;\r\n}\r\nSTATIC void\r\nxfs_attr_rmtval_copyin(\r\nstruct xfs_mount *mp,\r\nstruct xfs_buf *bp,\r\nxfs_ino_t ino,\r\nint *offset,\r\nint *valuelen,\r\n__uint8_t **src)\r\n{\r\nchar *dst = bp->b_addr;\r\nxfs_daddr_t bno = bp->b_bn;\r\nint len = BBTOB(bp->b_length);\r\nint blksize = mp->m_attr_geo->blksize;\r\nASSERT(len >= blksize);\r\nwhile (len > 0 && *valuelen > 0) {\r\nint hdr_size;\r\nint byte_cnt = XFS_ATTR3_RMT_BUF_SPACE(mp, blksize);\r\nbyte_cnt = min(*valuelen, byte_cnt);\r\nhdr_size = xfs_attr3_rmt_hdr_set(mp, dst, ino, *offset,\r\nbyte_cnt, bno);\r\nmemcpy(dst + hdr_size, *src, byte_cnt);\r\nif (byte_cnt + hdr_size < blksize) {\r\nASSERT(*valuelen - byte_cnt == 0);\r\nASSERT(len == blksize);\r\nmemset(dst + hdr_size + byte_cnt, 0,\r\nblksize - hdr_size - byte_cnt);\r\n}\r\nlen -= blksize;\r\ndst += blksize;\r\nbno += BTOBB(blksize);\r\n*valuelen -= byte_cnt;\r\n*src += byte_cnt;\r\n*offset += byte_cnt;\r\n}\r\n}\r\nint\r\nxfs_attr_rmtval_get(\r\nstruct xfs_da_args *args)\r\n{\r\nstruct xfs_bmbt_irec map[ATTR_RMTVALUE_MAPSIZE];\r\nstruct xfs_mount *mp = args->dp->i_mount;\r\nstruct xfs_buf *bp;\r\nxfs_dablk_t lblkno = args->rmtblkno;\r\n__uint8_t *dst = args->value;\r\nint valuelen;\r\nint nmap;\r\nint error;\r\nint blkcnt = args->rmtblkcnt;\r\nint i;\r\nint offset = 0;\r\ntrace_xfs_attr_rmtval_get(args);\r\nASSERT(!(args->flags & ATTR_KERNOVAL));\r\nASSERT(args->rmtvaluelen == args->valuelen);\r\nvaluelen = args->rmtvaluelen;\r\nwhile (valuelen > 0) {\r\nnmap = ATTR_RMTVALUE_MAPSIZE;\r\nerror = xfs_bmapi_read(args->dp, (xfs_fileoff_t)lblkno,\r\nblkcnt, map, &nmap,\r\nXFS_BMAPI_ATTRFORK);\r\nif (error)\r\nreturn error;\r\nASSERT(nmap >= 1);\r\nfor (i = 0; (i < nmap) && (valuelen > 0); i++) {\r\nxfs_daddr_t dblkno;\r\nint dblkcnt;\r\nASSERT((map[i].br_startblock != DELAYSTARTBLOCK) &&\r\n(map[i].br_startblock != HOLESTARTBLOCK));\r\ndblkno = XFS_FSB_TO_DADDR(mp, map[i].br_startblock);\r\ndblkcnt = XFS_FSB_TO_BB(mp, map[i].br_blockcount);\r\nerror = xfs_trans_read_buf(mp, NULL, mp->m_ddev_targp,\r\ndblkno, dblkcnt, 0, &bp,\r\n&xfs_attr3_rmt_buf_ops);\r\nif (error)\r\nreturn error;\r\nerror = xfs_attr_rmtval_copyout(mp, bp, args->dp->i_ino,\r\n&offset, &valuelen,\r\n&dst);\r\nxfs_buf_relse(bp);\r\nif (error)\r\nreturn error;\r\nlblkno += map[i].br_blockcount;\r\nblkcnt -= map[i].br_blockcount;\r\n}\r\n}\r\nASSERT(valuelen == 0);\r\nreturn 0;\r\n}\r\nint\r\nxfs_attr_rmtval_set(\r\nstruct xfs_da_args *args)\r\n{\r\nstruct xfs_inode *dp = args->dp;\r\nstruct xfs_mount *mp = dp->i_mount;\r\nstruct xfs_bmbt_irec map;\r\nxfs_dablk_t lblkno;\r\nxfs_fileoff_t lfileoff = 0;\r\n__uint8_t *src = args->value;\r\nint blkcnt;\r\nint valuelen;\r\nint nmap;\r\nint error;\r\nint offset = 0;\r\ntrace_xfs_attr_rmtval_set(args);\r\nblkcnt = xfs_attr3_rmt_blocks(mp, args->rmtvaluelen);\r\nerror = xfs_bmap_first_unused(args->trans, args->dp, blkcnt, &lfileoff,\r\nXFS_ATTR_FORK);\r\nif (error)\r\nreturn error;\r\nargs->rmtblkno = lblkno = (xfs_dablk_t)lfileoff;\r\nargs->rmtblkcnt = blkcnt;\r\nwhile (blkcnt > 0) {\r\nxfs_bmap_init(args->flist, args->firstblock);\r\nnmap = 1;\r\nerror = xfs_bmapi_write(args->trans, dp, (xfs_fileoff_t)lblkno,\r\nblkcnt, XFS_BMAPI_ATTRFORK, args->firstblock,\r\nargs->total, &map, &nmap, args->flist);\r\nif (!error)\r\nerror = xfs_bmap_finish(&args->trans, args->flist, dp);\r\nif (error) {\r\nargs->trans = NULL;\r\nxfs_bmap_cancel(args->flist);\r\nreturn error;\r\n}\r\nASSERT(nmap == 1);\r\nASSERT((map.br_startblock != DELAYSTARTBLOCK) &&\r\n(map.br_startblock != HOLESTARTBLOCK));\r\nlblkno += map.br_blockcount;\r\nblkcnt -= map.br_blockcount;\r\nerror = xfs_trans_roll(&args->trans, dp);\r\nif (error)\r\nreturn error;\r\n}\r\nlblkno = args->rmtblkno;\r\nblkcnt = args->rmtblkcnt;\r\nvaluelen = args->rmtvaluelen;\r\nwhile (valuelen > 0) {\r\nstruct xfs_buf *bp;\r\nxfs_daddr_t dblkno;\r\nint dblkcnt;\r\nASSERT(blkcnt > 0);\r\nxfs_bmap_init(args->flist, args->firstblock);\r\nnmap = 1;\r\nerror = xfs_bmapi_read(dp, (xfs_fileoff_t)lblkno,\r\nblkcnt, &map, &nmap,\r\nXFS_BMAPI_ATTRFORK);\r\nif (error)\r\nreturn error;\r\nASSERT(nmap == 1);\r\nASSERT((map.br_startblock != DELAYSTARTBLOCK) &&\r\n(map.br_startblock != HOLESTARTBLOCK));\r\ndblkno = XFS_FSB_TO_DADDR(mp, map.br_startblock),\r\ndblkcnt = XFS_FSB_TO_BB(mp, map.br_blockcount);\r\nbp = xfs_buf_get(mp->m_ddev_targp, dblkno, dblkcnt, 0);\r\nif (!bp)\r\nreturn -ENOMEM;\r\nbp->b_ops = &xfs_attr3_rmt_buf_ops;\r\nxfs_attr_rmtval_copyin(mp, bp, args->dp->i_ino, &offset,\r\n&valuelen, &src);\r\nerror = xfs_bwrite(bp);\r\nxfs_buf_relse(bp);\r\nif (error)\r\nreturn error;\r\nlblkno += map.br_blockcount;\r\nblkcnt -= map.br_blockcount;\r\n}\r\nASSERT(valuelen == 0);\r\nreturn 0;\r\n}\r\nint\r\nxfs_attr_rmtval_remove(\r\nstruct xfs_da_args *args)\r\n{\r\nstruct xfs_mount *mp = args->dp->i_mount;\r\nxfs_dablk_t lblkno;\r\nint blkcnt;\r\nint error;\r\nint done;\r\ntrace_xfs_attr_rmtval_remove(args);\r\nlblkno = args->rmtblkno;\r\nblkcnt = args->rmtblkcnt;\r\nwhile (blkcnt > 0) {\r\nstruct xfs_bmbt_irec map;\r\nstruct xfs_buf *bp;\r\nxfs_daddr_t dblkno;\r\nint dblkcnt;\r\nint nmap;\r\nnmap = 1;\r\nerror = xfs_bmapi_read(args->dp, (xfs_fileoff_t)lblkno,\r\nblkcnt, &map, &nmap, XFS_BMAPI_ATTRFORK);\r\nif (error)\r\nreturn error;\r\nASSERT(nmap == 1);\r\nASSERT((map.br_startblock != DELAYSTARTBLOCK) &&\r\n(map.br_startblock != HOLESTARTBLOCK));\r\ndblkno = XFS_FSB_TO_DADDR(mp, map.br_startblock),\r\ndblkcnt = XFS_FSB_TO_BB(mp, map.br_blockcount);\r\nbp = xfs_incore(mp->m_ddev_targp, dblkno, dblkcnt, XBF_TRYLOCK);\r\nif (bp) {\r\nxfs_buf_stale(bp);\r\nxfs_buf_relse(bp);\r\nbp = NULL;\r\n}\r\nlblkno += map.br_blockcount;\r\nblkcnt -= map.br_blockcount;\r\n}\r\nlblkno = args->rmtblkno;\r\nblkcnt = args->rmtblkcnt;\r\ndone = 0;\r\nwhile (!done) {\r\nxfs_bmap_init(args->flist, args->firstblock);\r\nerror = xfs_bunmapi(args->trans, args->dp, lblkno, blkcnt,\r\nXFS_BMAPI_ATTRFORK, 1, args->firstblock,\r\nargs->flist, &done);\r\nif (!error)\r\nerror = xfs_bmap_finish(&args->trans, args->flist,\r\nargs->dp);\r\nif (error) {\r\nargs->trans = NULL;\r\nxfs_bmap_cancel(args->flist);\r\nreturn error;\r\n}\r\nerror = xfs_trans_roll(&args->trans, args->dp);\r\nif (error)\r\nreturn error;\r\n}\r\nreturn 0;\r\n}
