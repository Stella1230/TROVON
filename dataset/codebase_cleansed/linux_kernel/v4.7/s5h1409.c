static int s5h1409_writereg(struct s5h1409_state *state, u8 reg, u16 data)\r\n{\r\nint ret;\r\nu8 buf[] = { reg, data >> 8, data & 0xff };\r\nstruct i2c_msg msg = { .addr = state->config->demod_address,\r\n.flags = 0, .buf = buf, .len = 3 };\r\nret = i2c_transfer(state->i2c, &msg, 1);\r\nif (ret != 1)\r\nprintk(KERN_ERR "%s: error (reg == 0x%02x, val == 0x%04x, "\r\n"ret == %i)\n", __func__, reg, data, ret);\r\nreturn (ret != 1) ? -1 : 0;\r\n}\r\nstatic u16 s5h1409_readreg(struct s5h1409_state *state, u8 reg)\r\n{\r\nint ret;\r\nu8 b0[] = { reg };\r\nu8 b1[] = { 0, 0 };\r\nstruct i2c_msg msg[] = {\r\n{ .addr = state->config->demod_address, .flags = 0,\r\n.buf = b0, .len = 1 },\r\n{ .addr = state->config->demod_address, .flags = I2C_M_RD,\r\n.buf = b1, .len = 2 } };\r\nret = i2c_transfer(state->i2c, msg, 2);\r\nif (ret != 2)\r\nprintk("%s: readreg error (ret == %i)\n", __func__, ret);\r\nreturn (b1[0] << 8) | b1[1];\r\n}\r\nstatic int s5h1409_softreset(struct dvb_frontend *fe)\r\n{\r\nstruct s5h1409_state *state = fe->demodulator_priv;\r\ndprintk("%s()\n", __func__);\r\ns5h1409_writereg(state, 0xf5, 0);\r\ns5h1409_writereg(state, 0xf5, 1);\r\nstate->is_qam_locked = 0;\r\nstate->qam_state = QAM_STATE_UNTUNED;\r\nreturn 0;\r\n}\r\nstatic int s5h1409_set_if_freq(struct dvb_frontend *fe, int KHz)\r\n{\r\nstruct s5h1409_state *state = fe->demodulator_priv;\r\ndprintk("%s(%d KHz)\n", __func__, KHz);\r\nswitch (KHz) {\r\ncase 4000:\r\ns5h1409_writereg(state, 0x87, 0x014b);\r\ns5h1409_writereg(state, 0x88, 0x0cb5);\r\ns5h1409_writereg(state, 0x89, 0x03e2);\r\nbreak;\r\ncase 5380:\r\ncase 44000:\r\ndefault:\r\ns5h1409_writereg(state, 0x87, 0x01be);\r\ns5h1409_writereg(state, 0x88, 0x0436);\r\ns5h1409_writereg(state, 0x89, 0x054d);\r\nbreak;\r\n}\r\nstate->if_freq = KHz;\r\nreturn 0;\r\n}\r\nstatic int s5h1409_set_spectralinversion(struct dvb_frontend *fe, int inverted)\r\n{\r\nstruct s5h1409_state *state = fe->demodulator_priv;\r\ndprintk("%s(%d)\n", __func__, inverted);\r\nif (inverted == 1)\r\nreturn s5h1409_writereg(state, 0x1b, 0x1101);\r\nelse\r\nreturn s5h1409_writereg(state, 0x1b, 0x0110);\r\n}\r\nstatic int s5h1409_enable_modulation(struct dvb_frontend *fe,\r\nenum fe_modulation m)\r\n{\r\nstruct s5h1409_state *state = fe->demodulator_priv;\r\ndprintk("%s(0x%08x)\n", __func__, m);\r\nswitch (m) {\r\ncase VSB_8:\r\ndprintk("%s() VSB_8\n", __func__);\r\nif (state->if_freq != S5H1409_VSB_IF_FREQ)\r\ns5h1409_set_if_freq(fe, S5H1409_VSB_IF_FREQ);\r\ns5h1409_writereg(state, 0xf4, 0);\r\nbreak;\r\ncase QAM_64:\r\ncase QAM_256:\r\ncase QAM_AUTO:\r\ndprintk("%s() QAM_AUTO (64/256)\n", __func__);\r\nif (state->if_freq != S5H1409_QAM_IF_FREQ)\r\ns5h1409_set_if_freq(fe, S5H1409_QAM_IF_FREQ);\r\ns5h1409_writereg(state, 0xf4, 1);\r\ns5h1409_writereg(state, 0x85, 0x110);\r\nbreak;\r\ndefault:\r\ndprintk("%s() Invalid modulation\n", __func__);\r\nreturn -EINVAL;\r\n}\r\nstate->current_modulation = m;\r\ns5h1409_softreset(fe);\r\nreturn 0;\r\n}\r\nstatic int s5h1409_i2c_gate_ctrl(struct dvb_frontend *fe, int enable)\r\n{\r\nstruct s5h1409_state *state = fe->demodulator_priv;\r\ndprintk("%s(%d)\n", __func__, enable);\r\nif (enable)\r\nreturn s5h1409_writereg(state, 0xf3, 1);\r\nelse\r\nreturn s5h1409_writereg(state, 0xf3, 0);\r\n}\r\nstatic int s5h1409_set_gpio(struct dvb_frontend *fe, int enable)\r\n{\r\nstruct s5h1409_state *state = fe->demodulator_priv;\r\ndprintk("%s(%d)\n", __func__, enable);\r\nif (enable)\r\nreturn s5h1409_writereg(state, 0xe3,\r\ns5h1409_readreg(state, 0xe3) | 0x1100);\r\nelse\r\nreturn s5h1409_writereg(state, 0xe3,\r\ns5h1409_readreg(state, 0xe3) & 0xfeff);\r\n}\r\nstatic int s5h1409_sleep(struct dvb_frontend *fe, int enable)\r\n{\r\nstruct s5h1409_state *state = fe->demodulator_priv;\r\ndprintk("%s(%d)\n", __func__, enable);\r\nreturn s5h1409_writereg(state, 0xf2, enable);\r\n}\r\nstatic int s5h1409_register_reset(struct dvb_frontend *fe)\r\n{\r\nstruct s5h1409_state *state = fe->demodulator_priv;\r\ndprintk("%s()\n", __func__);\r\nreturn s5h1409_writereg(state, 0xfa, 0);\r\n}\r\nstatic void s5h1409_set_qam_amhum_mode(struct dvb_frontend *fe)\r\n{\r\nstruct s5h1409_state *state = fe->demodulator_priv;\r\nu16 reg;\r\nif (state->qam_state < QAM_STATE_INTERLEAVE_SET) {\r\nreturn;\r\n}\r\nif (state->qam_state == QAM_STATE_QAM_OPTIMIZED_L3) {\r\nreturn;\r\n}\r\nreg = s5h1409_readreg(state, 0xf0);\r\nif ((reg >> 13) & 0x1) {\r\nreg &= 0xff;\r\ns5h1409_writereg(state, 0x96, 0x000c);\r\nif (reg < 0x68) {\r\nif (state->qam_state < QAM_STATE_QAM_OPTIMIZED_L3) {\r\ndprintk("%s() setting QAM state to OPT_L3\n",\r\n__func__);\r\ns5h1409_writereg(state, 0x93, 0x3130);\r\ns5h1409_writereg(state, 0x9e, 0x2836);\r\nstate->qam_state = QAM_STATE_QAM_OPTIMIZED_L3;\r\n}\r\n} else {\r\nif (state->qam_state < QAM_STATE_QAM_OPTIMIZED_L2) {\r\ndprintk("%s() setting QAM state to OPT_L2\n",\r\n__func__);\r\ns5h1409_writereg(state, 0x93, 0x3332);\r\ns5h1409_writereg(state, 0x9e, 0x2c37);\r\nstate->qam_state = QAM_STATE_QAM_OPTIMIZED_L2;\r\n}\r\n}\r\n} else {\r\nif (state->qam_state < QAM_STATE_QAM_OPTIMIZED_L1) {\r\ndprintk("%s() setting QAM state to OPT_L1\n", __func__);\r\ns5h1409_writereg(state, 0x96, 0x0008);\r\ns5h1409_writereg(state, 0x93, 0x3332);\r\ns5h1409_writereg(state, 0x9e, 0x2c37);\r\nstate->qam_state = QAM_STATE_QAM_OPTIMIZED_L1;\r\n}\r\n}\r\n}\r\nstatic void s5h1409_set_qam_amhum_mode_legacy(struct dvb_frontend *fe)\r\n{\r\nstruct s5h1409_state *state = fe->demodulator_priv;\r\nu16 reg;\r\nif (state->is_qam_locked)\r\nreturn;\r\nreg = s5h1409_readreg(state, 0xf0);\r\nif ((reg >> 13) & 0x1) {\r\nstate->is_qam_locked = 1;\r\nreg &= 0xff;\r\ns5h1409_writereg(state, 0x96, 0x00c);\r\nif ((reg < 0x38) || (reg > 0x68)) {\r\ns5h1409_writereg(state, 0x93, 0x3332);\r\ns5h1409_writereg(state, 0x9e, 0x2c37);\r\n} else {\r\ns5h1409_writereg(state, 0x93, 0x3130);\r\ns5h1409_writereg(state, 0x9e, 0x2836);\r\n}\r\n} else {\r\ns5h1409_writereg(state, 0x96, 0x0008);\r\ns5h1409_writereg(state, 0x93, 0x3332);\r\ns5h1409_writereg(state, 0x9e, 0x2c37);\r\n}\r\n}\r\nstatic void s5h1409_set_qam_interleave_mode(struct dvb_frontend *fe)\r\n{\r\nstruct s5h1409_state *state = fe->demodulator_priv;\r\nu16 reg, reg1, reg2;\r\nif (state->qam_state >= QAM_STATE_INTERLEAVE_SET) {\r\nreturn;\r\n}\r\nreg = s5h1409_readreg(state, 0xf1);\r\nif ((reg >> 15) & 0x1) {\r\nif (state->qam_state == QAM_STATE_UNTUNED ||\r\nstate->qam_state == QAM_STATE_TUNING_STARTED) {\r\ndprintk("%s() setting QAM state to INTERLEAVE_SET\n",\r\n__func__);\r\nreg1 = s5h1409_readreg(state, 0xb2);\r\nreg2 = s5h1409_readreg(state, 0xad);\r\ns5h1409_writereg(state, 0x96, 0x0020);\r\ns5h1409_writereg(state, 0xad,\r\n(((reg1 & 0xf000) >> 4) | (reg2 & 0xf0ff)));\r\nstate->qam_state = QAM_STATE_INTERLEAVE_SET;\r\n}\r\n} else {\r\nif (state->qam_state == QAM_STATE_UNTUNED) {\r\ndprintk("%s() setting QAM state to TUNING_STARTED\n",\r\n__func__);\r\ns5h1409_writereg(state, 0x96, 0x08);\r\ns5h1409_writereg(state, 0xab,\r\ns5h1409_readreg(state, 0xab) | 0x1001);\r\nstate->qam_state = QAM_STATE_TUNING_STARTED;\r\n}\r\n}\r\n}\r\nstatic void s5h1409_set_qam_interleave_mode_legacy(struct dvb_frontend *fe)\r\n{\r\nstruct s5h1409_state *state = fe->demodulator_priv;\r\nu16 reg, reg1, reg2;\r\nreg = s5h1409_readreg(state, 0xf1);\r\nif ((reg >> 15) & 0x1) {\r\nif (state->qam_state != 2) {\r\nstate->qam_state = 2;\r\nreg1 = s5h1409_readreg(state, 0xb2);\r\nreg2 = s5h1409_readreg(state, 0xad);\r\ns5h1409_writereg(state, 0x96, 0x20);\r\ns5h1409_writereg(state, 0xad,\r\n(((reg1 & 0xf000) >> 4) | (reg2 & 0xf0ff)));\r\ns5h1409_writereg(state, 0xab,\r\ns5h1409_readreg(state, 0xab) & 0xeffe);\r\n}\r\n} else {\r\nif (state->qam_state != 1) {\r\nstate->qam_state = 1;\r\ns5h1409_writereg(state, 0x96, 0x08);\r\ns5h1409_writereg(state, 0xab,\r\ns5h1409_readreg(state, 0xab) | 0x1001);\r\n}\r\n}\r\n}\r\nstatic int s5h1409_set_frontend(struct dvb_frontend *fe)\r\n{\r\nstruct dtv_frontend_properties *p = &fe->dtv_property_cache;\r\nstruct s5h1409_state *state = fe->demodulator_priv;\r\ndprintk("%s(frequency=%d)\n", __func__, p->frequency);\r\ns5h1409_softreset(fe);\r\nstate->current_frequency = p->frequency;\r\ns5h1409_enable_modulation(fe, p->modulation);\r\nif (fe->ops.tuner_ops.set_params) {\r\nif (fe->ops.i2c_gate_ctrl)\r\nfe->ops.i2c_gate_ctrl(fe, 1);\r\nfe->ops.tuner_ops.set_params(fe);\r\nif (fe->ops.i2c_gate_ctrl)\r\nfe->ops.i2c_gate_ctrl(fe, 0);\r\n}\r\ns5h1409_softreset(fe);\r\nif (state->current_modulation != VSB_8) {\r\nif (state->config->hvr1600_opt == S5H1409_HVR1600_OPTIMIZE) {\r\ns5h1409_set_qam_interleave_mode(fe);\r\ns5h1409_set_qam_amhum_mode(fe);\r\n} else {\r\ns5h1409_set_qam_amhum_mode_legacy(fe);\r\ns5h1409_set_qam_interleave_mode_legacy(fe);\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int s5h1409_set_mpeg_timing(struct dvb_frontend *fe, int mode)\r\n{\r\nstruct s5h1409_state *state = fe->demodulator_priv;\r\nu16 val;\r\ndprintk("%s(%d)\n", __func__, mode);\r\nval = s5h1409_readreg(state, 0xac) & 0xcfff;\r\nswitch (mode) {\r\ncase S5H1409_MPEGTIMING_CONTINOUS_INVERTING_CLOCK:\r\nval |= 0x0000;\r\nbreak;\r\ncase S5H1409_MPEGTIMING_CONTINOUS_NONINVERTING_CLOCK:\r\ndprintk("%s(%d) Mode1 or Defaulting\n", __func__, mode);\r\nval |= 0x1000;\r\nbreak;\r\ncase S5H1409_MPEGTIMING_NONCONTINOUS_INVERTING_CLOCK:\r\nval |= 0x2000;\r\nbreak;\r\ncase S5H1409_MPEGTIMING_NONCONTINOUS_NONINVERTING_CLOCK:\r\nval |= 0x3000;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn s5h1409_writereg(state, 0xac, val);\r\n}\r\nstatic int s5h1409_init(struct dvb_frontend *fe)\r\n{\r\nint i;\r\nstruct s5h1409_state *state = fe->demodulator_priv;\r\ndprintk("%s()\n", __func__);\r\ns5h1409_sleep(fe, 0);\r\ns5h1409_register_reset(fe);\r\nfor (i = 0; i < ARRAY_SIZE(init_tab); i++)\r\ns5h1409_writereg(state, init_tab[i].reg, init_tab[i].data);\r\nstate->current_modulation = VSB_8;\r\nif (state->config->hvr1600_opt == S5H1409_HVR1600_OPTIMIZE) {\r\ns5h1409_writereg(state, 0x09, 0x0050);\r\ns5h1409_writereg(state, 0x21, 0x0001);\r\ns5h1409_writereg(state, 0x50, 0x030e);\r\ns5h1409_writereg(state, 0x82, 0x0800);\r\n}\r\nif (state->config->output_mode == S5H1409_SERIAL_OUTPUT)\r\ns5h1409_writereg(state, 0xab,\r\ns5h1409_readreg(state, 0xab) | 0x100);\r\nelse\r\ns5h1409_writereg(state, 0xab,\r\ns5h1409_readreg(state, 0xab) & 0xfeff);\r\ns5h1409_set_spectralinversion(fe, state->config->inversion);\r\ns5h1409_set_if_freq(fe, state->if_freq);\r\ns5h1409_set_gpio(fe, state->config->gpio);\r\ns5h1409_set_mpeg_timing(fe, state->config->mpeg_timing);\r\ns5h1409_softreset(fe);\r\ns5h1409_i2c_gate_ctrl(fe, 0);\r\nreturn 0;\r\n}\r\nstatic int s5h1409_read_status(struct dvb_frontend *fe, enum fe_status *status)\r\n{\r\nstruct s5h1409_state *state = fe->demodulator_priv;\r\nu16 reg;\r\nu32 tuner_status = 0;\r\n*status = 0;\r\nif (state->current_modulation != VSB_8) {\r\nif (state->config->hvr1600_opt == S5H1409_HVR1600_OPTIMIZE) {\r\ns5h1409_set_qam_interleave_mode(fe);\r\ns5h1409_set_qam_amhum_mode(fe);\r\n}\r\n}\r\nreg = s5h1409_readreg(state, 0xf1);\r\nif (reg & 0x1000)\r\n*status |= FE_HAS_VITERBI;\r\nif (reg & 0x8000)\r\n*status |= FE_HAS_LOCK | FE_HAS_SYNC;\r\nswitch (state->config->status_mode) {\r\ncase S5H1409_DEMODLOCKING:\r\nif (*status & FE_HAS_VITERBI)\r\n*status |= FE_HAS_CARRIER | FE_HAS_SIGNAL;\r\nbreak;\r\ncase S5H1409_TUNERLOCKING:\r\nif (fe->ops.tuner_ops.get_status) {\r\nif (fe->ops.i2c_gate_ctrl)\r\nfe->ops.i2c_gate_ctrl(fe, 1);\r\nfe->ops.tuner_ops.get_status(fe, &tuner_status);\r\nif (fe->ops.i2c_gate_ctrl)\r\nfe->ops.i2c_gate_ctrl(fe, 0);\r\n}\r\nif (tuner_status)\r\n*status |= FE_HAS_CARRIER | FE_HAS_SIGNAL;\r\nbreak;\r\n}\r\ndprintk("%s() status 0x%08x\n", __func__, *status);\r\nreturn 0;\r\n}\r\nstatic int s5h1409_qam256_lookup_snr(struct dvb_frontend *fe, u16 *snr, u16 v)\r\n{\r\nint i, ret = -EINVAL;\r\ndprintk("%s()\n", __func__);\r\nfor (i = 0; i < ARRAY_SIZE(qam256_snr_tab); i++) {\r\nif (v < qam256_snr_tab[i].val) {\r\n*snr = qam256_snr_tab[i].data;\r\nret = 0;\r\nbreak;\r\n}\r\n}\r\nreturn ret;\r\n}\r\nstatic int s5h1409_qam64_lookup_snr(struct dvb_frontend *fe, u16 *snr, u16 v)\r\n{\r\nint i, ret = -EINVAL;\r\ndprintk("%s()\n", __func__);\r\nfor (i = 0; i < ARRAY_SIZE(qam64_snr_tab); i++) {\r\nif (v < qam64_snr_tab[i].val) {\r\n*snr = qam64_snr_tab[i].data;\r\nret = 0;\r\nbreak;\r\n}\r\n}\r\nreturn ret;\r\n}\r\nstatic int s5h1409_vsb_lookup_snr(struct dvb_frontend *fe, u16 *snr, u16 v)\r\n{\r\nint i, ret = -EINVAL;\r\ndprintk("%s()\n", __func__);\r\nfor (i = 0; i < ARRAY_SIZE(vsb_snr_tab); i++) {\r\nif (v > vsb_snr_tab[i].val) {\r\n*snr = vsb_snr_tab[i].data;\r\nret = 0;\r\nbreak;\r\n}\r\n}\r\ndprintk("%s() snr=%d\n", __func__, *snr);\r\nreturn ret;\r\n}\r\nstatic int s5h1409_read_snr(struct dvb_frontend *fe, u16 *snr)\r\n{\r\nstruct s5h1409_state *state = fe->demodulator_priv;\r\nu16 reg;\r\ndprintk("%s()\n", __func__);\r\nswitch (state->current_modulation) {\r\ncase QAM_64:\r\nreg = s5h1409_readreg(state, 0xf0) & 0xff;\r\nreturn s5h1409_qam64_lookup_snr(fe, snr, reg);\r\ncase QAM_256:\r\nreg = s5h1409_readreg(state, 0xf0) & 0xff;\r\nreturn s5h1409_qam256_lookup_snr(fe, snr, reg);\r\ncase VSB_8:\r\nreg = s5h1409_readreg(state, 0xf1) & 0x3ff;\r\nreturn s5h1409_vsb_lookup_snr(fe, snr, reg);\r\ndefault:\r\nbreak;\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int s5h1409_read_signal_strength(struct dvb_frontend *fe,\r\nu16 *signal_strength)\r\n{\r\nu16 snr;\r\nu32 tmp;\r\nint ret = s5h1409_read_snr(fe, &snr);\r\n*signal_strength = 0;\r\nif (0 == ret) {\r\ntmp = (snr * ((1 << 24) / 10));\r\nif (tmp >= 8960 * 0x10000)\r\n*signal_strength = 0xffff;\r\nelse\r\n*signal_strength = tmp / 8960;\r\n}\r\nreturn ret;\r\n}\r\nstatic int s5h1409_read_ucblocks(struct dvb_frontend *fe, u32 *ucblocks)\r\n{\r\nstruct s5h1409_state *state = fe->demodulator_priv;\r\n*ucblocks = s5h1409_readreg(state, 0xb5);\r\nreturn 0;\r\n}\r\nstatic int s5h1409_read_ber(struct dvb_frontend *fe, u32 *ber)\r\n{\r\nreturn s5h1409_read_ucblocks(fe, ber);\r\n}\r\nstatic int s5h1409_get_frontend(struct dvb_frontend *fe,\r\nstruct dtv_frontend_properties *p)\r\n{\r\nstruct s5h1409_state *state = fe->demodulator_priv;\r\np->frequency = state->current_frequency;\r\np->modulation = state->current_modulation;\r\nreturn 0;\r\n}\r\nstatic int s5h1409_get_tune_settings(struct dvb_frontend *fe,\r\nstruct dvb_frontend_tune_settings *tune)\r\n{\r\ntune->min_delay_ms = 1000;\r\nreturn 0;\r\n}\r\nstatic void s5h1409_release(struct dvb_frontend *fe)\r\n{\r\nstruct s5h1409_state *state = fe->demodulator_priv;\r\nkfree(state);\r\n}\r\nstruct dvb_frontend *s5h1409_attach(const struct s5h1409_config *config,\r\nstruct i2c_adapter *i2c)\r\n{\r\nstruct s5h1409_state *state = NULL;\r\nu16 reg;\r\nstate = kzalloc(sizeof(struct s5h1409_state), GFP_KERNEL);\r\nif (state == NULL)\r\ngoto error;\r\nstate->config = config;\r\nstate->i2c = i2c;\r\nstate->current_modulation = 0;\r\nstate->if_freq = S5H1409_VSB_IF_FREQ;\r\nreg = s5h1409_readreg(state, 0x04);\r\nif ((reg != 0x0066) && (reg != 0x007f))\r\ngoto error;\r\nmemcpy(&state->frontend.ops, &s5h1409_ops,\r\nsizeof(struct dvb_frontend_ops));\r\nstate->frontend.demodulator_priv = state;\r\nif (s5h1409_init(&state->frontend) != 0) {\r\nprintk(KERN_ERR "%s: Failed to initialize correctly\n",\r\n__func__);\r\ngoto error;\r\n}\r\ns5h1409_i2c_gate_ctrl(&state->frontend, 1);\r\nreturn &state->frontend;\r\nerror:\r\nkfree(state);\r\nreturn NULL;\r\n}
