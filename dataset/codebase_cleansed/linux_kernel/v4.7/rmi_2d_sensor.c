void rmi_2d_sensor_abs_process(struct rmi_2d_sensor *sensor,\r\nstruct rmi_2d_sensor_abs_object *obj,\r\nint slot)\r\n{\r\nstruct rmi_2d_axis_alignment *axis_align = &sensor->axis_align;\r\nif (obj->type == RMI_2D_OBJECT_NONE)\r\nreturn;\r\nif (axis_align->swap_axes)\r\nswap(obj->x, obj->y);\r\nif (axis_align->flip_x)\r\nobj->x = sensor->max_x - obj->x;\r\nif (axis_align->flip_y)\r\nobj->y = sensor->max_y - obj->y;\r\nobj->x += axis_align->offset_x;\r\nobj->y += axis_align->offset_y;\r\nobj->x = max(axis_align->clip_x_low, obj->x);\r\nobj->y = max(axis_align->clip_y_low, obj->y);\r\nif (axis_align->clip_x_high)\r\nobj->x = min(sensor->max_x, obj->x);\r\nif (axis_align->clip_y_high)\r\nobj->y = min(sensor->max_y, obj->y);\r\nsensor->tracking_pos[slot].x = obj->x;\r\nsensor->tracking_pos[slot].y = obj->y;\r\n}\r\nvoid rmi_2d_sensor_abs_report(struct rmi_2d_sensor *sensor,\r\nstruct rmi_2d_sensor_abs_object *obj,\r\nint slot)\r\n{\r\nstruct rmi_2d_axis_alignment *axis_align = &sensor->axis_align;\r\nstruct input_dev *input = sensor->input;\r\nint wide, major, minor;\r\nif (sensor->kernel_tracking)\r\ninput_mt_slot(input, sensor->tracking_slots[slot]);\r\nelse\r\ninput_mt_slot(input, slot);\r\ninput_mt_report_slot_state(input, obj->mt_tool,\r\nobj->type != RMI_2D_OBJECT_NONE);\r\nif (obj->type != RMI_2D_OBJECT_NONE) {\r\nobj->x = sensor->tracking_pos[slot].x;\r\nobj->y = sensor->tracking_pos[slot].y;\r\nif (axis_align->swap_axes)\r\nswap(obj->wx, obj->wy);\r\nwide = (obj->wx > obj->wy);\r\nmajor = max(obj->wx, obj->wy);\r\nminor = min(obj->wx, obj->wy);\r\nif (obj->type == RMI_2D_OBJECT_STYLUS) {\r\nmajor = max(1, major);\r\nminor = max(1, minor);\r\n}\r\ninput_event(sensor->input, EV_ABS, ABS_MT_POSITION_X, obj->x);\r\ninput_event(sensor->input, EV_ABS, ABS_MT_POSITION_Y, obj->y);\r\ninput_event(sensor->input, EV_ABS, ABS_MT_ORIENTATION, wide);\r\ninput_event(sensor->input, EV_ABS, ABS_MT_PRESSURE, obj->z);\r\ninput_event(sensor->input, EV_ABS, ABS_MT_TOUCH_MAJOR, major);\r\ninput_event(sensor->input, EV_ABS, ABS_MT_TOUCH_MINOR, minor);\r\nrmi_dbg(RMI_DEBUG_2D_SENSOR, &sensor->input->dev,\r\n"%s: obj[%d]: type: 0x%02x X: %d Y: %d Z: %d WX: %d WY: %d\n",\r\n__func__, slot, obj->type, obj->x, obj->y, obj->z,\r\nobj->wx, obj->wy);\r\n}\r\n}\r\nvoid rmi_2d_sensor_rel_report(struct rmi_2d_sensor *sensor, int x, int y)\r\n{\r\nstruct rmi_2d_axis_alignment *axis_align = &sensor->axis_align;\r\nx = min(RMI_2D_REL_POS_MAX, max(RMI_2D_REL_POS_MIN, (int)x));\r\ny = min(RMI_2D_REL_POS_MAX, max(RMI_2D_REL_POS_MIN, (int)y));\r\nif (axis_align->swap_axes)\r\nswap(x, y);\r\nif (axis_align->flip_x)\r\nx = min(RMI_2D_REL_POS_MAX, -x);\r\nif (axis_align->flip_y)\r\ny = min(RMI_2D_REL_POS_MAX, -y);\r\nif (x || y) {\r\ninput_report_rel(sensor->input, REL_X, x);\r\ninput_report_rel(sensor->input, REL_Y, y);\r\n}\r\n}\r\nstatic void rmi_2d_sensor_set_input_params(struct rmi_2d_sensor *sensor)\r\n{\r\nstruct input_dev *input = sensor->input;\r\nint res_x;\r\nint res_y;\r\nint input_flags = 0;\r\nif (sensor->report_abs) {\r\nif (sensor->axis_align.swap_axes)\r\nswap(sensor->max_x, sensor->max_y);\r\nsensor->min_x = sensor->axis_align.clip_x_low;\r\nif (sensor->axis_align.clip_x_high)\r\nsensor->max_x = min(sensor->max_x,\r\nsensor->axis_align.clip_x_high);\r\nsensor->min_y = sensor->axis_align.clip_y_low;\r\nif (sensor->axis_align.clip_y_high)\r\nsensor->max_y = min(sensor->max_y,\r\nsensor->axis_align.clip_y_high);\r\nset_bit(EV_ABS, input->evbit);\r\ninput_set_abs_params(input, ABS_MT_POSITION_X, 0, sensor->max_x,\r\n0, 0);\r\ninput_set_abs_params(input, ABS_MT_POSITION_Y, 0, sensor->max_y,\r\n0, 0);\r\nif (sensor->x_mm && sensor->y_mm) {\r\nres_x = (sensor->max_x - sensor->min_x) / sensor->x_mm;\r\nres_y = (sensor->max_y - sensor->min_y) / sensor->y_mm;\r\ninput_abs_set_res(input, ABS_X, res_x);\r\ninput_abs_set_res(input, ABS_Y, res_y);\r\ninput_abs_set_res(input, ABS_MT_POSITION_X, res_x);\r\ninput_abs_set_res(input, ABS_MT_POSITION_Y, res_y);\r\nif (!sensor->dmax)\r\nsensor->dmax = DMAX * res_x;\r\n}\r\ninput_set_abs_params(input, ABS_MT_PRESSURE, 0, 0xff, 0, 0);\r\ninput_set_abs_params(input, ABS_MT_TOUCH_MAJOR, 0, 0x0f, 0, 0);\r\ninput_set_abs_params(input, ABS_MT_TOUCH_MINOR, 0, 0x0f, 0, 0);\r\ninput_set_abs_params(input, ABS_MT_ORIENTATION, 0, 1, 0, 0);\r\nif (sensor->sensor_type == rmi_sensor_touchpad)\r\ninput_flags = INPUT_MT_POINTER;\r\nelse\r\ninput_flags = INPUT_MT_DIRECT;\r\nif (sensor->kernel_tracking)\r\ninput_flags |= INPUT_MT_TRACK;\r\ninput_mt_init_slots(input, sensor->nbr_fingers, input_flags);\r\n}\r\nif (sensor->report_rel) {\r\nset_bit(EV_REL, input->evbit);\r\nset_bit(REL_X, input->relbit);\r\nset_bit(REL_Y, input->relbit);\r\n}\r\nif (sensor->topbuttonpad)\r\nset_bit(INPUT_PROP_TOPBUTTONPAD, input->propbit);\r\n}\r\nint rmi_2d_sensor_configure_input(struct rmi_function *fn,\r\nstruct rmi_2d_sensor *sensor)\r\n{\r\nstruct rmi_device *rmi_dev = fn->rmi_dev;\r\nstruct rmi_driver_data *drv_data = dev_get_drvdata(&rmi_dev->dev);\r\nif (!drv_data->input)\r\nreturn -ENODEV;\r\nsensor->input = drv_data->input;\r\nrmi_2d_sensor_set_input_params(sensor);\r\nreturn 0;\r\n}\r\nint rmi_2d_sensor_of_probe(struct device *dev,\r\nstruct rmi_2d_sensor_platform_data *pdata)\r\n{\r\nint retval;\r\nu32 val;\r\npdata->axis_align.swap_axes = of_property_read_bool(dev->of_node,\r\n"touchscreen-swapped-x-y");\r\npdata->axis_align.flip_x = of_property_read_bool(dev->of_node,\r\n"touchscreen-inverted-x");\r\npdata->axis_align.flip_y = of_property_read_bool(dev->of_node,\r\n"touchscreen-inverted-y");\r\nretval = rmi_of_property_read_u32(dev, &val, "syna,clip-x-low", 1);\r\nif (retval)\r\nreturn retval;\r\npdata->axis_align.clip_x_low = val;\r\nretval = rmi_of_property_read_u32(dev, &val, "syna,clip-y-low", 1);\r\nif (retval)\r\nreturn retval;\r\npdata->axis_align.clip_y_low = val;\r\nretval = rmi_of_property_read_u32(dev, &val, "syna,clip-x-high", 1);\r\nif (retval)\r\nreturn retval;\r\npdata->axis_align.clip_x_high = val;\r\nretval = rmi_of_property_read_u32(dev, &val, "syna,clip-y-high", 1);\r\nif (retval)\r\nreturn retval;\r\npdata->axis_align.clip_y_high = val;\r\nretval = rmi_of_property_read_u32(dev, &val, "syna,offset-x", 1);\r\nif (retval)\r\nreturn retval;\r\npdata->axis_align.offset_x = val;\r\nretval = rmi_of_property_read_u32(dev, &val, "syna,offset-y", 1);\r\nif (retval)\r\nreturn retval;\r\npdata->axis_align.offset_y = val;\r\nretval = rmi_of_property_read_u32(dev, &val, "syna,delta-x-threshold",\r\n1);\r\nif (retval)\r\nreturn retval;\r\npdata->axis_align.delta_x_threshold = val;\r\nretval = rmi_of_property_read_u32(dev, &val, "syna,delta-y-threshold",\r\n1);\r\nif (retval)\r\nreturn retval;\r\npdata->axis_align.delta_y_threshold = val;\r\nretval = rmi_of_property_read_u32(dev, (u32 *)&pdata->sensor_type,\r\n"syna,sensor-type", 1);\r\nif (retval)\r\nreturn retval;\r\nretval = rmi_of_property_read_u32(dev, &val, "touchscreen-x-mm", 1);\r\nif (retval)\r\nreturn retval;\r\npdata->x_mm = val;\r\nretval = rmi_of_property_read_u32(dev, &val, "touchscreen-y-mm", 1);\r\nif (retval)\r\nreturn retval;\r\npdata->y_mm = val;\r\nretval = rmi_of_property_read_u32(dev, &val,\r\n"syna,disable-report-mask", 1);\r\nif (retval)\r\nreturn retval;\r\npdata->disable_report_mask = val;\r\nretval = rmi_of_property_read_u32(dev, &val, "syna,rezero-wait-ms",\r\n1);\r\nif (retval)\r\nreturn retval;\r\npdata->rezero_wait = val;\r\nreturn 0;\r\n}\r\ninline int rmi_2d_sensor_of_probe(struct device *dev,\r\nstruct rmi_2d_sensor_platform_data *pdata)\r\n{\r\nreturn -ENODEV;\r\n}
