static const char *fcoe_ctlr_state(enum fip_state state)\r\n{\r\nconst char *cp = "unknown";\r\nif (state < ARRAY_SIZE(fcoe_ctlr_states))\r\ncp = fcoe_ctlr_states[state];\r\nif (!cp)\r\ncp = "unknown";\r\nreturn cp;\r\n}\r\nstatic void fcoe_ctlr_set_state(struct fcoe_ctlr *fip, enum fip_state state)\r\n{\r\nif (state == fip->state)\r\nreturn;\r\nif (fip->lp)\r\nLIBFCOE_FIP_DBG(fip, "state %s -> %s\n",\r\nfcoe_ctlr_state(fip->state), fcoe_ctlr_state(state));\r\nfip->state = state;\r\n}\r\nstatic inline int fcoe_ctlr_mtu_valid(const struct fcoe_fcf *fcf)\r\n{\r\nreturn (fcf->flags & FIP_FL_SOL) != 0;\r\n}\r\nstatic inline int fcoe_ctlr_fcf_usable(struct fcoe_fcf *fcf)\r\n{\r\nu16 flags = FIP_FL_SOL | FIP_FL_AVAIL;\r\nreturn (fcf->flags & flags) == flags;\r\n}\r\nstatic void fcoe_ctlr_map_dest(struct fcoe_ctlr *fip)\r\n{\r\nif (fip->mode == FIP_MODE_VN2VN)\r\nhton24(fip->dest_addr, FIP_VN_FC_MAP);\r\nelse\r\nhton24(fip->dest_addr, FIP_DEF_FC_MAP);\r\nhton24(fip->dest_addr + 3, 0);\r\nfip->map_dest = 1;\r\n}\r\nvoid fcoe_ctlr_init(struct fcoe_ctlr *fip, enum fip_state mode)\r\n{\r\nfcoe_ctlr_set_state(fip, FIP_ST_LINK_WAIT);\r\nfip->mode = mode;\r\nINIT_LIST_HEAD(&fip->fcfs);\r\nmutex_init(&fip->ctlr_mutex);\r\nspin_lock_init(&fip->ctlr_lock);\r\nfip->flogi_oxid = FC_XID_UNKNOWN;\r\nsetup_timer(&fip->timer, fcoe_ctlr_timeout, (unsigned long)fip);\r\nINIT_WORK(&fip->timer_work, fcoe_ctlr_timer_work);\r\nINIT_WORK(&fip->recv_work, fcoe_ctlr_recv_work);\r\nskb_queue_head_init(&fip->fip_recv_list);\r\n}\r\nstatic int fcoe_sysfs_fcf_add(struct fcoe_fcf *new)\r\n{\r\nstruct fcoe_ctlr *fip = new->fip;\r\nstruct fcoe_ctlr_device *ctlr_dev;\r\nstruct fcoe_fcf_device *temp, *fcf_dev;\r\nint rc = -ENOMEM;\r\nLIBFCOE_FIP_DBG(fip, "New FCF fab %16.16llx mac %pM\n",\r\nnew->fabric_name, new->fcf_mac);\r\ntemp = kzalloc(sizeof(*temp), GFP_KERNEL);\r\nif (!temp)\r\ngoto out;\r\ntemp->fabric_name = new->fabric_name;\r\ntemp->switch_name = new->switch_name;\r\ntemp->fc_map = new->fc_map;\r\ntemp->vfid = new->vfid;\r\nmemcpy(temp->mac, new->fcf_mac, ETH_ALEN);\r\ntemp->priority = new->pri;\r\ntemp->fka_period = new->fka_period;\r\ntemp->selected = 0;\r\nctlr_dev = fcoe_ctlr_to_ctlr_dev(fip);\r\nif (ctlr_dev) {\r\nmutex_lock(&ctlr_dev->lock);\r\nfcf_dev = fcoe_fcf_device_add(ctlr_dev, temp);\r\nif (unlikely(!fcf_dev)) {\r\nrc = -ENOMEM;\r\nmutex_unlock(&ctlr_dev->lock);\r\ngoto out;\r\n}\r\nBUG_ON(fcf_dev->priv);\r\nfcf_dev->priv = new;\r\nnew->fcf_dev = fcf_dev;\r\nmutex_unlock(&ctlr_dev->lock);\r\n}\r\nlist_add(&new->list, &fip->fcfs);\r\nfip->fcf_count++;\r\nrc = 0;\r\nout:\r\nkfree(temp);\r\nreturn rc;\r\n}\r\nstatic void fcoe_sysfs_fcf_del(struct fcoe_fcf *new)\r\n{\r\nstruct fcoe_ctlr *fip = new->fip;\r\nstruct fcoe_ctlr_device *cdev;\r\nstruct fcoe_fcf_device *fcf_dev;\r\nlist_del(&new->list);\r\nfip->fcf_count--;\r\ncdev = fcoe_ctlr_to_ctlr_dev(fip);\r\nif (cdev) {\r\nmutex_lock(&cdev->lock);\r\nfcf_dev = fcoe_fcf_to_fcf_dev(new);\r\nWARN_ON(!fcf_dev);\r\nnew->fcf_dev = NULL;\r\nfcoe_fcf_device_delete(fcf_dev);\r\nkfree(new);\r\nmutex_unlock(&cdev->lock);\r\n}\r\n}\r\nstatic void fcoe_ctlr_reset_fcfs(struct fcoe_ctlr *fip)\r\n{\r\nstruct fcoe_fcf *fcf;\r\nstruct fcoe_fcf *next;\r\nfip->sel_fcf = NULL;\r\nlist_for_each_entry_safe(fcf, next, &fip->fcfs, list) {\r\nfcoe_sysfs_fcf_del(fcf);\r\n}\r\nWARN_ON(fip->fcf_count);\r\nfip->sel_time = 0;\r\n}\r\nvoid fcoe_ctlr_destroy(struct fcoe_ctlr *fip)\r\n{\r\ncancel_work_sync(&fip->recv_work);\r\nskb_queue_purge(&fip->fip_recv_list);\r\nmutex_lock(&fip->ctlr_mutex);\r\nfcoe_ctlr_set_state(fip, FIP_ST_DISABLED);\r\nfcoe_ctlr_reset_fcfs(fip);\r\nmutex_unlock(&fip->ctlr_mutex);\r\ndel_timer_sync(&fip->timer);\r\ncancel_work_sync(&fip->timer_work);\r\n}\r\nstatic void fcoe_ctlr_announce(struct fcoe_ctlr *fip)\r\n{\r\nstruct fcoe_fcf *sel;\r\nstruct fcoe_fcf *fcf;\r\nmutex_lock(&fip->ctlr_mutex);\r\nspin_lock_bh(&fip->ctlr_lock);\r\nkfree_skb(fip->flogi_req);\r\nfip->flogi_req = NULL;\r\nlist_for_each_entry(fcf, &fip->fcfs, list)\r\nfcf->flogi_sent = 0;\r\nspin_unlock_bh(&fip->ctlr_lock);\r\nsel = fip->sel_fcf;\r\nif (sel && ether_addr_equal(sel->fcf_mac, fip->dest_addr))\r\ngoto unlock;\r\nif (!is_zero_ether_addr(fip->dest_addr)) {\r\nprintk(KERN_NOTICE "libfcoe: host%d: "\r\n"FIP Fibre-Channel Forwarder MAC %pM deselected\n",\r\nfip->lp->host->host_no, fip->dest_addr);\r\nmemset(fip->dest_addr, 0, ETH_ALEN);\r\n}\r\nif (sel) {\r\nprintk(KERN_INFO "libfcoe: host%d: FIP selected "\r\n"Fibre-Channel Forwarder MAC %pM\n",\r\nfip->lp->host->host_no, sel->fcf_mac);\r\nmemcpy(fip->dest_addr, sel->fcoe_mac, ETH_ALEN);\r\nfip->map_dest = 0;\r\n}\r\nunlock:\r\nmutex_unlock(&fip->ctlr_mutex);\r\n}\r\nstatic inline u32 fcoe_ctlr_fcoe_size(struct fcoe_ctlr *fip)\r\n{\r\nreturn fip->lp->mfs + sizeof(struct fc_frame_header) +\r\nsizeof(struct fcoe_hdr) + sizeof(struct fcoe_crc_eof);\r\n}\r\nstatic void fcoe_ctlr_solicit(struct fcoe_ctlr *fip, struct fcoe_fcf *fcf)\r\n{\r\nstruct sk_buff *skb;\r\nstruct fip_sol {\r\nstruct ethhdr eth;\r\nstruct fip_header fip;\r\nstruct {\r\nstruct fip_mac_desc mac;\r\nstruct fip_wwn_desc wwnn;\r\nstruct fip_size_desc size;\r\n} __packed desc;\r\n} __packed * sol;\r\nu32 fcoe_size;\r\nskb = dev_alloc_skb(sizeof(*sol));\r\nif (!skb)\r\nreturn;\r\nsol = (struct fip_sol *)skb->data;\r\nmemset(sol, 0, sizeof(*sol));\r\nmemcpy(sol->eth.h_dest, fcf ? fcf->fcf_mac : fcoe_all_fcfs, ETH_ALEN);\r\nmemcpy(sol->eth.h_source, fip->ctl_src_addr, ETH_ALEN);\r\nsol->eth.h_proto = htons(ETH_P_FIP);\r\nsol->fip.fip_ver = FIP_VER_ENCAPS(FIP_VER);\r\nsol->fip.fip_op = htons(FIP_OP_DISC);\r\nsol->fip.fip_subcode = FIP_SC_SOL;\r\nsol->fip.fip_dl_len = htons(sizeof(sol->desc) / FIP_BPW);\r\nsol->fip.fip_flags = htons(FIP_FL_FPMA);\r\nif (fip->spma)\r\nsol->fip.fip_flags |= htons(FIP_FL_SPMA);\r\nsol->desc.mac.fd_desc.fip_dtype = FIP_DT_MAC;\r\nsol->desc.mac.fd_desc.fip_dlen = sizeof(sol->desc.mac) / FIP_BPW;\r\nmemcpy(sol->desc.mac.fd_mac, fip->ctl_src_addr, ETH_ALEN);\r\nsol->desc.wwnn.fd_desc.fip_dtype = FIP_DT_NAME;\r\nsol->desc.wwnn.fd_desc.fip_dlen = sizeof(sol->desc.wwnn) / FIP_BPW;\r\nput_unaligned_be64(fip->lp->wwnn, &sol->desc.wwnn.fd_wwn);\r\nfcoe_size = fcoe_ctlr_fcoe_size(fip);\r\nsol->desc.size.fd_desc.fip_dtype = FIP_DT_FCOE_SIZE;\r\nsol->desc.size.fd_desc.fip_dlen = sizeof(sol->desc.size) / FIP_BPW;\r\nsol->desc.size.fd_size = htons(fcoe_size);\r\nskb_put(skb, sizeof(*sol));\r\nskb->protocol = htons(ETH_P_FIP);\r\nskb->priority = fip->priority;\r\nskb_reset_mac_header(skb);\r\nskb_reset_network_header(skb);\r\nfip->send(fip, skb);\r\nif (!fcf)\r\nfip->sol_time = jiffies;\r\n}\r\nvoid fcoe_ctlr_link_up(struct fcoe_ctlr *fip)\r\n{\r\nmutex_lock(&fip->ctlr_mutex);\r\nif (fip->state == FIP_ST_NON_FIP || fip->state == FIP_ST_AUTO) {\r\nmutex_unlock(&fip->ctlr_mutex);\r\nfc_linkup(fip->lp);\r\n} else if (fip->state == FIP_ST_LINK_WAIT) {\r\nfcoe_ctlr_set_state(fip, fip->mode);\r\nswitch (fip->mode) {\r\ndefault:\r\nLIBFCOE_FIP_DBG(fip, "invalid mode %d\n", fip->mode);\r\ncase FIP_MODE_AUTO:\r\nLIBFCOE_FIP_DBG(fip, "%s", "setting AUTO mode.\n");\r\ncase FIP_MODE_FABRIC:\r\ncase FIP_MODE_NON_FIP:\r\nmutex_unlock(&fip->ctlr_mutex);\r\nfc_linkup(fip->lp);\r\nfcoe_ctlr_solicit(fip, NULL);\r\nbreak;\r\ncase FIP_MODE_VN2VN:\r\nfcoe_ctlr_vn_start(fip);\r\nmutex_unlock(&fip->ctlr_mutex);\r\nfc_linkup(fip->lp);\r\nbreak;\r\n}\r\n} else\r\nmutex_unlock(&fip->ctlr_mutex);\r\n}\r\nstatic void fcoe_ctlr_reset(struct fcoe_ctlr *fip)\r\n{\r\nfcoe_ctlr_reset_fcfs(fip);\r\ndel_timer(&fip->timer);\r\nfip->ctlr_ka_time = 0;\r\nfip->port_ka_time = 0;\r\nfip->sol_time = 0;\r\nfip->flogi_oxid = FC_XID_UNKNOWN;\r\nfcoe_ctlr_map_dest(fip);\r\n}\r\nint fcoe_ctlr_link_down(struct fcoe_ctlr *fip)\r\n{\r\nint link_dropped;\r\nLIBFCOE_FIP_DBG(fip, "link down.\n");\r\nmutex_lock(&fip->ctlr_mutex);\r\nfcoe_ctlr_reset(fip);\r\nlink_dropped = fip->state != FIP_ST_LINK_WAIT;\r\nfcoe_ctlr_set_state(fip, FIP_ST_LINK_WAIT);\r\nmutex_unlock(&fip->ctlr_mutex);\r\nif (link_dropped)\r\nfc_linkdown(fip->lp);\r\nreturn link_dropped;\r\n}\r\nstatic void fcoe_ctlr_send_keep_alive(struct fcoe_ctlr *fip,\r\nstruct fc_lport *lport,\r\nint ports, u8 *sa)\r\n{\r\nstruct sk_buff *skb;\r\nstruct fip_kal {\r\nstruct ethhdr eth;\r\nstruct fip_header fip;\r\nstruct fip_mac_desc mac;\r\n} __packed * kal;\r\nstruct fip_vn_desc *vn;\r\nu32 len;\r\nstruct fc_lport *lp;\r\nstruct fcoe_fcf *fcf;\r\nfcf = fip->sel_fcf;\r\nlp = fip->lp;\r\nif (!fcf || (ports && !lp->port_id))\r\nreturn;\r\nlen = sizeof(*kal) + ports * sizeof(*vn);\r\nskb = dev_alloc_skb(len);\r\nif (!skb)\r\nreturn;\r\nkal = (struct fip_kal *)skb->data;\r\nmemset(kal, 0, len);\r\nmemcpy(kal->eth.h_dest, fcf->fcf_mac, ETH_ALEN);\r\nmemcpy(kal->eth.h_source, sa, ETH_ALEN);\r\nkal->eth.h_proto = htons(ETH_P_FIP);\r\nkal->fip.fip_ver = FIP_VER_ENCAPS(FIP_VER);\r\nkal->fip.fip_op = htons(FIP_OP_CTRL);\r\nkal->fip.fip_subcode = FIP_SC_KEEP_ALIVE;\r\nkal->fip.fip_dl_len = htons((sizeof(kal->mac) +\r\nports * sizeof(*vn)) / FIP_BPW);\r\nkal->fip.fip_flags = htons(FIP_FL_FPMA);\r\nif (fip->spma)\r\nkal->fip.fip_flags |= htons(FIP_FL_SPMA);\r\nkal->mac.fd_desc.fip_dtype = FIP_DT_MAC;\r\nkal->mac.fd_desc.fip_dlen = sizeof(kal->mac) / FIP_BPW;\r\nmemcpy(kal->mac.fd_mac, fip->ctl_src_addr, ETH_ALEN);\r\nif (ports) {\r\nvn = (struct fip_vn_desc *)(kal + 1);\r\nvn->fd_desc.fip_dtype = FIP_DT_VN_ID;\r\nvn->fd_desc.fip_dlen = sizeof(*vn) / FIP_BPW;\r\nmemcpy(vn->fd_mac, fip->get_src_addr(lport), ETH_ALEN);\r\nhton24(vn->fd_fc_id, lport->port_id);\r\nput_unaligned_be64(lport->wwpn, &vn->fd_wwpn);\r\n}\r\nskb_put(skb, len);\r\nskb->protocol = htons(ETH_P_FIP);\r\nskb->priority = fip->priority;\r\nskb_reset_mac_header(skb);\r\nskb_reset_network_header(skb);\r\nfip->send(fip, skb);\r\n}\r\nstatic int fcoe_ctlr_encaps(struct fcoe_ctlr *fip, struct fc_lport *lport,\r\nu8 dtype, struct sk_buff *skb, u32 d_id)\r\n{\r\nstruct fip_encaps_head {\r\nstruct ethhdr eth;\r\nstruct fip_header fip;\r\nstruct fip_encaps encaps;\r\n} __packed * cap;\r\nstruct fc_frame_header *fh;\r\nstruct fip_mac_desc *mac;\r\nstruct fcoe_fcf *fcf;\r\nsize_t dlen;\r\nu16 fip_flags;\r\nu8 op;\r\nfh = (struct fc_frame_header *)skb->data;\r\nop = *(u8 *)(fh + 1);\r\ndlen = sizeof(struct fip_encaps) + skb->len;\r\ncap = (struct fip_encaps_head *)skb_push(skb, sizeof(*cap));\r\nmemset(cap, 0, sizeof(*cap));\r\nif (lport->point_to_multipoint) {\r\nif (fcoe_ctlr_vn_lookup(fip, d_id, cap->eth.h_dest))\r\nreturn -ENODEV;\r\nfip_flags = 0;\r\n} else {\r\nfcf = fip->sel_fcf;\r\nif (!fcf)\r\nreturn -ENODEV;\r\nfip_flags = fcf->flags;\r\nfip_flags &= fip->spma ? FIP_FL_SPMA | FIP_FL_FPMA :\r\nFIP_FL_FPMA;\r\nif (!fip_flags)\r\nreturn -ENODEV;\r\nmemcpy(cap->eth.h_dest, fcf->fcf_mac, ETH_ALEN);\r\n}\r\nmemcpy(cap->eth.h_source, fip->ctl_src_addr, ETH_ALEN);\r\ncap->eth.h_proto = htons(ETH_P_FIP);\r\ncap->fip.fip_ver = FIP_VER_ENCAPS(FIP_VER);\r\ncap->fip.fip_op = htons(FIP_OP_LS);\r\nif (op == ELS_LS_ACC || op == ELS_LS_RJT)\r\ncap->fip.fip_subcode = FIP_SC_REP;\r\nelse\r\ncap->fip.fip_subcode = FIP_SC_REQ;\r\ncap->fip.fip_flags = htons(fip_flags);\r\ncap->encaps.fd_desc.fip_dtype = dtype;\r\ncap->encaps.fd_desc.fip_dlen = dlen / FIP_BPW;\r\nif (op != ELS_LS_RJT) {\r\ndlen += sizeof(*mac);\r\nmac = (struct fip_mac_desc *)skb_put(skb, sizeof(*mac));\r\nmemset(mac, 0, sizeof(*mac));\r\nmac->fd_desc.fip_dtype = FIP_DT_MAC;\r\nmac->fd_desc.fip_dlen = sizeof(*mac) / FIP_BPW;\r\nif (dtype != FIP_DT_FLOGI && dtype != FIP_DT_FDISC) {\r\nmemcpy(mac->fd_mac, fip->get_src_addr(lport), ETH_ALEN);\r\n} else if (fip->mode == FIP_MODE_VN2VN) {\r\nhton24(mac->fd_mac, FIP_VN_FC_MAP);\r\nhton24(mac->fd_mac + 3, fip->port_id);\r\n} else if (fip_flags & FIP_FL_SPMA) {\r\nLIBFCOE_FIP_DBG(fip, "FLOGI/FDISC sent with SPMA\n");\r\nmemcpy(mac->fd_mac, fip->ctl_src_addr, ETH_ALEN);\r\n} else {\r\nLIBFCOE_FIP_DBG(fip, "FLOGI/FDISC sent with FPMA\n");\r\n}\r\n}\r\ncap->fip.fip_dl_len = htons(dlen / FIP_BPW);\r\nskb->protocol = htons(ETH_P_FIP);\r\nskb->priority = fip->priority;\r\nskb_reset_mac_header(skb);\r\nskb_reset_network_header(skb);\r\nreturn 0;\r\n}\r\nint fcoe_ctlr_els_send(struct fcoe_ctlr *fip, struct fc_lport *lport,\r\nstruct sk_buff *skb)\r\n{\r\nstruct fc_frame *fp;\r\nstruct fc_frame_header *fh;\r\nu16 old_xid;\r\nu8 op;\r\nu8 mac[ETH_ALEN];\r\nfp = container_of(skb, struct fc_frame, skb);\r\nfh = (struct fc_frame_header *)skb->data;\r\nop = *(u8 *)(fh + 1);\r\nif (op == ELS_FLOGI && fip->mode != FIP_MODE_VN2VN) {\r\nold_xid = fip->flogi_oxid;\r\nfip->flogi_oxid = ntohs(fh->fh_ox_id);\r\nif (fip->state == FIP_ST_AUTO) {\r\nif (old_xid == FC_XID_UNKNOWN)\r\nfip->flogi_count = 0;\r\nfip->flogi_count++;\r\nif (fip->flogi_count < 3)\r\ngoto drop;\r\nfcoe_ctlr_map_dest(fip);\r\nreturn 0;\r\n}\r\nif (fip->state == FIP_ST_NON_FIP)\r\nfcoe_ctlr_map_dest(fip);\r\n}\r\nif (fip->state == FIP_ST_NON_FIP)\r\nreturn 0;\r\nif (!fip->sel_fcf && fip->mode != FIP_MODE_VN2VN)\r\ngoto drop;\r\nswitch (op) {\r\ncase ELS_FLOGI:\r\nop = FIP_DT_FLOGI;\r\nif (fip->mode == FIP_MODE_VN2VN)\r\nbreak;\r\nspin_lock_bh(&fip->ctlr_lock);\r\nkfree_skb(fip->flogi_req);\r\nfip->flogi_req = skb;\r\nfip->flogi_req_send = 1;\r\nspin_unlock_bh(&fip->ctlr_lock);\r\nschedule_work(&fip->timer_work);\r\nreturn -EINPROGRESS;\r\ncase ELS_FDISC:\r\nif (ntoh24(fh->fh_s_id))\r\nreturn 0;\r\nop = FIP_DT_FDISC;\r\nbreak;\r\ncase ELS_LOGO:\r\nif (fip->mode == FIP_MODE_VN2VN) {\r\nif (fip->state != FIP_ST_VNMP_UP)\r\nreturn -EINVAL;\r\nif (ntoh24(fh->fh_d_id) == FC_FID_FLOGI)\r\nreturn -EINVAL;\r\n} else {\r\nif (fip->state != FIP_ST_ENABLED)\r\nreturn 0;\r\nif (ntoh24(fh->fh_d_id) != FC_FID_FLOGI)\r\nreturn 0;\r\n}\r\nop = FIP_DT_LOGO;\r\nbreak;\r\ncase ELS_LS_ACC:\r\nif (fip->state == FIP_ST_NON_FIP) {\r\nif (fip->flogi_oxid == FC_XID_UNKNOWN)\r\nreturn 0;\r\nfip->flogi_oxid = FC_XID_UNKNOWN;\r\nfc_fcoe_set_mac(mac, fh->fh_d_id);\r\nfip->update_mac(lport, mac);\r\n}\r\ncase ELS_LS_RJT:\r\nop = fr_encaps(fp);\r\nif (op)\r\nbreak;\r\nreturn 0;\r\ndefault:\r\nif (fip->state != FIP_ST_ENABLED &&\r\nfip->state != FIP_ST_VNMP_UP)\r\ngoto drop;\r\nreturn 0;\r\n}\r\nLIBFCOE_FIP_DBG(fip, "els_send op %u d_id %x\n",\r\nop, ntoh24(fh->fh_d_id));\r\nif (fcoe_ctlr_encaps(fip, lport, op, skb, ntoh24(fh->fh_d_id)))\r\ngoto drop;\r\nfip->send(fip, skb);\r\nreturn -EINPROGRESS;\r\ndrop:\r\nkfree_skb(skb);\r\nreturn -EINVAL;\r\n}\r\nstatic unsigned long fcoe_ctlr_age_fcfs(struct fcoe_ctlr *fip)\r\n{\r\nstruct fcoe_fcf *fcf;\r\nstruct fcoe_fcf *next;\r\nunsigned long next_timer = jiffies + msecs_to_jiffies(FIP_VN_KA_PERIOD);\r\nunsigned long deadline;\r\nunsigned long sel_time = 0;\r\nstruct list_head del_list;\r\nstruct fc_stats *stats;\r\nINIT_LIST_HEAD(&del_list);\r\nstats = per_cpu_ptr(fip->lp->stats, get_cpu());\r\nlist_for_each_entry_safe(fcf, next, &fip->fcfs, list) {\r\ndeadline = fcf->time + fcf->fka_period + fcf->fka_period / 2;\r\nif (fip->sel_fcf == fcf) {\r\nif (time_after(jiffies, deadline)) {\r\nstats->MissDiscAdvCount++;\r\nprintk(KERN_INFO "libfcoe: host%d: "\r\n"Missing Discovery Advertisement "\r\n"for fab %16.16llx count %lld\n",\r\nfip->lp->host->host_no, fcf->fabric_name,\r\nstats->MissDiscAdvCount);\r\n} else if (time_after(next_timer, deadline))\r\nnext_timer = deadline;\r\n}\r\ndeadline += fcf->fka_period;\r\nif (time_after_eq(jiffies, deadline)) {\r\nif (fip->sel_fcf == fcf)\r\nfip->sel_fcf = NULL;\r\nlist_del(&fcf->list);\r\nlist_add(&fcf->list, &del_list);\r\nstats->VLinkFailureCount++;\r\n} else {\r\nif (time_after(next_timer, deadline))\r\nnext_timer = deadline;\r\nif (fcoe_ctlr_mtu_valid(fcf) &&\r\n(!sel_time || time_before(sel_time, fcf->time)))\r\nsel_time = fcf->time;\r\n}\r\n}\r\nput_cpu();\r\nlist_for_each_entry_safe(fcf, next, &del_list, list) {\r\nfcoe_sysfs_fcf_del(fcf);\r\n}\r\nif (sel_time && !fip->sel_fcf && !fip->sel_time) {\r\nsel_time += msecs_to_jiffies(FCOE_CTLR_START_DELAY);\r\nfip->sel_time = sel_time;\r\n}\r\nreturn next_timer;\r\n}\r\nstatic int fcoe_ctlr_parse_adv(struct fcoe_ctlr *fip,\r\nstruct sk_buff *skb, struct fcoe_fcf *fcf)\r\n{\r\nstruct fip_header *fiph;\r\nstruct fip_desc *desc = NULL;\r\nstruct fip_wwn_desc *wwn;\r\nstruct fip_fab_desc *fab;\r\nstruct fip_fka_desc *fka;\r\nunsigned long t;\r\nsize_t rlen;\r\nsize_t dlen;\r\nu32 desc_mask;\r\nmemset(fcf, 0, sizeof(*fcf));\r\nfcf->fka_period = msecs_to_jiffies(FCOE_CTLR_DEF_FKA);\r\nfiph = (struct fip_header *)skb->data;\r\nfcf->flags = ntohs(fiph->fip_flags);\r\ndesc_mask = BIT(FIP_DT_PRI) | BIT(FIP_DT_MAC) | BIT(FIP_DT_NAME) |\r\nBIT(FIP_DT_FAB) | BIT(FIP_DT_FKA);\r\nrlen = ntohs(fiph->fip_dl_len) * 4;\r\nif (rlen + sizeof(*fiph) > skb->len)\r\nreturn -EINVAL;\r\ndesc = (struct fip_desc *)(fiph + 1);\r\nwhile (rlen > 0) {\r\ndlen = desc->fip_dlen * FIP_BPW;\r\nif (dlen < sizeof(*desc) || dlen > rlen)\r\nreturn -EINVAL;\r\nif ((desc->fip_dtype < 32) &&\r\n!(desc_mask & 1U << desc->fip_dtype)) {\r\nLIBFCOE_FIP_DBG(fip, "Duplicate Critical "\r\n"Descriptors in FIP adv\n");\r\nreturn -EINVAL;\r\n}\r\nswitch (desc->fip_dtype) {\r\ncase FIP_DT_PRI:\r\nif (dlen != sizeof(struct fip_pri_desc))\r\ngoto len_err;\r\nfcf->pri = ((struct fip_pri_desc *)desc)->fd_pri;\r\ndesc_mask &= ~BIT(FIP_DT_PRI);\r\nbreak;\r\ncase FIP_DT_MAC:\r\nif (dlen != sizeof(struct fip_mac_desc))\r\ngoto len_err;\r\nmemcpy(fcf->fcf_mac,\r\n((struct fip_mac_desc *)desc)->fd_mac,\r\nETH_ALEN);\r\nmemcpy(fcf->fcoe_mac, fcf->fcf_mac, ETH_ALEN);\r\nif (!is_valid_ether_addr(fcf->fcf_mac)) {\r\nLIBFCOE_FIP_DBG(fip,\r\n"Invalid MAC addr %pM in FIP adv\n",\r\nfcf->fcf_mac);\r\nreturn -EINVAL;\r\n}\r\ndesc_mask &= ~BIT(FIP_DT_MAC);\r\nbreak;\r\ncase FIP_DT_NAME:\r\nif (dlen != sizeof(struct fip_wwn_desc))\r\ngoto len_err;\r\nwwn = (struct fip_wwn_desc *)desc;\r\nfcf->switch_name = get_unaligned_be64(&wwn->fd_wwn);\r\ndesc_mask &= ~BIT(FIP_DT_NAME);\r\nbreak;\r\ncase FIP_DT_FAB:\r\nif (dlen != sizeof(struct fip_fab_desc))\r\ngoto len_err;\r\nfab = (struct fip_fab_desc *)desc;\r\nfcf->fabric_name = get_unaligned_be64(&fab->fd_wwn);\r\nfcf->vfid = ntohs(fab->fd_vfid);\r\nfcf->fc_map = ntoh24(fab->fd_map);\r\ndesc_mask &= ~BIT(FIP_DT_FAB);\r\nbreak;\r\ncase FIP_DT_FKA:\r\nif (dlen != sizeof(struct fip_fka_desc))\r\ngoto len_err;\r\nfka = (struct fip_fka_desc *)desc;\r\nif (fka->fd_flags & FIP_FKA_ADV_D)\r\nfcf->fd_flags = 1;\r\nt = ntohl(fka->fd_fka_period);\r\nif (t >= FCOE_CTLR_MIN_FKA)\r\nfcf->fka_period = msecs_to_jiffies(t);\r\ndesc_mask &= ~BIT(FIP_DT_FKA);\r\nbreak;\r\ncase FIP_DT_MAP_OUI:\r\ncase FIP_DT_FCOE_SIZE:\r\ncase FIP_DT_FLOGI:\r\ncase FIP_DT_FDISC:\r\ncase FIP_DT_LOGO:\r\ncase FIP_DT_ELP:\r\ndefault:\r\nLIBFCOE_FIP_DBG(fip, "unexpected descriptor type %x "\r\n"in FIP adv\n", desc->fip_dtype);\r\nif (desc->fip_dtype < FIP_DT_VENDOR_BASE)\r\nreturn -EINVAL;\r\nbreak;\r\n}\r\ndesc = (struct fip_desc *)((char *)desc + dlen);\r\nrlen -= dlen;\r\n}\r\nif (!fcf->fc_map || (fcf->fc_map & 0x10000))\r\nreturn -EINVAL;\r\nif (!fcf->switch_name)\r\nreturn -EINVAL;\r\nif (desc_mask) {\r\nLIBFCOE_FIP_DBG(fip, "adv missing descriptors mask %x\n",\r\ndesc_mask);\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\nlen_err:\r\nLIBFCOE_FIP_DBG(fip, "FIP length error in descriptor type %x len %zu\n",\r\ndesc->fip_dtype, dlen);\r\nreturn -EINVAL;\r\n}\r\nstatic void fcoe_ctlr_recv_adv(struct fcoe_ctlr *fip, struct sk_buff *skb)\r\n{\r\nstruct fcoe_fcf *fcf;\r\nstruct fcoe_fcf new;\r\nunsigned long sol_tov = msecs_to_jiffies(FCOE_CTRL_SOL_TOV);\r\nint first = 0;\r\nint mtu_valid;\r\nint found = 0;\r\nint rc = 0;\r\nif (fcoe_ctlr_parse_adv(fip, skb, &new))\r\nreturn;\r\nmutex_lock(&fip->ctlr_mutex);\r\nfirst = list_empty(&fip->fcfs);\r\nlist_for_each_entry(fcf, &fip->fcfs, list) {\r\nif (fcf->switch_name == new.switch_name &&\r\nfcf->fabric_name == new.fabric_name &&\r\nfcf->fc_map == new.fc_map &&\r\nether_addr_equal(fcf->fcf_mac, new.fcf_mac)) {\r\nfound = 1;\r\nbreak;\r\n}\r\n}\r\nif (!found) {\r\nif (fip->fcf_count >= FCOE_CTLR_FCF_LIMIT)\r\ngoto out;\r\nfcf = kmalloc(sizeof(*fcf), GFP_ATOMIC);\r\nif (!fcf)\r\ngoto out;\r\nmemcpy(fcf, &new, sizeof(new));\r\nfcf->fip = fip;\r\nrc = fcoe_sysfs_fcf_add(fcf);\r\nif (rc) {\r\nprintk(KERN_ERR "Failed to allocate sysfs instance "\r\n"for FCF, fab %16.16llx mac %pM\n",\r\nnew.fabric_name, new.fcf_mac);\r\nkfree(fcf);\r\ngoto out;\r\n}\r\n} else {\r\nfcf->fd_flags = new.fd_flags;\r\nif (!fcoe_ctlr_fcf_usable(fcf))\r\nfcf->flags = new.flags;\r\nif (fcf == fip->sel_fcf && !fcf->fd_flags) {\r\nfip->ctlr_ka_time -= fcf->fka_period;\r\nfip->ctlr_ka_time += new.fka_period;\r\nif (time_before(fip->ctlr_ka_time, fip->timer.expires))\r\nmod_timer(&fip->timer, fip->ctlr_ka_time);\r\n}\r\nfcf->fka_period = new.fka_period;\r\nmemcpy(fcf->fcf_mac, new.fcf_mac, ETH_ALEN);\r\n}\r\nmtu_valid = fcoe_ctlr_mtu_valid(fcf);\r\nfcf->time = jiffies;\r\nif (!found)\r\nLIBFCOE_FIP_DBG(fip, "New FCF fab %16.16llx mac %pM\n",\r\nfcf->fabric_name, fcf->fcf_mac);\r\nif (!mtu_valid)\r\nfcoe_ctlr_solicit(fip, fcf);\r\nif (first && time_after(jiffies, fip->sol_time + sol_tov))\r\nfcoe_ctlr_solicit(fip, NULL);\r\nif (mtu_valid)\r\nlist_move(&fcf->list, &fip->fcfs);\r\nif (mtu_valid && !fip->sel_fcf && !fip->sel_time &&\r\nfcoe_ctlr_fcf_usable(fcf)) {\r\nfip->sel_time = jiffies +\r\nmsecs_to_jiffies(FCOE_CTLR_START_DELAY);\r\nif (!timer_pending(&fip->timer) ||\r\ntime_before(fip->sel_time, fip->timer.expires))\r\nmod_timer(&fip->timer, fip->sel_time);\r\n}\r\nout:\r\nmutex_unlock(&fip->ctlr_mutex);\r\n}\r\nstatic void fcoe_ctlr_recv_els(struct fcoe_ctlr *fip, struct sk_buff *skb)\r\n{\r\nstruct fc_lport *lport = fip->lp;\r\nstruct fip_header *fiph;\r\nstruct fc_frame *fp = (struct fc_frame *)skb;\r\nstruct fc_frame_header *fh = NULL;\r\nstruct fip_desc *desc;\r\nstruct fip_encaps *els;\r\nstruct fcoe_fcf *sel;\r\nstruct fc_stats *stats;\r\nenum fip_desc_type els_dtype = 0;\r\nu8 els_op;\r\nu8 sub;\r\nu8 granted_mac[ETH_ALEN] = { 0 };\r\nsize_t els_len = 0;\r\nsize_t rlen;\r\nsize_t dlen;\r\nu32 desc_mask = 0;\r\nu32 desc_cnt = 0;\r\nfiph = (struct fip_header *)skb->data;\r\nsub = fiph->fip_subcode;\r\nif (sub != FIP_SC_REQ && sub != FIP_SC_REP)\r\ngoto drop;\r\nrlen = ntohs(fiph->fip_dl_len) * 4;\r\nif (rlen + sizeof(*fiph) > skb->len)\r\ngoto drop;\r\ndesc = (struct fip_desc *)(fiph + 1);\r\nwhile (rlen > 0) {\r\ndesc_cnt++;\r\ndlen = desc->fip_dlen * FIP_BPW;\r\nif (dlen < sizeof(*desc) || dlen > rlen)\r\ngoto drop;\r\nif (desc->fip_dtype < 32) {\r\nif ((desc->fip_dtype != FIP_DT_MAC) &&\r\n(desc_mask & 1U << desc->fip_dtype)) {\r\nLIBFCOE_FIP_DBG(fip, "Duplicate Critical "\r\n"Descriptors in FIP ELS\n");\r\ngoto drop;\r\n}\r\ndesc_mask |= (1 << desc->fip_dtype);\r\n}\r\nswitch (desc->fip_dtype) {\r\ncase FIP_DT_MAC:\r\nsel = fip->sel_fcf;\r\nif (desc_cnt == 1) {\r\nLIBFCOE_FIP_DBG(fip, "FIP descriptors "\r\n"received out of order\n");\r\ngoto drop;\r\n}\r\nif (desc_cnt == 2)\r\nmemcpy(granted_mac,\r\n((struct fip_mac_desc *)desc)->fd_mac,\r\nETH_ALEN);\r\nif (dlen != sizeof(struct fip_mac_desc))\r\ngoto len_err;\r\nif ((desc_cnt == 3) && (sel))\r\nmemcpy(sel->fcoe_mac,\r\n((struct fip_mac_desc *)desc)->fd_mac,\r\nETH_ALEN);\r\nbreak;\r\ncase FIP_DT_FLOGI:\r\ncase FIP_DT_FDISC:\r\ncase FIP_DT_LOGO:\r\ncase FIP_DT_ELP:\r\nif (desc_cnt != 1) {\r\nLIBFCOE_FIP_DBG(fip, "FIP descriptors "\r\n"received out of order\n");\r\ngoto drop;\r\n}\r\nif (fh)\r\ngoto drop;\r\nif (dlen < sizeof(*els) + sizeof(*fh) + 1)\r\ngoto len_err;\r\nels_len = dlen - sizeof(*els);\r\nels = (struct fip_encaps *)desc;\r\nfh = (struct fc_frame_header *)(els + 1);\r\nels_dtype = desc->fip_dtype;\r\nbreak;\r\ndefault:\r\nLIBFCOE_FIP_DBG(fip, "unexpected descriptor type %x "\r\n"in FIP adv\n", desc->fip_dtype);\r\nif (desc->fip_dtype < FIP_DT_VENDOR_BASE)\r\ngoto drop;\r\nif (desc_cnt <= 2) {\r\nLIBFCOE_FIP_DBG(fip, "FIP descriptors "\r\n"received out of order\n");\r\ngoto drop;\r\n}\r\nbreak;\r\n}\r\ndesc = (struct fip_desc *)((char *)desc + dlen);\r\nrlen -= dlen;\r\n}\r\nif (!fh)\r\ngoto drop;\r\nels_op = *(u8 *)(fh + 1);\r\nif ((els_dtype == FIP_DT_FLOGI || els_dtype == FIP_DT_FDISC) &&\r\nsub == FIP_SC_REP && fip->mode != FIP_MODE_VN2VN) {\r\nif (els_op == ELS_LS_ACC) {\r\nif (!is_valid_ether_addr(granted_mac)) {\r\nLIBFCOE_FIP_DBG(fip,\r\n"Invalid MAC address %pM in FIP ELS\n",\r\ngranted_mac);\r\ngoto drop;\r\n}\r\nmemcpy(fr_cb(fp)->granted_mac, granted_mac, ETH_ALEN);\r\nif (fip->flogi_oxid == ntohs(fh->fh_ox_id)) {\r\nfip->flogi_oxid = FC_XID_UNKNOWN;\r\nif (els_dtype == FIP_DT_FLOGI)\r\nfcoe_ctlr_announce(fip);\r\n}\r\n} else if (els_dtype == FIP_DT_FLOGI &&\r\n!fcoe_ctlr_flogi_retry(fip))\r\ngoto drop;\r\n}\r\nif ((desc_cnt == 0) || ((els_op != ELS_LS_RJT) &&\r\n(!(1U << FIP_DT_MAC & desc_mask)))) {\r\nLIBFCOE_FIP_DBG(fip, "Missing critical descriptors "\r\n"in FIP ELS\n");\r\ngoto drop;\r\n}\r\nskb_pull(skb, (u8 *)fh - skb->data);\r\nskb_trim(skb, els_len);\r\nfp = (struct fc_frame *)skb;\r\nfc_frame_init(fp);\r\nfr_sof(fp) = FC_SOF_I3;\r\nfr_eof(fp) = FC_EOF_T;\r\nfr_dev(fp) = lport;\r\nfr_encaps(fp) = els_dtype;\r\nstats = per_cpu_ptr(lport->stats, get_cpu());\r\nstats->RxFrames++;\r\nstats->RxWords += skb->len / FIP_BPW;\r\nput_cpu();\r\nfc_exch_recv(lport, fp);\r\nreturn;\r\nlen_err:\r\nLIBFCOE_FIP_DBG(fip, "FIP length error in descriptor type %x len %zu\n",\r\ndesc->fip_dtype, dlen);\r\ndrop:\r\nkfree_skb(skb);\r\n}\r\nstatic void fcoe_ctlr_recv_clr_vlink(struct fcoe_ctlr *fip,\r\nstruct fip_header *fh)\r\n{\r\nstruct fip_desc *desc;\r\nstruct fip_mac_desc *mp;\r\nstruct fip_wwn_desc *wp;\r\nstruct fip_vn_desc *vp;\r\nsize_t rlen;\r\nsize_t dlen;\r\nstruct fcoe_fcf *fcf = fip->sel_fcf;\r\nstruct fc_lport *lport = fip->lp;\r\nstruct fc_lport *vn_port = NULL;\r\nu32 desc_mask;\r\nint num_vlink_desc;\r\nint reset_phys_port = 0;\r\nstruct fip_vn_desc **vlink_desc_arr = NULL;\r\nLIBFCOE_FIP_DBG(fip, "Clear Virtual Link received\n");\r\nif (!fcf || !lport->port_id) {\r\nmutex_lock(&fip->ctlr_mutex);\r\nfcoe_ctlr_reset(fip);\r\nmutex_unlock(&fip->ctlr_mutex);\r\nreturn;\r\n}\r\ndesc_mask = BIT(FIP_DT_MAC) | BIT(FIP_DT_NAME);\r\nrlen = ntohs(fh->fip_dl_len) * FIP_BPW;\r\ndesc = (struct fip_desc *)(fh + 1);\r\nnum_vlink_desc = rlen / sizeof(*vp);\r\nif (num_vlink_desc)\r\nvlink_desc_arr = kmalloc(sizeof(vp) * num_vlink_desc,\r\nGFP_ATOMIC);\r\nif (!vlink_desc_arr)\r\nreturn;\r\nnum_vlink_desc = 0;\r\nwhile (rlen >= sizeof(*desc)) {\r\ndlen = desc->fip_dlen * FIP_BPW;\r\nif (dlen > rlen)\r\ngoto err;\r\nif ((desc->fip_dtype < 32) &&\r\n(desc->fip_dtype != FIP_DT_VN_ID) &&\r\n!(desc_mask & 1U << desc->fip_dtype)) {\r\nLIBFCOE_FIP_DBG(fip, "Duplicate Critical "\r\n"Descriptors in FIP CVL\n");\r\ngoto err;\r\n}\r\nswitch (desc->fip_dtype) {\r\ncase FIP_DT_MAC:\r\nmp = (struct fip_mac_desc *)desc;\r\nif (dlen < sizeof(*mp))\r\ngoto err;\r\nif (!ether_addr_equal(mp->fd_mac, fcf->fcf_mac))\r\ngoto err;\r\ndesc_mask &= ~BIT(FIP_DT_MAC);\r\nbreak;\r\ncase FIP_DT_NAME:\r\nwp = (struct fip_wwn_desc *)desc;\r\nif (dlen < sizeof(*wp))\r\ngoto err;\r\nif (get_unaligned_be64(&wp->fd_wwn) != fcf->switch_name)\r\ngoto err;\r\ndesc_mask &= ~BIT(FIP_DT_NAME);\r\nbreak;\r\ncase FIP_DT_VN_ID:\r\nvp = (struct fip_vn_desc *)desc;\r\nif (dlen < sizeof(*vp))\r\ngoto err;\r\nvlink_desc_arr[num_vlink_desc++] = vp;\r\nvn_port = fc_vport_id_lookup(lport,\r\nntoh24(vp->fd_fc_id));\r\nif (vn_port && (vn_port == lport)) {\r\nmutex_lock(&fip->ctlr_mutex);\r\nper_cpu_ptr(lport->stats,\r\nget_cpu())->VLinkFailureCount++;\r\nput_cpu();\r\nfcoe_ctlr_reset(fip);\r\nmutex_unlock(&fip->ctlr_mutex);\r\n}\r\nbreak;\r\ndefault:\r\nif (desc->fip_dtype < FIP_DT_VENDOR_BASE)\r\ngoto err;\r\nbreak;\r\n}\r\ndesc = (struct fip_desc *)((char *)desc + dlen);\r\nrlen -= dlen;\r\n}\r\nif (desc_mask)\r\nLIBFCOE_FIP_DBG(fip, "missing descriptors mask %x\n",\r\ndesc_mask);\r\nelse if (!num_vlink_desc) {\r\nLIBFCOE_FIP_DBG(fip, "CVL: no Vx_Port descriptor found\n");\r\nmutex_lock(&fip->ctlr_mutex);\r\nper_cpu_ptr(lport->stats, get_cpu())->VLinkFailureCount++;\r\nput_cpu();\r\nfcoe_ctlr_reset(fip);\r\nmutex_unlock(&fip->ctlr_mutex);\r\nmutex_lock(&lport->lp_mutex);\r\nlist_for_each_entry(vn_port, &lport->vports, list)\r\nfc_lport_reset(vn_port);\r\nmutex_unlock(&lport->lp_mutex);\r\nfc_lport_reset(fip->lp);\r\nfcoe_ctlr_solicit(fip, NULL);\r\n} else {\r\nint i;\r\nLIBFCOE_FIP_DBG(fip, "performing Clear Virtual Link\n");\r\nfor (i = 0; i < num_vlink_desc; i++) {\r\nvp = vlink_desc_arr[i];\r\nvn_port = fc_vport_id_lookup(lport,\r\nntoh24(vp->fd_fc_id));\r\nif (!vn_port)\r\ncontinue;\r\nif (!ether_addr_equal(fip->get_src_addr(vn_port),\r\nvp->fd_mac) ||\r\nget_unaligned_be64(&vp->fd_wwpn) !=\r\nvn_port->wwpn)\r\ncontinue;\r\nif (vn_port == lport)\r\nreset_phys_port = 1;\r\nelse\r\nfc_lport_reset(vn_port);\r\n}\r\nif (reset_phys_port) {\r\nfc_lport_reset(fip->lp);\r\nfcoe_ctlr_solicit(fip, NULL);\r\n}\r\n}\r\nerr:\r\nkfree(vlink_desc_arr);\r\n}\r\nvoid fcoe_ctlr_recv(struct fcoe_ctlr *fip, struct sk_buff *skb)\r\n{\r\nskb = skb_share_check(skb, GFP_ATOMIC);\r\nif (!skb)\r\nreturn;\r\nskb_queue_tail(&fip->fip_recv_list, skb);\r\nschedule_work(&fip->recv_work);\r\n}\r\nstatic int fcoe_ctlr_recv_handler(struct fcoe_ctlr *fip, struct sk_buff *skb)\r\n{\r\nstruct fip_header *fiph;\r\nstruct ethhdr *eh;\r\nenum fip_state state;\r\nu16 op;\r\nu8 sub;\r\nif (skb_linearize(skb))\r\ngoto drop;\r\nif (skb->len < sizeof(*fiph))\r\ngoto drop;\r\neh = eth_hdr(skb);\r\nif (fip->mode == FIP_MODE_VN2VN) {\r\nif (!ether_addr_equal(eh->h_dest, fip->ctl_src_addr) &&\r\n!ether_addr_equal(eh->h_dest, fcoe_all_vn2vn) &&\r\n!ether_addr_equal(eh->h_dest, fcoe_all_p2p))\r\ngoto drop;\r\n} else if (!ether_addr_equal(eh->h_dest, fip->ctl_src_addr) &&\r\n!ether_addr_equal(eh->h_dest, fcoe_all_enode))\r\ngoto drop;\r\nfiph = (struct fip_header *)skb->data;\r\nop = ntohs(fiph->fip_op);\r\nsub = fiph->fip_subcode;\r\nif (FIP_VER_DECAPS(fiph->fip_ver) != FIP_VER)\r\ngoto drop;\r\nif (ntohs(fiph->fip_dl_len) * FIP_BPW + sizeof(*fiph) > skb->len)\r\ngoto drop;\r\nmutex_lock(&fip->ctlr_mutex);\r\nstate = fip->state;\r\nif (state == FIP_ST_AUTO) {\r\nfip->map_dest = 0;\r\nfcoe_ctlr_set_state(fip, FIP_ST_ENABLED);\r\nstate = FIP_ST_ENABLED;\r\nLIBFCOE_FIP_DBG(fip, "Using FIP mode\n");\r\n}\r\nmutex_unlock(&fip->ctlr_mutex);\r\nif (fip->mode == FIP_MODE_VN2VN && op == FIP_OP_VN2VN)\r\nreturn fcoe_ctlr_vn_recv(fip, skb);\r\nif (state != FIP_ST_ENABLED && state != FIP_ST_VNMP_UP &&\r\nstate != FIP_ST_VNMP_CLAIM)\r\ngoto drop;\r\nif (op == FIP_OP_LS) {\r\nfcoe_ctlr_recv_els(fip, skb);\r\nreturn 0;\r\n}\r\nif (state != FIP_ST_ENABLED)\r\ngoto drop;\r\nif (op == FIP_OP_DISC && sub == FIP_SC_ADV)\r\nfcoe_ctlr_recv_adv(fip, skb);\r\nelse if (op == FIP_OP_CTRL && sub == FIP_SC_CLR_VLINK)\r\nfcoe_ctlr_recv_clr_vlink(fip, fiph);\r\nkfree_skb(skb);\r\nreturn 0;\r\ndrop:\r\nkfree_skb(skb);\r\nreturn -1;\r\n}\r\nstatic struct fcoe_fcf *fcoe_ctlr_select(struct fcoe_ctlr *fip)\r\n{\r\nstruct fcoe_fcf *fcf;\r\nstruct fcoe_fcf *best = fip->sel_fcf;\r\nlist_for_each_entry(fcf, &fip->fcfs, list) {\r\nLIBFCOE_FIP_DBG(fip, "consider FCF fab %16.16llx "\r\n"VFID %d mac %pM map %x val %d "\r\n"sent %u pri %u\n",\r\nfcf->fabric_name, fcf->vfid, fcf->fcf_mac,\r\nfcf->fc_map, fcoe_ctlr_mtu_valid(fcf),\r\nfcf->flogi_sent, fcf->pri);\r\nif (!fcoe_ctlr_fcf_usable(fcf)) {\r\nLIBFCOE_FIP_DBG(fip, "FCF for fab %16.16llx "\r\n"map %x %svalid %savailable\n",\r\nfcf->fabric_name, fcf->fc_map,\r\n(fcf->flags & FIP_FL_SOL) ? "" : "in",\r\n(fcf->flags & FIP_FL_AVAIL) ?\r\n"" : "un");\r\ncontinue;\r\n}\r\nif (!best || fcf->pri < best->pri || best->flogi_sent)\r\nbest = fcf;\r\nif (fcf->fabric_name != best->fabric_name ||\r\nfcf->vfid != best->vfid ||\r\nfcf->fc_map != best->fc_map) {\r\nLIBFCOE_FIP_DBG(fip, "Conflicting fabric, VFID, "\r\n"or FC-MAP\n");\r\nreturn NULL;\r\n}\r\n}\r\nfip->sel_fcf = best;\r\nif (best) {\r\nLIBFCOE_FIP_DBG(fip, "using FCF mac %pM\n", best->fcf_mac);\r\nfip->port_ka_time = jiffies +\r\nmsecs_to_jiffies(FIP_VN_KA_PERIOD);\r\nfip->ctlr_ka_time = jiffies + best->fka_period;\r\nif (time_before(fip->ctlr_ka_time, fip->timer.expires))\r\nmod_timer(&fip->timer, fip->ctlr_ka_time);\r\n}\r\nreturn best;\r\n}\r\nstatic int fcoe_ctlr_flogi_send_locked(struct fcoe_ctlr *fip)\r\n{\r\nstruct sk_buff *skb;\r\nstruct sk_buff *skb_orig;\r\nstruct fc_frame_header *fh;\r\nint error;\r\nskb_orig = fip->flogi_req;\r\nif (!skb_orig)\r\nreturn -EINVAL;\r\nskb = skb_clone(skb_orig, GFP_ATOMIC);\r\nif (!skb) {\r\nskb = skb_orig;\r\nfip->flogi_req = NULL;\r\n}\r\nfh = (struct fc_frame_header *)skb->data;\r\nerror = fcoe_ctlr_encaps(fip, fip->lp, FIP_DT_FLOGI, skb,\r\nntoh24(fh->fh_d_id));\r\nif (error) {\r\nkfree_skb(skb);\r\nreturn error;\r\n}\r\nfip->send(fip, skb);\r\nfip->sel_fcf->flogi_sent = 1;\r\nreturn 0;\r\n}\r\nstatic int fcoe_ctlr_flogi_retry(struct fcoe_ctlr *fip)\r\n{\r\nstruct fcoe_fcf *fcf;\r\nint error;\r\nmutex_lock(&fip->ctlr_mutex);\r\nspin_lock_bh(&fip->ctlr_lock);\r\nLIBFCOE_FIP_DBG(fip, "re-sending FLOGI - reselect\n");\r\nfcf = fcoe_ctlr_select(fip);\r\nif (!fcf || fcf->flogi_sent) {\r\nkfree_skb(fip->flogi_req);\r\nfip->flogi_req = NULL;\r\nerror = -ENOENT;\r\n} else {\r\nfcoe_ctlr_solicit(fip, NULL);\r\nerror = fcoe_ctlr_flogi_send_locked(fip);\r\n}\r\nspin_unlock_bh(&fip->ctlr_lock);\r\nmutex_unlock(&fip->ctlr_mutex);\r\nreturn error;\r\n}\r\nstatic void fcoe_ctlr_flogi_send(struct fcoe_ctlr *fip)\r\n{\r\nstruct fcoe_fcf *fcf;\r\nspin_lock_bh(&fip->ctlr_lock);\r\nfcf = fip->sel_fcf;\r\nif (!fcf || !fip->flogi_req_send)\r\ngoto unlock;\r\nLIBFCOE_FIP_DBG(fip, "sending FLOGI\n");\r\nif (fcf->flogi_sent) {\r\nLIBFCOE_FIP_DBG(fip, "sending FLOGI - reselect\n");\r\nfcf = fcoe_ctlr_select(fip);\r\nif (!fcf || fcf->flogi_sent) {\r\nLIBFCOE_FIP_DBG(fip, "sending FLOGI - clearing\n");\r\nlist_for_each_entry(fcf, &fip->fcfs, list)\r\nfcf->flogi_sent = 0;\r\nfcf = fcoe_ctlr_select(fip);\r\n}\r\n}\r\nif (fcf) {\r\nfcoe_ctlr_flogi_send_locked(fip);\r\nfip->flogi_req_send = 0;\r\n} else\r\nLIBFCOE_FIP_DBG(fip, "No FCF selected - defer send\n");\r\nunlock:\r\nspin_unlock_bh(&fip->ctlr_lock);\r\n}\r\nstatic void fcoe_ctlr_timeout(unsigned long arg)\r\n{\r\nstruct fcoe_ctlr *fip = (struct fcoe_ctlr *)arg;\r\nschedule_work(&fip->timer_work);\r\n}\r\nstatic void fcoe_ctlr_timer_work(struct work_struct *work)\r\n{\r\nstruct fcoe_ctlr *fip;\r\nstruct fc_lport *vport;\r\nu8 *mac;\r\nu8 reset = 0;\r\nu8 send_ctlr_ka = 0;\r\nu8 send_port_ka = 0;\r\nstruct fcoe_fcf *sel;\r\nstruct fcoe_fcf *fcf;\r\nunsigned long next_timer;\r\nfip = container_of(work, struct fcoe_ctlr, timer_work);\r\nif (fip->mode == FIP_MODE_VN2VN)\r\nreturn fcoe_ctlr_vn_timeout(fip);\r\nmutex_lock(&fip->ctlr_mutex);\r\nif (fip->state == FIP_ST_DISABLED) {\r\nmutex_unlock(&fip->ctlr_mutex);\r\nreturn;\r\n}\r\nfcf = fip->sel_fcf;\r\nnext_timer = fcoe_ctlr_age_fcfs(fip);\r\nsel = fip->sel_fcf;\r\nif (!sel && fip->sel_time) {\r\nif (time_after_eq(jiffies, fip->sel_time)) {\r\nsel = fcoe_ctlr_select(fip);\r\nfip->sel_time = 0;\r\n} else if (time_after(next_timer, fip->sel_time))\r\nnext_timer = fip->sel_time;\r\n}\r\nif (sel && fip->flogi_req_send)\r\nfcoe_ctlr_flogi_send(fip);\r\nelse if (!sel && fcf)\r\nreset = 1;\r\nif (sel && !sel->fd_flags) {\r\nif (time_after_eq(jiffies, fip->ctlr_ka_time)) {\r\nfip->ctlr_ka_time = jiffies + sel->fka_period;\r\nsend_ctlr_ka = 1;\r\n}\r\nif (time_after(next_timer, fip->ctlr_ka_time))\r\nnext_timer = fip->ctlr_ka_time;\r\nif (time_after_eq(jiffies, fip->port_ka_time)) {\r\nfip->port_ka_time = jiffies +\r\nmsecs_to_jiffies(FIP_VN_KA_PERIOD);\r\nsend_port_ka = 1;\r\n}\r\nif (time_after(next_timer, fip->port_ka_time))\r\nnext_timer = fip->port_ka_time;\r\n}\r\nif (!list_empty(&fip->fcfs))\r\nmod_timer(&fip->timer, next_timer);\r\nmutex_unlock(&fip->ctlr_mutex);\r\nif (reset) {\r\nfc_lport_reset(fip->lp);\r\nfcoe_ctlr_solicit(fip, NULL);\r\n}\r\nif (send_ctlr_ka)\r\nfcoe_ctlr_send_keep_alive(fip, NULL, 0, fip->ctl_src_addr);\r\nif (send_port_ka) {\r\nmutex_lock(&fip->lp->lp_mutex);\r\nmac = fip->get_src_addr(fip->lp);\r\nfcoe_ctlr_send_keep_alive(fip, fip->lp, 1, mac);\r\nlist_for_each_entry(vport, &fip->lp->vports, list) {\r\nmac = fip->get_src_addr(vport);\r\nfcoe_ctlr_send_keep_alive(fip, vport, 1, mac);\r\n}\r\nmutex_unlock(&fip->lp->lp_mutex);\r\n}\r\n}\r\nstatic void fcoe_ctlr_recv_work(struct work_struct *recv_work)\r\n{\r\nstruct fcoe_ctlr *fip;\r\nstruct sk_buff *skb;\r\nfip = container_of(recv_work, struct fcoe_ctlr, recv_work);\r\nwhile ((skb = skb_dequeue(&fip->fip_recv_list)))\r\nfcoe_ctlr_recv_handler(fip, skb);\r\n}\r\nint fcoe_ctlr_recv_flogi(struct fcoe_ctlr *fip, struct fc_lport *lport,\r\nstruct fc_frame *fp)\r\n{\r\nstruct fc_frame_header *fh;\r\nu8 op;\r\nu8 *sa;\r\nsa = eth_hdr(&fp->skb)->h_source;\r\nfh = fc_frame_header_get(fp);\r\nif (fh->fh_type != FC_TYPE_ELS)\r\nreturn 0;\r\nop = fc_frame_payload_op(fp);\r\nif (op == ELS_LS_ACC && fh->fh_r_ctl == FC_RCTL_ELS_REP &&\r\nfip->flogi_oxid == ntohs(fh->fh_ox_id)) {\r\nmutex_lock(&fip->ctlr_mutex);\r\nif (fip->state != FIP_ST_AUTO && fip->state != FIP_ST_NON_FIP) {\r\nmutex_unlock(&fip->ctlr_mutex);\r\nreturn -EINVAL;\r\n}\r\nfcoe_ctlr_set_state(fip, FIP_ST_NON_FIP);\r\nLIBFCOE_FIP_DBG(fip,\r\n"received FLOGI LS_ACC using non-FIP mode\n");\r\nif (ether_addr_equal(sa, (u8[6])FC_FCOE_FLOGI_MAC)) {\r\nfcoe_ctlr_map_dest(fip);\r\n} else {\r\nmemcpy(fip->dest_addr, sa, ETH_ALEN);\r\nfip->map_dest = 0;\r\n}\r\nfip->flogi_oxid = FC_XID_UNKNOWN;\r\nmutex_unlock(&fip->ctlr_mutex);\r\nfc_fcoe_set_mac(fr_cb(fp)->granted_mac, fh->fh_d_id);\r\n} else if (op == ELS_FLOGI && fh->fh_r_ctl == FC_RCTL_ELS_REQ && sa) {\r\nmutex_lock(&fip->ctlr_mutex);\r\nif (fip->state == FIP_ST_AUTO || fip->state == FIP_ST_NON_FIP) {\r\nmemcpy(fip->dest_addr, sa, ETH_ALEN);\r\nfip->map_dest = 0;\r\nif (fip->state == FIP_ST_AUTO)\r\nLIBFCOE_FIP_DBG(fip, "received non-FIP FLOGI. "\r\n"Setting non-FIP mode\n");\r\nfcoe_ctlr_set_state(fip, FIP_ST_NON_FIP);\r\n}\r\nmutex_unlock(&fip->ctlr_mutex);\r\n}\r\nreturn 0;\r\n}\r\nu64 fcoe_wwn_from_mac(unsigned char mac[MAX_ADDR_LEN],\r\nunsigned int scheme, unsigned int port)\r\n{\r\nu64 wwn;\r\nu64 host_mac;\r\nhost_mac = ((u64) mac[0] << 40) |\r\n((u64) mac[1] << 32) |\r\n((u64) mac[2] << 24) |\r\n((u64) mac[3] << 16) |\r\n((u64) mac[4] << 8) |\r\n(u64) mac[5];\r\nWARN_ON(host_mac >= (1ULL << 48));\r\nwwn = host_mac | ((u64) scheme << 60);\r\nswitch (scheme) {\r\ncase 1:\r\nWARN_ON(port != 0);\r\nbreak;\r\ncase 2:\r\nWARN_ON(port >= 0xfff);\r\nwwn |= (u64) port << 48;\r\nbreak;\r\ndefault:\r\nWARN_ON(1);\r\nbreak;\r\n}\r\nreturn wwn;\r\n}\r\nstatic inline struct fcoe_rport *fcoe_ctlr_rport(struct fc_rport_priv *rdata)\r\n{\r\nreturn (struct fcoe_rport *)(rdata + 1);\r\n}\r\nstatic void fcoe_ctlr_vn_send(struct fcoe_ctlr *fip,\r\nenum fip_vn2vn_subcode sub,\r\nconst u8 *dest, size_t min_len)\r\n{\r\nstruct sk_buff *skb;\r\nstruct fip_frame {\r\nstruct ethhdr eth;\r\nstruct fip_header fip;\r\nstruct fip_mac_desc mac;\r\nstruct fip_wwn_desc wwnn;\r\nstruct fip_vn_desc vn;\r\n} __packed * frame;\r\nstruct fip_fc4_feat *ff;\r\nstruct fip_size_desc *size;\r\nu32 fcp_feat;\r\nsize_t len;\r\nsize_t dlen;\r\nlen = sizeof(*frame);\r\ndlen = 0;\r\nif (sub == FIP_SC_VN_CLAIM_NOTIFY || sub == FIP_SC_VN_CLAIM_REP) {\r\ndlen = sizeof(struct fip_fc4_feat) +\r\nsizeof(struct fip_size_desc);\r\nlen += dlen;\r\n}\r\ndlen += sizeof(frame->mac) + sizeof(frame->wwnn) + sizeof(frame->vn);\r\nlen = max(len, min_len + sizeof(struct ethhdr));\r\nskb = dev_alloc_skb(len);\r\nif (!skb)\r\nreturn;\r\nframe = (struct fip_frame *)skb->data;\r\nmemset(frame, 0, len);\r\nmemcpy(frame->eth.h_dest, dest, ETH_ALEN);\r\nif (sub == FIP_SC_VN_BEACON) {\r\nhton24(frame->eth.h_source, FIP_VN_FC_MAP);\r\nhton24(frame->eth.h_source + 3, fip->port_id);\r\n} else {\r\nmemcpy(frame->eth.h_source, fip->ctl_src_addr, ETH_ALEN);\r\n}\r\nframe->eth.h_proto = htons(ETH_P_FIP);\r\nframe->fip.fip_ver = FIP_VER_ENCAPS(FIP_VER);\r\nframe->fip.fip_op = htons(FIP_OP_VN2VN);\r\nframe->fip.fip_subcode = sub;\r\nframe->fip.fip_dl_len = htons(dlen / FIP_BPW);\r\nframe->mac.fd_desc.fip_dtype = FIP_DT_MAC;\r\nframe->mac.fd_desc.fip_dlen = sizeof(frame->mac) / FIP_BPW;\r\nmemcpy(frame->mac.fd_mac, fip->ctl_src_addr, ETH_ALEN);\r\nframe->wwnn.fd_desc.fip_dtype = FIP_DT_NAME;\r\nframe->wwnn.fd_desc.fip_dlen = sizeof(frame->wwnn) / FIP_BPW;\r\nput_unaligned_be64(fip->lp->wwnn, &frame->wwnn.fd_wwn);\r\nframe->vn.fd_desc.fip_dtype = FIP_DT_VN_ID;\r\nframe->vn.fd_desc.fip_dlen = sizeof(frame->vn) / FIP_BPW;\r\nhton24(frame->vn.fd_mac, FIP_VN_FC_MAP);\r\nhton24(frame->vn.fd_mac + 3, fip->port_id);\r\nhton24(frame->vn.fd_fc_id, fip->port_id);\r\nput_unaligned_be64(fip->lp->wwpn, &frame->vn.fd_wwpn);\r\nif (sub == FIP_SC_VN_CLAIM_NOTIFY || sub == FIP_SC_VN_CLAIM_REP) {\r\nff = (struct fip_fc4_feat *)(frame + 1);\r\nff->fd_desc.fip_dtype = FIP_DT_FC4F;\r\nff->fd_desc.fip_dlen = sizeof(*ff) / FIP_BPW;\r\nff->fd_fts = fip->lp->fcts;\r\nfcp_feat = 0;\r\nif (fip->lp->service_params & FCP_SPPF_INIT_FCN)\r\nfcp_feat |= FCP_FEAT_INIT;\r\nif (fip->lp->service_params & FCP_SPPF_TARG_FCN)\r\nfcp_feat |= FCP_FEAT_TARG;\r\nfcp_feat <<= (FC_TYPE_FCP * 4) % 32;\r\nff->fd_ff.fd_feat[FC_TYPE_FCP * 4 / 32] = htonl(fcp_feat);\r\nsize = (struct fip_size_desc *)(ff + 1);\r\nsize->fd_desc.fip_dtype = FIP_DT_FCOE_SIZE;\r\nsize->fd_desc.fip_dlen = sizeof(*size) / FIP_BPW;\r\nsize->fd_size = htons(fcoe_ctlr_fcoe_size(fip));\r\n}\r\nskb_put(skb, len);\r\nskb->protocol = htons(ETH_P_FIP);\r\nskb->priority = fip->priority;\r\nskb_reset_mac_header(skb);\r\nskb_reset_network_header(skb);\r\nfip->send(fip, skb);\r\n}\r\nstatic void fcoe_ctlr_vn_rport_callback(struct fc_lport *lport,\r\nstruct fc_rport_priv *rdata,\r\nenum fc_rport_event event)\r\n{\r\nstruct fcoe_ctlr *fip = lport->disc.priv;\r\nstruct fcoe_rport *frport = fcoe_ctlr_rport(rdata);\r\nLIBFCOE_FIP_DBG(fip, "vn_rport_callback %x event %d\n",\r\nrdata->ids.port_id, event);\r\nmutex_lock(&fip->ctlr_mutex);\r\nswitch (event) {\r\ncase RPORT_EV_READY:\r\nfrport->login_count = 0;\r\nbreak;\r\ncase RPORT_EV_LOGO:\r\ncase RPORT_EV_FAILED:\r\ncase RPORT_EV_STOP:\r\nfrport->login_count++;\r\nif (frport->login_count > FCOE_CTLR_VN2VN_LOGIN_LIMIT) {\r\nLIBFCOE_FIP_DBG(fip,\r\n"rport FLOGI limited port_id %6.6x\n",\r\nrdata->ids.port_id);\r\nlport->tt.rport_logoff(rdata);\r\n}\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nmutex_unlock(&fip->ctlr_mutex);\r\n}\r\nstatic void fcoe_ctlr_disc_stop_locked(struct fc_lport *lport)\r\n{\r\nstruct fc_rport_priv *rdata;\r\nmutex_lock(&lport->disc.disc_mutex);\r\nlist_for_each_entry_rcu(rdata, &lport->disc.rports, peers)\r\nlport->tt.rport_logoff(rdata);\r\nlport->disc.disc_callback = NULL;\r\nmutex_unlock(&lport->disc.disc_mutex);\r\n}\r\nstatic void fcoe_ctlr_disc_stop(struct fc_lport *lport)\r\n{\r\nstruct fcoe_ctlr *fip = lport->disc.priv;\r\nmutex_lock(&fip->ctlr_mutex);\r\nfcoe_ctlr_disc_stop_locked(lport);\r\nmutex_unlock(&fip->ctlr_mutex);\r\n}\r\nstatic void fcoe_ctlr_disc_stop_final(struct fc_lport *lport)\r\n{\r\nfcoe_ctlr_disc_stop(lport);\r\nlport->tt.rport_flush_queue();\r\nsynchronize_rcu();\r\n}\r\nstatic void fcoe_ctlr_vn_restart(struct fcoe_ctlr *fip)\r\n{\r\nunsigned long wait;\r\nu32 port_id;\r\nfcoe_ctlr_disc_stop_locked(fip->lp);\r\nport_id = fip->port_id;\r\nif (fip->probe_tries)\r\nport_id = prandom_u32_state(&fip->rnd_state) & 0xffff;\r\nelse if (!port_id)\r\nport_id = fip->lp->wwpn & 0xffff;\r\nif (!port_id || port_id == 0xffff)\r\nport_id = 1;\r\nfip->port_id = port_id;\r\nif (fip->probe_tries < FIP_VN_RLIM_COUNT) {\r\nfip->probe_tries++;\r\nwait = prandom_u32() % FIP_VN_PROBE_WAIT;\r\n} else\r\nwait = FIP_VN_RLIM_INT;\r\nmod_timer(&fip->timer, jiffies + msecs_to_jiffies(wait));\r\nfcoe_ctlr_set_state(fip, FIP_ST_VNMP_START);\r\n}\r\nstatic void fcoe_ctlr_vn_start(struct fcoe_ctlr *fip)\r\n{\r\nfip->probe_tries = 0;\r\nprandom_seed_state(&fip->rnd_state, fip->lp->wwpn);\r\nfcoe_ctlr_vn_restart(fip);\r\n}\r\nstatic int fcoe_ctlr_vn_parse(struct fcoe_ctlr *fip,\r\nstruct sk_buff *skb,\r\nstruct fc_rport_priv *rdata)\r\n{\r\nstruct fip_header *fiph;\r\nstruct fip_desc *desc = NULL;\r\nstruct fip_mac_desc *macd = NULL;\r\nstruct fip_wwn_desc *wwn = NULL;\r\nstruct fip_vn_desc *vn = NULL;\r\nstruct fip_size_desc *size = NULL;\r\nstruct fcoe_rport *frport;\r\nsize_t rlen;\r\nsize_t dlen;\r\nu32 desc_mask = 0;\r\nu32 dtype;\r\nu8 sub;\r\nmemset(rdata, 0, sizeof(*rdata) + sizeof(*frport));\r\nfrport = fcoe_ctlr_rport(rdata);\r\nfiph = (struct fip_header *)skb->data;\r\nfrport->flags = ntohs(fiph->fip_flags);\r\nsub = fiph->fip_subcode;\r\nswitch (sub) {\r\ncase FIP_SC_VN_PROBE_REQ:\r\ncase FIP_SC_VN_PROBE_REP:\r\ncase FIP_SC_VN_BEACON:\r\ndesc_mask = BIT(FIP_DT_MAC) | BIT(FIP_DT_NAME) |\r\nBIT(FIP_DT_VN_ID);\r\nbreak;\r\ncase FIP_SC_VN_CLAIM_NOTIFY:\r\ncase FIP_SC_VN_CLAIM_REP:\r\ndesc_mask = BIT(FIP_DT_MAC) | BIT(FIP_DT_NAME) |\r\nBIT(FIP_DT_VN_ID) | BIT(FIP_DT_FC4F) |\r\nBIT(FIP_DT_FCOE_SIZE);\r\nbreak;\r\ndefault:\r\nLIBFCOE_FIP_DBG(fip, "vn_parse unknown subcode %u\n", sub);\r\nreturn -EINVAL;\r\n}\r\nrlen = ntohs(fiph->fip_dl_len) * 4;\r\nif (rlen + sizeof(*fiph) > skb->len)\r\nreturn -EINVAL;\r\ndesc = (struct fip_desc *)(fiph + 1);\r\nwhile (rlen > 0) {\r\ndlen = desc->fip_dlen * FIP_BPW;\r\nif (dlen < sizeof(*desc) || dlen > rlen)\r\nreturn -EINVAL;\r\ndtype = desc->fip_dtype;\r\nif (dtype < 32) {\r\nif (!(desc_mask & BIT(dtype))) {\r\nLIBFCOE_FIP_DBG(fip,\r\n"unexpected or duplicated desc "\r\n"desc type %u in "\r\n"FIP VN2VN subtype %u\n",\r\ndtype, sub);\r\nreturn -EINVAL;\r\n}\r\ndesc_mask &= ~BIT(dtype);\r\n}\r\nswitch (dtype) {\r\ncase FIP_DT_MAC:\r\nif (dlen != sizeof(struct fip_mac_desc))\r\ngoto len_err;\r\nmacd = (struct fip_mac_desc *)desc;\r\nif (!is_valid_ether_addr(macd->fd_mac)) {\r\nLIBFCOE_FIP_DBG(fip,\r\n"Invalid MAC addr %pM in FIP VN2VN\n",\r\nmacd->fd_mac);\r\nreturn -EINVAL;\r\n}\r\nmemcpy(frport->enode_mac, macd->fd_mac, ETH_ALEN);\r\nbreak;\r\ncase FIP_DT_NAME:\r\nif (dlen != sizeof(struct fip_wwn_desc))\r\ngoto len_err;\r\nwwn = (struct fip_wwn_desc *)desc;\r\nrdata->ids.node_name = get_unaligned_be64(&wwn->fd_wwn);\r\nbreak;\r\ncase FIP_DT_VN_ID:\r\nif (dlen != sizeof(struct fip_vn_desc))\r\ngoto len_err;\r\nvn = (struct fip_vn_desc *)desc;\r\nmemcpy(frport->vn_mac, vn->fd_mac, ETH_ALEN);\r\nrdata->ids.port_id = ntoh24(vn->fd_fc_id);\r\nrdata->ids.port_name = get_unaligned_be64(&vn->fd_wwpn);\r\nbreak;\r\ncase FIP_DT_FC4F:\r\nif (dlen != sizeof(struct fip_fc4_feat))\r\ngoto len_err;\r\nbreak;\r\ncase FIP_DT_FCOE_SIZE:\r\nif (dlen != sizeof(struct fip_size_desc))\r\ngoto len_err;\r\nsize = (struct fip_size_desc *)desc;\r\nfrport->fcoe_len = ntohs(size->fd_size);\r\nbreak;\r\ndefault:\r\nLIBFCOE_FIP_DBG(fip, "unexpected descriptor type %x "\r\n"in FIP probe\n", dtype);\r\nif (dtype < FIP_DT_VENDOR_BASE)\r\nreturn -EINVAL;\r\nbreak;\r\n}\r\ndesc = (struct fip_desc *)((char *)desc + dlen);\r\nrlen -= dlen;\r\n}\r\nreturn 0;\r\nlen_err:\r\nLIBFCOE_FIP_DBG(fip, "FIP length error in descriptor type %x len %zu\n",\r\ndtype, dlen);\r\nreturn -EINVAL;\r\n}\r\nstatic void fcoe_ctlr_vn_send_claim(struct fcoe_ctlr *fip)\r\n{\r\nfcoe_ctlr_vn_send(fip, FIP_SC_VN_CLAIM_NOTIFY, fcoe_all_vn2vn, 0);\r\nfip->sol_time = jiffies;\r\n}\r\nstatic void fcoe_ctlr_vn_probe_req(struct fcoe_ctlr *fip,\r\nstruct fc_rport_priv *rdata)\r\n{\r\nstruct fcoe_rport *frport = fcoe_ctlr_rport(rdata);\r\nif (rdata->ids.port_id != fip->port_id)\r\nreturn;\r\nswitch (fip->state) {\r\ncase FIP_ST_VNMP_CLAIM:\r\ncase FIP_ST_VNMP_UP:\r\nfcoe_ctlr_vn_send(fip, FIP_SC_VN_PROBE_REP,\r\nfrport->enode_mac, 0);\r\nbreak;\r\ncase FIP_ST_VNMP_PROBE1:\r\ncase FIP_ST_VNMP_PROBE2:\r\nif (fip->lp->wwpn > rdata->ids.port_name &&\r\n!(frport->flags & FIP_FL_REC_OR_P2P)) {\r\nfcoe_ctlr_vn_send(fip, FIP_SC_VN_PROBE_REP,\r\nfrport->enode_mac, 0);\r\nbreak;\r\n}\r\ncase FIP_ST_VNMP_START:\r\nfcoe_ctlr_vn_restart(fip);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nstatic void fcoe_ctlr_vn_probe_reply(struct fcoe_ctlr *fip,\r\nstruct fc_rport_priv *rdata)\r\n{\r\nif (rdata->ids.port_id != fip->port_id)\r\nreturn;\r\nswitch (fip->state) {\r\ncase FIP_ST_VNMP_START:\r\ncase FIP_ST_VNMP_PROBE1:\r\ncase FIP_ST_VNMP_PROBE2:\r\ncase FIP_ST_VNMP_CLAIM:\r\nfcoe_ctlr_vn_restart(fip);\r\nbreak;\r\ncase FIP_ST_VNMP_UP:\r\nfcoe_ctlr_vn_send_claim(fip);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nstatic void fcoe_ctlr_vn_add(struct fcoe_ctlr *fip, struct fc_rport_priv *new)\r\n{\r\nstruct fc_lport *lport = fip->lp;\r\nstruct fc_rport_priv *rdata;\r\nstruct fc_rport_identifiers *ids;\r\nstruct fcoe_rport *frport;\r\nu32 port_id;\r\nport_id = new->ids.port_id;\r\nif (port_id == fip->port_id)\r\nreturn;\r\nmutex_lock(&lport->disc.disc_mutex);\r\nrdata = lport->tt.rport_create(lport, port_id);\r\nif (!rdata) {\r\nmutex_unlock(&lport->disc.disc_mutex);\r\nreturn;\r\n}\r\nrdata->ops = &fcoe_ctlr_vn_rport_ops;\r\nrdata->disc_id = lport->disc.disc_id;\r\nids = &rdata->ids;\r\nif ((ids->port_name != -1 && ids->port_name != new->ids.port_name) ||\r\n(ids->node_name != -1 && ids->node_name != new->ids.node_name))\r\nlport->tt.rport_logoff(rdata);\r\nids->port_name = new->ids.port_name;\r\nids->node_name = new->ids.node_name;\r\nmutex_unlock(&lport->disc.disc_mutex);\r\nfrport = fcoe_ctlr_rport(rdata);\r\nLIBFCOE_FIP_DBG(fip, "vn_add rport %6.6x %s\n",\r\nport_id, frport->fcoe_len ? "old" : "new");\r\n*frport = *fcoe_ctlr_rport(new);\r\nfrport->time = 0;\r\n}\r\nstatic int fcoe_ctlr_vn_lookup(struct fcoe_ctlr *fip, u32 port_id, u8 *mac)\r\n{\r\nstruct fc_lport *lport = fip->lp;\r\nstruct fc_rport_priv *rdata;\r\nstruct fcoe_rport *frport;\r\nint ret = -1;\r\nrcu_read_lock();\r\nrdata = lport->tt.rport_lookup(lport, port_id);\r\nif (rdata) {\r\nfrport = fcoe_ctlr_rport(rdata);\r\nmemcpy(mac, frport->enode_mac, ETH_ALEN);\r\nret = 0;\r\n}\r\nrcu_read_unlock();\r\nreturn ret;\r\n}\r\nstatic void fcoe_ctlr_vn_claim_notify(struct fcoe_ctlr *fip,\r\nstruct fc_rport_priv *new)\r\n{\r\nstruct fcoe_rport *frport = fcoe_ctlr_rport(new);\r\nif (frport->flags & FIP_FL_REC_OR_P2P) {\r\nfcoe_ctlr_vn_send(fip, FIP_SC_VN_PROBE_REQ, fcoe_all_vn2vn, 0);\r\nreturn;\r\n}\r\nswitch (fip->state) {\r\ncase FIP_ST_VNMP_START:\r\ncase FIP_ST_VNMP_PROBE1:\r\ncase FIP_ST_VNMP_PROBE2:\r\nif (new->ids.port_id == fip->port_id)\r\nfcoe_ctlr_vn_restart(fip);\r\nbreak;\r\ncase FIP_ST_VNMP_CLAIM:\r\ncase FIP_ST_VNMP_UP:\r\nif (new->ids.port_id == fip->port_id) {\r\nif (new->ids.port_name > fip->lp->wwpn) {\r\nfcoe_ctlr_vn_restart(fip);\r\nbreak;\r\n}\r\nfcoe_ctlr_vn_send_claim(fip);\r\nbreak;\r\n}\r\nfcoe_ctlr_vn_send(fip, FIP_SC_VN_CLAIM_REP, frport->enode_mac,\r\nmin((u32)frport->fcoe_len,\r\nfcoe_ctlr_fcoe_size(fip)));\r\nfcoe_ctlr_vn_add(fip, new);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nstatic void fcoe_ctlr_vn_claim_resp(struct fcoe_ctlr *fip,\r\nstruct fc_rport_priv *new)\r\n{\r\nLIBFCOE_FIP_DBG(fip, "claim resp from from rport %x - state %s\n",\r\nnew->ids.port_id, fcoe_ctlr_state(fip->state));\r\nif (fip->state == FIP_ST_VNMP_UP || fip->state == FIP_ST_VNMP_CLAIM)\r\nfcoe_ctlr_vn_add(fip, new);\r\n}\r\nstatic void fcoe_ctlr_vn_beacon(struct fcoe_ctlr *fip,\r\nstruct fc_rport_priv *new)\r\n{\r\nstruct fc_lport *lport = fip->lp;\r\nstruct fc_rport_priv *rdata;\r\nstruct fcoe_rport *frport;\r\nfrport = fcoe_ctlr_rport(new);\r\nif (frport->flags & FIP_FL_REC_OR_P2P) {\r\nfcoe_ctlr_vn_send(fip, FIP_SC_VN_PROBE_REQ, fcoe_all_vn2vn, 0);\r\nreturn;\r\n}\r\nmutex_lock(&lport->disc.disc_mutex);\r\nrdata = lport->tt.rport_lookup(lport, new->ids.port_id);\r\nif (rdata)\r\nkref_get(&rdata->kref);\r\nmutex_unlock(&lport->disc.disc_mutex);\r\nif (rdata) {\r\nif (rdata->ids.node_name == new->ids.node_name &&\r\nrdata->ids.port_name == new->ids.port_name) {\r\nfrport = fcoe_ctlr_rport(rdata);\r\nif (!frport->time && fip->state == FIP_ST_VNMP_UP)\r\nlport->tt.rport_login(rdata);\r\nfrport->time = jiffies;\r\n}\r\nkref_put(&rdata->kref, lport->tt.rport_destroy);\r\nreturn;\r\n}\r\nif (fip->state != FIP_ST_VNMP_UP)\r\nreturn;\r\nLIBFCOE_FIP_DBG(fip, "beacon from new rport %x. sending claim notify\n",\r\nnew->ids.port_id);\r\nif (time_after(jiffies,\r\nfip->sol_time + msecs_to_jiffies(FIP_VN_ANN_WAIT)))\r\nfcoe_ctlr_vn_send_claim(fip);\r\n}\r\nstatic unsigned long fcoe_ctlr_vn_age(struct fcoe_ctlr *fip)\r\n{\r\nstruct fc_lport *lport = fip->lp;\r\nstruct fc_rport_priv *rdata;\r\nstruct fcoe_rport *frport;\r\nunsigned long next_time;\r\nunsigned long deadline;\r\nnext_time = jiffies + msecs_to_jiffies(FIP_VN_BEACON_INT * 10);\r\nmutex_lock(&lport->disc.disc_mutex);\r\nlist_for_each_entry_rcu(rdata, &lport->disc.rports, peers) {\r\nfrport = fcoe_ctlr_rport(rdata);\r\nif (!frport->time)\r\ncontinue;\r\ndeadline = frport->time +\r\nmsecs_to_jiffies(FIP_VN_BEACON_INT * 25 / 10);\r\nif (time_after_eq(jiffies, deadline)) {\r\nfrport->time = 0;\r\nLIBFCOE_FIP_DBG(fip,\r\n"port %16.16llx fc_id %6.6x beacon expired\n",\r\nrdata->ids.port_name, rdata->ids.port_id);\r\nlport->tt.rport_logoff(rdata);\r\n} else if (time_before(deadline, next_time))\r\nnext_time = deadline;\r\n}\r\nmutex_unlock(&lport->disc.disc_mutex);\r\nreturn next_time;\r\n}\r\nstatic int fcoe_ctlr_vn_recv(struct fcoe_ctlr *fip, struct sk_buff *skb)\r\n{\r\nstruct fip_header *fiph;\r\nenum fip_vn2vn_subcode sub;\r\nstruct {\r\nstruct fc_rport_priv rdata;\r\nstruct fcoe_rport frport;\r\n} buf;\r\nint rc;\r\nfiph = (struct fip_header *)skb->data;\r\nsub = fiph->fip_subcode;\r\nrc = fcoe_ctlr_vn_parse(fip, skb, &buf.rdata);\r\nif (rc) {\r\nLIBFCOE_FIP_DBG(fip, "vn_recv vn_parse error %d\n", rc);\r\ngoto drop;\r\n}\r\nmutex_lock(&fip->ctlr_mutex);\r\nswitch (sub) {\r\ncase FIP_SC_VN_PROBE_REQ:\r\nfcoe_ctlr_vn_probe_req(fip, &buf.rdata);\r\nbreak;\r\ncase FIP_SC_VN_PROBE_REP:\r\nfcoe_ctlr_vn_probe_reply(fip, &buf.rdata);\r\nbreak;\r\ncase FIP_SC_VN_CLAIM_NOTIFY:\r\nfcoe_ctlr_vn_claim_notify(fip, &buf.rdata);\r\nbreak;\r\ncase FIP_SC_VN_CLAIM_REP:\r\nfcoe_ctlr_vn_claim_resp(fip, &buf.rdata);\r\nbreak;\r\ncase FIP_SC_VN_BEACON:\r\nfcoe_ctlr_vn_beacon(fip, &buf.rdata);\r\nbreak;\r\ndefault:\r\nLIBFCOE_FIP_DBG(fip, "vn_recv unknown subcode %d\n", sub);\r\nrc = -1;\r\nbreak;\r\n}\r\nmutex_unlock(&fip->ctlr_mutex);\r\ndrop:\r\nkfree_skb(skb);\r\nreturn rc;\r\n}\r\nstatic void fcoe_ctlr_disc_recv(struct fc_lport *lport, struct fc_frame *fp)\r\n{\r\nstruct fc_seq_els_data rjt_data;\r\nrjt_data.reason = ELS_RJT_UNSUP;\r\nrjt_data.explan = ELS_EXPL_NONE;\r\nlport->tt.seq_els_rsp_send(fp, ELS_LS_RJT, &rjt_data);\r\nfc_frame_free(fp);\r\n}\r\nstatic void fcoe_ctlr_disc_start(void (*callback)(struct fc_lport *,\r\nenum fc_disc_event),\r\nstruct fc_lport *lport)\r\n{\r\nstruct fc_disc *disc = &lport->disc;\r\nstruct fcoe_ctlr *fip = disc->priv;\r\nmutex_lock(&disc->disc_mutex);\r\ndisc->disc_callback = callback;\r\ndisc->disc_id = (disc->disc_id + 2) | 1;\r\ndisc->pending = 1;\r\nschedule_work(&fip->timer_work);\r\nmutex_unlock(&disc->disc_mutex);\r\n}\r\nstatic void fcoe_ctlr_vn_disc(struct fcoe_ctlr *fip)\r\n{\r\nstruct fc_lport *lport = fip->lp;\r\nstruct fc_disc *disc = &lport->disc;\r\nstruct fc_rport_priv *rdata;\r\nstruct fcoe_rport *frport;\r\nvoid (*callback)(struct fc_lport *, enum fc_disc_event);\r\nmutex_lock(&disc->disc_mutex);\r\ncallback = disc->pending ? disc->disc_callback : NULL;\r\ndisc->pending = 0;\r\nlist_for_each_entry_rcu(rdata, &disc->rports, peers) {\r\nfrport = fcoe_ctlr_rport(rdata);\r\nif (frport->time)\r\nlport->tt.rport_login(rdata);\r\n}\r\nmutex_unlock(&disc->disc_mutex);\r\nif (callback)\r\ncallback(lport, DISC_EV_SUCCESS);\r\n}\r\nstatic void fcoe_ctlr_vn_timeout(struct fcoe_ctlr *fip)\r\n{\r\nunsigned long next_time;\r\nu8 mac[ETH_ALEN];\r\nu32 new_port_id = 0;\r\nmutex_lock(&fip->ctlr_mutex);\r\nswitch (fip->state) {\r\ncase FIP_ST_VNMP_START:\r\nfcoe_ctlr_set_state(fip, FIP_ST_VNMP_PROBE1);\r\nfcoe_ctlr_vn_send(fip, FIP_SC_VN_PROBE_REQ, fcoe_all_vn2vn, 0);\r\nnext_time = jiffies + msecs_to_jiffies(FIP_VN_PROBE_WAIT);\r\nbreak;\r\ncase FIP_ST_VNMP_PROBE1:\r\nfcoe_ctlr_set_state(fip, FIP_ST_VNMP_PROBE2);\r\nfcoe_ctlr_vn_send(fip, FIP_SC_VN_PROBE_REQ, fcoe_all_vn2vn, 0);\r\nnext_time = jiffies + msecs_to_jiffies(FIP_VN_ANN_WAIT);\r\nbreak;\r\ncase FIP_ST_VNMP_PROBE2:\r\nfcoe_ctlr_set_state(fip, FIP_ST_VNMP_CLAIM);\r\nnew_port_id = fip->port_id;\r\nhton24(mac, FIP_VN_FC_MAP);\r\nhton24(mac + 3, new_port_id);\r\nfcoe_ctlr_map_dest(fip);\r\nfip->update_mac(fip->lp, mac);\r\nfcoe_ctlr_vn_send_claim(fip);\r\nnext_time = jiffies + msecs_to_jiffies(FIP_VN_ANN_WAIT);\r\nbreak;\r\ncase FIP_ST_VNMP_CLAIM:\r\nnext_time = fip->sol_time + msecs_to_jiffies(FIP_VN_ANN_WAIT);\r\nif (time_after_eq(jiffies, next_time)) {\r\nfcoe_ctlr_set_state(fip, FIP_ST_VNMP_UP);\r\nfcoe_ctlr_vn_send(fip, FIP_SC_VN_BEACON,\r\nfcoe_all_vn2vn, 0);\r\nnext_time = jiffies + msecs_to_jiffies(FIP_VN_ANN_WAIT);\r\nfip->port_ka_time = next_time;\r\n}\r\nfcoe_ctlr_vn_disc(fip);\r\nbreak;\r\ncase FIP_ST_VNMP_UP:\r\nnext_time = fcoe_ctlr_vn_age(fip);\r\nif (time_after_eq(jiffies, fip->port_ka_time)) {\r\nfcoe_ctlr_vn_send(fip, FIP_SC_VN_BEACON,\r\nfcoe_all_vn2vn, 0);\r\nfip->port_ka_time = jiffies +\r\nmsecs_to_jiffies(FIP_VN_BEACON_INT +\r\n(prandom_u32() % FIP_VN_BEACON_FUZZ));\r\n}\r\nif (time_before(fip->port_ka_time, next_time))\r\nnext_time = fip->port_ka_time;\r\nbreak;\r\ncase FIP_ST_LINK_WAIT:\r\ngoto unlock;\r\ndefault:\r\nWARN(1, "unexpected state %d\n", fip->state);\r\ngoto unlock;\r\n}\r\nmod_timer(&fip->timer, next_time);\r\nunlock:\r\nmutex_unlock(&fip->ctlr_mutex);\r\nif (new_port_id)\r\nfc_lport_set_local_id(fip->lp, new_port_id);\r\n}\r\nstatic void fcoe_ctlr_mode_set(struct fc_lport *lport, struct fcoe_ctlr *fip,\r\nenum fip_state fip_mode)\r\n{\r\nvoid *priv;\r\nWARN_ON(lport->state != LPORT_ST_RESET &&\r\nlport->state != LPORT_ST_DISABLED);\r\nif (fip_mode == FIP_MODE_VN2VN) {\r\nlport->rport_priv_size = sizeof(struct fcoe_rport);\r\nlport->point_to_multipoint = 1;\r\nlport->tt.disc_recv_req = fcoe_ctlr_disc_recv;\r\nlport->tt.disc_start = fcoe_ctlr_disc_start;\r\nlport->tt.disc_stop = fcoe_ctlr_disc_stop;\r\nlport->tt.disc_stop_final = fcoe_ctlr_disc_stop_final;\r\npriv = fip;\r\n} else {\r\nlport->rport_priv_size = 0;\r\nlport->point_to_multipoint = 0;\r\nlport->tt.disc_recv_req = NULL;\r\nlport->tt.disc_start = NULL;\r\nlport->tt.disc_stop = NULL;\r\nlport->tt.disc_stop_final = NULL;\r\npriv = lport;\r\n}\r\nfc_disc_config(lport, priv);\r\n}\r\nint fcoe_libfc_config(struct fc_lport *lport, struct fcoe_ctlr *fip,\r\nconst struct libfc_function_template *tt, int init_fcp)\r\n{\r\nmemcpy(&lport->tt, tt, sizeof(*tt));\r\nif (init_fcp && fc_fcp_init(lport))\r\nreturn -ENOMEM;\r\nfc_exch_init(lport);\r\nfc_elsct_init(lport);\r\nfc_lport_init(lport);\r\nfc_rport_init(lport);\r\nfc_disc_init(lport);\r\nfcoe_ctlr_mode_set(lport, fip, fip->mode);\r\nreturn 0;\r\n}\r\nvoid fcoe_fcf_get_selected(struct fcoe_fcf_device *fcf_dev)\r\n{\r\nstruct fcoe_ctlr_device *ctlr_dev = fcoe_fcf_dev_to_ctlr_dev(fcf_dev);\r\nstruct fcoe_ctlr *fip = fcoe_ctlr_device_priv(ctlr_dev);\r\nstruct fcoe_fcf *fcf;\r\nmutex_lock(&fip->ctlr_mutex);\r\nmutex_lock(&ctlr_dev->lock);\r\nfcf = fcoe_fcf_device_priv(fcf_dev);\r\nif (fcf)\r\nfcf_dev->selected = (fcf == fip->sel_fcf) ? 1 : 0;\r\nelse\r\nfcf_dev->selected = 0;\r\nmutex_unlock(&ctlr_dev->lock);\r\nmutex_unlock(&fip->ctlr_mutex);\r\n}\r\nvoid fcoe_ctlr_set_fip_mode(struct fcoe_ctlr_device *ctlr_dev)\r\n{\r\nstruct fcoe_ctlr *ctlr = fcoe_ctlr_device_priv(ctlr_dev);\r\nstruct fc_lport *lport = ctlr->lp;\r\nmutex_lock(&ctlr->ctlr_mutex);\r\nswitch (ctlr_dev->mode) {\r\ncase FIP_CONN_TYPE_VN2VN:\r\nctlr->mode = FIP_MODE_VN2VN;\r\nbreak;\r\ncase FIP_CONN_TYPE_FABRIC:\r\ndefault:\r\nctlr->mode = FIP_MODE_FABRIC;\r\nbreak;\r\n}\r\nmutex_unlock(&ctlr->ctlr_mutex);\r\nfcoe_ctlr_mode_set(lport, ctlr, ctlr->mode);\r\n}
