static int check_effect_access(struct ff_device *ff, int effect_id,\r\nstruct file *file)\r\n{\r\nif (effect_id < 0 || effect_id >= ff->max_effects ||\r\n!ff->effect_owners[effect_id])\r\nreturn -EINVAL;\r\nif (file && ff->effect_owners[effect_id] != file)\r\nreturn -EACCES;\r\nreturn 0;\r\n}\r\nstatic inline int check_effects_compatible(struct ff_effect *e1,\r\nstruct ff_effect *e2)\r\n{\r\nreturn e1->type == e2->type &&\r\n(e1->type != FF_PERIODIC ||\r\ne1->u.periodic.waveform == e2->u.periodic.waveform);\r\n}\r\nstatic int compat_effect(struct ff_device *ff, struct ff_effect *effect)\r\n{\r\nint magnitude;\r\nswitch (effect->type) {\r\ncase FF_RUMBLE:\r\nif (!test_bit(FF_PERIODIC, ff->ffbit))\r\nreturn -EINVAL;\r\nmagnitude = effect->u.rumble.strong_magnitude / 3 +\r\neffect->u.rumble.weak_magnitude / 6;\r\neffect->type = FF_PERIODIC;\r\neffect->u.periodic.waveform = FF_SINE;\r\neffect->u.periodic.period = 50;\r\neffect->u.periodic.magnitude = max(magnitude, 0x7fff);\r\neffect->u.periodic.offset = 0;\r\neffect->u.periodic.phase = 0;\r\neffect->u.periodic.envelope.attack_length = 0;\r\neffect->u.periodic.envelope.attack_level = 0;\r\neffect->u.periodic.envelope.fade_length = 0;\r\neffect->u.periodic.envelope.fade_level = 0;\r\nreturn 0;\r\ndefault:\r\nreturn 0;\r\n}\r\n}\r\nint input_ff_upload(struct input_dev *dev, struct ff_effect *effect,\r\nstruct file *file)\r\n{\r\nstruct ff_device *ff = dev->ff;\r\nstruct ff_effect *old;\r\nint ret = 0;\r\nint id;\r\nif (!test_bit(EV_FF, dev->evbit))\r\nreturn -ENOSYS;\r\nif (effect->type < FF_EFFECT_MIN || effect->type > FF_EFFECT_MAX ||\r\n!test_bit(effect->type, dev->ffbit)) {\r\ndev_dbg(&dev->dev, "invalid or not supported effect type in upload\n");\r\nreturn -EINVAL;\r\n}\r\nif (effect->type == FF_PERIODIC &&\r\n(effect->u.periodic.waveform < FF_WAVEFORM_MIN ||\r\neffect->u.periodic.waveform > FF_WAVEFORM_MAX ||\r\n!test_bit(effect->u.periodic.waveform, dev->ffbit))) {\r\ndev_dbg(&dev->dev, "invalid or not supported wave form in upload\n");\r\nreturn -EINVAL;\r\n}\r\nif (!test_bit(effect->type, ff->ffbit)) {\r\nret = compat_effect(ff, effect);\r\nif (ret)\r\nreturn ret;\r\n}\r\nmutex_lock(&ff->mutex);\r\nif (effect->id == -1) {\r\nfor (id = 0; id < ff->max_effects; id++)\r\nif (!ff->effect_owners[id])\r\nbreak;\r\nif (id >= ff->max_effects) {\r\nret = -ENOSPC;\r\ngoto out;\r\n}\r\neffect->id = id;\r\nold = NULL;\r\n} else {\r\nid = effect->id;\r\nret = check_effect_access(ff, id, file);\r\nif (ret)\r\ngoto out;\r\nold = &ff->effects[id];\r\nif (!check_effects_compatible(effect, old)) {\r\nret = -EINVAL;\r\ngoto out;\r\n}\r\n}\r\nret = ff->upload(dev, effect, old);\r\nif (ret)\r\ngoto out;\r\nspin_lock_irq(&dev->event_lock);\r\nff->effects[id] = *effect;\r\nff->effect_owners[id] = file;\r\nspin_unlock_irq(&dev->event_lock);\r\nout:\r\nmutex_unlock(&ff->mutex);\r\nreturn ret;\r\n}\r\nstatic int erase_effect(struct input_dev *dev, int effect_id,\r\nstruct file *file)\r\n{\r\nstruct ff_device *ff = dev->ff;\r\nint error;\r\nerror = check_effect_access(ff, effect_id, file);\r\nif (error)\r\nreturn error;\r\nspin_lock_irq(&dev->event_lock);\r\nff->playback(dev, effect_id, 0);\r\nff->effect_owners[effect_id] = NULL;\r\nspin_unlock_irq(&dev->event_lock);\r\nif (ff->erase) {\r\nerror = ff->erase(dev, effect_id);\r\nif (error) {\r\nspin_lock_irq(&dev->event_lock);\r\nff->effect_owners[effect_id] = file;\r\nspin_unlock_irq(&dev->event_lock);\r\nreturn error;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nint input_ff_erase(struct input_dev *dev, int effect_id, struct file *file)\r\n{\r\nstruct ff_device *ff = dev->ff;\r\nint ret;\r\nif (!test_bit(EV_FF, dev->evbit))\r\nreturn -ENOSYS;\r\nmutex_lock(&ff->mutex);\r\nret = erase_effect(dev, effect_id, file);\r\nmutex_unlock(&ff->mutex);\r\nreturn ret;\r\n}\r\nstatic int flush_effects(struct input_dev *dev, struct file *file)\r\n{\r\nstruct ff_device *ff = dev->ff;\r\nint i;\r\ndev_dbg(&dev->dev, "flushing now\n");\r\nmutex_lock(&ff->mutex);\r\nfor (i = 0; i < ff->max_effects; i++)\r\nerase_effect(dev, i, file);\r\nmutex_unlock(&ff->mutex);\r\nreturn 0;\r\n}\r\nint input_ff_event(struct input_dev *dev, unsigned int type,\r\nunsigned int code, int value)\r\n{\r\nstruct ff_device *ff = dev->ff;\r\nif (type != EV_FF)\r\nreturn 0;\r\nswitch (code) {\r\ncase FF_GAIN:\r\nif (!test_bit(FF_GAIN, dev->ffbit) || value > 0xffffU)\r\nbreak;\r\nff->set_gain(dev, value);\r\nbreak;\r\ncase FF_AUTOCENTER:\r\nif (!test_bit(FF_AUTOCENTER, dev->ffbit) || value > 0xffffU)\r\nbreak;\r\nff->set_autocenter(dev, value);\r\nbreak;\r\ndefault:\r\nif (check_effect_access(ff, code, NULL) == 0)\r\nff->playback(dev, code, value);\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nint input_ff_create(struct input_dev *dev, unsigned int max_effects)\r\n{\r\nstruct ff_device *ff;\r\nsize_t ff_dev_size;\r\nint i;\r\nif (!max_effects) {\r\ndev_err(&dev->dev, "cannot allocate device without any effects\n");\r\nreturn -EINVAL;\r\n}\r\nif (max_effects > FF_MAX_EFFECTS) {\r\ndev_err(&dev->dev, "cannot allocate more than FF_MAX_EFFECTS effects\n");\r\nreturn -EINVAL;\r\n}\r\nff_dev_size = sizeof(struct ff_device) +\r\nmax_effects * sizeof(struct file *);\r\nif (ff_dev_size < max_effects)\r\nreturn -EINVAL;\r\nff = kzalloc(ff_dev_size, GFP_KERNEL);\r\nif (!ff)\r\nreturn -ENOMEM;\r\nff->effects = kcalloc(max_effects, sizeof(struct ff_effect),\r\nGFP_KERNEL);\r\nif (!ff->effects) {\r\nkfree(ff);\r\nreturn -ENOMEM;\r\n}\r\nff->max_effects = max_effects;\r\nmutex_init(&ff->mutex);\r\ndev->ff = ff;\r\ndev->flush = flush_effects;\r\ndev->event = input_ff_event;\r\n__set_bit(EV_FF, dev->evbit);\r\nfor_each_set_bit(i, dev->ffbit, FF_CNT)\r\n__set_bit(i, ff->ffbit);\r\nif (test_bit(FF_PERIODIC, ff->ffbit))\r\n__set_bit(FF_RUMBLE, dev->ffbit);\r\nreturn 0;\r\n}\r\nvoid input_ff_destroy(struct input_dev *dev)\r\n{\r\nstruct ff_device *ff = dev->ff;\r\n__clear_bit(EV_FF, dev->evbit);\r\nif (ff) {\r\nif (ff->destroy)\r\nff->destroy(ff);\r\nkfree(ff->private);\r\nkfree(ff->effects);\r\nkfree(ff);\r\ndev->ff = NULL;\r\n}\r\n}
