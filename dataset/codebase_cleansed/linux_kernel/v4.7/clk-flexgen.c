static int flexgen_enable(struct clk_hw *hw)\r\n{\r\nstruct flexgen *flexgen = to_flexgen(hw);\r\nstruct clk_hw *pgate_hw = &flexgen->pgate.hw;\r\nstruct clk_hw *fgate_hw = &flexgen->fgate.hw;\r\n__clk_hw_set_clk(pgate_hw, hw);\r\n__clk_hw_set_clk(fgate_hw, hw);\r\nclk_gate_ops.enable(pgate_hw);\r\nclk_gate_ops.enable(fgate_hw);\r\npr_debug("%s: flexgen output enabled\n", clk_hw_get_name(hw));\r\nreturn 0;\r\n}\r\nstatic void flexgen_disable(struct clk_hw *hw)\r\n{\r\nstruct flexgen *flexgen = to_flexgen(hw);\r\nstruct clk_hw *fgate_hw = &flexgen->fgate.hw;\r\n__clk_hw_set_clk(fgate_hw, hw);\r\nclk_gate_ops.disable(fgate_hw);\r\npr_debug("%s: flexgen output disabled\n", clk_hw_get_name(hw));\r\n}\r\nstatic int flexgen_is_enabled(struct clk_hw *hw)\r\n{\r\nstruct flexgen *flexgen = to_flexgen(hw);\r\nstruct clk_hw *fgate_hw = &flexgen->fgate.hw;\r\n__clk_hw_set_clk(fgate_hw, hw);\r\nif (!clk_gate_ops.is_enabled(fgate_hw))\r\nreturn 0;\r\nreturn 1;\r\n}\r\nstatic u8 flexgen_get_parent(struct clk_hw *hw)\r\n{\r\nstruct flexgen *flexgen = to_flexgen(hw);\r\nstruct clk_hw *mux_hw = &flexgen->mux.hw;\r\n__clk_hw_set_clk(mux_hw, hw);\r\nreturn clk_mux_ops.get_parent(mux_hw);\r\n}\r\nstatic int flexgen_set_parent(struct clk_hw *hw, u8 index)\r\n{\r\nstruct flexgen *flexgen = to_flexgen(hw);\r\nstruct clk_hw *mux_hw = &flexgen->mux.hw;\r\n__clk_hw_set_clk(mux_hw, hw);\r\nreturn clk_mux_ops.set_parent(mux_hw, index);\r\n}\r\nstatic inline unsigned long\r\nclk_best_div(unsigned long parent_rate, unsigned long rate)\r\n{\r\nreturn parent_rate / rate + ((rate > (2*(parent_rate % rate))) ? 0 : 1);\r\n}\r\nstatic long flexgen_round_rate(struct clk_hw *hw, unsigned long rate,\r\nunsigned long *prate)\r\n{\r\nunsigned long div;\r\ndiv = clk_best_div(*prate, rate);\r\nif (clk_hw_get_flags(hw) & CLK_SET_RATE_PARENT) {\r\n*prate = rate * div;\r\nreturn rate;\r\n}\r\nreturn *prate / div;\r\n}\r\nstatic unsigned long flexgen_recalc_rate(struct clk_hw *hw,\r\nunsigned long parent_rate)\r\n{\r\nstruct flexgen *flexgen = to_flexgen(hw);\r\nstruct clk_hw *pdiv_hw = &flexgen->pdiv.hw;\r\nstruct clk_hw *fdiv_hw = &flexgen->fdiv.hw;\r\nunsigned long mid_rate;\r\n__clk_hw_set_clk(pdiv_hw, hw);\r\n__clk_hw_set_clk(fdiv_hw, hw);\r\nmid_rate = clk_divider_ops.recalc_rate(pdiv_hw, parent_rate);\r\nreturn clk_divider_ops.recalc_rate(fdiv_hw, mid_rate);\r\n}\r\nstatic int flexgen_set_rate(struct clk_hw *hw, unsigned long rate,\r\nunsigned long parent_rate)\r\n{\r\nstruct flexgen *flexgen = to_flexgen(hw);\r\nstruct clk_hw *pdiv_hw = &flexgen->pdiv.hw;\r\nstruct clk_hw *fdiv_hw = &flexgen->fdiv.hw;\r\nunsigned long div = 0;\r\nint ret = 0;\r\n__clk_hw_set_clk(pdiv_hw, hw);\r\n__clk_hw_set_clk(fdiv_hw, hw);\r\ndiv = clk_best_div(parent_rate, rate);\r\nif (div <= 64) {\r\nclk_divider_ops.set_rate(pdiv_hw, parent_rate, parent_rate);\r\nret = clk_divider_ops.set_rate(fdiv_hw, rate, rate * div);\r\n} else {\r\nclk_divider_ops.set_rate(fdiv_hw, parent_rate, parent_rate);\r\nret = clk_divider_ops.set_rate(pdiv_hw, rate, rate * div);\r\n}\r\nreturn ret;\r\n}\r\nstatic struct clk *clk_register_flexgen(const char *name,\r\nconst char **parent_names, u8 num_parents,\r\nvoid __iomem *reg, spinlock_t *lock, u32 idx,\r\nunsigned long flexgen_flags) {\r\nstruct flexgen *fgxbar;\r\nstruct clk *clk;\r\nstruct clk_init_data init;\r\nu32 xbar_shift;\r\nvoid __iomem *xbar_reg, *fdiv_reg;\r\nfgxbar = kzalloc(sizeof(struct flexgen), GFP_KERNEL);\r\nif (!fgxbar)\r\nreturn ERR_PTR(-ENOMEM);\r\ninit.name = name;\r\ninit.ops = &flexgen_ops;\r\ninit.flags = CLK_IS_BASIC | CLK_GET_RATE_NOCACHE | flexgen_flags;\r\ninit.parent_names = parent_names;\r\ninit.num_parents = num_parents;\r\nxbar_reg = reg + 0x18 + (idx & ~0x3);\r\nxbar_shift = (idx % 4) * 0x8;\r\nfdiv_reg = reg + 0x164 + idx * 4;\r\nfgxbar->mux.lock = lock;\r\nfgxbar->mux.mask = BIT(6) - 1;\r\nfgxbar->mux.reg = xbar_reg;\r\nfgxbar->mux.shift = xbar_shift;\r\nfgxbar->mux.table = NULL;\r\nfgxbar->pgate.lock = lock;\r\nfgxbar->pgate.reg = xbar_reg;\r\nfgxbar->pgate.bit_idx = xbar_shift + 6;\r\nfgxbar->pdiv.lock = lock;\r\nfgxbar->pdiv.reg = reg + 0x58 + idx * 4;\r\nfgxbar->pdiv.width = 10;\r\nfgxbar->fgate.lock = lock;\r\nfgxbar->fgate.reg = fdiv_reg;\r\nfgxbar->fgate.bit_idx = 6;\r\nfgxbar->fdiv.lock = lock;\r\nfgxbar->fdiv.reg = fdiv_reg;\r\nfgxbar->fdiv.width = 6;\r\nfgxbar->hw.init = &init;\r\nclk = clk_register(NULL, &fgxbar->hw);\r\nif (IS_ERR(clk))\r\nkfree(fgxbar);\r\nelse\r\npr_debug("%s: parent %s rate %u\n",\r\n__clk_get_name(clk),\r\n__clk_get_name(clk_get_parent(clk)),\r\n(unsigned int)clk_get_rate(clk));\r\nreturn clk;\r\n}\r\nstatic const char ** __init flexgen_get_parents(struct device_node *np,\r\nint *num_parents)\r\n{\r\nconst char **parents;\r\nunsigned int nparents;\r\nnparents = of_clk_get_parent_count(np);\r\nif (WARN_ON(!nparents))\r\nreturn NULL;\r\nparents = kcalloc(nparents, sizeof(const char *), GFP_KERNEL);\r\nif (!parents)\r\nreturn NULL;\r\n*num_parents = of_clk_parent_fill(np, parents, nparents);\r\nreturn parents;\r\n}\r\nstatic void __init st_of_flexgen_setup(struct device_node *np)\r\n{\r\nstruct device_node *pnode;\r\nvoid __iomem *reg;\r\nstruct clk_onecell_data *clk_data;\r\nconst char **parents;\r\nint num_parents, i;\r\nspinlock_t *rlock = NULL;\r\nunsigned long flex_flags = 0;\r\nint ret;\r\npnode = of_get_parent(np);\r\nif (!pnode)\r\nreturn;\r\nreg = of_iomap(pnode, 0);\r\nif (!reg)\r\nreturn;\r\nparents = flexgen_get_parents(np, &num_parents);\r\nif (!parents)\r\nreturn;\r\nclk_data = kzalloc(sizeof(*clk_data), GFP_KERNEL);\r\nif (!clk_data)\r\ngoto err;\r\nret = of_property_count_strings(np, "clock-output-names");\r\nif (ret <= 0) {\r\npr_err("%s: Failed to get number of output clocks (%d)",\r\n__func__, clk_data->clk_num);\r\ngoto err;\r\n}\r\nclk_data->clk_num = ret;\r\nclk_data->clks = kcalloc(clk_data->clk_num, sizeof(struct clk *),\r\nGFP_KERNEL);\r\nif (!clk_data->clks)\r\ngoto err;\r\nrlock = kzalloc(sizeof(spinlock_t), GFP_KERNEL);\r\nif (!rlock)\r\ngoto err;\r\nspin_lock_init(rlock);\r\nfor (i = 0; i < clk_data->clk_num; i++) {\r\nstruct clk *clk;\r\nconst char *clk_name;\r\nif (of_property_read_string_index(np, "clock-output-names",\r\ni, &clk_name)) {\r\nbreak;\r\n}\r\nif (*clk_name == '\0')\r\ncontinue;\r\nclk = clk_register_flexgen(clk_name, parents, num_parents,\r\nreg, rlock, i, flex_flags);\r\nif (IS_ERR(clk))\r\ngoto err;\r\nclk_data->clks[i] = clk;\r\n}\r\nkfree(parents);\r\nof_clk_add_provider(np, of_clk_src_onecell_get, clk_data);\r\nreturn;\r\nerr:\r\nif (clk_data)\r\nkfree(clk_data->clks);\r\nkfree(clk_data);\r\nkfree(parents);\r\nkfree(rlock);\r\n}
