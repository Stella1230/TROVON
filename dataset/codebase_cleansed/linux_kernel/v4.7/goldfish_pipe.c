static u32 goldfish_cmd_status(struct goldfish_pipe *pipe, u32 cmd)\r\n{\r\nunsigned long flags;\r\nu32 status;\r\nstruct goldfish_pipe_dev *dev = pipe->dev;\r\nspin_lock_irqsave(&dev->lock, flags);\r\ngf_write_ptr(pipe, dev->base + PIPE_REG_CHANNEL,\r\ndev->base + PIPE_REG_CHANNEL_HIGH);\r\nwritel(cmd, dev->base + PIPE_REG_COMMAND);\r\nstatus = readl(dev->base + PIPE_REG_STATUS);\r\nspin_unlock_irqrestore(&dev->lock, flags);\r\nreturn status;\r\n}\r\nstatic void goldfish_cmd(struct goldfish_pipe *pipe, u32 cmd)\r\n{\r\nunsigned long flags;\r\nstruct goldfish_pipe_dev *dev = pipe->dev;\r\nspin_lock_irqsave(&dev->lock, flags);\r\ngf_write_ptr(pipe, dev->base + PIPE_REG_CHANNEL,\r\ndev->base + PIPE_REG_CHANNEL_HIGH);\r\nwritel(cmd, dev->base + PIPE_REG_COMMAND);\r\nspin_unlock_irqrestore(&dev->lock, flags);\r\n}\r\nstatic int goldfish_pipe_error_convert(int status)\r\n{\r\nswitch (status) {\r\ncase PIPE_ERROR_AGAIN:\r\nreturn -EAGAIN;\r\ncase PIPE_ERROR_NOMEM:\r\nreturn -ENOMEM;\r\ncase PIPE_ERROR_IO:\r\nreturn -EIO;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\n}\r\nstatic int valid_batchbuffer_addr(struct goldfish_pipe_dev *dev,\r\nstruct access_params *aps)\r\n{\r\nu32 aph, apl;\r\nu64 paddr;\r\naph = readl(dev->base + PIPE_REG_PARAMS_ADDR_HIGH);\r\napl = readl(dev->base + PIPE_REG_PARAMS_ADDR_LOW);\r\npaddr = ((u64)aph << 32) | apl;\r\nif (paddr != (__pa(aps)))\r\nreturn 0;\r\nreturn 1;\r\n}\r\nstatic int setup_access_params_addr(struct platform_device *pdev,\r\nstruct goldfish_pipe_dev *dev)\r\n{\r\ndma_addr_t dma_handle;\r\nstruct access_params *aps;\r\naps = dmam_alloc_coherent(&pdev->dev, sizeof(struct access_params),\r\n&dma_handle, GFP_KERNEL);\r\nif (!aps)\r\nreturn -ENOMEM;\r\nwritel(upper_32_bits(dma_handle), dev->base + PIPE_REG_PARAMS_ADDR_HIGH);\r\nwritel(lower_32_bits(dma_handle), dev->base + PIPE_REG_PARAMS_ADDR_LOW);\r\nif (valid_batchbuffer_addr(dev, aps)) {\r\ndev->aps = aps;\r\nreturn 0;\r\n} else\r\nreturn -1;\r\n}\r\nstatic int access_with_param(struct goldfish_pipe_dev *dev, const int cmd,\r\nunsigned long address, unsigned long avail,\r\nstruct goldfish_pipe *pipe, int *status)\r\n{\r\nstruct access_params *aps = dev->aps;\r\nif (aps == NULL)\r\nreturn -1;\r\naps->result = INITIAL_BATCH_RESULT;\r\naps->channel = (unsigned long)pipe;\r\naps->size = avail;\r\naps->address = address;\r\naps->cmd = cmd;\r\nwritel(cmd, dev->base + PIPE_REG_ACCESS_PARAMS);\r\nif (aps->result == INITIAL_BATCH_RESULT)\r\nreturn -1;\r\n*status = aps->result;\r\nreturn 0;\r\n}\r\nstatic ssize_t goldfish_pipe_read_write(struct file *filp, char __user *buffer,\r\nsize_t bufflen, int is_write)\r\n{\r\nunsigned long irq_flags;\r\nstruct goldfish_pipe *pipe = filp->private_data;\r\nstruct goldfish_pipe_dev *dev = pipe->dev;\r\nunsigned long address, address_end;\r\nint count = 0, ret = -EINVAL;\r\nif (test_bit(BIT_CLOSED_ON_HOST, &pipe->flags))\r\nreturn -EIO;\r\nif (unlikely(bufflen == 0))\r\nreturn 0;\r\nif (!access_ok(is_write ? VERIFY_WRITE : VERIFY_READ,\r\nbuffer, bufflen))\r\nreturn -EFAULT;\r\nif (mutex_lock_interruptible(&pipe->lock))\r\nreturn -ERESTARTSYS;\r\naddress = (unsigned long)(void *)buffer;\r\naddress_end = address + bufflen;\r\nwhile (address < address_end) {\r\nunsigned long page_end = (address & PAGE_MASK) + PAGE_SIZE;\r\nunsigned long next = page_end < address_end ? page_end\r\n: address_end;\r\nunsigned long avail = next - address;\r\nint status, wakeBit;\r\nstruct page *page;\r\nunsigned long xaddr;\r\ndown_read(&current->mm->mmap_sem);\r\nret = get_user_pages(address, 1, !is_write, 0, &page, NULL);\r\nup_read(&current->mm->mmap_sem);\r\nif (ret < 0)\r\nbreak;\r\nif (dev->version) {\r\nxaddr = page_to_phys(page) | (address & ~PAGE_MASK);\r\n} else {\r\nxaddr = address;\r\n}\r\nspin_lock_irqsave(&dev->lock, irq_flags);\r\nif (access_with_param(dev,\r\nis_write ? CMD_WRITE_BUFFER : CMD_READ_BUFFER,\r\nxaddr, avail, pipe, &status)) {\r\ngf_write_ptr(pipe, dev->base + PIPE_REG_CHANNEL,\r\ndev->base + PIPE_REG_CHANNEL_HIGH);\r\nwritel(avail, dev->base + PIPE_REG_SIZE);\r\ngf_write_ptr((void *)xaddr,\r\ndev->base + PIPE_REG_ADDRESS,\r\ndev->base + PIPE_REG_ADDRESS_HIGH);\r\nwritel(is_write ? CMD_WRITE_BUFFER : CMD_READ_BUFFER,\r\ndev->base + PIPE_REG_COMMAND);\r\nstatus = readl(dev->base + PIPE_REG_STATUS);\r\n}\r\nspin_unlock_irqrestore(&dev->lock, irq_flags);\r\nif (status > 0 && !is_write)\r\nset_page_dirty(page);\r\nput_page(page);\r\nif (status > 0) {\r\ncount += status;\r\naddress += status;\r\ncontinue;\r\n} else if (status == 0) {\r\nret = 0;\r\nbreak;\r\n} else if (status < 0 && count > 0) {\r\nif (status != PIPE_ERROR_AGAIN)\r\npr_info_ratelimited("goldfish_pipe: backend returned error %d on %s\n",\r\nstatus, is_write ? "write" : "read");\r\nret = 0;\r\nbreak;\r\n}\r\nif (status != PIPE_ERROR_AGAIN ||\r\n(filp->f_flags & O_NONBLOCK) != 0) {\r\nret = goldfish_pipe_error_convert(status);\r\nbreak;\r\n}\r\nwakeBit = is_write ? BIT_WAKE_ON_WRITE : BIT_WAKE_ON_READ;\r\nset_bit(wakeBit, &pipe->flags);\r\ngoldfish_cmd(pipe,\r\nis_write ? CMD_WAKE_ON_WRITE : CMD_WAKE_ON_READ);\r\nmutex_unlock(&pipe->lock);\r\nwhile (test_bit(wakeBit, &pipe->flags)) {\r\nif (wait_event_interruptible(\r\npipe->wake_queue,\r\n!test_bit(wakeBit, &pipe->flags)))\r\nreturn -ERESTARTSYS;\r\nif (test_bit(BIT_CLOSED_ON_HOST, &pipe->flags))\r\nreturn -EIO;\r\n}\r\nif (mutex_lock_interruptible(&pipe->lock))\r\nreturn -ERESTARTSYS;\r\n}\r\nmutex_unlock(&pipe->lock);\r\nif (ret < 0)\r\nreturn ret;\r\nelse\r\nreturn count;\r\n}\r\nstatic ssize_t goldfish_pipe_read(struct file *filp, char __user *buffer,\r\nsize_t bufflen, loff_t *ppos)\r\n{\r\nreturn goldfish_pipe_read_write(filp, buffer, bufflen, 0);\r\n}\r\nstatic ssize_t goldfish_pipe_write(struct file *filp,\r\nconst char __user *buffer, size_t bufflen,\r\nloff_t *ppos)\r\n{\r\nreturn goldfish_pipe_read_write(filp, (char __user *)buffer,\r\nbufflen, 1);\r\n}\r\nstatic unsigned int goldfish_pipe_poll(struct file *filp, poll_table *wait)\r\n{\r\nstruct goldfish_pipe *pipe = filp->private_data;\r\nunsigned int mask = 0;\r\nint status;\r\nmutex_lock(&pipe->lock);\r\npoll_wait(filp, &pipe->wake_queue, wait);\r\nstatus = goldfish_cmd_status(pipe, CMD_POLL);\r\nmutex_unlock(&pipe->lock);\r\nif (status & PIPE_POLL_IN)\r\nmask |= POLLIN | POLLRDNORM;\r\nif (status & PIPE_POLL_OUT)\r\nmask |= POLLOUT | POLLWRNORM;\r\nif (status & PIPE_POLL_HUP)\r\nmask |= POLLHUP;\r\nif (test_bit(BIT_CLOSED_ON_HOST, &pipe->flags))\r\nmask |= POLLERR;\r\nreturn mask;\r\n}\r\nstatic irqreturn_t goldfish_pipe_interrupt(int irq, void *dev_id)\r\n{\r\nstruct goldfish_pipe_dev *dev = dev_id;\r\nunsigned long irq_flags;\r\nint count = 0;\r\nspin_lock_irqsave(&dev->lock, irq_flags);\r\nfor (;;) {\r\nstruct goldfish_pipe *pipe;\r\nunsigned long wakes;\r\nunsigned long channel = 0;\r\n#ifdef CONFIG_64BIT\r\nchannel = (u64)readl(dev->base + PIPE_REG_CHANNEL_HIGH) << 32;\r\nif (channel == 0)\r\nbreak;\r\n#endif\r\nchannel |= readl(dev->base + PIPE_REG_CHANNEL);\r\nif (channel == 0)\r\nbreak;\r\nwakes = readl(dev->base + PIPE_REG_WAKES);\r\npipe = (struct goldfish_pipe *)(ptrdiff_t)channel;\r\nif (wakes & PIPE_WAKE_CLOSED) {\r\nset_bit(BIT_CLOSED_ON_HOST, &pipe->flags);\r\nwakes |= PIPE_WAKE_READ | PIPE_WAKE_WRITE;\r\n}\r\nif (wakes & PIPE_WAKE_READ)\r\nclear_bit(BIT_WAKE_ON_READ, &pipe->flags);\r\nif (wakes & PIPE_WAKE_WRITE)\r\nclear_bit(BIT_WAKE_ON_WRITE, &pipe->flags);\r\nwake_up_interruptible(&pipe->wake_queue);\r\ncount++;\r\n}\r\nspin_unlock_irqrestore(&dev->lock, irq_flags);\r\nreturn (count == 0) ? IRQ_NONE : IRQ_HANDLED;\r\n}\r\nstatic int goldfish_pipe_open(struct inode *inode, struct file *file)\r\n{\r\nstruct goldfish_pipe *pipe;\r\nstruct goldfish_pipe_dev *dev = pipe_dev;\r\nint32_t status;\r\npipe = kzalloc(sizeof(*pipe), GFP_KERNEL);\r\nif (pipe == NULL)\r\nreturn -ENOMEM;\r\npipe->dev = dev;\r\nmutex_init(&pipe->lock);\r\ninit_waitqueue_head(&pipe->wake_queue);\r\nstatus = goldfish_cmd_status(pipe, CMD_OPEN);\r\nif (status < 0) {\r\nkfree(pipe);\r\nreturn status;\r\n}\r\nfile->private_data = pipe;\r\nreturn 0;\r\n}\r\nstatic int goldfish_pipe_release(struct inode *inode, struct file *filp)\r\n{\r\nstruct goldfish_pipe *pipe = filp->private_data;\r\ngoldfish_cmd(pipe, CMD_CLOSE);\r\nkfree(pipe);\r\nfilp->private_data = NULL;\r\nreturn 0;\r\n}\r\nstatic int goldfish_pipe_probe(struct platform_device *pdev)\r\n{\r\nint err;\r\nstruct resource *r;\r\nstruct goldfish_pipe_dev *dev = pipe_dev;\r\nWARN_ON(dev->base != NULL);\r\nspin_lock_init(&dev->lock);\r\nr = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nif (r == NULL || resource_size(r) < PAGE_SIZE) {\r\ndev_err(&pdev->dev, "can't allocate i/o page\n");\r\nreturn -EINVAL;\r\n}\r\ndev->base = devm_ioremap(&pdev->dev, r->start, PAGE_SIZE);\r\nif (dev->base == NULL) {\r\ndev_err(&pdev->dev, "ioremap failed\n");\r\nreturn -EINVAL;\r\n}\r\nr = platform_get_resource(pdev, IORESOURCE_IRQ, 0);\r\nif (r == NULL) {\r\nerr = -EINVAL;\r\ngoto error;\r\n}\r\ndev->irq = r->start;\r\nerr = devm_request_irq(&pdev->dev, dev->irq, goldfish_pipe_interrupt,\r\nIRQF_SHARED, "goldfish_pipe", dev);\r\nif (err) {\r\ndev_err(&pdev->dev, "unable to allocate IRQ\n");\r\ngoto error;\r\n}\r\nerr = misc_register(&goldfish_pipe_device);\r\nif (err) {\r\ndev_err(&pdev->dev, "unable to register device\n");\r\ngoto error;\r\n}\r\nsetup_access_params_addr(pdev, dev);\r\ndev->version = readl(dev->base + PIPE_REG_VERSION);\r\nreturn 0;\r\nerror:\r\ndev->base = NULL;\r\nreturn err;\r\n}\r\nstatic int goldfish_pipe_remove(struct platform_device *pdev)\r\n{\r\nstruct goldfish_pipe_dev *dev = pipe_dev;\r\nmisc_deregister(&goldfish_pipe_device);\r\ndev->base = NULL;\r\nreturn 0;\r\n}
