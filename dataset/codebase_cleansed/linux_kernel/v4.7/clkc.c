struct clk ** __init meson_clk_init(struct device_node *np,\r\nunsigned long nr_clks)\r\n{\r\nclks = kcalloc(nr_clks, sizeof(*clks), GFP_KERNEL);\r\nif (!clks)\r\nreturn ERR_PTR(-ENOMEM);\r\nclk_data.clks = clks;\r\nclk_data.clk_num = nr_clks;\r\nof_clk_add_provider(np, of_clk_src_onecell_get, &clk_data);\r\nreturn clks;\r\n}\r\nstatic void meson_clk_add_lookup(struct clk *clk, unsigned int id)\r\n{\r\nif (clks && id)\r\nclks[id] = clk;\r\n}\r\nstatic struct clk * __init\r\nmeson_clk_register_composite(const struct clk_conf *clk_conf,\r\nvoid __iomem *clk_base)\r\n{\r\nstruct clk *clk;\r\nstruct clk_mux *mux = NULL;\r\nstruct clk_divider *div = NULL;\r\nstruct clk_gate *gate = NULL;\r\nconst struct clk_ops *mux_ops = NULL;\r\nconst struct composite_conf *composite_conf;\r\ncomposite_conf = clk_conf->conf.composite;\r\nif (clk_conf->num_parents > 1) {\r\nmux = kzalloc(sizeof(*mux), GFP_KERNEL);\r\nif (!mux)\r\nreturn ERR_PTR(-ENOMEM);\r\nmux->reg = clk_base + clk_conf->reg_off\r\n+ composite_conf->mux_parm.reg_off;\r\nmux->shift = composite_conf->mux_parm.shift;\r\nmux->mask = BIT(composite_conf->mux_parm.width) - 1;\r\nmux->flags = composite_conf->mux_flags;\r\nmux->lock = &clk_lock;\r\nmux->table = composite_conf->mux_table;\r\nmux_ops = (composite_conf->mux_flags & CLK_MUX_READ_ONLY) ?\r\n&clk_mux_ro_ops : &clk_mux_ops;\r\n}\r\nif (MESON_PARM_APPLICABLE(&composite_conf->div_parm)) {\r\ndiv = kzalloc(sizeof(*div), GFP_KERNEL);\r\nif (!div) {\r\nclk = ERR_PTR(-ENOMEM);\r\ngoto error;\r\n}\r\ndiv->reg = clk_base + clk_conf->reg_off\r\n+ composite_conf->div_parm.reg_off;\r\ndiv->shift = composite_conf->div_parm.shift;\r\ndiv->width = composite_conf->div_parm.width;\r\ndiv->lock = &clk_lock;\r\ndiv->flags = composite_conf->div_flags;\r\ndiv->table = composite_conf->div_table;\r\n}\r\nif (MESON_PARM_APPLICABLE(&composite_conf->gate_parm)) {\r\ngate = kzalloc(sizeof(*gate), GFP_KERNEL);\r\nif (!gate) {\r\nclk = ERR_PTR(-ENOMEM);\r\ngoto error;\r\n}\r\ngate->reg = clk_base + clk_conf->reg_off\r\n+ composite_conf->div_parm.reg_off;\r\ngate->bit_idx = composite_conf->gate_parm.shift;\r\ngate->flags = composite_conf->gate_flags;\r\ngate->lock = &clk_lock;\r\n}\r\nclk = clk_register_composite(NULL, clk_conf->clk_name,\r\nclk_conf->clks_parent,\r\nclk_conf->num_parents,\r\nmux ? &mux->hw : NULL, mux_ops,\r\ndiv ? &div->hw : NULL, &clk_divider_ops,\r\ngate ? &gate->hw : NULL, &clk_gate_ops,\r\nclk_conf->flags);\r\nif (IS_ERR(clk))\r\ngoto error;\r\nreturn clk;\r\nerror:\r\nkfree(gate);\r\nkfree(div);\r\nkfree(mux);\r\nreturn clk;\r\n}\r\nstatic struct clk * __init\r\nmeson_clk_register_fixed_factor(const struct clk_conf *clk_conf,\r\nvoid __iomem *clk_base)\r\n{\r\nstruct clk *clk;\r\nconst struct fixed_fact_conf *fixed_fact_conf;\r\nconst struct parm *p;\r\nunsigned int mult, div;\r\nu32 reg;\r\nfixed_fact_conf = &clk_conf->conf.fixed_fact;\r\nmult = clk_conf->conf.fixed_fact.mult;\r\ndiv = clk_conf->conf.fixed_fact.div;\r\nif (!mult) {\r\nmult = 1;\r\np = &fixed_fact_conf->mult_parm;\r\nif (MESON_PARM_APPLICABLE(p)) {\r\nreg = readl(clk_base + clk_conf->reg_off + p->reg_off);\r\nmult = PARM_GET(p->width, p->shift, reg);\r\n}\r\n}\r\nif (!div) {\r\ndiv = 1;\r\np = &fixed_fact_conf->div_parm;\r\nif (MESON_PARM_APPLICABLE(p)) {\r\nreg = readl(clk_base + clk_conf->reg_off + p->reg_off);\r\nmult = PARM_GET(p->width, p->shift, reg);\r\n}\r\n}\r\nclk = clk_register_fixed_factor(NULL,\r\nclk_conf->clk_name,\r\nclk_conf->clks_parent[0],\r\nclk_conf->flags,\r\nmult, div);\r\nreturn clk;\r\n}\r\nstatic struct clk * __init\r\nmeson_clk_register_fixed_rate(const struct clk_conf *clk_conf,\r\nvoid __iomem *clk_base)\r\n{\r\nstruct clk *clk;\r\nconst struct fixed_rate_conf *fixed_rate_conf;\r\nconst struct parm *r;\r\nunsigned long rate;\r\nu32 reg;\r\nfixed_rate_conf = &clk_conf->conf.fixed_rate;\r\nrate = fixed_rate_conf->rate;\r\nif (!rate) {\r\nr = &fixed_rate_conf->rate_parm;\r\nreg = readl(clk_base + clk_conf->reg_off + r->reg_off);\r\nrate = PARM_GET(r->width, r->shift, reg);\r\n}\r\nrate *= 1000000;\r\nclk = clk_register_fixed_rate(NULL,\r\nclk_conf->clk_name,\r\nclk_conf->num_parents\r\n? clk_conf->clks_parent[0] : NULL,\r\nclk_conf->flags, rate);\r\nreturn clk;\r\n}\r\nvoid __init meson_clk_register_clks(const struct clk_conf *clk_confs,\r\nunsigned int nr_confs,\r\nvoid __iomem *clk_base)\r\n{\r\nunsigned int i;\r\nstruct clk *clk = NULL;\r\nfor (i = 0; i < nr_confs; i++) {\r\nconst struct clk_conf *clk_conf = &clk_confs[i];\r\nswitch (clk_conf->clk_type) {\r\ncase CLK_FIXED_RATE:\r\nclk = meson_clk_register_fixed_rate(clk_conf,\r\nclk_base);\r\nbreak;\r\ncase CLK_FIXED_FACTOR:\r\nclk = meson_clk_register_fixed_factor(clk_conf,\r\nclk_base);\r\nbreak;\r\ncase CLK_COMPOSITE:\r\nclk = meson_clk_register_composite(clk_conf,\r\nclk_base);\r\nbreak;\r\ncase CLK_CPU:\r\nclk = meson_clk_register_cpu(clk_conf, clk_base,\r\n&clk_lock);\r\nbreak;\r\ncase CLK_PLL:\r\nclk = meson_clk_register_pll(clk_conf, clk_base,\r\n&clk_lock);\r\nbreak;\r\ndefault:\r\nclk = NULL;\r\n}\r\nif (!clk) {\r\npr_err("%s: unknown clock type %d\n", __func__,\r\nclk_conf->clk_type);\r\ncontinue;\r\n}\r\nif (IS_ERR(clk)) {\r\npr_warn("%s: Unable to create %s clock\n", __func__,\r\nclk_conf->clk_name);\r\ncontinue;\r\n}\r\nmeson_clk_add_lookup(clk, clk_conf->clk_id);\r\n}\r\n}
