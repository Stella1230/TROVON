static u64 notrace _gt_counter_read(void)\r\n{\r\nu64 counter;\r\nu32 lower;\r\nu32 upper, old_upper;\r\nupper = readl_relaxed(gt_base + GT_COUNTER1);\r\ndo {\r\nold_upper = upper;\r\nlower = readl_relaxed(gt_base + GT_COUNTER0);\r\nupper = readl_relaxed(gt_base + GT_COUNTER1);\r\n} while (upper != old_upper);\r\ncounter = upper;\r\ncounter <<= 32;\r\ncounter |= lower;\r\nreturn counter;\r\n}\r\nstatic u64 gt_counter_read(void)\r\n{\r\nreturn _gt_counter_read();\r\n}\r\nstatic void gt_compare_set(unsigned long delta, int periodic)\r\n{\r\nu64 counter = gt_counter_read();\r\nunsigned long ctrl;\r\ncounter += delta;\r\nctrl = GT_CONTROL_TIMER_ENABLE;\r\nwritel_relaxed(ctrl, gt_base + GT_CONTROL);\r\nwritel_relaxed(lower_32_bits(counter), gt_base + GT_COMP0);\r\nwritel_relaxed(upper_32_bits(counter), gt_base + GT_COMP1);\r\nif (periodic) {\r\nwritel_relaxed(delta, gt_base + GT_AUTO_INC);\r\nctrl |= GT_CONTROL_AUTO_INC;\r\n}\r\nctrl |= GT_CONTROL_COMP_ENABLE | GT_CONTROL_IRQ_ENABLE;\r\nwritel_relaxed(ctrl, gt_base + GT_CONTROL);\r\n}\r\nstatic int gt_clockevent_shutdown(struct clock_event_device *evt)\r\n{\r\nunsigned long ctrl;\r\nctrl = readl(gt_base + GT_CONTROL);\r\nctrl &= ~(GT_CONTROL_COMP_ENABLE | GT_CONTROL_IRQ_ENABLE |\r\nGT_CONTROL_AUTO_INC);\r\nwritel(ctrl, gt_base + GT_CONTROL);\r\nreturn 0;\r\n}\r\nstatic int gt_clockevent_set_periodic(struct clock_event_device *evt)\r\n{\r\ngt_compare_set(DIV_ROUND_CLOSEST(gt_clk_rate, HZ), 1);\r\nreturn 0;\r\n}\r\nstatic int gt_clockevent_set_next_event(unsigned long evt,\r\nstruct clock_event_device *unused)\r\n{\r\ngt_compare_set(evt, 0);\r\nreturn 0;\r\n}\r\nstatic irqreturn_t gt_clockevent_interrupt(int irq, void *dev_id)\r\n{\r\nstruct clock_event_device *evt = dev_id;\r\nif (!(readl_relaxed(gt_base + GT_INT_STATUS) &\r\nGT_INT_STATUS_EVENT_FLAG))\r\nreturn IRQ_NONE;\r\nif (clockevent_state_oneshot(evt))\r\ngt_compare_set(ULONG_MAX, 0);\r\nwritel_relaxed(GT_INT_STATUS_EVENT_FLAG, gt_base + GT_INT_STATUS);\r\nevt->event_handler(evt);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int gt_clockevents_init(struct clock_event_device *clk)\r\n{\r\nint cpu = smp_processor_id();\r\nclk->name = "arm_global_timer";\r\nclk->features = CLOCK_EVT_FEAT_PERIODIC | CLOCK_EVT_FEAT_ONESHOT |\r\nCLOCK_EVT_FEAT_PERCPU;\r\nclk->set_state_shutdown = gt_clockevent_shutdown;\r\nclk->set_state_periodic = gt_clockevent_set_periodic;\r\nclk->set_state_oneshot = gt_clockevent_shutdown;\r\nclk->set_state_oneshot_stopped = gt_clockevent_shutdown;\r\nclk->set_next_event = gt_clockevent_set_next_event;\r\nclk->cpumask = cpumask_of(cpu);\r\nclk->rating = 300;\r\nclk->irq = gt_ppi;\r\nclockevents_config_and_register(clk, gt_clk_rate,\r\n1, 0xffffffff);\r\nenable_percpu_irq(clk->irq, IRQ_TYPE_NONE);\r\nreturn 0;\r\n}\r\nstatic void gt_clockevents_stop(struct clock_event_device *clk)\r\n{\r\ngt_clockevent_shutdown(clk);\r\ndisable_percpu_irq(clk->irq);\r\n}\r\nstatic cycle_t gt_clocksource_read(struct clocksource *cs)\r\n{\r\nreturn gt_counter_read();\r\n}\r\nstatic void gt_resume(struct clocksource *cs)\r\n{\r\nunsigned long ctrl;\r\nctrl = readl(gt_base + GT_CONTROL);\r\nif (!(ctrl & GT_CONTROL_TIMER_ENABLE))\r\nwritel(GT_CONTROL_TIMER_ENABLE, gt_base + GT_CONTROL);\r\n}\r\nstatic u64 notrace gt_sched_clock_read(void)\r\n{\r\nreturn _gt_counter_read();\r\n}\r\nstatic unsigned long gt_read_long(void)\r\n{\r\nreturn readl_relaxed(gt_base + GT_COUNTER0);\r\n}\r\nstatic void __init gt_delay_timer_init(void)\r\n{\r\ngt_delay_timer.freq = gt_clk_rate;\r\nregister_current_timer_delay(&gt_delay_timer);\r\n}\r\nstatic void __init gt_clocksource_init(void)\r\n{\r\nwritel(0, gt_base + GT_CONTROL);\r\nwritel(0, gt_base + GT_COUNTER0);\r\nwritel(0, gt_base + GT_COUNTER1);\r\nwritel(GT_CONTROL_TIMER_ENABLE, gt_base + GT_CONTROL);\r\n#ifdef CONFIG_CLKSRC_ARM_GLOBAL_TIMER_SCHED_CLOCK\r\nsched_clock_register(gt_sched_clock_read, 64, gt_clk_rate);\r\n#endif\r\nclocksource_register_hz(&gt_clocksource, gt_clk_rate);\r\n}\r\nstatic int gt_cpu_notify(struct notifier_block *self, unsigned long action,\r\nvoid *hcpu)\r\n{\r\nswitch (action & ~CPU_TASKS_FROZEN) {\r\ncase CPU_STARTING:\r\ngt_clockevents_init(this_cpu_ptr(gt_evt));\r\nbreak;\r\ncase CPU_DYING:\r\ngt_clockevents_stop(this_cpu_ptr(gt_evt));\r\nbreak;\r\n}\r\nreturn NOTIFY_OK;\r\n}\r\nstatic void __init global_timer_of_register(struct device_node *np)\r\n{\r\nstruct clk *gt_clk;\r\nint err = 0;\r\nif (read_cpuid_part() == ARM_CPU_PART_CORTEX_A9\r\n&& (read_cpuid_id() & 0xf0000f) < 0x200000) {\r\npr_warn("global-timer: non support for this cpu version.\n");\r\nreturn;\r\n}\r\ngt_ppi = irq_of_parse_and_map(np, 0);\r\nif (!gt_ppi) {\r\npr_warn("global-timer: unable to parse irq\n");\r\nreturn;\r\n}\r\ngt_base = of_iomap(np, 0);\r\nif (!gt_base) {\r\npr_warn("global-timer: invalid base address\n");\r\nreturn;\r\n}\r\ngt_clk = of_clk_get(np, 0);\r\nif (!IS_ERR(gt_clk)) {\r\nerr = clk_prepare_enable(gt_clk);\r\nif (err)\r\ngoto out_unmap;\r\n} else {\r\npr_warn("global-timer: clk not found\n");\r\nerr = -EINVAL;\r\ngoto out_unmap;\r\n}\r\ngt_clk_rate = clk_get_rate(gt_clk);\r\ngt_evt = alloc_percpu(struct clock_event_device);\r\nif (!gt_evt) {\r\npr_warn("global-timer: can't allocate memory\n");\r\nerr = -ENOMEM;\r\ngoto out_clk;\r\n}\r\nerr = request_percpu_irq(gt_ppi, gt_clockevent_interrupt,\r\n"gt", gt_evt);\r\nif (err) {\r\npr_warn("global-timer: can't register interrupt %d (%d)\n",\r\ngt_ppi, err);\r\ngoto out_free;\r\n}\r\nerr = register_cpu_notifier(&gt_cpu_nb);\r\nif (err) {\r\npr_warn("global-timer: unable to register cpu notifier.\n");\r\ngoto out_irq;\r\n}\r\ngt_clocksource_init();\r\ngt_clockevents_init(this_cpu_ptr(gt_evt));\r\ngt_delay_timer_init();\r\nreturn;\r\nout_irq:\r\nfree_percpu_irq(gt_ppi, gt_evt);\r\nout_free:\r\nfree_percpu(gt_evt);\r\nout_clk:\r\nclk_disable_unprepare(gt_clk);\r\nout_unmap:\r\niounmap(gt_base);\r\nWARN(err, "ARM Global timer register failed (%d)\n", err);\r\n}
