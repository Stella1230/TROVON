void kvm_mips_queue_irq(struct kvm_vcpu *vcpu, uint32_t priority)\r\n{\r\nset_bit(priority, &vcpu->arch.pending_exceptions);\r\n}\r\nvoid kvm_mips_dequeue_irq(struct kvm_vcpu *vcpu, uint32_t priority)\r\n{\r\nclear_bit(priority, &vcpu->arch.pending_exceptions);\r\n}\r\nvoid kvm_mips_queue_timer_int_cb(struct kvm_vcpu *vcpu)\r\n{\r\nkvm_set_c0_guest_cause(vcpu->arch.cop0, (C_IRQ5 | C_TI));\r\nkvm_mips_queue_irq(vcpu, MIPS_EXC_INT_TIMER);\r\n}\r\nvoid kvm_mips_dequeue_timer_int_cb(struct kvm_vcpu *vcpu)\r\n{\r\nkvm_clear_c0_guest_cause(vcpu->arch.cop0, (C_IRQ5 | C_TI));\r\nkvm_mips_dequeue_irq(vcpu, MIPS_EXC_INT_TIMER);\r\n}\r\nvoid kvm_mips_queue_io_int_cb(struct kvm_vcpu *vcpu,\r\nstruct kvm_mips_interrupt *irq)\r\n{\r\nint intr = (int)irq->irq;\r\nswitch (intr) {\r\ncase 2:\r\nkvm_set_c0_guest_cause(vcpu->arch.cop0, (C_IRQ0));\r\nkvm_mips_queue_irq(vcpu, MIPS_EXC_INT_IO);\r\nbreak;\r\ncase 3:\r\nkvm_set_c0_guest_cause(vcpu->arch.cop0, (C_IRQ1));\r\nkvm_mips_queue_irq(vcpu, MIPS_EXC_INT_IPI_1);\r\nbreak;\r\ncase 4:\r\nkvm_set_c0_guest_cause(vcpu->arch.cop0, (C_IRQ2));\r\nkvm_mips_queue_irq(vcpu, MIPS_EXC_INT_IPI_2);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nvoid kvm_mips_dequeue_io_int_cb(struct kvm_vcpu *vcpu,\r\nstruct kvm_mips_interrupt *irq)\r\n{\r\nint intr = (int)irq->irq;\r\nswitch (intr) {\r\ncase -2:\r\nkvm_clear_c0_guest_cause(vcpu->arch.cop0, (C_IRQ0));\r\nkvm_mips_dequeue_irq(vcpu, MIPS_EXC_INT_IO);\r\nbreak;\r\ncase -3:\r\nkvm_clear_c0_guest_cause(vcpu->arch.cop0, (C_IRQ1));\r\nkvm_mips_dequeue_irq(vcpu, MIPS_EXC_INT_IPI_1);\r\nbreak;\r\ncase -4:\r\nkvm_clear_c0_guest_cause(vcpu->arch.cop0, (C_IRQ2));\r\nkvm_mips_dequeue_irq(vcpu, MIPS_EXC_INT_IPI_2);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nint kvm_mips_irq_deliver_cb(struct kvm_vcpu *vcpu, unsigned int priority,\r\nuint32_t cause)\r\n{\r\nint allowed = 0;\r\nuint32_t exccode;\r\nstruct kvm_vcpu_arch *arch = &vcpu->arch;\r\nstruct mips_coproc *cop0 = vcpu->arch.cop0;\r\nswitch (priority) {\r\ncase MIPS_EXC_INT_TIMER:\r\nif ((kvm_read_c0_guest_status(cop0) & ST0_IE)\r\n&& (!(kvm_read_c0_guest_status(cop0) & (ST0_EXL | ST0_ERL)))\r\n&& (kvm_read_c0_guest_status(cop0) & IE_IRQ5)) {\r\nallowed = 1;\r\nexccode = EXCCODE_INT;\r\n}\r\nbreak;\r\ncase MIPS_EXC_INT_IO:\r\nif ((kvm_read_c0_guest_status(cop0) & ST0_IE)\r\n&& (!(kvm_read_c0_guest_status(cop0) & (ST0_EXL | ST0_ERL)))\r\n&& (kvm_read_c0_guest_status(cop0) & IE_IRQ0)) {\r\nallowed = 1;\r\nexccode = EXCCODE_INT;\r\n}\r\nbreak;\r\ncase MIPS_EXC_INT_IPI_1:\r\nif ((kvm_read_c0_guest_status(cop0) & ST0_IE)\r\n&& (!(kvm_read_c0_guest_status(cop0) & (ST0_EXL | ST0_ERL)))\r\n&& (kvm_read_c0_guest_status(cop0) & IE_IRQ1)) {\r\nallowed = 1;\r\nexccode = EXCCODE_INT;\r\n}\r\nbreak;\r\ncase MIPS_EXC_INT_IPI_2:\r\nif ((kvm_read_c0_guest_status(cop0) & ST0_IE)\r\n&& (!(kvm_read_c0_guest_status(cop0) & (ST0_EXL | ST0_ERL)))\r\n&& (kvm_read_c0_guest_status(cop0) & IE_IRQ2)) {\r\nallowed = 1;\r\nexccode = EXCCODE_INT;\r\n}\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nif (allowed) {\r\nif ((kvm_read_c0_guest_status(cop0) & ST0_EXL) == 0) {\r\nkvm_write_c0_guest_epc(cop0, arch->pc);\r\nkvm_set_c0_guest_status(cop0, ST0_EXL);\r\nif (cause & CAUSEF_BD)\r\nkvm_set_c0_guest_cause(cop0, CAUSEF_BD);\r\nelse\r\nkvm_clear_c0_guest_cause(cop0, CAUSEF_BD);\r\nkvm_debug("Delivering INT @ pc %#lx\n", arch->pc);\r\n} else\r\nkvm_err("Trying to deliver interrupt when EXL is already set\n");\r\nkvm_change_c0_guest_cause(cop0, CAUSEF_EXCCODE,\r\n(exccode << CAUSEB_EXCCODE));\r\nif (kvm_read_c0_guest_cause(cop0) & CAUSEF_IV)\r\narch->pc = KVM_GUEST_KSEG0 + 0x200;\r\nelse\r\narch->pc = KVM_GUEST_KSEG0 + 0x180;\r\nclear_bit(priority, &vcpu->arch.pending_exceptions);\r\n}\r\nreturn allowed;\r\n}\r\nint kvm_mips_irq_clear_cb(struct kvm_vcpu *vcpu, unsigned int priority,\r\nuint32_t cause)\r\n{\r\nreturn 1;\r\n}\r\nvoid kvm_mips_deliver_interrupts(struct kvm_vcpu *vcpu, uint32_t cause)\r\n{\r\nunsigned long *pending = &vcpu->arch.pending_exceptions;\r\nunsigned long *pending_clr = &vcpu->arch.pending_exceptions_clr;\r\nunsigned int priority;\r\nif (!(*pending) && !(*pending_clr))\r\nreturn;\r\npriority = __ffs(*pending_clr);\r\nwhile (priority <= MIPS_EXC_MAX) {\r\nif (kvm_mips_callbacks->irq_clear(vcpu, priority, cause)) {\r\nif (!KVM_MIPS_IRQ_CLEAR_ALL_AT_ONCE)\r\nbreak;\r\n}\r\npriority = find_next_bit(pending_clr,\r\nBITS_PER_BYTE * sizeof(*pending_clr),\r\npriority + 1);\r\n}\r\npriority = __ffs(*pending);\r\nwhile (priority <= MIPS_EXC_MAX) {\r\nif (kvm_mips_callbacks->irq_deliver(vcpu, priority, cause)) {\r\nif (!KVM_MIPS_IRQ_DELIVER_ALL_AT_ONCE)\r\nbreak;\r\n}\r\npriority = find_next_bit(pending,\r\nBITS_PER_BYTE * sizeof(*pending),\r\npriority + 1);\r\n}\r\n}\r\nint kvm_mips_pending_timer(struct kvm_vcpu *vcpu)\r\n{\r\nreturn test_bit(MIPS_EXC_INT_TIMER, &vcpu->arch.pending_exceptions);\r\n}
