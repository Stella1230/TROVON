static s32 lg4ff_adjust_dfp_x_axis(s32 value, u16 range)\r\n{\r\nu16 max_range;\r\ns32 new_value;\r\nif (range == 900)\r\nreturn value;\r\nelse if (range == 200)\r\nreturn value;\r\nelse if (range < 200)\r\nmax_range = 200;\r\nelse\r\nmax_range = 900;\r\nnew_value = 8192 + mult_frac(value - 8192, max_range, range);\r\nif (new_value < 0)\r\nreturn 0;\r\nelse if (new_value > 16383)\r\nreturn 16383;\r\nelse\r\nreturn new_value;\r\n}\r\nint lg4ff_adjust_input_event(struct hid_device *hid, struct hid_field *field,\r\nstruct hid_usage *usage, s32 value, struct lg_drv_data *drv_data)\r\n{\r\nstruct lg4ff_device_entry *entry = drv_data->device_props;\r\ns32 new_value = 0;\r\nif (!entry) {\r\nhid_err(hid, "Device properties not found");\r\nreturn 0;\r\n}\r\nswitch (entry->wdata.product_id) {\r\ncase USB_DEVICE_ID_LOGITECH_DFP_WHEEL:\r\nswitch (usage->code) {\r\ncase ABS_X:\r\nnew_value = lg4ff_adjust_dfp_x_axis(value, entry->wdata.range);\r\ninput_event(field->hidinput->input, usage->type, usage->code, new_value);\r\nreturn 1;\r\ndefault:\r\nreturn 0;\r\n}\r\ndefault:\r\nreturn 0;\r\n}\r\n}\r\nstatic void lg4ff_init_wheel_data(struct lg4ff_wheel_data * const wdata, const struct lg4ff_wheel *wheel,\r\nconst struct lg4ff_multimode_wheel *mmode_wheel,\r\nconst u16 real_product_id)\r\n{\r\nu32 alternate_modes = 0;\r\nconst char *real_tag = NULL;\r\nconst char *real_name = NULL;\r\nif (mmode_wheel) {\r\nalternate_modes = mmode_wheel->alternate_modes;\r\nreal_tag = mmode_wheel->real_tag;\r\nreal_name = mmode_wheel->real_name;\r\n}\r\n{\r\nstruct lg4ff_wheel_data t_wdata = { .product_id = wheel->product_id,\r\n.real_product_id = real_product_id,\r\n.min_range = wheel->min_range,\r\n.max_range = wheel->max_range,\r\n.set_range = wheel->set_range,\r\n.alternate_modes = alternate_modes,\r\n.real_tag = real_tag,\r\n.real_name = real_name };\r\nmemcpy(wdata, &t_wdata, sizeof(t_wdata));\r\n}\r\n}\r\nstatic int lg4ff_play(struct input_dev *dev, void *data, struct ff_effect *effect)\r\n{\r\nstruct hid_device *hid = input_get_drvdata(dev);\r\nstruct lg4ff_device_entry *entry;\r\nstruct lg_drv_data *drv_data;\r\nunsigned long flags;\r\ns32 *value;\r\nint x;\r\ndrv_data = hid_get_drvdata(hid);\r\nif (!drv_data) {\r\nhid_err(hid, "Private driver data not found!\n");\r\nreturn -EINVAL;\r\n}\r\nentry = drv_data->device_props;\r\nif (!entry) {\r\nhid_err(hid, "Device properties not found!\n");\r\nreturn -EINVAL;\r\n}\r\nvalue = entry->report->field[0]->value;\r\n#define CLAMP(x) do { if (x < 0) x = 0; else if (x > 0xff) x = 0xff; } while (0)\r\nswitch (effect->type) {\r\ncase FF_CONSTANT:\r\nx = effect->u.ramp.start_level + 0x80;\r\nCLAMP(x);\r\nspin_lock_irqsave(&entry->report_lock, flags);\r\nif (x == 0x80) {\r\nvalue[0] = 0x13;\r\nvalue[1] = 0x00;\r\nvalue[2] = 0x00;\r\nvalue[3] = 0x00;\r\nvalue[4] = 0x00;\r\nvalue[5] = 0x00;\r\nvalue[6] = 0x00;\r\nhid_hw_request(hid, entry->report, HID_REQ_SET_REPORT);\r\nspin_unlock_irqrestore(&entry->report_lock, flags);\r\nreturn 0;\r\n}\r\nvalue[0] = 0x11;\r\nvalue[1] = 0x08;\r\nvalue[2] = x;\r\nvalue[3] = 0x80;\r\nvalue[4] = 0x00;\r\nvalue[5] = 0x00;\r\nvalue[6] = 0x00;\r\nhid_hw_request(hid, entry->report, HID_REQ_SET_REPORT);\r\nspin_unlock_irqrestore(&entry->report_lock, flags);\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic void lg4ff_set_autocenter_default(struct input_dev *dev, u16 magnitude)\r\n{\r\nstruct hid_device *hid = input_get_drvdata(dev);\r\nstruct list_head *report_list = &hid->report_enum[HID_OUTPUT_REPORT].report_list;\r\nstruct hid_report *report = list_entry(report_list->next, struct hid_report, list);\r\ns32 *value = report->field[0]->value;\r\nu32 expand_a, expand_b;\r\nstruct lg4ff_device_entry *entry;\r\nstruct lg_drv_data *drv_data;\r\nunsigned long flags;\r\ndrv_data = hid_get_drvdata(hid);\r\nif (!drv_data) {\r\nhid_err(hid, "Private driver data not found!\n");\r\nreturn;\r\n}\r\nentry = drv_data->device_props;\r\nif (!entry) {\r\nhid_err(hid, "Device properties not found!\n");\r\nreturn;\r\n}\r\nvalue = entry->report->field[0]->value;\r\nspin_lock_irqsave(&entry->report_lock, flags);\r\nif (magnitude == 0) {\r\nvalue[0] = 0xf5;\r\nvalue[1] = 0x00;\r\nvalue[2] = 0x00;\r\nvalue[3] = 0x00;\r\nvalue[4] = 0x00;\r\nvalue[5] = 0x00;\r\nvalue[6] = 0x00;\r\nhid_hw_request(hid, entry->report, HID_REQ_SET_REPORT);\r\nspin_unlock_irqrestore(&entry->report_lock, flags);\r\nreturn;\r\n}\r\nif (magnitude <= 0xaaaa) {\r\nexpand_a = 0x0c * magnitude;\r\nexpand_b = 0x80 * magnitude;\r\n} else {\r\nexpand_a = (0x0c * 0xaaaa) + 0x06 * (magnitude - 0xaaaa);\r\nexpand_b = (0x80 * 0xaaaa) + 0xff * (magnitude - 0xaaaa);\r\n}\r\nswitch (entry->wdata.product_id) {\r\ncase USB_DEVICE_ID_LOGITECH_MOMO_WHEEL:\r\ncase USB_DEVICE_ID_LOGITECH_MOMO_WHEEL2:\r\nbreak;\r\ndefault:\r\nexpand_a = expand_a >> 1;\r\nbreak;\r\n}\r\nvalue[0] = 0xfe;\r\nvalue[1] = 0x0d;\r\nvalue[2] = expand_a / 0xaaaa;\r\nvalue[3] = expand_a / 0xaaaa;\r\nvalue[4] = expand_b / 0xaaaa;\r\nvalue[5] = 0x00;\r\nvalue[6] = 0x00;\r\nhid_hw_request(hid, entry->report, HID_REQ_SET_REPORT);\r\nvalue[0] = 0x14;\r\nvalue[1] = 0x00;\r\nvalue[2] = 0x00;\r\nvalue[3] = 0x00;\r\nvalue[4] = 0x00;\r\nvalue[5] = 0x00;\r\nvalue[6] = 0x00;\r\nhid_hw_request(hid, entry->report, HID_REQ_SET_REPORT);\r\nspin_unlock_irqrestore(&entry->report_lock, flags);\r\n}\r\nstatic void lg4ff_set_autocenter_ffex(struct input_dev *dev, u16 magnitude)\r\n{\r\nstruct hid_device *hid = input_get_drvdata(dev);\r\nstruct lg4ff_device_entry *entry;\r\nstruct lg_drv_data *drv_data;\r\nunsigned long flags;\r\ns32 *value;\r\nmagnitude = magnitude * 90 / 65535;\r\ndrv_data = hid_get_drvdata(hid);\r\nif (!drv_data) {\r\nhid_err(hid, "Private driver data not found!\n");\r\nreturn;\r\n}\r\nentry = drv_data->device_props;\r\nif (!entry) {\r\nhid_err(hid, "Device properties not found!\n");\r\nreturn;\r\n}\r\nvalue = entry->report->field[0]->value;\r\nspin_lock_irqsave(&entry->report_lock, flags);\r\nvalue[0] = 0xfe;\r\nvalue[1] = 0x03;\r\nvalue[2] = magnitude >> 14;\r\nvalue[3] = magnitude >> 14;\r\nvalue[4] = magnitude;\r\nvalue[5] = 0x00;\r\nvalue[6] = 0x00;\r\nhid_hw_request(hid, entry->report, HID_REQ_SET_REPORT);\r\nspin_unlock_irqrestore(&entry->report_lock, flags);\r\n}\r\nstatic void lg4ff_set_range_g25(struct hid_device *hid, u16 range)\r\n{\r\nstruct lg4ff_device_entry *entry;\r\nstruct lg_drv_data *drv_data;\r\nunsigned long flags;\r\ns32 *value;\r\ndrv_data = hid_get_drvdata(hid);\r\nif (!drv_data) {\r\nhid_err(hid, "Private driver data not found!\n");\r\nreturn;\r\n}\r\nentry = drv_data->device_props;\r\nif (!entry) {\r\nhid_err(hid, "Device properties not found!\n");\r\nreturn;\r\n}\r\nvalue = entry->report->field[0]->value;\r\ndbg_hid("G25/G27/DFGT: setting range to %u\n", range);\r\nspin_lock_irqsave(&entry->report_lock, flags);\r\nvalue[0] = 0xf8;\r\nvalue[1] = 0x81;\r\nvalue[2] = range & 0x00ff;\r\nvalue[3] = (range & 0xff00) >> 8;\r\nvalue[4] = 0x00;\r\nvalue[5] = 0x00;\r\nvalue[6] = 0x00;\r\nhid_hw_request(hid, entry->report, HID_REQ_SET_REPORT);\r\nspin_unlock_irqrestore(&entry->report_lock, flags);\r\n}\r\nstatic void lg4ff_set_range_dfp(struct hid_device *hid, u16 range)\r\n{\r\nstruct lg4ff_device_entry *entry;\r\nstruct lg_drv_data *drv_data;\r\nunsigned long flags;\r\nint start_left, start_right, full_range;\r\ns32 *value;\r\ndrv_data = hid_get_drvdata(hid);\r\nif (!drv_data) {\r\nhid_err(hid, "Private driver data not found!\n");\r\nreturn;\r\n}\r\nentry = drv_data->device_props;\r\nif (!entry) {\r\nhid_err(hid, "Device properties not found!\n");\r\nreturn;\r\n}\r\nvalue = entry->report->field[0]->value;\r\ndbg_hid("Driving Force Pro: setting range to %u\n", range);\r\nspin_lock_irqsave(&entry->report_lock, flags);\r\nvalue[0] = 0xf8;\r\nvalue[1] = 0x00;\r\nvalue[2] = 0x00;\r\nvalue[3] = 0x00;\r\nvalue[4] = 0x00;\r\nvalue[5] = 0x00;\r\nvalue[6] = 0x00;\r\nif (range > 200) {\r\nvalue[1] = 0x03;\r\nfull_range = 900;\r\n} else {\r\nvalue[1] = 0x02;\r\nfull_range = 200;\r\n}\r\nhid_hw_request(hid, entry->report, HID_REQ_SET_REPORT);\r\nvalue[0] = 0x81;\r\nvalue[1] = 0x0b;\r\nvalue[2] = 0x00;\r\nvalue[3] = 0x00;\r\nvalue[4] = 0x00;\r\nvalue[5] = 0x00;\r\nvalue[6] = 0x00;\r\nif (range == 200 || range == 900) {\r\nhid_hw_request(hid, entry->report, HID_REQ_SET_REPORT);\r\nspin_unlock_irqrestore(&entry->report_lock, flags);\r\nreturn;\r\n}\r\nstart_left = (((full_range - range + 1) * 2047) / full_range);\r\nstart_right = 0xfff - start_left;\r\nvalue[2] = start_left >> 4;\r\nvalue[3] = start_right >> 4;\r\nvalue[4] = 0xff;\r\nvalue[5] = (start_right & 0xe) << 4 | (start_left & 0xe);\r\nvalue[6] = 0xff;\r\nhid_hw_request(hid, entry->report, HID_REQ_SET_REPORT);\r\nspin_unlock_irqrestore(&entry->report_lock, flags);\r\n}\r\nstatic const struct lg4ff_compat_mode_switch *lg4ff_get_mode_switch_command(const u16 real_product_id, const u16 target_product_id)\r\n{\r\nswitch (real_product_id) {\r\ncase USB_DEVICE_ID_LOGITECH_DFP_WHEEL:\r\nswitch (target_product_id) {\r\ncase USB_DEVICE_ID_LOGITECH_DFP_WHEEL:\r\nreturn &lg4ff_mode_switch_ext01_dfp;\r\ndefault:\r\nreturn NULL;\r\n}\r\nbreak;\r\ncase USB_DEVICE_ID_LOGITECH_G25_WHEEL:\r\nswitch (target_product_id) {\r\ncase USB_DEVICE_ID_LOGITECH_DFP_WHEEL:\r\nreturn &lg4ff_mode_switch_ext01_dfp;\r\ncase USB_DEVICE_ID_LOGITECH_G25_WHEEL:\r\nreturn &lg4ff_mode_switch_ext16_g25;\r\ndefault:\r\nreturn NULL;\r\n}\r\nbreak;\r\ncase USB_DEVICE_ID_LOGITECH_G27_WHEEL:\r\nswitch (target_product_id) {\r\ncase USB_DEVICE_ID_LOGITECH_WHEEL:\r\nreturn &lg4ff_mode_switch_ext09_dfex;\r\ncase USB_DEVICE_ID_LOGITECH_DFP_WHEEL:\r\nreturn &lg4ff_mode_switch_ext09_dfp;\r\ncase USB_DEVICE_ID_LOGITECH_G25_WHEEL:\r\nreturn &lg4ff_mode_switch_ext09_g25;\r\ncase USB_DEVICE_ID_LOGITECH_G27_WHEEL:\r\nreturn &lg4ff_mode_switch_ext09_g27;\r\ndefault:\r\nreturn NULL;\r\n}\r\nbreak;\r\ncase USB_DEVICE_ID_LOGITECH_G29_WHEEL:\r\nswitch (target_product_id) {\r\ncase USB_DEVICE_ID_LOGITECH_DFP_WHEEL:\r\nreturn &lg4ff_mode_switch_ext09_dfp;\r\ncase USB_DEVICE_ID_LOGITECH_DFGT_WHEEL:\r\nreturn &lg4ff_mode_switch_ext09_dfgt;\r\ncase USB_DEVICE_ID_LOGITECH_G25_WHEEL:\r\nreturn &lg4ff_mode_switch_ext09_g25;\r\ncase USB_DEVICE_ID_LOGITECH_G27_WHEEL:\r\nreturn &lg4ff_mode_switch_ext09_g27;\r\ncase USB_DEVICE_ID_LOGITECH_G29_WHEEL:\r\nreturn &lg4ff_mode_switch_ext09_g29;\r\ndefault:\r\nreturn NULL;\r\n}\r\nbreak;\r\ncase USB_DEVICE_ID_LOGITECH_DFGT_WHEEL:\r\nswitch (target_product_id) {\r\ncase USB_DEVICE_ID_LOGITECH_WHEEL:\r\nreturn &lg4ff_mode_switch_ext09_dfex;\r\ncase USB_DEVICE_ID_LOGITECH_DFP_WHEEL:\r\nreturn &lg4ff_mode_switch_ext09_dfp;\r\ncase USB_DEVICE_ID_LOGITECH_DFGT_WHEEL:\r\nreturn &lg4ff_mode_switch_ext09_dfgt;\r\ndefault:\r\nreturn NULL;\r\n}\r\nbreak;\r\ndefault:\r\nreturn NULL;\r\n}\r\n}\r\nstatic int lg4ff_switch_compatibility_mode(struct hid_device *hid, const struct lg4ff_compat_mode_switch *s)\r\n{\r\nstruct lg4ff_device_entry *entry;\r\nstruct lg_drv_data *drv_data;\r\nunsigned long flags;\r\ns32 *value;\r\nu8 i;\r\ndrv_data = hid_get_drvdata(hid);\r\nif (!drv_data) {\r\nhid_err(hid, "Private driver data not found!\n");\r\nreturn -EINVAL;\r\n}\r\nentry = drv_data->device_props;\r\nif (!entry) {\r\nhid_err(hid, "Device properties not found!\n");\r\nreturn -EINVAL;\r\n}\r\nvalue = entry->report->field[0]->value;\r\nspin_lock_irqsave(&entry->report_lock, flags);\r\nfor (i = 0; i < s->cmd_count; i++) {\r\nu8 j;\r\nfor (j = 0; j < 7; j++)\r\nvalue[j] = s->cmd[j + (7*i)];\r\nhid_hw_request(hid, entry->report, HID_REQ_SET_REPORT);\r\n}\r\nspin_unlock_irqrestore(&entry->report_lock, flags);\r\nhid_hw_wait(hid);\r\nreturn 0;\r\n}\r\nstatic ssize_t lg4ff_alternate_modes_show(struct device *dev, struct device_attribute *attr, char *buf)\r\n{\r\nstruct hid_device *hid = to_hid_device(dev);\r\nstruct lg4ff_device_entry *entry;\r\nstruct lg_drv_data *drv_data;\r\nssize_t count = 0;\r\nint i;\r\ndrv_data = hid_get_drvdata(hid);\r\nif (!drv_data) {\r\nhid_err(hid, "Private driver data not found!\n");\r\nreturn 0;\r\n}\r\nentry = drv_data->device_props;\r\nif (!entry) {\r\nhid_err(hid, "Device properties not found!\n");\r\nreturn 0;\r\n}\r\nif (!entry->wdata.real_name) {\r\nhid_err(hid, "NULL pointer to string\n");\r\nreturn 0;\r\n}\r\nfor (i = 0; i < LG4FF_MODE_MAX_IDX; i++) {\r\nif (entry->wdata.alternate_modes & BIT(i)) {\r\ncount += scnprintf(buf + count, PAGE_SIZE - count, "%s: %s",\r\nlg4ff_alternate_modes[i].tag,\r\n!lg4ff_alternate_modes[i].product_id ? entry->wdata.real_name : lg4ff_alternate_modes[i].name);\r\nif (count >= PAGE_SIZE - 1)\r\nreturn count;\r\nif (lg4ff_alternate_modes[i].product_id == entry->wdata.product_id ||\r\n(lg4ff_alternate_modes[i].product_id == 0 && entry->wdata.product_id == entry->wdata.real_product_id))\r\ncount += scnprintf(buf + count, PAGE_SIZE - count, " *\n");\r\nelse\r\ncount += scnprintf(buf + count, PAGE_SIZE - count, "\n");\r\nif (count >= PAGE_SIZE - 1)\r\nreturn count;\r\n}\r\n}\r\nreturn count;\r\n}\r\nstatic ssize_t lg4ff_alternate_modes_store(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)\r\n{\r\nstruct hid_device *hid = to_hid_device(dev);\r\nstruct lg4ff_device_entry *entry;\r\nstruct lg_drv_data *drv_data;\r\nconst struct lg4ff_compat_mode_switch *s;\r\nu16 target_product_id = 0;\r\nint i, ret;\r\nchar *lbuf;\r\ndrv_data = hid_get_drvdata(hid);\r\nif (!drv_data) {\r\nhid_err(hid, "Private driver data not found!\n");\r\nreturn -EINVAL;\r\n}\r\nentry = drv_data->device_props;\r\nif (!entry) {\r\nhid_err(hid, "Device properties not found!\n");\r\nreturn -EINVAL;\r\n}\r\nlbuf = kasprintf(GFP_KERNEL, "%s", buf);\r\nif (!lbuf)\r\nreturn -ENOMEM;\r\ni = strlen(lbuf);\r\nif (lbuf[i-1] == '\n') {\r\nif (i == 1) {\r\nkfree(lbuf);\r\nreturn -EINVAL;\r\n}\r\nlbuf[i-1] = '\0';\r\n}\r\nfor (i = 0; i < LG4FF_MODE_MAX_IDX; i++) {\r\nconst u16 mode_product_id = lg4ff_alternate_modes[i].product_id;\r\nconst char *tag = lg4ff_alternate_modes[i].tag;\r\nif (entry->wdata.alternate_modes & BIT(i)) {\r\nif (!strcmp(tag, lbuf)) {\r\nif (!mode_product_id)\r\ntarget_product_id = entry->wdata.real_product_id;\r\nelse\r\ntarget_product_id = mode_product_id;\r\nbreak;\r\n}\r\n}\r\n}\r\nif (i == LG4FF_MODE_MAX_IDX) {\r\nhid_info(hid, "Requested mode \"%s\" is not supported by the device\n", lbuf);\r\nkfree(lbuf);\r\nreturn -EINVAL;\r\n}\r\nkfree(lbuf);\r\nif (target_product_id == entry->wdata.product_id)\r\nreturn count;\r\nif (target_product_id == USB_DEVICE_ID_LOGITECH_WHEEL && !lg4ff_no_autoswitch) {\r\nhid_info(hid, "\"%s\" cannot be switched to \"DF-EX\" mode. Load the \"hid_logitech\" module with \"lg4ff_no_autoswitch=1\" parameter set and try again\n",\r\nentry->wdata.real_name);\r\nreturn -EINVAL;\r\n}\r\nif ((entry->wdata.real_product_id == USB_DEVICE_ID_LOGITECH_DFP_WHEEL || entry->wdata.real_product_id == USB_DEVICE_ID_LOGITECH_G25_WHEEL) &&\r\nentry->wdata.product_id > target_product_id) {\r\nhid_info(hid, "\"%s\" cannot be switched back into \"%s\" mode\n", entry->wdata.real_name, lg4ff_alternate_modes[i].name);\r\nreturn -EINVAL;\r\n}\r\ns = lg4ff_get_mode_switch_command(entry->wdata.real_product_id, target_product_id);\r\nif (!s) {\r\nhid_err(hid, "Invalid target product ID %X\n", target_product_id);\r\nreturn -EINVAL;\r\n}\r\nret = lg4ff_switch_compatibility_mode(hid, s);\r\nreturn (ret == 0 ? count : ret);\r\n}\r\nstatic ssize_t lg4ff_range_show(struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct hid_device *hid = to_hid_device(dev);\r\nstruct lg4ff_device_entry *entry;\r\nstruct lg_drv_data *drv_data;\r\nsize_t count;\r\ndrv_data = hid_get_drvdata(hid);\r\nif (!drv_data) {\r\nhid_err(hid, "Private driver data not found!\n");\r\nreturn 0;\r\n}\r\nentry = drv_data->device_props;\r\nif (!entry) {\r\nhid_err(hid, "Device properties not found!\n");\r\nreturn 0;\r\n}\r\ncount = scnprintf(buf, PAGE_SIZE, "%u\n", entry->wdata.range);\r\nreturn count;\r\n}\r\nstatic ssize_t lg4ff_range_store(struct device *dev, struct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct hid_device *hid = to_hid_device(dev);\r\nstruct lg4ff_device_entry *entry;\r\nstruct lg_drv_data *drv_data;\r\nu16 range = simple_strtoul(buf, NULL, 10);\r\ndrv_data = hid_get_drvdata(hid);\r\nif (!drv_data) {\r\nhid_err(hid, "Private driver data not found!\n");\r\nreturn -EINVAL;\r\n}\r\nentry = drv_data->device_props;\r\nif (!entry) {\r\nhid_err(hid, "Device properties not found!\n");\r\nreturn -EINVAL;\r\n}\r\nif (range == 0)\r\nrange = entry->wdata.max_range;\r\nif (entry->wdata.set_range && range >= entry->wdata.min_range && range <= entry->wdata.max_range) {\r\nentry->wdata.set_range(hid, range);\r\nentry->wdata.range = range;\r\n}\r\nreturn count;\r\n}\r\nstatic ssize_t lg4ff_real_id_show(struct device *dev, struct device_attribute *attr, char *buf)\r\n{\r\nstruct hid_device *hid = to_hid_device(dev);\r\nstruct lg4ff_device_entry *entry;\r\nstruct lg_drv_data *drv_data;\r\nsize_t count;\r\ndrv_data = hid_get_drvdata(hid);\r\nif (!drv_data) {\r\nhid_err(hid, "Private driver data not found!\n");\r\nreturn 0;\r\n}\r\nentry = drv_data->device_props;\r\nif (!entry) {\r\nhid_err(hid, "Device properties not found!\n");\r\nreturn 0;\r\n}\r\nif (!entry->wdata.real_tag || !entry->wdata.real_name) {\r\nhid_err(hid, "NULL pointer to string\n");\r\nreturn 0;\r\n}\r\ncount = scnprintf(buf, PAGE_SIZE, "%s: %s\n", entry->wdata.real_tag, entry->wdata.real_name);\r\nreturn count;\r\n}\r\nstatic ssize_t lg4ff_real_id_store(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)\r\n{\r\nreturn -EPERM;\r\n}\r\nstatic void lg4ff_set_leds(struct hid_device *hid, u8 leds)\r\n{\r\nstruct lg_drv_data *drv_data;\r\nstruct lg4ff_device_entry *entry;\r\nunsigned long flags;\r\ns32 *value;\r\ndrv_data = hid_get_drvdata(hid);\r\nif (!drv_data) {\r\nhid_err(hid, "Private driver data not found!\n");\r\nreturn;\r\n}\r\nentry = drv_data->device_props;\r\nif (!entry) {\r\nhid_err(hid, "Device properties not found!\n");\r\nreturn;\r\n}\r\nvalue = entry->report->field[0]->value;\r\nspin_lock_irqsave(&entry->report_lock, flags);\r\nvalue[0] = 0xf8;\r\nvalue[1] = 0x12;\r\nvalue[2] = leds;\r\nvalue[3] = 0x00;\r\nvalue[4] = 0x00;\r\nvalue[5] = 0x00;\r\nvalue[6] = 0x00;\r\nhid_hw_request(hid, entry->report, HID_REQ_SET_REPORT);\r\nspin_unlock_irqrestore(&entry->report_lock, flags);\r\n}\r\nstatic void lg4ff_led_set_brightness(struct led_classdev *led_cdev,\r\nenum led_brightness value)\r\n{\r\nstruct device *dev = led_cdev->dev->parent;\r\nstruct hid_device *hid = to_hid_device(dev);\r\nstruct lg_drv_data *drv_data = hid_get_drvdata(hid);\r\nstruct lg4ff_device_entry *entry;\r\nint i, state = 0;\r\nif (!drv_data) {\r\nhid_err(hid, "Device data not found.");\r\nreturn;\r\n}\r\nentry = drv_data->device_props;\r\nif (!entry) {\r\nhid_err(hid, "Device properties not found.");\r\nreturn;\r\n}\r\nfor (i = 0; i < 5; i++) {\r\nif (led_cdev != entry->wdata.led[i])\r\ncontinue;\r\nstate = (entry->wdata.led_state >> i) & 1;\r\nif (value == LED_OFF && state) {\r\nentry->wdata.led_state &= ~(1 << i);\r\nlg4ff_set_leds(hid, entry->wdata.led_state);\r\n} else if (value != LED_OFF && !state) {\r\nentry->wdata.led_state |= 1 << i;\r\nlg4ff_set_leds(hid, entry->wdata.led_state);\r\n}\r\nbreak;\r\n}\r\n}\r\nstatic enum led_brightness lg4ff_led_get_brightness(struct led_classdev *led_cdev)\r\n{\r\nstruct device *dev = led_cdev->dev->parent;\r\nstruct hid_device *hid = to_hid_device(dev);\r\nstruct lg_drv_data *drv_data = hid_get_drvdata(hid);\r\nstruct lg4ff_device_entry *entry;\r\nint i, value = 0;\r\nif (!drv_data) {\r\nhid_err(hid, "Device data not found.");\r\nreturn LED_OFF;\r\n}\r\nentry = drv_data->device_props;\r\nif (!entry) {\r\nhid_err(hid, "Device properties not found.");\r\nreturn LED_OFF;\r\n}\r\nfor (i = 0; i < 5; i++)\r\nif (led_cdev == entry->wdata.led[i]) {\r\nvalue = (entry->wdata.led_state >> i) & 1;\r\nbreak;\r\n}\r\nreturn value ? LED_FULL : LED_OFF;\r\n}\r\nstatic u16 lg4ff_identify_multimode_wheel(struct hid_device *hid, const u16 reported_product_id, const u16 bcdDevice)\r\n{\r\nu32 current_mode;\r\nint i;\r\nfor (i = 1; i < ARRAY_SIZE(lg4ff_alternate_modes); i++) {\r\ndbg_hid("Testing whether PID is %X\n", lg4ff_alternate_modes[i].product_id);\r\nif (reported_product_id == lg4ff_alternate_modes[i].product_id)\r\nbreak;\r\n}\r\nif (i == ARRAY_SIZE(lg4ff_alternate_modes))\r\nreturn 0;\r\ncurrent_mode = BIT(i);\r\nfor (i = 0; i < ARRAY_SIZE(lg4ff_main_checklist); i++) {\r\nconst u16 mask = lg4ff_main_checklist[i]->mask;\r\nconst u16 result = lg4ff_main_checklist[i]->result;\r\nconst u16 real_product_id = lg4ff_main_checklist[i]->real_product_id;\r\nif ((current_mode & lg4ff_main_checklist[i]->modes) && \\r\n(bcdDevice & mask) == result) {\r\ndbg_hid("Found wheel with real PID %X whose reported PID is %X\n", real_product_id, reported_product_id);\r\nreturn real_product_id;\r\n}\r\n}\r\ndbg_hid("Wheel with bcdDevice %X was not recognized as multimode wheel, leaving in its current mode\n", bcdDevice);\r\nreturn 0;\r\n}\r\nstatic int lg4ff_handle_multimode_wheel(struct hid_device *hid, u16 *real_product_id, const u16 bcdDevice)\r\n{\r\nconst u16 reported_product_id = hid->product;\r\nint ret;\r\n*real_product_id = lg4ff_identify_multimode_wheel(hid, reported_product_id, bcdDevice);\r\nif (!*real_product_id) {\r\n*real_product_id = reported_product_id;\r\ndbg_hid("Wheel is not a multimode wheel\n");\r\nreturn LG4FF_MMODE_NOT_MULTIMODE;\r\n}\r\nif (reported_product_id == USB_DEVICE_ID_LOGITECH_WHEEL &&\r\nreported_product_id != *real_product_id &&\r\n!lg4ff_no_autoswitch) {\r\nconst struct lg4ff_compat_mode_switch *s = lg4ff_get_mode_switch_command(*real_product_id, *real_product_id);\r\nif (!s) {\r\nhid_err(hid, "Invalid product id %X\n", *real_product_id);\r\nreturn LG4FF_MMODE_NOT_MULTIMODE;\r\n}\r\nret = lg4ff_switch_compatibility_mode(hid, s);\r\nif (ret) {\r\nhid_err(hid, "Unable to switch wheel mode, errno %d\n", ret);\r\nreturn LG4FF_MMODE_IS_MULTIMODE;\r\n}\r\nreturn LG4FF_MMODE_SWITCHED;\r\n}\r\nreturn LG4FF_MMODE_IS_MULTIMODE;\r\n}\r\nint lg4ff_init(struct hid_device *hid)\r\n{\r\nstruct hid_input *hidinput = list_entry(hid->inputs.next, struct hid_input, list);\r\nstruct input_dev *dev = hidinput->input;\r\nstruct list_head *report_list = &hid->report_enum[HID_OUTPUT_REPORT].report_list;\r\nstruct hid_report *report = list_entry(report_list->next, struct hid_report, list);\r\nconst struct usb_device_descriptor *udesc = &(hid_to_usb_dev(hid)->descriptor);\r\nconst u16 bcdDevice = le16_to_cpu(udesc->bcdDevice);\r\nconst struct lg4ff_multimode_wheel *mmode_wheel = NULL;\r\nstruct lg4ff_device_entry *entry;\r\nstruct lg_drv_data *drv_data;\r\nint error, i, j;\r\nint mmode_ret, mmode_idx = -1;\r\nu16 real_product_id;\r\nif (!hid_validate_values(hid, HID_OUTPUT_REPORT, 0, 0, 7))\r\nreturn -1;\r\ndrv_data = hid_get_drvdata(hid);\r\nif (!drv_data) {\r\nhid_err(hid, "Cannot add device, private driver data not allocated\n");\r\nreturn -1;\r\n}\r\nentry = kzalloc(sizeof(*entry), GFP_KERNEL);\r\nif (!entry)\r\nreturn -ENOMEM;\r\nspin_lock_init(&entry->report_lock);\r\nentry->report = report;\r\ndrv_data->device_props = entry;\r\nmmode_ret = lg4ff_handle_multimode_wheel(hid, &real_product_id, bcdDevice);\r\nif (mmode_ret == LG4FF_MMODE_SWITCHED)\r\nreturn 0;\r\nelse if (mmode_ret < 0) {\r\nhid_err(hid, "Unable to switch device mode during initialization, errno %d\n", mmode_ret);\r\nerror = mmode_ret;\r\ngoto err_init;\r\n}\r\nfor (i = 0; i < ARRAY_SIZE(lg4ff_devices); i++) {\r\nif (hid->product == lg4ff_devices[i].product_id) {\r\ndbg_hid("Found compatible device, product ID %04X\n", lg4ff_devices[i].product_id);\r\nbreak;\r\n}\r\n}\r\nif (i == ARRAY_SIZE(lg4ff_devices)) {\r\nhid_err(hid, "This device is flagged to be handled by the lg4ff module but this module does not know how to handle it. "\r\n"Please report this as a bug to LKML, Simon Wood <simon@mungewell.org> or "\r\n"Michal Maly <madcatxster@devoid-pointer.net>\n");\r\nerror = -1;\r\ngoto err_init;\r\n}\r\nif (mmode_ret == LG4FF_MMODE_IS_MULTIMODE) {\r\nfor (mmode_idx = 0; mmode_idx < ARRAY_SIZE(lg4ff_multimode_wheels); mmode_idx++) {\r\nif (real_product_id == lg4ff_multimode_wheels[mmode_idx].product_id)\r\nbreak;\r\n}\r\nif (mmode_idx == ARRAY_SIZE(lg4ff_multimode_wheels)) {\r\nhid_err(hid, "Device product ID %X is not listed as a multimode wheel", real_product_id);\r\nerror = -1;\r\ngoto err_init;\r\n}\r\n}\r\nfor (j = 0; lg4ff_devices[i].ff_effects[j] >= 0; j++)\r\nset_bit(lg4ff_devices[i].ff_effects[j], dev->ffbit);\r\nerror = input_ff_create_memless(dev, NULL, lg4ff_play);\r\nif (error)\r\ngoto err_init;\r\nif (mmode_ret == LG4FF_MMODE_IS_MULTIMODE) {\r\nBUG_ON(mmode_idx == -1);\r\nmmode_wheel = &lg4ff_multimode_wheels[mmode_idx];\r\n}\r\nlg4ff_init_wheel_data(&entry->wdata, &lg4ff_devices[i], mmode_wheel, real_product_id);\r\nif (test_bit(FF_AUTOCENTER, dev->ffbit)) {\r\nif ((bcdDevice >> 8) == LG4FF_FFEX_REV_MAJ &&\r\n(bcdDevice & 0xff) == LG4FF_FFEX_REV_MIN)\r\ndev->ff->set_autocenter = lg4ff_set_autocenter_ffex;\r\nelse\r\ndev->ff->set_autocenter = lg4ff_set_autocenter_default;\r\ndev->ff->set_autocenter(dev, 0);\r\n}\r\nerror = device_create_file(&hid->dev, &dev_attr_range);\r\nif (error)\r\nhid_warn(hid, "Unable to create sysfs interface for \"range\", errno %d\n", error);\r\nif (mmode_ret == LG4FF_MMODE_IS_MULTIMODE) {\r\nerror = device_create_file(&hid->dev, &dev_attr_real_id);\r\nif (error)\r\nhid_warn(hid, "Unable to create sysfs interface for \"real_id\", errno %d\n", error);\r\nerror = device_create_file(&hid->dev, &dev_attr_alternate_modes);\r\nif (error)\r\nhid_warn(hid, "Unable to create sysfs interface for \"alternate_modes\", errno %d\n", error);\r\n}\r\ndbg_hid("sysfs interface created\n");\r\nentry->wdata.range = entry->wdata.max_range;\r\nif (entry->wdata.set_range)\r\nentry->wdata.set_range(hid, entry->wdata.range);\r\n#ifdef CONFIG_LEDS_CLASS\r\nentry->wdata.led_state = 0;\r\nfor (j = 0; j < 5; j++)\r\nentry->wdata.led[j] = NULL;\r\nif (lg4ff_devices[i].product_id == USB_DEVICE_ID_LOGITECH_G27_WHEEL ||\r\nlg4ff_devices[i].product_id == USB_DEVICE_ID_LOGITECH_G29_WHEEL) {\r\nstruct led_classdev *led;\r\nsize_t name_sz;\r\nchar *name;\r\nlg4ff_set_leds(hid, 0);\r\nname_sz = strlen(dev_name(&hid->dev)) + 8;\r\nfor (j = 0; j < 5; j++) {\r\nled = kzalloc(sizeof(struct led_classdev)+name_sz, GFP_KERNEL);\r\nif (!led) {\r\nhid_err(hid, "can't allocate memory for LED %d\n", j);\r\ngoto err_leds;\r\n}\r\nname = (void *)(&led[1]);\r\nsnprintf(name, name_sz, "%s::RPM%d", dev_name(&hid->dev), j+1);\r\nled->name = name;\r\nled->brightness = 0;\r\nled->max_brightness = 1;\r\nled->brightness_get = lg4ff_led_get_brightness;\r\nled->brightness_set = lg4ff_led_set_brightness;\r\nentry->wdata.led[j] = led;\r\nerror = led_classdev_register(&hid->dev, led);\r\nif (error) {\r\nhid_err(hid, "failed to register LED %d. Aborting.\n", j);\r\nerr_leds:\r\nfor (j = 0; j < 5; j++) {\r\nled = entry->wdata.led[j];\r\nentry->wdata.led[j] = NULL;\r\nif (!led)\r\ncontinue;\r\nled_classdev_unregister(led);\r\nkfree(led);\r\n}\r\ngoto out;\r\n}\r\n}\r\n}\r\nout:\r\n#endif\r\nhid_info(hid, "Force feedback support for Logitech Gaming Wheels\n");\r\nreturn 0;\r\nerr_init:\r\ndrv_data->device_props = NULL;\r\nkfree(entry);\r\nreturn error;\r\n}\r\nint lg4ff_deinit(struct hid_device *hid)\r\n{\r\nstruct lg4ff_device_entry *entry;\r\nstruct lg_drv_data *drv_data;\r\ndrv_data = hid_get_drvdata(hid);\r\nif (!drv_data) {\r\nhid_err(hid, "Error while deinitializing device, no private driver data.\n");\r\nreturn -1;\r\n}\r\nentry = drv_data->device_props;\r\nif (!entry)\r\ngoto out;\r\nif (entry->wdata.alternate_modes) {\r\ndevice_remove_file(&hid->dev, &dev_attr_real_id);\r\ndevice_remove_file(&hid->dev, &dev_attr_alternate_modes);\r\n}\r\ndevice_remove_file(&hid->dev, &dev_attr_range);\r\n#ifdef CONFIG_LEDS_CLASS\r\n{\r\nint j;\r\nstruct led_classdev *led;\r\nfor (j = 0; j < 5; j++) {\r\nled = entry->wdata.led[j];\r\nentry->wdata.led[j] = NULL;\r\nif (!led)\r\ncontinue;\r\nled_classdev_unregister(led);\r\nkfree(led);\r\n}\r\n}\r\n#endif\r\nhid_hw_stop(hid);\r\ndrv_data->device_props = NULL;\r\nkfree(entry);\r\nout:\r\ndbg_hid("Device successfully unregistered\n");\r\nreturn 0;\r\n}
