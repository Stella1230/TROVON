static int st6422_s_ctrl(struct v4l2_ctrl *ctrl)\r\n{\r\nstruct gspca_dev *gspca_dev =\r\ncontainer_of(ctrl->handler, struct gspca_dev, ctrl_handler);\r\nstruct sd *sd = (struct sd *)gspca_dev;\r\nint err = -EINVAL;\r\nswitch (ctrl->id) {\r\ncase V4L2_CID_BRIGHTNESS:\r\nerr = setbrightness(sd, ctrl->val);\r\nbreak;\r\ncase V4L2_CID_CONTRAST:\r\nerr = setcontrast(sd, ctrl->val);\r\nbreak;\r\ncase V4L2_CID_GAIN:\r\nerr = setgain(sd, ctrl->val);\r\nbreak;\r\ncase V4L2_CID_EXPOSURE:\r\nerr = setexposure(sd, ctrl->val);\r\nbreak;\r\n}\r\nif (err >= 0)\r\nerr = stv06xx_write_bridge(sd, 0x143f, 0x01);\r\nsd->gspca_dev.usb_err = err;\r\nreturn err;\r\n}\r\nstatic int st6422_init_controls(struct sd *sd)\r\n{\r\nstruct v4l2_ctrl_handler *hdl = &sd->gspca_dev.ctrl_handler;\r\nv4l2_ctrl_handler_init(hdl, 4);\r\nv4l2_ctrl_new_std(hdl, &st6422_ctrl_ops,\r\nV4L2_CID_BRIGHTNESS, 0, 31, 1, 3);\r\nv4l2_ctrl_new_std(hdl, &st6422_ctrl_ops,\r\nV4L2_CID_CONTRAST, 0, 15, 1, 11);\r\nv4l2_ctrl_new_std(hdl, &st6422_ctrl_ops,\r\nV4L2_CID_EXPOSURE, 0, 1023, 1, 256);\r\nv4l2_ctrl_new_std(hdl, &st6422_ctrl_ops,\r\nV4L2_CID_GAIN, 0, 255, 1, 64);\r\nreturn hdl->error;\r\n}\r\nstatic int st6422_probe(struct sd *sd)\r\n{\r\nif (sd->bridge != BRIDGE_ST6422)\r\nreturn -ENODEV;\r\npr_info("st6422 sensor detected\n");\r\nsd->gspca_dev.cam.cam_mode = st6422_mode;\r\nsd->gspca_dev.cam.nmodes = ARRAY_SIZE(st6422_mode);\r\nreturn 0;\r\n}\r\nstatic int st6422_init(struct sd *sd)\r\n{\r\nint err = 0, i;\r\nconst u16 st6422_bridge_init[][2] = {\r\n{ STV_ISO_ENABLE, 0x00 },\r\n{ 0x1436, 0x00 },\r\n{ 0x1432, 0x03 },\r\n{ 0x143a, 0xf9 },\r\n{ 0x0509, 0x38 },\r\n{ 0x050a, 0x38 },\r\n{ 0x050b, 0x38 },\r\n{ 0x050c, 0x2a },\r\n{ 0x050d, 0x01 },\r\n{ 0x1431, 0x00 },\r\n{ 0x1433, 0x34 },\r\n{ 0x1438, 0x18 },\r\n{ 0x1439, 0x00 },\r\n{ 0x143b, 0x05 },\r\n{ 0x143c, 0x00 },\r\n{ 0x143e, 0x01 },\r\n{ 0x143d, 0x00 },\r\n{ 0x1442, 0xe2 },\r\n{ 0x1500, 0xd0 },\r\n{ 0x1500, 0xd0 },\r\n{ 0x1500, 0x50 },\r\n{ 0x1501, 0xaf },\r\n{ 0x1502, 0xc2 },\r\n{ 0x1503, 0x45 },\r\n{ 0x1505, 0x02 },\r\n{ 0x150e, 0x8e },\r\n{ 0x150f, 0x37 },\r\n{ 0x15c0, 0x00 },\r\n{ 0x15c3, 0x08 },\r\n{ 0x143f, 0x01 },\r\n};\r\nfor (i = 0; i < ARRAY_SIZE(st6422_bridge_init) && !err; i++) {\r\nerr = stv06xx_write_bridge(sd, st6422_bridge_init[i][0],\r\nst6422_bridge_init[i][1]);\r\n}\r\nreturn err;\r\n}\r\nstatic int setbrightness(struct sd *sd, s32 val)\r\n{\r\nreturn stv06xx_write_bridge(sd, 0x1432, val);\r\n}\r\nstatic int setcontrast(struct sd *sd, s32 val)\r\n{\r\nreturn stv06xx_write_bridge(sd, 0x143a, val | 0xf0);\r\n}\r\nstatic int setgain(struct sd *sd, u8 gain)\r\n{\r\nint err;\r\nerr = stv06xx_write_bridge(sd, 0x0509, gain);\r\nif (err < 0)\r\nreturn err;\r\nerr = stv06xx_write_bridge(sd, 0x050a, gain);\r\nif (err < 0)\r\nreturn err;\r\nerr = stv06xx_write_bridge(sd, 0x050b, gain);\r\nif (err < 0)\r\nreturn err;\r\nerr = stv06xx_write_bridge(sd, 0x050c, 0x2a);\r\nif (err < 0)\r\nreturn err;\r\nreturn stv06xx_write_bridge(sd, 0x050d, 0x01);\r\n}\r\nstatic int setexposure(struct sd *sd, s16 expo)\r\n{\r\nint err;\r\nerr = stv06xx_write_bridge(sd, 0x143d, expo & 0xff);\r\nif (err < 0)\r\nreturn err;\r\nreturn stv06xx_write_bridge(sd, 0x143e, expo >> 8);\r\n}\r\nstatic int st6422_start(struct sd *sd)\r\n{\r\nint err;\r\nstruct cam *cam = &sd->gspca_dev.cam;\r\nif (cam->cam_mode[sd->gspca_dev.curr_mode].priv)\r\nerr = stv06xx_write_bridge(sd, 0x1505, 0x0f);\r\nelse\r\nerr = stv06xx_write_bridge(sd, 0x1505, 0x02);\r\nif (err < 0)\r\nreturn err;\r\nerr = stv06xx_write_bridge(sd, 0x143f, 0x01);\r\nreturn (err < 0) ? err : 0;\r\n}\r\nstatic int st6422_stop(struct sd *sd)\r\n{\r\nstruct gspca_dev *gspca_dev = (struct gspca_dev *)sd;\r\nPDEBUG(D_STREAM, "Halting stream");\r\nreturn 0;\r\n}
