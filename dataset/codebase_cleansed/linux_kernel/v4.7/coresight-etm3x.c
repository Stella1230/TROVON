static void etm_os_unlock(struct etm_drvdata *drvdata)\r\n{\r\netm_writel(drvdata, 0x0, ETMOSLAR);\r\ndrvdata->os_unlock = true;\r\nisb();\r\n}\r\nstatic void etm_set_pwrdwn(struct etm_drvdata *drvdata)\r\n{\r\nu32 etmcr;\r\nmb();\r\nisb();\r\netmcr = etm_readl(drvdata, ETMCR);\r\netmcr |= ETMCR_PWD_DWN;\r\netm_writel(drvdata, etmcr, ETMCR);\r\n}\r\nstatic void etm_clr_pwrdwn(struct etm_drvdata *drvdata)\r\n{\r\nu32 etmcr;\r\netmcr = etm_readl(drvdata, ETMCR);\r\netmcr &= ~ETMCR_PWD_DWN;\r\netm_writel(drvdata, etmcr, ETMCR);\r\nmb();\r\nisb();\r\n}\r\nstatic void etm_set_pwrup(struct etm_drvdata *drvdata)\r\n{\r\nu32 etmpdcr;\r\netmpdcr = readl_relaxed(drvdata->base + ETMPDCR);\r\netmpdcr |= ETMPDCR_PWD_UP;\r\nwritel_relaxed(etmpdcr, drvdata->base + ETMPDCR);\r\nmb();\r\nisb();\r\n}\r\nstatic void etm_clr_pwrup(struct etm_drvdata *drvdata)\r\n{\r\nu32 etmpdcr;\r\nmb();\r\nisb();\r\netmpdcr = readl_relaxed(drvdata->base + ETMPDCR);\r\netmpdcr &= ~ETMPDCR_PWD_UP;\r\nwritel_relaxed(etmpdcr, drvdata->base + ETMPDCR);\r\n}\r\nstatic int coresight_timeout_etm(struct etm_drvdata *drvdata, u32 offset,\r\nint position, int value)\r\n{\r\nint i;\r\nu32 val;\r\nfor (i = TIMEOUT_US; i > 0; i--) {\r\nval = etm_readl(drvdata, offset);\r\nif (value) {\r\nif (val & BIT(position))\r\nreturn 0;\r\n} else {\r\nif (!(val & BIT(position)))\r\nreturn 0;\r\n}\r\nif (i - 1)\r\nudelay(1);\r\n}\r\nreturn -EAGAIN;\r\n}\r\nstatic void etm_set_prog(struct etm_drvdata *drvdata)\r\n{\r\nu32 etmcr;\r\netmcr = etm_readl(drvdata, ETMCR);\r\netmcr |= ETMCR_ETM_PRG;\r\netm_writel(drvdata, etmcr, ETMCR);\r\nisb();\r\nif (coresight_timeout_etm(drvdata, ETMSR, ETMSR_PROG_BIT, 1)) {\r\ndev_err(drvdata->dev,\r\n"%s: timeout observed when probing at offset %#x\n",\r\n__func__, ETMSR);\r\n}\r\n}\r\nstatic void etm_clr_prog(struct etm_drvdata *drvdata)\r\n{\r\nu32 etmcr;\r\netmcr = etm_readl(drvdata, ETMCR);\r\netmcr &= ~ETMCR_ETM_PRG;\r\netm_writel(drvdata, etmcr, ETMCR);\r\nisb();\r\nif (coresight_timeout_etm(drvdata, ETMSR, ETMSR_PROG_BIT, 0)) {\r\ndev_err(drvdata->dev,\r\n"%s: timeout observed when probing at offset %#x\n",\r\n__func__, ETMSR);\r\n}\r\n}\r\nvoid etm_set_default(struct etm_config *config)\r\n{\r\nint i;\r\nif (WARN_ON_ONCE(!config))\r\nreturn;\r\nconfig->enable_ctrl1 = BIT(24);\r\nconfig->enable_ctrl2 = 0x0;\r\nconfig->enable_event = ETM_HARD_WIRE_RES_A;\r\nconfig->trigger_event = ETM_DEFAULT_EVENT_VAL;\r\nconfig->enable_event = ETM_HARD_WIRE_RES_A;\r\nconfig->seq_12_event = ETM_DEFAULT_EVENT_VAL;\r\nconfig->seq_21_event = ETM_DEFAULT_EVENT_VAL;\r\nconfig->seq_23_event = ETM_DEFAULT_EVENT_VAL;\r\nconfig->seq_31_event = ETM_DEFAULT_EVENT_VAL;\r\nconfig->seq_32_event = ETM_DEFAULT_EVENT_VAL;\r\nconfig->seq_13_event = ETM_DEFAULT_EVENT_VAL;\r\nconfig->timestamp_event = ETM_DEFAULT_EVENT_VAL;\r\nfor (i = 0; i < ETM_MAX_CNTR; i++) {\r\nconfig->cntr_rld_val[i] = 0x0;\r\nconfig->cntr_event[i] = ETM_DEFAULT_EVENT_VAL;\r\nconfig->cntr_rld_event[i] = ETM_DEFAULT_EVENT_VAL;\r\nconfig->cntr_val[i] = 0x0;\r\n}\r\nconfig->seq_curr_state = 0x0;\r\nconfig->ctxid_idx = 0x0;\r\nfor (i = 0; i < ETM_MAX_CTXID_CMP; i++) {\r\nconfig->ctxid_pid[i] = 0x0;\r\nconfig->ctxid_vpid[i] = 0x0;\r\n}\r\nconfig->ctxid_mask = 0x0;\r\n}\r\nvoid etm_config_trace_mode(struct etm_config *config)\r\n{\r\nu32 flags, mode;\r\nmode = config->mode;\r\nmode &= (ETM_MODE_EXCL_KERN | ETM_MODE_EXCL_USER);\r\nif (mode == (ETM_MODE_EXCL_KERN | ETM_MODE_EXCL_USER))\r\nreturn;\r\nif (!(mode & ETM_MODE_EXCL_KERN) && !(mode & ETM_MODE_EXCL_USER))\r\nreturn;\r\nflags = (1 << 0 |\r\n3 << 3 |\r\n0 << 5 |\r\n0 << 7 |\r\n0 << 8);\r\nconfig->enable_ctrl2 = 0x0;\r\nconfig->enable_ctrl1 = ETMTECR1_ADDR_COMP_1;\r\nflags |= (0 << 12 | 1 << 10);\r\nif (mode & ETM_MODE_EXCL_USER) {\r\nflags |= (1 << 13 | 0 << 11);\r\n} else {\r\nflags |= (1 << 13 | 1 << 11);\r\n}\r\nconfig->addr_val[0] = (u32) 0x0;\r\nconfig->addr_val[1] = (u32) ~0x0;\r\nconfig->addr_acctype[0] = flags;\r\nconfig->addr_acctype[1] = flags;\r\nconfig->addr_type[0] = ETM_ADDR_TYPE_RANGE;\r\nconfig->addr_type[1] = ETM_ADDR_TYPE_RANGE;\r\n}\r\nstatic int etm_parse_event_config(struct etm_drvdata *drvdata,\r\nstruct perf_event_attr *attr)\r\n{\r\nstruct etm_config *config = &drvdata->config;\r\nif (!attr)\r\nreturn -EINVAL;\r\nmemset(config, 0, sizeof(struct etm_config));\r\nif (attr->exclude_kernel)\r\nconfig->mode = ETM_MODE_EXCL_KERN;\r\nif (attr->exclude_user)\r\nconfig->mode = ETM_MODE_EXCL_USER;\r\netm_set_default(config);\r\nif (config->mode)\r\netm_config_trace_mode(config);\r\nif (attr->config & ~ETM3X_SUPPORTED_OPTIONS)\r\nreturn -EINVAL;\r\nconfig->ctrl = attr->config;\r\nreturn 0;\r\n}\r\nstatic void etm_enable_hw(void *info)\r\n{\r\nint i;\r\nu32 etmcr;\r\nstruct etm_drvdata *drvdata = info;\r\nstruct etm_config *config = &drvdata->config;\r\nCS_UNLOCK(drvdata->base);\r\netm_clr_pwrdwn(drvdata);\r\netm_set_pwrup(drvdata);\r\netm_os_unlock(drvdata);\r\netm_set_prog(drvdata);\r\netmcr = etm_readl(drvdata, ETMCR);\r\netmcr &= ~ETM3X_SUPPORTED_OPTIONS;\r\netmcr |= drvdata->port_size;\r\netmcr |= ETMCR_ETM_EN;\r\netm_writel(drvdata, config->ctrl | etmcr, ETMCR);\r\netm_writel(drvdata, config->trigger_event, ETMTRIGGER);\r\netm_writel(drvdata, config->startstop_ctrl, ETMTSSCR);\r\netm_writel(drvdata, config->enable_event, ETMTEEVR);\r\netm_writel(drvdata, config->enable_ctrl1, ETMTECR1);\r\netm_writel(drvdata, config->fifofull_level, ETMFFLR);\r\nfor (i = 0; i < drvdata->nr_addr_cmp; i++) {\r\netm_writel(drvdata, config->addr_val[i], ETMACVRn(i));\r\netm_writel(drvdata, config->addr_acctype[i], ETMACTRn(i));\r\n}\r\nfor (i = 0; i < drvdata->nr_cntr; i++) {\r\netm_writel(drvdata, config->cntr_rld_val[i], ETMCNTRLDVRn(i));\r\netm_writel(drvdata, config->cntr_event[i], ETMCNTENRn(i));\r\netm_writel(drvdata, config->cntr_rld_event[i],\r\nETMCNTRLDEVRn(i));\r\netm_writel(drvdata, config->cntr_val[i], ETMCNTVRn(i));\r\n}\r\netm_writel(drvdata, config->seq_12_event, ETMSQ12EVR);\r\netm_writel(drvdata, config->seq_21_event, ETMSQ21EVR);\r\netm_writel(drvdata, config->seq_23_event, ETMSQ23EVR);\r\netm_writel(drvdata, config->seq_31_event, ETMSQ31EVR);\r\netm_writel(drvdata, config->seq_32_event, ETMSQ32EVR);\r\netm_writel(drvdata, config->seq_13_event, ETMSQ13EVR);\r\netm_writel(drvdata, config->seq_curr_state, ETMSQR);\r\nfor (i = 0; i < drvdata->nr_ext_out; i++)\r\netm_writel(drvdata, ETM_DEFAULT_EVENT_VAL, ETMEXTOUTEVRn(i));\r\nfor (i = 0; i < drvdata->nr_ctxid_cmp; i++)\r\netm_writel(drvdata, config->ctxid_pid[i], ETMCIDCVRn(i));\r\netm_writel(drvdata, config->ctxid_mask, ETMCIDCMR);\r\netm_writel(drvdata, config->sync_freq, ETMSYNCFR);\r\netm_writel(drvdata, 0x0, ETMEXTINSELR);\r\netm_writel(drvdata, config->timestamp_event, ETMTSEVR);\r\netm_writel(drvdata, 0x0, ETMAUXCR);\r\netm_writel(drvdata, drvdata->traceid, ETMTRACEIDR);\r\netm_writel(drvdata, 0x0, ETMVMIDCVR);\r\netm_clr_prog(drvdata);\r\nCS_LOCK(drvdata->base);\r\ndev_dbg(drvdata->dev, "cpu: %d enable smp call done\n", drvdata->cpu);\r\n}\r\nstatic int etm_cpu_id(struct coresight_device *csdev)\r\n{\r\nstruct etm_drvdata *drvdata = dev_get_drvdata(csdev->dev.parent);\r\nreturn drvdata->cpu;\r\n}\r\nint etm_get_trace_id(struct etm_drvdata *drvdata)\r\n{\r\nunsigned long flags;\r\nint trace_id = -1;\r\nif (!drvdata)\r\ngoto out;\r\nif (!local_read(&drvdata->mode))\r\nreturn drvdata->traceid;\r\npm_runtime_get_sync(drvdata->dev);\r\nspin_lock_irqsave(&drvdata->spinlock, flags);\r\nCS_UNLOCK(drvdata->base);\r\ntrace_id = (etm_readl(drvdata, ETMTRACEIDR) & ETM_TRACEID_MASK);\r\nCS_LOCK(drvdata->base);\r\nspin_unlock_irqrestore(&drvdata->spinlock, flags);\r\npm_runtime_put(drvdata->dev);\r\nout:\r\nreturn trace_id;\r\n}\r\nstatic int etm_trace_id(struct coresight_device *csdev)\r\n{\r\nstruct etm_drvdata *drvdata = dev_get_drvdata(csdev->dev.parent);\r\nreturn etm_get_trace_id(drvdata);\r\n}\r\nstatic int etm_enable_perf(struct coresight_device *csdev,\r\nstruct perf_event_attr *attr)\r\n{\r\nstruct etm_drvdata *drvdata = dev_get_drvdata(csdev->dev.parent);\r\nif (WARN_ON_ONCE(drvdata->cpu != smp_processor_id()))\r\nreturn -EINVAL;\r\netm_parse_event_config(drvdata, attr);\r\netm_enable_hw(drvdata);\r\nreturn 0;\r\n}\r\nstatic int etm_enable_sysfs(struct coresight_device *csdev)\r\n{\r\nstruct etm_drvdata *drvdata = dev_get_drvdata(csdev->dev.parent);\r\nint ret;\r\nspin_lock(&drvdata->spinlock);\r\nif (cpu_online(drvdata->cpu)) {\r\nret = smp_call_function_single(drvdata->cpu,\r\netm_enable_hw, drvdata, 1);\r\nif (ret)\r\ngoto err;\r\n}\r\ndrvdata->sticky_enable = true;\r\nspin_unlock(&drvdata->spinlock);\r\ndev_info(drvdata->dev, "ETM tracing enabled\n");\r\nreturn 0;\r\nerr:\r\nspin_unlock(&drvdata->spinlock);\r\nreturn ret;\r\n}\r\nstatic int etm_enable(struct coresight_device *csdev,\r\nstruct perf_event_attr *attr, u32 mode)\r\n{\r\nint ret;\r\nu32 val;\r\nstruct etm_drvdata *drvdata = dev_get_drvdata(csdev->dev.parent);\r\nval = local_cmpxchg(&drvdata->mode, CS_MODE_DISABLED, mode);\r\nif (val)\r\nreturn -EBUSY;\r\nswitch (mode) {\r\ncase CS_MODE_SYSFS:\r\nret = etm_enable_sysfs(csdev);\r\nbreak;\r\ncase CS_MODE_PERF:\r\nret = etm_enable_perf(csdev, attr);\r\nbreak;\r\ndefault:\r\nret = -EINVAL;\r\n}\r\nif (ret)\r\nlocal_set(&drvdata->mode, CS_MODE_DISABLED);\r\nreturn ret;\r\n}\r\nstatic void etm_disable_hw(void *info)\r\n{\r\nint i;\r\nstruct etm_drvdata *drvdata = info;\r\nstruct etm_config *config = &drvdata->config;\r\nCS_UNLOCK(drvdata->base);\r\netm_set_prog(drvdata);\r\nconfig->seq_curr_state = (etm_readl(drvdata, ETMSQR) & ETM_SQR_MASK);\r\nfor (i = 0; i < drvdata->nr_cntr; i++)\r\nconfig->cntr_val[i] = etm_readl(drvdata, ETMCNTVRn(i));\r\netm_set_pwrdwn(drvdata);\r\nCS_LOCK(drvdata->base);\r\ndev_dbg(drvdata->dev, "cpu: %d disable smp call done\n", drvdata->cpu);\r\n}\r\nstatic void etm_disable_perf(struct coresight_device *csdev)\r\n{\r\nstruct etm_drvdata *drvdata = dev_get_drvdata(csdev->dev.parent);\r\nif (WARN_ON_ONCE(drvdata->cpu != smp_processor_id()))\r\nreturn;\r\nCS_UNLOCK(drvdata->base);\r\netm_set_prog(drvdata);\r\netm_set_pwrdwn(drvdata);\r\nCS_LOCK(drvdata->base);\r\n}\r\nstatic void etm_disable_sysfs(struct coresight_device *csdev)\r\n{\r\nstruct etm_drvdata *drvdata = dev_get_drvdata(csdev->dev.parent);\r\nget_online_cpus();\r\nspin_lock(&drvdata->spinlock);\r\nsmp_call_function_single(drvdata->cpu, etm_disable_hw, drvdata, 1);\r\nspin_unlock(&drvdata->spinlock);\r\nput_online_cpus();\r\ndev_info(drvdata->dev, "ETM tracing disabled\n");\r\n}\r\nstatic void etm_disable(struct coresight_device *csdev)\r\n{\r\nu32 mode;\r\nstruct etm_drvdata *drvdata = dev_get_drvdata(csdev->dev.parent);\r\nmode = local_read(&drvdata->mode);\r\nswitch (mode) {\r\ncase CS_MODE_DISABLED:\r\nbreak;\r\ncase CS_MODE_SYSFS:\r\netm_disable_sysfs(csdev);\r\nbreak;\r\ncase CS_MODE_PERF:\r\netm_disable_perf(csdev);\r\nbreak;\r\ndefault:\r\nWARN_ON_ONCE(mode);\r\nreturn;\r\n}\r\nif (mode)\r\nlocal_set(&drvdata->mode, CS_MODE_DISABLED);\r\n}\r\nstatic int etm_cpu_callback(struct notifier_block *nfb, unsigned long action,\r\nvoid *hcpu)\r\n{\r\nunsigned int cpu = (unsigned long)hcpu;\r\nif (!etmdrvdata[cpu])\r\ngoto out;\r\nswitch (action & (~CPU_TASKS_FROZEN)) {\r\ncase CPU_STARTING:\r\nspin_lock(&etmdrvdata[cpu]->spinlock);\r\nif (!etmdrvdata[cpu]->os_unlock) {\r\netm_os_unlock(etmdrvdata[cpu]);\r\netmdrvdata[cpu]->os_unlock = true;\r\n}\r\nif (local_read(&etmdrvdata[cpu]->mode))\r\netm_enable_hw(etmdrvdata[cpu]);\r\nspin_unlock(&etmdrvdata[cpu]->spinlock);\r\nbreak;\r\ncase CPU_ONLINE:\r\nif (etmdrvdata[cpu]->boot_enable &&\r\n!etmdrvdata[cpu]->sticky_enable)\r\ncoresight_enable(etmdrvdata[cpu]->csdev);\r\nbreak;\r\ncase CPU_DYING:\r\nspin_lock(&etmdrvdata[cpu]->spinlock);\r\nif (local_read(&etmdrvdata[cpu]->mode))\r\netm_disable_hw(etmdrvdata[cpu]);\r\nspin_unlock(&etmdrvdata[cpu]->spinlock);\r\nbreak;\r\n}\r\nout:\r\nreturn NOTIFY_OK;\r\n}\r\nstatic bool etm_arch_supported(u8 arch)\r\n{\r\nswitch (arch) {\r\ncase ETM_ARCH_V3_3:\r\nbreak;\r\ncase ETM_ARCH_V3_5:\r\nbreak;\r\ncase PFT_ARCH_V1_0:\r\nbreak;\r\ncase PFT_ARCH_V1_1:\r\nbreak;\r\ndefault:\r\nreturn false;\r\n}\r\nreturn true;\r\n}\r\nstatic void etm_init_arch_data(void *info)\r\n{\r\nu32 etmidr;\r\nu32 etmccr;\r\nstruct etm_drvdata *drvdata = info;\r\netm_os_unlock(drvdata);\r\nCS_UNLOCK(drvdata->base);\r\n(void)etm_readl(drvdata, ETMPDSR);\r\netm_set_pwrup(drvdata);\r\netm_clr_pwrdwn(drvdata);\r\netm_set_prog(drvdata);\r\netmidr = etm_readl(drvdata, ETMIDR);\r\ndrvdata->arch = BMVAL(etmidr, 4, 11);\r\ndrvdata->port_size = etm_readl(drvdata, ETMCR) & PORT_SIZE_MASK;\r\ndrvdata->etmccer = etm_readl(drvdata, ETMCCER);\r\netmccr = etm_readl(drvdata, ETMCCR);\r\ndrvdata->etmccr = etmccr;\r\ndrvdata->nr_addr_cmp = BMVAL(etmccr, 0, 3) * 2;\r\ndrvdata->nr_cntr = BMVAL(etmccr, 13, 15);\r\ndrvdata->nr_ext_inp = BMVAL(etmccr, 17, 19);\r\ndrvdata->nr_ext_out = BMVAL(etmccr, 20, 22);\r\ndrvdata->nr_ctxid_cmp = BMVAL(etmccr, 24, 25);\r\netm_set_pwrdwn(drvdata);\r\netm_clr_pwrup(drvdata);\r\nCS_LOCK(drvdata->base);\r\n}\r\nstatic void etm_init_trace_id(struct etm_drvdata *drvdata)\r\n{\r\ndrvdata->traceid = coresight_get_trace_id(drvdata->cpu);\r\n}\r\nstatic int etm_probe(struct amba_device *adev, const struct amba_id *id)\r\n{\r\nint ret;\r\nvoid __iomem *base;\r\nstruct device *dev = &adev->dev;\r\nstruct coresight_platform_data *pdata = NULL;\r\nstruct etm_drvdata *drvdata;\r\nstruct resource *res = &adev->res;\r\nstruct coresight_desc *desc;\r\nstruct device_node *np = adev->dev.of_node;\r\ndesc = devm_kzalloc(dev, sizeof(*desc), GFP_KERNEL);\r\nif (!desc)\r\nreturn -ENOMEM;\r\ndrvdata = devm_kzalloc(dev, sizeof(*drvdata), GFP_KERNEL);\r\nif (!drvdata)\r\nreturn -ENOMEM;\r\nif (np) {\r\npdata = of_get_coresight_platform_data(dev, np);\r\nif (IS_ERR(pdata))\r\nreturn PTR_ERR(pdata);\r\nadev->dev.platform_data = pdata;\r\ndrvdata->use_cp14 = of_property_read_bool(np, "arm,cp14");\r\n}\r\ndrvdata->dev = &adev->dev;\r\ndev_set_drvdata(dev, drvdata);\r\nbase = devm_ioremap_resource(dev, res);\r\nif (IS_ERR(base))\r\nreturn PTR_ERR(base);\r\ndrvdata->base = base;\r\nspin_lock_init(&drvdata->spinlock);\r\ndrvdata->atclk = devm_clk_get(&adev->dev, "atclk");\r\nif (!IS_ERR(drvdata->atclk)) {\r\nret = clk_prepare_enable(drvdata->atclk);\r\nif (ret)\r\nreturn ret;\r\n}\r\ndrvdata->cpu = pdata ? pdata->cpu : 0;\r\nget_online_cpus();\r\netmdrvdata[drvdata->cpu] = drvdata;\r\nif (smp_call_function_single(drvdata->cpu,\r\netm_init_arch_data, drvdata, 1))\r\ndev_err(dev, "ETM arch init failed\n");\r\nif (!etm_count++)\r\nregister_hotcpu_notifier(&etm_cpu_notifier);\r\nput_online_cpus();\r\nif (etm_arch_supported(drvdata->arch) == false) {\r\nret = -EINVAL;\r\ngoto err_arch_supported;\r\n}\r\netm_init_trace_id(drvdata);\r\netm_set_default(&drvdata->config);\r\ndesc->type = CORESIGHT_DEV_TYPE_SOURCE;\r\ndesc->subtype.source_subtype = CORESIGHT_DEV_SUBTYPE_SOURCE_PROC;\r\ndesc->ops = &etm_cs_ops;\r\ndesc->pdata = pdata;\r\ndesc->dev = dev;\r\ndesc->groups = coresight_etm_groups;\r\ndrvdata->csdev = coresight_register(desc);\r\nif (IS_ERR(drvdata->csdev)) {\r\nret = PTR_ERR(drvdata->csdev);\r\ngoto err_arch_supported;\r\n}\r\nret = etm_perf_symlink(drvdata->csdev, true);\r\nif (ret) {\r\ncoresight_unregister(drvdata->csdev);\r\ngoto err_arch_supported;\r\n}\r\npm_runtime_put(&adev->dev);\r\ndev_info(dev, "%s initialized\n", (char *)id->data);\r\nif (boot_enable) {\r\ncoresight_enable(drvdata->csdev);\r\ndrvdata->boot_enable = true;\r\n}\r\nreturn 0;\r\nerr_arch_supported:\r\nif (--etm_count == 0)\r\nunregister_hotcpu_notifier(&etm_cpu_notifier);\r\nreturn ret;\r\n}\r\nstatic int etm_runtime_suspend(struct device *dev)\r\n{\r\nstruct etm_drvdata *drvdata = dev_get_drvdata(dev);\r\nif (drvdata && !IS_ERR(drvdata->atclk))\r\nclk_disable_unprepare(drvdata->atclk);\r\nreturn 0;\r\n}\r\nstatic int etm_runtime_resume(struct device *dev)\r\n{\r\nstruct etm_drvdata *drvdata = dev_get_drvdata(dev);\r\nif (drvdata && !IS_ERR(drvdata->atclk))\r\nclk_prepare_enable(drvdata->atclk);\r\nreturn 0;\r\n}
