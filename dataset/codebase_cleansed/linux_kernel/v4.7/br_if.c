static int port_cost(struct net_device *dev)\r\n{\r\nstruct ethtool_link_ksettings ecmd;\r\nif (!__ethtool_get_link_ksettings(dev, &ecmd)) {\r\nswitch (ecmd.base.speed) {\r\ncase SPEED_10000:\r\nreturn 2;\r\ncase SPEED_1000:\r\nreturn 4;\r\ncase SPEED_100:\r\nreturn 19;\r\ncase SPEED_10:\r\nreturn 100;\r\n}\r\n}\r\nif (!strncmp(dev->name, "lec", 3))\r\nreturn 7;\r\nif (!strncmp(dev->name, "plip", 4))\r\nreturn 2500;\r\nreturn 100;\r\n}\r\nvoid br_port_carrier_check(struct net_bridge_port *p)\r\n{\r\nstruct net_device *dev = p->dev;\r\nstruct net_bridge *br = p->br;\r\nif (!(p->flags & BR_ADMIN_COST) &&\r\nnetif_running(dev) && netif_oper_up(dev))\r\np->path_cost = port_cost(dev);\r\nif (!netif_running(br->dev))\r\nreturn;\r\nspin_lock_bh(&br->lock);\r\nif (netif_running(dev) && netif_oper_up(dev)) {\r\nif (p->state == BR_STATE_DISABLED)\r\nbr_stp_enable_port(p);\r\n} else {\r\nif (p->state != BR_STATE_DISABLED)\r\nbr_stp_disable_port(p);\r\n}\r\nspin_unlock_bh(&br->lock);\r\n}\r\nstatic void br_port_set_promisc(struct net_bridge_port *p)\r\n{\r\nint err = 0;\r\nif (br_promisc_port(p))\r\nreturn;\r\nerr = dev_set_promiscuity(p->dev, 1);\r\nif (err)\r\nreturn;\r\nbr_fdb_unsync_static(p->br, p);\r\np->flags |= BR_PROMISC;\r\n}\r\nstatic void br_port_clear_promisc(struct net_bridge_port *p)\r\n{\r\nint err;\r\nif (!br_promisc_port(p) || !(p->dev->priv_flags & IFF_UNICAST_FLT))\r\nreturn;\r\nerr = br_fdb_sync_static(p->br, p);\r\nif (err)\r\nreturn;\r\ndev_set_promiscuity(p->dev, -1);\r\np->flags &= ~BR_PROMISC;\r\n}\r\nvoid br_manage_promisc(struct net_bridge *br)\r\n{\r\nstruct net_bridge_port *p;\r\nbool set_all = false;\r\nif ((br->dev->flags & IFF_PROMISC) || !br_vlan_enabled(br))\r\nset_all = true;\r\nlist_for_each_entry(p, &br->port_list, list) {\r\nif (set_all) {\r\nbr_port_set_promisc(p);\r\n} else {\r\nif (br->auto_cnt == 0 ||\r\n(br->auto_cnt == 1 && br_auto_port(p)))\r\nbr_port_clear_promisc(p);\r\nelse\r\nbr_port_set_promisc(p);\r\n}\r\n}\r\n}\r\nstatic void nbp_update_port_count(struct net_bridge *br)\r\n{\r\nstruct net_bridge_port *p;\r\nu32 cnt = 0;\r\nlist_for_each_entry(p, &br->port_list, list) {\r\nif (br_auto_port(p))\r\ncnt++;\r\n}\r\nif (br->auto_cnt != cnt) {\r\nbr->auto_cnt = cnt;\r\nbr_manage_promisc(br);\r\n}\r\n}\r\nstatic void nbp_delete_promisc(struct net_bridge_port *p)\r\n{\r\ndev_set_allmulti(p->dev, -1);\r\nif (br_promisc_port(p))\r\ndev_set_promiscuity(p->dev, -1);\r\nelse\r\nbr_fdb_unsync_static(p->br, p);\r\n}\r\nstatic void release_nbp(struct kobject *kobj)\r\n{\r\nstruct net_bridge_port *p\r\n= container_of(kobj, struct net_bridge_port, kobj);\r\nkfree(p);\r\n}\r\nstatic void destroy_nbp(struct net_bridge_port *p)\r\n{\r\nstruct net_device *dev = p->dev;\r\np->br = NULL;\r\np->dev = NULL;\r\ndev_put(dev);\r\nkobject_put(&p->kobj);\r\n}\r\nstatic void destroy_nbp_rcu(struct rcu_head *head)\r\n{\r\nstruct net_bridge_port *p =\r\ncontainer_of(head, struct net_bridge_port, rcu);\r\ndestroy_nbp(p);\r\n}\r\nstatic unsigned get_max_headroom(struct net_bridge *br)\r\n{\r\nunsigned max_headroom = 0;\r\nstruct net_bridge_port *p;\r\nlist_for_each_entry(p, &br->port_list, list) {\r\nunsigned dev_headroom = netdev_get_fwd_headroom(p->dev);\r\nif (dev_headroom > max_headroom)\r\nmax_headroom = dev_headroom;\r\n}\r\nreturn max_headroom;\r\n}\r\nstatic void update_headroom(struct net_bridge *br, int new_hr)\r\n{\r\nstruct net_bridge_port *p;\r\nlist_for_each_entry(p, &br->port_list, list)\r\nnetdev_set_rx_headroom(p->dev, new_hr);\r\nbr->dev->needed_headroom = new_hr;\r\n}\r\nstatic void del_nbp(struct net_bridge_port *p)\r\n{\r\nstruct net_bridge *br = p->br;\r\nstruct net_device *dev = p->dev;\r\nsysfs_remove_link(br->ifobj, p->dev->name);\r\nnbp_delete_promisc(p);\r\nspin_lock_bh(&br->lock);\r\nbr_stp_disable_port(p);\r\nspin_unlock_bh(&br->lock);\r\nbr_ifinfo_notify(RTM_DELLINK, p);\r\nlist_del_rcu(&p->list);\r\nif (netdev_get_fwd_headroom(dev) == br->dev->needed_headroom)\r\nupdate_headroom(br, get_max_headroom(br));\r\nnetdev_reset_rx_headroom(dev);\r\nnbp_vlan_flush(p);\r\nbr_fdb_delete_by_port(br, p, 0, 1);\r\nswitchdev_deferred_process();\r\nnbp_update_port_count(br);\r\nnetdev_upper_dev_unlink(dev, br->dev);\r\ndev->priv_flags &= ~IFF_BRIDGE_PORT;\r\nnetdev_rx_handler_unregister(dev);\r\nbr_multicast_del_port(p);\r\nkobject_uevent(&p->kobj, KOBJ_REMOVE);\r\nkobject_del(&p->kobj);\r\nbr_netpoll_disable(p);\r\ncall_rcu(&p->rcu, destroy_nbp_rcu);\r\n}\r\nvoid br_dev_delete(struct net_device *dev, struct list_head *head)\r\n{\r\nstruct net_bridge *br = netdev_priv(dev);\r\nstruct net_bridge_port *p, *n;\r\nlist_for_each_entry_safe(p, n, &br->port_list, list) {\r\ndel_nbp(p);\r\n}\r\nbr_fdb_delete_by_port(br, NULL, 0, 1);\r\nbr_vlan_flush(br);\r\nbr_multicast_dev_del(br);\r\ndel_timer_sync(&br->gc_timer);\r\nbr_sysfs_delbr(br->dev);\r\nunregister_netdevice_queue(br->dev, head);\r\n}\r\nstatic int find_portno(struct net_bridge *br)\r\n{\r\nint index;\r\nstruct net_bridge_port *p;\r\nunsigned long *inuse;\r\ninuse = kcalloc(BITS_TO_LONGS(BR_MAX_PORTS), sizeof(unsigned long),\r\nGFP_KERNEL);\r\nif (!inuse)\r\nreturn -ENOMEM;\r\nset_bit(0, inuse);\r\nlist_for_each_entry(p, &br->port_list, list) {\r\nset_bit(p->port_no, inuse);\r\n}\r\nindex = find_first_zero_bit(inuse, BR_MAX_PORTS);\r\nkfree(inuse);\r\nreturn (index >= BR_MAX_PORTS) ? -EXFULL : index;\r\n}\r\nstatic struct net_bridge_port *new_nbp(struct net_bridge *br,\r\nstruct net_device *dev)\r\n{\r\nint index;\r\nstruct net_bridge_port *p;\r\nindex = find_portno(br);\r\nif (index < 0)\r\nreturn ERR_PTR(index);\r\np = kzalloc(sizeof(*p), GFP_KERNEL);\r\nif (p == NULL)\r\nreturn ERR_PTR(-ENOMEM);\r\np->br = br;\r\ndev_hold(dev);\r\np->dev = dev;\r\np->path_cost = port_cost(dev);\r\np->priority = 0x8000 >> BR_PORT_BITS;\r\np->port_no = index;\r\np->flags = BR_LEARNING | BR_FLOOD;\r\nbr_init_port(p);\r\nbr_set_state(p, BR_STATE_DISABLED);\r\nbr_stp_port_timer_init(p);\r\nbr_multicast_add_port(p);\r\nreturn p;\r\n}\r\nint br_add_bridge(struct net *net, const char *name)\r\n{\r\nstruct net_device *dev;\r\nint res;\r\ndev = alloc_netdev(sizeof(struct net_bridge), name, NET_NAME_UNKNOWN,\r\nbr_dev_setup);\r\nif (!dev)\r\nreturn -ENOMEM;\r\ndev_net_set(dev, net);\r\ndev->rtnl_link_ops = &br_link_ops;\r\nres = register_netdev(dev);\r\nif (res)\r\nfree_netdev(dev);\r\nreturn res;\r\n}\r\nint br_del_bridge(struct net *net, const char *name)\r\n{\r\nstruct net_device *dev;\r\nint ret = 0;\r\nrtnl_lock();\r\ndev = __dev_get_by_name(net, name);\r\nif (dev == NULL)\r\nret = -ENXIO;\r\nelse if (!(dev->priv_flags & IFF_EBRIDGE)) {\r\nret = -EPERM;\r\n}\r\nelse if (dev->flags & IFF_UP) {\r\nret = -EBUSY;\r\n}\r\nelse\r\nbr_dev_delete(dev, NULL);\r\nrtnl_unlock();\r\nreturn ret;\r\n}\r\nint br_min_mtu(const struct net_bridge *br)\r\n{\r\nconst struct net_bridge_port *p;\r\nint mtu = 0;\r\nASSERT_RTNL();\r\nif (list_empty(&br->port_list))\r\nmtu = ETH_DATA_LEN;\r\nelse {\r\nlist_for_each_entry(p, &br->port_list, list) {\r\nif (!mtu || p->dev->mtu < mtu)\r\nmtu = p->dev->mtu;\r\n}\r\n}\r\nreturn mtu;\r\n}\r\nstatic void br_set_gso_limits(struct net_bridge *br)\r\n{\r\nunsigned int gso_max_size = GSO_MAX_SIZE;\r\nu16 gso_max_segs = GSO_MAX_SEGS;\r\nconst struct net_bridge_port *p;\r\nlist_for_each_entry(p, &br->port_list, list) {\r\ngso_max_size = min(gso_max_size, p->dev->gso_max_size);\r\ngso_max_segs = min(gso_max_segs, p->dev->gso_max_segs);\r\n}\r\nbr->dev->gso_max_size = gso_max_size;\r\nbr->dev->gso_max_segs = gso_max_segs;\r\n}\r\nnetdev_features_t br_features_recompute(struct net_bridge *br,\r\nnetdev_features_t features)\r\n{\r\nstruct net_bridge_port *p;\r\nnetdev_features_t mask;\r\nif (list_empty(&br->port_list))\r\nreturn features;\r\nmask = features;\r\nfeatures &= ~NETIF_F_ONE_FOR_ALL;\r\nlist_for_each_entry(p, &br->port_list, list) {\r\nfeatures = netdev_increment_features(features,\r\np->dev->features, mask);\r\n}\r\nfeatures = netdev_add_tso_features(features, mask);\r\nreturn features;\r\n}\r\nint br_add_if(struct net_bridge *br, struct net_device *dev)\r\n{\r\nstruct net_bridge_port *p;\r\nint err = 0;\r\nunsigned br_hr, dev_hr;\r\nbool changed_addr;\r\nif ((dev->flags & IFF_LOOPBACK) ||\r\ndev->type != ARPHRD_ETHER || dev->addr_len != ETH_ALEN ||\r\n!is_valid_ether_addr(dev->dev_addr) ||\r\nnetdev_uses_dsa(dev))\r\nreturn -EINVAL;\r\nif (dev->netdev_ops->ndo_start_xmit == br_dev_xmit)\r\nreturn -ELOOP;\r\nif (br_port_exists(dev))\r\nreturn -EBUSY;\r\nif (dev->priv_flags & IFF_DONT_BRIDGE)\r\nreturn -EOPNOTSUPP;\r\np = new_nbp(br, dev);\r\nif (IS_ERR(p))\r\nreturn PTR_ERR(p);\r\ncall_netdevice_notifiers(NETDEV_JOIN, dev);\r\nerr = dev_set_allmulti(dev, 1);\r\nif (err)\r\ngoto put_back;\r\nerr = kobject_init_and_add(&p->kobj, &brport_ktype, &(dev->dev.kobj),\r\nSYSFS_BRIDGE_PORT_ATTR);\r\nif (err)\r\ngoto err1;\r\nerr = br_sysfs_addif(p);\r\nif (err)\r\ngoto err2;\r\nerr = br_netpoll_enable(p);\r\nif (err)\r\ngoto err3;\r\nerr = netdev_rx_handler_register(dev, br_handle_frame, p);\r\nif (err)\r\ngoto err4;\r\ndev->priv_flags |= IFF_BRIDGE_PORT;\r\nerr = netdev_master_upper_dev_link(dev, br->dev, NULL, NULL);\r\nif (err)\r\ngoto err5;\r\ndev_disable_lro(dev);\r\nlist_add_rcu(&p->list, &br->port_list);\r\nnbp_update_port_count(br);\r\nnetdev_update_features(br->dev);\r\nbr_hr = br->dev->needed_headroom;\r\ndev_hr = netdev_get_fwd_headroom(dev);\r\nif (br_hr < dev_hr)\r\nupdate_headroom(br, dev_hr);\r\nelse\r\nnetdev_set_rx_headroom(dev, br_hr);\r\nif (br_fdb_insert(br, p, dev->dev_addr, 0))\r\nnetdev_err(dev, "failed insert local address bridge forwarding table\n");\r\nerr = nbp_vlan_init(p);\r\nif (err) {\r\nnetdev_err(dev, "failed to initialize vlan filtering on this port\n");\r\ngoto err6;\r\n}\r\nspin_lock_bh(&br->lock);\r\nchanged_addr = br_stp_recalculate_bridge_id(br);\r\nif (netif_running(dev) && netif_oper_up(dev) &&\r\n(br->dev->flags & IFF_UP))\r\nbr_stp_enable_port(p);\r\nspin_unlock_bh(&br->lock);\r\nbr_ifinfo_notify(RTM_NEWLINK, p);\r\nif (changed_addr)\r\ncall_netdevice_notifiers(NETDEV_CHANGEADDR, br->dev);\r\ndev_set_mtu(br->dev, br_min_mtu(br));\r\nbr_set_gso_limits(br);\r\nkobject_uevent(&p->kobj, KOBJ_ADD);\r\nreturn 0;\r\nerr6:\r\nlist_del_rcu(&p->list);\r\nbr_fdb_delete_by_port(br, p, 0, 1);\r\nnbp_update_port_count(br);\r\nnetdev_upper_dev_unlink(dev, br->dev);\r\nerr5:\r\ndev->priv_flags &= ~IFF_BRIDGE_PORT;\r\nnetdev_rx_handler_unregister(dev);\r\nerr4:\r\nbr_netpoll_disable(p);\r\nerr3:\r\nsysfs_remove_link(br->ifobj, p->dev->name);\r\nerr2:\r\nkobject_put(&p->kobj);\r\np = NULL;\r\nerr1:\r\ndev_set_allmulti(dev, -1);\r\nput_back:\r\ndev_put(dev);\r\nkfree(p);\r\nreturn err;\r\n}\r\nint br_del_if(struct net_bridge *br, struct net_device *dev)\r\n{\r\nstruct net_bridge_port *p;\r\nbool changed_addr;\r\np = br_port_get_rtnl(dev);\r\nif (!p || p->br != br)\r\nreturn -EINVAL;\r\ndel_nbp(p);\r\ndev_set_mtu(br->dev, br_min_mtu(br));\r\nbr_set_gso_limits(br);\r\nspin_lock_bh(&br->lock);\r\nchanged_addr = br_stp_recalculate_bridge_id(br);\r\nspin_unlock_bh(&br->lock);\r\nif (changed_addr)\r\ncall_netdevice_notifiers(NETDEV_CHANGEADDR, br->dev);\r\nnetdev_update_features(br->dev);\r\nreturn 0;\r\n}\r\nvoid br_port_flags_change(struct net_bridge_port *p, unsigned long mask)\r\n{\r\nstruct net_bridge *br = p->br;\r\nif (mask & BR_AUTO_MASK)\r\nnbp_update_port_count(br);\r\n}
