static inline int w83791d_read(struct i2c_client *client, u8 reg)\r\n{\r\nreturn i2c_smbus_read_byte_data(client, reg);\r\n}\r\nstatic inline int w83791d_write(struct i2c_client *client, u8 reg, u8 value)\r\n{\r\nreturn i2c_smbus_write_byte_data(client, reg, value);\r\n}\r\nstatic u8 fan_to_reg(long rpm, int div)\r\n{\r\nif (rpm == 0)\r\nreturn 255;\r\nrpm = clamp_val(rpm, 1, 1000000);\r\nreturn clamp_val((1350000 + rpm * div / 2) / (rpm * div), 1, 254);\r\n}\r\nstatic u8 div_to_reg(int nr, long val)\r\n{\r\nint i;\r\nval = clamp_val(val, 1, 128) >> 1;\r\nfor (i = 0; i < 7; i++) {\r\nif (val == 0)\r\nbreak;\r\nval >>= 1;\r\n}\r\nreturn (u8) i;\r\n}\r\nstatic ssize_t show_beep(struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct sensor_device_attribute *sensor_attr =\r\nto_sensor_dev_attr(attr);\r\nstruct w83791d_data *data = w83791d_update_device(dev);\r\nint bitnr = sensor_attr->index;\r\nreturn sprintf(buf, "%d\n", (data->beep_mask >> bitnr) & 1);\r\n}\r\nstatic ssize_t store_beep(struct device *dev, struct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct sensor_device_attribute *sensor_attr =\r\nto_sensor_dev_attr(attr);\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nstruct w83791d_data *data = i2c_get_clientdata(client);\r\nint bitnr = sensor_attr->index;\r\nint bytenr = bitnr / 8;\r\nunsigned long val;\r\nint err;\r\nerr = kstrtoul(buf, 10, &val);\r\nif (err)\r\nreturn err;\r\nval = val ? 1 : 0;\r\nmutex_lock(&data->update_lock);\r\ndata->beep_mask &= ~(0xff << (bytenr * 8));\r\ndata->beep_mask |= w83791d_read(client, W83791D_REG_BEEP_CTRL[bytenr])\r\n<< (bytenr * 8);\r\ndata->beep_mask &= ~(1 << bitnr);\r\ndata->beep_mask |= val << bitnr;\r\nw83791d_write(client, W83791D_REG_BEEP_CTRL[bytenr],\r\n(data->beep_mask >> (bytenr * 8)) & 0xff);\r\nmutex_unlock(&data->update_lock);\r\nreturn count;\r\n}\r\nstatic ssize_t show_alarm(struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct sensor_device_attribute *sensor_attr =\r\nto_sensor_dev_attr(attr);\r\nstruct w83791d_data *data = w83791d_update_device(dev);\r\nint bitnr = sensor_attr->index;\r\nreturn sprintf(buf, "%d\n", (data->alarms >> bitnr) & 1);\r\n}\r\nstatic ssize_t store_fan_min(struct device *dev, struct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct sensor_device_attribute *sensor_attr = to_sensor_dev_attr(attr);\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nstruct w83791d_data *data = i2c_get_clientdata(client);\r\nint nr = sensor_attr->index;\r\nunsigned long val;\r\nint err;\r\nerr = kstrtoul(buf, 10, &val);\r\nif (err)\r\nreturn err;\r\nmutex_lock(&data->update_lock);\r\ndata->fan_min[nr] = fan_to_reg(val, DIV_FROM_REG(data->fan_div[nr]));\r\nw83791d_write(client, W83791D_REG_FAN_MIN[nr], data->fan_min[nr]);\r\nmutex_unlock(&data->update_lock);\r\nreturn count;\r\n}\r\nstatic ssize_t show_fan_div(struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct sensor_device_attribute *sensor_attr = to_sensor_dev_attr(attr);\r\nint nr = sensor_attr->index;\r\nstruct w83791d_data *data = w83791d_update_device(dev);\r\nreturn sprintf(buf, "%u\n", DIV_FROM_REG(data->fan_div[nr]));\r\n}\r\nstatic ssize_t store_fan_div(struct device *dev, struct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct sensor_device_attribute *sensor_attr = to_sensor_dev_attr(attr);\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nstruct w83791d_data *data = i2c_get_clientdata(client);\r\nint nr = sensor_attr->index;\r\nunsigned long min;\r\nu8 tmp_fan_div;\r\nu8 fan_div_reg;\r\nu8 vbat_reg;\r\nint indx = 0;\r\nu8 keep_mask = 0;\r\nu8 new_shift = 0;\r\nunsigned long val;\r\nint err;\r\nerr = kstrtoul(buf, 10, &val);\r\nif (err)\r\nreturn err;\r\nmin = FAN_FROM_REG(data->fan_min[nr], DIV_FROM_REG(data->fan_div[nr]));\r\nmutex_lock(&data->update_lock);\r\ndata->fan_div[nr] = div_to_reg(nr, val);\r\nswitch (nr) {\r\ncase 0:\r\nindx = 0;\r\nkeep_mask = 0xcf;\r\nnew_shift = 4;\r\nbreak;\r\ncase 1:\r\nindx = 0;\r\nkeep_mask = 0x3f;\r\nnew_shift = 6;\r\nbreak;\r\ncase 2:\r\nindx = 1;\r\nkeep_mask = 0x3f;\r\nnew_shift = 6;\r\nbreak;\r\ncase 3:\r\nindx = 2;\r\nkeep_mask = 0xf8;\r\nnew_shift = 0;\r\nbreak;\r\ncase 4:\r\nindx = 2;\r\nkeep_mask = 0x8f;\r\nnew_shift = 4;\r\nbreak;\r\n#ifdef DEBUG\r\ndefault:\r\ndev_warn(dev, "store_fan_div: Unexpected nr seen: %d\n", nr);\r\ncount = -EINVAL;\r\ngoto err_exit;\r\n#endif\r\n}\r\nfan_div_reg = w83791d_read(client, W83791D_REG_FAN_DIV[indx])\r\n& keep_mask;\r\ntmp_fan_div = (data->fan_div[nr] << new_shift) & ~keep_mask;\r\nw83791d_write(client, W83791D_REG_FAN_DIV[indx],\r\nfan_div_reg | tmp_fan_div);\r\nif (nr < 3) {\r\nkeep_mask = ~(1 << (nr + 5));\r\nvbat_reg = w83791d_read(client, W83791D_REG_VBAT)\r\n& keep_mask;\r\ntmp_fan_div = (data->fan_div[nr] << (3 + nr)) & ~keep_mask;\r\nw83791d_write(client, W83791D_REG_VBAT,\r\nvbat_reg | tmp_fan_div);\r\n}\r\ndata->fan_min[nr] = fan_to_reg(min, DIV_FROM_REG(data->fan_div[nr]));\r\nw83791d_write(client, W83791D_REG_FAN_MIN[nr], data->fan_min[nr]);\r\n#ifdef DEBUG\r\nerr_exit:\r\n#endif\r\nmutex_unlock(&data->update_lock);\r\nreturn count;\r\n}\r\nstatic ssize_t show_pwm(struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct sensor_device_attribute *sensor_attr = to_sensor_dev_attr(attr);\r\nint nr = sensor_attr->index;\r\nstruct w83791d_data *data = w83791d_update_device(dev);\r\nreturn sprintf(buf, "%u\n", data->pwm[nr]);\r\n}\r\nstatic ssize_t store_pwm(struct device *dev, struct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct sensor_device_attribute *sensor_attr = to_sensor_dev_attr(attr);\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nstruct w83791d_data *data = i2c_get_clientdata(client);\r\nint nr = sensor_attr->index;\r\nunsigned long val;\r\nif (kstrtoul(buf, 10, &val))\r\nreturn -EINVAL;\r\nmutex_lock(&data->update_lock);\r\ndata->pwm[nr] = clamp_val(val, 0, 255);\r\nw83791d_write(client, W83791D_REG_PWM[nr], data->pwm[nr]);\r\nmutex_unlock(&data->update_lock);\r\nreturn count;\r\n}\r\nstatic ssize_t show_pwmenable(struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct sensor_device_attribute *sensor_attr = to_sensor_dev_attr(attr);\r\nint nr = sensor_attr->index;\r\nstruct w83791d_data *data = w83791d_update_device(dev);\r\nreturn sprintf(buf, "%u\n", data->pwm_enable[nr] + 1);\r\n}\r\nstatic ssize_t store_pwmenable(struct device *dev,\r\nstruct device_attribute *attr, const char *buf, size_t count)\r\n{\r\nstruct sensor_device_attribute *sensor_attr = to_sensor_dev_attr(attr);\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nstruct w83791d_data *data = i2c_get_clientdata(client);\r\nint nr = sensor_attr->index;\r\nunsigned long val;\r\nu8 reg_cfg_tmp;\r\nu8 reg_idx = 0;\r\nu8 val_shift = 0;\r\nu8 keep_mask = 0;\r\nint ret = kstrtoul(buf, 10, &val);\r\nif (ret || val < 1 || val > 3)\r\nreturn -EINVAL;\r\nmutex_lock(&data->update_lock);\r\ndata->pwm_enable[nr] = val - 1;\r\nswitch (nr) {\r\ncase 0:\r\nreg_idx = 0;\r\nval_shift = 2;\r\nkeep_mask = 0xf3;\r\nbreak;\r\ncase 1:\r\nreg_idx = 0;\r\nval_shift = 4;\r\nkeep_mask = 0xcf;\r\nbreak;\r\ncase 2:\r\nreg_idx = 1;\r\nval_shift = 2;\r\nkeep_mask = 0xf3;\r\nbreak;\r\n}\r\nreg_cfg_tmp = w83791d_read(client, W83791D_REG_FAN_CFG[reg_idx]);\r\nreg_cfg_tmp = (reg_cfg_tmp & keep_mask) |\r\ndata->pwm_enable[nr] << val_shift;\r\nw83791d_write(client, W83791D_REG_FAN_CFG[reg_idx], reg_cfg_tmp);\r\nmutex_unlock(&data->update_lock);\r\nreturn count;\r\n}\r\nstatic ssize_t show_temp_target(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct sensor_device_attribute *sensor_attr = to_sensor_dev_attr(attr);\r\nstruct w83791d_data *data = w83791d_update_device(dev);\r\nint nr = sensor_attr->index;\r\nreturn sprintf(buf, "%d\n", TEMP1_FROM_REG(data->temp_target[nr]));\r\n}\r\nstatic ssize_t store_temp_target(struct device *dev,\r\nstruct device_attribute *attr, const char *buf, size_t count)\r\n{\r\nstruct sensor_device_attribute *sensor_attr = to_sensor_dev_attr(attr);\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nstruct w83791d_data *data = i2c_get_clientdata(client);\r\nint nr = sensor_attr->index;\r\nlong val;\r\nu8 target_mask;\r\nif (kstrtol(buf, 10, &val))\r\nreturn -EINVAL;\r\nmutex_lock(&data->update_lock);\r\ndata->temp_target[nr] = TARGET_TEMP_TO_REG(val);\r\ntarget_mask = w83791d_read(client,\r\nW83791D_REG_TEMP_TARGET[nr]) & 0x80;\r\nw83791d_write(client, W83791D_REG_TEMP_TARGET[nr],\r\ndata->temp_target[nr] | target_mask);\r\nmutex_unlock(&data->update_lock);\r\nreturn count;\r\n}\r\nstatic ssize_t show_temp_tolerance(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct sensor_device_attribute *sensor_attr = to_sensor_dev_attr(attr);\r\nstruct w83791d_data *data = w83791d_update_device(dev);\r\nint nr = sensor_attr->index;\r\nreturn sprintf(buf, "%d\n", TEMP1_FROM_REG(data->temp_tolerance[nr]));\r\n}\r\nstatic ssize_t store_temp_tolerance(struct device *dev,\r\nstruct device_attribute *attr, const char *buf, size_t count)\r\n{\r\nstruct sensor_device_attribute *sensor_attr = to_sensor_dev_attr(attr);\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nstruct w83791d_data *data = i2c_get_clientdata(client);\r\nint nr = sensor_attr->index;\r\nunsigned long val;\r\nu8 target_mask;\r\nu8 reg_idx = 0;\r\nu8 val_shift = 0;\r\nu8 keep_mask = 0;\r\nif (kstrtoul(buf, 10, &val))\r\nreturn -EINVAL;\r\nswitch (nr) {\r\ncase 0:\r\nreg_idx = 0;\r\nval_shift = 0;\r\nkeep_mask = 0xf0;\r\nbreak;\r\ncase 1:\r\nreg_idx = 0;\r\nval_shift = 4;\r\nkeep_mask = 0x0f;\r\nbreak;\r\ncase 2:\r\nreg_idx = 1;\r\nval_shift = 0;\r\nkeep_mask = 0xf0;\r\nbreak;\r\n}\r\nmutex_lock(&data->update_lock);\r\ndata->temp_tolerance[nr] = TOL_TEMP_TO_REG(val);\r\ntarget_mask = w83791d_read(client,\r\nW83791D_REG_TEMP_TOL[reg_idx]) & keep_mask;\r\nw83791d_write(client, W83791D_REG_TEMP_TOL[reg_idx],\r\n(data->temp_tolerance[nr] << val_shift) | target_mask);\r\nmutex_unlock(&data->update_lock);\r\nreturn count;\r\n}\r\nstatic ssize_t show_temp1(struct device *dev, struct device_attribute *devattr,\r\nchar *buf)\r\n{\r\nstruct sensor_device_attribute *attr = to_sensor_dev_attr(devattr);\r\nstruct w83791d_data *data = w83791d_update_device(dev);\r\nreturn sprintf(buf, "%d\n", TEMP1_FROM_REG(data->temp1[attr->index]));\r\n}\r\nstatic ssize_t store_temp1(struct device *dev, struct device_attribute *devattr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct sensor_device_attribute *attr = to_sensor_dev_attr(devattr);\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nstruct w83791d_data *data = i2c_get_clientdata(client);\r\nint nr = attr->index;\r\nlong val;\r\nint err;\r\nerr = kstrtol(buf, 10, &val);\r\nif (err)\r\nreturn err;\r\nmutex_lock(&data->update_lock);\r\ndata->temp1[nr] = TEMP1_TO_REG(val);\r\nw83791d_write(client, W83791D_REG_TEMP1[nr], data->temp1[nr]);\r\nmutex_unlock(&data->update_lock);\r\nreturn count;\r\n}\r\nstatic ssize_t show_temp23(struct device *dev, struct device_attribute *devattr,\r\nchar *buf)\r\n{\r\nstruct sensor_device_attribute_2 *attr = to_sensor_dev_attr_2(devattr);\r\nstruct w83791d_data *data = w83791d_update_device(dev);\r\nint nr = attr->nr;\r\nint index = attr->index;\r\nreturn sprintf(buf, "%d\n", TEMP23_FROM_REG(data->temp_add[nr][index]));\r\n}\r\nstatic ssize_t store_temp23(struct device *dev,\r\nstruct device_attribute *devattr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct sensor_device_attribute_2 *attr = to_sensor_dev_attr_2(devattr);\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nstruct w83791d_data *data = i2c_get_clientdata(client);\r\nlong val;\r\nint err;\r\nint nr = attr->nr;\r\nint index = attr->index;\r\nerr = kstrtol(buf, 10, &val);\r\nif (err)\r\nreturn err;\r\nmutex_lock(&data->update_lock);\r\ndata->temp_add[nr][index] = TEMP23_TO_REG(val);\r\nw83791d_write(client, W83791D_REG_TEMP_ADD[nr][index * 2],\r\ndata->temp_add[nr][index] >> 8);\r\nw83791d_write(client, W83791D_REG_TEMP_ADD[nr][index * 2 + 1],\r\ndata->temp_add[nr][index] & 0x80);\r\nmutex_unlock(&data->update_lock);\r\nreturn count;\r\n}\r\nstatic ssize_t show_alarms_reg(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct w83791d_data *data = w83791d_update_device(dev);\r\nreturn sprintf(buf, "%u\n", data->alarms);\r\n}\r\nstatic ssize_t show_beep_enable(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct w83791d_data *data = w83791d_update_device(dev);\r\nreturn sprintf(buf, "%d\n", data->beep_enable);\r\n}\r\nstatic ssize_t show_beep_mask(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct w83791d_data *data = w83791d_update_device(dev);\r\nreturn sprintf(buf, "%d\n", BEEP_MASK_FROM_REG(data->beep_mask));\r\n}\r\nstatic ssize_t store_beep_mask(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nstruct w83791d_data *data = i2c_get_clientdata(client);\r\nint i;\r\nlong val;\r\nint err;\r\nerr = kstrtol(buf, 10, &val);\r\nif (err)\r\nreturn err;\r\nmutex_lock(&data->update_lock);\r\ndata->beep_mask = BEEP_MASK_TO_REG(val) & ~GLOBAL_BEEP_ENABLE_MASK;\r\ndata->beep_mask |= (data->beep_enable << GLOBAL_BEEP_ENABLE_SHIFT);\r\nval = data->beep_mask;\r\nfor (i = 0; i < 3; i++) {\r\nw83791d_write(client, W83791D_REG_BEEP_CTRL[i], (val & 0xff));\r\nval >>= 8;\r\n}\r\nmutex_unlock(&data->update_lock);\r\nreturn count;\r\n}\r\nstatic ssize_t store_beep_enable(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nstruct w83791d_data *data = i2c_get_clientdata(client);\r\nlong val;\r\nint err;\r\nerr = kstrtol(buf, 10, &val);\r\nif (err)\r\nreturn err;\r\nmutex_lock(&data->update_lock);\r\ndata->beep_enable = val ? 1 : 0;\r\ndata->beep_mask &= ~GLOBAL_BEEP_ENABLE_MASK;\r\ndata->beep_mask |= (data->beep_enable << GLOBAL_BEEP_ENABLE_SHIFT);\r\nval = (data->beep_mask >> 8) & 0xff;\r\nw83791d_write(client, W83791D_REG_BEEP_CTRL[1], val);\r\nmutex_unlock(&data->update_lock);\r\nreturn count;\r\n}\r\nstatic ssize_t show_vid_reg(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct w83791d_data *data = w83791d_update_device(dev);\r\nreturn sprintf(buf, "%d\n", vid_from_reg(data->vid, data->vrm));\r\n}\r\nstatic ssize_t show_vrm_reg(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct w83791d_data *data = dev_get_drvdata(dev);\r\nreturn sprintf(buf, "%d\n", data->vrm);\r\n}\r\nstatic ssize_t store_vrm_reg(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct w83791d_data *data = dev_get_drvdata(dev);\r\nunsigned long val;\r\nint err;\r\nerr = kstrtoul(buf, 10, &val);\r\nif (err)\r\nreturn err;\r\nif (val > 255)\r\nreturn -EINVAL;\r\ndata->vrm = val;\r\nreturn count;\r\n}\r\nstatic int w83791d_detect_subclients(struct i2c_client *client)\r\n{\r\nstruct i2c_adapter *adapter = client->adapter;\r\nstruct w83791d_data *data = i2c_get_clientdata(client);\r\nint address = client->addr;\r\nint i, id, err;\r\nu8 val;\r\nid = i2c_adapter_id(adapter);\r\nif (force_subclients[0] == id && force_subclients[1] == address) {\r\nfor (i = 2; i <= 3; i++) {\r\nif (force_subclients[i] < 0x48 ||\r\nforce_subclients[i] > 0x4f) {\r\ndev_err(&client->dev,\r\n"invalid subclient "\r\n"address %d; must be 0x48-0x4f\n",\r\nforce_subclients[i]);\r\nerr = -ENODEV;\r\ngoto error_sc_0;\r\n}\r\n}\r\nw83791d_write(client, W83791D_REG_I2C_SUBADDR,\r\n(force_subclients[2] & 0x07) |\r\n((force_subclients[3] & 0x07) << 4));\r\n}\r\nval = w83791d_read(client, W83791D_REG_I2C_SUBADDR);\r\nif (!(val & 0x08))\r\ndata->lm75[0] = i2c_new_dummy(adapter, 0x48 + (val & 0x7));\r\nif (!(val & 0x80)) {\r\nif ((data->lm75[0] != NULL) &&\r\n((val & 0x7) == ((val >> 4) & 0x7))) {\r\ndev_err(&client->dev,\r\n"duplicate addresses 0x%x, "\r\n"use force_subclient\n",\r\ndata->lm75[0]->addr);\r\nerr = -ENODEV;\r\ngoto error_sc_1;\r\n}\r\ndata->lm75[1] = i2c_new_dummy(adapter,\r\n0x48 + ((val >> 4) & 0x7));\r\n}\r\nreturn 0;\r\nerror_sc_1:\r\nif (data->lm75[0] != NULL)\r\ni2c_unregister_device(data->lm75[0]);\r\nerror_sc_0:\r\nreturn err;\r\n}\r\nstatic int w83791d_detect(struct i2c_client *client,\r\nstruct i2c_board_info *info)\r\n{\r\nstruct i2c_adapter *adapter = client->adapter;\r\nint val1, val2;\r\nunsigned short address = client->addr;\r\nif (!i2c_check_functionality(adapter, I2C_FUNC_SMBUS_BYTE_DATA))\r\nreturn -ENODEV;\r\nif (w83791d_read(client, W83791D_REG_CONFIG) & 0x80)\r\nreturn -ENODEV;\r\nval1 = w83791d_read(client, W83791D_REG_BANK);\r\nval2 = w83791d_read(client, W83791D_REG_CHIPMAN);\r\nif (!(val1 & 0x07)) {\r\nif ((!(val1 & 0x80) && val2 != 0xa3) ||\r\n((val1 & 0x80) && val2 != 0x5c)) {\r\nreturn -ENODEV;\r\n}\r\n}\r\nif (w83791d_read(client, W83791D_REG_I2C_ADDR) != address)\r\nreturn -ENODEV;\r\nval1 = w83791d_read(client, W83791D_REG_BANK) & 0x78;\r\nw83791d_write(client, W83791D_REG_BANK, val1 | 0x80);\r\nval1 = w83791d_read(client, W83791D_REG_WCHIPID);\r\nval2 = w83791d_read(client, W83791D_REG_CHIPMAN);\r\nif (val1 != 0x71 || val2 != 0x5c)\r\nreturn -ENODEV;\r\nstrlcpy(info->type, "w83791d", I2C_NAME_SIZE);\r\nreturn 0;\r\n}\r\nstatic int w83791d_probe(struct i2c_client *client,\r\nconst struct i2c_device_id *id)\r\n{\r\nstruct w83791d_data *data;\r\nstruct device *dev = &client->dev;\r\nint i, err;\r\nu8 has_fanpwm45;\r\n#ifdef DEBUG\r\nint val1;\r\nval1 = w83791d_read(client, W83791D_REG_DID_VID4);\r\ndev_dbg(dev, "Device ID version: %d.%d (0x%02x)\n",\r\n(val1 >> 5) & 0x07, (val1 >> 1) & 0x0f, val1);\r\n#endif\r\ndata = devm_kzalloc(&client->dev, sizeof(struct w83791d_data),\r\nGFP_KERNEL);\r\nif (!data)\r\nreturn -ENOMEM;\r\ni2c_set_clientdata(client, data);\r\nmutex_init(&data->update_lock);\r\nerr = w83791d_detect_subclients(client);\r\nif (err)\r\nreturn err;\r\nw83791d_init_client(client);\r\nfor (i = 0; i < NUMBER_OF_FANIN; i++)\r\ndata->fan_min[i] = w83791d_read(client, W83791D_REG_FAN_MIN[i]);\r\nerr = sysfs_create_group(&client->dev.kobj, &w83791d_group);\r\nif (err)\r\ngoto error3;\r\nhas_fanpwm45 = w83791d_read(client, W83791D_REG_GPIO) & 0x10;\r\nif (has_fanpwm45) {\r\nerr = sysfs_create_group(&client->dev.kobj,\r\n&w83791d_group_fanpwm45);\r\nif (err)\r\ngoto error4;\r\n}\r\ndata->hwmon_dev = hwmon_device_register(dev);\r\nif (IS_ERR(data->hwmon_dev)) {\r\nerr = PTR_ERR(data->hwmon_dev);\r\ngoto error5;\r\n}\r\nreturn 0;\r\nerror5:\r\nif (has_fanpwm45)\r\nsysfs_remove_group(&client->dev.kobj, &w83791d_group_fanpwm45);\r\nerror4:\r\nsysfs_remove_group(&client->dev.kobj, &w83791d_group);\r\nerror3:\r\nif (data->lm75[0] != NULL)\r\ni2c_unregister_device(data->lm75[0]);\r\nif (data->lm75[1] != NULL)\r\ni2c_unregister_device(data->lm75[1]);\r\nreturn err;\r\n}\r\nstatic int w83791d_remove(struct i2c_client *client)\r\n{\r\nstruct w83791d_data *data = i2c_get_clientdata(client);\r\nhwmon_device_unregister(data->hwmon_dev);\r\nsysfs_remove_group(&client->dev.kobj, &w83791d_group);\r\nif (data->lm75[0] != NULL)\r\ni2c_unregister_device(data->lm75[0]);\r\nif (data->lm75[1] != NULL)\r\ni2c_unregister_device(data->lm75[1]);\r\nreturn 0;\r\n}\r\nstatic void w83791d_init_client(struct i2c_client *client)\r\n{\r\nstruct w83791d_data *data = i2c_get_clientdata(client);\r\nu8 tmp;\r\nu8 old_beep;\r\nif (reset || init) {\r\nold_beep = w83791d_read(client, W83791D_REG_BEEP_CONFIG);\r\nif (reset) {\r\nw83791d_write(client, W83791D_REG_CONFIG, 0x80);\r\n}\r\nw83791d_write(client, W83791D_REG_BEEP_CONFIG, old_beep | 0x80);\r\ntmp = w83791d_read(client, W83791D_REG_BEEP_CTRL[1]);\r\nw83791d_write(client, W83791D_REG_BEEP_CTRL[1], tmp & 0xef);\r\nif (init) {\r\ntmp = w83791d_read(client, W83791D_REG_TEMP2_CONFIG);\r\nif (tmp & 1) {\r\nw83791d_write(client, W83791D_REG_TEMP2_CONFIG,\r\ntmp & 0xfe);\r\n}\r\ntmp = w83791d_read(client, W83791D_REG_TEMP3_CONFIG);\r\nif (tmp & 1) {\r\nw83791d_write(client, W83791D_REG_TEMP3_CONFIG,\r\ntmp & 0xfe);\r\n}\r\ntmp = w83791d_read(client, W83791D_REG_CONFIG) & 0xf7;\r\nw83791d_write(client, W83791D_REG_CONFIG, tmp | 0x01);\r\n}\r\n}\r\ndata->vrm = vid_which_vrm();\r\n}\r\nstatic struct w83791d_data *w83791d_update_device(struct device *dev)\r\n{\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nstruct w83791d_data *data = i2c_get_clientdata(client);\r\nint i, j;\r\nu8 reg_array_tmp[3];\r\nu8 vbat_reg;\r\nmutex_lock(&data->update_lock);\r\nif (time_after(jiffies, data->last_updated + (HZ * 3))\r\n|| !data->valid) {\r\ndev_dbg(dev, "Starting w83791d device update\n");\r\nfor (i = 0; i < NUMBER_OF_VIN; i++) {\r\ndata->in[i] = w83791d_read(client,\r\nW83791D_REG_IN[i]);\r\ndata->in_max[i] = w83791d_read(client,\r\nW83791D_REG_IN_MAX[i]);\r\ndata->in_min[i] = w83791d_read(client,\r\nW83791D_REG_IN_MIN[i]);\r\n}\r\nfor (i = 0; i < NUMBER_OF_FANIN; i++) {\r\ndata->fan[i] = w83791d_read(client,\r\nW83791D_REG_FAN[i]);\r\ndata->fan_min[i] = w83791d_read(client,\r\nW83791D_REG_FAN_MIN[i]);\r\n}\r\nfor (i = 0; i < 3; i++) {\r\nreg_array_tmp[i] = w83791d_read(client,\r\nW83791D_REG_FAN_DIV[i]);\r\n}\r\ndata->fan_div[0] = (reg_array_tmp[0] >> 4) & 0x03;\r\ndata->fan_div[1] = (reg_array_tmp[0] >> 6) & 0x03;\r\ndata->fan_div[2] = (reg_array_tmp[1] >> 6) & 0x03;\r\ndata->fan_div[3] = reg_array_tmp[2] & 0x07;\r\ndata->fan_div[4] = (reg_array_tmp[2] >> 4) & 0x07;\r\nvbat_reg = w83791d_read(client, W83791D_REG_VBAT);\r\nfor (i = 0; i < 3; i++)\r\ndata->fan_div[i] |= (vbat_reg >> (3 + i)) & 0x04;\r\nfor (i = 0; i < NUMBER_OF_PWM; i++) {\r\ndata->pwm[i] = w83791d_read(client,\r\nW83791D_REG_PWM[i]);\r\n}\r\nfor (i = 0; i < 2; i++) {\r\nreg_array_tmp[i] = w83791d_read(client,\r\nW83791D_REG_FAN_CFG[i]);\r\n}\r\ndata->pwm_enable[0] = (reg_array_tmp[0] >> 2) & 0x03;\r\ndata->pwm_enable[1] = (reg_array_tmp[0] >> 4) & 0x03;\r\ndata->pwm_enable[2] = (reg_array_tmp[1] >> 2) & 0x03;\r\nfor (i = 0; i < 3; i++) {\r\ndata->temp_target[i] = w83791d_read(client,\r\nW83791D_REG_TEMP_TARGET[i]) & 0x7f;\r\n}\r\nfor (i = 0; i < 2; i++) {\r\nreg_array_tmp[i] = w83791d_read(client,\r\nW83791D_REG_TEMP_TOL[i]);\r\n}\r\ndata->temp_tolerance[0] = reg_array_tmp[0] & 0x0f;\r\ndata->temp_tolerance[1] = (reg_array_tmp[0] >> 4) & 0x0f;\r\ndata->temp_tolerance[2] = reg_array_tmp[1] & 0x0f;\r\nfor (i = 0; i < 3; i++) {\r\ndata->temp1[i] = w83791d_read(client,\r\nW83791D_REG_TEMP1[i]);\r\n}\r\nfor (i = 0; i < 2; i++) {\r\nfor (j = 0; j < 3; j++) {\r\ndata->temp_add[i][j] =\r\n(w83791d_read(client,\r\nW83791D_REG_TEMP_ADD[i][j * 2]) << 8) |\r\nw83791d_read(client,\r\nW83791D_REG_TEMP_ADD[i][j * 2 + 1]);\r\n}\r\n}\r\ndata->alarms =\r\nw83791d_read(client, W83791D_REG_ALARM1) +\r\n(w83791d_read(client, W83791D_REG_ALARM2) << 8) +\r\n(w83791d_read(client, W83791D_REG_ALARM3) << 16);\r\ndata->beep_mask =\r\nw83791d_read(client, W83791D_REG_BEEP_CTRL[0]) +\r\n(w83791d_read(client, W83791D_REG_BEEP_CTRL[1]) << 8) +\r\n(w83791d_read(client, W83791D_REG_BEEP_CTRL[2]) << 16);\r\ndata->beep_enable =\r\n(data->beep_mask >> GLOBAL_BEEP_ENABLE_SHIFT) & 0x01;\r\ni = w83791d_read(client, W83791D_REG_VID_FANDIV);\r\ndata->vid = i & 0x0f;\r\ndata->vid |= (w83791d_read(client, W83791D_REG_DID_VID4) & 0x01)\r\n<< 4;\r\ndata->last_updated = jiffies;\r\ndata->valid = 1;\r\n}\r\nmutex_unlock(&data->update_lock);\r\n#ifdef DEBUG\r\nw83791d_print_debug(data, dev);\r\n#endif\r\nreturn data;\r\n}\r\nstatic void w83791d_print_debug(struct w83791d_data *data, struct device *dev)\r\n{\r\nint i = 0, j = 0;\r\ndev_dbg(dev, "======Start of w83791d debug values======\n");\r\ndev_dbg(dev, "%d set of Voltages: ===>\n", NUMBER_OF_VIN);\r\nfor (i = 0; i < NUMBER_OF_VIN; i++) {\r\ndev_dbg(dev, "vin[%d] is: 0x%02x\n", i, data->in[i]);\r\ndev_dbg(dev, "vin[%d] min is: 0x%02x\n", i, data->in_min[i]);\r\ndev_dbg(dev, "vin[%d] max is: 0x%02x\n", i, data->in_max[i]);\r\n}\r\ndev_dbg(dev, "%d set of Fan Counts/Divisors: ===>\n", NUMBER_OF_FANIN);\r\nfor (i = 0; i < NUMBER_OF_FANIN; i++) {\r\ndev_dbg(dev, "fan[%d] is: 0x%02x\n", i, data->fan[i]);\r\ndev_dbg(dev, "fan[%d] min is: 0x%02x\n", i, data->fan_min[i]);\r\ndev_dbg(dev, "fan_div[%d] is: 0x%02x\n", i, data->fan_div[i]);\r\n}\r\ndev_dbg(dev, "%d set of Temperatures: ===>\n", NUMBER_OF_TEMPIN);\r\nfor (i = 0; i < 3; i++)\r\ndev_dbg(dev, "temp1[%d] is: 0x%02x\n", i, (u8) data->temp1[i]);\r\nfor (i = 0; i < 2; i++) {\r\nfor (j = 0; j < 3; j++) {\r\ndev_dbg(dev, "temp_add[%d][%d] is: 0x%04x\n", i, j,\r\n(u16) data->temp_add[i][j]);\r\n}\r\n}\r\ndev_dbg(dev, "Misc Information: ===>\n");\r\ndev_dbg(dev, "alarm is: 0x%08x\n", data->alarms);\r\ndev_dbg(dev, "beep_mask is: 0x%08x\n", data->beep_mask);\r\ndev_dbg(dev, "beep_enable is: %d\n", data->beep_enable);\r\ndev_dbg(dev, "vid is: 0x%02x\n", data->vid);\r\ndev_dbg(dev, "vrm is: 0x%02x\n", data->vrm);\r\ndev_dbg(dev, "=======End of w83791d debug values========\n");\r\ndev_dbg(dev, "\n");\r\n}
