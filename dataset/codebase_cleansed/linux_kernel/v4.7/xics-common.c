void xics_update_irq_servers(void)\r\n{\r\nint i, j;\r\nstruct device_node *np;\r\nu32 ilen;\r\nconst __be32 *ireg;\r\nu32 hcpuid;\r\nnp = of_get_cpu_node(boot_cpuid, NULL);\r\nBUG_ON(!np);\r\nhcpuid = get_hard_smp_processor_id(boot_cpuid);\r\nxics_default_server = xics_default_distrib_server = hcpuid;\r\npr_devel("xics: xics_default_server = 0x%x\n", xics_default_server);\r\nireg = of_get_property(np, "ibm,ppc-interrupt-gserver#s", &ilen);\r\nif (!ireg) {\r\nof_node_put(np);\r\nreturn;\r\n}\r\ni = ilen / sizeof(int);\r\nfor (j = 0; j < i; j += 2) {\r\nif (be32_to_cpu(ireg[j]) == hcpuid) {\r\nxics_default_distrib_server = be32_to_cpu(ireg[j+1]);\r\nbreak;\r\n}\r\n}\r\npr_devel("xics: xics_default_distrib_server = 0x%x\n",\r\nxics_default_distrib_server);\r\nof_node_put(np);\r\n}\r\nvoid xics_set_cpu_giq(unsigned int gserver, unsigned int join)\r\n{\r\n#ifdef CONFIG_PPC_RTAS\r\nint index;\r\nint status;\r\nif (!rtas_indicator_present(GLOBAL_INTERRUPT_QUEUE, NULL))\r\nreturn;\r\nindex = (1UL << xics_interrupt_server_size) - 1 - gserver;\r\nstatus = rtas_set_indicator_fast(GLOBAL_INTERRUPT_QUEUE, index, join);\r\nWARN(status < 0, "set-indicator(%d, %d, %u) returned %d\n",\r\nGLOBAL_INTERRUPT_QUEUE, index, join, status);\r\n#endif\r\n}\r\nvoid xics_setup_cpu(void)\r\n{\r\nicp_ops->set_priority(LOWEST_PRIORITY);\r\nxics_set_cpu_giq(xics_default_distrib_server, 1);\r\n}\r\nvoid xics_mask_unknown_vec(unsigned int vec)\r\n{\r\nstruct ics *ics;\r\npr_err("Interrupt 0x%x (real) is invalid, disabling it.\n", vec);\r\nlist_for_each_entry(ics, &ics_list, link)\r\nics->mask_unknown(ics, vec);\r\n}\r\nstatic void xics_request_ipi(void)\r\n{\r\nunsigned int ipi;\r\nipi = irq_create_mapping(xics_host, XICS_IPI);\r\nBUG_ON(ipi == NO_IRQ);\r\nBUG_ON(request_irq(ipi, icp_ops->ipi_action,\r\nIRQF_PERCPU | IRQF_NO_THREAD, "IPI", NULL));\r\n}\r\nvoid __init xics_smp_probe(void)\r\n{\r\nsmp_ops->cause_ipi = icp_ops->cause_ipi;\r\nxics_request_ipi();\r\n}\r\nvoid xics_teardown_cpu(void)\r\n{\r\nstruct xics_cppr *os_cppr = this_cpu_ptr(&xics_cppr);\r\nos_cppr->index = 0;\r\nicp_ops->set_priority(0);\r\nicp_ops->teardown_cpu();\r\n}\r\nvoid xics_kexec_teardown_cpu(int secondary)\r\n{\r\nxics_teardown_cpu();\r\nicp_ops->flush_ipi();\r\nif (secondary)\r\nxics_set_cpu_giq(xics_default_distrib_server, 0);\r\n}\r\nvoid xics_migrate_irqs_away(void)\r\n{\r\nint cpu = smp_processor_id(), hw_cpu = hard_smp_processor_id();\r\nunsigned int irq, virq;\r\nstruct irq_desc *desc;\r\nif (hw_cpu == xics_default_server)\r\nxics_update_irq_servers();\r\nicp_ops->set_priority(0);\r\nxics_set_cpu_giq(xics_default_distrib_server, 0);\r\nicp_ops->set_priority(DEFAULT_PRIORITY);\r\nfor_each_irq_desc(virq, desc) {\r\nstruct irq_chip *chip;\r\nlong server;\r\nunsigned long flags;\r\nstruct ics *ics;\r\nif (virq < NUM_ISA_INTERRUPTS)\r\ncontinue;\r\nif (!desc->action)\r\ncontinue;\r\nif (desc->irq_data.domain != xics_host)\r\ncontinue;\r\nirq = desc->irq_data.hwirq;\r\nif (irq == XICS_IPI || irq == XICS_IRQ_SPURIOUS)\r\ncontinue;\r\nchip = irq_desc_get_chip(desc);\r\nif (!chip || !chip->irq_set_affinity)\r\ncontinue;\r\nraw_spin_lock_irqsave(&desc->lock, flags);\r\nserver = -1;\r\nics = irq_desc_get_chip_data(desc);\r\nif (ics)\r\nserver = ics->get_server(ics, irq);\r\nif (server < 0) {\r\nprintk(KERN_ERR "%s: Can't find server for irq %d\n",\r\n__func__, irq);\r\ngoto unlock;\r\n}\r\nif (server != hw_cpu)\r\ngoto unlock;\r\nif (cpu_online(cpu))\r\npr_warning("IRQ %u affinity broken off cpu %u\n",\r\nvirq, cpu);\r\nraw_spin_unlock_irqrestore(&desc->lock, flags);\r\nirq_set_affinity(virq, cpu_all_mask);\r\ncontinue;\r\nunlock:\r\nraw_spin_unlock_irqrestore(&desc->lock, flags);\r\n}\r\n}\r\nint xics_get_irq_server(unsigned int virq, const struct cpumask *cpumask,\r\nunsigned int strict_check)\r\n{\r\nif (!distribute_irqs)\r\nreturn xics_default_server;\r\nif (!cpumask_subset(cpu_possible_mask, cpumask)) {\r\nint server = cpumask_first_and(cpu_online_mask, cpumask);\r\nif (server < nr_cpu_ids)\r\nreturn get_hard_smp_processor_id(server);\r\nif (strict_check)\r\nreturn -1;\r\n}\r\nif (cpumask_equal(cpu_online_mask, cpu_present_mask))\r\nreturn xics_default_distrib_server;\r\nreturn xics_default_server;\r\n}\r\nstatic int xics_host_match(struct irq_domain *h, struct device_node *node,\r\nenum irq_domain_bus_token bus_token)\r\n{\r\nstruct ics *ics;\r\nlist_for_each_entry(ics, &ics_list, link)\r\nif (ics->host_match(ics, node))\r\nreturn 1;\r\nreturn 0;\r\n}\r\nstatic void xics_ipi_unmask(struct irq_data *d) { }\r\nstatic void xics_ipi_mask(struct irq_data *d) { }\r\nstatic int xics_host_map(struct irq_domain *h, unsigned int virq,\r\nirq_hw_number_t hw)\r\n{\r\nstruct ics *ics;\r\npr_devel("xics: map virq %d, hwirq 0x%lx\n", virq, hw);\r\nirq_set_status_flags(virq, IRQ_LEVEL);\r\nif (hw == XICS_IPI) {\r\nirq_set_chip_and_handler(virq, &xics_ipi_chip,\r\nhandle_percpu_irq);\r\nreturn 0;\r\n}\r\nlist_for_each_entry(ics, &ics_list, link)\r\nif (ics->map(ics, virq) == 0)\r\nreturn 0;\r\nreturn -EINVAL;\r\n}\r\nstatic int xics_host_xlate(struct irq_domain *h, struct device_node *ct,\r\nconst u32 *intspec, unsigned int intsize,\r\nirq_hw_number_t *out_hwirq, unsigned int *out_flags)\r\n{\r\n*out_hwirq = intspec[0];\r\n*out_flags = IRQ_TYPE_LEVEL_LOW;\r\nreturn 0;\r\n}\r\nstatic void __init xics_init_host(void)\r\n{\r\nxics_host = irq_domain_add_tree(NULL, &xics_host_ops, NULL);\r\nBUG_ON(xics_host == NULL);\r\nirq_set_default_host(xics_host);\r\n}\r\nvoid __init xics_register_ics(struct ics *ics)\r\n{\r\nlist_add(&ics->link, &ics_list);\r\n}\r\nstatic void __init xics_get_server_size(void)\r\n{\r\nstruct device_node *np;\r\nconst __be32 *isize;\r\nnp = of_find_compatible_node(NULL, NULL, "ibm,ppc-xics");\r\nif (!np)\r\nreturn;\r\nisize = of_get_property(np, "ibm,interrupt-server#-size", NULL);\r\nif (!isize)\r\nreturn;\r\nxics_interrupt_server_size = be32_to_cpu(*isize);\r\nof_node_put(np);\r\n}\r\nvoid __init xics_init(void)\r\n{\r\nint rc = -1;\r\nif (firmware_has_feature(FW_FEATURE_LPAR))\r\nrc = icp_hv_init();\r\nif (rc < 0)\r\nrc = icp_native_init();\r\nif (rc < 0) {\r\npr_warning("XICS: Cannot find a Presentation Controller !\n");\r\nreturn;\r\n}\r\nppc_md.get_irq = icp_ops->get_irq;\r\nxics_ipi_chip.irq_eoi = icp_ops->eoi;\r\nrc = ics_rtas_init();\r\nif (rc < 0)\r\nrc = ics_opal_init();\r\nif (rc < 0)\r\npr_warning("XICS: Cannot find a Source Controller !\n");\r\nxics_get_server_size();\r\nxics_update_irq_servers();\r\nxics_init_host();\r\nxics_setup_cpu();\r\n}
