void vivid_clear_fb(struct vivid_dev *dev)\r\n{\r\nvoid *p = dev->video_vbase;\r\nconst u16 *rgb = rgb555;\r\nunsigned x, y;\r\nif (dev->fb_defined.green.length == 6)\r\nrgb = rgb565;\r\nfor (y = 0; y < dev->display_height; y++) {\r\nu16 *d = p;\r\nfor (x = 0; x < dev->display_width; x++)\r\nd[x] = rgb[(y / 16 + x / 16) % 16];\r\np += dev->display_byte_stride;\r\n}\r\n}\r\nstatic int vivid_fb_ioctl(struct fb_info *info, unsigned cmd, unsigned long arg)\r\n{\r\nstruct vivid_dev *dev = (struct vivid_dev *)info->par;\r\nswitch (cmd) {\r\ncase FBIOGET_VBLANK: {\r\nstruct fb_vblank vblank;\r\nmemset(&vblank, 0, sizeof(vblank));\r\nvblank.flags = FB_VBLANK_HAVE_COUNT | FB_VBLANK_HAVE_VCOUNT |\r\nFB_VBLANK_HAVE_VSYNC;\r\nvblank.count = 0;\r\nvblank.vcount = 0;\r\nvblank.hcount = 0;\r\nif (copy_to_user((void __user *)arg, &vblank, sizeof(vblank)))\r\nreturn -EFAULT;\r\nreturn 0;\r\n}\r\ndefault:\r\ndprintk(dev, 1, "Unknown ioctl %08x\n", cmd);\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int vivid_fb_set_var(struct vivid_dev *dev, struct fb_var_screeninfo *var)\r\n{\r\ndprintk(dev, 1, "vivid_fb_set_var\n");\r\nif (var->bits_per_pixel != 16) {\r\ndprintk(dev, 1, "vivid_fb_set_var - Invalid bpp\n");\r\nreturn -EINVAL;\r\n}\r\ndev->display_byte_stride = var->xres * dev->bytes_per_pixel;\r\nreturn 0;\r\n}\r\nstatic int vivid_fb_get_fix(struct vivid_dev *dev, struct fb_fix_screeninfo *fix)\r\n{\r\ndprintk(dev, 1, "vivid_fb_get_fix\n");\r\nmemset(fix, 0, sizeof(struct fb_fix_screeninfo));\r\nstrlcpy(fix->id, "vioverlay fb", sizeof(fix->id));\r\nfix->smem_start = dev->video_pbase;\r\nfix->smem_len = dev->video_buffer_size;\r\nfix->type = FB_TYPE_PACKED_PIXELS;\r\nfix->visual = FB_VISUAL_TRUECOLOR;\r\nfix->xpanstep = 1;\r\nfix->ypanstep = 1;\r\nfix->ywrapstep = 0;\r\nfix->line_length = dev->display_byte_stride;\r\nfix->accel = FB_ACCEL_NONE;\r\nreturn 0;\r\n}\r\nstatic int _vivid_fb_check_var(struct fb_var_screeninfo *var, struct vivid_dev *dev)\r\n{\r\ndprintk(dev, 1, "vivid_fb_check_var\n");\r\nvar->bits_per_pixel = 16;\r\nif (var->green.length == 5) {\r\nvar->red.offset = 10;\r\nvar->red.length = 5;\r\nvar->green.offset = 5;\r\nvar->green.length = 5;\r\nvar->blue.offset = 0;\r\nvar->blue.length = 5;\r\nvar->transp.offset = 15;\r\nvar->transp.length = 1;\r\n} else {\r\nvar->red.offset = 11;\r\nvar->red.length = 5;\r\nvar->green.offset = 5;\r\nvar->green.length = 6;\r\nvar->blue.offset = 0;\r\nvar->blue.length = 5;\r\nvar->transp.offset = 0;\r\nvar->transp.length = 0;\r\n}\r\nvar->xoffset = var->yoffset = 0;\r\nvar->left_margin = var->upper_margin = 0;\r\nvar->nonstd = 0;\r\nvar->vmode &= ~FB_VMODE_MASK;\r\nvar->vmode = FB_VMODE_NONINTERLACED;\r\nvar->hsync_len = 24;\r\nvar->vsync_len = 2;\r\nvar->pixclock = 84316;\r\nvar->right_margin = 776;\r\nvar->lower_margin = 591;\r\nreturn 0;\r\n}\r\nstatic int vivid_fb_check_var(struct fb_var_screeninfo *var, struct fb_info *info)\r\n{\r\nstruct vivid_dev *dev = (struct vivid_dev *) info->par;\r\ndprintk(dev, 1, "vivid_fb_check_var\n");\r\nreturn _vivid_fb_check_var(var, dev);\r\n}\r\nstatic int vivid_fb_pan_display(struct fb_var_screeninfo *var, struct fb_info *info)\r\n{\r\nreturn 0;\r\n}\r\nstatic int vivid_fb_set_par(struct fb_info *info)\r\n{\r\nint rc = 0;\r\nstruct vivid_dev *dev = (struct vivid_dev *) info->par;\r\ndprintk(dev, 1, "vivid_fb_set_par\n");\r\nrc = vivid_fb_set_var(dev, &info->var);\r\nvivid_fb_get_fix(dev, &info->fix);\r\nreturn rc;\r\n}\r\nstatic int vivid_fb_setcolreg(unsigned regno, unsigned red, unsigned green,\r\nunsigned blue, unsigned transp,\r\nstruct fb_info *info)\r\n{\r\nu32 color, *palette;\r\nif (regno >= info->cmap.len)\r\nreturn -EINVAL;\r\ncolor = ((transp & 0xFF00) << 16) | ((red & 0xFF00) << 8) |\r\n(green & 0xFF00) | ((blue & 0xFF00) >> 8);\r\nif (regno >= 16)\r\nreturn -EINVAL;\r\npalette = info->pseudo_palette;\r\nif (info->var.bits_per_pixel == 16) {\r\nswitch (info->var.green.length) {\r\ncase 6:\r\ncolor = (red & 0xf800) |\r\n((green & 0xfc00) >> 5) |\r\n((blue & 0xf800) >> 11);\r\nbreak;\r\ncase 5:\r\ncolor = ((red & 0xf800) >> 1) |\r\n((green & 0xf800) >> 6) |\r\n((blue & 0xf800) >> 11) |\r\n(transp ? 0x8000 : 0);\r\nbreak;\r\n}\r\n}\r\npalette[regno] = color;\r\nreturn 0;\r\n}\r\nstatic int vivid_fb_blank(int blank_mode, struct fb_info *info)\r\n{\r\nstruct vivid_dev *dev = (struct vivid_dev *)info->par;\r\ndprintk(dev, 1, "Set blanking mode : %d\n", blank_mode);\r\nswitch (blank_mode) {\r\ncase FB_BLANK_UNBLANK:\r\nbreak;\r\ncase FB_BLANK_NORMAL:\r\ncase FB_BLANK_HSYNC_SUSPEND:\r\ncase FB_BLANK_VSYNC_SUSPEND:\r\ncase FB_BLANK_POWERDOWN:\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic int vivid_fb_init_vidmode(struct vivid_dev *dev)\r\n{\r\nstruct v4l2_rect start_window;\r\ndev->bits_per_pixel = 16;\r\ndev->bytes_per_pixel = dev->bits_per_pixel / 8;\r\nstart_window.width = MAX_OSD_WIDTH;\r\nstart_window.left = 0;\r\ndev->display_byte_stride = start_window.width * dev->bytes_per_pixel;\r\nstart_window.height = MAX_OSD_HEIGHT;\r\nstart_window.top = 0;\r\ndev->display_width = start_window.width;\r\ndev->display_height = start_window.height;\r\ndev->fb_defined.xres = dev->display_width;\r\ndev->fb_defined.yres = dev->display_height;\r\ndev->fb_defined.xres_virtual = dev->display_width;\r\ndev->fb_defined.yres_virtual = dev->display_height;\r\ndev->fb_defined.bits_per_pixel = dev->bits_per_pixel;\r\ndev->fb_defined.vmode = FB_VMODE_NONINTERLACED;\r\ndev->fb_defined.left_margin = start_window.left + 1;\r\ndev->fb_defined.upper_margin = start_window.top + 1;\r\ndev->fb_defined.accel_flags = FB_ACCEL_NONE;\r\ndev->fb_defined.nonstd = 0;\r\ndev->fb_defined.green.length = 5;\r\n_vivid_fb_check_var(&dev->fb_defined, dev);\r\nvivid_fb_get_fix(dev, &dev->fb_fix);\r\ndev->fb_info.node = -1;\r\ndev->fb_info.flags = FBINFO_FLAG_DEFAULT;\r\ndev->fb_info.fbops = &vivid_fb_ops;\r\ndev->fb_info.par = dev;\r\ndev->fb_info.var = dev->fb_defined;\r\ndev->fb_info.fix = dev->fb_fix;\r\ndev->fb_info.screen_base = (u8 __iomem *)dev->video_vbase;\r\ndev->fb_info.fbops = &vivid_fb_ops;\r\ndev->fb_info.monspecs.hfmin = 8000;\r\ndev->fb_info.monspecs.hfmax = 70000;\r\ndev->fb_info.monspecs.vfmin = 10;\r\ndev->fb_info.monspecs.vfmax = 100;\r\nif (fb_alloc_cmap(&dev->fb_info.cmap, 256, 1)) {\r\npr_err("abort, unable to alloc cmap\n");\r\nreturn -ENOMEM;\r\n}\r\ndev->fb_info.pseudo_palette = kmalloc_array(16, sizeof(u32), GFP_KERNEL);\r\nreturn dev->fb_info.pseudo_palette ? 0 : -ENOMEM;\r\n}\r\nvoid vivid_fb_release_buffers(struct vivid_dev *dev)\r\n{\r\nif (dev->video_vbase == NULL)\r\nreturn;\r\nif (dev->fb_info.cmap.len)\r\nfb_dealloc_cmap(&dev->fb_info.cmap);\r\nkfree(dev->fb_info.pseudo_palette);\r\nkfree(dev->video_vbase);\r\n}\r\nint vivid_fb_init(struct vivid_dev *dev)\r\n{\r\nint ret;\r\ndev->video_buffer_size = MAX_OSD_HEIGHT * MAX_OSD_WIDTH * 2;\r\ndev->video_vbase = kzalloc(dev->video_buffer_size, GFP_KERNEL | GFP_DMA32);\r\nif (dev->video_vbase == NULL)\r\nreturn -ENOMEM;\r\ndev->video_pbase = virt_to_phys(dev->video_vbase);\r\npr_info("Framebuffer at 0x%lx, mapped to 0x%p, size %dk\n",\r\ndev->video_pbase, dev->video_vbase,\r\ndev->video_buffer_size / 1024);\r\nret = vivid_fb_init_vidmode(dev);\r\nif (ret) {\r\nvivid_fb_release_buffers(dev);\r\nreturn ret;\r\n}\r\nvivid_clear_fb(dev);\r\nif (register_framebuffer(&dev->fb_info) < 0) {\r\nvivid_fb_release_buffers(dev);\r\nreturn -EINVAL;\r\n}\r\nvivid_fb_set_par(&dev->fb_info);\r\nreturn 0;\r\n}
