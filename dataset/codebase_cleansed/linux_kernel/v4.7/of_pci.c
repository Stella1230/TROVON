static inline int __of_pci_pci_compare(struct device_node *node,\r\nunsigned int data)\r\n{\r\nint devfn;\r\ndevfn = of_pci_get_devfn(node);\r\nif (devfn < 0)\r\nreturn 0;\r\nreturn devfn == data;\r\n}\r\nstruct device_node *of_pci_find_child_device(struct device_node *parent,\r\nunsigned int devfn)\r\n{\r\nstruct device_node *node, *node2;\r\nfor_each_child_of_node(parent, node) {\r\nif (__of_pci_pci_compare(node, devfn))\r\nreturn node;\r\nif (!strcmp(node->name, "multifunc-device")) {\r\nfor_each_child_of_node(node, node2) {\r\nif (__of_pci_pci_compare(node2, devfn)) {\r\nof_node_put(node);\r\nreturn node2;\r\n}\r\n}\r\n}\r\n}\r\nreturn NULL;\r\n}\r\nint of_pci_get_devfn(struct device_node *np)\r\n{\r\nunsigned int size;\r\nconst __be32 *reg;\r\nreg = of_get_property(np, "reg", &size);\r\nif (!reg || size < 5 * sizeof(__be32))\r\nreturn -EINVAL;\r\nreturn (be32_to_cpup(reg) >> 8) & 0xff;\r\n}\r\nint of_pci_parse_bus_range(struct device_node *node, struct resource *res)\r\n{\r\nconst __be32 *values;\r\nint len;\r\nvalues = of_get_property(node, "bus-range", &len);\r\nif (!values || len < sizeof(*values) * 2)\r\nreturn -EINVAL;\r\nres->name = node->name;\r\nres->start = be32_to_cpup(values++);\r\nres->end = be32_to_cpup(values);\r\nres->flags = IORESOURCE_BUS;\r\nreturn 0;\r\n}\r\nint of_get_pci_domain_nr(struct device_node *node)\r\n{\r\nconst __be32 *value;\r\nint len;\r\nu16 domain;\r\nvalue = of_get_property(node, "linux,pci-domain", &len);\r\nif (!value || len < sizeof(*value))\r\nreturn -EINVAL;\r\ndomain = (u16)be32_to_cpup(value);\r\nreturn domain;\r\n}\r\nvoid of_pci_check_probe_only(void)\r\n{\r\nu32 val;\r\nint ret;\r\nret = of_property_read_u32(of_chosen, "linux,pci-probe-only", &val);\r\nif (ret) {\r\nif (ret == -ENODATA || ret == -EOVERFLOW)\r\npr_warn("linux,pci-probe-only without valid value, ignoring\n");\r\nreturn;\r\n}\r\nif (val)\r\npci_add_flags(PCI_PROBE_ONLY);\r\nelse\r\npci_clear_flags(PCI_PROBE_ONLY);\r\npr_info("PCI: PROBE_ONLY %sabled\n", val ? "en" : "dis");\r\n}\r\nint of_pci_get_host_bridge_resources(struct device_node *dev,\r\nunsigned char busno, unsigned char bus_max,\r\nstruct list_head *resources, resource_size_t *io_base)\r\n{\r\nstruct resource_entry *window;\r\nstruct resource *res;\r\nstruct resource *bus_range;\r\nstruct of_pci_range range;\r\nstruct of_pci_range_parser parser;\r\nchar range_type[4];\r\nint err;\r\nif (io_base)\r\n*io_base = (resource_size_t)OF_BAD_ADDR;\r\nbus_range = kzalloc(sizeof(*bus_range), GFP_KERNEL);\r\nif (!bus_range)\r\nreturn -ENOMEM;\r\npr_info("PCI host bridge %s ranges:\n", dev->full_name);\r\nerr = of_pci_parse_bus_range(dev, bus_range);\r\nif (err) {\r\nbus_range->start = busno;\r\nbus_range->end = bus_max;\r\nbus_range->flags = IORESOURCE_BUS;\r\npr_info(" No bus range found for %s, using %pR\n",\r\ndev->full_name, bus_range);\r\n} else {\r\nif (bus_range->end > bus_range->start + bus_max)\r\nbus_range->end = bus_range->start + bus_max;\r\n}\r\npci_add_resource(resources, bus_range);\r\nerr = of_pci_range_parser_init(&parser, dev);\r\nif (err)\r\ngoto parse_failed;\r\npr_debug("Parsing ranges property...\n");\r\nfor_each_of_pci_range(&parser, &range) {\r\nif ((range.flags & IORESOURCE_TYPE_BITS) == IORESOURCE_IO)\r\nsnprintf(range_type, 4, " IO");\r\nelse if ((range.flags & IORESOURCE_TYPE_BITS) == IORESOURCE_MEM)\r\nsnprintf(range_type, 4, "MEM");\r\nelse\r\nsnprintf(range_type, 4, "err");\r\npr_info(" %s %#010llx..%#010llx -> %#010llx\n", range_type,\r\nrange.cpu_addr, range.cpu_addr + range.size - 1,\r\nrange.pci_addr);\r\nif (range.cpu_addr == OF_BAD_ADDR || range.size == 0)\r\ncontinue;\r\nres = kzalloc(sizeof(struct resource), GFP_KERNEL);\r\nif (!res) {\r\nerr = -ENOMEM;\r\ngoto parse_failed;\r\n}\r\nerr = of_pci_range_to_resource(&range, dev, res);\r\nif (err) {\r\nkfree(res);\r\ncontinue;\r\n}\r\nif (resource_type(res) == IORESOURCE_IO) {\r\nif (!io_base) {\r\npr_err("I/O range found for %s. Please provide an io_base pointer to save CPU base address\n",\r\ndev->full_name);\r\nerr = -EINVAL;\r\ngoto conversion_failed;\r\n}\r\nif (*io_base != (resource_size_t)OF_BAD_ADDR)\r\npr_warn("More than one I/O resource converted for %s. CPU base address for old range lost!\n",\r\ndev->full_name);\r\n*io_base = range.cpu_addr;\r\n}\r\npci_add_resource_offset(resources, res, res->start - range.pci_addr);\r\n}\r\nreturn 0;\r\nconversion_failed:\r\nkfree(res);\r\nparse_failed:\r\nresource_list_for_each_entry(window, resources)\r\nkfree(window->res);\r\npci_free_resource_list(resources);\r\nreturn err;\r\n}\r\nint of_pci_msi_chip_add(struct msi_controller *chip)\r\n{\r\nif (!of_property_read_bool(chip->of_node, "msi-controller"))\r\nreturn -EINVAL;\r\nmutex_lock(&of_pci_msi_chip_mutex);\r\nlist_add(&chip->list, &of_pci_msi_chip_list);\r\nmutex_unlock(&of_pci_msi_chip_mutex);\r\nreturn 0;\r\n}\r\nvoid of_pci_msi_chip_remove(struct msi_controller *chip)\r\n{\r\nmutex_lock(&of_pci_msi_chip_mutex);\r\nlist_del(&chip->list);\r\nmutex_unlock(&of_pci_msi_chip_mutex);\r\n}\r\nstruct msi_controller *of_pci_find_msi_chip_by_node(struct device_node *of_node)\r\n{\r\nstruct msi_controller *c;\r\nmutex_lock(&of_pci_msi_chip_mutex);\r\nlist_for_each_entry(c, &of_pci_msi_chip_list, list) {\r\nif (c->of_node == of_node) {\r\nmutex_unlock(&of_pci_msi_chip_mutex);\r\nreturn c;\r\n}\r\n}\r\nmutex_unlock(&of_pci_msi_chip_mutex);\r\nreturn NULL;\r\n}
