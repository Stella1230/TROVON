static int dsi_pll_enable(struct msm_dsi_pll *pll)\r\n{\r\nint i, ret = 0;\r\nif (unlikely(pll->pll_on))\r\nreturn 0;\r\nfor (i = 0; i < pll->en_seq_cnt; i++) {\r\nret = pll->enable_seqs[i](pll);\r\nDBG("DSI PLL %s after sequence #%d",\r\nret ? "unlocked" : "locked", i + 1);\r\nif (!ret)\r\nbreak;\r\n}\r\nif (ret) {\r\nDRM_ERROR("DSI PLL failed to lock\n");\r\nreturn ret;\r\n}\r\npll->pll_on = true;\r\nreturn 0;\r\n}\r\nstatic void dsi_pll_disable(struct msm_dsi_pll *pll)\r\n{\r\nif (unlikely(!pll->pll_on))\r\nreturn;\r\npll->disable_seq(pll);\r\npll->pll_on = false;\r\n}\r\nlong msm_dsi_pll_helper_clk_round_rate(struct clk_hw *hw,\r\nunsigned long rate, unsigned long *parent_rate)\r\n{\r\nstruct msm_dsi_pll *pll = hw_clk_to_pll(hw);\r\nif (rate < pll->min_rate)\r\nreturn pll->min_rate;\r\nelse if (rate > pll->max_rate)\r\nreturn pll->max_rate;\r\nelse\r\nreturn rate;\r\n}\r\nint msm_dsi_pll_helper_clk_prepare(struct clk_hw *hw)\r\n{\r\nstruct msm_dsi_pll *pll = hw_clk_to_pll(hw);\r\nreturn dsi_pll_enable(pll);\r\n}\r\nvoid msm_dsi_pll_helper_clk_unprepare(struct clk_hw *hw)\r\n{\r\nstruct msm_dsi_pll *pll = hw_clk_to_pll(hw);\r\ndsi_pll_disable(pll);\r\n}\r\nvoid msm_dsi_pll_helper_unregister_clks(struct platform_device *pdev,\r\nstruct clk **clks, u32 num_clks)\r\n{\r\nof_clk_del_provider(pdev->dev.of_node);\r\nif (!num_clks || !clks)\r\nreturn;\r\ndo {\r\nclk_unregister(clks[--num_clks]);\r\nclks[num_clks] = NULL;\r\n} while (num_clks);\r\n}\r\nint msm_dsi_pll_get_clk_provider(struct msm_dsi_pll *pll,\r\nstruct clk **byte_clk_provider, struct clk **pixel_clk_provider)\r\n{\r\nif (pll->get_provider)\r\nreturn pll->get_provider(pll,\r\nbyte_clk_provider,\r\npixel_clk_provider);\r\nreturn -EINVAL;\r\n}\r\nvoid msm_dsi_pll_destroy(struct msm_dsi_pll *pll)\r\n{\r\nif (pll->destroy)\r\npll->destroy(pll);\r\n}\r\nvoid msm_dsi_pll_save_state(struct msm_dsi_pll *pll)\r\n{\r\nif (pll->save_state) {\r\npll->save_state(pll);\r\npll->state_saved = true;\r\n}\r\n}\r\nint msm_dsi_pll_restore_state(struct msm_dsi_pll *pll)\r\n{\r\nint ret;\r\nif (pll->restore_state && pll->state_saved) {\r\nret = pll->restore_state(pll);\r\nif (ret)\r\nreturn ret;\r\npll->state_saved = false;\r\n}\r\nreturn 0;\r\n}\r\nstruct msm_dsi_pll *msm_dsi_pll_init(struct platform_device *pdev,\r\nenum msm_dsi_phy_type type, int id)\r\n{\r\nstruct device *dev = &pdev->dev;\r\nstruct msm_dsi_pll *pll;\r\nswitch (type) {\r\ncase MSM_DSI_PHY_28NM_HPM:\r\ncase MSM_DSI_PHY_28NM_LP:\r\npll = msm_dsi_pll_28nm_init(pdev, type, id);\r\nbreak;\r\ncase MSM_DSI_PHY_28NM_8960:\r\npll = msm_dsi_pll_28nm_8960_init(pdev, id);\r\nbreak;\r\ndefault:\r\npll = ERR_PTR(-ENXIO);\r\nbreak;\r\n}\r\nif (IS_ERR(pll)) {\r\ndev_err(dev, "%s: failed to init DSI PLL\n", __func__);\r\nreturn NULL;\r\n}\r\npll->type = type;\r\nDBG("DSI:%d PLL registered", id);\r\nreturn pll;\r\n}
