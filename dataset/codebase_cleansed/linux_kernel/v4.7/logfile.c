static bool ntfs_check_restart_page_header(struct inode *vi,\r\nRESTART_PAGE_HEADER *rp, s64 pos)\r\n{\r\nu32 logfile_system_page_size, logfile_log_page_size;\r\nu16 ra_ofs, usa_count, usa_ofs, usa_end = 0;\r\nbool have_usa = true;\r\nntfs_debug("Entering.");\r\nlogfile_system_page_size = le32_to_cpu(rp->system_page_size);\r\nlogfile_log_page_size = le32_to_cpu(rp->log_page_size);\r\nif (logfile_system_page_size < NTFS_BLOCK_SIZE ||\r\nlogfile_log_page_size < NTFS_BLOCK_SIZE ||\r\nlogfile_system_page_size &\r\n(logfile_system_page_size - 1) ||\r\n!is_power_of_2(logfile_log_page_size)) {\r\nntfs_error(vi->i_sb, "$LogFile uses unsupported page size.");\r\nreturn false;\r\n}\r\nif (pos && pos != logfile_system_page_size) {\r\nntfs_error(vi->i_sb, "Found restart area in incorrect "\r\n"position in $LogFile.");\r\nreturn false;\r\n}\r\nif (sle16_to_cpu(rp->major_ver) != 1 ||\r\nsle16_to_cpu(rp->minor_ver) != 1) {\r\nntfs_error(vi->i_sb, "$LogFile version %i.%i is not "\r\n"supported. (This driver supports version "\r\n"1.1 only.)", (int)sle16_to_cpu(rp->major_ver),\r\n(int)sle16_to_cpu(rp->minor_ver));\r\nreturn false;\r\n}\r\nif (ntfs_is_chkd_record(rp->magic) && !le16_to_cpu(rp->usa_count)) {\r\nhave_usa = false;\r\ngoto skip_usa_checks;\r\n}\r\nusa_count = 1 + (logfile_system_page_size >> NTFS_BLOCK_SIZE_BITS);\r\nif (usa_count != le16_to_cpu(rp->usa_count)) {\r\nntfs_error(vi->i_sb, "$LogFile restart page specifies "\r\n"inconsistent update sequence array count.");\r\nreturn false;\r\n}\r\nusa_ofs = le16_to_cpu(rp->usa_ofs);\r\nusa_end = usa_ofs + usa_count * sizeof(u16);\r\nif (usa_ofs < sizeof(RESTART_PAGE_HEADER) ||\r\nusa_end > NTFS_BLOCK_SIZE - sizeof(u16)) {\r\nntfs_error(vi->i_sb, "$LogFile restart page specifies "\r\n"inconsistent update sequence array offset.");\r\nreturn false;\r\n}\r\nskip_usa_checks:\r\nra_ofs = le16_to_cpu(rp->restart_area_offset);\r\nif (ra_ofs & 7 || (have_usa ? ra_ofs < usa_end :\r\nra_ofs < sizeof(RESTART_PAGE_HEADER)) ||\r\nra_ofs > logfile_system_page_size) {\r\nntfs_error(vi->i_sb, "$LogFile restart page specifies "\r\n"inconsistent restart area offset.");\r\nreturn false;\r\n}\r\nif (!ntfs_is_chkd_record(rp->magic) && sle64_to_cpu(rp->chkdsk_lsn)) {\r\nntfs_error(vi->i_sb, "$LogFile restart page is not modified "\r\n"by chkdsk but a chkdsk LSN is specified.");\r\nreturn false;\r\n}\r\nntfs_debug("Done.");\r\nreturn true;\r\n}\r\nstatic bool ntfs_check_restart_area(struct inode *vi, RESTART_PAGE_HEADER *rp)\r\n{\r\nu64 file_size;\r\nRESTART_AREA *ra;\r\nu16 ra_ofs, ra_len, ca_ofs;\r\nu8 fs_bits;\r\nntfs_debug("Entering.");\r\nra_ofs = le16_to_cpu(rp->restart_area_offset);\r\nra = (RESTART_AREA*)((u8*)rp + ra_ofs);\r\nif (ra_ofs + offsetof(RESTART_AREA, file_size) >\r\nNTFS_BLOCK_SIZE - sizeof(u16)) {\r\nntfs_error(vi->i_sb, "$LogFile restart area specifies "\r\n"inconsistent file offset.");\r\nreturn false;\r\n}\r\nca_ofs = le16_to_cpu(ra->client_array_offset);\r\nif (((ca_ofs + 7) & ~7) != ca_ofs ||\r\nra_ofs + ca_ofs > NTFS_BLOCK_SIZE - sizeof(u16)) {\r\nntfs_error(vi->i_sb, "$LogFile restart area specifies "\r\n"inconsistent client array offset.");\r\nreturn false;\r\n}\r\nra_len = ca_ofs + le16_to_cpu(ra->log_clients) *\r\nsizeof(LOG_CLIENT_RECORD);\r\nif (ra_ofs + ra_len > le32_to_cpu(rp->system_page_size) ||\r\nra_ofs + le16_to_cpu(ra->restart_area_length) >\r\nle32_to_cpu(rp->system_page_size) ||\r\nra_len > le16_to_cpu(ra->restart_area_length)) {\r\nntfs_error(vi->i_sb, "$LogFile restart area is out of bounds "\r\n"of the system page size specified by the "\r\n"restart page header and/or the specified "\r\n"restart area length is inconsistent.");\r\nreturn false;\r\n}\r\nif ((ra->client_free_list != LOGFILE_NO_CLIENT &&\r\nle16_to_cpu(ra->client_free_list) >=\r\nle16_to_cpu(ra->log_clients)) ||\r\n(ra->client_in_use_list != LOGFILE_NO_CLIENT &&\r\nle16_to_cpu(ra->client_in_use_list) >=\r\nle16_to_cpu(ra->log_clients))) {\r\nntfs_error(vi->i_sb, "$LogFile restart area specifies "\r\n"overflowing client free and/or in use lists.");\r\nreturn false;\r\n}\r\nfile_size = (u64)sle64_to_cpu(ra->file_size);\r\nfs_bits = 0;\r\nwhile (file_size) {\r\nfile_size >>= 1;\r\nfs_bits++;\r\n}\r\nif (le32_to_cpu(ra->seq_number_bits) != 67 - fs_bits) {\r\nntfs_error(vi->i_sb, "$LogFile restart area specifies "\r\n"inconsistent sequence number bits.");\r\nreturn false;\r\n}\r\nif (((le16_to_cpu(ra->log_record_header_length) + 7) & ~7) !=\r\nle16_to_cpu(ra->log_record_header_length)) {\r\nntfs_error(vi->i_sb, "$LogFile restart area specifies "\r\n"inconsistent log record header length.");\r\nreturn false;\r\n}\r\nif (((le16_to_cpu(ra->log_page_data_offset) + 7) & ~7) !=\r\nle16_to_cpu(ra->log_page_data_offset)) {\r\nntfs_error(vi->i_sb, "$LogFile restart area specifies "\r\n"inconsistent log page data offset.");\r\nreturn false;\r\n}\r\nntfs_debug("Done.");\r\nreturn true;\r\n}\r\nstatic bool ntfs_check_log_client_array(struct inode *vi,\r\nRESTART_PAGE_HEADER *rp)\r\n{\r\nRESTART_AREA *ra;\r\nLOG_CLIENT_RECORD *ca, *cr;\r\nu16 nr_clients, idx;\r\nbool in_free_list, idx_is_first;\r\nntfs_debug("Entering.");\r\nra = (RESTART_AREA*)((u8*)rp + le16_to_cpu(rp->restart_area_offset));\r\nca = (LOG_CLIENT_RECORD*)((u8*)ra +\r\nle16_to_cpu(ra->client_array_offset));\r\nnr_clients = le16_to_cpu(ra->log_clients);\r\nidx = le16_to_cpu(ra->client_free_list);\r\nin_free_list = true;\r\ncheck_list:\r\nfor (idx_is_first = true; idx != LOGFILE_NO_CLIENT_CPU; nr_clients--,\r\nidx = le16_to_cpu(cr->next_client)) {\r\nif (!nr_clients || idx >= le16_to_cpu(ra->log_clients))\r\ngoto err_out;\r\ncr = ca + idx;\r\nif (idx_is_first) {\r\nif (cr->prev_client != LOGFILE_NO_CLIENT)\r\ngoto err_out;\r\nidx_is_first = false;\r\n}\r\n}\r\nif (in_free_list) {\r\nin_free_list = false;\r\nidx = le16_to_cpu(ra->client_in_use_list);\r\ngoto check_list;\r\n}\r\nntfs_debug("Done.");\r\nreturn true;\r\nerr_out:\r\nntfs_error(vi->i_sb, "$LogFile log client array is corrupt.");\r\nreturn false;\r\n}\r\nstatic int ntfs_check_and_load_restart_page(struct inode *vi,\r\nRESTART_PAGE_HEADER *rp, s64 pos, RESTART_PAGE_HEADER **wrp,\r\nLSN *lsn)\r\n{\r\nRESTART_AREA *ra;\r\nRESTART_PAGE_HEADER *trp;\r\nint size, err;\r\nntfs_debug("Entering.");\r\nif (!ntfs_check_restart_page_header(vi, rp, pos)) {\r\nreturn -EINVAL;\r\n}\r\nif (!ntfs_check_restart_area(vi, rp)) {\r\nreturn -EINVAL;\r\n}\r\nra = (RESTART_AREA*)((u8*)rp + le16_to_cpu(rp->restart_area_offset));\r\ntrp = ntfs_malloc_nofs(le32_to_cpu(rp->system_page_size));\r\nif (!trp) {\r\nntfs_error(vi->i_sb, "Failed to allocate memory for $LogFile "\r\n"restart page buffer.");\r\nreturn -ENOMEM;\r\n}\r\nsize = PAGE_SIZE - (pos & ~PAGE_MASK);\r\nif (size >= le32_to_cpu(rp->system_page_size)) {\r\nmemcpy(trp, rp, le32_to_cpu(rp->system_page_size));\r\n} else {\r\npgoff_t idx;\r\nstruct page *page;\r\nint have_read, to_read;\r\nmemcpy(trp, rp, size);\r\nhave_read = size;\r\nto_read = le32_to_cpu(rp->system_page_size) - size;\r\nidx = (pos + size) >> PAGE_SHIFT;\r\nBUG_ON((pos + size) & ~PAGE_MASK);\r\ndo {\r\npage = ntfs_map_page(vi->i_mapping, idx);\r\nif (IS_ERR(page)) {\r\nntfs_error(vi->i_sb, "Error mapping $LogFile "\r\n"page (index %lu).", idx);\r\nerr = PTR_ERR(page);\r\nif (err != -EIO && err != -ENOMEM)\r\nerr = -EIO;\r\ngoto err_out;\r\n}\r\nsize = min_t(int, to_read, PAGE_SIZE);\r\nmemcpy((u8*)trp + have_read, page_address(page), size);\r\nntfs_unmap_page(page);\r\nhave_read += size;\r\nto_read -= size;\r\nidx++;\r\n} while (to_read > 0);\r\n}\r\nif ((!ntfs_is_chkd_record(trp->magic) || le16_to_cpu(trp->usa_count))\r\n&& post_read_mst_fixup((NTFS_RECORD*)trp,\r\nle32_to_cpu(rp->system_page_size))) {\r\nif (le16_to_cpu(rp->restart_area_offset) +\r\nle16_to_cpu(ra->restart_area_length) >\r\nNTFS_BLOCK_SIZE - sizeof(u16)) {\r\nntfs_error(vi->i_sb, "Multi sector transfer error "\r\n"detected in $LogFile restart page.");\r\nerr = -EINVAL;\r\ngoto err_out;\r\n}\r\n}\r\nerr = 0;\r\nif (ntfs_is_rstr_record(rp->magic) &&\r\nra->client_in_use_list != LOGFILE_NO_CLIENT) {\r\nif (!ntfs_check_log_client_array(vi, trp)) {\r\nerr = -EINVAL;\r\ngoto err_out;\r\n}\r\n}\r\nif (lsn) {\r\nif (ntfs_is_rstr_record(rp->magic))\r\n*lsn = sle64_to_cpu(ra->current_lsn);\r\nelse\r\n*lsn = sle64_to_cpu(rp->chkdsk_lsn);\r\n}\r\nntfs_debug("Done.");\r\nif (wrp)\r\n*wrp = trp;\r\nelse {\r\nerr_out:\r\nntfs_free(trp);\r\n}\r\nreturn err;\r\n}\r\nbool ntfs_check_logfile(struct inode *log_vi, RESTART_PAGE_HEADER **rp)\r\n{\r\ns64 size, pos;\r\nLSN rstr1_lsn, rstr2_lsn;\r\nntfs_volume *vol = NTFS_SB(log_vi->i_sb);\r\nstruct address_space *mapping = log_vi->i_mapping;\r\nstruct page *page = NULL;\r\nu8 *kaddr = NULL;\r\nRESTART_PAGE_HEADER *rstr1_ph = NULL;\r\nRESTART_PAGE_HEADER *rstr2_ph = NULL;\r\nint log_page_size, log_page_mask, err;\r\nbool logfile_is_empty = true;\r\nu8 log_page_bits;\r\nntfs_debug("Entering.");\r\nif (NVolLogFileEmpty(vol))\r\ngoto is_empty;\r\nsize = i_size_read(log_vi);\r\nif (size > MaxLogFileSize)\r\nsize = MaxLogFileSize;\r\nif (PAGE_SIZE >= DefaultLogPageSize && PAGE_SIZE <=\r\nDefaultLogPageSize * 2)\r\nlog_page_size = DefaultLogPageSize;\r\nelse\r\nlog_page_size = PAGE_SIZE;\r\nlog_page_mask = log_page_size - 1;\r\nlog_page_bits = ntfs_ffs(log_page_size) - 1;\r\nsize &= ~(s64)(log_page_size - 1);\r\nif (size < log_page_size * 2 || (size - log_page_size * 2) >>\r\nlog_page_bits < MinLogRecordPages) {\r\nntfs_error(vol->sb, "$LogFile is too small.");\r\nreturn false;\r\n}\r\nfor (pos = 0; pos < size; pos <<= 1) {\r\npgoff_t idx = pos >> PAGE_SHIFT;\r\nif (!page || page->index != idx) {\r\nif (page)\r\nntfs_unmap_page(page);\r\npage = ntfs_map_page(mapping, idx);\r\nif (IS_ERR(page)) {\r\nntfs_error(vol->sb, "Error mapping $LogFile "\r\n"page (index %lu).", idx);\r\ngoto err_out;\r\n}\r\n}\r\nkaddr = (u8*)page_address(page) + (pos & ~PAGE_MASK);\r\nif (!ntfs_is_empty_recordp((le32*)kaddr))\r\nlogfile_is_empty = false;\r\nelse if (!logfile_is_empty)\r\nbreak;\r\nif (ntfs_is_rcrd_recordp((le32*)kaddr))\r\nbreak;\r\nif (!ntfs_is_rstr_recordp((le32*)kaddr) &&\r\n!ntfs_is_chkd_recordp((le32*)kaddr)) {\r\nif (!pos)\r\npos = NTFS_BLOCK_SIZE >> 1;\r\ncontinue;\r\n}\r\nerr = ntfs_check_and_load_restart_page(log_vi,\r\n(RESTART_PAGE_HEADER*)kaddr, pos,\r\n!rstr1_ph ? &rstr1_ph : &rstr2_ph,\r\n!rstr1_ph ? &rstr1_lsn : &rstr2_lsn);\r\nif (!err) {\r\nif (!pos) {\r\npos = NTFS_BLOCK_SIZE >> 1;\r\ncontinue;\r\n}\r\nbreak;\r\n}\r\nif (err != -EINVAL) {\r\nntfs_unmap_page(page);\r\ngoto err_out;\r\n}\r\nif (!pos)\r\npos = NTFS_BLOCK_SIZE >> 1;\r\n}\r\nif (page)\r\nntfs_unmap_page(page);\r\nif (logfile_is_empty) {\r\nNVolSetLogFileEmpty(vol);\r\nis_empty:\r\nntfs_debug("Done. ($LogFile is empty.)");\r\nreturn true;\r\n}\r\nif (!rstr1_ph) {\r\nBUG_ON(rstr2_ph);\r\nntfs_error(vol->sb, "Did not find any restart pages in "\r\n"$LogFile and it was not empty.");\r\nreturn false;\r\n}\r\nif (rstr2_ph) {\r\nif (rstr2_lsn > rstr1_lsn) {\r\nntfs_debug("Using second restart page as it is more "\r\n"recent.");\r\nntfs_free(rstr1_ph);\r\nrstr1_ph = rstr2_ph;\r\n} else {\r\nntfs_debug("Using first restart page as it is more "\r\n"recent.");\r\nntfs_free(rstr2_ph);\r\n}\r\nrstr2_ph = NULL;\r\n}\r\nif (rp)\r\n*rp = rstr1_ph;\r\nelse\r\nntfs_free(rstr1_ph);\r\nntfs_debug("Done.");\r\nreturn true;\r\nerr_out:\r\nif (rstr1_ph)\r\nntfs_free(rstr1_ph);\r\nreturn false;\r\n}\r\nbool ntfs_is_logfile_clean(struct inode *log_vi, const RESTART_PAGE_HEADER *rp)\r\n{\r\nntfs_volume *vol = NTFS_SB(log_vi->i_sb);\r\nRESTART_AREA *ra;\r\nntfs_debug("Entering.");\r\nif (NVolLogFileEmpty(vol)) {\r\nntfs_debug("Done. ($LogFile is empty.)");\r\nreturn true;\r\n}\r\nBUG_ON(!rp);\r\nif (!ntfs_is_rstr_record(rp->magic) &&\r\n!ntfs_is_chkd_record(rp->magic)) {\r\nntfs_error(vol->sb, "Restart page buffer is invalid. This is "\r\n"probably a bug in that the $LogFile should "\r\n"have been consistency checked before calling "\r\n"this function.");\r\nreturn false;\r\n}\r\nra = (RESTART_AREA*)((u8*)rp + le16_to_cpu(rp->restart_area_offset));\r\nif (ra->client_in_use_list != LOGFILE_NO_CLIENT &&\r\n!(ra->flags & RESTART_VOLUME_IS_CLEAN)) {\r\nntfs_debug("Done. $LogFile indicates a dirty shutdown.");\r\nreturn false;\r\n}\r\nntfs_debug("Done. $LogFile indicates a clean shutdown.");\r\nreturn true;\r\n}\r\nbool ntfs_empty_logfile(struct inode *log_vi)\r\n{\r\nVCN vcn, end_vcn;\r\nntfs_inode *log_ni = NTFS_I(log_vi);\r\nntfs_volume *vol = log_ni->vol;\r\nstruct super_block *sb = vol->sb;\r\nrunlist_element *rl;\r\nunsigned long flags;\r\nunsigned block_size, block_size_bits;\r\nint err;\r\nbool should_wait = true;\r\nntfs_debug("Entering.");\r\nif (NVolLogFileEmpty(vol)) {\r\nntfs_debug("Done.");\r\nreturn true;\r\n}\r\nblock_size = sb->s_blocksize;\r\nblock_size_bits = sb->s_blocksize_bits;\r\nvcn = 0;\r\nread_lock_irqsave(&log_ni->size_lock, flags);\r\nend_vcn = (log_ni->initialized_size + vol->cluster_size_mask) >>\r\nvol->cluster_size_bits;\r\nread_unlock_irqrestore(&log_ni->size_lock, flags);\r\ntruncate_inode_pages(log_vi->i_mapping, 0);\r\ndown_write(&log_ni->runlist.lock);\r\nrl = log_ni->runlist.rl;\r\nif (unlikely(!rl || vcn < rl->vcn || !rl->length)) {\r\nmap_vcn:\r\nerr = ntfs_map_runlist_nolock(log_ni, vcn, NULL);\r\nif (err) {\r\nntfs_error(sb, "Failed to map runlist fragment (error "\r\n"%d).", -err);\r\ngoto err;\r\n}\r\nrl = log_ni->runlist.rl;\r\nBUG_ON(!rl || vcn < rl->vcn || !rl->length);\r\n}\r\nwhile (rl->length && vcn >= rl[1].vcn)\r\nrl++;\r\ndo {\r\nLCN lcn;\r\nsector_t block, end_block;\r\ns64 len;\r\nlcn = rl->lcn;\r\nif (unlikely(lcn == LCN_RL_NOT_MAPPED)) {\r\nvcn = rl->vcn;\r\ngoto map_vcn;\r\n}\r\nif (unlikely(!rl->length || lcn < LCN_HOLE))\r\ngoto rl_err;\r\nif (lcn == LCN_HOLE)\r\ncontinue;\r\nblock = lcn << vol->cluster_size_bits >> block_size_bits;\r\nlen = rl->length;\r\nif (rl[1].vcn > end_vcn)\r\nlen = end_vcn - rl->vcn;\r\nend_block = (lcn + len) << vol->cluster_size_bits >>\r\nblock_size_bits;\r\ndo {\r\nstruct buffer_head *bh;\r\nbh = sb_getblk(sb, block);\r\nBUG_ON(!bh);\r\nlock_buffer(bh);\r\nbh->b_end_io = end_buffer_write_sync;\r\nget_bh(bh);\r\nmemset(bh->b_data, -1, block_size);\r\nif (!buffer_uptodate(bh))\r\nset_buffer_uptodate(bh);\r\nif (buffer_dirty(bh))\r\nclear_buffer_dirty(bh);\r\nsubmit_bh(WRITE, bh);\r\nif (should_wait) {\r\nshould_wait = false;\r\nwait_on_buffer(bh);\r\nif (unlikely(!buffer_uptodate(bh)))\r\ngoto io_err;\r\n}\r\nbrelse(bh);\r\n} while (++block < end_block);\r\n} while ((++rl)->vcn < end_vcn);\r\nup_write(&log_ni->runlist.lock);\r\ntruncate_inode_pages(log_vi->i_mapping, 0);\r\nNVolSetLogFileEmpty(vol);\r\nntfs_debug("Done.");\r\nreturn true;\r\nio_err:\r\nntfs_error(sb, "Failed to write buffer. Unmount and run chkdsk.");\r\ngoto dirty_err;\r\nrl_err:\r\nntfs_error(sb, "Runlist is corrupt. Unmount and run chkdsk.");\r\ndirty_err:\r\nNVolSetErrors(vol);\r\nerr = -EIO;\r\nerr:\r\nup_write(&log_ni->runlist.lock);\r\nntfs_error(sb, "Failed to fill $LogFile with 0xff bytes (error %d).",\r\n-err);\r\nreturn false;\r\n}
