static inline struct fd_dev *FD_DEV(struct se_device *dev)\r\n{\r\nreturn container_of(dev, struct fd_dev, dev);\r\n}\r\nstatic int fd_attach_hba(struct se_hba *hba, u32 host_id)\r\n{\r\nstruct fd_host *fd_host;\r\nfd_host = kzalloc(sizeof(struct fd_host), GFP_KERNEL);\r\nif (!fd_host) {\r\npr_err("Unable to allocate memory for struct fd_host\n");\r\nreturn -ENOMEM;\r\n}\r\nfd_host->fd_host_id = host_id;\r\nhba->hba_ptr = fd_host;\r\npr_debug("CORE_HBA[%d] - TCM FILEIO HBA Driver %s on Generic"\r\n" Target Core Stack %s\n", hba->hba_id, FD_VERSION,\r\nTARGET_CORE_VERSION);\r\npr_debug("CORE_HBA[%d] - Attached FILEIO HBA: %u to Generic\n",\r\nhba->hba_id, fd_host->fd_host_id);\r\nreturn 0;\r\n}\r\nstatic void fd_detach_hba(struct se_hba *hba)\r\n{\r\nstruct fd_host *fd_host = hba->hba_ptr;\r\npr_debug("CORE_HBA[%d] - Detached FILEIO HBA: %u from Generic"\r\n" Target Core\n", hba->hba_id, fd_host->fd_host_id);\r\nkfree(fd_host);\r\nhba->hba_ptr = NULL;\r\n}\r\nstatic struct se_device *fd_alloc_device(struct se_hba *hba, const char *name)\r\n{\r\nstruct fd_dev *fd_dev;\r\nstruct fd_host *fd_host = hba->hba_ptr;\r\nfd_dev = kzalloc(sizeof(struct fd_dev), GFP_KERNEL);\r\nif (!fd_dev) {\r\npr_err("Unable to allocate memory for struct fd_dev\n");\r\nreturn NULL;\r\n}\r\nfd_dev->fd_host = fd_host;\r\npr_debug("FILEIO: Allocated fd_dev for %p\n", name);\r\nreturn &fd_dev->dev;\r\n}\r\nstatic int fd_configure_device(struct se_device *dev)\r\n{\r\nstruct fd_dev *fd_dev = FD_DEV(dev);\r\nstruct fd_host *fd_host = dev->se_hba->hba_ptr;\r\nstruct file *file;\r\nstruct inode *inode = NULL;\r\nint flags, ret = -EINVAL;\r\nif (!(fd_dev->fbd_flags & FBDF_HAS_PATH)) {\r\npr_err("Missing fd_dev_name=\n");\r\nreturn -EINVAL;\r\n}\r\nflags = O_RDWR | O_CREAT | O_LARGEFILE | O_DSYNC;\r\nif (fd_dev->fbd_flags & FDBD_HAS_BUFFERED_IO_WCE) {\r\npr_debug("FILEIO: Disabling O_DSYNC, using buffered FILEIO\n");\r\nflags &= ~O_DSYNC;\r\n}\r\nfile = filp_open(fd_dev->fd_dev_name, flags, 0600);\r\nif (IS_ERR(file)) {\r\npr_err("filp_open(%s) failed\n", fd_dev->fd_dev_name);\r\nret = PTR_ERR(file);\r\ngoto fail;\r\n}\r\nfd_dev->fd_file = file;\r\ninode = file->f_mapping->host;\r\nif (S_ISBLK(inode->i_mode)) {\r\nstruct request_queue *q = bdev_get_queue(inode->i_bdev);\r\nunsigned long long dev_size;\r\nfd_dev->fd_block_size = bdev_logical_block_size(inode->i_bdev);\r\ndev_size = (i_size_read(file->f_mapping->host) -\r\nfd_dev->fd_block_size);\r\npr_debug("FILEIO: Using size: %llu bytes from struct"\r\n" block_device blocks: %llu logical_block_size: %d\n",\r\ndev_size, div_u64(dev_size, fd_dev->fd_block_size),\r\nfd_dev->fd_block_size);\r\nif (target_configure_unmap_from_queue(&dev->dev_attrib, q,\r\nfd_dev->fd_block_size))\r\npr_debug("IFILE: BLOCK Discard support available,"\r\n" disabled by default\n");\r\ndev->dev_attrib.max_write_same_len = 0xFFFF;\r\nif (blk_queue_nonrot(q))\r\ndev->dev_attrib.is_nonrot = 1;\r\n} else {\r\nif (!(fd_dev->fbd_flags & FBDF_HAS_SIZE)) {\r\npr_err("FILEIO: Missing fd_dev_size="\r\n" parameter, and no backing struct"\r\n" block_device\n");\r\ngoto fail;\r\n}\r\nfd_dev->fd_block_size = FD_BLOCKSIZE;\r\ndev->dev_attrib.max_unmap_lba_count = 0x2000;\r\ndev->dev_attrib.max_unmap_block_desc_count = 1;\r\ndev->dev_attrib.unmap_granularity = 1;\r\ndev->dev_attrib.unmap_granularity_alignment = 0;\r\ndev->dev_attrib.max_write_same_len = 0x1000;\r\n}\r\ndev->dev_attrib.hw_block_size = fd_dev->fd_block_size;\r\ndev->dev_attrib.max_bytes_per_io = FD_MAX_BYTES;\r\ndev->dev_attrib.hw_max_sectors = FD_MAX_BYTES / fd_dev->fd_block_size;\r\ndev->dev_attrib.hw_queue_depth = FD_MAX_DEVICE_QUEUE_DEPTH;\r\nif (fd_dev->fbd_flags & FDBD_HAS_BUFFERED_IO_WCE) {\r\npr_debug("FILEIO: Forcing setting of emulate_write_cache=1"\r\n" with FDBD_HAS_BUFFERED_IO_WCE\n");\r\ndev->dev_attrib.emulate_write_cache = 1;\r\n}\r\nfd_dev->fd_dev_id = fd_host->fd_host_dev_id_count++;\r\nfd_dev->fd_queue_depth = dev->queue_depth;\r\npr_debug("CORE_FILE[%u] - Added TCM FILEIO Device ID: %u at %s,"\r\n" %llu total bytes\n", fd_host->fd_host_id, fd_dev->fd_dev_id,\r\nfd_dev->fd_dev_name, fd_dev->fd_dev_size);\r\nreturn 0;\r\nfail:\r\nif (fd_dev->fd_file) {\r\nfilp_close(fd_dev->fd_file, NULL);\r\nfd_dev->fd_file = NULL;\r\n}\r\nreturn ret;\r\n}\r\nstatic void fd_dev_call_rcu(struct rcu_head *p)\r\n{\r\nstruct se_device *dev = container_of(p, struct se_device, rcu_head);\r\nstruct fd_dev *fd_dev = FD_DEV(dev);\r\nkfree(fd_dev);\r\n}\r\nstatic void fd_free_device(struct se_device *dev)\r\n{\r\nstruct fd_dev *fd_dev = FD_DEV(dev);\r\nif (fd_dev->fd_file) {\r\nfilp_close(fd_dev->fd_file, NULL);\r\nfd_dev->fd_file = NULL;\r\n}\r\ncall_rcu(&dev->rcu_head, fd_dev_call_rcu);\r\n}\r\nstatic int fd_do_rw(struct se_cmd *cmd, struct file *fd,\r\nu32 block_size, struct scatterlist *sgl,\r\nu32 sgl_nents, u32 data_length, int is_write)\r\n{\r\nstruct scatterlist *sg;\r\nstruct iov_iter iter;\r\nstruct bio_vec *bvec;\r\nssize_t len = 0;\r\nloff_t pos = (cmd->t_task_lba * block_size);\r\nint ret = 0, i;\r\nbvec = kcalloc(sgl_nents, sizeof(struct bio_vec), GFP_KERNEL);\r\nif (!bvec) {\r\npr_err("Unable to allocate fd_do_readv iov[]\n");\r\nreturn -ENOMEM;\r\n}\r\nfor_each_sg(sgl, sg, sgl_nents, i) {\r\nbvec[i].bv_page = sg_page(sg);\r\nbvec[i].bv_len = sg->length;\r\nbvec[i].bv_offset = sg->offset;\r\nlen += sg->length;\r\n}\r\niov_iter_bvec(&iter, ITER_BVEC, bvec, sgl_nents, len);\r\nif (is_write)\r\nret = vfs_iter_write(fd, &iter, &pos);\r\nelse\r\nret = vfs_iter_read(fd, &iter, &pos);\r\nkfree(bvec);\r\nif (is_write) {\r\nif (ret < 0 || ret != data_length) {\r\npr_err("%s() write returned %d\n", __func__, ret);\r\nreturn (ret < 0 ? ret : -EINVAL);\r\n}\r\n} else {\r\nif (S_ISBLK(file_inode(fd)->i_mode)) {\r\nif (ret < 0 || ret != data_length) {\r\npr_err("%s() returned %d, expecting %u for "\r\n"S_ISBLK\n", __func__, ret,\r\ndata_length);\r\nreturn (ret < 0 ? ret : -EINVAL);\r\n}\r\n} else {\r\nif (ret < 0) {\r\npr_err("%s() returned %d for non S_ISBLK\n",\r\n__func__, ret);\r\nreturn ret;\r\n}\r\n}\r\n}\r\nreturn 1;\r\n}\r\nstatic sense_reason_t\r\nfd_execute_sync_cache(struct se_cmd *cmd)\r\n{\r\nstruct se_device *dev = cmd->se_dev;\r\nstruct fd_dev *fd_dev = FD_DEV(dev);\r\nint immed = (cmd->t_task_cdb[1] & 0x2);\r\nloff_t start, end;\r\nint ret;\r\nif (immed)\r\ntarget_complete_cmd(cmd, SAM_STAT_GOOD);\r\nif (cmd->t_task_lba == 0 && cmd->data_length == 0) {\r\nstart = 0;\r\nend = LLONG_MAX;\r\n} else {\r\nstart = cmd->t_task_lba * dev->dev_attrib.block_size;\r\nif (cmd->data_length)\r\nend = start + cmd->data_length - 1;\r\nelse\r\nend = LLONG_MAX;\r\n}\r\nret = vfs_fsync_range(fd_dev->fd_file, start, end, 1);\r\nif (ret != 0)\r\npr_err("FILEIO: vfs_fsync_range() failed: %d\n", ret);\r\nif (immed)\r\nreturn 0;\r\nif (ret)\r\ntarget_complete_cmd(cmd, SAM_STAT_CHECK_CONDITION);\r\nelse\r\ntarget_complete_cmd(cmd, SAM_STAT_GOOD);\r\nreturn 0;\r\n}\r\nstatic sense_reason_t\r\nfd_execute_write_same(struct se_cmd *cmd)\r\n{\r\nstruct se_device *se_dev = cmd->se_dev;\r\nstruct fd_dev *fd_dev = FD_DEV(se_dev);\r\nloff_t pos = cmd->t_task_lba * se_dev->dev_attrib.block_size;\r\nsector_t nolb = sbc_get_write_same_sectors(cmd);\r\nstruct iov_iter iter;\r\nstruct bio_vec *bvec;\r\nunsigned int len = 0, i;\r\nssize_t ret;\r\nif (!nolb) {\r\ntarget_complete_cmd(cmd, SAM_STAT_GOOD);\r\nreturn 0;\r\n}\r\nif (cmd->prot_op) {\r\npr_err("WRITE_SAME: Protection information with FILEIO"\r\n" backends not supported\n");\r\nreturn TCM_LOGICAL_UNIT_COMMUNICATION_FAILURE;\r\n}\r\nif (cmd->t_data_nents > 1 ||\r\ncmd->t_data_sg[0].length != cmd->se_dev->dev_attrib.block_size) {\r\npr_err("WRITE_SAME: Illegal SGL t_data_nents: %u length: %u"\r\n" block_size: %u\n",\r\ncmd->t_data_nents,\r\ncmd->t_data_sg[0].length,\r\ncmd->se_dev->dev_attrib.block_size);\r\nreturn TCM_INVALID_CDB_FIELD;\r\n}\r\nbvec = kcalloc(nolb, sizeof(struct bio_vec), GFP_KERNEL);\r\nif (!bvec)\r\nreturn TCM_LOGICAL_UNIT_COMMUNICATION_FAILURE;\r\nfor (i = 0; i < nolb; i++) {\r\nbvec[i].bv_page = sg_page(&cmd->t_data_sg[0]);\r\nbvec[i].bv_len = cmd->t_data_sg[0].length;\r\nbvec[i].bv_offset = cmd->t_data_sg[0].offset;\r\nlen += se_dev->dev_attrib.block_size;\r\n}\r\niov_iter_bvec(&iter, ITER_BVEC, bvec, nolb, len);\r\nret = vfs_iter_write(fd_dev->fd_file, &iter, &pos);\r\nkfree(bvec);\r\nif (ret < 0 || ret != len) {\r\npr_err("vfs_iter_write() returned %zd for write same\n", ret);\r\nreturn TCM_LOGICAL_UNIT_COMMUNICATION_FAILURE;\r\n}\r\ntarget_complete_cmd(cmd, SAM_STAT_GOOD);\r\nreturn 0;\r\n}\r\nstatic int\r\nfd_do_prot_fill(struct se_device *se_dev, sector_t lba, sector_t nolb,\r\nvoid *buf, size_t bufsize)\r\n{\r\nstruct fd_dev *fd_dev = FD_DEV(se_dev);\r\nstruct file *prot_fd = fd_dev->fd_prot_file;\r\nsector_t prot_length, prot;\r\nloff_t pos = lba * se_dev->prot_length;\r\nif (!prot_fd) {\r\npr_err("Unable to locate fd_dev->fd_prot_file\n");\r\nreturn -ENODEV;\r\n}\r\nprot_length = nolb * se_dev->prot_length;\r\nfor (prot = 0; prot < prot_length;) {\r\nsector_t len = min_t(sector_t, bufsize, prot_length - prot);\r\nssize_t ret = kernel_write(prot_fd, buf, len, pos + prot);\r\nif (ret != len) {\r\npr_err("vfs_write to prot file failed: %zd\n", ret);\r\nreturn ret < 0 ? ret : -ENODEV;\r\n}\r\nprot += ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic int\r\nfd_do_prot_unmap(struct se_cmd *cmd, sector_t lba, sector_t nolb)\r\n{\r\nvoid *buf;\r\nint rc;\r\nbuf = (void *)__get_free_page(GFP_KERNEL);\r\nif (!buf) {\r\npr_err("Unable to allocate FILEIO prot buf\n");\r\nreturn -ENOMEM;\r\n}\r\nmemset(buf, 0xff, PAGE_SIZE);\r\nrc = fd_do_prot_fill(cmd->se_dev, lba, nolb, buf, PAGE_SIZE);\r\nfree_page((unsigned long)buf);\r\nreturn rc;\r\n}\r\nstatic sense_reason_t\r\nfd_execute_unmap(struct se_cmd *cmd, sector_t lba, sector_t nolb)\r\n{\r\nstruct file *file = FD_DEV(cmd->se_dev)->fd_file;\r\nstruct inode *inode = file->f_mapping->host;\r\nint ret;\r\nif (cmd->se_dev->dev_attrib.pi_prot_type) {\r\nret = fd_do_prot_unmap(cmd, lba, nolb);\r\nif (ret)\r\nreturn TCM_LOGICAL_UNIT_COMMUNICATION_FAILURE;\r\n}\r\nif (S_ISBLK(inode->i_mode)) {\r\nstruct block_device *bdev = inode->i_bdev;\r\nstruct se_device *dev = cmd->se_dev;\r\nret = blkdev_issue_discard(bdev,\r\ntarget_to_linux_sector(dev, lba),\r\ntarget_to_linux_sector(dev, nolb),\r\nGFP_KERNEL, 0);\r\nif (ret < 0) {\r\npr_warn("FILEIO: blkdev_issue_discard() failed: %d\n",\r\nret);\r\nreturn TCM_LOGICAL_UNIT_COMMUNICATION_FAILURE;\r\n}\r\n} else {\r\nstruct se_device *se_dev = cmd->se_dev;\r\nloff_t pos = lba * se_dev->dev_attrib.block_size;\r\nunsigned int len = nolb * se_dev->dev_attrib.block_size;\r\nint mode = FALLOC_FL_PUNCH_HOLE | FALLOC_FL_KEEP_SIZE;\r\nif (!file->f_op->fallocate)\r\nreturn TCM_LOGICAL_UNIT_COMMUNICATION_FAILURE;\r\nret = file->f_op->fallocate(file, mode, pos, len);\r\nif (ret < 0) {\r\npr_warn("FILEIO: fallocate() failed: %d\n", ret);\r\nreturn TCM_LOGICAL_UNIT_COMMUNICATION_FAILURE;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic sense_reason_t\r\nfd_execute_rw(struct se_cmd *cmd, struct scatterlist *sgl, u32 sgl_nents,\r\nenum dma_data_direction data_direction)\r\n{\r\nstruct se_device *dev = cmd->se_dev;\r\nstruct fd_dev *fd_dev = FD_DEV(dev);\r\nstruct file *file = fd_dev->fd_file;\r\nstruct file *pfile = fd_dev->fd_prot_file;\r\nsense_reason_t rc;\r\nint ret = 0;\r\nif (cmd->data_length > FD_MAX_BYTES) {\r\npr_err("FILEIO: Not able to process I/O of %u bytes due to"\r\n"FD_MAX_BYTES: %u iovec count limitiation\n",\r\ncmd->data_length, FD_MAX_BYTES);\r\nreturn TCM_LOGICAL_UNIT_COMMUNICATION_FAILURE;\r\n}\r\nif (data_direction == DMA_FROM_DEVICE) {\r\nif (cmd->prot_type && dev->dev_attrib.pi_prot_type) {\r\nret = fd_do_rw(cmd, pfile, dev->prot_length,\r\ncmd->t_prot_sg, cmd->t_prot_nents,\r\ncmd->prot_length, 0);\r\nif (ret < 0)\r\nreturn TCM_LOGICAL_UNIT_COMMUNICATION_FAILURE;\r\n}\r\nret = fd_do_rw(cmd, file, dev->dev_attrib.block_size,\r\nsgl, sgl_nents, cmd->data_length, 0);\r\nif (ret > 0 && cmd->prot_type && dev->dev_attrib.pi_prot_type) {\r\nu32 sectors = cmd->data_length >>\r\nilog2(dev->dev_attrib.block_size);\r\nrc = sbc_dif_verify(cmd, cmd->t_task_lba, sectors,\r\n0, cmd->t_prot_sg, 0);\r\nif (rc)\r\nreturn rc;\r\n}\r\n} else {\r\nif (cmd->prot_type && dev->dev_attrib.pi_prot_type) {\r\nu32 sectors = cmd->data_length >>\r\nilog2(dev->dev_attrib.block_size);\r\nrc = sbc_dif_verify(cmd, cmd->t_task_lba, sectors,\r\n0, cmd->t_prot_sg, 0);\r\nif (rc)\r\nreturn rc;\r\n}\r\nret = fd_do_rw(cmd, file, dev->dev_attrib.block_size,\r\nsgl, sgl_nents, cmd->data_length, 1);\r\nif (ret > 0 && (cmd->se_cmd_flags & SCF_FUA)) {\r\nloff_t start = cmd->t_task_lba *\r\ndev->dev_attrib.block_size;\r\nloff_t end;\r\nif (cmd->data_length)\r\nend = start + cmd->data_length - 1;\r\nelse\r\nend = LLONG_MAX;\r\nvfs_fsync_range(fd_dev->fd_file, start, end, 1);\r\n}\r\nif (ret > 0 && cmd->prot_type && dev->dev_attrib.pi_prot_type) {\r\nret = fd_do_rw(cmd, pfile, dev->prot_length,\r\ncmd->t_prot_sg, cmd->t_prot_nents,\r\ncmd->prot_length, 1);\r\nif (ret < 0)\r\nreturn TCM_LOGICAL_UNIT_COMMUNICATION_FAILURE;\r\n}\r\n}\r\nif (ret < 0)\r\nreturn TCM_LOGICAL_UNIT_COMMUNICATION_FAILURE;\r\nif (ret)\r\ntarget_complete_cmd(cmd, SAM_STAT_GOOD);\r\nreturn 0;\r\n}\r\nstatic ssize_t fd_set_configfs_dev_params(struct se_device *dev,\r\nconst char *page, ssize_t count)\r\n{\r\nstruct fd_dev *fd_dev = FD_DEV(dev);\r\nchar *orig, *ptr, *arg_p, *opts;\r\nsubstring_t args[MAX_OPT_ARGS];\r\nint ret = 0, arg, token;\r\nopts = kstrdup(page, GFP_KERNEL);\r\nif (!opts)\r\nreturn -ENOMEM;\r\norig = opts;\r\nwhile ((ptr = strsep(&opts, ",\n")) != NULL) {\r\nif (!*ptr)\r\ncontinue;\r\ntoken = match_token(ptr, tokens, args);\r\nswitch (token) {\r\ncase Opt_fd_dev_name:\r\nif (match_strlcpy(fd_dev->fd_dev_name, &args[0],\r\nFD_MAX_DEV_NAME) == 0) {\r\nret = -EINVAL;\r\nbreak;\r\n}\r\npr_debug("FILEIO: Referencing Path: %s\n",\r\nfd_dev->fd_dev_name);\r\nfd_dev->fbd_flags |= FBDF_HAS_PATH;\r\nbreak;\r\ncase Opt_fd_dev_size:\r\narg_p = match_strdup(&args[0]);\r\nif (!arg_p) {\r\nret = -ENOMEM;\r\nbreak;\r\n}\r\nret = kstrtoull(arg_p, 0, &fd_dev->fd_dev_size);\r\nkfree(arg_p);\r\nif (ret < 0) {\r\npr_err("kstrtoull() failed for"\r\n" fd_dev_size=\n");\r\ngoto out;\r\n}\r\npr_debug("FILEIO: Referencing Size: %llu"\r\n" bytes\n", fd_dev->fd_dev_size);\r\nfd_dev->fbd_flags |= FBDF_HAS_SIZE;\r\nbreak;\r\ncase Opt_fd_buffered_io:\r\nret = match_int(args, &arg);\r\nif (ret)\r\ngoto out;\r\nif (arg != 1) {\r\npr_err("bogus fd_buffered_io=%d value\n", arg);\r\nret = -EINVAL;\r\ngoto out;\r\n}\r\npr_debug("FILEIO: Using buffered I/O"\r\n" operations for struct fd_dev\n");\r\nfd_dev->fbd_flags |= FDBD_HAS_BUFFERED_IO_WCE;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nout:\r\nkfree(orig);\r\nreturn (!ret) ? count : ret;\r\n}\r\nstatic ssize_t fd_show_configfs_dev_params(struct se_device *dev, char *b)\r\n{\r\nstruct fd_dev *fd_dev = FD_DEV(dev);\r\nssize_t bl = 0;\r\nbl = sprintf(b + bl, "TCM FILEIO ID: %u", fd_dev->fd_dev_id);\r\nbl += sprintf(b + bl, " File: %s Size: %llu Mode: %s\n",\r\nfd_dev->fd_dev_name, fd_dev->fd_dev_size,\r\n(fd_dev->fbd_flags & FDBD_HAS_BUFFERED_IO_WCE) ?\r\n"Buffered-WCE" : "O_DSYNC");\r\nreturn bl;\r\n}\r\nstatic sector_t fd_get_blocks(struct se_device *dev)\r\n{\r\nstruct fd_dev *fd_dev = FD_DEV(dev);\r\nstruct file *f = fd_dev->fd_file;\r\nstruct inode *i = f->f_mapping->host;\r\nunsigned long long dev_size;\r\nif (S_ISBLK(i->i_mode))\r\ndev_size = i_size_read(i);\r\nelse\r\ndev_size = fd_dev->fd_dev_size;\r\nreturn div_u64(dev_size - dev->dev_attrib.block_size,\r\ndev->dev_attrib.block_size);\r\n}\r\nstatic int fd_init_prot(struct se_device *dev)\r\n{\r\nstruct fd_dev *fd_dev = FD_DEV(dev);\r\nstruct file *prot_file, *file = fd_dev->fd_file;\r\nstruct inode *inode;\r\nint ret, flags = O_RDWR | O_CREAT | O_LARGEFILE | O_DSYNC;\r\nchar buf[FD_MAX_DEV_PROT_NAME];\r\nif (!file) {\r\npr_err("Unable to locate fd_dev->fd_file\n");\r\nreturn -ENODEV;\r\n}\r\ninode = file->f_mapping->host;\r\nif (S_ISBLK(inode->i_mode)) {\r\npr_err("FILEIO Protection emulation only supported on"\r\n" !S_ISBLK\n");\r\nreturn -ENOSYS;\r\n}\r\nif (fd_dev->fbd_flags & FDBD_HAS_BUFFERED_IO_WCE)\r\nflags &= ~O_DSYNC;\r\nsnprintf(buf, FD_MAX_DEV_PROT_NAME, "%s.protection",\r\nfd_dev->fd_dev_name);\r\nprot_file = filp_open(buf, flags, 0600);\r\nif (IS_ERR(prot_file)) {\r\npr_err("filp_open(%s) failed\n", buf);\r\nret = PTR_ERR(prot_file);\r\nreturn ret;\r\n}\r\nfd_dev->fd_prot_file = prot_file;\r\nreturn 0;\r\n}\r\nstatic int fd_format_prot(struct se_device *dev)\r\n{\r\nunsigned char *buf;\r\nint unit_size = FDBD_FORMAT_UNIT_SIZE * dev->dev_attrib.block_size;\r\nint ret;\r\nif (!dev->dev_attrib.pi_prot_type) {\r\npr_err("Unable to format_prot while pi_prot_type == 0\n");\r\nreturn -ENODEV;\r\n}\r\nbuf = vzalloc(unit_size);\r\nif (!buf) {\r\npr_err("Unable to allocate FILEIO prot buf\n");\r\nreturn -ENOMEM;\r\n}\r\npr_debug("Using FILEIO prot_length: %llu\n",\r\n(unsigned long long)(dev->transport->get_blocks(dev) + 1) *\r\ndev->prot_length);\r\nmemset(buf, 0xff, unit_size);\r\nret = fd_do_prot_fill(dev, 0, dev->transport->get_blocks(dev) + 1,\r\nbuf, unit_size);\r\nvfree(buf);\r\nreturn ret;\r\n}\r\nstatic void fd_free_prot(struct se_device *dev)\r\n{\r\nstruct fd_dev *fd_dev = FD_DEV(dev);\r\nif (!fd_dev->fd_prot_file)\r\nreturn;\r\nfilp_close(fd_dev->fd_prot_file, NULL);\r\nfd_dev->fd_prot_file = NULL;\r\n}\r\nstatic sense_reason_t\r\nfd_parse_cdb(struct se_cmd *cmd)\r\n{\r\nreturn sbc_parse_cdb(cmd, &fd_sbc_ops);\r\n}\r\nstatic int __init fileio_module_init(void)\r\n{\r\nreturn transport_backend_register(&fileio_ops);\r\n}\r\nstatic void __exit fileio_module_exit(void)\r\n{\r\ntarget_backend_unregister(&fileio_ops);\r\n}
