static struct of_mmc_spi *to_of_mmc_spi(struct device *dev)\r\n{\r\nreturn container_of(dev->platform_data, struct of_mmc_spi, pdata);\r\n}\r\nstatic int of_mmc_spi_init(struct device *dev,\r\nirqreturn_t (*irqhandler)(int, void *), void *mmc)\r\n{\r\nstruct of_mmc_spi *oms = to_of_mmc_spi(dev);\r\nreturn request_threaded_irq(oms->detect_irq, NULL, irqhandler,\r\nIRQF_ONESHOT, dev_name(dev), mmc);\r\n}\r\nstatic void of_mmc_spi_exit(struct device *dev, void *mmc)\r\n{\r\nstruct of_mmc_spi *oms = to_of_mmc_spi(dev);\r\nfree_irq(oms->detect_irq, mmc);\r\n}\r\nstruct mmc_spi_platform_data *mmc_spi_get_pdata(struct spi_device *spi)\r\n{\r\nstruct device *dev = &spi->dev;\r\nstruct device_node *np = dev->of_node;\r\nstruct of_mmc_spi *oms;\r\nconst u32 *voltage_ranges;\r\nint num_ranges;\r\nint i;\r\nif (dev->platform_data || !np)\r\nreturn dev->platform_data;\r\noms = kzalloc(sizeof(*oms), GFP_KERNEL);\r\nif (!oms)\r\nreturn NULL;\r\nvoltage_ranges = of_get_property(np, "voltage-ranges", &num_ranges);\r\nnum_ranges = num_ranges / sizeof(*voltage_ranges) / 2;\r\nif (!voltage_ranges || !num_ranges) {\r\ndev_err(dev, "OF: voltage-ranges unspecified\n");\r\ngoto err_ocr;\r\n}\r\nfor (i = 0; i < num_ranges; i++) {\r\nconst int j = i * 2;\r\nu32 mask;\r\nmask = mmc_vddrange_to_ocrmask(be32_to_cpu(voltage_ranges[j]),\r\nbe32_to_cpu(voltage_ranges[j + 1]));\r\nif (!mask) {\r\ndev_err(dev, "OF: voltage-range #%d is invalid\n", i);\r\ngoto err_ocr;\r\n}\r\noms->pdata.ocr_mask |= mask;\r\n}\r\nfor (i = 0; i < ARRAY_SIZE(oms->gpios); i++) {\r\nenum of_gpio_flags gpio_flags;\r\noms->gpios[i] = of_get_gpio_flags(np, i, &gpio_flags);\r\nif (!gpio_is_valid(oms->gpios[i]))\r\ncontinue;\r\nif (gpio_flags & OF_GPIO_ACTIVE_LOW)\r\noms->alow_gpios[i] = true;\r\n}\r\nif (gpio_is_valid(oms->gpios[CD_GPIO])) {\r\noms->pdata.cd_gpio = oms->gpios[CD_GPIO];\r\noms->pdata.flags |= MMC_SPI_USE_CD_GPIO;\r\nif (!oms->alow_gpios[CD_GPIO])\r\noms->pdata.caps2 |= MMC_CAP2_CD_ACTIVE_HIGH;\r\n}\r\nif (gpio_is_valid(oms->gpios[WP_GPIO])) {\r\noms->pdata.ro_gpio = oms->gpios[WP_GPIO];\r\noms->pdata.flags |= MMC_SPI_USE_RO_GPIO;\r\nif (!oms->alow_gpios[WP_GPIO])\r\noms->pdata.caps2 |= MMC_CAP2_RO_ACTIVE_HIGH;\r\n}\r\noms->detect_irq = irq_of_parse_and_map(np, 0);\r\nif (oms->detect_irq != 0) {\r\noms->pdata.init = of_mmc_spi_init;\r\noms->pdata.exit = of_mmc_spi_exit;\r\n} else {\r\noms->pdata.caps |= MMC_CAP_NEEDS_POLL;\r\n}\r\ndev->platform_data = &oms->pdata;\r\nreturn dev->platform_data;\r\nerr_ocr:\r\nkfree(oms);\r\nreturn NULL;\r\n}\r\nvoid mmc_spi_put_pdata(struct spi_device *spi)\r\n{\r\nstruct device *dev = &spi->dev;\r\nstruct device_node *np = dev->of_node;\r\nstruct of_mmc_spi *oms = to_of_mmc_spi(dev);\r\nif (!dev->platform_data || !np)\r\nreturn;\r\nkfree(oms);\r\ndev->platform_data = NULL;\r\n}
