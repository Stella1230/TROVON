static void nft_log_eval(const struct nft_expr *expr,\r\nstruct nft_regs *regs,\r\nconst struct nft_pktinfo *pkt)\r\n{\r\nconst struct nft_log *priv = nft_expr_priv(expr);\r\nnf_log_packet(pkt->net, pkt->pf, pkt->hook, pkt->skb, pkt->in,\r\npkt->out, &priv->loginfo, "%s", priv->prefix);\r\n}\r\nstatic int nft_log_init(const struct nft_ctx *ctx,\r\nconst struct nft_expr *expr,\r\nconst struct nlattr * const tb[])\r\n{\r\nstruct nft_log *priv = nft_expr_priv(expr);\r\nstruct nf_loginfo *li = &priv->loginfo;\r\nconst struct nlattr *nla;\r\nint ret;\r\nnla = tb[NFTA_LOG_PREFIX];\r\nif (nla != NULL) {\r\npriv->prefix = kmalloc(nla_len(nla) + 1, GFP_KERNEL);\r\nif (priv->prefix == NULL)\r\nreturn -ENOMEM;\r\nnla_strlcpy(priv->prefix, nla, nla_len(nla) + 1);\r\n} else {\r\npriv->prefix = (char *)nft_log_null_prefix;\r\n}\r\nli->type = NF_LOG_TYPE_LOG;\r\nif (tb[NFTA_LOG_LEVEL] != NULL &&\r\ntb[NFTA_LOG_GROUP] != NULL)\r\nreturn -EINVAL;\r\nif (tb[NFTA_LOG_GROUP] != NULL)\r\nli->type = NF_LOG_TYPE_ULOG;\r\nswitch (li->type) {\r\ncase NF_LOG_TYPE_LOG:\r\nif (tb[NFTA_LOG_LEVEL] != NULL) {\r\nli->u.log.level =\r\nntohl(nla_get_be32(tb[NFTA_LOG_LEVEL]));\r\n} else {\r\nli->u.log.level = LOGLEVEL_WARNING;\r\n}\r\nif (tb[NFTA_LOG_FLAGS] != NULL) {\r\nli->u.log.logflags =\r\nntohl(nla_get_be32(tb[NFTA_LOG_FLAGS]));\r\n}\r\nbreak;\r\ncase NF_LOG_TYPE_ULOG:\r\nli->u.ulog.group = ntohs(nla_get_be16(tb[NFTA_LOG_GROUP]));\r\nif (tb[NFTA_LOG_SNAPLEN] != NULL) {\r\nli->u.ulog.copy_len =\r\nntohl(nla_get_be32(tb[NFTA_LOG_SNAPLEN]));\r\n}\r\nif (tb[NFTA_LOG_QTHRESHOLD] != NULL) {\r\nli->u.ulog.qthreshold =\r\nntohs(nla_get_be16(tb[NFTA_LOG_QTHRESHOLD]));\r\n}\r\nbreak;\r\n}\r\nif (ctx->afi->family == NFPROTO_INET) {\r\nret = nf_logger_find_get(NFPROTO_IPV4, li->type);\r\nif (ret < 0)\r\nreturn ret;\r\nret = nf_logger_find_get(NFPROTO_IPV6, li->type);\r\nif (ret < 0) {\r\nnf_logger_put(NFPROTO_IPV4, li->type);\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nreturn nf_logger_find_get(ctx->afi->family, li->type);\r\n}\r\nstatic void nft_log_destroy(const struct nft_ctx *ctx,\r\nconst struct nft_expr *expr)\r\n{\r\nstruct nft_log *priv = nft_expr_priv(expr);\r\nstruct nf_loginfo *li = &priv->loginfo;\r\nif (priv->prefix != nft_log_null_prefix)\r\nkfree(priv->prefix);\r\nif (ctx->afi->family == NFPROTO_INET) {\r\nnf_logger_put(NFPROTO_IPV4, li->type);\r\nnf_logger_put(NFPROTO_IPV6, li->type);\r\n} else {\r\nnf_logger_put(ctx->afi->family, li->type);\r\n}\r\n}\r\nstatic int nft_log_dump(struct sk_buff *skb, const struct nft_expr *expr)\r\n{\r\nconst struct nft_log *priv = nft_expr_priv(expr);\r\nconst struct nf_loginfo *li = &priv->loginfo;\r\nif (priv->prefix != nft_log_null_prefix)\r\nif (nla_put_string(skb, NFTA_LOG_PREFIX, priv->prefix))\r\ngoto nla_put_failure;\r\nswitch (li->type) {\r\ncase NF_LOG_TYPE_LOG:\r\nif (nla_put_be32(skb, NFTA_LOG_LEVEL, htonl(li->u.log.level)))\r\ngoto nla_put_failure;\r\nif (li->u.log.logflags) {\r\nif (nla_put_be32(skb, NFTA_LOG_FLAGS,\r\nhtonl(li->u.log.logflags)))\r\ngoto nla_put_failure;\r\n}\r\nbreak;\r\ncase NF_LOG_TYPE_ULOG:\r\nif (nla_put_be16(skb, NFTA_LOG_GROUP, htons(li->u.ulog.group)))\r\ngoto nla_put_failure;\r\nif (li->u.ulog.copy_len) {\r\nif (nla_put_be32(skb, NFTA_LOG_SNAPLEN,\r\nhtonl(li->u.ulog.copy_len)))\r\ngoto nla_put_failure;\r\n}\r\nif (li->u.ulog.qthreshold) {\r\nif (nla_put_be16(skb, NFTA_LOG_QTHRESHOLD,\r\nhtons(li->u.ulog.qthreshold)))\r\ngoto nla_put_failure;\r\n}\r\nbreak;\r\n}\r\nreturn 0;\r\nnla_put_failure:\r\nreturn -1;\r\n}\r\nstatic int __init nft_log_module_init(void)\r\n{\r\nreturn nft_register_expr(&nft_log_type);\r\n}\r\nstatic void __exit nft_log_module_exit(void)\r\n{\r\nnft_unregister_expr(&nft_log_type);\r\n}
