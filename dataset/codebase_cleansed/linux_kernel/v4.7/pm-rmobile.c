static inline\r\nstruct rmobile_pm_domain *to_rmobile_pd(struct generic_pm_domain *d)\r\n{\r\nreturn container_of(d, struct rmobile_pm_domain, genpd);\r\n}\r\nstatic int rmobile_pd_power_down(struct generic_pm_domain *genpd)\r\n{\r\nstruct rmobile_pm_domain *rmobile_pd = to_rmobile_pd(genpd);\r\nunsigned int mask;\r\nif (rmobile_pd->bit_shift == ~0)\r\nreturn -EBUSY;\r\nmask = BIT(rmobile_pd->bit_shift);\r\nif (rmobile_pd->suspend) {\r\nint ret = rmobile_pd->suspend();\r\nif (ret)\r\nreturn ret;\r\n}\r\nif (__raw_readl(rmobile_pd->base + PSTR) & mask) {\r\nunsigned int retry_count;\r\n__raw_writel(mask, rmobile_pd->base + SPDCR);\r\nfor (retry_count = PSTR_RETRIES; retry_count; retry_count--) {\r\nif (!(__raw_readl(rmobile_pd->base + SPDCR) & mask))\r\nbreak;\r\ncpu_relax();\r\n}\r\n}\r\nif (!rmobile_pd->no_debug)\r\npr_debug("%s: Power off, 0x%08x -> PSTR = 0x%08x\n",\r\ngenpd->name, mask,\r\n__raw_readl(rmobile_pd->base + PSTR));\r\nreturn 0;\r\n}\r\nstatic int __rmobile_pd_power_up(struct rmobile_pm_domain *rmobile_pd,\r\nbool do_resume)\r\n{\r\nunsigned int mask;\r\nunsigned int retry_count;\r\nint ret = 0;\r\nif (rmobile_pd->bit_shift == ~0)\r\nreturn 0;\r\nmask = BIT(rmobile_pd->bit_shift);\r\nif (__raw_readl(rmobile_pd->base + PSTR) & mask)\r\ngoto out;\r\n__raw_writel(mask, rmobile_pd->base + SWUCR);\r\nfor (retry_count = 2 * PSTR_RETRIES; retry_count; retry_count--) {\r\nif (!(__raw_readl(rmobile_pd->base + SWUCR) & mask))\r\nbreak;\r\nif (retry_count > PSTR_RETRIES)\r\nudelay(PSTR_DELAY_US);\r\nelse\r\ncpu_relax();\r\n}\r\nif (!retry_count)\r\nret = -EIO;\r\nif (!rmobile_pd->no_debug)\r\npr_debug("%s: Power on, 0x%08x -> PSTR = 0x%08x\n",\r\nrmobile_pd->genpd.name, mask,\r\n__raw_readl(rmobile_pd->base + PSTR));\r\nout:\r\nif (ret == 0 && rmobile_pd->resume && do_resume)\r\nrmobile_pd->resume();\r\nreturn ret;\r\n}\r\nstatic int rmobile_pd_power_up(struct generic_pm_domain *genpd)\r\n{\r\nreturn __rmobile_pd_power_up(to_rmobile_pd(genpd), true);\r\n}\r\nstatic bool rmobile_pd_active_wakeup(struct device *dev)\r\n{\r\nreturn true;\r\n}\r\nstatic void rmobile_init_pm_domain(struct rmobile_pm_domain *rmobile_pd)\r\n{\r\nstruct generic_pm_domain *genpd = &rmobile_pd->genpd;\r\nstruct dev_power_governor *gov = rmobile_pd->gov;\r\ngenpd->flags = GENPD_FLAG_PM_CLK;\r\npm_genpd_init(genpd, gov ? : &simple_qos_governor, false);\r\ngenpd->dev_ops.active_wakeup = rmobile_pd_active_wakeup;\r\ngenpd->power_off = rmobile_pd_power_down;\r\ngenpd->power_on = rmobile_pd_power_up;\r\ngenpd->attach_dev = cpg_mstp_attach_dev;\r\ngenpd->detach_dev = cpg_mstp_detach_dev;\r\n__rmobile_pd_power_up(rmobile_pd, false);\r\n}\r\nstatic int rmobile_pd_suspend_busy(void)\r\n{\r\nreturn -EBUSY;\r\n}\r\nstatic int rmobile_pd_suspend_console(void)\r\n{\r\nreturn console_suspend_enabled ? 0 : -EBUSY;\r\n}\r\nstatic void __init add_special_pd(struct device_node *np, enum pd_types type)\r\n{\r\nunsigned int i;\r\nstruct device_node *pd;\r\npd = of_parse_phandle(np, "power-domains", 0);\r\nif (!pd)\r\nreturn;\r\nfor (i = 0; i < num_special_pds; i++)\r\nif (pd == special_pds[i].pd && type == special_pds[i].type) {\r\nof_node_put(pd);\r\nreturn;\r\n}\r\nif (num_special_pds == ARRAY_SIZE(special_pds)) {\r\npr_warn("Too many special PM domains\n");\r\nof_node_put(pd);\r\nreturn;\r\n}\r\npr_debug("Special PM domain %s type %d for %s\n", pd->name, type,\r\nnp->full_name);\r\nspecial_pds[num_special_pds].pd = pd;\r\nspecial_pds[num_special_pds].type = type;\r\nnum_special_pds++;\r\n}\r\nstatic void __init get_special_pds(void)\r\n{\r\nstruct device_node *np;\r\nconst struct of_device_id *id;\r\nfor_each_node_by_type(np, "cpu")\r\nadd_special_pd(np, PD_CPU);\r\nif (of_stdout)\r\nadd_special_pd(of_stdout, PD_CONSOLE);\r\nfor_each_matching_node_and_match(np, special_ids, &id)\r\nadd_special_pd(np, (enum pd_types)id->data);\r\n}\r\nstatic void __init put_special_pds(void)\r\n{\r\nunsigned int i;\r\nfor (i = 0; i < num_special_pds; i++)\r\nof_node_put(special_pds[i].pd);\r\n}\r\nstatic enum pd_types __init pd_type(const struct device_node *pd)\r\n{\r\nunsigned int i;\r\nfor (i = 0; i < num_special_pds; i++)\r\nif (pd == special_pds[i].pd)\r\nreturn special_pds[i].type;\r\nreturn PD_NORMAL;\r\n}\r\nstatic void __init rmobile_setup_pm_domain(struct device_node *np,\r\nstruct rmobile_pm_domain *pd)\r\n{\r\nconst char *name = pd->genpd.name;\r\nswitch (pd_type(np)) {\r\ncase PD_CPU:\r\npr_debug("PM domain %s contains CPU\n", name);\r\npd->gov = &pm_domain_always_on_gov;\r\npd->suspend = rmobile_pd_suspend_busy;\r\nbreak;\r\ncase PD_CONSOLE:\r\npr_debug("PM domain %s contains serial console\n", name);\r\npd->gov = &pm_domain_always_on_gov;\r\npd->suspend = rmobile_pd_suspend_console;\r\nbreak;\r\ncase PD_DEBUG:\r\npr_debug("PM domain %s contains Coresight-ETM\n", name);\r\npd->gov = &pm_domain_always_on_gov;\r\npd->suspend = rmobile_pd_suspend_busy;\r\nbreak;\r\ncase PD_MEMCTL:\r\npr_debug("PM domain %s contains MEMCTL\n", name);\r\npd->gov = &pm_domain_always_on_gov;\r\npd->suspend = rmobile_pd_suspend_busy;\r\nbreak;\r\ncase PD_NORMAL:\r\nbreak;\r\n}\r\nrmobile_init_pm_domain(pd);\r\n}\r\nstatic int __init rmobile_add_pm_domains(void __iomem *base,\r\nstruct device_node *parent,\r\nstruct generic_pm_domain *genpd_parent)\r\n{\r\nstruct device_node *np;\r\nfor_each_child_of_node(parent, np) {\r\nstruct rmobile_pm_domain *pd;\r\nu32 idx = ~0;\r\nif (of_property_read_u32(np, "reg", &idx)) {\r\n}\r\npd = kzalloc(sizeof(*pd), GFP_KERNEL);\r\nif (!pd) {\r\nof_node_put(np);\r\nreturn -ENOMEM;\r\n}\r\npd->genpd.name = np->name;\r\npd->base = base;\r\npd->bit_shift = idx;\r\nrmobile_setup_pm_domain(np, pd);\r\nif (genpd_parent)\r\npm_genpd_add_subdomain(genpd_parent, &pd->genpd);\r\nof_genpd_add_provider_simple(np, &pd->genpd);\r\nrmobile_add_pm_domains(base, np, &pd->genpd);\r\n}\r\nreturn 0;\r\n}\r\nstatic int __init rmobile_init_pm_domains(void)\r\n{\r\nstruct device_node *np, *pmd;\r\nbool scanned = false;\r\nvoid __iomem *base;\r\nint ret = 0;\r\nfor_each_compatible_node(np, NULL, "renesas,sysc-rmobile") {\r\nbase = of_iomap(np, 0);\r\nif (!base) {\r\npr_warn("%s cannot map reg 0\n", np->full_name);\r\ncontinue;\r\n}\r\npmd = of_get_child_by_name(np, "pm-domains");\r\nif (!pmd) {\r\npr_warn("%s lacks pm-domains node\n", np->full_name);\r\ncontinue;\r\n}\r\nif (!scanned) {\r\nget_special_pds();\r\nscanned = true;\r\n}\r\nret = rmobile_add_pm_domains(base, pmd, NULL);\r\nof_node_put(pmd);\r\nif (ret) {\r\nof_node_put(np);\r\nbreak;\r\n}\r\n}\r\nput_special_pds();\r\nreturn ret;\r\n}
