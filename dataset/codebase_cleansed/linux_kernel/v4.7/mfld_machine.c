static int headset_get_switch(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nucontrol->value.enumerated.item[0] = hs_switch;\r\nreturn 0;\r\n}\r\nstatic int headset_set_switch(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_soc_card *card = snd_kcontrol_chip(kcontrol);\r\nstruct snd_soc_dapm_context *dapm = &card->dapm;\r\nif (ucontrol->value.enumerated.item[0] == hs_switch)\r\nreturn 0;\r\nsnd_soc_dapm_mutex_lock(dapm);\r\nif (ucontrol->value.enumerated.item[0]) {\r\npr_debug("hs_set HS path\n");\r\nsnd_soc_dapm_enable_pin_unlocked(dapm, "Headphones");\r\nsnd_soc_dapm_disable_pin_unlocked(dapm, "EPOUT");\r\n} else {\r\npr_debug("hs_set EP path\n");\r\nsnd_soc_dapm_disable_pin_unlocked(dapm, "Headphones");\r\nsnd_soc_dapm_enable_pin_unlocked(dapm, "EPOUT");\r\n}\r\nsnd_soc_dapm_sync_unlocked(dapm);\r\nsnd_soc_dapm_mutex_unlock(dapm);\r\nhs_switch = ucontrol->value.enumerated.item[0];\r\nreturn 0;\r\n}\r\nstatic void lo_enable_out_pins(struct snd_soc_dapm_context *dapm)\r\n{\r\nsnd_soc_dapm_enable_pin_unlocked(dapm, "IHFOUTL");\r\nsnd_soc_dapm_enable_pin_unlocked(dapm, "IHFOUTR");\r\nsnd_soc_dapm_enable_pin_unlocked(dapm, "LINEOUTL");\r\nsnd_soc_dapm_enable_pin_unlocked(dapm, "LINEOUTR");\r\nsnd_soc_dapm_enable_pin_unlocked(dapm, "VIB1OUT");\r\nsnd_soc_dapm_enable_pin_unlocked(dapm, "VIB2OUT");\r\nif (hs_switch) {\r\nsnd_soc_dapm_enable_pin_unlocked(dapm, "Headphones");\r\nsnd_soc_dapm_disable_pin_unlocked(dapm, "EPOUT");\r\n} else {\r\nsnd_soc_dapm_disable_pin_unlocked(dapm, "Headphones");\r\nsnd_soc_dapm_enable_pin_unlocked(dapm, "EPOUT");\r\n}\r\n}\r\nstatic int lo_get_switch(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nucontrol->value.enumerated.item[0] = lo_dac;\r\nreturn 0;\r\n}\r\nstatic int lo_set_switch(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_soc_card *card = snd_kcontrol_chip(kcontrol);\r\nstruct snd_soc_dapm_context *dapm = &card->dapm;\r\nif (ucontrol->value.enumerated.item[0] == lo_dac)\r\nreturn 0;\r\nsnd_soc_dapm_mutex_lock(dapm);\r\nlo_enable_out_pins(dapm);\r\nswitch (ucontrol->value.enumerated.item[0]) {\r\ncase 0:\r\npr_debug("set vibra path\n");\r\nsnd_soc_dapm_disable_pin_unlocked(dapm, "VIB1OUT");\r\nsnd_soc_dapm_disable_pin_unlocked(dapm, "VIB2OUT");\r\nsnd_soc_update_bits(mfld_codec, SN95031_LOCTL, 0x66, 0);\r\nbreak;\r\ncase 1:\r\npr_debug("set hs path\n");\r\nsnd_soc_dapm_disable_pin_unlocked(dapm, "Headphones");\r\nsnd_soc_dapm_disable_pin_unlocked(dapm, "EPOUT");\r\nsnd_soc_update_bits(mfld_codec, SN95031_LOCTL, 0x66, 0x22);\r\nbreak;\r\ncase 2:\r\npr_debug("set spkr path\n");\r\nsnd_soc_dapm_disable_pin_unlocked(dapm, "IHFOUTL");\r\nsnd_soc_dapm_disable_pin_unlocked(dapm, "IHFOUTR");\r\nsnd_soc_update_bits(mfld_codec, SN95031_LOCTL, 0x66, 0x44);\r\nbreak;\r\ncase 3:\r\npr_debug("set null path\n");\r\nsnd_soc_dapm_disable_pin_unlocked(dapm, "LINEOUTL");\r\nsnd_soc_dapm_disable_pin_unlocked(dapm, "LINEOUTR");\r\nsnd_soc_update_bits(mfld_codec, SN95031_LOCTL, 0x66, 0x66);\r\nbreak;\r\n}\r\nsnd_soc_dapm_sync_unlocked(dapm);\r\nsnd_soc_dapm_mutex_unlock(dapm);\r\nlo_dac = ucontrol->value.enumerated.item[0];\r\nreturn 0;\r\n}\r\nstatic void mfld_jack_check(unsigned int intr_status)\r\n{\r\nstruct mfld_jack_data jack_data;\r\nif (!mfld_codec)\r\nreturn;\r\njack_data.mfld_jack = &mfld_jack;\r\njack_data.intr_id = intr_status;\r\nsn95031_jack_detection(mfld_codec, &jack_data);\r\n}\r\nstatic int mfld_init(struct snd_soc_pcm_runtime *runtime)\r\n{\r\nstruct snd_soc_dapm_context *dapm = &runtime->card->dapm;\r\nint ret_val;\r\nsnd_soc_dapm_disable_pin(dapm, "Headphones");\r\nsnd_soc_dapm_disable_pin(dapm, "LINEOUTL");\r\nsnd_soc_dapm_disable_pin(dapm, "LINEOUTR");\r\nlo_dac = 3;\r\nhs_switch = 0;\r\nsnd_soc_dapm_disable_pin(dapm, "LINEINL");\r\nsnd_soc_dapm_disable_pin(dapm, "LINEINR");\r\nret_val = snd_soc_card_jack_new(runtime->card,\r\n"Intel(R) MID Audio Jack", SND_JACK_HEADSET |\r\nSND_JACK_BTN_0 | SND_JACK_BTN_1, &mfld_jack,\r\nmfld_jack_pins, ARRAY_SIZE(mfld_jack_pins));\r\nif (ret_val) {\r\npr_err("jack creation failed\n");\r\nreturn ret_val;\r\n}\r\nret_val = snd_soc_jack_add_zones(&mfld_jack,\r\nARRAY_SIZE(mfld_zones), mfld_zones);\r\nif (ret_val) {\r\npr_err("adding jack zones failed\n");\r\nreturn ret_val;\r\n}\r\nmfld_codec = runtime->codec;\r\nmfld_jack_check(MFLD_JACK_INSERT);\r\nreturn ret_val;\r\n}\r\nstatic irqreturn_t snd_mfld_jack_intr_handler(int irq, void *dev)\r\n{\r\nstruct mfld_mc_private *mc_private = (struct mfld_mc_private *) dev;\r\nmemcpy_fromio(&mc_private->interrupt_status,\r\n((void *)(mc_private->int_base)),\r\nsizeof(u8));\r\nreturn IRQ_WAKE_THREAD;\r\n}\r\nstatic irqreturn_t snd_mfld_jack_detection(int irq, void *data)\r\n{\r\nstruct mfld_mc_private *mc_drv_ctx = (struct mfld_mc_private *) data;\r\nmfld_jack_check(mc_drv_ctx->interrupt_status);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int snd_mfld_mc_probe(struct platform_device *pdev)\r\n{\r\nint ret_val = 0, irq;\r\nstruct mfld_mc_private *mc_drv_ctx;\r\nstruct resource *irq_mem;\r\npr_debug("snd_mfld_mc_probe called\n");\r\nirq = platform_get_irq(pdev, 0);\r\nmc_drv_ctx = devm_kzalloc(&pdev->dev, sizeof(*mc_drv_ctx), GFP_ATOMIC);\r\nif (!mc_drv_ctx) {\r\npr_err("allocation failed\n");\r\nreturn -ENOMEM;\r\n}\r\nirq_mem = platform_get_resource_byname(\r\npdev, IORESOURCE_MEM, "IRQ_BASE");\r\nif (!irq_mem) {\r\npr_err("no mem resource given\n");\r\nreturn -ENODEV;\r\n}\r\nmc_drv_ctx->int_base = devm_ioremap_nocache(&pdev->dev, irq_mem->start,\r\nresource_size(irq_mem));\r\nif (!mc_drv_ctx->int_base) {\r\npr_err("Mapping of cache failed\n");\r\nreturn -ENOMEM;\r\n}\r\nret_val = devm_request_threaded_irq(&pdev->dev, irq,\r\nsnd_mfld_jack_intr_handler,\r\nsnd_mfld_jack_detection,\r\nIRQF_SHARED, pdev->dev.driver->name, mc_drv_ctx);\r\nif (ret_val) {\r\npr_err("cannot register IRQ\n");\r\nreturn ret_val;\r\n}\r\nsnd_soc_card_mfld.dev = &pdev->dev;\r\nret_val = devm_snd_soc_register_card(&pdev->dev, &snd_soc_card_mfld);\r\nif (ret_val) {\r\npr_debug("snd_soc_register_card failed %d\n", ret_val);\r\nreturn ret_val;\r\n}\r\nplatform_set_drvdata(pdev, mc_drv_ctx);\r\npr_debug("successfully exited probe\n");\r\nreturn 0;\r\n}
