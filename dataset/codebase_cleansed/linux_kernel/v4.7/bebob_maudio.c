int snd_bebob_maudio_load_firmware(struct fw_unit *unit)\r\n{\r\nstruct fw_device *device = fw_parent_device(unit);\r\nint err, rcode;\r\nu64 date;\r\n__le32 cues[3] = {\r\ncpu_to_le32(MAUDIO_BOOTLOADER_CUE1),\r\ncpu_to_le32(MAUDIO_BOOTLOADER_CUE2),\r\ncpu_to_le32(MAUDIO_BOOTLOADER_CUE3)\r\n};\r\nerr = snd_bebob_read_block(unit, INFO_OFFSET_SW_DATE,\r\n&date, sizeof(u64));\r\nif (err < 0)\r\ngoto end;\r\nif (date < 0x3230303730343031LL) {\r\ndev_err(&unit->device,\r\n"Use firmware version 5058 or later\n");\r\nerr = -ENOSYS;\r\ngoto end;\r\n}\r\nrcode = fw_run_transaction(device->card, TCODE_WRITE_BLOCK_REQUEST,\r\ndevice->node_id, device->generation,\r\ndevice->max_speed, BEBOB_ADDR_REG_REQ,\r\ncues, sizeof(cues));\r\nif (rcode != RCODE_COMPLETE) {\r\ndev_err(&unit->device,\r\n"Failed to send a cue to load firmware\n");\r\nerr = -EIO;\r\n}\r\nend:\r\nreturn err;\r\n}\r\nstatic inline int\r\nget_meter(struct snd_bebob *bebob, void *buf, unsigned int size)\r\n{\r\nreturn snd_fw_transaction(bebob->unit, TCODE_READ_BLOCK_REQUEST,\r\nMAUDIO_SPECIFIC_ADDRESS + METER_OFFSET,\r\nbuf, size, 0);\r\n}\r\nstatic int\r\ncheck_clk_sync(struct snd_bebob *bebob, unsigned int size, bool *sync)\r\n{\r\nint err;\r\nu8 *buf;\r\nbuf = kmalloc(size, GFP_KERNEL);\r\nif (buf == NULL)\r\nreturn -ENOMEM;\r\nerr = get_meter(bebob, buf, size);\r\nif (err < 0)\r\ngoto end;\r\n*sync = (buf[size - 2] != 0xff);\r\nend:\r\nkfree(buf);\r\nreturn err;\r\n}\r\nstatic int\r\navc_maudio_set_special_clk(struct snd_bebob *bebob, unsigned int clk_src,\r\nunsigned int dig_in_fmt, unsigned int dig_out_fmt,\r\nunsigned int clk_lock)\r\n{\r\nstruct special_params *params = bebob->maudio_special_quirk;\r\nint err;\r\nu8 *buf;\r\nif (amdtp_stream_running(&bebob->rx_stream) ||\r\namdtp_stream_running(&bebob->tx_stream))\r\nreturn -EBUSY;\r\nbuf = kmalloc(12, GFP_KERNEL);\r\nif (buf == NULL)\r\nreturn -ENOMEM;\r\nbuf[0] = 0x00;\r\nbuf[1] = 0xff;\r\nbuf[2] = 0x00;\r\nbuf[3] = 0x04;\r\nbuf[4] = 0x00;\r\nbuf[5] = 0x04;\r\nbuf[6] = 0xff & clk_src;\r\nbuf[7] = 0xff & dig_in_fmt;\r\nbuf[8] = 0xff & dig_out_fmt;\r\nbuf[9] = 0xff & clk_lock;\r\nbuf[10] = 0x00;\r\nbuf[11] = 0x00;\r\nerr = fcp_avc_transaction(bebob->unit, buf, 12, buf, 12,\r\nBIT(1) | BIT(2) | BIT(3) | BIT(4) |\r\nBIT(5) | BIT(6) | BIT(7) | BIT(8) |\r\nBIT(9));\r\nif ((err > 0) && (err < 10))\r\nerr = -EIO;\r\nelse if (buf[0] == 0x08)\r\nerr = -ENOSYS;\r\nelse if (buf[0] == 0x0a)\r\nerr = -EINVAL;\r\nif (err < 0)\r\ngoto end;\r\nparams->clk_src = buf[6];\r\nparams->dig_in_fmt = buf[7];\r\nparams->dig_out_fmt = buf[8];\r\nparams->clk_lock = buf[9];\r\nif (params->ctl_id_sync)\r\nsnd_ctl_notify(bebob->card, SNDRV_CTL_EVENT_MASK_VALUE,\r\nparams->ctl_id_sync);\r\nerr = 0;\r\nend:\r\nkfree(buf);\r\nreturn err;\r\n}\r\nstatic void\r\nspecial_stream_formation_set(struct snd_bebob *bebob)\r\n{\r\nstatic const unsigned int ch_table[2][2][3] = {\r\n{ { 6, 6, 4 },\r\n{ 12, 8, 4 } },\r\n{ { 10, 10, 2 },\r\n{ 16, 12, 2 } }\r\n};\r\nstruct special_params *params = bebob->maudio_special_quirk;\r\nunsigned int i, max;\r\nmax = SND_BEBOB_STRM_FMT_ENTRIES - 1;\r\nif (!params->is1814)\r\nmax -= 2;\r\nfor (i = 0; i < max; i++) {\r\nbebob->tx_stream_formations[i + 1].pcm =\r\nch_table[AMDTP_IN_STREAM][params->dig_in_fmt][i / 2];\r\nbebob->tx_stream_formations[i + 1].midi = 1;\r\nbebob->rx_stream_formations[i + 1].pcm =\r\nch_table[AMDTP_OUT_STREAM][params->dig_out_fmt][i / 2];\r\nbebob->rx_stream_formations[i + 1].midi = 1;\r\n}\r\n}\r\nint\r\nsnd_bebob_maudio_special_discover(struct snd_bebob *bebob, bool is1814)\r\n{\r\nstruct special_params *params;\r\nint err;\r\nparams = kzalloc(sizeof(struct special_params), GFP_KERNEL);\r\nif (params == NULL)\r\nreturn -ENOMEM;\r\nmutex_lock(&bebob->mutex);\r\nbebob->maudio_special_quirk = (void *)params;\r\nparams->is1814 = is1814;\r\nbebob->rx_stream.context = ERR_PTR(-1);\r\nbebob->tx_stream.context = ERR_PTR(-1);\r\nerr = avc_maudio_set_special_clk(bebob, 0x03, 0x00, 0x00, 0x00);\r\nif (err < 0) {\r\ndev_err(&bebob->unit->device,\r\n"fail to initialize clock params: %d\n", err);\r\ngoto end;\r\n}\r\nerr = add_special_controls(bebob);\r\nif (err < 0)\r\ngoto end;\r\nspecial_stream_formation_set(bebob);\r\nif (params->is1814) {\r\nbebob->midi_input_ports = 1;\r\nbebob->midi_output_ports = 1;\r\n} else {\r\nbebob->midi_input_ports = 2;\r\nbebob->midi_output_ports = 2;\r\n}\r\nend:\r\nif (err < 0) {\r\nkfree(params);\r\nbebob->maudio_special_quirk = NULL;\r\n}\r\nmutex_unlock(&bebob->mutex);\r\nreturn err;\r\n}\r\nstatic int special_get_rate(struct snd_bebob *bebob, unsigned int *rate)\r\n{\r\nint err, trials;\r\ntrials = 0;\r\ndo {\r\nerr = avc_general_get_sig_fmt(bebob->unit, rate,\r\nAVC_GENERAL_PLUG_DIR_IN, 0);\r\n} while (err == -EAGAIN && ++trials < 3);\r\nreturn err;\r\n}\r\nstatic int special_set_rate(struct snd_bebob *bebob, unsigned int rate)\r\n{\r\nstruct special_params *params = bebob->maudio_special_quirk;\r\nint err;\r\nerr = avc_general_set_sig_fmt(bebob->unit, rate,\r\nAVC_GENERAL_PLUG_DIR_OUT, 0);\r\nif (err < 0)\r\ngoto end;\r\nmsleep(100);\r\nerr = avc_general_set_sig_fmt(bebob->unit, rate,\r\nAVC_GENERAL_PLUG_DIR_IN, 0);\r\nif (err < 0)\r\ngoto end;\r\nif (params->ctl_id_sync)\r\nsnd_ctl_notify(bebob->card, SNDRV_CTL_EVENT_MASK_VALUE,\r\nparams->ctl_id_sync);\r\nend:\r\nreturn err;\r\n}\r\nstatic int special_clk_get(struct snd_bebob *bebob, unsigned int *id)\r\n{\r\nstruct special_params *params = bebob->maudio_special_quirk;\r\n*id = params->clk_src;\r\nreturn 0;\r\n}\r\nstatic int special_clk_ctl_info(struct snd_kcontrol *kctl,\r\nstruct snd_ctl_elem_info *einf)\r\n{\r\nstatic const char *const special_clk_labels[] = {\r\n"Internal with Digital Mute",\r\n"Digital",\r\n"Word Clock",\r\n"Internal"\r\n};\r\nreturn snd_ctl_enum_info(einf, 1, ARRAY_SIZE(special_clk_types),\r\nspecial_clk_labels);\r\n}\r\nstatic int special_clk_ctl_get(struct snd_kcontrol *kctl,\r\nstruct snd_ctl_elem_value *uval)\r\n{\r\nstruct snd_bebob *bebob = snd_kcontrol_chip(kctl);\r\nstruct special_params *params = bebob->maudio_special_quirk;\r\nuval->value.enumerated.item[0] = params->clk_src;\r\nreturn 0;\r\n}\r\nstatic int special_clk_ctl_put(struct snd_kcontrol *kctl,\r\nstruct snd_ctl_elem_value *uval)\r\n{\r\nstruct snd_bebob *bebob = snd_kcontrol_chip(kctl);\r\nstruct special_params *params = bebob->maudio_special_quirk;\r\nint err, id;\r\nid = uval->value.enumerated.item[0];\r\nif (id >= ARRAY_SIZE(special_clk_types))\r\nreturn -EINVAL;\r\nmutex_lock(&bebob->mutex);\r\nerr = avc_maudio_set_special_clk(bebob, id,\r\nparams->dig_in_fmt,\r\nparams->dig_out_fmt,\r\nparams->clk_lock);\r\nmutex_unlock(&bebob->mutex);\r\nif (err >= 0)\r\nerr = 1;\r\nreturn err;\r\n}\r\nstatic int special_sync_ctl_info(struct snd_kcontrol *kctl,\r\nstruct snd_ctl_elem_info *einf)\r\n{\r\neinf->type = SNDRV_CTL_ELEM_TYPE_BOOLEAN;\r\neinf->count = 1;\r\neinf->value.integer.min = 0;\r\neinf->value.integer.max = 1;\r\nreturn 0;\r\n}\r\nstatic int special_sync_ctl_get(struct snd_kcontrol *kctl,\r\nstruct snd_ctl_elem_value *uval)\r\n{\r\nstruct snd_bebob *bebob = snd_kcontrol_chip(kctl);\r\nint err;\r\nbool synced = 0;\r\nerr = check_clk_sync(bebob, METER_SIZE_SPECIAL, &synced);\r\nif (err >= 0)\r\nuval->value.integer.value[0] = synced;\r\nreturn 0;\r\n}\r\nstatic int special_dig_in_iface_ctl_info(struct snd_kcontrol *kctl,\r\nstruct snd_ctl_elem_info *einf)\r\n{\r\nreturn snd_ctl_enum_info(einf, 1,\r\nARRAY_SIZE(special_dig_in_iface_labels),\r\nspecial_dig_in_iface_labels);\r\n}\r\nstatic int special_dig_in_iface_ctl_get(struct snd_kcontrol *kctl,\r\nstruct snd_ctl_elem_value *uval)\r\n{\r\nstruct snd_bebob *bebob = snd_kcontrol_chip(kctl);\r\nstruct special_params *params = bebob->maudio_special_quirk;\r\nunsigned int dig_in_iface;\r\nint err, val;\r\nmutex_lock(&bebob->mutex);\r\nerr = avc_audio_get_selector(bebob->unit, 0x00, 0x04,\r\n&dig_in_iface);\r\nif (err < 0) {\r\ndev_err(&bebob->unit->device,\r\n"fail to get digital input interface: %d\n", err);\r\ngoto end;\r\n}\r\nval = (params->dig_in_fmt << 1) | (dig_in_iface & 0x01);\r\nif (val > 2)\r\nval = 2;\r\nuval->value.enumerated.item[0] = val;\r\nend:\r\nmutex_unlock(&bebob->mutex);\r\nreturn err;\r\n}\r\nstatic int special_dig_in_iface_ctl_set(struct snd_kcontrol *kctl,\r\nstruct snd_ctl_elem_value *uval)\r\n{\r\nstruct snd_bebob *bebob = snd_kcontrol_chip(kctl);\r\nstruct special_params *params = bebob->maudio_special_quirk;\r\nunsigned int id, dig_in_fmt, dig_in_iface;\r\nint err;\r\nid = uval->value.enumerated.item[0];\r\nif (id >= ARRAY_SIZE(special_dig_in_iface_labels))\r\nreturn -EINVAL;\r\ndig_in_fmt = (id >> 1) & 0x01;\r\ndig_in_iface = id & 0x01;\r\nmutex_lock(&bebob->mutex);\r\nerr = avc_maudio_set_special_clk(bebob,\r\nparams->clk_src,\r\ndig_in_fmt,\r\nparams->dig_out_fmt,\r\nparams->clk_lock);\r\nif (err < 0)\r\ngoto end;\r\nif (params->dig_in_fmt > 0) {\r\nerr = 1;\r\ngoto end;\r\n}\r\nerr = avc_audio_set_selector(bebob->unit, 0x00, 0x04, dig_in_iface);\r\nif (err < 0)\r\ndev_err(&bebob->unit->device,\r\n"fail to set digital input interface: %d\n", err);\r\nerr = 1;\r\nend:\r\nspecial_stream_formation_set(bebob);\r\nmutex_unlock(&bebob->mutex);\r\nreturn err;\r\n}\r\nstatic int special_dig_out_iface_ctl_info(struct snd_kcontrol *kctl,\r\nstruct snd_ctl_elem_info *einf)\r\n{\r\nreturn snd_ctl_enum_info(einf, 1,\r\nARRAY_SIZE(special_dig_out_iface_labels),\r\nspecial_dig_out_iface_labels);\r\n}\r\nstatic int special_dig_out_iface_ctl_get(struct snd_kcontrol *kctl,\r\nstruct snd_ctl_elem_value *uval)\r\n{\r\nstruct snd_bebob *bebob = snd_kcontrol_chip(kctl);\r\nstruct special_params *params = bebob->maudio_special_quirk;\r\nmutex_lock(&bebob->mutex);\r\nuval->value.enumerated.item[0] = params->dig_out_fmt;\r\nmutex_unlock(&bebob->mutex);\r\nreturn 0;\r\n}\r\nstatic int special_dig_out_iface_ctl_set(struct snd_kcontrol *kctl,\r\nstruct snd_ctl_elem_value *uval)\r\n{\r\nstruct snd_bebob *bebob = snd_kcontrol_chip(kctl);\r\nstruct special_params *params = bebob->maudio_special_quirk;\r\nunsigned int id;\r\nint err;\r\nid = uval->value.enumerated.item[0];\r\nif (id >= ARRAY_SIZE(special_dig_out_iface_labels))\r\nreturn -EINVAL;\r\nmutex_lock(&bebob->mutex);\r\nerr = avc_maudio_set_special_clk(bebob,\r\nparams->clk_src,\r\nparams->dig_in_fmt,\r\nid, params->clk_lock);\r\nif (err >= 0) {\r\nspecial_stream_formation_set(bebob);\r\nerr = 1;\r\n}\r\nmutex_unlock(&bebob->mutex);\r\nreturn err;\r\n}\r\nstatic int add_special_controls(struct snd_bebob *bebob)\r\n{\r\nstruct snd_kcontrol *kctl;\r\nstruct special_params *params = bebob->maudio_special_quirk;\r\nint err;\r\nkctl = snd_ctl_new1(&special_clk_ctl, bebob);\r\nerr = snd_ctl_add(bebob->card, kctl);\r\nif (err < 0)\r\ngoto end;\r\nkctl = snd_ctl_new1(&special_sync_ctl, bebob);\r\nerr = snd_ctl_add(bebob->card, kctl);\r\nif (err < 0)\r\ngoto end;\r\nparams->ctl_id_sync = &kctl->id;\r\nkctl = snd_ctl_new1(&special_dig_in_iface_ctl, bebob);\r\nerr = snd_ctl_add(bebob->card, kctl);\r\nif (err < 0)\r\ngoto end;\r\nkctl = snd_ctl_new1(&special_dig_out_iface_ctl, bebob);\r\nerr = snd_ctl_add(bebob->card, kctl);\r\nend:\r\nreturn err;\r\n}\r\nstatic int\r\nspecial_meter_get(struct snd_bebob *bebob, u32 *target, unsigned int size)\r\n{\r\n__be16 *buf;\r\nunsigned int i, c, channels;\r\nint err;\r\nchannels = ARRAY_SIZE(special_meter_labels) * 2;\r\nif (size < channels * sizeof(u32))\r\nreturn -EINVAL;\r\nbuf = kmalloc(METER_SIZE_SPECIAL - 4, GFP_KERNEL);\r\nif (buf == NULL)\r\nreturn -ENOMEM;\r\nerr = get_meter(bebob, (void *)buf, METER_SIZE_SPECIAL - 4);\r\nif (err < 0)\r\ngoto end;\r\ni = 0;\r\nfor (c = 2; c < channels + 2; c++)\r\ntarget[i++] = be16_to_cpu(buf[c]) << 16;\r\nend:\r\nkfree(buf);\r\nreturn err;\r\n}\r\nstatic int\r\nnormal_meter_get(struct snd_bebob *bebob, u32 *buf, unsigned int size)\r\n{\r\nconst struct snd_bebob_meter_spec *spec = bebob->spec->meter;\r\nunsigned int c, channels;\r\nint err;\r\nchannels = spec->num * 2;\r\nif (size < channels * sizeof(u32))\r\nreturn -EINVAL;\r\nerr = get_meter(bebob, (void *)buf, size);\r\nif (err < 0)\r\ngoto end;\r\nfor (c = 0; c < channels; c++)\r\nbe32_to_cpus(&buf[c]);\r\nif (spec->labels == solo_meter_labels) {\r\nswap(buf[4], buf[6]);\r\nswap(buf[5], buf[7]);\r\n}\r\nend:\r\nreturn err;\r\n}
