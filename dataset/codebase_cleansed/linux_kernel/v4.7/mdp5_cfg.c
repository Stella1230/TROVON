const struct mdp5_cfg_hw *mdp5_cfg_get_hw_config(struct mdp5_cfg_handler *cfg_handler)\r\n{\r\nreturn cfg_handler->config.hw;\r\n}\r\nstruct mdp5_cfg *mdp5_cfg_get_config(struct mdp5_cfg_handler *cfg_handler)\r\n{\r\nreturn &cfg_handler->config;\r\n}\r\nint mdp5_cfg_get_hw_rev(struct mdp5_cfg_handler *cfg_handler)\r\n{\r\nreturn cfg_handler->revision;\r\n}\r\nvoid mdp5_cfg_destroy(struct mdp5_cfg_handler *cfg_handler)\r\n{\r\nkfree(cfg_handler);\r\n}\r\nstruct mdp5_cfg_handler *mdp5_cfg_init(struct mdp5_kms *mdp5_kms,\r\nuint32_t major, uint32_t minor)\r\n{\r\nstruct drm_device *dev = mdp5_kms->dev;\r\nstruct platform_device *pdev = dev->platformdev;\r\nstruct mdp5_cfg_handler *cfg_handler;\r\nstruct mdp5_cfg_platform *pconfig;\r\nint i, ret = 0;\r\ncfg_handler = kzalloc(sizeof(*cfg_handler), GFP_KERNEL);\r\nif (unlikely(!cfg_handler)) {\r\nret = -ENOMEM;\r\ngoto fail;\r\n}\r\nif (major != 1) {\r\ndev_err(dev->dev, "unexpected MDP major version: v%d.%d\n",\r\nmajor, minor);\r\nret = -ENXIO;\r\ngoto fail;\r\n}\r\nfor (i = 0; i < ARRAY_SIZE(cfg_handlers); i++) {\r\nif (cfg_handlers[i].revision != minor)\r\ncontinue;\r\nmdp5_cfg = cfg_handlers[i].config.hw;\r\nbreak;\r\n}\r\nif (unlikely(!mdp5_cfg)) {\r\ndev_err(dev->dev, "unexpected MDP minor revision: v%d.%d\n",\r\nmajor, minor);\r\nret = -ENXIO;\r\ngoto fail;\r\n}\r\ncfg_handler->revision = minor;\r\ncfg_handler->config.hw = mdp5_cfg;\r\npconfig = mdp5_get_config(pdev);\r\nmemcpy(&cfg_handler->config.platform, pconfig, sizeof(*pconfig));\r\nDBG("MDP5: %s hw config selected", mdp5_cfg->name);\r\nreturn cfg_handler;\r\nfail:\r\nif (cfg_handler)\r\nmdp5_cfg_destroy(cfg_handler);\r\nreturn NULL;\r\n}\r\nstatic struct mdp5_cfg_platform *mdp5_get_config(struct platform_device *dev)\r\n{\r\nstatic struct mdp5_cfg_platform config = {};\r\nconfig.iommu = iommu_domain_alloc(&platform_bus_type);\r\nreturn &config;\r\n}
