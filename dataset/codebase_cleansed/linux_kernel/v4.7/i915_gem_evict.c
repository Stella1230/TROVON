static bool\r\nmark_free(struct i915_vma *vma, struct list_head *unwind)\r\n{\r\nif (vma->pin_count)\r\nreturn false;\r\nif (WARN_ON(!list_empty(&vma->exec_list)))\r\nreturn false;\r\nlist_add(&vma->exec_list, unwind);\r\nreturn drm_mm_scan_add_block(&vma->node);\r\n}\r\nint\r\ni915_gem_evict_something(struct drm_device *dev, struct i915_address_space *vm,\r\nint min_size, unsigned alignment, unsigned cache_level,\r\nunsigned long start, unsigned long end,\r\nunsigned flags)\r\n{\r\nstruct list_head eviction_list, unwind_list;\r\nstruct i915_vma *vma;\r\nint ret = 0;\r\nint pass = 0;\r\ntrace_i915_gem_evict(dev, min_size, alignment, flags);\r\nINIT_LIST_HEAD(&unwind_list);\r\nif (start != 0 || end != vm->total) {\r\ndrm_mm_init_scan_with_range(&vm->mm, min_size,\r\nalignment, cache_level,\r\nstart, end);\r\n} else\r\ndrm_mm_init_scan(&vm->mm, min_size, alignment, cache_level);\r\nsearch_again:\r\nlist_for_each_entry(vma, &vm->inactive_list, vm_link) {\r\nif (mark_free(vma, &unwind_list))\r\ngoto found;\r\n}\r\nif (flags & PIN_NONBLOCK)\r\ngoto none;\r\nlist_for_each_entry(vma, &vm->active_list, vm_link) {\r\nif (mark_free(vma, &unwind_list))\r\ngoto found;\r\n}\r\nnone:\r\nwhile (!list_empty(&unwind_list)) {\r\nvma = list_first_entry(&unwind_list,\r\nstruct i915_vma,\r\nexec_list);\r\nret = drm_mm_scan_remove_block(&vma->node);\r\nBUG_ON(ret);\r\nlist_del_init(&vma->exec_list);\r\n}\r\nif (flags & PIN_NONBLOCK)\r\nreturn -ENOSPC;\r\nif (pass++ == 0) {\r\nret = i915_gpu_idle(dev);\r\nif (ret)\r\nreturn ret;\r\ni915_gem_retire_requests(dev);\r\ngoto search_again;\r\n}\r\nreturn intel_has_pending_fb_unpin(dev) ? -EAGAIN : -ENOSPC;\r\nfound:\r\nINIT_LIST_HEAD(&eviction_list);\r\nwhile (!list_empty(&unwind_list)) {\r\nvma = list_first_entry(&unwind_list,\r\nstruct i915_vma,\r\nexec_list);\r\nif (drm_mm_scan_remove_block(&vma->node)) {\r\nlist_move(&vma->exec_list, &eviction_list);\r\ndrm_gem_object_reference(&vma->obj->base);\r\ncontinue;\r\n}\r\nlist_del_init(&vma->exec_list);\r\n}\r\nwhile (!list_empty(&eviction_list)) {\r\nstruct drm_gem_object *obj;\r\nvma = list_first_entry(&eviction_list,\r\nstruct i915_vma,\r\nexec_list);\r\nobj = &vma->obj->base;\r\nlist_del_init(&vma->exec_list);\r\nif (ret == 0)\r\nret = i915_vma_unbind(vma);\r\ndrm_gem_object_unreference(obj);\r\n}\r\nreturn ret;\r\n}\r\nint\r\ni915_gem_evict_for_vma(struct i915_vma *target)\r\n{\r\nstruct drm_mm_node *node, *next;\r\nlist_for_each_entry_safe(node, next,\r\n&target->vm->mm.head_node.node_list,\r\nnode_list) {\r\nstruct i915_vma *vma;\r\nint ret;\r\nif (node->start + node->size <= target->node.start)\r\ncontinue;\r\nif (node->start >= target->node.start + target->node.size)\r\nbreak;\r\nvma = container_of(node, typeof(*vma), node);\r\nif (vma->pin_count) {\r\nif (!vma->exec_entry || (vma->pin_count > 1))\r\nreturn -EBUSY;\r\nif (vma->exec_entry->flags & EXEC_OBJECT_PINNED)\r\nreturn -EINVAL;\r\nreturn -ENOSPC;\r\n}\r\nret = i915_vma_unbind(vma);\r\nif (ret)\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nint i915_gem_evict_vm(struct i915_address_space *vm, bool do_idle)\r\n{\r\nstruct i915_vma *vma, *next;\r\nint ret;\r\nWARN_ON(!mutex_is_locked(&vm->dev->struct_mutex));\r\ntrace_i915_gem_evict_vm(vm);\r\nif (do_idle) {\r\nret = i915_gpu_idle(vm->dev);\r\nif (ret)\r\nreturn ret;\r\ni915_gem_retire_requests(vm->dev);\r\nWARN_ON(!list_empty(&vm->active_list));\r\n}\r\nlist_for_each_entry_safe(vma, next, &vm->inactive_list, vm_link)\r\nif (vma->pin_count == 0)\r\nWARN_ON(i915_vma_unbind(vma));\r\nreturn 0;\r\n}
