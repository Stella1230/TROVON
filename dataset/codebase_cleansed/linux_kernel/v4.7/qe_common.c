int cpm_muram_init(void)\r\n{\r\nstruct device_node *np;\r\nstruct resource r;\r\nu32 zero[OF_MAX_ADDR_CELLS] = {};\r\nresource_size_t max = 0;\r\nint i = 0;\r\nint ret = 0;\r\nif (muram_pbase)\r\nreturn 0;\r\nspin_lock_init(&cpm_muram_lock);\r\nnp = of_find_compatible_node(NULL, NULL, "fsl,cpm-muram-data");\r\nif (!np) {\r\nnp = of_find_node_by_name(NULL, "data-only");\r\nif (!np) {\r\npr_err("Cannot find CPM muram data node");\r\nret = -ENODEV;\r\ngoto out_muram;\r\n}\r\n}\r\nmuram_pool = gen_pool_create(0, -1);\r\nmuram_pbase = of_translate_address(np, zero);\r\nif (muram_pbase == (phys_addr_t)OF_BAD_ADDR) {\r\npr_err("Cannot translate zero through CPM muram node");\r\nret = -ENODEV;\r\ngoto out_pool;\r\n}\r\nwhile (of_address_to_resource(np, i++, &r) == 0) {\r\nif (r.end > max)\r\nmax = r.end;\r\nret = gen_pool_add(muram_pool, r.start - muram_pbase +\r\nGENPOOL_OFFSET, resource_size(&r), -1);\r\nif (ret) {\r\npr_err("QE: couldn't add muram to pool!\n");\r\ngoto out_pool;\r\n}\r\n}\r\nmuram_vbase = ioremap(muram_pbase, max - muram_pbase + 1);\r\nif (!muram_vbase) {\r\npr_err("Cannot map QE muram");\r\nret = -ENOMEM;\r\ngoto out_pool;\r\n}\r\ngoto out_muram;\r\nout_pool:\r\ngen_pool_destroy(muram_pool);\r\nout_muram:\r\nof_node_put(np);\r\nreturn ret;\r\n}\r\nstatic unsigned long cpm_muram_alloc_common(unsigned long size,\r\ngenpool_algo_t algo, void *data)\r\n{\r\nstruct muram_block *entry;\r\nunsigned long start;\r\nstart = gen_pool_alloc_algo(muram_pool, size, algo, data);\r\nif (!start)\r\ngoto out2;\r\nstart = start - GENPOOL_OFFSET;\r\nmemset_io(cpm_muram_addr(start), 0, size);\r\nentry = kmalloc(sizeof(*entry), GFP_ATOMIC);\r\nif (!entry)\r\ngoto out1;\r\nentry->start = start;\r\nentry->size = size;\r\nlist_add(&entry->head, &muram_block_list);\r\nreturn start;\r\nout1:\r\ngen_pool_free(muram_pool, start, size);\r\nout2:\r\nreturn (unsigned long)-ENOMEM;\r\n}\r\nunsigned long cpm_muram_alloc(unsigned long size, unsigned long align)\r\n{\r\nunsigned long start;\r\nunsigned long flags;\r\nstruct genpool_data_align muram_pool_data;\r\nspin_lock_irqsave(&cpm_muram_lock, flags);\r\nmuram_pool_data.align = align;\r\nstart = cpm_muram_alloc_common(size, gen_pool_first_fit_align,\r\n&muram_pool_data);\r\nspin_unlock_irqrestore(&cpm_muram_lock, flags);\r\nreturn start;\r\n}\r\nint cpm_muram_free(unsigned long offset)\r\n{\r\nunsigned long flags;\r\nint size;\r\nstruct muram_block *tmp;\r\nsize = 0;\r\nspin_lock_irqsave(&cpm_muram_lock, flags);\r\nlist_for_each_entry(tmp, &muram_block_list, head) {\r\nif (tmp->start == offset) {\r\nsize = tmp->size;\r\nlist_del(&tmp->head);\r\nkfree(tmp);\r\nbreak;\r\n}\r\n}\r\ngen_pool_free(muram_pool, offset + GENPOOL_OFFSET, size);\r\nspin_unlock_irqrestore(&cpm_muram_lock, flags);\r\nreturn size;\r\n}\r\nunsigned long cpm_muram_alloc_fixed(unsigned long offset, unsigned long size)\r\n{\r\nunsigned long start;\r\nunsigned long flags;\r\nstruct genpool_data_fixed muram_pool_data_fixed;\r\nspin_lock_irqsave(&cpm_muram_lock, flags);\r\nmuram_pool_data_fixed.offset = offset + GENPOOL_OFFSET;\r\nstart = cpm_muram_alloc_common(size, gen_pool_fixed_alloc,\r\n&muram_pool_data_fixed);\r\nspin_unlock_irqrestore(&cpm_muram_lock, flags);\r\nreturn start;\r\n}\r\nvoid __iomem *cpm_muram_addr(unsigned long offset)\r\n{\r\nreturn muram_vbase + offset;\r\n}\r\nunsigned long cpm_muram_offset(void __iomem *addr)\r\n{\r\nreturn addr - (void __iomem *)muram_vbase;\r\n}\r\ndma_addr_t cpm_muram_dma(void __iomem *addr)\r\n{\r\nreturn muram_pbase + ((u8 __iomem *)addr - muram_vbase);\r\n}
