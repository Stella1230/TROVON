void snd_opl3_calc_volume(unsigned char *volbyte, int vel,\r\nstruct snd_midi_channel *chan)\r\n{\r\nint oldvol, newvol, n;\r\nint volume;\r\nvolume = (vel * chan->gm_volume * chan->gm_expression) / (127*127);\r\nif (volume > 127)\r\nvolume = 127;\r\noldvol = OPL3_TOTAL_LEVEL_MASK - (*volbyte & OPL3_TOTAL_LEVEL_MASK);\r\nnewvol = opl3_volume_table[volume] + oldvol;\r\nif (newvol > OPL3_TOTAL_LEVEL_MASK)\r\nnewvol = OPL3_TOTAL_LEVEL_MASK;\r\nelse if (newvol < 0)\r\nnewvol = 0;\r\nn = OPL3_TOTAL_LEVEL_MASK - (newvol & OPL3_TOTAL_LEVEL_MASK);\r\n*volbyte = (*volbyte & OPL3_KSL_MASK) | (n & OPL3_TOTAL_LEVEL_MASK);\r\n}\r\nstatic void snd_opl3_calc_pitch(unsigned char *fnum, unsigned char *blocknum,\r\nint note, struct snd_midi_channel *chan)\r\n{\r\nint block = ((note / 12) & 0x07) - 1;\r\nint idx = (note % 12) + 2;\r\nint freq;\r\nif (chan->midi_pitchbend) {\r\nint pitchbend = chan->midi_pitchbend;\r\nint segment;\r\nif (pitchbend < -0x2000)\r\npitchbend = -0x2000;\r\nif (pitchbend > 0x1FFF)\r\npitchbend = 0x1FFF;\r\nsegment = pitchbend / 0x1000;\r\nfreq = opl3_note_table[idx+segment];\r\nfreq += ((opl3_note_table[idx+segment+1] - freq) *\r\n(pitchbend % 0x1000)) / 0x1000;\r\n} else {\r\nfreq = opl3_note_table[idx];\r\n}\r\n*fnum = (unsigned char) freq;\r\n*blocknum = ((freq >> 8) & OPL3_FNUM_HIGH_MASK) |\r\n((block << 2) & OPL3_BLOCKNUM_MASK);\r\n}\r\nstatic void debug_alloc(struct snd_opl3 *opl3, char *s, int voice) {\r\nint i;\r\nchar *str = "x.24";\r\nprintk(KERN_DEBUG "time %.5i: %s [%.2i]: ", opl3->use_time, s, voice);\r\nfor (i = 0; i < opl3->max_voices; i++)\r\nprintk("%c", *(str + opl3->voices[i].state + 1));\r\nprintk("\n");\r\n}\r\nstatic int opl3_get_voice(struct snd_opl3 *opl3, int instr_4op,\r\nstruct snd_midi_channel *chan) {\r\nint chan_4op_1;\r\nint chan_4op_2;\r\nstruct snd_opl3_voice *vp, *vp2;\r\nunsigned int voice_time;\r\nint i;\r\n#ifdef DEBUG_ALLOC\r\nchar *alloc_type[3] = { "FREE ", "CHEAP ", "EXPENSIVE" };\r\n#endif\r\nenum {\r\nFREE = 0, CHEAP, EXPENSIVE, END\r\n};\r\nstruct best {\r\nunsigned int time;\r\nint voice;\r\n} best[END];\r\nstruct best *bp;\r\nfor (i = 0; i < END; i++) {\r\nbest[i].time = (unsigned int)(-1);\r\nbest[i].voice = -1;\r\n}\r\nfor (i = 0; i < opl3->max_voices; i++) {\r\nvp = &opl3->voices[i];\r\nif (vp->state == SNDRV_OPL3_ST_NOT_AVAIL)\r\ncontinue;\r\nvoice_time = vp->time;\r\nbp = best;\r\nchan_4op_1 = ((i < 3) || (i > 8 && i < 12));\r\nchan_4op_2 = ((i > 2 && i < 6) || (i > 11 && i < 15));\r\nif (instr_4op) {\r\nif (!chan_4op_1)\r\ncontinue;\r\nif (vp->state)\r\nbp++;\r\nvp2 = &opl3->voices[i + 3];\r\nif (vp2->state == SNDRV_OPL3_ST_ON_2OP) {\r\nbp++;\r\nvoice_time = (voice_time > vp->time) ?\r\nvoice_time : vp->time;\r\n}\r\n} else {\r\nif ((chan_4op_1) || (chan_4op_2))\r\nbp++;\r\nelse if (vp->state)\r\nbp++;\r\nif (vp->state)\r\nbp++;\r\n}\r\nif (voice_time < bp->time) {\r\nbp->time = voice_time;\r\nbp->voice = i;\r\n}\r\n}\r\nfor (i = 0; i < END; i++) {\r\nif (best[i].voice >= 0) {\r\n#ifdef DEBUG_ALLOC\r\nprintk(KERN_DEBUG "%s %iop allocation on voice %i\n",\r\nalloc_type[i], instr_4op ? 4 : 2,\r\nbest[i].voice);\r\n#endif\r\nreturn best[i].voice;\r\n}\r\n}\r\nreturn -1;\r\n}\r\nvoid snd_opl3_timer_func(unsigned long data)\r\n{\r\nstruct snd_opl3 *opl3 = (struct snd_opl3 *)data;\r\nunsigned long flags;\r\nint again = 0;\r\nint i;\r\nspin_lock_irqsave(&opl3->voice_lock, flags);\r\nfor (i = 0; i < opl3->max_voices; i++) {\r\nstruct snd_opl3_voice *vp = &opl3->voices[i];\r\nif (vp->state > 0 && vp->note_off_check) {\r\nif (vp->note_off == jiffies)\r\nsnd_opl3_note_off_unsafe(opl3, vp->note, 0,\r\nvp->chan);\r\nelse\r\nagain++;\r\n}\r\n}\r\nspin_unlock_irqrestore(&opl3->voice_lock, flags);\r\nspin_lock_irqsave(&opl3->sys_timer_lock, flags);\r\nif (again)\r\nmod_timer(&opl3->tlist, jiffies + 1);\r\nelse\r\nopl3->sys_timer_status = 0;\r\nspin_unlock_irqrestore(&opl3->sys_timer_lock, flags);\r\n}\r\nstatic void snd_opl3_start_timer(struct snd_opl3 *opl3)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&opl3->sys_timer_lock, flags);\r\nif (! opl3->sys_timer_status) {\r\nmod_timer(&opl3->tlist, jiffies + 1);\r\nopl3->sys_timer_status = 1;\r\n}\r\nspin_unlock_irqrestore(&opl3->sys_timer_lock, flags);\r\n}\r\nvoid snd_opl3_note_on(void *p, int note, int vel, struct snd_midi_channel *chan)\r\n{\r\nstruct snd_opl3 *opl3;\r\nint instr_4op;\r\nint voice;\r\nstruct snd_opl3_voice *vp, *vp2;\r\nunsigned short connect_mask;\r\nunsigned char connection;\r\nunsigned char vol_op[4];\r\nint extra_prg = 0;\r\nunsigned short reg_side;\r\nunsigned char op_offset;\r\nunsigned char voice_offset;\r\nunsigned short opl3_reg;\r\nunsigned char reg_val;\r\nunsigned char prg, bank;\r\nint key = note;\r\nunsigned char fnum, blocknum;\r\nint i;\r\nstruct fm_patch *patch;\r\nstruct fm_instrument *fm;\r\nunsigned long flags;\r\nopl3 = p;\r\n#ifdef DEBUG_MIDI\r\nsnd_printk(KERN_DEBUG "Note on, ch %i, inst %i, note %i, vel %i\n",\r\nchan->number, chan->midi_program, note, vel);\r\n#endif\r\nif (opl3->synth_mode == SNDRV_OPL3_MODE_SEQ) {\r\nif (chan->drum_channel) {\r\nbank = 128;\r\nprg = note;\r\n} else {\r\nbank = chan->gm_bank_select;\r\nprg = chan->midi_program;\r\n}\r\n} else {\r\nif (chan->number >= MAX_OPL3_VOICES)\r\nreturn;\r\nbank = 127;\r\nprg = chan->midi_program;\r\n}\r\nspin_lock_irqsave(&opl3->voice_lock, flags);\r\nif (use_internal_drums) {\r\nsnd_opl3_drum_switch(opl3, note, vel, 1, chan);\r\nspin_unlock_irqrestore(&opl3->voice_lock, flags);\r\nreturn;\r\n}\r\n__extra_prg:\r\npatch = snd_opl3_find_patch(opl3, prg, bank, 0);\r\nif (!patch) {\r\nspin_unlock_irqrestore(&opl3->voice_lock, flags);\r\nreturn;\r\n}\r\nfm = &patch->inst;\r\nswitch (patch->type) {\r\ncase FM_PATCH_OPL2:\r\ninstr_4op = 0;\r\nbreak;\r\ncase FM_PATCH_OPL3:\r\nif (opl3->hardware >= OPL3_HW_OPL3) {\r\ninstr_4op = 1;\r\nbreak;\r\n}\r\ndefault:\r\nspin_unlock_irqrestore(&opl3->voice_lock, flags);\r\nreturn;\r\n}\r\n#ifdef DEBUG_MIDI\r\nsnd_printk(KERN_DEBUG " --> OPL%i instrument: %s\n",\r\ninstr_4op ? 3 : 2, patch->name);\r\n#endif\r\nif (opl3->synth_mode == SNDRV_OPL3_MODE_SEQ) {\r\nvoice = opl3_get_voice(opl3, instr_4op, chan);\r\n} else {\r\nvoice = snd_opl3_oss_map[chan->number];\r\n}\r\nif (voice < 0) {\r\nspin_unlock_irqrestore(&opl3->voice_lock, flags);\r\nreturn;\r\n}\r\nif (voice < MAX_OPL2_VOICES) {\r\nreg_side = OPL3_LEFT;\r\nvoice_offset = voice;\r\nconnect_mask = (OPL3_LEFT_4OP_0 << voice_offset) & 0x07;\r\n} else {\r\nreg_side = OPL3_RIGHT;\r\nvoice_offset = voice - MAX_OPL2_VOICES;\r\nconnect_mask = (OPL3_RIGHT_4OP_0 << voice_offset) & 0x38;\r\n}\r\nvp = &opl3->voices[voice];\r\nif (vp->state > 0) {\r\nopl3_reg = reg_side | (OPL3_REG_KEYON_BLOCK + voice_offset);\r\nreg_val = vp->keyon_reg & ~OPL3_KEYON_BIT;\r\nopl3->command(opl3, opl3_reg, reg_val);\r\n}\r\nif (instr_4op) {\r\nvp2 = &opl3->voices[voice + 3];\r\nif (vp->state > 0) {\r\nopl3_reg = reg_side | (OPL3_REG_KEYON_BLOCK +\r\nvoice_offset + 3);\r\nreg_val = vp->keyon_reg & ~OPL3_KEYON_BIT;\r\nopl3->command(opl3, opl3_reg, reg_val);\r\n}\r\n}\r\nif (instr_4op) {\r\nif ((opl3->connection_reg ^ connect_mask) & connect_mask) {\r\nopl3->connection_reg |= connect_mask;\r\nopl3_reg = OPL3_RIGHT | OPL3_REG_CONNECTION_SELECT;\r\nopl3->command(opl3, opl3_reg, opl3->connection_reg);\r\n}\r\n} else {\r\nif ((opl3->connection_reg ^ ~connect_mask) & connect_mask) {\r\nopl3->connection_reg &= ~connect_mask;\r\nopl3_reg = OPL3_RIGHT | OPL3_REG_CONNECTION_SELECT;\r\nopl3->command(opl3, opl3_reg, opl3->connection_reg);\r\n}\r\n}\r\n#ifdef DEBUG_MIDI\r\nsnd_printk(KERN_DEBUG " --> setting OPL3 connection: 0x%x\n",\r\nopl3->connection_reg);\r\n#endif\r\nfor (i = 0; i < (instr_4op ? 4 : 2); i++)\r\nvol_op[i] = fm->op[i].ksl_level;\r\nconnection = fm->feedback_connection[0] & 0x01;\r\nif (instr_4op) {\r\nconnection <<= 1;\r\nconnection |= fm->feedback_connection[1] & 0x01;\r\nsnd_opl3_calc_volume(&vol_op[3], vel, chan);\r\nswitch (connection) {\r\ncase 0x03:\r\nsnd_opl3_calc_volume(&vol_op[2], vel, chan);\r\ncase 0x02:\r\nsnd_opl3_calc_volume(&vol_op[0], vel, chan);\r\nbreak;\r\ncase 0x01:\r\nsnd_opl3_calc_volume(&vol_op[1], vel, chan);\r\n}\r\n} else {\r\nsnd_opl3_calc_volume(&vol_op[1], vel, chan);\r\nif (connection)\r\nsnd_opl3_calc_volume(&vol_op[0], vel, chan);\r\n}\r\nfor (i = 0; i < (instr_4op ? 4 : 2); i++) {\r\n#ifdef DEBUG_MIDI\r\nsnd_printk(KERN_DEBUG " --> programming operator %i\n", i);\r\n#endif\r\nop_offset = snd_opl3_regmap[voice_offset][i];\r\nreg_val = fm->op[i].am_vib;\r\nopl3_reg = reg_side | (OPL3_REG_AM_VIB + op_offset);\r\nopl3->command(opl3, opl3_reg, reg_val);\r\nreg_val = vol_op[i];\r\nopl3_reg = reg_side | (OPL3_REG_KSL_LEVEL + op_offset);\r\nopl3->command(opl3, opl3_reg, reg_val);\r\nreg_val = fm->op[i].attack_decay;\r\nopl3_reg = reg_side | (OPL3_REG_ATTACK_DECAY + op_offset);\r\nopl3->command(opl3, opl3_reg, reg_val);\r\nreg_val = fm->op[i].sustain_release;\r\nopl3_reg = reg_side | (OPL3_REG_SUSTAIN_RELEASE + op_offset);\r\nopl3->command(opl3, opl3_reg, reg_val);\r\nreg_val = fm->op[i].wave_select;\r\nopl3_reg = reg_side | (OPL3_REG_WAVE_SELECT + op_offset);\r\nopl3->command(opl3, opl3_reg, reg_val);\r\n}\r\nreg_val = fm->feedback_connection[0];\r\nreg_val |= OPL3_STEREO_BITS;\r\nif (chan->gm_pan < 43)\r\nreg_val &= ~OPL3_VOICE_TO_RIGHT;\r\nif (chan->gm_pan > 85)\r\nreg_val &= ~OPL3_VOICE_TO_LEFT;\r\nopl3_reg = reg_side | (OPL3_REG_FEEDBACK_CONNECTION + voice_offset);\r\nopl3->command(opl3, opl3_reg, reg_val);\r\nif (instr_4op) {\r\nreg_val = fm->feedback_connection[1] & OPL3_CONNECTION_BIT;\r\nreg_val |= OPL3_STEREO_BITS;\r\nif (chan->gm_pan < 43)\r\nreg_val &= ~OPL3_VOICE_TO_RIGHT;\r\nif (chan->gm_pan > 85)\r\nreg_val &= ~OPL3_VOICE_TO_LEFT;\r\nopl3_reg = reg_side | (OPL3_REG_FEEDBACK_CONNECTION +\r\nvoice_offset + 3);\r\nopl3->command(opl3, opl3_reg, reg_val);\r\n}\r\nif (fm->fix_key)\r\nnote = fm->fix_key;\r\nif (fm->trnsps)\r\nnote += (fm->trnsps - 64);\r\nsnd_opl3_calc_pitch(&fnum, &blocknum, note, chan);\r\nopl3_reg = reg_side | (OPL3_REG_FNUM_LOW + voice_offset);\r\nopl3->command(opl3, opl3_reg, fnum);\r\nopl3->voices[voice].keyon_reg = blocknum;\r\nblocknum |= OPL3_KEYON_BIT;\r\n#ifdef DEBUG_MIDI\r\nsnd_printk(KERN_DEBUG " --> trigger voice %i\n", voice);\r\n#endif\r\nopl3_reg = reg_side | (OPL3_REG_KEYON_BLOCK + voice_offset);\r\nopl3->command(opl3, opl3_reg, blocknum);\r\nif (fm->fix_dur) {\r\nopl3->voices[voice].note_off = jiffies +\r\n(fm->fix_dur * HZ) / 100;\r\nsnd_opl3_start_timer(opl3);\r\nopl3->voices[voice].note_off_check = 1;\r\n} else\r\nopl3->voices[voice].note_off_check = 0;\r\nextra_prg = (extra_prg) ? 0 : fm->modes;\r\nvp->time = opl3->use_time++;\r\nvp->note = key;\r\nvp->chan = chan;\r\nif (instr_4op) {\r\nvp->state = SNDRV_OPL3_ST_ON_4OP;\r\nvp2 = &opl3->voices[voice + 3];\r\nvp2->time = opl3->use_time++;\r\nvp2->note = key;\r\nvp2->chan = chan;\r\nvp2->state = SNDRV_OPL3_ST_NOT_AVAIL;\r\n} else {\r\nif (vp->state == SNDRV_OPL3_ST_ON_4OP) {\r\nvp2 = &opl3->voices[voice + 3];\r\nvp2->time = opl3->use_time++;\r\nvp2->state = SNDRV_OPL3_ST_OFF;\r\n}\r\nvp->state = SNDRV_OPL3_ST_ON_2OP;\r\n}\r\n#ifdef DEBUG_ALLOC\r\ndebug_alloc(opl3, "note on ", voice);\r\n#endif\r\nif (extra_prg) {\r\nif (extra_prg > 128) {\r\nbank = 128;\r\nprg = extra_prg - 128 + 35 - 1;\r\n} else {\r\nbank = 0;\r\nprg = extra_prg - 1;\r\n}\r\n#ifdef DEBUG_MIDI\r\nsnd_printk(KERN_DEBUG " *** allocating extra program\n");\r\n#endif\r\ngoto __extra_prg;\r\n}\r\nspin_unlock_irqrestore(&opl3->voice_lock, flags);\r\n}\r\nstatic void snd_opl3_kill_voice(struct snd_opl3 *opl3, int voice)\r\n{\r\nunsigned short reg_side;\r\nunsigned char voice_offset;\r\nunsigned short opl3_reg;\r\nstruct snd_opl3_voice *vp, *vp2;\r\nif (snd_BUG_ON(voice >= MAX_OPL3_VOICES))\r\nreturn;\r\nvp = &opl3->voices[voice];\r\nif (voice < MAX_OPL2_VOICES) {\r\nreg_side = OPL3_LEFT;\r\nvoice_offset = voice;\r\n} else {\r\nreg_side = OPL3_RIGHT;\r\nvoice_offset = voice - MAX_OPL2_VOICES;\r\n}\r\n#ifdef DEBUG_MIDI\r\nsnd_printk(KERN_DEBUG " --> kill voice %i\n", voice);\r\n#endif\r\nopl3_reg = reg_side | (OPL3_REG_KEYON_BLOCK + voice_offset);\r\nopl3->command(opl3, opl3_reg, vp->keyon_reg);\r\nvp->time = opl3->use_time++;\r\nif (vp->state == SNDRV_OPL3_ST_ON_4OP) {\r\nvp2 = &opl3->voices[voice + 3];\r\nvp2->time = opl3->use_time++;\r\nvp2->state = SNDRV_OPL3_ST_OFF;\r\n}\r\nvp->state = SNDRV_OPL3_ST_OFF;\r\n#ifdef DEBUG_ALLOC\r\ndebug_alloc(opl3, "note off", voice);\r\n#endif\r\n}\r\nstatic void snd_opl3_note_off_unsafe(void *p, int note, int vel,\r\nstruct snd_midi_channel *chan)\r\n{\r\nstruct snd_opl3 *opl3;\r\nint voice;\r\nstruct snd_opl3_voice *vp;\r\nopl3 = p;\r\n#ifdef DEBUG_MIDI\r\nsnd_printk(KERN_DEBUG "Note off, ch %i, inst %i, note %i\n",\r\nchan->number, chan->midi_program, note);\r\n#endif\r\nif (opl3->synth_mode == SNDRV_OPL3_MODE_SEQ) {\r\nif (chan->drum_channel && use_internal_drums) {\r\nsnd_opl3_drum_switch(opl3, note, vel, 0, chan);\r\nreturn;\r\n}\r\nfor (voice = 0; voice < opl3->max_voices; voice++) {\r\nvp = &opl3->voices[voice];\r\nif (vp->state > 0 && vp->chan == chan && vp->note == note) {\r\nsnd_opl3_kill_voice(opl3, voice);\r\n}\r\n}\r\n} else {\r\nif (chan->number < MAX_OPL3_VOICES) {\r\nvoice = snd_opl3_oss_map[chan->number];\r\nsnd_opl3_kill_voice(opl3, voice);\r\n}\r\n}\r\n}\r\nvoid snd_opl3_note_off(void *p, int note, int vel,\r\nstruct snd_midi_channel *chan)\r\n{\r\nstruct snd_opl3 *opl3 = p;\r\nunsigned long flags;\r\nspin_lock_irqsave(&opl3->voice_lock, flags);\r\nsnd_opl3_note_off_unsafe(p, note, vel, chan);\r\nspin_unlock_irqrestore(&opl3->voice_lock, flags);\r\n}\r\nvoid snd_opl3_key_press(void *p, int note, int vel, struct snd_midi_channel *chan)\r\n{\r\nstruct snd_opl3 *opl3;\r\nopl3 = p;\r\n#ifdef DEBUG_MIDI\r\nsnd_printk(KERN_DEBUG "Key pressure, ch#: %i, inst#: %i\n",\r\nchan->number, chan->midi_program);\r\n#endif\r\n}\r\nvoid snd_opl3_terminate_note(void *p, int note, struct snd_midi_channel *chan)\r\n{\r\nstruct snd_opl3 *opl3;\r\nopl3 = p;\r\n#ifdef DEBUG_MIDI\r\nsnd_printk(KERN_DEBUG "Terminate note, ch#: %i, inst#: %i\n",\r\nchan->number, chan->midi_program);\r\n#endif\r\n}\r\nstatic void snd_opl3_update_pitch(struct snd_opl3 *opl3, int voice)\r\n{\r\nunsigned short reg_side;\r\nunsigned char voice_offset;\r\nunsigned short opl3_reg;\r\nunsigned char fnum, blocknum;\r\nstruct snd_opl3_voice *vp;\r\nif (snd_BUG_ON(voice >= MAX_OPL3_VOICES))\r\nreturn;\r\nvp = &opl3->voices[voice];\r\nif (vp->chan == NULL)\r\nreturn;\r\nif (voice < MAX_OPL2_VOICES) {\r\nreg_side = OPL3_LEFT;\r\nvoice_offset = voice;\r\n} else {\r\nreg_side = OPL3_RIGHT;\r\nvoice_offset = voice - MAX_OPL2_VOICES;\r\n}\r\nsnd_opl3_calc_pitch(&fnum, &blocknum, vp->note, vp->chan);\r\nopl3_reg = reg_side | (OPL3_REG_FNUM_LOW + voice_offset);\r\nopl3->command(opl3, opl3_reg, fnum);\r\nvp->keyon_reg = blocknum;\r\nblocknum |= OPL3_KEYON_BIT;\r\nopl3_reg = reg_side | (OPL3_REG_KEYON_BLOCK + voice_offset);\r\nopl3->command(opl3, opl3_reg, blocknum);\r\nvp->time = opl3->use_time++;\r\n}\r\nstatic void snd_opl3_pitch_ctrl(struct snd_opl3 *opl3, struct snd_midi_channel *chan)\r\n{\r\nint voice;\r\nstruct snd_opl3_voice *vp;\r\nunsigned long flags;\r\nspin_lock_irqsave(&opl3->voice_lock, flags);\r\nif (opl3->synth_mode == SNDRV_OPL3_MODE_SEQ) {\r\nfor (voice = 0; voice < opl3->max_voices; voice++) {\r\nvp = &opl3->voices[voice];\r\nif (vp->state > 0 && vp->chan == chan) {\r\nsnd_opl3_update_pitch(opl3, voice);\r\n}\r\n}\r\n} else {\r\nif (chan->number < MAX_OPL3_VOICES) {\r\nvoice = snd_opl3_oss_map[chan->number];\r\nsnd_opl3_update_pitch(opl3, voice);\r\n}\r\n}\r\nspin_unlock_irqrestore(&opl3->voice_lock, flags);\r\n}\r\nvoid snd_opl3_control(void *p, int type, struct snd_midi_channel *chan)\r\n{\r\nstruct snd_opl3 *opl3;\r\nopl3 = p;\r\n#ifdef DEBUG_MIDI\r\nsnd_printk(KERN_DEBUG "Controller, TYPE = %i, ch#: %i, inst#: %i\n",\r\ntype, chan->number, chan->midi_program);\r\n#endif\r\nswitch (type) {\r\ncase MIDI_CTL_MSB_MODWHEEL:\r\nif (chan->control[MIDI_CTL_MSB_MODWHEEL] > 63)\r\nopl3->drum_reg |= OPL3_VIBRATO_DEPTH;\r\nelse\r\nopl3->drum_reg &= ~OPL3_VIBRATO_DEPTH;\r\nopl3->command(opl3, OPL3_LEFT | OPL3_REG_PERCUSSION,\r\nopl3->drum_reg);\r\nbreak;\r\ncase MIDI_CTL_E2_TREMOLO_DEPTH:\r\nif (chan->control[MIDI_CTL_E2_TREMOLO_DEPTH] > 63)\r\nopl3->drum_reg |= OPL3_TREMOLO_DEPTH;\r\nelse\r\nopl3->drum_reg &= ~OPL3_TREMOLO_DEPTH;\r\nopl3->command(opl3, OPL3_LEFT | OPL3_REG_PERCUSSION,\r\nopl3->drum_reg);\r\nbreak;\r\ncase MIDI_CTL_PITCHBEND:\r\nsnd_opl3_pitch_ctrl(opl3, chan);\r\nbreak;\r\n}\r\n}\r\nvoid snd_opl3_nrpn(void *p, struct snd_midi_channel *chan,\r\nstruct snd_midi_channel_set *chset)\r\n{\r\nstruct snd_opl3 *opl3;\r\nopl3 = p;\r\n#ifdef DEBUG_MIDI\r\nsnd_printk(KERN_DEBUG "NRPN, ch#: %i, inst#: %i\n",\r\nchan->number, chan->midi_program);\r\n#endif\r\n}\r\nvoid snd_opl3_sysex(void *p, unsigned char *buf, int len,\r\nint parsed, struct snd_midi_channel_set *chset)\r\n{\r\nstruct snd_opl3 *opl3;\r\nopl3 = p;\r\n#ifdef DEBUG_MIDI\r\nsnd_printk(KERN_DEBUG "SYSEX\n");\r\n#endif\r\n}
