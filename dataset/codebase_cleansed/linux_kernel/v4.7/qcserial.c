static int handle_quectel_ec20(struct device *dev, int ifnum)\r\n{\r\nint altsetting = 0;\r\nswitch (ifnum) {\r\ncase 0:\r\ndev_dbg(dev, "Quectel EC20 DM/DIAG interface found\n");\r\nbreak;\r\ncase 1:\r\ndev_dbg(dev, "Quectel EC20 NMEA GPS interface found\n");\r\nbreak;\r\ncase 2:\r\ncase 3:\r\ndev_dbg(dev, "Quectel EC20 Modem port found\n");\r\nbreak;\r\ncase 4:\r\naltsetting = -1;\r\nbreak;\r\n}\r\nreturn altsetting;\r\n}\r\nstatic int qcprobe(struct usb_serial *serial, const struct usb_device_id *id)\r\n{\r\nstruct usb_host_interface *intf = serial->interface->cur_altsetting;\r\nstruct device *dev = &serial->dev->dev;\r\nint retval = -ENODEV;\r\n__u8 nintf;\r\n__u8 ifnum;\r\nint altsetting = -1;\r\nbool sendsetup = false;\r\nif (intf->desc.bInterfaceClass != USB_CLASS_VENDOR_SPEC)\r\ngoto done;\r\nnintf = serial->dev->actconfig->desc.bNumInterfaces;\r\ndev_dbg(dev, "Num Interfaces = %d\n", nintf);\r\nifnum = intf->desc.bInterfaceNumber;\r\ndev_dbg(dev, "This Interface = %d\n", ifnum);\r\nif (nintf == 1) {\r\nif (serial->interface->num_altsetting == 2)\r\nintf = &serial->interface->altsetting[1];\r\nelse if (serial->interface->num_altsetting > 2)\r\ngoto done;\r\nif (intf->desc.bNumEndpoints == 2 &&\r\nusb_endpoint_is_bulk_in(&intf->endpoint[0].desc) &&\r\nusb_endpoint_is_bulk_out(&intf->endpoint[1].desc)) {\r\ndev_dbg(dev, "QDL port found\n");\r\nif (serial->interface->num_altsetting == 1)\r\nretval = 0;\r\nelse\r\naltsetting = 1;\r\n}\r\ngoto done;\r\n}\r\naltsetting = 0;\r\nswitch (id->driver_info) {\r\ncase QCSERIAL_G1K:\r\nif (nintf < 3 || nintf > 4) {\r\ndev_err(dev, "unknown number of interfaces: %d\n", nintf);\r\naltsetting = -1;\r\ngoto done;\r\n}\r\nif (ifnum == 0) {\r\ndev_dbg(dev, "Gobi 1K DM/DIAG interface found\n");\r\naltsetting = 1;\r\n} else if (ifnum == 2)\r\ndev_dbg(dev, "Modem port found\n");\r\nelse\r\naltsetting = -1;\r\nbreak;\r\ncase QCSERIAL_G2K:\r\nif (nintf == 5 && id->idProduct == QUECTEL_EC20_PID) {\r\naltsetting = handle_quectel_ec20(dev, ifnum);\r\ngoto done;\r\n}\r\nif (nintf < 3 || nintf > 4) {\r\ndev_err(dev, "unknown number of interfaces: %d\n", nintf);\r\naltsetting = -1;\r\ngoto done;\r\n}\r\nswitch (ifnum) {\r\ncase 0:\r\naltsetting = -1;\r\nbreak;\r\ncase 1:\r\ndev_dbg(dev, "Gobi 2K+ DM/DIAG interface found\n");\r\nbreak;\r\ncase 2:\r\ndev_dbg(dev, "Modem port found\n");\r\nbreak;\r\ncase 3:\r\ndev_dbg(dev, "Gobi 2K+ NMEA GPS interface found\n");\r\nbreak;\r\n}\r\nbreak;\r\ncase QCSERIAL_SWI:\r\nswitch (ifnum) {\r\ncase 0:\r\ndev_dbg(dev, "DM/DIAG interface found\n");\r\nbreak;\r\ncase 2:\r\ndev_dbg(dev, "NMEA GPS interface found\n");\r\nbreak;\r\ncase 3:\r\ndev_dbg(dev, "Modem port found\n");\r\nsendsetup = true;\r\nbreak;\r\ndefault:\r\naltsetting = -1;\r\nbreak;\r\n}\r\nbreak;\r\ncase QCSERIAL_HWI:\r\nswitch (intf->desc.bInterfaceProtocol) {\r\ncase 0x07:\r\ncase 0x37:\r\ncase 0x67:\r\ncase 0x08:\r\ncase 0x38:\r\ncase 0x68:\r\ncase 0x09:\r\ncase 0x39:\r\ncase 0x69:\r\ncase 0x16:\r\ncase 0x46:\r\ncase 0x76:\r\naltsetting = -1;\r\nbreak;\r\ndefault:\r\ndev_dbg(dev, "Huawei type serial port found (%02x/%02x/%02x)\n",\r\nintf->desc.bInterfaceClass,\r\nintf->desc.bInterfaceSubClass,\r\nintf->desc.bInterfaceProtocol);\r\n}\r\nbreak;\r\ndefault:\r\ndev_err(dev, "unsupported device layout type: %lu\n",\r\nid->driver_info);\r\nbreak;\r\n}\r\ndone:\r\nif (altsetting >= 0) {\r\nretval = usb_set_interface(serial->dev, ifnum, altsetting);\r\nif (retval < 0) {\r\ndev_err(dev,\r\n"Could not set interface, error %d\n",\r\nretval);\r\nretval = -ENODEV;\r\n}\r\n}\r\nif (!retval)\r\nusb_set_serial_data(serial, (void *)(unsigned long)sendsetup);\r\nreturn retval;\r\n}\r\nstatic int qc_attach(struct usb_serial *serial)\r\n{\r\nstruct usb_wwan_intf_private *data;\r\nbool sendsetup;\r\ndata = kzalloc(sizeof(*data), GFP_KERNEL);\r\nif (!data)\r\nreturn -ENOMEM;\r\nsendsetup = !!(unsigned long)(usb_get_serial_data(serial));\r\nif (sendsetup)\r\ndata->use_send_setup = 1;\r\nspin_lock_init(&data->susp_lock);\r\nusb_set_serial_data(serial, data);\r\nreturn 0;\r\n}\r\nstatic void qc_release(struct usb_serial *serial)\r\n{\r\nstruct usb_wwan_intf_private *priv = usb_get_serial_data(serial);\r\nusb_set_serial_data(serial, NULL);\r\nkfree(priv);\r\n}
