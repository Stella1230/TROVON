int fcoe_link_speed_update(struct fc_lport *lport)\r\n{\r\nstruct net_device *netdev = fcoe_get_netdev(lport);\r\nstruct ethtool_link_ksettings ecmd;\r\nif (!__ethtool_get_link_ksettings(netdev, &ecmd)) {\r\nlport->link_supported_speeds &= ~(FC_PORTSPEED_1GBIT |\r\nFC_PORTSPEED_10GBIT |\r\nFC_PORTSPEED_20GBIT |\r\nFC_PORTSPEED_40GBIT);\r\nif (ecmd.link_modes.supported[0] & (\r\nSUPPORTED_1000baseT_Half |\r\nSUPPORTED_1000baseT_Full |\r\nSUPPORTED_1000baseKX_Full))\r\nlport->link_supported_speeds |= FC_PORTSPEED_1GBIT;\r\nif (ecmd.link_modes.supported[0] & (\r\nSUPPORTED_10000baseT_Full |\r\nSUPPORTED_10000baseKX4_Full |\r\nSUPPORTED_10000baseKR_Full |\r\nSUPPORTED_10000baseR_FEC))\r\nlport->link_supported_speeds |= FC_PORTSPEED_10GBIT;\r\nif (ecmd.link_modes.supported[0] & (\r\nSUPPORTED_20000baseMLD2_Full |\r\nSUPPORTED_20000baseKR2_Full))\r\nlport->link_supported_speeds |= FC_PORTSPEED_20GBIT;\r\nif (ecmd.link_modes.supported[0] & (\r\nSUPPORTED_40000baseKR4_Full |\r\nSUPPORTED_40000baseCR4_Full |\r\nSUPPORTED_40000baseSR4_Full |\r\nSUPPORTED_40000baseLR4_Full))\r\nlport->link_supported_speeds |= FC_PORTSPEED_40GBIT;\r\nswitch (ecmd.base.speed) {\r\ncase SPEED_1000:\r\nlport->link_speed = FC_PORTSPEED_1GBIT;\r\nbreak;\r\ncase SPEED_10000:\r\nlport->link_speed = FC_PORTSPEED_10GBIT;\r\nbreak;\r\ncase 20000:\r\nlport->link_speed = FC_PORTSPEED_20GBIT;\r\nbreak;\r\ncase 40000:\r\nlport->link_speed = FC_PORTSPEED_40GBIT;\r\nbreak;\r\ndefault:\r\nlport->link_speed = FC_PORTSPEED_UNKNOWN;\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nreturn -1;\r\n}\r\nvoid __fcoe_get_lesb(struct fc_lport *lport,\r\nstruct fc_els_lesb *fc_lesb,\r\nstruct net_device *netdev)\r\n{\r\nunsigned int cpu;\r\nu32 lfc, vlfc, mdac;\r\nstruct fc_stats *stats;\r\nstruct fcoe_fc_els_lesb *lesb;\r\nstruct rtnl_link_stats64 temp;\r\nlfc = 0;\r\nvlfc = 0;\r\nmdac = 0;\r\nlesb = (struct fcoe_fc_els_lesb *)fc_lesb;\r\nmemset(lesb, 0, sizeof(*lesb));\r\nfor_each_possible_cpu(cpu) {\r\nstats = per_cpu_ptr(lport->stats, cpu);\r\nlfc += stats->LinkFailureCount;\r\nvlfc += stats->VLinkFailureCount;\r\nmdac += stats->MissDiscAdvCount;\r\n}\r\nlesb->lesb_link_fail = htonl(lfc);\r\nlesb->lesb_vlink_fail = htonl(vlfc);\r\nlesb->lesb_miss_fka = htonl(mdac);\r\nlesb->lesb_fcs_error =\r\nhtonl(dev_get_stats(netdev, &temp)->rx_crc_errors);\r\n}\r\nvoid fcoe_get_lesb(struct fc_lport *lport,\r\nstruct fc_els_lesb *fc_lesb)\r\n{\r\nstruct net_device *netdev = fcoe_get_netdev(lport);\r\n__fcoe_get_lesb(lport, fc_lesb, netdev);\r\n}\r\nvoid fcoe_ctlr_get_lesb(struct fcoe_ctlr_device *ctlr_dev)\r\n{\r\nstruct fcoe_ctlr *fip = fcoe_ctlr_device_priv(ctlr_dev);\r\nstruct net_device *netdev = fcoe_get_netdev(fip->lp);\r\nstruct fc_els_lesb *fc_lesb;\r\nfc_lesb = (struct fc_els_lesb *)(&ctlr_dev->lesb);\r\n__fcoe_get_lesb(fip->lp, fc_lesb, netdev);\r\n}\r\nvoid fcoe_wwn_to_str(u64 wwn, char *buf, int len)\r\n{\r\nu8 wwpn[8];\r\nu64_to_wwn(wwn, wwpn);\r\nsnprintf(buf, len, "%02x%02x%02x%02x%02x%02x%02x%02x",\r\nwwpn[0], wwpn[1], wwpn[2], wwpn[3],\r\nwwpn[4], wwpn[5], wwpn[6], wwpn[7]);\r\n}\r\nint fcoe_validate_vport_create(struct fc_vport *vport)\r\n{\r\nstruct Scsi_Host *shost = vport_to_shost(vport);\r\nstruct fc_lport *n_port = shost_priv(shost);\r\nstruct fc_lport *vn_port;\r\nint rc = 0;\r\nchar buf[32];\r\nmutex_lock(&n_port->lp_mutex);\r\nfcoe_wwn_to_str(vport->port_name, buf, sizeof(buf));\r\nif (!memcmp(&n_port->wwpn, &vport->port_name, sizeof(u64))) {\r\nLIBFCOE_TRANSPORT_DBG("vport WWPN 0x%s is same as that of the "\r\n"base port WWPN\n", buf);\r\nrc = -EINVAL;\r\ngoto out;\r\n}\r\nlist_for_each_entry(vn_port, &n_port->vports, list) {\r\nif (!memcmp(&vn_port->wwpn, &vport->port_name, sizeof(u64))) {\r\nLIBFCOE_TRANSPORT_DBG("vport with given WWPN 0x%s "\r\n"already exists\n", buf);\r\nrc = -EINVAL;\r\nbreak;\r\n}\r\n}\r\nout:\r\nmutex_unlock(&n_port->lp_mutex);\r\nreturn rc;\r\n}\r\nint fcoe_get_wwn(struct net_device *netdev, u64 *wwn, int type)\r\n{\r\nconst struct net_device_ops *ops = netdev->netdev_ops;\r\nif (ops->ndo_fcoe_get_wwn)\r\nreturn ops->ndo_fcoe_get_wwn(netdev, wwn, type);\r\nreturn -EINVAL;\r\n}\r\nu32 fcoe_fc_crc(struct fc_frame *fp)\r\n{\r\nstruct sk_buff *skb = fp_skb(fp);\r\nstruct skb_frag_struct *frag;\r\nunsigned char *data;\r\nunsigned long off, len, clen;\r\nu32 crc;\r\nunsigned i;\r\ncrc = crc32(~0, skb->data, skb_headlen(skb));\r\nfor (i = 0; i < skb_shinfo(skb)->nr_frags; i++) {\r\nfrag = &skb_shinfo(skb)->frags[i];\r\noff = frag->page_offset;\r\nlen = skb_frag_size(frag);\r\nwhile (len > 0) {\r\nclen = min(len, PAGE_SIZE - (off & ~PAGE_MASK));\r\ndata = kmap_atomic(\r\nskb_frag_page(frag) + (off >> PAGE_SHIFT));\r\ncrc = crc32(crc, data + (off & ~PAGE_MASK), clen);\r\nkunmap_atomic(data);\r\noff += clen;\r\nlen -= clen;\r\n}\r\n}\r\nreturn crc;\r\n}\r\nint fcoe_start_io(struct sk_buff *skb)\r\n{\r\nstruct sk_buff *nskb;\r\nint rc;\r\nnskb = skb_clone(skb, GFP_ATOMIC);\r\nif (!nskb)\r\nreturn -ENOMEM;\r\nrc = dev_queue_xmit(nskb);\r\nif (rc != 0)\r\nreturn rc;\r\nkfree_skb(skb);\r\nreturn 0;\r\n}\r\nvoid fcoe_clean_pending_queue(struct fc_lport *lport)\r\n{\r\nstruct fcoe_port *port = lport_priv(lport);\r\nstruct sk_buff *skb;\r\nspin_lock_bh(&port->fcoe_pending_queue.lock);\r\nwhile ((skb = __skb_dequeue(&port->fcoe_pending_queue)) != NULL) {\r\nspin_unlock_bh(&port->fcoe_pending_queue.lock);\r\nkfree_skb(skb);\r\nspin_lock_bh(&port->fcoe_pending_queue.lock);\r\n}\r\nspin_unlock_bh(&port->fcoe_pending_queue.lock);\r\n}\r\nvoid fcoe_check_wait_queue(struct fc_lport *lport, struct sk_buff *skb)\r\n{\r\nstruct fcoe_port *port = lport_priv(lport);\r\nint rc;\r\nspin_lock_bh(&port->fcoe_pending_queue.lock);\r\nif (skb)\r\n__skb_queue_tail(&port->fcoe_pending_queue, skb);\r\nif (port->fcoe_pending_queue_active)\r\ngoto out;\r\nport->fcoe_pending_queue_active = 1;\r\nwhile (port->fcoe_pending_queue.qlen) {\r\nport->fcoe_pending_queue.qlen++;\r\nskb = __skb_dequeue(&port->fcoe_pending_queue);\r\nspin_unlock_bh(&port->fcoe_pending_queue.lock);\r\nrc = fcoe_start_io(skb);\r\nspin_lock_bh(&port->fcoe_pending_queue.lock);\r\nif (rc) {\r\n__skb_queue_head(&port->fcoe_pending_queue, skb);\r\nport->fcoe_pending_queue.qlen--;\r\nbreak;\r\n}\r\nport->fcoe_pending_queue.qlen--;\r\n}\r\nif (port->fcoe_pending_queue.qlen < port->min_queue_depth)\r\nlport->qfull = 0;\r\nif (port->fcoe_pending_queue.qlen && !timer_pending(&port->timer))\r\nmod_timer(&port->timer, jiffies + 2);\r\nport->fcoe_pending_queue_active = 0;\r\nout:\r\nif (port->fcoe_pending_queue.qlen > port->max_queue_depth)\r\nlport->qfull = 1;\r\nspin_unlock_bh(&port->fcoe_pending_queue.lock);\r\n}\r\nvoid fcoe_queue_timer(ulong lport)\r\n{\r\nfcoe_check_wait_queue((struct fc_lport *)lport, NULL);\r\n}\r\nint fcoe_get_paged_crc_eof(struct sk_buff *skb, int tlen,\r\nstruct fcoe_percpu_s *fps)\r\n{\r\nstruct page *page;\r\npage = fps->crc_eof_page;\r\nif (!page) {\r\npage = alloc_page(GFP_ATOMIC);\r\nif (!page)\r\nreturn -ENOMEM;\r\nfps->crc_eof_page = page;\r\nfps->crc_eof_offset = 0;\r\n}\r\nget_page(page);\r\nskb_fill_page_desc(skb, skb_shinfo(skb)->nr_frags, page,\r\nfps->crc_eof_offset, tlen);\r\nskb->len += tlen;\r\nskb->data_len += tlen;\r\nskb->truesize += tlen;\r\nfps->crc_eof_offset += sizeof(struct fcoe_crc_eof);\r\nif (fps->crc_eof_offset >= PAGE_SIZE) {\r\nfps->crc_eof_page = NULL;\r\nfps->crc_eof_offset = 0;\r\nput_page(page);\r\n}\r\nreturn 0;\r\n}\r\nstatic struct fcoe_transport *fcoe_transport_lookup(struct net_device *netdev)\r\n{\r\nstruct fcoe_transport *ft = NULL;\r\nlist_for_each_entry(ft, &fcoe_transports, list)\r\nif (ft->match && ft->match(netdev))\r\nreturn ft;\r\nreturn NULL;\r\n}\r\nint fcoe_transport_attach(struct fcoe_transport *ft)\r\n{\r\nint rc = 0;\r\nmutex_lock(&ft_mutex);\r\nif (ft->attached) {\r\nLIBFCOE_TRANSPORT_DBG("transport %s already attached\n",\r\nft->name);\r\nrc = -EEXIST;\r\ngoto out_attach;\r\n}\r\nif (strcmp(ft->name, FCOE_TRANSPORT_DEFAULT))\r\nlist_add(&ft->list, &fcoe_transports);\r\nelse\r\nlist_add_tail(&ft->list, &fcoe_transports);\r\nft->attached = true;\r\nLIBFCOE_TRANSPORT_DBG("attaching transport %s\n", ft->name);\r\nout_attach:\r\nmutex_unlock(&ft_mutex);\r\nreturn rc;\r\n}\r\nint fcoe_transport_detach(struct fcoe_transport *ft)\r\n{\r\nint rc = 0;\r\nstruct fcoe_netdev_mapping *nm = NULL, *tmp;\r\nmutex_lock(&ft_mutex);\r\nif (!ft->attached) {\r\nLIBFCOE_TRANSPORT_DBG("transport %s already detached\n",\r\nft->name);\r\nrc = -ENODEV;\r\ngoto out_attach;\r\n}\r\nmutex_lock(&fn_mutex);\r\nlist_for_each_entry_safe(nm, tmp, &fcoe_netdevs, list) {\r\nif (nm->ft == ft) {\r\nLIBFCOE_TRANSPORT_DBG("transport %s going away, "\r\n"remove its netdev mapping for %s\n",\r\nft->name, nm->netdev->name);\r\nlist_del(&nm->list);\r\nkfree(nm);\r\n}\r\n}\r\nmutex_unlock(&fn_mutex);\r\nlist_del(&ft->list);\r\nft->attached = false;\r\nLIBFCOE_TRANSPORT_DBG("detaching transport %s\n", ft->name);\r\nout_attach:\r\nmutex_unlock(&ft_mutex);\r\nreturn rc;\r\n}\r\nstatic int fcoe_transport_show(char *buffer, const struct kernel_param *kp)\r\n{\r\nint i, j;\r\nstruct fcoe_transport *ft = NULL;\r\ni = j = sprintf(buffer, "Attached FCoE transports:");\r\nmutex_lock(&ft_mutex);\r\nlist_for_each_entry(ft, &fcoe_transports, list) {\r\nif (i >= PAGE_SIZE - IFNAMSIZ)\r\nbreak;\r\ni += snprintf(&buffer[i], IFNAMSIZ, "%s ", ft->name);\r\n}\r\nmutex_unlock(&ft_mutex);\r\nif (i == j)\r\ni += snprintf(&buffer[i], IFNAMSIZ, "none");\r\nreturn i;\r\n}\r\nstatic int __init fcoe_transport_init(void)\r\n{\r\nregister_netdevice_notifier(&libfcoe_notifier);\r\nreturn 0;\r\n}\r\nstatic int fcoe_transport_exit(void)\r\n{\r\nstruct fcoe_transport *ft;\r\nunregister_netdevice_notifier(&libfcoe_notifier);\r\nmutex_lock(&ft_mutex);\r\nlist_for_each_entry(ft, &fcoe_transports, list)\r\nprintk(KERN_ERR "FCoE transport %s is still attached!\n",\r\nft->name);\r\nmutex_unlock(&ft_mutex);\r\nreturn 0;\r\n}\r\nstatic int fcoe_add_netdev_mapping(struct net_device *netdev,\r\nstruct fcoe_transport *ft)\r\n{\r\nstruct fcoe_netdev_mapping *nm;\r\nnm = kmalloc(sizeof(*nm), GFP_KERNEL);\r\nif (!nm) {\r\nprintk(KERN_ERR "Unable to allocate netdev_mapping");\r\nreturn -ENOMEM;\r\n}\r\nnm->netdev = netdev;\r\nnm->ft = ft;\r\nmutex_lock(&fn_mutex);\r\nlist_add(&nm->list, &fcoe_netdevs);\r\nmutex_unlock(&fn_mutex);\r\nreturn 0;\r\n}\r\nstatic void fcoe_del_netdev_mapping(struct net_device *netdev)\r\n{\r\nstruct fcoe_netdev_mapping *nm = NULL, *tmp;\r\nmutex_lock(&fn_mutex);\r\nlist_for_each_entry_safe(nm, tmp, &fcoe_netdevs, list) {\r\nif (nm->netdev == netdev) {\r\nlist_del(&nm->list);\r\nkfree(nm);\r\nmutex_unlock(&fn_mutex);\r\nreturn;\r\n}\r\n}\r\nmutex_unlock(&fn_mutex);\r\n}\r\nstatic struct fcoe_transport *fcoe_netdev_map_lookup(struct net_device *netdev)\r\n{\r\nstruct fcoe_transport *ft = NULL;\r\nstruct fcoe_netdev_mapping *nm;\r\nmutex_lock(&fn_mutex);\r\nlist_for_each_entry(nm, &fcoe_netdevs, list) {\r\nif (netdev == nm->netdev) {\r\nft = nm->ft;\r\nmutex_unlock(&fn_mutex);\r\nreturn ft;\r\n}\r\n}\r\nmutex_unlock(&fn_mutex);\r\nreturn NULL;\r\n}\r\nstatic struct net_device *fcoe_if_to_netdev(const char *buffer)\r\n{\r\nchar *cp;\r\nchar ifname[IFNAMSIZ + 2];\r\nif (buffer) {\r\nstrlcpy(ifname, buffer, IFNAMSIZ);\r\ncp = ifname + strlen(ifname);\r\nwhile (--cp >= ifname && *cp == '\n')\r\n*cp = '\0';\r\nreturn dev_get_by_name(&init_net, ifname);\r\n}\r\nreturn NULL;\r\n}\r\nstatic int libfcoe_device_notification(struct notifier_block *notifier,\r\nulong event, void *ptr)\r\n{\r\nstruct net_device *netdev = netdev_notifier_info_to_dev(ptr);\r\nswitch (event) {\r\ncase NETDEV_UNREGISTER:\r\nLIBFCOE_TRANSPORT_DBG("NETDEV_UNREGISTER %s\n",\r\nnetdev->name);\r\nfcoe_del_netdev_mapping(netdev);\r\nbreak;\r\n}\r\nreturn NOTIFY_OK;\r\n}\r\nssize_t fcoe_ctlr_create_store(struct bus_type *bus,\r\nconst char *buf, size_t count)\r\n{\r\nstruct net_device *netdev = NULL;\r\nstruct fcoe_transport *ft = NULL;\r\nint rc = 0;\r\nint err;\r\nmutex_lock(&ft_mutex);\r\nnetdev = fcoe_if_to_netdev(buf);\r\nif (!netdev) {\r\nLIBFCOE_TRANSPORT_DBG("Invalid device %s.\n", buf);\r\nrc = -ENODEV;\r\ngoto out_nodev;\r\n}\r\nft = fcoe_netdev_map_lookup(netdev);\r\nif (ft) {\r\nLIBFCOE_TRANSPORT_DBG("transport %s already has existing "\r\n"FCoE instance on %s.\n",\r\nft->name, netdev->name);\r\nrc = -EEXIST;\r\ngoto out_putdev;\r\n}\r\nft = fcoe_transport_lookup(netdev);\r\nif (!ft) {\r\nLIBFCOE_TRANSPORT_DBG("no FCoE transport found for %s.\n",\r\nnetdev->name);\r\nrc = -ENODEV;\r\ngoto out_putdev;\r\n}\r\nerr = ft->alloc ? ft->alloc(netdev) : -ENODEV;\r\nif (err) {\r\nfcoe_del_netdev_mapping(netdev);\r\nrc = -ENOMEM;\r\ngoto out_putdev;\r\n}\r\nerr = fcoe_add_netdev_mapping(netdev, ft);\r\nif (err) {\r\nLIBFCOE_TRANSPORT_DBG("failed to add new netdev mapping "\r\n"for FCoE transport %s for %s.\n",\r\nft->name, netdev->name);\r\nrc = -ENODEV;\r\ngoto out_putdev;\r\n}\r\nLIBFCOE_TRANSPORT_DBG("transport %s succeeded to create fcoe on %s.\n",\r\nft->name, netdev->name);\r\nout_putdev:\r\ndev_put(netdev);\r\nout_nodev:\r\nmutex_unlock(&ft_mutex);\r\nif (rc)\r\nreturn rc;\r\nreturn count;\r\n}\r\nssize_t fcoe_ctlr_destroy_store(struct bus_type *bus,\r\nconst char *buf, size_t count)\r\n{\r\nint rc = -ENODEV;\r\nstruct net_device *netdev = NULL;\r\nstruct fcoe_transport *ft = NULL;\r\nmutex_lock(&ft_mutex);\r\nnetdev = fcoe_if_to_netdev(buf);\r\nif (!netdev) {\r\nLIBFCOE_TRANSPORT_DBG("invalid device %s.\n", buf);\r\ngoto out_nodev;\r\n}\r\nft = fcoe_netdev_map_lookup(netdev);\r\nif (!ft) {\r\nLIBFCOE_TRANSPORT_DBG("no FCoE transport found for %s.\n",\r\nnetdev->name);\r\ngoto out_putdev;\r\n}\r\nrc = ft->destroy(netdev);\r\nif (rc)\r\ngoto out_putdev;\r\nfcoe_del_netdev_mapping(netdev);\r\nLIBFCOE_TRANSPORT_DBG("transport %s %s to destroy fcoe on %s.\n",\r\nft->name, (rc) ? "failed" : "succeeded",\r\nnetdev->name);\r\nrc = count;\r\nout_putdev:\r\ndev_put(netdev);\r\nout_nodev:\r\nmutex_unlock(&ft_mutex);\r\nreturn rc;\r\n}\r\nstatic int fcoe_transport_create(const char *buffer, struct kernel_param *kp)\r\n{\r\nint rc = -ENODEV;\r\nstruct net_device *netdev = NULL;\r\nstruct fcoe_transport *ft = NULL;\r\nenum fip_state fip_mode = (enum fip_state)(long)kp->arg;\r\nmutex_lock(&ft_mutex);\r\nnetdev = fcoe_if_to_netdev(buffer);\r\nif (!netdev) {\r\nLIBFCOE_TRANSPORT_DBG("Invalid device %s.\n", buffer);\r\ngoto out_nodev;\r\n}\r\nft = fcoe_netdev_map_lookup(netdev);\r\nif (ft) {\r\nLIBFCOE_TRANSPORT_DBG("transport %s already has existing "\r\n"FCoE instance on %s.\n",\r\nft->name, netdev->name);\r\nrc = -EEXIST;\r\ngoto out_putdev;\r\n}\r\nft = fcoe_transport_lookup(netdev);\r\nif (!ft) {\r\nLIBFCOE_TRANSPORT_DBG("no FCoE transport found for %s.\n",\r\nnetdev->name);\r\ngoto out_putdev;\r\n}\r\nrc = fcoe_add_netdev_mapping(netdev, ft);\r\nif (rc) {\r\nLIBFCOE_TRANSPORT_DBG("failed to add new netdev mapping "\r\n"for FCoE transport %s for %s.\n",\r\nft->name, netdev->name);\r\ngoto out_putdev;\r\n}\r\nrc = ft->create ? ft->create(netdev, fip_mode) : -ENODEV;\r\nif (rc)\r\nfcoe_del_netdev_mapping(netdev);\r\nLIBFCOE_TRANSPORT_DBG("transport %s %s to create fcoe on %s.\n",\r\nft->name, (rc) ? "failed" : "succeeded",\r\nnetdev->name);\r\nout_putdev:\r\ndev_put(netdev);\r\nout_nodev:\r\nmutex_unlock(&ft_mutex);\r\nreturn rc;\r\n}\r\nstatic int fcoe_transport_destroy(const char *buffer, struct kernel_param *kp)\r\n{\r\nint rc = -ENODEV;\r\nstruct net_device *netdev = NULL;\r\nstruct fcoe_transport *ft = NULL;\r\nmutex_lock(&ft_mutex);\r\nnetdev = fcoe_if_to_netdev(buffer);\r\nif (!netdev) {\r\nLIBFCOE_TRANSPORT_DBG("invalid device %s.\n", buffer);\r\ngoto out_nodev;\r\n}\r\nft = fcoe_netdev_map_lookup(netdev);\r\nif (!ft) {\r\nLIBFCOE_TRANSPORT_DBG("no FCoE transport found for %s.\n",\r\nnetdev->name);\r\ngoto out_putdev;\r\n}\r\nrc = ft->destroy ? ft->destroy(netdev) : -ENODEV;\r\nfcoe_del_netdev_mapping(netdev);\r\nLIBFCOE_TRANSPORT_DBG("transport %s %s to destroy fcoe on %s.\n",\r\nft->name, (rc) ? "failed" : "succeeded",\r\nnetdev->name);\r\nout_putdev:\r\ndev_put(netdev);\r\nout_nodev:\r\nmutex_unlock(&ft_mutex);\r\nreturn rc;\r\n}\r\nstatic int fcoe_transport_disable(const char *buffer, struct kernel_param *kp)\r\n{\r\nint rc = -ENODEV;\r\nstruct net_device *netdev = NULL;\r\nstruct fcoe_transport *ft = NULL;\r\nmutex_lock(&ft_mutex);\r\nnetdev = fcoe_if_to_netdev(buffer);\r\nif (!netdev)\r\ngoto out_nodev;\r\nft = fcoe_netdev_map_lookup(netdev);\r\nif (!ft)\r\ngoto out_putdev;\r\nrc = ft->disable ? ft->disable(netdev) : -ENODEV;\r\nout_putdev:\r\ndev_put(netdev);\r\nout_nodev:\r\nmutex_unlock(&ft_mutex);\r\nreturn rc;\r\n}\r\nstatic int fcoe_transport_enable(const char *buffer, struct kernel_param *kp)\r\n{\r\nint rc = -ENODEV;\r\nstruct net_device *netdev = NULL;\r\nstruct fcoe_transport *ft = NULL;\r\nmutex_lock(&ft_mutex);\r\nnetdev = fcoe_if_to_netdev(buffer);\r\nif (!netdev)\r\ngoto out_nodev;\r\nft = fcoe_netdev_map_lookup(netdev);\r\nif (!ft)\r\ngoto out_putdev;\r\nrc = ft->enable ? ft->enable(netdev) : -ENODEV;\r\nout_putdev:\r\ndev_put(netdev);\r\nout_nodev:\r\nmutex_unlock(&ft_mutex);\r\nreturn rc;\r\n}\r\nstatic int __init libfcoe_init(void)\r\n{\r\nint rc = 0;\r\nrc = fcoe_transport_init();\r\nif (rc)\r\nreturn rc;\r\nrc = fcoe_sysfs_setup();\r\nif (rc)\r\nfcoe_transport_exit();\r\nreturn rc;\r\n}\r\nstatic void __exit libfcoe_exit(void)\r\n{\r\nfcoe_sysfs_teardown();\r\nfcoe_transport_exit();\r\n}
