unsigned long read_timer(void)\r\n{\r\nunsigned long t, flags;\r\nint i;\r\nraw_spin_lock_irqsave(&i8253_lock, flags);\r\nt = jiffies * 11932;\r\noutb_p(0, 0x43);\r\ni = inb_p(0x40);\r\ni |= inb(0x40) << 8;\r\nraw_spin_unlock_irqrestore(&i8253_lock, flags);\r\nreturn(t - i);\r\n}\r\nstatic void __init hd_setup(char *str, int *ints)\r\n{\r\nint hdind = 0;\r\nif (ints[0] != 3)\r\nreturn;\r\nif (hd_info[0].head != 0)\r\nhdind = 1;\r\nhd_info[hdind].head = ints[2];\r\nhd_info[hdind].sect = ints[3];\r\nhd_info[hdind].cyl = ints[1];\r\nhd_info[hdind].wpcom = 0;\r\nhd_info[hdind].lzone = ints[1];\r\nhd_info[hdind].ctl = (ints[2] > 8 ? 8 : 0);\r\nNR_HD = hdind+1;\r\n}\r\nstatic bool hd_end_request(int err, unsigned int bytes)\r\n{\r\nif (__blk_end_request(hd_req, err, bytes))\r\nreturn true;\r\nhd_req = NULL;\r\nreturn false;\r\n}\r\nstatic bool hd_end_request_cur(int err)\r\n{\r\nreturn hd_end_request(err, blk_rq_cur_bytes(hd_req));\r\n}\r\nstatic void dump_status(const char *msg, unsigned int stat)\r\n{\r\nchar *name = "hd?";\r\nif (hd_req)\r\nname = hd_req->rq_disk->disk_name;\r\n#ifdef VERBOSE_ERRORS\r\nprintk("%s: %s: status=0x%02x { ", name, msg, stat & 0xff);\r\nif (stat & BUSY_STAT) printk("Busy ");\r\nif (stat & READY_STAT) printk("DriveReady ");\r\nif (stat & WRERR_STAT) printk("WriteFault ");\r\nif (stat & SEEK_STAT) printk("SeekComplete ");\r\nif (stat & DRQ_STAT) printk("DataRequest ");\r\nif (stat & ECC_STAT) printk("CorrectedError ");\r\nif (stat & INDEX_STAT) printk("Index ");\r\nif (stat & ERR_STAT) printk("Error ");\r\nprintk("}\n");\r\nif ((stat & ERR_STAT) == 0) {\r\nhd_error = 0;\r\n} else {\r\nhd_error = inb(HD_ERROR);\r\nprintk("%s: %s: error=0x%02x { ", name, msg, hd_error & 0xff);\r\nif (hd_error & BBD_ERR) printk("BadSector ");\r\nif (hd_error & ECC_ERR) printk("UncorrectableError ");\r\nif (hd_error & ID_ERR) printk("SectorIdNotFound ");\r\nif (hd_error & ABRT_ERR) printk("DriveStatusError ");\r\nif (hd_error & TRK0_ERR) printk("TrackZeroNotFound ");\r\nif (hd_error & MARK_ERR) printk("AddrMarkNotFound ");\r\nprintk("}");\r\nif (hd_error & (BBD_ERR|ECC_ERR|ID_ERR|MARK_ERR)) {\r\nprintk(", CHS=%d/%d/%d", (inb(HD_HCYL)<<8) + inb(HD_LCYL),\r\ninb(HD_CURRENT) & 0xf, inb(HD_SECTOR));\r\nif (hd_req)\r\nprintk(", sector=%ld", blk_rq_pos(hd_req));\r\n}\r\nprintk("\n");\r\n}\r\n#else\r\nprintk("%s: %s: status=0x%02x.\n", name, msg, stat & 0xff);\r\nif ((stat & ERR_STAT) == 0) {\r\nhd_error = 0;\r\n} else {\r\nhd_error = inb(HD_ERROR);\r\nprintk("%s: %s: error=0x%02x.\n", name, msg, hd_error & 0xff);\r\n}\r\n#endif\r\n}\r\nstatic void check_status(void)\r\n{\r\nint i = inb_p(HD_STATUS);\r\nif (!OK_STATUS(i)) {\r\ndump_status("check_status", i);\r\nbad_rw_intr();\r\n}\r\n}\r\nstatic int controller_busy(void)\r\n{\r\nint retries = 100000;\r\nunsigned char status;\r\ndo {\r\nstatus = inb_p(HD_STATUS);\r\n} while ((status & BUSY_STAT) && --retries);\r\nreturn status;\r\n}\r\nstatic int status_ok(void)\r\n{\r\nunsigned char status = inb_p(HD_STATUS);\r\nif (status & BUSY_STAT)\r\nreturn 1;\r\nif (status & WRERR_STAT)\r\nreturn 0;\r\nif (!(status & READY_STAT))\r\nreturn 0;\r\nif (!(status & SEEK_STAT))\r\nreturn 0;\r\nreturn 1;\r\n}\r\nstatic int controller_ready(unsigned int drive, unsigned int head)\r\n{\r\nint retry = 100;\r\ndo {\r\nif (controller_busy() & BUSY_STAT)\r\nreturn 0;\r\noutb_p(0xA0 | (drive<<4) | head, HD_CURRENT);\r\nif (status_ok())\r\nreturn 1;\r\n} while (--retry);\r\nreturn 0;\r\n}\r\nstatic void hd_out(struct hd_i_struct *disk,\r\nunsigned int nsect,\r\nunsigned int sect,\r\nunsigned int head,\r\nunsigned int cyl,\r\nunsigned int cmd,\r\nvoid (*intr_addr)(void))\r\n{\r\nunsigned short port;\r\n#if (HD_DELAY > 0)\r\nwhile (read_timer() - last_req < HD_DELAY)\r\n;\r\n#endif\r\nif (reset)\r\nreturn;\r\nif (!controller_ready(disk->unit, head)) {\r\nreset = 1;\r\nreturn;\r\n}\r\nSET_HANDLER(intr_addr);\r\noutb_p(disk->ctl, HD_CMD);\r\nport = HD_DATA;\r\noutb_p(disk->wpcom >> 2, ++port);\r\noutb_p(nsect, ++port);\r\noutb_p(sect, ++port);\r\noutb_p(cyl, ++port);\r\noutb_p(cyl >> 8, ++port);\r\noutb_p(0xA0 | (disk->unit << 4) | head, ++port);\r\noutb_p(cmd, ++port);\r\n}\r\nstatic int drive_busy(void)\r\n{\r\nunsigned int i;\r\nunsigned char c;\r\nfor (i = 0; i < 500000 ; i++) {\r\nc = inb_p(HD_STATUS);\r\nif ((c & (BUSY_STAT | READY_STAT | SEEK_STAT)) == STAT_OK)\r\nreturn 0;\r\n}\r\ndump_status("reset timed out", c);\r\nreturn 1;\r\n}\r\nstatic void reset_controller(void)\r\n{\r\nint i;\r\noutb_p(4, HD_CMD);\r\nfor (i = 0; i < 1000; i++) barrier();\r\noutb_p(hd_info[0].ctl & 0x0f, HD_CMD);\r\nfor (i = 0; i < 1000; i++) barrier();\r\nif (drive_busy())\r\nprintk("hd: controller still busy\n");\r\nelse if ((hd_error = inb(HD_ERROR)) != 1)\r\nprintk("hd: controller reset failed: %02x\n", hd_error);\r\n}\r\nstatic void reset_hd(void)\r\n{\r\nstatic int i;\r\nrepeat:\r\nif (reset) {\r\nreset = 0;\r\ni = -1;\r\nreset_controller();\r\n} else {\r\ncheck_status();\r\nif (reset)\r\ngoto repeat;\r\n}\r\nif (++i < NR_HD) {\r\nstruct hd_i_struct *disk = &hd_info[i];\r\ndisk->special_op = disk->recalibrate = 1;\r\nhd_out(disk, disk->sect, disk->sect, disk->head-1,\r\ndisk->cyl, ATA_CMD_INIT_DEV_PARAMS, &reset_hd);\r\nif (reset)\r\ngoto repeat;\r\n} else\r\nhd_request();\r\n}\r\nstatic void unexpected_hd_interrupt(void)\r\n{\r\nunsigned int stat = inb_p(HD_STATUS);\r\nif (stat & (BUSY_STAT|DRQ_STAT|ECC_STAT|ERR_STAT)) {\r\ndump_status("unexpected interrupt", stat);\r\nSET_TIMER;\r\n}\r\n}\r\nstatic void bad_rw_intr(void)\r\n{\r\nstruct request *req = hd_req;\r\nif (req != NULL) {\r\nstruct hd_i_struct *disk = req->rq_disk->private_data;\r\nif (++req->errors >= MAX_ERRORS || (hd_error & BBD_ERR)) {\r\nhd_end_request_cur(-EIO);\r\ndisk->special_op = disk->recalibrate = 1;\r\n} else if (req->errors % RESET_FREQ == 0)\r\nreset = 1;\r\nelse if ((hd_error & TRK0_ERR) || req->errors % RECAL_FREQ == 0)\r\ndisk->special_op = disk->recalibrate = 1;\r\n}\r\n}\r\nstatic inline int wait_DRQ(void)\r\n{\r\nint retries;\r\nint stat;\r\nfor (retries = 0; retries < 100000; retries++) {\r\nstat = inb_p(HD_STATUS);\r\nif (stat & DRQ_STAT)\r\nreturn 0;\r\n}\r\ndump_status("wait_DRQ", stat);\r\nreturn -1;\r\n}\r\nstatic void read_intr(void)\r\n{\r\nstruct request *req;\r\nint i, retries = 100000;\r\ndo {\r\ni = (unsigned) inb_p(HD_STATUS);\r\nif (i & BUSY_STAT)\r\ncontinue;\r\nif (!OK_STATUS(i))\r\nbreak;\r\nif (i & DRQ_STAT)\r\ngoto ok_to_read;\r\n} while (--retries > 0);\r\ndump_status("read_intr", i);\r\nbad_rw_intr();\r\nhd_request();\r\nreturn;\r\nok_to_read:\r\nreq = hd_req;\r\ninsw(HD_DATA, bio_data(req->bio), 256);\r\n#ifdef DEBUG\r\nprintk("%s: read: sector %ld, remaining = %u, buffer=%p\n",\r\nreq->rq_disk->disk_name, blk_rq_pos(req) + 1,\r\nblk_rq_sectors(req) - 1, bio_data(req->bio)+512);\r\n#endif\r\nif (hd_end_request(0, 512)) {\r\nSET_HANDLER(&read_intr);\r\nreturn;\r\n}\r\n(void) inb_p(HD_STATUS);\r\n#if (HD_DELAY > 0)\r\nlast_req = read_timer();\r\n#endif\r\nhd_request();\r\n}\r\nstatic void write_intr(void)\r\n{\r\nstruct request *req = hd_req;\r\nint i;\r\nint retries = 100000;\r\ndo {\r\ni = (unsigned) inb_p(HD_STATUS);\r\nif (i & BUSY_STAT)\r\ncontinue;\r\nif (!OK_STATUS(i))\r\nbreak;\r\nif ((blk_rq_sectors(req) <= 1) || (i & DRQ_STAT))\r\ngoto ok_to_write;\r\n} while (--retries > 0);\r\ndump_status("write_intr", i);\r\nbad_rw_intr();\r\nhd_request();\r\nreturn;\r\nok_to_write:\r\nif (hd_end_request(0, 512)) {\r\nSET_HANDLER(&write_intr);\r\noutsw(HD_DATA, bio_data(req->bio), 256);\r\nreturn;\r\n}\r\n#if (HD_DELAY > 0)\r\nlast_req = read_timer();\r\n#endif\r\nhd_request();\r\n}\r\nstatic void recal_intr(void)\r\n{\r\ncheck_status();\r\n#if (HD_DELAY > 0)\r\nlast_req = read_timer();\r\n#endif\r\nhd_request();\r\n}\r\nstatic void hd_times_out(unsigned long dummy)\r\n{\r\nchar *name;\r\ndo_hd = NULL;\r\nif (!hd_req)\r\nreturn;\r\nspin_lock_irq(hd_queue->queue_lock);\r\nreset = 1;\r\nname = hd_req->rq_disk->disk_name;\r\nprintk("%s: timeout\n", name);\r\nif (++hd_req->errors >= MAX_ERRORS) {\r\n#ifdef DEBUG\r\nprintk("%s: too many errors\n", name);\r\n#endif\r\nhd_end_request_cur(-EIO);\r\n}\r\nhd_request();\r\nspin_unlock_irq(hd_queue->queue_lock);\r\n}\r\nstatic int do_special_op(struct hd_i_struct *disk, struct request *req)\r\n{\r\nif (disk->recalibrate) {\r\ndisk->recalibrate = 0;\r\nhd_out(disk, disk->sect, 0, 0, 0, ATA_CMD_RESTORE, &recal_intr);\r\nreturn reset;\r\n}\r\nif (disk->head > 16) {\r\nprintk("%s: cannot handle device with more than 16 heads - giving up\n", req->rq_disk->disk_name);\r\nhd_end_request_cur(-EIO);\r\n}\r\ndisk->special_op = 0;\r\nreturn 1;\r\n}\r\nstatic void hd_request(void)\r\n{\r\nunsigned int block, nsect, sec, track, head, cyl;\r\nstruct hd_i_struct *disk;\r\nstruct request *req;\r\nif (do_hd)\r\nreturn;\r\nrepeat:\r\ndel_timer(&device_timer);\r\nif (!hd_req) {\r\nhd_req = blk_fetch_request(hd_queue);\r\nif (!hd_req) {\r\ndo_hd = NULL;\r\nreturn;\r\n}\r\n}\r\nreq = hd_req;\r\nif (reset) {\r\nreset_hd();\r\nreturn;\r\n}\r\ndisk = req->rq_disk->private_data;\r\nblock = blk_rq_pos(req);\r\nnsect = blk_rq_sectors(req);\r\nif (block >= get_capacity(req->rq_disk) ||\r\n((block+nsect) > get_capacity(req->rq_disk))) {\r\nprintk("%s: bad access: block=%d, count=%d\n",\r\nreq->rq_disk->disk_name, block, nsect);\r\nhd_end_request_cur(-EIO);\r\ngoto repeat;\r\n}\r\nif (disk->special_op) {\r\nif (do_special_op(disk, req))\r\ngoto repeat;\r\nreturn;\r\n}\r\nsec = block % disk->sect + 1;\r\ntrack = block / disk->sect;\r\nhead = track % disk->head;\r\ncyl = track / disk->head;\r\n#ifdef DEBUG\r\nprintk("%s: %sing: CHS=%d/%d/%d, sectors=%d, buffer=%p\n",\r\nreq->rq_disk->disk_name,\r\nreq_data_dir(req) == READ ? "read" : "writ",\r\ncyl, head, sec, nsect, bio_data(req->bio));\r\n#endif\r\nif (req->cmd_type == REQ_TYPE_FS) {\r\nswitch (rq_data_dir(req)) {\r\ncase READ:\r\nhd_out(disk, nsect, sec, head, cyl, ATA_CMD_PIO_READ,\r\n&read_intr);\r\nif (reset)\r\ngoto repeat;\r\nbreak;\r\ncase WRITE:\r\nhd_out(disk, nsect, sec, head, cyl, ATA_CMD_PIO_WRITE,\r\n&write_intr);\r\nif (reset)\r\ngoto repeat;\r\nif (wait_DRQ()) {\r\nbad_rw_intr();\r\ngoto repeat;\r\n}\r\noutsw(HD_DATA, bio_data(req->bio), 256);\r\nbreak;\r\ndefault:\r\nprintk("unknown hd-command\n");\r\nhd_end_request_cur(-EIO);\r\nbreak;\r\n}\r\n}\r\n}\r\nstatic void do_hd_request(struct request_queue *q)\r\n{\r\nhd_request();\r\n}\r\nstatic int hd_getgeo(struct block_device *bdev, struct hd_geometry *geo)\r\n{\r\nstruct hd_i_struct *disk = bdev->bd_disk->private_data;\r\ngeo->heads = disk->head;\r\ngeo->sectors = disk->sect;\r\ngeo->cylinders = disk->cyl;\r\nreturn 0;\r\n}\r\nstatic irqreturn_t hd_interrupt(int irq, void *dev_id)\r\n{\r\nvoid (*handler)(void) = do_hd;\r\nspin_lock(hd_queue->queue_lock);\r\ndo_hd = NULL;\r\ndel_timer(&device_timer);\r\nif (!handler)\r\nhandler = unexpected_hd_interrupt;\r\nhandler();\r\nspin_unlock(hd_queue->queue_lock);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int __init hd_init(void)\r\n{\r\nint drive;\r\nif (register_blkdev(HD_MAJOR, "hd"))\r\nreturn -1;\r\nhd_queue = blk_init_queue(do_hd_request, &hd_lock);\r\nif (!hd_queue) {\r\nunregister_blkdev(HD_MAJOR, "hd");\r\nreturn -ENOMEM;\r\n}\r\nblk_queue_max_hw_sectors(hd_queue, 255);\r\ninit_timer(&device_timer);\r\ndevice_timer.function = hd_times_out;\r\nblk_queue_logical_block_size(hd_queue, 512);\r\nif (!NR_HD) {\r\nprintk("hd: no drives specified - use hd=cyl,head,sectors"\r\n" on kernel command line\n");\r\ngoto out;\r\n}\r\nfor (drive = 0 ; drive < NR_HD ; drive++) {\r\nstruct gendisk *disk = alloc_disk(64);\r\nstruct hd_i_struct *p = &hd_info[drive];\r\nif (!disk)\r\ngoto Enomem;\r\ndisk->major = HD_MAJOR;\r\ndisk->first_minor = drive << 6;\r\ndisk->fops = &hd_fops;\r\nsprintf(disk->disk_name, "hd%c", 'a'+drive);\r\ndisk->private_data = p;\r\nset_capacity(disk, p->head * p->sect * p->cyl);\r\ndisk->queue = hd_queue;\r\np->unit = drive;\r\nhd_gendisk[drive] = disk;\r\nprintk("%s: %luMB, CHS=%d/%d/%d\n",\r\ndisk->disk_name, (unsigned long)get_capacity(disk)/2048,\r\np->cyl, p->head, p->sect);\r\n}\r\nif (request_irq(HD_IRQ, hd_interrupt, 0, "hd", NULL)) {\r\nprintk("hd: unable to get IRQ%d for the hard disk driver\n",\r\nHD_IRQ);\r\ngoto out1;\r\n}\r\nif (!request_region(HD_DATA, 8, "hd")) {\r\nprintk(KERN_WARNING "hd: port 0x%x busy\n", HD_DATA);\r\ngoto out2;\r\n}\r\nif (!request_region(HD_CMD, 1, "hd(cmd)")) {\r\nprintk(KERN_WARNING "hd: port 0x%x busy\n", HD_CMD);\r\ngoto out3;\r\n}\r\nfor (drive = 0; drive < NR_HD; drive++)\r\nadd_disk(hd_gendisk[drive]);\r\nreturn 0;\r\nout3:\r\nrelease_region(HD_DATA, 8);\r\nout2:\r\nfree_irq(HD_IRQ, NULL);\r\nout1:\r\nfor (drive = 0; drive < NR_HD; drive++)\r\nput_disk(hd_gendisk[drive]);\r\nNR_HD = 0;\r\nout:\r\ndel_timer(&device_timer);\r\nunregister_blkdev(HD_MAJOR, "hd");\r\nblk_cleanup_queue(hd_queue);\r\nreturn -1;\r\nEnomem:\r\nwhile (drive--)\r\nput_disk(hd_gendisk[drive]);\r\ngoto out;\r\n}\r\nstatic int __init parse_hd_setup(char *line)\r\n{\r\nint ints[6];\r\n(void) get_options(line, ARRAY_SIZE(ints), ints);\r\nhd_setup(NULL, ints);\r\nreturn 1;\r\n}
