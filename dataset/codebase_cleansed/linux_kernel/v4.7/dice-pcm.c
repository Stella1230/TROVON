static int limit_channels_and_rates(struct snd_dice *dice,\r\nstruct snd_pcm_runtime *runtime,\r\nenum amdtp_stream_direction dir,\r\nunsigned int index, unsigned int size)\r\n{\r\nstruct snd_pcm_hardware *hw = &runtime->hw;\r\nstruct amdtp_stream *stream;\r\nunsigned int rate;\r\n__be32 reg;\r\nint err;\r\nif (dir == AMDTP_IN_STREAM) {\r\nstream = &dice->tx_stream[index];\r\nerr = snd_dice_transaction_read_tx(dice,\r\nsize * index + TX_NUMBER_AUDIO,\r\n&reg, sizeof(reg));\r\n} else {\r\nstream = &dice->rx_stream[index];\r\nerr = snd_dice_transaction_read_rx(dice,\r\nsize * index + RX_NUMBER_AUDIO,\r\n&reg, sizeof(reg));\r\n}\r\nif (err < 0)\r\nreturn err;\r\nhw->channels_min = hw->channels_max = be32_to_cpu(reg);\r\nerr = snd_dice_transaction_get_rate(dice, &rate);\r\nif (err < 0)\r\nreturn err;\r\nhw->rates = snd_pcm_rate_to_rate_bit(rate);\r\nsnd_pcm_limit_hw_rates(runtime);\r\nreturn 0;\r\n}\r\nstatic void limit_period_and_buffer(struct snd_pcm_hardware *hw)\r\n{\r\nhw->periods_min = 2;\r\nhw->periods_max = UINT_MAX;\r\nhw->period_bytes_min = 4 * hw->channels_max;\r\nhw->period_bytes_max = hw->period_bytes_min * 2048;\r\nhw->buffer_bytes_max = hw->period_bytes_max * hw->periods_min;\r\n}\r\nstatic int init_hw_info(struct snd_dice *dice,\r\nstruct snd_pcm_substream *substream)\r\n{\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nstruct snd_pcm_hardware *hw = &runtime->hw;\r\nenum amdtp_stream_direction dir;\r\nstruct amdtp_stream *stream;\r\n__be32 reg[2];\r\nunsigned int count, size;\r\nint err;\r\nhw->info = SNDRV_PCM_INFO_MMAP |\r\nSNDRV_PCM_INFO_MMAP_VALID |\r\nSNDRV_PCM_INFO_BATCH |\r\nSNDRV_PCM_INFO_INTERLEAVED |\r\nSNDRV_PCM_INFO_JOINT_DUPLEX |\r\nSNDRV_PCM_INFO_BLOCK_TRANSFER;\r\nif (substream->stream == SNDRV_PCM_STREAM_CAPTURE) {\r\nhw->formats = AM824_IN_PCM_FORMAT_BITS;\r\ndir = AMDTP_IN_STREAM;\r\nstream = &dice->tx_stream[substream->pcm->device];\r\nerr = snd_dice_transaction_read_tx(dice, TX_NUMBER, reg,\r\nsizeof(reg));\r\n} else {\r\nhw->formats = AM824_OUT_PCM_FORMAT_BITS;\r\ndir = AMDTP_OUT_STREAM;\r\nstream = &dice->rx_stream[substream->pcm->device];\r\nerr = snd_dice_transaction_read_rx(dice, RX_NUMBER, reg,\r\nsizeof(reg));\r\n}\r\nif (err < 0)\r\nreturn err;\r\ncount = min_t(unsigned int, be32_to_cpu(reg[0]), MAX_STREAMS);\r\nif (substream->pcm->device >= count)\r\nreturn -ENXIO;\r\nsize = be32_to_cpu(reg[1]) * 4;\r\nerr = limit_channels_and_rates(dice, substream->runtime, dir,\r\nsubstream->pcm->device, size);\r\nif (err < 0)\r\nreturn err;\r\nlimit_period_and_buffer(hw);\r\nreturn amdtp_am824_add_pcm_hw_constraints(stream, runtime);\r\n}\r\nstatic int pcm_open(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_dice *dice = substream->private_data;\r\nint err;\r\nerr = snd_dice_stream_lock_try(dice);\r\nif (err < 0)\r\ngoto end;\r\nerr = init_hw_info(dice, substream);\r\nif (err < 0)\r\ngoto err_locked;\r\nsnd_pcm_set_sync(substream);\r\nend:\r\nreturn err;\r\nerr_locked:\r\nsnd_dice_stream_lock_release(dice);\r\nreturn err;\r\n}\r\nstatic int pcm_close(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_dice *dice = substream->private_data;\r\nsnd_dice_stream_lock_release(dice);\r\nreturn 0;\r\n}\r\nstatic int capture_hw_params(struct snd_pcm_substream *substream,\r\nstruct snd_pcm_hw_params *hw_params)\r\n{\r\nstruct snd_dice *dice = substream->private_data;\r\nstruct amdtp_stream *stream = &dice->tx_stream[substream->pcm->device];\r\nint err;\r\nerr = snd_pcm_lib_alloc_vmalloc_buffer(substream,\r\nparams_buffer_bytes(hw_params));\r\nif (err < 0)\r\nreturn err;\r\nif (substream->runtime->status->state == SNDRV_PCM_STATE_OPEN) {\r\nmutex_lock(&dice->mutex);\r\ndice->substreams_counter++;\r\nmutex_unlock(&dice->mutex);\r\n}\r\namdtp_am824_set_pcm_format(stream, params_format(hw_params));\r\nreturn 0;\r\n}\r\nstatic int playback_hw_params(struct snd_pcm_substream *substream,\r\nstruct snd_pcm_hw_params *hw_params)\r\n{\r\nstruct snd_dice *dice = substream->private_data;\r\nstruct amdtp_stream *stream = &dice->rx_stream[substream->pcm->device];\r\nint err;\r\nerr = snd_pcm_lib_alloc_vmalloc_buffer(substream,\r\nparams_buffer_bytes(hw_params));\r\nif (err < 0)\r\nreturn err;\r\nif (substream->runtime->status->state == SNDRV_PCM_STATE_OPEN) {\r\nmutex_lock(&dice->mutex);\r\ndice->substreams_counter++;\r\nmutex_unlock(&dice->mutex);\r\n}\r\namdtp_am824_set_pcm_format(stream, params_format(hw_params));\r\nreturn 0;\r\n}\r\nstatic int capture_hw_free(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_dice *dice = substream->private_data;\r\nmutex_lock(&dice->mutex);\r\nif (substream->runtime->status->state != SNDRV_PCM_STATE_OPEN)\r\ndice->substreams_counter--;\r\nsnd_dice_stream_stop_duplex(dice);\r\nmutex_unlock(&dice->mutex);\r\nreturn snd_pcm_lib_free_vmalloc_buffer(substream);\r\n}\r\nstatic int playback_hw_free(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_dice *dice = substream->private_data;\r\nmutex_lock(&dice->mutex);\r\nif (substream->runtime->status->state != SNDRV_PCM_STATE_OPEN)\r\ndice->substreams_counter--;\r\nsnd_dice_stream_stop_duplex(dice);\r\nmutex_unlock(&dice->mutex);\r\nreturn snd_pcm_lib_free_vmalloc_buffer(substream);\r\n}\r\nstatic int capture_prepare(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_dice *dice = substream->private_data;\r\nstruct amdtp_stream *stream = &dice->tx_stream[substream->pcm->device];\r\nint err;\r\nmutex_lock(&dice->mutex);\r\nerr = snd_dice_stream_start_duplex(dice, substream->runtime->rate);\r\nmutex_unlock(&dice->mutex);\r\nif (err >= 0)\r\namdtp_stream_pcm_prepare(stream);\r\nreturn 0;\r\n}\r\nstatic int playback_prepare(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_dice *dice = substream->private_data;\r\nstruct amdtp_stream *stream = &dice->rx_stream[substream->pcm->device];\r\nint err;\r\nmutex_lock(&dice->mutex);\r\nerr = snd_dice_stream_start_duplex(dice, substream->runtime->rate);\r\nmutex_unlock(&dice->mutex);\r\nif (err >= 0)\r\namdtp_stream_pcm_prepare(stream);\r\nreturn err;\r\n}\r\nstatic int capture_trigger(struct snd_pcm_substream *substream, int cmd)\r\n{\r\nstruct snd_dice *dice = substream->private_data;\r\nstruct amdtp_stream *stream = &dice->tx_stream[substream->pcm->device];\r\nswitch (cmd) {\r\ncase SNDRV_PCM_TRIGGER_START:\r\namdtp_stream_pcm_trigger(stream, substream);\r\nbreak;\r\ncase SNDRV_PCM_TRIGGER_STOP:\r\namdtp_stream_pcm_trigger(stream, NULL);\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int playback_trigger(struct snd_pcm_substream *substream, int cmd)\r\n{\r\nstruct snd_dice *dice = substream->private_data;\r\nstruct amdtp_stream *stream = &dice->rx_stream[substream->pcm->device];\r\nswitch (cmd) {\r\ncase SNDRV_PCM_TRIGGER_START:\r\namdtp_stream_pcm_trigger(stream, substream);\r\nbreak;\r\ncase SNDRV_PCM_TRIGGER_STOP:\r\namdtp_stream_pcm_trigger(stream, NULL);\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic snd_pcm_uframes_t capture_pointer(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_dice *dice = substream->private_data;\r\nstruct amdtp_stream *stream = &dice->tx_stream[substream->pcm->device];\r\nreturn amdtp_stream_pcm_pointer(stream);\r\n}\r\nstatic snd_pcm_uframes_t playback_pointer(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_dice *dice = substream->private_data;\r\nstruct amdtp_stream *stream = &dice->rx_stream[substream->pcm->device];\r\nreturn amdtp_stream_pcm_pointer(stream);\r\n}\r\nint snd_dice_create_pcm(struct snd_dice *dice)\r\n{\r\nstatic struct snd_pcm_ops capture_ops = {\r\n.open = pcm_open,\r\n.close = pcm_close,\r\n.ioctl = snd_pcm_lib_ioctl,\r\n.hw_params = capture_hw_params,\r\n.hw_free = capture_hw_free,\r\n.prepare = capture_prepare,\r\n.trigger = capture_trigger,\r\n.pointer = capture_pointer,\r\n.page = snd_pcm_lib_get_vmalloc_page,\r\n.mmap = snd_pcm_lib_mmap_vmalloc,\r\n};\r\nstatic struct snd_pcm_ops playback_ops = {\r\n.open = pcm_open,\r\n.close = pcm_close,\r\n.ioctl = snd_pcm_lib_ioctl,\r\n.hw_params = playback_hw_params,\r\n.hw_free = playback_hw_free,\r\n.prepare = playback_prepare,\r\n.trigger = playback_trigger,\r\n.pointer = playback_pointer,\r\n.page = snd_pcm_lib_get_vmalloc_page,\r\n.mmap = snd_pcm_lib_mmap_vmalloc,\r\n};\r\n__be32 reg;\r\nstruct snd_pcm *pcm;\r\nunsigned int i, max_capture, max_playback, capture, playback;\r\nint err;\r\nif (dice->force_two_pcms) {\r\nmax_capture = max_playback = 2;\r\n} else {\r\nmax_capture = max_playback = 0;\r\nerr = snd_dice_transaction_read_tx(dice, TX_NUMBER, &reg,\r\nsizeof(reg));\r\nif (err < 0)\r\nreturn err;\r\nmax_capture = min_t(unsigned int, be32_to_cpu(reg), MAX_STREAMS);\r\nerr = snd_dice_transaction_read_rx(dice, RX_NUMBER, &reg,\r\nsizeof(reg));\r\nif (err < 0)\r\nreturn err;\r\nmax_playback = min_t(unsigned int, be32_to_cpu(reg), MAX_STREAMS);\r\n}\r\nfor (i = 0; i < MAX_STREAMS; i++) {\r\ncapture = playback = 0;\r\nif (i < max_capture)\r\ncapture = 1;\r\nif (i < max_playback)\r\nplayback = 1;\r\nif (capture == 0 && playback == 0)\r\nbreak;\r\nerr = snd_pcm_new(dice->card, "DICE", i, playback, capture,\r\n&pcm);\r\nif (err < 0)\r\nreturn err;\r\npcm->private_data = dice;\r\nstrcpy(pcm->name, dice->card->shortname);\r\nif (capture > 0)\r\nsnd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_CAPTURE,\r\n&capture_ops);\r\nif (playback > 0)\r\nsnd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_PLAYBACK,\r\n&playback_ops);\r\n}\r\nreturn 0;\r\n}
