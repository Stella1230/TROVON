struct expr *expr_alloc_symbol(struct symbol *sym)\r\n{\r\nstruct expr *e = xcalloc(1, sizeof(*e));\r\ne->type = E_SYMBOL;\r\ne->left.sym = sym;\r\nreturn e;\r\n}\r\nstruct expr *expr_alloc_one(enum expr_type type, struct expr *ce)\r\n{\r\nstruct expr *e = xcalloc(1, sizeof(*e));\r\ne->type = type;\r\ne->left.expr = ce;\r\nreturn e;\r\n}\r\nstruct expr *expr_alloc_two(enum expr_type type, struct expr *e1, struct expr *e2)\r\n{\r\nstruct expr *e = xcalloc(1, sizeof(*e));\r\ne->type = type;\r\ne->left.expr = e1;\r\ne->right.expr = e2;\r\nreturn e;\r\n}\r\nstruct expr *expr_alloc_comp(enum expr_type type, struct symbol *s1, struct symbol *s2)\r\n{\r\nstruct expr *e = xcalloc(1, sizeof(*e));\r\ne->type = type;\r\ne->left.sym = s1;\r\ne->right.sym = s2;\r\nreturn e;\r\n}\r\nstruct expr *expr_alloc_and(struct expr *e1, struct expr *e2)\r\n{\r\nif (!e1)\r\nreturn e2;\r\nreturn e2 ? expr_alloc_two(E_AND, e1, e2) : e1;\r\n}\r\nstruct expr *expr_alloc_or(struct expr *e1, struct expr *e2)\r\n{\r\nif (!e1)\r\nreturn e2;\r\nreturn e2 ? expr_alloc_two(E_OR, e1, e2) : e1;\r\n}\r\nstruct expr *expr_copy(const struct expr *org)\r\n{\r\nstruct expr *e;\r\nif (!org)\r\nreturn NULL;\r\ne = xmalloc(sizeof(*org));\r\nmemcpy(e, org, sizeof(*org));\r\nswitch (org->type) {\r\ncase E_SYMBOL:\r\ne->left = org->left;\r\nbreak;\r\ncase E_NOT:\r\ne->left.expr = expr_copy(org->left.expr);\r\nbreak;\r\ncase E_EQUAL:\r\ncase E_GEQ:\r\ncase E_GTH:\r\ncase E_LEQ:\r\ncase E_LTH:\r\ncase E_UNEQUAL:\r\ne->left.sym = org->left.sym;\r\ne->right.sym = org->right.sym;\r\nbreak;\r\ncase E_AND:\r\ncase E_OR:\r\ncase E_LIST:\r\ne->left.expr = expr_copy(org->left.expr);\r\ne->right.expr = expr_copy(org->right.expr);\r\nbreak;\r\ndefault:\r\nprintf("can't copy type %d\n", e->type);\r\nfree(e);\r\ne = NULL;\r\nbreak;\r\n}\r\nreturn e;\r\n}\r\nvoid expr_free(struct expr *e)\r\n{\r\nif (!e)\r\nreturn;\r\nswitch (e->type) {\r\ncase E_SYMBOL:\r\nbreak;\r\ncase E_NOT:\r\nexpr_free(e->left.expr);\r\nreturn;\r\ncase E_EQUAL:\r\ncase E_GEQ:\r\ncase E_GTH:\r\ncase E_LEQ:\r\ncase E_LTH:\r\ncase E_UNEQUAL:\r\nbreak;\r\ncase E_OR:\r\ncase E_AND:\r\nexpr_free(e->left.expr);\r\nexpr_free(e->right.expr);\r\nbreak;\r\ndefault:\r\nprintf("how to free type %d?\n", e->type);\r\nbreak;\r\n}\r\nfree(e);\r\n}\r\nstatic void __expr_eliminate_eq(enum expr_type type, struct expr **ep1, struct expr **ep2)\r\n{\r\nif (e1->type == type) {\r\n__expr_eliminate_eq(type, &e1->left.expr, &e2);\r\n__expr_eliminate_eq(type, &e1->right.expr, &e2);\r\nreturn;\r\n}\r\nif (e2->type == type) {\r\n__expr_eliminate_eq(type, &e1, &e2->left.expr);\r\n__expr_eliminate_eq(type, &e1, &e2->right.expr);\r\nreturn;\r\n}\r\nif (e1->type == E_SYMBOL && e2->type == E_SYMBOL &&\r\ne1->left.sym == e2->left.sym &&\r\n(e1->left.sym == &symbol_yes || e1->left.sym == &symbol_no))\r\nreturn;\r\nif (!expr_eq(e1, e2))\r\nreturn;\r\ntrans_count++;\r\nexpr_free(e1); expr_free(e2);\r\nswitch (type) {\r\ncase E_OR:\r\ne1 = expr_alloc_symbol(&symbol_no);\r\ne2 = expr_alloc_symbol(&symbol_no);\r\nbreak;\r\ncase E_AND:\r\ne1 = expr_alloc_symbol(&symbol_yes);\r\ne2 = expr_alloc_symbol(&symbol_yes);\r\nbreak;\r\ndefault:\r\n;\r\n}\r\n}\r\nvoid expr_eliminate_eq(struct expr **ep1, struct expr **ep2)\r\n{\r\nif (!e1 || !e2)\r\nreturn;\r\nswitch (e1->type) {\r\ncase E_OR:\r\ncase E_AND:\r\n__expr_eliminate_eq(e1->type, ep1, ep2);\r\ndefault:\r\n;\r\n}\r\nif (e1->type != e2->type) switch (e2->type) {\r\ncase E_OR:\r\ncase E_AND:\r\n__expr_eliminate_eq(e2->type, ep1, ep2);\r\ndefault:\r\n;\r\n}\r\ne1 = expr_eliminate_yn(e1);\r\ne2 = expr_eliminate_yn(e2);\r\n}\r\nstatic int expr_eq(struct expr *e1, struct expr *e2)\r\n{\r\nint res, old_count;\r\nif (e1->type != e2->type)\r\nreturn 0;\r\nswitch (e1->type) {\r\ncase E_EQUAL:\r\ncase E_GEQ:\r\ncase E_GTH:\r\ncase E_LEQ:\r\ncase E_LTH:\r\ncase E_UNEQUAL:\r\nreturn e1->left.sym == e2->left.sym && e1->right.sym == e2->right.sym;\r\ncase E_SYMBOL:\r\nreturn e1->left.sym == e2->left.sym;\r\ncase E_NOT:\r\nreturn expr_eq(e1->left.expr, e2->left.expr);\r\ncase E_AND:\r\ncase E_OR:\r\ne1 = expr_copy(e1);\r\ne2 = expr_copy(e2);\r\nold_count = trans_count;\r\nexpr_eliminate_eq(&e1, &e2);\r\nres = (e1->type == E_SYMBOL && e2->type == E_SYMBOL &&\r\ne1->left.sym == e2->left.sym);\r\nexpr_free(e1);\r\nexpr_free(e2);\r\ntrans_count = old_count;\r\nreturn res;\r\ncase E_LIST:\r\ncase E_RANGE:\r\ncase E_NONE:\r\n;\r\n}\r\nif (DEBUG_EXPR) {\r\nexpr_fprint(e1, stdout);\r\nprintf(" = ");\r\nexpr_fprint(e2, stdout);\r\nprintf(" ?\n");\r\n}\r\nreturn 0;\r\n}\r\nstatic struct expr *expr_eliminate_yn(struct expr *e)\r\n{\r\nstruct expr *tmp;\r\nif (e) switch (e->type) {\r\ncase E_AND:\r\ne->left.expr = expr_eliminate_yn(e->left.expr);\r\ne->right.expr = expr_eliminate_yn(e->right.expr);\r\nif (e->left.expr->type == E_SYMBOL) {\r\nif (e->left.expr->left.sym == &symbol_no) {\r\nexpr_free(e->left.expr);\r\nexpr_free(e->right.expr);\r\ne->type = E_SYMBOL;\r\ne->left.sym = &symbol_no;\r\ne->right.expr = NULL;\r\nreturn e;\r\n} else if (e->left.expr->left.sym == &symbol_yes) {\r\nfree(e->left.expr);\r\ntmp = e->right.expr;\r\n*e = *(e->right.expr);\r\nfree(tmp);\r\nreturn e;\r\n}\r\n}\r\nif (e->right.expr->type == E_SYMBOL) {\r\nif (e->right.expr->left.sym == &symbol_no) {\r\nexpr_free(e->left.expr);\r\nexpr_free(e->right.expr);\r\ne->type = E_SYMBOL;\r\ne->left.sym = &symbol_no;\r\ne->right.expr = NULL;\r\nreturn e;\r\n} else if (e->right.expr->left.sym == &symbol_yes) {\r\nfree(e->right.expr);\r\ntmp = e->left.expr;\r\n*e = *(e->left.expr);\r\nfree(tmp);\r\nreturn e;\r\n}\r\n}\r\nbreak;\r\ncase E_OR:\r\ne->left.expr = expr_eliminate_yn(e->left.expr);\r\ne->right.expr = expr_eliminate_yn(e->right.expr);\r\nif (e->left.expr->type == E_SYMBOL) {\r\nif (e->left.expr->left.sym == &symbol_no) {\r\nfree(e->left.expr);\r\ntmp = e->right.expr;\r\n*e = *(e->right.expr);\r\nfree(tmp);\r\nreturn e;\r\n} else if (e->left.expr->left.sym == &symbol_yes) {\r\nexpr_free(e->left.expr);\r\nexpr_free(e->right.expr);\r\ne->type = E_SYMBOL;\r\ne->left.sym = &symbol_yes;\r\ne->right.expr = NULL;\r\nreturn e;\r\n}\r\n}\r\nif (e->right.expr->type == E_SYMBOL) {\r\nif (e->right.expr->left.sym == &symbol_no) {\r\nfree(e->right.expr);\r\ntmp = e->left.expr;\r\n*e = *(e->left.expr);\r\nfree(tmp);\r\nreturn e;\r\n} else if (e->right.expr->left.sym == &symbol_yes) {\r\nexpr_free(e->left.expr);\r\nexpr_free(e->right.expr);\r\ne->type = E_SYMBOL;\r\ne->left.sym = &symbol_yes;\r\ne->right.expr = NULL;\r\nreturn e;\r\n}\r\n}\r\nbreak;\r\ndefault:\r\n;\r\n}\r\nreturn e;\r\n}\r\nstruct expr *expr_trans_bool(struct expr *e)\r\n{\r\nif (!e)\r\nreturn NULL;\r\nswitch (e->type) {\r\ncase E_AND:\r\ncase E_OR:\r\ncase E_NOT:\r\ne->left.expr = expr_trans_bool(e->left.expr);\r\ne->right.expr = expr_trans_bool(e->right.expr);\r\nbreak;\r\ncase E_UNEQUAL:\r\nif (e->left.sym->type == S_TRISTATE) {\r\nif (e->right.sym == &symbol_no) {\r\ne->type = E_SYMBOL;\r\ne->right.sym = NULL;\r\n}\r\n}\r\nbreak;\r\ndefault:\r\n;\r\n}\r\nreturn e;\r\n}\r\nstatic struct expr *expr_join_or(struct expr *e1, struct expr *e2)\r\n{\r\nstruct expr *tmp;\r\nstruct symbol *sym1, *sym2;\r\nif (expr_eq(e1, e2))\r\nreturn expr_copy(e1);\r\nif (e1->type != E_EQUAL && e1->type != E_UNEQUAL && e1->type != E_SYMBOL && e1->type != E_NOT)\r\nreturn NULL;\r\nif (e2->type != E_EQUAL && e2->type != E_UNEQUAL && e2->type != E_SYMBOL && e2->type != E_NOT)\r\nreturn NULL;\r\nif (e1->type == E_NOT) {\r\ntmp = e1->left.expr;\r\nif (tmp->type != E_EQUAL && tmp->type != E_UNEQUAL && tmp->type != E_SYMBOL)\r\nreturn NULL;\r\nsym1 = tmp->left.sym;\r\n} else\r\nsym1 = e1->left.sym;\r\nif (e2->type == E_NOT) {\r\nif (e2->left.expr->type != E_SYMBOL)\r\nreturn NULL;\r\nsym2 = e2->left.expr->left.sym;\r\n} else\r\nsym2 = e2->left.sym;\r\nif (sym1 != sym2)\r\nreturn NULL;\r\nif (sym1->type != S_BOOLEAN && sym1->type != S_TRISTATE)\r\nreturn NULL;\r\nif (sym1->type == S_TRISTATE) {\r\nif (e1->type == E_EQUAL && e2->type == E_EQUAL &&\r\n((e1->right.sym == &symbol_yes && e2->right.sym == &symbol_mod) ||\r\n(e1->right.sym == &symbol_mod && e2->right.sym == &symbol_yes))) {\r\nreturn expr_alloc_comp(E_UNEQUAL, sym1, &symbol_no);\r\n}\r\nif (e1->type == E_EQUAL && e2->type == E_EQUAL &&\r\n((e1->right.sym == &symbol_yes && e2->right.sym == &symbol_no) ||\r\n(e1->right.sym == &symbol_no && e2->right.sym == &symbol_yes))) {\r\nreturn expr_alloc_comp(E_UNEQUAL, sym1, &symbol_mod);\r\n}\r\nif (e1->type == E_EQUAL && e2->type == E_EQUAL &&\r\n((e1->right.sym == &symbol_mod && e2->right.sym == &symbol_no) ||\r\n(e1->right.sym == &symbol_no && e2->right.sym == &symbol_mod))) {\r\nreturn expr_alloc_comp(E_UNEQUAL, sym1, &symbol_yes);\r\n}\r\n}\r\nif (sym1->type == S_BOOLEAN && sym1 == sym2) {\r\nif ((e1->type == E_NOT && e1->left.expr->type == E_SYMBOL && e2->type == E_SYMBOL) ||\r\n(e2->type == E_NOT && e2->left.expr->type == E_SYMBOL && e1->type == E_SYMBOL))\r\nreturn expr_alloc_symbol(&symbol_yes);\r\n}\r\nif (DEBUG_EXPR) {\r\nprintf("optimize (");\r\nexpr_fprint(e1, stdout);\r\nprintf(") || (");\r\nexpr_fprint(e2, stdout);\r\nprintf(")?\n");\r\n}\r\nreturn NULL;\r\n}\r\nstatic struct expr *expr_join_and(struct expr *e1, struct expr *e2)\r\n{\r\nstruct expr *tmp;\r\nstruct symbol *sym1, *sym2;\r\nif (expr_eq(e1, e2))\r\nreturn expr_copy(e1);\r\nif (e1->type != E_EQUAL && e1->type != E_UNEQUAL && e1->type != E_SYMBOL && e1->type != E_NOT)\r\nreturn NULL;\r\nif (e2->type != E_EQUAL && e2->type != E_UNEQUAL && e2->type != E_SYMBOL && e2->type != E_NOT)\r\nreturn NULL;\r\nif (e1->type == E_NOT) {\r\ntmp = e1->left.expr;\r\nif (tmp->type != E_EQUAL && tmp->type != E_UNEQUAL && tmp->type != E_SYMBOL)\r\nreturn NULL;\r\nsym1 = tmp->left.sym;\r\n} else\r\nsym1 = e1->left.sym;\r\nif (e2->type == E_NOT) {\r\nif (e2->left.expr->type != E_SYMBOL)\r\nreturn NULL;\r\nsym2 = e2->left.expr->left.sym;\r\n} else\r\nsym2 = e2->left.sym;\r\nif (sym1 != sym2)\r\nreturn NULL;\r\nif (sym1->type != S_BOOLEAN && sym1->type != S_TRISTATE)\r\nreturn NULL;\r\nif ((e1->type == E_SYMBOL && e2->type == E_EQUAL && e2->right.sym == &symbol_yes) ||\r\n(e2->type == E_SYMBOL && e1->type == E_EQUAL && e1->right.sym == &symbol_yes))\r\nreturn expr_alloc_comp(E_EQUAL, sym1, &symbol_yes);\r\nif ((e1->type == E_SYMBOL && e2->type == E_UNEQUAL && e2->right.sym == &symbol_no) ||\r\n(e2->type == E_SYMBOL && e1->type == E_UNEQUAL && e1->right.sym == &symbol_no))\r\nreturn expr_alloc_symbol(sym1);\r\nif ((e1->type == E_SYMBOL && e2->type == E_UNEQUAL && e2->right.sym == &symbol_mod) ||\r\n(e2->type == E_SYMBOL && e1->type == E_UNEQUAL && e1->right.sym == &symbol_mod))\r\nreturn expr_alloc_comp(E_EQUAL, sym1, &symbol_yes);\r\nif (sym1->type == S_TRISTATE) {\r\nif (e1->type == E_EQUAL && e2->type == E_UNEQUAL) {\r\nsym2 = e1->right.sym;\r\nif ((e2->right.sym->flags & SYMBOL_CONST) && (sym2->flags & SYMBOL_CONST))\r\nreturn sym2 != e2->right.sym ? expr_alloc_comp(E_EQUAL, sym1, sym2)\r\n: expr_alloc_symbol(&symbol_no);\r\n}\r\nif (e1->type == E_UNEQUAL && e2->type == E_EQUAL) {\r\nsym2 = e2->right.sym;\r\nif ((e1->right.sym->flags & SYMBOL_CONST) && (sym2->flags & SYMBOL_CONST))\r\nreturn sym2 != e1->right.sym ? expr_alloc_comp(E_EQUAL, sym1, sym2)\r\n: expr_alloc_symbol(&symbol_no);\r\n}\r\nif (e1->type == E_UNEQUAL && e2->type == E_UNEQUAL &&\r\n((e1->right.sym == &symbol_yes && e2->right.sym == &symbol_no) ||\r\n(e1->right.sym == &symbol_no && e2->right.sym == &symbol_yes)))\r\nreturn expr_alloc_comp(E_EQUAL, sym1, &symbol_mod);\r\nif (e1->type == E_UNEQUAL && e2->type == E_UNEQUAL &&\r\n((e1->right.sym == &symbol_yes && e2->right.sym == &symbol_mod) ||\r\n(e1->right.sym == &symbol_mod && e2->right.sym == &symbol_yes)))\r\nreturn expr_alloc_comp(E_EQUAL, sym1, &symbol_no);\r\nif (e1->type == E_UNEQUAL && e2->type == E_UNEQUAL &&\r\n((e1->right.sym == &symbol_mod && e2->right.sym == &symbol_no) ||\r\n(e1->right.sym == &symbol_no && e2->right.sym == &symbol_mod)))\r\nreturn expr_alloc_comp(E_EQUAL, sym1, &symbol_yes);\r\nif ((e1->type == E_SYMBOL && e2->type == E_EQUAL && e2->right.sym == &symbol_mod) ||\r\n(e2->type == E_SYMBOL && e1->type == E_EQUAL && e1->right.sym == &symbol_mod) ||\r\n(e1->type == E_SYMBOL && e2->type == E_UNEQUAL && e2->right.sym == &symbol_yes) ||\r\n(e2->type == E_SYMBOL && e1->type == E_UNEQUAL && e1->right.sym == &symbol_yes))\r\nreturn NULL;\r\n}\r\nif (DEBUG_EXPR) {\r\nprintf("optimize (");\r\nexpr_fprint(e1, stdout);\r\nprintf(") && (");\r\nexpr_fprint(e2, stdout);\r\nprintf(")?\n");\r\n}\r\nreturn NULL;\r\n}\r\nstatic void expr_eliminate_dups1(enum expr_type type, struct expr **ep1, struct expr **ep2)\r\n{\r\n#define e1 (*ep1)\r\n#define e2 (*ep2)\r\nstruct expr *tmp;\r\nif (e1->type == type) {\r\nexpr_eliminate_dups1(type, &e1->left.expr, &e2);\r\nexpr_eliminate_dups1(type, &e1->right.expr, &e2);\r\nreturn;\r\n}\r\nif (e2->type == type) {\r\nexpr_eliminate_dups1(type, &e1, &e2->left.expr);\r\nexpr_eliminate_dups1(type, &e1, &e2->right.expr);\r\nreturn;\r\n}\r\nif (e1 == e2)\r\nreturn;\r\nswitch (e1->type) {\r\ncase E_OR: case E_AND:\r\nexpr_eliminate_dups1(e1->type, &e1, &e1);\r\ndefault:\r\n;\r\n}\r\nswitch (type) {\r\ncase E_OR:\r\ntmp = expr_join_or(e1, e2);\r\nif (tmp) {\r\nexpr_free(e1); expr_free(e2);\r\ne1 = expr_alloc_symbol(&symbol_no);\r\ne2 = tmp;\r\ntrans_count++;\r\n}\r\nbreak;\r\ncase E_AND:\r\ntmp = expr_join_and(e1, e2);\r\nif (tmp) {\r\nexpr_free(e1); expr_free(e2);\r\ne1 = expr_alloc_symbol(&symbol_yes);\r\ne2 = tmp;\r\ntrans_count++;\r\n}\r\nbreak;\r\ndefault:\r\n;\r\n}\r\n#undef e1\r\n#undef e2\r\n}\r\nstruct expr *expr_eliminate_dups(struct expr *e)\r\n{\r\nint oldcount;\r\nif (!e)\r\nreturn e;\r\noldcount = trans_count;\r\nwhile (1) {\r\ntrans_count = 0;\r\nswitch (e->type) {\r\ncase E_OR: case E_AND:\r\nexpr_eliminate_dups1(e->type, &e, &e);\r\ndefault:\r\n;\r\n}\r\nif (!trans_count)\r\nbreak;\r\ne = expr_eliminate_yn(e);\r\n}\r\ntrans_count = oldcount;\r\nreturn e;\r\n}\r\nstruct expr *expr_transform(struct expr *e)\r\n{\r\nstruct expr *tmp;\r\nif (!e)\r\nreturn NULL;\r\nswitch (e->type) {\r\ncase E_EQUAL:\r\ncase E_GEQ:\r\ncase E_GTH:\r\ncase E_LEQ:\r\ncase E_LTH:\r\ncase E_UNEQUAL:\r\ncase E_SYMBOL:\r\ncase E_LIST:\r\nbreak;\r\ndefault:\r\ne->left.expr = expr_transform(e->left.expr);\r\ne->right.expr = expr_transform(e->right.expr);\r\n}\r\nswitch (e->type) {\r\ncase E_EQUAL:\r\nif (e->left.sym->type != S_BOOLEAN)\r\nbreak;\r\nif (e->right.sym == &symbol_no) {\r\ne->type = E_NOT;\r\ne->left.expr = expr_alloc_symbol(e->left.sym);\r\ne->right.sym = NULL;\r\nbreak;\r\n}\r\nif (e->right.sym == &symbol_mod) {\r\nprintf("boolean symbol %s tested for 'm'? test forced to 'n'\n", e->left.sym->name);\r\ne->type = E_SYMBOL;\r\ne->left.sym = &symbol_no;\r\ne->right.sym = NULL;\r\nbreak;\r\n}\r\nif (e->right.sym == &symbol_yes) {\r\ne->type = E_SYMBOL;\r\ne->right.sym = NULL;\r\nbreak;\r\n}\r\nbreak;\r\ncase E_UNEQUAL:\r\nif (e->left.sym->type != S_BOOLEAN)\r\nbreak;\r\nif (e->right.sym == &symbol_no) {\r\ne->type = E_SYMBOL;\r\ne->right.sym = NULL;\r\nbreak;\r\n}\r\nif (e->right.sym == &symbol_mod) {\r\nprintf("boolean symbol %s tested for 'm'? test forced to 'y'\n", e->left.sym->name);\r\ne->type = E_SYMBOL;\r\ne->left.sym = &symbol_yes;\r\ne->right.sym = NULL;\r\nbreak;\r\n}\r\nif (e->right.sym == &symbol_yes) {\r\ne->type = E_NOT;\r\ne->left.expr = expr_alloc_symbol(e->left.sym);\r\ne->right.sym = NULL;\r\nbreak;\r\n}\r\nbreak;\r\ncase E_NOT:\r\nswitch (e->left.expr->type) {\r\ncase E_NOT:\r\ntmp = e->left.expr->left.expr;\r\nfree(e->left.expr);\r\nfree(e);\r\ne = tmp;\r\ne = expr_transform(e);\r\nbreak;\r\ncase E_EQUAL:\r\ncase E_UNEQUAL:\r\ntmp = e->left.expr;\r\nfree(e);\r\ne = tmp;\r\ne->type = e->type == E_EQUAL ? E_UNEQUAL : E_EQUAL;\r\nbreak;\r\ncase E_LEQ:\r\ncase E_GEQ:\r\ntmp = e->left.expr;\r\nfree(e);\r\ne = tmp;\r\ne->type = e->type == E_LEQ ? E_GTH : E_LTH;\r\nbreak;\r\ncase E_LTH:\r\ncase E_GTH:\r\ntmp = e->left.expr;\r\nfree(e);\r\ne = tmp;\r\ne->type = e->type == E_LTH ? E_GEQ : E_LEQ;\r\nbreak;\r\ncase E_OR:\r\ntmp = e->left.expr;\r\ne->type = E_AND;\r\ne->right.expr = expr_alloc_one(E_NOT, tmp->right.expr);\r\ntmp->type = E_NOT;\r\ntmp->right.expr = NULL;\r\ne = expr_transform(e);\r\nbreak;\r\ncase E_AND:\r\ntmp = e->left.expr;\r\ne->type = E_OR;\r\ne->right.expr = expr_alloc_one(E_NOT, tmp->right.expr);\r\ntmp->type = E_NOT;\r\ntmp->right.expr = NULL;\r\ne = expr_transform(e);\r\nbreak;\r\ncase E_SYMBOL:\r\nif (e->left.expr->left.sym == &symbol_yes) {\r\ntmp = e->left.expr;\r\nfree(e);\r\ne = tmp;\r\ne->type = E_SYMBOL;\r\ne->left.sym = &symbol_no;\r\nbreak;\r\n}\r\nif (e->left.expr->left.sym == &symbol_mod) {\r\ntmp = e->left.expr;\r\nfree(e);\r\ne = tmp;\r\ne->type = E_SYMBOL;\r\ne->left.sym = &symbol_mod;\r\nbreak;\r\n}\r\nif (e->left.expr->left.sym == &symbol_no) {\r\ntmp = e->left.expr;\r\nfree(e);\r\ne = tmp;\r\ne->type = E_SYMBOL;\r\ne->left.sym = &symbol_yes;\r\nbreak;\r\n}\r\nbreak;\r\ndefault:\r\n;\r\n}\r\nbreak;\r\ndefault:\r\n;\r\n}\r\nreturn e;\r\n}\r\nint expr_contains_symbol(struct expr *dep, struct symbol *sym)\r\n{\r\nif (!dep)\r\nreturn 0;\r\nswitch (dep->type) {\r\ncase E_AND:\r\ncase E_OR:\r\nreturn expr_contains_symbol(dep->left.expr, sym) ||\r\nexpr_contains_symbol(dep->right.expr, sym);\r\ncase E_SYMBOL:\r\nreturn dep->left.sym == sym;\r\ncase E_EQUAL:\r\ncase E_GEQ:\r\ncase E_GTH:\r\ncase E_LEQ:\r\ncase E_LTH:\r\ncase E_UNEQUAL:\r\nreturn dep->left.sym == sym ||\r\ndep->right.sym == sym;\r\ncase E_NOT:\r\nreturn expr_contains_symbol(dep->left.expr, sym);\r\ndefault:\r\n;\r\n}\r\nreturn 0;\r\n}\r\nbool expr_depends_symbol(struct expr *dep, struct symbol *sym)\r\n{\r\nif (!dep)\r\nreturn false;\r\nswitch (dep->type) {\r\ncase E_AND:\r\nreturn expr_depends_symbol(dep->left.expr, sym) ||\r\nexpr_depends_symbol(dep->right.expr, sym);\r\ncase E_SYMBOL:\r\nreturn dep->left.sym == sym;\r\ncase E_EQUAL:\r\nif (dep->left.sym == sym) {\r\nif (dep->right.sym == &symbol_yes || dep->right.sym == &symbol_mod)\r\nreturn true;\r\n}\r\nbreak;\r\ncase E_UNEQUAL:\r\nif (dep->left.sym == sym) {\r\nif (dep->right.sym == &symbol_no)\r\nreturn true;\r\n}\r\nbreak;\r\ndefault:\r\n;\r\n}\r\nreturn false;\r\n}\r\nstruct expr *expr_trans_compare(struct expr *e, enum expr_type type, struct symbol *sym)\r\n{\r\nstruct expr *e1, *e2;\r\nif (!e) {\r\ne = expr_alloc_symbol(sym);\r\nif (type == E_UNEQUAL)\r\ne = expr_alloc_one(E_NOT, e);\r\nreturn e;\r\n}\r\nswitch (e->type) {\r\ncase E_AND:\r\ne1 = expr_trans_compare(e->left.expr, E_EQUAL, sym);\r\ne2 = expr_trans_compare(e->right.expr, E_EQUAL, sym);\r\nif (sym == &symbol_yes)\r\ne = expr_alloc_two(E_AND, e1, e2);\r\nif (sym == &symbol_no)\r\ne = expr_alloc_two(E_OR, e1, e2);\r\nif (type == E_UNEQUAL)\r\ne = expr_alloc_one(E_NOT, e);\r\nreturn e;\r\ncase E_OR:\r\ne1 = expr_trans_compare(e->left.expr, E_EQUAL, sym);\r\ne2 = expr_trans_compare(e->right.expr, E_EQUAL, sym);\r\nif (sym == &symbol_yes)\r\ne = expr_alloc_two(E_OR, e1, e2);\r\nif (sym == &symbol_no)\r\ne = expr_alloc_two(E_AND, e1, e2);\r\nif (type == E_UNEQUAL)\r\ne = expr_alloc_one(E_NOT, e);\r\nreturn e;\r\ncase E_NOT:\r\nreturn expr_trans_compare(e->left.expr, type == E_EQUAL ? E_UNEQUAL : E_EQUAL, sym);\r\ncase E_UNEQUAL:\r\ncase E_LTH:\r\ncase E_LEQ:\r\ncase E_GTH:\r\ncase E_GEQ:\r\ncase E_EQUAL:\r\nif (type == E_EQUAL) {\r\nif (sym == &symbol_yes)\r\nreturn expr_copy(e);\r\nif (sym == &symbol_mod)\r\nreturn expr_alloc_symbol(&symbol_no);\r\nif (sym == &symbol_no)\r\nreturn expr_alloc_one(E_NOT, expr_copy(e));\r\n} else {\r\nif (sym == &symbol_yes)\r\nreturn expr_alloc_one(E_NOT, expr_copy(e));\r\nif (sym == &symbol_mod)\r\nreturn expr_alloc_symbol(&symbol_yes);\r\nif (sym == &symbol_no)\r\nreturn expr_copy(e);\r\n}\r\nbreak;\r\ncase E_SYMBOL:\r\nreturn expr_alloc_comp(type, e->left.sym, sym);\r\ncase E_LIST:\r\ncase E_RANGE:\r\ncase E_NONE:\r\n;\r\n}\r\nreturn NULL;\r\n}\r\nstatic enum string_value_kind expr_parse_string(const char *str,\r\nenum symbol_type type,\r\nunion string_value *val)\r\n{\r\nchar *tail;\r\nenum string_value_kind kind;\r\nerrno = 0;\r\nswitch (type) {\r\ncase S_BOOLEAN:\r\ncase S_TRISTATE:\r\nreturn k_string;\r\ncase S_INT:\r\nval->s = strtoll(str, &tail, 10);\r\nkind = k_signed;\r\nbreak;\r\ncase S_HEX:\r\nval->u = strtoull(str, &tail, 16);\r\nkind = k_unsigned;\r\nbreak;\r\ncase S_STRING:\r\ncase S_UNKNOWN:\r\nval->s = strtoll(str, &tail, 0);\r\nkind = k_signed;\r\nbreak;\r\ndefault:\r\nreturn k_invalid;\r\n}\r\nreturn !errno && !*tail && tail > str && isxdigit(tail[-1])\r\n? kind : k_string;\r\n}\r\ntristate expr_calc_value(struct expr *e)\r\n{\r\ntristate val1, val2;\r\nconst char *str1, *str2;\r\nenum string_value_kind k1 = k_string, k2 = k_string;\r\nunion string_value lval = {}, rval = {};\r\nint res;\r\nif (!e)\r\nreturn yes;\r\nswitch (e->type) {\r\ncase E_SYMBOL:\r\nsym_calc_value(e->left.sym);\r\nreturn e->left.sym->curr.tri;\r\ncase E_AND:\r\nval1 = expr_calc_value(e->left.expr);\r\nval2 = expr_calc_value(e->right.expr);\r\nreturn EXPR_AND(val1, val2);\r\ncase E_OR:\r\nval1 = expr_calc_value(e->left.expr);\r\nval2 = expr_calc_value(e->right.expr);\r\nreturn EXPR_OR(val1, val2);\r\ncase E_NOT:\r\nval1 = expr_calc_value(e->left.expr);\r\nreturn EXPR_NOT(val1);\r\ncase E_EQUAL:\r\ncase E_GEQ:\r\ncase E_GTH:\r\ncase E_LEQ:\r\ncase E_LTH:\r\ncase E_UNEQUAL:\r\nbreak;\r\ndefault:\r\nprintf("expr_calc_value: %d?\n", e->type);\r\nreturn no;\r\n}\r\nsym_calc_value(e->left.sym);\r\nsym_calc_value(e->right.sym);\r\nstr1 = sym_get_string_value(e->left.sym);\r\nstr2 = sym_get_string_value(e->right.sym);\r\nif (e->left.sym->type != S_STRING || e->right.sym->type != S_STRING) {\r\nk1 = expr_parse_string(str1, e->left.sym->type, &lval);\r\nk2 = expr_parse_string(str2, e->right.sym->type, &rval);\r\n}\r\nif (k1 == k_string || k2 == k_string)\r\nres = strcmp(str1, str2);\r\nelse if (k1 == k_invalid || k2 == k_invalid) {\r\nif (e->type != E_EQUAL && e->type != E_UNEQUAL) {\r\nprintf("Cannot compare \"%s\" and \"%s\"\n", str1, str2);\r\nreturn no;\r\n}\r\nres = strcmp(str1, str2);\r\n} else if (k1 == k_unsigned || k2 == k_unsigned)\r\nres = (lval.u > rval.u) - (lval.u < rval.u);\r\nelse\r\nres = (lval.s > rval.s) - (lval.s < rval.s);\r\nswitch(e->type) {\r\ncase E_EQUAL:\r\nreturn res ? no : yes;\r\ncase E_GEQ:\r\nreturn res >= 0 ? yes : no;\r\ncase E_GTH:\r\nreturn res > 0 ? yes : no;\r\ncase E_LEQ:\r\nreturn res <= 0 ? yes : no;\r\ncase E_LTH:\r\nreturn res < 0 ? yes : no;\r\ncase E_UNEQUAL:\r\nreturn res ? yes : no;\r\ndefault:\r\nprintf("expr_calc_value: relation %d?\n", e->type);\r\nreturn no;\r\n}\r\n}\r\nstatic int expr_compare_type(enum expr_type t1, enum expr_type t2)\r\n{\r\nif (t1 == t2)\r\nreturn 0;\r\nswitch (t1) {\r\ncase E_LEQ:\r\ncase E_LTH:\r\ncase E_GEQ:\r\ncase E_GTH:\r\nif (t2 == E_EQUAL || t2 == E_UNEQUAL)\r\nreturn 1;\r\ncase E_EQUAL:\r\ncase E_UNEQUAL:\r\nif (t2 == E_NOT)\r\nreturn 1;\r\ncase E_NOT:\r\nif (t2 == E_AND)\r\nreturn 1;\r\ncase E_AND:\r\nif (t2 == E_OR)\r\nreturn 1;\r\ncase E_OR:\r\nif (t2 == E_LIST)\r\nreturn 1;\r\ncase E_LIST:\r\nif (t2 == 0)\r\nreturn 1;\r\ndefault:\r\nreturn -1;\r\n}\r\nprintf("[%dgt%d?]", t1, t2);\r\nreturn 0;\r\n}\r\nstatic inline struct expr *\r\nexpr_get_leftmost_symbol(const struct expr *e)\r\n{\r\nif (e == NULL)\r\nreturn NULL;\r\nwhile (e->type != E_SYMBOL)\r\ne = e->left.expr;\r\nreturn expr_copy(e);\r\n}\r\nstruct expr *expr_simplify_unmet_dep(struct expr *e1, struct expr *e2)\r\n{\r\nstruct expr *ret;\r\nswitch (e1->type) {\r\ncase E_OR:\r\nreturn expr_alloc_and(\r\nexpr_simplify_unmet_dep(e1->left.expr, e2),\r\nexpr_simplify_unmet_dep(e1->right.expr, e2));\r\ncase E_AND: {\r\nstruct expr *e;\r\ne = expr_alloc_and(expr_copy(e1), expr_copy(e2));\r\ne = expr_eliminate_dups(e);\r\nret = (!expr_eq(e, e1)) ? e1 : NULL;\r\nexpr_free(e);\r\nbreak;\r\n}\r\ndefault:\r\nret = e1;\r\nbreak;\r\n}\r\nreturn expr_get_leftmost_symbol(ret);\r\n}\r\nvoid expr_print(struct expr *e, void (*fn)(void *, struct symbol *, const char *), void *data, int prevtoken)\r\n{\r\nif (!e) {\r\nfn(data, NULL, "y");\r\nreturn;\r\n}\r\nif (expr_compare_type(prevtoken, e->type) > 0)\r\nfn(data, NULL, "(");\r\nswitch (e->type) {\r\ncase E_SYMBOL:\r\nif (e->left.sym->name)\r\nfn(data, e->left.sym, e->left.sym->name);\r\nelse\r\nfn(data, NULL, "<choice>");\r\nbreak;\r\ncase E_NOT:\r\nfn(data, NULL, "!");\r\nexpr_print(e->left.expr, fn, data, E_NOT);\r\nbreak;\r\ncase E_EQUAL:\r\nif (e->left.sym->name)\r\nfn(data, e->left.sym, e->left.sym->name);\r\nelse\r\nfn(data, NULL, "<choice>");\r\nfn(data, NULL, "=");\r\nfn(data, e->right.sym, e->right.sym->name);\r\nbreak;\r\ncase E_LEQ:\r\ncase E_LTH:\r\nif (e->left.sym->name)\r\nfn(data, e->left.sym, e->left.sym->name);\r\nelse\r\nfn(data, NULL, "<choice>");\r\nfn(data, NULL, e->type == E_LEQ ? "<=" : "<");\r\nfn(data, e->right.sym, e->right.sym->name);\r\nbreak;\r\ncase E_GEQ:\r\ncase E_GTH:\r\nif (e->left.sym->name)\r\nfn(data, e->left.sym, e->left.sym->name);\r\nelse\r\nfn(data, NULL, "<choice>");\r\nfn(data, NULL, e->type == E_GEQ ? ">=" : ">");\r\nfn(data, e->right.sym, e->right.sym->name);\r\nbreak;\r\ncase E_UNEQUAL:\r\nif (e->left.sym->name)\r\nfn(data, e->left.sym, e->left.sym->name);\r\nelse\r\nfn(data, NULL, "<choice>");\r\nfn(data, NULL, "!=");\r\nfn(data, e->right.sym, e->right.sym->name);\r\nbreak;\r\ncase E_OR:\r\nexpr_print(e->left.expr, fn, data, E_OR);\r\nfn(data, NULL, " || ");\r\nexpr_print(e->right.expr, fn, data, E_OR);\r\nbreak;\r\ncase E_AND:\r\nexpr_print(e->left.expr, fn, data, E_AND);\r\nfn(data, NULL, " && ");\r\nexpr_print(e->right.expr, fn, data, E_AND);\r\nbreak;\r\ncase E_LIST:\r\nfn(data, e->right.sym, e->right.sym->name);\r\nif (e->left.expr) {\r\nfn(data, NULL, " ^ ");\r\nexpr_print(e->left.expr, fn, data, E_LIST);\r\n}\r\nbreak;\r\ncase E_RANGE:\r\nfn(data, NULL, "[");\r\nfn(data, e->left.sym, e->left.sym->name);\r\nfn(data, NULL, " ");\r\nfn(data, e->right.sym, e->right.sym->name);\r\nfn(data, NULL, "]");\r\nbreak;\r\ndefault:\r\n{\r\nchar buf[32];\r\nsprintf(buf, "<unknown type %d>", e->type);\r\nfn(data, NULL, buf);\r\nbreak;\r\n}\r\n}\r\nif (expr_compare_type(prevtoken, e->type) > 0)\r\nfn(data, NULL, ")");\r\n}\r\nstatic void expr_print_file_helper(void *data, struct symbol *sym, const char *str)\r\n{\r\nxfwrite(str, strlen(str), 1, data);\r\n}\r\nvoid expr_fprint(struct expr *e, FILE *out)\r\n{\r\nexpr_print(e, expr_print_file_helper, out, E_NONE);\r\n}\r\nstatic void expr_print_gstr_helper(void *data, struct symbol *sym, const char *str)\r\n{\r\nstruct gstr *gs = (struct gstr*)data;\r\nconst char *sym_str = NULL;\r\nif (sym)\r\nsym_str = sym_get_string_value(sym);\r\nif (gs->max_width) {\r\nunsigned extra_length = strlen(str);\r\nconst char *last_cr = strrchr(gs->s, '\n');\r\nunsigned last_line_length;\r\nif (sym_str)\r\nextra_length += 4 + strlen(sym_str);\r\nif (!last_cr)\r\nlast_cr = gs->s;\r\nlast_line_length = strlen(gs->s) - (last_cr - gs->s);\r\nif ((last_line_length + extra_length) > gs->max_width)\r\nstr_append(gs, "\\\n");\r\n}\r\nstr_append(gs, str);\r\nif (sym && sym->type != S_UNKNOWN)\r\nstr_printf(gs, " [=%s]", sym_str);\r\n}\r\nvoid expr_gstr_print(struct expr *e, struct gstr *gs)\r\n{\r\nexpr_print(e, expr_print_gstr_helper, gs, E_NONE);\r\n}
