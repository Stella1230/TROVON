static void transient_timer_function(unsigned long data)\r\n{\r\nstruct led_classdev *led_cdev = (struct led_classdev *) data;\r\nstruct transient_trig_data *transient_data = led_cdev->trigger_data;\r\ntransient_data->activate = 0;\r\nled_set_brightness_nosleep(led_cdev, transient_data->restore_state);\r\n}\r\nstatic ssize_t transient_activate_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct led_classdev *led_cdev = dev_get_drvdata(dev);\r\nstruct transient_trig_data *transient_data = led_cdev->trigger_data;\r\nreturn sprintf(buf, "%d\n", transient_data->activate);\r\n}\r\nstatic ssize_t transient_activate_store(struct device *dev,\r\nstruct device_attribute *attr, const char *buf, size_t size)\r\n{\r\nstruct led_classdev *led_cdev = dev_get_drvdata(dev);\r\nstruct transient_trig_data *transient_data = led_cdev->trigger_data;\r\nunsigned long state;\r\nssize_t ret;\r\nret = kstrtoul(buf, 10, &state);\r\nif (ret)\r\nreturn ret;\r\nif (state != 1 && state != 0)\r\nreturn -EINVAL;\r\nif (state == 0 && transient_data->activate == 1) {\r\ndel_timer(&transient_data->timer);\r\ntransient_data->activate = state;\r\nled_set_brightness_nosleep(led_cdev,\r\ntransient_data->restore_state);\r\nreturn size;\r\n}\r\nif (state == 1 && transient_data->activate == 0 &&\r\ntransient_data->duration != 0) {\r\ntransient_data->activate = state;\r\nled_set_brightness_nosleep(led_cdev, transient_data->state);\r\ntransient_data->restore_state =\r\n(transient_data->state == LED_FULL) ? LED_OFF : LED_FULL;\r\nmod_timer(&transient_data->timer,\r\njiffies + msecs_to_jiffies(transient_data->duration));\r\n}\r\nreturn size;\r\n}\r\nstatic ssize_t transient_duration_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct led_classdev *led_cdev = dev_get_drvdata(dev);\r\nstruct transient_trig_data *transient_data = led_cdev->trigger_data;\r\nreturn sprintf(buf, "%lu\n", transient_data->duration);\r\n}\r\nstatic ssize_t transient_duration_store(struct device *dev,\r\nstruct device_attribute *attr, const char *buf, size_t size)\r\n{\r\nstruct led_classdev *led_cdev = dev_get_drvdata(dev);\r\nstruct transient_trig_data *transient_data = led_cdev->trigger_data;\r\nunsigned long state;\r\nssize_t ret;\r\nret = kstrtoul(buf, 10, &state);\r\nif (ret)\r\nreturn ret;\r\ntransient_data->duration = state;\r\nreturn size;\r\n}\r\nstatic ssize_t transient_state_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct led_classdev *led_cdev = dev_get_drvdata(dev);\r\nstruct transient_trig_data *transient_data = led_cdev->trigger_data;\r\nint state;\r\nstate = (transient_data->state == LED_FULL) ? 1 : 0;\r\nreturn sprintf(buf, "%d\n", state);\r\n}\r\nstatic ssize_t transient_state_store(struct device *dev,\r\nstruct device_attribute *attr, const char *buf, size_t size)\r\n{\r\nstruct led_classdev *led_cdev = dev_get_drvdata(dev);\r\nstruct transient_trig_data *transient_data = led_cdev->trigger_data;\r\nunsigned long state;\r\nssize_t ret;\r\nret = kstrtoul(buf, 10, &state);\r\nif (ret)\r\nreturn ret;\r\nif (state != 1 && state != 0)\r\nreturn -EINVAL;\r\ntransient_data->state = (state == 1) ? LED_FULL : LED_OFF;\r\nreturn size;\r\n}\r\nstatic void transient_trig_activate(struct led_classdev *led_cdev)\r\n{\r\nint rc;\r\nstruct transient_trig_data *tdata;\r\ntdata = kzalloc(sizeof(struct transient_trig_data), GFP_KERNEL);\r\nif (!tdata) {\r\ndev_err(led_cdev->dev,\r\n"unable to allocate transient trigger\n");\r\nreturn;\r\n}\r\nled_cdev->trigger_data = tdata;\r\nrc = device_create_file(led_cdev->dev, &dev_attr_activate);\r\nif (rc)\r\ngoto err_out;\r\nrc = device_create_file(led_cdev->dev, &dev_attr_duration);\r\nif (rc)\r\ngoto err_out_duration;\r\nrc = device_create_file(led_cdev->dev, &dev_attr_state);\r\nif (rc)\r\ngoto err_out_state;\r\nsetup_timer(&tdata->timer, transient_timer_function,\r\n(unsigned long) led_cdev);\r\nled_cdev->activated = true;\r\nreturn;\r\nerr_out_state:\r\ndevice_remove_file(led_cdev->dev, &dev_attr_duration);\r\nerr_out_duration:\r\ndevice_remove_file(led_cdev->dev, &dev_attr_activate);\r\nerr_out:\r\ndev_err(led_cdev->dev, "unable to register transient trigger\n");\r\nled_cdev->trigger_data = NULL;\r\nkfree(tdata);\r\n}\r\nstatic void transient_trig_deactivate(struct led_classdev *led_cdev)\r\n{\r\nstruct transient_trig_data *transient_data = led_cdev->trigger_data;\r\nif (led_cdev->activated) {\r\ndel_timer_sync(&transient_data->timer);\r\nled_set_brightness_nosleep(led_cdev,\r\ntransient_data->restore_state);\r\ndevice_remove_file(led_cdev->dev, &dev_attr_activate);\r\ndevice_remove_file(led_cdev->dev, &dev_attr_duration);\r\ndevice_remove_file(led_cdev->dev, &dev_attr_state);\r\nled_cdev->trigger_data = NULL;\r\nled_cdev->activated = false;\r\nkfree(transient_data);\r\n}\r\n}\r\nstatic int __init transient_trig_init(void)\r\n{\r\nreturn led_trigger_register(&transient_trigger);\r\n}\r\nstatic void __exit transient_trig_exit(void)\r\n{\r\nled_trigger_unregister(&transient_trigger);\r\n}
