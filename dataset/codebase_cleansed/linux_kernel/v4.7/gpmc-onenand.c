static void omap2_onenand_calc_async_timings(struct gpmc_timings *t)\r\n{\r\nstruct gpmc_device_timings dev_t;\r\nconst int t_cer = 15;\r\nconst int t_avdp = 12;\r\nconst int t_aavdh = 7;\r\nconst int t_ce = 76;\r\nconst int t_aa = 76;\r\nconst int t_oe = 20;\r\nconst int t_cez = 20;\r\nconst int t_wpl = 40;\r\nconst int t_wph = 30;\r\nmemset(&dev_t, 0, sizeof(dev_t));\r\ndev_t.t_avdp_r = max_t(int, t_avdp, t_cer) * 1000;\r\ndev_t.t_avdp_w = dev_t.t_avdp_r;\r\ndev_t.t_aavdh = t_aavdh * 1000;\r\ndev_t.t_aa = t_aa * 1000;\r\ndev_t.t_ce = t_ce * 1000;\r\ndev_t.t_oe = t_oe * 1000;\r\ndev_t.t_cez_r = t_cez * 1000;\r\ndev_t.t_cez_w = dev_t.t_cez_r;\r\ndev_t.t_wpl = t_wpl * 1000;\r\ndev_t.t_wph = t_wph * 1000;\r\ngpmc_calc_timings(t, &onenand_async, &dev_t);\r\n}\r\nstatic void omap2_onenand_set_async_mode(void __iomem *onenand_base)\r\n{\r\nu32 reg;\r\nreg = readw(onenand_base + ONENAND_REG_SYS_CFG1);\r\nreg &= ~ONENAND_SYS_CFG1_SYNC_READ & ~ONENAND_SYS_CFG1_SYNC_WRITE;\r\nwritew(reg, onenand_base + ONENAND_REG_SYS_CFG1);\r\n}\r\nstatic void set_onenand_cfg(void __iomem *onenand_base)\r\n{\r\nu32 reg = ONENAND_SYS_CFG1_RDY | ONENAND_SYS_CFG1_INT;\r\nreg |= (latency << ONENAND_SYS_CFG1_BRL_SHIFT) |\r\nONENAND_SYS_CFG1_BL_16;\r\nif (onenand_flags & ONENAND_FLAG_SYNCREAD)\r\nreg |= ONENAND_SYS_CFG1_SYNC_READ;\r\nelse\r\nreg &= ~ONENAND_SYS_CFG1_SYNC_READ;\r\nif (onenand_flags & ONENAND_FLAG_SYNCWRITE)\r\nreg |= ONENAND_SYS_CFG1_SYNC_WRITE;\r\nelse\r\nreg &= ~ONENAND_SYS_CFG1_SYNC_WRITE;\r\nif (onenand_flags & ONENAND_FLAG_HF)\r\nreg |= ONENAND_SYS_CFG1_HF;\r\nelse\r\nreg &= ~ONENAND_SYS_CFG1_HF;\r\nif (onenand_flags & ONENAND_FLAG_VHF)\r\nreg |= ONENAND_SYS_CFG1_VHF;\r\nelse\r\nreg &= ~ONENAND_SYS_CFG1_VHF;\r\nwritew(reg, onenand_base + ONENAND_REG_SYS_CFG1);\r\n}\r\nstatic int omap2_onenand_get_freq(struct omap_onenand_platform_data *cfg,\r\nvoid __iomem *onenand_base)\r\n{\r\nu16 ver = readw(onenand_base + ONENAND_REG_VERSION_ID);\r\nint freq;\r\nswitch ((ver >> 4) & 0xf) {\r\ncase 0:\r\nfreq = 40;\r\nbreak;\r\ncase 1:\r\nfreq = 54;\r\nbreak;\r\ncase 2:\r\nfreq = 66;\r\nbreak;\r\ncase 3:\r\nfreq = 83;\r\nbreak;\r\ncase 4:\r\nfreq = 104;\r\nbreak;\r\ndefault:\r\npr_err("onenand rate not detected, bad GPMC async timings?\n");\r\nfreq = 0;\r\n}\r\nreturn freq;\r\n}\r\nstatic void omap2_onenand_calc_sync_timings(struct gpmc_timings *t,\r\nunsigned int flags,\r\nint freq)\r\n{\r\nstruct gpmc_device_timings dev_t;\r\nconst int t_cer = 15;\r\nconst int t_avdp = 12;\r\nconst int t_cez = 20;\r\nconst int t_wpl = 40;\r\nconst int t_wph = 30;\r\nint min_gpmc_clk_period, t_ces, t_avds, t_avdh, t_ach, t_aavdh, t_rdyo;\r\nint div, gpmc_clk_ns;\r\nif (flags & ONENAND_SYNC_READ)\r\nonenand_flags = ONENAND_FLAG_SYNCREAD;\r\nelse if (flags & ONENAND_SYNC_READWRITE)\r\nonenand_flags = ONENAND_FLAG_SYNCREAD | ONENAND_FLAG_SYNCWRITE;\r\nswitch (freq) {\r\ncase 104:\r\nmin_gpmc_clk_period = 9600;\r\nt_ces = 3;\r\nt_avds = 4;\r\nt_avdh = 2;\r\nt_ach = 3;\r\nt_aavdh = 6;\r\nt_rdyo = 6;\r\nbreak;\r\ncase 83:\r\nmin_gpmc_clk_period = 12000;\r\nt_ces = 5;\r\nt_avds = 4;\r\nt_avdh = 2;\r\nt_ach = 6;\r\nt_aavdh = 6;\r\nt_rdyo = 9;\r\nbreak;\r\ncase 66:\r\nmin_gpmc_clk_period = 15000;\r\nt_ces = 6;\r\nt_avds = 5;\r\nt_avdh = 2;\r\nt_ach = 6;\r\nt_aavdh = 6;\r\nt_rdyo = 11;\r\nbreak;\r\ndefault:\r\nmin_gpmc_clk_period = 18500;\r\nt_ces = 7;\r\nt_avds = 7;\r\nt_avdh = 7;\r\nt_ach = 9;\r\nt_aavdh = 7;\r\nt_rdyo = 15;\r\nonenand_flags &= ~ONENAND_FLAG_SYNCWRITE;\r\nbreak;\r\n}\r\ndiv = gpmc_calc_divider(min_gpmc_clk_period);\r\ngpmc_clk_ns = gpmc_ticks_to_ns(div);\r\nif (gpmc_clk_ns < 15)\r\nonenand_flags |= ONENAND_FLAG_HF;\r\nelse\r\nonenand_flags &= ~ONENAND_FLAG_HF;\r\nif (gpmc_clk_ns < 12)\r\nonenand_flags |= ONENAND_FLAG_VHF;\r\nelse\r\nonenand_flags &= ~ONENAND_FLAG_VHF;\r\nif (onenand_flags & ONENAND_FLAG_VHF)\r\nlatency = 8;\r\nelse if (onenand_flags & ONENAND_FLAG_HF)\r\nlatency = 6;\r\nelse if (gpmc_clk_ns >= 25)\r\nlatency = 3;\r\nelse\r\nlatency = 4;\r\nmemset(&dev_t, 0, sizeof(dev_t));\r\nif (onenand_flags & ONENAND_FLAG_SYNCREAD)\r\nonenand_sync.sync_read = true;\r\nif (onenand_flags & ONENAND_FLAG_SYNCWRITE) {\r\nonenand_sync.sync_write = true;\r\nonenand_sync.burst_write = true;\r\n} else {\r\ndev_t.t_avdp_w = max(t_avdp, t_cer) * 1000;\r\ndev_t.t_wpl = t_wpl * 1000;\r\ndev_t.t_wph = t_wph * 1000;\r\ndev_t.t_aavdh = t_aavdh * 1000;\r\n}\r\ndev_t.ce_xdelay = true;\r\ndev_t.avd_xdelay = true;\r\ndev_t.oe_xdelay = true;\r\ndev_t.we_xdelay = true;\r\ndev_t.clk = min_gpmc_clk_period;\r\ndev_t.t_bacc = dev_t.clk;\r\ndev_t.t_ces = t_ces * 1000;\r\ndev_t.t_avds = t_avds * 1000;\r\ndev_t.t_avdh = t_avdh * 1000;\r\ndev_t.t_ach = t_ach * 1000;\r\ndev_t.cyc_iaa = (latency + 1);\r\ndev_t.t_cez_r = t_cez * 1000;\r\ndev_t.t_cez_w = dev_t.t_cez_r;\r\ndev_t.cyc_aavdh_oe = 1;\r\ndev_t.t_rdyo = t_rdyo * 1000 + min_gpmc_clk_period;\r\ngpmc_calc_timings(t, &onenand_sync, &dev_t);\r\n}\r\nstatic int omap2_onenand_setup_async(void __iomem *onenand_base)\r\n{\r\nstruct gpmc_timings t;\r\nint ret;\r\nif (gpmc_onenand_data->of_node) {\r\ngpmc_read_settings_dt(gpmc_onenand_data->of_node,\r\n&onenand_async);\r\nif (onenand_async.sync_read || onenand_async.sync_write) {\r\nif (onenand_async.sync_write)\r\ngpmc_onenand_data->flags |=\r\nONENAND_SYNC_READWRITE;\r\nelse\r\ngpmc_onenand_data->flags |= ONENAND_SYNC_READ;\r\nonenand_async.sync_read = false;\r\n}\r\n}\r\nonenand_async.sync_write = true;\r\nomap2_onenand_calc_async_timings(&t);\r\nret = gpmc_cs_program_settings(gpmc_onenand_data->cs, &onenand_async);\r\nif (ret < 0)\r\nreturn ret;\r\nret = gpmc_cs_set_timings(gpmc_onenand_data->cs, &t, &onenand_async);\r\nif (ret < 0)\r\nreturn ret;\r\nomap2_onenand_set_async_mode(onenand_base);\r\nreturn 0;\r\n}\r\nstatic int omap2_onenand_setup_sync(void __iomem *onenand_base, int *freq_ptr)\r\n{\r\nint ret, freq = *freq_ptr;\r\nstruct gpmc_timings t;\r\nif (!freq) {\r\nfreq = omap2_onenand_get_freq(gpmc_onenand_data, onenand_base);\r\nif (!freq)\r\nreturn -ENODEV;\r\nset_onenand_cfg(onenand_base);\r\n}\r\nif (gpmc_onenand_data->of_node) {\r\ngpmc_read_settings_dt(gpmc_onenand_data->of_node,\r\n&onenand_sync);\r\n} else {\r\nif (!cpu_is_omap34xx())\r\nonenand_sync.wait_on_read = true;\r\n}\r\nomap2_onenand_calc_sync_timings(&t, gpmc_onenand_data->flags, freq);\r\nret = gpmc_cs_program_settings(gpmc_onenand_data->cs, &onenand_sync);\r\nif (ret < 0)\r\nreturn ret;\r\nret = gpmc_cs_set_timings(gpmc_onenand_data->cs, &t, &onenand_sync);\r\nif (ret < 0)\r\nreturn ret;\r\nset_onenand_cfg(onenand_base);\r\n*freq_ptr = freq;\r\nreturn 0;\r\n}\r\nstatic int gpmc_onenand_setup(void __iomem *onenand_base, int *freq_ptr)\r\n{\r\nstruct device *dev = &gpmc_onenand_device.dev;\r\nunsigned l = ONENAND_SYNC_READ | ONENAND_SYNC_READWRITE;\r\nint ret;\r\nret = omap2_onenand_setup_async(onenand_base);\r\nif (ret) {\r\ndev_err(dev, "unable to set to async mode\n");\r\nreturn ret;\r\n}\r\nif (!(gpmc_onenand_data->flags & l))\r\nreturn 0;\r\nret = omap2_onenand_setup_sync(onenand_base, freq_ptr);\r\nif (ret)\r\ndev_err(dev, "unable to set to sync mode\n");\r\nreturn ret;\r\n}\r\nvoid gpmc_onenand_init(struct omap_onenand_platform_data *_onenand_data)\r\n{\r\nint err;\r\nstruct device *dev = &gpmc_onenand_device.dev;\r\ngpmc_onenand_data = _onenand_data;\r\ngpmc_onenand_data->onenand_setup = gpmc_onenand_setup;\r\ngpmc_onenand_device.dev.platform_data = gpmc_onenand_data;\r\nif (cpu_is_omap24xx() &&\r\n(gpmc_onenand_data->flags & ONENAND_SYNC_READWRITE)) {\r\ndev_warn(dev, "OneNAND using only SYNC_READ on 24xx\n");\r\ngpmc_onenand_data->flags &= ~ONENAND_SYNC_READWRITE;\r\ngpmc_onenand_data->flags |= ONENAND_SYNC_READ;\r\n}\r\nif (cpu_is_omap34xx())\r\ngpmc_onenand_data->flags |= ONENAND_IN_OMAP34XX;\r\nelse\r\ngpmc_onenand_data->flags &= ~ONENAND_IN_OMAP34XX;\r\nerr = gpmc_cs_request(gpmc_onenand_data->cs, ONENAND_IO_SIZE,\r\n(unsigned long *)&gpmc_onenand_resource.start);\r\nif (err < 0) {\r\ndev_err(dev, "Cannot request GPMC CS %d, error %d\n",\r\ngpmc_onenand_data->cs, err);\r\nreturn;\r\n}\r\ngpmc_onenand_resource.end = gpmc_onenand_resource.start +\r\nONENAND_IO_SIZE - 1;\r\nif (platform_device_register(&gpmc_onenand_device) < 0) {\r\ndev_err(dev, "Unable to register OneNAND device\n");\r\ngpmc_cs_free(gpmc_onenand_data->cs);\r\nreturn;\r\n}\r\n}
