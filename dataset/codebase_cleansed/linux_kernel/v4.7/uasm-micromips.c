static inline u32 build_bimm(s32 arg)\r\n{\r\nWARN(arg > 0xffff || arg < -0x10000,\r\nKERN_WARNING "Micro-assembler field overflow\n");\r\nWARN(arg & 0x3, KERN_WARNING "Invalid micro-assembler branch target\n");\r\nreturn ((arg < 0) ? (1 << 15) : 0) | ((arg >> 1) & 0x7fff);\r\n}\r\nstatic inline u32 build_jimm(u32 arg)\r\n{\r\nWARN(arg & ~((JIMM_MASK << 2) | 1),\r\nKERN_WARNING "Micro-assembler field overflow\n");\r\nreturn (arg >> 1) & JIMM_MASK;\r\n}\r\nstatic void build_insn(u32 **buf, enum opcode opc, ...)\r\n{\r\nstruct insn *ip = NULL;\r\nunsigned int i;\r\nva_list ap;\r\nu32 op;\r\nfor (i = 0; insn_table_MM[i].opcode != insn_invalid; i++)\r\nif (insn_table_MM[i].opcode == opc) {\r\nip = &insn_table_MM[i];\r\nbreak;\r\n}\r\nif (!ip || (opc == insn_daddiu && r4k_daddiu_bug()))\r\npanic("Unsupported Micro-assembler instruction %d", opc);\r\nop = ip->match;\r\nva_start(ap, opc);\r\nif (ip->fields & RS) {\r\nif (opc == insn_mfc0 || opc == insn_mtc0)\r\nop |= build_rt(va_arg(ap, u32));\r\nelse\r\nop |= build_rs(va_arg(ap, u32));\r\n}\r\nif (ip->fields & RT) {\r\nif (opc == insn_mfc0 || opc == insn_mtc0)\r\nop |= build_rs(va_arg(ap, u32));\r\nelse\r\nop |= build_rt(va_arg(ap, u32));\r\n}\r\nif (ip->fields & RD)\r\nop |= build_rd(va_arg(ap, u32));\r\nif (ip->fields & RE)\r\nop |= build_re(va_arg(ap, u32));\r\nif (ip->fields & SIMM)\r\nop |= build_simm(va_arg(ap, s32));\r\nif (ip->fields & UIMM)\r\nop |= build_uimm(va_arg(ap, u32));\r\nif (ip->fields & BIMM)\r\nop |= build_bimm(va_arg(ap, s32));\r\nif (ip->fields & JIMM)\r\nop |= build_jimm(va_arg(ap, u32));\r\nif (ip->fields & FUNC)\r\nop |= build_func(va_arg(ap, u32));\r\nif (ip->fields & SET)\r\nop |= build_set(va_arg(ap, u32));\r\nif (ip->fields & SCIMM)\r\nop |= build_scimm(va_arg(ap, u32));\r\nva_end(ap);\r\n#ifdef CONFIG_CPU_LITTLE_ENDIAN\r\n**buf = ((op & 0xffff) << 16) | (op >> 16);\r\n#else\r\n**buf = op;\r\n#endif\r\n(*buf)++;\r\n}\r\nstatic inline void\r\n__resolve_relocs(struct uasm_reloc *rel, struct uasm_label *lab)\r\n{\r\nlong laddr = (long)lab->addr;\r\nlong raddr = (long)rel->addr;\r\nswitch (rel->type) {\r\ncase R_MIPS_PC16:\r\n#ifdef CONFIG_CPU_LITTLE_ENDIAN\r\n*rel->addr |= (build_bimm(laddr - (raddr + 4)) << 16);\r\n#else\r\n*rel->addr |= build_bimm(laddr - (raddr + 4));\r\n#endif\r\nbreak;\r\ndefault:\r\npanic("Unsupported Micro-assembler relocation %d",\r\nrel->type);\r\n}\r\n}
