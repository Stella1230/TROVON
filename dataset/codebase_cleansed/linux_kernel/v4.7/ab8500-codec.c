static inline const char *amic_micbias_str(enum amic_micbias micbias)\r\n{\r\nswitch (micbias) {\r\ncase AMIC_MICBIAS_VAMIC1:\r\nreturn "VAMIC1";\r\ncase AMIC_MICBIAS_VAMIC2:\r\nreturn "VAMIC2";\r\ndefault:\r\nreturn "Unknown";\r\n}\r\n}\r\nstatic inline const char *amic_type_str(enum amic_type type)\r\n{\r\nswitch (type) {\r\ncase AMIC_TYPE_DIFFERENTIAL:\r\nreturn "DIFFERENTIAL";\r\ncase AMIC_TYPE_SINGLE_ENDED:\r\nreturn "SINGLE ENDED";\r\ndefault:\r\nreturn "Unknown";\r\n}\r\n}\r\nstatic int ab8500_codec_read_reg(void *context, unsigned int reg,\r\nunsigned int *value)\r\n{\r\nstruct device *dev = context;\r\nint status;\r\nu8 value8;\r\nstatus = abx500_get_register_interruptible(dev, AB8500_AUDIO,\r\nreg, &value8);\r\n*value = (unsigned int)value8;\r\nreturn status;\r\n}\r\nstatic int ab8500_codec_write_reg(void *context, unsigned int reg,\r\nunsigned int value)\r\n{\r\nstruct device *dev = context;\r\nreturn abx500_set_register_interruptible(dev, AB8500_AUDIO,\r\nreg, value);\r\n}\r\nstatic void anc_fir(struct snd_soc_codec *codec,\r\nunsigned int bnk, unsigned int par, unsigned int val)\r\n{\r\nif (par == 0 && bnk == 0)\r\nsnd_soc_update_bits(codec, AB8500_ANCCONF1,\r\nBIT(AB8500_ANCCONF1_ANCFIRUPDATE),\r\nBIT(AB8500_ANCCONF1_ANCFIRUPDATE));\r\nsnd_soc_write(codec, AB8500_ANCCONF5, val >> 8 & 0xff);\r\nsnd_soc_write(codec, AB8500_ANCCONF6, val & 0xff);\r\nif (par == AB8500_ANC_FIR_COEFFS - 1 && bnk == 1)\r\nsnd_soc_update_bits(codec, AB8500_ANCCONF1,\r\nBIT(AB8500_ANCCONF1_ANCFIRUPDATE), 0);\r\n}\r\nstatic void anc_iir(struct snd_soc_codec *codec, unsigned int bnk,\r\nunsigned int par, unsigned int val)\r\n{\r\nif (par == 0) {\r\nif (bnk == 0) {\r\nsnd_soc_update_bits(codec, AB8500_ANCCONF1,\r\nBIT(AB8500_ANCCONF1_ANCIIRINIT),\r\nBIT(AB8500_ANCCONF1_ANCIIRINIT));\r\nusleep_range(AB8500_ANC_SM_DELAY, AB8500_ANC_SM_DELAY);\r\nsnd_soc_update_bits(codec, AB8500_ANCCONF1,\r\nBIT(AB8500_ANCCONF1_ANCIIRINIT), 0);\r\nusleep_range(AB8500_ANC_SM_DELAY, AB8500_ANC_SM_DELAY);\r\n} else {\r\nsnd_soc_update_bits(codec, AB8500_ANCCONF1,\r\nBIT(AB8500_ANCCONF1_ANCIIRUPDATE),\r\nBIT(AB8500_ANCCONF1_ANCIIRUPDATE));\r\n}\r\n} else if (par > 3) {\r\nsnd_soc_write(codec, AB8500_ANCCONF7, 0);\r\nsnd_soc_write(codec, AB8500_ANCCONF8, val >> 16 & 0xff);\r\n}\r\nsnd_soc_write(codec, AB8500_ANCCONF7, val >> 8 & 0xff);\r\nsnd_soc_write(codec, AB8500_ANCCONF8, val & 0xff);\r\nif (par == AB8500_ANC_IIR_COEFFS - 1 && bnk == 1)\r\nsnd_soc_update_bits(codec, AB8500_ANCCONF1,\r\nBIT(AB8500_ANCCONF1_ANCIIRUPDATE), 0);\r\n}\r\nstatic void anc_configure(struct snd_soc_codec *codec,\r\nbool apply_fir, bool apply_iir)\r\n{\r\nstruct ab8500_codec_drvdata *drvdata = dev_get_drvdata(codec->dev);\r\nunsigned int bnk, par, val;\r\ndev_dbg(codec->dev, "%s: Enter.\n", __func__);\r\nif (apply_fir)\r\nsnd_soc_update_bits(codec, AB8500_ANCCONF1,\r\nBIT(AB8500_ANCCONF1_ENANC), 0);\r\nsnd_soc_update_bits(codec, AB8500_ANCCONF1,\r\nBIT(AB8500_ANCCONF1_ENANC), BIT(AB8500_ANCCONF1_ENANC));\r\nif (apply_fir)\r\nfor (bnk = 0; bnk < AB8500_NR_OF_ANC_COEFF_BANKS; bnk++)\r\nfor (par = 0; par < AB8500_ANC_FIR_COEFFS; par++) {\r\nval = snd_soc_read(codec,\r\ndrvdata->anc_fir_values[par]);\r\nanc_fir(codec, bnk, par, val);\r\n}\r\nif (apply_iir)\r\nfor (bnk = 0; bnk < AB8500_NR_OF_ANC_COEFF_BANKS; bnk++)\r\nfor (par = 0; par < AB8500_ANC_IIR_COEFFS; par++) {\r\nval = snd_soc_read(codec,\r\ndrvdata->anc_iir_values[par]);\r\nanc_iir(codec, bnk, par, val);\r\n}\r\ndev_dbg(codec->dev, "%s: Exit.\n", __func__);\r\n}\r\nstatic int sid_status_control_get(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_soc_codec *codec = snd_soc_kcontrol_codec(kcontrol);\r\nstruct ab8500_codec_drvdata *drvdata = dev_get_drvdata(codec->dev);\r\nmutex_lock(&drvdata->ctrl_lock);\r\nucontrol->value.enumerated.item[0] = drvdata->sid_status;\r\nmutex_unlock(&drvdata->ctrl_lock);\r\nreturn 0;\r\n}\r\nstatic int sid_status_control_put(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_soc_codec *codec = snd_soc_kcontrol_codec(kcontrol);\r\nstruct ab8500_codec_drvdata *drvdata = dev_get_drvdata(codec->dev);\r\nunsigned int param, sidconf, val;\r\nint status = 1;\r\ndev_dbg(codec->dev, "%s: Enter\n", __func__);\r\nif (ucontrol->value.enumerated.item[0] != SID_APPLY_FIR) {\r\ndev_err(codec->dev,\r\n"%s: ERROR: This control supports '%s' only!\n",\r\n__func__, enum_sid_state[SID_APPLY_FIR]);\r\nreturn -EIO;\r\n}\r\nmutex_lock(&drvdata->ctrl_lock);\r\nsidconf = snd_soc_read(codec, AB8500_SIDFIRCONF);\r\nif (((sidconf & BIT(AB8500_SIDFIRCONF_FIRSIDBUSY)) != 0)) {\r\nif ((sidconf & BIT(AB8500_SIDFIRCONF_ENFIRSIDS)) == 0) {\r\ndev_err(codec->dev, "%s: Sidetone busy while off!\n",\r\n__func__);\r\nstatus = -EPERM;\r\n} else {\r\nstatus = -EBUSY;\r\n}\r\ngoto out;\r\n}\r\nsnd_soc_write(codec, AB8500_SIDFIRADR, 0);\r\nfor (param = 0; param < AB8500_SID_FIR_COEFFS; param++) {\r\nval = snd_soc_read(codec, drvdata->sid_fir_values[param]);\r\nsnd_soc_write(codec, AB8500_SIDFIRCOEF1, val >> 8 & 0xff);\r\nsnd_soc_write(codec, AB8500_SIDFIRCOEF2, val & 0xff);\r\n}\r\nsnd_soc_update_bits(codec, AB8500_SIDFIRADR,\r\nBIT(AB8500_SIDFIRADR_FIRSIDSET),\r\nBIT(AB8500_SIDFIRADR_FIRSIDSET));\r\nsnd_soc_update_bits(codec, AB8500_SIDFIRADR,\r\nBIT(AB8500_SIDFIRADR_FIRSIDSET), 0);\r\ndrvdata->sid_status = SID_FIR_CONFIGURED;\r\nout:\r\nmutex_unlock(&drvdata->ctrl_lock);\r\ndev_dbg(codec->dev, "%s: Exit\n", __func__);\r\nreturn status;\r\n}\r\nstatic int anc_status_control_get(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_soc_codec *codec = snd_soc_kcontrol_codec(kcontrol);\r\nstruct ab8500_codec_drvdata *drvdata = dev_get_drvdata(codec->dev);\r\nmutex_lock(&drvdata->ctrl_lock);\r\nucontrol->value.enumerated.item[0] = drvdata->anc_status;\r\nmutex_unlock(&drvdata->ctrl_lock);\r\nreturn 0;\r\n}\r\nstatic int anc_status_control_put(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_soc_codec *codec = snd_soc_kcontrol_codec(kcontrol);\r\nstruct snd_soc_dapm_context *dapm = snd_soc_codec_get_dapm(codec);\r\nstruct ab8500_codec_drvdata *drvdata = dev_get_drvdata(codec->dev);\r\nstruct device *dev = codec->dev;\r\nbool apply_fir, apply_iir;\r\nunsigned int req;\r\nint status;\r\ndev_dbg(dev, "%s: Enter.\n", __func__);\r\nmutex_lock(&drvdata->ctrl_lock);\r\nreq = ucontrol->value.enumerated.item[0];\r\nif (req >= ARRAY_SIZE(enum_anc_state)) {\r\nstatus = -EINVAL;\r\ngoto cleanup;\r\n}\r\nif (req != ANC_APPLY_FIR_IIR && req != ANC_APPLY_FIR &&\r\nreq != ANC_APPLY_IIR) {\r\ndev_err(dev, "%s: ERROR: Unsupported status to set '%s'!\n",\r\n__func__, enum_anc_state[req]);\r\nstatus = -EINVAL;\r\ngoto cleanup;\r\n}\r\napply_fir = req == ANC_APPLY_FIR || req == ANC_APPLY_FIR_IIR;\r\napply_iir = req == ANC_APPLY_IIR || req == ANC_APPLY_FIR_IIR;\r\nstatus = snd_soc_dapm_force_enable_pin(dapm, "ANC Configure Input");\r\nif (status < 0) {\r\ndev_err(dev,\r\n"%s: ERROR: Failed to enable power (status = %d)!\n",\r\n__func__, status);\r\ngoto cleanup;\r\n}\r\nsnd_soc_dapm_sync(dapm);\r\nanc_configure(codec, apply_fir, apply_iir);\r\nif (apply_fir) {\r\nif (drvdata->anc_status == ANC_IIR_CONFIGURED)\r\ndrvdata->anc_status = ANC_FIR_IIR_CONFIGURED;\r\nelse if (drvdata->anc_status != ANC_FIR_IIR_CONFIGURED)\r\ndrvdata->anc_status = ANC_FIR_CONFIGURED;\r\n}\r\nif (apply_iir) {\r\nif (drvdata->anc_status == ANC_FIR_CONFIGURED)\r\ndrvdata->anc_status = ANC_FIR_IIR_CONFIGURED;\r\nelse if (drvdata->anc_status != ANC_FIR_IIR_CONFIGURED)\r\ndrvdata->anc_status = ANC_IIR_CONFIGURED;\r\n}\r\nstatus = snd_soc_dapm_disable_pin(dapm, "ANC Configure Input");\r\nsnd_soc_dapm_sync(dapm);\r\ncleanup:\r\nmutex_unlock(&drvdata->ctrl_lock);\r\nif (status < 0)\r\ndev_err(dev, "%s: Unable to configure ANC! (status = %d)\n",\r\n__func__, status);\r\ndev_dbg(dev, "%s: Exit.\n", __func__);\r\nreturn (status < 0) ? status : 1;\r\n}\r\nstatic int filter_control_info(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_info *uinfo)\r\n{\r\nstruct filter_control *fc =\r\n(struct filter_control *)kcontrol->private_value;\r\nuinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;\r\nuinfo->count = fc->count;\r\nuinfo->value.integer.min = fc->min;\r\nuinfo->value.integer.max = fc->max;\r\nreturn 0;\r\n}\r\nstatic int filter_control_get(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_soc_codec *codec = snd_soc_kcontrol_codec(kcontrol);\r\nstruct ab8500_codec_drvdata *drvdata = snd_soc_codec_get_drvdata(codec);\r\nstruct filter_control *fc =\r\n(struct filter_control *)kcontrol->private_value;\r\nunsigned int i;\r\nmutex_lock(&drvdata->ctrl_lock);\r\nfor (i = 0; i < fc->count; i++)\r\nucontrol->value.integer.value[i] = fc->value[i];\r\nmutex_unlock(&drvdata->ctrl_lock);\r\nreturn 0;\r\n}\r\nstatic int filter_control_put(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_soc_codec *codec = snd_soc_kcontrol_codec(kcontrol);\r\nstruct ab8500_codec_drvdata *drvdata = snd_soc_codec_get_drvdata(codec);\r\nstruct filter_control *fc =\r\n(struct filter_control *)kcontrol->private_value;\r\nunsigned int i;\r\nmutex_lock(&drvdata->ctrl_lock);\r\nfor (i = 0; i < fc->count; i++)\r\nfc->value[i] = ucontrol->value.integer.value[i];\r\nmutex_unlock(&drvdata->ctrl_lock);\r\nreturn 0;\r\n}\r\nstatic int ab8500_audio_init_audioblock(struct snd_soc_codec *codec)\r\n{\r\nint status;\r\ndev_dbg(codec->dev, "%s: Enter.\n", __func__);\r\nstatus = ab8500_sysctrl_write(AB8500_STW4500CTRL3,\r\nAB8500_STW4500CTRL3_CLK32KOUT2DIS |\r\nAB8500_STW4500CTRL3_RESETAUDN,\r\nAB8500_STW4500CTRL3_RESETAUDN);\r\nif (status < 0)\r\nreturn status;\r\nreturn 0;\r\n}\r\nstatic int ab8500_audio_setup_mics(struct snd_soc_codec *codec,\r\nstruct amic_settings *amics)\r\n{\r\nstruct snd_soc_dapm_context *dapm = snd_soc_codec_get_dapm(codec);\r\nu8 value8;\r\nunsigned int value;\r\nint status;\r\nconst struct snd_soc_dapm_route *route;\r\ndev_dbg(codec->dev, "%s: Enter.\n", __func__);\r\nstatus = abx500_get_register_interruptible(codec->dev, AB8500_MISC,\r\nAB8500_GPIO_DIR4_REG,\r\n&value8);\r\nif (status < 0)\r\nreturn status;\r\nvalue = value8 | GPIO27_DIR_OUTPUT | GPIO29_DIR_OUTPUT |\r\nGPIO31_DIR_OUTPUT;\r\nstatus = abx500_set_register_interruptible(codec->dev,\r\nAB8500_MISC,\r\nAB8500_GPIO_DIR4_REG,\r\nvalue);\r\nif (status < 0)\r\nreturn status;\r\ndev_dbg(codec->dev, "%s: Mic 1a regulator: %s\n", __func__,\r\namic_micbias_str(amics->mic1a_micbias));\r\nroute = &ab8500_dapm_routes_mic1a_vamicx[amics->mic1a_micbias];\r\nstatus = snd_soc_dapm_add_routes(dapm, route, 1);\r\ndev_dbg(codec->dev, "%s: Mic 1b regulator: %s\n", __func__,\r\namic_micbias_str(amics->mic1b_micbias));\r\nroute = &ab8500_dapm_routes_mic1b_vamicx[amics->mic1b_micbias];\r\nstatus |= snd_soc_dapm_add_routes(dapm, route, 1);\r\ndev_dbg(codec->dev, "%s: Mic 2 regulator: %s\n", __func__,\r\namic_micbias_str(amics->mic2_micbias));\r\nroute = &ab8500_dapm_routes_mic2_vamicx[amics->mic2_micbias];\r\nstatus |= snd_soc_dapm_add_routes(dapm, route, 1);\r\nif (status < 0) {\r\ndev_err(codec->dev,\r\n"%s: Failed to add AMic-regulator DAPM-routes (%d).\n",\r\n__func__, status);\r\nreturn status;\r\n}\r\ndev_dbg(codec->dev, "%s: Mic 1 mic-type: %s\n", __func__,\r\namic_type_str(amics->mic1_type));\r\nsnd_soc_update_bits(codec, AB8500_ANAGAIN1, AB8500_ANAGAINX_ENSEMICX,\r\namics->mic1_type == AMIC_TYPE_DIFFERENTIAL ?\r\n0 : AB8500_ANAGAINX_ENSEMICX);\r\ndev_dbg(codec->dev, "%s: Mic 2 mic-type: %s\n", __func__,\r\namic_type_str(amics->mic2_type));\r\nsnd_soc_update_bits(codec, AB8500_ANAGAIN2, AB8500_ANAGAINX_ENSEMICX,\r\namics->mic2_type == AMIC_TYPE_DIFFERENTIAL ?\r\n0 : AB8500_ANAGAINX_ENSEMICX);\r\nreturn 0;\r\n}\r\nstatic int ab8500_audio_set_ear_cmv(struct snd_soc_codec *codec,\r\nenum ear_cm_voltage ear_cmv)\r\n{\r\nchar *cmv_str;\r\nswitch (ear_cmv) {\r\ncase EAR_CMV_0_95V:\r\ncmv_str = "0.95V";\r\nbreak;\r\ncase EAR_CMV_1_10V:\r\ncmv_str = "1.10V";\r\nbreak;\r\ncase EAR_CMV_1_27V:\r\ncmv_str = "1.27V";\r\nbreak;\r\ncase EAR_CMV_1_58V:\r\ncmv_str = "1.58V";\r\nbreak;\r\ndefault:\r\ndev_err(codec->dev,\r\n"%s: Unknown earpiece CM-voltage (%d)!\n",\r\n__func__, (int)ear_cmv);\r\nreturn -EINVAL;\r\n}\r\ndev_dbg(codec->dev, "%s: Earpiece CM-voltage: %s\n", __func__,\r\ncmv_str);\r\nsnd_soc_update_bits(codec, AB8500_ANACONF1, AB8500_ANACONF1_EARSELCM,\r\near_cmv);\r\nreturn 0;\r\n}\r\nstatic int ab8500_audio_set_bit_delay(struct snd_soc_dai *dai,\r\nunsigned int delay)\r\n{\r\nunsigned int mask, val;\r\nstruct snd_soc_codec *codec = dai->codec;\r\nmask = BIT(AB8500_DIGIFCONF2_IF0DEL);\r\nval = 0;\r\nswitch (delay) {\r\ncase 0:\r\nbreak;\r\ncase 1:\r\nval |= BIT(AB8500_DIGIFCONF2_IF0DEL);\r\nbreak;\r\ndefault:\r\ndev_err(dai->codec->dev,\r\n"%s: ERROR: Unsupported bit-delay (0x%x)!\n",\r\n__func__, delay);\r\nreturn -EINVAL;\r\n}\r\ndev_dbg(dai->codec->dev, "%s: IF0 Bit-delay: %d bits.\n",\r\n__func__, delay);\r\nsnd_soc_update_bits(codec, AB8500_DIGIFCONF2, mask, val);\r\nreturn 0;\r\n}\r\nstatic int ab8500_codec_set_dai_clock_gate(struct snd_soc_codec *codec,\r\nunsigned int fmt)\r\n{\r\nunsigned int mask;\r\nunsigned int val;\r\nmask = BIT(AB8500_DIGIFCONF1_ENMASTGEN) |\r\nBIT(AB8500_DIGIFCONF1_ENFSBITCLK0);\r\nval = BIT(AB8500_DIGIFCONF1_ENMASTGEN);\r\nswitch (fmt & SND_SOC_DAIFMT_CLOCK_MASK) {\r\ncase SND_SOC_DAIFMT_CONT:\r\ndev_dbg(codec->dev, "%s: IF0 Clock is continuous.\n",\r\n__func__);\r\nval |= BIT(AB8500_DIGIFCONF1_ENFSBITCLK0);\r\nbreak;\r\ncase SND_SOC_DAIFMT_GATED:\r\ndev_dbg(codec->dev, "%s: IF0 Clock is gated.\n",\r\n__func__);\r\nbreak;\r\ndefault:\r\ndev_err(codec->dev,\r\n"%s: ERROR: Unsupported clock mask (0x%x)!\n",\r\n__func__, fmt & SND_SOC_DAIFMT_CLOCK_MASK);\r\nreturn -EINVAL;\r\n}\r\nsnd_soc_update_bits(codec, AB8500_DIGIFCONF1, mask, val);\r\nreturn 0;\r\n}\r\nstatic int ab8500_codec_set_dai_fmt(struct snd_soc_dai *dai, unsigned int fmt)\r\n{\r\nunsigned int mask;\r\nunsigned int val;\r\nstruct snd_soc_codec *codec = dai->codec;\r\nint status;\r\ndev_dbg(codec->dev, "%s: Enter (fmt = 0x%x)\n", __func__, fmt);\r\nmask = BIT(AB8500_DIGIFCONF3_IF1DATOIF0AD) |\r\nBIT(AB8500_DIGIFCONF3_IF1CLKTOIF0CLK) |\r\nBIT(AB8500_DIGIFCONF3_IF0BFIFOEN) |\r\nBIT(AB8500_DIGIFCONF3_IF0MASTER);\r\nval = 0;\r\nswitch (fmt & SND_SOC_DAIFMT_MASTER_MASK) {\r\ncase SND_SOC_DAIFMT_CBM_CFM:\r\ndev_dbg(dai->codec->dev,\r\n"%s: IF0 Master-mode: AB8500 master.\n", __func__);\r\nval |= BIT(AB8500_DIGIFCONF3_IF0MASTER);\r\nbreak;\r\ncase SND_SOC_DAIFMT_CBS_CFS:\r\ndev_dbg(dai->codec->dev,\r\n"%s: IF0 Master-mode: AB8500 slave.\n", __func__);\r\nbreak;\r\ncase SND_SOC_DAIFMT_CBS_CFM:\r\ncase SND_SOC_DAIFMT_CBM_CFS:\r\ndev_err(dai->codec->dev,\r\n"%s: ERROR: The device is either a master or a slave.\n",\r\n__func__);\r\ndefault:\r\ndev_err(dai->codec->dev,\r\n"%s: ERROR: Unsupporter master mask 0x%x\n",\r\n__func__, fmt & SND_SOC_DAIFMT_MASTER_MASK);\r\nreturn -EINVAL;\r\n}\r\nsnd_soc_update_bits(codec, AB8500_DIGIFCONF3, mask, val);\r\nstatus = ab8500_codec_set_dai_clock_gate(codec, fmt);\r\nif (status) {\r\ndev_err(dai->codec->dev,\r\n"%s: ERROR: Failed to set clock gate (%d).\n",\r\n__func__, status);\r\nreturn status;\r\n}\r\nmask = BIT(AB8500_DIGIFCONF2_IF0FORMAT0) |\r\nBIT(AB8500_DIGIFCONF2_IF0FORMAT1) |\r\nBIT(AB8500_DIGIFCONF2_FSYNC0P) |\r\nBIT(AB8500_DIGIFCONF2_BITCLK0P);\r\nval = 0;\r\nswitch (fmt & SND_SOC_DAIFMT_FORMAT_MASK) {\r\ncase SND_SOC_DAIFMT_I2S:\r\ndev_dbg(dai->codec->dev, "%s: IF0 Protocol: I2S\n", __func__);\r\nval |= BIT(AB8500_DIGIFCONF2_IF0FORMAT1);\r\nab8500_audio_set_bit_delay(dai, 0);\r\nbreak;\r\ncase SND_SOC_DAIFMT_DSP_A:\r\ndev_dbg(dai->codec->dev,\r\n"%s: IF0 Protocol: DSP A (TDM)\n", __func__);\r\nval |= BIT(AB8500_DIGIFCONF2_IF0FORMAT0);\r\nab8500_audio_set_bit_delay(dai, 1);\r\nbreak;\r\ncase SND_SOC_DAIFMT_DSP_B:\r\ndev_dbg(dai->codec->dev,\r\n"%s: IF0 Protocol: DSP B (TDM)\n", __func__);\r\nval |= BIT(AB8500_DIGIFCONF2_IF0FORMAT0);\r\nab8500_audio_set_bit_delay(dai, 0);\r\nbreak;\r\ndefault:\r\ndev_err(dai->codec->dev,\r\n"%s: ERROR: Unsupported format (0x%x)!\n",\r\n__func__, fmt & SND_SOC_DAIFMT_FORMAT_MASK);\r\nreturn -EINVAL;\r\n}\r\nswitch (fmt & SND_SOC_DAIFMT_INV_MASK) {\r\ncase SND_SOC_DAIFMT_NB_NF:\r\ndev_dbg(dai->codec->dev,\r\n"%s: IF0: Normal bit clock, normal frame\n",\r\n__func__);\r\nbreak;\r\ncase SND_SOC_DAIFMT_NB_IF:\r\ndev_dbg(dai->codec->dev,\r\n"%s: IF0: Normal bit clock, inverted frame\n",\r\n__func__);\r\nval |= BIT(AB8500_DIGIFCONF2_FSYNC0P);\r\nbreak;\r\ncase SND_SOC_DAIFMT_IB_NF:\r\ndev_dbg(dai->codec->dev,\r\n"%s: IF0: Inverted bit clock, normal frame\n",\r\n__func__);\r\nval |= BIT(AB8500_DIGIFCONF2_BITCLK0P);\r\nbreak;\r\ncase SND_SOC_DAIFMT_IB_IF:\r\ndev_dbg(dai->codec->dev,\r\n"%s: IF0: Inverted bit clock, inverted frame\n",\r\n__func__);\r\nval |= BIT(AB8500_DIGIFCONF2_FSYNC0P);\r\nval |= BIT(AB8500_DIGIFCONF2_BITCLK0P);\r\nbreak;\r\ndefault:\r\ndev_err(dai->codec->dev,\r\n"%s: ERROR: Unsupported INV mask 0x%x\n",\r\n__func__, fmt & SND_SOC_DAIFMT_INV_MASK);\r\nreturn -EINVAL;\r\n}\r\nsnd_soc_update_bits(codec, AB8500_DIGIFCONF2, mask, val);\r\nreturn 0;\r\n}\r\nstatic int ab8500_codec_set_dai_tdm_slot(struct snd_soc_dai *dai,\r\nunsigned int tx_mask, unsigned int rx_mask,\r\nint slots, int slot_width)\r\n{\r\nstruct snd_soc_codec *codec = dai->codec;\r\nunsigned int val, mask, slot, slots_active;\r\nmask = BIT(AB8500_DIGIFCONF2_IF0WL0) |\r\nBIT(AB8500_DIGIFCONF2_IF0WL1);\r\nval = 0;\r\nswitch (slot_width) {\r\ncase 16:\r\nbreak;\r\ncase 20:\r\nval |= BIT(AB8500_DIGIFCONF2_IF0WL0);\r\nbreak;\r\ncase 24:\r\nval |= BIT(AB8500_DIGIFCONF2_IF0WL1);\r\nbreak;\r\ncase 32:\r\nval |= BIT(AB8500_DIGIFCONF2_IF0WL1) |\r\nBIT(AB8500_DIGIFCONF2_IF0WL0);\r\nbreak;\r\ndefault:\r\ndev_err(dai->codec->dev, "%s: Unsupported slot-width 0x%x\n",\r\n__func__, slot_width);\r\nreturn -EINVAL;\r\n}\r\ndev_dbg(dai->codec->dev, "%s: IF0 slot-width: %d bits.\n",\r\n__func__, slot_width);\r\nsnd_soc_update_bits(codec, AB8500_DIGIFCONF2, mask, val);\r\ndev_dbg(dai->codec->dev, "%s: Slots, total: %d\n", __func__, slots);\r\nmask = BIT(AB8500_DIGIFCONF1_IF0BITCLKOS0) |\r\nBIT(AB8500_DIGIFCONF1_IF0BITCLKOS1);\r\nswitch (slots) {\r\ncase 2:\r\nval = AB8500_MASK_NONE;\r\nbreak;\r\ncase 4:\r\nval = BIT(AB8500_DIGIFCONF1_IF0BITCLKOS0);\r\nbreak;\r\ncase 8:\r\nval = BIT(AB8500_DIGIFCONF1_IF0BITCLKOS1);\r\nbreak;\r\ncase 16:\r\nval = BIT(AB8500_DIGIFCONF1_IF0BITCLKOS0) |\r\nBIT(AB8500_DIGIFCONF1_IF0BITCLKOS1);\r\nbreak;\r\ndefault:\r\ndev_err(dai->codec->dev,\r\n"%s: ERROR: Unsupported number of slots (%d)!\n",\r\n__func__, slots);\r\nreturn -EINVAL;\r\n}\r\nsnd_soc_update_bits(codec, AB8500_DIGIFCONF1, mask, val);\r\nif (tx_mask & ~0xff)\r\nreturn -EINVAL;\r\nmask = AB8500_DASLOTCONFX_SLTODAX_MASK;\r\ntx_mask = tx_mask << AB8500_DA_DATA0_OFFSET;\r\nslots_active = hweight32(tx_mask);\r\ndev_dbg(dai->codec->dev, "%s: Slots, active, TX: %d\n", __func__,\r\nslots_active);\r\nswitch (slots_active) {\r\ncase 0:\r\nbreak;\r\ncase 1:\r\nslot = ffs(tx_mask);\r\nsnd_soc_update_bits(codec, AB8500_DASLOTCONF1, mask, slot);\r\nsnd_soc_update_bits(codec, AB8500_DASLOTCONF3, mask, slot);\r\nsnd_soc_update_bits(codec, AB8500_DASLOTCONF2, mask, slot);\r\nsnd_soc_update_bits(codec, AB8500_DASLOTCONF4, mask, slot);\r\nbreak;\r\ncase 2:\r\nslot = ffs(tx_mask);\r\nsnd_soc_update_bits(codec, AB8500_DASLOTCONF1, mask, slot);\r\nsnd_soc_update_bits(codec, AB8500_DASLOTCONF3, mask, slot);\r\nslot = fls(tx_mask);\r\nsnd_soc_update_bits(codec, AB8500_DASLOTCONF2, mask, slot);\r\nsnd_soc_update_bits(codec, AB8500_DASLOTCONF4, mask, slot);\r\nbreak;\r\ncase 8:\r\ndev_dbg(dai->codec->dev,\r\n"%s: In 8-channel mode DA-from-slot mapping is set manually.",\r\n__func__);\r\nbreak;\r\ndefault:\r\ndev_err(dai->codec->dev,\r\n"%s: Unsupported number of active TX-slots (%d)!\n",\r\n__func__, slots_active);\r\nreturn -EINVAL;\r\n}\r\nif (rx_mask & ~0xff)\r\nreturn -EINVAL;\r\nrx_mask = rx_mask << AB8500_AD_DATA0_OFFSET;\r\nslots_active = hweight32(rx_mask);\r\ndev_dbg(dai->codec->dev, "%s: Slots, active, RX: %d\n", __func__,\r\nslots_active);\r\nswitch (slots_active) {\r\ncase 0:\r\nbreak;\r\ncase 1:\r\nslot = ffs(rx_mask);\r\nsnd_soc_update_bits(codec, AB8500_ADSLOTSEL(slot),\r\nAB8500_MASK_SLOT(slot),\r\nAB8500_ADSLOTSELX_AD_OUT_TO_SLOT(AB8500_AD_OUT3, slot));\r\nbreak;\r\ncase 2:\r\nslot = ffs(rx_mask);\r\nsnd_soc_update_bits(codec,\r\nAB8500_ADSLOTSEL(slot),\r\nAB8500_MASK_SLOT(slot),\r\nAB8500_ADSLOTSELX_AD_OUT_TO_SLOT(AB8500_AD_OUT3, slot));\r\nslot = fls(rx_mask);\r\nsnd_soc_update_bits(codec,\r\nAB8500_ADSLOTSEL(slot),\r\nAB8500_MASK_SLOT(slot),\r\nAB8500_ADSLOTSELX_AD_OUT_TO_SLOT(AB8500_AD_OUT2, slot));\r\nbreak;\r\ncase 8:\r\ndev_dbg(dai->codec->dev,\r\n"%s: In 8-channel mode AD-to-slot mapping is set manually.",\r\n__func__);\r\nbreak;\r\ndefault:\r\ndev_err(dai->codec->dev,\r\n"%s: Unsupported number of active RX-slots (%d)!\n",\r\n__func__, slots_active);\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic void ab8500_codec_of_probe(struct device *dev, struct device_node *np,\r\nstruct ab8500_codec_platform_data *codec)\r\n{\r\nu32 value;\r\nif (of_get_property(np, "stericsson,amic1-type-single-ended", NULL))\r\ncodec->amics.mic1_type = AMIC_TYPE_SINGLE_ENDED;\r\nelse\r\ncodec->amics.mic1_type = AMIC_TYPE_DIFFERENTIAL;\r\nif (of_get_property(np, "stericsson,amic2-type-single-ended", NULL))\r\ncodec->amics.mic2_type = AMIC_TYPE_SINGLE_ENDED;\r\nelse\r\ncodec->amics.mic2_type = AMIC_TYPE_DIFFERENTIAL;\r\nif (of_get_property(np, "stericsson,amic1a-bias-vamic2", NULL))\r\ncodec->amics.mic1a_micbias = AMIC_MICBIAS_VAMIC2;\r\nelse\r\ncodec->amics.mic1a_micbias = AMIC_MICBIAS_VAMIC1;\r\nif (of_get_property(np, "stericsson,amic1b-bias-vamic2", NULL))\r\ncodec->amics.mic1b_micbias = AMIC_MICBIAS_VAMIC2;\r\nelse\r\ncodec->amics.mic1b_micbias = AMIC_MICBIAS_VAMIC1;\r\nif (of_get_property(np, "stericsson,amic2-bias-vamic1", NULL))\r\ncodec->amics.mic2_micbias = AMIC_MICBIAS_VAMIC1;\r\nelse\r\ncodec->amics.mic2_micbias = AMIC_MICBIAS_VAMIC2;\r\nif (!of_property_read_u32(np, "stericsson,earpeice-cmv", &value)) {\r\nswitch (value) {\r\ncase 950 :\r\ncodec->ear_cmv = EAR_CMV_0_95V;\r\nbreak;\r\ncase 1100 :\r\ncodec->ear_cmv = EAR_CMV_1_10V;\r\nbreak;\r\ncase 1270 :\r\ncodec->ear_cmv = EAR_CMV_1_27V;\r\nbreak;\r\ncase 1580 :\r\ncodec->ear_cmv = EAR_CMV_1_58V;\r\nbreak;\r\ndefault :\r\ncodec->ear_cmv = EAR_CMV_UNKNOWN;\r\ndev_err(dev, "Unsuitable earpiece voltage found in DT\n");\r\n}\r\n} else {\r\ndev_warn(dev, "No earpiece voltage found in DT - using default\n");\r\ncodec->ear_cmv = EAR_CMV_0_95V;\r\n}\r\n}\r\nstatic int ab8500_codec_probe(struct snd_soc_codec *codec)\r\n{\r\nstruct snd_soc_dapm_context *dapm = snd_soc_codec_get_dapm(codec);\r\nstruct device *dev = codec->dev;\r\nstruct device_node *np = dev->of_node;\r\nstruct ab8500_codec_drvdata *drvdata = dev_get_drvdata(dev);\r\nstruct ab8500_platform_data *pdata;\r\nstruct filter_control *fc;\r\nint status;\r\ndev_dbg(dev, "%s: Enter.\n", __func__);\r\npdata = dev_get_platdata(dev->parent);\r\nif (np) {\r\nif (!pdata)\r\npdata = devm_kzalloc(dev,\r\nsizeof(struct ab8500_platform_data),\r\nGFP_KERNEL);\r\nif (pdata && !pdata->codec)\r\npdata->codec\r\n= devm_kzalloc(dev,\r\nsizeof(struct ab8500_codec_platform_data),\r\nGFP_KERNEL);\r\nif (!(pdata && pdata->codec))\r\nreturn -ENOMEM;\r\nab8500_codec_of_probe(dev, np, pdata->codec);\r\n} else {\r\nif (!(pdata && pdata->codec)) {\r\ndev_err(dev, "No codec platform data or DT found\n");\r\nreturn -EINVAL;\r\n}\r\n}\r\nstatus = ab8500_audio_setup_mics(codec, &pdata->codec->amics);\r\nif (status < 0) {\r\npr_err("%s: Failed to setup mics (%d)!\n", __func__, status);\r\nreturn status;\r\n}\r\nstatus = ab8500_audio_set_ear_cmv(codec, pdata->codec->ear_cmv);\r\nif (status < 0) {\r\npr_err("%s: Failed to set earpiece CM-voltage (%d)!\n",\r\n__func__, status);\r\nreturn status;\r\n}\r\nstatus = ab8500_audio_init_audioblock(codec);\r\nif (status < 0) {\r\ndev_err(dev, "%s: failed to init audio-block (%d)!\n",\r\n__func__, status);\r\nreturn status;\r\n}\r\nsnd_soc_write(codec, AB8500_ANACONF5,\r\nBIT(AB8500_ANACONF5_HSAUTOEN));\r\nsnd_soc_write(codec, AB8500_SHORTCIRCONF,\r\nBIT(AB8500_SHORTCIRCONF_HSZCDDIS));\r\nstatus = snd_soc_add_codec_controls(codec, ab8500_filter_controls,\r\nARRAY_SIZE(ab8500_filter_controls));\r\nif (status < 0) {\r\ndev_err(dev,\r\n"%s: failed to add ab8500 filter controls (%d).\n",\r\n__func__, status);\r\nreturn status;\r\n}\r\nfc = (struct filter_control *)\r\n&ab8500_filter_controls[AB8500_FILTER_ANC_FIR].private_value;\r\ndrvdata->anc_fir_values = (long *)fc->value;\r\nfc = (struct filter_control *)\r\n&ab8500_filter_controls[AB8500_FILTER_ANC_IIR].private_value;\r\ndrvdata->anc_iir_values = (long *)fc->value;\r\nfc = (struct filter_control *)\r\n&ab8500_filter_controls[AB8500_FILTER_SID_FIR].private_value;\r\ndrvdata->sid_fir_values = (long *)fc->value;\r\nsnd_soc_dapm_disable_pin(dapm, "ANC Configure Input");\r\nmutex_init(&drvdata->ctrl_lock);\r\nreturn status;\r\n}\r\nstatic int ab8500_codec_driver_probe(struct platform_device *pdev)\r\n{\r\nint status;\r\nstruct ab8500_codec_drvdata *drvdata;\r\ndev_dbg(&pdev->dev, "%s: Enter.\n", __func__);\r\ndrvdata = devm_kzalloc(&pdev->dev, sizeof(struct ab8500_codec_drvdata),\r\nGFP_KERNEL);\r\nif (!drvdata)\r\nreturn -ENOMEM;\r\ndrvdata->sid_status = SID_UNCONFIGURED;\r\ndrvdata->anc_status = ANC_UNCONFIGURED;\r\ndev_set_drvdata(&pdev->dev, drvdata);\r\ndrvdata->regmap = devm_regmap_init(&pdev->dev, NULL, &pdev->dev,\r\n&ab8500_codec_regmap);\r\nif (IS_ERR(drvdata->regmap)) {\r\nstatus = PTR_ERR(drvdata->regmap);\r\ndev_err(&pdev->dev, "%s: Failed to allocate regmap: %d\n",\r\n__func__, status);\r\nreturn status;\r\n}\r\ndev_dbg(&pdev->dev, "%s: Register codec.\n", __func__);\r\nstatus = snd_soc_register_codec(&pdev->dev, &ab8500_codec_driver,\r\nab8500_codec_dai,\r\nARRAY_SIZE(ab8500_codec_dai));\r\nif (status < 0)\r\ndev_err(&pdev->dev,\r\n"%s: Error: Failed to register codec (%d).\n",\r\n__func__, status);\r\nreturn status;\r\n}\r\nstatic int ab8500_codec_driver_remove(struct platform_device *pdev)\r\n{\r\ndev_dbg(&pdev->dev, "%s Enter.\n", __func__);\r\nsnd_soc_unregister_codec(&pdev->dev);\r\nreturn 0;\r\n}
