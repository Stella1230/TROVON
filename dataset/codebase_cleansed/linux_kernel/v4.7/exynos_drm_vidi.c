static inline struct vidi_context *encoder_to_vidi(struct drm_encoder *e)\r\n{\r\nreturn container_of(e, struct vidi_context, encoder);\r\n}\r\nstatic int vidi_enable_vblank(struct exynos_drm_crtc *crtc)\r\n{\r\nstruct vidi_context *ctx = crtc->ctx;\r\nif (ctx->suspended)\r\nreturn -EPERM;\r\nif (!test_and_set_bit(0, &ctx->irq_flags))\r\nctx->vblank_on = true;\r\nctx->direct_vblank = true;\r\nschedule_work(&ctx->work);\r\nreturn 0;\r\n}\r\nstatic void vidi_disable_vblank(struct exynos_drm_crtc *crtc)\r\n{\r\nstruct vidi_context *ctx = crtc->ctx;\r\nif (ctx->suspended)\r\nreturn;\r\nif (test_and_clear_bit(0, &ctx->irq_flags))\r\nctx->vblank_on = false;\r\n}\r\nstatic void vidi_update_plane(struct exynos_drm_crtc *crtc,\r\nstruct exynos_drm_plane *plane)\r\n{\r\nstruct drm_plane_state *state = plane->base.state;\r\nstruct vidi_context *ctx = crtc->ctx;\r\ndma_addr_t addr;\r\nif (ctx->suspended)\r\nreturn;\r\naddr = exynos_drm_fb_dma_addr(state->fb, 0);\r\nDRM_DEBUG_KMS("dma_addr = %pad\n", &addr);\r\nif (ctx->vblank_on)\r\nschedule_work(&ctx->work);\r\n}\r\nstatic void vidi_enable(struct exynos_drm_crtc *crtc)\r\n{\r\nstruct vidi_context *ctx = crtc->ctx;\r\nmutex_lock(&ctx->lock);\r\nctx->suspended = false;\r\nif (test_and_clear_bit(0, &ctx->irq_flags))\r\nvidi_enable_vblank(ctx->crtc);\r\nmutex_unlock(&ctx->lock);\r\n}\r\nstatic void vidi_disable(struct exynos_drm_crtc *crtc)\r\n{\r\nstruct vidi_context *ctx = crtc->ctx;\r\nmutex_lock(&ctx->lock);\r\nctx->suspended = true;\r\nmutex_unlock(&ctx->lock);\r\n}\r\nstatic int vidi_ctx_initialize(struct vidi_context *ctx,\r\nstruct drm_device *drm_dev)\r\n{\r\nstruct exynos_drm_private *priv = drm_dev->dev_private;\r\nctx->drm_dev = drm_dev;\r\nctx->pipe = priv->pipe++;\r\nreturn 0;\r\n}\r\nstatic void vidi_fake_vblank_handler(struct work_struct *work)\r\n{\r\nstruct vidi_context *ctx = container_of(work, struct vidi_context,\r\nwork);\r\nint win;\r\nif (ctx->pipe < 0)\r\nreturn;\r\nusleep_range(16000, 20000);\r\nmutex_lock(&ctx->lock);\r\nif (ctx->direct_vblank) {\r\ndrm_crtc_handle_vblank(&ctx->crtc->base);\r\nctx->direct_vblank = false;\r\nmutex_unlock(&ctx->lock);\r\nreturn;\r\n}\r\nmutex_unlock(&ctx->lock);\r\nfor (win = 0 ; win < WINDOWS_NR ; win++) {\r\nstruct exynos_drm_plane *plane = &ctx->planes[win];\r\nif (!plane->pending_fb)\r\ncontinue;\r\nexynos_drm_crtc_finish_update(ctx->crtc, plane);\r\n}\r\n}\r\nstatic ssize_t vidi_show_connection(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct vidi_context *ctx = dev_get_drvdata(dev);\r\nint rc;\r\nmutex_lock(&ctx->lock);\r\nrc = sprintf(buf, "%d\n", ctx->connected);\r\nmutex_unlock(&ctx->lock);\r\nreturn rc;\r\n}\r\nstatic ssize_t vidi_store_connection(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t len)\r\n{\r\nstruct vidi_context *ctx = dev_get_drvdata(dev);\r\nint ret;\r\nret = kstrtoint(buf, 0, &ctx->connected);\r\nif (ret)\r\nreturn ret;\r\nif (ctx->connected > 1)\r\nreturn -EINVAL;\r\nif (!ctx->raw_edid)\r\nctx->raw_edid = (struct edid *)fake_edid_info;\r\nif (ctx->raw_edid != (struct edid *)fake_edid_info) {\r\nDRM_DEBUG_KMS("edid data is not fake data.\n");\r\nreturn -EINVAL;\r\n}\r\nDRM_DEBUG_KMS("requested connection.\n");\r\ndrm_helper_hpd_irq_event(ctx->drm_dev);\r\nreturn len;\r\n}\r\nint vidi_connection_ioctl(struct drm_device *drm_dev, void *data,\r\nstruct drm_file *file_priv)\r\n{\r\nstruct vidi_context *ctx = dev_get_drvdata(drm_dev->dev);\r\nstruct drm_exynos_vidi_connection *vidi = data;\r\nif (!vidi) {\r\nDRM_DEBUG_KMS("user data for vidi is null.\n");\r\nreturn -EINVAL;\r\n}\r\nif (vidi->connection > 1) {\r\nDRM_DEBUG_KMS("connection should be 0 or 1.\n");\r\nreturn -EINVAL;\r\n}\r\nif (ctx->connected == vidi->connection) {\r\nDRM_DEBUG_KMS("same connection request.\n");\r\nreturn -EINVAL;\r\n}\r\nif (vidi->connection) {\r\nstruct edid *raw_edid;\r\nraw_edid = (struct edid *)(unsigned long)vidi->edid;\r\nif (!drm_edid_is_valid(raw_edid)) {\r\nDRM_DEBUG_KMS("edid data is invalid.\n");\r\nreturn -EINVAL;\r\n}\r\nctx->raw_edid = drm_edid_duplicate(raw_edid);\r\nif (!ctx->raw_edid) {\r\nDRM_DEBUG_KMS("failed to allocate raw_edid.\n");\r\nreturn -ENOMEM;\r\n}\r\n} else {\r\nif (ctx->raw_edid && ctx->raw_edid !=\r\n(struct edid *)fake_edid_info) {\r\nkfree(ctx->raw_edid);\r\nctx->raw_edid = NULL;\r\n}\r\n}\r\nctx->connected = vidi->connection;\r\ndrm_helper_hpd_irq_event(ctx->drm_dev);\r\nreturn 0;\r\n}\r\nstatic enum drm_connector_status vidi_detect(struct drm_connector *connector,\r\nbool force)\r\n{\r\nstruct vidi_context *ctx = ctx_from_connector(connector);\r\nreturn ctx->connected ? connector_status_connected :\r\nconnector_status_disconnected;\r\n}\r\nstatic void vidi_connector_destroy(struct drm_connector *connector)\r\n{\r\n}\r\nstatic int vidi_get_modes(struct drm_connector *connector)\r\n{\r\nstruct vidi_context *ctx = ctx_from_connector(connector);\r\nstruct edid *edid;\r\nint edid_len;\r\nif (!ctx->raw_edid) {\r\nDRM_DEBUG_KMS("raw_edid is null.\n");\r\nreturn -EFAULT;\r\n}\r\nedid_len = (1 + ctx->raw_edid->extensions) * EDID_LENGTH;\r\nedid = kmemdup(ctx->raw_edid, edid_len, GFP_KERNEL);\r\nif (!edid) {\r\nDRM_DEBUG_KMS("failed to allocate edid\n");\r\nreturn -ENOMEM;\r\n}\r\ndrm_mode_connector_update_edid_property(connector, edid);\r\nreturn drm_add_edid_modes(connector, edid);\r\n}\r\nstatic struct drm_encoder *vidi_best_encoder(struct drm_connector *connector)\r\n{\r\nstruct vidi_context *ctx = ctx_from_connector(connector);\r\nreturn &ctx->encoder;\r\n}\r\nstatic int vidi_create_connector(struct drm_encoder *encoder)\r\n{\r\nstruct vidi_context *ctx = encoder_to_vidi(encoder);\r\nstruct drm_connector *connector = &ctx->connector;\r\nint ret;\r\nconnector->polled = DRM_CONNECTOR_POLL_HPD;\r\nret = drm_connector_init(ctx->drm_dev, connector,\r\n&vidi_connector_funcs, DRM_MODE_CONNECTOR_VIRTUAL);\r\nif (ret) {\r\nDRM_ERROR("Failed to initialize connector with drm\n");\r\nreturn ret;\r\n}\r\ndrm_connector_helper_add(connector, &vidi_connector_helper_funcs);\r\ndrm_connector_register(connector);\r\ndrm_mode_connector_attach_encoder(connector, encoder);\r\nreturn 0;\r\n}\r\nstatic void exynos_vidi_mode_set(struct drm_encoder *encoder,\r\nstruct drm_display_mode *mode,\r\nstruct drm_display_mode *adjusted_mode)\r\n{\r\n}\r\nstatic void exynos_vidi_enable(struct drm_encoder *encoder)\r\n{\r\n}\r\nstatic void exynos_vidi_disable(struct drm_encoder *encoder)\r\n{\r\n}\r\nstatic int vidi_bind(struct device *dev, struct device *master, void *data)\r\n{\r\nstruct vidi_context *ctx = dev_get_drvdata(dev);\r\nstruct drm_device *drm_dev = data;\r\nstruct drm_encoder *encoder = &ctx->encoder;\r\nstruct exynos_drm_plane *exynos_plane;\r\nstruct exynos_drm_plane_config plane_config = { 0 };\r\nunsigned int i;\r\nint pipe, ret;\r\nvidi_ctx_initialize(ctx, drm_dev);\r\nplane_config.pixel_formats = formats;\r\nplane_config.num_pixel_formats = ARRAY_SIZE(formats);\r\nfor (i = 0; i < WINDOWS_NR; i++) {\r\nplane_config.zpos = i;\r\nplane_config.type = vidi_win_types[i];\r\nret = exynos_plane_init(drm_dev, &ctx->planes[i], i,\r\n1 << ctx->pipe, &plane_config);\r\nif (ret)\r\nreturn ret;\r\n}\r\nexynos_plane = &ctx->planes[DEFAULT_WIN];\r\nctx->crtc = exynos_drm_crtc_create(drm_dev, &exynos_plane->base,\r\nctx->pipe, EXYNOS_DISPLAY_TYPE_VIDI,\r\n&vidi_crtc_ops, ctx);\r\nif (IS_ERR(ctx->crtc)) {\r\nDRM_ERROR("failed to create crtc.\n");\r\nreturn PTR_ERR(ctx->crtc);\r\n}\r\npipe = exynos_drm_crtc_get_pipe_from_type(drm_dev,\r\nEXYNOS_DISPLAY_TYPE_VIDI);\r\nif (pipe < 0)\r\nreturn pipe;\r\nencoder->possible_crtcs = 1 << pipe;\r\nDRM_DEBUG_KMS("possible_crtcs = 0x%x\n", encoder->possible_crtcs);\r\ndrm_encoder_init(drm_dev, encoder, &exynos_vidi_encoder_funcs,\r\nDRM_MODE_ENCODER_TMDS, NULL);\r\ndrm_encoder_helper_add(encoder, &exynos_vidi_encoder_helper_funcs);\r\nret = vidi_create_connector(encoder);\r\nif (ret) {\r\nDRM_ERROR("failed to create connector ret = %d\n", ret);\r\ndrm_encoder_cleanup(encoder);\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic void vidi_unbind(struct device *dev, struct device *master, void *data)\r\n{\r\n}\r\nstatic int vidi_probe(struct platform_device *pdev)\r\n{\r\nstruct vidi_context *ctx;\r\nint ret;\r\nctx = devm_kzalloc(&pdev->dev, sizeof(*ctx), GFP_KERNEL);\r\nif (!ctx)\r\nreturn -ENOMEM;\r\nctx->pdev = pdev;\r\nINIT_WORK(&ctx->work, vidi_fake_vblank_handler);\r\nmutex_init(&ctx->lock);\r\nplatform_set_drvdata(pdev, ctx);\r\nret = device_create_file(&pdev->dev, &dev_attr_connection);\r\nif (ret < 0) {\r\nDRM_ERROR("failed to create connection sysfs.\n");\r\nreturn ret;\r\n}\r\nret = component_add(&pdev->dev, &vidi_component_ops);\r\nif (ret)\r\ngoto err_remove_file;\r\nreturn ret;\r\nerr_remove_file:\r\ndevice_remove_file(&pdev->dev, &dev_attr_connection);\r\nreturn ret;\r\n}\r\nstatic int vidi_remove(struct platform_device *pdev)\r\n{\r\nstruct vidi_context *ctx = platform_get_drvdata(pdev);\r\nif (ctx->raw_edid != (struct edid *)fake_edid_info) {\r\nkfree(ctx->raw_edid);\r\nctx->raw_edid = NULL;\r\nreturn -EINVAL;\r\n}\r\ncomponent_del(&pdev->dev, &vidi_component_ops);\r\nreturn 0;\r\n}
