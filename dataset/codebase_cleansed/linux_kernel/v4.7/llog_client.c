static int llog_client_open(const struct lu_env *env,\r\nstruct llog_handle *lgh, struct llog_logid *logid,\r\nchar *name, enum llog_open_param open_param)\r\n{\r\nstruct obd_import *imp;\r\nstruct llogd_body *body;\r\nstruct llog_ctxt *ctxt = lgh->lgh_ctxt;\r\nstruct ptlrpc_request *req = NULL;\r\nint rc;\r\nLLOG_CLIENT_ENTRY(ctxt, imp);\r\nLASSERTF(open_param != LLOG_OPEN_NEW, "%#x\n", open_param);\r\nLASSERT(lgh);\r\nreq = ptlrpc_request_alloc(imp, &RQF_LLOG_ORIGIN_HANDLE_CREATE);\r\nif (!req) {\r\nrc = -ENOMEM;\r\ngoto out;\r\n}\r\nif (name)\r\nreq_capsule_set_size(&req->rq_pill, &RMF_NAME, RCL_CLIENT,\r\nstrlen(name) + 1);\r\nrc = ptlrpc_request_pack(req, LUSTRE_LOG_VERSION,\r\nLLOG_ORIGIN_HANDLE_CREATE);\r\nif (rc) {\r\nptlrpc_request_free(req);\r\nreq = NULL;\r\ngoto out;\r\n}\r\nptlrpc_request_set_replen(req);\r\nbody = req_capsule_client_get(&req->rq_pill, &RMF_LLOGD_BODY);\r\nif (logid)\r\nbody->lgd_logid = *logid;\r\nbody->lgd_ctxt_idx = ctxt->loc_idx - 1;\r\nif (name) {\r\nchar *tmp;\r\ntmp = req_capsule_client_sized_get(&req->rq_pill, &RMF_NAME,\r\nstrlen(name) + 1);\r\nLASSERT(tmp);\r\nstrcpy(tmp, name);\r\n}\r\nrc = ptlrpc_queue_wait(req);\r\nif (rc)\r\ngoto out;\r\nbody = req_capsule_server_get(&req->rq_pill, &RMF_LLOGD_BODY);\r\nif (!body) {\r\nrc = -EFAULT;\r\ngoto out;\r\n}\r\nlgh->lgh_id = body->lgd_logid;\r\nlgh->lgh_ctxt = ctxt;\r\nout:\r\nLLOG_CLIENT_EXIT(ctxt, imp);\r\nptlrpc_req_finished(req);\r\nreturn rc;\r\n}\r\nstatic int llog_client_next_block(const struct lu_env *env,\r\nstruct llog_handle *loghandle,\r\nint *cur_idx, int next_idx,\r\n__u64 *cur_offset, void *buf, int len)\r\n{\r\nstruct obd_import *imp;\r\nstruct ptlrpc_request *req = NULL;\r\nstruct llogd_body *body;\r\nvoid *ptr;\r\nint rc;\r\nLLOG_CLIENT_ENTRY(loghandle->lgh_ctxt, imp);\r\nreq = ptlrpc_request_alloc_pack(imp, &RQF_LLOG_ORIGIN_HANDLE_NEXT_BLOCK,\r\nLUSTRE_LOG_VERSION,\r\nLLOG_ORIGIN_HANDLE_NEXT_BLOCK);\r\nif (!req) {\r\nrc = -ENOMEM;\r\ngoto err_exit;\r\n}\r\nbody = req_capsule_client_get(&req->rq_pill, &RMF_LLOGD_BODY);\r\nbody->lgd_logid = loghandle->lgh_id;\r\nbody->lgd_ctxt_idx = loghandle->lgh_ctxt->loc_idx - 1;\r\nbody->lgd_llh_flags = loghandle->lgh_hdr->llh_flags;\r\nbody->lgd_index = next_idx;\r\nbody->lgd_saved_index = *cur_idx;\r\nbody->lgd_len = len;\r\nbody->lgd_cur_offset = *cur_offset;\r\nreq_capsule_set_size(&req->rq_pill, &RMF_EADATA, RCL_SERVER, len);\r\nptlrpc_request_set_replen(req);\r\nrc = ptlrpc_queue_wait(req);\r\nif (rc)\r\ngoto out;\r\nbody = req_capsule_server_get(&req->rq_pill, &RMF_LLOGD_BODY);\r\nif (!body) {\r\nrc = -EFAULT;\r\ngoto out;\r\n}\r\nptr = req_capsule_server_get(&req->rq_pill, &RMF_EADATA);\r\nif (!ptr) {\r\nrc = -EFAULT;\r\ngoto out;\r\n}\r\n*cur_idx = body->lgd_saved_index;\r\n*cur_offset = body->lgd_cur_offset;\r\nmemcpy(buf, ptr, len);\r\nout:\r\nptlrpc_req_finished(req);\r\nerr_exit:\r\nLLOG_CLIENT_EXIT(loghandle->lgh_ctxt, imp);\r\nreturn rc;\r\n}\r\nstatic int llog_client_prev_block(const struct lu_env *env,\r\nstruct llog_handle *loghandle,\r\nint prev_idx, void *buf, int len)\r\n{\r\nstruct obd_import *imp;\r\nstruct ptlrpc_request *req = NULL;\r\nstruct llogd_body *body;\r\nvoid *ptr;\r\nint rc;\r\nLLOG_CLIENT_ENTRY(loghandle->lgh_ctxt, imp);\r\nreq = ptlrpc_request_alloc_pack(imp, &RQF_LLOG_ORIGIN_HANDLE_PREV_BLOCK,\r\nLUSTRE_LOG_VERSION,\r\nLLOG_ORIGIN_HANDLE_PREV_BLOCK);\r\nif (!req) {\r\nrc = -ENOMEM;\r\ngoto err_exit;\r\n}\r\nbody = req_capsule_client_get(&req->rq_pill, &RMF_LLOGD_BODY);\r\nbody->lgd_logid = loghandle->lgh_id;\r\nbody->lgd_ctxt_idx = loghandle->lgh_ctxt->loc_idx - 1;\r\nbody->lgd_llh_flags = loghandle->lgh_hdr->llh_flags;\r\nbody->lgd_index = prev_idx;\r\nbody->lgd_len = len;\r\nreq_capsule_set_size(&req->rq_pill, &RMF_EADATA, RCL_SERVER, len);\r\nptlrpc_request_set_replen(req);\r\nrc = ptlrpc_queue_wait(req);\r\nif (rc)\r\ngoto out;\r\nbody = req_capsule_server_get(&req->rq_pill, &RMF_LLOGD_BODY);\r\nif (!body) {\r\nrc = -EFAULT;\r\ngoto out;\r\n}\r\nptr = req_capsule_server_get(&req->rq_pill, &RMF_EADATA);\r\nif (!ptr) {\r\nrc = -EFAULT;\r\ngoto out;\r\n}\r\nmemcpy(buf, ptr, len);\r\nout:\r\nptlrpc_req_finished(req);\r\nerr_exit:\r\nLLOG_CLIENT_EXIT(loghandle->lgh_ctxt, imp);\r\nreturn rc;\r\n}\r\nstatic int llog_client_read_header(const struct lu_env *env,\r\nstruct llog_handle *handle)\r\n{\r\nstruct obd_import *imp;\r\nstruct ptlrpc_request *req = NULL;\r\nstruct llogd_body *body;\r\nstruct llog_log_hdr *hdr;\r\nstruct llog_rec_hdr *llh_hdr;\r\nint rc;\r\nLLOG_CLIENT_ENTRY(handle->lgh_ctxt, imp);\r\nreq = ptlrpc_request_alloc_pack(imp, &RQF_LLOG_ORIGIN_HANDLE_READ_HEADER,\r\nLUSTRE_LOG_VERSION,\r\nLLOG_ORIGIN_HANDLE_READ_HEADER);\r\nif (!req) {\r\nrc = -ENOMEM;\r\ngoto err_exit;\r\n}\r\nbody = req_capsule_client_get(&req->rq_pill, &RMF_LLOGD_BODY);\r\nbody->lgd_logid = handle->lgh_id;\r\nbody->lgd_ctxt_idx = handle->lgh_ctxt->loc_idx - 1;\r\nbody->lgd_llh_flags = handle->lgh_hdr->llh_flags;\r\nptlrpc_request_set_replen(req);\r\nrc = ptlrpc_queue_wait(req);\r\nif (rc)\r\ngoto out;\r\nhdr = req_capsule_server_get(&req->rq_pill, &RMF_LLOG_LOG_HDR);\r\nif (!hdr) {\r\nrc = -EFAULT;\r\ngoto out;\r\n}\r\nmemcpy(handle->lgh_hdr, hdr, sizeof(*hdr));\r\nhandle->lgh_last_idx = handle->lgh_hdr->llh_tail.lrt_index;\r\nllh_hdr = &handle->lgh_hdr->llh_hdr;\r\nif (llh_hdr->lrh_type != LLOG_HDR_MAGIC) {\r\nCERROR("bad log header magic: %#x (expecting %#x)\n",\r\nllh_hdr->lrh_type, LLOG_HDR_MAGIC);\r\nrc = -EIO;\r\n} else if (llh_hdr->lrh_len != LLOG_CHUNK_SIZE) {\r\nCERROR("incorrectly sized log header: %#x (expecting %#x)\n",\r\nllh_hdr->lrh_len, LLOG_CHUNK_SIZE);\r\nCERROR("you may need to re-run lconf --write_conf.\n");\r\nrc = -EIO;\r\n}\r\nout:\r\nptlrpc_req_finished(req);\r\nerr_exit:\r\nLLOG_CLIENT_EXIT(handle->lgh_ctxt, imp);\r\nreturn rc;\r\n}\r\nstatic int llog_client_close(const struct lu_env *env,\r\nstruct llog_handle *handle)\r\n{\r\nreturn 0;\r\n}
