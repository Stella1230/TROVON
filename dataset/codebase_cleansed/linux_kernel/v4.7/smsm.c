static int smsm_update_bits(void *data, u32 mask, u32 value)\r\n{\r\nstruct qcom_smsm *smsm = data;\r\nstruct smsm_host *hostp;\r\nunsigned long flags;\r\nu32 changes;\r\nu32 host;\r\nu32 orig;\r\nu32 val;\r\nspin_lock_irqsave(&smsm->lock, flags);\r\nval = orig = readl(smsm->local_state);\r\nval &= ~mask;\r\nval |= value;\r\nchanges = val ^ orig;\r\nif (!changes) {\r\nspin_unlock_irqrestore(&smsm->lock, flags);\r\ngoto done;\r\n}\r\nwritel(val, smsm->local_state);\r\nspin_unlock_irqrestore(&smsm->lock, flags);\r\nwmb();\r\nfor (host = 0; host < smsm->num_hosts; host++) {\r\nhostp = &smsm->hosts[host];\r\nval = readl(smsm->subscription + host);\r\nif (val & changes && hostp->ipc_regmap) {\r\nregmap_write(hostp->ipc_regmap,\r\nhostp->ipc_offset,\r\nBIT(hostp->ipc_bit));\r\n}\r\n}\r\ndone:\r\nreturn 0;\r\n}\r\nstatic irqreturn_t smsm_intr(int irq, void *data)\r\n{\r\nstruct smsm_entry *entry = data;\r\nunsigned i;\r\nint irq_pin;\r\nu32 changed;\r\nu32 val;\r\nval = readl(entry->remote_state);\r\nchanged = val ^ entry->last_value;\r\nentry->last_value = val;\r\nfor_each_set_bit(i, entry->irq_enabled, 32) {\r\nif (!(changed & BIT(i)))\r\ncontinue;\r\nif (val & BIT(i)) {\r\nif (test_bit(i, entry->irq_rising)) {\r\nirq_pin = irq_find_mapping(entry->domain, i);\r\nhandle_nested_irq(irq_pin);\r\n}\r\n} else {\r\nif (test_bit(i, entry->irq_falling)) {\r\nirq_pin = irq_find_mapping(entry->domain, i);\r\nhandle_nested_irq(irq_pin);\r\n}\r\n}\r\n}\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void smsm_mask_irq(struct irq_data *irqd)\r\n{\r\nstruct smsm_entry *entry = irq_data_get_irq_chip_data(irqd);\r\nirq_hw_number_t irq = irqd_to_hwirq(irqd);\r\nstruct qcom_smsm *smsm = entry->smsm;\r\nu32 val;\r\nif (entry->subscription) {\r\nval = readl(entry->subscription + smsm->local_host);\r\nval &= ~BIT(irq);\r\nwritel(val, entry->subscription + smsm->local_host);\r\n}\r\nclear_bit(irq, entry->irq_enabled);\r\n}\r\nstatic void smsm_unmask_irq(struct irq_data *irqd)\r\n{\r\nstruct smsm_entry *entry = irq_data_get_irq_chip_data(irqd);\r\nirq_hw_number_t irq = irqd_to_hwirq(irqd);\r\nstruct qcom_smsm *smsm = entry->smsm;\r\nu32 val;\r\nset_bit(irq, entry->irq_enabled);\r\nif (entry->subscription) {\r\nval = readl(entry->subscription + smsm->local_host);\r\nval |= BIT(irq);\r\nwritel(val, entry->subscription + smsm->local_host);\r\n}\r\n}\r\nstatic int smsm_set_irq_type(struct irq_data *irqd, unsigned int type)\r\n{\r\nstruct smsm_entry *entry = irq_data_get_irq_chip_data(irqd);\r\nirq_hw_number_t irq = irqd_to_hwirq(irqd);\r\nif (!(type & IRQ_TYPE_EDGE_BOTH))\r\nreturn -EINVAL;\r\nif (type & IRQ_TYPE_EDGE_RISING)\r\nset_bit(irq, entry->irq_rising);\r\nelse\r\nclear_bit(irq, entry->irq_rising);\r\nif (type & IRQ_TYPE_EDGE_FALLING)\r\nset_bit(irq, entry->irq_falling);\r\nelse\r\nclear_bit(irq, entry->irq_falling);\r\nreturn 0;\r\n}\r\nstatic int smsm_irq_map(struct irq_domain *d,\r\nunsigned int irq,\r\nirq_hw_number_t hw)\r\n{\r\nstruct smsm_entry *entry = d->host_data;\r\nirq_set_chip_and_handler(irq, &smsm_irq_chip, handle_level_irq);\r\nirq_set_chip_data(irq, entry);\r\nirq_set_nested_thread(irq, 1);\r\nreturn 0;\r\n}\r\nstatic int smsm_parse_ipc(struct qcom_smsm *smsm, unsigned host_id)\r\n{\r\nstruct device_node *syscon;\r\nstruct device_node *node = smsm->dev->of_node;\r\nstruct smsm_host *host = &smsm->hosts[host_id];\r\nchar key[16];\r\nint ret;\r\nsnprintf(key, sizeof(key), "qcom,ipc-%d", host_id);\r\nsyscon = of_parse_phandle(node, key, 0);\r\nif (!syscon)\r\nreturn 0;\r\nhost->ipc_regmap = syscon_node_to_regmap(syscon);\r\nif (IS_ERR(host->ipc_regmap))\r\nreturn PTR_ERR(host->ipc_regmap);\r\nret = of_property_read_u32_index(node, key, 1, &host->ipc_offset);\r\nif (ret < 0) {\r\ndev_err(smsm->dev, "no offset in %s\n", key);\r\nreturn -EINVAL;\r\n}\r\nret = of_property_read_u32_index(node, key, 2, &host->ipc_bit);\r\nif (ret < 0) {\r\ndev_err(smsm->dev, "no bit in %s\n", key);\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int smsm_inbound_entry(struct qcom_smsm *smsm,\r\nstruct smsm_entry *entry,\r\nstruct device_node *node)\r\n{\r\nint ret;\r\nint irq;\r\nirq = irq_of_parse_and_map(node, 0);\r\nif (!irq) {\r\ndev_err(smsm->dev, "failed to parse smsm interrupt\n");\r\nreturn -EINVAL;\r\n}\r\nret = devm_request_threaded_irq(smsm->dev, irq,\r\nNULL, smsm_intr,\r\nIRQF_ONESHOT,\r\n"smsm", (void *)entry);\r\nif (ret) {\r\ndev_err(smsm->dev, "failed to request interrupt\n");\r\nreturn ret;\r\n}\r\nentry->domain = irq_domain_add_linear(node, 32, &smsm_irq_ops, entry);\r\nif (!entry->domain) {\r\ndev_err(smsm->dev, "failed to add irq_domain\n");\r\nreturn -ENOMEM;\r\n}\r\nreturn 0;\r\n}\r\nstatic int smsm_get_size_info(struct qcom_smsm *smsm)\r\n{\r\nsize_t size;\r\nstruct {\r\nu32 num_hosts;\r\nu32 num_entries;\r\nu32 reserved0;\r\nu32 reserved1;\r\n} *info;\r\ninfo = qcom_smem_get(QCOM_SMEM_HOST_ANY, SMEM_SMSM_SIZE_INFO, &size);\r\nif (PTR_ERR(info) == -ENOENT || size != sizeof(*info)) {\r\ndev_warn(smsm->dev, "no smsm size info, using defaults\n");\r\nsmsm->num_entries = SMSM_DEFAULT_NUM_ENTRIES;\r\nsmsm->num_hosts = SMSM_DEFAULT_NUM_HOSTS;\r\nreturn 0;\r\n} else if (IS_ERR(info)) {\r\ndev_err(smsm->dev, "unable to retrieve smsm size info\n");\r\nreturn PTR_ERR(info);\r\n}\r\nsmsm->num_entries = info->num_entries;\r\nsmsm->num_hosts = info->num_hosts;\r\ndev_dbg(smsm->dev,\r\n"found custom size of smsm: %d entries %d hosts\n",\r\nsmsm->num_entries, smsm->num_hosts);\r\nreturn 0;\r\n}\r\nstatic int qcom_smsm_probe(struct platform_device *pdev)\r\n{\r\nstruct device_node *local_node;\r\nstruct device_node *node;\r\nstruct smsm_entry *entry;\r\nstruct qcom_smsm *smsm;\r\nu32 *intr_mask;\r\nsize_t size;\r\nu32 *states;\r\nu32 id;\r\nint ret;\r\nsmsm = devm_kzalloc(&pdev->dev, sizeof(*smsm), GFP_KERNEL);\r\nif (!smsm)\r\nreturn -ENOMEM;\r\nsmsm->dev = &pdev->dev;\r\nspin_lock_init(&smsm->lock);\r\nret = smsm_get_size_info(smsm);\r\nif (ret)\r\nreturn ret;\r\nsmsm->entries = devm_kcalloc(&pdev->dev,\r\nsmsm->num_entries,\r\nsizeof(struct smsm_entry),\r\nGFP_KERNEL);\r\nif (!smsm->entries)\r\nreturn -ENOMEM;\r\nsmsm->hosts = devm_kcalloc(&pdev->dev,\r\nsmsm->num_hosts,\r\nsizeof(struct smsm_host),\r\nGFP_KERNEL);\r\nif (!smsm->hosts)\r\nreturn -ENOMEM;\r\nlocal_node = of_find_node_with_property(pdev->dev.of_node, "#qcom,state-cells");\r\nif (!local_node) {\r\ndev_err(&pdev->dev, "no state entry\n");\r\nreturn -EINVAL;\r\n}\r\nof_property_read_u32(pdev->dev.of_node,\r\n"qcom,local-host",\r\n&smsm->local_host);\r\nfor (id = 0; id < smsm->num_hosts; id++) {\r\nret = smsm_parse_ipc(smsm, id);\r\nif (ret < 0)\r\nreturn ret;\r\n}\r\nret = qcom_smem_alloc(QCOM_SMEM_HOST_ANY, SMEM_SMSM_SHARED_STATE,\r\nsmsm->num_entries * sizeof(u32));\r\nif (ret < 0 && ret != -EEXIST) {\r\ndev_err(&pdev->dev, "unable to allocate shared state entry\n");\r\nreturn ret;\r\n}\r\nstates = qcom_smem_get(QCOM_SMEM_HOST_ANY, SMEM_SMSM_SHARED_STATE, NULL);\r\nif (IS_ERR(states)) {\r\ndev_err(&pdev->dev, "Unable to acquire shared state entry\n");\r\nreturn PTR_ERR(states);\r\n}\r\nsize = smsm->num_entries * smsm->num_hosts * sizeof(u32);\r\nret = qcom_smem_alloc(QCOM_SMEM_HOST_ANY, SMEM_SMSM_CPU_INTR_MASK, size);\r\nif (ret < 0 && ret != -EEXIST) {\r\ndev_err(&pdev->dev, "unable to allocate smsm interrupt mask\n");\r\nreturn ret;\r\n}\r\nintr_mask = qcom_smem_get(QCOM_SMEM_HOST_ANY, SMEM_SMSM_CPU_INTR_MASK, NULL);\r\nif (IS_ERR(intr_mask)) {\r\ndev_err(&pdev->dev, "unable to acquire shared memory interrupt mask\n");\r\nreturn PTR_ERR(intr_mask);\r\n}\r\nsmsm->local_state = states + smsm->local_host;\r\nsmsm->subscription = intr_mask + smsm->local_host * smsm->num_hosts;\r\nsmsm->state = qcom_smem_state_register(local_node, &smsm_state_ops, smsm);\r\nif (IS_ERR(smsm->state)) {\r\ndev_err(smsm->dev, "failed to register qcom_smem_state\n");\r\nreturn PTR_ERR(smsm->state);\r\n}\r\nfor_each_available_child_of_node(pdev->dev.of_node, node) {\r\nif (!of_property_read_bool(node, "interrupt-controller"))\r\ncontinue;\r\nret = of_property_read_u32(node, "reg", &id);\r\nif (ret || id >= smsm->num_entries) {\r\ndev_err(&pdev->dev, "invalid reg of entry\n");\r\nif (!ret)\r\nret = -EINVAL;\r\ngoto unwind_interfaces;\r\n}\r\nentry = &smsm->entries[id];\r\nentry->smsm = smsm;\r\nentry->remote_state = states + id;\r\nentry->subscription = intr_mask + id * smsm->num_hosts;\r\nwritel(0, entry->subscription + smsm->local_host);\r\nret = smsm_inbound_entry(smsm, entry, node);\r\nif (ret < 0)\r\ngoto unwind_interfaces;\r\n}\r\nplatform_set_drvdata(pdev, smsm);\r\nreturn 0;\r\nunwind_interfaces:\r\nfor (id = 0; id < smsm->num_entries; id++)\r\nif (smsm->entries[id].domain)\r\nirq_domain_remove(smsm->entries[id].domain);\r\nqcom_smem_state_unregister(smsm->state);\r\nreturn ret;\r\n}\r\nstatic int qcom_smsm_remove(struct platform_device *pdev)\r\n{\r\nstruct qcom_smsm *smsm = platform_get_drvdata(pdev);\r\nunsigned id;\r\nfor (id = 0; id < smsm->num_entries; id++)\r\nif (smsm->entries[id].domain)\r\nirq_domain_remove(smsm->entries[id].domain);\r\nqcom_smem_state_unregister(smsm->state);\r\nreturn 0;\r\n}
