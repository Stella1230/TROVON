static int crg_gate_control(struct clk_hw *hw, int en)\r\n{\r\nstruct crg_clk *crgclk = to_crg_clk(hw);\r\nstruct mb86s7x_peri_clk cmd;\r\nint ret;\r\ncmd.payload_size = sizeof(cmd);\r\ncmd.cntrlr = crgclk->cntrlr;\r\ncmd.domain = crgclk->domain;\r\ncmd.port = crgclk->port;\r\ncmd.en = en;\r\nif (cmd.port == 8)\r\nreturn en ? 0 : -EINVAL;\r\npr_debug("%s:%d CMD Cntrlr-%u Dom-%u Port-%u En-%u}\n",\r\n__func__, __LINE__, cmd.cntrlr,\r\ncmd.domain, cmd.port, cmd.en);\r\nret = mb86s7x_send_packet(CMD_PERI_CLOCK_GATE_SET_REQ,\r\n&cmd, sizeof(cmd));\r\nif (ret < 0) {\r\npr_err("%s:%d failed!\n", __func__, __LINE__);\r\nreturn ret;\r\n}\r\npr_debug("%s:%d REP Cntrlr-%u Dom-%u Port-%u En-%u}\n",\r\n__func__, __LINE__, cmd.cntrlr,\r\ncmd.domain, cmd.port, cmd.en);\r\nif (cmd.en != en)\r\nret = -EINVAL;\r\nelse\r\nret = 0;\r\nreturn ret;\r\n}\r\nstatic int crg_port_prepare(struct clk_hw *hw)\r\n{\r\nreturn crg_gate_control(hw, 1);\r\n}\r\nstatic void crg_port_unprepare(struct clk_hw *hw)\r\n{\r\ncrg_gate_control(hw, 0);\r\n}\r\nstatic int\r\ncrg_rate_control(struct clk_hw *hw, int set, unsigned long *rate)\r\n{\r\nstruct crg_clk *crgclk = to_crg_clk(hw);\r\nstruct mb86s7x_peri_clk cmd;\r\nint code, ret;\r\ncmd.payload_size = sizeof(cmd);\r\ncmd.cntrlr = crgclk->cntrlr;\r\ncmd.domain = crgclk->domain;\r\ncmd.port = crgclk->port;\r\ncmd.frequency = *rate;\r\nif (set) {\r\ncode = CMD_PERI_CLOCK_RATE_SET_REQ;\r\npr_debug("%s:%d CMD Cntrlr-%u Dom-%u Port-%u Rate-SET %lluHz}\n",\r\n__func__, __LINE__, cmd.cntrlr,\r\ncmd.domain, cmd.port, cmd.frequency);\r\n} else {\r\ncode = CMD_PERI_CLOCK_RATE_GET_REQ;\r\npr_debug("%s:%d CMD Cntrlr-%u Dom-%u Port-%u Rate-GET}\n",\r\n__func__, __LINE__, cmd.cntrlr,\r\ncmd.domain, cmd.port);\r\n}\r\nret = mb86s7x_send_packet(code, &cmd, sizeof(cmd));\r\nif (ret < 0) {\r\npr_err("%s:%d failed!\n", __func__, __LINE__);\r\nreturn ret;\r\n}\r\nif (set)\r\npr_debug("%s:%d REP Cntrlr-%u Dom-%u Port-%u Rate-SET %lluHz}\n",\r\n__func__, __LINE__, cmd.cntrlr,\r\ncmd.domain, cmd.port, cmd.frequency);\r\nelse\r\npr_debug("%s:%d REP Cntrlr-%u Dom-%u Port-%u Rate-GOT %lluHz}\n",\r\n__func__, __LINE__, cmd.cntrlr,\r\ncmd.domain, cmd.port, cmd.frequency);\r\n*rate = cmd.frequency;\r\nreturn 0;\r\n}\r\nstatic unsigned long\r\ncrg_port_recalc_rate(struct clk_hw *hw, unsigned long parent_rate)\r\n{\r\nunsigned long rate;\r\ncrg_rate_control(hw, 0, &rate);\r\nreturn rate;\r\n}\r\nstatic long\r\ncrg_port_round_rate(struct clk_hw *hw,\r\nunsigned long rate, unsigned long *pr)\r\n{\r\nreturn rate;\r\n}\r\nstatic int\r\ncrg_port_set_rate(struct clk_hw *hw,\r\nunsigned long rate, unsigned long parent_rate)\r\n{\r\nreturn crg_rate_control(hw, 1, &rate);\r\n}\r\nstatic struct clk *crg11_get(struct of_phandle_args *clkspec, void *data)\r\n{\r\nstruct mb86s70_crg11 *crg11 = data;\r\nstruct clk_init_data init;\r\nu32 cntrlr, domain, port;\r\nstruct crg_clk *crgclk;\r\nstruct clk *clk;\r\nchar clkp[20];\r\nif (clkspec->args_count != 3)\r\nreturn ERR_PTR(-EINVAL);\r\ncntrlr = clkspec->args[0];\r\ndomain = clkspec->args[1];\r\nport = clkspec->args[2];\r\nif (port > 7)\r\nsnprintf(clkp, 20, "UngatedCLK%d_%X", cntrlr, domain);\r\nelse\r\nsnprintf(clkp, 20, "CLK%d_%X_%d", cntrlr, domain, port);\r\nmutex_lock(&crg11->lock);\r\nclk = __clk_lookup(clkp);\r\nif (clk) {\r\nmutex_unlock(&crg11->lock);\r\nreturn clk;\r\n}\r\ncrgclk = kzalloc(sizeof(*crgclk), GFP_KERNEL);\r\nif (!crgclk) {\r\nmutex_unlock(&crg11->lock);\r\nreturn ERR_PTR(-ENOMEM);\r\n}\r\ninit.name = clkp;\r\ninit.num_parents = 0;\r\ninit.ops = &crg_port_ops;\r\ninit.flags = 0;\r\ncrgclk->hw.init = &init;\r\ncrgclk->cntrlr = cntrlr;\r\ncrgclk->domain = domain;\r\ncrgclk->port = port;\r\nclk = clk_register(NULL, &crgclk->hw);\r\nif (IS_ERR(clk))\r\npr_err("%s:%d Error!\n", __func__, __LINE__);\r\nelse\r\npr_debug("Registered %s\n", clkp);\r\nclk_register_clkdev(clk, clkp, NULL);\r\nmutex_unlock(&crg11->lock);\r\nreturn clk;\r\n}\r\nstatic void __init crg_port_init(struct device_node *node)\r\n{\r\nstruct mb86s70_crg11 *crg11;\r\ncrg11 = kzalloc(sizeof(*crg11), GFP_KERNEL);\r\nif (!crg11)\r\nreturn;\r\nmutex_init(&crg11->lock);\r\nof_clk_add_provider(node, crg11_get, crg11);\r\n}\r\nstatic void mhu_cluster_rate(struct clk_hw *hw, unsigned long *rate, int get)\r\n{\r\nstruct cl_clk *clc = to_clc_clk(hw);\r\nstruct mb86s7x_cpu_freq cmd;\r\nint code, ret;\r\ncmd.payload_size = sizeof(cmd);\r\ncmd.cluster_class = 0;\r\ncmd.cluster_id = clc->cluster;\r\ncmd.cpu_id = 0;\r\ncmd.frequency = *rate;\r\nif (get)\r\ncode = CMD_CPU_CLOCK_RATE_GET_REQ;\r\nelse\r\ncode = CMD_CPU_CLOCK_RATE_SET_REQ;\r\npr_debug("%s:%d CMD Cl_Class-%u CL_ID-%u CPU_ID-%u Freq-%llu}\n",\r\n__func__, __LINE__, cmd.cluster_class,\r\ncmd.cluster_id, cmd.cpu_id, cmd.frequency);\r\nret = mb86s7x_send_packet(code, &cmd, sizeof(cmd));\r\nif (ret < 0) {\r\npr_err("%s:%d failed!\n", __func__, __LINE__);\r\nreturn;\r\n}\r\npr_debug("%s:%d REP Cl_Class-%u CL_ID-%u CPU_ID-%u Freq-%llu}\n",\r\n__func__, __LINE__, cmd.cluster_class,\r\ncmd.cluster_id, cmd.cpu_id, cmd.frequency);\r\n*rate = cmd.frequency;\r\n}\r\nstatic unsigned long\r\nclc_recalc_rate(struct clk_hw *hw, unsigned long unused)\r\n{\r\nunsigned long rate;\r\nmhu_cluster_rate(hw, &rate, 1);\r\nreturn rate;\r\n}\r\nstatic long\r\nclc_round_rate(struct clk_hw *hw, unsigned long rate,\r\nunsigned long *unused)\r\n{\r\nreturn rate;\r\n}\r\nstatic int\r\nclc_set_rate(struct clk_hw *hw, unsigned long rate,\r\nunsigned long unused)\r\n{\r\nunsigned long res = rate;\r\nmhu_cluster_rate(hw, &res, 0);\r\nreturn (res == rate) ? 0 : -EINVAL;\r\n}\r\nstruct clk *mb86s7x_clclk_register(struct device *cpu_dev)\r\n{\r\nstruct clk_init_data init;\r\nstruct cl_clk *clc;\r\nclc = kzalloc(sizeof(*clc), GFP_KERNEL);\r\nif (!clc)\r\nreturn ERR_PTR(-ENOMEM);\r\nclc->hw.init = &init;\r\nclc->cluster = topology_physical_package_id(cpu_dev->id);\r\ninit.name = dev_name(cpu_dev);\r\ninit.ops = &clk_clc_ops;\r\ninit.flags = CLK_GET_RATE_NOCACHE;\r\ninit.num_parents = 0;\r\nreturn devm_clk_register(cpu_dev, &clc->hw);\r\n}\r\nstatic int mb86s7x_clclk_of_init(void)\r\n{\r\nint cpu, ret = -ENODEV;\r\nstruct device_node *np;\r\nstruct clk *clk;\r\nnp = of_find_compatible_node(NULL, NULL, "fujitsu,mb86s70-scb-1.0");\r\nif (!np || !of_device_is_available(np))\r\ngoto exit;\r\nfor_each_possible_cpu(cpu) {\r\nstruct device *cpu_dev = get_cpu_device(cpu);\r\nif (!cpu_dev) {\r\npr_err("failed to get cpu%d device\n", cpu);\r\ncontinue;\r\n}\r\nclk = mb86s7x_clclk_register(cpu_dev);\r\nif (IS_ERR(clk)) {\r\npr_err("failed to register cpu%d clock\n", cpu);\r\ncontinue;\r\n}\r\nif (clk_register_clkdev(clk, NULL, dev_name(cpu_dev))) {\r\npr_err("failed to register cpu%d clock lookup\n", cpu);\r\ncontinue;\r\n}\r\npr_debug("registered clk for %s\n", dev_name(cpu_dev));\r\n}\r\nret = 0;\r\nplatform_device_register_simple("arm-bL-cpufreq-dt", -1, NULL, 0);\r\nexit:\r\nof_node_put(np);\r\nreturn ret;\r\n}
