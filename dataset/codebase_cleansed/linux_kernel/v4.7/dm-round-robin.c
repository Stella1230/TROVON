static void free_paths(struct list_head *paths)\r\n{\r\nstruct path_info *pi, *next;\r\nlist_for_each_entry_safe(pi, next, paths, list) {\r\nlist_del(&pi->list);\r\nkfree(pi);\r\n}\r\n}\r\nstatic void set_percpu_current_path(struct selector *s, struct dm_path *path)\r\n{\r\nint cpu;\r\nfor_each_possible_cpu(cpu)\r\n*per_cpu_ptr(s->current_path, cpu) = path;\r\n}\r\nstatic struct selector *alloc_selector(void)\r\n{\r\nstruct selector *s = kmalloc(sizeof(*s), GFP_KERNEL);\r\nif (!s)\r\nreturn NULL;\r\nINIT_LIST_HEAD(&s->valid_paths);\r\nINIT_LIST_HEAD(&s->invalid_paths);\r\nspin_lock_init(&s->lock);\r\ns->current_path = alloc_percpu(struct dm_path *);\r\nif (!s->current_path)\r\ngoto out_current_path;\r\nset_percpu_current_path(s, NULL);\r\nif (percpu_counter_init(&s->repeat_count, 0, GFP_KERNEL))\r\ngoto out_repeat_count;\r\nreturn s;\r\nout_repeat_count:\r\nfree_percpu(s->current_path);\r\nout_current_path:\r\nkfree(s);\r\nreturn NULL;;\r\n}\r\nstatic int rr_create(struct path_selector *ps, unsigned argc, char **argv)\r\n{\r\nstruct selector *s;\r\ns = alloc_selector();\r\nif (!s)\r\nreturn -ENOMEM;\r\nps->context = s;\r\nreturn 0;\r\n}\r\nstatic void rr_destroy(struct path_selector *ps)\r\n{\r\nstruct selector *s = ps->context;\r\nfree_paths(&s->valid_paths);\r\nfree_paths(&s->invalid_paths);\r\nfree_percpu(s->current_path);\r\npercpu_counter_destroy(&s->repeat_count);\r\nkfree(s);\r\nps->context = NULL;\r\n}\r\nstatic int rr_status(struct path_selector *ps, struct dm_path *path,\r\nstatus_type_t type, char *result, unsigned int maxlen)\r\n{\r\nstruct path_info *pi;\r\nint sz = 0;\r\nif (!path)\r\nDMEMIT("0 ");\r\nelse {\r\nswitch(type) {\r\ncase STATUSTYPE_INFO:\r\nbreak;\r\ncase STATUSTYPE_TABLE:\r\npi = path->pscontext;\r\nDMEMIT("%u ", pi->repeat_count);\r\nbreak;\r\n}\r\n}\r\nreturn sz;\r\n}\r\nstatic int rr_add_path(struct path_selector *ps, struct dm_path *path,\r\nint argc, char **argv, char **error)\r\n{\r\nstruct selector *s = ps->context;\r\nstruct path_info *pi;\r\nunsigned repeat_count = RR_MIN_IO;\r\nchar dummy;\r\nunsigned long flags;\r\nif (argc > 1) {\r\n*error = "round-robin ps: incorrect number of arguments";\r\nreturn -EINVAL;\r\n}\r\nif ((argc == 1) && (sscanf(argv[0], "%u%c", &repeat_count, &dummy) != 1)) {\r\n*error = "round-robin ps: invalid repeat count";\r\nreturn -EINVAL;\r\n}\r\npi = kmalloc(sizeof(*pi), GFP_KERNEL);\r\nif (!pi) {\r\n*error = "round-robin ps: Error allocating path context";\r\nreturn -ENOMEM;\r\n}\r\npi->path = path;\r\npi->repeat_count = repeat_count;\r\npath->pscontext = pi;\r\nspin_lock_irqsave(&s->lock, flags);\r\nlist_add_tail(&pi->list, &s->valid_paths);\r\nspin_unlock_irqrestore(&s->lock, flags);\r\nreturn 0;\r\n}\r\nstatic void rr_fail_path(struct path_selector *ps, struct dm_path *p)\r\n{\r\nunsigned long flags;\r\nstruct selector *s = ps->context;\r\nstruct path_info *pi = p->pscontext;\r\nspin_lock_irqsave(&s->lock, flags);\r\nif (p == *this_cpu_ptr(s->current_path))\r\nset_percpu_current_path(s, NULL);\r\nlist_move(&pi->list, &s->invalid_paths);\r\nspin_unlock_irqrestore(&s->lock, flags);\r\n}\r\nstatic int rr_reinstate_path(struct path_selector *ps, struct dm_path *p)\r\n{\r\nunsigned long flags;\r\nstruct selector *s = ps->context;\r\nstruct path_info *pi = p->pscontext;\r\nspin_lock_irqsave(&s->lock, flags);\r\nlist_move(&pi->list, &s->valid_paths);\r\nspin_unlock_irqrestore(&s->lock, flags);\r\nreturn 0;\r\n}\r\nstatic struct dm_path *rr_select_path(struct path_selector *ps, size_t nr_bytes)\r\n{\r\nunsigned long flags;\r\nstruct selector *s = ps->context;\r\nstruct path_info *pi = NULL;\r\nstruct dm_path *current_path = NULL;\r\ncurrent_path = *this_cpu_ptr(s->current_path);\r\nif (current_path) {\r\npercpu_counter_dec(&s->repeat_count);\r\nif (percpu_counter_read_positive(&s->repeat_count) > 0)\r\nreturn current_path;\r\n}\r\nspin_lock_irqsave(&s->lock, flags);\r\nif (!list_empty(&s->valid_paths)) {\r\npi = list_entry(s->valid_paths.next, struct path_info, list);\r\nlist_move_tail(&pi->list, &s->valid_paths);\r\npercpu_counter_set(&s->repeat_count, pi->repeat_count);\r\nset_percpu_current_path(s, pi->path);\r\ncurrent_path = pi->path;\r\n}\r\nspin_unlock_irqrestore(&s->lock, flags);\r\nreturn current_path;\r\n}\r\nstatic int __init dm_rr_init(void)\r\n{\r\nint r = dm_register_path_selector(&rr_ps);\r\nif (r < 0)\r\nDMERR("register failed %d", r);\r\nDMINFO("version " RR_VERSION " loaded");\r\nreturn r;\r\n}\r\nstatic void __exit dm_rr_exit(void)\r\n{\r\nint r = dm_unregister_path_selector(&rr_ps);\r\nif (r < 0)\r\nDMERR("unregister failed %d", r);\r\n}
