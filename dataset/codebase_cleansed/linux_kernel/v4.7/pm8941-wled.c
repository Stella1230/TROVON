static int pm8941_wled_update_status(struct backlight_device *bl)\r\n{\r\nstruct pm8941_wled *wled = bl_get_data(bl);\r\nu16 val = bl->props.brightness;\r\nu8 ctrl = 0;\r\nint rc;\r\nint i;\r\nif (bl->props.power != FB_BLANK_UNBLANK ||\r\nbl->props.fb_blank != FB_BLANK_UNBLANK ||\r\nbl->props.state & BL_CORE_FBBLANK)\r\nval = 0;\r\nif (val != 0)\r\nctrl = PM8941_WLED_REG_MOD_EN_BIT;\r\nrc = regmap_update_bits(wled->regmap,\r\nwled->addr + PM8941_WLED_REG_MOD_EN,\r\nPM8941_WLED_REG_MOD_EN_MASK, ctrl);\r\nif (rc)\r\nreturn rc;\r\nfor (i = 0; i < wled->cfg.num_strings; ++i) {\r\nu8 v[2] = { val & 0xff, (val >> 8) & 0xf };\r\nrc = regmap_bulk_write(wled->regmap,\r\nwled->addr + PM8941_WLED_REG_VAL_BASE + 2 * i,\r\nv, 2);\r\nif (rc)\r\nreturn rc;\r\n}\r\nrc = regmap_update_bits(wled->regmap,\r\nwled->addr + PM8941_WLED_REG_SYNC,\r\nPM8941_WLED_REG_SYNC_MASK, PM8941_WLED_REG_SYNC_ALL);\r\nif (rc)\r\nreturn rc;\r\nrc = regmap_update_bits(wled->regmap,\r\nwled->addr + PM8941_WLED_REG_SYNC,\r\nPM8941_WLED_REG_SYNC_MASK, PM8941_WLED_REG_SYNC_CLEAR);\r\nreturn rc;\r\n}\r\nstatic int pm8941_wled_setup(struct pm8941_wled *wled)\r\n{\r\nint rc;\r\nint i;\r\nrc = regmap_update_bits(wled->regmap,\r\nwled->addr + PM8941_WLED_REG_OVP,\r\nPM8941_WLED_REG_OVP_MASK, wled->cfg.ovp);\r\nif (rc)\r\nreturn rc;\r\nrc = regmap_update_bits(wled->regmap,\r\nwled->addr + PM8941_WLED_REG_BOOST,\r\nPM8941_WLED_REG_BOOST_MASK, wled->cfg.i_boost_limit);\r\nif (rc)\r\nreturn rc;\r\nrc = regmap_update_bits(wled->regmap,\r\nwled->addr + PM8941_WLED_REG_FREQ,\r\nPM8941_WLED_REG_FREQ_MASK, wled->cfg.switch_freq);\r\nif (rc)\r\nreturn rc;\r\nif (wled->cfg.cs_out_en) {\r\nu8 all = (BIT(wled->cfg.num_strings) - 1)\r\n<< PM8941_WLED_REG_SINK_SHFT;\r\nrc = regmap_update_bits(wled->regmap,\r\nwled->addr + PM8941_WLED_REG_SINK,\r\nPM8941_WLED_REG_SINK_MASK, all);\r\nif (rc)\r\nreturn rc;\r\n}\r\nfor (i = 0; i < wled->cfg.num_strings; ++i) {\r\nu16 addr = wled->addr + PM8941_WLED_REG_STR_OFFSET * i;\r\nrc = regmap_update_bits(wled->regmap,\r\naddr + PM8941_WLED_REG_STR_MOD_EN_BASE,\r\nPM8941_WLED_REG_STR_MOD_MASK,\r\nPM8941_WLED_REG_STR_MOD_EN);\r\nif (rc)\r\nreturn rc;\r\nif (wled->cfg.ext_gen) {\r\nrc = regmap_update_bits(wled->regmap,\r\naddr + PM8941_WLED_REG_STR_MOD_SRC_BASE,\r\nPM8941_WLED_REG_STR_MOD_SRC_MASK,\r\nPM8941_WLED_REG_STR_MOD_SRC_EXT);\r\nif (rc)\r\nreturn rc;\r\n}\r\nrc = regmap_update_bits(wled->regmap,\r\naddr + PM8941_WLED_REG_STR_SCALE_BASE,\r\nPM8941_WLED_REG_STR_SCALE_MASK,\r\nwled->cfg.i_limit);\r\nif (rc)\r\nreturn rc;\r\nrc = regmap_update_bits(wled->regmap,\r\naddr + PM8941_WLED_REG_STR_CABC_BASE,\r\nPM8941_WLED_REG_STR_CABC_MASK,\r\nwled->cfg.cabc_en ?\r\nPM8941_WLED_REG_STR_CABC_EN : 0);\r\nif (rc)\r\nreturn rc;\r\n}\r\nreturn 0;\r\n}\r\nstatic u32 pm8941_wled_num_strings_values_fn(u32 idx)\r\n{\r\nreturn idx + 1;\r\n}\r\nstatic u32 pm8941_wled_switch_freq_values_fn(u32 idx)\r\n{\r\nreturn 19200 / (2 * (1 + idx));\r\n}\r\nstatic u32 pm8941_wled_values(const struct pm8941_wled_var_cfg *cfg, u32 idx)\r\n{\r\nif (idx >= cfg->size)\r\nreturn UINT_MAX;\r\nif (cfg->fn)\r\nreturn cfg->fn(idx);\r\nif (cfg->values)\r\nreturn cfg->values[idx];\r\nreturn idx;\r\n}\r\nstatic int pm8941_wled_configure(struct pm8941_wled *wled, struct device *dev)\r\n{\r\nstruct pm8941_wled_config *cfg = &wled->cfg;\r\nu32 val;\r\nint rc;\r\nu32 c;\r\nint i;\r\nint j;\r\nconst struct {\r\nconst char *name;\r\nu32 *val_ptr;\r\nconst struct pm8941_wled_var_cfg *cfg;\r\n} u32_opts[] = {\r\n{\r\n"qcom,current-boost-limit",\r\n&cfg->i_boost_limit,\r\n.cfg = &pm8941_wled_i_boost_limit_cfg,\r\n},\r\n{\r\n"qcom,current-limit",\r\n&cfg->i_limit,\r\n.cfg = &pm8941_wled_i_limit_cfg,\r\n},\r\n{\r\n"qcom,ovp",\r\n&cfg->ovp,\r\n.cfg = &pm8941_wled_ovp_cfg,\r\n},\r\n{\r\n"qcom,switching-freq",\r\n&cfg->switch_freq,\r\n.cfg = &pm8941_wled_switch_freq_cfg,\r\n},\r\n{\r\n"qcom,num-strings",\r\n&cfg->num_strings,\r\n.cfg = &pm8941_wled_num_strings_cfg,\r\n},\r\n};\r\nconst struct {\r\nconst char *name;\r\nbool *val_ptr;\r\n} bool_opts[] = {\r\n{ "qcom,cs-out", &cfg->cs_out_en, },\r\n{ "qcom,ext-gen", &cfg->ext_gen, },\r\n{ "qcom,cabc", &cfg->cabc_en, },\r\n};\r\nrc = of_property_read_u32(dev->of_node, "reg", &val);\r\nif (rc || val > 0xffff) {\r\ndev_err(dev, "invalid IO resources\n");\r\nreturn rc ? rc : -EINVAL;\r\n}\r\nwled->addr = val;\r\nrc = of_property_read_string(dev->of_node, "label", &wled->name);\r\nif (rc)\r\nwled->name = dev->of_node->name;\r\n*cfg = pm8941_wled_config_defaults;\r\nfor (i = 0; i < ARRAY_SIZE(u32_opts); ++i) {\r\nrc = of_property_read_u32(dev->of_node, u32_opts[i].name, &val);\r\nif (rc == -EINVAL) {\r\ncontinue;\r\n} else if (rc) {\r\ndev_err(dev, "error reading '%s'\n", u32_opts[i].name);\r\nreturn rc;\r\n}\r\nc = UINT_MAX;\r\nfor (j = 0; c != val; j++) {\r\nc = pm8941_wled_values(u32_opts[i].cfg, j);\r\nif (c == UINT_MAX) {\r\ndev_err(dev, "invalid value for '%s'\n",\r\nu32_opts[i].name);\r\nreturn -EINVAL;\r\n}\r\n}\r\ndev_dbg(dev, "'%s' = %u\n", u32_opts[i].name, c);\r\n*u32_opts[i].val_ptr = j;\r\n}\r\nfor (i = 0; i < ARRAY_SIZE(bool_opts); ++i) {\r\nif (of_property_read_bool(dev->of_node, bool_opts[i].name))\r\n*bool_opts[i].val_ptr = true;\r\n}\r\ncfg->num_strings = cfg->num_strings + 1;\r\nreturn 0;\r\n}\r\nstatic int pm8941_wled_probe(struct platform_device *pdev)\r\n{\r\nstruct backlight_properties props;\r\nstruct backlight_device *bl;\r\nstruct pm8941_wled *wled;\r\nstruct regmap *regmap;\r\nu32 val;\r\nint rc;\r\nregmap = dev_get_regmap(pdev->dev.parent, NULL);\r\nif (!regmap) {\r\ndev_err(&pdev->dev, "Unable to get regmap\n");\r\nreturn -EINVAL;\r\n}\r\nwled = devm_kzalloc(&pdev->dev, sizeof(*wled), GFP_KERNEL);\r\nif (!wled)\r\nreturn -ENOMEM;\r\nwled->regmap = regmap;\r\nrc = pm8941_wled_configure(wled, &pdev->dev);\r\nif (rc)\r\nreturn rc;\r\nrc = pm8941_wled_setup(wled);\r\nif (rc)\r\nreturn rc;\r\nval = PM8941_WLED_DEFAULT_BRIGHTNESS;\r\nof_property_read_u32(pdev->dev.of_node, "default-brightness", &val);\r\nmemset(&props, 0, sizeof(struct backlight_properties));\r\nprops.type = BACKLIGHT_RAW;\r\nprops.brightness = val;\r\nprops.max_brightness = PM8941_WLED_REG_VAL_MAX;\r\nbl = devm_backlight_device_register(&pdev->dev, wled->name,\r\n&pdev->dev, wled,\r\n&pm8941_wled_ops, &props);\r\nreturn PTR_ERR_OR_ZERO(bl);\r\n}
