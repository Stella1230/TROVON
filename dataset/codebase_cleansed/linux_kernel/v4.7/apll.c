static int dra7_apll_enable(struct clk_hw *hw)\r\n{\r\nstruct clk_hw_omap *clk = to_clk_hw_omap(hw);\r\nint r = 0, i = 0;\r\nstruct dpll_data *ad;\r\nconst char *clk_name;\r\nu8 state = 1;\r\nu32 v;\r\nad = clk->dpll_data;\r\nif (!ad)\r\nreturn -EINVAL;\r\nclk_name = clk_hw_get_name(&clk->hw);\r\nstate <<= __ffs(ad->idlest_mask);\r\nv = ti_clk_ll_ops->clk_readl(ad->idlest_reg);\r\nif ((v & ad->idlest_mask) == state)\r\nreturn r;\r\nv = ti_clk_ll_ops->clk_readl(ad->control_reg);\r\nv &= ~ad->enable_mask;\r\nv |= APLL_FORCE_LOCK << __ffs(ad->enable_mask);\r\nti_clk_ll_ops->clk_writel(v, ad->control_reg);\r\nstate <<= __ffs(ad->idlest_mask);\r\nwhile (1) {\r\nv = ti_clk_ll_ops->clk_readl(ad->idlest_reg);\r\nif ((v & ad->idlest_mask) == state)\r\nbreak;\r\nif (i > MAX_APLL_WAIT_TRIES)\r\nbreak;\r\ni++;\r\nudelay(1);\r\n}\r\nif (i == MAX_APLL_WAIT_TRIES) {\r\npr_warn("clock: %s failed transition to '%s'\n",\r\nclk_name, (state) ? "locked" : "bypassed");\r\nr = -EBUSY;\r\n} else\r\npr_debug("clock: %s transition to '%s' in %d loops\n",\r\nclk_name, (state) ? "locked" : "bypassed", i);\r\nreturn r;\r\n}\r\nstatic void dra7_apll_disable(struct clk_hw *hw)\r\n{\r\nstruct clk_hw_omap *clk = to_clk_hw_omap(hw);\r\nstruct dpll_data *ad;\r\nu8 state = 1;\r\nu32 v;\r\nad = clk->dpll_data;\r\nstate <<= __ffs(ad->idlest_mask);\r\nv = ti_clk_ll_ops->clk_readl(ad->control_reg);\r\nv &= ~ad->enable_mask;\r\nv |= APLL_AUTO_IDLE << __ffs(ad->enable_mask);\r\nti_clk_ll_ops->clk_writel(v, ad->control_reg);\r\n}\r\nstatic int dra7_apll_is_enabled(struct clk_hw *hw)\r\n{\r\nstruct clk_hw_omap *clk = to_clk_hw_omap(hw);\r\nstruct dpll_data *ad;\r\nu32 v;\r\nad = clk->dpll_data;\r\nv = ti_clk_ll_ops->clk_readl(ad->control_reg);\r\nv &= ad->enable_mask;\r\nv >>= __ffs(ad->enable_mask);\r\nreturn v == APLL_AUTO_IDLE ? 0 : 1;\r\n}\r\nstatic u8 dra7_init_apll_parent(struct clk_hw *hw)\r\n{\r\nreturn 0;\r\n}\r\nstatic void __init omap_clk_register_apll(struct clk_hw *hw,\r\nstruct device_node *node)\r\n{\r\nstruct clk_hw_omap *clk_hw = to_clk_hw_omap(hw);\r\nstruct dpll_data *ad = clk_hw->dpll_data;\r\nstruct clk *clk;\r\nclk = of_clk_get(node, 0);\r\nif (IS_ERR(clk)) {\r\npr_debug("clk-ref for %s not ready, retry\n",\r\nnode->name);\r\nif (!ti_clk_retry_init(node, hw, omap_clk_register_apll))\r\nreturn;\r\ngoto cleanup;\r\n}\r\nad->clk_ref = __clk_get_hw(clk);\r\nclk = of_clk_get(node, 1);\r\nif (IS_ERR(clk)) {\r\npr_debug("clk-bypass for %s not ready, retry\n",\r\nnode->name);\r\nif (!ti_clk_retry_init(node, hw, omap_clk_register_apll))\r\nreturn;\r\ngoto cleanup;\r\n}\r\nad->clk_bypass = __clk_get_hw(clk);\r\nclk = clk_register(NULL, &clk_hw->hw);\r\nif (!IS_ERR(clk)) {\r\nof_clk_add_provider(node, of_clk_src_simple_get, clk);\r\nkfree(clk_hw->hw.init->parent_names);\r\nkfree(clk_hw->hw.init);\r\nreturn;\r\n}\r\ncleanup:\r\nkfree(clk_hw->dpll_data);\r\nkfree(clk_hw->hw.init->parent_names);\r\nkfree(clk_hw->hw.init);\r\nkfree(clk_hw);\r\n}\r\nstatic void __init of_dra7_apll_setup(struct device_node *node)\r\n{\r\nstruct dpll_data *ad = NULL;\r\nstruct clk_hw_omap *clk_hw = NULL;\r\nstruct clk_init_data *init = NULL;\r\nconst char **parent_names = NULL;\r\nad = kzalloc(sizeof(*ad), GFP_KERNEL);\r\nclk_hw = kzalloc(sizeof(*clk_hw), GFP_KERNEL);\r\ninit = kzalloc(sizeof(*init), GFP_KERNEL);\r\nif (!ad || !clk_hw || !init)\r\ngoto cleanup;\r\nclk_hw->dpll_data = ad;\r\nclk_hw->hw.init = init;\r\nclk_hw->flags = MEMMAP_ADDRESSING;\r\ninit->name = node->name;\r\ninit->ops = &apll_ck_ops;\r\ninit->num_parents = of_clk_get_parent_count(node);\r\nif (init->num_parents < 1) {\r\npr_err("dra7 apll %s must have parent(s)\n", node->name);\r\ngoto cleanup;\r\n}\r\nparent_names = kzalloc(sizeof(char *) * init->num_parents, GFP_KERNEL);\r\nif (!parent_names)\r\ngoto cleanup;\r\nof_clk_parent_fill(node, parent_names, init->num_parents);\r\ninit->parent_names = parent_names;\r\nad->control_reg = ti_clk_get_reg_addr(node, 0);\r\nad->idlest_reg = ti_clk_get_reg_addr(node, 1);\r\nif (IS_ERR(ad->control_reg) || IS_ERR(ad->idlest_reg))\r\ngoto cleanup;\r\nad->idlest_mask = 0x1;\r\nad->enable_mask = 0x3;\r\nomap_clk_register_apll(&clk_hw->hw, node);\r\nreturn;\r\ncleanup:\r\nkfree(parent_names);\r\nkfree(ad);\r\nkfree(clk_hw);\r\nkfree(init);\r\n}\r\nstatic int omap2_apll_is_enabled(struct clk_hw *hw)\r\n{\r\nstruct clk_hw_omap *clk = to_clk_hw_omap(hw);\r\nstruct dpll_data *ad = clk->dpll_data;\r\nu32 v;\r\nv = ti_clk_ll_ops->clk_readl(ad->control_reg);\r\nv &= ad->enable_mask;\r\nv >>= __ffs(ad->enable_mask);\r\nreturn v == OMAP2_EN_APLL_LOCKED ? 1 : 0;\r\n}\r\nstatic unsigned long omap2_apll_recalc(struct clk_hw *hw,\r\nunsigned long parent_rate)\r\n{\r\nstruct clk_hw_omap *clk = to_clk_hw_omap(hw);\r\nif (omap2_apll_is_enabled(hw))\r\nreturn clk->fixed_rate;\r\nreturn 0;\r\n}\r\nstatic int omap2_apll_enable(struct clk_hw *hw)\r\n{\r\nstruct clk_hw_omap *clk = to_clk_hw_omap(hw);\r\nstruct dpll_data *ad = clk->dpll_data;\r\nu32 v;\r\nint i = 0;\r\nv = ti_clk_ll_ops->clk_readl(ad->control_reg);\r\nv &= ~ad->enable_mask;\r\nv |= OMAP2_EN_APLL_LOCKED << __ffs(ad->enable_mask);\r\nti_clk_ll_ops->clk_writel(v, ad->control_reg);\r\nwhile (1) {\r\nv = ti_clk_ll_ops->clk_readl(ad->idlest_reg);\r\nif (v & ad->idlest_mask)\r\nbreak;\r\nif (i > MAX_APLL_WAIT_TRIES)\r\nbreak;\r\ni++;\r\nudelay(1);\r\n}\r\nif (i == MAX_APLL_WAIT_TRIES) {\r\npr_warn("%s failed to transition to locked\n",\r\nclk_hw_get_name(&clk->hw));\r\nreturn -EBUSY;\r\n}\r\nreturn 0;\r\n}\r\nstatic void omap2_apll_disable(struct clk_hw *hw)\r\n{\r\nstruct clk_hw_omap *clk = to_clk_hw_omap(hw);\r\nstruct dpll_data *ad = clk->dpll_data;\r\nu32 v;\r\nv = ti_clk_ll_ops->clk_readl(ad->control_reg);\r\nv &= ~ad->enable_mask;\r\nv |= OMAP2_EN_APLL_STOPPED << __ffs(ad->enable_mask);\r\nti_clk_ll_ops->clk_writel(v, ad->control_reg);\r\n}\r\nstatic void omap2_apll_set_autoidle(struct clk_hw_omap *clk, u32 val)\r\n{\r\nstruct dpll_data *ad = clk->dpll_data;\r\nu32 v;\r\nv = ti_clk_ll_ops->clk_readl(ad->autoidle_reg);\r\nv &= ~ad->autoidle_mask;\r\nv |= val << __ffs(ad->autoidle_mask);\r\nti_clk_ll_ops->clk_writel(v, ad->control_reg);\r\n}\r\nstatic void omap2_apll_allow_idle(struct clk_hw_omap *clk)\r\n{\r\nomap2_apll_set_autoidle(clk, OMAP2_APLL_AUTOIDLE_LOW_POWER_STOP);\r\n}\r\nstatic void omap2_apll_deny_idle(struct clk_hw_omap *clk)\r\n{\r\nomap2_apll_set_autoidle(clk, OMAP2_APLL_AUTOIDLE_DISABLE);\r\n}\r\nstatic void __init of_omap2_apll_setup(struct device_node *node)\r\n{\r\nstruct dpll_data *ad = NULL;\r\nstruct clk_hw_omap *clk_hw = NULL;\r\nstruct clk_init_data *init = NULL;\r\nstruct clk *clk;\r\nconst char *parent_name;\r\nu32 val;\r\nad = kzalloc(sizeof(*ad), GFP_KERNEL);\r\nclk_hw = kzalloc(sizeof(*clk_hw), GFP_KERNEL);\r\ninit = kzalloc(sizeof(*init), GFP_KERNEL);\r\nif (!ad || !clk_hw || !init)\r\ngoto cleanup;\r\nclk_hw->dpll_data = ad;\r\nclk_hw->hw.init = init;\r\ninit->ops = &omap2_apll_ops;\r\ninit->name = node->name;\r\nclk_hw->ops = &omap2_apll_hwops;\r\ninit->num_parents = of_clk_get_parent_count(node);\r\nif (init->num_parents != 1) {\r\npr_err("%s must have one parent\n", node->name);\r\ngoto cleanup;\r\n}\r\nparent_name = of_clk_get_parent_name(node, 0);\r\ninit->parent_names = &parent_name;\r\nif (of_property_read_u32(node, "ti,clock-frequency", &val)) {\r\npr_err("%s missing clock-frequency\n", node->name);\r\ngoto cleanup;\r\n}\r\nclk_hw->fixed_rate = val;\r\nif (of_property_read_u32(node, "ti,bit-shift", &val)) {\r\npr_err("%s missing bit-shift\n", node->name);\r\ngoto cleanup;\r\n}\r\nclk_hw->enable_bit = val;\r\nad->enable_mask = 0x3 << val;\r\nad->autoidle_mask = 0x3 << val;\r\nif (of_property_read_u32(node, "ti,idlest-shift", &val)) {\r\npr_err("%s missing idlest-shift\n", node->name);\r\ngoto cleanup;\r\n}\r\nad->idlest_mask = 1 << val;\r\nad->control_reg = ti_clk_get_reg_addr(node, 0);\r\nad->autoidle_reg = ti_clk_get_reg_addr(node, 1);\r\nad->idlest_reg = ti_clk_get_reg_addr(node, 2);\r\nif (IS_ERR(ad->control_reg) || IS_ERR(ad->autoidle_reg) ||\r\nIS_ERR(ad->idlest_reg))\r\ngoto cleanup;\r\nclk = clk_register(NULL, &clk_hw->hw);\r\nif (!IS_ERR(clk)) {\r\nof_clk_add_provider(node, of_clk_src_simple_get, clk);\r\nkfree(init);\r\nreturn;\r\n}\r\ncleanup:\r\nkfree(ad);\r\nkfree(clk_hw);\r\nkfree(init);\r\n}
