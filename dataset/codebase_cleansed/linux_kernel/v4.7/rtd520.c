static int rtd_ns_to_timer_base(unsigned int *nanosec,\r\nunsigned int flags, int base)\r\n{\r\nint divider;\r\nswitch (flags & CMDF_ROUND_MASK) {\r\ncase CMDF_ROUND_NEAREST:\r\ndefault:\r\ndivider = DIV_ROUND_CLOSEST(*nanosec, base);\r\nbreak;\r\ncase CMDF_ROUND_DOWN:\r\ndivider = (*nanosec) / base;\r\nbreak;\r\ncase CMDF_ROUND_UP:\r\ndivider = DIV_ROUND_UP(*nanosec, base);\r\nbreak;\r\n}\r\nif (divider < 2)\r\ndivider = 2;\r\n*nanosec = base * divider;\r\nreturn divider - 1;\r\n}\r\nstatic int rtd_ns_to_timer(unsigned int *ns, unsigned int flags)\r\n{\r\nreturn rtd_ns_to_timer_base(ns, flags, RTD_CLOCK_BASE);\r\n}\r\nstatic unsigned short rtd_convert_chan_gain(struct comedi_device *dev,\r\nunsigned int chanspec, int index)\r\n{\r\nconst struct rtd_boardinfo *board = dev->board_ptr;\r\nunsigned int chan = CR_CHAN(chanspec);\r\nunsigned int range = CR_RANGE(chanspec);\r\nunsigned int aref = CR_AREF(chanspec);\r\nunsigned short r = 0;\r\nr |= chan & 0xf;\r\nif (range < board->range_bip10) {\r\nr |= 0x000;\r\nr |= (range & 0x7) << 4;\r\n} else if (range < board->range_uni10) {\r\nr |= 0x100;\r\nr |= ((range - board->range_bip10) & 0x7) << 4;\r\n} else {\r\nr |= 0x200;\r\nr |= ((range - board->range_uni10) & 0x7) << 4;\r\n}\r\nswitch (aref) {\r\ncase AREF_GROUND:\r\nbreak;\r\ncase AREF_COMMON:\r\nr |= 0x80;\r\nbreak;\r\ncase AREF_DIFF:\r\nr |= 0x400;\r\nbreak;\r\ncase AREF_OTHER:\r\nbreak;\r\n}\r\nreturn r;\r\n}\r\nstatic void rtd_load_channelgain_list(struct comedi_device *dev,\r\nunsigned int n_chan, unsigned int *list)\r\n{\r\nif (n_chan > 1) {\r\nint ii;\r\nwritel(0, dev->mmio + LAS0_CGT_CLEAR);\r\nwritel(1, dev->mmio + LAS0_CGT_ENABLE);\r\nfor (ii = 0; ii < n_chan; ii++) {\r\nwritel(rtd_convert_chan_gain(dev, list[ii], ii),\r\ndev->mmio + LAS0_CGT_WRITE);\r\n}\r\n} else {\r\nwritel(0, dev->mmio + LAS0_CGT_ENABLE);\r\nwritel(rtd_convert_chan_gain(dev, list[0], 0),\r\ndev->mmio + LAS0_CGL_WRITE);\r\n}\r\n}\r\nstatic int rtd520_probe_fifo_depth(struct comedi_device *dev)\r\n{\r\nunsigned int chanspec = CR_PACK(0, 0, AREF_GROUND);\r\nunsigned i;\r\nstatic const unsigned limit = 0x2000;\r\nunsigned fifo_size = 0;\r\nwritel(0, dev->mmio + LAS0_ADC_FIFO_CLEAR);\r\nrtd_load_channelgain_list(dev, 1, &chanspec);\r\nwritel(0, dev->mmio + LAS0_ADC_CONVERSION);\r\nfor (i = 0; i < limit; ++i) {\r\nunsigned fifo_status;\r\nwritew(0, dev->mmio + LAS0_ADC);\r\nusleep_range(1, 1000);\r\nfifo_status = readl(dev->mmio + LAS0_ADC);\r\nif ((fifo_status & FS_ADC_HEMPTY) == 0) {\r\nfifo_size = 2 * i;\r\nbreak;\r\n}\r\n}\r\nif (i == limit) {\r\ndev_info(dev->class_dev, "failed to probe fifo size.\n");\r\nreturn -EIO;\r\n}\r\nwritel(0, dev->mmio + LAS0_ADC_FIFO_CLEAR);\r\nif (fifo_size != 0x400 && fifo_size != 0x2000) {\r\ndev_info(dev->class_dev,\r\n"unexpected fifo size of %i, expected 1024 or 8192.\n",\r\nfifo_size);\r\nreturn -EIO;\r\n}\r\nreturn fifo_size;\r\n}\r\nstatic int rtd_ai_eoc(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_insn *insn,\r\nunsigned long context)\r\n{\r\nunsigned int status;\r\nstatus = readl(dev->mmio + LAS0_ADC);\r\nif (status & FS_ADC_NOT_EMPTY)\r\nreturn 0;\r\nreturn -EBUSY;\r\n}\r\nstatic int rtd_ai_rinsn(struct comedi_device *dev,\r\nstruct comedi_subdevice *s, struct comedi_insn *insn,\r\nunsigned int *data)\r\n{\r\nstruct rtd_private *devpriv = dev->private;\r\nunsigned int range = CR_RANGE(insn->chanspec);\r\nint ret;\r\nint n;\r\nwritel(0, dev->mmio + LAS0_ADC_FIFO_CLEAR);\r\nrtd_load_channelgain_list(dev, 1, &insn->chanspec);\r\nwritel(0, dev->mmio + LAS0_ADC_CONVERSION);\r\nfor (n = 0; n < insn->n; n++) {\r\nunsigned short d;\r\nwritew(0, dev->mmio + LAS0_ADC);\r\nret = comedi_timeout(dev, s, insn, rtd_ai_eoc, 0);\r\nif (ret)\r\nreturn ret;\r\nd = readw(devpriv->las1 + LAS1_ADC_FIFO);\r\nd >>= 3;\r\nif (comedi_range_is_bipolar(s, range))\r\nd = comedi_offset_munge(s, d);\r\ndata[n] = d & s->maxdata;\r\n}\r\nreturn n;\r\n}\r\nstatic int ai_read_n(struct comedi_device *dev, struct comedi_subdevice *s,\r\nint count)\r\n{\r\nstruct rtd_private *devpriv = dev->private;\r\nstruct comedi_async *async = s->async;\r\nstruct comedi_cmd *cmd = &async->cmd;\r\nint ii;\r\nfor (ii = 0; ii < count; ii++) {\r\nunsigned int range = CR_RANGE(cmd->chanlist[async->cur_chan]);\r\nunsigned short d;\r\nif (devpriv->ai_count == 0) {\r\nd = readw(devpriv->las1 + LAS1_ADC_FIFO);\r\ncontinue;\r\n}\r\nd = readw(devpriv->las1 + LAS1_ADC_FIFO);\r\nd >>= 3;\r\nif (comedi_range_is_bipolar(s, range))\r\nd = comedi_offset_munge(s, d);\r\nd &= s->maxdata;\r\nif (!comedi_buf_write_samples(s, &d, 1))\r\nreturn -1;\r\nif (devpriv->ai_count > 0)\r\ndevpriv->ai_count--;\r\n}\r\nreturn 0;\r\n}\r\nstatic irqreturn_t rtd_interrupt(int irq, void *d)\r\n{\r\nstruct comedi_device *dev = d;\r\nstruct comedi_subdevice *s = dev->read_subdev;\r\nstruct rtd_private *devpriv = dev->private;\r\nu32 overrun;\r\nu16 status;\r\nu16 fifo_status;\r\nif (!dev->attached)\r\nreturn IRQ_NONE;\r\nfifo_status = readl(dev->mmio + LAS0_ADC);\r\nif (!(fifo_status & FS_ADC_NOT_FULL))\r\ngoto xfer_abort;\r\nstatus = readw(dev->mmio + LAS0_IT);\r\nif (status == 0)\r\nreturn IRQ_HANDLED;\r\nif (status & IRQM_ADC_ABOUT_CNT) {\r\nif (!(fifo_status & FS_ADC_HEMPTY)) {\r\nif (ai_read_n(dev, s, devpriv->fifosz / 2) < 0)\r\ngoto xfer_abort;\r\nif (devpriv->ai_count == 0)\r\ngoto xfer_done;\r\n} else if (devpriv->xfer_count > 0) {\r\nif (fifo_status & FS_ADC_NOT_EMPTY) {\r\nif (ai_read_n(dev, s, devpriv->xfer_count) < 0)\r\ngoto xfer_abort;\r\nif (devpriv->ai_count == 0)\r\ngoto xfer_done;\r\n}\r\n}\r\n}\r\noverrun = readl(dev->mmio + LAS0_OVERRUN) & 0xffff;\r\nif (overrun)\r\ngoto xfer_abort;\r\nwritew(status, dev->mmio + LAS0_CLEAR);\r\nreadw(dev->mmio + LAS0_CLEAR);\r\ncomedi_handle_events(dev, s);\r\nreturn IRQ_HANDLED;\r\nxfer_abort:\r\ns->async->events |= COMEDI_CB_ERROR;\r\nxfer_done:\r\ns->async->events |= COMEDI_CB_EOA;\r\nstatus = readw(dev->mmio + LAS0_IT);\r\nwritew(status, dev->mmio + LAS0_CLEAR);\r\nreadw(dev->mmio + LAS0_CLEAR);\r\nfifo_status = readl(dev->mmio + LAS0_ADC);\r\noverrun = readl(dev->mmio + LAS0_OVERRUN) & 0xffff;\r\ncomedi_handle_events(dev, s);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int rtd_ai_cmdtest(struct comedi_device *dev,\r\nstruct comedi_subdevice *s, struct comedi_cmd *cmd)\r\n{\r\nint err = 0;\r\nunsigned int arg;\r\nerr |= comedi_check_trigger_src(&cmd->start_src, TRIG_NOW);\r\nerr |= comedi_check_trigger_src(&cmd->scan_begin_src,\r\nTRIG_TIMER | TRIG_EXT);\r\nerr |= comedi_check_trigger_src(&cmd->convert_src,\r\nTRIG_TIMER | TRIG_EXT);\r\nerr |= comedi_check_trigger_src(&cmd->scan_end_src, TRIG_COUNT);\r\nerr |= comedi_check_trigger_src(&cmd->stop_src, TRIG_COUNT | TRIG_NONE);\r\nif (err)\r\nreturn 1;\r\nerr |= comedi_check_trigger_is_unique(cmd->scan_begin_src);\r\nerr |= comedi_check_trigger_is_unique(cmd->convert_src);\r\nerr |= comedi_check_trigger_is_unique(cmd->stop_src);\r\nif (err)\r\nreturn 2;\r\nerr |= comedi_check_trigger_arg_is(&cmd->start_arg, 0);\r\nif (cmd->scan_begin_src == TRIG_TIMER) {\r\nif (cmd->chanlist_len == 1) {\r\nif (comedi_check_trigger_arg_min(&cmd->scan_begin_arg,\r\nRTD_MAX_SPEED_1)) {\r\nrtd_ns_to_timer(&cmd->scan_begin_arg,\r\nCMDF_ROUND_UP);\r\nerr |= -EINVAL;\r\n}\r\nif (comedi_check_trigger_arg_max(&cmd->scan_begin_arg,\r\nRTD_MIN_SPEED_1)) {\r\nrtd_ns_to_timer(&cmd->scan_begin_arg,\r\nCMDF_ROUND_DOWN);\r\nerr |= -EINVAL;\r\n}\r\n} else {\r\nif (comedi_check_trigger_arg_min(&cmd->scan_begin_arg,\r\nRTD_MAX_SPEED)) {\r\nrtd_ns_to_timer(&cmd->scan_begin_arg,\r\nCMDF_ROUND_UP);\r\nerr |= -EINVAL;\r\n}\r\nif (comedi_check_trigger_arg_max(&cmd->scan_begin_arg,\r\nRTD_MIN_SPEED)) {\r\nrtd_ns_to_timer(&cmd->scan_begin_arg,\r\nCMDF_ROUND_DOWN);\r\nerr |= -EINVAL;\r\n}\r\n}\r\n} else {\r\nerr |= comedi_check_trigger_arg_max(&cmd->scan_begin_arg, 9);\r\n}\r\nif (cmd->convert_src == TRIG_TIMER) {\r\nif (cmd->chanlist_len == 1) {\r\nif (comedi_check_trigger_arg_min(&cmd->convert_arg,\r\nRTD_MAX_SPEED_1)) {\r\nrtd_ns_to_timer(&cmd->convert_arg,\r\nCMDF_ROUND_UP);\r\nerr |= -EINVAL;\r\n}\r\nif (comedi_check_trigger_arg_max(&cmd->convert_arg,\r\nRTD_MIN_SPEED_1)) {\r\nrtd_ns_to_timer(&cmd->convert_arg,\r\nCMDF_ROUND_DOWN);\r\nerr |= -EINVAL;\r\n}\r\n} else {\r\nif (comedi_check_trigger_arg_min(&cmd->convert_arg,\r\nRTD_MAX_SPEED)) {\r\nrtd_ns_to_timer(&cmd->convert_arg,\r\nCMDF_ROUND_UP);\r\nerr |= -EINVAL;\r\n}\r\nif (comedi_check_trigger_arg_max(&cmd->convert_arg,\r\nRTD_MIN_SPEED)) {\r\nrtd_ns_to_timer(&cmd->convert_arg,\r\nCMDF_ROUND_DOWN);\r\nerr |= -EINVAL;\r\n}\r\n}\r\n} else {\r\nerr |= comedi_check_trigger_arg_max(&cmd->convert_arg, 9);\r\n}\r\nerr |= comedi_check_trigger_arg_is(&cmd->scan_end_arg,\r\ncmd->chanlist_len);\r\nif (cmd->stop_src == TRIG_COUNT)\r\nerr |= comedi_check_trigger_arg_min(&cmd->stop_arg, 1);\r\nelse\r\nerr |= comedi_check_trigger_arg_is(&cmd->stop_arg, 0);\r\nif (err)\r\nreturn 3;\r\nif (cmd->scan_begin_src == TRIG_TIMER) {\r\narg = cmd->scan_begin_arg;\r\nrtd_ns_to_timer(&arg, cmd->flags);\r\nerr |= comedi_check_trigger_arg_is(&cmd->scan_begin_arg, arg);\r\n}\r\nif (cmd->convert_src == TRIG_TIMER) {\r\narg = cmd->convert_arg;\r\nrtd_ns_to_timer(&arg, cmd->flags);\r\nerr |= comedi_check_trigger_arg_is(&cmd->convert_arg, arg);\r\nif (cmd->scan_begin_src == TRIG_TIMER) {\r\narg = cmd->convert_arg * cmd->scan_end_arg;\r\nerr |= comedi_check_trigger_arg_min(&cmd->\r\nscan_begin_arg,\r\narg);\r\n}\r\n}\r\nif (err)\r\nreturn 4;\r\nreturn 0;\r\n}\r\nstatic int rtd_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)\r\n{\r\nstruct rtd_private *devpriv = dev->private;\r\nstruct comedi_cmd *cmd = &s->async->cmd;\r\nint timer;\r\nwritel(0, dev->mmio + LAS0_PACER_STOP);\r\nwritel(0, dev->mmio + LAS0_PACER);\r\nwritel(0, dev->mmio + LAS0_ADC_CONVERSION);\r\nwritew(0, dev->mmio + LAS0_IT);\r\nwritel(0, dev->mmio + LAS0_ADC_FIFO_CLEAR);\r\nwritel(0, dev->mmio + LAS0_OVERRUN);\r\nrtd_load_channelgain_list(dev, cmd->chanlist_len, cmd->chanlist);\r\nif (cmd->chanlist_len > 1) {\r\nwritel(0, dev->mmio + LAS0_PACER_START);\r\nwritel(1, dev->mmio + LAS0_BURST_START);\r\nwritel(2, dev->mmio + LAS0_ADC_CONVERSION);\r\n} else {\r\nwritel(0, dev->mmio + LAS0_PACER_START);\r\nwritel(1, dev->mmio + LAS0_ADC_CONVERSION);\r\n}\r\nwritel((devpriv->fifosz / 2 - 1) & 0xffff, dev->mmio + LAS0_ACNT);\r\nif (cmd->scan_begin_src == TRIG_TIMER) {\r\nif (cmd->flags & CMDF_WAKE_EOS) {\r\ndevpriv->xfer_count = cmd->chanlist_len;\r\ndevpriv->flags |= SEND_EOS;\r\n} else {\r\ndevpriv->xfer_count =\r\n(TRANS_TARGET_PERIOD * cmd->chanlist_len) /\r\ncmd->scan_begin_arg;\r\nif (devpriv->xfer_count < cmd->chanlist_len) {\r\ndevpriv->xfer_count = cmd->chanlist_len;\r\n} else {\r\ndevpriv->xfer_count =\r\nDIV_ROUND_UP(devpriv->xfer_count,\r\ncmd->chanlist_len);\r\ndevpriv->xfer_count *= cmd->chanlist_len;\r\n}\r\ndevpriv->flags |= SEND_EOS;\r\n}\r\nif (devpriv->xfer_count >= (devpriv->fifosz / 2)) {\r\ndevpriv->xfer_count = 0;\r\ndevpriv->flags &= ~SEND_EOS;\r\n} else {\r\nwritel((devpriv->xfer_count - 1) & 0xffff,\r\ndev->mmio + LAS0_ACNT);\r\n}\r\n} else {\r\ndevpriv->xfer_count = 0;\r\ndevpriv->flags &= ~SEND_EOS;\r\n}\r\nwritel(1, dev->mmio + LAS0_PACER_SELECT);\r\nwritel(1, dev->mmio + LAS0_ACNT_STOP_ENABLE);\r\nswitch (cmd->stop_src) {\r\ncase TRIG_COUNT:\r\ndevpriv->ai_count = cmd->stop_arg * cmd->chanlist_len;\r\nif ((devpriv->xfer_count > 0) &&\r\n(devpriv->xfer_count > devpriv->ai_count)) {\r\ndevpriv->xfer_count = devpriv->ai_count;\r\n}\r\nbreak;\r\ncase TRIG_NONE:\r\ndevpriv->ai_count = -1;\r\nbreak;\r\n}\r\nswitch (cmd->scan_begin_src) {\r\ncase TRIG_TIMER:\r\ntimer = rtd_ns_to_timer(&cmd->scan_begin_arg,\r\nCMDF_ROUND_NEAREST);\r\nwritel(timer & 0xffffff, dev->mmio + LAS0_PCLK);\r\nbreak;\r\ncase TRIG_EXT:\r\nwritel(1, dev->mmio + LAS0_PACER_START);\r\nbreak;\r\n}\r\nswitch (cmd->convert_src) {\r\ncase TRIG_TIMER:\r\nif (cmd->chanlist_len > 1) {\r\ntimer = rtd_ns_to_timer(&cmd->convert_arg,\r\nCMDF_ROUND_NEAREST);\r\nwritel(timer & 0x3ff, dev->mmio + LAS0_BCLK);\r\n}\r\nbreak;\r\ncase TRIG_EXT:\r\nwritel(2, dev->mmio + LAS0_BURST_START);\r\nbreak;\r\n}\r\nwritew(~0, dev->mmio + LAS0_CLEAR);\r\nreadw(dev->mmio + LAS0_CLEAR);\r\nwritew(IRQM_ADC_ABOUT_CNT, dev->mmio + LAS0_IT);\r\nreadl(dev->mmio + LAS0_PACER);\r\nreturn 0;\r\n}\r\nstatic int rtd_ai_cancel(struct comedi_device *dev, struct comedi_subdevice *s)\r\n{\r\nstruct rtd_private *devpriv = dev->private;\r\nwritel(0, dev->mmio + LAS0_PACER_STOP);\r\nwritel(0, dev->mmio + LAS0_PACER);\r\nwritel(0, dev->mmio + LAS0_ADC_CONVERSION);\r\nwritew(0, dev->mmio + LAS0_IT);\r\ndevpriv->ai_count = 0;\r\nwritel(0, dev->mmio + LAS0_ADC_FIFO_CLEAR);\r\nreturn 0;\r\n}\r\nstatic int rtd_ao_eoc(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_insn *insn,\r\nunsigned long context)\r\n{\r\nunsigned int chan = CR_CHAN(insn->chanspec);\r\nunsigned int bit = (chan == 0) ? FS_DAC1_NOT_EMPTY : FS_DAC2_NOT_EMPTY;\r\nunsigned int status;\r\nstatus = readl(dev->mmio + LAS0_ADC);\r\nif (status & bit)\r\nreturn 0;\r\nreturn -EBUSY;\r\n}\r\nstatic int rtd_ao_insn_write(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_insn *insn,\r\nunsigned int *data)\r\n{\r\nstruct rtd_private *devpriv = dev->private;\r\nunsigned int chan = CR_CHAN(insn->chanspec);\r\nunsigned int range = CR_RANGE(insn->chanspec);\r\nint ret;\r\nint i;\r\nwritew(range & 7, dev->mmio + LAS0_DAC_CTRL(chan));\r\nfor (i = 0; i < insn->n; ++i) {\r\nunsigned int val = data[i];\r\nif (comedi_range_is_bipolar(s, range)) {\r\nval = comedi_offset_munge(s, val);\r\nval |= (val & ((s->maxdata + 1) >> 1)) << 1;\r\n}\r\nval <<= 3;\r\nwritew(val, devpriv->las1 + LAS1_DAC_FIFO(chan));\r\nwritew(0, dev->mmio + LAS0_UPDATE_DAC(chan));\r\nret = comedi_timeout(dev, s, insn, rtd_ao_eoc, 0);\r\nif (ret)\r\nreturn ret;\r\ns->readback[chan] = data[i];\r\n}\r\nreturn insn->n;\r\n}\r\nstatic int rtd_dio_insn_bits(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_insn *insn,\r\nunsigned int *data)\r\n{\r\nif (comedi_dio_update_state(s, data))\r\nwritew(s->state & 0xff, dev->mmio + LAS0_DIO0);\r\ndata[1] = readw(dev->mmio + LAS0_DIO0) & 0xff;\r\nreturn insn->n;\r\n}\r\nstatic int rtd_dio_insn_config(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_insn *insn,\r\nunsigned int *data)\r\n{\r\nint ret;\r\nret = comedi_dio_insn_config(dev, s, insn, data, 0);\r\nif (ret)\r\nreturn ret;\r\nwritew(0x01, dev->mmio + LAS0_DIO_STATUS);\r\nwritew(s->io_bits & 0xff, dev->mmio + LAS0_DIO0_CTRL);\r\nwritew(0x00, dev->mmio + LAS0_DIO_STATUS);\r\nreturn insn->n;\r\n}\r\nstatic int rtd_counter_insn_config(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_insn *insn,\r\nunsigned int *data)\r\n{\r\nstruct rtd_private *devpriv = dev->private;\r\nunsigned int chan = CR_CHAN(insn->chanspec);\r\nunsigned int max_src;\r\nunsigned int src;\r\nswitch (data[0]) {\r\ncase INSN_CONFIG_SET_GATE_SRC:\r\nsrc = data[2];\r\nmax_src = (chan == 0) ? 3 : 4;\r\nif (src > max_src)\r\nreturn -EINVAL;\r\ndevpriv->timer_gate_src[chan] = src;\r\nwriteb(src, dev->mmio + LAS0_8254_GATE_SEL(chan));\r\nbreak;\r\ncase INSN_CONFIG_GET_GATE_SRC:\r\ndata[2] = devpriv->timer_gate_src[chan];\r\nbreak;\r\ncase INSN_CONFIG_SET_CLOCK_SRC:\r\nsrc = data[1];\r\nswitch (chan) {\r\ncase 0:\r\nmax_src = 3;\r\nbreak;\r\ncase 1:\r\nmax_src = 5;\r\nbreak;\r\ncase 2:\r\nmax_src = 4;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nif (src > max_src)\r\nreturn -EINVAL;\r\ndevpriv->timer_clk_src[chan] = src;\r\nwriteb(src, dev->mmio + LAS0_8254_CLK_SEL(chan));\r\nbreak;\r\ncase INSN_CONFIG_GET_CLOCK_SRC:\r\nsrc = devpriv->timer_clk_src[chan];\r\ndata[1] = devpriv->timer_clk_src[chan];\r\ndata[2] = (src == 0) ? RTD_CLOCK_BASE : 0;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn insn->n;\r\n}\r\nstatic void rtd_reset(struct comedi_device *dev)\r\n{\r\nstruct rtd_private *devpriv = dev->private;\r\nwritel(0, dev->mmio + LAS0_BOARD_RESET);\r\nusleep_range(100, 1000);\r\nwritel(0, devpriv->lcfg + PLX_INTRCS_REG);\r\nwritew(0, dev->mmio + LAS0_IT);\r\nwritew(~0, dev->mmio + LAS0_CLEAR);\r\nreadw(dev->mmio + LAS0_CLEAR);\r\n}\r\nstatic void rtd_init_board(struct comedi_device *dev)\r\n{\r\nrtd_reset(dev);\r\nwritel(0, dev->mmio + LAS0_OVERRUN);\r\nwritel(0, dev->mmio + LAS0_CGT_CLEAR);\r\nwritel(0, dev->mmio + LAS0_ADC_FIFO_CLEAR);\r\nwritel(0, dev->mmio + LAS0_DAC_RESET(0));\r\nwritel(0, dev->mmio + LAS0_DAC_RESET(1));\r\nwritew(0, dev->mmio + LAS0_DIO_STATUS);\r\n}\r\nstatic void rtd_pci_latency_quirk(struct comedi_device *dev,\r\nstruct pci_dev *pcidev)\r\n{\r\nunsigned char pci_latency;\r\npci_read_config_byte(pcidev, PCI_LATENCY_TIMER, &pci_latency);\r\nif (pci_latency < 32) {\r\ndev_info(dev->class_dev,\r\n"PCI latency changed from %d to %d\n",\r\npci_latency, 32);\r\npci_write_config_byte(pcidev, PCI_LATENCY_TIMER, 32);\r\n}\r\n}\r\nstatic int rtd_auto_attach(struct comedi_device *dev,\r\nunsigned long context)\r\n{\r\nstruct pci_dev *pcidev = comedi_to_pci_dev(dev);\r\nconst struct rtd_boardinfo *board = NULL;\r\nstruct rtd_private *devpriv;\r\nstruct comedi_subdevice *s;\r\nint ret;\r\nif (context < ARRAY_SIZE(rtd520_boards))\r\nboard = &rtd520_boards[context];\r\nif (!board)\r\nreturn -ENODEV;\r\ndev->board_ptr = board;\r\ndev->board_name = board->name;\r\ndevpriv = comedi_alloc_devpriv(dev, sizeof(*devpriv));\r\nif (!devpriv)\r\nreturn -ENOMEM;\r\nret = comedi_pci_enable(dev);\r\nif (ret)\r\nreturn ret;\r\ndev->mmio = pci_ioremap_bar(pcidev, 2);\r\ndevpriv->las1 = pci_ioremap_bar(pcidev, 3);\r\ndevpriv->lcfg = pci_ioremap_bar(pcidev, 0);\r\nif (!dev->mmio || !devpriv->las1 || !devpriv->lcfg)\r\nreturn -ENOMEM;\r\nrtd_pci_latency_quirk(dev, pcidev);\r\nif (pcidev->irq) {\r\nret = request_irq(pcidev->irq, rtd_interrupt, IRQF_SHARED,\r\ndev->board_name, dev);\r\nif (ret == 0)\r\ndev->irq = pcidev->irq;\r\n}\r\nret = comedi_alloc_subdevices(dev, 4);\r\nif (ret)\r\nreturn ret;\r\ns = &dev->subdevices[0];\r\ns->type = COMEDI_SUBD_AI;\r\ns->subdev_flags = SDF_READABLE | SDF_GROUND | SDF_COMMON | SDF_DIFF;\r\ns->n_chan = 16;\r\ns->maxdata = 0x0fff;\r\ns->range_table = board->ai_range;\r\ns->len_chanlist = RTD_MAX_CHANLIST;\r\ns->insn_read = rtd_ai_rinsn;\r\nif (dev->irq) {\r\ndev->read_subdev = s;\r\ns->subdev_flags |= SDF_CMD_READ;\r\ns->do_cmd = rtd_ai_cmd;\r\ns->do_cmdtest = rtd_ai_cmdtest;\r\ns->cancel = rtd_ai_cancel;\r\n}\r\ns = &dev->subdevices[1];\r\ns->type = COMEDI_SUBD_AO;\r\ns->subdev_flags = SDF_WRITABLE;\r\ns->n_chan = 2;\r\ns->maxdata = 0x0fff;\r\ns->range_table = &rtd_ao_range;\r\ns->insn_write = rtd_ao_insn_write;\r\nret = comedi_alloc_subdev_readback(s);\r\nif (ret)\r\nreturn ret;\r\ns = &dev->subdevices[2];\r\ns->type = COMEDI_SUBD_DIO;\r\ns->subdev_flags = SDF_READABLE | SDF_WRITABLE;\r\ns->n_chan = 8;\r\ns->maxdata = 1;\r\ns->range_table = &range_digital;\r\ns->insn_bits = rtd_dio_insn_bits;\r\ns->insn_config = rtd_dio_insn_config;\r\ns = &dev->subdevices[3];\r\ndev->pacer = comedi_8254_mm_init(dev->mmio + LAS0_8254_TIMER_BASE,\r\nRTD_CLOCK_BASE, I8254_IO8, 2);\r\nif (!dev->pacer)\r\nreturn -ENOMEM;\r\ncomedi_8254_subdevice_init(s, dev->pacer);\r\ndev->pacer->insn_config = rtd_counter_insn_config;\r\nrtd_init_board(dev);\r\nret = rtd520_probe_fifo_depth(dev);\r\nif (ret < 0)\r\nreturn ret;\r\ndevpriv->fifosz = ret;\r\nif (dev->irq)\r\nwritel(ICS_PIE | ICS_PLIE, devpriv->lcfg + PLX_INTRCS_REG);\r\nreturn 0;\r\n}\r\nstatic void rtd_detach(struct comedi_device *dev)\r\n{\r\nstruct rtd_private *devpriv = dev->private;\r\nif (devpriv) {\r\nif (dev->mmio && devpriv->lcfg)\r\nrtd_reset(dev);\r\nif (dev->irq)\r\nfree_irq(dev->irq, dev);\r\nif (dev->mmio)\r\niounmap(dev->mmio);\r\nif (devpriv->las1)\r\niounmap(devpriv->las1);\r\nif (devpriv->lcfg)\r\niounmap(devpriv->lcfg);\r\n}\r\ncomedi_pci_disable(dev);\r\n}\r\nstatic int rtd520_pci_probe(struct pci_dev *dev,\r\nconst struct pci_device_id *id)\r\n{\r\nreturn comedi_pci_auto_config(dev, &rtd520_driver, id->driver_data);\r\n}
