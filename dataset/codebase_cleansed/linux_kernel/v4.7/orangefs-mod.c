static int __init orangefs_init(void)\r\n{\r\nint ret = -1;\r\n__u32 i = 0;\r\ngossip_debug_mask = (unsigned long long) module_parm_debug_mask;\r\ndebug_mask_to_string(&gossip_debug_mask, 0);\r\ndebug_string_to_mask(kernel_debug_string, &gossip_debug_mask, 0);\r\nif (gossip_debug_mask != 0)\r\nkernel_mask_set_mod_init = true;\r\npr_info("%s: called with debug mask: :%s: :%llx:\n",\r\n__func__,\r\nkernel_debug_string,\r\n(unsigned long long)gossip_debug_mask);\r\nret = bdi_init(&orangefs_backing_dev_info);\r\nif (ret)\r\nreturn ret;\r\nif (op_timeout_secs < 0)\r\nop_timeout_secs = 0;\r\nif (slot_timeout_secs < 0)\r\nslot_timeout_secs = 0;\r\nret = op_cache_initialize();\r\nif (ret < 0)\r\ngoto err;\r\nret = orangefs_inode_cache_initialize();\r\nif (ret < 0)\r\ngoto cleanup_op;\r\nhtable_ops_in_progress =\r\nkcalloc(hash_table_size, sizeof(struct list_head), GFP_KERNEL);\r\nif (!htable_ops_in_progress) {\r\ngossip_err("Failed to initialize op hashtable");\r\nret = -ENOMEM;\r\ngoto cleanup_inode;\r\n}\r\nfor (i = 0; i < hash_table_size; i++)\r\nINIT_LIST_HEAD(&htable_ops_in_progress[i]);\r\nret = fsid_key_table_initialize();\r\nif (ret < 0)\r\ngoto cleanup_progress_table;\r\nret = orangefs_prepare_debugfs_help_string(1);\r\nif (ret)\r\ngoto cleanup_key_table;\r\nret = orangefs_debugfs_init();\r\nif (ret)\r\ngoto debugfs_init_failed;\r\nret = orangefs_kernel_debug_init();\r\nif (ret)\r\ngoto kernel_debug_init_failed;\r\nret = orangefs_sysfs_init();\r\nif (ret)\r\ngoto sysfs_init_failed;\r\nret = orangefs_dev_init();\r\nif (ret < 0) {\r\ngossip_err("%s: could not initialize device subsystem %d!\n",\r\n__func__,\r\nret);\r\ngoto cleanup_device;\r\n}\r\nret = register_filesystem(&orangefs_fs_type);\r\nif (ret == 0) {\r\npr_info("orangefs: module version %s loaded\n", ORANGEFS_VERSION);\r\nret = 0;\r\ngoto out;\r\n}\r\norangefs_sysfs_exit();\r\ncleanup_device:\r\norangefs_dev_cleanup();\r\nsysfs_init_failed:\r\nkernel_debug_init_failed:\r\ndebugfs_init_failed:\r\norangefs_debugfs_cleanup();\r\ncleanup_key_table:\r\nfsid_key_table_finalize();\r\ncleanup_progress_table:\r\nkfree(htable_ops_in_progress);\r\ncleanup_inode:\r\norangefs_inode_cache_finalize();\r\ncleanup_op:\r\nop_cache_finalize();\r\nerr:\r\nbdi_destroy(&orangefs_backing_dev_info);\r\nout:\r\nreturn ret;\r\n}\r\nstatic void __exit orangefs_exit(void)\r\n{\r\nint i = 0;\r\ngossip_debug(GOSSIP_INIT_DEBUG, "orangefs: orangefs_exit called\n");\r\nunregister_filesystem(&orangefs_fs_type);\r\norangefs_debugfs_cleanup();\r\norangefs_sysfs_exit();\r\nfsid_key_table_finalize();\r\norangefs_dev_cleanup();\r\nBUG_ON(!list_empty(&orangefs_request_list));\r\nfor (i = 0; i < hash_table_size; i++)\r\nBUG_ON(!list_empty(&htable_ops_in_progress[i]));\r\norangefs_inode_cache_finalize();\r\nop_cache_finalize();\r\nkfree(htable_ops_in_progress);\r\nbdi_destroy(&orangefs_backing_dev_info);\r\npr_info("orangefs: module version %s unloaded\n", ORANGEFS_VERSION);\r\n}\r\nvoid purge_inprogress_ops(void)\r\n{\r\nint i;\r\nfor (i = 0; i < hash_table_size; i++) {\r\nstruct orangefs_kernel_op_s *op;\r\nstruct orangefs_kernel_op_s *next;\r\nspin_lock(&htable_ops_in_progress_lock);\r\nlist_for_each_entry_safe(op,\r\nnext,\r\n&htable_ops_in_progress[i],\r\nlist) {\r\nset_op_state_purged(op);\r\ngossip_debug(GOSSIP_DEV_DEBUG,\r\n"%s: op:%s: op_state:%d: process:%s:\n",\r\n__func__,\r\nget_opname_string(op),\r\nop->op_state,\r\ncurrent->comm);\r\n}\r\nspin_unlock(&htable_ops_in_progress_lock);\r\n}\r\n}
