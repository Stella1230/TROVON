static void ath9k_reset_beacon_status(struct ath_softc *sc)\r\n{\r\nsc->beacon.tx_processed = false;\r\nsc->beacon.tx_last = false;\r\n}\r\nstatic void ath9k_beaconq_config(struct ath_softc *sc)\r\n{\r\nstruct ath_hw *ah = sc->sc_ah;\r\nstruct ath_common *common = ath9k_hw_common(ah);\r\nstruct ath9k_tx_queue_info qi, qi_be;\r\nstruct ath_txq *txq;\r\nath9k_hw_get_txq_props(ah, sc->beacon.beaconq, &qi);\r\nif (sc->sc_ah->opmode == NL80211_IFTYPE_AP ||\r\nsc->sc_ah->opmode == NL80211_IFTYPE_MESH_POINT) {\r\nqi.tqi_aifs = 1;\r\nqi.tqi_cwmin = 0;\r\nqi.tqi_cwmax = 0;\r\n} else {\r\ntxq = sc->tx.txq_map[IEEE80211_AC_BE];\r\nath9k_hw_get_txq_props(ah, txq->axq_qnum, &qi_be);\r\nqi.tqi_aifs = qi_be.tqi_aifs;\r\nif (ah->slottime == ATH9K_SLOT_TIME_20)\r\nqi.tqi_cwmin = 2*qi_be.tqi_cwmin;\r\nelse\r\nqi.tqi_cwmin = 4*qi_be.tqi_cwmin;\r\nqi.tqi_cwmax = qi_be.tqi_cwmax;\r\n}\r\nif (!ath9k_hw_set_txq_props(ah, sc->beacon.beaconq, &qi)) {\r\nath_err(common, "Unable to update h/w beacon queue parameters\n");\r\n} else {\r\nath9k_hw_resettxqueue(ah, sc->beacon.beaconq);\r\n}\r\n}\r\nstatic void ath9k_beacon_setup(struct ath_softc *sc, struct ieee80211_vif *vif,\r\nstruct ath_buf *bf, int rateidx)\r\n{\r\nstruct sk_buff *skb = bf->bf_mpdu;\r\nstruct ath_hw *ah = sc->sc_ah;\r\nstruct ath_common *common = ath9k_hw_common(ah);\r\nstruct ath_tx_info info;\r\nstruct ieee80211_supported_band *sband;\r\nu8 chainmask = ah->txchainmask;\r\nu8 i, rate = 0;\r\nsband = &common->sbands[sc->cur_chandef.chan->band];\r\nrate = sband->bitrates[rateidx].hw_value;\r\nif (vif->bss_conf.use_short_preamble)\r\nrate |= sband->bitrates[rateidx].hw_value_short;\r\nmemset(&info, 0, sizeof(info));\r\ninfo.pkt_len = skb->len + FCS_LEN;\r\ninfo.type = ATH9K_PKT_TYPE_BEACON;\r\nfor (i = 0; i < 4; i++)\r\ninfo.txpower[i] = MAX_RATE_POWER;\r\ninfo.keyix = ATH9K_TXKEYIX_INVALID;\r\ninfo.keytype = ATH9K_KEY_TYPE_CLEAR;\r\ninfo.flags = ATH9K_TXDESC_NOACK | ATH9K_TXDESC_CLRDMASK;\r\ninfo.buf_addr[0] = bf->bf_buf_addr;\r\ninfo.buf_len[0] = roundup(skb->len, 4);\r\ninfo.is_first = true;\r\ninfo.is_last = true;\r\ninfo.qcu = sc->beacon.beaconq;\r\ninfo.rates[0].Tries = 1;\r\ninfo.rates[0].Rate = rate;\r\ninfo.rates[0].ChSel = ath_txchainmask_reduction(sc, chainmask, rate);\r\nath9k_hw_set_txdesc(ah, bf->bf_desc, &info);\r\n}\r\nstatic struct ath_buf *ath9k_beacon_generate(struct ieee80211_hw *hw,\r\nstruct ieee80211_vif *vif)\r\n{\r\nstruct ath_softc *sc = hw->priv;\r\nstruct ath_common *common = ath9k_hw_common(sc->sc_ah);\r\nstruct ath_buf *bf;\r\nstruct ath_vif *avp = (void *)vif->drv_priv;\r\nstruct sk_buff *skb;\r\nstruct ath_txq *cabq = sc->beacon.cabq;\r\nstruct ieee80211_tx_info *info;\r\nstruct ieee80211_mgmt *mgmt_hdr;\r\nint cabq_depth;\r\nif (avp->av_bcbuf == NULL)\r\nreturn NULL;\r\nbf = avp->av_bcbuf;\r\nskb = bf->bf_mpdu;\r\nif (skb) {\r\ndma_unmap_single(sc->dev, bf->bf_buf_addr,\r\nskb->len, DMA_TO_DEVICE);\r\ndev_kfree_skb_any(skb);\r\nbf->bf_buf_addr = 0;\r\nbf->bf_mpdu = NULL;\r\n}\r\nskb = ieee80211_beacon_get(hw, vif);\r\nif (skb == NULL)\r\nreturn NULL;\r\nbf->bf_mpdu = skb;\r\nmgmt_hdr = (struct ieee80211_mgmt *)skb->data;\r\nmgmt_hdr->u.beacon.timestamp = avp->tsf_adjust;\r\ninfo = IEEE80211_SKB_CB(skb);\r\nath_assign_seq(common, skb);\r\nif (ath9k_is_chanctx_enabled())\r\nath9k_beacon_add_noa(sc, avp, skb);\r\nbf->bf_buf_addr = dma_map_single(sc->dev, skb->data,\r\nskb->len, DMA_TO_DEVICE);\r\nif (unlikely(dma_mapping_error(sc->dev, bf->bf_buf_addr))) {\r\ndev_kfree_skb_any(skb);\r\nbf->bf_mpdu = NULL;\r\nbf->bf_buf_addr = 0;\r\nath_err(common, "dma_mapping_error on beaconing\n");\r\nreturn NULL;\r\n}\r\nskb = ieee80211_get_buffered_bc(hw, vif);\r\nspin_lock_bh(&cabq->axq_lock);\r\ncabq_depth = cabq->axq_depth;\r\nspin_unlock_bh(&cabq->axq_lock);\r\nif (skb && cabq_depth) {\r\nif (sc->cur_chan->nvifs > 1) {\r\nath_dbg(common, BEACON,\r\n"Flushing previous cabq traffic\n");\r\nath_draintxq(sc, cabq);\r\n}\r\n}\r\nath9k_beacon_setup(sc, vif, bf, info->control.rates[0].idx);\r\nif (skb)\r\nath_tx_cabq(hw, vif, skb);\r\nreturn bf;\r\n}\r\nvoid ath9k_beacon_assign_slot(struct ath_softc *sc, struct ieee80211_vif *vif)\r\n{\r\nstruct ath_common *common = ath9k_hw_common(sc->sc_ah);\r\nstruct ath_vif *avp = (void *)vif->drv_priv;\r\nint slot;\r\navp->av_bcbuf = list_first_entry(&sc->beacon.bbuf, struct ath_buf, list);\r\nlist_del(&avp->av_bcbuf->list);\r\nfor (slot = 0; slot < ATH_BCBUF; slot++) {\r\nif (sc->beacon.bslot[slot] == NULL) {\r\navp->av_bslot = slot;\r\nbreak;\r\n}\r\n}\r\nsc->beacon.bslot[avp->av_bslot] = vif;\r\nsc->nbcnvifs++;\r\nath_dbg(common, CONFIG, "Added interface at beacon slot: %d\n",\r\navp->av_bslot);\r\n}\r\nvoid ath9k_beacon_remove_slot(struct ath_softc *sc, struct ieee80211_vif *vif)\r\n{\r\nstruct ath_common *common = ath9k_hw_common(sc->sc_ah);\r\nstruct ath_vif *avp = (void *)vif->drv_priv;\r\nstruct ath_buf *bf = avp->av_bcbuf;\r\nstruct ath_beacon_config *cur_conf = &sc->cur_chan->beacon;\r\nath_dbg(common, CONFIG, "Removing interface at beacon slot: %d\n",\r\navp->av_bslot);\r\ntasklet_disable(&sc->bcon_tasklet);\r\ncur_conf->enable_beacon &= ~BIT(avp->av_bslot);\r\nif (bf && bf->bf_mpdu) {\r\nstruct sk_buff *skb = bf->bf_mpdu;\r\ndma_unmap_single(sc->dev, bf->bf_buf_addr,\r\nskb->len, DMA_TO_DEVICE);\r\ndev_kfree_skb_any(skb);\r\nbf->bf_mpdu = NULL;\r\nbf->bf_buf_addr = 0;\r\n}\r\navp->av_bcbuf = NULL;\r\nsc->beacon.bslot[avp->av_bslot] = NULL;\r\nsc->nbcnvifs--;\r\nlist_add_tail(&bf->list, &sc->beacon.bbuf);\r\ntasklet_enable(&sc->bcon_tasklet);\r\n}\r\nstatic int ath9k_beacon_choose_slot(struct ath_softc *sc)\r\n{\r\nstruct ath_common *common = ath9k_hw_common(sc->sc_ah);\r\nstruct ath_beacon_config *cur_conf = &sc->cur_chan->beacon;\r\nu16 intval;\r\nu32 tsftu;\r\nu64 tsf;\r\nint slot;\r\nif (sc->sc_ah->opmode != NL80211_IFTYPE_AP &&\r\nsc->sc_ah->opmode != NL80211_IFTYPE_MESH_POINT) {\r\nath_dbg(common, BEACON, "slot 0, tsf: %llu\n",\r\nath9k_hw_gettsf64(sc->sc_ah));\r\nreturn 0;\r\n}\r\nintval = cur_conf->beacon_interval ? : ATH_DEFAULT_BINTVAL;\r\ntsf = ath9k_hw_gettsf64(sc->sc_ah);\r\ntsf += TU_TO_USEC(sc->sc_ah->config.sw_beacon_response_time);\r\ntsftu = TSF_TO_TU((tsf * ATH_BCBUF) >>32, tsf * ATH_BCBUF);\r\nslot = (tsftu % (intval * ATH_BCBUF)) / intval;\r\nath_dbg(common, BEACON, "slot: %d tsf: %llu tsftu: %u\n",\r\nslot, tsf, tsftu / ATH_BCBUF);\r\nreturn slot;\r\n}\r\nstatic void ath9k_set_tsfadjust(struct ath_softc *sc, struct ieee80211_vif *vif)\r\n{\r\nstruct ath_common *common = ath9k_hw_common(sc->sc_ah);\r\nstruct ath_vif *avp = (void *)vif->drv_priv;\r\nstruct ath_beacon_config *cur_conf = &avp->chanctx->beacon;\r\nu32 tsfadjust;\r\nif (avp->av_bslot == 0)\r\nreturn;\r\ntsfadjust = cur_conf->beacon_interval * avp->av_bslot;\r\ntsfadjust = TU_TO_USEC(tsfadjust) / ATH_BCBUF;\r\navp->tsf_adjust = cpu_to_le64(tsfadjust);\r\nath_dbg(common, CONFIG, "tsfadjust is: %llu for bslot: %d\n",\r\n(unsigned long long)tsfadjust, avp->av_bslot);\r\n}\r\nbool ath9k_csa_is_finished(struct ath_softc *sc, struct ieee80211_vif *vif)\r\n{\r\nif (!vif || !vif->csa_active)\r\nreturn false;\r\nif (!ieee80211_csa_is_complete(vif))\r\nreturn false;\r\nieee80211_csa_finish(vif);\r\nreturn true;\r\n}\r\nstatic void ath9k_csa_update_vif(void *data, u8 *mac, struct ieee80211_vif *vif)\r\n{\r\nstruct ath_softc *sc = data;\r\nath9k_csa_is_finished(sc, vif);\r\n}\r\nvoid ath9k_csa_update(struct ath_softc *sc)\r\n{\r\nieee80211_iterate_active_interfaces_atomic(sc->hw,\r\nIEEE80211_IFACE_ITER_NORMAL,\r\nath9k_csa_update_vif, sc);\r\n}\r\nvoid ath9k_beacon_tasklet(unsigned long data)\r\n{\r\nstruct ath_softc *sc = (struct ath_softc *)data;\r\nstruct ath_hw *ah = sc->sc_ah;\r\nstruct ath_common *common = ath9k_hw_common(ah);\r\nstruct ath_buf *bf = NULL;\r\nstruct ieee80211_vif *vif;\r\nbool edma = !!(ah->caps.hw_caps & ATH9K_HW_CAP_EDMA);\r\nint slot;\r\nif (test_bit(ATH_OP_HW_RESET, &common->op_flags)) {\r\nath_dbg(common, RESET,\r\n"reset work is pending, skip beaconing now\n");\r\nreturn;\r\n}\r\nif (ath9k_hw_numtxpending(ah, sc->beacon.beaconq) != 0) {\r\nsc->beacon.bmisscnt++;\r\nath9k_hw_check_nav(ah);\r\nif (!ath_hw_check(sc))\r\nreturn;\r\nif (sc->beacon.bmisscnt < BSTUCK_THRESH * sc->nbcnvifs) {\r\nath_dbg(common, BSTUCK,\r\n"missed %u consecutive beacons\n",\r\nsc->beacon.bmisscnt);\r\nath9k_hw_stop_dma_queue(ah, sc->beacon.beaconq);\r\nif (sc->beacon.bmisscnt > 3)\r\nath9k_hw_bstuck_nfcal(ah);\r\n} else if (sc->beacon.bmisscnt >= BSTUCK_THRESH) {\r\nath_dbg(common, BSTUCK, "beacon is officially stuck\n");\r\nsc->beacon.bmisscnt = 0;\r\nath9k_queue_reset(sc, RESET_TYPE_BEACON_STUCK);\r\n}\r\nreturn;\r\n}\r\nslot = ath9k_beacon_choose_slot(sc);\r\nvif = sc->beacon.bslot[slot];\r\nif (!edma) {\r\nif (ath9k_is_chanctx_enabled()) {\r\nath_chanctx_beacon_sent_ev(sc,\r\nATH_CHANCTX_EVENT_BEACON_SENT);\r\n}\r\nif (ath9k_csa_is_finished(sc, vif))\r\nreturn;\r\n}\r\nif (!vif || !vif->bss_conf.enable_beacon)\r\nreturn;\r\nif (ath9k_is_chanctx_enabled()) {\r\nath_chanctx_event(sc, vif, ATH_CHANCTX_EVENT_BEACON_PREPARE);\r\n}\r\nbf = ath9k_beacon_generate(sc->hw, vif);\r\nif (sc->beacon.bmisscnt != 0) {\r\nath_dbg(common, BSTUCK, "resume beacon xmit after %u misses\n",\r\nsc->beacon.bmisscnt);\r\nsc->beacon.bmisscnt = 0;\r\n}\r\nif (sc->beacon.updateslot == UPDATE) {\r\nsc->beacon.updateslot = COMMIT;\r\nsc->beacon.slotupdate = slot;\r\n} else if (sc->beacon.updateslot == COMMIT &&\r\nsc->beacon.slotupdate == slot) {\r\nah->slottime = sc->beacon.slottime;\r\nath9k_hw_init_global_settings(ah);\r\nsc->beacon.updateslot = OK;\r\n}\r\nif (bf) {\r\nath9k_reset_beacon_status(sc);\r\nath_dbg(common, BEACON,\r\n"Transmitting beacon for slot: %d\n", slot);\r\nath9k_hw_puttxbuf(ah, sc->beacon.beaconq, bf->bf_daddr);\r\nif (!edma)\r\nath9k_hw_txstart(ah, sc->beacon.beaconq);\r\n}\r\n}\r\nstatic void ath9k_beacon_init(struct ath_softc *sc, u32 nexttbtt,\r\nu32 intval, bool reset_tsf)\r\n{\r\nstruct ath_hw *ah = sc->sc_ah;\r\nath9k_hw_disable_interrupts(ah);\r\nif (reset_tsf)\r\nath9k_hw_reset_tsf(ah);\r\nath9k_beaconq_config(sc);\r\nath9k_hw_beaconinit(ah, nexttbtt, intval);\r\nsc->beacon.bmisscnt = 0;\r\nath9k_hw_set_interrupts(ah);\r\nath9k_hw_enable_interrupts(ah);\r\n}\r\nstatic void ath9k_beacon_config_ap(struct ath_softc *sc,\r\nstruct ath_beacon_config *conf)\r\n{\r\nstruct ath_hw *ah = sc->sc_ah;\r\nath9k_cmn_beacon_config_ap(ah, conf, ATH_BCBUF);\r\nath9k_beacon_init(sc, conf->nexttbtt, conf->intval, false);\r\n}\r\nstatic void ath9k_beacon_config_sta(struct ath_hw *ah,\r\nstruct ath_beacon_config *conf)\r\n{\r\nstruct ath9k_beacon_state bs;\r\nif (ath9k_cmn_beacon_config_sta(ah, conf, &bs) == -EPERM)\r\nreturn;\r\nath9k_hw_disable_interrupts(ah);\r\nath9k_hw_set_sta_beacon_timers(ah, &bs);\r\nah->imask |= ATH9K_INT_BMISS;\r\nath9k_hw_set_interrupts(ah);\r\nath9k_hw_enable_interrupts(ah);\r\n}\r\nstatic void ath9k_beacon_config_adhoc(struct ath_softc *sc,\r\nstruct ath_beacon_config *conf)\r\n{\r\nstruct ath_hw *ah = sc->sc_ah;\r\nstruct ath_common *common = ath9k_hw_common(ah);\r\nath9k_reset_beacon_status(sc);\r\nath9k_cmn_beacon_config_adhoc(ah, conf);\r\nath9k_beacon_init(sc, conf->nexttbtt, conf->intval, conf->ibss_creator);\r\nif (!conf->ibss_creator && conf->enable_beacon)\r\nset_bit(ATH_OP_BEACONS, &common->op_flags);\r\n}\r\nstatic bool ath9k_allow_beacon_config(struct ath_softc *sc,\r\nstruct ieee80211_vif *vif)\r\n{\r\nstruct ath_common *common = ath9k_hw_common(sc->sc_ah);\r\nstruct ath_vif *avp = (void *)vif->drv_priv;\r\nif (ath9k_is_chanctx_enabled()) {\r\nif (sc->cur_chan != avp->chanctx)\r\nreturn true;\r\n}\r\nif (sc->sc_ah->opmode == NL80211_IFTYPE_AP) {\r\nif (vif->type != NL80211_IFTYPE_AP) {\r\nath_dbg(common, CONFIG,\r\n"An AP interface is already present !\n");\r\nreturn false;\r\n}\r\n}\r\nif (sc->sc_ah->opmode == NL80211_IFTYPE_STATION) {\r\nif ((vif->type == NL80211_IFTYPE_STATION) &&\r\ntest_bit(ATH_OP_BEACONS, &common->op_flags) &&\r\nvif != sc->cur_chan->primary_sta) {\r\nath_dbg(common, CONFIG,\r\n"Beacon already configured for a station interface\n");\r\nreturn false;\r\n}\r\n}\r\nreturn true;\r\n}\r\nstatic void ath9k_cache_beacon_config(struct ath_softc *sc,\r\nstruct ath_chanctx *ctx,\r\nstruct ieee80211_bss_conf *bss_conf)\r\n{\r\nstruct ath_common *common = ath9k_hw_common(sc->sc_ah);\r\nstruct ath_beacon_config *cur_conf = &ctx->beacon;\r\nath_dbg(common, BEACON,\r\n"Caching beacon data for BSS: %pM\n", bss_conf->bssid);\r\ncur_conf->beacon_interval = bss_conf->beacon_int;\r\ncur_conf->dtim_period = bss_conf->dtim_period;\r\ncur_conf->dtim_count = 1;\r\ncur_conf->ibss_creator = bss_conf->ibss_creator;\r\nif (cur_conf->beacon_interval == 0)\r\ncur_conf->beacon_interval = 100;\r\ncur_conf->bmiss_timeout =\r\nATH_DEFAULT_BMISS_LIMIT * cur_conf->beacon_interval;\r\nif (cur_conf->dtim_period == 0)\r\ncur_conf->dtim_period = 1;\r\n}\r\nvoid ath9k_beacon_config(struct ath_softc *sc, struct ieee80211_vif *vif,\r\nu32 changed)\r\n{\r\nstruct ieee80211_bss_conf *bss_conf = &vif->bss_conf;\r\nstruct ath_hw *ah = sc->sc_ah;\r\nstruct ath_common *common = ath9k_hw_common(ah);\r\nstruct ath_vif *avp = (void *)vif->drv_priv;\r\nstruct ath_chanctx *ctx = avp->chanctx;\r\nstruct ath_beacon_config *cur_conf;\r\nunsigned long flags;\r\nbool skip_beacon = false;\r\nif (!ctx)\r\nreturn;\r\ncur_conf = &avp->chanctx->beacon;\r\nif (vif->type == NL80211_IFTYPE_AP)\r\nath9k_set_tsfadjust(sc, vif);\r\nif (!ath9k_allow_beacon_config(sc, vif))\r\nreturn;\r\nif (vif->type == NL80211_IFTYPE_STATION) {\r\nath9k_cache_beacon_config(sc, ctx, bss_conf);\r\nif (ctx != sc->cur_chan)\r\nreturn;\r\nath9k_set_beacon(sc);\r\nset_bit(ATH_OP_BEACONS, &common->op_flags);\r\nreturn;\r\n}\r\nif (changed & BSS_CHANGED_BEACON_ENABLED) {\r\nbool enabled = cur_conf->enable_beacon;\r\nif (!bss_conf->enable_beacon) {\r\ncur_conf->enable_beacon &= ~BIT(avp->av_bslot);\r\n} else {\r\ncur_conf->enable_beacon |= BIT(avp->av_bslot);\r\nif (!enabled)\r\nath9k_cache_beacon_config(sc, ctx, bss_conf);\r\n}\r\n}\r\nif (ctx != sc->cur_chan)\r\nreturn;\r\nif (cur_conf->beacon_interval) {\r\nif ((changed & BSS_CHANGED_IBSS) && !bss_conf->ibss_creator &&\r\nbss_conf->enable_beacon) {\r\nspin_lock_irqsave(&sc->sc_pm_lock, flags);\r\nsc->ps_flags |= PS_BEACON_SYNC | PS_WAIT_FOR_BEACON;\r\nspin_unlock_irqrestore(&sc->sc_pm_lock, flags);\r\nskip_beacon = true;\r\n} else {\r\nath9k_set_beacon(sc);\r\n}\r\nif (cur_conf->enable_beacon && !skip_beacon)\r\nset_bit(ATH_OP_BEACONS, &common->op_flags);\r\nelse\r\nclear_bit(ATH_OP_BEACONS, &common->op_flags);\r\n}\r\n}\r\nvoid ath9k_set_beacon(struct ath_softc *sc)\r\n{\r\nstruct ath_common *common = ath9k_hw_common(sc->sc_ah);\r\nstruct ath_beacon_config *cur_conf = &sc->cur_chan->beacon;\r\nswitch (sc->sc_ah->opmode) {\r\ncase NL80211_IFTYPE_AP:\r\ncase NL80211_IFTYPE_MESH_POINT:\r\nath9k_beacon_config_ap(sc, cur_conf);\r\nbreak;\r\ncase NL80211_IFTYPE_ADHOC:\r\nath9k_beacon_config_adhoc(sc, cur_conf);\r\nbreak;\r\ncase NL80211_IFTYPE_STATION:\r\nath9k_beacon_config_sta(sc->sc_ah, cur_conf);\r\nbreak;\r\ndefault:\r\nath_dbg(common, CONFIG, "Unsupported beaconing mode\n");\r\nreturn;\r\n}\r\n}
