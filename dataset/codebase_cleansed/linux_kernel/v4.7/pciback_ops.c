static void xen_pcibk_control_isr(struct pci_dev *dev, int reset)\r\n{\r\nstruct xen_pcibk_dev_data *dev_data;\r\nint rc;\r\nint enable = 0;\r\ndev_data = pci_get_drvdata(dev);\r\nif (!dev_data)\r\nreturn;\r\nif (dev->hdr_type != PCI_HEADER_TYPE_NORMAL)\r\nreturn;\r\nif (reset) {\r\ndev_data->enable_intx = 0;\r\ndev_data->ack_intr = 0;\r\n}\r\nenable = dev_data->enable_intx;\r\nif (!enable && !dev_data->isr_on)\r\nreturn;\r\nif (enable)\r\ndev_data->irq = dev->irq;\r\nif (dev_data->irq == 0)\r\ngoto out;\r\ndev_dbg(&dev->dev, "%s: #%d %s %s%s %s-> %s\n",\r\ndev_data->irq_name,\r\ndev_data->irq,\r\npci_is_enabled(dev) ? "on" : "off",\r\ndev->msi_enabled ? "MSI" : "",\r\ndev->msix_enabled ? "MSI/X" : "",\r\ndev_data->isr_on ? "enable" : "disable",\r\nenable ? "enable" : "disable");\r\nif (enable) {\r\nif (dev->msi_enabled || dev->msix_enabled)\r\ngoto out;\r\nrc = request_irq(dev_data->irq,\r\nxen_pcibk_guest_interrupt, IRQF_SHARED,\r\ndev_data->irq_name, dev);\r\nif (rc) {\r\ndev_err(&dev->dev, "%s: failed to install fake IRQ " \\r\n"handler for IRQ %d! (rc:%d)\n",\r\ndev_data->irq_name, dev_data->irq, rc);\r\ngoto out;\r\n}\r\n} else {\r\nfree_irq(dev_data->irq, dev);\r\ndev_data->irq = 0;\r\n}\r\ndev_data->isr_on = enable;\r\ndev_data->ack_intr = enable;\r\nout:\r\ndev_dbg(&dev->dev, "%s: #%d %s %s%s %s\n",\r\ndev_data->irq_name,\r\ndev_data->irq,\r\npci_is_enabled(dev) ? "on" : "off",\r\ndev->msi_enabled ? "MSI" : "",\r\ndev->msix_enabled ? "MSI/X" : "",\r\nenable ? (dev_data->isr_on ? "enabled" : "failed to enable") :\r\n(dev_data->isr_on ? "failed to disable" : "disabled"));\r\n}\r\nvoid xen_pcibk_reset_device(struct pci_dev *dev)\r\n{\r\nu16 cmd;\r\nxen_pcibk_control_isr(dev, 1 );\r\nif (dev->hdr_type == PCI_HEADER_TYPE_NORMAL) {\r\n#ifdef CONFIG_PCI_MSI\r\nif (dev->msix_enabled)\r\npci_disable_msix(dev);\r\nif (dev->msi_enabled)\r\npci_disable_msi(dev);\r\n#endif\r\nif (pci_is_enabled(dev))\r\npci_disable_device(dev);\r\npci_write_config_word(dev, PCI_COMMAND, 0);\r\ndev->is_busmaster = 0;\r\n} else {\r\npci_read_config_word(dev, PCI_COMMAND, &cmd);\r\nif (cmd & (PCI_COMMAND_INVALIDATE)) {\r\ncmd &= ~(PCI_COMMAND_INVALIDATE);\r\npci_write_config_word(dev, PCI_COMMAND, cmd);\r\ndev->is_busmaster = 0;\r\n}\r\n}\r\n}\r\nstatic\r\nint xen_pcibk_enable_msi(struct xen_pcibk_device *pdev,\r\nstruct pci_dev *dev, struct xen_pci_op *op)\r\n{\r\nstruct xen_pcibk_dev_data *dev_data;\r\nint status;\r\nif (unlikely(verbose_request))\r\nprintk(KERN_DEBUG DRV_NAME ": %s: enable MSI\n", pci_name(dev));\r\nif (dev->msi_enabled)\r\nstatus = -EALREADY;\r\nelse if (dev->msix_enabled)\r\nstatus = -ENXIO;\r\nelse\r\nstatus = pci_enable_msi(dev);\r\nif (status) {\r\npr_warn_ratelimited("%s: error enabling MSI for guest %u: err %d\n",\r\npci_name(dev), pdev->xdev->otherend_id,\r\nstatus);\r\nop->value = 0;\r\nreturn XEN_PCI_ERR_op_failed;\r\n}\r\nop->value = dev->irq ? xen_pirq_from_irq(dev->irq) : 0;\r\nif (unlikely(verbose_request))\r\nprintk(KERN_DEBUG DRV_NAME ": %s: MSI: %d\n", pci_name(dev),\r\nop->value);\r\ndev_data = pci_get_drvdata(dev);\r\nif (dev_data)\r\ndev_data->ack_intr = 0;\r\nreturn 0;\r\n}\r\nstatic\r\nint xen_pcibk_disable_msi(struct xen_pcibk_device *pdev,\r\nstruct pci_dev *dev, struct xen_pci_op *op)\r\n{\r\nif (unlikely(verbose_request))\r\nprintk(KERN_DEBUG DRV_NAME ": %s: disable MSI\n",\r\npci_name(dev));\r\nif (dev->msi_enabled) {\r\nstruct xen_pcibk_dev_data *dev_data;\r\npci_disable_msi(dev);\r\ndev_data = pci_get_drvdata(dev);\r\nif (dev_data)\r\ndev_data->ack_intr = 1;\r\n}\r\nop->value = dev->irq ? xen_pirq_from_irq(dev->irq) : 0;\r\nif (unlikely(verbose_request))\r\nprintk(KERN_DEBUG DRV_NAME ": %s: MSI: %d\n", pci_name(dev),\r\nop->value);\r\nreturn 0;\r\n}\r\nstatic\r\nint xen_pcibk_enable_msix(struct xen_pcibk_device *pdev,\r\nstruct pci_dev *dev, struct xen_pci_op *op)\r\n{\r\nstruct xen_pcibk_dev_data *dev_data;\r\nint i, result;\r\nstruct msix_entry *entries;\r\nu16 cmd;\r\nif (unlikely(verbose_request))\r\nprintk(KERN_DEBUG DRV_NAME ": %s: enable MSI-X\n",\r\npci_name(dev));\r\nif (op->value > SH_INFO_MAX_VEC)\r\nreturn -EINVAL;\r\nif (dev->msix_enabled)\r\nreturn -EALREADY;\r\npci_read_config_word(pci_physfn(dev), PCI_COMMAND, &cmd);\r\nif (dev->msi_enabled || !(cmd & PCI_COMMAND_MEMORY))\r\nreturn -ENXIO;\r\nentries = kmalloc(op->value * sizeof(*entries), GFP_KERNEL);\r\nif (entries == NULL)\r\nreturn -ENOMEM;\r\nfor (i = 0; i < op->value; i++) {\r\nentries[i].entry = op->msix_entries[i].entry;\r\nentries[i].vector = op->msix_entries[i].vector;\r\n}\r\nresult = pci_enable_msix_exact(dev, entries, op->value);\r\nif (result == 0) {\r\nfor (i = 0; i < op->value; i++) {\r\nop->msix_entries[i].entry = entries[i].entry;\r\nif (entries[i].vector) {\r\nop->msix_entries[i].vector =\r\nxen_pirq_from_irq(entries[i].vector);\r\nif (unlikely(verbose_request))\r\nprintk(KERN_DEBUG DRV_NAME ": %s: " \\r\n"MSI-X[%d]: %d\n",\r\npci_name(dev), i,\r\nop->msix_entries[i].vector);\r\n}\r\n}\r\n} else\r\npr_warn_ratelimited("%s: error enabling MSI-X for guest %u: err %d!\n",\r\npci_name(dev), pdev->xdev->otherend_id,\r\nresult);\r\nkfree(entries);\r\nop->value = result;\r\ndev_data = pci_get_drvdata(dev);\r\nif (dev_data)\r\ndev_data->ack_intr = 0;\r\nreturn result > 0 ? 0 : result;\r\n}\r\nstatic\r\nint xen_pcibk_disable_msix(struct xen_pcibk_device *pdev,\r\nstruct pci_dev *dev, struct xen_pci_op *op)\r\n{\r\nif (unlikely(verbose_request))\r\nprintk(KERN_DEBUG DRV_NAME ": %s: disable MSI-X\n",\r\npci_name(dev));\r\nif (dev->msix_enabled) {\r\nstruct xen_pcibk_dev_data *dev_data;\r\npci_disable_msix(dev);\r\ndev_data = pci_get_drvdata(dev);\r\nif (dev_data)\r\ndev_data->ack_intr = 1;\r\n}\r\nop->value = dev->irq ? xen_pirq_from_irq(dev->irq) : 0;\r\nif (unlikely(verbose_request))\r\nprintk(KERN_DEBUG DRV_NAME ": %s: MSI-X: %d\n",\r\npci_name(dev), op->value);\r\nreturn 0;\r\n}\r\nvoid xen_pcibk_test_and_schedule_op(struct xen_pcibk_device *pdev)\r\n{\r\nif (test_bit(_XEN_PCIF_active, (unsigned long *)&pdev->sh_info->flags)\r\n&& !test_and_set_bit(_PDEVF_op_active, &pdev->flags)) {\r\nqueue_work(xen_pcibk_wq, &pdev->op_work);\r\n}\r\nif (!test_bit(_XEN_PCIB_active, (unsigned long *)&pdev->sh_info->flags)\r\n&& test_bit(_PCIB_op_pending, &pdev->flags)) {\r\nwake_up(&xen_pcibk_aer_wait_queue);\r\n}\r\n}\r\nvoid xen_pcibk_do_op(struct work_struct *data)\r\n{\r\nstruct xen_pcibk_device *pdev =\r\ncontainer_of(data, struct xen_pcibk_device, op_work);\r\nstruct pci_dev *dev;\r\nstruct xen_pcibk_dev_data *dev_data = NULL;\r\nstruct xen_pci_op *op = &pdev->op;\r\nint test_intx = 0;\r\n#ifdef CONFIG_PCI_MSI\r\nunsigned int nr = 0;\r\n#endif\r\n*op = pdev->sh_info->op;\r\nbarrier();\r\ndev = xen_pcibk_get_pci_dev(pdev, op->domain, op->bus, op->devfn);\r\nif (dev == NULL)\r\nop->err = XEN_PCI_ERR_dev_not_found;\r\nelse {\r\ndev_data = pci_get_drvdata(dev);\r\nif (dev_data)\r\ntest_intx = dev_data->enable_intx;\r\nswitch (op->cmd) {\r\ncase XEN_PCI_OP_conf_read:\r\nop->err = xen_pcibk_config_read(dev,\r\nop->offset, op->size, &op->value);\r\nbreak;\r\ncase XEN_PCI_OP_conf_write:\r\nop->err = xen_pcibk_config_write(dev,\r\nop->offset, op->size, op->value);\r\nbreak;\r\n#ifdef CONFIG_PCI_MSI\r\ncase XEN_PCI_OP_enable_msi:\r\nop->err = xen_pcibk_enable_msi(pdev, dev, op);\r\nbreak;\r\ncase XEN_PCI_OP_disable_msi:\r\nop->err = xen_pcibk_disable_msi(pdev, dev, op);\r\nbreak;\r\ncase XEN_PCI_OP_enable_msix:\r\nnr = op->value;\r\nop->err = xen_pcibk_enable_msix(pdev, dev, op);\r\nbreak;\r\ncase XEN_PCI_OP_disable_msix:\r\nop->err = xen_pcibk_disable_msix(pdev, dev, op);\r\nbreak;\r\n#endif\r\ndefault:\r\nop->err = XEN_PCI_ERR_not_implemented;\r\nbreak;\r\n}\r\n}\r\nif (!op->err && dev && dev_data) {\r\nif ((dev_data->enable_intx != test_intx))\r\nxen_pcibk_control_isr(dev, 0 );\r\n}\r\npdev->sh_info->op.err = op->err;\r\npdev->sh_info->op.value = op->value;\r\n#ifdef CONFIG_PCI_MSI\r\nif (op->cmd == XEN_PCI_OP_enable_msix && op->err == 0) {\r\nunsigned int i;\r\nfor (i = 0; i < nr; i++)\r\npdev->sh_info->op.msix_entries[i].vector =\r\nop->msix_entries[i].vector;\r\n}\r\n#endif\r\nwmb();\r\nclear_bit(_XEN_PCIF_active, (unsigned long *)&pdev->sh_info->flags);\r\nnotify_remote_via_irq(pdev->evtchn_irq);\r\nsmp_mb__before_atomic();\r\nclear_bit(_PDEVF_op_active, &pdev->flags);\r\nsmp_mb__after_atomic();\r\nxen_pcibk_test_and_schedule_op(pdev);\r\n}\r\nirqreturn_t xen_pcibk_handle_event(int irq, void *dev_id)\r\n{\r\nstruct xen_pcibk_device *pdev = dev_id;\r\nxen_pcibk_test_and_schedule_op(pdev);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic irqreturn_t xen_pcibk_guest_interrupt(int irq, void *dev_id)\r\n{\r\nstruct pci_dev *dev = (struct pci_dev *)dev_id;\r\nstruct xen_pcibk_dev_data *dev_data = pci_get_drvdata(dev);\r\nif (dev_data->isr_on && dev_data->ack_intr) {\r\ndev_data->handled++;\r\nif ((dev_data->handled % 1000) == 0) {\r\nif (xen_test_irq_shared(irq)) {\r\npr_info("%s IRQ line is not shared "\r\n"with other domains. Turning ISR off\n",\r\ndev_data->irq_name);\r\ndev_data->ack_intr = 0;\r\n}\r\n}\r\nreturn IRQ_HANDLED;\r\n}\r\nreturn IRQ_NONE;\r\n}
