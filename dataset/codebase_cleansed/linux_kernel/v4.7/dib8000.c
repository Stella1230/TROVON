static u16 dib8000_i2c_read16(struct i2c_device *i2c, u16 reg)\r\n{\r\nu16 ret;\r\nstruct i2c_msg msg[2] = {\r\n{.addr = i2c->addr >> 1, .flags = 0, .len = 2},\r\n{.addr = i2c->addr >> 1, .flags = I2C_M_RD, .len = 2},\r\n};\r\nif (mutex_lock_interruptible(i2c->i2c_buffer_lock) < 0) {\r\ndprintk("could not acquire lock");\r\nreturn 0;\r\n}\r\nmsg[0].buf = i2c->i2c_write_buffer;\r\nmsg[0].buf[0] = reg >> 8;\r\nmsg[0].buf[1] = reg & 0xff;\r\nmsg[1].buf = i2c->i2c_read_buffer;\r\nif (i2c_transfer(i2c->adap, msg, 2) != 2)\r\ndprintk("i2c read error on %d", reg);\r\nret = (msg[1].buf[0] << 8) | msg[1].buf[1];\r\nmutex_unlock(i2c->i2c_buffer_lock);\r\nreturn ret;\r\n}\r\nstatic u16 __dib8000_read_word(struct dib8000_state *state, u16 reg)\r\n{\r\nu16 ret;\r\nstate->i2c_write_buffer[0] = reg >> 8;\r\nstate->i2c_write_buffer[1] = reg & 0xff;\r\nmemset(state->msg, 0, 2 * sizeof(struct i2c_msg));\r\nstate->msg[0].addr = state->i2c.addr >> 1;\r\nstate->msg[0].flags = 0;\r\nstate->msg[0].buf = state->i2c_write_buffer;\r\nstate->msg[0].len = 2;\r\nstate->msg[1].addr = state->i2c.addr >> 1;\r\nstate->msg[1].flags = I2C_M_RD;\r\nstate->msg[1].buf = state->i2c_read_buffer;\r\nstate->msg[1].len = 2;\r\nif (i2c_transfer(state->i2c.adap, state->msg, 2) != 2)\r\ndprintk("i2c read error on %d", reg);\r\nret = (state->i2c_read_buffer[0] << 8) | state->i2c_read_buffer[1];\r\nreturn ret;\r\n}\r\nstatic u16 dib8000_read_word(struct dib8000_state *state, u16 reg)\r\n{\r\nu16 ret;\r\nif (mutex_lock_interruptible(&state->i2c_buffer_lock) < 0) {\r\ndprintk("could not acquire lock");\r\nreturn 0;\r\n}\r\nret = __dib8000_read_word(state, reg);\r\nmutex_unlock(&state->i2c_buffer_lock);\r\nreturn ret;\r\n}\r\nstatic u32 dib8000_read32(struct dib8000_state *state, u16 reg)\r\n{\r\nu16 rw[2];\r\nif (mutex_lock_interruptible(&state->i2c_buffer_lock) < 0) {\r\ndprintk("could not acquire lock");\r\nreturn 0;\r\n}\r\nrw[0] = __dib8000_read_word(state, reg + 0);\r\nrw[1] = __dib8000_read_word(state, reg + 1);\r\nmutex_unlock(&state->i2c_buffer_lock);\r\nreturn ((rw[0] << 16) | (rw[1]));\r\n}\r\nstatic int dib8000_i2c_write16(struct i2c_device *i2c, u16 reg, u16 val)\r\n{\r\nstruct i2c_msg msg = {.addr = i2c->addr >> 1, .flags = 0, .len = 4};\r\nint ret = 0;\r\nif (mutex_lock_interruptible(i2c->i2c_buffer_lock) < 0) {\r\ndprintk("could not acquire lock");\r\nreturn -EINVAL;\r\n}\r\nmsg.buf = i2c->i2c_write_buffer;\r\nmsg.buf[0] = (reg >> 8) & 0xff;\r\nmsg.buf[1] = reg & 0xff;\r\nmsg.buf[2] = (val >> 8) & 0xff;\r\nmsg.buf[3] = val & 0xff;\r\nret = i2c_transfer(i2c->adap, &msg, 1) != 1 ? -EREMOTEIO : 0;\r\nmutex_unlock(i2c->i2c_buffer_lock);\r\nreturn ret;\r\n}\r\nstatic int dib8000_write_word(struct dib8000_state *state, u16 reg, u16 val)\r\n{\r\nint ret;\r\nif (mutex_lock_interruptible(&state->i2c_buffer_lock) < 0) {\r\ndprintk("could not acquire lock");\r\nreturn -EINVAL;\r\n}\r\nstate->i2c_write_buffer[0] = (reg >> 8) & 0xff;\r\nstate->i2c_write_buffer[1] = reg & 0xff;\r\nstate->i2c_write_buffer[2] = (val >> 8) & 0xff;\r\nstate->i2c_write_buffer[3] = val & 0xff;\r\nmemset(&state->msg[0], 0, sizeof(struct i2c_msg));\r\nstate->msg[0].addr = state->i2c.addr >> 1;\r\nstate->msg[0].flags = 0;\r\nstate->msg[0].buf = state->i2c_write_buffer;\r\nstate->msg[0].len = 4;\r\nret = (i2c_transfer(state->i2c.adap, state->msg, 1) != 1 ?\r\n-EREMOTEIO : 0);\r\nmutex_unlock(&state->i2c_buffer_lock);\r\nreturn ret;\r\n}\r\nstatic u16 fft_to_mode(struct dib8000_state *state)\r\n{\r\nu16 mode;\r\nswitch (state->fe[0]->dtv_property_cache.transmission_mode) {\r\ncase TRANSMISSION_MODE_2K:\r\nmode = 1;\r\nbreak;\r\ncase TRANSMISSION_MODE_4K:\r\nmode = 2;\r\nbreak;\r\ndefault:\r\ncase TRANSMISSION_MODE_AUTO:\r\ncase TRANSMISSION_MODE_8K:\r\nmode = 3;\r\nbreak;\r\n}\r\nreturn mode;\r\n}\r\nstatic void dib8000_set_acquisition_mode(struct dib8000_state *state)\r\n{\r\nu16 nud = dib8000_read_word(state, 298);\r\nnud |= (1 << 3) | (1 << 0);\r\ndprintk("acquisition mode activated");\r\ndib8000_write_word(state, 298, nud);\r\n}\r\nstatic int dib8000_set_output_mode(struct dvb_frontend *fe, int mode)\r\n{\r\nstruct dib8000_state *state = fe->demodulator_priv;\r\nu16 outreg, fifo_threshold, smo_mode, sram = 0x0205;\r\nstate->output_mode = mode;\r\noutreg = 0;\r\nfifo_threshold = 1792;\r\nsmo_mode = (dib8000_read_word(state, 299) & 0x0050) | (1 << 1);\r\ndprintk("-I- Setting output mode for demod %p to %d",\r\n&state->fe[0], mode);\r\nswitch (mode) {\r\ncase OUTMODE_MPEG2_PAR_GATED_CLK:\r\noutreg = (1 << 10);\r\nbreak;\r\ncase OUTMODE_MPEG2_PAR_CONT_CLK:\r\noutreg = (1 << 10) | (1 << 6);\r\nbreak;\r\ncase OUTMODE_MPEG2_SERIAL:\r\noutreg = (1 << 10) | (2 << 6) | (0 << 1);\r\nbreak;\r\ncase OUTMODE_DIVERSITY:\r\nif (state->cfg.hostbus_diversity) {\r\noutreg = (1 << 10) | (4 << 6);\r\nsram &= 0xfdff;\r\n} else\r\nsram |= 0x0c00;\r\nbreak;\r\ncase OUTMODE_MPEG2_FIFO:\r\nsmo_mode |= (3 << 1);\r\nfifo_threshold = 512;\r\noutreg = (1 << 10) | (5 << 6);\r\nbreak;\r\ncase OUTMODE_HIGH_Z:\r\noutreg = 0;\r\nbreak;\r\ncase OUTMODE_ANALOG_ADC:\r\noutreg = (1 << 10) | (3 << 6);\r\ndib8000_set_acquisition_mode(state);\r\nbreak;\r\ndefault:\r\ndprintk("Unhandled output_mode passed to be set for demod %p",\r\n&state->fe[0]);\r\nreturn -EINVAL;\r\n}\r\nif (state->cfg.output_mpeg2_in_188_bytes)\r\nsmo_mode |= (1 << 5);\r\ndib8000_write_word(state, 299, smo_mode);\r\ndib8000_write_word(state, 300, fifo_threshold);\r\ndib8000_write_word(state, 1286, outreg);\r\ndib8000_write_word(state, 1291, sram);\r\nreturn 0;\r\n}\r\nstatic int dib8000_set_diversity_in(struct dvb_frontend *fe, int onoff)\r\n{\r\nstruct dib8000_state *state = fe->demodulator_priv;\r\nu16 tmp, sync_wait = dib8000_read_word(state, 273) & 0xfff0;\r\ndprintk("set diversity input to %i", onoff);\r\nif (!state->differential_constellation) {\r\ndib8000_write_word(state, 272, 1 << 9);\r\ndib8000_write_word(state, 273, sync_wait | (1 << 2) | 2);\r\n} else {\r\ndib8000_write_word(state, 272, 0);\r\ndib8000_write_word(state, 273, sync_wait);\r\n}\r\nstate->diversity_onoff = onoff;\r\nswitch (onoff) {\r\ncase 0:\r\ndib8000_write_word(state, 270, 1);\r\ndib8000_write_word(state, 271, 0);\r\nbreak;\r\ncase 1:\r\ndib8000_write_word(state, 270, 6);\r\ndib8000_write_word(state, 271, 6);\r\nbreak;\r\ncase 2:\r\ndib8000_write_word(state, 270, 0);\r\ndib8000_write_word(state, 271, 1);\r\nbreak;\r\n}\r\nif (state->revision == 0x8002) {\r\ntmp = dib8000_read_word(state, 903);\r\ndib8000_write_word(state, 903, tmp & ~(1 << 3));\r\nmsleep(30);\r\ndib8000_write_word(state, 903, tmp | (1 << 3));\r\n}\r\nreturn 0;\r\n}\r\nstatic void dib8000_set_power_mode(struct dib8000_state *state, enum dib8000_power_mode mode)\r\n{\r\nu16 reg_774 = 0x3fff, reg_775 = 0xffff, reg_776 = 0xffff,\r\nreg_900 = (dib8000_read_word(state, 900) & 0xfffc) | 0x3,\r\nreg_1280;\r\nif (state->revision != 0x8090)\r\nreg_1280 = (dib8000_read_word(state, 1280) & 0x00ff) | 0xff00;\r\nelse\r\nreg_1280 = (dib8000_read_word(state, 1280) & 0x707f) | 0x8f80;\r\nswitch (mode) {\r\ncase DIB8000_POWER_ALL:\r\nreg_774 = 0x0000;\r\nreg_775 = 0x0000;\r\nreg_776 = 0x0000;\r\nreg_900 &= 0xfffc;\r\nif (state->revision != 0x8090)\r\nreg_1280 &= 0x00ff;\r\nelse\r\nreg_1280 &= 0x707f;\r\nbreak;\r\ncase DIB8000_POWER_INTERFACE_ONLY:\r\nif (state->revision != 0x8090)\r\nreg_1280 &= 0x00ff;\r\nelse\r\nreg_1280 &= 0xfa7b;\r\nbreak;\r\n}\r\ndprintk("powermode : 774 : %x ; 775 : %x; 776 : %x ; 900 : %x; 1280 : %x", reg_774, reg_775, reg_776, reg_900, reg_1280);\r\ndib8000_write_word(state, 774, reg_774);\r\ndib8000_write_word(state, 775, reg_775);\r\ndib8000_write_word(state, 776, reg_776);\r\ndib8000_write_word(state, 900, reg_900);\r\ndib8000_write_word(state, 1280, reg_1280);\r\n}\r\nstatic int dib8000_set_adc_state(struct dib8000_state *state, enum dibx000_adc_states no)\r\n{\r\nint ret = 0;\r\nu16 reg, reg_907 = dib8000_read_word(state, 907);\r\nu16 reg_908 = dib8000_read_word(state, 908);\r\nswitch (no) {\r\ncase DIBX000_SLOW_ADC_ON:\r\nif (state->revision != 0x8090) {\r\nreg_908 |= (1 << 1) | (1 << 0);\r\nret |= dib8000_write_word(state, 908, reg_908);\r\nreg_908 &= ~(1 << 1);\r\n} else {\r\nreg = dib8000_read_word(state, 1925);\r\ndib8000_write_word(state, 1925, reg |\r\n(1<<4) | (1<<2));\r\nreg = dib8000_read_word(state, 1925);\r\nmsleep(20);\r\ndib8000_write_word(state, 1925, reg & ~(1<<4));\r\nreg = dib8000_read_word(state, 921) & ~((0x3 << 14)\r\n| (0x3 << 12));\r\ndib8000_write_word(state, 921, reg | (1 << 14)\r\n| (3 << 12));\r\n}\r\nbreak;\r\ncase DIBX000_SLOW_ADC_OFF:\r\nif (state->revision == 0x8090) {\r\nreg = dib8000_read_word(state, 1925);\r\ndib8000_write_word(state, 1925,\r\n(reg & ~(1<<2)) | (1<<4));\r\n}\r\nreg_908 |= (1 << 1) | (1 << 0);\r\nbreak;\r\ncase DIBX000_ADC_ON:\r\nreg_907 &= 0x0fff;\r\nreg_908 &= 0x0003;\r\nbreak;\r\ncase DIBX000_ADC_OFF:\r\nreg_907 = (1 << 13) | (1 << 12);\r\nreg_908 = (1 << 6) | (1 << 5) | (1 << 4) | (1 << 3) | (1 << 1);\r\nbreak;\r\ncase DIBX000_VBG_ENABLE:\r\nreg_907 &= ~(1 << 15);\r\nbreak;\r\ncase DIBX000_VBG_DISABLE:\r\nreg_907 |= (1 << 15);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nret |= dib8000_write_word(state, 907, reg_907);\r\nret |= dib8000_write_word(state, 908, reg_908);\r\nreturn ret;\r\n}\r\nstatic int dib8000_set_bandwidth(struct dvb_frontend *fe, u32 bw)\r\n{\r\nstruct dib8000_state *state = fe->demodulator_priv;\r\nu32 timf;\r\nif (bw == 0)\r\nbw = 6000;\r\nif (state->timf == 0) {\r\ndprintk("using default timf");\r\ntimf = state->timf_default;\r\n} else {\r\ndprintk("using updated timf");\r\ntimf = state->timf;\r\n}\r\ndib8000_write_word(state, 29, (u16) ((timf >> 16) & 0xffff));\r\ndib8000_write_word(state, 30, (u16) ((timf) & 0xffff));\r\nreturn 0;\r\n}\r\nstatic int dib8000_sad_calib(struct dib8000_state *state)\r\n{\r\nu8 sad_sel = 3;\r\nif (state->revision == 0x8090) {\r\ndib8000_write_word(state, 922, (sad_sel << 2));\r\ndib8000_write_word(state, 923, 2048);\r\ndib8000_write_word(state, 922, (sad_sel << 2) | 0x1);\r\ndib8000_write_word(state, 922, (sad_sel << 2));\r\n} else {\r\ndib8000_write_word(state, 923, (0 << 1) | (0 << 0));\r\ndib8000_write_word(state, 924, 776);\r\ndib8000_write_word(state, 923, (1 << 0));\r\ndib8000_write_word(state, 923, (0 << 0));\r\n}\r\nmsleep(1);\r\nreturn 0;\r\n}\r\nstatic int dib8000_set_wbd_ref(struct dvb_frontend *fe, u16 value)\r\n{\r\nstruct dib8000_state *state = fe->demodulator_priv;\r\nif (value > 4095)\r\nvalue = 4095;\r\nstate->wbd_ref = value;\r\nreturn dib8000_write_word(state, 106, value);\r\n}\r\nstatic void dib8000_reset_pll_common(struct dib8000_state *state, const struct dibx000_bandwidth_config *bw)\r\n{\r\ndprintk("ifreq: %d %x, inversion: %d", bw->ifreq, bw->ifreq, bw->ifreq >> 25);\r\nif (state->revision != 0x8090) {\r\ndib8000_write_word(state, 23,\r\n(u16) (((bw->internal * 1000) >> 16) & 0xffff));\r\ndib8000_write_word(state, 24,\r\n(u16) ((bw->internal * 1000) & 0xffff));\r\n} else {\r\ndib8000_write_word(state, 23, (u16) (((bw->internal / 2 * 1000) >> 16) & 0xffff));\r\ndib8000_write_word(state, 24,\r\n(u16) ((bw->internal / 2 * 1000) & 0xffff));\r\n}\r\ndib8000_write_word(state, 27, (u16) ((bw->ifreq >> 16) & 0x01ff));\r\ndib8000_write_word(state, 28, (u16) (bw->ifreq & 0xffff));\r\ndib8000_write_word(state, 26, (u16) ((bw->ifreq >> 25) & 0x0003));\r\nif (state->revision != 0x8090)\r\ndib8000_write_word(state, 922, bw->sad_cfg);\r\n}\r\nstatic void dib8000_reset_pll(struct dib8000_state *state)\r\n{\r\nconst struct dibx000_bandwidth_config *pll = state->cfg.pll;\r\nu16 clk_cfg1, reg;\r\nif (state->revision != 0x8090) {\r\ndib8000_write_word(state, 901,\r\n(pll->pll_prediv << 8) | (pll->pll_ratio << 0));\r\nclk_cfg1 = (1 << 10) | (0 << 9) | (pll->IO_CLK_en_core << 8) |\r\n(pll->bypclk_div << 5) | (pll->enable_refdiv << 4) |\r\n(1 << 3) | (pll->pll_range << 1) |\r\n(pll->pll_reset << 0);\r\ndib8000_write_word(state, 902, clk_cfg1);\r\nclk_cfg1 = (clk_cfg1 & 0xfff7) | (pll->pll_bypass << 3);\r\ndib8000_write_word(state, 902, clk_cfg1);\r\ndprintk("clk_cfg1: 0x%04x", clk_cfg1);\r\nif (state->cfg.pll->ADClkSrc == 0)\r\ndib8000_write_word(state, 904,\r\n(0 << 15) | (0 << 12) | (0 << 10) |\r\n(pll->modulo << 8) |\r\n(pll->ADClkSrc << 7) | (0 << 1));\r\nelse if (state->cfg.refclksel != 0)\r\ndib8000_write_word(state, 904, (0 << 15) | (1 << 12) |\r\n((state->cfg.refclksel & 0x3) << 10) |\r\n(pll->modulo << 8) |\r\n(pll->ADClkSrc << 7) | (0 << 1));\r\nelse\r\ndib8000_write_word(state, 904, (0 << 15) | (1 << 12) |\r\n(3 << 10) | (pll->modulo << 8) |\r\n(pll->ADClkSrc << 7) | (0 << 1));\r\n} else {\r\ndib8000_write_word(state, 1856, (!pll->pll_reset<<13) |\r\n(pll->pll_range<<12) | (pll->pll_ratio<<6) |\r\n(pll->pll_prediv));\r\nreg = dib8000_read_word(state, 1857);\r\ndib8000_write_word(state, 1857, reg|(!pll->pll_bypass<<15));\r\nreg = dib8000_read_word(state, 1858);\r\ndib8000_write_word(state, 1858, reg | 1);\r\ndib8000_write_word(state, 904, (pll->modulo << 8));\r\n}\r\ndib8000_reset_pll_common(state, pll);\r\n}\r\nstatic int dib8000_update_pll(struct dvb_frontend *fe,\r\nstruct dibx000_bandwidth_config *pll, u32 bw, u8 ratio)\r\n{\r\nstruct dib8000_state *state = fe->demodulator_priv;\r\nu16 reg_1857, reg_1856 = dib8000_read_word(state, 1856);\r\nu8 loopdiv, prediv, oldprediv = state->cfg.pll->pll_prediv ;\r\nu32 internal, xtal;\r\nprediv = reg_1856 & 0x3f;\r\nloopdiv = (reg_1856 >> 6) & 0x3f;\r\nif ((pll == NULL) || (pll->pll_prediv == prediv &&\r\npll->pll_ratio == loopdiv))\r\nreturn -EINVAL;\r\ndprintk("Updating pll (prediv: old = %d new = %d ; loopdiv : old = %d new = %d)", prediv, pll->pll_prediv, loopdiv, pll->pll_ratio);\r\nif (state->revision == 0x8090) {\r\nreg_1856 &= 0xf000;\r\nreg_1857 = dib8000_read_word(state, 1857);\r\ndib8000_write_word(state, 1857, reg_1857 & ~(1 << 15));\r\ndib8000_write_word(state, 1856, reg_1856 |\r\n((pll->pll_ratio & 0x3f) << 6) |\r\n(pll->pll_prediv & 0x3f));\r\ninternal = dib8000_read32(state, 23) / 1000;\r\ndprintk("Old Internal = %d", internal);\r\nxtal = 2 * (internal / loopdiv) * prediv;\r\ninternal = 1000 * (xtal/pll->pll_prediv) * pll->pll_ratio;\r\ndprintk("Xtal = %d , New Fmem = %d New Fdemod = %d, New Fsampling = %d", xtal, internal/1000, internal/2000, internal/8000);\r\ndprintk("New Internal = %d", internal);\r\ndib8000_write_word(state, 23,\r\n(u16) (((internal / 2) >> 16) & 0xffff));\r\ndib8000_write_word(state, 24, (u16) ((internal / 2) & 0xffff));\r\ndib8000_write_word(state, 1857, reg_1857 | (1 << 15));\r\nwhile (((dib8000_read_word(state, 1856)>>15)&0x1) != 1)\r\ndprintk("Waiting for PLL to lock");\r\nreg_1856 = dib8000_read_word(state, 1856);\r\ndprintk("PLL Updated with prediv = %d and loopdiv = %d",\r\nreg_1856&0x3f, (reg_1856>>6)&0x3f);\r\n} else {\r\nif (bw != state->current_demod_bw) {\r\ndprintk("PLL: Bandwidth Change %d MHz -> %d MHz (prediv: %d->%d)", state->current_demod_bw / 1000, bw / 1000, oldprediv, state->cfg.pll->pll_prediv);\r\nif (state->cfg.pll->pll_prediv != oldprediv) {\r\ndprintk("PLL: New Setting for %d MHz Bandwidth (prediv: %d, ratio: %d)", bw/1000, state->cfg.pll->pll_prediv, state->cfg.pll->pll_ratio);\r\ndib8000_write_word(state, 902, dib8000_read_word(state, 902) | (1<<3));\r\ndib8000_reset_pll(state);\r\ndib8000_write_word(state, 898, 0x0004);\r\n} else\r\nratio = state->cfg.pll->pll_ratio;\r\nstate->current_demod_bw = bw;\r\n}\r\nif (ratio != 0) {\r\ndprintk("PLL: Update ratio (prediv: %d, ratio: %d)", state->cfg.pll->pll_prediv, ratio);\r\ndib8000_write_word(state, 901, (state->cfg.pll->pll_prediv << 8) | (ratio << 0));\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int dib8000_reset_gpio(struct dib8000_state *st)\r\n{\r\ndib8000_write_word(st, 1029, st->cfg.gpio_dir);\r\ndib8000_write_word(st, 1030, st->cfg.gpio_val);\r\ndib8000_write_word(st, 1032, st->cfg.gpio_pwm_pos);\r\ndib8000_write_word(st, 1037, st->cfg.pwm_freq_div);\r\nreturn 0;\r\n}\r\nstatic int dib8000_cfg_gpio(struct dib8000_state *st, u8 num, u8 dir, u8 val)\r\n{\r\nst->cfg.gpio_dir = dib8000_read_word(st, 1029);\r\nst->cfg.gpio_dir &= ~(1 << num);\r\nst->cfg.gpio_dir |= (dir & 0x1) << num;\r\ndib8000_write_word(st, 1029, st->cfg.gpio_dir);\r\nst->cfg.gpio_val = dib8000_read_word(st, 1030);\r\nst->cfg.gpio_val &= ~(1 << num);\r\nst->cfg.gpio_val |= (val & 0x01) << num;\r\ndib8000_write_word(st, 1030, st->cfg.gpio_val);\r\ndprintk("gpio dir: %x: gpio val: %x", st->cfg.gpio_dir, st->cfg.gpio_val);\r\nreturn 0;\r\n}\r\nstatic int dib8000_set_gpio(struct dvb_frontend *fe, u8 num, u8 dir, u8 val)\r\n{\r\nstruct dib8000_state *state = fe->demodulator_priv;\r\nreturn dib8000_cfg_gpio(state, num, dir, val);\r\n}\r\nstatic u16 dib8000_identify(struct i2c_device *client)\r\n{\r\nu16 value;\r\nvalue = dib8000_i2c_read16(client, 896);\r\nif ((value = dib8000_i2c_read16(client, 896)) != 0x01b3) {\r\ndprintk("wrong Vendor ID (read=0x%x)", value);\r\nreturn 0;\r\n}\r\nvalue = dib8000_i2c_read16(client, 897);\r\nif (value != 0x8000 && value != 0x8001 &&\r\nvalue != 0x8002 && value != 0x8090) {\r\ndprintk("wrong Device ID (%x)", value);\r\nreturn 0;\r\n}\r\nswitch (value) {\r\ncase 0x8000:\r\ndprintk("found DiB8000A");\r\nbreak;\r\ncase 0x8001:\r\ndprintk("found DiB8000B");\r\nbreak;\r\ncase 0x8002:\r\ndprintk("found DiB8000C");\r\nbreak;\r\ncase 0x8090:\r\ndprintk("found DiB8096P");\r\nbreak;\r\n}\r\nreturn value;\r\n}\r\nstatic void dib8000_reset_stats(struct dvb_frontend *fe)\r\n{\r\nstruct dib8000_state *state = fe->demodulator_priv;\r\nstruct dtv_frontend_properties *c = &state->fe[0]->dtv_property_cache;\r\nu32 ucb;\r\nmemset(&c->strength, 0, sizeof(c->strength));\r\nmemset(&c->cnr, 0, sizeof(c->cnr));\r\nmemset(&c->post_bit_error, 0, sizeof(c->post_bit_error));\r\nmemset(&c->post_bit_count, 0, sizeof(c->post_bit_count));\r\nmemset(&c->block_error, 0, sizeof(c->block_error));\r\nc->strength.len = 1;\r\nc->cnr.len = 1;\r\nc->block_error.len = 1;\r\nc->block_count.len = 1;\r\nc->post_bit_error.len = 1;\r\nc->post_bit_count.len = 1;\r\nc->strength.stat[0].scale = FE_SCALE_DECIBEL;\r\nc->strength.stat[0].uvalue = 0;\r\nc->cnr.stat[0].scale = FE_SCALE_NOT_AVAILABLE;\r\nc->block_error.stat[0].scale = FE_SCALE_NOT_AVAILABLE;\r\nc->block_count.stat[0].scale = FE_SCALE_NOT_AVAILABLE;\r\nc->post_bit_error.stat[0].scale = FE_SCALE_NOT_AVAILABLE;\r\nc->post_bit_count.stat[0].scale = FE_SCALE_NOT_AVAILABLE;\r\ndib8000_read_unc_blocks(fe, &ucb);\r\nstate->init_ucb = -ucb;\r\nstate->ber_jiffies_stats = 0;\r\nstate->per_jiffies_stats = 0;\r\nmemset(&state->ber_jiffies_stats_layer, 0,\r\nsizeof(state->ber_jiffies_stats_layer));\r\n}\r\nstatic int dib8000_reset(struct dvb_frontend *fe)\r\n{\r\nstruct dib8000_state *state = fe->demodulator_priv;\r\nif ((state->revision = dib8000_identify(&state->i2c)) == 0)\r\nreturn -EINVAL;\r\nif (state->revision != 0x8090)\r\ndib8000_write_word(state, 1287, 0x0003);\r\nif (state->revision == 0x8000)\r\ndprintk("error : dib8000 MA not supported");\r\ndibx000_reset_i2c_master(&state->i2c_master);\r\ndib8000_set_power_mode(state, DIB8000_POWER_ALL);\r\ndib8000_set_adc_state(state, DIBX000_ADC_OFF);\r\ndib8000_write_word(state, 770, 0xffff);\r\ndib8000_write_word(state, 771, 0xffff);\r\ndib8000_write_word(state, 772, 0xfffc);\r\ndib8000_write_word(state, 898, 0x000c);\r\nif (state->revision == 0x8090)\r\ndib8000_write_word(state, 1280, 0x0045);\r\nelse\r\ndib8000_write_word(state, 1280, 0x004d);\r\ndib8000_write_word(state, 1281, 0x000c);\r\ndib8000_write_word(state, 770, 0x0000);\r\ndib8000_write_word(state, 771, 0x0000);\r\ndib8000_write_word(state, 772, 0x0000);\r\ndib8000_write_word(state, 898, 0x0004);\r\ndib8000_write_word(state, 1280, 0x0000);\r\ndib8000_write_word(state, 1281, 0x0000);\r\nif (state->revision != 0x8090) {\r\nif (state->cfg.drives)\r\ndib8000_write_word(state, 906, state->cfg.drives);\r\nelse {\r\ndprintk("using standard PAD-drive-settings, please adjust settings in config-struct to be optimal.");\r\ndib8000_write_word(state, 906, 0x2d98);\r\n}\r\n}\r\ndib8000_reset_pll(state);\r\nif (state->revision != 0x8090)\r\ndib8000_write_word(state, 898, 0x0004);\r\nif (dib8000_reset_gpio(state) != 0)\r\ndprintk("GPIO reset was not successful.");\r\nif ((state->revision != 0x8090) &&\r\n(dib8000_set_output_mode(fe, OUTMODE_HIGH_Z) != 0))\r\ndprintk("OUTPUT_MODE could not be resetted.");\r\nstate->current_agc = NULL;\r\nif (state->cfg.pll->ifreq == 0)\r\ndib8000_write_word(state, 40, 0x0755);\r\nelse\r\ndib8000_write_word(state, 40, 0x1f55);\r\n{\r\nu16 l = 0, r;\r\nconst u16 *n;\r\nn = dib8000_defaults;\r\nl = *n++;\r\nwhile (l) {\r\nr = *n++;\r\ndo {\r\ndib8000_write_word(state, r, *n++);\r\nr++;\r\n} while (--l);\r\nl = *n++;\r\n}\r\n}\r\nstate->isdbt_cfg_loaded = 0;\r\nif ((state->revision != 8090) && (state->cfg.div_cfg != 0))\r\ndib8000_write_word(state, 903, state->cfg.div_cfg);\r\ndib8000_write_word(state, 1285, dib8000_read_word(state, 1285) & ~(1 << 1));\r\ndib8000_set_bandwidth(fe, 6000);\r\ndib8000_set_adc_state(state, DIBX000_SLOW_ADC_ON);\r\ndib8000_sad_calib(state);\r\nif (state->revision != 0x8090)\r\ndib8000_set_adc_state(state, DIBX000_SLOW_ADC_OFF);\r\ndib8000_write_word(state, 285, (dib8000_read_word(state, 285) & ~0x60) | (3 << 5));\r\ndib8000_set_power_mode(state, DIB8000_POWER_INTERFACE_ONLY);\r\ndib8000_reset_stats(fe);\r\nreturn 0;\r\n}\r\nstatic void dib8000_restart_agc(struct dib8000_state *state)\r\n{\r\ndib8000_write_word(state, 770, 0x0a00);\r\ndib8000_write_word(state, 770, 0x0000);\r\n}\r\nstatic int dib8000_update_lna(struct dib8000_state *state)\r\n{\r\nu16 dyn_gain;\r\nif (state->cfg.update_lna) {\r\ndyn_gain = dib8000_read_word(state, 390);\r\nif (state->cfg.update_lna(state->fe[0], dyn_gain)) {\r\ndib8000_restart_agc(state);\r\nreturn 1;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int dib8000_set_agc_config(struct dib8000_state *state, u8 band)\r\n{\r\nstruct dibx000_agc_config *agc = NULL;\r\nint i;\r\nu16 reg;\r\nif (state->current_band == band && state->current_agc != NULL)\r\nreturn 0;\r\nstate->current_band = band;\r\nfor (i = 0; i < state->cfg.agc_config_count; i++)\r\nif (state->cfg.agc[i].band_caps & band) {\r\nagc = &state->cfg.agc[i];\r\nbreak;\r\n}\r\nif (agc == NULL) {\r\ndprintk("no valid AGC configuration found for band 0x%02x", band);\r\nreturn -EINVAL;\r\n}\r\nstate->current_agc = agc;\r\ndib8000_write_word(state, 76, agc->setup);\r\ndib8000_write_word(state, 77, agc->inv_gain);\r\ndib8000_write_word(state, 78, agc->time_stabiliz);\r\ndib8000_write_word(state, 101, (agc->alpha_level << 12) | agc->thlock);\r\ndib8000_write_word(state, 102, (agc->alpha_mant << 5) | agc->alpha_exp);\r\ndib8000_write_word(state, 103, (agc->beta_mant << 6) | agc->beta_exp);\r\ndprintk("WBD: ref: %d, sel: %d, active: %d, alpha: %d",\r\nstate->wbd_ref != 0 ? state->wbd_ref : agc->wbd_ref, agc->wbd_sel, !agc->perform_agc_softsplit, agc->wbd_sel);\r\nif (state->wbd_ref != 0)\r\ndib8000_write_word(state, 106, state->wbd_ref);\r\nelse\r\ndib8000_write_word(state, 106, agc->wbd_ref);\r\nif (state->revision == 0x8090) {\r\nreg = dib8000_read_word(state, 922) & (0x3 << 2);\r\ndib8000_write_word(state, 922, reg | (agc->wbd_sel << 2));\r\n}\r\ndib8000_write_word(state, 107, (agc->wbd_alpha << 9) | (agc->perform_agc_softsplit << 8));\r\ndib8000_write_word(state, 108, agc->agc1_max);\r\ndib8000_write_word(state, 109, agc->agc1_min);\r\ndib8000_write_word(state, 110, agc->agc2_max);\r\ndib8000_write_word(state, 111, agc->agc2_min);\r\ndib8000_write_word(state, 112, (agc->agc1_pt1 << 8) | agc->agc1_pt2);\r\ndib8000_write_word(state, 113, (agc->agc1_slope1 << 8) | agc->agc1_slope2);\r\ndib8000_write_word(state, 114, (agc->agc2_pt1 << 8) | agc->agc2_pt2);\r\ndib8000_write_word(state, 115, (agc->agc2_slope1 << 8) | agc->agc2_slope2);\r\ndib8000_write_word(state, 75, agc->agc1_pt3);\r\nif (state->revision != 0x8090)\r\ndib8000_write_word(state, 923,\r\n(dib8000_read_word(state, 923) & 0xffe3) |\r\n(agc->wbd_inv << 4) | (agc->wbd_sel << 2));\r\nreturn 0;\r\n}\r\nstatic void dib8000_pwm_agc_reset(struct dvb_frontend *fe)\r\n{\r\nstruct dib8000_state *state = fe->demodulator_priv;\r\ndib8000_set_adc_state(state, DIBX000_ADC_ON);\r\ndib8000_set_agc_config(state, (unsigned char)(BAND_OF_FREQUENCY(fe->dtv_property_cache.frequency / 1000)));\r\n}\r\nstatic int dib8000_agc_soft_split(struct dib8000_state *state)\r\n{\r\nu16 agc, split_offset;\r\nif (!state->current_agc || !state->current_agc->perform_agc_softsplit || state->current_agc->split.max == 0)\r\nreturn 0;\r\nagc = dib8000_read_word(state, 390);\r\nif (agc > state->current_agc->split.min_thres)\r\nsplit_offset = state->current_agc->split.min;\r\nelse if (agc < state->current_agc->split.max_thres)\r\nsplit_offset = state->current_agc->split.max;\r\nelse\r\nsplit_offset = state->current_agc->split.max *\r\n(agc - state->current_agc->split.min_thres) /\r\n(state->current_agc->split.max_thres - state->current_agc->split.min_thres);\r\ndprintk("AGC split_offset: %d", split_offset);\r\ndib8000_write_word(state, 107, (dib8000_read_word(state, 107) & 0xff00) | split_offset);\r\nreturn 5000;\r\n}\r\nstatic int dib8000_agc_startup(struct dvb_frontend *fe)\r\n{\r\nstruct dib8000_state *state = fe->demodulator_priv;\r\nenum frontend_tune_state *tune_state = &state->tune_state;\r\nint ret = 0;\r\nu16 reg;\r\nu32 upd_demod_gain_period = 0x8000;\r\nswitch (*tune_state) {\r\ncase CT_AGC_START:\r\nif (state->revision != 0x8090)\r\ndib8000_set_adc_state(state, DIBX000_ADC_ON);\r\nelse {\r\ndib8000_set_power_mode(state, DIB8000_POWER_ALL);\r\nreg = dib8000_read_word(state, 1947)&0xff00;\r\ndib8000_write_word(state, 1946,\r\nupd_demod_gain_period & 0xFFFF);\r\ndib8000_write_word(state, 1947, reg | (1<<14) |\r\n((upd_demod_gain_period >> 16) & 0xFF));\r\nreg = dib8000_read_word(state, 1920);\r\ndib8000_write_word(state, 1920, (reg | 0x3) &\r\n(~(1 << 7)));\r\n}\r\nif (dib8000_set_agc_config(state, (unsigned char)(BAND_OF_FREQUENCY(fe->dtv_property_cache.frequency / 1000))) != 0) {\r\n*tune_state = CT_AGC_STOP;\r\nstate->status = FE_STATUS_TUNE_FAILED;\r\nbreak;\r\n}\r\nret = 70;\r\n*tune_state = CT_AGC_STEP_0;\r\nbreak;\r\ncase CT_AGC_STEP_0:\r\nif (state->cfg.agc_control)\r\nstate->cfg.agc_control(fe, 1);\r\ndib8000_restart_agc(state);\r\nret = 50;\r\n*tune_state = CT_AGC_STEP_1;\r\nbreak;\r\ncase CT_AGC_STEP_1:\r\nret = 70;\r\nif (dib8000_update_lna(state))\r\nret = 50;\r\nelse\r\n*tune_state = CT_AGC_STEP_2;\r\nbreak;\r\ncase CT_AGC_STEP_2:\r\ndib8000_agc_soft_split(state);\r\nif (state->cfg.agc_control)\r\nstate->cfg.agc_control(fe, 0);\r\n*tune_state = CT_AGC_STOP;\r\nbreak;\r\ndefault:\r\nret = dib8000_agc_soft_split(state);\r\nbreak;\r\n}\r\nreturn ret;\r\n}\r\nstatic void dib8096p_host_bus_drive(struct dib8000_state *state, u8 drive)\r\n{\r\nu16 reg;\r\ndrive &= 0x7;\r\nreg = dib8000_read_word(state, 1798) &\r\n~(0x7 | (0x7 << 6) | (0x7 << 12));\r\nreg |= (drive<<12) | (drive<<6) | drive;\r\ndib8000_write_word(state, 1798, reg);\r\nreg = dib8000_read_word(state, 1799) & ~((0x7 << 2) | (0x7 << 8));\r\nreg |= (drive<<8) | (drive<<2);\r\ndib8000_write_word(state, 1799, reg);\r\nreg = dib8000_read_word(state, 1800) &\r\n~(0x7 | (0x7 << 6) | (0x7 << 12));\r\nreg |= (drive<<12) | (drive<<6) | drive;\r\ndib8000_write_word(state, 1800, reg);\r\nreg = dib8000_read_word(state, 1801) & ~((0x7 << 2) | (0x7 << 8));\r\nreg |= (drive<<8) | (drive<<2);\r\ndib8000_write_word(state, 1801, reg);\r\nreg = dib8000_read_word(state, 1802) &\r\n~(0x7 | (0x7 << 6) | (0x7 << 12));\r\nreg |= (drive<<12) | (drive<<6) | drive;\r\ndib8000_write_word(state, 1802, reg);\r\n}\r\nstatic u32 dib8096p_calcSyncFreq(u32 P_Kin, u32 P_Kout,\r\nu32 insertExtSynchro, u32 syncSize)\r\n{\r\nu32 quantif = 3;\r\nu32 nom = (insertExtSynchro * P_Kin+syncSize);\r\nu32 denom = P_Kout;\r\nu32 syncFreq = ((nom << quantif) / denom);\r\nif ((syncFreq & ((1 << quantif) - 1)) != 0)\r\nsyncFreq = (syncFreq >> quantif) + 1;\r\nelse\r\nsyncFreq = (syncFreq >> quantif);\r\nif (syncFreq != 0)\r\nsyncFreq = syncFreq - 1;\r\nreturn syncFreq;\r\n}\r\nstatic void dib8096p_cfg_DibTx(struct dib8000_state *state, u32 P_Kin,\r\nu32 P_Kout, u32 insertExtSynchro, u32 synchroMode,\r\nu32 syncWord, u32 syncSize)\r\n{\r\ndprintk("Configure DibStream Tx");\r\ndib8000_write_word(state, 1615, 1);\r\ndib8000_write_word(state, 1603, P_Kin);\r\ndib8000_write_word(state, 1605, P_Kout);\r\ndib8000_write_word(state, 1606, insertExtSynchro);\r\ndib8000_write_word(state, 1608, synchroMode);\r\ndib8000_write_word(state, 1609, (syncWord >> 16) & 0xffff);\r\ndib8000_write_word(state, 1610, syncWord & 0xffff);\r\ndib8000_write_word(state, 1612, syncSize);\r\ndib8000_write_word(state, 1615, 0);\r\n}\r\nstatic void dib8096p_cfg_DibRx(struct dib8000_state *state, u32 P_Kin,\r\nu32 P_Kout, u32 synchroMode, u32 insertExtSynchro,\r\nu32 syncWord, u32 syncSize, u32 dataOutRate)\r\n{\r\nu32 syncFreq;\r\ndprintk("Configure DibStream Rx synchroMode = %d", synchroMode);\r\nif ((P_Kin != 0) && (P_Kout != 0)) {\r\nsyncFreq = dib8096p_calcSyncFreq(P_Kin, P_Kout,\r\ninsertExtSynchro, syncSize);\r\ndib8000_write_word(state, 1542, syncFreq);\r\n}\r\ndib8000_write_word(state, 1554, 1);\r\ndib8000_write_word(state, 1536, P_Kin);\r\ndib8000_write_word(state, 1537, P_Kout);\r\ndib8000_write_word(state, 1539, synchroMode);\r\ndib8000_write_word(state, 1540, (syncWord >> 16) & 0xffff);\r\ndib8000_write_word(state, 1541, syncWord & 0xffff);\r\ndib8000_write_word(state, 1543, syncSize);\r\ndib8000_write_word(state, 1544, dataOutRate);\r\ndib8000_write_word(state, 1554, 0);\r\n}\r\nstatic void dib8096p_enMpegMux(struct dib8000_state *state, int onoff)\r\n{\r\nu16 reg_1287;\r\nreg_1287 = dib8000_read_word(state, 1287);\r\nswitch (onoff) {\r\ncase 1:\r\nreg_1287 &= ~(1 << 8);\r\nbreak;\r\ncase 0:\r\nreg_1287 |= (1 << 8);\r\nbreak;\r\n}\r\ndib8000_write_word(state, 1287, reg_1287);\r\n}\r\nstatic void dib8096p_configMpegMux(struct dib8000_state *state,\r\nu16 pulseWidth, u16 enSerialMode, u16 enSerialClkDiv2)\r\n{\r\nu16 reg_1287;\r\ndprintk("Enable Mpeg mux");\r\ndib8096p_enMpegMux(state, 0);\r\nif ((enSerialMode == 1) && (state->input_mode_mpeg == 1))\r\nenSerialClkDiv2 = 0;\r\nreg_1287 = ((pulseWidth & 0x1f) << 3) |\r\n((enSerialMode & 0x1) << 2) | (enSerialClkDiv2 & 0x1);\r\ndib8000_write_word(state, 1287, reg_1287);\r\ndib8096p_enMpegMux(state, 1);\r\n}\r\nstatic void dib8096p_setDibTxMux(struct dib8000_state *state, int mode)\r\n{\r\nu16 reg_1288 = dib8000_read_word(state, 1288) & ~(0x7 << 7);\r\nswitch (mode) {\r\ncase MPEG_ON_DIBTX:\r\ndprintk("SET MPEG ON DIBSTREAM TX");\r\ndib8096p_cfg_DibTx(state, 8, 5, 0, 0, 0, 0);\r\nreg_1288 |= (1 << 9); break;\r\ncase DIV_ON_DIBTX:\r\ndprintk("SET DIV_OUT ON DIBSTREAM TX");\r\ndib8096p_cfg_DibTx(state, 5, 5, 0, 0, 0, 0);\r\nreg_1288 |= (1 << 8); break;\r\ncase ADC_ON_DIBTX:\r\ndprintk("SET ADC_OUT ON DIBSTREAM TX");\r\ndib8096p_cfg_DibTx(state, 20, 5, 10, 0, 0, 0);\r\nreg_1288 |= (1 << 7); break;\r\ndefault:\r\nbreak;\r\n}\r\ndib8000_write_word(state, 1288, reg_1288);\r\n}\r\nstatic void dib8096p_setHostBusMux(struct dib8000_state *state, int mode)\r\n{\r\nu16 reg_1288 = dib8000_read_word(state, 1288) & ~(0x7 << 4);\r\nswitch (mode) {\r\ncase DEMOUT_ON_HOSTBUS:\r\ndprintk("SET DEM OUT OLD INTERF ON HOST BUS");\r\ndib8096p_enMpegMux(state, 0);\r\nreg_1288 |= (1 << 6);\r\nbreak;\r\ncase DIBTX_ON_HOSTBUS:\r\ndprintk("SET DIBSTREAM TX ON HOST BUS");\r\ndib8096p_enMpegMux(state, 0);\r\nreg_1288 |= (1 << 5);\r\nbreak;\r\ncase MPEG_ON_HOSTBUS:\r\ndprintk("SET MPEG MUX ON HOST BUS");\r\nreg_1288 |= (1 << 4);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\ndib8000_write_word(state, 1288, reg_1288);\r\n}\r\nstatic int dib8096p_set_diversity_in(struct dvb_frontend *fe, int onoff)\r\n{\r\nstruct dib8000_state *state = fe->demodulator_priv;\r\nu16 reg_1287;\r\nswitch (onoff) {\r\ncase 0:\r\ndprintk("%s mode OFF : by default Enable Mpeg INPUT",\r\n__func__);\r\ndib8096p_cfg_DibRx(state, 8, 5, 0, 0, 0, 8, 0);\r\nreg_1287 = dib8000_read_word(state, 1287);\r\nif ((reg_1287 & 0x1) == 1) {\r\nreg_1287 &= ~0x1;\r\ndib8000_write_word(state, 1287, reg_1287);\r\n}\r\nstate->input_mode_mpeg = 1;\r\nbreak;\r\ncase 1:\r\ncase 2:\r\ndprintk("%s ON : Enable diversity INPUT", __func__);\r\ndib8096p_cfg_DibRx(state, 5, 5, 0, 0, 0, 0, 0);\r\nstate->input_mode_mpeg = 0;\r\nbreak;\r\n}\r\ndib8000_set_diversity_in(state->fe[0], onoff);\r\nreturn 0;\r\n}\r\nstatic int dib8096p_set_output_mode(struct dvb_frontend *fe, int mode)\r\n{\r\nstruct dib8000_state *state = fe->demodulator_priv;\r\nu16 outreg, smo_mode, fifo_threshold;\r\nu8 prefer_mpeg_mux_use = 1;\r\nint ret = 0;\r\nstate->output_mode = mode;\r\ndib8096p_host_bus_drive(state, 1);\r\nfifo_threshold = 1792;\r\nsmo_mode = (dib8000_read_word(state, 299) & 0x0050) | (1 << 1);\r\noutreg = dib8000_read_word(state, 1286) &\r\n~((1 << 10) | (0x7 << 6) | (1 << 1));\r\nswitch (mode) {\r\ncase OUTMODE_HIGH_Z:\r\noutreg = 0;\r\nbreak;\r\ncase OUTMODE_MPEG2_SERIAL:\r\nif (prefer_mpeg_mux_use) {\r\ndprintk("dib8096P setting output mode TS_SERIAL using Mpeg Mux");\r\ndib8096p_configMpegMux(state, 3, 1, 1);\r\ndib8096p_setHostBusMux(state, MPEG_ON_HOSTBUS);\r\n} else {\r\ndprintk("dib8096P setting output mode TS_SERIAL using Smooth bloc");\r\ndib8096p_setHostBusMux(state,\r\nDEMOUT_ON_HOSTBUS);\r\noutreg |= (2 << 6) | (0 << 1);\r\n}\r\nbreak;\r\ncase OUTMODE_MPEG2_PAR_GATED_CLK:\r\nif (prefer_mpeg_mux_use) {\r\ndprintk("dib8096P setting output mode TS_PARALLEL_GATED using Mpeg Mux");\r\ndib8096p_configMpegMux(state, 2, 0, 0);\r\ndib8096p_setHostBusMux(state, MPEG_ON_HOSTBUS);\r\n} else {\r\ndprintk("dib8096P setting output mode TS_PARALLEL_GATED using Smooth block");\r\ndib8096p_setHostBusMux(state,\r\nDEMOUT_ON_HOSTBUS);\r\noutreg |= (0 << 6);\r\n}\r\nbreak;\r\ncase OUTMODE_MPEG2_PAR_CONT_CLK:\r\ndprintk("dib8096P setting output mode TS_PARALLEL_CONT using Smooth block");\r\ndib8096p_setHostBusMux(state, DEMOUT_ON_HOSTBUS);\r\noutreg |= (1 << 6);\r\nbreak;\r\ncase OUTMODE_MPEG2_FIFO:\r\ndprintk("dib8096P setting output mode TS_FIFO using Smooth block");\r\ndib8096p_setHostBusMux(state, DEMOUT_ON_HOSTBUS);\r\noutreg |= (5 << 6);\r\nsmo_mode |= (3 << 1);\r\nfifo_threshold = 512;\r\nbreak;\r\ncase OUTMODE_DIVERSITY:\r\ndprintk("dib8096P setting output mode MODE_DIVERSITY");\r\ndib8096p_setDibTxMux(state, DIV_ON_DIBTX);\r\ndib8096p_setHostBusMux(state, DIBTX_ON_HOSTBUS);\r\nbreak;\r\ncase OUTMODE_ANALOG_ADC:\r\ndprintk("dib8096P setting output mode MODE_ANALOG_ADC");\r\ndib8096p_setDibTxMux(state, ADC_ON_DIBTX);\r\ndib8096p_setHostBusMux(state, DIBTX_ON_HOSTBUS);\r\nbreak;\r\n}\r\nif (mode != OUTMODE_HIGH_Z)\r\noutreg |= (1<<10);\r\ndprintk("output_mpeg2_in_188_bytes = %d",\r\nstate->cfg.output_mpeg2_in_188_bytes);\r\nif (state->cfg.output_mpeg2_in_188_bytes)\r\nsmo_mode |= (1 << 5);\r\nret |= dib8000_write_word(state, 299, smo_mode);\r\nret |= dib8000_write_word(state, 299 + 1, fifo_threshold);\r\nret |= dib8000_write_word(state, 1286, outreg);\r\nreturn ret;\r\n}\r\nstatic int map_addr_to_serpar_number(struct i2c_msg *msg)\r\n{\r\nif (msg->buf[0] <= 15)\r\nmsg->buf[0] -= 1;\r\nelse if (msg->buf[0] == 17)\r\nmsg->buf[0] = 15;\r\nelse if (msg->buf[0] == 16)\r\nmsg->buf[0] = 17;\r\nelse if (msg->buf[0] == 19)\r\nmsg->buf[0] = 16;\r\nelse if (msg->buf[0] >= 21 && msg->buf[0] <= 25)\r\nmsg->buf[0] -= 3;\r\nelse if (msg->buf[0] == 28)\r\nmsg->buf[0] = 23;\r\nelse if (msg->buf[0] == 99)\r\nmsg->buf[0] = 99;\r\nelse\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\nstatic int dib8096p_tuner_write_serpar(struct i2c_adapter *i2c_adap,\r\nstruct i2c_msg msg[], int num)\r\n{\r\nstruct dib8000_state *state = i2c_get_adapdata(i2c_adap);\r\nu8 n_overflow = 1;\r\nu16 i = 1000;\r\nu16 serpar_num = msg[0].buf[0];\r\nwhile (n_overflow == 1 && i) {\r\nn_overflow = (dib8000_read_word(state, 1984) >> 1) & 0x1;\r\ni--;\r\nif (i == 0)\r\ndprintk("Tuner ITF: write busy (overflow)");\r\n}\r\ndib8000_write_word(state, 1985, (1 << 6) | (serpar_num & 0x3f));\r\ndib8000_write_word(state, 1986, (msg[0].buf[1] << 8) | msg[0].buf[2]);\r\nreturn num;\r\n}\r\nstatic int dib8096p_tuner_read_serpar(struct i2c_adapter *i2c_adap,\r\nstruct i2c_msg msg[], int num)\r\n{\r\nstruct dib8000_state *state = i2c_get_adapdata(i2c_adap);\r\nu8 n_overflow = 1, n_empty = 1;\r\nu16 i = 1000;\r\nu16 serpar_num = msg[0].buf[0];\r\nu16 read_word;\r\nwhile (n_overflow == 1 && i) {\r\nn_overflow = (dib8000_read_word(state, 1984) >> 1) & 0x1;\r\ni--;\r\nif (i == 0)\r\ndprintk("TunerITF: read busy (overflow)");\r\n}\r\ndib8000_write_word(state, 1985, (0<<6) | (serpar_num&0x3f));\r\ni = 1000;\r\nwhile (n_empty == 1 && i) {\r\nn_empty = dib8000_read_word(state, 1984)&0x1;\r\ni--;\r\nif (i == 0)\r\ndprintk("TunerITF: read busy (empty)");\r\n}\r\nread_word = dib8000_read_word(state, 1987);\r\nmsg[1].buf[0] = (read_word >> 8) & 0xff;\r\nmsg[1].buf[1] = (read_word) & 0xff;\r\nreturn num;\r\n}\r\nstatic int dib8096p_tuner_rw_serpar(struct i2c_adapter *i2c_adap,\r\nstruct i2c_msg msg[], int num)\r\n{\r\nif (map_addr_to_serpar_number(&msg[0]) == 0) {\r\nif (num == 1)\r\nreturn dib8096p_tuner_write_serpar(i2c_adap, msg, 1);\r\nelse\r\nreturn dib8096p_tuner_read_serpar(i2c_adap, msg, 2);\r\n}\r\nreturn num;\r\n}\r\nstatic int dib8096p_rw_on_apb(struct i2c_adapter *i2c_adap,\r\nstruct i2c_msg msg[], int num, u16 apb_address)\r\n{\r\nstruct dib8000_state *state = i2c_get_adapdata(i2c_adap);\r\nu16 word;\r\nif (num == 1) {\r\ndib8000_write_word(state, apb_address,\r\n((msg[0].buf[1] << 8) | (msg[0].buf[2])));\r\n} else {\r\nword = dib8000_read_word(state, apb_address);\r\nmsg[1].buf[0] = (word >> 8) & 0xff;\r\nmsg[1].buf[1] = (word) & 0xff;\r\n}\r\nreturn num;\r\n}\r\nstatic int dib8096p_tuner_xfer(struct i2c_adapter *i2c_adap,\r\nstruct i2c_msg msg[], int num)\r\n{\r\nstruct dib8000_state *state = i2c_get_adapdata(i2c_adap);\r\nu16 apb_address = 0, word;\r\nint i = 0;\r\nswitch (msg[0].buf[0]) {\r\ncase 0x12:\r\napb_address = 1920;\r\nbreak;\r\ncase 0x14:\r\napb_address = 1921;\r\nbreak;\r\ncase 0x24:\r\napb_address = 1922;\r\nbreak;\r\ncase 0x1a:\r\napb_address = 1923;\r\nbreak;\r\ncase 0x22:\r\napb_address = 1924;\r\nbreak;\r\ncase 0x33:\r\napb_address = 1926;\r\nbreak;\r\ncase 0x34:\r\napb_address = 1927;\r\nbreak;\r\ncase 0x35:\r\napb_address = 1928;\r\nbreak;\r\ncase 0x36:\r\napb_address = 1929;\r\nbreak;\r\ncase 0x37:\r\napb_address = 1930;\r\nbreak;\r\ncase 0x38:\r\napb_address = 1931;\r\nbreak;\r\ncase 0x39:\r\napb_address = 1932;\r\nbreak;\r\ncase 0x2a:\r\napb_address = 1935;\r\nbreak;\r\ncase 0x2b:\r\napb_address = 1936;\r\nbreak;\r\ncase 0x2c:\r\napb_address = 1937;\r\nbreak;\r\ncase 0x2d:\r\napb_address = 1938;\r\nbreak;\r\ncase 0x2e:\r\napb_address = 1939;\r\nbreak;\r\ncase 0x2f:\r\napb_address = 1940;\r\nbreak;\r\ncase 0x30:\r\napb_address = 1941;\r\nbreak;\r\ncase 0x31:\r\napb_address = 1942;\r\nbreak;\r\ncase 0x32:\r\napb_address = 1943;\r\nbreak;\r\ncase 0x3e:\r\napb_address = 1944;\r\nbreak;\r\ncase 0x3f:\r\napb_address = 1945;\r\nbreak;\r\ncase 0x40:\r\napb_address = 1948;\r\nbreak;\r\ncase 0x25:\r\napb_address = 936;\r\nbreak;\r\ncase 0x26:\r\napb_address = 937;\r\nbreak;\r\ncase 0x27:\r\napb_address = 938;\r\nbreak;\r\ncase 0x28:\r\napb_address = 939;\r\nbreak;\r\ncase 0x1d:\r\ni = ((dib8000_read_word(state, 921) >> 12)&0x3);\r\nword = dib8000_read_word(state, 924+i);\r\nmsg[1].buf[0] = (word >> 8) & 0xff;\r\nmsg[1].buf[1] = (word) & 0xff;\r\nreturn num;\r\ncase 0x1f:\r\nif (num == 1) {\r\nword = (u16) ((msg[0].buf[1] << 8) |\r\nmsg[0].buf[2]);\r\nword &= 0x3;\r\nword = (dib8000_read_word(state, 921) &\r\n~(3<<12)) | (word<<12);\r\ndib8000_write_word(state, 921, word);\r\nreturn num;\r\n}\r\n}\r\nif (apb_address != 0)\r\nreturn dib8096p_rw_on_apb(i2c_adap, msg, num, apb_address);\r\nelse\r\nreturn dib8096p_tuner_rw_serpar(i2c_adap, msg, num);\r\nreturn 0;\r\n}\r\nstatic u32 dib8096p_i2c_func(struct i2c_adapter *adapter)\r\n{\r\nreturn I2C_FUNC_I2C;\r\n}\r\nstatic struct i2c_adapter *dib8096p_get_i2c_tuner(struct dvb_frontend *fe)\r\n{\r\nstruct dib8000_state *st = fe->demodulator_priv;\r\nreturn &st->dib8096p_tuner_adap;\r\n}\r\nstatic int dib8096p_tuner_sleep(struct dvb_frontend *fe, int onoff)\r\n{\r\nstruct dib8000_state *state = fe->demodulator_priv;\r\nu16 en_cur_state;\r\ndprintk("sleep dib8096p: %d", onoff);\r\nen_cur_state = dib8000_read_word(state, 1922);\r\nif (en_cur_state > 0xff)\r\nstate->tuner_enable = en_cur_state ;\r\nif (onoff)\r\nen_cur_state &= 0x00ff;\r\nelse {\r\nif (state->tuner_enable != 0)\r\nen_cur_state = state->tuner_enable;\r\n}\r\ndib8000_write_word(state, 1922, en_cur_state);\r\nreturn 0;\r\n}\r\nstatic s32 dib8000_get_adc_power(struct dvb_frontend *fe, u8 mode)\r\n{\r\nstruct dib8000_state *state = fe->demodulator_priv;\r\nu32 ix = 0, tmp_val = 0, exp = 0, mant = 0;\r\ns32 val;\r\nval = dib8000_read32(state, 384);\r\nif (mode) {\r\ntmp_val = val;\r\nwhile (tmp_val >>= 1)\r\nexp++;\r\nmant = (val * 1000 / (1<<exp));\r\nix = (u8)((mant-1000)/100);\r\nval = (lut_1000ln_mant[ix] + 693*(exp-20) - 6908);\r\nval = (val*256)/1000;\r\n}\r\nreturn val;\r\n}\r\nstatic int dib8090p_get_dc_power(struct dvb_frontend *fe, u8 IQ)\r\n{\r\nstruct dib8000_state *state = fe->demodulator_priv;\r\nint val = 0;\r\nswitch (IQ) {\r\ncase 1:\r\nval = dib8000_read_word(state, 403);\r\nbreak;\r\ncase 0:\r\nval = dib8000_read_word(state, 404);\r\nbreak;\r\n}\r\nif (val & 0x200)\r\nval -= 1024;\r\nreturn val;\r\n}\r\nstatic void dib8000_update_timf(struct dib8000_state *state)\r\n{\r\nu32 timf = state->timf = dib8000_read32(state, 435);\r\ndib8000_write_word(state, 29, (u16) (timf >> 16));\r\ndib8000_write_word(state, 30, (u16) (timf & 0xffff));\r\ndprintk("Updated timing frequency: %d (default: %d)", state->timf, state->timf_default);\r\n}\r\nstatic u32 dib8000_ctrl_timf(struct dvb_frontend *fe, uint8_t op, uint32_t timf)\r\n{\r\nstruct dib8000_state *state = fe->demodulator_priv;\r\nswitch (op) {\r\ncase DEMOD_TIMF_SET:\r\nstate->timf = timf;\r\nbreak;\r\ncase DEMOD_TIMF_UPDATE:\r\ndib8000_update_timf(state);\r\nbreak;\r\ncase DEMOD_TIMF_GET:\r\nbreak;\r\n}\r\ndib8000_set_bandwidth(state->fe[0], 6000);\r\nreturn state->timf;\r\n}\r\nstatic u16 dib8000_set_layer(struct dib8000_state *state, u8 layer_index, u16 max_constellation)\r\n{\r\nu8 cr, constellation, time_intlv;\r\nstruct dtv_frontend_properties *c = &state->fe[0]->dtv_property_cache;\r\nswitch (c->layer[layer_index].modulation) {\r\ncase DQPSK:\r\nconstellation = 0;\r\nbreak;\r\ncase QPSK:\r\nconstellation = 1;\r\nbreak;\r\ncase QAM_16:\r\nconstellation = 2;\r\nbreak;\r\ncase QAM_64:\r\ndefault:\r\nconstellation = 3;\r\nbreak;\r\n}\r\nswitch (c->layer[layer_index].fec) {\r\ncase FEC_1_2:\r\ncr = 1;\r\nbreak;\r\ncase FEC_2_3:\r\ncr = 2;\r\nbreak;\r\ncase FEC_3_4:\r\ncr = 3;\r\nbreak;\r\ncase FEC_5_6:\r\ncr = 5;\r\nbreak;\r\ncase FEC_7_8:\r\ndefault:\r\ncr = 7;\r\nbreak;\r\n}\r\ntime_intlv = fls(c->layer[layer_index].interleaving);\r\nif (time_intlv > 3 && !(time_intlv == 4 && c->isdbt_sb_mode == 1))\r\ntime_intlv = 0;\r\ndib8000_write_word(state, 2 + layer_index, (constellation << 10) | ((c->layer[layer_index].segment_count & 0xf) << 6) | (cr << 3) | time_intlv);\r\nif (c->layer[layer_index].segment_count > 0) {\r\nswitch (max_constellation) {\r\ncase DQPSK:\r\ncase QPSK:\r\nif (c->layer[layer_index].modulation == QAM_16 || c->layer[layer_index].modulation == QAM_64)\r\nmax_constellation = c->layer[layer_index].modulation;\r\nbreak;\r\ncase QAM_16:\r\nif (c->layer[layer_index].modulation == QAM_64)\r\nmax_constellation = c->layer[layer_index].modulation;\r\nbreak;\r\n}\r\n}\r\nreturn max_constellation;\r\n}\r\nstatic u16 dib8000_adp_fine_tune(struct dib8000_state *state, u16 max_constellation)\r\n{\r\nu16 i, ana_gain = 0;\r\nconst u16 *adp;\r\nswitch (max_constellation) {\r\ncase QAM_64:\r\nana_gain = 0x7;\r\nadp = &adp_Q64[0];\r\nbreak;\r\ncase QAM_16:\r\nana_gain = 0x7;\r\nadp = &adp_Q16[0];\r\nbreak;\r\ndefault:\r\nana_gain = 0;\r\nadp = &adp_Qdefault[0];\r\nbreak;\r\n}\r\nfor (i = 0; i < 4; i++)\r\ndib8000_write_word(state, 215 + i, adp[i]);\r\nreturn ana_gain;\r\n}\r\nstatic void dib8000_update_ana_gain(struct dib8000_state *state, u16 ana_gain)\r\n{\r\nu16 i;\r\ndib8000_write_word(state, 116, ana_gain);\r\nif (ana_gain) {\r\nfor (i = 0; i < 10; i++)\r\ndib8000_write_word(state, 80 + i, adc_target_16dB[i]);\r\n} else {\r\nfor (i = 0; i < 10; i++)\r\ndib8000_write_word(state, 80 + i, adc_target_16dB[i] - 355);\r\n}\r\n}\r\nstatic void dib8000_load_ana_fe_coefs(struct dib8000_state *state, const s16 *ana_fe)\r\n{\r\nu16 mode = 0;\r\nif (state->isdbt_cfg_loaded == 0)\r\nfor (mode = 0; mode < 24; mode++)\r\ndib8000_write_word(state, 117 + mode, ana_fe[mode]);\r\n}\r\nstatic u16 dib8000_get_init_prbs(struct dib8000_state *state, u16 subchannel)\r\n{\r\nint sub_channel_prbs_group = 0;\r\nsub_channel_prbs_group = (subchannel / 3) + 1;\r\ndprintk("sub_channel_prbs_group = %d , subchannel =%d prbs = 0x%04x", sub_channel_prbs_group, subchannel, lut_prbs_8k[sub_channel_prbs_group]);\r\nswitch (state->fe[0]->dtv_property_cache.transmission_mode) {\r\ncase TRANSMISSION_MODE_2K:\r\nreturn lut_prbs_2k[sub_channel_prbs_group];\r\ncase TRANSMISSION_MODE_4K:\r\nreturn lut_prbs_4k[sub_channel_prbs_group];\r\ndefault:\r\ncase TRANSMISSION_MODE_8K:\r\nreturn lut_prbs_8k[sub_channel_prbs_group];\r\n}\r\n}\r\nstatic void dib8000_set_13seg_channel(struct dib8000_state *state)\r\n{\r\nu16 i;\r\nu16 coff_pow = 0x2800;\r\nstate->seg_mask = 0x1fff;\r\nif (state->isdbt_cfg_loaded == 0) {\r\ndib8000_write_word(state, 180, (16 << 6) | 9);\r\ndib8000_write_word(state, 187, (4 << 12) | (8 << 5) | 0x2);\r\ncoff_pow = 0x2800;\r\nfor (i = 0; i < 6; i++)\r\ndib8000_write_word(state, 181+i, coff_pow);\r\ndib8000_write_word(state, 338, (1 << 12) | (1 << 10) | (0 << 9) | (3 << 5) | 1);\r\ndib8000_write_word(state, 340, (8 << 6) | (6 << 0));\r\ndib8000_write_word(state, 341, (4 << 3) | (1 << 2) | (1 << 1) | (1 << 0));\r\ndib8000_write_word(state, 228, 0);\r\ndib8000_write_word(state, 265, 31);\r\ndib8000_write_word(state, 205, 0x200f);\r\n}\r\nif (state->cfg.pll->ifreq == 0)\r\ndib8000_write_word(state, 266, ~state->seg_mask | state->seg_diff_mask | 0x40);\r\ndib8000_load_ana_fe_coefs(state, ana_fe_coeff_13seg);\r\n}\r\nstatic void dib8000_set_subchannel_prbs(struct dib8000_state *state, u16 init_prbs)\r\n{\r\nu16 reg_1;\r\nreg_1 = dib8000_read_word(state, 1);\r\ndib8000_write_word(state, 1, (init_prbs << 2) | (reg_1 & 0x3));\r\n}\r\nstatic void dib8000_small_fine_tune(struct dib8000_state *state)\r\n{\r\nu16 i;\r\nconst s16 *ncoeff;\r\nstruct dtv_frontend_properties *c = &state->fe[0]->dtv_property_cache;\r\ndib8000_write_word(state, 352, state->seg_diff_mask);\r\ndib8000_write_word(state, 353, state->seg_mask);\r\ndib8000_write_word(state, 351, (c->isdbt_sb_mode << 9) | (c->isdbt_sb_mode << 8) | (13 << 4) | 5);\r\nif (c->isdbt_sb_mode) {\r\nswitch (c->transmission_mode) {\r\ncase TRANSMISSION_MODE_2K:\r\nif (c->isdbt_partial_reception == 0) {\r\nif (c->layer[0].modulation == DQPSK)\r\nncoeff = coeff_2k_sb_1seg_dqpsk;\r\nelse\r\nncoeff = coeff_2k_sb_1seg;\r\n} else {\r\nif (c->layer[0].modulation == DQPSK) {\r\nif (c->layer[1].modulation == DQPSK)\r\nncoeff = coeff_2k_sb_3seg_0dqpsk_1dqpsk;\r\nelse\r\nncoeff = coeff_2k_sb_3seg_0dqpsk;\r\n} else {\r\nif (c->layer[1].modulation == DQPSK)\r\nncoeff = coeff_2k_sb_3seg_1dqpsk;\r\nelse\r\nncoeff = coeff_2k_sb_3seg;\r\n}\r\n}\r\nbreak;\r\ncase TRANSMISSION_MODE_4K:\r\nif (c->isdbt_partial_reception == 0) {\r\nif (c->layer[0].modulation == DQPSK)\r\nncoeff = coeff_4k_sb_1seg_dqpsk;\r\nelse\r\nncoeff = coeff_4k_sb_1seg;\r\n} else {\r\nif (c->layer[0].modulation == DQPSK) {\r\nif (c->layer[1].modulation == DQPSK)\r\nncoeff = coeff_4k_sb_3seg_0dqpsk_1dqpsk;\r\nelse\r\nncoeff = coeff_4k_sb_3seg_0dqpsk;\r\n} else {\r\nif (c->layer[1].modulation == DQPSK)\r\nncoeff = coeff_4k_sb_3seg_1dqpsk;\r\nelse\r\nncoeff = coeff_4k_sb_3seg;\r\n}\r\n}\r\nbreak;\r\ncase TRANSMISSION_MODE_AUTO:\r\ncase TRANSMISSION_MODE_8K:\r\ndefault:\r\nif (c->isdbt_partial_reception == 0) {\r\nif (c->layer[0].modulation == DQPSK)\r\nncoeff = coeff_8k_sb_1seg_dqpsk;\r\nelse\r\nncoeff = coeff_8k_sb_1seg;\r\n} else {\r\nif (c->layer[0].modulation == DQPSK) {\r\nif (c->layer[1].modulation == DQPSK)\r\nncoeff = coeff_8k_sb_3seg_0dqpsk_1dqpsk;\r\nelse\r\nncoeff = coeff_8k_sb_3seg_0dqpsk;\r\n} else {\r\nif (c->layer[1].modulation == DQPSK)\r\nncoeff = coeff_8k_sb_3seg_1dqpsk;\r\nelse\r\nncoeff = coeff_8k_sb_3seg;\r\n}\r\n}\r\nbreak;\r\n}\r\nfor (i = 0; i < 8; i++)\r\ndib8000_write_word(state, 343 + i, ncoeff[i]);\r\n}\r\n}\r\nstatic void dib8000_set_sb_channel(struct dib8000_state *state)\r\n{\r\nstruct dtv_frontend_properties *c = &state->fe[0]->dtv_property_cache;\r\nconst u16 *coff;\r\nu16 i;\r\nif (c->transmission_mode == TRANSMISSION_MODE_2K || c->transmission_mode == TRANSMISSION_MODE_4K) {\r\ndib8000_write_word(state, 219, dib8000_read_word(state, 219) | 0x1);\r\ndib8000_write_word(state, 190, dib8000_read_word(state, 190) | (0x1 << 14));\r\n} else {\r\ndib8000_write_word(state, 219, dib8000_read_word(state, 219) & 0xfffe);\r\ndib8000_write_word(state, 190, dib8000_read_word(state, 190) & 0xbfff);\r\n}\r\nif (c->isdbt_partial_reception == 1)\r\nstate->seg_mask = 0x00E0;\r\nelse\r\nstate->seg_mask = 0x0040;\r\ndib8000_write_word(state, 268, (dib8000_read_word(state, 268) & 0xF9FF) | 0x0200);\r\ndib8000_write_word(state, 187, (4 << 12) | (0 << 11) | (63 << 5) | (0x3 << 3) | ((~c->isdbt_partial_reception & 1) << 2) | 0x3);\r\ndib8000_write_word(state, 340, (16 << 6) | (8 << 0));\r\ndib8000_write_word(state, 341, (6 << 3) | (1 << 2) | (1 << 1) | (1 << 0));\r\nif (c->isdbt_partial_reception == 0) {\r\nif (state->mode == 3)\r\ndib8000_write_word(state, 180, 0x1fcf | ((state->mode - 1) << 14));\r\nelse\r\ndib8000_write_word(state, 180, 0x0fcf | ((state->mode - 1) << 14));\r\ndib8000_write_word(state, 338, (1 << 12) | (1 << 10) | (0 << 9) | (5 << 5) | 4);\r\ncoff = &coff_thres_1seg[0];\r\n} else {\r\ndib8000_write_word(state, 180, 0x1fcf | (1 << 14));\r\ndib8000_write_word(state, 338, (1 << 12) | (1 << 10) | (0 << 9) | (4 << 5) | 4);\r\ncoff = &coff_thres_3seg[0];\r\n}\r\ndib8000_write_word(state, 228, 1);\r\ndib8000_write_word(state, 205, dib8000_read_word(state, 205) & 0xfff0);\r\nif (c->isdbt_partial_reception == 0 && c->transmission_mode == TRANSMISSION_MODE_2K)\r\ndib8000_write_word(state, 265, 15);\r\nfor (i = 0 ; i < 3; i++) {\r\ndib8000_write_word(state, 181+i, coff[i]);\r\ndib8000_write_word(state, 184+i, coff[i]);\r\n}\r\ndib8000_write_word(state, 266, ~state->seg_mask | state->seg_diff_mask);\r\nif (c->isdbt_partial_reception == 0)\r\ndib8000_write_word(state, 178, 64);\r\nelse\r\ndib8000_write_word(state, 178, 32);\r\n}\r\nstatic void dib8000_set_isdbt_common_channel(struct dib8000_state *state, u8 seq, u8 autosearching)\r\n{\r\nu16 p_cfr_left_edge = 0, p_cfr_right_edge = 0;\r\nu16 tmcc_pow = 0, ana_gain = 0, tmp = 0, i = 0, nbseg_diff = 0 ;\r\nu16 max_constellation = DQPSK;\r\nint init_prbs;\r\nstruct dtv_frontend_properties *c = &state->fe[0]->dtv_property_cache;\r\nif (autosearching)\r\nc->isdbt_partial_reception = 1;\r\ndib8000_write_word(state, 10, (seq << 4));\r\nstate->mode = fft_to_mode(state);\r\ntmp = dib8000_read_word(state, 1);\r\ndib8000_write_word(state, 1, (tmp&0xfffc) | (c->guard_interval & 0x3));\r\ndib8000_write_word(state, 274, (dib8000_read_word(state, 274) & 0xffcf) | ((c->isdbt_partial_reception & 1) << 5) | ((c->isdbt_sb_mode & 1) << 4));\r\nif (c->isdbt_partial_reception) {\r\nstate->seg_diff_mask = (c->layer[0].modulation == DQPSK) << permu_seg[0];\r\nfor (i = 1; i < 3; i++)\r\nnbseg_diff += (c->layer[i].modulation == DQPSK) * c->layer[i].segment_count;\r\nfor (i = 0; i < nbseg_diff; i++)\r\nstate->seg_diff_mask |= 1 << permu_seg[i+1];\r\n} else {\r\nfor (i = 0; i < 3; i++)\r\nnbseg_diff += (c->layer[i].modulation == DQPSK) * c->layer[i].segment_count;\r\nfor (i = 0; i < nbseg_diff; i++)\r\nstate->seg_diff_mask |= 1 << permu_seg[i];\r\n}\r\nif (state->seg_diff_mask)\r\ndib8000_write_word(state, 268, (dib8000_read_word(state, 268) & 0xF9FF) | 0x0200);\r\nelse\r\ndib8000_write_word(state, 268, (2 << 9) | 39);\r\nfor (i = 0; i < 3; i++)\r\nmax_constellation = dib8000_set_layer(state, i, max_constellation);\r\nif (autosearching == 0) {\r\nstate->layer_b_nb_seg = c->layer[1].segment_count;\r\nstate->layer_c_nb_seg = c->layer[2].segment_count;\r\n}\r\ndib8000_write_word(state, 0, (state->mode << 13) | state->seg_diff_mask);\r\nstate->differential_constellation = (state->seg_diff_mask != 0);\r\nana_gain = dib8000_adp_fine_tune(state, max_constellation);\r\ndib8000_update_ana_gain(state, ana_gain);\r\nif (c->isdbt_partial_reception)\r\ndib8000_load_ana_fe_coefs(state, ana_fe_coeff_3seg);\r\nelse\r\ndib8000_load_ana_fe_coefs(state, ana_fe_coeff_1seg);\r\nif (c->isdbt_sb_mode) {\r\ndib8000_set_sb_channel(state);\r\nif (c->isdbt_sb_subchannel < 14)\r\ninit_prbs = dib8000_get_init_prbs(state, c->isdbt_sb_subchannel);\r\nelse\r\ninit_prbs = 0;\r\n} else {\r\ndib8000_set_13seg_channel(state);\r\ninit_prbs = 0xfff;\r\n}\r\ndib8000_small_fine_tune(state);\r\ndib8000_set_subchannel_prbs(state, init_prbs);\r\nfor (i = 0; i < 13; i++) {\r\nif ((((~state->seg_diff_mask) >> i) & 1) == 1) {\r\np_cfr_left_edge += (1 << i) * ((i == 0) || ((((state->seg_mask & (~state->seg_diff_mask)) >> (i - 1)) & 1) == 0));\r\np_cfr_right_edge += (1 << i) * ((i == 12) || ((((state->seg_mask & (~state->seg_diff_mask)) >> (i + 1)) & 1) == 0));\r\n}\r\n}\r\ndib8000_write_word(state, 222, p_cfr_left_edge);\r\ndib8000_write_word(state, 223, p_cfr_right_edge);\r\ndib8000_write_word(state, 189, ~state->seg_mask | state->seg_diff_mask);\r\ndib8000_write_word(state, 192, ~state->seg_mask | state->seg_diff_mask);\r\ndib8000_write_word(state, 225, ~state->seg_mask | state->seg_diff_mask);\r\nif (!autosearching)\r\ndib8000_write_word(state, 288, (~state->seg_mask | state->seg_diff_mask) & 0x1fff);\r\nelse\r\ndib8000_write_word(state, 288, 0x1fff);\r\ndib8000_write_word(state, 211, state->seg_mask & (~state->seg_diff_mask));\r\ndib8000_write_word(state, 287, ~state->seg_mask | 0x1000);\r\ndib8000_write_word(state, 178, 32);\r\nfor (i = 0; i < 3; i++)\r\ntmcc_pow += (((c->layer[i].modulation == DQPSK) * 4 + 1) * c->layer[i].segment_count) ;\r\ntmcc_pow *= (1 << (9-2));\r\ndib8000_write_word(state, 290, tmcc_pow);\r\ndib8000_write_word(state, 291, tmcc_pow);\r\ndib8000_write_word(state, 292, tmcc_pow);\r\nif (state->isdbt_cfg_loaded == 0)\r\ndib8000_write_word(state, 250, 3285);\r\nstate->isdbt_cfg_loaded = 0;\r\n}\r\nstatic u32 dib8000_wait_lock(struct dib8000_state *state, u32 internal,\r\nu32 wait0_ms, u32 wait1_ms, u32 wait2_ms)\r\n{\r\nu32 value = 0;\r\nu16 reg = 11;\r\nfor (reg = 11; reg < 16; reg += 2) {\r\nif (reg == 11) {\r\nif (state->revision == 0x8090)\r\nvalue = internal * wait1_ms;\r\nelse\r\nvalue = internal * wait0_ms;\r\n} else if (reg == 13)\r\nvalue = internal * wait1_ms;\r\nelse if (reg == 15)\r\nvalue = internal * wait2_ms;\r\ndib8000_write_word(state, reg, (u16)((value >> 16) & 0xffff));\r\ndib8000_write_word(state, (reg + 1), (u16)(value & 0xffff));\r\n}\r\nreturn value;\r\n}\r\nstatic int dib8000_autosearch_start(struct dvb_frontend *fe)\r\n{\r\nstruct dib8000_state *state = fe->demodulator_priv;\r\nstruct dtv_frontend_properties *c = &state->fe[0]->dtv_property_cache;\r\nu8 slist = 0;\r\nu32 value, internal = state->cfg.pll->internal;\r\nif (state->revision == 0x8090)\r\ninternal = dib8000_read32(state, 23) / 1000;\r\nif ((state->revision >= 0x8002) &&\r\n(state->autosearch_state == AS_SEARCHING_FFT)) {\r\ndib8000_write_word(state, 37, 0x0065);\r\ndib8000_write_word(state, 116, 0x0000);\r\ndib8000_write_word(state, 0, (dib8000_read_word(state, 0) & 0x1fff) | (0 << 13) | (1 << 15));\r\ndib8000_write_word(state, 1, (dib8000_read_word(state, 1) & 0xfffc) | 0);\r\ndib8000_write_word(state, 6, 0);\r\ndib8000_write_word(state, 7, 0);\r\ndib8000_write_word(state, 8, 0);\r\ndib8000_write_word(state, 10, (dib8000_read_word(state, 10) & 0x200) | (16 << 4) | (0 << 0));\r\nif (state->revision == 0x8090)\r\nvalue = dib8000_wait_lock(state, internal, 10, 10, 10);\r\nelse\r\nvalue = dib8000_wait_lock(state, internal, 20, 20, 20);\r\ndib8000_write_word(state, 17, 0);\r\ndib8000_write_word(state, 18, 200);\r\ndib8000_write_word(state, 19, 0);\r\ndib8000_write_word(state, 20, 400);\r\ndib8000_write_word(state, 21, (value >> 16) & 0xffff);\r\ndib8000_write_word(state, 22, value & 0xffff);\r\nif (state->revision == 0x8090)\r\ndib8000_write_word(state, 32, (dib8000_read_word(state, 32) & 0xf0ff) | (0 << 8));\r\nelse\r\ndib8000_write_word(state, 32, (dib8000_read_word(state, 32) & 0xf0ff) | (9 << 8));\r\ndib8000_write_word(state, 355, 2);\r\ndib8000_write_word(state, 356, 0);\r\ndib8000_write_word(state, 357, 0x111);\r\ndib8000_write_word(state, 770, (dib8000_read_word(state, 770) & 0xdfff) | (1 << 13));\r\ndib8000_write_word(state, 770, (dib8000_read_word(state, 770) & 0xdfff) | (0 << 13));\r\ndib8000_write_word(state, 0, (dib8000_read_word(state, 0) & 0x7ff) | (0 << 15) | (1 << 13));\r\n} else if ((state->revision >= 0x8002) &&\r\n(state->autosearch_state == AS_SEARCHING_GUARD)) {\r\nc->transmission_mode = TRANSMISSION_MODE_8K;\r\nc->guard_interval = GUARD_INTERVAL_1_8;\r\nc->inversion = 0;\r\nc->layer[0].modulation = QAM_64;\r\nc->layer[0].fec = FEC_2_3;\r\nc->layer[0].interleaving = 0;\r\nc->layer[0].segment_count = 13;\r\nslist = 16;\r\nc->transmission_mode = state->found_nfft;\r\ndib8000_set_isdbt_common_channel(state, slist, 1);\r\ndib8000_write_word(state, 6, 0x4);\r\nif (state->revision == 0x8090)\r\ndib8000_write_word(state, 7, ((1 << 12) | (1 << 11) | (1 << 10)));\r\nelse\r\ndib8000_write_word(state, 7, 0x8);\r\ndib8000_write_word(state, 8, 0x1000);\r\nif (state->revision == 0x8090)\r\ndib8000_wait_lock(state, internal, 50, 100, 1000);\r\nelse\r\ndib8000_wait_lock(state, internal, 50, 200, 1000);\r\ndib8000_write_word(state, 355, 3);\r\ndib8000_write_word(state, 356, 0);\r\ndib8000_write_word(state, 357, 0xf);\r\nvalue = dib8000_read_word(state, 0);\r\ndib8000_write_word(state, 0, (u16)((1 << 15) | value));\r\ndib8000_read_word(state, 1284);\r\ndib8000_write_word(state, 0, (u16)value);\r\n} else {\r\nc->inversion = 0;\r\nc->layer[0].modulation = QAM_64;\r\nc->layer[0].fec = FEC_2_3;\r\nc->layer[0].interleaving = 0;\r\nc->layer[0].segment_count = 13;\r\nif (!c->isdbt_sb_mode)\r\nc->layer[0].segment_count = 13;\r\nif (c->isdbt_sb_mode) {\r\nslist = 7;\r\ndib8000_write_word(state, 0, (dib8000_read_word(state, 0) & 0x9fff) | (1 << 13));\r\n} else {\r\nif (c->guard_interval == GUARD_INTERVAL_AUTO) {\r\nif (c->transmission_mode == TRANSMISSION_MODE_AUTO) {\r\nc->transmission_mode = TRANSMISSION_MODE_8K;\r\nc->guard_interval = GUARD_INTERVAL_1_8;\r\nslist = 7;\r\ndib8000_write_word(state, 0, (dib8000_read_word(state, 0) & 0x9fff) | (1 << 13));\r\n} else {\r\nc->guard_interval = GUARD_INTERVAL_1_8;\r\nslist = 3;\r\n}\r\n} else {\r\nif (c->transmission_mode == TRANSMISSION_MODE_AUTO) {\r\nc->transmission_mode = TRANSMISSION_MODE_8K;\r\nslist = 2;\r\ndib8000_write_word(state, 0, (dib8000_read_word(state, 0) & 0x9fff) | (1 << 13));\r\n} else\r\nslist = 0;\r\n}\r\n}\r\ndprintk("Using list for autosearch : %d", slist);\r\ndib8000_set_isdbt_common_channel(state, slist, 1);\r\ndib8000_write_word(state, 6, 0x4);\r\nif (state->revision == 0x8090)\r\ndib8000_write_word(state, 7, (1 << 12) | (1 << 11) | (1 << 10));\r\nelse\r\ndib8000_write_word(state, 7, 0x8);\r\ndib8000_write_word(state, 8, 0x1000);\r\nif (state->revision == 0x8090)\r\ndib8000_wait_lock(state, internal, 50, 200, 1000);\r\nelse\r\ndib8000_wait_lock(state, internal, 50, 100, 1000);\r\nvalue = dib8000_read_word(state, 0);\r\ndib8000_write_word(state, 0, (u16)((1 << 15) | value));\r\ndib8000_read_word(state, 1284);\r\ndib8000_write_word(state, 0, (u16)value);\r\n}\r\nreturn 0;\r\n}\r\nstatic int dib8000_autosearch_irq(struct dvb_frontend *fe)\r\n{\r\nstruct dib8000_state *state = fe->demodulator_priv;\r\nu16 irq_pending = dib8000_read_word(state, 1284);\r\nif ((state->revision >= 0x8002) &&\r\n(state->autosearch_state == AS_SEARCHING_FFT)) {\r\nif (irq_pending & 0x1) {\r\ndprintk("dib8000_autosearch_irq: max correlation result available");\r\nreturn 3;\r\n}\r\n} else {\r\nif (irq_pending & 0x1) {\r\ndprintk("dib8000_autosearch_irq failed");\r\nreturn 1;\r\n}\r\nif (irq_pending & 0x2) {\r\ndprintk("dib8000_autosearch_irq succeeded");\r\nreturn 2;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic void dib8000_viterbi_state(struct dib8000_state *state, u8 onoff)\r\n{\r\nu16 tmp;\r\ntmp = dib8000_read_word(state, 771);\r\nif (onoff)\r\ndib8000_write_word(state, 771, tmp & 0xfffd);\r\nelse\r\ndib8000_write_word(state, 771, tmp | (1<<1));\r\n}\r\nstatic void dib8000_set_dds(struct dib8000_state *state, s32 offset_khz)\r\n{\r\ns16 unit_khz_dds_val;\r\nu32 abs_offset_khz = ABS(offset_khz);\r\nu32 dds = state->cfg.pll->ifreq & 0x1ffffff;\r\nu8 invert = !!(state->cfg.pll->ifreq & (1 << 25));\r\nu8 ratio;\r\nif (state->revision == 0x8090) {\r\nratio = 4;\r\nunit_khz_dds_val = (1<<26) / (dib8000_read32(state, 23) / 1000);\r\nif (offset_khz < 0)\r\ndds = (1 << 26) - (abs_offset_khz * unit_khz_dds_val);\r\nelse\r\ndds = (abs_offset_khz * unit_khz_dds_val);\r\nif (invert)\r\ndds = (1<<26) - dds;\r\n} else {\r\nratio = 2;\r\nunit_khz_dds_val = (u16) (67108864 / state->cfg.pll->internal);\r\nif (offset_khz < 0)\r\nunit_khz_dds_val *= -1;\r\nif (invert)\r\ndds -= abs_offset_khz * unit_khz_dds_val;\r\nelse\r\ndds += abs_offset_khz * unit_khz_dds_val;\r\n}\r\ndprintk("setting a DDS frequency offset of %c%dkHz", invert ? '-' : ' ', dds / unit_khz_dds_val);\r\nif (abs_offset_khz <= (state->cfg.pll->internal / ratio)) {\r\ndib8000_write_word(state, 26, invert);\r\ndib8000_write_word(state, 27, (u16)(dds >> 16) & 0x1ff);\r\ndib8000_write_word(state, 28, (u16)(dds & 0xffff));\r\n}\r\n}\r\nstatic void dib8000_set_frequency_offset(struct dib8000_state *state)\r\n{\r\nstruct dtv_frontend_properties *c = &state->fe[0]->dtv_property_cache;\r\nint i;\r\nu32 current_rf;\r\nint total_dds_offset_khz;\r\nif (state->fe[0]->ops.tuner_ops.get_frequency)\r\nstate->fe[0]->ops.tuner_ops.get_frequency(state->fe[0], &current_rf);\r\nelse\r\ncurrent_rf = c->frequency;\r\ncurrent_rf /= 1000;\r\ntotal_dds_offset_khz = (int)current_rf - (int)c->frequency / 1000;\r\nif (c->isdbt_sb_mode) {\r\nstate->subchannel = c->isdbt_sb_subchannel;\r\ni = dib8000_read_word(state, 26) & 1;\r\ndib8000_write_word(state, 26, c->inversion ^ i);\r\nif (state->cfg.pll->ifreq == 0) {\r\nif ((c->inversion ^ i) == 0)\r\ndib8000_write_word(state, 26, dib8000_read_word(state, 26) | 1);\r\n} else {\r\nif ((c->inversion ^ i) == 0)\r\ntotal_dds_offset_khz *= -1;\r\n}\r\n}\r\ndprintk("%dkhz tuner offset (frequency = %dHz & current_rf = %dHz) total_dds_offset_hz = %d", c->frequency - current_rf, c->frequency, current_rf, total_dds_offset_khz);\r\ndib8000_set_dds(state, total_dds_offset_khz);\r\n}\r\nstatic u32 dib8000_get_symbol_duration(struct dib8000_state *state)\r\n{\r\nstruct dtv_frontend_properties *c = &state->fe[0]->dtv_property_cache;\r\nu16 i;\r\nswitch (c->transmission_mode) {\r\ncase TRANSMISSION_MODE_2K:\r\ni = 0;\r\nbreak;\r\ncase TRANSMISSION_MODE_4K:\r\ni = 2;\r\nbreak;\r\ndefault:\r\ncase TRANSMISSION_MODE_AUTO:\r\ncase TRANSMISSION_MODE_8K:\r\ni = 1;\r\nbreak;\r\n}\r\nreturn (LUT_isdbt_symbol_duration[i] / (c->bandwidth_hz / 1000)) + 1;\r\n}\r\nstatic void dib8000_set_isdbt_loop_params(struct dib8000_state *state, enum param_loop_step loop_step)\r\n{\r\nstruct dtv_frontend_properties *c = &state->fe[0]->dtv_property_cache;\r\nu16 reg_32 = 0, reg_37 = 0;\r\nswitch (loop_step) {\r\ncase LOOP_TUNE_1:\r\nif (c->isdbt_sb_mode) {\r\nif (c->isdbt_partial_reception == 0) {\r\nreg_32 = ((11 - state->mode) << 12) | (6 << 8) | 0x40;\r\nreg_37 = (3 << 5) | (0 << 4) | (10 - state->mode);\r\n} else {\r\nreg_32 = ((10 - state->mode) << 12) | (6 << 8) | 0x60;\r\nreg_37 = (3 << 5) | (0 << 4) | (9 - state->mode);\r\n}\r\n} else {\r\nreg_32 = ((9 - state->mode) << 12) | (6 << 8) | 0x80;\r\nreg_37 = (3 << 5) | (0 << 4) | (8 - state->mode);\r\n}\r\nbreak;\r\ncase LOOP_TUNE_2:\r\nif (c->isdbt_sb_mode) {\r\nif (c->isdbt_partial_reception == 0) {\r\nreg_32 = ((13-state->mode) << 12) | (6 << 8) | 0x40;\r\nreg_37 = (12-state->mode) | ((5 + state->mode) << 5);\r\n} else {\r\nreg_32 = ((12-state->mode) << 12) | (6 << 8) | 0x60;\r\nreg_37 = (11-state->mode) | ((5 + state->mode) << 5);\r\n}\r\n} else {\r\nreg_32 = ((11-state->mode) << 12) | (6 << 8) | 0x80;\r\nreg_37 = ((5+state->mode) << 5) | (10 - state->mode);\r\n}\r\nbreak;\r\n}\r\ndib8000_write_word(state, 32, reg_32);\r\ndib8000_write_word(state, 37, reg_37);\r\n}\r\nstatic void dib8000_demod_restart(struct dib8000_state *state)\r\n{\r\ndib8000_write_word(state, 770, 0x4000);\r\ndib8000_write_word(state, 770, 0x0000);\r\nreturn;\r\n}\r\nstatic void dib8000_set_sync_wait(struct dib8000_state *state)\r\n{\r\nstruct dtv_frontend_properties *c = &state->fe[0]->dtv_property_cache;\r\nu16 sync_wait = 64;\r\nswitch (c->transmission_mode) {\r\ncase TRANSMISSION_MODE_8K:\r\nsync_wait = 256;\r\nbreak;\r\ncase TRANSMISSION_MODE_4K:\r\nsync_wait = 128;\r\nbreak;\r\ndefault:\r\ncase TRANSMISSION_MODE_2K:\r\nsync_wait = 64;\r\nbreak;\r\n}\r\nif (state->cfg.diversity_delay == 0)\r\nsync_wait = (sync_wait * (1 << (c->guard_interval)) * 3) / 2 + 48;\r\nelse\r\nsync_wait = (sync_wait * (1 << (c->guard_interval)) * 3) / 2 + state->cfg.diversity_delay;\r\ndib8000_write_word(state, 273, (dib8000_read_word(state, 273) & 0x000f) | (sync_wait << 4));\r\n}\r\nstatic unsigned long dib8000_get_timeout(struct dib8000_state *state, u32 delay, enum timeout_mode mode)\r\n{\r\nif (mode == SYMBOL_DEPENDENT_ON)\r\ndelay *= state->symbol_duration;\r\nreturn jiffies + usecs_to_jiffies(delay * 100);\r\n}\r\nstatic s32 dib8000_get_status(struct dvb_frontend *fe)\r\n{\r\nstruct dib8000_state *state = fe->demodulator_priv;\r\nreturn state->status;\r\n}\r\nstatic enum frontend_tune_state dib8000_get_tune_state(struct dvb_frontend *fe)\r\n{\r\nstruct dib8000_state *state = fe->demodulator_priv;\r\nreturn state->tune_state;\r\n}\r\nstatic int dib8000_set_tune_state(struct dvb_frontend *fe, enum frontend_tune_state tune_state)\r\n{\r\nstruct dib8000_state *state = fe->demodulator_priv;\r\nstate->tune_state = tune_state;\r\nreturn 0;\r\n}\r\nstatic int dib8000_tune_restart_from_demod(struct dvb_frontend *fe)\r\n{\r\nstruct dib8000_state *state = fe->demodulator_priv;\r\nstate->status = FE_STATUS_TUNE_PENDING;\r\nstate->tune_state = CT_DEMOD_START;\r\nreturn 0;\r\n}\r\nstatic u16 dib8000_read_lock(struct dvb_frontend *fe)\r\n{\r\nstruct dib8000_state *state = fe->demodulator_priv;\r\nif (state->revision == 0x8090)\r\nreturn dib8000_read_word(state, 570);\r\nreturn dib8000_read_word(state, 568);\r\n}\r\nstatic int dib8090p_init_sdram(struct dib8000_state *state)\r\n{\r\nu16 reg = 0;\r\ndprintk("init sdram");\r\nreg = dib8000_read_word(state, 274) & 0xfff0;\r\ndib8000_write_word(state, 274, reg | 0x7);\r\ndib8000_write_word(state, 1803, (7 << 2));\r\nreg = dib8000_read_word(state, 1280);\r\ndib8000_write_word(state, 1280, reg | (1 << 2));\r\ndib8000_write_word(state, 1280, reg);\r\nreturn 0;\r\n}\r\nstatic int is_manual_mode(struct dtv_frontend_properties *c)\r\n{\r\nint i, n_segs = 0;\r\nif (c->delivery_system != SYS_ISDBT)\r\nreturn 0;\r\nif (c->transmission_mode == TRANSMISSION_MODE_AUTO) {\r\ndprintk("transmission mode auto");\r\nreturn 0;\r\n}\r\nif (c->guard_interval == GUARD_INTERVAL_AUTO) {\r\ndprintk("guard interval auto");\r\nreturn 0;\r\n}\r\nif (!c->isdbt_layer_enabled) {\r\ndprintk("no layer modulation specified");\r\nreturn 0;\r\n}\r\nfor (i = 0; i < 3; i++) {\r\nif (!(c->isdbt_layer_enabled & 1 << i))\r\ncontinue;\r\nif ((c->layer[i].segment_count > 13) ||\r\n(c->layer[i].segment_count == 0)) {\r\nc->isdbt_layer_enabled &= ~(1 << i);\r\ncontinue;\r\n}\r\nn_segs += c->layer[i].segment_count;\r\nif ((c->layer[i].modulation == QAM_AUTO) ||\r\n(c->layer[i].fec == FEC_AUTO)) {\r\ndprintk("layer %c has either modulation or FEC auto",\r\n'A' + i);\r\nreturn 0;\r\n}\r\n}\r\nif (n_segs == 0 || n_segs > 13) {\r\ndprintk("number of segments is invalid");\r\nreturn 0;\r\n}\r\nreturn 1;\r\n}\r\nstatic int dib8000_tune(struct dvb_frontend *fe)\r\n{\r\nstruct dib8000_state *state = fe->demodulator_priv;\r\nstruct dtv_frontend_properties *c = &state->fe[0]->dtv_property_cache;\r\nenum frontend_tune_state *tune_state = &state->tune_state;\r\nu16 locks, deeper_interleaver = 0, i;\r\nint ret = 1;\r\nunsigned long *timeout = &state->timeout;\r\nunsigned long now = jiffies;\r\n#ifdef DIB8000_AGC_FREEZE\r\nu16 agc1, agc2;\r\n#endif\r\nu32 corm[4] = {0, 0, 0, 0};\r\nu8 find_index, max_value;\r\n#if 0\r\nif (*tune_state < CT_DEMOD_STOP)\r\ndprintk("IN: context status = %d, TUNE_STATE %d autosearch step = %u jiffies = %lu",\r\nstate->channel_parameters_set, *tune_state, state->autosearch_state, now);\r\n#endif\r\nswitch (*tune_state) {\r\ncase CT_DEMOD_START:\r\ndib8000_reset_stats(fe);\r\nif (state->revision == 0x8090)\r\ndib8090p_init_sdram(state);\r\nstate->status = FE_STATUS_TUNE_PENDING;\r\nstate->channel_parameters_set = is_manual_mode(c);\r\ndprintk("Tuning channel on %s search mode",\r\nstate->channel_parameters_set ? "manual" : "auto");\r\ndib8000_viterbi_state(state, 0);\r\ndib8000_write_word(state, 285, dib8000_read_word(state, 285) & 0x60);\r\ndib8000_set_frequency_offset(state);\r\ndib8000_set_bandwidth(fe, c->bandwidth_hz / 1000);\r\nif (state->channel_parameters_set == 0) {\r\n#ifdef DIB8000_AGC_FREEZE\r\nif (state->revision != 0x8090) {\r\nstate->agc1_max = dib8000_read_word(state, 108);\r\nstate->agc1_min = dib8000_read_word(state, 109);\r\nstate->agc2_max = dib8000_read_word(state, 110);\r\nstate->agc2_min = dib8000_read_word(state, 111);\r\nagc1 = dib8000_read_word(state, 388);\r\nagc2 = dib8000_read_word(state, 389);\r\ndib8000_write_word(state, 108, agc1);\r\ndib8000_write_word(state, 109, agc1);\r\ndib8000_write_word(state, 110, agc2);\r\ndib8000_write_word(state, 111, agc2);\r\n}\r\n#endif\r\nstate->autosearch_state = AS_SEARCHING_FFT;\r\nstate->found_nfft = TRANSMISSION_MODE_AUTO;\r\nstate->found_guard = GUARD_INTERVAL_AUTO;\r\n*tune_state = CT_DEMOD_SEARCH_NEXT;\r\n} else {\r\nstate->autosearch_state = AS_DONE;\r\n*tune_state = CT_DEMOD_STEP_3;\r\n}\r\nstate->symbol_duration = dib8000_get_symbol_duration(state);\r\nbreak;\r\ncase CT_DEMOD_SEARCH_NEXT:\r\ndib8000_autosearch_start(fe);\r\nif (state->revision == 0x8090)\r\nret = 50;\r\nelse\r\nret = 15;\r\n*tune_state = CT_DEMOD_STEP_1;\r\nbreak;\r\ncase CT_DEMOD_STEP_1:\r\nswitch (dib8000_autosearch_irq(fe)) {\r\ncase 1:\r\nstate->status = FE_STATUS_TUNE_FAILED;\r\nstate->autosearch_state = AS_DONE;\r\n*tune_state = CT_DEMOD_STOP;\r\nbreak;\r\ncase 2:\r\nstate->status = FE_STATUS_FFT_SUCCESS;\r\n*tune_state = CT_DEMOD_STEP_3;\r\nif (state->autosearch_state == AS_SEARCHING_GUARD)\r\n*tune_state = CT_DEMOD_STEP_2;\r\nelse\r\nstate->autosearch_state = AS_DONE;\r\nbreak;\r\ncase 3:\r\n*tune_state = CT_DEMOD_STEP_2;\r\nbreak;\r\n}\r\nbreak;\r\ncase CT_DEMOD_STEP_2:\r\nswitch (state->autosearch_state) {\r\ncase AS_SEARCHING_FFT:\r\nif (state->revision == 0x8090) {\r\ncorm[2] = (dib8000_read_word(state, 596) << 16) | (dib8000_read_word(state, 597));\r\ncorm[1] = (dib8000_read_word(state, 598) << 16) | (dib8000_read_word(state, 599));\r\ncorm[0] = (dib8000_read_word(state, 600) << 16) | (dib8000_read_word(state, 601));\r\n} else {\r\ncorm[2] = (dib8000_read_word(state, 594) << 16) | (dib8000_read_word(state, 595));\r\ncorm[1] = (dib8000_read_word(state, 596) << 16) | (dib8000_read_word(state, 597));\r\ncorm[0] = (dib8000_read_word(state, 598) << 16) | (dib8000_read_word(state, 599));\r\n}\r\nmax_value = 0;\r\nfor (find_index = 1 ; find_index < 3 ; find_index++) {\r\nif (corm[max_value] < corm[find_index])\r\nmax_value = find_index ;\r\n}\r\nswitch (max_value) {\r\ncase 0:\r\nstate->found_nfft = TRANSMISSION_MODE_2K;\r\nbreak;\r\ncase 1:\r\nstate->found_nfft = TRANSMISSION_MODE_4K;\r\nbreak;\r\ncase 2:\r\ndefault:\r\nstate->found_nfft = TRANSMISSION_MODE_8K;\r\nbreak;\r\n}\r\n*tune_state = CT_DEMOD_SEARCH_NEXT;\r\nstate->autosearch_state = AS_SEARCHING_GUARD;\r\nif (state->revision == 0x8090)\r\nret = 50;\r\nelse\r\nret = 10;\r\nbreak;\r\ncase AS_SEARCHING_GUARD:\r\nif (state->revision == 0x8090)\r\nstate->found_guard = dib8000_read_word(state, 572) & 0x3;\r\nelse\r\nstate->found_guard = dib8000_read_word(state, 570) & 0x3;\r\n*tune_state = CT_DEMOD_STEP_3;\r\nbreak;\r\ndefault:\r\nstate->status = FE_STATUS_TUNE_FAILED;\r\nstate->autosearch_state = AS_DONE;\r\n*tune_state = CT_DEMOD_STOP;\r\nbreak;\r\n}\r\nbreak;\r\ncase CT_DEMOD_STEP_3:\r\ndib8000_set_isdbt_loop_params(state, LOOP_TUNE_1);\r\ndib8000_set_isdbt_common_channel(state, 0, 0);\r\n*tune_state = CT_DEMOD_STEP_4;\r\nbreak;\r\ncase CT_DEMOD_STEP_4:\r\ndib8000_demod_restart(state);\r\ndib8000_set_sync_wait(state);\r\ndib8000_set_diversity_in(state->fe[0], state->diversity_onoff);\r\nlocks = (dib8000_read_word(state, 180) >> 6) & 0x3f;\r\n*timeout = dib8000_get_timeout(state, 2 * locks, SYMBOL_DEPENDENT_ON);\r\n*tune_state = CT_DEMOD_STEP_5;\r\nbreak;\r\ncase CT_DEMOD_STEP_5:\r\nlocks = dib8000_read_lock(fe);\r\nif (locks & (0x3 << 11)) {\r\ndib8000_update_timf(state);\r\nif (!state->differential_constellation) {\r\n*timeout = dib8000_get_timeout(state, (20 * ((dib8000_read_word(state, 188)>>5)&0x1f)), SYMBOL_DEPENDENT_ON);\r\n*tune_state = CT_DEMOD_STEP_7;\r\n} else {\r\n*tune_state = CT_DEMOD_STEP_8;\r\n}\r\n} else if (time_after(now, *timeout)) {\r\n*tune_state = CT_DEMOD_STEP_6;\r\n}\r\nbreak;\r\ncase CT_DEMOD_STEP_6:\r\nif ((state->fe[1] != NULL) && (state->output_mode != OUTMODE_DIVERSITY)) {\r\nif (dib8000_get_status(state->fe[1]) <= FE_STATUS_STD_SUCCESS)\r\n*tune_state = CT_DEMOD_STEP_8;\r\nelse if (dib8000_get_status(state->fe[1]) >= FE_STATUS_TUNE_TIME_TOO_SHORT) {\r\n*tune_state = CT_DEMOD_STOP;\r\ndib8000_viterbi_state(state, 1);\r\ndib8000_set_isdbt_loop_params(state, LOOP_TUNE_2);\r\nstate->status = FE_STATUS_TUNE_FAILED;\r\n}\r\n} else {\r\ndib8000_viterbi_state(state, 1);\r\ndib8000_set_isdbt_loop_params(state, LOOP_TUNE_2);\r\n*tune_state = CT_DEMOD_STOP;\r\nstate->status = FE_STATUS_TUNE_FAILED;\r\n}\r\nbreak;\r\ncase CT_DEMOD_STEP_7:\r\nlocks = dib8000_read_lock(fe);\r\nif (locks & (1<<10)) {\r\nret = 14;\r\n*tune_state = CT_DEMOD_STEP_8;\r\n} else if (time_after(now, *timeout))\r\n*tune_state = CT_DEMOD_STEP_6;\r\nbreak;\r\ncase CT_DEMOD_STEP_8:\r\ndib8000_viterbi_state(state, 1);\r\ndib8000_set_isdbt_loop_params(state, LOOP_TUNE_2);\r\nif (c->isdbt_sb_mode\r\n&& c->isdbt_sb_subchannel < 14\r\n&& !state->differential_constellation) {\r\nstate->subchannel = 0;\r\n*tune_state = CT_DEMOD_STEP_11;\r\n} else {\r\n*tune_state = CT_DEMOD_STEP_9;\r\nstate->status = FE_STATUS_LOCKED;\r\n}\r\nbreak;\r\ncase CT_DEMOD_STEP_9:\r\nif ((state->revision == 0x8090) || ((dib8000_read_word(state, 1291) >> 9) & 0x1)) {\r\nfor (i = 0; i < 3; i++) {\r\nif (c->layer[i].interleaving >= deeper_interleaver) {\r\ndprintk("layer%i: time interleaver = %d ", i, c->layer[i].interleaving);\r\nif (c->layer[i].segment_count > 0) {\r\ndeeper_interleaver = c->layer[0].interleaving;\r\nstate->longest_intlv_layer = i;\r\n}\r\n}\r\n}\r\nif (deeper_interleaver == 0)\r\nlocks = 2;\r\nelse if (deeper_interleaver == 3)\r\nlocks = 8;\r\nelse\r\nlocks = 2 * deeper_interleaver;\r\nif (state->diversity_onoff != 0)\r\nlocks *= 2;\r\n*timeout = now + msecs_to_jiffies(200 * locks);\r\ndprintk("Deeper interleaver mode = %d on layer %d : timeout mult factor = %d => will use timeout = %ld",\r\ndeeper_interleaver, state->longest_intlv_layer, locks, *timeout);\r\n*tune_state = CT_DEMOD_STEP_10;\r\n} else\r\n*tune_state = CT_DEMOD_STOP;\r\nbreak;\r\ncase CT_DEMOD_STEP_10:\r\nlocks = dib8000_read_lock(fe);\r\nif (locks&(1<<(7-state->longest_intlv_layer))) {\r\ndprintk("ISDB-T layer locks: Layer A %s, Layer B %s, Layer C %s",\r\nc->layer[0].segment_count ? (locks >> 7) & 0x1 ? "locked" : "NOT LOCKED" : "not enabled",\r\nc->layer[1].segment_count ? (locks >> 6) & 0x1 ? "locked" : "NOT LOCKED" : "not enabled",\r\nc->layer[2].segment_count ? (locks >> 5) & 0x1 ? "locked" : "NOT LOCKED" : "not enabled");\r\nif (c->isdbt_sb_mode\r\n&& c->isdbt_sb_subchannel < 14\r\n&& !state->differential_constellation)\r\nstate->status = FE_STATUS_DEMOD_SUCCESS;\r\nelse\r\nstate->status = FE_STATUS_DATA_LOCKED;\r\n*tune_state = CT_DEMOD_STOP;\r\n} else if (time_after(now, *timeout)) {\r\nif (c->isdbt_sb_mode\r\n&& c->isdbt_sb_subchannel < 14\r\n&& !state->differential_constellation) {\r\nstate->subchannel += 3;\r\n*tune_state = CT_DEMOD_STEP_11;\r\n} else {\r\nif (locks & (0x7 << 5)) {\r\ndprintk("Not all ISDB-T layers locked in %d ms: Layer A %s, Layer B %s, Layer C %s",\r\njiffies_to_msecs(now - *timeout),\r\nc->layer[0].segment_count ? (locks >> 7) & 0x1 ? "locked" : "NOT LOCKED" : "not enabled",\r\nc->layer[1].segment_count ? (locks >> 6) & 0x1 ? "locked" : "NOT LOCKED" : "not enabled",\r\nc->layer[2].segment_count ? (locks >> 5) & 0x1 ? "locked" : "NOT LOCKED" : "not enabled");\r\nstate->status = FE_STATUS_DATA_LOCKED;\r\n} else\r\nstate->status = FE_STATUS_TUNE_FAILED;\r\n*tune_state = CT_DEMOD_STOP;\r\n}\r\n}\r\nbreak;\r\ncase CT_DEMOD_STEP_11:\r\nif (state->subchannel <= 41) {\r\ndib8000_set_subchannel_prbs(state, dib8000_get_init_prbs(state, state->subchannel));\r\n*tune_state = CT_DEMOD_STEP_9;\r\n} else {\r\n*tune_state = CT_DEMOD_STOP;\r\nstate->status = FE_STATUS_TUNE_FAILED;\r\n}\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nswitch (*tune_state) {\r\ncase CT_DEMOD_STOP:\r\n#ifdef DIB8000_AGC_FREEZE\r\nif ((state->revision != 0x8090) && (state->agc1_max != 0)) {\r\ndib8000_write_word(state, 108, state->agc1_max);\r\ndib8000_write_word(state, 109, state->agc1_min);\r\ndib8000_write_word(state, 110, state->agc2_max);\r\ndib8000_write_word(state, 111, state->agc2_min);\r\nstate->agc1_max = 0;\r\nstate->agc1_min = 0;\r\nstate->agc2_max = 0;\r\nstate->agc2_min = 0;\r\n}\r\n#endif\r\nret = 0;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nif ((ret > 0) && (*tune_state > CT_DEMOD_STEP_3))\r\nreturn ret * state->symbol_duration;\r\nif ((ret > 0) && (ret < state->symbol_duration))\r\nreturn state->symbol_duration;\r\nreturn ret;\r\n}\r\nstatic int dib8000_wakeup(struct dvb_frontend *fe)\r\n{\r\nstruct dib8000_state *state = fe->demodulator_priv;\r\nu8 index_frontend;\r\nint ret;\r\ndib8000_set_power_mode(state, DIB8000_POWER_ALL);\r\ndib8000_set_adc_state(state, DIBX000_ADC_ON);\r\nif (dib8000_set_adc_state(state, DIBX000_SLOW_ADC_ON) != 0)\r\ndprintk("could not start Slow ADC");\r\nif (state->revision == 0x8090)\r\ndib8000_sad_calib(state);\r\nfor (index_frontend = 1; (index_frontend < MAX_NUMBER_OF_FRONTENDS) && (state->fe[index_frontend] != NULL); index_frontend++) {\r\nret = state->fe[index_frontend]->ops.init(state->fe[index_frontend]);\r\nif (ret < 0)\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic int dib8000_sleep(struct dvb_frontend *fe)\r\n{\r\nstruct dib8000_state *state = fe->demodulator_priv;\r\nu8 index_frontend;\r\nint ret;\r\nfor (index_frontend = 1; (index_frontend < MAX_NUMBER_OF_FRONTENDS) && (state->fe[index_frontend] != NULL); index_frontend++) {\r\nret = state->fe[index_frontend]->ops.sleep(state->fe[index_frontend]);\r\nif (ret < 0)\r\nreturn ret;\r\n}\r\nif (state->revision != 0x8090)\r\ndib8000_set_output_mode(fe, OUTMODE_HIGH_Z);\r\ndib8000_set_power_mode(state, DIB8000_POWER_INTERFACE_ONLY);\r\nreturn dib8000_set_adc_state(state, DIBX000_SLOW_ADC_OFF) | dib8000_set_adc_state(state, DIBX000_ADC_OFF);\r\n}\r\nstatic int dib8000_get_frontend(struct dvb_frontend *fe,\r\nstruct dtv_frontend_properties *c)\r\n{\r\nstruct dib8000_state *state = fe->demodulator_priv;\r\nu16 i, val = 0;\r\nenum fe_status stat = 0;\r\nu8 index_frontend, sub_index_frontend;\r\nc->bandwidth_hz = 6000000;\r\ndib8000_read_status(fe, &stat);\r\nif (!(stat & FE_HAS_SYNC))\r\nreturn 0;\r\ndprintk("dib8000_get_frontend: TMCC lock");\r\nfor (index_frontend = 1; (index_frontend < MAX_NUMBER_OF_FRONTENDS) && (state->fe[index_frontend] != NULL); index_frontend++) {\r\nstate->fe[index_frontend]->ops.read_status(state->fe[index_frontend], &stat);\r\nif (stat&FE_HAS_SYNC) {\r\ndprintk("TMCC lock on the slave%i", index_frontend);\r\nstate->fe[index_frontend]->ops.get_frontend(state->fe[index_frontend], c);\r\nfor (sub_index_frontend = 0; (sub_index_frontend < MAX_NUMBER_OF_FRONTENDS) && (state->fe[sub_index_frontend] != NULL); sub_index_frontend++) {\r\nif (sub_index_frontend != index_frontend) {\r\nstate->fe[sub_index_frontend]->dtv_property_cache.isdbt_sb_mode = state->fe[index_frontend]->dtv_property_cache.isdbt_sb_mode;\r\nstate->fe[sub_index_frontend]->dtv_property_cache.inversion = state->fe[index_frontend]->dtv_property_cache.inversion;\r\nstate->fe[sub_index_frontend]->dtv_property_cache.transmission_mode = state->fe[index_frontend]->dtv_property_cache.transmission_mode;\r\nstate->fe[sub_index_frontend]->dtv_property_cache.guard_interval = state->fe[index_frontend]->dtv_property_cache.guard_interval;\r\nstate->fe[sub_index_frontend]->dtv_property_cache.isdbt_partial_reception = state->fe[index_frontend]->dtv_property_cache.isdbt_partial_reception;\r\nfor (i = 0; i < 3; i++) {\r\nstate->fe[sub_index_frontend]->dtv_property_cache.layer[i].segment_count = state->fe[index_frontend]->dtv_property_cache.layer[i].segment_count;\r\nstate->fe[sub_index_frontend]->dtv_property_cache.layer[i].interleaving = state->fe[index_frontend]->dtv_property_cache.layer[i].interleaving;\r\nstate->fe[sub_index_frontend]->dtv_property_cache.layer[i].fec = state->fe[index_frontend]->dtv_property_cache.layer[i].fec;\r\nstate->fe[sub_index_frontend]->dtv_property_cache.layer[i].modulation = state->fe[index_frontend]->dtv_property_cache.layer[i].modulation;\r\n}\r\n}\r\n}\r\nreturn 0;\r\n}\r\n}\r\nc->isdbt_sb_mode = dib8000_read_word(state, 508) & 0x1;\r\nif (state->revision == 0x8090)\r\nval = dib8000_read_word(state, 572);\r\nelse\r\nval = dib8000_read_word(state, 570);\r\nc->inversion = (val & 0x40) >> 6;\r\nswitch ((val & 0x30) >> 4) {\r\ncase 1:\r\nc->transmission_mode = TRANSMISSION_MODE_2K;\r\ndprintk("dib8000_get_frontend: transmission mode 2K");\r\nbreak;\r\ncase 2:\r\nc->transmission_mode = TRANSMISSION_MODE_4K;\r\ndprintk("dib8000_get_frontend: transmission mode 4K");\r\nbreak;\r\ncase 3:\r\ndefault:\r\nc->transmission_mode = TRANSMISSION_MODE_8K;\r\ndprintk("dib8000_get_frontend: transmission mode 8K");\r\nbreak;\r\n}\r\nswitch (val & 0x3) {\r\ncase 0:\r\nc->guard_interval = GUARD_INTERVAL_1_32;\r\ndprintk("dib8000_get_frontend: Guard Interval = 1/32 ");\r\nbreak;\r\ncase 1:\r\nc->guard_interval = GUARD_INTERVAL_1_16;\r\ndprintk("dib8000_get_frontend: Guard Interval = 1/16 ");\r\nbreak;\r\ncase 2:\r\ndprintk("dib8000_get_frontend: Guard Interval = 1/8 ");\r\nc->guard_interval = GUARD_INTERVAL_1_8;\r\nbreak;\r\ncase 3:\r\ndprintk("dib8000_get_frontend: Guard Interval = 1/4 ");\r\nc->guard_interval = GUARD_INTERVAL_1_4;\r\nbreak;\r\n}\r\nval = dib8000_read_word(state, 505);\r\nc->isdbt_partial_reception = val & 1;\r\ndprintk("dib8000_get_frontend: partial_reception = %d ", c->isdbt_partial_reception);\r\nfor (i = 0; i < 3; i++) {\r\nint show;\r\nval = dib8000_read_word(state, 493 + i) & 0x0f;\r\nc->layer[i].segment_count = val;\r\nif (val == 0 || val > 13)\r\nshow = 0;\r\nelse\r\nshow = 1;\r\nif (show)\r\ndprintk("dib8000_get_frontend: Layer %d segments = %d ",\r\ni, c->layer[i].segment_count);\r\nval = dib8000_read_word(state, 499 + i) & 0x3;\r\nif (val == 3)\r\nval = 4;\r\nc->layer[i].interleaving = val;\r\nif (show)\r\ndprintk("dib8000_get_frontend: Layer %d time_intlv = %d ",\r\ni, c->layer[i].interleaving);\r\nval = dib8000_read_word(state, 481 + i);\r\nswitch (val & 0x7) {\r\ncase 1:\r\nc->layer[i].fec = FEC_1_2;\r\nif (show)\r\ndprintk("dib8000_get_frontend: Layer %d Code Rate = 1/2 ", i);\r\nbreak;\r\ncase 2:\r\nc->layer[i].fec = FEC_2_3;\r\nif (show)\r\ndprintk("dib8000_get_frontend: Layer %d Code Rate = 2/3 ", i);\r\nbreak;\r\ncase 3:\r\nc->layer[i].fec = FEC_3_4;\r\nif (show)\r\ndprintk("dib8000_get_frontend: Layer %d Code Rate = 3/4 ", i);\r\nbreak;\r\ncase 5:\r\nc->layer[i].fec = FEC_5_6;\r\nif (show)\r\ndprintk("dib8000_get_frontend: Layer %d Code Rate = 5/6 ", i);\r\nbreak;\r\ndefault:\r\nc->layer[i].fec = FEC_7_8;\r\nif (show)\r\ndprintk("dib8000_get_frontend: Layer %d Code Rate = 7/8 ", i);\r\nbreak;\r\n}\r\nval = dib8000_read_word(state, 487 + i);\r\nswitch (val & 0x3) {\r\ncase 0:\r\nc->layer[i].modulation = DQPSK;\r\nif (show)\r\ndprintk("dib8000_get_frontend: Layer %d DQPSK ", i);\r\nbreak;\r\ncase 1:\r\nc->layer[i].modulation = QPSK;\r\nif (show)\r\ndprintk("dib8000_get_frontend: Layer %d QPSK ", i);\r\nbreak;\r\ncase 2:\r\nc->layer[i].modulation = QAM_16;\r\nif (show)\r\ndprintk("dib8000_get_frontend: Layer %d QAM16 ", i);\r\nbreak;\r\ncase 3:\r\ndefault:\r\nc->layer[i].modulation = QAM_64;\r\nif (show)\r\ndprintk("dib8000_get_frontend: Layer %d QAM64 ", i);\r\nbreak;\r\n}\r\n}\r\nfor (index_frontend = 1; (index_frontend < MAX_NUMBER_OF_FRONTENDS) && (state->fe[index_frontend] != NULL); index_frontend++) {\r\nstate->fe[index_frontend]->dtv_property_cache.isdbt_sb_mode = c->isdbt_sb_mode;\r\nstate->fe[index_frontend]->dtv_property_cache.inversion = c->inversion;\r\nstate->fe[index_frontend]->dtv_property_cache.transmission_mode = c->transmission_mode;\r\nstate->fe[index_frontend]->dtv_property_cache.guard_interval = c->guard_interval;\r\nstate->fe[index_frontend]->dtv_property_cache.isdbt_partial_reception = c->isdbt_partial_reception;\r\nfor (i = 0; i < 3; i++) {\r\nstate->fe[index_frontend]->dtv_property_cache.layer[i].segment_count = c->layer[i].segment_count;\r\nstate->fe[index_frontend]->dtv_property_cache.layer[i].interleaving = c->layer[i].interleaving;\r\nstate->fe[index_frontend]->dtv_property_cache.layer[i].fec = c->layer[i].fec;\r\nstate->fe[index_frontend]->dtv_property_cache.layer[i].modulation = c->layer[i].modulation;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int dib8000_set_frontend(struct dvb_frontend *fe)\r\n{\r\nstruct dib8000_state *state = fe->demodulator_priv;\r\nstruct dtv_frontend_properties *c = &state->fe[0]->dtv_property_cache;\r\nint l, i, active, time, time_slave = 0;\r\nu8 exit_condition, index_frontend;\r\nunsigned long delay, callback_time;\r\nif (c->frequency == 0) {\r\ndprintk("dib8000: must at least specify frequency ");\r\nreturn 0;\r\n}\r\nif (c->bandwidth_hz == 0) {\r\ndprintk("dib8000: no bandwidth specified, set to default ");\r\nc->bandwidth_hz = 6000000;\r\n}\r\nfor (index_frontend = 0; (index_frontend < MAX_NUMBER_OF_FRONTENDS) && (state->fe[index_frontend] != NULL); index_frontend++) {\r\nstate->fe[index_frontend]->dtv_property_cache.delivery_system = SYS_ISDBT;\r\nmemcpy(&state->fe[index_frontend]->dtv_property_cache, &fe->dtv_property_cache, sizeof(struct dtv_frontend_properties));\r\nif (state->revision != 0x8090) {\r\ndib8000_set_diversity_in(state->fe[index_frontend], 1);\r\nif (index_frontend != 0)\r\ndib8000_set_output_mode(state->fe[index_frontend],\r\nOUTMODE_DIVERSITY);\r\nelse\r\ndib8000_set_output_mode(state->fe[0], OUTMODE_HIGH_Z);\r\n} else {\r\ndib8096p_set_diversity_in(state->fe[index_frontend], 1);\r\nif (index_frontend != 0)\r\ndib8096p_set_output_mode(state->fe[index_frontend],\r\nOUTMODE_DIVERSITY);\r\nelse\r\ndib8096p_set_output_mode(state->fe[0], OUTMODE_HIGH_Z);\r\n}\r\nif (state->fe[index_frontend]->ops.tuner_ops.set_params)\r\nstate->fe[index_frontend]->ops.tuner_ops.set_params(state->fe[index_frontend]);\r\ndib8000_set_tune_state(state->fe[index_frontend], CT_AGC_START);\r\n}\r\nif (state->revision != 0x8090)\r\ndib8000_set_diversity_in(state->fe[index_frontend - 1], 0);\r\nelse\r\ndib8096p_set_diversity_in(state->fe[index_frontend - 1], 0);\r\ndo {\r\ntime = dib8000_agc_startup(state->fe[0]);\r\nfor (index_frontend = 1; (index_frontend < MAX_NUMBER_OF_FRONTENDS) && (state->fe[index_frontend] != NULL); index_frontend++) {\r\ntime_slave = dib8000_agc_startup(state->fe[index_frontend]);\r\nif (time == 0)\r\ntime = time_slave;\r\nelse if ((time_slave != 0) && (time_slave > time))\r\ntime = time_slave;\r\n}\r\nif (time == 0)\r\nbreak;\r\ntime = 10 * (time + 99)/100;\r\nusleep_range(time * 1000, (time + 1) * 1000);\r\nexit_condition = 1;\r\nfor (index_frontend = 0; (index_frontend < MAX_NUMBER_OF_FRONTENDS) && (state->fe[index_frontend] != NULL); index_frontend++) {\r\nif (dib8000_get_tune_state(state->fe[index_frontend]) != CT_AGC_STOP) {\r\nexit_condition = 0;\r\nbreak;\r\n}\r\n}\r\n} while (exit_condition == 0);\r\nfor (index_frontend = 0; (index_frontend < MAX_NUMBER_OF_FRONTENDS) && (state->fe[index_frontend] != NULL); index_frontend++)\r\ndib8000_set_tune_state(state->fe[index_frontend], CT_DEMOD_START);\r\nactive = 1;\r\ndo {\r\ncallback_time = 0;\r\nfor (index_frontend = 0; (index_frontend < MAX_NUMBER_OF_FRONTENDS) && (state->fe[index_frontend] != NULL); index_frontend++) {\r\ndelay = dib8000_tune(state->fe[index_frontend]);\r\nif (delay != 0) {\r\ndelay = jiffies + usecs_to_jiffies(100 * delay);\r\nif (!callback_time || delay < callback_time)\r\ncallback_time = delay;\r\n}\r\nif (state->channel_parameters_set == 0) {\r\nif ((dib8000_get_status(state->fe[index_frontend]) == FE_STATUS_DEMOD_SUCCESS) || (dib8000_get_status(state->fe[index_frontend]) == FE_STATUS_FFT_SUCCESS)) {\r\ndprintk("autosearch succeeded on fe%i", index_frontend);\r\ndib8000_get_frontend(state->fe[index_frontend], c);\r\nstate->channel_parameters_set = 1;\r\nfor (l = 0; (l < MAX_NUMBER_OF_FRONTENDS) && (state->fe[l] != NULL); l++) {\r\nif (l != index_frontend) {\r\ndprintk("Restarting frontend %d\n", l);\r\ndib8000_tune_restart_from_demod(state->fe[l]);\r\nstate->fe[l]->dtv_property_cache.isdbt_sb_mode = state->fe[index_frontend]->dtv_property_cache.isdbt_sb_mode;\r\nstate->fe[l]->dtv_property_cache.inversion = state->fe[index_frontend]->dtv_property_cache.inversion;\r\nstate->fe[l]->dtv_property_cache.transmission_mode = state->fe[index_frontend]->dtv_property_cache.transmission_mode;\r\nstate->fe[l]->dtv_property_cache.guard_interval = state->fe[index_frontend]->dtv_property_cache.guard_interval;\r\nstate->fe[l]->dtv_property_cache.isdbt_partial_reception = state->fe[index_frontend]->dtv_property_cache.isdbt_partial_reception;\r\nfor (i = 0; i < 3; i++) {\r\nstate->fe[l]->dtv_property_cache.layer[i].segment_count = state->fe[index_frontend]->dtv_property_cache.layer[i].segment_count;\r\nstate->fe[l]->dtv_property_cache.layer[i].interleaving = state->fe[index_frontend]->dtv_property_cache.layer[i].interleaving;\r\nstate->fe[l]->dtv_property_cache.layer[i].fec = state->fe[index_frontend]->dtv_property_cache.layer[i].fec;\r\nstate->fe[l]->dtv_property_cache.layer[i].modulation = state->fe[index_frontend]->dtv_property_cache.layer[i].modulation;\r\n}\r\n}\r\n}\r\n}\r\n}\r\n}\r\nif (dib8000_get_status(state->fe[0]) == FE_STATUS_TUNE_FAILED ||\r\ndib8000_get_status(state->fe[0]) == FE_STATUS_LOCKED ||\r\ndib8000_get_status(state->fe[0]) == FE_STATUS_DATA_LOCKED) {\r\nactive = 0;\r\nfor (index_frontend = 0; (index_frontend < MAX_NUMBER_OF_FRONTENDS) && (state->fe[index_frontend] != NULL); index_frontend++) {\r\nif (dib8000_get_tune_state(state->fe[index_frontend]) != CT_DEMOD_STOP)\r\nactive = 1;\r\n}\r\nif (active == 0)\r\ndprintk("tuning done with status %d", dib8000_get_status(state->fe[0]));\r\n}\r\nif ((active == 1) && (callback_time == 0)) {\r\ndprintk("strange callback time something went wrong");\r\nactive = 0;\r\n}\r\nwhile ((active == 1) && (time_before(jiffies, callback_time)))\r\nmsleep(100);\r\n} while (active);\r\nif (state->revision != 0x8090)\r\ndib8000_set_output_mode(state->fe[0], state->cfg.output_mode);\r\nelse {\r\ndib8096p_set_output_mode(state->fe[0], state->cfg.output_mode);\r\nif (state->cfg.enMpegOutput == 0) {\r\ndib8096p_setDibTxMux(state, MPEG_ON_DIBTX);\r\ndib8096p_setHostBusMux(state, DIBTX_ON_HOSTBUS);\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int dib8000_read_status(struct dvb_frontend *fe, enum fe_status *stat)\r\n{\r\nstruct dib8000_state *state = fe->demodulator_priv;\r\nu16 lock_slave = 0, lock;\r\nu8 index_frontend;\r\nlock = dib8000_read_lock(fe);\r\nfor (index_frontend = 1; (index_frontend < MAX_NUMBER_OF_FRONTENDS) && (state->fe[index_frontend] != NULL); index_frontend++)\r\nlock_slave |= dib8000_read_lock(state->fe[index_frontend]);\r\n*stat = 0;\r\nif (((lock >> 13) & 1) || ((lock_slave >> 13) & 1))\r\n*stat |= FE_HAS_SIGNAL;\r\nif (((lock >> 8) & 1) || ((lock_slave >> 8) & 1))\r\n*stat |= FE_HAS_CARRIER;\r\nif ((((lock >> 1) & 0xf) == 0xf) || (((lock_slave >> 1) & 0xf) == 0xf))\r\n*stat |= FE_HAS_SYNC;\r\nif ((((lock >> 12) & 1) || ((lock_slave >> 12) & 1)) && ((lock >> 5) & 7))\r\n*stat |= FE_HAS_LOCK;\r\nif (((lock >> 12) & 1) || ((lock_slave >> 12) & 1)) {\r\nlock = dib8000_read_word(state, 554);\r\nif (lock & 0x01)\r\n*stat |= FE_HAS_VITERBI;\r\nlock = dib8000_read_word(state, 555);\r\nif (lock & 0x01)\r\n*stat |= FE_HAS_VITERBI;\r\nlock = dib8000_read_word(state, 556);\r\nif (lock & 0x01)\r\n*stat |= FE_HAS_VITERBI;\r\n}\r\ndib8000_get_stats(fe, *stat);\r\nreturn 0;\r\n}\r\nstatic int dib8000_read_ber(struct dvb_frontend *fe, u32 * ber)\r\n{\r\nstruct dib8000_state *state = fe->demodulator_priv;\r\nif (state->revision == 0x8090)\r\n*ber = (dib8000_read_word(state, 562) << 16) |\r\ndib8000_read_word(state, 563);\r\nelse\r\n*ber = (dib8000_read_word(state, 560) << 16) |\r\ndib8000_read_word(state, 561);\r\nreturn 0;\r\n}\r\nstatic int dib8000_read_unc_blocks(struct dvb_frontend *fe, u32 * unc)\r\n{\r\nstruct dib8000_state *state = fe->demodulator_priv;\r\nif (state->revision == 0x8090)\r\n*unc = dib8000_read_word(state, 567);\r\nelse\r\n*unc = dib8000_read_word(state, 565);\r\nreturn 0;\r\n}\r\nstatic int dib8000_read_signal_strength(struct dvb_frontend *fe, u16 * strength)\r\n{\r\nstruct dib8000_state *state = fe->demodulator_priv;\r\nu8 index_frontend;\r\nu16 val;\r\n*strength = 0;\r\nfor (index_frontend = 1; (index_frontend < MAX_NUMBER_OF_FRONTENDS) && (state->fe[index_frontend] != NULL); index_frontend++) {\r\nstate->fe[index_frontend]->ops.read_signal_strength(state->fe[index_frontend], &val);\r\nif (val > 65535 - *strength)\r\n*strength = 65535;\r\nelse\r\n*strength += val;\r\n}\r\nval = 65535 - dib8000_read_word(state, 390);\r\nif (val > 65535 - *strength)\r\n*strength = 65535;\r\nelse\r\n*strength += val;\r\nreturn 0;\r\n}\r\nstatic u32 dib8000_get_snr(struct dvb_frontend *fe)\r\n{\r\nstruct dib8000_state *state = fe->demodulator_priv;\r\nu32 n, s, exp;\r\nu16 val;\r\nif (state->revision != 0x8090)\r\nval = dib8000_read_word(state, 542);\r\nelse\r\nval = dib8000_read_word(state, 544);\r\nn = (val >> 6) & 0xff;\r\nexp = (val & 0x3f);\r\nif ((exp & 0x20) != 0)\r\nexp -= 0x40;\r\nn <<= exp+16;\r\nif (state->revision != 0x8090)\r\nval = dib8000_read_word(state, 543);\r\nelse\r\nval = dib8000_read_word(state, 545);\r\ns = (val >> 6) & 0xff;\r\nexp = (val & 0x3f);\r\nif ((exp & 0x20) != 0)\r\nexp -= 0x40;\r\ns <<= exp+16;\r\nif (n > 0) {\r\nu32 t = (s/n) << 16;\r\nreturn t + ((s << 16) - n*t) / n;\r\n}\r\nreturn 0xffffffff;\r\n}\r\nstatic int dib8000_read_snr(struct dvb_frontend *fe, u16 * snr)\r\n{\r\nstruct dib8000_state *state = fe->demodulator_priv;\r\nu8 index_frontend;\r\nu32 snr_master;\r\nsnr_master = dib8000_get_snr(fe);\r\nfor (index_frontend = 1; (index_frontend < MAX_NUMBER_OF_FRONTENDS) && (state->fe[index_frontend] != NULL); index_frontend++)\r\nsnr_master += dib8000_get_snr(state->fe[index_frontend]);\r\nif ((snr_master >> 16) != 0) {\r\nsnr_master = 10*intlog10(snr_master>>16);\r\n*snr = snr_master / ((1 << 24) / 10);\r\n}\r\nelse\r\n*snr = 0;\r\nreturn 0;\r\n}\r\nstatic u32 interpolate_value(u32 value, struct linear_segments *segments,\r\nunsigned len)\r\n{\r\nu64 tmp64;\r\nu32 dx;\r\ns32 dy;\r\nint i, ret;\r\nif (value >= segments[0].x)\r\nreturn segments[0].y;\r\nif (value < segments[len-1].x)\r\nreturn segments[len-1].y;\r\nfor (i = 1; i < len - 1; i++) {\r\nif (value == segments[i].x)\r\nreturn segments[i].y;\r\nif (value > segments[i].x)\r\nbreak;\r\n}\r\ndy = segments[i - 1].y - segments[i].y;\r\ndx = segments[i - 1].x - segments[i].x;\r\ntmp64 = value - segments[i].x;\r\ntmp64 *= dy;\r\ndo_div(tmp64, dx);\r\nret = segments[i].y + tmp64;\r\nreturn ret;\r\n}\r\nstatic u32 dib8000_get_time_us(struct dvb_frontend *fe, int layer)\r\n{\r\nstruct dib8000_state *state = fe->demodulator_priv;\r\nstruct dtv_frontend_properties *c = &state->fe[0]->dtv_property_cache;\r\nint ini_layer, end_layer, i;\r\nu64 time_us, tmp64;\r\nu32 tmp, denom;\r\nint guard, rate_num, rate_denum = 1, bits_per_symbol, nsegs;\r\nint interleaving = 0, fft_div;\r\nif (layer >= 0) {\r\nini_layer = layer;\r\nend_layer = layer + 1;\r\n} else {\r\nini_layer = 0;\r\nend_layer = 3;\r\n}\r\nswitch (c->guard_interval) {\r\ncase GUARD_INTERVAL_1_4:\r\nguard = 4;\r\nbreak;\r\ncase GUARD_INTERVAL_1_8:\r\nguard = 8;\r\nbreak;\r\ncase GUARD_INTERVAL_1_16:\r\nguard = 16;\r\nbreak;\r\ndefault:\r\ncase GUARD_INTERVAL_1_32:\r\nguard = 32;\r\nbreak;\r\n}\r\nswitch (c->transmission_mode) {\r\ncase TRANSMISSION_MODE_2K:\r\nfft_div = 4;\r\nbreak;\r\ncase TRANSMISSION_MODE_4K:\r\nfft_div = 2;\r\nbreak;\r\ndefault:\r\ncase TRANSMISSION_MODE_8K:\r\nfft_div = 1;\r\nbreak;\r\n}\r\ndenom = 0;\r\nfor (i = ini_layer; i < end_layer; i++) {\r\nnsegs = c->layer[i].segment_count;\r\nif (nsegs == 0 || nsegs > 13)\r\ncontinue;\r\nswitch (c->layer[i].modulation) {\r\ncase DQPSK:\r\ncase QPSK:\r\nbits_per_symbol = 2;\r\nbreak;\r\ncase QAM_16:\r\nbits_per_symbol = 4;\r\nbreak;\r\ndefault:\r\ncase QAM_64:\r\nbits_per_symbol = 6;\r\nbreak;\r\n}\r\nswitch (c->layer[i].fec) {\r\ncase FEC_1_2:\r\nrate_num = 1;\r\nrate_denum = 2;\r\nbreak;\r\ncase FEC_2_3:\r\nrate_num = 2;\r\nrate_denum = 3;\r\nbreak;\r\ncase FEC_3_4:\r\nrate_num = 3;\r\nrate_denum = 4;\r\nbreak;\r\ncase FEC_5_6:\r\nrate_num = 5;\r\nrate_denum = 6;\r\nbreak;\r\ndefault:\r\ncase FEC_7_8:\r\nrate_num = 7;\r\nrate_denum = 8;\r\nbreak;\r\n}\r\ninterleaving = c->layer[i].interleaving;\r\ndenom += bits_per_symbol * rate_num * fft_div * nsegs * 384;\r\n}\r\nif (!denom)\r\nreturn 0;\r\ntime_us = rate_denum * (1008 * 1562500L);\r\ntmp64 = time_us;\r\ndo_div(tmp64, guard);\r\ntime_us = time_us + tmp64;\r\ntime_us += denom / 2;\r\ndo_div(time_us, denom);\r\ntmp = 1008 * 96 * interleaving;\r\ntime_us += tmp + tmp / guard;\r\nreturn time_us;\r\n}\r\nstatic int dib8000_get_stats(struct dvb_frontend *fe, enum fe_status stat)\r\n{\r\nstruct dib8000_state *state = fe->demodulator_priv;\r\nstruct dtv_frontend_properties *c = &state->fe[0]->dtv_property_cache;\r\nint i;\r\nint show_per_stats = 0;\r\nu32 time_us = 0, snr, val;\r\nu64 blocks;\r\ns32 db;\r\nu16 strength;\r\ndib8000_read_signal_strength(fe, &strength);\r\nval = strength;\r\ndb = interpolate_value(val,\r\nstrength_to_db_table,\r\nARRAY_SIZE(strength_to_db_table)) - 131000;\r\nc->strength.stat[0].svalue = db;\r\nif (!(stat & FE_HAS_LOCK)) {\r\nc->cnr.len = 1;\r\nc->block_count.len = 1;\r\nc->block_error.len = 1;\r\nc->post_bit_error.len = 1;\r\nc->post_bit_count.len = 1;\r\nc->cnr.stat[0].scale = FE_SCALE_NOT_AVAILABLE;\r\nc->post_bit_error.stat[0].scale = FE_SCALE_NOT_AVAILABLE;\r\nc->post_bit_count.stat[0].scale = FE_SCALE_NOT_AVAILABLE;\r\nc->block_error.stat[0].scale = FE_SCALE_NOT_AVAILABLE;\r\nc->block_count.stat[0].scale = FE_SCALE_NOT_AVAILABLE;\r\nreturn 0;\r\n}\r\nif (time_after(jiffies, state->per_jiffies_stats)) {\r\nstate->per_jiffies_stats = jiffies + msecs_to_jiffies(1000);\r\nsnr = dib8000_get_snr(fe);\r\nfor (i = 1; i < MAX_NUMBER_OF_FRONTENDS; i++) {\r\nif (state->fe[i])\r\nsnr += dib8000_get_snr(state->fe[i]);\r\n}\r\nsnr = snr >> 16;\r\nif (snr) {\r\nsnr = 10 * intlog10(snr);\r\nsnr = (1000L * snr) >> 24;\r\n} else {\r\nsnr = 0;\r\n}\r\nc->cnr.stat[0].svalue = snr;\r\nc->cnr.stat[0].scale = FE_SCALE_DECIBEL;\r\ndib8000_read_unc_blocks(fe, &val);\r\nif (val < state->init_ucb)\r\nstate->init_ucb += 0x100000000LL;\r\nc->block_error.stat[0].scale = FE_SCALE_COUNTER;\r\nc->block_error.stat[0].uvalue = val + state->init_ucb;\r\nif (!time_us)\r\ntime_us = dib8000_get_time_us(fe, -1);\r\nif (time_us) {\r\nblocks = 1250000ULL * 1000000ULL;\r\ndo_div(blocks, time_us * 8 * 204);\r\nc->block_count.stat[0].scale = FE_SCALE_COUNTER;\r\nc->block_count.stat[0].uvalue += blocks;\r\n}\r\nshow_per_stats = 1;\r\n}\r\nif (time_after(jiffies, state->ber_jiffies_stats)) {\r\ntime_us = dib8000_get_time_us(fe, -1);\r\nstate->ber_jiffies_stats = jiffies + msecs_to_jiffies((time_us + 500) / 1000);\r\ndprintk("Next all layers stats available in %u us.", time_us);\r\ndib8000_read_ber(fe, &val);\r\nc->post_bit_error.stat[0].scale = FE_SCALE_COUNTER;\r\nc->post_bit_error.stat[0].uvalue += val;\r\nc->post_bit_count.stat[0].scale = FE_SCALE_COUNTER;\r\nc->post_bit_count.stat[0].uvalue += 100000000;\r\n}\r\nif (state->revision < 0x8002)\r\nreturn 0;\r\nc->block_error.len = 4;\r\nc->post_bit_error.len = 4;\r\nc->post_bit_count.len = 4;\r\nfor (i = 0; i < 3; i++) {\r\nunsigned nsegs = c->layer[i].segment_count;\r\nif (nsegs == 0 || nsegs > 13)\r\ncontinue;\r\ntime_us = 0;\r\nif (time_after(jiffies, state->ber_jiffies_stats_layer[i])) {\r\ntime_us = dib8000_get_time_us(fe, i);\r\nstate->ber_jiffies_stats_layer[i] = jiffies + msecs_to_jiffies((time_us + 500) / 1000);\r\ndprintk("Next layer %c stats will be available in %u us\n",\r\n'A' + i, time_us);\r\nval = dib8000_read_word(state, per_layer_regs[i].ber);\r\nc->post_bit_error.stat[1 + i].scale = FE_SCALE_COUNTER;\r\nc->post_bit_error.stat[1 + i].uvalue += val;\r\nc->post_bit_count.stat[1 + i].scale = FE_SCALE_COUNTER;\r\nc->post_bit_count.stat[1 + i].uvalue += 100000000;\r\n}\r\nif (show_per_stats) {\r\nval = dib8000_read_word(state, per_layer_regs[i].per);\r\nc->block_error.stat[1 + i].scale = FE_SCALE_COUNTER;\r\nc->block_error.stat[1 + i].uvalue += val;\r\nif (!time_us)\r\ntime_us = dib8000_get_time_us(fe, i);\r\nif (time_us) {\r\nblocks = 1250000ULL * 1000000ULL;\r\ndo_div(blocks, time_us * 8 * 204);\r\nc->block_count.stat[0].scale = FE_SCALE_COUNTER;\r\nc->block_count.stat[0].uvalue += blocks;\r\n}\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int dib8000_set_slave_frontend(struct dvb_frontend *fe, struct dvb_frontend *fe_slave)\r\n{\r\nstruct dib8000_state *state = fe->demodulator_priv;\r\nu8 index_frontend = 1;\r\nwhile ((index_frontend < MAX_NUMBER_OF_FRONTENDS) && (state->fe[index_frontend] != NULL))\r\nindex_frontend++;\r\nif (index_frontend < MAX_NUMBER_OF_FRONTENDS) {\r\ndprintk("set slave fe %p to index %i", fe_slave, index_frontend);\r\nstate->fe[index_frontend] = fe_slave;\r\nreturn 0;\r\n}\r\ndprintk("too many slave frontend");\r\nreturn -ENOMEM;\r\n}\r\nstatic int dib8000_remove_slave_frontend(struct dvb_frontend *fe)\r\n{\r\nstruct dib8000_state *state = fe->demodulator_priv;\r\nu8 index_frontend = 1;\r\nwhile ((index_frontend < MAX_NUMBER_OF_FRONTENDS) && (state->fe[index_frontend] != NULL))\r\nindex_frontend++;\r\nif (index_frontend != 1) {\r\ndprintk("remove slave fe %p (index %i)", state->fe[index_frontend-1], index_frontend-1);\r\nstate->fe[index_frontend] = NULL;\r\nreturn 0;\r\n}\r\ndprintk("no frontend to be removed");\r\nreturn -ENODEV;\r\n}\r\nstatic struct dvb_frontend *dib8000_get_slave_frontend(struct dvb_frontend *fe, int slave_index)\r\n{\r\nstruct dib8000_state *state = fe->demodulator_priv;\r\nif (slave_index >= MAX_NUMBER_OF_FRONTENDS)\r\nreturn NULL;\r\nreturn state->fe[slave_index];\r\n}\r\nstatic int dib8000_i2c_enumeration(struct i2c_adapter *host, int no_of_demods,\r\nu8 default_addr, u8 first_addr, u8 is_dib8096p)\r\n{\r\nint k = 0, ret = 0;\r\nu8 new_addr = 0;\r\nstruct i2c_device client = {.adap = host };\r\nclient.i2c_write_buffer = kzalloc(4 * sizeof(u8), GFP_KERNEL);\r\nif (!client.i2c_write_buffer) {\r\ndprintk("%s: not enough memory", __func__);\r\nreturn -ENOMEM;\r\n}\r\nclient.i2c_read_buffer = kzalloc(4 * sizeof(u8), GFP_KERNEL);\r\nif (!client.i2c_read_buffer) {\r\ndprintk("%s: not enough memory", __func__);\r\nret = -ENOMEM;\r\ngoto error_memory_read;\r\n}\r\nclient.i2c_buffer_lock = kzalloc(sizeof(struct mutex), GFP_KERNEL);\r\nif (!client.i2c_buffer_lock) {\r\ndprintk("%s: not enough memory", __func__);\r\nret = -ENOMEM;\r\ngoto error_memory_lock;\r\n}\r\nmutex_init(client.i2c_buffer_lock);\r\nfor (k = no_of_demods - 1; k >= 0; k--) {\r\nnew_addr = first_addr + (k << 1);\r\nclient.addr = new_addr;\r\nif (!is_dib8096p)\r\ndib8000_i2c_write16(&client, 1287, 0x0003);\r\nif (dib8000_identify(&client) == 0) {\r\nif (!is_dib8096p)\r\ndib8000_i2c_write16(&client, 1287, 0x0003);\r\nclient.addr = default_addr;\r\nif (dib8000_identify(&client) == 0) {\r\ndprintk("#%d: not identified", k);\r\nret = -EINVAL;\r\ngoto error;\r\n}\r\n}\r\ndib8000_i2c_write16(&client, 1286, (1 << 10) | (4 << 6));\r\ndib8000_i2c_write16(&client, 1285, (new_addr << 2) | 0x2);\r\nclient.addr = new_addr;\r\ndib8000_identify(&client);\r\ndprintk("IC %d initialized (to i2c_address 0x%x)", k, new_addr);\r\n}\r\nfor (k = 0; k < no_of_demods; k++) {\r\nnew_addr = first_addr | (k << 1);\r\nclient.addr = new_addr;\r\ndib8000_i2c_write16(&client, 1285, new_addr << 2);\r\ndib8000_i2c_write16(&client, 1286, 0);\r\n}\r\nerror:\r\nkfree(client.i2c_buffer_lock);\r\nerror_memory_lock:\r\nkfree(client.i2c_read_buffer);\r\nerror_memory_read:\r\nkfree(client.i2c_write_buffer);\r\nreturn ret;\r\n}\r\nstatic int dib8000_fe_get_tune_settings(struct dvb_frontend *fe, struct dvb_frontend_tune_settings *tune)\r\n{\r\ntune->min_delay_ms = 1000;\r\ntune->step_size = 0;\r\ntune->max_drift = 0;\r\nreturn 0;\r\n}\r\nstatic void dib8000_release(struct dvb_frontend *fe)\r\n{\r\nstruct dib8000_state *st = fe->demodulator_priv;\r\nu8 index_frontend;\r\nfor (index_frontend = 1; (index_frontend < MAX_NUMBER_OF_FRONTENDS) && (st->fe[index_frontend] != NULL); index_frontend++)\r\ndvb_frontend_detach(st->fe[index_frontend]);\r\ndibx000_exit_i2c_master(&st->i2c_master);\r\ni2c_del_adapter(&st->dib8096p_tuner_adap);\r\nkfree(st->fe[0]);\r\nkfree(st);\r\n}\r\nstatic struct i2c_adapter *dib8000_get_i2c_master(struct dvb_frontend *fe, enum dibx000_i2c_interface intf, int gating)\r\n{\r\nstruct dib8000_state *st = fe->demodulator_priv;\r\nreturn dibx000_get_i2c_adapter(&st->i2c_master, intf, gating);\r\n}\r\nstatic int dib8000_pid_filter_ctrl(struct dvb_frontend *fe, u8 onoff)\r\n{\r\nstruct dib8000_state *st = fe->demodulator_priv;\r\nu16 val = dib8000_read_word(st, 299) & 0xffef;\r\nval |= (onoff & 0x1) << 4;\r\ndprintk("pid filter enabled %d", onoff);\r\nreturn dib8000_write_word(st, 299, val);\r\n}\r\nstatic int dib8000_pid_filter(struct dvb_frontend *fe, u8 id, u16 pid, u8 onoff)\r\n{\r\nstruct dib8000_state *st = fe->demodulator_priv;\r\ndprintk("Index %x, PID %d, OnOff %d", id, pid, onoff);\r\nreturn dib8000_write_word(st, 305 + id, onoff ? (1 << 13) | pid : 0);\r\n}\r\nstatic struct dvb_frontend *dib8000_init(struct i2c_adapter *i2c_adap, u8 i2c_addr, struct dib8000_config *cfg)\r\n{\r\nstruct dvb_frontend *fe;\r\nstruct dib8000_state *state;\r\ndprintk("dib8000_init");\r\nstate = kzalloc(sizeof(struct dib8000_state), GFP_KERNEL);\r\nif (state == NULL)\r\nreturn NULL;\r\nfe = kzalloc(sizeof(struct dvb_frontend), GFP_KERNEL);\r\nif (fe == NULL)\r\ngoto error;\r\nmemcpy(&state->cfg, cfg, sizeof(struct dib8000_config));\r\nstate->i2c.adap = i2c_adap;\r\nstate->i2c.addr = i2c_addr;\r\nstate->i2c.i2c_write_buffer = state->i2c_write_buffer;\r\nstate->i2c.i2c_read_buffer = state->i2c_read_buffer;\r\nmutex_init(&state->i2c_buffer_lock);\r\nstate->i2c.i2c_buffer_lock = &state->i2c_buffer_lock;\r\nstate->gpio_val = cfg->gpio_val;\r\nstate->gpio_dir = cfg->gpio_dir;\r\nif ((state->cfg.output_mode != OUTMODE_MPEG2_SERIAL) && (state->cfg.output_mode != OUTMODE_MPEG2_PAR_GATED_CLK))\r\nstate->cfg.output_mode = OUTMODE_MPEG2_FIFO;\r\nstate->fe[0] = fe;\r\nfe->demodulator_priv = state;\r\nmemcpy(&state->fe[0]->ops, &dib8000_ops, sizeof(struct dvb_frontend_ops));\r\nstate->timf_default = cfg->pll->timf;\r\nif (dib8000_identify(&state->i2c) == 0)\r\ngoto error;\r\ndibx000_init_i2c_master(&state->i2c_master, DIB8000, state->i2c.adap, state->i2c.addr);\r\nstrncpy(state->dib8096p_tuner_adap.name, "DiB8096P tuner interface",\r\nsizeof(state->dib8096p_tuner_adap.name));\r\nstate->dib8096p_tuner_adap.algo = &dib8096p_tuner_xfer_algo;\r\nstate->dib8096p_tuner_adap.algo_data = NULL;\r\nstate->dib8096p_tuner_adap.dev.parent = state->i2c.adap->dev.parent;\r\ni2c_set_adapdata(&state->dib8096p_tuner_adap, state);\r\ni2c_add_adapter(&state->dib8096p_tuner_adap);\r\ndib8000_reset(fe);\r\ndib8000_write_word(state, 285, (dib8000_read_word(state, 285) & ~0x60) | (3 << 5));\r\nstate->current_demod_bw = 6000;\r\nreturn fe;\r\nerror:\r\nkfree(state);\r\nreturn NULL;\r\n}\r\nvoid *dib8000_attach(struct dib8000_ops *ops)\r\n{\r\nif (!ops)\r\nreturn NULL;\r\nops->pwm_agc_reset = dib8000_pwm_agc_reset;\r\nops->get_dc_power = dib8090p_get_dc_power;\r\nops->set_gpio = dib8000_set_gpio;\r\nops->get_slave_frontend = dib8000_get_slave_frontend;\r\nops->set_tune_state = dib8000_set_tune_state;\r\nops->pid_filter_ctrl = dib8000_pid_filter_ctrl;\r\nops->remove_slave_frontend = dib8000_remove_slave_frontend;\r\nops->get_adc_power = dib8000_get_adc_power;\r\nops->update_pll = dib8000_update_pll;\r\nops->tuner_sleep = dib8096p_tuner_sleep;\r\nops->get_tune_state = dib8000_get_tune_state;\r\nops->get_i2c_tuner = dib8096p_get_i2c_tuner;\r\nops->set_slave_frontend = dib8000_set_slave_frontend;\r\nops->pid_filter = dib8000_pid_filter;\r\nops->ctrl_timf = dib8000_ctrl_timf;\r\nops->init = dib8000_init;\r\nops->get_i2c_master = dib8000_get_i2c_master;\r\nops->i2c_enumeration = dib8000_i2c_enumeration;\r\nops->set_wbd_ref = dib8000_set_wbd_ref;\r\nreturn ops;\r\n}
