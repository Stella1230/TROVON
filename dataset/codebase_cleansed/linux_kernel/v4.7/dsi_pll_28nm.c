static bool pll_28nm_poll_for_ready(struct dsi_pll_28nm *pll_28nm,\r\nu32 nb_tries, u32 timeout_us)\r\n{\r\nbool pll_locked = false;\r\nu32 val;\r\nwhile (nb_tries--) {\r\nval = pll_read(pll_28nm->mmio + REG_DSI_28nm_PHY_PLL_STATUS);\r\npll_locked = !!(val & DSI_28nm_PHY_PLL_STATUS_PLL_RDY);\r\nif (pll_locked)\r\nbreak;\r\nudelay(timeout_us);\r\n}\r\nDBG("DSI PLL is %slocked", pll_locked ? "" : "*not* ");\r\nreturn pll_locked;\r\n}\r\nstatic void pll_28nm_software_reset(struct dsi_pll_28nm *pll_28nm)\r\n{\r\nvoid __iomem *base = pll_28nm->mmio;\r\npll_write_udelay(base + REG_DSI_28nm_PHY_PLL_TEST_CFG,\r\nDSI_28nm_PHY_PLL_TEST_CFG_PLL_SW_RESET, 1);\r\npll_write_udelay(base + REG_DSI_28nm_PHY_PLL_TEST_CFG, 0x00, 1);\r\n}\r\nstatic int dsi_pll_28nm_clk_set_rate(struct clk_hw *hw, unsigned long rate,\r\nunsigned long parent_rate)\r\n{\r\nstruct msm_dsi_pll *pll = hw_clk_to_pll(hw);\r\nstruct dsi_pll_28nm *pll_28nm = to_pll_28nm(pll);\r\nstruct device *dev = &pll_28nm->pdev->dev;\r\nvoid __iomem *base = pll_28nm->mmio;\r\nunsigned long div_fbx1000, gen_vco_clk;\r\nu32 refclk_cfg, frac_n_mode, frac_n_value;\r\nu32 sdm_cfg0, sdm_cfg1, sdm_cfg2, sdm_cfg3;\r\nu32 cal_cfg10, cal_cfg11;\r\nu32 rem;\r\nint i;\r\nVERB("rate=%lu, parent's=%lu", rate, parent_rate);\r\npll_write(base + REG_DSI_28nm_PHY_PLL_POSTDIV2_CFG, 3);\r\nfor (i = 0; i < LPFR_LUT_SIZE; i++)\r\nif (rate <= lpfr_lut[i].vco_rate)\r\nbreak;\r\nif (i == LPFR_LUT_SIZE) {\r\ndev_err(dev, "unable to get loop filter resistance. vco=%lu\n",\r\nrate);\r\nreturn -EINVAL;\r\n}\r\npll_write(base + REG_DSI_28nm_PHY_PLL_LPFR_CFG, lpfr_lut[i].resistance);\r\npll_write(base + REG_DSI_28nm_PHY_PLL_LPFC1_CFG, 0x70);\r\npll_write(base + REG_DSI_28nm_PHY_PLL_LPFC2_CFG, 0x15);\r\nrem = rate % VCO_REF_CLK_RATE;\r\nif (rem) {\r\nrefclk_cfg = DSI_28nm_PHY_PLL_REFCLK_CFG_DBLR;\r\nfrac_n_mode = 1;\r\ndiv_fbx1000 = rate / (VCO_REF_CLK_RATE / 500);\r\ngen_vco_clk = div_fbx1000 * (VCO_REF_CLK_RATE / 500);\r\n} else {\r\nrefclk_cfg = 0x0;\r\nfrac_n_mode = 0;\r\ndiv_fbx1000 = rate / (VCO_REF_CLK_RATE / 1000);\r\ngen_vco_clk = div_fbx1000 * (VCO_REF_CLK_RATE / 1000);\r\n}\r\nDBG("refclk_cfg = %d", refclk_cfg);\r\nrem = div_fbx1000 % 1000;\r\nfrac_n_value = (rem << 16) / 1000;\r\nDBG("div_fb = %lu", div_fbx1000);\r\nDBG("frac_n_value = %d", frac_n_value);\r\nDBG("Generated VCO Clock: %lu", gen_vco_clk);\r\nrem = 0;\r\nsdm_cfg1 = pll_read(base + REG_DSI_28nm_PHY_PLL_SDM_CFG1);\r\nsdm_cfg1 &= ~DSI_28nm_PHY_PLL_SDM_CFG1_DC_OFFSET__MASK;\r\nif (frac_n_mode) {\r\nsdm_cfg0 = 0x0;\r\nsdm_cfg0 |= DSI_28nm_PHY_PLL_SDM_CFG0_BYP_DIV(0);\r\nsdm_cfg1 |= DSI_28nm_PHY_PLL_SDM_CFG1_DC_OFFSET(\r\n(u32)(((div_fbx1000 / 1000) & 0x3f) - 1));\r\nsdm_cfg3 = frac_n_value >> 8;\r\nsdm_cfg2 = frac_n_value & 0xff;\r\n} else {\r\nsdm_cfg0 = DSI_28nm_PHY_PLL_SDM_CFG0_BYP;\r\nsdm_cfg0 |= DSI_28nm_PHY_PLL_SDM_CFG0_BYP_DIV(\r\n(u32)(((div_fbx1000 / 1000) & 0x3f) - 1));\r\nsdm_cfg1 |= DSI_28nm_PHY_PLL_SDM_CFG1_DC_OFFSET(0);\r\nsdm_cfg2 = 0;\r\nsdm_cfg3 = 0;\r\n}\r\nDBG("sdm_cfg0=%d", sdm_cfg0);\r\nDBG("sdm_cfg1=%d", sdm_cfg1);\r\nDBG("sdm_cfg2=%d", sdm_cfg2);\r\nDBG("sdm_cfg3=%d", sdm_cfg3);\r\ncal_cfg11 = (u32)(gen_vco_clk / (256 * 1000000));\r\ncal_cfg10 = (u32)((gen_vco_clk % (256 * 1000000)) / 1000000);\r\nDBG("cal_cfg10=%d, cal_cfg11=%d", cal_cfg10, cal_cfg11);\r\npll_write(base + REG_DSI_28nm_PHY_PLL_CHGPUMP_CFG, 0x02);\r\npll_write(base + REG_DSI_28nm_PHY_PLL_CAL_CFG3, 0x2b);\r\npll_write(base + REG_DSI_28nm_PHY_PLL_CAL_CFG4, 0x06);\r\npll_write(base + REG_DSI_28nm_PHY_PLL_LKDET_CFG2, 0x0d);\r\npll_write(base + REG_DSI_28nm_PHY_PLL_SDM_CFG1, sdm_cfg1);\r\npll_write(base + REG_DSI_28nm_PHY_PLL_SDM_CFG2,\r\nDSI_28nm_PHY_PLL_SDM_CFG2_FREQ_SEED_7_0(sdm_cfg2));\r\npll_write(base + REG_DSI_28nm_PHY_PLL_SDM_CFG3,\r\nDSI_28nm_PHY_PLL_SDM_CFG3_FREQ_SEED_15_8(sdm_cfg3));\r\npll_write(base + REG_DSI_28nm_PHY_PLL_SDM_CFG4, 0x00);\r\nif (pll_28nm->vco_delay)\r\nudelay(pll_28nm->vco_delay);\r\npll_write(base + REG_DSI_28nm_PHY_PLL_REFCLK_CFG, refclk_cfg);\r\npll_write(base + REG_DSI_28nm_PHY_PLL_PWRGEN_CFG, 0x00);\r\npll_write(base + REG_DSI_28nm_PHY_PLL_VCOLPF_CFG, 0x31);\r\npll_write(base + REG_DSI_28nm_PHY_PLL_SDM_CFG0, sdm_cfg0);\r\npll_write(base + REG_DSI_28nm_PHY_PLL_CAL_CFG0, 0x12);\r\npll_write(base + REG_DSI_28nm_PHY_PLL_CAL_CFG6, 0x30);\r\npll_write(base + REG_DSI_28nm_PHY_PLL_CAL_CFG7, 0x00);\r\npll_write(base + REG_DSI_28nm_PHY_PLL_CAL_CFG8, 0x60);\r\npll_write(base + REG_DSI_28nm_PHY_PLL_CAL_CFG9, 0x00);\r\npll_write(base + REG_DSI_28nm_PHY_PLL_CAL_CFG10, cal_cfg10 & 0xff);\r\npll_write(base + REG_DSI_28nm_PHY_PLL_CAL_CFG11, cal_cfg11 & 0xff);\r\npll_write(base + REG_DSI_28nm_PHY_PLL_EFUSE_CFG, 0x20);\r\nreturn 0;\r\n}\r\nstatic int dsi_pll_28nm_clk_is_enabled(struct clk_hw *hw)\r\n{\r\nstruct msm_dsi_pll *pll = hw_clk_to_pll(hw);\r\nstruct dsi_pll_28nm *pll_28nm = to_pll_28nm(pll);\r\nreturn pll_28nm_poll_for_ready(pll_28nm, POLL_MAX_READS,\r\nPOLL_TIMEOUT_US);\r\n}\r\nstatic unsigned long dsi_pll_28nm_clk_recalc_rate(struct clk_hw *hw,\r\nunsigned long parent_rate)\r\n{\r\nstruct msm_dsi_pll *pll = hw_clk_to_pll(hw);\r\nstruct dsi_pll_28nm *pll_28nm = to_pll_28nm(pll);\r\nvoid __iomem *base = pll_28nm->mmio;\r\nu32 sdm0, doubler, sdm_byp_div;\r\nu32 sdm_dc_off, sdm_freq_seed, sdm2, sdm3;\r\nu32 ref_clk = VCO_REF_CLK_RATE;\r\nunsigned long vco_rate;\r\nVERB("parent_rate=%lu", parent_rate);\r\ndoubler = pll_read(base + REG_DSI_28nm_PHY_PLL_REFCLK_CFG) &\r\nDSI_28nm_PHY_PLL_REFCLK_CFG_DBLR;\r\nref_clk += (doubler * VCO_REF_CLK_RATE);\r\nsdm0 = pll_read(base + REG_DSI_28nm_PHY_PLL_SDM_CFG0);\r\nif (sdm0 & DSI_28nm_PHY_PLL_SDM_CFG0_BYP) {\r\nsdm_byp_div = FIELD(\r\npll_read(base + REG_DSI_28nm_PHY_PLL_SDM_CFG0),\r\nDSI_28nm_PHY_PLL_SDM_CFG0_BYP_DIV) + 1;\r\nvco_rate = ref_clk * sdm_byp_div;\r\n} else {\r\nsdm_dc_off = FIELD(\r\npll_read(base + REG_DSI_28nm_PHY_PLL_SDM_CFG1),\r\nDSI_28nm_PHY_PLL_SDM_CFG1_DC_OFFSET);\r\nDBG("sdm_dc_off = %d", sdm_dc_off);\r\nsdm2 = FIELD(pll_read(base + REG_DSI_28nm_PHY_PLL_SDM_CFG2),\r\nDSI_28nm_PHY_PLL_SDM_CFG2_FREQ_SEED_7_0);\r\nsdm3 = FIELD(pll_read(base + REG_DSI_28nm_PHY_PLL_SDM_CFG3),\r\nDSI_28nm_PHY_PLL_SDM_CFG3_FREQ_SEED_15_8);\r\nsdm_freq_seed = (sdm3 << 8) | sdm2;\r\nDBG("sdm_freq_seed = %d", sdm_freq_seed);\r\nvco_rate = (ref_clk * (sdm_dc_off + 1)) +\r\nmult_frac(ref_clk, sdm_freq_seed, BIT(16));\r\nDBG("vco rate = %lu", vco_rate);\r\n}\r\nDBG("returning vco rate = %lu", vco_rate);\r\nreturn vco_rate;\r\n}\r\nstatic int dsi_pll_28nm_enable_seq_hpm(struct msm_dsi_pll *pll)\r\n{\r\nstruct dsi_pll_28nm *pll_28nm = to_pll_28nm(pll);\r\nstruct device *dev = &pll_28nm->pdev->dev;\r\nvoid __iomem *base = pll_28nm->mmio;\r\nu32 max_reads = 5, timeout_us = 100;\r\nbool locked;\r\nu32 val;\r\nint i;\r\nDBG("id=%d", pll_28nm->id);\r\npll_28nm_software_reset(pll_28nm);\r\nval = DSI_28nm_PHY_PLL_GLB_CFG_PLL_PWRDN_B;\r\npll_write_udelay(base + REG_DSI_28nm_PHY_PLL_GLB_CFG, val, 1);\r\nval |= DSI_28nm_PHY_PLL_GLB_CFG_PLL_PWRGEN_PWRDN_B;\r\npll_write_udelay(base + REG_DSI_28nm_PHY_PLL_GLB_CFG, val, 200);\r\nval |= DSI_28nm_PHY_PLL_GLB_CFG_PLL_LDO_PWRDN_B;\r\npll_write_udelay(base + REG_DSI_28nm_PHY_PLL_GLB_CFG, val, 500);\r\nval |= DSI_28nm_PHY_PLL_GLB_CFG_PLL_ENABLE;\r\npll_write_udelay(base + REG_DSI_28nm_PHY_PLL_GLB_CFG, val, 600);\r\nfor (i = 0; i < 2; i++) {\r\npll_write_udelay(base + REG_DSI_28nm_PHY_PLL_LKDET_CFG2,\r\n0x0c, 100);\r\npll_write(base + REG_DSI_28nm_PHY_PLL_LKDET_CFG2, 0x0d);\r\nlocked = pll_28nm_poll_for_ready(pll_28nm,\r\nmax_reads, timeout_us);\r\nif (locked)\r\nbreak;\r\npll_28nm_software_reset(pll_28nm);\r\nval = DSI_28nm_PHY_PLL_GLB_CFG_PLL_PWRDN_B;\r\npll_write_udelay(base + REG_DSI_28nm_PHY_PLL_GLB_CFG, val, 1);\r\nval |= DSI_28nm_PHY_PLL_GLB_CFG_PLL_PWRGEN_PWRDN_B;\r\npll_write_udelay(base + REG_DSI_28nm_PHY_PLL_GLB_CFG, val, 200);\r\nval |= DSI_28nm_PHY_PLL_GLB_CFG_PLL_LDO_PWRDN_B;\r\npll_write_udelay(base + REG_DSI_28nm_PHY_PLL_GLB_CFG, val, 250);\r\nval &= ~DSI_28nm_PHY_PLL_GLB_CFG_PLL_LDO_PWRDN_B;\r\npll_write_udelay(base + REG_DSI_28nm_PHY_PLL_GLB_CFG, val, 200);\r\nval |= DSI_28nm_PHY_PLL_GLB_CFG_PLL_LDO_PWRDN_B;\r\npll_write_udelay(base + REG_DSI_28nm_PHY_PLL_GLB_CFG, val, 500);\r\nval |= DSI_28nm_PHY_PLL_GLB_CFG_PLL_ENABLE;\r\npll_write_udelay(base + REG_DSI_28nm_PHY_PLL_GLB_CFG, val, 600);\r\n}\r\nif (unlikely(!locked))\r\ndev_err(dev, "DSI PLL lock failed\n");\r\nelse\r\nDBG("DSI PLL Lock success");\r\nreturn locked ? 0 : -EINVAL;\r\n}\r\nstatic int dsi_pll_28nm_enable_seq_lp(struct msm_dsi_pll *pll)\r\n{\r\nstruct dsi_pll_28nm *pll_28nm = to_pll_28nm(pll);\r\nstruct device *dev = &pll_28nm->pdev->dev;\r\nvoid __iomem *base = pll_28nm->mmio;\r\nbool locked;\r\nu32 max_reads = 10, timeout_us = 50;\r\nu32 val;\r\nDBG("id=%d", pll_28nm->id);\r\npll_28nm_software_reset(pll_28nm);\r\npll_write_ndelay(base + REG_DSI_28nm_PHY_PLL_CAL_CFG1, 0x34, 500);\r\nval = DSI_28nm_PHY_PLL_GLB_CFG_PLL_PWRDN_B;\r\npll_write_ndelay(base + REG_DSI_28nm_PHY_PLL_GLB_CFG, val, 500);\r\nval |= DSI_28nm_PHY_PLL_GLB_CFG_PLL_PWRGEN_PWRDN_B;\r\npll_write_ndelay(base + REG_DSI_28nm_PHY_PLL_GLB_CFG, val, 500);\r\nval |= DSI_28nm_PHY_PLL_GLB_CFG_PLL_LDO_PWRDN_B |\r\nDSI_28nm_PHY_PLL_GLB_CFG_PLL_ENABLE;\r\npll_write_ndelay(base + REG_DSI_28nm_PHY_PLL_GLB_CFG, val, 500);\r\npll_write_ndelay(base + REG_DSI_28nm_PHY_PLL_LKDET_CFG2, 0x04, 500);\r\npll_write_udelay(base + REG_DSI_28nm_PHY_PLL_LKDET_CFG2, 0x05, 512);\r\nlocked = pll_28nm_poll_for_ready(pll_28nm, max_reads, timeout_us);\r\nif (unlikely(!locked))\r\ndev_err(dev, "DSI PLL lock failed\n");\r\nelse\r\nDBG("DSI PLL lock success");\r\nreturn locked ? 0 : -EINVAL;\r\n}\r\nstatic void dsi_pll_28nm_disable_seq(struct msm_dsi_pll *pll)\r\n{\r\nstruct dsi_pll_28nm *pll_28nm = to_pll_28nm(pll);\r\nDBG("id=%d", pll_28nm->id);\r\npll_write(pll_28nm->mmio + REG_DSI_28nm_PHY_PLL_GLB_CFG, 0x00);\r\n}\r\nstatic void dsi_pll_28nm_save_state(struct msm_dsi_pll *pll)\r\n{\r\nstruct dsi_pll_28nm *pll_28nm = to_pll_28nm(pll);\r\nstruct pll_28nm_cached_state *cached_state = &pll_28nm->cached_state;\r\nvoid __iomem *base = pll_28nm->mmio;\r\ncached_state->postdiv3 =\r\npll_read(base + REG_DSI_28nm_PHY_PLL_POSTDIV3_CFG);\r\ncached_state->postdiv1 =\r\npll_read(base + REG_DSI_28nm_PHY_PLL_POSTDIV1_CFG);\r\ncached_state->byte_mux = pll_read(base + REG_DSI_28nm_PHY_PLL_VREG_CFG);\r\ncached_state->vco_rate = clk_hw_get_rate(&pll->clk_hw);\r\n}\r\nstatic int dsi_pll_28nm_restore_state(struct msm_dsi_pll *pll)\r\n{\r\nstruct dsi_pll_28nm *pll_28nm = to_pll_28nm(pll);\r\nstruct pll_28nm_cached_state *cached_state = &pll_28nm->cached_state;\r\nvoid __iomem *base = pll_28nm->mmio;\r\nint ret;\r\nret = dsi_pll_28nm_clk_set_rate(&pll->clk_hw,\r\ncached_state->vco_rate, 0);\r\nif (ret) {\r\ndev_err(&pll_28nm->pdev->dev,\r\n"restore vco rate failed. ret=%d\n", ret);\r\nreturn ret;\r\n}\r\npll_write(base + REG_DSI_28nm_PHY_PLL_POSTDIV3_CFG,\r\ncached_state->postdiv3);\r\npll_write(base + REG_DSI_28nm_PHY_PLL_POSTDIV1_CFG,\r\ncached_state->postdiv1);\r\npll_write(base + REG_DSI_28nm_PHY_PLL_VREG_CFG,\r\ncached_state->byte_mux);\r\nreturn 0;\r\n}\r\nstatic int dsi_pll_28nm_get_provider(struct msm_dsi_pll *pll,\r\nstruct clk **byte_clk_provider,\r\nstruct clk **pixel_clk_provider)\r\n{\r\nstruct dsi_pll_28nm *pll_28nm = to_pll_28nm(pll);\r\nif (byte_clk_provider)\r\n*byte_clk_provider = pll_28nm->provided_clks[DSI_BYTE_PLL_CLK];\r\nif (pixel_clk_provider)\r\n*pixel_clk_provider =\r\npll_28nm->provided_clks[DSI_PIXEL_PLL_CLK];\r\nreturn 0;\r\n}\r\nstatic void dsi_pll_28nm_destroy(struct msm_dsi_pll *pll)\r\n{\r\nstruct dsi_pll_28nm *pll_28nm = to_pll_28nm(pll);\r\nint i;\r\nmsm_dsi_pll_helper_unregister_clks(pll_28nm->pdev,\r\npll_28nm->clks, pll_28nm->num_clks);\r\nfor (i = 0; i < NUM_PROVIDED_CLKS; i++)\r\npll_28nm->provided_clks[i] = NULL;\r\npll_28nm->num_clks = 0;\r\npll_28nm->clk_data.clks = NULL;\r\npll_28nm->clk_data.clk_num = 0;\r\n}\r\nstatic int pll_28nm_register(struct dsi_pll_28nm *pll_28nm)\r\n{\r\nchar clk_name[32], parent1[32], parent2[32], vco_name[32];\r\nstruct clk_init_data vco_init = {\r\n.parent_names = (const char *[]){ "xo" },\r\n.num_parents = 1,\r\n.name = vco_name,\r\n.ops = &clk_ops_dsi_pll_28nm_vco,\r\n};\r\nstruct device *dev = &pll_28nm->pdev->dev;\r\nstruct clk **clks = pll_28nm->clks;\r\nstruct clk **provided_clks = pll_28nm->provided_clks;\r\nint num = 0;\r\nint ret;\r\nDBG("%d", pll_28nm->id);\r\nsnprintf(vco_name, 32, "dsi%dvco_clk", pll_28nm->id);\r\npll_28nm->base.clk_hw.init = &vco_init;\r\nclks[num++] = clk_register(dev, &pll_28nm->base.clk_hw);\r\nsnprintf(clk_name, 32, "dsi%danalog_postdiv_clk", pll_28nm->id);\r\nsnprintf(parent1, 32, "dsi%dvco_clk", pll_28nm->id);\r\nclks[num++] = clk_register_divider(dev, clk_name,\r\nparent1, CLK_SET_RATE_PARENT,\r\npll_28nm->mmio +\r\nREG_DSI_28nm_PHY_PLL_POSTDIV1_CFG,\r\n0, 4, 0, NULL);\r\nsnprintf(clk_name, 32, "dsi%dindirect_path_div2_clk", pll_28nm->id);\r\nsnprintf(parent1, 32, "dsi%danalog_postdiv_clk", pll_28nm->id);\r\nclks[num++] = clk_register_fixed_factor(dev, clk_name,\r\nparent1, CLK_SET_RATE_PARENT,\r\n1, 2);\r\nsnprintf(clk_name, 32, "dsi%dpll", pll_28nm->id);\r\nsnprintf(parent1, 32, "dsi%dvco_clk", pll_28nm->id);\r\nclks[num++] = provided_clks[DSI_PIXEL_PLL_CLK] =\r\nclk_register_divider(dev, clk_name,\r\nparent1, 0, pll_28nm->mmio +\r\nREG_DSI_28nm_PHY_PLL_POSTDIV3_CFG,\r\n0, 8, 0, NULL);\r\nsnprintf(clk_name, 32, "dsi%dbyte_mux", pll_28nm->id);\r\nsnprintf(parent1, 32, "dsi%dvco_clk", pll_28nm->id);\r\nsnprintf(parent2, 32, "dsi%dindirect_path_div2_clk", pll_28nm->id);\r\nclks[num++] = clk_register_mux(dev, clk_name,\r\n(const char *[]){\r\nparent1, parent2\r\n}, 2, CLK_SET_RATE_PARENT, pll_28nm->mmio +\r\nREG_DSI_28nm_PHY_PLL_VREG_CFG, 1, 1, 0, NULL);\r\nsnprintf(clk_name, 32, "dsi%dpllbyte", pll_28nm->id);\r\nsnprintf(parent1, 32, "dsi%dbyte_mux", pll_28nm->id);\r\nclks[num++] = provided_clks[DSI_BYTE_PLL_CLK] =\r\nclk_register_fixed_factor(dev, clk_name,\r\nparent1, CLK_SET_RATE_PARENT, 1, 4);\r\npll_28nm->num_clks = num;\r\npll_28nm->clk_data.clk_num = NUM_PROVIDED_CLKS;\r\npll_28nm->clk_data.clks = provided_clks;\r\nret = of_clk_add_provider(dev->of_node,\r\nof_clk_src_onecell_get, &pll_28nm->clk_data);\r\nif (ret) {\r\ndev_err(dev, "failed to register clk provider: %d\n", ret);\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstruct msm_dsi_pll *msm_dsi_pll_28nm_init(struct platform_device *pdev,\r\nenum msm_dsi_phy_type type, int id)\r\n{\r\nstruct dsi_pll_28nm *pll_28nm;\r\nstruct msm_dsi_pll *pll;\r\nint ret;\r\nif (!pdev)\r\nreturn ERR_PTR(-ENODEV);\r\npll_28nm = devm_kzalloc(&pdev->dev, sizeof(*pll_28nm), GFP_KERNEL);\r\nif (!pll_28nm)\r\nreturn ERR_PTR(-ENOMEM);\r\npll_28nm->pdev = pdev;\r\npll_28nm->id = id;\r\npll_28nm->mmio = msm_ioremap(pdev, "dsi_pll", "DSI_PLL");\r\nif (IS_ERR_OR_NULL(pll_28nm->mmio)) {\r\ndev_err(&pdev->dev, "%s: failed to map pll base\n", __func__);\r\nreturn ERR_PTR(-ENOMEM);\r\n}\r\npll = &pll_28nm->base;\r\npll->min_rate = VCO_MIN_RATE;\r\npll->max_rate = VCO_MAX_RATE;\r\npll->get_provider = dsi_pll_28nm_get_provider;\r\npll->destroy = dsi_pll_28nm_destroy;\r\npll->disable_seq = dsi_pll_28nm_disable_seq;\r\npll->save_state = dsi_pll_28nm_save_state;\r\npll->restore_state = dsi_pll_28nm_restore_state;\r\nif (type == MSM_DSI_PHY_28NM_HPM) {\r\npll_28nm->vco_delay = 1;\r\npll->en_seq_cnt = 3;\r\npll->enable_seqs[0] = dsi_pll_28nm_enable_seq_hpm;\r\npll->enable_seqs[1] = dsi_pll_28nm_enable_seq_hpm;\r\npll->enable_seqs[2] = dsi_pll_28nm_enable_seq_hpm;\r\n} else if (type == MSM_DSI_PHY_28NM_LP) {\r\npll_28nm->vco_delay = 1000;\r\npll->en_seq_cnt = 1;\r\npll->enable_seqs[0] = dsi_pll_28nm_enable_seq_lp;\r\n} else {\r\ndev_err(&pdev->dev, "phy type (%d) is not 28nm\n", type);\r\nreturn ERR_PTR(-EINVAL);\r\n}\r\nret = pll_28nm_register(pll_28nm);\r\nif (ret) {\r\ndev_err(&pdev->dev, "failed to register PLL: %d\n", ret);\r\nreturn ERR_PTR(ret);\r\n}\r\nreturn pll;\r\n}
