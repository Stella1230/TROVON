static inline struct f_midi *func_to_midi(struct usb_function *f)\r\n{\r\nreturn container_of(f, struct f_midi, func);\r\n}\r\nstatic inline struct usb_request *midi_alloc_ep_req(struct usb_ep *ep,\r\nunsigned length)\r\n{\r\nreturn alloc_ep_req(ep, length, length);\r\n}\r\nstatic void f_midi_read_data(struct usb_ep *ep, int cable,\r\nuint8_t *data, int length)\r\n{\r\nstruct f_midi *midi = ep->driver_data;\r\nstruct snd_rawmidi_substream *substream = midi->out_substream[cable];\r\nif (!substream)\r\nreturn;\r\nif (!test_bit(cable, &midi->out_triggered))\r\nreturn;\r\nsnd_rawmidi_receive(substream, data, length);\r\n}\r\nstatic void f_midi_handle_out_data(struct usb_ep *ep, struct usb_request *req)\r\n{\r\nunsigned int i;\r\nu8 *buf = req->buf;\r\nfor (i = 0; i + 3 < req->actual; i += 4)\r\nif (buf[i] != 0) {\r\nint cable = buf[i] >> 4;\r\nint length = f_midi_cin_length[buf[i] & 0x0f];\r\nf_midi_read_data(ep, cable, &buf[i + 1], length);\r\n}\r\n}\r\nstatic void\r\nf_midi_complete(struct usb_ep *ep, struct usb_request *req)\r\n{\r\nstruct f_midi *midi = ep->driver_data;\r\nstruct usb_composite_dev *cdev = midi->func.config->cdev;\r\nint status = req->status;\r\nswitch (status) {\r\ncase 0:\r\nif (ep == midi->out_ep) {\r\nf_midi_handle_out_data(ep, req);\r\n} else if (ep == midi->in_ep) {\r\nreq->length = 0;\r\nf_midi_transmit(midi);\r\nreturn;\r\n}\r\nbreak;\r\ncase -ECONNABORTED:\r\ncase -ECONNRESET:\r\ncase -ESHUTDOWN:\r\nVDBG(cdev, "%s gone (%d), %d/%d\n", ep->name, status,\r\nreq->actual, req->length);\r\nif (ep == midi->out_ep) {\r\nf_midi_handle_out_data(ep, req);\r\nfree_ep_req(ep, req);\r\n}\r\nreturn;\r\ncase -EOVERFLOW:\r\ndefault:\r\nDBG(cdev, "%s complete --> %d, %d/%d\n", ep->name,\r\nstatus, req->actual, req->length);\r\nbreak;\r\ncase -EREMOTEIO:\r\nbreak;\r\n}\r\nstatus = usb_ep_queue(ep, req, GFP_ATOMIC);\r\nif (status) {\r\nERROR(cdev, "kill %s: resubmit %d bytes --> %d\n",\r\nep->name, req->length, status);\r\nusb_ep_set_halt(ep);\r\n}\r\n}\r\nstatic int f_midi_start_ep(struct f_midi *midi,\r\nstruct usb_function *f,\r\nstruct usb_ep *ep)\r\n{\r\nint err;\r\nstruct usb_composite_dev *cdev = f->config->cdev;\r\nusb_ep_disable(ep);\r\nerr = config_ep_by_speed(midi->gadget, f, ep);\r\nif (err) {\r\nERROR(cdev, "can't configure %s: %d\n", ep->name, err);\r\nreturn err;\r\n}\r\nerr = usb_ep_enable(ep);\r\nif (err) {\r\nERROR(cdev, "can't start %s: %d\n", ep->name, err);\r\nreturn err;\r\n}\r\nep->driver_data = midi;\r\nreturn 0;\r\n}\r\nstatic int f_midi_set_alt(struct usb_function *f, unsigned intf, unsigned alt)\r\n{\r\nstruct f_midi *midi = func_to_midi(f);\r\nunsigned i;\r\nint err;\r\nif (intf != midi->ms_id)\r\nreturn 0;\r\nerr = f_midi_start_ep(midi, f, midi->in_ep);\r\nif (err)\r\nreturn err;\r\nerr = f_midi_start_ep(midi, f, midi->out_ep);\r\nif (err)\r\nreturn err;\r\nwhile (kfifo_avail(&midi->in_req_fifo)) {\r\nstruct usb_request *req =\r\nmidi_alloc_ep_req(midi->in_ep, midi->buflen);\r\nif (req == NULL)\r\nreturn -ENOMEM;\r\nreq->length = 0;\r\nreq->complete = f_midi_complete;\r\nkfifo_put(&midi->in_req_fifo, req);\r\n}\r\nfor (i = 0; i < midi->qlen && err == 0; i++) {\r\nstruct usb_request *req =\r\nmidi_alloc_ep_req(midi->out_ep,\r\nmax_t(unsigned, midi->buflen,\r\nbulk_out_desc.wMaxPacketSize));\r\nif (req == NULL)\r\nreturn -ENOMEM;\r\nreq->complete = f_midi_complete;\r\nerr = usb_ep_queue(midi->out_ep, req, GFP_ATOMIC);\r\nif (err) {\r\nERROR(midi, "%s: couldn't enqueue request: %d\n",\r\nmidi->out_ep->name, err);\r\nfree_ep_req(midi->out_ep, req);\r\nreturn err;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic void f_midi_disable(struct usb_function *f)\r\n{\r\nstruct f_midi *midi = func_to_midi(f);\r\nstruct usb_composite_dev *cdev = f->config->cdev;\r\nstruct usb_request *req = NULL;\r\nDBG(cdev, "disable\n");\r\nusb_ep_disable(midi->in_ep);\r\nusb_ep_disable(midi->out_ep);\r\nwhile (kfifo_get(&midi->in_req_fifo, &req))\r\nfree_ep_req(midi->in_ep, req);\r\n}\r\nstatic int f_midi_snd_free(struct snd_device *device)\r\n{\r\nreturn 0;\r\n}\r\nstatic void f_midi_transmit_packet(struct usb_request *req, uint8_t p0,\r\nuint8_t p1, uint8_t p2, uint8_t p3)\r\n{\r\nunsigned length = req->length;\r\nu8 *buf = (u8 *)req->buf + length;\r\nbuf[0] = p0;\r\nbuf[1] = p1;\r\nbuf[2] = p2;\r\nbuf[3] = p3;\r\nreq->length = length + 4;\r\n}\r\nstatic void f_midi_transmit_byte(struct usb_request *req,\r\nstruct gmidi_in_port *port, uint8_t b)\r\n{\r\nuint8_t p0 = port->cable << 4;\r\nif (b >= 0xf8) {\r\nf_midi_transmit_packet(req, p0 | 0x0f, b, 0, 0);\r\n} else if (b >= 0xf0) {\r\nswitch (b) {\r\ncase 0xf0:\r\nport->data[0] = b;\r\nport->state = STATE_SYSEX_1;\r\nbreak;\r\ncase 0xf1:\r\ncase 0xf3:\r\nport->data[0] = b;\r\nport->state = STATE_1PARAM;\r\nbreak;\r\ncase 0xf2:\r\nport->data[0] = b;\r\nport->state = STATE_2PARAM_1;\r\nbreak;\r\ncase 0xf4:\r\ncase 0xf5:\r\nport->state = STATE_UNKNOWN;\r\nbreak;\r\ncase 0xf6:\r\nf_midi_transmit_packet(req, p0 | 0x05, 0xf6, 0, 0);\r\nport->state = STATE_UNKNOWN;\r\nbreak;\r\ncase 0xf7:\r\nswitch (port->state) {\r\ncase STATE_SYSEX_0:\r\nf_midi_transmit_packet(req,\r\np0 | 0x05, 0xf7, 0, 0);\r\nbreak;\r\ncase STATE_SYSEX_1:\r\nf_midi_transmit_packet(req,\r\np0 | 0x06, port->data[0], 0xf7, 0);\r\nbreak;\r\ncase STATE_SYSEX_2:\r\nf_midi_transmit_packet(req,\r\np0 | 0x07, port->data[0],\r\nport->data[1], 0xf7);\r\nbreak;\r\n}\r\nport->state = STATE_UNKNOWN;\r\nbreak;\r\n}\r\n} else if (b >= 0x80) {\r\nport->data[0] = b;\r\nif (b >= 0xc0 && b <= 0xdf)\r\nport->state = STATE_1PARAM;\r\nelse\r\nport->state = STATE_2PARAM_1;\r\n} else {\r\nswitch (port->state) {\r\ncase STATE_1PARAM:\r\nif (port->data[0] < 0xf0) {\r\np0 |= port->data[0] >> 4;\r\n} else {\r\np0 |= 0x02;\r\nport->state = STATE_UNKNOWN;\r\n}\r\nf_midi_transmit_packet(req, p0, port->data[0], b, 0);\r\nbreak;\r\ncase STATE_2PARAM_1:\r\nport->data[1] = b;\r\nport->state = STATE_2PARAM_2;\r\nbreak;\r\ncase STATE_2PARAM_2:\r\nif (port->data[0] < 0xf0) {\r\np0 |= port->data[0] >> 4;\r\nport->state = STATE_2PARAM_1;\r\n} else {\r\np0 |= 0x03;\r\nport->state = STATE_UNKNOWN;\r\n}\r\nf_midi_transmit_packet(req,\r\np0, port->data[0], port->data[1], b);\r\nbreak;\r\ncase STATE_SYSEX_0:\r\nport->data[0] = b;\r\nport->state = STATE_SYSEX_1;\r\nbreak;\r\ncase STATE_SYSEX_1:\r\nport->data[1] = b;\r\nport->state = STATE_SYSEX_2;\r\nbreak;\r\ncase STATE_SYSEX_2:\r\nf_midi_transmit_packet(req,\r\np0 | 0x04, port->data[0], port->data[1], b);\r\nport->state = STATE_SYSEX_0;\r\nbreak;\r\n}\r\n}\r\n}\r\nstatic void f_midi_drop_out_substreams(struct f_midi *midi)\r\n{\r\nunsigned int i;\r\nfor (i = 0; i < midi->in_ports; i++) {\r\nstruct gmidi_in_port *port = midi->in_ports_array + i;\r\nstruct snd_rawmidi_substream *substream = port->substream;\r\nif (port->active && substream)\r\nsnd_rawmidi_drop_output(substream);\r\n}\r\n}\r\nstatic int f_midi_do_transmit(struct f_midi *midi, struct usb_ep *ep)\r\n{\r\nstruct usb_request *req = NULL;\r\nunsigned int len, i;\r\nbool active = false;\r\nint err;\r\nlen = kfifo_peek(&midi->in_req_fifo, &req);\r\nif (len != 1) {\r\nERROR(midi, "%s: Couldn't get usb request\n", __func__);\r\nreturn -1;\r\n}\r\nif (req->length > 0)\r\nreturn 0;\r\nfor (i = midi->in_last_port; i < midi->in_ports; ++i) {\r\nstruct gmidi_in_port *port = midi->in_ports_array + i;\r\nstruct snd_rawmidi_substream *substream = port->substream;\r\nif (!port->active || !substream)\r\ncontinue;\r\nwhile (req->length + 3 < midi->buflen) {\r\nuint8_t b;\r\nif (snd_rawmidi_transmit(substream, &b, 1) != 1) {\r\nport->active = 0;\r\nbreak;\r\n}\r\nf_midi_transmit_byte(req, port, b);\r\n}\r\nactive = !!port->active;\r\nif (active)\r\nbreak;\r\n}\r\nmidi->in_last_port = active ? i : 0;\r\nif (req->length <= 0)\r\ngoto done;\r\nerr = usb_ep_queue(ep, req, GFP_ATOMIC);\r\nif (err < 0) {\r\nERROR(midi, "%s failed to queue req: %d\n",\r\nmidi->in_ep->name, err);\r\nreq->length = 0;\r\n} else {\r\nkfifo_skip(&midi->in_req_fifo);\r\nkfifo_put(&midi->in_req_fifo, req);\r\n}\r\ndone:\r\nreturn active;\r\n}\r\nstatic void f_midi_transmit(struct f_midi *midi)\r\n{\r\nstruct usb_ep *ep = midi->in_ep;\r\nint ret;\r\nunsigned long flags;\r\nif (!ep || !ep->enabled)\r\ngoto drop_out;\r\nspin_lock_irqsave(&midi->transmit_lock, flags);\r\ndo {\r\nret = f_midi_do_transmit(midi, ep);\r\nif (ret < 0) {\r\nspin_unlock_irqrestore(&midi->transmit_lock, flags);\r\ngoto drop_out;\r\n}\r\n} while (ret);\r\nspin_unlock_irqrestore(&midi->transmit_lock, flags);\r\nreturn;\r\ndrop_out:\r\nf_midi_drop_out_substreams(midi);\r\n}\r\nstatic void f_midi_in_tasklet(unsigned long data)\r\n{\r\nstruct f_midi *midi = (struct f_midi *) data;\r\nf_midi_transmit(midi);\r\n}\r\nstatic int f_midi_in_open(struct snd_rawmidi_substream *substream)\r\n{\r\nstruct f_midi *midi = substream->rmidi->private_data;\r\nstruct gmidi_in_port *port;\r\nif (substream->number >= midi->in_ports)\r\nreturn -EINVAL;\r\nVDBG(midi, "%s()\n", __func__);\r\nport = midi->in_ports_array + substream->number;\r\nport->substream = substream;\r\nport->state = STATE_UNKNOWN;\r\nreturn 0;\r\n}\r\nstatic int f_midi_in_close(struct snd_rawmidi_substream *substream)\r\n{\r\nstruct f_midi *midi = substream->rmidi->private_data;\r\nVDBG(midi, "%s()\n", __func__);\r\nreturn 0;\r\n}\r\nstatic void f_midi_in_trigger(struct snd_rawmidi_substream *substream, int up)\r\n{\r\nstruct f_midi *midi = substream->rmidi->private_data;\r\nif (substream->number >= midi->in_ports)\r\nreturn;\r\nVDBG(midi, "%s() %d\n", __func__, up);\r\nmidi->in_ports_array[substream->number].active = up;\r\nif (up)\r\ntasklet_hi_schedule(&midi->tasklet);\r\n}\r\nstatic int f_midi_out_open(struct snd_rawmidi_substream *substream)\r\n{\r\nstruct f_midi *midi = substream->rmidi->private_data;\r\nif (substream->number >= MAX_PORTS)\r\nreturn -EINVAL;\r\nVDBG(midi, "%s()\n", __func__);\r\nmidi->out_substream[substream->number] = substream;\r\nreturn 0;\r\n}\r\nstatic int f_midi_out_close(struct snd_rawmidi_substream *substream)\r\n{\r\nstruct f_midi *midi = substream->rmidi->private_data;\r\nVDBG(midi, "%s()\n", __func__);\r\nreturn 0;\r\n}\r\nstatic void f_midi_out_trigger(struct snd_rawmidi_substream *substream, int up)\r\n{\r\nstruct f_midi *midi = substream->rmidi->private_data;\r\nVDBG(midi, "%s()\n", __func__);\r\nif (up)\r\nset_bit(substream->number, &midi->out_triggered);\r\nelse\r\nclear_bit(substream->number, &midi->out_triggered);\r\n}\r\nstatic inline void f_midi_unregister_card(struct f_midi *midi)\r\n{\r\nif (midi->card) {\r\nsnd_card_free(midi->card);\r\nmidi->card = NULL;\r\n}\r\n}\r\nstatic int f_midi_register_card(struct f_midi *midi)\r\n{\r\nstruct snd_card *card;\r\nstruct snd_rawmidi *rmidi;\r\nint err;\r\nstatic struct snd_device_ops ops = {\r\n.dev_free = f_midi_snd_free,\r\n};\r\nerr = snd_card_new(&midi->gadget->dev, midi->index, midi->id,\r\nTHIS_MODULE, 0, &card);\r\nif (err < 0) {\r\nERROR(midi, "snd_card_new() failed\n");\r\ngoto fail;\r\n}\r\nmidi->card = card;\r\nerr = snd_device_new(card, SNDRV_DEV_LOWLEVEL, midi, &ops);\r\nif (err < 0) {\r\nERROR(midi, "snd_device_new() failed: error %d\n", err);\r\ngoto fail;\r\n}\r\nstrcpy(card->driver, f_midi_longname);\r\nstrcpy(card->longname, f_midi_longname);\r\nstrcpy(card->shortname, f_midi_shortname);\r\nsnd_component_add(card, "MIDI");\r\nerr = snd_rawmidi_new(card, card->longname, 0,\r\nmidi->out_ports, midi->in_ports, &rmidi);\r\nif (err < 0) {\r\nERROR(midi, "snd_rawmidi_new() failed: error %d\n", err);\r\ngoto fail;\r\n}\r\nmidi->rmidi = rmidi;\r\nmidi->in_last_port = 0;\r\nstrcpy(rmidi->name, card->shortname);\r\nrmidi->info_flags = SNDRV_RAWMIDI_INFO_OUTPUT |\r\nSNDRV_RAWMIDI_INFO_INPUT |\r\nSNDRV_RAWMIDI_INFO_DUPLEX;\r\nrmidi->private_data = midi;\r\nsnd_rawmidi_set_ops(rmidi, SNDRV_RAWMIDI_STREAM_OUTPUT, &gmidi_in_ops);\r\nsnd_rawmidi_set_ops(rmidi, SNDRV_RAWMIDI_STREAM_INPUT, &gmidi_out_ops);\r\nerr = snd_card_register(card);\r\nif (err < 0) {\r\nERROR(midi, "snd_card_register() failed\n");\r\ngoto fail;\r\n}\r\nVDBG(midi, "%s() finished ok\n", __func__);\r\nreturn 0;\r\nfail:\r\nf_midi_unregister_card(midi);\r\nreturn err;\r\n}\r\nstatic int f_midi_bind(struct usb_configuration *c, struct usb_function *f)\r\n{\r\nstruct usb_descriptor_header **midi_function;\r\nstruct usb_midi_in_jack_descriptor jack_in_ext_desc[MAX_PORTS];\r\nstruct usb_midi_in_jack_descriptor jack_in_emb_desc[MAX_PORTS];\r\nstruct usb_midi_out_jack_descriptor_1 jack_out_ext_desc[MAX_PORTS];\r\nstruct usb_midi_out_jack_descriptor_1 jack_out_emb_desc[MAX_PORTS];\r\nstruct usb_composite_dev *cdev = c->cdev;\r\nstruct f_midi *midi = func_to_midi(f);\r\nstruct usb_string *us;\r\nint status, n, jack = 1, i = 0;\r\nmidi->gadget = cdev->gadget;\r\ntasklet_init(&midi->tasklet, f_midi_in_tasklet, (unsigned long) midi);\r\nstatus = f_midi_register_card(midi);\r\nif (status < 0)\r\ngoto fail_register;\r\nus = usb_gstrings_attach(c->cdev, midi_strings,\r\nARRAY_SIZE(midi_string_defs));\r\nif (IS_ERR(us)) {\r\nstatus = PTR_ERR(us);\r\ngoto fail;\r\n}\r\nac_interface_desc.iInterface = us[STRING_FUNC_IDX].id;\r\nstatus = usb_interface_id(c, f);\r\nif (status < 0)\r\ngoto fail;\r\nac_interface_desc.bInterfaceNumber = status;\r\nstatus = usb_interface_id(c, f);\r\nif (status < 0)\r\ngoto fail;\r\nms_interface_desc.bInterfaceNumber = status;\r\nac_header_desc.baInterfaceNr[0] = status;\r\nmidi->ms_id = status;\r\nstatus = -ENODEV;\r\nmidi->in_ep = usb_ep_autoconfig(cdev->gadget, &bulk_in_desc);\r\nif (!midi->in_ep)\r\ngoto fail;\r\nmidi->out_ep = usb_ep_autoconfig(cdev->gadget, &bulk_out_desc);\r\nif (!midi->out_ep)\r\ngoto fail;\r\nmidi_function = kcalloc((MAX_PORTS * 4) + 9, sizeof(*midi_function),\r\nGFP_KERNEL);\r\nif (!midi_function) {\r\nstatus = -ENOMEM;\r\ngoto fail;\r\n}\r\nmidi_function[i++] = (struct usb_descriptor_header *) &ac_interface_desc;\r\nmidi_function[i++] = (struct usb_descriptor_header *) &ac_header_desc;\r\nmidi_function[i++] = (struct usb_descriptor_header *) &ms_interface_desc;\r\nn = USB_DT_MS_HEADER_SIZE\r\n+ (midi->in_ports + midi->out_ports) *\r\n(USB_DT_MIDI_IN_SIZE + USB_DT_MIDI_OUT_SIZE(1));\r\nms_header_desc.wTotalLength = cpu_to_le16(n);\r\nmidi_function[i++] = (struct usb_descriptor_header *) &ms_header_desc;\r\nfor (n = 0; n < midi->in_ports; n++) {\r\nstruct usb_midi_in_jack_descriptor *in_ext = &jack_in_ext_desc[n];\r\nstruct usb_midi_out_jack_descriptor_1 *out_emb = &jack_out_emb_desc[n];\r\nin_ext->bLength = USB_DT_MIDI_IN_SIZE;\r\nin_ext->bDescriptorType = USB_DT_CS_INTERFACE;\r\nin_ext->bDescriptorSubtype = USB_MS_MIDI_IN_JACK;\r\nin_ext->bJackType = USB_MS_EXTERNAL;\r\nin_ext->bJackID = jack++;\r\nin_ext->iJack = 0;\r\nmidi_function[i++] = (struct usb_descriptor_header *) in_ext;\r\nout_emb->bLength = USB_DT_MIDI_OUT_SIZE(1);\r\nout_emb->bDescriptorType = USB_DT_CS_INTERFACE;\r\nout_emb->bDescriptorSubtype = USB_MS_MIDI_OUT_JACK;\r\nout_emb->bJackType = USB_MS_EMBEDDED;\r\nout_emb->bJackID = jack++;\r\nout_emb->bNrInputPins = 1;\r\nout_emb->pins[0].baSourcePin = 1;\r\nout_emb->pins[0].baSourceID = in_ext->bJackID;\r\nout_emb->iJack = 0;\r\nmidi_function[i++] = (struct usb_descriptor_header *) out_emb;\r\nms_in_desc.baAssocJackID[n] = out_emb->bJackID;\r\n}\r\nfor (n = 0; n < midi->out_ports; n++) {\r\nstruct usb_midi_in_jack_descriptor *in_emb = &jack_in_emb_desc[n];\r\nstruct usb_midi_out_jack_descriptor_1 *out_ext = &jack_out_ext_desc[n];\r\nin_emb->bLength = USB_DT_MIDI_IN_SIZE;\r\nin_emb->bDescriptorType = USB_DT_CS_INTERFACE;\r\nin_emb->bDescriptorSubtype = USB_MS_MIDI_IN_JACK;\r\nin_emb->bJackType = USB_MS_EMBEDDED;\r\nin_emb->bJackID = jack++;\r\nin_emb->iJack = 0;\r\nmidi_function[i++] = (struct usb_descriptor_header *) in_emb;\r\nout_ext->bLength = USB_DT_MIDI_OUT_SIZE(1);\r\nout_ext->bDescriptorType = USB_DT_CS_INTERFACE;\r\nout_ext->bDescriptorSubtype = USB_MS_MIDI_OUT_JACK;\r\nout_ext->bJackType = USB_MS_EXTERNAL;\r\nout_ext->bJackID = jack++;\r\nout_ext->bNrInputPins = 1;\r\nout_ext->iJack = 0;\r\nout_ext->pins[0].baSourceID = in_emb->bJackID;\r\nout_ext->pins[0].baSourcePin = 1;\r\nmidi_function[i++] = (struct usb_descriptor_header *) out_ext;\r\nms_out_desc.baAssocJackID[n] = in_emb->bJackID;\r\n}\r\nms_out_desc.bLength = USB_DT_MS_ENDPOINT_SIZE(midi->in_ports);\r\nms_out_desc.bNumEmbMIDIJack = midi->in_ports;\r\nms_in_desc.bLength = USB_DT_MS_ENDPOINT_SIZE(midi->out_ports);\r\nms_in_desc.bNumEmbMIDIJack = midi->out_ports;\r\nmidi_function[i++] = (struct usb_descriptor_header *) &bulk_out_desc;\r\nmidi_function[i++] = (struct usb_descriptor_header *) &ms_out_desc;\r\nmidi_function[i++] = (struct usb_descriptor_header *) &bulk_in_desc;\r\nmidi_function[i++] = (struct usb_descriptor_header *) &ms_in_desc;\r\nmidi_function[i++] = NULL;\r\nf->fs_descriptors = usb_copy_descriptors(midi_function);\r\nif (!f->fs_descriptors)\r\ngoto fail_f_midi;\r\nif (gadget_is_dualspeed(c->cdev->gadget)) {\r\nbulk_in_desc.wMaxPacketSize = cpu_to_le16(512);\r\nbulk_out_desc.wMaxPacketSize = cpu_to_le16(512);\r\nf->hs_descriptors = usb_copy_descriptors(midi_function);\r\nif (!f->hs_descriptors)\r\ngoto fail_f_midi;\r\n}\r\nkfree(midi_function);\r\nreturn 0;\r\nfail_f_midi:\r\nkfree(midi_function);\r\nusb_free_descriptors(f->hs_descriptors);\r\nfail:\r\nf_midi_unregister_card(midi);\r\nfail_register:\r\nERROR(cdev, "%s: can't bind, err %d\n", f->name, status);\r\nreturn status;\r\n}\r\nstatic inline struct f_midi_opts *to_f_midi_opts(struct config_item *item)\r\n{\r\nreturn container_of(to_config_group(item), struct f_midi_opts,\r\nfunc_inst.group);\r\n}\r\nstatic void midi_attr_release(struct config_item *item)\r\n{\r\nstruct f_midi_opts *opts = to_f_midi_opts(item);\r\nusb_put_function_instance(&opts->func_inst);\r\n}\r\nstatic ssize_t f_midi_opts_id_show(struct config_item *item, char *page)\r\n{\r\nstruct f_midi_opts *opts = to_f_midi_opts(item);\r\nint result;\r\nmutex_lock(&opts->lock);\r\nif (opts->id) {\r\nresult = strlcpy(page, opts->id, PAGE_SIZE);\r\n} else {\r\npage[0] = 0;\r\nresult = 0;\r\n}\r\nmutex_unlock(&opts->lock);\r\nreturn result;\r\n}\r\nstatic ssize_t f_midi_opts_id_store(struct config_item *item,\r\nconst char *page, size_t len)\r\n{\r\nstruct f_midi_opts *opts = to_f_midi_opts(item);\r\nint ret;\r\nchar *c;\r\nmutex_lock(&opts->lock);\r\nif (opts->refcnt) {\r\nret = -EBUSY;\r\ngoto end;\r\n}\r\nc = kstrndup(page, len, GFP_KERNEL);\r\nif (!c) {\r\nret = -ENOMEM;\r\ngoto end;\r\n}\r\nif (opts->id_allocated)\r\nkfree(opts->id);\r\nopts->id = c;\r\nopts->id_allocated = true;\r\nret = len;\r\nend:\r\nmutex_unlock(&opts->lock);\r\nreturn ret;\r\n}\r\nstatic void f_midi_free_inst(struct usb_function_instance *f)\r\n{\r\nstruct f_midi_opts *opts;\r\nopts = container_of(f, struct f_midi_opts, func_inst);\r\nif (opts->id_allocated)\r\nkfree(opts->id);\r\nkfree(opts);\r\n}\r\nstatic struct usb_function_instance *f_midi_alloc_inst(void)\r\n{\r\nstruct f_midi_opts *opts;\r\nopts = kzalloc(sizeof(*opts), GFP_KERNEL);\r\nif (!opts)\r\nreturn ERR_PTR(-ENOMEM);\r\nmutex_init(&opts->lock);\r\nopts->func_inst.free_func_inst = f_midi_free_inst;\r\nopts->index = SNDRV_DEFAULT_IDX1;\r\nopts->id = SNDRV_DEFAULT_STR1;\r\nopts->buflen = 256;\r\nopts->qlen = 32;\r\nopts->in_ports = 1;\r\nopts->out_ports = 1;\r\nconfig_group_init_type_name(&opts->func_inst.group, "",\r\n&midi_func_type);\r\nreturn &opts->func_inst;\r\n}\r\nstatic void f_midi_free(struct usb_function *f)\r\n{\r\nstruct f_midi *midi;\r\nstruct f_midi_opts *opts;\r\nmidi = func_to_midi(f);\r\nopts = container_of(f->fi, struct f_midi_opts, func_inst);\r\nkfree(midi->id);\r\nmutex_lock(&opts->lock);\r\nkfifo_free(&midi->in_req_fifo);\r\nkfree(midi);\r\n--opts->refcnt;\r\nmutex_unlock(&opts->lock);\r\n}\r\nstatic void f_midi_unbind(struct usb_configuration *c, struct usb_function *f)\r\n{\r\nstruct usb_composite_dev *cdev = f->config->cdev;\r\nstruct f_midi *midi = func_to_midi(f);\r\nstruct snd_card *card;\r\nDBG(cdev, "unbind\n");\r\nf_midi_disable(f);\r\ncard = midi->card;\r\nmidi->card = NULL;\r\nif (card)\r\nsnd_card_free(card);\r\nusb_free_all_descriptors(f);\r\n}\r\nstatic struct usb_function *f_midi_alloc(struct usb_function_instance *fi)\r\n{\r\nstruct f_midi *midi = NULL;\r\nstruct f_midi_opts *opts;\r\nint status, i;\r\nopts = container_of(fi, struct f_midi_opts, func_inst);\r\nmutex_lock(&opts->lock);\r\nif (opts->in_ports > MAX_PORTS || opts->out_ports > MAX_PORTS) {\r\nstatus = -EINVAL;\r\ngoto setup_fail;\r\n}\r\nmidi = kzalloc(\r\nsizeof(*midi) + opts->in_ports * sizeof(*midi->in_ports_array),\r\nGFP_KERNEL);\r\nif (!midi) {\r\nstatus = -ENOMEM;\r\ngoto setup_fail;\r\n}\r\nfor (i = 0; i < opts->in_ports; i++)\r\nmidi->in_ports_array[i].cable = i;\r\nmidi->id = kstrdup(opts->id, GFP_KERNEL);\r\nif (opts->id && !midi->id) {\r\nstatus = -ENOMEM;\r\ngoto setup_fail;\r\n}\r\nmidi->in_ports = opts->in_ports;\r\nmidi->out_ports = opts->out_ports;\r\nmidi->index = opts->index;\r\nmidi->buflen = opts->buflen;\r\nmidi->qlen = opts->qlen;\r\nmidi->in_last_port = 0;\r\nstatus = kfifo_alloc(&midi->in_req_fifo, midi->qlen, GFP_KERNEL);\r\nif (status)\r\ngoto setup_fail;\r\nspin_lock_init(&midi->transmit_lock);\r\n++opts->refcnt;\r\nmutex_unlock(&opts->lock);\r\nmidi->func.name = "gmidi function";\r\nmidi->func.bind = f_midi_bind;\r\nmidi->func.unbind = f_midi_unbind;\r\nmidi->func.set_alt = f_midi_set_alt;\r\nmidi->func.disable = f_midi_disable;\r\nmidi->func.free_func = f_midi_free;\r\nreturn &midi->func;\r\nsetup_fail:\r\nmutex_unlock(&opts->lock);\r\nkfree(midi);\r\nreturn ERR_PTR(status);\r\n}
