static bool ls_pcie_is_bridge(struct ls_pcie *pcie)\r\n{\r\nu32 header_type;\r\nheader_type = ioread8(pcie->dbi + PCI_HEADER_TYPE);\r\nheader_type &= 0x7f;\r\nreturn header_type == PCI_HEADER_TYPE_BRIDGE;\r\n}\r\nstatic void ls_pcie_clear_multifunction(struct ls_pcie *pcie)\r\n{\r\niowrite8(PCI_HEADER_TYPE_BRIDGE, pcie->dbi + PCI_HEADER_TYPE);\r\n}\r\nstatic void ls_pcie_fix_class(struct ls_pcie *pcie)\r\n{\r\niowrite16(PCI_CLASS_BRIDGE_PCI, pcie->dbi + PCI_CLASS_DEVICE);\r\n}\r\nstatic void ls_pcie_drop_msg_tlp(struct ls_pcie *pcie)\r\n{\r\nu32 val;\r\nval = ioread32(pcie->dbi + PCIE_STRFMR1);\r\nval &= 0xDFFFFFFF;\r\niowrite32(val, pcie->dbi + PCIE_STRFMR1);\r\n}\r\nstatic int ls1021_pcie_link_up(struct pcie_port *pp)\r\n{\r\nu32 state;\r\nstruct ls_pcie *pcie = to_ls_pcie(pp);\r\nif (!pcie->scfg)\r\nreturn 0;\r\nregmap_read(pcie->scfg, SCFG_PEXMSCPORTSR(pcie->index), &state);\r\nstate = (state >> LTSSM_STATE_SHIFT) & LTSSM_STATE_MASK;\r\nif (state < LTSSM_PCIE_L0)\r\nreturn 0;\r\nreturn 1;\r\n}\r\nstatic void ls1021_pcie_host_init(struct pcie_port *pp)\r\n{\r\nstruct ls_pcie *pcie = to_ls_pcie(pp);\r\nu32 index[2];\r\npcie->scfg = syscon_regmap_lookup_by_phandle(pp->dev->of_node,\r\n"fsl,pcie-scfg");\r\nif (IS_ERR(pcie->scfg)) {\r\ndev_err(pp->dev, "No syscfg phandle specified\n");\r\npcie->scfg = NULL;\r\nreturn;\r\n}\r\nif (of_property_read_u32_array(pp->dev->of_node,\r\n"fsl,pcie-scfg", index, 2)) {\r\npcie->scfg = NULL;\r\nreturn;\r\n}\r\npcie->index = index[1];\r\ndw_pcie_setup_rc(pp);\r\nls_pcie_drop_msg_tlp(pcie);\r\n}\r\nstatic int ls_pcie_link_up(struct pcie_port *pp)\r\n{\r\nstruct ls_pcie *pcie = to_ls_pcie(pp);\r\nu32 state;\r\nstate = (ioread32(pcie->lut + PCIE_LUT_DBG) >>\r\npcie->drvdata->ltssm_shift) &\r\nLTSSM_STATE_MASK;\r\nif (state < LTSSM_PCIE_L0)\r\nreturn 0;\r\nreturn 1;\r\n}\r\nstatic void ls_pcie_host_init(struct pcie_port *pp)\r\n{\r\nstruct ls_pcie *pcie = to_ls_pcie(pp);\r\niowrite32(1, pcie->dbi + PCIE_DBI_RO_WR_EN);\r\nls_pcie_fix_class(pcie);\r\nls_pcie_clear_multifunction(pcie);\r\nls_pcie_drop_msg_tlp(pcie);\r\niowrite32(0, pcie->dbi + PCIE_DBI_RO_WR_EN);\r\n}\r\nstatic int ls_pcie_msi_host_init(struct pcie_port *pp,\r\nstruct msi_controller *chip)\r\n{\r\nstruct device_node *msi_node;\r\nstruct device_node *np = pp->dev->of_node;\r\nmsi_node = of_parse_phandle(np, "msi-parent", 0);\r\nif (!msi_node) {\r\ndev_err(pp->dev, "failed to find msi-parent\n");\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int __init ls_add_pcie_port(struct pcie_port *pp,\r\nstruct platform_device *pdev)\r\n{\r\nint ret;\r\nstruct ls_pcie *pcie = to_ls_pcie(pp);\r\npp->dev = &pdev->dev;\r\npp->dbi_base = pcie->dbi;\r\npp->ops = pcie->drvdata->ops;\r\nret = dw_pcie_host_init(pp);\r\nif (ret) {\r\ndev_err(pp->dev, "failed to initialize host\n");\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic int __init ls_pcie_probe(struct platform_device *pdev)\r\n{\r\nconst struct of_device_id *match;\r\nstruct ls_pcie *pcie;\r\nstruct resource *dbi_base;\r\nint ret;\r\nmatch = of_match_device(ls_pcie_of_match, &pdev->dev);\r\nif (!match)\r\nreturn -ENODEV;\r\npcie = devm_kzalloc(&pdev->dev, sizeof(*pcie), GFP_KERNEL);\r\nif (!pcie)\r\nreturn -ENOMEM;\r\ndbi_base = platform_get_resource_byname(pdev, IORESOURCE_MEM, "regs");\r\npcie->dbi = devm_ioremap_resource(&pdev->dev, dbi_base);\r\nif (IS_ERR(pcie->dbi)) {\r\ndev_err(&pdev->dev, "missing *regs* space\n");\r\nreturn PTR_ERR(pcie->dbi);\r\n}\r\npcie->drvdata = match->data;\r\npcie->lut = pcie->dbi + pcie->drvdata->lut_offset;\r\nif (!ls_pcie_is_bridge(pcie))\r\nreturn -ENODEV;\r\nret = ls_add_pcie_port(&pcie->pp, pdev);\r\nif (ret < 0)\r\nreturn ret;\r\nplatform_set_drvdata(pdev, pcie);\r\nreturn 0;\r\n}
