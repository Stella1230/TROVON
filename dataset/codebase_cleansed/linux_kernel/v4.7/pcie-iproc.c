static inline struct iproc_pcie *iproc_data(struct pci_bus *bus)\r\n{\r\nstruct iproc_pcie *pcie;\r\n#ifdef CONFIG_ARM\r\nstruct pci_sys_data *sys = bus->sysdata;\r\npcie = sys->private_data;\r\n#else\r\npcie = bus->sysdata;\r\n#endif\r\nreturn pcie;\r\n}\r\nstatic inline bool iproc_pcie_reg_is_invalid(u16 reg_offset)\r\n{\r\nreturn !!(reg_offset == IPROC_PCIE_REG_INVALID);\r\n}\r\nstatic inline u16 iproc_pcie_reg_offset(struct iproc_pcie *pcie,\r\nenum iproc_pcie_reg reg)\r\n{\r\nreturn pcie->reg_offsets[reg];\r\n}\r\nstatic inline u32 iproc_pcie_read_reg(struct iproc_pcie *pcie,\r\nenum iproc_pcie_reg reg)\r\n{\r\nu16 offset = iproc_pcie_reg_offset(pcie, reg);\r\nif (iproc_pcie_reg_is_invalid(offset))\r\nreturn 0;\r\nreturn readl(pcie->base + offset);\r\n}\r\nstatic inline void iproc_pcie_write_reg(struct iproc_pcie *pcie,\r\nenum iproc_pcie_reg reg, u32 val)\r\n{\r\nu16 offset = iproc_pcie_reg_offset(pcie, reg);\r\nif (iproc_pcie_reg_is_invalid(offset))\r\nreturn;\r\nwritel(val, pcie->base + offset);\r\n}\r\nstatic inline void iproc_pcie_ob_write(struct iproc_pcie *pcie,\r\nenum iproc_pcie_reg reg,\r\nunsigned window, u32 val)\r\n{\r\nu16 offset = iproc_pcie_reg_offset(pcie, reg);\r\nif (iproc_pcie_reg_is_invalid(offset))\r\nreturn;\r\nwritel(val, pcie->base + offset + (window * 8));\r\n}\r\nstatic void __iomem *iproc_pcie_map_cfg_bus(struct pci_bus *bus,\r\nunsigned int devfn,\r\nint where)\r\n{\r\nstruct iproc_pcie *pcie = iproc_data(bus);\r\nunsigned slot = PCI_SLOT(devfn);\r\nunsigned fn = PCI_FUNC(devfn);\r\nunsigned busno = bus->number;\r\nu32 val;\r\nu16 offset;\r\nif (busno == 0) {\r\nif (slot > 0 || fn > 0)\r\nreturn NULL;\r\niproc_pcie_write_reg(pcie, IPROC_PCIE_CFG_IND_ADDR,\r\nwhere & CFG_IND_ADDR_MASK);\r\noffset = iproc_pcie_reg_offset(pcie, IPROC_PCIE_CFG_IND_DATA);\r\nif (iproc_pcie_reg_is_invalid(offset))\r\nreturn NULL;\r\nelse\r\nreturn (pcie->base + offset);\r\n}\r\nif (pcie->type == IPROC_PCIE_PAXC)\r\nif (slot > 0)\r\nreturn NULL;\r\nval = (busno << CFG_ADDR_BUS_NUM_SHIFT) |\r\n(slot << CFG_ADDR_DEV_NUM_SHIFT) |\r\n(fn << CFG_ADDR_FUNC_NUM_SHIFT) |\r\n(where & CFG_ADDR_REG_NUM_MASK) |\r\n(1 & CFG_ADDR_CFG_TYPE_MASK);\r\niproc_pcie_write_reg(pcie, IPROC_PCIE_CFG_ADDR, val);\r\noffset = iproc_pcie_reg_offset(pcie, IPROC_PCIE_CFG_DATA);\r\nif (iproc_pcie_reg_is_invalid(offset))\r\nreturn NULL;\r\nelse\r\nreturn (pcie->base + offset);\r\n}\r\nstatic void iproc_pcie_reset(struct iproc_pcie *pcie)\r\n{\r\nu32 val;\r\nif (pcie->type == IPROC_PCIE_PAXC) {\r\nval = iproc_pcie_read_reg(pcie, IPROC_PCIE_CLK_CTRL);\r\nval &= ~PAXC_RESET_MASK;\r\niproc_pcie_write_reg(pcie, IPROC_PCIE_CLK_CTRL, val);\r\nudelay(100);\r\nval |= PAXC_RESET_MASK;\r\niproc_pcie_write_reg(pcie, IPROC_PCIE_CLK_CTRL, val);\r\nudelay(100);\r\nreturn;\r\n}\r\nval = iproc_pcie_read_reg(pcie, IPROC_PCIE_CLK_CTRL);\r\nval &= ~EP_PERST_SOURCE_SELECT & ~EP_MODE_SURVIVE_PERST &\r\n~RC_PCIE_RST_OUTPUT;\r\niproc_pcie_write_reg(pcie, IPROC_PCIE_CLK_CTRL, val);\r\nudelay(250);\r\nval |= RC_PCIE_RST_OUTPUT;\r\niproc_pcie_write_reg(pcie, IPROC_PCIE_CLK_CTRL, val);\r\nmsleep(100);\r\n}\r\nstatic int iproc_pcie_check_link(struct iproc_pcie *pcie, struct pci_bus *bus)\r\n{\r\nu8 hdr_type;\r\nu32 link_ctrl, class, val;\r\nu16 pos, link_status;\r\nbool link_is_active = false;\r\nif (pcie->type == IPROC_PCIE_PAXC)\r\nreturn 0;\r\nval = iproc_pcie_read_reg(pcie, IPROC_PCIE_LINK_STATUS);\r\nif (!(val & PCIE_PHYLINKUP) || !(val & PCIE_DL_ACTIVE)) {\r\ndev_err(pcie->dev, "PHY or data link is INACTIVE!\n");\r\nreturn -ENODEV;\r\n}\r\npci_bus_read_config_byte(bus, 0, PCI_HEADER_TYPE, &hdr_type);\r\nif ((hdr_type & 0x7f) != PCI_HEADER_TYPE_BRIDGE) {\r\ndev_err(pcie->dev, "in EP mode, hdr=%#02x\n", hdr_type);\r\nreturn -EFAULT;\r\n}\r\n#define PCI_BRIDGE_CTRL_REG_OFFSET 0x43c\r\n#define PCI_CLASS_BRIDGE_MASK 0xffff00\r\n#define PCI_CLASS_BRIDGE_SHIFT 8\r\npci_bus_read_config_dword(bus, 0, PCI_BRIDGE_CTRL_REG_OFFSET, &class);\r\nclass &= ~PCI_CLASS_BRIDGE_MASK;\r\nclass |= (PCI_CLASS_BRIDGE_PCI << PCI_CLASS_BRIDGE_SHIFT);\r\npci_bus_write_config_dword(bus, 0, PCI_BRIDGE_CTRL_REG_OFFSET, class);\r\npos = pci_bus_find_capability(bus, 0, PCI_CAP_ID_EXP);\r\npci_bus_read_config_word(bus, 0, pos + PCI_EXP_LNKSTA, &link_status);\r\nif (link_status & PCI_EXP_LNKSTA_NLW)\r\nlink_is_active = true;\r\nif (!link_is_active) {\r\n#define PCI_LINK_STATUS_CTRL_2_OFFSET 0x0dc\r\n#define PCI_TARGET_LINK_SPEED_MASK 0xf\r\n#define PCI_TARGET_LINK_SPEED_GEN2 0x2\r\n#define PCI_TARGET_LINK_SPEED_GEN1 0x1\r\npci_bus_read_config_dword(bus, 0,\r\nPCI_LINK_STATUS_CTRL_2_OFFSET,\r\n&link_ctrl);\r\nif ((link_ctrl & PCI_TARGET_LINK_SPEED_MASK) ==\r\nPCI_TARGET_LINK_SPEED_GEN2) {\r\nlink_ctrl &= ~PCI_TARGET_LINK_SPEED_MASK;\r\nlink_ctrl |= PCI_TARGET_LINK_SPEED_GEN1;\r\npci_bus_write_config_dword(bus, 0,\r\nPCI_LINK_STATUS_CTRL_2_OFFSET,\r\nlink_ctrl);\r\nmsleep(100);\r\npos = pci_bus_find_capability(bus, 0, PCI_CAP_ID_EXP);\r\npci_bus_read_config_word(bus, 0, pos + PCI_EXP_LNKSTA,\r\n&link_status);\r\nif (link_status & PCI_EXP_LNKSTA_NLW)\r\nlink_is_active = true;\r\n}\r\n}\r\ndev_info(pcie->dev, "link: %s\n", link_is_active ? "UP" : "DOWN");\r\nreturn link_is_active ? 0 : -ENODEV;\r\n}\r\nstatic void iproc_pcie_enable(struct iproc_pcie *pcie)\r\n{\r\niproc_pcie_write_reg(pcie, IPROC_PCIE_INTX_EN, SYS_RC_INTX_MASK);\r\n}\r\nstatic int iproc_pcie_setup_ob(struct iproc_pcie *pcie, u64 axi_addr,\r\nu64 pci_addr, resource_size_t size)\r\n{\r\nstruct iproc_pcie_ob *ob = &pcie->ob;\r\nunsigned i;\r\nu64 max_size = (u64)ob->window_size * MAX_NUM_OB_WINDOWS;\r\nu64 remainder;\r\nif (size > max_size) {\r\ndev_err(pcie->dev,\r\n"res size %pap exceeds max supported size 0x%llx\n",\r\n&size, max_size);\r\nreturn -EINVAL;\r\n}\r\ndiv64_u64_rem(size, ob->window_size, &remainder);\r\nif (remainder) {\r\ndev_err(pcie->dev,\r\n"res size %pap needs to be multiple of window size %pap\n",\r\n&size, &ob->window_size);\r\nreturn -EINVAL;\r\n}\r\nif (axi_addr < ob->axi_offset) {\r\ndev_err(pcie->dev,\r\n"axi address %pap less than offset %pap\n",\r\n&axi_addr, &ob->axi_offset);\r\nreturn -EINVAL;\r\n}\r\naxi_addr -= ob->axi_offset;\r\nfor (i = 0; i < MAX_NUM_OB_WINDOWS; i++) {\r\niproc_pcie_ob_write(pcie, IPROC_PCIE_OARR_LO, i,\r\nlower_32_bits(axi_addr) | OARR_VALID |\r\n(ob->set_oarr_size ? 1 : 0));\r\niproc_pcie_ob_write(pcie, IPROC_PCIE_OARR_HI, i,\r\nupper_32_bits(axi_addr));\r\niproc_pcie_ob_write(pcie, IPROC_PCIE_OMAP_LO, i,\r\nlower_32_bits(pci_addr));\r\niproc_pcie_ob_write(pcie, IPROC_PCIE_OMAP_HI, i,\r\nupper_32_bits(pci_addr));\r\nsize -= ob->window_size;\r\nif (size == 0)\r\nbreak;\r\naxi_addr += ob->window_size;\r\npci_addr += ob->window_size;\r\n}\r\nreturn 0;\r\n}\r\nstatic int iproc_pcie_map_ranges(struct iproc_pcie *pcie,\r\nstruct list_head *resources)\r\n{\r\nstruct resource_entry *window;\r\nint ret;\r\nresource_list_for_each_entry(window, resources) {\r\nstruct resource *res = window->res;\r\nu64 res_type = resource_type(res);\r\nswitch (res_type) {\r\ncase IORESOURCE_IO:\r\ncase IORESOURCE_BUS:\r\nbreak;\r\ncase IORESOURCE_MEM:\r\nret = iproc_pcie_setup_ob(pcie, res->start,\r\nres->start - window->offset,\r\nresource_size(res));\r\nif (ret)\r\nreturn ret;\r\nbreak;\r\ndefault:\r\ndev_err(pcie->dev, "invalid resource %pR\n", res);\r\nreturn -EINVAL;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int iproc_pcie_msi_enable(struct iproc_pcie *pcie)\r\n{\r\nstruct device_node *msi_node;\r\nmsi_node = of_parse_phandle(pcie->dev->of_node, "msi-parent", 0);\r\nif (!msi_node)\r\nreturn -ENODEV;\r\nreturn iproc_msi_init(pcie, msi_node);\r\n}\r\nstatic void iproc_pcie_msi_disable(struct iproc_pcie *pcie)\r\n{\r\niproc_msi_exit(pcie);\r\n}\r\nint iproc_pcie_setup(struct iproc_pcie *pcie, struct list_head *res)\r\n{\r\nint ret;\r\nvoid *sysdata;\r\nstruct pci_bus *bus;\r\nif (!pcie || !pcie->dev || !pcie->base)\r\nreturn -EINVAL;\r\nret = phy_init(pcie->phy);\r\nif (ret) {\r\ndev_err(pcie->dev, "unable to initialize PCIe PHY\n");\r\nreturn ret;\r\n}\r\nret = phy_power_on(pcie->phy);\r\nif (ret) {\r\ndev_err(pcie->dev, "unable to power on PCIe PHY\n");\r\ngoto err_exit_phy;\r\n}\r\nswitch (pcie->type) {\r\ncase IPROC_PCIE_PAXB:\r\npcie->reg_offsets = iproc_pcie_reg_paxb;\r\nbreak;\r\ncase IPROC_PCIE_PAXC:\r\npcie->reg_offsets = iproc_pcie_reg_paxc;\r\nbreak;\r\ndefault:\r\ndev_err(pcie->dev, "incompatible iProc PCIe interface\n");\r\nret = -EINVAL;\r\ngoto err_power_off_phy;\r\n}\r\niproc_pcie_reset(pcie);\r\nif (pcie->need_ob_cfg) {\r\nret = iproc_pcie_map_ranges(pcie, res);\r\nif (ret) {\r\ndev_err(pcie->dev, "map failed\n");\r\ngoto err_power_off_phy;\r\n}\r\n}\r\n#ifdef CONFIG_ARM\r\npcie->sysdata.private_data = pcie;\r\nsysdata = &pcie->sysdata;\r\n#else\r\nsysdata = pcie;\r\n#endif\r\nbus = pci_create_root_bus(pcie->dev, 0, &iproc_pcie_ops, sysdata, res);\r\nif (!bus) {\r\ndev_err(pcie->dev, "unable to create PCI root bus\n");\r\nret = -ENOMEM;\r\ngoto err_power_off_phy;\r\n}\r\npcie->root_bus = bus;\r\nret = iproc_pcie_check_link(pcie, bus);\r\nif (ret) {\r\ndev_err(pcie->dev, "no PCIe EP device detected\n");\r\ngoto err_rm_root_bus;\r\n}\r\niproc_pcie_enable(pcie);\r\nif (IS_ENABLED(CONFIG_PCI_MSI))\r\nif (iproc_pcie_msi_enable(pcie))\r\ndev_info(pcie->dev, "not using iProc MSI\n");\r\npci_scan_child_bus(bus);\r\npci_assign_unassigned_bus_resources(bus);\r\npci_fixup_irqs(pci_common_swizzle, pcie->map_irq);\r\npci_bus_add_devices(bus);\r\nreturn 0;\r\nerr_rm_root_bus:\r\npci_stop_root_bus(bus);\r\npci_remove_root_bus(bus);\r\nerr_power_off_phy:\r\nphy_power_off(pcie->phy);\r\nerr_exit_phy:\r\nphy_exit(pcie->phy);\r\nreturn ret;\r\n}\r\nint iproc_pcie_remove(struct iproc_pcie *pcie)\r\n{\r\npci_stop_root_bus(pcie->root_bus);\r\npci_remove_root_bus(pcie->root_bus);\r\niproc_pcie_msi_disable(pcie);\r\nphy_power_off(pcie->phy);\r\nphy_exit(pcie->phy);\r\nreturn 0;\r\n}
