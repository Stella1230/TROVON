static int get_offset(unsigned int last_mmap)\r\n{\r\nreturn (last_mmap & (SHM_COLOUR-1)) >> PAGE_SHIFT;\r\n}\r\nstatic unsigned long shared_align_offset(unsigned int last_mmap,\r\nunsigned long pgoff)\r\n{\r\nreturn (get_offset(last_mmap) + pgoff) << PAGE_SHIFT;\r\n}\r\nstatic inline unsigned long COLOR_ALIGN(unsigned long addr,\r\nunsigned int last_mmap, unsigned long pgoff)\r\n{\r\nunsigned long base = (addr+SHM_COLOUR-1) & ~(SHM_COLOUR-1);\r\nunsigned long off = (SHM_COLOUR-1) &\r\n(shared_align_offset(last_mmap, pgoff) << PAGE_SHIFT);\r\nreturn base + off;\r\n}\r\nstatic unsigned long mmap_upper_limit(void)\r\n{\r\nunsigned long stack_base;\r\nstack_base = rlimit_max(RLIMIT_STACK);\r\nif (stack_base > STACK_SIZE_MAX)\r\nstack_base = STACK_SIZE_MAX;\r\nstack_base += (STACK_RND_MASK << PAGE_SHIFT);\r\nreturn PAGE_ALIGN(STACK_TOP - stack_base);\r\n}\r\nunsigned long arch_get_unmapped_area(struct file *filp, unsigned long addr,\r\nunsigned long len, unsigned long pgoff, unsigned long flags)\r\n{\r\nstruct mm_struct *mm = current->mm;\r\nstruct vm_area_struct *vma;\r\nunsigned long task_size = TASK_SIZE;\r\nint do_color_align, last_mmap;\r\nstruct vm_unmapped_area_info info;\r\nif (len > task_size)\r\nreturn -ENOMEM;\r\ndo_color_align = 0;\r\nif (filp || (flags & MAP_SHARED))\r\ndo_color_align = 1;\r\nlast_mmap = GET_LAST_MMAP(filp);\r\nif (flags & MAP_FIXED) {\r\nif ((flags & MAP_SHARED) && last_mmap &&\r\n(addr - shared_align_offset(last_mmap, pgoff))\r\n& (SHM_COLOUR - 1))\r\nreturn -EINVAL;\r\ngoto found_addr;\r\n}\r\nif (addr) {\r\nif (do_color_align && last_mmap)\r\naddr = COLOR_ALIGN(addr, last_mmap, pgoff);\r\nelse\r\naddr = PAGE_ALIGN(addr);\r\nvma = find_vma(mm, addr);\r\nif (task_size - len >= addr &&\r\n(!vma || addr + len <= vma->vm_start))\r\ngoto found_addr;\r\n}\r\ninfo.flags = 0;\r\ninfo.length = len;\r\ninfo.low_limit = mm->mmap_legacy_base;\r\ninfo.high_limit = mmap_upper_limit();\r\ninfo.align_mask = last_mmap ? (PAGE_MASK & (SHM_COLOUR - 1)) : 0;\r\ninfo.align_offset = shared_align_offset(last_mmap, pgoff);\r\naddr = vm_unmapped_area(&info);\r\nfound_addr:\r\nif (do_color_align && !last_mmap && !(addr & ~PAGE_MASK))\r\nSET_LAST_MMAP(filp, addr - (pgoff << PAGE_SHIFT));\r\nreturn addr;\r\n}\r\nunsigned long\r\narch_get_unmapped_area_topdown(struct file *filp, const unsigned long addr0,\r\nconst unsigned long len, const unsigned long pgoff,\r\nconst unsigned long flags)\r\n{\r\nstruct vm_area_struct *vma;\r\nstruct mm_struct *mm = current->mm;\r\nunsigned long addr = addr0;\r\nint do_color_align, last_mmap;\r\nstruct vm_unmapped_area_info info;\r\n#ifdef CONFIG_64BIT\r\nBUG_ON(!test_thread_flag(TIF_32BIT));\r\n#endif\r\nif (len > TASK_SIZE)\r\nreturn -ENOMEM;\r\ndo_color_align = 0;\r\nif (filp || (flags & MAP_SHARED))\r\ndo_color_align = 1;\r\nlast_mmap = GET_LAST_MMAP(filp);\r\nif (flags & MAP_FIXED) {\r\nif ((flags & MAP_SHARED) && last_mmap &&\r\n(addr - shared_align_offset(last_mmap, pgoff))\r\n& (SHM_COLOUR - 1))\r\nreturn -EINVAL;\r\ngoto found_addr;\r\n}\r\nif (addr) {\r\nif (do_color_align && last_mmap)\r\naddr = COLOR_ALIGN(addr, last_mmap, pgoff);\r\nelse\r\naddr = PAGE_ALIGN(addr);\r\nvma = find_vma(mm, addr);\r\nif (TASK_SIZE - len >= addr &&\r\n(!vma || addr + len <= vma->vm_start))\r\ngoto found_addr;\r\n}\r\ninfo.flags = VM_UNMAPPED_AREA_TOPDOWN;\r\ninfo.length = len;\r\ninfo.low_limit = PAGE_SIZE;\r\ninfo.high_limit = mm->mmap_base;\r\ninfo.align_mask = last_mmap ? (PAGE_MASK & (SHM_COLOUR - 1)) : 0;\r\ninfo.align_offset = shared_align_offset(last_mmap, pgoff);\r\naddr = vm_unmapped_area(&info);\r\nif (!(addr & ~PAGE_MASK))\r\ngoto found_addr;\r\nVM_BUG_ON(addr != -ENOMEM);\r\nreturn arch_get_unmapped_area(filp, addr0, len, pgoff, flags);\r\nfound_addr:\r\nif (do_color_align && !last_mmap && !(addr & ~PAGE_MASK))\r\nSET_LAST_MMAP(filp, addr - (pgoff << PAGE_SHIFT));\r\nreturn addr;\r\n}\r\nstatic int mmap_is_legacy(void)\r\n{\r\nif (current->personality & ADDR_COMPAT_LAYOUT)\r\nreturn 1;\r\nreturn sysctl_legacy_va_layout;\r\n}\r\nstatic unsigned long mmap_rnd(void)\r\n{\r\nunsigned long rnd = 0;\r\nif (current->flags & PF_RANDOMIZE) {\r\nif (is_32bit_task())\r\nrnd = get_random_int() % (1<<8);\r\nelse\r\nrnd = get_random_int() % (1<<28);\r\n}\r\nreturn rnd << PAGE_SHIFT;\r\n}\r\nstatic unsigned long mmap_legacy_base(void)\r\n{\r\nreturn TASK_UNMAPPED_BASE + mmap_rnd();\r\n}\r\nvoid arch_pick_mmap_layout(struct mm_struct *mm)\r\n{\r\nmm->mmap_legacy_base = mmap_legacy_base();\r\nmm->mmap_base = mmap_upper_limit();\r\nif (mmap_is_legacy()) {\r\nmm->mmap_base = mm->mmap_legacy_base;\r\nmm->get_unmapped_area = arch_get_unmapped_area;\r\n} else {\r\nmm->get_unmapped_area = arch_get_unmapped_area_topdown;\r\n}\r\n}\r\nasmlinkage unsigned long sys_mmap2(unsigned long addr, unsigned long len,\r\nunsigned long prot, unsigned long flags, unsigned long fd,\r\nunsigned long pgoff)\r\n{\r\nreturn sys_mmap_pgoff(addr, len, prot, flags, fd,\r\npgoff >> (PAGE_SHIFT - 12));\r\n}\r\nasmlinkage unsigned long sys_mmap(unsigned long addr, unsigned long len,\r\nunsigned long prot, unsigned long flags, unsigned long fd,\r\nunsigned long offset)\r\n{\r\nif (!(offset & ~PAGE_MASK)) {\r\nreturn sys_mmap_pgoff(addr, len, prot, flags, fd,\r\noffset >> PAGE_SHIFT);\r\n} else {\r\nreturn -EINVAL;\r\n}\r\n}\r\nasmlinkage long parisc_truncate64(const char __user * path,\r\nunsigned int high, unsigned int low)\r\n{\r\nreturn sys_truncate(path, (long)high << 32 | low);\r\n}\r\nasmlinkage long parisc_ftruncate64(unsigned int fd,\r\nunsigned int high, unsigned int low)\r\n{\r\nreturn sys_ftruncate(fd, (long)high << 32 | low);\r\n}\r\nasmlinkage long sys_truncate64(const char __user * path, unsigned long length)\r\n{\r\nreturn sys_truncate(path, length);\r\n}\r\nasmlinkage long sys_ftruncate64(unsigned int fd, unsigned long length)\r\n{\r\nreturn sys_ftruncate(fd, length);\r\n}\r\nasmlinkage long sys_fcntl64(unsigned int fd, unsigned int cmd, unsigned long arg)\r\n{\r\nreturn sys_fcntl(fd, cmd, arg);\r\n}\r\nasmlinkage long parisc_truncate64(const char __user * path,\r\nunsigned int high, unsigned int low)\r\n{\r\nreturn sys_truncate64(path, (loff_t)high << 32 | low);\r\n}\r\nasmlinkage long parisc_ftruncate64(unsigned int fd,\r\nunsigned int high, unsigned int low)\r\n{\r\nreturn sys_ftruncate64(fd, (loff_t)high << 32 | low);\r\n}\r\nasmlinkage ssize_t parisc_pread64(unsigned int fd, char __user *buf, size_t count,\r\nunsigned int high, unsigned int low)\r\n{\r\nreturn sys_pread64(fd, buf, count, (loff_t)high << 32 | low);\r\n}\r\nasmlinkage ssize_t parisc_pwrite64(unsigned int fd, const char __user *buf,\r\nsize_t count, unsigned int high, unsigned int low)\r\n{\r\nreturn sys_pwrite64(fd, buf, count, (loff_t)high << 32 | low);\r\n}\r\nasmlinkage ssize_t parisc_readahead(int fd, unsigned int high, unsigned int low,\r\nsize_t count)\r\n{\r\nreturn sys_readahead(fd, (loff_t)high << 32 | low, count);\r\n}\r\nasmlinkage long parisc_fadvise64_64(int fd,\r\nunsigned int high_off, unsigned int low_off,\r\nunsigned int high_len, unsigned int low_len, int advice)\r\n{\r\nreturn sys_fadvise64_64(fd, (loff_t)high_off << 32 | low_off,\r\n(loff_t)high_len << 32 | low_len, advice);\r\n}\r\nasmlinkage long parisc_sync_file_range(int fd,\r\nu32 hi_off, u32 lo_off, u32 hi_nbytes, u32 lo_nbytes,\r\nunsigned int flags)\r\n{\r\nreturn sys_sync_file_range(fd, (loff_t)hi_off << 32 | lo_off,\r\n(loff_t)hi_nbytes << 32 | lo_nbytes, flags);\r\n}\r\nasmlinkage long parisc_fallocate(int fd, int mode, u32 offhi, u32 offlo,\r\nu32 lenhi, u32 lenlo)\r\n{\r\nreturn sys_fallocate(fd, mode, ((u64)offhi << 32) | offlo,\r\n((u64)lenhi << 32) | lenlo);\r\n}\r\nlong parisc_personality(unsigned long personality)\r\n{\r\nlong err;\r\nif (personality(current->personality) == PER_LINUX32\r\n&& personality(personality) == PER_LINUX)\r\npersonality = (personality & ~PER_MASK) | PER_LINUX32;\r\nerr = sys_personality(personality);\r\nif (personality(err) == PER_LINUX32)\r\nerr = (err & ~PER_MASK) | PER_LINUX;\r\nreturn err;\r\n}
