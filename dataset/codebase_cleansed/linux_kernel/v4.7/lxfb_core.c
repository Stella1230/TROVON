static void get_modedb(struct fb_videomode **modedb, unsigned int *size)\r\n{\r\nif (olpc_has_dcon()) {\r\n*modedb = (struct fb_videomode *) olpc_dcon_modedb;\r\n*size = ARRAY_SIZE(olpc_dcon_modedb);\r\n} else {\r\n*modedb = (struct fb_videomode *) geode_modedb;\r\n*size = ARRAY_SIZE(geode_modedb);\r\n}\r\n}\r\nstatic void get_modedb(struct fb_videomode **modedb, unsigned int *size)\r\n{\r\n*modedb = (struct fb_videomode *) geode_modedb;\r\n*size = ARRAY_SIZE(geode_modedb);\r\n}\r\nstatic int lxfb_check_var(struct fb_var_screeninfo *var, struct fb_info *info)\r\n{\r\nif (var->xres > 1920 || var->yres > 1440)\r\nreturn -EINVAL;\r\nif (var->bits_per_pixel == 32) {\r\nvar->red.offset = 16; var->red.length = 8;\r\nvar->green.offset = 8; var->green.length = 8;\r\nvar->blue.offset = 0; var->blue.length = 8;\r\n} else if (var->bits_per_pixel == 16) {\r\nvar->red.offset = 11; var->red.length = 5;\r\nvar->green.offset = 5; var->green.length = 6;\r\nvar->blue.offset = 0; var->blue.length = 5;\r\n} else if (var->bits_per_pixel == 8) {\r\nvar->red.offset = 0; var->red.length = 8;\r\nvar->green.offset = 0; var->green.length = 8;\r\nvar->blue.offset = 0; var->blue.length = 8;\r\n} else\r\nreturn -EINVAL;\r\nvar->transp.offset = 0; var->transp.length = 0;\r\nif ((lx_get_pitch(var->xres, var->bits_per_pixel) * var->yres)\r\n> info->fix.smem_len)\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\nstatic int lxfb_set_par(struct fb_info *info)\r\n{\r\nif (info->var.bits_per_pixel > 8)\r\ninfo->fix.visual = FB_VISUAL_TRUECOLOR;\r\nelse\r\ninfo->fix.visual = FB_VISUAL_PSEUDOCOLOR;\r\ninfo->fix.line_length = lx_get_pitch(info->var.xres,\r\ninfo->var.bits_per_pixel);\r\nlx_set_mode(info);\r\nreturn 0;\r\n}\r\nstatic inline u_int chan_to_field(u_int chan, struct fb_bitfield *bf)\r\n{\r\nchan &= 0xffff;\r\nchan >>= 16 - bf->length;\r\nreturn chan << bf->offset;\r\n}\r\nstatic int lxfb_setcolreg(unsigned regno, unsigned red, unsigned green,\r\nunsigned blue, unsigned transp,\r\nstruct fb_info *info)\r\n{\r\nif (info->var.grayscale) {\r\nred = green = blue = (red * 77 + green * 151 + blue * 28) >> 8;\r\n}\r\nif (info->fix.visual == FB_VISUAL_TRUECOLOR) {\r\nu32 *pal = info->pseudo_palette;\r\nu32 v;\r\nif (regno >= 16)\r\nreturn -EINVAL;\r\nv = chan_to_field(red, &info->var.red);\r\nv |= chan_to_field(green, &info->var.green);\r\nv |= chan_to_field(blue, &info->var.blue);\r\npal[regno] = v;\r\n} else {\r\nif (regno >= 256)\r\nreturn -EINVAL;\r\nlx_set_palette_reg(info, regno, red, green, blue);\r\n}\r\nreturn 0;\r\n}\r\nstatic int lxfb_blank(int blank_mode, struct fb_info *info)\r\n{\r\nreturn lx_blank_display(info, blank_mode);\r\n}\r\nstatic int lxfb_map_video_memory(struct fb_info *info, struct pci_dev *dev)\r\n{\r\nstruct lxfb_par *par = info->par;\r\nint ret;\r\nret = pci_enable_device(dev);\r\nif (ret)\r\nreturn ret;\r\nret = pci_request_region(dev, 0, "lxfb-framebuffer");\r\nif (ret)\r\nreturn ret;\r\nret = pci_request_region(dev, 1, "lxfb-gp");\r\nif (ret)\r\nreturn ret;\r\nret = pci_request_region(dev, 2, "lxfb-vg");\r\nif (ret)\r\nreturn ret;\r\nret = pci_request_region(dev, 3, "lxfb-vp");\r\nif (ret)\r\nreturn ret;\r\ninfo->fix.smem_start = pci_resource_start(dev, 0);\r\ninfo->fix.smem_len = vram ? vram : lx_framebuffer_size();\r\ninfo->screen_base = ioremap(info->fix.smem_start, info->fix.smem_len);\r\nret = -ENOMEM;\r\nif (info->screen_base == NULL)\r\nreturn ret;\r\npar->gp_regs = pci_ioremap_bar(dev, 1);\r\nif (par->gp_regs == NULL)\r\nreturn ret;\r\npar->dc_regs = pci_ioremap_bar(dev, 2);\r\nif (par->dc_regs == NULL)\r\nreturn ret;\r\npar->vp_regs = pci_ioremap_bar(dev, 3);\r\nif (par->vp_regs == NULL)\r\nreturn ret;\r\nwrite_dc(par, DC_UNLOCK, DC_UNLOCK_UNLOCK);\r\nwrite_dc(par, DC_GLIU0_MEM_OFFSET, info->fix.smem_start & 0xFF000000);\r\nwrite_dc(par, DC_UNLOCK, DC_UNLOCK_LOCK);\r\ndev_info(&dev->dev, "%d KB of video memory at 0x%lx\n",\r\ninfo->fix.smem_len / 1024, info->fix.smem_start);\r\nreturn 0;\r\n}\r\nstatic struct fb_info *lxfb_init_fbinfo(struct device *dev)\r\n{\r\nstruct lxfb_par *par;\r\nstruct fb_info *info;\r\ninfo = framebuffer_alloc(sizeof(struct lxfb_par) + sizeof(u32) * 16,\r\ndev);\r\nif (!info)\r\nreturn NULL;\r\npar = info->par;\r\nstrcpy(info->fix.id, "Geode LX");\r\ninfo->fix.type = FB_TYPE_PACKED_PIXELS;\r\ninfo->fix.type_aux = 0;\r\ninfo->fix.xpanstep = 0;\r\ninfo->fix.ypanstep = 0;\r\ninfo->fix.ywrapstep = 0;\r\ninfo->fix.accel = FB_ACCEL_NONE;\r\ninfo->var.nonstd = 0;\r\ninfo->var.activate = FB_ACTIVATE_NOW;\r\ninfo->var.height = -1;\r\ninfo->var.width = -1;\r\ninfo->var.accel_flags = 0;\r\ninfo->var.vmode = FB_VMODE_NONINTERLACED;\r\ninfo->fbops = &lxfb_ops;\r\ninfo->flags = FBINFO_DEFAULT;\r\ninfo->node = -1;\r\ninfo->pseudo_palette = (void *)par + sizeof(struct lxfb_par);\r\nif (fb_alloc_cmap(&info->cmap, 256, 0) < 0) {\r\nframebuffer_release(info);\r\nreturn NULL;\r\n}\r\ninfo->var.grayscale = 0;\r\nreturn info;\r\n}\r\nstatic int lxfb_suspend(struct pci_dev *pdev, pm_message_t state)\r\n{\r\nstruct fb_info *info = pci_get_drvdata(pdev);\r\nif (state.event == PM_EVENT_SUSPEND) {\r\nconsole_lock();\r\nlx_powerdown(info);\r\nfb_set_suspend(info, 1);\r\nconsole_unlock();\r\n}\r\nreturn 0;\r\n}\r\nstatic int lxfb_resume(struct pci_dev *pdev)\r\n{\r\nstruct fb_info *info = pci_get_drvdata(pdev);\r\nint ret;\r\nconsole_lock();\r\nret = lx_powerup(info);\r\nif (ret) {\r\nprintk(KERN_ERR "lxfb: power up failed!\n");\r\nreturn ret;\r\n}\r\nfb_set_suspend(info, 0);\r\nconsole_unlock();\r\nreturn 0;\r\n}\r\nstatic int lxfb_probe(struct pci_dev *pdev, const struct pci_device_id *id)\r\n{\r\nstruct lxfb_par *par;\r\nstruct fb_info *info;\r\nint ret;\r\nstruct fb_videomode *modedb_ptr;\r\nunsigned int modedb_size;\r\ninfo = lxfb_init_fbinfo(&pdev->dev);\r\nif (info == NULL)\r\nreturn -ENOMEM;\r\npar = info->par;\r\nret = lxfb_map_video_memory(info, pdev);\r\nif (ret < 0) {\r\ndev_err(&pdev->dev,\r\n"failed to map frame buffer or controller registers\n");\r\ngoto err;\r\n}\r\npar->output = 0;\r\npar->output |= (nopanel) ? 0 : OUTPUT_PANEL;\r\npar->output |= (nocrt) ? 0 : OUTPUT_CRT;\r\nget_modedb(&modedb_ptr, &modedb_size);\r\nret = fb_find_mode(&info->var, info, mode_option,\r\nmodedb_ptr, modedb_size, NULL, 16);\r\nif (ret == 0 || ret == 4) {\r\ndev_err(&pdev->dev, "could not find valid video mode\n");\r\nret = -EINVAL;\r\ngoto err;\r\n}\r\nif (!noclear)\r\nmemset_io(info->screen_base, 0, info->fix.smem_len);\r\nlxfb_check_var(&info->var, info);\r\nlxfb_set_par(info);\r\npm_set_vt_switch(vt_switch);\r\nif (register_framebuffer(info) < 0) {\r\nret = -EINVAL;\r\ngoto err;\r\n}\r\npci_set_drvdata(pdev, info);\r\nfb_info(info, "%s frame buffer device\n", info->fix.id);\r\nreturn 0;\r\nerr:\r\nif (info->screen_base) {\r\niounmap(info->screen_base);\r\npci_release_region(pdev, 0);\r\n}\r\nif (par->gp_regs) {\r\niounmap(par->gp_regs);\r\npci_release_region(pdev, 1);\r\n}\r\nif (par->dc_regs) {\r\niounmap(par->dc_regs);\r\npci_release_region(pdev, 2);\r\n}\r\nif (par->vp_regs) {\r\niounmap(par->vp_regs);\r\npci_release_region(pdev, 3);\r\n}\r\nfb_dealloc_cmap(&info->cmap);\r\nframebuffer_release(info);\r\nreturn ret;\r\n}\r\nstatic void lxfb_remove(struct pci_dev *pdev)\r\n{\r\nstruct fb_info *info = pci_get_drvdata(pdev);\r\nstruct lxfb_par *par = info->par;\r\nunregister_framebuffer(info);\r\niounmap(info->screen_base);\r\npci_release_region(pdev, 0);\r\niounmap(par->gp_regs);\r\npci_release_region(pdev, 1);\r\niounmap(par->dc_regs);\r\npci_release_region(pdev, 2);\r\niounmap(par->vp_regs);\r\npci_release_region(pdev, 3);\r\nfb_dealloc_cmap(&info->cmap);\r\nframebuffer_release(info);\r\n}\r\nstatic int __init lxfb_setup(char *options)\r\n{\r\nchar *opt;\r\nif (!options || !*options)\r\nreturn 0;\r\nwhile ((opt = strsep(&options, ",")) != NULL) {\r\nif (!*opt)\r\ncontinue;\r\nif (!strcmp(opt, "noclear"))\r\nnoclear = 1;\r\nelse if (!strcmp(opt, "nopanel"))\r\nnopanel = 1;\r\nelse if (!strcmp(opt, "nocrt"))\r\nnocrt = 1;\r\nelse\r\nmode_option = opt;\r\n}\r\nreturn 0;\r\n}\r\nstatic int __init lxfb_init(void)\r\n{\r\n#ifndef MODULE\r\nchar *option = NULL;\r\nif (fb_get_options("lxfb", &option))\r\nreturn -ENODEV;\r\nlxfb_setup(option);\r\n#endif\r\nreturn pci_register_driver(&lxfb_driver);\r\n}\r\nstatic void __exit lxfb_cleanup(void)\r\n{\r\npci_unregister_driver(&lxfb_driver);\r\n}
