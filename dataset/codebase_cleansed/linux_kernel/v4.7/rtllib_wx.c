static inline char *rtl819x_translate_scan(struct rtllib_device *ieee,\r\nchar *start, char *stop,\r\nstruct rtllib_network *network,\r\nstruct iw_request_info *info)\r\n{\r\nchar custom[MAX_CUSTOM_LEN];\r\nchar proto_name[IFNAMSIZ];\r\nchar *pname = proto_name;\r\nchar *p;\r\nstruct iw_event iwe;\r\nint i, j;\r\nu16 max_rate, rate;\r\nstatic u8 EWC11NHTCap[] = {0x00, 0x90, 0x4c, 0x33};\r\niwe.cmd = SIOCGIWAP;\r\niwe.u.ap_addr.sa_family = ARPHRD_ETHER;\r\nether_addr_copy(iwe.u.ap_addr.sa_data, network->bssid);\r\nstart = iwe_stream_add_event_rsl(info, start, stop,\r\n&iwe, IW_EV_ADDR_LEN);\r\niwe.cmd = SIOCGIWESSID;\r\niwe.u.data.flags = 1;\r\nif (network->ssid_len > 0) {\r\niwe.u.data.length = min_t(u8, network->ssid_len, 32);\r\nstart = iwe_stream_add_point_rsl(info, start, stop, &iwe,\r\nnetwork->ssid);\r\n} else if (network->hidden_ssid_len == 0) {\r\niwe.u.data.length = sizeof("<hidden>");\r\nstart = iwe_stream_add_point_rsl(info, start, stop,\r\n&iwe, "<hidden>");\r\n} else {\r\niwe.u.data.length = min_t(u8, network->hidden_ssid_len, 32);\r\nstart = iwe_stream_add_point_rsl(info, start, stop, &iwe,\r\nnetwork->hidden_ssid);\r\n}\r\niwe.cmd = SIOCGIWNAME;\r\nfor (i = 0; i < ARRAY_SIZE(rtllib_modes); i++) {\r\nif (network->mode&(1<<i)) {\r\nsprintf(pname, rtllib_modes[i].mode_string,\r\nrtllib_modes[i].mode_size);\r\npname += rtllib_modes[i].mode_size;\r\n}\r\n}\r\n*pname = '\0';\r\nsnprintf(iwe.u.name, IFNAMSIZ, "IEEE802.11%s", proto_name);\r\nstart = iwe_stream_add_event_rsl(info, start, stop,\r\n&iwe, IW_EV_CHAR_LEN);\r\niwe.cmd = SIOCGIWMODE;\r\nif (network->capability &\r\n(WLAN_CAPABILITY_ESS | WLAN_CAPABILITY_IBSS)) {\r\nif (network->capability & WLAN_CAPABILITY_ESS)\r\niwe.u.mode = IW_MODE_MASTER;\r\nelse\r\niwe.u.mode = IW_MODE_ADHOC;\r\nstart = iwe_stream_add_event_rsl(info, start, stop,\r\n&iwe, IW_EV_UINT_LEN);\r\n}\r\niwe.cmd = SIOCGIWFREQ;\r\niwe.u.freq.m = network->channel;\r\niwe.u.freq.e = 0;\r\niwe.u.freq.i = 0;\r\nstart = iwe_stream_add_event_rsl(info, start, stop, &iwe,\r\nIW_EV_FREQ_LEN);\r\niwe.cmd = SIOCGIWENCODE;\r\nif (network->capability & WLAN_CAPABILITY_PRIVACY)\r\niwe.u.data.flags = IW_ENCODE_ENABLED | IW_ENCODE_NOKEY;\r\nelse\r\niwe.u.data.flags = IW_ENCODE_DISABLED;\r\niwe.u.data.length = 0;\r\nstart = iwe_stream_add_point_rsl(info, start, stop,\r\n&iwe, network->ssid);\r\nmax_rate = 0;\r\np = custom;\r\np += snprintf(p, MAX_CUSTOM_LEN - (p - custom), " Rates (Mb/s): ");\r\nfor (i = 0, j = 0; i < network->rates_len;) {\r\nif (j < network->rates_ex_len &&\r\n((network->rates_ex[j] & 0x7F) <\r\n(network->rates[i] & 0x7F)))\r\nrate = network->rates_ex[j++] & 0x7F;\r\nelse\r\nrate = network->rates[i++] & 0x7F;\r\nif (rate > max_rate)\r\nmax_rate = rate;\r\np += snprintf(p, MAX_CUSTOM_LEN - (p - custom),\r\n"%d%s ", rate >> 1, (rate & 1) ? ".5" : "");\r\n}\r\nfor (; j < network->rates_ex_len; j++) {\r\nrate = network->rates_ex[j] & 0x7F;\r\np += snprintf(p, MAX_CUSTOM_LEN - (p - custom),\r\n"%d%s ", rate >> 1, (rate & 1) ? ".5" : "");\r\nif (rate > max_rate)\r\nmax_rate = rate;\r\n}\r\nif (network->mode >= IEEE_N_24G) {\r\nstruct ht_capab_ele *ht_cap = NULL;\r\nbool is40M = false, isShortGI = false;\r\nu8 max_mcs = 0;\r\nif (!memcmp(network->bssht.bdHTCapBuf, EWC11NHTCap, 4))\r\nht_cap = (struct ht_capab_ele *)\r\n&network->bssht.bdHTCapBuf[4];\r\nelse\r\nht_cap = (struct ht_capab_ele *)\r\n&network->bssht.bdHTCapBuf[0];\r\nis40M = (ht_cap->ChlWidth) ? 1 : 0;\r\nisShortGI = (ht_cap->ChlWidth) ?\r\n((ht_cap->ShortGI40Mhz) ? 1 : 0) :\r\n((ht_cap->ShortGI20Mhz) ? 1 : 0);\r\nmax_mcs = HTGetHighestMCSRate(ieee, ht_cap->MCS,\r\nMCS_FILTER_ALL);\r\nrate = MCS_DATA_RATE[is40M][isShortGI][max_mcs & 0x7f];\r\nif (rate > max_rate)\r\nmax_rate = rate;\r\n}\r\niwe.cmd = SIOCGIWRATE;\r\niwe.u.bitrate.fixed = iwe.u.bitrate.disabled = 0;\r\niwe.u.bitrate.value = max_rate * 500000;\r\nstart = iwe_stream_add_event_rsl(info, start, stop, &iwe,\r\nIW_EV_PARAM_LEN);\r\niwe.cmd = IWEVCUSTOM;\r\niwe.u.data.length = p - custom;\r\nif (iwe.u.data.length)\r\nstart = iwe_stream_add_point_rsl(info, start, stop,\r\n&iwe, custom);\r\niwe.cmd = IWEVQUAL;\r\niwe.u.qual.qual = network->stats.signal;\r\niwe.u.qual.level = network->stats.rssi;\r\niwe.u.qual.noise = network->stats.noise;\r\niwe.u.qual.updated = network->stats.mask & RTLLIB_STATMASK_WEMASK;\r\nif (!(network->stats.mask & RTLLIB_STATMASK_RSSI))\r\niwe.u.qual.updated |= IW_QUAL_LEVEL_INVALID;\r\nif (!(network->stats.mask & RTLLIB_STATMASK_NOISE))\r\niwe.u.qual.updated |= IW_QUAL_NOISE_INVALID;\r\nif (!(network->stats.mask & RTLLIB_STATMASK_SIGNAL))\r\niwe.u.qual.updated |= IW_QUAL_QUAL_INVALID;\r\niwe.u.qual.updated = 7;\r\nstart = iwe_stream_add_event_rsl(info, start, stop, &iwe,\r\nIW_EV_QUAL_LEN);\r\niwe.cmd = IWEVCUSTOM;\r\np = custom;\r\niwe.u.data.length = p - custom;\r\nif (iwe.u.data.length)\r\nstart = iwe_stream_add_point_rsl(info, start, stop,\r\n&iwe, custom);\r\nmemset(&iwe, 0, sizeof(iwe));\r\nif (network->wpa_ie_len) {\r\nchar buf[MAX_WPA_IE_LEN];\r\nmemcpy(buf, network->wpa_ie, network->wpa_ie_len);\r\niwe.cmd = IWEVGENIE;\r\niwe.u.data.length = network->wpa_ie_len;\r\nstart = iwe_stream_add_point_rsl(info, start, stop, &iwe, buf);\r\n}\r\nmemset(&iwe, 0, sizeof(iwe));\r\nif (network->rsn_ie_len) {\r\nchar buf[MAX_WPA_IE_LEN];\r\nmemcpy(buf, network->rsn_ie, network->rsn_ie_len);\r\niwe.cmd = IWEVGENIE;\r\niwe.u.data.length = network->rsn_ie_len;\r\nstart = iwe_stream_add_point_rsl(info, start, stop, &iwe, buf);\r\n}\r\nmemset(&iwe, 0, sizeof(iwe));\r\nif (network->wzc_ie_len) {\r\nchar buf[MAX_WZC_IE_LEN];\r\nmemcpy(buf, network->wzc_ie, network->wzc_ie_len);\r\niwe.cmd = IWEVGENIE;\r\niwe.u.data.length = network->wzc_ie_len;\r\nstart = iwe_stream_add_point_rsl(info, start, stop, &iwe, buf);\r\n}\r\niwe.cmd = IWEVCUSTOM;\r\np = custom;\r\np += snprintf(p, MAX_CUSTOM_LEN - (p - custom),\r\n" Last beacon: %lums ago",\r\n(jiffies - network->last_scanned) / (HZ / 100));\r\niwe.u.data.length = p - custom;\r\nif (iwe.u.data.length)\r\nstart = iwe_stream_add_point_rsl(info, start, stop,\r\n&iwe, custom);\r\nreturn start;\r\n}\r\nint rtllib_wx_get_scan(struct rtllib_device *ieee,\r\nstruct iw_request_info *info,\r\nunion iwreq_data *wrqu, char *extra)\r\n{\r\nstruct rtllib_network *network;\r\nunsigned long flags;\r\nchar *ev = extra;\r\nchar *stop = ev + wrqu->data.length;\r\nint i = 0;\r\nint err = 0;\r\nnetdev_dbg(ieee->dev, "Getting scan\n");\r\ndown(&ieee->wx_sem);\r\nspin_lock_irqsave(&ieee->lock, flags);\r\nlist_for_each_entry(network, &ieee->network_list, list) {\r\ni++;\r\nif ((stop - ev) < 200) {\r\nerr = -E2BIG;\r\nbreak;\r\n}\r\nif (ieee->scan_age == 0 ||\r\ntime_after(network->last_scanned + ieee->scan_age, jiffies))\r\nev = rtl819x_translate_scan(ieee, ev, stop, network,\r\ninfo);\r\nelse\r\nnetdev_dbg(ieee->dev,\r\n"Network '%s ( %pM)' hidden due to age (%lums).\n",\r\nescape_essid(network->ssid,\r\nnetwork->ssid_len),\r\nnetwork->bssid,\r\n(jiffies - network->last_scanned) /\r\n(HZ / 100));\r\n}\r\nspin_unlock_irqrestore(&ieee->lock, flags);\r\nup(&ieee->wx_sem);\r\nwrqu->data.length = ev - extra;\r\nwrqu->data.flags = 0;\r\nnetdev_dbg(ieee->dev, "%s(): %d networks returned.\n", __func__, i);\r\nreturn err;\r\n}\r\nint rtllib_wx_set_encode(struct rtllib_device *ieee,\r\nstruct iw_request_info *info,\r\nunion iwreq_data *wrqu, char *keybuf)\r\n{\r\nstruct iw_point *erq = &(wrqu->encoding);\r\nstruct net_device *dev = ieee->dev;\r\nstruct rtllib_security sec = {\r\n.flags = 0\r\n};\r\nint i, key, key_provided, len;\r\nstruct lib80211_crypt_data **crypt;\r\nnetdev_dbg(ieee->dev, "%s()\n", __func__);\r\nkey = erq->flags & IW_ENCODE_INDEX;\r\nif (key) {\r\nif (key > NUM_WEP_KEYS)\r\nreturn -EINVAL;\r\nkey--;\r\nkey_provided = 1;\r\n} else {\r\nkey_provided = 0;\r\nkey = ieee->crypt_info.tx_keyidx;\r\n}\r\nnetdev_dbg(ieee->dev, "Key: %d [%s]\n", key, key_provided ?\r\n"provided" : "default");\r\ncrypt = &ieee->crypt_info.crypt[key];\r\nif (erq->flags & IW_ENCODE_DISABLED) {\r\nif (key_provided && *crypt) {\r\nnetdev_dbg(ieee->dev,\r\n"Disabling encryption on key %d.\n", key);\r\nlib80211_crypt_delayed_deinit(&ieee->crypt_info, crypt);\r\n} else\r\nnetdev_dbg(ieee->dev, "Disabling encryption.\n");\r\nfor (i = 0; i < NUM_WEP_KEYS; i++) {\r\nif (ieee->crypt_info.crypt[i] != NULL) {\r\nif (key_provided)\r\nbreak;\r\nlib80211_crypt_delayed_deinit(&ieee->crypt_info,\r\n&ieee->crypt_info.crypt[i]);\r\n}\r\n}\r\nif (i == NUM_WEP_KEYS) {\r\nsec.enabled = 0;\r\nsec.level = SEC_LEVEL_0;\r\nsec.flags |= SEC_ENABLED | SEC_LEVEL;\r\n}\r\ngoto done;\r\n}\r\nsec.enabled = 1;\r\nsec.flags |= SEC_ENABLED;\r\nif (*crypt != NULL && (*crypt)->ops != NULL &&\r\nstrcmp((*crypt)->ops->name, "R-WEP") != 0) {\r\nlib80211_crypt_delayed_deinit(&ieee->crypt_info, crypt);\r\n}\r\nif (*crypt == NULL) {\r\nstruct lib80211_crypt_data *new_crypt;\r\nnew_crypt = kzalloc(sizeof(struct lib80211_crypt_data),\r\nGFP_KERNEL);\r\nif (new_crypt == NULL)\r\nreturn -ENOMEM;\r\nnew_crypt->ops = lib80211_get_crypto_ops("R-WEP");\r\nif (!new_crypt->ops) {\r\nrequest_module("rtllib_crypt_wep");\r\nnew_crypt->ops = lib80211_get_crypto_ops("R-WEP");\r\n}\r\nif (new_crypt->ops)\r\nnew_crypt->priv = new_crypt->ops->init(key);\r\nif (!new_crypt->ops || !new_crypt->priv) {\r\nkfree(new_crypt);\r\nnew_crypt = NULL;\r\nnetdev_warn(dev,\r\n"%s: could not initialize WEP: load module rtllib_crypt_wep\n",\r\ndev->name);\r\nreturn -EOPNOTSUPP;\r\n}\r\n*crypt = new_crypt;\r\n}\r\nif (erq->length > 0) {\r\nlen = erq->length <= 5 ? 5 : 13;\r\nmemcpy(sec.keys[key], keybuf, erq->length);\r\nif (len > erq->length)\r\nmemset(sec.keys[key] + erq->length, 0,\r\nlen - erq->length);\r\nnetdev_dbg(ieee->dev, "Setting key %d to '%s' (%d:%d bytes)\n",\r\nkey, escape_essid(sec.keys[key], len), erq->length,\r\nlen);\r\nsec.key_sizes[key] = len;\r\n(*crypt)->ops->set_key(sec.keys[key], len, NULL,\r\n(*crypt)->priv);\r\nsec.flags |= (1 << key);\r\nif (key == sec.active_key)\r\nsec.flags |= SEC_ACTIVE_KEY;\r\nieee->crypt_info.tx_keyidx = key;\r\n} else {\r\nlen = (*crypt)->ops->get_key(sec.keys[key], WEP_KEY_LEN,\r\nNULL, (*crypt)->priv);\r\nif (len == 0) {\r\nnetdev_info(ieee->dev, "Setting key %d to all zero.\n",\r\nkey);\r\nmemset(sec.keys[key], 0, 13);\r\n(*crypt)->ops->set_key(sec.keys[key], 13, NULL,\r\n(*crypt)->priv);\r\nsec.key_sizes[key] = 13;\r\nsec.flags |= (1 << key);\r\n}\r\nif (key_provided) {\r\nnetdev_dbg(ieee->dev,\r\n"Setting key %d as default Tx key.\n", key);\r\nieee->crypt_info.tx_keyidx = key;\r\nsec.active_key = key;\r\nsec.flags |= SEC_ACTIVE_KEY;\r\n}\r\n}\r\ndone:\r\nieee->open_wep = !(erq->flags & IW_ENCODE_RESTRICTED);\r\nieee->auth_mode = ieee->open_wep ? WLAN_AUTH_OPEN :\r\nWLAN_AUTH_SHARED_KEY;\r\nsec.auth_mode = ieee->open_wep ? WLAN_AUTH_OPEN : WLAN_AUTH_SHARED_KEY;\r\nsec.flags |= SEC_AUTH_MODE;\r\nnetdev_dbg(ieee->dev, "Auth: %s\n", sec.auth_mode == WLAN_AUTH_OPEN ?\r\n"OPEN" : "SHARED KEY");\r\nsec.flags |= SEC_LEVEL;\r\nsec.level = SEC_LEVEL_1;\r\nif (ieee->set_security)\r\nieee->set_security(dev, &sec);\r\nif (ieee->reset_on_keychange &&\r\nieee->iw_mode != IW_MODE_INFRA &&\r\nieee->reset_port && ieee->reset_port(dev)) {\r\nnetdev_dbg(dev, "%s: reset_port failed\n", dev->name);\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nint rtllib_wx_get_encode(struct rtllib_device *ieee,\r\nstruct iw_request_info *info,\r\nunion iwreq_data *wrqu, char *keybuf)\r\n{\r\nstruct iw_point *erq = &(wrqu->encoding);\r\nint len, key;\r\nstruct lib80211_crypt_data *crypt;\r\nnetdev_dbg(ieee->dev, "%s()\n", __func__);\r\nif (ieee->iw_mode == IW_MODE_MONITOR)\r\nreturn -1;\r\nkey = erq->flags & IW_ENCODE_INDEX;\r\nif (key) {\r\nif (key > NUM_WEP_KEYS)\r\nreturn -EINVAL;\r\nkey--;\r\n} else {\r\nkey = ieee->crypt_info.tx_keyidx;\r\n}\r\ncrypt = ieee->crypt_info.crypt[key];\r\nerq->flags = key + 1;\r\nif (crypt == NULL || crypt->ops == NULL) {\r\nerq->length = 0;\r\nerq->flags |= IW_ENCODE_DISABLED;\r\nreturn 0;\r\n}\r\nlen = crypt->ops->get_key(keybuf, SCM_KEY_LEN, NULL, crypt->priv);\r\nerq->length = max(len, 0);\r\nerq->flags |= IW_ENCODE_ENABLED;\r\nif (ieee->open_wep)\r\nerq->flags |= IW_ENCODE_OPEN;\r\nelse\r\nerq->flags |= IW_ENCODE_RESTRICTED;\r\nreturn 0;\r\n}\r\nint rtllib_wx_set_encode_ext(struct rtllib_device *ieee,\r\nstruct iw_request_info *info,\r\nunion iwreq_data *wrqu, char *extra)\r\n{\r\nint ret = 0;\r\nstruct net_device *dev = ieee->dev;\r\nstruct iw_point *encoding = &wrqu->encoding;\r\nstruct iw_encode_ext *ext = (struct iw_encode_ext *)extra;\r\nint i, idx;\r\nint group_key = 0;\r\nconst char *alg, *module;\r\nstruct lib80211_crypto_ops *ops;\r\nstruct lib80211_crypt_data **crypt;\r\nstruct rtllib_security sec = {\r\n.flags = 0,\r\n};\r\nidx = encoding->flags & IW_ENCODE_INDEX;\r\nif (idx) {\r\nif (idx < 1 || idx > NUM_WEP_KEYS)\r\nreturn -EINVAL;\r\nidx--;\r\n} else{\r\nidx = ieee->crypt_info.tx_keyidx;\r\n}\r\nif (ext->ext_flags & IW_ENCODE_EXT_GROUP_KEY) {\r\ncrypt = &ieee->crypt_info.crypt[idx];\r\ngroup_key = 1;\r\n} else {\r\nif (idx != 0 && ext->alg != IW_ENCODE_ALG_WEP)\r\nreturn -EINVAL;\r\nif (ieee->iw_mode == IW_MODE_INFRA)\r\ncrypt = &ieee->crypt_info.crypt[idx];\r\nelse\r\nreturn -EINVAL;\r\n}\r\nsec.flags |= SEC_ENABLED;\r\nif ((encoding->flags & IW_ENCODE_DISABLED) ||\r\next->alg == IW_ENCODE_ALG_NONE) {\r\nif (*crypt)\r\nlib80211_crypt_delayed_deinit(&ieee->crypt_info, crypt);\r\nfor (i = 0; i < NUM_WEP_KEYS; i++) {\r\nif (ieee->crypt_info.crypt[i] != NULL)\r\nbreak;\r\n}\r\nif (i == NUM_WEP_KEYS) {\r\nsec.enabled = 0;\r\nsec.level = SEC_LEVEL_0;\r\nsec.flags |= SEC_LEVEL;\r\n}\r\ngoto done;\r\n}\r\nsec.enabled = 1;\r\nswitch (ext->alg) {\r\ncase IW_ENCODE_ALG_WEP:\r\nalg = "R-WEP";\r\nmodule = "rtllib_crypt_wep";\r\nbreak;\r\ncase IW_ENCODE_ALG_TKIP:\r\nalg = "R-TKIP";\r\nmodule = "rtllib_crypt_tkip";\r\nbreak;\r\ncase IW_ENCODE_ALG_CCMP:\r\nalg = "R-CCMP";\r\nmodule = "rtllib_crypt_ccmp";\r\nbreak;\r\ndefault:\r\nnetdev_dbg(ieee->dev, "Unknown crypto alg %d\n", ext->alg);\r\nret = -EINVAL;\r\ngoto done;\r\n}\r\nnetdev_info(dev, "alg name:%s\n", alg);\r\nops = lib80211_get_crypto_ops(alg);\r\nif (ops == NULL) {\r\nchar tempbuf[100];\r\nmemset(tempbuf, 0x00, 100);\r\nsprintf(tempbuf, "%s", module);\r\nrequest_module("%s", tempbuf);\r\nops = lib80211_get_crypto_ops(alg);\r\n}\r\nif (ops == NULL) {\r\nnetdev_info(dev, "========>unknown crypto alg %d\n", ext->alg);\r\nret = -EINVAL;\r\ngoto done;\r\n}\r\nif (*crypt == NULL || (*crypt)->ops != ops) {\r\nstruct lib80211_crypt_data *new_crypt;\r\nlib80211_crypt_delayed_deinit(&ieee->crypt_info, crypt);\r\nnew_crypt = kzalloc(sizeof(*new_crypt), GFP_KERNEL);\r\nif (new_crypt == NULL) {\r\nret = -ENOMEM;\r\ngoto done;\r\n}\r\nnew_crypt->ops = ops;\r\nif (new_crypt->ops && try_module_get(new_crypt->ops->owner))\r\nnew_crypt->priv = new_crypt->ops->init(idx);\r\nif (new_crypt->priv == NULL) {\r\nkfree(new_crypt);\r\nret = -EINVAL;\r\ngoto done;\r\n}\r\n*crypt = new_crypt;\r\n}\r\nif (ext->key_len > 0 && (*crypt)->ops->set_key &&\r\n(*crypt)->ops->set_key(ext->key, ext->key_len, ext->rx_seq,\r\n(*crypt)->priv) < 0) {\r\nnetdev_info(dev, "key setting failed\n");\r\nret = -EINVAL;\r\ngoto done;\r\n}\r\nif (ext->ext_flags & IW_ENCODE_EXT_SET_TX_KEY) {\r\nieee->crypt_info.tx_keyidx = idx;\r\nsec.active_key = idx;\r\nsec.flags |= SEC_ACTIVE_KEY;\r\n}\r\nif (ext->alg != IW_ENCODE_ALG_NONE) {\r\nsec.key_sizes[idx] = ext->key_len;\r\nsec.flags |= (1 << idx);\r\nif (ext->alg == IW_ENCODE_ALG_WEP) {\r\nsec.flags |= SEC_LEVEL;\r\nsec.level = SEC_LEVEL_1;\r\n} else if (ext->alg == IW_ENCODE_ALG_TKIP) {\r\nsec.flags |= SEC_LEVEL;\r\nsec.level = SEC_LEVEL_2;\r\n} else if (ext->alg == IW_ENCODE_ALG_CCMP) {\r\nsec.flags |= SEC_LEVEL;\r\nsec.level = SEC_LEVEL_3;\r\n}\r\nif (group_key)\r\nsec.flags &= ~SEC_LEVEL;\r\n}\r\ndone:\r\nif (ieee->set_security)\r\nieee->set_security(ieee->dev, &sec);\r\nif (ieee->reset_on_keychange &&\r\nieee->iw_mode != IW_MODE_INFRA &&\r\nieee->reset_port && ieee->reset_port(dev)) {\r\nnetdev_dbg(ieee->dev, "Port reset failed\n");\r\nreturn -EINVAL;\r\n}\r\nreturn ret;\r\n}\r\nint rtllib_wx_set_mlme(struct rtllib_device *ieee,\r\nstruct iw_request_info *info,\r\nunion iwreq_data *wrqu, char *extra)\r\n{\r\nu8 i = 0;\r\nbool deauth = false;\r\nstruct iw_mlme *mlme = (struct iw_mlme *) extra;\r\nif (ieee->state != RTLLIB_LINKED)\r\nreturn -ENOLINK;\r\ndown(&ieee->wx_sem);\r\nswitch (mlme->cmd) {\r\ncase IW_MLME_DEAUTH:\r\ndeauth = true;\r\ncase IW_MLME_DISASSOC:\r\nif (deauth)\r\nnetdev_info(ieee->dev, "disauth packet !\n");\r\nelse\r\nnetdev_info(ieee->dev, "dis associate packet!\n");\r\nieee->cannot_notify = true;\r\nSendDisassociation(ieee, deauth, mlme->reason_code);\r\nrtllib_disassociate(ieee);\r\nieee->wap_set = 0;\r\nfor (i = 0; i < 6; i++)\r\nieee->current_network.bssid[i] = 0x55;\r\nieee->ssid_set = 0;\r\nieee->current_network.ssid[0] = '\0';\r\nieee->current_network.ssid_len = 0;\r\nbreak;\r\ndefault:\r\nup(&ieee->wx_sem);\r\nreturn -EOPNOTSUPP;\r\n}\r\nup(&ieee->wx_sem);\r\nreturn 0;\r\n}\r\nint rtllib_wx_set_auth(struct rtllib_device *ieee,\r\nstruct iw_request_info *info,\r\nstruct iw_param *data, char *extra)\r\n{\r\nswitch (data->flags & IW_AUTH_INDEX) {\r\ncase IW_AUTH_WPA_VERSION:\r\nbreak;\r\ncase IW_AUTH_CIPHER_PAIRWISE:\r\ncase IW_AUTH_CIPHER_GROUP:\r\ncase IW_AUTH_KEY_MGMT:\r\nbreak;\r\ncase IW_AUTH_TKIP_COUNTERMEASURES:\r\nieee->tkip_countermeasures = data->value;\r\nbreak;\r\ncase IW_AUTH_DROP_UNENCRYPTED:\r\nieee->drop_unencrypted = data->value;\r\nbreak;\r\ncase IW_AUTH_80211_AUTH_ALG:\r\nif (data->value & IW_AUTH_ALG_SHARED_KEY) {\r\nieee->open_wep = 0;\r\nieee->auth_mode = 1;\r\n} else if (data->value & IW_AUTH_ALG_OPEN_SYSTEM) {\r\nieee->open_wep = 1;\r\nieee->auth_mode = 0;\r\n} else if (data->value & IW_AUTH_ALG_LEAP) {\r\nieee->open_wep = 1;\r\nieee->auth_mode = 2;\r\n} else\r\nreturn -EINVAL;\r\nbreak;\r\ncase IW_AUTH_WPA_ENABLED:\r\nieee->wpa_enabled = (data->value) ? 1 : 0;\r\nbreak;\r\ncase IW_AUTH_RX_UNENCRYPTED_EAPOL:\r\nieee->ieee802_1x = data->value;\r\nbreak;\r\ncase IW_AUTH_PRIVACY_INVOKED:\r\nieee->privacy_invoked = data->value;\r\nbreak;\r\ndefault:\r\nreturn -EOPNOTSUPP;\r\n}\r\nreturn 0;\r\n}\r\nint rtllib_wx_set_gen_ie(struct rtllib_device *ieee, u8 *ie, size_t len)\r\n{\r\nu8 *buf;\r\nu8 eid, wps_oui[4] = {0x0, 0x50, 0xf2, 0x04};\r\nif (len > MAX_WPA_IE_LEN || (len && ie == NULL))\r\nreturn -EINVAL;\r\nif (len) {\r\neid = ie[0];\r\nif ((eid == MFIE_TYPE_GENERIC) && (!memcmp(&ie[2],\r\nwps_oui, 4))) {\r\nieee->wps_ie_len = min_t(size_t, len, MAX_WZC_IE_LEN);\r\nbuf = kmemdup(ie, ieee->wps_ie_len, GFP_KERNEL);\r\nif (buf == NULL)\r\nreturn -ENOMEM;\r\nieee->wps_ie = buf;\r\nreturn 0;\r\n}\r\n}\r\nieee->wps_ie_len = 0;\r\nkfree(ieee->wps_ie);\r\nieee->wps_ie = NULL;\r\nif (len) {\r\nif (len != ie[1]+2)\r\nreturn -EINVAL;\r\nbuf = kmemdup(ie, len, GFP_KERNEL);\r\nif (buf == NULL)\r\nreturn -ENOMEM;\r\nkfree(ieee->wpa_ie);\r\nieee->wpa_ie = buf;\r\nieee->wpa_ie_len = len;\r\n} else {\r\nkfree(ieee->wpa_ie);\r\nieee->wpa_ie = NULL;\r\nieee->wpa_ie_len = 0;\r\n}\r\nreturn 0;\r\n}
