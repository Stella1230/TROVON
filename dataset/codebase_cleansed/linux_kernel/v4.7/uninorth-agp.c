static int uninorth_fetch_size(void)\r\n{\r\nint i, size = 0;\r\nstruct aper_size_info_32 *values =\r\nA_SIZE_32(agp_bridge->driver->aperture_sizes);\r\nif (aperture) {\r\nchar *save = aperture;\r\nsize = memparse(aperture, &aperture) >> 20;\r\naperture = save;\r\nfor (i = 0; i < agp_bridge->driver->num_aperture_sizes; i++)\r\nif (size == values[i].size)\r\nbreak;\r\nif (i == agp_bridge->driver->num_aperture_sizes) {\r\ndev_err(&agp_bridge->dev->dev, "invalid aperture size, "\r\n"using default\n");\r\nsize = 0;\r\naperture = NULL;\r\n}\r\n}\r\nif (!size) {\r\nfor (i = 0; i < agp_bridge->driver->num_aperture_sizes; i++)\r\nif (values[i].size == DEFAULT_APERTURE_SIZE)\r\nbreak;\r\n}\r\nagp_bridge->previous_size =\r\nagp_bridge->current_size = (void *)(values + i);\r\nagp_bridge->aperture_size_idx = i;\r\nreturn values[i].size;\r\n}\r\nstatic void uninorth_tlbflush(struct agp_memory *mem)\r\n{\r\nu32 ctrl = UNI_N_CFG_GART_ENABLE;\r\nif (is_u3)\r\nctrl |= U3_N_CFG_GART_PERFRD;\r\npci_write_config_dword(agp_bridge->dev, UNI_N_CFG_GART_CTRL,\r\nctrl | UNI_N_CFG_GART_INVAL);\r\npci_write_config_dword(agp_bridge->dev, UNI_N_CFG_GART_CTRL, ctrl);\r\nif (!mem && uninorth_rev <= 0x30) {\r\npci_write_config_dword(agp_bridge->dev, UNI_N_CFG_GART_CTRL,\r\nctrl | UNI_N_CFG_GART_2xRESET);\r\npci_write_config_dword(agp_bridge->dev, UNI_N_CFG_GART_CTRL,\r\nctrl);\r\n}\r\n}\r\nstatic void uninorth_cleanup(void)\r\n{\r\nu32 tmp;\r\npci_read_config_dword(agp_bridge->dev, UNI_N_CFG_GART_CTRL, &tmp);\r\nif (!(tmp & UNI_N_CFG_GART_ENABLE))\r\nreturn;\r\ntmp |= UNI_N_CFG_GART_INVAL;\r\npci_write_config_dword(agp_bridge->dev, UNI_N_CFG_GART_CTRL, tmp);\r\npci_write_config_dword(agp_bridge->dev, UNI_N_CFG_GART_CTRL, 0);\r\nif (uninorth_rev <= 0x30) {\r\npci_write_config_dword(agp_bridge->dev, UNI_N_CFG_GART_CTRL,\r\nUNI_N_CFG_GART_2xRESET);\r\npci_write_config_dword(agp_bridge->dev, UNI_N_CFG_GART_CTRL,\r\n0);\r\n}\r\n}\r\nstatic int uninorth_configure(void)\r\n{\r\nstruct aper_size_info_32 *current_size;\r\ncurrent_size = A_SIZE_32(agp_bridge->current_size);\r\ndev_info(&agp_bridge->dev->dev, "configuring for size idx: %d\n",\r\ncurrent_size->size_value);\r\npci_write_config_dword(agp_bridge->dev,\r\nUNI_N_CFG_GART_BASE,\r\n(agp_bridge->gatt_bus_addr & 0xfffff000)\r\n| current_size->size_value);\r\nagp_bridge->gart_bus_addr = 0;\r\n#ifdef CONFIG_PPC64\r\npci_write_config_dword(agp_bridge->dev, UNI_N_CFG_AGP_BASE,\r\n(agp_bridge->gatt_bus_addr >> 32) & 0xf);\r\n#else\r\npci_write_config_dword(agp_bridge->dev,\r\nUNI_N_CFG_AGP_BASE, agp_bridge->gart_bus_addr);\r\n#endif\r\nif (is_u3) {\r\npci_write_config_dword(agp_bridge->dev,\r\nUNI_N_CFG_GART_DUMMY_PAGE,\r\npage_to_phys(agp_bridge->scratch_page_page) >> 12);\r\n}\r\nreturn 0;\r\n}\r\nstatic int uninorth_insert_memory(struct agp_memory *mem, off_t pg_start, int type)\r\n{\r\nint i, num_entries;\r\nvoid *temp;\r\nu32 *gp;\r\nint mask_type;\r\nif (type != mem->type)\r\nreturn -EINVAL;\r\nmask_type = agp_bridge->driver->agp_type_to_mask_type(agp_bridge, type);\r\nif (mask_type != 0) {\r\nreturn -EINVAL;\r\n}\r\nif (mem->page_count == 0)\r\nreturn 0;\r\ntemp = agp_bridge->current_size;\r\nnum_entries = A_SIZE_32(temp)->num_entries;\r\nif ((pg_start + mem->page_count) > num_entries)\r\nreturn -EINVAL;\r\ngp = (u32 *) &agp_bridge->gatt_table[pg_start];\r\nfor (i = 0; i < mem->page_count; ++i) {\r\nif (gp[i] != scratch_value) {\r\ndev_info(&agp_bridge->dev->dev,\r\n"uninorth_insert_memory: entry 0x%x occupied (%x)\n",\r\ni, gp[i]);\r\nreturn -EBUSY;\r\n}\r\n}\r\nfor (i = 0; i < mem->page_count; i++) {\r\nif (is_u3)\r\ngp[i] = (page_to_phys(mem->pages[i]) >> PAGE_SHIFT) | 0x80000000UL;\r\nelse\r\ngp[i] = cpu_to_le32((page_to_phys(mem->pages[i]) & 0xFFFFF000UL) |\r\n0x1UL);\r\nflush_dcache_range((unsigned long)__va(page_to_phys(mem->pages[i])),\r\n(unsigned long)__va(page_to_phys(mem->pages[i]))+0x1000);\r\n}\r\nmb();\r\nuninorth_tlbflush(mem);\r\nreturn 0;\r\n}\r\nint uninorth_remove_memory(struct agp_memory *mem, off_t pg_start, int type)\r\n{\r\nsize_t i;\r\nu32 *gp;\r\nint mask_type;\r\nif (type != mem->type)\r\nreturn -EINVAL;\r\nmask_type = agp_bridge->driver->agp_type_to_mask_type(agp_bridge, type);\r\nif (mask_type != 0) {\r\nreturn -EINVAL;\r\n}\r\nif (mem->page_count == 0)\r\nreturn 0;\r\ngp = (u32 *) &agp_bridge->gatt_table[pg_start];\r\nfor (i = 0; i < mem->page_count; ++i) {\r\ngp[i] = scratch_value;\r\n}\r\nmb();\r\nuninorth_tlbflush(mem);\r\nreturn 0;\r\n}\r\nstatic void uninorth_agp_enable(struct agp_bridge_data *bridge, u32 mode)\r\n{\r\nu32 command, scratch, status;\r\nint timeout;\r\npci_read_config_dword(bridge->dev,\r\nbridge->capndx + PCI_AGP_STATUS,\r\n&status);\r\ncommand = agp_collect_device_status(bridge, mode, status);\r\ncommand |= PCI_AGP_COMMAND_AGP;\r\nif (uninorth_rev == 0x21) {\r\ncommand &= ~AGPSTAT2_4X;\r\n}\r\nif ((uninorth_rev >= 0x30) && (uninorth_rev <= 0x33)) {\r\nif ((command >> AGPSTAT_RQ_DEPTH_SHIFT) > 7)\r\ncommand = (command & ~AGPSTAT_RQ_DEPTH)\r\n| (7 << AGPSTAT_RQ_DEPTH_SHIFT);\r\n}\r\nuninorth_tlbflush(NULL);\r\ntimeout = 0;\r\ndo {\r\npci_write_config_dword(bridge->dev,\r\nbridge->capndx + PCI_AGP_COMMAND,\r\ncommand);\r\npci_read_config_dword(bridge->dev,\r\nbridge->capndx + PCI_AGP_COMMAND,\r\n&scratch);\r\n} while ((scratch & PCI_AGP_COMMAND_AGP) == 0 && ++timeout < 1000);\r\nif ((scratch & PCI_AGP_COMMAND_AGP) == 0)\r\ndev_err(&bridge->dev->dev, "can't write UniNorth AGP "\r\n"command register\n");\r\nif (uninorth_rev >= 0x30) {\r\nagp_device_command(command, (status & AGPSTAT_MODE_3_0) != 0);\r\n} else {\r\nagp_device_command(command, false);\r\n}\r\nuninorth_tlbflush(NULL);\r\n}\r\nstatic int agp_uninorth_suspend(struct pci_dev *pdev)\r\n{\r\nstruct agp_bridge_data *bridge;\r\nu32 cmd;\r\nu8 agp;\r\nstruct pci_dev *device = NULL;\r\nbridge = agp_find_bridge(pdev);\r\nif (bridge == NULL)\r\nreturn -ENODEV;\r\nif (bridge->dev_private_data)\r\nreturn 0;\r\nfor_each_pci_dev(device) {\r\nif (device == pdev)\r\ncontinue;\r\nif (device->bus != pdev->bus)\r\ncontinue;\r\nagp = pci_find_capability(device, PCI_CAP_ID_AGP);\r\nif (!agp)\r\ncontinue;\r\npci_read_config_dword(device, agp + PCI_AGP_COMMAND, &cmd);\r\nif (!(cmd & PCI_AGP_COMMAND_AGP))\r\ncontinue;\r\ndev_info(&pdev->dev, "disabling AGP on device %s\n",\r\npci_name(device));\r\ncmd &= ~PCI_AGP_COMMAND_AGP;\r\npci_write_config_dword(device, agp + PCI_AGP_COMMAND, cmd);\r\n}\r\nagp = pci_find_capability(pdev, PCI_CAP_ID_AGP);\r\npci_read_config_dword(pdev, agp + PCI_AGP_COMMAND, &cmd);\r\nbridge->dev_private_data = (void *)(long)cmd;\r\nif (cmd & PCI_AGP_COMMAND_AGP) {\r\ndev_info(&pdev->dev, "disabling AGP on bridge\n");\r\ncmd &= ~PCI_AGP_COMMAND_AGP;\r\npci_write_config_dword(pdev, agp + PCI_AGP_COMMAND, cmd);\r\n}\r\nuninorth_cleanup();\r\nreturn 0;\r\n}\r\nstatic int agp_uninorth_resume(struct pci_dev *pdev)\r\n{\r\nstruct agp_bridge_data *bridge;\r\nu32 command;\r\nbridge = agp_find_bridge(pdev);\r\nif (bridge == NULL)\r\nreturn -ENODEV;\r\ncommand = (long)bridge->dev_private_data;\r\nbridge->dev_private_data = NULL;\r\nif (!(command & PCI_AGP_COMMAND_AGP))\r\nreturn 0;\r\nuninorth_agp_enable(bridge, command);\r\nreturn 0;\r\n}\r\nstatic int uninorth_create_gatt_table(struct agp_bridge_data *bridge)\r\n{\r\nchar *table;\r\nchar *table_end;\r\nint size;\r\nint page_order;\r\nint num_entries;\r\nint i;\r\nvoid *temp;\r\nstruct page *page;\r\nif (bridge->driver->size_type == LVL2_APER_SIZE)\r\nreturn -EINVAL;\r\ntable = NULL;\r\ni = bridge->aperture_size_idx;\r\ntemp = bridge->current_size;\r\nsize = page_order = num_entries = 0;\r\ndo {\r\nsize = A_SIZE_32(temp)->size;\r\npage_order = A_SIZE_32(temp)->page_order;\r\nnum_entries = A_SIZE_32(temp)->num_entries;\r\ntable = (char *) __get_free_pages(GFP_KERNEL, page_order);\r\nif (table == NULL) {\r\ni++;\r\nbridge->current_size = A_IDX32(bridge);\r\n} else {\r\nbridge->aperture_size_idx = i;\r\n}\r\n} while (!table && (i < bridge->driver->num_aperture_sizes));\r\nif (table == NULL)\r\nreturn -ENOMEM;\r\nuninorth_priv.pages_arr = kmalloc((1 << page_order) * sizeof(struct page*), GFP_KERNEL);\r\nif (uninorth_priv.pages_arr == NULL)\r\ngoto enomem;\r\ntable_end = table + ((PAGE_SIZE * (1 << page_order)) - 1);\r\nfor (page = virt_to_page(table), i = 0; page <= virt_to_page(table_end);\r\npage++, i++) {\r\nSetPageReserved(page);\r\nuninorth_priv.pages_arr[i] = page;\r\n}\r\nbridge->gatt_table_real = (u32 *) table;\r\nflush_dcache_range((unsigned long)table,\r\n(unsigned long)table_end + 1);\r\nbridge->gatt_table = vmap(uninorth_priv.pages_arr, (1 << page_order), 0, PAGE_KERNEL_NCG);\r\nif (bridge->gatt_table == NULL)\r\ngoto enomem;\r\nbridge->gatt_bus_addr = virt_to_phys(table);\r\nif (is_u3)\r\nscratch_value = (page_to_phys(agp_bridge->scratch_page_page) >> PAGE_SHIFT) | 0x80000000UL;\r\nelse\r\nscratch_value = cpu_to_le32((page_to_phys(agp_bridge->scratch_page_page) & 0xFFFFF000UL) |\r\n0x1UL);\r\nfor (i = 0; i < num_entries; i++)\r\nbridge->gatt_table[i] = scratch_value;\r\nreturn 0;\r\nenomem:\r\nkfree(uninorth_priv.pages_arr);\r\nif (table)\r\nfree_pages((unsigned long)table, page_order);\r\nreturn -ENOMEM;\r\n}\r\nstatic int uninorth_free_gatt_table(struct agp_bridge_data *bridge)\r\n{\r\nint page_order;\r\nchar *table, *table_end;\r\nvoid *temp;\r\nstruct page *page;\r\ntemp = bridge->current_size;\r\npage_order = A_SIZE_32(temp)->page_order;\r\nvunmap(bridge->gatt_table);\r\nkfree(uninorth_priv.pages_arr);\r\ntable = (char *) bridge->gatt_table_real;\r\ntable_end = table + ((PAGE_SIZE * (1 << page_order)) - 1);\r\nfor (page = virt_to_page(table); page <= virt_to_page(table_end); page++)\r\nClearPageReserved(page);\r\nfree_pages((unsigned long) bridge->gatt_table_real, page_order);\r\nreturn 0;\r\n}\r\nvoid null_cache_flush(void)\r\n{\r\nmb();\r\n}\r\nstatic int agp_uninorth_probe(struct pci_dev *pdev,\r\nconst struct pci_device_id *ent)\r\n{\r\nstruct agp_device_ids *devs = uninorth_agp_device_ids;\r\nstruct agp_bridge_data *bridge;\r\nstruct device_node *uninorth_node;\r\nu8 cap_ptr;\r\nint j;\r\ncap_ptr = pci_find_capability(pdev, PCI_CAP_ID_AGP);\r\nif (cap_ptr == 0)\r\nreturn -ENODEV;\r\nfor (j = 0; devs[j].chipset_name != NULL; ++j) {\r\nif (pdev->device == devs[j].device_id) {\r\ndev_info(&pdev->dev, "Apple %s chipset\n",\r\ndevs[j].chipset_name);\r\ngoto found;\r\n}\r\n}\r\ndev_err(&pdev->dev, "unsupported Apple chipset [%04x/%04x]\n",\r\npdev->vendor, pdev->device);\r\nreturn -ENODEV;\r\nfound:\r\nuninorth_rev = 0;\r\nis_u3 = 0;\r\nuninorth_node = of_find_node_by_name(NULL, "uni-n");\r\nif (uninorth_node == NULL) {\r\nis_u3 = 1;\r\nuninorth_node = of_find_node_by_name(NULL, "u3");\r\n}\r\nif (uninorth_node) {\r\nconst int *revprop = of_get_property(uninorth_node,\r\n"device-rev", NULL);\r\nif (revprop != NULL)\r\nuninorth_rev = *revprop & 0x3f;\r\nof_node_put(uninorth_node);\r\n}\r\n#ifdef CONFIG_PM\r\npmac_register_agp_pm(pdev, agp_uninorth_suspend, agp_uninorth_resume);\r\n#endif\r\nbridge = agp_alloc_bridge();\r\nif (!bridge)\r\nreturn -ENOMEM;\r\nif (is_u3)\r\nbridge->driver = &u3_agp_driver;\r\nelse\r\nbridge->driver = &uninorth_agp_driver;\r\nbridge->dev = pdev;\r\nbridge->capndx = cap_ptr;\r\nbridge->flags = AGP_ERRATA_FASTWRITES;\r\npci_read_config_dword(pdev, cap_ptr+PCI_AGP_STATUS, &bridge->mode);\r\npci_set_drvdata(pdev, bridge);\r\nreturn agp_add_bridge(bridge);\r\n}\r\nstatic void agp_uninorth_remove(struct pci_dev *pdev)\r\n{\r\nstruct agp_bridge_data *bridge = pci_get_drvdata(pdev);\r\n#ifdef CONFIG_PM\r\npmac_register_agp_pm(pdev, NULL, NULL);\r\n#endif\r\nagp_remove_bridge(bridge);\r\nagp_put_bridge(bridge);\r\n}\r\nstatic int __init agp_uninorth_init(void)\r\n{\r\nif (agp_off)\r\nreturn -EINVAL;\r\nreturn pci_register_driver(&agp_uninorth_pci_driver);\r\n}\r\nstatic void __exit agp_uninorth_cleanup(void)\r\n{\r\npci_unregister_driver(&agp_uninorth_pci_driver);\r\n}
