static inline void img_i2s_in_writel(struct img_i2s_in *i2s, u32 val, u32 reg)\r\n{\r\nwritel(val, i2s->base + reg);\r\n}\r\nstatic inline u32 img_i2s_in_readl(struct img_i2s_in *i2s, u32 reg)\r\n{\r\nreturn readl(i2s->base + reg);\r\n}\r\nstatic inline void img_i2s_in_ch_writel(struct img_i2s_in *i2s, u32 chan,\r\nu32 val, u32 reg)\r\n{\r\nwritel(val, i2s->channel_base + (chan * IMG_I2S_IN_CH_STRIDE) + reg);\r\n}\r\nstatic inline u32 img_i2s_in_ch_readl(struct img_i2s_in *i2s, u32 chan,\r\nu32 reg)\r\n{\r\nreturn readl(i2s->channel_base + (chan * IMG_I2S_IN_CH_STRIDE) + reg);\r\n}\r\nstatic inline void img_i2s_in_ch_disable(struct img_i2s_in *i2s, u32 chan)\r\n{\r\nu32 reg;\r\nreg = img_i2s_in_ch_readl(i2s, chan, IMG_I2S_IN_CH_CTL);\r\nreg &= ~IMG_I2S_IN_CH_CTL_ME_MASK;\r\nimg_i2s_in_ch_writel(i2s, chan, reg, IMG_I2S_IN_CH_CTL);\r\n}\r\nstatic inline void img_i2s_in_ch_enable(struct img_i2s_in *i2s, u32 chan)\r\n{\r\nu32 reg;\r\nreg = img_i2s_in_ch_readl(i2s, chan, IMG_I2S_IN_CH_CTL);\r\nreg |= IMG_I2S_IN_CH_CTL_ME_MASK;\r\nimg_i2s_in_ch_writel(i2s, chan, reg, IMG_I2S_IN_CH_CTL);\r\n}\r\nstatic inline void img_i2s_in_disable(struct img_i2s_in *i2s)\r\n{\r\nu32 reg;\r\nreg = img_i2s_in_readl(i2s, IMG_I2S_IN_CTL);\r\nreg &= ~IMG_I2S_IN_CTL_ME_MASK;\r\nimg_i2s_in_writel(i2s, reg, IMG_I2S_IN_CTL);\r\n}\r\nstatic inline void img_i2s_in_enable(struct img_i2s_in *i2s)\r\n{\r\nu32 reg;\r\nreg = img_i2s_in_readl(i2s, IMG_I2S_IN_CTL);\r\nreg |= IMG_I2S_IN_CTL_ME_MASK;\r\nimg_i2s_in_writel(i2s, reg, IMG_I2S_IN_CTL);\r\n}\r\nstatic inline void img_i2s_in_flush(struct img_i2s_in *i2s)\r\n{\r\nint i;\r\nu32 reg;\r\nfor (i = 0; i < i2s->active_channels; i++) {\r\nreg = img_i2s_in_ch_readl(i2s, i, IMG_I2S_IN_CH_CTL);\r\nreg |= IMG_I2S_IN_CH_CTL_FIFO_FLUSH_MASK;\r\nimg_i2s_in_ch_writel(i2s, i, reg, IMG_I2S_IN_CH_CTL);\r\nreg &= ~IMG_I2S_IN_CH_CTL_FIFO_FLUSH_MASK;\r\nimg_i2s_in_ch_writel(i2s, i, reg, IMG_I2S_IN_CH_CTL);\r\n}\r\n}\r\nstatic int img_i2s_in_trigger(struct snd_pcm_substream *substream, int cmd,\r\nstruct snd_soc_dai *dai)\r\n{\r\nstruct img_i2s_in *i2s = snd_soc_dai_get_drvdata(dai);\r\nswitch (cmd) {\r\ncase SNDRV_PCM_TRIGGER_START:\r\ncase SNDRV_PCM_TRIGGER_RESUME:\r\ncase SNDRV_PCM_TRIGGER_PAUSE_RELEASE:\r\nimg_i2s_in_enable(i2s);\r\nbreak;\r\ncase SNDRV_PCM_TRIGGER_STOP:\r\ncase SNDRV_PCM_TRIGGER_SUSPEND:\r\ncase SNDRV_PCM_TRIGGER_PAUSE_PUSH:\r\nimg_i2s_in_disable(i2s);\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int img_i2s_in_check_rate(struct img_i2s_in *i2s,\r\nunsigned int sample_rate, unsigned int frame_size,\r\nunsigned int *bclk_filter_enable,\r\nunsigned int *bclk_filter_value)\r\n{\r\nunsigned int bclk_freq, cur_freq;\r\nbclk_freq = sample_rate * frame_size;\r\ncur_freq = clk_get_rate(i2s->clk_sys);\r\nif (cur_freq >= bclk_freq * 8) {\r\n*bclk_filter_enable = 1;\r\n*bclk_filter_value = 0;\r\n} else if (cur_freq >= bclk_freq * 7) {\r\n*bclk_filter_enable = 1;\r\n*bclk_filter_value = 1;\r\n} else if (cur_freq >= bclk_freq * 6) {\r\n*bclk_filter_enable = 0;\r\n*bclk_filter_value = 0;\r\n} else {\r\ndev_err(i2s->dev,\r\n"Sys clock rate %u insufficient for sample rate %u\n",\r\ncur_freq, sample_rate);\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int img_i2s_in_hw_params(struct snd_pcm_substream *substream,\r\nstruct snd_pcm_hw_params *params, struct snd_soc_dai *dai)\r\n{\r\nstruct img_i2s_in *i2s = snd_soc_dai_get_drvdata(dai);\r\nunsigned int rate, channels, i2s_channels, frame_size;\r\nunsigned int bclk_filter_enable, bclk_filter_value;\r\nint i, ret = 0;\r\nu32 reg, control_mask, chan_control_mask;\r\nu32 control_set = 0, chan_control_set = 0;\r\nsnd_pcm_format_t format;\r\nrate = params_rate(params);\r\nformat = params_format(params);\r\nchannels = params_channels(params);\r\ni2s_channels = channels / 2;\r\nswitch (format) {\r\ncase SNDRV_PCM_FORMAT_S32_LE:\r\nframe_size = 64;\r\nchan_control_set |= IMG_I2S_IN_CH_CTL_SW_MASK;\r\nchan_control_set |= IMG_I2S_IN_CH_CTL_FW_MASK;\r\nchan_control_set |= IMG_I2S_IN_CH_CTL_PACKH_MASK;\r\nbreak;\r\ncase SNDRV_PCM_FORMAT_S24_LE:\r\nframe_size = 64;\r\nchan_control_set |= IMG_I2S_IN_CH_CTL_SW_MASK;\r\nchan_control_set |= IMG_I2S_IN_CH_CTL_FW_MASK;\r\nbreak;\r\ncase SNDRV_PCM_FORMAT_S16_LE:\r\nframe_size = 32;\r\ncontrol_set |= IMG_I2S_IN_CTL_16PACK_MASK;\r\nchan_control_set |= IMG_I2S_IN_CH_CTL_16PACK_MASK;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nif ((channels < 2) ||\r\n(channels > (i2s->max_i2s_chan * 2)) ||\r\n(channels % 2))\r\nreturn -EINVAL;\r\ncontrol_set |= ((i2s_channels - 1) << IMG_I2S_IN_CTL_ACTIVE_CH_SHIFT);\r\nret = img_i2s_in_check_rate(i2s, rate, frame_size,\r\n&bclk_filter_enable, &bclk_filter_value);\r\nif (ret < 0)\r\nreturn ret;\r\nif (bclk_filter_enable)\r\nchan_control_set |= IMG_I2S_IN_CH_CTL_FEN_MASK;\r\nif (bclk_filter_value)\r\nchan_control_set |= IMG_I2S_IN_CH_CTL_FMODE_MASK;\r\ncontrol_mask = IMG_I2S_IN_CTL_16PACK_MASK |\r\nIMG_I2S_IN_CTL_ACTIVE_CHAN_MASK;\r\nchan_control_mask = IMG_I2S_IN_CH_CTL_16PACK_MASK |\r\nIMG_I2S_IN_CH_CTL_FEN_MASK |\r\nIMG_I2S_IN_CH_CTL_FMODE_MASK |\r\nIMG_I2S_IN_CH_CTL_SW_MASK |\r\nIMG_I2S_IN_CH_CTL_FW_MASK |\r\nIMG_I2S_IN_CH_CTL_PACKH_MASK;\r\nreg = img_i2s_in_readl(i2s, IMG_I2S_IN_CTL);\r\nreg = (reg & ~control_mask) | control_set;\r\nimg_i2s_in_writel(i2s, reg, IMG_I2S_IN_CTL);\r\nfor (i = 0; i < i2s->active_channels; i++)\r\nimg_i2s_in_ch_disable(i2s, i);\r\nfor (i = 0; i < i2s->max_i2s_chan; i++) {\r\nreg = img_i2s_in_ch_readl(i2s, i, IMG_I2S_IN_CH_CTL);\r\nreg = (reg & ~chan_control_mask) | chan_control_set;\r\nimg_i2s_in_ch_writel(i2s, i, reg, IMG_I2S_IN_CH_CTL);\r\n}\r\ni2s->active_channels = i2s_channels;\r\nimg_i2s_in_flush(i2s);\r\nfor (i = 0; i < i2s->active_channels; i++)\r\nimg_i2s_in_ch_enable(i2s, i);\r\nreturn 0;\r\n}\r\nstatic int img_i2s_in_set_fmt(struct snd_soc_dai *dai, unsigned int fmt)\r\n{\r\nstruct img_i2s_in *i2s = snd_soc_dai_get_drvdata(dai);\r\nint i;\r\nu32 chan_control_mask, lrd_set = 0, blkp_set = 0, chan_control_set = 0;\r\nu32 reg;\r\nswitch (fmt & SND_SOC_DAIFMT_INV_MASK) {\r\ncase SND_SOC_DAIFMT_NB_NF:\r\nlrd_set |= IMG_I2S_IN_CH_CTL_LRD_MASK;\r\nbreak;\r\ncase SND_SOC_DAIFMT_NB_IF:\r\nbreak;\r\ncase SND_SOC_DAIFMT_IB_NF:\r\nlrd_set |= IMG_I2S_IN_CH_CTL_LRD_MASK;\r\nblkp_set |= IMG_I2S_IN_CH_CTL_BLKP_MASK;\r\nbreak;\r\ncase SND_SOC_DAIFMT_IB_IF:\r\nblkp_set |= IMG_I2S_IN_CH_CTL_BLKP_MASK;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nswitch (fmt & SND_SOC_DAIFMT_FORMAT_MASK) {\r\ncase SND_SOC_DAIFMT_I2S:\r\nchan_control_set |= IMG_I2S_IN_CH_CTL_CLK_TRANS_MASK;\r\nbreak;\r\ncase SND_SOC_DAIFMT_LEFT_J:\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nswitch (fmt & SND_SOC_DAIFMT_MASTER_MASK) {\r\ncase SND_SOC_DAIFMT_CBM_CFM:\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nchan_control_mask = IMG_I2S_IN_CH_CTL_CLK_TRANS_MASK;\r\nfor (i = 0; i < i2s->active_channels; i++)\r\nimg_i2s_in_ch_disable(i2s, i);\r\nfor (i = 0; i < i2s->max_i2s_chan; i++) {\r\nreg = img_i2s_in_ch_readl(i2s, i, IMG_I2S_IN_CH_CTL);\r\nreg = (reg & ~chan_control_mask) | chan_control_set;\r\nimg_i2s_in_ch_writel(i2s, i, reg, IMG_I2S_IN_CH_CTL);\r\nreg = (reg & ~IMG_I2S_IN_CH_CTL_BLKP_MASK) | blkp_set;\r\nimg_i2s_in_ch_writel(i2s, i, reg, IMG_I2S_IN_CH_CTL);\r\nreg = (reg & ~IMG_I2S_IN_CH_CTL_LRD_MASK) | lrd_set;\r\nimg_i2s_in_ch_writel(i2s, i, reg, IMG_I2S_IN_CH_CTL);\r\n}\r\nfor (i = 0; i < i2s->active_channels; i++)\r\nimg_i2s_in_ch_enable(i2s, i);\r\nreturn 0;\r\n}\r\nstatic int img_i2s_in_dai_probe(struct snd_soc_dai *dai)\r\n{\r\nstruct img_i2s_in *i2s = snd_soc_dai_get_drvdata(dai);\r\nsnd_soc_dai_init_dma_data(dai, NULL, &i2s->dma_data);\r\nreturn 0;\r\n}\r\nstatic int img_i2s_in_dma_prepare_slave_config(struct snd_pcm_substream *st,\r\nstruct snd_pcm_hw_params *params, struct dma_slave_config *sc)\r\n{\r\nunsigned int i2s_channels = params_channels(params) / 2;\r\nstruct snd_soc_pcm_runtime *rtd = st->private_data;\r\nstruct snd_dmaengine_dai_dma_data *dma_data;\r\nint ret;\r\ndma_data = snd_soc_dai_get_dma_data(rtd->cpu_dai, st);\r\nret = snd_hwparams_to_dma_slave_config(st, params, sc);\r\nif (ret)\r\nreturn ret;\r\nsc->src_addr = dma_data->addr;\r\nsc->src_addr_width = dma_data->addr_width;\r\nsc->src_maxburst = 4 * i2s_channels;\r\nreturn 0;\r\n}\r\nstatic int img_i2s_in_probe(struct platform_device *pdev)\r\n{\r\nstruct img_i2s_in *i2s;\r\nstruct resource *res;\r\nvoid __iomem *base;\r\nint ret, i;\r\nstruct reset_control *rst;\r\nunsigned int max_i2s_chan_pow_2;\r\nstruct device *dev = &pdev->dev;\r\ni2s = devm_kzalloc(dev, sizeof(*i2s), GFP_KERNEL);\r\nif (!i2s)\r\nreturn -ENOMEM;\r\nplatform_set_drvdata(pdev, i2s);\r\ni2s->dev = dev;\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nbase = devm_ioremap_resource(dev, res);\r\nif (IS_ERR(base))\r\nreturn PTR_ERR(base);\r\ni2s->base = base;\r\nif (of_property_read_u32(pdev->dev.of_node, "img,i2s-channels",\r\n&i2s->max_i2s_chan)) {\r\ndev_err(dev, "No img,i2s-channels property\n");\r\nreturn -EINVAL;\r\n}\r\nmax_i2s_chan_pow_2 = 1 << get_count_order(i2s->max_i2s_chan);\r\ni2s->channel_base = base + (max_i2s_chan_pow_2 * 0x20);\r\ni2s->clk_sys = devm_clk_get(dev, "sys");\r\nif (IS_ERR(i2s->clk_sys)) {\r\nif (PTR_ERR(i2s->clk_sys) != -EPROBE_DEFER)\r\ndev_err(dev, "Failed to acquire clock 'sys'\n");\r\nreturn PTR_ERR(i2s->clk_sys);\r\n}\r\nret = clk_prepare_enable(i2s->clk_sys);\r\nif (ret)\r\nreturn ret;\r\ni2s->active_channels = 1;\r\ni2s->dma_data.addr = res->start + IMG_I2S_IN_RX_FIFO;\r\ni2s->dma_data.addr_width = 4;\r\ni2s->dai_driver.probe = img_i2s_in_dai_probe;\r\ni2s->dai_driver.capture.channels_min = 2;\r\ni2s->dai_driver.capture.channels_max = i2s->max_i2s_chan * 2;\r\ni2s->dai_driver.capture.rates = SNDRV_PCM_RATE_8000_192000;\r\ni2s->dai_driver.capture.formats = SNDRV_PCM_FMTBIT_S32_LE |\r\nSNDRV_PCM_FMTBIT_S24_LE | SNDRV_PCM_FMTBIT_S16_LE;\r\ni2s->dai_driver.ops = &img_i2s_in_dai_ops;\r\nrst = devm_reset_control_get(dev, "rst");\r\nif (IS_ERR(rst)) {\r\nif (PTR_ERR(rst) == -EPROBE_DEFER) {\r\nret = -EPROBE_DEFER;\r\ngoto err_clk_disable;\r\n}\r\ndev_dbg(dev, "No top level reset found\n");\r\nimg_i2s_in_disable(i2s);\r\nfor (i = 0; i < i2s->max_i2s_chan; i++)\r\nimg_i2s_in_ch_disable(i2s, i);\r\n} else {\r\nreset_control_assert(rst);\r\nreset_control_deassert(rst);\r\n}\r\nimg_i2s_in_writel(i2s, 0, IMG_I2S_IN_CTL);\r\nfor (i = 0; i < i2s->max_i2s_chan; i++)\r\nimg_i2s_in_ch_writel(i2s, i,\r\n(4 << IMG_I2S_IN_CH_CTL_CCDEL_SHIFT) |\r\nIMG_I2S_IN_CH_CTL_JUST_MASK |\r\nIMG_I2S_IN_CH_CTL_FW_MASK, IMG_I2S_IN_CH_CTL);\r\nret = devm_snd_soc_register_component(dev, &img_i2s_in_component,\r\n&i2s->dai_driver, 1);\r\nif (ret)\r\ngoto err_clk_disable;\r\nret = devm_snd_dmaengine_pcm_register(dev, &img_i2s_in_dma_config, 0);\r\nif (ret)\r\ngoto err_clk_disable;\r\nreturn 0;\r\nerr_clk_disable:\r\nclk_disable_unprepare(i2s->clk_sys);\r\nreturn ret;\r\n}\r\nstatic int img_i2s_in_dev_remove(struct platform_device *pdev)\r\n{\r\nstruct img_i2s_in *i2s = platform_get_drvdata(pdev);\r\nclk_disable_unprepare(i2s->clk_sys);\r\nreturn 0;\r\n}
