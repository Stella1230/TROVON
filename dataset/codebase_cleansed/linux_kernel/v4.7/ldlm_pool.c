static inline __u64 dru(__u64 val, __u32 shift, int round_up)\r\n{\r\nreturn (val + (round_up ? (1 << shift) - 1 : 0)) >> shift;\r\n}\r\nstatic inline __u64 ldlm_pool_slv_max(__u32 L)\r\n{\r\n__u64 lim = (__u64)L * LDLM_POOL_MAX_AGE / 1;\r\nreturn lim;\r\n}\r\nstatic inline __u64 ldlm_pool_slv_min(__u32 L)\r\n{\r\nreturn 1;\r\n}\r\nstatic inline int ldlm_pool_t2gsp(unsigned int t)\r\n{\r\nreturn LDLM_POOL_MAX_GSP -\r\n((LDLM_POOL_MAX_GSP - LDLM_POOL_MIN_GSP) >>\r\n(t >> LDLM_POOL_GSP_STEP_SHIFT));\r\n}\r\nstatic void ldlm_pool_recalc_stats(struct ldlm_pool *pl)\r\n{\r\nint grant_plan = pl->pl_grant_plan;\r\n__u64 slv = pl->pl_server_lock_volume;\r\nint granted = atomic_read(&pl->pl_granted);\r\nint grant_rate = atomic_read(&pl->pl_grant_rate);\r\nint cancel_rate = atomic_read(&pl->pl_cancel_rate);\r\nlprocfs_counter_add(pl->pl_stats, LDLM_POOL_SLV_STAT,\r\nslv);\r\nlprocfs_counter_add(pl->pl_stats, LDLM_POOL_GRANTED_STAT,\r\ngranted);\r\nlprocfs_counter_add(pl->pl_stats, LDLM_POOL_GRANT_RATE_STAT,\r\ngrant_rate);\r\nlprocfs_counter_add(pl->pl_stats, LDLM_POOL_GRANT_PLAN_STAT,\r\ngrant_plan);\r\nlprocfs_counter_add(pl->pl_stats, LDLM_POOL_CANCEL_RATE_STAT,\r\ncancel_rate);\r\n}\r\nstatic void ldlm_cli_pool_pop_slv(struct ldlm_pool *pl)\r\n{\r\nstruct obd_device *obd;\r\nobd = container_of(pl, struct ldlm_namespace,\r\nns_pool)->ns_obd;\r\nread_lock(&obd->obd_pool_lock);\r\npl->pl_server_lock_volume = obd->obd_pool_slv;\r\natomic_set(&pl->pl_limit, obd->obd_pool_limit);\r\nread_unlock(&obd->obd_pool_lock);\r\n}\r\nstatic int ldlm_cli_pool_recalc(struct ldlm_pool *pl)\r\n{\r\ntime64_t recalc_interval_sec;\r\nint ret;\r\nrecalc_interval_sec = ktime_get_real_seconds() - pl->pl_recalc_time;\r\nif (recalc_interval_sec < pl->pl_recalc_period)\r\nreturn 0;\r\nspin_lock(&pl->pl_lock);\r\nrecalc_interval_sec = ktime_get_real_seconds() - pl->pl_recalc_time;\r\nif (recalc_interval_sec < pl->pl_recalc_period) {\r\nspin_unlock(&pl->pl_lock);\r\nreturn 0;\r\n}\r\nldlm_cli_pool_pop_slv(pl);\r\nspin_unlock(&pl->pl_lock);\r\nif (!ns_connect_lru_resize(container_of(pl, struct ldlm_namespace,\r\nns_pool))) {\r\nret = 0;\r\ngoto out;\r\n}\r\nret = ldlm_cancel_lru(container_of(pl, struct ldlm_namespace, ns_pool),\r\n0, LCF_ASYNC, LDLM_CANCEL_LRUR);\r\nout:\r\nspin_lock(&pl->pl_lock);\r\npl->pl_recalc_time = ktime_get_real_seconds();\r\nlprocfs_counter_add(pl->pl_stats, LDLM_POOL_TIMING_STAT,\r\nrecalc_interval_sec);\r\nspin_unlock(&pl->pl_lock);\r\nreturn ret;\r\n}\r\nstatic int ldlm_cli_pool_shrink(struct ldlm_pool *pl,\r\nint nr, gfp_t gfp_mask)\r\n{\r\nstruct ldlm_namespace *ns;\r\nint unused;\r\nns = container_of(pl, struct ldlm_namespace, ns_pool);\r\nif (!ns_connect_lru_resize(ns))\r\nreturn 0;\r\nldlm_cli_pool_pop_slv(pl);\r\nspin_lock(&ns->ns_lock);\r\nunused = ns->ns_nr_unused;\r\nspin_unlock(&ns->ns_lock);\r\nif (nr == 0)\r\nreturn (unused / 100) * sysctl_vfs_cache_pressure;\r\nelse\r\nreturn ldlm_cancel_lru(ns, nr, LCF_ASYNC, LDLM_CANCEL_SHRINK);\r\n}\r\nstatic int ldlm_pool_recalc(struct ldlm_pool *pl)\r\n{\r\nu32 recalc_interval_sec;\r\nint count;\r\nrecalc_interval_sec = ktime_get_seconds() - pl->pl_recalc_time;\r\nif (recalc_interval_sec <= 0)\r\ngoto recalc;\r\nspin_lock(&pl->pl_lock);\r\nif (recalc_interval_sec > 0) {\r\nldlm_pool_recalc_stats(pl);\r\natomic_set(&pl->pl_grant_rate, 0);\r\natomic_set(&pl->pl_cancel_rate, 0);\r\n}\r\nspin_unlock(&pl->pl_lock);\r\nrecalc:\r\nif (pl->pl_ops->po_recalc) {\r\ncount = pl->pl_ops->po_recalc(pl);\r\nlprocfs_counter_add(pl->pl_stats, LDLM_POOL_RECALC_STAT,\r\ncount);\r\n}\r\nrecalc_interval_sec = pl->pl_recalc_time - ktime_get_seconds() +\r\npl->pl_recalc_period;\r\nif (recalc_interval_sec <= 0) {\r\nCDEBUG(D_DLMTRACE,\r\n"Negative interval(%d), too short period(%lld)",\r\nrecalc_interval_sec,\r\n(s64)pl->pl_recalc_period);\r\nrecalc_interval_sec = 1;\r\n}\r\nreturn recalc_interval_sec;\r\n}\r\nstatic int ldlm_pool_shrink(struct ldlm_pool *pl, int nr, gfp_t gfp_mask)\r\n{\r\nint cancel = 0;\r\nif (pl->pl_ops->po_shrink) {\r\ncancel = pl->pl_ops->po_shrink(pl, nr, gfp_mask);\r\nif (nr > 0) {\r\nlprocfs_counter_add(pl->pl_stats,\r\nLDLM_POOL_SHRINK_REQTD_STAT,\r\nnr);\r\nlprocfs_counter_add(pl->pl_stats,\r\nLDLM_POOL_SHRINK_FREED_STAT,\r\ncancel);\r\nCDEBUG(D_DLMTRACE, "%s: request to shrink %d locks, shrunk %d\n",\r\npl->pl_name, nr, cancel);\r\n}\r\n}\r\nreturn cancel;\r\n}\r\nstatic int lprocfs_pool_state_seq_show(struct seq_file *m, void *unused)\r\n{\r\nint granted, grant_rate, cancel_rate;\r\nint grant_speed, lvf;\r\nstruct ldlm_pool *pl = m->private;\r\n__u64 slv, clv;\r\n__u32 limit;\r\nspin_lock(&pl->pl_lock);\r\nslv = pl->pl_server_lock_volume;\r\nclv = pl->pl_client_lock_volume;\r\nlimit = atomic_read(&pl->pl_limit);\r\ngranted = atomic_read(&pl->pl_granted);\r\ngrant_rate = atomic_read(&pl->pl_grant_rate);\r\ncancel_rate = atomic_read(&pl->pl_cancel_rate);\r\ngrant_speed = grant_rate - cancel_rate;\r\nlvf = atomic_read(&pl->pl_lock_volume_factor);\r\nspin_unlock(&pl->pl_lock);\r\nseq_printf(m, "LDLM pool state (%s):\n"\r\n" SLV: %llu\n"\r\n" CLV: %llu\n"\r\n" LVF: %d\n",\r\npl->pl_name, slv, clv, lvf);\r\nseq_printf(m, " GR: %d\n CR: %d\n GS: %d\n"\r\n" G: %d\n L: %d\n",\r\ngrant_rate, cancel_rate, grant_speed,\r\ngranted, limit);\r\nreturn 0;\r\n}\r\nstatic ssize_t grant_speed_show(struct kobject *kobj, struct attribute *attr,\r\nchar *buf)\r\n{\r\nstruct ldlm_pool *pl = container_of(kobj, struct ldlm_pool,\r\npl_kobj);\r\nint grant_speed;\r\nspin_lock(&pl->pl_lock);\r\ngrant_speed = atomic_read(&pl->pl_grant_rate) -\r\natomic_read(&pl->pl_cancel_rate);\r\nspin_unlock(&pl->pl_lock);\r\nreturn sprintf(buf, "%d\n", grant_speed);\r\n}\r\nstatic void ldlm_pl_release(struct kobject *kobj)\r\n{\r\nstruct ldlm_pool *pl = container_of(kobj, struct ldlm_pool,\r\npl_kobj);\r\ncomplete(&pl->pl_kobj_unregister);\r\n}\r\nstatic int ldlm_pool_sysfs_init(struct ldlm_pool *pl)\r\n{\r\nstruct ldlm_namespace *ns = container_of(pl, struct ldlm_namespace,\r\nns_pool);\r\nint err;\r\ninit_completion(&pl->pl_kobj_unregister);\r\nerr = kobject_init_and_add(&pl->pl_kobj, &ldlm_pl_ktype, &ns->ns_kobj,\r\n"pool");\r\nreturn err;\r\n}\r\nstatic int ldlm_pool_debugfs_init(struct ldlm_pool *pl)\r\n{\r\nstruct ldlm_namespace *ns = container_of(pl, struct ldlm_namespace,\r\nns_pool);\r\nstruct dentry *debugfs_ns_parent;\r\nstruct lprocfs_vars pool_vars[2];\r\nchar *var_name = NULL;\r\nint rc = 0;\r\nvar_name = kzalloc(MAX_STRING_SIZE + 1, GFP_NOFS);\r\nif (!var_name)\r\nreturn -ENOMEM;\r\ndebugfs_ns_parent = ns->ns_debugfs_entry;\r\nif (IS_ERR_OR_NULL(debugfs_ns_parent)) {\r\nCERROR("%s: debugfs entry is not initialized\n",\r\nldlm_ns_name(ns));\r\nrc = -EINVAL;\r\ngoto out_free_name;\r\n}\r\npl->pl_debugfs_entry = ldebugfs_register("pool", debugfs_ns_parent,\r\nNULL, NULL);\r\nif (IS_ERR(pl->pl_debugfs_entry)) {\r\nCERROR("LdebugFS failed in ldlm-pool-init\n");\r\nrc = PTR_ERR(pl->pl_debugfs_entry);\r\npl->pl_debugfs_entry = NULL;\r\ngoto out_free_name;\r\n}\r\nvar_name[MAX_STRING_SIZE] = '\0';\r\nmemset(pool_vars, 0, sizeof(pool_vars));\r\npool_vars[0].name = var_name;\r\nLDLM_POOL_ADD_VAR(state, pl, &lprocfs_pool_state_fops);\r\npl->pl_stats = lprocfs_alloc_stats(LDLM_POOL_LAST_STAT -\r\nLDLM_POOL_FIRST_STAT, 0);\r\nif (!pl->pl_stats) {\r\nrc = -ENOMEM;\r\ngoto out_free_name;\r\n}\r\nlprocfs_counter_init(pl->pl_stats, LDLM_POOL_GRANTED_STAT,\r\nLPROCFS_CNTR_AVGMINMAX | LPROCFS_CNTR_STDDEV,\r\n"granted", "locks");\r\nlprocfs_counter_init(pl->pl_stats, LDLM_POOL_GRANT_STAT,\r\nLPROCFS_CNTR_AVGMINMAX | LPROCFS_CNTR_STDDEV,\r\n"grant", "locks");\r\nlprocfs_counter_init(pl->pl_stats, LDLM_POOL_CANCEL_STAT,\r\nLPROCFS_CNTR_AVGMINMAX | LPROCFS_CNTR_STDDEV,\r\n"cancel", "locks");\r\nlprocfs_counter_init(pl->pl_stats, LDLM_POOL_GRANT_RATE_STAT,\r\nLPROCFS_CNTR_AVGMINMAX | LPROCFS_CNTR_STDDEV,\r\n"grant_rate", "locks/s");\r\nlprocfs_counter_init(pl->pl_stats, LDLM_POOL_CANCEL_RATE_STAT,\r\nLPROCFS_CNTR_AVGMINMAX | LPROCFS_CNTR_STDDEV,\r\n"cancel_rate", "locks/s");\r\nlprocfs_counter_init(pl->pl_stats, LDLM_POOL_GRANT_PLAN_STAT,\r\nLPROCFS_CNTR_AVGMINMAX | LPROCFS_CNTR_STDDEV,\r\n"grant_plan", "locks/s");\r\nlprocfs_counter_init(pl->pl_stats, LDLM_POOL_SLV_STAT,\r\nLPROCFS_CNTR_AVGMINMAX | LPROCFS_CNTR_STDDEV,\r\n"slv", "slv");\r\nlprocfs_counter_init(pl->pl_stats, LDLM_POOL_SHRINK_REQTD_STAT,\r\nLPROCFS_CNTR_AVGMINMAX | LPROCFS_CNTR_STDDEV,\r\n"shrink_request", "locks");\r\nlprocfs_counter_init(pl->pl_stats, LDLM_POOL_SHRINK_FREED_STAT,\r\nLPROCFS_CNTR_AVGMINMAX | LPROCFS_CNTR_STDDEV,\r\n"shrink_freed", "locks");\r\nlprocfs_counter_init(pl->pl_stats, LDLM_POOL_RECALC_STAT,\r\nLPROCFS_CNTR_AVGMINMAX | LPROCFS_CNTR_STDDEV,\r\n"recalc_freed", "locks");\r\nlprocfs_counter_init(pl->pl_stats, LDLM_POOL_TIMING_STAT,\r\nLPROCFS_CNTR_AVGMINMAX | LPROCFS_CNTR_STDDEV,\r\n"recalc_timing", "sec");\r\nrc = ldebugfs_register_stats(pl->pl_debugfs_entry, "stats",\r\npl->pl_stats);\r\nout_free_name:\r\nkfree(var_name);\r\nreturn rc;\r\n}\r\nstatic void ldlm_pool_sysfs_fini(struct ldlm_pool *pl)\r\n{\r\nkobject_put(&pl->pl_kobj);\r\nwait_for_completion(&pl->pl_kobj_unregister);\r\n}\r\nstatic void ldlm_pool_debugfs_fini(struct ldlm_pool *pl)\r\n{\r\nif (pl->pl_stats) {\r\nlprocfs_free_stats(&pl->pl_stats);\r\npl->pl_stats = NULL;\r\n}\r\nif (pl->pl_debugfs_entry) {\r\nldebugfs_remove(&pl->pl_debugfs_entry);\r\npl->pl_debugfs_entry = NULL;\r\n}\r\n}\r\nint ldlm_pool_init(struct ldlm_pool *pl, struct ldlm_namespace *ns,\r\nint idx, ldlm_side_t client)\r\n{\r\nint rc;\r\nspin_lock_init(&pl->pl_lock);\r\natomic_set(&pl->pl_granted, 0);\r\npl->pl_recalc_time = ktime_get_seconds();\r\natomic_set(&pl->pl_lock_volume_factor, 1);\r\natomic_set(&pl->pl_grant_rate, 0);\r\natomic_set(&pl->pl_cancel_rate, 0);\r\npl->pl_grant_plan = LDLM_POOL_GP(LDLM_POOL_HOST_L);\r\nsnprintf(pl->pl_name, sizeof(pl->pl_name), "ldlm-pool-%s-%d",\r\nldlm_ns_name(ns), idx);\r\natomic_set(&pl->pl_limit, 1);\r\npl->pl_server_lock_volume = 0;\r\npl->pl_ops = &ldlm_cli_pool_ops;\r\npl->pl_recalc_period = LDLM_POOL_CLI_DEF_RECALC_PERIOD;\r\npl->pl_client_lock_volume = 0;\r\nrc = ldlm_pool_debugfs_init(pl);\r\nif (rc)\r\nreturn rc;\r\nrc = ldlm_pool_sysfs_init(pl);\r\nif (rc)\r\nreturn rc;\r\nCDEBUG(D_DLMTRACE, "Lock pool %s is initialized\n", pl->pl_name);\r\nreturn rc;\r\n}\r\nvoid ldlm_pool_fini(struct ldlm_pool *pl)\r\n{\r\nldlm_pool_sysfs_fini(pl);\r\nldlm_pool_debugfs_fini(pl);\r\nPOISON(pl, 0x5a, sizeof(*pl));\r\n}\r\nvoid ldlm_pool_add(struct ldlm_pool *pl, struct ldlm_lock *lock)\r\n{\r\nif (lock->l_resource->lr_type == LDLM_FLOCK)\r\nreturn;\r\natomic_inc(&pl->pl_granted);\r\natomic_inc(&pl->pl_grant_rate);\r\nlprocfs_counter_incr(pl->pl_stats, LDLM_POOL_GRANT_STAT);\r\n}\r\nvoid ldlm_pool_del(struct ldlm_pool *pl, struct ldlm_lock *lock)\r\n{\r\nif (lock->l_resource->lr_type == LDLM_FLOCK)\r\nreturn;\r\nLASSERT(atomic_read(&pl->pl_granted) > 0);\r\natomic_dec(&pl->pl_granted);\r\natomic_inc(&pl->pl_cancel_rate);\r\nlprocfs_counter_incr(pl->pl_stats, LDLM_POOL_CANCEL_STAT);\r\n}\r\n__u64 ldlm_pool_get_slv(struct ldlm_pool *pl)\r\n{\r\n__u64 slv;\r\nspin_lock(&pl->pl_lock);\r\nslv = pl->pl_server_lock_volume;\r\nspin_unlock(&pl->pl_lock);\r\nreturn slv;\r\n}\r\nvoid ldlm_pool_set_clv(struct ldlm_pool *pl, __u64 clv)\r\n{\r\nspin_lock(&pl->pl_lock);\r\npl->pl_client_lock_volume = clv;\r\nspin_unlock(&pl->pl_lock);\r\n}\r\n__u32 ldlm_pool_get_lvf(struct ldlm_pool *pl)\r\n{\r\nreturn atomic_read(&pl->pl_lock_volume_factor);\r\n}\r\nstatic int ldlm_pool_granted(struct ldlm_pool *pl)\r\n{\r\nreturn atomic_read(&pl->pl_granted);\r\n}\r\nstatic unsigned long ldlm_pools_count(ldlm_side_t client, gfp_t gfp_mask)\r\n{\r\nint total = 0, nr_ns;\r\nstruct ldlm_namespace *ns;\r\nstruct ldlm_namespace *ns_old = NULL;\r\nvoid *cookie;\r\nif (client == LDLM_NAMESPACE_CLIENT && !(gfp_mask & __GFP_FS))\r\nreturn 0;\r\nCDEBUG(D_DLMTRACE, "Request to count %s locks from all pools\n",\r\nclient == LDLM_NAMESPACE_CLIENT ? "client" : "server");\r\ncookie = cl_env_reenter();\r\nfor (nr_ns = ldlm_namespace_nr_read(client);\r\nnr_ns > 0; nr_ns--) {\r\nmutex_lock(ldlm_namespace_lock(client));\r\nif (list_empty(ldlm_namespace_list(client))) {\r\nmutex_unlock(ldlm_namespace_lock(client));\r\ncl_env_reexit(cookie);\r\nreturn 0;\r\n}\r\nns = ldlm_namespace_first_locked(client);\r\nif (ns == ns_old) {\r\nmutex_unlock(ldlm_namespace_lock(client));\r\nbreak;\r\n}\r\nif (ldlm_ns_empty(ns)) {\r\nldlm_namespace_move_to_inactive_locked(ns, client);\r\nmutex_unlock(ldlm_namespace_lock(client));\r\ncontinue;\r\n}\r\nif (!ns_old)\r\nns_old = ns;\r\nldlm_namespace_get(ns);\r\nldlm_namespace_move_to_active_locked(ns, client);\r\nmutex_unlock(ldlm_namespace_lock(client));\r\ntotal += ldlm_pool_shrink(&ns->ns_pool, 0, gfp_mask);\r\nldlm_namespace_put(ns);\r\n}\r\ncl_env_reexit(cookie);\r\nreturn total;\r\n}\r\nstatic unsigned long ldlm_pools_scan(ldlm_side_t client, int nr, gfp_t gfp_mask)\r\n{\r\nunsigned long freed = 0;\r\nint tmp, nr_ns;\r\nstruct ldlm_namespace *ns;\r\nvoid *cookie;\r\nif (client == LDLM_NAMESPACE_CLIENT && !(gfp_mask & __GFP_FS))\r\nreturn -1;\r\ncookie = cl_env_reenter();\r\nfor (tmp = nr_ns = ldlm_namespace_nr_read(client);\r\ntmp > 0; tmp--) {\r\nint cancel, nr_locks;\r\nmutex_lock(ldlm_namespace_lock(client));\r\nif (list_empty(ldlm_namespace_list(client))) {\r\nmutex_unlock(ldlm_namespace_lock(client));\r\nbreak;\r\n}\r\nns = ldlm_namespace_first_locked(client);\r\nldlm_namespace_get(ns);\r\nldlm_namespace_move_to_active_locked(ns, client);\r\nmutex_unlock(ldlm_namespace_lock(client));\r\nnr_locks = ldlm_pool_granted(&ns->ns_pool);\r\ncancel = 1 + min_t(int, nr_locks, nr / nr_ns);\r\nfreed += ldlm_pool_shrink(&ns->ns_pool, cancel, gfp_mask);\r\nldlm_namespace_put(ns);\r\n}\r\ncl_env_reexit(cookie);\r\nreturn freed;\r\n}\r\nstatic unsigned long ldlm_pools_cli_count(struct shrinker *s,\r\nstruct shrink_control *sc)\r\n{\r\nreturn ldlm_pools_count(LDLM_NAMESPACE_CLIENT, sc->gfp_mask);\r\n}\r\nstatic unsigned long ldlm_pools_cli_scan(struct shrinker *s,\r\nstruct shrink_control *sc)\r\n{\r\nreturn ldlm_pools_scan(LDLM_NAMESPACE_CLIENT, sc->nr_to_scan,\r\nsc->gfp_mask);\r\n}\r\nstatic int ldlm_pools_recalc(ldlm_side_t client)\r\n{\r\nstruct ldlm_namespace *ns;\r\nstruct ldlm_namespace *ns_old = NULL;\r\nint nr;\r\nint time = 50;\r\nfor (nr = ldlm_namespace_nr_read(client); nr > 0; nr--) {\r\nint skip;\r\nmutex_lock(ldlm_namespace_lock(client));\r\nif (list_empty(ldlm_namespace_list(client))) {\r\nmutex_unlock(ldlm_namespace_lock(client));\r\nbreak;\r\n}\r\nns = ldlm_namespace_first_locked(client);\r\nif (ns_old == ns) {\r\nmutex_unlock(ldlm_namespace_lock(client));\r\nbreak;\r\n}\r\nif (ldlm_ns_empty(ns)) {\r\nldlm_namespace_move_to_inactive_locked(ns, client);\r\nmutex_unlock(ldlm_namespace_lock(client));\r\ncontinue;\r\n}\r\nif (!ns_old)\r\nns_old = ns;\r\nspin_lock(&ns->ns_lock);\r\nif (ns->ns_stopping) {\r\nskip = 1;\r\n} else {\r\nskip = 0;\r\nldlm_namespace_get(ns);\r\n}\r\nspin_unlock(&ns->ns_lock);\r\nldlm_namespace_move_to_active_locked(ns, client);\r\nmutex_unlock(ldlm_namespace_lock(client));\r\nif (!skip) {\r\nint ttime = ldlm_pool_recalc(&ns->ns_pool);\r\nif (ttime < time)\r\ntime = ttime;\r\nldlm_namespace_put(ns);\r\n}\r\n}\r\nreturn time;\r\n}\r\nstatic int ldlm_pools_thread_main(void *arg)\r\n{\r\nstruct ptlrpc_thread *thread = (struct ptlrpc_thread *)arg;\r\nint c_time;\r\nthread_set_flags(thread, SVC_RUNNING);\r\nwake_up(&thread->t_ctl_waitq);\r\nCDEBUG(D_DLMTRACE, "%s: pool thread starting, process %d\n",\r\n"ldlm_poold", current_pid());\r\nwhile (1) {\r\nstruct l_wait_info lwi;\r\nc_time = ldlm_pools_recalc(LDLM_NAMESPACE_CLIENT);\r\nlwi = LWI_TIMEOUT(cfs_time_seconds(c_time),\r\nNULL, NULL);\r\nl_wait_event(thread->t_ctl_waitq,\r\nthread_is_stopping(thread) ||\r\nthread_is_event(thread),\r\n&lwi);\r\nif (thread_test_and_clear_flags(thread, SVC_STOPPING))\r\nbreak;\r\nthread_test_and_clear_flags(thread, SVC_EVENT);\r\n}\r\nthread_set_flags(thread, SVC_STOPPED);\r\nwake_up(&thread->t_ctl_waitq);\r\nCDEBUG(D_DLMTRACE, "%s: pool thread exiting, process %d\n",\r\n"ldlm_poold", current_pid());\r\ncomplete_and_exit(&ldlm_pools_comp, 0);\r\n}\r\nstatic int ldlm_pools_thread_start(void)\r\n{\r\nstruct l_wait_info lwi = { 0 };\r\nstruct task_struct *task;\r\nif (ldlm_pools_thread)\r\nreturn -EALREADY;\r\nldlm_pools_thread = kzalloc(sizeof(*ldlm_pools_thread), GFP_NOFS);\r\nif (!ldlm_pools_thread)\r\nreturn -ENOMEM;\r\ninit_completion(&ldlm_pools_comp);\r\ninit_waitqueue_head(&ldlm_pools_thread->t_ctl_waitq);\r\ntask = kthread_run(ldlm_pools_thread_main, ldlm_pools_thread,\r\n"ldlm_poold");\r\nif (IS_ERR(task)) {\r\nCERROR("Can't start pool thread, error %ld\n", PTR_ERR(task));\r\nkfree(ldlm_pools_thread);\r\nldlm_pools_thread = NULL;\r\nreturn PTR_ERR(task);\r\n}\r\nl_wait_event(ldlm_pools_thread->t_ctl_waitq,\r\nthread_is_running(ldlm_pools_thread), &lwi);\r\nreturn 0;\r\n}\r\nstatic void ldlm_pools_thread_stop(void)\r\n{\r\nif (!ldlm_pools_thread)\r\nreturn;\r\nthread_set_flags(ldlm_pools_thread, SVC_STOPPING);\r\nwake_up(&ldlm_pools_thread->t_ctl_waitq);\r\nwait_for_completion(&ldlm_pools_comp);\r\nkfree(ldlm_pools_thread);\r\nldlm_pools_thread = NULL;\r\n}\r\nint ldlm_pools_init(void)\r\n{\r\nint rc;\r\nrc = ldlm_pools_thread_start();\r\nif (rc == 0)\r\nregister_shrinker(&ldlm_pools_cli_shrinker);\r\nreturn rc;\r\n}\r\nvoid ldlm_pools_fini(void)\r\n{\r\nif (ldlm_pools_thread)\r\nunregister_shrinker(&ldlm_pools_cli_shrinker);\r\nldlm_pools_thread_stop();\r\n}
