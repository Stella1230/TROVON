static void ext4_dir_crypt_complete(struct crypto_async_request *req, int res)\r\n{\r\nstruct ext4_completion_result *ecr = req->data;\r\nif (res == -EINPROGRESS)\r\nreturn;\r\necr->res = res;\r\ncomplete(&ecr->completion);\r\n}\r\nbool ext4_valid_filenames_enc_mode(uint32_t mode)\r\n{\r\nreturn (mode == EXT4_ENCRYPTION_MODE_AES_256_CTS);\r\n}\r\nstatic unsigned max_name_len(struct inode *inode)\r\n{\r\nreturn S_ISLNK(inode->i_mode) ? inode->i_sb->s_blocksize :\r\nEXT4_NAME_LEN;\r\n}\r\nstatic int ext4_fname_encrypt(struct inode *inode,\r\nconst struct qstr *iname,\r\nstruct ext4_str *oname)\r\n{\r\nu32 ciphertext_len;\r\nstruct skcipher_request *req = NULL;\r\nDECLARE_EXT4_COMPLETION_RESULT(ecr);\r\nstruct ext4_crypt_info *ci = EXT4_I(inode)->i_crypt_info;\r\nstruct crypto_skcipher *tfm = ci->ci_ctfm;\r\nint res = 0;\r\nchar iv[EXT4_CRYPTO_BLOCK_SIZE];\r\nstruct scatterlist src_sg, dst_sg;\r\nint padding = 4 << (ci->ci_flags & EXT4_POLICY_FLAGS_PAD_MASK);\r\nchar *workbuf, buf[32], *alloc_buf = NULL;\r\nunsigned lim = max_name_len(inode);\r\nif (iname->len <= 0 || iname->len > lim)\r\nreturn -EIO;\r\nciphertext_len = (iname->len < EXT4_CRYPTO_BLOCK_SIZE) ?\r\nEXT4_CRYPTO_BLOCK_SIZE : iname->len;\r\nciphertext_len = ext4_fname_crypto_round_up(ciphertext_len, padding);\r\nciphertext_len = (ciphertext_len > lim)\r\n? lim : ciphertext_len;\r\nif (ciphertext_len <= sizeof(buf)) {\r\nworkbuf = buf;\r\n} else {\r\nalloc_buf = kmalloc(ciphertext_len, GFP_NOFS);\r\nif (!alloc_buf)\r\nreturn -ENOMEM;\r\nworkbuf = alloc_buf;\r\n}\r\nreq = skcipher_request_alloc(tfm, GFP_NOFS);\r\nif (!req) {\r\nprintk_ratelimited(\r\nKERN_ERR "%s: crypto_request_alloc() failed\n", __func__);\r\nkfree(alloc_buf);\r\nreturn -ENOMEM;\r\n}\r\nskcipher_request_set_callback(req,\r\nCRYPTO_TFM_REQ_MAY_BACKLOG | CRYPTO_TFM_REQ_MAY_SLEEP,\r\next4_dir_crypt_complete, &ecr);\r\nmemcpy(workbuf, iname->name, iname->len);\r\nif (iname->len < ciphertext_len)\r\nmemset(workbuf + iname->len, 0, ciphertext_len - iname->len);\r\nmemset(iv, 0, EXT4_CRYPTO_BLOCK_SIZE);\r\nsg_init_one(&src_sg, workbuf, ciphertext_len);\r\nsg_init_one(&dst_sg, oname->name, ciphertext_len);\r\nskcipher_request_set_crypt(req, &src_sg, &dst_sg, ciphertext_len, iv);\r\nres = crypto_skcipher_encrypt(req);\r\nif (res == -EINPROGRESS || res == -EBUSY) {\r\nwait_for_completion(&ecr.completion);\r\nres = ecr.res;\r\n}\r\nkfree(alloc_buf);\r\nskcipher_request_free(req);\r\nif (res < 0) {\r\nprintk_ratelimited(\r\nKERN_ERR "%s: Error (error code %d)\n", __func__, res);\r\n}\r\noname->len = ciphertext_len;\r\nreturn res;\r\n}\r\nstatic int ext4_fname_decrypt(struct inode *inode,\r\nconst struct ext4_str *iname,\r\nstruct ext4_str *oname)\r\n{\r\nstruct ext4_str tmp_in[2], tmp_out[1];\r\nstruct skcipher_request *req = NULL;\r\nDECLARE_EXT4_COMPLETION_RESULT(ecr);\r\nstruct scatterlist src_sg, dst_sg;\r\nstruct ext4_crypt_info *ci = EXT4_I(inode)->i_crypt_info;\r\nstruct crypto_skcipher *tfm = ci->ci_ctfm;\r\nint res = 0;\r\nchar iv[EXT4_CRYPTO_BLOCK_SIZE];\r\nunsigned lim = max_name_len(inode);\r\nif (iname->len <= 0 || iname->len > lim)\r\nreturn -EIO;\r\ntmp_in[0].name = iname->name;\r\ntmp_in[0].len = iname->len;\r\ntmp_out[0].name = oname->name;\r\nreq = skcipher_request_alloc(tfm, GFP_NOFS);\r\nif (!req) {\r\nprintk_ratelimited(\r\nKERN_ERR "%s: crypto_request_alloc() failed\n", __func__);\r\nreturn -ENOMEM;\r\n}\r\nskcipher_request_set_callback(req,\r\nCRYPTO_TFM_REQ_MAY_BACKLOG | CRYPTO_TFM_REQ_MAY_SLEEP,\r\next4_dir_crypt_complete, &ecr);\r\nmemset(iv, 0, EXT4_CRYPTO_BLOCK_SIZE);\r\nsg_init_one(&src_sg, iname->name, iname->len);\r\nsg_init_one(&dst_sg, oname->name, oname->len);\r\nskcipher_request_set_crypt(req, &src_sg, &dst_sg, iname->len, iv);\r\nres = crypto_skcipher_decrypt(req);\r\nif (res == -EINPROGRESS || res == -EBUSY) {\r\nwait_for_completion(&ecr.completion);\r\nres = ecr.res;\r\n}\r\nskcipher_request_free(req);\r\nif (res < 0) {\r\nprintk_ratelimited(\r\nKERN_ERR "%s: Error in ext4_fname_encrypt (error code %d)\n",\r\n__func__, res);\r\nreturn res;\r\n}\r\noname->len = strnlen(oname->name, iname->len);\r\nreturn oname->len;\r\n}\r\nstatic int digest_encode(const char *src, int len, char *dst)\r\n{\r\nint i = 0, bits = 0, ac = 0;\r\nchar *cp = dst;\r\nwhile (i < len) {\r\nac += (((unsigned char) src[i]) << bits);\r\nbits += 8;\r\ndo {\r\n*cp++ = lookup_table[ac & 0x3f];\r\nac >>= 6;\r\nbits -= 6;\r\n} while (bits >= 6);\r\ni++;\r\n}\r\nif (bits)\r\n*cp++ = lookup_table[ac & 0x3f];\r\nreturn cp - dst;\r\n}\r\nstatic int digest_decode(const char *src, int len, char *dst)\r\n{\r\nint i = 0, bits = 0, ac = 0;\r\nconst char *p;\r\nchar *cp = dst;\r\nwhile (i < len) {\r\np = strchr(lookup_table, src[i]);\r\nif (p == NULL || src[i] == 0)\r\nreturn -2;\r\nac += (p - lookup_table) << bits;\r\nbits += 6;\r\nif (bits >= 8) {\r\n*cp++ = ac & 0xff;\r\nac >>= 8;\r\nbits -= 8;\r\n}\r\ni++;\r\n}\r\nif (ac)\r\nreturn -1;\r\nreturn cp - dst;\r\n}\r\nu32 ext4_fname_crypto_round_up(u32 size, u32 blksize)\r\n{\r\nreturn ((size+blksize-1)/blksize)*blksize;\r\n}\r\nunsigned ext4_fname_encrypted_size(struct inode *inode, u32 ilen)\r\n{\r\nstruct ext4_crypt_info *ci = EXT4_I(inode)->i_crypt_info;\r\nint padding = 32;\r\nif (ci)\r\npadding = 4 << (ci->ci_flags & EXT4_POLICY_FLAGS_PAD_MASK);\r\nif (ilen < EXT4_CRYPTO_BLOCK_SIZE)\r\nilen = EXT4_CRYPTO_BLOCK_SIZE;\r\nreturn ext4_fname_crypto_round_up(ilen, padding);\r\n}\r\nint ext4_fname_crypto_alloc_buffer(struct inode *inode,\r\nu32 ilen, struct ext4_str *crypto_str)\r\n{\r\nunsigned int olen = ext4_fname_encrypted_size(inode, ilen);\r\ncrypto_str->len = olen;\r\nif (olen < EXT4_FNAME_CRYPTO_DIGEST_SIZE*2)\r\nolen = EXT4_FNAME_CRYPTO_DIGEST_SIZE*2;\r\ncrypto_str->name = kmalloc(olen+1, GFP_NOFS);\r\nif (!(crypto_str->name))\r\nreturn -ENOMEM;\r\nreturn 0;\r\n}\r\nvoid ext4_fname_crypto_free_buffer(struct ext4_str *crypto_str)\r\n{\r\nif (!crypto_str)\r\nreturn;\r\nkfree(crypto_str->name);\r\ncrypto_str->name = NULL;\r\n}\r\nint _ext4_fname_disk_to_usr(struct inode *inode,\r\nstruct dx_hash_info *hinfo,\r\nconst struct ext4_str *iname,\r\nstruct ext4_str *oname)\r\n{\r\nchar buf[24];\r\nint ret;\r\nif (iname->len < 3) {\r\nif (iname->name[0] == '.' && iname->name[iname->len-1] == '.') {\r\noname->name[0] = '.';\r\noname->name[iname->len-1] = '.';\r\noname->len = iname->len;\r\nreturn oname->len;\r\n}\r\n}\r\nif (iname->len < EXT4_CRYPTO_BLOCK_SIZE) {\r\nEXT4_ERROR_INODE(inode, "encrypted inode too small");\r\nreturn -EUCLEAN;\r\n}\r\nif (EXT4_I(inode)->i_crypt_info)\r\nreturn ext4_fname_decrypt(inode, iname, oname);\r\nif (iname->len <= EXT4_FNAME_CRYPTO_DIGEST_SIZE) {\r\nret = digest_encode(iname->name, iname->len, oname->name);\r\noname->len = ret;\r\nreturn ret;\r\n}\r\nif (hinfo) {\r\nmemcpy(buf, &hinfo->hash, 4);\r\nmemcpy(buf+4, &hinfo->minor_hash, 4);\r\n} else\r\nmemset(buf, 0, 8);\r\nmemcpy(buf + 8, iname->name + iname->len - 16, 16);\r\noname->name[0] = '_';\r\nret = digest_encode(buf, 24, oname->name+1);\r\noname->len = ret + 1;\r\nreturn ret + 1;\r\n}\r\nint ext4_fname_disk_to_usr(struct inode *inode,\r\nstruct dx_hash_info *hinfo,\r\nconst struct ext4_dir_entry_2 *de,\r\nstruct ext4_str *oname)\r\n{\r\nstruct ext4_str iname = {.name = (unsigned char *) de->name,\r\n.len = de->name_len };\r\nreturn _ext4_fname_disk_to_usr(inode, hinfo, &iname, oname);\r\n}\r\nint ext4_fname_usr_to_disk(struct inode *inode,\r\nconst struct qstr *iname,\r\nstruct ext4_str *oname)\r\n{\r\nint res;\r\nstruct ext4_crypt_info *ci = EXT4_I(inode)->i_crypt_info;\r\nif (iname->len < 3) {\r\nif (iname->name[0] == '.' &&\r\niname->name[iname->len-1] == '.') {\r\noname->name[0] = '.';\r\noname->name[iname->len-1] = '.';\r\noname->len = iname->len;\r\nreturn oname->len;\r\n}\r\n}\r\nif (ci) {\r\nres = ext4_fname_encrypt(inode, iname, oname);\r\nreturn res;\r\n}\r\nreturn -EACCES;\r\n}\r\nint ext4_fname_setup_filename(struct inode *dir, const struct qstr *iname,\r\nint lookup, struct ext4_filename *fname)\r\n{\r\nstruct ext4_crypt_info *ci;\r\nint ret = 0, bigname = 0;\r\nmemset(fname, 0, sizeof(struct ext4_filename));\r\nfname->usr_fname = iname;\r\nif (!ext4_encrypted_inode(dir) ||\r\n((iname->name[0] == '.') &&\r\n((iname->len == 1) ||\r\n((iname->name[1] == '.') && (iname->len == 2))))) {\r\nfname->disk_name.name = (unsigned char *) iname->name;\r\nfname->disk_name.len = iname->len;\r\nreturn 0;\r\n}\r\nret = ext4_get_encryption_info(dir);\r\nif (ret)\r\nreturn ret;\r\nci = EXT4_I(dir)->i_crypt_info;\r\nif (ci) {\r\nret = ext4_fname_crypto_alloc_buffer(dir, iname->len,\r\n&fname->crypto_buf);\r\nif (ret < 0)\r\nreturn ret;\r\nret = ext4_fname_encrypt(dir, iname, &fname->crypto_buf);\r\nif (ret < 0)\r\ngoto errout;\r\nfname->disk_name.name = fname->crypto_buf.name;\r\nfname->disk_name.len = fname->crypto_buf.len;\r\nreturn 0;\r\n}\r\nif (!lookup)\r\nreturn -EACCES;\r\nif (iname->name[0] == '_')\r\nbigname = 1;\r\nif ((bigname && (iname->len != 33)) ||\r\n(!bigname && (iname->len > 43)))\r\nreturn -ENOENT;\r\nfname->crypto_buf.name = kmalloc(32, GFP_KERNEL);\r\nif (fname->crypto_buf.name == NULL)\r\nreturn -ENOMEM;\r\nret = digest_decode(iname->name + bigname, iname->len - bigname,\r\nfname->crypto_buf.name);\r\nif (ret < 0) {\r\nret = -ENOENT;\r\ngoto errout;\r\n}\r\nfname->crypto_buf.len = ret;\r\nif (bigname) {\r\nmemcpy(&fname->hinfo.hash, fname->crypto_buf.name, 4);\r\nmemcpy(&fname->hinfo.minor_hash, fname->crypto_buf.name + 4, 4);\r\n} else {\r\nfname->disk_name.name = fname->crypto_buf.name;\r\nfname->disk_name.len = fname->crypto_buf.len;\r\n}\r\nreturn 0;\r\nerrout:\r\nkfree(fname->crypto_buf.name);\r\nfname->crypto_buf.name = NULL;\r\nreturn ret;\r\n}\r\nvoid ext4_fname_free_filename(struct ext4_filename *fname)\r\n{\r\nkfree(fname->crypto_buf.name);\r\nfname->crypto_buf.name = NULL;\r\nfname->usr_fname = NULL;\r\nfname->disk_name.name = NULL;\r\n}
