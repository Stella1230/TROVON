static bool\r\nicmpv6_in_range(const struct nf_conntrack_tuple *tuple,\r\nenum nf_nat_manip_type maniptype,\r\nconst union nf_conntrack_man_proto *min,\r\nconst union nf_conntrack_man_proto *max)\r\n{\r\nreturn ntohs(tuple->src.u.icmp.id) >= ntohs(min->icmp.id) &&\r\nntohs(tuple->src.u.icmp.id) <= ntohs(max->icmp.id);\r\n}\r\nstatic void\r\nicmpv6_unique_tuple(const struct nf_nat_l3proto *l3proto,\r\nstruct nf_conntrack_tuple *tuple,\r\nconst struct nf_nat_range *range,\r\nenum nf_nat_manip_type maniptype,\r\nconst struct nf_conn *ct)\r\n{\r\nstatic u16 id;\r\nunsigned int range_size;\r\nunsigned int i;\r\nrange_size = ntohs(range->max_proto.icmp.id) -\r\nntohs(range->min_proto.icmp.id) + 1;\r\nif (!(range->flags & NF_NAT_RANGE_PROTO_SPECIFIED))\r\nrange_size = 0xffff;\r\nfor (i = 0; ; ++id) {\r\ntuple->src.u.icmp.id = htons(ntohs(range->min_proto.icmp.id) +\r\n(id % range_size));\r\nif (++i == range_size || !nf_nat_used_tuple(tuple, ct))\r\nreturn;\r\n}\r\n}\r\nstatic bool\r\nicmpv6_manip_pkt(struct sk_buff *skb,\r\nconst struct nf_nat_l3proto *l3proto,\r\nunsigned int iphdroff, unsigned int hdroff,\r\nconst struct nf_conntrack_tuple *tuple,\r\nenum nf_nat_manip_type maniptype)\r\n{\r\nstruct icmp6hdr *hdr;\r\nif (!skb_make_writable(skb, hdroff + sizeof(*hdr)))\r\nreturn false;\r\nhdr = (struct icmp6hdr *)(skb->data + hdroff);\r\nl3proto->csum_update(skb, iphdroff, &hdr->icmp6_cksum,\r\ntuple, maniptype);\r\nif (hdr->icmp6_type == ICMPV6_ECHO_REQUEST ||\r\nhdr->icmp6_type == ICMPV6_ECHO_REPLY) {\r\ninet_proto_csum_replace2(&hdr->icmp6_cksum, skb,\r\nhdr->icmp6_identifier,\r\ntuple->src.u.icmp.id, false);\r\nhdr->icmp6_identifier = tuple->src.u.icmp.id;\r\n}\r\nreturn true;\r\n}
