static int usb_get_report(struct usb_device *dev,\r\nstruct usb_host_interface *inter, unsigned char type,\r\nunsigned char id, void *buf, int size)\r\n{\r\nreturn usb_control_msg(dev, usb_rcvctrlpipe(dev, 0),\r\nUSB_REQ_GET_REPORT,\r\nUSB_DIR_IN | USB_TYPE_CLASS |\r\nUSB_RECIP_INTERFACE, (type << 8) + id,\r\ninter->desc.bInterfaceNumber, buf, size,\r\nGET_TIMEOUT*HZ);\r\n}\r\nstatic int usb_set_report(struct usb_interface *intf, unsigned char type,\r\nunsigned char id, void *buf, int size)\r\n{\r\nreturn usb_control_msg(interface_to_usbdev(intf),\r\nusb_sndctrlpipe(interface_to_usbdev(intf), 0),\r\nUSB_REQ_SET_REPORT,\r\nUSB_TYPE_CLASS | USB_RECIP_INTERFACE,\r\n(type << 8) + id,\r\nintf->cur_altsetting->desc.bInterfaceNumber, buf,\r\nsize, HZ);\r\n}\r\nstatic void iowarrior_callback(struct urb *urb)\r\n{\r\nstruct iowarrior *dev = urb->context;\r\nint intr_idx;\r\nint read_idx;\r\nint aux_idx;\r\nint offset;\r\nint status = urb->status;\r\nint retval;\r\nswitch (status) {\r\ncase 0:\r\nbreak;\r\ncase -ECONNRESET:\r\ncase -ENOENT:\r\ncase -ESHUTDOWN:\r\nreturn;\r\ndefault:\r\ngoto exit;\r\n}\r\nspin_lock(&dev->intr_idx_lock);\r\nintr_idx = atomic_read(&dev->intr_idx);\r\naux_idx = (intr_idx == 0) ? (MAX_INTERRUPT_BUFFER - 1) : (intr_idx - 1);\r\nread_idx = atomic_read(&dev->read_idx);\r\nif ((intr_idx != read_idx)\r\n&& (dev->interface->cur_altsetting->desc.bInterfaceNumber == 0)) {\r\noffset = aux_idx * (dev->report_size + 1);\r\nif (!memcmp\r\n(dev->read_queue + offset, urb->transfer_buffer,\r\ndev->report_size)) {\r\nspin_unlock(&dev->intr_idx_lock);\r\ngoto exit;\r\n}\r\n}\r\naux_idx = (intr_idx == (MAX_INTERRUPT_BUFFER - 1)) ? 0 : (intr_idx + 1);\r\nif (read_idx == aux_idx) {\r\nread_idx = (++read_idx == MAX_INTERRUPT_BUFFER) ? 0 : read_idx;\r\natomic_set(&dev->read_idx, read_idx);\r\natomic_set(&dev->overflow_flag, 1);\r\n}\r\noffset = intr_idx * (dev->report_size + 1);\r\nmemcpy(dev->read_queue + offset, urb->transfer_buffer,\r\ndev->report_size);\r\n*(dev->read_queue + offset + (dev->report_size)) = dev->serial_number++;\r\natomic_set(&dev->intr_idx, aux_idx);\r\nspin_unlock(&dev->intr_idx_lock);\r\nwake_up_interruptible(&dev->read_wait);\r\nexit:\r\nretval = usb_submit_urb(urb, GFP_ATOMIC);\r\nif (retval)\r\ndev_err(&dev->interface->dev, "%s - usb_submit_urb failed with result %d\n",\r\n__func__, retval);\r\n}\r\nstatic void iowarrior_write_callback(struct urb *urb)\r\n{\r\nstruct iowarrior *dev;\r\nint status = urb->status;\r\ndev = urb->context;\r\nif (status &&\r\n!(status == -ENOENT ||\r\nstatus == -ECONNRESET || status == -ESHUTDOWN)) {\r\ndev_dbg(&dev->interface->dev,\r\n"nonzero write bulk status received: %d\n", status);\r\n}\r\nusb_free_coherent(urb->dev, urb->transfer_buffer_length,\r\nurb->transfer_buffer, urb->transfer_dma);\r\natomic_dec(&dev->write_busy);\r\nwake_up_interruptible(&dev->write_wait);\r\n}\r\nstatic inline void iowarrior_delete(struct iowarrior *dev)\r\n{\r\ndev_dbg(&dev->interface->dev, "minor %d\n", dev->minor);\r\nkfree(dev->int_in_buffer);\r\nusb_free_urb(dev->int_in_urb);\r\nkfree(dev->read_queue);\r\nkfree(dev);\r\n}\r\nstatic int read_index(struct iowarrior *dev)\r\n{\r\nint intr_idx, read_idx;\r\nread_idx = atomic_read(&dev->read_idx);\r\nintr_idx = atomic_read(&dev->intr_idx);\r\nreturn (read_idx == intr_idx ? -1 : read_idx);\r\n}\r\nstatic ssize_t iowarrior_read(struct file *file, char __user *buffer,\r\nsize_t count, loff_t *ppos)\r\n{\r\nstruct iowarrior *dev;\r\nint read_idx;\r\nint offset;\r\ndev = file->private_data;\r\nif (dev == NULL || !dev->present)\r\nreturn -ENODEV;\r\ndev_dbg(&dev->interface->dev, "minor %d, count = %zd\n",\r\ndev->minor, count);\r\nif ((count != dev->report_size)\r\n&& (count != (dev->report_size + 1)))\r\nreturn -EINVAL;\r\ndo {\r\natomic_set(&dev->overflow_flag, 0);\r\nif ((read_idx = read_index(dev)) == -1) {\r\nif (file->f_flags & O_NONBLOCK)\r\nreturn -EAGAIN;\r\nelse {\r\nint r = wait_event_interruptible(dev->read_wait,\r\n(!dev->present\r\n|| (read_idx =\r\nread_index\r\n(dev)) !=\r\n-1));\r\nif (r) {\r\nreturn -ERESTART;\r\n}\r\nif (!dev->present) {\r\nreturn -ENODEV;\r\n}\r\nif (read_idx == -1) {\r\nreturn 0;\r\n}\r\n}\r\n}\r\noffset = read_idx * (dev->report_size + 1);\r\nif (copy_to_user(buffer, dev->read_queue + offset, count)) {\r\nreturn -EFAULT;\r\n}\r\n} while (atomic_read(&dev->overflow_flag));\r\nread_idx = ++read_idx == MAX_INTERRUPT_BUFFER ? 0 : read_idx;\r\natomic_set(&dev->read_idx, read_idx);\r\nreturn count;\r\n}\r\nstatic ssize_t iowarrior_write(struct file *file,\r\nconst char __user *user_buffer,\r\nsize_t count, loff_t *ppos)\r\n{\r\nstruct iowarrior *dev;\r\nint retval = 0;\r\nchar *buf = NULL;\r\nstruct urb *int_out_urb = NULL;\r\ndev = file->private_data;\r\nmutex_lock(&dev->mutex);\r\nif (!dev->present) {\r\nretval = -ENODEV;\r\ngoto exit;\r\n}\r\ndev_dbg(&dev->interface->dev, "minor %d, count = %zd\n",\r\ndev->minor, count);\r\nif (count == 0) {\r\nretval = 0;\r\ngoto exit;\r\n}\r\nif (count != dev->report_size) {\r\nretval = -EINVAL;\r\ngoto exit;\r\n}\r\nswitch (dev->product_id) {\r\ncase USB_DEVICE_ID_CODEMERCS_IOW24:\r\ncase USB_DEVICE_ID_CODEMERCS_IOWPV1:\r\ncase USB_DEVICE_ID_CODEMERCS_IOWPV2:\r\ncase USB_DEVICE_ID_CODEMERCS_IOW40:\r\nbuf = kmalloc(count, GFP_KERNEL);\r\nif (!buf) {\r\nretval = -ENOMEM;\r\ngoto exit;\r\n}\r\nif (copy_from_user(buf, user_buffer, count)) {\r\nretval = -EFAULT;\r\nkfree(buf);\r\ngoto exit;\r\n}\r\nretval = usb_set_report(dev->interface, 2, 0, buf, count);\r\nkfree(buf);\r\ngoto exit;\r\nbreak;\r\ncase USB_DEVICE_ID_CODEMERCS_IOW56:\r\nif (atomic_read(&dev->write_busy) == MAX_WRITES_IN_FLIGHT) {\r\nif (file->f_flags & O_NONBLOCK) {\r\nretval = -EAGAIN;\r\ngoto exit;\r\n} else {\r\nretval = wait_event_interruptible(dev->write_wait,\r\n(!dev->present || (atomic_read (&dev-> write_busy) < MAX_WRITES_IN_FLIGHT)));\r\nif (retval) {\r\nretval = -ERESTART;\r\ngoto exit;\r\n}\r\nif (!dev->present) {\r\nretval = -ENODEV;\r\ngoto exit;\r\n}\r\nif (!dev->opened) {\r\nretval = -ENODEV;\r\ngoto exit;\r\n}\r\n}\r\n}\r\natomic_inc(&dev->write_busy);\r\nint_out_urb = usb_alloc_urb(0, GFP_KERNEL);\r\nif (!int_out_urb) {\r\nretval = -ENOMEM;\r\ndev_dbg(&dev->interface->dev,\r\n"Unable to allocate urb\n");\r\ngoto error_no_urb;\r\n}\r\nbuf = usb_alloc_coherent(dev->udev, dev->report_size,\r\nGFP_KERNEL, &int_out_urb->transfer_dma);\r\nif (!buf) {\r\nretval = -ENOMEM;\r\ndev_dbg(&dev->interface->dev,\r\n"Unable to allocate buffer\n");\r\ngoto error_no_buffer;\r\n}\r\nusb_fill_int_urb(int_out_urb, dev->udev,\r\nusb_sndintpipe(dev->udev,\r\ndev->int_out_endpoint->bEndpointAddress),\r\nbuf, dev->report_size,\r\niowarrior_write_callback, dev,\r\ndev->int_out_endpoint->bInterval);\r\nint_out_urb->transfer_flags |= URB_NO_TRANSFER_DMA_MAP;\r\nif (copy_from_user(buf, user_buffer, count)) {\r\nretval = -EFAULT;\r\ngoto error;\r\n}\r\nretval = usb_submit_urb(int_out_urb, GFP_KERNEL);\r\nif (retval) {\r\ndev_dbg(&dev->interface->dev,\r\n"submit error %d for urb nr.%d\n",\r\nretval, atomic_read(&dev->write_busy));\r\ngoto error;\r\n}\r\nretval = count;\r\nusb_free_urb(int_out_urb);\r\ngoto exit;\r\nbreak;\r\ndefault:\r\ndev_err(&dev->interface->dev, "%s - not supported for product=0x%x\n",\r\n__func__, dev->product_id);\r\nretval = -EFAULT;\r\ngoto exit;\r\nbreak;\r\n}\r\nerror:\r\nusb_free_coherent(dev->udev, dev->report_size, buf,\r\nint_out_urb->transfer_dma);\r\nerror_no_buffer:\r\nusb_free_urb(int_out_urb);\r\nerror_no_urb:\r\natomic_dec(&dev->write_busy);\r\nwake_up_interruptible(&dev->write_wait);\r\nexit:\r\nmutex_unlock(&dev->mutex);\r\nreturn retval;\r\n}\r\nstatic long iowarrior_ioctl(struct file *file, unsigned int cmd,\r\nunsigned long arg)\r\n{\r\nstruct iowarrior *dev = NULL;\r\n__u8 *buffer;\r\n__u8 __user *user_buffer;\r\nint retval;\r\nint io_res;\r\ndev = file->private_data;\r\nif (dev == NULL) {\r\nreturn -ENODEV;\r\n}\r\nbuffer = kzalloc(dev->report_size, GFP_KERNEL);\r\nif (!buffer)\r\nreturn -ENOMEM;\r\nmutex_lock(&iowarrior_mutex);\r\nmutex_lock(&dev->mutex);\r\nif (!dev->present) {\r\nretval = -ENODEV;\r\ngoto error_out;\r\n}\r\ndev_dbg(&dev->interface->dev, "minor %d, cmd 0x%.4x, arg %ld\n",\r\ndev->minor, cmd, arg);\r\nretval = 0;\r\nio_res = 0;\r\nswitch (cmd) {\r\ncase IOW_WRITE:\r\nif (dev->product_id == USB_DEVICE_ID_CODEMERCS_IOW24 ||\r\ndev->product_id == USB_DEVICE_ID_CODEMERCS_IOWPV1 ||\r\ndev->product_id == USB_DEVICE_ID_CODEMERCS_IOWPV2 ||\r\ndev->product_id == USB_DEVICE_ID_CODEMERCS_IOW40) {\r\nuser_buffer = (__u8 __user *)arg;\r\nio_res = copy_from_user(buffer, user_buffer,\r\ndev->report_size);\r\nif (io_res) {\r\nretval = -EFAULT;\r\n} else {\r\nio_res = usb_set_report(dev->interface, 2, 0,\r\nbuffer,\r\ndev->report_size);\r\nif (io_res < 0)\r\nretval = io_res;\r\n}\r\n} else {\r\nretval = -EINVAL;\r\ndev_err(&dev->interface->dev,\r\n"ioctl 'IOW_WRITE' is not supported for product=0x%x.\n",\r\ndev->product_id);\r\n}\r\nbreak;\r\ncase IOW_READ:\r\nuser_buffer = (__u8 __user *)arg;\r\nio_res = usb_get_report(dev->udev,\r\ndev->interface->cur_altsetting, 1, 0,\r\nbuffer, dev->report_size);\r\nif (io_res < 0)\r\nretval = io_res;\r\nelse {\r\nio_res = copy_to_user(user_buffer, buffer, dev->report_size);\r\nif (io_res)\r\nretval = -EFAULT;\r\n}\r\nbreak;\r\ncase IOW_GETINFO:\r\n{\r\nstruct iowarrior_info info;\r\nstruct usb_config_descriptor *cfg_descriptor = &dev->udev->actconfig->desc;\r\nmemset(&info, 0, sizeof(info));\r\ninfo.vendor = le16_to_cpu(dev->udev->descriptor.idVendor);\r\ninfo.product = dev->product_id;\r\ninfo.revision = le16_to_cpu(dev->udev->descriptor.bcdDevice);\r\ninfo.speed = le16_to_cpu(dev->udev->speed);\r\ninfo.if_num = dev->interface->cur_altsetting->desc.bInterfaceNumber;\r\ninfo.report_size = dev->report_size;\r\nmemcpy(info.serial, dev->chip_serial,\r\nsizeof(dev->chip_serial));\r\nif (cfg_descriptor == NULL) {\r\ninfo.power = -1;\r\n} else {\r\ninfo.power = cfg_descriptor->bMaxPower * 2;\r\n}\r\nio_res = copy_to_user((struct iowarrior_info __user *)arg, &info,\r\nsizeof(struct iowarrior_info));\r\nif (io_res)\r\nretval = -EFAULT;\r\nbreak;\r\n}\r\ndefault:\r\nretval = -ENOTTY;\r\nbreak;\r\n}\r\nerror_out:\r\nmutex_unlock(&dev->mutex);\r\nmutex_unlock(&iowarrior_mutex);\r\nkfree(buffer);\r\nreturn retval;\r\n}\r\nstatic int iowarrior_open(struct inode *inode, struct file *file)\r\n{\r\nstruct iowarrior *dev = NULL;\r\nstruct usb_interface *interface;\r\nint subminor;\r\nint retval = 0;\r\nmutex_lock(&iowarrior_mutex);\r\nsubminor = iminor(inode);\r\ninterface = usb_find_interface(&iowarrior_driver, subminor);\r\nif (!interface) {\r\nmutex_unlock(&iowarrior_mutex);\r\nprintk(KERN_ERR "%s - error, can't find device for minor %d\n",\r\n__func__, subminor);\r\nreturn -ENODEV;\r\n}\r\nmutex_lock(&iowarrior_open_disc_lock);\r\ndev = usb_get_intfdata(interface);\r\nif (!dev) {\r\nmutex_unlock(&iowarrior_open_disc_lock);\r\nmutex_unlock(&iowarrior_mutex);\r\nreturn -ENODEV;\r\n}\r\nmutex_lock(&dev->mutex);\r\nmutex_unlock(&iowarrior_open_disc_lock);\r\nif (dev->opened) {\r\nretval = -EBUSY;\r\ngoto out;\r\n}\r\nif ((retval = usb_submit_urb(dev->int_in_urb, GFP_KERNEL)) < 0) {\r\ndev_err(&interface->dev, "Error %d while submitting URB\n", retval);\r\nretval = -EFAULT;\r\ngoto out;\r\n}\r\n++dev->opened;\r\nfile->private_data = dev;\r\nretval = 0;\r\nout:\r\nmutex_unlock(&dev->mutex);\r\nmutex_unlock(&iowarrior_mutex);\r\nreturn retval;\r\n}\r\nstatic int iowarrior_release(struct inode *inode, struct file *file)\r\n{\r\nstruct iowarrior *dev;\r\nint retval = 0;\r\ndev = file->private_data;\r\nif (dev == NULL) {\r\nreturn -ENODEV;\r\n}\r\ndev_dbg(&dev->interface->dev, "minor %d\n", dev->minor);\r\nmutex_lock(&dev->mutex);\r\nif (dev->opened <= 0) {\r\nretval = -ENODEV;\r\nmutex_unlock(&dev->mutex);\r\n} else {\r\ndev->opened = 0;\r\nretval = 0;\r\nif (dev->present) {\r\nusb_kill_urb(dev->int_in_urb);\r\nwake_up_interruptible(&dev->read_wait);\r\nwake_up_interruptible(&dev->write_wait);\r\nmutex_unlock(&dev->mutex);\r\n} else {\r\nmutex_unlock(&dev->mutex);\r\niowarrior_delete(dev);\r\n}\r\n}\r\nreturn retval;\r\n}\r\nstatic unsigned iowarrior_poll(struct file *file, poll_table * wait)\r\n{\r\nstruct iowarrior *dev = file->private_data;\r\nunsigned int mask = 0;\r\nif (!dev->present)\r\nreturn POLLERR | POLLHUP;\r\npoll_wait(file, &dev->read_wait, wait);\r\npoll_wait(file, &dev->write_wait, wait);\r\nif (!dev->present)\r\nreturn POLLERR | POLLHUP;\r\nif (read_index(dev) != -1)\r\nmask |= POLLIN | POLLRDNORM;\r\nif (atomic_read(&dev->write_busy) < MAX_WRITES_IN_FLIGHT)\r\nmask |= POLLOUT | POLLWRNORM;\r\nreturn mask;\r\n}\r\nstatic char *iowarrior_devnode(struct device *dev, umode_t *mode)\r\n{\r\nreturn kasprintf(GFP_KERNEL, "usb/%s", dev_name(dev));\r\n}\r\nstatic int iowarrior_probe(struct usb_interface *interface,\r\nconst struct usb_device_id *id)\r\n{\r\nstruct usb_device *udev = interface_to_usbdev(interface);\r\nstruct iowarrior *dev = NULL;\r\nstruct usb_host_interface *iface_desc;\r\nstruct usb_endpoint_descriptor *endpoint;\r\nint i;\r\nint retval = -ENOMEM;\r\ndev = kzalloc(sizeof(struct iowarrior), GFP_KERNEL);\r\nif (dev == NULL) {\r\ndev_err(&interface->dev, "Out of memory\n");\r\nreturn retval;\r\n}\r\nmutex_init(&dev->mutex);\r\natomic_set(&dev->intr_idx, 0);\r\natomic_set(&dev->read_idx, 0);\r\nspin_lock_init(&dev->intr_idx_lock);\r\natomic_set(&dev->overflow_flag, 0);\r\ninit_waitqueue_head(&dev->read_wait);\r\natomic_set(&dev->write_busy, 0);\r\ninit_waitqueue_head(&dev->write_wait);\r\ndev->udev = udev;\r\ndev->interface = interface;\r\niface_desc = interface->cur_altsetting;\r\ndev->product_id = le16_to_cpu(udev->descriptor.idProduct);\r\nif (iface_desc->desc.bNumEndpoints < 1) {\r\ndev_err(&interface->dev, "Invalid number of endpoints\n");\r\nretval = -EINVAL;\r\ngoto error;\r\n}\r\nfor (i = 0; i < iface_desc->desc.bNumEndpoints; ++i) {\r\nendpoint = &iface_desc->endpoint[i].desc;\r\nif (usb_endpoint_is_int_in(endpoint))\r\ndev->int_in_endpoint = endpoint;\r\nif (usb_endpoint_is_int_out(endpoint))\r\ndev->int_out_endpoint = endpoint;\r\n}\r\ndev->report_size = usb_endpoint_maxp(dev->int_in_endpoint);\r\nif ((dev->interface->cur_altsetting->desc.bInterfaceNumber == 0) &&\r\n(dev->product_id == USB_DEVICE_ID_CODEMERCS_IOW56))\r\ndev->report_size = 7;\r\ndev->int_in_urb = usb_alloc_urb(0, GFP_KERNEL);\r\nif (!dev->int_in_urb) {\r\ndev_err(&interface->dev, "Couldn't allocate interrupt_in_urb\n");\r\ngoto error;\r\n}\r\ndev->int_in_buffer = kmalloc(dev->report_size, GFP_KERNEL);\r\nif (!dev->int_in_buffer) {\r\ndev_err(&interface->dev, "Couldn't allocate int_in_buffer\n");\r\ngoto error;\r\n}\r\nusb_fill_int_urb(dev->int_in_urb, dev->udev,\r\nusb_rcvintpipe(dev->udev,\r\ndev->int_in_endpoint->bEndpointAddress),\r\ndev->int_in_buffer, dev->report_size,\r\niowarrior_callback, dev,\r\ndev->int_in_endpoint->bInterval);\r\ndev->read_queue =\r\nkmalloc(((dev->report_size + 1) * MAX_INTERRUPT_BUFFER),\r\nGFP_KERNEL);\r\nif (!dev->read_queue) {\r\ndev_err(&interface->dev, "Couldn't allocate read_queue\n");\r\ngoto error;\r\n}\r\nmemset(dev->chip_serial, 0x00, sizeof(dev->chip_serial));\r\nusb_string(udev, udev->descriptor.iSerialNumber, dev->chip_serial,\r\nsizeof(dev->chip_serial));\r\nif (strlen(dev->chip_serial) != 8)\r\nmemset(dev->chip_serial, 0x00, sizeof(dev->chip_serial));\r\nif (dev->interface->cur_altsetting->desc.bInterfaceNumber == 0) {\r\nusb_control_msg(udev, usb_sndctrlpipe(udev, 0),\r\n0x0A,\r\nUSB_TYPE_CLASS | USB_RECIP_INTERFACE, 0,\r\n0, NULL, 0, USB_CTRL_SET_TIMEOUT);\r\n}\r\ndev->present = 1;\r\nusb_set_intfdata(interface, dev);\r\nretval = usb_register_dev(interface, &iowarrior_class);\r\nif (retval) {\r\ndev_err(&interface->dev, "Not able to get a minor for this device.\n");\r\nusb_set_intfdata(interface, NULL);\r\ngoto error;\r\n}\r\ndev->minor = interface->minor;\r\ndev_info(&interface->dev, "IOWarrior product=0x%x, serial=%s interface=%d "\r\n"now attached to iowarrior%d\n", dev->product_id, dev->chip_serial,\r\niface_desc->desc.bInterfaceNumber, dev->minor - IOWARRIOR_MINOR_BASE);\r\nreturn retval;\r\nerror:\r\niowarrior_delete(dev);\r\nreturn retval;\r\n}\r\nstatic void iowarrior_disconnect(struct usb_interface *interface)\r\n{\r\nstruct iowarrior *dev;\r\nint minor;\r\ndev = usb_get_intfdata(interface);\r\nmutex_lock(&iowarrior_open_disc_lock);\r\nusb_set_intfdata(interface, NULL);\r\nminor = dev->minor;\r\nusb_deregister_dev(interface, &iowarrior_class);\r\nmutex_lock(&dev->mutex);\r\ndev->present = 0;\r\nmutex_unlock(&dev->mutex);\r\nmutex_unlock(&iowarrior_open_disc_lock);\r\nif (dev->opened) {\r\nusb_kill_urb(dev->int_in_urb);\r\nwake_up_interruptible(&dev->read_wait);\r\nwake_up_interruptible(&dev->write_wait);\r\n} else {\r\niowarrior_delete(dev);\r\n}\r\ndev_info(&interface->dev, "I/O-Warror #%d now disconnected\n",\r\nminor - IOWARRIOR_MINOR_BASE);\r\n}
