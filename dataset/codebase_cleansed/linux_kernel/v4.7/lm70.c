static ssize_t lm70_sense_temp(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct lm70 *p_lm70 = dev_get_drvdata(dev);\r\nstruct spi_device *spi = p_lm70->spi;\r\nint status, val = 0;\r\nu8 rxbuf[2];\r\ns16 raw = 0;\r\nif (mutex_lock_interruptible(&p_lm70->lock))\r\nreturn -ERESTARTSYS;\r\nstatus = spi_write_then_read(spi, NULL, 0, &rxbuf[0], 2);\r\nif (status < 0) {\r\npr_warn("spi_write_then_read failed with status %d\n", status);\r\ngoto out;\r\n}\r\nraw = (rxbuf[0] << 8) + rxbuf[1];\r\ndev_dbg(dev, "rxbuf[0] : 0x%02x rxbuf[1] : 0x%02x raw=0x%04x\n",\r\nrxbuf[0], rxbuf[1], raw);\r\nswitch (p_lm70->chip) {\r\ncase LM70_CHIP_LM70:\r\nval = ((int)raw / 32) * 250;\r\nbreak;\r\ncase LM70_CHIP_TMP121:\r\ncase LM70_CHIP_LM74:\r\nval = ((int)raw / 8) * 625 / 10;\r\nbreak;\r\ncase LM70_CHIP_LM71:\r\nval = ((int)raw / 4) * 3125 / 100;\r\nbreak;\r\n}\r\nstatus = sprintf(buf, "%d\n", val);\r\nout:\r\nmutex_unlock(&p_lm70->lock);\r\nreturn status;\r\n}\r\nstatic int lm70_probe(struct spi_device *spi)\r\n{\r\nconst struct of_device_id *match;\r\nstruct device *hwmon_dev;\r\nstruct lm70 *p_lm70;\r\nint chip;\r\nmatch = of_match_device(lm70_of_ids, &spi->dev);\r\nif (match)\r\nchip = (int)(uintptr_t)match->data;\r\nelse\r\nchip = spi_get_device_id(spi)->driver_data;\r\nif (spi->mode & (SPI_CPOL | SPI_CPHA))\r\nreturn -EINVAL;\r\np_lm70 = devm_kzalloc(&spi->dev, sizeof(*p_lm70), GFP_KERNEL);\r\nif (!p_lm70)\r\nreturn -ENOMEM;\r\nmutex_init(&p_lm70->lock);\r\np_lm70->chip = chip;\r\np_lm70->spi = spi;\r\nhwmon_dev = devm_hwmon_device_register_with_groups(&spi->dev,\r\nspi->modalias,\r\np_lm70, lm70_groups);\r\nreturn PTR_ERR_OR_ZERO(hwmon_dev);\r\n}
