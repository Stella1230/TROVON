static __init void vtwm_set_pmc_base(void)\r\n{\r\nstruct device_node *np =\r\nof_find_compatible_node(NULL, NULL, "via,vt8500-pmc");\r\nif (np)\r\npmc_base = of_iomap(np, 0);\r\nelse\r\npmc_base = ioremap(LEGACY_PMC_BASE, 0x1000);\r\nof_node_put(np);\r\nif (!pmc_base)\r\npr_err("%s:of_iomap(pmc) failed\n", __func__);\r\n}\r\nstatic void vt8500_pmc_wait_busy(void)\r\n{\r\nwhile (readl(pmc_base) & VT8500_PMC_BUSY_MASK)\r\ncpu_relax();\r\n}\r\nstatic int vt8500_dclk_enable(struct clk_hw *hw)\r\n{\r\nstruct clk_device *cdev = to_clk_device(hw);\r\nu32 en_val;\r\nunsigned long flags = 0;\r\nspin_lock_irqsave(cdev->lock, flags);\r\nen_val = readl(cdev->en_reg);\r\nen_val |= BIT(cdev->en_bit);\r\nwritel(en_val, cdev->en_reg);\r\nspin_unlock_irqrestore(cdev->lock, flags);\r\nreturn 0;\r\n}\r\nstatic void vt8500_dclk_disable(struct clk_hw *hw)\r\n{\r\nstruct clk_device *cdev = to_clk_device(hw);\r\nu32 en_val;\r\nunsigned long flags = 0;\r\nspin_lock_irqsave(cdev->lock, flags);\r\nen_val = readl(cdev->en_reg);\r\nen_val &= ~BIT(cdev->en_bit);\r\nwritel(en_val, cdev->en_reg);\r\nspin_unlock_irqrestore(cdev->lock, flags);\r\n}\r\nstatic int vt8500_dclk_is_enabled(struct clk_hw *hw)\r\n{\r\nstruct clk_device *cdev = to_clk_device(hw);\r\nu32 en_val = (readl(cdev->en_reg) & BIT(cdev->en_bit));\r\nreturn en_val ? 1 : 0;\r\n}\r\nstatic unsigned long vt8500_dclk_recalc_rate(struct clk_hw *hw,\r\nunsigned long parent_rate)\r\n{\r\nstruct clk_device *cdev = to_clk_device(hw);\r\nu32 div = readl(cdev->div_reg) & cdev->div_mask;\r\nif ((cdev->div_mask == 0x3F) && (div & BIT(5)))\r\ndiv = 64 * (div & 0x1f);\r\nif (div == 0)\r\ndiv = (cdev->div_mask + 1);\r\nreturn parent_rate / div;\r\n}\r\nstatic long vt8500_dclk_round_rate(struct clk_hw *hw, unsigned long rate,\r\nunsigned long *prate)\r\n{\r\nstruct clk_device *cdev = to_clk_device(hw);\r\nu32 divisor;\r\nif (rate == 0)\r\nreturn 0;\r\ndivisor = *prate / rate;\r\nif (rate * divisor < *prate)\r\ndivisor++;\r\nif ((cdev->div_mask == 0x3F) && (divisor > 31)) {\r\ndivisor = 64 * ((divisor / 64) + 1);\r\n}\r\nreturn *prate / divisor;\r\n}\r\nstatic int vt8500_dclk_set_rate(struct clk_hw *hw, unsigned long rate,\r\nunsigned long parent_rate)\r\n{\r\nstruct clk_device *cdev = to_clk_device(hw);\r\nu32 divisor;\r\nunsigned long flags = 0;\r\nif (rate == 0)\r\nreturn 0;\r\ndivisor = parent_rate / rate;\r\nif (divisor == cdev->div_mask + 1)\r\ndivisor = 0;\r\nif ((cdev->div_mask == 0x3F) && (divisor > 31)) {\r\ndivisor = 0x20 + (divisor / 64);\r\n}\r\nif (divisor > cdev->div_mask) {\r\npr_err("%s: invalid divisor for clock\n", __func__);\r\nreturn -EINVAL;\r\n}\r\nspin_lock_irqsave(cdev->lock, flags);\r\nvt8500_pmc_wait_busy();\r\nwritel(divisor, cdev->div_reg);\r\nvt8500_pmc_wait_busy();\r\nspin_unlock_irqrestore(cdev->lock, flags);\r\nreturn 0;\r\n}\r\nstatic __init void vtwm_device_clk_init(struct device_node *node)\r\n{\r\nu32 en_reg, div_reg;\r\nstruct clk *clk;\r\nstruct clk_device *dev_clk;\r\nconst char *clk_name = node->name;\r\nconst char *parent_name;\r\nstruct clk_init_data init;\r\nint rc;\r\nint clk_init_flags = 0;\r\nif (!pmc_base)\r\nvtwm_set_pmc_base();\r\ndev_clk = kzalloc(sizeof(*dev_clk), GFP_KERNEL);\r\nif (WARN_ON(!dev_clk))\r\nreturn;\r\ndev_clk->lock = &_lock;\r\nrc = of_property_read_u32(node, "enable-reg", &en_reg);\r\nif (!rc) {\r\ndev_clk->en_reg = pmc_base + en_reg;\r\nrc = of_property_read_u32(node, "enable-bit", &dev_clk->en_bit);\r\nif (rc) {\r\npr_err("%s: enable-bit property required for gated clock\n",\r\n__func__);\r\nreturn;\r\n}\r\nclk_init_flags |= CLK_INIT_GATED;\r\n}\r\nrc = of_property_read_u32(node, "divisor-reg", &div_reg);\r\nif (!rc) {\r\ndev_clk->div_reg = pmc_base + div_reg;\r\ndev_clk->div_mask = 0x1f;\r\nof_property_read_u32(node, "divisor-mask", &dev_clk->div_mask);\r\nclk_init_flags |= CLK_INIT_DIVISOR;\r\n}\r\nof_property_read_string(node, "clock-output-names", &clk_name);\r\nswitch (clk_init_flags) {\r\ncase CLK_INIT_GATED:\r\ninit.ops = &vt8500_gated_clk_ops;\r\nbreak;\r\ncase CLK_INIT_DIVISOR:\r\ninit.ops = &vt8500_divisor_clk_ops;\r\nbreak;\r\ncase CLK_INIT_GATED_DIVISOR:\r\ninit.ops = &vt8500_gated_divisor_clk_ops;\r\nbreak;\r\ndefault:\r\npr_err("%s: Invalid clock description in device tree\n",\r\n__func__);\r\nkfree(dev_clk);\r\nreturn;\r\n}\r\ninit.name = clk_name;\r\ninit.flags = 0;\r\nparent_name = of_clk_get_parent_name(node, 0);\r\ninit.parent_names = &parent_name;\r\ninit.num_parents = 1;\r\ndev_clk->hw.init = &init;\r\nclk = clk_register(NULL, &dev_clk->hw);\r\nif (WARN_ON(IS_ERR(clk))) {\r\nkfree(dev_clk);\r\nreturn;\r\n}\r\nrc = of_clk_add_provider(node, of_clk_src_simple_get, clk);\r\nclk_register_clkdev(clk, clk_name, NULL);\r\n}\r\nstatic int vt8500_find_pll_bits(unsigned long rate, unsigned long parent_rate,\r\nu32 *multiplier, u32 *prediv)\r\n{\r\nunsigned long tclk;\r\nif ((rate < parent_rate * 4) || (rate > parent_rate * 62)) {\r\npr_err("%s: requested rate out of range\n", __func__);\r\n*multiplier = 0;\r\n*prediv = 1;\r\nreturn -EINVAL;\r\n}\r\nif (rate <= parent_rate * 31)\r\n*prediv = 2;\r\nelse\r\n*prediv = 1;\r\n*multiplier = rate / (parent_rate / *prediv);\r\ntclk = (parent_rate / *prediv) * *multiplier;\r\nif (tclk != rate)\r\npr_warn("%s: requested rate %lu, found rate %lu\n", __func__,\r\nrate, tclk);\r\nreturn 0;\r\n}\r\nstatic int wm8650_find_pll_bits(unsigned long rate, unsigned long parent_rate,\r\nu32 *multiplier, u32 *divisor1, u32 *divisor2)\r\n{\r\nu32 mul, div1;\r\nint div2;\r\nu32 best_mul, best_div1, best_div2;\r\nunsigned long tclk, rate_err, best_err;\r\nbest_err = (unsigned long)-1;\r\nfor (div1 = 5; div1 >= 3; div1--)\r\nfor (div2 = 3; div2 >= 0; div2--)\r\nfor (mul = 3; mul <= 1023; mul++) {\r\ntclk = parent_rate * mul / (div1 * (1 << div2));\r\nif (tclk > rate)\r\ncontinue;\r\nrate_err = rate - tclk;\r\nif (rate_err == 0) {\r\n*multiplier = mul;\r\n*divisor1 = div1;\r\n*divisor2 = div2;\r\nreturn 0;\r\n}\r\nif (rate_err < best_err) {\r\nbest_err = rate_err;\r\nbest_mul = mul;\r\nbest_div1 = div1;\r\nbest_div2 = div2;\r\n}\r\n}\r\nif (best_err == (unsigned long)-1) {\r\npr_warn("%s: impossible rate %lu\n", __func__, rate);\r\nreturn -EINVAL;\r\n}\r\npr_warn("%s: requested rate %lu, found rate %lu\n", __func__, rate,\r\nrate - best_err);\r\n*multiplier = best_mul;\r\n*divisor1 = best_div1;\r\n*divisor2 = best_div2;\r\nreturn 0;\r\n}\r\nstatic u32 wm8750_get_filter(u32 parent_rate, u32 divisor1)\r\n{\r\nu32 freq = (parent_rate / 1000000) / (divisor1 + 1);\r\nif ((freq < 10) || (freq > 200))\r\npr_warn("%s: PLL recommended input frequency 10..200Mhz (requested %d Mhz)\n",\r\n__func__, freq);\r\nif (freq >= 166)\r\nreturn 7;\r\nelse if (freq >= 104)\r\nreturn 6;\r\nelse if (freq >= 65)\r\nreturn 5;\r\nelse if (freq >= 42)\r\nreturn 4;\r\nelse if (freq >= 26)\r\nreturn 3;\r\nelse if (freq >= 16)\r\nreturn 2;\r\nelse if (freq >= 10)\r\nreturn 1;\r\nreturn 0;\r\n}\r\nstatic int wm8750_find_pll_bits(unsigned long rate, unsigned long parent_rate,\r\nu32 *filter, u32 *multiplier, u32 *divisor1, u32 *divisor2)\r\n{\r\nu32 mul;\r\nint div1, div2;\r\nu32 best_mul, best_div1, best_div2;\r\nunsigned long tclk, rate_err, best_err;\r\nbest_err = (unsigned long)-1;\r\nfor (div1 = 1; div1 >= 0; div1--)\r\nfor (div2 = 7; div2 >= 0; div2--)\r\nfor (mul = 0; mul <= 255; mul++) {\r\ntclk = parent_rate * (mul + 1) / ((div1 + 1) * (1 << div2));\r\nif (tclk > rate)\r\ncontinue;\r\nrate_err = rate - tclk;\r\nif (rate_err == 0) {\r\n*filter = wm8750_get_filter(parent_rate, div1);\r\n*multiplier = mul;\r\n*divisor1 = div1;\r\n*divisor2 = div2;\r\nreturn 0;\r\n}\r\nif (rate_err < best_err) {\r\nbest_err = rate_err;\r\nbest_mul = mul;\r\nbest_div1 = div1;\r\nbest_div2 = div2;\r\n}\r\n}\r\nif (best_err == (unsigned long)-1) {\r\npr_warn("%s: impossible rate %lu\n", __func__, rate);\r\nreturn -EINVAL;\r\n}\r\npr_warn("%s: requested rate %lu, found rate %lu\n", __func__, rate,\r\nrate - best_err);\r\n*filter = wm8750_get_filter(parent_rate, best_div1);\r\n*multiplier = best_mul;\r\n*divisor1 = best_div1;\r\n*divisor2 = best_div2;\r\nreturn 0;\r\n}\r\nstatic int wm8850_find_pll_bits(unsigned long rate, unsigned long parent_rate,\r\nu32 *multiplier, u32 *divisor1, u32 *divisor2)\r\n{\r\nu32 mul;\r\nint div1, div2;\r\nu32 best_mul, best_div1, best_div2;\r\nunsigned long tclk, rate_err, best_err;\r\nbest_err = (unsigned long)-1;\r\nfor (div1 = 1; div1 >= 0; div1--)\r\nfor (div2 = 3; div2 >= 0; div2--)\r\nfor (mul = 0; mul <= 127; mul++) {\r\ntclk = parent_rate * ((mul + 1) * 2) /\r\n((div1 + 1) * (1 << div2));\r\nif (tclk > rate)\r\ncontinue;\r\nrate_err = rate - tclk;\r\nif (rate_err == 0) {\r\n*multiplier = mul;\r\n*divisor1 = div1;\r\n*divisor2 = div2;\r\nreturn 0;\r\n}\r\nif (rate_err < best_err) {\r\nbest_err = rate_err;\r\nbest_mul = mul;\r\nbest_div1 = div1;\r\nbest_div2 = div2;\r\n}\r\n}\r\nif (best_err == (unsigned long)-1) {\r\npr_warn("%s: impossible rate %lu\n", __func__, rate);\r\nreturn -EINVAL;\r\n}\r\npr_warn("%s: requested rate %lu, found rate %lu\n", __func__, rate,\r\nrate - best_err);\r\n*multiplier = best_mul;\r\n*divisor1 = best_div1;\r\n*divisor2 = best_div2;\r\nreturn 0;\r\n}\r\nstatic int vtwm_pll_set_rate(struct clk_hw *hw, unsigned long rate,\r\nunsigned long parent_rate)\r\n{\r\nstruct clk_pll *pll = to_clk_pll(hw);\r\nu32 filter, mul, div1, div2;\r\nu32 pll_val;\r\nunsigned long flags = 0;\r\nint ret;\r\nswitch (pll->type) {\r\ncase PLL_TYPE_VT8500:\r\nret = vt8500_find_pll_bits(rate, parent_rate, &mul, &div1);\r\nif (!ret)\r\npll_val = VT8500_BITS_TO_VAL(mul, div1);\r\nbreak;\r\ncase PLL_TYPE_WM8650:\r\nret = wm8650_find_pll_bits(rate, parent_rate, &mul, &div1, &div2);\r\nif (!ret)\r\npll_val = WM8650_BITS_TO_VAL(mul, div1, div2);\r\nbreak;\r\ncase PLL_TYPE_WM8750:\r\nret = wm8750_find_pll_bits(rate, parent_rate, &filter, &mul, &div1, &div2);\r\nif (!ret)\r\npll_val = WM8750_BITS_TO_VAL(filter, mul, div1, div2);\r\nbreak;\r\ncase PLL_TYPE_WM8850:\r\nret = wm8850_find_pll_bits(rate, parent_rate, &mul, &div1, &div2);\r\nif (!ret)\r\npll_val = WM8850_BITS_TO_VAL(mul, div1, div2);\r\nbreak;\r\ndefault:\r\npr_err("%s: invalid pll type\n", __func__);\r\nret = -EINVAL;\r\n}\r\nif (ret)\r\nreturn ret;\r\nspin_lock_irqsave(pll->lock, flags);\r\nvt8500_pmc_wait_busy();\r\nwritel(pll_val, pll->reg);\r\nvt8500_pmc_wait_busy();\r\nspin_unlock_irqrestore(pll->lock, flags);\r\nreturn 0;\r\n}\r\nstatic long vtwm_pll_round_rate(struct clk_hw *hw, unsigned long rate,\r\nunsigned long *prate)\r\n{\r\nstruct clk_pll *pll = to_clk_pll(hw);\r\nu32 filter, mul, div1, div2;\r\nlong round_rate;\r\nint ret;\r\nswitch (pll->type) {\r\ncase PLL_TYPE_VT8500:\r\nret = vt8500_find_pll_bits(rate, *prate, &mul, &div1);\r\nif (!ret)\r\nround_rate = VT8500_BITS_TO_FREQ(*prate, mul, div1);\r\nbreak;\r\ncase PLL_TYPE_WM8650:\r\nret = wm8650_find_pll_bits(rate, *prate, &mul, &div1, &div2);\r\nif (!ret)\r\nround_rate = WM8650_BITS_TO_FREQ(*prate, mul, div1, div2);\r\nbreak;\r\ncase PLL_TYPE_WM8750:\r\nret = wm8750_find_pll_bits(rate, *prate, &filter, &mul, &div1, &div2);\r\nif (!ret)\r\nround_rate = WM8750_BITS_TO_FREQ(*prate, mul, div1, div2);\r\nbreak;\r\ncase PLL_TYPE_WM8850:\r\nret = wm8850_find_pll_bits(rate, *prate, &mul, &div1, &div2);\r\nif (!ret)\r\nround_rate = WM8850_BITS_TO_FREQ(*prate, mul, div1, div2);\r\nbreak;\r\ndefault:\r\nret = -EINVAL;\r\n}\r\nif (ret)\r\nreturn ret;\r\nreturn round_rate;\r\n}\r\nstatic unsigned long vtwm_pll_recalc_rate(struct clk_hw *hw,\r\nunsigned long parent_rate)\r\n{\r\nstruct clk_pll *pll = to_clk_pll(hw);\r\nu32 pll_val = readl(pll->reg);\r\nunsigned long pll_freq;\r\nswitch (pll->type) {\r\ncase PLL_TYPE_VT8500:\r\npll_freq = parent_rate * VT8500_PLL_MUL(pll_val);\r\npll_freq /= VT8500_PLL_DIV(pll_val);\r\nbreak;\r\ncase PLL_TYPE_WM8650:\r\npll_freq = parent_rate * WM8650_PLL_MUL(pll_val);\r\npll_freq /= WM8650_PLL_DIV(pll_val);\r\nbreak;\r\ncase PLL_TYPE_WM8750:\r\npll_freq = parent_rate * WM8750_PLL_MUL(pll_val);\r\npll_freq /= WM8750_PLL_DIV(pll_val);\r\nbreak;\r\ncase PLL_TYPE_WM8850:\r\npll_freq = parent_rate * WM8850_PLL_MUL(pll_val);\r\npll_freq /= WM8850_PLL_DIV(pll_val);\r\nbreak;\r\ndefault:\r\npll_freq = 0;\r\n}\r\nreturn pll_freq;\r\n}\r\nstatic __init void vtwm_pll_clk_init(struct device_node *node, int pll_type)\r\n{\r\nu32 reg;\r\nstruct clk *clk;\r\nstruct clk_pll *pll_clk;\r\nconst char *clk_name = node->name;\r\nconst char *parent_name;\r\nstruct clk_init_data init;\r\nint rc;\r\nif (!pmc_base)\r\nvtwm_set_pmc_base();\r\nrc = of_property_read_u32(node, "reg", &reg);\r\nif (WARN_ON(rc))\r\nreturn;\r\npll_clk = kzalloc(sizeof(*pll_clk), GFP_KERNEL);\r\nif (WARN_ON(!pll_clk))\r\nreturn;\r\npll_clk->reg = pmc_base + reg;\r\npll_clk->lock = &_lock;\r\npll_clk->type = pll_type;\r\nof_property_read_string(node, "clock-output-names", &clk_name);\r\ninit.name = clk_name;\r\ninit.ops = &vtwm_pll_ops;\r\ninit.flags = 0;\r\nparent_name = of_clk_get_parent_name(node, 0);\r\ninit.parent_names = &parent_name;\r\ninit.num_parents = 1;\r\npll_clk->hw.init = &init;\r\nclk = clk_register(NULL, &pll_clk->hw);\r\nif (WARN_ON(IS_ERR(clk))) {\r\nkfree(pll_clk);\r\nreturn;\r\n}\r\nrc = of_clk_add_provider(node, of_clk_src_simple_get, clk);\r\nclk_register_clkdev(clk, clk_name, NULL);\r\n}\r\nstatic void __init vt8500_pll_init(struct device_node *node)\r\n{\r\nvtwm_pll_clk_init(node, PLL_TYPE_VT8500);\r\n}\r\nstatic void __init wm8650_pll_init(struct device_node *node)\r\n{\r\nvtwm_pll_clk_init(node, PLL_TYPE_WM8650);\r\n}\r\nstatic void __init wm8750_pll_init(struct device_node *node)\r\n{\r\nvtwm_pll_clk_init(node, PLL_TYPE_WM8750);\r\n}\r\nstatic void __init wm8850_pll_init(struct device_node *node)\r\n{\r\nvtwm_pll_clk_init(node, PLL_TYPE_WM8850);\r\n}
