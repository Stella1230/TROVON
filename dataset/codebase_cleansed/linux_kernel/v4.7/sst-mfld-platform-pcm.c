int sst_register_dsp(struct sst_device *dev)\r\n{\r\nif (WARN_ON(!dev))\r\nreturn -EINVAL;\r\nif (!try_module_get(dev->dev->driver->owner))\r\nreturn -ENODEV;\r\nmutex_lock(&sst_lock);\r\nif (sst) {\r\ndev_err(dev->dev, "we already have a device %s\n", sst->name);\r\nmodule_put(dev->dev->driver->owner);\r\nmutex_unlock(&sst_lock);\r\nreturn -EEXIST;\r\n}\r\ndev_dbg(dev->dev, "registering device %s\n", dev->name);\r\nsst = dev;\r\nmutex_unlock(&sst_lock);\r\nreturn 0;\r\n}\r\nint sst_unregister_dsp(struct sst_device *dev)\r\n{\r\nif (WARN_ON(!dev))\r\nreturn -EINVAL;\r\nif (dev != sst)\r\nreturn -EINVAL;\r\nmutex_lock(&sst_lock);\r\nif (!sst) {\r\nmutex_unlock(&sst_lock);\r\nreturn -EIO;\r\n}\r\nmodule_put(sst->dev->driver->owner);\r\ndev_dbg(dev->dev, "unreg %s\n", sst->name);\r\nsst = NULL;\r\nmutex_unlock(&sst_lock);\r\nreturn 0;\r\n}\r\nstatic int sst_media_digital_mute(struct snd_soc_dai *dai, int mute, int stream)\r\n{\r\nreturn sst_send_pipe_gains(dai, stream, mute);\r\n}\r\nvoid sst_set_stream_status(struct sst_runtime_stream *stream,\r\nint state)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&stream->status_lock, flags);\r\nstream->stream_status = state;\r\nspin_unlock_irqrestore(&stream->status_lock, flags);\r\n}\r\nstatic inline int sst_get_stream_status(struct sst_runtime_stream *stream)\r\n{\r\nint state;\r\nunsigned long flags;\r\nspin_lock_irqsave(&stream->status_lock, flags);\r\nstate = stream->stream_status;\r\nspin_unlock_irqrestore(&stream->status_lock, flags);\r\nreturn state;\r\n}\r\nstatic void sst_fill_alloc_params(struct snd_pcm_substream *substream,\r\nstruct snd_sst_alloc_params_ext *alloc_param)\r\n{\r\nunsigned int channels;\r\nsnd_pcm_uframes_t period_size;\r\nssize_t periodbytes;\r\nssize_t buffer_bytes = snd_pcm_lib_buffer_bytes(substream);\r\nu32 buffer_addr = virt_to_phys(substream->dma_buffer.area);\r\nchannels = substream->runtime->channels;\r\nperiod_size = substream->runtime->period_size;\r\nperiodbytes = samples_to_bytes(substream->runtime, period_size);\r\nalloc_param->ring_buf_info[0].addr = buffer_addr;\r\nalloc_param->ring_buf_info[0].size = buffer_bytes;\r\nalloc_param->sg_count = 1;\r\nalloc_param->reserved = 0;\r\nalloc_param->frag_size = periodbytes * channels;\r\n}\r\nstatic void sst_fill_pcm_params(struct snd_pcm_substream *substream,\r\nstruct snd_sst_stream_params *param)\r\n{\r\nparam->uc.pcm_params.num_chan = (u8) substream->runtime->channels;\r\nparam->uc.pcm_params.pcm_wd_sz = substream->runtime->sample_bits;\r\nparam->uc.pcm_params.sfreq = substream->runtime->rate;\r\nparam->uc.pcm_params.use_offload_path = 0;\r\nparam->uc.pcm_params.reserved2 = 0;\r\nmemset(param->uc.pcm_params.channel_map, 0, sizeof(u8));\r\n}\r\nstatic int sst_get_stream_mapping(int dev, int sdev, int dir,\r\nstruct sst_dev_stream_map *map, int size)\r\n{\r\nint i;\r\nif (map == NULL)\r\nreturn -EINVAL;\r\nfor (i = 1; i < size; i++) {\r\nif ((map[i].dev_num == dev) && (map[i].direction == dir))\r\nreturn i;\r\n}\r\nreturn 0;\r\n}\r\nint sst_fill_stream_params(void *substream,\r\nconst struct sst_data *ctx, struct snd_sst_params *str_params, bool is_compress)\r\n{\r\nint map_size;\r\nint index;\r\nstruct sst_dev_stream_map *map;\r\nstruct snd_pcm_substream *pstream = NULL;\r\nstruct snd_compr_stream *cstream = NULL;\r\nmap = ctx->pdata->pdev_strm_map;\r\nmap_size = ctx->pdata->strm_map_size;\r\nif (is_compress == true)\r\ncstream = (struct snd_compr_stream *)substream;\r\nelse\r\npstream = (struct snd_pcm_substream *)substream;\r\nstr_params->stream_type = SST_STREAM_TYPE_MUSIC;\r\nif (pstream) {\r\nindex = sst_get_stream_mapping(pstream->pcm->device,\r\npstream->number, pstream->stream,\r\nmap, map_size);\r\nif (index <= 0)\r\nreturn -EINVAL;\r\nstr_params->stream_id = index;\r\nstr_params->device_type = map[index].device_id;\r\nstr_params->task = map[index].task_id;\r\nstr_params->ops = (u8)pstream->stream;\r\n}\r\nif (cstream) {\r\nindex = sst_get_stream_mapping(cstream->device->device,\r\n0, cstream->direction,\r\nmap, map_size);\r\nif (index <= 0)\r\nreturn -EINVAL;\r\nstr_params->stream_id = index;\r\nstr_params->device_type = map[index].device_id;\r\nstr_params->task = map[index].task_id;\r\nstr_params->ops = (u8)cstream->direction;\r\n}\r\nreturn 0;\r\n}\r\nstatic int sst_platform_alloc_stream(struct snd_pcm_substream *substream,\r\nstruct snd_soc_dai *dai)\r\n{\r\nstruct sst_runtime_stream *stream =\r\nsubstream->runtime->private_data;\r\nstruct snd_sst_stream_params param = {{{0,},},};\r\nstruct snd_sst_params str_params = {0};\r\nstruct snd_sst_alloc_params_ext alloc_params = {0};\r\nint ret_val = 0;\r\nstruct sst_data *ctx = snd_soc_dai_get_drvdata(dai);\r\nsst_fill_pcm_params(substream, &param);\r\nsst_fill_alloc_params(substream, &alloc_params);\r\nsubstream->runtime->dma_area = substream->dma_buffer.area;\r\nstr_params.sparams = param;\r\nstr_params.aparams = alloc_params;\r\nstr_params.codec = SST_CODEC_TYPE_PCM;\r\nret_val = sst_fill_stream_params(substream, ctx, &str_params, false);\r\nif (ret_val < 0)\r\nreturn ret_val;\r\nstream->stream_info.str_id = str_params.stream_id;\r\nret_val = stream->ops->open(sst->dev, &str_params);\r\nif (ret_val <= 0)\r\nreturn ret_val;\r\nreturn ret_val;\r\n}\r\nstatic void sst_period_elapsed(void *arg)\r\n{\r\nstruct snd_pcm_substream *substream = arg;\r\nstruct sst_runtime_stream *stream;\r\nint status;\r\nif (!substream || !substream->runtime)\r\nreturn;\r\nstream = substream->runtime->private_data;\r\nif (!stream)\r\nreturn;\r\nstatus = sst_get_stream_status(stream);\r\nif (status != SST_PLATFORM_RUNNING)\r\nreturn;\r\nsnd_pcm_period_elapsed(substream);\r\n}\r\nstatic int sst_platform_init_stream(struct snd_pcm_substream *substream)\r\n{\r\nstruct sst_runtime_stream *stream =\r\nsubstream->runtime->private_data;\r\nstruct snd_soc_pcm_runtime *rtd = substream->private_data;\r\nint ret_val;\r\ndev_dbg(rtd->dev, "setting buffer ptr param\n");\r\nsst_set_stream_status(stream, SST_PLATFORM_INIT);\r\nstream->stream_info.period_elapsed = sst_period_elapsed;\r\nstream->stream_info.arg = substream;\r\nstream->stream_info.buffer_ptr = 0;\r\nstream->stream_info.sfreq = substream->runtime->rate;\r\nret_val = stream->ops->stream_init(sst->dev, &stream->stream_info);\r\nif (ret_val)\r\ndev_err(rtd->dev, "control_set ret error %d\n", ret_val);\r\nreturn ret_val;\r\n}\r\nstatic int power_up_sst(struct sst_runtime_stream *stream)\r\n{\r\nreturn stream->ops->power(sst->dev, true);\r\n}\r\nstatic void power_down_sst(struct sst_runtime_stream *stream)\r\n{\r\nstream->ops->power(sst->dev, false);\r\n}\r\nstatic int sst_media_open(struct snd_pcm_substream *substream,\r\nstruct snd_soc_dai *dai)\r\n{\r\nint ret_val = 0;\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nstruct sst_runtime_stream *stream;\r\nstream = kzalloc(sizeof(*stream), GFP_KERNEL);\r\nif (!stream)\r\nreturn -ENOMEM;\r\nspin_lock_init(&stream->status_lock);\r\nmutex_lock(&sst_lock);\r\nif (!sst ||\r\n!try_module_get(sst->dev->driver->owner)) {\r\ndev_err(dai->dev, "no device available to run\n");\r\nret_val = -ENODEV;\r\ngoto out_ops;\r\n}\r\nstream->ops = sst->ops;\r\nmutex_unlock(&sst_lock);\r\nstream->stream_info.str_id = 0;\r\nstream->stream_info.arg = substream;\r\nruntime->private_data = stream;\r\nret_val = power_up_sst(stream);\r\nif (ret_val < 0)\r\nreturn ret_val;\r\nsnd_pcm_hw_constraint_step(substream->runtime, 0,\r\nSNDRV_PCM_HW_PARAM_PERIODS, 2);\r\nreturn snd_pcm_hw_constraint_integer(runtime,\r\nSNDRV_PCM_HW_PARAM_PERIODS);\r\nout_ops:\r\nkfree(stream);\r\nmutex_unlock(&sst_lock);\r\nreturn ret_val;\r\n}\r\nstatic void sst_media_close(struct snd_pcm_substream *substream,\r\nstruct snd_soc_dai *dai)\r\n{\r\nstruct sst_runtime_stream *stream;\r\nint ret_val = 0, str_id;\r\nstream = substream->runtime->private_data;\r\npower_down_sst(stream);\r\nstr_id = stream->stream_info.str_id;\r\nif (str_id)\r\nret_val = stream->ops->close(sst->dev, str_id);\r\nmodule_put(sst->dev->driver->owner);\r\nkfree(stream);\r\n}\r\nstatic int sst_media_prepare(struct snd_pcm_substream *substream,\r\nstruct snd_soc_dai *dai)\r\n{\r\nstruct sst_runtime_stream *stream;\r\nint ret_val = 0, str_id;\r\nstream = substream->runtime->private_data;\r\nstr_id = stream->stream_info.str_id;\r\nif (stream->stream_info.str_id) {\r\nret_val = stream->ops->stream_drop(sst->dev, str_id);\r\nreturn ret_val;\r\n}\r\nret_val = sst_platform_alloc_stream(substream, dai);\r\nif (ret_val <= 0)\r\nreturn ret_val;\r\nsnprintf(substream->pcm->id, sizeof(substream->pcm->id),\r\n"%d", stream->stream_info.str_id);\r\nret_val = sst_platform_init_stream(substream);\r\nif (ret_val)\r\nreturn ret_val;\r\nsubstream->runtime->hw.info = SNDRV_PCM_INFO_BLOCK_TRANSFER;\r\nreturn ret_val;\r\n}\r\nstatic int sst_media_hw_params(struct snd_pcm_substream *substream,\r\nstruct snd_pcm_hw_params *params,\r\nstruct snd_soc_dai *dai)\r\n{\r\nsnd_pcm_lib_malloc_pages(substream, params_buffer_bytes(params));\r\nmemset(substream->runtime->dma_area, 0, params_buffer_bytes(params));\r\nreturn 0;\r\n}\r\nstatic int sst_media_hw_free(struct snd_pcm_substream *substream,\r\nstruct snd_soc_dai *dai)\r\n{\r\nreturn snd_pcm_lib_free_pages(substream);\r\n}\r\nstatic int sst_enable_ssp(struct snd_pcm_substream *substream,\r\nstruct snd_soc_dai *dai)\r\n{\r\nint ret = 0;\r\nif (!dai->active) {\r\nret = sst_handle_vb_timer(dai, true);\r\nsst_fill_ssp_defaults(dai);\r\n}\r\nreturn ret;\r\n}\r\nstatic int sst_be_hw_params(struct snd_pcm_substream *substream,\r\nstruct snd_pcm_hw_params *params,\r\nstruct snd_soc_dai *dai)\r\n{\r\nint ret = 0;\r\nif (dai->active == 1)\r\nret = send_ssp_cmd(dai, dai->name, 1);\r\nreturn ret;\r\n}\r\nstatic int sst_set_format(struct snd_soc_dai *dai, unsigned int fmt)\r\n{\r\nint ret = 0;\r\nif (!dai->active)\r\nreturn 0;\r\nret = sst_fill_ssp_config(dai, fmt);\r\nif (ret < 0)\r\ndev_err(dai->dev, "sst_set_format failed..\n");\r\nreturn ret;\r\n}\r\nstatic int sst_platform_set_ssp_slot(struct snd_soc_dai *dai,\r\nunsigned int tx_mask, unsigned int rx_mask,\r\nint slots, int slot_width) {\r\nint ret = 0;\r\nif (!dai->active)\r\nreturn ret;\r\nret = sst_fill_ssp_slot(dai, tx_mask, rx_mask, slots, slot_width);\r\nif (ret < 0)\r\ndev_err(dai->dev, "sst_fill_ssp_slot failed..%d\n", ret);\r\nreturn ret;\r\n}\r\nstatic void sst_disable_ssp(struct snd_pcm_substream *substream,\r\nstruct snd_soc_dai *dai)\r\n{\r\nif (!dai->active) {\r\nsend_ssp_cmd(dai, dai->name, 0);\r\nsst_handle_vb_timer(dai, false);\r\n}\r\n}\r\nstatic int sst_platform_open(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_pcm_runtime *runtime;\r\nif (substream->pcm->internal)\r\nreturn 0;\r\nruntime = substream->runtime;\r\nruntime->hw = sst_platform_pcm_hw;\r\nreturn 0;\r\n}\r\nstatic int sst_platform_pcm_trigger(struct snd_pcm_substream *substream,\r\nint cmd)\r\n{\r\nint ret_val = 0, str_id;\r\nstruct sst_runtime_stream *stream;\r\nint status;\r\nstruct snd_soc_pcm_runtime *rtd = substream->private_data;\r\ndev_dbg(rtd->dev, "sst_platform_pcm_trigger called\n");\r\nif (substream->pcm->internal)\r\nreturn 0;\r\nstream = substream->runtime->private_data;\r\nstr_id = stream->stream_info.str_id;\r\nswitch (cmd) {\r\ncase SNDRV_PCM_TRIGGER_START:\r\ndev_dbg(rtd->dev, "sst: Trigger Start\n");\r\nstatus = SST_PLATFORM_RUNNING;\r\nstream->stream_info.arg = substream;\r\nret_val = stream->ops->stream_start(sst->dev, str_id);\r\nbreak;\r\ncase SNDRV_PCM_TRIGGER_STOP:\r\ndev_dbg(rtd->dev, "sst: in stop\n");\r\nstatus = SST_PLATFORM_DROPPED;\r\nret_val = stream->ops->stream_drop(sst->dev, str_id);\r\nbreak;\r\ncase SNDRV_PCM_TRIGGER_PAUSE_PUSH:\r\ncase SNDRV_PCM_TRIGGER_SUSPEND:\r\ndev_dbg(rtd->dev, "sst: in pause\n");\r\nstatus = SST_PLATFORM_PAUSED;\r\nret_val = stream->ops->stream_pause(sst->dev, str_id);\r\nbreak;\r\ncase SNDRV_PCM_TRIGGER_PAUSE_RELEASE:\r\ncase SNDRV_PCM_TRIGGER_RESUME:\r\ndev_dbg(rtd->dev, "sst: in pause release\n");\r\nstatus = SST_PLATFORM_RUNNING;\r\nret_val = stream->ops->stream_pause_release(sst->dev, str_id);\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nif (!ret_val)\r\nsst_set_stream_status(stream, status);\r\nreturn ret_val;\r\n}\r\nstatic snd_pcm_uframes_t sst_platform_pcm_pointer\r\n(struct snd_pcm_substream *substream)\r\n{\r\nstruct sst_runtime_stream *stream;\r\nint ret_val, status;\r\nstruct pcm_stream_info *str_info;\r\nstruct snd_soc_pcm_runtime *rtd = substream->private_data;\r\nstream = substream->runtime->private_data;\r\nstatus = sst_get_stream_status(stream);\r\nif (status == SST_PLATFORM_INIT)\r\nreturn 0;\r\nstr_info = &stream->stream_info;\r\nret_val = stream->ops->stream_read_tstamp(sst->dev, str_info);\r\nif (ret_val) {\r\ndev_err(rtd->dev, "sst: error code = %d\n", ret_val);\r\nreturn ret_val;\r\n}\r\nsubstream->runtime->delay = str_info->pcm_delay;\r\nreturn str_info->buffer_ptr;\r\n}\r\nstatic int sst_pcm_new(struct snd_soc_pcm_runtime *rtd)\r\n{\r\nstruct snd_soc_dai *dai = rtd->cpu_dai;\r\nstruct snd_pcm *pcm = rtd->pcm;\r\nint retval = 0;\r\nif (dai->driver->playback.channels_min ||\r\ndai->driver->capture.channels_min) {\r\nretval = snd_pcm_lib_preallocate_pages_for_all(pcm,\r\nSNDRV_DMA_TYPE_CONTINUOUS,\r\nsnd_dma_continuous_data(GFP_DMA),\r\nSST_MIN_BUFFER, SST_MAX_BUFFER);\r\nif (retval) {\r\ndev_err(rtd->dev, "dma buffer allocationf fail\n");\r\nreturn retval;\r\n}\r\n}\r\nreturn retval;\r\n}\r\nstatic int sst_soc_probe(struct snd_soc_platform *platform)\r\n{\r\nstruct sst_data *drv = dev_get_drvdata(platform->dev);\r\ndrv->soc_card = platform->component.card;\r\nreturn sst_dsp_init_v2_dpcm(platform);\r\n}\r\nstatic int sst_platform_probe(struct platform_device *pdev)\r\n{\r\nstruct sst_data *drv;\r\nint ret;\r\nstruct sst_platform_data *pdata;\r\ndrv = devm_kzalloc(&pdev->dev, sizeof(*drv), GFP_KERNEL);\r\nif (drv == NULL) {\r\nreturn -ENOMEM;\r\n}\r\npdata = devm_kzalloc(&pdev->dev, sizeof(*pdata), GFP_KERNEL);\r\nif (pdata == NULL) {\r\nreturn -ENOMEM;\r\n}\r\npdata->pdev_strm_map = dpcm_strm_map;\r\npdata->strm_map_size = ARRAY_SIZE(dpcm_strm_map);\r\ndrv->pdata = pdata;\r\ndrv->pdev = pdev;\r\nmutex_init(&drv->lock);\r\ndev_set_drvdata(&pdev->dev, drv);\r\nret = snd_soc_register_platform(&pdev->dev, &sst_soc_platform_drv);\r\nif (ret) {\r\ndev_err(&pdev->dev, "registering soc platform failed\n");\r\nreturn ret;\r\n}\r\nret = snd_soc_register_component(&pdev->dev, &sst_component,\r\nsst_platform_dai, ARRAY_SIZE(sst_platform_dai));\r\nif (ret) {\r\ndev_err(&pdev->dev, "registering cpu dais failed\n");\r\nsnd_soc_unregister_platform(&pdev->dev);\r\n}\r\nreturn ret;\r\n}\r\nstatic int sst_platform_remove(struct platform_device *pdev)\r\n{\r\nsnd_soc_unregister_component(&pdev->dev);\r\nsnd_soc_unregister_platform(&pdev->dev);\r\ndev_dbg(&pdev->dev, "sst_platform_remove success\n");\r\nreturn 0;\r\n}\r\nstatic int sst_soc_prepare(struct device *dev)\r\n{\r\nstruct sst_data *drv = dev_get_drvdata(dev);\r\nstruct snd_soc_pcm_runtime *rtd;\r\nsnd_soc_suspend(drv->soc_card->dev);\r\nsnd_soc_poweroff(drv->soc_card->dev);\r\nlist_for_each_entry(rtd, &drv->soc_card->rtd_list, list) {\r\nstruct snd_soc_dai *dai = rtd->cpu_dai;\r\nif (dai->active) {\r\nsend_ssp_cmd(dai, dai->name, 0);\r\nsst_handle_vb_timer(dai, false);\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic void sst_soc_complete(struct device *dev)\r\n{\r\nstruct sst_data *drv = dev_get_drvdata(dev);\r\nstruct snd_soc_pcm_runtime *rtd;\r\nlist_for_each_entry(rtd, &drv->soc_card->rtd_list, list) {\r\nstruct snd_soc_dai *dai = rtd->cpu_dai;\r\nif (dai->active) {\r\nsst_handle_vb_timer(dai, true);\r\nsend_ssp_cmd(dai, dai->name, 1);\r\n}\r\n}\r\nsnd_soc_resume(drv->soc_card->dev);\r\n}
