static int usb_8dev_send_cmd_msg(struct usb_8dev_priv *priv, u8 *msg, int size)\r\n{\r\nint actual_length;\r\nreturn usb_bulk_msg(priv->udev,\r\nusb_sndbulkpipe(priv->udev, USB_8DEV_ENDP_CMD_TX),\r\nmsg, size, &actual_length, USB_8DEV_CMD_TIMEOUT);\r\n}\r\nstatic int usb_8dev_wait_cmd_msg(struct usb_8dev_priv *priv, u8 *msg, int size,\r\nint *actual_length)\r\n{\r\nreturn usb_bulk_msg(priv->udev,\r\nusb_rcvbulkpipe(priv->udev, USB_8DEV_ENDP_CMD_RX),\r\nmsg, size, actual_length, USB_8DEV_CMD_TIMEOUT);\r\n}\r\nstatic int usb_8dev_send_cmd(struct usb_8dev_priv *priv,\r\nstruct usb_8dev_cmd_msg *out,\r\nstruct usb_8dev_cmd_msg *in)\r\n{\r\nint err;\r\nint num_bytes_read;\r\nstruct net_device *netdev;\r\nnetdev = priv->netdev;\r\nout->begin = USB_8DEV_CMD_START;\r\nout->end = USB_8DEV_CMD_END;\r\nmutex_lock(&priv->usb_8dev_cmd_lock);\r\nmemcpy(priv->cmd_msg_buffer, out,\r\nsizeof(struct usb_8dev_cmd_msg));\r\nerr = usb_8dev_send_cmd_msg(priv, priv->cmd_msg_buffer,\r\nsizeof(struct usb_8dev_cmd_msg));\r\nif (err < 0) {\r\nnetdev_err(netdev, "sending command message failed\n");\r\ngoto failed;\r\n}\r\nerr = usb_8dev_wait_cmd_msg(priv, priv->cmd_msg_buffer,\r\nsizeof(struct usb_8dev_cmd_msg),\r\n&num_bytes_read);\r\nif (err < 0) {\r\nnetdev_err(netdev, "no command message answer\n");\r\ngoto failed;\r\n}\r\nmemcpy(in, priv->cmd_msg_buffer, sizeof(struct usb_8dev_cmd_msg));\r\nif (in->begin != USB_8DEV_CMD_START || in->end != USB_8DEV_CMD_END ||\r\nnum_bytes_read != 16 || in->opt1 != 0)\r\nerr = -EPROTO;\r\nfailed:\r\nmutex_unlock(&priv->usb_8dev_cmd_lock);\r\nreturn err;\r\n}\r\nstatic int usb_8dev_cmd_open(struct usb_8dev_priv *priv)\r\n{\r\nstruct can_bittiming *bt = &priv->can.bittiming;\r\nstruct usb_8dev_cmd_msg outmsg;\r\nstruct usb_8dev_cmd_msg inmsg;\r\nu32 ctrlmode = priv->can.ctrlmode;\r\nu32 flags = USB_8DEV_STATUS_FRAME;\r\n__be32 beflags;\r\n__be16 bebrp;\r\nmemset(&outmsg, 0, sizeof(outmsg));\r\noutmsg.command = USB_8DEV_OPEN;\r\noutmsg.opt1 = USB_8DEV_BAUD_MANUAL;\r\noutmsg.data[0] = bt->prop_seg + bt->phase_seg1;\r\noutmsg.data[1] = bt->phase_seg2;\r\noutmsg.data[2] = bt->sjw;\r\nbebrp = cpu_to_be16((u16)bt->brp);\r\nmemcpy(&outmsg.data[3], &bebrp, sizeof(bebrp));\r\nif (ctrlmode & CAN_CTRLMODE_LOOPBACK)\r\nflags |= USB_8DEV_LOOPBACK;\r\nif (ctrlmode & CAN_CTRLMODE_LISTENONLY)\r\nflags |= USB_8DEV_SILENT;\r\nif (ctrlmode & CAN_CTRLMODE_ONE_SHOT)\r\nflags |= USB_8DEV_DISABLE_AUTO_RESTRANS;\r\nbeflags = cpu_to_be32(flags);\r\nmemcpy(&outmsg.data[5], &beflags, sizeof(beflags));\r\nreturn usb_8dev_send_cmd(priv, &outmsg, &inmsg);\r\n}\r\nstatic int usb_8dev_cmd_close(struct usb_8dev_priv *priv)\r\n{\r\nstruct usb_8dev_cmd_msg inmsg;\r\nstruct usb_8dev_cmd_msg outmsg = {\r\n.channel = 0,\r\n.command = USB_8DEV_CLOSE,\r\n.opt1 = 0,\r\n.opt2 = 0\r\n};\r\nreturn usb_8dev_send_cmd(priv, &outmsg, &inmsg);\r\n}\r\nstatic int usb_8dev_cmd_version(struct usb_8dev_priv *priv, u32 *res)\r\n{\r\nstruct usb_8dev_cmd_msg inmsg;\r\nstruct usb_8dev_cmd_msg outmsg = {\r\n.channel = 0,\r\n.command = USB_8DEV_GET_SOFTW_HARDW_VER,\r\n.opt1 = 0,\r\n.opt2 = 0\r\n};\r\nint err = usb_8dev_send_cmd(priv, &outmsg, &inmsg);\r\nif (err)\r\nreturn err;\r\n*res = be32_to_cpup((__be32 *)inmsg.data);\r\nreturn err;\r\n}\r\nstatic int usb_8dev_set_mode(struct net_device *netdev, enum can_mode mode)\r\n{\r\nstruct usb_8dev_priv *priv = netdev_priv(netdev);\r\nint err = 0;\r\nswitch (mode) {\r\ncase CAN_MODE_START:\r\nerr = usb_8dev_cmd_open(priv);\r\nif (err)\r\nnetdev_warn(netdev, "couldn't start device");\r\nbreak;\r\ndefault:\r\nreturn -EOPNOTSUPP;\r\n}\r\nreturn err;\r\n}\r\nstatic void usb_8dev_rx_err_msg(struct usb_8dev_priv *priv,\r\nstruct usb_8dev_rx_msg *msg)\r\n{\r\nstruct can_frame *cf;\r\nstruct sk_buff *skb;\r\nstruct net_device_stats *stats = &priv->netdev->stats;\r\nu8 state = msg->data[0];\r\nu8 rxerr = msg->data[1] & USB_8DEV_RP_MASK;\r\nu8 txerr = msg->data[2];\r\nint rx_errors = 0;\r\nint tx_errors = 0;\r\nskb = alloc_can_err_skb(priv->netdev, &cf);\r\nif (!skb)\r\nreturn;\r\nswitch (state) {\r\ncase USB_8DEV_STATUSMSG_OK:\r\npriv->can.state = CAN_STATE_ERROR_ACTIVE;\r\ncf->can_id |= CAN_ERR_PROT;\r\ncf->data[2] = CAN_ERR_PROT_ACTIVE;\r\nbreak;\r\ncase USB_8DEV_STATUSMSG_BUSOFF:\r\npriv->can.state = CAN_STATE_BUS_OFF;\r\ncf->can_id |= CAN_ERR_BUSOFF;\r\npriv->can.can_stats.bus_off++;\r\ncan_bus_off(priv->netdev);\r\nbreak;\r\ncase USB_8DEV_STATUSMSG_OVERRUN:\r\ncase USB_8DEV_STATUSMSG_BUSLIGHT:\r\ncase USB_8DEV_STATUSMSG_BUSHEAVY:\r\ncf->can_id |= CAN_ERR_CRTL;\r\nbreak;\r\ndefault:\r\npriv->can.state = CAN_STATE_ERROR_WARNING;\r\ncf->can_id |= CAN_ERR_PROT | CAN_ERR_BUSERROR;\r\npriv->can.can_stats.bus_error++;\r\nbreak;\r\n}\r\nswitch (state) {\r\ncase USB_8DEV_STATUSMSG_OK:\r\ncase USB_8DEV_STATUSMSG_BUSOFF:\r\nbreak;\r\ncase USB_8DEV_STATUSMSG_ACK:\r\ncf->can_id |= CAN_ERR_ACK;\r\ntx_errors = 1;\r\nbreak;\r\ncase USB_8DEV_STATUSMSG_CRC:\r\ncf->data[3] = CAN_ERR_PROT_LOC_CRC_SEQ;\r\nrx_errors = 1;\r\nbreak;\r\ncase USB_8DEV_STATUSMSG_BIT0:\r\ncf->data[2] |= CAN_ERR_PROT_BIT0;\r\ntx_errors = 1;\r\nbreak;\r\ncase USB_8DEV_STATUSMSG_BIT1:\r\ncf->data[2] |= CAN_ERR_PROT_BIT1;\r\ntx_errors = 1;\r\nbreak;\r\ncase USB_8DEV_STATUSMSG_FORM:\r\ncf->data[2] |= CAN_ERR_PROT_FORM;\r\nrx_errors = 1;\r\nbreak;\r\ncase USB_8DEV_STATUSMSG_STUFF:\r\ncf->data[2] |= CAN_ERR_PROT_STUFF;\r\nrx_errors = 1;\r\nbreak;\r\ncase USB_8DEV_STATUSMSG_OVERRUN:\r\ncf->data[1] = CAN_ERR_CRTL_RX_OVERFLOW;\r\nstats->rx_over_errors++;\r\nrx_errors = 1;\r\nbreak;\r\ncase USB_8DEV_STATUSMSG_BUSLIGHT:\r\npriv->can.state = CAN_STATE_ERROR_WARNING;\r\ncf->data[1] = (txerr > rxerr) ?\r\nCAN_ERR_CRTL_TX_WARNING :\r\nCAN_ERR_CRTL_RX_WARNING;\r\npriv->can.can_stats.error_warning++;\r\nbreak;\r\ncase USB_8DEV_STATUSMSG_BUSHEAVY:\r\npriv->can.state = CAN_STATE_ERROR_PASSIVE;\r\ncf->data[1] = (txerr > rxerr) ?\r\nCAN_ERR_CRTL_TX_PASSIVE :\r\nCAN_ERR_CRTL_RX_PASSIVE;\r\npriv->can.can_stats.error_passive++;\r\nbreak;\r\ndefault:\r\nnetdev_warn(priv->netdev,\r\n"Unknown status/error message (%d)\n", state);\r\nbreak;\r\n}\r\nif (tx_errors) {\r\ncf->data[2] |= CAN_ERR_PROT_TX;\r\nstats->tx_errors++;\r\n}\r\nif (rx_errors)\r\nstats->rx_errors++;\r\ncf->data[6] = txerr;\r\ncf->data[7] = rxerr;\r\npriv->bec.txerr = txerr;\r\npriv->bec.rxerr = rxerr;\r\nstats->rx_packets++;\r\nstats->rx_bytes += cf->can_dlc;\r\nnetif_rx(skb);\r\n}\r\nstatic void usb_8dev_rx_can_msg(struct usb_8dev_priv *priv,\r\nstruct usb_8dev_rx_msg *msg)\r\n{\r\nstruct can_frame *cf;\r\nstruct sk_buff *skb;\r\nstruct net_device_stats *stats = &priv->netdev->stats;\r\nif (msg->type == USB_8DEV_TYPE_ERROR_FRAME &&\r\nmsg->flags == USB_8DEV_ERR_FLAG) {\r\nusb_8dev_rx_err_msg(priv, msg);\r\n} else if (msg->type == USB_8DEV_TYPE_CAN_FRAME) {\r\nskb = alloc_can_skb(priv->netdev, &cf);\r\nif (!skb)\r\nreturn;\r\ncf->can_id = be32_to_cpu(msg->id);\r\ncf->can_dlc = get_can_dlc(msg->dlc & 0xF);\r\nif (msg->flags & USB_8DEV_EXTID)\r\ncf->can_id |= CAN_EFF_FLAG;\r\nif (msg->flags & USB_8DEV_RTR)\r\ncf->can_id |= CAN_RTR_FLAG;\r\nelse\r\nmemcpy(cf->data, msg->data, cf->can_dlc);\r\nstats->rx_packets++;\r\nstats->rx_bytes += cf->can_dlc;\r\nnetif_rx(skb);\r\ncan_led_event(priv->netdev, CAN_LED_EVENT_RX);\r\n} else {\r\nnetdev_warn(priv->netdev, "frame type %d unknown",\r\nmsg->type);\r\n}\r\n}\r\nstatic void usb_8dev_read_bulk_callback(struct urb *urb)\r\n{\r\nstruct usb_8dev_priv *priv = urb->context;\r\nstruct net_device *netdev;\r\nint retval;\r\nint pos = 0;\r\nnetdev = priv->netdev;\r\nif (!netif_device_present(netdev))\r\nreturn;\r\nswitch (urb->status) {\r\ncase 0:\r\nbreak;\r\ncase -ENOENT:\r\ncase -ESHUTDOWN:\r\nreturn;\r\ndefault:\r\nnetdev_info(netdev, "Rx URB aborted (%d)\n",\r\nurb->status);\r\ngoto resubmit_urb;\r\n}\r\nwhile (pos < urb->actual_length) {\r\nstruct usb_8dev_rx_msg *msg;\r\nif (pos + sizeof(struct usb_8dev_rx_msg) > urb->actual_length) {\r\nnetdev_err(priv->netdev, "format error\n");\r\nbreak;\r\n}\r\nmsg = (struct usb_8dev_rx_msg *)(urb->transfer_buffer + pos);\r\nusb_8dev_rx_can_msg(priv, msg);\r\npos += sizeof(struct usb_8dev_rx_msg);\r\n}\r\nresubmit_urb:\r\nusb_fill_bulk_urb(urb, priv->udev,\r\nusb_rcvbulkpipe(priv->udev, USB_8DEV_ENDP_DATA_RX),\r\nurb->transfer_buffer, RX_BUFFER_SIZE,\r\nusb_8dev_read_bulk_callback, priv);\r\nretval = usb_submit_urb(urb, GFP_ATOMIC);\r\nif (retval == -ENODEV)\r\nnetif_device_detach(netdev);\r\nelse if (retval)\r\nnetdev_err(netdev,\r\n"failed resubmitting read bulk urb: %d\n", retval);\r\n}\r\nstatic void usb_8dev_write_bulk_callback(struct urb *urb)\r\n{\r\nstruct usb_8dev_tx_urb_context *context = urb->context;\r\nstruct usb_8dev_priv *priv;\r\nstruct net_device *netdev;\r\nBUG_ON(!context);\r\npriv = context->priv;\r\nnetdev = priv->netdev;\r\nusb_free_coherent(urb->dev, urb->transfer_buffer_length,\r\nurb->transfer_buffer, urb->transfer_dma);\r\natomic_dec(&priv->active_tx_urbs);\r\nif (!netif_device_present(netdev))\r\nreturn;\r\nif (urb->status)\r\nnetdev_info(netdev, "Tx URB aborted (%d)\n",\r\nurb->status);\r\nnetdev->stats.tx_packets++;\r\nnetdev->stats.tx_bytes += context->dlc;\r\ncan_get_echo_skb(netdev, context->echo_index);\r\ncan_led_event(netdev, CAN_LED_EVENT_TX);\r\ncontext->echo_index = MAX_TX_URBS;\r\nnetif_wake_queue(netdev);\r\n}\r\nstatic netdev_tx_t usb_8dev_start_xmit(struct sk_buff *skb,\r\nstruct net_device *netdev)\r\n{\r\nstruct usb_8dev_priv *priv = netdev_priv(netdev);\r\nstruct net_device_stats *stats = &netdev->stats;\r\nstruct can_frame *cf = (struct can_frame *) skb->data;\r\nstruct usb_8dev_tx_msg *msg;\r\nstruct urb *urb;\r\nstruct usb_8dev_tx_urb_context *context = NULL;\r\nu8 *buf;\r\nint i, err;\r\nsize_t size = sizeof(struct usb_8dev_tx_msg);\r\nif (can_dropped_invalid_skb(netdev, skb))\r\nreturn NETDEV_TX_OK;\r\nurb = usb_alloc_urb(0, GFP_ATOMIC);\r\nif (!urb) {\r\nnetdev_err(netdev, "No memory left for URBs\n");\r\ngoto nomem;\r\n}\r\nbuf = usb_alloc_coherent(priv->udev, size, GFP_ATOMIC,\r\n&urb->transfer_dma);\r\nif (!buf) {\r\nnetdev_err(netdev, "No memory left for USB buffer\n");\r\ngoto nomembuf;\r\n}\r\nmemset(buf, 0, size);\r\nmsg = (struct usb_8dev_tx_msg *)buf;\r\nmsg->begin = USB_8DEV_DATA_START;\r\nmsg->flags = 0x00;\r\nif (cf->can_id & CAN_RTR_FLAG)\r\nmsg->flags |= USB_8DEV_RTR;\r\nif (cf->can_id & CAN_EFF_FLAG)\r\nmsg->flags |= USB_8DEV_EXTID;\r\nmsg->id = cpu_to_be32(cf->can_id & CAN_ERR_MASK);\r\nmsg->dlc = cf->can_dlc;\r\nmemcpy(msg->data, cf->data, cf->can_dlc);\r\nmsg->end = USB_8DEV_DATA_END;\r\nfor (i = 0; i < MAX_TX_URBS; i++) {\r\nif (priv->tx_contexts[i].echo_index == MAX_TX_URBS) {\r\ncontext = &priv->tx_contexts[i];\r\nbreak;\r\n}\r\n}\r\nif (!context)\r\ngoto nofreecontext;\r\ncontext->priv = priv;\r\ncontext->echo_index = i;\r\ncontext->dlc = cf->can_dlc;\r\nusb_fill_bulk_urb(urb, priv->udev,\r\nusb_sndbulkpipe(priv->udev, USB_8DEV_ENDP_DATA_TX),\r\nbuf, size, usb_8dev_write_bulk_callback, context);\r\nurb->transfer_flags |= URB_NO_TRANSFER_DMA_MAP;\r\nusb_anchor_urb(urb, &priv->tx_submitted);\r\ncan_put_echo_skb(skb, netdev, context->echo_index);\r\natomic_inc(&priv->active_tx_urbs);\r\nerr = usb_submit_urb(urb, GFP_ATOMIC);\r\nif (unlikely(err))\r\ngoto failed;\r\nelse if (atomic_read(&priv->active_tx_urbs) >= MAX_TX_URBS)\r\nnetif_stop_queue(netdev);\r\nusb_free_urb(urb);\r\nreturn NETDEV_TX_OK;\r\nnofreecontext:\r\nusb_free_coherent(priv->udev, size, buf, urb->transfer_dma);\r\nusb_free_urb(urb);\r\nnetdev_warn(netdev, "couldn't find free context");\r\nreturn NETDEV_TX_BUSY;\r\nfailed:\r\ncan_free_echo_skb(netdev, context->echo_index);\r\nusb_unanchor_urb(urb);\r\nusb_free_coherent(priv->udev, size, buf, urb->transfer_dma);\r\natomic_dec(&priv->active_tx_urbs);\r\nif (err == -ENODEV)\r\nnetif_device_detach(netdev);\r\nelse\r\nnetdev_warn(netdev, "failed tx_urb %d\n", err);\r\nnomembuf:\r\nusb_free_urb(urb);\r\nnomem:\r\ndev_kfree_skb(skb);\r\nstats->tx_dropped++;\r\nreturn NETDEV_TX_OK;\r\n}\r\nstatic int usb_8dev_get_berr_counter(const struct net_device *netdev,\r\nstruct can_berr_counter *bec)\r\n{\r\nstruct usb_8dev_priv *priv = netdev_priv(netdev);\r\nbec->txerr = priv->bec.txerr;\r\nbec->rxerr = priv->bec.rxerr;\r\nreturn 0;\r\n}\r\nstatic int usb_8dev_start(struct usb_8dev_priv *priv)\r\n{\r\nstruct net_device *netdev = priv->netdev;\r\nint err, i;\r\nfor (i = 0; i < MAX_RX_URBS; i++) {\r\nstruct urb *urb = NULL;\r\nu8 *buf;\r\nurb = usb_alloc_urb(0, GFP_KERNEL);\r\nif (!urb) {\r\nnetdev_err(netdev, "No memory left for URBs\n");\r\nerr = -ENOMEM;\r\nbreak;\r\n}\r\nbuf = usb_alloc_coherent(priv->udev, RX_BUFFER_SIZE, GFP_KERNEL,\r\n&urb->transfer_dma);\r\nif (!buf) {\r\nnetdev_err(netdev, "No memory left for USB buffer\n");\r\nusb_free_urb(urb);\r\nerr = -ENOMEM;\r\nbreak;\r\n}\r\nusb_fill_bulk_urb(urb, priv->udev,\r\nusb_rcvbulkpipe(priv->udev,\r\nUSB_8DEV_ENDP_DATA_RX),\r\nbuf, RX_BUFFER_SIZE,\r\nusb_8dev_read_bulk_callback, priv);\r\nurb->transfer_flags |= URB_NO_TRANSFER_DMA_MAP;\r\nusb_anchor_urb(urb, &priv->rx_submitted);\r\nerr = usb_submit_urb(urb, GFP_KERNEL);\r\nif (err) {\r\nusb_unanchor_urb(urb);\r\nusb_free_coherent(priv->udev, RX_BUFFER_SIZE, buf,\r\nurb->transfer_dma);\r\nusb_free_urb(urb);\r\nbreak;\r\n}\r\nusb_free_urb(urb);\r\n}\r\nif (i == 0) {\r\nnetdev_warn(netdev, "couldn't setup read URBs\n");\r\nreturn err;\r\n}\r\nif (i < MAX_RX_URBS)\r\nnetdev_warn(netdev, "rx performance may be slow\n");\r\nerr = usb_8dev_cmd_open(priv);\r\nif (err)\r\ngoto failed;\r\npriv->can.state = CAN_STATE_ERROR_ACTIVE;\r\nreturn 0;\r\nfailed:\r\nif (err == -ENODEV)\r\nnetif_device_detach(priv->netdev);\r\nnetdev_warn(netdev, "couldn't submit control: %d\n", err);\r\nreturn err;\r\n}\r\nstatic int usb_8dev_open(struct net_device *netdev)\r\n{\r\nstruct usb_8dev_priv *priv = netdev_priv(netdev);\r\nint err;\r\nerr = open_candev(netdev);\r\nif (err)\r\nreturn err;\r\ncan_led_event(netdev, CAN_LED_EVENT_OPEN);\r\nerr = usb_8dev_start(priv);\r\nif (err) {\r\nif (err == -ENODEV)\r\nnetif_device_detach(priv->netdev);\r\nnetdev_warn(netdev, "couldn't start device: %d\n",\r\nerr);\r\nclose_candev(netdev);\r\nreturn err;\r\n}\r\nnetif_start_queue(netdev);\r\nreturn 0;\r\n}\r\nstatic void unlink_all_urbs(struct usb_8dev_priv *priv)\r\n{\r\nint i;\r\nusb_kill_anchored_urbs(&priv->rx_submitted);\r\nusb_kill_anchored_urbs(&priv->tx_submitted);\r\natomic_set(&priv->active_tx_urbs, 0);\r\nfor (i = 0; i < MAX_TX_URBS; i++)\r\npriv->tx_contexts[i].echo_index = MAX_TX_URBS;\r\n}\r\nstatic int usb_8dev_close(struct net_device *netdev)\r\n{\r\nstruct usb_8dev_priv *priv = netdev_priv(netdev);\r\nint err = 0;\r\nerr = usb_8dev_cmd_close(priv);\r\nif (err)\r\nnetdev_warn(netdev, "couldn't stop device");\r\npriv->can.state = CAN_STATE_STOPPED;\r\nnetif_stop_queue(netdev);\r\nunlink_all_urbs(priv);\r\nclose_candev(netdev);\r\ncan_led_event(netdev, CAN_LED_EVENT_STOP);\r\nreturn err;\r\n}\r\nstatic int usb_8dev_probe(struct usb_interface *intf,\r\nconst struct usb_device_id *id)\r\n{\r\nstruct net_device *netdev;\r\nstruct usb_8dev_priv *priv;\r\nint i, err = -ENOMEM;\r\nu32 version;\r\nchar buf[18];\r\nstruct usb_device *usbdev = interface_to_usbdev(intf);\r\nif (usb_string(usbdev, usbdev->descriptor.iProduct, buf,\r\nsizeof(buf)) > 0 && strcmp(buf, "USB2CAN converter")) {\r\ndev_info(&usbdev->dev, "ignoring: not an USB2CAN converter\n");\r\nreturn -ENODEV;\r\n}\r\nnetdev = alloc_candev(sizeof(struct usb_8dev_priv), MAX_TX_URBS);\r\nif (!netdev) {\r\ndev_err(&intf->dev, "Couldn't alloc candev\n");\r\nreturn -ENOMEM;\r\n}\r\npriv = netdev_priv(netdev);\r\npriv->udev = usbdev;\r\npriv->netdev = netdev;\r\npriv->can.state = CAN_STATE_STOPPED;\r\npriv->can.clock.freq = USB_8DEV_ABP_CLOCK;\r\npriv->can.bittiming_const = &usb_8dev_bittiming_const;\r\npriv->can.do_set_mode = usb_8dev_set_mode;\r\npriv->can.do_get_berr_counter = usb_8dev_get_berr_counter;\r\npriv->can.ctrlmode_supported = CAN_CTRLMODE_LOOPBACK |\r\nCAN_CTRLMODE_LISTENONLY |\r\nCAN_CTRLMODE_ONE_SHOT;\r\nnetdev->netdev_ops = &usb_8dev_netdev_ops;\r\nnetdev->flags |= IFF_ECHO;\r\ninit_usb_anchor(&priv->rx_submitted);\r\ninit_usb_anchor(&priv->tx_submitted);\r\natomic_set(&priv->active_tx_urbs, 0);\r\nfor (i = 0; i < MAX_TX_URBS; i++)\r\npriv->tx_contexts[i].echo_index = MAX_TX_URBS;\r\npriv->cmd_msg_buffer = kzalloc(sizeof(struct usb_8dev_cmd_msg),\r\nGFP_KERNEL);\r\nif (!priv->cmd_msg_buffer)\r\ngoto cleanup_candev;\r\nusb_set_intfdata(intf, priv);\r\nSET_NETDEV_DEV(netdev, &intf->dev);\r\nmutex_init(&priv->usb_8dev_cmd_lock);\r\nerr = register_candev(netdev);\r\nif (err) {\r\nnetdev_err(netdev,\r\n"couldn't register CAN device: %d\n", err);\r\ngoto cleanup_cmd_msg_buffer;\r\n}\r\nerr = usb_8dev_cmd_version(priv, &version);\r\nif (err) {\r\nnetdev_err(netdev, "can't get firmware version\n");\r\ngoto cleanup_unregister_candev;\r\n} else {\r\nnetdev_info(netdev,\r\n"firmware: %d.%d, hardware: %d.%d\n",\r\n(version>>24) & 0xff, (version>>16) & 0xff,\r\n(version>>8) & 0xff, version & 0xff);\r\n}\r\ndevm_can_led_init(netdev);\r\nreturn 0;\r\ncleanup_unregister_candev:\r\nunregister_netdev(priv->netdev);\r\ncleanup_cmd_msg_buffer:\r\nkfree(priv->cmd_msg_buffer);\r\ncleanup_candev:\r\nfree_candev(netdev);\r\nreturn err;\r\n}\r\nstatic void usb_8dev_disconnect(struct usb_interface *intf)\r\n{\r\nstruct usb_8dev_priv *priv = usb_get_intfdata(intf);\r\nusb_set_intfdata(intf, NULL);\r\nif (priv) {\r\nnetdev_info(priv->netdev, "device disconnected\n");\r\nunregister_netdev(priv->netdev);\r\nfree_candev(priv->netdev);\r\nunlink_all_urbs(priv);\r\n}\r\n}
