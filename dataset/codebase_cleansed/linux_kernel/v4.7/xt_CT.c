static inline int xt_ct_target(struct sk_buff *skb, struct nf_conn *ct)\r\n{\r\nif (skb->nfct != NULL)\r\nreturn XT_CONTINUE;\r\nif (!ct)\r\nct = nf_ct_untracked_get();\r\natomic_inc(&ct->ct_general.use);\r\nskb->nfct = &ct->ct_general;\r\nskb->nfctinfo = IP_CT_NEW;\r\nreturn XT_CONTINUE;\r\n}\r\nstatic unsigned int xt_ct_target_v0(struct sk_buff *skb,\r\nconst struct xt_action_param *par)\r\n{\r\nconst struct xt_ct_target_info *info = par->targinfo;\r\nstruct nf_conn *ct = info->ct;\r\nreturn xt_ct_target(skb, ct);\r\n}\r\nstatic unsigned int xt_ct_target_v1(struct sk_buff *skb,\r\nconst struct xt_action_param *par)\r\n{\r\nconst struct xt_ct_target_info_v1 *info = par->targinfo;\r\nstruct nf_conn *ct = info->ct;\r\nreturn xt_ct_target(skb, ct);\r\n}\r\nstatic u8 xt_ct_find_proto(const struct xt_tgchk_param *par)\r\n{\r\nif (par->family == NFPROTO_IPV4) {\r\nconst struct ipt_entry *e = par->entryinfo;\r\nif (e->ip.invflags & IPT_INV_PROTO)\r\nreturn 0;\r\nreturn e->ip.proto;\r\n} else if (par->family == NFPROTO_IPV6) {\r\nconst struct ip6t_entry *e = par->entryinfo;\r\nif (e->ipv6.invflags & IP6T_INV_PROTO)\r\nreturn 0;\r\nreturn e->ipv6.proto;\r\n} else\r\nreturn 0;\r\n}\r\nstatic int\r\nxt_ct_set_helper(struct nf_conn *ct, const char *helper_name,\r\nconst struct xt_tgchk_param *par)\r\n{\r\nstruct nf_conntrack_helper *helper;\r\nstruct nf_conn_help *help;\r\nu8 proto;\r\nproto = xt_ct_find_proto(par);\r\nif (!proto) {\r\npr_info("You must specify a L4 protocol, and not use "\r\n"inversions on it.\n");\r\nreturn -ENOENT;\r\n}\r\nhelper = nf_conntrack_helper_try_module_get(helper_name, par->family,\r\nproto);\r\nif (helper == NULL) {\r\npr_info("No such helper \"%s\"\n", helper_name);\r\nreturn -ENOENT;\r\n}\r\nhelp = nf_ct_helper_ext_add(ct, helper, GFP_KERNEL);\r\nif (help == NULL) {\r\nmodule_put(helper->me);\r\nreturn -ENOMEM;\r\n}\r\nhelp->helper = helper;\r\nreturn 0;\r\n}\r\nstatic void __xt_ct_tg_timeout_put(struct ctnl_timeout *timeout)\r\n{\r\ntypeof(nf_ct_timeout_put_hook) timeout_put;\r\ntimeout_put = rcu_dereference(nf_ct_timeout_put_hook);\r\nif (timeout_put)\r\ntimeout_put(timeout);\r\n}\r\nstatic int\r\nxt_ct_set_timeout(struct nf_conn *ct, const struct xt_tgchk_param *par,\r\nconst char *timeout_name)\r\n{\r\n#ifdef CONFIG_NF_CONNTRACK_TIMEOUT\r\ntypeof(nf_ct_timeout_find_get_hook) timeout_find_get;\r\nstruct ctnl_timeout *timeout;\r\nstruct nf_conn_timeout *timeout_ext;\r\nstruct nf_conntrack_l4proto *l4proto;\r\nint ret = 0;\r\nu8 proto;\r\nrcu_read_lock();\r\ntimeout_find_get = rcu_dereference(nf_ct_timeout_find_get_hook);\r\nif (timeout_find_get == NULL) {\r\nret = -ENOENT;\r\npr_info("Timeout policy base is empty\n");\r\ngoto out;\r\n}\r\nproto = xt_ct_find_proto(par);\r\nif (!proto) {\r\nret = -EINVAL;\r\npr_info("You must specify a L4 protocol, and not use "\r\n"inversions on it.\n");\r\ngoto out;\r\n}\r\ntimeout = timeout_find_get(par->net, timeout_name);\r\nif (timeout == NULL) {\r\nret = -ENOENT;\r\npr_info("No such timeout policy \"%s\"\n", timeout_name);\r\ngoto out;\r\n}\r\nif (timeout->l3num != par->family) {\r\nret = -EINVAL;\r\npr_info("Timeout policy `%s' can only be used by L3 protocol "\r\n"number %d\n", timeout_name, timeout->l3num);\r\ngoto err_put_timeout;\r\n}\r\nl4proto = __nf_ct_l4proto_find(par->family, proto);\r\nif (timeout->l4proto->l4proto != l4proto->l4proto) {\r\nret = -EINVAL;\r\npr_info("Timeout policy `%s' can only be used by L4 protocol "\r\n"number %d\n",\r\ntimeout_name, timeout->l4proto->l4proto);\r\ngoto err_put_timeout;\r\n}\r\ntimeout_ext = nf_ct_timeout_ext_add(ct, timeout, GFP_ATOMIC);\r\nif (timeout_ext == NULL)\r\nret = -ENOMEM;\r\nrcu_read_unlock();\r\nreturn ret;\r\nerr_put_timeout:\r\n__xt_ct_tg_timeout_put(timeout);\r\nout:\r\nrcu_read_unlock();\r\nreturn ret;\r\n#else\r\nreturn -EOPNOTSUPP;\r\n#endif\r\n}\r\nstatic u16 xt_ct_flags_to_dir(const struct xt_ct_target_info_v1 *info)\r\n{\r\nswitch (info->flags & (XT_CT_ZONE_DIR_ORIG |\r\nXT_CT_ZONE_DIR_REPL)) {\r\ncase XT_CT_ZONE_DIR_ORIG:\r\nreturn NF_CT_ZONE_DIR_ORIG;\r\ncase XT_CT_ZONE_DIR_REPL:\r\nreturn NF_CT_ZONE_DIR_REPL;\r\ndefault:\r\nreturn NF_CT_DEFAULT_ZONE_DIR;\r\n}\r\n}\r\nstatic int xt_ct_tg_check(const struct xt_tgchk_param *par,\r\nstruct xt_ct_target_info_v1 *info)\r\n{\r\nstruct nf_conntrack_zone zone;\r\nstruct nf_conn *ct;\r\nint ret = -EOPNOTSUPP;\r\nif (info->flags & XT_CT_NOTRACK) {\r\nct = NULL;\r\ngoto out;\r\n}\r\n#ifndef CONFIG_NF_CONNTRACK_ZONES\r\nif (info->zone || info->flags & (XT_CT_ZONE_DIR_ORIG |\r\nXT_CT_ZONE_DIR_REPL |\r\nXT_CT_ZONE_MARK))\r\ngoto err1;\r\n#endif\r\nret = nf_ct_l3proto_try_module_get(par->family);\r\nif (ret < 0)\r\ngoto err1;\r\nmemset(&zone, 0, sizeof(zone));\r\nzone.id = info->zone;\r\nzone.dir = xt_ct_flags_to_dir(info);\r\nif (info->flags & XT_CT_ZONE_MARK)\r\nzone.flags |= NF_CT_FLAG_MARK;\r\nct = nf_ct_tmpl_alloc(par->net, &zone, GFP_KERNEL);\r\nif (!ct) {\r\nret = -ENOMEM;\r\ngoto err2;\r\n}\r\nret = 0;\r\nif ((info->ct_events || info->exp_events) &&\r\n!nf_ct_ecache_ext_add(ct, info->ct_events, info->exp_events,\r\nGFP_KERNEL)) {\r\nret = -EINVAL;\r\ngoto err3;\r\n}\r\nif (info->helper[0]) {\r\nret = xt_ct_set_helper(ct, info->helper, par);\r\nif (ret < 0)\r\ngoto err3;\r\n}\r\nif (info->timeout[0]) {\r\nret = xt_ct_set_timeout(ct, par, info->timeout);\r\nif (ret < 0)\r\ngoto err3;\r\n}\r\n__set_bit(IPS_CONFIRMED_BIT, &ct->status);\r\nnf_conntrack_get(&ct->ct_general);\r\nout:\r\ninfo->ct = ct;\r\nreturn 0;\r\nerr3:\r\nnf_ct_tmpl_free(ct);\r\nerr2:\r\nnf_ct_l3proto_module_put(par->family);\r\nerr1:\r\nreturn ret;\r\n}\r\nstatic int xt_ct_tg_check_v0(const struct xt_tgchk_param *par)\r\n{\r\nstruct xt_ct_target_info *info = par->targinfo;\r\nstruct xt_ct_target_info_v1 info_v1 = {\r\n.flags = info->flags,\r\n.zone = info->zone,\r\n.ct_events = info->ct_events,\r\n.exp_events = info->exp_events,\r\n};\r\nint ret;\r\nif (info->flags & ~XT_CT_NOTRACK)\r\nreturn -EINVAL;\r\nmemcpy(info_v1.helper, info->helper, sizeof(info->helper));\r\nret = xt_ct_tg_check(par, &info_v1);\r\nif (ret < 0)\r\nreturn ret;\r\ninfo->ct = info_v1.ct;\r\nreturn ret;\r\n}\r\nstatic int xt_ct_tg_check_v1(const struct xt_tgchk_param *par)\r\n{\r\nstruct xt_ct_target_info_v1 *info = par->targinfo;\r\nif (info->flags & ~XT_CT_NOTRACK)\r\nreturn -EINVAL;\r\nreturn xt_ct_tg_check(par, par->targinfo);\r\n}\r\nstatic int xt_ct_tg_check_v2(const struct xt_tgchk_param *par)\r\n{\r\nstruct xt_ct_target_info_v1 *info = par->targinfo;\r\nif (info->flags & ~XT_CT_MASK)\r\nreturn -EINVAL;\r\nreturn xt_ct_tg_check(par, par->targinfo);\r\n}\r\nstatic void xt_ct_destroy_timeout(struct nf_conn *ct)\r\n{\r\n#ifdef CONFIG_NF_CONNTRACK_TIMEOUT\r\nstruct nf_conn_timeout *timeout_ext;\r\ntypeof(nf_ct_timeout_put_hook) timeout_put;\r\nrcu_read_lock();\r\ntimeout_put = rcu_dereference(nf_ct_timeout_put_hook);\r\nif (timeout_put) {\r\ntimeout_ext = nf_ct_timeout_find(ct);\r\nif (timeout_ext) {\r\ntimeout_put(timeout_ext->timeout);\r\nRCU_INIT_POINTER(timeout_ext->timeout, NULL);\r\n}\r\n}\r\nrcu_read_unlock();\r\n#endif\r\n}\r\nstatic void xt_ct_tg_destroy(const struct xt_tgdtor_param *par,\r\nstruct xt_ct_target_info_v1 *info)\r\n{\r\nstruct nf_conn *ct = info->ct;\r\nstruct nf_conn_help *help;\r\nif (ct && !nf_ct_is_untracked(ct)) {\r\nhelp = nfct_help(ct);\r\nif (help)\r\nmodule_put(help->helper->me);\r\nnf_ct_l3proto_module_put(par->family);\r\nxt_ct_destroy_timeout(ct);\r\nnf_ct_put(info->ct);\r\n}\r\n}\r\nstatic void xt_ct_tg_destroy_v0(const struct xt_tgdtor_param *par)\r\n{\r\nstruct xt_ct_target_info *info = par->targinfo;\r\nstruct xt_ct_target_info_v1 info_v1 = {\r\n.flags = info->flags,\r\n.zone = info->zone,\r\n.ct_events = info->ct_events,\r\n.exp_events = info->exp_events,\r\n.ct = info->ct,\r\n};\r\nmemcpy(info_v1.helper, info->helper, sizeof(info->helper));\r\nxt_ct_tg_destroy(par, &info_v1);\r\n}\r\nstatic void xt_ct_tg_destroy_v1(const struct xt_tgdtor_param *par)\r\n{\r\nxt_ct_tg_destroy(par, par->targinfo);\r\n}\r\nstatic unsigned int\r\nnotrack_tg(struct sk_buff *skb, const struct xt_action_param *par)\r\n{\r\nif (skb->nfct != NULL)\r\nreturn XT_CONTINUE;\r\nskb->nfct = &nf_ct_untracked_get()->ct_general;\r\nskb->nfctinfo = IP_CT_NEW;\r\nnf_conntrack_get(skb->nfct);\r\nreturn XT_CONTINUE;\r\n}\r\nstatic int notrack_chk(const struct xt_tgchk_param *par)\r\n{\r\nif (!par->net->xt.notrack_deprecated_warning) {\r\npr_info("netfilter: NOTRACK target is deprecated, "\r\n"use CT instead or upgrade iptables\n");\r\npar->net->xt.notrack_deprecated_warning = true;\r\n}\r\nreturn 0;\r\n}\r\nstatic int __init xt_ct_tg_init(void)\r\n{\r\nint ret;\r\nret = xt_register_target(&notrack_tg_reg);\r\nif (ret < 0)\r\nreturn ret;\r\nret = xt_register_targets(xt_ct_tg_reg, ARRAY_SIZE(xt_ct_tg_reg));\r\nif (ret < 0) {\r\nxt_unregister_target(&notrack_tg_reg);\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic void __exit xt_ct_tg_exit(void)\r\n{\r\nxt_unregister_targets(xt_ct_tg_reg, ARRAY_SIZE(xt_ct_tg_reg));\r\nxt_unregister_target(&notrack_tg_reg);\r\n}
