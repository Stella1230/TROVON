static u32 txx9spi_rd(struct txx9spi *c, int reg)\r\n{\r\nreturn __raw_readl(c->membase + reg);\r\n}\r\nstatic void txx9spi_wr(struct txx9spi *c, u32 val, int reg)\r\n{\r\n__raw_writel(val, c->membase + reg);\r\n}\r\nstatic void txx9spi_cs_func(struct spi_device *spi, struct txx9spi *c,\r\nint on, unsigned int cs_delay)\r\n{\r\nint val = (spi->mode & SPI_CS_HIGH) ? on : !on;\r\nif (on) {\r\nif (c->last_chipselect >= 0)\r\ngpio_set_value(c->last_chipselect,\r\n!c->last_chipselect_val);\r\nc->last_chipselect = spi->chip_select;\r\nc->last_chipselect_val = val;\r\n} else {\r\nc->last_chipselect = -1;\r\nndelay(cs_delay);\r\n}\r\ngpio_set_value(spi->chip_select, val);\r\nndelay(cs_delay);\r\n}\r\nstatic int txx9spi_setup(struct spi_device *spi)\r\n{\r\nstruct txx9spi *c = spi_master_get_devdata(spi->master);\r\nif (!spi->max_speed_hz)\r\nreturn -EINVAL;\r\nif (gpio_direction_output(spi->chip_select,\r\n!(spi->mode & SPI_CS_HIGH))) {\r\ndev_err(&spi->dev, "Cannot setup GPIO for chipselect.\n");\r\nreturn -EINVAL;\r\n}\r\nspin_lock(&c->lock);\r\ntxx9spi_cs_func(spi, c, 0, (NSEC_PER_SEC / 2) / spi->max_speed_hz);\r\nspin_unlock(&c->lock);\r\nreturn 0;\r\n}\r\nstatic irqreturn_t txx9spi_interrupt(int irq, void *dev_id)\r\n{\r\nstruct txx9spi *c = dev_id;\r\ntxx9spi_wr(c, txx9spi_rd(c, TXx9_SPCR0) & ~TXx9_SPCR0_RBSIE,\r\nTXx9_SPCR0);\r\nwake_up(&c->waitq);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void txx9spi_work_one(struct txx9spi *c, struct spi_message *m)\r\n{\r\nstruct spi_device *spi = m->spi;\r\nstruct spi_transfer *t;\r\nunsigned int cs_delay;\r\nunsigned int cs_change = 1;\r\nint status = 0;\r\nu32 mcr;\r\nu32 prev_speed_hz = 0;\r\nu8 prev_bits_per_word = 0;\r\ncs_delay = 100 + (NSEC_PER_SEC / 2) / spi->max_speed_hz;\r\nmcr = txx9spi_rd(c, TXx9_SPMCR);\r\nif (unlikely((mcr & TXx9_SPMCR_OPMODE) == TXx9_SPMCR_ACTIVE)) {\r\ndev_err(&spi->dev, "Bad mode.\n");\r\nstatus = -EIO;\r\ngoto exit;\r\n}\r\nmcr &= ~(TXx9_SPMCR_OPMODE | TXx9_SPMCR_SPSTP | TXx9_SPMCR_BCLR);\r\ntxx9spi_wr(c, mcr | TXx9_SPMCR_CONFIG | TXx9_SPMCR_BCLR, TXx9_SPMCR);\r\ntxx9spi_wr(c, TXx9_SPCR0_SBOS\r\n| ((spi->mode & SPI_CPOL) ? TXx9_SPCR0_SPOL : 0)\r\n| ((spi->mode & SPI_CPHA) ? TXx9_SPCR0_SPHA : 0)\r\n| 0x08,\r\nTXx9_SPCR0);\r\nlist_for_each_entry(t, &m->transfers, transfer_list) {\r\nconst void *txbuf = t->tx_buf;\r\nvoid *rxbuf = t->rx_buf;\r\nu32 data;\r\nunsigned int len = t->len;\r\nunsigned int wsize;\r\nu32 speed_hz = t->speed_hz;\r\nu8 bits_per_word = t->bits_per_word;\r\nwsize = bits_per_word >> 3;\r\nif (prev_speed_hz != speed_hz\r\n|| prev_bits_per_word != bits_per_word) {\r\nint n = DIV_ROUND_UP(c->baseclk, speed_hz) - 1;\r\nn = clamp(n, SPI_MIN_DIVIDER, SPI_MAX_DIVIDER);\r\ntxx9spi_wr(c, mcr | TXx9_SPMCR_CONFIG | TXx9_SPMCR_BCLR,\r\nTXx9_SPMCR);\r\ntxx9spi_wr(c, (n << 8) | bits_per_word, TXx9_SPCR1);\r\ntxx9spi_wr(c, mcr | TXx9_SPMCR_ACTIVE, TXx9_SPMCR);\r\nprev_speed_hz = speed_hz;\r\nprev_bits_per_word = bits_per_word;\r\n}\r\nif (cs_change)\r\ntxx9spi_cs_func(spi, c, 1, cs_delay);\r\ncs_change = t->cs_change;\r\nwhile (len) {\r\nunsigned int count = SPI_FIFO_SIZE;\r\nint i;\r\nu32 cr0;\r\nif (len < count * wsize)\r\ncount = len / wsize;\r\nwhile (!(txx9spi_rd(c, TXx9_SPSR) & TXx9_SPSR_SIDLE))\r\ncpu_relax();\r\ncr0 = txx9spi_rd(c, TXx9_SPCR0);\r\ncr0 &= ~TXx9_SPCR0_RXIFL_MASK;\r\ncr0 |= (count - 1) << 12;\r\ncr0 |= TXx9_SPCR0_RBSIE;\r\ntxx9spi_wr(c, cr0, TXx9_SPCR0);\r\nfor (i = 0; i < count; i++) {\r\nif (txbuf) {\r\ndata = (wsize == 1)\r\n? *(const u8 *)txbuf\r\n: *(const u16 *)txbuf;\r\ntxx9spi_wr(c, data, TXx9_SPDR);\r\ntxbuf += wsize;\r\n} else\r\ntxx9spi_wr(c, 0, TXx9_SPDR);\r\n}\r\nwait_event(c->waitq,\r\ntxx9spi_rd(c, TXx9_SPSR) & TXx9_SPSR_RBSI);\r\nfor (i = 0; i < count; i++) {\r\ndata = txx9spi_rd(c, TXx9_SPDR);\r\nif (rxbuf) {\r\nif (wsize == 1)\r\n*(u8 *)rxbuf = data;\r\nelse\r\n*(u16 *)rxbuf = data;\r\nrxbuf += wsize;\r\n}\r\n}\r\nlen -= count * wsize;\r\n}\r\nm->actual_length += t->len;\r\nif (t->delay_usecs)\r\nudelay(t->delay_usecs);\r\nif (!cs_change)\r\ncontinue;\r\nif (t->transfer_list.next == &m->transfers)\r\nbreak;\r\ntxx9spi_cs_func(spi, c, 0, cs_delay);\r\n}\r\nexit:\r\nm->status = status;\r\nif (m->complete)\r\nm->complete(m->context);\r\nif (!(status == 0 && cs_change))\r\ntxx9spi_cs_func(spi, c, 0, cs_delay);\r\ntxx9spi_wr(c, mcr | TXx9_SPMCR_CONFIG | TXx9_SPMCR_BCLR, TXx9_SPMCR);\r\n}\r\nstatic void txx9spi_work(struct work_struct *work)\r\n{\r\nstruct txx9spi *c = container_of(work, struct txx9spi, work);\r\nunsigned long flags;\r\nspin_lock_irqsave(&c->lock, flags);\r\nwhile (!list_empty(&c->queue)) {\r\nstruct spi_message *m;\r\nm = container_of(c->queue.next, struct spi_message, queue);\r\nlist_del_init(&m->queue);\r\nspin_unlock_irqrestore(&c->lock, flags);\r\ntxx9spi_work_one(c, m);\r\nspin_lock_irqsave(&c->lock, flags);\r\n}\r\nspin_unlock_irqrestore(&c->lock, flags);\r\n}\r\nstatic int txx9spi_transfer(struct spi_device *spi, struct spi_message *m)\r\n{\r\nstruct spi_master *master = spi->master;\r\nstruct txx9spi *c = spi_master_get_devdata(master);\r\nstruct spi_transfer *t;\r\nunsigned long flags;\r\nm->actual_length = 0;\r\nlist_for_each_entry(t, &m->transfers, transfer_list) {\r\nif (!t->tx_buf && !t->rx_buf && t->len)\r\nreturn -EINVAL;\r\n}\r\nspin_lock_irqsave(&c->lock, flags);\r\nlist_add_tail(&m->queue, &c->queue);\r\nqueue_work(c->workqueue, &c->work);\r\nspin_unlock_irqrestore(&c->lock, flags);\r\nreturn 0;\r\n}\r\nstatic int txx9spi_probe(struct platform_device *dev)\r\n{\r\nstruct spi_master *master;\r\nstruct txx9spi *c;\r\nstruct resource *res;\r\nint ret = -ENODEV;\r\nu32 mcr;\r\nint irq;\r\nmaster = spi_alloc_master(&dev->dev, sizeof(*c));\r\nif (!master)\r\nreturn ret;\r\nc = spi_master_get_devdata(master);\r\nplatform_set_drvdata(dev, master);\r\nINIT_WORK(&c->work, txx9spi_work);\r\nspin_lock_init(&c->lock);\r\nINIT_LIST_HEAD(&c->queue);\r\ninit_waitqueue_head(&c->waitq);\r\nc->clk = devm_clk_get(&dev->dev, "spi-baseclk");\r\nif (IS_ERR(c->clk)) {\r\nret = PTR_ERR(c->clk);\r\nc->clk = NULL;\r\ngoto exit;\r\n}\r\nret = clk_enable(c->clk);\r\nif (ret) {\r\nc->clk = NULL;\r\ngoto exit;\r\n}\r\nc->baseclk = clk_get_rate(c->clk);\r\nmaster->min_speed_hz = DIV_ROUND_UP(c->baseclk, SPI_MAX_DIVIDER + 1);\r\nmaster->max_speed_hz = c->baseclk / (SPI_MIN_DIVIDER + 1);\r\nres = platform_get_resource(dev, IORESOURCE_MEM, 0);\r\nc->membase = devm_ioremap_resource(&dev->dev, res);\r\nif (IS_ERR(c->membase))\r\ngoto exit_busy;\r\nmcr = txx9spi_rd(c, TXx9_SPMCR);\r\nmcr &= ~(TXx9_SPMCR_OPMODE | TXx9_SPMCR_SPSTP | TXx9_SPMCR_BCLR);\r\ntxx9spi_wr(c, mcr | TXx9_SPMCR_CONFIG | TXx9_SPMCR_BCLR, TXx9_SPMCR);\r\nirq = platform_get_irq(dev, 0);\r\nif (irq < 0)\r\ngoto exit_busy;\r\nret = devm_request_irq(&dev->dev, irq, txx9spi_interrupt, 0,\r\n"spi_txx9", c);\r\nif (ret)\r\ngoto exit;\r\nc->workqueue = create_singlethread_workqueue(\r\ndev_name(master->dev.parent));\r\nif (!c->workqueue)\r\ngoto exit_busy;\r\nc->last_chipselect = -1;\r\ndev_info(&dev->dev, "at %#llx, irq %d, %dMHz\n",\r\n(unsigned long long)res->start, irq,\r\n(c->baseclk + 500000) / 1000000);\r\nmaster->mode_bits = SPI_CS_HIGH | SPI_CPOL | SPI_CPHA;\r\nmaster->bus_num = dev->id;\r\nmaster->setup = txx9spi_setup;\r\nmaster->transfer = txx9spi_transfer;\r\nmaster->num_chipselect = (u16)UINT_MAX;\r\nmaster->bits_per_word_mask = SPI_BPW_MASK(8) | SPI_BPW_MASK(16);\r\nret = devm_spi_register_master(&dev->dev, master);\r\nif (ret)\r\ngoto exit;\r\nreturn 0;\r\nexit_busy:\r\nret = -EBUSY;\r\nexit:\r\nif (c->workqueue)\r\ndestroy_workqueue(c->workqueue);\r\nclk_disable(c->clk);\r\nspi_master_put(master);\r\nreturn ret;\r\n}\r\nstatic int txx9spi_remove(struct platform_device *dev)\r\n{\r\nstruct spi_master *master = platform_get_drvdata(dev);\r\nstruct txx9spi *c = spi_master_get_devdata(master);\r\ndestroy_workqueue(c->workqueue);\r\nclk_disable(c->clk);\r\nreturn 0;\r\n}\r\nstatic int __init txx9spi_init(void)\r\n{\r\nreturn platform_driver_register(&txx9spi_driver);\r\n}\r\nstatic void __exit txx9spi_exit(void)\r\n{\r\nplatform_driver_unregister(&txx9spi_driver);\r\n}
