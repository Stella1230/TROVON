static u8 sinp(int offset)\r\n{\r\nif (iommap)\r\noffset <<= ioshift;\r\nreturn inb(io + offset);\r\n}\r\nstatic void soutp(int offset, u8 value)\r\n{\r\nif (iommap)\r\noffset <<= ioshift;\r\noutb(value, io + offset);\r\n}\r\nstatic void on(void)\r\n{\r\nif (txsense)\r\nsoutp(UART_MCR, hardware[type].off);\r\nelse\r\nsoutp(UART_MCR, hardware[type].on);\r\n}\r\nstatic void off(void)\r\n{\r\nif (txsense)\r\nsoutp(UART_MCR, hardware[type].on);\r\nelse\r\nsoutp(UART_MCR, hardware[type].off);\r\n}\r\nstatic void safe_udelay(unsigned long usecs)\r\n{\r\nwhile (usecs > MAX_UDELAY_US) {\r\nudelay(MAX_UDELAY_US);\r\nusecs -= MAX_UDELAY_US;\r\n}\r\nudelay(usecs);\r\n}\r\nstatic int init_timing_params(unsigned int new_duty_cycle,\r\nunsigned int new_freq)\r\n{\r\n__u64 loops_per_sec, work;\r\nduty_cycle = new_duty_cycle;\r\nfreq = new_freq;\r\nloops_per_sec = __this_cpu_read(cpu.info.loops_per_jiffy);\r\nloops_per_sec *= HZ;\r\nwork = loops_per_sec;\r\nwork *= 4295;\r\nperiod = loops_per_sec >> 3;\r\nperiod /= (freq >> 3);\r\npulse_width = period * duty_cycle / 100;\r\nspace_width = period - pulse_width;\r\npr_debug("in init_timing_params, freq=%d, duty_cycle=%d, clk/jiffy=%ld, pulse=%ld, space=%ld, conv_us_to_clocks=%ld\n",\r\nfreq, duty_cycle, __this_cpu_read(cpu_info.loops_per_jiffy),\r\npulse_width, space_width, conv_us_to_clocks);\r\nreturn 0;\r\n}\r\nstatic int init_timing_params(unsigned int new_duty_cycle,\r\nunsigned int new_freq)\r\n{\r\nif (256 * 1000000L / new_freq * new_duty_cycle / 100 <=\r\nLIRC_SERIAL_TRANSMITTER_LATENCY)\r\nreturn -EINVAL;\r\nif (256 * 1000000L / new_freq * (100 - new_duty_cycle) / 100 <=\r\nLIRC_SERIAL_TRANSMITTER_LATENCY)\r\nreturn -EINVAL;\r\nduty_cycle = new_duty_cycle;\r\nfreq = new_freq;\r\nperiod = 256 * 1000000L / freq;\r\npulse_width = period * duty_cycle / 100;\r\nspace_width = period - pulse_width;\r\npr_debug("in init_timing_params, freq=%d pulse=%ld, space=%ld\n",\r\nfreq, pulse_width, space_width);\r\nreturn 0;\r\n}\r\nstatic long send_pulse_irdeo(unsigned long length)\r\n{\r\nlong rawbits, ret;\r\nint i;\r\nunsigned char output;\r\nunsigned char chunk, shifted;\r\nrawbits = length * 1152 / 10000;\r\nif (duty_cycle > 50)\r\nchunk = 3;\r\nelse\r\nchunk = 1;\r\nfor (i = 0, output = 0x7f; rawbits > 0; rawbits -= 3) {\r\nshifted = chunk << (i * 3);\r\nshifted >>= 1;\r\noutput &= (~shifted);\r\ni++;\r\nif (i == 3) {\r\nsoutp(UART_TX, output);\r\nwhile (!(sinp(UART_LSR) & UART_LSR_THRE))\r\n;\r\noutput = 0x7f;\r\ni = 0;\r\n}\r\n}\r\nif (i != 0) {\r\nsoutp(UART_TX, output);\r\nwhile (!(sinp(UART_LSR) & UART_LSR_TEMT))\r\n;\r\n}\r\nif (i == 0)\r\nret = (-rawbits) * 10000 / 1152;\r\nelse\r\nret = (3 - i) * 3 * 10000 / 1152 + (-rawbits) * 10000 / 1152;\r\nreturn ret;\r\n}\r\nstatic long send_pulse_homebrew_softcarrier(unsigned long length)\r\n{\r\nint flag;\r\nunsigned long actual, target, d;\r\nlength <<= 8;\r\nactual = 0; target = 0; flag = 0;\r\nwhile (actual < length) {\r\nif (flag) {\r\noff();\r\ntarget += space_width;\r\n} else {\r\non();\r\ntarget += pulse_width;\r\n}\r\nd = (target - actual -\r\nLIRC_SERIAL_TRANSMITTER_LATENCY + 128) >> 8;\r\nudelay(d);\r\nactual += (d << 8) + LIRC_SERIAL_TRANSMITTER_LATENCY;\r\nflag = !flag;\r\n}\r\nreturn (actual-length) >> 8;\r\n}\r\nstatic long send_pulse_homebrew(unsigned long length)\r\n{\r\nif (length <= 0)\r\nreturn 0;\r\nif (softcarrier)\r\nreturn send_pulse_homebrew_softcarrier(length);\r\non();\r\nsafe_udelay(length);\r\nreturn 0;\r\n}\r\nstatic void send_space_irdeo(long length)\r\n{\r\nif (length <= 0)\r\nreturn;\r\nsafe_udelay(length);\r\n}\r\nstatic void send_space_homebrew(long length)\r\n{\r\noff();\r\nif (length <= 0)\r\nreturn;\r\nsafe_udelay(length);\r\n}\r\nstatic void rbwrite(int l)\r\n{\r\nif (lirc_buffer_full(&rbuf)) {\r\npr_debug("Buffer overrun\n");\r\nreturn;\r\n}\r\nlirc_buffer_write(&rbuf, (void *)&l);\r\n}\r\nstatic void frbwrite(int l)\r\n{\r\nstatic int pulse, space;\r\nstatic unsigned int ptr;\r\nif (ptr > 0 && (l & PULSE_BIT)) {\r\npulse += l & PULSE_MASK;\r\nif (pulse > 250) {\r\nrbwrite(space);\r\nrbwrite(pulse | PULSE_BIT);\r\nptr = 0;\r\npulse = 0;\r\n}\r\nreturn;\r\n}\r\nif (!(l & PULSE_BIT)) {\r\nif (ptr == 0) {\r\nif (l > 20000) {\r\nspace = l;\r\nptr++;\r\nreturn;\r\n}\r\n} else {\r\nif (l > 20000) {\r\nspace += pulse;\r\nif (space > PULSE_MASK)\r\nspace = PULSE_MASK;\r\nspace += l;\r\nif (space > PULSE_MASK)\r\nspace = PULSE_MASK;\r\npulse = 0;\r\nreturn;\r\n}\r\nrbwrite(space);\r\nrbwrite(pulse | PULSE_BIT);\r\nptr = 0;\r\npulse = 0;\r\n}\r\n}\r\nrbwrite(l);\r\n}\r\nstatic irqreturn_t lirc_irq_handler(int i, void *blah)\r\n{\r\nktime_t kt;\r\nint counter, dcd;\r\nu8 status;\r\nktime_t delkt;\r\nint data;\r\nstatic int last_dcd = -1;\r\nif ((sinp(UART_IIR) & UART_IIR_NO_INT)) {\r\nreturn IRQ_NONE;\r\n}\r\ncounter = 0;\r\ndo {\r\ncounter++;\r\nstatus = sinp(UART_MSR);\r\nif (counter > RS_ISR_PASS_LIMIT) {\r\npr_warn("AIEEEE: We're caught!\n");\r\nbreak;\r\n}\r\nif ((status & hardware[type].signal_pin_change)\r\n&& sense != -1) {\r\nkt = ktime_get();\r\ndcd = (status & hardware[type].signal_pin) ? 1 : 0;\r\nif (dcd == last_dcd) {\r\npr_warn("ignoring spike: %d %d %llx %llx\n",\r\ndcd, sense, ktime_to_us(kt),\r\nktime_to_us(lastkt));\r\ncontinue;\r\n}\r\ndelkt = ktime_sub(kt, lastkt);\r\nif (ktime_compare(delkt, ktime_set(15, 0)) > 0) {\r\ndata = PULSE_MASK;\r\nif (!(dcd^sense)) {\r\npr_warn("AIEEEE: %d %d %llx %llx\n",\r\ndcd, sense, ktime_to_us(kt),\r\nktime_to_us(lastkt));\r\nsense = sense ? 0 : 1;\r\n}\r\n} else\r\ndata = (int) ktime_to_us(delkt);\r\nfrbwrite(dcd^sense ? data : (data|PULSE_BIT));\r\nlastkt = kt;\r\nlast_dcd = dcd;\r\nwake_up_interruptible(&rbuf.wait_poll);\r\n}\r\n} while (!(sinp(UART_IIR) & UART_IIR_NO_INT));\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int hardware_init_port(void)\r\n{\r\nu8 scratch, scratch2, scratch3;\r\nscratch = sinp(UART_IER);\r\nsoutp(UART_IER, 0);\r\n#ifdef __i386__\r\noutb(0xff, 0x080);\r\n#endif\r\nscratch2 = sinp(UART_IER) & 0x0f;\r\nsoutp(UART_IER, 0x0f);\r\n#ifdef __i386__\r\noutb(0x00, 0x080);\r\n#endif\r\nscratch3 = sinp(UART_IER) & 0x0f;\r\nsoutp(UART_IER, scratch);\r\nif (scratch2 != 0 || scratch3 != 0x0f) {\r\npr_err("port existence test failed, cannot continue\n");\r\nreturn -ENODEV;\r\n}\r\nsoutp(UART_LCR, sinp(UART_LCR) & (~UART_LCR_DLAB));\r\nsoutp(UART_IER, sinp(UART_IER) &\r\n(~(UART_IER_MSI|UART_IER_RLSI|UART_IER_THRI|UART_IER_RDI)));\r\nsinp(UART_LSR);\r\nsinp(UART_RX);\r\nsinp(UART_IIR);\r\nsinp(UART_MSR);\r\noff();\r\nsinp(UART_LSR);\r\nsinp(UART_RX);\r\nsinp(UART_IIR);\r\nsinp(UART_MSR);\r\nswitch (type) {\r\ncase LIRC_IRDEO:\r\ncase LIRC_IRDEO_REMOTE:\r\nsoutp(UART_LCR, sinp(UART_LCR) | UART_LCR_DLAB);\r\nsoutp(UART_DLM, 0);\r\nsoutp(UART_DLL, 1);\r\nsoutp(UART_LCR, UART_LCR_WLEN7);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic int lirc_serial_probe(struct platform_device *dev)\r\n{\r\nint i, nlow, nhigh, result;\r\nresult = devm_request_irq(&dev->dev, irq, lirc_irq_handler,\r\n(share_irq ? IRQF_SHARED : 0),\r\nLIRC_DRIVER_NAME, &hardware);\r\nif (result < 0) {\r\nif (result == -EBUSY)\r\ndev_err(&dev->dev, "IRQ %d busy\n", irq);\r\nelse if (result == -EINVAL)\r\ndev_err(&dev->dev, "Bad irq number or handler\n");\r\nreturn result;\r\n}\r\nif (((iommap)\r\n&& (devm_request_mem_region(&dev->dev, iommap, 8 << ioshift,\r\nLIRC_DRIVER_NAME) == NULL))\r\n|| ((!iommap)\r\n&& (devm_request_region(&dev->dev, io, 8,\r\nLIRC_DRIVER_NAME) == NULL))) {\r\ndev_err(&dev->dev, "port %04x already in use\n", io);\r\ndev_warn(&dev->dev, "use 'setserial /dev/ttySX uart none'\n");\r\ndev_warn(&dev->dev,\r\n"or compile the serial port driver as module and\n");\r\ndev_warn(&dev->dev, "make sure this module is loaded first\n");\r\nreturn -EBUSY;\r\n}\r\nresult = hardware_init_port();\r\nif (result < 0)\r\nreturn result;\r\ninit_timing_params(duty_cycle, freq);\r\nif (sense == -1) {\r\nmsleep(500);\r\nnlow = 0;\r\nnhigh = 0;\r\nfor (i = 0; i < 9; i++) {\r\nif (sinp(UART_MSR) & hardware[type].signal_pin)\r\nnlow++;\r\nelse\r\nnhigh++;\r\nmsleep(40);\r\n}\r\nsense = nlow >= nhigh ? 1 : 0;\r\ndev_info(&dev->dev, "auto-detected active %s receiver\n",\r\nsense ? "low" : "high");\r\n} else\r\ndev_info(&dev->dev, "Manually using active %s receiver\n",\r\nsense ? "low" : "high");\r\ndev_dbg(&dev->dev, "Interrupt %d, port %04x obtained\n", irq, io);\r\nreturn 0;\r\n}\r\nstatic int set_use_inc(void *data)\r\n{\r\nunsigned long flags;\r\nlastkt = ktime_get();\r\nspin_lock_irqsave(&hardware[type].lock, flags);\r\nsoutp(UART_LCR, sinp(UART_LCR) & (~UART_LCR_DLAB));\r\nsoutp(UART_IER, sinp(UART_IER)|UART_IER_MSI);\r\nspin_unlock_irqrestore(&hardware[type].lock, flags);\r\nreturn 0;\r\n}\r\nstatic void set_use_dec(void *data)\r\n{ unsigned long flags;\r\nspin_lock_irqsave(&hardware[type].lock, flags);\r\nsoutp(UART_LCR, sinp(UART_LCR) & (~UART_LCR_DLAB));\r\nsoutp(UART_IER, sinp(UART_IER) &\r\n(~(UART_IER_MSI|UART_IER_RLSI|UART_IER_THRI|UART_IER_RDI)));\r\nspin_unlock_irqrestore(&hardware[type].lock, flags);\r\n}\r\nstatic ssize_t lirc_write(struct file *file, const char __user *buf,\r\nsize_t n, loff_t *ppos)\r\n{\r\nint i, count;\r\nunsigned long flags;\r\nlong delta = 0;\r\nint *wbuf;\r\nif (!(hardware[type].features & LIRC_CAN_SEND_PULSE))\r\nreturn -EPERM;\r\ncount = n / sizeof(int);\r\nif (n % sizeof(int) || count % 2 == 0)\r\nreturn -EINVAL;\r\nwbuf = memdup_user(buf, n);\r\nif (IS_ERR(wbuf))\r\nreturn PTR_ERR(wbuf);\r\nspin_lock_irqsave(&hardware[type].lock, flags);\r\nif (type == LIRC_IRDEO) {\r\non();\r\n}\r\nfor (i = 0; i < count; i++) {\r\nif (i%2)\r\nhardware[type].send_space(wbuf[i] - delta);\r\nelse\r\ndelta = hardware[type].send_pulse(wbuf[i]);\r\n}\r\noff();\r\nspin_unlock_irqrestore(&hardware[type].lock, flags);\r\nkfree(wbuf);\r\nreturn n;\r\n}\r\nstatic long lirc_ioctl(struct file *filep, unsigned int cmd, unsigned long arg)\r\n{\r\nint result;\r\nu32 __user *uptr = (u32 __user *)arg;\r\nu32 value;\r\nswitch (cmd) {\r\ncase LIRC_GET_SEND_MODE:\r\nif (!(hardware[type].features&LIRC_CAN_SEND_MASK))\r\nreturn -ENOIOCTLCMD;\r\nresult = put_user(LIRC_SEND2MODE\r\n(hardware[type].features&LIRC_CAN_SEND_MASK),\r\nuptr);\r\nif (result)\r\nreturn result;\r\nbreak;\r\ncase LIRC_SET_SEND_MODE:\r\nif (!(hardware[type].features&LIRC_CAN_SEND_MASK))\r\nreturn -ENOIOCTLCMD;\r\nresult = get_user(value, uptr);\r\nif (result)\r\nreturn result;\r\nif (value != LIRC_MODE_PULSE)\r\nreturn -EINVAL;\r\nbreak;\r\ncase LIRC_GET_LENGTH:\r\nreturn -ENOIOCTLCMD;\r\ncase LIRC_SET_SEND_DUTY_CYCLE:\r\npr_debug("SET_SEND_DUTY_CYCLE\n");\r\nif (!(hardware[type].features&LIRC_CAN_SET_SEND_DUTY_CYCLE))\r\nreturn -ENOIOCTLCMD;\r\nresult = get_user(value, uptr);\r\nif (result)\r\nreturn result;\r\nif (value <= 0 || value > 100)\r\nreturn -EINVAL;\r\nreturn init_timing_params(value, freq);\r\ncase LIRC_SET_SEND_CARRIER:\r\npr_debug("SET_SEND_CARRIER\n");\r\nif (!(hardware[type].features&LIRC_CAN_SET_SEND_CARRIER))\r\nreturn -ENOIOCTLCMD;\r\nresult = get_user(value, uptr);\r\nif (result)\r\nreturn result;\r\nif (value > 500000 || value < 20000)\r\nreturn -EINVAL;\r\nreturn init_timing_params(duty_cycle, value);\r\ndefault:\r\nreturn lirc_dev_fop_ioctl(filep, cmd, arg);\r\n}\r\nreturn 0;\r\n}\r\nstatic int lirc_serial_suspend(struct platform_device *dev,\r\npm_message_t state)\r\n{\r\nsoutp(UART_LCR, sinp(UART_LCR) & (~UART_LCR_DLAB));\r\nsoutp(UART_IER, sinp(UART_IER) &\r\n(~(UART_IER_MSI|UART_IER_RLSI|UART_IER_THRI|UART_IER_RDI)));\r\nsinp(UART_LSR);\r\nsinp(UART_RX);\r\nsinp(UART_IIR);\r\nsinp(UART_MSR);\r\nreturn 0;\r\n}\r\nstatic int lirc_serial_resume(struct platform_device *dev)\r\n{\r\nunsigned long flags;\r\nint result;\r\nresult = hardware_init_port();\r\nif (result < 0)\r\nreturn result;\r\nspin_lock_irqsave(&hardware[type].lock, flags);\r\nlastkt = ktime_get();\r\nsoutp(UART_IER, sinp(UART_IER)|UART_IER_MSI);\r\noff();\r\nlirc_buffer_clear(&rbuf);\r\nspin_unlock_irqrestore(&hardware[type].lock, flags);\r\nreturn 0;\r\n}\r\nstatic int __init lirc_serial_init(void)\r\n{\r\nint result;\r\nresult = lirc_buffer_init(&rbuf, sizeof(int), RBUF_LEN);\r\nif (result < 0)\r\nreturn result;\r\nresult = platform_driver_register(&lirc_serial_driver);\r\nif (result) {\r\nprintk("lirc register returned %d\n", result);\r\ngoto exit_buffer_free;\r\n}\r\nlirc_serial_dev = platform_device_alloc("lirc_serial", 0);\r\nif (!lirc_serial_dev) {\r\nresult = -ENOMEM;\r\ngoto exit_driver_unregister;\r\n}\r\nresult = platform_device_add(lirc_serial_dev);\r\nif (result)\r\ngoto exit_device_put;\r\nreturn 0;\r\nexit_device_put:\r\nplatform_device_put(lirc_serial_dev);\r\nexit_driver_unregister:\r\nplatform_driver_unregister(&lirc_serial_driver);\r\nexit_buffer_free:\r\nlirc_buffer_free(&rbuf);\r\nreturn result;\r\n}\r\nstatic void lirc_serial_exit(void)\r\n{\r\nplatform_device_unregister(lirc_serial_dev);\r\nplatform_driver_unregister(&lirc_serial_driver);\r\nlirc_buffer_free(&rbuf);\r\n}\r\nstatic int __init lirc_serial_init_module(void)\r\n{\r\nint result;\r\nswitch (type) {\r\ncase LIRC_HOMEBREW:\r\ncase LIRC_IRDEO:\r\ncase LIRC_IRDEO_REMOTE:\r\ncase LIRC_ANIMAX:\r\ncase LIRC_IGOR:\r\nio = io ? io : 0x3f8;\r\nirq = irq ? irq : 4;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nif (!softcarrier) {\r\nswitch (type) {\r\ncase LIRC_HOMEBREW:\r\ncase LIRC_IGOR:\r\nhardware[type].features &=\r\n~(LIRC_CAN_SET_SEND_DUTY_CYCLE|\r\nLIRC_CAN_SET_SEND_CARRIER);\r\nbreak;\r\n}\r\n}\r\nif (sense != -1)\r\nsense = !!sense;\r\nresult = lirc_serial_init();\r\nif (result)\r\nreturn result;\r\ndriver.features = hardware[type].features;\r\ndriver.dev = &lirc_serial_dev->dev;\r\ndriver.minor = lirc_register_driver(&driver);\r\nif (driver.minor < 0) {\r\npr_err("register_chrdev failed!\n");\r\nlirc_serial_exit();\r\nreturn driver.minor;\r\n}\r\nreturn 0;\r\n}\r\nstatic void __exit lirc_serial_exit_module(void)\r\n{\r\nlirc_unregister_driver(driver.minor);\r\nlirc_serial_exit();\r\npr_debug("cleaned up module\n");\r\n}
