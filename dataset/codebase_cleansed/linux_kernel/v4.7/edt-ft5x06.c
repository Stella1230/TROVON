static int edt_ft5x06_ts_readwrite(struct i2c_client *client,\r\nu16 wr_len, u8 *wr_buf,\r\nu16 rd_len, u8 *rd_buf)\r\n{\r\nstruct i2c_msg wrmsg[2];\r\nint i = 0;\r\nint ret;\r\nif (wr_len) {\r\nwrmsg[i].addr = client->addr;\r\nwrmsg[i].flags = 0;\r\nwrmsg[i].len = wr_len;\r\nwrmsg[i].buf = wr_buf;\r\ni++;\r\n}\r\nif (rd_len) {\r\nwrmsg[i].addr = client->addr;\r\nwrmsg[i].flags = I2C_M_RD;\r\nwrmsg[i].len = rd_len;\r\nwrmsg[i].buf = rd_buf;\r\ni++;\r\n}\r\nret = i2c_transfer(client->adapter, wrmsg, i);\r\nif (ret < 0)\r\nreturn ret;\r\nif (ret != i)\r\nreturn -EIO;\r\nreturn 0;\r\n}\r\nstatic bool edt_ft5x06_ts_check_crc(struct edt_ft5x06_ts_data *tsdata,\r\nu8 *buf, int buflen)\r\n{\r\nint i;\r\nu8 crc = 0;\r\nfor (i = 0; i < buflen - 1; i++)\r\ncrc ^= buf[i];\r\nif (crc != buf[buflen-1]) {\r\ndev_err_ratelimited(&tsdata->client->dev,\r\n"crc error: 0x%02x expected, got 0x%02x\n",\r\ncrc, buf[buflen-1]);\r\nreturn false;\r\n}\r\nreturn true;\r\n}\r\nstatic irqreturn_t edt_ft5x06_ts_isr(int irq, void *dev_id)\r\n{\r\nstruct edt_ft5x06_ts_data *tsdata = dev_id;\r\nstruct device *dev = &tsdata->client->dev;\r\nu8 cmd;\r\nu8 rdbuf[63];\r\nint i, type, x, y, id;\r\nint offset, tplen, datalen, crclen;\r\nint error;\r\nswitch (tsdata->version) {\r\ncase M06:\r\ncmd = 0xf9;\r\noffset = 5;\r\ntplen = 4;\r\ncrclen = 1;\r\nbreak;\r\ncase M09:\r\ncmd = 0x0;\r\noffset = 3;\r\ntplen = 6;\r\ncrclen = 0;\r\nbreak;\r\ndefault:\r\ngoto out;\r\n}\r\nmemset(rdbuf, 0, sizeof(rdbuf));\r\ndatalen = tplen * tsdata->max_support_points + offset + crclen;\r\nerror = edt_ft5x06_ts_readwrite(tsdata->client,\r\nsizeof(cmd), &cmd,\r\ndatalen, rdbuf);\r\nif (error) {\r\ndev_err_ratelimited(dev, "Unable to fetch data, error: %d\n",\r\nerror);\r\ngoto out;\r\n}\r\nif (tsdata->version == M06) {\r\nif (rdbuf[0] != 0xaa || rdbuf[1] != 0xaa ||\r\nrdbuf[2] != datalen) {\r\ndev_err_ratelimited(dev,\r\n"Unexpected header: %02x%02x%02x!\n",\r\nrdbuf[0], rdbuf[1], rdbuf[2]);\r\ngoto out;\r\n}\r\nif (!edt_ft5x06_ts_check_crc(tsdata, rdbuf, datalen))\r\ngoto out;\r\n}\r\nfor (i = 0; i < tsdata->max_support_points; i++) {\r\nu8 *buf = &rdbuf[i * tplen + offset];\r\nbool down;\r\ntype = buf[0] >> 6;\r\nif (type == TOUCH_EVENT_RESERVED)\r\ncontinue;\r\nif (tsdata->version == M06 && type == TOUCH_EVENT_DOWN)\r\ncontinue;\r\nx = ((buf[0] << 8) | buf[1]) & 0x0fff;\r\ny = ((buf[2] << 8) | buf[3]) & 0x0fff;\r\nid = (buf[2] >> 4) & 0x0f;\r\ndown = type != TOUCH_EVENT_UP;\r\ninput_mt_slot(tsdata->input, id);\r\ninput_mt_report_slot_state(tsdata->input, MT_TOOL_FINGER, down);\r\nif (!down)\r\ncontinue;\r\ninput_report_abs(tsdata->input, ABS_MT_POSITION_X, x);\r\ninput_report_abs(tsdata->input, ABS_MT_POSITION_Y, y);\r\n}\r\ninput_mt_report_pointer_emulation(tsdata->input, true);\r\ninput_sync(tsdata->input);\r\nout:\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int edt_ft5x06_register_write(struct edt_ft5x06_ts_data *tsdata,\r\nu8 addr, u8 value)\r\n{\r\nu8 wrbuf[4];\r\nswitch (tsdata->version) {\r\ncase M06:\r\nwrbuf[0] = tsdata->factory_mode ? 0xf3 : 0xfc;\r\nwrbuf[1] = tsdata->factory_mode ? addr & 0x7f : addr & 0x3f;\r\nwrbuf[2] = value;\r\nwrbuf[3] = wrbuf[0] ^ wrbuf[1] ^ wrbuf[2];\r\nreturn edt_ft5x06_ts_readwrite(tsdata->client, 4,\r\nwrbuf, 0, NULL);\r\ncase M09:\r\nwrbuf[0] = addr;\r\nwrbuf[1] = value;\r\nreturn edt_ft5x06_ts_readwrite(tsdata->client, 2,\r\nwrbuf, 0, NULL);\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\n}\r\nstatic int edt_ft5x06_register_read(struct edt_ft5x06_ts_data *tsdata,\r\nu8 addr)\r\n{\r\nu8 wrbuf[2], rdbuf[2];\r\nint error;\r\nswitch (tsdata->version) {\r\ncase M06:\r\nwrbuf[0] = tsdata->factory_mode ? 0xf3 : 0xfc;\r\nwrbuf[1] = tsdata->factory_mode ? addr & 0x7f : addr & 0x3f;\r\nwrbuf[1] |= tsdata->factory_mode ? 0x80 : 0x40;\r\nerror = edt_ft5x06_ts_readwrite(tsdata->client, 2, wrbuf, 2,\r\nrdbuf);\r\nif (error)\r\nreturn error;\r\nif ((wrbuf[0] ^ wrbuf[1] ^ rdbuf[0]) != rdbuf[1]) {\r\ndev_err(&tsdata->client->dev,\r\n"crc error: 0x%02x expected, got 0x%02x\n",\r\nwrbuf[0] ^ wrbuf[1] ^ rdbuf[0],\r\nrdbuf[1]);\r\nreturn -EIO;\r\n}\r\nbreak;\r\ncase M09:\r\nwrbuf[0] = addr;\r\nerror = edt_ft5x06_ts_readwrite(tsdata->client, 1,\r\nwrbuf, 1, rdbuf);\r\nif (error)\r\nreturn error;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn rdbuf[0];\r\n}\r\nstatic ssize_t edt_ft5x06_setting_show(struct device *dev,\r\nstruct device_attribute *dattr,\r\nchar *buf)\r\n{\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nstruct edt_ft5x06_ts_data *tsdata = i2c_get_clientdata(client);\r\nstruct edt_ft5x06_attribute *attr =\r\ncontainer_of(dattr, struct edt_ft5x06_attribute, dattr);\r\nu8 *field = (u8 *)tsdata + attr->field_offset;\r\nint val;\r\nsize_t count = 0;\r\nint error = 0;\r\nu8 addr;\r\nmutex_lock(&tsdata->mutex);\r\nif (tsdata->factory_mode) {\r\nerror = -EIO;\r\ngoto out;\r\n}\r\nswitch (tsdata->version) {\r\ncase M06:\r\naddr = attr->addr_m06;\r\nbreak;\r\ncase M09:\r\naddr = attr->addr_m09;\r\nbreak;\r\ndefault:\r\nerror = -ENODEV;\r\ngoto out;\r\n}\r\nif (addr != NO_REGISTER) {\r\nval = edt_ft5x06_register_read(tsdata, addr);\r\nif (val < 0) {\r\nerror = val;\r\ndev_err(&tsdata->client->dev,\r\n"Failed to fetch attribute %s, error %d\n",\r\ndattr->attr.name, error);\r\ngoto out;\r\n}\r\n} else {\r\nval = *field;\r\n}\r\nif (val != *field) {\r\ndev_warn(&tsdata->client->dev,\r\n"%s: read (%d) and stored value (%d) differ\n",\r\ndattr->attr.name, val, *field);\r\n*field = val;\r\n}\r\ncount = scnprintf(buf, PAGE_SIZE, "%d\n", val);\r\nout:\r\nmutex_unlock(&tsdata->mutex);\r\nreturn error ?: count;\r\n}\r\nstatic ssize_t edt_ft5x06_setting_store(struct device *dev,\r\nstruct device_attribute *dattr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nstruct edt_ft5x06_ts_data *tsdata = i2c_get_clientdata(client);\r\nstruct edt_ft5x06_attribute *attr =\r\ncontainer_of(dattr, struct edt_ft5x06_attribute, dattr);\r\nu8 *field = (u8 *)tsdata + attr->field_offset;\r\nunsigned int val;\r\nint error;\r\nu8 addr;\r\nmutex_lock(&tsdata->mutex);\r\nif (tsdata->factory_mode) {\r\nerror = -EIO;\r\ngoto out;\r\n}\r\nerror = kstrtouint(buf, 0, &val);\r\nif (error)\r\ngoto out;\r\nif (val < attr->limit_low || val > attr->limit_high) {\r\nerror = -ERANGE;\r\ngoto out;\r\n}\r\nswitch (tsdata->version) {\r\ncase M06:\r\naddr = attr->addr_m06;\r\nbreak;\r\ncase M09:\r\naddr = attr->addr_m09;\r\nbreak;\r\ndefault:\r\nerror = -ENODEV;\r\ngoto out;\r\n}\r\nif (addr != NO_REGISTER) {\r\nerror = edt_ft5x06_register_write(tsdata, addr, val);\r\nif (error) {\r\ndev_err(&tsdata->client->dev,\r\n"Failed to update attribute %s, error: %d\n",\r\ndattr->attr.name, error);\r\ngoto out;\r\n}\r\n}\r\n*field = val;\r\nout:\r\nmutex_unlock(&tsdata->mutex);\r\nreturn error ?: count;\r\n}\r\nstatic int edt_ft5x06_factory_mode(struct edt_ft5x06_ts_data *tsdata)\r\n{\r\nstruct i2c_client *client = tsdata->client;\r\nint retries = EDT_SWITCH_MODE_RETRIES;\r\nint ret;\r\nint error;\r\ndisable_irq(client->irq);\r\nif (!tsdata->raw_buffer) {\r\ntsdata->raw_bufsize = tsdata->num_x * tsdata->num_y *\r\nsizeof(u16);\r\ntsdata->raw_buffer = kzalloc(tsdata->raw_bufsize, GFP_KERNEL);\r\nif (!tsdata->raw_buffer) {\r\nerror = -ENOMEM;\r\ngoto err_out;\r\n}\r\n}\r\nif (tsdata->version == M09)\r\ngoto m09_out;\r\nerror = edt_ft5x06_register_write(tsdata, WORK_REGISTER_OPMODE, 0x03);\r\nif (error) {\r\ndev_err(&client->dev,\r\n"failed to switch to factory mode, error %d\n", error);\r\ngoto err_out;\r\n}\r\ntsdata->factory_mode = true;\r\ndo {\r\nmdelay(EDT_SWITCH_MODE_DELAY);\r\nret = edt_ft5x06_register_read(tsdata, FACTORY_REGISTER_OPMODE);\r\nif (ret == 0x03)\r\nbreak;\r\n} while (--retries > 0);\r\nif (retries == 0) {\r\ndev_err(&client->dev, "not in factory mode after %dms.\n",\r\nEDT_SWITCH_MODE_RETRIES * EDT_SWITCH_MODE_DELAY);\r\nerror = -EIO;\r\ngoto err_out;\r\n}\r\nreturn 0;\r\nerr_out:\r\nkfree(tsdata->raw_buffer);\r\ntsdata->raw_buffer = NULL;\r\ntsdata->factory_mode = false;\r\nenable_irq(client->irq);\r\nreturn error;\r\nm09_out:\r\ndev_err(&client->dev, "No factory mode support for M09\n");\r\nreturn -EINVAL;\r\n}\r\nstatic int edt_ft5x06_work_mode(struct edt_ft5x06_ts_data *tsdata)\r\n{\r\nstruct i2c_client *client = tsdata->client;\r\nint retries = EDT_SWITCH_MODE_RETRIES;\r\nstruct edt_reg_addr *reg_addr = &tsdata->reg_addr;\r\nint ret;\r\nint error;\r\nerror = edt_ft5x06_register_write(tsdata, FACTORY_REGISTER_OPMODE, 0x1);\r\nif (error) {\r\ndev_err(&client->dev,\r\n"failed to switch to work mode, error: %d\n", error);\r\nreturn error;\r\n}\r\ntsdata->factory_mode = false;\r\ndo {\r\nmdelay(EDT_SWITCH_MODE_DELAY);\r\nret = edt_ft5x06_register_read(tsdata, WORK_REGISTER_OPMODE);\r\nif (ret == 0x01)\r\nbreak;\r\n} while (--retries > 0);\r\nif (retries == 0) {\r\ndev_err(&client->dev, "not in work mode after %dms.\n",\r\nEDT_SWITCH_MODE_RETRIES * EDT_SWITCH_MODE_DELAY);\r\ntsdata->factory_mode = true;\r\nreturn -EIO;\r\n}\r\nkfree(tsdata->raw_buffer);\r\ntsdata->raw_buffer = NULL;\r\nedt_ft5x06_register_write(tsdata, reg_addr->reg_threshold,\r\ntsdata->threshold);\r\nedt_ft5x06_register_write(tsdata, reg_addr->reg_gain,\r\ntsdata->gain);\r\nedt_ft5x06_register_write(tsdata, reg_addr->reg_offset,\r\ntsdata->offset);\r\nif (reg_addr->reg_report_rate)\r\nedt_ft5x06_register_write(tsdata, reg_addr->reg_report_rate,\r\ntsdata->report_rate);\r\nenable_irq(client->irq);\r\nreturn 0;\r\n}\r\nstatic int edt_ft5x06_debugfs_mode_get(void *data, u64 *mode)\r\n{\r\nstruct edt_ft5x06_ts_data *tsdata = data;\r\n*mode = tsdata->factory_mode;\r\nreturn 0;\r\n}\r\nstatic int edt_ft5x06_debugfs_mode_set(void *data, u64 mode)\r\n{\r\nstruct edt_ft5x06_ts_data *tsdata = data;\r\nint retval = 0;\r\nif (mode > 1)\r\nreturn -ERANGE;\r\nmutex_lock(&tsdata->mutex);\r\nif (mode != tsdata->factory_mode) {\r\nretval = mode ? edt_ft5x06_factory_mode(tsdata) :\r\nedt_ft5x06_work_mode(tsdata);\r\n}\r\nmutex_unlock(&tsdata->mutex);\r\nreturn retval;\r\n}\r\nstatic ssize_t edt_ft5x06_debugfs_raw_data_read(struct file *file,\r\nchar __user *buf, size_t count, loff_t *off)\r\n{\r\nstruct edt_ft5x06_ts_data *tsdata = file->private_data;\r\nstruct i2c_client *client = tsdata->client;\r\nint retries = EDT_RAW_DATA_RETRIES;\r\nint val, i, error;\r\nsize_t read = 0;\r\nint colbytes;\r\nchar wrbuf[3];\r\nu8 *rdbuf;\r\nif (*off < 0 || *off >= tsdata->raw_bufsize)\r\nreturn 0;\r\nmutex_lock(&tsdata->mutex);\r\nif (!tsdata->factory_mode || !tsdata->raw_buffer) {\r\nerror = -EIO;\r\ngoto out;\r\n}\r\nerror = edt_ft5x06_register_write(tsdata, 0x08, 0x01);\r\nif (error) {\r\ndev_dbg(&client->dev,\r\n"failed to write 0x08 register, error %d\n", error);\r\ngoto out;\r\n}\r\ndo {\r\nmsleep(EDT_RAW_DATA_DELAY);\r\nval = edt_ft5x06_register_read(tsdata, 0x08);\r\nif (val < 1)\r\nbreak;\r\n} while (--retries > 0);\r\nif (val < 0) {\r\nerror = val;\r\ndev_dbg(&client->dev,\r\n"failed to read 0x08 register, error %d\n", error);\r\ngoto out;\r\n}\r\nif (retries == 0) {\r\ndev_dbg(&client->dev,\r\n"timed out waiting for register to settle\n");\r\nerror = -ETIMEDOUT;\r\ngoto out;\r\n}\r\nrdbuf = tsdata->raw_buffer;\r\ncolbytes = tsdata->num_y * sizeof(u16);\r\nwrbuf[0] = 0xf5;\r\nwrbuf[1] = 0x0e;\r\nfor (i = 0; i < tsdata->num_x; i++) {\r\nwrbuf[2] = i;\r\nerror = edt_ft5x06_ts_readwrite(tsdata->client,\r\nsizeof(wrbuf), wrbuf,\r\ncolbytes, rdbuf);\r\nif (error)\r\ngoto out;\r\nrdbuf += colbytes;\r\n}\r\nread = min_t(size_t, count, tsdata->raw_bufsize - *off);\r\nif (copy_to_user(buf, tsdata->raw_buffer + *off, read)) {\r\nerror = -EFAULT;\r\ngoto out;\r\n}\r\n*off += read;\r\nout:\r\nmutex_unlock(&tsdata->mutex);\r\nreturn error ?: read;\r\n}\r\nstatic void\r\nedt_ft5x06_ts_prepare_debugfs(struct edt_ft5x06_ts_data *tsdata,\r\nconst char *debugfs_name)\r\n{\r\ntsdata->debug_dir = debugfs_create_dir(debugfs_name, NULL);\r\nif (!tsdata->debug_dir)\r\nreturn;\r\ndebugfs_create_u16("num_x", S_IRUSR, tsdata->debug_dir, &tsdata->num_x);\r\ndebugfs_create_u16("num_y", S_IRUSR, tsdata->debug_dir, &tsdata->num_y);\r\ndebugfs_create_file("mode", S_IRUSR | S_IWUSR,\r\ntsdata->debug_dir, tsdata, &debugfs_mode_fops);\r\ndebugfs_create_file("raw_data", S_IRUSR,\r\ntsdata->debug_dir, tsdata, &debugfs_raw_data_fops);\r\n}\r\nstatic void\r\nedt_ft5x06_ts_teardown_debugfs(struct edt_ft5x06_ts_data *tsdata)\r\n{\r\ndebugfs_remove_recursive(tsdata->debug_dir);\r\nkfree(tsdata->raw_buffer);\r\n}\r\nstatic inline void\r\nedt_ft5x06_ts_prepare_debugfs(struct edt_ft5x06_ts_data *tsdata,\r\nconst char *debugfs_name)\r\n{\r\n}\r\nstatic inline void\r\nedt_ft5x06_ts_teardown_debugfs(struct edt_ft5x06_ts_data *tsdata)\r\n{\r\n}\r\nstatic int edt_ft5x06_ts_identify(struct i2c_client *client,\r\nstruct edt_ft5x06_ts_data *tsdata,\r\nchar *fw_version)\r\n{\r\nu8 rdbuf[EDT_NAME_LEN];\r\nchar *p;\r\nint error;\r\nchar *model_name = tsdata->name;\r\nmemset(rdbuf, 0, sizeof(rdbuf));\r\nerror = edt_ft5x06_ts_readwrite(client, 1, "\xbb",\r\nEDT_NAME_LEN - 1, rdbuf);\r\nif (error)\r\nreturn error;\r\nif (!(strncasecmp(rdbuf + 1, "EP0", 3))) {\r\ntsdata->version = M06;\r\nrdbuf[EDT_NAME_LEN - 1] = '\0';\r\nif (rdbuf[EDT_NAME_LEN - 2] == '$')\r\nrdbuf[EDT_NAME_LEN - 2] = '\0';\r\np = strchr(rdbuf, '*');\r\nif (p)\r\n*p++ = '\0';\r\nstrlcpy(model_name, rdbuf + 1, EDT_NAME_LEN);\r\nstrlcpy(fw_version, p ? p : "", EDT_NAME_LEN);\r\n} else {\r\ntsdata->version = M09;\r\nerror = edt_ft5x06_ts_readwrite(client, 1, "\xA6",\r\n2, rdbuf);\r\nif (error)\r\nreturn error;\r\nstrlcpy(fw_version, rdbuf, 2);\r\nerror = edt_ft5x06_ts_readwrite(client, 1, "\xA8",\r\n1, rdbuf);\r\nif (error)\r\nreturn error;\r\nsnprintf(model_name, EDT_NAME_LEN, "EP0%i%i0M09",\r\nrdbuf[0] >> 4, rdbuf[0] & 0x0F);\r\n}\r\nreturn 0;\r\n}\r\nstatic void edt_ft5x06_ts_get_defaults(struct device *dev,\r\nstruct edt_ft5x06_ts_data *tsdata)\r\n{\r\nstruct edt_reg_addr *reg_addr = &tsdata->reg_addr;\r\nu32 val;\r\nint error;\r\nerror = device_property_read_u32(dev, "threshold", &val);\r\nif (!error) {\r\nedt_ft5x06_register_write(tsdata, reg_addr->reg_threshold, val);\r\ntsdata->threshold = val;\r\n}\r\nerror = device_property_read_u32(dev, "gain", &val);\r\nif (!error) {\r\nedt_ft5x06_register_write(tsdata, reg_addr->reg_gain, val);\r\ntsdata->gain = val;\r\n}\r\nerror = device_property_read_u32(dev, "offset", &val);\r\nif (!error) {\r\nedt_ft5x06_register_write(tsdata, reg_addr->reg_offset, val);\r\ntsdata->offset = val;\r\n}\r\n}\r\nstatic void\r\nedt_ft5x06_ts_get_parameters(struct edt_ft5x06_ts_data *tsdata)\r\n{\r\nstruct edt_reg_addr *reg_addr = &tsdata->reg_addr;\r\ntsdata->threshold = edt_ft5x06_register_read(tsdata,\r\nreg_addr->reg_threshold);\r\ntsdata->gain = edt_ft5x06_register_read(tsdata, reg_addr->reg_gain);\r\ntsdata->offset = edt_ft5x06_register_read(tsdata, reg_addr->reg_offset);\r\nif (reg_addr->reg_report_rate != NO_REGISTER)\r\ntsdata->report_rate = edt_ft5x06_register_read(tsdata,\r\nreg_addr->reg_report_rate);\r\ntsdata->num_x = edt_ft5x06_register_read(tsdata, reg_addr->reg_num_x);\r\ntsdata->num_y = edt_ft5x06_register_read(tsdata, reg_addr->reg_num_y);\r\n}\r\nstatic void\r\nedt_ft5x06_ts_set_regs(struct edt_ft5x06_ts_data *tsdata)\r\n{\r\nstruct edt_reg_addr *reg_addr = &tsdata->reg_addr;\r\nswitch (tsdata->version) {\r\ncase M06:\r\nreg_addr->reg_threshold = WORK_REGISTER_THRESHOLD;\r\nreg_addr->reg_report_rate = WORK_REGISTER_REPORT_RATE;\r\nreg_addr->reg_gain = WORK_REGISTER_GAIN;\r\nreg_addr->reg_offset = WORK_REGISTER_OFFSET;\r\nreg_addr->reg_num_x = WORK_REGISTER_NUM_X;\r\nreg_addr->reg_num_y = WORK_REGISTER_NUM_Y;\r\nbreak;\r\ncase M09:\r\nreg_addr->reg_threshold = M09_REGISTER_THRESHOLD;\r\nreg_addr->reg_gain = M09_REGISTER_GAIN;\r\nreg_addr->reg_offset = M09_REGISTER_OFFSET;\r\nreg_addr->reg_num_x = M09_REGISTER_NUM_X;\r\nreg_addr->reg_num_y = M09_REGISTER_NUM_Y;\r\nbreak;\r\n}\r\n}\r\nstatic int edt_ft5x06_ts_probe(struct i2c_client *client,\r\nconst struct i2c_device_id *id)\r\n{\r\nconst struct edt_i2c_chip_data *chip_data;\r\nstruct edt_ft5x06_ts_data *tsdata;\r\nstruct input_dev *input;\r\nunsigned long irq_flags;\r\nint error;\r\nchar fw_version[EDT_NAME_LEN];\r\ndev_dbg(&client->dev, "probing for EDT FT5x06 I2C\n");\r\ntsdata = devm_kzalloc(&client->dev, sizeof(*tsdata), GFP_KERNEL);\r\nif (!tsdata) {\r\ndev_err(&client->dev, "failed to allocate driver data.\n");\r\nreturn -ENOMEM;\r\n}\r\nchip_data = of_device_get_match_data(&client->dev);\r\nif (!chip_data)\r\nchip_data = (const struct edt_i2c_chip_data *)id->driver_data;\r\nif (!chip_data || !chip_data->max_support_points) {\r\ndev_err(&client->dev, "invalid or missing chip data\n");\r\nreturn -EINVAL;\r\n}\r\ntsdata->max_support_points = chip_data->max_support_points;\r\ntsdata->reset_gpio = devm_gpiod_get_optional(&client->dev,\r\n"reset", GPIOD_OUT_HIGH);\r\nif (IS_ERR(tsdata->reset_gpio)) {\r\nerror = PTR_ERR(tsdata->reset_gpio);\r\ndev_err(&client->dev,\r\n"Failed to request GPIO reset pin, error %d\n", error);\r\nreturn error;\r\n}\r\ntsdata->wake_gpio = devm_gpiod_get_optional(&client->dev,\r\n"wake", GPIOD_OUT_LOW);\r\nif (IS_ERR(tsdata->wake_gpio)) {\r\nerror = PTR_ERR(tsdata->wake_gpio);\r\ndev_err(&client->dev,\r\n"Failed to request GPIO wake pin, error %d\n", error);\r\nreturn error;\r\n}\r\nif (tsdata->wake_gpio) {\r\nusleep_range(5000, 6000);\r\ngpiod_set_value_cansleep(tsdata->wake_gpio, 1);\r\n}\r\nif (tsdata->reset_gpio) {\r\nusleep_range(5000, 6000);\r\ngpiod_set_value_cansleep(tsdata->reset_gpio, 0);\r\nmsleep(300);\r\n}\r\ninput = devm_input_allocate_device(&client->dev);\r\nif (!input) {\r\ndev_err(&client->dev, "failed to allocate input device.\n");\r\nreturn -ENOMEM;\r\n}\r\nmutex_init(&tsdata->mutex);\r\ntsdata->client = client;\r\ntsdata->input = input;\r\ntsdata->factory_mode = false;\r\nerror = edt_ft5x06_ts_identify(client, tsdata, fw_version);\r\nif (error) {\r\ndev_err(&client->dev, "touchscreen probe failed\n");\r\nreturn error;\r\n}\r\nedt_ft5x06_ts_set_regs(tsdata);\r\nedt_ft5x06_ts_get_defaults(&client->dev, tsdata);\r\nedt_ft5x06_ts_get_parameters(tsdata);\r\ndev_dbg(&client->dev,\r\n"Model \"%s\", Rev. \"%s\", %dx%d sensors\n",\r\ntsdata->name, fw_version, tsdata->num_x, tsdata->num_y);\r\ninput->name = tsdata->name;\r\ninput->id.bustype = BUS_I2C;\r\ninput->dev.parent = &client->dev;\r\ninput_set_abs_params(input, ABS_MT_POSITION_X,\r\n0, tsdata->num_x * 64 - 1, 0, 0);\r\ninput_set_abs_params(input, ABS_MT_POSITION_Y,\r\n0, tsdata->num_y * 64 - 1, 0, 0);\r\ntouchscreen_parse_properties(input, true);\r\nerror = input_mt_init_slots(input, tsdata->max_support_points,\r\nINPUT_MT_DIRECT);\r\nif (error) {\r\ndev_err(&client->dev, "Unable to init MT slots.\n");\r\nreturn error;\r\n}\r\ninput_set_drvdata(input, tsdata);\r\ni2c_set_clientdata(client, tsdata);\r\nirq_flags = irq_get_trigger_type(client->irq);\r\nif (irq_flags == IRQF_TRIGGER_NONE)\r\nirq_flags = IRQF_TRIGGER_FALLING;\r\nirq_flags |= IRQF_ONESHOT;\r\nerror = devm_request_threaded_irq(&client->dev, client->irq,\r\nNULL, edt_ft5x06_ts_isr, irq_flags,\r\nclient->name, tsdata);\r\nif (error) {\r\ndev_err(&client->dev, "Unable to request touchscreen IRQ.\n");\r\nreturn error;\r\n}\r\nerror = sysfs_create_group(&client->dev.kobj, &edt_ft5x06_attr_group);\r\nif (error)\r\nreturn error;\r\nerror = input_register_device(input);\r\nif (error)\r\ngoto err_remove_attrs;\r\nedt_ft5x06_ts_prepare_debugfs(tsdata, dev_driver_string(&client->dev));\r\ndevice_init_wakeup(&client->dev, 1);\r\ndev_dbg(&client->dev,\r\n"EDT FT5x06 initialized: IRQ %d, WAKE pin %d, Reset pin %d.\n",\r\nclient->irq,\r\ntsdata->wake_gpio ? desc_to_gpio(tsdata->wake_gpio) : -1,\r\ntsdata->reset_gpio ? desc_to_gpio(tsdata->reset_gpio) : -1);\r\nreturn 0;\r\nerr_remove_attrs:\r\nsysfs_remove_group(&client->dev.kobj, &edt_ft5x06_attr_group);\r\nreturn error;\r\n}\r\nstatic int edt_ft5x06_ts_remove(struct i2c_client *client)\r\n{\r\nstruct edt_ft5x06_ts_data *tsdata = i2c_get_clientdata(client);\r\nedt_ft5x06_ts_teardown_debugfs(tsdata);\r\nsysfs_remove_group(&client->dev.kobj, &edt_ft5x06_attr_group);\r\nreturn 0;\r\n}\r\nstatic int __maybe_unused edt_ft5x06_ts_suspend(struct device *dev)\r\n{\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nif (device_may_wakeup(dev))\r\nenable_irq_wake(client->irq);\r\nreturn 0;\r\n}\r\nstatic int __maybe_unused edt_ft5x06_ts_resume(struct device *dev)\r\n{\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nif (device_may_wakeup(dev))\r\ndisable_irq_wake(client->irq);\r\nreturn 0;\r\n}
