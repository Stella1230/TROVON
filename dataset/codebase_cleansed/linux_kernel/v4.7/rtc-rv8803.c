static irqreturn_t rv8803_handle_irq(int irq, void *dev_id)\r\n{\r\nstruct i2c_client *client = dev_id;\r\nstruct rv8803_data *rv8803 = i2c_get_clientdata(client);\r\nunsigned long events = 0;\r\nint flags, try = 0;\r\nmutex_lock(&rv8803->flags_lock);\r\ndo {\r\nflags = i2c_smbus_read_byte_data(client, RV8803_FLAG);\r\ntry++;\r\n} while ((flags == -ENXIO) && (try < 3));\r\nif (flags <= 0) {\r\nmutex_unlock(&rv8803->flags_lock);\r\nreturn IRQ_NONE;\r\n}\r\nif (flags & RV8803_FLAG_V1F)\r\ndev_warn(&client->dev, "Voltage low, temperature compensation stopped.\n");\r\nif (flags & RV8803_FLAG_V2F)\r\ndev_warn(&client->dev, "Voltage low, data loss detected.\n");\r\nif (flags & RV8803_FLAG_TF) {\r\nflags &= ~RV8803_FLAG_TF;\r\nrv8803->ctrl &= ~RV8803_CTRL_TIE;\r\nevents |= RTC_PF;\r\n}\r\nif (flags & RV8803_FLAG_AF) {\r\nflags &= ~RV8803_FLAG_AF;\r\nrv8803->ctrl &= ~RV8803_CTRL_AIE;\r\nevents |= RTC_AF;\r\n}\r\nif (flags & RV8803_FLAG_UF) {\r\nflags &= ~RV8803_FLAG_UF;\r\nrv8803->ctrl &= ~RV8803_CTRL_UIE;\r\nevents |= RTC_UF;\r\n}\r\nif (events) {\r\nrtc_update_irq(rv8803->rtc, 1, events);\r\ni2c_smbus_write_byte_data(client, RV8803_FLAG, flags);\r\ni2c_smbus_write_byte_data(rv8803->client, RV8803_CTRL,\r\nrv8803->ctrl);\r\n}\r\nmutex_unlock(&rv8803->flags_lock);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int rv8803_get_time(struct device *dev, struct rtc_time *tm)\r\n{\r\nstruct rv8803_data *rv8803 = dev_get_drvdata(dev);\r\nu8 date1[7];\r\nu8 date2[7];\r\nu8 *date = date1;\r\nint ret, flags;\r\nflags = i2c_smbus_read_byte_data(rv8803->client, RV8803_FLAG);\r\nif (flags < 0)\r\nreturn flags;\r\nif (flags & RV8803_FLAG_V2F) {\r\ndev_warn(dev, "Voltage low, data is invalid.\n");\r\nreturn -EINVAL;\r\n}\r\nret = i2c_smbus_read_i2c_block_data(rv8803->client, RV8803_SEC,\r\n7, date);\r\nif (ret != 7)\r\nreturn ret < 0 ? ret : -EIO;\r\nif ((date1[RV8803_SEC] & 0x7f) == bin2bcd(59)) {\r\nret = i2c_smbus_read_i2c_block_data(rv8803->client, RV8803_SEC,\r\n7, date2);\r\nif (ret != 7)\r\nreturn ret < 0 ? ret : -EIO;\r\nif ((date2[RV8803_SEC] & 0x7f) != bin2bcd(59))\r\ndate = date2;\r\n}\r\ntm->tm_sec = bcd2bin(date[RV8803_SEC] & 0x7f);\r\ntm->tm_min = bcd2bin(date[RV8803_MIN] & 0x7f);\r\ntm->tm_hour = bcd2bin(date[RV8803_HOUR] & 0x3f);\r\ntm->tm_wday = ffs(date[RV8803_WEEK] & 0x7f);\r\ntm->tm_mday = bcd2bin(date[RV8803_DAY] & 0x3f);\r\ntm->tm_mon = bcd2bin(date[RV8803_MONTH] & 0x1f) - 1;\r\ntm->tm_year = bcd2bin(date[RV8803_YEAR]) + 100;\r\nreturn rtc_valid_tm(tm);\r\n}\r\nstatic int rv8803_set_time(struct device *dev, struct rtc_time *tm)\r\n{\r\nstruct rv8803_data *rv8803 = dev_get_drvdata(dev);\r\nu8 date[7];\r\nint flags, ret;\r\nif ((tm->tm_year < 100) || (tm->tm_year > 199))\r\nreturn -EINVAL;\r\ndate[RV8803_SEC] = bin2bcd(tm->tm_sec);\r\ndate[RV8803_MIN] = bin2bcd(tm->tm_min);\r\ndate[RV8803_HOUR] = bin2bcd(tm->tm_hour);\r\ndate[RV8803_WEEK] = 1 << (tm->tm_wday);\r\ndate[RV8803_DAY] = bin2bcd(tm->tm_mday);\r\ndate[RV8803_MONTH] = bin2bcd(tm->tm_mon + 1);\r\ndate[RV8803_YEAR] = bin2bcd(tm->tm_year - 100);\r\nret = i2c_smbus_write_i2c_block_data(rv8803->client, RV8803_SEC,\r\n7, date);\r\nif (ret < 0)\r\nreturn ret;\r\nmutex_lock(&rv8803->flags_lock);\r\nflags = i2c_smbus_read_byte_data(rv8803->client, RV8803_FLAG);\r\nif (flags < 0) {\r\nmutex_unlock(&rv8803->flags_lock);\r\nreturn flags;\r\n}\r\nret = i2c_smbus_write_byte_data(rv8803->client, RV8803_FLAG,\r\nflags & ~RV8803_FLAG_V2F);\r\nmutex_unlock(&rv8803->flags_lock);\r\nreturn ret;\r\n}\r\nstatic int rv8803_get_alarm(struct device *dev, struct rtc_wkalrm *alrm)\r\n{\r\nstruct rv8803_data *rv8803 = dev_get_drvdata(dev);\r\nstruct i2c_client *client = rv8803->client;\r\nu8 alarmvals[3];\r\nint flags, ret;\r\nret = i2c_smbus_read_i2c_block_data(client, RV8803_ALARM_MIN,\r\n3, alarmvals);\r\nif (ret != 3)\r\nreturn ret < 0 ? ret : -EIO;\r\nflags = i2c_smbus_read_byte_data(client, RV8803_FLAG);\r\nif (flags < 0)\r\nreturn flags;\r\nalrm->time.tm_sec = 0;\r\nalrm->time.tm_min = bcd2bin(alarmvals[0] & 0x7f);\r\nalrm->time.tm_hour = bcd2bin(alarmvals[1] & 0x3f);\r\nalrm->time.tm_wday = -1;\r\nalrm->time.tm_mday = bcd2bin(alarmvals[2] & 0x3f);\r\nalrm->time.tm_mon = -1;\r\nalrm->time.tm_year = -1;\r\nalrm->enabled = !!(rv8803->ctrl & RV8803_CTRL_AIE);\r\nalrm->pending = (flags & RV8803_FLAG_AF) && alrm->enabled;\r\nreturn 0;\r\n}\r\nstatic int rv8803_set_alarm(struct device *dev, struct rtc_wkalrm *alrm)\r\n{\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nstruct rv8803_data *rv8803 = dev_get_drvdata(dev);\r\nu8 alarmvals[3];\r\nu8 ctrl[2];\r\nint ret, err;\r\nif (alrm->time.tm_sec) {\r\ntime64_t alarm_time = rtc_tm_to_time64(&alrm->time);\r\nalarm_time += 60 - alrm->time.tm_sec;\r\nrtc_time64_to_tm(alarm_time, &alrm->time);\r\n}\r\nmutex_lock(&rv8803->flags_lock);\r\nret = i2c_smbus_read_i2c_block_data(client, RV8803_FLAG, 2, ctrl);\r\nif (ret != 2) {\r\nmutex_unlock(&rv8803->flags_lock);\r\nreturn ret < 0 ? ret : -EIO;\r\n}\r\nalarmvals[0] = bin2bcd(alrm->time.tm_min);\r\nalarmvals[1] = bin2bcd(alrm->time.tm_hour);\r\nalarmvals[2] = bin2bcd(alrm->time.tm_mday);\r\nif (rv8803->ctrl & (RV8803_CTRL_AIE | RV8803_CTRL_UIE)) {\r\nrv8803->ctrl &= ~(RV8803_CTRL_AIE | RV8803_CTRL_UIE);\r\nerr = i2c_smbus_write_byte_data(rv8803->client, RV8803_CTRL,\r\nrv8803->ctrl);\r\nif (err) {\r\nmutex_unlock(&rv8803->flags_lock);\r\nreturn err;\r\n}\r\n}\r\nctrl[1] &= ~RV8803_FLAG_AF;\r\nerr = i2c_smbus_write_byte_data(rv8803->client, RV8803_FLAG, ctrl[1]);\r\nmutex_unlock(&rv8803->flags_lock);\r\nif (err)\r\nreturn err;\r\nerr = i2c_smbus_write_i2c_block_data(rv8803->client, RV8803_ALARM_MIN,\r\n3, alarmvals);\r\nif (err)\r\nreturn err;\r\nif (alrm->enabled) {\r\nif (rv8803->rtc->uie_rtctimer.enabled)\r\nrv8803->ctrl |= RV8803_CTRL_UIE;\r\nif (rv8803->rtc->aie_timer.enabled)\r\nrv8803->ctrl |= RV8803_CTRL_AIE;\r\nerr = i2c_smbus_write_byte_data(rv8803->client, RV8803_CTRL,\r\nrv8803->ctrl);\r\nif (err)\r\nreturn err;\r\n}\r\nreturn 0;\r\n}\r\nstatic int rv8803_alarm_irq_enable(struct device *dev, unsigned int enabled)\r\n{\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nstruct rv8803_data *rv8803 = dev_get_drvdata(dev);\r\nint ctrl, flags, err;\r\nctrl = rv8803->ctrl;\r\nif (enabled) {\r\nif (rv8803->rtc->uie_rtctimer.enabled)\r\nctrl |= RV8803_CTRL_UIE;\r\nif (rv8803->rtc->aie_timer.enabled)\r\nctrl |= RV8803_CTRL_AIE;\r\n} else {\r\nif (!rv8803->rtc->uie_rtctimer.enabled)\r\nctrl &= ~RV8803_CTRL_UIE;\r\nif (!rv8803->rtc->aie_timer.enabled)\r\nctrl &= ~RV8803_CTRL_AIE;\r\n}\r\nmutex_lock(&rv8803->flags_lock);\r\nflags = i2c_smbus_read_byte_data(client, RV8803_FLAG);\r\nif (flags < 0) {\r\nmutex_unlock(&rv8803->flags_lock);\r\nreturn flags;\r\n}\r\nflags &= ~(RV8803_FLAG_AF | RV8803_FLAG_UF);\r\nerr = i2c_smbus_write_byte_data(client, RV8803_FLAG, flags);\r\nmutex_unlock(&rv8803->flags_lock);\r\nif (err)\r\nreturn err;\r\nif (ctrl != rv8803->ctrl) {\r\nrv8803->ctrl = ctrl;\r\nerr = i2c_smbus_write_byte_data(client, RV8803_CTRL,\r\nrv8803->ctrl);\r\nif (err)\r\nreturn err;\r\n}\r\nreturn 0;\r\n}\r\nstatic int rv8803_ioctl(struct device *dev, unsigned int cmd, unsigned long arg)\r\n{\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nstruct rv8803_data *rv8803 = dev_get_drvdata(dev);\r\nint flags, ret = 0;\r\nswitch (cmd) {\r\ncase RTC_VL_READ:\r\nflags = i2c_smbus_read_byte_data(client, RV8803_FLAG);\r\nif (flags < 0)\r\nreturn flags;\r\nif (flags & RV8803_FLAG_V1F)\r\ndev_warn(&client->dev, "Voltage low, temperature compensation stopped.\n");\r\nif (flags & RV8803_FLAG_V2F)\r\ndev_warn(&client->dev, "Voltage low, data loss detected.\n");\r\nflags &= RV8803_FLAG_V1F | RV8803_FLAG_V2F;\r\nif (copy_to_user((void __user *)arg, &flags, sizeof(int)))\r\nreturn -EFAULT;\r\nreturn 0;\r\ncase RTC_VL_CLR:\r\nmutex_lock(&rv8803->flags_lock);\r\nflags = i2c_smbus_read_byte_data(client, RV8803_FLAG);\r\nif (flags < 0) {\r\nmutex_unlock(&rv8803->flags_lock);\r\nreturn flags;\r\n}\r\nflags &= ~(RV8803_FLAG_V1F | RV8803_FLAG_V2F);\r\nret = i2c_smbus_write_byte_data(client, RV8803_FLAG, flags);\r\nmutex_unlock(&rv8803->flags_lock);\r\nif (ret < 0)\r\nreturn ret;\r\nreturn 0;\r\ndefault:\r\nreturn -ENOIOCTLCMD;\r\n}\r\n}\r\nstatic ssize_t rv8803_nvram_write(struct file *filp, struct kobject *kobj,\r\nstruct bin_attribute *attr,\r\nchar *buf, loff_t off, size_t count)\r\n{\r\nstruct device *dev = kobj_to_dev(kobj);\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nint ret;\r\nret = i2c_smbus_write_byte_data(client, RV8803_RAM, buf[0]);\r\nif (ret < 0)\r\nreturn ret;\r\nreturn 1;\r\n}\r\nstatic ssize_t rv8803_nvram_read(struct file *filp, struct kobject *kobj,\r\nstruct bin_attribute *attr,\r\nchar *buf, loff_t off, size_t count)\r\n{\r\nstruct device *dev = kobj_to_dev(kobj);\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nint ret;\r\nret = i2c_smbus_read_byte_data(client, RV8803_RAM);\r\nif (ret < 0)\r\nreturn ret;\r\nbuf[0] = ret;\r\nreturn 1;\r\n}\r\nstatic int rv8803_probe(struct i2c_client *client,\r\nconst struct i2c_device_id *id)\r\n{\r\nstruct i2c_adapter *adapter = to_i2c_adapter(client->dev.parent);\r\nstruct rv8803_data *rv8803;\r\nint err, flags, try = 0;\r\nif (!i2c_check_functionality(adapter, I2C_FUNC_SMBUS_BYTE_DATA |\r\nI2C_FUNC_SMBUS_I2C_BLOCK)) {\r\ndev_err(&adapter->dev, "doesn't support I2C_FUNC_SMBUS_BYTE_DATA | I2C_FUNC_SMBUS_I2C_BLOCK\n");\r\nreturn -EIO;\r\n}\r\nrv8803 = devm_kzalloc(&client->dev, sizeof(struct rv8803_data),\r\nGFP_KERNEL);\r\nif (!rv8803)\r\nreturn -ENOMEM;\r\nmutex_init(&rv8803->flags_lock);\r\nrv8803->client = client;\r\ni2c_set_clientdata(client, rv8803);\r\ndo {\r\nflags = i2c_smbus_read_byte_data(client, RV8803_FLAG);\r\ntry++;\r\n} while ((flags == -ENXIO) && (try < 3));\r\nif (flags < 0)\r\nreturn flags;\r\nif (flags & RV8803_FLAG_V1F)\r\ndev_warn(&client->dev, "Voltage low, temperature compensation stopped.\n");\r\nif (flags & RV8803_FLAG_V2F)\r\ndev_warn(&client->dev, "Voltage low, data loss detected.\n");\r\nif (flags & RV8803_FLAG_AF)\r\ndev_warn(&client->dev, "An alarm maybe have been missed.\n");\r\nif (client->irq > 0) {\r\nerr = devm_request_threaded_irq(&client->dev, client->irq,\r\nNULL, rv8803_handle_irq,\r\nIRQF_TRIGGER_LOW | IRQF_ONESHOT,\r\n"rv8803", client);\r\nif (err) {\r\ndev_warn(&client->dev, "unable to request IRQ, alarms disabled\n");\r\nclient->irq = 0;\r\n} else {\r\nrv8803_rtc_ops.read_alarm = rv8803_get_alarm;\r\nrv8803_rtc_ops.set_alarm = rv8803_set_alarm;\r\nrv8803_rtc_ops.alarm_irq_enable = rv8803_alarm_irq_enable;\r\n}\r\n}\r\nrv8803->rtc = devm_rtc_device_register(&client->dev, client->name,\r\n&rv8803_rtc_ops, THIS_MODULE);\r\nif (IS_ERR(rv8803->rtc)) {\r\ndev_err(&client->dev, "unable to register the class device\n");\r\nreturn PTR_ERR(rv8803->rtc);\r\n}\r\ntry = 0;\r\ndo {\r\nerr = i2c_smbus_write_byte_data(rv8803->client, RV8803_EXT,\r\nRV8803_EXT_WADA);\r\ntry++;\r\n} while ((err == -ENXIO) && (try < 3));\r\nif (err)\r\nreturn err;\r\nerr = device_create_bin_file(&client->dev, &rv8803_nvram_attr);\r\nif (err)\r\nreturn err;\r\nrv8803->rtc->max_user_freq = 1;\r\nreturn 0;\r\n}\r\nstatic int rv8803_remove(struct i2c_client *client)\r\n{\r\ndevice_remove_bin_file(&client->dev, &rv8803_nvram_attr);\r\nreturn 0;\r\n}
