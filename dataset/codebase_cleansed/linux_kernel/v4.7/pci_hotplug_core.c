static ssize_t power_read_file(struct pci_slot *pci_slot, char *buf)\r\n{\r\nint retval;\r\nu8 value;\r\nretval = get_power_status(pci_slot->hotplug, &value);\r\nif (retval)\r\nreturn retval;\r\nreturn sprintf(buf, "%d\n", value);\r\n}\r\nstatic ssize_t power_write_file(struct pci_slot *pci_slot, const char *buf,\r\nsize_t count)\r\n{\r\nstruct hotplug_slot *slot = pci_slot->hotplug;\r\nunsigned long lpower;\r\nu8 power;\r\nint retval = 0;\r\nlpower = simple_strtoul(buf, NULL, 10);\r\npower = (u8)(lpower & 0xff);\r\ndbg("power = %d\n", power);\r\nif (!try_module_get(slot->ops->owner)) {\r\nretval = -ENODEV;\r\ngoto exit;\r\n}\r\nswitch (power) {\r\ncase 0:\r\nif (slot->ops->disable_slot)\r\nretval = slot->ops->disable_slot(slot);\r\nbreak;\r\ncase 1:\r\nif (slot->ops->enable_slot)\r\nretval = slot->ops->enable_slot(slot);\r\nbreak;\r\ndefault:\r\nerr("Illegal value specified for power\n");\r\nretval = -EINVAL;\r\n}\r\nmodule_put(slot->ops->owner);\r\nexit:\r\nif (retval)\r\nreturn retval;\r\nreturn count;\r\n}\r\nstatic ssize_t attention_read_file(struct pci_slot *pci_slot, char *buf)\r\n{\r\nint retval;\r\nu8 value;\r\nretval = get_attention_status(pci_slot->hotplug, &value);\r\nif (retval)\r\nreturn retval;\r\nreturn sprintf(buf, "%d\n", value);\r\n}\r\nstatic ssize_t attention_write_file(struct pci_slot *pci_slot, const char *buf,\r\nsize_t count)\r\n{\r\nstruct hotplug_slot_ops *ops = pci_slot->hotplug->ops;\r\nunsigned long lattention;\r\nu8 attention;\r\nint retval = 0;\r\nlattention = simple_strtoul(buf, NULL, 10);\r\nattention = (u8)(lattention & 0xff);\r\ndbg(" - attention = %d\n", attention);\r\nif (!try_module_get(ops->owner)) {\r\nretval = -ENODEV;\r\ngoto exit;\r\n}\r\nif (ops->set_attention_status)\r\nretval = ops->set_attention_status(pci_slot->hotplug, attention);\r\nmodule_put(ops->owner);\r\nexit:\r\nif (retval)\r\nreturn retval;\r\nreturn count;\r\n}\r\nstatic ssize_t latch_read_file(struct pci_slot *pci_slot, char *buf)\r\n{\r\nint retval;\r\nu8 value;\r\nretval = get_latch_status(pci_slot->hotplug, &value);\r\nif (retval)\r\nreturn retval;\r\nreturn sprintf(buf, "%d\n", value);\r\n}\r\nstatic ssize_t presence_read_file(struct pci_slot *pci_slot, char *buf)\r\n{\r\nint retval;\r\nu8 value;\r\nretval = get_adapter_status(pci_slot->hotplug, &value);\r\nif (retval)\r\nreturn retval;\r\nreturn sprintf(buf, "%d\n", value);\r\n}\r\nstatic ssize_t test_write_file(struct pci_slot *pci_slot, const char *buf,\r\nsize_t count)\r\n{\r\nstruct hotplug_slot *slot = pci_slot->hotplug;\r\nunsigned long ltest;\r\nu32 test;\r\nint retval = 0;\r\nltest = simple_strtoul(buf, NULL, 10);\r\ntest = (u32)(ltest & 0xffffffff);\r\ndbg("test = %d\n", test);\r\nif (!try_module_get(slot->ops->owner)) {\r\nretval = -ENODEV;\r\ngoto exit;\r\n}\r\nif (slot->ops->hardware_test)\r\nretval = slot->ops->hardware_test(slot, test);\r\nmodule_put(slot->ops->owner);\r\nexit:\r\nif (retval)\r\nreturn retval;\r\nreturn count;\r\n}\r\nstatic bool has_power_file(struct pci_slot *pci_slot)\r\n{\r\nstruct hotplug_slot *slot = pci_slot->hotplug;\r\nif ((!slot) || (!slot->ops))\r\nreturn false;\r\nif ((slot->ops->enable_slot) ||\r\n(slot->ops->disable_slot) ||\r\n(slot->ops->get_power_status))\r\nreturn true;\r\nreturn false;\r\n}\r\nstatic bool has_attention_file(struct pci_slot *pci_slot)\r\n{\r\nstruct hotplug_slot *slot = pci_slot->hotplug;\r\nif ((!slot) || (!slot->ops))\r\nreturn false;\r\nif ((slot->ops->set_attention_status) ||\r\n(slot->ops->get_attention_status))\r\nreturn true;\r\nreturn false;\r\n}\r\nstatic bool has_latch_file(struct pci_slot *pci_slot)\r\n{\r\nstruct hotplug_slot *slot = pci_slot->hotplug;\r\nif ((!slot) || (!slot->ops))\r\nreturn false;\r\nif (slot->ops->get_latch_status)\r\nreturn true;\r\nreturn false;\r\n}\r\nstatic bool has_adapter_file(struct pci_slot *pci_slot)\r\n{\r\nstruct hotplug_slot *slot = pci_slot->hotplug;\r\nif ((!slot) || (!slot->ops))\r\nreturn false;\r\nif (slot->ops->get_adapter_status)\r\nreturn true;\r\nreturn false;\r\n}\r\nstatic bool has_test_file(struct pci_slot *pci_slot)\r\n{\r\nstruct hotplug_slot *slot = pci_slot->hotplug;\r\nif ((!slot) || (!slot->ops))\r\nreturn false;\r\nif (slot->ops->hardware_test)\r\nreturn true;\r\nreturn false;\r\n}\r\nstatic int fs_add_slot(struct pci_slot *pci_slot)\r\n{\r\nint retval = 0;\r\npci_hp_create_module_link(pci_slot);\r\nif (has_power_file(pci_slot)) {\r\nretval = sysfs_create_file(&pci_slot->kobj,\r\n&hotplug_slot_attr_power.attr);\r\nif (retval)\r\ngoto exit_power;\r\n}\r\nif (has_attention_file(pci_slot)) {\r\nretval = sysfs_create_file(&pci_slot->kobj,\r\n&hotplug_slot_attr_attention.attr);\r\nif (retval)\r\ngoto exit_attention;\r\n}\r\nif (has_latch_file(pci_slot)) {\r\nretval = sysfs_create_file(&pci_slot->kobj,\r\n&hotplug_slot_attr_latch.attr);\r\nif (retval)\r\ngoto exit_latch;\r\n}\r\nif (has_adapter_file(pci_slot)) {\r\nretval = sysfs_create_file(&pci_slot->kobj,\r\n&hotplug_slot_attr_presence.attr);\r\nif (retval)\r\ngoto exit_adapter;\r\n}\r\nif (has_test_file(pci_slot)) {\r\nretval = sysfs_create_file(&pci_slot->kobj,\r\n&hotplug_slot_attr_test.attr);\r\nif (retval)\r\ngoto exit_test;\r\n}\r\ngoto exit;\r\nexit_test:\r\nif (has_adapter_file(pci_slot))\r\nsysfs_remove_file(&pci_slot->kobj,\r\n&hotplug_slot_attr_presence.attr);\r\nexit_adapter:\r\nif (has_latch_file(pci_slot))\r\nsysfs_remove_file(&pci_slot->kobj, &hotplug_slot_attr_latch.attr);\r\nexit_latch:\r\nif (has_attention_file(pci_slot))\r\nsysfs_remove_file(&pci_slot->kobj,\r\n&hotplug_slot_attr_attention.attr);\r\nexit_attention:\r\nif (has_power_file(pci_slot))\r\nsysfs_remove_file(&pci_slot->kobj, &hotplug_slot_attr_power.attr);\r\nexit_power:\r\npci_hp_remove_module_link(pci_slot);\r\nexit:\r\nreturn retval;\r\n}\r\nstatic void fs_remove_slot(struct pci_slot *pci_slot)\r\n{\r\nif (has_power_file(pci_slot))\r\nsysfs_remove_file(&pci_slot->kobj, &hotplug_slot_attr_power.attr);\r\nif (has_attention_file(pci_slot))\r\nsysfs_remove_file(&pci_slot->kobj,\r\n&hotplug_slot_attr_attention.attr);\r\nif (has_latch_file(pci_slot))\r\nsysfs_remove_file(&pci_slot->kobj, &hotplug_slot_attr_latch.attr);\r\nif (has_adapter_file(pci_slot))\r\nsysfs_remove_file(&pci_slot->kobj,\r\n&hotplug_slot_attr_presence.attr);\r\nif (has_test_file(pci_slot))\r\nsysfs_remove_file(&pci_slot->kobj, &hotplug_slot_attr_test.attr);\r\npci_hp_remove_module_link(pci_slot);\r\n}\r\nstatic struct hotplug_slot *get_slot_from_name(const char *name)\r\n{\r\nstruct hotplug_slot *slot;\r\nlist_for_each_entry(slot, &pci_hotplug_slot_list, slot_list) {\r\nif (strcmp(hotplug_slot_name(slot), name) == 0)\r\nreturn slot;\r\n}\r\nreturn NULL;\r\n}\r\nint __pci_hp_register(struct hotplug_slot *slot, struct pci_bus *bus,\r\nint devnr, const char *name,\r\nstruct module *owner, const char *mod_name)\r\n{\r\nint result;\r\nstruct pci_slot *pci_slot;\r\nif (slot == NULL)\r\nreturn -ENODEV;\r\nif ((slot->info == NULL) || (slot->ops == NULL))\r\nreturn -EINVAL;\r\nif (slot->release == NULL) {\r\ndbg("Why are you trying to register a hotplug slot without a proper release function?\n");\r\nreturn -EINVAL;\r\n}\r\nslot->ops->owner = owner;\r\nslot->ops->mod_name = mod_name;\r\nmutex_lock(&pci_hp_mutex);\r\npci_slot = pci_create_slot(bus, devnr, name, slot);\r\nif (IS_ERR(pci_slot)) {\r\nresult = PTR_ERR(pci_slot);\r\ngoto out;\r\n}\r\nslot->pci_slot = pci_slot;\r\npci_slot->hotplug = slot;\r\nlist_add(&slot->slot_list, &pci_hotplug_slot_list);\r\nresult = fs_add_slot(pci_slot);\r\nkobject_uevent(&pci_slot->kobj, KOBJ_ADD);\r\ndbg("Added slot %s to the list\n", name);\r\nout:\r\nmutex_unlock(&pci_hp_mutex);\r\nreturn result;\r\n}\r\nint pci_hp_deregister(struct hotplug_slot *slot)\r\n{\r\nstruct hotplug_slot *temp;\r\nstruct pci_slot *pci_slot;\r\nif (!slot)\r\nreturn -ENODEV;\r\nmutex_lock(&pci_hp_mutex);\r\ntemp = get_slot_from_name(hotplug_slot_name(slot));\r\nif (temp != slot) {\r\nmutex_unlock(&pci_hp_mutex);\r\nreturn -ENODEV;\r\n}\r\nlist_del(&slot->slot_list);\r\npci_slot = slot->pci_slot;\r\nfs_remove_slot(pci_slot);\r\ndbg("Removed slot %s from the list\n", hotplug_slot_name(slot));\r\nslot->release(slot);\r\npci_slot->hotplug = NULL;\r\npci_destroy_slot(pci_slot);\r\nmutex_unlock(&pci_hp_mutex);\r\nreturn 0;\r\n}\r\nint pci_hp_change_slot_info(struct hotplug_slot *slot,\r\nstruct hotplug_slot_info *info)\r\n{\r\nif (!slot || !info)\r\nreturn -ENODEV;\r\nmemcpy(slot->info, info, sizeof(struct hotplug_slot_info));\r\nreturn 0;\r\n}\r\nstatic int __init pci_hotplug_init(void)\r\n{\r\nint result;\r\nresult = cpci_hotplug_init(debug);\r\nif (result) {\r\nerr("cpci_hotplug_init with error %d\n", result);\r\nreturn result;\r\n}\r\ninfo(DRIVER_DESC " version: " DRIVER_VERSION "\n");\r\nreturn result;\r\n}\r\nstatic void __exit pci_hotplug_exit(void)\r\n{\r\ncpci_hotplug_exit();\r\n}
