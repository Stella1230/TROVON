static void derive_crypt_complete(struct crypto_async_request *req, int rc)\r\n{\r\nstruct ext4_completion_result *ecr = req->data;\r\nif (rc == -EINPROGRESS)\r\nreturn;\r\necr->res = rc;\r\ncomplete(&ecr->completion);\r\n}\r\nstatic int ext4_derive_key_aes(char deriving_key[EXT4_AES_128_ECB_KEY_SIZE],\r\nchar source_key[EXT4_AES_256_XTS_KEY_SIZE],\r\nchar derived_key[EXT4_AES_256_XTS_KEY_SIZE])\r\n{\r\nint res = 0;\r\nstruct skcipher_request *req = NULL;\r\nDECLARE_EXT4_COMPLETION_RESULT(ecr);\r\nstruct scatterlist src_sg, dst_sg;\r\nstruct crypto_skcipher *tfm = crypto_alloc_skcipher("ecb(aes)", 0, 0);\r\nif (IS_ERR(tfm)) {\r\nres = PTR_ERR(tfm);\r\ntfm = NULL;\r\ngoto out;\r\n}\r\ncrypto_skcipher_set_flags(tfm, CRYPTO_TFM_REQ_WEAK_KEY);\r\nreq = skcipher_request_alloc(tfm, GFP_NOFS);\r\nif (!req) {\r\nres = -ENOMEM;\r\ngoto out;\r\n}\r\nskcipher_request_set_callback(req,\r\nCRYPTO_TFM_REQ_MAY_BACKLOG | CRYPTO_TFM_REQ_MAY_SLEEP,\r\nderive_crypt_complete, &ecr);\r\nres = crypto_skcipher_setkey(tfm, deriving_key,\r\nEXT4_AES_128_ECB_KEY_SIZE);\r\nif (res < 0)\r\ngoto out;\r\nsg_init_one(&src_sg, source_key, EXT4_AES_256_XTS_KEY_SIZE);\r\nsg_init_one(&dst_sg, derived_key, EXT4_AES_256_XTS_KEY_SIZE);\r\nskcipher_request_set_crypt(req, &src_sg, &dst_sg,\r\nEXT4_AES_256_XTS_KEY_SIZE, NULL);\r\nres = crypto_skcipher_encrypt(req);\r\nif (res == -EINPROGRESS || res == -EBUSY) {\r\nwait_for_completion(&ecr.completion);\r\nres = ecr.res;\r\n}\r\nout:\r\nskcipher_request_free(req);\r\ncrypto_free_skcipher(tfm);\r\nreturn res;\r\n}\r\nvoid ext4_free_crypt_info(struct ext4_crypt_info *ci)\r\n{\r\nif (!ci)\r\nreturn;\r\nif (ci->ci_keyring_key)\r\nkey_put(ci->ci_keyring_key);\r\ncrypto_free_skcipher(ci->ci_ctfm);\r\nkmem_cache_free(ext4_crypt_info_cachep, ci);\r\n}\r\nvoid ext4_free_encryption_info(struct inode *inode,\r\nstruct ext4_crypt_info *ci)\r\n{\r\nstruct ext4_inode_info *ei = EXT4_I(inode);\r\nstruct ext4_crypt_info *prev;\r\nif (ci == NULL)\r\nci = ACCESS_ONCE(ei->i_crypt_info);\r\nif (ci == NULL)\r\nreturn;\r\nprev = cmpxchg(&ei->i_crypt_info, ci, NULL);\r\nif (prev != ci)\r\nreturn;\r\next4_free_crypt_info(ci);\r\n}\r\nint _ext4_get_encryption_info(struct inode *inode)\r\n{\r\nstruct ext4_inode_info *ei = EXT4_I(inode);\r\nstruct ext4_crypt_info *crypt_info;\r\nchar full_key_descriptor[EXT4_KEY_DESC_PREFIX_SIZE +\r\n(EXT4_KEY_DESCRIPTOR_SIZE * 2) + 1];\r\nstruct key *keyring_key = NULL;\r\nstruct ext4_encryption_key *master_key;\r\nstruct ext4_encryption_context ctx;\r\nconst struct user_key_payload *ukp;\r\nstruct ext4_sb_info *sbi = EXT4_SB(inode->i_sb);\r\nstruct crypto_skcipher *ctfm;\r\nconst char *cipher_str;\r\nchar raw_key[EXT4_MAX_KEY_SIZE];\r\nchar mode;\r\nint res;\r\nif (!ext4_read_workqueue) {\r\nres = ext4_init_crypto();\r\nif (res)\r\nreturn res;\r\n}\r\nretry:\r\ncrypt_info = ACCESS_ONCE(ei->i_crypt_info);\r\nif (crypt_info) {\r\nif (!crypt_info->ci_keyring_key ||\r\nkey_validate(crypt_info->ci_keyring_key) == 0)\r\nreturn 0;\r\next4_free_encryption_info(inode, crypt_info);\r\ngoto retry;\r\n}\r\nres = ext4_xattr_get(inode, EXT4_XATTR_INDEX_ENCRYPTION,\r\nEXT4_XATTR_NAME_ENCRYPTION_CONTEXT,\r\n&ctx, sizeof(ctx));\r\nif (res < 0) {\r\nif (!DUMMY_ENCRYPTION_ENABLED(sbi))\r\nreturn res;\r\nctx.contents_encryption_mode = EXT4_ENCRYPTION_MODE_AES_256_XTS;\r\nctx.filenames_encryption_mode =\r\nEXT4_ENCRYPTION_MODE_AES_256_CTS;\r\nctx.flags = 0;\r\n} else if (res != sizeof(ctx))\r\nreturn -EINVAL;\r\nres = 0;\r\ncrypt_info = kmem_cache_alloc(ext4_crypt_info_cachep, GFP_KERNEL);\r\nif (!crypt_info)\r\nreturn -ENOMEM;\r\ncrypt_info->ci_flags = ctx.flags;\r\ncrypt_info->ci_data_mode = ctx.contents_encryption_mode;\r\ncrypt_info->ci_filename_mode = ctx.filenames_encryption_mode;\r\ncrypt_info->ci_ctfm = NULL;\r\ncrypt_info->ci_keyring_key = NULL;\r\nmemcpy(crypt_info->ci_master_key, ctx.master_key_descriptor,\r\nsizeof(crypt_info->ci_master_key));\r\nif (S_ISREG(inode->i_mode))\r\nmode = crypt_info->ci_data_mode;\r\nelse if (S_ISDIR(inode->i_mode) || S_ISLNK(inode->i_mode))\r\nmode = crypt_info->ci_filename_mode;\r\nelse\r\nBUG();\r\nswitch (mode) {\r\ncase EXT4_ENCRYPTION_MODE_AES_256_XTS:\r\ncipher_str = "xts(aes)";\r\nbreak;\r\ncase EXT4_ENCRYPTION_MODE_AES_256_CTS:\r\ncipher_str = "cts(cbc(aes))";\r\nbreak;\r\ndefault:\r\nprintk_once(KERN_WARNING\r\n"ext4: unsupported key mode %d (ino %u)\n",\r\nmode, (unsigned) inode->i_ino);\r\nres = -ENOKEY;\r\ngoto out;\r\n}\r\nif (DUMMY_ENCRYPTION_ENABLED(sbi)) {\r\nmemset(raw_key, 0x42, EXT4_AES_256_XTS_KEY_SIZE);\r\ngoto got_key;\r\n}\r\nmemcpy(full_key_descriptor, EXT4_KEY_DESC_PREFIX,\r\nEXT4_KEY_DESC_PREFIX_SIZE);\r\nsprintf(full_key_descriptor + EXT4_KEY_DESC_PREFIX_SIZE,\r\n"%*phN", EXT4_KEY_DESCRIPTOR_SIZE,\r\nctx.master_key_descriptor);\r\nfull_key_descriptor[EXT4_KEY_DESC_PREFIX_SIZE +\r\n(2 * EXT4_KEY_DESCRIPTOR_SIZE)] = '\0';\r\nkeyring_key = request_key(&key_type_logon, full_key_descriptor, NULL);\r\nif (IS_ERR(keyring_key)) {\r\nres = PTR_ERR(keyring_key);\r\nkeyring_key = NULL;\r\ngoto out;\r\n}\r\ncrypt_info->ci_keyring_key = keyring_key;\r\nif (keyring_key->type != &key_type_logon) {\r\nprintk_once(KERN_WARNING\r\n"ext4: key type must be logon\n");\r\nres = -ENOKEY;\r\ngoto out;\r\n}\r\ndown_read(&keyring_key->sem);\r\nukp = user_key_payload(keyring_key);\r\nif (ukp->datalen != sizeof(struct ext4_encryption_key)) {\r\nres = -EINVAL;\r\nup_read(&keyring_key->sem);\r\ngoto out;\r\n}\r\nmaster_key = (struct ext4_encryption_key *)ukp->data;\r\nBUILD_BUG_ON(EXT4_AES_128_ECB_KEY_SIZE !=\r\nEXT4_KEY_DERIVATION_NONCE_SIZE);\r\nif (master_key->size != EXT4_AES_256_XTS_KEY_SIZE) {\r\nprintk_once(KERN_WARNING\r\n"ext4: key size incorrect: %d\n",\r\nmaster_key->size);\r\nres = -ENOKEY;\r\nup_read(&keyring_key->sem);\r\ngoto out;\r\n}\r\nres = ext4_derive_key_aes(ctx.nonce, master_key->raw,\r\nraw_key);\r\nup_read(&keyring_key->sem);\r\nif (res)\r\ngoto out;\r\ngot_key:\r\nctfm = crypto_alloc_skcipher(cipher_str, 0, 0);\r\nif (!ctfm || IS_ERR(ctfm)) {\r\nres = ctfm ? PTR_ERR(ctfm) : -ENOMEM;\r\nprintk(KERN_DEBUG\r\n"%s: error %d (inode %u) allocating crypto tfm\n",\r\n__func__, res, (unsigned) inode->i_ino);\r\ngoto out;\r\n}\r\ncrypt_info->ci_ctfm = ctfm;\r\ncrypto_skcipher_clear_flags(ctfm, ~0);\r\ncrypto_tfm_set_flags(crypto_skcipher_tfm(ctfm),\r\nCRYPTO_TFM_REQ_WEAK_KEY);\r\nres = crypto_skcipher_setkey(ctfm, raw_key,\r\next4_encryption_key_size(mode));\r\nif (res)\r\ngoto out;\r\nmemzero_explicit(raw_key, sizeof(raw_key));\r\nif (cmpxchg(&ei->i_crypt_info, NULL, crypt_info) != NULL) {\r\next4_free_crypt_info(crypt_info);\r\ngoto retry;\r\n}\r\nreturn 0;\r\nout:\r\nif (res == -ENOKEY)\r\nres = 0;\r\next4_free_crypt_info(crypt_info);\r\nmemzero_explicit(raw_key, sizeof(raw_key));\r\nreturn res;\r\n}\r\nint ext4_has_encryption_key(struct inode *inode)\r\n{\r\nstruct ext4_inode_info *ei = EXT4_I(inode);\r\nreturn (ei->i_crypt_info != NULL);\r\n}
