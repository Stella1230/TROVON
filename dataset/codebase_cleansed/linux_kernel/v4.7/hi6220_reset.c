static int hi6220_reset_assert(struct reset_controller_dev *rc_dev,\r\nunsigned long idx)\r\n{\r\nstruct hi6220_reset_data *data = to_reset_data(rc_dev);\r\nint bank = idx >> 8;\r\nint offset = idx & 0xff;\r\nwritel(BIT(offset), data->assert_base + (bank * 0x10));\r\nreturn 0;\r\n}\r\nstatic int hi6220_reset_deassert(struct reset_controller_dev *rc_dev,\r\nunsigned long idx)\r\n{\r\nstruct hi6220_reset_data *data = to_reset_data(rc_dev);\r\nint bank = idx >> 8;\r\nint offset = idx & 0xff;\r\nwritel(BIT(offset), data->deassert_base + (bank * 0x10));\r\nreturn 0;\r\n}\r\nstatic int hi6220_reset_probe(struct platform_device *pdev)\r\n{\r\nstruct hi6220_reset_data *data;\r\nstruct resource *res;\r\nvoid __iomem *src_base;\r\ndata = devm_kzalloc(&pdev->dev, sizeof(*data), GFP_KERNEL);\r\nif (!data)\r\nreturn -ENOMEM;\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nsrc_base = devm_ioremap_resource(&pdev->dev, res);\r\nif (IS_ERR(src_base))\r\nreturn PTR_ERR(src_base);\r\ndata->assert_base = src_base + ASSERT_OFFSET;\r\ndata->deassert_base = src_base + DEASSERT_OFFSET;\r\ndata->rc_dev.nr_resets = MAX_INDEX;\r\ndata->rc_dev.ops = &hi6220_reset_ops;\r\ndata->rc_dev.of_node = pdev->dev.of_node;\r\nreturn reset_controller_register(&data->rc_dev);\r\n}\r\nstatic int __init hi6220_reset_init(void)\r\n{\r\nreturn platform_driver_register(&hi6220_reset_driver);\r\n}
