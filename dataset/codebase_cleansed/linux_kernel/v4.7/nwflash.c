static int get_flash_id(void)\r\n{\r\nvolatile unsigned int c1, c2;\r\nkick_open();\r\nc2 = inb(0x80);\r\n*(volatile unsigned char *) (FLASH_BASE + 0x8000) = 0x90;\r\nudelay(15);\r\nc1 = *(volatile unsigned char *) FLASH_BASE;\r\nc2 = inb(0x80);\r\nif (c1 == 0xB0)\r\nc2 = *(volatile unsigned char *) (FLASH_BASE + 2);\r\nelse\r\nc2 = *(volatile unsigned char *) (FLASH_BASE + 1);\r\nc2 += (c1 << 8);\r\n*(volatile unsigned char *) (FLASH_BASE + 0x8000) = 0xFF;\r\nif (c2 == KFLASH_ID4)\r\ngbFlashSize = KFLASH_SIZE4;\r\nreturn c2;\r\n}\r\nstatic long flash_ioctl(struct file *filep, unsigned int cmd, unsigned long arg)\r\n{\r\nmutex_lock(&flash_mutex);\r\nswitch (cmd) {\r\ncase CMD_WRITE_DISABLE:\r\ngbWriteBase64Enable = 0;\r\ngbWriteEnable = 0;\r\nbreak;\r\ncase CMD_WRITE_ENABLE:\r\ngbWriteEnable = 1;\r\nbreak;\r\ncase CMD_WRITE_BASE64K_ENABLE:\r\ngbWriteBase64Enable = 1;\r\nbreak;\r\ndefault:\r\ngbWriteBase64Enable = 0;\r\ngbWriteEnable = 0;\r\nmutex_unlock(&flash_mutex);\r\nreturn -EINVAL;\r\n}\r\nmutex_unlock(&flash_mutex);\r\nreturn 0;\r\n}\r\nstatic ssize_t flash_read(struct file *file, char __user *buf, size_t size,\r\nloff_t *ppos)\r\n{\r\nssize_t ret;\r\nif (flashdebug)\r\nprintk(KERN_DEBUG "flash_read: flash_read: offset=0x%llx, "\r\n"buffer=%p, count=0x%zx.\n", *ppos, buf, size);\r\nif (mutex_lock_interruptible(&nwflash_mutex))\r\nreturn -ERESTARTSYS;\r\nret = simple_read_from_buffer(buf, size, ppos, (void *)FLASH_BASE, gbFlashSize);\r\nmutex_unlock(&nwflash_mutex);\r\nreturn ret;\r\n}\r\nstatic ssize_t flash_write(struct file *file, const char __user *buf,\r\nsize_t size, loff_t * ppos)\r\n{\r\nunsigned long p = *ppos;\r\nunsigned int count = size;\r\nint written;\r\nint nBlock, temp, rc;\r\nint i, j;\r\nif (flashdebug)\r\nprintk("flash_write: offset=0x%lX, buffer=0x%p, count=0x%X.\n",\r\np, buf, count);\r\nif (!gbWriteEnable)\r\nreturn -EINVAL;\r\nif (p < 64 * 1024 && (!gbWriteBase64Enable))\r\nreturn -EINVAL;\r\nif (p >= gbFlashSize)\r\nreturn count ? -ENXIO : 0;\r\nif (count > gbFlashSize - p)\r\ncount = gbFlashSize - p;\r\nif (!access_ok(VERIFY_READ, buf, count))\r\nreturn -EFAULT;\r\nif (mutex_lock_interruptible(&nwflash_mutex))\r\nreturn -ERESTARTSYS;\r\nwritten = 0;\r\nnBlock = (int) p >> 16;\r\ntemp = ((int) (p + count) >> 16) - nBlock + 1;\r\nif (((int) (p + count) & 0xFFFF) == 0)\r\ntemp -= 1;\r\nif (flashdebug)\r\nprintk(KERN_DEBUG "flash_write: writing %d block(s) "\r\n"starting at %d.\n", temp, nBlock);\r\nfor (; temp; temp--, nBlock++) {\r\nif (flashdebug)\r\nprintk(KERN_DEBUG "flash_write: erasing block %d.\n", nBlock);\r\ni = 0;\r\nj = 0;\r\nRetryBlock:\r\ndo {\r\nrc = erase_block(nBlock);\r\ni++;\r\n} while (rc && i < 10);\r\nif (rc) {\r\nprintk(KERN_ERR "flash_write: erase error %x\n", rc);\r\nbreak;\r\n}\r\nif (flashdebug)\r\nprintk(KERN_DEBUG "flash_write: writing offset %lX, "\r\n"from buf %p, bytes left %X.\n", p, buf,\r\ncount - written);\r\nrc = write_block(p, buf, count - written);\r\nj++;\r\nif (!rc) {\r\nif (j < 10)\r\ngoto RetryBlock;\r\nelse\r\nrc = -1;\r\n}\r\nif (rc < 0) {\r\nprintk(KERN_ERR "flash_write: write error %X\n", rc);\r\nbreak;\r\n}\r\np += rc;\r\nbuf += rc;\r\nwritten += rc;\r\n*ppos += rc;\r\nif (flashdebug)\r\nprintk(KERN_DEBUG "flash_write: written 0x%X bytes OK.\n", written);\r\n}\r\nmutex_unlock(&nwflash_mutex);\r\nreturn written;\r\n}\r\nstatic loff_t flash_llseek(struct file *file, loff_t offset, int orig)\r\n{\r\nloff_t ret;\r\nmutex_lock(&flash_mutex);\r\nif (flashdebug)\r\nprintk(KERN_DEBUG "flash_llseek: offset=0x%X, orig=0x%X.\n",\r\n(unsigned int) offset, orig);\r\nret = no_seek_end_llseek_size(file, offset, orig, gbFlashSize);\r\nmutex_unlock(&flash_mutex);\r\nreturn ret;\r\n}\r\nstatic int erase_block(int nBlock)\r\n{\r\nvolatile unsigned int c1;\r\nvolatile unsigned char *pWritePtr;\r\nunsigned long timeout;\r\nint temp, temp1;\r\n*CSR_ROMWRITEREG = 0;\r\nc1 = *(volatile unsigned char *) (FLASH_BASE + 0x8000);\r\nkick_open();\r\n*(volatile unsigned char *) (FLASH_BASE + 0x8000) = 0x50;\r\npWritePtr = (unsigned char *) ((unsigned int) (FLASH_BASE + 0x8000 + (nBlock << 16)));\r\nc1 = *pWritePtr;\r\nkick_open();\r\n*(volatile unsigned char *) pWritePtr = 0x20;\r\n*(volatile unsigned char *) pWritePtr = 0xD0;\r\nmsleep(10);\r\ntimeout = jiffies + 10 * HZ;\r\nc1 = 0;\r\nwhile (!(c1 & 0x80) && time_before(jiffies, timeout)) {\r\nmsleep(10);\r\nc1 = *(volatile unsigned char *) (pWritePtr);\r\n}\r\nkick_open();\r\n*(volatile unsigned char *) pWritePtr = 0xFF;\r\nif (c1 & 0x20) {\r\nprintk(KERN_ERR "flash_erase: err at %p\n", pWritePtr);\r\n*(volatile unsigned char *) (FLASH_BASE + 0x8000) = 0x50;\r\nreturn -2;\r\n}\r\nmsleep(10);\r\npWritePtr = (unsigned char *) ((unsigned int) (FLASH_BASE + (nBlock << 16)));\r\nfor (temp = 0; temp < 16 * 1024; temp++, pWritePtr += 4) {\r\nif ((temp1 = *(volatile unsigned int *) pWritePtr) != 0xFFFFFFFF) {\r\nprintk(KERN_ERR "flash_erase: verify err at %p = %X\n",\r\npWritePtr, temp1);\r\nreturn -1;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int write_block(unsigned long p, const char __user *buf, int count)\r\n{\r\nvolatile unsigned int c1;\r\nvolatile unsigned int c2;\r\nunsigned char *pWritePtr;\r\nunsigned int uAddress;\r\nunsigned int offset;\r\nunsigned long timeout;\r\nunsigned long timeout1;\r\npWritePtr = (unsigned char *) ((unsigned int) (FLASH_BASE + p));\r\noffset = p & 0xFFFF;\r\nif (offset + count > 0x10000)\r\ncount = 0x10000 - offset;\r\ntimeout = jiffies + 30 * HZ;\r\nfor (offset = 0; offset < count; offset++, pWritePtr++) {\r\nuAddress = (unsigned int) pWritePtr;\r\nuAddress &= 0xFFFFFFFC;\r\nif (__get_user(c2, buf + offset))\r\nreturn -EFAULT;\r\nWriteRetry:\r\nc1 = *(volatile unsigned char *) (FLASH_BASE + 0x8000);\r\nkick_open();\r\n*CSR_ROMWRITEREG = (unsigned int) pWritePtr & 3;\r\n*(volatile unsigned char *) (uAddress) = 0x40;\r\n*(volatile unsigned char *) (uAddress) = c2;\r\n*(volatile unsigned char *) (FLASH_BASE + 0x10000) = 0x70;\r\nc1 = 0;\r\ntimeout1 = jiffies + 1 * HZ;\r\nwhile (!(c1 & 0x80) && time_before(jiffies, timeout1))\r\nc1 = *(volatile unsigned char *) (FLASH_BASE + 0x8000);\r\nif (time_after_eq(jiffies, timeout1)) {\r\nkick_open();\r\n*(volatile unsigned char *) (FLASH_BASE + 0x8000) = 0x50;\r\ngoto WriteRetry;\r\n}\r\nkick_open();\r\n*(volatile unsigned char *) (FLASH_BASE + 0x8000) = 0xFF;\r\nif (c1 & 0x10) {\r\nkick_open();\r\n*(volatile unsigned char *) (FLASH_BASE + 0x8000) = 0x50;\r\nif (time_before(jiffies, timeout)) {\r\nif (flashdebug)\r\nprintk(KERN_DEBUG "write_block: Retrying write at 0x%X)n",\r\npWritePtr - FLASH_BASE);\r\nmsleep(10);\r\ngoto WriteRetry;\r\n} else {\r\nprintk(KERN_ERR "write_block: timeout at 0x%X\n",\r\npWritePtr - FLASH_BASE);\r\nreturn -2;\r\n}\r\n}\r\n}\r\nmsleep(10);\r\npWritePtr = (unsigned char *) ((unsigned int) (FLASH_BASE + p));\r\nfor (offset = 0; offset < count; offset++) {\r\nchar c, c1;\r\nif (__get_user(c, buf))\r\nreturn -EFAULT;\r\nbuf++;\r\nif ((c1 = *pWritePtr++) != c) {\r\nprintk(KERN_ERR "write_block: verify error at 0x%X (%02X!=%02X)\n",\r\npWritePtr - FLASH_BASE, c1, c);\r\nreturn 0;\r\n}\r\n}\r\nreturn count;\r\n}\r\nstatic void kick_open(void)\r\n{\r\nunsigned long flags;\r\nraw_spin_lock_irqsave(&nw_gpio_lock, flags);\r\nnw_cpld_modify(CPLD_FLASH_WR_ENABLE, CPLD_FLASH_WR_ENABLE);\r\nraw_spin_unlock_irqrestore(&nw_gpio_lock, flags);\r\nudelay(25);\r\n}\r\nstatic int __init nwflash_init(void)\r\n{\r\nint ret = -ENODEV;\r\nif (machine_is_netwinder()) {\r\nint id;\r\nFLASH_BASE = ioremap(DC21285_FLASH, KFLASH_SIZE4);\r\nif (!FLASH_BASE)\r\ngoto out;\r\nid = get_flash_id();\r\nif ((id != KFLASH_ID) && (id != KFLASH_ID4)) {\r\nret = -ENXIO;\r\niounmap((void *)FLASH_BASE);\r\nprintk("Flash: incorrect ID 0x%04X.\n", id);\r\ngoto out;\r\n}\r\nprintk("Flash ROM driver v.%s, flash device ID 0x%04X, size %d Mb.\n",\r\nNWFLASH_VERSION, id, gbFlashSize / (1024 * 1024));\r\nret = misc_register(&flash_miscdev);\r\nif (ret < 0) {\r\niounmap((void *)FLASH_BASE);\r\n}\r\n}\r\nout:\r\nreturn ret;\r\n}\r\nstatic void __exit nwflash_exit(void)\r\n{\r\nmisc_deregister(&flash_miscdev);\r\niounmap((void *)FLASH_BASE);\r\n}
