static inline u8 wd719x_readb(struct wd719x *wd, u8 reg)\r\n{\r\nreturn ioread8(wd->base + reg);\r\n}\r\nstatic inline u32 wd719x_readl(struct wd719x *wd, u8 reg)\r\n{\r\nreturn ioread32(wd->base + reg);\r\n}\r\nstatic inline void wd719x_writeb(struct wd719x *wd, u8 reg, u8 val)\r\n{\r\niowrite8(val, wd->base + reg);\r\n}\r\nstatic inline void wd719x_writew(struct wd719x *wd, u8 reg, u16 val)\r\n{\r\niowrite16(val, wd->base + reg);\r\n}\r\nstatic inline void wd719x_writel(struct wd719x *wd, u8 reg, u32 val)\r\n{\r\niowrite32(val, wd->base + reg);\r\n}\r\nstatic inline int wd719x_wait_ready(struct wd719x *wd)\r\n{\r\nint i = 0;\r\ndo {\r\nif (wd719x_readb(wd, WD719X_AMR_COMMAND) == WD719X_CMD_READY)\r\nreturn 0;\r\nudelay(1);\r\n} while (i++ < WD719X_WAIT_FOR_CMD_READY);\r\ndev_err(&wd->pdev->dev, "command register is not ready: 0x%02x\n",\r\nwd719x_readb(wd, WD719X_AMR_COMMAND));\r\nreturn -ETIMEDOUT;\r\n}\r\nstatic inline int wd719x_wait_done(struct wd719x *wd, int timeout)\r\n{\r\nu8 status;\r\nwhile (timeout > 0) {\r\nstatus = wd719x_readb(wd, WD719X_AMR_INT_STATUS);\r\nif (status)\r\nbreak;\r\ntimeout--;\r\nudelay(1);\r\n}\r\nif (timeout <= 0) {\r\ndev_err(&wd->pdev->dev, "direct command timed out\n");\r\nreturn -ETIMEDOUT;\r\n}\r\nif (status != WD719X_INT_NOERRORS) {\r\ndev_err(&wd->pdev->dev, "direct command failed, status 0x%02x, SUE 0x%02x\n",\r\nstatus, wd719x_readb(wd, WD719X_AMR_SCB_ERROR));\r\nreturn -EIO;\r\n}\r\nreturn 0;\r\n}\r\nstatic int wd719x_direct_cmd(struct wd719x *wd, u8 opcode, u8 dev, u8 lun,\r\nu8 tag, dma_addr_t data, int timeout)\r\n{\r\nint ret = 0;\r\nwd719x_writeb(wd, WD719X_AMR_INT_STATUS, WD719X_INT_NONE);\r\nif (wd719x_wait_ready(wd))\r\nreturn -ETIMEDOUT;\r\ndev |= WD719X_DISABLE_INT;\r\nwd719x_writeb(wd, WD719X_AMR_CMD_PARAM, dev);\r\nwd719x_writeb(wd, WD719X_AMR_CMD_PARAM_2, lun);\r\nwd719x_writeb(wd, WD719X_AMR_CMD_PARAM_3, tag);\r\nif (data)\r\nwd719x_writel(wd, WD719X_AMR_SCB_IN, data);\r\nwd719x_writeb(wd, WD719X_AMR_INT_STATUS, WD719X_INT_NONE);\r\nwd719x_writeb(wd, WD719X_AMR_COMMAND, opcode);\r\nif (timeout)\r\nret = wd719x_wait_done(wd, timeout);\r\nif (opcode != WD719X_CMD_READ_FIRMVER)\r\nwd719x_writeb(wd, WD719X_AMR_INT_STATUS, WD719X_INT_NONE);\r\nreturn ret;\r\n}\r\nstatic void wd719x_destroy(struct wd719x *wd)\r\n{\r\nstruct wd719x_scb *scb;\r\nif (wd719x_direct_cmd(wd, WD719X_CMD_SLEEP, 0, 0, 0, 0,\r\nWD719X_WAIT_FOR_RISC))\r\ndev_warn(&wd->pdev->dev, "RISC sleep command failed\n");\r\nwd719x_writeb(wd, WD719X_PCI_MODE_SELECT, 0);\r\nlist_for_each_entry(scb, &wd->active_scbs, list)\r\npci_free_consistent(wd->pdev, sizeof(struct wd719x_scb), scb,\r\nscb->phys);\r\nlist_for_each_entry(scb, &wd->free_scbs, list)\r\npci_free_consistent(wd->pdev, sizeof(struct wd719x_scb), scb,\r\nscb->phys);\r\npci_free_consistent(wd->pdev, wd->fw_size, wd->fw_virt, wd->fw_phys);\r\nwd->fw_virt = NULL;\r\npci_free_consistent(wd->pdev, WD719X_HASH_TABLE_SIZE, wd->hash_virt,\r\nwd->hash_phys);\r\nwd->hash_virt = NULL;\r\npci_free_consistent(wd->pdev, sizeof(struct wd719x_host_param),\r\nwd->params, wd->params_phys);\r\nwd->params = NULL;\r\nfree_irq(wd->pdev->irq, wd);\r\n}\r\nstatic void wd719x_finish_cmd(struct scsi_cmnd *cmd, int result)\r\n{\r\nstruct wd719x *wd = shost_priv(cmd->device->host);\r\nstruct wd719x_scb *scb = (struct wd719x_scb *) cmd->host_scribble;\r\nif (scb) {\r\nlist_move(&scb->list, &wd->free_scbs);\r\ndma_unmap_single(&wd->pdev->dev, cmd->SCp.dma_handle,\r\nSCSI_SENSE_BUFFERSIZE, DMA_FROM_DEVICE);\r\nscsi_dma_unmap(cmd);\r\n}\r\ncmd->result = result << 16;\r\ncmd->scsi_done(cmd);\r\n}\r\nstatic int wd719x_queuecommand(struct Scsi_Host *sh, struct scsi_cmnd *cmd)\r\n{\r\nint i, count_sg;\r\nunsigned long flags;\r\nstruct wd719x_scb *scb;\r\nstruct wd719x *wd = shost_priv(sh);\r\ndma_addr_t phys;\r\ncmd->host_scribble = NULL;\r\nspin_lock_irqsave(wd->sh->host_lock, flags);\r\nscb = list_first_entry_or_null(&wd->free_scbs, struct wd719x_scb, list);\r\nif (scb) {\r\nlist_del(&scb->list);\r\nphys = scb->phys;\r\n} else {\r\nspin_unlock_irqrestore(wd->sh->host_lock, flags);\r\nscb = pci_alloc_consistent(wd->pdev, sizeof(struct wd719x_scb),\r\n&phys);\r\nspin_lock_irqsave(wd->sh->host_lock, flags);\r\nif (!scb) {\r\ndev_err(&wd->pdev->dev, "unable to allocate SCB\n");\r\nwd719x_finish_cmd(cmd, DID_ERROR);\r\nspin_unlock_irqrestore(wd->sh->host_lock, flags);\r\nreturn 0;\r\n}\r\n}\r\nmemset(scb, 0, sizeof(struct wd719x_scb));\r\nlist_add(&scb->list, &wd->active_scbs);\r\nscb->phys = phys;\r\nscb->cmd = cmd;\r\ncmd->host_scribble = (char *) scb;\r\nscb->CDB_tag = 0;\r\nscb->devid = cmd->device->id;\r\nscb->lun = cmd->device->lun;\r\nmemcpy(scb->CDB, cmd->cmnd, cmd->cmd_len);\r\nscb->sense_buf_length = SCSI_SENSE_BUFFERSIZE;\r\ncmd->SCp.dma_handle = dma_map_single(&wd->pdev->dev, cmd->sense_buffer,\r\nSCSI_SENSE_BUFFERSIZE, DMA_FROM_DEVICE);\r\nscb->sense_buf = cpu_to_le32(cmd->SCp.dma_handle);\r\nscb->SCB_options |= WD719X_SCB_FLAGS_AUTO_REQUEST_SENSE;\r\nif (cmd->sc_data_direction == DMA_TO_DEVICE)\r\nscb->SCB_options |= WD719X_SCB_FLAGS_CHECK_DIRECTION\r\n| WD719X_SCB_FLAGS_PCI_TO_SCSI;\r\nelse if (cmd->sc_data_direction == DMA_FROM_DEVICE)\r\nscb->SCB_options |= WD719X_SCB_FLAGS_CHECK_DIRECTION;\r\ncount_sg = scsi_dma_map(cmd);\r\nif (count_sg < 0) {\r\nwd719x_finish_cmd(cmd, DID_ERROR);\r\nspin_unlock_irqrestore(wd->sh->host_lock, flags);\r\nreturn 0;\r\n}\r\nBUG_ON(count_sg > WD719X_SG);\r\nif (count_sg) {\r\nstruct scatterlist *sg;\r\nscb->data_length = cpu_to_le32(count_sg *\r\nsizeof(struct wd719x_sglist));\r\nscb->data_p = cpu_to_le32(scb->phys +\r\noffsetof(struct wd719x_scb, sg_list));\r\nscsi_for_each_sg(cmd, sg, count_sg, i) {\r\nscb->sg_list[i].ptr = cpu_to_le32(sg_dma_address(sg));\r\nscb->sg_list[i].length = cpu_to_le32(sg_dma_len(sg));\r\n}\r\nscb->SCB_options |= WD719X_SCB_FLAGS_DO_SCATTER_GATHER;\r\n} else {\r\nscb->data_length = 0;\r\nscb->data_p = 0;\r\n}\r\nif (wd719x_readb(wd, WD719X_AMR_COMMAND) != WD719X_CMD_READY) {\r\nspin_unlock_irqrestore(wd->sh->host_lock, flags);\r\nreturn SCSI_MLQUEUE_HOST_BUSY;\r\n}\r\nwd719x_writel(wd, WD719X_AMR_SCB_IN, scb->phys);\r\nwd719x_writeb(wd, WD719X_AMR_COMMAND, WD719X_CMD_PROCESS_SCB);\r\nspin_unlock_irqrestore(wd->sh->host_lock, flags);\r\nreturn 0;\r\n}\r\nstatic int wd719x_chip_init(struct wd719x *wd)\r\n{\r\nint i, ret;\r\nu32 risc_init[3];\r\nconst struct firmware *fw_wcs, *fw_risc;\r\nconst char fwname_wcs[] = "wd719x-wcs.bin";\r\nconst char fwname_risc[] = "wd719x-risc.bin";\r\nmemset(wd->hash_virt, 0, WD719X_HASH_TABLE_SIZE);\r\nret = request_firmware(&fw_wcs, fwname_wcs, &wd->pdev->dev);\r\nif (ret) {\r\ndev_err(&wd->pdev->dev, "Unable to load firmware %s: %d\n",\r\nfwname_wcs, ret);\r\nreturn ret;\r\n}\r\nret = request_firmware(&fw_risc, fwname_risc, &wd->pdev->dev);\r\nif (ret) {\r\ndev_err(&wd->pdev->dev, "Unable to load firmware %s: %d\n",\r\nfwname_risc, ret);\r\nrelease_firmware(fw_wcs);\r\nreturn ret;\r\n}\r\nwd->fw_size = ALIGN(fw_wcs->size, 4) + fw_risc->size;\r\nif (!wd->fw_virt)\r\nwd->fw_virt = pci_alloc_consistent(wd->pdev, wd->fw_size,\r\n&wd->fw_phys);\r\nif (!wd->fw_virt) {\r\nret = -ENOMEM;\r\ngoto wd719x_init_end;\r\n}\r\nmemcpy(wd->fw_virt, fw_wcs->data, fw_wcs->size);\r\nmemcpy(wd->fw_virt + ALIGN(fw_wcs->size, 4), fw_risc->data,\r\nfw_risc->size);\r\nwd719x_writeb(wd, WD719X_PCI_PORT_RESET, WD719X_PCI_RESET);\r\nudelay(WD719X_WAIT_FOR_RISC);\r\nwd719x_writeb(wd, WD719X_AMR_CMD_PARAM, 0);\r\nwd719x_writeb(wd, WD719X_PCI_MODE_SELECT, 0);\r\nwd719x_writeb(wd, WD719X_AMR_COMMAND, 0);\r\nif (wd719x_wait_ready(wd)) {\r\nret = -ETIMEDOUT;\r\ngoto wd719x_init_end;\r\n}\r\nrisc_init[0] = wd->fw_phys;\r\nrisc_init[1] = wd->fw_phys + ALIGN(fw_wcs->size, 4);\r\nrisc_init[2] = wd->hash_phys;\r\nwd719x_writeb(wd, WD719X_PCI_CHANNEL2_3STATUS, 0);\r\nwd719x_writel(wd, WD719X_PCI_EXTERNAL_ADDR, risc_init[1]);\r\nwd719x_writew(wd, WD719X_PCI_INTERNAL_ADDR, WD719X_PRAM_BASE_ADDR);\r\nwd719x_writew(wd, WD719X_PCI_DMA_TRANSFER_SIZE, 2048 * 2);\r\nwd719x_writeb(wd, WD719X_PCI_CHANNEL2_3CMD, WD719X_START_CHANNEL2_3DMA);\r\ni = WD719X_WAIT_FOR_RISC;\r\nwhile (i-- > 0) {\r\nu8 status = wd719x_readb(wd, WD719X_PCI_CHANNEL2_3STATUS);\r\nif (status == WD719X_START_CHANNEL2_3DONE)\r\nbreak;\r\nif (status == WD719X_START_CHANNEL2_3ABORT) {\r\ndev_warn(&wd->pdev->dev, "RISC bootstrap failed: DMA aborted\n");\r\nret = -EIO;\r\ngoto wd719x_init_end;\r\n}\r\nudelay(1);\r\n}\r\nif (i < 1) {\r\ndev_warn(&wd->pdev->dev, "RISC bootstrap failed: DMA timeout\n");\r\nret = -ETIMEDOUT;\r\ngoto wd719x_init_end;\r\n}\r\nwd719x_writel(wd, WD719X_AMR_SCB_IN, risc_init[0]);\r\nwd719x_writel(wd, WD719X_AMR_SCB_IN + 4, risc_init[1]);\r\nwd719x_writel(wd, WD719X_AMR_SCB_IN + 8, risc_init[2]);\r\nwd719x_writeb(wd, WD719X_AMR_CMD_PARAM, WD719X_DISABLE_INT);\r\nwd719x_writeb(wd, WD719X_AMR_COMMAND, WD719X_CMD_INIT_RISC);\r\nwd719x_writeb(wd, WD719X_PCI_MODE_SELECT, WD719X_ENABLE_ADVANCE_MODE);\r\nudelay(WD719X_WAIT_FOR_RISC);\r\nret = wd719x_wait_done(wd, WD719X_WAIT_FOR_RISC);\r\nwd719x_writeb(wd, WD719X_AMR_INT_STATUS, WD719X_INT_NONE);\r\nif (ret) {\r\ndev_warn(&wd->pdev->dev, "Unable to initialize RISC\n");\r\ngoto wd719x_init_end;\r\n}\r\nret = wd719x_direct_cmd(wd, WD719X_CMD_READ_FIRMVER, 0, 0, 0, 0,\r\nWD719X_WAIT_FOR_RISC);\r\nif (ret) {\r\ndev_warn(&wd->pdev->dev, "Unable to read firmware version\n");\r\ngoto wd719x_init_end;\r\n}\r\ndev_info(&wd->pdev->dev, "RISC initialized with firmware version %.2x.%.2x\n",\r\nwd719x_readb(wd, WD719X_AMR_SCB_OUT + 1),\r\nwd719x_readb(wd, WD719X_AMR_SCB_OUT));\r\nret = wd719x_direct_cmd(wd, WD719X_CMD_BUSRESET, 0, 0, 0, 0,\r\nWD719X_WAIT_FOR_SCSI_RESET);\r\nif (ret) {\r\ndev_warn(&wd->pdev->dev, "SCSI bus reset failed\n");\r\ngoto wd719x_init_end;\r\n}\r\nret = wd719x_direct_cmd(wd, WD719X_CMD_SET_PARAM, 0,\r\nsizeof(struct wd719x_host_param), 0,\r\nwd->params_phys, WD719X_WAIT_FOR_RISC);\r\nif (ret) {\r\ndev_warn(&wd->pdev->dev, "Failed to set HOST PARAMETERS\n");\r\ngoto wd719x_init_end;\r\n}\r\nret = wd719x_direct_cmd(wd, WD719X_CMD_INIT_SCAM, 0, 0, 0, 0,\r\nWD719X_WAIT_FOR_SCSI_RESET);\r\nif (ret) {\r\ndev_warn(&wd->pdev->dev, "SCAM initialization failed\n");\r\ngoto wd719x_init_end;\r\n}\r\nwd719x_writeb(wd, WD719X_AMR_BIOS_SHARE_INT, 0);\r\nwd719x_init_end:\r\nrelease_firmware(fw_wcs);\r\nrelease_firmware(fw_risc);\r\nreturn ret;\r\n}\r\nstatic int wd719x_abort(struct scsi_cmnd *cmd)\r\n{\r\nint action, result;\r\nunsigned long flags;\r\nstruct wd719x_scb *scb = (struct wd719x_scb *)cmd->host_scribble;\r\nstruct wd719x *wd = shost_priv(cmd->device->host);\r\ndev_info(&wd->pdev->dev, "abort command, tag: %x\n", cmd->tag);\r\naction = WD719X_CMD_ABORT;\r\nspin_lock_irqsave(wd->sh->host_lock, flags);\r\nresult = wd719x_direct_cmd(wd, action, cmd->device->id,\r\ncmd->device->lun, cmd->tag, scb->phys, 0);\r\nspin_unlock_irqrestore(wd->sh->host_lock, flags);\r\nif (result)\r\nreturn FAILED;\r\nreturn SUCCESS;\r\n}\r\nstatic int wd719x_reset(struct scsi_cmnd *cmd, u8 opcode, u8 device)\r\n{\r\nint result;\r\nunsigned long flags;\r\nstruct wd719x *wd = shost_priv(cmd->device->host);\r\ndev_info(&wd->pdev->dev, "%s reset requested\n",\r\n(opcode == WD719X_CMD_BUSRESET) ? "bus" : "device");\r\nspin_lock_irqsave(wd->sh->host_lock, flags);\r\nresult = wd719x_direct_cmd(wd, opcode, device, 0, 0, 0,\r\nWD719X_WAIT_FOR_SCSI_RESET);\r\nspin_unlock_irqrestore(wd->sh->host_lock, flags);\r\nif (result)\r\nreturn FAILED;\r\nreturn SUCCESS;\r\n}\r\nstatic int wd719x_dev_reset(struct scsi_cmnd *cmd)\r\n{\r\nreturn wd719x_reset(cmd, WD719X_CMD_RESET, cmd->device->id);\r\n}\r\nstatic int wd719x_bus_reset(struct scsi_cmnd *cmd)\r\n{\r\nreturn wd719x_reset(cmd, WD719X_CMD_BUSRESET, 0);\r\n}\r\nstatic int wd719x_host_reset(struct scsi_cmnd *cmd)\r\n{\r\nstruct wd719x *wd = shost_priv(cmd->device->host);\r\nstruct wd719x_scb *scb, *tmp;\r\nunsigned long flags;\r\nint result;\r\ndev_info(&wd->pdev->dev, "host reset requested\n");\r\nspin_lock_irqsave(wd->sh->host_lock, flags);\r\nif (wd719x_chip_init(wd) == 0)\r\nresult = SUCCESS;\r\nelse\r\nresult = FAILED;\r\nlist_for_each_entry_safe(scb, tmp, &wd->active_scbs, list) {\r\nstruct scsi_cmnd *tmp_cmd = scb->cmd;\r\nwd719x_finish_cmd(tmp_cmd, result);\r\n}\r\nspin_unlock_irqrestore(wd->sh->host_lock, flags);\r\nreturn result;\r\n}\r\nstatic int wd719x_biosparam(struct scsi_device *sdev, struct block_device *bdev,\r\nsector_t capacity, int geom[])\r\n{\r\nif (capacity >= 0x200000) {\r\ngeom[0] = 255;\r\ngeom[1] = 63;\r\n} else {\r\ngeom[0] = 64;\r\ngeom[1] = 32;\r\n}\r\ngeom[2] = sector_div(capacity, geom[0] * geom[1]);\r\nreturn 0;\r\n}\r\nstatic inline void wd719x_interrupt_SCB(struct wd719x *wd,\r\nunion wd719x_regs regs,\r\nstruct wd719x_scb *scb)\r\n{\r\nstruct scsi_cmnd *cmd;\r\nint result;\r\nswitch (regs.bytes.SUE) {\r\ncase WD719X_SUE_NOERRORS:\r\nresult = DID_OK;\r\nbreak;\r\ncase WD719X_SUE_REJECTED:\r\ndev_err(&wd->pdev->dev, "command rejected\n");\r\nresult = DID_ERROR;\r\nbreak;\r\ncase WD719X_SUE_SCBQFULL:\r\ndev_err(&wd->pdev->dev, "SCB queue is full\n");\r\nresult = DID_ERROR;\r\nbreak;\r\ncase WD719X_SUE_TERM:\r\ndev_dbg(&wd->pdev->dev, "SCB terminated by direct command\n");\r\nresult = DID_ABORT;\r\nbreak;\r\ncase WD719X_SUE_CHAN1ABORT:\r\ncase WD719X_SUE_CHAN23ABORT:\r\nresult = DID_ABORT;\r\ndev_err(&wd->pdev->dev, "DMA abort\n");\r\nbreak;\r\ncase WD719X_SUE_CHAN1PAR:\r\ncase WD719X_SUE_CHAN23PAR:\r\nresult = DID_PARITY;\r\ndev_err(&wd->pdev->dev, "DMA parity error\n");\r\nbreak;\r\ncase WD719X_SUE_TIMEOUT:\r\nresult = DID_TIME_OUT;\r\ndev_dbg(&wd->pdev->dev, "selection timeout\n");\r\nbreak;\r\ncase WD719X_SUE_RESET:\r\ndev_dbg(&wd->pdev->dev, "bus reset occurred\n");\r\nresult = DID_RESET;\r\nbreak;\r\ncase WD719X_SUE_BUSERROR:\r\ndev_dbg(&wd->pdev->dev, "SCSI bus error\n");\r\nresult = DID_ERROR;\r\nbreak;\r\ncase WD719X_SUE_WRONGWAY:\r\ndev_err(&wd->pdev->dev, "wrong data transfer direction\n");\r\nresult = DID_ERROR;\r\nbreak;\r\ncase WD719X_SUE_BADPHASE:\r\ndev_err(&wd->pdev->dev, "invalid SCSI phase\n");\r\nresult = DID_ERROR;\r\nbreak;\r\ncase WD719X_SUE_TOOLONG:\r\ndev_err(&wd->pdev->dev, "record too long\n");\r\nresult = DID_ERROR;\r\nbreak;\r\ncase WD719X_SUE_BUSFREE:\r\ndev_err(&wd->pdev->dev, "unexpected bus free\n");\r\nresult = DID_NO_CONNECT;\r\nbreak;\r\ncase WD719X_SUE_ARSDONE:\r\ndev_dbg(&wd->pdev->dev, "auto request sense\n");\r\nif (regs.bytes.SCSI == 0)\r\nresult = DID_OK;\r\nelse\r\nresult = DID_PARITY;\r\nbreak;\r\ncase WD719X_SUE_IGNORED:\r\ndev_err(&wd->pdev->dev, "target id %d ignored command\n",\r\nscb->cmd->device->id);\r\nresult = DID_NO_CONNECT;\r\nbreak;\r\ncase WD719X_SUE_WRONGTAGS:\r\ndev_err(&wd->pdev->dev, "reversed tags\n");\r\nresult = DID_ERROR;\r\nbreak;\r\ncase WD719X_SUE_BADTAGS:\r\ndev_err(&wd->pdev->dev, "tag type not supported by target\n");\r\nresult = DID_ERROR;\r\nbreak;\r\ncase WD719X_SUE_NOSCAMID:\r\ndev_err(&wd->pdev->dev, "no SCAM soft ID available\n");\r\nresult = DID_ERROR;\r\nbreak;\r\ndefault:\r\ndev_warn(&wd->pdev->dev, "unknown SUE error code: 0x%x\n",\r\nregs.bytes.SUE);\r\nresult = DID_ERROR;\r\nbreak;\r\n}\r\ncmd = scb->cmd;\r\nwd719x_finish_cmd(cmd, result);\r\n}\r\nstatic irqreturn_t wd719x_interrupt(int irq, void *dev_id)\r\n{\r\nstruct wd719x *wd = dev_id;\r\nunion wd719x_regs regs;\r\nunsigned long flags;\r\nu32 SCB_out;\r\nspin_lock_irqsave(wd->sh->host_lock, flags);\r\nSCB_out = wd719x_readl(wd, WD719X_AMR_SCB_OUT);\r\nregs.all = cpu_to_le32(wd719x_readl(wd, WD719X_AMR_OP_CODE));\r\nswitch (regs.bytes.INT) {\r\ncase WD719X_INT_NONE:\r\nspin_unlock_irqrestore(wd->sh->host_lock, flags);\r\nreturn IRQ_NONE;\r\ncase WD719X_INT_LINKNOSTATUS:\r\ndev_err(&wd->pdev->dev, "linked command completed with no status\n");\r\nbreak;\r\ncase WD719X_INT_BADINT:\r\ndev_err(&wd->pdev->dev, "unsolicited interrupt\n");\r\nbreak;\r\ncase WD719X_INT_NOERRORS:\r\ncase WD719X_INT_LINKNOERRORS:\r\ncase WD719X_INT_ERRORSLOGGED:\r\ncase WD719X_INT_SPIDERFAILED:\r\nif (regs.bytes.OPC == WD719X_CMD_PROCESS_SCB) {\r\nstruct wd719x_scb *scb;\r\nlist_for_each_entry(scb, &wd->active_scbs, list)\r\nif (SCB_out == scb->phys)\r\nbreak;\r\nif (SCB_out == scb->phys)\r\nwd719x_interrupt_SCB(wd, regs, scb);\r\nelse\r\ndev_err(&wd->pdev->dev, "card returned invalid SCB pointer\n");\r\n} else\r\ndev_warn(&wd->pdev->dev, "direct command 0x%x completed\n",\r\nregs.bytes.OPC);\r\nbreak;\r\ncase WD719X_INT_PIOREADY:\r\ndev_err(&wd->pdev->dev, "card indicates PIO data ready but we never use PIO\n");\r\nbreak;\r\ndefault:\r\ndev_err(&wd->pdev->dev, "unknown interrupt reason: %d\n",\r\nregs.bytes.INT);\r\n}\r\nwd719x_writeb(wd, WD719X_AMR_INT_STATUS, WD719X_INT_NONE);\r\nspin_unlock_irqrestore(wd->sh->host_lock, flags);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void wd719x_eeprom_reg_read(struct eeprom_93cx6 *eeprom)\r\n{\r\nstruct wd719x *wd = eeprom->data;\r\nu8 reg = wd719x_readb(wd, WD719X_PCI_GPIO_DATA);\r\neeprom->reg_data_out = reg & WD719X_EE_DO;\r\n}\r\nstatic void wd719x_eeprom_reg_write(struct eeprom_93cx6 *eeprom)\r\n{\r\nstruct wd719x *wd = eeprom->data;\r\nu8 reg = 0;\r\nif (eeprom->reg_data_in)\r\nreg |= WD719X_EE_DI;\r\nif (eeprom->reg_data_clock)\r\nreg |= WD719X_EE_CLK;\r\nif (eeprom->reg_chip_select)\r\nreg |= WD719X_EE_CS;\r\nwd719x_writeb(wd, WD719X_PCI_GPIO_DATA, reg);\r\n}\r\nstatic void wd719x_read_eeprom(struct wd719x *wd)\r\n{\r\nstruct eeprom_93cx6 eeprom;\r\nu8 gpio;\r\nstruct wd719x_eeprom_header header;\r\neeprom.data = wd;\r\neeprom.register_read = wd719x_eeprom_reg_read;\r\neeprom.register_write = wd719x_eeprom_reg_write;\r\neeprom.width = PCI_EEPROM_WIDTH_93C46;\r\nwd719x_writeb(wd, WD719X_PCI_GPIO_DATA, 0);\r\ngpio = wd719x_readb(wd, WD719X_PCI_GPIO_CONTROL);\r\ngpio &= (~(WD719X_EE_CLK | WD719X_EE_DI | WD719X_EE_CS));\r\ngpio |= WD719X_EE_DO;\r\nwd719x_writeb(wd, WD719X_PCI_GPIO_CONTROL, gpio);\r\neeprom_93cx6_multireadb(&eeprom, 0, (u8 *)&header, sizeof(header));\r\nif (header.sig1 == 'W' && header.sig2 == 'D')\r\neeprom_93cx6_multireadb(&eeprom, header.cfg_offset,\r\n(u8 *)wd->params,\r\nsizeof(struct wd719x_host_param));\r\nelse {\r\ndev_warn(&wd->pdev->dev, "EEPROM signature is invalid (0x%02x 0x%02x), using default values\n",\r\nheader.sig1, header.sig2);\r\nwd->params->ch_1_th = 0x10;\r\nwd->params->scsi_conf = 0x4c;\r\nwd->params->own_scsi_id = 0x07;\r\nwd->params->sel_timeout = 0x4d;\r\nwd->params->sleep_timer = 0x01;\r\nwd->params->cdb_size = cpu_to_le16(0x5555);\r\nwd->params->scsi_pad = 0x1b;\r\nif (wd->type == WD719X_TYPE_7193)\r\nwd->params->wide = cpu_to_le32(0x00000000);\r\nelse\r\nwd->params->wide = cpu_to_le32(0xffffffff);\r\nwd->params->sync = cpu_to_le32(0xffffffff);\r\nwd->params->soft_mask = 0x00;\r\nwd->params->unsol_mask = 0x00;\r\n}\r\nwd->params->tag_en = cpu_to_le16(0x0000);\r\n}\r\nstatic enum wd719x_card_type wd719x_detect_type(struct wd719x *wd)\r\n{\r\nu8 card = wd719x_readb(wd, WD719X_PCI_GPIO_CONTROL);\r\ncard |= WD719X_GPIO_ID_BITS;\r\nwd719x_writeb(wd, WD719X_PCI_GPIO_CONTROL, card);\r\ncard = wd719x_readb(wd, WD719X_PCI_GPIO_DATA) & WD719X_GPIO_ID_BITS;\r\nswitch (card) {\r\ncase 0x08:\r\nreturn WD719X_TYPE_7193;\r\ncase 0x02:\r\nreturn WD719X_TYPE_7197;\r\ncase 0x00:\r\nreturn WD719X_TYPE_7296;\r\ndefault:\r\ndev_warn(&wd->pdev->dev, "unknown card type 0x%x\n", card);\r\nreturn WD719X_TYPE_UNKNOWN;\r\n}\r\n}\r\nstatic int wd719x_board_found(struct Scsi_Host *sh)\r\n{\r\nstruct wd719x *wd = shost_priv(sh);\r\nchar *card_types[] = { "Unknown card", "WD7193", "WD7197", "WD7296" };\r\nint ret;\r\nINIT_LIST_HEAD(&wd->active_scbs);\r\nINIT_LIST_HEAD(&wd->free_scbs);\r\nsh->base = pci_resource_start(wd->pdev, 0);\r\nwd->type = wd719x_detect_type(wd);\r\nwd->sh = sh;\r\nsh->irq = wd->pdev->irq;\r\nwd->fw_virt = NULL;\r\nwd->params = pci_alloc_consistent(wd->pdev,\r\nsizeof(struct wd719x_host_param),\r\n&wd->params_phys);\r\nif (!wd->params) {\r\ndev_warn(&wd->pdev->dev, "unable to allocate parameter buffer\n");\r\nreturn -ENOMEM;\r\n}\r\nwd->hash_virt = pci_alloc_consistent(wd->pdev, WD719X_HASH_TABLE_SIZE,\r\n&wd->hash_phys);\r\nif (!wd->hash_virt) {\r\ndev_warn(&wd->pdev->dev, "unable to allocate hash buffer\n");\r\nret = -ENOMEM;\r\ngoto fail_free_params;\r\n}\r\nret = request_irq(wd->pdev->irq, wd719x_interrupt, IRQF_SHARED,\r\n"wd719x", wd);\r\nif (ret) {\r\ndev_warn(&wd->pdev->dev, "unable to assign IRQ %d\n",\r\nwd->pdev->irq);\r\ngoto fail_free_hash;\r\n}\r\nwd719x_read_eeprom(wd);\r\nret = wd719x_chip_init(wd);\r\nif (ret)\r\ngoto fail_free_irq;\r\nsh->this_id = wd->params->own_scsi_id & WD719X_EE_SCSI_ID_MASK;\r\ndev_info(&wd->pdev->dev, "%s at I/O 0x%lx, IRQ %u, SCSI ID %d\n",\r\ncard_types[wd->type], sh->base, sh->irq, sh->this_id);\r\nreturn 0;\r\nfail_free_irq:\r\nfree_irq(wd->pdev->irq, wd);\r\nfail_free_hash:\r\npci_free_consistent(wd->pdev, WD719X_HASH_TABLE_SIZE, wd->hash_virt,\r\nwd->hash_phys);\r\nfail_free_params:\r\npci_free_consistent(wd->pdev, sizeof(struct wd719x_host_param),\r\nwd->params, wd->params_phys);\r\nreturn ret;\r\n}\r\nstatic int wd719x_pci_probe(struct pci_dev *pdev, const struct pci_device_id *d)\r\n{\r\nint err;\r\nstruct Scsi_Host *sh;\r\nstruct wd719x *wd;\r\nerr = pci_enable_device(pdev);\r\nif (err)\r\ngoto fail;\r\nif (pci_set_dma_mask(pdev, DMA_BIT_MASK(32))) {\r\ndev_warn(&pdev->dev, "Unable to set 32-bit DMA mask\n");\r\ngoto disable_device;\r\n}\r\nerr = pci_request_regions(pdev, "wd719x");\r\nif (err)\r\ngoto disable_device;\r\npci_set_master(pdev);\r\nerr = -ENODEV;\r\nif (pci_resource_len(pdev, 0) == 0)\r\ngoto release_region;\r\nerr = -ENOMEM;\r\nsh = scsi_host_alloc(&wd719x_template, sizeof(struct wd719x));\r\nif (!sh)\r\ngoto release_region;\r\nwd = shost_priv(sh);\r\nwd->base = pci_iomap(pdev, 0, 0);\r\nif (!wd->base)\r\ngoto free_host;\r\nwd->pdev = pdev;\r\nerr = wd719x_board_found(sh);\r\nif (err)\r\ngoto unmap;\r\nerr = scsi_add_host(sh, &wd->pdev->dev);\r\nif (err)\r\ngoto destroy;\r\nscsi_scan_host(sh);\r\npci_set_drvdata(pdev, sh);\r\nreturn 0;\r\ndestroy:\r\nwd719x_destroy(wd);\r\nunmap:\r\npci_iounmap(pdev, wd->base);\r\nfree_host:\r\nscsi_host_put(sh);\r\nrelease_region:\r\npci_release_regions(pdev);\r\ndisable_device:\r\npci_disable_device(pdev);\r\nfail:\r\nreturn err;\r\n}\r\nstatic void wd719x_pci_remove(struct pci_dev *pdev)\r\n{\r\nstruct Scsi_Host *sh = pci_get_drvdata(pdev);\r\nstruct wd719x *wd = shost_priv(sh);\r\nscsi_remove_host(sh);\r\nwd719x_destroy(wd);\r\npci_iounmap(pdev, wd->base);\r\npci_release_regions(pdev);\r\npci_disable_device(pdev);\r\nscsi_host_put(sh);\r\n}\r\nstatic int __init wd719x_init(void)\r\n{\r\nreturn pci_register_driver(&wd719x_pci_driver);\r\n}\r\nstatic void __exit wd719x_exit(void)\r\n{\r\npci_unregister_driver(&wd719x_pci_driver);\r\n}
