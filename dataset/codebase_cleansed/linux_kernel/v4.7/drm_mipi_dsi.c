static int mipi_dsi_device_match(struct device *dev, struct device_driver *drv)\r\n{\r\nstruct mipi_dsi_device *dsi = to_mipi_dsi_device(dev);\r\nif (of_driver_match_device(dev, drv))\r\nreturn 1;\r\nif (!strcmp(dsi->name, drv->name))\r\nreturn 1;\r\nreturn 0;\r\n}\r\nstatic int of_device_match(struct device *dev, void *data)\r\n{\r\nreturn dev->of_node == data;\r\n}\r\nstruct mipi_dsi_device *of_find_mipi_dsi_device_by_node(struct device_node *np)\r\n{\r\nstruct device *dev;\r\ndev = bus_find_device(&mipi_dsi_bus_type, NULL, np, of_device_match);\r\nreturn dev ? to_mipi_dsi_device(dev) : NULL;\r\n}\r\nstatic void mipi_dsi_dev_release(struct device *dev)\r\n{\r\nstruct mipi_dsi_device *dsi = to_mipi_dsi_device(dev);\r\nof_node_put(dev->of_node);\r\nkfree(dsi);\r\n}\r\nstatic struct mipi_dsi_device *mipi_dsi_device_alloc(struct mipi_dsi_host *host)\r\n{\r\nstruct mipi_dsi_device *dsi;\r\ndsi = kzalloc(sizeof(*dsi), GFP_KERNEL);\r\nif (!dsi)\r\nreturn ERR_PTR(-ENOMEM);\r\ndsi->host = host;\r\ndsi->dev.bus = &mipi_dsi_bus_type;\r\ndsi->dev.parent = host->dev;\r\ndsi->dev.type = &mipi_dsi_device_type;\r\ndevice_initialize(&dsi->dev);\r\nreturn dsi;\r\n}\r\nstatic int mipi_dsi_device_add(struct mipi_dsi_device *dsi)\r\n{\r\nstruct mipi_dsi_host *host = dsi->host;\r\ndev_set_name(&dsi->dev, "%s.%d", dev_name(host->dev), dsi->channel);\r\nreturn device_add(&dsi->dev);\r\n}\r\nstatic struct mipi_dsi_device *\r\nof_mipi_dsi_device_add(struct mipi_dsi_host *host, struct device_node *node)\r\n{\r\nstruct device *dev = host->dev;\r\nstruct mipi_dsi_device_info info = { };\r\nint ret;\r\nu32 reg;\r\nif (of_modalias_node(node, info.type, sizeof(info.type)) < 0) {\r\ndev_err(dev, "modalias failure on %s\n", node->full_name);\r\nreturn ERR_PTR(-EINVAL);\r\n}\r\nret = of_property_read_u32(node, "reg", &reg);\r\nif (ret) {\r\ndev_err(dev, "device node %s has no valid reg property: %d\n",\r\nnode->full_name, ret);\r\nreturn ERR_PTR(-EINVAL);\r\n}\r\ninfo.channel = reg;\r\ninfo.node = of_node_get(node);\r\nreturn mipi_dsi_device_register_full(host, &info);\r\n}\r\nstatic struct mipi_dsi_device *\r\nof_mipi_dsi_device_add(struct mipi_dsi_host *host, struct device_node *node)\r\n{\r\nreturn ERR_PTR(-ENODEV);\r\n}\r\nstruct mipi_dsi_device *\r\nmipi_dsi_device_register_full(struct mipi_dsi_host *host,\r\nconst struct mipi_dsi_device_info *info)\r\n{\r\nstruct mipi_dsi_device *dsi;\r\nstruct device *dev = host->dev;\r\nint ret;\r\nif (!info) {\r\ndev_err(dev, "invalid mipi_dsi_device_info pointer\n");\r\nreturn ERR_PTR(-EINVAL);\r\n}\r\nif (info->channel > 3) {\r\ndev_err(dev, "invalid virtual channel: %u\n", info->channel);\r\nreturn ERR_PTR(-EINVAL);\r\n}\r\ndsi = mipi_dsi_device_alloc(host);\r\nif (IS_ERR(dsi)) {\r\ndev_err(dev, "failed to allocate DSI device %ld\n",\r\nPTR_ERR(dsi));\r\nreturn dsi;\r\n}\r\ndsi->dev.of_node = info->node;\r\ndsi->channel = info->channel;\r\nstrlcpy(dsi->name, info->type, sizeof(dsi->name));\r\nret = mipi_dsi_device_add(dsi);\r\nif (ret) {\r\ndev_err(dev, "failed to add DSI device %d\n", ret);\r\nkfree(dsi);\r\nreturn ERR_PTR(ret);\r\n}\r\nreturn dsi;\r\n}\r\nvoid mipi_dsi_device_unregister(struct mipi_dsi_device *dsi)\r\n{\r\ndevice_unregister(&dsi->dev);\r\n}\r\nstruct mipi_dsi_host *of_find_mipi_dsi_host_by_node(struct device_node *node)\r\n{\r\nstruct mipi_dsi_host *host;\r\nmutex_lock(&host_lock);\r\nlist_for_each_entry(host, &host_list, list) {\r\nif (host->dev->of_node == node) {\r\nmutex_unlock(&host_lock);\r\nreturn host;\r\n}\r\n}\r\nmutex_unlock(&host_lock);\r\nreturn NULL;\r\n}\r\nint mipi_dsi_host_register(struct mipi_dsi_host *host)\r\n{\r\nstruct device_node *node;\r\nfor_each_available_child_of_node(host->dev->of_node, node) {\r\nif (!of_find_property(node, "reg", NULL))\r\ncontinue;\r\nof_mipi_dsi_device_add(host, node);\r\n}\r\nmutex_lock(&host_lock);\r\nlist_add_tail(&host->list, &host_list);\r\nmutex_unlock(&host_lock);\r\nreturn 0;\r\n}\r\nstatic int mipi_dsi_remove_device_fn(struct device *dev, void *priv)\r\n{\r\nstruct mipi_dsi_device *dsi = to_mipi_dsi_device(dev);\r\nmipi_dsi_device_unregister(dsi);\r\nreturn 0;\r\n}\r\nvoid mipi_dsi_host_unregister(struct mipi_dsi_host *host)\r\n{\r\ndevice_for_each_child(host->dev, NULL, mipi_dsi_remove_device_fn);\r\nmutex_lock(&host_lock);\r\nlist_del_init(&host->list);\r\nmutex_unlock(&host_lock);\r\n}\r\nint mipi_dsi_attach(struct mipi_dsi_device *dsi)\r\n{\r\nconst struct mipi_dsi_host_ops *ops = dsi->host->ops;\r\nif (!ops || !ops->attach)\r\nreturn -ENOSYS;\r\nreturn ops->attach(dsi->host, dsi);\r\n}\r\nint mipi_dsi_detach(struct mipi_dsi_device *dsi)\r\n{\r\nconst struct mipi_dsi_host_ops *ops = dsi->host->ops;\r\nif (!ops || !ops->detach)\r\nreturn -ENOSYS;\r\nreturn ops->detach(dsi->host, dsi);\r\n}\r\nstatic ssize_t mipi_dsi_device_transfer(struct mipi_dsi_device *dsi,\r\nstruct mipi_dsi_msg *msg)\r\n{\r\nconst struct mipi_dsi_host_ops *ops = dsi->host->ops;\r\nif (!ops || !ops->transfer)\r\nreturn -ENOSYS;\r\nif (dsi->mode_flags & MIPI_DSI_MODE_LPM)\r\nmsg->flags |= MIPI_DSI_MSG_USE_LPM;\r\nreturn ops->transfer(dsi->host, msg);\r\n}\r\nbool mipi_dsi_packet_format_is_short(u8 type)\r\n{\r\nswitch (type) {\r\ncase MIPI_DSI_V_SYNC_START:\r\ncase MIPI_DSI_V_SYNC_END:\r\ncase MIPI_DSI_H_SYNC_START:\r\ncase MIPI_DSI_H_SYNC_END:\r\ncase MIPI_DSI_END_OF_TRANSMISSION:\r\ncase MIPI_DSI_COLOR_MODE_OFF:\r\ncase MIPI_DSI_COLOR_MODE_ON:\r\ncase MIPI_DSI_SHUTDOWN_PERIPHERAL:\r\ncase MIPI_DSI_TURN_ON_PERIPHERAL:\r\ncase MIPI_DSI_GENERIC_SHORT_WRITE_0_PARAM:\r\ncase MIPI_DSI_GENERIC_SHORT_WRITE_1_PARAM:\r\ncase MIPI_DSI_GENERIC_SHORT_WRITE_2_PARAM:\r\ncase MIPI_DSI_GENERIC_READ_REQUEST_0_PARAM:\r\ncase MIPI_DSI_GENERIC_READ_REQUEST_1_PARAM:\r\ncase MIPI_DSI_GENERIC_READ_REQUEST_2_PARAM:\r\ncase MIPI_DSI_DCS_SHORT_WRITE:\r\ncase MIPI_DSI_DCS_SHORT_WRITE_PARAM:\r\ncase MIPI_DSI_DCS_READ:\r\ncase MIPI_DSI_SET_MAXIMUM_RETURN_PACKET_SIZE:\r\nreturn true;\r\n}\r\nreturn false;\r\n}\r\nbool mipi_dsi_packet_format_is_long(u8 type)\r\n{\r\nswitch (type) {\r\ncase MIPI_DSI_NULL_PACKET:\r\ncase MIPI_DSI_BLANKING_PACKET:\r\ncase MIPI_DSI_GENERIC_LONG_WRITE:\r\ncase MIPI_DSI_DCS_LONG_WRITE:\r\ncase MIPI_DSI_LOOSELY_PACKED_PIXEL_STREAM_YCBCR20:\r\ncase MIPI_DSI_PACKED_PIXEL_STREAM_YCBCR24:\r\ncase MIPI_DSI_PACKED_PIXEL_STREAM_YCBCR16:\r\ncase MIPI_DSI_PACKED_PIXEL_STREAM_30:\r\ncase MIPI_DSI_PACKED_PIXEL_STREAM_36:\r\ncase MIPI_DSI_PACKED_PIXEL_STREAM_YCBCR12:\r\ncase MIPI_DSI_PACKED_PIXEL_STREAM_16:\r\ncase MIPI_DSI_PACKED_PIXEL_STREAM_18:\r\ncase MIPI_DSI_PIXEL_STREAM_3BYTE_18:\r\ncase MIPI_DSI_PACKED_PIXEL_STREAM_24:\r\nreturn true;\r\n}\r\nreturn false;\r\n}\r\nint mipi_dsi_create_packet(struct mipi_dsi_packet *packet,\r\nconst struct mipi_dsi_msg *msg)\r\n{\r\nif (!packet || !msg)\r\nreturn -EINVAL;\r\nif (!mipi_dsi_packet_format_is_short(msg->type) &&\r\n!mipi_dsi_packet_format_is_long(msg->type))\r\nreturn -EINVAL;\r\nif (msg->channel > 3)\r\nreturn -EINVAL;\r\nmemset(packet, 0, sizeof(*packet));\r\npacket->header[0] = ((msg->channel & 0x3) << 6) | (msg->type & 0x3f);\r\nif (mipi_dsi_packet_format_is_long(msg->type)) {\r\npacket->header[1] = (msg->tx_len >> 0) & 0xff;\r\npacket->header[2] = (msg->tx_len >> 8) & 0xff;\r\npacket->payload_length = msg->tx_len;\r\npacket->payload = msg->tx_buf;\r\n} else {\r\nconst u8 *tx = msg->tx_buf;\r\npacket->header[1] = (msg->tx_len > 0) ? tx[0] : 0;\r\npacket->header[2] = (msg->tx_len > 1) ? tx[1] : 0;\r\n}\r\npacket->size = sizeof(packet->header) + packet->payload_length;\r\nreturn 0;\r\n}\r\nint mipi_dsi_shutdown_peripheral(struct mipi_dsi_device *dsi)\r\n{\r\nstruct mipi_dsi_msg msg = {\r\n.channel = dsi->channel,\r\n.type = MIPI_DSI_SHUTDOWN_PERIPHERAL,\r\n.tx_buf = (u8 [2]) { 0, 0 },\r\n.tx_len = 2,\r\n};\r\nreturn mipi_dsi_device_transfer(dsi, &msg);\r\n}\r\nint mipi_dsi_turn_on_peripheral(struct mipi_dsi_device *dsi)\r\n{\r\nstruct mipi_dsi_msg msg = {\r\n.channel = dsi->channel,\r\n.type = MIPI_DSI_TURN_ON_PERIPHERAL,\r\n.tx_buf = (u8 [2]) { 0, 0 },\r\n.tx_len = 2,\r\n};\r\nreturn mipi_dsi_device_transfer(dsi, &msg);\r\n}\r\nint mipi_dsi_set_maximum_return_packet_size(struct mipi_dsi_device *dsi,\r\nu16 value)\r\n{\r\nu8 tx[2] = { value & 0xff, value >> 8 };\r\nstruct mipi_dsi_msg msg = {\r\n.channel = dsi->channel,\r\n.type = MIPI_DSI_SET_MAXIMUM_RETURN_PACKET_SIZE,\r\n.tx_len = sizeof(tx),\r\n.tx_buf = tx,\r\n};\r\nreturn mipi_dsi_device_transfer(dsi, &msg);\r\n}\r\nssize_t mipi_dsi_generic_write(struct mipi_dsi_device *dsi, const void *payload,\r\nsize_t size)\r\n{\r\nstruct mipi_dsi_msg msg = {\r\n.channel = dsi->channel,\r\n.tx_buf = payload,\r\n.tx_len = size\r\n};\r\nswitch (size) {\r\ncase 0:\r\nmsg.type = MIPI_DSI_GENERIC_SHORT_WRITE_0_PARAM;\r\nbreak;\r\ncase 1:\r\nmsg.type = MIPI_DSI_GENERIC_SHORT_WRITE_1_PARAM;\r\nbreak;\r\ncase 2:\r\nmsg.type = MIPI_DSI_GENERIC_SHORT_WRITE_2_PARAM;\r\nbreak;\r\ndefault:\r\nmsg.type = MIPI_DSI_GENERIC_LONG_WRITE;\r\nbreak;\r\n}\r\nreturn mipi_dsi_device_transfer(dsi, &msg);\r\n}\r\nssize_t mipi_dsi_generic_read(struct mipi_dsi_device *dsi, const void *params,\r\nsize_t num_params, void *data, size_t size)\r\n{\r\nstruct mipi_dsi_msg msg = {\r\n.channel = dsi->channel,\r\n.tx_len = num_params,\r\n.tx_buf = params,\r\n.rx_len = size,\r\n.rx_buf = data\r\n};\r\nswitch (num_params) {\r\ncase 0:\r\nmsg.type = MIPI_DSI_GENERIC_READ_REQUEST_0_PARAM;\r\nbreak;\r\ncase 1:\r\nmsg.type = MIPI_DSI_GENERIC_READ_REQUEST_1_PARAM;\r\nbreak;\r\ncase 2:\r\nmsg.type = MIPI_DSI_GENERIC_READ_REQUEST_2_PARAM;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn mipi_dsi_device_transfer(dsi, &msg);\r\n}\r\nssize_t mipi_dsi_dcs_write_buffer(struct mipi_dsi_device *dsi,\r\nconst void *data, size_t len)\r\n{\r\nstruct mipi_dsi_msg msg = {\r\n.channel = dsi->channel,\r\n.tx_buf = data,\r\n.tx_len = len\r\n};\r\nswitch (len) {\r\ncase 0:\r\nreturn -EINVAL;\r\ncase 1:\r\nmsg.type = MIPI_DSI_DCS_SHORT_WRITE;\r\nbreak;\r\ncase 2:\r\nmsg.type = MIPI_DSI_DCS_SHORT_WRITE_PARAM;\r\nbreak;\r\ndefault:\r\nmsg.type = MIPI_DSI_DCS_LONG_WRITE;\r\nbreak;\r\n}\r\nreturn mipi_dsi_device_transfer(dsi, &msg);\r\n}\r\nssize_t mipi_dsi_dcs_write(struct mipi_dsi_device *dsi, u8 cmd,\r\nconst void *data, size_t len)\r\n{\r\nssize_t err;\r\nsize_t size;\r\nu8 *tx;\r\nif (len > 0) {\r\nsize = 1 + len;\r\ntx = kmalloc(size, GFP_KERNEL);\r\nif (!tx)\r\nreturn -ENOMEM;\r\ntx[0] = cmd;\r\nmemcpy(&tx[1], data, len);\r\n} else {\r\ntx = &cmd;\r\nsize = 1;\r\n}\r\nerr = mipi_dsi_dcs_write_buffer(dsi, tx, size);\r\nif (len > 0)\r\nkfree(tx);\r\nreturn err;\r\n}\r\nssize_t mipi_dsi_dcs_read(struct mipi_dsi_device *dsi, u8 cmd, void *data,\r\nsize_t len)\r\n{\r\nstruct mipi_dsi_msg msg = {\r\n.channel = dsi->channel,\r\n.type = MIPI_DSI_DCS_READ,\r\n.tx_buf = &cmd,\r\n.tx_len = 1,\r\n.rx_buf = data,\r\n.rx_len = len\r\n};\r\nreturn mipi_dsi_device_transfer(dsi, &msg);\r\n}\r\nint mipi_dsi_dcs_nop(struct mipi_dsi_device *dsi)\r\n{\r\nssize_t err;\r\nerr = mipi_dsi_dcs_write(dsi, MIPI_DCS_NOP, NULL, 0);\r\nif (err < 0)\r\nreturn err;\r\nreturn 0;\r\n}\r\nint mipi_dsi_dcs_soft_reset(struct mipi_dsi_device *dsi)\r\n{\r\nssize_t err;\r\nerr = mipi_dsi_dcs_write(dsi, MIPI_DCS_SOFT_RESET, NULL, 0);\r\nif (err < 0)\r\nreturn err;\r\nreturn 0;\r\n}\r\nint mipi_dsi_dcs_get_power_mode(struct mipi_dsi_device *dsi, u8 *mode)\r\n{\r\nssize_t err;\r\nerr = mipi_dsi_dcs_read(dsi, MIPI_DCS_GET_POWER_MODE, mode,\r\nsizeof(*mode));\r\nif (err <= 0) {\r\nif (err == 0)\r\nerr = -ENODATA;\r\nreturn err;\r\n}\r\nreturn 0;\r\n}\r\nint mipi_dsi_dcs_get_pixel_format(struct mipi_dsi_device *dsi, u8 *format)\r\n{\r\nssize_t err;\r\nerr = mipi_dsi_dcs_read(dsi, MIPI_DCS_GET_PIXEL_FORMAT, format,\r\nsizeof(*format));\r\nif (err <= 0) {\r\nif (err == 0)\r\nerr = -ENODATA;\r\nreturn err;\r\n}\r\nreturn 0;\r\n}\r\nint mipi_dsi_dcs_enter_sleep_mode(struct mipi_dsi_device *dsi)\r\n{\r\nssize_t err;\r\nerr = mipi_dsi_dcs_write(dsi, MIPI_DCS_ENTER_SLEEP_MODE, NULL, 0);\r\nif (err < 0)\r\nreturn err;\r\nreturn 0;\r\n}\r\nint mipi_dsi_dcs_exit_sleep_mode(struct mipi_dsi_device *dsi)\r\n{\r\nssize_t err;\r\nerr = mipi_dsi_dcs_write(dsi, MIPI_DCS_EXIT_SLEEP_MODE, NULL, 0);\r\nif (err < 0)\r\nreturn err;\r\nreturn 0;\r\n}\r\nint mipi_dsi_dcs_set_display_off(struct mipi_dsi_device *dsi)\r\n{\r\nssize_t err;\r\nerr = mipi_dsi_dcs_write(dsi, MIPI_DCS_SET_DISPLAY_OFF, NULL, 0);\r\nif (err < 0)\r\nreturn err;\r\nreturn 0;\r\n}\r\nint mipi_dsi_dcs_set_display_on(struct mipi_dsi_device *dsi)\r\n{\r\nssize_t err;\r\nerr = mipi_dsi_dcs_write(dsi, MIPI_DCS_SET_DISPLAY_ON, NULL, 0);\r\nif (err < 0)\r\nreturn err;\r\nreturn 0;\r\n}\r\nint mipi_dsi_dcs_set_column_address(struct mipi_dsi_device *dsi, u16 start,\r\nu16 end)\r\n{\r\nu8 payload[4] = { start >> 8, start & 0xff, end >> 8, end & 0xff };\r\nssize_t err;\r\nerr = mipi_dsi_dcs_write(dsi, MIPI_DCS_SET_COLUMN_ADDRESS, payload,\r\nsizeof(payload));\r\nif (err < 0)\r\nreturn err;\r\nreturn 0;\r\n}\r\nint mipi_dsi_dcs_set_page_address(struct mipi_dsi_device *dsi, u16 start,\r\nu16 end)\r\n{\r\nu8 payload[4] = { start >> 8, start & 0xff, end >> 8, end & 0xff };\r\nssize_t err;\r\nerr = mipi_dsi_dcs_write(dsi, MIPI_DCS_SET_PAGE_ADDRESS, payload,\r\nsizeof(payload));\r\nif (err < 0)\r\nreturn err;\r\nreturn 0;\r\n}\r\nint mipi_dsi_dcs_set_tear_off(struct mipi_dsi_device *dsi)\r\n{\r\nssize_t err;\r\nerr = mipi_dsi_dcs_write(dsi, MIPI_DCS_SET_TEAR_OFF, NULL, 0);\r\nif (err < 0)\r\nreturn err;\r\nreturn 0;\r\n}\r\nint mipi_dsi_dcs_set_tear_on(struct mipi_dsi_device *dsi,\r\nenum mipi_dsi_dcs_tear_mode mode)\r\n{\r\nu8 value = mode;\r\nssize_t err;\r\nerr = mipi_dsi_dcs_write(dsi, MIPI_DCS_SET_TEAR_ON, &value,\r\nsizeof(value));\r\nif (err < 0)\r\nreturn err;\r\nreturn 0;\r\n}\r\nint mipi_dsi_dcs_set_pixel_format(struct mipi_dsi_device *dsi, u8 format)\r\n{\r\nssize_t err;\r\nerr = mipi_dsi_dcs_write(dsi, MIPI_DCS_SET_PIXEL_FORMAT, &format,\r\nsizeof(format));\r\nif (err < 0)\r\nreturn err;\r\nreturn 0;\r\n}\r\nstatic int mipi_dsi_drv_probe(struct device *dev)\r\n{\r\nstruct mipi_dsi_driver *drv = to_mipi_dsi_driver(dev->driver);\r\nstruct mipi_dsi_device *dsi = to_mipi_dsi_device(dev);\r\nreturn drv->probe(dsi);\r\n}\r\nstatic int mipi_dsi_drv_remove(struct device *dev)\r\n{\r\nstruct mipi_dsi_driver *drv = to_mipi_dsi_driver(dev->driver);\r\nstruct mipi_dsi_device *dsi = to_mipi_dsi_device(dev);\r\nreturn drv->remove(dsi);\r\n}\r\nstatic void mipi_dsi_drv_shutdown(struct device *dev)\r\n{\r\nstruct mipi_dsi_driver *drv = to_mipi_dsi_driver(dev->driver);\r\nstruct mipi_dsi_device *dsi = to_mipi_dsi_device(dev);\r\ndrv->shutdown(dsi);\r\n}\r\nint mipi_dsi_driver_register_full(struct mipi_dsi_driver *drv,\r\nstruct module *owner)\r\n{\r\ndrv->driver.bus = &mipi_dsi_bus_type;\r\ndrv->driver.owner = owner;\r\nif (drv->probe)\r\ndrv->driver.probe = mipi_dsi_drv_probe;\r\nif (drv->remove)\r\ndrv->driver.remove = mipi_dsi_drv_remove;\r\nif (drv->shutdown)\r\ndrv->driver.shutdown = mipi_dsi_drv_shutdown;\r\nreturn driver_register(&drv->driver);\r\n}\r\nvoid mipi_dsi_driver_unregister(struct mipi_dsi_driver *drv)\r\n{\r\ndriver_unregister(&drv->driver);\r\n}\r\nstatic int __init mipi_dsi_bus_init(void)\r\n{\r\nreturn bus_register(&mipi_dsi_bus_type);\r\n}
