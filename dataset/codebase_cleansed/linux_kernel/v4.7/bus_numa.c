static struct pci_root_info *x86_find_pci_root_info(int bus)\r\n{\r\nstruct pci_root_info *info;\r\nlist_for_each_entry(info, &pci_root_infos, list)\r\nif (info->busn.start == bus)\r\nreturn info;\r\nreturn NULL;\r\n}\r\nint x86_pci_root_bus_node(int bus)\r\n{\r\nstruct pci_root_info *info = x86_find_pci_root_info(bus);\r\nif (!info)\r\nreturn NUMA_NO_NODE;\r\nreturn info->node;\r\n}\r\nvoid x86_pci_root_bus_resources(int bus, struct list_head *resources)\r\n{\r\nstruct pci_root_info *info = x86_find_pci_root_info(bus);\r\nstruct pci_root_res *root_res;\r\nstruct resource_entry *window;\r\nbool found = false;\r\nif (!info)\r\ngoto default_resources;\r\nprintk(KERN_DEBUG "PCI: root bus %02x: hardware-probed resources\n",\r\nbus);\r\nresource_list_for_each_entry(window, resources)\r\nif (window->res->flags & IORESOURCE_BUS) {\r\nfound = true;\r\nbreak;\r\n}\r\nif (!found)\r\npci_add_resource(resources, &info->busn);\r\nlist_for_each_entry(root_res, &info->resources, list)\r\npci_add_resource(resources, &root_res->res);\r\nreturn;\r\ndefault_resources:\r\nprintk(KERN_DEBUG "PCI: root bus %02x: using default resources\n", bus);\r\npci_add_resource(resources, &ioport_resource);\r\npci_add_resource(resources, &iomem_resource);\r\n}\r\nstruct pci_root_info __init *alloc_pci_root_info(int bus_min, int bus_max,\r\nint node, int link)\r\n{\r\nstruct pci_root_info *info;\r\ninfo = kzalloc(sizeof(*info), GFP_KERNEL);\r\nif (!info)\r\nreturn info;\r\nsprintf(info->name, "PCI Bus #%02x", bus_min);\r\nINIT_LIST_HEAD(&info->resources);\r\ninfo->busn.name = info->name;\r\ninfo->busn.start = bus_min;\r\ninfo->busn.end = bus_max;\r\ninfo->busn.flags = IORESOURCE_BUS;\r\ninfo->node = node;\r\ninfo->link = link;\r\nlist_add_tail(&info->list, &pci_root_infos);\r\nreturn info;\r\n}\r\nvoid update_res(struct pci_root_info *info, resource_size_t start,\r\nresource_size_t end, unsigned long flags, int merge)\r\n{\r\nstruct resource *res;\r\nstruct pci_root_res *root_res;\r\nif (start > end)\r\nreturn;\r\nif (start == MAX_RESOURCE)\r\nreturn;\r\nif (!merge)\r\ngoto addit;\r\nlist_for_each_entry(root_res, &info->resources, list) {\r\nresource_size_t final_start, final_end;\r\nresource_size_t common_start, common_end;\r\nres = &root_res->res;\r\nif (res->flags != flags)\r\ncontinue;\r\ncommon_start = max(res->start, start);\r\ncommon_end = min(res->end, end);\r\nif (common_start > common_end + 1)\r\ncontinue;\r\nfinal_start = min(res->start, start);\r\nfinal_end = max(res->end, end);\r\nres->start = final_start;\r\nres->end = final_end;\r\nreturn;\r\n}\r\naddit:\r\nroot_res = kzalloc(sizeof(*root_res), GFP_KERNEL);\r\nif (!root_res)\r\nreturn;\r\nres = &root_res->res;\r\nres->name = info->name;\r\nres->flags = flags;\r\nres->start = start;\r\nres->end = end;\r\nlist_add_tail(&root_res->list, &info->resources);\r\n}
