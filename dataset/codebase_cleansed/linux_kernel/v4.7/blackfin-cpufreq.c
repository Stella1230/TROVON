static void __init bfin_init_tables(unsigned long cclk, unsigned long sclk)\r\n{\r\nunsigned long csel, min_cclk;\r\nint index;\r\n#if ANOMALY_05000273 || ANOMALY_05000274 || \\r\n(!(defined(CONFIG_BF54x) || defined(CONFIG_BF60x)) \\r\n&& defined(CONFIG_BFIN_EXTMEM_DCACHEABLE))\r\nmin_cclk = sclk * 2;\r\n#else\r\nmin_cclk = sclk;\r\n#endif\r\n#ifndef CONFIG_BF60x\r\ncsel = ((bfin_read_PLL_DIV() & CSEL) >> 4);\r\n#else\r\ncsel = bfin_read32(CGU0_DIV) & 0x1F;\r\n#endif\r\nfor (index = 0; (cclk >> index) >= min_cclk && csel <= 3 && index < 3; index++, csel++) {\r\nbfin_freq_table[index].frequency = cclk >> index;\r\n#ifndef CONFIG_BF60x\r\ndpm_state_table[index].csel = csel << 4;\r\n#else\r\ndpm_state_table[index].csel = csel;\r\n#endif\r\ndpm_state_table[index].tscale = (TIME_SCALE >> index) - 1;\r\npr_debug("cpufreq: freq:%d csel:0x%x tscale:%d\n",\r\nbfin_freq_table[index].frequency,\r\ndpm_state_table[index].csel,\r\ndpm_state_table[index].tscale);\r\n}\r\nreturn;\r\n}\r\nstatic void bfin_adjust_core_timer(void *info)\r\n{\r\nunsigned int tscale;\r\nunsigned int index = *(unsigned int *)info;\r\ntscale = dpm_state_table[index].tscale;\r\nbfin_write_TSCALE(tscale);\r\nreturn;\r\n}\r\nstatic unsigned int bfin_getfreq_khz(unsigned int cpu)\r\n{\r\nreturn get_cclk() / 1000;\r\n}\r\nstatic int cpu_set_cclk(int cpu, unsigned long new)\r\n{\r\nstruct clk *clk;\r\nint ret;\r\nclk = clk_get(NULL, "CCLK");\r\nif (IS_ERR(clk))\r\nreturn -ENODEV;\r\nret = clk_set_rate(clk, new);\r\nclk_put(clk);\r\nreturn ret;\r\n}\r\nstatic int bfin_target(struct cpufreq_policy *policy, unsigned int index)\r\n{\r\n#ifndef CONFIG_BF60x\r\nunsigned int plldiv;\r\n#endif\r\nstatic unsigned long lpj_ref;\r\nstatic unsigned int lpj_ref_freq;\r\nunsigned int old_freq, new_freq;\r\nint ret = 0;\r\n#if defined(CONFIG_CYCLES_CLOCKSOURCE)\r\ncycles_t cycles;\r\n#endif\r\nold_freq = bfin_getfreq_khz(0);\r\nnew_freq = bfin_freq_table[index].frequency;\r\n#ifndef CONFIG_BF60x\r\nplldiv = (bfin_read_PLL_DIV() & SSEL) | dpm_state_table[index].csel;\r\nbfin_write_PLL_DIV(plldiv);\r\n#else\r\nret = cpu_set_cclk(policy->cpu, new_freq * 1000);\r\nif (ret != 0) {\r\nWARN_ONCE(ret, "cpufreq set freq failed %d\n", ret);\r\nreturn ret;\r\n}\r\n#endif\r\non_each_cpu(bfin_adjust_core_timer, &index, 1);\r\n#if defined(CONFIG_CYCLES_CLOCKSOURCE)\r\ncycles = get_cycles();\r\nSSYNC();\r\ncycles += 10;\r\n__bfin_cycles_off += (cycles << __bfin_cycles_mod) - (cycles << index);\r\n__bfin_cycles_mod = index;\r\n#endif\r\nif (!lpj_ref_freq) {\r\nlpj_ref = loops_per_jiffy;\r\nlpj_ref_freq = old_freq;\r\n}\r\nif (new_freq != old_freq) {\r\nloops_per_jiffy = cpufreq_scale(lpj_ref,\r\nlpj_ref_freq, new_freq);\r\n}\r\nreturn ret;\r\n}\r\nstatic int __bfin_cpu_init(struct cpufreq_policy *policy)\r\n{\r\nunsigned long cclk, sclk;\r\ncclk = get_cclk() / 1000;\r\nsclk = get_sclk() / 1000;\r\nif (policy->cpu == CPUFREQ_CPU)\r\nbfin_init_tables(cclk, sclk);\r\npolicy->cpuinfo.transition_latency = 50000;\r\nreturn cpufreq_table_validate_and_show(policy, bfin_freq_table);\r\n}\r\nstatic int __init bfin_cpu_init(void)\r\n{\r\nreturn cpufreq_register_driver(&bfin_driver);\r\n}\r\nstatic void __exit bfin_cpu_exit(void)\r\n{\r\ncpufreq_unregister_driver(&bfin_driver);\r\n}
