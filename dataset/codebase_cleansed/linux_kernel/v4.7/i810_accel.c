static inline void i810_report_error(u8 __iomem *mmio)\r\n{\r\nprintk("IIR : 0x%04x\n"\r\n"EIR : 0x%04x\n"\r\n"PGTBL_ER: 0x%04x\n"\r\n"IPEIR : 0x%04x\n"\r\n"IPEHR : 0x%04x\n",\r\ni810_readw(IIR, mmio),\r\ni810_readb(EIR, mmio),\r\ni810_readl(PGTBL_ER, mmio),\r\ni810_readl(IPEIR, mmio),\r\ni810_readl(IPEHR, mmio));\r\n}\r\nstatic inline int wait_for_space(struct fb_info *info, u32 space)\r\n{\r\nstruct i810fb_par *par = info->par;\r\nu32 head, count = WAIT_COUNT, tail;\r\nu8 __iomem *mmio = par->mmio_start_virtual;\r\ntail = par->cur_tail;\r\nwhile (count--) {\r\nhead = i810_readl(IRING + 4, mmio) & RBUFFER_HEAD_MASK;\r\nif ((tail == head) ||\r\n(tail > head &&\r\n(par->iring.size - tail + head) >= space) ||\r\n(tail < head && (head - tail) >= space)) {\r\nreturn 0;\r\n}\r\n}\r\nprintk("ringbuffer lockup!!!\n");\r\ni810_report_error(mmio);\r\npar->dev_flags |= LOCKUP;\r\ninfo->pixmap.scan_align = 1;\r\nreturn 1;\r\n}\r\nstatic inline int wait_for_engine_idle(struct fb_info *info)\r\n{\r\nstruct i810fb_par *par = info->par;\r\nu8 __iomem *mmio = par->mmio_start_virtual;\r\nint count = WAIT_COUNT;\r\nif (wait_for_space(info, par->iring.size))\r\nreturn 1;\r\nwhile((i810_readw(INSTDONE, mmio) & 0x7B) != 0x7B && --count);\r\nif (count) return 0;\r\nprintk("accel engine lockup!!!\n");\r\nprintk("INSTDONE: 0x%04x\n", i810_readl(INSTDONE, mmio));\r\ni810_report_error(mmio);\r\npar->dev_flags |= LOCKUP;\r\ninfo->pixmap.scan_align = 1;\r\nreturn 1;\r\n}\r\nstatic inline u32 begin_iring(struct fb_info *info, u32 space)\r\n{\r\nstruct i810fb_par *par = info->par;\r\nif (par->dev_flags & ALWAYS_SYNC)\r\nwait_for_engine_idle(info);\r\nreturn wait_for_space(info, space);\r\n}\r\nstatic inline void end_iring(struct i810fb_par *par)\r\n{\r\nu8 __iomem *mmio = par->mmio_start_virtual;\r\ni810_writel(IRING, mmio, par->cur_tail);\r\n}\r\nstatic inline void source_copy_blit(int dwidth, int dheight, int dpitch,\r\nint xdir, int src, int dest, int rop,\r\nint blit_bpp, struct fb_info *info)\r\n{\r\nstruct i810fb_par *par = info->par;\r\nif (begin_iring(info, 24 + IRING_PAD)) return;\r\nPUT_RING(BLIT | SOURCE_COPY_BLIT | 4);\r\nPUT_RING(xdir | rop << 16 | dpitch | DYN_COLOR_EN | blit_bpp);\r\nPUT_RING(dheight << 16 | dwidth);\r\nPUT_RING(dest);\r\nPUT_RING(dpitch);\r\nPUT_RING(src);\r\nend_iring(par);\r\n}\r\nstatic inline void color_blit(int width, int height, int pitch, int dest,\r\nint rop, int what, int blit_bpp,\r\nstruct fb_info *info)\r\n{\r\nstruct i810fb_par *par = info->par;\r\nif (begin_iring(info, 24 + IRING_PAD)) return;\r\nPUT_RING(BLIT | COLOR_BLT | 3);\r\nPUT_RING(rop << 16 | pitch | SOLIDPATTERN | DYN_COLOR_EN | blit_bpp);\r\nPUT_RING(height << 16 | width);\r\nPUT_RING(dest);\r\nPUT_RING(what);\r\nPUT_RING(NOP);\r\nend_iring(par);\r\n}\r\nstatic inline void mono_src_copy_imm_blit(int dwidth, int dheight, int dpitch,\r\nint dsize, int blit_bpp, int rop,\r\nint dest, const u32 *src, int bg,\r\nint fg, struct fb_info *info)\r\n{\r\nstruct i810fb_par *par = info->par;\r\nif (begin_iring(info, 24 + (dsize << 2) + IRING_PAD)) return;\r\nPUT_RING(BLIT | MONO_SOURCE_COPY_IMMEDIATE | (4 + dsize));\r\nPUT_RING(DYN_COLOR_EN | blit_bpp | rop << 16 | dpitch);\r\nPUT_RING(dheight << 16 | dwidth);\r\nPUT_RING(dest);\r\nPUT_RING(bg);\r\nPUT_RING(fg);\r\nwhile (dsize--)\r\nPUT_RING(*src++);\r\nend_iring(par);\r\n}\r\nstatic inline void load_front(int offset, struct fb_info *info)\r\n{\r\nstruct i810fb_par *par = info->par;\r\nif (begin_iring(info, 8 + IRING_PAD)) return;\r\nPUT_RING(PARSER | FLUSH);\r\nPUT_RING(NOP);\r\nend_iring(par);\r\nif (begin_iring(info, 8 + IRING_PAD)) return;\r\nPUT_RING(PARSER | FRONT_BUFFER | ((par->pitch >> 3) << 8));\r\nPUT_RING((par->fb.offset << 12) + offset);\r\nend_iring(par);\r\n}\r\nstatic inline void i810fb_iring_enable(struct i810fb_par *par, u32 mode)\r\n{\r\nu32 tmp;\r\nu8 __iomem *mmio = par->mmio_start_virtual;\r\ntmp = i810_readl(IRING + 12, mmio);\r\nif (mode == OFF)\r\ntmp &= ~1;\r\nelse\r\ntmp |= 1;\r\nflush_cache();\r\ni810_writel(IRING + 12, mmio, tmp);\r\n}\r\nvoid i810fb_fillrect(struct fb_info *info, const struct fb_fillrect *rect)\r\n{\r\nstruct i810fb_par *par = info->par;\r\nu32 dx, dy, width, height, dest, rop = 0, color = 0;\r\nif (!info->var.accel_flags || par->dev_flags & LOCKUP ||\r\npar->depth == 4) {\r\ncfb_fillrect(info, rect);\r\nreturn;\r\n}\r\nif (par->depth == 1)\r\ncolor = rect->color;\r\nelse\r\ncolor = ((u32 *) (info->pseudo_palette))[rect->color];\r\nrop = i810fb_rop[rect->rop];\r\ndx = rect->dx * par->depth;\r\nwidth = rect->width * par->depth;\r\ndy = rect->dy;\r\nheight = rect->height;\r\ndest = info->fix.smem_start + (dy * info->fix.line_length) + dx;\r\ncolor_blit(width, height, info->fix.line_length, dest, rop, color,\r\npar->blit_bpp, info);\r\n}\r\nvoid i810fb_copyarea(struct fb_info *info, const struct fb_copyarea *region)\r\n{\r\nstruct i810fb_par *par = info->par;\r\nu32 sx, sy, dx, dy, pitch, width, height, src, dest, xdir;\r\nif (!info->var.accel_flags || par->dev_flags & LOCKUP ||\r\npar->depth == 4) {\r\ncfb_copyarea(info, region);\r\nreturn;\r\n}\r\ndx = region->dx * par->depth;\r\nsx = region->sx * par->depth;\r\nwidth = region->width * par->depth;\r\nsy = region->sy;\r\ndy = region->dy;\r\nheight = region->height;\r\nif (dx <= sx) {\r\nxdir = INCREMENT;\r\n}\r\nelse {\r\nxdir = DECREMENT;\r\nsx += width - 1;\r\ndx += width - 1;\r\n}\r\nif (dy <= sy) {\r\npitch = info->fix.line_length;\r\n}\r\nelse {\r\npitch = (-(info->fix.line_length)) & 0xFFFF;\r\nsy += height - 1;\r\ndy += height - 1;\r\n}\r\nsrc = info->fix.smem_start + (sy * info->fix.line_length) + sx;\r\ndest = info->fix.smem_start + (dy * info->fix.line_length) + dx;\r\nsource_copy_blit(width, height, pitch, xdir, src, dest,\r\nPAT_COPY_ROP, par->blit_bpp, info);\r\n}\r\nvoid i810fb_imageblit(struct fb_info *info, const struct fb_image *image)\r\n{\r\nstruct i810fb_par *par = info->par;\r\nu32 fg = 0, bg = 0, size, dst;\r\nif (!info->var.accel_flags || par->dev_flags & LOCKUP ||\r\npar->depth == 4 || image->depth != 1) {\r\ncfb_imageblit(info, image);\r\nreturn;\r\n}\r\nswitch (info->var.bits_per_pixel) {\r\ncase 8:\r\nfg = image->fg_color;\r\nbg = image->bg_color;\r\nbreak;\r\ncase 16:\r\ncase 24:\r\nfg = ((u32 *)(info->pseudo_palette))[image->fg_color];\r\nbg = ((u32 *)(info->pseudo_palette))[image->bg_color];\r\nbreak;\r\n}\r\ndst = info->fix.smem_start + (image->dy * info->fix.line_length) +\r\n(image->dx * par->depth);\r\nsize = (image->width+7)/8 + 1;\r\nsize &= ~1;\r\nsize *= image->height;\r\nsize += 7;\r\nsize &= ~7;\r\nmono_src_copy_imm_blit(image->width * par->depth,\r\nimage->height, info->fix.line_length,\r\nsize/4, par->blit_bpp,\r\nPAT_COPY_ROP, dst, (u32 *) image->data,\r\nbg, fg, info);\r\n}\r\nint i810fb_sync(struct fb_info *info)\r\n{\r\nstruct i810fb_par *par = info->par;\r\nif (!info->var.accel_flags || par->dev_flags & LOCKUP)\r\nreturn 0;\r\nreturn wait_for_engine_idle(info);\r\n}\r\nvoid i810fb_load_front(u32 offset, struct fb_info *info)\r\n{\r\nstruct i810fb_par *par = info->par;\r\nu8 __iomem *mmio = par->mmio_start_virtual;\r\nif (!info->var.accel_flags || par->dev_flags & LOCKUP)\r\ni810_writel(DPLYBASE, mmio, par->fb.physical + offset);\r\nelse\r\nload_front(offset, info);\r\n}\r\nvoid i810fb_init_ringbuffer(struct fb_info *info)\r\n{\r\nstruct i810fb_par *par = info->par;\r\nu32 tmp1, tmp2;\r\nu8 __iomem *mmio = par->mmio_start_virtual;\r\nwait_for_engine_idle(info);\r\ni810fb_iring_enable(par, OFF);\r\ni810_writel(IRING, mmio, 0);\r\ni810_writel(IRING + 4, mmio, 0);\r\npar->cur_tail = 0;\r\ntmp2 = i810_readl(IRING + 8, mmio) & ~RBUFFER_START_MASK;\r\ntmp1 = par->iring.physical;\r\ni810_writel(IRING + 8, mmio, tmp2 | tmp1);\r\ntmp1 = i810_readl(IRING + 12, mmio);\r\ntmp1 &= ~RBUFFER_SIZE_MASK;\r\ntmp2 = (par->iring.size - I810_PAGESIZE) & RBUFFER_SIZE_MASK;\r\ni810_writel(IRING + 12, mmio, tmp1 | tmp2);\r\ni810fb_iring_enable(par, ON);\r\n}
