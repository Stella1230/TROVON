static int max77843_muic_set_path(struct max77843_muic_info *info,\r\nu8 val, bool attached)\r\n{\r\nstruct max77693_dev *max77843 = info->max77843;\r\nint ret = 0;\r\nunsigned int ctrl1, ctrl2;\r\nif (attached)\r\nctrl1 = val;\r\nelse\r\nctrl1 = MAX77843_MUIC_CONTROL1_SW_OPEN;\r\nret = regmap_update_bits(max77843->regmap_muic,\r\nMAX77843_MUIC_REG_CONTROL1,\r\nMAX77843_MUIC_CONTROL1_COM_SW, ctrl1);\r\nif (ret < 0) {\r\ndev_err(info->dev, "Cannot switch MUIC port\n");\r\nreturn ret;\r\n}\r\nif (attached)\r\nctrl2 = MAX77843_MUIC_CONTROL2_CPEN_MASK;\r\nelse\r\nctrl2 = MAX77843_MUIC_CONTROL2_LOWPWR_MASK;\r\nret = regmap_update_bits(max77843->regmap_muic,\r\nMAX77843_MUIC_REG_CONTROL2,\r\nMAX77843_MUIC_CONTROL2_LOWPWR_MASK |\r\nMAX77843_MUIC_CONTROL2_CPEN_MASK, ctrl2);\r\nif (ret < 0) {\r\ndev_err(info->dev, "Cannot update lowpower mode\n");\r\nreturn ret;\r\n}\r\ndev_dbg(info->dev,\r\n"CONTROL1 : 0x%02x, CONTROL2 : 0x%02x, state : %s\n",\r\nctrl1, ctrl2, attached ? "attached" : "detached");\r\nreturn 0;\r\n}\r\nstatic int max77843_muic_get_cable_type(struct max77843_muic_info *info,\r\nenum max77843_muic_cable_group group, bool *attached)\r\n{\r\nint adc, chg_type, cable_type, gnd_type;\r\nadc = info->status[MAX77843_MUIC_STATUS1] &\r\nMAX77843_MUIC_STATUS1_ADC_MASK;\r\nadc >>= MAX77843_MUIC_STATUS1_ADC_SHIFT;\r\nswitch (group) {\r\ncase MAX77843_CABLE_GROUP_ADC:\r\nif (adc == MAX77843_MUIC_ADC_OPEN) {\r\n*attached = false;\r\ncable_type = info->prev_cable_type;\r\ninfo->prev_cable_type = MAX77843_MUIC_ADC_OPEN;\r\n} else {\r\n*attached = true;\r\ncable_type = info->prev_cable_type = adc;\r\n}\r\nbreak;\r\ncase MAX77843_CABLE_GROUP_CHG:\r\nchg_type = info->status[MAX77843_MUIC_STATUS2] &\r\nMAX77843_MUIC_STATUS2_CHGTYP_MASK;\r\nif (adc == MAX77843_MUIC_ADC_GROUND) {\r\nif (chg_type == MAX77843_MUIC_CHG_NONE) {\r\n*attached = false;\r\ncable_type = info->prev_chg_type;\r\ninfo->prev_chg_type = MAX77843_MUIC_CHG_NONE;\r\n} else {\r\n*attached = true;\r\ncable_type = MAX77843_MUIC_CHG_GND;\r\ninfo->prev_chg_type = MAX77843_MUIC_CHG_GND;\r\n}\r\nbreak;\r\n}\r\nif (chg_type == MAX77843_MUIC_CHG_NONE) {\r\n*attached = false;\r\ncable_type = info->prev_chg_type;\r\ninfo->prev_chg_type = MAX77843_MUIC_CHG_NONE;\r\n} else {\r\n*attached = true;\r\ncable_type = info->prev_chg_type = chg_type;\r\n}\r\nbreak;\r\ncase MAX77843_CABLE_GROUP_ADC_GND:\r\nif (adc == MAX77843_MUIC_ADC_OPEN) {\r\n*attached = false;\r\ncable_type = info->prev_gnd_type;\r\ninfo->prev_gnd_type = MAX77843_MUIC_ADC_OPEN;\r\n} else {\r\n*attached = true;\r\ngnd_type = (info->status[MAX77843_MUIC_STATUS1] &\r\nMAX77843_MUIC_STATUS1_ADC1K_MASK);\r\ngnd_type |= (info->status[MAX77843_MUIC_STATUS2] &\r\nMAX77843_MUIC_STATUS2_VBVOLT_MASK);\r\ngnd_type >>= MAX77843_MUIC_STATUS2_VBVOLT_SHIFT;\r\ngnd_type |= MAX77843_MUIC_GND_USB_HOST;\r\ncable_type = info->prev_gnd_type = gnd_type;\r\n}\r\nbreak;\r\ndefault:\r\ndev_err(info->dev, "Unknown cable group (%d)\n", group);\r\ncable_type = -EINVAL;\r\nbreak;\r\n}\r\nreturn cable_type;\r\n}\r\nstatic int max77843_muic_adc_gnd_handler(struct max77843_muic_info *info)\r\n{\r\nint ret, gnd_cable_type;\r\nbool attached;\r\ngnd_cable_type = max77843_muic_get_cable_type(info,\r\nMAX77843_CABLE_GROUP_ADC_GND, &attached);\r\ndev_dbg(info->dev, "external connector is %s (gnd:0x%02x)\n",\r\nattached ? "attached" : "detached", gnd_cable_type);\r\nswitch (gnd_cable_type) {\r\ncase MAX77843_MUIC_GND_USB_HOST:\r\ncase MAX77843_MUIC_GND_USB_HOST_VB:\r\nret = max77843_muic_set_path(info,\r\nMAX77843_MUIC_CONTROL1_SW_USB,\r\nattached);\r\nif (ret < 0)\r\nreturn ret;\r\nextcon_set_cable_state_(info->edev, EXTCON_USB_HOST, attached);\r\nbreak;\r\ncase MAX77843_MUIC_GND_MHL_VB:\r\ncase MAX77843_MUIC_GND_MHL:\r\nret = max77843_muic_set_path(info,\r\nMAX77843_MUIC_CONTROL1_SW_OPEN,\r\nattached);\r\nif (ret < 0)\r\nreturn ret;\r\nextcon_set_cable_state_(info->edev, EXTCON_DISP_MHL, attached);\r\nbreak;\r\ndefault:\r\ndev_err(info->dev, "failed to detect %s accessory(gnd:0x%x)\n",\r\nattached ? "attached" : "detached", gnd_cable_type);\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int max77843_muic_jig_handler(struct max77843_muic_info *info,\r\nint cable_type, bool attached)\r\n{\r\nint ret;\r\nu8 path = MAX77843_MUIC_CONTROL1_SW_OPEN;\r\ndev_dbg(info->dev, "external connector is %s (adc:0x%02x)\n",\r\nattached ? "attached" : "detached", cable_type);\r\nswitch (cable_type) {\r\ncase MAX77843_MUIC_ADC_FACTORY_MODE_USB_OFF:\r\ncase MAX77843_MUIC_ADC_FACTORY_MODE_USB_ON:\r\npath = MAX77843_MUIC_CONTROL1_SW_USB;\r\nbreak;\r\ncase MAX77843_MUIC_ADC_FACTORY_MODE_UART_OFF:\r\npath = MAX77843_MUIC_CONTROL1_SW_UART;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nret = max77843_muic_set_path(info, path, attached);\r\nif (ret < 0)\r\nreturn ret;\r\nextcon_set_cable_state_(info->edev, EXTCON_JIG, attached);\r\nreturn 0;\r\n}\r\nstatic int max77843_muic_adc_handler(struct max77843_muic_info *info)\r\n{\r\nint ret, cable_type;\r\nbool attached;\r\ncable_type = max77843_muic_get_cable_type(info,\r\nMAX77843_CABLE_GROUP_ADC, &attached);\r\ndev_dbg(info->dev,\r\n"external connector is %s (adc:0x%02x, prev_adc:0x%x)\n",\r\nattached ? "attached" : "detached", cable_type,\r\ninfo->prev_cable_type);\r\nswitch (cable_type) {\r\ncase MAX77843_MUIC_ADC_GROUND:\r\nret = max77843_muic_adc_gnd_handler(info);\r\nif (ret < 0)\r\nreturn ret;\r\nbreak;\r\ncase MAX77843_MUIC_ADC_FACTORY_MODE_USB_OFF:\r\ncase MAX77843_MUIC_ADC_FACTORY_MODE_USB_ON:\r\ncase MAX77843_MUIC_ADC_FACTORY_MODE_UART_OFF:\r\nret = max77843_muic_jig_handler(info, cable_type, attached);\r\nif (ret < 0)\r\nreturn ret;\r\nbreak;\r\ncase MAX77843_MUIC_ADC_SEND_END_BUTTON:\r\ncase MAX77843_MUIC_ADC_REMOTE_S1_BUTTON:\r\ncase MAX77843_MUIC_ADC_REMOTE_S2_BUTTON:\r\ncase MAX77843_MUIC_ADC_REMOTE_S3_BUTTON:\r\ncase MAX77843_MUIC_ADC_REMOTE_S4_BUTTON:\r\ncase MAX77843_MUIC_ADC_REMOTE_S5_BUTTON:\r\ncase MAX77843_MUIC_ADC_REMOTE_S6_BUTTON:\r\ncase MAX77843_MUIC_ADC_REMOTE_S7_BUTTON:\r\ncase MAX77843_MUIC_ADC_REMOTE_S8_BUTTON:\r\ncase MAX77843_MUIC_ADC_REMOTE_S9_BUTTON:\r\ncase MAX77843_MUIC_ADC_REMOTE_S10_BUTTON:\r\ncase MAX77843_MUIC_ADC_REMOTE_S11_BUTTON:\r\ncase MAX77843_MUIC_ADC_REMOTE_S12_BUTTON:\r\ncase MAX77843_MUIC_ADC_RESERVED_ACC_1:\r\ncase MAX77843_MUIC_ADC_RESERVED_ACC_2:\r\ncase MAX77843_MUIC_ADC_RESERVED_ACC_3:\r\ncase MAX77843_MUIC_ADC_RESERVED_ACC_4:\r\ncase MAX77843_MUIC_ADC_RESERVED_ACC_5:\r\ncase MAX77843_MUIC_ADC_AUDIO_DEVICE_TYPE2:\r\ncase MAX77843_MUIC_ADC_PHONE_POWERED_DEV:\r\ncase MAX77843_MUIC_ADC_TTY_CONVERTER:\r\ncase MAX77843_MUIC_ADC_UART_CABLE:\r\ncase MAX77843_MUIC_ADC_CEA936A_TYPE1_CHG:\r\ncase MAX77843_MUIC_ADC_AV_CABLE_NOLOAD:\r\ncase MAX77843_MUIC_ADC_CEA936A_TYPE2_CHG:\r\ncase MAX77843_MUIC_ADC_FACTORY_MODE_UART_ON:\r\ncase MAX77843_MUIC_ADC_AUDIO_DEVICE_TYPE1:\r\ncase MAX77843_MUIC_ADC_OPEN:\r\ndev_err(info->dev,\r\n"accessory is %s but it isn't used (adc:0x%x)\n",\r\nattached ? "attached" : "detached", cable_type);\r\nreturn -EAGAIN;\r\ndefault:\r\ndev_err(info->dev,\r\n"failed to detect %s accessory (adc:0x%x)\n",\r\nattached ? "attached" : "detached", cable_type);\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int max77843_muic_chg_handler(struct max77843_muic_info *info)\r\n{\r\nint ret, chg_type, gnd_type;\r\nbool attached;\r\nchg_type = max77843_muic_get_cable_type(info,\r\nMAX77843_CABLE_GROUP_CHG, &attached);\r\ndev_dbg(info->dev,\r\n"external connector is %s(chg_type:0x%x, prev_chg_type:0x%x)\n",\r\nattached ? "attached" : "detached",\r\nchg_type, info->prev_chg_type);\r\nswitch (chg_type) {\r\ncase MAX77843_MUIC_CHG_USB:\r\nret = max77843_muic_set_path(info,\r\nMAX77843_MUIC_CONTROL1_SW_USB,\r\nattached);\r\nif (ret < 0)\r\nreturn ret;\r\nextcon_set_cable_state_(info->edev, EXTCON_USB, attached);\r\nextcon_set_cable_state_(info->edev, EXTCON_CHG_USB_SDP,\r\nattached);\r\nbreak;\r\ncase MAX77843_MUIC_CHG_DOWNSTREAM:\r\nret = max77843_muic_set_path(info,\r\nMAX77843_MUIC_CONTROL1_SW_OPEN,\r\nattached);\r\nif (ret < 0)\r\nreturn ret;\r\nextcon_set_cable_state_(info->edev, EXTCON_CHG_USB_CDP,\r\nattached);\r\nbreak;\r\ncase MAX77843_MUIC_CHG_DEDICATED:\r\nret = max77843_muic_set_path(info,\r\nMAX77843_MUIC_CONTROL1_SW_OPEN,\r\nattached);\r\nif (ret < 0)\r\nreturn ret;\r\nextcon_set_cable_state_(info->edev, EXTCON_CHG_USB_DCP,\r\nattached);\r\nbreak;\r\ncase MAX77843_MUIC_CHG_SPECIAL_500MA:\r\nret = max77843_muic_set_path(info,\r\nMAX77843_MUIC_CONTROL1_SW_OPEN,\r\nattached);\r\nif (ret < 0)\r\nreturn ret;\r\nextcon_set_cable_state_(info->edev, EXTCON_CHG_USB_SLOW,\r\nattached);\r\nbreak;\r\ncase MAX77843_MUIC_CHG_SPECIAL_1A:\r\nret = max77843_muic_set_path(info,\r\nMAX77843_MUIC_CONTROL1_SW_OPEN,\r\nattached);\r\nif (ret < 0)\r\nreturn ret;\r\nextcon_set_cable_state_(info->edev, EXTCON_CHG_USB_FAST,\r\nattached);\r\nbreak;\r\ncase MAX77843_MUIC_CHG_GND:\r\ngnd_type = max77843_muic_get_cable_type(info,\r\nMAX77843_CABLE_GROUP_ADC_GND, &attached);\r\nif (gnd_type == MAX77843_MUIC_GND_MHL_VB)\r\nextcon_set_cable_state_(info->edev, EXTCON_CHG_USB_DCP,\r\ntrue);\r\nelse if (gnd_type == MAX77843_MUIC_GND_MHL)\r\nextcon_set_cable_state_(info->edev, EXTCON_CHG_USB_DCP,\r\nfalse);\r\nbreak;\r\ncase MAX77843_MUIC_CHG_NONE:\r\nbreak;\r\ndefault:\r\ndev_err(info->dev,\r\n"failed to detect %s accessory (chg_type:0x%x)\n",\r\nattached ? "attached" : "detached", chg_type);\r\nmax77843_muic_set_path(info, MAX77843_MUIC_CONTROL1_SW_OPEN,\r\nattached);\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic void max77843_muic_irq_work(struct work_struct *work)\r\n{\r\nstruct max77843_muic_info *info = container_of(work,\r\nstruct max77843_muic_info, irq_work);\r\nstruct max77693_dev *max77843 = info->max77843;\r\nint ret = 0;\r\nmutex_lock(&info->mutex);\r\nret = regmap_bulk_read(max77843->regmap_muic,\r\nMAX77843_MUIC_REG_STATUS1, info->status,\r\nMAX77843_MUIC_STATUS_NUM);\r\nif (ret) {\r\ndev_err(info->dev, "Cannot read STATUS registers\n");\r\nmutex_unlock(&info->mutex);\r\nreturn;\r\n}\r\nif (info->irq_adc) {\r\nret = max77843_muic_adc_handler(info);\r\nif (ret)\r\ndev_err(info->dev, "Unknown cable type\n");\r\ninfo->irq_adc = false;\r\n}\r\nif (info->irq_chg) {\r\nret = max77843_muic_chg_handler(info);\r\nif (ret)\r\ndev_err(info->dev, "Unknown charger type\n");\r\ninfo->irq_chg = false;\r\n}\r\nmutex_unlock(&info->mutex);\r\n}\r\nstatic irqreturn_t max77843_muic_irq_handler(int irq, void *data)\r\n{\r\nstruct max77843_muic_info *info = data;\r\nint i, irq_type = -1;\r\nfor (i = 0; i < ARRAY_SIZE(max77843_muic_irqs); i++)\r\nif (irq == max77843_muic_irqs[i].virq)\r\nirq_type = max77843_muic_irqs[i].irq;\r\nswitch (irq_type) {\r\ncase MAX77843_MUIC_IRQ_INT1_ADC:\r\ncase MAX77843_MUIC_IRQ_INT1_ADCERROR:\r\ncase MAX77843_MUIC_IRQ_INT1_ADC1K:\r\ninfo->irq_adc = true;\r\nbreak;\r\ncase MAX77843_MUIC_IRQ_INT2_CHGTYP:\r\ncase MAX77843_MUIC_IRQ_INT2_CHGDETRUN:\r\ncase MAX77843_MUIC_IRQ_INT2_DCDTMR:\r\ncase MAX77843_MUIC_IRQ_INT2_DXOVP:\r\ncase MAX77843_MUIC_IRQ_INT2_VBVOLT:\r\ninfo->irq_chg = true;\r\nbreak;\r\ncase MAX77843_MUIC_IRQ_INT3_VBADC:\r\ncase MAX77843_MUIC_IRQ_INT3_VDNMON:\r\ncase MAX77843_MUIC_IRQ_INT3_DNRES:\r\ncase MAX77843_MUIC_IRQ_INT3_MPNACK:\r\ncase MAX77843_MUIC_IRQ_INT3_MRXBUFOW:\r\ncase MAX77843_MUIC_IRQ_INT3_MRXTRF:\r\ncase MAX77843_MUIC_IRQ_INT3_MRXPERR:\r\ncase MAX77843_MUIC_IRQ_INT3_MRXRDY:\r\nbreak;\r\ndefault:\r\ndev_err(info->dev, "Cannot recognize IRQ(%d)\n", irq_type);\r\nbreak;\r\n}\r\nschedule_work(&info->irq_work);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void max77843_muic_detect_cable_wq(struct work_struct *work)\r\n{\r\nstruct max77843_muic_info *info = container_of(to_delayed_work(work),\r\nstruct max77843_muic_info, wq_detcable);\r\nstruct max77693_dev *max77843 = info->max77843;\r\nint chg_type, adc, ret;\r\nbool attached;\r\nmutex_lock(&info->mutex);\r\nret = regmap_bulk_read(max77843->regmap_muic,\r\nMAX77843_MUIC_REG_STATUS1, info->status,\r\nMAX77843_MUIC_STATUS_NUM);\r\nif (ret) {\r\ndev_err(info->dev, "Cannot read STATUS registers\n");\r\ngoto err_cable_wq;\r\n}\r\nadc = max77843_muic_get_cable_type(info,\r\nMAX77843_CABLE_GROUP_ADC, &attached);\r\nif (attached && adc != MAX77843_MUIC_ADC_OPEN) {\r\nret = max77843_muic_adc_handler(info);\r\nif (ret < 0) {\r\ndev_err(info->dev, "Cannot detect accessory\n");\r\ngoto err_cable_wq;\r\n}\r\n}\r\nchg_type = max77843_muic_get_cable_type(info,\r\nMAX77843_CABLE_GROUP_CHG, &attached);\r\nif (attached && chg_type != MAX77843_MUIC_CHG_NONE) {\r\nret = max77843_muic_chg_handler(info);\r\nif (ret < 0) {\r\ndev_err(info->dev, "Cannot detect charger accessory\n");\r\ngoto err_cable_wq;\r\n}\r\n}\r\nerr_cable_wq:\r\nmutex_unlock(&info->mutex);\r\n}\r\nstatic int max77843_muic_set_debounce_time(struct max77843_muic_info *info,\r\nenum max77843_muic_adc_debounce_time time)\r\n{\r\nstruct max77693_dev *max77843 = info->max77843;\r\nint ret;\r\nswitch (time) {\r\ncase MAX77843_DEBOUNCE_TIME_5MS:\r\ncase MAX77843_DEBOUNCE_TIME_10MS:\r\ncase MAX77843_DEBOUNCE_TIME_25MS:\r\ncase MAX77843_DEBOUNCE_TIME_38_62MS:\r\nret = regmap_update_bits(max77843->regmap_muic,\r\nMAX77843_MUIC_REG_CONTROL4,\r\nMAX77843_MUIC_CONTROL4_ADCDBSET_MASK,\r\ntime << MAX77843_MUIC_CONTROL4_ADCDBSET_SHIFT);\r\nif (ret < 0) {\r\ndev_err(info->dev, "Cannot write MUIC regmap\n");\r\nreturn ret;\r\n}\r\nbreak;\r\ndefault:\r\ndev_err(info->dev, "Invalid ADC debounce time\n");\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int max77843_init_muic_regmap(struct max77693_dev *max77843)\r\n{\r\nint ret;\r\nmax77843->i2c_muic = i2c_new_dummy(max77843->i2c->adapter,\r\nI2C_ADDR_MUIC);\r\nif (!max77843->i2c_muic) {\r\ndev_err(&max77843->i2c->dev,\r\n"Cannot allocate I2C device for MUIC\n");\r\nreturn -ENOMEM;\r\n}\r\ni2c_set_clientdata(max77843->i2c_muic, max77843);\r\nmax77843->regmap_muic = devm_regmap_init_i2c(max77843->i2c_muic,\r\n&max77843_muic_regmap_config);\r\nif (IS_ERR(max77843->regmap_muic)) {\r\nret = PTR_ERR(max77843->regmap_muic);\r\ngoto err_muic_i2c;\r\n}\r\nret = regmap_add_irq_chip(max77843->regmap_muic, max77843->irq,\r\nIRQF_TRIGGER_LOW | IRQF_ONESHOT | IRQF_SHARED,\r\n0, &max77843_muic_irq_chip, &max77843->irq_data_muic);\r\nif (ret < 0) {\r\ndev_err(&max77843->i2c->dev, "Cannot add MUIC IRQ chip\n");\r\ngoto err_muic_i2c;\r\n}\r\nreturn 0;\r\nerr_muic_i2c:\r\ni2c_unregister_device(max77843->i2c_muic);\r\nreturn ret;\r\n}\r\nstatic int max77843_muic_probe(struct platform_device *pdev)\r\n{\r\nstruct max77693_dev *max77843 = dev_get_drvdata(pdev->dev.parent);\r\nstruct max77843_muic_info *info;\r\nunsigned int id;\r\nint i, ret;\r\ninfo = devm_kzalloc(&pdev->dev, sizeof(*info), GFP_KERNEL);\r\nif (!info)\r\nreturn -ENOMEM;\r\ninfo->dev = &pdev->dev;\r\ninfo->max77843 = max77843;\r\nplatform_set_drvdata(pdev, info);\r\nmutex_init(&info->mutex);\r\nret = max77843_init_muic_regmap(max77843);\r\nif (ret) {\r\ndev_err(&pdev->dev, "Failed to init MUIC regmap\n");\r\nreturn ret;\r\n}\r\nret = regmap_update_bits(max77843->regmap_muic,\r\nMAX77843_MUIC_REG_CONTROL4,\r\nMAX77843_MUIC_CONTROL4_USBAUTO_MASK |\r\nMAX77843_MUIC_CONTROL4_FCTAUTO_MASK,\r\nCONTROL4_AUTO_DISABLE);\r\ninfo->edev = devm_extcon_dev_allocate(&pdev->dev,\r\nmax77843_extcon_cable);\r\nif (IS_ERR(info->edev)) {\r\ndev_err(&pdev->dev, "Failed to allocate memory for extcon\n");\r\nret = -ENODEV;\r\ngoto err_muic_irq;\r\n}\r\nret = devm_extcon_dev_register(&pdev->dev, info->edev);\r\nif (ret) {\r\ndev_err(&pdev->dev, "Failed to register extcon device\n");\r\ngoto err_muic_irq;\r\n}\r\nmax77843_muic_set_debounce_time(info, MAX77843_DEBOUNCE_TIME_25MS);\r\nmax77843_muic_set_path(info, MAX77843_MUIC_CONTROL1_SW_UART, true);\r\nret = regmap_read(max77843->regmap_muic, MAX77843_MUIC_REG_ID, &id);\r\nif (ret < 0) {\r\ndev_err(&pdev->dev, "Failed to read revision number\n");\r\ngoto err_muic_irq;\r\n}\r\ndev_info(info->dev, "MUIC device ID : 0x%x\n", id);\r\nINIT_WORK(&info->irq_work, max77843_muic_irq_work);\r\nret = regmap_bulk_read(max77843->regmap_muic,\r\nMAX77843_MUIC_REG_INT1, info->status,\r\nMAX77843_MUIC_STATUS_NUM);\r\nif (ret) {\r\ndev_err(&pdev->dev, "Failed to Clear IRQ bits\n");\r\ngoto err_muic_irq;\r\n}\r\nfor (i = 0; i < ARRAY_SIZE(max77843_muic_irqs); i++) {\r\nstruct max77843_muic_irq *muic_irq = &max77843_muic_irqs[i];\r\nint virq = 0;\r\nvirq = regmap_irq_get_virq(max77843->irq_data_muic,\r\nmuic_irq->irq);\r\nif (virq <= 0) {\r\nret = -EINVAL;\r\ngoto err_muic_irq;\r\n}\r\nmuic_irq->virq = virq;\r\nret = devm_request_threaded_irq(&pdev->dev, virq, NULL,\r\nmax77843_muic_irq_handler, IRQF_NO_SUSPEND,\r\nmuic_irq->name, info);\r\nif (ret) {\r\ndev_err(&pdev->dev,\r\n"Failed to request irq (IRQ: %d, error: %d)\n",\r\nmuic_irq->irq, ret);\r\ngoto err_muic_irq;\r\n}\r\n}\r\nINIT_DELAYED_WORK(&info->wq_detcable, max77843_muic_detect_cable_wq);\r\nqueue_delayed_work(system_power_efficient_wq,\r\n&info->wq_detcable, msecs_to_jiffies(DELAY_MS_DEFAULT));\r\nreturn 0;\r\nerr_muic_irq:\r\nregmap_del_irq_chip(max77843->irq, max77843->irq_data_muic);\r\ni2c_unregister_device(max77843->i2c_muic);\r\nreturn ret;\r\n}\r\nstatic int max77843_muic_remove(struct platform_device *pdev)\r\n{\r\nstruct max77843_muic_info *info = platform_get_drvdata(pdev);\r\nstruct max77693_dev *max77843 = info->max77843;\r\ncancel_work_sync(&info->irq_work);\r\nregmap_del_irq_chip(max77843->irq, max77843->irq_data_muic);\r\ni2c_unregister_device(max77843->i2c_muic);\r\nreturn 0;\r\n}\r\nstatic int __init max77843_muic_init(void)\r\n{\r\nreturn platform_driver_register(&max77843_muic_driver);\r\n}
