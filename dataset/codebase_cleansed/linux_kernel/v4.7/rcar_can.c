static void tx_failure_cleanup(struct net_device *ndev)\r\n{\r\nint i;\r\nfor (i = 0; i < RCAR_CAN_FIFO_DEPTH; i++)\r\ncan_free_echo_skb(ndev, i);\r\n}\r\nstatic void rcar_can_error(struct net_device *ndev)\r\n{\r\nstruct rcar_can_priv *priv = netdev_priv(ndev);\r\nstruct net_device_stats *stats = &ndev->stats;\r\nstruct can_frame *cf;\r\nstruct sk_buff *skb;\r\nu8 eifr, txerr = 0, rxerr = 0;\r\nskb = alloc_can_err_skb(ndev, &cf);\r\neifr = readb(&priv->regs->eifr);\r\nif (eifr & (RCAR_CAN_EIFR_EWIF | RCAR_CAN_EIFR_EPIF)) {\r\ntxerr = readb(&priv->regs->tecr);\r\nrxerr = readb(&priv->regs->recr);\r\nif (skb) {\r\ncf->can_id |= CAN_ERR_CRTL;\r\ncf->data[6] = txerr;\r\ncf->data[7] = rxerr;\r\n}\r\n}\r\nif (eifr & RCAR_CAN_EIFR_BEIF) {\r\nint rx_errors = 0, tx_errors = 0;\r\nu8 ecsr;\r\nnetdev_dbg(priv->ndev, "Bus error interrupt:\n");\r\nif (skb)\r\ncf->can_id |= CAN_ERR_BUSERROR | CAN_ERR_PROT;\r\necsr = readb(&priv->regs->ecsr);\r\nif (ecsr & RCAR_CAN_ECSR_ADEF) {\r\nnetdev_dbg(priv->ndev, "ACK Delimiter Error\n");\r\ntx_errors++;\r\nwriteb(~RCAR_CAN_ECSR_ADEF, &priv->regs->ecsr);\r\nif (skb)\r\ncf->data[3] = CAN_ERR_PROT_LOC_ACK_DEL;\r\n}\r\nif (ecsr & RCAR_CAN_ECSR_BE0F) {\r\nnetdev_dbg(priv->ndev, "Bit Error (dominant)\n");\r\ntx_errors++;\r\nwriteb(~RCAR_CAN_ECSR_BE0F, &priv->regs->ecsr);\r\nif (skb)\r\ncf->data[2] |= CAN_ERR_PROT_BIT0;\r\n}\r\nif (ecsr & RCAR_CAN_ECSR_BE1F) {\r\nnetdev_dbg(priv->ndev, "Bit Error (recessive)\n");\r\ntx_errors++;\r\nwriteb(~RCAR_CAN_ECSR_BE1F, &priv->regs->ecsr);\r\nif (skb)\r\ncf->data[2] |= CAN_ERR_PROT_BIT1;\r\n}\r\nif (ecsr & RCAR_CAN_ECSR_CEF) {\r\nnetdev_dbg(priv->ndev, "CRC Error\n");\r\nrx_errors++;\r\nwriteb(~RCAR_CAN_ECSR_CEF, &priv->regs->ecsr);\r\nif (skb)\r\ncf->data[3] = CAN_ERR_PROT_LOC_CRC_SEQ;\r\n}\r\nif (ecsr & RCAR_CAN_ECSR_AEF) {\r\nnetdev_dbg(priv->ndev, "ACK Error\n");\r\ntx_errors++;\r\nwriteb(~RCAR_CAN_ECSR_AEF, &priv->regs->ecsr);\r\nif (skb) {\r\ncf->can_id |= CAN_ERR_ACK;\r\ncf->data[3] = CAN_ERR_PROT_LOC_ACK;\r\n}\r\n}\r\nif (ecsr & RCAR_CAN_ECSR_FEF) {\r\nnetdev_dbg(priv->ndev, "Form Error\n");\r\nrx_errors++;\r\nwriteb(~RCAR_CAN_ECSR_FEF, &priv->regs->ecsr);\r\nif (skb)\r\ncf->data[2] |= CAN_ERR_PROT_FORM;\r\n}\r\nif (ecsr & RCAR_CAN_ECSR_SEF) {\r\nnetdev_dbg(priv->ndev, "Stuff Error\n");\r\nrx_errors++;\r\nwriteb(~RCAR_CAN_ECSR_SEF, &priv->regs->ecsr);\r\nif (skb)\r\ncf->data[2] |= CAN_ERR_PROT_STUFF;\r\n}\r\npriv->can.can_stats.bus_error++;\r\nndev->stats.rx_errors += rx_errors;\r\nndev->stats.tx_errors += tx_errors;\r\nwriteb(~RCAR_CAN_EIFR_BEIF, &priv->regs->eifr);\r\n}\r\nif (eifr & RCAR_CAN_EIFR_EWIF) {\r\nnetdev_dbg(priv->ndev, "Error warning interrupt\n");\r\npriv->can.state = CAN_STATE_ERROR_WARNING;\r\npriv->can.can_stats.error_warning++;\r\nwriteb(~RCAR_CAN_EIFR_EWIF, &priv->regs->eifr);\r\nif (skb)\r\ncf->data[1] = txerr > rxerr ? CAN_ERR_CRTL_TX_WARNING :\r\nCAN_ERR_CRTL_RX_WARNING;\r\n}\r\nif (eifr & RCAR_CAN_EIFR_EPIF) {\r\nnetdev_dbg(priv->ndev, "Error passive interrupt\n");\r\npriv->can.state = CAN_STATE_ERROR_PASSIVE;\r\npriv->can.can_stats.error_passive++;\r\nwriteb(~RCAR_CAN_EIFR_EPIF, &priv->regs->eifr);\r\nif (skb)\r\ncf->data[1] = txerr > rxerr ? CAN_ERR_CRTL_TX_PASSIVE :\r\nCAN_ERR_CRTL_RX_PASSIVE;\r\n}\r\nif (eifr & RCAR_CAN_EIFR_BOEIF) {\r\nnetdev_dbg(priv->ndev, "Bus-off entry interrupt\n");\r\ntx_failure_cleanup(ndev);\r\npriv->ier = RCAR_CAN_IER_ERSIE;\r\nwriteb(priv->ier, &priv->regs->ier);\r\npriv->can.state = CAN_STATE_BUS_OFF;\r\nwriteb(~RCAR_CAN_EIFR_BOEIF, &priv->regs->eifr);\r\npriv->can.can_stats.bus_off++;\r\ncan_bus_off(ndev);\r\nif (skb)\r\ncf->can_id |= CAN_ERR_BUSOFF;\r\n}\r\nif (eifr & RCAR_CAN_EIFR_ORIF) {\r\nnetdev_dbg(priv->ndev, "Receive overrun error interrupt\n");\r\nndev->stats.rx_over_errors++;\r\nndev->stats.rx_errors++;\r\nwriteb(~RCAR_CAN_EIFR_ORIF, &priv->regs->eifr);\r\nif (skb) {\r\ncf->can_id |= CAN_ERR_CRTL;\r\ncf->data[1] = CAN_ERR_CRTL_RX_OVERFLOW;\r\n}\r\n}\r\nif (eifr & RCAR_CAN_EIFR_OLIF) {\r\nnetdev_dbg(priv->ndev,\r\n"Overload Frame Transmission error interrupt\n");\r\nndev->stats.rx_over_errors++;\r\nndev->stats.rx_errors++;\r\nwriteb(~RCAR_CAN_EIFR_OLIF, &priv->regs->eifr);\r\nif (skb) {\r\ncf->can_id |= CAN_ERR_PROT;\r\ncf->data[2] |= CAN_ERR_PROT_OVERLOAD;\r\n}\r\n}\r\nif (skb) {\r\nstats->rx_packets++;\r\nstats->rx_bytes += cf->can_dlc;\r\nnetif_rx(skb);\r\n}\r\n}\r\nstatic void rcar_can_tx_done(struct net_device *ndev)\r\n{\r\nstruct rcar_can_priv *priv = netdev_priv(ndev);\r\nstruct net_device_stats *stats = &ndev->stats;\r\nu8 isr;\r\nwhile (1) {\r\nu8 unsent = readb(&priv->regs->tfcr);\r\nunsent = (unsent & RCAR_CAN_TFCR_TFUST) >>\r\nRCAR_CAN_TFCR_TFUST_SHIFT;\r\nif (priv->tx_head - priv->tx_tail <= unsent)\r\nbreak;\r\nstats->tx_packets++;\r\nstats->tx_bytes += priv->tx_dlc[priv->tx_tail %\r\nRCAR_CAN_FIFO_DEPTH];\r\npriv->tx_dlc[priv->tx_tail % RCAR_CAN_FIFO_DEPTH] = 0;\r\ncan_get_echo_skb(ndev, priv->tx_tail % RCAR_CAN_FIFO_DEPTH);\r\npriv->tx_tail++;\r\nnetif_wake_queue(ndev);\r\n}\r\nisr = readb(&priv->regs->isr);\r\nwriteb(isr & ~RCAR_CAN_ISR_TXFF, &priv->regs->isr);\r\ncan_led_event(ndev, CAN_LED_EVENT_TX);\r\n}\r\nstatic irqreturn_t rcar_can_interrupt(int irq, void *dev_id)\r\n{\r\nstruct net_device *ndev = dev_id;\r\nstruct rcar_can_priv *priv = netdev_priv(ndev);\r\nu8 isr;\r\nisr = readb(&priv->regs->isr);\r\nif (!(isr & priv->ier))\r\nreturn IRQ_NONE;\r\nif (isr & RCAR_CAN_ISR_ERSF)\r\nrcar_can_error(ndev);\r\nif (isr & RCAR_CAN_ISR_TXFF)\r\nrcar_can_tx_done(ndev);\r\nif (isr & RCAR_CAN_ISR_RXFF) {\r\nif (napi_schedule_prep(&priv->napi)) {\r\npriv->ier &= ~RCAR_CAN_IER_RXFIE;\r\nwriteb(priv->ier, &priv->regs->ier);\r\n__napi_schedule(&priv->napi);\r\n}\r\n}\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void rcar_can_set_bittiming(struct net_device *dev)\r\n{\r\nstruct rcar_can_priv *priv = netdev_priv(dev);\r\nstruct can_bittiming *bt = &priv->can.bittiming;\r\nu32 bcr;\r\nbcr = RCAR_CAN_BCR_TSEG1(bt->phase_seg1 + bt->prop_seg - 1) |\r\nRCAR_CAN_BCR_BPR(bt->brp - 1) | RCAR_CAN_BCR_SJW(bt->sjw - 1) |\r\nRCAR_CAN_BCR_TSEG2(bt->phase_seg2 - 1);\r\nwritel((bcr << 8) | priv->clock_select, &priv->regs->bcr);\r\n}\r\nstatic void rcar_can_start(struct net_device *ndev)\r\n{\r\nstruct rcar_can_priv *priv = netdev_priv(ndev);\r\nu16 ctlr;\r\nint i;\r\nctlr = readw(&priv->regs->ctlr);\r\nctlr &= ~RCAR_CAN_CTLR_SLPM;\r\nwritew(ctlr, &priv->regs->ctlr);\r\nctlr |= RCAR_CAN_CTLR_CANM_FORCE_RESET;\r\nwritew(ctlr, &priv->regs->ctlr);\r\nfor (i = 0; i < MAX_STR_READS; i++) {\r\nif (readw(&priv->regs->str) & RCAR_CAN_STR_RSTST)\r\nbreak;\r\n}\r\nrcar_can_set_bittiming(ndev);\r\nctlr |= RCAR_CAN_CTLR_IDFM_MIXED;\r\nctlr |= RCAR_CAN_CTLR_BOM_ENT;\r\nctlr |= RCAR_CAN_CTLR_MBM;\r\nctlr |= RCAR_CAN_CTLR_MLM;\r\nwritew(ctlr, &priv->regs->ctlr);\r\nwritel(0, &priv->regs->mkr_2_9[6]);\r\nwritel(0, &priv->regs->mkr_2_9[7]);\r\nwritel(0, &priv->regs->mkivlr1);\r\nwritel(0, &priv->regs->fidcr[0]);\r\nwritel(RCAR_CAN_FIDCR_IDE | RCAR_CAN_FIDCR_RTR, &priv->regs->fidcr[1]);\r\nwritel(RCAR_CAN_MIER1_RXFIE | RCAR_CAN_MIER1_TXFIE, &priv->regs->mier1);\r\npriv->ier = RCAR_CAN_IER_ERSIE | RCAR_CAN_IER_RXFIE |\r\nRCAR_CAN_IER_TXFIE;\r\nwriteb(priv->ier, &priv->regs->ier);\r\nwriteb(RCAR_CAN_ECSR_EDPM, &priv->regs->ecsr);\r\nwriteb(RCAR_CAN_EIER_EWIE | RCAR_CAN_EIER_EPIE | RCAR_CAN_EIER_BOEIE |\r\n(priv->can.ctrlmode & CAN_CTRLMODE_BERR_REPORTING ?\r\nRCAR_CAN_EIER_BEIE : 0) | RCAR_CAN_EIER_ORIE |\r\nRCAR_CAN_EIER_OLIE, &priv->regs->eier);\r\npriv->can.state = CAN_STATE_ERROR_ACTIVE;\r\nwritew(ctlr & ~RCAR_CAN_CTLR_CANM, &priv->regs->ctlr);\r\nfor (i = 0; i < MAX_STR_READS; i++) {\r\nif (!(readw(&priv->regs->str) & RCAR_CAN_STR_RSTST))\r\nbreak;\r\n}\r\nwriteb(RCAR_CAN_RFCR_RFE, &priv->regs->rfcr);\r\nwriteb(RCAR_CAN_TFCR_TFE, &priv->regs->tfcr);\r\n}\r\nstatic int rcar_can_open(struct net_device *ndev)\r\n{\r\nstruct rcar_can_priv *priv = netdev_priv(ndev);\r\nint err;\r\nerr = clk_prepare_enable(priv->clk);\r\nif (err) {\r\nnetdev_err(ndev,\r\n"failed to enable peripheral clock, error %d\n",\r\nerr);\r\ngoto out;\r\n}\r\nerr = clk_prepare_enable(priv->can_clk);\r\nif (err) {\r\nnetdev_err(ndev, "failed to enable CAN clock, error %d\n",\r\nerr);\r\ngoto out_clock;\r\n}\r\nerr = open_candev(ndev);\r\nif (err) {\r\nnetdev_err(ndev, "open_candev() failed, error %d\n", err);\r\ngoto out_can_clock;\r\n}\r\nnapi_enable(&priv->napi);\r\nerr = request_irq(ndev->irq, rcar_can_interrupt, 0, ndev->name, ndev);\r\nif (err) {\r\nnetdev_err(ndev, "request_irq(%d) failed, error %d\n",\r\nndev->irq, err);\r\ngoto out_close;\r\n}\r\ncan_led_event(ndev, CAN_LED_EVENT_OPEN);\r\nrcar_can_start(ndev);\r\nnetif_start_queue(ndev);\r\nreturn 0;\r\nout_close:\r\nnapi_disable(&priv->napi);\r\nclose_candev(ndev);\r\nout_can_clock:\r\nclk_disable_unprepare(priv->can_clk);\r\nout_clock:\r\nclk_disable_unprepare(priv->clk);\r\nout:\r\nreturn err;\r\n}\r\nstatic void rcar_can_stop(struct net_device *ndev)\r\n{\r\nstruct rcar_can_priv *priv = netdev_priv(ndev);\r\nu16 ctlr;\r\nint i;\r\nctlr = readw(&priv->regs->ctlr);\r\nctlr |= RCAR_CAN_CTLR_CANM_FORCE_RESET;\r\nwritew(ctlr, &priv->regs->ctlr);\r\nfor (i = 0; i < MAX_STR_READS; i++) {\r\nif (readw(&priv->regs->str) & RCAR_CAN_STR_RSTST)\r\nbreak;\r\n}\r\nwritel(0, &priv->regs->mier0);\r\nwritel(0, &priv->regs->mier1);\r\nwriteb(0, &priv->regs->ier);\r\nwriteb(0, &priv->regs->eier);\r\nctlr |= RCAR_CAN_CTLR_SLPM;\r\nwritew(ctlr, &priv->regs->ctlr);\r\npriv->can.state = CAN_STATE_STOPPED;\r\n}\r\nstatic int rcar_can_close(struct net_device *ndev)\r\n{\r\nstruct rcar_can_priv *priv = netdev_priv(ndev);\r\nnetif_stop_queue(ndev);\r\nrcar_can_stop(ndev);\r\nfree_irq(ndev->irq, ndev);\r\nnapi_disable(&priv->napi);\r\nclk_disable_unprepare(priv->can_clk);\r\nclk_disable_unprepare(priv->clk);\r\nclose_candev(ndev);\r\ncan_led_event(ndev, CAN_LED_EVENT_STOP);\r\nreturn 0;\r\n}\r\nstatic netdev_tx_t rcar_can_start_xmit(struct sk_buff *skb,\r\nstruct net_device *ndev)\r\n{\r\nstruct rcar_can_priv *priv = netdev_priv(ndev);\r\nstruct can_frame *cf = (struct can_frame *)skb->data;\r\nu32 data, i;\r\nif (can_dropped_invalid_skb(ndev, skb))\r\nreturn NETDEV_TX_OK;\r\nif (cf->can_id & CAN_EFF_FLAG)\r\ndata = (cf->can_id & CAN_EFF_MASK) | RCAR_CAN_IDE;\r\nelse\r\ndata = (cf->can_id & CAN_SFF_MASK) << RCAR_CAN_SID_SHIFT;\r\nif (cf->can_id & CAN_RTR_FLAG) {\r\ndata |= RCAR_CAN_RTR;\r\n} else {\r\nfor (i = 0; i < cf->can_dlc; i++)\r\nwriteb(cf->data[i],\r\n&priv->regs->mb[RCAR_CAN_TX_FIFO_MBX].data[i]);\r\n}\r\nwritel(data, &priv->regs->mb[RCAR_CAN_TX_FIFO_MBX].id);\r\nwriteb(cf->can_dlc, &priv->regs->mb[RCAR_CAN_TX_FIFO_MBX].dlc);\r\npriv->tx_dlc[priv->tx_head % RCAR_CAN_FIFO_DEPTH] = cf->can_dlc;\r\ncan_put_echo_skb(skb, ndev, priv->tx_head % RCAR_CAN_FIFO_DEPTH);\r\npriv->tx_head++;\r\nwriteb(0xff, &priv->regs->tfpcr);\r\nif (priv->tx_head - priv->tx_tail >= RCAR_CAN_FIFO_DEPTH)\r\nnetif_stop_queue(ndev);\r\nreturn NETDEV_TX_OK;\r\n}\r\nstatic void rcar_can_rx_pkt(struct rcar_can_priv *priv)\r\n{\r\nstruct net_device_stats *stats = &priv->ndev->stats;\r\nstruct can_frame *cf;\r\nstruct sk_buff *skb;\r\nu32 data;\r\nu8 dlc;\r\nskb = alloc_can_skb(priv->ndev, &cf);\r\nif (!skb) {\r\nstats->rx_dropped++;\r\nreturn;\r\n}\r\ndata = readl(&priv->regs->mb[RCAR_CAN_RX_FIFO_MBX].id);\r\nif (data & RCAR_CAN_IDE)\r\ncf->can_id = (data & CAN_EFF_MASK) | CAN_EFF_FLAG;\r\nelse\r\ncf->can_id = (data >> RCAR_CAN_SID_SHIFT) & CAN_SFF_MASK;\r\ndlc = readb(&priv->regs->mb[RCAR_CAN_RX_FIFO_MBX].dlc);\r\ncf->can_dlc = get_can_dlc(dlc);\r\nif (data & RCAR_CAN_RTR) {\r\ncf->can_id |= CAN_RTR_FLAG;\r\n} else {\r\nfor (dlc = 0; dlc < cf->can_dlc; dlc++)\r\ncf->data[dlc] =\r\nreadb(&priv->regs->mb[RCAR_CAN_RX_FIFO_MBX].data[dlc]);\r\n}\r\ncan_led_event(priv->ndev, CAN_LED_EVENT_RX);\r\nstats->rx_bytes += cf->can_dlc;\r\nstats->rx_packets++;\r\nnetif_receive_skb(skb);\r\n}\r\nstatic int rcar_can_rx_poll(struct napi_struct *napi, int quota)\r\n{\r\nstruct rcar_can_priv *priv = container_of(napi,\r\nstruct rcar_can_priv, napi);\r\nint num_pkts;\r\nfor (num_pkts = 0; num_pkts < quota; num_pkts++) {\r\nu8 rfcr, isr;\r\nisr = readb(&priv->regs->isr);\r\nif (isr & RCAR_CAN_ISR_RXFF)\r\nwriteb(isr & ~RCAR_CAN_ISR_RXFF, &priv->regs->isr);\r\nrfcr = readb(&priv->regs->rfcr);\r\nif (rfcr & RCAR_CAN_RFCR_RFEST)\r\nbreak;\r\nrcar_can_rx_pkt(priv);\r\nwriteb(0xff, &priv->regs->rfpcr);\r\n}\r\nif (num_pkts < quota) {\r\nnapi_complete(napi);\r\npriv->ier |= RCAR_CAN_IER_RXFIE;\r\nwriteb(priv->ier, &priv->regs->ier);\r\n}\r\nreturn num_pkts;\r\n}\r\nstatic int rcar_can_do_set_mode(struct net_device *ndev, enum can_mode mode)\r\n{\r\nswitch (mode) {\r\ncase CAN_MODE_START:\r\nrcar_can_start(ndev);\r\nnetif_wake_queue(ndev);\r\nreturn 0;\r\ndefault:\r\nreturn -EOPNOTSUPP;\r\n}\r\n}\r\nstatic int rcar_can_get_berr_counter(const struct net_device *dev,\r\nstruct can_berr_counter *bec)\r\n{\r\nstruct rcar_can_priv *priv = netdev_priv(dev);\r\nint err;\r\nerr = clk_prepare_enable(priv->clk);\r\nif (err)\r\nreturn err;\r\nbec->txerr = readb(&priv->regs->tecr);\r\nbec->rxerr = readb(&priv->regs->recr);\r\nclk_disable_unprepare(priv->clk);\r\nreturn 0;\r\n}\r\nstatic int rcar_can_probe(struct platform_device *pdev)\r\n{\r\nstruct rcar_can_platform_data *pdata;\r\nstruct rcar_can_priv *priv;\r\nstruct net_device *ndev;\r\nstruct resource *mem;\r\nvoid __iomem *addr;\r\nu32 clock_select = CLKR_CLKP1;\r\nint err = -ENODEV;\r\nint irq;\r\nif (pdev->dev.of_node) {\r\nof_property_read_u32(pdev->dev.of_node,\r\n"renesas,can-clock-select", &clock_select);\r\n} else {\r\npdata = dev_get_platdata(&pdev->dev);\r\nif (!pdata) {\r\ndev_err(&pdev->dev, "No platform data provided!\n");\r\ngoto fail;\r\n}\r\nclock_select = pdata->clock_select;\r\n}\r\nirq = platform_get_irq(pdev, 0);\r\nif (irq < 0) {\r\ndev_err(&pdev->dev, "No IRQ resource\n");\r\nerr = irq;\r\ngoto fail;\r\n}\r\nmem = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\naddr = devm_ioremap_resource(&pdev->dev, mem);\r\nif (IS_ERR(addr)) {\r\nerr = PTR_ERR(addr);\r\ngoto fail;\r\n}\r\nndev = alloc_candev(sizeof(struct rcar_can_priv), RCAR_CAN_FIFO_DEPTH);\r\nif (!ndev) {\r\ndev_err(&pdev->dev, "alloc_candev() failed\n");\r\nerr = -ENOMEM;\r\ngoto fail;\r\n}\r\npriv = netdev_priv(ndev);\r\npriv->clk = devm_clk_get(&pdev->dev, "clkp1");\r\nif (IS_ERR(priv->clk)) {\r\nerr = PTR_ERR(priv->clk);\r\ndev_err(&pdev->dev, "cannot get peripheral clock, error %d\n",\r\nerr);\r\ngoto fail_clk;\r\n}\r\nif (clock_select >= ARRAY_SIZE(clock_names)) {\r\nerr = -EINVAL;\r\ndev_err(&pdev->dev, "invalid CAN clock selected\n");\r\ngoto fail_clk;\r\n}\r\npriv->can_clk = devm_clk_get(&pdev->dev, clock_names[clock_select]);\r\nif (IS_ERR(priv->can_clk)) {\r\nerr = PTR_ERR(priv->can_clk);\r\ndev_err(&pdev->dev, "cannot get CAN clock, error %d\n", err);\r\ngoto fail_clk;\r\n}\r\nndev->netdev_ops = &rcar_can_netdev_ops;\r\nndev->irq = irq;\r\nndev->flags |= IFF_ECHO;\r\npriv->ndev = ndev;\r\npriv->regs = addr;\r\npriv->clock_select = clock_select;\r\npriv->can.clock.freq = clk_get_rate(priv->can_clk);\r\npriv->can.bittiming_const = &rcar_can_bittiming_const;\r\npriv->can.do_set_mode = rcar_can_do_set_mode;\r\npriv->can.do_get_berr_counter = rcar_can_get_berr_counter;\r\npriv->can.ctrlmode_supported = CAN_CTRLMODE_BERR_REPORTING;\r\nplatform_set_drvdata(pdev, ndev);\r\nSET_NETDEV_DEV(ndev, &pdev->dev);\r\nnetif_napi_add(ndev, &priv->napi, rcar_can_rx_poll,\r\nRCAR_CAN_NAPI_WEIGHT);\r\nerr = register_candev(ndev);\r\nif (err) {\r\ndev_err(&pdev->dev, "register_candev() failed, error %d\n",\r\nerr);\r\ngoto fail_candev;\r\n}\r\ndevm_can_led_init(ndev);\r\ndev_info(&pdev->dev, "device registered (regs @ %p, IRQ%d)\n",\r\npriv->regs, ndev->irq);\r\nreturn 0;\r\nfail_candev:\r\nnetif_napi_del(&priv->napi);\r\nfail_clk:\r\nfree_candev(ndev);\r\nfail:\r\nreturn err;\r\n}\r\nstatic int rcar_can_remove(struct platform_device *pdev)\r\n{\r\nstruct net_device *ndev = platform_get_drvdata(pdev);\r\nstruct rcar_can_priv *priv = netdev_priv(ndev);\r\nunregister_candev(ndev);\r\nnetif_napi_del(&priv->napi);\r\nfree_candev(ndev);\r\nreturn 0;\r\n}\r\nstatic int __maybe_unused rcar_can_suspend(struct device *dev)\r\n{\r\nstruct net_device *ndev = dev_get_drvdata(dev);\r\nstruct rcar_can_priv *priv = netdev_priv(ndev);\r\nu16 ctlr;\r\nif (netif_running(ndev)) {\r\nnetif_stop_queue(ndev);\r\nnetif_device_detach(ndev);\r\n}\r\nctlr = readw(&priv->regs->ctlr);\r\nctlr |= RCAR_CAN_CTLR_CANM_HALT;\r\nwritew(ctlr, &priv->regs->ctlr);\r\nctlr |= RCAR_CAN_CTLR_SLPM;\r\nwritew(ctlr, &priv->regs->ctlr);\r\npriv->can.state = CAN_STATE_SLEEPING;\r\nclk_disable(priv->clk);\r\nreturn 0;\r\n}\r\nstatic int __maybe_unused rcar_can_resume(struct device *dev)\r\n{\r\nstruct net_device *ndev = dev_get_drvdata(dev);\r\nstruct rcar_can_priv *priv = netdev_priv(ndev);\r\nu16 ctlr;\r\nint err;\r\nerr = clk_enable(priv->clk);\r\nif (err) {\r\nnetdev_err(ndev, "clk_enable() failed, error %d\n", err);\r\nreturn err;\r\n}\r\nctlr = readw(&priv->regs->ctlr);\r\nctlr &= ~RCAR_CAN_CTLR_SLPM;\r\nwritew(ctlr, &priv->regs->ctlr);\r\nctlr &= ~RCAR_CAN_CTLR_CANM;\r\nwritew(ctlr, &priv->regs->ctlr);\r\npriv->can.state = CAN_STATE_ERROR_ACTIVE;\r\nif (netif_running(ndev)) {\r\nnetif_device_attach(ndev);\r\nnetif_start_queue(ndev);\r\n}\r\nreturn 0;\r\n}
