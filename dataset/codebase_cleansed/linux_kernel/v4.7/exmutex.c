void acpi_ex_unlink_mutex(union acpi_operand_object *obj_desc)\r\n{\r\nstruct acpi_thread_state *thread = obj_desc->mutex.owner_thread;\r\nif (!thread) {\r\nreturn;\r\n}\r\nif (obj_desc->mutex.next) {\r\n(obj_desc->mutex.next)->mutex.prev = obj_desc->mutex.prev;\r\n}\r\nif (obj_desc->mutex.prev) {\r\n(obj_desc->mutex.prev)->mutex.next = obj_desc->mutex.next;\r\n(obj_desc->mutex.prev)->mutex.original_sync_level =\r\nobj_desc->mutex.original_sync_level;\r\n} else {\r\nthread->acquired_mutex_list = obj_desc->mutex.next;\r\n}\r\n}\r\nstatic void\r\nacpi_ex_link_mutex(union acpi_operand_object *obj_desc,\r\nstruct acpi_thread_state *thread)\r\n{\r\nunion acpi_operand_object *list_head;\r\nlist_head = thread->acquired_mutex_list;\r\nobj_desc->mutex.prev = NULL;\r\nobj_desc->mutex.next = list_head;\r\nif (list_head) {\r\nlist_head->mutex.prev = obj_desc;\r\n}\r\nthread->acquired_mutex_list = obj_desc;\r\n}\r\nacpi_status\r\nacpi_ex_acquire_mutex_object(u16 timeout,\r\nunion acpi_operand_object *obj_desc,\r\nacpi_thread_id thread_id)\r\n{\r\nacpi_status status;\r\nACPI_FUNCTION_TRACE_PTR(ex_acquire_mutex_object, obj_desc);\r\nif (!obj_desc) {\r\nreturn_ACPI_STATUS(AE_BAD_PARAMETER);\r\n}\r\nif (obj_desc->mutex.thread_id == thread_id) {\r\nobj_desc->mutex.acquisition_depth++;\r\nreturn_ACPI_STATUS(AE_OK);\r\n}\r\nif (obj_desc == acpi_gbl_global_lock_mutex) {\r\nstatus = acpi_ev_acquire_global_lock(timeout);\r\n} else {\r\nstatus =\r\nacpi_ex_system_wait_mutex(obj_desc->mutex.os_mutex,\r\ntimeout);\r\n}\r\nif (ACPI_FAILURE(status)) {\r\nreturn_ACPI_STATUS(status);\r\n}\r\nobj_desc->mutex.thread_id = thread_id;\r\nobj_desc->mutex.acquisition_depth = 1;\r\nobj_desc->mutex.original_sync_level = 0;\r\nobj_desc->mutex.owner_thread = NULL;\r\nreturn_ACPI_STATUS(AE_OK);\r\n}\r\nacpi_status\r\nacpi_ex_acquire_mutex(union acpi_operand_object *time_desc,\r\nunion acpi_operand_object *obj_desc,\r\nstruct acpi_walk_state *walk_state)\r\n{\r\nacpi_status status;\r\nACPI_FUNCTION_TRACE_PTR(ex_acquire_mutex, obj_desc);\r\nif (!obj_desc) {\r\nreturn_ACPI_STATUS(AE_BAD_PARAMETER);\r\n}\r\nif (!walk_state->thread) {\r\nACPI_ERROR((AE_INFO,\r\n"Cannot acquire Mutex [%4.4s], null thread info",\r\nacpi_ut_get_node_name(obj_desc->mutex.node)));\r\nreturn_ACPI_STATUS(AE_AML_INTERNAL);\r\n}\r\nif (walk_state->thread->current_sync_level > obj_desc->mutex.sync_level) {\r\nACPI_ERROR((AE_INFO,\r\n"Cannot acquire Mutex [%4.4s], "\r\n"current SyncLevel is too large (%u)",\r\nacpi_ut_get_node_name(obj_desc->mutex.node),\r\nwalk_state->thread->current_sync_level));\r\nreturn_ACPI_STATUS(AE_AML_MUTEX_ORDER);\r\n}\r\nACPI_DEBUG_PRINT((ACPI_DB_EXEC,\r\n"Acquiring: Mutex SyncLevel %u, Thread SyncLevel %u, "\r\n"Depth %u TID %p\n",\r\nobj_desc->mutex.sync_level,\r\nwalk_state->thread->current_sync_level,\r\nobj_desc->mutex.acquisition_depth,\r\nwalk_state->thread));\r\nstatus = acpi_ex_acquire_mutex_object((u16)time_desc->integer.value,\r\nobj_desc,\r\nwalk_state->thread->thread_id);\r\nif (ACPI_SUCCESS(status) && obj_desc->mutex.acquisition_depth == 1) {\r\nobj_desc->mutex.owner_thread = walk_state->thread;\r\nobj_desc->mutex.original_sync_level =\r\nwalk_state->thread->current_sync_level;\r\nwalk_state->thread->current_sync_level =\r\nobj_desc->mutex.sync_level;\r\nacpi_ex_link_mutex(obj_desc, walk_state->thread);\r\n}\r\nACPI_DEBUG_PRINT((ACPI_DB_EXEC,\r\n"Acquired: Mutex SyncLevel %u, Thread SyncLevel %u, Depth %u\n",\r\nobj_desc->mutex.sync_level,\r\nwalk_state->thread->current_sync_level,\r\nobj_desc->mutex.acquisition_depth));\r\nreturn_ACPI_STATUS(status);\r\n}\r\nacpi_status acpi_ex_release_mutex_object(union acpi_operand_object *obj_desc)\r\n{\r\nacpi_status status = AE_OK;\r\nACPI_FUNCTION_TRACE(ex_release_mutex_object);\r\nif (obj_desc->mutex.acquisition_depth == 0) {\r\nreturn_ACPI_STATUS(AE_NOT_ACQUIRED);\r\n}\r\nobj_desc->mutex.acquisition_depth--;\r\nif (obj_desc->mutex.acquisition_depth != 0) {\r\nreturn_ACPI_STATUS(AE_OK);\r\n}\r\nif (obj_desc->mutex.owner_thread) {\r\nacpi_ex_unlink_mutex(obj_desc);\r\nobj_desc->mutex.owner_thread = NULL;\r\n}\r\nif (obj_desc == acpi_gbl_global_lock_mutex) {\r\nstatus = acpi_ev_release_global_lock();\r\n} else {\r\nacpi_os_release_mutex(obj_desc->mutex.os_mutex);\r\n}\r\nobj_desc->mutex.thread_id = 0;\r\nreturn_ACPI_STATUS(status);\r\n}\r\nacpi_status\r\nacpi_ex_release_mutex(union acpi_operand_object *obj_desc,\r\nstruct acpi_walk_state *walk_state)\r\n{\r\nu8 previous_sync_level;\r\nstruct acpi_thread_state *owner_thread;\r\nacpi_status status = AE_OK;\r\nACPI_FUNCTION_TRACE(ex_release_mutex);\r\nif (!obj_desc) {\r\nreturn_ACPI_STATUS(AE_BAD_PARAMETER);\r\n}\r\nowner_thread = obj_desc->mutex.owner_thread;\r\nif (!owner_thread) {\r\nACPI_ERROR((AE_INFO,\r\n"Cannot release Mutex [%4.4s], not acquired",\r\nacpi_ut_get_node_name(obj_desc->mutex.node)));\r\nreturn_ACPI_STATUS(AE_AML_MUTEX_NOT_ACQUIRED);\r\n}\r\nif (!walk_state->thread) {\r\nACPI_ERROR((AE_INFO,\r\n"Cannot release Mutex [%4.4s], null thread info",\r\nacpi_ut_get_node_name(obj_desc->mutex.node)));\r\nreturn_ACPI_STATUS(AE_AML_INTERNAL);\r\n}\r\nif ((owner_thread->thread_id != walk_state->thread->thread_id) &&\r\n(obj_desc != acpi_gbl_global_lock_mutex)) {\r\nACPI_ERROR((AE_INFO,\r\n"Thread %u cannot release Mutex [%4.4s] acquired by thread %u",\r\n(u32)walk_state->thread->thread_id,\r\nacpi_ut_get_node_name(obj_desc->mutex.node),\r\n(u32)owner_thread->thread_id));\r\nreturn_ACPI_STATUS(AE_AML_NOT_OWNER);\r\n}\r\nif (obj_desc->mutex.sync_level != owner_thread->current_sync_level) {\r\nACPI_ERROR((AE_INFO,\r\n"Cannot release Mutex [%4.4s], SyncLevel mismatch: "\r\n"mutex %u current %u",\r\nacpi_ut_get_node_name(obj_desc->mutex.node),\r\nobj_desc->mutex.sync_level,\r\nwalk_state->thread->current_sync_level));\r\nreturn_ACPI_STATUS(AE_AML_MUTEX_ORDER);\r\n}\r\nprevious_sync_level =\r\nowner_thread->acquired_mutex_list->mutex.original_sync_level;\r\nACPI_DEBUG_PRINT((ACPI_DB_EXEC,\r\n"Releasing: Object SyncLevel %u, Thread SyncLevel %u, "\r\n"Prev SyncLevel %u, Depth %u TID %p\n",\r\nobj_desc->mutex.sync_level,\r\nwalk_state->thread->current_sync_level,\r\nprevious_sync_level,\r\nobj_desc->mutex.acquisition_depth,\r\nwalk_state->thread));\r\nstatus = acpi_ex_release_mutex_object(obj_desc);\r\nif (ACPI_FAILURE(status)) {\r\nreturn_ACPI_STATUS(status);\r\n}\r\nif (obj_desc->mutex.acquisition_depth == 0) {\r\nowner_thread->current_sync_level = previous_sync_level;\r\n}\r\nACPI_DEBUG_PRINT((ACPI_DB_EXEC,\r\n"Released: Object SyncLevel %u, Thread SyncLevel, %u, "\r\n"Prev SyncLevel %u, Depth %u\n",\r\nobj_desc->mutex.sync_level,\r\nwalk_state->thread->current_sync_level,\r\nprevious_sync_level,\r\nobj_desc->mutex.acquisition_depth));\r\nreturn_ACPI_STATUS(status);\r\n}\r\nvoid acpi_ex_release_all_mutexes(struct acpi_thread_state *thread)\r\n{\r\nunion acpi_operand_object *next = thread->acquired_mutex_list;\r\nunion acpi_operand_object *obj_desc;\r\nACPI_FUNCTION_TRACE(ex_release_all_mutexes);\r\nwhile (next) {\r\nobj_desc = next;\r\nACPI_DEBUG_PRINT((ACPI_DB_EXEC,\r\n"Mutex [%4.4s] force-release, SyncLevel %u Depth %u\n",\r\nobj_desc->mutex.node->name.ascii,\r\nobj_desc->mutex.sync_level,\r\nobj_desc->mutex.acquisition_depth));\r\nif (obj_desc == acpi_gbl_global_lock_mutex) {\r\n(void)acpi_ev_release_global_lock();\r\n} else {\r\nacpi_os_release_mutex(obj_desc->mutex.os_mutex);\r\n}\r\nthread->current_sync_level =\r\nobj_desc->mutex.original_sync_level;\r\nnext = obj_desc->mutex.next;\r\nobj_desc->mutex.prev = NULL;\r\nobj_desc->mutex.next = NULL;\r\nobj_desc->mutex.acquisition_depth = 0;\r\nobj_desc->mutex.owner_thread = NULL;\r\nobj_desc->mutex.thread_id = 0;\r\n}\r\nreturn_VOID;\r\n}
