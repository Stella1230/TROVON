static void _ft_dump_cmd(struct ft_cmd *cmd, const char *caller)\r\n{\r\nstruct fc_exch *ep;\r\nstruct fc_seq *sp;\r\nstruct se_cmd *se_cmd;\r\nstruct scatterlist *sg;\r\nint count;\r\nse_cmd = &cmd->se_cmd;\r\npr_debug("%s: cmd %p sess %p seq %p se_cmd %p\n",\r\ncaller, cmd, cmd->sess, cmd->seq, se_cmd);\r\npr_debug("%s: cmd %p data_nents %u len %u se_cmd_flags <0x%x>\n",\r\ncaller, cmd, se_cmd->t_data_nents,\r\nse_cmd->data_length, se_cmd->se_cmd_flags);\r\nfor_each_sg(se_cmd->t_data_sg, sg, se_cmd->t_data_nents, count)\r\npr_debug("%s: cmd %p sg %p page %p "\r\n"len 0x%x off 0x%x\n",\r\ncaller, cmd, sg,\r\nsg_page(sg), sg->length, sg->offset);\r\nsp = cmd->seq;\r\nif (sp) {\r\nep = fc_seq_exch(sp);\r\npr_debug("%s: cmd %p sid %x did %x "\r\n"ox_id %x rx_id %x seq_id %x e_stat %x\n",\r\ncaller, cmd, ep->sid, ep->did, ep->oxid, ep->rxid,\r\nsp->id, ep->esb_stat);\r\n}\r\n}\r\nvoid ft_dump_cmd(struct ft_cmd *cmd, const char *caller)\r\n{\r\nif (unlikely(ft_debug_logging))\r\n_ft_dump_cmd(cmd, caller);\r\n}\r\nstatic void ft_free_cmd(struct ft_cmd *cmd)\r\n{\r\nstruct fc_frame *fp;\r\nstruct fc_lport *lport;\r\nstruct ft_sess *sess;\r\nif (!cmd)\r\nreturn;\r\nsess = cmd->sess;\r\nfp = cmd->req_frame;\r\nlport = fr_dev(fp);\r\nif (fr_seq(fp))\r\nlport->tt.seq_release(fr_seq(fp));\r\nfc_frame_free(fp);\r\npercpu_ida_free(&sess->se_sess->sess_tag_pool, cmd->se_cmd.map_tag);\r\nft_sess_put(sess);\r\n}\r\nvoid ft_release_cmd(struct se_cmd *se_cmd)\r\n{\r\nstruct ft_cmd *cmd = container_of(se_cmd, struct ft_cmd, se_cmd);\r\nft_free_cmd(cmd);\r\n}\r\nint ft_check_stop_free(struct se_cmd *se_cmd)\r\n{\r\nreturn transport_generic_free_cmd(se_cmd, 0);\r\n}\r\nint ft_queue_status(struct se_cmd *se_cmd)\r\n{\r\nstruct ft_cmd *cmd = container_of(se_cmd, struct ft_cmd, se_cmd);\r\nstruct fc_frame *fp;\r\nstruct fcp_resp_with_ext *fcp;\r\nstruct fc_lport *lport;\r\nstruct fc_exch *ep;\r\nsize_t len;\r\nint rc;\r\nif (cmd->aborted)\r\nreturn 0;\r\nft_dump_cmd(cmd, __func__);\r\nep = fc_seq_exch(cmd->seq);\r\nlport = ep->lp;\r\nlen = sizeof(*fcp) + se_cmd->scsi_sense_length;\r\nfp = fc_frame_alloc(lport, len);\r\nif (!fp) {\r\nse_cmd->scsi_status = SAM_STAT_TASK_SET_FULL;\r\nreturn -ENOMEM;\r\n}\r\nfcp = fc_frame_payload_get(fp, len);\r\nmemset(fcp, 0, len);\r\nfcp->resp.fr_status = se_cmd->scsi_status;\r\nlen = se_cmd->scsi_sense_length;\r\nif (len) {\r\nfcp->resp.fr_flags |= FCP_SNS_LEN_VAL;\r\nfcp->ext.fr_sns_len = htonl(len);\r\nmemcpy((fcp + 1), se_cmd->sense_buffer, len);\r\n}\r\nif (se_cmd->se_cmd_flags & (SCF_OVERFLOW_BIT | SCF_UNDERFLOW_BIT)) {\r\nif (se_cmd->se_cmd_flags & SCF_OVERFLOW_BIT)\r\nfcp->resp.fr_flags |= FCP_RESID_OVER;\r\nelse\r\nfcp->resp.fr_flags |= FCP_RESID_UNDER;\r\nfcp->ext.fr_resid = cpu_to_be32(se_cmd->residual_count);\r\n}\r\ncmd->seq = lport->tt.seq_start_next(cmd->seq);\r\nfc_fill_fc_hdr(fp, FC_RCTL_DD_CMD_STATUS, ep->did, ep->sid, FC_TYPE_FCP,\r\nFC_FC_EX_CTX | FC_FC_LAST_SEQ | FC_FC_END_SEQ, 0);\r\nrc = lport->tt.seq_send(lport, cmd->seq, fp);\r\nif (rc) {\r\npr_info_ratelimited("%s: Failed to send response frame %p, "\r\n"xid <0x%x>\n", __func__, fp, ep->xid);\r\nse_cmd->scsi_status = SAM_STAT_TASK_SET_FULL;\r\nreturn -ENOMEM;\r\n}\r\nlport->tt.exch_done(cmd->seq);\r\ntarget_put_sess_cmd(&cmd->se_cmd);\r\nreturn 0;\r\n}\r\nint ft_write_pending_status(struct se_cmd *se_cmd)\r\n{\r\nstruct ft_cmd *cmd = container_of(se_cmd, struct ft_cmd, se_cmd);\r\nreturn cmd->write_data_len != se_cmd->data_length;\r\n}\r\nint ft_write_pending(struct se_cmd *se_cmd)\r\n{\r\nstruct ft_cmd *cmd = container_of(se_cmd, struct ft_cmd, se_cmd);\r\nstruct fc_frame *fp;\r\nstruct fcp_txrdy *txrdy;\r\nstruct fc_lport *lport;\r\nstruct fc_exch *ep;\r\nstruct fc_frame_header *fh;\r\nu32 f_ctl;\r\nft_dump_cmd(cmd, __func__);\r\nif (cmd->aborted)\r\nreturn 0;\r\nep = fc_seq_exch(cmd->seq);\r\nlport = ep->lp;\r\nfp = fc_frame_alloc(lport, sizeof(*txrdy));\r\nif (!fp)\r\nreturn -ENOMEM;\r\ntxrdy = fc_frame_payload_get(fp, sizeof(*txrdy));\r\nmemset(txrdy, 0, sizeof(*txrdy));\r\ntxrdy->ft_burst_len = htonl(se_cmd->data_length);\r\ncmd->seq = lport->tt.seq_start_next(cmd->seq);\r\nfc_fill_fc_hdr(fp, FC_RCTL_DD_DATA_DESC, ep->did, ep->sid, FC_TYPE_FCP,\r\nFC_FC_EX_CTX | FC_FC_END_SEQ | FC_FC_SEQ_INIT, 0);\r\nfh = fc_frame_header_get(fp);\r\nf_ctl = ntoh24(fh->fh_f_ctl);\r\nif (f_ctl & FC_FC_EX_CTX) {\r\nif ((ep->xid <= lport->lro_xid) &&\r\n(fh->fh_r_ctl == FC_RCTL_DD_DATA_DESC)) {\r\nif ((se_cmd->se_cmd_flags & SCF_SCSI_DATA_CDB) &&\r\nlport->tt.ddp_target(lport, ep->xid,\r\nse_cmd->t_data_sg,\r\nse_cmd->t_data_nents))\r\ncmd->was_ddp_setup = 1;\r\n}\r\n}\r\nlport->tt.seq_send(lport, cmd->seq, fp);\r\nreturn 0;\r\n}\r\nint ft_get_cmd_state(struct se_cmd *se_cmd)\r\n{\r\nreturn 0;\r\n}\r\nstatic void ft_recv_seq(struct fc_seq *sp, struct fc_frame *fp, void *arg)\r\n{\r\nstruct ft_cmd *cmd = arg;\r\nstruct fc_frame_header *fh;\r\nif (IS_ERR(fp)) {\r\ncmd->seq = NULL;\r\ncmd->aborted = true;\r\nreturn;\r\n}\r\nfh = fc_frame_header_get(fp);\r\nswitch (fh->fh_r_ctl) {\r\ncase FC_RCTL_DD_SOL_DATA:\r\nft_recv_write_data(cmd, fp);\r\nbreak;\r\ncase FC_RCTL_DD_UNSOL_CTL:\r\ncase FC_RCTL_DD_SOL_CTL:\r\ncase FC_RCTL_DD_DATA_DESC:\r\ndefault:\r\npr_debug("%s: unhandled frame r_ctl %x\n",\r\n__func__, fh->fh_r_ctl);\r\nft_invl_hw_context(cmd);\r\nfc_frame_free(fp);\r\ntransport_generic_free_cmd(&cmd->se_cmd, 0);\r\nbreak;\r\n}\r\n}\r\nstatic void ft_send_resp_status(struct fc_lport *lport,\r\nconst struct fc_frame *rx_fp,\r\nu32 status, enum fcp_resp_rsp_codes code)\r\n{\r\nstruct fc_frame *fp;\r\nstruct fc_seq *sp;\r\nconst struct fc_frame_header *fh;\r\nsize_t len;\r\nstruct fcp_resp_with_ext *fcp;\r\nstruct fcp_resp_rsp_info *info;\r\nfh = fc_frame_header_get(rx_fp);\r\npr_debug("FCP error response: did %x oxid %x status %x code %x\n",\r\nntoh24(fh->fh_s_id), ntohs(fh->fh_ox_id), status, code);\r\nlen = sizeof(*fcp);\r\nif (status == SAM_STAT_GOOD)\r\nlen += sizeof(*info);\r\nfp = fc_frame_alloc(lport, len);\r\nif (!fp)\r\nreturn;\r\nfcp = fc_frame_payload_get(fp, len);\r\nmemset(fcp, 0, len);\r\nfcp->resp.fr_status = status;\r\nif (status == SAM_STAT_GOOD) {\r\nfcp->ext.fr_rsp_len = htonl(sizeof(*info));\r\nfcp->resp.fr_flags |= FCP_RSP_LEN_VAL;\r\ninfo = (struct fcp_resp_rsp_info *)(fcp + 1);\r\ninfo->rsp_code = code;\r\n}\r\nfc_fill_reply_hdr(fp, rx_fp, FC_RCTL_DD_CMD_STATUS, 0);\r\nsp = fr_seq(fp);\r\nif (sp) {\r\nlport->tt.seq_send(lport, sp, fp);\r\nlport->tt.exch_done(sp);\r\n} else {\r\nlport->tt.frame_send(lport, fp);\r\n}\r\n}\r\nstatic void ft_send_resp_code(struct ft_cmd *cmd,\r\nenum fcp_resp_rsp_codes code)\r\n{\r\nft_send_resp_status(cmd->sess->tport->lport,\r\ncmd->req_frame, SAM_STAT_GOOD, code);\r\n}\r\nstatic void ft_send_resp_code_and_free(struct ft_cmd *cmd,\r\nenum fcp_resp_rsp_codes code)\r\n{\r\nft_send_resp_code(cmd, code);\r\nft_free_cmd(cmd);\r\n}\r\nstatic void ft_send_tm(struct ft_cmd *cmd)\r\n{\r\nstruct fcp_cmnd *fcp;\r\nint rc;\r\nu8 tm_func;\r\nfcp = fc_frame_payload_get(cmd->req_frame, sizeof(*fcp));\r\nswitch (fcp->fc_tm_flags) {\r\ncase FCP_TMF_LUN_RESET:\r\ntm_func = TMR_LUN_RESET;\r\nbreak;\r\ncase FCP_TMF_TGT_RESET:\r\ntm_func = TMR_TARGET_WARM_RESET;\r\nbreak;\r\ncase FCP_TMF_CLR_TASK_SET:\r\ntm_func = TMR_CLEAR_TASK_SET;\r\nbreak;\r\ncase FCP_TMF_ABT_TASK_SET:\r\ntm_func = TMR_ABORT_TASK_SET;\r\nbreak;\r\ncase FCP_TMF_CLR_ACA:\r\ntm_func = TMR_CLEAR_ACA;\r\nbreak;\r\ndefault:\r\npr_debug("invalid FCP tm_flags %x\n", fcp->fc_tm_flags);\r\nft_send_resp_code_and_free(cmd, FCP_CMND_FIELDS_INVALID);\r\nreturn;\r\n}\r\nrc = target_submit_tmr(&cmd->se_cmd, cmd->sess->se_sess,\r\n&cmd->ft_sense_buffer[0], scsilun_to_int(&fcp->fc_lun),\r\ncmd, tm_func, GFP_KERNEL, 0, TARGET_SCF_ACK_KREF);\r\nif (rc < 0)\r\nft_send_resp_code_and_free(cmd, FCP_TMF_FAILED);\r\n}\r\nvoid ft_queue_tm_resp(struct se_cmd *se_cmd)\r\n{\r\nstruct ft_cmd *cmd = container_of(se_cmd, struct ft_cmd, se_cmd);\r\nstruct se_tmr_req *tmr = se_cmd->se_tmr_req;\r\nenum fcp_resp_rsp_codes code;\r\nif (cmd->aborted)\r\nreturn;\r\nswitch (tmr->response) {\r\ncase TMR_FUNCTION_COMPLETE:\r\ncode = FCP_TMF_CMPL;\r\nbreak;\r\ncase TMR_LUN_DOES_NOT_EXIST:\r\ncode = FCP_TMF_INVALID_LUN;\r\nbreak;\r\ncase TMR_FUNCTION_REJECTED:\r\ncode = FCP_TMF_REJECTED;\r\nbreak;\r\ncase TMR_TASK_DOES_NOT_EXIST:\r\ncase TMR_TASK_MGMT_FUNCTION_NOT_SUPPORTED:\r\ndefault:\r\ncode = FCP_TMF_FAILED;\r\nbreak;\r\n}\r\npr_debug("tmr fn %d resp %d fcp code %d\n",\r\ntmr->function, tmr->response, code);\r\nft_send_resp_code(cmd, code);\r\ntarget_put_sess_cmd(&cmd->se_cmd);\r\n}\r\nvoid ft_aborted_task(struct se_cmd *se_cmd)\r\n{\r\nreturn;\r\n}\r\nstatic void ft_recv_cmd(struct ft_sess *sess, struct fc_frame *fp)\r\n{\r\nstruct ft_cmd *cmd;\r\nstruct fc_lport *lport = sess->tport->lport;\r\nstruct se_session *se_sess = sess->se_sess;\r\nint tag;\r\ntag = percpu_ida_alloc(&se_sess->sess_tag_pool, TASK_RUNNING);\r\nif (tag < 0)\r\ngoto busy;\r\ncmd = &((struct ft_cmd *)se_sess->sess_cmd_map)[tag];\r\nmemset(cmd, 0, sizeof(struct ft_cmd));\r\ncmd->se_cmd.map_tag = tag;\r\ncmd->sess = sess;\r\ncmd->seq = lport->tt.seq_assign(lport, fp);\r\nif (!cmd->seq) {\r\npercpu_ida_free(&se_sess->sess_tag_pool, tag);\r\ngoto busy;\r\n}\r\ncmd->req_frame = fp;\r\nINIT_WORK(&cmd->work, ft_send_work);\r\nqueue_work(sess->tport->tpg->workqueue, &cmd->work);\r\nreturn;\r\nbusy:\r\npr_debug("cmd or seq allocation failure - sending BUSY\n");\r\nft_send_resp_status(lport, fp, SAM_STAT_BUSY, 0);\r\nfc_frame_free(fp);\r\nft_sess_put(sess);\r\n}\r\nvoid ft_recv_req(struct ft_sess *sess, struct fc_frame *fp)\r\n{\r\nstruct fc_frame_header *fh = fc_frame_header_get(fp);\r\nswitch (fh->fh_r_ctl) {\r\ncase FC_RCTL_DD_UNSOL_CMD:\r\nft_recv_cmd(sess, fp);\r\nbreak;\r\ncase FC_RCTL_DD_SOL_DATA:\r\ncase FC_RCTL_DD_UNSOL_CTL:\r\ncase FC_RCTL_DD_SOL_CTL:\r\ncase FC_RCTL_DD_DATA_DESC:\r\ncase FC_RCTL_ELS4_REQ:\r\ndefault:\r\npr_debug("%s: unhandled frame r_ctl %x\n",\r\n__func__, fh->fh_r_ctl);\r\nfc_frame_free(fp);\r\nft_sess_put(sess);\r\nbreak;\r\n}\r\n}\r\nstatic void ft_send_work(struct work_struct *work)\r\n{\r\nstruct ft_cmd *cmd = container_of(work, struct ft_cmd, work);\r\nstruct fc_frame_header *fh = fc_frame_header_get(cmd->req_frame);\r\nstruct fcp_cmnd *fcp;\r\nint data_dir = 0;\r\nint task_attr;\r\nfcp = fc_frame_payload_get(cmd->req_frame, sizeof(*fcp));\r\nif (!fcp)\r\ngoto err;\r\nif (fcp->fc_flags & FCP_CFL_LEN_MASK)\r\ngoto err;\r\nif (fcp->fc_tm_flags) {\r\nft_send_tm(cmd);\r\nreturn;\r\n}\r\nswitch (fcp->fc_flags & (FCP_CFL_RDDATA | FCP_CFL_WRDATA)) {\r\ncase 0:\r\ndata_dir = DMA_NONE;\r\nbreak;\r\ncase FCP_CFL_RDDATA:\r\ndata_dir = DMA_FROM_DEVICE;\r\nbreak;\r\ncase FCP_CFL_WRDATA:\r\ndata_dir = DMA_TO_DEVICE;\r\nbreak;\r\ncase FCP_CFL_WRDATA | FCP_CFL_RDDATA:\r\ngoto err;\r\n}\r\nswitch (fcp->fc_pri_ta & FCP_PTA_MASK) {\r\ncase FCP_PTA_HEADQ:\r\ntask_attr = TCM_HEAD_TAG;\r\nbreak;\r\ncase FCP_PTA_ORDERED:\r\ntask_attr = TCM_ORDERED_TAG;\r\nbreak;\r\ncase FCP_PTA_ACA:\r\ntask_attr = TCM_ACA_TAG;\r\nbreak;\r\ncase FCP_PTA_SIMPLE:\r\ndefault:\r\ntask_attr = TCM_SIMPLE_TAG;\r\n}\r\nfc_seq_exch(cmd->seq)->lp->tt.seq_set_resp(cmd->seq, ft_recv_seq, cmd);\r\ncmd->se_cmd.tag = fc_seq_exch(cmd->seq)->rxid;\r\nif (target_submit_cmd(&cmd->se_cmd, cmd->sess->se_sess, fcp->fc_cdb,\r\n&cmd->ft_sense_buffer[0], scsilun_to_int(&fcp->fc_lun),\r\nntohl(fcp->fc_dl), task_attr, data_dir,\r\nTARGET_SCF_ACK_KREF))\r\ngoto err;\r\npr_debug("r_ctl %x alloc target_submit_cmd\n", fh->fh_r_ctl);\r\nreturn;\r\nerr:\r\nft_send_resp_code_and_free(cmd, FCP_CMND_FIELDS_INVALID);\r\n}
