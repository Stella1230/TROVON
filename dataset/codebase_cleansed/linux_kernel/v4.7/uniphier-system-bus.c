static int uniphier_system_bus_add_bank(struct uniphier_system_bus_priv *priv,\r\nint bank, u32 addr, u64 paddr, u32 size)\r\n{\r\nu64 end, mask;\r\ndev_dbg(priv->dev,\r\n"range found: bank = %d, addr = %08x, paddr = %08llx, size = %08x\n",\r\nbank, addr, paddr, size);\r\nif (bank >= ARRAY_SIZE(priv->bank)) {\r\ndev_err(priv->dev, "unsupported bank number %d\n", bank);\r\nreturn -EINVAL;\r\n}\r\nif (priv->bank[bank].base || priv->bank[bank].end) {\r\ndev_err(priv->dev,\r\n"range for bank %d has already been specified\n", bank);\r\nreturn -EINVAL;\r\n}\r\nif (paddr > U32_MAX) {\r\ndev_err(priv->dev, "base address %llx is too high\n", paddr);\r\nreturn -EINVAL;\r\n}\r\nend = paddr + size;\r\nif (addr > paddr) {\r\ndev_err(priv->dev,\r\n"base %08x cannot be mapped to %08llx of parent\n",\r\naddr, paddr);\r\nreturn -EINVAL;\r\n}\r\npaddr -= addr;\r\npaddr = round_down(paddr, 0x00020000);\r\nend = round_up(end, 0x00020000);\r\nif (end > U32_MAX) {\r\ndev_err(priv->dev, "end address %08llx is too high\n", end);\r\nreturn -EINVAL;\r\n}\r\nmask = paddr ^ (end - 1);\r\nmask = roundup_pow_of_two(mask);\r\npaddr = round_down(paddr, mask);\r\nend = round_up(end, mask);\r\npriv->bank[bank].base = paddr;\r\npriv->bank[bank].end = end;\r\ndev_dbg(priv->dev, "range added: bank = %d, addr = %08x, end = %08x\n",\r\nbank, priv->bank[bank].base, priv->bank[bank].end);\r\nreturn 0;\r\n}\r\nstatic int uniphier_system_bus_check_overlap(\r\nconst struct uniphier_system_bus_priv *priv)\r\n{\r\nint i, j;\r\nfor (i = 0; i < ARRAY_SIZE(priv->bank); i++) {\r\nfor (j = i + 1; j < ARRAY_SIZE(priv->bank); j++) {\r\nif (priv->bank[i].end > priv->bank[j].base &&\r\npriv->bank[i].base < priv->bank[j].end) {\r\ndev_err(priv->dev,\r\n"region overlap between bank%d and bank%d\n",\r\ni, j);\r\nreturn -EINVAL;\r\n}\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic void uniphier_system_bus_check_boot_swap(\r\nstruct uniphier_system_bus_priv *priv)\r\n{\r\nvoid __iomem *base_reg = priv->membase + UNIPHIER_SBC_BASE;\r\nint is_swapped;\r\nis_swapped = !(readl(base_reg) & UNIPHIER_SBC_BASE_BE);\r\ndev_dbg(priv->dev, "Boot Swap: %s\n", is_swapped ? "on" : "off");\r\nif (is_swapped)\r\nswap(priv->bank[0], priv->bank[1]);\r\n}\r\nstatic void uniphier_system_bus_set_reg(\r\nconst struct uniphier_system_bus_priv *priv)\r\n{\r\nvoid __iomem *base_reg = priv->membase + UNIPHIER_SBC_BASE;\r\nu32 base, end, mask, val;\r\nint i;\r\nfor (i = 0; i < ARRAY_SIZE(priv->bank); i++) {\r\nbase = priv->bank[i].base;\r\nend = priv->bank[i].end;\r\nif (base == end) {\r\nif (i < 2)\r\nval = UNIPHIER_SBC_BASE_DUMMY;\r\nelse\r\nval = 0;\r\n} else {\r\nmask = base ^ (end - 1);\r\nval = base & 0xfffe0000;\r\nval |= (~mask >> 16) & 0xfffe;\r\nval |= UNIPHIER_SBC_BASE_BE;\r\n}\r\ndev_dbg(priv->dev, "SBC_BASE[%d] = 0x%08x\n", i, val);\r\nwritel(val, base_reg + UNIPHIER_SBC_STRIDE * i);\r\n}\r\n}\r\nstatic int uniphier_system_bus_probe(struct platform_device *pdev)\r\n{\r\nstruct device *dev = &pdev->dev;\r\nstruct uniphier_system_bus_priv *priv;\r\nstruct resource *regs;\r\nconst __be32 *ranges;\r\nu32 cells, addr, size;\r\nu64 paddr;\r\nint pna, bank, rlen, rone, ret;\r\npriv = devm_kzalloc(dev, sizeof(*priv), GFP_KERNEL);\r\nif (!priv)\r\nreturn -ENOMEM;\r\nregs = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\npriv->membase = devm_ioremap_resource(dev, regs);\r\nif (IS_ERR(priv->membase))\r\nreturn PTR_ERR(priv->membase);\r\npriv->dev = dev;\r\npna = of_n_addr_cells(dev->of_node);\r\nret = of_property_read_u32(dev->of_node, "#address-cells", &cells);\r\nif (ret) {\r\ndev_err(dev, "failed to get #address-cells\n");\r\nreturn ret;\r\n}\r\nif (cells != 2) {\r\ndev_err(dev, "#address-cells must be 2\n");\r\nreturn -EINVAL;\r\n}\r\nret = of_property_read_u32(dev->of_node, "#size-cells", &cells);\r\nif (ret) {\r\ndev_err(dev, "failed to get #size-cells\n");\r\nreturn ret;\r\n}\r\nif (cells != 1) {\r\ndev_err(dev, "#size-cells must be 1\n");\r\nreturn -EINVAL;\r\n}\r\nranges = of_get_property(dev->of_node, "ranges", &rlen);\r\nif (!ranges) {\r\ndev_err(dev, "failed to get ranges property\n");\r\nreturn -ENOENT;\r\n}\r\nrlen /= sizeof(*ranges);\r\nrone = pna + 2;\r\nfor (; rlen >= rone; rlen -= rone) {\r\nbank = be32_to_cpup(ranges++);\r\naddr = be32_to_cpup(ranges++);\r\npaddr = of_translate_address(dev->of_node, ranges);\r\nif (paddr == OF_BAD_ADDR)\r\nreturn -EINVAL;\r\nranges += pna;\r\nsize = be32_to_cpup(ranges++);\r\nret = uniphier_system_bus_add_bank(priv, bank, addr,\r\npaddr, size);\r\nif (ret)\r\nreturn ret;\r\n}\r\nret = uniphier_system_bus_check_overlap(priv);\r\nif (ret)\r\nreturn ret;\r\nuniphier_system_bus_check_boot_swap(priv);\r\nuniphier_system_bus_set_reg(priv);\r\nreturn of_platform_populate(dev->of_node, of_default_bus_match_table,\r\nNULL, dev);\r\n}
