static int p8_ghash_init_tfm(struct crypto_tfm *tfm)\r\n{\r\nconst char *alg;\r\nstruct crypto_shash *fallback;\r\nstruct crypto_shash *shash_tfm = __crypto_shash_cast(tfm);\r\nstruct p8_ghash_ctx *ctx = crypto_tfm_ctx(tfm);\r\nif (!(alg = crypto_tfm_alg_name(tfm))) {\r\nprintk(KERN_ERR "Failed to get algorithm name.\n");\r\nreturn -ENOENT;\r\n}\r\nfallback = crypto_alloc_shash(alg, 0, CRYPTO_ALG_NEED_FALLBACK);\r\nif (IS_ERR(fallback)) {\r\nprintk(KERN_ERR\r\n"Failed to allocate transformation for '%s': %ld\n",\r\nalg, PTR_ERR(fallback));\r\nreturn PTR_ERR(fallback);\r\n}\r\nprintk(KERN_INFO "Using '%s' as fallback implementation.\n",\r\ncrypto_tfm_alg_driver_name(crypto_shash_tfm(fallback)));\r\ncrypto_shash_set_flags(fallback,\r\ncrypto_shash_get_flags((struct crypto_shash\r\n*) tfm));\r\nctx->fallback = fallback;\r\nshash_tfm->descsize = sizeof(struct p8_ghash_desc_ctx)\r\n+ crypto_shash_descsize(fallback);\r\nreturn 0;\r\n}\r\nstatic void p8_ghash_exit_tfm(struct crypto_tfm *tfm)\r\n{\r\nstruct p8_ghash_ctx *ctx = crypto_tfm_ctx(tfm);\r\nif (ctx->fallback) {\r\ncrypto_free_shash(ctx->fallback);\r\nctx->fallback = NULL;\r\n}\r\n}\r\nstatic int p8_ghash_init(struct shash_desc *desc)\r\n{\r\nstruct p8_ghash_ctx *ctx = crypto_tfm_ctx(crypto_shash_tfm(desc->tfm));\r\nstruct p8_ghash_desc_ctx *dctx = shash_desc_ctx(desc);\r\ndctx->bytes = 0;\r\nmemset(dctx->shash, 0, GHASH_DIGEST_SIZE);\r\ndctx->fallback_desc.tfm = ctx->fallback;\r\ndctx->fallback_desc.flags = desc->flags;\r\nreturn crypto_shash_init(&dctx->fallback_desc);\r\n}\r\nstatic int p8_ghash_setkey(struct crypto_shash *tfm, const u8 *key,\r\nunsigned int keylen)\r\n{\r\nstruct p8_ghash_ctx *ctx = crypto_tfm_ctx(crypto_shash_tfm(tfm));\r\nif (keylen != GHASH_KEY_LEN)\r\nreturn -EINVAL;\r\npreempt_disable();\r\npagefault_disable();\r\nenable_kernel_vsx();\r\ngcm_init_p8(ctx->htable, (const u64 *) key);\r\ndisable_kernel_vsx();\r\npagefault_enable();\r\npreempt_enable();\r\nreturn crypto_shash_setkey(ctx->fallback, key, keylen);\r\n}\r\nstatic int p8_ghash_update(struct shash_desc *desc,\r\nconst u8 *src, unsigned int srclen)\r\n{\r\nunsigned int len;\r\nstruct p8_ghash_ctx *ctx = crypto_tfm_ctx(crypto_shash_tfm(desc->tfm));\r\nstruct p8_ghash_desc_ctx *dctx = shash_desc_ctx(desc);\r\nif (IN_INTERRUPT) {\r\nreturn crypto_shash_update(&dctx->fallback_desc, src,\r\nsrclen);\r\n} else {\r\nif (dctx->bytes) {\r\nif (dctx->bytes + srclen < GHASH_DIGEST_SIZE) {\r\nmemcpy(dctx->buffer + dctx->bytes, src,\r\nsrclen);\r\ndctx->bytes += srclen;\r\nreturn 0;\r\n}\r\nmemcpy(dctx->buffer + dctx->bytes, src,\r\nGHASH_DIGEST_SIZE - dctx->bytes);\r\npreempt_disable();\r\npagefault_disable();\r\nenable_kernel_vsx();\r\ngcm_ghash_p8(dctx->shash, ctx->htable,\r\ndctx->buffer, GHASH_DIGEST_SIZE);\r\ndisable_kernel_vsx();\r\npagefault_enable();\r\npreempt_enable();\r\nsrc += GHASH_DIGEST_SIZE - dctx->bytes;\r\nsrclen -= GHASH_DIGEST_SIZE - dctx->bytes;\r\ndctx->bytes = 0;\r\n}\r\nlen = srclen & ~(GHASH_DIGEST_SIZE - 1);\r\nif (len) {\r\npreempt_disable();\r\npagefault_disable();\r\nenable_kernel_vsx();\r\ngcm_ghash_p8(dctx->shash, ctx->htable, src, len);\r\ndisable_kernel_vsx();\r\npagefault_enable();\r\npreempt_enable();\r\nsrc += len;\r\nsrclen -= len;\r\n}\r\nif (srclen) {\r\nmemcpy(dctx->buffer, src, srclen);\r\ndctx->bytes = srclen;\r\n}\r\nreturn 0;\r\n}\r\n}\r\nstatic int p8_ghash_final(struct shash_desc *desc, u8 *out)\r\n{\r\nint i;\r\nstruct p8_ghash_ctx *ctx = crypto_tfm_ctx(crypto_shash_tfm(desc->tfm));\r\nstruct p8_ghash_desc_ctx *dctx = shash_desc_ctx(desc);\r\nif (IN_INTERRUPT) {\r\nreturn crypto_shash_final(&dctx->fallback_desc, out);\r\n} else {\r\nif (dctx->bytes) {\r\nfor (i = dctx->bytes; i < GHASH_DIGEST_SIZE; i++)\r\ndctx->buffer[i] = 0;\r\npreempt_disable();\r\npagefault_disable();\r\nenable_kernel_vsx();\r\ngcm_ghash_p8(dctx->shash, ctx->htable,\r\ndctx->buffer, GHASH_DIGEST_SIZE);\r\ndisable_kernel_vsx();\r\npagefault_enable();\r\npreempt_enable();\r\ndctx->bytes = 0;\r\n}\r\nmemcpy(out, dctx->shash, GHASH_DIGEST_SIZE);\r\nreturn 0;\r\n}\r\n}
