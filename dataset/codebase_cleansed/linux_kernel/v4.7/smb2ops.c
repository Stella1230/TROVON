static int\r\nchange_conf(struct TCP_Server_Info *server)\r\n{\r\nserver->credits += server->echo_credits + server->oplock_credits;\r\nserver->oplock_credits = server->echo_credits = 0;\r\nswitch (server->credits) {\r\ncase 0:\r\nreturn -1;\r\ncase 1:\r\nserver->echoes = false;\r\nserver->oplocks = false;\r\ncifs_dbg(VFS, "disabling echoes and oplocks\n");\r\nbreak;\r\ncase 2:\r\nserver->echoes = true;\r\nserver->oplocks = false;\r\nserver->echo_credits = 1;\r\ncifs_dbg(FYI, "disabling oplocks\n");\r\nbreak;\r\ndefault:\r\nserver->echoes = true;\r\nif (enable_oplocks) {\r\nserver->oplocks = true;\r\nserver->oplock_credits = 1;\r\n} else\r\nserver->oplocks = false;\r\nserver->echo_credits = 1;\r\n}\r\nserver->credits -= server->echo_credits + server->oplock_credits;\r\nreturn 0;\r\n}\r\nstatic void\r\nsmb2_add_credits(struct TCP_Server_Info *server, const unsigned int add,\r\nconst int optype)\r\n{\r\nint *val, rc = 0;\r\nspin_lock(&server->req_lock);\r\nval = server->ops->get_credits_field(server, optype);\r\n*val += add;\r\nserver->in_flight--;\r\nif (server->in_flight == 0 && (optype & CIFS_OP_MASK) != CIFS_NEG_OP)\r\nrc = change_conf(server);\r\nelse if (server->in_flight > 0 && server->oplock_credits == 0 &&\r\nserver->oplocks) {\r\nif (server->credits > 1) {\r\nserver->credits--;\r\nserver->oplock_credits++;\r\n}\r\n}\r\nspin_unlock(&server->req_lock);\r\nwake_up(&server->request_q);\r\nif (rc)\r\ncifs_reconnect(server);\r\n}\r\nstatic void\r\nsmb2_set_credits(struct TCP_Server_Info *server, const int val)\r\n{\r\nspin_lock(&server->req_lock);\r\nserver->credits = val;\r\nspin_unlock(&server->req_lock);\r\n}\r\nstatic int *\r\nsmb2_get_credits_field(struct TCP_Server_Info *server, const int optype)\r\n{\r\nswitch (optype) {\r\ncase CIFS_ECHO_OP:\r\nreturn &server->echo_credits;\r\ncase CIFS_OBREAK_OP:\r\nreturn &server->oplock_credits;\r\ndefault:\r\nreturn &server->credits;\r\n}\r\n}\r\nstatic unsigned int\r\nsmb2_get_credits(struct mid_q_entry *mid)\r\n{\r\nreturn le16_to_cpu(((struct smb2_hdr *)mid->resp_buf)->CreditRequest);\r\n}\r\nstatic int\r\nsmb2_wait_mtu_credits(struct TCP_Server_Info *server, unsigned int size,\r\nunsigned int *num, unsigned int *credits)\r\n{\r\nint rc = 0;\r\nunsigned int scredits;\r\nspin_lock(&server->req_lock);\r\nwhile (1) {\r\nif (server->credits <= 0) {\r\nspin_unlock(&server->req_lock);\r\ncifs_num_waiters_inc(server);\r\nrc = wait_event_killable(server->request_q,\r\nhas_credits(server, &server->credits));\r\ncifs_num_waiters_dec(server);\r\nif (rc)\r\nreturn rc;\r\nspin_lock(&server->req_lock);\r\n} else {\r\nif (server->tcpStatus == CifsExiting) {\r\nspin_unlock(&server->req_lock);\r\nreturn -ENOENT;\r\n}\r\nscredits = server->credits;\r\nif (scredits == 1) {\r\n*num = SMB2_MAX_BUFFER_SIZE;\r\n*credits = 0;\r\nbreak;\r\n}\r\nscredits--;\r\n*num = min_t(unsigned int, size,\r\nscredits * SMB2_MAX_BUFFER_SIZE);\r\n*credits = DIV_ROUND_UP(*num, SMB2_MAX_BUFFER_SIZE);\r\nserver->credits -= *credits;\r\nserver->in_flight++;\r\nbreak;\r\n}\r\n}\r\nspin_unlock(&server->req_lock);\r\nreturn rc;\r\n}\r\nstatic __u64\r\nsmb2_get_next_mid(struct TCP_Server_Info *server)\r\n{\r\n__u64 mid;\r\nspin_lock(&GlobalMid_Lock);\r\nmid = server->CurrentMid++;\r\nspin_unlock(&GlobalMid_Lock);\r\nreturn mid;\r\n}\r\nstatic struct mid_q_entry *\r\nsmb2_find_mid(struct TCP_Server_Info *server, char *buf)\r\n{\r\nstruct mid_q_entry *mid;\r\nstruct smb2_hdr *hdr = (struct smb2_hdr *)buf;\r\n__u64 wire_mid = le64_to_cpu(hdr->MessageId);\r\nif (hdr->ProtocolId == SMB2_TRANSFORM_PROTO_NUM) {\r\ncifs_dbg(VFS, "encrypted frame parsing not supported yet");\r\nreturn NULL;\r\n}\r\nspin_lock(&GlobalMid_Lock);\r\nlist_for_each_entry(mid, &server->pending_mid_q, qhead) {\r\nif ((mid->mid == wire_mid) &&\r\n(mid->mid_state == MID_REQUEST_SUBMITTED) &&\r\n(mid->command == hdr->Command)) {\r\nspin_unlock(&GlobalMid_Lock);\r\nreturn mid;\r\n}\r\n}\r\nspin_unlock(&GlobalMid_Lock);\r\nreturn NULL;\r\n}\r\nstatic void\r\nsmb2_dump_detail(void *buf)\r\n{\r\n#ifdef CONFIG_CIFS_DEBUG2\r\nstruct smb2_hdr *smb = (struct smb2_hdr *)buf;\r\ncifs_dbg(VFS, "Cmd: %d Err: 0x%x Flags: 0x%x Mid: %llu Pid: %d\n",\r\nsmb->Command, smb->Status, smb->Flags, smb->MessageId,\r\nsmb->ProcessId);\r\ncifs_dbg(VFS, "smb buf %p len %u\n", smb, smb2_calc_size(smb));\r\n#endif\r\n}\r\nstatic bool\r\nsmb2_need_neg(struct TCP_Server_Info *server)\r\n{\r\nreturn server->max_read == 0;\r\n}\r\nstatic int\r\nsmb2_negotiate(const unsigned int xid, struct cifs_ses *ses)\r\n{\r\nint rc;\r\nses->server->CurrentMid = 0;\r\nrc = SMB2_negotiate(xid, ses);\r\nif (rc == -EAGAIN)\r\nrc = -EHOSTDOWN;\r\nreturn rc;\r\n}\r\nstatic unsigned int\r\nsmb2_negotiate_wsize(struct cifs_tcon *tcon, struct smb_vol *volume_info)\r\n{\r\nstruct TCP_Server_Info *server = tcon->ses->server;\r\nunsigned int wsize;\r\nwsize = volume_info->wsize ? volume_info->wsize : CIFS_DEFAULT_IOSIZE;\r\nwsize = min_t(unsigned int, wsize, server->max_write);\r\nif (!(server->capabilities & SMB2_GLOBAL_CAP_LARGE_MTU))\r\nwsize = min_t(unsigned int, wsize, SMB2_MAX_BUFFER_SIZE);\r\nreturn wsize;\r\n}\r\nstatic unsigned int\r\nsmb2_negotiate_rsize(struct cifs_tcon *tcon, struct smb_vol *volume_info)\r\n{\r\nstruct TCP_Server_Info *server = tcon->ses->server;\r\nunsigned int rsize;\r\nrsize = volume_info->rsize ? volume_info->rsize : CIFS_DEFAULT_IOSIZE;\r\nrsize = min_t(unsigned int, rsize, server->max_read);\r\nif (!(server->capabilities & SMB2_GLOBAL_CAP_LARGE_MTU))\r\nrsize = min_t(unsigned int, rsize, SMB2_MAX_BUFFER_SIZE);\r\nreturn rsize;\r\n}\r\nstatic int\r\nSMB3_request_interfaces(const unsigned int xid, struct cifs_tcon *tcon)\r\n{\r\nint rc;\r\nunsigned int ret_data_len = 0;\r\nstruct network_interface_info_ioctl_rsp *out_buf;\r\nrc = SMB2_ioctl(xid, tcon, NO_FILE_ID, NO_FILE_ID,\r\nFSCTL_QUERY_NETWORK_INTERFACE_INFO, true ,\r\nNULL , 0 ,\r\n(char **)&out_buf, &ret_data_len);\r\nif (rc != 0)\r\ncifs_dbg(VFS, "error %d on ioctl to get interface list\n", rc);\r\nelse if (ret_data_len < sizeof(struct network_interface_info_ioctl_rsp)) {\r\ncifs_dbg(VFS, "server returned bad net interface info buf\n");\r\nrc = -EINVAL;\r\n} else {\r\ncifs_dbg(FYI, "Adapter Capability 0x%x\t",\r\nle32_to_cpu(out_buf->Capability));\r\ncifs_dbg(FYI, "Link Speed %lld\n",\r\nle64_to_cpu(out_buf->LinkSpeed));\r\n}\r\nreturn rc;\r\n}\r\nstatic void\r\nsmb3_qfs_tcon(const unsigned int xid, struct cifs_tcon *tcon)\r\n{\r\nint rc;\r\n__le16 srch_path = 0;\r\nu8 oplock = SMB2_OPLOCK_LEVEL_NONE;\r\nstruct cifs_open_parms oparms;\r\nstruct cifs_fid fid;\r\noparms.tcon = tcon;\r\noparms.desired_access = FILE_READ_ATTRIBUTES;\r\noparms.disposition = FILE_OPEN;\r\noparms.create_options = 0;\r\noparms.fid = &fid;\r\noparms.reconnect = false;\r\nrc = SMB2_open(xid, &oparms, &srch_path, &oplock, NULL, NULL);\r\nif (rc)\r\nreturn;\r\n#ifdef CONFIG_CIFS_STATS2\r\nSMB3_request_interfaces(xid, tcon);\r\n#endif\r\nSMB2_QFS_attr(xid, tcon, fid.persistent_fid, fid.volatile_fid,\r\nFS_ATTRIBUTE_INFORMATION);\r\nSMB2_QFS_attr(xid, tcon, fid.persistent_fid, fid.volatile_fid,\r\nFS_DEVICE_INFORMATION);\r\nSMB2_QFS_attr(xid, tcon, fid.persistent_fid, fid.volatile_fid,\r\nFS_SECTOR_SIZE_INFORMATION);\r\nSMB2_close(xid, tcon, fid.persistent_fid, fid.volatile_fid);\r\nreturn;\r\n}\r\nstatic void\r\nsmb2_qfs_tcon(const unsigned int xid, struct cifs_tcon *tcon)\r\n{\r\nint rc;\r\n__le16 srch_path = 0;\r\nu8 oplock = SMB2_OPLOCK_LEVEL_NONE;\r\nstruct cifs_open_parms oparms;\r\nstruct cifs_fid fid;\r\noparms.tcon = tcon;\r\noparms.desired_access = FILE_READ_ATTRIBUTES;\r\noparms.disposition = FILE_OPEN;\r\noparms.create_options = 0;\r\noparms.fid = &fid;\r\noparms.reconnect = false;\r\nrc = SMB2_open(xid, &oparms, &srch_path, &oplock, NULL, NULL);\r\nif (rc)\r\nreturn;\r\nSMB2_QFS_attr(xid, tcon, fid.persistent_fid, fid.volatile_fid,\r\nFS_ATTRIBUTE_INFORMATION);\r\nSMB2_QFS_attr(xid, tcon, fid.persistent_fid, fid.volatile_fid,\r\nFS_DEVICE_INFORMATION);\r\nSMB2_close(xid, tcon, fid.persistent_fid, fid.volatile_fid);\r\nreturn;\r\n}\r\nstatic int\r\nsmb2_is_path_accessible(const unsigned int xid, struct cifs_tcon *tcon,\r\nstruct cifs_sb_info *cifs_sb, const char *full_path)\r\n{\r\nint rc;\r\n__le16 *utf16_path;\r\n__u8 oplock = SMB2_OPLOCK_LEVEL_NONE;\r\nstruct cifs_open_parms oparms;\r\nstruct cifs_fid fid;\r\nutf16_path = cifs_convert_path_to_utf16(full_path, cifs_sb);\r\nif (!utf16_path)\r\nreturn -ENOMEM;\r\noparms.tcon = tcon;\r\noparms.desired_access = FILE_READ_ATTRIBUTES;\r\noparms.disposition = FILE_OPEN;\r\noparms.create_options = 0;\r\noparms.fid = &fid;\r\noparms.reconnect = false;\r\nrc = SMB2_open(xid, &oparms, utf16_path, &oplock, NULL, NULL);\r\nif (rc) {\r\nkfree(utf16_path);\r\nreturn rc;\r\n}\r\nrc = SMB2_close(xid, tcon, fid.persistent_fid, fid.volatile_fid);\r\nkfree(utf16_path);\r\nreturn rc;\r\n}\r\nstatic int\r\nsmb2_get_srv_inum(const unsigned int xid, struct cifs_tcon *tcon,\r\nstruct cifs_sb_info *cifs_sb, const char *full_path,\r\nu64 *uniqueid, FILE_ALL_INFO *data)\r\n{\r\n*uniqueid = le64_to_cpu(data->IndexNumber);\r\nreturn 0;\r\n}\r\nstatic int\r\nsmb2_query_file_info(const unsigned int xid, struct cifs_tcon *tcon,\r\nstruct cifs_fid *fid, FILE_ALL_INFO *data)\r\n{\r\nint rc;\r\nstruct smb2_file_all_info *smb2_data;\r\nsmb2_data = kzalloc(sizeof(struct smb2_file_all_info) + PATH_MAX * 2,\r\nGFP_KERNEL);\r\nif (smb2_data == NULL)\r\nreturn -ENOMEM;\r\nrc = SMB2_query_info(xid, tcon, fid->persistent_fid, fid->volatile_fid,\r\nsmb2_data);\r\nif (!rc)\r\nmove_smb2_info_to_cifs(data, smb2_data);\r\nkfree(smb2_data);\r\nreturn rc;\r\n}\r\nstatic bool\r\nsmb2_can_echo(struct TCP_Server_Info *server)\r\n{\r\nreturn server->echoes;\r\n}\r\nstatic void\r\nsmb2_clear_stats(struct cifs_tcon *tcon)\r\n{\r\n#ifdef CONFIG_CIFS_STATS\r\nint i;\r\nfor (i = 0; i < NUMBER_OF_SMB2_COMMANDS; i++) {\r\natomic_set(&tcon->stats.smb2_stats.smb2_com_sent[i], 0);\r\natomic_set(&tcon->stats.smb2_stats.smb2_com_failed[i], 0);\r\n}\r\n#endif\r\n}\r\nstatic void\r\nsmb2_dump_share_caps(struct seq_file *m, struct cifs_tcon *tcon)\r\n{\r\nseq_puts(m, "\n\tShare Capabilities:");\r\nif (tcon->capabilities & SMB2_SHARE_CAP_DFS)\r\nseq_puts(m, " DFS,");\r\nif (tcon->capabilities & SMB2_SHARE_CAP_CONTINUOUS_AVAILABILITY)\r\nseq_puts(m, " CONTINUOUS AVAILABILITY,");\r\nif (tcon->capabilities & SMB2_SHARE_CAP_SCALEOUT)\r\nseq_puts(m, " SCALEOUT,");\r\nif (tcon->capabilities & SMB2_SHARE_CAP_CLUSTER)\r\nseq_puts(m, " CLUSTER,");\r\nif (tcon->capabilities & SMB2_SHARE_CAP_ASYMMETRIC)\r\nseq_puts(m, " ASYMMETRIC,");\r\nif (tcon->capabilities == 0)\r\nseq_puts(m, " None");\r\nif (tcon->ss_flags & SSINFO_FLAGS_ALIGNED_DEVICE)\r\nseq_puts(m, " Aligned,");\r\nif (tcon->ss_flags & SSINFO_FLAGS_PARTITION_ALIGNED_ON_DEVICE)\r\nseq_puts(m, " Partition Aligned,");\r\nif (tcon->ss_flags & SSINFO_FLAGS_NO_SEEK_PENALTY)\r\nseq_puts(m, " SSD,");\r\nif (tcon->ss_flags & SSINFO_FLAGS_TRIM_ENABLED)\r\nseq_puts(m, " TRIM-support,");\r\nseq_printf(m, "\tShare Flags: 0x%x", tcon->share_flags);\r\nif (tcon->perf_sector_size)\r\nseq_printf(m, "\tOptimal sector size: 0x%x",\r\ntcon->perf_sector_size);\r\n}\r\nstatic void\r\nsmb2_print_stats(struct seq_file *m, struct cifs_tcon *tcon)\r\n{\r\n#ifdef CONFIG_CIFS_STATS\r\natomic_t *sent = tcon->stats.smb2_stats.smb2_com_sent;\r\natomic_t *failed = tcon->stats.smb2_stats.smb2_com_failed;\r\nseq_printf(m, "\nNegotiates: %d sent %d failed",\r\natomic_read(&sent[SMB2_NEGOTIATE_HE]),\r\natomic_read(&failed[SMB2_NEGOTIATE_HE]));\r\nseq_printf(m, "\nSessionSetups: %d sent %d failed",\r\natomic_read(&sent[SMB2_SESSION_SETUP_HE]),\r\natomic_read(&failed[SMB2_SESSION_SETUP_HE]));\r\nseq_printf(m, "\nLogoffs: %d sent %d failed",\r\natomic_read(&sent[SMB2_LOGOFF_HE]),\r\natomic_read(&failed[SMB2_LOGOFF_HE]));\r\nseq_printf(m, "\nTreeConnects: %d sent %d failed",\r\natomic_read(&sent[SMB2_TREE_CONNECT_HE]),\r\natomic_read(&failed[SMB2_TREE_CONNECT_HE]));\r\nseq_printf(m, "\nTreeDisconnects: %d sent %d failed",\r\natomic_read(&sent[SMB2_TREE_DISCONNECT_HE]),\r\natomic_read(&failed[SMB2_TREE_DISCONNECT_HE]));\r\nseq_printf(m, "\nCreates: %d sent %d failed",\r\natomic_read(&sent[SMB2_CREATE_HE]),\r\natomic_read(&failed[SMB2_CREATE_HE]));\r\nseq_printf(m, "\nCloses: %d sent %d failed",\r\natomic_read(&sent[SMB2_CLOSE_HE]),\r\natomic_read(&failed[SMB2_CLOSE_HE]));\r\nseq_printf(m, "\nFlushes: %d sent %d failed",\r\natomic_read(&sent[SMB2_FLUSH_HE]),\r\natomic_read(&failed[SMB2_FLUSH_HE]));\r\nseq_printf(m, "\nReads: %d sent %d failed",\r\natomic_read(&sent[SMB2_READ_HE]),\r\natomic_read(&failed[SMB2_READ_HE]));\r\nseq_printf(m, "\nWrites: %d sent %d failed",\r\natomic_read(&sent[SMB2_WRITE_HE]),\r\natomic_read(&failed[SMB2_WRITE_HE]));\r\nseq_printf(m, "\nLocks: %d sent %d failed",\r\natomic_read(&sent[SMB2_LOCK_HE]),\r\natomic_read(&failed[SMB2_LOCK_HE]));\r\nseq_printf(m, "\nIOCTLs: %d sent %d failed",\r\natomic_read(&sent[SMB2_IOCTL_HE]),\r\natomic_read(&failed[SMB2_IOCTL_HE]));\r\nseq_printf(m, "\nCancels: %d sent %d failed",\r\natomic_read(&sent[SMB2_CANCEL_HE]),\r\natomic_read(&failed[SMB2_CANCEL_HE]));\r\nseq_printf(m, "\nEchos: %d sent %d failed",\r\natomic_read(&sent[SMB2_ECHO_HE]),\r\natomic_read(&failed[SMB2_ECHO_HE]));\r\nseq_printf(m, "\nQueryDirectories: %d sent %d failed",\r\natomic_read(&sent[SMB2_QUERY_DIRECTORY_HE]),\r\natomic_read(&failed[SMB2_QUERY_DIRECTORY_HE]));\r\nseq_printf(m, "\nChangeNotifies: %d sent %d failed",\r\natomic_read(&sent[SMB2_CHANGE_NOTIFY_HE]),\r\natomic_read(&failed[SMB2_CHANGE_NOTIFY_HE]));\r\nseq_printf(m, "\nQueryInfos: %d sent %d failed",\r\natomic_read(&sent[SMB2_QUERY_INFO_HE]),\r\natomic_read(&failed[SMB2_QUERY_INFO_HE]));\r\nseq_printf(m, "\nSetInfos: %d sent %d failed",\r\natomic_read(&sent[SMB2_SET_INFO_HE]),\r\natomic_read(&failed[SMB2_SET_INFO_HE]));\r\nseq_printf(m, "\nOplockBreaks: %d sent %d failed",\r\natomic_read(&sent[SMB2_OPLOCK_BREAK_HE]),\r\natomic_read(&failed[SMB2_OPLOCK_BREAK_HE]));\r\n#endif\r\n}\r\nstatic void\r\nsmb2_set_fid(struct cifsFileInfo *cfile, struct cifs_fid *fid, __u32 oplock)\r\n{\r\nstruct cifsInodeInfo *cinode = CIFS_I(d_inode(cfile->dentry));\r\nstruct TCP_Server_Info *server = tlink_tcon(cfile->tlink)->ses->server;\r\ncfile->fid.persistent_fid = fid->persistent_fid;\r\ncfile->fid.volatile_fid = fid->volatile_fid;\r\nserver->ops->set_oplock_level(cinode, oplock, fid->epoch,\r\n&fid->purge_cache);\r\ncinode->can_cache_brlcks = CIFS_CACHE_WRITE(cinode);\r\n}\r\nstatic void\r\nsmb2_close_file(const unsigned int xid, struct cifs_tcon *tcon,\r\nstruct cifs_fid *fid)\r\n{\r\nSMB2_close(xid, tcon, fid->persistent_fid, fid->volatile_fid);\r\n}\r\nstatic int\r\nSMB2_request_res_key(const unsigned int xid, struct cifs_tcon *tcon,\r\nu64 persistent_fid, u64 volatile_fid,\r\nstruct copychunk_ioctl *pcchunk)\r\n{\r\nint rc;\r\nunsigned int ret_data_len;\r\nstruct resume_key_req *res_key;\r\nrc = SMB2_ioctl(xid, tcon, persistent_fid, volatile_fid,\r\nFSCTL_SRV_REQUEST_RESUME_KEY, true ,\r\nNULL, 0 ,\r\n(char **)&res_key, &ret_data_len);\r\nif (rc) {\r\ncifs_dbg(VFS, "refcpy ioctl error %d getting resume key\n", rc);\r\ngoto req_res_key_exit;\r\n}\r\nif (ret_data_len < sizeof(struct resume_key_req)) {\r\ncifs_dbg(VFS, "Invalid refcopy resume key length\n");\r\nrc = -EINVAL;\r\ngoto req_res_key_exit;\r\n}\r\nmemcpy(pcchunk->SourceKey, res_key->ResumeKey, COPY_CHUNK_RES_KEY_SIZE);\r\nreq_res_key_exit:\r\nkfree(res_key);\r\nreturn rc;\r\n}\r\nstatic int\r\nsmb2_clone_range(const unsigned int xid,\r\nstruct cifsFileInfo *srcfile,\r\nstruct cifsFileInfo *trgtfile, u64 src_off,\r\nu64 len, u64 dest_off)\r\n{\r\nint rc;\r\nunsigned int ret_data_len;\r\nstruct copychunk_ioctl *pcchunk;\r\nstruct copychunk_ioctl_rsp *retbuf = NULL;\r\nstruct cifs_tcon *tcon;\r\nint chunks_copied = 0;\r\nbool chunk_sizes_updated = false;\r\npcchunk = kmalloc(sizeof(struct copychunk_ioctl), GFP_KERNEL);\r\nif (pcchunk == NULL)\r\nreturn -ENOMEM;\r\ncifs_dbg(FYI, "in smb2_clone_range - about to call request res key\n");\r\nrc = SMB2_request_res_key(xid, tlink_tcon(srcfile->tlink),\r\nsrcfile->fid.persistent_fid,\r\nsrcfile->fid.volatile_fid, pcchunk);\r\nif (rc)\r\ngoto cchunk_out;\r\npcchunk->ChunkCount = cpu_to_le32(1);\r\npcchunk->Reserved = 0;\r\npcchunk->Reserved2 = 0;\r\ntcon = tlink_tcon(trgtfile->tlink);\r\nwhile (len > 0) {\r\npcchunk->SourceOffset = cpu_to_le64(src_off);\r\npcchunk->TargetOffset = cpu_to_le64(dest_off);\r\npcchunk->Length =\r\ncpu_to_le32(min_t(u32, len, tcon->max_bytes_chunk));\r\nrc = SMB2_ioctl(xid, tcon, trgtfile->fid.persistent_fid,\r\ntrgtfile->fid.volatile_fid, FSCTL_SRV_COPYCHUNK_WRITE,\r\ntrue , (char *)pcchunk,\r\nsizeof(struct copychunk_ioctl), (char **)&retbuf,\r\n&ret_data_len);\r\nif (rc == 0) {\r\nif (ret_data_len !=\r\nsizeof(struct copychunk_ioctl_rsp)) {\r\ncifs_dbg(VFS, "invalid cchunk response size\n");\r\nrc = -EIO;\r\ngoto cchunk_out;\r\n}\r\nif (retbuf->TotalBytesWritten == 0) {\r\ncifs_dbg(FYI, "no bytes copied\n");\r\nrc = -EIO;\r\ngoto cchunk_out;\r\n}\r\nif (le32_to_cpu(retbuf->TotalBytesWritten) >\r\nle32_to_cpu(pcchunk->Length)) {\r\ncifs_dbg(VFS, "invalid copy chunk response\n");\r\nrc = -EIO;\r\ngoto cchunk_out;\r\n}\r\nif (le32_to_cpu(retbuf->ChunksWritten) != 1) {\r\ncifs_dbg(VFS, "invalid num chunks written\n");\r\nrc = -EIO;\r\ngoto cchunk_out;\r\n}\r\nchunks_copied++;\r\nsrc_off += le32_to_cpu(retbuf->TotalBytesWritten);\r\ndest_off += le32_to_cpu(retbuf->TotalBytesWritten);\r\nlen -= le32_to_cpu(retbuf->TotalBytesWritten);\r\ncifs_dbg(FYI, "Chunks %d PartialChunk %d Total %d\n",\r\nle32_to_cpu(retbuf->ChunksWritten),\r\nle32_to_cpu(retbuf->ChunkBytesWritten),\r\nle32_to_cpu(retbuf->TotalBytesWritten));\r\n} else if (rc == -EINVAL) {\r\nif (ret_data_len != sizeof(struct copychunk_ioctl_rsp))\r\ngoto cchunk_out;\r\ncifs_dbg(FYI, "MaxChunks %d BytesChunk %d MaxCopy %d\n",\r\nle32_to_cpu(retbuf->ChunksWritten),\r\nle32_to_cpu(retbuf->ChunkBytesWritten),\r\nle32_to_cpu(retbuf->TotalBytesWritten));\r\nif ((chunks_copied != 0) || chunk_sizes_updated)\r\ngoto cchunk_out;\r\nif (le32_to_cpu(retbuf->ChunkBytesWritten) <\r\ntcon->max_bytes_chunk)\r\ntcon->max_bytes_chunk =\r\nle32_to_cpu(retbuf->ChunkBytesWritten);\r\nelse\r\ngoto cchunk_out;\r\nchunk_sizes_updated = true;\r\n} else\r\ngoto cchunk_out;\r\n}\r\ncchunk_out:\r\nkfree(pcchunk);\r\nreturn rc;\r\n}\r\nstatic int\r\nsmb2_flush_file(const unsigned int xid, struct cifs_tcon *tcon,\r\nstruct cifs_fid *fid)\r\n{\r\nreturn SMB2_flush(xid, tcon, fid->persistent_fid, fid->volatile_fid);\r\n}\r\nstatic unsigned int\r\nsmb2_read_data_offset(char *buf)\r\n{\r\nstruct smb2_read_rsp *rsp = (struct smb2_read_rsp *)buf;\r\nreturn rsp->DataOffset;\r\n}\r\nstatic unsigned int\r\nsmb2_read_data_length(char *buf)\r\n{\r\nstruct smb2_read_rsp *rsp = (struct smb2_read_rsp *)buf;\r\nreturn le32_to_cpu(rsp->DataLength);\r\n}\r\nstatic int\r\nsmb2_sync_read(const unsigned int xid, struct cifs_fid *pfid,\r\nstruct cifs_io_parms *parms, unsigned int *bytes_read,\r\nchar **buf, int *buf_type)\r\n{\r\nparms->persistent_fid = pfid->persistent_fid;\r\nparms->volatile_fid = pfid->volatile_fid;\r\nreturn SMB2_read(xid, parms, bytes_read, buf, buf_type);\r\n}\r\nstatic int\r\nsmb2_sync_write(const unsigned int xid, struct cifs_fid *pfid,\r\nstruct cifs_io_parms *parms, unsigned int *written,\r\nstruct kvec *iov, unsigned long nr_segs)\r\n{\r\nparms->persistent_fid = pfid->persistent_fid;\r\nparms->volatile_fid = pfid->volatile_fid;\r\nreturn SMB2_write(xid, parms, written, iov, nr_segs);\r\n}\r\nstatic bool smb2_set_sparse(const unsigned int xid, struct cifs_tcon *tcon,\r\nstruct cifsFileInfo *cfile, struct inode *inode, __u8 setsparse)\r\n{\r\nstruct cifsInodeInfo *cifsi;\r\nint rc;\r\ncifsi = CIFS_I(inode);\r\nif ((cifsi->cifsAttrs & FILE_ATTRIBUTE_SPARSE_FILE) && setsparse)\r\nreturn true;\r\nif (!(cifsi->cifsAttrs & FILE_ATTRIBUTE_SPARSE_FILE) && !setsparse)\r\nreturn true;\r\nif (tcon->broken_sparse_sup)\r\nreturn false;\r\nrc = SMB2_ioctl(xid, tcon, cfile->fid.persistent_fid,\r\ncfile->fid.volatile_fid, FSCTL_SET_SPARSE,\r\ntrue , &setsparse, 1, NULL, NULL);\r\nif (rc) {\r\ntcon->broken_sparse_sup = true;\r\ncifs_dbg(FYI, "set sparse rc = %d\n", rc);\r\nreturn false;\r\n}\r\nif (setsparse)\r\ncifsi->cifsAttrs |= FILE_ATTRIBUTE_SPARSE_FILE;\r\nelse\r\ncifsi->cifsAttrs &= (~FILE_ATTRIBUTE_SPARSE_FILE);\r\nreturn true;\r\n}\r\nstatic int\r\nsmb2_set_file_size(const unsigned int xid, struct cifs_tcon *tcon,\r\nstruct cifsFileInfo *cfile, __u64 size, bool set_alloc)\r\n{\r\n__le64 eof = cpu_to_le64(size);\r\nstruct inode *inode;\r\ninode = d_inode(cfile->dentry);\r\nif (!set_alloc && (size > inode->i_size + 8192)) {\r\n__u8 set_sparse = 1;\r\nsmb2_set_sparse(xid, tcon, cfile, inode, set_sparse);\r\n}\r\nreturn SMB2_set_eof(xid, tcon, cfile->fid.persistent_fid,\r\ncfile->fid.volatile_fid, cfile->pid, &eof, false);\r\n}\r\nstatic int\r\nsmb2_duplicate_extents(const unsigned int xid,\r\nstruct cifsFileInfo *srcfile,\r\nstruct cifsFileInfo *trgtfile, u64 src_off,\r\nu64 len, u64 dest_off)\r\n{\r\nint rc;\r\nunsigned int ret_data_len;\r\nchar *retbuf = NULL;\r\nstruct duplicate_extents_to_file dup_ext_buf;\r\nstruct cifs_tcon *tcon = tlink_tcon(trgtfile->tlink);\r\nif ((le32_to_cpu(tcon->fsAttrInfo.Attributes) &\r\nFILE_SUPPORTS_BLOCK_REFCOUNTING) == 0)\r\nreturn -EOPNOTSUPP;\r\ndup_ext_buf.VolatileFileHandle = srcfile->fid.volatile_fid;\r\ndup_ext_buf.PersistentFileHandle = srcfile->fid.persistent_fid;\r\ndup_ext_buf.SourceFileOffset = cpu_to_le64(src_off);\r\ndup_ext_buf.TargetFileOffset = cpu_to_le64(dest_off);\r\ndup_ext_buf.ByteCount = cpu_to_le64(len);\r\ncifs_dbg(FYI, "duplicate extents: src off %lld dst off %lld len %lld",\r\nsrc_off, dest_off, len);\r\nrc = smb2_set_file_size(xid, tcon, trgtfile, dest_off + len, false);\r\nif (rc)\r\ngoto duplicate_extents_out;\r\nrc = SMB2_ioctl(xid, tcon, trgtfile->fid.persistent_fid,\r\ntrgtfile->fid.volatile_fid,\r\nFSCTL_DUPLICATE_EXTENTS_TO_FILE,\r\ntrue , (char *)&dup_ext_buf,\r\nsizeof(struct duplicate_extents_to_file),\r\n(char **)&retbuf,\r\n&ret_data_len);\r\nif (ret_data_len > 0)\r\ncifs_dbg(FYI, "non-zero response length in duplicate extents");\r\nduplicate_extents_out:\r\nreturn rc;\r\n}\r\nstatic int\r\nsmb2_set_compression(const unsigned int xid, struct cifs_tcon *tcon,\r\nstruct cifsFileInfo *cfile)\r\n{\r\nreturn SMB2_set_compression(xid, tcon, cfile->fid.persistent_fid,\r\ncfile->fid.volatile_fid);\r\n}\r\nstatic int\r\nsmb3_set_integrity(const unsigned int xid, struct cifs_tcon *tcon,\r\nstruct cifsFileInfo *cfile)\r\n{\r\nstruct fsctl_set_integrity_information_req integr_info;\r\nchar *retbuf = NULL;\r\nunsigned int ret_data_len;\r\nintegr_info.ChecksumAlgorithm = cpu_to_le16(CHECKSUM_TYPE_UNCHANGED);\r\nintegr_info.Flags = 0;\r\nintegr_info.Reserved = 0;\r\nreturn SMB2_ioctl(xid, tcon, cfile->fid.persistent_fid,\r\ncfile->fid.volatile_fid,\r\nFSCTL_SET_INTEGRITY_INFORMATION,\r\ntrue , (char *)&integr_info,\r\nsizeof(struct fsctl_set_integrity_information_req),\r\n(char **)&retbuf,\r\n&ret_data_len);\r\n}\r\nstatic int\r\nsmb2_query_dir_first(const unsigned int xid, struct cifs_tcon *tcon,\r\nconst char *path, struct cifs_sb_info *cifs_sb,\r\nstruct cifs_fid *fid, __u16 search_flags,\r\nstruct cifs_search_info *srch_inf)\r\n{\r\n__le16 *utf16_path;\r\nint rc;\r\n__u8 oplock = SMB2_OPLOCK_LEVEL_NONE;\r\nstruct cifs_open_parms oparms;\r\nutf16_path = cifs_convert_path_to_utf16(path, cifs_sb);\r\nif (!utf16_path)\r\nreturn -ENOMEM;\r\noparms.tcon = tcon;\r\noparms.desired_access = FILE_READ_ATTRIBUTES | FILE_READ_DATA;\r\noparms.disposition = FILE_OPEN;\r\noparms.create_options = 0;\r\noparms.fid = fid;\r\noparms.reconnect = false;\r\nrc = SMB2_open(xid, &oparms, utf16_path, &oplock, NULL, NULL);\r\nkfree(utf16_path);\r\nif (rc) {\r\ncifs_dbg(VFS, "open dir failed\n");\r\nreturn rc;\r\n}\r\nsrch_inf->entries_in_buffer = 0;\r\nsrch_inf->index_of_last_entry = 0;\r\nrc = SMB2_query_directory(xid, tcon, fid->persistent_fid,\r\nfid->volatile_fid, 0, srch_inf);\r\nif (rc) {\r\ncifs_dbg(VFS, "query directory failed\n");\r\nSMB2_close(xid, tcon, fid->persistent_fid, fid->volatile_fid);\r\n}\r\nreturn rc;\r\n}\r\nstatic int\r\nsmb2_query_dir_next(const unsigned int xid, struct cifs_tcon *tcon,\r\nstruct cifs_fid *fid, __u16 search_flags,\r\nstruct cifs_search_info *srch_inf)\r\n{\r\nreturn SMB2_query_directory(xid, tcon, fid->persistent_fid,\r\nfid->volatile_fid, 0, srch_inf);\r\n}\r\nstatic int\r\nsmb2_close_dir(const unsigned int xid, struct cifs_tcon *tcon,\r\nstruct cifs_fid *fid)\r\n{\r\nreturn SMB2_close(xid, tcon, fid->persistent_fid, fid->volatile_fid);\r\n}\r\nstatic bool\r\nsmb2_is_status_pending(char *buf, struct TCP_Server_Info *server, int length)\r\n{\r\nstruct smb2_hdr *hdr = (struct smb2_hdr *)buf;\r\nif (hdr->Status != STATUS_PENDING)\r\nreturn false;\r\nif (!length) {\r\nspin_lock(&server->req_lock);\r\nserver->credits += le16_to_cpu(hdr->CreditRequest);\r\nspin_unlock(&server->req_lock);\r\nwake_up(&server->request_q);\r\n}\r\nreturn true;\r\n}\r\nstatic int\r\nsmb2_oplock_response(struct cifs_tcon *tcon, struct cifs_fid *fid,\r\nstruct cifsInodeInfo *cinode)\r\n{\r\nif (tcon->ses->server->capabilities & SMB2_GLOBAL_CAP_LEASING)\r\nreturn SMB2_lease_break(0, tcon, cinode->lease_key,\r\nsmb2_get_lease_state(cinode));\r\nreturn SMB2_oplock_break(0, tcon, fid->persistent_fid,\r\nfid->volatile_fid,\r\nCIFS_CACHE_READ(cinode) ? 1 : 0);\r\n}\r\nstatic int\r\nsmb2_queryfs(const unsigned int xid, struct cifs_tcon *tcon,\r\nstruct kstatfs *buf)\r\n{\r\nint rc;\r\n__le16 srch_path = 0;\r\nu8 oplock = SMB2_OPLOCK_LEVEL_NONE;\r\nstruct cifs_open_parms oparms;\r\nstruct cifs_fid fid;\r\noparms.tcon = tcon;\r\noparms.desired_access = FILE_READ_ATTRIBUTES;\r\noparms.disposition = FILE_OPEN;\r\noparms.create_options = 0;\r\noparms.fid = &fid;\r\noparms.reconnect = false;\r\nrc = SMB2_open(xid, &oparms, &srch_path, &oplock, NULL, NULL);\r\nif (rc)\r\nreturn rc;\r\nbuf->f_type = SMB2_MAGIC_NUMBER;\r\nrc = SMB2_QFS_info(xid, tcon, fid.persistent_fid, fid.volatile_fid,\r\nbuf);\r\nSMB2_close(xid, tcon, fid.persistent_fid, fid.volatile_fid);\r\nreturn rc;\r\n}\r\nstatic bool\r\nsmb2_compare_fids(struct cifsFileInfo *ob1, struct cifsFileInfo *ob2)\r\n{\r\nreturn ob1->fid.persistent_fid == ob2->fid.persistent_fid &&\r\nob1->fid.volatile_fid == ob2->fid.volatile_fid;\r\n}\r\nstatic int\r\nsmb2_mand_lock(const unsigned int xid, struct cifsFileInfo *cfile, __u64 offset,\r\n__u64 length, __u32 type, int lock, int unlock, bool wait)\r\n{\r\nif (unlock && !lock)\r\ntype = SMB2_LOCKFLAG_UNLOCK;\r\nreturn SMB2_lock(xid, tlink_tcon(cfile->tlink),\r\ncfile->fid.persistent_fid, cfile->fid.volatile_fid,\r\ncurrent->tgid, length, offset, type, wait);\r\n}\r\nstatic void\r\nsmb2_get_lease_key(struct inode *inode, struct cifs_fid *fid)\r\n{\r\nmemcpy(fid->lease_key, CIFS_I(inode)->lease_key, SMB2_LEASE_KEY_SIZE);\r\n}\r\nstatic void\r\nsmb2_set_lease_key(struct inode *inode, struct cifs_fid *fid)\r\n{\r\nmemcpy(CIFS_I(inode)->lease_key, fid->lease_key, SMB2_LEASE_KEY_SIZE);\r\n}\r\nstatic void\r\nsmb2_new_lease_key(struct cifs_fid *fid)\r\n{\r\nget_random_bytes(fid->lease_key, SMB2_LEASE_KEY_SIZE);\r\n}\r\nstatic int\r\nsmb2_query_symlink(const unsigned int xid, struct cifs_tcon *tcon,\r\nconst char *full_path, char **target_path,\r\nstruct cifs_sb_info *cifs_sb)\r\n{\r\nint rc;\r\n__le16 *utf16_path;\r\n__u8 oplock = SMB2_OPLOCK_LEVEL_NONE;\r\nstruct cifs_open_parms oparms;\r\nstruct cifs_fid fid;\r\nstruct smb2_err_rsp *err_buf = NULL;\r\nstruct smb2_symlink_err_rsp *symlink;\r\nunsigned int sub_len, sub_offset;\r\ncifs_dbg(FYI, "%s: path: %s\n", __func__, full_path);\r\nutf16_path = cifs_convert_path_to_utf16(full_path, cifs_sb);\r\nif (!utf16_path)\r\nreturn -ENOMEM;\r\noparms.tcon = tcon;\r\noparms.desired_access = FILE_READ_ATTRIBUTES;\r\noparms.disposition = FILE_OPEN;\r\noparms.create_options = 0;\r\noparms.fid = &fid;\r\noparms.reconnect = false;\r\nrc = SMB2_open(xid, &oparms, utf16_path, &oplock, NULL, &err_buf);\r\nif (!rc || !err_buf) {\r\nkfree(utf16_path);\r\nreturn -ENOENT;\r\n}\r\nrc = 0;\r\nsymlink = (struct smb2_symlink_err_rsp *)err_buf->ErrorData;\r\nsub_len = le16_to_cpu(symlink->SubstituteNameLength);\r\nsub_offset = le16_to_cpu(symlink->SubstituteNameOffset);\r\n*target_path = cifs_strndup_from_utf16(\r\n(char *)symlink->PathBuffer + sub_offset,\r\nsub_len, true, cifs_sb->local_nls);\r\nif (!(*target_path)) {\r\nkfree(utf16_path);\r\nreturn -ENOMEM;\r\n}\r\nconvert_delimiter(*target_path, '/');\r\ncifs_dbg(FYI, "%s: target path: %s\n", __func__, *target_path);\r\nkfree(utf16_path);\r\nreturn rc;\r\n}\r\nstatic long smb3_zero_range(struct file *file, struct cifs_tcon *tcon,\r\nloff_t offset, loff_t len, bool keep_size)\r\n{\r\nstruct inode *inode;\r\nstruct cifsInodeInfo *cifsi;\r\nstruct cifsFileInfo *cfile = file->private_data;\r\nstruct file_zero_data_information fsctl_buf;\r\nlong rc;\r\nunsigned int xid;\r\nxid = get_xid();\r\ninode = d_inode(cfile->dentry);\r\ncifsi = CIFS_I(inode);\r\nif (!CIFS_CACHE_READ(cifsi))\r\nif (keep_size == false)\r\nreturn -EOPNOTSUPP;\r\nif (!(cifsi->cifsAttrs & FILE_ATTRIBUTE_SPARSE_FILE))\r\nreturn -EOPNOTSUPP;\r\nif (keep_size == false)\r\nif (i_size_read(inode) < offset + len)\r\nreturn -EOPNOTSUPP;\r\ncifs_dbg(FYI, "offset %lld len %lld", offset, len);\r\nfsctl_buf.FileOffset = cpu_to_le64(offset);\r\nfsctl_buf.BeyondFinalZero = cpu_to_le64(offset + len);\r\nrc = SMB2_ioctl(xid, tcon, cfile->fid.persistent_fid,\r\ncfile->fid.volatile_fid, FSCTL_SET_ZERO_DATA,\r\ntrue , (char *)&fsctl_buf,\r\nsizeof(struct file_zero_data_information), NULL, NULL);\r\nfree_xid(xid);\r\nreturn rc;\r\n}\r\nstatic long smb3_punch_hole(struct file *file, struct cifs_tcon *tcon,\r\nloff_t offset, loff_t len)\r\n{\r\nstruct inode *inode;\r\nstruct cifsInodeInfo *cifsi;\r\nstruct cifsFileInfo *cfile = file->private_data;\r\nstruct file_zero_data_information fsctl_buf;\r\nlong rc;\r\nunsigned int xid;\r\n__u8 set_sparse = 1;\r\nxid = get_xid();\r\ninode = d_inode(cfile->dentry);\r\ncifsi = CIFS_I(inode);\r\nif (!smb2_set_sparse(xid, tcon, cfile, inode, set_sparse))\r\nreturn -EOPNOTSUPP;\r\ncifs_dbg(FYI, "offset %lld len %lld", offset, len);\r\nfsctl_buf.FileOffset = cpu_to_le64(offset);\r\nfsctl_buf.BeyondFinalZero = cpu_to_le64(offset + len);\r\nrc = SMB2_ioctl(xid, tcon, cfile->fid.persistent_fid,\r\ncfile->fid.volatile_fid, FSCTL_SET_ZERO_DATA,\r\ntrue , (char *)&fsctl_buf,\r\nsizeof(struct file_zero_data_information), NULL, NULL);\r\nfree_xid(xid);\r\nreturn rc;\r\n}\r\nstatic long smb3_simple_falloc(struct file *file, struct cifs_tcon *tcon,\r\nloff_t off, loff_t len, bool keep_size)\r\n{\r\nstruct inode *inode;\r\nstruct cifsInodeInfo *cifsi;\r\nstruct cifsFileInfo *cfile = file->private_data;\r\nlong rc = -EOPNOTSUPP;\r\nunsigned int xid;\r\nxid = get_xid();\r\ninode = d_inode(cfile->dentry);\r\ncifsi = CIFS_I(inode);\r\nif (!CIFS_CACHE_READ(cifsi))\r\nif (keep_size == false)\r\nreturn -EOPNOTSUPP;\r\nif ((cifsi->cifsAttrs & FILE_ATTRIBUTE_SPARSE_FILE) == 0) {\r\nif (keep_size == true)\r\nreturn 0;\r\nelse if (i_size_read(inode) >= off + len)\r\nreturn 0;\r\nelse\r\nreturn -EOPNOTSUPP;\r\n}\r\nif ((keep_size == true) || (i_size_read(inode) >= off + len)) {\r\nif ((off > 8192) || (off + len + 8192 < i_size_read(inode)))\r\nreturn -EOPNOTSUPP;\r\nrc = smb2_set_sparse(xid, tcon, cfile, inode, false);\r\n}\r\nfree_xid(xid);\r\nreturn rc;\r\n}\r\nstatic long smb3_fallocate(struct file *file, struct cifs_tcon *tcon, int mode,\r\nloff_t off, loff_t len)\r\n{\r\nif (mode & FALLOC_FL_PUNCH_HOLE)\r\nreturn smb3_punch_hole(file, tcon, off, len);\r\nelse if (mode & FALLOC_FL_ZERO_RANGE) {\r\nif (mode & FALLOC_FL_KEEP_SIZE)\r\nreturn smb3_zero_range(file, tcon, off, len, true);\r\nreturn smb3_zero_range(file, tcon, off, len, false);\r\n} else if (mode == FALLOC_FL_KEEP_SIZE)\r\nreturn smb3_simple_falloc(file, tcon, off, len, true);\r\nelse if (mode == 0)\r\nreturn smb3_simple_falloc(file, tcon, off, len, false);\r\nreturn -EOPNOTSUPP;\r\n}\r\nstatic void\r\nsmb2_downgrade_oplock(struct TCP_Server_Info *server,\r\nstruct cifsInodeInfo *cinode, bool set_level2)\r\n{\r\nif (set_level2)\r\nserver->ops->set_oplock_level(cinode, SMB2_OPLOCK_LEVEL_II,\r\n0, NULL);\r\nelse\r\nserver->ops->set_oplock_level(cinode, 0, 0, NULL);\r\n}\r\nstatic void\r\nsmb2_set_oplock_level(struct cifsInodeInfo *cinode, __u32 oplock,\r\nunsigned int epoch, bool *purge_cache)\r\n{\r\noplock &= 0xFF;\r\nif (oplock == SMB2_OPLOCK_LEVEL_NOCHANGE)\r\nreturn;\r\nif (oplock == SMB2_OPLOCK_LEVEL_BATCH) {\r\ncinode->oplock = CIFS_CACHE_RHW_FLG;\r\ncifs_dbg(FYI, "Batch Oplock granted on inode %p\n",\r\n&cinode->vfs_inode);\r\n} else if (oplock == SMB2_OPLOCK_LEVEL_EXCLUSIVE) {\r\ncinode->oplock = CIFS_CACHE_RW_FLG;\r\ncifs_dbg(FYI, "Exclusive Oplock granted on inode %p\n",\r\n&cinode->vfs_inode);\r\n} else if (oplock == SMB2_OPLOCK_LEVEL_II) {\r\ncinode->oplock = CIFS_CACHE_READ_FLG;\r\ncifs_dbg(FYI, "Level II Oplock granted on inode %p\n",\r\n&cinode->vfs_inode);\r\n} else\r\ncinode->oplock = 0;\r\n}\r\nstatic void\r\nsmb21_set_oplock_level(struct cifsInodeInfo *cinode, __u32 oplock,\r\nunsigned int epoch, bool *purge_cache)\r\n{\r\nchar message[5] = {0};\r\noplock &= 0xFF;\r\nif (oplock == SMB2_OPLOCK_LEVEL_NOCHANGE)\r\nreturn;\r\ncinode->oplock = 0;\r\nif (oplock & SMB2_LEASE_READ_CACHING_HE) {\r\ncinode->oplock |= CIFS_CACHE_READ_FLG;\r\nstrcat(message, "R");\r\n}\r\nif (oplock & SMB2_LEASE_HANDLE_CACHING_HE) {\r\ncinode->oplock |= CIFS_CACHE_HANDLE_FLG;\r\nstrcat(message, "H");\r\n}\r\nif (oplock & SMB2_LEASE_WRITE_CACHING_HE) {\r\ncinode->oplock |= CIFS_CACHE_WRITE_FLG;\r\nstrcat(message, "W");\r\n}\r\nif (!cinode->oplock)\r\nstrcat(message, "None");\r\ncifs_dbg(FYI, "%s Lease granted on inode %p\n", message,\r\n&cinode->vfs_inode);\r\n}\r\nstatic void\r\nsmb3_set_oplock_level(struct cifsInodeInfo *cinode, __u32 oplock,\r\nunsigned int epoch, bool *purge_cache)\r\n{\r\nunsigned int old_oplock = cinode->oplock;\r\nsmb21_set_oplock_level(cinode, oplock, epoch, purge_cache);\r\nif (purge_cache) {\r\n*purge_cache = false;\r\nif (old_oplock == CIFS_CACHE_READ_FLG) {\r\nif (cinode->oplock == CIFS_CACHE_READ_FLG &&\r\n(epoch - cinode->epoch > 0))\r\n*purge_cache = true;\r\nelse if (cinode->oplock == CIFS_CACHE_RH_FLG &&\r\n(epoch - cinode->epoch > 1))\r\n*purge_cache = true;\r\nelse if (cinode->oplock == CIFS_CACHE_RHW_FLG &&\r\n(epoch - cinode->epoch > 1))\r\n*purge_cache = true;\r\nelse if (cinode->oplock == 0 &&\r\n(epoch - cinode->epoch > 0))\r\n*purge_cache = true;\r\n} else if (old_oplock == CIFS_CACHE_RH_FLG) {\r\nif (cinode->oplock == CIFS_CACHE_RH_FLG &&\r\n(epoch - cinode->epoch > 0))\r\n*purge_cache = true;\r\nelse if (cinode->oplock == CIFS_CACHE_RHW_FLG &&\r\n(epoch - cinode->epoch > 1))\r\n*purge_cache = true;\r\n}\r\ncinode->epoch = epoch;\r\n}\r\n}\r\nstatic bool\r\nsmb2_is_read_op(__u32 oplock)\r\n{\r\nreturn oplock == SMB2_OPLOCK_LEVEL_II;\r\n}\r\nstatic bool\r\nsmb21_is_read_op(__u32 oplock)\r\n{\r\nreturn (oplock & SMB2_LEASE_READ_CACHING_HE) &&\r\n!(oplock & SMB2_LEASE_WRITE_CACHING_HE);\r\n}\r\nstatic __le32\r\nmap_oplock_to_lease(u8 oplock)\r\n{\r\nif (oplock == SMB2_OPLOCK_LEVEL_EXCLUSIVE)\r\nreturn SMB2_LEASE_WRITE_CACHING | SMB2_LEASE_READ_CACHING;\r\nelse if (oplock == SMB2_OPLOCK_LEVEL_II)\r\nreturn SMB2_LEASE_READ_CACHING;\r\nelse if (oplock == SMB2_OPLOCK_LEVEL_BATCH)\r\nreturn SMB2_LEASE_HANDLE_CACHING | SMB2_LEASE_READ_CACHING |\r\nSMB2_LEASE_WRITE_CACHING;\r\nreturn 0;\r\n}\r\nstatic char *\r\nsmb2_create_lease_buf(u8 *lease_key, u8 oplock)\r\n{\r\nstruct create_lease *buf;\r\nbuf = kzalloc(sizeof(struct create_lease), GFP_KERNEL);\r\nif (!buf)\r\nreturn NULL;\r\nbuf->lcontext.LeaseKeyLow = cpu_to_le64(*((u64 *)lease_key));\r\nbuf->lcontext.LeaseKeyHigh = cpu_to_le64(*((u64 *)(lease_key + 8)));\r\nbuf->lcontext.LeaseState = map_oplock_to_lease(oplock);\r\nbuf->ccontext.DataOffset = cpu_to_le16(offsetof\r\n(struct create_lease, lcontext));\r\nbuf->ccontext.DataLength = cpu_to_le32(sizeof(struct lease_context));\r\nbuf->ccontext.NameOffset = cpu_to_le16(offsetof\r\n(struct create_lease, Name));\r\nbuf->ccontext.NameLength = cpu_to_le16(4);\r\nbuf->Name[0] = 'R';\r\nbuf->Name[1] = 'q';\r\nbuf->Name[2] = 'L';\r\nbuf->Name[3] = 's';\r\nreturn (char *)buf;\r\n}\r\nstatic char *\r\nsmb3_create_lease_buf(u8 *lease_key, u8 oplock)\r\n{\r\nstruct create_lease_v2 *buf;\r\nbuf = kzalloc(sizeof(struct create_lease_v2), GFP_KERNEL);\r\nif (!buf)\r\nreturn NULL;\r\nbuf->lcontext.LeaseKeyLow = cpu_to_le64(*((u64 *)lease_key));\r\nbuf->lcontext.LeaseKeyHigh = cpu_to_le64(*((u64 *)(lease_key + 8)));\r\nbuf->lcontext.LeaseState = map_oplock_to_lease(oplock);\r\nbuf->ccontext.DataOffset = cpu_to_le16(offsetof\r\n(struct create_lease_v2, lcontext));\r\nbuf->ccontext.DataLength = cpu_to_le32(sizeof(struct lease_context_v2));\r\nbuf->ccontext.NameOffset = cpu_to_le16(offsetof\r\n(struct create_lease_v2, Name));\r\nbuf->ccontext.NameLength = cpu_to_le16(4);\r\nbuf->Name[0] = 'R';\r\nbuf->Name[1] = 'q';\r\nbuf->Name[2] = 'L';\r\nbuf->Name[3] = 's';\r\nreturn (char *)buf;\r\n}\r\nstatic __u8\r\nsmb2_parse_lease_buf(void *buf, unsigned int *epoch)\r\n{\r\nstruct create_lease *lc = (struct create_lease *)buf;\r\n*epoch = 0;\r\nif (lc->lcontext.LeaseFlags & SMB2_LEASE_FLAG_BREAK_IN_PROGRESS)\r\nreturn SMB2_OPLOCK_LEVEL_NOCHANGE;\r\nreturn le32_to_cpu(lc->lcontext.LeaseState);\r\n}\r\nstatic __u8\r\nsmb3_parse_lease_buf(void *buf, unsigned int *epoch)\r\n{\r\nstruct create_lease_v2 *lc = (struct create_lease_v2 *)buf;\r\n*epoch = le16_to_cpu(lc->lcontext.Epoch);\r\nif (lc->lcontext.LeaseFlags & SMB2_LEASE_FLAG_BREAK_IN_PROGRESS)\r\nreturn SMB2_OPLOCK_LEVEL_NOCHANGE;\r\nreturn le32_to_cpu(lc->lcontext.LeaseState);\r\n}\r\nstatic unsigned int\r\nsmb2_wp_retry_size(struct inode *inode)\r\n{\r\nreturn min_t(unsigned int, CIFS_SB(inode->i_sb)->wsize,\r\nSMB2_MAX_BUFFER_SIZE);\r\n}\r\nstatic bool\r\nsmb2_dir_needs_close(struct cifsFileInfo *cfile)\r\n{\r\nreturn !cfile->invalidHandle;\r\n}
