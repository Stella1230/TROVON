static int xgene_ahci_init_memram(struct xgene_ahci_context *ctx)\r\n{\r\ndev_dbg(ctx->dev, "Release memory from shutdown\n");\r\nwritel(0x0, ctx->csr_diag + CFG_MEM_RAM_SHUTDOWN);\r\nreadl(ctx->csr_diag + CFG_MEM_RAM_SHUTDOWN);\r\nmsleep(1);\r\nif (readl(ctx->csr_diag + BLOCK_MEM_RDY) != 0xFFFFFFFF) {\r\ndev_err(ctx->dev, "failed to release memory from shutdown\n");\r\nreturn -ENODEV;\r\n}\r\nreturn 0;\r\n}\r\nstatic int xgene_ahci_poll_reg_val(struct ata_port *ap,\r\nvoid __iomem *reg, unsigned\r\nint val, unsigned long interval,\r\nunsigned long timeout)\r\n{\r\nunsigned long deadline;\r\nunsigned int tmp;\r\ntmp = ioread32(reg);\r\ndeadline = ata_deadline(jiffies, timeout);\r\nwhile (tmp != val && time_before(jiffies, deadline)) {\r\nata_msleep(ap, interval);\r\ntmp = ioread32(reg);\r\n}\r\nreturn tmp;\r\n}\r\nstatic int xgene_ahci_restart_engine(struct ata_port *ap)\r\n{\r\nstruct ahci_host_priv *hpriv = ap->host->private_data;\r\nstruct ahci_port_priv *pp = ap->private_data;\r\nvoid __iomem *port_mmio = ahci_port_base(ap);\r\nu32 fbs;\r\nif (xgene_ahci_poll_reg_val(ap, port_mmio +\r\nPORT_CMD_ISSUE, 0x0, 1, 100))\r\nreturn -EBUSY;\r\nahci_stop_engine(ap);\r\nahci_start_fis_rx(ap);\r\nif (pp->fbs_supported) {\r\nfbs = readl(port_mmio + PORT_FBS);\r\nwritel(fbs | PORT_FBS_EN, port_mmio + PORT_FBS);\r\nfbs = readl(port_mmio + PORT_FBS);\r\n}\r\nhpriv->start_engine(ap);\r\nreturn 0;\r\n}\r\nstatic unsigned int xgene_ahci_qc_issue(struct ata_queued_cmd *qc)\r\n{\r\nstruct ata_port *ap = qc->ap;\r\nstruct ahci_host_priv *hpriv = ap->host->private_data;\r\nstruct xgene_ahci_context *ctx = hpriv->plat_data;\r\nint rc = 0;\r\nu32 port_fbs;\r\nvoid *port_mmio = ahci_port_base(ap);\r\nif (ctx->class[ap->port_no] == ATA_DEV_PMP) {\r\nport_fbs = readl(port_mmio + PORT_FBS);\r\nport_fbs &= ~PORT_FBS_DEV_MASK;\r\nport_fbs |= qc->dev->link->pmp << PORT_FBS_DEV_OFFSET;\r\nwritel(port_fbs, port_mmio + PORT_FBS);\r\n}\r\nif (unlikely((ctx->last_cmd[ap->port_no] == ATA_CMD_ID_ATA) ||\r\n(ctx->last_cmd[ap->port_no] == ATA_CMD_PACKET) ||\r\n(ctx->last_cmd[ap->port_no] == ATA_CMD_SMART)))\r\nxgene_ahci_restart_engine(ap);\r\nrc = ahci_qc_issue(qc);\r\nctx->last_cmd[ap->port_no] = qc->tf.command;\r\nreturn rc;\r\n}\r\nstatic bool xgene_ahci_is_memram_inited(struct xgene_ahci_context *ctx)\r\n{\r\nvoid __iomem *diagcsr = ctx->csr_diag;\r\nreturn (readl(diagcsr + CFG_MEM_RAM_SHUTDOWN) == 0 &&\r\nreadl(diagcsr + BLOCK_MEM_RDY) == 0xFFFFFFFF);\r\n}\r\nstatic unsigned int xgene_ahci_read_id(struct ata_device *dev,\r\nstruct ata_taskfile *tf, u16 *id)\r\n{\r\nu32 err_mask;\r\nerr_mask = ata_do_dev_read_id(dev, tf, id);\r\nif (err_mask)\r\nreturn err_mask;\r\nid[ATA_ID_FEATURE_SUPP] &= cpu_to_le16(~(1 << 8));\r\nreturn 0;\r\n}\r\nstatic void xgene_ahci_set_phy_cfg(struct xgene_ahci_context *ctx, int channel)\r\n{\r\nvoid __iomem *mmio = ctx->hpriv->mmio;\r\nu32 val;\r\ndev_dbg(ctx->dev, "port configure mmio 0x%p channel %d\n",\r\nmmio, channel);\r\nval = readl(mmio + PORTCFG);\r\nval = PORTADDR_SET(val, channel == 0 ? 2 : 3);\r\nwritel(val, mmio + PORTCFG);\r\nreadl(mmio + PORTCFG);\r\nwritel(0x0001fffe, mmio + PORTPHY1CFG);\r\nreadl(mmio + PORTPHY1CFG);\r\nwritel(0x28183219, mmio + PORTPHY2CFG);\r\nreadl(mmio + PORTPHY2CFG);\r\nwritel(0x13081008, mmio + PORTPHY3CFG);\r\nreadl(mmio + PORTPHY3CFG);\r\nwritel(0x00480815, mmio + PORTPHY4CFG);\r\nreadl(mmio + PORTPHY4CFG);\r\nval = readl(mmio + PORTPHY5CFG);\r\nval = PORTPHY5CFG_RTCHG_SET(val, 0x300);\r\nwritel(val, mmio + PORTPHY5CFG);\r\nreadl(mmio + PORTPHY5CFG);\r\nval = readl(mmio + PORTAXICFG);\r\nval = PORTAXICFG_EN_CONTEXT_SET(val, 0x1);\r\nval = PORTAXICFG_OUTTRANS_SET(val, 0xe);\r\nwritel(val, mmio + PORTAXICFG);\r\nreadl(mmio + PORTAXICFG);\r\nval = readl(mmio + PORTRANSCFG);\r\nval = PORTRANSCFG_RXWM_SET(val, 0x30);\r\nwritel(val, mmio + PORTRANSCFG);\r\n}\r\nstatic int xgene_ahci_do_hardreset(struct ata_link *link,\r\nunsigned long deadline, bool *online)\r\n{\r\nconst unsigned long *timing = sata_ehc_deb_timing(&link->eh_context);\r\nstruct ata_port *ap = link->ap;\r\nstruct ahci_host_priv *hpriv = ap->host->private_data;\r\nstruct xgene_ahci_context *ctx = hpriv->plat_data;\r\nstruct ahci_port_priv *pp = ap->private_data;\r\nu8 *d2h_fis = pp->rx_fis + RX_FIS_D2H_REG;\r\nvoid __iomem *port_mmio = ahci_port_base(ap);\r\nstruct ata_taskfile tf;\r\nint link_down_retry = 0;\r\nint rc;\r\nu32 val, sstatus;\r\ndo {\r\nata_tf_init(link->device, &tf);\r\ntf.command = ATA_BUSY;\r\nata_tf_to_fis(&tf, 0, 0, d2h_fis);\r\nrc = sata_link_hardreset(link, timing, deadline, online,\r\nahci_check_ready);\r\nif (*online) {\r\nval = readl(port_mmio + PORT_SCR_ERR);\r\nif (val & (SERR_DISPARITY | SERR_10B_8B_ERR))\r\ndev_warn(ctx->dev, "link has error\n");\r\nbreak;\r\n}\r\nsata_scr_read(link, SCR_STATUS, &sstatus);\r\n} while (link_down_retry++ < MAX_LINK_DOWN_RETRY &&\r\n(sstatus & 0xff) == 0x1);\r\nval = readl(port_mmio + PORT_SCR_ERR);\r\nwritel(val, port_mmio + PORT_SCR_ERR);\r\nreturn rc;\r\n}\r\nstatic int xgene_ahci_hardreset(struct ata_link *link, unsigned int *class,\r\nunsigned long deadline)\r\n{\r\nstruct ata_port *ap = link->ap;\r\nstruct ahci_host_priv *hpriv = ap->host->private_data;\r\nvoid __iomem *port_mmio = ahci_port_base(ap);\r\nbool online;\r\nint rc;\r\nu32 portcmd_saved;\r\nu32 portclb_saved;\r\nu32 portclbhi_saved;\r\nu32 portrxfis_saved;\r\nu32 portrxfishi_saved;\r\nportcmd_saved = readl(port_mmio + PORT_CMD);\r\nportclb_saved = readl(port_mmio + PORT_LST_ADDR);\r\nportclbhi_saved = readl(port_mmio + PORT_LST_ADDR_HI);\r\nportrxfis_saved = readl(port_mmio + PORT_FIS_ADDR);\r\nportrxfishi_saved = readl(port_mmio + PORT_FIS_ADDR_HI);\r\nahci_stop_engine(ap);\r\nrc = xgene_ahci_do_hardreset(link, deadline, &online);\r\nwritel(portcmd_saved, port_mmio + PORT_CMD);\r\nwritel(portclb_saved, port_mmio + PORT_LST_ADDR);\r\nwritel(portclbhi_saved, port_mmio + PORT_LST_ADDR_HI);\r\nwritel(portrxfis_saved, port_mmio + PORT_FIS_ADDR);\r\nwritel(portrxfishi_saved, port_mmio + PORT_FIS_ADDR_HI);\r\nhpriv->start_engine(ap);\r\nif (online)\r\n*class = ahci_dev_classify(ap);\r\nreturn rc;\r\n}\r\nstatic void xgene_ahci_host_stop(struct ata_host *host)\r\n{\r\nstruct ahci_host_priv *hpriv = host->private_data;\r\nahci_platform_disable_resources(hpriv);\r\n}\r\nstatic int xgene_ahci_pmp_softreset(struct ata_link *link, unsigned int *class,\r\nunsigned long deadline)\r\n{\r\nint pmp = sata_srst_pmp(link);\r\nstruct ata_port *ap = link->ap;\r\nu32 rc;\r\nvoid *port_mmio = ahci_port_base(ap);\r\nu32 port_fbs;\r\nport_fbs = readl(port_mmio + PORT_FBS);\r\nport_fbs &= ~PORT_FBS_DEV_MASK;\r\nport_fbs |= pmp << PORT_FBS_DEV_OFFSET;\r\nwritel(port_fbs, port_mmio + PORT_FBS);\r\nrc = ahci_do_softreset(link, class, pmp, deadline, ahci_check_ready);\r\nreturn rc;\r\n}\r\nstatic int xgene_ahci_softreset(struct ata_link *link, unsigned int *class,\r\nunsigned long deadline)\r\n{\r\nint pmp = sata_srst_pmp(link);\r\nstruct ata_port *ap = link->ap;\r\nstruct ahci_host_priv *hpriv = ap->host->private_data;\r\nstruct xgene_ahci_context *ctx = hpriv->plat_data;\r\nvoid *port_mmio = ahci_port_base(ap);\r\nu32 port_fbs;\r\nu32 port_fbs_save;\r\nu32 retry = 1;\r\nu32 rc;\r\nport_fbs_save = readl(port_mmio + PORT_FBS);\r\nport_fbs = readl(port_mmio + PORT_FBS);\r\nport_fbs &= ~PORT_FBS_DEV_MASK;\r\nport_fbs |= pmp << PORT_FBS_DEV_OFFSET;\r\nwritel(port_fbs, port_mmio + PORT_FBS);\r\nsoftreset_retry:\r\nrc = ahci_do_softreset(link, class, pmp,\r\ndeadline, ahci_check_ready);\r\nctx->class[ap->port_no] = *class;\r\nif (*class != ATA_DEV_PMP) {\r\nif (retry--) {\r\nwritel(port_fbs_save, port_mmio + PORT_FBS);\r\ngoto softreset_retry;\r\n}\r\n}\r\nreturn rc;\r\n}\r\nstatic int xgene_ahci_handle_broken_edge_irq(struct ata_host *host,\r\nu32 irq_masked)\r\n{\r\nstruct ahci_host_priv *hpriv = host->private_data;\r\nvoid __iomem *port_mmio;\r\nint i;\r\nif (!readl(hpriv->mmio + HOST_IRQ_STAT)) {\r\nfor (i = 0; i < host->n_ports; i++) {\r\nif (irq_masked & (1 << i))\r\ncontinue;\r\nport_mmio = ahci_port_base(host->ports[i]);\r\nif (readl(port_mmio + PORT_IRQ_STAT))\r\nirq_masked |= (1 << i);\r\n}\r\n}\r\nreturn ahci_handle_port_intr(host, irq_masked);\r\n}\r\nstatic irqreturn_t xgene_ahci_irq_intr(int irq, void *dev_instance)\r\n{\r\nstruct ata_host *host = dev_instance;\r\nstruct ahci_host_priv *hpriv;\r\nunsigned int rc = 0;\r\nvoid __iomem *mmio;\r\nu32 irq_stat, irq_masked;\r\nVPRINTK("ENTER\n");\r\nhpriv = host->private_data;\r\nmmio = hpriv->mmio;\r\nirq_stat = readl(mmio + HOST_IRQ_STAT);\r\nif (!irq_stat)\r\nreturn IRQ_NONE;\r\nirq_masked = irq_stat & hpriv->port_map;\r\nspin_lock(&host->lock);\r\nwritel(irq_stat, mmio + HOST_IRQ_STAT);\r\nrc = xgene_ahci_handle_broken_edge_irq(host, irq_masked);\r\nspin_unlock(&host->lock);\r\nVPRINTK("EXIT\n");\r\nreturn IRQ_RETVAL(rc);\r\n}\r\nstatic int xgene_ahci_hw_init(struct ahci_host_priv *hpriv)\r\n{\r\nstruct xgene_ahci_context *ctx = hpriv->plat_data;\r\nint i;\r\nint rc;\r\nu32 val;\r\nrc = xgene_ahci_init_memram(ctx);\r\nif (rc)\r\nreturn rc;\r\nfor (i = 0; i < MAX_AHCI_CHN_PERCTR; i++)\r\nxgene_ahci_set_phy_cfg(ctx, i);\r\nwritel(0xffffffff, hpriv->mmio + HOST_IRQ_STAT);\r\nreadl(hpriv->mmio + HOST_IRQ_STAT);\r\nwritel(0, ctx->csr_core + INTSTATUSMASK);\r\nval = readl(ctx->csr_core + INTSTATUSMASK);\r\ndev_dbg(ctx->dev, "top level interrupt mask 0x%X value 0x%08X\n",\r\nINTSTATUSMASK, val);\r\nwritel(0x0, ctx->csr_core + ERRINTSTATUSMASK);\r\nreadl(ctx->csr_core + ERRINTSTATUSMASK);\r\nwritel(0x0, ctx->csr_axi + INT_SLV_TMOMASK);\r\nreadl(ctx->csr_axi + INT_SLV_TMOMASK);\r\nwritel(0xffffffff, ctx->csr_core + SLVRDERRATTRIBUTES);\r\nwritel(0xffffffff, ctx->csr_core + SLVWRERRATTRIBUTES);\r\nwritel(0xffffffff, ctx->csr_core + MSTRDERRATTRIBUTES);\r\nwritel(0xffffffff, ctx->csr_core + MSTWRERRATTRIBUTES);\r\nval = readl(ctx->csr_core + BUSCTLREG);\r\nval &= ~0x00000002;\r\nval &= ~0x00000001;\r\nwritel(val, ctx->csr_core + BUSCTLREG);\r\nval = readl(ctx->csr_core + IOFMSTRWAUX);\r\nval |= (1 << 3);\r\nval |= (1 << 9);\r\nwritel(val, ctx->csr_core + IOFMSTRWAUX);\r\nval = readl(ctx->csr_core + IOFMSTRWAUX);\r\ndev_dbg(ctx->dev, "coherency 0x%X value 0x%08X\n",\r\nIOFMSTRWAUX, val);\r\nreturn rc;\r\n}\r\nstatic int xgene_ahci_mux_select(struct xgene_ahci_context *ctx)\r\n{\r\nu32 val;\r\nif (!ctx->csr_mux)\r\nreturn 0;\r\nval = readl(ctx->csr_mux + SATA_ENET_CONFIG_REG);\r\nval &= ~CFG_SATA_ENET_SELECT_MASK;\r\nwritel(val, ctx->csr_mux + SATA_ENET_CONFIG_REG);\r\nval = readl(ctx->csr_mux + SATA_ENET_CONFIG_REG);\r\nreturn val & CFG_SATA_ENET_SELECT_MASK ? -1 : 0;\r\n}\r\nstatic int xgene_ahci_probe(struct platform_device *pdev)\r\n{\r\nstruct device *dev = &pdev->dev;\r\nstruct ahci_host_priv *hpriv;\r\nstruct xgene_ahci_context *ctx;\r\nstruct resource *res;\r\nconst struct of_device_id *of_devid;\r\nenum xgene_ahci_version version = XGENE_AHCI_V1;\r\nconst struct ata_port_info *ppi[] = { &xgene_ahci_v1_port_info,\r\n&xgene_ahci_v2_port_info };\r\nint rc;\r\nhpriv = ahci_platform_get_resources(pdev);\r\nif (IS_ERR(hpriv))\r\nreturn PTR_ERR(hpriv);\r\nctx = devm_kzalloc(dev, sizeof(*ctx), GFP_KERNEL);\r\nif (!ctx)\r\nreturn -ENOMEM;\r\nhpriv->plat_data = ctx;\r\nctx->hpriv = hpriv;\r\nctx->dev = dev;\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 1);\r\nctx->csr_core = devm_ioremap_resource(dev, res);\r\nif (IS_ERR(ctx->csr_core))\r\nreturn PTR_ERR(ctx->csr_core);\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 2);\r\nctx->csr_diag = devm_ioremap_resource(dev, res);\r\nif (IS_ERR(ctx->csr_diag))\r\nreturn PTR_ERR(ctx->csr_diag);\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 3);\r\nctx->csr_axi = devm_ioremap_resource(dev, res);\r\nif (IS_ERR(ctx->csr_axi))\r\nreturn PTR_ERR(ctx->csr_axi);\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 4);\r\nif (res) {\r\nvoid __iomem *csr = devm_ioremap_resource(dev, res);\r\nif (IS_ERR(csr))\r\nreturn PTR_ERR(csr);\r\nctx->csr_mux = csr;\r\n}\r\nof_devid = of_match_device(xgene_ahci_of_match, dev);\r\nif (of_devid) {\r\nif (of_devid->data)\r\nversion = (enum xgene_ahci_version) of_devid->data;\r\n}\r\n#ifdef CONFIG_ACPI\r\nelse {\r\nconst struct acpi_device_id *acpi_id;\r\nstruct acpi_device_info *info;\r\nacpi_status status;\r\nacpi_id = acpi_match_device(xgene_ahci_acpi_match, &pdev->dev);\r\nif (!acpi_id) {\r\ndev_warn(&pdev->dev, "No node entry in ACPI table. Assume version1\n");\r\nversion = XGENE_AHCI_V1;\r\n} else if (acpi_id->driver_data) {\r\nversion = (enum xgene_ahci_version) acpi_id->driver_data;\r\nstatus = acpi_get_object_info(ACPI_HANDLE(&pdev->dev), &info);\r\nif (ACPI_FAILURE(status)) {\r\ndev_warn(&pdev->dev, "%s: Error reading device info. Assume version1\n",\r\n__func__);\r\nversion = XGENE_AHCI_V1;\r\n} else if (info->valid & ACPI_VALID_CID) {\r\nversion = XGENE_AHCI_V2;\r\n}\r\n}\r\n}\r\n#endif\r\ndev_dbg(dev, "VAddr 0x%p Mmio VAddr 0x%p\n", ctx->csr_core,\r\nhpriv->mmio);\r\nif ((rc = xgene_ahci_mux_select(ctx))) {\r\ndev_err(dev, "SATA mux selection failed error %d\n", rc);\r\nreturn -ENODEV;\r\n}\r\nif (xgene_ahci_is_memram_inited(ctx)) {\r\ndev_info(dev, "skip clock and PHY initialization\n");\r\ngoto skip_clk_phy;\r\n}\r\nrc = ahci_platform_enable_clks(hpriv);\r\nif (rc)\r\ngoto disable_resources;\r\nahci_platform_disable_clks(hpriv);\r\nrc = ahci_platform_enable_resources(hpriv);\r\nif (rc)\r\ngoto disable_resources;\r\nxgene_ahci_hw_init(hpriv);\r\nskip_clk_phy:\r\nswitch (version) {\r\ncase XGENE_AHCI_V1:\r\nhpriv->flags = AHCI_HFLAG_NO_NCQ;\r\nbreak;\r\ncase XGENE_AHCI_V2:\r\nhpriv->flags |= AHCI_HFLAG_YES_FBS;\r\nhpriv->irq_handler = xgene_ahci_irq_intr;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nrc = ahci_platform_init_host(pdev, hpriv, ppi[version - 1],\r\n&ahci_platform_sht);\r\nif (rc)\r\ngoto disable_resources;\r\ndev_dbg(dev, "X-Gene SATA host controller initialized\n");\r\nreturn 0;\r\ndisable_resources:\r\nahci_platform_disable_resources(hpriv);\r\nreturn rc;\r\n}
