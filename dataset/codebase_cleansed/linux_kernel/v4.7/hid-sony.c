static u8 *sixaxis_fixup(struct hid_device *hdev, u8 *rdesc,\r\nunsigned int *rsize)\r\n{\r\n*rsize = sizeof(sixaxis_rdesc);\r\nreturn sixaxis_rdesc;\r\n}\r\nstatic u8 *motion_fixup(struct hid_device *hdev, u8 *rdesc,\r\nunsigned int *rsize)\r\n{\r\n*rsize = sizeof(motion_rdesc);\r\nreturn motion_rdesc;\r\n}\r\nstatic u8 *navigation_fixup(struct hid_device *hdev, u8 *rdesc,\r\nunsigned int *rsize)\r\n{\r\n*rsize = sizeof(navigation_rdesc);\r\nreturn navigation_rdesc;\r\n}\r\nstatic u8 *ps3remote_fixup(struct hid_device *hdev, u8 *rdesc,\r\nunsigned int *rsize)\r\n{\r\n*rsize = sizeof(ps3remote_rdesc);\r\nreturn ps3remote_rdesc;\r\n}\r\nstatic int ps3remote_mapping(struct hid_device *hdev, struct hid_input *hi,\r\nstruct hid_field *field, struct hid_usage *usage,\r\nunsigned long **bit, int *max)\r\n{\r\nunsigned int key = usage->hid & HID_USAGE;\r\nif ((usage->hid & HID_USAGE_PAGE) != HID_UP_BUTTON)\r\nreturn -1;\r\nswitch (usage->collection_index) {\r\ncase 1:\r\nif (key >= ARRAY_SIZE(ps3remote_keymap_joypad_buttons))\r\nreturn -1;\r\nkey = ps3remote_keymap_joypad_buttons[key];\r\nif (!key)\r\nreturn -1;\r\nbreak;\r\ncase 2:\r\nif (key >= ARRAY_SIZE(ps3remote_keymap_remote_buttons))\r\nreturn -1;\r\nkey = ps3remote_keymap_remote_buttons[key];\r\nif (!key)\r\nreturn -1;\r\nbreak;\r\ndefault:\r\nreturn -1;\r\n}\r\nhid_map_usage_clear(hi, usage, bit, max, EV_KEY, key);\r\nreturn 1;\r\n}\r\nstatic u8 *sony_report_fixup(struct hid_device *hdev, u8 *rdesc,\r\nunsigned int *rsize)\r\n{\r\nstruct sony_sc *sc = hid_get_drvdata(hdev);\r\nif (sc->quirks & SINO_LITE_CONTROLLER)\r\nreturn rdesc;\r\nif ((sc->quirks & VAIO_RDESC_CONSTANT) && *rsize >= 56 &&\r\nrdesc[2] == 0x09 && rdesc[3] == 0x02 &&\r\nrdesc[54] == 0x81 && rdesc[55] == 0x07) {\r\nhid_info(hdev, "Fixing up Sony RF Receiver report descriptor\n");\r\nrdesc[55] = 0x06;\r\n}\r\nif (sc->quirks & DUALSHOCK4_CONTROLLER_USB) {\r\nhid_info(hdev, "Using modified Dualshock 4 report descriptor with gyroscope axes\n");\r\nrdesc = dualshock4_usb_rdesc;\r\n*rsize = sizeof(dualshock4_usb_rdesc);\r\n} else if (sc->quirks & DUALSHOCK4_CONTROLLER_BT) {\r\nhid_info(hdev, "Using modified Dualshock 4 Bluetooth report descriptor\n");\r\nrdesc = dualshock4_bt_rdesc;\r\n*rsize = sizeof(dualshock4_bt_rdesc);\r\n}\r\nif (sc->quirks & SIXAXIS_CONTROLLER)\r\nreturn sixaxis_fixup(hdev, rdesc, rsize);\r\nif (sc->quirks & MOTION_CONTROLLER)\r\nreturn motion_fixup(hdev, rdesc, rsize);\r\nif (sc->quirks & NAVIGATION_CONTROLLER)\r\nreturn navigation_fixup(hdev, rdesc, rsize);\r\nif (sc->quirks & PS3REMOTE)\r\nreturn ps3remote_fixup(hdev, rdesc, rsize);\r\nreturn rdesc;\r\n}\r\nstatic void sixaxis_parse_report(struct sony_sc *sc, u8 *rd, int size)\r\n{\r\nstatic const u8 sixaxis_battery_capacity[] = { 0, 1, 25, 50, 75, 100 };\r\nunsigned long flags;\r\nint offset;\r\nu8 cable_state, battery_capacity, battery_charging;\r\noffset = (sc->quirks & MOTION_CONTROLLER) ? 12 : 30;\r\nif (rd[offset] >= 0xee) {\r\nbattery_capacity = 100;\r\nbattery_charging = !(rd[offset] & 0x01);\r\ncable_state = 1;\r\n} else {\r\nu8 index = rd[offset] <= 5 ? rd[offset] : 5;\r\nbattery_capacity = sixaxis_battery_capacity[index];\r\nbattery_charging = 0;\r\ncable_state = 0;\r\n}\r\nspin_lock_irqsave(&sc->lock, flags);\r\nsc->cable_state = cable_state;\r\nsc->battery_capacity = battery_capacity;\r\nsc->battery_charging = battery_charging;\r\nspin_unlock_irqrestore(&sc->lock, flags);\r\n}\r\nstatic void dualshock4_parse_report(struct sony_sc *sc, u8 *rd, int size)\r\n{\r\nstruct hid_input *hidinput = list_entry(sc->hdev->inputs.next,\r\nstruct hid_input, list);\r\nstruct input_dev *input_dev = hidinput->input;\r\nunsigned long flags;\r\nint n, offset;\r\nu8 cable_state, battery_capacity, battery_charging;\r\noffset = (sc->quirks & DUALSHOCK4_CONTROLLER_USB) ? 30 : 32;\r\ncable_state = (rd[offset] >> 4) & 0x01;\r\nbattery_capacity = rd[offset] & 0x0F;\r\nif (!cable_state || battery_capacity > 10)\r\nbattery_charging = 0;\r\nelse\r\nbattery_charging = 1;\r\nif (!cable_state)\r\nbattery_capacity++;\r\nif (battery_capacity > 10)\r\nbattery_capacity = 10;\r\nbattery_capacity *= 10;\r\nspin_lock_irqsave(&sc->lock, flags);\r\nsc->cable_state = cable_state;\r\nsc->battery_capacity = battery_capacity;\r\nsc->battery_charging = battery_charging;\r\nspin_unlock_irqrestore(&sc->lock, flags);\r\noffset += 5;\r\nfor (n = 0; n < 2; n++) {\r\nu16 x, y;\r\nx = rd[offset+1] | ((rd[offset+2] & 0xF) << 8);\r\ny = ((rd[offset+2] & 0xF0) >> 4) | (rd[offset+3] << 4);\r\ninput_mt_slot(input_dev, n);\r\ninput_mt_report_slot_state(input_dev, MT_TOOL_FINGER,\r\n!(rd[offset] >> 7));\r\ninput_report_abs(input_dev, ABS_MT_POSITION_X, x);\r\ninput_report_abs(input_dev, ABS_MT_POSITION_Y, y);\r\noffset += 4;\r\n}\r\n}\r\nstatic int sony_raw_event(struct hid_device *hdev, struct hid_report *report,\r\nu8 *rd, int size)\r\n{\r\nstruct sony_sc *sc = hid_get_drvdata(hdev);\r\nif ((sc->quirks & SIXAXIS_CONTROLLER) && rd[0] == 0x01 && size == 49) {\r\nif (rd[1] == 0xff)\r\nreturn -EINVAL;\r\nswap(rd[41], rd[42]);\r\nswap(rd[43], rd[44]);\r\nswap(rd[45], rd[46]);\r\nswap(rd[47], rd[48]);\r\nsixaxis_parse_report(sc, rd, size);\r\n} else if ((sc->quirks & MOTION_CONTROLLER_BT) && rd[0] == 0x01 && size == 49) {\r\nsixaxis_parse_report(sc, rd, size);\r\n} else if ((sc->quirks & NAVIGATION_CONTROLLER) && rd[0] == 0x01 &&\r\nsize == 49) {\r\nsixaxis_parse_report(sc, rd, size);\r\n} else if (((sc->quirks & DUALSHOCK4_CONTROLLER_USB) && rd[0] == 0x01 &&\r\nsize == 64) || ((sc->quirks & DUALSHOCK4_CONTROLLER_BT)\r\n&& rd[0] == 0x11 && size == 78)) {\r\ndualshock4_parse_report(sc, rd, size);\r\n}\r\nreturn 0;\r\n}\r\nstatic int sony_mapping(struct hid_device *hdev, struct hid_input *hi,\r\nstruct hid_field *field, struct hid_usage *usage,\r\nunsigned long **bit, int *max)\r\n{\r\nstruct sony_sc *sc = hid_get_drvdata(hdev);\r\nif (sc->quirks & BUZZ_CONTROLLER) {\r\nunsigned int key = usage->hid & HID_USAGE;\r\nif ((usage->hid & HID_USAGE_PAGE) != HID_UP_BUTTON)\r\nreturn -1;\r\nswitch (usage->collection_index) {\r\ncase 1:\r\nif (key >= ARRAY_SIZE(buzz_keymap))\r\nreturn -1;\r\nkey = buzz_keymap[key];\r\nif (!key)\r\nreturn -1;\r\nbreak;\r\ndefault:\r\nreturn -1;\r\n}\r\nhid_map_usage_clear(hi, usage, bit, max, EV_KEY, key);\r\nreturn 1;\r\n}\r\nif (sc->quirks & PS3REMOTE)\r\nreturn ps3remote_mapping(hdev, hi, field, usage, bit, max);\r\nreturn 0;\r\n}\r\nstatic int sony_register_touchpad(struct hid_input *hi, int touch_count,\r\nint w, int h)\r\n{\r\nstruct input_dev *input_dev = hi->input;\r\nint ret;\r\nret = input_mt_init_slots(input_dev, touch_count, 0);\r\nif (ret < 0)\r\nreturn ret;\r\ninput_set_abs_params(input_dev, ABS_MT_POSITION_X, 0, w, 0, 0);\r\ninput_set_abs_params(input_dev, ABS_MT_POSITION_Y, 0, h, 0, 0);\r\nreturn 0;\r\n}\r\nstatic int sony_input_configured(struct hid_device *hdev,\r\nstruct hid_input *hidinput)\r\n{\r\nstruct sony_sc *sc = hid_get_drvdata(hdev);\r\nint ret;\r\nif (sc->quirks & DUALSHOCK4_CONTROLLER) {\r\nret = sony_register_touchpad(hidinput, 2, 1920, 942);\r\nif (ret) {\r\nhid_err(sc->hdev,\r\n"Unable to initialize multi-touch slots: %d\n",\r\nret);\r\nreturn ret;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int sixaxis_set_operational_usb(struct hid_device *hdev)\r\n{\r\nconst int buf_size =\r\nmax(SIXAXIS_REPORT_0xF2_SIZE, SIXAXIS_REPORT_0xF5_SIZE);\r\nu8 *buf;\r\nint ret;\r\nbuf = kmalloc(buf_size, GFP_KERNEL);\r\nif (!buf)\r\nreturn -ENOMEM;\r\nret = hid_hw_raw_request(hdev, 0xf2, buf, SIXAXIS_REPORT_0xF2_SIZE,\r\nHID_FEATURE_REPORT, HID_REQ_GET_REPORT);\r\nif (ret < 0) {\r\nhid_err(hdev, "can't set operational mode: step 1\n");\r\ngoto out;\r\n}\r\nret = hid_hw_raw_request(hdev, 0xf5, buf, SIXAXIS_REPORT_0xF5_SIZE,\r\nHID_FEATURE_REPORT, HID_REQ_GET_REPORT);\r\nif (ret < 0) {\r\nhid_err(hdev, "can't set operational mode: step 2\n");\r\ngoto out;\r\n}\r\nret = hid_hw_output_report(hdev, buf, 1);\r\nif (ret < 0) {\r\nhid_info(hdev, "can't set operational mode: step 3, ignoring\n");\r\nret = 0;\r\n}\r\nout:\r\nkfree(buf);\r\nreturn ret;\r\n}\r\nstatic int sixaxis_set_operational_bt(struct hid_device *hdev)\r\n{\r\nstatic const u8 report[] = { 0xf4, 0x42, 0x03, 0x00, 0x00 };\r\nu8 *buf;\r\nint ret;\r\nbuf = kmemdup(report, sizeof(report), GFP_KERNEL);\r\nif (!buf)\r\nreturn -ENOMEM;\r\nret = hid_hw_raw_request(hdev, buf[0], buf, sizeof(report),\r\nHID_FEATURE_REPORT, HID_REQ_SET_REPORT);\r\nkfree(buf);\r\nreturn ret;\r\n}\r\nstatic int dualshock4_set_operational_bt(struct hid_device *hdev)\r\n{\r\nu8 *buf;\r\nint ret;\r\nbuf = kmalloc(DS4_REPORT_0x02_SIZE, GFP_KERNEL);\r\nif (!buf)\r\nreturn -ENOMEM;\r\nret = hid_hw_raw_request(hdev, 0x02, buf, DS4_REPORT_0x02_SIZE,\r\nHID_FEATURE_REPORT, HID_REQ_GET_REPORT);\r\nkfree(buf);\r\nreturn ret;\r\n}\r\nstatic void sixaxis_set_leds_from_id(struct sony_sc *sc)\r\n{\r\nstatic const u8 sixaxis_leds[10][4] = {\r\n{ 0x01, 0x00, 0x00, 0x00 },\r\n{ 0x00, 0x01, 0x00, 0x00 },\r\n{ 0x00, 0x00, 0x01, 0x00 },\r\n{ 0x00, 0x00, 0x00, 0x01 },\r\n{ 0x01, 0x00, 0x00, 0x01 },\r\n{ 0x00, 0x01, 0x00, 0x01 },\r\n{ 0x00, 0x00, 0x01, 0x01 },\r\n{ 0x01, 0x00, 0x01, 0x01 },\r\n{ 0x00, 0x01, 0x01, 0x01 },\r\n{ 0x01, 0x01, 0x01, 0x01 }\r\n};\r\nint id = sc->device_id;\r\nBUILD_BUG_ON(MAX_LEDS < ARRAY_SIZE(sixaxis_leds[0]));\r\nif (id < 0)\r\nreturn;\r\nid %= 10;\r\nmemcpy(sc->led_state, sixaxis_leds[id], sizeof(sixaxis_leds[id]));\r\n}\r\nstatic void dualshock4_set_leds_from_id(struct sony_sc *sc)\r\n{\r\nstatic const u8 color_code[7][3] = {\r\n{ 0x00, 0x00, 0x01 },\r\n{ 0x01, 0x00, 0x00 },\r\n{ 0x00, 0x01, 0x00 },\r\n{ 0x02, 0x00, 0x01 },\r\n{ 0x02, 0x01, 0x00 },\r\n{ 0x00, 0x01, 0x01 },\r\n{ 0x01, 0x01, 0x01 }\r\n};\r\nint id = sc->device_id;\r\nBUILD_BUG_ON(MAX_LEDS < ARRAY_SIZE(color_code[0]));\r\nif (id < 0)\r\nreturn;\r\nid %= 7;\r\nmemcpy(sc->led_state, color_code[id], sizeof(color_code[id]));\r\n}\r\nstatic void buzz_set_leds(struct sony_sc *sc)\r\n{\r\nstruct hid_device *hdev = sc->hdev;\r\nstruct list_head *report_list =\r\n&hdev->report_enum[HID_OUTPUT_REPORT].report_list;\r\nstruct hid_report *report = list_entry(report_list->next,\r\nstruct hid_report, list);\r\ns32 *value = report->field[0]->value;\r\nBUILD_BUG_ON(MAX_LEDS < 4);\r\nvalue[0] = 0x00;\r\nvalue[1] = sc->led_state[0] ? 0xff : 0x00;\r\nvalue[2] = sc->led_state[1] ? 0xff : 0x00;\r\nvalue[3] = sc->led_state[2] ? 0xff : 0x00;\r\nvalue[4] = sc->led_state[3] ? 0xff : 0x00;\r\nvalue[5] = 0x00;\r\nvalue[6] = 0x00;\r\nhid_hw_request(hdev, report, HID_REQ_SET_REPORT);\r\n}\r\nstatic void sony_set_leds(struct sony_sc *sc)\r\n{\r\nif (!(sc->quirks & BUZZ_CONTROLLER))\r\nschedule_work(&sc->state_worker);\r\nelse\r\nbuzz_set_leds(sc);\r\n}\r\nstatic void sony_led_set_brightness(struct led_classdev *led,\r\nenum led_brightness value)\r\n{\r\nstruct device *dev = led->dev->parent;\r\nstruct hid_device *hdev = to_hid_device(dev);\r\nstruct sony_sc *drv_data;\r\nint n;\r\nint force_update;\r\ndrv_data = hid_get_drvdata(hdev);\r\nif (!drv_data) {\r\nhid_err(hdev, "No device data\n");\r\nreturn;\r\n}\r\nforce_update = !!(drv_data->quirks & SIXAXIS_CONTROLLER_USB);\r\nfor (n = 0; n < drv_data->led_count; n++) {\r\nif (led == drv_data->leds[n] && (force_update ||\r\n(value != drv_data->led_state[n] ||\r\ndrv_data->led_delay_on[n] ||\r\ndrv_data->led_delay_off[n]))) {\r\ndrv_data->led_state[n] = value;\r\ndrv_data->led_delay_on[n] = 0;\r\ndrv_data->led_delay_off[n] = 0;\r\nsony_set_leds(drv_data);\r\nbreak;\r\n}\r\n}\r\n}\r\nstatic enum led_brightness sony_led_get_brightness(struct led_classdev *led)\r\n{\r\nstruct device *dev = led->dev->parent;\r\nstruct hid_device *hdev = to_hid_device(dev);\r\nstruct sony_sc *drv_data;\r\nint n;\r\ndrv_data = hid_get_drvdata(hdev);\r\nif (!drv_data) {\r\nhid_err(hdev, "No device data\n");\r\nreturn LED_OFF;\r\n}\r\nfor (n = 0; n < drv_data->led_count; n++) {\r\nif (led == drv_data->leds[n])\r\nreturn drv_data->led_state[n];\r\n}\r\nreturn LED_OFF;\r\n}\r\nstatic int sony_led_blink_set(struct led_classdev *led, unsigned long *delay_on,\r\nunsigned long *delay_off)\r\n{\r\nstruct device *dev = led->dev->parent;\r\nstruct hid_device *hdev = to_hid_device(dev);\r\nstruct sony_sc *drv_data = hid_get_drvdata(hdev);\r\nint n;\r\nu8 new_on, new_off;\r\nif (!drv_data) {\r\nhid_err(hdev, "No device data\n");\r\nreturn -EINVAL;\r\n}\r\nif (*delay_on > 2550)\r\n*delay_on = 2550;\r\nif (*delay_off > 2550)\r\n*delay_off = 2550;\r\nif (!*delay_on && !*delay_off)\r\n*delay_on = *delay_off = 500;\r\nnew_on = *delay_on / 10;\r\nnew_off = *delay_off / 10;\r\nfor (n = 0; n < drv_data->led_count; n++) {\r\nif (led == drv_data->leds[n])\r\nbreak;\r\n}\r\nif (n >= drv_data->led_count)\r\nreturn -EINVAL;\r\nif (new_on != drv_data->led_delay_on[n] ||\r\nnew_off != drv_data->led_delay_off[n]) {\r\ndrv_data->led_delay_on[n] = new_on;\r\ndrv_data->led_delay_off[n] = new_off;\r\nschedule_work(&drv_data->state_worker);\r\n}\r\nreturn 0;\r\n}\r\nstatic void sony_leds_remove(struct sony_sc *sc)\r\n{\r\nstruct led_classdev *led;\r\nint n;\r\nBUG_ON(!(sc->quirks & SONY_LED_SUPPORT));\r\nfor (n = 0; n < sc->led_count; n++) {\r\nled = sc->leds[n];\r\nsc->leds[n] = NULL;\r\nif (!led)\r\ncontinue;\r\nled_classdev_unregister(led);\r\nkfree(led);\r\n}\r\nsc->led_count = 0;\r\n}\r\nstatic int sony_leds_init(struct sony_sc *sc)\r\n{\r\nstruct hid_device *hdev = sc->hdev;\r\nint n, ret = 0;\r\nint use_ds4_names;\r\nstruct led_classdev *led;\r\nsize_t name_sz;\r\nchar *name;\r\nsize_t name_len;\r\nconst char *name_fmt;\r\nstatic const char * const ds4_name_str[] = { "red", "green", "blue",\r\n"global" };\r\nu8 max_brightness[MAX_LEDS] = { [0 ... (MAX_LEDS - 1)] = 1 };\r\nu8 use_hw_blink[MAX_LEDS] = { 0 };\r\nBUG_ON(!(sc->quirks & SONY_LED_SUPPORT));\r\nif (sc->quirks & BUZZ_CONTROLLER) {\r\nsc->led_count = 4;\r\nuse_ds4_names = 0;\r\nname_len = strlen("::buzz#");\r\nname_fmt = "%s::buzz%d";\r\nif (!hid_validate_values(hdev, HID_OUTPUT_REPORT, 0, 0, 7))\r\nreturn -ENODEV;\r\n} else if (sc->quirks & DUALSHOCK4_CONTROLLER) {\r\ndualshock4_set_leds_from_id(sc);\r\nsc->led_state[3] = 1;\r\nsc->led_count = 4;\r\nmemset(max_brightness, 255, 3);\r\nuse_hw_blink[3] = 1;\r\nuse_ds4_names = 1;\r\nname_len = 0;\r\nname_fmt = "%s:%s";\r\n} else if (sc->quirks & MOTION_CONTROLLER) {\r\nsc->led_count = 3;\r\nmemset(max_brightness, 255, 3);\r\nuse_ds4_names = 1;\r\nname_len = 0;\r\nname_fmt = "%s:%s";\r\n} else if (sc->quirks & NAVIGATION_CONTROLLER) {\r\nstatic const u8 navigation_leds[4] = {0x01, 0x00, 0x00, 0x00};\r\nmemcpy(sc->led_state, navigation_leds, sizeof(navigation_leds));\r\nsc->led_count = 1;\r\nmemset(use_hw_blink, 1, 4);\r\nuse_ds4_names = 0;\r\nname_len = strlen("::sony#");\r\nname_fmt = "%s::sony%d";\r\n} else {\r\nsixaxis_set_leds_from_id(sc);\r\nsc->led_count = 4;\r\nmemset(use_hw_blink, 1, 4);\r\nuse_ds4_names = 0;\r\nname_len = strlen("::sony#");\r\nname_fmt = "%s::sony%d";\r\n}\r\nsony_set_leds(sc);\r\nname_sz = strlen(dev_name(&hdev->dev)) + name_len + 1;\r\nfor (n = 0; n < sc->led_count; n++) {\r\nif (use_ds4_names)\r\nname_sz = strlen(dev_name(&hdev->dev)) + strlen(ds4_name_str[n]) + 2;\r\nled = kzalloc(sizeof(struct led_classdev) + name_sz, GFP_KERNEL);\r\nif (!led) {\r\nhid_err(hdev, "Couldn't allocate memory for LED %d\n", n);\r\nret = -ENOMEM;\r\ngoto error_leds;\r\n}\r\nname = (void *)(&led[1]);\r\nif (use_ds4_names)\r\nsnprintf(name, name_sz, name_fmt, dev_name(&hdev->dev),\r\nds4_name_str[n]);\r\nelse\r\nsnprintf(name, name_sz, name_fmt, dev_name(&hdev->dev), n + 1);\r\nled->name = name;\r\nled->brightness = sc->led_state[n];\r\nled->max_brightness = max_brightness[n];\r\nled->brightness_get = sony_led_get_brightness;\r\nled->brightness_set = sony_led_set_brightness;\r\nif (use_hw_blink[n])\r\nled->blink_set = sony_led_blink_set;\r\nsc->leds[n] = led;\r\nret = led_classdev_register(&hdev->dev, led);\r\nif (ret) {\r\nhid_err(hdev, "Failed to register LED %d\n", n);\r\nsc->leds[n] = NULL;\r\nkfree(led);\r\ngoto error_leds;\r\n}\r\n}\r\nreturn ret;\r\nerror_leds:\r\nsony_leds_remove(sc);\r\nreturn ret;\r\n}\r\nstatic void sixaxis_send_output_report(struct sony_sc *sc)\r\n{\r\nstatic const union sixaxis_output_report_01 default_report = {\r\n.buf = {\r\n0x01,\r\n0x01, 0xff, 0x00, 0xff, 0x00,\r\n0x00, 0x00, 0x00, 0x00, 0x00,\r\n0xff, 0x27, 0x10, 0x00, 0x32,\r\n0xff, 0x27, 0x10, 0x00, 0x32,\r\n0xff, 0x27, 0x10, 0x00, 0x32,\r\n0xff, 0x27, 0x10, 0x00, 0x32,\r\n0x00, 0x00, 0x00, 0x00, 0x00\r\n}\r\n};\r\nstruct sixaxis_output_report *report =\r\n(struct sixaxis_output_report *)sc->output_report_dmabuf;\r\nint n;\r\nmemcpy(report, &default_report, sizeof(struct sixaxis_output_report));\r\n#ifdef CONFIG_SONY_FF\r\nreport->rumble.right_motor_on = sc->right ? 1 : 0;\r\nreport->rumble.left_motor_force = sc->left;\r\n#endif\r\nreport->leds_bitmap |= sc->led_state[0] << 1;\r\nreport->leds_bitmap |= sc->led_state[1] << 2;\r\nreport->leds_bitmap |= sc->led_state[2] << 3;\r\nreport->leds_bitmap |= sc->led_state[3] << 4;\r\nif ((report->leds_bitmap & 0x1E) == 0)\r\nreport->leds_bitmap |= 0x20;\r\nfor (n = 0; n < 4; n++) {\r\nif (sc->led_delay_on[n] || sc->led_delay_off[n]) {\r\nreport->led[3 - n].duty_off = sc->led_delay_off[n];\r\nreport->led[3 - n].duty_on = sc->led_delay_on[n];\r\n}\r\n}\r\nhid_hw_raw_request(sc->hdev, report->report_id, (u8 *)report,\r\nsizeof(struct sixaxis_output_report),\r\nHID_OUTPUT_REPORT, HID_REQ_SET_REPORT);\r\n}\r\nstatic void dualshock4_send_output_report(struct sony_sc *sc)\r\n{\r\nstruct hid_device *hdev = sc->hdev;\r\nu8 *buf = sc->output_report_dmabuf;\r\nint offset;\r\nif (sc->quirks & DUALSHOCK4_CONTROLLER_USB) {\r\nmemset(buf, 0, DS4_REPORT_0x05_SIZE);\r\nbuf[0] = 0x05;\r\nbuf[1] = 0xFF;\r\noffset = 4;\r\n} else {\r\nmemset(buf, 0, DS4_REPORT_0x11_SIZE);\r\nbuf[0] = 0x11;\r\nbuf[1] = 0x80;\r\nbuf[3] = 0x0F;\r\noffset = 6;\r\n}\r\n#ifdef CONFIG_SONY_FF\r\nbuf[offset++] = sc->right;\r\nbuf[offset++] = sc->left;\r\n#else\r\noffset += 2;\r\n#endif\r\nif (sc->led_state[3]) {\r\nbuf[offset++] = sc->led_state[0];\r\nbuf[offset++] = sc->led_state[1];\r\nbuf[offset++] = sc->led_state[2];\r\n} else {\r\noffset += 3;\r\n}\r\nbuf[offset++] = sc->led_delay_on[3];\r\nbuf[offset++] = sc->led_delay_off[3];\r\nif (sc->quirks & DUALSHOCK4_CONTROLLER_USB)\r\nhid_hw_output_report(hdev, buf, DS4_REPORT_0x05_SIZE);\r\nelse\r\nhid_hw_raw_request(hdev, 0x11, buf, DS4_REPORT_0x11_SIZE,\r\nHID_OUTPUT_REPORT, HID_REQ_SET_REPORT);\r\n}\r\nstatic void motion_send_output_report(struct sony_sc *sc)\r\n{\r\nstruct hid_device *hdev = sc->hdev;\r\nstruct motion_output_report_02 *report =\r\n(struct motion_output_report_02 *)sc->output_report_dmabuf;\r\nmemset(report, 0, MOTION_REPORT_0x02_SIZE);\r\nreport->type = 0x02;\r\nreport->r = sc->led_state[0];\r\nreport->g = sc->led_state[1];\r\nreport->b = sc->led_state[2];\r\n#ifdef CONFIG_SONY_FF\r\nreport->rumble = max(sc->right, sc->left);\r\n#endif\r\nhid_hw_output_report(hdev, (u8 *)report, MOTION_REPORT_0x02_SIZE);\r\n}\r\nstatic inline void sony_send_output_report(struct sony_sc *sc)\r\n{\r\nif (sc->send_output_report)\r\nsc->send_output_report(sc);\r\n}\r\nstatic void sony_state_worker(struct work_struct *work)\r\n{\r\nstruct sony_sc *sc = container_of(work, struct sony_sc, state_worker);\r\nsc->send_output_report(sc);\r\n}\r\nstatic int sony_allocate_output_report(struct sony_sc *sc)\r\n{\r\nif ((sc->quirks & SIXAXIS_CONTROLLER) ||\r\n(sc->quirks & NAVIGATION_CONTROLLER))\r\nsc->output_report_dmabuf =\r\nkmalloc(sizeof(union sixaxis_output_report_01),\r\nGFP_KERNEL);\r\nelse if (sc->quirks & DUALSHOCK4_CONTROLLER_BT)\r\nsc->output_report_dmabuf = kmalloc(DS4_REPORT_0x11_SIZE,\r\nGFP_KERNEL);\r\nelse if (sc->quirks & DUALSHOCK4_CONTROLLER_USB)\r\nsc->output_report_dmabuf = kmalloc(DS4_REPORT_0x05_SIZE,\r\nGFP_KERNEL);\r\nelse if (sc->quirks & MOTION_CONTROLLER)\r\nsc->output_report_dmabuf = kmalloc(MOTION_REPORT_0x02_SIZE,\r\nGFP_KERNEL);\r\nelse\r\nreturn 0;\r\nif (!sc->output_report_dmabuf)\r\nreturn -ENOMEM;\r\nreturn 0;\r\n}\r\nstatic int sony_play_effect(struct input_dev *dev, void *data,\r\nstruct ff_effect *effect)\r\n{\r\nstruct hid_device *hid = input_get_drvdata(dev);\r\nstruct sony_sc *sc = hid_get_drvdata(hid);\r\nif (effect->type != FF_RUMBLE)\r\nreturn 0;\r\nsc->left = effect->u.rumble.strong_magnitude / 256;\r\nsc->right = effect->u.rumble.weak_magnitude / 256;\r\nschedule_work(&sc->state_worker);\r\nreturn 0;\r\n}\r\nstatic int sony_init_ff(struct sony_sc *sc)\r\n{\r\nstruct hid_input *hidinput = list_entry(sc->hdev->inputs.next,\r\nstruct hid_input, list);\r\nstruct input_dev *input_dev = hidinput->input;\r\ninput_set_capability(input_dev, EV_FF, FF_RUMBLE);\r\nreturn input_ff_create_memless(input_dev, NULL, sony_play_effect);\r\n}\r\nstatic int sony_init_ff(struct sony_sc *sc)\r\n{\r\nreturn 0;\r\n}\r\nstatic int sony_battery_get_property(struct power_supply *psy,\r\nenum power_supply_property psp,\r\nunion power_supply_propval *val)\r\n{\r\nstruct sony_sc *sc = power_supply_get_drvdata(psy);\r\nunsigned long flags;\r\nint ret = 0;\r\nu8 battery_charging, battery_capacity, cable_state;\r\nspin_lock_irqsave(&sc->lock, flags);\r\nbattery_charging = sc->battery_charging;\r\nbattery_capacity = sc->battery_capacity;\r\ncable_state = sc->cable_state;\r\nspin_unlock_irqrestore(&sc->lock, flags);\r\nswitch (psp) {\r\ncase POWER_SUPPLY_PROP_PRESENT:\r\nval->intval = 1;\r\nbreak;\r\ncase POWER_SUPPLY_PROP_SCOPE:\r\nval->intval = POWER_SUPPLY_SCOPE_DEVICE;\r\nbreak;\r\ncase POWER_SUPPLY_PROP_CAPACITY:\r\nval->intval = battery_capacity;\r\nbreak;\r\ncase POWER_SUPPLY_PROP_STATUS:\r\nif (battery_charging)\r\nval->intval = POWER_SUPPLY_STATUS_CHARGING;\r\nelse\r\nif (battery_capacity == 100 && cable_state)\r\nval->intval = POWER_SUPPLY_STATUS_FULL;\r\nelse\r\nval->intval = POWER_SUPPLY_STATUS_DISCHARGING;\r\nbreak;\r\ndefault:\r\nret = -EINVAL;\r\nbreak;\r\n}\r\nreturn ret;\r\n}\r\nstatic int sony_battery_probe(struct sony_sc *sc)\r\n{\r\nstruct power_supply_config psy_cfg = { .drv_data = sc, };\r\nstruct hid_device *hdev = sc->hdev;\r\nint ret;\r\nsc->battery_capacity = 100;\r\nsc->battery_desc.properties = sony_battery_props;\r\nsc->battery_desc.num_properties = ARRAY_SIZE(sony_battery_props);\r\nsc->battery_desc.get_property = sony_battery_get_property;\r\nsc->battery_desc.type = POWER_SUPPLY_TYPE_BATTERY;\r\nsc->battery_desc.use_for_apm = 0;\r\nsc->battery_desc.name = kasprintf(GFP_KERNEL,\r\n"sony_controller_battery_%pMR",\r\nsc->mac_address);\r\nif (!sc->battery_desc.name)\r\nreturn -ENOMEM;\r\nsc->battery = power_supply_register(&hdev->dev, &sc->battery_desc,\r\n&psy_cfg);\r\nif (IS_ERR(sc->battery)) {\r\nret = PTR_ERR(sc->battery);\r\nhid_err(hdev, "Unable to register battery device\n");\r\ngoto err_free;\r\n}\r\npower_supply_powers(sc->battery, &hdev->dev);\r\nreturn 0;\r\nerr_free:\r\nkfree(sc->battery_desc.name);\r\nsc->battery_desc.name = NULL;\r\nreturn ret;\r\n}\r\nstatic void sony_battery_remove(struct sony_sc *sc)\r\n{\r\nif (!sc->battery_desc.name)\r\nreturn;\r\npower_supply_unregister(sc->battery);\r\nkfree(sc->battery_desc.name);\r\nsc->battery_desc.name = NULL;\r\n}\r\nstatic int sony_check_add_dev_list(struct sony_sc *sc)\r\n{\r\nstruct sony_sc *entry;\r\nunsigned long flags;\r\nint ret;\r\nspin_lock_irqsave(&sony_dev_list_lock, flags);\r\nlist_for_each_entry(entry, &sony_device_list, list_node) {\r\nret = memcmp(sc->mac_address, entry->mac_address,\r\nsizeof(sc->mac_address));\r\nif (!ret) {\r\nret = -EEXIST;\r\nhid_info(sc->hdev, "controller with MAC address %pMR already connected\n",\r\nsc->mac_address);\r\ngoto unlock;\r\n}\r\n}\r\nret = 0;\r\nlist_add(&(sc->list_node), &sony_device_list);\r\nunlock:\r\nspin_unlock_irqrestore(&sony_dev_list_lock, flags);\r\nreturn ret;\r\n}\r\nstatic void sony_remove_dev_list(struct sony_sc *sc)\r\n{\r\nunsigned long flags;\r\nif (sc->list_node.next) {\r\nspin_lock_irqsave(&sony_dev_list_lock, flags);\r\nlist_del(&(sc->list_node));\r\nspin_unlock_irqrestore(&sony_dev_list_lock, flags);\r\n}\r\n}\r\nstatic int sony_get_bt_devaddr(struct sony_sc *sc)\r\n{\r\nint ret;\r\nret = strlen(sc->hdev->uniq);\r\nif (ret != 17)\r\nreturn -EINVAL;\r\nret = sscanf(sc->hdev->uniq,\r\n"%02hhx:%02hhx:%02hhx:%02hhx:%02hhx:%02hhx",\r\n&sc->mac_address[5], &sc->mac_address[4], &sc->mac_address[3],\r\n&sc->mac_address[2], &sc->mac_address[1], &sc->mac_address[0]);\r\nif (ret != 6)\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\nstatic int sony_check_add(struct sony_sc *sc)\r\n{\r\nu8 *buf = NULL;\r\nint n, ret;\r\nif ((sc->quirks & DUALSHOCK4_CONTROLLER_BT) ||\r\n(sc->quirks & MOTION_CONTROLLER_BT) ||\r\n(sc->quirks & NAVIGATION_CONTROLLER_BT) ||\r\n(sc->quirks & SIXAXIS_CONTROLLER_BT)) {\r\nif (sony_get_bt_devaddr(sc) < 0) {\r\nhid_warn(sc->hdev, "UNIQ does not contain a MAC address; duplicate check skipped\n");\r\nreturn 0;\r\n}\r\n} else if (sc->quirks & DUALSHOCK4_CONTROLLER_USB) {\r\nbuf = kmalloc(DS4_REPORT_0x81_SIZE, GFP_KERNEL);\r\nif (!buf)\r\nreturn -ENOMEM;\r\nret = hid_hw_raw_request(sc->hdev, 0x81, buf,\r\nDS4_REPORT_0x81_SIZE, HID_FEATURE_REPORT,\r\nHID_REQ_GET_REPORT);\r\nif (ret != DS4_REPORT_0x81_SIZE) {\r\nhid_err(sc->hdev, "failed to retrieve feature report 0x81 with the DualShock 4 MAC address\n");\r\nret = ret < 0 ? ret : -EINVAL;\r\ngoto out_free;\r\n}\r\nmemcpy(sc->mac_address, &buf[1], sizeof(sc->mac_address));\r\n} else if ((sc->quirks & SIXAXIS_CONTROLLER_USB) ||\r\n(sc->quirks & NAVIGATION_CONTROLLER_USB)) {\r\nbuf = kmalloc(SIXAXIS_REPORT_0xF2_SIZE, GFP_KERNEL);\r\nif (!buf)\r\nreturn -ENOMEM;\r\nret = hid_hw_raw_request(sc->hdev, 0xf2, buf,\r\nSIXAXIS_REPORT_0xF2_SIZE, HID_FEATURE_REPORT,\r\nHID_REQ_GET_REPORT);\r\nif (ret != SIXAXIS_REPORT_0xF2_SIZE) {\r\nhid_err(sc->hdev, "failed to retrieve feature report 0xf2 with the Sixaxis MAC address\n");\r\nret = ret < 0 ? ret : -EINVAL;\r\ngoto out_free;\r\n}\r\nfor (n = 0; n < 6; n++)\r\nsc->mac_address[5-n] = buf[4+n];\r\n} else {\r\nreturn 0;\r\n}\r\nret = sony_check_add_dev_list(sc);\r\nout_free:\r\nkfree(buf);\r\nreturn ret;\r\n}\r\nstatic int sony_set_device_id(struct sony_sc *sc)\r\n{\r\nint ret;\r\nif ((sc->quirks & SIXAXIS_CONTROLLER) ||\r\n(sc->quirks & DUALSHOCK4_CONTROLLER)) {\r\nret = ida_simple_get(&sony_device_id_allocator, 0, 0,\r\nGFP_KERNEL);\r\nif (ret < 0) {\r\nsc->device_id = -1;\r\nreturn ret;\r\n}\r\nsc->device_id = ret;\r\n} else {\r\nsc->device_id = -1;\r\n}\r\nreturn 0;\r\n}\r\nstatic void sony_release_device_id(struct sony_sc *sc)\r\n{\r\nif (sc->device_id >= 0) {\r\nida_simple_remove(&sony_device_id_allocator, sc->device_id);\r\nsc->device_id = -1;\r\n}\r\n}\r\nstatic inline void sony_init_output_report(struct sony_sc *sc,\r\nvoid (*send_output_report)(struct sony_sc *))\r\n{\r\nsc->send_output_report = send_output_report;\r\nif (!sc->worker_initialized)\r\nINIT_WORK(&sc->state_worker, sony_state_worker);\r\nsc->worker_initialized = 1;\r\n}\r\nstatic inline void sony_cancel_work_sync(struct sony_sc *sc)\r\n{\r\nif (sc->worker_initialized)\r\ncancel_work_sync(&sc->state_worker);\r\n}\r\nstatic int sony_probe(struct hid_device *hdev, const struct hid_device_id *id)\r\n{\r\nint ret;\r\nunsigned long quirks = id->driver_data;\r\nstruct sony_sc *sc;\r\nunsigned int connect_mask = HID_CONNECT_DEFAULT;\r\nsc = devm_kzalloc(&hdev->dev, sizeof(*sc), GFP_KERNEL);\r\nif (sc == NULL) {\r\nhid_err(hdev, "can't alloc sony descriptor\n");\r\nreturn -ENOMEM;\r\n}\r\nspin_lock_init(&sc->lock);\r\nsc->quirks = quirks;\r\nhid_set_drvdata(hdev, sc);\r\nsc->hdev = hdev;\r\nret = hid_parse(hdev);\r\nif (ret) {\r\nhid_err(hdev, "parse failed\n");\r\nreturn ret;\r\n}\r\nif (sc->quirks & VAIO_RDESC_CONSTANT)\r\nconnect_mask |= HID_CONNECT_HIDDEV_FORCE;\r\nelse if (sc->quirks & SIXAXIS_CONTROLLER)\r\nconnect_mask |= HID_CONNECT_HIDDEV_FORCE;\r\nret = hid_hw_start(hdev, connect_mask);\r\nif (ret) {\r\nhid_err(hdev, "hw start failed\n");\r\nreturn ret;\r\n}\r\nret = sony_set_device_id(sc);\r\nif (ret < 0) {\r\nhid_err(hdev, "failed to allocate the device id\n");\r\ngoto err_stop;\r\n}\r\nret = sony_allocate_output_report(sc);\r\nif (ret < 0) {\r\nhid_err(hdev, "failed to allocate the output report buffer\n");\r\ngoto err_stop;\r\n}\r\nif ((sc->quirks & SIXAXIS_CONTROLLER_USB) ||\r\n(sc->quirks & NAVIGATION_CONTROLLER_USB)) {\r\nhdev->quirks |= HID_QUIRK_NO_OUTPUT_REPORTS_ON_INTR_EP;\r\nhdev->quirks |= HID_QUIRK_SKIP_OUTPUT_REPORT_ID;\r\nret = sixaxis_set_operational_usb(hdev);\r\nsony_init_output_report(sc, sixaxis_send_output_report);\r\n} else if ((sc->quirks & SIXAXIS_CONTROLLER_BT) ||\r\n(sc->quirks & NAVIGATION_CONTROLLER_BT)) {\r\nhdev->quirks |= HID_QUIRK_NO_OUTPUT_REPORTS_ON_INTR_EP;\r\nret = sixaxis_set_operational_bt(hdev);\r\nsony_init_output_report(sc, sixaxis_send_output_report);\r\n} else if (sc->quirks & DUALSHOCK4_CONTROLLER) {\r\nif (sc->quirks & DUALSHOCK4_CONTROLLER_BT) {\r\nhdev->quirks |= HID_QUIRK_NO_OUTPUT_REPORTS_ON_INTR_EP;\r\nret = dualshock4_set_operational_bt(hdev);\r\nif (ret < 0) {\r\nhid_err(hdev, "failed to set the Dualshock 4 operational mode\n");\r\ngoto err_stop;\r\n}\r\n}\r\nsony_init_output_report(sc, dualshock4_send_output_report);\r\n} else if (sc->quirks & MOTION_CONTROLLER) {\r\nsony_init_output_report(sc, motion_send_output_report);\r\n} else {\r\nret = 0;\r\n}\r\nif (ret < 0)\r\ngoto err_stop;\r\nret = sony_check_add(sc);\r\nif (ret < 0)\r\ngoto err_stop;\r\nif (sc->quirks & SONY_LED_SUPPORT) {\r\nret = sony_leds_init(sc);\r\nif (ret < 0)\r\ngoto err_stop;\r\n}\r\nif (sc->quirks & SONY_BATTERY_SUPPORT) {\r\nret = sony_battery_probe(sc);\r\nif (ret < 0)\r\ngoto err_stop;\r\nret = hid_hw_open(hdev);\r\nif (ret < 0) {\r\nhid_err(hdev, "hw open failed\n");\r\ngoto err_stop;\r\n}\r\n}\r\nif (sc->quirks & SONY_FF_SUPPORT) {\r\nret = sony_init_ff(sc);\r\nif (ret < 0)\r\ngoto err_close;\r\n}\r\nreturn 0;\r\nerr_close:\r\nhid_hw_close(hdev);\r\nerr_stop:\r\nif (sc->quirks & SONY_LED_SUPPORT)\r\nsony_leds_remove(sc);\r\nif (sc->quirks & SONY_BATTERY_SUPPORT)\r\nsony_battery_remove(sc);\r\nsony_cancel_work_sync(sc);\r\nkfree(sc->output_report_dmabuf);\r\nsony_remove_dev_list(sc);\r\nsony_release_device_id(sc);\r\nhid_hw_stop(hdev);\r\nreturn ret;\r\n}\r\nstatic void sony_remove(struct hid_device *hdev)\r\n{\r\nstruct sony_sc *sc = hid_get_drvdata(hdev);\r\nif (sc->quirks & SONY_LED_SUPPORT)\r\nsony_leds_remove(sc);\r\nif (sc->quirks & SONY_BATTERY_SUPPORT) {\r\nhid_hw_close(hdev);\r\nsony_battery_remove(sc);\r\n}\r\nsony_cancel_work_sync(sc);\r\nkfree(sc->output_report_dmabuf);\r\nsony_remove_dev_list(sc);\r\nsony_release_device_id(sc);\r\nhid_hw_stop(hdev);\r\n}\r\nstatic int sony_suspend(struct hid_device *hdev, pm_message_t message)\r\n{\r\nif (SONY_LED_SUPPORT || SONY_FF_SUPPORT) {\r\nstruct sony_sc *sc = hid_get_drvdata(hdev);\r\n#ifdef CONFIG_SONY_FF\r\nsc->left = sc->right = 0;\r\n#endif\r\nmemcpy(sc->resume_led_state, sc->led_state,\r\nsizeof(sc->resume_led_state));\r\nmemset(sc->led_state, 0, sizeof(sc->led_state));\r\nsony_send_output_report(sc);\r\n}\r\nreturn 0;\r\n}\r\nstatic int sony_resume(struct hid_device *hdev)\r\n{\r\nif (SONY_LED_SUPPORT) {\r\nstruct sony_sc *sc = hid_get_drvdata(hdev);\r\nmemcpy(sc->led_state, sc->resume_led_state,\r\nsizeof(sc->led_state));\r\nif ((sc->quirks & SIXAXIS_CONTROLLER_USB) ||\r\n(sc->quirks & NAVIGATION_CONTROLLER_USB))\r\nsixaxis_set_operational_usb(sc->hdev);\r\nsony_set_leds(sc);\r\n}\r\nreturn 0;\r\n}\r\nstatic int __init sony_init(void)\r\n{\r\ndbg_hid("Sony:%s\n", __func__);\r\nreturn hid_register_driver(&sony_driver);\r\n}\r\nstatic void __exit sony_exit(void)\r\n{\r\ndbg_hid("Sony:%s\n", __func__);\r\nhid_unregister_driver(&sony_driver);\r\nida_destroy(&sony_device_id_allocator);\r\n}
