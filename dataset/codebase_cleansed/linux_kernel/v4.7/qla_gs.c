void *\r\nqla2x00_prep_ms_iocb(scsi_qla_host_t *vha, uint32_t req_size, uint32_t rsp_size)\r\n{\r\nstruct qla_hw_data *ha = vha->hw;\r\nms_iocb_entry_t *ms_pkt;\r\nms_pkt = ha->ms_iocb;\r\nmemset(ms_pkt, 0, sizeof(ms_iocb_entry_t));\r\nms_pkt->entry_type = MS_IOCB_TYPE;\r\nms_pkt->entry_count = 1;\r\nSET_TARGET_ID(ha, ms_pkt->loop_id, SIMPLE_NAME_SERVER);\r\nms_pkt->control_flags = cpu_to_le16(CF_READ | CF_HEAD_TAG);\r\nms_pkt->timeout = cpu_to_le16(ha->r_a_tov / 10 * 2);\r\nms_pkt->cmd_dsd_count = cpu_to_le16(1);\r\nms_pkt->total_dsd_count = cpu_to_le16(2);\r\nms_pkt->rsp_bytecount = cpu_to_le32(rsp_size);\r\nms_pkt->req_bytecount = cpu_to_le32(req_size);\r\nms_pkt->dseg_req_address[0] = cpu_to_le32(LSD(ha->ct_sns_dma));\r\nms_pkt->dseg_req_address[1] = cpu_to_le32(MSD(ha->ct_sns_dma));\r\nms_pkt->dseg_req_length = ms_pkt->req_bytecount;\r\nms_pkt->dseg_rsp_address[0] = cpu_to_le32(LSD(ha->ct_sns_dma));\r\nms_pkt->dseg_rsp_address[1] = cpu_to_le32(MSD(ha->ct_sns_dma));\r\nms_pkt->dseg_rsp_length = ms_pkt->rsp_bytecount;\r\nvha->qla_stats.control_requests++;\r\nreturn (ms_pkt);\r\n}\r\nvoid *\r\nqla24xx_prep_ms_iocb(scsi_qla_host_t *vha, uint32_t req_size, uint32_t rsp_size)\r\n{\r\nstruct qla_hw_data *ha = vha->hw;\r\nstruct ct_entry_24xx *ct_pkt;\r\nct_pkt = (struct ct_entry_24xx *)ha->ms_iocb;\r\nmemset(ct_pkt, 0, sizeof(struct ct_entry_24xx));\r\nct_pkt->entry_type = CT_IOCB_TYPE;\r\nct_pkt->entry_count = 1;\r\nct_pkt->nport_handle = cpu_to_le16(NPH_SNS);\r\nct_pkt->timeout = cpu_to_le16(ha->r_a_tov / 10 * 2);\r\nct_pkt->cmd_dsd_count = cpu_to_le16(1);\r\nct_pkt->rsp_dsd_count = cpu_to_le16(1);\r\nct_pkt->rsp_byte_count = cpu_to_le32(rsp_size);\r\nct_pkt->cmd_byte_count = cpu_to_le32(req_size);\r\nct_pkt->dseg_0_address[0] = cpu_to_le32(LSD(ha->ct_sns_dma));\r\nct_pkt->dseg_0_address[1] = cpu_to_le32(MSD(ha->ct_sns_dma));\r\nct_pkt->dseg_0_len = ct_pkt->cmd_byte_count;\r\nct_pkt->dseg_1_address[0] = cpu_to_le32(LSD(ha->ct_sns_dma));\r\nct_pkt->dseg_1_address[1] = cpu_to_le32(MSD(ha->ct_sns_dma));\r\nct_pkt->dseg_1_len = ct_pkt->rsp_byte_count;\r\nct_pkt->vp_index = vha->vp_idx;\r\nvha->qla_stats.control_requests++;\r\nreturn (ct_pkt);\r\n}\r\nstatic inline struct ct_sns_req *\r\nqla2x00_prep_ct_req(struct ct_sns_pkt *p, uint16_t cmd, uint16_t rsp_size)\r\n{\r\nmemset(p, 0, sizeof(struct ct_sns_pkt));\r\np->p.req.header.revision = 0x01;\r\np->p.req.header.gs_type = 0xFC;\r\np->p.req.header.gs_subtype = 0x02;\r\np->p.req.command = cpu_to_be16(cmd);\r\np->p.req.max_rsp_size = cpu_to_be16((rsp_size - 16) / 4);\r\nreturn &p->p.req;\r\n}\r\nstatic int\r\nqla2x00_chk_ms_status(scsi_qla_host_t *vha, ms_iocb_entry_t *ms_pkt,\r\nstruct ct_sns_rsp *ct_rsp, const char *routine)\r\n{\r\nint rval;\r\nuint16_t comp_status;\r\nstruct qla_hw_data *ha = vha->hw;\r\nrval = QLA_FUNCTION_FAILED;\r\nif (ms_pkt->entry_status != 0) {\r\nql_dbg(ql_dbg_disc, vha, 0x2031,\r\n"%s failed, error status (%x) on port_id: %02x%02x%02x.\n",\r\nroutine, ms_pkt->entry_status, vha->d_id.b.domain,\r\nvha->d_id.b.area, vha->d_id.b.al_pa);\r\n} else {\r\nif (IS_FWI2_CAPABLE(ha))\r\ncomp_status = le16_to_cpu(\r\n((struct ct_entry_24xx *)ms_pkt)->comp_status);\r\nelse\r\ncomp_status = le16_to_cpu(ms_pkt->status);\r\nswitch (comp_status) {\r\ncase CS_COMPLETE:\r\ncase CS_DATA_UNDERRUN:\r\ncase CS_DATA_OVERRUN:\r\nif (ct_rsp->header.response !=\r\ncpu_to_be16(CT_ACCEPT_RESPONSE)) {\r\nql_dbg(ql_dbg_disc + ql_dbg_buffer, vha, 0x2077,\r\n"%s failed rejected request on port_id: %02x%02x%02x Compeltion status 0x%x, response 0x%x\n",\r\nroutine, vha->d_id.b.domain,\r\nvha->d_id.b.area, vha->d_id.b.al_pa,\r\ncomp_status, ct_rsp->header.response);\r\nql_dump_buffer(ql_dbg_disc + ql_dbg_buffer, vha,\r\n0x2078, (uint8_t *)&ct_rsp->header,\r\nsizeof(struct ct_rsp_hdr));\r\nrval = QLA_INVALID_COMMAND;\r\n} else\r\nrval = QLA_SUCCESS;\r\nbreak;\r\ndefault:\r\nql_dbg(ql_dbg_disc, vha, 0x2033,\r\n"%s failed, completion status (%x) on port_id: "\r\n"%02x%02x%02x.\n", routine, comp_status,\r\nvha->d_id.b.domain, vha->d_id.b.area,\r\nvha->d_id.b.al_pa);\r\nbreak;\r\n}\r\n}\r\nreturn rval;\r\n}\r\nint\r\nqla2x00_ga_nxt(scsi_qla_host_t *vha, fc_port_t *fcport)\r\n{\r\nint rval;\r\nms_iocb_entry_t *ms_pkt;\r\nstruct ct_sns_req *ct_req;\r\nstruct ct_sns_rsp *ct_rsp;\r\nstruct qla_hw_data *ha = vha->hw;\r\nif (IS_QLA2100(ha) || IS_QLA2200(ha))\r\nreturn qla2x00_sns_ga_nxt(vha, fcport);\r\nms_pkt = ha->isp_ops->prep_ms_iocb(vha, GA_NXT_REQ_SIZE,\r\nGA_NXT_RSP_SIZE);\r\nct_req = qla2x00_prep_ct_req(ha->ct_sns, GA_NXT_CMD,\r\nGA_NXT_RSP_SIZE);\r\nct_rsp = &ha->ct_sns->p.rsp;\r\nct_req->req.port_id.port_id[0] = fcport->d_id.b.domain;\r\nct_req->req.port_id.port_id[1] = fcport->d_id.b.area;\r\nct_req->req.port_id.port_id[2] = fcport->d_id.b.al_pa;\r\nrval = qla2x00_issue_iocb(vha, ha->ms_iocb, ha->ms_iocb_dma,\r\nsizeof(ms_iocb_entry_t));\r\nif (rval != QLA_SUCCESS) {\r\nql_dbg(ql_dbg_disc, vha, 0x2062,\r\n"GA_NXT issue IOCB failed (%d).\n", rval);\r\n} else if (qla2x00_chk_ms_status(vha, ms_pkt, ct_rsp, "GA_NXT") !=\r\nQLA_SUCCESS) {\r\nrval = QLA_FUNCTION_FAILED;\r\n} else {\r\nfcport->d_id.b.domain = ct_rsp->rsp.ga_nxt.port_id[0];\r\nfcport->d_id.b.area = ct_rsp->rsp.ga_nxt.port_id[1];\r\nfcport->d_id.b.al_pa = ct_rsp->rsp.ga_nxt.port_id[2];\r\nmemcpy(fcport->node_name, ct_rsp->rsp.ga_nxt.node_name,\r\nWWN_SIZE);\r\nmemcpy(fcport->port_name, ct_rsp->rsp.ga_nxt.port_name,\r\nWWN_SIZE);\r\nfcport->fc4_type = (ct_rsp->rsp.ga_nxt.fc4_types[2] & BIT_0) ?\r\nFC4_TYPE_FCP_SCSI : FC4_TYPE_OTHER;\r\nif (ct_rsp->rsp.ga_nxt.port_type != NS_N_PORT_TYPE &&\r\nct_rsp->rsp.ga_nxt.port_type != NS_NL_PORT_TYPE)\r\nfcport->d_id.b.domain = 0xf0;\r\nql_dbg(ql_dbg_disc, vha, 0x2063,\r\n"GA_NXT entry - nn %8phN pn %8phN "\r\n"port_id=%02x%02x%02x.\n",\r\nfcport->node_name, fcport->port_name,\r\nfcport->d_id.b.domain, fcport->d_id.b.area,\r\nfcport->d_id.b.al_pa);\r\n}\r\nreturn (rval);\r\n}\r\nstatic inline int\r\nqla2x00_gid_pt_rsp_size(scsi_qla_host_t *vha)\r\n{\r\nreturn vha->hw->max_fibre_devices * 4 + 16;\r\n}\r\nint\r\nqla2x00_gid_pt(scsi_qla_host_t *vha, sw_info_t *list)\r\n{\r\nint rval;\r\nuint16_t i;\r\nms_iocb_entry_t *ms_pkt;\r\nstruct ct_sns_req *ct_req;\r\nstruct ct_sns_rsp *ct_rsp;\r\nstruct ct_sns_gid_pt_data *gid_data;\r\nstruct qla_hw_data *ha = vha->hw;\r\nuint16_t gid_pt_rsp_size;\r\nif (IS_QLA2100(ha) || IS_QLA2200(ha))\r\nreturn qla2x00_sns_gid_pt(vha, list);\r\ngid_data = NULL;\r\ngid_pt_rsp_size = qla2x00_gid_pt_rsp_size(vha);\r\nms_pkt = ha->isp_ops->prep_ms_iocb(vha, GID_PT_REQ_SIZE,\r\ngid_pt_rsp_size);\r\nct_req = qla2x00_prep_ct_req(ha->ct_sns, GID_PT_CMD, gid_pt_rsp_size);\r\nct_rsp = &ha->ct_sns->p.rsp;\r\nct_req->req.gid_pt.port_type = NS_NX_PORT_TYPE;\r\nrval = qla2x00_issue_iocb(vha, ha->ms_iocb, ha->ms_iocb_dma,\r\nsizeof(ms_iocb_entry_t));\r\nif (rval != QLA_SUCCESS) {\r\nql_dbg(ql_dbg_disc, vha, 0x2055,\r\n"GID_PT issue IOCB failed (%d).\n", rval);\r\n} else if (qla2x00_chk_ms_status(vha, ms_pkt, ct_rsp, "GID_PT") !=\r\nQLA_SUCCESS) {\r\nrval = QLA_FUNCTION_FAILED;\r\n} else {\r\nfor (i = 0; i < ha->max_fibre_devices; i++) {\r\ngid_data = &ct_rsp->rsp.gid_pt.entries[i];\r\nlist[i].d_id.b.domain = gid_data->port_id[0];\r\nlist[i].d_id.b.area = gid_data->port_id[1];\r\nlist[i].d_id.b.al_pa = gid_data->port_id[2];\r\nmemset(list[i].fabric_port_name, 0, WWN_SIZE);\r\nlist[i].fp_speed = PORT_SPEED_UNKNOWN;\r\nif (gid_data->control_byte & BIT_7) {\r\nlist[i].d_id.b.rsvd_1 = gid_data->control_byte;\r\nbreak;\r\n}\r\n}\r\nif (i == ha->max_fibre_devices)\r\nrval = QLA_FUNCTION_FAILED;\r\n}\r\nreturn (rval);\r\n}\r\nint\r\nqla2x00_gpn_id(scsi_qla_host_t *vha, sw_info_t *list)\r\n{\r\nint rval = QLA_SUCCESS;\r\nuint16_t i;\r\nms_iocb_entry_t *ms_pkt;\r\nstruct ct_sns_req *ct_req;\r\nstruct ct_sns_rsp *ct_rsp;\r\nstruct qla_hw_data *ha = vha->hw;\r\nif (IS_QLA2100(ha) || IS_QLA2200(ha))\r\nreturn qla2x00_sns_gpn_id(vha, list);\r\nfor (i = 0; i < ha->max_fibre_devices; i++) {\r\nms_pkt = ha->isp_ops->prep_ms_iocb(vha, GPN_ID_REQ_SIZE,\r\nGPN_ID_RSP_SIZE);\r\nct_req = qla2x00_prep_ct_req(ha->ct_sns, GPN_ID_CMD,\r\nGPN_ID_RSP_SIZE);\r\nct_rsp = &ha->ct_sns->p.rsp;\r\nct_req->req.port_id.port_id[0] = list[i].d_id.b.domain;\r\nct_req->req.port_id.port_id[1] = list[i].d_id.b.area;\r\nct_req->req.port_id.port_id[2] = list[i].d_id.b.al_pa;\r\nrval = qla2x00_issue_iocb(vha, ha->ms_iocb, ha->ms_iocb_dma,\r\nsizeof(ms_iocb_entry_t));\r\nif (rval != QLA_SUCCESS) {\r\nql_dbg(ql_dbg_disc, vha, 0x2056,\r\n"GPN_ID issue IOCB failed (%d).\n", rval);\r\nbreak;\r\n} else if (qla2x00_chk_ms_status(vha, ms_pkt, ct_rsp,\r\n"GPN_ID") != QLA_SUCCESS) {\r\nrval = QLA_FUNCTION_FAILED;\r\nbreak;\r\n} else {\r\nmemcpy(list[i].port_name,\r\nct_rsp->rsp.gpn_id.port_name, WWN_SIZE);\r\n}\r\nif (list[i].d_id.b.rsvd_1 != 0)\r\nbreak;\r\n}\r\nreturn (rval);\r\n}\r\nint\r\nqla2x00_gnn_id(scsi_qla_host_t *vha, sw_info_t *list)\r\n{\r\nint rval = QLA_SUCCESS;\r\nuint16_t i;\r\nstruct qla_hw_data *ha = vha->hw;\r\nms_iocb_entry_t *ms_pkt;\r\nstruct ct_sns_req *ct_req;\r\nstruct ct_sns_rsp *ct_rsp;\r\nif (IS_QLA2100(ha) || IS_QLA2200(ha))\r\nreturn qla2x00_sns_gnn_id(vha, list);\r\nfor (i = 0; i < ha->max_fibre_devices; i++) {\r\nms_pkt = ha->isp_ops->prep_ms_iocb(vha, GNN_ID_REQ_SIZE,\r\nGNN_ID_RSP_SIZE);\r\nct_req = qla2x00_prep_ct_req(ha->ct_sns, GNN_ID_CMD,\r\nGNN_ID_RSP_SIZE);\r\nct_rsp = &ha->ct_sns->p.rsp;\r\nct_req->req.port_id.port_id[0] = list[i].d_id.b.domain;\r\nct_req->req.port_id.port_id[1] = list[i].d_id.b.area;\r\nct_req->req.port_id.port_id[2] = list[i].d_id.b.al_pa;\r\nrval = qla2x00_issue_iocb(vha, ha->ms_iocb, ha->ms_iocb_dma,\r\nsizeof(ms_iocb_entry_t));\r\nif (rval != QLA_SUCCESS) {\r\nql_dbg(ql_dbg_disc, vha, 0x2057,\r\n"GNN_ID issue IOCB failed (%d).\n", rval);\r\nbreak;\r\n} else if (qla2x00_chk_ms_status(vha, ms_pkt, ct_rsp,\r\n"GNN_ID") != QLA_SUCCESS) {\r\nrval = QLA_FUNCTION_FAILED;\r\nbreak;\r\n} else {\r\nmemcpy(list[i].node_name,\r\nct_rsp->rsp.gnn_id.node_name, WWN_SIZE);\r\nql_dbg(ql_dbg_disc, vha, 0x2058,\r\n"GID_PT entry - nn %8phN pn %8phN "\r\n"portid=%02x%02x%02x.\n",\r\nlist[i].node_name, list[i].port_name,\r\nlist[i].d_id.b.domain, list[i].d_id.b.area,\r\nlist[i].d_id.b.al_pa);\r\n}\r\nif (list[i].d_id.b.rsvd_1 != 0)\r\nbreak;\r\n}\r\nreturn (rval);\r\n}\r\nint\r\nqla2x00_rft_id(scsi_qla_host_t *vha)\r\n{\r\nint rval;\r\nstruct qla_hw_data *ha = vha->hw;\r\nms_iocb_entry_t *ms_pkt;\r\nstruct ct_sns_req *ct_req;\r\nstruct ct_sns_rsp *ct_rsp;\r\nif (IS_QLA2100(ha) || IS_QLA2200(ha))\r\nreturn qla2x00_sns_rft_id(vha);\r\nms_pkt = ha->isp_ops->prep_ms_iocb(vha, RFT_ID_REQ_SIZE,\r\nRFT_ID_RSP_SIZE);\r\nct_req = qla2x00_prep_ct_req(ha->ct_sns, RFT_ID_CMD,\r\nRFT_ID_RSP_SIZE);\r\nct_rsp = &ha->ct_sns->p.rsp;\r\nct_req->req.rft_id.port_id[0] = vha->d_id.b.domain;\r\nct_req->req.rft_id.port_id[1] = vha->d_id.b.area;\r\nct_req->req.rft_id.port_id[2] = vha->d_id.b.al_pa;\r\nct_req->req.rft_id.fc4_types[2] = 0x01;\r\nrval = qla2x00_issue_iocb(vha, ha->ms_iocb, ha->ms_iocb_dma,\r\nsizeof(ms_iocb_entry_t));\r\nif (rval != QLA_SUCCESS) {\r\nql_dbg(ql_dbg_disc, vha, 0x2043,\r\n"RFT_ID issue IOCB failed (%d).\n", rval);\r\n} else if (qla2x00_chk_ms_status(vha, ms_pkt, ct_rsp, "RFT_ID") !=\r\nQLA_SUCCESS) {\r\nrval = QLA_FUNCTION_FAILED;\r\n} else {\r\nql_dbg(ql_dbg_disc, vha, 0x2044,\r\n"RFT_ID exiting normally.\n");\r\n}\r\nreturn (rval);\r\n}\r\nint\r\nqla2x00_rff_id(scsi_qla_host_t *vha)\r\n{\r\nint rval;\r\nstruct qla_hw_data *ha = vha->hw;\r\nms_iocb_entry_t *ms_pkt;\r\nstruct ct_sns_req *ct_req;\r\nstruct ct_sns_rsp *ct_rsp;\r\nif (IS_QLA2100(ha) || IS_QLA2200(ha)) {\r\nql_dbg(ql_dbg_disc, vha, 0x2046,\r\n"RFF_ID call not supported on ISP2100/ISP2200.\n");\r\nreturn (QLA_SUCCESS);\r\n}\r\nms_pkt = ha->isp_ops->prep_ms_iocb(vha, RFF_ID_REQ_SIZE,\r\nRFF_ID_RSP_SIZE);\r\nct_req = qla2x00_prep_ct_req(ha->ct_sns, RFF_ID_CMD,\r\nRFF_ID_RSP_SIZE);\r\nct_rsp = &ha->ct_sns->p.rsp;\r\nct_req->req.rff_id.port_id[0] = vha->d_id.b.domain;\r\nct_req->req.rff_id.port_id[1] = vha->d_id.b.area;\r\nct_req->req.rff_id.port_id[2] = vha->d_id.b.al_pa;\r\nqlt_rff_id(vha, ct_req);\r\nct_req->req.rff_id.fc4_type = 0x08;\r\nrval = qla2x00_issue_iocb(vha, ha->ms_iocb, ha->ms_iocb_dma,\r\nsizeof(ms_iocb_entry_t));\r\nif (rval != QLA_SUCCESS) {\r\nql_dbg(ql_dbg_disc, vha, 0x2047,\r\n"RFF_ID issue IOCB failed (%d).\n", rval);\r\n} else if (qla2x00_chk_ms_status(vha, ms_pkt, ct_rsp, "RFF_ID") !=\r\nQLA_SUCCESS) {\r\nrval = QLA_FUNCTION_FAILED;\r\n} else {\r\nql_dbg(ql_dbg_disc, vha, 0x2048,\r\n"RFF_ID exiting normally.\n");\r\n}\r\nreturn (rval);\r\n}\r\nint\r\nqla2x00_rnn_id(scsi_qla_host_t *vha)\r\n{\r\nint rval;\r\nstruct qla_hw_data *ha = vha->hw;\r\nms_iocb_entry_t *ms_pkt;\r\nstruct ct_sns_req *ct_req;\r\nstruct ct_sns_rsp *ct_rsp;\r\nif (IS_QLA2100(ha) || IS_QLA2200(ha))\r\nreturn qla2x00_sns_rnn_id(vha);\r\nms_pkt = ha->isp_ops->prep_ms_iocb(vha, RNN_ID_REQ_SIZE,\r\nRNN_ID_RSP_SIZE);\r\nct_req = qla2x00_prep_ct_req(ha->ct_sns, RNN_ID_CMD, RNN_ID_RSP_SIZE);\r\nct_rsp = &ha->ct_sns->p.rsp;\r\nct_req->req.rnn_id.port_id[0] = vha->d_id.b.domain;\r\nct_req->req.rnn_id.port_id[1] = vha->d_id.b.area;\r\nct_req->req.rnn_id.port_id[2] = vha->d_id.b.al_pa;\r\nmemcpy(ct_req->req.rnn_id.node_name, vha->node_name, WWN_SIZE);\r\nrval = qla2x00_issue_iocb(vha, ha->ms_iocb, ha->ms_iocb_dma,\r\nsizeof(ms_iocb_entry_t));\r\nif (rval != QLA_SUCCESS) {\r\nql_dbg(ql_dbg_disc, vha, 0x204d,\r\n"RNN_ID issue IOCB failed (%d).\n", rval);\r\n} else if (qla2x00_chk_ms_status(vha, ms_pkt, ct_rsp, "RNN_ID") !=\r\nQLA_SUCCESS) {\r\nrval = QLA_FUNCTION_FAILED;\r\n} else {\r\nql_dbg(ql_dbg_disc, vha, 0x204e,\r\n"RNN_ID exiting normally.\n");\r\n}\r\nreturn (rval);\r\n}\r\nvoid\r\nqla2x00_get_sym_node_name(scsi_qla_host_t *vha, uint8_t *snn, size_t size)\r\n{\r\nstruct qla_hw_data *ha = vha->hw;\r\nif (IS_QLAFX00(ha))\r\nsnprintf(snn, size, "%s FW:v%s DVR:v%s", ha->model_number,\r\nha->mr.fw_version, qla2x00_version_str);\r\nelse\r\nsnprintf(snn, size,\r\n"%s FW:v%d.%02d.%02d DVR:v%s", ha->model_number,\r\nha->fw_major_version, ha->fw_minor_version,\r\nha->fw_subminor_version, qla2x00_version_str);\r\n}\r\nint\r\nqla2x00_rsnn_nn(scsi_qla_host_t *vha)\r\n{\r\nint rval;\r\nstruct qla_hw_data *ha = vha->hw;\r\nms_iocb_entry_t *ms_pkt;\r\nstruct ct_sns_req *ct_req;\r\nstruct ct_sns_rsp *ct_rsp;\r\nif (IS_QLA2100(ha) || IS_QLA2200(ha)) {\r\nql_dbg(ql_dbg_disc, vha, 0x2050,\r\n"RSNN_ID call unsupported on ISP2100/ISP2200.\n");\r\nreturn (QLA_SUCCESS);\r\n}\r\nms_pkt = ha->isp_ops->prep_ms_iocb(vha, 0, RSNN_NN_RSP_SIZE);\r\nct_req = qla2x00_prep_ct_req(ha->ct_sns, RSNN_NN_CMD,\r\nRSNN_NN_RSP_SIZE);\r\nct_rsp = &ha->ct_sns->p.rsp;\r\nmemcpy(ct_req->req.rsnn_nn.node_name, vha->node_name, WWN_SIZE);\r\nqla2x00_get_sym_node_name(vha, ct_req->req.rsnn_nn.sym_node_name,\r\nsizeof(ct_req->req.rsnn_nn.sym_node_name));\r\nct_req->req.rsnn_nn.name_len =\r\n(uint8_t)strlen(ct_req->req.rsnn_nn.sym_node_name);\r\nms_pkt->req_bytecount =\r\ncpu_to_le32(24 + 1 + ct_req->req.rsnn_nn.name_len);\r\nms_pkt->dseg_req_length = ms_pkt->req_bytecount;\r\nrval = qla2x00_issue_iocb(vha, ha->ms_iocb, ha->ms_iocb_dma,\r\nsizeof(ms_iocb_entry_t));\r\nif (rval != QLA_SUCCESS) {\r\nql_dbg(ql_dbg_disc, vha, 0x2051,\r\n"RSNN_NN issue IOCB failed (%d).\n", rval);\r\n} else if (qla2x00_chk_ms_status(vha, ms_pkt, ct_rsp, "RSNN_NN") !=\r\nQLA_SUCCESS) {\r\nrval = QLA_FUNCTION_FAILED;\r\n} else {\r\nql_dbg(ql_dbg_disc, vha, 0x2052,\r\n"RSNN_NN exiting normally.\n");\r\n}\r\nreturn (rval);\r\n}\r\nstatic inline struct sns_cmd_pkt *\r\nqla2x00_prep_sns_cmd(scsi_qla_host_t *vha, uint16_t cmd, uint16_t scmd_len,\r\nuint16_t data_size)\r\n{\r\nuint16_t wc;\r\nstruct sns_cmd_pkt *sns_cmd;\r\nstruct qla_hw_data *ha = vha->hw;\r\nsns_cmd = ha->sns_cmd;\r\nmemset(sns_cmd, 0, sizeof(struct sns_cmd_pkt));\r\nwc = data_size / 2;\r\nsns_cmd->p.cmd.buffer_length = cpu_to_le16(wc);\r\nsns_cmd->p.cmd.buffer_address[0] = cpu_to_le32(LSD(ha->sns_cmd_dma));\r\nsns_cmd->p.cmd.buffer_address[1] = cpu_to_le32(MSD(ha->sns_cmd_dma));\r\nsns_cmd->p.cmd.subcommand_length = cpu_to_le16(scmd_len);\r\nsns_cmd->p.cmd.subcommand = cpu_to_le16(cmd);\r\nwc = (data_size - 16) / 4;\r\nsns_cmd->p.cmd.size = cpu_to_le16(wc);\r\nvha->qla_stats.control_requests++;\r\nreturn (sns_cmd);\r\n}\r\nstatic int\r\nqla2x00_sns_ga_nxt(scsi_qla_host_t *vha, fc_port_t *fcport)\r\n{\r\nint rval = QLA_SUCCESS;\r\nstruct qla_hw_data *ha = vha->hw;\r\nstruct sns_cmd_pkt *sns_cmd;\r\nsns_cmd = qla2x00_prep_sns_cmd(vha, GA_NXT_CMD, GA_NXT_SNS_SCMD_LEN,\r\nGA_NXT_SNS_DATA_SIZE);\r\nsns_cmd->p.cmd.param[0] = fcport->d_id.b.al_pa;\r\nsns_cmd->p.cmd.param[1] = fcport->d_id.b.area;\r\nsns_cmd->p.cmd.param[2] = fcport->d_id.b.domain;\r\nrval = qla2x00_send_sns(vha, ha->sns_cmd_dma, GA_NXT_SNS_CMD_SIZE / 2,\r\nsizeof(struct sns_cmd_pkt));\r\nif (rval != QLA_SUCCESS) {\r\nql_dbg(ql_dbg_disc, vha, 0x205f,\r\n"GA_NXT Send SNS failed (%d).\n", rval);\r\n} else if (sns_cmd->p.gan_data[8] != 0x80 ||\r\nsns_cmd->p.gan_data[9] != 0x02) {\r\nql_dbg(ql_dbg_disc + ql_dbg_buffer, vha, 0x2084,\r\n"GA_NXT failed, rejected request ga_nxt_rsp:\n");\r\nql_dump_buffer(ql_dbg_disc + ql_dbg_buffer, vha, 0x2074,\r\nsns_cmd->p.gan_data, 16);\r\nrval = QLA_FUNCTION_FAILED;\r\n} else {\r\nfcport->d_id.b.domain = sns_cmd->p.gan_data[17];\r\nfcport->d_id.b.area = sns_cmd->p.gan_data[18];\r\nfcport->d_id.b.al_pa = sns_cmd->p.gan_data[19];\r\nmemcpy(fcport->node_name, &sns_cmd->p.gan_data[284], WWN_SIZE);\r\nmemcpy(fcport->port_name, &sns_cmd->p.gan_data[20], WWN_SIZE);\r\nif (sns_cmd->p.gan_data[16] != NS_N_PORT_TYPE &&\r\nsns_cmd->p.gan_data[16] != NS_NL_PORT_TYPE)\r\nfcport->d_id.b.domain = 0xf0;\r\nql_dbg(ql_dbg_disc, vha, 0x2061,\r\n"GA_NXT entry - nn %8phN pn %8phN "\r\n"port_id=%02x%02x%02x.\n",\r\nfcport->node_name, fcport->port_name,\r\nfcport->d_id.b.domain, fcport->d_id.b.area,\r\nfcport->d_id.b.al_pa);\r\n}\r\nreturn (rval);\r\n}\r\nstatic int\r\nqla2x00_sns_gid_pt(scsi_qla_host_t *vha, sw_info_t *list)\r\n{\r\nint rval;\r\nstruct qla_hw_data *ha = vha->hw;\r\nuint16_t i;\r\nuint8_t *entry;\r\nstruct sns_cmd_pkt *sns_cmd;\r\nuint16_t gid_pt_sns_data_size;\r\ngid_pt_sns_data_size = qla2x00_gid_pt_rsp_size(vha);\r\nsns_cmd = qla2x00_prep_sns_cmd(vha, GID_PT_CMD, GID_PT_SNS_SCMD_LEN,\r\ngid_pt_sns_data_size);\r\nsns_cmd->p.cmd.param[0] = NS_NX_PORT_TYPE;\r\nrval = qla2x00_send_sns(vha, ha->sns_cmd_dma, GID_PT_SNS_CMD_SIZE / 2,\r\nsizeof(struct sns_cmd_pkt));\r\nif (rval != QLA_SUCCESS) {\r\nql_dbg(ql_dbg_disc, vha, 0x206d,\r\n"GID_PT Send SNS failed (%d).\n", rval);\r\n} else if (sns_cmd->p.gid_data[8] != 0x80 ||\r\nsns_cmd->p.gid_data[9] != 0x02) {\r\nql_dbg(ql_dbg_disc, vha, 0x202f,\r\n"GID_PT failed, rejected request, gid_rsp:\n");\r\nql_dump_buffer(ql_dbg_disc + ql_dbg_buffer, vha, 0x2081,\r\nsns_cmd->p.gid_data, 16);\r\nrval = QLA_FUNCTION_FAILED;\r\n} else {\r\nfor (i = 0; i < ha->max_fibre_devices; i++) {\r\nentry = &sns_cmd->p.gid_data[(i * 4) + 16];\r\nlist[i].d_id.b.domain = entry[1];\r\nlist[i].d_id.b.area = entry[2];\r\nlist[i].d_id.b.al_pa = entry[3];\r\nif (entry[0] & BIT_7) {\r\nlist[i].d_id.b.rsvd_1 = entry[0];\r\nbreak;\r\n}\r\n}\r\nif (i == ha->max_fibre_devices)\r\nrval = QLA_FUNCTION_FAILED;\r\n}\r\nreturn (rval);\r\n}\r\nstatic int\r\nqla2x00_sns_gpn_id(scsi_qla_host_t *vha, sw_info_t *list)\r\n{\r\nint rval = QLA_SUCCESS;\r\nstruct qla_hw_data *ha = vha->hw;\r\nuint16_t i;\r\nstruct sns_cmd_pkt *sns_cmd;\r\nfor (i = 0; i < ha->max_fibre_devices; i++) {\r\nsns_cmd = qla2x00_prep_sns_cmd(vha, GPN_ID_CMD,\r\nGPN_ID_SNS_SCMD_LEN, GPN_ID_SNS_DATA_SIZE);\r\nsns_cmd->p.cmd.param[0] = list[i].d_id.b.al_pa;\r\nsns_cmd->p.cmd.param[1] = list[i].d_id.b.area;\r\nsns_cmd->p.cmd.param[2] = list[i].d_id.b.domain;\r\nrval = qla2x00_send_sns(vha, ha->sns_cmd_dma,\r\nGPN_ID_SNS_CMD_SIZE / 2, sizeof(struct sns_cmd_pkt));\r\nif (rval != QLA_SUCCESS) {\r\nql_dbg(ql_dbg_disc, vha, 0x2032,\r\n"GPN_ID Send SNS failed (%d).\n", rval);\r\n} else if (sns_cmd->p.gpn_data[8] != 0x80 ||\r\nsns_cmd->p.gpn_data[9] != 0x02) {\r\nql_dbg(ql_dbg_disc + ql_dbg_buffer, vha, 0x207e,\r\n"GPN_ID failed, rejected request, gpn_rsp:\n");\r\nql_dump_buffer(ql_dbg_disc + ql_dbg_buffer, vha, 0x207f,\r\nsns_cmd->p.gpn_data, 16);\r\nrval = QLA_FUNCTION_FAILED;\r\n} else {\r\nmemcpy(list[i].port_name, &sns_cmd->p.gpn_data[16],\r\nWWN_SIZE);\r\n}\r\nif (list[i].d_id.b.rsvd_1 != 0)\r\nbreak;\r\n}\r\nreturn (rval);\r\n}\r\nstatic int\r\nqla2x00_sns_gnn_id(scsi_qla_host_t *vha, sw_info_t *list)\r\n{\r\nint rval = QLA_SUCCESS;\r\nstruct qla_hw_data *ha = vha->hw;\r\nuint16_t i;\r\nstruct sns_cmd_pkt *sns_cmd;\r\nfor (i = 0; i < ha->max_fibre_devices; i++) {\r\nsns_cmd = qla2x00_prep_sns_cmd(vha, GNN_ID_CMD,\r\nGNN_ID_SNS_SCMD_LEN, GNN_ID_SNS_DATA_SIZE);\r\nsns_cmd->p.cmd.param[0] = list[i].d_id.b.al_pa;\r\nsns_cmd->p.cmd.param[1] = list[i].d_id.b.area;\r\nsns_cmd->p.cmd.param[2] = list[i].d_id.b.domain;\r\nrval = qla2x00_send_sns(vha, ha->sns_cmd_dma,\r\nGNN_ID_SNS_CMD_SIZE / 2, sizeof(struct sns_cmd_pkt));\r\nif (rval != QLA_SUCCESS) {\r\nql_dbg(ql_dbg_disc, vha, 0x203f,\r\n"GNN_ID Send SNS failed (%d).\n", rval);\r\n} else if (sns_cmd->p.gnn_data[8] != 0x80 ||\r\nsns_cmd->p.gnn_data[9] != 0x02) {\r\nql_dbg(ql_dbg_disc + ql_dbg_buffer, vha, 0x2082,\r\n"GNN_ID failed, rejected request, gnn_rsp:\n");\r\nql_dump_buffer(ql_dbg_disc + ql_dbg_buffer, vha, 0x207a,\r\nsns_cmd->p.gnn_data, 16);\r\nrval = QLA_FUNCTION_FAILED;\r\n} else {\r\nmemcpy(list[i].node_name, &sns_cmd->p.gnn_data[16],\r\nWWN_SIZE);\r\nql_dbg(ql_dbg_disc, vha, 0x206e,\r\n"GID_PT entry - nn %8phN pn %8phN "\r\n"port_id=%02x%02x%02x.\n",\r\nlist[i].node_name, list[i].port_name,\r\nlist[i].d_id.b.domain, list[i].d_id.b.area,\r\nlist[i].d_id.b.al_pa);\r\n}\r\nif (list[i].d_id.b.rsvd_1 != 0)\r\nbreak;\r\n}\r\nreturn (rval);\r\n}\r\nstatic int\r\nqla2x00_sns_rft_id(scsi_qla_host_t *vha)\r\n{\r\nint rval;\r\nstruct qla_hw_data *ha = vha->hw;\r\nstruct sns_cmd_pkt *sns_cmd;\r\nsns_cmd = qla2x00_prep_sns_cmd(vha, RFT_ID_CMD, RFT_ID_SNS_SCMD_LEN,\r\nRFT_ID_SNS_DATA_SIZE);\r\nsns_cmd->p.cmd.param[0] = vha->d_id.b.al_pa;\r\nsns_cmd->p.cmd.param[1] = vha->d_id.b.area;\r\nsns_cmd->p.cmd.param[2] = vha->d_id.b.domain;\r\nsns_cmd->p.cmd.param[5] = 0x01;\r\nrval = qla2x00_send_sns(vha, ha->sns_cmd_dma, RFT_ID_SNS_CMD_SIZE / 2,\r\nsizeof(struct sns_cmd_pkt));\r\nif (rval != QLA_SUCCESS) {\r\nql_dbg(ql_dbg_disc, vha, 0x2060,\r\n"RFT_ID Send SNS failed (%d).\n", rval);\r\n} else if (sns_cmd->p.rft_data[8] != 0x80 ||\r\nsns_cmd->p.rft_data[9] != 0x02) {\r\nql_dbg(ql_dbg_disc + ql_dbg_buffer, vha, 0x2083,\r\n"RFT_ID failed, rejected request rft_rsp:\n");\r\nql_dump_buffer(ql_dbg_disc + ql_dbg_buffer, vha, 0x2080,\r\nsns_cmd->p.rft_data, 16);\r\nrval = QLA_FUNCTION_FAILED;\r\n} else {\r\nql_dbg(ql_dbg_disc, vha, 0x2073,\r\n"RFT_ID exiting normally.\n");\r\n}\r\nreturn (rval);\r\n}\r\nstatic int\r\nqla2x00_sns_rnn_id(scsi_qla_host_t *vha)\r\n{\r\nint rval;\r\nstruct qla_hw_data *ha = vha->hw;\r\nstruct sns_cmd_pkt *sns_cmd;\r\nsns_cmd = qla2x00_prep_sns_cmd(vha, RNN_ID_CMD, RNN_ID_SNS_SCMD_LEN,\r\nRNN_ID_SNS_DATA_SIZE);\r\nsns_cmd->p.cmd.param[0] = vha->d_id.b.al_pa;\r\nsns_cmd->p.cmd.param[1] = vha->d_id.b.area;\r\nsns_cmd->p.cmd.param[2] = vha->d_id.b.domain;\r\nsns_cmd->p.cmd.param[4] = vha->node_name[7];\r\nsns_cmd->p.cmd.param[5] = vha->node_name[6];\r\nsns_cmd->p.cmd.param[6] = vha->node_name[5];\r\nsns_cmd->p.cmd.param[7] = vha->node_name[4];\r\nsns_cmd->p.cmd.param[8] = vha->node_name[3];\r\nsns_cmd->p.cmd.param[9] = vha->node_name[2];\r\nsns_cmd->p.cmd.param[10] = vha->node_name[1];\r\nsns_cmd->p.cmd.param[11] = vha->node_name[0];\r\nrval = qla2x00_send_sns(vha, ha->sns_cmd_dma, RNN_ID_SNS_CMD_SIZE / 2,\r\nsizeof(struct sns_cmd_pkt));\r\nif (rval != QLA_SUCCESS) {\r\nql_dbg(ql_dbg_disc, vha, 0x204a,\r\n"RNN_ID Send SNS failed (%d).\n", rval);\r\n} else if (sns_cmd->p.rnn_data[8] != 0x80 ||\r\nsns_cmd->p.rnn_data[9] != 0x02) {\r\nql_dbg(ql_dbg_disc + ql_dbg_buffer, vha, 0x207b,\r\n"RNN_ID failed, rejected request, rnn_rsp:\n");\r\nql_dump_buffer(ql_dbg_disc + ql_dbg_buffer, vha, 0x207c,\r\nsns_cmd->p.rnn_data, 16);\r\nrval = QLA_FUNCTION_FAILED;\r\n} else {\r\nql_dbg(ql_dbg_disc, vha, 0x204c,\r\n"RNN_ID exiting normally.\n");\r\n}\r\nreturn (rval);\r\n}\r\nstatic int\r\nqla2x00_mgmt_svr_login(scsi_qla_host_t *vha)\r\n{\r\nint ret, rval;\r\nuint16_t mb[MAILBOX_REGISTER_COUNT];\r\nstruct qla_hw_data *ha = vha->hw;\r\nret = QLA_SUCCESS;\r\nif (vha->flags.management_server_logged_in)\r\nreturn ret;\r\nrval = ha->isp_ops->fabric_login(vha, vha->mgmt_svr_loop_id, 0xff, 0xff,\r\n0xfa, mb, BIT_1);\r\nif (rval != QLA_SUCCESS || mb[0] != MBS_COMMAND_COMPLETE) {\r\nif (rval == QLA_MEMORY_ALLOC_FAILED)\r\nql_dbg(ql_dbg_disc, vha, 0x2085,\r\n"Failed management_server login: loopid=%x "\r\n"rval=%d\n", vha->mgmt_svr_loop_id, rval);\r\nelse\r\nql_dbg(ql_dbg_disc, vha, 0x2024,\r\n"Failed management_server login: loopid=%x "\r\n"mb[0]=%x mb[1]=%x mb[2]=%x mb[6]=%x mb[7]=%x.\n",\r\nvha->mgmt_svr_loop_id, mb[0], mb[1], mb[2], mb[6],\r\nmb[7]);\r\nret = QLA_FUNCTION_FAILED;\r\n} else\r\nvha->flags.management_server_logged_in = 1;\r\nreturn ret;\r\n}\r\nvoid *\r\nqla2x00_prep_ms_fdmi_iocb(scsi_qla_host_t *vha, uint32_t req_size,\r\nuint32_t rsp_size)\r\n{\r\nms_iocb_entry_t *ms_pkt;\r\nstruct qla_hw_data *ha = vha->hw;\r\nms_pkt = ha->ms_iocb;\r\nmemset(ms_pkt, 0, sizeof(ms_iocb_entry_t));\r\nms_pkt->entry_type = MS_IOCB_TYPE;\r\nms_pkt->entry_count = 1;\r\nSET_TARGET_ID(ha, ms_pkt->loop_id, vha->mgmt_svr_loop_id);\r\nms_pkt->control_flags = cpu_to_le16(CF_READ | CF_HEAD_TAG);\r\nms_pkt->timeout = cpu_to_le16(ha->r_a_tov / 10 * 2);\r\nms_pkt->cmd_dsd_count = cpu_to_le16(1);\r\nms_pkt->total_dsd_count = cpu_to_le16(2);\r\nms_pkt->rsp_bytecount = cpu_to_le32(rsp_size);\r\nms_pkt->req_bytecount = cpu_to_le32(req_size);\r\nms_pkt->dseg_req_address[0] = cpu_to_le32(LSD(ha->ct_sns_dma));\r\nms_pkt->dseg_req_address[1] = cpu_to_le32(MSD(ha->ct_sns_dma));\r\nms_pkt->dseg_req_length = ms_pkt->req_bytecount;\r\nms_pkt->dseg_rsp_address[0] = cpu_to_le32(LSD(ha->ct_sns_dma));\r\nms_pkt->dseg_rsp_address[1] = cpu_to_le32(MSD(ha->ct_sns_dma));\r\nms_pkt->dseg_rsp_length = ms_pkt->rsp_bytecount;\r\nreturn ms_pkt;\r\n}\r\nvoid *\r\nqla24xx_prep_ms_fdmi_iocb(scsi_qla_host_t *vha, uint32_t req_size,\r\nuint32_t rsp_size)\r\n{\r\nstruct ct_entry_24xx *ct_pkt;\r\nstruct qla_hw_data *ha = vha->hw;\r\nct_pkt = (struct ct_entry_24xx *)ha->ms_iocb;\r\nmemset(ct_pkt, 0, sizeof(struct ct_entry_24xx));\r\nct_pkt->entry_type = CT_IOCB_TYPE;\r\nct_pkt->entry_count = 1;\r\nct_pkt->nport_handle = cpu_to_le16(vha->mgmt_svr_loop_id);\r\nct_pkt->timeout = cpu_to_le16(ha->r_a_tov / 10 * 2);\r\nct_pkt->cmd_dsd_count = cpu_to_le16(1);\r\nct_pkt->rsp_dsd_count = cpu_to_le16(1);\r\nct_pkt->rsp_byte_count = cpu_to_le32(rsp_size);\r\nct_pkt->cmd_byte_count = cpu_to_le32(req_size);\r\nct_pkt->dseg_0_address[0] = cpu_to_le32(LSD(ha->ct_sns_dma));\r\nct_pkt->dseg_0_address[1] = cpu_to_le32(MSD(ha->ct_sns_dma));\r\nct_pkt->dseg_0_len = ct_pkt->cmd_byte_count;\r\nct_pkt->dseg_1_address[0] = cpu_to_le32(LSD(ha->ct_sns_dma));\r\nct_pkt->dseg_1_address[1] = cpu_to_le32(MSD(ha->ct_sns_dma));\r\nct_pkt->dseg_1_len = ct_pkt->rsp_byte_count;\r\nct_pkt->vp_index = vha->vp_idx;\r\nreturn ct_pkt;\r\n}\r\nstatic inline ms_iocb_entry_t *\r\nqla2x00_update_ms_fdmi_iocb(scsi_qla_host_t *vha, uint32_t req_size)\r\n{\r\nstruct qla_hw_data *ha = vha->hw;\r\nms_iocb_entry_t *ms_pkt = ha->ms_iocb;\r\nstruct ct_entry_24xx *ct_pkt = (struct ct_entry_24xx *)ha->ms_iocb;\r\nif (IS_FWI2_CAPABLE(ha)) {\r\nct_pkt->cmd_byte_count = cpu_to_le32(req_size);\r\nct_pkt->dseg_0_len = ct_pkt->cmd_byte_count;\r\n} else {\r\nms_pkt->req_bytecount = cpu_to_le32(req_size);\r\nms_pkt->dseg_req_length = ms_pkt->req_bytecount;\r\n}\r\nreturn ms_pkt;\r\n}\r\nstatic inline struct ct_sns_req *\r\nqla2x00_prep_ct_fdmi_req(struct ct_sns_pkt *p, uint16_t cmd,\r\nuint16_t rsp_size)\r\n{\r\nmemset(p, 0, sizeof(struct ct_sns_pkt));\r\np->p.req.header.revision = 0x01;\r\np->p.req.header.gs_type = 0xFA;\r\np->p.req.header.gs_subtype = 0x10;\r\np->p.req.command = cpu_to_be16(cmd);\r\np->p.req.max_rsp_size = cpu_to_be16((rsp_size - 16) / 4);\r\nreturn &p->p.req;\r\n}\r\nstatic int\r\nqla2x00_fdmi_rhba(scsi_qla_host_t *vha)\r\n{\r\nint rval, alen;\r\nuint32_t size, sn;\r\nms_iocb_entry_t *ms_pkt;\r\nstruct ct_sns_req *ct_req;\r\nstruct ct_sns_rsp *ct_rsp;\r\nvoid *entries;\r\nstruct ct_fdmi_hba_attr *eiter;\r\nstruct qla_hw_data *ha = vha->hw;\r\nms_pkt = ha->isp_ops->prep_ms_fdmi_iocb(vha, 0, RHBA_RSP_SIZE);\r\nct_req = qla2x00_prep_ct_fdmi_req(ha->ct_sns, RHBA_CMD, RHBA_RSP_SIZE);\r\nct_rsp = &ha->ct_sns->p.rsp;\r\nmemcpy(ct_req->req.rhba.hba_identifier, vha->port_name, WWN_SIZE);\r\nct_req->req.rhba.entry_count = cpu_to_be32(1);\r\nmemcpy(ct_req->req.rhba.port_name, vha->port_name, WWN_SIZE);\r\nsize = 2 * WWN_SIZE + 4 + 4;\r\nct_req->req.rhba.attrs.count =\r\ncpu_to_be32(FDMI_HBA_ATTR_COUNT);\r\nentries = ct_req->req.rhba.hba_identifier;\r\neiter = entries + size;\r\neiter->type = cpu_to_be16(FDMI_HBA_NODE_NAME);\r\neiter->len = cpu_to_be16(4 + WWN_SIZE);\r\nmemcpy(eiter->a.node_name, vha->node_name, WWN_SIZE);\r\nsize += 4 + WWN_SIZE;\r\nql_dbg(ql_dbg_disc, vha, 0x2025,\r\n"NodeName = %8phN.\n", eiter->a.node_name);\r\neiter = entries + size;\r\neiter->type = cpu_to_be16(FDMI_HBA_MANUFACTURER);\r\nalen = strlen(QLA2XXX_MANUFACTURER);\r\nsnprintf(eiter->a.manufacturer, sizeof(eiter->a.manufacturer),\r\n"%s", "QLogic Corporation");\r\nalen += 4 - (alen & 3);\r\neiter->len = cpu_to_be16(4 + alen);\r\nsize += 4 + alen;\r\nql_dbg(ql_dbg_disc, vha, 0x2026,\r\n"Manufacturer = %s.\n", eiter->a.manufacturer);\r\neiter = entries + size;\r\neiter->type = cpu_to_be16(FDMI_HBA_SERIAL_NUMBER);\r\nif (IS_FWI2_CAPABLE(ha))\r\nqla2xxx_get_vpd_field(vha, "SN", eiter->a.serial_num,\r\nsizeof(eiter->a.serial_num));\r\nelse {\r\nsn = ((ha->serial0 & 0x1f) << 16) |\r\n(ha->serial2 << 8) | ha->serial1;\r\nsnprintf(eiter->a.serial_num, sizeof(eiter->a.serial_num),\r\n"%c%05d", 'A' + sn / 100000, sn % 100000);\r\n}\r\nalen = strlen(eiter->a.serial_num);\r\nalen += 4 - (alen & 3);\r\neiter->len = cpu_to_be16(4 + alen);\r\nsize += 4 + alen;\r\nql_dbg(ql_dbg_disc, vha, 0x2027,\r\n"Serial no. = %s.\n", eiter->a.serial_num);\r\neiter = entries + size;\r\neiter->type = cpu_to_be16(FDMI_HBA_MODEL);\r\nsnprintf(eiter->a.model, sizeof(eiter->a.model),\r\n"%s", ha->model_number);\r\nalen = strlen(eiter->a.model);\r\nalen += 4 - (alen & 3);\r\neiter->len = cpu_to_be16(4 + alen);\r\nsize += 4 + alen;\r\nql_dbg(ql_dbg_disc, vha, 0x2028,\r\n"Model Name = %s.\n", eiter->a.model);\r\neiter = entries + size;\r\neiter->type = cpu_to_be16(FDMI_HBA_MODEL_DESCRIPTION);\r\nsnprintf(eiter->a.model_desc, sizeof(eiter->a.model_desc),\r\n"%s", ha->model_desc);\r\nalen = strlen(eiter->a.model_desc);\r\nalen += 4 - (alen & 3);\r\neiter->len = cpu_to_be16(4 + alen);\r\nsize += 4 + alen;\r\nql_dbg(ql_dbg_disc, vha, 0x2029,\r\n"Model Desc = %s.\n", eiter->a.model_desc);\r\neiter = entries + size;\r\neiter->type = cpu_to_be16(FDMI_HBA_HARDWARE_VERSION);\r\nif (!IS_FWI2_CAPABLE(ha)) {\r\nsnprintf(eiter->a.hw_version, sizeof(eiter->a.hw_version),\r\n"HW:%s", ha->adapter_id);\r\n} else if (qla2xxx_get_vpd_field(vha, "MN", eiter->a.hw_version,\r\nsizeof(eiter->a.hw_version))) {\r\n;\r\n} else if (qla2xxx_get_vpd_field(vha, "EC", eiter->a.hw_version,\r\nsizeof(eiter->a.hw_version))) {\r\n;\r\n} else {\r\nsnprintf(eiter->a.hw_version, sizeof(eiter->a.hw_version),\r\n"HW:%s", ha->adapter_id);\r\n}\r\nalen = strlen(eiter->a.hw_version);\r\nalen += 4 - (alen & 3);\r\neiter->len = cpu_to_be16(4 + alen);\r\nsize += 4 + alen;\r\nql_dbg(ql_dbg_disc, vha, 0x202a,\r\n"Hardware ver = %s.\n", eiter->a.hw_version);\r\neiter = entries + size;\r\neiter->type = cpu_to_be16(FDMI_HBA_DRIVER_VERSION);\r\nsnprintf(eiter->a.driver_version, sizeof(eiter->a.driver_version),\r\n"%s", qla2x00_version_str);\r\nalen = strlen(eiter->a.driver_version);\r\nalen += 4 - (alen & 3);\r\neiter->len = cpu_to_be16(4 + alen);\r\nsize += 4 + alen;\r\nql_dbg(ql_dbg_disc, vha, 0x202b,\r\n"Driver ver = %s.\n", eiter->a.driver_version);\r\neiter = entries + size;\r\neiter->type = cpu_to_be16(FDMI_HBA_OPTION_ROM_VERSION);\r\nsnprintf(eiter->a.orom_version, sizeof(eiter->a.orom_version),\r\n"%d.%02d", ha->bios_revision[1], ha->bios_revision[0]);\r\nalen = strlen(eiter->a.orom_version);\r\nalen += 4 - (alen & 3);\r\neiter->len = cpu_to_be16(4 + alen);\r\nsize += 4 + alen;\r\nql_dbg(ql_dbg_disc, vha , 0x202c,\r\n"Optrom vers = %s.\n", eiter->a.orom_version);\r\neiter = entries + size;\r\neiter->type = cpu_to_be16(FDMI_HBA_FIRMWARE_VERSION);\r\nha->isp_ops->fw_version_str(vha, eiter->a.fw_version,\r\nsizeof(eiter->a.fw_version));\r\nalen = strlen(eiter->a.fw_version);\r\nalen += 4 - (alen & 3);\r\neiter->len = cpu_to_be16(4 + alen);\r\nsize += 4 + alen;\r\nql_dbg(ql_dbg_disc, vha, 0x202d,\r\n"Firmware vers = %s.\n", eiter->a.fw_version);\r\nqla2x00_update_ms_fdmi_iocb(vha, size + 16);\r\nql_dbg(ql_dbg_disc, vha, 0x202e,\r\n"RHBA identifier = %8phN size=%d.\n",\r\nct_req->req.rhba.hba_identifier, size);\r\nql_dump_buffer(ql_dbg_disc + ql_dbg_buffer, vha, 0x2076,\r\nentries, size);\r\nrval = qla2x00_issue_iocb(vha, ha->ms_iocb, ha->ms_iocb_dma,\r\nsizeof(ms_iocb_entry_t));\r\nif (rval != QLA_SUCCESS) {\r\nql_dbg(ql_dbg_disc, vha, 0x2030,\r\n"RHBA issue IOCB failed (%d).\n", rval);\r\n} else if (qla2x00_chk_ms_status(vha, ms_pkt, ct_rsp, "RHBA") !=\r\nQLA_SUCCESS) {\r\nrval = QLA_FUNCTION_FAILED;\r\nif (ct_rsp->header.reason_code == CT_REASON_CANNOT_PERFORM &&\r\nct_rsp->header.explanation_code ==\r\nCT_EXPL_ALREADY_REGISTERED) {\r\nql_dbg(ql_dbg_disc, vha, 0x2034,\r\n"HBA already registered.\n");\r\nrval = QLA_ALREADY_REGISTERED;\r\n} else {\r\nql_dbg(ql_dbg_disc, vha, 0x20ad,\r\n"RHBA FDMI registration failed, CT Reason code: 0x%x, CT Explanation 0x%x\n",\r\nct_rsp->header.reason_code,\r\nct_rsp->header.explanation_code);\r\n}\r\n} else {\r\nql_dbg(ql_dbg_disc, vha, 0x2035,\r\n"RHBA exiting normally.\n");\r\n}\r\nreturn rval;\r\n}\r\nstatic int\r\nqla2x00_fdmi_rpa(scsi_qla_host_t *vha)\r\n{\r\nint rval, alen;\r\nuint32_t size;\r\nstruct qla_hw_data *ha = vha->hw;\r\nms_iocb_entry_t *ms_pkt;\r\nstruct ct_sns_req *ct_req;\r\nstruct ct_sns_rsp *ct_rsp;\r\nvoid *entries;\r\nstruct ct_fdmi_port_attr *eiter;\r\nstruct init_cb_24xx *icb24 = (struct init_cb_24xx *)ha->init_cb;\r\nstruct new_utsname *p_sysid = NULL;\r\nms_pkt = ha->isp_ops->prep_ms_fdmi_iocb(vha, 0, RPA_RSP_SIZE);\r\nct_req = qla2x00_prep_ct_fdmi_req(ha->ct_sns, RPA_CMD,\r\nRPA_RSP_SIZE);\r\nct_rsp = &ha->ct_sns->p.rsp;\r\nmemcpy(ct_req->req.rpa.port_name, vha->port_name, WWN_SIZE);\r\nsize = WWN_SIZE + 4;\r\nct_req->req.rpa.attrs.count = cpu_to_be32(FDMI_PORT_ATTR_COUNT);\r\nentries = ct_req->req.rpa.port_name;\r\neiter = entries + size;\r\neiter->type = cpu_to_be16(FDMI_PORT_FC4_TYPES);\r\neiter->len = cpu_to_be16(4 + 32);\r\neiter->a.fc4_types[2] = 0x01;\r\nsize += 4 + 32;\r\nql_dbg(ql_dbg_disc, vha, 0x2039,\r\n"FC4_TYPES=%02x %02x.\n",\r\neiter->a.fc4_types[2],\r\neiter->a.fc4_types[1]);\r\neiter = entries + size;\r\neiter->type = cpu_to_be16(FDMI_PORT_SUPPORT_SPEED);\r\neiter->len = cpu_to_be16(4 + 4);\r\nif (IS_CNA_CAPABLE(ha))\r\neiter->a.sup_speed = cpu_to_be32(\r\nFDMI_PORT_SPEED_10GB);\r\nelse if (IS_QLA27XX(ha))\r\neiter->a.sup_speed = cpu_to_be32(\r\nFDMI_PORT_SPEED_32GB|\r\nFDMI_PORT_SPEED_16GB|\r\nFDMI_PORT_SPEED_8GB);\r\nelse if (IS_QLA2031(ha))\r\neiter->a.sup_speed = cpu_to_be32(\r\nFDMI_PORT_SPEED_16GB|\r\nFDMI_PORT_SPEED_8GB|\r\nFDMI_PORT_SPEED_4GB);\r\nelse if (IS_QLA25XX(ha))\r\neiter->a.sup_speed = cpu_to_be32(\r\nFDMI_PORT_SPEED_8GB|\r\nFDMI_PORT_SPEED_4GB|\r\nFDMI_PORT_SPEED_2GB|\r\nFDMI_PORT_SPEED_1GB);\r\nelse if (IS_QLA24XX_TYPE(ha))\r\neiter->a.sup_speed = cpu_to_be32(\r\nFDMI_PORT_SPEED_4GB|\r\nFDMI_PORT_SPEED_2GB|\r\nFDMI_PORT_SPEED_1GB);\r\nelse if (IS_QLA23XX(ha))\r\neiter->a.sup_speed = cpu_to_be32(\r\nFDMI_PORT_SPEED_2GB|\r\nFDMI_PORT_SPEED_1GB);\r\nelse\r\neiter->a.sup_speed = cpu_to_be32(\r\nFDMI_PORT_SPEED_1GB);\r\nsize += 4 + 4;\r\nql_dbg(ql_dbg_disc, vha, 0x203a,\r\n"Supported_Speed=%x.\n", eiter->a.sup_speed);\r\neiter = entries + size;\r\neiter->type = cpu_to_be16(FDMI_PORT_CURRENT_SPEED);\r\neiter->len = cpu_to_be16(4 + 4);\r\nswitch (ha->link_data_rate) {\r\ncase PORT_SPEED_1GB:\r\neiter->a.cur_speed =\r\ncpu_to_be32(FDMI_PORT_SPEED_1GB);\r\nbreak;\r\ncase PORT_SPEED_2GB:\r\neiter->a.cur_speed =\r\ncpu_to_be32(FDMI_PORT_SPEED_2GB);\r\nbreak;\r\ncase PORT_SPEED_4GB:\r\neiter->a.cur_speed =\r\ncpu_to_be32(FDMI_PORT_SPEED_4GB);\r\nbreak;\r\ncase PORT_SPEED_8GB:\r\neiter->a.cur_speed =\r\ncpu_to_be32(FDMI_PORT_SPEED_8GB);\r\nbreak;\r\ncase PORT_SPEED_10GB:\r\neiter->a.cur_speed =\r\ncpu_to_be32(FDMI_PORT_SPEED_10GB);\r\nbreak;\r\ncase PORT_SPEED_16GB:\r\neiter->a.cur_speed =\r\ncpu_to_be32(FDMI_PORT_SPEED_16GB);\r\nbreak;\r\ncase PORT_SPEED_32GB:\r\neiter->a.cur_speed =\r\ncpu_to_be32(FDMI_PORT_SPEED_32GB);\r\nbreak;\r\ndefault:\r\neiter->a.cur_speed =\r\ncpu_to_be32(FDMI_PORT_SPEED_UNKNOWN);\r\nbreak;\r\n}\r\nsize += 4 + 4;\r\nql_dbg(ql_dbg_disc, vha, 0x203b,\r\n"Current_Speed=%x.\n", eiter->a.cur_speed);\r\neiter = entries + size;\r\neiter->type = cpu_to_be16(FDMI_PORT_MAX_FRAME_SIZE);\r\neiter->len = cpu_to_be16(4 + 4);\r\neiter->a.max_frame_size = IS_FWI2_CAPABLE(ha) ?\r\nle16_to_cpu(icb24->frame_payload_size) :\r\nle16_to_cpu(ha->init_cb->frame_payload_size);\r\neiter->a.max_frame_size = cpu_to_be32(eiter->a.max_frame_size);\r\nsize += 4 + 4;\r\nql_dbg(ql_dbg_disc, vha, 0x203c,\r\n"Max_Frame_Size=%x.\n", eiter->a.max_frame_size);\r\neiter = entries + size;\r\neiter->type = cpu_to_be16(FDMI_PORT_OS_DEVICE_NAME);\r\nsnprintf(eiter->a.os_dev_name, sizeof(eiter->a.os_dev_name),\r\n"%s:host%lu", QLA2XXX_DRIVER_NAME, vha->host_no);\r\nalen = strlen(eiter->a.os_dev_name);\r\nalen += 4 - (alen & 3);\r\neiter->len = cpu_to_be16(4 + alen);\r\nsize += 4 + alen;\r\nql_dbg(ql_dbg_disc, vha, 0x204b,\r\n"OS_Device_Name=%s.\n", eiter->a.os_dev_name);\r\neiter = entries + size;\r\neiter->type = cpu_to_be16(FDMI_PORT_HOST_NAME);\r\np_sysid = utsname();\r\nif (p_sysid) {\r\nsnprintf(eiter->a.host_name, sizeof(eiter->a.host_name),\r\n"%s", p_sysid->nodename);\r\n} else {\r\nsnprintf(eiter->a.host_name, sizeof(eiter->a.host_name),\r\n"%s", fc_host_system_hostname(vha->host));\r\n}\r\nalen = strlen(eiter->a.host_name);\r\nalen += 4 - (alen & 3);\r\neiter->len = cpu_to_be16(4 + alen);\r\nsize += 4 + alen;\r\nql_dbg(ql_dbg_disc, vha, 0x203d, "HostName=%s.\n", eiter->a.host_name);\r\nqla2x00_update_ms_fdmi_iocb(vha, size + 16);\r\nql_dbg(ql_dbg_disc, vha, 0x203e,\r\n"RPA portname %016llx, size = %d.\n",\r\nwwn_to_u64(ct_req->req.rpa.port_name), size);\r\nql_dump_buffer(ql_dbg_disc + ql_dbg_buffer, vha, 0x2079,\r\nentries, size);\r\nrval = qla2x00_issue_iocb(vha, ha->ms_iocb, ha->ms_iocb_dma,\r\nsizeof(ms_iocb_entry_t));\r\nif (rval != QLA_SUCCESS) {\r\nql_dbg(ql_dbg_disc, vha, 0x2040,\r\n"RPA issue IOCB failed (%d).\n", rval);\r\n} else if (qla2x00_chk_ms_status(vha, ms_pkt, ct_rsp, "RPA") !=\r\nQLA_SUCCESS) {\r\nrval = QLA_FUNCTION_FAILED;\r\nif (ct_rsp->header.reason_code == CT_REASON_CANNOT_PERFORM &&\r\nct_rsp->header.explanation_code ==\r\nCT_EXPL_ALREADY_REGISTERED) {\r\nql_dbg(ql_dbg_disc, vha, 0x20cd,\r\n"RPA already registered.\n");\r\nrval = QLA_ALREADY_REGISTERED;\r\n}\r\n} else {\r\nql_dbg(ql_dbg_disc, vha, 0x2041,\r\n"RPA exiting normally.\n");\r\n}\r\nreturn rval;\r\n}\r\nstatic int\r\nqla2x00_fdmiv2_rhba(scsi_qla_host_t *vha)\r\n{\r\nint rval, alen;\r\nuint32_t size, sn;\r\nms_iocb_entry_t *ms_pkt;\r\nstruct ct_sns_req *ct_req;\r\nstruct ct_sns_rsp *ct_rsp;\r\nvoid *entries;\r\nstruct ct_fdmiv2_hba_attr *eiter;\r\nstruct qla_hw_data *ha = vha->hw;\r\nstruct init_cb_24xx *icb24 = (struct init_cb_24xx *)ha->init_cb;\r\nstruct new_utsname *p_sysid = NULL;\r\nms_pkt = ha->isp_ops->prep_ms_fdmi_iocb(vha, 0, RHBA_RSP_SIZE);\r\nct_req = qla2x00_prep_ct_fdmi_req(ha->ct_sns, RHBA_CMD,\r\nRHBA_RSP_SIZE);\r\nct_rsp = &ha->ct_sns->p.rsp;\r\nmemcpy(ct_req->req.rhba2.hba_identifier, vha->port_name, WWN_SIZE);\r\nct_req->req.rhba2.entry_count = cpu_to_be32(1);\r\nmemcpy(ct_req->req.rhba2.port_name, vha->port_name, WWN_SIZE);\r\nsize = 2 * WWN_SIZE + 4 + 4;\r\nct_req->req.rhba2.attrs.count = cpu_to_be32(FDMIV2_HBA_ATTR_COUNT);\r\nentries = ct_req->req.rhba2.hba_identifier;\r\neiter = entries + size;\r\neiter->type = cpu_to_be16(FDMI_HBA_NODE_NAME);\r\neiter->len = cpu_to_be16(4 + WWN_SIZE);\r\nmemcpy(eiter->a.node_name, vha->node_name, WWN_SIZE);\r\nsize += 4 + WWN_SIZE;\r\nql_dbg(ql_dbg_disc, vha, 0x207d,\r\n"NodeName = %016llx.\n", wwn_to_u64(eiter->a.node_name));\r\neiter = entries + size;\r\neiter->type = cpu_to_be16(FDMI_HBA_MANUFACTURER);\r\nsnprintf(eiter->a.manufacturer, sizeof(eiter->a.manufacturer),\r\n"%s", "QLogic Corporation");\r\neiter->a.manufacturer[strlen("QLogic Corporation")] = '\0';\r\nalen = strlen(eiter->a.manufacturer);\r\nalen += 4 - (alen & 3);\r\neiter->len = cpu_to_be16(4 + alen);\r\nsize += 4 + alen;\r\nql_dbg(ql_dbg_disc, vha, 0x20a5,\r\n"Manufacturer = %s.\n", eiter->a.manufacturer);\r\neiter = entries + size;\r\neiter->type = cpu_to_be16(FDMI_HBA_SERIAL_NUMBER);\r\nif (IS_FWI2_CAPABLE(ha))\r\nqla2xxx_get_vpd_field(vha, "SN", eiter->a.serial_num,\r\nsizeof(eiter->a.serial_num));\r\nelse {\r\nsn = ((ha->serial0 & 0x1f) << 16) |\r\n(ha->serial2 << 8) | ha->serial1;\r\nsnprintf(eiter->a.serial_num, sizeof(eiter->a.serial_num),\r\n"%c%05d", 'A' + sn / 100000, sn % 100000);\r\n}\r\nalen = strlen(eiter->a.serial_num);\r\nalen += 4 - (alen & 3);\r\neiter->len = cpu_to_be16(4 + alen);\r\nsize += 4 + alen;\r\nql_dbg(ql_dbg_disc, vha, 0x20a6,\r\n"Serial no. = %s.\n", eiter->a.serial_num);\r\neiter = entries + size;\r\neiter->type = cpu_to_be16(FDMI_HBA_MODEL);\r\nsnprintf(eiter->a.model, sizeof(eiter->a.model),\r\n"%s", ha->model_number);\r\nalen = strlen(eiter->a.model);\r\nalen += 4 - (alen & 3);\r\neiter->len = cpu_to_be16(4 + alen);\r\nsize += 4 + alen;\r\nql_dbg(ql_dbg_disc, vha, 0x20a7,\r\n"Model Name = %s.\n", eiter->a.model);\r\neiter = entries + size;\r\neiter->type = cpu_to_be16(FDMI_HBA_MODEL_DESCRIPTION);\r\nsnprintf(eiter->a.model_desc, sizeof(eiter->a.model_desc),\r\n"%s", ha->model_desc);\r\nalen = strlen(eiter->a.model_desc);\r\nalen += 4 - (alen & 3);\r\neiter->len = cpu_to_be16(4 + alen);\r\nsize += 4 + alen;\r\nql_dbg(ql_dbg_disc, vha, 0x20a8,\r\n"Model Desc = %s.\n", eiter->a.model_desc);\r\neiter = entries + size;\r\neiter->type = cpu_to_be16(FDMI_HBA_HARDWARE_VERSION);\r\nif (!IS_FWI2_CAPABLE(ha)) {\r\nsnprintf(eiter->a.hw_version, sizeof(eiter->a.hw_version),\r\n"HW:%s", ha->adapter_id);\r\n} else if (qla2xxx_get_vpd_field(vha, "MN", eiter->a.hw_version,\r\nsizeof(eiter->a.hw_version))) {\r\n;\r\n} else if (qla2xxx_get_vpd_field(vha, "EC", eiter->a.hw_version,\r\nsizeof(eiter->a.hw_version))) {\r\n;\r\n} else {\r\nsnprintf(eiter->a.hw_version, sizeof(eiter->a.hw_version),\r\n"HW:%s", ha->adapter_id);\r\n}\r\nalen = strlen(eiter->a.hw_version);\r\nalen += 4 - (alen & 3);\r\neiter->len = cpu_to_be16(4 + alen);\r\nsize += 4 + alen;\r\nql_dbg(ql_dbg_disc, vha, 0x20a9,\r\n"Hardware ver = %s.\n", eiter->a.hw_version);\r\neiter = entries + size;\r\neiter->type = cpu_to_be16(FDMI_HBA_DRIVER_VERSION);\r\nsnprintf(eiter->a.driver_version, sizeof(eiter->a.driver_version),\r\n"%s", qla2x00_version_str);\r\nalen = strlen(eiter->a.driver_version);\r\nalen += 4 - (alen & 3);\r\neiter->len = cpu_to_be16(4 + alen);\r\nsize += 4 + alen;\r\nql_dbg(ql_dbg_disc, vha, 0x20aa,\r\n"Driver ver = %s.\n", eiter->a.driver_version);\r\neiter = entries + size;\r\neiter->type = cpu_to_be16(FDMI_HBA_OPTION_ROM_VERSION);\r\nsnprintf(eiter->a.orom_version, sizeof(eiter->a.orom_version),\r\n"%d.%02d", ha->bios_revision[1], ha->bios_revision[0]);\r\nalen = strlen(eiter->a.orom_version);\r\nalen += 4 - (alen & 3);\r\neiter->len = cpu_to_be16(4 + alen);\r\nsize += 4 + alen;\r\nql_dbg(ql_dbg_disc, vha , 0x20ab,\r\n"Optrom version = %d.%02d.\n", eiter->a.orom_version[1],\r\neiter->a.orom_version[0]);\r\neiter = entries + size;\r\neiter->type = cpu_to_be16(FDMI_HBA_FIRMWARE_VERSION);\r\nha->isp_ops->fw_version_str(vha, eiter->a.fw_version,\r\nsizeof(eiter->a.fw_version));\r\nalen = strlen(eiter->a.fw_version);\r\nalen += 4 - (alen & 3);\r\neiter->len = cpu_to_be16(4 + alen);\r\nsize += 4 + alen;\r\nql_dbg(ql_dbg_disc, vha, 0x20ac,\r\n"Firmware vers = %s.\n", eiter->a.fw_version);\r\neiter = entries + size;\r\neiter->type = cpu_to_be16(FDMI_HBA_OS_NAME_AND_VERSION);\r\np_sysid = utsname();\r\nif (p_sysid) {\r\nsnprintf(eiter->a.os_version, sizeof(eiter->a.os_version),\r\n"%s %s %s",\r\np_sysid->sysname, p_sysid->release, p_sysid->version);\r\n} else {\r\nsnprintf(eiter->a.os_version, sizeof(eiter->a.os_version),\r\n"%s %s", "Linux", fc_host_system_hostname(vha->host));\r\n}\r\nalen = strlen(eiter->a.os_version);\r\nalen += 4 - (alen & 3);\r\neiter->len = cpu_to_be16(4 + alen);\r\nsize += 4 + alen;\r\nql_dbg(ql_dbg_disc, vha, 0x20ae,\r\n"OS Name and Version = %s.\n", eiter->a.os_version);\r\neiter = entries + size;\r\neiter->type = cpu_to_be16(FDMI_HBA_MAXIMUM_CT_PAYLOAD_LENGTH);\r\neiter->a.max_ct_len = IS_FWI2_CAPABLE(ha) ?\r\nle16_to_cpu(icb24->frame_payload_size) :\r\nle16_to_cpu(ha->init_cb->frame_payload_size);\r\neiter->a.max_ct_len = cpu_to_be32(eiter->a.max_ct_len);\r\neiter->len = cpu_to_be16(4 + 4);\r\nsize += 4 + 4;\r\nql_dbg(ql_dbg_disc, vha, 0x20af,\r\n"CT Payload Length = 0x%x.\n", eiter->a.max_ct_len);\r\neiter = entries + size;\r\neiter->type = cpu_to_be16(FDMI_HBA_NODE_SYMBOLIC_NAME);\r\nqla2x00_get_sym_node_name(vha, eiter->a.sym_name,\r\nsizeof(eiter->a.sym_name));\r\nalen = strlen(eiter->a.sym_name);\r\nalen += 4 - (alen & 3);\r\neiter->len = cpu_to_be16(4 + alen);\r\nsize += 4 + alen;\r\nql_dbg(ql_dbg_disc, vha, 0x20b0,\r\n"Symbolic Name = %s.\n", eiter->a.sym_name);\r\neiter = entries + size;\r\neiter->type = cpu_to_be16(FDMI_HBA_VENDOR_ID);\r\neiter->a.vendor_id = cpu_to_be32(0x1077);\r\neiter->len = cpu_to_be16(4 + 4);\r\nsize += 4 + 4;\r\nql_dbg(ql_dbg_disc, vha, 0x20b1,\r\n"Vendor Id = %x.\n", eiter->a.vendor_id);\r\neiter = entries + size;\r\neiter->type = cpu_to_be16(FDMI_HBA_NUM_PORTS);\r\neiter->a.num_ports = cpu_to_be32(1);\r\neiter->len = cpu_to_be16(4 + 4);\r\nsize += 4 + 4;\r\nql_dbg(ql_dbg_disc, vha, 0x20b2,\r\n"Port Num = %x.\n", eiter->a.num_ports);\r\neiter = entries + size;\r\neiter->type = cpu_to_be16(FDMI_HBA_FABRIC_NAME);\r\nmemcpy(eiter->a.fabric_name, vha->fabric_node_name, WWN_SIZE);\r\neiter->len = cpu_to_be16(4 + WWN_SIZE);\r\nsize += 4 + WWN_SIZE;\r\nql_dbg(ql_dbg_disc, vha, 0x20b3,\r\n"Fabric Name = %016llx.\n", wwn_to_u64(eiter->a.fabric_name));\r\neiter = entries + size;\r\neiter->type = cpu_to_be16(FDMI_HBA_BOOT_BIOS_NAME);\r\nsnprintf(eiter->a.bios_name, sizeof(eiter->a.bios_name),\r\n"BIOS %d.%02d", ha->bios_revision[1], ha->bios_revision[0]);\r\nalen = strlen(eiter->a.bios_name);\r\nalen += 4 - (alen & 3);\r\neiter->len = cpu_to_be16(4 + alen);\r\nsize += 4 + alen;\r\nql_dbg(ql_dbg_disc, vha, 0x20b4,\r\n"BIOS Name = %s\n", eiter->a.bios_name);\r\neiter = entries + size;\r\neiter->type = cpu_to_be16(FDMI_HBA_TYPE_VENDOR_IDENTIFIER);\r\nsnprintf(eiter->a.vendor_indentifer, sizeof(eiter->a.vendor_indentifer),\r\n"%s", "QLGC");\r\nalen = strlen(eiter->a.vendor_indentifer);\r\nalen += 4 - (alen & 3);\r\neiter->len = cpu_to_be16(4 + alen);\r\nsize += 4 + alen;\r\nql_dbg(ql_dbg_disc, vha, 0x20b1,\r\n"Vendor Identifier = %s.\n", eiter->a.vendor_indentifer);\r\nqla2x00_update_ms_fdmi_iocb(vha, size + 16);\r\nql_dbg(ql_dbg_disc, vha, 0x20b5,\r\n"RHBA identifier = %016llx.\n",\r\nwwn_to_u64(ct_req->req.rhba2.hba_identifier));\r\nql_dump_buffer(ql_dbg_disc + ql_dbg_buffer, vha, 0x20b6,\r\nentries, size);\r\nrval = qla2x00_issue_iocb(vha, ha->ms_iocb, ha->ms_iocb_dma,\r\nsizeof(ms_iocb_entry_t));\r\nif (rval != QLA_SUCCESS) {\r\nql_dbg(ql_dbg_disc, vha, 0x20b7,\r\n"RHBA issue IOCB failed (%d).\n", rval);\r\n} else if (qla2x00_chk_ms_status(vha, ms_pkt, ct_rsp, "RHBA") !=\r\nQLA_SUCCESS) {\r\nrval = QLA_FUNCTION_FAILED;\r\nif (ct_rsp->header.reason_code == CT_REASON_CANNOT_PERFORM &&\r\nct_rsp->header.explanation_code ==\r\nCT_EXPL_ALREADY_REGISTERED) {\r\nql_dbg(ql_dbg_disc, vha, 0x20b8,\r\n"HBA already registered.\n");\r\nrval = QLA_ALREADY_REGISTERED;\r\n} else {\r\nql_dbg(ql_dbg_disc, vha, 0x2016,\r\n"RHBA FDMI v2 failed, CT Reason code: 0x%x, CT Explanation 0x%x\n",\r\nct_rsp->header.reason_code,\r\nct_rsp->header.explanation_code);\r\n}\r\n} else {\r\nql_dbg(ql_dbg_disc, vha, 0x20b9,\r\n"RHBA FDMI V2 exiting normally.\n");\r\n}\r\nreturn rval;\r\n}\r\nstatic int\r\nqla2x00_fdmi_dhba(scsi_qla_host_t *vha)\r\n{\r\nint rval;\r\nstruct qla_hw_data *ha = vha->hw;\r\nms_iocb_entry_t *ms_pkt;\r\nstruct ct_sns_req *ct_req;\r\nstruct ct_sns_rsp *ct_rsp;\r\nms_pkt = ha->isp_ops->prep_ms_fdmi_iocb(vha, DHBA_REQ_SIZE,\r\nDHBA_RSP_SIZE);\r\nct_req = qla2x00_prep_ct_fdmi_req(ha->ct_sns, DHBA_CMD, DHBA_RSP_SIZE);\r\nct_rsp = &ha->ct_sns->p.rsp;\r\nmemcpy(ct_req->req.dhba.port_name, vha->port_name, WWN_SIZE);\r\nql_dbg(ql_dbg_disc, vha, 0x2036,\r\n"DHBA portname = %8phN.\n", ct_req->req.dhba.port_name);\r\nrval = qla2x00_issue_iocb(vha, ha->ms_iocb, ha->ms_iocb_dma,\r\nsizeof(ms_iocb_entry_t));\r\nif (rval != QLA_SUCCESS) {\r\nql_dbg(ql_dbg_disc, vha, 0x2037,\r\n"DHBA issue IOCB failed (%d).\n", rval);\r\n} else if (qla2x00_chk_ms_status(vha, ms_pkt, ct_rsp, "DHBA") !=\r\nQLA_SUCCESS) {\r\nrval = QLA_FUNCTION_FAILED;\r\n} else {\r\nql_dbg(ql_dbg_disc, vha, 0x2038,\r\n"DHBA exiting normally.\n");\r\n}\r\nreturn rval;\r\n}\r\nstatic int\r\nqla2x00_fdmiv2_rpa(scsi_qla_host_t *vha)\r\n{\r\nint rval, alen;\r\nuint32_t size;\r\nstruct qla_hw_data *ha = vha->hw;\r\nms_iocb_entry_t *ms_pkt;\r\nstruct ct_sns_req *ct_req;\r\nstruct ct_sns_rsp *ct_rsp;\r\nvoid *entries;\r\nstruct ct_fdmiv2_port_attr *eiter;\r\nstruct init_cb_24xx *icb24 = (struct init_cb_24xx *)ha->init_cb;\r\nstruct new_utsname *p_sysid = NULL;\r\nms_pkt = ha->isp_ops->prep_ms_fdmi_iocb(vha, 0, RPA_RSP_SIZE);\r\nct_req = qla2x00_prep_ct_fdmi_req(ha->ct_sns, RPA_CMD, RPA_RSP_SIZE);\r\nct_rsp = &ha->ct_sns->p.rsp;\r\nmemcpy(ct_req->req.rpa2.port_name, vha->port_name, WWN_SIZE);\r\nsize = WWN_SIZE + 4;\r\nct_req->req.rpa2.attrs.count = cpu_to_be32(FDMIV2_PORT_ATTR_COUNT);\r\nentries = ct_req->req.rpa2.port_name;\r\neiter = entries + size;\r\neiter->type = cpu_to_be16(FDMI_PORT_FC4_TYPES);\r\neiter->len = cpu_to_be16(4 + 32);\r\neiter->a.fc4_types[2] = 0x01;\r\nsize += 4 + 32;\r\nql_dbg(ql_dbg_disc, vha, 0x20ba,\r\n"FC4_TYPES=%02x %02x.\n",\r\neiter->a.fc4_types[2],\r\neiter->a.fc4_types[1]);\r\neiter = entries + size;\r\neiter->type = cpu_to_be16(FDMI_PORT_SUPPORT_SPEED);\r\neiter->len = cpu_to_be16(4 + 4);\r\nif (IS_CNA_CAPABLE(ha))\r\neiter->a.sup_speed = cpu_to_be32(\r\nFDMI_PORT_SPEED_10GB);\r\nelse if (IS_QLA27XX(ha))\r\neiter->a.sup_speed = cpu_to_be32(\r\nFDMI_PORT_SPEED_32GB|\r\nFDMI_PORT_SPEED_16GB|\r\nFDMI_PORT_SPEED_8GB);\r\nelse if (IS_QLA2031(ha))\r\neiter->a.sup_speed = cpu_to_be32(\r\nFDMI_PORT_SPEED_16GB|\r\nFDMI_PORT_SPEED_8GB|\r\nFDMI_PORT_SPEED_4GB);\r\nelse if (IS_QLA25XX(ha))\r\neiter->a.sup_speed = cpu_to_be32(\r\nFDMI_PORT_SPEED_8GB|\r\nFDMI_PORT_SPEED_4GB|\r\nFDMI_PORT_SPEED_2GB|\r\nFDMI_PORT_SPEED_1GB);\r\nelse if (IS_QLA24XX_TYPE(ha))\r\neiter->a.sup_speed = cpu_to_be32(\r\nFDMI_PORT_SPEED_4GB|\r\nFDMI_PORT_SPEED_2GB|\r\nFDMI_PORT_SPEED_1GB);\r\nelse if (IS_QLA23XX(ha))\r\neiter->a.sup_speed = cpu_to_be32(\r\nFDMI_PORT_SPEED_2GB|\r\nFDMI_PORT_SPEED_1GB);\r\nelse\r\neiter->a.sup_speed = cpu_to_be32(\r\nFDMI_PORT_SPEED_1GB);\r\nsize += 4 + 4;\r\nql_dbg(ql_dbg_disc, vha, 0x20bb,\r\n"Supported Port Speed = %x.\n", eiter->a.sup_speed);\r\neiter = entries + size;\r\neiter->type = cpu_to_be16(FDMI_PORT_CURRENT_SPEED);\r\neiter->len = cpu_to_be16(4 + 4);\r\nswitch (ha->link_data_rate) {\r\ncase PORT_SPEED_1GB:\r\neiter->a.cur_speed = cpu_to_be32(FDMI_PORT_SPEED_1GB);\r\nbreak;\r\ncase PORT_SPEED_2GB:\r\neiter->a.cur_speed = cpu_to_be32(FDMI_PORT_SPEED_2GB);\r\nbreak;\r\ncase PORT_SPEED_4GB:\r\neiter->a.cur_speed = cpu_to_be32(FDMI_PORT_SPEED_4GB);\r\nbreak;\r\ncase PORT_SPEED_8GB:\r\neiter->a.cur_speed = cpu_to_be32(FDMI_PORT_SPEED_8GB);\r\nbreak;\r\ncase PORT_SPEED_10GB:\r\neiter->a.cur_speed = cpu_to_be32(FDMI_PORT_SPEED_10GB);\r\nbreak;\r\ncase PORT_SPEED_16GB:\r\neiter->a.cur_speed = cpu_to_be32(FDMI_PORT_SPEED_16GB);\r\nbreak;\r\ncase PORT_SPEED_32GB:\r\neiter->a.cur_speed = cpu_to_be32(FDMI_PORT_SPEED_32GB);\r\nbreak;\r\ndefault:\r\neiter->a.cur_speed = cpu_to_be32(FDMI_PORT_SPEED_UNKNOWN);\r\nbreak;\r\n}\r\nsize += 4 + 4;\r\nql_dbg(ql_dbg_disc, vha, 0x20bc,\r\n"Current_Speed = %x.\n", eiter->a.cur_speed);\r\neiter = entries + size;\r\neiter->type = cpu_to_be16(FDMI_PORT_MAX_FRAME_SIZE);\r\neiter->len = cpu_to_be16(4 + 4);\r\neiter->a.max_frame_size = IS_FWI2_CAPABLE(ha) ?\r\nle16_to_cpu(icb24->frame_payload_size):\r\nle16_to_cpu(ha->init_cb->frame_payload_size);\r\neiter->a.max_frame_size = cpu_to_be32(eiter->a.max_frame_size);\r\nsize += 4 + 4;\r\nql_dbg(ql_dbg_disc, vha, 0x20bc,\r\n"Max_Frame_Size = %x.\n", eiter->a.max_frame_size);\r\neiter = entries + size;\r\neiter->type = cpu_to_be16(FDMI_PORT_OS_DEVICE_NAME);\r\nalen = strlen(QLA2XXX_DRIVER_NAME);\r\nsnprintf(eiter->a.os_dev_name, sizeof(eiter->a.os_dev_name),\r\n"%s:host%lu", QLA2XXX_DRIVER_NAME, vha->host_no);\r\nalen += 4 - (alen & 3);\r\neiter->len = cpu_to_be16(4 + alen);\r\nsize += 4 + alen;\r\nql_dbg(ql_dbg_disc, vha, 0x20be,\r\n"OS_Device_Name = %s.\n", eiter->a.os_dev_name);\r\neiter = entries + size;\r\neiter->type = cpu_to_be16(FDMI_PORT_HOST_NAME);\r\np_sysid = utsname();\r\nif (p_sysid) {\r\nsnprintf(eiter->a.host_name, sizeof(eiter->a.host_name),\r\n"%s", p_sysid->nodename);\r\n} else {\r\nsnprintf(eiter->a.host_name, sizeof(eiter->a.host_name),\r\n"%s", fc_host_system_hostname(vha->host));\r\n}\r\nalen = strlen(eiter->a.host_name);\r\nalen += 4 - (alen & 3);\r\neiter->len = cpu_to_be16(4 + alen);\r\nsize += 4 + alen;\r\nql_dbg(ql_dbg_disc, vha, 0x203d,\r\n"HostName=%s.\n", eiter->a.host_name);\r\neiter = entries + size;\r\neiter->type = cpu_to_be16(FDMI_PORT_NODE_NAME);\r\nmemcpy(eiter->a.node_name, vha->node_name, WWN_SIZE);\r\neiter->len = cpu_to_be16(4 + WWN_SIZE);\r\nsize += 4 + WWN_SIZE;\r\nql_dbg(ql_dbg_disc, vha, 0x20c0,\r\n"Node Name = %016llx.\n", wwn_to_u64(eiter->a.node_name));\r\neiter = entries + size;\r\neiter->type = cpu_to_be16(FDMI_PORT_NAME);\r\nmemcpy(eiter->a.port_name, vha->port_name, WWN_SIZE);\r\neiter->len = cpu_to_be16(4 + WWN_SIZE);\r\nsize += 4 + WWN_SIZE;\r\nql_dbg(ql_dbg_disc, vha, 0x20c1,\r\n"Port Name = %016llx.\n", wwn_to_u64(eiter->a.port_name));\r\neiter = entries + size;\r\neiter->type = cpu_to_be16(FDMI_PORT_SYM_NAME);\r\nqla2x00_get_sym_node_name(vha, eiter->a.port_sym_name,\r\nsizeof(eiter->a.port_sym_name));\r\nalen = strlen(eiter->a.port_sym_name);\r\nalen += 4 - (alen & 3);\r\neiter->len = cpu_to_be16(4 + alen);\r\nsize += 4 + alen;\r\nql_dbg(ql_dbg_disc, vha, 0x20c2,\r\n"port symbolic name = %s\n", eiter->a.port_sym_name);\r\neiter = entries + size;\r\neiter->type = cpu_to_be16(FDMI_PORT_TYPE);\r\neiter->a.port_type = cpu_to_be32(NS_NX_PORT_TYPE);\r\neiter->len = cpu_to_be16(4 + 4);\r\nsize += 4 + 4;\r\nql_dbg(ql_dbg_disc, vha, 0x20c3,\r\n"Port Type = %x.\n", eiter->a.port_type);\r\neiter = entries + size;\r\neiter->type = cpu_to_be16(FDMI_PORT_SUPP_COS);\r\neiter->a.port_supported_cos = cpu_to_be32(FC_CLASS_3);\r\neiter->len = cpu_to_be16(4 + 4);\r\nsize += 4 + 4;\r\nql_dbg(ql_dbg_disc, vha, 0x20c4,\r\n"Supported COS = %08x\n", eiter->a.port_supported_cos);\r\neiter = entries + size;\r\neiter->type = cpu_to_be16(FDMI_PORT_FABRIC_NAME);\r\nmemcpy(eiter->a.fabric_name, vha->fabric_node_name, WWN_SIZE);\r\neiter->len = cpu_to_be16(4 + WWN_SIZE);\r\nsize += 4 + WWN_SIZE;\r\nql_dbg(ql_dbg_disc, vha, 0x20c5,\r\n"Fabric Name = %016llx.\n", wwn_to_u64(eiter->a.fabric_name));\r\neiter = entries + size;\r\neiter->type = cpu_to_be16(FDMI_PORT_FC4_TYPE);\r\neiter->a.port_fc4_type[0] = 0;\r\neiter->a.port_fc4_type[1] = 0;\r\neiter->a.port_fc4_type[2] = 1;\r\neiter->a.port_fc4_type[3] = 0;\r\neiter->len = cpu_to_be16(4 + 32);\r\nsize += 4 + 32;\r\nql_dbg(ql_dbg_disc, vha, 0x20c6,\r\n"Port Active FC4 Type = %02x %02x.\n",\r\neiter->a.port_fc4_type[2], eiter->a.port_fc4_type[1]);\r\neiter = entries + size;\r\neiter->type = cpu_to_be16(FDMI_PORT_STATE);\r\neiter->a.port_state = cpu_to_be32(1);\r\neiter->len = cpu_to_be16(4 + 4);\r\nsize += 4 + 4;\r\nql_dbg(ql_dbg_disc, vha, 0x20c7,\r\n"Port State = %x.\n", eiter->a.port_state);\r\neiter = entries + size;\r\neiter->type = cpu_to_be16(FDMI_PORT_COUNT);\r\neiter->a.num_ports = cpu_to_be32(1);\r\neiter->len = cpu_to_be16(4 + 4);\r\nsize += 4 + 4;\r\nql_dbg(ql_dbg_disc, vha, 0x20c8,\r\n"Number of ports = %x.\n", eiter->a.num_ports);\r\neiter = entries + size;\r\neiter->type = cpu_to_be16(FDMI_PORT_ID);\r\neiter->a.port_id = cpu_to_be32(vha->d_id.b24);\r\neiter->len = cpu_to_be16(4 + 4);\r\nsize += 4 + 4;\r\nql_dbg(ql_dbg_disc, vha, 0x20c8,\r\n"Port Id = %x.\n", eiter->a.port_id);\r\nqla2x00_update_ms_fdmi_iocb(vha, size + 16);\r\nql_dbg(ql_dbg_disc, vha, 0x203e,\r\n"RPA portname= %8phN size=%d.\n", ct_req->req.rpa.port_name, size);\r\nql_dump_buffer(ql_dbg_disc + ql_dbg_buffer, vha, 0x20ca,\r\nentries, size);\r\nrval = qla2x00_issue_iocb(vha, ha->ms_iocb, ha->ms_iocb_dma,\r\nsizeof(ms_iocb_entry_t));\r\nif (rval != QLA_SUCCESS) {\r\nql_dbg(ql_dbg_disc, vha, 0x20cb,\r\n"RPA FDMI v2 issue IOCB failed (%d).\n", rval);\r\n} else if (qla2x00_chk_ms_status(vha, ms_pkt, ct_rsp, "RPA") !=\r\nQLA_SUCCESS) {\r\nrval = QLA_FUNCTION_FAILED;\r\nif (ct_rsp->header.reason_code == CT_REASON_CANNOT_PERFORM &&\r\nct_rsp->header.explanation_code ==\r\nCT_EXPL_ALREADY_REGISTERED) {\r\nql_dbg(ql_dbg_disc, vha, 0x20ce,\r\n"RPA FDMI v2 already registered\n");\r\nrval = QLA_ALREADY_REGISTERED;\r\n} else {\r\nql_dbg(ql_dbg_disc, vha, 0x2020,\r\n"RPA FDMI v2 failed, CT Reason code: 0x%x, CT Explanation 0x%x\n",\r\nct_rsp->header.reason_code,\r\nct_rsp->header.explanation_code);\r\n}\r\n} else {\r\nql_dbg(ql_dbg_disc, vha, 0x20cc,\r\n"RPA FDMI V2 exiting normally.\n");\r\n}\r\nreturn rval;\r\n}\r\nint\r\nqla2x00_fdmi_register(scsi_qla_host_t *vha)\r\n{\r\nint rval = QLA_FUNCTION_FAILED;\r\nstruct qla_hw_data *ha = vha->hw;\r\nif (IS_QLA2100(ha) || IS_QLA2200(ha) ||\r\nIS_QLAFX00(ha))\r\nreturn QLA_FUNCTION_FAILED;\r\nrval = qla2x00_mgmt_svr_login(vha);\r\nif (rval)\r\nreturn rval;\r\nrval = qla2x00_fdmiv2_rhba(vha);\r\nif (rval) {\r\nif (rval != QLA_ALREADY_REGISTERED)\r\ngoto try_fdmi;\r\nrval = qla2x00_fdmi_dhba(vha);\r\nif (rval)\r\ngoto try_fdmi;\r\nrval = qla2x00_fdmiv2_rhba(vha);\r\nif (rval)\r\ngoto try_fdmi;\r\n}\r\nrval = qla2x00_fdmiv2_rpa(vha);\r\nif (rval)\r\ngoto try_fdmi;\r\ngoto out;\r\ntry_fdmi:\r\nrval = qla2x00_fdmi_rhba(vha);\r\nif (rval) {\r\nif (rval != QLA_ALREADY_REGISTERED)\r\nreturn rval;\r\nrval = qla2x00_fdmi_dhba(vha);\r\nif (rval)\r\nreturn rval;\r\nrval = qla2x00_fdmi_rhba(vha);\r\nif (rval)\r\nreturn rval;\r\n}\r\nrval = qla2x00_fdmi_rpa(vha);\r\nout:\r\nreturn rval;\r\n}\r\nint\r\nqla2x00_gfpn_id(scsi_qla_host_t *vha, sw_info_t *list)\r\n{\r\nint rval = QLA_SUCCESS;\r\nuint16_t i;\r\nstruct qla_hw_data *ha = vha->hw;\r\nms_iocb_entry_t *ms_pkt;\r\nstruct ct_sns_req *ct_req;\r\nstruct ct_sns_rsp *ct_rsp;\r\nif (!IS_IIDMA_CAPABLE(ha))\r\nreturn QLA_FUNCTION_FAILED;\r\nfor (i = 0; i < ha->max_fibre_devices; i++) {\r\nms_pkt = ha->isp_ops->prep_ms_iocb(vha, GFPN_ID_REQ_SIZE,\r\nGFPN_ID_RSP_SIZE);\r\nct_req = qla2x00_prep_ct_req(ha->ct_sns, GFPN_ID_CMD,\r\nGFPN_ID_RSP_SIZE);\r\nct_rsp = &ha->ct_sns->p.rsp;\r\nct_req->req.port_id.port_id[0] = list[i].d_id.b.domain;\r\nct_req->req.port_id.port_id[1] = list[i].d_id.b.area;\r\nct_req->req.port_id.port_id[2] = list[i].d_id.b.al_pa;\r\nrval = qla2x00_issue_iocb(vha, ha->ms_iocb, ha->ms_iocb_dma,\r\nsizeof(ms_iocb_entry_t));\r\nif (rval != QLA_SUCCESS) {\r\nql_dbg(ql_dbg_disc, vha, 0x2023,\r\n"GFPN_ID issue IOCB failed (%d).\n", rval);\r\nbreak;\r\n} else if (qla2x00_chk_ms_status(vha, ms_pkt, ct_rsp,\r\n"GFPN_ID") != QLA_SUCCESS) {\r\nrval = QLA_FUNCTION_FAILED;\r\nbreak;\r\n} else {\r\nmemcpy(list[i].fabric_port_name,\r\nct_rsp->rsp.gfpn_id.port_name, WWN_SIZE);\r\n}\r\nif (list[i].d_id.b.rsvd_1 != 0)\r\nbreak;\r\n}\r\nreturn (rval);\r\n}\r\nstatic inline void *\r\nqla24xx_prep_ms_fm_iocb(scsi_qla_host_t *vha, uint32_t req_size,\r\nuint32_t rsp_size)\r\n{\r\nstruct ct_entry_24xx *ct_pkt;\r\nstruct qla_hw_data *ha = vha->hw;\r\nct_pkt = (struct ct_entry_24xx *)ha->ms_iocb;\r\nmemset(ct_pkt, 0, sizeof(struct ct_entry_24xx));\r\nct_pkt->entry_type = CT_IOCB_TYPE;\r\nct_pkt->entry_count = 1;\r\nct_pkt->nport_handle = cpu_to_le16(vha->mgmt_svr_loop_id);\r\nct_pkt->timeout = cpu_to_le16(ha->r_a_tov / 10 * 2);\r\nct_pkt->cmd_dsd_count = cpu_to_le16(1);\r\nct_pkt->rsp_dsd_count = cpu_to_le16(1);\r\nct_pkt->rsp_byte_count = cpu_to_le32(rsp_size);\r\nct_pkt->cmd_byte_count = cpu_to_le32(req_size);\r\nct_pkt->dseg_0_address[0] = cpu_to_le32(LSD(ha->ct_sns_dma));\r\nct_pkt->dseg_0_address[1] = cpu_to_le32(MSD(ha->ct_sns_dma));\r\nct_pkt->dseg_0_len = ct_pkt->cmd_byte_count;\r\nct_pkt->dseg_1_address[0] = cpu_to_le32(LSD(ha->ct_sns_dma));\r\nct_pkt->dseg_1_address[1] = cpu_to_le32(MSD(ha->ct_sns_dma));\r\nct_pkt->dseg_1_len = ct_pkt->rsp_byte_count;\r\nct_pkt->vp_index = vha->vp_idx;\r\nreturn ct_pkt;\r\n}\r\nstatic inline struct ct_sns_req *\r\nqla24xx_prep_ct_fm_req(struct ct_sns_pkt *p, uint16_t cmd,\r\nuint16_t rsp_size)\r\n{\r\nmemset(p, 0, sizeof(struct ct_sns_pkt));\r\np->p.req.header.revision = 0x01;\r\np->p.req.header.gs_type = 0xFA;\r\np->p.req.header.gs_subtype = 0x01;\r\np->p.req.command = cpu_to_be16(cmd);\r\np->p.req.max_rsp_size = cpu_to_be16((rsp_size - 16) / 4);\r\nreturn &p->p.req;\r\n}\r\nint\r\nqla2x00_gpsc(scsi_qla_host_t *vha, sw_info_t *list)\r\n{\r\nint rval;\r\nuint16_t i;\r\nstruct qla_hw_data *ha = vha->hw;\r\nms_iocb_entry_t *ms_pkt;\r\nstruct ct_sns_req *ct_req;\r\nstruct ct_sns_rsp *ct_rsp;\r\nif (!IS_IIDMA_CAPABLE(ha))\r\nreturn QLA_FUNCTION_FAILED;\r\nif (!ha->flags.gpsc_supported)\r\nreturn QLA_FUNCTION_FAILED;\r\nrval = qla2x00_mgmt_svr_login(vha);\r\nif (rval)\r\nreturn rval;\r\nfor (i = 0; i < ha->max_fibre_devices; i++) {\r\nms_pkt = qla24xx_prep_ms_fm_iocb(vha, GPSC_REQ_SIZE,\r\nGPSC_RSP_SIZE);\r\nct_req = qla24xx_prep_ct_fm_req(ha->ct_sns, GPSC_CMD,\r\nGPSC_RSP_SIZE);\r\nct_rsp = &ha->ct_sns->p.rsp;\r\nmemcpy(ct_req->req.gpsc.port_name, list[i].fabric_port_name,\r\nWWN_SIZE);\r\nrval = qla2x00_issue_iocb(vha, ha->ms_iocb, ha->ms_iocb_dma,\r\nsizeof(ms_iocb_entry_t));\r\nif (rval != QLA_SUCCESS) {\r\nql_dbg(ql_dbg_disc, vha, 0x2059,\r\n"GPSC issue IOCB failed (%d).\n", rval);\r\n} else if ((rval = qla2x00_chk_ms_status(vha, ms_pkt, ct_rsp,\r\n"GPSC")) != QLA_SUCCESS) {\r\nif (rval == QLA_INVALID_COMMAND &&\r\n(ct_rsp->header.reason_code ==\r\nCT_REASON_INVALID_COMMAND_CODE ||\r\nct_rsp->header.reason_code ==\r\nCT_REASON_COMMAND_UNSUPPORTED)) {\r\nql_dbg(ql_dbg_disc, vha, 0x205a,\r\n"GPSC command unsupported, disabling "\r\n"query.\n");\r\nha->flags.gpsc_supported = 0;\r\nrval = QLA_FUNCTION_FAILED;\r\nbreak;\r\n}\r\nrval = QLA_FUNCTION_FAILED;\r\n} else {\r\nswitch (be16_to_cpu(ct_rsp->rsp.gpsc.speed)) {\r\ncase BIT_15:\r\nlist[i].fp_speed = PORT_SPEED_1GB;\r\nbreak;\r\ncase BIT_14:\r\nlist[i].fp_speed = PORT_SPEED_2GB;\r\nbreak;\r\ncase BIT_13:\r\nlist[i].fp_speed = PORT_SPEED_4GB;\r\nbreak;\r\ncase BIT_12:\r\nlist[i].fp_speed = PORT_SPEED_10GB;\r\nbreak;\r\ncase BIT_11:\r\nlist[i].fp_speed = PORT_SPEED_8GB;\r\nbreak;\r\ncase BIT_10:\r\nlist[i].fp_speed = PORT_SPEED_16GB;\r\nbreak;\r\ncase BIT_8:\r\nlist[i].fp_speed = PORT_SPEED_32GB;\r\nbreak;\r\n}\r\nql_dbg(ql_dbg_disc, vha, 0x205b,\r\n"GPSC ext entry - fpn "\r\n"%8phN speeds=%04x speed=%04x.\n",\r\nlist[i].fabric_port_name,\r\nbe16_to_cpu(ct_rsp->rsp.gpsc.speeds),\r\nbe16_to_cpu(ct_rsp->rsp.gpsc.speed));\r\n}\r\nif (list[i].d_id.b.rsvd_1 != 0)\r\nbreak;\r\n}\r\nreturn (rval);\r\n}\r\nvoid\r\nqla2x00_gff_id(scsi_qla_host_t *vha, sw_info_t *list)\r\n{\r\nint rval;\r\nuint16_t i;\r\nms_iocb_entry_t *ms_pkt;\r\nstruct ct_sns_req *ct_req;\r\nstruct ct_sns_rsp *ct_rsp;\r\nstruct qla_hw_data *ha = vha->hw;\r\nuint8_t fcp_scsi_features = 0;\r\nfor (i = 0; i < ha->max_fibre_devices; i++) {\r\nlist[i].fc4_type = FC4_TYPE_UNKNOWN;\r\nif (!IS_FWI2_CAPABLE(ha))\r\ncontinue;\r\nms_pkt = ha->isp_ops->prep_ms_iocb(vha, GFF_ID_REQ_SIZE,\r\nGFF_ID_RSP_SIZE);\r\nct_req = qla2x00_prep_ct_req(ha->ct_sns, GFF_ID_CMD,\r\nGFF_ID_RSP_SIZE);\r\nct_rsp = &ha->ct_sns->p.rsp;\r\nct_req->req.port_id.port_id[0] = list[i].d_id.b.domain;\r\nct_req->req.port_id.port_id[1] = list[i].d_id.b.area;\r\nct_req->req.port_id.port_id[2] = list[i].d_id.b.al_pa;\r\nrval = qla2x00_issue_iocb(vha, ha->ms_iocb, ha->ms_iocb_dma,\r\nsizeof(ms_iocb_entry_t));\r\nif (rval != QLA_SUCCESS) {\r\nql_dbg(ql_dbg_disc, vha, 0x205c,\r\n"GFF_ID issue IOCB failed (%d).\n", rval);\r\n} else if (qla2x00_chk_ms_status(vha, ms_pkt, ct_rsp,\r\n"GFF_ID") != QLA_SUCCESS) {\r\nql_dbg(ql_dbg_disc, vha, 0x205d,\r\n"GFF_ID IOCB status had a failure status code.\n");\r\n} else {\r\nfcp_scsi_features =\r\nct_rsp->rsp.gff_id.fc4_features[GFF_FCP_SCSI_OFFSET];\r\nfcp_scsi_features &= 0x0f;\r\nif (fcp_scsi_features)\r\nlist[i].fc4_type = FC4_TYPE_FCP_SCSI;\r\nelse\r\nlist[i].fc4_type = FC4_TYPE_OTHER;\r\n}\r\nif (list[i].d_id.b.rsvd_1 != 0)\r\nbreak;\r\n}\r\n}
