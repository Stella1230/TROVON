static struct s5p_mfc_fmt *find_format(struct v4l2_format *f, unsigned int t)\r\n{\r\nunsigned int i;\r\nfor (i = 0; i < NUM_FORMATS; i++) {\r\nif (formats[i].fourcc == f->fmt.pix_mp.pixelformat &&\r\nformats[i].type == t)\r\nreturn &formats[i];\r\n}\r\nreturn NULL;\r\n}\r\nstatic const char * const *mfc51_get_menu(u32 id)\r\n{\r\nstatic const char * const mfc51_video_frame_skip[] = {\r\n"Disabled",\r\n"Level Limit",\r\n"VBV/CPB Limit",\r\nNULL,\r\n};\r\nstatic const char * const mfc51_video_force_frame[] = {\r\n"Disabled",\r\n"I Frame",\r\n"Not Coded",\r\nNULL,\r\n};\r\nswitch (id) {\r\ncase V4L2_CID_MPEG_MFC51_VIDEO_FRAME_SKIP_MODE:\r\nreturn mfc51_video_frame_skip;\r\ncase V4L2_CID_MPEG_MFC51_VIDEO_FORCE_FRAME_TYPE:\r\nreturn mfc51_video_force_frame;\r\n}\r\nreturn NULL;\r\n}\r\nstatic int s5p_mfc_ctx_ready(struct s5p_mfc_ctx *ctx)\r\n{\r\nmfc_debug(2, "src=%d, dst=%d, state=%d\n",\r\nctx->src_queue_cnt, ctx->dst_queue_cnt, ctx->state);\r\nif (ctx->state == MFCINST_GOT_INST && ctx->dst_queue_cnt >= 1)\r\nreturn 1;\r\nif ((ctx->state == MFCINST_RUNNING ||\r\nctx->state == MFCINST_HEAD_PRODUCED) &&\r\nctx->src_queue_cnt >= 1 && ctx->dst_queue_cnt >= 1)\r\nreturn 1;\r\nif (ctx->state == MFCINST_FINISHING &&\r\nctx->dst_queue_cnt >= 1)\r\nreturn 1;\r\nmfc_debug(2, "ctx is not ready\n");\r\nreturn 0;\r\n}\r\nstatic void cleanup_ref_queue(struct s5p_mfc_ctx *ctx)\r\n{\r\nstruct s5p_mfc_buf *mb_entry;\r\nwhile (!list_empty(&ctx->ref_queue)) {\r\nmb_entry = list_entry((&ctx->ref_queue)->next,\r\nstruct s5p_mfc_buf, list);\r\nlist_del(&mb_entry->list);\r\nctx->ref_queue_cnt--;\r\nlist_add_tail(&mb_entry->list, &ctx->src_queue);\r\nctx->src_queue_cnt++;\r\n}\r\nmfc_debug(2, "enc src count: %d, enc ref count: %d\n",\r\nctx->src_queue_cnt, ctx->ref_queue_cnt);\r\nINIT_LIST_HEAD(&ctx->ref_queue);\r\nctx->ref_queue_cnt = 0;\r\n}\r\nstatic int enc_pre_seq_start(struct s5p_mfc_ctx *ctx)\r\n{\r\nstruct s5p_mfc_dev *dev = ctx->dev;\r\nstruct s5p_mfc_buf *dst_mb;\r\nunsigned long dst_addr;\r\nunsigned int dst_size;\r\ndst_mb = list_entry(ctx->dst_queue.next, struct s5p_mfc_buf, list);\r\ndst_addr = vb2_dma_contig_plane_dma_addr(&dst_mb->b->vb2_buf, 0);\r\ndst_size = vb2_plane_size(&dst_mb->b->vb2_buf, 0);\r\ns5p_mfc_hw_call(dev->mfc_ops, set_enc_stream_buffer, ctx, dst_addr,\r\ndst_size);\r\nreturn 0;\r\n}\r\nstatic int enc_post_seq_start(struct s5p_mfc_ctx *ctx)\r\n{\r\nstruct s5p_mfc_dev *dev = ctx->dev;\r\nstruct s5p_mfc_enc_params *p = &ctx->enc_params;\r\nstruct s5p_mfc_buf *dst_mb;\r\nunsigned int enc_pb_count;\r\nif (p->seq_hdr_mode == V4L2_MPEG_VIDEO_HEADER_MODE_SEPARATE) {\r\nif (!list_empty(&ctx->dst_queue)) {\r\ndst_mb = list_entry(ctx->dst_queue.next,\r\nstruct s5p_mfc_buf, list);\r\nlist_del(&dst_mb->list);\r\nctx->dst_queue_cnt--;\r\nvb2_set_plane_payload(&dst_mb->b->vb2_buf, 0,\r\ns5p_mfc_hw_call(dev->mfc_ops, get_enc_strm_size,\r\ndev));\r\nvb2_buffer_done(&dst_mb->b->vb2_buf,\r\nVB2_BUF_STATE_DONE);\r\n}\r\n}\r\nif (!IS_MFCV6_PLUS(dev)) {\r\nctx->state = MFCINST_RUNNING;\r\nif (s5p_mfc_ctx_ready(ctx))\r\nset_work_bit_irqsave(ctx);\r\ns5p_mfc_hw_call(dev->mfc_ops, try_run, dev);\r\n} else {\r\nenc_pb_count = s5p_mfc_hw_call(dev->mfc_ops,\r\nget_enc_dpb_count, dev);\r\nif (ctx->pb_count < enc_pb_count)\r\nctx->pb_count = enc_pb_count;\r\nctx->state = MFCINST_HEAD_PRODUCED;\r\n}\r\nreturn 0;\r\n}\r\nstatic int enc_pre_frame_start(struct s5p_mfc_ctx *ctx)\r\n{\r\nstruct s5p_mfc_dev *dev = ctx->dev;\r\nstruct s5p_mfc_buf *dst_mb;\r\nstruct s5p_mfc_buf *src_mb;\r\nunsigned long src_y_addr, src_c_addr, dst_addr;\r\nunsigned int dst_size;\r\nsrc_mb = list_entry(ctx->src_queue.next, struct s5p_mfc_buf, list);\r\nsrc_y_addr = vb2_dma_contig_plane_dma_addr(&src_mb->b->vb2_buf, 0);\r\nsrc_c_addr = vb2_dma_contig_plane_dma_addr(&src_mb->b->vb2_buf, 1);\r\ns5p_mfc_hw_call(dev->mfc_ops, set_enc_frame_buffer, ctx,\r\nsrc_y_addr, src_c_addr);\r\ndst_mb = list_entry(ctx->dst_queue.next, struct s5p_mfc_buf, list);\r\ndst_addr = vb2_dma_contig_plane_dma_addr(&dst_mb->b->vb2_buf, 0);\r\ndst_size = vb2_plane_size(&dst_mb->b->vb2_buf, 0);\r\ns5p_mfc_hw_call(dev->mfc_ops, set_enc_stream_buffer, ctx, dst_addr,\r\ndst_size);\r\nreturn 0;\r\n}\r\nstatic int enc_post_frame_start(struct s5p_mfc_ctx *ctx)\r\n{\r\nstruct s5p_mfc_dev *dev = ctx->dev;\r\nstruct s5p_mfc_buf *mb_entry;\r\nunsigned long enc_y_addr, enc_c_addr;\r\nunsigned long mb_y_addr, mb_c_addr;\r\nint slice_type;\r\nunsigned int strm_size;\r\nslice_type = s5p_mfc_hw_call(dev->mfc_ops, get_enc_slice_type, dev);\r\nstrm_size = s5p_mfc_hw_call(dev->mfc_ops, get_enc_strm_size, dev);\r\nmfc_debug(2, "Encoded slice type: %d\n", slice_type);\r\nmfc_debug(2, "Encoded stream size: %d\n", strm_size);\r\nmfc_debug(2, "Display order: %d\n",\r\nmfc_read(dev, S5P_FIMV_ENC_SI_PIC_CNT));\r\nif (slice_type >= 0) {\r\ns5p_mfc_hw_call(dev->mfc_ops, get_enc_frame_buffer, ctx,\r\n&enc_y_addr, &enc_c_addr);\r\nlist_for_each_entry(mb_entry, &ctx->src_queue, list) {\r\nmb_y_addr = vb2_dma_contig_plane_dma_addr(\r\n&mb_entry->b->vb2_buf, 0);\r\nmb_c_addr = vb2_dma_contig_plane_dma_addr(\r\n&mb_entry->b->vb2_buf, 1);\r\nif ((enc_y_addr == mb_y_addr) &&\r\n(enc_c_addr == mb_c_addr)) {\r\nlist_del(&mb_entry->list);\r\nctx->src_queue_cnt--;\r\nvb2_buffer_done(&mb_entry->b->vb2_buf,\r\nVB2_BUF_STATE_DONE);\r\nbreak;\r\n}\r\n}\r\nlist_for_each_entry(mb_entry, &ctx->ref_queue, list) {\r\nmb_y_addr = vb2_dma_contig_plane_dma_addr(\r\n&mb_entry->b->vb2_buf, 0);\r\nmb_c_addr = vb2_dma_contig_plane_dma_addr(\r\n&mb_entry->b->vb2_buf, 1);\r\nif ((enc_y_addr == mb_y_addr) &&\r\n(enc_c_addr == mb_c_addr)) {\r\nlist_del(&mb_entry->list);\r\nctx->ref_queue_cnt--;\r\nvb2_buffer_done(&mb_entry->b->vb2_buf,\r\nVB2_BUF_STATE_DONE);\r\nbreak;\r\n}\r\n}\r\n}\r\nif ((ctx->src_queue_cnt > 0) && (ctx->state == MFCINST_RUNNING)) {\r\nmb_entry = list_entry(ctx->src_queue.next, struct s5p_mfc_buf,\r\nlist);\r\nif (mb_entry->flags & MFC_BUF_FLAG_USED) {\r\nlist_del(&mb_entry->list);\r\nctx->src_queue_cnt--;\r\nlist_add_tail(&mb_entry->list, &ctx->ref_queue);\r\nctx->ref_queue_cnt++;\r\n}\r\n}\r\nmfc_debug(2, "enc src count: %d, enc ref count: %d\n",\r\nctx->src_queue_cnt, ctx->ref_queue_cnt);\r\nif ((ctx->dst_queue_cnt > 0) && (strm_size > 0)) {\r\nmb_entry = list_entry(ctx->dst_queue.next, struct s5p_mfc_buf,\r\nlist);\r\nlist_del(&mb_entry->list);\r\nctx->dst_queue_cnt--;\r\nswitch (slice_type) {\r\ncase S5P_FIMV_ENC_SI_SLICE_TYPE_I:\r\nmb_entry->b->flags |= V4L2_BUF_FLAG_KEYFRAME;\r\nbreak;\r\ncase S5P_FIMV_ENC_SI_SLICE_TYPE_P:\r\nmb_entry->b->flags |= V4L2_BUF_FLAG_PFRAME;\r\nbreak;\r\ncase S5P_FIMV_ENC_SI_SLICE_TYPE_B:\r\nmb_entry->b->flags |= V4L2_BUF_FLAG_BFRAME;\r\nbreak;\r\n}\r\nvb2_set_plane_payload(&mb_entry->b->vb2_buf, 0, strm_size);\r\nvb2_buffer_done(&mb_entry->b->vb2_buf, VB2_BUF_STATE_DONE);\r\n}\r\nif ((ctx->src_queue_cnt == 0) || (ctx->dst_queue_cnt == 0))\r\nclear_work_bit(ctx);\r\nreturn 0;\r\n}\r\nstatic int vidioc_querycap(struct file *file, void *priv,\r\nstruct v4l2_capability *cap)\r\n{\r\nstruct s5p_mfc_dev *dev = video_drvdata(file);\r\nstrncpy(cap->driver, dev->plat_dev->name, sizeof(cap->driver) - 1);\r\nstrncpy(cap->card, dev->plat_dev->name, sizeof(cap->card) - 1);\r\ncap->bus_info[0] = 0;\r\ncap->device_caps = V4L2_CAP_VIDEO_M2M_MPLANE | V4L2_CAP_STREAMING;\r\ncap->capabilities = cap->device_caps | V4L2_CAP_DEVICE_CAPS;\r\nreturn 0;\r\n}\r\nstatic int vidioc_enum_fmt(struct file *file, struct v4l2_fmtdesc *f,\r\nbool out)\r\n{\r\nstruct s5p_mfc_dev *dev = video_drvdata(file);\r\nstruct s5p_mfc_fmt *fmt;\r\nint i, j = 0;\r\nfor (i = 0; i < ARRAY_SIZE(formats); ++i) {\r\nif (out && formats[i].type != MFC_FMT_RAW)\r\ncontinue;\r\nelse if (!out && formats[i].type != MFC_FMT_ENC)\r\ncontinue;\r\nelse if ((dev->variant->version_bit & formats[i].versions) == 0)\r\ncontinue;\r\nif (j == f->index) {\r\nfmt = &formats[i];\r\nstrlcpy(f->description, fmt->name,\r\nsizeof(f->description));\r\nf->pixelformat = fmt->fourcc;\r\nreturn 0;\r\n}\r\n++j;\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int vidioc_enum_fmt_vid_cap_mplane(struct file *file, void *pirv,\r\nstruct v4l2_fmtdesc *f)\r\n{\r\nreturn vidioc_enum_fmt(file, f, false);\r\n}\r\nstatic int vidioc_enum_fmt_vid_out_mplane(struct file *file, void *prov,\r\nstruct v4l2_fmtdesc *f)\r\n{\r\nreturn vidioc_enum_fmt(file, f, true);\r\n}\r\nstatic int vidioc_g_fmt(struct file *file, void *priv, struct v4l2_format *f)\r\n{\r\nstruct s5p_mfc_ctx *ctx = fh_to_ctx(priv);\r\nstruct v4l2_pix_format_mplane *pix_fmt_mp = &f->fmt.pix_mp;\r\nmfc_debug(2, "f->type = %d ctx->state = %d\n", f->type, ctx->state);\r\nif (f->type == V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE) {\r\npix_fmt_mp->width = 0;\r\npix_fmt_mp->height = 0;\r\npix_fmt_mp->field = V4L2_FIELD_NONE;\r\npix_fmt_mp->pixelformat = ctx->dst_fmt->fourcc;\r\npix_fmt_mp->num_planes = ctx->dst_fmt->num_planes;\r\npix_fmt_mp->plane_fmt[0].bytesperline = ctx->enc_dst_buf_size;\r\npix_fmt_mp->plane_fmt[0].sizeimage = ctx->enc_dst_buf_size;\r\n} else if (f->type == V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE) {\r\npix_fmt_mp->width = ctx->img_width;\r\npix_fmt_mp->height = ctx->img_height;\r\npix_fmt_mp->field = V4L2_FIELD_NONE;\r\npix_fmt_mp->pixelformat = ctx->src_fmt->fourcc;\r\npix_fmt_mp->num_planes = ctx->src_fmt->num_planes;\r\npix_fmt_mp->plane_fmt[0].bytesperline = ctx->buf_width;\r\npix_fmt_mp->plane_fmt[0].sizeimage = ctx->luma_size;\r\npix_fmt_mp->plane_fmt[1].bytesperline = ctx->buf_width;\r\npix_fmt_mp->plane_fmt[1].sizeimage = ctx->chroma_size;\r\n} else {\r\nmfc_err("invalid buf type\n");\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int vidioc_try_fmt(struct file *file, void *priv, struct v4l2_format *f)\r\n{\r\nstruct s5p_mfc_dev *dev = video_drvdata(file);\r\nstruct s5p_mfc_fmt *fmt;\r\nstruct v4l2_pix_format_mplane *pix_fmt_mp = &f->fmt.pix_mp;\r\nif (f->type == V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE) {\r\nfmt = find_format(f, MFC_FMT_ENC);\r\nif (!fmt) {\r\nmfc_err("failed to try output format\n");\r\nreturn -EINVAL;\r\n}\r\nif (pix_fmt_mp->plane_fmt[0].sizeimage == 0) {\r\nmfc_err("must be set encoding output size\n");\r\nreturn -EINVAL;\r\n}\r\nif ((dev->variant->version_bit & fmt->versions) == 0) {\r\nmfc_err("Unsupported format by this MFC version.\n");\r\nreturn -EINVAL;\r\n}\r\npix_fmt_mp->plane_fmt[0].bytesperline =\r\npix_fmt_mp->plane_fmt[0].sizeimage;\r\n} else if (f->type == V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE) {\r\nfmt = find_format(f, MFC_FMT_RAW);\r\nif (!fmt) {\r\nmfc_err("failed to try output format\n");\r\nreturn -EINVAL;\r\n}\r\nif (fmt->num_planes != pix_fmt_mp->num_planes) {\r\nmfc_err("failed to try output format\n");\r\nreturn -EINVAL;\r\n}\r\nif ((dev->variant->version_bit & fmt->versions) == 0) {\r\nmfc_err("Unsupported format by this MFC version.\n");\r\nreturn -EINVAL;\r\n}\r\nv4l_bound_align_image(&pix_fmt_mp->width, 8, 1920, 1,\r\n&pix_fmt_mp->height, 4, 1080, 1, 0);\r\n} else {\r\nmfc_err("invalid buf type\n");\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int vidioc_s_fmt(struct file *file, void *priv, struct v4l2_format *f)\r\n{\r\nstruct s5p_mfc_dev *dev = video_drvdata(file);\r\nstruct s5p_mfc_ctx *ctx = fh_to_ctx(priv);\r\nstruct v4l2_pix_format_mplane *pix_fmt_mp = &f->fmt.pix_mp;\r\nint ret = 0;\r\nret = vidioc_try_fmt(file, priv, f);\r\nif (ret)\r\nreturn ret;\r\nif (ctx->vq_src.streaming || ctx->vq_dst.streaming) {\r\nv4l2_err(&dev->v4l2_dev, "%s queue busy\n", __func__);\r\nret = -EBUSY;\r\ngoto out;\r\n}\r\nif (f->type == V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE) {\r\nctx->dst_fmt = find_format(f, MFC_FMT_ENC);\r\nctx->state = MFCINST_INIT;\r\nctx->codec_mode = ctx->dst_fmt->codec_mode;\r\nctx->enc_dst_buf_size = pix_fmt_mp->plane_fmt[0].sizeimage;\r\npix_fmt_mp->plane_fmt[0].bytesperline = 0;\r\nctx->dst_bufs_cnt = 0;\r\nctx->capture_state = QUEUE_FREE;\r\nret = s5p_mfc_open_mfc_inst(dev, ctx);\r\n} else if (f->type == V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE) {\r\nctx->src_fmt = find_format(f, MFC_FMT_RAW);\r\nctx->img_width = pix_fmt_mp->width;\r\nctx->img_height = pix_fmt_mp->height;\r\nmfc_debug(2, "codec number: %d\n", ctx->src_fmt->codec_mode);\r\nmfc_debug(2, "fmt - w: %d, h: %d, ctx - w: %d, h: %d\n",\r\npix_fmt_mp->width, pix_fmt_mp->height,\r\nctx->img_width, ctx->img_height);\r\ns5p_mfc_hw_call(dev->mfc_ops, enc_calc_src_size, ctx);\r\npix_fmt_mp->plane_fmt[0].sizeimage = ctx->luma_size;\r\npix_fmt_mp->plane_fmt[0].bytesperline = ctx->buf_width;\r\npix_fmt_mp->plane_fmt[1].sizeimage = ctx->chroma_size;\r\npix_fmt_mp->plane_fmt[1].bytesperline = ctx->buf_width;\r\nctx->src_bufs_cnt = 0;\r\nctx->output_state = QUEUE_FREE;\r\n} else {\r\nmfc_err("invalid buf type\n");\r\nret = -EINVAL;\r\n}\r\nout:\r\nmfc_debug_leave();\r\nreturn ret;\r\n}\r\nstatic int vidioc_reqbufs(struct file *file, void *priv,\r\nstruct v4l2_requestbuffers *reqbufs)\r\n{\r\nstruct s5p_mfc_dev *dev = video_drvdata(file);\r\nstruct s5p_mfc_ctx *ctx = fh_to_ctx(priv);\r\nint ret = 0;\r\nif ((reqbufs->memory != V4L2_MEMORY_MMAP) &&\r\n(reqbufs->memory != V4L2_MEMORY_USERPTR))\r\nreturn -EINVAL;\r\nif (reqbufs->type == V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE) {\r\nif (reqbufs->count == 0) {\r\nret = vb2_reqbufs(&ctx->vq_dst, reqbufs);\r\nctx->capture_state = QUEUE_FREE;\r\nreturn ret;\r\n}\r\nif (ctx->capture_state != QUEUE_FREE) {\r\nmfc_err("invalid capture state: %d\n",\r\nctx->capture_state);\r\nreturn -EINVAL;\r\n}\r\nret = vb2_reqbufs(&ctx->vq_dst, reqbufs);\r\nif (ret != 0) {\r\nmfc_err("error in vb2_reqbufs() for E(D)\n");\r\nreturn ret;\r\n}\r\nctx->capture_state = QUEUE_BUFS_REQUESTED;\r\nret = s5p_mfc_hw_call(ctx->dev->mfc_ops,\r\nalloc_codec_buffers, ctx);\r\nif (ret) {\r\nmfc_err("Failed to allocate encoding buffers\n");\r\nreqbufs->count = 0;\r\nret = vb2_reqbufs(&ctx->vq_dst, reqbufs);\r\nreturn -ENOMEM;\r\n}\r\n} else if (reqbufs->type == V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE) {\r\nif (reqbufs->count == 0) {\r\nmfc_debug(2, "Freeing buffers\n");\r\nret = vb2_reqbufs(&ctx->vq_src, reqbufs);\r\ns5p_mfc_hw_call(dev->mfc_ops, release_codec_buffers,\r\nctx);\r\nctx->output_state = QUEUE_FREE;\r\nreturn ret;\r\n}\r\nif (ctx->output_state != QUEUE_FREE) {\r\nmfc_err("invalid output state: %d\n",\r\nctx->output_state);\r\nreturn -EINVAL;\r\n}\r\nif (IS_MFCV6_PLUS(dev)) {\r\nif (ctx->pb_count &&\r\n(reqbufs->count < ctx->pb_count)) {\r\nreqbufs->count = ctx->pb_count;\r\nmfc_debug(2, "Minimum %d output buffers needed\n",\r\nctx->pb_count);\r\n} else {\r\nctx->pb_count = reqbufs->count;\r\n}\r\n}\r\nret = vb2_reqbufs(&ctx->vq_src, reqbufs);\r\nif (ret != 0) {\r\nmfc_err("error in vb2_reqbufs() for E(S)\n");\r\nreturn ret;\r\n}\r\nctx->output_state = QUEUE_BUFS_REQUESTED;\r\n} else {\r\nmfc_err("invalid buf type\n");\r\nreturn -EINVAL;\r\n}\r\nreturn ret;\r\n}\r\nstatic int vidioc_querybuf(struct file *file, void *priv,\r\nstruct v4l2_buffer *buf)\r\n{\r\nstruct s5p_mfc_ctx *ctx = fh_to_ctx(priv);\r\nint ret = 0;\r\nif ((buf->memory != V4L2_MEMORY_MMAP) &&\r\n(buf->memory != V4L2_MEMORY_USERPTR))\r\nreturn -EINVAL;\r\nif (buf->type == V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE) {\r\nif (ctx->state != MFCINST_GOT_INST) {\r\nmfc_err("invalid context state: %d\n", ctx->state);\r\nreturn -EINVAL;\r\n}\r\nret = vb2_querybuf(&ctx->vq_dst, buf);\r\nif (ret != 0) {\r\nmfc_err("error in vb2_querybuf() for E(D)\n");\r\nreturn ret;\r\n}\r\nbuf->m.planes[0].m.mem_offset += DST_QUEUE_OFF_BASE;\r\n} else if (buf->type == V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE) {\r\nret = vb2_querybuf(&ctx->vq_src, buf);\r\nif (ret != 0) {\r\nmfc_err("error in vb2_querybuf() for E(S)\n");\r\nreturn ret;\r\n}\r\n} else {\r\nmfc_err("invalid buf type\n");\r\nreturn -EINVAL;\r\n}\r\nreturn ret;\r\n}\r\nstatic int vidioc_qbuf(struct file *file, void *priv, struct v4l2_buffer *buf)\r\n{\r\nstruct s5p_mfc_ctx *ctx = fh_to_ctx(priv);\r\nif (ctx->state == MFCINST_ERROR) {\r\nmfc_err("Call on QBUF after unrecoverable error\n");\r\nreturn -EIO;\r\n}\r\nif (buf->type == V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE) {\r\nif (ctx->state == MFCINST_FINISHING) {\r\nmfc_err("Call on QBUF after EOS command\n");\r\nreturn -EIO;\r\n}\r\nreturn vb2_qbuf(&ctx->vq_src, buf);\r\n} else if (buf->type == V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE) {\r\nreturn vb2_qbuf(&ctx->vq_dst, buf);\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int vidioc_dqbuf(struct file *file, void *priv, struct v4l2_buffer *buf)\r\n{\r\nconst struct v4l2_event ev = {\r\n.type = V4L2_EVENT_EOS\r\n};\r\nstruct s5p_mfc_ctx *ctx = fh_to_ctx(priv);\r\nint ret;\r\nif (ctx->state == MFCINST_ERROR) {\r\nmfc_err("Call on DQBUF after unrecoverable error\n");\r\nreturn -EIO;\r\n}\r\nif (buf->type == V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE) {\r\nret = vb2_dqbuf(&ctx->vq_src, buf, file->f_flags & O_NONBLOCK);\r\n} else if (buf->type == V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE) {\r\nret = vb2_dqbuf(&ctx->vq_dst, buf, file->f_flags & O_NONBLOCK);\r\nif (ret == 0 && ctx->state == MFCINST_FINISHED\r\n&& list_empty(&ctx->vq_dst.done_list))\r\nv4l2_event_queue_fh(&ctx->fh, &ev);\r\n} else {\r\nret = -EINVAL;\r\n}\r\nreturn ret;\r\n}\r\nstatic int vidioc_expbuf(struct file *file, void *priv,\r\nstruct v4l2_exportbuffer *eb)\r\n{\r\nstruct s5p_mfc_ctx *ctx = fh_to_ctx(priv);\r\nif (eb->type == V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE)\r\nreturn vb2_expbuf(&ctx->vq_src, eb);\r\nif (eb->type == V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE)\r\nreturn vb2_expbuf(&ctx->vq_dst, eb);\r\nreturn -EINVAL;\r\n}\r\nstatic int vidioc_streamon(struct file *file, void *priv,\r\nenum v4l2_buf_type type)\r\n{\r\nstruct s5p_mfc_ctx *ctx = fh_to_ctx(priv);\r\nif (type == V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE)\r\nreturn vb2_streamon(&ctx->vq_src, type);\r\nelse if (type == V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE)\r\nreturn vb2_streamon(&ctx->vq_dst, type);\r\nreturn -EINVAL;\r\n}\r\nstatic int vidioc_streamoff(struct file *file, void *priv,\r\nenum v4l2_buf_type type)\r\n{\r\nstruct s5p_mfc_ctx *ctx = fh_to_ctx(priv);\r\nif (type == V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE)\r\nreturn vb2_streamoff(&ctx->vq_src, type);\r\nelse if (type == V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE)\r\nreturn vb2_streamoff(&ctx->vq_dst, type);\r\nreturn -EINVAL;\r\n}\r\nstatic inline int h264_level(enum v4l2_mpeg_video_h264_level lvl)\r\n{\r\nstatic unsigned int t[V4L2_MPEG_VIDEO_H264_LEVEL_4_0 + 1] = {\r\n10,\r\n9,\r\n11,\r\n12,\r\n13,\r\n20,\r\n21,\r\n22,\r\n30,\r\n31,\r\n32,\r\n40,\r\n};\r\nreturn t[lvl];\r\n}\r\nstatic inline int mpeg4_level(enum v4l2_mpeg_video_mpeg4_level lvl)\r\n{\r\nstatic unsigned int t[V4L2_MPEG_VIDEO_MPEG4_LEVEL_5 + 1] = {\r\n0,\r\n9,\r\n1,\r\n2,\r\n3,\r\n7,\r\n4,\r\n5,\r\n};\r\nreturn t[lvl];\r\n}\r\nstatic inline int vui_sar_idc(enum v4l2_mpeg_video_h264_vui_sar_idc sar)\r\n{\r\nstatic unsigned int t[V4L2_MPEG_VIDEO_H264_VUI_SAR_IDC_EXTENDED + 1] = {\r\n0,\r\n1,\r\n2,\r\n3,\r\n4,\r\n5,\r\n6,\r\n7,\r\n8,\r\n9,\r\n10,\r\n11,\r\n12,\r\n13,\r\n14,\r\n15,\r\n16,\r\n255,\r\n};\r\nreturn t[sar];\r\n}\r\nstatic int s5p_mfc_enc_s_ctrl(struct v4l2_ctrl *ctrl)\r\n{\r\nstruct s5p_mfc_ctx *ctx = ctrl_to_ctx(ctrl);\r\nstruct s5p_mfc_dev *dev = ctx->dev;\r\nstruct s5p_mfc_enc_params *p = &ctx->enc_params;\r\nint ret = 0;\r\nswitch (ctrl->id) {\r\ncase V4L2_CID_MPEG_VIDEO_GOP_SIZE:\r\np->gop_size = ctrl->val;\r\nbreak;\r\ncase V4L2_CID_MPEG_VIDEO_MULTI_SLICE_MODE:\r\np->slice_mode = ctrl->val;\r\nbreak;\r\ncase V4L2_CID_MPEG_VIDEO_MULTI_SLICE_MAX_MB:\r\np->slice_mb = ctrl->val;\r\nbreak;\r\ncase V4L2_CID_MPEG_VIDEO_MULTI_SLICE_MAX_BYTES:\r\np->slice_bit = ctrl->val * 8;\r\nbreak;\r\ncase V4L2_CID_MPEG_VIDEO_CYCLIC_INTRA_REFRESH_MB:\r\np->intra_refresh_mb = ctrl->val;\r\nbreak;\r\ncase V4L2_CID_MPEG_MFC51_VIDEO_PADDING:\r\np->pad = ctrl->val;\r\nbreak;\r\ncase V4L2_CID_MPEG_MFC51_VIDEO_PADDING_YUV:\r\np->pad_luma = (ctrl->val >> 16) & 0xff;\r\np->pad_cb = (ctrl->val >> 8) & 0xff;\r\np->pad_cr = (ctrl->val >> 0) & 0xff;\r\nbreak;\r\ncase V4L2_CID_MPEG_VIDEO_FRAME_RC_ENABLE:\r\np->rc_frame = ctrl->val;\r\nbreak;\r\ncase V4L2_CID_MPEG_VIDEO_BITRATE:\r\np->rc_bitrate = ctrl->val;\r\nbreak;\r\ncase V4L2_CID_MPEG_MFC51_VIDEO_RC_REACTION_COEFF:\r\np->rc_reaction_coeff = ctrl->val;\r\nbreak;\r\ncase V4L2_CID_MPEG_MFC51_VIDEO_FORCE_FRAME_TYPE:\r\nctx->force_frame_type = ctrl->val;\r\nbreak;\r\ncase V4L2_CID_MPEG_VIDEO_FORCE_KEY_FRAME:\r\nctx->force_frame_type =\r\nV4L2_MPEG_MFC51_VIDEO_FORCE_FRAME_TYPE_I_FRAME;\r\nbreak;\r\ncase V4L2_CID_MPEG_VIDEO_VBV_SIZE:\r\np->vbv_size = ctrl->val;\r\nbreak;\r\ncase V4L2_CID_MPEG_VIDEO_MV_H_SEARCH_RANGE:\r\np->mv_h_range = ctrl->val;\r\nbreak;\r\ncase V4L2_CID_MPEG_VIDEO_MV_V_SEARCH_RANGE:\r\np->mv_v_range = ctrl->val;\r\nbreak;\r\ncase V4L2_CID_MPEG_VIDEO_H264_CPB_SIZE:\r\np->codec.h264.cpb_size = ctrl->val;\r\nbreak;\r\ncase V4L2_CID_MPEG_VIDEO_HEADER_MODE:\r\np->seq_hdr_mode = ctrl->val;\r\nbreak;\r\ncase V4L2_CID_MPEG_MFC51_VIDEO_FRAME_SKIP_MODE:\r\np->frame_skip_mode = ctrl->val;\r\nbreak;\r\ncase V4L2_CID_MPEG_MFC51_VIDEO_RC_FIXED_TARGET_BIT:\r\np->fixed_target_bit = ctrl->val;\r\nbreak;\r\ncase V4L2_CID_MPEG_VIDEO_B_FRAMES:\r\np->num_b_frame = ctrl->val;\r\nbreak;\r\ncase V4L2_CID_MPEG_VIDEO_H264_PROFILE:\r\nswitch (ctrl->val) {\r\ncase V4L2_MPEG_VIDEO_H264_PROFILE_MAIN:\r\np->codec.h264.profile =\r\nS5P_FIMV_ENC_PROFILE_H264_MAIN;\r\nbreak;\r\ncase V4L2_MPEG_VIDEO_H264_PROFILE_HIGH:\r\np->codec.h264.profile =\r\nS5P_FIMV_ENC_PROFILE_H264_HIGH;\r\nbreak;\r\ncase V4L2_MPEG_VIDEO_H264_PROFILE_BASELINE:\r\np->codec.h264.profile =\r\nS5P_FIMV_ENC_PROFILE_H264_BASELINE;\r\nbreak;\r\ncase V4L2_MPEG_VIDEO_H264_PROFILE_CONSTRAINED_BASELINE:\r\nif (IS_MFCV6_PLUS(dev))\r\np->codec.h264.profile =\r\nS5P_FIMV_ENC_PROFILE_H264_CONSTRAINED_BASELINE;\r\nelse\r\nret = -EINVAL;\r\nbreak;\r\ndefault:\r\nret = -EINVAL;\r\n}\r\nbreak;\r\ncase V4L2_CID_MPEG_VIDEO_H264_LEVEL:\r\np->codec.h264.level_v4l2 = ctrl->val;\r\np->codec.h264.level = h264_level(ctrl->val);\r\nif (p->codec.h264.level < 0) {\r\nmfc_err("Level number is wrong\n");\r\nret = p->codec.h264.level;\r\n}\r\nbreak;\r\ncase V4L2_CID_MPEG_VIDEO_MPEG4_LEVEL:\r\np->codec.mpeg4.level_v4l2 = ctrl->val;\r\np->codec.mpeg4.level = mpeg4_level(ctrl->val);\r\nif (p->codec.mpeg4.level < 0) {\r\nmfc_err("Level number is wrong\n");\r\nret = p->codec.mpeg4.level;\r\n}\r\nbreak;\r\ncase V4L2_CID_MPEG_VIDEO_H264_LOOP_FILTER_MODE:\r\np->codec.h264.loop_filter_mode = ctrl->val;\r\nbreak;\r\ncase V4L2_CID_MPEG_VIDEO_H264_LOOP_FILTER_ALPHA:\r\np->codec.h264.loop_filter_alpha = ctrl->val;\r\nbreak;\r\ncase V4L2_CID_MPEG_VIDEO_H264_LOOP_FILTER_BETA:\r\np->codec.h264.loop_filter_beta = ctrl->val;\r\nbreak;\r\ncase V4L2_CID_MPEG_VIDEO_H264_ENTROPY_MODE:\r\np->codec.h264.entropy_mode = ctrl->val;\r\nbreak;\r\ncase V4L2_CID_MPEG_MFC51_VIDEO_H264_NUM_REF_PIC_FOR_P:\r\np->codec.h264.num_ref_pic_4p = ctrl->val;\r\nbreak;\r\ncase V4L2_CID_MPEG_VIDEO_H264_8X8_TRANSFORM:\r\np->codec.h264._8x8_transform = ctrl->val;\r\nbreak;\r\ncase V4L2_CID_MPEG_VIDEO_MB_RC_ENABLE:\r\np->rc_mb = ctrl->val;\r\nbreak;\r\ncase V4L2_CID_MPEG_VIDEO_H264_I_FRAME_QP:\r\np->codec.h264.rc_frame_qp = ctrl->val;\r\nbreak;\r\ncase V4L2_CID_MPEG_VIDEO_H264_MIN_QP:\r\np->codec.h264.rc_min_qp = ctrl->val;\r\nbreak;\r\ncase V4L2_CID_MPEG_VIDEO_H264_MAX_QP:\r\np->codec.h264.rc_max_qp = ctrl->val;\r\nbreak;\r\ncase V4L2_CID_MPEG_VIDEO_H264_P_FRAME_QP:\r\np->codec.h264.rc_p_frame_qp = ctrl->val;\r\nbreak;\r\ncase V4L2_CID_MPEG_VIDEO_H264_B_FRAME_QP:\r\np->codec.h264.rc_b_frame_qp = ctrl->val;\r\nbreak;\r\ncase V4L2_CID_MPEG_VIDEO_MPEG4_I_FRAME_QP:\r\ncase V4L2_CID_MPEG_VIDEO_H263_I_FRAME_QP:\r\np->codec.mpeg4.rc_frame_qp = ctrl->val;\r\nbreak;\r\ncase V4L2_CID_MPEG_VIDEO_MPEG4_MIN_QP:\r\ncase V4L2_CID_MPEG_VIDEO_H263_MIN_QP:\r\np->codec.mpeg4.rc_min_qp = ctrl->val;\r\nbreak;\r\ncase V4L2_CID_MPEG_VIDEO_MPEG4_MAX_QP:\r\ncase V4L2_CID_MPEG_VIDEO_H263_MAX_QP:\r\np->codec.mpeg4.rc_max_qp = ctrl->val;\r\nbreak;\r\ncase V4L2_CID_MPEG_VIDEO_MPEG4_P_FRAME_QP:\r\ncase V4L2_CID_MPEG_VIDEO_H263_P_FRAME_QP:\r\np->codec.mpeg4.rc_p_frame_qp = ctrl->val;\r\nbreak;\r\ncase V4L2_CID_MPEG_VIDEO_MPEG4_B_FRAME_QP:\r\ncase V4L2_CID_MPEG_VIDEO_H263_B_FRAME_QP:\r\np->codec.mpeg4.rc_b_frame_qp = ctrl->val;\r\nbreak;\r\ncase V4L2_CID_MPEG_MFC51_VIDEO_H264_ADAPTIVE_RC_DARK:\r\np->codec.h264.rc_mb_dark = ctrl->val;\r\nbreak;\r\ncase V4L2_CID_MPEG_MFC51_VIDEO_H264_ADAPTIVE_RC_SMOOTH:\r\np->codec.h264.rc_mb_smooth = ctrl->val;\r\nbreak;\r\ncase V4L2_CID_MPEG_MFC51_VIDEO_H264_ADAPTIVE_RC_STATIC:\r\np->codec.h264.rc_mb_static = ctrl->val;\r\nbreak;\r\ncase V4L2_CID_MPEG_MFC51_VIDEO_H264_ADAPTIVE_RC_ACTIVITY:\r\np->codec.h264.rc_mb_activity = ctrl->val;\r\nbreak;\r\ncase V4L2_CID_MPEG_VIDEO_H264_VUI_SAR_ENABLE:\r\np->codec.h264.vui_sar = ctrl->val;\r\nbreak;\r\ncase V4L2_CID_MPEG_VIDEO_H264_VUI_SAR_IDC:\r\np->codec.h264.vui_sar_idc = vui_sar_idc(ctrl->val);\r\nbreak;\r\ncase V4L2_CID_MPEG_VIDEO_H264_VUI_EXT_SAR_WIDTH:\r\np->codec.h264.vui_ext_sar_width = ctrl->val;\r\nbreak;\r\ncase V4L2_CID_MPEG_VIDEO_H264_VUI_EXT_SAR_HEIGHT:\r\np->codec.h264.vui_ext_sar_height = ctrl->val;\r\nbreak;\r\ncase V4L2_CID_MPEG_VIDEO_GOP_CLOSURE:\r\np->codec.h264.open_gop = !ctrl->val;\r\nbreak;\r\ncase V4L2_CID_MPEG_VIDEO_H264_I_PERIOD:\r\np->codec.h264.open_gop_size = ctrl->val;\r\nbreak;\r\ncase V4L2_CID_MPEG_VIDEO_MPEG4_PROFILE:\r\nswitch (ctrl->val) {\r\ncase V4L2_MPEG_VIDEO_MPEG4_PROFILE_SIMPLE:\r\np->codec.mpeg4.profile =\r\nS5P_FIMV_ENC_PROFILE_MPEG4_SIMPLE;\r\nbreak;\r\ncase V4L2_MPEG_VIDEO_MPEG4_PROFILE_ADVANCED_SIMPLE:\r\np->codec.mpeg4.profile =\r\nS5P_FIMV_ENC_PROFILE_MPEG4_ADVANCED_SIMPLE;\r\nbreak;\r\ndefault:\r\nret = -EINVAL;\r\n}\r\nbreak;\r\ncase V4L2_CID_MPEG_VIDEO_MPEG4_QPEL:\r\np->codec.mpeg4.quarter_pixel = ctrl->val;\r\nbreak;\r\ncase V4L2_CID_MPEG_VIDEO_VPX_NUM_PARTITIONS:\r\np->codec.vp8.num_partitions = ctrl->val;\r\nbreak;\r\ncase V4L2_CID_MPEG_VIDEO_VPX_IMD_DISABLE_4X4:\r\np->codec.vp8.imd_4x4 = ctrl->val;\r\nbreak;\r\ncase V4L2_CID_MPEG_VIDEO_VPX_NUM_REF_FRAMES:\r\np->codec.vp8.num_ref = ctrl->val;\r\nbreak;\r\ncase V4L2_CID_MPEG_VIDEO_VPX_FILTER_LEVEL:\r\np->codec.vp8.filter_level = ctrl->val;\r\nbreak;\r\ncase V4L2_CID_MPEG_VIDEO_VPX_FILTER_SHARPNESS:\r\np->codec.vp8.filter_sharpness = ctrl->val;\r\nbreak;\r\ncase V4L2_CID_MPEG_VIDEO_VPX_GOLDEN_FRAME_REF_PERIOD:\r\np->codec.vp8.golden_frame_ref_period = ctrl->val;\r\nbreak;\r\ncase V4L2_CID_MPEG_VIDEO_VPX_GOLDEN_FRAME_SEL:\r\np->codec.vp8.golden_frame_sel = ctrl->val;\r\nbreak;\r\ncase V4L2_CID_MPEG_VIDEO_VPX_MIN_QP:\r\np->codec.vp8.rc_min_qp = ctrl->val;\r\nbreak;\r\ncase V4L2_CID_MPEG_VIDEO_VPX_MAX_QP:\r\np->codec.vp8.rc_max_qp = ctrl->val;\r\nbreak;\r\ncase V4L2_CID_MPEG_VIDEO_VPX_I_FRAME_QP:\r\np->codec.vp8.rc_frame_qp = ctrl->val;\r\nbreak;\r\ncase V4L2_CID_MPEG_VIDEO_VPX_P_FRAME_QP:\r\np->codec.vp8.rc_p_frame_qp = ctrl->val;\r\nbreak;\r\ncase V4L2_CID_MPEG_VIDEO_VPX_PROFILE:\r\np->codec.vp8.profile = ctrl->val;\r\nbreak;\r\ndefault:\r\nv4l2_err(&dev->v4l2_dev, "Invalid control, id=%d, val=%d\n",\r\nctrl->id, ctrl->val);\r\nret = -EINVAL;\r\n}\r\nreturn ret;\r\n}\r\nstatic int s5p_mfc_enc_g_v_ctrl(struct v4l2_ctrl *ctrl)\r\n{\r\nstruct s5p_mfc_ctx *ctx = ctrl_to_ctx(ctrl);\r\nstruct s5p_mfc_dev *dev = ctx->dev;\r\nswitch (ctrl->id) {\r\ncase V4L2_CID_MIN_BUFFERS_FOR_OUTPUT:\r\nif (ctx->state >= MFCINST_HEAD_PARSED &&\r\nctx->state < MFCINST_ABORT) {\r\nctrl->val = ctx->pb_count;\r\nbreak;\r\n} else if (ctx->state != MFCINST_INIT) {\r\nv4l2_err(&dev->v4l2_dev, "Encoding not initialised\n");\r\nreturn -EINVAL;\r\n}\r\ns5p_mfc_wait_for_done_ctx(ctx,\r\nS5P_MFC_R2H_CMD_SEQ_DONE_RET, 0);\r\nif (ctx->state >= MFCINST_HEAD_PARSED &&\r\nctx->state < MFCINST_ABORT) {\r\nctrl->val = ctx->pb_count;\r\n} else {\r\nv4l2_err(&dev->v4l2_dev, "Encoding not initialised\n");\r\nreturn -EINVAL;\r\n}\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic int vidioc_s_parm(struct file *file, void *priv,\r\nstruct v4l2_streamparm *a)\r\n{\r\nstruct s5p_mfc_ctx *ctx = fh_to_ctx(priv);\r\nif (a->type == V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE) {\r\nctx->enc_params.rc_framerate_num =\r\na->parm.output.timeperframe.denominator;\r\nctx->enc_params.rc_framerate_denom =\r\na->parm.output.timeperframe.numerator;\r\n} else {\r\nmfc_err("Setting FPS is only possible for the output queue\n");\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int vidioc_g_parm(struct file *file, void *priv,\r\nstruct v4l2_streamparm *a)\r\n{\r\nstruct s5p_mfc_ctx *ctx = fh_to_ctx(priv);\r\nif (a->type == V4L2_BUF_TYPE_VIDEO_OUTPUT) {\r\na->parm.output.timeperframe.denominator =\r\nctx->enc_params.rc_framerate_num;\r\na->parm.output.timeperframe.numerator =\r\nctx->enc_params.rc_framerate_denom;\r\n} else {\r\nmfc_err("Setting FPS is only possible for the output queue\n");\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int vidioc_encoder_cmd(struct file *file, void *priv,\r\nstruct v4l2_encoder_cmd *cmd)\r\n{\r\nstruct s5p_mfc_ctx *ctx = fh_to_ctx(priv);\r\nstruct s5p_mfc_dev *dev = ctx->dev;\r\nstruct s5p_mfc_buf *buf;\r\nunsigned long flags;\r\nswitch (cmd->cmd) {\r\ncase V4L2_ENC_CMD_STOP:\r\nif (cmd->flags != 0)\r\nreturn -EINVAL;\r\nif (!ctx->vq_src.streaming)\r\nreturn -EINVAL;\r\nspin_lock_irqsave(&dev->irqlock, flags);\r\nif (list_empty(&ctx->src_queue)) {\r\nmfc_debug(2, "EOS: empty src queue, entering finishing state\n");\r\nctx->state = MFCINST_FINISHING;\r\nif (s5p_mfc_ctx_ready(ctx))\r\nset_work_bit_irqsave(ctx);\r\nspin_unlock_irqrestore(&dev->irqlock, flags);\r\ns5p_mfc_hw_call(dev->mfc_ops, try_run, dev);\r\n} else {\r\nmfc_debug(2, "EOS: marking last buffer of stream\n");\r\nbuf = list_entry(ctx->src_queue.prev,\r\nstruct s5p_mfc_buf, list);\r\nif (buf->flags & MFC_BUF_FLAG_USED)\r\nctx->state = MFCINST_FINISHING;\r\nelse\r\nbuf->flags |= MFC_BUF_FLAG_EOS;\r\nspin_unlock_irqrestore(&dev->irqlock, flags);\r\n}\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int vidioc_subscribe_event(struct v4l2_fh *fh,\r\nconst struct v4l2_event_subscription *sub)\r\n{\r\nswitch (sub->type) {\r\ncase V4L2_EVENT_EOS:\r\nreturn v4l2_event_subscribe(fh, sub, 2, NULL);\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\n}\r\nstatic int check_vb_with_fmt(struct s5p_mfc_fmt *fmt, struct vb2_buffer *vb)\r\n{\r\nint i;\r\nif (!fmt)\r\nreturn -EINVAL;\r\nif (fmt->num_planes != vb->num_planes) {\r\nmfc_err("invalid plane number for the format\n");\r\nreturn -EINVAL;\r\n}\r\nfor (i = 0; i < fmt->num_planes; i++) {\r\ndma_addr_t dma = vb2_dma_contig_plane_dma_addr(vb, i);\r\nif (!dma) {\r\nmfc_err("failed to get plane cookie\n");\r\nreturn -EINVAL;\r\n}\r\nmfc_debug(2, "index: %d, plane[%d] cookie: %pad\n",\r\nvb->index, i, &dma);\r\n}\r\nreturn 0;\r\n}\r\nstatic int s5p_mfc_queue_setup(struct vb2_queue *vq,\r\nunsigned int *buf_count, unsigned int *plane_count,\r\nunsigned int psize[], void *allocators[])\r\n{\r\nstruct s5p_mfc_ctx *ctx = fh_to_ctx(vq->drv_priv);\r\nstruct s5p_mfc_dev *dev = ctx->dev;\r\nif (vq->type == V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE) {\r\nif (ctx->state != MFCINST_GOT_INST) {\r\nmfc_err("invalid state: %d\n", ctx->state);\r\nreturn -EINVAL;\r\n}\r\nif (ctx->dst_fmt)\r\n*plane_count = ctx->dst_fmt->num_planes;\r\nelse\r\n*plane_count = MFC_ENC_CAP_PLANE_COUNT;\r\nif (*buf_count < 1)\r\n*buf_count = 1;\r\nif (*buf_count > MFC_MAX_BUFFERS)\r\n*buf_count = MFC_MAX_BUFFERS;\r\npsize[0] = ctx->enc_dst_buf_size;\r\nallocators[0] = ctx->dev->alloc_ctx[MFC_BANK1_ALLOC_CTX];\r\n} else if (vq->type == V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE) {\r\nif (ctx->src_fmt)\r\n*plane_count = ctx->src_fmt->num_planes;\r\nelse\r\n*plane_count = MFC_ENC_OUT_PLANE_COUNT;\r\nif (*buf_count < 1)\r\n*buf_count = 1;\r\nif (*buf_count > MFC_MAX_BUFFERS)\r\n*buf_count = MFC_MAX_BUFFERS;\r\npsize[0] = ctx->luma_size;\r\npsize[1] = ctx->chroma_size;\r\nif (IS_MFCV6_PLUS(dev)) {\r\nallocators[0] =\r\nctx->dev->alloc_ctx[MFC_BANK1_ALLOC_CTX];\r\nallocators[1] =\r\nctx->dev->alloc_ctx[MFC_BANK1_ALLOC_CTX];\r\n} else {\r\nallocators[0] =\r\nctx->dev->alloc_ctx[MFC_BANK2_ALLOC_CTX];\r\nallocators[1] =\r\nctx->dev->alloc_ctx[MFC_BANK2_ALLOC_CTX];\r\n}\r\n} else {\r\nmfc_err("invalid queue type: %d\n", vq->type);\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int s5p_mfc_buf_init(struct vb2_buffer *vb)\r\n{\r\nstruct vb2_v4l2_buffer *vbuf = to_vb2_v4l2_buffer(vb);\r\nstruct vb2_queue *vq = vb->vb2_queue;\r\nstruct s5p_mfc_ctx *ctx = fh_to_ctx(vq->drv_priv);\r\nunsigned int i;\r\nint ret;\r\nif (vq->type == V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE) {\r\nret = check_vb_with_fmt(ctx->dst_fmt, vb);\r\nif (ret < 0)\r\nreturn ret;\r\ni = vb->index;\r\nctx->dst_bufs[i].b = vbuf;\r\nctx->dst_bufs[i].cookie.stream =\r\nvb2_dma_contig_plane_dma_addr(vb, 0);\r\nctx->dst_bufs_cnt++;\r\n} else if (vq->type == V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE) {\r\nret = check_vb_with_fmt(ctx->src_fmt, vb);\r\nif (ret < 0)\r\nreturn ret;\r\ni = vb->index;\r\nctx->src_bufs[i].b = vbuf;\r\nctx->src_bufs[i].cookie.raw.luma =\r\nvb2_dma_contig_plane_dma_addr(vb, 0);\r\nctx->src_bufs[i].cookie.raw.chroma =\r\nvb2_dma_contig_plane_dma_addr(vb, 1);\r\nctx->src_bufs_cnt++;\r\n} else {\r\nmfc_err("invalid queue type: %d\n", vq->type);\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int s5p_mfc_buf_prepare(struct vb2_buffer *vb)\r\n{\r\nstruct vb2_queue *vq = vb->vb2_queue;\r\nstruct s5p_mfc_ctx *ctx = fh_to_ctx(vq->drv_priv);\r\nint ret;\r\nif (vq->type == V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE) {\r\nret = check_vb_with_fmt(ctx->dst_fmt, vb);\r\nif (ret < 0)\r\nreturn ret;\r\nmfc_debug(2, "plane size: %ld, dst size: %zu\n",\r\nvb2_plane_size(vb, 0), ctx->enc_dst_buf_size);\r\nif (vb2_plane_size(vb, 0) < ctx->enc_dst_buf_size) {\r\nmfc_err("plane size is too small for capture\n");\r\nreturn -EINVAL;\r\n}\r\n} else if (vq->type == V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE) {\r\nret = check_vb_with_fmt(ctx->src_fmt, vb);\r\nif (ret < 0)\r\nreturn ret;\r\nmfc_debug(2, "plane size: %ld, luma size: %d\n",\r\nvb2_plane_size(vb, 0), ctx->luma_size);\r\nmfc_debug(2, "plane size: %ld, chroma size: %d\n",\r\nvb2_plane_size(vb, 1), ctx->chroma_size);\r\nif (vb2_plane_size(vb, 0) < ctx->luma_size ||\r\nvb2_plane_size(vb, 1) < ctx->chroma_size) {\r\nmfc_err("plane size is too small for output\n");\r\nreturn -EINVAL;\r\n}\r\n} else {\r\nmfc_err("invalid queue type: %d\n", vq->type);\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int s5p_mfc_start_streaming(struct vb2_queue *q, unsigned int count)\r\n{\r\nstruct s5p_mfc_ctx *ctx = fh_to_ctx(q->drv_priv);\r\nstruct s5p_mfc_dev *dev = ctx->dev;\r\nif (IS_MFCV6_PLUS(dev) &&\r\n(q->type == V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE)) {\r\nif ((ctx->state == MFCINST_GOT_INST) &&\r\n(dev->curr_ctx == ctx->num) && dev->hw_lock) {\r\ns5p_mfc_wait_for_done_ctx(ctx,\r\nS5P_MFC_R2H_CMD_SEQ_DONE_RET,\r\n0);\r\n}\r\nif (ctx->src_bufs_cnt < ctx->pb_count) {\r\nmfc_err("Need minimum %d OUTPUT buffers\n",\r\nctx->pb_count);\r\nreturn -ENOBUFS;\r\n}\r\n}\r\nif (s5p_mfc_ctx_ready(ctx))\r\nset_work_bit_irqsave(ctx);\r\ns5p_mfc_hw_call(dev->mfc_ops, try_run, dev);\r\nreturn 0;\r\n}\r\nstatic void s5p_mfc_stop_streaming(struct vb2_queue *q)\r\n{\r\nunsigned long flags;\r\nstruct s5p_mfc_ctx *ctx = fh_to_ctx(q->drv_priv);\r\nstruct s5p_mfc_dev *dev = ctx->dev;\r\nif ((ctx->state == MFCINST_FINISHING ||\r\nctx->state == MFCINST_RUNNING) &&\r\ndev->curr_ctx == ctx->num && dev->hw_lock) {\r\nctx->state = MFCINST_ABORT;\r\ns5p_mfc_wait_for_done_ctx(ctx, S5P_MFC_R2H_CMD_FRAME_DONE_RET,\r\n0);\r\n}\r\nctx->state = MFCINST_FINISHED;\r\nspin_lock_irqsave(&dev->irqlock, flags);\r\nif (q->type == V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE) {\r\ns5p_mfc_cleanup_queue(&ctx->dst_queue, &ctx->vq_dst);\r\nINIT_LIST_HEAD(&ctx->dst_queue);\r\nctx->dst_queue_cnt = 0;\r\n}\r\nif (q->type == V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE) {\r\ncleanup_ref_queue(ctx);\r\ns5p_mfc_cleanup_queue(&ctx->src_queue, &ctx->vq_src);\r\nINIT_LIST_HEAD(&ctx->src_queue);\r\nctx->src_queue_cnt = 0;\r\n}\r\nspin_unlock_irqrestore(&dev->irqlock, flags);\r\n}\r\nstatic void s5p_mfc_buf_queue(struct vb2_buffer *vb)\r\n{\r\nstruct vb2_queue *vq = vb->vb2_queue;\r\nstruct s5p_mfc_ctx *ctx = fh_to_ctx(vq->drv_priv);\r\nstruct s5p_mfc_dev *dev = ctx->dev;\r\nunsigned long flags;\r\nstruct s5p_mfc_buf *mfc_buf;\r\nif (ctx->state == MFCINST_ERROR) {\r\nvb2_buffer_done(vb, VB2_BUF_STATE_ERROR);\r\ncleanup_ref_queue(ctx);\r\nreturn;\r\n}\r\nif (vq->type == V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE) {\r\nmfc_buf = &ctx->dst_bufs[vb->index];\r\nmfc_buf->flags &= ~MFC_BUF_FLAG_USED;\r\nspin_lock_irqsave(&dev->irqlock, flags);\r\nlist_add_tail(&mfc_buf->list, &ctx->dst_queue);\r\nctx->dst_queue_cnt++;\r\nspin_unlock_irqrestore(&dev->irqlock, flags);\r\n} else if (vq->type == V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE) {\r\nmfc_buf = &ctx->src_bufs[vb->index];\r\nmfc_buf->flags &= ~MFC_BUF_FLAG_USED;\r\nspin_lock_irqsave(&dev->irqlock, flags);\r\nlist_add_tail(&mfc_buf->list, &ctx->src_queue);\r\nctx->src_queue_cnt++;\r\nspin_unlock_irqrestore(&dev->irqlock, flags);\r\n} else {\r\nmfc_err("unsupported buffer type (%d)\n", vq->type);\r\n}\r\nif (s5p_mfc_ctx_ready(ctx))\r\nset_work_bit_irqsave(ctx);\r\ns5p_mfc_hw_call(dev->mfc_ops, try_run, dev);\r\n}\r\nconst struct s5p_mfc_codec_ops *get_enc_codec_ops(void)\r\n{\r\nreturn &encoder_codec_ops;\r\n}\r\nstruct vb2_ops *get_enc_queue_ops(void)\r\n{\r\nreturn &s5p_mfc_enc_qops;\r\n}\r\nconst struct v4l2_ioctl_ops *get_enc_v4l2_ioctl_ops(void)\r\n{\r\nreturn &s5p_mfc_enc_ioctl_ops;\r\n}\r\nint s5p_mfc_enc_ctrls_setup(struct s5p_mfc_ctx *ctx)\r\n{\r\nstruct v4l2_ctrl_config cfg;\r\nint i;\r\nv4l2_ctrl_handler_init(&ctx->ctrl_handler, NUM_CTRLS);\r\nif (ctx->ctrl_handler.error) {\r\nmfc_err("v4l2_ctrl_handler_init failed\n");\r\nreturn ctx->ctrl_handler.error;\r\n}\r\nfor (i = 0; i < NUM_CTRLS; i++) {\r\nif (IS_MFC51_PRIV(controls[i].id)) {\r\nmemset(&cfg, 0, sizeof(struct v4l2_ctrl_config));\r\ncfg.ops = &s5p_mfc_enc_ctrl_ops;\r\ncfg.id = controls[i].id;\r\ncfg.min = controls[i].minimum;\r\ncfg.max = controls[i].maximum;\r\ncfg.def = controls[i].default_value;\r\ncfg.name = controls[i].name;\r\ncfg.type = controls[i].type;\r\ncfg.flags = 0;\r\nif (cfg.type == V4L2_CTRL_TYPE_MENU) {\r\ncfg.step = 0;\r\ncfg.menu_skip_mask = cfg.menu_skip_mask;\r\ncfg.qmenu = mfc51_get_menu(cfg.id);\r\n} else {\r\ncfg.step = controls[i].step;\r\ncfg.menu_skip_mask = 0;\r\n}\r\nctx->ctrls[i] = v4l2_ctrl_new_custom(&ctx->ctrl_handler,\r\n&cfg, NULL);\r\n} else {\r\nif ((controls[i].type == V4L2_CTRL_TYPE_MENU) ||\r\n(controls[i].type ==\r\nV4L2_CTRL_TYPE_INTEGER_MENU)) {\r\nctx->ctrls[i] = v4l2_ctrl_new_std_menu(\r\n&ctx->ctrl_handler,\r\n&s5p_mfc_enc_ctrl_ops, controls[i].id,\r\ncontrols[i].maximum, 0,\r\ncontrols[i].default_value);\r\n} else {\r\nctx->ctrls[i] = v4l2_ctrl_new_std(\r\n&ctx->ctrl_handler,\r\n&s5p_mfc_enc_ctrl_ops, controls[i].id,\r\ncontrols[i].minimum,\r\ncontrols[i].maximum, controls[i].step,\r\ncontrols[i].default_value);\r\n}\r\n}\r\nif (ctx->ctrl_handler.error) {\r\nmfc_err("Adding control (%d) failed\n", i);\r\nreturn ctx->ctrl_handler.error;\r\n}\r\nif (controls[i].is_volatile && ctx->ctrls[i])\r\nctx->ctrls[i]->flags |= V4L2_CTRL_FLAG_VOLATILE;\r\n}\r\nv4l2_ctrl_handler_setup(&ctx->ctrl_handler);\r\nreturn 0;\r\n}\r\nvoid s5p_mfc_enc_ctrls_delete(struct s5p_mfc_ctx *ctx)\r\n{\r\nint i;\r\nv4l2_ctrl_handler_free(&ctx->ctrl_handler);\r\nfor (i = 0; i < NUM_CTRLS; i++)\r\nctx->ctrls[i] = NULL;\r\n}\r\nvoid s5p_mfc_enc_init(struct s5p_mfc_ctx *ctx)\r\n{\r\nstruct v4l2_format f;\r\nf.fmt.pix_mp.pixelformat = DEF_SRC_FMT_ENC;\r\nctx->src_fmt = find_format(&f, MFC_FMT_RAW);\r\nf.fmt.pix_mp.pixelformat = DEF_DST_FMT_ENC;\r\nctx->dst_fmt = find_format(&f, MFC_FMT_ENC);\r\n}
