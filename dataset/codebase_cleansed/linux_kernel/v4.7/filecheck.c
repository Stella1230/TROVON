static const char *\r\nocfs2_filecheck_error(int errno)\r\n{\r\nif (!errno)\r\nreturn ocfs2_filecheck_errs[errno];\r\nBUG_ON(errno < OCFS2_FILECHECK_ERR_START ||\r\nerrno > OCFS2_FILECHECK_ERR_END);\r\nreturn ocfs2_filecheck_errs[errno - OCFS2_FILECHECK_ERR_START + 1];\r\n}\r\nstatic int ocfs2_filecheck_sysfs_wait(atomic_t *p)\r\n{\r\nschedule();\r\nreturn 0;\r\n}\r\nstatic void\r\nocfs2_filecheck_sysfs_free(struct ocfs2_filecheck_sysfs_entry *entry)\r\n{\r\nstruct ocfs2_filecheck_entry *p;\r\nif (!atomic_dec_and_test(&entry->fs_count))\r\nwait_on_atomic_t(&entry->fs_count, ocfs2_filecheck_sysfs_wait,\r\nTASK_UNINTERRUPTIBLE);\r\nspin_lock(&entry->fs_fcheck->fc_lock);\r\nwhile (!list_empty(&entry->fs_fcheck->fc_head)) {\r\np = list_first_entry(&entry->fs_fcheck->fc_head,\r\nstruct ocfs2_filecheck_entry, fe_list);\r\nlist_del(&p->fe_list);\r\nBUG_ON(!p->fe_done);\r\nkfree(p);\r\n}\r\nspin_unlock(&entry->fs_fcheck->fc_lock);\r\nkset_unregister(entry->fs_fcheckkset);\r\nkset_unregister(entry->fs_devicekset);\r\nkfree(entry->fs_fcheck);\r\nkfree(entry);\r\n}\r\nstatic void\r\nocfs2_filecheck_sysfs_add(struct ocfs2_filecheck_sysfs_entry *entry)\r\n{\r\nspin_lock(&ocfs2_filecheck_sysfs_lock);\r\nlist_add_tail(&entry->fs_list, &ocfs2_filecheck_sysfs_list);\r\nspin_unlock(&ocfs2_filecheck_sysfs_lock);\r\n}\r\nstatic int ocfs2_filecheck_sysfs_del(const char *devname)\r\n{\r\nstruct ocfs2_filecheck_sysfs_entry *p;\r\nspin_lock(&ocfs2_filecheck_sysfs_lock);\r\nlist_for_each_entry(p, &ocfs2_filecheck_sysfs_list, fs_list) {\r\nif (!strcmp(p->fs_sb->s_id, devname)) {\r\nlist_del(&p->fs_list);\r\nspin_unlock(&ocfs2_filecheck_sysfs_lock);\r\nocfs2_filecheck_sysfs_free(p);\r\nreturn 0;\r\n}\r\n}\r\nspin_unlock(&ocfs2_filecheck_sysfs_lock);\r\nreturn 1;\r\n}\r\nstatic void\r\nocfs2_filecheck_sysfs_put(struct ocfs2_filecheck_sysfs_entry *entry)\r\n{\r\nif (atomic_dec_and_test(&entry->fs_count))\r\nwake_up_atomic_t(&entry->fs_count);\r\n}\r\nstatic struct ocfs2_filecheck_sysfs_entry *\r\nocfs2_filecheck_sysfs_get(const char *devname)\r\n{\r\nstruct ocfs2_filecheck_sysfs_entry *p = NULL;\r\nspin_lock(&ocfs2_filecheck_sysfs_lock);\r\nlist_for_each_entry(p, &ocfs2_filecheck_sysfs_list, fs_list) {\r\nif (!strcmp(p->fs_sb->s_id, devname)) {\r\natomic_inc(&p->fs_count);\r\nspin_unlock(&ocfs2_filecheck_sysfs_lock);\r\nreturn p;\r\n}\r\n}\r\nspin_unlock(&ocfs2_filecheck_sysfs_lock);\r\nreturn NULL;\r\n}\r\nint ocfs2_filecheck_create_sysfs(struct super_block *sb)\r\n{\r\nint ret = 0;\r\nstruct kset *device_kset = NULL;\r\nstruct kset *fcheck_kset = NULL;\r\nstruct ocfs2_filecheck *fcheck = NULL;\r\nstruct ocfs2_filecheck_sysfs_entry *entry = NULL;\r\nstruct attribute **attrs = NULL;\r\nstruct attribute_group attrgp;\r\nif (!ocfs2_kset)\r\nreturn -ENOMEM;\r\nattrs = kmalloc(sizeof(struct attribute *) * 4, GFP_NOFS);\r\nif (!attrs) {\r\nret = -ENOMEM;\r\ngoto error;\r\n} else {\r\nattrs[0] = &ocfs2_attr_filecheck_chk.attr;\r\nattrs[1] = &ocfs2_attr_filecheck_fix.attr;\r\nattrs[2] = &ocfs2_attr_filecheck_set.attr;\r\nattrs[3] = NULL;\r\nmemset(&attrgp, 0, sizeof(attrgp));\r\nattrgp.attrs = attrs;\r\n}\r\nfcheck = kmalloc(sizeof(struct ocfs2_filecheck), GFP_NOFS);\r\nif (!fcheck) {\r\nret = -ENOMEM;\r\ngoto error;\r\n} else {\r\nINIT_LIST_HEAD(&fcheck->fc_head);\r\nspin_lock_init(&fcheck->fc_lock);\r\nfcheck->fc_max = OCFS2_FILECHECK_MINSIZE;\r\nfcheck->fc_size = 0;\r\nfcheck->fc_done = 0;\r\n}\r\nif (strlen(sb->s_id) <= 0) {\r\nmlog(ML_ERROR,\r\n"Cannot get device basename when create filecheck sysfs\n");\r\nret = -ENODEV;\r\ngoto error;\r\n}\r\ndevice_kset = kset_create_and_add(sb->s_id, NULL, &ocfs2_kset->kobj);\r\nif (!device_kset) {\r\nret = -ENOMEM;\r\ngoto error;\r\n}\r\nfcheck_kset = kset_create_and_add("filecheck", NULL,\r\n&device_kset->kobj);\r\nif (!fcheck_kset) {\r\nret = -ENOMEM;\r\ngoto error;\r\n}\r\nret = sysfs_create_group(&fcheck_kset->kobj, &attrgp);\r\nif (ret)\r\ngoto error;\r\nentry = kmalloc(sizeof(struct ocfs2_filecheck_sysfs_entry), GFP_NOFS);\r\nif (!entry) {\r\nret = -ENOMEM;\r\ngoto error;\r\n} else {\r\natomic_set(&entry->fs_count, 1);\r\nentry->fs_sb = sb;\r\nentry->fs_devicekset = device_kset;\r\nentry->fs_fcheckkset = fcheck_kset;\r\nentry->fs_fcheck = fcheck;\r\nocfs2_filecheck_sysfs_add(entry);\r\n}\r\nkfree(attrs);\r\nreturn 0;\r\nerror:\r\nkfree(attrs);\r\nkfree(entry);\r\nkfree(fcheck);\r\nkset_unregister(fcheck_kset);\r\nkset_unregister(device_kset);\r\nreturn ret;\r\n}\r\nint ocfs2_filecheck_remove_sysfs(struct super_block *sb)\r\n{\r\nreturn ocfs2_filecheck_sysfs_del(sb->s_id);\r\n}\r\nstatic int\r\nocfs2_filecheck_adjust_max(struct ocfs2_filecheck_sysfs_entry *ent,\r\nunsigned int len)\r\n{\r\nint ret;\r\nif ((len < OCFS2_FILECHECK_MINSIZE) || (len > OCFS2_FILECHECK_MAXSIZE))\r\nreturn -EINVAL;\r\nspin_lock(&ent->fs_fcheck->fc_lock);\r\nif (len < (ent->fs_fcheck->fc_size - ent->fs_fcheck->fc_done)) {\r\nmlog(ML_ERROR,\r\n"Cannot set online file check maximum entry number "\r\n"to %u due to too many pending entries(%u)\n",\r\nlen, ent->fs_fcheck->fc_size - ent->fs_fcheck->fc_done);\r\nret = -EBUSY;\r\n} else {\r\nif (len < ent->fs_fcheck->fc_size)\r\nBUG_ON(!ocfs2_filecheck_erase_entries(ent,\r\nent->fs_fcheck->fc_size - len));\r\nent->fs_fcheck->fc_max = len;\r\nret = 0;\r\n}\r\nspin_unlock(&ent->fs_fcheck->fc_lock);\r\nreturn ret;\r\n}\r\nstatic int\r\nocfs2_filecheck_args_get_long(const char *buf, size_t count,\r\nunsigned long *val)\r\n{\r\nchar buffer[OCFS2_FILECHECK_ARGS_LEN];\r\nmemcpy(buffer, buf, count);\r\nbuffer[count] = '\0';\r\nif (kstrtoul(buffer, 0, val))\r\nreturn 1;\r\nreturn 0;\r\n}\r\nstatic int\r\nocfs2_filecheck_type_parse(const char *name, unsigned int *type)\r\n{\r\nif (!strncmp(name, "fix", 4))\r\n*type = OCFS2_FILECHECK_TYPE_FIX;\r\nelse if (!strncmp(name, "check", 6))\r\n*type = OCFS2_FILECHECK_TYPE_CHK;\r\nelse if (!strncmp(name, "set", 4))\r\n*type = OCFS2_FILECHECK_TYPE_SET;\r\nelse\r\nreturn 1;\r\nreturn 0;\r\n}\r\nstatic int\r\nocfs2_filecheck_args_parse(const char *name, const char *buf, size_t count,\r\nstruct ocfs2_filecheck_args *args)\r\n{\r\nunsigned long val = 0;\r\nunsigned int type;\r\nif ((count < 1) || (count >= OCFS2_FILECHECK_ARGS_LEN))\r\nreturn 1;\r\nif (ocfs2_filecheck_type_parse(name, &type))\r\nreturn 1;\r\nif (ocfs2_filecheck_args_get_long(buf, count, &val))\r\nreturn 1;\r\nif (val <= 0)\r\nreturn 1;\r\nargs->fa_type = type;\r\nif (type == OCFS2_FILECHECK_TYPE_SET)\r\nargs->fa_len = (unsigned int)val;\r\nelse\r\nargs->fa_ino = val;\r\nreturn 0;\r\n}\r\nstatic ssize_t ocfs2_filecheck_show(struct kobject *kobj,\r\nstruct kobj_attribute *attr,\r\nchar *buf)\r\n{\r\nssize_t ret = 0, total = 0, remain = PAGE_SIZE;\r\nunsigned int type;\r\nstruct ocfs2_filecheck_entry *p;\r\nstruct ocfs2_filecheck_sysfs_entry *ent;\r\nif (ocfs2_filecheck_type_parse(attr->attr.name, &type))\r\nreturn -EINVAL;\r\nent = ocfs2_filecheck_sysfs_get(kobj->parent->name);\r\nif (!ent) {\r\nmlog(ML_ERROR,\r\n"Cannot get the corresponding entry via device basename %s\n",\r\nkobj->name);\r\nreturn -ENODEV;\r\n}\r\nif (type == OCFS2_FILECHECK_TYPE_SET) {\r\nspin_lock(&ent->fs_fcheck->fc_lock);\r\ntotal = snprintf(buf, remain, "%u\n", ent->fs_fcheck->fc_max);\r\nspin_unlock(&ent->fs_fcheck->fc_lock);\r\ngoto exit;\r\n}\r\nret = snprintf(buf, remain, "INO\t\tDONE\tERROR\n");\r\ntotal += ret;\r\nremain -= ret;\r\nspin_lock(&ent->fs_fcheck->fc_lock);\r\nlist_for_each_entry(p, &ent->fs_fcheck->fc_head, fe_list) {\r\nif (p->fe_type != type)\r\ncontinue;\r\nret = snprintf(buf + total, remain, "%lu\t\t%u\t%s\n",\r\np->fe_ino, p->fe_done,\r\nocfs2_filecheck_error(p->fe_status));\r\nif (ret < 0) {\r\ntotal = ret;\r\nbreak;\r\n}\r\nif (ret == remain) {\r\ntotal = -E2BIG;\r\nbreak;\r\n}\r\ntotal += ret;\r\nremain -= ret;\r\n}\r\nspin_unlock(&ent->fs_fcheck->fc_lock);\r\nexit:\r\nocfs2_filecheck_sysfs_put(ent);\r\nreturn total;\r\n}\r\nstatic int\r\nocfs2_filecheck_erase_entry(struct ocfs2_filecheck_sysfs_entry *ent)\r\n{\r\nstruct ocfs2_filecheck_entry *p;\r\nlist_for_each_entry(p, &ent->fs_fcheck->fc_head, fe_list) {\r\nif (p->fe_done) {\r\nlist_del(&p->fe_list);\r\nkfree(p);\r\nent->fs_fcheck->fc_size--;\r\nent->fs_fcheck->fc_done--;\r\nreturn 1;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int\r\nocfs2_filecheck_erase_entries(struct ocfs2_filecheck_sysfs_entry *ent,\r\nunsigned int count)\r\n{\r\nunsigned int i = 0;\r\nunsigned int ret = 0;\r\nwhile (i++ < count) {\r\nif (ocfs2_filecheck_erase_entry(ent))\r\nret++;\r\nelse\r\nbreak;\r\n}\r\nreturn (ret == count ? 1 : 0);\r\n}\r\nstatic void\r\nocfs2_filecheck_done_entry(struct ocfs2_filecheck_sysfs_entry *ent,\r\nstruct ocfs2_filecheck_entry *entry)\r\n{\r\nentry->fe_done = 1;\r\nspin_lock(&ent->fs_fcheck->fc_lock);\r\nent->fs_fcheck->fc_done++;\r\nspin_unlock(&ent->fs_fcheck->fc_lock);\r\n}\r\nstatic unsigned int\r\nocfs2_filecheck_handle(struct super_block *sb,\r\nunsigned long ino, unsigned int flags)\r\n{\r\nunsigned int ret = OCFS2_FILECHECK_ERR_SUCCESS;\r\nstruct inode *inode = NULL;\r\nint rc;\r\ninode = ocfs2_iget(OCFS2_SB(sb), ino, flags, 0);\r\nif (IS_ERR(inode)) {\r\nrc = (int)(-(long)inode);\r\nif (rc >= OCFS2_FILECHECK_ERR_START &&\r\nrc < OCFS2_FILECHECK_ERR_END)\r\nret = rc;\r\nelse\r\nret = OCFS2_FILECHECK_ERR_FAILED;\r\n} else\r\niput(inode);\r\nreturn ret;\r\n}\r\nstatic void\r\nocfs2_filecheck_handle_entry(struct ocfs2_filecheck_sysfs_entry *ent,\r\nstruct ocfs2_filecheck_entry *entry)\r\n{\r\nif (entry->fe_type == OCFS2_FILECHECK_TYPE_CHK)\r\nentry->fe_status = ocfs2_filecheck_handle(ent->fs_sb,\r\nentry->fe_ino, OCFS2_FI_FLAG_FILECHECK_CHK);\r\nelse if (entry->fe_type == OCFS2_FILECHECK_TYPE_FIX)\r\nentry->fe_status = ocfs2_filecheck_handle(ent->fs_sb,\r\nentry->fe_ino, OCFS2_FI_FLAG_FILECHECK_FIX);\r\nelse\r\nentry->fe_status = OCFS2_FILECHECK_ERR_UNSUPPORTED;\r\nocfs2_filecheck_done_entry(ent, entry);\r\n}\r\nstatic ssize_t ocfs2_filecheck_store(struct kobject *kobj,\r\nstruct kobj_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct ocfs2_filecheck_args args;\r\nstruct ocfs2_filecheck_entry *entry;\r\nstruct ocfs2_filecheck_sysfs_entry *ent;\r\nssize_t ret = 0;\r\nif (count == 0)\r\nreturn count;\r\nif (ocfs2_filecheck_args_parse(attr->attr.name, buf, count, &args)) {\r\nmlog(ML_ERROR, "Invalid arguments for online file check\n");\r\nreturn -EINVAL;\r\n}\r\nent = ocfs2_filecheck_sysfs_get(kobj->parent->name);\r\nif (!ent) {\r\nmlog(ML_ERROR,\r\n"Cannot get the corresponding entry via device basename %s\n",\r\nkobj->parent->name);\r\nreturn -ENODEV;\r\n}\r\nif (args.fa_type == OCFS2_FILECHECK_TYPE_SET) {\r\nret = ocfs2_filecheck_adjust_max(ent, args.fa_len);\r\ngoto exit;\r\n}\r\nentry = kmalloc(sizeof(struct ocfs2_filecheck_entry), GFP_NOFS);\r\nif (!entry) {\r\nret = -ENOMEM;\r\ngoto exit;\r\n}\r\nspin_lock(&ent->fs_fcheck->fc_lock);\r\nif ((ent->fs_fcheck->fc_size >= ent->fs_fcheck->fc_max) &&\r\n(ent->fs_fcheck->fc_done == 0)) {\r\nmlog(ML_ERROR,\r\n"Cannot do more file check "\r\n"since file check queue(%u) is full now\n",\r\nent->fs_fcheck->fc_max);\r\nret = -EBUSY;\r\nkfree(entry);\r\n} else {\r\nif ((ent->fs_fcheck->fc_size >= ent->fs_fcheck->fc_max) &&\r\n(ent->fs_fcheck->fc_done > 0)) {\r\nBUG_ON(!ocfs2_filecheck_erase_entry(ent));\r\n}\r\nentry->fe_ino = args.fa_ino;\r\nentry->fe_type = args.fa_type;\r\nentry->fe_done = 0;\r\nentry->fe_status = OCFS2_FILECHECK_ERR_INPROGRESS;\r\nlist_add_tail(&entry->fe_list, &ent->fs_fcheck->fc_head);\r\nent->fs_fcheck->fc_size++;\r\n}\r\nspin_unlock(&ent->fs_fcheck->fc_lock);\r\nif (!ret)\r\nocfs2_filecheck_handle_entry(ent, entry);\r\nexit:\r\nocfs2_filecheck_sysfs_put(ent);\r\nreturn (!ret ? count : ret);\r\n}
