int badblocks_check(struct badblocks *bb, sector_t s, int sectors,\r\nsector_t *first_bad, int *bad_sectors)\r\n{\r\nint hi;\r\nint lo;\r\nu64 *p = bb->page;\r\nint rv;\r\nsector_t target = s + sectors;\r\nunsigned seq;\r\nif (bb->shift > 0) {\r\ns >>= bb->shift;\r\ntarget += (1<<bb->shift) - 1;\r\ntarget >>= bb->shift;\r\nsectors = target - s;\r\n}\r\nretry:\r\nseq = read_seqbegin(&bb->lock);\r\nlo = 0;\r\nrv = 0;\r\nhi = bb->count;\r\nwhile (hi - lo > 1) {\r\nint mid = (lo + hi) / 2;\r\nsector_t a = BB_OFFSET(p[mid]);\r\nif (a < target)\r\nlo = mid;\r\nelse\r\nhi = mid;\r\n}\r\nif (hi > lo) {\r\nwhile (lo >= 0 &&\r\nBB_OFFSET(p[lo]) + BB_LEN(p[lo]) > s) {\r\nif (BB_OFFSET(p[lo]) < target) {\r\nif (rv != -1 && BB_ACK(p[lo]))\r\nrv = 1;\r\nelse\r\nrv = -1;\r\n*first_bad = BB_OFFSET(p[lo]);\r\n*bad_sectors = BB_LEN(p[lo]);\r\n}\r\nlo--;\r\n}\r\n}\r\nif (read_seqretry(&bb->lock, seq))\r\ngoto retry;\r\nreturn rv;\r\n}\r\nint badblocks_set(struct badblocks *bb, sector_t s, int sectors,\r\nint acknowledged)\r\n{\r\nu64 *p;\r\nint lo, hi;\r\nint rv = 0;\r\nunsigned long flags;\r\nif (bb->shift < 0)\r\nreturn 0;\r\nif (bb->shift) {\r\nsector_t next = s + sectors;\r\ns >>= bb->shift;\r\nnext += (1<<bb->shift) - 1;\r\nnext >>= bb->shift;\r\nsectors = next - s;\r\n}\r\nwrite_seqlock_irqsave(&bb->lock, flags);\r\np = bb->page;\r\nlo = 0;\r\nhi = bb->count;\r\nwhile (hi - lo > 1) {\r\nint mid = (lo + hi) / 2;\r\nsector_t a = BB_OFFSET(p[mid]);\r\nif (a <= s)\r\nlo = mid;\r\nelse\r\nhi = mid;\r\n}\r\nif (hi > lo && BB_OFFSET(p[lo]) > s)\r\nhi = lo;\r\nif (hi > lo) {\r\nsector_t a = BB_OFFSET(p[lo]);\r\nsector_t e = a + BB_LEN(p[lo]);\r\nint ack = BB_ACK(p[lo]);\r\nif (e >= s) {\r\nif (s == a && s + sectors >= e)\r\nack = acknowledged;\r\nelse\r\nack = ack && acknowledged;\r\nif (e < s + sectors)\r\ne = s + sectors;\r\nif (e - a <= BB_MAX_LEN) {\r\np[lo] = BB_MAKE(a, e-a, ack);\r\ns = e;\r\n} else {\r\nif (BB_LEN(p[lo]) != BB_MAX_LEN)\r\np[lo] = BB_MAKE(a, BB_MAX_LEN, ack);\r\ns = a + BB_MAX_LEN;\r\n}\r\nsectors = e - s;\r\n}\r\n}\r\nif (sectors && hi < bb->count) {\r\nsector_t a = BB_OFFSET(p[hi]);\r\nsector_t e = a + BB_LEN(p[hi]);\r\nint ack = BB_ACK(p[hi]);\r\nif (a <= s + sectors) {\r\nif (e <= s + sectors) {\r\ne = s + sectors;\r\nack = acknowledged;\r\n} else\r\nack = ack && acknowledged;\r\na = s;\r\nif (e - a <= BB_MAX_LEN) {\r\np[hi] = BB_MAKE(a, e-a, ack);\r\ns = e;\r\n} else {\r\np[hi] = BB_MAKE(a, BB_MAX_LEN, ack);\r\ns = a + BB_MAX_LEN;\r\n}\r\nsectors = e - s;\r\nlo = hi;\r\nhi++;\r\n}\r\n}\r\nif (sectors == 0 && hi < bb->count) {\r\nsector_t a = BB_OFFSET(p[hi]);\r\nint lolen = BB_LEN(p[lo]);\r\nint hilen = BB_LEN(p[hi]);\r\nint newlen = lolen + hilen - (s - a);\r\nif (s >= a && newlen < BB_MAX_LEN) {\r\nint ack = BB_ACK(p[lo]) && BB_ACK(p[hi]);\r\np[lo] = BB_MAKE(BB_OFFSET(p[lo]), newlen, ack);\r\nmemmove(p + hi, p + hi + 1,\r\n(bb->count - hi - 1) * 8);\r\nbb->count--;\r\n}\r\n}\r\nwhile (sectors) {\r\nif (bb->count >= MAX_BADBLOCKS) {\r\nrv = 1;\r\nbreak;\r\n} else {\r\nint this_sectors = sectors;\r\nmemmove(p + hi + 1, p + hi,\r\n(bb->count - hi) * 8);\r\nbb->count++;\r\nif (this_sectors > BB_MAX_LEN)\r\nthis_sectors = BB_MAX_LEN;\r\np[hi] = BB_MAKE(s, this_sectors, acknowledged);\r\nsectors -= this_sectors;\r\ns += this_sectors;\r\n}\r\n}\r\nbb->changed = 1;\r\nif (!acknowledged)\r\nbb->unacked_exist = 1;\r\nwrite_sequnlock_irqrestore(&bb->lock, flags);\r\nreturn rv;\r\n}\r\nint badblocks_clear(struct badblocks *bb, sector_t s, int sectors)\r\n{\r\nu64 *p;\r\nint lo, hi;\r\nsector_t target = s + sectors;\r\nint rv = 0;\r\nif (bb->shift > 0) {\r\ns += (1<<bb->shift) - 1;\r\ns >>= bb->shift;\r\ntarget >>= bb->shift;\r\nsectors = target - s;\r\n}\r\nwrite_seqlock_irq(&bb->lock);\r\np = bb->page;\r\nlo = 0;\r\nhi = bb->count;\r\nwhile (hi - lo > 1) {\r\nint mid = (lo + hi) / 2;\r\nsector_t a = BB_OFFSET(p[mid]);\r\nif (a < target)\r\nlo = mid;\r\nelse\r\nhi = mid;\r\n}\r\nif (hi > lo) {\r\nif (BB_OFFSET(p[lo]) + BB_LEN(p[lo]) > target) {\r\nint ack = BB_ACK(p[lo]);\r\nsector_t a = BB_OFFSET(p[lo]);\r\nsector_t end = a + BB_LEN(p[lo]);\r\nif (a < s) {\r\nif (bb->count >= MAX_BADBLOCKS) {\r\nrv = -ENOSPC;\r\ngoto out;\r\n}\r\nmemmove(p+lo+1, p+lo, (bb->count - lo) * 8);\r\nbb->count++;\r\np[lo] = BB_MAKE(a, s-a, ack);\r\nlo++;\r\n}\r\np[lo] = BB_MAKE(target, end - target, ack);\r\nhi = lo;\r\nlo--;\r\n}\r\nwhile (lo >= 0 &&\r\nBB_OFFSET(p[lo]) + BB_LEN(p[lo]) > s) {\r\nif (BB_OFFSET(p[lo]) < s) {\r\nint ack = BB_ACK(p[lo]);\r\nsector_t start = BB_OFFSET(p[lo]);\r\np[lo] = BB_MAKE(start, s - start, ack);\r\nbreak;\r\n}\r\nlo--;\r\n}\r\nif (hi - lo > 1) {\r\nmemmove(p+lo+1, p+hi, (bb->count - hi) * 8);\r\nbb->count -= (hi - lo - 1);\r\n}\r\n}\r\nbb->changed = 1;\r\nout:\r\nwrite_sequnlock_irq(&bb->lock);\r\nreturn rv;\r\n}\r\nvoid ack_all_badblocks(struct badblocks *bb)\r\n{\r\nif (bb->page == NULL || bb->changed)\r\nreturn;\r\nwrite_seqlock_irq(&bb->lock);\r\nif (bb->changed == 0 && bb->unacked_exist) {\r\nu64 *p = bb->page;\r\nint i;\r\nfor (i = 0; i < bb->count ; i++) {\r\nif (!BB_ACK(p[i])) {\r\nsector_t start = BB_OFFSET(p[i]);\r\nint len = BB_LEN(p[i]);\r\np[i] = BB_MAKE(start, len, 1);\r\n}\r\n}\r\nbb->unacked_exist = 0;\r\n}\r\nwrite_sequnlock_irq(&bb->lock);\r\n}\r\nssize_t badblocks_show(struct badblocks *bb, char *page, int unack)\r\n{\r\nsize_t len;\r\nint i;\r\nu64 *p = bb->page;\r\nunsigned seq;\r\nif (bb->shift < 0)\r\nreturn 0;\r\nretry:\r\nseq = read_seqbegin(&bb->lock);\r\nlen = 0;\r\ni = 0;\r\nwhile (len < PAGE_SIZE && i < bb->count) {\r\nsector_t s = BB_OFFSET(p[i]);\r\nunsigned int length = BB_LEN(p[i]);\r\nint ack = BB_ACK(p[i]);\r\ni++;\r\nif (unack && ack)\r\ncontinue;\r\nlen += snprintf(page+len, PAGE_SIZE-len, "%llu %u\n",\r\n(unsigned long long)s << bb->shift,\r\nlength << bb->shift);\r\n}\r\nif (unack && len == 0)\r\nbb->unacked_exist = 0;\r\nif (read_seqretry(&bb->lock, seq))\r\ngoto retry;\r\nreturn len;\r\n}\r\nssize_t badblocks_store(struct badblocks *bb, const char *page, size_t len,\r\nint unack)\r\n{\r\nunsigned long long sector;\r\nint length;\r\nchar newline;\r\nswitch (sscanf(page, "%llu %d%c", &sector, &length, &newline)) {\r\ncase 3:\r\nif (newline != '\n')\r\nreturn -EINVAL;\r\ncase 2:\r\nif (length <= 0)\r\nreturn -EINVAL;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nif (badblocks_set(bb, sector, length, !unack))\r\nreturn -ENOSPC;\r\nelse\r\nreturn len;\r\n}\r\nstatic int __badblocks_init(struct device *dev, struct badblocks *bb,\r\nint enable)\r\n{\r\nbb->dev = dev;\r\nbb->count = 0;\r\nif (enable)\r\nbb->shift = 0;\r\nelse\r\nbb->shift = -1;\r\nif (dev)\r\nbb->page = devm_kzalloc(dev, PAGE_SIZE, GFP_KERNEL);\r\nelse\r\nbb->page = kzalloc(PAGE_SIZE, GFP_KERNEL);\r\nif (!bb->page) {\r\nbb->shift = -1;\r\nreturn -ENOMEM;\r\n}\r\nseqlock_init(&bb->lock);\r\nreturn 0;\r\n}\r\nint badblocks_init(struct badblocks *bb, int enable)\r\n{\r\nreturn __badblocks_init(NULL, bb, enable);\r\n}\r\nint devm_init_badblocks(struct device *dev, struct badblocks *bb)\r\n{\r\nif (!bb)\r\nreturn -EINVAL;\r\nreturn __badblocks_init(dev, bb, 1);\r\n}\r\nvoid badblocks_exit(struct badblocks *bb)\r\n{\r\nif (!bb)\r\nreturn;\r\nif (bb->dev)\r\ndevm_kfree(bb->dev, bb->page);\r\nelse\r\nkfree(bb->page);\r\nbb->page = NULL;\r\n}
