static int cs42xx8_set_dai_sysclk(struct snd_soc_dai *codec_dai,\r\nint clk_id, unsigned int freq, int dir)\r\n{\r\nstruct snd_soc_codec *codec = codec_dai->codec;\r\nstruct cs42xx8_priv *cs42xx8 = snd_soc_codec_get_drvdata(codec);\r\ncs42xx8->sysclk = freq;\r\nreturn 0;\r\n}\r\nstatic int cs42xx8_set_dai_fmt(struct snd_soc_dai *codec_dai,\r\nunsigned int format)\r\n{\r\nstruct snd_soc_codec *codec = codec_dai->codec;\r\nstruct cs42xx8_priv *cs42xx8 = snd_soc_codec_get_drvdata(codec);\r\nu32 val;\r\nswitch (format & SND_SOC_DAIFMT_FORMAT_MASK) {\r\ncase SND_SOC_DAIFMT_LEFT_J:\r\nval = CS42XX8_INTF_DAC_DIF_LEFTJ | CS42XX8_INTF_ADC_DIF_LEFTJ;\r\nbreak;\r\ncase SND_SOC_DAIFMT_I2S:\r\nval = CS42XX8_INTF_DAC_DIF_I2S | CS42XX8_INTF_ADC_DIF_I2S;\r\nbreak;\r\ncase SND_SOC_DAIFMT_RIGHT_J:\r\nval = CS42XX8_INTF_DAC_DIF_RIGHTJ | CS42XX8_INTF_ADC_DIF_RIGHTJ;\r\nbreak;\r\ncase SND_SOC_DAIFMT_DSP_A:\r\nval = CS42XX8_INTF_DAC_DIF_TDM | CS42XX8_INTF_ADC_DIF_TDM;\r\nbreak;\r\ndefault:\r\ndev_err(codec->dev, "unsupported dai format\n");\r\nreturn -EINVAL;\r\n}\r\nregmap_update_bits(cs42xx8->regmap, CS42XX8_INTF,\r\nCS42XX8_INTF_DAC_DIF_MASK |\r\nCS42XX8_INTF_ADC_DIF_MASK, val);\r\nswitch (format & SND_SOC_DAIFMT_MASTER_MASK) {\r\ncase SND_SOC_DAIFMT_CBS_CFS:\r\ncs42xx8->slave_mode = true;\r\nbreak;\r\ncase SND_SOC_DAIFMT_CBM_CFM:\r\ncs42xx8->slave_mode = false;\r\nbreak;\r\ndefault:\r\ndev_err(codec->dev, "unsupported master/slave mode\n");\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int cs42xx8_hw_params(struct snd_pcm_substream *substream,\r\nstruct snd_pcm_hw_params *params,\r\nstruct snd_soc_dai *dai)\r\n{\r\nstruct snd_soc_codec *codec = dai->codec;\r\nstruct cs42xx8_priv *cs42xx8 = snd_soc_codec_get_drvdata(codec);\r\nbool tx = substream->stream == SNDRV_PCM_STREAM_PLAYBACK;\r\nu32 ratio = cs42xx8->sysclk / params_rate(params);\r\nu32 i, fm, val, mask;\r\nif (tx)\r\ncs42xx8->tx_channels = params_channels(params);\r\nfor (i = 0; i < ARRAY_SIZE(cs42xx8_ratios); i++) {\r\nif (cs42xx8_ratios[i].ratio == ratio)\r\nbreak;\r\n}\r\nif (i == ARRAY_SIZE(cs42xx8_ratios)) {\r\ndev_err(codec->dev, "unsupported sysclk ratio\n");\r\nreturn -EINVAL;\r\n}\r\nmask = CS42XX8_FUNCMOD_MFREQ_MASK;\r\nval = cs42xx8_ratios[i].mclk;\r\nfm = cs42xx8->slave_mode ? CS42XX8_FM_AUTO : cs42xx8_ratios[i].speed;\r\nregmap_update_bits(cs42xx8->regmap, CS42XX8_FUNCMOD,\r\nCS42XX8_FUNCMOD_xC_FM_MASK(tx) | mask,\r\nCS42XX8_FUNCMOD_xC_FM(tx, fm) | val);\r\nreturn 0;\r\n}\r\nstatic int cs42xx8_digital_mute(struct snd_soc_dai *dai, int mute)\r\n{\r\nstruct snd_soc_codec *codec = dai->codec;\r\nstruct cs42xx8_priv *cs42xx8 = snd_soc_codec_get_drvdata(codec);\r\nu8 dac_unmute = cs42xx8->tx_channels ?\r\n~((0x1 << cs42xx8->tx_channels) - 1) : 0;\r\nregmap_write(cs42xx8->regmap, CS42XX8_DACMUTE,\r\nmute ? CS42XX8_DACMUTE_ALL : dac_unmute);\r\nreturn 0;\r\n}\r\nstatic bool cs42xx8_volatile_register(struct device *dev, unsigned int reg)\r\n{\r\nswitch (reg) {\r\ncase CS42XX8_STATUS:\r\nreturn true;\r\ndefault:\r\nreturn false;\r\n}\r\n}\r\nstatic bool cs42xx8_writeable_register(struct device *dev, unsigned int reg)\r\n{\r\nswitch (reg) {\r\ncase CS42XX8_CHIPID:\r\ncase CS42XX8_STATUS:\r\nreturn false;\r\ndefault:\r\nreturn true;\r\n}\r\n}\r\nstatic int cs42xx8_codec_probe(struct snd_soc_codec *codec)\r\n{\r\nstruct cs42xx8_priv *cs42xx8 = snd_soc_codec_get_drvdata(codec);\r\nstruct snd_soc_dapm_context *dapm = snd_soc_codec_get_dapm(codec);\r\nswitch (cs42xx8->drvdata->num_adcs) {\r\ncase 3:\r\nsnd_soc_add_codec_controls(codec, cs42xx8_adc3_snd_controls,\r\nARRAY_SIZE(cs42xx8_adc3_snd_controls));\r\nsnd_soc_dapm_new_controls(dapm, cs42xx8_adc3_dapm_widgets,\r\nARRAY_SIZE(cs42xx8_adc3_dapm_widgets));\r\nsnd_soc_dapm_add_routes(dapm, cs42xx8_adc3_dapm_routes,\r\nARRAY_SIZE(cs42xx8_adc3_dapm_routes));\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nregmap_write(cs42xx8->regmap, CS42XX8_DACMUTE, CS42XX8_DACMUTE_ALL);\r\nreturn 0;\r\n}\r\nint cs42xx8_probe(struct device *dev, struct regmap *regmap)\r\n{\r\nconst struct of_device_id *of_id;\r\nstruct cs42xx8_priv *cs42xx8;\r\nint ret, val, i;\r\nif (IS_ERR(regmap)) {\r\nret = PTR_ERR(regmap);\r\ndev_err(dev, "failed to allocate regmap: %d\n", ret);\r\nreturn ret;\r\n}\r\ncs42xx8 = devm_kzalloc(dev, sizeof(*cs42xx8), GFP_KERNEL);\r\nif (cs42xx8 == NULL)\r\nreturn -ENOMEM;\r\ncs42xx8->regmap = regmap;\r\ndev_set_drvdata(dev, cs42xx8);\r\nof_id = of_match_device(cs42xx8_of_match, dev);\r\nif (of_id)\r\ncs42xx8->drvdata = of_id->data;\r\nif (!cs42xx8->drvdata) {\r\ndev_err(dev, "failed to find driver data\n");\r\nreturn -EINVAL;\r\n}\r\ncs42xx8->clk = devm_clk_get(dev, "mclk");\r\nif (IS_ERR(cs42xx8->clk)) {\r\ndev_err(dev, "failed to get the clock: %ld\n",\r\nPTR_ERR(cs42xx8->clk));\r\nreturn -EINVAL;\r\n}\r\ncs42xx8->sysclk = clk_get_rate(cs42xx8->clk);\r\nfor (i = 0; i < ARRAY_SIZE(cs42xx8->supplies); i++)\r\ncs42xx8->supplies[i].supply = cs42xx8_supply_names[i];\r\nret = devm_regulator_bulk_get(dev,\r\nARRAY_SIZE(cs42xx8->supplies), cs42xx8->supplies);\r\nif (ret) {\r\ndev_err(dev, "failed to request supplies: %d\n", ret);\r\nreturn ret;\r\n}\r\nret = regulator_bulk_enable(ARRAY_SIZE(cs42xx8->supplies),\r\ncs42xx8->supplies);\r\nif (ret) {\r\ndev_err(dev, "failed to enable supplies: %d\n", ret);\r\nreturn ret;\r\n}\r\nmsleep(5);\r\nregcache_cache_bypass(cs42xx8->regmap, true);\r\nret = regmap_read(cs42xx8->regmap, CS42XX8_CHIPID, &val);\r\nif (ret < 0) {\r\ndev_err(dev, "failed to get device ID, ret = %d", ret);\r\ngoto err_enable;\r\n}\r\nif (((val & CS42XX8_CHIPID_CHIP_ID_MASK) >> 4) != 0x00) {\r\ndev_err(dev, "unmatched chip ID: %d\n",\r\n(val & CS42XX8_CHIPID_CHIP_ID_MASK) >> 4);\r\nret = -EINVAL;\r\ngoto err_enable;\r\n}\r\ndev_info(dev, "found device, revision %X\n",\r\nval & CS42XX8_CHIPID_REV_ID_MASK);\r\nregcache_cache_bypass(cs42xx8->regmap, false);\r\ncs42xx8_dai.name = cs42xx8->drvdata->name;\r\ncs42xx8_dai.capture.channels_max = cs42xx8->drvdata->num_adcs * 2;\r\nret = snd_soc_register_codec(dev, &cs42xx8_driver, &cs42xx8_dai, 1);\r\nif (ret) {\r\ndev_err(dev, "failed to register codec:%d\n", ret);\r\ngoto err_enable;\r\n}\r\nregcache_cache_only(cs42xx8->regmap, true);\r\nerr_enable:\r\nregulator_bulk_disable(ARRAY_SIZE(cs42xx8->supplies),\r\ncs42xx8->supplies);\r\nreturn ret;\r\n}\r\nstatic int cs42xx8_runtime_resume(struct device *dev)\r\n{\r\nstruct cs42xx8_priv *cs42xx8 = dev_get_drvdata(dev);\r\nint ret;\r\nret = clk_prepare_enable(cs42xx8->clk);\r\nif (ret) {\r\ndev_err(dev, "failed to enable mclk: %d\n", ret);\r\nreturn ret;\r\n}\r\nret = regulator_bulk_enable(ARRAY_SIZE(cs42xx8->supplies),\r\ncs42xx8->supplies);\r\nif (ret) {\r\ndev_err(dev, "failed to enable supplies: %d\n", ret);\r\ngoto err_clk;\r\n}\r\nmsleep(5);\r\nregcache_cache_only(cs42xx8->regmap, false);\r\nret = regcache_sync(cs42xx8->regmap);\r\nif (ret) {\r\ndev_err(dev, "failed to sync regmap: %d\n", ret);\r\ngoto err_bulk;\r\n}\r\nreturn 0;\r\nerr_bulk:\r\nregulator_bulk_disable(ARRAY_SIZE(cs42xx8->supplies),\r\ncs42xx8->supplies);\r\nerr_clk:\r\nclk_disable_unprepare(cs42xx8->clk);\r\nreturn ret;\r\n}\r\nstatic int cs42xx8_runtime_suspend(struct device *dev)\r\n{\r\nstruct cs42xx8_priv *cs42xx8 = dev_get_drvdata(dev);\r\nregcache_cache_only(cs42xx8->regmap, true);\r\nregulator_bulk_disable(ARRAY_SIZE(cs42xx8->supplies),\r\ncs42xx8->supplies);\r\nclk_disable_unprepare(cs42xx8->clk);\r\nreturn 0;\r\n}
