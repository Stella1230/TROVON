static inline unsigned ep93xx_ac97_read_reg(struct ep93xx_ac97_info *info,\r\nunsigned reg)\r\n{\r\nreturn __raw_readl(info->regs + reg);\r\n}\r\nstatic inline void ep93xx_ac97_write_reg(struct ep93xx_ac97_info *info,\r\nunsigned reg, unsigned val)\r\n{\r\n__raw_writel(val, info->regs + reg);\r\n}\r\nstatic unsigned short ep93xx_ac97_read(struct snd_ac97 *ac97,\r\nunsigned short reg)\r\n{\r\nstruct ep93xx_ac97_info *info = ep93xx_ac97_info;\r\nunsigned short val;\r\nmutex_lock(&info->lock);\r\nep93xx_ac97_write_reg(info, AC97S1DATA, reg);\r\nep93xx_ac97_write_reg(info, AC97IM, AC97_SLOT2RXVALID);\r\nif (!wait_for_completion_timeout(&info->done, AC97_TIMEOUT)) {\r\ndev_warn(info->dev, "timeout reading register %x\n", reg);\r\nmutex_unlock(&info->lock);\r\nreturn -ETIMEDOUT;\r\n}\r\nval = (unsigned short)ep93xx_ac97_read_reg(info, AC97S2DATA);\r\nmutex_unlock(&info->lock);\r\nreturn val;\r\n}\r\nstatic void ep93xx_ac97_write(struct snd_ac97 *ac97,\r\nunsigned short reg,\r\nunsigned short val)\r\n{\r\nstruct ep93xx_ac97_info *info = ep93xx_ac97_info;\r\nmutex_lock(&info->lock);\r\nep93xx_ac97_write_reg(info, AC97S2DATA, val);\r\nep93xx_ac97_write_reg(info, AC97S1DATA, reg);\r\nep93xx_ac97_write_reg(info, AC97IM, AC97_SLOT2TXCOMPLETE);\r\nif (!wait_for_completion_timeout(&info->done, AC97_TIMEOUT))\r\ndev_warn(info->dev, "timeout writing register %x\n", reg);\r\nmutex_unlock(&info->lock);\r\n}\r\nstatic void ep93xx_ac97_warm_reset(struct snd_ac97 *ac97)\r\n{\r\nstruct ep93xx_ac97_info *info = ep93xx_ac97_info;\r\nmutex_lock(&info->lock);\r\nep93xx_ac97_write_reg(info, AC97SYNC, AC97SYNC_TIMEDSYNC);\r\nep93xx_ac97_write_reg(info, AC97IM, AC97_CODECREADY);\r\nif (!wait_for_completion_timeout(&info->done, AC97_TIMEOUT))\r\ndev_warn(info->dev, "codec warm reset timeout\n");\r\nmutex_unlock(&info->lock);\r\n}\r\nstatic void ep93xx_ac97_cold_reset(struct snd_ac97 *ac97)\r\n{\r\nstruct ep93xx_ac97_info *info = ep93xx_ac97_info;\r\nmutex_lock(&info->lock);\r\nep93xx_ac97_write_reg(info, AC97GCR, 0);\r\nep93xx_ac97_write_reg(info, AC97EOI, AC97EOI_CODECREADY | AC97EOI_WINT);\r\nep93xx_ac97_write_reg(info, AC97GCR, AC97GCR_AC97IFE);\r\nep93xx_ac97_write_reg(info, AC97RESET, AC97RESET_TIMEDRESET);\r\nep93xx_ac97_write_reg(info, AC97IM, AC97_CODECREADY);\r\nif (!wait_for_completion_timeout(&info->done, AC97_TIMEOUT))\r\ndev_warn(info->dev, "codec cold reset timeout\n");\r\nusleep_range(15000, 20000);\r\nmutex_unlock(&info->lock);\r\n}\r\nstatic irqreturn_t ep93xx_ac97_interrupt(int irq, void *dev_id)\r\n{\r\nstruct ep93xx_ac97_info *info = dev_id;\r\nunsigned status, mask;\r\nstatus = ep93xx_ac97_read_reg(info, AC97GIS);\r\nmask = ep93xx_ac97_read_reg(info, AC97IM);\r\nmask &= ~status;\r\nep93xx_ac97_write_reg(info, AC97IM, mask);\r\ncomplete(&info->done);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int ep93xx_ac97_trigger(struct snd_pcm_substream *substream,\r\nint cmd, struct snd_soc_dai *dai)\r\n{\r\nstruct ep93xx_ac97_info *info = snd_soc_dai_get_drvdata(dai);\r\nunsigned v = 0;\r\nswitch (cmd) {\r\ncase SNDRV_PCM_TRIGGER_START:\r\ncase SNDRV_PCM_TRIGGER_RESUME:\r\ncase SNDRV_PCM_TRIGGER_PAUSE_RELEASE:\r\nif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {\r\nv |= AC97TXCR_CM;\r\nv |= AC97TXCR_TX3 | AC97TXCR_TX4;\r\nv |= AC97TXCR_TEN;\r\nep93xx_ac97_write_reg(info, AC97TXCR(1), v);\r\n} else {\r\nv |= AC97RXCR_CM;\r\nv |= AC97RXCR_RX3 | AC97RXCR_RX4;\r\nv |= AC97RXCR_REN;\r\nep93xx_ac97_write_reg(info, AC97RXCR(1), v);\r\n}\r\nbreak;\r\ncase SNDRV_PCM_TRIGGER_STOP:\r\ncase SNDRV_PCM_TRIGGER_SUSPEND:\r\ncase SNDRV_PCM_TRIGGER_PAUSE_PUSH:\r\nif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {\r\nunsigned long timeout = jiffies + AC97_TIMEOUT;\r\ndo {\r\nv = ep93xx_ac97_read_reg(info, AC97SR(1));\r\nif (time_after(jiffies, timeout)) {\r\ndev_warn(info->dev, "TX timeout\n");\r\nbreak;\r\n}\r\n} while (!(v & (AC97SR_TXFE | AC97SR_TXUE)));\r\nep93xx_ac97_write_reg(info, AC97TXCR(1), 0);\r\n} else {\r\nep93xx_ac97_write_reg(info, AC97RXCR(1), 0);\r\n}\r\nbreak;\r\ndefault:\r\ndev_warn(info->dev, "unknown command %d\n", cmd);\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int ep93xx_ac97_dai_probe(struct snd_soc_dai *dai)\r\n{\r\nstruct ep93xx_ac97_info *info = snd_soc_dai_get_drvdata(dai);\r\ninfo->dma_params_tx.filter_data = &ep93xx_ac97_pcm_out;\r\ninfo->dma_params_rx.filter_data = &ep93xx_ac97_pcm_in;\r\ndai->playback_dma_data = &info->dma_params_tx;\r\ndai->capture_dma_data = &info->dma_params_rx;\r\nreturn 0;\r\n}\r\nstatic int ep93xx_ac97_probe(struct platform_device *pdev)\r\n{\r\nstruct ep93xx_ac97_info *info;\r\nstruct resource *res;\r\nunsigned int irq;\r\nint ret;\r\ninfo = devm_kzalloc(&pdev->dev, sizeof(*info), GFP_KERNEL);\r\nif (!info)\r\nreturn -ENOMEM;\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\ninfo->regs = devm_ioremap_resource(&pdev->dev, res);\r\nif (IS_ERR(info->regs))\r\nreturn PTR_ERR(info->regs);\r\nirq = platform_get_irq(pdev, 0);\r\nif (!irq)\r\nreturn -ENODEV;\r\nret = devm_request_irq(&pdev->dev, irq, ep93xx_ac97_interrupt,\r\nIRQF_TRIGGER_HIGH, pdev->name, info);\r\nif (ret)\r\ngoto fail;\r\ndev_set_drvdata(&pdev->dev, info);\r\nmutex_init(&info->lock);\r\ninit_completion(&info->done);\r\ninfo->dev = &pdev->dev;\r\nep93xx_ac97_info = info;\r\nplatform_set_drvdata(pdev, info);\r\nret = snd_soc_set_ac97_ops(&ep93xx_ac97_ops);\r\nif (ret)\r\ngoto fail;\r\nret = snd_soc_register_component(&pdev->dev, &ep93xx_ac97_component,\r\n&ep93xx_ac97_dai, 1);\r\nif (ret)\r\ngoto fail;\r\nret = devm_ep93xx_pcm_platform_register(&pdev->dev);\r\nif (ret)\r\ngoto fail_unregister;\r\nreturn 0;\r\nfail_unregister:\r\nsnd_soc_unregister_component(&pdev->dev);\r\nfail:\r\nep93xx_ac97_info = NULL;\r\nsnd_soc_set_ac97_ops(NULL);\r\nreturn ret;\r\n}\r\nstatic int ep93xx_ac97_remove(struct platform_device *pdev)\r\n{\r\nstruct ep93xx_ac97_info *info = platform_get_drvdata(pdev);\r\nsnd_soc_unregister_component(&pdev->dev);\r\nep93xx_ac97_write_reg(info, AC97GCR, 0);\r\nep93xx_ac97_info = NULL;\r\nsnd_soc_set_ac97_ops(NULL);\r\nreturn 0;\r\n}
