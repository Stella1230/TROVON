void saa7146_setgpio(struct saa7146_dev *dev, int port, u32 data)\r\n{\r\nu32 value = 0;\r\nBUG_ON(port > 3);\r\nvalue = saa7146_read(dev, GPIO_CTRL);\r\nvalue &= ~(0xff << (8*port));\r\nvalue |= (data << (8*port));\r\nsaa7146_write(dev, GPIO_CTRL, value);\r\n}\r\nstatic inline int saa7146_wait_for_debi_done_sleep(struct saa7146_dev *dev,\r\nunsigned long us1, unsigned long us2)\r\n{\r\nunsigned long timeout;\r\nint err;\r\ntimeout = jiffies + usecs_to_jiffies(us1);\r\nwhile (1) {\r\nerr = time_after(jiffies, timeout);\r\nif (saa7146_read(dev, MC2) & 2)\r\nbreak;\r\nif (err) {\r\npr_debug("%s: %s timed out while waiting for registers getting programmed\n",\r\ndev->name, __func__);\r\nreturn -ETIMEDOUT;\r\n}\r\nmsleep(1);\r\n}\r\ntimeout = jiffies + usecs_to_jiffies(us2);\r\nwhile (1) {\r\nerr = time_after(jiffies, timeout);\r\nif (!(saa7146_read(dev, PSR) & SPCI_DEBI_S))\r\nbreak;\r\nsaa7146_read(dev, MC2);\r\nif (err) {\r\nDEB_S("%s: %s timed out while waiting for transfer completion\n",\r\ndev->name, __func__);\r\nreturn -ETIMEDOUT;\r\n}\r\nmsleep(1);\r\n}\r\nreturn 0;\r\n}\r\nstatic inline int saa7146_wait_for_debi_done_busyloop(struct saa7146_dev *dev,\r\nunsigned long us1, unsigned long us2)\r\n{\r\nunsigned long loops;\r\nloops = us1;\r\nwhile (1) {\r\nif (saa7146_read(dev, MC2) & 2)\r\nbreak;\r\nif (!loops--) {\r\npr_err("%s: %s timed out while waiting for registers getting programmed\n",\r\ndev->name, __func__);\r\nreturn -ETIMEDOUT;\r\n}\r\nudelay(1);\r\n}\r\nloops = us2 / 5;\r\nwhile (1) {\r\nif (!(saa7146_read(dev, PSR) & SPCI_DEBI_S))\r\nbreak;\r\nsaa7146_read(dev, MC2);\r\nif (!loops--) {\r\nDEB_S("%s: %s timed out while waiting for transfer completion\n",\r\ndev->name, __func__);\r\nreturn -ETIMEDOUT;\r\n}\r\nudelay(5);\r\n}\r\nreturn 0;\r\n}\r\nint saa7146_wait_for_debi_done(struct saa7146_dev *dev, int nobusyloop)\r\n{\r\nif (nobusyloop)\r\nreturn saa7146_wait_for_debi_done_sleep(dev, 50000, 250000);\r\nelse\r\nreturn saa7146_wait_for_debi_done_busyloop(dev, 50000, 250000);\r\n}\r\nstatic struct scatterlist* vmalloc_to_sg(unsigned char *virt, int nr_pages)\r\n{\r\nstruct scatterlist *sglist;\r\nstruct page *pg;\r\nint i;\r\nsglist = kcalloc(nr_pages, sizeof(struct scatterlist), GFP_KERNEL);\r\nif (NULL == sglist)\r\nreturn NULL;\r\nsg_init_table(sglist, nr_pages);\r\nfor (i = 0; i < nr_pages; i++, virt += PAGE_SIZE) {\r\npg = vmalloc_to_page(virt);\r\nif (NULL == pg)\r\ngoto err;\r\nBUG_ON(PageHighMem(pg));\r\nsg_set_page(&sglist[i], pg, PAGE_SIZE, 0);\r\n}\r\nreturn sglist;\r\nerr:\r\nkfree(sglist);\r\nreturn NULL;\r\n}\r\nvoid *saa7146_vmalloc_build_pgtable(struct pci_dev *pci, long length, struct saa7146_pgtable *pt)\r\n{\r\nint pages = (length+PAGE_SIZE-1)/PAGE_SIZE;\r\nvoid *mem = vmalloc_32(length);\r\nint slen = 0;\r\nif (NULL == mem)\r\ngoto err_null;\r\nif (!(pt->slist = vmalloc_to_sg(mem, pages)))\r\ngoto err_free_mem;\r\nif (saa7146_pgtable_alloc(pci, pt))\r\ngoto err_free_slist;\r\npt->nents = pages;\r\nslen = pci_map_sg(pci,pt->slist,pt->nents,PCI_DMA_FROMDEVICE);\r\nif (0 == slen)\r\ngoto err_free_pgtable;\r\nif (0 != saa7146_pgtable_build_single(pci, pt, pt->slist, slen))\r\ngoto err_unmap_sg;\r\nreturn mem;\r\nerr_unmap_sg:\r\npci_unmap_sg(pci, pt->slist, pt->nents, PCI_DMA_FROMDEVICE);\r\nerr_free_pgtable:\r\nsaa7146_pgtable_free(pci, pt);\r\nerr_free_slist:\r\nkfree(pt->slist);\r\npt->slist = NULL;\r\nerr_free_mem:\r\nvfree(mem);\r\nerr_null:\r\nreturn NULL;\r\n}\r\nvoid saa7146_vfree_destroy_pgtable(struct pci_dev *pci, void *mem, struct saa7146_pgtable *pt)\r\n{\r\npci_unmap_sg(pci, pt->slist, pt->nents, PCI_DMA_FROMDEVICE);\r\nsaa7146_pgtable_free(pci, pt);\r\nkfree(pt->slist);\r\npt->slist = NULL;\r\nvfree(mem);\r\n}\r\nvoid saa7146_pgtable_free(struct pci_dev *pci, struct saa7146_pgtable *pt)\r\n{\r\nif (NULL == pt->cpu)\r\nreturn;\r\npci_free_consistent(pci, pt->size, pt->cpu, pt->dma);\r\npt->cpu = NULL;\r\n}\r\nint saa7146_pgtable_alloc(struct pci_dev *pci, struct saa7146_pgtable *pt)\r\n{\r\n__le32 *cpu;\r\ndma_addr_t dma_addr = 0;\r\ncpu = pci_alloc_consistent(pci, PAGE_SIZE, &dma_addr);\r\nif (NULL == cpu) {\r\nreturn -ENOMEM;\r\n}\r\npt->size = PAGE_SIZE;\r\npt->cpu = cpu;\r\npt->dma = dma_addr;\r\nreturn 0;\r\n}\r\nint saa7146_pgtable_build_single(struct pci_dev *pci, struct saa7146_pgtable *pt,\r\nstruct scatterlist *list, int sglen )\r\n{\r\n__le32 *ptr, fill;\r\nint nr_pages = 0;\r\nint i,p;\r\nBUG_ON(0 == sglen);\r\nBUG_ON(list->offset > PAGE_SIZE);\r\npt->offset = list->offset;\r\nptr = pt->cpu;\r\nfor (i = 0; i < sglen; i++, list++) {\r\nfor (p = 0; p * 4096 < list->length; p++, ptr++) {\r\n*ptr = cpu_to_le32(sg_dma_address(list) + p * 4096);\r\nnr_pages++;\r\n}\r\n}\r\nfill = *(ptr-1);\r\nfor(i=nr_pages;i<1024;i++) {\r\n*ptr++ = fill;\r\n}\r\nreturn 0;\r\n}\r\nstatic irqreturn_t interrupt_hw(int irq, void *dev_id)\r\n{\r\nstruct saa7146_dev *dev = dev_id;\r\nu32 isr;\r\nu32 ack_isr;\r\nack_isr = isr = saa7146_read(dev, ISR);\r\nif ( 0 == isr ) {\r\nreturn IRQ_NONE;\r\n}\r\nif (dev->ext) {\r\nif (dev->ext->irq_mask & isr) {\r\nif (dev->ext->irq_func)\r\ndev->ext->irq_func(dev, &isr);\r\nisr &= ~dev->ext->irq_mask;\r\n}\r\n}\r\nif (0 != (isr & (MASK_27))) {\r\nDEB_INT("irq: RPS0 (0x%08x)\n", isr);\r\nif (dev->vv_data && dev->vv_callback)\r\ndev->vv_callback(dev,isr);\r\nisr &= ~MASK_27;\r\n}\r\nif (0 != (isr & (MASK_28))) {\r\nif (dev->vv_data && dev->vv_callback)\r\ndev->vv_callback(dev,isr);\r\nisr &= ~MASK_28;\r\n}\r\nif (0 != (isr & (MASK_16|MASK_17))) {\r\nSAA7146_IER_DISABLE(dev, MASK_16|MASK_17);\r\nif (0 != dev->i2c_op) {\r\ndev->i2c_op = 0;\r\nwake_up(&dev->i2c_wq);\r\n} else {\r\nu32 psr = saa7146_read(dev, PSR);\r\nu32 ssr = saa7146_read(dev, SSR);\r\npr_warn("%s: unexpected i2c irq: isr %08x psr %08x ssr %08x\n",\r\ndev->name, isr, psr, ssr);\r\n}\r\nisr &= ~(MASK_16|MASK_17);\r\n}\r\nif( 0 != isr ) {\r\nERR("warning: interrupt enabled, but not handled properly.(0x%08x)\n",\r\nisr);\r\nERR("disabling interrupt source(s)!\n");\r\nSAA7146_IER_DISABLE(dev,isr);\r\n}\r\nsaa7146_write(dev, ISR, ack_isr);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int saa7146_init_one(struct pci_dev *pci, const struct pci_device_id *ent)\r\n{\r\nstruct saa7146_pci_extension_data *pci_ext = (struct saa7146_pci_extension_data *)ent->driver_data;\r\nstruct saa7146_extension *ext = pci_ext->ext;\r\nstruct saa7146_dev *dev;\r\nint err = -ENOMEM;\r\ndev = kzalloc(sizeof(struct saa7146_dev), GFP_KERNEL);\r\nif (!dev) {\r\nERR("out of memory\n");\r\ngoto out;\r\n}\r\nsprintf(dev->name, "saa7146 (%d)", saa7146_num);\r\nDEB_EE("pci:%p\n", pci);\r\nerr = pci_enable_device(pci);\r\nif (err < 0) {\r\nERR("pci_enable_device() failed\n");\r\ngoto err_free;\r\n}\r\npci_set_master(pci);\r\ndev->pci = pci;\r\ndev->revision = pci->revision;\r\nerr = pci_request_region(pci, 0, "saa7146");\r\nif (err < 0)\r\ngoto err_disable;\r\ndev->mem = ioremap(pci_resource_start(pci, 0),\r\npci_resource_len(pci, 0));\r\nif (!dev->mem) {\r\nERR("ioremap() failed\n");\r\nerr = -ENODEV;\r\ngoto err_release;\r\n}\r\nsaa7146_write(dev, IER, 0);\r\nsaa7146_write(dev, MC1, 0x30ff0000);\r\nsaa7146_write(dev, MC2, 0xf8000000);\r\nerr = request_irq(pci->irq, interrupt_hw, IRQF_SHARED,\r\ndev->name, dev);\r\nif (err < 0) {\r\nERR("request_irq() failed\n");\r\ngoto err_unmap;\r\n}\r\nerr = -ENOMEM;\r\ndev->d_rps0.cpu_addr = pci_zalloc_consistent(pci, SAA7146_RPS_MEM,\r\n&dev->d_rps0.dma_handle);\r\nif (!dev->d_rps0.cpu_addr)\r\ngoto err_free_irq;\r\ndev->d_rps1.cpu_addr = pci_zalloc_consistent(pci, SAA7146_RPS_MEM,\r\n&dev->d_rps1.dma_handle);\r\nif (!dev->d_rps1.cpu_addr)\r\ngoto err_free_rps0;\r\ndev->d_i2c.cpu_addr = pci_zalloc_consistent(pci, SAA7146_RPS_MEM,\r\n&dev->d_i2c.dma_handle);\r\nif (!dev->d_i2c.cpu_addr)\r\ngoto err_free_rps1;\r\npr_info("found saa7146 @ mem %p (revision %d, irq %d) (0x%04x,0x%04x)\n",\r\ndev->mem, dev->revision, pci->irq,\r\npci->subsystem_vendor, pci->subsystem_device);\r\ndev->ext = ext;\r\nmutex_init(&dev->v4l2_lock);\r\nspin_lock_init(&dev->int_slock);\r\nspin_lock_init(&dev->slock);\r\nmutex_init(&dev->i2c_lock);\r\ndev->module = THIS_MODULE;\r\ninit_waitqueue_head(&dev->i2c_wq);\r\nsaa7146_write(dev, PCI_BT_V1, 0x1c00101f);\r\nerr = -ENODEV;\r\nif (ext->probe && ext->probe(dev)) {\r\nDEB_D("ext->probe() failed for %p. skipping device.\n", dev);\r\ngoto err_free_i2c;\r\n}\r\nif (ext->attach(dev, pci_ext)) {\r\nDEB_D("ext->attach() failed for %p. skipping device.\n", dev);\r\ngoto err_free_i2c;\r\n}\r\npci_set_drvdata(pci, &dev->v4l2_dev);\r\nsaa7146_num++;\r\nerr = 0;\r\nout:\r\nreturn err;\r\nerr_free_i2c:\r\npci_free_consistent(pci, SAA7146_RPS_MEM, dev->d_i2c.cpu_addr,\r\ndev->d_i2c.dma_handle);\r\nerr_free_rps1:\r\npci_free_consistent(pci, SAA7146_RPS_MEM, dev->d_rps1.cpu_addr,\r\ndev->d_rps1.dma_handle);\r\nerr_free_rps0:\r\npci_free_consistent(pci, SAA7146_RPS_MEM, dev->d_rps0.cpu_addr,\r\ndev->d_rps0.dma_handle);\r\nerr_free_irq:\r\nfree_irq(pci->irq, (void *)dev);\r\nerr_unmap:\r\niounmap(dev->mem);\r\nerr_release:\r\npci_release_region(pci, 0);\r\nerr_disable:\r\npci_disable_device(pci);\r\nerr_free:\r\nkfree(dev);\r\ngoto out;\r\n}\r\nstatic void saa7146_remove_one(struct pci_dev *pdev)\r\n{\r\nstruct v4l2_device *v4l2_dev = pci_get_drvdata(pdev);\r\nstruct saa7146_dev *dev = to_saa7146_dev(v4l2_dev);\r\nstruct {\r\nvoid *addr;\r\ndma_addr_t dma;\r\n} dev_map[] = {\r\n{ dev->d_i2c.cpu_addr, dev->d_i2c.dma_handle },\r\n{ dev->d_rps1.cpu_addr, dev->d_rps1.dma_handle },\r\n{ dev->d_rps0.cpu_addr, dev->d_rps0.dma_handle },\r\n{ NULL, 0 }\r\n}, *p;\r\nDEB_EE("dev:%p\n", dev);\r\ndev->ext->detach(dev);\r\nsaa7146_write(dev, MC1, 0x00ff0000);\r\nsaa7146_write(dev, IER, 0);\r\nfree_irq(pdev->irq, dev);\r\nfor (p = dev_map; p->addr; p++)\r\npci_free_consistent(pdev, SAA7146_RPS_MEM, p->addr, p->dma);\r\niounmap(dev->mem);\r\npci_release_region(pdev, 0);\r\npci_disable_device(pdev);\r\nkfree(dev);\r\nsaa7146_num--;\r\n}\r\nint saa7146_register_extension(struct saa7146_extension* ext)\r\n{\r\nDEB_EE("ext:%p\n", ext);\r\next->driver.name = ext->name;\r\next->driver.id_table = ext->pci_tbl;\r\next->driver.probe = saa7146_init_one;\r\next->driver.remove = saa7146_remove_one;\r\npr_info("register extension '%s'\n", ext->name);\r\nreturn pci_register_driver(&ext->driver);\r\n}\r\nint saa7146_unregister_extension(struct saa7146_extension* ext)\r\n{\r\nDEB_EE("ext:%p\n", ext);\r\npr_info("unregister extension '%s'\n", ext->name);\r\npci_unregister_driver(&ext->driver);\r\nreturn 0;\r\n}
