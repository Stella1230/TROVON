static int\r\nnvkm_fan_update(struct nvkm_fan *fan, bool immediate, int target)\r\n{\r\nstruct nvkm_therm *therm = fan->parent;\r\nstruct nvkm_subdev *subdev = &therm->subdev;\r\nstruct nvkm_timer *tmr = subdev->device->timer;\r\nunsigned long flags;\r\nint ret = 0;\r\nint duty;\r\nspin_lock_irqsave(&fan->lock, flags);\r\nif (target < 0)\r\ntarget = fan->percent;\r\ntarget = max_t(u8, target, fan->bios.min_duty);\r\ntarget = min_t(u8, target, fan->bios.max_duty);\r\nif (fan->percent != target) {\r\nnvkm_debug(subdev, "FAN target: %d\n", target);\r\nfan->percent = target;\r\n}\r\nduty = fan->get(therm);\r\nif (duty == target) {\r\nspin_unlock_irqrestore(&fan->lock, flags);\r\nreturn 0;\r\n}\r\nif (!immediate && duty >= 0) {\r\nif (duty < target)\r\nduty = min(duty + 3, target);\r\nelse if (duty > target)\r\nduty = max(duty - 3, target);\r\n} else {\r\nduty = target;\r\n}\r\nnvkm_debug(subdev, "FAN update: %d\n", duty);\r\nret = fan->set(therm, duty);\r\nif (ret) {\r\nspin_unlock_irqrestore(&fan->lock, flags);\r\nreturn ret;\r\n}\r\nspin_unlock_irqrestore(&fan->lock, flags);\r\nif (list_empty(&fan->alarm.head) && target != duty) {\r\nu16 bump_period = fan->bios.bump_period;\r\nu16 slow_down_period = fan->bios.slow_down_period;\r\nu64 delay;\r\nif (duty > target)\r\ndelay = slow_down_period;\r\nelse if (duty == target)\r\ndelay = min(bump_period, slow_down_period) ;\r\nelse\r\ndelay = bump_period;\r\nnvkm_timer_alarm(tmr, delay * 1000 * 1000, &fan->alarm);\r\n}\r\nreturn ret;\r\n}\r\nstatic void\r\nnvkm_fan_alarm(struct nvkm_alarm *alarm)\r\n{\r\nstruct nvkm_fan *fan = container_of(alarm, struct nvkm_fan, alarm);\r\nnvkm_fan_update(fan, false, -1);\r\n}\r\nint\r\nnvkm_therm_fan_get(struct nvkm_therm *therm)\r\n{\r\nreturn therm->fan->get(therm);\r\n}\r\nint\r\nnvkm_therm_fan_set(struct nvkm_therm *therm, bool immediate, int percent)\r\n{\r\nreturn nvkm_fan_update(therm->fan, immediate, percent);\r\n}\r\nint\r\nnvkm_therm_fan_sense(struct nvkm_therm *therm)\r\n{\r\nstruct nvkm_device *device = therm->subdev.device;\r\nstruct nvkm_timer *tmr = device->timer;\r\nstruct nvkm_gpio *gpio = device->gpio;\r\nu32 cycles, cur, prev;\r\nu64 start, end, tach;\r\nif (therm->func->fan_sense)\r\nreturn therm->func->fan_sense(therm);\r\nif (therm->fan->tach.func == DCB_GPIO_UNUSED)\r\nreturn -ENODEV;\r\nstart = nvkm_timer_read(tmr);\r\nprev = nvkm_gpio_get(gpio, 0, therm->fan->tach.func,\r\ntherm->fan->tach.line);\r\ncycles = 0;\r\ndo {\r\nusleep_range(500, 1000);\r\ncur = nvkm_gpio_get(gpio, 0, therm->fan->tach.func,\r\ntherm->fan->tach.line);\r\nif (prev != cur) {\r\nif (!start)\r\nstart = nvkm_timer_read(tmr);\r\ncycles++;\r\nprev = cur;\r\n}\r\n} while (cycles < 5 && nvkm_timer_read(tmr) - start < 250000000);\r\nend = nvkm_timer_read(tmr);\r\nif (cycles == 5) {\r\ntach = (u64)60000000000ULL;\r\ndo_div(tach, (end - start));\r\nreturn tach;\r\n} else\r\nreturn 0;\r\n}\r\nint\r\nnvkm_therm_fan_user_get(struct nvkm_therm *therm)\r\n{\r\nreturn nvkm_therm_fan_get(therm);\r\n}\r\nint\r\nnvkm_therm_fan_user_set(struct nvkm_therm *therm, int percent)\r\n{\r\nif (therm->mode != NVKM_THERM_CTRL_MANUAL)\r\nreturn -EINVAL;\r\nreturn nvkm_therm_fan_set(therm, true, percent);\r\n}\r\nstatic void\r\nnvkm_therm_fan_set_defaults(struct nvkm_therm *therm)\r\n{\r\ntherm->fan->bios.pwm_freq = 0;\r\ntherm->fan->bios.min_duty = 0;\r\ntherm->fan->bios.max_duty = 100;\r\ntherm->fan->bios.bump_period = 500;\r\ntherm->fan->bios.slow_down_period = 2000;\r\ntherm->fan->bios.linear_min_temp = 40;\r\ntherm->fan->bios.linear_max_temp = 85;\r\n}\r\nstatic void\r\nnvkm_therm_fan_safety_checks(struct nvkm_therm *therm)\r\n{\r\nif (therm->fan->bios.min_duty > 100)\r\ntherm->fan->bios.min_duty = 100;\r\nif (therm->fan->bios.max_duty > 100)\r\ntherm->fan->bios.max_duty = 100;\r\nif (therm->fan->bios.min_duty > therm->fan->bios.max_duty)\r\ntherm->fan->bios.min_duty = therm->fan->bios.max_duty;\r\n}\r\nint\r\nnvkm_therm_fan_init(struct nvkm_therm *therm)\r\n{\r\nreturn 0;\r\n}\r\nint\r\nnvkm_therm_fan_fini(struct nvkm_therm *therm, bool suspend)\r\n{\r\nstruct nvkm_timer *tmr = therm->subdev.device->timer;\r\nif (suspend)\r\nnvkm_timer_alarm_cancel(tmr, &therm->fan->alarm);\r\nreturn 0;\r\n}\r\nint\r\nnvkm_therm_fan_ctor(struct nvkm_therm *therm)\r\n{\r\nstruct nvkm_subdev *subdev = &therm->subdev;\r\nstruct nvkm_device *device = subdev->device;\r\nstruct nvkm_gpio *gpio = device->gpio;\r\nstruct nvkm_bios *bios = device->bios;\r\nstruct dcb_gpio_func func;\r\nint ret;\r\nret = nvkm_gpio_find(gpio, 0, DCB_GPIO_FAN, 0xff, &func);\r\nif (ret == 0) {\r\nif (func.line != 16 && func.log[0] & DCB_GPIO_LOG_DIR_IN) {\r\nnvkm_debug(subdev, "GPIO_FAN is in input mode\n");\r\nret = -EINVAL;\r\n} else {\r\nret = nvkm_fanpwm_create(therm, &func);\r\nif (ret != 0)\r\nret = nvkm_fantog_create(therm, &func);\r\n}\r\n}\r\nif (ret != 0) {\r\nret = nvkm_fannil_create(therm);\r\nif (ret)\r\nreturn ret;\r\n}\r\nnvkm_debug(subdev, "FAN control: %s\n", therm->fan->type);\r\ntherm->fan->percent = nvkm_therm_fan_get(therm);\r\nret = nvkm_gpio_find(gpio, 0, DCB_GPIO_FAN_SENSE, 0xff,\r\n&therm->fan->tach);\r\nif (ret)\r\ntherm->fan->tach.func = DCB_GPIO_UNUSED;\r\ntherm->fan->parent = therm;\r\nnvkm_alarm_init(&therm->fan->alarm, nvkm_fan_alarm);\r\nspin_lock_init(&therm->fan->lock);\r\nnvkm_therm_fan_set_defaults(therm);\r\nnvbios_perf_fan_parse(bios, &therm->fan->perf);\r\nif (!nvbios_fan_parse(bios, &therm->fan->bios)) {\r\nnvkm_debug(subdev, "parsing the fan table failed\n");\r\nif (nvbios_therm_fan_parse(bios, &therm->fan->bios))\r\nnvkm_error(subdev, "parsing both fan tables failed\n");\r\n}\r\nnvkm_therm_fan_safety_checks(therm);\r\nreturn 0;\r\n}
