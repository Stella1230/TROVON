static int clk_slow_osc_prepare(struct clk_hw *hw)\r\n{\r\nstruct clk_slow_osc *osc = to_clk_slow_osc(hw);\r\nvoid __iomem *sckcr = osc->sckcr;\r\nu32 tmp = readl(sckcr);\r\nif (tmp & AT91_SCKC_OSC32BYP)\r\nreturn 0;\r\nwritel(tmp | AT91_SCKC_OSC32EN, sckcr);\r\nusleep_range(osc->startup_usec, osc->startup_usec + 1);\r\nreturn 0;\r\n}\r\nstatic void clk_slow_osc_unprepare(struct clk_hw *hw)\r\n{\r\nstruct clk_slow_osc *osc = to_clk_slow_osc(hw);\r\nvoid __iomem *sckcr = osc->sckcr;\r\nu32 tmp = readl(sckcr);\r\nif (tmp & AT91_SCKC_OSC32BYP)\r\nreturn;\r\nwritel(tmp & ~AT91_SCKC_OSC32EN, sckcr);\r\n}\r\nstatic int clk_slow_osc_is_prepared(struct clk_hw *hw)\r\n{\r\nstruct clk_slow_osc *osc = to_clk_slow_osc(hw);\r\nvoid __iomem *sckcr = osc->sckcr;\r\nu32 tmp = readl(sckcr);\r\nif (tmp & AT91_SCKC_OSC32BYP)\r\nreturn 1;\r\nreturn !!(tmp & AT91_SCKC_OSC32EN);\r\n}\r\nstatic struct clk * __init\r\nat91_clk_register_slow_osc(void __iomem *sckcr,\r\nconst char *name,\r\nconst char *parent_name,\r\nunsigned long startup,\r\nbool bypass)\r\n{\r\nstruct clk_slow_osc *osc;\r\nstruct clk *clk = NULL;\r\nstruct clk_init_data init;\r\nif (!sckcr || !name || !parent_name)\r\nreturn ERR_PTR(-EINVAL);\r\nosc = kzalloc(sizeof(*osc), GFP_KERNEL);\r\nif (!osc)\r\nreturn ERR_PTR(-ENOMEM);\r\ninit.name = name;\r\ninit.ops = &slow_osc_ops;\r\ninit.parent_names = &parent_name;\r\ninit.num_parents = 1;\r\ninit.flags = CLK_IGNORE_UNUSED;\r\nosc->hw.init = &init;\r\nosc->sckcr = sckcr;\r\nosc->startup_usec = startup;\r\nif (bypass)\r\nwritel((readl(sckcr) & ~AT91_SCKC_OSC32EN) | AT91_SCKC_OSC32BYP,\r\nsckcr);\r\nclk = clk_register(NULL, &osc->hw);\r\nif (IS_ERR(clk))\r\nkfree(osc);\r\nreturn clk;\r\n}\r\nvoid __init of_at91sam9x5_clk_slow_osc_setup(struct device_node *np,\r\nvoid __iomem *sckcr)\r\n{\r\nstruct clk *clk;\r\nconst char *parent_name;\r\nconst char *name = np->name;\r\nu32 startup;\r\nbool bypass;\r\nparent_name = of_clk_get_parent_name(np, 0);\r\nof_property_read_string(np, "clock-output-names", &name);\r\nof_property_read_u32(np, "atmel,startup-time-usec", &startup);\r\nbypass = of_property_read_bool(np, "atmel,osc-bypass");\r\nclk = at91_clk_register_slow_osc(sckcr, name, parent_name, startup,\r\nbypass);\r\nif (IS_ERR(clk))\r\nreturn;\r\nof_clk_add_provider(np, of_clk_src_simple_get, clk);\r\n}\r\nstatic unsigned long clk_slow_rc_osc_recalc_rate(struct clk_hw *hw,\r\nunsigned long parent_rate)\r\n{\r\nstruct clk_slow_rc_osc *osc = to_clk_slow_rc_osc(hw);\r\nreturn osc->frequency;\r\n}\r\nstatic unsigned long clk_slow_rc_osc_recalc_accuracy(struct clk_hw *hw,\r\nunsigned long parent_acc)\r\n{\r\nstruct clk_slow_rc_osc *osc = to_clk_slow_rc_osc(hw);\r\nreturn osc->accuracy;\r\n}\r\nstatic int clk_slow_rc_osc_prepare(struct clk_hw *hw)\r\n{\r\nstruct clk_slow_rc_osc *osc = to_clk_slow_rc_osc(hw);\r\nvoid __iomem *sckcr = osc->sckcr;\r\nwritel(readl(sckcr) | AT91_SCKC_RCEN, sckcr);\r\nusleep_range(osc->startup_usec, osc->startup_usec + 1);\r\nreturn 0;\r\n}\r\nstatic void clk_slow_rc_osc_unprepare(struct clk_hw *hw)\r\n{\r\nstruct clk_slow_rc_osc *osc = to_clk_slow_rc_osc(hw);\r\nvoid __iomem *sckcr = osc->sckcr;\r\nwritel(readl(sckcr) & ~AT91_SCKC_RCEN, sckcr);\r\n}\r\nstatic int clk_slow_rc_osc_is_prepared(struct clk_hw *hw)\r\n{\r\nstruct clk_slow_rc_osc *osc = to_clk_slow_rc_osc(hw);\r\nreturn !!(readl(osc->sckcr) & AT91_SCKC_RCEN);\r\n}\r\nstatic struct clk * __init\r\nat91_clk_register_slow_rc_osc(void __iomem *sckcr,\r\nconst char *name,\r\nunsigned long frequency,\r\nunsigned long accuracy,\r\nunsigned long startup)\r\n{\r\nstruct clk_slow_rc_osc *osc;\r\nstruct clk *clk = NULL;\r\nstruct clk_init_data init;\r\nif (!sckcr || !name)\r\nreturn ERR_PTR(-EINVAL);\r\nosc = kzalloc(sizeof(*osc), GFP_KERNEL);\r\nif (!osc)\r\nreturn ERR_PTR(-ENOMEM);\r\ninit.name = name;\r\ninit.ops = &slow_rc_osc_ops;\r\ninit.parent_names = NULL;\r\ninit.num_parents = 0;\r\ninit.flags = CLK_IGNORE_UNUSED;\r\nosc->hw.init = &init;\r\nosc->sckcr = sckcr;\r\nosc->frequency = frequency;\r\nosc->accuracy = accuracy;\r\nosc->startup_usec = startup;\r\nclk = clk_register(NULL, &osc->hw);\r\nif (IS_ERR(clk))\r\nkfree(osc);\r\nreturn clk;\r\n}\r\nvoid __init of_at91sam9x5_clk_slow_rc_osc_setup(struct device_node *np,\r\nvoid __iomem *sckcr)\r\n{\r\nstruct clk *clk;\r\nu32 frequency = 0;\r\nu32 accuracy = 0;\r\nu32 startup = 0;\r\nconst char *name = np->name;\r\nof_property_read_string(np, "clock-output-names", &name);\r\nof_property_read_u32(np, "clock-frequency", &frequency);\r\nof_property_read_u32(np, "clock-accuracy", &accuracy);\r\nof_property_read_u32(np, "atmel,startup-time-usec", &startup);\r\nclk = at91_clk_register_slow_rc_osc(sckcr, name, frequency, accuracy,\r\nstartup);\r\nif (IS_ERR(clk))\r\nreturn;\r\nof_clk_add_provider(np, of_clk_src_simple_get, clk);\r\n}\r\nstatic int clk_sam9x5_slow_set_parent(struct clk_hw *hw, u8 index)\r\n{\r\nstruct clk_sam9x5_slow *slowck = to_clk_sam9x5_slow(hw);\r\nvoid __iomem *sckcr = slowck->sckcr;\r\nu32 tmp;\r\nif (index > 1)\r\nreturn -EINVAL;\r\ntmp = readl(sckcr);\r\nif ((!index && !(tmp & AT91_SCKC_OSCSEL)) ||\r\n(index && (tmp & AT91_SCKC_OSCSEL)))\r\nreturn 0;\r\nif (index)\r\ntmp |= AT91_SCKC_OSCSEL;\r\nelse\r\ntmp &= ~AT91_SCKC_OSCSEL;\r\nwritel(tmp, sckcr);\r\nusleep_range(SLOWCK_SW_TIME_USEC, SLOWCK_SW_TIME_USEC + 1);\r\nreturn 0;\r\n}\r\nstatic u8 clk_sam9x5_slow_get_parent(struct clk_hw *hw)\r\n{\r\nstruct clk_sam9x5_slow *slowck = to_clk_sam9x5_slow(hw);\r\nreturn !!(readl(slowck->sckcr) & AT91_SCKC_OSCSEL);\r\n}\r\nstatic struct clk * __init\r\nat91_clk_register_sam9x5_slow(void __iomem *sckcr,\r\nconst char *name,\r\nconst char **parent_names,\r\nint num_parents)\r\n{\r\nstruct clk_sam9x5_slow *slowck;\r\nstruct clk *clk = NULL;\r\nstruct clk_init_data init;\r\nif (!sckcr || !name || !parent_names || !num_parents)\r\nreturn ERR_PTR(-EINVAL);\r\nslowck = kzalloc(sizeof(*slowck), GFP_KERNEL);\r\nif (!slowck)\r\nreturn ERR_PTR(-ENOMEM);\r\ninit.name = name;\r\ninit.ops = &sam9x5_slow_ops;\r\ninit.parent_names = parent_names;\r\ninit.num_parents = num_parents;\r\ninit.flags = 0;\r\nslowck->hw.init = &init;\r\nslowck->sckcr = sckcr;\r\nslowck->parent = !!(readl(sckcr) & AT91_SCKC_OSCSEL);\r\nclk = clk_register(NULL, &slowck->hw);\r\nif (IS_ERR(clk))\r\nkfree(slowck);\r\nreturn clk;\r\n}\r\nvoid __init of_at91sam9x5_clk_slow_setup(struct device_node *np,\r\nvoid __iomem *sckcr)\r\n{\r\nstruct clk *clk;\r\nconst char *parent_names[2];\r\nunsigned int num_parents;\r\nconst char *name = np->name;\r\nnum_parents = of_clk_get_parent_count(np);\r\nif (num_parents == 0 || num_parents > 2)\r\nreturn;\r\nof_clk_parent_fill(np, parent_names, num_parents);\r\nof_property_read_string(np, "clock-output-names", &name);\r\nclk = at91_clk_register_sam9x5_slow(sckcr, name, parent_names,\r\nnum_parents);\r\nif (IS_ERR(clk))\r\nreturn;\r\nof_clk_add_provider(np, of_clk_src_simple_get, clk);\r\n}\r\nstatic u8 clk_sam9260_slow_get_parent(struct clk_hw *hw)\r\n{\r\nstruct clk_sam9260_slow *slowck = to_clk_sam9260_slow(hw);\r\nunsigned int status;\r\nregmap_read(slowck->regmap, AT91_PMC_SR, &status);\r\nreturn status & AT91_PMC_OSCSEL ? 1 : 0;\r\n}\r\nstatic struct clk * __init\r\nat91_clk_register_sam9260_slow(struct regmap *regmap,\r\nconst char *name,\r\nconst char **parent_names,\r\nint num_parents)\r\n{\r\nstruct clk_sam9260_slow *slowck;\r\nstruct clk *clk = NULL;\r\nstruct clk_init_data init;\r\nif (!name)\r\nreturn ERR_PTR(-EINVAL);\r\nif (!parent_names || !num_parents)\r\nreturn ERR_PTR(-EINVAL);\r\nslowck = kzalloc(sizeof(*slowck), GFP_KERNEL);\r\nif (!slowck)\r\nreturn ERR_PTR(-ENOMEM);\r\ninit.name = name;\r\ninit.ops = &sam9260_slow_ops;\r\ninit.parent_names = parent_names;\r\ninit.num_parents = num_parents;\r\ninit.flags = 0;\r\nslowck->hw.init = &init;\r\nslowck->regmap = regmap;\r\nclk = clk_register(NULL, &slowck->hw);\r\nif (IS_ERR(clk))\r\nkfree(slowck);\r\nreturn clk;\r\n}\r\nstatic void __init of_at91sam9260_clk_slow_setup(struct device_node *np)\r\n{\r\nstruct clk *clk;\r\nconst char *parent_names[2];\r\nunsigned int num_parents;\r\nconst char *name = np->name;\r\nstruct regmap *regmap;\r\nnum_parents = of_clk_get_parent_count(np);\r\nif (num_parents != 2)\r\nreturn;\r\nof_clk_parent_fill(np, parent_names, num_parents);\r\nregmap = syscon_node_to_regmap(of_get_parent(np));\r\nif (IS_ERR(regmap))\r\nreturn;\r\nof_property_read_string(np, "clock-output-names", &name);\r\nclk = at91_clk_register_sam9260_slow(regmap, name, parent_names,\r\nnum_parents);\r\nif (IS_ERR(clk))\r\nreturn;\r\nof_clk_add_provider(np, of_clk_src_simple_get, clk);\r\n}
