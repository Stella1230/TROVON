static int ehci_platform_reset(struct usb_hcd *hcd)\r\n{\r\nstruct platform_device *pdev = to_platform_device(hcd->self.controller);\r\nstruct usb_ehci_pdata *pdata = dev_get_platdata(&pdev->dev);\r\nstruct ehci_hcd *ehci = hcd_to_ehci(hcd);\r\nint retval;\r\nehci->has_synopsys_hc_bug = pdata->has_synopsys_hc_bug;\r\nif (pdata->pre_setup) {\r\nretval = pdata->pre_setup(hcd);\r\nif (retval < 0)\r\nreturn retval;\r\n}\r\nehci->caps = hcd->regs + pdata->caps_offset;\r\nretval = ehci_setup(hcd);\r\nif (retval)\r\nreturn retval;\r\nif (pdata->no_io_watchdog)\r\nehci->need_io_watchdog = 0;\r\nreturn 0;\r\n}\r\nstatic int ehci_platform_power_on(struct platform_device *dev)\r\n{\r\nstruct usb_hcd *hcd = platform_get_drvdata(dev);\r\nstruct ehci_platform_priv *priv = hcd_to_ehci_priv(hcd);\r\nint clk, ret, phy_num;\r\nfor (clk = 0; clk < EHCI_MAX_CLKS && priv->clks[clk]; clk++) {\r\nret = clk_prepare_enable(priv->clks[clk]);\r\nif (ret)\r\ngoto err_disable_clks;\r\n}\r\nfor (phy_num = 0; phy_num < priv->num_phys; phy_num++) {\r\nret = phy_init(priv->phys[phy_num]);\r\nif (ret)\r\ngoto err_exit_phy;\r\nret = phy_power_on(priv->phys[phy_num]);\r\nif (ret) {\r\nphy_exit(priv->phys[phy_num]);\r\ngoto err_exit_phy;\r\n}\r\n}\r\nreturn 0;\r\nerr_exit_phy:\r\nwhile (--phy_num >= 0) {\r\nphy_power_off(priv->phys[phy_num]);\r\nphy_exit(priv->phys[phy_num]);\r\n}\r\nerr_disable_clks:\r\nwhile (--clk >= 0)\r\nclk_disable_unprepare(priv->clks[clk]);\r\nreturn ret;\r\n}\r\nstatic void ehci_platform_power_off(struct platform_device *dev)\r\n{\r\nstruct usb_hcd *hcd = platform_get_drvdata(dev);\r\nstruct ehci_platform_priv *priv = hcd_to_ehci_priv(hcd);\r\nint clk, phy_num;\r\nfor (phy_num = 0; phy_num < priv->num_phys; phy_num++) {\r\nphy_power_off(priv->phys[phy_num]);\r\nphy_exit(priv->phys[phy_num]);\r\n}\r\nfor (clk = EHCI_MAX_CLKS - 1; clk >= 0; clk--)\r\nif (priv->clks[clk])\r\nclk_disable_unprepare(priv->clks[clk]);\r\n}\r\nstatic int ehci_platform_probe(struct platform_device *dev)\r\n{\r\nstruct usb_hcd *hcd;\r\nstruct resource *res_mem;\r\nstruct usb_ehci_pdata *pdata = dev_get_platdata(&dev->dev);\r\nstruct ehci_platform_priv *priv;\r\nstruct ehci_hcd *ehci;\r\nint err, irq, phy_num, clk = 0;\r\nif (usb_disabled())\r\nreturn -ENODEV;\r\nif (!pdata)\r\npdata = &ehci_platform_defaults;\r\nerr = dma_coerce_mask_and_coherent(&dev->dev,\r\npdata->dma_mask_64 ? DMA_BIT_MASK(64) : DMA_BIT_MASK(32));\r\nif (err) {\r\ndev_err(&dev->dev, "Error: DMA mask configuration failed\n");\r\nreturn err;\r\n}\r\nirq = platform_get_irq(dev, 0);\r\nif (irq < 0) {\r\ndev_err(&dev->dev, "no irq provided");\r\nreturn irq;\r\n}\r\nhcd = usb_create_hcd(&ehci_platform_hc_driver, &dev->dev,\r\ndev_name(&dev->dev));\r\nif (!hcd)\r\nreturn -ENOMEM;\r\nplatform_set_drvdata(dev, hcd);\r\ndev->dev.platform_data = pdata;\r\npriv = hcd_to_ehci_priv(hcd);\r\nehci = hcd_to_ehci(hcd);\r\nif (pdata == &ehci_platform_defaults && dev->dev.of_node) {\r\nif (of_property_read_bool(dev->dev.of_node, "big-endian-regs"))\r\nehci->big_endian_mmio = 1;\r\nif (of_property_read_bool(dev->dev.of_node, "big-endian-desc"))\r\nehci->big_endian_desc = 1;\r\nif (of_property_read_bool(dev->dev.of_node, "big-endian"))\r\nehci->big_endian_mmio = ehci->big_endian_desc = 1;\r\nif (of_property_read_bool(dev->dev.of_node,\r\n"needs-reset-on-resume"))\r\npriv->reset_on_resume = true;\r\nif (of_property_read_bool(dev->dev.of_node,\r\n"has-transaction-translator"))\r\nhcd->has_tt = 1;\r\npriv->num_phys = of_count_phandle_with_args(dev->dev.of_node,\r\n"phys", "#phy-cells");\r\nif (priv->num_phys > 0) {\r\npriv->phys = devm_kcalloc(&dev->dev, priv->num_phys,\r\nsizeof(struct phy *), GFP_KERNEL);\r\nif (!priv->phys)\r\nreturn -ENOMEM;\r\n} else\r\npriv->num_phys = 0;\r\nfor (phy_num = 0; phy_num < priv->num_phys; phy_num++) {\r\npriv->phys[phy_num] = devm_of_phy_get_by_index(\r\n&dev->dev, dev->dev.of_node, phy_num);\r\nif (IS_ERR(priv->phys[phy_num])) {\r\nerr = PTR_ERR(priv->phys[phy_num]);\r\ngoto err_put_hcd;\r\n}\r\n}\r\nfor (clk = 0; clk < EHCI_MAX_CLKS; clk++) {\r\npriv->clks[clk] = of_clk_get(dev->dev.of_node, clk);\r\nif (IS_ERR(priv->clks[clk])) {\r\nerr = PTR_ERR(priv->clks[clk]);\r\nif (err == -EPROBE_DEFER)\r\ngoto err_put_clks;\r\npriv->clks[clk] = NULL;\r\nbreak;\r\n}\r\n}\r\n}\r\npriv->rst = devm_reset_control_get_optional(&dev->dev, NULL);\r\nif (IS_ERR(priv->rst)) {\r\nerr = PTR_ERR(priv->rst);\r\nif (err == -EPROBE_DEFER)\r\ngoto err_put_clks;\r\npriv->rst = NULL;\r\n} else {\r\nerr = reset_control_deassert(priv->rst);\r\nif (err)\r\ngoto err_put_clks;\r\n}\r\nif (pdata->big_endian_desc)\r\nehci->big_endian_desc = 1;\r\nif (pdata->big_endian_mmio)\r\nehci->big_endian_mmio = 1;\r\nif (pdata->has_tt)\r\nhcd->has_tt = 1;\r\nif (pdata->reset_on_resume)\r\npriv->reset_on_resume = true;\r\n#ifndef CONFIG_USB_EHCI_BIG_ENDIAN_MMIO\r\nif (ehci->big_endian_mmio) {\r\ndev_err(&dev->dev,\r\n"Error: CONFIG_USB_EHCI_BIG_ENDIAN_MMIO not set\n");\r\nerr = -EINVAL;\r\ngoto err_reset;\r\n}\r\n#endif\r\n#ifndef CONFIG_USB_EHCI_BIG_ENDIAN_DESC\r\nif (ehci->big_endian_desc) {\r\ndev_err(&dev->dev,\r\n"Error: CONFIG_USB_EHCI_BIG_ENDIAN_DESC not set\n");\r\nerr = -EINVAL;\r\ngoto err_reset;\r\n}\r\n#endif\r\nif (pdata->power_on) {\r\nerr = pdata->power_on(dev);\r\nif (err < 0)\r\ngoto err_reset;\r\n}\r\nres_mem = platform_get_resource(dev, IORESOURCE_MEM, 0);\r\nhcd->regs = devm_ioremap_resource(&dev->dev, res_mem);\r\nif (IS_ERR(hcd->regs)) {\r\nerr = PTR_ERR(hcd->regs);\r\ngoto err_power;\r\n}\r\nhcd->rsrc_start = res_mem->start;\r\nhcd->rsrc_len = resource_size(res_mem);\r\nerr = usb_add_hcd(hcd, irq, IRQF_SHARED);\r\nif (err)\r\ngoto err_power;\r\ndevice_wakeup_enable(hcd->self.controller);\r\nplatform_set_drvdata(dev, hcd);\r\nreturn err;\r\nerr_power:\r\nif (pdata->power_off)\r\npdata->power_off(dev);\r\nerr_reset:\r\nif (priv->rst)\r\nreset_control_assert(priv->rst);\r\nerr_put_clks:\r\nwhile (--clk >= 0)\r\nclk_put(priv->clks[clk]);\r\nerr_put_hcd:\r\nif (pdata == &ehci_platform_defaults)\r\ndev->dev.platform_data = NULL;\r\nusb_put_hcd(hcd);\r\nreturn err;\r\n}\r\nstatic int ehci_platform_remove(struct platform_device *dev)\r\n{\r\nstruct usb_hcd *hcd = platform_get_drvdata(dev);\r\nstruct usb_ehci_pdata *pdata = dev_get_platdata(&dev->dev);\r\nstruct ehci_platform_priv *priv = hcd_to_ehci_priv(hcd);\r\nint clk;\r\nusb_remove_hcd(hcd);\r\nif (pdata->power_off)\r\npdata->power_off(dev);\r\nif (priv->rst)\r\nreset_control_assert(priv->rst);\r\nfor (clk = 0; clk < EHCI_MAX_CLKS && priv->clks[clk]; clk++)\r\nclk_put(priv->clks[clk]);\r\nusb_put_hcd(hcd);\r\nif (pdata == &ehci_platform_defaults)\r\ndev->dev.platform_data = NULL;\r\nreturn 0;\r\n}\r\nstatic int ehci_platform_suspend(struct device *dev)\r\n{\r\nstruct usb_hcd *hcd = dev_get_drvdata(dev);\r\nstruct usb_ehci_pdata *pdata = dev_get_platdata(dev);\r\nstruct platform_device *pdev = to_platform_device(dev);\r\nbool do_wakeup = device_may_wakeup(dev);\r\nint ret;\r\nret = ehci_suspend(hcd, do_wakeup);\r\nif (ret)\r\nreturn ret;\r\nif (pdata->power_suspend)\r\npdata->power_suspend(pdev);\r\nreturn ret;\r\n}\r\nstatic int ehci_platform_resume(struct device *dev)\r\n{\r\nstruct usb_hcd *hcd = dev_get_drvdata(dev);\r\nstruct usb_ehci_pdata *pdata = dev_get_platdata(dev);\r\nstruct platform_device *pdev = to_platform_device(dev);\r\nstruct ehci_platform_priv *priv = hcd_to_ehci_priv(hcd);\r\nif (pdata->power_on) {\r\nint err = pdata->power_on(pdev);\r\nif (err < 0)\r\nreturn err;\r\n}\r\nehci_resume(hcd, priv->reset_on_resume);\r\nreturn 0;\r\n}\r\nstatic int __init ehci_platform_init(void)\r\n{\r\nif (usb_disabled())\r\nreturn -ENODEV;\r\npr_info("%s: " DRIVER_DESC "\n", hcd_name);\r\nehci_init_driver(&ehci_platform_hc_driver, &platform_overrides);\r\nreturn platform_driver_register(&ehci_platform_driver);\r\n}\r\nstatic void __exit ehci_platform_cleanup(void)\r\n{\r\nplatform_driver_unregister(&ehci_platform_driver);\r\n}
