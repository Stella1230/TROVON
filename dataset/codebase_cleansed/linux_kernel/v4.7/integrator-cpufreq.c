static int integrator_verify_policy(struct cpufreq_policy *policy)\r\n{\r\nstruct icst_vco vco;\r\ncpufreq_verify_within_cpu_limits(policy);\r\nvco = icst_hz_to_vco(&cclk_params, policy->max * 1000);\r\npolicy->max = icst_hz(&cclk_params, vco) / 1000;\r\nvco = icst_hz_to_vco(&cclk_params, policy->min * 1000);\r\npolicy->min = icst_hz(&cclk_params, vco) / 1000;\r\ncpufreq_verify_within_cpu_limits(policy);\r\nreturn 0;\r\n}\r\nstatic int integrator_set_target(struct cpufreq_policy *policy,\r\nunsigned int target_freq,\r\nunsigned int relation)\r\n{\r\ncpumask_t cpus_allowed;\r\nint cpu = policy->cpu;\r\nstruct icst_vco vco;\r\nstruct cpufreq_freqs freqs;\r\nu_int cm_osc;\r\ncpus_allowed = current->cpus_allowed;\r\nset_cpus_allowed_ptr(current, cpumask_of(cpu));\r\nBUG_ON(cpu != smp_processor_id());\r\ncm_osc = __raw_readl(cm_base + INTEGRATOR_HDR_OSC_OFFSET);\r\nif (machine_is_integrator())\r\nvco.s = (cm_osc >> 8) & 7;\r\nelse if (machine_is_cintegrator())\r\nvco.s = 1;\r\nvco.v = cm_osc & 255;\r\nvco.r = 22;\r\nfreqs.old = icst_hz(&cclk_params, vco) / 1000;\r\nif (relation == CPUFREQ_RELATION_L)\r\ntarget_freq += 999;\r\nif (target_freq > policy->max)\r\ntarget_freq = policy->max;\r\nvco = icst_hz_to_vco(&cclk_params, target_freq * 1000);\r\nfreqs.new = icst_hz(&cclk_params, vco) / 1000;\r\nif (freqs.old == freqs.new) {\r\nset_cpus_allowed_ptr(current, &cpus_allowed);\r\nreturn 0;\r\n}\r\ncpufreq_freq_transition_begin(policy, &freqs);\r\ncm_osc = __raw_readl(cm_base + INTEGRATOR_HDR_OSC_OFFSET);\r\nif (machine_is_integrator()) {\r\ncm_osc &= 0xfffff800;\r\ncm_osc |= vco.s << 8;\r\n} else if (machine_is_cintegrator()) {\r\ncm_osc &= 0xffffff00;\r\n}\r\ncm_osc |= vco.v;\r\n__raw_writel(0xa05f, cm_base + INTEGRATOR_HDR_LOCK_OFFSET);\r\n__raw_writel(cm_osc, cm_base + INTEGRATOR_HDR_OSC_OFFSET);\r\n__raw_writel(0, cm_base + INTEGRATOR_HDR_LOCK_OFFSET);\r\nset_cpus_allowed_ptr(current, &cpus_allowed);\r\ncpufreq_freq_transition_end(policy, &freqs, 0);\r\nreturn 0;\r\n}\r\nstatic unsigned int integrator_get(unsigned int cpu)\r\n{\r\ncpumask_t cpus_allowed;\r\nunsigned int current_freq;\r\nu_int cm_osc;\r\nstruct icst_vco vco;\r\ncpus_allowed = current->cpus_allowed;\r\nset_cpus_allowed_ptr(current, cpumask_of(cpu));\r\nBUG_ON(cpu != smp_processor_id());\r\ncm_osc = __raw_readl(cm_base + INTEGRATOR_HDR_OSC_OFFSET);\r\nif (machine_is_integrator())\r\nvco.s = (cm_osc >> 8) & 7;\r\nelse\r\nvco.s = 1;\r\nvco.v = cm_osc & 255;\r\nvco.r = 22;\r\ncurrent_freq = icst_hz(&cclk_params, vco) / 1000;\r\nset_cpus_allowed_ptr(current, &cpus_allowed);\r\nreturn current_freq;\r\n}\r\nstatic int integrator_cpufreq_init(struct cpufreq_policy *policy)\r\n{\r\npolicy->max = policy->cpuinfo.max_freq = 160000;\r\npolicy->min = policy->cpuinfo.min_freq = 12000;\r\npolicy->cpuinfo.transition_latency = 1000000;\r\nreturn 0;\r\n}\r\nstatic int __init integrator_cpufreq_probe(struct platform_device *pdev)\r\n{\r\nstruct resource *res;\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nif (!res)\r\nreturn -ENODEV;\r\ncm_base = devm_ioremap(&pdev->dev, res->start, resource_size(res));\r\nif (!cm_base)\r\nreturn -ENODEV;\r\nreturn cpufreq_register_driver(&integrator_driver);\r\n}\r\nstatic int __exit integrator_cpufreq_remove(struct platform_device *pdev)\r\n{\r\nreturn cpufreq_unregister_driver(&integrator_driver);\r\n}
