static int logfs_mtd_read(struct super_block *sb, loff_t ofs, size_t len,\r\nvoid *buf)\r\n{\r\nstruct mtd_info *mtd = logfs_super(sb)->s_mtd;\r\nsize_t retlen;\r\nint ret;\r\nret = mtd_read(mtd, ofs, len, &retlen, buf);\r\nBUG_ON(ret == -EINVAL);\r\nif (ret)\r\nreturn ret;\r\nif (retlen != len)\r\nreturn -EIO;\r\nreturn 0;\r\n}\r\nstatic int loffs_mtd_write(struct super_block *sb, loff_t ofs, size_t len,\r\nvoid *buf)\r\n{\r\nstruct logfs_super *super = logfs_super(sb);\r\nstruct mtd_info *mtd = super->s_mtd;\r\nsize_t retlen;\r\nloff_t page_start, page_end;\r\nint ret;\r\nif (super->s_flags & LOGFS_SB_FLAG_RO)\r\nreturn -EROFS;\r\nBUG_ON((ofs >= mtd->size) || (len > mtd->size - ofs));\r\nBUG_ON(ofs != (ofs >> super->s_writeshift) << super->s_writeshift);\r\nBUG_ON(len > PAGE_SIZE);\r\npage_start = ofs & PAGE_MASK;\r\npage_end = PAGE_ALIGN(ofs + len) - 1;\r\nret = mtd_write(mtd, ofs, len, &retlen, buf);\r\nif (ret || (retlen != len))\r\nreturn -EIO;\r\nreturn 0;\r\n}\r\nstatic void logfs_erase_callback(struct erase_info *ei)\r\n{\r\ncomplete((struct completion *)ei->priv);\r\n}\r\nstatic int logfs_mtd_erase_mapping(struct super_block *sb, loff_t ofs,\r\nsize_t len)\r\n{\r\nstruct logfs_super *super = logfs_super(sb);\r\nstruct address_space *mapping = super->s_mapping_inode->i_mapping;\r\nstruct page *page;\r\npgoff_t index = ofs >> PAGE_SHIFT;\r\nfor (index = ofs >> PAGE_SHIFT; index < (ofs + len) >> PAGE_SHIFT; index++) {\r\npage = find_get_page(mapping, index);\r\nif (!page)\r\ncontinue;\r\nmemset(page_address(page), 0xFF, PAGE_SIZE);\r\nput_page(page);\r\n}\r\nreturn 0;\r\n}\r\nstatic int logfs_mtd_erase(struct super_block *sb, loff_t ofs, size_t len,\r\nint ensure_write)\r\n{\r\nstruct mtd_info *mtd = logfs_super(sb)->s_mtd;\r\nstruct erase_info ei;\r\nDECLARE_COMPLETION_ONSTACK(complete);\r\nint ret;\r\nBUG_ON(len % mtd->erasesize);\r\nif (logfs_super(sb)->s_flags & LOGFS_SB_FLAG_RO)\r\nreturn -EROFS;\r\nmemset(&ei, 0, sizeof(ei));\r\nei.mtd = mtd;\r\nei.addr = ofs;\r\nei.len = len;\r\nei.callback = logfs_erase_callback;\r\nei.priv = (long)&complete;\r\nret = mtd_erase(mtd, &ei);\r\nif (ret)\r\nreturn -EIO;\r\nwait_for_completion(&complete);\r\nif (ei.state != MTD_ERASE_DONE)\r\nreturn -EIO;\r\nreturn logfs_mtd_erase_mapping(sb, ofs, len);\r\n}\r\nstatic void logfs_mtd_sync(struct super_block *sb)\r\n{\r\nstruct mtd_info *mtd = logfs_super(sb)->s_mtd;\r\nmtd_sync(mtd);\r\n}\r\nstatic int logfs_mtd_readpage(void *_sb, struct page *page)\r\n{\r\nstruct super_block *sb = _sb;\r\nint err;\r\nerr = logfs_mtd_read(sb, page->index << PAGE_SHIFT, PAGE_SIZE,\r\npage_address(page));\r\nif (err == -EUCLEAN || err == -EBADMSG) {\r\nerr = 0;\r\n}\r\nif (err) {\r\nClearPageUptodate(page);\r\nSetPageError(page);\r\n} else {\r\nSetPageUptodate(page);\r\nClearPageError(page);\r\n}\r\nunlock_page(page);\r\nreturn err;\r\n}\r\nstatic struct page *logfs_mtd_find_first_sb(struct super_block *sb, u64 *ofs)\r\n{\r\nstruct logfs_super *super = logfs_super(sb);\r\nstruct address_space *mapping = super->s_mapping_inode->i_mapping;\r\nfiller_t *filler = logfs_mtd_readpage;\r\nstruct mtd_info *mtd = super->s_mtd;\r\n*ofs = 0;\r\nwhile (mtd_block_isbad(mtd, *ofs)) {\r\n*ofs += mtd->erasesize;\r\nif (*ofs >= mtd->size)\r\nreturn NULL;\r\n}\r\nBUG_ON(*ofs & ~PAGE_MASK);\r\nreturn read_cache_page(mapping, *ofs >> PAGE_SHIFT, filler, sb);\r\n}\r\nstatic struct page *logfs_mtd_find_last_sb(struct super_block *sb, u64 *ofs)\r\n{\r\nstruct logfs_super *super = logfs_super(sb);\r\nstruct address_space *mapping = super->s_mapping_inode->i_mapping;\r\nfiller_t *filler = logfs_mtd_readpage;\r\nstruct mtd_info *mtd = super->s_mtd;\r\n*ofs = mtd->size - mtd->erasesize;\r\nwhile (mtd_block_isbad(mtd, *ofs)) {\r\n*ofs -= mtd->erasesize;\r\nif (*ofs <= 0)\r\nreturn NULL;\r\n}\r\n*ofs = *ofs + mtd->erasesize - 0x1000;\r\nBUG_ON(*ofs & ~PAGE_MASK);\r\nreturn read_cache_page(mapping, *ofs >> PAGE_SHIFT, filler, sb);\r\n}\r\nstatic int __logfs_mtd_writeseg(struct super_block *sb, u64 ofs, pgoff_t index,\r\nsize_t nr_pages)\r\n{\r\nstruct logfs_super *super = logfs_super(sb);\r\nstruct address_space *mapping = super->s_mapping_inode->i_mapping;\r\nstruct page *page;\r\nint i, err;\r\nfor (i = 0; i < nr_pages; i++) {\r\npage = find_lock_page(mapping, index + i);\r\nBUG_ON(!page);\r\nerr = loffs_mtd_write(sb, page->index << PAGE_SHIFT, PAGE_SIZE,\r\npage_address(page));\r\nunlock_page(page);\r\nput_page(page);\r\nif (err)\r\nreturn err;\r\n}\r\nreturn 0;\r\n}\r\nstatic void logfs_mtd_writeseg(struct super_block *sb, u64 ofs, size_t len)\r\n{\r\nstruct logfs_super *super = logfs_super(sb);\r\nint head;\r\nif (super->s_flags & LOGFS_SB_FLAG_RO)\r\nreturn;\r\nif (len == 0) {\r\nreturn;\r\n}\r\nhead = ofs & (PAGE_SIZE - 1);\r\nif (head) {\r\nofs -= head;\r\nlen += head;\r\n}\r\nlen = PAGE_ALIGN(len);\r\n__logfs_mtd_writeseg(sb, ofs, ofs >> PAGE_SHIFT, len >> PAGE_SHIFT);\r\n}\r\nstatic void logfs_mtd_put_device(struct logfs_super *s)\r\n{\r\nput_mtd_device(s->s_mtd);\r\n}\r\nstatic int logfs_mtd_can_write_buf(struct super_block *sb, u64 ofs)\r\n{\r\nstruct logfs_super *super = logfs_super(sb);\r\nvoid *buf;\r\nint err;\r\nbuf = kmalloc(super->s_writesize, GFP_KERNEL);\r\nif (!buf)\r\nreturn -ENOMEM;\r\nerr = logfs_mtd_read(sb, ofs, super->s_writesize, buf);\r\nif (err)\r\ngoto out;\r\nif (memchr_inv(buf, 0xff, super->s_writesize))\r\nerr = -EIO;\r\nkfree(buf);\r\nout:\r\nreturn err;\r\n}\r\nint logfs_get_sb_mtd(struct logfs_super *s, int mtdnr)\r\n{\r\nstruct mtd_info *mtd = get_mtd_device(NULL, mtdnr);\r\nif (IS_ERR(mtd))\r\nreturn PTR_ERR(mtd);\r\ns->s_bdev = NULL;\r\ns->s_mtd = mtd;\r\ns->s_devops = &mtd_devops;\r\nreturn 0;\r\n}
