static struct kmem_cache *create_pid_cachep(int nr_ids)\r\n{\r\nstruct pid_cache *pcache;\r\nstruct kmem_cache *cachep;\r\nmutex_lock(&pid_caches_mutex);\r\nlist_for_each_entry(pcache, &pid_caches_lh, list)\r\nif (pcache->nr_ids == nr_ids)\r\ngoto out;\r\npcache = kmalloc(sizeof(struct pid_cache), GFP_KERNEL);\r\nif (pcache == NULL)\r\ngoto err_alloc;\r\nsnprintf(pcache->name, sizeof(pcache->name), "pid_%d", nr_ids);\r\ncachep = kmem_cache_create(pcache->name,\r\nsizeof(struct pid) + (nr_ids - 1) * sizeof(struct upid),\r\n0, SLAB_HWCACHE_ALIGN, NULL);\r\nif (cachep == NULL)\r\ngoto err_cachep;\r\npcache->nr_ids = nr_ids;\r\npcache->cachep = cachep;\r\nlist_add(&pcache->list, &pid_caches_lh);\r\nout:\r\nmutex_unlock(&pid_caches_mutex);\r\nreturn pcache->cachep;\r\nerr_cachep:\r\nkfree(pcache);\r\nerr_alloc:\r\nmutex_unlock(&pid_caches_mutex);\r\nreturn NULL;\r\n}\r\nstatic void proc_cleanup_work(struct work_struct *work)\r\n{\r\nstruct pid_namespace *ns = container_of(work, struct pid_namespace, proc_work);\r\npid_ns_release_proc(ns);\r\n}\r\nstatic struct pid_namespace *create_pid_namespace(struct user_namespace *user_ns,\r\nstruct pid_namespace *parent_pid_ns)\r\n{\r\nstruct pid_namespace *ns;\r\nunsigned int level = parent_pid_ns->level + 1;\r\nint i;\r\nint err;\r\nif (level > MAX_PID_NS_LEVEL) {\r\nerr = -EINVAL;\r\ngoto out;\r\n}\r\nerr = -ENOMEM;\r\nns = kmem_cache_zalloc(pid_ns_cachep, GFP_KERNEL);\r\nif (ns == NULL)\r\ngoto out;\r\nns->pidmap[0].page = kzalloc(PAGE_SIZE, GFP_KERNEL);\r\nif (!ns->pidmap[0].page)\r\ngoto out_free;\r\nns->pid_cachep = create_pid_cachep(level + 1);\r\nif (ns->pid_cachep == NULL)\r\ngoto out_free_map;\r\nerr = ns_alloc_inum(&ns->ns);\r\nif (err)\r\ngoto out_free_map;\r\nns->ns.ops = &pidns_operations;\r\nkref_init(&ns->kref);\r\nns->level = level;\r\nns->parent = get_pid_ns(parent_pid_ns);\r\nns->user_ns = get_user_ns(user_ns);\r\nns->nr_hashed = PIDNS_HASH_ADDING;\r\nINIT_WORK(&ns->proc_work, proc_cleanup_work);\r\nset_bit(0, ns->pidmap[0].page);\r\natomic_set(&ns->pidmap[0].nr_free, BITS_PER_PAGE - 1);\r\nfor (i = 1; i < PIDMAP_ENTRIES; i++)\r\natomic_set(&ns->pidmap[i].nr_free, BITS_PER_PAGE);\r\nreturn ns;\r\nout_free_map:\r\nkfree(ns->pidmap[0].page);\r\nout_free:\r\nkmem_cache_free(pid_ns_cachep, ns);\r\nout:\r\nreturn ERR_PTR(err);\r\n}\r\nstatic void delayed_free_pidns(struct rcu_head *p)\r\n{\r\nkmem_cache_free(pid_ns_cachep,\r\ncontainer_of(p, struct pid_namespace, rcu));\r\n}\r\nstatic void destroy_pid_namespace(struct pid_namespace *ns)\r\n{\r\nint i;\r\nns_free_inum(&ns->ns);\r\nfor (i = 0; i < PIDMAP_ENTRIES; i++)\r\nkfree(ns->pidmap[i].page);\r\nput_user_ns(ns->user_ns);\r\ncall_rcu(&ns->rcu, delayed_free_pidns);\r\n}\r\nstruct pid_namespace *copy_pid_ns(unsigned long flags,\r\nstruct user_namespace *user_ns, struct pid_namespace *old_ns)\r\n{\r\nif (!(flags & CLONE_NEWPID))\r\nreturn get_pid_ns(old_ns);\r\nif (task_active_pid_ns(current) != old_ns)\r\nreturn ERR_PTR(-EINVAL);\r\nreturn create_pid_namespace(user_ns, old_ns);\r\n}\r\nstatic void free_pid_ns(struct kref *kref)\r\n{\r\nstruct pid_namespace *ns;\r\nns = container_of(kref, struct pid_namespace, kref);\r\ndestroy_pid_namespace(ns);\r\n}\r\nvoid put_pid_ns(struct pid_namespace *ns)\r\n{\r\nstruct pid_namespace *parent;\r\nwhile (ns != &init_pid_ns) {\r\nparent = ns->parent;\r\nif (!kref_put(&ns->kref, free_pid_ns))\r\nbreak;\r\nns = parent;\r\n}\r\n}\r\nvoid zap_pid_ns_processes(struct pid_namespace *pid_ns)\r\n{\r\nint nr;\r\nint rc;\r\nstruct task_struct *task, *me = current;\r\nint init_pids = thread_group_leader(me) ? 1 : 2;\r\ndisable_pid_allocation(pid_ns);\r\nspin_lock_irq(&me->sighand->siglock);\r\nme->sighand->action[SIGCHLD - 1].sa.sa_handler = SIG_IGN;\r\nspin_unlock_irq(&me->sighand->siglock);\r\nread_lock(&tasklist_lock);\r\nnr = next_pidmap(pid_ns, 1);\r\nwhile (nr > 0) {\r\nrcu_read_lock();\r\ntask = pid_task(find_vpid(nr), PIDTYPE_PID);\r\nif (task && !__fatal_signal_pending(task))\r\nsend_sig_info(SIGKILL, SEND_SIG_FORCED, task);\r\nrcu_read_unlock();\r\nnr = next_pidmap(pid_ns, nr);\r\n}\r\nread_unlock(&tasklist_lock);\r\ndo {\r\nclear_thread_flag(TIF_SIGPENDING);\r\nrc = sys_wait4(-1, NULL, __WALL, NULL);\r\n} while (rc != -ECHILD);\r\nfor (;;) {\r\nset_current_state(TASK_UNINTERRUPTIBLE);\r\nif (pid_ns->nr_hashed == init_pids)\r\nbreak;\r\nschedule();\r\n}\r\n__set_current_state(TASK_RUNNING);\r\nif (pid_ns->reboot)\r\ncurrent->signal->group_exit_code = pid_ns->reboot;\r\nacct_exit_ns(pid_ns);\r\nreturn;\r\n}\r\nstatic int pid_ns_ctl_handler(struct ctl_table *table, int write,\r\nvoid __user *buffer, size_t *lenp, loff_t *ppos)\r\n{\r\nstruct pid_namespace *pid_ns = task_active_pid_ns(current);\r\nstruct ctl_table tmp = *table;\r\nif (write && !ns_capable(pid_ns->user_ns, CAP_SYS_ADMIN))\r\nreturn -EPERM;\r\ntmp.data = &pid_ns->last_pid;\r\nreturn proc_dointvec_minmax(&tmp, write, buffer, lenp, ppos);\r\n}\r\nint reboot_pid_ns(struct pid_namespace *pid_ns, int cmd)\r\n{\r\nif (pid_ns == &init_pid_ns)\r\nreturn 0;\r\nswitch (cmd) {\r\ncase LINUX_REBOOT_CMD_RESTART2:\r\ncase LINUX_REBOOT_CMD_RESTART:\r\npid_ns->reboot = SIGHUP;\r\nbreak;\r\ncase LINUX_REBOOT_CMD_POWER_OFF:\r\ncase LINUX_REBOOT_CMD_HALT:\r\npid_ns->reboot = SIGINT;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nread_lock(&tasklist_lock);\r\nforce_sig(SIGKILL, pid_ns->child_reaper);\r\nread_unlock(&tasklist_lock);\r\ndo_exit(0);\r\nreturn 0;\r\n}\r\nstatic inline struct pid_namespace *to_pid_ns(struct ns_common *ns)\r\n{\r\nreturn container_of(ns, struct pid_namespace, ns);\r\n}\r\nstatic struct ns_common *pidns_get(struct task_struct *task)\r\n{\r\nstruct pid_namespace *ns;\r\nrcu_read_lock();\r\nns = task_active_pid_ns(task);\r\nif (ns)\r\nget_pid_ns(ns);\r\nrcu_read_unlock();\r\nreturn ns ? &ns->ns : NULL;\r\n}\r\nstatic void pidns_put(struct ns_common *ns)\r\n{\r\nput_pid_ns(to_pid_ns(ns));\r\n}\r\nstatic int pidns_install(struct nsproxy *nsproxy, struct ns_common *ns)\r\n{\r\nstruct pid_namespace *active = task_active_pid_ns(current);\r\nstruct pid_namespace *ancestor, *new = to_pid_ns(ns);\r\nif (!ns_capable(new->user_ns, CAP_SYS_ADMIN) ||\r\n!ns_capable(current_user_ns(), CAP_SYS_ADMIN))\r\nreturn -EPERM;\r\nif (new->level < active->level)\r\nreturn -EINVAL;\r\nancestor = new;\r\nwhile (ancestor->level > active->level)\r\nancestor = ancestor->parent;\r\nif (ancestor != active)\r\nreturn -EINVAL;\r\nput_pid_ns(nsproxy->pid_ns_for_children);\r\nnsproxy->pid_ns_for_children = get_pid_ns(new);\r\nreturn 0;\r\n}\r\nstatic __init int pid_namespaces_init(void)\r\n{\r\npid_ns_cachep = KMEM_CACHE(pid_namespace, SLAB_PANIC);\r\n#ifdef CONFIG_CHECKPOINT_RESTORE\r\nregister_sysctl_paths(kern_path, pid_ns_ctl_table);\r\n#endif\r\nreturn 0;\r\n}
