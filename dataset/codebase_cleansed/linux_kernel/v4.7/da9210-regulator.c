static int da9210_set_current_limit(struct regulator_dev *rdev, int min_uA,\r\nint max_uA)\r\n{\r\nstruct da9210 *chip = rdev_get_drvdata(rdev);\r\nunsigned int sel;\r\nint i;\r\nfor (i = ARRAY_SIZE(da9210_buck_limits)-1; i >= 0; i--) {\r\nif (min_uA <= da9210_buck_limits[i] &&\r\nmax_uA >= da9210_buck_limits[i]) {\r\nsel = i;\r\nsel = sel << DA9210_BUCK_ILIM_SHIFT;\r\nreturn regmap_update_bits(chip->regmap,\r\nDA9210_REG_BUCK_ILIM,\r\nDA9210_BUCK_ILIM_MASK, sel);\r\n}\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int da9210_get_current_limit(struct regulator_dev *rdev)\r\n{\r\nstruct da9210 *chip = rdev_get_drvdata(rdev);\r\nunsigned int data;\r\nunsigned int sel;\r\nint ret;\r\nret = regmap_read(chip->regmap, DA9210_REG_BUCK_ILIM, &data);\r\nif (ret < 0)\r\nreturn ret;\r\nsel = (data & DA9210_BUCK_ILIM_MASK) >> DA9210_BUCK_ILIM_SHIFT;\r\nreturn da9210_buck_limits[sel];\r\n}\r\nstatic irqreturn_t da9210_irq_handler(int irq, void *data)\r\n{\r\nstruct da9210 *chip = data;\r\nunsigned int val, handled = 0;\r\nint error, ret = IRQ_NONE;\r\nerror = regmap_read(chip->regmap, DA9210_REG_EVENT_B, &val);\r\nif (error < 0)\r\ngoto error_i2c;\r\nmutex_lock(&chip->rdev->mutex);\r\nif (val & DA9210_E_OVCURR) {\r\nregulator_notifier_call_chain(chip->rdev,\r\nREGULATOR_EVENT_OVER_CURRENT,\r\nNULL);\r\nhandled |= DA9210_E_OVCURR;\r\n}\r\nif (val & DA9210_E_NPWRGOOD) {\r\nregulator_notifier_call_chain(chip->rdev,\r\nREGULATOR_EVENT_UNDER_VOLTAGE,\r\nNULL);\r\nhandled |= DA9210_E_NPWRGOOD;\r\n}\r\nif (val & (DA9210_E_TEMP_WARN | DA9210_E_TEMP_CRIT)) {\r\nregulator_notifier_call_chain(chip->rdev,\r\nREGULATOR_EVENT_OVER_TEMP, NULL);\r\nhandled |= val & (DA9210_E_TEMP_WARN | DA9210_E_TEMP_CRIT);\r\n}\r\nif (val & DA9210_E_VMAX) {\r\nregulator_notifier_call_chain(chip->rdev,\r\nREGULATOR_EVENT_REGULATION_OUT,\r\nNULL);\r\nhandled |= DA9210_E_VMAX;\r\n}\r\nmutex_unlock(&chip->rdev->mutex);\r\nif (handled) {\r\nerror = regmap_write(chip->regmap, DA9210_REG_EVENT_B, handled);\r\nif (error < 0)\r\ngoto error_i2c;\r\nret = IRQ_HANDLED;\r\n}\r\nreturn ret;\r\nerror_i2c:\r\ndev_err(regmap_get_device(chip->regmap), "I2C error : %d\n", error);\r\nreturn ret;\r\n}\r\nstatic int da9210_i2c_probe(struct i2c_client *i2c,\r\nconst struct i2c_device_id *id)\r\n{\r\nstruct da9210 *chip;\r\nstruct device *dev = &i2c->dev;\r\nstruct da9210_pdata *pdata = dev_get_platdata(dev);\r\nstruct regulator_dev *rdev = NULL;\r\nstruct regulator_config config = { };\r\nint error;\r\nchip = devm_kzalloc(&i2c->dev, sizeof(struct da9210), GFP_KERNEL);\r\nif (!chip)\r\nreturn -ENOMEM;\r\nchip->regmap = devm_regmap_init_i2c(i2c, &da9210_regmap_config);\r\nif (IS_ERR(chip->regmap)) {\r\nerror = PTR_ERR(chip->regmap);\r\ndev_err(&i2c->dev, "Failed to allocate register map: %d\n",\r\nerror);\r\nreturn error;\r\n}\r\nconfig.dev = &i2c->dev;\r\nconfig.init_data = pdata ? &pdata->da9210_constraints :\r\nof_get_regulator_init_data(dev, dev->of_node, &da9210_reg);\r\nconfig.driver_data = chip;\r\nconfig.regmap = chip->regmap;\r\nconfig.of_node = dev->of_node;\r\nerror = regmap_write(chip->regmap, DA9210_REG_MASK_A, ~0);\r\nif (!error)\r\nerror = regmap_write(chip->regmap, DA9210_REG_MASK_B, ~0);\r\nif (error) {\r\ndev_err(&i2c->dev, "Failed to write to mask reg: %d\n", error);\r\nreturn error;\r\n}\r\nrdev = devm_regulator_register(&i2c->dev, &da9210_reg, &config);\r\nif (IS_ERR(rdev)) {\r\ndev_err(&i2c->dev, "Failed to register DA9210 regulator\n");\r\nreturn PTR_ERR(rdev);\r\n}\r\nchip->rdev = rdev;\r\nif (i2c->irq) {\r\nerror = devm_request_threaded_irq(&i2c->dev, i2c->irq, NULL,\r\nda9210_irq_handler,\r\nIRQF_TRIGGER_LOW |\r\nIRQF_ONESHOT | IRQF_SHARED,\r\n"da9210", chip);\r\nif (error) {\r\ndev_err(&i2c->dev, "Failed to request IRQ%u: %d\n",\r\ni2c->irq, error);\r\nreturn error;\r\n}\r\nerror = regmap_update_bits(chip->regmap, DA9210_REG_MASK_B,\r\nDA9210_M_OVCURR | DA9210_M_NPWRGOOD |\r\nDA9210_M_TEMP_WARN |\r\nDA9210_M_TEMP_CRIT | DA9210_M_VMAX, 0);\r\nif (error < 0) {\r\ndev_err(&i2c->dev, "Failed to update mask reg: %d\n",\r\nerror);\r\nreturn error;\r\n}\r\n} else {\r\ndev_warn(&i2c->dev, "No IRQ configured\n");\r\n}\r\ni2c_set_clientdata(i2c, chip);\r\nreturn 0;\r\n}
