static int\r\nkernel_sock_unlocked_ioctl(struct file *filp, int cmd, unsigned long arg)\r\n{\r\nmm_segment_t oldfs = get_fs();\r\nint err;\r\nset_fs(KERNEL_DS);\r\nerr = filp->f_op->unlocked_ioctl(filp, cmd, arg);\r\nset_fs(oldfs);\r\nreturn err;\r\n}\r\nstatic int\r\nlnet_sock_ioctl(int cmd, unsigned long arg)\r\n{\r\nstruct file *sock_filp;\r\nstruct socket *sock;\r\nint rc;\r\nrc = sock_create(PF_INET, SOCK_STREAM, 0, &sock);\r\nif (rc) {\r\nCERROR("Can't create socket: %d\n", rc);\r\nreturn rc;\r\n}\r\nsock_filp = sock_alloc_file(sock, 0, NULL);\r\nif (IS_ERR(sock_filp)) {\r\nsock_release(sock);\r\nrc = PTR_ERR(sock_filp);\r\ngoto out;\r\n}\r\nrc = kernel_sock_unlocked_ioctl(sock_filp, cmd, arg);\r\nfput(sock_filp);\r\nout:\r\nreturn rc;\r\n}\r\nint\r\nlnet_ipif_query(char *name, int *up, __u32 *ip, __u32 *mask)\r\n{\r\nstruct ifreq ifr;\r\nint nob;\r\nint rc;\r\n__u32 val;\r\nnob = strnlen(name, IFNAMSIZ);\r\nif (nob == IFNAMSIZ) {\r\nCERROR("Interface name %s too long\n", name);\r\nreturn -EINVAL;\r\n}\r\nCLASSERT(sizeof(ifr.ifr_name) >= IFNAMSIZ);\r\nif (strlen(name) > sizeof(ifr.ifr_name) - 1)\r\nreturn -E2BIG;\r\nstrncpy(ifr.ifr_name, name, sizeof(ifr.ifr_name));\r\nrc = lnet_sock_ioctl(SIOCGIFFLAGS, (unsigned long)&ifr);\r\nif (rc) {\r\nCERROR("Can't get flags for interface %s\n", name);\r\nreturn rc;\r\n}\r\nif (!(ifr.ifr_flags & IFF_UP)) {\r\nCDEBUG(D_NET, "Interface %s down\n", name);\r\n*up = 0;\r\n*ip = *mask = 0;\r\nreturn 0;\r\n}\r\n*up = 1;\r\nif (strlen(name) > sizeof(ifr.ifr_name) - 1)\r\nreturn -E2BIG;\r\nstrncpy(ifr.ifr_name, name, sizeof(ifr.ifr_name));\r\nifr.ifr_addr.sa_family = AF_INET;\r\nrc = lnet_sock_ioctl(SIOCGIFADDR, (unsigned long)&ifr);\r\nif (rc) {\r\nCERROR("Can't get IP address for interface %s\n", name);\r\nreturn rc;\r\n}\r\nval = ((struct sockaddr_in *)&ifr.ifr_addr)->sin_addr.s_addr;\r\n*ip = ntohl(val);\r\nif (strlen(name) > sizeof(ifr.ifr_name) - 1)\r\nreturn -E2BIG;\r\nstrncpy(ifr.ifr_name, name, sizeof(ifr.ifr_name));\r\nifr.ifr_addr.sa_family = AF_INET;\r\nrc = lnet_sock_ioctl(SIOCGIFNETMASK, (unsigned long)&ifr);\r\nif (rc) {\r\nCERROR("Can't get netmask for interface %s\n", name);\r\nreturn rc;\r\n}\r\nval = ((struct sockaddr_in *)&ifr.ifr_netmask)->sin_addr.s_addr;\r\n*mask = ntohl(val);\r\nreturn 0;\r\n}\r\nint\r\nlnet_ipif_enumerate(char ***namesp)\r\n{\r\nchar **names;\r\nint toobig;\r\nint nalloc;\r\nint nfound;\r\nstruct ifreq *ifr;\r\nstruct ifconf ifc;\r\nint rc;\r\nint nob;\r\nint i;\r\nnalloc = 16;\r\ntoobig = 0;\r\nfor (;;) {\r\nif (nalloc * sizeof(*ifr) > PAGE_SIZE) {\r\ntoobig = 1;\r\nnalloc = PAGE_SIZE / sizeof(*ifr);\r\nCWARN("Too many interfaces: only enumerating first %d\n",\r\nnalloc);\r\n}\r\nLIBCFS_ALLOC(ifr, nalloc * sizeof(*ifr));\r\nif (!ifr) {\r\nCERROR("ENOMEM enumerating up to %d interfaces\n",\r\nnalloc);\r\nrc = -ENOMEM;\r\ngoto out0;\r\n}\r\nifc.ifc_buf = (char *)ifr;\r\nifc.ifc_len = nalloc * sizeof(*ifr);\r\nrc = lnet_sock_ioctl(SIOCGIFCONF, (unsigned long)&ifc);\r\nif (rc < 0) {\r\nCERROR("Error %d enumerating interfaces\n", rc);\r\ngoto out1;\r\n}\r\nLASSERT(!rc);\r\nnfound = ifc.ifc_len / sizeof(*ifr);\r\nLASSERT(nfound <= nalloc);\r\nif (nfound < nalloc || toobig)\r\nbreak;\r\nLIBCFS_FREE(ifr, nalloc * sizeof(*ifr));\r\nnalloc *= 2;\r\n}\r\nif (!nfound)\r\ngoto out1;\r\nLIBCFS_ALLOC(names, nfound * sizeof(*names));\r\nif (!names) {\r\nrc = -ENOMEM;\r\ngoto out1;\r\n}\r\nfor (i = 0; i < nfound; i++) {\r\nnob = strnlen(ifr[i].ifr_name, IFNAMSIZ);\r\nif (nob == IFNAMSIZ) {\r\nCERROR("interface name %.*s too long (%d max)\n",\r\nnob, ifr[i].ifr_name, IFNAMSIZ);\r\nrc = -ENAMETOOLONG;\r\ngoto out2;\r\n}\r\nLIBCFS_ALLOC(names[i], IFNAMSIZ);\r\nif (!names[i]) {\r\nrc = -ENOMEM;\r\ngoto out2;\r\n}\r\nmemcpy(names[i], ifr[i].ifr_name, nob);\r\nnames[i][nob] = 0;\r\n}\r\n*namesp = names;\r\nrc = nfound;\r\nout2:\r\nif (rc < 0)\r\nlnet_ipif_free_enumeration(names, nfound);\r\nout1:\r\nLIBCFS_FREE(ifr, nalloc * sizeof(*ifr));\r\nout0:\r\nreturn rc;\r\n}\r\nvoid\r\nlnet_ipif_free_enumeration(char **names, int n)\r\n{\r\nint i;\r\nLASSERT(n > 0);\r\nfor (i = 0; i < n && names[i]; i++)\r\nLIBCFS_FREE(names[i], IFNAMSIZ);\r\nLIBCFS_FREE(names, n * sizeof(*names));\r\n}\r\nint\r\nlnet_sock_write(struct socket *sock, void *buffer, int nob, int timeout)\r\n{\r\nint rc;\r\nlong jiffies_left = timeout * msecs_to_jiffies(MSEC_PER_SEC);\r\nunsigned long then;\r\nstruct timeval tv;\r\nLASSERT(nob > 0);\r\nfor (;;) {\r\nstruct kvec iov = {\r\n.iov_base = buffer,\r\n.iov_len = nob\r\n};\r\nstruct msghdr msg = {\r\n.msg_flags = !timeout ? MSG_DONTWAIT : 0\r\n};\r\nif (timeout) {\r\njiffies_to_timeval(jiffies_left, &tv);\r\nrc = kernel_setsockopt(sock, SOL_SOCKET, SO_SNDTIMEO,\r\n(char *)&tv, sizeof(tv));\r\nif (rc) {\r\nCERROR("Can't set socket send timeout %ld.%06d: %d\n",\r\n(long)tv.tv_sec, (int)tv.tv_usec, rc);\r\nreturn rc;\r\n}\r\n}\r\nthen = jiffies;\r\nrc = kernel_sendmsg(sock, &msg, &iov, 1, nob);\r\njiffies_left -= jiffies - then;\r\nif (rc == nob)\r\nreturn 0;\r\nif (rc < 0)\r\nreturn rc;\r\nif (!rc) {\r\nCERROR("Unexpected zero rc\n");\r\nreturn -ECONNABORTED;\r\n}\r\nif (jiffies_left <= 0)\r\nreturn -EAGAIN;\r\nbuffer = ((char *)buffer) + rc;\r\nnob -= rc;\r\n}\r\nreturn 0;\r\n}\r\nint\r\nlnet_sock_read(struct socket *sock, void *buffer, int nob, int timeout)\r\n{\r\nint rc;\r\nlong jiffies_left = timeout * msecs_to_jiffies(MSEC_PER_SEC);\r\nunsigned long then;\r\nstruct timeval tv;\r\nLASSERT(nob > 0);\r\nLASSERT(jiffies_left > 0);\r\nfor (;;) {\r\nstruct kvec iov = {\r\n.iov_base = buffer,\r\n.iov_len = nob\r\n};\r\nstruct msghdr msg = {\r\n.msg_flags = 0\r\n};\r\njiffies_to_timeval(jiffies_left, &tv);\r\nrc = kernel_setsockopt(sock, SOL_SOCKET, SO_RCVTIMEO,\r\n(char *)&tv, sizeof(tv));\r\nif (rc) {\r\nCERROR("Can't set socket recv timeout %ld.%06d: %d\n",\r\n(long)tv.tv_sec, (int)tv.tv_usec, rc);\r\nreturn rc;\r\n}\r\nthen = jiffies;\r\nrc = kernel_recvmsg(sock, &msg, &iov, 1, nob, 0);\r\njiffies_left -= jiffies - then;\r\nif (rc < 0)\r\nreturn rc;\r\nif (!rc)\r\nreturn -ECONNRESET;\r\nbuffer = ((char *)buffer) + rc;\r\nnob -= rc;\r\nif (!nob)\r\nreturn 0;\r\nif (jiffies_left <= 0)\r\nreturn -ETIMEDOUT;\r\n}\r\n}\r\nstatic int\r\nlnet_sock_create(struct socket **sockp, int *fatal, __u32 local_ip,\r\nint local_port)\r\n{\r\nstruct sockaddr_in locaddr;\r\nstruct socket *sock;\r\nint rc;\r\nint option;\r\n*fatal = 1;\r\nrc = sock_create(PF_INET, SOCK_STREAM, 0, &sock);\r\n*sockp = sock;\r\nif (rc) {\r\nCERROR("Can't create socket: %d\n", rc);\r\nreturn rc;\r\n}\r\noption = 1;\r\nrc = kernel_setsockopt(sock, SOL_SOCKET, SO_REUSEADDR,\r\n(char *)&option, sizeof(option));\r\nif (rc) {\r\nCERROR("Can't set SO_REUSEADDR for socket: %d\n", rc);\r\ngoto failed;\r\n}\r\nif (local_ip || local_port) {\r\nmemset(&locaddr, 0, sizeof(locaddr));\r\nlocaddr.sin_family = AF_INET;\r\nlocaddr.sin_port = htons(local_port);\r\nlocaddr.sin_addr.s_addr = !local_ip ?\r\nINADDR_ANY : htonl(local_ip);\r\nrc = kernel_bind(sock, (struct sockaddr *)&locaddr,\r\nsizeof(locaddr));\r\nif (rc == -EADDRINUSE) {\r\nCDEBUG(D_NET, "Port %d already in use\n", local_port);\r\n*fatal = 0;\r\ngoto failed;\r\n}\r\nif (rc) {\r\nCERROR("Error trying to bind to port %d: %d\n",\r\nlocal_port, rc);\r\ngoto failed;\r\n}\r\n}\r\nreturn 0;\r\nfailed:\r\nsock_release(sock);\r\nreturn rc;\r\n}\r\nint\r\nlnet_sock_setbuf(struct socket *sock, int txbufsize, int rxbufsize)\r\n{\r\nint option;\r\nint rc;\r\nif (txbufsize) {\r\noption = txbufsize;\r\nrc = kernel_setsockopt(sock, SOL_SOCKET, SO_SNDBUF,\r\n(char *)&option, sizeof(option));\r\nif (rc) {\r\nCERROR("Can't set send buffer %d: %d\n",\r\noption, rc);\r\nreturn rc;\r\n}\r\n}\r\nif (rxbufsize) {\r\noption = rxbufsize;\r\nrc = kernel_setsockopt(sock, SOL_SOCKET, SO_RCVBUF,\r\n(char *)&option, sizeof(option));\r\nif (rc) {\r\nCERROR("Can't set receive buffer %d: %d\n",\r\noption, rc);\r\nreturn rc;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nint\r\nlnet_sock_getaddr(struct socket *sock, bool remote, __u32 *ip, int *port)\r\n{\r\nstruct sockaddr_in sin;\r\nint len = sizeof(sin);\r\nint rc;\r\nif (remote)\r\nrc = kernel_getpeername(sock, (struct sockaddr *)&sin, &len);\r\nelse\r\nrc = kernel_getsockname(sock, (struct sockaddr *)&sin, &len);\r\nif (rc) {\r\nCERROR("Error %d getting sock %s IP/port\n",\r\nrc, remote ? "peer" : "local");\r\nreturn rc;\r\n}\r\nif (ip)\r\n*ip = ntohl(sin.sin_addr.s_addr);\r\nif (port)\r\n*port = ntohs(sin.sin_port);\r\nreturn 0;\r\n}\r\nint\r\nlnet_sock_getbuf(struct socket *sock, int *txbufsize, int *rxbufsize)\r\n{\r\nif (txbufsize)\r\n*txbufsize = sock->sk->sk_sndbuf;\r\nif (rxbufsize)\r\n*rxbufsize = sock->sk->sk_rcvbuf;\r\nreturn 0;\r\n}\r\nint\r\nlnet_sock_listen(struct socket **sockp, __u32 local_ip, int local_port,\r\nint backlog)\r\n{\r\nint fatal;\r\nint rc;\r\nrc = lnet_sock_create(sockp, &fatal, local_ip, local_port);\r\nif (rc) {\r\nif (!fatal)\r\nCERROR("Can't create socket: port %d already in use\n",\r\nlocal_port);\r\nreturn rc;\r\n}\r\nrc = kernel_listen(*sockp, backlog);\r\nif (!rc)\r\nreturn 0;\r\nCERROR("Can't set listen backlog %d: %d\n", backlog, rc);\r\nsock_release(*sockp);\r\nreturn rc;\r\n}\r\nint\r\nlnet_sock_accept(struct socket **newsockp, struct socket *sock)\r\n{\r\nwait_queue_t wait;\r\nstruct socket *newsock;\r\nint rc;\r\nrc = sock_create_lite(PF_PACKET, sock->type, IPPROTO_TCP, &newsock);\r\nif (rc) {\r\nCERROR("Can't allocate socket\n");\r\nreturn rc;\r\n}\r\nnewsock->ops = sock->ops;\r\nrc = sock->ops->accept(sock, newsock, O_NONBLOCK);\r\nif (rc == -EAGAIN) {\r\ninit_waitqueue_entry(&wait, current);\r\nadd_wait_queue(sk_sleep(sock->sk), &wait);\r\nset_current_state(TASK_INTERRUPTIBLE);\r\nschedule();\r\nremove_wait_queue(sk_sleep(sock->sk), &wait);\r\nrc = sock->ops->accept(sock, newsock, O_NONBLOCK);\r\n}\r\nif (rc)\r\ngoto failed;\r\n*newsockp = newsock;\r\nreturn 0;\r\nfailed:\r\nsock_release(newsock);\r\nreturn rc;\r\n}\r\nint\r\nlnet_sock_connect(struct socket **sockp, int *fatal, __u32 local_ip,\r\nint local_port, __u32 peer_ip, int peer_port)\r\n{\r\nstruct sockaddr_in srvaddr;\r\nint rc;\r\nrc = lnet_sock_create(sockp, fatal, local_ip, local_port);\r\nif (rc)\r\nreturn rc;\r\nmemset(&srvaddr, 0, sizeof(srvaddr));\r\nsrvaddr.sin_family = AF_INET;\r\nsrvaddr.sin_port = htons(peer_port);\r\nsrvaddr.sin_addr.s_addr = htonl(peer_ip);\r\nrc = kernel_connect(*sockp, (struct sockaddr *)&srvaddr,\r\nsizeof(srvaddr), 0);\r\nif (!rc)\r\nreturn 0;\r\n*fatal = !(rc == -EADDRNOTAVAIL);\r\nCDEBUG_LIMIT(*fatal ? D_NETERROR : D_NET,\r\n"Error %d connecting %pI4h/%d -> %pI4h/%d\n", rc,\r\n&local_ip, local_port, &peer_ip, peer_port);\r\nsock_release(*sockp);\r\nreturn rc;\r\n}
