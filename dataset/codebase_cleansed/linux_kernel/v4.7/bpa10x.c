static void bpa10x_tx_complete(struct urb *urb)\r\n{\r\nstruct sk_buff *skb = urb->context;\r\nstruct hci_dev *hdev = (struct hci_dev *) skb->dev;\r\nBT_DBG("%s urb %p status %d count %d", hdev->name,\r\nurb, urb->status, urb->actual_length);\r\nif (!test_bit(HCI_RUNNING, &hdev->flags))\r\ngoto done;\r\nif (!urb->status)\r\nhdev->stat.byte_tx += urb->transfer_buffer_length;\r\nelse\r\nhdev->stat.err_tx++;\r\ndone:\r\nkfree(urb->setup_packet);\r\nkfree_skb(skb);\r\n}\r\nstatic void bpa10x_rx_complete(struct urb *urb)\r\n{\r\nstruct hci_dev *hdev = urb->context;\r\nstruct bpa10x_data *data = hci_get_drvdata(hdev);\r\nint err;\r\nBT_DBG("%s urb %p status %d count %d", hdev->name,\r\nurb, urb->status, urb->actual_length);\r\nif (!test_bit(HCI_RUNNING, &hdev->flags))\r\nreturn;\r\nif (urb->status == 0) {\r\nbool idx = usb_pipebulk(urb->pipe);\r\ndata->rx_skb[idx] = h4_recv_buf(hdev, data->rx_skb[idx],\r\nurb->transfer_buffer,\r\nurb->actual_length,\r\nbpa10x_recv_pkts,\r\nARRAY_SIZE(bpa10x_recv_pkts));\r\nif (IS_ERR(data->rx_skb[idx])) {\r\nBT_ERR("%s corrupted event packet", hdev->name);\r\nhdev->stat.err_rx++;\r\ndata->rx_skb[idx] = NULL;\r\n}\r\n}\r\nusb_anchor_urb(urb, &data->rx_anchor);\r\nerr = usb_submit_urb(urb, GFP_ATOMIC);\r\nif (err < 0) {\r\nBT_ERR("%s urb %p failed to resubmit (%d)",\r\nhdev->name, urb, -err);\r\nusb_unanchor_urb(urb);\r\n}\r\n}\r\nstatic inline int bpa10x_submit_intr_urb(struct hci_dev *hdev)\r\n{\r\nstruct bpa10x_data *data = hci_get_drvdata(hdev);\r\nstruct urb *urb;\r\nunsigned char *buf;\r\nunsigned int pipe;\r\nint err, size = 16;\r\nBT_DBG("%s", hdev->name);\r\nurb = usb_alloc_urb(0, GFP_KERNEL);\r\nif (!urb)\r\nreturn -ENOMEM;\r\nbuf = kmalloc(size, GFP_KERNEL);\r\nif (!buf) {\r\nusb_free_urb(urb);\r\nreturn -ENOMEM;\r\n}\r\npipe = usb_rcvintpipe(data->udev, 0x81);\r\nusb_fill_int_urb(urb, data->udev, pipe, buf, size,\r\nbpa10x_rx_complete, hdev, 1);\r\nurb->transfer_flags |= URB_FREE_BUFFER;\r\nusb_anchor_urb(urb, &data->rx_anchor);\r\nerr = usb_submit_urb(urb, GFP_KERNEL);\r\nif (err < 0) {\r\nBT_ERR("%s urb %p submission failed (%d)",\r\nhdev->name, urb, -err);\r\nusb_unanchor_urb(urb);\r\n}\r\nusb_free_urb(urb);\r\nreturn err;\r\n}\r\nstatic inline int bpa10x_submit_bulk_urb(struct hci_dev *hdev)\r\n{\r\nstruct bpa10x_data *data = hci_get_drvdata(hdev);\r\nstruct urb *urb;\r\nunsigned char *buf;\r\nunsigned int pipe;\r\nint err, size = 64;\r\nBT_DBG("%s", hdev->name);\r\nurb = usb_alloc_urb(0, GFP_KERNEL);\r\nif (!urb)\r\nreturn -ENOMEM;\r\nbuf = kmalloc(size, GFP_KERNEL);\r\nif (!buf) {\r\nusb_free_urb(urb);\r\nreturn -ENOMEM;\r\n}\r\npipe = usb_rcvbulkpipe(data->udev, 0x82);\r\nusb_fill_bulk_urb(urb, data->udev, pipe,\r\nbuf, size, bpa10x_rx_complete, hdev);\r\nurb->transfer_flags |= URB_FREE_BUFFER;\r\nusb_anchor_urb(urb, &data->rx_anchor);\r\nerr = usb_submit_urb(urb, GFP_KERNEL);\r\nif (err < 0) {\r\nBT_ERR("%s urb %p submission failed (%d)",\r\nhdev->name, urb, -err);\r\nusb_unanchor_urb(urb);\r\n}\r\nusb_free_urb(urb);\r\nreturn err;\r\n}\r\nstatic int bpa10x_open(struct hci_dev *hdev)\r\n{\r\nstruct bpa10x_data *data = hci_get_drvdata(hdev);\r\nint err;\r\nBT_DBG("%s", hdev->name);\r\nerr = bpa10x_submit_intr_urb(hdev);\r\nif (err < 0)\r\ngoto error;\r\nerr = bpa10x_submit_bulk_urb(hdev);\r\nif (err < 0)\r\ngoto error;\r\nreturn 0;\r\nerror:\r\nusb_kill_anchored_urbs(&data->rx_anchor);\r\nreturn err;\r\n}\r\nstatic int bpa10x_close(struct hci_dev *hdev)\r\n{\r\nstruct bpa10x_data *data = hci_get_drvdata(hdev);\r\nBT_DBG("%s", hdev->name);\r\nusb_kill_anchored_urbs(&data->rx_anchor);\r\nreturn 0;\r\n}\r\nstatic int bpa10x_flush(struct hci_dev *hdev)\r\n{\r\nstruct bpa10x_data *data = hci_get_drvdata(hdev);\r\nBT_DBG("%s", hdev->name);\r\nusb_kill_anchored_urbs(&data->tx_anchor);\r\nreturn 0;\r\n}\r\nstatic int bpa10x_setup(struct hci_dev *hdev)\r\n{\r\nconst u8 req[] = { 0x07 };\r\nstruct sk_buff *skb;\r\nBT_DBG("%s", hdev->name);\r\nskb = __hci_cmd_sync(hdev, 0xfc0e, sizeof(req), req, HCI_INIT_TIMEOUT);\r\nif (IS_ERR(skb))\r\nreturn PTR_ERR(skb);\r\nBT_INFO("%s: %s", hdev->name, (char *)(skb->data + 1));\r\nkfree_skb(skb);\r\nreturn 0;\r\n}\r\nstatic int bpa10x_send_frame(struct hci_dev *hdev, struct sk_buff *skb)\r\n{\r\nstruct bpa10x_data *data = hci_get_drvdata(hdev);\r\nstruct usb_ctrlrequest *dr;\r\nstruct urb *urb;\r\nunsigned int pipe;\r\nint err;\r\nBT_DBG("%s", hdev->name);\r\nskb->dev = (void *) hdev;\r\nurb = usb_alloc_urb(0, GFP_ATOMIC);\r\nif (!urb)\r\nreturn -ENOMEM;\r\n*skb_push(skb, 1) = hci_skb_pkt_type(skb);\r\nswitch (hci_skb_pkt_type(skb)) {\r\ncase HCI_COMMAND_PKT:\r\ndr = kmalloc(sizeof(*dr), GFP_ATOMIC);\r\nif (!dr) {\r\nusb_free_urb(urb);\r\nreturn -ENOMEM;\r\n}\r\ndr->bRequestType = USB_TYPE_VENDOR;\r\ndr->bRequest = 0;\r\ndr->wIndex = 0;\r\ndr->wValue = 0;\r\ndr->wLength = __cpu_to_le16(skb->len);\r\npipe = usb_sndctrlpipe(data->udev, 0x00);\r\nusb_fill_control_urb(urb, data->udev, pipe, (void *) dr,\r\nskb->data, skb->len, bpa10x_tx_complete, skb);\r\nhdev->stat.cmd_tx++;\r\nbreak;\r\ncase HCI_ACLDATA_PKT:\r\npipe = usb_sndbulkpipe(data->udev, 0x02);\r\nusb_fill_bulk_urb(urb, data->udev, pipe,\r\nskb->data, skb->len, bpa10x_tx_complete, skb);\r\nhdev->stat.acl_tx++;\r\nbreak;\r\ncase HCI_SCODATA_PKT:\r\npipe = usb_sndbulkpipe(data->udev, 0x02);\r\nusb_fill_bulk_urb(urb, data->udev, pipe,\r\nskb->data, skb->len, bpa10x_tx_complete, skb);\r\nhdev->stat.sco_tx++;\r\nbreak;\r\ndefault:\r\nusb_free_urb(urb);\r\nreturn -EILSEQ;\r\n}\r\nusb_anchor_urb(urb, &data->tx_anchor);\r\nerr = usb_submit_urb(urb, GFP_ATOMIC);\r\nif (err < 0) {\r\nBT_ERR("%s urb %p submission failed", hdev->name, urb);\r\nkfree(urb->setup_packet);\r\nusb_unanchor_urb(urb);\r\n}\r\nusb_free_urb(urb);\r\nreturn 0;\r\n}\r\nstatic int bpa10x_set_diag(struct hci_dev *hdev, bool enable)\r\n{\r\nconst u8 req[] = { 0x00, enable };\r\nstruct sk_buff *skb;\r\nBT_DBG("%s", hdev->name);\r\nif (!test_bit(HCI_RUNNING, &hdev->flags))\r\nreturn -ENETDOWN;\r\nskb = __hci_cmd_sync(hdev, 0xfc0e, sizeof(req), req, HCI_INIT_TIMEOUT);\r\nif (IS_ERR(skb))\r\nreturn PTR_ERR(skb);\r\nkfree_skb(skb);\r\nreturn 0;\r\n}\r\nstatic int bpa10x_probe(struct usb_interface *intf, const struct usb_device_id *id)\r\n{\r\nstruct bpa10x_data *data;\r\nstruct hci_dev *hdev;\r\nint err;\r\nBT_DBG("intf %p id %p", intf, id);\r\nif (intf->cur_altsetting->desc.bInterfaceNumber != 0)\r\nreturn -ENODEV;\r\ndata = devm_kzalloc(&intf->dev, sizeof(*data), GFP_KERNEL);\r\nif (!data)\r\nreturn -ENOMEM;\r\ndata->udev = interface_to_usbdev(intf);\r\ninit_usb_anchor(&data->tx_anchor);\r\ninit_usb_anchor(&data->rx_anchor);\r\nhdev = hci_alloc_dev();\r\nif (!hdev)\r\nreturn -ENOMEM;\r\nhdev->bus = HCI_USB;\r\nhci_set_drvdata(hdev, data);\r\ndata->hdev = hdev;\r\nSET_HCIDEV_DEV(hdev, &intf->dev);\r\nhdev->open = bpa10x_open;\r\nhdev->close = bpa10x_close;\r\nhdev->flush = bpa10x_flush;\r\nhdev->setup = bpa10x_setup;\r\nhdev->send = bpa10x_send_frame;\r\nhdev->set_diag = bpa10x_set_diag;\r\nset_bit(HCI_QUIRK_RESET_ON_CLOSE, &hdev->quirks);\r\nerr = hci_register_dev(hdev);\r\nif (err < 0) {\r\nhci_free_dev(hdev);\r\nreturn err;\r\n}\r\nusb_set_intfdata(intf, data);\r\nreturn 0;\r\n}\r\nstatic void bpa10x_disconnect(struct usb_interface *intf)\r\n{\r\nstruct bpa10x_data *data = usb_get_intfdata(intf);\r\nBT_DBG("intf %p", intf);\r\nif (!data)\r\nreturn;\r\nusb_set_intfdata(intf, NULL);\r\nhci_unregister_dev(data->hdev);\r\nhci_free_dev(data->hdev);\r\nkfree_skb(data->rx_skb[0]);\r\nkfree_skb(data->rx_skb[1]);\r\n}
