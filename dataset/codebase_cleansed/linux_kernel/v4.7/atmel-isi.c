static void set_dma_ctrl(struct fbd *fb_desc, u32 ctrl)\r\n{\r\nfb_desc->dma_ctrl = ctrl;\r\n}\r\nstatic void isi_writel(struct atmel_isi *isi, u32 reg, u32 val)\r\n{\r\nwritel(val, isi->regs + reg);\r\n}\r\nstatic u32 isi_readl(struct atmel_isi *isi, u32 reg)\r\n{\r\nreturn readl(isi->regs + reg);\r\n}\r\nstatic u32 setup_cfg2_yuv_swap(struct atmel_isi *isi,\r\nconst struct soc_camera_format_xlate *xlate)\r\n{\r\nif (xlate->host_fmt->fourcc == V4L2_PIX_FMT_YUYV) {\r\nswitch (xlate->code) {\r\ncase MEDIA_BUS_FMT_VYUY8_2X8:\r\nreturn ISI_CFG2_YCC_SWAP_MODE_3;\r\ncase MEDIA_BUS_FMT_UYVY8_2X8:\r\nreturn ISI_CFG2_YCC_SWAP_MODE_2;\r\ncase MEDIA_BUS_FMT_YVYU8_2X8:\r\nreturn ISI_CFG2_YCC_SWAP_MODE_1;\r\n}\r\n} else if (xlate->host_fmt->fourcc == V4L2_PIX_FMT_RGB565) {\r\nswitch (xlate->code) {\r\ncase MEDIA_BUS_FMT_VYUY8_2X8:\r\nreturn ISI_CFG2_YCC_SWAP_MODE_1;\r\ncase MEDIA_BUS_FMT_YUYV8_2X8:\r\nreturn ISI_CFG2_YCC_SWAP_MODE_2;\r\ncase MEDIA_BUS_FMT_YVYU8_2X8:\r\nreturn ISI_CFG2_YCC_SWAP_MODE_3;\r\n}\r\n}\r\nreturn ISI_CFG2_YCC_SWAP_DEFAULT;\r\n}\r\nstatic void configure_geometry(struct atmel_isi *isi, u32 width,\r\nu32 height, const struct soc_camera_format_xlate *xlate)\r\n{\r\nu32 cfg2, psize;\r\nu32 fourcc = xlate->host_fmt->fourcc;\r\nisi->enable_preview_path = fourcc == V4L2_PIX_FMT_RGB565 ||\r\nfourcc == V4L2_PIX_FMT_RGB32;\r\nswitch (xlate->code) {\r\ndefault:\r\ncase MEDIA_BUS_FMT_Y8_1X8:\r\ncfg2 = ISI_CFG2_GRAYSCALE | ISI_CFG2_COL_SPACE_YCbCr;\r\nbreak;\r\ncase MEDIA_BUS_FMT_VYUY8_2X8:\r\ncase MEDIA_BUS_FMT_UYVY8_2X8:\r\ncase MEDIA_BUS_FMT_YVYU8_2X8:\r\ncase MEDIA_BUS_FMT_YUYV8_2X8:\r\ncfg2 = ISI_CFG2_COL_SPACE_YCbCr |\r\nsetup_cfg2_yuv_swap(isi, xlate);\r\nbreak;\r\n}\r\nisi_writel(isi, ISI_CTRL, ISI_CTRL_DIS);\r\ncfg2 |= ((width - 1) << ISI_CFG2_IM_HSIZE_OFFSET) &\r\nISI_CFG2_IM_HSIZE_MASK;\r\ncfg2 |= ((height - 1) << ISI_CFG2_IM_VSIZE_OFFSET)\r\n& ISI_CFG2_IM_VSIZE_MASK;\r\nisi_writel(isi, ISI_CFG2, cfg2);\r\npsize = ((width - 1) << ISI_PSIZE_PREV_HSIZE_OFFSET) &\r\nISI_PSIZE_PREV_HSIZE_MASK;\r\npsize |= ((height - 1) << ISI_PSIZE_PREV_VSIZE_OFFSET) &\r\nISI_PSIZE_PREV_VSIZE_MASK;\r\nisi_writel(isi, ISI_PSIZE, psize);\r\nisi_writel(isi, ISI_PDECF, ISI_PDECF_NO_SAMPLING);\r\nreturn;\r\n}\r\nstatic bool is_supported(struct soc_camera_device *icd,\r\nconst u32 pixformat)\r\n{\r\nswitch (pixformat) {\r\ncase V4L2_PIX_FMT_GREY:\r\ncase V4L2_PIX_FMT_YUYV:\r\ncase V4L2_PIX_FMT_UYVY:\r\ncase V4L2_PIX_FMT_YVYU:\r\ncase V4L2_PIX_FMT_VYUY:\r\ncase V4L2_PIX_FMT_RGB565:\r\nreturn true;\r\ndefault:\r\nreturn false;\r\n}\r\n}\r\nstatic irqreturn_t atmel_isi_handle_streaming(struct atmel_isi *isi)\r\n{\r\nif (isi->active) {\r\nstruct vb2_v4l2_buffer *vbuf = &isi->active->vb;\r\nstruct frame_buffer *buf = isi->active;\r\nlist_del_init(&buf->list);\r\nvbuf->vb2_buf.timestamp = ktime_get_ns();\r\nvbuf->sequence = isi->sequence++;\r\nvb2_buffer_done(&vbuf->vb2_buf, VB2_BUF_STATE_DONE);\r\n}\r\nif (list_empty(&isi->video_buffer_list)) {\r\nisi->active = NULL;\r\n} else {\r\nisi->active = list_entry(isi->video_buffer_list.next,\r\nstruct frame_buffer, list);\r\nif (!isi->enable_preview_path) {\r\nisi_writel(isi, ISI_DMA_C_DSCR,\r\n(u32)isi->active->p_dma_desc->fbd_phys);\r\nisi_writel(isi, ISI_DMA_C_CTRL,\r\nISI_DMA_CTRL_FETCH | ISI_DMA_CTRL_DONE);\r\nisi_writel(isi, ISI_DMA_CHER, ISI_DMA_CHSR_C_CH);\r\n} else {\r\nisi_writel(isi, ISI_DMA_P_DSCR,\r\n(u32)isi->active->p_dma_desc->fbd_phys);\r\nisi_writel(isi, ISI_DMA_P_CTRL,\r\nISI_DMA_CTRL_FETCH | ISI_DMA_CTRL_DONE);\r\nisi_writel(isi, ISI_DMA_CHER, ISI_DMA_CHSR_P_CH);\r\n}\r\n}\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic irqreturn_t isi_interrupt(int irq, void *dev_id)\r\n{\r\nstruct atmel_isi *isi = dev_id;\r\nu32 status, mask, pending;\r\nirqreturn_t ret = IRQ_NONE;\r\nspin_lock(&isi->lock);\r\nstatus = isi_readl(isi, ISI_STATUS);\r\nmask = isi_readl(isi, ISI_INTMASK);\r\npending = status & mask;\r\nif (pending & ISI_CTRL_SRST) {\r\ncomplete(&isi->complete);\r\nisi_writel(isi, ISI_INTDIS, ISI_CTRL_SRST);\r\nret = IRQ_HANDLED;\r\n} else if (pending & ISI_CTRL_DIS) {\r\ncomplete(&isi->complete);\r\nisi_writel(isi, ISI_INTDIS, ISI_CTRL_DIS);\r\nret = IRQ_HANDLED;\r\n} else {\r\nif (likely(pending & ISI_SR_CXFR_DONE) ||\r\nlikely(pending & ISI_SR_PXFR_DONE))\r\nret = atmel_isi_handle_streaming(isi);\r\n}\r\nspin_unlock(&isi->lock);\r\nreturn ret;\r\n}\r\nstatic int atmel_isi_wait_status(struct atmel_isi *isi, int wait_reset)\r\n{\r\nunsigned long timeout;\r\ninit_completion(&isi->complete);\r\nif (wait_reset) {\r\nisi_writel(isi, ISI_INTEN, ISI_CTRL_SRST);\r\nisi_writel(isi, ISI_CTRL, ISI_CTRL_SRST);\r\n} else {\r\nisi_writel(isi, ISI_INTEN, ISI_CTRL_DIS);\r\nisi_writel(isi, ISI_CTRL, ISI_CTRL_DIS);\r\n}\r\ntimeout = wait_for_completion_timeout(&isi->complete,\r\nmsecs_to_jiffies(500));\r\nif (timeout == 0)\r\nreturn -ETIMEDOUT;\r\nreturn 0;\r\n}\r\nstatic int queue_setup(struct vb2_queue *vq,\r\nunsigned int *nbuffers, unsigned int *nplanes,\r\nunsigned int sizes[], void *alloc_ctxs[])\r\n{\r\nstruct soc_camera_device *icd = soc_camera_from_vb2q(vq);\r\nstruct soc_camera_host *ici = to_soc_camera_host(icd->parent);\r\nstruct atmel_isi *isi = ici->priv;\r\nunsigned long size;\r\nsize = icd->sizeimage;\r\nif (!*nbuffers || *nbuffers > MAX_BUFFER_NUM)\r\n*nbuffers = MAX_BUFFER_NUM;\r\nif (size * *nbuffers > VID_LIMIT_BYTES)\r\n*nbuffers = VID_LIMIT_BYTES / size;\r\n*nplanes = 1;\r\nsizes[0] = size;\r\nalloc_ctxs[0] = isi->alloc_ctx;\r\nisi->sequence = 0;\r\nisi->active = NULL;\r\ndev_dbg(icd->parent, "%s, count=%d, size=%ld\n", __func__,\r\n*nbuffers, size);\r\nreturn 0;\r\n}\r\nstatic int buffer_init(struct vb2_buffer *vb)\r\n{\r\nstruct vb2_v4l2_buffer *vbuf = to_vb2_v4l2_buffer(vb);\r\nstruct frame_buffer *buf = container_of(vbuf, struct frame_buffer, vb);\r\nbuf->p_dma_desc = NULL;\r\nINIT_LIST_HEAD(&buf->list);\r\nreturn 0;\r\n}\r\nstatic int buffer_prepare(struct vb2_buffer *vb)\r\n{\r\nstruct vb2_v4l2_buffer *vbuf = to_vb2_v4l2_buffer(vb);\r\nstruct soc_camera_device *icd = soc_camera_from_vb2q(vb->vb2_queue);\r\nstruct frame_buffer *buf = container_of(vbuf, struct frame_buffer, vb);\r\nstruct soc_camera_host *ici = to_soc_camera_host(icd->parent);\r\nstruct atmel_isi *isi = ici->priv;\r\nunsigned long size;\r\nstruct isi_dma_desc *desc;\r\nsize = icd->sizeimage;\r\nif (vb2_plane_size(vb, 0) < size) {\r\ndev_err(icd->parent, "%s data will not fit into plane (%lu < %lu)\n",\r\n__func__, vb2_plane_size(vb, 0), size);\r\nreturn -EINVAL;\r\n}\r\nvb2_set_plane_payload(vb, 0, size);\r\nif (!buf->p_dma_desc) {\r\nif (list_empty(&isi->dma_desc_head)) {\r\ndev_err(icd->parent, "Not enough dma descriptors.\n");\r\nreturn -EINVAL;\r\n} else {\r\ndesc = list_entry(isi->dma_desc_head.next,\r\nstruct isi_dma_desc, list);\r\nlist_del_init(&desc->list);\r\ndesc->p_fbd->fb_address =\r\nvb2_dma_contig_plane_dma_addr(vb, 0);\r\ndesc->p_fbd->next_fbd_address = 0;\r\nset_dma_ctrl(desc->p_fbd, ISI_DMA_CTRL_WB);\r\nbuf->p_dma_desc = desc;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic void buffer_cleanup(struct vb2_buffer *vb)\r\n{\r\nstruct vb2_v4l2_buffer *vbuf = to_vb2_v4l2_buffer(vb);\r\nstruct soc_camera_device *icd = soc_camera_from_vb2q(vb->vb2_queue);\r\nstruct soc_camera_host *ici = to_soc_camera_host(icd->parent);\r\nstruct atmel_isi *isi = ici->priv;\r\nstruct frame_buffer *buf = container_of(vbuf, struct frame_buffer, vb);\r\nif (buf->p_dma_desc)\r\nlist_add(&buf->p_dma_desc->list, &isi->dma_desc_head);\r\n}\r\nstatic void start_dma(struct atmel_isi *isi, struct frame_buffer *buffer)\r\n{\r\nu32 ctrl, cfg1;\r\ncfg1 = isi_readl(isi, ISI_CFG1);\r\nisi_writel(isi, ISI_INTEN,\r\nISI_SR_CXFR_DONE | ISI_SR_PXFR_DONE);\r\nif (!isi->enable_preview_path) {\r\nif (isi_readl(isi, ISI_STATUS) & ISI_CTRL_CDC) {\r\ndev_err(isi->soc_host.icd->parent, "Already in frame handling.\n");\r\nreturn;\r\n}\r\nisi_writel(isi, ISI_DMA_C_DSCR,\r\n(u32)buffer->p_dma_desc->fbd_phys);\r\nisi_writel(isi, ISI_DMA_C_CTRL,\r\nISI_DMA_CTRL_FETCH | ISI_DMA_CTRL_DONE);\r\nisi_writel(isi, ISI_DMA_CHER, ISI_DMA_CHSR_C_CH);\r\n} else {\r\nisi_writel(isi, ISI_DMA_P_DSCR,\r\n(u32)buffer->p_dma_desc->fbd_phys);\r\nisi_writel(isi, ISI_DMA_P_CTRL,\r\nISI_DMA_CTRL_FETCH | ISI_DMA_CTRL_DONE);\r\nisi_writel(isi, ISI_DMA_CHER, ISI_DMA_CHSR_P_CH);\r\n}\r\ncfg1 &= ~ISI_CFG1_FRATE_DIV_MASK;\r\ncfg1 |= isi->pdata.frate | ISI_CFG1_DISCR;\r\nctrl = ISI_CTRL_EN;\r\nif (!isi->enable_preview_path)\r\nctrl |= ISI_CTRL_CDC;\r\nisi_writel(isi, ISI_CTRL, ctrl);\r\nisi_writel(isi, ISI_CFG1, cfg1);\r\n}\r\nstatic void buffer_queue(struct vb2_buffer *vb)\r\n{\r\nstruct vb2_v4l2_buffer *vbuf = to_vb2_v4l2_buffer(vb);\r\nstruct soc_camera_device *icd = soc_camera_from_vb2q(vb->vb2_queue);\r\nstruct soc_camera_host *ici = to_soc_camera_host(icd->parent);\r\nstruct atmel_isi *isi = ici->priv;\r\nstruct frame_buffer *buf = container_of(vbuf, struct frame_buffer, vb);\r\nunsigned long flags = 0;\r\nspin_lock_irqsave(&isi->lock, flags);\r\nlist_add_tail(&buf->list, &isi->video_buffer_list);\r\nif (isi->active == NULL) {\r\nisi->active = buf;\r\nif (vb2_is_streaming(vb->vb2_queue))\r\nstart_dma(isi, buf);\r\n}\r\nspin_unlock_irqrestore(&isi->lock, flags);\r\n}\r\nstatic int start_streaming(struct vb2_queue *vq, unsigned int count)\r\n{\r\nstruct soc_camera_device *icd = soc_camera_from_vb2q(vq);\r\nstruct soc_camera_host *ici = to_soc_camera_host(icd->parent);\r\nstruct atmel_isi *isi = ici->priv;\r\nint ret;\r\npm_runtime_get_sync(ici->v4l2_dev.dev);\r\nret = atmel_isi_wait_status(isi, WAIT_ISI_RESET);\r\nif (ret < 0) {\r\ndev_err(icd->parent, "Reset ISI timed out\n");\r\npm_runtime_put(ici->v4l2_dev.dev);\r\nreturn ret;\r\n}\r\nisi_writel(isi, ISI_INTDIS, (u32)~0UL);\r\nconfigure_geometry(isi, icd->user_width, icd->user_height,\r\nicd->current_fmt);\r\nspin_lock_irq(&isi->lock);\r\nisi_readl(isi, ISI_STATUS);\r\nif (count)\r\nstart_dma(isi, isi->active);\r\nspin_unlock_irq(&isi->lock);\r\nreturn 0;\r\n}\r\nstatic void stop_streaming(struct vb2_queue *vq)\r\n{\r\nstruct soc_camera_device *icd = soc_camera_from_vb2q(vq);\r\nstruct soc_camera_host *ici = to_soc_camera_host(icd->parent);\r\nstruct atmel_isi *isi = ici->priv;\r\nstruct frame_buffer *buf, *node;\r\nint ret = 0;\r\nunsigned long timeout;\r\nspin_lock_irq(&isi->lock);\r\nisi->active = NULL;\r\nlist_for_each_entry_safe(buf, node, &isi->video_buffer_list, list) {\r\nlist_del_init(&buf->list);\r\nvb2_buffer_done(&buf->vb.vb2_buf, VB2_BUF_STATE_ERROR);\r\n}\r\nspin_unlock_irq(&isi->lock);\r\nif (!isi->enable_preview_path) {\r\ntimeout = jiffies + FRAME_INTERVAL_MILLI_SEC * HZ;\r\nwhile ((isi_readl(isi, ISI_STATUS) & ISI_CTRL_CDC) &&\r\ntime_before(jiffies, timeout))\r\nmsleep(1);\r\nif (time_after(jiffies, timeout))\r\ndev_err(icd->parent,\r\n"Timeout waiting for finishing codec request\n");\r\n}\r\nisi_writel(isi, ISI_INTDIS,\r\nISI_SR_CXFR_DONE | ISI_SR_PXFR_DONE);\r\nret = atmel_isi_wait_status(isi, WAIT_ISI_DISABLE);\r\nif (ret < 0)\r\ndev_err(icd->parent, "Disable ISI timed out\n");\r\npm_runtime_put(ici->v4l2_dev.dev);\r\n}\r\nstatic int isi_camera_init_videobuf(struct vb2_queue *q,\r\nstruct soc_camera_device *icd)\r\n{\r\nstruct soc_camera_host *ici = to_soc_camera_host(icd->parent);\r\nq->type = V4L2_BUF_TYPE_VIDEO_CAPTURE;\r\nq->io_modes = VB2_MMAP;\r\nq->drv_priv = icd;\r\nq->buf_struct_size = sizeof(struct frame_buffer);\r\nq->ops = &isi_video_qops;\r\nq->mem_ops = &vb2_dma_contig_memops;\r\nq->timestamp_flags = V4L2_BUF_FLAG_TIMESTAMP_MONOTONIC;\r\nq->lock = &ici->host_lock;\r\nreturn vb2_queue_init(q);\r\n}\r\nstatic int isi_camera_set_fmt(struct soc_camera_device *icd,\r\nstruct v4l2_format *f)\r\n{\r\nstruct v4l2_subdev *sd = soc_camera_to_subdev(icd);\r\nconst struct soc_camera_format_xlate *xlate;\r\nstruct v4l2_pix_format *pix = &f->fmt.pix;\r\nstruct v4l2_subdev_format format = {\r\n.which = V4L2_SUBDEV_FORMAT_ACTIVE,\r\n};\r\nstruct v4l2_mbus_framefmt *mf = &format.format;\r\nint ret;\r\nif (!is_supported(icd, pix->pixelformat))\r\npix->pixelformat = V4L2_PIX_FMT_YUYV;\r\nxlate = soc_camera_xlate_by_fourcc(icd, pix->pixelformat);\r\nif (!xlate) {\r\ndev_warn(icd->parent, "Format %x not found\n",\r\npix->pixelformat);\r\nreturn -EINVAL;\r\n}\r\ndev_dbg(icd->parent, "Plan to set format %dx%d\n",\r\npix->width, pix->height);\r\nmf->width = pix->width;\r\nmf->height = pix->height;\r\nmf->field = pix->field;\r\nmf->colorspace = pix->colorspace;\r\nmf->code = xlate->code;\r\nret = v4l2_subdev_call(sd, pad, set_fmt, NULL, &format);\r\nif (ret < 0)\r\nreturn ret;\r\nif (mf->code != xlate->code)\r\nreturn -EINVAL;\r\npix->width = mf->width;\r\npix->height = mf->height;\r\npix->field = mf->field;\r\npix->colorspace = mf->colorspace;\r\nicd->current_fmt = xlate;\r\ndev_dbg(icd->parent, "Finally set format %dx%d\n",\r\npix->width, pix->height);\r\nreturn ret;\r\n}\r\nstatic int isi_camera_try_fmt(struct soc_camera_device *icd,\r\nstruct v4l2_format *f)\r\n{\r\nstruct v4l2_subdev *sd = soc_camera_to_subdev(icd);\r\nconst struct soc_camera_format_xlate *xlate;\r\nstruct v4l2_pix_format *pix = &f->fmt.pix;\r\nstruct v4l2_subdev_pad_config pad_cfg;\r\nstruct v4l2_subdev_format format = {\r\n.which = V4L2_SUBDEV_FORMAT_TRY,\r\n};\r\nstruct v4l2_mbus_framefmt *mf = &format.format;\r\nu32 pixfmt = pix->pixelformat;\r\nint ret;\r\nif (!is_supported(icd, pix->pixelformat))\r\npix->pixelformat = V4L2_PIX_FMT_YUYV;\r\nxlate = soc_camera_xlate_by_fourcc(icd, pixfmt);\r\nif (pixfmt && !xlate) {\r\ndev_warn(icd->parent, "Format %x not found\n", pixfmt);\r\nreturn -EINVAL;\r\n}\r\nif (pix->height > MAX_SUPPORT_HEIGHT)\r\npix->height = MAX_SUPPORT_HEIGHT;\r\nif (pix->width > MAX_SUPPORT_WIDTH)\r\npix->width = MAX_SUPPORT_WIDTH;\r\nmf->width = pix->width;\r\nmf->height = pix->height;\r\nmf->field = pix->field;\r\nmf->colorspace = pix->colorspace;\r\nmf->code = xlate->code;\r\nret = v4l2_subdev_call(sd, pad, set_fmt, &pad_cfg, &format);\r\nif (ret < 0)\r\nreturn ret;\r\npix->width = mf->width;\r\npix->height = mf->height;\r\npix->colorspace = mf->colorspace;\r\nswitch (mf->field) {\r\ncase V4L2_FIELD_ANY:\r\npix->field = V4L2_FIELD_NONE;\r\nbreak;\r\ncase V4L2_FIELD_NONE:\r\nbreak;\r\ndefault:\r\ndev_err(icd->parent, "Field type %d unsupported.\n",\r\nmf->field);\r\nret = -EINVAL;\r\n}\r\nreturn ret;\r\n}\r\nstatic bool isi_camera_packing_supported(const struct soc_mbus_pixelfmt *fmt)\r\n{\r\nreturn fmt->packing == SOC_MBUS_PACKING_NONE ||\r\n(fmt->bits_per_sample == 8 &&\r\nfmt->packing == SOC_MBUS_PACKING_2X8_PADHI) ||\r\n(fmt->bits_per_sample > 8 &&\r\nfmt->packing == SOC_MBUS_PACKING_EXTEND16);\r\n}\r\nstatic int isi_camera_try_bus_param(struct soc_camera_device *icd,\r\nunsigned char buswidth)\r\n{\r\nstruct v4l2_subdev *sd = soc_camera_to_subdev(icd);\r\nstruct soc_camera_host *ici = to_soc_camera_host(icd->parent);\r\nstruct atmel_isi *isi = ici->priv;\r\nstruct v4l2_mbus_config cfg = {.type = V4L2_MBUS_PARALLEL,};\r\nunsigned long common_flags;\r\nint ret;\r\nret = v4l2_subdev_call(sd, video, g_mbus_config, &cfg);\r\nif (!ret) {\r\ncommon_flags = soc_mbus_config_compatible(&cfg,\r\nISI_BUS_PARAM);\r\nif (!common_flags) {\r\ndev_warn(icd->parent,\r\n"Flags incompatible: camera 0x%x, host 0x%x\n",\r\ncfg.flags, ISI_BUS_PARAM);\r\nreturn -EINVAL;\r\n}\r\n} else if (ret != -ENOIOCTLCMD) {\r\nreturn ret;\r\n}\r\nif ((1 << (buswidth - 1)) & isi->width_flags)\r\nreturn 0;\r\nreturn -EINVAL;\r\n}\r\nstatic int isi_camera_get_formats(struct soc_camera_device *icd,\r\nunsigned int idx,\r\nstruct soc_camera_format_xlate *xlate)\r\n{\r\nstruct v4l2_subdev *sd = soc_camera_to_subdev(icd);\r\nint formats = 0, ret, i, n;\r\nstruct v4l2_subdev_mbus_code_enum code = {\r\n.which = V4L2_SUBDEV_FORMAT_ACTIVE,\r\n.index = idx,\r\n};\r\nconst struct soc_mbus_pixelfmt *fmt;\r\nret = v4l2_subdev_call(sd, pad, enum_mbus_code, NULL, &code);\r\nif (ret < 0)\r\nreturn 0;\r\nfmt = soc_mbus_get_fmtdesc(code.code);\r\nif (!fmt) {\r\ndev_err(icd->parent,\r\n"Invalid format code #%u: %d\n", idx, code.code);\r\nreturn 0;\r\n}\r\nret = isi_camera_try_bus_param(icd, fmt->bits_per_sample);\r\nif (ret < 0) {\r\ndev_err(icd->parent,\r\n"Fail to try the bus parameters.\n");\r\nreturn 0;\r\n}\r\nswitch (code.code) {\r\ncase MEDIA_BUS_FMT_UYVY8_2X8:\r\ncase MEDIA_BUS_FMT_VYUY8_2X8:\r\ncase MEDIA_BUS_FMT_YUYV8_2X8:\r\ncase MEDIA_BUS_FMT_YVYU8_2X8:\r\nn = ARRAY_SIZE(isi_camera_formats);\r\nformats += n;\r\nfor (i = 0; xlate && i < n; i++, xlate++) {\r\nxlate->host_fmt = &isi_camera_formats[i];\r\nxlate->code = code.code;\r\ndev_dbg(icd->parent, "Providing format %s using code %d\n",\r\nxlate->host_fmt->name, xlate->code);\r\n}\r\nbreak;\r\ndefault:\r\nif (!isi_camera_packing_supported(fmt))\r\nreturn 0;\r\nif (xlate)\r\ndev_dbg(icd->parent,\r\n"Providing format %s in pass-through mode\n",\r\nfmt->name);\r\n}\r\nformats++;\r\nif (xlate) {\r\nxlate->host_fmt = fmt;\r\nxlate->code = code.code;\r\nxlate++;\r\n}\r\nreturn formats;\r\n}\r\nstatic int isi_camera_add_device(struct soc_camera_device *icd)\r\n{\r\ndev_dbg(icd->parent, "Atmel ISI Camera driver attached to camera %d\n",\r\nicd->devnum);\r\nreturn 0;\r\n}\r\nstatic void isi_camera_remove_device(struct soc_camera_device *icd)\r\n{\r\ndev_dbg(icd->parent, "Atmel ISI Camera driver detached from camera %d\n",\r\nicd->devnum);\r\n}\r\nstatic unsigned int isi_camera_poll(struct file *file, poll_table *pt)\r\n{\r\nstruct soc_camera_device *icd = file->private_data;\r\nreturn vb2_poll(&icd->vb2_vidq, file, pt);\r\n}\r\nstatic int isi_camera_querycap(struct soc_camera_host *ici,\r\nstruct v4l2_capability *cap)\r\n{\r\nstrcpy(cap->driver, "atmel-isi");\r\nstrcpy(cap->card, "Atmel Image Sensor Interface");\r\ncap->device_caps = V4L2_CAP_VIDEO_CAPTURE | V4L2_CAP_STREAMING;\r\ncap->capabilities = cap->device_caps | V4L2_CAP_DEVICE_CAPS;\r\nreturn 0;\r\n}\r\nstatic int isi_camera_set_bus_param(struct soc_camera_device *icd)\r\n{\r\nstruct v4l2_subdev *sd = soc_camera_to_subdev(icd);\r\nstruct soc_camera_host *ici = to_soc_camera_host(icd->parent);\r\nstruct atmel_isi *isi = ici->priv;\r\nstruct v4l2_mbus_config cfg = {.type = V4L2_MBUS_PARALLEL,};\r\nunsigned long common_flags;\r\nint ret;\r\nu32 cfg1 = 0;\r\nret = v4l2_subdev_call(sd, video, g_mbus_config, &cfg);\r\nif (!ret) {\r\ncommon_flags = soc_mbus_config_compatible(&cfg,\r\nISI_BUS_PARAM);\r\nif (!common_flags) {\r\ndev_warn(icd->parent,\r\n"Flags incompatible: camera 0x%x, host 0x%x\n",\r\ncfg.flags, ISI_BUS_PARAM);\r\nreturn -EINVAL;\r\n}\r\n} else if (ret != -ENOIOCTLCMD) {\r\nreturn ret;\r\n} else {\r\ncommon_flags = ISI_BUS_PARAM;\r\n}\r\ndev_dbg(icd->parent, "Flags cam: 0x%x host: 0x%x common: 0x%lx\n",\r\ncfg.flags, ISI_BUS_PARAM, common_flags);\r\nif ((common_flags & V4L2_MBUS_HSYNC_ACTIVE_HIGH) &&\r\n(common_flags & V4L2_MBUS_HSYNC_ACTIVE_LOW)) {\r\nif (isi->pdata.hsync_act_low)\r\ncommon_flags &= ~V4L2_MBUS_HSYNC_ACTIVE_HIGH;\r\nelse\r\ncommon_flags &= ~V4L2_MBUS_HSYNC_ACTIVE_LOW;\r\n}\r\nif ((common_flags & V4L2_MBUS_VSYNC_ACTIVE_HIGH) &&\r\n(common_flags & V4L2_MBUS_VSYNC_ACTIVE_LOW)) {\r\nif (isi->pdata.vsync_act_low)\r\ncommon_flags &= ~V4L2_MBUS_VSYNC_ACTIVE_HIGH;\r\nelse\r\ncommon_flags &= ~V4L2_MBUS_VSYNC_ACTIVE_LOW;\r\n}\r\nif ((common_flags & V4L2_MBUS_PCLK_SAMPLE_RISING) &&\r\n(common_flags & V4L2_MBUS_PCLK_SAMPLE_FALLING)) {\r\nif (isi->pdata.pclk_act_falling)\r\ncommon_flags &= ~V4L2_MBUS_PCLK_SAMPLE_RISING;\r\nelse\r\ncommon_flags &= ~V4L2_MBUS_PCLK_SAMPLE_FALLING;\r\n}\r\ncfg.flags = common_flags;\r\nret = v4l2_subdev_call(sd, video, s_mbus_config, &cfg);\r\nif (ret < 0 && ret != -ENOIOCTLCMD) {\r\ndev_dbg(icd->parent, "camera s_mbus_config(0x%lx) returned %d\n",\r\ncommon_flags, ret);\r\nreturn ret;\r\n}\r\nif (common_flags & V4L2_MBUS_HSYNC_ACTIVE_LOW)\r\ncfg1 |= ISI_CFG1_HSYNC_POL_ACTIVE_LOW;\r\nif (common_flags & V4L2_MBUS_VSYNC_ACTIVE_LOW)\r\ncfg1 |= ISI_CFG1_VSYNC_POL_ACTIVE_LOW;\r\nif (common_flags & V4L2_MBUS_PCLK_SAMPLE_FALLING)\r\ncfg1 |= ISI_CFG1_PIXCLK_POL_ACTIVE_FALLING;\r\ndev_dbg(icd->parent, "vsync active %s, hsync active %s, sampling on pix clock %s edge\n",\r\ncommon_flags & V4L2_MBUS_VSYNC_ACTIVE_LOW ? "low" : "high",\r\ncommon_flags & V4L2_MBUS_HSYNC_ACTIVE_LOW ? "low" : "high",\r\ncommon_flags & V4L2_MBUS_PCLK_SAMPLE_FALLING ? "falling" : "rising");\r\nif (isi->pdata.has_emb_sync)\r\ncfg1 |= ISI_CFG1_EMB_SYNC;\r\nif (isi->pdata.full_mode)\r\ncfg1 |= ISI_CFG1_FULL_MODE;\r\ncfg1 |= ISI_CFG1_THMASK_BEATS_16;\r\npm_runtime_get_sync(ici->v4l2_dev.dev);\r\nisi_writel(isi, ISI_CTRL, ISI_CTRL_DIS);\r\nisi_writel(isi, ISI_CFG1, cfg1);\r\npm_runtime_put(ici->v4l2_dev.dev);\r\nreturn 0;\r\n}\r\nstatic int atmel_isi_remove(struct platform_device *pdev)\r\n{\r\nstruct soc_camera_host *soc_host = to_soc_camera_host(&pdev->dev);\r\nstruct atmel_isi *isi = container_of(soc_host,\r\nstruct atmel_isi, soc_host);\r\nsoc_camera_host_unregister(soc_host);\r\nvb2_dma_contig_cleanup_ctx(isi->alloc_ctx);\r\ndma_free_coherent(&pdev->dev,\r\nsizeof(struct fbd) * MAX_BUFFER_NUM,\r\nisi->p_fb_descriptors,\r\nisi->fb_descriptors_phys);\r\npm_runtime_disable(&pdev->dev);\r\nreturn 0;\r\n}\r\nstatic int atmel_isi_parse_dt(struct atmel_isi *isi,\r\nstruct platform_device *pdev)\r\n{\r\nstruct device_node *np= pdev->dev.of_node;\r\nstruct v4l2_of_endpoint ep;\r\nint err;\r\nisi->pdata.full_mode = 1;\r\nisi->pdata.frate = ISI_CFG1_FRATE_CAPTURE_ALL;\r\nnp = of_graph_get_next_endpoint(np, NULL);\r\nif (!np) {\r\ndev_err(&pdev->dev, "Could not find the endpoint\n");\r\nreturn -EINVAL;\r\n}\r\nerr = v4l2_of_parse_endpoint(np, &ep);\r\nof_node_put(np);\r\nif (err) {\r\ndev_err(&pdev->dev, "Could not parse the endpoint\n");\r\nreturn err;\r\n}\r\nswitch (ep.bus.parallel.bus_width) {\r\ncase 8:\r\nisi->pdata.data_width_flags = ISI_DATAWIDTH_8;\r\nbreak;\r\ncase 10:\r\nisi->pdata.data_width_flags =\r\nISI_DATAWIDTH_8 | ISI_DATAWIDTH_10;\r\nbreak;\r\ndefault:\r\ndev_err(&pdev->dev, "Unsupported bus width: %d\n",\r\nep.bus.parallel.bus_width);\r\nreturn -EINVAL;\r\n}\r\nif (ep.bus.parallel.flags & V4L2_MBUS_HSYNC_ACTIVE_LOW)\r\nisi->pdata.hsync_act_low = true;\r\nif (ep.bus.parallel.flags & V4L2_MBUS_VSYNC_ACTIVE_LOW)\r\nisi->pdata.vsync_act_low = true;\r\nif (ep.bus.parallel.flags & V4L2_MBUS_PCLK_SAMPLE_FALLING)\r\nisi->pdata.pclk_act_falling = true;\r\nif (ep.bus_type == V4L2_MBUS_BT656)\r\nisi->pdata.has_emb_sync = true;\r\nreturn 0;\r\n}\r\nstatic int atmel_isi_probe(struct platform_device *pdev)\r\n{\r\nint irq;\r\nstruct atmel_isi *isi;\r\nstruct resource *regs;\r\nint ret, i;\r\nstruct soc_camera_host *soc_host;\r\nisi = devm_kzalloc(&pdev->dev, sizeof(struct atmel_isi), GFP_KERNEL);\r\nif (!isi) {\r\ndev_err(&pdev->dev, "Can't allocate interface!\n");\r\nreturn -ENOMEM;\r\n}\r\nisi->pclk = devm_clk_get(&pdev->dev, "isi_clk");\r\nif (IS_ERR(isi->pclk))\r\nreturn PTR_ERR(isi->pclk);\r\nret = atmel_isi_parse_dt(isi, pdev);\r\nif (ret)\r\nreturn ret;\r\nisi->active = NULL;\r\nspin_lock_init(&isi->lock);\r\nINIT_LIST_HEAD(&isi->video_buffer_list);\r\nINIT_LIST_HEAD(&isi->dma_desc_head);\r\nisi->p_fb_descriptors = dma_alloc_coherent(&pdev->dev,\r\nsizeof(struct fbd) * MAX_BUFFER_NUM,\r\n&isi->fb_descriptors_phys,\r\nGFP_KERNEL);\r\nif (!isi->p_fb_descriptors) {\r\ndev_err(&pdev->dev, "Can't allocate descriptors!\n");\r\nreturn -ENOMEM;\r\n}\r\nfor (i = 0; i < MAX_BUFFER_NUM; i++) {\r\nisi->dma_desc[i].p_fbd = isi->p_fb_descriptors + i;\r\nisi->dma_desc[i].fbd_phys = isi->fb_descriptors_phys +\r\ni * sizeof(struct fbd);\r\nlist_add(&isi->dma_desc[i].list, &isi->dma_desc_head);\r\n}\r\nisi->alloc_ctx = vb2_dma_contig_init_ctx(&pdev->dev);\r\nif (IS_ERR(isi->alloc_ctx)) {\r\nret = PTR_ERR(isi->alloc_ctx);\r\ngoto err_alloc_ctx;\r\n}\r\nregs = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nisi->regs = devm_ioremap_resource(&pdev->dev, regs);\r\nif (IS_ERR(isi->regs)) {\r\nret = PTR_ERR(isi->regs);\r\ngoto err_ioremap;\r\n}\r\nif (isi->pdata.data_width_flags & ISI_DATAWIDTH_8)\r\nisi->width_flags = 1 << 7;\r\nif (isi->pdata.data_width_flags & ISI_DATAWIDTH_10)\r\nisi->width_flags |= 1 << 9;\r\nirq = platform_get_irq(pdev, 0);\r\nif (irq < 0) {\r\nret = irq;\r\ngoto err_req_irq;\r\n}\r\nret = devm_request_irq(&pdev->dev, irq, isi_interrupt, 0, "isi", isi);\r\nif (ret) {\r\ndev_err(&pdev->dev, "Unable to request irq %d\n", irq);\r\ngoto err_req_irq;\r\n}\r\nisi->irq = irq;\r\nsoc_host = &isi->soc_host;\r\nsoc_host->drv_name = "isi-camera";\r\nsoc_host->ops = &isi_soc_camera_host_ops;\r\nsoc_host->priv = isi;\r\nsoc_host->v4l2_dev.dev = &pdev->dev;\r\nsoc_host->nr = pdev->id;\r\npm_suspend_ignore_children(&pdev->dev, true);\r\npm_runtime_enable(&pdev->dev);\r\nret = soc_camera_host_register(soc_host);\r\nif (ret) {\r\ndev_err(&pdev->dev, "Unable to register soc camera host\n");\r\ngoto err_register_soc_camera_host;\r\n}\r\nreturn 0;\r\nerr_register_soc_camera_host:\r\npm_runtime_disable(&pdev->dev);\r\nerr_req_irq:\r\nerr_ioremap:\r\nvb2_dma_contig_cleanup_ctx(isi->alloc_ctx);\r\nerr_alloc_ctx:\r\ndma_free_coherent(&pdev->dev,\r\nsizeof(struct fbd) * MAX_BUFFER_NUM,\r\nisi->p_fb_descriptors,\r\nisi->fb_descriptors_phys);\r\nreturn ret;\r\n}\r\nstatic int atmel_isi_runtime_suspend(struct device *dev)\r\n{\r\nstruct soc_camera_host *soc_host = to_soc_camera_host(dev);\r\nstruct atmel_isi *isi = container_of(soc_host,\r\nstruct atmel_isi, soc_host);\r\nclk_disable_unprepare(isi->pclk);\r\nreturn 0;\r\n}\r\nstatic int atmel_isi_runtime_resume(struct device *dev)\r\n{\r\nstruct soc_camera_host *soc_host = to_soc_camera_host(dev);\r\nstruct atmel_isi *isi = container_of(soc_host,\r\nstruct atmel_isi, soc_host);\r\nreturn clk_prepare_enable(isi->pclk);\r\n}
