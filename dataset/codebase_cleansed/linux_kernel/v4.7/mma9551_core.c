static int mma9551_transfer(struct i2c_client *client,\r\nu8 app_id, u8 command, u16 offset,\r\nu8 *inbytes, int num_inbytes,\r\nu8 *outbytes, int num_outbytes)\r\n{\r\nstruct mma9551_mbox_request req;\r\nstruct mma9551_mbox_response rsp;\r\nstruct i2c_msg in, out;\r\nu8 req_len, err_code;\r\nint ret, retries;\r\nif (offset >= 1 << 12) {\r\ndev_err(&client->dev, "register offset too large\n");\r\nreturn -EINVAL;\r\n}\r\nreq_len = 1 + MMA9551_MAILBOX_CTRL_REGS + num_inbytes;\r\nreq.start_mbox = 0;\r\nreq.app_id = app_id;\r\nreq.cmd_off = command | (offset >> 8);\r\nreq.lower_off = offset;\r\nif (command == MMA9551_CMD_WRITE_CONFIG)\r\nreq.nbytes = num_inbytes;\r\nelse\r\nreq.nbytes = num_outbytes;\r\nif (num_inbytes)\r\nmemcpy(req.buf, inbytes, num_inbytes);\r\nout.addr = client->addr;\r\nout.flags = 0;\r\nout.len = req_len;\r\nout.buf = (u8 *)&req;\r\nret = i2c_transfer(client->adapter, &out, 1);\r\nif (ret < 0) {\r\ndev_err(&client->dev, "i2c write failed\n");\r\nreturn ret;\r\n}\r\nretries = MMA9551_I2C_READ_RETRIES;\r\ndo {\r\nudelay(MMA9551_I2C_READ_DELAY);\r\nin.addr = client->addr;\r\nin.flags = I2C_M_RD;\r\nin.len = sizeof(rsp);\r\nin.buf = (u8 *)&rsp;\r\nret = i2c_transfer(client->adapter, &in, 1);\r\nif (ret < 0) {\r\ndev_err(&client->dev, "i2c read failed\n");\r\nreturn ret;\r\n}\r\nif (rsp.coco_err & MMA9551_RESPONSE_COCO)\r\nbreak;\r\n} while (--retries > 0);\r\nif (retries == 0) {\r\ndev_err(&client->dev,\r\n"timed out while waiting for command response\n");\r\nreturn -ETIMEDOUT;\r\n}\r\nif (rsp.app_id != app_id) {\r\ndev_err(&client->dev,\r\n"app_id mismatch in response got %02x expected %02x\n",\r\nrsp.app_id, app_id);\r\nreturn -EINVAL;\r\n}\r\nerr_code = rsp.coco_err & ~MMA9551_RESPONSE_COCO;\r\nif (err_code != MMA9551_MCI_ERROR_NONE) {\r\ndev_err(&client->dev, "read returned error %x\n", err_code);\r\nreturn -EINVAL;\r\n}\r\nif (rsp.nbytes != rsp.req_bytes) {\r\ndev_err(&client->dev,\r\n"output length mismatch got %d expected %d\n",\r\nrsp.nbytes, rsp.req_bytes);\r\nreturn -EINVAL;\r\n}\r\nif (num_outbytes)\r\nmemcpy(outbytes, rsp.buf, num_outbytes);\r\nreturn 0;\r\n}\r\nint mma9551_read_config_byte(struct i2c_client *client, u8 app_id,\r\nu16 reg, u8 *val)\r\n{\r\nreturn mma9551_transfer(client, app_id, MMA9551_CMD_READ_CONFIG,\r\nreg, NULL, 0, val, 1);\r\n}\r\nint mma9551_write_config_byte(struct i2c_client *client, u8 app_id,\r\nu16 reg, u8 val)\r\n{\r\nreturn mma9551_transfer(client, app_id, MMA9551_CMD_WRITE_CONFIG, reg,\r\n&val, 1, NULL, 0);\r\n}\r\nint mma9551_read_status_byte(struct i2c_client *client, u8 app_id,\r\nu16 reg, u8 *val)\r\n{\r\nreturn mma9551_transfer(client, app_id, MMA9551_CMD_READ_STATUS,\r\nreg, NULL, 0, val, 1);\r\n}\r\nint mma9551_read_config_word(struct i2c_client *client, u8 app_id,\r\nu16 reg, u16 *val)\r\n{\r\nint ret;\r\n__be16 v;\r\nret = mma9551_transfer(client, app_id, MMA9551_CMD_READ_CONFIG,\r\nreg, NULL, 0, (u8 *)&v, 2);\r\n*val = be16_to_cpu(v);\r\nreturn ret;\r\n}\r\nint mma9551_write_config_word(struct i2c_client *client, u8 app_id,\r\nu16 reg, u16 val)\r\n{\r\n__be16 v = cpu_to_be16(val);\r\nreturn mma9551_transfer(client, app_id, MMA9551_CMD_WRITE_CONFIG, reg,\r\n(u8 *)&v, 2, NULL, 0);\r\n}\r\nint mma9551_read_status_word(struct i2c_client *client, u8 app_id,\r\nu16 reg, u16 *val)\r\n{\r\nint ret;\r\n__be16 v;\r\nret = mma9551_transfer(client, app_id, MMA9551_CMD_READ_STATUS,\r\nreg, NULL, 0, (u8 *)&v, 2);\r\n*val = be16_to_cpu(v);\r\nreturn ret;\r\n}\r\nint mma9551_read_config_words(struct i2c_client *client, u8 app_id,\r\nu16 reg, u8 len, u16 *buf)\r\n{\r\nint ret, i;\r\n__be16 be_buf[MMA9551_MAX_MAILBOX_DATA_REGS / 2];\r\nif (len > ARRAY_SIZE(be_buf)) {\r\ndev_err(&client->dev, "Invalid buffer size %d\n", len);\r\nreturn -EINVAL;\r\n}\r\nret = mma9551_transfer(client, app_id, MMA9551_CMD_READ_CONFIG,\r\nreg, NULL, 0, (u8 *)be_buf, len * sizeof(u16));\r\nif (ret < 0)\r\nreturn ret;\r\nfor (i = 0; i < len; i++)\r\nbuf[i] = be16_to_cpu(be_buf[i]);\r\nreturn 0;\r\n}\r\nint mma9551_read_status_words(struct i2c_client *client, u8 app_id,\r\nu16 reg, u8 len, u16 *buf)\r\n{\r\nint ret, i;\r\n__be16 be_buf[MMA9551_MAX_MAILBOX_DATA_REGS / 2];\r\nif (len > ARRAY_SIZE(be_buf)) {\r\ndev_err(&client->dev, "Invalid buffer size %d\n", len);\r\nreturn -EINVAL;\r\n}\r\nret = mma9551_transfer(client, app_id, MMA9551_CMD_READ_STATUS,\r\nreg, NULL, 0, (u8 *)be_buf, len * sizeof(u16));\r\nif (ret < 0)\r\nreturn ret;\r\nfor (i = 0; i < len; i++)\r\nbuf[i] = be16_to_cpu(be_buf[i]);\r\nreturn 0;\r\n}\r\nint mma9551_write_config_words(struct i2c_client *client, u8 app_id,\r\nu16 reg, u8 len, u16 *buf)\r\n{\r\nint i;\r\n__be16 be_buf[(MMA9551_MAX_MAILBOX_DATA_REGS - 1) / 2];\r\nif (len > ARRAY_SIZE(be_buf)) {\r\ndev_err(&client->dev, "Invalid buffer size %d\n", len);\r\nreturn -EINVAL;\r\n}\r\nfor (i = 0; i < len; i++)\r\nbe_buf[i] = cpu_to_be16(buf[i]);\r\nreturn mma9551_transfer(client, app_id, MMA9551_CMD_WRITE_CONFIG,\r\nreg, (u8 *)be_buf, len * sizeof(u16), NULL, 0);\r\n}\r\nint mma9551_update_config_bits(struct i2c_client *client, u8 app_id,\r\nu16 reg, u8 mask, u8 val)\r\n{\r\nint ret;\r\nu8 tmp, orig;\r\nret = mma9551_read_config_byte(client, app_id, reg, &orig);\r\nif (ret < 0)\r\nreturn ret;\r\ntmp = orig & ~mask;\r\ntmp |= val & mask;\r\nif (tmp == orig)\r\nreturn 0;\r\nreturn mma9551_write_config_byte(client, app_id, reg, tmp);\r\n}\r\nint mma9551_gpio_config(struct i2c_client *client, enum mma9551_gpio_pin pin,\r\nu8 app_id, u8 bitnum, int polarity)\r\n{\r\nu8 reg, pol_mask, pol_val;\r\nint ret;\r\nif (pin > mma9551_gpio_max) {\r\ndev_err(&client->dev, "bad GPIO pin\n");\r\nreturn -EINVAL;\r\n}\r\nreg = pin * 2;\r\nret = mma9551_write_config_byte(client, MMA9551_APPID_GPIO,\r\nreg, app_id);\r\nif (ret < 0) {\r\ndev_err(&client->dev, "error setting GPIO app_id\n");\r\nreturn ret;\r\n}\r\nret = mma9551_write_config_byte(client, MMA9551_APPID_GPIO,\r\nreg + 1, bitnum);\r\nif (ret < 0) {\r\ndev_err(&client->dev, "error setting GPIO bit number\n");\r\nreturn ret;\r\n}\r\nswitch (pin) {\r\ncase mma9551_gpio6:\r\nreg = MMA9551_GPIO_POL_LSB;\r\npol_mask = 1 << 6;\r\nbreak;\r\ncase mma9551_gpio7:\r\nreg = MMA9551_GPIO_POL_LSB;\r\npol_mask = 1 << 7;\r\nbreak;\r\ncase mma9551_gpio8:\r\nreg = MMA9551_GPIO_POL_MSB;\r\npol_mask = 1 << 0;\r\nbreak;\r\ncase mma9551_gpio9:\r\nreg = MMA9551_GPIO_POL_MSB;\r\npol_mask = 1 << 1;\r\nbreak;\r\n}\r\npol_val = polarity ? pol_mask : 0;\r\nret = mma9551_update_config_bits(client, MMA9551_APPID_GPIO, reg,\r\npol_mask, pol_val);\r\nif (ret < 0)\r\ndev_err(&client->dev, "error setting GPIO polarity\n");\r\nreturn ret;\r\n}\r\nint mma9551_read_version(struct i2c_client *client)\r\n{\r\nstruct mma9551_version_info info;\r\nint ret;\r\nret = mma9551_transfer(client, MMA9551_APPID_VERSION, 0x00, 0x00,\r\nNULL, 0, (u8 *)&info, sizeof(info));\r\nif (ret < 0)\r\nreturn ret;\r\ndev_info(&client->dev, "device ID 0x%x, firmware version %02x.%02x\n",\r\nbe32_to_cpu(info.device_id), info.fw_version[0],\r\ninfo.fw_version[1]);\r\nreturn 0;\r\n}\r\nint mma9551_set_device_state(struct i2c_client *client, bool enable)\r\n{\r\nreturn mma9551_update_config_bits(client, MMA9551_APPID_SLEEP_WAKE,\r\nMMA9551_SLEEP_CFG,\r\nMMA9551_SLEEP_CFG_SNCEN |\r\nMMA9551_SLEEP_CFG_FLEEN |\r\nMMA9551_SLEEP_CFG_SCHEN,\r\nenable ? MMA9551_SLEEP_CFG_SCHEN |\r\nMMA9551_SLEEP_CFG_FLEEN :\r\nMMA9551_SLEEP_CFG_SNCEN);\r\n}\r\nint mma9551_set_power_state(struct i2c_client *client, bool on)\r\n{\r\n#ifdef CONFIG_PM\r\nint ret;\r\nif (on)\r\nret = pm_runtime_get_sync(&client->dev);\r\nelse {\r\npm_runtime_mark_last_busy(&client->dev);\r\nret = pm_runtime_put_autosuspend(&client->dev);\r\n}\r\nif (ret < 0) {\r\ndev_err(&client->dev,\r\n"failed to change power state to %d\n", on);\r\nif (on)\r\npm_runtime_put_noidle(&client->dev);\r\nreturn ret;\r\n}\r\n#endif\r\nreturn 0;\r\n}\r\nvoid mma9551_sleep(int freq)\r\n{\r\nint sleep_val = 1000 / freq;\r\nif (sleep_val < 20)\r\nusleep_range(sleep_val * 1000, 20000);\r\nelse\r\nmsleep_interruptible(sleep_val);\r\n}\r\nint mma9551_read_accel_chan(struct i2c_client *client,\r\nconst struct iio_chan_spec *chan,\r\nint *val, int *val2)\r\n{\r\nu16 reg_addr;\r\ns16 raw_accel;\r\nint ret;\r\nswitch (chan->channel2) {\r\ncase IIO_MOD_X:\r\nreg_addr = MMA9551_AFE_X_ACCEL_REG;\r\nbreak;\r\ncase IIO_MOD_Y:\r\nreg_addr = MMA9551_AFE_Y_ACCEL_REG;\r\nbreak;\r\ncase IIO_MOD_Z:\r\nreg_addr = MMA9551_AFE_Z_ACCEL_REG;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nret = mma9551_set_power_state(client, true);\r\nif (ret < 0)\r\nreturn ret;\r\nret = mma9551_read_status_word(client, MMA9551_APPID_AFE,\r\nreg_addr, &raw_accel);\r\nif (ret < 0)\r\ngoto out_poweroff;\r\n*val = raw_accel;\r\nret = IIO_VAL_INT;\r\nout_poweroff:\r\nmma9551_set_power_state(client, false);\r\nreturn ret;\r\n}\r\nint mma9551_read_accel_scale(int *val, int *val2)\r\n{\r\n*val = 0;\r\n*val2 = 2440;\r\nreturn IIO_VAL_INT_PLUS_MICRO;\r\n}\r\nint mma9551_app_reset(struct i2c_client *client, u32 app_mask)\r\n{\r\nreturn mma9551_write_config_byte(client, MMA9551_APPID_RSC,\r\nMMA9551_RSC_RESET +\r\nMMA9551_RSC_OFFSET(app_mask),\r\nMMA9551_RSC_VAL(app_mask));\r\n}
