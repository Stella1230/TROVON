static int ensure_phase_lock(struct snd_dice *dice)\r\n{\r\n__be32 reg, nominal;\r\nint err;\r\nerr = snd_dice_transaction_read_global(dice, GLOBAL_CLOCK_SELECT,\r\n&reg, sizeof(reg));\r\nif (err < 0)\r\nreturn err;\r\nif (completion_done(&dice->clock_accepted))\r\nreinit_completion(&dice->clock_accepted);\r\nerr = snd_dice_transaction_write_global(dice, GLOBAL_CLOCK_SELECT,\r\n&reg, sizeof(reg));\r\nif (err < 0)\r\nreturn err;\r\nif (wait_for_completion_timeout(&dice->clock_accepted,\r\nmsecs_to_jiffies(NOTIFICATION_TIMEOUT_MS)) == 0) {\r\nerr = snd_dice_transaction_read_global(dice, GLOBAL_STATUS,\r\n&nominal, sizeof(nominal));\r\nif (err < 0)\r\nreturn err;\r\nif (!(be32_to_cpu(nominal) & STATUS_SOURCE_LOCKED))\r\nreturn -ETIMEDOUT;\r\n}\r\nreturn 0;\r\n}\r\nstatic int get_register_params(struct snd_dice *dice,\r\nstruct reg_params *tx_params,\r\nstruct reg_params *rx_params)\r\n{\r\n__be32 reg[2];\r\nint err;\r\nerr = snd_dice_transaction_read_tx(dice, TX_NUMBER, reg, sizeof(reg));\r\nif (err < 0)\r\nreturn err;\r\ntx_params->count =\r\nmin_t(unsigned int, be32_to_cpu(reg[0]), MAX_STREAMS);\r\ntx_params->size = be32_to_cpu(reg[1]) * 4;\r\nerr = snd_dice_transaction_read_rx(dice, RX_NUMBER, reg, sizeof(reg));\r\nif (err < 0)\r\nreturn err;\r\nrx_params->count =\r\nmin_t(unsigned int, be32_to_cpu(reg[0]), MAX_STREAMS);\r\nrx_params->size = be32_to_cpu(reg[1]) * 4;\r\nreturn 0;\r\n}\r\nstatic void release_resources(struct snd_dice *dice)\r\n{\r\nunsigned int i;\r\nfor (i = 0; i < MAX_STREAMS; i++) {\r\nif (amdtp_stream_running(&dice->tx_stream[i])) {\r\namdtp_stream_pcm_abort(&dice->tx_stream[i]);\r\namdtp_stream_stop(&dice->tx_stream[i]);\r\n}\r\nif (amdtp_stream_running(&dice->rx_stream[i])) {\r\namdtp_stream_pcm_abort(&dice->rx_stream[i]);\r\namdtp_stream_stop(&dice->rx_stream[i]);\r\n}\r\nfw_iso_resources_free(&dice->tx_resources[i]);\r\nfw_iso_resources_free(&dice->rx_resources[i]);\r\n}\r\n}\r\nstatic void stop_streams(struct snd_dice *dice, enum amdtp_stream_direction dir,\r\nstruct reg_params *params)\r\n{\r\n__be32 reg;\r\nunsigned int i;\r\nfor (i = 0; i < params->count; i++) {\r\nreg = cpu_to_be32((u32)-1);\r\nif (dir == AMDTP_IN_STREAM) {\r\nsnd_dice_transaction_write_tx(dice,\r\nparams->size * i + TX_ISOCHRONOUS,\r\n&reg, sizeof(reg));\r\n} else {\r\nsnd_dice_transaction_write_rx(dice,\r\nparams->size * i + RX_ISOCHRONOUS,\r\n&reg, sizeof(reg));\r\n}\r\n}\r\n}\r\nstatic int keep_resources(struct snd_dice *dice,\r\nenum amdtp_stream_direction dir, unsigned int index,\r\nunsigned int rate, unsigned int pcm_chs,\r\nunsigned int midi_ports)\r\n{\r\nstruct amdtp_stream *stream;\r\nstruct fw_iso_resources *resources;\r\nbool double_pcm_frames;\r\nunsigned int i;\r\nint err;\r\nif (dir == AMDTP_IN_STREAM) {\r\nstream = &dice->tx_stream[index];\r\nresources = &dice->tx_resources[index];\r\n} else {\r\nstream = &dice->rx_stream[index];\r\nresources = &dice->rx_resources[index];\r\n}\r\ndouble_pcm_frames = rate > 96000;\r\nif (double_pcm_frames) {\r\nrate /= 2;\r\npcm_chs *= 2;\r\n}\r\nerr = amdtp_am824_set_parameters(stream, rate, pcm_chs, midi_ports,\r\ndouble_pcm_frames);\r\nif (err < 0)\r\nreturn err;\r\nif (double_pcm_frames) {\r\npcm_chs /= 2;\r\nfor (i = 0; i < pcm_chs; i++) {\r\namdtp_am824_set_pcm_position(stream, i, i * 2);\r\namdtp_am824_set_pcm_position(stream, i + pcm_chs,\r\ni * 2 + 1);\r\n}\r\n}\r\nreturn fw_iso_resources_allocate(resources,\r\namdtp_stream_get_max_payload(stream),\r\nfw_parent_device(dice->unit)->max_speed);\r\n}\r\nstatic int start_streams(struct snd_dice *dice, enum amdtp_stream_direction dir,\r\nunsigned int rate, struct reg_params *params)\r\n{\r\n__be32 reg[2];\r\nunsigned int i, pcm_chs, midi_ports;\r\nstruct amdtp_stream *streams;\r\nstruct fw_iso_resources *resources;\r\nint err = 0;\r\nif (dir == AMDTP_IN_STREAM) {\r\nstreams = dice->tx_stream;\r\nresources = dice->tx_resources;\r\n} else {\r\nstreams = dice->rx_stream;\r\nresources = dice->rx_resources;\r\n}\r\nfor (i = 0; i < params->count; i++) {\r\nif (dir == AMDTP_IN_STREAM) {\r\nerr = snd_dice_transaction_read_tx(dice,\r\nparams->size * i + TX_NUMBER_AUDIO,\r\nreg, sizeof(reg));\r\n} else {\r\nerr = snd_dice_transaction_read_rx(dice,\r\nparams->size * i + RX_NUMBER_AUDIO,\r\nreg, sizeof(reg));\r\n}\r\nif (err < 0)\r\nreturn err;\r\npcm_chs = be32_to_cpu(reg[0]);\r\nmidi_ports = be32_to_cpu(reg[1]);\r\nerr = keep_resources(dice, dir, i, rate, pcm_chs, midi_ports);\r\nif (err < 0)\r\nreturn err;\r\nreg[0] = cpu_to_be32(resources[i].channel);\r\nif (dir == AMDTP_IN_STREAM) {\r\nerr = snd_dice_transaction_write_tx(dice,\r\nparams->size * i + TX_ISOCHRONOUS,\r\nreg, sizeof(reg[0]));\r\n} else {\r\nerr = snd_dice_transaction_write_rx(dice,\r\nparams->size * i + RX_ISOCHRONOUS,\r\nreg, sizeof(reg[0]));\r\n}\r\nif (err < 0)\r\nreturn err;\r\nerr = amdtp_stream_start(&streams[i], resources[i].channel,\r\nfw_parent_device(dice->unit)->max_speed);\r\nif (err < 0)\r\nreturn err;\r\n}\r\nreturn err;\r\n}\r\nint snd_dice_stream_start_duplex(struct snd_dice *dice, unsigned int rate)\r\n{\r\nunsigned int curr_rate;\r\nunsigned int i;\r\nstruct reg_params tx_params, rx_params;\r\nbool need_to_start;\r\nint err;\r\nif (dice->substreams_counter == 0)\r\nreturn -EIO;\r\nerr = get_register_params(dice, &tx_params, &rx_params);\r\nif (err < 0)\r\nreturn err;\r\nerr = snd_dice_transaction_get_rate(dice, &curr_rate);\r\nif (err < 0) {\r\ndev_err(&dice->unit->device,\r\n"fail to get sampling rate\n");\r\nreturn err;\r\n}\r\nif (rate == 0)\r\nrate = curr_rate;\r\nif (rate != curr_rate)\r\nreturn -EINVAL;\r\nfor (i = 0; i < MAX_STREAMS; i++) {\r\nif (i < tx_params.count) {\r\nif (amdtp_streaming_error(&dice->tx_stream[i]) ||\r\n!amdtp_stream_running(&dice->tx_stream[i]))\r\nbreak;\r\n}\r\nif (i < rx_params.count) {\r\nif (amdtp_streaming_error(&dice->rx_stream[i]) ||\r\n!amdtp_stream_running(&dice->rx_stream[i]))\r\nbreak;\r\n}\r\n}\r\nneed_to_start = (i < MAX_STREAMS);\r\nif (need_to_start) {\r\nsnd_dice_transaction_clear_enable(dice);\r\nstop_streams(dice, AMDTP_IN_STREAM, &tx_params);\r\nstop_streams(dice, AMDTP_OUT_STREAM, &rx_params);\r\nrelease_resources(dice);\r\nerr = ensure_phase_lock(dice);\r\nif (err < 0) {\r\ndev_err(&dice->unit->device,\r\n"fail to ensure phase lock\n");\r\nreturn err;\r\n}\r\nerr = start_streams(dice, AMDTP_IN_STREAM, rate, &tx_params);\r\nif (err < 0)\r\ngoto error;\r\nerr = start_streams(dice, AMDTP_OUT_STREAM, rate, &rx_params);\r\nif (err < 0)\r\ngoto error;\r\nerr = snd_dice_transaction_set_enable(dice);\r\nif (err < 0) {\r\ndev_err(&dice->unit->device,\r\n"fail to enable interface\n");\r\ngoto error;\r\n}\r\nfor (i = 0; i < MAX_STREAMS; i++) {\r\nif ((i < tx_params.count &&\r\n!amdtp_stream_wait_callback(&dice->tx_stream[i],\r\nCALLBACK_TIMEOUT)) ||\r\n(i < rx_params.count &&\r\n!amdtp_stream_wait_callback(&dice->rx_stream[i],\r\nCALLBACK_TIMEOUT))) {\r\nerr = -ETIMEDOUT;\r\ngoto error;\r\n}\r\n}\r\n}\r\nreturn err;\r\nerror:\r\nsnd_dice_transaction_clear_enable(dice);\r\nstop_streams(dice, AMDTP_IN_STREAM, &tx_params);\r\nstop_streams(dice, AMDTP_OUT_STREAM, &rx_params);\r\nrelease_resources(dice);\r\nreturn err;\r\n}\r\nvoid snd_dice_stream_stop_duplex(struct snd_dice *dice)\r\n{\r\nstruct reg_params tx_params, rx_params;\r\nif (dice->substreams_counter > 0)\r\nreturn;\r\nsnd_dice_transaction_clear_enable(dice);\r\nif (get_register_params(dice, &tx_params, &rx_params) == 0) {\r\nstop_streams(dice, AMDTP_IN_STREAM, &tx_params);\r\nstop_streams(dice, AMDTP_OUT_STREAM, &rx_params);\r\n}\r\nrelease_resources(dice);\r\n}\r\nstatic int init_stream(struct snd_dice *dice, enum amdtp_stream_direction dir,\r\nunsigned int index)\r\n{\r\nstruct amdtp_stream *stream;\r\nstruct fw_iso_resources *resources;\r\nint err;\r\nif (dir == AMDTP_IN_STREAM) {\r\nstream = &dice->tx_stream[index];\r\nresources = &dice->tx_resources[index];\r\n} else {\r\nstream = &dice->rx_stream[index];\r\nresources = &dice->rx_resources[index];\r\n}\r\nerr = fw_iso_resources_init(resources, dice->unit);\r\nif (err < 0)\r\ngoto end;\r\nresources->channels_mask = 0x00000000ffffffffuLL;\r\nerr = amdtp_am824_init(stream, dice->unit, dir, CIP_BLOCKING);\r\nif (err < 0) {\r\namdtp_stream_destroy(stream);\r\nfw_iso_resources_destroy(resources);\r\n}\r\nend:\r\nreturn err;\r\n}\r\nstatic void destroy_stream(struct snd_dice *dice,\r\nenum amdtp_stream_direction dir,\r\nunsigned int index)\r\n{\r\nstruct amdtp_stream *stream;\r\nstruct fw_iso_resources *resources;\r\nif (dir == AMDTP_IN_STREAM) {\r\nstream = &dice->tx_stream[index];\r\nresources = &dice->tx_resources[index];\r\n} else {\r\nstream = &dice->rx_stream[index];\r\nresources = &dice->rx_resources[index];\r\n}\r\namdtp_stream_destroy(stream);\r\nfw_iso_resources_destroy(resources);\r\n}\r\nint snd_dice_stream_init_duplex(struct snd_dice *dice)\r\n{\r\nint i, err;\r\nfor (i = 0; i < MAX_STREAMS; i++) {\r\nerr = init_stream(dice, AMDTP_IN_STREAM, i);\r\nif (err < 0) {\r\nfor (; i >= 0; i--)\r\ndestroy_stream(dice, AMDTP_OUT_STREAM, i);\r\ngoto end;\r\n}\r\n}\r\nfor (i = 0; i < MAX_STREAMS; i++) {\r\nerr = init_stream(dice, AMDTP_OUT_STREAM, i);\r\nif (err < 0) {\r\nfor (; i >= 0; i--)\r\ndestroy_stream(dice, AMDTP_OUT_STREAM, i);\r\nfor (i = 0; i < MAX_STREAMS; i++)\r\ndestroy_stream(dice, AMDTP_IN_STREAM, i);\r\nbreak;\r\n}\r\n}\r\nend:\r\nreturn err;\r\n}\r\nvoid snd_dice_stream_destroy_duplex(struct snd_dice *dice)\r\n{\r\nunsigned int i;\r\nfor (i = 0; i < MAX_STREAMS; i++) {\r\ndestroy_stream(dice, AMDTP_IN_STREAM, i);\r\ndestroy_stream(dice, AMDTP_OUT_STREAM, i);\r\n}\r\n}\r\nvoid snd_dice_stream_update_duplex(struct snd_dice *dice)\r\n{\r\nstruct reg_params tx_params, rx_params;\r\ndice->global_enabled = false;\r\nif (get_register_params(dice, &tx_params, &rx_params) == 0) {\r\nstop_streams(dice, AMDTP_IN_STREAM, &tx_params);\r\nstop_streams(dice, AMDTP_OUT_STREAM, &rx_params);\r\n}\r\n}\r\nstatic void dice_lock_changed(struct snd_dice *dice)\r\n{\r\ndice->dev_lock_changed = true;\r\nwake_up(&dice->hwdep_wait);\r\n}\r\nint snd_dice_stream_lock_try(struct snd_dice *dice)\r\n{\r\nint err;\r\nspin_lock_irq(&dice->lock);\r\nif (dice->dev_lock_count < 0) {\r\nerr = -EBUSY;\r\ngoto out;\r\n}\r\nif (dice->dev_lock_count++ == 0)\r\ndice_lock_changed(dice);\r\nerr = 0;\r\nout:\r\nspin_unlock_irq(&dice->lock);\r\nreturn err;\r\n}\r\nvoid snd_dice_stream_lock_release(struct snd_dice *dice)\r\n{\r\nspin_lock_irq(&dice->lock);\r\nif (WARN_ON(dice->dev_lock_count <= 0))\r\ngoto out;\r\nif (--dice->dev_lock_count == 0)\r\ndice_lock_changed(dice);\r\nout:\r\nspin_unlock_irq(&dice->lock);\r\n}
