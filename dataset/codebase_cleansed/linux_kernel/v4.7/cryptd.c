static int cryptd_init_queue(struct cryptd_queue *queue,\r\nunsigned int max_cpu_qlen)\r\n{\r\nint cpu;\r\nstruct cryptd_cpu_queue *cpu_queue;\r\nqueue->cpu_queue = alloc_percpu(struct cryptd_cpu_queue);\r\nif (!queue->cpu_queue)\r\nreturn -ENOMEM;\r\nfor_each_possible_cpu(cpu) {\r\ncpu_queue = per_cpu_ptr(queue->cpu_queue, cpu);\r\ncrypto_init_queue(&cpu_queue->queue, max_cpu_qlen);\r\nINIT_WORK(&cpu_queue->work, cryptd_queue_worker);\r\n}\r\nreturn 0;\r\n}\r\nstatic void cryptd_fini_queue(struct cryptd_queue *queue)\r\n{\r\nint cpu;\r\nstruct cryptd_cpu_queue *cpu_queue;\r\nfor_each_possible_cpu(cpu) {\r\ncpu_queue = per_cpu_ptr(queue->cpu_queue, cpu);\r\nBUG_ON(cpu_queue->queue.qlen);\r\n}\r\nfree_percpu(queue->cpu_queue);\r\n}\r\nstatic int cryptd_enqueue_request(struct cryptd_queue *queue,\r\nstruct crypto_async_request *request)\r\n{\r\nint cpu, err;\r\nstruct cryptd_cpu_queue *cpu_queue;\r\ncpu = get_cpu();\r\ncpu_queue = this_cpu_ptr(queue->cpu_queue);\r\nerr = crypto_enqueue_request(&cpu_queue->queue, request);\r\nqueue_work_on(cpu, kcrypto_wq, &cpu_queue->work);\r\nput_cpu();\r\nreturn err;\r\n}\r\nstatic void cryptd_queue_worker(struct work_struct *work)\r\n{\r\nstruct cryptd_cpu_queue *cpu_queue;\r\nstruct crypto_async_request *req, *backlog;\r\ncpu_queue = container_of(work, struct cryptd_cpu_queue, work);\r\nlocal_bh_disable();\r\npreempt_disable();\r\nbacklog = crypto_get_backlog(&cpu_queue->queue);\r\nreq = crypto_dequeue_request(&cpu_queue->queue);\r\npreempt_enable();\r\nlocal_bh_enable();\r\nif (!req)\r\nreturn;\r\nif (backlog)\r\nbacklog->complete(backlog, -EINPROGRESS);\r\nreq->complete(req, 0);\r\nif (cpu_queue->queue.qlen)\r\nqueue_work(kcrypto_wq, &cpu_queue->work);\r\n}\r\nstatic inline struct cryptd_queue *cryptd_get_queue(struct crypto_tfm *tfm)\r\n{\r\nstruct crypto_instance *inst = crypto_tfm_alg_instance(tfm);\r\nstruct cryptd_instance_ctx *ictx = crypto_instance_ctx(inst);\r\nreturn ictx->queue;\r\n}\r\nstatic inline void cryptd_check_internal(struct rtattr **tb, u32 *type,\r\nu32 *mask)\r\n{\r\nstruct crypto_attr_type *algt;\r\nalgt = crypto_get_attr_type(tb);\r\nif (IS_ERR(algt))\r\nreturn;\r\n*type |= algt->type & CRYPTO_ALG_INTERNAL;\r\n*mask |= algt->mask & CRYPTO_ALG_INTERNAL;\r\n}\r\nstatic int cryptd_blkcipher_setkey(struct crypto_ablkcipher *parent,\r\nconst u8 *key, unsigned int keylen)\r\n{\r\nstruct cryptd_blkcipher_ctx *ctx = crypto_ablkcipher_ctx(parent);\r\nstruct crypto_blkcipher *child = ctx->child;\r\nint err;\r\ncrypto_blkcipher_clear_flags(child, CRYPTO_TFM_REQ_MASK);\r\ncrypto_blkcipher_set_flags(child, crypto_ablkcipher_get_flags(parent) &\r\nCRYPTO_TFM_REQ_MASK);\r\nerr = crypto_blkcipher_setkey(child, key, keylen);\r\ncrypto_ablkcipher_set_flags(parent, crypto_blkcipher_get_flags(child) &\r\nCRYPTO_TFM_RES_MASK);\r\nreturn err;\r\n}\r\nstatic void cryptd_blkcipher_crypt(struct ablkcipher_request *req,\r\nstruct crypto_blkcipher *child,\r\nint err,\r\nint (*crypt)(struct blkcipher_desc *desc,\r\nstruct scatterlist *dst,\r\nstruct scatterlist *src,\r\nunsigned int len))\r\n{\r\nstruct cryptd_blkcipher_request_ctx *rctx;\r\nstruct blkcipher_desc desc;\r\nrctx = ablkcipher_request_ctx(req);\r\nif (unlikely(err == -EINPROGRESS))\r\ngoto out;\r\ndesc.tfm = child;\r\ndesc.info = req->info;\r\ndesc.flags = CRYPTO_TFM_REQ_MAY_SLEEP;\r\nerr = crypt(&desc, req->dst, req->src, req->nbytes);\r\nreq->base.complete = rctx->complete;\r\nout:\r\nlocal_bh_disable();\r\nrctx->complete(&req->base, err);\r\nlocal_bh_enable();\r\n}\r\nstatic void cryptd_blkcipher_encrypt(struct crypto_async_request *req, int err)\r\n{\r\nstruct cryptd_blkcipher_ctx *ctx = crypto_tfm_ctx(req->tfm);\r\nstruct crypto_blkcipher *child = ctx->child;\r\ncryptd_blkcipher_crypt(ablkcipher_request_cast(req), child, err,\r\ncrypto_blkcipher_crt(child)->encrypt);\r\n}\r\nstatic void cryptd_blkcipher_decrypt(struct crypto_async_request *req, int err)\r\n{\r\nstruct cryptd_blkcipher_ctx *ctx = crypto_tfm_ctx(req->tfm);\r\nstruct crypto_blkcipher *child = ctx->child;\r\ncryptd_blkcipher_crypt(ablkcipher_request_cast(req), child, err,\r\ncrypto_blkcipher_crt(child)->decrypt);\r\n}\r\nstatic int cryptd_blkcipher_enqueue(struct ablkcipher_request *req,\r\ncrypto_completion_t compl)\r\n{\r\nstruct cryptd_blkcipher_request_ctx *rctx = ablkcipher_request_ctx(req);\r\nstruct crypto_ablkcipher *tfm = crypto_ablkcipher_reqtfm(req);\r\nstruct cryptd_queue *queue;\r\nqueue = cryptd_get_queue(crypto_ablkcipher_tfm(tfm));\r\nrctx->complete = req->base.complete;\r\nreq->base.complete = compl;\r\nreturn cryptd_enqueue_request(queue, &req->base);\r\n}\r\nstatic int cryptd_blkcipher_encrypt_enqueue(struct ablkcipher_request *req)\r\n{\r\nreturn cryptd_blkcipher_enqueue(req, cryptd_blkcipher_encrypt);\r\n}\r\nstatic int cryptd_blkcipher_decrypt_enqueue(struct ablkcipher_request *req)\r\n{\r\nreturn cryptd_blkcipher_enqueue(req, cryptd_blkcipher_decrypt);\r\n}\r\nstatic int cryptd_blkcipher_init_tfm(struct crypto_tfm *tfm)\r\n{\r\nstruct crypto_instance *inst = crypto_tfm_alg_instance(tfm);\r\nstruct cryptd_instance_ctx *ictx = crypto_instance_ctx(inst);\r\nstruct crypto_spawn *spawn = &ictx->spawn;\r\nstruct cryptd_blkcipher_ctx *ctx = crypto_tfm_ctx(tfm);\r\nstruct crypto_blkcipher *cipher;\r\ncipher = crypto_spawn_blkcipher(spawn);\r\nif (IS_ERR(cipher))\r\nreturn PTR_ERR(cipher);\r\nctx->child = cipher;\r\ntfm->crt_ablkcipher.reqsize =\r\nsizeof(struct cryptd_blkcipher_request_ctx);\r\nreturn 0;\r\n}\r\nstatic void cryptd_blkcipher_exit_tfm(struct crypto_tfm *tfm)\r\n{\r\nstruct cryptd_blkcipher_ctx *ctx = crypto_tfm_ctx(tfm);\r\ncrypto_free_blkcipher(ctx->child);\r\n}\r\nstatic int cryptd_init_instance(struct crypto_instance *inst,\r\nstruct crypto_alg *alg)\r\n{\r\nif (snprintf(inst->alg.cra_driver_name, CRYPTO_MAX_ALG_NAME,\r\n"cryptd(%s)",\r\nalg->cra_driver_name) >= CRYPTO_MAX_ALG_NAME)\r\nreturn -ENAMETOOLONG;\r\nmemcpy(inst->alg.cra_name, alg->cra_name, CRYPTO_MAX_ALG_NAME);\r\ninst->alg.cra_priority = alg->cra_priority + 50;\r\ninst->alg.cra_blocksize = alg->cra_blocksize;\r\ninst->alg.cra_alignmask = alg->cra_alignmask;\r\nreturn 0;\r\n}\r\nstatic void *cryptd_alloc_instance(struct crypto_alg *alg, unsigned int head,\r\nunsigned int tail)\r\n{\r\nchar *p;\r\nstruct crypto_instance *inst;\r\nint err;\r\np = kzalloc(head + sizeof(*inst) + tail, GFP_KERNEL);\r\nif (!p)\r\nreturn ERR_PTR(-ENOMEM);\r\ninst = (void *)(p + head);\r\nerr = cryptd_init_instance(inst, alg);\r\nif (err)\r\ngoto out_free_inst;\r\nout:\r\nreturn p;\r\nout_free_inst:\r\nkfree(p);\r\np = ERR_PTR(err);\r\ngoto out;\r\n}\r\nstatic int cryptd_create_blkcipher(struct crypto_template *tmpl,\r\nstruct rtattr **tb,\r\nstruct cryptd_queue *queue)\r\n{\r\nstruct cryptd_instance_ctx *ctx;\r\nstruct crypto_instance *inst;\r\nstruct crypto_alg *alg;\r\nu32 type = CRYPTO_ALG_TYPE_BLKCIPHER;\r\nu32 mask = CRYPTO_ALG_TYPE_MASK;\r\nint err;\r\ncryptd_check_internal(tb, &type, &mask);\r\nalg = crypto_get_attr_alg(tb, type, mask);\r\nif (IS_ERR(alg))\r\nreturn PTR_ERR(alg);\r\ninst = cryptd_alloc_instance(alg, 0, sizeof(*ctx));\r\nerr = PTR_ERR(inst);\r\nif (IS_ERR(inst))\r\ngoto out_put_alg;\r\nctx = crypto_instance_ctx(inst);\r\nctx->queue = queue;\r\nerr = crypto_init_spawn(&ctx->spawn, alg, inst,\r\nCRYPTO_ALG_TYPE_MASK | CRYPTO_ALG_ASYNC);\r\nif (err)\r\ngoto out_free_inst;\r\ntype = CRYPTO_ALG_TYPE_ABLKCIPHER | CRYPTO_ALG_ASYNC;\r\nif (alg->cra_flags & CRYPTO_ALG_INTERNAL)\r\ntype |= CRYPTO_ALG_INTERNAL;\r\ninst->alg.cra_flags = type;\r\ninst->alg.cra_type = &crypto_ablkcipher_type;\r\ninst->alg.cra_ablkcipher.ivsize = alg->cra_blkcipher.ivsize;\r\ninst->alg.cra_ablkcipher.min_keysize = alg->cra_blkcipher.min_keysize;\r\ninst->alg.cra_ablkcipher.max_keysize = alg->cra_blkcipher.max_keysize;\r\ninst->alg.cra_ablkcipher.geniv = alg->cra_blkcipher.geniv;\r\ninst->alg.cra_ctxsize = sizeof(struct cryptd_blkcipher_ctx);\r\ninst->alg.cra_init = cryptd_blkcipher_init_tfm;\r\ninst->alg.cra_exit = cryptd_blkcipher_exit_tfm;\r\ninst->alg.cra_ablkcipher.setkey = cryptd_blkcipher_setkey;\r\ninst->alg.cra_ablkcipher.encrypt = cryptd_blkcipher_encrypt_enqueue;\r\ninst->alg.cra_ablkcipher.decrypt = cryptd_blkcipher_decrypt_enqueue;\r\nerr = crypto_register_instance(tmpl, inst);\r\nif (err) {\r\ncrypto_drop_spawn(&ctx->spawn);\r\nout_free_inst:\r\nkfree(inst);\r\n}\r\nout_put_alg:\r\ncrypto_mod_put(alg);\r\nreturn err;\r\n}\r\nstatic int cryptd_hash_init_tfm(struct crypto_tfm *tfm)\r\n{\r\nstruct crypto_instance *inst = crypto_tfm_alg_instance(tfm);\r\nstruct hashd_instance_ctx *ictx = crypto_instance_ctx(inst);\r\nstruct crypto_shash_spawn *spawn = &ictx->spawn;\r\nstruct cryptd_hash_ctx *ctx = crypto_tfm_ctx(tfm);\r\nstruct crypto_shash *hash;\r\nhash = crypto_spawn_shash(spawn);\r\nif (IS_ERR(hash))\r\nreturn PTR_ERR(hash);\r\nctx->child = hash;\r\ncrypto_ahash_set_reqsize(__crypto_ahash_cast(tfm),\r\nsizeof(struct cryptd_hash_request_ctx) +\r\ncrypto_shash_descsize(hash));\r\nreturn 0;\r\n}\r\nstatic void cryptd_hash_exit_tfm(struct crypto_tfm *tfm)\r\n{\r\nstruct cryptd_hash_ctx *ctx = crypto_tfm_ctx(tfm);\r\ncrypto_free_shash(ctx->child);\r\n}\r\nstatic int cryptd_hash_setkey(struct crypto_ahash *parent,\r\nconst u8 *key, unsigned int keylen)\r\n{\r\nstruct cryptd_hash_ctx *ctx = crypto_ahash_ctx(parent);\r\nstruct crypto_shash *child = ctx->child;\r\nint err;\r\ncrypto_shash_clear_flags(child, CRYPTO_TFM_REQ_MASK);\r\ncrypto_shash_set_flags(child, crypto_ahash_get_flags(parent) &\r\nCRYPTO_TFM_REQ_MASK);\r\nerr = crypto_shash_setkey(child, key, keylen);\r\ncrypto_ahash_set_flags(parent, crypto_shash_get_flags(child) &\r\nCRYPTO_TFM_RES_MASK);\r\nreturn err;\r\n}\r\nstatic int cryptd_hash_enqueue(struct ahash_request *req,\r\ncrypto_completion_t compl)\r\n{\r\nstruct cryptd_hash_request_ctx *rctx = ahash_request_ctx(req);\r\nstruct crypto_ahash *tfm = crypto_ahash_reqtfm(req);\r\nstruct cryptd_queue *queue =\r\ncryptd_get_queue(crypto_ahash_tfm(tfm));\r\nrctx->complete = req->base.complete;\r\nreq->base.complete = compl;\r\nreturn cryptd_enqueue_request(queue, &req->base);\r\n}\r\nstatic void cryptd_hash_init(struct crypto_async_request *req_async, int err)\r\n{\r\nstruct cryptd_hash_ctx *ctx = crypto_tfm_ctx(req_async->tfm);\r\nstruct crypto_shash *child = ctx->child;\r\nstruct ahash_request *req = ahash_request_cast(req_async);\r\nstruct cryptd_hash_request_ctx *rctx = ahash_request_ctx(req);\r\nstruct shash_desc *desc = &rctx->desc;\r\nif (unlikely(err == -EINPROGRESS))\r\ngoto out;\r\ndesc->tfm = child;\r\ndesc->flags = CRYPTO_TFM_REQ_MAY_SLEEP;\r\nerr = crypto_shash_init(desc);\r\nreq->base.complete = rctx->complete;\r\nout:\r\nlocal_bh_disable();\r\nrctx->complete(&req->base, err);\r\nlocal_bh_enable();\r\n}\r\nstatic int cryptd_hash_init_enqueue(struct ahash_request *req)\r\n{\r\nreturn cryptd_hash_enqueue(req, cryptd_hash_init);\r\n}\r\nstatic void cryptd_hash_update(struct crypto_async_request *req_async, int err)\r\n{\r\nstruct ahash_request *req = ahash_request_cast(req_async);\r\nstruct cryptd_hash_request_ctx *rctx;\r\nrctx = ahash_request_ctx(req);\r\nif (unlikely(err == -EINPROGRESS))\r\ngoto out;\r\nerr = shash_ahash_update(req, &rctx->desc);\r\nreq->base.complete = rctx->complete;\r\nout:\r\nlocal_bh_disable();\r\nrctx->complete(&req->base, err);\r\nlocal_bh_enable();\r\n}\r\nstatic int cryptd_hash_update_enqueue(struct ahash_request *req)\r\n{\r\nreturn cryptd_hash_enqueue(req, cryptd_hash_update);\r\n}\r\nstatic void cryptd_hash_final(struct crypto_async_request *req_async, int err)\r\n{\r\nstruct ahash_request *req = ahash_request_cast(req_async);\r\nstruct cryptd_hash_request_ctx *rctx = ahash_request_ctx(req);\r\nif (unlikely(err == -EINPROGRESS))\r\ngoto out;\r\nerr = crypto_shash_final(&rctx->desc, req->result);\r\nreq->base.complete = rctx->complete;\r\nout:\r\nlocal_bh_disable();\r\nrctx->complete(&req->base, err);\r\nlocal_bh_enable();\r\n}\r\nstatic int cryptd_hash_final_enqueue(struct ahash_request *req)\r\n{\r\nreturn cryptd_hash_enqueue(req, cryptd_hash_final);\r\n}\r\nstatic void cryptd_hash_finup(struct crypto_async_request *req_async, int err)\r\n{\r\nstruct ahash_request *req = ahash_request_cast(req_async);\r\nstruct cryptd_hash_request_ctx *rctx = ahash_request_ctx(req);\r\nif (unlikely(err == -EINPROGRESS))\r\ngoto out;\r\nerr = shash_ahash_finup(req, &rctx->desc);\r\nreq->base.complete = rctx->complete;\r\nout:\r\nlocal_bh_disable();\r\nrctx->complete(&req->base, err);\r\nlocal_bh_enable();\r\n}\r\nstatic int cryptd_hash_finup_enqueue(struct ahash_request *req)\r\n{\r\nreturn cryptd_hash_enqueue(req, cryptd_hash_finup);\r\n}\r\nstatic void cryptd_hash_digest(struct crypto_async_request *req_async, int err)\r\n{\r\nstruct cryptd_hash_ctx *ctx = crypto_tfm_ctx(req_async->tfm);\r\nstruct crypto_shash *child = ctx->child;\r\nstruct ahash_request *req = ahash_request_cast(req_async);\r\nstruct cryptd_hash_request_ctx *rctx = ahash_request_ctx(req);\r\nstruct shash_desc *desc = &rctx->desc;\r\nif (unlikely(err == -EINPROGRESS))\r\ngoto out;\r\ndesc->tfm = child;\r\ndesc->flags = CRYPTO_TFM_REQ_MAY_SLEEP;\r\nerr = shash_ahash_digest(req, desc);\r\nreq->base.complete = rctx->complete;\r\nout:\r\nlocal_bh_disable();\r\nrctx->complete(&req->base, err);\r\nlocal_bh_enable();\r\n}\r\nstatic int cryptd_hash_digest_enqueue(struct ahash_request *req)\r\n{\r\nreturn cryptd_hash_enqueue(req, cryptd_hash_digest);\r\n}\r\nstatic int cryptd_hash_export(struct ahash_request *req, void *out)\r\n{\r\nstruct cryptd_hash_request_ctx *rctx = ahash_request_ctx(req);\r\nreturn crypto_shash_export(&rctx->desc, out);\r\n}\r\nstatic int cryptd_hash_import(struct ahash_request *req, const void *in)\r\n{\r\nstruct cryptd_hash_request_ctx *rctx = ahash_request_ctx(req);\r\nreturn crypto_shash_import(&rctx->desc, in);\r\n}\r\nstatic int cryptd_create_hash(struct crypto_template *tmpl, struct rtattr **tb,\r\nstruct cryptd_queue *queue)\r\n{\r\nstruct hashd_instance_ctx *ctx;\r\nstruct ahash_instance *inst;\r\nstruct shash_alg *salg;\r\nstruct crypto_alg *alg;\r\nu32 type = 0;\r\nu32 mask = 0;\r\nint err;\r\ncryptd_check_internal(tb, &type, &mask);\r\nsalg = shash_attr_alg(tb[1], type, mask);\r\nif (IS_ERR(salg))\r\nreturn PTR_ERR(salg);\r\nalg = &salg->base;\r\ninst = cryptd_alloc_instance(alg, ahash_instance_headroom(),\r\nsizeof(*ctx));\r\nerr = PTR_ERR(inst);\r\nif (IS_ERR(inst))\r\ngoto out_put_alg;\r\nctx = ahash_instance_ctx(inst);\r\nctx->queue = queue;\r\nerr = crypto_init_shash_spawn(&ctx->spawn, salg,\r\nahash_crypto_instance(inst));\r\nif (err)\r\ngoto out_free_inst;\r\ntype = CRYPTO_ALG_ASYNC;\r\nif (alg->cra_flags & CRYPTO_ALG_INTERNAL)\r\ntype |= CRYPTO_ALG_INTERNAL;\r\ninst->alg.halg.base.cra_flags = type;\r\ninst->alg.halg.digestsize = salg->digestsize;\r\ninst->alg.halg.statesize = salg->statesize;\r\ninst->alg.halg.base.cra_ctxsize = sizeof(struct cryptd_hash_ctx);\r\ninst->alg.halg.base.cra_init = cryptd_hash_init_tfm;\r\ninst->alg.halg.base.cra_exit = cryptd_hash_exit_tfm;\r\ninst->alg.init = cryptd_hash_init_enqueue;\r\ninst->alg.update = cryptd_hash_update_enqueue;\r\ninst->alg.final = cryptd_hash_final_enqueue;\r\ninst->alg.finup = cryptd_hash_finup_enqueue;\r\ninst->alg.export = cryptd_hash_export;\r\ninst->alg.import = cryptd_hash_import;\r\ninst->alg.setkey = cryptd_hash_setkey;\r\ninst->alg.digest = cryptd_hash_digest_enqueue;\r\nerr = ahash_register_instance(tmpl, inst);\r\nif (err) {\r\ncrypto_drop_shash(&ctx->spawn);\r\nout_free_inst:\r\nkfree(inst);\r\n}\r\nout_put_alg:\r\ncrypto_mod_put(alg);\r\nreturn err;\r\n}\r\nstatic int cryptd_aead_setkey(struct crypto_aead *parent,\r\nconst u8 *key, unsigned int keylen)\r\n{\r\nstruct cryptd_aead_ctx *ctx = crypto_aead_ctx(parent);\r\nstruct crypto_aead *child = ctx->child;\r\nreturn crypto_aead_setkey(child, key, keylen);\r\n}\r\nstatic int cryptd_aead_setauthsize(struct crypto_aead *parent,\r\nunsigned int authsize)\r\n{\r\nstruct cryptd_aead_ctx *ctx = crypto_aead_ctx(parent);\r\nstruct crypto_aead *child = ctx->child;\r\nreturn crypto_aead_setauthsize(child, authsize);\r\n}\r\nstatic void cryptd_aead_crypt(struct aead_request *req,\r\nstruct crypto_aead *child,\r\nint err,\r\nint (*crypt)(struct aead_request *req))\r\n{\r\nstruct cryptd_aead_request_ctx *rctx;\r\ncrypto_completion_t compl;\r\nrctx = aead_request_ctx(req);\r\ncompl = rctx->complete;\r\nif (unlikely(err == -EINPROGRESS))\r\ngoto out;\r\naead_request_set_tfm(req, child);\r\nerr = crypt( req );\r\nout:\r\nlocal_bh_disable();\r\ncompl(&req->base, err);\r\nlocal_bh_enable();\r\n}\r\nstatic void cryptd_aead_encrypt(struct crypto_async_request *areq, int err)\r\n{\r\nstruct cryptd_aead_ctx *ctx = crypto_tfm_ctx(areq->tfm);\r\nstruct crypto_aead *child = ctx->child;\r\nstruct aead_request *req;\r\nreq = container_of(areq, struct aead_request, base);\r\ncryptd_aead_crypt(req, child, err, crypto_aead_alg(child)->encrypt);\r\n}\r\nstatic void cryptd_aead_decrypt(struct crypto_async_request *areq, int err)\r\n{\r\nstruct cryptd_aead_ctx *ctx = crypto_tfm_ctx(areq->tfm);\r\nstruct crypto_aead *child = ctx->child;\r\nstruct aead_request *req;\r\nreq = container_of(areq, struct aead_request, base);\r\ncryptd_aead_crypt(req, child, err, crypto_aead_alg(child)->decrypt);\r\n}\r\nstatic int cryptd_aead_enqueue(struct aead_request *req,\r\ncrypto_completion_t compl)\r\n{\r\nstruct cryptd_aead_request_ctx *rctx = aead_request_ctx(req);\r\nstruct crypto_aead *tfm = crypto_aead_reqtfm(req);\r\nstruct cryptd_queue *queue = cryptd_get_queue(crypto_aead_tfm(tfm));\r\nrctx->complete = req->base.complete;\r\nreq->base.complete = compl;\r\nreturn cryptd_enqueue_request(queue, &req->base);\r\n}\r\nstatic int cryptd_aead_encrypt_enqueue(struct aead_request *req)\r\n{\r\nreturn cryptd_aead_enqueue(req, cryptd_aead_encrypt );\r\n}\r\nstatic int cryptd_aead_decrypt_enqueue(struct aead_request *req)\r\n{\r\nreturn cryptd_aead_enqueue(req, cryptd_aead_decrypt );\r\n}\r\nstatic int cryptd_aead_init_tfm(struct crypto_aead *tfm)\r\n{\r\nstruct aead_instance *inst = aead_alg_instance(tfm);\r\nstruct aead_instance_ctx *ictx = aead_instance_ctx(inst);\r\nstruct crypto_aead_spawn *spawn = &ictx->aead_spawn;\r\nstruct cryptd_aead_ctx *ctx = crypto_aead_ctx(tfm);\r\nstruct crypto_aead *cipher;\r\ncipher = crypto_spawn_aead(spawn);\r\nif (IS_ERR(cipher))\r\nreturn PTR_ERR(cipher);\r\nctx->child = cipher;\r\ncrypto_aead_set_reqsize(\r\ntfm, max((unsigned)sizeof(struct cryptd_aead_request_ctx),\r\ncrypto_aead_reqsize(cipher)));\r\nreturn 0;\r\n}\r\nstatic void cryptd_aead_exit_tfm(struct crypto_aead *tfm)\r\n{\r\nstruct cryptd_aead_ctx *ctx = crypto_aead_ctx(tfm);\r\ncrypto_free_aead(ctx->child);\r\n}\r\nstatic int cryptd_create_aead(struct crypto_template *tmpl,\r\nstruct rtattr **tb,\r\nstruct cryptd_queue *queue)\r\n{\r\nstruct aead_instance_ctx *ctx;\r\nstruct aead_instance *inst;\r\nstruct aead_alg *alg;\r\nconst char *name;\r\nu32 type = 0;\r\nu32 mask = CRYPTO_ALG_ASYNC;\r\nint err;\r\ncryptd_check_internal(tb, &type, &mask);\r\nname = crypto_attr_alg_name(tb[1]);\r\nif (IS_ERR(name))\r\nreturn PTR_ERR(name);\r\ninst = kzalloc(sizeof(*inst) + sizeof(*ctx), GFP_KERNEL);\r\nif (!inst)\r\nreturn -ENOMEM;\r\nctx = aead_instance_ctx(inst);\r\nctx->queue = queue;\r\ncrypto_set_aead_spawn(&ctx->aead_spawn, aead_crypto_instance(inst));\r\nerr = crypto_grab_aead(&ctx->aead_spawn, name, type, mask);\r\nif (err)\r\ngoto out_free_inst;\r\nalg = crypto_spawn_aead_alg(&ctx->aead_spawn);\r\nerr = cryptd_init_instance(aead_crypto_instance(inst), &alg->base);\r\nif (err)\r\ngoto out_drop_aead;\r\ninst->alg.base.cra_flags = CRYPTO_ALG_ASYNC |\r\n(alg->base.cra_flags & CRYPTO_ALG_INTERNAL);\r\ninst->alg.base.cra_ctxsize = sizeof(struct cryptd_aead_ctx);\r\ninst->alg.ivsize = crypto_aead_alg_ivsize(alg);\r\ninst->alg.maxauthsize = crypto_aead_alg_maxauthsize(alg);\r\ninst->alg.init = cryptd_aead_init_tfm;\r\ninst->alg.exit = cryptd_aead_exit_tfm;\r\ninst->alg.setkey = cryptd_aead_setkey;\r\ninst->alg.setauthsize = cryptd_aead_setauthsize;\r\ninst->alg.encrypt = cryptd_aead_encrypt_enqueue;\r\ninst->alg.decrypt = cryptd_aead_decrypt_enqueue;\r\nerr = aead_register_instance(tmpl, inst);\r\nif (err) {\r\nout_drop_aead:\r\ncrypto_drop_aead(&ctx->aead_spawn);\r\nout_free_inst:\r\nkfree(inst);\r\n}\r\nreturn err;\r\n}\r\nstatic int cryptd_create(struct crypto_template *tmpl, struct rtattr **tb)\r\n{\r\nstruct crypto_attr_type *algt;\r\nalgt = crypto_get_attr_type(tb);\r\nif (IS_ERR(algt))\r\nreturn PTR_ERR(algt);\r\nswitch (algt->type & algt->mask & CRYPTO_ALG_TYPE_MASK) {\r\ncase CRYPTO_ALG_TYPE_BLKCIPHER:\r\nreturn cryptd_create_blkcipher(tmpl, tb, &queue);\r\ncase CRYPTO_ALG_TYPE_DIGEST:\r\nreturn cryptd_create_hash(tmpl, tb, &queue);\r\ncase CRYPTO_ALG_TYPE_AEAD:\r\nreturn cryptd_create_aead(tmpl, tb, &queue);\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic void cryptd_free(struct crypto_instance *inst)\r\n{\r\nstruct cryptd_instance_ctx *ctx = crypto_instance_ctx(inst);\r\nstruct hashd_instance_ctx *hctx = crypto_instance_ctx(inst);\r\nstruct aead_instance_ctx *aead_ctx = crypto_instance_ctx(inst);\r\nswitch (inst->alg.cra_flags & CRYPTO_ALG_TYPE_MASK) {\r\ncase CRYPTO_ALG_TYPE_AHASH:\r\ncrypto_drop_shash(&hctx->spawn);\r\nkfree(ahash_instance(inst));\r\nreturn;\r\ncase CRYPTO_ALG_TYPE_AEAD:\r\ncrypto_drop_aead(&aead_ctx->aead_spawn);\r\nkfree(aead_instance(inst));\r\nreturn;\r\ndefault:\r\ncrypto_drop_spawn(&ctx->spawn);\r\nkfree(inst);\r\n}\r\n}\r\nstruct cryptd_ablkcipher *cryptd_alloc_ablkcipher(const char *alg_name,\r\nu32 type, u32 mask)\r\n{\r\nchar cryptd_alg_name[CRYPTO_MAX_ALG_NAME];\r\nstruct crypto_tfm *tfm;\r\nif (snprintf(cryptd_alg_name, CRYPTO_MAX_ALG_NAME,\r\n"cryptd(%s)", alg_name) >= CRYPTO_MAX_ALG_NAME)\r\nreturn ERR_PTR(-EINVAL);\r\ntype = crypto_skcipher_type(type);\r\nmask &= ~CRYPTO_ALG_TYPE_MASK;\r\nmask |= (CRYPTO_ALG_GENIV | CRYPTO_ALG_TYPE_BLKCIPHER_MASK);\r\ntfm = crypto_alloc_base(cryptd_alg_name, type, mask);\r\nif (IS_ERR(tfm))\r\nreturn ERR_CAST(tfm);\r\nif (tfm->__crt_alg->cra_module != THIS_MODULE) {\r\ncrypto_free_tfm(tfm);\r\nreturn ERR_PTR(-EINVAL);\r\n}\r\nreturn __cryptd_ablkcipher_cast(__crypto_ablkcipher_cast(tfm));\r\n}\r\nstruct crypto_blkcipher *cryptd_ablkcipher_child(struct cryptd_ablkcipher *tfm)\r\n{\r\nstruct cryptd_blkcipher_ctx *ctx = crypto_ablkcipher_ctx(&tfm->base);\r\nreturn ctx->child;\r\n}\r\nvoid cryptd_free_ablkcipher(struct cryptd_ablkcipher *tfm)\r\n{\r\ncrypto_free_ablkcipher(&tfm->base);\r\n}\r\nstruct cryptd_ahash *cryptd_alloc_ahash(const char *alg_name,\r\nu32 type, u32 mask)\r\n{\r\nchar cryptd_alg_name[CRYPTO_MAX_ALG_NAME];\r\nstruct crypto_ahash *tfm;\r\nif (snprintf(cryptd_alg_name, CRYPTO_MAX_ALG_NAME,\r\n"cryptd(%s)", alg_name) >= CRYPTO_MAX_ALG_NAME)\r\nreturn ERR_PTR(-EINVAL);\r\ntfm = crypto_alloc_ahash(cryptd_alg_name, type, mask);\r\nif (IS_ERR(tfm))\r\nreturn ERR_CAST(tfm);\r\nif (tfm->base.__crt_alg->cra_module != THIS_MODULE) {\r\ncrypto_free_ahash(tfm);\r\nreturn ERR_PTR(-EINVAL);\r\n}\r\nreturn __cryptd_ahash_cast(tfm);\r\n}\r\nstruct crypto_shash *cryptd_ahash_child(struct cryptd_ahash *tfm)\r\n{\r\nstruct cryptd_hash_ctx *ctx = crypto_ahash_ctx(&tfm->base);\r\nreturn ctx->child;\r\n}\r\nstruct shash_desc *cryptd_shash_desc(struct ahash_request *req)\r\n{\r\nstruct cryptd_hash_request_ctx *rctx = ahash_request_ctx(req);\r\nreturn &rctx->desc;\r\n}\r\nvoid cryptd_free_ahash(struct cryptd_ahash *tfm)\r\n{\r\ncrypto_free_ahash(&tfm->base);\r\n}\r\nstruct cryptd_aead *cryptd_alloc_aead(const char *alg_name,\r\nu32 type, u32 mask)\r\n{\r\nchar cryptd_alg_name[CRYPTO_MAX_ALG_NAME];\r\nstruct crypto_aead *tfm;\r\nif (snprintf(cryptd_alg_name, CRYPTO_MAX_ALG_NAME,\r\n"cryptd(%s)", alg_name) >= CRYPTO_MAX_ALG_NAME)\r\nreturn ERR_PTR(-EINVAL);\r\ntfm = crypto_alloc_aead(cryptd_alg_name, type, mask);\r\nif (IS_ERR(tfm))\r\nreturn ERR_CAST(tfm);\r\nif (tfm->base.__crt_alg->cra_module != THIS_MODULE) {\r\ncrypto_free_aead(tfm);\r\nreturn ERR_PTR(-EINVAL);\r\n}\r\nreturn __cryptd_aead_cast(tfm);\r\n}\r\nstruct crypto_aead *cryptd_aead_child(struct cryptd_aead *tfm)\r\n{\r\nstruct cryptd_aead_ctx *ctx;\r\nctx = crypto_aead_ctx(&tfm->base);\r\nreturn ctx->child;\r\n}\r\nvoid cryptd_free_aead(struct cryptd_aead *tfm)\r\n{\r\ncrypto_free_aead(&tfm->base);\r\n}\r\nstatic int __init cryptd_init(void)\r\n{\r\nint err;\r\nerr = cryptd_init_queue(&queue, CRYPTD_MAX_CPU_QLEN);\r\nif (err)\r\nreturn err;\r\nerr = crypto_register_template(&cryptd_tmpl);\r\nif (err)\r\ncryptd_fini_queue(&queue);\r\nreturn err;\r\n}\r\nstatic void __exit cryptd_exit(void)\r\n{\r\ncryptd_fini_queue(&queue);\r\ncrypto_unregister_template(&cryptd_tmpl);\r\n}
