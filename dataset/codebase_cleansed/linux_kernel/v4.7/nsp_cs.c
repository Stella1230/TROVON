static inline void nsp_inc_resid(struct scsi_cmnd *SCpnt, int residInc)\r\n{\r\nscsi_set_resid(SCpnt, scsi_get_resid(SCpnt) + residInc);\r\n}\r\nstatic void nsp_cs_message(const char *func, int line, char *type, char *fmt, ...)\r\n{\r\nva_list args;\r\nchar buf[NSP_DEBUG_BUF_LEN];\r\nva_start(args, fmt);\r\nvsnprintf(buf, sizeof(buf), fmt, args);\r\nva_end(args);\r\n#ifndef NSP_DEBUG\r\nprintk("%snsp_cs: %s\n", type, buf);\r\n#else\r\nprintk("%snsp_cs: %s (%d): %s\n", type, func, line, buf);\r\n#endif\r\n}\r\nstatic void nsp_cs_dmessage(const char *func, int line, int mask, char *fmt, ...)\r\n{\r\nva_list args;\r\nchar buf[NSP_DEBUG_BUF_LEN];\r\nva_start(args, fmt);\r\nvsnprintf(buf, sizeof(buf), fmt, args);\r\nva_end(args);\r\nif (mask & NSP_DEBUG_MASK) {\r\nprintk("nsp_cs-debug: 0x%x %s (%d): %s\n", mask, func, line, buf);\r\n}\r\n}\r\nstatic void nsp_scsi_done(struct scsi_cmnd *SCpnt)\r\n{\r\nnsp_hw_data *data = (nsp_hw_data *)SCpnt->device->host->hostdata;\r\ndata->CurrentSC = NULL;\r\nSCpnt->scsi_done(SCpnt);\r\n}\r\nstatic int nsp_queuecommand_lck(struct scsi_cmnd *SCpnt,\r\nvoid (*done)(struct scsi_cmnd *))\r\n{\r\n#ifdef NSP_DEBUG\r\nunsigned char target = scmd_id(SCpnt);\r\n#endif\r\nnsp_hw_data *data = (nsp_hw_data *)SCpnt->device->host->hostdata;\r\nnsp_dbg(NSP_DEBUG_QUEUECOMMAND,\r\n"SCpnt=0x%p target=%d lun=%llu sglist=0x%p bufflen=%d sg_count=%d",\r\nSCpnt, target, SCpnt->device->lun, scsi_sglist(SCpnt),\r\nscsi_bufflen(SCpnt), scsi_sg_count(SCpnt));\r\nSCpnt->scsi_done = done;\r\nif (data->CurrentSC != NULL) {\r\nnsp_msg(KERN_DEBUG, "CurrentSC!=NULL this can't be happen");\r\nSCpnt->result = DID_BAD_TARGET << 16;\r\nnsp_scsi_done(SCpnt);\r\nreturn 0;\r\n}\r\n#if 0\r\nif (data->ScsiInfo->stop != 0) {\r\nnsp_msg(KERN_INFO, "suspending device. reject command.");\r\nSCpnt->result = DID_BAD_TARGET << 16;\r\nnsp_scsi_done(SCpnt);\r\nreturn SCSI_MLQUEUE_HOST_BUSY;\r\n}\r\n#endif\r\nshow_command(SCpnt);\r\ndata->CurrentSC = SCpnt;\r\nSCpnt->SCp.Status = CHECK_CONDITION;\r\nSCpnt->SCp.Message = 0;\r\nSCpnt->SCp.have_data_in = IO_UNKNOWN;\r\nSCpnt->SCp.sent_command = 0;\r\nSCpnt->SCp.phase = PH_UNDETERMINED;\r\nscsi_set_resid(SCpnt, scsi_bufflen(SCpnt));\r\nif (scsi_bufflen(SCpnt)) {\r\nSCpnt->SCp.buffer = scsi_sglist(SCpnt);\r\nSCpnt->SCp.ptr = BUFFER_ADDR;\r\nSCpnt->SCp.this_residual = SCpnt->SCp.buffer->length;\r\nSCpnt->SCp.buffers_residual = scsi_sg_count(SCpnt) - 1;\r\n} else {\r\nSCpnt->SCp.ptr = NULL;\r\nSCpnt->SCp.this_residual = 0;\r\nSCpnt->SCp.buffer = NULL;\r\nSCpnt->SCp.buffers_residual = 0;\r\n}\r\nif (nsphw_start_selection(SCpnt) == FALSE) {\r\nnsp_dbg(NSP_DEBUG_QUEUECOMMAND, "selection fail");\r\nSCpnt->result = DID_BUS_BUSY << 16;\r\nnsp_scsi_done(SCpnt);\r\nreturn 0;\r\n}\r\n#ifdef NSP_DEBUG\r\ndata->CmdId++;\r\n#endif\r\nreturn 0;\r\n}\r\nvoid nsphw_init_sync(nsp_hw_data *data)\r\n{\r\nsync_data tmp_sync = { .SyncNegotiation = SYNC_NOT_YET,\r\n.SyncPeriod = 0,\r\n.SyncOffset = 0\r\n};\r\nint i;\r\nfor ( i = 0; i < ARRAY_SIZE(data->Sync); i++ ) {\r\ndata->Sync[i] = tmp_sync;\r\n}\r\n}\r\nstatic int nsphw_init(nsp_hw_data *data)\r\n{\r\nunsigned int base = data->BaseAddress;\r\nnsp_dbg(NSP_DEBUG_INIT, "in base=0x%x", base);\r\ndata->ScsiClockDiv = CLOCK_40M | FAST_20;\r\ndata->CurrentSC = NULL;\r\ndata->FifoCount = 0;\r\ndata->TransferMode = MODE_IO8;\r\nnsphw_init_sync(data);\r\nnsp_write(base, IRQCONTROL, IRQCONTROL_ALLMASK);\r\nnsp_write(base, IFSELECT, IF_IFSEL);\r\nnsp_index_write(base, SCSIIRQMODE, 0);\r\nnsp_index_write(base, TRANSFERMODE, MODE_IO8);\r\nnsp_index_write(base, CLOCKDIV, data->ScsiClockDiv);\r\nnsp_index_write(base, PARITYCTRL, 0);\r\nnsp_index_write(base, POINTERCLR, POINTER_CLEAR |\r\nACK_COUNTER_CLEAR |\r\nREQ_COUNTER_CLEAR |\r\nHOST_COUNTER_CLEAR);\r\nnsp_write(base, IFSELECT, IF_REGSEL);\r\nnsp_index_write(base, TERMPWRCTRL, 0);\r\nif ((nsp_index_read(base, OTHERCONTROL) & TPWR_SENSE) == 0) {\r\nnsp_msg(KERN_INFO, "terminator power on");\r\nnsp_index_write(base, TERMPWRCTRL, POWER_ON);\r\n}\r\nnsp_index_write(base, TIMERCOUNT, 0);\r\nnsp_index_write(base, TIMERCOUNT, 0);\r\nnsp_index_write(base, SYNCREG, 0);\r\nnsp_index_write(base, ACKWIDTH, 0);\r\nnsp_index_write(base, SCSIIRQMODE, SCSI_PHASE_CHANGE_EI |\r\nRESELECT_EI |\r\nSCSI_RESET_IRQ_EI );\r\nnsp_write(base, IRQCONTROL, IRQCONTROL_ALLCLEAR);\r\nnsp_setup_fifo(data, FALSE);\r\nreturn TRUE;\r\n}\r\nstatic int nsphw_start_selection(struct scsi_cmnd *SCpnt)\r\n{\r\nunsigned int host_id = SCpnt->device->host->this_id;\r\nunsigned int base = SCpnt->device->host->io_port;\r\nunsigned char target = scmd_id(SCpnt);\r\nnsp_hw_data *data = (nsp_hw_data *)SCpnt->device->host->hostdata;\r\nint time_out;\r\nunsigned char phase, arbit;\r\nphase = nsp_index_read(base, SCSIBUSMON);\r\nif(phase != BUSMON_BUS_FREE) {\r\nreturn FALSE;\r\n}\r\nSCpnt->SCp.phase = PH_ARBSTART;\r\nnsp_index_write(base, SETARBIT, ARBIT_GO);\r\ntime_out = 1000;\r\ndo {\r\narbit = nsp_index_read(base, ARBITSTATUS);\r\nudelay(1);\r\n} while((arbit & (ARBIT_WIN | ARBIT_FAIL)) == 0 &&\r\n(time_out-- != 0));\r\nif (!(arbit & ARBIT_WIN)) {\r\nnsp_index_write(base, SETARBIT, ARBIT_FLAG_CLEAR);\r\nreturn FALSE;\r\n}\r\nSCpnt->SCp.phase = PH_SELSTART;\r\nudelay(3);\r\nnsp_index_write(base, SCSIDATALATCH, BIT(host_id) | BIT(target));\r\nnsp_index_write(base, SCSIBUSCTRL, SCSI_SEL | SCSI_BSY | SCSI_ATN);\r\nudelay(2);\r\nnsp_index_write(base, SCSIBUSCTRL, SCSI_SEL | SCSI_BSY | SCSI_DATAOUT_ENB | SCSI_ATN);\r\nnsp_index_write(base, SETARBIT, ARBIT_FLAG_CLEAR);\r\nnsp_index_write(base, SCSIBUSCTRL, SCSI_SEL | SCSI_DATAOUT_ENB | SCSI_ATN);\r\nnsp_start_timer(SCpnt, 1000/51);\r\ndata->SelectionTimeOut = 1;\r\nreturn TRUE;\r\n}\r\nstatic int nsp_analyze_sdtr(struct scsi_cmnd *SCpnt)\r\n{\r\nunsigned char target = scmd_id(SCpnt);\r\nnsp_hw_data *data = (nsp_hw_data *)SCpnt->device->host->hostdata;\r\nsync_data *sync = &(data->Sync[target]);\r\nstruct nsp_sync_table *sync_table;\r\nunsigned int period, offset;\r\nint i;\r\nnsp_dbg(NSP_DEBUG_SYNC, "in");\r\nperiod = sync->SyncPeriod;\r\noffset = sync->SyncOffset;\r\nnsp_dbg(NSP_DEBUG_SYNC, "period=0x%x, offset=0x%x", period, offset);\r\nif ((data->ScsiClockDiv & (BIT(0)|BIT(1))) == CLOCK_20M) {\r\nsync_table = nsp_sync_table_20M;\r\n} else {\r\nsync_table = nsp_sync_table_40M;\r\n}\r\nfor ( i = 0; sync_table->max_period != 0; i++, sync_table++) {\r\nif ( period >= sync_table->min_period &&\r\nperiod <= sync_table->max_period ) {\r\nbreak;\r\n}\r\n}\r\nif (period != 0 && sync_table->max_period == 0) {\r\nnsp_dbg(NSP_DEBUG_SYNC, "no proper period/offset");\r\nsync->SyncPeriod = 0;\r\nsync->SyncOffset = 0;\r\nsync->SyncRegister = 0;\r\nsync->AckWidth = 0;\r\nreturn FALSE;\r\n}\r\nsync->SyncRegister = (sync_table->chip_period << SYNCREG_PERIOD_SHIFT) |\r\n(offset & SYNCREG_OFFSET_MASK);\r\nsync->AckWidth = sync_table->ack_width;\r\nnsp_dbg(NSP_DEBUG_SYNC, "sync_reg=0x%x, ack_width=0x%x", sync->SyncRegister, sync->AckWidth);\r\nreturn TRUE;\r\n}\r\nstatic void nsp_start_timer(struct scsi_cmnd *SCpnt, int time)\r\n{\r\nunsigned int base = SCpnt->device->host->io_port;\r\nnsp_hw_data *data = (nsp_hw_data *)SCpnt->device->host->hostdata;\r\ndata->TimerCount = time;\r\nnsp_index_write(base, TIMERCOUNT, time);\r\n}\r\nstatic int nsp_negate_signal(struct scsi_cmnd *SCpnt, unsigned char mask,\r\nchar *str)\r\n{\r\nunsigned int base = SCpnt->device->host->io_port;\r\nunsigned char reg;\r\nint time_out;\r\ntime_out = 100;\r\ndo {\r\nreg = nsp_index_read(base, SCSIBUSMON);\r\nif (reg == 0xff) {\r\nbreak;\r\n}\r\n} while ((--time_out != 0) && (reg & mask) != 0);\r\nif (time_out == 0) {\r\nnsp_msg(KERN_DEBUG, " %s signal off timeout", str);\r\n}\r\nreturn 0;\r\n}\r\nstatic int nsp_expect_signal(struct scsi_cmnd *SCpnt,\r\nunsigned char current_phase,\r\nunsigned char mask)\r\n{\r\nunsigned int base = SCpnt->device->host->io_port;\r\nint time_out;\r\nunsigned char phase, i_src;\r\ntime_out = 100;\r\ndo {\r\nphase = nsp_index_read(base, SCSIBUSMON);\r\nif (phase == 0xff) {\r\nreturn -1;\r\n}\r\ni_src = nsp_read(base, IRQSTATUS);\r\nif (i_src & IRQSTATUS_SCSI) {\r\nreturn 0;\r\n}\r\nif ((phase & mask) != 0 && (phase & BUSMON_PHASE_MASK) == current_phase) {\r\nreturn 1;\r\n}\r\n} while(time_out-- != 0);\r\nreturn -1;\r\n}\r\nstatic int nsp_xfer(struct scsi_cmnd *SCpnt, int phase)\r\n{\r\nunsigned int base = SCpnt->device->host->io_port;\r\nnsp_hw_data *data = (nsp_hw_data *)SCpnt->device->host->hostdata;\r\nchar *buf = data->MsgBuffer;\r\nint len = min(MSGBUF_SIZE, data->MsgLen);\r\nint ptr;\r\nint ret;\r\nfor (ptr = 0; len > 0; len--, ptr++) {\r\nret = nsp_expect_signal(SCpnt, phase, BUSMON_REQ);\r\nif (ret <= 0) {\r\nnsp_dbg(NSP_DEBUG_DATA_IO, "xfer quit");\r\nreturn 0;\r\n}\r\nif (len == 1 && SCpnt->SCp.phase == PH_MSG_OUT) {\r\nnsp_index_write(base, SCSIBUSCTRL, AUTODIRECTION | ACKENB);\r\n}\r\nif (phase & BUSMON_IO) {\r\nnsp_dbg(NSP_DEBUG_DATA_IO, "read msg");\r\nbuf[ptr] = nsp_index_read(base, SCSIDATAWITHACK);\r\n} else {\r\nnsp_dbg(NSP_DEBUG_DATA_IO, "write msg");\r\nnsp_index_write(base, SCSIDATAWITHACK, buf[ptr]);\r\n}\r\nnsp_negate_signal(SCpnt, BUSMON_ACK, "xfer<ack>");\r\n}\r\nreturn len;\r\n}\r\nstatic int nsp_dataphase_bypass(struct scsi_cmnd *SCpnt)\r\n{\r\nnsp_hw_data *data = (nsp_hw_data *)SCpnt->device->host->hostdata;\r\nunsigned int count;\r\nif (SCpnt->SCp.have_data_in != IO_IN) {\r\nreturn 0;\r\n}\r\ncount = nsp_fifo_count(SCpnt);\r\nif (data->FifoCount == count) {\r\nreturn 0;\r\n}\r\nnsp_dbg(NSP_DEBUG_DATA_IO, "use bypass quirk");\r\nSCpnt->SCp.phase = PH_DATA;\r\nnsp_pio_read(SCpnt);\r\nnsp_setup_fifo(data, FALSE);\r\nreturn 0;\r\n}\r\nstatic int nsp_reselected(struct scsi_cmnd *SCpnt)\r\n{\r\nunsigned int base = SCpnt->device->host->io_port;\r\nunsigned int host_id = SCpnt->device->host->this_id;\r\nunsigned char bus_reg;\r\nunsigned char id_reg, tmp;\r\nint target;\r\nnsp_dbg(NSP_DEBUG_RESELECTION, "in");\r\nid_reg = nsp_index_read(base, RESELECTID);\r\ntmp = id_reg & (~BIT(host_id));\r\ntarget = 0;\r\nwhile(tmp != 0) {\r\nif (tmp & BIT(0)) {\r\nbreak;\r\n}\r\ntmp >>= 1;\r\ntarget++;\r\n}\r\nif (scmd_id(SCpnt) != target) {\r\nnsp_msg(KERN_ERR, "XXX: reselect ID must be %d in this implementation.", target);\r\n}\r\nnsp_negate_signal(SCpnt, BUSMON_SEL, "reselect<SEL>");\r\nnsp_nexus(SCpnt);\r\nbus_reg = nsp_index_read(base, SCSIBUSCTRL) & ~(SCSI_BSY | SCSI_ATN);\r\nnsp_index_write(base, SCSIBUSCTRL, bus_reg);\r\nnsp_index_write(base, SCSIBUSCTRL, bus_reg | AUTODIRECTION | ACKENB);\r\nreturn TRUE;\r\n}\r\nstatic int nsp_fifo_count(struct scsi_cmnd *SCpnt)\r\n{\r\nunsigned int base = SCpnt->device->host->io_port;\r\nunsigned int count;\r\nunsigned int l, m, h, dummy;\r\nnsp_index_write(base, POINTERCLR, POINTER_CLEAR | ACK_COUNTER);\r\nl = nsp_index_read(base, TRANSFERCOUNT);\r\nm = nsp_index_read(base, TRANSFERCOUNT);\r\nh = nsp_index_read(base, TRANSFERCOUNT);\r\ndummy = nsp_index_read(base, TRANSFERCOUNT);\r\ncount = (h << 16) | (m << 8) | (l << 0);\r\nreturn count;\r\n}\r\nstatic void nsp_pio_read(struct scsi_cmnd *SCpnt)\r\n{\r\nunsigned int base = SCpnt->device->host->io_port;\r\nunsigned long mmio_base = SCpnt->device->host->base;\r\nnsp_hw_data *data = (nsp_hw_data *)SCpnt->device->host->hostdata;\r\nlong time_out;\r\nint ocount, res;\r\nunsigned char stat, fifo_stat;\r\nocount = data->FifoCount;\r\nnsp_dbg(NSP_DEBUG_DATA_IO, "in SCpnt=0x%p resid=%d ocount=%d ptr=0x%p this_residual=%d buffers=0x%p nbuf=%d",\r\nSCpnt, scsi_get_resid(SCpnt), ocount, SCpnt->SCp.ptr,\r\nSCpnt->SCp.this_residual, SCpnt->SCp.buffer,\r\nSCpnt->SCp.buffers_residual);\r\ntime_out = 1000;\r\nwhile ((time_out-- != 0) &&\r\n(SCpnt->SCp.this_residual > 0 || SCpnt->SCp.buffers_residual > 0 ) ) {\r\nstat = nsp_index_read(base, SCSIBUSMON);\r\nstat &= BUSMON_PHASE_MASK;\r\nres = nsp_fifo_count(SCpnt) - ocount;\r\nif (res == 0) {\r\nif (stat == BUSPHASE_DATA_IN) {\r\ncontinue;\r\n} else {\r\nnsp_dbg(NSP_DEBUG_DATA_IO, "phase changed stat=0x%x", stat);\r\nbreak;\r\n}\r\n}\r\nfifo_stat = nsp_read(base, FIFOSTATUS);\r\nif ((fifo_stat & FIFOSTATUS_FULL_EMPTY) == 0 &&\r\nstat == BUSPHASE_DATA_IN) {\r\ncontinue;\r\n}\r\nres = min(res, SCpnt->SCp.this_residual);\r\nswitch (data->TransferMode) {\r\ncase MODE_IO32:\r\nres &= ~(BIT(1)|BIT(0));\r\nnsp_fifo32_read(base, SCpnt->SCp.ptr, res >> 2);\r\nbreak;\r\ncase MODE_IO8:\r\nnsp_fifo8_read (base, SCpnt->SCp.ptr, res );\r\nbreak;\r\ncase MODE_MEM32:\r\nres &= ~(BIT(1)|BIT(0));\r\nnsp_mmio_fifo32_read(mmio_base, SCpnt->SCp.ptr, res >> 2);\r\nbreak;\r\ndefault:\r\nnsp_dbg(NSP_DEBUG_DATA_IO, "unknown read mode");\r\nreturn;\r\n}\r\nnsp_inc_resid(SCpnt, -res);\r\nSCpnt->SCp.ptr += res;\r\nSCpnt->SCp.this_residual -= res;\r\nocount += res;\r\nif (SCpnt->SCp.this_residual == 0 &&\r\nSCpnt->SCp.buffers_residual != 0 ) {\r\nSCpnt->SCp.buffers_residual--;\r\nSCpnt->SCp.buffer++;\r\nSCpnt->SCp.ptr = BUFFER_ADDR;\r\nSCpnt->SCp.this_residual = SCpnt->SCp.buffer->length;\r\ntime_out = 1000;\r\n}\r\n}\r\ndata->FifoCount = ocount;\r\nif (time_out < 0) {\r\nnsp_msg(KERN_DEBUG, "pio read timeout resid=%d this_residual=%d buffers_residual=%d",\r\nscsi_get_resid(SCpnt), SCpnt->SCp.this_residual,\r\nSCpnt->SCp.buffers_residual);\r\n}\r\nnsp_dbg(NSP_DEBUG_DATA_IO, "read ocount=0x%x", ocount);\r\nnsp_dbg(NSP_DEBUG_DATA_IO, "r cmd=%d resid=0x%x\n", data->CmdId,\r\nscsi_get_resid(SCpnt));\r\n}\r\nstatic void nsp_pio_write(struct scsi_cmnd *SCpnt)\r\n{\r\nunsigned int base = SCpnt->device->host->io_port;\r\nunsigned long mmio_base = SCpnt->device->host->base;\r\nnsp_hw_data *data = (nsp_hw_data *)SCpnt->device->host->hostdata;\r\nint time_out;\r\nint ocount, res;\r\nunsigned char stat;\r\nocount = data->FifoCount;\r\nnsp_dbg(NSP_DEBUG_DATA_IO, "in fifocount=%d ptr=0x%p this_residual=%d buffers=0x%p nbuf=%d resid=0x%x",\r\ndata->FifoCount, SCpnt->SCp.ptr, SCpnt->SCp.this_residual,\r\nSCpnt->SCp.buffer, SCpnt->SCp.buffers_residual,\r\nscsi_get_resid(SCpnt));\r\ntime_out = 1000;\r\nwhile ((time_out-- != 0) &&\r\n(SCpnt->SCp.this_residual > 0 || SCpnt->SCp.buffers_residual > 0)) {\r\nstat = nsp_index_read(base, SCSIBUSMON);\r\nstat &= BUSMON_PHASE_MASK;\r\nif (stat != BUSPHASE_DATA_OUT) {\r\nres = ocount - nsp_fifo_count(SCpnt);\r\nnsp_dbg(NSP_DEBUG_DATA_IO, "phase changed stat=0x%x, res=%d\n", stat, res);\r\nnsp_inc_resid(SCpnt, res);\r\nSCpnt->SCp.ptr -= res;\r\nSCpnt->SCp.this_residual += res;\r\nocount -= res;\r\nbreak;\r\n}\r\nres = ocount - nsp_fifo_count(SCpnt);\r\nif (res > 0) {\r\nnsp_dbg(NSP_DEBUG_DATA_IO, "wait for all data out. ocount=0x%x res=%d", ocount, res);\r\ncontinue;\r\n}\r\nres = min(SCpnt->SCp.this_residual, WFIFO_CRIT);\r\nswitch (data->TransferMode) {\r\ncase MODE_IO32:\r\nres &= ~(BIT(1)|BIT(0));\r\nnsp_fifo32_write(base, SCpnt->SCp.ptr, res >> 2);\r\nbreak;\r\ncase MODE_IO8:\r\nnsp_fifo8_write (base, SCpnt->SCp.ptr, res );\r\nbreak;\r\ncase MODE_MEM32:\r\nres &= ~(BIT(1)|BIT(0));\r\nnsp_mmio_fifo32_write(mmio_base, SCpnt->SCp.ptr, res >> 2);\r\nbreak;\r\ndefault:\r\nnsp_dbg(NSP_DEBUG_DATA_IO, "unknown write mode");\r\nbreak;\r\n}\r\nnsp_inc_resid(SCpnt, -res);\r\nSCpnt->SCp.ptr += res;\r\nSCpnt->SCp.this_residual -= res;\r\nocount += res;\r\nif (SCpnt->SCp.this_residual == 0 &&\r\nSCpnt->SCp.buffers_residual != 0 ) {\r\nSCpnt->SCp.buffers_residual--;\r\nSCpnt->SCp.buffer++;\r\nSCpnt->SCp.ptr = BUFFER_ADDR;\r\nSCpnt->SCp.this_residual = SCpnt->SCp.buffer->length;\r\ntime_out = 1000;\r\n}\r\n}\r\ndata->FifoCount = ocount;\r\nif (time_out < 0) {\r\nnsp_msg(KERN_DEBUG, "pio write timeout resid=0x%x",\r\nscsi_get_resid(SCpnt));\r\n}\r\nnsp_dbg(NSP_DEBUG_DATA_IO, "write ocount=0x%x", ocount);\r\nnsp_dbg(NSP_DEBUG_DATA_IO, "w cmd=%d resid=0x%x\n", data->CmdId,\r\nscsi_get_resid(SCpnt));\r\n}\r\nstatic int nsp_nexus(struct scsi_cmnd *SCpnt)\r\n{\r\nunsigned int base = SCpnt->device->host->io_port;\r\nunsigned char target = scmd_id(SCpnt);\r\nnsp_hw_data *data = (nsp_hw_data *)SCpnt->device->host->hostdata;\r\nsync_data *sync = &(data->Sync[target]);\r\nnsp_index_write(base, SYNCREG, sync->SyncRegister);\r\nnsp_index_write(base, ACKWIDTH, sync->AckWidth);\r\nif (scsi_get_resid(SCpnt) % 4 != 0 ||\r\nscsi_get_resid(SCpnt) <= PAGE_SIZE ) {\r\ndata->TransferMode = MODE_IO8;\r\n} else if (nsp_burst_mode == BURST_MEM32) {\r\ndata->TransferMode = MODE_MEM32;\r\n} else if (nsp_burst_mode == BURST_IO32) {\r\ndata->TransferMode = MODE_IO32;\r\n} else {\r\ndata->TransferMode = MODE_IO8;\r\n}\r\nnsp_setup_fifo(data, TRUE);\r\ndata->FifoCount = 0;\r\nnsp_index_write(base, POINTERCLR, POINTER_CLEAR |\r\nACK_COUNTER_CLEAR |\r\nREQ_COUNTER_CLEAR |\r\nHOST_COUNTER_CLEAR);\r\nreturn 0;\r\n}\r\nstatic irqreturn_t nspintr(int irq, void *dev_id)\r\n{\r\nunsigned int base;\r\nunsigned char irq_status, irq_phase, phase;\r\nstruct scsi_cmnd *tmpSC;\r\nunsigned char target, lun;\r\nunsigned int *sync_neg;\r\nint i, tmp;\r\nnsp_hw_data *data;\r\nif ( dev_id != NULL &&\r\n((scsi_info_t *)dev_id)->host != NULL ) {\r\nscsi_info_t *info = (scsi_info_t *)dev_id;\r\ndata = (nsp_hw_data *)info->host->hostdata;\r\n} else {\r\nnsp_dbg(NSP_DEBUG_INTR, "host data wrong");\r\nreturn IRQ_NONE;\r\n}\r\nbase = data->BaseAddress;\r\nnsp_write(base, IRQCONTROL, IRQCONTROL_IRQDISABLE);\r\nirq_status = nsp_read(base, IRQSTATUS);\r\nif ((irq_status == 0xff) || ((irq_status & IRQSTATUS_MASK) == 0)) {\r\nnsp_write(base, IRQCONTROL, 0);\r\nreturn IRQ_NONE;\r\n}\r\nphase = nsp_index_read(base, SCSIBUSMON);\r\nif((irq_status & IRQSTATUS_SCSI) != 0) {\r\nirq_phase = nsp_index_read(base, IRQPHASESENCE);\r\n} else {\r\nirq_phase = 0;\r\n}\r\nif (data->TimerCount != 0) {\r\nnsp_index_write(base, TIMERCOUNT, 0);\r\nnsp_index_write(base, TIMERCOUNT, 0);\r\ndata->TimerCount = 0;\r\n}\r\nif ((irq_status & IRQSTATUS_MASK) == IRQSTATUS_TIMER &&\r\ndata->SelectionTimeOut == 0) {\r\nnsp_write(base, IRQCONTROL, IRQCONTROL_TIMER_CLEAR);\r\nreturn IRQ_HANDLED;\r\n}\r\nnsp_write(base, IRQCONTROL, IRQCONTROL_TIMER_CLEAR | IRQCONTROL_FIFO_CLEAR);\r\nif ((irq_status & IRQSTATUS_SCSI) &&\r\n(irq_phase & SCSI_RESET_IRQ)) {\r\nnsp_msg(KERN_ERR, "bus reset (power off?)");\r\nnsphw_init(data);\r\nnsp_bus_reset(data);\r\nif(data->CurrentSC != NULL) {\r\ntmpSC = data->CurrentSC;\r\ntmpSC->result = (DID_RESET << 16) |\r\n((tmpSC->SCp.Message & 0xff) << 8) |\r\n((tmpSC->SCp.Status & 0xff) << 0);\r\nnsp_scsi_done(tmpSC);\r\n}\r\nreturn IRQ_HANDLED;\r\n}\r\nif (data->CurrentSC == NULL) {\r\nnsp_msg(KERN_ERR, "CurrentSC==NULL irq_status=0x%x phase=0x%x irq_phase=0x%x this can't be happen. reset everything", irq_status, phase, irq_phase);\r\nnsphw_init(data);\r\nnsp_bus_reset(data);\r\nreturn IRQ_HANDLED;\r\n}\r\ntmpSC = data->CurrentSC;\r\ntarget = tmpSC->device->id;\r\nlun = tmpSC->device->lun;\r\nsync_neg = &(data->Sync[target].SyncNegotiation);\r\nif (irq_status & IRQSTATUS_SCSI) {\r\nif (irq_phase & RESELECT_IRQ) {\r\nnsp_dbg(NSP_DEBUG_INTR, "reselect");\r\nnsp_write(base, IRQCONTROL, IRQCONTROL_RESELECT_CLEAR);\r\nif (nsp_reselected(tmpSC) != FALSE) {\r\nreturn IRQ_HANDLED;\r\n}\r\n}\r\nif ((irq_phase & (PHASE_CHANGE_IRQ | LATCHED_BUS_FREE)) == 0) {\r\nreturn IRQ_HANDLED;\r\n}\r\n}\r\nswitch(tmpSC->SCp.phase) {\r\ncase PH_SELSTART:\r\nif ((phase & BUSMON_BSY) == 0) {\r\nif (data->SelectionTimeOut >= NSP_SELTIMEOUT) {\r\nnsp_dbg(NSP_DEBUG_INTR, "selection time out");\r\ndata->SelectionTimeOut = 0;\r\nnsp_index_write(base, SCSIBUSCTRL, 0);\r\ntmpSC->result = DID_TIME_OUT << 16;\r\nnsp_scsi_done(tmpSC);\r\nreturn IRQ_HANDLED;\r\n}\r\ndata->SelectionTimeOut += 1;\r\nnsp_start_timer(tmpSC, 1000/51);\r\nreturn IRQ_HANDLED;\r\n}\r\ndata->SelectionTimeOut = 0;\r\ntmpSC->SCp.phase = PH_SELECTED;\r\nnsp_index_write(base, SCSIBUSCTRL, SCSI_ATN);\r\nudelay(1);\r\nnsp_index_write(base, SCSIBUSCTRL, SCSI_ATN | AUTODIRECTION | ACKENB);\r\nreturn IRQ_HANDLED;\r\nbreak;\r\ncase PH_RESELECT:\r\nif ((phase & BUSMON_PHASE_MASK) != BUSPHASE_MESSAGE_IN) {\r\ntmpSC->result = DID_ABORT << 16;\r\nnsp_scsi_done(tmpSC);\r\nreturn IRQ_HANDLED;\r\n}\r\ndefault:\r\nif ((irq_status & (IRQSTATUS_SCSI | IRQSTATUS_FIFO)) == 0) {\r\nreturn IRQ_HANDLED;\r\n}\r\nbreak;\r\n}\r\nif (((tmpSC->SCp.phase == PH_MSG_IN) || (tmpSC->SCp.phase == PH_MSG_OUT)) &&\r\n(irq_phase & LATCHED_BUS_FREE) != 0 ) {\r\nnsp_dbg(NSP_DEBUG_INTR, "normal disconnect irq_status=0x%x, phase=0x%x, irq_phase=0x%x", irq_status, phase, irq_phase);\r\nif ((tmpSC->SCp.Message == MSG_COMMAND_COMPLETE)) {\r\ntmpSC->result = (DID_OK << 16) |\r\n((tmpSC->SCp.Message & 0xff) << 8) |\r\n((tmpSC->SCp.Status & 0xff) << 0);\r\nnsp_dbg(NSP_DEBUG_INTR, "command complete result=0x%x", tmpSC->result);\r\nnsp_scsi_done(tmpSC);\r\nreturn IRQ_HANDLED;\r\n}\r\nreturn IRQ_HANDLED;\r\n}\r\nif (phase == 0) {\r\nnsp_msg(KERN_DEBUG, "unexpected bus free. irq_status=0x%x, phase=0x%x, irq_phase=0x%x", irq_status, phase, irq_phase);\r\n*sync_neg = SYNC_NG;\r\ntmpSC->result = DID_ERROR << 16;\r\nnsp_scsi_done(tmpSC);\r\nreturn IRQ_HANDLED;\r\n}\r\nswitch (phase & BUSMON_PHASE_MASK) {\r\ncase BUSPHASE_COMMAND:\r\nnsp_dbg(NSP_DEBUG_INTR, "BUSPHASE_COMMAND");\r\nif ((phase & BUSMON_REQ) == 0) {\r\nnsp_dbg(NSP_DEBUG_INTR, "REQ == 0");\r\nreturn IRQ_HANDLED;\r\n}\r\ntmpSC->SCp.phase = PH_COMMAND;\r\nnsp_nexus(tmpSC);\r\nnsp_dbg(NSP_DEBUG_INTR, "cmd_len=%d", tmpSC->cmd_len);\r\nnsp_index_write(base, COMMANDCTRL, CLEAR_COMMAND_POINTER);\r\nfor (i = 0; i < tmpSC->cmd_len; i++) {\r\nnsp_index_write(base, COMMANDDATA, tmpSC->cmnd[i]);\r\n}\r\nnsp_index_write(base, COMMANDCTRL, CLEAR_COMMAND_POINTER | AUTO_COMMAND_GO);\r\nbreak;\r\ncase BUSPHASE_DATA_OUT:\r\nnsp_dbg(NSP_DEBUG_INTR, "BUSPHASE_DATA_OUT");\r\ntmpSC->SCp.phase = PH_DATA;\r\ntmpSC->SCp.have_data_in = IO_OUT;\r\nnsp_pio_write(tmpSC);\r\nbreak;\r\ncase BUSPHASE_DATA_IN:\r\nnsp_dbg(NSP_DEBUG_INTR, "BUSPHASE_DATA_IN");\r\ntmpSC->SCp.phase = PH_DATA;\r\ntmpSC->SCp.have_data_in = IO_IN;\r\nnsp_pio_read(tmpSC);\r\nbreak;\r\ncase BUSPHASE_STATUS:\r\nnsp_dataphase_bypass(tmpSC);\r\nnsp_dbg(NSP_DEBUG_INTR, "BUSPHASE_STATUS");\r\ntmpSC->SCp.phase = PH_STATUS;\r\ntmpSC->SCp.Status = nsp_index_read(base, SCSIDATAWITHACK);\r\nnsp_dbg(NSP_DEBUG_INTR, "message=0x%x status=0x%x", tmpSC->SCp.Message, tmpSC->SCp.Status);\r\nbreak;\r\ncase BUSPHASE_MESSAGE_OUT:\r\nnsp_dbg(NSP_DEBUG_INTR, "BUSPHASE_MESSAGE_OUT");\r\nif ((phase & BUSMON_REQ) == 0) {\r\ngoto timer_out;\r\n}\r\ntmpSC->SCp.phase = PH_MSG_OUT;\r\ndata->MsgLen = i = 0;\r\ndata->MsgBuffer[i] = IDENTIFY(TRUE, lun); i++;\r\nif (*sync_neg == SYNC_NOT_YET) {\r\ndata->Sync[target].SyncPeriod = 0;\r\ndata->Sync[target].SyncOffset = 0;\r\ndata->MsgBuffer[i] = MSG_EXTENDED; i++;\r\ndata->MsgBuffer[i] = 3; i++;\r\ndata->MsgBuffer[i] = MSG_EXT_SDTR; i++;\r\ndata->MsgBuffer[i] = 0x0c; i++;\r\ndata->MsgBuffer[i] = 15; i++;\r\n}\r\ndata->MsgLen = i;\r\nnsp_analyze_sdtr(tmpSC);\r\nshow_message(data);\r\nnsp_message_out(tmpSC);\r\nbreak;\r\ncase BUSPHASE_MESSAGE_IN:\r\nnsp_dataphase_bypass(tmpSC);\r\nnsp_dbg(NSP_DEBUG_INTR, "BUSPHASE_MESSAGE_IN");\r\nif ((phase & BUSMON_REQ) == 0) {\r\ngoto timer_out;\r\n}\r\ntmpSC->SCp.phase = PH_MSG_IN;\r\nnsp_message_in(tmpSC);\r\nif (*sync_neg == SYNC_NOT_YET) {\r\nif (data->MsgLen >= 5 &&\r\ndata->MsgBuffer[0] == MSG_EXTENDED &&\r\ndata->MsgBuffer[1] == 3 &&\r\ndata->MsgBuffer[2] == MSG_EXT_SDTR ) {\r\ndata->Sync[target].SyncPeriod = data->MsgBuffer[3];\r\ndata->Sync[target].SyncOffset = data->MsgBuffer[4];\r\n*sync_neg = SYNC_OK;\r\n} else {\r\ndata->Sync[target].SyncPeriod = 0;\r\ndata->Sync[target].SyncOffset = 0;\r\n*sync_neg = SYNC_NG;\r\n}\r\nnsp_analyze_sdtr(tmpSC);\r\n}\r\ntmp = -1;\r\nfor (i = 0; i < data->MsgLen; i++) {\r\ntmp = data->MsgBuffer[i];\r\nif (data->MsgBuffer[i] == MSG_EXTENDED) {\r\ni += (1 + data->MsgBuffer[i+1]);\r\n}\r\n}\r\ntmpSC->SCp.Message = tmp;\r\nnsp_dbg(NSP_DEBUG_INTR, "message=0x%x len=%d", tmpSC->SCp.Message, data->MsgLen);\r\nshow_message(data);\r\nbreak;\r\ncase BUSPHASE_SELECT:\r\ndefault:\r\nnsp_dbg(NSP_DEBUG_INTR, "BUSPHASE other");\r\nbreak;\r\n}\r\nreturn IRQ_HANDLED;\r\ntimer_out:\r\nnsp_start_timer(tmpSC, 1000/102);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic struct Scsi_Host *nsp_detect(struct scsi_host_template *sht)\r\n{\r\nstruct Scsi_Host *host;\r\nnsp_hw_data *data_b = &nsp_data_base, *data;\r\nnsp_dbg(NSP_DEBUG_INIT, "this_id=%d", sht->this_id);\r\nhost = scsi_host_alloc(&nsp_driver_template, sizeof(nsp_hw_data));\r\nif (host == NULL) {\r\nnsp_dbg(NSP_DEBUG_INIT, "host failed");\r\nreturn NULL;\r\n}\r\nmemcpy(host->hostdata, data_b, sizeof(nsp_hw_data));\r\ndata = (nsp_hw_data *)host->hostdata;\r\ndata->ScsiInfo->host = host;\r\n#ifdef NSP_DEBUG\r\ndata->CmdId = 0;\r\n#endif\r\nnsp_dbg(NSP_DEBUG_INIT, "irq=%d,%d", data_b->IrqNumber, ((nsp_hw_data *)host->hostdata)->IrqNumber);\r\nhost->unique_id = data->BaseAddress;\r\nhost->io_port = data->BaseAddress;\r\nhost->n_io_port = data->NumAddress;\r\nhost->irq = data->IrqNumber;\r\nhost->base = data->MmioAddress;\r\nspin_lock_init(&(data->Lock));\r\nsnprintf(data->nspinfo,\r\nsizeof(data->nspinfo),\r\n"NinjaSCSI-3/32Bi Driver $Revision: 1.23 $ IO:0x%04lx-0x%04lx MMIO(virt addr):0x%04lx IRQ:%02d",\r\nhost->io_port, host->io_port + host->n_io_port - 1,\r\nhost->base,\r\nhost->irq);\r\nsht->name = data->nspinfo;\r\nnsp_dbg(NSP_DEBUG_INIT, "end");\r\nreturn host;\r\n}\r\nstatic const char *nsp_info(struct Scsi_Host *shpnt)\r\n{\r\nnsp_hw_data *data = (nsp_hw_data *)shpnt->hostdata;\r\nreturn data->nspinfo;\r\n}\r\nstatic int nsp_show_info(struct seq_file *m, struct Scsi_Host *host)\r\n{\r\nint id;\r\nint speed;\r\nunsigned long flags;\r\nnsp_hw_data *data;\r\nint hostno;\r\nhostno = host->host_no;\r\ndata = (nsp_hw_data *)host->hostdata;\r\nseq_puts(m, "NinjaSCSI status\n\n"\r\n"Driver version: $Revision: 1.23 $\n");\r\nseq_printf(m, "SCSI host No.: %d\n", hostno);\r\nseq_printf(m, "IRQ: %d\n", host->irq);\r\nseq_printf(m, "IO: 0x%lx-0x%lx\n", host->io_port, host->io_port + host->n_io_port - 1);\r\nseq_printf(m, "MMIO(virtual address): 0x%lx-0x%lx\n", host->base, host->base + data->MmioLength - 1);\r\nseq_printf(m, "sg_tablesize: %d\n", host->sg_tablesize);\r\nseq_puts(m, "burst transfer mode: ");\r\nswitch (nsp_burst_mode) {\r\ncase BURST_IO8:\r\nseq_puts(m, "io8");\r\nbreak;\r\ncase BURST_IO32:\r\nseq_puts(m, "io32");\r\nbreak;\r\ncase BURST_MEM32:\r\nseq_puts(m, "mem32");\r\nbreak;\r\ndefault:\r\nseq_puts(m, "???");\r\nbreak;\r\n}\r\nseq_putc(m, '\n');\r\nspin_lock_irqsave(&(data->Lock), flags);\r\nseq_printf(m, "CurrentSC: 0x%p\n\n", data->CurrentSC);\r\nspin_unlock_irqrestore(&(data->Lock), flags);\r\nseq_puts(m, "SDTR status\n");\r\nfor(id = 0; id < ARRAY_SIZE(data->Sync); id++) {\r\nseq_printf(m, "id %d: ", id);\r\nif (id == host->this_id) {\r\nseq_puts(m, "----- NinjaSCSI-3 host adapter\n");\r\ncontinue;\r\n}\r\nswitch(data->Sync[id].SyncNegotiation) {\r\ncase SYNC_OK:\r\nseq_puts(m, " sync");\r\nbreak;\r\ncase SYNC_NG:\r\nseq_puts(m, "async");\r\nbreak;\r\ncase SYNC_NOT_YET:\r\nseq_puts(m, " none");\r\nbreak;\r\ndefault:\r\nseq_puts(m, "?????");\r\nbreak;\r\n}\r\nif (data->Sync[id].SyncPeriod != 0) {\r\nspeed = 1000000 / (data->Sync[id].SyncPeriod * 4);\r\nseq_printf(m, " transfer %d.%dMB/s, offset %d",\r\nspeed / 1000,\r\nspeed % 1000,\r\ndata->Sync[id].SyncOffset\r\n);\r\n}\r\nseq_putc(m, '\n');\r\n}\r\nreturn 0;\r\n}\r\nstatic int nsp_bus_reset(nsp_hw_data *data)\r\n{\r\nunsigned int base = data->BaseAddress;\r\nint i;\r\nnsp_write(base, IRQCONTROL, IRQCONTROL_ALLMASK);\r\nnsp_index_write(base, SCSIBUSCTRL, SCSI_RST);\r\nmdelay(100);\r\nnsp_index_write(base, SCSIBUSCTRL, 0);\r\nfor(i = 0; i < 5; i++) {\r\nnsp_index_read(base, IRQPHASESENCE);\r\n}\r\nnsphw_init_sync(data);\r\nnsp_write(base, IRQCONTROL, IRQCONTROL_ALLCLEAR);\r\nreturn SUCCESS;\r\n}\r\nstatic int nsp_eh_bus_reset(struct scsi_cmnd *SCpnt)\r\n{\r\nnsp_hw_data *data = (nsp_hw_data *)SCpnt->device->host->hostdata;\r\nnsp_dbg(NSP_DEBUG_BUSRESET, "SCpnt=0x%p", SCpnt);\r\nreturn nsp_bus_reset(data);\r\n}\r\nstatic int nsp_eh_host_reset(struct scsi_cmnd *SCpnt)\r\n{\r\nnsp_hw_data *data = (nsp_hw_data *)SCpnt->device->host->hostdata;\r\nnsp_dbg(NSP_DEBUG_BUSRESET, "in");\r\nnsphw_init(data);\r\nreturn SUCCESS;\r\n}\r\nstatic int nsp_cs_probe(struct pcmcia_device *link)\r\n{\r\nscsi_info_t *info;\r\nnsp_hw_data *data = &nsp_data_base;\r\nint ret;\r\nnsp_dbg(NSP_DEBUG_INIT, "in");\r\ninfo = kzalloc(sizeof(*info), GFP_KERNEL);\r\nif (info == NULL) { return -ENOMEM; }\r\ninfo->p_dev = link;\r\nlink->priv = info;\r\ndata->ScsiInfo = info;\r\nnsp_dbg(NSP_DEBUG_INIT, "info=0x%p", info);\r\nret = nsp_cs_config(link);\r\nnsp_dbg(NSP_DEBUG_INIT, "link=0x%p", link);\r\nreturn ret;\r\n}\r\nstatic void nsp_cs_detach(struct pcmcia_device *link)\r\n{\r\nnsp_dbg(NSP_DEBUG_INIT, "in, link=0x%p", link);\r\n((scsi_info_t *)link->priv)->stop = 1;\r\nnsp_cs_release(link);\r\nkfree(link->priv);\r\nlink->priv = NULL;\r\n}\r\nstatic int nsp_cs_config_check(struct pcmcia_device *p_dev, void *priv_data)\r\n{\r\nnsp_hw_data *data = priv_data;\r\nif (p_dev->config_index == 0)\r\nreturn -ENODEV;\r\nif (pcmcia_request_io(p_dev) != 0)\r\ngoto next_entry;\r\nif (resource_size(p_dev->resource[2])) {\r\np_dev->resource[2]->flags |= (WIN_DATA_WIDTH_16 |\r\nWIN_MEMORY_TYPE_CM |\r\nWIN_ENABLE);\r\nif (p_dev->resource[2]->end < 0x1000)\r\np_dev->resource[2]->end = 0x1000;\r\nif (pcmcia_request_window(p_dev, p_dev->resource[2], 0) != 0)\r\ngoto next_entry;\r\nif (pcmcia_map_mem_page(p_dev, p_dev->resource[2],\r\np_dev->card_addr) != 0)\r\ngoto next_entry;\r\ndata->MmioAddress = (unsigned long)\r\nioremap_nocache(p_dev->resource[2]->start,\r\nresource_size(p_dev->resource[2]));\r\ndata->MmioLength = resource_size(p_dev->resource[2]);\r\n}\r\nreturn 0;\r\nnext_entry:\r\nnsp_dbg(NSP_DEBUG_INIT, "next");\r\npcmcia_disable_device(p_dev);\r\nreturn -ENODEV;\r\n}\r\nstatic int nsp_cs_config(struct pcmcia_device *link)\r\n{\r\nint ret;\r\nscsi_info_t *info = link->priv;\r\nstruct Scsi_Host *host;\r\nnsp_hw_data *data = &nsp_data_base;\r\nnsp_dbg(NSP_DEBUG_INIT, "in");\r\nlink->config_flags |= CONF_ENABLE_IRQ | CONF_AUTO_CHECK_VCC |\r\nCONF_AUTO_SET_VPP | CONF_AUTO_AUDIO | CONF_AUTO_SET_IOMEM |\r\nCONF_AUTO_SET_IO;\r\nret = pcmcia_loop_config(link, nsp_cs_config_check, data);\r\nif (ret)\r\ngoto cs_failed;\r\nif (pcmcia_request_irq(link, nspintr))\r\ngoto cs_failed;\r\nret = pcmcia_enable_device(link);\r\nif (ret)\r\ngoto cs_failed;\r\nif (free_ports) {\r\nif (link->resource[0]) {\r\nrelease_region(link->resource[0]->start,\r\nresource_size(link->resource[0]));\r\n}\r\nif (link->resource[1]) {\r\nrelease_region(link->resource[1]->start,\r\nresource_size(link->resource[1]));\r\n}\r\n}\r\ndata->BaseAddress = link->resource[0]->start;\r\ndata->NumAddress = resource_size(link->resource[0]);\r\ndata->IrqNumber = link->irq;\r\nnsp_dbg(NSP_DEBUG_INIT, "I/O[0x%x+0x%x] IRQ %d",\r\ndata->BaseAddress, data->NumAddress, data->IrqNumber);\r\nif(nsphw_init(data) == FALSE) {\r\ngoto cs_failed;\r\n}\r\nhost = nsp_detect(&nsp_driver_template);\r\nif (host == NULL) {\r\nnsp_dbg(NSP_DEBUG_INIT, "detect failed");\r\ngoto cs_failed;\r\n}\r\nret = scsi_add_host (host, NULL);\r\nif (ret)\r\ngoto cs_failed;\r\nscsi_scan_host(host);\r\ninfo->host = host;\r\nreturn 0;\r\ncs_failed:\r\nnsp_dbg(NSP_DEBUG_INIT, "config fail");\r\nnsp_cs_release(link);\r\nreturn -ENODEV;\r\n}\r\nstatic void nsp_cs_release(struct pcmcia_device *link)\r\n{\r\nscsi_info_t *info = link->priv;\r\nnsp_hw_data *data = NULL;\r\nif (info->host == NULL) {\r\nnsp_msg(KERN_DEBUG, "unexpected card release call.");\r\n} else {\r\ndata = (nsp_hw_data *)info->host->hostdata;\r\n}\r\nnsp_dbg(NSP_DEBUG_INIT, "link=0x%p", link);\r\nif (info->host != NULL) {\r\nscsi_remove_host(info->host);\r\n}\r\nif (resource_size(link->resource[2])) {\r\nif (data != NULL) {\r\niounmap((void *)(data->MmioAddress));\r\n}\r\n}\r\npcmcia_disable_device(link);\r\nif (info->host != NULL) {\r\nscsi_host_put(info->host);\r\n}\r\n}\r\nstatic int nsp_cs_suspend(struct pcmcia_device *link)\r\n{\r\nscsi_info_t *info = link->priv;\r\nnsp_hw_data *data;\r\nnsp_dbg(NSP_DEBUG_INIT, "event: suspend");\r\nif (info->host != NULL) {\r\nnsp_msg(KERN_INFO, "clear SDTR status");\r\ndata = (nsp_hw_data *)info->host->hostdata;\r\nnsphw_init_sync(data);\r\n}\r\ninfo->stop = 1;\r\nreturn 0;\r\n}\r\nstatic int nsp_cs_resume(struct pcmcia_device *link)\r\n{\r\nscsi_info_t *info = link->priv;\r\nnsp_hw_data *data;\r\nnsp_dbg(NSP_DEBUG_INIT, "event: resume");\r\ninfo->stop = 0;\r\nif (info->host != NULL) {\r\nnsp_msg(KERN_INFO, "reset host and bus");\r\ndata = (nsp_hw_data *)info->host->hostdata;\r\nnsphw_init (data);\r\nnsp_bus_reset(data);\r\n}\r\nreturn 0;\r\n}\r\nstatic int __init nsp_cs_init(void)\r\n{\r\nreturn pcmcia_register_driver(&nsp_driver);\r\n}\r\nstatic void __exit nsp_cs_exit(void)\r\n{\r\npcmcia_unregister_driver(&nsp_driver);\r\n}
