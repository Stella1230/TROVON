static void print_open_warning(int err, bool uprobe)\r\n{\r\nchar sbuf[STRERR_BUFSIZE];\r\nif (err == -ENOENT) {\r\nconst char *config;\r\nif (uprobe)\r\nconfig = "CONFIG_UPROBE_EVENTS";\r\nelse\r\nconfig = "CONFIG_KPROBE_EVENTS";\r\npr_warning("%cprobe_events file does not exist"\r\n" - please rebuild kernel with %s.\n",\r\nuprobe ? 'u' : 'k', config);\r\n} else if (err == -ENOTSUP)\r\npr_warning("Tracefs or debugfs is not mounted.\n");\r\nelse\r\npr_warning("Failed to open %cprobe_events: %s\n",\r\nuprobe ? 'u' : 'k',\r\nstrerror_r(-err, sbuf, sizeof(sbuf)));\r\n}\r\nstatic void print_both_open_warning(int kerr, int uerr)\r\n{\r\nif (kerr == -ENOTSUP && uerr == -ENOTSUP)\r\npr_warning("Tracefs or debugfs is not mounted.\n");\r\nelse if (kerr == -ENOENT && uerr == -ENOENT)\r\npr_warning("Please rebuild kernel with CONFIG_KPROBE_EVENTS "\r\n"or/and CONFIG_UPROBE_EVENTS.\n");\r\nelse {\r\nchar sbuf[STRERR_BUFSIZE];\r\npr_warning("Failed to open kprobe events: %s.\n",\r\nstrerror_r(-kerr, sbuf, sizeof(sbuf)));\r\npr_warning("Failed to open uprobe events: %s.\n",\r\nstrerror_r(-uerr, sbuf, sizeof(sbuf)));\r\n}\r\n}\r\nstatic int open_probe_events(const char *trace_file, bool readwrite)\r\n{\r\nchar buf[PATH_MAX];\r\nconst char *tracing_dir = "";\r\nint ret;\r\nret = e_snprintf(buf, PATH_MAX, "%s/%s%s",\r\ntracing_path, tracing_dir, trace_file);\r\nif (ret >= 0) {\r\npr_debug("Opening %s write=%d\n", buf, readwrite);\r\nif (readwrite && !probe_event_dry_run)\r\nret = open(buf, O_RDWR | O_APPEND, 0);\r\nelse\r\nret = open(buf, O_RDONLY, 0);\r\nif (ret < 0)\r\nret = -errno;\r\n}\r\nreturn ret;\r\n}\r\nstatic int open_kprobe_events(bool readwrite)\r\n{\r\nreturn open_probe_events("kprobe_events", readwrite);\r\n}\r\nstatic int open_uprobe_events(bool readwrite)\r\n{\r\nreturn open_probe_events("uprobe_events", readwrite);\r\n}\r\nint probe_file__open(int flag)\r\n{\r\nint fd;\r\nif (flag & PF_FL_UPROBE)\r\nfd = open_uprobe_events(flag & PF_FL_RW);\r\nelse\r\nfd = open_kprobe_events(flag & PF_FL_RW);\r\nif (fd < 0)\r\nprint_open_warning(fd, flag & PF_FL_UPROBE);\r\nreturn fd;\r\n}\r\nint probe_file__open_both(int *kfd, int *ufd, int flag)\r\n{\r\nif (!kfd || !ufd)\r\nreturn -EINVAL;\r\n*kfd = open_kprobe_events(flag & PF_FL_RW);\r\n*ufd = open_uprobe_events(flag & PF_FL_RW);\r\nif (*kfd < 0 && *ufd < 0) {\r\nprint_both_open_warning(*kfd, *ufd);\r\nreturn *kfd;\r\n}\r\nreturn 0;\r\n}\r\nstruct strlist *probe_file__get_rawlist(int fd)\r\n{\r\nint ret, idx;\r\nFILE *fp;\r\nchar buf[MAX_CMDLEN];\r\nchar *p;\r\nstruct strlist *sl;\r\nif (fd < 0)\r\nreturn NULL;\r\nsl = strlist__new(NULL, NULL);\r\nfp = fdopen(dup(fd), "r");\r\nwhile (!feof(fp)) {\r\np = fgets(buf, MAX_CMDLEN, fp);\r\nif (!p)\r\nbreak;\r\nidx = strlen(p) - 1;\r\nif (p[idx] == '\n')\r\np[idx] = '\0';\r\nret = strlist__add(sl, buf);\r\nif (ret < 0) {\r\npr_debug("strlist__add failed (%d)\n", ret);\r\nstrlist__delete(sl);\r\nreturn NULL;\r\n}\r\n}\r\nfclose(fp);\r\nreturn sl;\r\n}\r\nstatic struct strlist *__probe_file__get_namelist(int fd, bool include_group)\r\n{\r\nchar buf[128];\r\nstruct strlist *sl, *rawlist;\r\nstruct str_node *ent;\r\nstruct probe_trace_event tev;\r\nint ret = 0;\r\nmemset(&tev, 0, sizeof(tev));\r\nrawlist = probe_file__get_rawlist(fd);\r\nif (!rawlist)\r\nreturn NULL;\r\nsl = strlist__new(NULL, NULL);\r\nstrlist__for_each(ent, rawlist) {\r\nret = parse_probe_trace_command(ent->s, &tev);\r\nif (ret < 0)\r\nbreak;\r\nif (include_group) {\r\nret = e_snprintf(buf, 128, "%s:%s", tev.group,\r\ntev.event);\r\nif (ret >= 0)\r\nret = strlist__add(sl, buf);\r\n} else\r\nret = strlist__add(sl, tev.event);\r\nclear_probe_trace_event(&tev);\r\nif (ret < 0)\r\nbreak;\r\n}\r\nstrlist__delete(rawlist);\r\nif (ret < 0) {\r\nstrlist__delete(sl);\r\nreturn NULL;\r\n}\r\nreturn sl;\r\n}\r\nstruct strlist *probe_file__get_namelist(int fd)\r\n{\r\nreturn __probe_file__get_namelist(fd, false);\r\n}\r\nint probe_file__add_event(int fd, struct probe_trace_event *tev)\r\n{\r\nint ret = 0;\r\nchar *buf = synthesize_probe_trace_command(tev);\r\nchar sbuf[STRERR_BUFSIZE];\r\nif (!buf) {\r\npr_debug("Failed to synthesize probe trace event.\n");\r\nreturn -EINVAL;\r\n}\r\npr_debug("Writing event: %s\n", buf);\r\nif (!probe_event_dry_run) {\r\nret = write(fd, buf, strlen(buf));\r\nif (ret <= 0) {\r\nret = -errno;\r\npr_warning("Failed to write event: %s\n",\r\nstrerror_r(errno, sbuf, sizeof(sbuf)));\r\n}\r\n}\r\nfree(buf);\r\nreturn ret;\r\n}\r\nstatic int __del_trace_probe_event(int fd, struct str_node *ent)\r\n{\r\nchar *p;\r\nchar buf[128];\r\nint ret;\r\nret = e_snprintf(buf, 128, "-:%s", ent->s);\r\nif (ret < 0)\r\ngoto error;\r\np = strchr(buf + 2, ':');\r\nif (!p) {\r\npr_debug("Internal error: %s should have ':' but not.\n",\r\nent->s);\r\nret = -ENOTSUP;\r\ngoto error;\r\n}\r\n*p = '/';\r\npr_debug("Writing event: %s\n", buf);\r\nret = write(fd, buf, strlen(buf));\r\nif (ret < 0) {\r\nret = -errno;\r\ngoto error;\r\n}\r\nreturn 0;\r\nerror:\r\npr_warning("Failed to delete event: %s\n",\r\nstrerror_r(-ret, buf, sizeof(buf)));\r\nreturn ret;\r\n}\r\nint probe_file__get_events(int fd, struct strfilter *filter,\r\nstruct strlist *plist)\r\n{\r\nstruct strlist *namelist;\r\nstruct str_node *ent;\r\nconst char *p;\r\nint ret = -ENOENT;\r\nif (!plist)\r\nreturn -EINVAL;\r\nnamelist = __probe_file__get_namelist(fd, true);\r\nif (!namelist)\r\nreturn -ENOENT;\r\nstrlist__for_each(ent, namelist) {\r\np = strchr(ent->s, ':');\r\nif ((p && strfilter__compare(filter, p + 1)) ||\r\nstrfilter__compare(filter, ent->s)) {\r\nstrlist__add(plist, ent->s);\r\nret = 0;\r\n}\r\n}\r\nstrlist__delete(namelist);\r\nreturn ret;\r\n}\r\nint probe_file__del_strlist(int fd, struct strlist *namelist)\r\n{\r\nint ret = 0;\r\nstruct str_node *ent;\r\nstrlist__for_each(ent, namelist) {\r\nret = __del_trace_probe_event(fd, ent);\r\nif (ret < 0)\r\nbreak;\r\n}\r\nreturn ret;\r\n}\r\nint probe_file__del_events(int fd, struct strfilter *filter)\r\n{\r\nstruct strlist *namelist;\r\nint ret;\r\nnamelist = strlist__new(NULL, NULL);\r\nif (!namelist)\r\nreturn -ENOMEM;\r\nret = probe_file__get_events(fd, filter, namelist);\r\nif (ret < 0)\r\nreturn ret;\r\nret = probe_file__del_strlist(fd, namelist);\r\nstrlist__delete(namelist);\r\nreturn ret;\r\n}
