static inline void *align_ptr(void *p, unsigned int align)\r\n{\r\nreturn (void *)ALIGN((unsigned long)p, align);\r\n}\r\nstatic inline struct hmac_ctx *hmac_ctx(struct crypto_shash *tfm)\r\n{\r\nreturn align_ptr(crypto_shash_ctx_aligned(tfm) +\r\ncrypto_shash_statesize(tfm) * 2,\r\ncrypto_tfm_ctx_alignment());\r\n}\r\nstatic int hmac_setkey(struct crypto_shash *parent,\r\nconst u8 *inkey, unsigned int keylen)\r\n{\r\nint bs = crypto_shash_blocksize(parent);\r\nint ds = crypto_shash_digestsize(parent);\r\nint ss = crypto_shash_statesize(parent);\r\nchar *ipad = crypto_shash_ctx_aligned(parent);\r\nchar *opad = ipad + ss;\r\nstruct hmac_ctx *ctx = align_ptr(opad + ss,\r\ncrypto_tfm_ctx_alignment());\r\nstruct crypto_shash *hash = ctx->hash;\r\nSHASH_DESC_ON_STACK(shash, hash);\r\nunsigned int i;\r\nshash->tfm = hash;\r\nshash->flags = crypto_shash_get_flags(parent)\r\n& CRYPTO_TFM_REQ_MAY_SLEEP;\r\nif (keylen > bs) {\r\nint err;\r\nerr = crypto_shash_digest(shash, inkey, keylen, ipad);\r\nif (err)\r\nreturn err;\r\nkeylen = ds;\r\n} else\r\nmemcpy(ipad, inkey, keylen);\r\nmemset(ipad + keylen, 0, bs - keylen);\r\nmemcpy(opad, ipad, bs);\r\nfor (i = 0; i < bs; i++) {\r\nipad[i] ^= 0x36;\r\nopad[i] ^= 0x5c;\r\n}\r\nreturn crypto_shash_init(shash) ?:\r\ncrypto_shash_update(shash, ipad, bs) ?:\r\ncrypto_shash_export(shash, ipad) ?:\r\ncrypto_shash_init(shash) ?:\r\ncrypto_shash_update(shash, opad, bs) ?:\r\ncrypto_shash_export(shash, opad);\r\n}\r\nstatic int hmac_export(struct shash_desc *pdesc, void *out)\r\n{\r\nstruct shash_desc *desc = shash_desc_ctx(pdesc);\r\ndesc->flags = pdesc->flags & CRYPTO_TFM_REQ_MAY_SLEEP;\r\nreturn crypto_shash_export(desc, out);\r\n}\r\nstatic int hmac_import(struct shash_desc *pdesc, const void *in)\r\n{\r\nstruct shash_desc *desc = shash_desc_ctx(pdesc);\r\nstruct hmac_ctx *ctx = hmac_ctx(pdesc->tfm);\r\ndesc->tfm = ctx->hash;\r\ndesc->flags = pdesc->flags & CRYPTO_TFM_REQ_MAY_SLEEP;\r\nreturn crypto_shash_import(desc, in);\r\n}\r\nstatic int hmac_init(struct shash_desc *pdesc)\r\n{\r\nreturn hmac_import(pdesc, crypto_shash_ctx_aligned(pdesc->tfm));\r\n}\r\nstatic int hmac_update(struct shash_desc *pdesc,\r\nconst u8 *data, unsigned int nbytes)\r\n{\r\nstruct shash_desc *desc = shash_desc_ctx(pdesc);\r\ndesc->flags = pdesc->flags & CRYPTO_TFM_REQ_MAY_SLEEP;\r\nreturn crypto_shash_update(desc, data, nbytes);\r\n}\r\nstatic int hmac_final(struct shash_desc *pdesc, u8 *out)\r\n{\r\nstruct crypto_shash *parent = pdesc->tfm;\r\nint ds = crypto_shash_digestsize(parent);\r\nint ss = crypto_shash_statesize(parent);\r\nchar *opad = crypto_shash_ctx_aligned(parent) + ss;\r\nstruct shash_desc *desc = shash_desc_ctx(pdesc);\r\ndesc->flags = pdesc->flags & CRYPTO_TFM_REQ_MAY_SLEEP;\r\nreturn crypto_shash_final(desc, out) ?:\r\ncrypto_shash_import(desc, opad) ?:\r\ncrypto_shash_finup(desc, out, ds, out);\r\n}\r\nstatic int hmac_finup(struct shash_desc *pdesc, const u8 *data,\r\nunsigned int nbytes, u8 *out)\r\n{\r\nstruct crypto_shash *parent = pdesc->tfm;\r\nint ds = crypto_shash_digestsize(parent);\r\nint ss = crypto_shash_statesize(parent);\r\nchar *opad = crypto_shash_ctx_aligned(parent) + ss;\r\nstruct shash_desc *desc = shash_desc_ctx(pdesc);\r\ndesc->flags = pdesc->flags & CRYPTO_TFM_REQ_MAY_SLEEP;\r\nreturn crypto_shash_finup(desc, data, nbytes, out) ?:\r\ncrypto_shash_import(desc, opad) ?:\r\ncrypto_shash_finup(desc, out, ds, out);\r\n}\r\nstatic int hmac_init_tfm(struct crypto_tfm *tfm)\r\n{\r\nstruct crypto_shash *parent = __crypto_shash_cast(tfm);\r\nstruct crypto_shash *hash;\r\nstruct crypto_instance *inst = (void *)tfm->__crt_alg;\r\nstruct crypto_shash_spawn *spawn = crypto_instance_ctx(inst);\r\nstruct hmac_ctx *ctx = hmac_ctx(parent);\r\nhash = crypto_spawn_shash(spawn);\r\nif (IS_ERR(hash))\r\nreturn PTR_ERR(hash);\r\nparent->descsize = sizeof(struct shash_desc) +\r\ncrypto_shash_descsize(hash);\r\nctx->hash = hash;\r\nreturn 0;\r\n}\r\nstatic void hmac_exit_tfm(struct crypto_tfm *tfm)\r\n{\r\nstruct hmac_ctx *ctx = hmac_ctx(__crypto_shash_cast(tfm));\r\ncrypto_free_shash(ctx->hash);\r\n}\r\nstatic int hmac_create(struct crypto_template *tmpl, struct rtattr **tb)\r\n{\r\nstruct shash_instance *inst;\r\nstruct crypto_alg *alg;\r\nstruct shash_alg *salg;\r\nint err;\r\nint ds;\r\nint ss;\r\nerr = crypto_check_attr_type(tb, CRYPTO_ALG_TYPE_SHASH);\r\nif (err)\r\nreturn err;\r\nsalg = shash_attr_alg(tb[1], 0, 0);\r\nif (IS_ERR(salg))\r\nreturn PTR_ERR(salg);\r\nerr = -EINVAL;\r\nds = salg->digestsize;\r\nss = salg->statesize;\r\nalg = &salg->base;\r\nif (ds > alg->cra_blocksize ||\r\nss < alg->cra_blocksize)\r\ngoto out_put_alg;\r\ninst = shash_alloc_instance("hmac", alg);\r\nerr = PTR_ERR(inst);\r\nif (IS_ERR(inst))\r\ngoto out_put_alg;\r\nerr = crypto_init_shash_spawn(shash_instance_ctx(inst), salg,\r\nshash_crypto_instance(inst));\r\nif (err)\r\ngoto out_free_inst;\r\ninst->alg.base.cra_priority = alg->cra_priority;\r\ninst->alg.base.cra_blocksize = alg->cra_blocksize;\r\ninst->alg.base.cra_alignmask = alg->cra_alignmask;\r\nss = ALIGN(ss, alg->cra_alignmask + 1);\r\ninst->alg.digestsize = ds;\r\ninst->alg.statesize = ss;\r\ninst->alg.base.cra_ctxsize = sizeof(struct hmac_ctx) +\r\nALIGN(ss * 2, crypto_tfm_ctx_alignment());\r\ninst->alg.base.cra_init = hmac_init_tfm;\r\ninst->alg.base.cra_exit = hmac_exit_tfm;\r\ninst->alg.init = hmac_init;\r\ninst->alg.update = hmac_update;\r\ninst->alg.final = hmac_final;\r\ninst->alg.finup = hmac_finup;\r\ninst->alg.export = hmac_export;\r\ninst->alg.import = hmac_import;\r\ninst->alg.setkey = hmac_setkey;\r\nerr = shash_register_instance(tmpl, inst);\r\nif (err) {\r\nout_free_inst:\r\nshash_free_instance(shash_crypto_instance(inst));\r\n}\r\nout_put_alg:\r\ncrypto_mod_put(alg);\r\nreturn err;\r\n}\r\nstatic int __init hmac_module_init(void)\r\n{\r\nreturn crypto_register_template(&hmac_tmpl);\r\n}\r\nstatic void __exit hmac_module_exit(void)\r\n{\r\ncrypto_unregister_template(&hmac_tmpl);\r\n}
