int\r\ni915_verify_lists(struct drm_device *dev)\r\n{\r\nstatic int warned;\r\nstruct drm_i915_private *dev_priv = to_i915(dev);\r\nstruct drm_i915_gem_object *obj;\r\nstruct intel_engine_cs *ring;\r\nint err = 0;\r\nint i;\r\nif (warned)\r\nreturn 0;\r\nfor_each_ring(ring, dev_priv, i) {\r\nlist_for_each_entry(obj, &ring->active_list, ring_list[ring->id]) {\r\nif (obj->base.dev != dev ||\r\n!atomic_read(&obj->base.refcount.refcount)) {\r\nDRM_ERROR("%s: freed active obj %p\n",\r\nring->name, obj);\r\nerr++;\r\nbreak;\r\n} else if (!obj->active ||\r\nobj->last_read_req[ring->id] == NULL) {\r\nDRM_ERROR("%s: invalid active obj %p\n",\r\nring->name, obj);\r\nerr++;\r\n} else if (obj->base.write_domain) {\r\nDRM_ERROR("%s: invalid write obj %p (w %x)\n",\r\nring->name,\r\nobj, obj->base.write_domain);\r\nerr++;\r\n}\r\n}\r\n}\r\nreturn warned = err;\r\n}
