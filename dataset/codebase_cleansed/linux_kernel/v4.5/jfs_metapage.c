static inline void unlock_metapage(struct metapage *mp)\r\n{\r\nclear_bit_unlock(META_locked, &mp->flag);\r\nwake_up(&mp->wait);\r\n}\r\nstatic inline void __lock_metapage(struct metapage *mp)\r\n{\r\nDECLARE_WAITQUEUE(wait, current);\r\nINCREMENT(mpStat.lockwait);\r\nadd_wait_queue_exclusive(&mp->wait, &wait);\r\ndo {\r\nset_current_state(TASK_UNINTERRUPTIBLE);\r\nif (metapage_locked(mp)) {\r\nunlock_page(mp->page);\r\nio_schedule();\r\nlock_page(mp->page);\r\n}\r\n} while (trylock_metapage(mp));\r\n__set_current_state(TASK_RUNNING);\r\nremove_wait_queue(&mp->wait, &wait);\r\n}\r\nstatic inline void lock_metapage(struct metapage *mp)\r\n{\r\nif (trylock_metapage(mp))\r\n__lock_metapage(mp);\r\n}\r\nstatic inline struct metapage *page_to_mp(struct page *page, int offset)\r\n{\r\nif (!PagePrivate(page))\r\nreturn NULL;\r\nreturn mp_anchor(page)->mp[offset >> L2PSIZE];\r\n}\r\nstatic inline int insert_metapage(struct page *page, struct metapage *mp)\r\n{\r\nstruct meta_anchor *a;\r\nint index;\r\nint l2mp_blocks;\r\nif (PagePrivate(page))\r\na = mp_anchor(page);\r\nelse {\r\na = kzalloc(sizeof(struct meta_anchor), GFP_NOFS);\r\nif (!a)\r\nreturn -ENOMEM;\r\nset_page_private(page, (unsigned long)a);\r\nSetPagePrivate(page);\r\nkmap(page);\r\n}\r\nif (mp) {\r\nl2mp_blocks = L2PSIZE - page->mapping->host->i_blkbits;\r\nindex = (mp->index >> l2mp_blocks) & (MPS_PER_PAGE - 1);\r\na->mp_count++;\r\na->mp[index] = mp;\r\n}\r\nreturn 0;\r\n}\r\nstatic inline void remove_metapage(struct page *page, struct metapage *mp)\r\n{\r\nstruct meta_anchor *a = mp_anchor(page);\r\nint l2mp_blocks = L2PSIZE - page->mapping->host->i_blkbits;\r\nint index;\r\nindex = (mp->index >> l2mp_blocks) & (MPS_PER_PAGE - 1);\r\nBUG_ON(a->mp[index] != mp);\r\na->mp[index] = NULL;\r\nif (--a->mp_count == 0) {\r\nkfree(a);\r\nset_page_private(page, 0);\r\nClearPagePrivate(page);\r\nkunmap(page);\r\n}\r\n}\r\nstatic inline void inc_io(struct page *page)\r\n{\r\natomic_inc(&mp_anchor(page)->io_count);\r\n}\r\nstatic inline void dec_io(struct page *page, void (*handler) (struct page *))\r\n{\r\nif (atomic_dec_and_test(&mp_anchor(page)->io_count))\r\nhandler(page);\r\n}\r\nstatic inline struct metapage *page_to_mp(struct page *page, int offset)\r\n{\r\nreturn PagePrivate(page) ? (struct metapage *)page_private(page) : NULL;\r\n}\r\nstatic inline int insert_metapage(struct page *page, struct metapage *mp)\r\n{\r\nif (mp) {\r\nset_page_private(page, (unsigned long)mp);\r\nSetPagePrivate(page);\r\nkmap(page);\r\n}\r\nreturn 0;\r\n}\r\nstatic inline void remove_metapage(struct page *page, struct metapage *mp)\r\n{\r\nset_page_private(page, 0);\r\nClearPagePrivate(page);\r\nkunmap(page);\r\n}\r\nstatic inline struct metapage *alloc_metapage(gfp_t gfp_mask)\r\n{\r\nstruct metapage *mp = mempool_alloc(metapage_mempool, gfp_mask);\r\nif (mp) {\r\nmp->lid = 0;\r\nmp->lsn = 0;\r\nmp->data = NULL;\r\nmp->clsn = 0;\r\nmp->log = NULL;\r\ninit_waitqueue_head(&mp->wait);\r\n}\r\nreturn mp;\r\n}\r\nstatic inline void free_metapage(struct metapage *mp)\r\n{\r\nmempool_free(mp, metapage_mempool);\r\n}\r\nint __init metapage_init(void)\r\n{\r\nmetapage_cache = kmem_cache_create("jfs_mp", sizeof(struct metapage),\r\n0, 0, NULL);\r\nif (metapage_cache == NULL)\r\nreturn -ENOMEM;\r\nmetapage_mempool = mempool_create_slab_pool(METAPOOL_MIN_PAGES,\r\nmetapage_cache);\r\nif (metapage_mempool == NULL) {\r\nkmem_cache_destroy(metapage_cache);\r\nreturn -ENOMEM;\r\n}\r\nreturn 0;\r\n}\r\nvoid metapage_exit(void)\r\n{\r\nmempool_destroy(metapage_mempool);\r\nkmem_cache_destroy(metapage_cache);\r\n}\r\nstatic inline void drop_metapage(struct page *page, struct metapage *mp)\r\n{\r\nif (mp->count || mp->nohomeok || test_bit(META_dirty, &mp->flag) ||\r\ntest_bit(META_io, &mp->flag))\r\nreturn;\r\nremove_metapage(page, mp);\r\nINCREMENT(mpStat.pagefree);\r\nfree_metapage(mp);\r\n}\r\nstatic sector_t metapage_get_blocks(struct inode *inode, sector_t lblock,\r\nint *len)\r\n{\r\nint rc = 0;\r\nint xflag;\r\ns64 xaddr;\r\nsector_t file_blocks = (inode->i_size + inode->i_sb->s_blocksize - 1) >>\r\ninode->i_blkbits;\r\nif (lblock >= file_blocks)\r\nreturn 0;\r\nif (lblock + *len > file_blocks)\r\n*len = file_blocks - lblock;\r\nif (inode->i_ino) {\r\nrc = xtLookup(inode, (s64)lblock, *len, &xflag, &xaddr, len, 0);\r\nif ((rc == 0) && *len)\r\nlblock = (sector_t)xaddr;\r\nelse\r\nlblock = 0;\r\n}\r\nreturn lblock;\r\n}\r\nstatic void last_read_complete(struct page *page)\r\n{\r\nif (!PageError(page))\r\nSetPageUptodate(page);\r\nunlock_page(page);\r\n}\r\nstatic void metapage_read_end_io(struct bio *bio)\r\n{\r\nstruct page *page = bio->bi_private;\r\nif (bio->bi_error) {\r\nprintk(KERN_ERR "metapage_read_end_io: I/O error\n");\r\nSetPageError(page);\r\n}\r\ndec_io(page, last_read_complete);\r\nbio_put(bio);\r\n}\r\nstatic void remove_from_logsync(struct metapage *mp)\r\n{\r\nstruct jfs_log *log = mp->log;\r\nunsigned long flags;\r\nif (!log)\r\nreturn;\r\nLOGSYNC_LOCK(log, flags);\r\nif (mp->lsn) {\r\nmp->log = NULL;\r\nmp->lsn = 0;\r\nmp->clsn = 0;\r\nlog->count--;\r\nlist_del(&mp->synclist);\r\n}\r\nLOGSYNC_UNLOCK(log, flags);\r\n}\r\nstatic void last_write_complete(struct page *page)\r\n{\r\nstruct metapage *mp;\r\nunsigned int offset;\r\nfor (offset = 0; offset < PAGE_CACHE_SIZE; offset += PSIZE) {\r\nmp = page_to_mp(page, offset);\r\nif (mp && test_bit(META_io, &mp->flag)) {\r\nif (mp->lsn)\r\nremove_from_logsync(mp);\r\nclear_bit(META_io, &mp->flag);\r\n}\r\n}\r\nend_page_writeback(page);\r\n}\r\nstatic void metapage_write_end_io(struct bio *bio)\r\n{\r\nstruct page *page = bio->bi_private;\r\nBUG_ON(!PagePrivate(page));\r\nif (bio->bi_error) {\r\nprintk(KERN_ERR "metapage_write_end_io: I/O error\n");\r\nSetPageError(page);\r\n}\r\ndec_io(page, last_write_complete);\r\nbio_put(bio);\r\n}\r\nstatic int metapage_writepage(struct page *page, struct writeback_control *wbc)\r\n{\r\nstruct bio *bio = NULL;\r\nint block_offset;\r\nstruct inode *inode = page->mapping->host;\r\nint blocks_per_mp = JFS_SBI(inode->i_sb)->nbperpage;\r\nint len;\r\nint xlen;\r\nstruct metapage *mp;\r\nint redirty = 0;\r\nsector_t lblock;\r\nint nr_underway = 0;\r\nsector_t pblock;\r\nsector_t next_block = 0;\r\nsector_t page_start;\r\nunsigned long bio_bytes = 0;\r\nunsigned long bio_offset = 0;\r\nint offset;\r\nint bad_blocks = 0;\r\npage_start = (sector_t)page->index <<\r\n(PAGE_CACHE_SHIFT - inode->i_blkbits);\r\nBUG_ON(!PageLocked(page));\r\nBUG_ON(PageWriteback(page));\r\nset_page_writeback(page);\r\nfor (offset = 0; offset < PAGE_CACHE_SIZE; offset += PSIZE) {\r\nmp = page_to_mp(page, offset);\r\nif (!mp || !test_bit(META_dirty, &mp->flag))\r\ncontinue;\r\nif (mp->nohomeok && !test_bit(META_forcewrite, &mp->flag)) {\r\nredirty = 1;\r\nif (mp->log && !(mp->log->cflag & logGC_PAGEOUT))\r\njfs_flush_journal(mp->log, 0);\r\ncontinue;\r\n}\r\nclear_bit(META_dirty, &mp->flag);\r\nset_bit(META_io, &mp->flag);\r\nblock_offset = offset >> inode->i_blkbits;\r\nlblock = page_start + block_offset;\r\nif (bio) {\r\nif (xlen && lblock == next_block) {\r\nlen = min(xlen, blocks_per_mp);\r\nxlen -= len;\r\nbio_bytes += len << inode->i_blkbits;\r\ncontinue;\r\n}\r\nif (bio_add_page(bio, page, bio_bytes, bio_offset) <\r\nbio_bytes)\r\ngoto add_failed;\r\ninc_io(page);\r\nif (!bio->bi_iter.bi_size)\r\ngoto dump_bio;\r\nsubmit_bio(WRITE, bio);\r\nnr_underway++;\r\nbio = NULL;\r\n} else\r\ninc_io(page);\r\nxlen = (PAGE_CACHE_SIZE - offset) >> inode->i_blkbits;\r\npblock = metapage_get_blocks(inode, lblock, &xlen);\r\nif (!pblock) {\r\nprintk(KERN_ERR "JFS: metapage_get_blocks failed\n");\r\nbad_blocks++;\r\ncontinue;\r\n}\r\nlen = min(xlen, (int)JFS_SBI(inode->i_sb)->nbperpage);\r\nbio = bio_alloc(GFP_NOFS, 1);\r\nbio->bi_bdev = inode->i_sb->s_bdev;\r\nbio->bi_iter.bi_sector = pblock << (inode->i_blkbits - 9);\r\nbio->bi_end_io = metapage_write_end_io;\r\nbio->bi_private = page;\r\nbio_offset = offset;\r\nbio_bytes = len << inode->i_blkbits;\r\nxlen -= len;\r\nnext_block = lblock + len;\r\n}\r\nif (bio) {\r\nif (bio_add_page(bio, page, bio_bytes, bio_offset) < bio_bytes)\r\ngoto add_failed;\r\nif (!bio->bi_iter.bi_size)\r\ngoto dump_bio;\r\nsubmit_bio(WRITE, bio);\r\nnr_underway++;\r\n}\r\nif (redirty)\r\nredirty_page_for_writepage(wbc, page);\r\nunlock_page(page);\r\nif (bad_blocks)\r\ngoto err_out;\r\nif (nr_underway == 0)\r\nend_page_writeback(page);\r\nreturn 0;\r\nadd_failed:\r\nprintk(KERN_ERR "JFS: bio_add_page failed unexpectedly\n");\r\ngoto skip;\r\ndump_bio:\r\nprint_hex_dump(KERN_ERR, "JFS: dump of bio: ", DUMP_PREFIX_ADDRESS, 16,\r\n4, bio, sizeof(*bio), 0);\r\nskip:\r\nbio_put(bio);\r\nunlock_page(page);\r\ndec_io(page, last_write_complete);\r\nerr_out:\r\nwhile (bad_blocks--)\r\ndec_io(page, last_write_complete);\r\nreturn -EIO;\r\n}\r\nstatic int metapage_readpage(struct file *fp, struct page *page)\r\n{\r\nstruct inode *inode = page->mapping->host;\r\nstruct bio *bio = NULL;\r\nint block_offset;\r\nint blocks_per_page = PAGE_CACHE_SIZE >> inode->i_blkbits;\r\nsector_t page_start;\r\nsector_t pblock;\r\nint xlen;\r\nunsigned int len;\r\nint offset;\r\nBUG_ON(!PageLocked(page));\r\npage_start = (sector_t)page->index <<\r\n(PAGE_CACHE_SHIFT - inode->i_blkbits);\r\nblock_offset = 0;\r\nwhile (block_offset < blocks_per_page) {\r\nxlen = blocks_per_page - block_offset;\r\npblock = metapage_get_blocks(inode, page_start + block_offset,\r\n&xlen);\r\nif (pblock) {\r\nif (!PagePrivate(page))\r\ninsert_metapage(page, NULL);\r\ninc_io(page);\r\nif (bio)\r\nsubmit_bio(READ, bio);\r\nbio = bio_alloc(GFP_NOFS, 1);\r\nbio->bi_bdev = inode->i_sb->s_bdev;\r\nbio->bi_iter.bi_sector =\r\npblock << (inode->i_blkbits - 9);\r\nbio->bi_end_io = metapage_read_end_io;\r\nbio->bi_private = page;\r\nlen = xlen << inode->i_blkbits;\r\noffset = block_offset << inode->i_blkbits;\r\nif (bio_add_page(bio, page, len, offset) < len)\r\ngoto add_failed;\r\nblock_offset += xlen;\r\n} else\r\nblock_offset++;\r\n}\r\nif (bio)\r\nsubmit_bio(READ, bio);\r\nelse\r\nunlock_page(page);\r\nreturn 0;\r\nadd_failed:\r\nprintk(KERN_ERR "JFS: bio_add_page failed unexpectedly\n");\r\nbio_put(bio);\r\ndec_io(page, last_read_complete);\r\nreturn -EIO;\r\n}\r\nstatic int metapage_releasepage(struct page *page, gfp_t gfp_mask)\r\n{\r\nstruct metapage *mp;\r\nint ret = 1;\r\nint offset;\r\nfor (offset = 0; offset < PAGE_CACHE_SIZE; offset += PSIZE) {\r\nmp = page_to_mp(page, offset);\r\nif (!mp)\r\ncontinue;\r\njfs_info("metapage_releasepage: mp = 0x%p", mp);\r\nif (mp->count || mp->nohomeok ||\r\ntest_bit(META_dirty, &mp->flag)) {\r\njfs_info("count = %ld, nohomeok = %d", mp->count,\r\nmp->nohomeok);\r\nret = 0;\r\ncontinue;\r\n}\r\nif (mp->lsn)\r\nremove_from_logsync(mp);\r\nremove_metapage(page, mp);\r\nINCREMENT(mpStat.pagefree);\r\nfree_metapage(mp);\r\n}\r\nreturn ret;\r\n}\r\nstatic void metapage_invalidatepage(struct page *page, unsigned int offset,\r\nunsigned int length)\r\n{\r\nBUG_ON(offset || length < PAGE_CACHE_SIZE);\r\nBUG_ON(PageWriteback(page));\r\nmetapage_releasepage(page, 0);\r\n}\r\nstruct metapage *__get_metapage(struct inode *inode, unsigned long lblock,\r\nunsigned int size, int absolute,\r\nunsigned long new)\r\n{\r\nint l2BlocksPerPage;\r\nint l2bsize;\r\nstruct address_space *mapping;\r\nstruct metapage *mp = NULL;\r\nstruct page *page;\r\nunsigned long page_index;\r\nunsigned long page_offset;\r\njfs_info("__get_metapage: ino = %ld, lblock = 0x%lx, abs=%d",\r\ninode->i_ino, lblock, absolute);\r\nl2bsize = inode->i_blkbits;\r\nl2BlocksPerPage = PAGE_CACHE_SHIFT - l2bsize;\r\npage_index = lblock >> l2BlocksPerPage;\r\npage_offset = (lblock - (page_index << l2BlocksPerPage)) << l2bsize;\r\nif ((page_offset + size) > PAGE_CACHE_SIZE) {\r\njfs_err("MetaData crosses page boundary!!");\r\njfs_err("lblock = %lx, size = %d", lblock, size);\r\ndump_stack();\r\nreturn NULL;\r\n}\r\nif (absolute)\r\nmapping = JFS_SBI(inode->i_sb)->direct_inode->i_mapping;\r\nelse {\r\nif ((lblock << inode->i_blkbits) >= inode->i_size)\r\nreturn NULL;\r\nmapping = inode->i_mapping;\r\n}\r\nif (new && (PSIZE == PAGE_CACHE_SIZE)) {\r\npage = grab_cache_page(mapping, page_index);\r\nif (!page) {\r\njfs_err("grab_cache_page failed!");\r\nreturn NULL;\r\n}\r\nSetPageUptodate(page);\r\n} else {\r\npage = read_mapping_page(mapping, page_index, NULL);\r\nif (IS_ERR(page) || !PageUptodate(page)) {\r\njfs_err("read_mapping_page failed!");\r\nreturn NULL;\r\n}\r\nlock_page(page);\r\n}\r\nmp = page_to_mp(page, page_offset);\r\nif (mp) {\r\nif (mp->logical_size != size) {\r\njfs_error(inode->i_sb,\r\n"get_mp->logical_size != size\n");\r\njfs_err("logical_size = %d, size = %d",\r\nmp->logical_size, size);\r\ndump_stack();\r\ngoto unlock;\r\n}\r\nmp->count++;\r\nlock_metapage(mp);\r\nif (test_bit(META_discard, &mp->flag)) {\r\nif (!new) {\r\njfs_error(inode->i_sb,\r\n"using a discarded metapage\n");\r\ndiscard_metapage(mp);\r\ngoto unlock;\r\n}\r\nclear_bit(META_discard, &mp->flag);\r\n}\r\n} else {\r\nINCREMENT(mpStat.pagealloc);\r\nmp = alloc_metapage(GFP_NOFS);\r\nmp->page = page;\r\nmp->flag = 0;\r\nmp->xflag = COMMIT_PAGE;\r\nmp->count = 1;\r\nmp->nohomeok = 0;\r\nmp->logical_size = size;\r\nmp->data = page_address(page) + page_offset;\r\nmp->index = lblock;\r\nif (unlikely(insert_metapage(page, mp))) {\r\nfree_metapage(mp);\r\ngoto unlock;\r\n}\r\nlock_metapage(mp);\r\n}\r\nif (new) {\r\njfs_info("zeroing mp = 0x%p", mp);\r\nmemset(mp->data, 0, PSIZE);\r\n}\r\nunlock_page(page);\r\njfs_info("__get_metapage: returning = 0x%p data = 0x%p", mp, mp->data);\r\nreturn mp;\r\nunlock:\r\nunlock_page(page);\r\nreturn NULL;\r\n}\r\nvoid grab_metapage(struct metapage * mp)\r\n{\r\njfs_info("grab_metapage: mp = 0x%p", mp);\r\npage_cache_get(mp->page);\r\nlock_page(mp->page);\r\nmp->count++;\r\nlock_metapage(mp);\r\nunlock_page(mp->page);\r\n}\r\nvoid force_metapage(struct metapage *mp)\r\n{\r\nstruct page *page = mp->page;\r\njfs_info("force_metapage: mp = 0x%p", mp);\r\nset_bit(META_forcewrite, &mp->flag);\r\nclear_bit(META_sync, &mp->flag);\r\npage_cache_get(page);\r\nlock_page(page);\r\nset_page_dirty(page);\r\nwrite_one_page(page, 1);\r\nclear_bit(META_forcewrite, &mp->flag);\r\npage_cache_release(page);\r\n}\r\nvoid hold_metapage(struct metapage *mp)\r\n{\r\nlock_page(mp->page);\r\n}\r\nvoid put_metapage(struct metapage *mp)\r\n{\r\nif (mp->count || mp->nohomeok) {\r\nunlock_page(mp->page);\r\nreturn;\r\n}\r\npage_cache_get(mp->page);\r\nmp->count++;\r\nlock_metapage(mp);\r\nunlock_page(mp->page);\r\nrelease_metapage(mp);\r\n}\r\nvoid release_metapage(struct metapage * mp)\r\n{\r\nstruct page *page = mp->page;\r\njfs_info("release_metapage: mp = 0x%p, flag = 0x%lx", mp, mp->flag);\r\nBUG_ON(!page);\r\nlock_page(page);\r\nunlock_metapage(mp);\r\nassert(mp->count);\r\nif (--mp->count || mp->nohomeok) {\r\nunlock_page(page);\r\npage_cache_release(page);\r\nreturn;\r\n}\r\nif (test_bit(META_dirty, &mp->flag)) {\r\nset_page_dirty(page);\r\nif (test_bit(META_sync, &mp->flag)) {\r\nclear_bit(META_sync, &mp->flag);\r\nwrite_one_page(page, 1);\r\nlock_page(page);\r\n}\r\n} else if (mp->lsn)\r\nremove_from_logsync(mp);\r\ndrop_metapage(page, mp);\r\nunlock_page(page);\r\npage_cache_release(page);\r\n}\r\nvoid __invalidate_metapages(struct inode *ip, s64 addr, int len)\r\n{\r\nsector_t lblock;\r\nint l2BlocksPerPage = PAGE_CACHE_SHIFT - ip->i_blkbits;\r\nint BlocksPerPage = 1 << l2BlocksPerPage;\r\nstruct address_space *mapping =\r\nJFS_SBI(ip->i_sb)->direct_inode->i_mapping;\r\nstruct metapage *mp;\r\nstruct page *page;\r\nunsigned int offset;\r\nfor (lblock = addr & ~(BlocksPerPage - 1); lblock < addr + len;\r\nlblock += BlocksPerPage) {\r\npage = find_lock_page(mapping, lblock >> l2BlocksPerPage);\r\nif (!page)\r\ncontinue;\r\nfor (offset = 0; offset < PAGE_CACHE_SIZE; offset += PSIZE) {\r\nmp = page_to_mp(page, offset);\r\nif (!mp)\r\ncontinue;\r\nif (mp->index < addr)\r\ncontinue;\r\nif (mp->index >= addr + len)\r\nbreak;\r\nclear_bit(META_dirty, &mp->flag);\r\nset_bit(META_discard, &mp->flag);\r\nif (mp->lsn)\r\nremove_from_logsync(mp);\r\n}\r\nunlock_page(page);\r\npage_cache_release(page);\r\n}\r\n}\r\nstatic int jfs_mpstat_proc_show(struct seq_file *m, void *v)\r\n{\r\nseq_printf(m,\r\n"JFS Metapage statistics\n"\r\n"=======================\n"\r\n"page allocations = %d\n"\r\n"page frees = %d\n"\r\n"lock waits = %d\n",\r\nmpStat.pagealloc,\r\nmpStat.pagefree,\r\nmpStat.lockwait);\r\nreturn 0;\r\n}\r\nstatic int jfs_mpstat_proc_open(struct inode *inode, struct file *file)\r\n{\r\nreturn single_open(file, jfs_mpstat_proc_show, NULL);\r\n}
