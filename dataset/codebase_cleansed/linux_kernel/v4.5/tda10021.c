static int _tda10021_writereg (struct tda10021_state* state, u8 reg, u8 data)\r\n{\r\nu8 buf[] = { reg, data };\r\nstruct i2c_msg msg = { .addr = state->config->demod_address, .flags = 0, .buf = buf, .len = 2 };\r\nint ret;\r\nret = i2c_transfer (state->i2c, &msg, 1);\r\nif (ret != 1)\r\nprintk("DVB: TDA10021(%d): %s, writereg error "\r\n"(reg == 0x%02x, val == 0x%02x, ret == %i)\n",\r\nstate->frontend.dvb->num, __func__, reg, data, ret);\r\nmsleep(10);\r\nreturn (ret != 1) ? -EREMOTEIO : 0;\r\n}\r\nstatic u8 tda10021_readreg (struct tda10021_state* state, u8 reg)\r\n{\r\nu8 b0 [] = { reg };\r\nu8 b1 [] = { 0 };\r\nstruct i2c_msg msg [] = { { .addr = state->config->demod_address, .flags = 0, .buf = b0, .len = 1 },\r\n{ .addr = state->config->demod_address, .flags = I2C_M_RD, .buf = b1, .len = 1 } };\r\nint ret;\r\nret = i2c_transfer (state->i2c, msg, 2);\r\nif (ret != 2 && reg != 0x1a)\r\nprintk("DVB: TDA10021: %s: readreg error (ret == %i)\n",\r\n__func__, ret);\r\nreturn b1[0];\r\n}\r\nstatic int lock_tuner(struct tda10021_state* state)\r\n{\r\nu8 buf[2] = { 0x0f, tda10021_inittab[0x0f] | 0x80 };\r\nstruct i2c_msg msg = {.addr=state->config->demod_address, .flags=0, .buf=buf, .len=2};\r\nif(i2c_transfer(state->i2c, &msg, 1) != 1)\r\n{\r\nprintk("tda10021: lock tuner fails\n");\r\nreturn -EREMOTEIO;\r\n}\r\nreturn 0;\r\n}\r\nstatic int unlock_tuner(struct tda10021_state* state)\r\n{\r\nu8 buf[2] = { 0x0f, tda10021_inittab[0x0f] & 0x7f };\r\nstruct i2c_msg msg_post={.addr=state->config->demod_address, .flags=0, .buf=buf, .len=2};\r\nif(i2c_transfer(state->i2c, &msg_post, 1) != 1)\r\n{\r\nprintk("tda10021: unlock tuner fails\n");\r\nreturn -EREMOTEIO;\r\n}\r\nreturn 0;\r\n}\r\nstatic int tda10021_setup_reg0(struct tda10021_state *state, u8 reg0,\r\nenum fe_spectral_inversion inversion)\r\n{\r\nreg0 |= state->reg0 & 0x63;\r\nif ((INVERSION_ON == inversion) ^ (state->config->invert == 0))\r\nreg0 &= ~0x20;\r\nelse\r\nreg0 |= 0x20;\r\n_tda10021_writereg (state, 0x00, reg0 & 0xfe);\r\n_tda10021_writereg (state, 0x00, reg0 | 0x01);\r\nstate->reg0 = reg0;\r\nreturn 0;\r\n}\r\nstatic int tda10021_set_symbolrate (struct tda10021_state* state, u32 symbolrate)\r\n{\r\ns32 BDR;\r\ns32 BDRI;\r\ns16 SFIL=0;\r\nu16 NDEC = 0;\r\nu32 tmp, ratio;\r\nif (symbolrate > XIN/2)\r\nsymbolrate = XIN/2;\r\nif (symbolrate < 500000)\r\nsymbolrate = 500000;\r\nif (symbolrate < XIN/16) NDEC = 1;\r\nif (symbolrate < XIN/32) NDEC = 2;\r\nif (symbolrate < XIN/64) NDEC = 3;\r\nif (symbolrate < (u32)(XIN/12.3)) SFIL = 1;\r\nif (symbolrate < (u32)(XIN/16)) SFIL = 0;\r\nif (symbolrate < (u32)(XIN/24.6)) SFIL = 1;\r\nif (symbolrate < (u32)(XIN/32)) SFIL = 0;\r\nif (symbolrate < (u32)(XIN/49.2)) SFIL = 1;\r\nif (symbolrate < (u32)(XIN/64)) SFIL = 0;\r\nif (symbolrate < (u32)(XIN/98.4)) SFIL = 1;\r\nsymbolrate <<= NDEC;\r\nratio = (symbolrate << 4) / FIN;\r\ntmp = ((symbolrate << 4) % FIN) << 8;\r\nratio = (ratio << 8) + tmp / FIN;\r\ntmp = (tmp % FIN) << 8;\r\nratio = (ratio << 8) + DIV_ROUND_CLOSEST(tmp, FIN);\r\nBDR = ratio;\r\nBDRI = (((XIN << 5) / symbolrate) + 1) / 2;\r\nif (BDRI > 0xFF)\r\nBDRI = 0xFF;\r\nSFIL = (SFIL << 4) | tda10021_inittab[0x0E];\r\nNDEC = (NDEC << 6) | tda10021_inittab[0x03];\r\n_tda10021_writereg (state, 0x03, NDEC);\r\n_tda10021_writereg (state, 0x0a, BDR&0xff);\r\n_tda10021_writereg (state, 0x0b, (BDR>> 8)&0xff);\r\n_tda10021_writereg (state, 0x0c, (BDR>>16)&0x3f);\r\n_tda10021_writereg (state, 0x0d, BDRI);\r\n_tda10021_writereg (state, 0x0e, SFIL);\r\nreturn 0;\r\n}\r\nstatic int tda10021_init (struct dvb_frontend *fe)\r\n{\r\nstruct tda10021_state* state = fe->demodulator_priv;\r\nint i;\r\ndprintk("DVB: TDA10021(%d): init chip\n", fe->adapter->num);\r\nfor (i=0; i<tda10021_inittab_size; i++)\r\n_tda10021_writereg (state, i, tda10021_inittab[i]);\r\n_tda10021_writereg (state, 0x34, state->pwm);\r\n_tda10021_writereg(state, 0x2a, tda10021_inittab[0x2a] & 0xef);\r\nreturn 0;\r\n}\r\nstatic int tda10021_set_parameters(struct dvb_frontend *fe)\r\n{\r\nstruct dtv_frontend_properties *c = &fe->dtv_property_cache;\r\nu32 delsys = c->delivery_system;\r\nunsigned qam = c->modulation;\r\nbool is_annex_c;\r\nu32 reg0x3d;\r\nstruct tda10021_state* state = fe->demodulator_priv;\r\nstatic const struct qam_params qam_params[] = {\r\n[QPSK] = { 0x14, 0x78, 0x78, 0x8c, 0x96 },\r\n[QAM_16] = { 0x00, 0x8c, 0x87, 0xa2, 0x91 },\r\n[QAM_32] = { 0x04, 0x8c, 0x64, 0x74, 0x96 },\r\n[QAM_64] = { 0x08, 0x6a, 0x46, 0x43, 0x6a },\r\n[QAM_128] = { 0x0c, 0x78, 0x36, 0x34, 0x7e },\r\n[QAM_256] = { 0x10, 0x5c, 0x26, 0x23, 0x6b },\r\n};\r\nswitch (delsys) {\r\ncase SYS_DVBC_ANNEX_A:\r\nis_annex_c = false;\r\nbreak;\r\ncase SYS_DVBC_ANNEX_C:\r\nis_annex_c = true;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nswitch (qam) {\r\ncase QPSK:\r\ncase QAM_16:\r\ncase QAM_32:\r\ncase QAM_64:\r\ncase QAM_128:\r\ncase QAM_256:\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nif (c->inversion != INVERSION_ON && c->inversion != INVERSION_OFF)\r\nreturn -EINVAL;\r\nif (fe->ops.tuner_ops.set_params) {\r\nfe->ops.tuner_ops.set_params(fe);\r\nif (fe->ops.i2c_gate_ctrl) fe->ops.i2c_gate_ctrl(fe, 0);\r\n}\r\ntda10021_set_symbolrate(state, c->symbol_rate);\r\n_tda10021_writereg(state, 0x34, state->pwm);\r\n_tda10021_writereg(state, 0x01, qam_params[qam].agcref);\r\n_tda10021_writereg(state, 0x05, qam_params[qam].lthr);\r\n_tda10021_writereg(state, 0x08, qam_params[qam].mseth);\r\n_tda10021_writereg(state, 0x09, qam_params[qam].aref);\r\nreg0x3d = tda10021_readreg (state, 0x3d);\r\nif (is_annex_c)\r\n_tda10021_writereg (state, 0x3d, 0x01 | reg0x3d);\r\nelse\r\n_tda10021_writereg (state, 0x3d, 0xfe & reg0x3d);\r\ntda10021_setup_reg0(state, qam_params[qam].conf, c->inversion);\r\nreturn 0;\r\n}\r\nstatic int tda10021_read_status(struct dvb_frontend *fe,\r\nenum fe_status *status)\r\n{\r\nstruct tda10021_state* state = fe->demodulator_priv;\r\nint sync;\r\n*status = 0;\r\nsync = tda10021_readreg (state, 0x11);\r\nif (sync & 2)\r\n*status |= FE_HAS_SIGNAL|FE_HAS_CARRIER;\r\nif (sync & 4)\r\n*status |= FE_HAS_SYNC|FE_HAS_VITERBI;\r\nif (sync & 8)\r\n*status |= FE_HAS_LOCK;\r\nreturn 0;\r\n}\r\nstatic int tda10021_read_ber(struct dvb_frontend* fe, u32* ber)\r\n{\r\nstruct tda10021_state* state = fe->demodulator_priv;\r\nu32 _ber = tda10021_readreg(state, 0x14) |\r\n(tda10021_readreg(state, 0x15) << 8) |\r\n((tda10021_readreg(state, 0x16) & 0x0f) << 16);\r\n_tda10021_writereg(state, 0x10, (tda10021_readreg(state, 0x10) & ~0xc0)\r\n| (tda10021_inittab[0x10] & 0xc0));\r\n*ber = 10 * _ber;\r\nreturn 0;\r\n}\r\nstatic int tda10021_read_signal_strength(struct dvb_frontend* fe, u16* strength)\r\n{\r\nstruct tda10021_state* state = fe->demodulator_priv;\r\nu8 config = tda10021_readreg(state, 0x02);\r\nu8 gain = tda10021_readreg(state, 0x17);\r\nif (config & 0x02)\r\ngain = ~gain;\r\n*strength = (gain << 8) | gain;\r\nreturn 0;\r\n}\r\nstatic int tda10021_read_snr(struct dvb_frontend* fe, u16* snr)\r\n{\r\nstruct tda10021_state* state = fe->demodulator_priv;\r\nu8 quality = ~tda10021_readreg(state, 0x18);\r\n*snr = (quality << 8) | quality;\r\nreturn 0;\r\n}\r\nstatic int tda10021_read_ucblocks(struct dvb_frontend* fe, u32* ucblocks)\r\n{\r\nstruct tda10021_state* state = fe->demodulator_priv;\r\n*ucblocks = tda10021_readreg (state, 0x13) & 0x7f;\r\nif (*ucblocks == 0x7f)\r\n*ucblocks = 0xffffffff;\r\n_tda10021_writereg (state, 0x10, tda10021_inittab[0x10] & 0xdf);\r\n_tda10021_writereg (state, 0x10, tda10021_inittab[0x10]);\r\nreturn 0;\r\n}\r\nstatic int tda10021_get_frontend(struct dvb_frontend *fe)\r\n{\r\nstruct dtv_frontend_properties *p = &fe->dtv_property_cache;\r\nstruct tda10021_state* state = fe->demodulator_priv;\r\nint sync;\r\ns8 afc = 0;\r\nsync = tda10021_readreg(state, 0x11);\r\nafc = tda10021_readreg(state, 0x19);\r\nif (verbose) {\r\nprintk(sync & 2 ? "DVB: TDA10021(%d): AFC (%d) %dHz\n" :\r\n"DVB: TDA10021(%d): [AFC (%d) %dHz]\n",\r\nstate->frontend.dvb->num, afc,\r\n-((s32)p->symbol_rate * afc) >> 10);\r\n}\r\np->inversion = ((state->reg0 & 0x20) == 0x20) ^ (state->config->invert != 0) ? INVERSION_ON : INVERSION_OFF;\r\np->modulation = ((state->reg0 >> 2) & 7) + QAM_16;\r\np->fec_inner = FEC_NONE;\r\np->frequency = ((p->frequency + 31250) / 62500) * 62500;\r\nif (sync & 2)\r\np->frequency -= ((s32)p->symbol_rate * afc) >> 10;\r\nreturn 0;\r\n}\r\nstatic int tda10021_i2c_gate_ctrl(struct dvb_frontend* fe, int enable)\r\n{\r\nstruct tda10021_state* state = fe->demodulator_priv;\r\nif (enable) {\r\nlock_tuner(state);\r\n} else {\r\nunlock_tuner(state);\r\n}\r\nreturn 0;\r\n}\r\nstatic int tda10021_sleep(struct dvb_frontend* fe)\r\n{\r\nstruct tda10021_state* state = fe->demodulator_priv;\r\n_tda10021_writereg (state, 0x1b, 0x02);\r\n_tda10021_writereg (state, 0x00, 0x80);\r\nreturn 0;\r\n}\r\nstatic void tda10021_release(struct dvb_frontend* fe)\r\n{\r\nstruct tda10021_state* state = fe->demodulator_priv;\r\nkfree(state);\r\n}\r\nstruct dvb_frontend* tda10021_attach(const struct tda1002x_config* config,\r\nstruct i2c_adapter* i2c,\r\nu8 pwm)\r\n{\r\nstruct tda10021_state* state = NULL;\r\nu8 id;\r\nstate = kzalloc(sizeof(struct tda10021_state), GFP_KERNEL);\r\nif (state == NULL) goto error;\r\nstate->config = config;\r\nstate->i2c = i2c;\r\nstate->pwm = pwm;\r\nstate->reg0 = tda10021_inittab[0];\r\nid = tda10021_readreg(state, 0x1a);\r\nif ((id & 0xf0) != 0x70) goto error;\r\nif (id == 0x7d)\r\ngoto error;\r\nprintk("TDA10021: i2c-addr = 0x%02x, id = 0x%02x\n",\r\nstate->config->demod_address, id);\r\nmemcpy(&state->frontend.ops, &tda10021_ops, sizeof(struct dvb_frontend_ops));\r\nstate->frontend.demodulator_priv = state;\r\nreturn &state->frontend;\r\nerror:\r\nkfree(state);\r\nreturn NULL;\r\n}
