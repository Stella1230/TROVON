static int acpi_thermal_rel_open(struct inode *inode, struct file *file)\r\n{\r\nspin_lock(&acpi_thermal_rel_chrdev_lock);\r\nif (acpi_thermal_rel_chrdev_exclu ||\r\n(acpi_thermal_rel_chrdev_count && (file->f_flags & O_EXCL))) {\r\nspin_unlock(&acpi_thermal_rel_chrdev_lock);\r\nreturn -EBUSY;\r\n}\r\nif (file->f_flags & O_EXCL)\r\nacpi_thermal_rel_chrdev_exclu = 1;\r\nacpi_thermal_rel_chrdev_count++;\r\nspin_unlock(&acpi_thermal_rel_chrdev_lock);\r\nreturn nonseekable_open(inode, file);\r\n}\r\nstatic int acpi_thermal_rel_release(struct inode *inode, struct file *file)\r\n{\r\nspin_lock(&acpi_thermal_rel_chrdev_lock);\r\nacpi_thermal_rel_chrdev_count--;\r\nacpi_thermal_rel_chrdev_exclu = 0;\r\nspin_unlock(&acpi_thermal_rel_chrdev_lock);\r\nreturn 0;\r\n}\r\nint acpi_parse_trt(acpi_handle handle, int *trt_count, struct trt **trtp,\r\nbool create_dev)\r\n{\r\nacpi_status status;\r\nint result = 0;\r\nint i;\r\nint nr_bad_entries = 0;\r\nstruct trt *trts;\r\nstruct acpi_device *adev;\r\nunion acpi_object *p;\r\nstruct acpi_buffer buffer = { ACPI_ALLOCATE_BUFFER, NULL };\r\nstruct acpi_buffer element = { 0, NULL };\r\nstruct acpi_buffer trt_format = { sizeof("RRNNNNNN"), "RRNNNNNN" };\r\nif (!acpi_has_method(handle, "_TRT"))\r\nreturn -ENODEV;\r\nstatus = acpi_evaluate_object(handle, "_TRT", NULL, &buffer);\r\nif (ACPI_FAILURE(status))\r\nreturn -ENODEV;\r\np = buffer.pointer;\r\nif (!p || (p->type != ACPI_TYPE_PACKAGE)) {\r\npr_err("Invalid _TRT data\n");\r\nresult = -EFAULT;\r\ngoto end;\r\n}\r\n*trt_count = p->package.count;\r\ntrts = kzalloc(*trt_count * sizeof(struct trt), GFP_KERNEL);\r\nif (!trts) {\r\nresult = -ENOMEM;\r\ngoto end;\r\n}\r\nfor (i = 0; i < *trt_count; i++) {\r\nstruct trt *trt = &trts[i - nr_bad_entries];\r\nelement.length = sizeof(struct trt);\r\nelement.pointer = trt;\r\nstatus = acpi_extract_package(&(p->package.elements[i]),\r\n&trt_format, &element);\r\nif (ACPI_FAILURE(status)) {\r\nnr_bad_entries++;\r\npr_warn("_TRT package %d is invalid, ignored\n", i);\r\ncontinue;\r\n}\r\nif (!create_dev)\r\ncontinue;\r\nresult = acpi_bus_get_device(trt->source, &adev);\r\nif (result)\r\npr_warn("Failed to get source ACPI device\n");\r\nresult = acpi_bus_get_device(trt->target, &adev);\r\nif (result)\r\npr_warn("Failed to get target ACPI device\n");\r\n}\r\nresult = 0;\r\n*trtp = trts;\r\n*trt_count -= nr_bad_entries;\r\nend:\r\nkfree(buffer.pointer);\r\nreturn result;\r\n}\r\nint acpi_parse_art(acpi_handle handle, int *art_count, struct art **artp,\r\nbool create_dev)\r\n{\r\nacpi_status status;\r\nint result = 0;\r\nint i;\r\nint nr_bad_entries = 0;\r\nstruct art *arts;\r\nstruct acpi_device *adev;\r\nunion acpi_object *p;\r\nstruct acpi_buffer buffer = { ACPI_ALLOCATE_BUFFER, NULL };\r\nstruct acpi_buffer element = { 0, NULL };\r\nstruct acpi_buffer art_format = {\r\nsizeof("RRNNNNNNNNNNN"), "RRNNNNNNNNNNN" };\r\nif (!acpi_has_method(handle, "_ART"))\r\nreturn -ENODEV;\r\nstatus = acpi_evaluate_object(handle, "_ART", NULL, &buffer);\r\nif (ACPI_FAILURE(status))\r\nreturn -ENODEV;\r\np = buffer.pointer;\r\nif (!p || (p->type != ACPI_TYPE_PACKAGE)) {\r\npr_err("Invalid _ART data\n");\r\nresult = -EFAULT;\r\ngoto end;\r\n}\r\n*art_count = p->package.count - 1;\r\narts = kzalloc(*art_count * sizeof(struct art), GFP_KERNEL);\r\nif (!arts) {\r\nresult = -ENOMEM;\r\ngoto end;\r\n}\r\nfor (i = 0; i < *art_count; i++) {\r\nstruct art *art = &arts[i - nr_bad_entries];\r\nelement.length = sizeof(struct art);\r\nelement.pointer = art;\r\nstatus = acpi_extract_package(&(p->package.elements[i + 1]),\r\n&art_format, &element);\r\nif (ACPI_FAILURE(status)) {\r\npr_warn("_ART package %d is invalid, ignored", i);\r\nnr_bad_entries++;\r\ncontinue;\r\n}\r\nif (!create_dev)\r\ncontinue;\r\nif (art->source) {\r\nresult = acpi_bus_get_device(art->source, &adev);\r\nif (result)\r\npr_warn("Failed to get source ACPI device\n");\r\n}\r\nif (art->target) {\r\nresult = acpi_bus_get_device(art->target, &adev);\r\nif (result)\r\npr_warn("Failed to get source ACPI device\n");\r\n}\r\n}\r\n*artp = arts;\r\n*art_count -= nr_bad_entries;\r\nend:\r\nkfree(buffer.pointer);\r\nreturn result;\r\n}\r\nstatic void get_single_name(acpi_handle handle, char *name)\r\n{\r\nstruct acpi_buffer buffer = {ACPI_ALLOCATE_BUFFER};\r\nif (ACPI_FAILURE(acpi_get_name(handle, ACPI_SINGLE_NAME, &buffer)))\r\npr_warn("Failed get name from handle\n");\r\nelse {\r\nmemcpy(name, buffer.pointer, ACPI_NAME_SIZE);\r\nkfree(buffer.pointer);\r\n}\r\n}\r\nstatic int fill_art(char __user *ubuf)\r\n{\r\nint i;\r\nint ret;\r\nint count;\r\nint art_len;\r\nstruct art *arts = NULL;\r\nunion art_object *art_user;\r\nret = acpi_parse_art(acpi_thermal_rel_handle, &count, &arts, false);\r\nif (ret)\r\ngoto free_art;\r\nart_len = count * sizeof(union art_object);\r\nart_user = kzalloc(art_len, GFP_KERNEL);\r\nif (!art_user) {\r\nret = -ENOMEM;\r\ngoto free_art;\r\n}\r\nfor (i = 0; i < count; i++) {\r\nget_single_name(arts[i].source, art_user[i].source_device);\r\nget_single_name(arts[i].target, art_user[i].target_device);\r\nmemcpy(&art_user[i].weight, &arts[i].weight,\r\nsizeof(u64) * (ACPI_NR_ART_ELEMENTS - 2));\r\n}\r\nif (copy_to_user(ubuf, art_user, art_len))\r\nret = -EFAULT;\r\nkfree(art_user);\r\nfree_art:\r\nkfree(arts);\r\nreturn ret;\r\n}\r\nstatic int fill_trt(char __user *ubuf)\r\n{\r\nint i;\r\nint ret;\r\nint count;\r\nint trt_len;\r\nstruct trt *trts = NULL;\r\nunion trt_object *trt_user;\r\nret = acpi_parse_trt(acpi_thermal_rel_handle, &count, &trts, false);\r\nif (ret)\r\ngoto free_trt;\r\ntrt_len = count * sizeof(union trt_object);\r\ntrt_user = kzalloc(trt_len, GFP_KERNEL);\r\nif (!trt_user) {\r\nret = -ENOMEM;\r\ngoto free_trt;\r\n}\r\nfor (i = 0; i < count; i++) {\r\nget_single_name(trts[i].source, trt_user[i].source_device);\r\nget_single_name(trts[i].target, trt_user[i].target_device);\r\ntrt_user[i].sample_period = trts[i].sample_period;\r\ntrt_user[i].influence = trts[i].influence;\r\n}\r\nif (copy_to_user(ubuf, trt_user, trt_len))\r\nret = -EFAULT;\r\nkfree(trt_user);\r\nfree_trt:\r\nkfree(trts);\r\nreturn ret;\r\n}\r\nstatic long acpi_thermal_rel_ioctl(struct file *f, unsigned int cmd,\r\nunsigned long __arg)\r\n{\r\nint ret = 0;\r\nunsigned long length = 0;\r\nint count = 0;\r\nchar __user *arg = (void __user *)__arg;\r\nstruct trt *trts = NULL;\r\nstruct art *arts = NULL;\r\nswitch (cmd) {\r\ncase ACPI_THERMAL_GET_TRT_COUNT:\r\nret = acpi_parse_trt(acpi_thermal_rel_handle, &count,\r\n&trts, false);\r\nkfree(trts);\r\nif (!ret)\r\nreturn put_user(count, (unsigned long __user *)__arg);\r\nreturn ret;\r\ncase ACPI_THERMAL_GET_TRT_LEN:\r\nret = acpi_parse_trt(acpi_thermal_rel_handle, &count,\r\n&trts, false);\r\nkfree(trts);\r\nlength = count * sizeof(union trt_object);\r\nif (!ret)\r\nreturn put_user(length, (unsigned long __user *)__arg);\r\nreturn ret;\r\ncase ACPI_THERMAL_GET_TRT:\r\nreturn fill_trt(arg);\r\ncase ACPI_THERMAL_GET_ART_COUNT:\r\nret = acpi_parse_art(acpi_thermal_rel_handle, &count,\r\n&arts, false);\r\nkfree(arts);\r\nif (!ret)\r\nreturn put_user(count, (unsigned long __user *)__arg);\r\nreturn ret;\r\ncase ACPI_THERMAL_GET_ART_LEN:\r\nret = acpi_parse_art(acpi_thermal_rel_handle, &count,\r\n&arts, false);\r\nkfree(arts);\r\nlength = count * sizeof(union art_object);\r\nif (!ret)\r\nreturn put_user(length, (unsigned long __user *)__arg);\r\nreturn ret;\r\ncase ACPI_THERMAL_GET_ART:\r\nreturn fill_art(arg);\r\ndefault:\r\nreturn -ENOTTY;\r\n}\r\n}\r\nint acpi_thermal_rel_misc_device_add(acpi_handle handle)\r\n{\r\nacpi_thermal_rel_handle = handle;\r\nreturn misc_register(&acpi_thermal_rel_misc_device);\r\n}\r\nint acpi_thermal_rel_misc_device_remove(acpi_handle handle)\r\n{\r\nmisc_deregister(&acpi_thermal_rel_misc_device);\r\nreturn 0;\r\n}
