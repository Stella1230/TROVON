static int elants_i2c_send(struct i2c_client *client,\r\nconst void *data, size_t size)\r\n{\r\nint ret;\r\nret = i2c_master_send(client, data, size);\r\nif (ret == size)\r\nreturn 0;\r\nif (ret >= 0)\r\nret = -EIO;\r\ndev_err(&client->dev, "%s failed (%*ph): %d\n",\r\n__func__, (int)size, data, ret);\r\nreturn ret;\r\n}\r\nstatic int elants_i2c_read(struct i2c_client *client, void *data, size_t size)\r\n{\r\nint ret;\r\nret = i2c_master_recv(client, data, size);\r\nif (ret == size)\r\nreturn 0;\r\nif (ret >= 0)\r\nret = -EIO;\r\ndev_err(&client->dev, "%s failed: %d\n", __func__, ret);\r\nreturn ret;\r\n}\r\nstatic int elants_i2c_execute_command(struct i2c_client *client,\r\nconst u8 *cmd, size_t cmd_size,\r\nu8 *resp, size_t resp_size)\r\n{\r\nstruct i2c_msg msgs[2];\r\nint ret;\r\nu8 expected_response;\r\nswitch (cmd[0]) {\r\ncase CMD_HEADER_READ:\r\nexpected_response = CMD_HEADER_RESP;\r\nbreak;\r\ncase CMD_HEADER_6B_READ:\r\nexpected_response = CMD_HEADER_6B_RESP;\r\nbreak;\r\ndefault:\r\ndev_err(&client->dev, "%s: invalid command %*ph\n",\r\n__func__, (int)cmd_size, cmd);\r\nreturn -EINVAL;\r\n}\r\nmsgs[0].addr = client->addr;\r\nmsgs[0].flags = client->flags & I2C_M_TEN;\r\nmsgs[0].len = cmd_size;\r\nmsgs[0].buf = (u8 *)cmd;\r\nmsgs[1].addr = client->addr;\r\nmsgs[1].flags = client->flags & I2C_M_TEN;\r\nmsgs[1].flags |= I2C_M_RD;\r\nmsgs[1].len = resp_size;\r\nmsgs[1].buf = resp;\r\nret = i2c_transfer(client->adapter, msgs, ARRAY_SIZE(msgs));\r\nif (ret < 0)\r\nreturn ret;\r\nif (ret != ARRAY_SIZE(msgs) || resp[FW_HDR_TYPE] != expected_response)\r\nreturn -EIO;\r\nreturn 0;\r\n}\r\nstatic int elants_i2c_calibrate(struct elants_data *ts)\r\n{\r\nstruct i2c_client *client = ts->client;\r\nint ret, error;\r\nstatic const u8 w_flashkey[] = { 0x54, 0xC0, 0xE1, 0x5A };\r\nstatic const u8 rek[] = { 0x54, 0x29, 0x00, 0x01 };\r\nstatic const u8 rek_resp[] = { CMD_HEADER_REK, 0x66, 0x66, 0x66 };\r\ndisable_irq(client->irq);\r\nts->state = ELAN_WAIT_RECALIBRATION;\r\nreinit_completion(&ts->cmd_done);\r\nelants_i2c_send(client, w_flashkey, sizeof(w_flashkey));\r\nelants_i2c_send(client, rek, sizeof(rek));\r\nenable_irq(client->irq);\r\nret = wait_for_completion_interruptible_timeout(&ts->cmd_done,\r\nmsecs_to_jiffies(ELAN_CALI_TIMEOUT_MSEC));\r\nts->state = ELAN_STATE_NORMAL;\r\nif (ret <= 0) {\r\nerror = ret < 0 ? ret : -ETIMEDOUT;\r\ndev_err(&client->dev,\r\n"error while waiting for calibration to complete: %d\n",\r\nerror);\r\nreturn error;\r\n}\r\nif (memcmp(rek_resp, ts->cmd_resp, sizeof(rek_resp))) {\r\ndev_err(&client->dev,\r\n"unexpected calibration response: %*ph\n",\r\n(int)sizeof(ts->cmd_resp), ts->cmd_resp);\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int elants_i2c_sw_reset(struct i2c_client *client)\r\n{\r\nconst u8 soft_rst_cmd[] = { 0x77, 0x77, 0x77, 0x77 };\r\nint error;\r\nerror = elants_i2c_send(client, soft_rst_cmd,\r\nsizeof(soft_rst_cmd));\r\nif (error) {\r\ndev_err(&client->dev, "software reset failed: %d\n", error);\r\nreturn error;\r\n}\r\nmsleep(30);\r\nreturn 0;\r\n}\r\nstatic u16 elants_i2c_parse_version(u8 *buf)\r\n{\r\nreturn get_unaligned_be32(buf) >> 4;\r\n}\r\nstatic int elants_i2c_query_fw_id(struct elants_data *ts)\r\n{\r\nstruct i2c_client *client = ts->client;\r\nint error, retry_cnt;\r\nconst u8 cmd[] = { CMD_HEADER_READ, E_ELAN_INFO_FW_ID, 0x00, 0x01 };\r\nu8 resp[HEADER_SIZE];\r\nfor (retry_cnt = 0; retry_cnt < MAX_RETRIES; retry_cnt++) {\r\nerror = elants_i2c_execute_command(client, cmd, sizeof(cmd),\r\nresp, sizeof(resp));\r\nif (!error) {\r\nts->hw_version = elants_i2c_parse_version(resp);\r\nif (ts->hw_version != 0xffff)\r\nreturn 0;\r\n}\r\ndev_dbg(&client->dev, "read fw id error=%d, buf=%*phC\n",\r\nerror, (int)sizeof(resp), resp);\r\n}\r\ndev_err(&client->dev,\r\n"Failed to read fw id or fw id is invalid\n");\r\nreturn -EINVAL;\r\n}\r\nstatic int elants_i2c_query_fw_version(struct elants_data *ts)\r\n{\r\nstruct i2c_client *client = ts->client;\r\nint error, retry_cnt;\r\nconst u8 cmd[] = { CMD_HEADER_READ, E_ELAN_INFO_FW_VER, 0x00, 0x01 };\r\nu8 resp[HEADER_SIZE];\r\nfor (retry_cnt = 0; retry_cnt < MAX_RETRIES; retry_cnt++) {\r\nerror = elants_i2c_execute_command(client, cmd, sizeof(cmd),\r\nresp, sizeof(resp));\r\nif (!error) {\r\nts->fw_version = elants_i2c_parse_version(resp);\r\nif (ts->fw_version != 0x0000 &&\r\nts->fw_version != 0xffff)\r\nreturn 0;\r\n}\r\ndev_dbg(&client->dev, "read fw version error=%d, buf=%*phC\n",\r\nerror, (int)sizeof(resp), resp);\r\n}\r\ndev_err(&client->dev,\r\n"Failed to read fw version or fw version is invalid\n");\r\nreturn -EINVAL;\r\n}\r\nstatic int elants_i2c_query_test_version(struct elants_data *ts)\r\n{\r\nstruct i2c_client *client = ts->client;\r\nint error, retry_cnt;\r\nu16 version;\r\nconst u8 cmd[] = { CMD_HEADER_READ, E_ELAN_INFO_TEST_VER, 0x00, 0x01 };\r\nu8 resp[HEADER_SIZE];\r\nfor (retry_cnt = 0; retry_cnt < MAX_RETRIES; retry_cnt++) {\r\nerror = elants_i2c_execute_command(client, cmd, sizeof(cmd),\r\nresp, sizeof(resp));\r\nif (!error) {\r\nversion = elants_i2c_parse_version(resp);\r\nts->test_version = version >> 8;\r\nts->solution_version = version & 0xff;\r\nreturn 0;\r\n}\r\ndev_dbg(&client->dev,\r\n"read test version error rc=%d, buf=%*phC\n",\r\nerror, (int)sizeof(resp), resp);\r\n}\r\ndev_err(&client->dev, "Failed to read test version\n");\r\nreturn -EINVAL;\r\n}\r\nstatic int elants_i2c_query_bc_version(struct elants_data *ts)\r\n{\r\nstruct i2c_client *client = ts->client;\r\nconst u8 cmd[] = { CMD_HEADER_READ, E_ELAN_INFO_BC_VER, 0x00, 0x01 };\r\nu8 resp[HEADER_SIZE];\r\nu16 version;\r\nint error;\r\nerror = elants_i2c_execute_command(client, cmd, sizeof(cmd),\r\nresp, sizeof(resp));\r\nif (error) {\r\ndev_err(&client->dev,\r\n"read BC version error=%d, buf=%*phC\n",\r\nerror, (int)sizeof(resp), resp);\r\nreturn error;\r\n}\r\nversion = elants_i2c_parse_version(resp);\r\nts->bc_version = version >> 8;\r\nts->iap_version = version & 0xff;\r\nreturn 0;\r\n}\r\nstatic int elants_i2c_query_ts_info(struct elants_data *ts)\r\n{\r\nstruct i2c_client *client = ts->client;\r\nint error;\r\nu8 resp[17];\r\nu16 phy_x, phy_y, rows, cols, osr;\r\nconst u8 get_resolution_cmd[] = {\r\nCMD_HEADER_6B_READ, 0x00, 0x00, 0x00, 0x00, 0x00\r\n};\r\nconst u8 get_osr_cmd[] = {\r\nCMD_HEADER_READ, E_INFO_OSR, 0x00, 0x01\r\n};\r\nconst u8 get_physical_scan_cmd[] = {\r\nCMD_HEADER_READ, E_INFO_PHY_SCAN, 0x00, 0x01\r\n};\r\nconst u8 get_physical_drive_cmd[] = {\r\nCMD_HEADER_READ, E_INFO_PHY_DRIVER, 0x00, 0x01\r\n};\r\nerror = elants_i2c_execute_command(client,\r\nget_resolution_cmd,\r\nsizeof(get_resolution_cmd),\r\nresp, sizeof(resp));\r\nif (error) {\r\ndev_err(&client->dev, "get resolution command failed: %d\n",\r\nerror);\r\nreturn error;\r\n}\r\nrows = resp[2] + resp[6] + resp[10];\r\ncols = resp[3] + resp[7] + resp[11];\r\nerror = elants_i2c_execute_command(client,\r\nget_osr_cmd, sizeof(get_osr_cmd),\r\nresp, sizeof(resp));\r\nif (error) {\r\ndev_err(&client->dev, "get osr command failed: %d\n",\r\nerror);\r\nreturn error;\r\n}\r\nosr = resp[3];\r\nerror = elants_i2c_execute_command(client,\r\nget_physical_scan_cmd,\r\nsizeof(get_physical_scan_cmd),\r\nresp, sizeof(resp));\r\nif (error) {\r\ndev_err(&client->dev, "get physical scan command failed: %d\n",\r\nerror);\r\nreturn error;\r\n}\r\nphy_x = get_unaligned_be16(&resp[2]);\r\nerror = elants_i2c_execute_command(client,\r\nget_physical_drive_cmd,\r\nsizeof(get_physical_drive_cmd),\r\nresp, sizeof(resp));\r\nif (error) {\r\ndev_err(&client->dev, "get physical drive command failed: %d\n",\r\nerror);\r\nreturn error;\r\n}\r\nphy_y = get_unaligned_be16(&resp[2]);\r\ndev_dbg(&client->dev, "phy_x=%d, phy_y=%d\n", phy_x, phy_y);\r\nif (rows == 0 || cols == 0 || osr == 0) {\r\ndev_warn(&client->dev,\r\n"invalid trace number data: %d, %d, %d\n",\r\nrows, cols, osr);\r\n} else {\r\nts->x_max = ELAN_TS_RESOLUTION(rows, osr);\r\nts->x_res = DIV_ROUND_CLOSEST(ts->x_max, phy_x);\r\nts->y_max = ELAN_TS_RESOLUTION(cols, osr);\r\nts->y_res = DIV_ROUND_CLOSEST(ts->y_max, phy_y);\r\n}\r\nreturn 0;\r\n}\r\nstatic int elants_i2c_fastboot(struct i2c_client *client)\r\n{\r\nconst u8 boot_cmd[] = { 0x4D, 0x61, 0x69, 0x6E };\r\nint error;\r\nerror = elants_i2c_send(client, boot_cmd, sizeof(boot_cmd));\r\nif (error) {\r\ndev_err(&client->dev, "boot failed: %d\n", error);\r\nreturn error;\r\n}\r\ndev_dbg(&client->dev, "boot success -- 0x%x\n", client->addr);\r\nreturn 0;\r\n}\r\nstatic int elants_i2c_initialize(struct elants_data *ts)\r\n{\r\nstruct i2c_client *client = ts->client;\r\nint error, retry_cnt;\r\nconst u8 hello_packet[] = { 0x55, 0x55, 0x55, 0x55 };\r\nconst u8 recov_packet[] = { 0x55, 0x55, 0x80, 0x80 };\r\nu8 buf[HEADER_SIZE];\r\nfor (retry_cnt = 0; retry_cnt < MAX_RETRIES; retry_cnt++) {\r\nerror = elants_i2c_sw_reset(client);\r\nif (error) {\r\nif (retry_cnt < MAX_RETRIES - 1)\r\ncontinue;\r\n}\r\nerror = elants_i2c_fastboot(client);\r\nif (error) {\r\nif (retry_cnt < MAX_RETRIES - 1)\r\ncontinue;\r\n}\r\nmsleep(BOOT_TIME_DELAY_MS);\r\nerror = elants_i2c_read(client, buf, sizeof(buf));\r\nif (error) {\r\ndev_err(&client->dev,\r\n"failed to read 'hello' packet: %d\n", error);\r\n} else if (!memcmp(buf, hello_packet, sizeof(hello_packet))) {\r\nts->iap_mode = ELAN_IAP_OPERATIONAL;\r\nbreak;\r\n} else if (!memcmp(buf, recov_packet, sizeof(recov_packet))) {\r\nerror = -EIO;\r\nbreak;\r\n} else {\r\nerror = -EINVAL;\r\ndev_err(&client->dev,\r\n"invalid 'hello' packet: %*ph\n",\r\n(int)sizeof(buf), buf);\r\n}\r\n}\r\nif (!error)\r\nerror = elants_i2c_query_fw_id(ts);\r\nif (!error)\r\nerror = elants_i2c_query_fw_version(ts);\r\nif (error) {\r\nts->iap_mode = ELAN_IAP_RECOVERY;\r\n} else {\r\nelants_i2c_query_test_version(ts);\r\nelants_i2c_query_bc_version(ts);\r\nelants_i2c_query_ts_info(ts);\r\n}\r\nreturn 0;\r\n}\r\nstatic int elants_i2c_fw_write_page(struct i2c_client *client,\r\nconst void *page)\r\n{\r\nconst u8 ack_ok[] = { 0xaa, 0xaa };\r\nu8 buf[2];\r\nint retry;\r\nint error;\r\nfor (retry = 0; retry < MAX_FW_UPDATE_RETRIES; retry++) {\r\nerror = elants_i2c_send(client, page, ELAN_FW_PAGESIZE);\r\nif (error) {\r\ndev_err(&client->dev,\r\n"IAP Write Page failed: %d\n", error);\r\ncontinue;\r\n}\r\nerror = elants_i2c_read(client, buf, 2);\r\nif (error) {\r\ndev_err(&client->dev,\r\n"IAP Ack read failed: %d\n", error);\r\nreturn error;\r\n}\r\nif (!memcmp(buf, ack_ok, sizeof(ack_ok)))\r\nreturn 0;\r\nerror = -EIO;\r\ndev_err(&client->dev,\r\n"IAP Get Ack Error [%02x:%02x]\n",\r\nbuf[0], buf[1]);\r\n}\r\nreturn error;\r\n}\r\nstatic int elants_i2c_do_update_firmware(struct i2c_client *client,\r\nconst struct firmware *fw,\r\nbool force)\r\n{\r\nconst u8 enter_iap[] = { 0x45, 0x49, 0x41, 0x50 };\r\nconst u8 enter_iap2[] = { 0x54, 0x00, 0x12, 0x34 };\r\nconst u8 iap_ack[] = { 0x55, 0xaa, 0x33, 0xcc };\r\nconst u8 close_idle[] = {0x54, 0x2c, 0x01, 0x01};\r\nu8 buf[HEADER_SIZE];\r\nu16 send_id;\r\nint page, n_fw_pages;\r\nint error;\r\nif (force) {\r\ndev_dbg(&client->dev, "Recovery mode procedure\n");\r\nerror = elants_i2c_send(client, enter_iap2, sizeof(enter_iap2));\r\n} else {\r\ndev_dbg(&client->dev, "Normal IAP procedure\n");\r\nerror = elants_i2c_send(client, close_idle, sizeof(close_idle));\r\nif (error)\r\ndev_err(&client->dev, "Failed close idle: %d\n", error);\r\nmsleep(60);\r\nelants_i2c_sw_reset(client);\r\nmsleep(20);\r\nerror = elants_i2c_send(client, enter_iap, sizeof(enter_iap));\r\n}\r\nif (error) {\r\ndev_err(&client->dev, "failed to enter IAP mode: %d\n", error);\r\nreturn error;\r\n}\r\nmsleep(20);\r\nerror = elants_i2c_read(client, buf, 4);\r\nif (error) {\r\ndev_err(&client->dev,\r\n"failed to read IAP acknowledgement: %d\n",\r\nerror);\r\nreturn error;\r\n}\r\nif (memcmp(buf, iap_ack, sizeof(iap_ack))) {\r\ndev_err(&client->dev,\r\n"failed to enter IAP: %*ph (expected %*ph)\n",\r\n(int)sizeof(buf), buf, (int)sizeof(iap_ack), iap_ack);\r\nreturn -EIO;\r\n}\r\ndev_info(&client->dev, "successfully entered IAP mode");\r\nsend_id = client->addr;\r\nerror = elants_i2c_send(client, &send_id, 1);\r\nif (error) {\r\ndev_err(&client->dev, "sending dummy byte failed: %d\n",\r\nerror);\r\nreturn error;\r\n}\r\nerror = elants_i2c_send(client, fw->data, ELAN_FW_PAGESIZE);\r\nif (error) {\r\ndev_err(&client->dev, "clearing of the last page failed: %d\n",\r\nerror);\r\nreturn error;\r\n}\r\nerror = elants_i2c_read(client, buf, 2);\r\nif (error) {\r\ndev_err(&client->dev,\r\n"failed to read ACK for clearing the last page: %d\n",\r\nerror);\r\nreturn error;\r\n}\r\nn_fw_pages = fw->size / ELAN_FW_PAGESIZE;\r\ndev_dbg(&client->dev, "IAP Pages = %d\n", n_fw_pages);\r\nfor (page = 0; page < n_fw_pages; page++) {\r\nerror = elants_i2c_fw_write_page(client,\r\nfw->data + page * ELAN_FW_PAGESIZE);\r\nif (error) {\r\ndev_err(&client->dev,\r\n"failed to write FW page %d: %d\n",\r\npage, error);\r\nreturn error;\r\n}\r\n}\r\nmsleep(300);\r\ndev_info(&client->dev, "firmware update completed\n");\r\nreturn 0;\r\n}\r\nstatic int elants_i2c_fw_update(struct elants_data *ts)\r\n{\r\nstruct i2c_client *client = ts->client;\r\nconst struct firmware *fw;\r\nchar *fw_name;\r\nint error;\r\nfw_name = kasprintf(GFP_KERNEL, "elants_i2c_%04x.bin", ts->hw_version);\r\nif (!fw_name)\r\nreturn -ENOMEM;\r\ndev_info(&client->dev, "requesting fw name = %s\n", fw_name);\r\nerror = request_firmware(&fw, fw_name, &client->dev);\r\nkfree(fw_name);\r\nif (error) {\r\ndev_err(&client->dev, "failed to request firmware: %d\n",\r\nerror);\r\nreturn error;\r\n}\r\nif (fw->size % ELAN_FW_PAGESIZE) {\r\ndev_err(&client->dev, "invalid firmware length: %zu\n",\r\nfw->size);\r\nerror = -EINVAL;\r\ngoto out;\r\n}\r\ndisable_irq(client->irq);\r\nerror = elants_i2c_do_update_firmware(client, fw,\r\nts->iap_mode == ELAN_IAP_RECOVERY);\r\nif (error) {\r\ndev_err(&client->dev, "firmware update failed: %d\n", error);\r\nts->iap_mode = ELAN_IAP_RECOVERY;\r\ngoto out_enable_irq;\r\n}\r\nerror = elants_i2c_initialize(ts);\r\nif (error) {\r\ndev_err(&client->dev,\r\n"failed to initialize device after firmware update: %d\n",\r\nerror);\r\nts->iap_mode = ELAN_IAP_RECOVERY;\r\ngoto out_enable_irq;\r\n}\r\nts->iap_mode = ELAN_IAP_OPERATIONAL;\r\nout_enable_irq:\r\nts->state = ELAN_STATE_NORMAL;\r\nenable_irq(client->irq);\r\nmsleep(100);\r\nif (!error)\r\nelants_i2c_calibrate(ts);\r\nout:\r\nrelease_firmware(fw);\r\nreturn error;\r\n}\r\nstatic void elants_i2c_mt_event(struct elants_data *ts, u8 *buf)\r\n{\r\nstruct input_dev *input = ts->input;\r\nunsigned int n_fingers;\r\nu16 finger_state;\r\nint i;\r\nn_fingers = buf[FW_POS_STATE + 1] & 0x0f;\r\nfinger_state = ((buf[FW_POS_STATE + 1] & 0x30) << 4) |\r\nbuf[FW_POS_STATE];\r\ndev_dbg(&ts->client->dev,\r\n"n_fingers: %u, state: %04x\n", n_fingers, finger_state);\r\nfor (i = 0; i < MAX_CONTACT_NUM && n_fingers; i++) {\r\nif (finger_state & 1) {\r\nunsigned int x, y, p, w;\r\nu8 *pos;\r\npos = &buf[FW_POS_XY + i * 3];\r\nx = (((u16)pos[0] & 0xf0) << 4) | pos[1];\r\ny = (((u16)pos[0] & 0x0f) << 8) | pos[2];\r\np = buf[FW_POS_PRESSURE + i];\r\nw = buf[FW_POS_WIDTH + i];\r\ndev_dbg(&ts->client->dev, "i=%d x=%d y=%d p=%d w=%d\n",\r\ni, x, y, p, w);\r\ninput_mt_slot(input, i);\r\ninput_mt_report_slot_state(input, MT_TOOL_FINGER, true);\r\ninput_event(input, EV_ABS, ABS_MT_POSITION_X, x);\r\ninput_event(input, EV_ABS, ABS_MT_POSITION_Y, y);\r\ninput_event(input, EV_ABS, ABS_MT_PRESSURE, p);\r\ninput_event(input, EV_ABS, ABS_MT_TOUCH_MAJOR, w);\r\nn_fingers--;\r\n}\r\nfinger_state >>= 1;\r\n}\r\ninput_mt_sync_frame(input);\r\ninput_sync(input);\r\n}\r\nstatic u8 elants_i2c_calculate_checksum(u8 *buf)\r\n{\r\nu8 checksum = 0;\r\nu8 i;\r\nfor (i = 0; i < FW_POS_CHECKSUM; i++)\r\nchecksum += buf[i];\r\nreturn checksum;\r\n}\r\nstatic void elants_i2c_event(struct elants_data *ts, u8 *buf)\r\n{\r\nu8 checksum = elants_i2c_calculate_checksum(buf);\r\nif (unlikely(buf[FW_POS_CHECKSUM] != checksum))\r\ndev_warn(&ts->client->dev,\r\n"%s: invalid checksum for packet %02x: %02x vs. %02x\n",\r\n__func__, buf[FW_POS_HEADER],\r\nchecksum, buf[FW_POS_CHECKSUM]);\r\nelse if (unlikely(buf[FW_POS_HEADER] != HEADER_REPORT_10_FINGER))\r\ndev_warn(&ts->client->dev,\r\n"%s: unknown packet type: %02x\n",\r\n__func__, buf[FW_POS_HEADER]);\r\nelse\r\nelants_i2c_mt_event(ts, buf);\r\n}\r\nstatic irqreturn_t elants_i2c_irq(int irq, void *_dev)\r\n{\r\nconst u8 wait_packet[] = { 0x64, 0x64, 0x64, 0x64 };\r\nstruct elants_data *ts = _dev;\r\nstruct i2c_client *client = ts->client;\r\nint report_count, report_len;\r\nint i;\r\nint len;\r\nlen = i2c_master_recv(client, ts->buf, sizeof(ts->buf));\r\nif (len < 0) {\r\ndev_err(&client->dev, "%s: failed to read data: %d\n",\r\n__func__, len);\r\ngoto out;\r\n}\r\ndev_dbg(&client->dev, "%s: packet %*ph\n",\r\n__func__, HEADER_SIZE, ts->buf);\r\nswitch (ts->state) {\r\ncase ELAN_WAIT_RECALIBRATION:\r\nif (ts->buf[FW_HDR_TYPE] == CMD_HEADER_REK) {\r\nmemcpy(ts->cmd_resp, ts->buf, sizeof(ts->cmd_resp));\r\ncomplete(&ts->cmd_done);\r\nts->state = ELAN_STATE_NORMAL;\r\n}\r\nbreak;\r\ncase ELAN_WAIT_QUEUE_HEADER:\r\nif (ts->buf[FW_HDR_TYPE] != QUEUE_HEADER_NORMAL)\r\nbreak;\r\nts->state = ELAN_STATE_NORMAL;\r\ncase ELAN_STATE_NORMAL:\r\nswitch (ts->buf[FW_HDR_TYPE]) {\r\ncase CMD_HEADER_HELLO:\r\ncase CMD_HEADER_RESP:\r\ncase CMD_HEADER_REK:\r\nbreak;\r\ncase QUEUE_HEADER_WAIT:\r\nif (memcmp(ts->buf, wait_packet, sizeof(wait_packet))) {\r\ndev_err(&client->dev,\r\n"invalid wait packet %*ph\n",\r\nHEADER_SIZE, ts->buf);\r\n} else {\r\nts->state = ELAN_WAIT_QUEUE_HEADER;\r\nudelay(30);\r\n}\r\nbreak;\r\ncase QUEUE_HEADER_SINGLE:\r\nelants_i2c_event(ts, &ts->buf[HEADER_SIZE]);\r\nbreak;\r\ncase QUEUE_HEADER_NORMAL:\r\nreport_count = ts->buf[FW_HDR_COUNT];\r\nif (report_count > 3) {\r\ndev_err(&client->dev,\r\n"too large report count: %*ph\n",\r\nHEADER_SIZE, ts->buf);\r\nbreak;\r\n}\r\nreport_len = ts->buf[FW_HDR_LENGTH] / report_count;\r\nif (report_len != PACKET_SIZE) {\r\ndev_err(&client->dev,\r\n"mismatching report length: %*ph\n",\r\nHEADER_SIZE, ts->buf);\r\nbreak;\r\n}\r\nfor (i = 0; i < report_count; i++) {\r\nu8 *buf = ts->buf + HEADER_SIZE +\r\ni * PACKET_SIZE;\r\nelants_i2c_event(ts, buf);\r\n}\r\nbreak;\r\ndefault:\r\ndev_err(&client->dev, "unknown packet %*ph\n",\r\nHEADER_SIZE, ts->buf);\r\nbreak;\r\n}\r\nbreak;\r\n}\r\nout:\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic ssize_t calibrate_store(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nstruct elants_data *ts = i2c_get_clientdata(client);\r\nint error;\r\nerror = mutex_lock_interruptible(&ts->sysfs_mutex);\r\nif (error)\r\nreturn error;\r\nerror = elants_i2c_calibrate(ts);\r\nmutex_unlock(&ts->sysfs_mutex);\r\nreturn error ?: count;\r\n}\r\nstatic ssize_t write_update_fw(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nstruct elants_data *ts = i2c_get_clientdata(client);\r\nint error;\r\nerror = mutex_lock_interruptible(&ts->sysfs_mutex);\r\nif (error)\r\nreturn error;\r\nerror = elants_i2c_fw_update(ts);\r\ndev_dbg(dev, "firmware update result: %d\n", error);\r\nmutex_unlock(&ts->sysfs_mutex);\r\nreturn error ?: count;\r\n}\r\nstatic ssize_t show_iap_mode(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nstruct elants_data *ts = i2c_get_clientdata(client);\r\nreturn sprintf(buf, "%s\n",\r\nts->iap_mode == ELAN_IAP_OPERATIONAL ?\r\n"Normal" : "Recovery");\r\n}\r\nstatic ssize_t elants_version_attribute_show(struct device *dev,\r\nstruct device_attribute *dattr,\r\nchar *buf)\r\n{\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nstruct elants_data *ts = i2c_get_clientdata(client);\r\nstruct elants_version_attribute *attr =\r\ncontainer_of(dattr, struct elants_version_attribute, dattr);\r\nu8 *field = (u8 *)((char *)ts + attr->field_offset);\r\nunsigned int fmt_size;\r\nunsigned int val;\r\nif (attr->field_size == 1) {\r\nval = *field;\r\nfmt_size = 2;\r\n} else {\r\nval = *(u16 *)field;\r\nfmt_size = 4;\r\n}\r\nreturn sprintf(buf, "%0*x\n", fmt_size, val);\r\n}\r\nstatic void elants_i2c_remove_sysfs_group(void *_data)\r\n{\r\nstruct elants_data *ts = _data;\r\nsysfs_remove_group(&ts->client->dev.kobj, &elants_attribute_group);\r\n}\r\nstatic int elants_i2c_power_on(struct elants_data *ts)\r\n{\r\nint error;\r\nif (IS_ERR_OR_NULL(ts->reset_gpio))\r\nreturn 0;\r\ngpiod_set_value_cansleep(ts->reset_gpio, 1);\r\nerror = regulator_enable(ts->vcc33);\r\nif (error) {\r\ndev_err(&ts->client->dev,\r\n"failed to enable vcc33 regulator: %d\n",\r\nerror);\r\ngoto release_reset_gpio;\r\n}\r\nerror = regulator_enable(ts->vccio);\r\nif (error) {\r\ndev_err(&ts->client->dev,\r\n"failed to enable vccio regulator: %d\n",\r\nerror);\r\nregulator_disable(ts->vcc33);\r\ngoto release_reset_gpio;\r\n}\r\nudelay(ELAN_POWERON_DELAY_USEC);\r\nrelease_reset_gpio:\r\ngpiod_set_value_cansleep(ts->reset_gpio, 0);\r\nif (error)\r\nreturn error;\r\nmsleep(ELAN_RESET_DELAY_MSEC);\r\nreturn 0;\r\n}\r\nstatic void elants_i2c_power_off(void *_data)\r\n{\r\nstruct elants_data *ts = _data;\r\nif (!IS_ERR_OR_NULL(ts->reset_gpio)) {\r\ngpiod_set_value_cansleep(ts->reset_gpio, 1);\r\nregulator_disable(ts->vccio);\r\nregulator_disable(ts->vcc33);\r\n}\r\n}\r\nstatic int elants_i2c_probe(struct i2c_client *client,\r\nconst struct i2c_device_id *id)\r\n{\r\nunion i2c_smbus_data dummy;\r\nstruct elants_data *ts;\r\nunsigned long irqflags;\r\nint error;\r\nif (!i2c_check_functionality(client->adapter, I2C_FUNC_I2C)) {\r\ndev_err(&client->dev,\r\n"%s: i2c check functionality error\n", DEVICE_NAME);\r\nreturn -ENXIO;\r\n}\r\nts = devm_kzalloc(&client->dev, sizeof(struct elants_data), GFP_KERNEL);\r\nif (!ts)\r\nreturn -ENOMEM;\r\nmutex_init(&ts->sysfs_mutex);\r\ninit_completion(&ts->cmd_done);\r\nts->client = client;\r\ni2c_set_clientdata(client, ts);\r\nts->vcc33 = devm_regulator_get(&client->dev, "vcc33");\r\nif (IS_ERR(ts->vcc33)) {\r\nerror = PTR_ERR(ts->vcc33);\r\nif (error != -EPROBE_DEFER)\r\ndev_err(&client->dev,\r\n"Failed to get 'vcc33' regulator: %d\n",\r\nerror);\r\nreturn error;\r\n}\r\nts->vccio = devm_regulator_get(&client->dev, "vccio");\r\nif (IS_ERR(ts->vccio)) {\r\nerror = PTR_ERR(ts->vccio);\r\nif (error != -EPROBE_DEFER)\r\ndev_err(&client->dev,\r\n"Failed to get 'vccio' regulator: %d\n",\r\nerror);\r\nreturn error;\r\n}\r\nts->reset_gpio = devm_gpiod_get(&client->dev, "reset", GPIOD_OUT_LOW);\r\nif (IS_ERR(ts->reset_gpio)) {\r\nerror = PTR_ERR(ts->reset_gpio);\r\nif (error == -EPROBE_DEFER)\r\nreturn error;\r\nif (error != -ENOENT && error != -ENOSYS) {\r\ndev_err(&client->dev,\r\n"failed to get reset gpio: %d\n",\r\nerror);\r\nreturn error;\r\n}\r\nts->keep_power_in_suspend = true;\r\n}\r\nerror = elants_i2c_power_on(ts);\r\nif (error)\r\nreturn error;\r\nerror = devm_add_action(&client->dev, elants_i2c_power_off, ts);\r\nif (error) {\r\ndev_err(&client->dev,\r\n"failed to install power off action: %d\n", error);\r\nelants_i2c_power_off(ts);\r\nreturn error;\r\n}\r\nif (i2c_smbus_xfer(client->adapter, client->addr, 0,\r\nI2C_SMBUS_READ, 0, I2C_SMBUS_BYTE, &dummy) < 0) {\r\ndev_err(&client->dev, "nothing at this address\n");\r\nreturn -ENXIO;\r\n}\r\nerror = elants_i2c_initialize(ts);\r\nif (error) {\r\ndev_err(&client->dev, "failed to initialize: %d\n", error);\r\nreturn error;\r\n}\r\nts->input = devm_input_allocate_device(&client->dev);\r\nif (!ts->input) {\r\ndev_err(&client->dev, "Failed to allocate input device\n");\r\nreturn -ENOMEM;\r\n}\r\nts->input->name = "Elan Touchscreen";\r\nts->input->id.bustype = BUS_I2C;\r\n__set_bit(BTN_TOUCH, ts->input->keybit);\r\n__set_bit(EV_ABS, ts->input->evbit);\r\n__set_bit(EV_KEY, ts->input->evbit);\r\ninput_set_abs_params(ts->input, ABS_X, 0, ts->x_max, 0, 0);\r\ninput_set_abs_params(ts->input, ABS_Y, 0, ts->y_max, 0, 0);\r\ninput_set_abs_params(ts->input, ABS_PRESSURE, 0, 255, 0, 0);\r\ninput_abs_set_res(ts->input, ABS_X, ts->x_res);\r\ninput_abs_set_res(ts->input, ABS_Y, ts->y_res);\r\nerror = input_mt_init_slots(ts->input, MAX_CONTACT_NUM,\r\nINPUT_MT_DIRECT | INPUT_MT_DROP_UNUSED);\r\nif (error) {\r\ndev_err(&client->dev,\r\n"failed to initialize MT slots: %d\n", error);\r\nreturn error;\r\n}\r\ninput_set_abs_params(ts->input, ABS_MT_POSITION_X, 0, ts->x_max, 0, 0);\r\ninput_set_abs_params(ts->input, ABS_MT_POSITION_Y, 0, ts->y_max, 0, 0);\r\ninput_set_abs_params(ts->input, ABS_MT_TOUCH_MAJOR, 0, 255, 0, 0);\r\ninput_set_abs_params(ts->input, ABS_MT_PRESSURE, 0, 255, 0, 0);\r\ninput_abs_set_res(ts->input, ABS_MT_POSITION_X, ts->x_res);\r\ninput_abs_set_res(ts->input, ABS_MT_POSITION_Y, ts->y_res);\r\ninput_set_drvdata(ts->input, ts);\r\nerror = input_register_device(ts->input);\r\nif (error) {\r\ndev_err(&client->dev,\r\n"unable to register input device: %d\n", error);\r\nreturn error;\r\n}\r\nirqflags = client->dev.of_node ? 0 : IRQF_TRIGGER_FALLING;\r\nerror = devm_request_threaded_irq(&client->dev, client->irq,\r\nNULL, elants_i2c_irq,\r\nirqflags | IRQF_ONESHOT,\r\nclient->name, ts);\r\nif (error) {\r\ndev_err(&client->dev, "Failed to register interrupt\n");\r\nreturn error;\r\n}\r\nif (!client->dev.of_node)\r\ndevice_init_wakeup(&client->dev, true);\r\nerror = sysfs_create_group(&client->dev.kobj, &elants_attribute_group);\r\nif (error) {\r\ndev_err(&client->dev, "failed to create sysfs attributes: %d\n",\r\nerror);\r\nreturn error;\r\n}\r\nerror = devm_add_action(&client->dev,\r\nelants_i2c_remove_sysfs_group, ts);\r\nif (error) {\r\nelants_i2c_remove_sysfs_group(ts);\r\ndev_err(&client->dev,\r\n"Failed to add sysfs cleanup action: %d\n",\r\nerror);\r\nreturn error;\r\n}\r\nreturn 0;\r\n}\r\nstatic int __maybe_unused elants_i2c_suspend(struct device *dev)\r\n{\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nstruct elants_data *ts = i2c_get_clientdata(client);\r\nconst u8 set_sleep_cmd[] = { 0x54, 0x50, 0x00, 0x01 };\r\nint retry_cnt;\r\nint error;\r\nif (ts->iap_mode != ELAN_IAP_OPERATIONAL)\r\nreturn -EBUSY;\r\ndisable_irq(client->irq);\r\nif (device_may_wakeup(dev)) {\r\nts->wake_irq_enabled = (enable_irq_wake(client->irq) == 0);\r\n} else if (ts->keep_power_in_suspend) {\r\nfor (retry_cnt = 0; retry_cnt < MAX_RETRIES; retry_cnt++) {\r\nerror = elants_i2c_send(client, set_sleep_cmd,\r\nsizeof(set_sleep_cmd));\r\nif (!error)\r\nbreak;\r\ndev_err(&client->dev,\r\n"suspend command failed: %d\n", error);\r\n}\r\n} else {\r\nelants_i2c_power_off(ts);\r\n}\r\nreturn 0;\r\n}\r\nstatic int __maybe_unused elants_i2c_resume(struct device *dev)\r\n{\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nstruct elants_data *ts = i2c_get_clientdata(client);\r\nconst u8 set_active_cmd[] = { 0x54, 0x58, 0x00, 0x01 };\r\nint retry_cnt;\r\nint error;\r\nif (device_may_wakeup(dev)) {\r\nif (ts->wake_irq_enabled)\r\ndisable_irq_wake(client->irq);\r\nelants_i2c_sw_reset(client);\r\n} else if (ts->keep_power_in_suspend) {\r\nfor (retry_cnt = 0; retry_cnt < MAX_RETRIES; retry_cnt++) {\r\nerror = elants_i2c_send(client, set_active_cmd,\r\nsizeof(set_active_cmd));\r\nif (!error)\r\nbreak;\r\ndev_err(&client->dev,\r\n"resume command failed: %d\n", error);\r\n}\r\n} else {\r\nelants_i2c_power_on(ts);\r\nelants_i2c_initialize(ts);\r\n}\r\nts->state = ELAN_STATE_NORMAL;\r\nenable_irq(client->irq);\r\nreturn 0;\r\n}
