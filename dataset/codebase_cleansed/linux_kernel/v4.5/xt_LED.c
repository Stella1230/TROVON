static unsigned int\r\nled_tg(struct sk_buff *skb, const struct xt_action_param *par)\r\n{\r\nconst struct xt_led_info *ledinfo = par->targinfo;\r\nstruct xt_led_info_internal *ledinternal = ledinfo->internal_data;\r\nunsigned long led_delay = XT_LED_BLINK_DELAY;\r\nif ((ledinfo->delay > 0) && ledinfo->always_blink &&\r\ntimer_pending(&ledinternal->timer))\r\nled_trigger_blink_oneshot(&ledinternal->netfilter_led_trigger,\r\n&led_delay, &led_delay, 1);\r\nelse\r\nled_trigger_event(&ledinternal->netfilter_led_trigger, LED_FULL);\r\nif (ledinfo->delay > 0) {\r\nmod_timer(&ledinternal->timer,\r\njiffies + msecs_to_jiffies(ledinfo->delay));\r\n} else if (ledinfo->delay == 0) {\r\nled_trigger_event(&ledinternal->netfilter_led_trigger, LED_OFF);\r\n}\r\nreturn XT_CONTINUE;\r\n}\r\nstatic void led_timeout_callback(unsigned long data)\r\n{\r\nstruct xt_led_info_internal *ledinternal = (struct xt_led_info_internal *)data;\r\nled_trigger_event(&ledinternal->netfilter_led_trigger, LED_OFF);\r\n}\r\nstatic struct xt_led_info_internal *led_trigger_lookup(const char *name)\r\n{\r\nstruct xt_led_info_internal *ledinternal;\r\nlist_for_each_entry(ledinternal, &xt_led_triggers, list) {\r\nif (!strcmp(name, ledinternal->netfilter_led_trigger.name)) {\r\nreturn ledinternal;\r\n}\r\n}\r\nreturn NULL;\r\n}\r\nstatic int led_tg_check(const struct xt_tgchk_param *par)\r\n{\r\nstruct xt_led_info *ledinfo = par->targinfo;\r\nstruct xt_led_info_internal *ledinternal;\r\nint err;\r\nif (ledinfo->id[0] == '\0') {\r\npr_info("No 'id' parameter given.\n");\r\nreturn -EINVAL;\r\n}\r\nmutex_lock(&xt_led_mutex);\r\nledinternal = led_trigger_lookup(ledinfo->id);\r\nif (ledinternal) {\r\nledinternal->refcnt++;\r\ngoto out;\r\n}\r\nerr = -ENOMEM;\r\nledinternal = kzalloc(sizeof(struct xt_led_info_internal), GFP_KERNEL);\r\nif (!ledinternal)\r\ngoto exit_mutex_only;\r\nledinternal->trigger_id = kstrdup(ledinfo->id, GFP_KERNEL);\r\nif (!ledinternal->trigger_id)\r\ngoto exit_internal_alloc;\r\nledinternal->refcnt = 1;\r\nledinternal->netfilter_led_trigger.name = ledinternal->trigger_id;\r\nerr = led_trigger_register(&ledinternal->netfilter_led_trigger);\r\nif (err) {\r\npr_err("Trigger name is already in use.\n");\r\ngoto exit_alloc;\r\n}\r\nif (ledinfo->delay > 0)\r\nsetup_timer(&ledinternal->timer, led_timeout_callback,\r\n(unsigned long)ledinternal);\r\nlist_add_tail(&ledinternal->list, &xt_led_triggers);\r\nout:\r\nmutex_unlock(&xt_led_mutex);\r\nledinfo->internal_data = ledinternal;\r\nreturn 0;\r\nexit_alloc:\r\nkfree(ledinternal->trigger_id);\r\nexit_internal_alloc:\r\nkfree(ledinternal);\r\nexit_mutex_only:\r\nmutex_unlock(&xt_led_mutex);\r\nreturn err;\r\n}\r\nstatic void led_tg_destroy(const struct xt_tgdtor_param *par)\r\n{\r\nconst struct xt_led_info *ledinfo = par->targinfo;\r\nstruct xt_led_info_internal *ledinternal = ledinfo->internal_data;\r\nmutex_lock(&xt_led_mutex);\r\nif (--ledinternal->refcnt) {\r\nmutex_unlock(&xt_led_mutex);\r\nreturn;\r\n}\r\nlist_del(&ledinternal->list);\r\nif (ledinfo->delay > 0)\r\ndel_timer_sync(&ledinternal->timer);\r\nled_trigger_unregister(&ledinternal->netfilter_led_trigger);\r\nmutex_unlock(&xt_led_mutex);\r\nkfree(ledinternal->trigger_id);\r\nkfree(ledinternal);\r\n}\r\nstatic int __init led_tg_init(void)\r\n{\r\nreturn xt_register_target(&led_tg_reg);\r\n}\r\nstatic void __exit led_tg_exit(void)\r\n{\r\nxt_unregister_target(&led_tg_reg);\r\n}
