static bool nft_rbtree_lookup(const struct nft_set *set, const u32 *key,\r\nconst struct nft_set_ext **ext)\r\n{\r\nconst struct nft_rbtree *priv = nft_set_priv(set);\r\nconst struct nft_rbtree_elem *rbe, *interval = NULL;\r\nconst struct rb_node *parent;\r\nu8 genmask = nft_genmask_cur(read_pnet(&set->pnet));\r\nint d;\r\nspin_lock_bh(&nft_rbtree_lock);\r\nparent = priv->root.rb_node;\r\nwhile (parent != NULL) {\r\nrbe = rb_entry(parent, struct nft_rbtree_elem, node);\r\nd = memcmp(nft_set_ext_key(&rbe->ext), key, set->klen);\r\nif (d < 0) {\r\nparent = parent->rb_left;\r\ninterval = rbe;\r\n} else if (d > 0)\r\nparent = parent->rb_right;\r\nelse {\r\nfound:\r\nif (!nft_set_elem_active(&rbe->ext, genmask)) {\r\nparent = parent->rb_left;\r\ncontinue;\r\n}\r\nif (nft_set_ext_exists(&rbe->ext, NFT_SET_EXT_FLAGS) &&\r\n*nft_set_ext_flags(&rbe->ext) &\r\nNFT_SET_ELEM_INTERVAL_END)\r\ngoto out;\r\nspin_unlock_bh(&nft_rbtree_lock);\r\n*ext = &rbe->ext;\r\nreturn true;\r\n}\r\n}\r\nif (set->flags & NFT_SET_INTERVAL && interval != NULL) {\r\nrbe = interval;\r\ngoto found;\r\n}\r\nout:\r\nspin_unlock_bh(&nft_rbtree_lock);\r\nreturn false;\r\n}\r\nstatic int __nft_rbtree_insert(const struct nft_set *set,\r\nstruct nft_rbtree_elem *new)\r\n{\r\nstruct nft_rbtree *priv = nft_set_priv(set);\r\nstruct nft_rbtree_elem *rbe;\r\nstruct rb_node *parent, **p;\r\nu8 genmask = nft_genmask_next(read_pnet(&set->pnet));\r\nint d;\r\nparent = NULL;\r\np = &priv->root.rb_node;\r\nwhile (*p != NULL) {\r\nparent = *p;\r\nrbe = rb_entry(parent, struct nft_rbtree_elem, node);\r\nd = memcmp(nft_set_ext_key(&rbe->ext),\r\nnft_set_ext_key(&new->ext),\r\nset->klen);\r\nif (d < 0)\r\np = &parent->rb_left;\r\nelse if (d > 0)\r\np = &parent->rb_right;\r\nelse {\r\nif (nft_set_elem_active(&rbe->ext, genmask))\r\nreturn -EEXIST;\r\np = &parent->rb_left;\r\n}\r\n}\r\nrb_link_node(&new->node, parent, p);\r\nrb_insert_color(&new->node, &priv->root);\r\nreturn 0;\r\n}\r\nstatic int nft_rbtree_insert(const struct nft_set *set,\r\nconst struct nft_set_elem *elem)\r\n{\r\nstruct nft_rbtree_elem *rbe = elem->priv;\r\nint err;\r\nspin_lock_bh(&nft_rbtree_lock);\r\nerr = __nft_rbtree_insert(set, rbe);\r\nspin_unlock_bh(&nft_rbtree_lock);\r\nreturn err;\r\n}\r\nstatic void nft_rbtree_remove(const struct nft_set *set,\r\nconst struct nft_set_elem *elem)\r\n{\r\nstruct nft_rbtree *priv = nft_set_priv(set);\r\nstruct nft_rbtree_elem *rbe = elem->priv;\r\nspin_lock_bh(&nft_rbtree_lock);\r\nrb_erase(&rbe->node, &priv->root);\r\nspin_unlock_bh(&nft_rbtree_lock);\r\n}\r\nstatic void nft_rbtree_activate(const struct nft_set *set,\r\nconst struct nft_set_elem *elem)\r\n{\r\nstruct nft_rbtree_elem *rbe = elem->priv;\r\nnft_set_elem_change_active(set, &rbe->ext);\r\n}\r\nstatic void *nft_rbtree_deactivate(const struct nft_set *set,\r\nconst struct nft_set_elem *elem)\r\n{\r\nconst struct nft_rbtree *priv = nft_set_priv(set);\r\nconst struct rb_node *parent = priv->root.rb_node;\r\nstruct nft_rbtree_elem *rbe;\r\nu8 genmask = nft_genmask_cur(read_pnet(&set->pnet));\r\nint d;\r\nwhile (parent != NULL) {\r\nrbe = rb_entry(parent, struct nft_rbtree_elem, node);\r\nd = memcmp(nft_set_ext_key(&rbe->ext), &elem->key.val,\r\nset->klen);\r\nif (d < 0)\r\nparent = parent->rb_left;\r\nelse if (d > 0)\r\nparent = parent->rb_right;\r\nelse {\r\nif (!nft_set_elem_active(&rbe->ext, genmask)) {\r\nparent = parent->rb_left;\r\ncontinue;\r\n}\r\nnft_set_elem_change_active(set, &rbe->ext);\r\nreturn rbe;\r\n}\r\n}\r\nreturn NULL;\r\n}\r\nstatic void nft_rbtree_walk(const struct nft_ctx *ctx,\r\nconst struct nft_set *set,\r\nstruct nft_set_iter *iter)\r\n{\r\nconst struct nft_rbtree *priv = nft_set_priv(set);\r\nstruct nft_rbtree_elem *rbe;\r\nstruct nft_set_elem elem;\r\nstruct rb_node *node;\r\nu8 genmask = nft_genmask_cur(read_pnet(&set->pnet));\r\nspin_lock_bh(&nft_rbtree_lock);\r\nfor (node = rb_first(&priv->root); node != NULL; node = rb_next(node)) {\r\nrbe = rb_entry(node, struct nft_rbtree_elem, node);\r\nif (iter->count < iter->skip)\r\ngoto cont;\r\nif (!nft_set_elem_active(&rbe->ext, genmask))\r\ngoto cont;\r\nelem.priv = rbe;\r\niter->err = iter->fn(ctx, set, iter, &elem);\r\nif (iter->err < 0) {\r\nspin_unlock_bh(&nft_rbtree_lock);\r\nreturn;\r\n}\r\ncont:\r\niter->count++;\r\n}\r\nspin_unlock_bh(&nft_rbtree_lock);\r\n}\r\nstatic unsigned int nft_rbtree_privsize(const struct nlattr * const nla[])\r\n{\r\nreturn sizeof(struct nft_rbtree);\r\n}\r\nstatic int nft_rbtree_init(const struct nft_set *set,\r\nconst struct nft_set_desc *desc,\r\nconst struct nlattr * const nla[])\r\n{\r\nstruct nft_rbtree *priv = nft_set_priv(set);\r\npriv->root = RB_ROOT;\r\nreturn 0;\r\n}\r\nstatic void nft_rbtree_destroy(const struct nft_set *set)\r\n{\r\nstruct nft_rbtree *priv = nft_set_priv(set);\r\nstruct nft_rbtree_elem *rbe;\r\nstruct rb_node *node;\r\nwhile ((node = priv->root.rb_node) != NULL) {\r\nrb_erase(node, &priv->root);\r\nrbe = rb_entry(node, struct nft_rbtree_elem, node);\r\nnft_set_elem_destroy(set, rbe);\r\n}\r\n}\r\nstatic bool nft_rbtree_estimate(const struct nft_set_desc *desc, u32 features,\r\nstruct nft_set_estimate *est)\r\n{\r\nunsigned int nsize;\r\nnsize = sizeof(struct nft_rbtree_elem);\r\nif (desc->size)\r\nest->size = sizeof(struct nft_rbtree) + desc->size * nsize;\r\nelse\r\nest->size = nsize;\r\nest->class = NFT_SET_CLASS_O_LOG_N;\r\nreturn true;\r\n}\r\nstatic int __init nft_rbtree_module_init(void)\r\n{\r\nreturn nft_register_set(&nft_rbtree_ops);\r\n}\r\nstatic void __exit nft_rbtree_module_exit(void)\r\n{\r\nnft_unregister_set(&nft_rbtree_ops);\r\n}
