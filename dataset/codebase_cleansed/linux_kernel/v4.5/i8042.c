void i8042_lock_chip(void)\r\n{\r\nmutex_lock(&i8042_mutex);\r\n}\r\nvoid i8042_unlock_chip(void)\r\n{\r\nmutex_unlock(&i8042_mutex);\r\n}\r\nint i8042_install_filter(bool (*filter)(unsigned char data, unsigned char str,\r\nstruct serio *serio))\r\n{\r\nunsigned long flags;\r\nint ret = 0;\r\nspin_lock_irqsave(&i8042_lock, flags);\r\nif (i8042_platform_filter) {\r\nret = -EBUSY;\r\ngoto out;\r\n}\r\ni8042_platform_filter = filter;\r\nout:\r\nspin_unlock_irqrestore(&i8042_lock, flags);\r\nreturn ret;\r\n}\r\nint i8042_remove_filter(bool (*filter)(unsigned char data, unsigned char str,\r\nstruct serio *port))\r\n{\r\nunsigned long flags;\r\nint ret = 0;\r\nspin_lock_irqsave(&i8042_lock, flags);\r\nif (i8042_platform_filter != filter) {\r\nret = -EINVAL;\r\ngoto out;\r\n}\r\ni8042_platform_filter = NULL;\r\nout:\r\nspin_unlock_irqrestore(&i8042_lock, flags);\r\nreturn ret;\r\n}\r\nstatic int i8042_wait_read(void)\r\n{\r\nint i = 0;\r\nwhile ((~i8042_read_status() & I8042_STR_OBF) && (i < I8042_CTL_TIMEOUT)) {\r\nudelay(50);\r\ni++;\r\n}\r\nreturn -(i == I8042_CTL_TIMEOUT);\r\n}\r\nstatic int i8042_wait_write(void)\r\n{\r\nint i = 0;\r\nwhile ((i8042_read_status() & I8042_STR_IBF) && (i < I8042_CTL_TIMEOUT)) {\r\nudelay(50);\r\ni++;\r\n}\r\nreturn -(i == I8042_CTL_TIMEOUT);\r\n}\r\nstatic int i8042_flush(void)\r\n{\r\nunsigned long flags;\r\nunsigned char data, str;\r\nint count = 0;\r\nint retval = 0;\r\nspin_lock_irqsave(&i8042_lock, flags);\r\nwhile ((str = i8042_read_status()) & I8042_STR_OBF) {\r\nif (count++ < I8042_BUFFER_SIZE) {\r\nudelay(50);\r\ndata = i8042_read_data();\r\ndbg("%02x <- i8042 (flush, %s)\n",\r\ndata, str & I8042_STR_AUXDATA ? "aux" : "kbd");\r\n} else {\r\nretval = -EIO;\r\nbreak;\r\n}\r\n}\r\nspin_unlock_irqrestore(&i8042_lock, flags);\r\nreturn retval;\r\n}\r\nstatic int __i8042_command(unsigned char *param, int command)\r\n{\r\nint i, error;\r\nif (i8042_noloop && command == I8042_CMD_AUX_LOOP)\r\nreturn -1;\r\nerror = i8042_wait_write();\r\nif (error)\r\nreturn error;\r\ndbg("%02x -> i8042 (command)\n", command & 0xff);\r\ni8042_write_command(command & 0xff);\r\nfor (i = 0; i < ((command >> 12) & 0xf); i++) {\r\nerror = i8042_wait_write();\r\nif (error)\r\nreturn error;\r\ndbg("%02x -> i8042 (parameter)\n", param[i]);\r\ni8042_write_data(param[i]);\r\n}\r\nfor (i = 0; i < ((command >> 8) & 0xf); i++) {\r\nerror = i8042_wait_read();\r\nif (error) {\r\ndbg(" -- i8042 (timeout)\n");\r\nreturn error;\r\n}\r\nif (command == I8042_CMD_AUX_LOOP &&\r\n!(i8042_read_status() & I8042_STR_AUXDATA)) {\r\ndbg(" -- i8042 (auxerr)\n");\r\nreturn -1;\r\n}\r\nparam[i] = i8042_read_data();\r\ndbg("%02x <- i8042 (return)\n", param[i]);\r\n}\r\nreturn 0;\r\n}\r\nint i8042_command(unsigned char *param, int command)\r\n{\r\nunsigned long flags;\r\nint retval;\r\nspin_lock_irqsave(&i8042_lock, flags);\r\nretval = __i8042_command(param, command);\r\nspin_unlock_irqrestore(&i8042_lock, flags);\r\nreturn retval;\r\n}\r\nstatic int i8042_kbd_write(struct serio *port, unsigned char c)\r\n{\r\nunsigned long flags;\r\nint retval = 0;\r\nspin_lock_irqsave(&i8042_lock, flags);\r\nif (!(retval = i8042_wait_write())) {\r\ndbg("%02x -> i8042 (kbd-data)\n", c);\r\ni8042_write_data(c);\r\n}\r\nspin_unlock_irqrestore(&i8042_lock, flags);\r\nreturn retval;\r\n}\r\nstatic int i8042_aux_write(struct serio *serio, unsigned char c)\r\n{\r\nstruct i8042_port *port = serio->port_data;\r\nreturn i8042_command(&c, port->mux == -1 ?\r\nI8042_CMD_AUX_SEND :\r\nI8042_CMD_MUX_SEND + port->mux);\r\n}\r\nstatic void i8042_port_close(struct serio *serio)\r\n{\r\nint irq_bit;\r\nint disable_bit;\r\nconst char *port_name;\r\nif (serio == i8042_ports[I8042_AUX_PORT_NO].serio) {\r\nirq_bit = I8042_CTR_AUXINT;\r\ndisable_bit = I8042_CTR_AUXDIS;\r\nport_name = "AUX";\r\n} else {\r\nirq_bit = I8042_CTR_KBDINT;\r\ndisable_bit = I8042_CTR_KBDDIS;\r\nport_name = "KBD";\r\n}\r\ni8042_ctr &= ~irq_bit;\r\nif (i8042_command(&i8042_ctr, I8042_CMD_CTL_WCTR))\r\npr_warn("Can't write CTR while closing %s port\n", port_name);\r\nudelay(50);\r\ni8042_ctr &= ~disable_bit;\r\ni8042_ctr |= irq_bit;\r\nif (i8042_command(&i8042_ctr, I8042_CMD_CTL_WCTR))\r\npr_err("Can't reactivate %s port\n", port_name);\r\ni8042_interrupt(0, NULL);\r\n}\r\nstatic int i8042_start(struct serio *serio)\r\n{\r\nstruct i8042_port *port = serio->port_data;\r\nport->exists = true;\r\nmb();\r\nreturn 0;\r\n}\r\nstatic void i8042_stop(struct serio *serio)\r\n{\r\nstruct i8042_port *port = serio->port_data;\r\nport->exists = false;\r\nsynchronize_irq(I8042_AUX_IRQ);\r\nsynchronize_irq(I8042_KBD_IRQ);\r\nport->serio = NULL;\r\n}\r\nstatic bool i8042_filter(unsigned char data, unsigned char str,\r\nstruct serio *serio)\r\n{\r\nif (unlikely(i8042_suppress_kbd_ack)) {\r\nif ((~str & I8042_STR_AUXDATA) &&\r\n(data == 0xfa || data == 0xfe)) {\r\ni8042_suppress_kbd_ack--;\r\ndbg("Extra keyboard ACK - filtered out\n");\r\nreturn true;\r\n}\r\n}\r\nif (i8042_platform_filter && i8042_platform_filter(data, str, serio)) {\r\ndbg("Filtered out by platform filter\n");\r\nreturn true;\r\n}\r\nreturn false;\r\n}\r\nstatic irqreturn_t i8042_interrupt(int irq, void *dev_id)\r\n{\r\nstruct i8042_port *port;\r\nstruct serio *serio;\r\nunsigned long flags;\r\nunsigned char str, data;\r\nunsigned int dfl;\r\nunsigned int port_no;\r\nbool filtered;\r\nint ret = 1;\r\nspin_lock_irqsave(&i8042_lock, flags);\r\nstr = i8042_read_status();\r\nif (unlikely(~str & I8042_STR_OBF)) {\r\nspin_unlock_irqrestore(&i8042_lock, flags);\r\nif (irq)\r\ndbg("Interrupt %d, without any data\n", irq);\r\nret = 0;\r\ngoto out;\r\n}\r\ndata = i8042_read_data();\r\nif (i8042_mux_present && (str & I8042_STR_AUXDATA)) {\r\nstatic unsigned long last_transmit;\r\nstatic unsigned char last_str;\r\ndfl = 0;\r\nif (str & I8042_STR_MUXERR) {\r\ndbg("MUX error, status is %02x, data is %02x\n",\r\nstr, data);\r\nswitch (data) {\r\ndefault:\r\nif (time_before(jiffies, last_transmit + HZ/10)) {\r\nstr = last_str;\r\nbreak;\r\n}\r\ncase 0xfc:\r\ncase 0xfd:\r\ncase 0xfe: dfl = SERIO_TIMEOUT; data = 0xfe; break;\r\ncase 0xff: dfl = SERIO_PARITY; data = 0xfe; break;\r\n}\r\n}\r\nport_no = I8042_MUX_PORT_NO + ((str >> 6) & 3);\r\nlast_str = str;\r\nlast_transmit = jiffies;\r\n} else {\r\ndfl = ((str & I8042_STR_PARITY) ? SERIO_PARITY : 0) |\r\n((str & I8042_STR_TIMEOUT && !i8042_notimeout) ? SERIO_TIMEOUT : 0);\r\nport_no = (str & I8042_STR_AUXDATA) ?\r\nI8042_AUX_PORT_NO : I8042_KBD_PORT_NO;\r\n}\r\nport = &i8042_ports[port_no];\r\nserio = port->exists ? port->serio : NULL;\r\nfilter_dbg(port->driver_bound, data, "<- i8042 (interrupt, %d, %d%s%s)\n",\r\nport_no, irq,\r\ndfl & SERIO_PARITY ? ", bad parity" : "",\r\ndfl & SERIO_TIMEOUT ? ", timeout" : "");\r\nfiltered = i8042_filter(data, str, serio);\r\nspin_unlock_irqrestore(&i8042_lock, flags);\r\nif (likely(port->exists && !filtered))\r\nserio_interrupt(serio, data, dfl);\r\nout:\r\nreturn IRQ_RETVAL(ret);\r\n}\r\nstatic int i8042_enable_kbd_port(void)\r\n{\r\ni8042_ctr &= ~I8042_CTR_KBDDIS;\r\ni8042_ctr |= I8042_CTR_KBDINT;\r\nif (i8042_command(&i8042_ctr, I8042_CMD_CTL_WCTR)) {\r\ni8042_ctr &= ~I8042_CTR_KBDINT;\r\ni8042_ctr |= I8042_CTR_KBDDIS;\r\npr_err("Failed to enable KBD port\n");\r\nreturn -EIO;\r\n}\r\nreturn 0;\r\n}\r\nstatic int i8042_enable_aux_port(void)\r\n{\r\ni8042_ctr &= ~I8042_CTR_AUXDIS;\r\ni8042_ctr |= I8042_CTR_AUXINT;\r\nif (i8042_command(&i8042_ctr, I8042_CMD_CTL_WCTR)) {\r\ni8042_ctr &= ~I8042_CTR_AUXINT;\r\ni8042_ctr |= I8042_CTR_AUXDIS;\r\npr_err("Failed to enable AUX port\n");\r\nreturn -EIO;\r\n}\r\nreturn 0;\r\n}\r\nstatic int i8042_enable_mux_ports(void)\r\n{\r\nunsigned char param;\r\nint i;\r\nfor (i = 0; i < I8042_NUM_MUX_PORTS; i++) {\r\ni8042_command(&param, I8042_CMD_MUX_PFX + i);\r\ni8042_command(&param, I8042_CMD_AUX_ENABLE);\r\n}\r\nreturn i8042_enable_aux_port();\r\n}\r\nstatic int i8042_set_mux_mode(bool multiplex, unsigned char *mux_version)\r\n{\r\nunsigned char param, val;\r\ni8042_flush();\r\nparam = val = 0xf0;\r\nif (i8042_command(&param, I8042_CMD_AUX_LOOP) || param != val)\r\nreturn -1;\r\nparam = val = multiplex ? 0x56 : 0xf6;\r\nif (i8042_command(&param, I8042_CMD_AUX_LOOP) || param != val)\r\nreturn -1;\r\nparam = val = multiplex ? 0xa4 : 0xa5;\r\nif (i8042_command(&param, I8042_CMD_AUX_LOOP) || param == val)\r\nreturn -1;\r\nif (param == 0xac)\r\nreturn -1;\r\nif (mux_version)\r\n*mux_version = param;\r\nreturn 0;\r\n}\r\nstatic int __init i8042_check_mux(void)\r\n{\r\nunsigned char mux_version;\r\nif (i8042_set_mux_mode(true, &mux_version))\r\nreturn -1;\r\npr_info("Detected active multiplexing controller, rev %d.%d\n",\r\n(mux_version >> 4) & 0xf, mux_version & 0xf);\r\ni8042_ctr |= I8042_CTR_AUXDIS;\r\ni8042_ctr &= ~I8042_CTR_AUXINT;\r\nif (i8042_command(&i8042_ctr, I8042_CMD_CTL_WCTR)) {\r\npr_err("Failed to disable AUX port, can't use MUX\n");\r\nreturn -EIO;\r\n}\r\ni8042_mux_present = true;\r\nreturn 0;\r\n}\r\nstatic irqreturn_t __init i8042_aux_test_irq(int irq, void *dev_id)\r\n{\r\nunsigned long flags;\r\nunsigned char str, data;\r\nint ret = 0;\r\nspin_lock_irqsave(&i8042_lock, flags);\r\nstr = i8042_read_status();\r\nif (str & I8042_STR_OBF) {\r\ndata = i8042_read_data();\r\ndbg("%02x <- i8042 (aux_test_irq, %s)\n",\r\ndata, str & I8042_STR_AUXDATA ? "aux" : "kbd");\r\nif (i8042_irq_being_tested &&\r\ndata == 0xa5 && (str & I8042_STR_AUXDATA))\r\ncomplete(&i8042_aux_irq_delivered);\r\nret = 1;\r\n}\r\nspin_unlock_irqrestore(&i8042_lock, flags);\r\nreturn IRQ_RETVAL(ret);\r\n}\r\nstatic int __init i8042_toggle_aux(bool on)\r\n{\r\nunsigned char param;\r\nint i;\r\nif (i8042_command(&param,\r\non ? I8042_CMD_AUX_ENABLE : I8042_CMD_AUX_DISABLE))\r\nreturn -1;\r\nfor (i = 0; i < 100; i++) {\r\nudelay(50);\r\nif (i8042_command(&param, I8042_CMD_CTL_RCTR))\r\nreturn -1;\r\nif (!(param & I8042_CTR_AUXDIS) == on)\r\nreturn 0;\r\n}\r\nreturn -1;\r\n}\r\nstatic int __init i8042_check_aux(void)\r\n{\r\nint retval = -1;\r\nbool irq_registered = false;\r\nbool aux_loop_broken = false;\r\nunsigned long flags;\r\nunsigned char param;\r\ni8042_flush();\r\nparam = 0x5a;\r\nretval = i8042_command(&param, I8042_CMD_AUX_LOOP);\r\nif (retval || param != 0x5a) {\r\nif (i8042_command(&param, I8042_CMD_AUX_TEST) ||\r\n(param && param != 0xfa && param != 0xff))\r\nreturn -1;\r\nif (!retval)\r\naux_loop_broken = true;\r\n}\r\nif (i8042_toggle_aux(false)) {\r\npr_warn("Failed to disable AUX port, but continuing anyway... Is this a SiS?\n");\r\npr_warn("If AUX port is really absent please use the 'i8042.noaux' option\n");\r\n}\r\nif (i8042_toggle_aux(true))\r\nreturn -1;\r\nif (i8042_kbdreset) {\r\npr_warn("Attempting to reset device connected to KBD port\n");\r\ni8042_kbd_write(NULL, (unsigned char) 0xff);\r\n}\r\nif (i8042_noloop || i8042_bypass_aux_irq_test || aux_loop_broken) {\r\nretval = 0;\r\ngoto out;\r\n}\r\nif (request_irq(I8042_AUX_IRQ, i8042_aux_test_irq, IRQF_SHARED,\r\n"i8042", i8042_platform_device))\r\ngoto out;\r\nirq_registered = true;\r\nif (i8042_enable_aux_port())\r\ngoto out;\r\nspin_lock_irqsave(&i8042_lock, flags);\r\ninit_completion(&i8042_aux_irq_delivered);\r\ni8042_irq_being_tested = true;\r\nparam = 0xa5;\r\nretval = __i8042_command(&param, I8042_CMD_AUX_LOOP & 0xf0ff);\r\nspin_unlock_irqrestore(&i8042_lock, flags);\r\nif (retval)\r\ngoto out;\r\nif (wait_for_completion_timeout(&i8042_aux_irq_delivered,\r\nmsecs_to_jiffies(250)) == 0) {\r\ndbg(" -- i8042 (aux irq test timeout)\n");\r\ni8042_flush();\r\nretval = -1;\r\n}\r\nout:\r\ni8042_ctr |= I8042_CTR_AUXDIS;\r\ni8042_ctr &= ~I8042_CTR_AUXINT;\r\nif (i8042_command(&i8042_ctr, I8042_CMD_CTL_WCTR))\r\nretval = -1;\r\nif (irq_registered)\r\nfree_irq(I8042_AUX_IRQ, i8042_platform_device);\r\nreturn retval;\r\n}\r\nstatic int i8042_controller_check(void)\r\n{\r\nif (i8042_flush()) {\r\npr_info("No controller found\n");\r\nreturn -ENODEV;\r\n}\r\nreturn 0;\r\n}\r\nstatic int i8042_controller_selftest(void)\r\n{\r\nunsigned char param;\r\nint i = 0;\r\ndo {\r\nif (i8042_command(&param, I8042_CMD_CTL_TEST)) {\r\npr_err("i8042 controller selftest timeout\n");\r\nreturn -ENODEV;\r\n}\r\nif (param == I8042_RET_CTL_TEST)\r\nreturn 0;\r\ndbg("i8042 controller selftest: %#x != %#x\n",\r\nparam, I8042_RET_CTL_TEST);\r\nmsleep(50);\r\n} while (i++ < 5);\r\n#ifdef CONFIG_X86\r\npr_info("giving up on controller selftest, continuing anyway...\n");\r\nreturn 0;\r\n#else\r\npr_err("i8042 controller selftest failed\n");\r\nreturn -EIO;\r\n#endif\r\n}\r\nstatic int i8042_controller_init(void)\r\n{\r\nunsigned long flags;\r\nint n = 0;\r\nunsigned char ctr[2];\r\ndo {\r\nif (n >= 10) {\r\npr_err("Unable to get stable CTR read\n");\r\nreturn -EIO;\r\n}\r\nif (n != 0)\r\nudelay(50);\r\nif (i8042_command(&ctr[n++ % 2], I8042_CMD_CTL_RCTR)) {\r\npr_err("Can't read CTR while initializing i8042\n");\r\nreturn -EIO;\r\n}\r\n} while (n < 2 || ctr[0] != ctr[1]);\r\ni8042_initial_ctr = i8042_ctr = ctr[0];\r\ni8042_ctr |= I8042_CTR_KBDDIS;\r\ni8042_ctr &= ~I8042_CTR_KBDINT;\r\nspin_lock_irqsave(&i8042_lock, flags);\r\nif (~i8042_read_status() & I8042_STR_KEYLOCK) {\r\nif (i8042_unlock)\r\ni8042_ctr |= I8042_CTR_IGNKEYLOCK;\r\nelse\r\npr_warn("Warning: Keylock active\n");\r\n}\r\nspin_unlock_irqrestore(&i8042_lock, flags);\r\nif (~i8042_ctr & I8042_CTR_XLATE)\r\ni8042_direct = true;\r\nif (i8042_direct)\r\ni8042_ctr &= ~I8042_CTR_XLATE;\r\nif (i8042_command(&i8042_ctr, I8042_CMD_CTL_WCTR)) {\r\npr_err("Can't write CTR while initializing i8042\n");\r\nreturn -EIO;\r\n}\r\ni8042_flush();\r\nreturn 0;\r\n}\r\nstatic void i8042_controller_reset(bool force_reset)\r\n{\r\ni8042_flush();\r\ni8042_ctr |= I8042_CTR_KBDDIS | I8042_CTR_AUXDIS;\r\ni8042_ctr &= ~(I8042_CTR_KBDINT | I8042_CTR_AUXINT);\r\nif (i8042_command(&i8042_ctr, I8042_CMD_CTL_WCTR))\r\npr_warn("Can't write CTR while resetting\n");\r\nif (i8042_mux_present)\r\ni8042_set_mux_mode(false, NULL);\r\nif (i8042_reset || force_reset)\r\ni8042_controller_selftest();\r\nif (i8042_command(&i8042_initial_ctr, I8042_CMD_CTL_WCTR))\r\npr_warn("Can't restore CTR\n");\r\n}\r\nstatic long i8042_panic_blink(int state)\r\n{\r\nlong delay = 0;\r\nchar led;\r\nled = (state) ? 0x01 | 0x04 : 0;\r\nwhile (i8042_read_status() & I8042_STR_IBF)\r\nDELAY;\r\ndbg("%02x -> i8042 (panic blink)\n", 0xed);\r\ni8042_suppress_kbd_ack = 2;\r\ni8042_write_data(0xed);\r\nDELAY;\r\nwhile (i8042_read_status() & I8042_STR_IBF)\r\nDELAY;\r\nDELAY;\r\ndbg("%02x -> i8042 (panic blink)\n", led);\r\ni8042_write_data(led);\r\nDELAY;\r\nreturn delay;\r\n}\r\nstatic void i8042_dritek_enable(void)\r\n{\r\nunsigned char param = 0x90;\r\nint error;\r\nerror = i8042_command(&param, 0x1059);\r\nif (error)\r\npr_warn("Failed to enable DRITEK extension: %d\n", error);\r\n}\r\nstatic int i8042_controller_resume(bool force_reset)\r\n{\r\nint error;\r\nerror = i8042_controller_check();\r\nif (error)\r\nreturn error;\r\nif (i8042_reset || force_reset) {\r\nerror = i8042_controller_selftest();\r\nif (error)\r\nreturn error;\r\n}\r\ni8042_ctr = i8042_initial_ctr;\r\nif (i8042_direct)\r\ni8042_ctr &= ~I8042_CTR_XLATE;\r\ni8042_ctr |= I8042_CTR_AUXDIS | I8042_CTR_KBDDIS;\r\ni8042_ctr &= ~(I8042_CTR_AUXINT | I8042_CTR_KBDINT);\r\nif (i8042_command(&i8042_ctr, I8042_CMD_CTL_WCTR)) {\r\npr_warn("Can't write CTR to resume, retrying...\n");\r\nmsleep(50);\r\nif (i8042_command(&i8042_ctr, I8042_CMD_CTL_WCTR)) {\r\npr_err("CTR write retry failed\n");\r\nreturn -EIO;\r\n}\r\n}\r\n#ifdef CONFIG_X86\r\nif (i8042_dritek)\r\ni8042_dritek_enable();\r\n#endif\r\nif (i8042_mux_present) {\r\nif (i8042_set_mux_mode(true, NULL) || i8042_enable_mux_ports())\r\npr_warn("failed to resume active multiplexor, mouse won't work\n");\r\n} else if (i8042_ports[I8042_AUX_PORT_NO].serio)\r\ni8042_enable_aux_port();\r\nif (i8042_ports[I8042_KBD_PORT_NO].serio)\r\ni8042_enable_kbd_port();\r\ni8042_interrupt(0, NULL);\r\nreturn 0;\r\n}\r\nstatic int i8042_pm_suspend(struct device *dev)\r\n{\r\nint i;\r\nif (pm_suspend_via_firmware())\r\ni8042_controller_reset(true);\r\nfor (i = 0; i < I8042_NUM_PORTS; i++) {\r\nstruct serio *serio = i8042_ports[i].serio;\r\nif (serio && device_may_wakeup(&serio->dev))\r\nenable_irq_wake(i8042_ports[i].irq);\r\n}\r\nreturn 0;\r\n}\r\nstatic int i8042_pm_resume_noirq(struct device *dev)\r\n{\r\nif (!pm_resume_via_firmware())\r\ni8042_interrupt(0, NULL);\r\nreturn 0;\r\n}\r\nstatic int i8042_pm_resume(struct device *dev)\r\n{\r\nbool force_reset;\r\nint i;\r\nfor (i = 0; i < I8042_NUM_PORTS; i++) {\r\nstruct serio *serio = i8042_ports[i].serio;\r\nif (serio && device_may_wakeup(&serio->dev))\r\ndisable_irq_wake(i8042_ports[i].irq);\r\n}\r\nif (!pm_suspend_via_firmware())\r\nreturn 0;\r\nforce_reset = pm_resume_via_firmware();\r\nreturn i8042_controller_resume(force_reset);\r\n}\r\nstatic int i8042_pm_thaw(struct device *dev)\r\n{\r\ni8042_interrupt(0, NULL);\r\nreturn 0;\r\n}\r\nstatic int i8042_pm_reset(struct device *dev)\r\n{\r\ni8042_controller_reset(false);\r\nreturn 0;\r\n}\r\nstatic int i8042_pm_restore(struct device *dev)\r\n{\r\nreturn i8042_controller_resume(false);\r\n}\r\nstatic void i8042_shutdown(struct platform_device *dev)\r\n{\r\ni8042_controller_reset(false);\r\n}\r\nstatic int __init i8042_create_kbd_port(void)\r\n{\r\nstruct serio *serio;\r\nstruct i8042_port *port = &i8042_ports[I8042_KBD_PORT_NO];\r\nserio = kzalloc(sizeof(struct serio), GFP_KERNEL);\r\nif (!serio)\r\nreturn -ENOMEM;\r\nserio->id.type = i8042_direct ? SERIO_8042 : SERIO_8042_XL;\r\nserio->write = i8042_dumbkbd ? NULL : i8042_kbd_write;\r\nserio->start = i8042_start;\r\nserio->stop = i8042_stop;\r\nserio->close = i8042_port_close;\r\nserio->port_data = port;\r\nserio->dev.parent = &i8042_platform_device->dev;\r\nstrlcpy(serio->name, "i8042 KBD port", sizeof(serio->name));\r\nstrlcpy(serio->phys, I8042_KBD_PHYS_DESC, sizeof(serio->phys));\r\nstrlcpy(serio->firmware_id, i8042_kbd_firmware_id,\r\nsizeof(serio->firmware_id));\r\nport->serio = serio;\r\nport->irq = I8042_KBD_IRQ;\r\nreturn 0;\r\n}\r\nstatic int __init i8042_create_aux_port(int idx)\r\n{\r\nstruct serio *serio;\r\nint port_no = idx < 0 ? I8042_AUX_PORT_NO : I8042_MUX_PORT_NO + idx;\r\nstruct i8042_port *port = &i8042_ports[port_no];\r\nserio = kzalloc(sizeof(struct serio), GFP_KERNEL);\r\nif (!serio)\r\nreturn -ENOMEM;\r\nserio->id.type = SERIO_8042;\r\nserio->write = i8042_aux_write;\r\nserio->start = i8042_start;\r\nserio->stop = i8042_stop;\r\nserio->port_data = port;\r\nserio->dev.parent = &i8042_platform_device->dev;\r\nif (idx < 0) {\r\nstrlcpy(serio->name, "i8042 AUX port", sizeof(serio->name));\r\nstrlcpy(serio->phys, I8042_AUX_PHYS_DESC, sizeof(serio->phys));\r\nstrlcpy(serio->firmware_id, i8042_aux_firmware_id,\r\nsizeof(serio->firmware_id));\r\nserio->close = i8042_port_close;\r\n} else {\r\nsnprintf(serio->name, sizeof(serio->name), "i8042 AUX%d port", idx);\r\nsnprintf(serio->phys, sizeof(serio->phys), I8042_MUX_PHYS_DESC, idx + 1);\r\nstrlcpy(serio->firmware_id, i8042_aux_firmware_id,\r\nsizeof(serio->firmware_id));\r\n}\r\nport->serio = serio;\r\nport->mux = idx;\r\nport->irq = I8042_AUX_IRQ;\r\nreturn 0;\r\n}\r\nstatic void __init i8042_free_kbd_port(void)\r\n{\r\nkfree(i8042_ports[I8042_KBD_PORT_NO].serio);\r\ni8042_ports[I8042_KBD_PORT_NO].serio = NULL;\r\n}\r\nstatic void __init i8042_free_aux_ports(void)\r\n{\r\nint i;\r\nfor (i = I8042_AUX_PORT_NO; i < I8042_NUM_PORTS; i++) {\r\nkfree(i8042_ports[i].serio);\r\ni8042_ports[i].serio = NULL;\r\n}\r\n}\r\nstatic void __init i8042_register_ports(void)\r\n{\r\nint i;\r\nfor (i = 0; i < I8042_NUM_PORTS; i++) {\r\nstruct serio *serio = i8042_ports[i].serio;\r\nif (serio) {\r\nprintk(KERN_INFO "serio: %s at %#lx,%#lx irq %d\n",\r\nserio->name,\r\n(unsigned long) I8042_DATA_REG,\r\n(unsigned long) I8042_COMMAND_REG,\r\ni8042_ports[i].irq);\r\nserio_register_port(serio);\r\ndevice_set_wakeup_capable(&serio->dev, true);\r\n}\r\n}\r\n}\r\nstatic void i8042_unregister_ports(void)\r\n{\r\nint i;\r\nfor (i = 0; i < I8042_NUM_PORTS; i++) {\r\nif (i8042_ports[i].serio) {\r\nserio_unregister_port(i8042_ports[i].serio);\r\ni8042_ports[i].serio = NULL;\r\n}\r\n}\r\n}\r\nbool i8042_check_port_owner(const struct serio *port)\r\n{\r\nint i;\r\nfor (i = 0; i < I8042_NUM_PORTS; i++)\r\nif (i8042_ports[i].serio == port)\r\nreturn true;\r\nreturn false;\r\n}\r\nstatic void i8042_free_irqs(void)\r\n{\r\nif (i8042_aux_irq_registered)\r\nfree_irq(I8042_AUX_IRQ, i8042_platform_device);\r\nif (i8042_kbd_irq_registered)\r\nfree_irq(I8042_KBD_IRQ, i8042_platform_device);\r\ni8042_aux_irq_registered = i8042_kbd_irq_registered = false;\r\n}\r\nstatic int __init i8042_setup_aux(void)\r\n{\r\nint (*aux_enable)(void);\r\nint error;\r\nint i;\r\nif (i8042_check_aux())\r\nreturn -ENODEV;\r\nif (i8042_nomux || i8042_check_mux()) {\r\nerror = i8042_create_aux_port(-1);\r\nif (error)\r\ngoto err_free_ports;\r\naux_enable = i8042_enable_aux_port;\r\n} else {\r\nfor (i = 0; i < I8042_NUM_MUX_PORTS; i++) {\r\nerror = i8042_create_aux_port(i);\r\nif (error)\r\ngoto err_free_ports;\r\n}\r\naux_enable = i8042_enable_mux_ports;\r\n}\r\nerror = request_irq(I8042_AUX_IRQ, i8042_interrupt, IRQF_SHARED,\r\n"i8042", i8042_platform_device);\r\nif (error)\r\ngoto err_free_ports;\r\nif (aux_enable())\r\ngoto err_free_irq;\r\ni8042_aux_irq_registered = true;\r\nreturn 0;\r\nerr_free_irq:\r\nfree_irq(I8042_AUX_IRQ, i8042_platform_device);\r\nerr_free_ports:\r\ni8042_free_aux_ports();\r\nreturn error;\r\n}\r\nstatic int __init i8042_setup_kbd(void)\r\n{\r\nint error;\r\nerror = i8042_create_kbd_port();\r\nif (error)\r\nreturn error;\r\nerror = request_irq(I8042_KBD_IRQ, i8042_interrupt, IRQF_SHARED,\r\n"i8042", i8042_platform_device);\r\nif (error)\r\ngoto err_free_port;\r\nerror = i8042_enable_kbd_port();\r\nif (error)\r\ngoto err_free_irq;\r\ni8042_kbd_irq_registered = true;\r\nreturn 0;\r\nerr_free_irq:\r\nfree_irq(I8042_KBD_IRQ, i8042_platform_device);\r\nerr_free_port:\r\ni8042_free_kbd_port();\r\nreturn error;\r\n}\r\nstatic int i8042_kbd_bind_notifier(struct notifier_block *nb,\r\nunsigned long action, void *data)\r\n{\r\nstruct device *dev = data;\r\nstruct serio *serio = to_serio_port(dev);\r\nstruct i8042_port *port = serio->port_data;\r\nif (serio != i8042_ports[I8042_KBD_PORT_NO].serio)\r\nreturn 0;\r\nswitch (action) {\r\ncase BUS_NOTIFY_BOUND_DRIVER:\r\nport->driver_bound = true;\r\nbreak;\r\ncase BUS_NOTIFY_UNBIND_DRIVER:\r\nport->driver_bound = false;\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic int __init i8042_probe(struct platform_device *dev)\r\n{\r\nint error;\r\ni8042_platform_device = dev;\r\nif (i8042_reset) {\r\nerror = i8042_controller_selftest();\r\nif (error)\r\nreturn error;\r\n}\r\nerror = i8042_controller_init();\r\nif (error)\r\nreturn error;\r\n#ifdef CONFIG_X86\r\nif (i8042_dritek)\r\ni8042_dritek_enable();\r\n#endif\r\nif (!i8042_noaux) {\r\nerror = i8042_setup_aux();\r\nif (error && error != -ENODEV && error != -EBUSY)\r\ngoto out_fail;\r\n}\r\nif (!i8042_nokbd) {\r\nerror = i8042_setup_kbd();\r\nif (error)\r\ngoto out_fail;\r\n}\r\ni8042_register_ports();\r\nreturn 0;\r\nout_fail:\r\ni8042_free_aux_ports();\r\ni8042_free_irqs();\r\ni8042_controller_reset(false);\r\ni8042_platform_device = NULL;\r\nreturn error;\r\n}\r\nstatic int i8042_remove(struct platform_device *dev)\r\n{\r\ni8042_unregister_ports();\r\ni8042_free_irqs();\r\ni8042_controller_reset(false);\r\ni8042_platform_device = NULL;\r\nreturn 0;\r\n}\r\nstatic int __init i8042_init(void)\r\n{\r\nstruct platform_device *pdev;\r\nint err;\r\ndbg_init();\r\nerr = i8042_platform_init();\r\nif (err)\r\nreturn err;\r\nerr = i8042_controller_check();\r\nif (err)\r\ngoto err_platform_exit;\r\npdev = platform_create_bundle(&i8042_driver, i8042_probe, NULL, 0, NULL, 0);\r\nif (IS_ERR(pdev)) {\r\nerr = PTR_ERR(pdev);\r\ngoto err_platform_exit;\r\n}\r\nbus_register_notifier(&serio_bus, &i8042_kbd_bind_notifier_block);\r\npanic_blink = i8042_panic_blink;\r\nreturn 0;\r\nerr_platform_exit:\r\ni8042_platform_exit();\r\nreturn err;\r\n}\r\nstatic void __exit i8042_exit(void)\r\n{\r\nplatform_device_unregister(i8042_platform_device);\r\nplatform_driver_unregister(&i8042_driver);\r\ni8042_platform_exit();\r\nbus_unregister_notifier(&serio_bus, &i8042_kbd_bind_notifier_block);\r\npanic_blink = NULL;\r\n}
