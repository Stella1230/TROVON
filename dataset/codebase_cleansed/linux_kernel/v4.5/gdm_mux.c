static int packet_type_to_index(u16 packetType)\r\n{\r\nint i;\r\nfor (i = 0; i < TTY_MAX_COUNT; i++) {\r\nif (packet_type[i] == packetType)\r\nreturn i;\r\n}\r\nreturn -1;\r\n}\r\nstatic struct mux_tx *alloc_mux_tx(int len)\r\n{\r\nstruct mux_tx *t = NULL;\r\nt = kzalloc(sizeof(*t), GFP_ATOMIC);\r\nif (!t)\r\nreturn NULL;\r\nt->urb = usb_alloc_urb(0, GFP_ATOMIC);\r\nt->buf = kmalloc(MUX_TX_MAX_SIZE, GFP_ATOMIC);\r\nif (!t->urb || !t->buf) {\r\nusb_free_urb(t->urb);\r\nkfree(t->buf);\r\nkfree(t);\r\nreturn NULL;\r\n}\r\nreturn t;\r\n}\r\nstatic void free_mux_tx(struct mux_tx *t)\r\n{\r\nif (t) {\r\nusb_free_urb(t->urb);\r\nkfree(t->buf);\r\nkfree(t);\r\n}\r\n}\r\nstatic struct mux_rx *alloc_mux_rx(void)\r\n{\r\nstruct mux_rx *r = NULL;\r\nr = kzalloc(sizeof(*r), GFP_KERNEL);\r\nif (!r)\r\nreturn NULL;\r\nr->urb = usb_alloc_urb(0, GFP_KERNEL);\r\nr->buf = kmalloc(MUX_RX_MAX_SIZE, GFP_KERNEL);\r\nif (!r->urb || !r->buf) {\r\nusb_free_urb(r->urb);\r\nkfree(r->buf);\r\nkfree(r);\r\nreturn NULL;\r\n}\r\nreturn r;\r\n}\r\nstatic void free_mux_rx(struct mux_rx *r)\r\n{\r\nif (r) {\r\nusb_free_urb(r->urb);\r\nkfree(r->buf);\r\nkfree(r);\r\n}\r\n}\r\nstatic struct mux_rx *get_rx_struct(struct rx_cxt *rx)\r\n{\r\nstruct mux_rx *r;\r\nunsigned long flags;\r\nspin_lock_irqsave(&rx->free_list_lock, flags);\r\nif (list_empty(&rx->rx_free_list)) {\r\nspin_unlock_irqrestore(&rx->free_list_lock, flags);\r\nreturn NULL;\r\n}\r\nr = list_entry(rx->rx_free_list.prev, struct mux_rx, free_list);\r\nlist_del(&r->free_list);\r\nspin_unlock_irqrestore(&rx->free_list_lock, flags);\r\nreturn r;\r\n}\r\nstatic void put_rx_struct(struct rx_cxt *rx, struct mux_rx *r)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&rx->free_list_lock, flags);\r\nlist_add_tail(&r->free_list, &rx->rx_free_list);\r\nspin_unlock_irqrestore(&rx->free_list_lock, flags);\r\n}\r\nstatic int up_to_host(struct mux_rx *r)\r\n{\r\nstruct mux_dev *mux_dev = r->mux_dev;\r\nstruct mux_pkt_header *mux_header;\r\nunsigned int start_flag;\r\nunsigned int payload_size;\r\nunsigned short packet_type;\r\nint total_len;\r\nu32 packet_size_sum = r->offset;\r\nint index;\r\nint ret = TO_HOST_INVALID_PACKET;\r\nint len = r->len;\r\nwhile (1) {\r\nmux_header = (struct mux_pkt_header *)(r->buf +\r\npacket_size_sum);\r\nstart_flag = __le32_to_cpu(mux_header->start_flag);\r\npayload_size = __le32_to_cpu(mux_header->payload_size);\r\npacket_type = __le16_to_cpu(mux_header->packet_type);\r\nif (start_flag != START_FLAG) {\r\npr_err("invalid START_FLAG %x\n", start_flag);\r\nbreak;\r\n}\r\ntotal_len = ALIGN(MUX_HEADER_SIZE + payload_size, 4);\r\nif (len - packet_size_sum <\r\ntotal_len) {\r\npr_err("invalid payload : %d %d %04x\n",\r\npayload_size, len, packet_type);\r\nbreak;\r\n}\r\nindex = packet_type_to_index(packet_type);\r\nif (index < 0) {\r\npr_err("invalid index %d\n", index);\r\nbreak;\r\n}\r\nret = r->callback(mux_header->data,\r\npayload_size,\r\nindex,\r\nmux_dev->tty_dev,\r\nRECV_PACKET_PROCESS_CONTINUE\r\n);\r\nif (ret == TO_HOST_BUFFER_REQUEST_FAIL) {\r\nr->offset += packet_size_sum;\r\nbreak;\r\n}\r\npacket_size_sum += total_len;\r\nif (len - packet_size_sum <= MUX_HEADER_SIZE + 2) {\r\nret = r->callback(NULL,\r\n0,\r\nindex,\r\nmux_dev->tty_dev,\r\nRECV_PACKET_PROCESS_COMPLETE\r\n);\r\nbreak;\r\n}\r\n}\r\nreturn ret;\r\n}\r\nstatic void do_rx(struct work_struct *work)\r\n{\r\nstruct mux_dev *mux_dev =\r\ncontainer_of(work, struct mux_dev, work_rx.work);\r\nstruct mux_rx *r;\r\nstruct rx_cxt *rx = &mux_dev->rx;\r\nunsigned long flags;\r\nint ret = 0;\r\nwhile (1) {\r\nspin_lock_irqsave(&rx->to_host_lock, flags);\r\nif (list_empty(&rx->to_host_list)) {\r\nspin_unlock_irqrestore(&rx->to_host_lock, flags);\r\nbreak;\r\n}\r\nr = list_entry(rx->to_host_list.next, struct mux_rx,\r\nto_host_list);\r\nlist_del(&r->to_host_list);\r\nspin_unlock_irqrestore(&rx->to_host_lock, flags);\r\nret = up_to_host(r);\r\nif (ret == TO_HOST_BUFFER_REQUEST_FAIL)\r\npr_err("failed to send mux data to host\n");\r\nelse\r\nput_rx_struct(rx, r);\r\n}\r\n}\r\nstatic void remove_rx_submit_list(struct mux_rx *r, struct rx_cxt *rx)\r\n{\r\nunsigned long flags;\r\nstruct mux_rx *r_remove, *r_remove_next;\r\nspin_lock_irqsave(&rx->submit_list_lock, flags);\r\nlist_for_each_entry_safe(r_remove, r_remove_next, &rx->rx_submit_list,\r\nrx_submit_list) {\r\nif (r == r_remove)\r\nlist_del(&r->rx_submit_list);\r\n}\r\nspin_unlock_irqrestore(&rx->submit_list_lock, flags);\r\n}\r\nstatic void gdm_mux_rcv_complete(struct urb *urb)\r\n{\r\nstruct mux_rx *r = urb->context;\r\nstruct mux_dev *mux_dev = r->mux_dev;\r\nstruct rx_cxt *rx = &mux_dev->rx;\r\nunsigned long flags;\r\nremove_rx_submit_list(r, rx);\r\nif (urb->status) {\r\nif (mux_dev->usb_state == PM_NORMAL)\r\ndev_err(&urb->dev->dev, "%s: urb status error %d\n",\r\n__func__, urb->status);\r\nput_rx_struct(rx, r);\r\n} else {\r\nr->len = r->urb->actual_length;\r\nspin_lock_irqsave(&rx->to_host_lock, flags);\r\nlist_add_tail(&r->to_host_list, &rx->to_host_list);\r\nqueue_work(mux_rx_wq, &mux_dev->work_rx.work);\r\nspin_unlock_irqrestore(&rx->to_host_lock, flags);\r\n}\r\n}\r\nstatic int gdm_mux_recv(void *priv_dev, int (*cb)(void *data, int len,\r\nint tty_index, struct tty_dev *tty_dev, int complete))\r\n{\r\nstruct mux_dev *mux_dev = priv_dev;\r\nstruct usb_device *usbdev = mux_dev->usbdev;\r\nstruct mux_rx *r;\r\nstruct rx_cxt *rx = &mux_dev->rx;\r\nunsigned long flags;\r\nint ret;\r\nif (!usbdev) {\r\npr_err("device is disconnected\n");\r\nreturn -ENODEV;\r\n}\r\nr = get_rx_struct(rx);\r\nif (!r) {\r\npr_err("get_rx_struct fail\n");\r\nreturn -ENOMEM;\r\n}\r\nr->offset = 0;\r\nr->mux_dev = (void *)mux_dev;\r\nr->callback = cb;\r\nmux_dev->rx_cb = cb;\r\nusb_fill_bulk_urb(r->urb,\r\nusbdev,\r\nusb_rcvbulkpipe(usbdev, 0x86),\r\nr->buf,\r\nMUX_RX_MAX_SIZE,\r\ngdm_mux_rcv_complete,\r\nr);\r\nspin_lock_irqsave(&rx->submit_list_lock, flags);\r\nlist_add_tail(&r->rx_submit_list, &rx->rx_submit_list);\r\nspin_unlock_irqrestore(&rx->submit_list_lock, flags);\r\nret = usb_submit_urb(r->urb, GFP_KERNEL);\r\nif (ret) {\r\nspin_lock_irqsave(&rx->submit_list_lock, flags);\r\nlist_del(&r->rx_submit_list);\r\nspin_unlock_irqrestore(&rx->submit_list_lock, flags);\r\nput_rx_struct(rx, r);\r\npr_err("usb_submit_urb ret=%d\n", ret);\r\n}\r\nusb_mark_last_busy(usbdev);\r\nreturn ret;\r\n}\r\nstatic void gdm_mux_send_complete(struct urb *urb)\r\n{\r\nstruct mux_tx *t = urb->context;\r\nif (urb->status == -ECONNRESET) {\r\ndev_info(&urb->dev->dev, "CONNRESET\n");\r\nfree_mux_tx(t);\r\nreturn;\r\n}\r\nif (t->callback)\r\nt->callback(t->cb_data);\r\nfree_mux_tx(t);\r\n}\r\nstatic int gdm_mux_send(void *priv_dev, void *data, int len, int tty_index,\r\nvoid (*cb)(void *data), void *cb_data)\r\n{\r\nstruct mux_dev *mux_dev = priv_dev;\r\nstruct usb_device *usbdev = mux_dev->usbdev;\r\nstruct mux_pkt_header *mux_header;\r\nstruct mux_tx *t = NULL;\r\nstatic u32 seq_num = 1;\r\nint total_len;\r\nint ret;\r\nunsigned long flags;\r\nif (mux_dev->usb_state == PM_SUSPEND) {\r\nret = usb_autopm_get_interface(mux_dev->intf);\r\nif (!ret)\r\nusb_autopm_put_interface(mux_dev->intf);\r\n}\r\nspin_lock_irqsave(&mux_dev->write_lock, flags);\r\ntotal_len = ALIGN(MUX_HEADER_SIZE + len, 4);\r\nt = alloc_mux_tx(total_len);\r\nif (!t) {\r\npr_err("alloc_mux_tx fail\n");\r\nspin_unlock_irqrestore(&mux_dev->write_lock, flags);\r\nreturn -ENOMEM;\r\n}\r\nmux_header = (struct mux_pkt_header *)t->buf;\r\nmux_header->start_flag = __cpu_to_le32(START_FLAG);\r\nmux_header->seq_num = __cpu_to_le32(seq_num++);\r\nmux_header->payload_size = __cpu_to_le32((u32)len);\r\nmux_header->packet_type = __cpu_to_le16(packet_type[tty_index]);\r\nmemcpy(t->buf + MUX_HEADER_SIZE, data, len);\r\nmemset(t->buf + MUX_HEADER_SIZE + len, 0, total_len - MUX_HEADER_SIZE -\r\nlen);\r\nt->len = total_len;\r\nt->callback = cb;\r\nt->cb_data = cb_data;\r\nusb_fill_bulk_urb(t->urb,\r\nusbdev,\r\nusb_sndbulkpipe(usbdev, 5),\r\nt->buf,\r\ntotal_len,\r\ngdm_mux_send_complete,\r\nt);\r\nret = usb_submit_urb(t->urb, GFP_ATOMIC);\r\nspin_unlock_irqrestore(&mux_dev->write_lock, flags);\r\nif (ret)\r\npr_err("usb_submit_urb Error: %d\n", ret);\r\nusb_mark_last_busy(usbdev);\r\nreturn ret;\r\n}\r\nstatic int gdm_mux_send_control(void *priv_dev, int request, int value,\r\nvoid *buf, int len)\r\n{\r\nstruct mux_dev *mux_dev = priv_dev;\r\nstruct usb_device *usbdev = mux_dev->usbdev;\r\nint ret;\r\nret = usb_control_msg(usbdev,\r\nusb_sndctrlpipe(usbdev, 0),\r\nrequest,\r\nUSB_RT_ACM,\r\nvalue,\r\n2,\r\nbuf,\r\nlen,\r\n5000\r\n);\r\nif (ret < 0)\r\npr_err("usb_control_msg error: %d\n", ret);\r\nreturn ret < 0 ? ret : 0;\r\n}\r\nstatic void release_usb(struct mux_dev *mux_dev)\r\n{\r\nstruct rx_cxt *rx = &mux_dev->rx;\r\nstruct mux_rx *r, *r_next;\r\nunsigned long flags;\r\ncancel_delayed_work(&mux_dev->work_rx);\r\nspin_lock_irqsave(&rx->submit_list_lock, flags);\r\nlist_for_each_entry_safe(r, r_next, &rx->rx_submit_list,\r\nrx_submit_list) {\r\nspin_unlock_irqrestore(&rx->submit_list_lock, flags);\r\nusb_kill_urb(r->urb);\r\nspin_lock_irqsave(&rx->submit_list_lock, flags);\r\n}\r\nspin_unlock_irqrestore(&rx->submit_list_lock, flags);\r\nspin_lock_irqsave(&rx->free_list_lock, flags);\r\nlist_for_each_entry_safe(r, r_next, &rx->rx_free_list, free_list) {\r\nlist_del(&r->free_list);\r\nfree_mux_rx(r);\r\n}\r\nspin_unlock_irqrestore(&rx->free_list_lock, flags);\r\nspin_lock_irqsave(&rx->to_host_lock, flags);\r\nlist_for_each_entry_safe(r, r_next, &rx->to_host_list, to_host_list) {\r\nif (r->mux_dev == (void *)mux_dev) {\r\nlist_del(&r->to_host_list);\r\nfree_mux_rx(r);\r\n}\r\n}\r\nspin_unlock_irqrestore(&rx->to_host_lock, flags);\r\n}\r\nstatic int init_usb(struct mux_dev *mux_dev)\r\n{\r\nstruct mux_rx *r;\r\nstruct rx_cxt *rx = &mux_dev->rx;\r\nint ret = 0;\r\nint i;\r\nspin_lock_init(&mux_dev->write_lock);\r\nINIT_LIST_HEAD(&rx->to_host_list);\r\nINIT_LIST_HEAD(&rx->rx_submit_list);\r\nINIT_LIST_HEAD(&rx->rx_free_list);\r\nspin_lock_init(&rx->to_host_lock);\r\nspin_lock_init(&rx->submit_list_lock);\r\nspin_lock_init(&rx->free_list_lock);\r\nfor (i = 0; i < MAX_ISSUE_NUM * 2; i++) {\r\nr = alloc_mux_rx();\r\nif (!r) {\r\nret = -ENOMEM;\r\nbreak;\r\n}\r\nlist_add(&r->free_list, &rx->rx_free_list);\r\n}\r\nINIT_DELAYED_WORK(&mux_dev->work_rx, do_rx);\r\nreturn ret;\r\n}\r\nstatic int gdm_mux_probe(struct usb_interface *intf,\r\nconst struct usb_device_id *id)\r\n{\r\nstruct mux_dev *mux_dev;\r\nstruct tty_dev *tty_dev;\r\nu16 idVendor, idProduct;\r\nint bInterfaceNumber;\r\nint ret;\r\nint i;\r\nstruct usb_device *usbdev = interface_to_usbdev(intf);\r\nbInterfaceNumber = intf->cur_altsetting->desc.bInterfaceNumber;\r\nidVendor = __le16_to_cpu(usbdev->descriptor.idVendor);\r\nidProduct = __le16_to_cpu(usbdev->descriptor.idProduct);\r\npr_info("mux vid = 0x%04x pid = 0x%04x\n", idVendor, idProduct);\r\nif (bInterfaceNumber != 2)\r\nreturn -ENODEV;\r\nmux_dev = kzalloc(sizeof(*mux_dev), GFP_KERNEL);\r\nif (!mux_dev)\r\nreturn -ENOMEM;\r\ntty_dev = kzalloc(sizeof(*tty_dev), GFP_KERNEL);\r\nif (!tty_dev) {\r\nret = -ENOMEM;\r\ngoto err_free_mux;\r\n}\r\nmux_dev->usbdev = usbdev;\r\nmux_dev->control_intf = intf;\r\nret = init_usb(mux_dev);\r\nif (ret)\r\ngoto err_free_usb;\r\ntty_dev->priv_dev = (void *)mux_dev;\r\ntty_dev->send_func = gdm_mux_send;\r\ntty_dev->recv_func = gdm_mux_recv;\r\ntty_dev->send_control = gdm_mux_send_control;\r\nret = register_lte_tty_device(tty_dev, &intf->dev);\r\nif (ret)\r\ngoto err_unregister_tty;\r\nfor (i = 0; i < TTY_MAX_COUNT; i++)\r\nmux_dev->tty_dev = tty_dev;\r\nmux_dev->intf = intf;\r\nmux_dev->usb_state = PM_NORMAL;\r\nusb_get_dev(usbdev);\r\nusb_set_intfdata(intf, tty_dev);\r\nreturn 0;\r\nerr_unregister_tty:\r\nunregister_lte_tty_device(tty_dev);\r\nerr_free_usb:\r\nrelease_usb(mux_dev);\r\nkfree(tty_dev);\r\nerr_free_mux:\r\nkfree(mux_dev);\r\nreturn ret;\r\n}\r\nstatic void gdm_mux_disconnect(struct usb_interface *intf)\r\n{\r\nstruct tty_dev *tty_dev;\r\nstruct mux_dev *mux_dev;\r\nstruct usb_device *usbdev = interface_to_usbdev(intf);\r\ntty_dev = usb_get_intfdata(intf);\r\nmux_dev = tty_dev->priv_dev;\r\nrelease_usb(mux_dev);\r\nunregister_lte_tty_device(tty_dev);\r\nkfree(mux_dev);\r\nkfree(tty_dev);\r\nusb_put_dev(usbdev);\r\n}\r\nstatic int gdm_mux_suspend(struct usb_interface *intf, pm_message_t pm_msg)\r\n{\r\nstruct tty_dev *tty_dev;\r\nstruct mux_dev *mux_dev;\r\nstruct rx_cxt *rx;\r\nstruct mux_rx *r, *r_next;\r\nunsigned long flags;\r\ntty_dev = usb_get_intfdata(intf);\r\nmux_dev = tty_dev->priv_dev;\r\nrx = &mux_dev->rx;\r\nif (mux_dev->usb_state != PM_NORMAL) {\r\ndev_err(intf->usb_dev, "usb suspend - invalid state\n");\r\nreturn -1;\r\n}\r\nmux_dev->usb_state = PM_SUSPEND;\r\nspin_lock_irqsave(&rx->submit_list_lock, flags);\r\nlist_for_each_entry_safe(r, r_next, &rx->rx_submit_list,\r\nrx_submit_list) {\r\nspin_unlock_irqrestore(&rx->submit_list_lock, flags);\r\nusb_kill_urb(r->urb);\r\nspin_lock_irqsave(&rx->submit_list_lock, flags);\r\n}\r\nspin_unlock_irqrestore(&rx->submit_list_lock, flags);\r\nreturn 0;\r\n}\r\nstatic int gdm_mux_resume(struct usb_interface *intf)\r\n{\r\nstruct tty_dev *tty_dev;\r\nstruct mux_dev *mux_dev;\r\nu8 i;\r\ntty_dev = usb_get_intfdata(intf);\r\nmux_dev = tty_dev->priv_dev;\r\nif (mux_dev->usb_state != PM_SUSPEND) {\r\ndev_err(intf->usb_dev, "usb resume - invalid state\n");\r\nreturn -1;\r\n}\r\nmux_dev->usb_state = PM_NORMAL;\r\nfor (i = 0; i < MAX_ISSUE_NUM; i++)\r\ngdm_mux_recv(mux_dev, mux_dev->rx_cb);\r\nreturn 0;\r\n}\r\nstatic int __init gdm_usb_mux_init(void)\r\n{\r\nmux_rx_wq = create_workqueue("mux_rx_wq");\r\nif (!mux_rx_wq) {\r\npr_err("work queue create fail\n");\r\nreturn -1;\r\n}\r\nregister_lte_tty_driver();\r\nreturn usb_register(&gdm_mux_driver);\r\n}\r\nstatic void __exit gdm_usb_mux_exit(void)\r\n{\r\nunregister_lte_tty_driver();\r\nif (mux_rx_wq) {\r\nflush_workqueue(mux_rx_wq);\r\ndestroy_workqueue(mux_rx_wq);\r\n}\r\nusb_deregister(&gdm_mux_driver);\r\n}
