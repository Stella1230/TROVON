void sti_vid_commit(struct sti_vid *vid,\r\nstruct drm_plane_state *state)\r\n{\r\nstruct drm_crtc *crtc = state->crtc;\r\nstruct drm_display_mode *mode = &crtc->mode;\r\nint dst_x = state->crtc_x;\r\nint dst_y = state->crtc_y;\r\nint dst_w = clamp_val(state->crtc_w, 0, mode->crtc_hdisplay - dst_x);\r\nint dst_h = clamp_val(state->crtc_h, 0, mode->crtc_vdisplay - dst_y);\r\nu32 val, ydo, xdo, yds, xds;\r\ndst_w = ALIGN(dst_w, 2);\r\ndst_h = ALIGN(dst_h, 2);\r\nval = readl(vid->regs + VID_CTL);\r\nval &= ~VID_CTL_IGNORE;\r\nwritel(val, vid->regs + VID_CTL);\r\nydo = sti_vtg_get_line_number(*mode, dst_y);\r\nyds = sti_vtg_get_line_number(*mode, dst_y + dst_h - 1);\r\nxdo = sti_vtg_get_pixel_number(*mode, dst_x);\r\nxds = sti_vtg_get_pixel_number(*mode, dst_x + dst_w - 1);\r\nwritel((ydo << 16) | xdo, vid->regs + VID_VPO);\r\nwritel((yds << 16) | xds, vid->regs + VID_VPS);\r\n}\r\nvoid sti_vid_disable(struct sti_vid *vid)\r\n{\r\nu32 val;\r\nval = readl(vid->regs + VID_CTL);\r\nval |= VID_CTL_IGNORE;\r\nwritel(val, vid->regs + VID_CTL);\r\n}\r\nstatic void sti_vid_init(struct sti_vid *vid)\r\n{\r\nwritel(VID_CTL_PSI_ENABLE | VID_CTL_IGNORE, vid->regs + VID_CTL);\r\nwritel(VID_ALP_OPAQUE, vid->regs + VID_ALP);\r\nwritel(VID_MPR0_BT709, vid->regs + VID_MPR0);\r\nwritel(VID_MPR1_BT709, vid->regs + VID_MPR1);\r\nwritel(VID_MPR2_BT709, vid->regs + VID_MPR2);\r\nwritel(VID_MPR3_BT709, vid->regs + VID_MPR3);\r\nwritel(VID_BC_DFLT, vid->regs + VID_BC);\r\nwritel(VID_TINT_DFLT, vid->regs + VID_TINT);\r\nwritel(VID_CSAT_DFLT, vid->regs + VID_CSAT);\r\n}\r\nstruct sti_vid *sti_vid_create(struct device *dev, int id,\r\nvoid __iomem *baseaddr)\r\n{\r\nstruct sti_vid *vid;\r\nvid = devm_kzalloc(dev, sizeof(*vid), GFP_KERNEL);\r\nif (!vid) {\r\nDRM_ERROR("Failed to allocate memory for VID\n");\r\nreturn NULL;\r\n}\r\nvid->dev = dev;\r\nvid->regs = baseaddr;\r\nvid->id = id;\r\nsti_vid_init(vid);\r\nreturn vid;\r\n}
