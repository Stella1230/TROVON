static int _dpll_test_fint(struct clk_hw_omap *clk, unsigned int n)\r\n{\r\nstruct dpll_data *dd;\r\nlong fint, fint_min, fint_max;\r\nint ret = 0;\r\ndd = clk->dpll_data;\r\nfint = clk_hw_get_rate(clk_hw_get_parent(&clk->hw)) / n;\r\nif (dd->flags & DPLL_J_TYPE) {\r\nfint_min = OMAP3PLUS_DPLL_FINT_JTYPE_MIN;\r\nfint_max = OMAP3PLUS_DPLL_FINT_JTYPE_MAX;\r\n} else {\r\nfint_min = ti_clk_get_features()->fint_min;\r\nfint_max = ti_clk_get_features()->fint_max;\r\n}\r\nif (!fint_min || !fint_max) {\r\nWARN(1, "No fint limits available!\n");\r\nreturn DPLL_FINT_INVALID;\r\n}\r\nif (fint < ti_clk_get_features()->fint_min) {\r\npr_debug("rejecting n=%d due to Fint failure, lowering max_divider\n",\r\nn);\r\ndd->max_divider = n;\r\nret = DPLL_FINT_UNDERFLOW;\r\n} else if (fint > ti_clk_get_features()->fint_max) {\r\npr_debug("rejecting n=%d due to Fint failure, boosting min_divider\n",\r\nn);\r\ndd->min_divider = n;\r\nret = DPLL_FINT_INVALID;\r\n} else if (fint > ti_clk_get_features()->fint_band1_max &&\r\nfint < ti_clk_get_features()->fint_band2_min) {\r\npr_debug("rejecting n=%d due to Fint failure\n", n);\r\nret = DPLL_FINT_INVALID;\r\n}\r\nreturn ret;\r\n}\r\nstatic unsigned long _dpll_compute_new_rate(unsigned long parent_rate,\r\nunsigned int m, unsigned int n)\r\n{\r\nunsigned long long num;\r\nnum = (unsigned long long)parent_rate * m;\r\ndo_div(num, n);\r\nreturn num;\r\n}\r\nstatic int _dpll_test_mult(int *m, int n, unsigned long *new_rate,\r\nunsigned long target_rate,\r\nunsigned long parent_rate)\r\n{\r\nint r = 0, carry = 0;\r\nif (*m % DPLL_SCALE_FACTOR >= DPLL_ROUNDING_VAL)\r\ncarry = 1;\r\n*m = (*m / DPLL_SCALE_FACTOR) + carry;\r\n*new_rate = _dpll_compute_new_rate(parent_rate, *m, n);\r\nif (*new_rate > target_rate) {\r\n(*m)--;\r\n*new_rate = 0;\r\n}\r\nif (*m < DPLL_MIN_MULTIPLIER) {\r\n*m = DPLL_MIN_MULTIPLIER;\r\n*new_rate = 0;\r\nr = DPLL_MULT_UNDERFLOW;\r\n}\r\nif (*new_rate == 0)\r\n*new_rate = _dpll_compute_new_rate(parent_rate, *m, n);\r\nreturn r;\r\n}\r\nstatic int _omap2_dpll_is_in_bypass(u32 v)\r\n{\r\nu8 mask, val;\r\nmask = ti_clk_get_features()->dpll_bypass_vals;\r\nwhile (mask) {\r\nval = __ffs(mask);\r\nmask ^= (1 << val);\r\nif (v == val)\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}\r\nu8 omap2_init_dpll_parent(struct clk_hw *hw)\r\n{\r\nstruct clk_hw_omap *clk = to_clk_hw_omap(hw);\r\nu32 v;\r\nstruct dpll_data *dd;\r\ndd = clk->dpll_data;\r\nif (!dd)\r\nreturn -EINVAL;\r\nv = ti_clk_ll_ops->clk_readl(dd->control_reg);\r\nv &= dd->enable_mask;\r\nv >>= __ffs(dd->enable_mask);\r\nif (_omap2_dpll_is_in_bypass(v))\r\nreturn 1;\r\nreturn 0;\r\n}\r\nunsigned long omap2_get_dpll_rate(struct clk_hw_omap *clk)\r\n{\r\nu64 dpll_clk;\r\nu32 dpll_mult, dpll_div, v;\r\nstruct dpll_data *dd;\r\ndd = clk->dpll_data;\r\nif (!dd)\r\nreturn 0;\r\nv = ti_clk_ll_ops->clk_readl(dd->control_reg);\r\nv &= dd->enable_mask;\r\nv >>= __ffs(dd->enable_mask);\r\nif (_omap2_dpll_is_in_bypass(v))\r\nreturn clk_get_rate(dd->clk_bypass);\r\nv = ti_clk_ll_ops->clk_readl(dd->mult_div1_reg);\r\ndpll_mult = v & dd->mult_mask;\r\ndpll_mult >>= __ffs(dd->mult_mask);\r\ndpll_div = v & dd->div1_mask;\r\ndpll_div >>= __ffs(dd->div1_mask);\r\ndpll_clk = (u64)clk_get_rate(dd->clk_ref) * dpll_mult;\r\ndo_div(dpll_clk, dpll_div + 1);\r\nreturn dpll_clk;\r\n}\r\nlong omap2_dpll_round_rate(struct clk_hw *hw, unsigned long target_rate,\r\nunsigned long *parent_rate)\r\n{\r\nstruct clk_hw_omap *clk = to_clk_hw_omap(hw);\r\nint m, n, r, scaled_max_m;\r\nint min_delta_m = INT_MAX, min_delta_n = INT_MAX;\r\nunsigned long scaled_rt_rp;\r\nunsigned long new_rate = 0;\r\nstruct dpll_data *dd;\r\nunsigned long ref_rate;\r\nlong delta;\r\nlong prev_min_delta = LONG_MAX;\r\nconst char *clk_name;\r\nif (!clk || !clk->dpll_data)\r\nreturn ~0;\r\ndd = clk->dpll_data;\r\nref_rate = clk_get_rate(dd->clk_ref);\r\nclk_name = clk_hw_get_name(hw);\r\npr_debug("clock: %s: starting DPLL round_rate, target rate %lu\n",\r\nclk_name, target_rate);\r\nscaled_rt_rp = target_rate / (ref_rate / DPLL_SCALE_FACTOR);\r\nscaled_max_m = dd->max_multiplier * DPLL_SCALE_FACTOR;\r\ndd->last_rounded_rate = 0;\r\nfor (n = dd->min_divider; n <= dd->max_divider; n++) {\r\nr = _dpll_test_fint(clk, n);\r\nif (r == DPLL_FINT_UNDERFLOW)\r\nbreak;\r\nelse if (r == DPLL_FINT_INVALID)\r\ncontinue;\r\nm = scaled_rt_rp * n;\r\nif (m > scaled_max_m)\r\nbreak;\r\nr = _dpll_test_mult(&m, n, &new_rate, target_rate,\r\nref_rate);\r\nif (r == DPLL_MULT_UNDERFLOW)\r\ncontinue;\r\ndelta = target_rate - new_rate;\r\nif (delta < 0)\r\ncontinue;\r\nif (delta < prev_min_delta) {\r\nprev_min_delta = delta;\r\nmin_delta_m = m;\r\nmin_delta_n = n;\r\n}\r\npr_debug("clock: %s: m = %d: n = %d: new_rate = %lu\n",\r\nclk_name, m, n, new_rate);\r\nif (delta == 0)\r\nbreak;\r\n}\r\nif (prev_min_delta == LONG_MAX) {\r\npr_debug("clock: %s: cannot round to rate %lu\n",\r\nclk_name, target_rate);\r\nreturn ~0;\r\n}\r\ndd->last_rounded_m = min_delta_m;\r\ndd->last_rounded_n = min_delta_n;\r\ndd->last_rounded_rate = target_rate - prev_min_delta;\r\nreturn dd->last_rounded_rate;\r\n}
