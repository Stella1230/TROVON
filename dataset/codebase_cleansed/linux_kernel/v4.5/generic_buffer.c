int size_from_channelarray(struct iio_channel_info *channels, int num_channels)\r\n{\r\nint bytes = 0;\r\nint i = 0;\r\nwhile (i < num_channels) {\r\nif (bytes % channels[i].bytes == 0)\r\nchannels[i].location = bytes;\r\nelse\r\nchannels[i].location = bytes - bytes % channels[i].bytes\r\n+ channels[i].bytes;\r\nbytes = channels[i].location + channels[i].bytes;\r\ni++;\r\n}\r\nreturn bytes;\r\n}\r\nvoid print1byte(uint8_t input, struct iio_channel_info *info)\r\n{\r\ninput >>= info->shift;\r\ninput &= info->mask;\r\nif (info->is_signed) {\r\nint8_t val = (int8_t)(input << (8 - info->bits_used)) >>\r\n(8 - info->bits_used);\r\nprintf("%05f ", ((float)val + info->offset) * info->scale);\r\n} else {\r\nprintf("%05f ", ((float)input + info->offset) * info->scale);\r\n}\r\n}\r\nvoid print2byte(uint16_t input, struct iio_channel_info *info)\r\n{\r\nif (info->be)\r\ninput = be16toh(input);\r\nelse\r\ninput = le16toh(input);\r\ninput >>= info->shift;\r\ninput &= info->mask;\r\nif (info->is_signed) {\r\nint16_t val = (int16_t)(input << (16 - info->bits_used)) >>\r\n(16 - info->bits_used);\r\nprintf("%05f ", ((float)val + info->offset) * info->scale);\r\n} else {\r\nprintf("%05f ", ((float)input + info->offset) * info->scale);\r\n}\r\n}\r\nvoid print4byte(uint32_t input, struct iio_channel_info *info)\r\n{\r\nif (info->be)\r\ninput = be32toh(input);\r\nelse\r\ninput = le32toh(input);\r\ninput >>= info->shift;\r\ninput &= info->mask;\r\nif (info->is_signed) {\r\nint32_t val = (int32_t)(input << (32 - info->bits_used)) >>\r\n(32 - info->bits_used);\r\nprintf("%05f ", ((float)val + info->offset) * info->scale);\r\n} else {\r\nprintf("%05f ", ((float)input + info->offset) * info->scale);\r\n}\r\n}\r\nvoid print8byte(uint64_t input, struct iio_channel_info *info)\r\n{\r\nif (info->be)\r\ninput = be64toh(input);\r\nelse\r\ninput = le64toh(input);\r\ninput >>= info->shift;\r\ninput &= info->mask;\r\nif (info->is_signed) {\r\nint64_t val = (int64_t)(input << (64 - info->bits_used)) >>\r\n(64 - info->bits_used);\r\nif (info->scale == 1.0f && info->offset == 0.0f)\r\nprintf("%" PRId64 " ", val);\r\nelse\r\nprintf("%05f ",\r\n((float)val + info->offset) * info->scale);\r\n} else {\r\nprintf("%05f ", ((float)input + info->offset) * info->scale);\r\n}\r\n}\r\nvoid process_scan(char *data,\r\nstruct iio_channel_info *channels,\r\nint num_channels)\r\n{\r\nint k;\r\nfor (k = 0; k < num_channels; k++)\r\nswitch (channels[k].bytes) {\r\ncase 1:\r\nprint1byte(*(uint8_t *)(data + channels[k].location),\r\n&channels[k]);\r\nbreak;\r\ncase 2:\r\nprint2byte(*(uint16_t *)(data + channels[k].location),\r\n&channels[k]);\r\nbreak;\r\ncase 4:\r\nprint4byte(*(uint32_t *)(data + channels[k].location),\r\n&channels[k]);\r\nbreak;\r\ncase 8:\r\nprint8byte(*(uint64_t *)(data + channels[k].location),\r\n&channels[k]);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nprintf("\n");\r\n}\r\nvoid print_usage(void)\r\n{\r\nfprintf(stderr, "Usage: generic_buffer [options]...\n"\r\n"Capture, convert and output data from IIO device buffer\n"\r\n" -c <n> Do n conversions\n"\r\n" -e Disable wait for event (new data)\n"\r\n" -g Use trigger-less mode\n"\r\n" -l <n> Set buffer length to n samples\n"\r\n" -n <name> Set device name (mandatory)\n"\r\n" -t <name> Set trigger name\n"\r\n" -w <n> Set delay between reads in us (event-less mode)\n");\r\n}\r\nint main(int argc, char **argv)\r\n{\r\nunsigned long num_loops = 2;\r\nunsigned long timedelay = 1000000;\r\nunsigned long buf_len = 128;\r\nint ret, c, i, j, toread;\r\nint fp;\r\nint num_channels;\r\nchar *trigger_name = NULL, *device_name = NULL;\r\nchar *dev_dir_name, *buf_dir_name;\r\nint datardytrigger = 1;\r\nchar *data;\r\nssize_t read_size;\r\nint dev_num, trig_num;\r\nchar *buffer_access;\r\nint scan_size;\r\nint noevents = 0;\r\nint notrigger = 0;\r\nchar *dummy;\r\nstruct iio_channel_info *channels;\r\nwhile ((c = getopt(argc, argv, "c:egl:n:t:w:")) != -1) {\r\nswitch (c) {\r\ncase 'c':\r\nerrno = 0;\r\nnum_loops = strtoul(optarg, &dummy, 10);\r\nif (errno)\r\nreturn -errno;\r\nbreak;\r\ncase 'e':\r\nnoevents = 1;\r\nbreak;\r\ncase 'g':\r\nnotrigger = 1;\r\nbreak;\r\ncase 'l':\r\nerrno = 0;\r\nbuf_len = strtoul(optarg, &dummy, 10);\r\nif (errno)\r\nreturn -errno;\r\nbreak;\r\ncase 'n':\r\ndevice_name = optarg;\r\nbreak;\r\ncase 't':\r\ntrigger_name = optarg;\r\ndatardytrigger = 0;\r\nbreak;\r\ncase 'w':\r\nerrno = 0;\r\ntimedelay = strtoul(optarg, &dummy, 10);\r\nif (errno)\r\nreturn -errno;\r\nbreak;\r\ncase '?':\r\nprint_usage();\r\nreturn -1;\r\n}\r\n}\r\nif (!device_name) {\r\nfprintf(stderr, "Device name not set\n");\r\nprint_usage();\r\nreturn -1;\r\n}\r\ndev_num = find_type_by_name(device_name, "iio:device");\r\nif (dev_num < 0) {\r\nfprintf(stderr, "Failed to find the %s\n", device_name);\r\nreturn dev_num;\r\n}\r\nprintf("iio device number being used is %d\n", dev_num);\r\nret = asprintf(&dev_dir_name, "%siio:device%d", iio_dir, dev_num);\r\nif (ret < 0)\r\nreturn -ENOMEM;\r\nif (!notrigger) {\r\nif (!trigger_name) {\r\nret = asprintf(&trigger_name,\r\n"%s-dev%d", device_name, dev_num);\r\nif (ret < 0) {\r\nret = -ENOMEM;\r\ngoto error_free_dev_dir_name;\r\n}\r\n}\r\ntrig_num = find_type_by_name(trigger_name, "trigger");\r\nif (trig_num < 0) {\r\nfprintf(stderr, "Failed to find the trigger %s\n",\r\ntrigger_name);\r\nret = trig_num;\r\ngoto error_free_triggername;\r\n}\r\nprintf("iio trigger number being used is %d\n", trig_num);\r\n} else {\r\nprintf("trigger-less mode selected\n");\r\n}\r\nret = build_channel_array(dev_dir_name, &channels, &num_channels);\r\nif (ret) {\r\nfprintf(stderr, "Problem reading scan element information\n"\r\n"diag %s\n", dev_dir_name);\r\ngoto error_free_triggername;\r\n}\r\nif (!num_channels) {\r\nfprintf(stderr,\r\n"No channels are enabled, we have nothing to scan.\n");\r\nfprintf(stderr, "Enable channels manually in "\r\nFORMAT_SCAN_ELEMENTS_DIR\r\n"/*_en and try again.\n", dev_dir_name);\r\nret = -ENOENT;\r\ngoto error_free_triggername;\r\n}\r\nret = asprintf(&buf_dir_name,\r\n"%siio:device%d/buffer", iio_dir, dev_num);\r\nif (ret < 0) {\r\nret = -ENOMEM;\r\ngoto error_free_channels;\r\n}\r\nif (!notrigger) {\r\nprintf("%s %s\n", dev_dir_name, trigger_name);\r\nret = write_sysfs_string_and_verify("trigger/current_trigger",\r\ndev_dir_name,\r\ntrigger_name);\r\nif (ret < 0) {\r\nfprintf(stderr,\r\n"Failed to write current_trigger file\n");\r\ngoto error_free_buf_dir_name;\r\n}\r\n}\r\nret = write_sysfs_int("length", buf_dir_name, buf_len);\r\nif (ret < 0)\r\ngoto error_free_buf_dir_name;\r\nret = write_sysfs_int("enable", buf_dir_name, 1);\r\nif (ret < 0) {\r\nfprintf(stderr,\r\n"Failed to enable buffer: %s\n", strerror(-ret));\r\ngoto error_free_buf_dir_name;\r\n}\r\nscan_size = size_from_channelarray(channels, num_channels);\r\ndata = malloc(scan_size * buf_len);\r\nif (!data) {\r\nret = -ENOMEM;\r\ngoto error_free_buf_dir_name;\r\n}\r\nret = asprintf(&buffer_access, "/dev/iio:device%d", dev_num);\r\nif (ret < 0) {\r\nret = -ENOMEM;\r\ngoto error_free_data;\r\n}\r\nfp = open(buffer_access, O_RDONLY | O_NONBLOCK);\r\nif (fp == -1) {\r\nret = -errno;\r\nfprintf(stderr, "Failed to open %s\n", buffer_access);\r\ngoto error_free_buffer_access;\r\n}\r\nfor (j = 0; j < num_loops; j++) {\r\nif (!noevents) {\r\nstruct pollfd pfd = {\r\n.fd = fp,\r\n.events = POLLIN,\r\n};\r\nret = poll(&pfd, 1, -1);\r\nif (ret < 0) {\r\nret = -errno;\r\ngoto error_close_buffer_access;\r\n} else if (ret == 0) {\r\ncontinue;\r\n}\r\ntoread = buf_len;\r\n} else {\r\nusleep(timedelay);\r\ntoread = 64;\r\n}\r\nread_size = read(fp, data, toread * scan_size);\r\nif (read_size < 0) {\r\nif (errno == EAGAIN) {\r\nfprintf(stderr, "nothing available\n");\r\ncontinue;\r\n} else {\r\nbreak;\r\n}\r\n}\r\nfor (i = 0; i < read_size / scan_size; i++)\r\nprocess_scan(data + scan_size * i, channels,\r\nnum_channels);\r\n}\r\nret = write_sysfs_int("enable", buf_dir_name, 0);\r\nif (ret < 0)\r\ngoto error_close_buffer_access;\r\nif (!notrigger)\r\nret = write_sysfs_string("trigger/current_trigger",\r\ndev_dir_name, "NULL");\r\nif (ret < 0)\r\nfprintf(stderr, "Failed to write to %s\n",\r\ndev_dir_name);\r\nerror_close_buffer_access:\r\nif (close(fp) == -1)\r\nperror("Failed to close buffer");\r\nerror_free_buffer_access:\r\nfree(buffer_access);\r\nerror_free_data:\r\nfree(data);\r\nerror_free_buf_dir_name:\r\nfree(buf_dir_name);\r\nerror_free_channels:\r\nfor (i = num_channels - 1; i >= 0; i--) {\r\nfree(channels[i].name);\r\nfree(channels[i].generic_name);\r\n}\r\nfree(channels);\r\nerror_free_triggername:\r\nif (datardytrigger)\r\nfree(trigger_name);\r\nerror_free_dev_dir_name:\r\nfree(dev_dir_name);\r\nreturn ret;\r\n}
