void r8712_set_rpwm(struct _adapter *padapter, u8 val8)\r\n{\r\nu8 rpwm;\r\nstruct pwrctrl_priv *pwrpriv = &padapter->pwrctrlpriv;\r\nif (pwrpriv->rpwm == val8) {\r\nif (pwrpriv->rpwm_retry == 0)\r\nreturn;\r\n}\r\nif (padapter->bDriverStopped || padapter->bSurpriseRemoved)\r\nreturn;\r\nrpwm = val8 | pwrpriv->tog;\r\nswitch (val8) {\r\ncase PS_STATE_S1:\r\npwrpriv->cpwm = val8;\r\nbreak;\r\ncase PS_STATE_S2:\r\ncase PS_STATE_S3:\r\ncase PS_STATE_S4:\r\npwrpriv->cpwm = val8;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\npwrpriv->rpwm_retry = 0;\r\npwrpriv->rpwm = val8;\r\nr8712_write8(padapter, 0x1025FE58, rpwm);\r\npwrpriv->tog += 0x80;\r\n}\r\nvoid r8712_set_ps_mode(struct _adapter *padapter, uint ps_mode, uint smart_ps)\r\n{\r\nstruct pwrctrl_priv *pwrpriv = &padapter->pwrctrlpriv;\r\nif (ps_mode > PM_Card_Disable)\r\nreturn;\r\nif (ps_mode == PS_MODE_ACTIVE)\r\nsmart_ps = 0;\r\nif ((pwrpriv->pwr_mode != ps_mode) || (pwrpriv->smart_ps != smart_ps)) {\r\nif (pwrpriv->pwr_mode == PS_MODE_ACTIVE)\r\npwrpriv->bSleep = true;\r\nelse\r\npwrpriv->bSleep = false;\r\npwrpriv->pwr_mode = ps_mode;\r\npwrpriv->smart_ps = smart_ps;\r\nschedule_work(&pwrpriv->SetPSModeWorkItem);\r\n}\r\n}\r\nvoid r8712_cpwm_int_hdl(struct _adapter *padapter,\r\nstruct reportpwrstate_parm *preportpwrstate)\r\n{\r\nstruct pwrctrl_priv *pwrpriv = &(padapter->pwrctrlpriv);\r\nstruct cmd_priv *pcmdpriv = &(padapter->cmdpriv);\r\nif (pwrpriv->cpwm_tog == ((preportpwrstate->state) & 0x80))\r\nreturn;\r\ndel_timer(&padapter->pwrctrlpriv.rpwm_check_timer);\r\n_enter_pwrlock(&pwrpriv->lock);\r\npwrpriv->cpwm = (preportpwrstate->state) & 0xf;\r\nif (pwrpriv->cpwm >= PS_STATE_S2) {\r\nif (pwrpriv->alives & CMD_ALIVE)\r\nup(&(pcmdpriv->cmd_queue_sema));\r\n}\r\npwrpriv->cpwm_tog = (preportpwrstate->state) & 0x80;\r\nup(&pwrpriv->lock);\r\n}\r\nstatic inline void register_task_alive(struct pwrctrl_priv *pwrctrl, uint tag)\r\n{\r\npwrctrl->alives |= tag;\r\n}\r\nstatic inline void unregister_task_alive(struct pwrctrl_priv *pwrctrl, uint tag)\r\n{\r\nif (pwrctrl->alives & tag)\r\npwrctrl->alives ^= tag;\r\n}\r\nstatic void _rpwm_check_handler (struct _adapter *padapter)\r\n{\r\nstruct pwrctrl_priv *pwrpriv = &padapter->pwrctrlpriv;\r\nif (padapter->bDriverStopped || padapter->bSurpriseRemoved)\r\nreturn;\r\nif (pwrpriv->cpwm != pwrpriv->rpwm)\r\nschedule_work(&pwrpriv->rpwm_workitem);\r\n}\r\nstatic void SetPSModeWorkItemCallback(struct work_struct *work)\r\n{\r\nstruct pwrctrl_priv *pwrpriv = container_of(work,\r\nstruct pwrctrl_priv, SetPSModeWorkItem);\r\nstruct _adapter *padapter = container_of(pwrpriv,\r\nstruct _adapter, pwrctrlpriv);\r\nif (!pwrpriv->bSleep) {\r\n_enter_pwrlock(&pwrpriv->lock);\r\nif (pwrpriv->pwr_mode == PS_MODE_ACTIVE)\r\nr8712_set_rpwm(padapter, PS_STATE_S4);\r\nup(&pwrpriv->lock);\r\n}\r\n}\r\nstatic void rpwm_workitem_callback(struct work_struct *work)\r\n{\r\nstruct pwrctrl_priv *pwrpriv = container_of(work,\r\nstruct pwrctrl_priv, rpwm_workitem);\r\nstruct _adapter *padapter = container_of(pwrpriv,\r\nstruct _adapter, pwrctrlpriv);\r\nif (pwrpriv->cpwm != pwrpriv->rpwm) {\r\n_enter_pwrlock(&pwrpriv->lock);\r\nr8712_read8(padapter, SDIO_HCPWM);\r\npwrpriv->rpwm_retry = 1;\r\nr8712_set_rpwm(padapter, pwrpriv->rpwm);\r\nup(&pwrpriv->lock);\r\n}\r\n}\r\nstatic void rpwm_check_handler (unsigned long data)\r\n{\r\nstruct _adapter *adapter = (struct _adapter *)data;\r\n_rpwm_check_handler(adapter);\r\n}\r\nvoid r8712_init_pwrctrl_priv(struct _adapter *padapter)\r\n{\r\nstruct pwrctrl_priv *pwrctrlpriv = &padapter->pwrctrlpriv;\r\nmemset((unsigned char *)pwrctrlpriv, 0, sizeof(struct pwrctrl_priv));\r\nsema_init(&pwrctrlpriv->lock, 1);\r\npwrctrlpriv->cpwm = PS_STATE_S4;\r\npwrctrlpriv->pwr_mode = PS_MODE_ACTIVE;\r\npwrctrlpriv->smart_ps = 0;\r\npwrctrlpriv->tog = 0x80;\r\nr8712_write8(padapter, 0x1025FE58, 0);\r\nINIT_WORK(&pwrctrlpriv->SetPSModeWorkItem, SetPSModeWorkItemCallback);\r\nINIT_WORK(&pwrctrlpriv->rpwm_workitem, rpwm_workitem_callback);\r\nsetup_timer(&pwrctrlpriv->rpwm_check_timer, rpwm_check_handler,\r\n(unsigned long)padapter);\r\n}\r\nsint r8712_register_cmd_alive(struct _adapter *padapter)\r\n{\r\nuint res = _SUCCESS;\r\nstruct pwrctrl_priv *pwrctrl = &padapter->pwrctrlpriv;\r\n_enter_pwrlock(&pwrctrl->lock);\r\nregister_task_alive(pwrctrl, CMD_ALIVE);\r\nif (pwrctrl->cpwm < PS_STATE_S2) {\r\nr8712_set_rpwm(padapter, PS_STATE_S3);\r\nres = _FAIL;\r\n}\r\nup(&pwrctrl->lock);\r\nreturn res;\r\n}\r\nvoid r8712_unregister_cmd_alive(struct _adapter *padapter)\r\n{\r\nstruct pwrctrl_priv *pwrctrl = &padapter->pwrctrlpriv;\r\n_enter_pwrlock(&pwrctrl->lock);\r\nunregister_task_alive(pwrctrl, CMD_ALIVE);\r\nif ((pwrctrl->cpwm > PS_STATE_S2) &&\r\n(pwrctrl->pwr_mode > PS_MODE_ACTIVE)) {\r\nif ((pwrctrl->alives == 0) &&\r\n(check_fwstate(&padapter->mlmepriv,\r\n_FW_UNDER_LINKING) != true)) {\r\nr8712_set_rpwm(padapter, PS_STATE_S0);\r\n}\r\n}\r\nup(&pwrctrl->lock);\r\n}
