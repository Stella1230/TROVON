void hdmi_phy_dump(struct hdmi_phy_data *phy, struct seq_file *s)\r\n{\r\n#define DUMPPHY(r) seq_printf(s, "%-35s %08x\n", #r,\\r\nhdmi_read_reg(phy->base, r))\r\nDUMPPHY(HDMI_TXPHY_TX_CTRL);\r\nDUMPPHY(HDMI_TXPHY_DIGITAL_CTRL);\r\nDUMPPHY(HDMI_TXPHY_POWER_CTRL);\r\nDUMPPHY(HDMI_TXPHY_PAD_CFG_CTRL);\r\nif (phy_feat->bist_ctrl)\r\nDUMPPHY(HDMI_TXPHY_BIST_CONTROL);\r\n}\r\nint hdmi_phy_parse_lanes(struct hdmi_phy_data *phy, const u32 *lanes)\r\n{\r\nint i;\r\nfor (i = 0; i < 8; i += 2) {\r\nu8 lane, pol;\r\nint dx, dy;\r\ndx = lanes[i];\r\ndy = lanes[i + 1];\r\nif (dx < 0 || dx >= 8)\r\nreturn -EINVAL;\r\nif (dy < 0 || dy >= 8)\r\nreturn -EINVAL;\r\nif (dx & 1) {\r\nif (dy != dx - 1)\r\nreturn -EINVAL;\r\npol = 1;\r\n} else {\r\nif (dy != dx + 1)\r\nreturn -EINVAL;\r\npol = 0;\r\n}\r\nlane = dx / 2;\r\nphy->lane_function[lane] = i / 2;\r\nphy->lane_polarity[lane] = pol;\r\n}\r\nreturn 0;\r\n}\r\nstatic void hdmi_phy_configure_lanes(struct hdmi_phy_data *phy)\r\n{\r\nstatic const u16 pad_cfg_list[] = {\r\n0x0123,\r\n0x0132,\r\n0x0312,\r\n0x0321,\r\n0x0231,\r\n0x0213,\r\n0x1023,\r\n0x1032,\r\n0x3012,\r\n0x3021,\r\n0x2031,\r\n0x2013,\r\n0x1203,\r\n0x1302,\r\n0x3102,\r\n0x3201,\r\n0x2301,\r\n0x2103,\r\n0x1230,\r\n0x1320,\r\n0x3120,\r\n0x3210,\r\n0x2310,\r\n0x2130,\r\n};\r\nu16 lane_cfg = 0;\r\nint i;\r\nunsigned lane_cfg_val;\r\nu16 pol_val = 0;\r\nfor (i = 0; i < 4; ++i)\r\nlane_cfg |= phy->lane_function[i] << ((3 - i) * 4);\r\npol_val |= phy->lane_polarity[0] << 0;\r\npol_val |= phy->lane_polarity[1] << 3;\r\npol_val |= phy->lane_polarity[2] << 2;\r\npol_val |= phy->lane_polarity[3] << 1;\r\nfor (i = 0; i < ARRAY_SIZE(pad_cfg_list); ++i)\r\nif (pad_cfg_list[i] == lane_cfg)\r\nbreak;\r\nif (WARN_ON(i == ARRAY_SIZE(pad_cfg_list)))\r\ni = 0;\r\nlane_cfg_val = i;\r\nREG_FLD_MOD(phy->base, HDMI_TXPHY_PAD_CFG_CTRL, lane_cfg_val, 26, 22);\r\nREG_FLD_MOD(phy->base, HDMI_TXPHY_PAD_CFG_CTRL, pol_val, 30, 27);\r\n}\r\nint hdmi_phy_configure(struct hdmi_phy_data *phy, unsigned long hfbitclk,\r\nunsigned long lfbitclk)\r\n{\r\nu8 freqout;\r\nhdmi_read_reg(phy->base, HDMI_TXPHY_TX_CTRL);\r\nif (phy_feat->bist_ctrl)\r\nREG_FLD_MOD(phy->base, HDMI_TXPHY_BIST_CONTROL, 1, 11, 11);\r\nif (hfbitclk != lfbitclk)\r\nfreqout = 0;\r\nelse if (hfbitclk / 10 < phy_feat->max_phy)\r\nfreqout = 1;\r\nelse\r\nfreqout = 2;\r\nREG_FLD_MOD(phy->base, HDMI_TXPHY_TX_CTRL, freqout, 31, 30);\r\nhdmi_write_reg(phy->base, HDMI_TXPHY_DIGITAL_CTRL, 0xF0000000);\r\nif (phy_feat->ldo_voltage)\r\nREG_FLD_MOD(phy->base, HDMI_TXPHY_POWER_CTRL, 0xB, 3, 0);\r\nhdmi_phy_configure_lanes(phy);\r\nreturn 0;\r\n}\r\nstatic int hdmi_phy_init_features(struct platform_device *pdev)\r\n{\r\nstruct hdmi_phy_features *dst;\r\nconst struct hdmi_phy_features *src;\r\ndst = devm_kzalloc(&pdev->dev, sizeof(*dst), GFP_KERNEL);\r\nif (!dst) {\r\ndev_err(&pdev->dev, "Failed to allocate HDMI PHY Features\n");\r\nreturn -ENOMEM;\r\n}\r\nswitch (omapdss_get_version()) {\r\ncase OMAPDSS_VER_OMAP4430_ES1:\r\ncase OMAPDSS_VER_OMAP4430_ES2:\r\ncase OMAPDSS_VER_OMAP4:\r\nsrc = &omap44xx_phy_feats;\r\nbreak;\r\ncase OMAPDSS_VER_OMAP5:\r\ncase OMAPDSS_VER_DRA7xx:\r\nsrc = &omap54xx_phy_feats;\r\nbreak;\r\ndefault:\r\nreturn -ENODEV;\r\n}\r\nmemcpy(dst, src, sizeof(*dst));\r\nphy_feat = dst;\r\nreturn 0;\r\n}\r\nint hdmi_phy_init(struct platform_device *pdev, struct hdmi_phy_data *phy)\r\n{\r\nint r;\r\nstruct resource *res;\r\nr = hdmi_phy_init_features(pdev);\r\nif (r)\r\nreturn r;\r\nres = platform_get_resource_byname(pdev, IORESOURCE_MEM, "phy");\r\nif (!res) {\r\nDSSERR("can't get PHY mem resource\n");\r\nreturn -EINVAL;\r\n}\r\nphy->base = devm_ioremap_resource(&pdev->dev, res);\r\nif (IS_ERR(phy->base)) {\r\nDSSERR("can't ioremap TX PHY\n");\r\nreturn PTR_ERR(phy->base);\r\n}\r\nreturn 0;\r\n}
