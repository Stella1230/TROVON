static void dnotify_recalc_inode_mask(struct fsnotify_mark *fsn_mark)\r\n{\r\n__u32 new_mask, old_mask;\r\nstruct dnotify_struct *dn;\r\nstruct dnotify_mark *dn_mark = container_of(fsn_mark,\r\nstruct dnotify_mark,\r\nfsn_mark);\r\nassert_spin_locked(&fsn_mark->lock);\r\nold_mask = fsn_mark->mask;\r\nnew_mask = 0;\r\nfor (dn = dn_mark->dn; dn != NULL; dn = dn->dn_next)\r\nnew_mask |= (dn->dn_mask & ~FS_DN_MULTISHOT);\r\nfsnotify_set_mark_mask_locked(fsn_mark, new_mask);\r\nif (old_mask == new_mask)\r\nreturn;\r\nif (fsn_mark->inode)\r\nfsnotify_recalc_inode_mask(fsn_mark->inode);\r\n}\r\nstatic int dnotify_handle_event(struct fsnotify_group *group,\r\nstruct inode *inode,\r\nstruct fsnotify_mark *inode_mark,\r\nstruct fsnotify_mark *vfsmount_mark,\r\nu32 mask, void *data, int data_type,\r\nconst unsigned char *file_name, u32 cookie)\r\n{\r\nstruct dnotify_mark *dn_mark;\r\nstruct dnotify_struct *dn;\r\nstruct dnotify_struct **prev;\r\nstruct fown_struct *fown;\r\n__u32 test_mask = mask & ~FS_EVENT_ON_CHILD;\r\nif (!S_ISDIR(inode->i_mode))\r\nreturn 0;\r\nBUG_ON(vfsmount_mark);\r\ndn_mark = container_of(inode_mark, struct dnotify_mark, fsn_mark);\r\nspin_lock(&inode_mark->lock);\r\nprev = &dn_mark->dn;\r\nwhile ((dn = *prev) != NULL) {\r\nif ((dn->dn_mask & test_mask) == 0) {\r\nprev = &dn->dn_next;\r\ncontinue;\r\n}\r\nfown = &dn->dn_filp->f_owner;\r\nsend_sigio(fown, dn->dn_fd, POLL_MSG);\r\nif (dn->dn_mask & FS_DN_MULTISHOT)\r\nprev = &dn->dn_next;\r\nelse {\r\n*prev = dn->dn_next;\r\nkmem_cache_free(dnotify_struct_cache, dn);\r\ndnotify_recalc_inode_mask(inode_mark);\r\n}\r\n}\r\nspin_unlock(&inode_mark->lock);\r\nreturn 0;\r\n}\r\nstatic void dnotify_free_mark(struct fsnotify_mark *fsn_mark)\r\n{\r\nstruct dnotify_mark *dn_mark = container_of(fsn_mark,\r\nstruct dnotify_mark,\r\nfsn_mark);\r\nBUG_ON(dn_mark->dn);\r\nkmem_cache_free(dnotify_mark_cache, dn_mark);\r\n}\r\nvoid dnotify_flush(struct file *filp, fl_owner_t id)\r\n{\r\nstruct fsnotify_mark *fsn_mark;\r\nstruct dnotify_mark *dn_mark;\r\nstruct dnotify_struct *dn;\r\nstruct dnotify_struct **prev;\r\nstruct inode *inode;\r\nbool free = false;\r\ninode = file_inode(filp);\r\nif (!S_ISDIR(inode->i_mode))\r\nreturn;\r\nfsn_mark = fsnotify_find_inode_mark(dnotify_group, inode);\r\nif (!fsn_mark)\r\nreturn;\r\ndn_mark = container_of(fsn_mark, struct dnotify_mark, fsn_mark);\r\nmutex_lock(&dnotify_group->mark_mutex);\r\nspin_lock(&fsn_mark->lock);\r\nprev = &dn_mark->dn;\r\nwhile ((dn = *prev) != NULL) {\r\nif ((dn->dn_owner == id) && (dn->dn_filp == filp)) {\r\n*prev = dn->dn_next;\r\nkmem_cache_free(dnotify_struct_cache, dn);\r\ndnotify_recalc_inode_mask(fsn_mark);\r\nbreak;\r\n}\r\nprev = &dn->dn_next;\r\n}\r\nspin_unlock(&fsn_mark->lock);\r\nif (dn_mark->dn == NULL) {\r\nfsnotify_detach_mark(fsn_mark);\r\nfree = true;\r\n}\r\nmutex_unlock(&dnotify_group->mark_mutex);\r\nif (free)\r\nfsnotify_free_mark(fsn_mark);\r\nfsnotify_put_mark(fsn_mark);\r\n}\r\nstatic __u32 convert_arg(unsigned long arg)\r\n{\r\n__u32 new_mask = FS_EVENT_ON_CHILD;\r\nif (arg & DN_MULTISHOT)\r\nnew_mask |= FS_DN_MULTISHOT;\r\nif (arg & DN_DELETE)\r\nnew_mask |= (FS_DELETE | FS_MOVED_FROM);\r\nif (arg & DN_MODIFY)\r\nnew_mask |= FS_MODIFY;\r\nif (arg & DN_ACCESS)\r\nnew_mask |= FS_ACCESS;\r\nif (arg & DN_ATTRIB)\r\nnew_mask |= FS_ATTRIB;\r\nif (arg & DN_RENAME)\r\nnew_mask |= FS_DN_RENAME;\r\nif (arg & DN_CREATE)\r\nnew_mask |= (FS_CREATE | FS_MOVED_TO);\r\nreturn new_mask;\r\n}\r\nstatic int attach_dn(struct dnotify_struct *dn, struct dnotify_mark *dn_mark,\r\nfl_owner_t id, int fd, struct file *filp, __u32 mask)\r\n{\r\nstruct dnotify_struct *odn;\r\nodn = dn_mark->dn;\r\nwhile (odn != NULL) {\r\nif ((odn->dn_owner == id) && (odn->dn_filp == filp)) {\r\nodn->dn_fd = fd;\r\nodn->dn_mask |= mask;\r\nreturn -EEXIST;\r\n}\r\nodn = odn->dn_next;\r\n}\r\ndn->dn_mask = mask;\r\ndn->dn_fd = fd;\r\ndn->dn_filp = filp;\r\ndn->dn_owner = id;\r\ndn->dn_next = dn_mark->dn;\r\ndn_mark->dn = dn;\r\nreturn 0;\r\n}\r\nint fcntl_dirnotify(int fd, struct file *filp, unsigned long arg)\r\n{\r\nstruct dnotify_mark *new_dn_mark, *dn_mark;\r\nstruct fsnotify_mark *new_fsn_mark, *fsn_mark;\r\nstruct dnotify_struct *dn;\r\nstruct inode *inode;\r\nfl_owner_t id = current->files;\r\nstruct file *f;\r\nint destroy = 0, error = 0;\r\n__u32 mask;\r\nnew_fsn_mark = NULL;\r\ndn = NULL;\r\nif (!dir_notify_enable) {\r\nerror = -EINVAL;\r\ngoto out_err;\r\n}\r\nif ((arg & ~DN_MULTISHOT) == 0) {\r\ndnotify_flush(filp, id);\r\nerror = 0;\r\ngoto out_err;\r\n}\r\ninode = file_inode(filp);\r\nif (!S_ISDIR(inode->i_mode)) {\r\nerror = -ENOTDIR;\r\ngoto out_err;\r\n}\r\ndn = kmem_cache_alloc(dnotify_struct_cache, GFP_KERNEL);\r\nif (!dn) {\r\nerror = -ENOMEM;\r\ngoto out_err;\r\n}\r\nnew_dn_mark = kmem_cache_alloc(dnotify_mark_cache, GFP_KERNEL);\r\nif (!new_dn_mark) {\r\nerror = -ENOMEM;\r\ngoto out_err;\r\n}\r\nmask = convert_arg(arg);\r\nnew_fsn_mark = &new_dn_mark->fsn_mark;\r\nfsnotify_init_mark(new_fsn_mark, dnotify_free_mark);\r\nnew_fsn_mark->mask = mask;\r\nnew_dn_mark->dn = NULL;\r\nmutex_lock(&dnotify_group->mark_mutex);\r\nfsn_mark = fsnotify_find_inode_mark(dnotify_group, inode);\r\nif (fsn_mark) {\r\ndn_mark = container_of(fsn_mark, struct dnotify_mark, fsn_mark);\r\nspin_lock(&fsn_mark->lock);\r\n} else {\r\nfsnotify_add_mark_locked(new_fsn_mark, dnotify_group, inode,\r\nNULL, 0);\r\nspin_lock(&new_fsn_mark->lock);\r\nfsn_mark = new_fsn_mark;\r\ndn_mark = new_dn_mark;\r\nnew_fsn_mark = NULL;\r\n}\r\nrcu_read_lock();\r\nf = fcheck(fd);\r\nrcu_read_unlock();\r\nif (f != filp) {\r\nif (dn_mark == new_dn_mark)\r\ndestroy = 1;\r\ngoto out;\r\n}\r\n__f_setown(filp, task_pid(current), PIDTYPE_PID, 0);\r\nerror = attach_dn(dn, dn_mark, id, fd, filp, mask);\r\nif (!error)\r\ndn = NULL;\r\nelse if (error == -EEXIST)\r\nerror = 0;\r\ndnotify_recalc_inode_mask(fsn_mark);\r\nout:\r\nspin_unlock(&fsn_mark->lock);\r\nif (destroy)\r\nfsnotify_detach_mark(fsn_mark);\r\nmutex_unlock(&dnotify_group->mark_mutex);\r\nif (destroy)\r\nfsnotify_free_mark(fsn_mark);\r\nfsnotify_put_mark(fsn_mark);\r\nout_err:\r\nif (new_fsn_mark)\r\nfsnotify_put_mark(new_fsn_mark);\r\nif (dn)\r\nkmem_cache_free(dnotify_struct_cache, dn);\r\nreturn error;\r\n}\r\nstatic int __init dnotify_init(void)\r\n{\r\ndnotify_struct_cache = KMEM_CACHE(dnotify_struct, SLAB_PANIC);\r\ndnotify_mark_cache = KMEM_CACHE(dnotify_mark, SLAB_PANIC);\r\ndnotify_group = fsnotify_alloc_group(&dnotify_fsnotify_ops);\r\nif (IS_ERR(dnotify_group))\r\npanic("unable to allocate fsnotify group for dnotify\n");\r\nreturn 0;\r\n}
