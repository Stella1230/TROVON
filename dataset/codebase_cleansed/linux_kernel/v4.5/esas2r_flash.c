static u8 esas2r_calc_byte_xor_cksum(u8 *addr, u32 len, u8 seed)\r\n{\r\nu32 cksum = seed;\r\nu8 *p = (u8 *)&cksum;\r\nwhile (len) {\r\nif (((uintptr_t)addr & 3) == 0)\r\nbreak;\r\ncksum = cksum ^ *addr;\r\naddr++;\r\nlen--;\r\n}\r\nwhile (len >= sizeof(u32)) {\r\ncksum = cksum ^ *(u32 *)addr;\r\naddr += 4;\r\nlen -= 4;\r\n}\r\nwhile (len--) {\r\ncksum = cksum ^ *addr;\r\naddr++;\r\n}\r\nreturn p[0] ^ p[1] ^ p[2] ^ p[3];\r\n}\r\nstatic u8 esas2r_calc_byte_cksum(void *addr, u32 len, u8 seed)\r\n{\r\nu8 *p = (u8 *)addr;\r\nu8 cksum = seed;\r\nwhile (len--)\r\ncksum = cksum + p[len];\r\nreturn cksum;\r\n}\r\nstatic void esas2r_fmapi_callback(struct esas2r_adapter *a,\r\nstruct esas2r_request *rq)\r\n{\r\nstruct atto_vda_flash_req *vrq = &rq->vrq->flash;\r\nstruct esas2r_flash_context *fc =\r\n(struct esas2r_flash_context *)rq->interrupt_cx;\r\nif (rq->req_stat == RS_SUCCESS) {\r\nswitch (vrq->sub_func) {\r\ncase VDA_FLASH_BEGINW:\r\nif (fc->sgc.cur_offset == NULL)\r\ngoto commit;\r\nvrq->sub_func = VDA_FLASH_WRITE;\r\nrq->req_stat = RS_PENDING;\r\nbreak;\r\ncase VDA_FLASH_WRITE:\r\ncommit:\r\nvrq->sub_func = VDA_FLASH_COMMIT;\r\nrq->req_stat = RS_PENDING;\r\nrq->interrupt_cb = fc->interrupt_cb;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nif (rq->req_stat != RS_PENDING)\r\n(*fc->interrupt_cb)(a, rq);\r\n}\r\nstatic void build_flash_msg(struct esas2r_adapter *a,\r\nstruct esas2r_request *rq)\r\n{\r\nstruct esas2r_flash_context *fc =\r\n(struct esas2r_flash_context *)rq->interrupt_cx;\r\nstruct esas2r_sg_context *sgc = &fc->sgc;\r\nu8 cksum = 0;\r\nif (fc->func == VDA_FLASH_BEGINW) {\r\nif (sgc->cur_offset)\r\ncksum = esas2r_calc_byte_xor_cksum(sgc->cur_offset,\r\nsgc->length,\r\n0);\r\nrq->interrupt_cb = esas2r_fmapi_callback;\r\n} else {\r\nrq->interrupt_cb = fc->interrupt_cb;\r\n}\r\nesas2r_build_flash_req(a,\r\nrq,\r\nfc->func,\r\ncksum,\r\nfc->flsh_addr,\r\nsgc->length);\r\nesas2r_rq_free_sg_lists(rq, a);\r\nfc->curr_len = fc->sgc.length;\r\nif (sgc->cur_offset) {\r\nesas2r_sgc_init(sgc, a, rq, &rq->vrq->flash.data.sge[0]);\r\nif (!esas2r_build_sg_list(a, rq, sgc)) {\r\nrq->req_stat = RS_BUSY;\r\nreturn;\r\n}\r\n} else {\r\nfc->sgc.length = 0;\r\n}\r\nfc->flsh_addr += fc->curr_len;\r\n}\r\nstatic bool load_image(struct esas2r_adapter *a, struct esas2r_request *rq)\r\n{\r\nrq->req_stat = RS_PENDING;\r\nif (test_bit(AF_DEGRADED_MODE, &a->flags))\r\n;\r\nelse\r\nbuild_flash_msg(a, rq);\r\nreturn rq->req_stat == RS_PENDING;\r\n}\r\nstatic void fix_bios(struct esas2r_adapter *a, struct esas2r_flash_img *fi)\r\n{\r\nstruct esas2r_component_header *ch = &fi->cmp_hdr[CH_IT_BIOS];\r\nstruct esas2r_pc_image *pi;\r\nstruct esas2r_boot_header *bh;\r\npi = (struct esas2r_pc_image *)((u8 *)fi + ch->image_offset);\r\nbh =\r\n(struct esas2r_boot_header *)((u8 *)pi +\r\nle16_to_cpu(pi->header_offset));\r\nbh->device_id = cpu_to_le16(a->pcid->device);\r\nif (pi->pnp_offset) {\r\nu8 *pnp_header_bytes =\r\n((u8 *)pi + le16_to_cpu(pi->pnp_offset));\r\n*((u32 *)&pnp_header_bytes[10]) =\r\ncpu_to_le32(MAKEDWORD(a->pcid->subsystem_vendor,\r\na->pcid->subsystem_device));\r\npnp_header_bytes[9] -= esas2r_calc_byte_cksum(pnp_header_bytes,\r\n32, 0);\r\n}\r\npi->checksum = pi->checksum -\r\nesas2r_calc_byte_cksum((u8 *)pi, ch->length, 0);\r\n}\r\nstatic void fix_efi(struct esas2r_adapter *a, struct esas2r_flash_img *fi)\r\n{\r\nstruct esas2r_component_header *ch = &fi->cmp_hdr[CH_IT_EFI];\r\nu32 len = ch->length;\r\nu32 offset = ch->image_offset;\r\nstruct esas2r_efi_image *ei;\r\nstruct esas2r_boot_header *bh;\r\nwhile (len) {\r\nu32 thislen;\r\nei = (struct esas2r_efi_image *)((u8 *)fi + offset);\r\nbh = (struct esas2r_boot_header *)((u8 *)ei +\r\nle16_to_cpu(\r\nei->header_offset));\r\nbh->device_id = cpu_to_le16(a->pcid->device);\r\nthislen = (u32)le16_to_cpu(bh->image_length) * 512;\r\nif (thislen > len)\r\nbreak;\r\nlen -= thislen;\r\noffset += thislen;\r\n}\r\n}\r\nstatic bool complete_fmapi_req(struct esas2r_adapter *a,\r\nstruct esas2r_request *rq, u8 fi_stat)\r\n{\r\nstruct esas2r_flash_context *fc =\r\n(struct esas2r_flash_context *)rq->interrupt_cx;\r\nstruct esas2r_flash_img *fi = fc->fi;\r\nfi->status = fi_stat;\r\nfi->driver_error = rq->req_stat;\r\nrq->interrupt_cb = NULL;\r\nrq->req_stat = RS_SUCCESS;\r\nif (fi_stat != FI_STAT_IMG_VER)\r\nmemset(fc->scratch, 0, FM_BUF_SZ);\r\nesas2r_enable_heartbeat(a);\r\nclear_bit(AF_FLASH_LOCK, &a->flags);\r\nreturn false;\r\n}\r\nstatic void fw_download_proc(struct esas2r_adapter *a,\r\nstruct esas2r_request *rq)\r\n{\r\nstruct esas2r_flash_context *fc =\r\n(struct esas2r_flash_context *)rq->interrupt_cx;\r\nstruct esas2r_flash_img *fi = fc->fi;\r\nstruct esas2r_component_header *ch;\r\nu32 len;\r\nu8 *p, *q;\r\nif (rq->req_stat != RS_SUCCESS)\r\ngoto error;\r\nif (fc->func == VDA_FLASH_READ\r\n&& fc->cmp_len) {\r\nch = &fi->cmp_hdr[fc->comp_typ];\r\np = fc->scratch;\r\nq = (u8 *)fi\r\n+ ch->image_offset\r\n+ ch->length\r\n- fc->cmp_len;\r\nfor (len = fc->curr_len; len; len--)\r\nif (*p++ != *q++)\r\ngoto error;\r\nfc->cmp_len -= fc->curr_len;\r\nif (fc->cmp_len > FM_BUF_SZ)\r\nfc->sgc.length = FM_BUF_SZ;\r\nelse\r\nfc->sgc.length = fc->cmp_len;\r\nfc->sgc.cur_offset = fc->sgc_offset +\r\n((u8 *)fc->scratch - (u8 *)fi);\r\n}\r\nwhile (fc->sgc.length == 0) {\r\nch = &fi->cmp_hdr[fc->comp_typ];\r\nswitch (fc->task) {\r\ncase FMTSK_ERASE_BOOT:\r\nch = &fi->cmp_hdr[CH_IT_BIOS];\r\nif (ch->length == 0)\r\ngoto no_bios;\r\nfc->task = FMTSK_WRTBIOS;\r\nfc->func = VDA_FLASH_BEGINW;\r\nfc->comp_typ = CH_IT_BIOS;\r\nfc->flsh_addr = FLS_OFFSET_BOOT;\r\nfc->sgc.length = ch->length;\r\nfc->sgc.cur_offset = fc->sgc_offset +\r\nch->image_offset;\r\nbreak;\r\ncase FMTSK_WRTBIOS:\r\nfc->task = FMTSK_READBIOS;\r\nfc->func = VDA_FLASH_READ;\r\nfc->flsh_addr = FLS_OFFSET_BOOT;\r\nfc->cmp_len = ch->length;\r\nfc->sgc.length = FM_BUF_SZ;\r\nfc->sgc.cur_offset = fc->sgc_offset\r\n+ ((u8 *)fc->scratch -\r\n(u8 *)fi);\r\nbreak;\r\ncase FMTSK_READBIOS:\r\nno_bios:\r\nch->status = CH_STAT_SUCCESS;\r\nch = &fi->cmp_hdr[CH_IT_MAC];\r\nif (ch->length == 0)\r\ngoto no_mac;\r\nfc->task = FMTSK_WRTMAC;\r\nfc->func = VDA_FLASH_BEGINW;\r\nfc->comp_typ = CH_IT_MAC;\r\nfc->flsh_addr = FLS_OFFSET_BOOT\r\n+ fi->cmp_hdr[CH_IT_BIOS].length;\r\nfc->sgc.length = ch->length;\r\nfc->sgc.cur_offset = fc->sgc_offset +\r\nch->image_offset;\r\nbreak;\r\ncase FMTSK_WRTMAC:\r\nfc->task = FMTSK_READMAC;\r\nfc->func = VDA_FLASH_READ;\r\nfc->flsh_addr -= ch->length;\r\nfc->cmp_len = ch->length;\r\nfc->sgc.length = FM_BUF_SZ;\r\nfc->sgc.cur_offset = fc->sgc_offset\r\n+ ((u8 *)fc->scratch -\r\n(u8 *)fi);\r\nbreak;\r\ncase FMTSK_READMAC:\r\nno_mac:\r\nch->status = CH_STAT_SUCCESS;\r\nch = &fi->cmp_hdr[CH_IT_EFI];\r\nif (ch->length == 0)\r\ngoto no_efi;\r\nfc->task = FMTSK_WRTEFI;\r\nfc->func = VDA_FLASH_BEGINW;\r\nfc->comp_typ = CH_IT_EFI;\r\nfc->flsh_addr = FLS_OFFSET_BOOT\r\n+ fi->cmp_hdr[CH_IT_BIOS].length\r\n+ fi->cmp_hdr[CH_IT_MAC].length;\r\nfc->sgc.length = ch->length;\r\nfc->sgc.cur_offset = fc->sgc_offset +\r\nch->image_offset;\r\nbreak;\r\ncase FMTSK_WRTEFI:\r\nfc->task = FMTSK_READEFI;\r\nfc->func = VDA_FLASH_READ;\r\nfc->flsh_addr -= ch->length;\r\nfc->cmp_len = ch->length;\r\nfc->sgc.length = FM_BUF_SZ;\r\nfc->sgc.cur_offset = fc->sgc_offset\r\n+ ((u8 *)fc->scratch -\r\n(u8 *)fi);\r\nbreak;\r\ncase FMTSK_READEFI:\r\nno_efi:\r\nch->status = CH_STAT_SUCCESS;\r\nch = &fi->cmp_hdr[CH_IT_CFG];\r\nif (ch->length == 0)\r\ngoto no_cfg;\r\nfc->task = FMTSK_WRTCFG;\r\nfc->func = VDA_FLASH_BEGINW;\r\nfc->comp_typ = CH_IT_CFG;\r\nfc->flsh_addr = FLS_OFFSET_CPYR - ch->length;\r\nfc->sgc.length = ch->length;\r\nfc->sgc.cur_offset = fc->sgc_offset +\r\nch->image_offset;\r\nbreak;\r\ncase FMTSK_WRTCFG:\r\nfc->task = FMTSK_READCFG;\r\nfc->func = VDA_FLASH_READ;\r\nfc->flsh_addr = FLS_OFFSET_CPYR - ch->length;\r\nfc->cmp_len = ch->length;\r\nfc->sgc.length = FM_BUF_SZ;\r\nfc->sgc.cur_offset = fc->sgc_offset\r\n+ ((u8 *)fc->scratch -\r\n(u8 *)fi);\r\nbreak;\r\ncase FMTSK_READCFG:\r\nno_cfg:\r\nch->status = CH_STAT_SUCCESS;\r\nif (test_bit(AF_DEGRADED_MODE, &a->flags))\r\nesas2r_local_reset_adapter(a);\r\na->flash_ver = fi->cmp_hdr[CH_IT_BIOS].version;\r\nesas2r_print_flash_rev(a);\r\nmemcpy(a->image_type, fi->rel_version,\r\nsizeof(fi->rel_version));\r\ncomplete_fmapi_req(a, rq, FI_STAT_SUCCESS);\r\nreturn;\r\n}\r\nif (fc->func == VDA_FLASH_READ\r\n&& fc->sgc.length > fc->cmp_len)\r\nfc->sgc.length = fc->cmp_len;\r\n}\r\nif (!load_image(a, rq)) {\r\nerror:\r\nif (fc->comp_typ < fi->num_comps) {\r\nch = &fi->cmp_hdr[fc->comp_typ];\r\nch->status = CH_STAT_FAILED;\r\n}\r\ncomplete_fmapi_req(a, rq, FI_STAT_FAILED);\r\n}\r\n}\r\nstatic u8 get_fi_adap_type(struct esas2r_adapter *a)\r\n{\r\nu8 type;\r\nswitch (a->pcid->device) {\r\ncase ATTO_DID_INTEL_IOP348:\r\ntype = FI_AT_SUN_LAKE;\r\nbreak;\r\ncase ATTO_DID_MV_88RC9580:\r\ncase ATTO_DID_MV_88RC9580TS:\r\ncase ATTO_DID_MV_88RC9580TSE:\r\ncase ATTO_DID_MV_88RC9580TL:\r\ntype = FI_AT_MV_9580;\r\nbreak;\r\ndefault:\r\ntype = FI_AT_UNKNWN;\r\nbreak;\r\n}\r\nreturn type;\r\n}\r\nstatic u32 chk_cfg(u8 *cfg, u32 length, u32 *flash_ver)\r\n{\r\nu16 *pw = (u16 *)cfg - 1;\r\nu32 sz = 0;\r\nu32 len = length;\r\nif (len == 0)\r\nlen = FM_BUF_SZ;\r\nif (flash_ver)\r\n*flash_ver = 0;\r\nwhile (true) {\r\nu16 type;\r\nu16 size;\r\ntype = le16_to_cpu(*pw--);\r\nsize = le16_to_cpu(*pw--);\r\nif (type != FBT_CPYR\r\n&& type != FBT_SETUP\r\n&& type != FBT_FLASH_VER)\r\nbreak;\r\nif (type == FBT_FLASH_VER\r\n&& flash_ver)\r\n*flash_ver = le32_to_cpu(*(u32 *)(pw - 1));\r\nsz += size + (2 * sizeof(u16));\r\npw -= size / sizeof(u16);\r\nif (sz > len - (2 * sizeof(u16)))\r\nbreak;\r\n}\r\nif (length && sz != length)\r\nreturn 0;\r\nreturn sz;\r\n}\r\nstatic u8 chk_boot(u8 *boot_img, u32 length)\r\n{\r\nstruct esas2r_boot_image *bi = (struct esas2r_boot_image *)boot_img;\r\nu16 hdroffset = le16_to_cpu(bi->header_offset);\r\nstruct esas2r_boot_header *bh;\r\nif (bi->signature != le16_to_cpu(0xaa55)\r\n|| (long)hdroffset >\r\n(long)(65536L - sizeof(struct esas2r_boot_header))\r\n|| (hdroffset & 3)\r\n|| (hdroffset < sizeof(struct esas2r_boot_image))\r\n|| ((u32)hdroffset + sizeof(struct esas2r_boot_header) > length))\r\nreturn 0xff;\r\nbh = (struct esas2r_boot_header *)((char *)bi + hdroffset);\r\nif (bh->signature[0] != 'P'\r\n|| bh->signature[1] != 'C'\r\n|| bh->signature[2] != 'I'\r\n|| bh->signature[3] != 'R'\r\n|| le16_to_cpu(bh->struct_length) <\r\n(u16)sizeof(struct esas2r_boot_header)\r\n|| bh->class_code[2] != 0x01\r\n|| bh->class_code[1] != 0x04\r\n|| bh->class_code[0] != 0x00\r\n|| (bh->code_type != CODE_TYPE_PC\r\n&& bh->code_type != CODE_TYPE_OPEN\r\n&& bh->code_type != CODE_TYPE_EFI))\r\nreturn 0xff;\r\nreturn bh->code_type;\r\n}\r\nstatic u16 calc_fi_checksum(struct esas2r_flash_context *fc)\r\n{\r\nstruct esas2r_flash_img *fi = fc->fi;\r\nu16 cksum;\r\nu32 len;\r\nu16 *pw;\r\nfor (len = (fi->length - fc->fi_hdr_len) / 2,\r\npw = (u16 *)((u8 *)fi + fc->fi_hdr_len),\r\ncksum = 0;\r\nlen;\r\nlen--, pw++)\r\ncksum = cksum + le16_to_cpu(*pw);\r\nreturn cksum;\r\n}\r\nstatic bool verify_fi(struct esas2r_adapter *a,\r\nstruct esas2r_flash_context *fc)\r\n{\r\nstruct esas2r_flash_img *fi = fc->fi;\r\nu8 type;\r\nbool imgerr;\r\nu16 i;\r\nu32 len;\r\nstruct esas2r_component_header *ch;\r\nlen = fi->length;\r\nif ((len & 1)\r\n|| len < fc->fi_hdr_len) {\r\nfi->status = FI_STAT_LENGTH;\r\nreturn false;\r\n}\r\ntype = get_fi_adap_type(a);\r\nif ((type == FI_AT_UNKNWN) || (fi->adap_typ != type)) {\r\nfi->status = FI_STAT_ADAPTYP;\r\nreturn false;\r\n}\r\nimgerr = false;\r\nfor (i = 0, len = 0, ch = fi->cmp_hdr;\r\ni < fi->num_comps;\r\ni++, ch++) {\r\nbool cmperr = false;\r\nif (i != ch->img_type) {\r\nimgerr = true;\r\nch->status = CH_STAT_INVALID;\r\ncontinue;\r\n}\r\nswitch (ch->img_type) {\r\ncase CH_IT_BIOS:\r\ntype = CODE_TYPE_PC;\r\nbreak;\r\ncase CH_IT_MAC:\r\ntype = CODE_TYPE_OPEN;\r\nbreak;\r\ncase CH_IT_EFI:\r\ntype = CODE_TYPE_EFI;\r\nbreak;\r\n}\r\nswitch (ch->img_type) {\r\ncase CH_IT_FW:\r\ncase CH_IT_NVR:\r\nbreak;\r\ncase CH_IT_BIOS:\r\ncase CH_IT_MAC:\r\ncase CH_IT_EFI:\r\nif (ch->length & 0x1ff)\r\ncmperr = true;\r\nif (ch->length == 0)\r\nbreak;\r\nif (chk_boot((u8 *)fi + ch->image_offset, ch->length)\r\n!= type)\r\ncmperr = true;\r\nbreak;\r\ncase CH_IT_CFG:\r\nif (ch->length == 0) {\r\ncmperr = true;\r\nbreak;\r\n}\r\nif (!chk_cfg((u8 *)fi + ch->image_offset + ch->length,\r\nch->length, NULL))\r\ncmperr = true;\r\nbreak;\r\ndefault:\r\nfi->status = FI_STAT_UNKNOWN;\r\nreturn false;\r\n}\r\nif (cmperr) {\r\nimgerr = true;\r\nch->status = CH_STAT_INVALID;\r\n} else {\r\nch->status = CH_STAT_PENDING;\r\nlen += ch->length;\r\n}\r\n}\r\nif (imgerr) {\r\nfi->status = FI_STAT_MISSING;\r\nreturn false;\r\n}\r\nif (len != fi->length - fc->fi_hdr_len) {\r\nfi->status = FI_STAT_LENGTH;\r\nreturn false;\r\n}\r\nif (fi->checksum != calc_fi_checksum(fc)) {\r\nfi->status = FI_STAT_CHKSUM;\r\nreturn false;\r\n}\r\nreturn true;\r\n}\r\nstatic void esas2r_complete_fs_ioctl(struct esas2r_adapter *a,\r\nstruct esas2r_request *rq)\r\n{\r\nstruct esas2r_ioctl_fs *fs =\r\n(struct esas2r_ioctl_fs *)rq->interrupt_cx;\r\nif (rq->vrq->flash.sub_func == VDA_FLASH_COMMIT)\r\nesas2r_enable_heartbeat(a);\r\nfs->driver_error = rq->req_stat;\r\nif (fs->driver_error == RS_SUCCESS)\r\nfs->status = ATTO_STS_SUCCESS;\r\nelse\r\nfs->status = ATTO_STS_FAILED;\r\n}\r\nbool esas2r_process_fs_ioctl(struct esas2r_adapter *a,\r\nstruct esas2r_ioctl_fs *fs,\r\nstruct esas2r_request *rq,\r\nstruct esas2r_sg_context *sgc)\r\n{\r\nu8 cmdcnt = (u8)ARRAY_SIZE(cmd_to_fls_func);\r\nstruct esas2r_ioctlfs_command *fsc = &fs->command;\r\nu8 func = 0;\r\nu32 datalen;\r\nfs->status = ATTO_STS_FAILED;\r\nfs->driver_error = RS_PENDING;\r\nif (fs->version > ESAS2R_FS_VER) {\r\nfs->status = ATTO_STS_INV_VERSION;\r\nreturn false;\r\n}\r\nif (fsc->command >= cmdcnt) {\r\nfs->status = ATTO_STS_INV_FUNC;\r\nreturn false;\r\n}\r\nfunc = cmd_to_fls_func[fsc->command];\r\nif (func == 0xFF) {\r\nfs->status = ATTO_STS_INV_FUNC;\r\nreturn false;\r\n}\r\nif (fsc->command != ESAS2R_FS_CMD_CANCEL) {\r\nif ((a->pcid->device != ATTO_DID_MV_88RC9580\r\n|| fs->adap_type != ESAS2R_FS_AT_ESASRAID2)\r\n&& (a->pcid->device != ATTO_DID_MV_88RC9580TS\r\n|| fs->adap_type != ESAS2R_FS_AT_TSSASRAID2)\r\n&& (a->pcid->device != ATTO_DID_MV_88RC9580TSE\r\n|| fs->adap_type != ESAS2R_FS_AT_TSSASRAID2E)\r\n&& (a->pcid->device != ATTO_DID_MV_88RC9580TL\r\n|| fs->adap_type != ESAS2R_FS_AT_TLSASHBA)) {\r\nfs->status = ATTO_STS_INV_ADAPTER;\r\nreturn false;\r\n}\r\nif (fs->driver_ver > ESAS2R_FS_DRVR_VER) {\r\nfs->status = ATTO_STS_INV_DRVR_VER;\r\nreturn false;\r\n}\r\n}\r\nif (test_bit(AF_DEGRADED_MODE, &a->flags)) {\r\nfs->status = ATTO_STS_DEGRADED;\r\nreturn false;\r\n}\r\nrq->interrupt_cb = esas2r_complete_fs_ioctl;\r\nrq->interrupt_cx = fs;\r\ndatalen = le32_to_cpu(fsc->length);\r\nesas2r_build_flash_req(a,\r\nrq,\r\nfunc,\r\nfsc->checksum,\r\nle32_to_cpu(fsc->flash_addr),\r\ndatalen);\r\nif (func == VDA_FLASH_WRITE\r\n|| func == VDA_FLASH_READ) {\r\nif (datalen == 0) {\r\nfs->status = ATTO_STS_INV_FUNC;\r\nreturn false;\r\n}\r\nesas2r_sgc_init(sgc, a, rq, rq->vrq->flash.data.sge);\r\nsgc->length = datalen;\r\nif (!esas2r_build_sg_list(a, rq, sgc)) {\r\nfs->status = ATTO_STS_OUT_OF_RSRC;\r\nreturn false;\r\n}\r\n}\r\nif (func == VDA_FLASH_COMMIT)\r\nesas2r_disable_heartbeat(a);\r\nesas2r_start_request(a, rq);\r\nreturn true;\r\n}\r\nstatic bool esas2r_flash_access(struct esas2r_adapter *a, u32 function)\r\n{\r\nu32 starttime;\r\nu32 timeout;\r\nu32 intstat;\r\nu32 doorbell;\r\nif (function == DRBL_FLASH_REQ)\r\nesas2r_disable_chip_interrupts(a);\r\nesas2r_write_register_dword(a, MU_DOORBELL_IN, function);\r\nstarttime = jiffies_to_msecs(jiffies);\r\nif (test_bit(AF_CHPRST_PENDING, &a->flags) ||\r\ntest_bit(AF_DISC_PENDING, &a->flags))\r\ntimeout = 40000;\r\nelse\r\ntimeout = 5000;\r\nwhile (true) {\r\nintstat = esas2r_read_register_dword(a, MU_INT_STATUS_OUT);\r\nif (intstat & MU_INTSTAT_DRBL) {\r\ndoorbell =\r\nesas2r_read_register_dword(a, MU_DOORBELL_OUT);\r\nesas2r_write_register_dword(a, MU_DOORBELL_OUT,\r\ndoorbell);\r\nif (doorbell & function)\r\nbreak;\r\n}\r\nschedule_timeout_interruptible(msecs_to_jiffies(100));\r\nif ((jiffies_to_msecs(jiffies) - starttime) > timeout) {\r\nif (function == DRBL_FLASH_REQ) {\r\nesas2r_hdebug("flash access timeout");\r\nesas2r_write_register_dword(a, MU_DOORBELL_IN,\r\nDRBL_FLASH_DONE);\r\nesas2r_enable_chip_interrupts(a);\r\n} else {\r\nesas2r_hdebug("flash release timeout");\r\n}\r\nreturn false;\r\n}\r\n}\r\nif (function == DRBL_FLASH_DONE)\r\nesas2r_enable_chip_interrupts(a);\r\nreturn true;\r\n}\r\nbool esas2r_read_flash_block(struct esas2r_adapter *a,\r\nvoid *to,\r\nu32 from,\r\nu32 size)\r\n{\r\nu8 *end = (u8 *)to;\r\nif (!esas2r_flash_access(a, DRBL_FLASH_REQ))\r\nreturn false;\r\nwhile (size) {\r\nu32 len;\r\nu32 offset;\r\nu32 iatvr;\r\nif (test_bit(AF2_SERIAL_FLASH, &a->flags2))\r\niatvr = MW_DATA_ADDR_SER_FLASH + (from & -WINDOW_SIZE);\r\nelse\r\niatvr = MW_DATA_ADDR_PAR_FLASH + (from & -WINDOW_SIZE);\r\nesas2r_map_data_window(a, iatvr);\r\noffset = from & (WINDOW_SIZE - 1);\r\nlen = size;\r\nif (len > WINDOW_SIZE - offset)\r\nlen = WINDOW_SIZE - offset;\r\nfrom += len;\r\nsize -= len;\r\nwhile (len--) {\r\n*end++ = esas2r_read_data_byte(a, offset);\r\noffset++;\r\n}\r\n}\r\nesas2r_flash_access(a, DRBL_FLASH_DONE);\r\nreturn true;\r\n}\r\nbool esas2r_read_flash_rev(struct esas2r_adapter *a)\r\n{\r\nu8 bytes[256];\r\nu16 *pw;\r\nu16 *pwstart;\r\nu16 type;\r\nu16 size;\r\nu32 sz;\r\nsz = sizeof(bytes);\r\npw = (u16 *)(bytes + sz);\r\npwstart = (u16 *)bytes + 2;\r\nif (!esas2r_read_flash_block(a, bytes, FLS_OFFSET_CPYR - sz, sz))\r\ngoto invalid_rev;\r\nwhile (pw >= pwstart) {\r\npw--;\r\ntype = le16_to_cpu(*pw);\r\npw--;\r\nsize = le16_to_cpu(*pw);\r\npw -= size / 2;\r\nif (type == FBT_CPYR\r\n|| type == FBT_SETUP\r\n|| pw < pwstart)\r\ncontinue;\r\nif (type == FBT_FLASH_VER)\r\na->flash_ver = le32_to_cpu(*(u32 *)pw);\r\nbreak;\r\n}\r\ninvalid_rev:\r\nreturn esas2r_print_flash_rev(a);\r\n}\r\nbool esas2r_print_flash_rev(struct esas2r_adapter *a)\r\n{\r\nu16 year = LOWORD(a->flash_ver);\r\nu8 day = LOBYTE(HIWORD(a->flash_ver));\r\nu8 month = HIBYTE(HIWORD(a->flash_ver));\r\nif (day == 0\r\n|| month == 0\r\n|| day > 31\r\n|| month > 12\r\n|| year < 2006\r\n|| year > 9999) {\r\nstrcpy(a->flash_rev, "not found");\r\na->flash_ver = 0;\r\nreturn false;\r\n}\r\nsprintf(a->flash_rev, "%02d/%02d/%04d", month, day, year);\r\nesas2r_hdebug("flash version: %s", a->flash_rev);\r\nreturn true;\r\n}\r\nbool esas2r_read_image_type(struct esas2r_adapter *a)\r\n{\r\nu8 bytes[256];\r\nstruct esas2r_boot_image *bi;\r\nstruct esas2r_boot_header *bh;\r\nu32 sz;\r\nu32 len;\r\nu32 offset;\r\nsz = sizeof(bytes);\r\nlen = FLS_LENGTH_BOOT;\r\noffset = 0;\r\nwhile (true) {\r\nif (!esas2r_read_flash_block(a, bytes, FLS_OFFSET_BOOT +\r\noffset,\r\nsz))\r\ngoto invalid_rev;\r\nbi = (struct esas2r_boot_image *)bytes;\r\nbh = (struct esas2r_boot_header *)((u8 *)bi +\r\nle16_to_cpu(\r\nbi->header_offset));\r\nif (bi->signature != cpu_to_le16(0xAA55))\r\ngoto invalid_rev;\r\nif (bh->code_type == CODE_TYPE_PC) {\r\nstrcpy(a->image_type, "BIOS");\r\nreturn true;\r\n} else if (bh->code_type == CODE_TYPE_EFI) {\r\nstruct esas2r_efi_image *ei;\r\nei = (struct esas2r_efi_image *)bytes;\r\nswitch (le16_to_cpu(ei->machine_type)) {\r\ncase EFI_MACHINE_IA32:\r\nstrcpy(a->image_type, "EFI 32-bit");\r\nreturn true;\r\ncase EFI_MACHINE_IA64:\r\nstrcpy(a->image_type, "EFI itanium");\r\nreturn true;\r\ncase EFI_MACHINE_X64:\r\nstrcpy(a->image_type, "EFI 64-bit");\r\nreturn true;\r\ncase EFI_MACHINE_EBC:\r\nstrcpy(a->image_type, "EFI EBC");\r\nreturn true;\r\ndefault:\r\ngoto invalid_rev;\r\n}\r\n} else {\r\nu32 thislen;\r\nthislen = (u32)le16_to_cpu(bh->image_length) * 512;\r\nif (thislen == 0\r\n|| thislen + offset > len\r\n|| bh->indicator == INDICATOR_LAST)\r\nbreak;\r\noffset += thislen;\r\n}\r\n}\r\ninvalid_rev:\r\nstrcpy(a->image_type, "no boot images");\r\nreturn false;\r\n}\r\nbool esas2r_nvram_read_direct(struct esas2r_adapter *a)\r\n{\r\nbool result;\r\nif (down_interruptible(&a->nvram_semaphore))\r\nreturn false;\r\nif (!esas2r_read_flash_block(a, a->nvram, FLS_OFFSET_NVR,\r\nsizeof(struct esas2r_sas_nvram))) {\r\nesas2r_hdebug("NVRAM read failed, using defaults");\r\nreturn false;\r\n}\r\nresult = esas2r_nvram_validate(a);\r\nup(&a->nvram_semaphore);\r\nreturn result;\r\n}\r\nstatic void esas2r_nvram_callback(struct esas2r_adapter *a,\r\nstruct esas2r_request *rq)\r\n{\r\nstruct atto_vda_flash_req *vrq = &rq->vrq->flash;\r\nif (rq->req_stat == RS_SUCCESS) {\r\nswitch (vrq->sub_func) {\r\ncase VDA_FLASH_BEGINW:\r\nvrq->sub_func = VDA_FLASH_WRITE;\r\nrq->req_stat = RS_PENDING;\r\nbreak;\r\ncase VDA_FLASH_WRITE:\r\nvrq->sub_func = VDA_FLASH_COMMIT;\r\nrq->req_stat = RS_PENDING;\r\nbreak;\r\ncase VDA_FLASH_READ:\r\nesas2r_nvram_validate(a);\r\nbreak;\r\ncase VDA_FLASH_COMMIT:\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nif (rq->req_stat != RS_PENDING) {\r\nif (rq->req_stat == RS_SUCCESS)\r\nset_bit(AF_NVR_VALID, &a->flags);\r\nelse\r\nclear_bit(AF_NVR_VALID, &a->flags);\r\nesas2r_enable_heartbeat(a);\r\nup(&a->nvram_semaphore);\r\n}\r\n}\r\nbool esas2r_nvram_write(struct esas2r_adapter *a, struct esas2r_request *rq,\r\nstruct esas2r_sas_nvram *nvram)\r\n{\r\nstruct esas2r_sas_nvram *n = nvram;\r\nu8 sas_address_bytes[8];\r\nu32 *sas_address_dwords = (u32 *)&sas_address_bytes[0];\r\nstruct atto_vda_flash_req *vrq = &rq->vrq->flash;\r\nif (test_bit(AF_DEGRADED_MODE, &a->flags))\r\nreturn false;\r\nif (down_interruptible(&a->nvram_semaphore))\r\nreturn false;\r\nif (n == NULL)\r\nn = a->nvram;\r\nif (n->version > SASNVR_VERSION) {\r\nup(&a->nvram_semaphore);\r\nreturn false;\r\n}\r\nmemcpy(&sas_address_bytes[0], n->sas_addr, 8);\r\nif (sas_address_bytes[0] != 0x50\r\n|| sas_address_bytes[1] != 0x01\r\n|| sas_address_bytes[2] != 0x08\r\n|| (sas_address_bytes[3] & 0xF0) != 0x60\r\n|| ((sas_address_bytes[3] & 0x0F) | sas_address_dwords[1]) == 0) {\r\nup(&a->nvram_semaphore);\r\nreturn false;\r\n}\r\nif (n->spin_up_delay > SASNVR_SPINUP_MAX)\r\nn->spin_up_delay = SASNVR_SPINUP_MAX;\r\nn->version = SASNVR_VERSION;\r\nn->checksum = n->checksum - esas2r_nvramcalc_cksum(n);\r\nmemcpy(a->nvram, n, sizeof(struct esas2r_sas_nvram));\r\nn = a->nvram;\r\nesas2r_disable_heartbeat(a);\r\nesas2r_build_flash_req(a,\r\nrq,\r\nVDA_FLASH_BEGINW,\r\nesas2r_nvramcalc_xor_cksum(n),\r\nFLS_OFFSET_NVR,\r\nsizeof(struct esas2r_sas_nvram));\r\nif (test_bit(AF_LEGACY_SGE_MODE, &a->flags)) {\r\nvrq->data.sge[0].length =\r\ncpu_to_le32(SGE_LAST |\r\nsizeof(struct esas2r_sas_nvram));\r\nvrq->data.sge[0].address = cpu_to_le64(\r\na->uncached_phys + (u64)((u8 *)n - a->uncached));\r\n} else {\r\nvrq->data.prde[0].ctl_len =\r\ncpu_to_le32(sizeof(struct esas2r_sas_nvram));\r\nvrq->data.prde[0].address = cpu_to_le64(\r\na->uncached_phys\r\n+ (u64)((u8 *)n - a->uncached));\r\n}\r\nrq->interrupt_cb = esas2r_nvram_callback;\r\nesas2r_start_request(a, rq);\r\nreturn true;\r\n}\r\nbool esas2r_nvram_validate(struct esas2r_adapter *a)\r\n{\r\nstruct esas2r_sas_nvram *n = a->nvram;\r\nbool rslt = false;\r\nif (n->signature[0] != 'E'\r\n|| n->signature[1] != 'S'\r\n|| n->signature[2] != 'A'\r\n|| n->signature[3] != 'S') {\r\nesas2r_hdebug("invalid NVRAM signature");\r\n} else if (esas2r_nvramcalc_cksum(n)) {\r\nesas2r_hdebug("invalid NVRAM checksum");\r\n} else if (n->version > SASNVR_VERSION) {\r\nesas2r_hdebug("invalid NVRAM version");\r\n} else {\r\nset_bit(AF_NVR_VALID, &a->flags);\r\nrslt = true;\r\n}\r\nif (rslt == false) {\r\nesas2r_hdebug("using defaults");\r\nesas2r_nvram_set_defaults(a);\r\n}\r\nreturn rslt;\r\n}\r\nvoid esas2r_nvram_set_defaults(struct esas2r_adapter *a)\r\n{\r\nstruct esas2r_sas_nvram *n = a->nvram;\r\nu32 time = jiffies_to_msecs(jiffies);\r\nclear_bit(AF_NVR_VALID, &a->flags);\r\n*n = default_sas_nvram;\r\nn->sas_addr[3] |= 0x0F;\r\nn->sas_addr[4] = HIBYTE(LOWORD(time));\r\nn->sas_addr[5] = LOBYTE(LOWORD(time));\r\nn->sas_addr[6] = a->pcid->bus->number;\r\nn->sas_addr[7] = a->pcid->devfn;\r\n}\r\nvoid esas2r_nvram_get_defaults(struct esas2r_adapter *a,\r\nstruct esas2r_sas_nvram *nvram)\r\n{\r\nu8 sas_addr[8];\r\nmemcpy(&sas_addr[0], a->nvram->sas_addr, 8);\r\n*nvram = default_sas_nvram;\r\nmemcpy(&nvram->sas_addr[0], &sas_addr[0], 8);\r\n}\r\nbool esas2r_fm_api(struct esas2r_adapter *a, struct esas2r_flash_img *fi,\r\nstruct esas2r_request *rq, struct esas2r_sg_context *sgc)\r\n{\r\nstruct esas2r_flash_context *fc = &a->flash_context;\r\nu8 j;\r\nstruct esas2r_component_header *ch;\r\nif (test_and_set_bit(AF_FLASH_LOCK, &a->flags)) {\r\nfi->status = FI_STAT_BUSY;\r\nreturn false;\r\n}\r\nmemcpy(&fc->sgc, sgc, sizeof(struct esas2r_sg_context));\r\nsgc = &fc->sgc;\r\nfc->fi = fi;\r\nfc->sgc_offset = sgc->cur_offset;\r\nrq->req_stat = RS_SUCCESS;\r\nrq->interrupt_cx = fc;\r\nswitch (fi->fi_version) {\r\ncase FI_VERSION_1:\r\nfc->scratch = ((struct esas2r_flash_img *)fi)->scratch_buf;\r\nfc->num_comps = FI_NUM_COMPS_V1;\r\nfc->fi_hdr_len = sizeof(struct esas2r_flash_img);\r\nbreak;\r\ndefault:\r\nreturn complete_fmapi_req(a, rq, FI_STAT_IMG_VER);\r\n}\r\nif (test_bit(AF_DEGRADED_MODE, &a->flags))\r\nreturn complete_fmapi_req(a, rq, FI_STAT_DEGRADED);\r\nswitch (fi->action) {\r\ncase FI_ACT_DOWN:\r\nif (!verify_fi(a, fc))\r\nreturn complete_fmapi_req(a, rq, fi->status);\r\nch = &fi->cmp_hdr[CH_IT_BIOS];\r\nif (ch->length)\r\nfix_bios(a, fi);\r\nch = &fi->cmp_hdr[CH_IT_EFI];\r\nif (ch->length)\r\nfix_efi(a, fi);\r\nfi->checksum = calc_fi_checksum(fc);\r\nesas2r_disable_heartbeat(a);\r\nfc->task = FMTSK_ERASE_BOOT;\r\nfc->func = VDA_FLASH_BEGINW;\r\nfc->comp_typ = CH_IT_CFG;\r\nfc->flsh_addr = FLS_OFFSET_BOOT;\r\nfc->sgc.length = FLS_LENGTH_BOOT;\r\nfc->sgc.cur_offset = NULL;\r\nfc->interrupt_cb = fw_download_proc;\r\nbreak;\r\ncase FI_ACT_UPSZ:\r\nfi->adap_typ = get_fi_adap_type(a);\r\nfi->flags = 0;\r\nfi->num_comps = fc->num_comps;\r\nfi->length = fc->fi_hdr_len;\r\nmemcpy(fi->rel_version, a->image_type,\r\nsizeof(fi->rel_version));\r\nfor (j = 0, ch = fi->cmp_hdr;\r\nj < fi->num_comps;\r\nj++, ch++) {\r\nch->img_type = j;\r\nch->status = CH_STAT_PENDING;\r\nch->length = 0;\r\nch->version = 0xffffffff;\r\nch->image_offset = 0;\r\nch->pad[0] = 0;\r\nch->pad[1] = 0;\r\n}\r\nif (a->flash_ver != 0) {\r\nfi->cmp_hdr[CH_IT_BIOS].version =\r\nfi->cmp_hdr[CH_IT_MAC].version =\r\nfi->cmp_hdr[CH_IT_EFI].version =\r\nfi->cmp_hdr[CH_IT_CFG].version\r\n= a->flash_ver;\r\nfi->cmp_hdr[CH_IT_BIOS].status =\r\nfi->cmp_hdr[CH_IT_MAC].status =\r\nfi->cmp_hdr[CH_IT_EFI].status =\r\nfi->cmp_hdr[CH_IT_CFG].status =\r\nCH_STAT_SUCCESS;\r\nreturn complete_fmapi_req(a, rq, FI_STAT_SUCCESS);\r\n}\r\ncase FI_ACT_UP:\r\ndefault:\r\nreturn complete_fmapi_req(a, rq, FI_STAT_INVALID);\r\n}\r\nif (!load_image(a, rq))\r\nreturn complete_fmapi_req(a, rq, FI_STAT_FAILED);\r\nesas2r_start_request(a, rq);\r\nreturn true;\r\n}
