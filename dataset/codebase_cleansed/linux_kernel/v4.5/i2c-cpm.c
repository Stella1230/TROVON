static irqreturn_t cpm_i2c_interrupt(int irq, void *dev_id)\r\n{\r\nstruct cpm_i2c *cpm;\r\nstruct i2c_reg __iomem *i2c_reg;\r\nstruct i2c_adapter *adap = dev_id;\r\nint i;\r\ncpm = i2c_get_adapdata(dev_id);\r\ni2c_reg = cpm->i2c_reg;\r\ni = in_8(&i2c_reg->i2cer);\r\nout_8(&i2c_reg->i2cer, i);\r\ndev_dbg(&adap->dev, "Interrupt: %x\n", i);\r\nwake_up(&cpm->i2c_wait);\r\nreturn i ? IRQ_HANDLED : IRQ_NONE;\r\n}\r\nstatic void cpm_reset_i2c_params(struct cpm_i2c *cpm)\r\n{\r\nstruct i2c_ram __iomem *i2c_ram = cpm->i2c_ram;\r\nout_be16(&i2c_ram->tbase, (u8 __iomem *)cpm->tbase - DPRAM_BASE);\r\nout_be16(&i2c_ram->rbase, (u8 __iomem *)cpm->rbase - DPRAM_BASE);\r\nif (cpm->version == 1) {\r\nout_8(&i2c_ram->tfcr, I2C_EB);\r\nout_8(&i2c_ram->rfcr, I2C_EB);\r\n} else {\r\nout_8(&i2c_ram->tfcr, I2C_EB_CPM2);\r\nout_8(&i2c_ram->rfcr, I2C_EB_CPM2);\r\n}\r\nout_be16(&i2c_ram->mrblr, CPM_MAX_READ);\r\nout_be32(&i2c_ram->rstate, 0);\r\nout_be32(&i2c_ram->rdp, 0);\r\nout_be16(&i2c_ram->rbptr, 0);\r\nout_be16(&i2c_ram->rbc, 0);\r\nout_be32(&i2c_ram->rxtmp, 0);\r\nout_be32(&i2c_ram->tstate, 0);\r\nout_be32(&i2c_ram->tdp, 0);\r\nout_be16(&i2c_ram->tbptr, 0);\r\nout_be16(&i2c_ram->tbc, 0);\r\nout_be32(&i2c_ram->txtmp, 0);\r\n}\r\nstatic void cpm_i2c_force_close(struct i2c_adapter *adap)\r\n{\r\nstruct cpm_i2c *cpm = i2c_get_adapdata(adap);\r\nstruct i2c_reg __iomem *i2c_reg = cpm->i2c_reg;\r\ndev_dbg(&adap->dev, "cpm_i2c_force_close()\n");\r\ncpm_command(cpm->cp_command, CPM_CR_CLOSE_RX_BD);\r\nout_8(&i2c_reg->i2cmr, 0x00);\r\nout_8(&i2c_reg->i2cer, 0xff);\r\n}\r\nstatic void cpm_i2c_parse_message(struct i2c_adapter *adap,\r\nstruct i2c_msg *pmsg, int num, int tx, int rx)\r\n{\r\ncbd_t __iomem *tbdf;\r\ncbd_t __iomem *rbdf;\r\nu_char addr;\r\nu_char *tb;\r\nu_char *rb;\r\nstruct cpm_i2c *cpm = i2c_get_adapdata(adap);\r\ntbdf = cpm->tbase + tx;\r\nrbdf = cpm->rbase + rx;\r\naddr = pmsg->addr << 1;\r\nif (pmsg->flags & I2C_M_RD)\r\naddr |= 1;\r\ntb = cpm->txbuf[tx];\r\nrb = cpm->rxbuf[rx];\r\nrb = (u_char *) (((ulong) rb + 1) & ~1);\r\ntb[0] = addr;\r\nout_be16(&tbdf->cbd_datlen, pmsg->len + 1);\r\nout_be16(&tbdf->cbd_sc, 0);\r\nif (!(pmsg->flags & I2C_M_NOSTART))\r\nsetbits16(&tbdf->cbd_sc, BD_I2C_START);\r\nif (tx + 1 == num)\r\nsetbits16(&tbdf->cbd_sc, BD_SC_LAST | BD_SC_WRAP);\r\nif (pmsg->flags & I2C_M_RD) {\r\ndev_dbg(&adap->dev, "cpm_i2c_read(abyte=0x%x)\n", addr);\r\nout_be16(&rbdf->cbd_datlen, 0);\r\nout_be16(&rbdf->cbd_sc, BD_SC_EMPTY | BD_SC_INTRPT);\r\nif (rx + 1 == CPM_MAXBD)\r\nsetbits16(&rbdf->cbd_sc, BD_SC_WRAP);\r\neieio();\r\nsetbits16(&tbdf->cbd_sc, BD_SC_READY);\r\n} else {\r\ndev_dbg(&adap->dev, "cpm_i2c_write(abyte=0x%x)\n", addr);\r\nmemcpy(tb+1, pmsg->buf, pmsg->len);\r\neieio();\r\nsetbits16(&tbdf->cbd_sc, BD_SC_READY | BD_SC_INTRPT);\r\n}\r\n}\r\nstatic int cpm_i2c_check_message(struct i2c_adapter *adap,\r\nstruct i2c_msg *pmsg, int tx, int rx)\r\n{\r\ncbd_t __iomem *tbdf;\r\ncbd_t __iomem *rbdf;\r\nu_char *tb;\r\nu_char *rb;\r\nstruct cpm_i2c *cpm = i2c_get_adapdata(adap);\r\ntbdf = cpm->tbase + tx;\r\nrbdf = cpm->rbase + rx;\r\ntb = cpm->txbuf[tx];\r\nrb = cpm->rxbuf[rx];\r\nrb = (u_char *) (((uint) rb + 1) & ~1);\r\neieio();\r\nif (pmsg->flags & I2C_M_RD) {\r\ndev_dbg(&adap->dev, "tx sc 0x%04x, rx sc 0x%04x\n",\r\nin_be16(&tbdf->cbd_sc), in_be16(&rbdf->cbd_sc));\r\nif (in_be16(&tbdf->cbd_sc) & BD_SC_NAK) {\r\ndev_dbg(&adap->dev, "I2C read; No ack\n");\r\nreturn -ENXIO;\r\n}\r\nif (in_be16(&rbdf->cbd_sc) & BD_SC_EMPTY) {\r\ndev_err(&adap->dev,\r\n"I2C read; complete but rbuf empty\n");\r\nreturn -EREMOTEIO;\r\n}\r\nif (in_be16(&rbdf->cbd_sc) & BD_SC_OV) {\r\ndev_err(&adap->dev, "I2C read; Overrun\n");\r\nreturn -EREMOTEIO;\r\n}\r\nmemcpy(pmsg->buf, rb, pmsg->len);\r\n} else {\r\ndev_dbg(&adap->dev, "tx sc %d 0x%04x\n", tx,\r\nin_be16(&tbdf->cbd_sc));\r\nif (in_be16(&tbdf->cbd_sc) & BD_SC_NAK) {\r\ndev_dbg(&adap->dev, "I2C write; No ack\n");\r\nreturn -ENXIO;\r\n}\r\nif (in_be16(&tbdf->cbd_sc) & BD_SC_UN) {\r\ndev_err(&adap->dev, "I2C write; Underrun\n");\r\nreturn -EIO;\r\n}\r\nif (in_be16(&tbdf->cbd_sc) & BD_SC_CL) {\r\ndev_err(&adap->dev, "I2C write; Collision\n");\r\nreturn -EIO;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int cpm_i2c_xfer(struct i2c_adapter *adap, struct i2c_msg *msgs, int num)\r\n{\r\nstruct cpm_i2c *cpm = i2c_get_adapdata(adap);\r\nstruct i2c_reg __iomem *i2c_reg = cpm->i2c_reg;\r\nstruct i2c_ram __iomem *i2c_ram = cpm->i2c_ram;\r\nstruct i2c_msg *pmsg;\r\nint ret;\r\nint tptr;\r\nint rptr;\r\ncbd_t __iomem *tbdf;\r\ncbd_t __iomem *rbdf;\r\nout_be16(&i2c_ram->rbptr, in_be16(&i2c_ram->rbase));\r\nout_be16(&i2c_ram->tbptr, in_be16(&i2c_ram->tbase));\r\ntbdf = cpm->tbase;\r\nrbdf = cpm->rbase;\r\ntptr = 0;\r\nrptr = 0;\r\nif (in_be16(&tbdf->cbd_sc) & BD_SC_CL) {\r\nout_8(&cpm->i2c_reg->i2com, I2COM_MASTER);\r\n}\r\nwhile (tptr < num) {\r\npmsg = &msgs[tptr];\r\ndev_dbg(&adap->dev, "R: %d T: %d\n", rptr, tptr);\r\ncpm_i2c_parse_message(adap, pmsg, num, tptr, rptr);\r\nif (pmsg->flags & I2C_M_RD)\r\nrptr++;\r\ntptr++;\r\n}\r\nout_8(&i2c_reg->i2cmr, I2CER_TXE | I2CER_TXB | I2CER_RXB);\r\nout_8(&i2c_reg->i2cer, 0xff);\r\nsetbits8(&i2c_reg->i2mod, I2MOD_EN);\r\nsetbits8(&i2c_reg->i2com, I2COM_START);\r\ntptr = 0;\r\nrptr = 0;\r\nwhile (tptr < num) {\r\ndev_dbg(&adap->dev, "test ready.\n");\r\npmsg = &msgs[tptr];\r\nif (pmsg->flags & I2C_M_RD)\r\nret = wait_event_timeout(cpm->i2c_wait,\r\n(in_be16(&tbdf[tptr].cbd_sc) & BD_SC_NAK) ||\r\n!(in_be16(&rbdf[rptr].cbd_sc) & BD_SC_EMPTY),\r\n1 * HZ);\r\nelse\r\nret = wait_event_timeout(cpm->i2c_wait,\r\n!(in_be16(&tbdf[tptr].cbd_sc) & BD_SC_READY),\r\n1 * HZ);\r\nif (ret == 0) {\r\nret = -EREMOTEIO;\r\ndev_err(&adap->dev, "I2C transfer: timeout\n");\r\ngoto out_err;\r\n}\r\nif (ret > 0) {\r\ndev_dbg(&adap->dev, "ready.\n");\r\nret = cpm_i2c_check_message(adap, pmsg, tptr, rptr);\r\ntptr++;\r\nif (pmsg->flags & I2C_M_RD)\r\nrptr++;\r\nif (ret)\r\ngoto out_err;\r\n}\r\n}\r\n#ifdef I2C_CHIP_ERRATA\r\nudelay(4);\r\nclrbits8(&i2c_reg->i2mod, I2MOD_EN);\r\n#endif\r\nreturn (num);\r\nout_err:\r\ncpm_i2c_force_close(adap);\r\n#ifdef I2C_CHIP_ERRATA\r\nclrbits8(&i2c_reg->i2mod, I2MOD_EN);\r\n#endif\r\nreturn ret;\r\n}\r\nstatic u32 cpm_i2c_func(struct i2c_adapter *adap)\r\n{\r\nreturn I2C_FUNC_I2C | (I2C_FUNC_SMBUS_EMUL & ~I2C_FUNC_SMBUS_QUICK);\r\n}\r\nstatic int cpm_i2c_setup(struct cpm_i2c *cpm)\r\n{\r\nstruct platform_device *ofdev = cpm->ofdev;\r\nconst u32 *data;\r\nint len, ret, i;\r\nvoid __iomem *i2c_base;\r\ncbd_t __iomem *tbdf;\r\ncbd_t __iomem *rbdf;\r\nunsigned char brg;\r\ndev_dbg(&cpm->ofdev->dev, "cpm_i2c_setup()\n");\r\ninit_waitqueue_head(&cpm->i2c_wait);\r\ncpm->irq = irq_of_parse_and_map(ofdev->dev.of_node, 0);\r\nif (!cpm->irq)\r\nreturn -EINVAL;\r\nret = request_irq(cpm->irq, cpm_i2c_interrupt, 0, "cpm_i2c",\r\n&cpm->adap);\r\nif (ret)\r\nreturn ret;\r\ni2c_base = of_iomap(ofdev->dev.of_node, 1);\r\nif (i2c_base == NULL) {\r\nret = -EINVAL;\r\ngoto out_irq;\r\n}\r\nif (of_device_is_compatible(ofdev->dev.of_node, "fsl,cpm1-i2c")) {\r\ncpm->i2c_ram = i2c_base;\r\ncpm->i2c_addr = in_be16(&cpm->i2c_ram->rpbase);\r\nif (cpm->i2c_addr) {\r\ncpm->i2c_ram = cpm_muram_addr(cpm->i2c_addr);\r\niounmap(i2c_base);\r\n}\r\ncpm->version = 1;\r\n} else if (of_device_is_compatible(ofdev->dev.of_node, "fsl,cpm2-i2c")) {\r\ncpm->i2c_addr = cpm_muram_alloc(sizeof(struct i2c_ram), 64);\r\ncpm->i2c_ram = cpm_muram_addr(cpm->i2c_addr);\r\nout_be16(i2c_base, cpm->i2c_addr);\r\niounmap(i2c_base);\r\ncpm->version = 2;\r\n} else {\r\niounmap(i2c_base);\r\nret = -EINVAL;\r\ngoto out_irq;\r\n}\r\ncpm->i2c_reg = of_iomap(ofdev->dev.of_node, 0);\r\nif (cpm->i2c_reg == NULL) {\r\nret = -EINVAL;\r\ngoto out_ram;\r\n}\r\ndata = of_get_property(ofdev->dev.of_node, "fsl,cpm-command", &len);\r\nif (!data || len != 4) {\r\nret = -EINVAL;\r\ngoto out_reg;\r\n}\r\ncpm->cp_command = *data;\r\ndata = of_get_property(ofdev->dev.of_node, "linux,i2c-class", &len);\r\nif (data && len == 4)\r\ncpm->adap.class = *data;\r\ndata = of_get_property(ofdev->dev.of_node, "clock-frequency", &len);\r\nif (data && len == 4)\r\ncpm->freq = *data;\r\nelse\r\ncpm->freq = 60000;\r\ncpm->dp_addr = cpm_muram_alloc(sizeof(cbd_t) * 2 * CPM_MAXBD, 8);\r\nif (!cpm->dp_addr) {\r\nret = -ENOMEM;\r\ngoto out_reg;\r\n}\r\ncpm->tbase = cpm_muram_addr(cpm->dp_addr);\r\ncpm->rbase = cpm_muram_addr(cpm->dp_addr + sizeof(cbd_t) * CPM_MAXBD);\r\ntbdf = cpm->tbase;\r\nrbdf = cpm->rbase;\r\nfor (i = 0; i < CPM_MAXBD; i++) {\r\ncpm->rxbuf[i] = dma_alloc_coherent(&cpm->ofdev->dev,\r\nCPM_MAX_READ + 1,\r\n&cpm->rxdma[i], GFP_KERNEL);\r\nif (!cpm->rxbuf[i]) {\r\nret = -ENOMEM;\r\ngoto out_muram;\r\n}\r\nout_be32(&rbdf[i].cbd_bufaddr, ((cpm->rxdma[i] + 1) & ~1));\r\ncpm->txbuf[i] = (unsigned char *)dma_alloc_coherent(&cpm->ofdev->dev, CPM_MAX_READ + 1, &cpm->txdma[i], GFP_KERNEL);\r\nif (!cpm->txbuf[i]) {\r\nret = -ENOMEM;\r\ngoto out_muram;\r\n}\r\nout_be32(&tbdf[i].cbd_bufaddr, cpm->txdma[i]);\r\n}\r\ncpm_reset_i2c_params(cpm);\r\ndev_dbg(&cpm->ofdev->dev, "i2c_ram 0x%p, i2c_addr 0x%04x, freq %d\n",\r\ncpm->i2c_ram, cpm->i2c_addr, cpm->freq);\r\ndev_dbg(&cpm->ofdev->dev, "tbase 0x%04x, rbase 0x%04x\n",\r\n(u8 __iomem *)cpm->tbase - DPRAM_BASE,\r\n(u8 __iomem *)cpm->rbase - DPRAM_BASE);\r\ncpm_command(cpm->cp_command, CPM_CR_INIT_TRX);\r\nout_8(&cpm->i2c_reg->i2add, 0x7f << 1);\r\nbrg = get_brgfreq() / (32 * 2 * cpm->freq) - 3;\r\nout_8(&cpm->i2c_reg->i2brg, brg);\r\nout_8(&cpm->i2c_reg->i2mod, 0x00);\r\nout_8(&cpm->i2c_reg->i2com, I2COM_MASTER);\r\nout_8(&cpm->i2c_reg->i2cmr, 0);\r\nout_8(&cpm->i2c_reg->i2cer, 0xff);\r\nreturn 0;\r\nout_muram:\r\nfor (i = 0; i < CPM_MAXBD; i++) {\r\nif (cpm->rxbuf[i])\r\ndma_free_coherent(&cpm->ofdev->dev, CPM_MAX_READ + 1,\r\ncpm->rxbuf[i], cpm->rxdma[i]);\r\nif (cpm->txbuf[i])\r\ndma_free_coherent(&cpm->ofdev->dev, CPM_MAX_READ + 1,\r\ncpm->txbuf[i], cpm->txdma[i]);\r\n}\r\ncpm_muram_free(cpm->dp_addr);\r\nout_reg:\r\niounmap(cpm->i2c_reg);\r\nout_ram:\r\nif ((cpm->version == 1) && (!cpm->i2c_addr))\r\niounmap(cpm->i2c_ram);\r\nif (cpm->version == 2)\r\ncpm_muram_free(cpm->i2c_addr);\r\nout_irq:\r\nfree_irq(cpm->irq, &cpm->adap);\r\nreturn ret;\r\n}\r\nstatic void cpm_i2c_shutdown(struct cpm_i2c *cpm)\r\n{\r\nint i;\r\nclrbits8(&cpm->i2c_reg->i2mod, I2MOD_EN);\r\nout_8(&cpm->i2c_reg->i2cmr, 0);\r\nout_8(&cpm->i2c_reg->i2cer, 0xff);\r\nfree_irq(cpm->irq, &cpm->adap);\r\nfor (i = 0; i < CPM_MAXBD; i++) {\r\ndma_free_coherent(&cpm->ofdev->dev, CPM_MAX_READ + 1,\r\ncpm->rxbuf[i], cpm->rxdma[i]);\r\ndma_free_coherent(&cpm->ofdev->dev, CPM_MAX_READ + 1,\r\ncpm->txbuf[i], cpm->txdma[i]);\r\n}\r\ncpm_muram_free(cpm->dp_addr);\r\niounmap(cpm->i2c_reg);\r\nif ((cpm->version == 1) && (!cpm->i2c_addr))\r\niounmap(cpm->i2c_ram);\r\nif (cpm->version == 2)\r\ncpm_muram_free(cpm->i2c_addr);\r\n}\r\nstatic int cpm_i2c_probe(struct platform_device *ofdev)\r\n{\r\nint result, len;\r\nstruct cpm_i2c *cpm;\r\nconst u32 *data;\r\ncpm = kzalloc(sizeof(struct cpm_i2c), GFP_KERNEL);\r\nif (!cpm)\r\nreturn -ENOMEM;\r\ncpm->ofdev = ofdev;\r\nplatform_set_drvdata(ofdev, cpm);\r\ncpm->adap = cpm_ops;\r\ni2c_set_adapdata(&cpm->adap, cpm);\r\ncpm->adap.dev.parent = &ofdev->dev;\r\ncpm->adap.dev.of_node = of_node_get(ofdev->dev.of_node);\r\nresult = cpm_i2c_setup(cpm);\r\nif (result) {\r\ndev_err(&ofdev->dev, "Unable to init hardware\n");\r\ngoto out_free;\r\n}\r\ndata = of_get_property(ofdev->dev.of_node, "linux,i2c-index", &len);\r\ncpm->adap.nr = (data && len == 4) ? be32_to_cpup(data) : -1;\r\nresult = i2c_add_numbered_adapter(&cpm->adap);\r\nif (result < 0) {\r\ndev_err(&ofdev->dev, "Unable to register with I2C\n");\r\ngoto out_shut;\r\n}\r\ndev_dbg(&ofdev->dev, "hw routines for %s registered.\n",\r\ncpm->adap.name);\r\nreturn 0;\r\nout_shut:\r\ncpm_i2c_shutdown(cpm);\r\nout_free:\r\nkfree(cpm);\r\nreturn result;\r\n}\r\nstatic int cpm_i2c_remove(struct platform_device *ofdev)\r\n{\r\nstruct cpm_i2c *cpm = platform_get_drvdata(ofdev);\r\ni2c_del_adapter(&cpm->adap);\r\ncpm_i2c_shutdown(cpm);\r\nkfree(cpm);\r\nreturn 0;\r\n}
