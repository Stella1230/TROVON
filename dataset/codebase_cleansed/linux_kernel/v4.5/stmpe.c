static int __stmpe_enable(struct stmpe *stmpe, unsigned int blocks)\r\n{\r\nreturn stmpe->variant->enable(stmpe, blocks, true);\r\n}\r\nstatic int __stmpe_disable(struct stmpe *stmpe, unsigned int blocks)\r\n{\r\nreturn stmpe->variant->enable(stmpe, blocks, false);\r\n}\r\nstatic int __stmpe_reg_read(struct stmpe *stmpe, u8 reg)\r\n{\r\nint ret;\r\nret = stmpe->ci->read_byte(stmpe, reg);\r\nif (ret < 0)\r\ndev_err(stmpe->dev, "failed to read reg %#x: %d\n", reg, ret);\r\ndev_vdbg(stmpe->dev, "rd: reg %#x => data %#x\n", reg, ret);\r\nreturn ret;\r\n}\r\nstatic int __stmpe_reg_write(struct stmpe *stmpe, u8 reg, u8 val)\r\n{\r\nint ret;\r\ndev_vdbg(stmpe->dev, "wr: reg %#x <= %#x\n", reg, val);\r\nret = stmpe->ci->write_byte(stmpe, reg, val);\r\nif (ret < 0)\r\ndev_err(stmpe->dev, "failed to write reg %#x: %d\n", reg, ret);\r\nreturn ret;\r\n}\r\nstatic int __stmpe_set_bits(struct stmpe *stmpe, u8 reg, u8 mask, u8 val)\r\n{\r\nint ret;\r\nret = __stmpe_reg_read(stmpe, reg);\r\nif (ret < 0)\r\nreturn ret;\r\nret &= ~mask;\r\nret |= val;\r\nreturn __stmpe_reg_write(stmpe, reg, ret);\r\n}\r\nstatic int __stmpe_block_read(struct stmpe *stmpe, u8 reg, u8 length,\r\nu8 *values)\r\n{\r\nint ret;\r\nret = stmpe->ci->read_block(stmpe, reg, length, values);\r\nif (ret < 0)\r\ndev_err(stmpe->dev, "failed to read regs %#x: %d\n", reg, ret);\r\ndev_vdbg(stmpe->dev, "rd: reg %#x (%d) => ret %#x\n", reg, length, ret);\r\nstmpe_dump_bytes("stmpe rd: ", values, length);\r\nreturn ret;\r\n}\r\nstatic int __stmpe_block_write(struct stmpe *stmpe, u8 reg, u8 length,\r\nconst u8 *values)\r\n{\r\nint ret;\r\ndev_vdbg(stmpe->dev, "wr: regs %#x (%d)\n", reg, length);\r\nstmpe_dump_bytes("stmpe wr: ", values, length);\r\nret = stmpe->ci->write_block(stmpe, reg, length, values);\r\nif (ret < 0)\r\ndev_err(stmpe->dev, "failed to write regs %#x: %d\n", reg, ret);\r\nreturn ret;\r\n}\r\nint stmpe_enable(struct stmpe *stmpe, unsigned int blocks)\r\n{\r\nint ret;\r\nmutex_lock(&stmpe->lock);\r\nret = __stmpe_enable(stmpe, blocks);\r\nmutex_unlock(&stmpe->lock);\r\nreturn ret;\r\n}\r\nint stmpe_disable(struct stmpe *stmpe, unsigned int blocks)\r\n{\r\nint ret;\r\nmutex_lock(&stmpe->lock);\r\nret = __stmpe_disable(stmpe, blocks);\r\nmutex_unlock(&stmpe->lock);\r\nreturn ret;\r\n}\r\nint stmpe_reg_read(struct stmpe *stmpe, u8 reg)\r\n{\r\nint ret;\r\nmutex_lock(&stmpe->lock);\r\nret = __stmpe_reg_read(stmpe, reg);\r\nmutex_unlock(&stmpe->lock);\r\nreturn ret;\r\n}\r\nint stmpe_reg_write(struct stmpe *stmpe, u8 reg, u8 val)\r\n{\r\nint ret;\r\nmutex_lock(&stmpe->lock);\r\nret = __stmpe_reg_write(stmpe, reg, val);\r\nmutex_unlock(&stmpe->lock);\r\nreturn ret;\r\n}\r\nint stmpe_set_bits(struct stmpe *stmpe, u8 reg, u8 mask, u8 val)\r\n{\r\nint ret;\r\nmutex_lock(&stmpe->lock);\r\nret = __stmpe_set_bits(stmpe, reg, mask, val);\r\nmutex_unlock(&stmpe->lock);\r\nreturn ret;\r\n}\r\nint stmpe_block_read(struct stmpe *stmpe, u8 reg, u8 length, u8 *values)\r\n{\r\nint ret;\r\nmutex_lock(&stmpe->lock);\r\nret = __stmpe_block_read(stmpe, reg, length, values);\r\nmutex_unlock(&stmpe->lock);\r\nreturn ret;\r\n}\r\nint stmpe_block_write(struct stmpe *stmpe, u8 reg, u8 length,\r\nconst u8 *values)\r\n{\r\nint ret;\r\nmutex_lock(&stmpe->lock);\r\nret = __stmpe_block_write(stmpe, reg, length, values);\r\nmutex_unlock(&stmpe->lock);\r\nreturn ret;\r\n}\r\nint stmpe_set_altfunc(struct stmpe *stmpe, u32 pins, enum stmpe_block block)\r\n{\r\nstruct stmpe_variant_info *variant = stmpe->variant;\r\nu8 regaddr = stmpe->regs[STMPE_IDX_GPAFR_U_MSB];\r\nint af_bits = variant->af_bits;\r\nint numregs = DIV_ROUND_UP(stmpe->num_gpios * af_bits, 8);\r\nint mask = (1 << af_bits) - 1;\r\nu8 regs[8];\r\nint af, afperreg, ret;\r\nif (!variant->get_altfunc)\r\nreturn 0;\r\nafperreg = 8 / af_bits;\r\nmutex_lock(&stmpe->lock);\r\nret = __stmpe_enable(stmpe, STMPE_BLOCK_GPIO);\r\nif (ret < 0)\r\ngoto out;\r\nret = __stmpe_block_read(stmpe, regaddr, numregs, regs);\r\nif (ret < 0)\r\ngoto out;\r\naf = variant->get_altfunc(stmpe, block);\r\nwhile (pins) {\r\nint pin = __ffs(pins);\r\nint regoffset = numregs - (pin / afperreg) - 1;\r\nint pos = (pin % afperreg) * (8 / afperreg);\r\nregs[regoffset] &= ~(mask << pos);\r\nregs[regoffset] |= af << pos;\r\npins &= ~(1 << pin);\r\n}\r\nret = __stmpe_block_write(stmpe, regaddr, numregs, regs);\r\nout:\r\nmutex_unlock(&stmpe->lock);\r\nreturn ret;\r\n}\r\nstatic int stmpe801_enable(struct stmpe *stmpe, unsigned int blocks,\r\nbool enable)\r\n{\r\nif (blocks & STMPE_BLOCK_GPIO)\r\nreturn 0;\r\nelse\r\nreturn -EINVAL;\r\n}\r\nstatic int stmpe811_enable(struct stmpe *stmpe, unsigned int blocks,\r\nbool enable)\r\n{\r\nunsigned int mask = 0;\r\nif (blocks & STMPE_BLOCK_GPIO)\r\nmask |= STMPE811_SYS_CTRL2_GPIO_OFF;\r\nif (blocks & STMPE_BLOCK_ADC)\r\nmask |= STMPE811_SYS_CTRL2_ADC_OFF;\r\nif (blocks & STMPE_BLOCK_TOUCHSCREEN)\r\nmask |= STMPE811_SYS_CTRL2_TSC_OFF;\r\nreturn __stmpe_set_bits(stmpe, STMPE811_REG_SYS_CTRL2, mask,\r\nenable ? 0 : mask);\r\n}\r\nstatic int stmpe811_get_altfunc(struct stmpe *stmpe, enum stmpe_block block)\r\n{\r\nreturn block != STMPE_BLOCK_TOUCHSCREEN;\r\n}\r\nstatic int stmpe_round_timeout(int timeout)\r\n{\r\nint i;\r\nfor (i = 0; i < ARRAY_SIZE(stmpe_autosleep_delay); i++) {\r\nif (stmpe_autosleep_delay[i] >= timeout)\r\nreturn i;\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int stmpe_autosleep(struct stmpe *stmpe, int autosleep_timeout)\r\n{\r\nint ret;\r\nif (!stmpe->variant->enable_autosleep)\r\nreturn -ENOSYS;\r\nmutex_lock(&stmpe->lock);\r\nret = stmpe->variant->enable_autosleep(stmpe, autosleep_timeout);\r\nmutex_unlock(&stmpe->lock);\r\nreturn ret;\r\n}\r\nstatic int stmpe1601_autosleep(struct stmpe *stmpe,\r\nint autosleep_timeout)\r\n{\r\nint ret, timeout;\r\ntimeout = stmpe_round_timeout(autosleep_timeout);\r\nif (timeout < 0) {\r\ndev_err(stmpe->dev, "invalid timeout\n");\r\nreturn timeout;\r\n}\r\nret = __stmpe_set_bits(stmpe, STMPE1601_REG_SYS_CTRL2,\r\nSTMPE1601_AUTOSLEEP_TIMEOUT_MASK,\r\ntimeout);\r\nif (ret < 0)\r\nreturn ret;\r\nreturn __stmpe_set_bits(stmpe, STMPE1601_REG_SYS_CTRL2,\r\nSTPME1601_AUTOSLEEP_ENABLE,\r\nSTPME1601_AUTOSLEEP_ENABLE);\r\n}\r\nstatic int stmpe1601_enable(struct stmpe *stmpe, unsigned int blocks,\r\nbool enable)\r\n{\r\nunsigned int mask = 0;\r\nif (blocks & STMPE_BLOCK_GPIO)\r\nmask |= STMPE1601_SYS_CTRL_ENABLE_GPIO;\r\nelse\r\nmask &= ~STMPE1601_SYS_CTRL_ENABLE_GPIO;\r\nif (blocks & STMPE_BLOCK_KEYPAD)\r\nmask |= STMPE1601_SYS_CTRL_ENABLE_KPC;\r\nelse\r\nmask &= ~STMPE1601_SYS_CTRL_ENABLE_KPC;\r\nif (blocks & STMPE_BLOCK_PWM)\r\nmask |= STMPE1601_SYS_CTRL_ENABLE_SPWM;\r\nelse\r\nmask &= ~STMPE1601_SYS_CTRL_ENABLE_SPWM;\r\nreturn __stmpe_set_bits(stmpe, STMPE1601_REG_SYS_CTRL, mask,\r\nenable ? mask : 0);\r\n}\r\nstatic int stmpe1601_get_altfunc(struct stmpe *stmpe, enum stmpe_block block)\r\n{\r\nswitch (block) {\r\ncase STMPE_BLOCK_PWM:\r\nreturn 2;\r\ncase STMPE_BLOCK_KEYPAD:\r\nreturn 1;\r\ncase STMPE_BLOCK_GPIO:\r\ndefault:\r\nreturn 0;\r\n}\r\n}\r\nstatic int stmpe1801_enable(struct stmpe *stmpe, unsigned int blocks,\r\nbool enable)\r\n{\r\nunsigned int mask = 0;\r\nif (blocks & STMPE_BLOCK_GPIO)\r\nmask |= STMPE1801_MSK_INT_EN_GPIO;\r\nif (blocks & STMPE_BLOCK_KEYPAD)\r\nmask |= STMPE1801_MSK_INT_EN_KPC;\r\nreturn __stmpe_set_bits(stmpe, STMPE1801_REG_INT_EN_MASK_LOW, mask,\r\nenable ? mask : 0);\r\n}\r\nstatic int stmpe1801_reset(struct stmpe *stmpe)\r\n{\r\nunsigned long timeout;\r\nint ret = 0;\r\nret = __stmpe_set_bits(stmpe, STMPE1801_REG_SYS_CTRL,\r\nSTMPE1801_MSK_SYS_CTRL_RESET, STMPE1801_MSK_SYS_CTRL_RESET);\r\nif (ret < 0)\r\nreturn ret;\r\ntimeout = jiffies + msecs_to_jiffies(100);\r\nwhile (time_before(jiffies, timeout)) {\r\nret = __stmpe_reg_read(stmpe, STMPE1801_REG_SYS_CTRL);\r\nif (ret < 0)\r\nreturn ret;\r\nif (!(ret & STMPE1801_MSK_SYS_CTRL_RESET))\r\nreturn 0;\r\nusleep_range(100, 200);\r\n}\r\nreturn -EIO;\r\n}\r\nstatic int stmpe24xx_enable(struct stmpe *stmpe, unsigned int blocks,\r\nbool enable)\r\n{\r\nunsigned int mask = 0;\r\nif (blocks & STMPE_BLOCK_GPIO)\r\nmask |= STMPE24XX_SYS_CTRL_ENABLE_GPIO;\r\nif (blocks & STMPE_BLOCK_KEYPAD)\r\nmask |= STMPE24XX_SYS_CTRL_ENABLE_KPC;\r\nreturn __stmpe_set_bits(stmpe, STMPE24XX_REG_SYS_CTRL, mask,\r\nenable ? mask : 0);\r\n}\r\nstatic int stmpe24xx_get_altfunc(struct stmpe *stmpe, enum stmpe_block block)\r\n{\r\nswitch (block) {\r\ncase STMPE_BLOCK_ROTATOR:\r\nreturn 2;\r\ncase STMPE_BLOCK_KEYPAD:\r\ncase STMPE_BLOCK_PWM:\r\nreturn 1;\r\ncase STMPE_BLOCK_GPIO:\r\ndefault:\r\nreturn 0;\r\n}\r\n}\r\nstatic irqreturn_t stmpe_irq(int irq, void *data)\r\n{\r\nstruct stmpe *stmpe = data;\r\nstruct stmpe_variant_info *variant = stmpe->variant;\r\nint num = DIV_ROUND_UP(variant->num_irqs, 8);\r\nu8 israddr;\r\nu8 isr[3];\r\nint ret;\r\nint i;\r\nif (variant->id_val == STMPE801_ID) {\r\nint base = irq_create_mapping(stmpe->domain, 0);\r\nhandle_nested_irq(base);\r\nreturn IRQ_HANDLED;\r\n}\r\nif (variant->id_val == STMPE1801_ID)\r\nisraddr = stmpe->regs[STMPE_IDX_ISR_LSB];\r\nelse\r\nisraddr = stmpe->regs[STMPE_IDX_ISR_MSB];\r\nret = stmpe_block_read(stmpe, israddr, num, isr);\r\nif (ret < 0)\r\nreturn IRQ_NONE;\r\nfor (i = 0; i < num; i++) {\r\nint bank = num - i - 1;\r\nu8 status = isr[i];\r\nu8 clear;\r\nstatus &= stmpe->ier[bank];\r\nif (!status)\r\ncontinue;\r\nclear = status;\r\nwhile (status) {\r\nint bit = __ffs(status);\r\nint line = bank * 8 + bit;\r\nint nestedirq = irq_create_mapping(stmpe->domain, line);\r\nhandle_nested_irq(nestedirq);\r\nstatus &= ~(1 << bit);\r\n}\r\nstmpe_reg_write(stmpe, israddr + i, clear);\r\n}\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void stmpe_irq_lock(struct irq_data *data)\r\n{\r\nstruct stmpe *stmpe = irq_data_get_irq_chip_data(data);\r\nmutex_lock(&stmpe->irq_lock);\r\n}\r\nstatic void stmpe_irq_sync_unlock(struct irq_data *data)\r\n{\r\nstruct stmpe *stmpe = irq_data_get_irq_chip_data(data);\r\nstruct stmpe_variant_info *variant = stmpe->variant;\r\nint num = DIV_ROUND_UP(variant->num_irqs, 8);\r\nint i;\r\nfor (i = 0; i < num; i++) {\r\nu8 new = stmpe->ier[i];\r\nu8 old = stmpe->oldier[i];\r\nif (new == old)\r\ncontinue;\r\nstmpe->oldier[i] = new;\r\nstmpe_reg_write(stmpe, stmpe->regs[STMPE_IDX_IER_LSB] - i, new);\r\n}\r\nmutex_unlock(&stmpe->irq_lock);\r\n}\r\nstatic void stmpe_irq_mask(struct irq_data *data)\r\n{\r\nstruct stmpe *stmpe = irq_data_get_irq_chip_data(data);\r\nint offset = data->hwirq;\r\nint regoffset = offset / 8;\r\nint mask = 1 << (offset % 8);\r\nstmpe->ier[regoffset] &= ~mask;\r\n}\r\nstatic void stmpe_irq_unmask(struct irq_data *data)\r\n{\r\nstruct stmpe *stmpe = irq_data_get_irq_chip_data(data);\r\nint offset = data->hwirq;\r\nint regoffset = offset / 8;\r\nint mask = 1 << (offset % 8);\r\nstmpe->ier[regoffset] |= mask;\r\n}\r\nstatic int stmpe_irq_map(struct irq_domain *d, unsigned int virq,\r\nirq_hw_number_t hwirq)\r\n{\r\nstruct stmpe *stmpe = d->host_data;\r\nstruct irq_chip *chip = NULL;\r\nif (stmpe->variant->id_val != STMPE801_ID)\r\nchip = &stmpe_irq_chip;\r\nirq_set_chip_data(virq, stmpe);\r\nirq_set_chip_and_handler(virq, chip, handle_edge_irq);\r\nirq_set_nested_thread(virq, 1);\r\nirq_set_noprobe(virq);\r\nreturn 0;\r\n}\r\nstatic void stmpe_irq_unmap(struct irq_domain *d, unsigned int virq)\r\n{\r\nirq_set_chip_and_handler(virq, NULL, NULL);\r\nirq_set_chip_data(virq, NULL);\r\n}\r\nstatic int stmpe_irq_init(struct stmpe *stmpe, struct device_node *np)\r\n{\r\nint base = 0;\r\nint num_irqs = stmpe->variant->num_irqs;\r\nstmpe->domain = irq_domain_add_simple(np, num_irqs, base,\r\n&stmpe_irq_ops, stmpe);\r\nif (!stmpe->domain) {\r\ndev_err(stmpe->dev, "Failed to create irqdomain\n");\r\nreturn -ENOSYS;\r\n}\r\nreturn 0;\r\n}\r\nstatic int stmpe_chip_init(struct stmpe *stmpe)\r\n{\r\nunsigned int irq_trigger = stmpe->pdata->irq_trigger;\r\nint autosleep_timeout = stmpe->pdata->autosleep_timeout;\r\nstruct stmpe_variant_info *variant = stmpe->variant;\r\nu8 icr = 0;\r\nunsigned int id;\r\nu8 data[2];\r\nint ret;\r\nret = stmpe_block_read(stmpe, stmpe->regs[STMPE_IDX_CHIP_ID],\r\nARRAY_SIZE(data), data);\r\nif (ret < 0)\r\nreturn ret;\r\nid = (data[0] << 8) | data[1];\r\nif ((id & variant->id_mask) != variant->id_val) {\r\ndev_err(stmpe->dev, "unknown chip id: %#x\n", id);\r\nreturn -EINVAL;\r\n}\r\ndev_info(stmpe->dev, "%s detected, chip id: %#x\n", variant->name, id);\r\nret = stmpe_disable(stmpe, ~0);\r\nif (ret)\r\nreturn ret;\r\nif (id == STMPE1801_ID) {\r\nret = stmpe1801_reset(stmpe);\r\nif (ret < 0)\r\nreturn ret;\r\n}\r\nif (stmpe->irq >= 0) {\r\nif (id == STMPE801_ID)\r\nicr = STMPE801_REG_SYS_CTRL_INT_EN;\r\nelse\r\nicr = STMPE_ICR_LSB_GIM;\r\nif (id != STMPE801_ID) {\r\nif (irq_trigger == IRQF_TRIGGER_FALLING ||\r\nirq_trigger == IRQF_TRIGGER_RISING)\r\nicr |= STMPE_ICR_LSB_EDGE;\r\n}\r\nif (irq_trigger == IRQF_TRIGGER_RISING ||\r\nirq_trigger == IRQF_TRIGGER_HIGH) {\r\nif (id == STMPE801_ID)\r\nicr |= STMPE801_REG_SYS_CTRL_INT_HI;\r\nelse\r\nicr |= STMPE_ICR_LSB_HIGH;\r\n}\r\n}\r\nif (stmpe->pdata->autosleep) {\r\nret = stmpe_autosleep(stmpe, autosleep_timeout);\r\nif (ret)\r\nreturn ret;\r\n}\r\nreturn stmpe_reg_write(stmpe, stmpe->regs[STMPE_IDX_ICR_LSB], icr);\r\n}\r\nstatic int stmpe_add_device(struct stmpe *stmpe, const struct mfd_cell *cell)\r\n{\r\nreturn mfd_add_devices(stmpe->dev, stmpe->pdata->id, cell, 1,\r\nNULL, 0, stmpe->domain);\r\n}\r\nstatic int stmpe_devices_init(struct stmpe *stmpe)\r\n{\r\nstruct stmpe_variant_info *variant = stmpe->variant;\r\nunsigned int platform_blocks = stmpe->pdata->blocks;\r\nint ret = -EINVAL;\r\nint i, j;\r\nfor (i = 0; i < variant->num_blocks; i++) {\r\nstruct stmpe_variant_block *block = &variant->blocks[i];\r\nif (!(platform_blocks & block->block))\r\ncontinue;\r\nfor (j = 0; j < block->cell->num_resources; j++) {\r\nstruct resource *res =\r\n(struct resource *) &block->cell->resources[j];\r\nif (res->flags & IORESOURCE_IRQ)\r\nres->start = res->end = block->irq + j;\r\n}\r\nplatform_blocks &= ~block->block;\r\nret = stmpe_add_device(stmpe, block->cell);\r\nif (ret)\r\nreturn ret;\r\n}\r\nif (platform_blocks)\r\ndev_warn(stmpe->dev,\r\n"platform wants blocks (%#x) not present on variant",\r\nplatform_blocks);\r\nreturn ret;\r\n}\r\nstatic void stmpe_of_probe(struct stmpe_platform_data *pdata,\r\nstruct device_node *np)\r\n{\r\nstruct device_node *child;\r\npdata->id = of_alias_get_id(np, "stmpe-i2c");\r\nif (pdata->id < 0)\r\npdata->id = -1;\r\npdata->irq_gpio = of_get_named_gpio_flags(np, "irq-gpio", 0,\r\n&pdata->irq_trigger);\r\nif (gpio_is_valid(pdata->irq_gpio))\r\npdata->irq_over_gpio = 1;\r\nelse\r\npdata->irq_trigger = IRQF_TRIGGER_NONE;\r\nof_property_read_u32(np, "st,autosleep-timeout",\r\n&pdata->autosleep_timeout);\r\npdata->autosleep = (pdata->autosleep_timeout) ? true : false;\r\nfor_each_child_of_node(np, child) {\r\nif (!strcmp(child->name, "stmpe_gpio")) {\r\npdata->blocks |= STMPE_BLOCK_GPIO;\r\n} else if (!strcmp(child->name, "stmpe_keypad")) {\r\npdata->blocks |= STMPE_BLOCK_KEYPAD;\r\n} else if (!strcmp(child->name, "stmpe_touchscreen")) {\r\npdata->blocks |= STMPE_BLOCK_TOUCHSCREEN;\r\n} else if (!strcmp(child->name, "stmpe_adc")) {\r\npdata->blocks |= STMPE_BLOCK_ADC;\r\n} else if (!strcmp(child->name, "stmpe_pwm")) {\r\npdata->blocks |= STMPE_BLOCK_PWM;\r\n} else if (!strcmp(child->name, "stmpe_rotator")) {\r\npdata->blocks |= STMPE_BLOCK_ROTATOR;\r\n}\r\n}\r\n}\r\nint stmpe_probe(struct stmpe_client_info *ci, enum stmpe_partnum partnum)\r\n{\r\nstruct stmpe_platform_data *pdata = dev_get_platdata(ci->dev);\r\nstruct device_node *np = ci->dev->of_node;\r\nstruct stmpe *stmpe;\r\nint ret;\r\nif (!pdata) {\r\nif (!np)\r\nreturn -EINVAL;\r\npdata = devm_kzalloc(ci->dev, sizeof(*pdata), GFP_KERNEL);\r\nif (!pdata)\r\nreturn -ENOMEM;\r\nstmpe_of_probe(pdata, np);\r\nif (of_find_property(np, "interrupts", NULL) == NULL)\r\nci->irq = -1;\r\n}\r\nstmpe = devm_kzalloc(ci->dev, sizeof(struct stmpe), GFP_KERNEL);\r\nif (!stmpe)\r\nreturn -ENOMEM;\r\nmutex_init(&stmpe->irq_lock);\r\nmutex_init(&stmpe->lock);\r\nstmpe->dev = ci->dev;\r\nstmpe->client = ci->client;\r\nstmpe->pdata = pdata;\r\nstmpe->ci = ci;\r\nstmpe->partnum = partnum;\r\nstmpe->variant = stmpe_variant_info[partnum];\r\nstmpe->regs = stmpe->variant->regs;\r\nstmpe->num_gpios = stmpe->variant->num_gpios;\r\nstmpe->vcc = devm_regulator_get_optional(ci->dev, "vcc");\r\nif (!IS_ERR(stmpe->vcc)) {\r\nret = regulator_enable(stmpe->vcc);\r\nif (ret)\r\ndev_warn(ci->dev, "failed to enable VCC supply\n");\r\n}\r\nstmpe->vio = devm_regulator_get_optional(ci->dev, "vio");\r\nif (!IS_ERR(stmpe->vio)) {\r\nret = regulator_enable(stmpe->vio);\r\nif (ret)\r\ndev_warn(ci->dev, "failed to enable VIO supply\n");\r\n}\r\ndev_set_drvdata(stmpe->dev, stmpe);\r\nif (ci->init)\r\nci->init(stmpe);\r\nif (pdata->irq_over_gpio) {\r\nret = devm_gpio_request_one(ci->dev, pdata->irq_gpio,\r\nGPIOF_DIR_IN, "stmpe");\r\nif (ret) {\r\ndev_err(stmpe->dev, "failed to request IRQ GPIO: %d\n",\r\nret);\r\nreturn ret;\r\n}\r\nstmpe->irq = gpio_to_irq(pdata->irq_gpio);\r\n} else {\r\nstmpe->irq = ci->irq;\r\n}\r\nif (stmpe->irq < 0) {\r\ndev_info(stmpe->dev,\r\n"%s configured in no-irq mode by platform data\n",\r\nstmpe->variant->name);\r\nif (!stmpe_noirq_variant_info[stmpe->partnum]) {\r\ndev_err(stmpe->dev,\r\n"%s does not support no-irq mode!\n",\r\nstmpe->variant->name);\r\nreturn -ENODEV;\r\n}\r\nstmpe->variant = stmpe_noirq_variant_info[stmpe->partnum];\r\n} else if (pdata->irq_trigger == IRQF_TRIGGER_NONE) {\r\npdata->irq_trigger = irq_get_trigger_type(stmpe->irq);\r\n}\r\nret = stmpe_chip_init(stmpe);\r\nif (ret)\r\nreturn ret;\r\nif (stmpe->irq >= 0) {\r\nret = stmpe_irq_init(stmpe, np);\r\nif (ret)\r\nreturn ret;\r\nret = devm_request_threaded_irq(ci->dev, stmpe->irq, NULL,\r\nstmpe_irq, pdata->irq_trigger | IRQF_ONESHOT,\r\n"stmpe", stmpe);\r\nif (ret) {\r\ndev_err(stmpe->dev, "failed to request IRQ: %d\n",\r\nret);\r\nreturn ret;\r\n}\r\n}\r\nret = stmpe_devices_init(stmpe);\r\nif (!ret)\r\nreturn 0;\r\ndev_err(stmpe->dev, "failed to add children\n");\r\nmfd_remove_devices(stmpe->dev);\r\nreturn ret;\r\n}\r\nint stmpe_remove(struct stmpe *stmpe)\r\n{\r\nif (!IS_ERR(stmpe->vio))\r\nregulator_disable(stmpe->vio);\r\nif (!IS_ERR(stmpe->vcc))\r\nregulator_disable(stmpe->vcc);\r\nmfd_remove_devices(stmpe->dev);\r\nreturn 0;\r\n}\r\nstatic int stmpe_suspend(struct device *dev)\r\n{\r\nstruct stmpe *stmpe = dev_get_drvdata(dev);\r\nif (stmpe->irq >= 0 && device_may_wakeup(dev))\r\nenable_irq_wake(stmpe->irq);\r\nreturn 0;\r\n}\r\nstatic int stmpe_resume(struct device *dev)\r\n{\r\nstruct stmpe *stmpe = dev_get_drvdata(dev);\r\nif (stmpe->irq >= 0 && device_may_wakeup(dev))\r\ndisable_irq_wake(stmpe->irq);\r\nreturn 0;\r\n}
