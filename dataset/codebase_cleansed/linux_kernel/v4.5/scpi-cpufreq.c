static struct scpi_dvfs_info *scpi_get_dvfs_info(struct device *cpu_dev)\r\n{\r\nint domain = topology_physical_package_id(cpu_dev->id);\r\nif (domain < 0)\r\nreturn ERR_PTR(-EINVAL);\r\nreturn scpi_ops->dvfs_get_info(domain);\r\n}\r\nstatic int scpi_opp_table_ops(struct device *cpu_dev, bool remove)\r\n{\r\nint idx, ret = 0;\r\nstruct scpi_opp *opp;\r\nstruct scpi_dvfs_info *info = scpi_get_dvfs_info(cpu_dev);\r\nif (IS_ERR(info))\r\nreturn PTR_ERR(info);\r\nif (!info->opps)\r\nreturn -EIO;\r\nfor (opp = info->opps, idx = 0; idx < info->count; idx++, opp++) {\r\nif (remove)\r\ndev_pm_opp_remove(cpu_dev, opp->freq);\r\nelse\r\nret = dev_pm_opp_add(cpu_dev, opp->freq,\r\nopp->m_volt * 1000);\r\nif (ret) {\r\ndev_warn(cpu_dev, "failed to add opp %uHz %umV\n",\r\nopp->freq, opp->m_volt);\r\nwhile (idx-- > 0)\r\ndev_pm_opp_remove(cpu_dev, (--opp)->freq);\r\nreturn ret;\r\n}\r\n}\r\nreturn ret;\r\n}\r\nstatic int scpi_get_transition_latency(struct device *cpu_dev)\r\n{\r\nstruct scpi_dvfs_info *info = scpi_get_dvfs_info(cpu_dev);\r\nif (IS_ERR(info))\r\nreturn PTR_ERR(info);\r\nreturn info->latency;\r\n}\r\nstatic int scpi_init_opp_table(struct device *cpu_dev)\r\n{\r\nreturn scpi_opp_table_ops(cpu_dev, false);\r\n}\r\nstatic void scpi_free_opp_table(struct device *cpu_dev)\r\n{\r\nscpi_opp_table_ops(cpu_dev, true);\r\n}\r\nstatic int scpi_cpufreq_probe(struct platform_device *pdev)\r\n{\r\nscpi_ops = get_scpi_ops();\r\nif (!scpi_ops)\r\nreturn -EIO;\r\nreturn bL_cpufreq_register(&scpi_cpufreq_ops);\r\n}\r\nstatic int scpi_cpufreq_remove(struct platform_device *pdev)\r\n{\r\nbL_cpufreq_unregister(&scpi_cpufreq_ops);\r\nscpi_ops = NULL;\r\nreturn 0;\r\n}
