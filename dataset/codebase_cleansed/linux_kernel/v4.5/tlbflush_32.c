void local_flush_tlb_page(struct vm_area_struct *vma, unsigned long page)\r\n{\r\nunsigned int cpu = smp_processor_id();\r\nif (vma->vm_mm && cpu_context(cpu, vma->vm_mm) != NO_CONTEXT) {\r\nunsigned long flags;\r\nunsigned long asid;\r\nunsigned long saved_asid = MMU_NO_ASID;\r\nasid = cpu_asid(cpu, vma->vm_mm);\r\npage &= PAGE_MASK;\r\nlocal_irq_save(flags);\r\nif (vma->vm_mm != current->mm) {\r\nsaved_asid = get_asid();\r\nset_asid(asid);\r\n}\r\nlocal_flush_tlb_one(asid, page);\r\nif (saved_asid != MMU_NO_ASID)\r\nset_asid(saved_asid);\r\nlocal_irq_restore(flags);\r\n}\r\n}\r\nvoid local_flush_tlb_range(struct vm_area_struct *vma, unsigned long start,\r\nunsigned long end)\r\n{\r\nstruct mm_struct *mm = vma->vm_mm;\r\nunsigned int cpu = smp_processor_id();\r\nif (cpu_context(cpu, mm) != NO_CONTEXT) {\r\nunsigned long flags;\r\nint size;\r\nlocal_irq_save(flags);\r\nsize = (end - start + (PAGE_SIZE - 1)) >> PAGE_SHIFT;\r\nif (size > (MMU_NTLB_ENTRIES/4)) {\r\ncpu_context(cpu, mm) = NO_CONTEXT;\r\nif (mm == current->mm)\r\nactivate_context(mm, cpu);\r\n} else {\r\nunsigned long asid;\r\nunsigned long saved_asid = MMU_NO_ASID;\r\nasid = cpu_asid(cpu, mm);\r\nstart &= PAGE_MASK;\r\nend += (PAGE_SIZE - 1);\r\nend &= PAGE_MASK;\r\nif (mm != current->mm) {\r\nsaved_asid = get_asid();\r\nset_asid(asid);\r\n}\r\nwhile (start < end) {\r\nlocal_flush_tlb_one(asid, start);\r\nstart += PAGE_SIZE;\r\n}\r\nif (saved_asid != MMU_NO_ASID)\r\nset_asid(saved_asid);\r\n}\r\nlocal_irq_restore(flags);\r\n}\r\n}\r\nvoid local_flush_tlb_kernel_range(unsigned long start, unsigned long end)\r\n{\r\nunsigned int cpu = smp_processor_id();\r\nunsigned long flags;\r\nint size;\r\nlocal_irq_save(flags);\r\nsize = (end - start + (PAGE_SIZE - 1)) >> PAGE_SHIFT;\r\nif (size > (MMU_NTLB_ENTRIES/4)) {\r\nlocal_flush_tlb_all();\r\n} else {\r\nunsigned long asid;\r\nunsigned long saved_asid = get_asid();\r\nasid = cpu_asid(cpu, &init_mm);\r\nstart &= PAGE_MASK;\r\nend += (PAGE_SIZE - 1);\r\nend &= PAGE_MASK;\r\nset_asid(asid);\r\nwhile (start < end) {\r\nlocal_flush_tlb_one(asid, start);\r\nstart += PAGE_SIZE;\r\n}\r\nset_asid(saved_asid);\r\n}\r\nlocal_irq_restore(flags);\r\n}\r\nvoid local_flush_tlb_mm(struct mm_struct *mm)\r\n{\r\nunsigned int cpu = smp_processor_id();\r\nif (cpu_context(cpu, mm) != NO_CONTEXT) {\r\nunsigned long flags;\r\nlocal_irq_save(flags);\r\ncpu_context(cpu, mm) = NO_CONTEXT;\r\nif (mm == current->mm)\r\nactivate_context(mm, cpu);\r\nlocal_irq_restore(flags);\r\n}\r\n}\r\nvoid __flush_tlb_global(void)\r\n{\r\nunsigned long flags;\r\nlocal_irq_save(flags);\r\n__raw_writel(__raw_readl(MMUCR) | MMUCR_TI, MMUCR);\r\nlocal_irq_restore(flags);\r\n}
