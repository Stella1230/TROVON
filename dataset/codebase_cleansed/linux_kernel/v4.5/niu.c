static u64 readq(void __iomem *reg)\r\n{\r\nreturn ((u64) readl(reg)) | (((u64) readl(reg + 4UL)) << 32);\r\n}\r\nstatic void writeq(u64 val, void __iomem *reg)\r\n{\r\nwritel(val & 0xffffffff, reg);\r\nwritel(val >> 32, reg + 0x4UL);\r\n}\r\nstatic int __niu_wait_bits_clear_mac(struct niu *np, unsigned long reg,\r\nu64 bits, int limit, int delay)\r\n{\r\nwhile (--limit >= 0) {\r\nu64 val = nr64_mac(reg);\r\nif (!(val & bits))\r\nbreak;\r\nudelay(delay);\r\n}\r\nif (limit < 0)\r\nreturn -ENODEV;\r\nreturn 0;\r\n}\r\nstatic int __niu_set_and_wait_clear_mac(struct niu *np, unsigned long reg,\r\nu64 bits, int limit, int delay,\r\nconst char *reg_name)\r\n{\r\nint err;\r\nnw64_mac(reg, bits);\r\nerr = __niu_wait_bits_clear_mac(np, reg, bits, limit, delay);\r\nif (err)\r\nnetdev_err(np->dev, "bits (%llx) of register %s would not clear, val[%llx]\n",\r\n(unsigned long long)bits, reg_name,\r\n(unsigned long long)nr64_mac(reg));\r\nreturn err;\r\n}\r\nstatic int __niu_wait_bits_clear_ipp(struct niu *np, unsigned long reg,\r\nu64 bits, int limit, int delay)\r\n{\r\nwhile (--limit >= 0) {\r\nu64 val = nr64_ipp(reg);\r\nif (!(val & bits))\r\nbreak;\r\nudelay(delay);\r\n}\r\nif (limit < 0)\r\nreturn -ENODEV;\r\nreturn 0;\r\n}\r\nstatic int __niu_set_and_wait_clear_ipp(struct niu *np, unsigned long reg,\r\nu64 bits, int limit, int delay,\r\nconst char *reg_name)\r\n{\r\nint err;\r\nu64 val;\r\nval = nr64_ipp(reg);\r\nval |= bits;\r\nnw64_ipp(reg, val);\r\nerr = __niu_wait_bits_clear_ipp(np, reg, bits, limit, delay);\r\nif (err)\r\nnetdev_err(np->dev, "bits (%llx) of register %s would not clear, val[%llx]\n",\r\n(unsigned long long)bits, reg_name,\r\n(unsigned long long)nr64_ipp(reg));\r\nreturn err;\r\n}\r\nstatic int __niu_wait_bits_clear(struct niu *np, unsigned long reg,\r\nu64 bits, int limit, int delay)\r\n{\r\nwhile (--limit >= 0) {\r\nu64 val = nr64(reg);\r\nif (!(val & bits))\r\nbreak;\r\nudelay(delay);\r\n}\r\nif (limit < 0)\r\nreturn -ENODEV;\r\nreturn 0;\r\n}\r\nstatic int __niu_set_and_wait_clear(struct niu *np, unsigned long reg,\r\nu64 bits, int limit, int delay,\r\nconst char *reg_name)\r\n{\r\nint err;\r\nnw64(reg, bits);\r\nerr = __niu_wait_bits_clear(np, reg, bits, limit, delay);\r\nif (err)\r\nnetdev_err(np->dev, "bits (%llx) of register %s would not clear, val[%llx]\n",\r\n(unsigned long long)bits, reg_name,\r\n(unsigned long long)nr64(reg));\r\nreturn err;\r\n}\r\nstatic void niu_ldg_rearm(struct niu *np, struct niu_ldg *lp, int on)\r\n{\r\nu64 val = (u64) lp->timer;\r\nif (on)\r\nval |= LDG_IMGMT_ARM;\r\nnw64(LDG_IMGMT(lp->ldg_num), val);\r\n}\r\nstatic int niu_ldn_irq_enable(struct niu *np, int ldn, int on)\r\n{\r\nunsigned long mask_reg, bits;\r\nu64 val;\r\nif (ldn < 0 || ldn > LDN_MAX)\r\nreturn -EINVAL;\r\nif (ldn < 64) {\r\nmask_reg = LD_IM0(ldn);\r\nbits = LD_IM0_MASK;\r\n} else {\r\nmask_reg = LD_IM1(ldn - 64);\r\nbits = LD_IM1_MASK;\r\n}\r\nval = nr64(mask_reg);\r\nif (on)\r\nval &= ~bits;\r\nelse\r\nval |= bits;\r\nnw64(mask_reg, val);\r\nreturn 0;\r\n}\r\nstatic int niu_enable_ldn_in_ldg(struct niu *np, struct niu_ldg *lp, int on)\r\n{\r\nstruct niu_parent *parent = np->parent;\r\nint i;\r\nfor (i = 0; i <= LDN_MAX; i++) {\r\nint err;\r\nif (parent->ldg_map[i] != lp->ldg_num)\r\ncontinue;\r\nerr = niu_ldn_irq_enable(np, i, on);\r\nif (err)\r\nreturn err;\r\n}\r\nreturn 0;\r\n}\r\nstatic int niu_enable_interrupts(struct niu *np, int on)\r\n{\r\nint i;\r\nfor (i = 0; i < np->num_ldg; i++) {\r\nstruct niu_ldg *lp = &np->ldg[i];\r\nint err;\r\nerr = niu_enable_ldn_in_ldg(np, lp, on);\r\nif (err)\r\nreturn err;\r\n}\r\nfor (i = 0; i < np->num_ldg; i++)\r\nniu_ldg_rearm(np, &np->ldg[i], on);\r\nreturn 0;\r\n}\r\nstatic u32 phy_encode(u32 type, int port)\r\n{\r\nreturn type << (port * 2);\r\n}\r\nstatic u32 phy_decode(u32 val, int port)\r\n{\r\nreturn (val >> (port * 2)) & PORT_TYPE_MASK;\r\n}\r\nstatic int mdio_wait(struct niu *np)\r\n{\r\nint limit = 1000;\r\nu64 val;\r\nwhile (--limit > 0) {\r\nval = nr64(MIF_FRAME_OUTPUT);\r\nif ((val >> MIF_FRAME_OUTPUT_TA_SHIFT) & 0x1)\r\nreturn val & MIF_FRAME_OUTPUT_DATA;\r\nudelay(10);\r\n}\r\nreturn -ENODEV;\r\n}\r\nstatic int mdio_read(struct niu *np, int port, int dev, int reg)\r\n{\r\nint err;\r\nnw64(MIF_FRAME_OUTPUT, MDIO_ADDR_OP(port, dev, reg));\r\nerr = mdio_wait(np);\r\nif (err < 0)\r\nreturn err;\r\nnw64(MIF_FRAME_OUTPUT, MDIO_READ_OP(port, dev));\r\nreturn mdio_wait(np);\r\n}\r\nstatic int mdio_write(struct niu *np, int port, int dev, int reg, int data)\r\n{\r\nint err;\r\nnw64(MIF_FRAME_OUTPUT, MDIO_ADDR_OP(port, dev, reg));\r\nerr = mdio_wait(np);\r\nif (err < 0)\r\nreturn err;\r\nnw64(MIF_FRAME_OUTPUT, MDIO_WRITE_OP(port, dev, data));\r\nerr = mdio_wait(np);\r\nif (err < 0)\r\nreturn err;\r\nreturn 0;\r\n}\r\nstatic int mii_read(struct niu *np, int port, int reg)\r\n{\r\nnw64(MIF_FRAME_OUTPUT, MII_READ_OP(port, reg));\r\nreturn mdio_wait(np);\r\n}\r\nstatic int mii_write(struct niu *np, int port, int reg, int data)\r\n{\r\nint err;\r\nnw64(MIF_FRAME_OUTPUT, MII_WRITE_OP(port, reg, data));\r\nerr = mdio_wait(np);\r\nif (err < 0)\r\nreturn err;\r\nreturn 0;\r\n}\r\nstatic int esr2_set_tx_cfg(struct niu *np, unsigned long channel, u32 val)\r\n{\r\nint err;\r\nerr = mdio_write(np, np->port, NIU_ESR2_DEV_ADDR,\r\nESR2_TI_PLL_TX_CFG_L(channel),\r\nval & 0xffff);\r\nif (!err)\r\nerr = mdio_write(np, np->port, NIU_ESR2_DEV_ADDR,\r\nESR2_TI_PLL_TX_CFG_H(channel),\r\nval >> 16);\r\nreturn err;\r\n}\r\nstatic int esr2_set_rx_cfg(struct niu *np, unsigned long channel, u32 val)\r\n{\r\nint err;\r\nerr = mdio_write(np, np->port, NIU_ESR2_DEV_ADDR,\r\nESR2_TI_PLL_RX_CFG_L(channel),\r\nval & 0xffff);\r\nif (!err)\r\nerr = mdio_write(np, np->port, NIU_ESR2_DEV_ADDR,\r\nESR2_TI_PLL_RX_CFG_H(channel),\r\nval >> 16);\r\nreturn err;\r\n}\r\nstatic int serdes_init_niu_10g_fiber(struct niu *np)\r\n{\r\nstruct niu_link_config *lp = &np->link_config;\r\nu32 tx_cfg, rx_cfg;\r\nunsigned long i;\r\ntx_cfg = (PLL_TX_CFG_ENTX | PLL_TX_CFG_SWING_1375MV);\r\nrx_cfg = (PLL_RX_CFG_ENRX | PLL_RX_CFG_TERM_0P8VDDT |\r\nPLL_RX_CFG_ALIGN_ENA | PLL_RX_CFG_LOS_LTHRESH |\r\nPLL_RX_CFG_EQ_LP_ADAPTIVE);\r\nif (lp->loopback_mode == LOOPBACK_PHY) {\r\nu16 test_cfg = PLL_TEST_CFG_LOOPBACK_CML_DIS;\r\nmdio_write(np, np->port, NIU_ESR2_DEV_ADDR,\r\nESR2_TI_PLL_TEST_CFG_L, test_cfg);\r\ntx_cfg |= PLL_TX_CFG_ENTEST;\r\nrx_cfg |= PLL_RX_CFG_ENTEST;\r\n}\r\nfor (i = 0; i < 4; i++) {\r\nint err = esr2_set_tx_cfg(np, i, tx_cfg);\r\nif (err)\r\nreturn err;\r\n}\r\nfor (i = 0; i < 4; i++) {\r\nint err = esr2_set_rx_cfg(np, i, rx_cfg);\r\nif (err)\r\nreturn err;\r\n}\r\nreturn 0;\r\n}\r\nstatic int serdes_init_niu_1g_serdes(struct niu *np)\r\n{\r\nstruct niu_link_config *lp = &np->link_config;\r\nu16 pll_cfg, pll_sts;\r\nint max_retry = 100;\r\nu64 uninitialized_var(sig), mask, val;\r\nu32 tx_cfg, rx_cfg;\r\nunsigned long i;\r\nint err;\r\ntx_cfg = (PLL_TX_CFG_ENTX | PLL_TX_CFG_SWING_1375MV |\r\nPLL_TX_CFG_RATE_HALF);\r\nrx_cfg = (PLL_RX_CFG_ENRX | PLL_RX_CFG_TERM_0P8VDDT |\r\nPLL_RX_CFG_ALIGN_ENA | PLL_RX_CFG_LOS_LTHRESH |\r\nPLL_RX_CFG_RATE_HALF);\r\nif (np->port == 0)\r\nrx_cfg |= PLL_RX_CFG_EQ_LP_ADAPTIVE;\r\nif (lp->loopback_mode == LOOPBACK_PHY) {\r\nu16 test_cfg = PLL_TEST_CFG_LOOPBACK_CML_DIS;\r\nmdio_write(np, np->port, NIU_ESR2_DEV_ADDR,\r\nESR2_TI_PLL_TEST_CFG_L, test_cfg);\r\ntx_cfg |= PLL_TX_CFG_ENTEST;\r\nrx_cfg |= PLL_RX_CFG_ENTEST;\r\n}\r\npll_cfg = (PLL_CFG_ENPLL | PLL_CFG_MPY_8X);\r\nerr = mdio_write(np, np->port, NIU_ESR2_DEV_ADDR,\r\nESR2_TI_PLL_CFG_L, pll_cfg);\r\nif (err) {\r\nnetdev_err(np->dev, "NIU Port %d %s() mdio write to ESR2_TI_PLL_CFG_L failed\n",\r\nnp->port, __func__);\r\nreturn err;\r\n}\r\npll_sts = PLL_CFG_ENPLL;\r\nerr = mdio_write(np, np->port, NIU_ESR2_DEV_ADDR,\r\nESR2_TI_PLL_STS_L, pll_sts);\r\nif (err) {\r\nnetdev_err(np->dev, "NIU Port %d %s() mdio write to ESR2_TI_PLL_STS_L failed\n",\r\nnp->port, __func__);\r\nreturn err;\r\n}\r\nudelay(200);\r\nfor (i = 0; i < 4; i++) {\r\nerr = esr2_set_tx_cfg(np, i, tx_cfg);\r\nif (err)\r\nreturn err;\r\n}\r\nfor (i = 0; i < 4; i++) {\r\nerr = esr2_set_rx_cfg(np, i, rx_cfg);\r\nif (err)\r\nreturn err;\r\n}\r\nswitch (np->port) {\r\ncase 0:\r\nval = (ESR_INT_SRDY0_P0 | ESR_INT_DET0_P0);\r\nmask = val;\r\nbreak;\r\ncase 1:\r\nval = (ESR_INT_SRDY0_P1 | ESR_INT_DET0_P1);\r\nmask = val;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nwhile (max_retry--) {\r\nsig = nr64(ESR_INT_SIGNALS);\r\nif ((sig & mask) == val)\r\nbreak;\r\nmdelay(500);\r\n}\r\nif ((sig & mask) != val) {\r\nnetdev_err(np->dev, "Port %u signal bits [%08x] are not [%08x]\n",\r\nnp->port, (int)(sig & mask), (int)val);\r\nreturn -ENODEV;\r\n}\r\nreturn 0;\r\n}\r\nstatic int serdes_init_niu_10g_serdes(struct niu *np)\r\n{\r\nstruct niu_link_config *lp = &np->link_config;\r\nu32 tx_cfg, rx_cfg, pll_cfg, pll_sts;\r\nint max_retry = 100;\r\nu64 uninitialized_var(sig), mask, val;\r\nunsigned long i;\r\nint err;\r\ntx_cfg = (PLL_TX_CFG_ENTX | PLL_TX_CFG_SWING_1375MV);\r\nrx_cfg = (PLL_RX_CFG_ENRX | PLL_RX_CFG_TERM_0P8VDDT |\r\nPLL_RX_CFG_ALIGN_ENA | PLL_RX_CFG_LOS_LTHRESH |\r\nPLL_RX_CFG_EQ_LP_ADAPTIVE);\r\nif (lp->loopback_mode == LOOPBACK_PHY) {\r\nu16 test_cfg = PLL_TEST_CFG_LOOPBACK_CML_DIS;\r\nmdio_write(np, np->port, NIU_ESR2_DEV_ADDR,\r\nESR2_TI_PLL_TEST_CFG_L, test_cfg);\r\ntx_cfg |= PLL_TX_CFG_ENTEST;\r\nrx_cfg |= PLL_RX_CFG_ENTEST;\r\n}\r\npll_cfg = (PLL_CFG_ENPLL | PLL_CFG_MPY_10X);\r\nerr = mdio_write(np, np->port, NIU_ESR2_DEV_ADDR,\r\nESR2_TI_PLL_CFG_L, pll_cfg & 0xffff);\r\nif (err) {\r\nnetdev_err(np->dev, "NIU Port %d %s() mdio write to ESR2_TI_PLL_CFG_L failed\n",\r\nnp->port, __func__);\r\nreturn err;\r\n}\r\npll_sts = PLL_CFG_ENPLL;\r\nerr = mdio_write(np, np->port, NIU_ESR2_DEV_ADDR,\r\nESR2_TI_PLL_STS_L, pll_sts & 0xffff);\r\nif (err) {\r\nnetdev_err(np->dev, "NIU Port %d %s() mdio write to ESR2_TI_PLL_STS_L failed\n",\r\nnp->port, __func__);\r\nreturn err;\r\n}\r\nudelay(200);\r\nfor (i = 0; i < 4; i++) {\r\nerr = esr2_set_tx_cfg(np, i, tx_cfg);\r\nif (err)\r\nreturn err;\r\n}\r\nfor (i = 0; i < 4; i++) {\r\nerr = esr2_set_rx_cfg(np, i, rx_cfg);\r\nif (err)\r\nreturn err;\r\n}\r\nswitch (np->port) {\r\ncase 0:\r\nmask = ESR_INT_SIGNALS_P0_BITS;\r\nval = (ESR_INT_SRDY0_P0 |\r\nESR_INT_DET0_P0 |\r\nESR_INT_XSRDY_P0 |\r\nESR_INT_XDP_P0_CH3 |\r\nESR_INT_XDP_P0_CH2 |\r\nESR_INT_XDP_P0_CH1 |\r\nESR_INT_XDP_P0_CH0);\r\nbreak;\r\ncase 1:\r\nmask = ESR_INT_SIGNALS_P1_BITS;\r\nval = (ESR_INT_SRDY0_P1 |\r\nESR_INT_DET0_P1 |\r\nESR_INT_XSRDY_P1 |\r\nESR_INT_XDP_P1_CH3 |\r\nESR_INT_XDP_P1_CH2 |\r\nESR_INT_XDP_P1_CH1 |\r\nESR_INT_XDP_P1_CH0);\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nwhile (max_retry--) {\r\nsig = nr64(ESR_INT_SIGNALS);\r\nif ((sig & mask) == val)\r\nbreak;\r\nmdelay(500);\r\n}\r\nif ((sig & mask) != val) {\r\npr_info("NIU Port %u signal bits [%08x] are not [%08x] for 10G...trying 1G\n",\r\nnp->port, (int)(sig & mask), (int)val);\r\nerr = serdes_init_niu_1g_serdes(np);\r\nif (!err) {\r\nnp->flags &= ~NIU_FLAGS_10G;\r\nnp->mac_xcvr = MAC_XCVR_PCS;\r\n} else {\r\nnetdev_err(np->dev, "Port %u 10G/1G SERDES Link Failed\n",\r\nnp->port);\r\nreturn -ENODEV;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int esr_read_rxtx_ctrl(struct niu *np, unsigned long chan, u32 *val)\r\n{\r\nint err;\r\nerr = mdio_read(np, np->port, NIU_ESR_DEV_ADDR, ESR_RXTX_CTRL_L(chan));\r\nif (err >= 0) {\r\n*val = (err & 0xffff);\r\nerr = mdio_read(np, np->port, NIU_ESR_DEV_ADDR,\r\nESR_RXTX_CTRL_H(chan));\r\nif (err >= 0)\r\n*val |= ((err & 0xffff) << 16);\r\nerr = 0;\r\n}\r\nreturn err;\r\n}\r\nstatic int esr_read_glue0(struct niu *np, unsigned long chan, u32 *val)\r\n{\r\nint err;\r\nerr = mdio_read(np, np->port, NIU_ESR_DEV_ADDR,\r\nESR_GLUE_CTRL0_L(chan));\r\nif (err >= 0) {\r\n*val = (err & 0xffff);\r\nerr = mdio_read(np, np->port, NIU_ESR_DEV_ADDR,\r\nESR_GLUE_CTRL0_H(chan));\r\nif (err >= 0) {\r\n*val |= ((err & 0xffff) << 16);\r\nerr = 0;\r\n}\r\n}\r\nreturn err;\r\n}\r\nstatic int esr_read_reset(struct niu *np, u32 *val)\r\n{\r\nint err;\r\nerr = mdio_read(np, np->port, NIU_ESR_DEV_ADDR,\r\nESR_RXTX_RESET_CTRL_L);\r\nif (err >= 0) {\r\n*val = (err & 0xffff);\r\nerr = mdio_read(np, np->port, NIU_ESR_DEV_ADDR,\r\nESR_RXTX_RESET_CTRL_H);\r\nif (err >= 0) {\r\n*val |= ((err & 0xffff) << 16);\r\nerr = 0;\r\n}\r\n}\r\nreturn err;\r\n}\r\nstatic int esr_write_rxtx_ctrl(struct niu *np, unsigned long chan, u32 val)\r\n{\r\nint err;\r\nerr = mdio_write(np, np->port, NIU_ESR_DEV_ADDR,\r\nESR_RXTX_CTRL_L(chan), val & 0xffff);\r\nif (!err)\r\nerr = mdio_write(np, np->port, NIU_ESR_DEV_ADDR,\r\nESR_RXTX_CTRL_H(chan), (val >> 16));\r\nreturn err;\r\n}\r\nstatic int esr_write_glue0(struct niu *np, unsigned long chan, u32 val)\r\n{\r\nint err;\r\nerr = mdio_write(np, np->port, NIU_ESR_DEV_ADDR,\r\nESR_GLUE_CTRL0_L(chan), val & 0xffff);\r\nif (!err)\r\nerr = mdio_write(np, np->port, NIU_ESR_DEV_ADDR,\r\nESR_GLUE_CTRL0_H(chan), (val >> 16));\r\nreturn err;\r\n}\r\nstatic int esr_reset(struct niu *np)\r\n{\r\nu32 uninitialized_var(reset);\r\nint err;\r\nerr = mdio_write(np, np->port, NIU_ESR_DEV_ADDR,\r\nESR_RXTX_RESET_CTRL_L, 0x0000);\r\nif (err)\r\nreturn err;\r\nerr = mdio_write(np, np->port, NIU_ESR_DEV_ADDR,\r\nESR_RXTX_RESET_CTRL_H, 0xffff);\r\nif (err)\r\nreturn err;\r\nudelay(200);\r\nerr = mdio_write(np, np->port, NIU_ESR_DEV_ADDR,\r\nESR_RXTX_RESET_CTRL_L, 0xffff);\r\nif (err)\r\nreturn err;\r\nudelay(200);\r\nerr = mdio_write(np, np->port, NIU_ESR_DEV_ADDR,\r\nESR_RXTX_RESET_CTRL_H, 0x0000);\r\nif (err)\r\nreturn err;\r\nudelay(200);\r\nerr = esr_read_reset(np, &reset);\r\nif (err)\r\nreturn err;\r\nif (reset != 0) {\r\nnetdev_err(np->dev, "Port %u ESR_RESET did not clear [%08x]\n",\r\nnp->port, reset);\r\nreturn -ENODEV;\r\n}\r\nreturn 0;\r\n}\r\nstatic int serdes_init_10g(struct niu *np)\r\n{\r\nstruct niu_link_config *lp = &np->link_config;\r\nunsigned long ctrl_reg, test_cfg_reg, i;\r\nu64 ctrl_val, test_cfg_val, sig, mask, val;\r\nint err;\r\nswitch (np->port) {\r\ncase 0:\r\nctrl_reg = ENET_SERDES_0_CTRL_CFG;\r\ntest_cfg_reg = ENET_SERDES_0_TEST_CFG;\r\nbreak;\r\ncase 1:\r\nctrl_reg = ENET_SERDES_1_CTRL_CFG;\r\ntest_cfg_reg = ENET_SERDES_1_TEST_CFG;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nctrl_val = (ENET_SERDES_CTRL_SDET_0 |\r\nENET_SERDES_CTRL_SDET_1 |\r\nENET_SERDES_CTRL_SDET_2 |\r\nENET_SERDES_CTRL_SDET_3 |\r\n(0x5 << ENET_SERDES_CTRL_EMPH_0_SHIFT) |\r\n(0x5 << ENET_SERDES_CTRL_EMPH_1_SHIFT) |\r\n(0x5 << ENET_SERDES_CTRL_EMPH_2_SHIFT) |\r\n(0x5 << ENET_SERDES_CTRL_EMPH_3_SHIFT) |\r\n(0x1 << ENET_SERDES_CTRL_LADJ_0_SHIFT) |\r\n(0x1 << ENET_SERDES_CTRL_LADJ_1_SHIFT) |\r\n(0x1 << ENET_SERDES_CTRL_LADJ_2_SHIFT) |\r\n(0x1 << ENET_SERDES_CTRL_LADJ_3_SHIFT));\r\ntest_cfg_val = 0;\r\nif (lp->loopback_mode == LOOPBACK_PHY) {\r\ntest_cfg_val |= ((ENET_TEST_MD_PAD_LOOPBACK <<\r\nENET_SERDES_TEST_MD_0_SHIFT) |\r\n(ENET_TEST_MD_PAD_LOOPBACK <<\r\nENET_SERDES_TEST_MD_1_SHIFT) |\r\n(ENET_TEST_MD_PAD_LOOPBACK <<\r\nENET_SERDES_TEST_MD_2_SHIFT) |\r\n(ENET_TEST_MD_PAD_LOOPBACK <<\r\nENET_SERDES_TEST_MD_3_SHIFT));\r\n}\r\nnw64(ctrl_reg, ctrl_val);\r\nnw64(test_cfg_reg, test_cfg_val);\r\nfor (i = 0; i < 4; i++) {\r\nu32 rxtx_ctrl, glue0;\r\nerr = esr_read_rxtx_ctrl(np, i, &rxtx_ctrl);\r\nif (err)\r\nreturn err;\r\nerr = esr_read_glue0(np, i, &glue0);\r\nif (err)\r\nreturn err;\r\nrxtx_ctrl &= ~(ESR_RXTX_CTRL_VMUXLO);\r\nrxtx_ctrl |= (ESR_RXTX_CTRL_ENSTRETCH |\r\n(2 << ESR_RXTX_CTRL_VMUXLO_SHIFT));\r\nglue0 &= ~(ESR_GLUE_CTRL0_SRATE |\r\nESR_GLUE_CTRL0_THCNT |\r\nESR_GLUE_CTRL0_BLTIME);\r\nglue0 |= (ESR_GLUE_CTRL0_RXLOSENAB |\r\n(0xf << ESR_GLUE_CTRL0_SRATE_SHIFT) |\r\n(0xff << ESR_GLUE_CTRL0_THCNT_SHIFT) |\r\n(BLTIME_300_CYCLES <<\r\nESR_GLUE_CTRL0_BLTIME_SHIFT));\r\nerr = esr_write_rxtx_ctrl(np, i, rxtx_ctrl);\r\nif (err)\r\nreturn err;\r\nerr = esr_write_glue0(np, i, glue0);\r\nif (err)\r\nreturn err;\r\n}\r\nerr = esr_reset(np);\r\nif (err)\r\nreturn err;\r\nsig = nr64(ESR_INT_SIGNALS);\r\nswitch (np->port) {\r\ncase 0:\r\nmask = ESR_INT_SIGNALS_P0_BITS;\r\nval = (ESR_INT_SRDY0_P0 |\r\nESR_INT_DET0_P0 |\r\nESR_INT_XSRDY_P0 |\r\nESR_INT_XDP_P0_CH3 |\r\nESR_INT_XDP_P0_CH2 |\r\nESR_INT_XDP_P0_CH1 |\r\nESR_INT_XDP_P0_CH0);\r\nbreak;\r\ncase 1:\r\nmask = ESR_INT_SIGNALS_P1_BITS;\r\nval = (ESR_INT_SRDY0_P1 |\r\nESR_INT_DET0_P1 |\r\nESR_INT_XSRDY_P1 |\r\nESR_INT_XDP_P1_CH3 |\r\nESR_INT_XDP_P1_CH2 |\r\nESR_INT_XDP_P1_CH1 |\r\nESR_INT_XDP_P1_CH0);\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nif ((sig & mask) != val) {\r\nif (np->flags & NIU_FLAGS_HOTPLUG_PHY) {\r\nnp->flags &= ~NIU_FLAGS_HOTPLUG_PHY_PRESENT;\r\nreturn 0;\r\n}\r\nnetdev_err(np->dev, "Port %u signal bits [%08x] are not [%08x]\n",\r\nnp->port, (int)(sig & mask), (int)val);\r\nreturn -ENODEV;\r\n}\r\nif (np->flags & NIU_FLAGS_HOTPLUG_PHY)\r\nnp->flags |= NIU_FLAGS_HOTPLUG_PHY_PRESENT;\r\nreturn 0;\r\n}\r\nstatic int serdes_init_1g(struct niu *np)\r\n{\r\nu64 val;\r\nval = nr64(ENET_SERDES_1_PLL_CFG);\r\nval &= ~ENET_SERDES_PLL_FBDIV2;\r\nswitch (np->port) {\r\ncase 0:\r\nval |= ENET_SERDES_PLL_HRATE0;\r\nbreak;\r\ncase 1:\r\nval |= ENET_SERDES_PLL_HRATE1;\r\nbreak;\r\ncase 2:\r\nval |= ENET_SERDES_PLL_HRATE2;\r\nbreak;\r\ncase 3:\r\nval |= ENET_SERDES_PLL_HRATE3;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nnw64(ENET_SERDES_1_PLL_CFG, val);\r\nreturn 0;\r\n}\r\nstatic int serdes_init_1g_serdes(struct niu *np)\r\n{\r\nstruct niu_link_config *lp = &np->link_config;\r\nunsigned long ctrl_reg, test_cfg_reg, pll_cfg, i;\r\nu64 ctrl_val, test_cfg_val, sig, mask, val;\r\nint err;\r\nu64 reset_val, val_rd;\r\nval = ENET_SERDES_PLL_HRATE0 | ENET_SERDES_PLL_HRATE1 |\r\nENET_SERDES_PLL_HRATE2 | ENET_SERDES_PLL_HRATE3 |\r\nENET_SERDES_PLL_FBDIV0;\r\nswitch (np->port) {\r\ncase 0:\r\nreset_val = ENET_SERDES_RESET_0;\r\nctrl_reg = ENET_SERDES_0_CTRL_CFG;\r\ntest_cfg_reg = ENET_SERDES_0_TEST_CFG;\r\npll_cfg = ENET_SERDES_0_PLL_CFG;\r\nbreak;\r\ncase 1:\r\nreset_val = ENET_SERDES_RESET_1;\r\nctrl_reg = ENET_SERDES_1_CTRL_CFG;\r\ntest_cfg_reg = ENET_SERDES_1_TEST_CFG;\r\npll_cfg = ENET_SERDES_1_PLL_CFG;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nctrl_val = (ENET_SERDES_CTRL_SDET_0 |\r\nENET_SERDES_CTRL_SDET_1 |\r\nENET_SERDES_CTRL_SDET_2 |\r\nENET_SERDES_CTRL_SDET_3 |\r\n(0x5 << ENET_SERDES_CTRL_EMPH_0_SHIFT) |\r\n(0x5 << ENET_SERDES_CTRL_EMPH_1_SHIFT) |\r\n(0x5 << ENET_SERDES_CTRL_EMPH_2_SHIFT) |\r\n(0x5 << ENET_SERDES_CTRL_EMPH_3_SHIFT) |\r\n(0x1 << ENET_SERDES_CTRL_LADJ_0_SHIFT) |\r\n(0x1 << ENET_SERDES_CTRL_LADJ_1_SHIFT) |\r\n(0x1 << ENET_SERDES_CTRL_LADJ_2_SHIFT) |\r\n(0x1 << ENET_SERDES_CTRL_LADJ_3_SHIFT));\r\ntest_cfg_val = 0;\r\nif (lp->loopback_mode == LOOPBACK_PHY) {\r\ntest_cfg_val |= ((ENET_TEST_MD_PAD_LOOPBACK <<\r\nENET_SERDES_TEST_MD_0_SHIFT) |\r\n(ENET_TEST_MD_PAD_LOOPBACK <<\r\nENET_SERDES_TEST_MD_1_SHIFT) |\r\n(ENET_TEST_MD_PAD_LOOPBACK <<\r\nENET_SERDES_TEST_MD_2_SHIFT) |\r\n(ENET_TEST_MD_PAD_LOOPBACK <<\r\nENET_SERDES_TEST_MD_3_SHIFT));\r\n}\r\nnw64(ENET_SERDES_RESET, reset_val);\r\nmdelay(20);\r\nval_rd = nr64(ENET_SERDES_RESET);\r\nval_rd &= ~reset_val;\r\nnw64(pll_cfg, val);\r\nnw64(ctrl_reg, ctrl_val);\r\nnw64(test_cfg_reg, test_cfg_val);\r\nnw64(ENET_SERDES_RESET, val_rd);\r\nmdelay(2000);\r\nfor (i = 0; i < 4; i++) {\r\nu32 rxtx_ctrl, glue0;\r\nerr = esr_read_rxtx_ctrl(np, i, &rxtx_ctrl);\r\nif (err)\r\nreturn err;\r\nerr = esr_read_glue0(np, i, &glue0);\r\nif (err)\r\nreturn err;\r\nrxtx_ctrl &= ~(ESR_RXTX_CTRL_VMUXLO);\r\nrxtx_ctrl |= (ESR_RXTX_CTRL_ENSTRETCH |\r\n(2 << ESR_RXTX_CTRL_VMUXLO_SHIFT));\r\nglue0 &= ~(ESR_GLUE_CTRL0_SRATE |\r\nESR_GLUE_CTRL0_THCNT |\r\nESR_GLUE_CTRL0_BLTIME);\r\nglue0 |= (ESR_GLUE_CTRL0_RXLOSENAB |\r\n(0xf << ESR_GLUE_CTRL0_SRATE_SHIFT) |\r\n(0xff << ESR_GLUE_CTRL0_THCNT_SHIFT) |\r\n(BLTIME_300_CYCLES <<\r\nESR_GLUE_CTRL0_BLTIME_SHIFT));\r\nerr = esr_write_rxtx_ctrl(np, i, rxtx_ctrl);\r\nif (err)\r\nreturn err;\r\nerr = esr_write_glue0(np, i, glue0);\r\nif (err)\r\nreturn err;\r\n}\r\nsig = nr64(ESR_INT_SIGNALS);\r\nswitch (np->port) {\r\ncase 0:\r\nval = (ESR_INT_SRDY0_P0 | ESR_INT_DET0_P0);\r\nmask = val;\r\nbreak;\r\ncase 1:\r\nval = (ESR_INT_SRDY0_P1 | ESR_INT_DET0_P1);\r\nmask = val;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nif ((sig & mask) != val) {\r\nnetdev_err(np->dev, "Port %u signal bits [%08x] are not [%08x]\n",\r\nnp->port, (int)(sig & mask), (int)val);\r\nreturn -ENODEV;\r\n}\r\nreturn 0;\r\n}\r\nstatic int link_status_1g_serdes(struct niu *np, int *link_up_p)\r\n{\r\nstruct niu_link_config *lp = &np->link_config;\r\nint link_up;\r\nu64 val;\r\nu16 current_speed;\r\nunsigned long flags;\r\nu8 current_duplex;\r\nlink_up = 0;\r\ncurrent_speed = SPEED_INVALID;\r\ncurrent_duplex = DUPLEX_INVALID;\r\nspin_lock_irqsave(&np->lock, flags);\r\nval = nr64_pcs(PCS_MII_STAT);\r\nif (val & PCS_MII_STAT_LINK_STATUS) {\r\nlink_up = 1;\r\ncurrent_speed = SPEED_1000;\r\ncurrent_duplex = DUPLEX_FULL;\r\n}\r\nlp->active_speed = current_speed;\r\nlp->active_duplex = current_duplex;\r\nspin_unlock_irqrestore(&np->lock, flags);\r\n*link_up_p = link_up;\r\nreturn 0;\r\n}\r\nstatic int link_status_10g_serdes(struct niu *np, int *link_up_p)\r\n{\r\nunsigned long flags;\r\nstruct niu_link_config *lp = &np->link_config;\r\nint link_up = 0;\r\nint link_ok = 1;\r\nu64 val, val2;\r\nu16 current_speed;\r\nu8 current_duplex;\r\nif (!(np->flags & NIU_FLAGS_10G))\r\nreturn link_status_1g_serdes(np, link_up_p);\r\ncurrent_speed = SPEED_INVALID;\r\ncurrent_duplex = DUPLEX_INVALID;\r\nspin_lock_irqsave(&np->lock, flags);\r\nval = nr64_xpcs(XPCS_STATUS(0));\r\nval2 = nr64_mac(XMAC_INTER2);\r\nif (val2 & 0x01000000)\r\nlink_ok = 0;\r\nif ((val & 0x1000ULL) && link_ok) {\r\nlink_up = 1;\r\ncurrent_speed = SPEED_10000;\r\ncurrent_duplex = DUPLEX_FULL;\r\n}\r\nlp->active_speed = current_speed;\r\nlp->active_duplex = current_duplex;\r\nspin_unlock_irqrestore(&np->lock, flags);\r\n*link_up_p = link_up;\r\nreturn 0;\r\n}\r\nstatic int link_status_mii(struct niu *np, int *link_up_p)\r\n{\r\nstruct niu_link_config *lp = &np->link_config;\r\nint err;\r\nint bmsr, advert, ctrl1000, stat1000, lpa, bmcr, estatus;\r\nint supported, advertising, active_speed, active_duplex;\r\nerr = mii_read(np, np->phy_addr, MII_BMCR);\r\nif (unlikely(err < 0))\r\nreturn err;\r\nbmcr = err;\r\nerr = mii_read(np, np->phy_addr, MII_BMSR);\r\nif (unlikely(err < 0))\r\nreturn err;\r\nbmsr = err;\r\nerr = mii_read(np, np->phy_addr, MII_ADVERTISE);\r\nif (unlikely(err < 0))\r\nreturn err;\r\nadvert = err;\r\nerr = mii_read(np, np->phy_addr, MII_LPA);\r\nif (unlikely(err < 0))\r\nreturn err;\r\nlpa = err;\r\nif (likely(bmsr & BMSR_ESTATEN)) {\r\nerr = mii_read(np, np->phy_addr, MII_ESTATUS);\r\nif (unlikely(err < 0))\r\nreturn err;\r\nestatus = err;\r\nerr = mii_read(np, np->phy_addr, MII_CTRL1000);\r\nif (unlikely(err < 0))\r\nreturn err;\r\nctrl1000 = err;\r\nerr = mii_read(np, np->phy_addr, MII_STAT1000);\r\nif (unlikely(err < 0))\r\nreturn err;\r\nstat1000 = err;\r\n} else\r\nestatus = ctrl1000 = stat1000 = 0;\r\nsupported = 0;\r\nif (bmsr & BMSR_ANEGCAPABLE)\r\nsupported |= SUPPORTED_Autoneg;\r\nif (bmsr & BMSR_10HALF)\r\nsupported |= SUPPORTED_10baseT_Half;\r\nif (bmsr & BMSR_10FULL)\r\nsupported |= SUPPORTED_10baseT_Full;\r\nif (bmsr & BMSR_100HALF)\r\nsupported |= SUPPORTED_100baseT_Half;\r\nif (bmsr & BMSR_100FULL)\r\nsupported |= SUPPORTED_100baseT_Full;\r\nif (estatus & ESTATUS_1000_THALF)\r\nsupported |= SUPPORTED_1000baseT_Half;\r\nif (estatus & ESTATUS_1000_TFULL)\r\nsupported |= SUPPORTED_1000baseT_Full;\r\nlp->supported = supported;\r\nadvertising = mii_adv_to_ethtool_adv_t(advert);\r\nadvertising |= mii_ctrl1000_to_ethtool_adv_t(ctrl1000);\r\nif (bmcr & BMCR_ANENABLE) {\r\nint neg, neg1000;\r\nlp->active_autoneg = 1;\r\nadvertising |= ADVERTISED_Autoneg;\r\nneg = advert & lpa;\r\nneg1000 = (ctrl1000 << 2) & stat1000;\r\nif (neg1000 & (LPA_1000FULL | LPA_1000HALF))\r\nactive_speed = SPEED_1000;\r\nelse if (neg & LPA_100)\r\nactive_speed = SPEED_100;\r\nelse if (neg & (LPA_10HALF | LPA_10FULL))\r\nactive_speed = SPEED_10;\r\nelse\r\nactive_speed = SPEED_INVALID;\r\nif ((neg1000 & LPA_1000FULL) || (neg & LPA_DUPLEX))\r\nactive_duplex = DUPLEX_FULL;\r\nelse if (active_speed != SPEED_INVALID)\r\nactive_duplex = DUPLEX_HALF;\r\nelse\r\nactive_duplex = DUPLEX_INVALID;\r\n} else {\r\nlp->active_autoneg = 0;\r\nif ((bmcr & BMCR_SPEED1000) && !(bmcr & BMCR_SPEED100))\r\nactive_speed = SPEED_1000;\r\nelse if (bmcr & BMCR_SPEED100)\r\nactive_speed = SPEED_100;\r\nelse\r\nactive_speed = SPEED_10;\r\nif (bmcr & BMCR_FULLDPLX)\r\nactive_duplex = DUPLEX_FULL;\r\nelse\r\nactive_duplex = DUPLEX_HALF;\r\n}\r\nlp->active_advertising = advertising;\r\nlp->active_speed = active_speed;\r\nlp->active_duplex = active_duplex;\r\n*link_up_p = !!(bmsr & BMSR_LSTATUS);\r\nreturn 0;\r\n}\r\nstatic int link_status_1g_rgmii(struct niu *np, int *link_up_p)\r\n{\r\nstruct niu_link_config *lp = &np->link_config;\r\nu16 current_speed, bmsr;\r\nunsigned long flags;\r\nu8 current_duplex;\r\nint err, link_up;\r\nlink_up = 0;\r\ncurrent_speed = SPEED_INVALID;\r\ncurrent_duplex = DUPLEX_INVALID;\r\nspin_lock_irqsave(&np->lock, flags);\r\nerr = -EINVAL;\r\nerr = mii_read(np, np->phy_addr, MII_BMSR);\r\nif (err < 0)\r\ngoto out;\r\nbmsr = err;\r\nif (bmsr & BMSR_LSTATUS) {\r\nu16 adv, lpa;\r\nerr = mii_read(np, np->phy_addr, MII_ADVERTISE);\r\nif (err < 0)\r\ngoto out;\r\nadv = err;\r\nerr = mii_read(np, np->phy_addr, MII_LPA);\r\nif (err < 0)\r\ngoto out;\r\nlpa = err;\r\nerr = mii_read(np, np->phy_addr, MII_ESTATUS);\r\nif (err < 0)\r\ngoto out;\r\nlink_up = 1;\r\ncurrent_speed = SPEED_1000;\r\ncurrent_duplex = DUPLEX_FULL;\r\n}\r\nlp->active_speed = current_speed;\r\nlp->active_duplex = current_duplex;\r\nerr = 0;\r\nout:\r\nspin_unlock_irqrestore(&np->lock, flags);\r\n*link_up_p = link_up;\r\nreturn err;\r\n}\r\nstatic int link_status_1g(struct niu *np, int *link_up_p)\r\n{\r\nstruct niu_link_config *lp = &np->link_config;\r\nunsigned long flags;\r\nint err;\r\nspin_lock_irqsave(&np->lock, flags);\r\nerr = link_status_mii(np, link_up_p);\r\nlp->supported |= SUPPORTED_TP;\r\nlp->active_advertising |= ADVERTISED_TP;\r\nspin_unlock_irqrestore(&np->lock, flags);\r\nreturn err;\r\n}\r\nstatic int bcm8704_reset(struct niu *np)\r\n{\r\nint err, limit;\r\nerr = mdio_read(np, np->phy_addr,\r\nBCM8704_PHYXS_DEV_ADDR, MII_BMCR);\r\nif (err < 0 || err == 0xffff)\r\nreturn err;\r\nerr |= BMCR_RESET;\r\nerr = mdio_write(np, np->phy_addr, BCM8704_PHYXS_DEV_ADDR,\r\nMII_BMCR, err);\r\nif (err)\r\nreturn err;\r\nlimit = 1000;\r\nwhile (--limit >= 0) {\r\nerr = mdio_read(np, np->phy_addr,\r\nBCM8704_PHYXS_DEV_ADDR, MII_BMCR);\r\nif (err < 0)\r\nreturn err;\r\nif (!(err & BMCR_RESET))\r\nbreak;\r\n}\r\nif (limit < 0) {\r\nnetdev_err(np->dev, "Port %u PHY will not reset (bmcr=%04x)\n",\r\nnp->port, (err & 0xffff));\r\nreturn -ENODEV;\r\n}\r\nreturn 0;\r\n}\r\nstatic int bcm8704_user_dev3_readback(struct niu *np, int reg)\r\n{\r\nint err = mdio_read(np, np->phy_addr, BCM8704_USER_DEV3_ADDR, reg);\r\nif (err < 0)\r\nreturn err;\r\nerr = mdio_read(np, np->phy_addr, BCM8704_USER_DEV3_ADDR, reg);\r\nif (err < 0)\r\nreturn err;\r\nreturn 0;\r\n}\r\nstatic int bcm8706_init_user_dev3(struct niu *np)\r\n{\r\nint err;\r\nerr = mdio_read(np, np->phy_addr, BCM8704_USER_DEV3_ADDR,\r\nBCM8704_USER_OPT_DIGITAL_CTRL);\r\nif (err < 0)\r\nreturn err;\r\nerr &= ~USER_ODIG_CTRL_GPIOS;\r\nerr |= (0x3 << USER_ODIG_CTRL_GPIOS_SHIFT);\r\nerr |= USER_ODIG_CTRL_RESV2;\r\nerr = mdio_write(np, np->phy_addr, BCM8704_USER_DEV3_ADDR,\r\nBCM8704_USER_OPT_DIGITAL_CTRL, err);\r\nif (err)\r\nreturn err;\r\nmdelay(1000);\r\nreturn 0;\r\n}\r\nstatic int bcm8704_init_user_dev3(struct niu *np)\r\n{\r\nint err;\r\nerr = mdio_write(np, np->phy_addr,\r\nBCM8704_USER_DEV3_ADDR, BCM8704_USER_CONTROL,\r\n(USER_CONTROL_OPTXRST_LVL |\r\nUSER_CONTROL_OPBIASFLT_LVL |\r\nUSER_CONTROL_OBTMPFLT_LVL |\r\nUSER_CONTROL_OPPRFLT_LVL |\r\nUSER_CONTROL_OPTXFLT_LVL |\r\nUSER_CONTROL_OPRXLOS_LVL |\r\nUSER_CONTROL_OPRXFLT_LVL |\r\nUSER_CONTROL_OPTXON_LVL |\r\n(0x3f << USER_CONTROL_RES1_SHIFT)));\r\nif (err)\r\nreturn err;\r\nerr = mdio_write(np, np->phy_addr,\r\nBCM8704_USER_DEV3_ADDR, BCM8704_USER_PMD_TX_CONTROL,\r\n(USER_PMD_TX_CTL_XFP_CLKEN |\r\n(1 << USER_PMD_TX_CTL_TX_DAC_TXD_SH) |\r\n(2 << USER_PMD_TX_CTL_TX_DAC_TXCK_SH) |\r\nUSER_PMD_TX_CTL_TSCK_LPWREN));\r\nif (err)\r\nreturn err;\r\nerr = bcm8704_user_dev3_readback(np, BCM8704_USER_CONTROL);\r\nif (err)\r\nreturn err;\r\nerr = bcm8704_user_dev3_readback(np, BCM8704_USER_PMD_TX_CONTROL);\r\nif (err)\r\nreturn err;\r\nerr = mdio_read(np, np->phy_addr, BCM8704_USER_DEV3_ADDR,\r\nBCM8704_USER_OPT_DIGITAL_CTRL);\r\nif (err < 0)\r\nreturn err;\r\nerr &= ~USER_ODIG_CTRL_GPIOS;\r\nerr |= (0x3 << USER_ODIG_CTRL_GPIOS_SHIFT);\r\nerr = mdio_write(np, np->phy_addr, BCM8704_USER_DEV3_ADDR,\r\nBCM8704_USER_OPT_DIGITAL_CTRL, err);\r\nif (err)\r\nreturn err;\r\nmdelay(1000);\r\nreturn 0;\r\n}\r\nstatic int mrvl88x2011_act_led(struct niu *np, int val)\r\n{\r\nint err;\r\nerr = mdio_read(np, np->phy_addr, MRVL88X2011_USER_DEV2_ADDR,\r\nMRVL88X2011_LED_8_TO_11_CTL);\r\nif (err < 0)\r\nreturn err;\r\nerr &= ~MRVL88X2011_LED(MRVL88X2011_LED_ACT,MRVL88X2011_LED_CTL_MASK);\r\nerr |= MRVL88X2011_LED(MRVL88X2011_LED_ACT,val);\r\nreturn mdio_write(np, np->phy_addr, MRVL88X2011_USER_DEV2_ADDR,\r\nMRVL88X2011_LED_8_TO_11_CTL, err);\r\n}\r\nstatic int mrvl88x2011_led_blink_rate(struct niu *np, int rate)\r\n{\r\nint err;\r\nerr = mdio_read(np, np->phy_addr, MRVL88X2011_USER_DEV2_ADDR,\r\nMRVL88X2011_LED_BLINK_CTL);\r\nif (err >= 0) {\r\nerr &= ~MRVL88X2011_LED_BLKRATE_MASK;\r\nerr |= (rate << 4);\r\nerr = mdio_write(np, np->phy_addr, MRVL88X2011_USER_DEV2_ADDR,\r\nMRVL88X2011_LED_BLINK_CTL, err);\r\n}\r\nreturn err;\r\n}\r\nstatic int xcvr_init_10g_mrvl88x2011(struct niu *np)\r\n{\r\nint err;\r\nerr = mrvl88x2011_led_blink_rate(np, MRVL88X2011_LED_BLKRATE_134MS);\r\nif (err)\r\nreturn err;\r\nerr = mrvl88x2011_act_led(np, MRVL88X2011_LED_CTL_OFF);\r\nif (err)\r\nreturn err;\r\nerr = mdio_read(np, np->phy_addr, MRVL88X2011_USER_DEV3_ADDR,\r\nMRVL88X2011_GENERAL_CTL);\r\nif (err < 0)\r\nreturn err;\r\nerr |= MRVL88X2011_ENA_XFPREFCLK;\r\nerr = mdio_write(np, np->phy_addr, MRVL88X2011_USER_DEV3_ADDR,\r\nMRVL88X2011_GENERAL_CTL, err);\r\nif (err < 0)\r\nreturn err;\r\nerr = mdio_read(np, np->phy_addr, MRVL88X2011_USER_DEV1_ADDR,\r\nMRVL88X2011_PMA_PMD_CTL_1);\r\nif (err < 0)\r\nreturn err;\r\nif (np->link_config.loopback_mode == LOOPBACK_MAC)\r\nerr |= MRVL88X2011_LOOPBACK;\r\nelse\r\nerr &= ~MRVL88X2011_LOOPBACK;\r\nerr = mdio_write(np, np->phy_addr, MRVL88X2011_USER_DEV1_ADDR,\r\nMRVL88X2011_PMA_PMD_CTL_1, err);\r\nif (err < 0)\r\nreturn err;\r\nreturn mdio_write(np, np->phy_addr, MRVL88X2011_USER_DEV1_ADDR,\r\nMRVL88X2011_10G_PMD_TX_DIS, MRVL88X2011_ENA_PMDTX);\r\n}\r\nstatic int xcvr_diag_bcm870x(struct niu *np)\r\n{\r\nu16 analog_stat0, tx_alarm_status;\r\nint err = 0;\r\n#if 1\r\nerr = mdio_read(np, np->phy_addr, BCM8704_PMA_PMD_DEV_ADDR,\r\nMII_STAT1000);\r\nif (err < 0)\r\nreturn err;\r\npr_info("Port %u PMA_PMD(MII_STAT1000) [%04x]\n", np->port, err);\r\nerr = mdio_read(np, np->phy_addr, BCM8704_USER_DEV3_ADDR, 0x20);\r\nif (err < 0)\r\nreturn err;\r\npr_info("Port %u USER_DEV3(0x20) [%04x]\n", np->port, err);\r\nerr = mdio_read(np, np->phy_addr, BCM8704_PHYXS_DEV_ADDR,\r\nMII_NWAYTEST);\r\nif (err < 0)\r\nreturn err;\r\npr_info("Port %u PHYXS(MII_NWAYTEST) [%04x]\n", np->port, err);\r\n#endif\r\nerr = mdio_read(np, np->phy_addr, BCM8704_USER_DEV3_ADDR,\r\nBCM8704_USER_ANALOG_STATUS0);\r\nif (err < 0)\r\nreturn err;\r\nerr = mdio_read(np, np->phy_addr, BCM8704_USER_DEV3_ADDR,\r\nBCM8704_USER_ANALOG_STATUS0);\r\nif (err < 0)\r\nreturn err;\r\nanalog_stat0 = err;\r\nerr = mdio_read(np, np->phy_addr, BCM8704_USER_DEV3_ADDR,\r\nBCM8704_USER_TX_ALARM_STATUS);\r\nif (err < 0)\r\nreturn err;\r\nerr = mdio_read(np, np->phy_addr, BCM8704_USER_DEV3_ADDR,\r\nBCM8704_USER_TX_ALARM_STATUS);\r\nif (err < 0)\r\nreturn err;\r\ntx_alarm_status = err;\r\nif (analog_stat0 != 0x03fc) {\r\nif ((analog_stat0 == 0x43bc) && (tx_alarm_status != 0)) {\r\npr_info("Port %u cable not connected or bad cable\n",\r\nnp->port);\r\n} else if (analog_stat0 == 0x639c) {\r\npr_info("Port %u optical module is bad or missing\n",\r\nnp->port);\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int xcvr_10g_set_lb_bcm870x(struct niu *np)\r\n{\r\nstruct niu_link_config *lp = &np->link_config;\r\nint err;\r\nerr = mdio_read(np, np->phy_addr, BCM8704_PCS_DEV_ADDR,\r\nMII_BMCR);\r\nif (err < 0)\r\nreturn err;\r\nerr &= ~BMCR_LOOPBACK;\r\nif (lp->loopback_mode == LOOPBACK_MAC)\r\nerr |= BMCR_LOOPBACK;\r\nerr = mdio_write(np, np->phy_addr, BCM8704_PCS_DEV_ADDR,\r\nMII_BMCR, err);\r\nif (err)\r\nreturn err;\r\nreturn 0;\r\n}\r\nstatic int xcvr_init_10g_bcm8706(struct niu *np)\r\n{\r\nint err = 0;\r\nu64 val;\r\nif ((np->flags & NIU_FLAGS_HOTPLUG_PHY) &&\r\n(np->flags & NIU_FLAGS_HOTPLUG_PHY_PRESENT) == 0)\r\nreturn err;\r\nval = nr64_mac(XMAC_CONFIG);\r\nval &= ~XMAC_CONFIG_LED_POLARITY;\r\nval |= XMAC_CONFIG_FORCE_LED_ON;\r\nnw64_mac(XMAC_CONFIG, val);\r\nval = nr64(MIF_CONFIG);\r\nval |= MIF_CONFIG_INDIRECT_MODE;\r\nnw64(MIF_CONFIG, val);\r\nerr = bcm8704_reset(np);\r\nif (err)\r\nreturn err;\r\nerr = xcvr_10g_set_lb_bcm870x(np);\r\nif (err)\r\nreturn err;\r\nerr = bcm8706_init_user_dev3(np);\r\nif (err)\r\nreturn err;\r\nerr = xcvr_diag_bcm870x(np);\r\nif (err)\r\nreturn err;\r\nreturn 0;\r\n}\r\nstatic int xcvr_init_10g_bcm8704(struct niu *np)\r\n{\r\nint err;\r\nerr = bcm8704_reset(np);\r\nif (err)\r\nreturn err;\r\nerr = bcm8704_init_user_dev3(np);\r\nif (err)\r\nreturn err;\r\nerr = xcvr_10g_set_lb_bcm870x(np);\r\nif (err)\r\nreturn err;\r\nerr = xcvr_diag_bcm870x(np);\r\nif (err)\r\nreturn err;\r\nreturn 0;\r\n}\r\nstatic int xcvr_init_10g(struct niu *np)\r\n{\r\nint phy_id, err;\r\nu64 val;\r\nval = nr64_mac(XMAC_CONFIG);\r\nval &= ~XMAC_CONFIG_LED_POLARITY;\r\nval |= XMAC_CONFIG_FORCE_LED_ON;\r\nnw64_mac(XMAC_CONFIG, val);\r\nval = nr64(MIF_CONFIG);\r\nval |= MIF_CONFIG_INDIRECT_MODE;\r\nnw64(MIF_CONFIG, val);\r\nphy_id = phy_decode(np->parent->port_phy, np->port);\r\nphy_id = np->parent->phy_probe_info.phy_id[phy_id][np->port];\r\nswitch (phy_id & NIU_PHY_ID_MASK) {\r\ncase NIU_PHY_ID_MRVL88X2011:\r\nerr = xcvr_init_10g_mrvl88x2011(np);\r\nbreak;\r\ndefault:\r\nerr = xcvr_init_10g_bcm8704(np);\r\nbreak;\r\n}\r\nreturn err;\r\n}\r\nstatic int mii_reset(struct niu *np)\r\n{\r\nint limit, err;\r\nerr = mii_write(np, np->phy_addr, MII_BMCR, BMCR_RESET);\r\nif (err)\r\nreturn err;\r\nlimit = 1000;\r\nwhile (--limit >= 0) {\r\nudelay(500);\r\nerr = mii_read(np, np->phy_addr, MII_BMCR);\r\nif (err < 0)\r\nreturn err;\r\nif (!(err & BMCR_RESET))\r\nbreak;\r\n}\r\nif (limit < 0) {\r\nnetdev_err(np->dev, "Port %u MII would not reset, bmcr[%04x]\n",\r\nnp->port, err);\r\nreturn -ENODEV;\r\n}\r\nreturn 0;\r\n}\r\nstatic int xcvr_init_1g_rgmii(struct niu *np)\r\n{\r\nint err;\r\nu64 val;\r\nu16 bmcr, bmsr, estat;\r\nval = nr64(MIF_CONFIG);\r\nval &= ~MIF_CONFIG_INDIRECT_MODE;\r\nnw64(MIF_CONFIG, val);\r\nerr = mii_reset(np);\r\nif (err)\r\nreturn err;\r\nerr = mii_read(np, np->phy_addr, MII_BMSR);\r\nif (err < 0)\r\nreturn err;\r\nbmsr = err;\r\nestat = 0;\r\nif (bmsr & BMSR_ESTATEN) {\r\nerr = mii_read(np, np->phy_addr, MII_ESTATUS);\r\nif (err < 0)\r\nreturn err;\r\nestat = err;\r\n}\r\nbmcr = 0;\r\nerr = mii_write(np, np->phy_addr, MII_BMCR, bmcr);\r\nif (err)\r\nreturn err;\r\nif (bmsr & BMSR_ESTATEN) {\r\nu16 ctrl1000 = 0;\r\nif (estat & ESTATUS_1000_TFULL)\r\nctrl1000 |= ADVERTISE_1000FULL;\r\nerr = mii_write(np, np->phy_addr, MII_CTRL1000, ctrl1000);\r\nif (err)\r\nreturn err;\r\n}\r\nbmcr = (BMCR_SPEED1000 | BMCR_FULLDPLX);\r\nerr = mii_write(np, np->phy_addr, MII_BMCR, bmcr);\r\nif (err)\r\nreturn err;\r\nerr = mii_read(np, np->phy_addr, MII_BMCR);\r\nif (err < 0)\r\nreturn err;\r\nbmcr = mii_read(np, np->phy_addr, MII_BMCR);\r\nerr = mii_read(np, np->phy_addr, MII_BMSR);\r\nif (err < 0)\r\nreturn err;\r\nreturn 0;\r\n}\r\nstatic int mii_init_common(struct niu *np)\r\n{\r\nstruct niu_link_config *lp = &np->link_config;\r\nu16 bmcr, bmsr, adv, estat;\r\nint err;\r\nerr = mii_reset(np);\r\nif (err)\r\nreturn err;\r\nerr = mii_read(np, np->phy_addr, MII_BMSR);\r\nif (err < 0)\r\nreturn err;\r\nbmsr = err;\r\nestat = 0;\r\nif (bmsr & BMSR_ESTATEN) {\r\nerr = mii_read(np, np->phy_addr, MII_ESTATUS);\r\nif (err < 0)\r\nreturn err;\r\nestat = err;\r\n}\r\nbmcr = 0;\r\nerr = mii_write(np, np->phy_addr, MII_BMCR, bmcr);\r\nif (err)\r\nreturn err;\r\nif (lp->loopback_mode == LOOPBACK_MAC) {\r\nbmcr |= BMCR_LOOPBACK;\r\nif (lp->active_speed == SPEED_1000)\r\nbmcr |= BMCR_SPEED1000;\r\nif (lp->active_duplex == DUPLEX_FULL)\r\nbmcr |= BMCR_FULLDPLX;\r\n}\r\nif (lp->loopback_mode == LOOPBACK_PHY) {\r\nu16 aux;\r\naux = (BCM5464R_AUX_CTL_EXT_LB |\r\nBCM5464R_AUX_CTL_WRITE_1);\r\nerr = mii_write(np, np->phy_addr, BCM5464R_AUX_CTL, aux);\r\nif (err)\r\nreturn err;\r\n}\r\nif (lp->autoneg) {\r\nu16 ctrl1000;\r\nadv = ADVERTISE_CSMA | ADVERTISE_PAUSE_CAP;\r\nif ((bmsr & BMSR_10HALF) &&\r\n(lp->advertising & ADVERTISED_10baseT_Half))\r\nadv |= ADVERTISE_10HALF;\r\nif ((bmsr & BMSR_10FULL) &&\r\n(lp->advertising & ADVERTISED_10baseT_Full))\r\nadv |= ADVERTISE_10FULL;\r\nif ((bmsr & BMSR_100HALF) &&\r\n(lp->advertising & ADVERTISED_100baseT_Half))\r\nadv |= ADVERTISE_100HALF;\r\nif ((bmsr & BMSR_100FULL) &&\r\n(lp->advertising & ADVERTISED_100baseT_Full))\r\nadv |= ADVERTISE_100FULL;\r\nerr = mii_write(np, np->phy_addr, MII_ADVERTISE, adv);\r\nif (err)\r\nreturn err;\r\nif (likely(bmsr & BMSR_ESTATEN)) {\r\nctrl1000 = 0;\r\nif ((estat & ESTATUS_1000_THALF) &&\r\n(lp->advertising & ADVERTISED_1000baseT_Half))\r\nctrl1000 |= ADVERTISE_1000HALF;\r\nif ((estat & ESTATUS_1000_TFULL) &&\r\n(lp->advertising & ADVERTISED_1000baseT_Full))\r\nctrl1000 |= ADVERTISE_1000FULL;\r\nerr = mii_write(np, np->phy_addr,\r\nMII_CTRL1000, ctrl1000);\r\nif (err)\r\nreturn err;\r\n}\r\nbmcr |= (BMCR_ANENABLE | BMCR_ANRESTART);\r\n} else {\r\nint fulldpx;\r\nif (lp->duplex == DUPLEX_FULL) {\r\nbmcr |= BMCR_FULLDPLX;\r\nfulldpx = 1;\r\n} else if (lp->duplex == DUPLEX_HALF)\r\nfulldpx = 0;\r\nelse\r\nreturn -EINVAL;\r\nif (lp->speed == SPEED_1000) {\r\nif ((fulldpx && !(estat & ESTATUS_1000_TFULL)) ||\r\n(!fulldpx && !(estat & ESTATUS_1000_THALF)))\r\nreturn -EINVAL;\r\nbmcr |= BMCR_SPEED1000;\r\n} else if (lp->speed == SPEED_100) {\r\nif ((fulldpx && !(bmsr & BMSR_100FULL)) ||\r\n(!fulldpx && !(bmsr & BMSR_100HALF)))\r\nreturn -EINVAL;\r\nbmcr |= BMCR_SPEED100;\r\n} else if (lp->speed == SPEED_10) {\r\nif ((fulldpx && !(bmsr & BMSR_10FULL)) ||\r\n(!fulldpx && !(bmsr & BMSR_10HALF)))\r\nreturn -EINVAL;\r\n} else\r\nreturn -EINVAL;\r\n}\r\nerr = mii_write(np, np->phy_addr, MII_BMCR, bmcr);\r\nif (err)\r\nreturn err;\r\n#if 0\r\nerr = mii_read(np, np->phy_addr, MII_BMCR);\r\nif (err < 0)\r\nreturn err;\r\nbmcr = err;\r\nerr = mii_read(np, np->phy_addr, MII_BMSR);\r\nif (err < 0)\r\nreturn err;\r\nbmsr = err;\r\npr_info("Port %u after MII init bmcr[%04x] bmsr[%04x]\n",\r\nnp->port, bmcr, bmsr);\r\n#endif\r\nreturn 0;\r\n}\r\nstatic int xcvr_init_1g(struct niu *np)\r\n{\r\nu64 val;\r\nval = nr64(MIF_CONFIG);\r\nval &= ~MIF_CONFIG_INDIRECT_MODE;\r\nnw64(MIF_CONFIG, val);\r\nreturn mii_init_common(np);\r\n}\r\nstatic int niu_xcvr_init(struct niu *np)\r\n{\r\nconst struct niu_phy_ops *ops = np->phy_ops;\r\nint err;\r\nerr = 0;\r\nif (ops->xcvr_init)\r\nerr = ops->xcvr_init(np);\r\nreturn err;\r\n}\r\nstatic int niu_serdes_init(struct niu *np)\r\n{\r\nconst struct niu_phy_ops *ops = np->phy_ops;\r\nint err;\r\nerr = 0;\r\nif (ops->serdes_init)\r\nerr = ops->serdes_init(np);\r\nreturn err;\r\n}\r\nstatic int niu_link_status_common(struct niu *np, int link_up)\r\n{\r\nstruct niu_link_config *lp = &np->link_config;\r\nstruct net_device *dev = np->dev;\r\nunsigned long flags;\r\nif (!netif_carrier_ok(dev) && link_up) {\r\nnetif_info(np, link, dev, "Link is up at %s, %s duplex\n",\r\nlp->active_speed == SPEED_10000 ? "10Gb/sec" :\r\nlp->active_speed == SPEED_1000 ? "1Gb/sec" :\r\nlp->active_speed == SPEED_100 ? "100Mbit/sec" :\r\n"10Mbit/sec",\r\nlp->active_duplex == DUPLEX_FULL ? "full" : "half");\r\nspin_lock_irqsave(&np->lock, flags);\r\nniu_init_xif(np);\r\nniu_handle_led(np, 1);\r\nspin_unlock_irqrestore(&np->lock, flags);\r\nnetif_carrier_on(dev);\r\n} else if (netif_carrier_ok(dev) && !link_up) {\r\nnetif_warn(np, link, dev, "Link is down\n");\r\nspin_lock_irqsave(&np->lock, flags);\r\nniu_handle_led(np, 0);\r\nspin_unlock_irqrestore(&np->lock, flags);\r\nnetif_carrier_off(dev);\r\n}\r\nreturn 0;\r\n}\r\nstatic int link_status_10g_mrvl(struct niu *np, int *link_up_p)\r\n{\r\nint err, link_up, pma_status, pcs_status;\r\nlink_up = 0;\r\nerr = mdio_read(np, np->phy_addr, MRVL88X2011_USER_DEV1_ADDR,\r\nMRVL88X2011_10G_PMD_STATUS_2);\r\nif (err < 0)\r\ngoto out;\r\nerr = mdio_read(np, np->phy_addr, MRVL88X2011_USER_DEV1_ADDR,\r\nMRVL88X2011_PMA_PMD_STATUS_1);\r\nif (err < 0)\r\ngoto out;\r\npma_status = ((err & MRVL88X2011_LNK_STATUS_OK) ? 1 : 0);\r\nerr = mdio_read(np, np->phy_addr, MRVL88X2011_USER_DEV3_ADDR,\r\nMRVL88X2011_PMA_PMD_STATUS_1);\r\nif (err < 0)\r\ngoto out;\r\nerr = mdio_read(np, np->phy_addr, MRVL88X2011_USER_DEV3_ADDR,\r\nMRVL88X2011_PMA_PMD_STATUS_1);\r\nif (err < 0)\r\ngoto out;\r\npcs_status = ((err & MRVL88X2011_LNK_STATUS_OK) ? 1 : 0);\r\nerr = mdio_read(np, np->phy_addr, MRVL88X2011_USER_DEV4_ADDR,\r\nMRVL88X2011_10G_XGXS_LANE_STAT);\r\nif (err < 0)\r\ngoto out;\r\nif (err == (PHYXS_XGXS_LANE_STAT_ALINGED | PHYXS_XGXS_LANE_STAT_LANE3 |\r\nPHYXS_XGXS_LANE_STAT_LANE2 | PHYXS_XGXS_LANE_STAT_LANE1 |\r\nPHYXS_XGXS_LANE_STAT_LANE0 | PHYXS_XGXS_LANE_STAT_MAGIC |\r\n0x800))\r\nlink_up = (pma_status && pcs_status) ? 1 : 0;\r\nnp->link_config.active_speed = SPEED_10000;\r\nnp->link_config.active_duplex = DUPLEX_FULL;\r\nerr = 0;\r\nout:\r\nmrvl88x2011_act_led(np, (link_up ?\r\nMRVL88X2011_LED_CTL_PCS_ACT :\r\nMRVL88X2011_LED_CTL_OFF));\r\n*link_up_p = link_up;\r\nreturn err;\r\n}\r\nstatic int link_status_10g_bcm8706(struct niu *np, int *link_up_p)\r\n{\r\nint err, link_up;\r\nlink_up = 0;\r\nerr = mdio_read(np, np->phy_addr, BCM8704_PMA_PMD_DEV_ADDR,\r\nBCM8704_PMD_RCV_SIGDET);\r\nif (err < 0 || err == 0xffff)\r\ngoto out;\r\nif (!(err & PMD_RCV_SIGDET_GLOBAL)) {\r\nerr = 0;\r\ngoto out;\r\n}\r\nerr = mdio_read(np, np->phy_addr, BCM8704_PCS_DEV_ADDR,\r\nBCM8704_PCS_10G_R_STATUS);\r\nif (err < 0)\r\ngoto out;\r\nif (!(err & PCS_10G_R_STATUS_BLK_LOCK)) {\r\nerr = 0;\r\ngoto out;\r\n}\r\nerr = mdio_read(np, np->phy_addr, BCM8704_PHYXS_DEV_ADDR,\r\nBCM8704_PHYXS_XGXS_LANE_STAT);\r\nif (err < 0)\r\ngoto out;\r\nif (err != (PHYXS_XGXS_LANE_STAT_ALINGED |\r\nPHYXS_XGXS_LANE_STAT_MAGIC |\r\nPHYXS_XGXS_LANE_STAT_PATTEST |\r\nPHYXS_XGXS_LANE_STAT_LANE3 |\r\nPHYXS_XGXS_LANE_STAT_LANE2 |\r\nPHYXS_XGXS_LANE_STAT_LANE1 |\r\nPHYXS_XGXS_LANE_STAT_LANE0)) {\r\nerr = 0;\r\nnp->link_config.active_speed = SPEED_INVALID;\r\nnp->link_config.active_duplex = DUPLEX_INVALID;\r\ngoto out;\r\n}\r\nlink_up = 1;\r\nnp->link_config.active_speed = SPEED_10000;\r\nnp->link_config.active_duplex = DUPLEX_FULL;\r\nerr = 0;\r\nout:\r\n*link_up_p = link_up;\r\nreturn err;\r\n}\r\nstatic int link_status_10g_bcom(struct niu *np, int *link_up_p)\r\n{\r\nint err, link_up;\r\nlink_up = 0;\r\nerr = mdio_read(np, np->phy_addr, BCM8704_PMA_PMD_DEV_ADDR,\r\nBCM8704_PMD_RCV_SIGDET);\r\nif (err < 0)\r\ngoto out;\r\nif (!(err & PMD_RCV_SIGDET_GLOBAL)) {\r\nerr = 0;\r\ngoto out;\r\n}\r\nerr = mdio_read(np, np->phy_addr, BCM8704_PCS_DEV_ADDR,\r\nBCM8704_PCS_10G_R_STATUS);\r\nif (err < 0)\r\ngoto out;\r\nif (!(err & PCS_10G_R_STATUS_BLK_LOCK)) {\r\nerr = 0;\r\ngoto out;\r\n}\r\nerr = mdio_read(np, np->phy_addr, BCM8704_PHYXS_DEV_ADDR,\r\nBCM8704_PHYXS_XGXS_LANE_STAT);\r\nif (err < 0)\r\ngoto out;\r\nif (err != (PHYXS_XGXS_LANE_STAT_ALINGED |\r\nPHYXS_XGXS_LANE_STAT_MAGIC |\r\nPHYXS_XGXS_LANE_STAT_LANE3 |\r\nPHYXS_XGXS_LANE_STAT_LANE2 |\r\nPHYXS_XGXS_LANE_STAT_LANE1 |\r\nPHYXS_XGXS_LANE_STAT_LANE0)) {\r\nerr = 0;\r\ngoto out;\r\n}\r\nlink_up = 1;\r\nnp->link_config.active_speed = SPEED_10000;\r\nnp->link_config.active_duplex = DUPLEX_FULL;\r\nerr = 0;\r\nout:\r\n*link_up_p = link_up;\r\nreturn err;\r\n}\r\nstatic int link_status_10g(struct niu *np, int *link_up_p)\r\n{\r\nunsigned long flags;\r\nint err = -EINVAL;\r\nspin_lock_irqsave(&np->lock, flags);\r\nif (np->link_config.loopback_mode == LOOPBACK_DISABLED) {\r\nint phy_id;\r\nphy_id = phy_decode(np->parent->port_phy, np->port);\r\nphy_id = np->parent->phy_probe_info.phy_id[phy_id][np->port];\r\nswitch (phy_id & NIU_PHY_ID_MASK) {\r\ncase NIU_PHY_ID_MRVL88X2011:\r\nerr = link_status_10g_mrvl(np, link_up_p);\r\nbreak;\r\ndefault:\r\nerr = link_status_10g_bcom(np, link_up_p);\r\nbreak;\r\n}\r\n}\r\nspin_unlock_irqrestore(&np->lock, flags);\r\nreturn err;\r\n}\r\nstatic int niu_10g_phy_present(struct niu *np)\r\n{\r\nu64 sig, mask, val;\r\nsig = nr64(ESR_INT_SIGNALS);\r\nswitch (np->port) {\r\ncase 0:\r\nmask = ESR_INT_SIGNALS_P0_BITS;\r\nval = (ESR_INT_SRDY0_P0 |\r\nESR_INT_DET0_P0 |\r\nESR_INT_XSRDY_P0 |\r\nESR_INT_XDP_P0_CH3 |\r\nESR_INT_XDP_P0_CH2 |\r\nESR_INT_XDP_P0_CH1 |\r\nESR_INT_XDP_P0_CH0);\r\nbreak;\r\ncase 1:\r\nmask = ESR_INT_SIGNALS_P1_BITS;\r\nval = (ESR_INT_SRDY0_P1 |\r\nESR_INT_DET0_P1 |\r\nESR_INT_XSRDY_P1 |\r\nESR_INT_XDP_P1_CH3 |\r\nESR_INT_XDP_P1_CH2 |\r\nESR_INT_XDP_P1_CH1 |\r\nESR_INT_XDP_P1_CH0);\r\nbreak;\r\ndefault:\r\nreturn 0;\r\n}\r\nif ((sig & mask) != val)\r\nreturn 0;\r\nreturn 1;\r\n}\r\nstatic int link_status_10g_hotplug(struct niu *np, int *link_up_p)\r\n{\r\nunsigned long flags;\r\nint err = 0;\r\nint phy_present;\r\nint phy_present_prev;\r\nspin_lock_irqsave(&np->lock, flags);\r\nif (np->link_config.loopback_mode == LOOPBACK_DISABLED) {\r\nphy_present_prev = (np->flags & NIU_FLAGS_HOTPLUG_PHY_PRESENT) ?\r\n1 : 0;\r\nphy_present = niu_10g_phy_present(np);\r\nif (phy_present != phy_present_prev) {\r\nif (phy_present) {\r\nnp->flags |= NIU_FLAGS_HOTPLUG_PHY_PRESENT;\r\nif (np->phy_ops->xcvr_init)\r\nerr = np->phy_ops->xcvr_init(np);\r\nif (err) {\r\nerr = mdio_read(np, np->phy_addr,\r\nBCM8704_PHYXS_DEV_ADDR, MII_BMCR);\r\nif (err == 0xffff) {\r\ngoto out;\r\n}\r\nnp->flags &= ~NIU_FLAGS_HOTPLUG_PHY_PRESENT;\r\n}\r\n} else {\r\nnp->flags &= ~NIU_FLAGS_HOTPLUG_PHY_PRESENT;\r\n*link_up_p = 0;\r\nnetif_warn(np, link, np->dev,\r\n"Hotplug PHY Removed\n");\r\n}\r\n}\r\nout:\r\nif (np->flags & NIU_FLAGS_HOTPLUG_PHY_PRESENT) {\r\nerr = link_status_10g_bcm8706(np, link_up_p);\r\nif (err == 0xffff) {\r\n*link_up_p = 1;\r\nnp->link_config.active_speed = SPEED_10000;\r\nnp->link_config.active_duplex = DUPLEX_FULL;\r\n}\r\n}\r\n}\r\nspin_unlock_irqrestore(&np->lock, flags);\r\nreturn 0;\r\n}\r\nstatic int niu_link_status(struct niu *np, int *link_up_p)\r\n{\r\nconst struct niu_phy_ops *ops = np->phy_ops;\r\nint err;\r\nerr = 0;\r\nif (ops->link_status)\r\nerr = ops->link_status(np, link_up_p);\r\nreturn err;\r\n}\r\nstatic void niu_timer(unsigned long __opaque)\r\n{\r\nstruct niu *np = (struct niu *) __opaque;\r\nunsigned long off;\r\nint err, link_up;\r\nerr = niu_link_status(np, &link_up);\r\nif (!err)\r\nniu_link_status_common(np, link_up);\r\nif (netif_carrier_ok(np->dev))\r\noff = 5 * HZ;\r\nelse\r\noff = 1 * HZ;\r\nnp->timer.expires = jiffies + off;\r\nadd_timer(&np->timer);\r\n}\r\nstatic int serdes_init_10g_serdes(struct niu *np)\r\n{\r\nstruct niu_link_config *lp = &np->link_config;\r\nunsigned long ctrl_reg, test_cfg_reg, pll_cfg, i;\r\nu64 ctrl_val, test_cfg_val, sig, mask, val;\r\nswitch (np->port) {\r\ncase 0:\r\nctrl_reg = ENET_SERDES_0_CTRL_CFG;\r\ntest_cfg_reg = ENET_SERDES_0_TEST_CFG;\r\npll_cfg = ENET_SERDES_0_PLL_CFG;\r\nbreak;\r\ncase 1:\r\nctrl_reg = ENET_SERDES_1_CTRL_CFG;\r\ntest_cfg_reg = ENET_SERDES_1_TEST_CFG;\r\npll_cfg = ENET_SERDES_1_PLL_CFG;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nctrl_val = (ENET_SERDES_CTRL_SDET_0 |\r\nENET_SERDES_CTRL_SDET_1 |\r\nENET_SERDES_CTRL_SDET_2 |\r\nENET_SERDES_CTRL_SDET_3 |\r\n(0x5 << ENET_SERDES_CTRL_EMPH_0_SHIFT) |\r\n(0x5 << ENET_SERDES_CTRL_EMPH_1_SHIFT) |\r\n(0x5 << ENET_SERDES_CTRL_EMPH_2_SHIFT) |\r\n(0x5 << ENET_SERDES_CTRL_EMPH_3_SHIFT) |\r\n(0x1 << ENET_SERDES_CTRL_LADJ_0_SHIFT) |\r\n(0x1 << ENET_SERDES_CTRL_LADJ_1_SHIFT) |\r\n(0x1 << ENET_SERDES_CTRL_LADJ_2_SHIFT) |\r\n(0x1 << ENET_SERDES_CTRL_LADJ_3_SHIFT));\r\ntest_cfg_val = 0;\r\nif (lp->loopback_mode == LOOPBACK_PHY) {\r\ntest_cfg_val |= ((ENET_TEST_MD_PAD_LOOPBACK <<\r\nENET_SERDES_TEST_MD_0_SHIFT) |\r\n(ENET_TEST_MD_PAD_LOOPBACK <<\r\nENET_SERDES_TEST_MD_1_SHIFT) |\r\n(ENET_TEST_MD_PAD_LOOPBACK <<\r\nENET_SERDES_TEST_MD_2_SHIFT) |\r\n(ENET_TEST_MD_PAD_LOOPBACK <<\r\nENET_SERDES_TEST_MD_3_SHIFT));\r\n}\r\nesr_reset(np);\r\nnw64(pll_cfg, ENET_SERDES_PLL_FBDIV2);\r\nnw64(ctrl_reg, ctrl_val);\r\nnw64(test_cfg_reg, test_cfg_val);\r\nfor (i = 0; i < 4; i++) {\r\nu32 rxtx_ctrl, glue0;\r\nint err;\r\nerr = esr_read_rxtx_ctrl(np, i, &rxtx_ctrl);\r\nif (err)\r\nreturn err;\r\nerr = esr_read_glue0(np, i, &glue0);\r\nif (err)\r\nreturn err;\r\nrxtx_ctrl &= ~(ESR_RXTX_CTRL_VMUXLO);\r\nrxtx_ctrl |= (ESR_RXTX_CTRL_ENSTRETCH |\r\n(2 << ESR_RXTX_CTRL_VMUXLO_SHIFT));\r\nglue0 &= ~(ESR_GLUE_CTRL0_SRATE |\r\nESR_GLUE_CTRL0_THCNT |\r\nESR_GLUE_CTRL0_BLTIME);\r\nglue0 |= (ESR_GLUE_CTRL0_RXLOSENAB |\r\n(0xf << ESR_GLUE_CTRL0_SRATE_SHIFT) |\r\n(0xff << ESR_GLUE_CTRL0_THCNT_SHIFT) |\r\n(BLTIME_300_CYCLES <<\r\nESR_GLUE_CTRL0_BLTIME_SHIFT));\r\nerr = esr_write_rxtx_ctrl(np, i, rxtx_ctrl);\r\nif (err)\r\nreturn err;\r\nerr = esr_write_glue0(np, i, glue0);\r\nif (err)\r\nreturn err;\r\n}\r\nsig = nr64(ESR_INT_SIGNALS);\r\nswitch (np->port) {\r\ncase 0:\r\nmask = ESR_INT_SIGNALS_P0_BITS;\r\nval = (ESR_INT_SRDY0_P0 |\r\nESR_INT_DET0_P0 |\r\nESR_INT_XSRDY_P0 |\r\nESR_INT_XDP_P0_CH3 |\r\nESR_INT_XDP_P0_CH2 |\r\nESR_INT_XDP_P0_CH1 |\r\nESR_INT_XDP_P0_CH0);\r\nbreak;\r\ncase 1:\r\nmask = ESR_INT_SIGNALS_P1_BITS;\r\nval = (ESR_INT_SRDY0_P1 |\r\nESR_INT_DET0_P1 |\r\nESR_INT_XSRDY_P1 |\r\nESR_INT_XDP_P1_CH3 |\r\nESR_INT_XDP_P1_CH2 |\r\nESR_INT_XDP_P1_CH1 |\r\nESR_INT_XDP_P1_CH0);\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nif ((sig & mask) != val) {\r\nint err;\r\nerr = serdes_init_1g_serdes(np);\r\nif (!err) {\r\nnp->flags &= ~NIU_FLAGS_10G;\r\nnp->mac_xcvr = MAC_XCVR_PCS;\r\n} else {\r\nnetdev_err(np->dev, "Port %u 10G/1G SERDES Link Failed\n",\r\nnp->port);\r\nreturn -ENODEV;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int niu_determine_phy_disposition(struct niu *np)\r\n{\r\nstruct niu_parent *parent = np->parent;\r\nu8 plat_type = parent->plat_type;\r\nconst struct niu_phy_template *tp;\r\nu32 phy_addr_off = 0;\r\nif (plat_type == PLAT_TYPE_NIU) {\r\nswitch (np->flags &\r\n(NIU_FLAGS_10G |\r\nNIU_FLAGS_FIBER |\r\nNIU_FLAGS_XCVR_SERDES)) {\r\ncase NIU_FLAGS_10G | NIU_FLAGS_XCVR_SERDES:\r\ntp = &phy_template_niu_10g_serdes;\r\nbreak;\r\ncase NIU_FLAGS_XCVR_SERDES:\r\ntp = &phy_template_niu_1g_serdes;\r\nbreak;\r\ncase NIU_FLAGS_10G | NIU_FLAGS_FIBER:\r\ndefault:\r\nif (np->flags & NIU_FLAGS_HOTPLUG_PHY) {\r\ntp = &phy_template_niu_10g_hotplug;\r\nif (np->port == 0)\r\nphy_addr_off = 8;\r\nif (np->port == 1)\r\nphy_addr_off = 12;\r\n} else {\r\ntp = &phy_template_niu_10g_fiber;\r\nphy_addr_off += np->port;\r\n}\r\nbreak;\r\n}\r\n} else {\r\nswitch (np->flags &\r\n(NIU_FLAGS_10G |\r\nNIU_FLAGS_FIBER |\r\nNIU_FLAGS_XCVR_SERDES)) {\r\ncase 0:\r\ntp = &phy_template_1g_copper;\r\nif (plat_type == PLAT_TYPE_VF_P0)\r\nphy_addr_off = 10;\r\nelse if (plat_type == PLAT_TYPE_VF_P1)\r\nphy_addr_off = 26;\r\nphy_addr_off += (np->port ^ 0x3);\r\nbreak;\r\ncase NIU_FLAGS_10G:\r\ntp = &phy_template_10g_copper;\r\nbreak;\r\ncase NIU_FLAGS_FIBER:\r\ntp = &phy_template_1g_fiber;\r\nbreak;\r\ncase NIU_FLAGS_10G | NIU_FLAGS_FIBER:\r\ntp = &phy_template_10g_fiber;\r\nif (plat_type == PLAT_TYPE_VF_P0 ||\r\nplat_type == PLAT_TYPE_VF_P1)\r\nphy_addr_off = 8;\r\nphy_addr_off += np->port;\r\nif (np->flags & NIU_FLAGS_HOTPLUG_PHY) {\r\ntp = &phy_template_10g_fiber_hotplug;\r\nif (np->port == 0)\r\nphy_addr_off = 8;\r\nif (np->port == 1)\r\nphy_addr_off = 12;\r\n}\r\nbreak;\r\ncase NIU_FLAGS_10G | NIU_FLAGS_XCVR_SERDES:\r\ncase NIU_FLAGS_XCVR_SERDES | NIU_FLAGS_FIBER:\r\ncase NIU_FLAGS_XCVR_SERDES:\r\nswitch(np->port) {\r\ncase 0:\r\ncase 1:\r\ntp = &phy_template_10g_serdes;\r\nbreak;\r\ncase 2:\r\ncase 3:\r\ntp = &phy_template_1g_rgmii;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nphy_addr_off = niu_atca_port_num[np->port];\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\n}\r\nnp->phy_ops = tp->ops;\r\nnp->phy_addr = tp->phy_addr_base + phy_addr_off;\r\nreturn 0;\r\n}\r\nstatic int niu_init_link(struct niu *np)\r\n{\r\nstruct niu_parent *parent = np->parent;\r\nint err, ignore;\r\nif (parent->plat_type == PLAT_TYPE_NIU) {\r\nerr = niu_xcvr_init(np);\r\nif (err)\r\nreturn err;\r\nmsleep(200);\r\n}\r\nerr = niu_serdes_init(np);\r\nif (err && !(np->flags & NIU_FLAGS_HOTPLUG_PHY))\r\nreturn err;\r\nmsleep(200);\r\nerr = niu_xcvr_init(np);\r\nif (!err || (np->flags & NIU_FLAGS_HOTPLUG_PHY))\r\nniu_link_status(np, &ignore);\r\nreturn 0;\r\n}\r\nstatic void niu_set_primary_mac(struct niu *np, unsigned char *addr)\r\n{\r\nu16 reg0 = addr[4] << 8 | addr[5];\r\nu16 reg1 = addr[2] << 8 | addr[3];\r\nu16 reg2 = addr[0] << 8 | addr[1];\r\nif (np->flags & NIU_FLAGS_XMAC) {\r\nnw64_mac(XMAC_ADDR0, reg0);\r\nnw64_mac(XMAC_ADDR1, reg1);\r\nnw64_mac(XMAC_ADDR2, reg2);\r\n} else {\r\nnw64_mac(BMAC_ADDR0, reg0);\r\nnw64_mac(BMAC_ADDR1, reg1);\r\nnw64_mac(BMAC_ADDR2, reg2);\r\n}\r\n}\r\nstatic int niu_num_alt_addr(struct niu *np)\r\n{\r\nif (np->flags & NIU_FLAGS_XMAC)\r\nreturn XMAC_NUM_ALT_ADDR;\r\nelse\r\nreturn BMAC_NUM_ALT_ADDR;\r\n}\r\nstatic int niu_set_alt_mac(struct niu *np, int index, unsigned char *addr)\r\n{\r\nu16 reg0 = addr[4] << 8 | addr[5];\r\nu16 reg1 = addr[2] << 8 | addr[3];\r\nu16 reg2 = addr[0] << 8 | addr[1];\r\nif (index >= niu_num_alt_addr(np))\r\nreturn -EINVAL;\r\nif (np->flags & NIU_FLAGS_XMAC) {\r\nnw64_mac(XMAC_ALT_ADDR0(index), reg0);\r\nnw64_mac(XMAC_ALT_ADDR1(index), reg1);\r\nnw64_mac(XMAC_ALT_ADDR2(index), reg2);\r\n} else {\r\nnw64_mac(BMAC_ALT_ADDR0(index), reg0);\r\nnw64_mac(BMAC_ALT_ADDR1(index), reg1);\r\nnw64_mac(BMAC_ALT_ADDR2(index), reg2);\r\n}\r\nreturn 0;\r\n}\r\nstatic int niu_enable_alt_mac(struct niu *np, int index, int on)\r\n{\r\nunsigned long reg;\r\nu64 val, mask;\r\nif (index >= niu_num_alt_addr(np))\r\nreturn -EINVAL;\r\nif (np->flags & NIU_FLAGS_XMAC) {\r\nreg = XMAC_ADDR_CMPEN;\r\nmask = 1 << index;\r\n} else {\r\nreg = BMAC_ADDR_CMPEN;\r\nmask = 1 << (index + 1);\r\n}\r\nval = nr64_mac(reg);\r\nif (on)\r\nval |= mask;\r\nelse\r\nval &= ~mask;\r\nnw64_mac(reg, val);\r\nreturn 0;\r\n}\r\nstatic void __set_rdc_table_num_hw(struct niu *np, unsigned long reg,\r\nint num, int mac_pref)\r\n{\r\nu64 val = nr64_mac(reg);\r\nval &= ~(HOST_INFO_MACRDCTBLN | HOST_INFO_MPR);\r\nval |= num;\r\nif (mac_pref)\r\nval |= HOST_INFO_MPR;\r\nnw64_mac(reg, val);\r\n}\r\nstatic int __set_rdc_table_num(struct niu *np,\r\nint xmac_index, int bmac_index,\r\nint rdc_table_num, int mac_pref)\r\n{\r\nunsigned long reg;\r\nif (rdc_table_num & ~HOST_INFO_MACRDCTBLN)\r\nreturn -EINVAL;\r\nif (np->flags & NIU_FLAGS_XMAC)\r\nreg = XMAC_HOST_INFO(xmac_index);\r\nelse\r\nreg = BMAC_HOST_INFO(bmac_index);\r\n__set_rdc_table_num_hw(np, reg, rdc_table_num, mac_pref);\r\nreturn 0;\r\n}\r\nstatic int niu_set_primary_mac_rdc_table(struct niu *np, int table_num,\r\nint mac_pref)\r\n{\r\nreturn __set_rdc_table_num(np, 17, 0, table_num, mac_pref);\r\n}\r\nstatic int niu_set_multicast_mac_rdc_table(struct niu *np, int table_num,\r\nint mac_pref)\r\n{\r\nreturn __set_rdc_table_num(np, 16, 8, table_num, mac_pref);\r\n}\r\nstatic int niu_set_alt_mac_rdc_table(struct niu *np, int idx,\r\nint table_num, int mac_pref)\r\n{\r\nif (idx >= niu_num_alt_addr(np))\r\nreturn -EINVAL;\r\nreturn __set_rdc_table_num(np, idx, idx + 1, table_num, mac_pref);\r\n}\r\nstatic u64 vlan_entry_set_parity(u64 reg_val)\r\n{\r\nu64 port01_mask;\r\nu64 port23_mask;\r\nport01_mask = 0x00ff;\r\nport23_mask = 0xff00;\r\nif (hweight64(reg_val & port01_mask) & 1)\r\nreg_val |= ENET_VLAN_TBL_PARITY0;\r\nelse\r\nreg_val &= ~ENET_VLAN_TBL_PARITY0;\r\nif (hweight64(reg_val & port23_mask) & 1)\r\nreg_val |= ENET_VLAN_TBL_PARITY1;\r\nelse\r\nreg_val &= ~ENET_VLAN_TBL_PARITY1;\r\nreturn reg_val;\r\n}\r\nstatic void vlan_tbl_write(struct niu *np, unsigned long index,\r\nint port, int vpr, int rdc_table)\r\n{\r\nu64 reg_val = nr64(ENET_VLAN_TBL(index));\r\nreg_val &= ~((ENET_VLAN_TBL_VPR |\r\nENET_VLAN_TBL_VLANRDCTBLN) <<\r\nENET_VLAN_TBL_SHIFT(port));\r\nif (vpr)\r\nreg_val |= (ENET_VLAN_TBL_VPR <<\r\nENET_VLAN_TBL_SHIFT(port));\r\nreg_val |= (rdc_table << ENET_VLAN_TBL_SHIFT(port));\r\nreg_val = vlan_entry_set_parity(reg_val);\r\nnw64(ENET_VLAN_TBL(index), reg_val);\r\n}\r\nstatic void vlan_tbl_clear(struct niu *np)\r\n{\r\nint i;\r\nfor (i = 0; i < ENET_VLAN_TBL_NUM_ENTRIES; i++)\r\nnw64(ENET_VLAN_TBL(i), 0);\r\n}\r\nstatic int tcam_wait_bit(struct niu *np, u64 bit)\r\n{\r\nint limit = 1000;\r\nwhile (--limit > 0) {\r\nif (nr64(TCAM_CTL) & bit)\r\nbreak;\r\nudelay(1);\r\n}\r\nif (limit <= 0)\r\nreturn -ENODEV;\r\nreturn 0;\r\n}\r\nstatic int tcam_flush(struct niu *np, int index)\r\n{\r\nnw64(TCAM_KEY_0, 0x00);\r\nnw64(TCAM_KEY_MASK_0, 0xff);\r\nnw64(TCAM_CTL, (TCAM_CTL_RWC_TCAM_WRITE | index));\r\nreturn tcam_wait_bit(np, TCAM_CTL_STAT);\r\n}\r\nstatic int tcam_write(struct niu *np, int index,\r\nu64 *key, u64 *mask)\r\n{\r\nnw64(TCAM_KEY_0, key[0]);\r\nnw64(TCAM_KEY_1, key[1]);\r\nnw64(TCAM_KEY_2, key[2]);\r\nnw64(TCAM_KEY_3, key[3]);\r\nnw64(TCAM_KEY_MASK_0, mask[0]);\r\nnw64(TCAM_KEY_MASK_1, mask[1]);\r\nnw64(TCAM_KEY_MASK_2, mask[2]);\r\nnw64(TCAM_KEY_MASK_3, mask[3]);\r\nnw64(TCAM_CTL, (TCAM_CTL_RWC_TCAM_WRITE | index));\r\nreturn tcam_wait_bit(np, TCAM_CTL_STAT);\r\n}\r\nstatic int tcam_assoc_write(struct niu *np, int index, u64 assoc_data)\r\n{\r\nnw64(TCAM_KEY_1, assoc_data);\r\nnw64(TCAM_CTL, (TCAM_CTL_RWC_RAM_WRITE | index));\r\nreturn tcam_wait_bit(np, TCAM_CTL_STAT);\r\n}\r\nstatic void tcam_enable(struct niu *np, int on)\r\n{\r\nu64 val = nr64(FFLP_CFG_1);\r\nif (on)\r\nval &= ~FFLP_CFG_1_TCAM_DIS;\r\nelse\r\nval |= FFLP_CFG_1_TCAM_DIS;\r\nnw64(FFLP_CFG_1, val);\r\n}\r\nstatic void tcam_set_lat_and_ratio(struct niu *np, u64 latency, u64 ratio)\r\n{\r\nu64 val = nr64(FFLP_CFG_1);\r\nval &= ~(FFLP_CFG_1_FFLPINITDONE |\r\nFFLP_CFG_1_CAMLAT |\r\nFFLP_CFG_1_CAMRATIO);\r\nval |= (latency << FFLP_CFG_1_CAMLAT_SHIFT);\r\nval |= (ratio << FFLP_CFG_1_CAMRATIO_SHIFT);\r\nnw64(FFLP_CFG_1, val);\r\nval = nr64(FFLP_CFG_1);\r\nval |= FFLP_CFG_1_FFLPINITDONE;\r\nnw64(FFLP_CFG_1, val);\r\n}\r\nstatic int tcam_user_eth_class_enable(struct niu *np, unsigned long class,\r\nint on)\r\n{\r\nunsigned long reg;\r\nu64 val;\r\nif (class < CLASS_CODE_ETHERTYPE1 ||\r\nclass > CLASS_CODE_ETHERTYPE2)\r\nreturn -EINVAL;\r\nreg = L2_CLS(class - CLASS_CODE_ETHERTYPE1);\r\nval = nr64(reg);\r\nif (on)\r\nval |= L2_CLS_VLD;\r\nelse\r\nval &= ~L2_CLS_VLD;\r\nnw64(reg, val);\r\nreturn 0;\r\n}\r\nstatic int tcam_user_ip_class_enable(struct niu *np, unsigned long class,\r\nint on)\r\n{\r\nunsigned long reg;\r\nu64 val;\r\nif (class < CLASS_CODE_USER_PROG1 ||\r\nclass > CLASS_CODE_USER_PROG4)\r\nreturn -EINVAL;\r\nreg = L3_CLS(class - CLASS_CODE_USER_PROG1);\r\nval = nr64(reg);\r\nif (on)\r\nval |= L3_CLS_VALID;\r\nelse\r\nval &= ~L3_CLS_VALID;\r\nnw64(reg, val);\r\nreturn 0;\r\n}\r\nstatic int tcam_user_ip_class_set(struct niu *np, unsigned long class,\r\nint ipv6, u64 protocol_id,\r\nu64 tos_mask, u64 tos_val)\r\n{\r\nunsigned long reg;\r\nu64 val;\r\nif (class < CLASS_CODE_USER_PROG1 ||\r\nclass > CLASS_CODE_USER_PROG4 ||\r\n(protocol_id & ~(u64)0xff) != 0 ||\r\n(tos_mask & ~(u64)0xff) != 0 ||\r\n(tos_val & ~(u64)0xff) != 0)\r\nreturn -EINVAL;\r\nreg = L3_CLS(class - CLASS_CODE_USER_PROG1);\r\nval = nr64(reg);\r\nval &= ~(L3_CLS_IPVER | L3_CLS_PID |\r\nL3_CLS_TOSMASK | L3_CLS_TOS);\r\nif (ipv6)\r\nval |= L3_CLS_IPVER;\r\nval |= (protocol_id << L3_CLS_PID_SHIFT);\r\nval |= (tos_mask << L3_CLS_TOSMASK_SHIFT);\r\nval |= (tos_val << L3_CLS_TOS_SHIFT);\r\nnw64(reg, val);\r\nreturn 0;\r\n}\r\nstatic int tcam_early_init(struct niu *np)\r\n{\r\nunsigned long i;\r\nint err;\r\ntcam_enable(np, 0);\r\ntcam_set_lat_and_ratio(np,\r\nDEFAULT_TCAM_LATENCY,\r\nDEFAULT_TCAM_ACCESS_RATIO);\r\nfor (i = CLASS_CODE_ETHERTYPE1; i <= CLASS_CODE_ETHERTYPE2; i++) {\r\nerr = tcam_user_eth_class_enable(np, i, 0);\r\nif (err)\r\nreturn err;\r\n}\r\nfor (i = CLASS_CODE_USER_PROG1; i <= CLASS_CODE_USER_PROG4; i++) {\r\nerr = tcam_user_ip_class_enable(np, i, 0);\r\nif (err)\r\nreturn err;\r\n}\r\nreturn 0;\r\n}\r\nstatic int tcam_flush_all(struct niu *np)\r\n{\r\nunsigned long i;\r\nfor (i = 0; i < np->parent->tcam_num_entries; i++) {\r\nint err = tcam_flush(np, i);\r\nif (err)\r\nreturn err;\r\n}\r\nreturn 0;\r\n}\r\nstatic u64 hash_addr_regval(unsigned long index, unsigned long num_entries)\r\n{\r\nreturn (u64)index | (num_entries == 1 ? HASH_TBL_ADDR_AUTOINC : 0);\r\n}\r\nstatic int hash_write(struct niu *np, unsigned long partition,\r\nunsigned long index, unsigned long num_entries,\r\nu64 *data)\r\n{\r\nu64 val = hash_addr_regval(index, num_entries);\r\nunsigned long i;\r\nif (partition >= FCRAM_NUM_PARTITIONS ||\r\nindex + (num_entries * 8) > FCRAM_SIZE)\r\nreturn -EINVAL;\r\nnw64(HASH_TBL_ADDR(partition), val);\r\nfor (i = 0; i < num_entries; i++)\r\nnw64(HASH_TBL_DATA(partition), data[i]);\r\nreturn 0;\r\n}\r\nstatic void fflp_reset(struct niu *np)\r\n{\r\nu64 val;\r\nnw64(FFLP_CFG_1, FFLP_CFG_1_PIO_FIO_RST);\r\nudelay(10);\r\nnw64(FFLP_CFG_1, 0);\r\nval = FFLP_CFG_1_FCRAMOUTDR_NORMAL | FFLP_CFG_1_FFLPINITDONE;\r\nnw64(FFLP_CFG_1, val);\r\n}\r\nstatic void fflp_set_timings(struct niu *np)\r\n{\r\nu64 val = nr64(FFLP_CFG_1);\r\nval &= ~FFLP_CFG_1_FFLPINITDONE;\r\nval |= (DEFAULT_FCRAMRATIO << FFLP_CFG_1_FCRAMRATIO_SHIFT);\r\nnw64(FFLP_CFG_1, val);\r\nval = nr64(FFLP_CFG_1);\r\nval |= FFLP_CFG_1_FFLPINITDONE;\r\nnw64(FFLP_CFG_1, val);\r\nval = nr64(FCRAM_REF_TMR);\r\nval &= ~(FCRAM_REF_TMR_MAX | FCRAM_REF_TMR_MIN);\r\nval |= (DEFAULT_FCRAM_REFRESH_MAX << FCRAM_REF_TMR_MAX_SHIFT);\r\nval |= (DEFAULT_FCRAM_REFRESH_MIN << FCRAM_REF_TMR_MIN_SHIFT);\r\nnw64(FCRAM_REF_TMR, val);\r\n}\r\nstatic int fflp_set_partition(struct niu *np, u64 partition,\r\nu64 mask, u64 base, int enable)\r\n{\r\nunsigned long reg;\r\nu64 val;\r\nif (partition >= FCRAM_NUM_PARTITIONS ||\r\n(mask & ~(u64)0x1f) != 0 ||\r\n(base & ~(u64)0x1f) != 0)\r\nreturn -EINVAL;\r\nreg = FLW_PRT_SEL(partition);\r\nval = nr64(reg);\r\nval &= ~(FLW_PRT_SEL_EXT | FLW_PRT_SEL_MASK | FLW_PRT_SEL_BASE);\r\nval |= (mask << FLW_PRT_SEL_MASK_SHIFT);\r\nval |= (base << FLW_PRT_SEL_BASE_SHIFT);\r\nif (enable)\r\nval |= FLW_PRT_SEL_EXT;\r\nnw64(reg, val);\r\nreturn 0;\r\n}\r\nstatic int fflp_disable_all_partitions(struct niu *np)\r\n{\r\nunsigned long i;\r\nfor (i = 0; i < FCRAM_NUM_PARTITIONS; i++) {\r\nint err = fflp_set_partition(np, 0, 0, 0, 0);\r\nif (err)\r\nreturn err;\r\n}\r\nreturn 0;\r\n}\r\nstatic void fflp_llcsnap_enable(struct niu *np, int on)\r\n{\r\nu64 val = nr64(FFLP_CFG_1);\r\nif (on)\r\nval |= FFLP_CFG_1_LLCSNAP;\r\nelse\r\nval &= ~FFLP_CFG_1_LLCSNAP;\r\nnw64(FFLP_CFG_1, val);\r\n}\r\nstatic void fflp_errors_enable(struct niu *np, int on)\r\n{\r\nu64 val = nr64(FFLP_CFG_1);\r\nif (on)\r\nval &= ~FFLP_CFG_1_ERRORDIS;\r\nelse\r\nval |= FFLP_CFG_1_ERRORDIS;\r\nnw64(FFLP_CFG_1, val);\r\n}\r\nstatic int fflp_hash_clear(struct niu *np)\r\n{\r\nstruct fcram_hash_ipv4 ent;\r\nunsigned long i;\r\nmemset(&ent, 0, sizeof(ent));\r\nent.header = HASH_HEADER_EXT;\r\nfor (i = 0; i < FCRAM_SIZE; i += sizeof(ent)) {\r\nint err = hash_write(np, 0, i, 1, (u64 *) &ent);\r\nif (err)\r\nreturn err;\r\n}\r\nreturn 0;\r\n}\r\nstatic int fflp_early_init(struct niu *np)\r\n{\r\nstruct niu_parent *parent;\r\nunsigned long flags;\r\nint err;\r\nniu_lock_parent(np, flags);\r\nparent = np->parent;\r\nerr = 0;\r\nif (!(parent->flags & PARENT_FLGS_CLS_HWINIT)) {\r\nif (np->parent->plat_type != PLAT_TYPE_NIU) {\r\nfflp_reset(np);\r\nfflp_set_timings(np);\r\nerr = fflp_disable_all_partitions(np);\r\nif (err) {\r\nnetif_printk(np, probe, KERN_DEBUG, np->dev,\r\n"fflp_disable_all_partitions failed, err=%d\n",\r\nerr);\r\ngoto out;\r\n}\r\n}\r\nerr = tcam_early_init(np);\r\nif (err) {\r\nnetif_printk(np, probe, KERN_DEBUG, np->dev,\r\n"tcam_early_init failed, err=%d\n", err);\r\ngoto out;\r\n}\r\nfflp_llcsnap_enable(np, 1);\r\nfflp_errors_enable(np, 0);\r\nnw64(H1POLY, 0);\r\nnw64(H2POLY, 0);\r\nerr = tcam_flush_all(np);\r\nif (err) {\r\nnetif_printk(np, probe, KERN_DEBUG, np->dev,\r\n"tcam_flush_all failed, err=%d\n", err);\r\ngoto out;\r\n}\r\nif (np->parent->plat_type != PLAT_TYPE_NIU) {\r\nerr = fflp_hash_clear(np);\r\nif (err) {\r\nnetif_printk(np, probe, KERN_DEBUG, np->dev,\r\n"fflp_hash_clear failed, err=%d\n",\r\nerr);\r\ngoto out;\r\n}\r\n}\r\nvlan_tbl_clear(np);\r\nparent->flags |= PARENT_FLGS_CLS_HWINIT;\r\n}\r\nout:\r\nniu_unlock_parent(np, flags);\r\nreturn err;\r\n}\r\nstatic int niu_set_flow_key(struct niu *np, unsigned long class_code, u64 key)\r\n{\r\nif (class_code < CLASS_CODE_USER_PROG1 ||\r\nclass_code > CLASS_CODE_SCTP_IPV6)\r\nreturn -EINVAL;\r\nnw64(FLOW_KEY(class_code - CLASS_CODE_USER_PROG1), key);\r\nreturn 0;\r\n}\r\nstatic int niu_set_tcam_key(struct niu *np, unsigned long class_code, u64 key)\r\n{\r\nif (class_code < CLASS_CODE_USER_PROG1 ||\r\nclass_code > CLASS_CODE_SCTP_IPV6)\r\nreturn -EINVAL;\r\nnw64(TCAM_KEY(class_code - CLASS_CODE_USER_PROG1), key);\r\nreturn 0;\r\n}\r\nstatic u16 tcam_get_index(struct niu *np, u16 idx)\r\n{\r\nif (idx >= (np->clas.tcam_sz - 1))\r\nidx = 0;\r\nreturn np->clas.tcam_top + ((idx+1) * np->parent->num_ports);\r\n}\r\nstatic u16 tcam_get_size(struct niu *np)\r\n{\r\nreturn np->clas.tcam_sz - 1;\r\n}\r\nstatic u16 tcam_get_valid_entry_cnt(struct niu *np)\r\n{\r\nreturn np->clas.tcam_valid_entries - 1;\r\n}\r\nstatic void niu_rx_skb_append(struct sk_buff *skb, struct page *page,\r\nu32 offset, u32 size, u32 truesize)\r\n{\r\nskb_fill_page_desc(skb, skb_shinfo(skb)->nr_frags, page, offset, size);\r\nskb->len += size;\r\nskb->data_len += size;\r\nskb->truesize += truesize;\r\n}\r\nstatic unsigned int niu_hash_rxaddr(struct rx_ring_info *rp, u64 a)\r\n{\r\na >>= PAGE_SHIFT;\r\na ^= (a >> ilog2(MAX_RBR_RING_SIZE));\r\nreturn a & (MAX_RBR_RING_SIZE - 1);\r\n}\r\nstatic struct page *niu_find_rxpage(struct rx_ring_info *rp, u64 addr,\r\nstruct page ***link)\r\n{\r\nunsigned int h = niu_hash_rxaddr(rp, addr);\r\nstruct page *p, **pp;\r\naddr &= PAGE_MASK;\r\npp = &rp->rxhash[h];\r\nfor (; (p = *pp) != NULL; pp = (struct page **) &p->mapping) {\r\nif (p->index == addr) {\r\n*link = pp;\r\ngoto found;\r\n}\r\n}\r\nBUG();\r\nfound:\r\nreturn p;\r\n}\r\nstatic void niu_hash_page(struct rx_ring_info *rp, struct page *page, u64 base)\r\n{\r\nunsigned int h = niu_hash_rxaddr(rp, base);\r\npage->index = base;\r\npage->mapping = (struct address_space *) rp->rxhash[h];\r\nrp->rxhash[h] = page;\r\n}\r\nstatic int niu_rbr_add_page(struct niu *np, struct rx_ring_info *rp,\r\ngfp_t mask, int start_index)\r\n{\r\nstruct page *page;\r\nu64 addr;\r\nint i;\r\npage = alloc_page(mask);\r\nif (!page)\r\nreturn -ENOMEM;\r\naddr = np->ops->map_page(np->device, page, 0,\r\nPAGE_SIZE, DMA_FROM_DEVICE);\r\nif (!addr) {\r\n__free_page(page);\r\nreturn -ENOMEM;\r\n}\r\nniu_hash_page(rp, page, addr);\r\nif (rp->rbr_blocks_per_page > 1)\r\natomic_add(rp->rbr_blocks_per_page - 1, &page->_count);\r\nfor (i = 0; i < rp->rbr_blocks_per_page; i++) {\r\n__le32 *rbr = &rp->rbr[start_index + i];\r\n*rbr = cpu_to_le32(addr >> RBR_DESCR_ADDR_SHIFT);\r\naddr += rp->rbr_block_size;\r\n}\r\nreturn 0;\r\n}\r\nstatic void niu_rbr_refill(struct niu *np, struct rx_ring_info *rp, gfp_t mask)\r\n{\r\nint index = rp->rbr_index;\r\nrp->rbr_pending++;\r\nif ((rp->rbr_pending % rp->rbr_blocks_per_page) == 0) {\r\nint err = niu_rbr_add_page(np, rp, mask, index);\r\nif (unlikely(err)) {\r\nrp->rbr_pending--;\r\nreturn;\r\n}\r\nrp->rbr_index += rp->rbr_blocks_per_page;\r\nBUG_ON(rp->rbr_index > rp->rbr_table_size);\r\nif (rp->rbr_index == rp->rbr_table_size)\r\nrp->rbr_index = 0;\r\nif (rp->rbr_pending >= rp->rbr_kick_thresh) {\r\nnw64(RBR_KICK(rp->rx_channel), rp->rbr_pending);\r\nrp->rbr_pending = 0;\r\n}\r\n}\r\n}\r\nstatic int niu_rx_pkt_ignore(struct niu *np, struct rx_ring_info *rp)\r\n{\r\nunsigned int index = rp->rcr_index;\r\nint num_rcr = 0;\r\nrp->rx_dropped++;\r\nwhile (1) {\r\nstruct page *page, **link;\r\nu64 addr, val;\r\nu32 rcr_size;\r\nnum_rcr++;\r\nval = le64_to_cpup(&rp->rcr[index]);\r\naddr = (val & RCR_ENTRY_PKT_BUF_ADDR) <<\r\nRCR_ENTRY_PKT_BUF_ADDR_SHIFT;\r\npage = niu_find_rxpage(rp, addr, &link);\r\nrcr_size = rp->rbr_sizes[(val & RCR_ENTRY_PKTBUFSZ) >>\r\nRCR_ENTRY_PKTBUFSZ_SHIFT];\r\nif ((page->index + PAGE_SIZE) - rcr_size == addr) {\r\n*link = (struct page *) page->mapping;\r\nnp->ops->unmap_page(np->device, page->index,\r\nPAGE_SIZE, DMA_FROM_DEVICE);\r\npage->index = 0;\r\npage->mapping = NULL;\r\n__free_page(page);\r\nrp->rbr_refill_pending++;\r\n}\r\nindex = NEXT_RCR(rp, index);\r\nif (!(val & RCR_ENTRY_MULTI))\r\nbreak;\r\n}\r\nrp->rcr_index = index;\r\nreturn num_rcr;\r\n}\r\nstatic int niu_process_rx_pkt(struct napi_struct *napi, struct niu *np,\r\nstruct rx_ring_info *rp)\r\n{\r\nunsigned int index = rp->rcr_index;\r\nstruct rx_pkt_hdr1 *rh;\r\nstruct sk_buff *skb;\r\nint len, num_rcr;\r\nskb = netdev_alloc_skb(np->dev, RX_SKB_ALLOC_SIZE);\r\nif (unlikely(!skb))\r\nreturn niu_rx_pkt_ignore(np, rp);\r\nnum_rcr = 0;\r\nwhile (1) {\r\nstruct page *page, **link;\r\nu32 rcr_size, append_size;\r\nu64 addr, val, off;\r\nnum_rcr++;\r\nval = le64_to_cpup(&rp->rcr[index]);\r\nlen = (val & RCR_ENTRY_L2_LEN) >>\r\nRCR_ENTRY_L2_LEN_SHIFT;\r\nlen -= ETH_FCS_LEN;\r\naddr = (val & RCR_ENTRY_PKT_BUF_ADDR) <<\r\nRCR_ENTRY_PKT_BUF_ADDR_SHIFT;\r\npage = niu_find_rxpage(rp, addr, &link);\r\nrcr_size = rp->rbr_sizes[(val & RCR_ENTRY_PKTBUFSZ) >>\r\nRCR_ENTRY_PKTBUFSZ_SHIFT];\r\noff = addr & ~PAGE_MASK;\r\nappend_size = rcr_size;\r\nif (num_rcr == 1) {\r\nint ptype;\r\nptype = (val >> RCR_ENTRY_PKT_TYPE_SHIFT);\r\nif ((ptype == RCR_PKT_TYPE_TCP ||\r\nptype == RCR_PKT_TYPE_UDP) &&\r\n!(val & (RCR_ENTRY_NOPORT |\r\nRCR_ENTRY_ERROR)))\r\nskb->ip_summed = CHECKSUM_UNNECESSARY;\r\nelse\r\nskb_checksum_none_assert(skb);\r\n} else if (!(val & RCR_ENTRY_MULTI))\r\nappend_size = len - skb->len;\r\nniu_rx_skb_append(skb, page, off, append_size, rcr_size);\r\nif ((page->index + rp->rbr_block_size) - rcr_size == addr) {\r\n*link = (struct page *) page->mapping;\r\nnp->ops->unmap_page(np->device, page->index,\r\nPAGE_SIZE, DMA_FROM_DEVICE);\r\npage->index = 0;\r\npage->mapping = NULL;\r\nrp->rbr_refill_pending++;\r\n} else\r\nget_page(page);\r\nindex = NEXT_RCR(rp, index);\r\nif (!(val & RCR_ENTRY_MULTI))\r\nbreak;\r\n}\r\nrp->rcr_index = index;\r\nlen += sizeof(*rh);\r\nlen = min_t(int, len, sizeof(*rh) + VLAN_ETH_HLEN);\r\n__pskb_pull_tail(skb, len);\r\nrh = (struct rx_pkt_hdr1 *) skb->data;\r\nif (np->dev->features & NETIF_F_RXHASH)\r\nskb_set_hash(skb,\r\n((u32)rh->hashval2_0 << 24 |\r\n(u32)rh->hashval2_1 << 16 |\r\n(u32)rh->hashval1_1 << 8 |\r\n(u32)rh->hashval1_2 << 0),\r\nPKT_HASH_TYPE_L3);\r\nskb_pull(skb, sizeof(*rh));\r\nrp->rx_packets++;\r\nrp->rx_bytes += skb->len;\r\nskb->protocol = eth_type_trans(skb, np->dev);\r\nskb_record_rx_queue(skb, rp->rx_channel);\r\nnapi_gro_receive(napi, skb);\r\nreturn num_rcr;\r\n}\r\nstatic int niu_rbr_fill(struct niu *np, struct rx_ring_info *rp, gfp_t mask)\r\n{\r\nint blocks_per_page = rp->rbr_blocks_per_page;\r\nint err, index = rp->rbr_index;\r\nerr = 0;\r\nwhile (index < (rp->rbr_table_size - blocks_per_page)) {\r\nerr = niu_rbr_add_page(np, rp, mask, index);\r\nif (unlikely(err))\r\nbreak;\r\nindex += blocks_per_page;\r\n}\r\nrp->rbr_index = index;\r\nreturn err;\r\n}\r\nstatic void niu_rbr_free(struct niu *np, struct rx_ring_info *rp)\r\n{\r\nint i;\r\nfor (i = 0; i < MAX_RBR_RING_SIZE; i++) {\r\nstruct page *page;\r\npage = rp->rxhash[i];\r\nwhile (page) {\r\nstruct page *next = (struct page *) page->mapping;\r\nu64 base = page->index;\r\nnp->ops->unmap_page(np->device, base, PAGE_SIZE,\r\nDMA_FROM_DEVICE);\r\npage->index = 0;\r\npage->mapping = NULL;\r\n__free_page(page);\r\npage = next;\r\n}\r\n}\r\nfor (i = 0; i < rp->rbr_table_size; i++)\r\nrp->rbr[i] = cpu_to_le32(0);\r\nrp->rbr_index = 0;\r\n}\r\nstatic int release_tx_packet(struct niu *np, struct tx_ring_info *rp, int idx)\r\n{\r\nstruct tx_buff_info *tb = &rp->tx_buffs[idx];\r\nstruct sk_buff *skb = tb->skb;\r\nstruct tx_pkt_hdr *tp;\r\nu64 tx_flags;\r\nint i, len;\r\ntp = (struct tx_pkt_hdr *) skb->data;\r\ntx_flags = le64_to_cpup(&tp->flags);\r\nrp->tx_packets++;\r\nrp->tx_bytes += (((tx_flags & TXHDR_LEN) >> TXHDR_LEN_SHIFT) -\r\n((tx_flags & TXHDR_PAD) / 2));\r\nlen = skb_headlen(skb);\r\nnp->ops->unmap_single(np->device, tb->mapping,\r\nlen, DMA_TO_DEVICE);\r\nif (le64_to_cpu(rp->descr[idx]) & TX_DESC_MARK)\r\nrp->mark_pending--;\r\ntb->skb = NULL;\r\ndo {\r\nidx = NEXT_TX(rp, idx);\r\nlen -= MAX_TX_DESC_LEN;\r\n} while (len > 0);\r\nfor (i = 0; i < skb_shinfo(skb)->nr_frags; i++) {\r\ntb = &rp->tx_buffs[idx];\r\nBUG_ON(tb->skb != NULL);\r\nnp->ops->unmap_page(np->device, tb->mapping,\r\nskb_frag_size(&skb_shinfo(skb)->frags[i]),\r\nDMA_TO_DEVICE);\r\nidx = NEXT_TX(rp, idx);\r\n}\r\ndev_kfree_skb(skb);\r\nreturn idx;\r\n}\r\nstatic void niu_tx_work(struct niu *np, struct tx_ring_info *rp)\r\n{\r\nstruct netdev_queue *txq;\r\nu16 pkt_cnt, tmp;\r\nint cons, index;\r\nu64 cs;\r\nindex = (rp - np->tx_rings);\r\ntxq = netdev_get_tx_queue(np->dev, index);\r\ncs = rp->tx_cs;\r\nif (unlikely(!(cs & (TX_CS_MK | TX_CS_MMK))))\r\ngoto out;\r\ntmp = pkt_cnt = (cs & TX_CS_PKT_CNT) >> TX_CS_PKT_CNT_SHIFT;\r\npkt_cnt = (pkt_cnt - rp->last_pkt_cnt) &\r\n(TX_CS_PKT_CNT >> TX_CS_PKT_CNT_SHIFT);\r\nrp->last_pkt_cnt = tmp;\r\ncons = rp->cons;\r\nnetif_printk(np, tx_done, KERN_DEBUG, np->dev,\r\n"%s() pkt_cnt[%u] cons[%d]\n", __func__, pkt_cnt, cons);\r\nwhile (pkt_cnt--)\r\ncons = release_tx_packet(np, rp, cons);\r\nrp->cons = cons;\r\nsmp_mb();\r\nout:\r\nif (unlikely(netif_tx_queue_stopped(txq) &&\r\n(niu_tx_avail(rp) > NIU_TX_WAKEUP_THRESH(rp)))) {\r\n__netif_tx_lock(txq, smp_processor_id());\r\nif (netif_tx_queue_stopped(txq) &&\r\n(niu_tx_avail(rp) > NIU_TX_WAKEUP_THRESH(rp)))\r\nnetif_tx_wake_queue(txq);\r\n__netif_tx_unlock(txq);\r\n}\r\n}\r\nstatic inline void niu_sync_rx_discard_stats(struct niu *np,\r\nstruct rx_ring_info *rp,\r\nconst int limit)\r\n{\r\nint rx_channel = rp->rx_channel;\r\nu32 misc, wred;\r\nmisc = nr64(RXMISC(rx_channel));\r\nif (unlikely((misc & RXMISC_COUNT) > limit)) {\r\nnw64(RXMISC(rx_channel), 0);\r\nrp->rx_errors += misc & RXMISC_COUNT;\r\nif (unlikely(misc & RXMISC_OFLOW))\r\ndev_err(np->device, "rx-%d: Counter overflow RXMISC discard\n",\r\nrx_channel);\r\nnetif_printk(np, rx_err, KERN_DEBUG, np->dev,\r\n"rx-%d: MISC drop=%u over=%u\n",\r\nrx_channel, misc, misc-limit);\r\n}\r\nwred = nr64(RED_DIS_CNT(rx_channel));\r\nif (unlikely((wred & RED_DIS_CNT_COUNT) > limit)) {\r\nnw64(RED_DIS_CNT(rx_channel), 0);\r\nrp->rx_dropped += wred & RED_DIS_CNT_COUNT;\r\nif (unlikely(wred & RED_DIS_CNT_OFLOW))\r\ndev_err(np->device, "rx-%d: Counter overflow WRED discard\n", rx_channel);\r\nnetif_printk(np, rx_err, KERN_DEBUG, np->dev,\r\n"rx-%d: WRED drop=%u over=%u\n",\r\nrx_channel, wred, wred-limit);\r\n}\r\n}\r\nstatic int niu_rx_work(struct napi_struct *napi, struct niu *np,\r\nstruct rx_ring_info *rp, int budget)\r\n{\r\nint qlen, rcr_done = 0, work_done = 0;\r\nstruct rxdma_mailbox *mbox = rp->mbox;\r\nu64 stat;\r\n#if 1\r\nstat = nr64(RX_DMA_CTL_STAT(rp->rx_channel));\r\nqlen = nr64(RCRSTAT_A(rp->rx_channel)) & RCRSTAT_A_QLEN;\r\n#else\r\nstat = le64_to_cpup(&mbox->rx_dma_ctl_stat);\r\nqlen = (le64_to_cpup(&mbox->rcrstat_a) & RCRSTAT_A_QLEN);\r\n#endif\r\nmbox->rx_dma_ctl_stat = 0;\r\nmbox->rcrstat_a = 0;\r\nnetif_printk(np, rx_status, KERN_DEBUG, np->dev,\r\n"%s(chan[%d]), stat[%llx] qlen=%d\n",\r\n__func__, rp->rx_channel, (unsigned long long)stat, qlen);\r\nrcr_done = work_done = 0;\r\nqlen = min(qlen, budget);\r\nwhile (work_done < qlen) {\r\nrcr_done += niu_process_rx_pkt(napi, np, rp);\r\nwork_done++;\r\n}\r\nif (rp->rbr_refill_pending >= rp->rbr_kick_thresh) {\r\nunsigned int i;\r\nfor (i = 0; i < rp->rbr_refill_pending; i++)\r\nniu_rbr_refill(np, rp, GFP_ATOMIC);\r\nrp->rbr_refill_pending = 0;\r\n}\r\nstat = (RX_DMA_CTL_STAT_MEX |\r\n((u64)work_done << RX_DMA_CTL_STAT_PKTREAD_SHIFT) |\r\n((u64)rcr_done << RX_DMA_CTL_STAT_PTRREAD_SHIFT));\r\nnw64(RX_DMA_CTL_STAT(rp->rx_channel), stat);\r\nif (qlen > 10)\r\nniu_sync_rx_discard_stats(np, rp, 0x7FFF);\r\nreturn work_done;\r\n}\r\nstatic int niu_poll_core(struct niu *np, struct niu_ldg *lp, int budget)\r\n{\r\nu64 v0 = lp->v0;\r\nu32 tx_vec = (v0 >> 32);\r\nu32 rx_vec = (v0 & 0xffffffff);\r\nint i, work_done = 0;\r\nnetif_printk(np, intr, KERN_DEBUG, np->dev,\r\n"%s() v0[%016llx]\n", __func__, (unsigned long long)v0);\r\nfor (i = 0; i < np->num_tx_rings; i++) {\r\nstruct tx_ring_info *rp = &np->tx_rings[i];\r\nif (tx_vec & (1 << rp->tx_channel))\r\nniu_tx_work(np, rp);\r\nnw64(LD_IM0(LDN_TXDMA(rp->tx_channel)), 0);\r\n}\r\nfor (i = 0; i < np->num_rx_rings; i++) {\r\nstruct rx_ring_info *rp = &np->rx_rings[i];\r\nif (rx_vec & (1 << rp->rx_channel)) {\r\nint this_work_done;\r\nthis_work_done = niu_rx_work(&lp->napi, np, rp,\r\nbudget);\r\nbudget -= this_work_done;\r\nwork_done += this_work_done;\r\n}\r\nnw64(LD_IM0(LDN_RXDMA(rp->rx_channel)), 0);\r\n}\r\nreturn work_done;\r\n}\r\nstatic int niu_poll(struct napi_struct *napi, int budget)\r\n{\r\nstruct niu_ldg *lp = container_of(napi, struct niu_ldg, napi);\r\nstruct niu *np = lp->np;\r\nint work_done;\r\nwork_done = niu_poll_core(np, lp, budget);\r\nif (work_done < budget) {\r\nnapi_complete(napi);\r\nniu_ldg_rearm(np, lp, 1);\r\n}\r\nreturn work_done;\r\n}\r\nstatic void niu_log_rxchan_errors(struct niu *np, struct rx_ring_info *rp,\r\nu64 stat)\r\n{\r\nnetdev_err(np->dev, "RX channel %u errors ( ", rp->rx_channel);\r\nif (stat & RX_DMA_CTL_STAT_RBR_TMOUT)\r\npr_cont("RBR_TMOUT ");\r\nif (stat & RX_DMA_CTL_STAT_RSP_CNT_ERR)\r\npr_cont("RSP_CNT ");\r\nif (stat & RX_DMA_CTL_STAT_BYTE_EN_BUS)\r\npr_cont("BYTE_EN_BUS ");\r\nif (stat & RX_DMA_CTL_STAT_RSP_DAT_ERR)\r\npr_cont("RSP_DAT ");\r\nif (stat & RX_DMA_CTL_STAT_RCR_ACK_ERR)\r\npr_cont("RCR_ACK ");\r\nif (stat & RX_DMA_CTL_STAT_RCR_SHA_PAR)\r\npr_cont("RCR_SHA_PAR ");\r\nif (stat & RX_DMA_CTL_STAT_RBR_PRE_PAR)\r\npr_cont("RBR_PRE_PAR ");\r\nif (stat & RX_DMA_CTL_STAT_CONFIG_ERR)\r\npr_cont("CONFIG ");\r\nif (stat & RX_DMA_CTL_STAT_RCRINCON)\r\npr_cont("RCRINCON ");\r\nif (stat & RX_DMA_CTL_STAT_RCRFULL)\r\npr_cont("RCRFULL ");\r\nif (stat & RX_DMA_CTL_STAT_RBRFULL)\r\npr_cont("RBRFULL ");\r\nif (stat & RX_DMA_CTL_STAT_RBRLOGPAGE)\r\npr_cont("RBRLOGPAGE ");\r\nif (stat & RX_DMA_CTL_STAT_CFIGLOGPAGE)\r\npr_cont("CFIGLOGPAGE ");\r\nif (stat & RX_DMA_CTL_STAT_DC_FIFO_ERR)\r\npr_cont("DC_FIDO ");\r\npr_cont(")\n");\r\n}\r\nstatic int niu_rx_error(struct niu *np, struct rx_ring_info *rp)\r\n{\r\nu64 stat = nr64(RX_DMA_CTL_STAT(rp->rx_channel));\r\nint err = 0;\r\nif (stat & (RX_DMA_CTL_STAT_CHAN_FATAL |\r\nRX_DMA_CTL_STAT_PORT_FATAL))\r\nerr = -EINVAL;\r\nif (err) {\r\nnetdev_err(np->dev, "RX channel %u error, stat[%llx]\n",\r\nrp->rx_channel,\r\n(unsigned long long) stat);\r\nniu_log_rxchan_errors(np, rp, stat);\r\n}\r\nnw64(RX_DMA_CTL_STAT(rp->rx_channel),\r\nstat & RX_DMA_CTL_WRITE_CLEAR_ERRS);\r\nreturn err;\r\n}\r\nstatic void niu_log_txchan_errors(struct niu *np, struct tx_ring_info *rp,\r\nu64 cs)\r\n{\r\nnetdev_err(np->dev, "TX channel %u errors ( ", rp->tx_channel);\r\nif (cs & TX_CS_MBOX_ERR)\r\npr_cont("MBOX ");\r\nif (cs & TX_CS_PKT_SIZE_ERR)\r\npr_cont("PKT_SIZE ");\r\nif (cs & TX_CS_TX_RING_OFLOW)\r\npr_cont("TX_RING_OFLOW ");\r\nif (cs & TX_CS_PREF_BUF_PAR_ERR)\r\npr_cont("PREF_BUF_PAR ");\r\nif (cs & TX_CS_NACK_PREF)\r\npr_cont("NACK_PREF ");\r\nif (cs & TX_CS_NACK_PKT_RD)\r\npr_cont("NACK_PKT_RD ");\r\nif (cs & TX_CS_CONF_PART_ERR)\r\npr_cont("CONF_PART ");\r\nif (cs & TX_CS_PKT_PRT_ERR)\r\npr_cont("PKT_PTR ");\r\npr_cont(")\n");\r\n}\r\nstatic int niu_tx_error(struct niu *np, struct tx_ring_info *rp)\r\n{\r\nu64 cs, logh, logl;\r\ncs = nr64(TX_CS(rp->tx_channel));\r\nlogh = nr64(TX_RNG_ERR_LOGH(rp->tx_channel));\r\nlogl = nr64(TX_RNG_ERR_LOGL(rp->tx_channel));\r\nnetdev_err(np->dev, "TX channel %u error, cs[%llx] logh[%llx] logl[%llx]\n",\r\nrp->tx_channel,\r\n(unsigned long long)cs,\r\n(unsigned long long)logh,\r\n(unsigned long long)logl);\r\nniu_log_txchan_errors(np, rp, cs);\r\nreturn -ENODEV;\r\n}\r\nstatic int niu_mif_interrupt(struct niu *np)\r\n{\r\nu64 mif_status = nr64(MIF_STATUS);\r\nint phy_mdint = 0;\r\nif (np->flags & NIU_FLAGS_XMAC) {\r\nu64 xrxmac_stat = nr64_mac(XRXMAC_STATUS);\r\nif (xrxmac_stat & XRXMAC_STATUS_PHY_MDINT)\r\nphy_mdint = 1;\r\n}\r\nnetdev_err(np->dev, "MIF interrupt, stat[%llx] phy_mdint(%d)\n",\r\n(unsigned long long)mif_status, phy_mdint);\r\nreturn -ENODEV;\r\n}\r\nstatic void niu_xmac_interrupt(struct niu *np)\r\n{\r\nstruct niu_xmac_stats *mp = &np->mac_stats.xmac;\r\nu64 val;\r\nval = nr64_mac(XTXMAC_STATUS);\r\nif (val & XTXMAC_STATUS_FRAME_CNT_EXP)\r\nmp->tx_frames += TXMAC_FRM_CNT_COUNT;\r\nif (val & XTXMAC_STATUS_BYTE_CNT_EXP)\r\nmp->tx_bytes += TXMAC_BYTE_CNT_COUNT;\r\nif (val & XTXMAC_STATUS_TXFIFO_XFR_ERR)\r\nmp->tx_fifo_errors++;\r\nif (val & XTXMAC_STATUS_TXMAC_OFLOW)\r\nmp->tx_overflow_errors++;\r\nif (val & XTXMAC_STATUS_MAX_PSIZE_ERR)\r\nmp->tx_max_pkt_size_errors++;\r\nif (val & XTXMAC_STATUS_TXMAC_UFLOW)\r\nmp->tx_underflow_errors++;\r\nval = nr64_mac(XRXMAC_STATUS);\r\nif (val & XRXMAC_STATUS_LCL_FLT_STATUS)\r\nmp->rx_local_faults++;\r\nif (val & XRXMAC_STATUS_RFLT_DET)\r\nmp->rx_remote_faults++;\r\nif (val & XRXMAC_STATUS_LFLT_CNT_EXP)\r\nmp->rx_link_faults += LINK_FAULT_CNT_COUNT;\r\nif (val & XRXMAC_STATUS_ALIGNERR_CNT_EXP)\r\nmp->rx_align_errors += RXMAC_ALIGN_ERR_CNT_COUNT;\r\nif (val & XRXMAC_STATUS_RXFRAG_CNT_EXP)\r\nmp->rx_frags += RXMAC_FRAG_CNT_COUNT;\r\nif (val & XRXMAC_STATUS_RXMULTF_CNT_EXP)\r\nmp->rx_mcasts += RXMAC_MC_FRM_CNT_COUNT;\r\nif (val & XRXMAC_STATUS_RXBCAST_CNT_EXP)\r\nmp->rx_bcasts += RXMAC_BC_FRM_CNT_COUNT;\r\nif (val & XRXMAC_STATUS_RXBCAST_CNT_EXP)\r\nmp->rx_bcasts += RXMAC_BC_FRM_CNT_COUNT;\r\nif (val & XRXMAC_STATUS_RXHIST1_CNT_EXP)\r\nmp->rx_hist_cnt1 += RXMAC_HIST_CNT1_COUNT;\r\nif (val & XRXMAC_STATUS_RXHIST2_CNT_EXP)\r\nmp->rx_hist_cnt2 += RXMAC_HIST_CNT2_COUNT;\r\nif (val & XRXMAC_STATUS_RXHIST3_CNT_EXP)\r\nmp->rx_hist_cnt3 += RXMAC_HIST_CNT3_COUNT;\r\nif (val & XRXMAC_STATUS_RXHIST4_CNT_EXP)\r\nmp->rx_hist_cnt4 += RXMAC_HIST_CNT4_COUNT;\r\nif (val & XRXMAC_STATUS_RXHIST5_CNT_EXP)\r\nmp->rx_hist_cnt5 += RXMAC_HIST_CNT5_COUNT;\r\nif (val & XRXMAC_STATUS_RXHIST6_CNT_EXP)\r\nmp->rx_hist_cnt6 += RXMAC_HIST_CNT6_COUNT;\r\nif (val & XRXMAC_STATUS_RXHIST7_CNT_EXP)\r\nmp->rx_hist_cnt7 += RXMAC_HIST_CNT7_COUNT;\r\nif (val & XRXMAC_STATUS_RXOCTET_CNT_EXP)\r\nmp->rx_octets += RXMAC_BT_CNT_COUNT;\r\nif (val & XRXMAC_STATUS_CVIOLERR_CNT_EXP)\r\nmp->rx_code_violations += RXMAC_CD_VIO_CNT_COUNT;\r\nif (val & XRXMAC_STATUS_LENERR_CNT_EXP)\r\nmp->rx_len_errors += RXMAC_MPSZER_CNT_COUNT;\r\nif (val & XRXMAC_STATUS_CRCERR_CNT_EXP)\r\nmp->rx_crc_errors += RXMAC_CRC_ER_CNT_COUNT;\r\nif (val & XRXMAC_STATUS_RXUFLOW)\r\nmp->rx_underflows++;\r\nif (val & XRXMAC_STATUS_RXOFLOW)\r\nmp->rx_overflows++;\r\nval = nr64_mac(XMAC_FC_STAT);\r\nif (val & XMAC_FC_STAT_TX_MAC_NPAUSE)\r\nmp->pause_off_state++;\r\nif (val & XMAC_FC_STAT_TX_MAC_PAUSE)\r\nmp->pause_on_state++;\r\nif (val & XMAC_FC_STAT_RX_MAC_RPAUSE)\r\nmp->pause_received++;\r\n}\r\nstatic void niu_bmac_interrupt(struct niu *np)\r\n{\r\nstruct niu_bmac_stats *mp = &np->mac_stats.bmac;\r\nu64 val;\r\nval = nr64_mac(BTXMAC_STATUS);\r\nif (val & BTXMAC_STATUS_UNDERRUN)\r\nmp->tx_underflow_errors++;\r\nif (val & BTXMAC_STATUS_MAX_PKT_ERR)\r\nmp->tx_max_pkt_size_errors++;\r\nif (val & BTXMAC_STATUS_BYTE_CNT_EXP)\r\nmp->tx_bytes += BTXMAC_BYTE_CNT_COUNT;\r\nif (val & BTXMAC_STATUS_FRAME_CNT_EXP)\r\nmp->tx_frames += BTXMAC_FRM_CNT_COUNT;\r\nval = nr64_mac(BRXMAC_STATUS);\r\nif (val & BRXMAC_STATUS_OVERFLOW)\r\nmp->rx_overflows++;\r\nif (val & BRXMAC_STATUS_FRAME_CNT_EXP)\r\nmp->rx_frames += BRXMAC_FRAME_CNT_COUNT;\r\nif (val & BRXMAC_STATUS_ALIGN_ERR_EXP)\r\nmp->rx_align_errors += BRXMAC_ALIGN_ERR_CNT_COUNT;\r\nif (val & BRXMAC_STATUS_CRC_ERR_EXP)\r\nmp->rx_crc_errors += BRXMAC_ALIGN_ERR_CNT_COUNT;\r\nif (val & BRXMAC_STATUS_LEN_ERR_EXP)\r\nmp->rx_len_errors += BRXMAC_CODE_VIOL_ERR_CNT_COUNT;\r\nval = nr64_mac(BMAC_CTRL_STATUS);\r\nif (val & BMAC_CTRL_STATUS_NOPAUSE)\r\nmp->pause_off_state++;\r\nif (val & BMAC_CTRL_STATUS_PAUSE)\r\nmp->pause_on_state++;\r\nif (val & BMAC_CTRL_STATUS_PAUSE_RECV)\r\nmp->pause_received++;\r\n}\r\nstatic int niu_mac_interrupt(struct niu *np)\r\n{\r\nif (np->flags & NIU_FLAGS_XMAC)\r\nniu_xmac_interrupt(np);\r\nelse\r\nniu_bmac_interrupt(np);\r\nreturn 0;\r\n}\r\nstatic void niu_log_device_error(struct niu *np, u64 stat)\r\n{\r\nnetdev_err(np->dev, "Core device errors ( ");\r\nif (stat & SYS_ERR_MASK_META2)\r\npr_cont("META2 ");\r\nif (stat & SYS_ERR_MASK_META1)\r\npr_cont("META1 ");\r\nif (stat & SYS_ERR_MASK_PEU)\r\npr_cont("PEU ");\r\nif (stat & SYS_ERR_MASK_TXC)\r\npr_cont("TXC ");\r\nif (stat & SYS_ERR_MASK_RDMC)\r\npr_cont("RDMC ");\r\nif (stat & SYS_ERR_MASK_TDMC)\r\npr_cont("TDMC ");\r\nif (stat & SYS_ERR_MASK_ZCP)\r\npr_cont("ZCP ");\r\nif (stat & SYS_ERR_MASK_FFLP)\r\npr_cont("FFLP ");\r\nif (stat & SYS_ERR_MASK_IPP)\r\npr_cont("IPP ");\r\nif (stat & SYS_ERR_MASK_MAC)\r\npr_cont("MAC ");\r\nif (stat & SYS_ERR_MASK_SMX)\r\npr_cont("SMX ");\r\npr_cont(")\n");\r\n}\r\nstatic int niu_device_error(struct niu *np)\r\n{\r\nu64 stat = nr64(SYS_ERR_STAT);\r\nnetdev_err(np->dev, "Core device error, stat[%llx]\n",\r\n(unsigned long long)stat);\r\nniu_log_device_error(np, stat);\r\nreturn -ENODEV;\r\n}\r\nstatic int niu_slowpath_interrupt(struct niu *np, struct niu_ldg *lp,\r\nu64 v0, u64 v1, u64 v2)\r\n{\r\nint i, err = 0;\r\nlp->v0 = v0;\r\nlp->v1 = v1;\r\nlp->v2 = v2;\r\nif (v1 & 0x00000000ffffffffULL) {\r\nu32 rx_vec = (v1 & 0xffffffff);\r\nfor (i = 0; i < np->num_rx_rings; i++) {\r\nstruct rx_ring_info *rp = &np->rx_rings[i];\r\nif (rx_vec & (1 << rp->rx_channel)) {\r\nint r = niu_rx_error(np, rp);\r\nif (r) {\r\nerr = r;\r\n} else {\r\nif (!v0)\r\nnw64(RX_DMA_CTL_STAT(rp->rx_channel),\r\nRX_DMA_CTL_STAT_MEX);\r\n}\r\n}\r\n}\r\n}\r\nif (v1 & 0x7fffffff00000000ULL) {\r\nu32 tx_vec = (v1 >> 32) & 0x7fffffff;\r\nfor (i = 0; i < np->num_tx_rings; i++) {\r\nstruct tx_ring_info *rp = &np->tx_rings[i];\r\nif (tx_vec & (1 << rp->tx_channel)) {\r\nint r = niu_tx_error(np, rp);\r\nif (r)\r\nerr = r;\r\n}\r\n}\r\n}\r\nif ((v0 | v1) & 0x8000000000000000ULL) {\r\nint r = niu_mif_interrupt(np);\r\nif (r)\r\nerr = r;\r\n}\r\nif (v2) {\r\nif (v2 & 0x01ef) {\r\nint r = niu_mac_interrupt(np);\r\nif (r)\r\nerr = r;\r\n}\r\nif (v2 & 0x0210) {\r\nint r = niu_device_error(np);\r\nif (r)\r\nerr = r;\r\n}\r\n}\r\nif (err)\r\nniu_enable_interrupts(np, 0);\r\nreturn err;\r\n}\r\nstatic void niu_rxchan_intr(struct niu *np, struct rx_ring_info *rp,\r\nint ldn)\r\n{\r\nstruct rxdma_mailbox *mbox = rp->mbox;\r\nu64 stat_write, stat = le64_to_cpup(&mbox->rx_dma_ctl_stat);\r\nstat_write = (RX_DMA_CTL_STAT_RCRTHRES |\r\nRX_DMA_CTL_STAT_RCRTO);\r\nnw64(RX_DMA_CTL_STAT(rp->rx_channel), stat_write);\r\nnetif_printk(np, intr, KERN_DEBUG, np->dev,\r\n"%s() stat[%llx]\n", __func__, (unsigned long long)stat);\r\n}\r\nstatic void niu_txchan_intr(struct niu *np, struct tx_ring_info *rp,\r\nint ldn)\r\n{\r\nrp->tx_cs = nr64(TX_CS(rp->tx_channel));\r\nnetif_printk(np, intr, KERN_DEBUG, np->dev,\r\n"%s() cs[%llx]\n", __func__, (unsigned long long)rp->tx_cs);\r\n}\r\nstatic void __niu_fastpath_interrupt(struct niu *np, int ldg, u64 v0)\r\n{\r\nstruct niu_parent *parent = np->parent;\r\nu32 rx_vec, tx_vec;\r\nint i;\r\ntx_vec = (v0 >> 32);\r\nrx_vec = (v0 & 0xffffffff);\r\nfor (i = 0; i < np->num_rx_rings; i++) {\r\nstruct rx_ring_info *rp = &np->rx_rings[i];\r\nint ldn = LDN_RXDMA(rp->rx_channel);\r\nif (parent->ldg_map[ldn] != ldg)\r\ncontinue;\r\nnw64(LD_IM0(ldn), LD_IM0_MASK);\r\nif (rx_vec & (1 << rp->rx_channel))\r\nniu_rxchan_intr(np, rp, ldn);\r\n}\r\nfor (i = 0; i < np->num_tx_rings; i++) {\r\nstruct tx_ring_info *rp = &np->tx_rings[i];\r\nint ldn = LDN_TXDMA(rp->tx_channel);\r\nif (parent->ldg_map[ldn] != ldg)\r\ncontinue;\r\nnw64(LD_IM0(ldn), LD_IM0_MASK);\r\nif (tx_vec & (1 << rp->tx_channel))\r\nniu_txchan_intr(np, rp, ldn);\r\n}\r\n}\r\nstatic void niu_schedule_napi(struct niu *np, struct niu_ldg *lp,\r\nu64 v0, u64 v1, u64 v2)\r\n{\r\nif (likely(napi_schedule_prep(&lp->napi))) {\r\nlp->v0 = v0;\r\nlp->v1 = v1;\r\nlp->v2 = v2;\r\n__niu_fastpath_interrupt(np, lp->ldg_num, v0);\r\n__napi_schedule(&lp->napi);\r\n}\r\n}\r\nstatic irqreturn_t niu_interrupt(int irq, void *dev_id)\r\n{\r\nstruct niu_ldg *lp = dev_id;\r\nstruct niu *np = lp->np;\r\nint ldg = lp->ldg_num;\r\nunsigned long flags;\r\nu64 v0, v1, v2;\r\nif (netif_msg_intr(np))\r\nprintk(KERN_DEBUG KBUILD_MODNAME ": " "%s() ldg[%p](%d)",\r\n__func__, lp, ldg);\r\nspin_lock_irqsave(&np->lock, flags);\r\nv0 = nr64(LDSV0(ldg));\r\nv1 = nr64(LDSV1(ldg));\r\nv2 = nr64(LDSV2(ldg));\r\nif (netif_msg_intr(np))\r\npr_cont(" v0[%llx] v1[%llx] v2[%llx]\n",\r\n(unsigned long long) v0,\r\n(unsigned long long) v1,\r\n(unsigned long long) v2);\r\nif (unlikely(!v0 && !v1 && !v2)) {\r\nspin_unlock_irqrestore(&np->lock, flags);\r\nreturn IRQ_NONE;\r\n}\r\nif (unlikely((v0 & ((u64)1 << LDN_MIF)) || v1 || v2)) {\r\nint err = niu_slowpath_interrupt(np, lp, v0, v1, v2);\r\nif (err)\r\ngoto out;\r\n}\r\nif (likely(v0 & ~((u64)1 << LDN_MIF)))\r\nniu_schedule_napi(np, lp, v0, v1, v2);\r\nelse\r\nniu_ldg_rearm(np, lp, 1);\r\nout:\r\nspin_unlock_irqrestore(&np->lock, flags);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void niu_free_rx_ring_info(struct niu *np, struct rx_ring_info *rp)\r\n{\r\nif (rp->mbox) {\r\nnp->ops->free_coherent(np->device,\r\nsizeof(struct rxdma_mailbox),\r\nrp->mbox, rp->mbox_dma);\r\nrp->mbox = NULL;\r\n}\r\nif (rp->rcr) {\r\nnp->ops->free_coherent(np->device,\r\nMAX_RCR_RING_SIZE * sizeof(__le64),\r\nrp->rcr, rp->rcr_dma);\r\nrp->rcr = NULL;\r\nrp->rcr_table_size = 0;\r\nrp->rcr_index = 0;\r\n}\r\nif (rp->rbr) {\r\nniu_rbr_free(np, rp);\r\nnp->ops->free_coherent(np->device,\r\nMAX_RBR_RING_SIZE * sizeof(__le32),\r\nrp->rbr, rp->rbr_dma);\r\nrp->rbr = NULL;\r\nrp->rbr_table_size = 0;\r\nrp->rbr_index = 0;\r\n}\r\nkfree(rp->rxhash);\r\nrp->rxhash = NULL;\r\n}\r\nstatic void niu_free_tx_ring_info(struct niu *np, struct tx_ring_info *rp)\r\n{\r\nif (rp->mbox) {\r\nnp->ops->free_coherent(np->device,\r\nsizeof(struct txdma_mailbox),\r\nrp->mbox, rp->mbox_dma);\r\nrp->mbox = NULL;\r\n}\r\nif (rp->descr) {\r\nint i;\r\nfor (i = 0; i < MAX_TX_RING_SIZE; i++) {\r\nif (rp->tx_buffs[i].skb)\r\n(void) release_tx_packet(np, rp, i);\r\n}\r\nnp->ops->free_coherent(np->device,\r\nMAX_TX_RING_SIZE * sizeof(__le64),\r\nrp->descr, rp->descr_dma);\r\nrp->descr = NULL;\r\nrp->pending = 0;\r\nrp->prod = 0;\r\nrp->cons = 0;\r\nrp->wrap_bit = 0;\r\n}\r\n}\r\nstatic void niu_free_channels(struct niu *np)\r\n{\r\nint i;\r\nif (np->rx_rings) {\r\nfor (i = 0; i < np->num_rx_rings; i++) {\r\nstruct rx_ring_info *rp = &np->rx_rings[i];\r\nniu_free_rx_ring_info(np, rp);\r\n}\r\nkfree(np->rx_rings);\r\nnp->rx_rings = NULL;\r\nnp->num_rx_rings = 0;\r\n}\r\nif (np->tx_rings) {\r\nfor (i = 0; i < np->num_tx_rings; i++) {\r\nstruct tx_ring_info *rp = &np->tx_rings[i];\r\nniu_free_tx_ring_info(np, rp);\r\n}\r\nkfree(np->tx_rings);\r\nnp->tx_rings = NULL;\r\nnp->num_tx_rings = 0;\r\n}\r\n}\r\nstatic int niu_alloc_rx_ring_info(struct niu *np,\r\nstruct rx_ring_info *rp)\r\n{\r\nBUILD_BUG_ON(sizeof(struct rxdma_mailbox) != 64);\r\nrp->rxhash = kcalloc(MAX_RBR_RING_SIZE, sizeof(struct page *),\r\nGFP_KERNEL);\r\nif (!rp->rxhash)\r\nreturn -ENOMEM;\r\nrp->mbox = np->ops->alloc_coherent(np->device,\r\nsizeof(struct rxdma_mailbox),\r\n&rp->mbox_dma, GFP_KERNEL);\r\nif (!rp->mbox)\r\nreturn -ENOMEM;\r\nif ((unsigned long)rp->mbox & (64UL - 1)) {\r\nnetdev_err(np->dev, "Coherent alloc gives misaligned RXDMA mailbox %p\n",\r\nrp->mbox);\r\nreturn -EINVAL;\r\n}\r\nrp->rcr = np->ops->alloc_coherent(np->device,\r\nMAX_RCR_RING_SIZE * sizeof(__le64),\r\n&rp->rcr_dma, GFP_KERNEL);\r\nif (!rp->rcr)\r\nreturn -ENOMEM;\r\nif ((unsigned long)rp->rcr & (64UL - 1)) {\r\nnetdev_err(np->dev, "Coherent alloc gives misaligned RXDMA RCR table %p\n",\r\nrp->rcr);\r\nreturn -EINVAL;\r\n}\r\nrp->rcr_table_size = MAX_RCR_RING_SIZE;\r\nrp->rcr_index = 0;\r\nrp->rbr = np->ops->alloc_coherent(np->device,\r\nMAX_RBR_RING_SIZE * sizeof(__le32),\r\n&rp->rbr_dma, GFP_KERNEL);\r\nif (!rp->rbr)\r\nreturn -ENOMEM;\r\nif ((unsigned long)rp->rbr & (64UL - 1)) {\r\nnetdev_err(np->dev, "Coherent alloc gives misaligned RXDMA RBR table %p\n",\r\nrp->rbr);\r\nreturn -EINVAL;\r\n}\r\nrp->rbr_table_size = MAX_RBR_RING_SIZE;\r\nrp->rbr_index = 0;\r\nrp->rbr_pending = 0;\r\nreturn 0;\r\n}\r\nstatic void niu_set_max_burst(struct niu *np, struct tx_ring_info *rp)\r\n{\r\nint mtu = np->dev->mtu;\r\nrp->max_burst = mtu + 32;\r\nif (rp->max_burst > 4096)\r\nrp->max_burst = 4096;\r\n}\r\nstatic int niu_alloc_tx_ring_info(struct niu *np,\r\nstruct tx_ring_info *rp)\r\n{\r\nBUILD_BUG_ON(sizeof(struct txdma_mailbox) != 64);\r\nrp->mbox = np->ops->alloc_coherent(np->device,\r\nsizeof(struct txdma_mailbox),\r\n&rp->mbox_dma, GFP_KERNEL);\r\nif (!rp->mbox)\r\nreturn -ENOMEM;\r\nif ((unsigned long)rp->mbox & (64UL - 1)) {\r\nnetdev_err(np->dev, "Coherent alloc gives misaligned TXDMA mailbox %p\n",\r\nrp->mbox);\r\nreturn -EINVAL;\r\n}\r\nrp->descr = np->ops->alloc_coherent(np->device,\r\nMAX_TX_RING_SIZE * sizeof(__le64),\r\n&rp->descr_dma, GFP_KERNEL);\r\nif (!rp->descr)\r\nreturn -ENOMEM;\r\nif ((unsigned long)rp->descr & (64UL - 1)) {\r\nnetdev_err(np->dev, "Coherent alloc gives misaligned TXDMA descr table %p\n",\r\nrp->descr);\r\nreturn -EINVAL;\r\n}\r\nrp->pending = MAX_TX_RING_SIZE;\r\nrp->prod = 0;\r\nrp->cons = 0;\r\nrp->wrap_bit = 0;\r\nrp->mark_freq = rp->pending / 4;\r\nniu_set_max_burst(np, rp);\r\nreturn 0;\r\n}\r\nstatic void niu_size_rbr(struct niu *np, struct rx_ring_info *rp)\r\n{\r\nu16 bss;\r\nbss = min(PAGE_SHIFT, 15);\r\nrp->rbr_block_size = 1 << bss;\r\nrp->rbr_blocks_per_page = 1 << (PAGE_SHIFT-bss);\r\nrp->rbr_sizes[0] = 256;\r\nrp->rbr_sizes[1] = 1024;\r\nif (np->dev->mtu > ETH_DATA_LEN) {\r\nswitch (PAGE_SIZE) {\r\ncase 4 * 1024:\r\nrp->rbr_sizes[2] = 4096;\r\nbreak;\r\ndefault:\r\nrp->rbr_sizes[2] = 8192;\r\nbreak;\r\n}\r\n} else {\r\nrp->rbr_sizes[2] = 2048;\r\n}\r\nrp->rbr_sizes[3] = rp->rbr_block_size;\r\n}\r\nstatic int niu_alloc_channels(struct niu *np)\r\n{\r\nstruct niu_parent *parent = np->parent;\r\nint first_rx_channel, first_tx_channel;\r\nint num_rx_rings, num_tx_rings;\r\nstruct rx_ring_info *rx_rings;\r\nstruct tx_ring_info *tx_rings;\r\nint i, port, err;\r\nport = np->port;\r\nfirst_rx_channel = first_tx_channel = 0;\r\nfor (i = 0; i < port; i++) {\r\nfirst_rx_channel += parent->rxchan_per_port[i];\r\nfirst_tx_channel += parent->txchan_per_port[i];\r\n}\r\nnum_rx_rings = parent->rxchan_per_port[port];\r\nnum_tx_rings = parent->txchan_per_port[port];\r\nrx_rings = kcalloc(num_rx_rings, sizeof(struct rx_ring_info),\r\nGFP_KERNEL);\r\nerr = -ENOMEM;\r\nif (!rx_rings)\r\ngoto out_err;\r\nnp->num_rx_rings = num_rx_rings;\r\nsmp_wmb();\r\nnp->rx_rings = rx_rings;\r\nnetif_set_real_num_rx_queues(np->dev, num_rx_rings);\r\nfor (i = 0; i < np->num_rx_rings; i++) {\r\nstruct rx_ring_info *rp = &np->rx_rings[i];\r\nrp->np = np;\r\nrp->rx_channel = first_rx_channel + i;\r\nerr = niu_alloc_rx_ring_info(np, rp);\r\nif (err)\r\ngoto out_err;\r\nniu_size_rbr(np, rp);\r\nrp->nonsyn_window = 64;\r\nrp->nonsyn_threshold = rp->rcr_table_size - 64;\r\nrp->syn_window = 64;\r\nrp->syn_threshold = rp->rcr_table_size - 64;\r\nrp->rcr_pkt_threshold = 16;\r\nrp->rcr_timeout = 8;\r\nrp->rbr_kick_thresh = RBR_REFILL_MIN;\r\nif (rp->rbr_kick_thresh < rp->rbr_blocks_per_page)\r\nrp->rbr_kick_thresh = rp->rbr_blocks_per_page;\r\nerr = niu_rbr_fill(np, rp, GFP_KERNEL);\r\nif (err)\r\nreturn err;\r\n}\r\ntx_rings = kcalloc(num_tx_rings, sizeof(struct tx_ring_info),\r\nGFP_KERNEL);\r\nerr = -ENOMEM;\r\nif (!tx_rings)\r\ngoto out_err;\r\nnp->num_tx_rings = num_tx_rings;\r\nsmp_wmb();\r\nnp->tx_rings = tx_rings;\r\nnetif_set_real_num_tx_queues(np->dev, num_tx_rings);\r\nfor (i = 0; i < np->num_tx_rings; i++) {\r\nstruct tx_ring_info *rp = &np->tx_rings[i];\r\nrp->np = np;\r\nrp->tx_channel = first_tx_channel + i;\r\nerr = niu_alloc_tx_ring_info(np, rp);\r\nif (err)\r\ngoto out_err;\r\n}\r\nreturn 0;\r\nout_err:\r\nniu_free_channels(np);\r\nreturn err;\r\n}\r\nstatic int niu_tx_cs_sng_poll(struct niu *np, int channel)\r\n{\r\nint limit = 1000;\r\nwhile (--limit > 0) {\r\nu64 val = nr64(TX_CS(channel));\r\nif (val & TX_CS_SNG_STATE)\r\nreturn 0;\r\n}\r\nreturn -ENODEV;\r\n}\r\nstatic int niu_tx_channel_stop(struct niu *np, int channel)\r\n{\r\nu64 val = nr64(TX_CS(channel));\r\nval |= TX_CS_STOP_N_GO;\r\nnw64(TX_CS(channel), val);\r\nreturn niu_tx_cs_sng_poll(np, channel);\r\n}\r\nstatic int niu_tx_cs_reset_poll(struct niu *np, int channel)\r\n{\r\nint limit = 1000;\r\nwhile (--limit > 0) {\r\nu64 val = nr64(TX_CS(channel));\r\nif (!(val & TX_CS_RST))\r\nreturn 0;\r\n}\r\nreturn -ENODEV;\r\n}\r\nstatic int niu_tx_channel_reset(struct niu *np, int channel)\r\n{\r\nu64 val = nr64(TX_CS(channel));\r\nint err;\r\nval |= TX_CS_RST;\r\nnw64(TX_CS(channel), val);\r\nerr = niu_tx_cs_reset_poll(np, channel);\r\nif (!err)\r\nnw64(TX_RING_KICK(channel), 0);\r\nreturn err;\r\n}\r\nstatic int niu_tx_channel_lpage_init(struct niu *np, int channel)\r\n{\r\nu64 val;\r\nnw64(TX_LOG_MASK1(channel), 0);\r\nnw64(TX_LOG_VAL1(channel), 0);\r\nnw64(TX_LOG_MASK2(channel), 0);\r\nnw64(TX_LOG_VAL2(channel), 0);\r\nnw64(TX_LOG_PAGE_RELO1(channel), 0);\r\nnw64(TX_LOG_PAGE_RELO2(channel), 0);\r\nnw64(TX_LOG_PAGE_HDL(channel), 0);\r\nval = (u64)np->port << TX_LOG_PAGE_VLD_FUNC_SHIFT;\r\nval |= (TX_LOG_PAGE_VLD_PAGE0 | TX_LOG_PAGE_VLD_PAGE1);\r\nnw64(TX_LOG_PAGE_VLD(channel), val);\r\nreturn 0;\r\n}\r\nstatic void niu_txc_enable_port(struct niu *np, int on)\r\n{\r\nunsigned long flags;\r\nu64 val, mask;\r\nniu_lock_parent(np, flags);\r\nval = nr64(TXC_CONTROL);\r\nmask = (u64)1 << np->port;\r\nif (on) {\r\nval |= TXC_CONTROL_ENABLE | mask;\r\n} else {\r\nval &= ~mask;\r\nif ((val & ~TXC_CONTROL_ENABLE) == 0)\r\nval &= ~TXC_CONTROL_ENABLE;\r\n}\r\nnw64(TXC_CONTROL, val);\r\nniu_unlock_parent(np, flags);\r\n}\r\nstatic void niu_txc_set_imask(struct niu *np, u64 imask)\r\n{\r\nunsigned long flags;\r\nu64 val;\r\nniu_lock_parent(np, flags);\r\nval = nr64(TXC_INT_MASK);\r\nval &= ~TXC_INT_MASK_VAL(np->port);\r\nval |= (imask << TXC_INT_MASK_VAL_SHIFT(np->port));\r\nniu_unlock_parent(np, flags);\r\n}\r\nstatic void niu_txc_port_dma_enable(struct niu *np, int on)\r\n{\r\nu64 val = 0;\r\nif (on) {\r\nint i;\r\nfor (i = 0; i < np->num_tx_rings; i++)\r\nval |= (1 << np->tx_rings[i].tx_channel);\r\n}\r\nnw64(TXC_PORT_DMA(np->port), val);\r\n}\r\nstatic int niu_init_one_tx_channel(struct niu *np, struct tx_ring_info *rp)\r\n{\r\nint err, channel = rp->tx_channel;\r\nu64 val, ring_len;\r\nerr = niu_tx_channel_stop(np, channel);\r\nif (err)\r\nreturn err;\r\nerr = niu_tx_channel_reset(np, channel);\r\nif (err)\r\nreturn err;\r\nerr = niu_tx_channel_lpage_init(np, channel);\r\nif (err)\r\nreturn err;\r\nnw64(TXC_DMA_MAX(channel), rp->max_burst);\r\nnw64(TX_ENT_MSK(channel), 0);\r\nif (rp->descr_dma & ~(TX_RNG_CFIG_STADDR_BASE |\r\nTX_RNG_CFIG_STADDR)) {\r\nnetdev_err(np->dev, "TX ring channel %d DMA addr (%llx) is not aligned\n",\r\nchannel, (unsigned long long)rp->descr_dma);\r\nreturn -EINVAL;\r\n}\r\nring_len = (rp->pending / 8);\r\nval = ((ring_len << TX_RNG_CFIG_LEN_SHIFT) |\r\nrp->descr_dma);\r\nnw64(TX_RNG_CFIG(channel), val);\r\nif (((rp->mbox_dma >> 32) & ~TXDMA_MBH_MBADDR) ||\r\n((u32)rp->mbox_dma & ~TXDMA_MBL_MBADDR)) {\r\nnetdev_err(np->dev, "TX ring channel %d MBOX addr (%llx) has invalid bits\n",\r\nchannel, (unsigned long long)rp->mbox_dma);\r\nreturn -EINVAL;\r\n}\r\nnw64(TXDMA_MBH(channel), rp->mbox_dma >> 32);\r\nnw64(TXDMA_MBL(channel), rp->mbox_dma & TXDMA_MBL_MBADDR);\r\nnw64(TX_CS(channel), 0);\r\nrp->last_pkt_cnt = 0;\r\nreturn 0;\r\n}\r\nstatic void niu_init_rdc_groups(struct niu *np)\r\n{\r\nstruct niu_rdc_tables *tp = &np->parent->rdc_group_cfg[np->port];\r\nint i, first_table_num = tp->first_table_num;\r\nfor (i = 0; i < tp->num_tables; i++) {\r\nstruct rdc_table *tbl = &tp->tables[i];\r\nint this_table = first_table_num + i;\r\nint slot;\r\nfor (slot = 0; slot < NIU_RDC_TABLE_SLOTS; slot++)\r\nnw64(RDC_TBL(this_table, slot),\r\ntbl->rxdma_channel[slot]);\r\n}\r\nnw64(DEF_RDC(np->port), np->parent->rdc_default[np->port]);\r\n}\r\nstatic void niu_init_drr_weight(struct niu *np)\r\n{\r\nint type = phy_decode(np->parent->port_phy, np->port);\r\nu64 val;\r\nswitch (type) {\r\ncase PORT_TYPE_10G:\r\nval = PT_DRR_WEIGHT_DEFAULT_10G;\r\nbreak;\r\ncase PORT_TYPE_1G:\r\ndefault:\r\nval = PT_DRR_WEIGHT_DEFAULT_1G;\r\nbreak;\r\n}\r\nnw64(PT_DRR_WT(np->port), val);\r\n}\r\nstatic int niu_init_hostinfo(struct niu *np)\r\n{\r\nstruct niu_parent *parent = np->parent;\r\nstruct niu_rdc_tables *tp = &parent->rdc_group_cfg[np->port];\r\nint i, err, num_alt = niu_num_alt_addr(np);\r\nint first_rdc_table = tp->first_table_num;\r\nerr = niu_set_primary_mac_rdc_table(np, first_rdc_table, 1);\r\nif (err)\r\nreturn err;\r\nerr = niu_set_multicast_mac_rdc_table(np, first_rdc_table, 1);\r\nif (err)\r\nreturn err;\r\nfor (i = 0; i < num_alt; i++) {\r\nerr = niu_set_alt_mac_rdc_table(np, i, first_rdc_table, 1);\r\nif (err)\r\nreturn err;\r\n}\r\nreturn 0;\r\n}\r\nstatic int niu_rx_channel_reset(struct niu *np, int channel)\r\n{\r\nreturn niu_set_and_wait_clear(np, RXDMA_CFIG1(channel),\r\nRXDMA_CFIG1_RST, 1000, 10,\r\n"RXDMA_CFIG1");\r\n}\r\nstatic int niu_rx_channel_lpage_init(struct niu *np, int channel)\r\n{\r\nu64 val;\r\nnw64(RX_LOG_MASK1(channel), 0);\r\nnw64(RX_LOG_VAL1(channel), 0);\r\nnw64(RX_LOG_MASK2(channel), 0);\r\nnw64(RX_LOG_VAL2(channel), 0);\r\nnw64(RX_LOG_PAGE_RELO1(channel), 0);\r\nnw64(RX_LOG_PAGE_RELO2(channel), 0);\r\nnw64(RX_LOG_PAGE_HDL(channel), 0);\r\nval = (u64)np->port << RX_LOG_PAGE_VLD_FUNC_SHIFT;\r\nval |= (RX_LOG_PAGE_VLD_PAGE0 | RX_LOG_PAGE_VLD_PAGE1);\r\nnw64(RX_LOG_PAGE_VLD(channel), val);\r\nreturn 0;\r\n}\r\nstatic void niu_rx_channel_wred_init(struct niu *np, struct rx_ring_info *rp)\r\n{\r\nu64 val;\r\nval = (((u64)rp->nonsyn_window << RDC_RED_PARA_WIN_SHIFT) |\r\n((u64)rp->nonsyn_threshold << RDC_RED_PARA_THRE_SHIFT) |\r\n((u64)rp->syn_window << RDC_RED_PARA_WIN_SYN_SHIFT) |\r\n((u64)rp->syn_threshold << RDC_RED_PARA_THRE_SYN_SHIFT));\r\nnw64(RDC_RED_PARA(rp->rx_channel), val);\r\n}\r\nstatic int niu_compute_rbr_cfig_b(struct rx_ring_info *rp, u64 *ret)\r\n{\r\nu64 val = 0;\r\n*ret = 0;\r\nswitch (rp->rbr_block_size) {\r\ncase 4 * 1024:\r\nval |= (RBR_BLKSIZE_4K << RBR_CFIG_B_BLKSIZE_SHIFT);\r\nbreak;\r\ncase 8 * 1024:\r\nval |= (RBR_BLKSIZE_8K << RBR_CFIG_B_BLKSIZE_SHIFT);\r\nbreak;\r\ncase 16 * 1024:\r\nval |= (RBR_BLKSIZE_16K << RBR_CFIG_B_BLKSIZE_SHIFT);\r\nbreak;\r\ncase 32 * 1024:\r\nval |= (RBR_BLKSIZE_32K << RBR_CFIG_B_BLKSIZE_SHIFT);\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nval |= RBR_CFIG_B_VLD2;\r\nswitch (rp->rbr_sizes[2]) {\r\ncase 2 * 1024:\r\nval |= (RBR_BUFSZ2_2K << RBR_CFIG_B_BUFSZ2_SHIFT);\r\nbreak;\r\ncase 4 * 1024:\r\nval |= (RBR_BUFSZ2_4K << RBR_CFIG_B_BUFSZ2_SHIFT);\r\nbreak;\r\ncase 8 * 1024:\r\nval |= (RBR_BUFSZ2_8K << RBR_CFIG_B_BUFSZ2_SHIFT);\r\nbreak;\r\ncase 16 * 1024:\r\nval |= (RBR_BUFSZ2_16K << RBR_CFIG_B_BUFSZ2_SHIFT);\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nval |= RBR_CFIG_B_VLD1;\r\nswitch (rp->rbr_sizes[1]) {\r\ncase 1 * 1024:\r\nval |= (RBR_BUFSZ1_1K << RBR_CFIG_B_BUFSZ1_SHIFT);\r\nbreak;\r\ncase 2 * 1024:\r\nval |= (RBR_BUFSZ1_2K << RBR_CFIG_B_BUFSZ1_SHIFT);\r\nbreak;\r\ncase 4 * 1024:\r\nval |= (RBR_BUFSZ1_4K << RBR_CFIG_B_BUFSZ1_SHIFT);\r\nbreak;\r\ncase 8 * 1024:\r\nval |= (RBR_BUFSZ1_8K << RBR_CFIG_B_BUFSZ1_SHIFT);\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nval |= RBR_CFIG_B_VLD0;\r\nswitch (rp->rbr_sizes[0]) {\r\ncase 256:\r\nval |= (RBR_BUFSZ0_256 << RBR_CFIG_B_BUFSZ0_SHIFT);\r\nbreak;\r\ncase 512:\r\nval |= (RBR_BUFSZ0_512 << RBR_CFIG_B_BUFSZ0_SHIFT);\r\nbreak;\r\ncase 1 * 1024:\r\nval |= (RBR_BUFSZ0_1K << RBR_CFIG_B_BUFSZ0_SHIFT);\r\nbreak;\r\ncase 2 * 1024:\r\nval |= (RBR_BUFSZ0_2K << RBR_CFIG_B_BUFSZ0_SHIFT);\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\n*ret = val;\r\nreturn 0;\r\n}\r\nstatic int niu_enable_rx_channel(struct niu *np, int channel, int on)\r\n{\r\nu64 val = nr64(RXDMA_CFIG1(channel));\r\nint limit;\r\nif (on)\r\nval |= RXDMA_CFIG1_EN;\r\nelse\r\nval &= ~RXDMA_CFIG1_EN;\r\nnw64(RXDMA_CFIG1(channel), val);\r\nlimit = 1000;\r\nwhile (--limit > 0) {\r\nif (nr64(RXDMA_CFIG1(channel)) & RXDMA_CFIG1_QST)\r\nbreak;\r\nudelay(10);\r\n}\r\nif (limit <= 0)\r\nreturn -ENODEV;\r\nreturn 0;\r\n}\r\nstatic int niu_init_one_rx_channel(struct niu *np, struct rx_ring_info *rp)\r\n{\r\nint err, channel = rp->rx_channel;\r\nu64 val;\r\nerr = niu_rx_channel_reset(np, channel);\r\nif (err)\r\nreturn err;\r\nerr = niu_rx_channel_lpage_init(np, channel);\r\nif (err)\r\nreturn err;\r\nniu_rx_channel_wred_init(np, rp);\r\nnw64(RX_DMA_ENT_MSK(channel), RX_DMA_ENT_MSK_RBR_EMPTY);\r\nnw64(RX_DMA_CTL_STAT(channel),\r\n(RX_DMA_CTL_STAT_MEX |\r\nRX_DMA_CTL_STAT_RCRTHRES |\r\nRX_DMA_CTL_STAT_RCRTO |\r\nRX_DMA_CTL_STAT_RBR_EMPTY));\r\nnw64(RXDMA_CFIG1(channel), rp->mbox_dma >> 32);\r\nnw64(RXDMA_CFIG2(channel),\r\n((rp->mbox_dma & RXDMA_CFIG2_MBADDR_L) |\r\nRXDMA_CFIG2_FULL_HDR));\r\nnw64(RBR_CFIG_A(channel),\r\n((u64)rp->rbr_table_size << RBR_CFIG_A_LEN_SHIFT) |\r\n(rp->rbr_dma & (RBR_CFIG_A_STADDR_BASE | RBR_CFIG_A_STADDR)));\r\nerr = niu_compute_rbr_cfig_b(rp, &val);\r\nif (err)\r\nreturn err;\r\nnw64(RBR_CFIG_B(channel), val);\r\nnw64(RCRCFIG_A(channel),\r\n((u64)rp->rcr_table_size << RCRCFIG_A_LEN_SHIFT) |\r\n(rp->rcr_dma & (RCRCFIG_A_STADDR_BASE | RCRCFIG_A_STADDR)));\r\nnw64(RCRCFIG_B(channel),\r\n((u64)rp->rcr_pkt_threshold << RCRCFIG_B_PTHRES_SHIFT) |\r\nRCRCFIG_B_ENTOUT |\r\n((u64)rp->rcr_timeout << RCRCFIG_B_TIMEOUT_SHIFT));\r\nerr = niu_enable_rx_channel(np, channel, 1);\r\nif (err)\r\nreturn err;\r\nnw64(RBR_KICK(channel), rp->rbr_index);\r\nval = nr64(RX_DMA_CTL_STAT(channel));\r\nval |= RX_DMA_CTL_STAT_RBR_EMPTY;\r\nnw64(RX_DMA_CTL_STAT(channel), val);\r\nreturn 0;\r\n}\r\nstatic int niu_init_rx_channels(struct niu *np)\r\n{\r\nunsigned long flags;\r\nu64 seed = jiffies_64;\r\nint err, i;\r\nniu_lock_parent(np, flags);\r\nnw64(RX_DMA_CK_DIV, np->parent->rxdma_clock_divider);\r\nnw64(RED_RAN_INIT, RED_RAN_INIT_OPMODE | (seed & RED_RAN_INIT_VAL));\r\nniu_unlock_parent(np, flags);\r\nniu_init_rdc_groups(np);\r\nniu_init_drr_weight(np);\r\nerr = niu_init_hostinfo(np);\r\nif (err)\r\nreturn err;\r\nfor (i = 0; i < np->num_rx_rings; i++) {\r\nstruct rx_ring_info *rp = &np->rx_rings[i];\r\nerr = niu_init_one_rx_channel(np, rp);\r\nif (err)\r\nreturn err;\r\n}\r\nreturn 0;\r\n}\r\nstatic int niu_set_ip_frag_rule(struct niu *np)\r\n{\r\nstruct niu_parent *parent = np->parent;\r\nstruct niu_classifier *cp = &np->clas;\r\nstruct niu_tcam_entry *tp;\r\nint index, err;\r\nindex = cp->tcam_top;\r\ntp = &parent->tcam[index];\r\nmemset(tp, 0, sizeof(*tp));\r\ntp->key[1] = TCAM_V4KEY1_NOPORT;\r\ntp->key_mask[1] = TCAM_V4KEY1_NOPORT;\r\ntp->assoc_data = (TCAM_ASSOCDATA_TRES_USE_OFFSET |\r\n((u64)0 << TCAM_ASSOCDATA_OFFSET_SHIFT));\r\nerr = tcam_write(np, index, tp->key, tp->key_mask);\r\nif (err)\r\nreturn err;\r\nerr = tcam_assoc_write(np, index, tp->assoc_data);\r\nif (err)\r\nreturn err;\r\ntp->valid = 1;\r\ncp->tcam_valid_entries++;\r\nreturn 0;\r\n}\r\nstatic int niu_init_classifier_hw(struct niu *np)\r\n{\r\nstruct niu_parent *parent = np->parent;\r\nstruct niu_classifier *cp = &np->clas;\r\nint i, err;\r\nnw64(H1POLY, cp->h1_init);\r\nnw64(H2POLY, cp->h2_init);\r\nerr = niu_init_hostinfo(np);\r\nif (err)\r\nreturn err;\r\nfor (i = 0; i < ENET_VLAN_TBL_NUM_ENTRIES; i++) {\r\nstruct niu_vlan_rdc *vp = &cp->vlan_mappings[i];\r\nvlan_tbl_write(np, i, np->port,\r\nvp->vlan_pref, vp->rdc_num);\r\n}\r\nfor (i = 0; i < cp->num_alt_mac_mappings; i++) {\r\nstruct niu_altmac_rdc *ap = &cp->alt_mac_mappings[i];\r\nerr = niu_set_alt_mac_rdc_table(np, ap->alt_mac_num,\r\nap->rdc_num, ap->mac_pref);\r\nif (err)\r\nreturn err;\r\n}\r\nfor (i = CLASS_CODE_USER_PROG1; i <= CLASS_CODE_SCTP_IPV6; i++) {\r\nint index = i - CLASS_CODE_USER_PROG1;\r\nerr = niu_set_tcam_key(np, i, parent->tcam_key[index]);\r\nif (err)\r\nreturn err;\r\nerr = niu_set_flow_key(np, i, parent->flow_key[index]);\r\nif (err)\r\nreturn err;\r\n}\r\nerr = niu_set_ip_frag_rule(np);\r\nif (err)\r\nreturn err;\r\ntcam_enable(np, 1);\r\nreturn 0;\r\n}\r\nstatic int niu_zcp_write(struct niu *np, int index, u64 *data)\r\n{\r\nnw64(ZCP_RAM_DATA0, data[0]);\r\nnw64(ZCP_RAM_DATA1, data[1]);\r\nnw64(ZCP_RAM_DATA2, data[2]);\r\nnw64(ZCP_RAM_DATA3, data[3]);\r\nnw64(ZCP_RAM_DATA4, data[4]);\r\nnw64(ZCP_RAM_BE, ZCP_RAM_BE_VAL);\r\nnw64(ZCP_RAM_ACC,\r\n(ZCP_RAM_ACC_WRITE |\r\n(0 << ZCP_RAM_ACC_ZFCID_SHIFT) |\r\n(ZCP_RAM_SEL_CFIFO(np->port) << ZCP_RAM_ACC_RAM_SEL_SHIFT)));\r\nreturn niu_wait_bits_clear(np, ZCP_RAM_ACC, ZCP_RAM_ACC_BUSY,\r\n1000, 100);\r\n}\r\nstatic int niu_zcp_read(struct niu *np, int index, u64 *data)\r\n{\r\nint err;\r\nerr = niu_wait_bits_clear(np, ZCP_RAM_ACC, ZCP_RAM_ACC_BUSY,\r\n1000, 100);\r\nif (err) {\r\nnetdev_err(np->dev, "ZCP read busy won't clear, ZCP_RAM_ACC[%llx]\n",\r\n(unsigned long long)nr64(ZCP_RAM_ACC));\r\nreturn err;\r\n}\r\nnw64(ZCP_RAM_ACC,\r\n(ZCP_RAM_ACC_READ |\r\n(0 << ZCP_RAM_ACC_ZFCID_SHIFT) |\r\n(ZCP_RAM_SEL_CFIFO(np->port) << ZCP_RAM_ACC_RAM_SEL_SHIFT)));\r\nerr = niu_wait_bits_clear(np, ZCP_RAM_ACC, ZCP_RAM_ACC_BUSY,\r\n1000, 100);\r\nif (err) {\r\nnetdev_err(np->dev, "ZCP read busy2 won't clear, ZCP_RAM_ACC[%llx]\n",\r\n(unsigned long long)nr64(ZCP_RAM_ACC));\r\nreturn err;\r\n}\r\ndata[0] = nr64(ZCP_RAM_DATA0);\r\ndata[1] = nr64(ZCP_RAM_DATA1);\r\ndata[2] = nr64(ZCP_RAM_DATA2);\r\ndata[3] = nr64(ZCP_RAM_DATA3);\r\ndata[4] = nr64(ZCP_RAM_DATA4);\r\nreturn 0;\r\n}\r\nstatic void niu_zcp_cfifo_reset(struct niu *np)\r\n{\r\nu64 val = nr64(RESET_CFIFO);\r\nval |= RESET_CFIFO_RST(np->port);\r\nnw64(RESET_CFIFO, val);\r\nudelay(10);\r\nval &= ~RESET_CFIFO_RST(np->port);\r\nnw64(RESET_CFIFO, val);\r\n}\r\nstatic int niu_init_zcp(struct niu *np)\r\n{\r\nu64 data[5], rbuf[5];\r\nint i, max, err;\r\nif (np->parent->plat_type != PLAT_TYPE_NIU) {\r\nif (np->port == 0 || np->port == 1)\r\nmax = ATLAS_P0_P1_CFIFO_ENTRIES;\r\nelse\r\nmax = ATLAS_P2_P3_CFIFO_ENTRIES;\r\n} else\r\nmax = NIU_CFIFO_ENTRIES;\r\ndata[0] = 0;\r\ndata[1] = 0;\r\ndata[2] = 0;\r\ndata[3] = 0;\r\ndata[4] = 0;\r\nfor (i = 0; i < max; i++) {\r\nerr = niu_zcp_write(np, i, data);\r\nif (err)\r\nreturn err;\r\nerr = niu_zcp_read(np, i, rbuf);\r\nif (err)\r\nreturn err;\r\n}\r\nniu_zcp_cfifo_reset(np);\r\nnw64(CFIFO_ECC(np->port), 0);\r\nnw64(ZCP_INT_STAT, ZCP_INT_STAT_ALL);\r\n(void) nr64(ZCP_INT_STAT);\r\nnw64(ZCP_INT_MASK, ZCP_INT_MASK_ALL);\r\nreturn 0;\r\n}\r\nstatic void niu_ipp_write(struct niu *np, int index, u64 *data)\r\n{\r\nu64 val = nr64_ipp(IPP_CFIG);\r\nnw64_ipp(IPP_CFIG, val | IPP_CFIG_DFIFO_PIO_W);\r\nnw64_ipp(IPP_DFIFO_WR_PTR, index);\r\nnw64_ipp(IPP_DFIFO_WR0, data[0]);\r\nnw64_ipp(IPP_DFIFO_WR1, data[1]);\r\nnw64_ipp(IPP_DFIFO_WR2, data[2]);\r\nnw64_ipp(IPP_DFIFO_WR3, data[3]);\r\nnw64_ipp(IPP_DFIFO_WR4, data[4]);\r\nnw64_ipp(IPP_CFIG, val & ~IPP_CFIG_DFIFO_PIO_W);\r\n}\r\nstatic void niu_ipp_read(struct niu *np, int index, u64 *data)\r\n{\r\nnw64_ipp(IPP_DFIFO_RD_PTR, index);\r\ndata[0] = nr64_ipp(IPP_DFIFO_RD0);\r\ndata[1] = nr64_ipp(IPP_DFIFO_RD1);\r\ndata[2] = nr64_ipp(IPP_DFIFO_RD2);\r\ndata[3] = nr64_ipp(IPP_DFIFO_RD3);\r\ndata[4] = nr64_ipp(IPP_DFIFO_RD4);\r\n}\r\nstatic int niu_ipp_reset(struct niu *np)\r\n{\r\nreturn niu_set_and_wait_clear_ipp(np, IPP_CFIG, IPP_CFIG_SOFT_RST,\r\n1000, 100, "IPP_CFIG");\r\n}\r\nstatic int niu_init_ipp(struct niu *np)\r\n{\r\nu64 data[5], rbuf[5], val;\r\nint i, max, err;\r\nif (np->parent->plat_type != PLAT_TYPE_NIU) {\r\nif (np->port == 0 || np->port == 1)\r\nmax = ATLAS_P0_P1_DFIFO_ENTRIES;\r\nelse\r\nmax = ATLAS_P2_P3_DFIFO_ENTRIES;\r\n} else\r\nmax = NIU_DFIFO_ENTRIES;\r\ndata[0] = 0;\r\ndata[1] = 0;\r\ndata[2] = 0;\r\ndata[3] = 0;\r\ndata[4] = 0;\r\nfor (i = 0; i < max; i++) {\r\nniu_ipp_write(np, i, data);\r\nniu_ipp_read(np, i, rbuf);\r\n}\r\n(void) nr64_ipp(IPP_INT_STAT);\r\n(void) nr64_ipp(IPP_INT_STAT);\r\nerr = niu_ipp_reset(np);\r\nif (err)\r\nreturn err;\r\n(void) nr64_ipp(IPP_PKT_DIS);\r\n(void) nr64_ipp(IPP_BAD_CS_CNT);\r\n(void) nr64_ipp(IPP_ECC);\r\n(void) nr64_ipp(IPP_INT_STAT);\r\nnw64_ipp(IPP_MSK, ~IPP_MSK_ALL);\r\nval = nr64_ipp(IPP_CFIG);\r\nval &= ~IPP_CFIG_IP_MAX_PKT;\r\nval |= (IPP_CFIG_IPP_ENABLE |\r\nIPP_CFIG_DFIFO_ECC_EN |\r\nIPP_CFIG_DROP_BAD_CRC |\r\nIPP_CFIG_CKSUM_EN |\r\n(0x1ffff << IPP_CFIG_IP_MAX_PKT_SHIFT));\r\nnw64_ipp(IPP_CFIG, val);\r\nreturn 0;\r\n}\r\nstatic void niu_handle_led(struct niu *np, int status)\r\n{\r\nu64 val;\r\nval = nr64_mac(XMAC_CONFIG);\r\nif ((np->flags & NIU_FLAGS_10G) != 0 &&\r\n(np->flags & NIU_FLAGS_FIBER) != 0) {\r\nif (status) {\r\nval |= XMAC_CONFIG_LED_POLARITY;\r\nval &= ~XMAC_CONFIG_FORCE_LED_ON;\r\n} else {\r\nval |= XMAC_CONFIG_FORCE_LED_ON;\r\nval &= ~XMAC_CONFIG_LED_POLARITY;\r\n}\r\n}\r\nnw64_mac(XMAC_CONFIG, val);\r\n}\r\nstatic void niu_init_xif_xmac(struct niu *np)\r\n{\r\nstruct niu_link_config *lp = &np->link_config;\r\nu64 val;\r\nif (np->flags & NIU_FLAGS_XCVR_SERDES) {\r\nval = nr64(MIF_CONFIG);\r\nval |= MIF_CONFIG_ATCA_GE;\r\nnw64(MIF_CONFIG, val);\r\n}\r\nval = nr64_mac(XMAC_CONFIG);\r\nval &= ~XMAC_CONFIG_SEL_POR_CLK_SRC;\r\nval |= XMAC_CONFIG_TX_OUTPUT_EN;\r\nif (lp->loopback_mode == LOOPBACK_MAC) {\r\nval &= ~XMAC_CONFIG_SEL_POR_CLK_SRC;\r\nval |= XMAC_CONFIG_LOOPBACK;\r\n} else {\r\nval &= ~XMAC_CONFIG_LOOPBACK;\r\n}\r\nif (np->flags & NIU_FLAGS_10G) {\r\nval &= ~XMAC_CONFIG_LFS_DISABLE;\r\n} else {\r\nval |= XMAC_CONFIG_LFS_DISABLE;\r\nif (!(np->flags & NIU_FLAGS_FIBER) &&\r\n!(np->flags & NIU_FLAGS_XCVR_SERDES))\r\nval |= XMAC_CONFIG_1G_PCS_BYPASS;\r\nelse\r\nval &= ~XMAC_CONFIG_1G_PCS_BYPASS;\r\n}\r\nval &= ~XMAC_CONFIG_10G_XPCS_BYPASS;\r\nif (lp->active_speed == SPEED_100)\r\nval |= XMAC_CONFIG_SEL_CLK_25MHZ;\r\nelse\r\nval &= ~XMAC_CONFIG_SEL_CLK_25MHZ;\r\nnw64_mac(XMAC_CONFIG, val);\r\nval = nr64_mac(XMAC_CONFIG);\r\nval &= ~XMAC_CONFIG_MODE_MASK;\r\nif (np->flags & NIU_FLAGS_10G) {\r\nval |= XMAC_CONFIG_MODE_XGMII;\r\n} else {\r\nif (lp->active_speed == SPEED_1000)\r\nval |= XMAC_CONFIG_MODE_GMII;\r\nelse\r\nval |= XMAC_CONFIG_MODE_MII;\r\n}\r\nnw64_mac(XMAC_CONFIG, val);\r\n}\r\nstatic void niu_init_xif_bmac(struct niu *np)\r\n{\r\nstruct niu_link_config *lp = &np->link_config;\r\nu64 val;\r\nval = BMAC_XIF_CONFIG_TX_OUTPUT_EN;\r\nif (lp->loopback_mode == LOOPBACK_MAC)\r\nval |= BMAC_XIF_CONFIG_MII_LOOPBACK;\r\nelse\r\nval &= ~BMAC_XIF_CONFIG_MII_LOOPBACK;\r\nif (lp->active_speed == SPEED_1000)\r\nval |= BMAC_XIF_CONFIG_GMII_MODE;\r\nelse\r\nval &= ~BMAC_XIF_CONFIG_GMII_MODE;\r\nval &= ~(BMAC_XIF_CONFIG_LINK_LED |\r\nBMAC_XIF_CONFIG_LED_POLARITY);\r\nif (!(np->flags & NIU_FLAGS_10G) &&\r\n!(np->flags & NIU_FLAGS_FIBER) &&\r\nlp->active_speed == SPEED_100)\r\nval |= BMAC_XIF_CONFIG_25MHZ_CLOCK;\r\nelse\r\nval &= ~BMAC_XIF_CONFIG_25MHZ_CLOCK;\r\nnw64_mac(BMAC_XIF_CONFIG, val);\r\n}\r\nstatic void niu_init_xif(struct niu *np)\r\n{\r\nif (np->flags & NIU_FLAGS_XMAC)\r\nniu_init_xif_xmac(np);\r\nelse\r\nniu_init_xif_bmac(np);\r\n}\r\nstatic void niu_pcs_mii_reset(struct niu *np)\r\n{\r\nint limit = 1000;\r\nu64 val = nr64_pcs(PCS_MII_CTL);\r\nval |= PCS_MII_CTL_RST;\r\nnw64_pcs(PCS_MII_CTL, val);\r\nwhile ((--limit >= 0) && (val & PCS_MII_CTL_RST)) {\r\nudelay(100);\r\nval = nr64_pcs(PCS_MII_CTL);\r\n}\r\n}\r\nstatic void niu_xpcs_reset(struct niu *np)\r\n{\r\nint limit = 1000;\r\nu64 val = nr64_xpcs(XPCS_CONTROL1);\r\nval |= XPCS_CONTROL1_RESET;\r\nnw64_xpcs(XPCS_CONTROL1, val);\r\nwhile ((--limit >= 0) && (val & XPCS_CONTROL1_RESET)) {\r\nudelay(100);\r\nval = nr64_xpcs(XPCS_CONTROL1);\r\n}\r\n}\r\nstatic int niu_init_pcs(struct niu *np)\r\n{\r\nstruct niu_link_config *lp = &np->link_config;\r\nu64 val;\r\nswitch (np->flags & (NIU_FLAGS_10G |\r\nNIU_FLAGS_FIBER |\r\nNIU_FLAGS_XCVR_SERDES)) {\r\ncase NIU_FLAGS_FIBER:\r\nnw64_pcs(PCS_CONF, PCS_CONF_MASK | PCS_CONF_ENABLE);\r\nnw64_pcs(PCS_DPATH_MODE, 0);\r\nniu_pcs_mii_reset(np);\r\nbreak;\r\ncase NIU_FLAGS_10G:\r\ncase NIU_FLAGS_10G | NIU_FLAGS_FIBER:\r\ncase NIU_FLAGS_10G | NIU_FLAGS_XCVR_SERDES:\r\nif (!(np->flags & NIU_FLAGS_XMAC))\r\nreturn -EINVAL;\r\nval = nr64_mac(XMAC_CONFIG);\r\nval &= ~XMAC_CONFIG_10G_XPCS_BYPASS;\r\nnw64_mac(XMAC_CONFIG, val);\r\nniu_xpcs_reset(np);\r\nval = nr64_xpcs(XPCS_CONTROL1);\r\nif (lp->loopback_mode == LOOPBACK_PHY)\r\nval |= XPCS_CONTROL1_LOOPBACK;\r\nelse\r\nval &= ~XPCS_CONTROL1_LOOPBACK;\r\nnw64_xpcs(XPCS_CONTROL1, val);\r\nnw64_xpcs(XPCS_DESKEW_ERR_CNT, 0);\r\n(void) nr64_xpcs(XPCS_SYMERR_CNT01);\r\n(void) nr64_xpcs(XPCS_SYMERR_CNT23);\r\nbreak;\r\ncase NIU_FLAGS_XCVR_SERDES:\r\nniu_pcs_mii_reset(np);\r\nnw64_pcs(PCS_CONF, PCS_CONF_MASK | PCS_CONF_ENABLE);\r\nnw64_pcs(PCS_DPATH_MODE, 0);\r\nbreak;\r\ncase 0:\r\ncase NIU_FLAGS_XCVR_SERDES | NIU_FLAGS_FIBER:\r\nnw64_pcs(PCS_DPATH_MODE, PCS_DPATH_MODE_MII);\r\nniu_pcs_mii_reset(np);\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int niu_reset_tx_xmac(struct niu *np)\r\n{\r\nreturn niu_set_and_wait_clear_mac(np, XTXMAC_SW_RST,\r\n(XTXMAC_SW_RST_REG_RS |\r\nXTXMAC_SW_RST_SOFT_RST),\r\n1000, 100, "XTXMAC_SW_RST");\r\n}\r\nstatic int niu_reset_tx_bmac(struct niu *np)\r\n{\r\nint limit;\r\nnw64_mac(BTXMAC_SW_RST, BTXMAC_SW_RST_RESET);\r\nlimit = 1000;\r\nwhile (--limit >= 0) {\r\nif (!(nr64_mac(BTXMAC_SW_RST) & BTXMAC_SW_RST_RESET))\r\nbreak;\r\nudelay(100);\r\n}\r\nif (limit < 0) {\r\ndev_err(np->device, "Port %u TX BMAC would not reset, BTXMAC_SW_RST[%llx]\n",\r\nnp->port,\r\n(unsigned long long) nr64_mac(BTXMAC_SW_RST));\r\nreturn -ENODEV;\r\n}\r\nreturn 0;\r\n}\r\nstatic int niu_reset_tx_mac(struct niu *np)\r\n{\r\nif (np->flags & NIU_FLAGS_XMAC)\r\nreturn niu_reset_tx_xmac(np);\r\nelse\r\nreturn niu_reset_tx_bmac(np);\r\n}\r\nstatic void niu_init_tx_xmac(struct niu *np, u64 min, u64 max)\r\n{\r\nu64 val;\r\nval = nr64_mac(XMAC_MIN);\r\nval &= ~(XMAC_MIN_TX_MIN_PKT_SIZE |\r\nXMAC_MIN_RX_MIN_PKT_SIZE);\r\nval |= (min << XMAC_MIN_RX_MIN_PKT_SIZE_SHFT);\r\nval |= (min << XMAC_MIN_TX_MIN_PKT_SIZE_SHFT);\r\nnw64_mac(XMAC_MIN, val);\r\nnw64_mac(XMAC_MAX, max);\r\nnw64_mac(XTXMAC_STAT_MSK, ~(u64)0);\r\nval = nr64_mac(XMAC_IPG);\r\nif (np->flags & NIU_FLAGS_10G) {\r\nval &= ~XMAC_IPG_IPG_XGMII;\r\nval |= (IPG_12_15_XGMII << XMAC_IPG_IPG_XGMII_SHIFT);\r\n} else {\r\nval &= ~XMAC_IPG_IPG_MII_GMII;\r\nval |= (IPG_12_MII_GMII << XMAC_IPG_IPG_MII_GMII_SHIFT);\r\n}\r\nnw64_mac(XMAC_IPG, val);\r\nval = nr64_mac(XMAC_CONFIG);\r\nval &= ~(XMAC_CONFIG_ALWAYS_NO_CRC |\r\nXMAC_CONFIG_STRETCH_MODE |\r\nXMAC_CONFIG_VAR_MIN_IPG_EN |\r\nXMAC_CONFIG_TX_ENABLE);\r\nnw64_mac(XMAC_CONFIG, val);\r\nnw64_mac(TXMAC_FRM_CNT, 0);\r\nnw64_mac(TXMAC_BYTE_CNT, 0);\r\n}\r\nstatic void niu_init_tx_bmac(struct niu *np, u64 min, u64 max)\r\n{\r\nu64 val;\r\nnw64_mac(BMAC_MIN_FRAME, min);\r\nnw64_mac(BMAC_MAX_FRAME, max);\r\nnw64_mac(BTXMAC_STATUS_MASK, ~(u64)0);\r\nnw64_mac(BMAC_CTRL_TYPE, 0x8808);\r\nnw64_mac(BMAC_PREAMBLE_SIZE, 7);\r\nval = nr64_mac(BTXMAC_CONFIG);\r\nval &= ~(BTXMAC_CONFIG_FCS_DISABLE |\r\nBTXMAC_CONFIG_ENABLE);\r\nnw64_mac(BTXMAC_CONFIG, val);\r\n}\r\nstatic void niu_init_tx_mac(struct niu *np)\r\n{\r\nu64 min, max;\r\nmin = 64;\r\nif (np->dev->mtu > ETH_DATA_LEN)\r\nmax = 9216;\r\nelse\r\nmax = 1522;\r\nBUG_ON(min & 0x7);\r\nif (np->flags & NIU_FLAGS_XMAC)\r\nniu_init_tx_xmac(np, min, max);\r\nelse\r\nniu_init_tx_bmac(np, min, max);\r\n}\r\nstatic int niu_reset_rx_xmac(struct niu *np)\r\n{\r\nint limit;\r\nnw64_mac(XRXMAC_SW_RST,\r\nXRXMAC_SW_RST_REG_RS | XRXMAC_SW_RST_SOFT_RST);\r\nlimit = 1000;\r\nwhile (--limit >= 0) {\r\nif (!(nr64_mac(XRXMAC_SW_RST) & (XRXMAC_SW_RST_REG_RS |\r\nXRXMAC_SW_RST_SOFT_RST)))\r\nbreak;\r\nudelay(100);\r\n}\r\nif (limit < 0) {\r\ndev_err(np->device, "Port %u RX XMAC would not reset, XRXMAC_SW_RST[%llx]\n",\r\nnp->port,\r\n(unsigned long long) nr64_mac(XRXMAC_SW_RST));\r\nreturn -ENODEV;\r\n}\r\nreturn 0;\r\n}\r\nstatic int niu_reset_rx_bmac(struct niu *np)\r\n{\r\nint limit;\r\nnw64_mac(BRXMAC_SW_RST, BRXMAC_SW_RST_RESET);\r\nlimit = 1000;\r\nwhile (--limit >= 0) {\r\nif (!(nr64_mac(BRXMAC_SW_RST) & BRXMAC_SW_RST_RESET))\r\nbreak;\r\nudelay(100);\r\n}\r\nif (limit < 0) {\r\ndev_err(np->device, "Port %u RX BMAC would not reset, BRXMAC_SW_RST[%llx]\n",\r\nnp->port,\r\n(unsigned long long) nr64_mac(BRXMAC_SW_RST));\r\nreturn -ENODEV;\r\n}\r\nreturn 0;\r\n}\r\nstatic int niu_reset_rx_mac(struct niu *np)\r\n{\r\nif (np->flags & NIU_FLAGS_XMAC)\r\nreturn niu_reset_rx_xmac(np);\r\nelse\r\nreturn niu_reset_rx_bmac(np);\r\n}\r\nstatic void niu_init_rx_xmac(struct niu *np)\r\n{\r\nstruct niu_parent *parent = np->parent;\r\nstruct niu_rdc_tables *tp = &parent->rdc_group_cfg[np->port];\r\nint first_rdc_table = tp->first_table_num;\r\nunsigned long i;\r\nu64 val;\r\nnw64_mac(XMAC_ADD_FILT0, 0);\r\nnw64_mac(XMAC_ADD_FILT1, 0);\r\nnw64_mac(XMAC_ADD_FILT2, 0);\r\nnw64_mac(XMAC_ADD_FILT12_MASK, 0);\r\nnw64_mac(XMAC_ADD_FILT00_MASK, 0);\r\nfor (i = 0; i < MAC_NUM_HASH; i++)\r\nnw64_mac(XMAC_HASH_TBL(i), 0);\r\nnw64_mac(XRXMAC_STAT_MSK, ~(u64)0);\r\nniu_set_primary_mac_rdc_table(np, first_rdc_table, 1);\r\nniu_set_multicast_mac_rdc_table(np, first_rdc_table, 1);\r\nval = nr64_mac(XMAC_CONFIG);\r\nval &= ~(XMAC_CONFIG_RX_MAC_ENABLE |\r\nXMAC_CONFIG_PROMISCUOUS |\r\nXMAC_CONFIG_PROMISC_GROUP |\r\nXMAC_CONFIG_ERR_CHK_DIS |\r\nXMAC_CONFIG_RX_CRC_CHK_DIS |\r\nXMAC_CONFIG_RESERVED_MULTICAST |\r\nXMAC_CONFIG_RX_CODEV_CHK_DIS |\r\nXMAC_CONFIG_ADDR_FILTER_EN |\r\nXMAC_CONFIG_RCV_PAUSE_ENABLE |\r\nXMAC_CONFIG_STRIP_CRC |\r\nXMAC_CONFIG_PASS_FLOW_CTRL |\r\nXMAC_CONFIG_MAC2IPP_PKT_CNT_EN);\r\nval |= (XMAC_CONFIG_HASH_FILTER_EN);\r\nnw64_mac(XMAC_CONFIG, val);\r\nnw64_mac(RXMAC_BT_CNT, 0);\r\nnw64_mac(RXMAC_BC_FRM_CNT, 0);\r\nnw64_mac(RXMAC_MC_FRM_CNT, 0);\r\nnw64_mac(RXMAC_FRAG_CNT, 0);\r\nnw64_mac(RXMAC_HIST_CNT1, 0);\r\nnw64_mac(RXMAC_HIST_CNT2, 0);\r\nnw64_mac(RXMAC_HIST_CNT3, 0);\r\nnw64_mac(RXMAC_HIST_CNT4, 0);\r\nnw64_mac(RXMAC_HIST_CNT5, 0);\r\nnw64_mac(RXMAC_HIST_CNT6, 0);\r\nnw64_mac(RXMAC_HIST_CNT7, 0);\r\nnw64_mac(RXMAC_MPSZER_CNT, 0);\r\nnw64_mac(RXMAC_CRC_ER_CNT, 0);\r\nnw64_mac(RXMAC_CD_VIO_CNT, 0);\r\nnw64_mac(LINK_FAULT_CNT, 0);\r\n}\r\nstatic void niu_init_rx_bmac(struct niu *np)\r\n{\r\nstruct niu_parent *parent = np->parent;\r\nstruct niu_rdc_tables *tp = &parent->rdc_group_cfg[np->port];\r\nint first_rdc_table = tp->first_table_num;\r\nunsigned long i;\r\nu64 val;\r\nnw64_mac(BMAC_ADD_FILT0, 0);\r\nnw64_mac(BMAC_ADD_FILT1, 0);\r\nnw64_mac(BMAC_ADD_FILT2, 0);\r\nnw64_mac(BMAC_ADD_FILT12_MASK, 0);\r\nnw64_mac(BMAC_ADD_FILT00_MASK, 0);\r\nfor (i = 0; i < MAC_NUM_HASH; i++)\r\nnw64_mac(BMAC_HASH_TBL(i), 0);\r\nniu_set_primary_mac_rdc_table(np, first_rdc_table, 1);\r\nniu_set_multicast_mac_rdc_table(np, first_rdc_table, 1);\r\nnw64_mac(BRXMAC_STATUS_MASK, ~(u64)0);\r\nval = nr64_mac(BRXMAC_CONFIG);\r\nval &= ~(BRXMAC_CONFIG_ENABLE |\r\nBRXMAC_CONFIG_STRIP_PAD |\r\nBRXMAC_CONFIG_STRIP_FCS |\r\nBRXMAC_CONFIG_PROMISC |\r\nBRXMAC_CONFIG_PROMISC_GRP |\r\nBRXMAC_CONFIG_ADDR_FILT_EN |\r\nBRXMAC_CONFIG_DISCARD_DIS);\r\nval |= (BRXMAC_CONFIG_HASH_FILT_EN);\r\nnw64_mac(BRXMAC_CONFIG, val);\r\nval = nr64_mac(BMAC_ADDR_CMPEN);\r\nval |= BMAC_ADDR_CMPEN_EN0;\r\nnw64_mac(BMAC_ADDR_CMPEN, val);\r\n}\r\nstatic void niu_init_rx_mac(struct niu *np)\r\n{\r\nniu_set_primary_mac(np, np->dev->dev_addr);\r\nif (np->flags & NIU_FLAGS_XMAC)\r\nniu_init_rx_xmac(np);\r\nelse\r\nniu_init_rx_bmac(np);\r\n}\r\nstatic void niu_enable_tx_xmac(struct niu *np, int on)\r\n{\r\nu64 val = nr64_mac(XMAC_CONFIG);\r\nif (on)\r\nval |= XMAC_CONFIG_TX_ENABLE;\r\nelse\r\nval &= ~XMAC_CONFIG_TX_ENABLE;\r\nnw64_mac(XMAC_CONFIG, val);\r\n}\r\nstatic void niu_enable_tx_bmac(struct niu *np, int on)\r\n{\r\nu64 val = nr64_mac(BTXMAC_CONFIG);\r\nif (on)\r\nval |= BTXMAC_CONFIG_ENABLE;\r\nelse\r\nval &= ~BTXMAC_CONFIG_ENABLE;\r\nnw64_mac(BTXMAC_CONFIG, val);\r\n}\r\nstatic void niu_enable_tx_mac(struct niu *np, int on)\r\n{\r\nif (np->flags & NIU_FLAGS_XMAC)\r\nniu_enable_tx_xmac(np, on);\r\nelse\r\nniu_enable_tx_bmac(np, on);\r\n}\r\nstatic void niu_enable_rx_xmac(struct niu *np, int on)\r\n{\r\nu64 val = nr64_mac(XMAC_CONFIG);\r\nval &= ~(XMAC_CONFIG_HASH_FILTER_EN |\r\nXMAC_CONFIG_PROMISCUOUS);\r\nif (np->flags & NIU_FLAGS_MCAST)\r\nval |= XMAC_CONFIG_HASH_FILTER_EN;\r\nif (np->flags & NIU_FLAGS_PROMISC)\r\nval |= XMAC_CONFIG_PROMISCUOUS;\r\nif (on)\r\nval |= XMAC_CONFIG_RX_MAC_ENABLE;\r\nelse\r\nval &= ~XMAC_CONFIG_RX_MAC_ENABLE;\r\nnw64_mac(XMAC_CONFIG, val);\r\n}\r\nstatic void niu_enable_rx_bmac(struct niu *np, int on)\r\n{\r\nu64 val = nr64_mac(BRXMAC_CONFIG);\r\nval &= ~(BRXMAC_CONFIG_HASH_FILT_EN |\r\nBRXMAC_CONFIG_PROMISC);\r\nif (np->flags & NIU_FLAGS_MCAST)\r\nval |= BRXMAC_CONFIG_HASH_FILT_EN;\r\nif (np->flags & NIU_FLAGS_PROMISC)\r\nval |= BRXMAC_CONFIG_PROMISC;\r\nif (on)\r\nval |= BRXMAC_CONFIG_ENABLE;\r\nelse\r\nval &= ~BRXMAC_CONFIG_ENABLE;\r\nnw64_mac(BRXMAC_CONFIG, val);\r\n}\r\nstatic void niu_enable_rx_mac(struct niu *np, int on)\r\n{\r\nif (np->flags & NIU_FLAGS_XMAC)\r\nniu_enable_rx_xmac(np, on);\r\nelse\r\nniu_enable_rx_bmac(np, on);\r\n}\r\nstatic int niu_init_mac(struct niu *np)\r\n{\r\nint err;\r\nniu_init_xif(np);\r\nerr = niu_init_pcs(np);\r\nif (err)\r\nreturn err;\r\nerr = niu_reset_tx_mac(np);\r\nif (err)\r\nreturn err;\r\nniu_init_tx_mac(np);\r\nerr = niu_reset_rx_mac(np);\r\nif (err)\r\nreturn err;\r\nniu_init_rx_mac(np);\r\nniu_init_tx_mac(np);\r\nniu_enable_tx_mac(np, 1);\r\nniu_enable_rx_mac(np, 1);\r\nreturn 0;\r\n}\r\nstatic void niu_stop_one_tx_channel(struct niu *np, struct tx_ring_info *rp)\r\n{\r\n(void) niu_tx_channel_stop(np, rp->tx_channel);\r\n}\r\nstatic void niu_stop_tx_channels(struct niu *np)\r\n{\r\nint i;\r\nfor (i = 0; i < np->num_tx_rings; i++) {\r\nstruct tx_ring_info *rp = &np->tx_rings[i];\r\nniu_stop_one_tx_channel(np, rp);\r\n}\r\n}\r\nstatic void niu_reset_one_tx_channel(struct niu *np, struct tx_ring_info *rp)\r\n{\r\n(void) niu_tx_channel_reset(np, rp->tx_channel);\r\n}\r\nstatic void niu_reset_tx_channels(struct niu *np)\r\n{\r\nint i;\r\nfor (i = 0; i < np->num_tx_rings; i++) {\r\nstruct tx_ring_info *rp = &np->tx_rings[i];\r\nniu_reset_one_tx_channel(np, rp);\r\n}\r\n}\r\nstatic void niu_stop_one_rx_channel(struct niu *np, struct rx_ring_info *rp)\r\n{\r\n(void) niu_enable_rx_channel(np, rp->rx_channel, 0);\r\n}\r\nstatic void niu_stop_rx_channels(struct niu *np)\r\n{\r\nint i;\r\nfor (i = 0; i < np->num_rx_rings; i++) {\r\nstruct rx_ring_info *rp = &np->rx_rings[i];\r\nniu_stop_one_rx_channel(np, rp);\r\n}\r\n}\r\nstatic void niu_reset_one_rx_channel(struct niu *np, struct rx_ring_info *rp)\r\n{\r\nint channel = rp->rx_channel;\r\n(void) niu_rx_channel_reset(np, channel);\r\nnw64(RX_DMA_ENT_MSK(channel), RX_DMA_ENT_MSK_ALL);\r\nnw64(RX_DMA_CTL_STAT(channel), 0);\r\n(void) niu_enable_rx_channel(np, channel, 0);\r\n}\r\nstatic void niu_reset_rx_channels(struct niu *np)\r\n{\r\nint i;\r\nfor (i = 0; i < np->num_rx_rings; i++) {\r\nstruct rx_ring_info *rp = &np->rx_rings[i];\r\nniu_reset_one_rx_channel(np, rp);\r\n}\r\n}\r\nstatic void niu_disable_ipp(struct niu *np)\r\n{\r\nu64 rd, wr, val;\r\nint limit;\r\nrd = nr64_ipp(IPP_DFIFO_RD_PTR);\r\nwr = nr64_ipp(IPP_DFIFO_WR_PTR);\r\nlimit = 100;\r\nwhile (--limit >= 0 && (rd != wr)) {\r\nrd = nr64_ipp(IPP_DFIFO_RD_PTR);\r\nwr = nr64_ipp(IPP_DFIFO_WR_PTR);\r\n}\r\nif (limit < 0 &&\r\n(rd != 0 && wr != 1)) {\r\nnetdev_err(np->dev, "IPP would not quiesce, rd_ptr[%llx] wr_ptr[%llx]\n",\r\n(unsigned long long)nr64_ipp(IPP_DFIFO_RD_PTR),\r\n(unsigned long long)nr64_ipp(IPP_DFIFO_WR_PTR));\r\n}\r\nval = nr64_ipp(IPP_CFIG);\r\nval &= ~(IPP_CFIG_IPP_ENABLE |\r\nIPP_CFIG_DFIFO_ECC_EN |\r\nIPP_CFIG_DROP_BAD_CRC |\r\nIPP_CFIG_CKSUM_EN);\r\nnw64_ipp(IPP_CFIG, val);\r\n(void) niu_ipp_reset(np);\r\n}\r\nstatic int niu_init_hw(struct niu *np)\r\n{\r\nint i, err;\r\nnetif_printk(np, ifup, KERN_DEBUG, np->dev, "Initialize TXC\n");\r\nniu_txc_enable_port(np, 1);\r\nniu_txc_port_dma_enable(np, 1);\r\nniu_txc_set_imask(np, 0);\r\nnetif_printk(np, ifup, KERN_DEBUG, np->dev, "Initialize TX channels\n");\r\nfor (i = 0; i < np->num_tx_rings; i++) {\r\nstruct tx_ring_info *rp = &np->tx_rings[i];\r\nerr = niu_init_one_tx_channel(np, rp);\r\nif (err)\r\nreturn err;\r\n}\r\nnetif_printk(np, ifup, KERN_DEBUG, np->dev, "Initialize RX channels\n");\r\nerr = niu_init_rx_channels(np);\r\nif (err)\r\ngoto out_uninit_tx_channels;\r\nnetif_printk(np, ifup, KERN_DEBUG, np->dev, "Initialize classifier\n");\r\nerr = niu_init_classifier_hw(np);\r\nif (err)\r\ngoto out_uninit_rx_channels;\r\nnetif_printk(np, ifup, KERN_DEBUG, np->dev, "Initialize ZCP\n");\r\nerr = niu_init_zcp(np);\r\nif (err)\r\ngoto out_uninit_rx_channels;\r\nnetif_printk(np, ifup, KERN_DEBUG, np->dev, "Initialize IPP\n");\r\nerr = niu_init_ipp(np);\r\nif (err)\r\ngoto out_uninit_rx_channels;\r\nnetif_printk(np, ifup, KERN_DEBUG, np->dev, "Initialize MAC\n");\r\nerr = niu_init_mac(np);\r\nif (err)\r\ngoto out_uninit_ipp;\r\nreturn 0;\r\nout_uninit_ipp:\r\nnetif_printk(np, ifup, KERN_DEBUG, np->dev, "Uninit IPP\n");\r\nniu_disable_ipp(np);\r\nout_uninit_rx_channels:\r\nnetif_printk(np, ifup, KERN_DEBUG, np->dev, "Uninit RX channels\n");\r\nniu_stop_rx_channels(np);\r\nniu_reset_rx_channels(np);\r\nout_uninit_tx_channels:\r\nnetif_printk(np, ifup, KERN_DEBUG, np->dev, "Uninit TX channels\n");\r\nniu_stop_tx_channels(np);\r\nniu_reset_tx_channels(np);\r\nreturn err;\r\n}\r\nstatic void niu_stop_hw(struct niu *np)\r\n{\r\nnetif_printk(np, ifdown, KERN_DEBUG, np->dev, "Disable interrupts\n");\r\nniu_enable_interrupts(np, 0);\r\nnetif_printk(np, ifdown, KERN_DEBUG, np->dev, "Disable RX MAC\n");\r\nniu_enable_rx_mac(np, 0);\r\nnetif_printk(np, ifdown, KERN_DEBUG, np->dev, "Disable IPP\n");\r\nniu_disable_ipp(np);\r\nnetif_printk(np, ifdown, KERN_DEBUG, np->dev, "Stop TX channels\n");\r\nniu_stop_tx_channels(np);\r\nnetif_printk(np, ifdown, KERN_DEBUG, np->dev, "Stop RX channels\n");\r\nniu_stop_rx_channels(np);\r\nnetif_printk(np, ifdown, KERN_DEBUG, np->dev, "Reset TX channels\n");\r\nniu_reset_tx_channels(np);\r\nnetif_printk(np, ifdown, KERN_DEBUG, np->dev, "Reset RX channels\n");\r\nniu_reset_rx_channels(np);\r\n}\r\nstatic void niu_set_irq_name(struct niu *np)\r\n{\r\nint port = np->port;\r\nint i, j = 1;\r\nsprintf(np->irq_name[0], "%s:MAC", np->dev->name);\r\nif (port == 0) {\r\nsprintf(np->irq_name[1], "%s:MIF", np->dev->name);\r\nsprintf(np->irq_name[2], "%s:SYSERR", np->dev->name);\r\nj = 3;\r\n}\r\nfor (i = 0; i < np->num_ldg - j; i++) {\r\nif (i < np->num_rx_rings)\r\nsprintf(np->irq_name[i+j], "%s-rx-%d",\r\nnp->dev->name, i);\r\nelse if (i < np->num_tx_rings + np->num_rx_rings)\r\nsprintf(np->irq_name[i+j], "%s-tx-%d", np->dev->name,\r\ni - np->num_rx_rings);\r\n}\r\n}\r\nstatic int niu_request_irq(struct niu *np)\r\n{\r\nint i, j, err;\r\nniu_set_irq_name(np);\r\nerr = 0;\r\nfor (i = 0; i < np->num_ldg; i++) {\r\nstruct niu_ldg *lp = &np->ldg[i];\r\nerr = request_irq(lp->irq, niu_interrupt, IRQF_SHARED,\r\nnp->irq_name[i], lp);\r\nif (err)\r\ngoto out_free_irqs;\r\n}\r\nreturn 0;\r\nout_free_irqs:\r\nfor (j = 0; j < i; j++) {\r\nstruct niu_ldg *lp = &np->ldg[j];\r\nfree_irq(lp->irq, lp);\r\n}\r\nreturn err;\r\n}\r\nstatic void niu_free_irq(struct niu *np)\r\n{\r\nint i;\r\nfor (i = 0; i < np->num_ldg; i++) {\r\nstruct niu_ldg *lp = &np->ldg[i];\r\nfree_irq(lp->irq, lp);\r\n}\r\n}\r\nstatic void niu_enable_napi(struct niu *np)\r\n{\r\nint i;\r\nfor (i = 0; i < np->num_ldg; i++)\r\nnapi_enable(&np->ldg[i].napi);\r\n}\r\nstatic void niu_disable_napi(struct niu *np)\r\n{\r\nint i;\r\nfor (i = 0; i < np->num_ldg; i++)\r\nnapi_disable(&np->ldg[i].napi);\r\n}\r\nstatic int niu_open(struct net_device *dev)\r\n{\r\nstruct niu *np = netdev_priv(dev);\r\nint err;\r\nnetif_carrier_off(dev);\r\nerr = niu_alloc_channels(np);\r\nif (err)\r\ngoto out_err;\r\nerr = niu_enable_interrupts(np, 0);\r\nif (err)\r\ngoto out_free_channels;\r\nerr = niu_request_irq(np);\r\nif (err)\r\ngoto out_free_channels;\r\nniu_enable_napi(np);\r\nspin_lock_irq(&np->lock);\r\nerr = niu_init_hw(np);\r\nif (!err) {\r\ninit_timer(&np->timer);\r\nnp->timer.expires = jiffies + HZ;\r\nnp->timer.data = (unsigned long) np;\r\nnp->timer.function = niu_timer;\r\nerr = niu_enable_interrupts(np, 1);\r\nif (err)\r\nniu_stop_hw(np);\r\n}\r\nspin_unlock_irq(&np->lock);\r\nif (err) {\r\nniu_disable_napi(np);\r\ngoto out_free_irq;\r\n}\r\nnetif_tx_start_all_queues(dev);\r\nif (np->link_config.loopback_mode != LOOPBACK_DISABLED)\r\nnetif_carrier_on(dev);\r\nadd_timer(&np->timer);\r\nreturn 0;\r\nout_free_irq:\r\nniu_free_irq(np);\r\nout_free_channels:\r\nniu_free_channels(np);\r\nout_err:\r\nreturn err;\r\n}\r\nstatic void niu_full_shutdown(struct niu *np, struct net_device *dev)\r\n{\r\ncancel_work_sync(&np->reset_task);\r\nniu_disable_napi(np);\r\nnetif_tx_stop_all_queues(dev);\r\ndel_timer_sync(&np->timer);\r\nspin_lock_irq(&np->lock);\r\nniu_stop_hw(np);\r\nspin_unlock_irq(&np->lock);\r\n}\r\nstatic int niu_close(struct net_device *dev)\r\n{\r\nstruct niu *np = netdev_priv(dev);\r\nniu_full_shutdown(np, dev);\r\nniu_free_irq(np);\r\nniu_free_channels(np);\r\nniu_handle_led(np, 0);\r\nreturn 0;\r\n}\r\nstatic void niu_sync_xmac_stats(struct niu *np)\r\n{\r\nstruct niu_xmac_stats *mp = &np->mac_stats.xmac;\r\nmp->tx_frames += nr64_mac(TXMAC_FRM_CNT);\r\nmp->tx_bytes += nr64_mac(TXMAC_BYTE_CNT);\r\nmp->rx_link_faults += nr64_mac(LINK_FAULT_CNT);\r\nmp->rx_align_errors += nr64_mac(RXMAC_ALIGN_ERR_CNT);\r\nmp->rx_frags += nr64_mac(RXMAC_FRAG_CNT);\r\nmp->rx_mcasts += nr64_mac(RXMAC_MC_FRM_CNT);\r\nmp->rx_bcasts += nr64_mac(RXMAC_BC_FRM_CNT);\r\nmp->rx_hist_cnt1 += nr64_mac(RXMAC_HIST_CNT1);\r\nmp->rx_hist_cnt2 += nr64_mac(RXMAC_HIST_CNT2);\r\nmp->rx_hist_cnt3 += nr64_mac(RXMAC_HIST_CNT3);\r\nmp->rx_hist_cnt4 += nr64_mac(RXMAC_HIST_CNT4);\r\nmp->rx_hist_cnt5 += nr64_mac(RXMAC_HIST_CNT5);\r\nmp->rx_hist_cnt6 += nr64_mac(RXMAC_HIST_CNT6);\r\nmp->rx_hist_cnt7 += nr64_mac(RXMAC_HIST_CNT7);\r\nmp->rx_octets += nr64_mac(RXMAC_BT_CNT);\r\nmp->rx_code_violations += nr64_mac(RXMAC_CD_VIO_CNT);\r\nmp->rx_len_errors += nr64_mac(RXMAC_MPSZER_CNT);\r\nmp->rx_crc_errors += nr64_mac(RXMAC_CRC_ER_CNT);\r\n}\r\nstatic void niu_sync_bmac_stats(struct niu *np)\r\n{\r\nstruct niu_bmac_stats *mp = &np->mac_stats.bmac;\r\nmp->tx_bytes += nr64_mac(BTXMAC_BYTE_CNT);\r\nmp->tx_frames += nr64_mac(BTXMAC_FRM_CNT);\r\nmp->rx_frames += nr64_mac(BRXMAC_FRAME_CNT);\r\nmp->rx_align_errors += nr64_mac(BRXMAC_ALIGN_ERR_CNT);\r\nmp->rx_crc_errors += nr64_mac(BRXMAC_ALIGN_ERR_CNT);\r\nmp->rx_len_errors += nr64_mac(BRXMAC_CODE_VIOL_ERR_CNT);\r\n}\r\nstatic void niu_sync_mac_stats(struct niu *np)\r\n{\r\nif (np->flags & NIU_FLAGS_XMAC)\r\nniu_sync_xmac_stats(np);\r\nelse\r\nniu_sync_bmac_stats(np);\r\n}\r\nstatic void niu_get_rx_stats(struct niu *np,\r\nstruct rtnl_link_stats64 *stats)\r\n{\r\nu64 pkts, dropped, errors, bytes;\r\nstruct rx_ring_info *rx_rings;\r\nint i;\r\npkts = dropped = errors = bytes = 0;\r\nrx_rings = ACCESS_ONCE(np->rx_rings);\r\nif (!rx_rings)\r\ngoto no_rings;\r\nfor (i = 0; i < np->num_rx_rings; i++) {\r\nstruct rx_ring_info *rp = &rx_rings[i];\r\nniu_sync_rx_discard_stats(np, rp, 0);\r\npkts += rp->rx_packets;\r\nbytes += rp->rx_bytes;\r\ndropped += rp->rx_dropped;\r\nerrors += rp->rx_errors;\r\n}\r\nno_rings:\r\nstats->rx_packets = pkts;\r\nstats->rx_bytes = bytes;\r\nstats->rx_dropped = dropped;\r\nstats->rx_errors = errors;\r\n}\r\nstatic void niu_get_tx_stats(struct niu *np,\r\nstruct rtnl_link_stats64 *stats)\r\n{\r\nu64 pkts, errors, bytes;\r\nstruct tx_ring_info *tx_rings;\r\nint i;\r\npkts = errors = bytes = 0;\r\ntx_rings = ACCESS_ONCE(np->tx_rings);\r\nif (!tx_rings)\r\ngoto no_rings;\r\nfor (i = 0; i < np->num_tx_rings; i++) {\r\nstruct tx_ring_info *rp = &tx_rings[i];\r\npkts += rp->tx_packets;\r\nbytes += rp->tx_bytes;\r\nerrors += rp->tx_errors;\r\n}\r\nno_rings:\r\nstats->tx_packets = pkts;\r\nstats->tx_bytes = bytes;\r\nstats->tx_errors = errors;\r\n}\r\nstatic struct rtnl_link_stats64 *niu_get_stats(struct net_device *dev,\r\nstruct rtnl_link_stats64 *stats)\r\n{\r\nstruct niu *np = netdev_priv(dev);\r\nif (netif_running(dev)) {\r\nniu_get_rx_stats(np, stats);\r\nniu_get_tx_stats(np, stats);\r\n}\r\nreturn stats;\r\n}\r\nstatic void niu_load_hash_xmac(struct niu *np, u16 *hash)\r\n{\r\nint i;\r\nfor (i = 0; i < 16; i++)\r\nnw64_mac(XMAC_HASH_TBL(i), hash[i]);\r\n}\r\nstatic void niu_load_hash_bmac(struct niu *np, u16 *hash)\r\n{\r\nint i;\r\nfor (i = 0; i < 16; i++)\r\nnw64_mac(BMAC_HASH_TBL(i), hash[i]);\r\n}\r\nstatic void niu_load_hash(struct niu *np, u16 *hash)\r\n{\r\nif (np->flags & NIU_FLAGS_XMAC)\r\nniu_load_hash_xmac(np, hash);\r\nelse\r\nniu_load_hash_bmac(np, hash);\r\n}\r\nstatic void niu_set_rx_mode(struct net_device *dev)\r\n{\r\nstruct niu *np = netdev_priv(dev);\r\nint i, alt_cnt, err;\r\nstruct netdev_hw_addr *ha;\r\nunsigned long flags;\r\nu16 hash[16] = { 0, };\r\nspin_lock_irqsave(&np->lock, flags);\r\nniu_enable_rx_mac(np, 0);\r\nnp->flags &= ~(NIU_FLAGS_MCAST | NIU_FLAGS_PROMISC);\r\nif (dev->flags & IFF_PROMISC)\r\nnp->flags |= NIU_FLAGS_PROMISC;\r\nif ((dev->flags & IFF_ALLMULTI) || (!netdev_mc_empty(dev)))\r\nnp->flags |= NIU_FLAGS_MCAST;\r\nalt_cnt = netdev_uc_count(dev);\r\nif (alt_cnt > niu_num_alt_addr(np)) {\r\nalt_cnt = 0;\r\nnp->flags |= NIU_FLAGS_PROMISC;\r\n}\r\nif (alt_cnt) {\r\nint index = 0;\r\nnetdev_for_each_uc_addr(ha, dev) {\r\nerr = niu_set_alt_mac(np, index, ha->addr);\r\nif (err)\r\nnetdev_warn(dev, "Error %d adding alt mac %d\n",\r\nerr, index);\r\nerr = niu_enable_alt_mac(np, index, 1);\r\nif (err)\r\nnetdev_warn(dev, "Error %d enabling alt mac %d\n",\r\nerr, index);\r\nindex++;\r\n}\r\n} else {\r\nint alt_start;\r\nif (np->flags & NIU_FLAGS_XMAC)\r\nalt_start = 0;\r\nelse\r\nalt_start = 1;\r\nfor (i = alt_start; i < niu_num_alt_addr(np); i++) {\r\nerr = niu_enable_alt_mac(np, i, 0);\r\nif (err)\r\nnetdev_warn(dev, "Error %d disabling alt mac %d\n",\r\nerr, i);\r\n}\r\n}\r\nif (dev->flags & IFF_ALLMULTI) {\r\nfor (i = 0; i < 16; i++)\r\nhash[i] = 0xffff;\r\n} else if (!netdev_mc_empty(dev)) {\r\nnetdev_for_each_mc_addr(ha, dev) {\r\nu32 crc = ether_crc_le(ETH_ALEN, ha->addr);\r\ncrc >>= 24;\r\nhash[crc >> 4] |= (1 << (15 - (crc & 0xf)));\r\n}\r\n}\r\nif (np->flags & NIU_FLAGS_MCAST)\r\nniu_load_hash(np, hash);\r\nniu_enable_rx_mac(np, 1);\r\nspin_unlock_irqrestore(&np->lock, flags);\r\n}\r\nstatic int niu_set_mac_addr(struct net_device *dev, void *p)\r\n{\r\nstruct niu *np = netdev_priv(dev);\r\nstruct sockaddr *addr = p;\r\nunsigned long flags;\r\nif (!is_valid_ether_addr(addr->sa_data))\r\nreturn -EADDRNOTAVAIL;\r\nmemcpy(dev->dev_addr, addr->sa_data, ETH_ALEN);\r\nif (!netif_running(dev))\r\nreturn 0;\r\nspin_lock_irqsave(&np->lock, flags);\r\nniu_enable_rx_mac(np, 0);\r\nniu_set_primary_mac(np, dev->dev_addr);\r\nniu_enable_rx_mac(np, 1);\r\nspin_unlock_irqrestore(&np->lock, flags);\r\nreturn 0;\r\n}\r\nstatic int niu_ioctl(struct net_device *dev, struct ifreq *ifr, int cmd)\r\n{\r\nreturn -EOPNOTSUPP;\r\n}\r\nstatic void niu_netif_stop(struct niu *np)\r\n{\r\nnp->dev->trans_start = jiffies;\r\nniu_disable_napi(np);\r\nnetif_tx_disable(np->dev);\r\n}\r\nstatic void niu_netif_start(struct niu *np)\r\n{\r\nnetif_tx_wake_all_queues(np->dev);\r\nniu_enable_napi(np);\r\nniu_enable_interrupts(np, 1);\r\n}\r\nstatic void niu_reset_buffers(struct niu *np)\r\n{\r\nint i, j, k, err;\r\nif (np->rx_rings) {\r\nfor (i = 0; i < np->num_rx_rings; i++) {\r\nstruct rx_ring_info *rp = &np->rx_rings[i];\r\nfor (j = 0, k = 0; j < MAX_RBR_RING_SIZE; j++) {\r\nstruct page *page;\r\npage = rp->rxhash[j];\r\nwhile (page) {\r\nstruct page *next =\r\n(struct page *) page->mapping;\r\nu64 base = page->index;\r\nbase = base >> RBR_DESCR_ADDR_SHIFT;\r\nrp->rbr[k++] = cpu_to_le32(base);\r\npage = next;\r\n}\r\n}\r\nfor (; k < MAX_RBR_RING_SIZE; k++) {\r\nerr = niu_rbr_add_page(np, rp, GFP_ATOMIC, k);\r\nif (unlikely(err))\r\nbreak;\r\n}\r\nrp->rbr_index = rp->rbr_table_size - 1;\r\nrp->rcr_index = 0;\r\nrp->rbr_pending = 0;\r\nrp->rbr_refill_pending = 0;\r\n}\r\n}\r\nif (np->tx_rings) {\r\nfor (i = 0; i < np->num_tx_rings; i++) {\r\nstruct tx_ring_info *rp = &np->tx_rings[i];\r\nfor (j = 0; j < MAX_TX_RING_SIZE; j++) {\r\nif (rp->tx_buffs[j].skb)\r\n(void) release_tx_packet(np, rp, j);\r\n}\r\nrp->pending = MAX_TX_RING_SIZE;\r\nrp->prod = 0;\r\nrp->cons = 0;\r\nrp->wrap_bit = 0;\r\n}\r\n}\r\n}\r\nstatic void niu_reset_task(struct work_struct *work)\r\n{\r\nstruct niu *np = container_of(work, struct niu, reset_task);\r\nunsigned long flags;\r\nint err;\r\nspin_lock_irqsave(&np->lock, flags);\r\nif (!netif_running(np->dev)) {\r\nspin_unlock_irqrestore(&np->lock, flags);\r\nreturn;\r\n}\r\nspin_unlock_irqrestore(&np->lock, flags);\r\ndel_timer_sync(&np->timer);\r\nniu_netif_stop(np);\r\nspin_lock_irqsave(&np->lock, flags);\r\nniu_stop_hw(np);\r\nspin_unlock_irqrestore(&np->lock, flags);\r\nniu_reset_buffers(np);\r\nspin_lock_irqsave(&np->lock, flags);\r\nerr = niu_init_hw(np);\r\nif (!err) {\r\nnp->timer.expires = jiffies + HZ;\r\nadd_timer(&np->timer);\r\nniu_netif_start(np);\r\n}\r\nspin_unlock_irqrestore(&np->lock, flags);\r\n}\r\nstatic void niu_tx_timeout(struct net_device *dev)\r\n{\r\nstruct niu *np = netdev_priv(dev);\r\ndev_err(np->device, "%s: Transmit timed out, resetting\n",\r\ndev->name);\r\nschedule_work(&np->reset_task);\r\n}\r\nstatic void niu_set_txd(struct tx_ring_info *rp, int index,\r\nu64 mapping, u64 len, u64 mark,\r\nu64 n_frags)\r\n{\r\n__le64 *desc = &rp->descr[index];\r\n*desc = cpu_to_le64(mark |\r\n(n_frags << TX_DESC_NUM_PTR_SHIFT) |\r\n(len << TX_DESC_TR_LEN_SHIFT) |\r\n(mapping & TX_DESC_SAD));\r\n}\r\nstatic u64 niu_compute_tx_flags(struct sk_buff *skb, struct ethhdr *ehdr,\r\nu64 pad_bytes, u64 len)\r\n{\r\nu16 eth_proto, eth_proto_inner;\r\nu64 csum_bits, l3off, ihl, ret;\r\nu8 ip_proto;\r\nint ipv6;\r\neth_proto = be16_to_cpu(ehdr->h_proto);\r\neth_proto_inner = eth_proto;\r\nif (eth_proto == ETH_P_8021Q) {\r\nstruct vlan_ethhdr *vp = (struct vlan_ethhdr *) ehdr;\r\n__be16 val = vp->h_vlan_encapsulated_proto;\r\neth_proto_inner = be16_to_cpu(val);\r\n}\r\nipv6 = ihl = 0;\r\nswitch (skb->protocol) {\r\ncase cpu_to_be16(ETH_P_IP):\r\nip_proto = ip_hdr(skb)->protocol;\r\nihl = ip_hdr(skb)->ihl;\r\nbreak;\r\ncase cpu_to_be16(ETH_P_IPV6):\r\nip_proto = ipv6_hdr(skb)->nexthdr;\r\nihl = (40 >> 2);\r\nipv6 = 1;\r\nbreak;\r\ndefault:\r\nip_proto = ihl = 0;\r\nbreak;\r\n}\r\ncsum_bits = TXHDR_CSUM_NONE;\r\nif (skb->ip_summed == CHECKSUM_PARTIAL) {\r\nu64 start, stuff;\r\ncsum_bits = (ip_proto == IPPROTO_TCP ?\r\nTXHDR_CSUM_TCP :\r\n(ip_proto == IPPROTO_UDP ?\r\nTXHDR_CSUM_UDP : TXHDR_CSUM_SCTP));\r\nstart = skb_checksum_start_offset(skb) -\r\n(pad_bytes + sizeof(struct tx_pkt_hdr));\r\nstuff = start + skb->csum_offset;\r\ncsum_bits |= (start / 2) << TXHDR_L4START_SHIFT;\r\ncsum_bits |= (stuff / 2) << TXHDR_L4STUFF_SHIFT;\r\n}\r\nl3off = skb_network_offset(skb) -\r\n(pad_bytes + sizeof(struct tx_pkt_hdr));\r\nret = (((pad_bytes / 2) << TXHDR_PAD_SHIFT) |\r\n(len << TXHDR_LEN_SHIFT) |\r\n((l3off / 2) << TXHDR_L3START_SHIFT) |\r\n(ihl << TXHDR_IHL_SHIFT) |\r\n((eth_proto_inner < ETH_P_802_3_MIN) ? TXHDR_LLC : 0) |\r\n((eth_proto == ETH_P_8021Q) ? TXHDR_VLAN : 0) |\r\n(ipv6 ? TXHDR_IP_VER : 0) |\r\ncsum_bits);\r\nreturn ret;\r\n}\r\nstatic netdev_tx_t niu_start_xmit(struct sk_buff *skb,\r\nstruct net_device *dev)\r\n{\r\nstruct niu *np = netdev_priv(dev);\r\nunsigned long align, headroom;\r\nstruct netdev_queue *txq;\r\nstruct tx_ring_info *rp;\r\nstruct tx_pkt_hdr *tp;\r\nunsigned int len, nfg;\r\nstruct ethhdr *ehdr;\r\nint prod, i, tlen;\r\nu64 mapping, mrk;\r\ni = skb_get_queue_mapping(skb);\r\nrp = &np->tx_rings[i];\r\ntxq = netdev_get_tx_queue(dev, i);\r\nif (niu_tx_avail(rp) <= (skb_shinfo(skb)->nr_frags + 1)) {\r\nnetif_tx_stop_queue(txq);\r\ndev_err(np->device, "%s: BUG! Tx ring full when queue awake!\n", dev->name);\r\nrp->tx_errors++;\r\nreturn NETDEV_TX_BUSY;\r\n}\r\nif (eth_skb_pad(skb))\r\ngoto out;\r\nlen = sizeof(struct tx_pkt_hdr) + 15;\r\nif (skb_headroom(skb) < len) {\r\nstruct sk_buff *skb_new;\r\nskb_new = skb_realloc_headroom(skb, len);\r\nif (!skb_new)\r\ngoto out_drop;\r\nkfree_skb(skb);\r\nskb = skb_new;\r\n} else\r\nskb_orphan(skb);\r\nalign = ((unsigned long) skb->data & (16 - 1));\r\nheadroom = align + sizeof(struct tx_pkt_hdr);\r\nehdr = (struct ethhdr *) skb->data;\r\ntp = (struct tx_pkt_hdr *) skb_push(skb, headroom);\r\nlen = skb->len - sizeof(struct tx_pkt_hdr);\r\ntp->flags = cpu_to_le64(niu_compute_tx_flags(skb, ehdr, align, len));\r\ntp->resv = 0;\r\nlen = skb_headlen(skb);\r\nmapping = np->ops->map_single(np->device, skb->data,\r\nlen, DMA_TO_DEVICE);\r\nprod = rp->prod;\r\nrp->tx_buffs[prod].skb = skb;\r\nrp->tx_buffs[prod].mapping = mapping;\r\nmrk = TX_DESC_SOP;\r\nif (++rp->mark_counter == rp->mark_freq) {\r\nrp->mark_counter = 0;\r\nmrk |= TX_DESC_MARK;\r\nrp->mark_pending++;\r\n}\r\ntlen = len;\r\nnfg = skb_shinfo(skb)->nr_frags;\r\nwhile (tlen > 0) {\r\ntlen -= MAX_TX_DESC_LEN;\r\nnfg++;\r\n}\r\nwhile (len > 0) {\r\nunsigned int this_len = len;\r\nif (this_len > MAX_TX_DESC_LEN)\r\nthis_len = MAX_TX_DESC_LEN;\r\nniu_set_txd(rp, prod, mapping, this_len, mrk, nfg);\r\nmrk = nfg = 0;\r\nprod = NEXT_TX(rp, prod);\r\nmapping += this_len;\r\nlen -= this_len;\r\n}\r\nfor (i = 0; i < skb_shinfo(skb)->nr_frags; i++) {\r\nconst skb_frag_t *frag = &skb_shinfo(skb)->frags[i];\r\nlen = skb_frag_size(frag);\r\nmapping = np->ops->map_page(np->device, skb_frag_page(frag),\r\nfrag->page_offset, len,\r\nDMA_TO_DEVICE);\r\nrp->tx_buffs[prod].skb = NULL;\r\nrp->tx_buffs[prod].mapping = mapping;\r\nniu_set_txd(rp, prod, mapping, len, 0, 0);\r\nprod = NEXT_TX(rp, prod);\r\n}\r\nif (prod < rp->prod)\r\nrp->wrap_bit ^= TX_RING_KICK_WRAP;\r\nrp->prod = prod;\r\nnw64(TX_RING_KICK(rp->tx_channel), rp->wrap_bit | (prod << 3));\r\nif (unlikely(niu_tx_avail(rp) <= (MAX_SKB_FRAGS + 1))) {\r\nnetif_tx_stop_queue(txq);\r\nif (niu_tx_avail(rp) > NIU_TX_WAKEUP_THRESH(rp))\r\nnetif_tx_wake_queue(txq);\r\n}\r\nout:\r\nreturn NETDEV_TX_OK;\r\nout_drop:\r\nrp->tx_errors++;\r\nkfree_skb(skb);\r\ngoto out;\r\n}\r\nstatic int niu_change_mtu(struct net_device *dev, int new_mtu)\r\n{\r\nstruct niu *np = netdev_priv(dev);\r\nint err, orig_jumbo, new_jumbo;\r\nif (new_mtu < 68 || new_mtu > NIU_MAX_MTU)\r\nreturn -EINVAL;\r\norig_jumbo = (dev->mtu > ETH_DATA_LEN);\r\nnew_jumbo = (new_mtu > ETH_DATA_LEN);\r\ndev->mtu = new_mtu;\r\nif (!netif_running(dev) ||\r\n(orig_jumbo == new_jumbo))\r\nreturn 0;\r\nniu_full_shutdown(np, dev);\r\nniu_free_channels(np);\r\nniu_enable_napi(np);\r\nerr = niu_alloc_channels(np);\r\nif (err)\r\nreturn err;\r\nspin_lock_irq(&np->lock);\r\nerr = niu_init_hw(np);\r\nif (!err) {\r\ninit_timer(&np->timer);\r\nnp->timer.expires = jiffies + HZ;\r\nnp->timer.data = (unsigned long) np;\r\nnp->timer.function = niu_timer;\r\nerr = niu_enable_interrupts(np, 1);\r\nif (err)\r\nniu_stop_hw(np);\r\n}\r\nspin_unlock_irq(&np->lock);\r\nif (!err) {\r\nnetif_tx_start_all_queues(dev);\r\nif (np->link_config.loopback_mode != LOOPBACK_DISABLED)\r\nnetif_carrier_on(dev);\r\nadd_timer(&np->timer);\r\n}\r\nreturn err;\r\n}\r\nstatic void niu_get_drvinfo(struct net_device *dev,\r\nstruct ethtool_drvinfo *info)\r\n{\r\nstruct niu *np = netdev_priv(dev);\r\nstruct niu_vpd *vpd = &np->vpd;\r\nstrlcpy(info->driver, DRV_MODULE_NAME, sizeof(info->driver));\r\nstrlcpy(info->version, DRV_MODULE_VERSION, sizeof(info->version));\r\nsnprintf(info->fw_version, sizeof(info->fw_version), "%d.%d",\r\nvpd->fcode_major, vpd->fcode_minor);\r\nif (np->parent->plat_type != PLAT_TYPE_NIU)\r\nstrlcpy(info->bus_info, pci_name(np->pdev),\r\nsizeof(info->bus_info));\r\n}\r\nstatic int niu_get_settings(struct net_device *dev, struct ethtool_cmd *cmd)\r\n{\r\nstruct niu *np = netdev_priv(dev);\r\nstruct niu_link_config *lp;\r\nlp = &np->link_config;\r\nmemset(cmd, 0, sizeof(*cmd));\r\ncmd->phy_address = np->phy_addr;\r\ncmd->supported = lp->supported;\r\ncmd->advertising = lp->active_advertising;\r\ncmd->autoneg = lp->active_autoneg;\r\nethtool_cmd_speed_set(cmd, lp->active_speed);\r\ncmd->duplex = lp->active_duplex;\r\ncmd->port = (np->flags & NIU_FLAGS_FIBER) ? PORT_FIBRE : PORT_TP;\r\ncmd->transceiver = (np->flags & NIU_FLAGS_XCVR_SERDES) ?\r\nXCVR_EXTERNAL : XCVR_INTERNAL;\r\nreturn 0;\r\n}\r\nstatic int niu_set_settings(struct net_device *dev, struct ethtool_cmd *cmd)\r\n{\r\nstruct niu *np = netdev_priv(dev);\r\nstruct niu_link_config *lp = &np->link_config;\r\nlp->advertising = cmd->advertising;\r\nlp->speed = ethtool_cmd_speed(cmd);\r\nlp->duplex = cmd->duplex;\r\nlp->autoneg = cmd->autoneg;\r\nreturn niu_init_link(np);\r\n}\r\nstatic u32 niu_get_msglevel(struct net_device *dev)\r\n{\r\nstruct niu *np = netdev_priv(dev);\r\nreturn np->msg_enable;\r\n}\r\nstatic void niu_set_msglevel(struct net_device *dev, u32 value)\r\n{\r\nstruct niu *np = netdev_priv(dev);\r\nnp->msg_enable = value;\r\n}\r\nstatic int niu_nway_reset(struct net_device *dev)\r\n{\r\nstruct niu *np = netdev_priv(dev);\r\nif (np->link_config.autoneg)\r\nreturn niu_init_link(np);\r\nreturn 0;\r\n}\r\nstatic int niu_get_eeprom_len(struct net_device *dev)\r\n{\r\nstruct niu *np = netdev_priv(dev);\r\nreturn np->eeprom_len;\r\n}\r\nstatic int niu_get_eeprom(struct net_device *dev,\r\nstruct ethtool_eeprom *eeprom, u8 *data)\r\n{\r\nstruct niu *np = netdev_priv(dev);\r\nu32 offset, len, val;\r\noffset = eeprom->offset;\r\nlen = eeprom->len;\r\nif (offset + len < offset)\r\nreturn -EINVAL;\r\nif (offset >= np->eeprom_len)\r\nreturn -EINVAL;\r\nif (offset + len > np->eeprom_len)\r\nlen = eeprom->len = np->eeprom_len - offset;\r\nif (offset & 3) {\r\nu32 b_offset, b_count;\r\nb_offset = offset & 3;\r\nb_count = 4 - b_offset;\r\nif (b_count > len)\r\nb_count = len;\r\nval = nr64(ESPC_NCR((offset - b_offset) / 4));\r\nmemcpy(data, ((char *)&val) + b_offset, b_count);\r\ndata += b_count;\r\nlen -= b_count;\r\noffset += b_count;\r\n}\r\nwhile (len >= 4) {\r\nval = nr64(ESPC_NCR(offset / 4));\r\nmemcpy(data, &val, 4);\r\ndata += 4;\r\nlen -= 4;\r\noffset += 4;\r\n}\r\nif (len) {\r\nval = nr64(ESPC_NCR(offset / 4));\r\nmemcpy(data, &val, len);\r\n}\r\nreturn 0;\r\n}\r\nstatic void niu_ethflow_to_l3proto(int flow_type, u8 *pid)\r\n{\r\nswitch (flow_type) {\r\ncase TCP_V4_FLOW:\r\ncase TCP_V6_FLOW:\r\n*pid = IPPROTO_TCP;\r\nbreak;\r\ncase UDP_V4_FLOW:\r\ncase UDP_V6_FLOW:\r\n*pid = IPPROTO_UDP;\r\nbreak;\r\ncase SCTP_V4_FLOW:\r\ncase SCTP_V6_FLOW:\r\n*pid = IPPROTO_SCTP;\r\nbreak;\r\ncase AH_V4_FLOW:\r\ncase AH_V6_FLOW:\r\n*pid = IPPROTO_AH;\r\nbreak;\r\ncase ESP_V4_FLOW:\r\ncase ESP_V6_FLOW:\r\n*pid = IPPROTO_ESP;\r\nbreak;\r\ndefault:\r\n*pid = 0;\r\nbreak;\r\n}\r\n}\r\nstatic int niu_class_to_ethflow(u64 class, int *flow_type)\r\n{\r\nswitch (class) {\r\ncase CLASS_CODE_TCP_IPV4:\r\n*flow_type = TCP_V4_FLOW;\r\nbreak;\r\ncase CLASS_CODE_UDP_IPV4:\r\n*flow_type = UDP_V4_FLOW;\r\nbreak;\r\ncase CLASS_CODE_AH_ESP_IPV4:\r\n*flow_type = AH_V4_FLOW;\r\nbreak;\r\ncase CLASS_CODE_SCTP_IPV4:\r\n*flow_type = SCTP_V4_FLOW;\r\nbreak;\r\ncase CLASS_CODE_TCP_IPV6:\r\n*flow_type = TCP_V6_FLOW;\r\nbreak;\r\ncase CLASS_CODE_UDP_IPV6:\r\n*flow_type = UDP_V6_FLOW;\r\nbreak;\r\ncase CLASS_CODE_AH_ESP_IPV6:\r\n*flow_type = AH_V6_FLOW;\r\nbreak;\r\ncase CLASS_CODE_SCTP_IPV6:\r\n*flow_type = SCTP_V6_FLOW;\r\nbreak;\r\ncase CLASS_CODE_USER_PROG1:\r\ncase CLASS_CODE_USER_PROG2:\r\ncase CLASS_CODE_USER_PROG3:\r\ncase CLASS_CODE_USER_PROG4:\r\n*flow_type = IP_USER_FLOW;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int niu_ethflow_to_class(int flow_type, u64 *class)\r\n{\r\nswitch (flow_type) {\r\ncase TCP_V4_FLOW:\r\n*class = CLASS_CODE_TCP_IPV4;\r\nbreak;\r\ncase UDP_V4_FLOW:\r\n*class = CLASS_CODE_UDP_IPV4;\r\nbreak;\r\ncase AH_ESP_V4_FLOW:\r\ncase AH_V4_FLOW:\r\ncase ESP_V4_FLOW:\r\n*class = CLASS_CODE_AH_ESP_IPV4;\r\nbreak;\r\ncase SCTP_V4_FLOW:\r\n*class = CLASS_CODE_SCTP_IPV4;\r\nbreak;\r\ncase TCP_V6_FLOW:\r\n*class = CLASS_CODE_TCP_IPV6;\r\nbreak;\r\ncase UDP_V6_FLOW:\r\n*class = CLASS_CODE_UDP_IPV6;\r\nbreak;\r\ncase AH_ESP_V6_FLOW:\r\ncase AH_V6_FLOW:\r\ncase ESP_V6_FLOW:\r\n*class = CLASS_CODE_AH_ESP_IPV6;\r\nbreak;\r\ncase SCTP_V6_FLOW:\r\n*class = CLASS_CODE_SCTP_IPV6;\r\nbreak;\r\ndefault:\r\nreturn 0;\r\n}\r\nreturn 1;\r\n}\r\nstatic u64 niu_flowkey_to_ethflow(u64 flow_key)\r\n{\r\nu64 ethflow = 0;\r\nif (flow_key & FLOW_KEY_L2DA)\r\nethflow |= RXH_L2DA;\r\nif (flow_key & FLOW_KEY_VLAN)\r\nethflow |= RXH_VLAN;\r\nif (flow_key & FLOW_KEY_IPSA)\r\nethflow |= RXH_IP_SRC;\r\nif (flow_key & FLOW_KEY_IPDA)\r\nethflow |= RXH_IP_DST;\r\nif (flow_key & FLOW_KEY_PROTO)\r\nethflow |= RXH_L3_PROTO;\r\nif (flow_key & (FLOW_KEY_L4_BYTE12 << FLOW_KEY_L4_0_SHIFT))\r\nethflow |= RXH_L4_B_0_1;\r\nif (flow_key & (FLOW_KEY_L4_BYTE12 << FLOW_KEY_L4_1_SHIFT))\r\nethflow |= RXH_L4_B_2_3;\r\nreturn ethflow;\r\n}\r\nstatic int niu_ethflow_to_flowkey(u64 ethflow, u64 *flow_key)\r\n{\r\nu64 key = 0;\r\nif (ethflow & RXH_L2DA)\r\nkey |= FLOW_KEY_L2DA;\r\nif (ethflow & RXH_VLAN)\r\nkey |= FLOW_KEY_VLAN;\r\nif (ethflow & RXH_IP_SRC)\r\nkey |= FLOW_KEY_IPSA;\r\nif (ethflow & RXH_IP_DST)\r\nkey |= FLOW_KEY_IPDA;\r\nif (ethflow & RXH_L3_PROTO)\r\nkey |= FLOW_KEY_PROTO;\r\nif (ethflow & RXH_L4_B_0_1)\r\nkey |= (FLOW_KEY_L4_BYTE12 << FLOW_KEY_L4_0_SHIFT);\r\nif (ethflow & RXH_L4_B_2_3)\r\nkey |= (FLOW_KEY_L4_BYTE12 << FLOW_KEY_L4_1_SHIFT);\r\n*flow_key = key;\r\nreturn 1;\r\n}\r\nstatic int niu_get_hash_opts(struct niu *np, struct ethtool_rxnfc *nfc)\r\n{\r\nu64 class;\r\nnfc->data = 0;\r\nif (!niu_ethflow_to_class(nfc->flow_type, &class))\r\nreturn -EINVAL;\r\nif (np->parent->tcam_key[class - CLASS_CODE_USER_PROG1] &\r\nTCAM_KEY_DISC)\r\nnfc->data = RXH_DISCARD;\r\nelse\r\nnfc->data = niu_flowkey_to_ethflow(np->parent->flow_key[class -\r\nCLASS_CODE_USER_PROG1]);\r\nreturn 0;\r\n}\r\nstatic void niu_get_ip4fs_from_tcam_key(struct niu_tcam_entry *tp,\r\nstruct ethtool_rx_flow_spec *fsp)\r\n{\r\nu32 tmp;\r\nu16 prt;\r\ntmp = (tp->key[3] & TCAM_V4KEY3_SADDR) >> TCAM_V4KEY3_SADDR_SHIFT;\r\nfsp->h_u.tcp_ip4_spec.ip4src = cpu_to_be32(tmp);\r\ntmp = (tp->key[3] & TCAM_V4KEY3_DADDR) >> TCAM_V4KEY3_DADDR_SHIFT;\r\nfsp->h_u.tcp_ip4_spec.ip4dst = cpu_to_be32(tmp);\r\ntmp = (tp->key_mask[3] & TCAM_V4KEY3_SADDR) >> TCAM_V4KEY3_SADDR_SHIFT;\r\nfsp->m_u.tcp_ip4_spec.ip4src = cpu_to_be32(tmp);\r\ntmp = (tp->key_mask[3] & TCAM_V4KEY3_DADDR) >> TCAM_V4KEY3_DADDR_SHIFT;\r\nfsp->m_u.tcp_ip4_spec.ip4dst = cpu_to_be32(tmp);\r\nfsp->h_u.tcp_ip4_spec.tos = (tp->key[2] & TCAM_V4KEY2_TOS) >>\r\nTCAM_V4KEY2_TOS_SHIFT;\r\nfsp->m_u.tcp_ip4_spec.tos = (tp->key_mask[2] & TCAM_V4KEY2_TOS) >>\r\nTCAM_V4KEY2_TOS_SHIFT;\r\nswitch (fsp->flow_type) {\r\ncase TCP_V4_FLOW:\r\ncase UDP_V4_FLOW:\r\ncase SCTP_V4_FLOW:\r\nprt = ((tp->key[2] & TCAM_V4KEY2_PORT_SPI) >>\r\nTCAM_V4KEY2_PORT_SPI_SHIFT) >> 16;\r\nfsp->h_u.tcp_ip4_spec.psrc = cpu_to_be16(prt);\r\nprt = ((tp->key[2] & TCAM_V4KEY2_PORT_SPI) >>\r\nTCAM_V4KEY2_PORT_SPI_SHIFT) & 0xffff;\r\nfsp->h_u.tcp_ip4_spec.pdst = cpu_to_be16(prt);\r\nprt = ((tp->key_mask[2] & TCAM_V4KEY2_PORT_SPI) >>\r\nTCAM_V4KEY2_PORT_SPI_SHIFT) >> 16;\r\nfsp->m_u.tcp_ip4_spec.psrc = cpu_to_be16(prt);\r\nprt = ((tp->key_mask[2] & TCAM_V4KEY2_PORT_SPI) >>\r\nTCAM_V4KEY2_PORT_SPI_SHIFT) & 0xffff;\r\nfsp->m_u.tcp_ip4_spec.pdst = cpu_to_be16(prt);\r\nbreak;\r\ncase AH_V4_FLOW:\r\ncase ESP_V4_FLOW:\r\ntmp = (tp->key[2] & TCAM_V4KEY2_PORT_SPI) >>\r\nTCAM_V4KEY2_PORT_SPI_SHIFT;\r\nfsp->h_u.ah_ip4_spec.spi = cpu_to_be32(tmp);\r\ntmp = (tp->key_mask[2] & TCAM_V4KEY2_PORT_SPI) >>\r\nTCAM_V4KEY2_PORT_SPI_SHIFT;\r\nfsp->m_u.ah_ip4_spec.spi = cpu_to_be32(tmp);\r\nbreak;\r\ncase IP_USER_FLOW:\r\ntmp = (tp->key[2] & TCAM_V4KEY2_PORT_SPI) >>\r\nTCAM_V4KEY2_PORT_SPI_SHIFT;\r\nfsp->h_u.usr_ip4_spec.l4_4_bytes = cpu_to_be32(tmp);\r\ntmp = (tp->key_mask[2] & TCAM_V4KEY2_PORT_SPI) >>\r\nTCAM_V4KEY2_PORT_SPI_SHIFT;\r\nfsp->m_u.usr_ip4_spec.l4_4_bytes = cpu_to_be32(tmp);\r\nfsp->h_u.usr_ip4_spec.proto =\r\n(tp->key[2] & TCAM_V4KEY2_PROTO) >>\r\nTCAM_V4KEY2_PROTO_SHIFT;\r\nfsp->m_u.usr_ip4_spec.proto =\r\n(tp->key_mask[2] & TCAM_V4KEY2_PROTO) >>\r\nTCAM_V4KEY2_PROTO_SHIFT;\r\nfsp->h_u.usr_ip4_spec.ip_ver = ETH_RX_NFC_IP4;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nstatic int niu_get_ethtool_tcam_entry(struct niu *np,\r\nstruct ethtool_rxnfc *nfc)\r\n{\r\nstruct niu_parent *parent = np->parent;\r\nstruct niu_tcam_entry *tp;\r\nstruct ethtool_rx_flow_spec *fsp = &nfc->fs;\r\nu16 idx;\r\nu64 class;\r\nint ret = 0;\r\nidx = tcam_get_index(np, (u16)nfc->fs.location);\r\ntp = &parent->tcam[idx];\r\nif (!tp->valid) {\r\nnetdev_info(np->dev, "niu%d: entry [%d] invalid for idx[%d]\n",\r\nparent->index, (u16)nfc->fs.location, idx);\r\nreturn -EINVAL;\r\n}\r\nclass = (tp->key[0] & TCAM_V4KEY0_CLASS_CODE) >>\r\nTCAM_V4KEY0_CLASS_CODE_SHIFT;\r\nret = niu_class_to_ethflow(class, &fsp->flow_type);\r\nif (ret < 0) {\r\nnetdev_info(np->dev, "niu%d: niu_class_to_ethflow failed\n",\r\nparent->index);\r\ngoto out;\r\n}\r\nif (fsp->flow_type == AH_V4_FLOW || fsp->flow_type == AH_V6_FLOW) {\r\nu32 proto = (tp->key[2] & TCAM_V4KEY2_PROTO) >>\r\nTCAM_V4KEY2_PROTO_SHIFT;\r\nif (proto == IPPROTO_ESP) {\r\nif (fsp->flow_type == AH_V4_FLOW)\r\nfsp->flow_type = ESP_V4_FLOW;\r\nelse\r\nfsp->flow_type = ESP_V6_FLOW;\r\n}\r\n}\r\nswitch (fsp->flow_type) {\r\ncase TCP_V4_FLOW:\r\ncase UDP_V4_FLOW:\r\ncase SCTP_V4_FLOW:\r\ncase AH_V4_FLOW:\r\ncase ESP_V4_FLOW:\r\nniu_get_ip4fs_from_tcam_key(tp, fsp);\r\nbreak;\r\ncase TCP_V6_FLOW:\r\ncase UDP_V6_FLOW:\r\ncase SCTP_V6_FLOW:\r\ncase AH_V6_FLOW:\r\ncase ESP_V6_FLOW:\r\nret = -EINVAL;\r\nbreak;\r\ncase IP_USER_FLOW:\r\nniu_get_ip4fs_from_tcam_key(tp, fsp);\r\nbreak;\r\ndefault:\r\nret = -EINVAL;\r\nbreak;\r\n}\r\nif (ret < 0)\r\ngoto out;\r\nif (tp->assoc_data & TCAM_ASSOCDATA_DISC)\r\nfsp->ring_cookie = RX_CLS_FLOW_DISC;\r\nelse\r\nfsp->ring_cookie = (tp->assoc_data & TCAM_ASSOCDATA_OFFSET) >>\r\nTCAM_ASSOCDATA_OFFSET_SHIFT;\r\nnfc->data = tcam_get_size(np);\r\nout:\r\nreturn ret;\r\n}\r\nstatic int niu_get_ethtool_tcam_all(struct niu *np,\r\nstruct ethtool_rxnfc *nfc,\r\nu32 *rule_locs)\r\n{\r\nstruct niu_parent *parent = np->parent;\r\nstruct niu_tcam_entry *tp;\r\nint i, idx, cnt;\r\nunsigned long flags;\r\nint ret = 0;\r\nnfc->data = tcam_get_size(np);\r\nniu_lock_parent(np, flags);\r\nfor (cnt = 0, i = 0; i < nfc->data; i++) {\r\nidx = tcam_get_index(np, i);\r\ntp = &parent->tcam[idx];\r\nif (!tp->valid)\r\ncontinue;\r\nif (cnt == nfc->rule_cnt) {\r\nret = -EMSGSIZE;\r\nbreak;\r\n}\r\nrule_locs[cnt] = i;\r\ncnt++;\r\n}\r\nniu_unlock_parent(np, flags);\r\nnfc->rule_cnt = cnt;\r\nreturn ret;\r\n}\r\nstatic int niu_get_nfc(struct net_device *dev, struct ethtool_rxnfc *cmd,\r\nu32 *rule_locs)\r\n{\r\nstruct niu *np = netdev_priv(dev);\r\nint ret = 0;\r\nswitch (cmd->cmd) {\r\ncase ETHTOOL_GRXFH:\r\nret = niu_get_hash_opts(np, cmd);\r\nbreak;\r\ncase ETHTOOL_GRXRINGS:\r\ncmd->data = np->num_rx_rings;\r\nbreak;\r\ncase ETHTOOL_GRXCLSRLCNT:\r\ncmd->rule_cnt = tcam_get_valid_entry_cnt(np);\r\nbreak;\r\ncase ETHTOOL_GRXCLSRULE:\r\nret = niu_get_ethtool_tcam_entry(np, cmd);\r\nbreak;\r\ncase ETHTOOL_GRXCLSRLALL:\r\nret = niu_get_ethtool_tcam_all(np, cmd, rule_locs);\r\nbreak;\r\ndefault:\r\nret = -EINVAL;\r\nbreak;\r\n}\r\nreturn ret;\r\n}\r\nstatic int niu_set_hash_opts(struct niu *np, struct ethtool_rxnfc *nfc)\r\n{\r\nu64 class;\r\nu64 flow_key = 0;\r\nunsigned long flags;\r\nif (!niu_ethflow_to_class(nfc->flow_type, &class))\r\nreturn -EINVAL;\r\nif (class < CLASS_CODE_USER_PROG1 ||\r\nclass > CLASS_CODE_SCTP_IPV6)\r\nreturn -EINVAL;\r\nif (nfc->data & RXH_DISCARD) {\r\nniu_lock_parent(np, flags);\r\nflow_key = np->parent->tcam_key[class -\r\nCLASS_CODE_USER_PROG1];\r\nflow_key |= TCAM_KEY_DISC;\r\nnw64(TCAM_KEY(class - CLASS_CODE_USER_PROG1), flow_key);\r\nnp->parent->tcam_key[class - CLASS_CODE_USER_PROG1] = flow_key;\r\nniu_unlock_parent(np, flags);\r\nreturn 0;\r\n} else {\r\nif (np->parent->tcam_key[class - CLASS_CODE_USER_PROG1] &\r\nTCAM_KEY_DISC) {\r\nniu_lock_parent(np, flags);\r\nflow_key = np->parent->tcam_key[class -\r\nCLASS_CODE_USER_PROG1];\r\nflow_key &= ~TCAM_KEY_DISC;\r\nnw64(TCAM_KEY(class - CLASS_CODE_USER_PROG1),\r\nflow_key);\r\nnp->parent->tcam_key[class - CLASS_CODE_USER_PROG1] =\r\nflow_key;\r\nniu_unlock_parent(np, flags);\r\n}\r\n}\r\nif (!niu_ethflow_to_flowkey(nfc->data, &flow_key))\r\nreturn -EINVAL;\r\nniu_lock_parent(np, flags);\r\nnw64(FLOW_KEY(class - CLASS_CODE_USER_PROG1), flow_key);\r\nnp->parent->flow_key[class - CLASS_CODE_USER_PROG1] = flow_key;\r\nniu_unlock_parent(np, flags);\r\nreturn 0;\r\n}\r\nstatic void niu_get_tcamkey_from_ip4fs(struct ethtool_rx_flow_spec *fsp,\r\nstruct niu_tcam_entry *tp,\r\nint l2_rdc_tab, u64 class)\r\n{\r\nu8 pid = 0;\r\nu32 sip, dip, sipm, dipm, spi, spim;\r\nu16 sport, dport, spm, dpm;\r\nsip = be32_to_cpu(fsp->h_u.tcp_ip4_spec.ip4src);\r\nsipm = be32_to_cpu(fsp->m_u.tcp_ip4_spec.ip4src);\r\ndip = be32_to_cpu(fsp->h_u.tcp_ip4_spec.ip4dst);\r\ndipm = be32_to_cpu(fsp->m_u.tcp_ip4_spec.ip4dst);\r\ntp->key[0] = class << TCAM_V4KEY0_CLASS_CODE_SHIFT;\r\ntp->key_mask[0] = TCAM_V4KEY0_CLASS_CODE;\r\ntp->key[1] = (u64)l2_rdc_tab << TCAM_V4KEY1_L2RDCNUM_SHIFT;\r\ntp->key_mask[1] = TCAM_V4KEY1_L2RDCNUM;\r\ntp->key[3] = (u64)sip << TCAM_V4KEY3_SADDR_SHIFT;\r\ntp->key[3] |= dip;\r\ntp->key_mask[3] = (u64)sipm << TCAM_V4KEY3_SADDR_SHIFT;\r\ntp->key_mask[3] |= dipm;\r\ntp->key[2] |= ((u64)fsp->h_u.tcp_ip4_spec.tos <<\r\nTCAM_V4KEY2_TOS_SHIFT);\r\ntp->key_mask[2] |= ((u64)fsp->m_u.tcp_ip4_spec.tos <<\r\nTCAM_V4KEY2_TOS_SHIFT);\r\nswitch (fsp->flow_type) {\r\ncase TCP_V4_FLOW:\r\ncase UDP_V4_FLOW:\r\ncase SCTP_V4_FLOW:\r\nsport = be16_to_cpu(fsp->h_u.tcp_ip4_spec.psrc);\r\nspm = be16_to_cpu(fsp->m_u.tcp_ip4_spec.psrc);\r\ndport = be16_to_cpu(fsp->h_u.tcp_ip4_spec.pdst);\r\ndpm = be16_to_cpu(fsp->m_u.tcp_ip4_spec.pdst);\r\ntp->key[2] |= (((u64)sport << 16) | dport);\r\ntp->key_mask[2] |= (((u64)spm << 16) | dpm);\r\nniu_ethflow_to_l3proto(fsp->flow_type, &pid);\r\nbreak;\r\ncase AH_V4_FLOW:\r\ncase ESP_V4_FLOW:\r\nspi = be32_to_cpu(fsp->h_u.ah_ip4_spec.spi);\r\nspim = be32_to_cpu(fsp->m_u.ah_ip4_spec.spi);\r\ntp->key[2] |= spi;\r\ntp->key_mask[2] |= spim;\r\nniu_ethflow_to_l3proto(fsp->flow_type, &pid);\r\nbreak;\r\ncase IP_USER_FLOW:\r\nspi = be32_to_cpu(fsp->h_u.usr_ip4_spec.l4_4_bytes);\r\nspim = be32_to_cpu(fsp->m_u.usr_ip4_spec.l4_4_bytes);\r\ntp->key[2] |= spi;\r\ntp->key_mask[2] |= spim;\r\npid = fsp->h_u.usr_ip4_spec.proto;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\ntp->key[2] |= ((u64)pid << TCAM_V4KEY2_PROTO_SHIFT);\r\nif (pid) {\r\ntp->key_mask[2] |= TCAM_V4KEY2_PROTO;\r\n}\r\n}\r\nstatic int niu_add_ethtool_tcam_entry(struct niu *np,\r\nstruct ethtool_rxnfc *nfc)\r\n{\r\nstruct niu_parent *parent = np->parent;\r\nstruct niu_tcam_entry *tp;\r\nstruct ethtool_rx_flow_spec *fsp = &nfc->fs;\r\nstruct niu_rdc_tables *rdc_table = &parent->rdc_group_cfg[np->port];\r\nint l2_rdc_table = rdc_table->first_table_num;\r\nu16 idx;\r\nu64 class;\r\nunsigned long flags;\r\nint err, ret;\r\nret = 0;\r\nidx = nfc->fs.location;\r\nif (idx >= tcam_get_size(np))\r\nreturn -EINVAL;\r\nif (fsp->flow_type == IP_USER_FLOW) {\r\nint i;\r\nint add_usr_cls = 0;\r\nstruct ethtool_usrip4_spec *uspec = &fsp->h_u.usr_ip4_spec;\r\nstruct ethtool_usrip4_spec *umask = &fsp->m_u.usr_ip4_spec;\r\nif (uspec->ip_ver != ETH_RX_NFC_IP4)\r\nreturn -EINVAL;\r\nniu_lock_parent(np, flags);\r\nfor (i = 0; i < NIU_L3_PROG_CLS; i++) {\r\nif (parent->l3_cls[i]) {\r\nif (uspec->proto == parent->l3_cls_pid[i]) {\r\nclass = parent->l3_cls[i];\r\nparent->l3_cls_refcnt[i]++;\r\nadd_usr_cls = 1;\r\nbreak;\r\n}\r\n} else {\r\nswitch (i) {\r\ncase 0:\r\nclass = CLASS_CODE_USER_PROG1;\r\nbreak;\r\ncase 1:\r\nclass = CLASS_CODE_USER_PROG2;\r\nbreak;\r\ncase 2:\r\nclass = CLASS_CODE_USER_PROG3;\r\nbreak;\r\ncase 3:\r\nclass = CLASS_CODE_USER_PROG4;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nret = tcam_user_ip_class_set(np, class, 0,\r\nuspec->proto,\r\nuspec->tos,\r\numask->tos);\r\nif (ret)\r\ngoto out;\r\nret = tcam_user_ip_class_enable(np, class, 1);\r\nif (ret)\r\ngoto out;\r\nparent->l3_cls[i] = class;\r\nparent->l3_cls_pid[i] = uspec->proto;\r\nparent->l3_cls_refcnt[i]++;\r\nadd_usr_cls = 1;\r\nbreak;\r\n}\r\n}\r\nif (!add_usr_cls) {\r\nnetdev_info(np->dev, "niu%d: %s(): Could not find/insert class for pid %d\n",\r\nparent->index, __func__, uspec->proto);\r\nret = -EINVAL;\r\ngoto out;\r\n}\r\nniu_unlock_parent(np, flags);\r\n} else {\r\nif (!niu_ethflow_to_class(fsp->flow_type, &class)) {\r\nreturn -EINVAL;\r\n}\r\n}\r\nniu_lock_parent(np, flags);\r\nidx = tcam_get_index(np, idx);\r\ntp = &parent->tcam[idx];\r\nmemset(tp, 0, sizeof(*tp));\r\nswitch (fsp->flow_type) {\r\ncase TCP_V4_FLOW:\r\ncase UDP_V4_FLOW:\r\ncase SCTP_V4_FLOW:\r\ncase AH_V4_FLOW:\r\ncase ESP_V4_FLOW:\r\nniu_get_tcamkey_from_ip4fs(fsp, tp, l2_rdc_table, class);\r\nbreak;\r\ncase TCP_V6_FLOW:\r\ncase UDP_V6_FLOW:\r\ncase SCTP_V6_FLOW:\r\ncase AH_V6_FLOW:\r\ncase ESP_V6_FLOW:\r\nnetdev_info(np->dev, "niu%d: In %s(): flow %d for IPv6 not implemented\n",\r\nparent->index, __func__, fsp->flow_type);\r\nret = -EINVAL;\r\ngoto out;\r\ncase IP_USER_FLOW:\r\nniu_get_tcamkey_from_ip4fs(fsp, tp, l2_rdc_table, class);\r\nbreak;\r\ndefault:\r\nnetdev_info(np->dev, "niu%d: In %s(): Unknown flow type %d\n",\r\nparent->index, __func__, fsp->flow_type);\r\nret = -EINVAL;\r\ngoto out;\r\n}\r\nif (fsp->ring_cookie == RX_CLS_FLOW_DISC) {\r\ntp->assoc_data = TCAM_ASSOCDATA_DISC;\r\n} else {\r\nif (fsp->ring_cookie >= np->num_rx_rings) {\r\nnetdev_info(np->dev, "niu%d: In %s(): Invalid RX ring %lld\n",\r\nparent->index, __func__,\r\n(long long)fsp->ring_cookie);\r\nret = -EINVAL;\r\ngoto out;\r\n}\r\ntp->assoc_data = (TCAM_ASSOCDATA_TRES_USE_OFFSET |\r\n(fsp->ring_cookie <<\r\nTCAM_ASSOCDATA_OFFSET_SHIFT));\r\n}\r\nerr = tcam_write(np, idx, tp->key, tp->key_mask);\r\nif (err) {\r\nret = -EINVAL;\r\ngoto out;\r\n}\r\nerr = tcam_assoc_write(np, idx, tp->assoc_data);\r\nif (err) {\r\nret = -EINVAL;\r\ngoto out;\r\n}\r\ntp->valid = 1;\r\nnp->clas.tcam_valid_entries++;\r\nout:\r\nniu_unlock_parent(np, flags);\r\nreturn ret;\r\n}\r\nstatic int niu_del_ethtool_tcam_entry(struct niu *np, u32 loc)\r\n{\r\nstruct niu_parent *parent = np->parent;\r\nstruct niu_tcam_entry *tp;\r\nu16 idx;\r\nunsigned long flags;\r\nu64 class;\r\nint ret = 0;\r\nif (loc >= tcam_get_size(np))\r\nreturn -EINVAL;\r\nniu_lock_parent(np, flags);\r\nidx = tcam_get_index(np, loc);\r\ntp = &parent->tcam[idx];\r\nclass = (tp->key[0] & TCAM_V4KEY0_CLASS_CODE) >>\r\nTCAM_V4KEY0_CLASS_CODE_SHIFT;\r\nif (class >= CLASS_CODE_USER_PROG1 && class <= CLASS_CODE_USER_PROG4) {\r\nint i;\r\nfor (i = 0; i < NIU_L3_PROG_CLS; i++) {\r\nif (parent->l3_cls[i] == class) {\r\nparent->l3_cls_refcnt[i]--;\r\nif (!parent->l3_cls_refcnt[i]) {\r\nret = tcam_user_ip_class_enable(np,\r\nclass,\r\n0);\r\nif (ret)\r\ngoto out;\r\nparent->l3_cls[i] = 0;\r\nparent->l3_cls_pid[i] = 0;\r\n}\r\nbreak;\r\n}\r\n}\r\nif (i == NIU_L3_PROG_CLS) {\r\nnetdev_info(np->dev, "niu%d: In %s(): Usr class 0x%llx not found\n",\r\nparent->index, __func__,\r\n(unsigned long long)class);\r\nret = -EINVAL;\r\ngoto out;\r\n}\r\n}\r\nret = tcam_flush(np, idx);\r\nif (ret)\r\ngoto out;\r\ntp->valid = 0;\r\nnp->clas.tcam_valid_entries--;\r\nout:\r\nniu_unlock_parent(np, flags);\r\nreturn ret;\r\n}\r\nstatic int niu_set_nfc(struct net_device *dev, struct ethtool_rxnfc *cmd)\r\n{\r\nstruct niu *np = netdev_priv(dev);\r\nint ret = 0;\r\nswitch (cmd->cmd) {\r\ncase ETHTOOL_SRXFH:\r\nret = niu_set_hash_opts(np, cmd);\r\nbreak;\r\ncase ETHTOOL_SRXCLSRLINS:\r\nret = niu_add_ethtool_tcam_entry(np, cmd);\r\nbreak;\r\ncase ETHTOOL_SRXCLSRLDEL:\r\nret = niu_del_ethtool_tcam_entry(np, cmd->fs.location);\r\nbreak;\r\ndefault:\r\nret = -EINVAL;\r\nbreak;\r\n}\r\nreturn ret;\r\n}\r\nstatic void niu_get_strings(struct net_device *dev, u32 stringset, u8 *data)\r\n{\r\nstruct niu *np = netdev_priv(dev);\r\nint i;\r\nif (stringset != ETH_SS_STATS)\r\nreturn;\r\nif (np->flags & NIU_FLAGS_XMAC) {\r\nmemcpy(data, niu_xmac_stat_keys,\r\nsizeof(niu_xmac_stat_keys));\r\ndata += sizeof(niu_xmac_stat_keys);\r\n} else {\r\nmemcpy(data, niu_bmac_stat_keys,\r\nsizeof(niu_bmac_stat_keys));\r\ndata += sizeof(niu_bmac_stat_keys);\r\n}\r\nfor (i = 0; i < np->num_rx_rings; i++) {\r\nmemcpy(data, niu_rxchan_stat_keys,\r\nsizeof(niu_rxchan_stat_keys));\r\ndata += sizeof(niu_rxchan_stat_keys);\r\n}\r\nfor (i = 0; i < np->num_tx_rings; i++) {\r\nmemcpy(data, niu_txchan_stat_keys,\r\nsizeof(niu_txchan_stat_keys));\r\ndata += sizeof(niu_txchan_stat_keys);\r\n}\r\n}\r\nstatic int niu_get_sset_count(struct net_device *dev, int stringset)\r\n{\r\nstruct niu *np = netdev_priv(dev);\r\nif (stringset != ETH_SS_STATS)\r\nreturn -EINVAL;\r\nreturn (np->flags & NIU_FLAGS_XMAC ?\r\nNUM_XMAC_STAT_KEYS :\r\nNUM_BMAC_STAT_KEYS) +\r\n(np->num_rx_rings * NUM_RXCHAN_STAT_KEYS) +\r\n(np->num_tx_rings * NUM_TXCHAN_STAT_KEYS);\r\n}\r\nstatic void niu_get_ethtool_stats(struct net_device *dev,\r\nstruct ethtool_stats *stats, u64 *data)\r\n{\r\nstruct niu *np = netdev_priv(dev);\r\nint i;\r\nniu_sync_mac_stats(np);\r\nif (np->flags & NIU_FLAGS_XMAC) {\r\nmemcpy(data, &np->mac_stats.xmac,\r\nsizeof(struct niu_xmac_stats));\r\ndata += (sizeof(struct niu_xmac_stats) / sizeof(u64));\r\n} else {\r\nmemcpy(data, &np->mac_stats.bmac,\r\nsizeof(struct niu_bmac_stats));\r\ndata += (sizeof(struct niu_bmac_stats) / sizeof(u64));\r\n}\r\nfor (i = 0; i < np->num_rx_rings; i++) {\r\nstruct rx_ring_info *rp = &np->rx_rings[i];\r\nniu_sync_rx_discard_stats(np, rp, 0);\r\ndata[0] = rp->rx_channel;\r\ndata[1] = rp->rx_packets;\r\ndata[2] = rp->rx_bytes;\r\ndata[3] = rp->rx_dropped;\r\ndata[4] = rp->rx_errors;\r\ndata += 5;\r\n}\r\nfor (i = 0; i < np->num_tx_rings; i++) {\r\nstruct tx_ring_info *rp = &np->tx_rings[i];\r\ndata[0] = rp->tx_channel;\r\ndata[1] = rp->tx_packets;\r\ndata[2] = rp->tx_bytes;\r\ndata[3] = rp->tx_errors;\r\ndata += 4;\r\n}\r\n}\r\nstatic u64 niu_led_state_save(struct niu *np)\r\n{\r\nif (np->flags & NIU_FLAGS_XMAC)\r\nreturn nr64_mac(XMAC_CONFIG);\r\nelse\r\nreturn nr64_mac(BMAC_XIF_CONFIG);\r\n}\r\nstatic void niu_led_state_restore(struct niu *np, u64 val)\r\n{\r\nif (np->flags & NIU_FLAGS_XMAC)\r\nnw64_mac(XMAC_CONFIG, val);\r\nelse\r\nnw64_mac(BMAC_XIF_CONFIG, val);\r\n}\r\nstatic void niu_force_led(struct niu *np, int on)\r\n{\r\nu64 val, reg, bit;\r\nif (np->flags & NIU_FLAGS_XMAC) {\r\nreg = XMAC_CONFIG;\r\nbit = XMAC_CONFIG_FORCE_LED_ON;\r\n} else {\r\nreg = BMAC_XIF_CONFIG;\r\nbit = BMAC_XIF_CONFIG_LINK_LED;\r\n}\r\nval = nr64_mac(reg);\r\nif (on)\r\nval |= bit;\r\nelse\r\nval &= ~bit;\r\nnw64_mac(reg, val);\r\n}\r\nstatic int niu_set_phys_id(struct net_device *dev,\r\nenum ethtool_phys_id_state state)\r\n{\r\nstruct niu *np = netdev_priv(dev);\r\nif (!netif_running(dev))\r\nreturn -EAGAIN;\r\nswitch (state) {\r\ncase ETHTOOL_ID_ACTIVE:\r\nnp->orig_led_state = niu_led_state_save(np);\r\nreturn 1;\r\ncase ETHTOOL_ID_ON:\r\nniu_force_led(np, 1);\r\nbreak;\r\ncase ETHTOOL_ID_OFF:\r\nniu_force_led(np, 0);\r\nbreak;\r\ncase ETHTOOL_ID_INACTIVE:\r\nniu_led_state_restore(np, np->orig_led_state);\r\n}\r\nreturn 0;\r\n}\r\nstatic int niu_ldg_assign_ldn(struct niu *np, struct niu_parent *parent,\r\nint ldg, int ldn)\r\n{\r\nif (ldg < NIU_LDG_MIN || ldg > NIU_LDG_MAX)\r\nreturn -EINVAL;\r\nif (ldn < 0 || ldn > LDN_MAX)\r\nreturn -EINVAL;\r\nparent->ldg_map[ldn] = ldg;\r\nif (np->parent->plat_type == PLAT_TYPE_NIU) {\r\nif (nr64(LDG_NUM(ldn)) != ldg) {\r\ndev_err(np->device, "Port %u, mis-matched LDG assignment for ldn %d, should be %d is %llu\n",\r\nnp->port, ldn, ldg,\r\n(unsigned long long) nr64(LDG_NUM(ldn)));\r\nreturn -EINVAL;\r\n}\r\n} else\r\nnw64(LDG_NUM(ldn), ldg);\r\nreturn 0;\r\n}\r\nstatic int niu_set_ldg_timer_res(struct niu *np, int res)\r\n{\r\nif (res < 0 || res > LDG_TIMER_RES_VAL)\r\nreturn -EINVAL;\r\nnw64(LDG_TIMER_RES, res);\r\nreturn 0;\r\n}\r\nstatic int niu_set_ldg_sid(struct niu *np, int ldg, int func, int vector)\r\n{\r\nif ((ldg < NIU_LDG_MIN || ldg > NIU_LDG_MAX) ||\r\n(func < 0 || func > 3) ||\r\n(vector < 0 || vector > 0x1f))\r\nreturn -EINVAL;\r\nnw64(SID(ldg), (func << SID_FUNC_SHIFT) | vector);\r\nreturn 0;\r\n}\r\nstatic int niu_pci_eeprom_read(struct niu *np, u32 addr)\r\n{\r\nu64 frame, frame_base = (ESPC_PIO_STAT_READ_START |\r\n(addr << ESPC_PIO_STAT_ADDR_SHIFT));\r\nint limit;\r\nif (addr > (ESPC_PIO_STAT_ADDR >> ESPC_PIO_STAT_ADDR_SHIFT))\r\nreturn -EINVAL;\r\nframe = frame_base;\r\nnw64(ESPC_PIO_STAT, frame);\r\nlimit = 64;\r\ndo {\r\nudelay(5);\r\nframe = nr64(ESPC_PIO_STAT);\r\nif (frame & ESPC_PIO_STAT_READ_END)\r\nbreak;\r\n} while (limit--);\r\nif (!(frame & ESPC_PIO_STAT_READ_END)) {\r\ndev_err(np->device, "EEPROM read timeout frame[%llx]\n",\r\n(unsigned long long) frame);\r\nreturn -ENODEV;\r\n}\r\nframe = frame_base;\r\nnw64(ESPC_PIO_STAT, frame);\r\nlimit = 64;\r\ndo {\r\nudelay(5);\r\nframe = nr64(ESPC_PIO_STAT);\r\nif (frame & ESPC_PIO_STAT_READ_END)\r\nbreak;\r\n} while (limit--);\r\nif (!(frame & ESPC_PIO_STAT_READ_END)) {\r\ndev_err(np->device, "EEPROM read timeout frame[%llx]\n",\r\n(unsigned long long) frame);\r\nreturn -ENODEV;\r\n}\r\nframe = nr64(ESPC_PIO_STAT);\r\nreturn (frame & ESPC_PIO_STAT_DATA) >> ESPC_PIO_STAT_DATA_SHIFT;\r\n}\r\nstatic int niu_pci_eeprom_read16(struct niu *np, u32 off)\r\n{\r\nint err = niu_pci_eeprom_read(np, off);\r\nu16 val;\r\nif (err < 0)\r\nreturn err;\r\nval = (err << 8);\r\nerr = niu_pci_eeprom_read(np, off + 1);\r\nif (err < 0)\r\nreturn err;\r\nval |= (err & 0xff);\r\nreturn val;\r\n}\r\nstatic int niu_pci_eeprom_read16_swp(struct niu *np, u32 off)\r\n{\r\nint err = niu_pci_eeprom_read(np, off);\r\nu16 val;\r\nif (err < 0)\r\nreturn err;\r\nval = (err & 0xff);\r\nerr = niu_pci_eeprom_read(np, off + 1);\r\nif (err < 0)\r\nreturn err;\r\nval |= (err & 0xff) << 8;\r\nreturn val;\r\n}\r\nstatic int niu_pci_vpd_get_propname(struct niu *np, u32 off, char *namebuf,\r\nint namebuf_len)\r\n{\r\nint i;\r\nfor (i = 0; i < namebuf_len; i++) {\r\nint err = niu_pci_eeprom_read(np, off + i);\r\nif (err < 0)\r\nreturn err;\r\n*namebuf++ = err;\r\nif (!err)\r\nbreak;\r\n}\r\nif (i >= namebuf_len)\r\nreturn -EINVAL;\r\nreturn i + 1;\r\n}\r\nstatic void niu_vpd_parse_version(struct niu *np)\r\n{\r\nstruct niu_vpd *vpd = &np->vpd;\r\nint len = strlen(vpd->version) + 1;\r\nconst char *s = vpd->version;\r\nint i;\r\nfor (i = 0; i < len - 5; i++) {\r\nif (!strncmp(s + i, "FCode ", 6))\r\nbreak;\r\n}\r\nif (i >= len - 5)\r\nreturn;\r\ns += i + 5;\r\nsscanf(s, "%d.%d", &vpd->fcode_major, &vpd->fcode_minor);\r\nnetif_printk(np, probe, KERN_DEBUG, np->dev,\r\n"VPD_SCAN: FCODE major(%d) minor(%d)\n",\r\nvpd->fcode_major, vpd->fcode_minor);\r\nif (vpd->fcode_major > NIU_VPD_MIN_MAJOR ||\r\n(vpd->fcode_major == NIU_VPD_MIN_MAJOR &&\r\nvpd->fcode_minor >= NIU_VPD_MIN_MINOR))\r\nnp->flags |= NIU_FLAGS_VPD_VALID;\r\n}\r\nstatic int niu_pci_vpd_scan_props(struct niu *np, u32 start, u32 end)\r\n{\r\nunsigned int found_mask = 0;\r\n#define FOUND_MASK_MODEL 0x00000001\r\n#define FOUND_MASK_BMODEL 0x00000002\r\n#define FOUND_MASK_VERS 0x00000004\r\n#define FOUND_MASK_MAC 0x00000008\r\n#define FOUND_MASK_NMAC 0x00000010\r\n#define FOUND_MASK_PHY 0x00000020\r\n#define FOUND_MASK_ALL 0x0000003f\r\nnetif_printk(np, probe, KERN_DEBUG, np->dev,\r\n"VPD_SCAN: start[%x] end[%x]\n", start, end);\r\nwhile (start < end) {\r\nint len, err, prop_len;\r\nchar namebuf[64];\r\nu8 *prop_buf;\r\nint max_len;\r\nif (found_mask == FOUND_MASK_ALL) {\r\nniu_vpd_parse_version(np);\r\nreturn 1;\r\n}\r\nerr = niu_pci_eeprom_read(np, start + 2);\r\nif (err < 0)\r\nreturn err;\r\nlen = err;\r\nstart += 3;\r\nprop_len = niu_pci_eeprom_read(np, start + 4);\r\nerr = niu_pci_vpd_get_propname(np, start + 5, namebuf, 64);\r\nif (err < 0)\r\nreturn err;\r\nprop_buf = NULL;\r\nmax_len = 0;\r\nif (!strcmp(namebuf, "model")) {\r\nprop_buf = np->vpd.model;\r\nmax_len = NIU_VPD_MODEL_MAX;\r\nfound_mask |= FOUND_MASK_MODEL;\r\n} else if (!strcmp(namebuf, "board-model")) {\r\nprop_buf = np->vpd.board_model;\r\nmax_len = NIU_VPD_BD_MODEL_MAX;\r\nfound_mask |= FOUND_MASK_BMODEL;\r\n} else if (!strcmp(namebuf, "version")) {\r\nprop_buf = np->vpd.version;\r\nmax_len = NIU_VPD_VERSION_MAX;\r\nfound_mask |= FOUND_MASK_VERS;\r\n} else if (!strcmp(namebuf, "local-mac-address")) {\r\nprop_buf = np->vpd.local_mac;\r\nmax_len = ETH_ALEN;\r\nfound_mask |= FOUND_MASK_MAC;\r\n} else if (!strcmp(namebuf, "num-mac-addresses")) {\r\nprop_buf = &np->vpd.mac_num;\r\nmax_len = 1;\r\nfound_mask |= FOUND_MASK_NMAC;\r\n} else if (!strcmp(namebuf, "phy-type")) {\r\nprop_buf = np->vpd.phy_type;\r\nmax_len = NIU_VPD_PHY_TYPE_MAX;\r\nfound_mask |= FOUND_MASK_PHY;\r\n}\r\nif (max_len && prop_len > max_len) {\r\ndev_err(np->device, "Property '%s' length (%d) is too long\n", namebuf, prop_len);\r\nreturn -EINVAL;\r\n}\r\nif (prop_buf) {\r\nu32 off = start + 5 + err;\r\nint i;\r\nnetif_printk(np, probe, KERN_DEBUG, np->dev,\r\n"VPD_SCAN: Reading in property [%s] len[%d]\n",\r\nnamebuf, prop_len);\r\nfor (i = 0; i < prop_len; i++)\r\n*prop_buf++ = niu_pci_eeprom_read(np, off + i);\r\n}\r\nstart += len;\r\n}\r\nreturn 0;\r\n}\r\nstatic void niu_pci_vpd_fetch(struct niu *np, u32 start)\r\n{\r\nu32 offset;\r\nint err;\r\nerr = niu_pci_eeprom_read16_swp(np, start + 1);\r\nif (err < 0)\r\nreturn;\r\noffset = err + 3;\r\nwhile (start + offset < ESPC_EEPROM_SIZE) {\r\nu32 here = start + offset;\r\nu32 end;\r\nerr = niu_pci_eeprom_read(np, here);\r\nif (err != 0x90)\r\nreturn;\r\nerr = niu_pci_eeprom_read16_swp(np, here + 1);\r\nif (err < 0)\r\nreturn;\r\nhere = start + offset + 3;\r\nend = start + offset + err;\r\noffset += err;\r\nerr = niu_pci_vpd_scan_props(np, here, end);\r\nif (err < 0 || err == 1)\r\nreturn;\r\n}\r\n}\r\nstatic u32 niu_pci_vpd_offset(struct niu *np)\r\n{\r\nu32 start = 0, end = ESPC_EEPROM_SIZE, ret;\r\nint err;\r\nwhile (start < end) {\r\nret = start;\r\nerr = niu_pci_eeprom_read16(np, start + 0);\r\nif (err != 0x55aa)\r\nreturn 0;\r\nerr = niu_pci_eeprom_read16(np, start + 23);\r\nif (err < 0)\r\nreturn 0;\r\nstart += err;\r\nerr = niu_pci_eeprom_read16(np, start + 0);\r\nif (err != 0x5043)\r\nreturn 0;\r\nerr = niu_pci_eeprom_read16(np, start + 2);\r\nif (err != 0x4952)\r\nreturn 0;\r\nerr = niu_pci_eeprom_read(np, start + 20);\r\nif (err < 0)\r\nreturn 0;\r\nif (err != 0x01) {\r\nerr = niu_pci_eeprom_read(np, ret + 2);\r\nif (err < 0)\r\nreturn 0;\r\nstart = ret + (err * 512);\r\ncontinue;\r\n}\r\nerr = niu_pci_eeprom_read16_swp(np, start + 8);\r\nif (err < 0)\r\nreturn err;\r\nret += err;\r\nerr = niu_pci_eeprom_read(np, ret + 0);\r\nif (err != 0x82)\r\nreturn 0;\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic int niu_phy_type_prop_decode(struct niu *np, const char *phy_prop)\r\n{\r\nif (!strcmp(phy_prop, "mif")) {\r\nnp->flags &= ~(NIU_FLAGS_FIBER |\r\nNIU_FLAGS_10G);\r\nnp->mac_xcvr = MAC_XCVR_MII;\r\n} else if (!strcmp(phy_prop, "xgf")) {\r\nnp->flags |= (NIU_FLAGS_10G |\r\nNIU_FLAGS_FIBER);\r\nnp->mac_xcvr = MAC_XCVR_XPCS;\r\n} else if (!strcmp(phy_prop, "pcs")) {\r\nnp->flags &= ~NIU_FLAGS_10G;\r\nnp->flags |= NIU_FLAGS_FIBER;\r\nnp->mac_xcvr = MAC_XCVR_PCS;\r\n} else if (!strcmp(phy_prop, "xgc")) {\r\nnp->flags |= NIU_FLAGS_10G;\r\nnp->flags &= ~NIU_FLAGS_FIBER;\r\nnp->mac_xcvr = MAC_XCVR_XPCS;\r\n} else if (!strcmp(phy_prop, "xgsd") || !strcmp(phy_prop, "gsd")) {\r\nnp->flags |= NIU_FLAGS_10G;\r\nnp->flags &= ~NIU_FLAGS_FIBER;\r\nnp->flags |= NIU_FLAGS_XCVR_SERDES;\r\nnp->mac_xcvr = MAC_XCVR_XPCS;\r\n} else {\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int niu_pci_vpd_get_nports(struct niu *np)\r\n{\r\nint ports = 0;\r\nif ((!strcmp(np->vpd.model, NIU_QGC_LP_MDL_STR)) ||\r\n(!strcmp(np->vpd.model, NIU_QGC_PEM_MDL_STR)) ||\r\n(!strcmp(np->vpd.model, NIU_MARAMBA_MDL_STR)) ||\r\n(!strcmp(np->vpd.model, NIU_KIMI_MDL_STR)) ||\r\n(!strcmp(np->vpd.model, NIU_ALONSO_MDL_STR))) {\r\nports = 4;\r\n} else if ((!strcmp(np->vpd.model, NIU_2XGF_LP_MDL_STR)) ||\r\n(!strcmp(np->vpd.model, NIU_2XGF_PEM_MDL_STR)) ||\r\n(!strcmp(np->vpd.model, NIU_FOXXY_MDL_STR)) ||\r\n(!strcmp(np->vpd.model, NIU_2XGF_MRVL_MDL_STR))) {\r\nports = 2;\r\n}\r\nreturn ports;\r\n}\r\nstatic void niu_pci_vpd_validate(struct niu *np)\r\n{\r\nstruct net_device *dev = np->dev;\r\nstruct niu_vpd *vpd = &np->vpd;\r\nu8 val8;\r\nif (!is_valid_ether_addr(&vpd->local_mac[0])) {\r\ndev_err(np->device, "VPD MAC invalid, falling back to SPROM\n");\r\nnp->flags &= ~NIU_FLAGS_VPD_VALID;\r\nreturn;\r\n}\r\nif (!strcmp(np->vpd.model, NIU_ALONSO_MDL_STR) ||\r\n!strcmp(np->vpd.model, NIU_KIMI_MDL_STR)) {\r\nnp->flags |= NIU_FLAGS_10G;\r\nnp->flags &= ~NIU_FLAGS_FIBER;\r\nnp->flags |= NIU_FLAGS_XCVR_SERDES;\r\nnp->mac_xcvr = MAC_XCVR_PCS;\r\nif (np->port > 1) {\r\nnp->flags |= NIU_FLAGS_FIBER;\r\nnp->flags &= ~NIU_FLAGS_10G;\r\n}\r\nif (np->flags & NIU_FLAGS_10G)\r\nnp->mac_xcvr = MAC_XCVR_XPCS;\r\n} else if (!strcmp(np->vpd.model, NIU_FOXXY_MDL_STR)) {\r\nnp->flags |= (NIU_FLAGS_10G | NIU_FLAGS_FIBER |\r\nNIU_FLAGS_HOTPLUG_PHY);\r\n} else if (niu_phy_type_prop_decode(np, np->vpd.phy_type)) {\r\ndev_err(np->device, "Illegal phy string [%s]\n",\r\nnp->vpd.phy_type);\r\ndev_err(np->device, "Falling back to SPROM\n");\r\nnp->flags &= ~NIU_FLAGS_VPD_VALID;\r\nreturn;\r\n}\r\nmemcpy(dev->dev_addr, vpd->local_mac, ETH_ALEN);\r\nval8 = dev->dev_addr[5];\r\ndev->dev_addr[5] += np->port;\r\nif (dev->dev_addr[5] < val8)\r\ndev->dev_addr[4]++;\r\n}\r\nstatic int niu_pci_probe_sprom(struct niu *np)\r\n{\r\nstruct net_device *dev = np->dev;\r\nint len, i;\r\nu64 val, sum;\r\nu8 val8;\r\nval = (nr64(ESPC_VER_IMGSZ) & ESPC_VER_IMGSZ_IMGSZ);\r\nval >>= ESPC_VER_IMGSZ_IMGSZ_SHIFT;\r\nlen = val / 4;\r\nnp->eeprom_len = len;\r\nnetif_printk(np, probe, KERN_DEBUG, np->dev,\r\n"SPROM: Image size %llu\n", (unsigned long long)val);\r\nsum = 0;\r\nfor (i = 0; i < len; i++) {\r\nval = nr64(ESPC_NCR(i));\r\nsum += (val >> 0) & 0xff;\r\nsum += (val >> 8) & 0xff;\r\nsum += (val >> 16) & 0xff;\r\nsum += (val >> 24) & 0xff;\r\n}\r\nnetif_printk(np, probe, KERN_DEBUG, np->dev,\r\n"SPROM: Checksum %x\n", (int)(sum & 0xff));\r\nif ((sum & 0xff) != 0xab) {\r\ndev_err(np->device, "Bad SPROM checksum (%x, should be 0xab)\n", (int)(sum & 0xff));\r\nreturn -EINVAL;\r\n}\r\nval = nr64(ESPC_PHY_TYPE);\r\nswitch (np->port) {\r\ncase 0:\r\nval8 = (val & ESPC_PHY_TYPE_PORT0) >>\r\nESPC_PHY_TYPE_PORT0_SHIFT;\r\nbreak;\r\ncase 1:\r\nval8 = (val & ESPC_PHY_TYPE_PORT1) >>\r\nESPC_PHY_TYPE_PORT1_SHIFT;\r\nbreak;\r\ncase 2:\r\nval8 = (val & ESPC_PHY_TYPE_PORT2) >>\r\nESPC_PHY_TYPE_PORT2_SHIFT;\r\nbreak;\r\ncase 3:\r\nval8 = (val & ESPC_PHY_TYPE_PORT3) >>\r\nESPC_PHY_TYPE_PORT3_SHIFT;\r\nbreak;\r\ndefault:\r\ndev_err(np->device, "Bogus port number %u\n",\r\nnp->port);\r\nreturn -EINVAL;\r\n}\r\nnetif_printk(np, probe, KERN_DEBUG, np->dev,\r\n"SPROM: PHY type %x\n", val8);\r\nswitch (val8) {\r\ncase ESPC_PHY_TYPE_1G_COPPER:\r\nnp->flags &= ~(NIU_FLAGS_FIBER |\r\nNIU_FLAGS_10G);\r\nnp->mac_xcvr = MAC_XCVR_MII;\r\nbreak;\r\ncase ESPC_PHY_TYPE_1G_FIBER:\r\nnp->flags &= ~NIU_FLAGS_10G;\r\nnp->flags |= NIU_FLAGS_FIBER;\r\nnp->mac_xcvr = MAC_XCVR_PCS;\r\nbreak;\r\ncase ESPC_PHY_TYPE_10G_COPPER:\r\nnp->flags |= NIU_FLAGS_10G;\r\nnp->flags &= ~NIU_FLAGS_FIBER;\r\nnp->mac_xcvr = MAC_XCVR_XPCS;\r\nbreak;\r\ncase ESPC_PHY_TYPE_10G_FIBER:\r\nnp->flags |= (NIU_FLAGS_10G |\r\nNIU_FLAGS_FIBER);\r\nnp->mac_xcvr = MAC_XCVR_XPCS;\r\nbreak;\r\ndefault:\r\ndev_err(np->device, "Bogus SPROM phy type %u\n", val8);\r\nreturn -EINVAL;\r\n}\r\nval = nr64(ESPC_MAC_ADDR0);\r\nnetif_printk(np, probe, KERN_DEBUG, np->dev,\r\n"SPROM: MAC_ADDR0[%08llx]\n", (unsigned long long)val);\r\ndev->dev_addr[0] = (val >> 0) & 0xff;\r\ndev->dev_addr[1] = (val >> 8) & 0xff;\r\ndev->dev_addr[2] = (val >> 16) & 0xff;\r\ndev->dev_addr[3] = (val >> 24) & 0xff;\r\nval = nr64(ESPC_MAC_ADDR1);\r\nnetif_printk(np, probe, KERN_DEBUG, np->dev,\r\n"SPROM: MAC_ADDR1[%08llx]\n", (unsigned long long)val);\r\ndev->dev_addr[4] = (val >> 0) & 0xff;\r\ndev->dev_addr[5] = (val >> 8) & 0xff;\r\nif (!is_valid_ether_addr(&dev->dev_addr[0])) {\r\ndev_err(np->device, "SPROM MAC address invalid [ %pM ]\n",\r\ndev->dev_addr);\r\nreturn -EINVAL;\r\n}\r\nval8 = dev->dev_addr[5];\r\ndev->dev_addr[5] += np->port;\r\nif (dev->dev_addr[5] < val8)\r\ndev->dev_addr[4]++;\r\nval = nr64(ESPC_MOD_STR_LEN);\r\nnetif_printk(np, probe, KERN_DEBUG, np->dev,\r\n"SPROM: MOD_STR_LEN[%llu]\n", (unsigned long long)val);\r\nif (val >= 8 * 4)\r\nreturn -EINVAL;\r\nfor (i = 0; i < val; i += 4) {\r\nu64 tmp = nr64(ESPC_NCR(5 + (i / 4)));\r\nnp->vpd.model[i + 3] = (tmp >> 0) & 0xff;\r\nnp->vpd.model[i + 2] = (tmp >> 8) & 0xff;\r\nnp->vpd.model[i + 1] = (tmp >> 16) & 0xff;\r\nnp->vpd.model[i + 0] = (tmp >> 24) & 0xff;\r\n}\r\nnp->vpd.model[val] = '\0';\r\nval = nr64(ESPC_BD_MOD_STR_LEN);\r\nnetif_printk(np, probe, KERN_DEBUG, np->dev,\r\n"SPROM: BD_MOD_STR_LEN[%llu]\n", (unsigned long long)val);\r\nif (val >= 4 * 4)\r\nreturn -EINVAL;\r\nfor (i = 0; i < val; i += 4) {\r\nu64 tmp = nr64(ESPC_NCR(14 + (i / 4)));\r\nnp->vpd.board_model[i + 3] = (tmp >> 0) & 0xff;\r\nnp->vpd.board_model[i + 2] = (tmp >> 8) & 0xff;\r\nnp->vpd.board_model[i + 1] = (tmp >> 16) & 0xff;\r\nnp->vpd.board_model[i + 0] = (tmp >> 24) & 0xff;\r\n}\r\nnp->vpd.board_model[val] = '\0';\r\nnp->vpd.mac_num =\r\nnr64(ESPC_NUM_PORTS_MACS) & ESPC_NUM_PORTS_MACS_VAL;\r\nnetif_printk(np, probe, KERN_DEBUG, np->dev,\r\n"SPROM: NUM_PORTS_MACS[%d]\n", np->vpd.mac_num);\r\nreturn 0;\r\n}\r\nstatic int niu_get_and_validate_port(struct niu *np)\r\n{\r\nstruct niu_parent *parent = np->parent;\r\nif (np->port <= 1)\r\nnp->flags |= NIU_FLAGS_XMAC;\r\nif (!parent->num_ports) {\r\nif (parent->plat_type == PLAT_TYPE_NIU) {\r\nparent->num_ports = 2;\r\n} else {\r\nparent->num_ports = niu_pci_vpd_get_nports(np);\r\nif (!parent->num_ports) {\r\nparent->num_ports = nr64(ESPC_NUM_PORTS_MACS) &\r\nESPC_NUM_PORTS_MACS_VAL;\r\nif (!parent->num_ports)\r\nparent->num_ports = 4;\r\n}\r\n}\r\n}\r\nif (np->port >= parent->num_ports)\r\nreturn -ENODEV;\r\nreturn 0;\r\n}\r\nstatic int phy_record(struct niu_parent *parent, struct phy_probe_info *p,\r\nint dev_id_1, int dev_id_2, u8 phy_port, int type)\r\n{\r\nu32 id = (dev_id_1 << 16) | dev_id_2;\r\nu8 idx;\r\nif (dev_id_1 < 0 || dev_id_2 < 0)\r\nreturn 0;\r\nif (type == PHY_TYPE_PMA_PMD || type == PHY_TYPE_PCS) {\r\nif (((id & NIU_PHY_ID_MASK) != NIU_PHY_ID_BCM8704) &&\r\n((id & NIU_PHY_ID_MASK) != NIU_PHY_ID_MRVL88X2011))\r\nreturn 0;\r\n} else {\r\nif ((id & NIU_PHY_ID_MASK) != NIU_PHY_ID_BCM5464R)\r\nreturn 0;\r\n}\r\npr_info("niu%d: Found PHY %08x type %s at phy_port %u\n",\r\nparent->index, id,\r\ntype == PHY_TYPE_PMA_PMD ? "PMA/PMD" :\r\ntype == PHY_TYPE_PCS ? "PCS" : "MII",\r\nphy_port);\r\nif (p->cur[type] >= NIU_MAX_PORTS) {\r\npr_err("Too many PHY ports\n");\r\nreturn -EINVAL;\r\n}\r\nidx = p->cur[type];\r\np->phy_id[type][idx] = id;\r\np->phy_port[type][idx] = phy_port;\r\np->cur[type] = idx + 1;\r\nreturn 0;\r\n}\r\nstatic int port_has_10g(struct phy_probe_info *p, int port)\r\n{\r\nint i;\r\nfor (i = 0; i < p->cur[PHY_TYPE_PMA_PMD]; i++) {\r\nif (p->phy_port[PHY_TYPE_PMA_PMD][i] == port)\r\nreturn 1;\r\n}\r\nfor (i = 0; i < p->cur[PHY_TYPE_PCS]; i++) {\r\nif (p->phy_port[PHY_TYPE_PCS][i] == port)\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}\r\nstatic int count_10g_ports(struct phy_probe_info *p, int *lowest)\r\n{\r\nint port, cnt;\r\ncnt = 0;\r\n*lowest = 32;\r\nfor (port = 8; port < 32; port++) {\r\nif (port_has_10g(p, port)) {\r\nif (!cnt)\r\n*lowest = port;\r\ncnt++;\r\n}\r\n}\r\nreturn cnt;\r\n}\r\nstatic int count_1g_ports(struct phy_probe_info *p, int *lowest)\r\n{\r\n*lowest = 32;\r\nif (p->cur[PHY_TYPE_MII])\r\n*lowest = p->phy_port[PHY_TYPE_MII][0];\r\nreturn p->cur[PHY_TYPE_MII];\r\n}\r\nstatic void niu_n2_divide_channels(struct niu_parent *parent)\r\n{\r\nint num_ports = parent->num_ports;\r\nint i;\r\nfor (i = 0; i < num_ports; i++) {\r\nparent->rxchan_per_port[i] = (16 / num_ports);\r\nparent->txchan_per_port[i] = (16 / num_ports);\r\npr_info("niu%d: Port %u [%u RX chans] [%u TX chans]\n",\r\nparent->index, i,\r\nparent->rxchan_per_port[i],\r\nparent->txchan_per_port[i]);\r\n}\r\n}\r\nstatic void niu_divide_channels(struct niu_parent *parent,\r\nint num_10g, int num_1g)\r\n{\r\nint num_ports = parent->num_ports;\r\nint rx_chans_per_10g, rx_chans_per_1g;\r\nint tx_chans_per_10g, tx_chans_per_1g;\r\nint i, tot_rx, tot_tx;\r\nif (!num_10g || !num_1g) {\r\nrx_chans_per_10g = rx_chans_per_1g =\r\n(NIU_NUM_RXCHAN / num_ports);\r\ntx_chans_per_10g = tx_chans_per_1g =\r\n(NIU_NUM_TXCHAN / num_ports);\r\n} else {\r\nrx_chans_per_1g = NIU_NUM_RXCHAN / 8;\r\nrx_chans_per_10g = (NIU_NUM_RXCHAN -\r\n(rx_chans_per_1g * num_1g)) /\r\nnum_10g;\r\ntx_chans_per_1g = NIU_NUM_TXCHAN / 6;\r\ntx_chans_per_10g = (NIU_NUM_TXCHAN -\r\n(tx_chans_per_1g * num_1g)) /\r\nnum_10g;\r\n}\r\ntot_rx = tot_tx = 0;\r\nfor (i = 0; i < num_ports; i++) {\r\nint type = phy_decode(parent->port_phy, i);\r\nif (type == PORT_TYPE_10G) {\r\nparent->rxchan_per_port[i] = rx_chans_per_10g;\r\nparent->txchan_per_port[i] = tx_chans_per_10g;\r\n} else {\r\nparent->rxchan_per_port[i] = rx_chans_per_1g;\r\nparent->txchan_per_port[i] = tx_chans_per_1g;\r\n}\r\npr_info("niu%d: Port %u [%u RX chans] [%u TX chans]\n",\r\nparent->index, i,\r\nparent->rxchan_per_port[i],\r\nparent->txchan_per_port[i]);\r\ntot_rx += parent->rxchan_per_port[i];\r\ntot_tx += parent->txchan_per_port[i];\r\n}\r\nif (tot_rx > NIU_NUM_RXCHAN) {\r\npr_err("niu%d: Too many RX channels (%d), resetting to one per port\n",\r\nparent->index, tot_rx);\r\nfor (i = 0; i < num_ports; i++)\r\nparent->rxchan_per_port[i] = 1;\r\n}\r\nif (tot_tx > NIU_NUM_TXCHAN) {\r\npr_err("niu%d: Too many TX channels (%d), resetting to one per port\n",\r\nparent->index, tot_tx);\r\nfor (i = 0; i < num_ports; i++)\r\nparent->txchan_per_port[i] = 1;\r\n}\r\nif (tot_rx < NIU_NUM_RXCHAN || tot_tx < NIU_NUM_TXCHAN) {\r\npr_warn("niu%d: Driver bug, wasted channels, RX[%d] TX[%d]\n",\r\nparent->index, tot_rx, tot_tx);\r\n}\r\n}\r\nstatic void niu_divide_rdc_groups(struct niu_parent *parent,\r\nint num_10g, int num_1g)\r\n{\r\nint i, num_ports = parent->num_ports;\r\nint rdc_group, rdc_groups_per_port;\r\nint rdc_channel_base;\r\nrdc_group = 0;\r\nrdc_groups_per_port = NIU_NUM_RDC_TABLES / num_ports;\r\nrdc_channel_base = 0;\r\nfor (i = 0; i < num_ports; i++) {\r\nstruct niu_rdc_tables *tp = &parent->rdc_group_cfg[i];\r\nint grp, num_channels = parent->rxchan_per_port[i];\r\nint this_channel_offset;\r\ntp->first_table_num = rdc_group;\r\ntp->num_tables = rdc_groups_per_port;\r\nthis_channel_offset = 0;\r\nfor (grp = 0; grp < tp->num_tables; grp++) {\r\nstruct rdc_table *rt = &tp->tables[grp];\r\nint slot;\r\npr_info("niu%d: Port %d RDC tbl(%d) [ ",\r\nparent->index, i, tp->first_table_num + grp);\r\nfor (slot = 0; slot < NIU_RDC_TABLE_SLOTS; slot++) {\r\nrt->rxdma_channel[slot] =\r\nrdc_channel_base + this_channel_offset;\r\npr_cont("%d ", rt->rxdma_channel[slot]);\r\nif (++this_channel_offset == num_channels)\r\nthis_channel_offset = 0;\r\n}\r\npr_cont("]\n");\r\n}\r\nparent->rdc_default[i] = rdc_channel_base;\r\nrdc_channel_base += num_channels;\r\nrdc_group += rdc_groups_per_port;\r\n}\r\n}\r\nstatic int fill_phy_probe_info(struct niu *np, struct niu_parent *parent,\r\nstruct phy_probe_info *info)\r\n{\r\nunsigned long flags;\r\nint port, err;\r\nmemset(info, 0, sizeof(*info));\r\nniu_lock_parent(np, flags);\r\nerr = 0;\r\nfor (port = 8; port < 32; port++) {\r\nint dev_id_1, dev_id_2;\r\ndev_id_1 = mdio_read(np, port,\r\nNIU_PMA_PMD_DEV_ADDR, MII_PHYSID1);\r\ndev_id_2 = mdio_read(np, port,\r\nNIU_PMA_PMD_DEV_ADDR, MII_PHYSID2);\r\nerr = phy_record(parent, info, dev_id_1, dev_id_2, port,\r\nPHY_TYPE_PMA_PMD);\r\nif (err)\r\nbreak;\r\ndev_id_1 = mdio_read(np, port,\r\nNIU_PCS_DEV_ADDR, MII_PHYSID1);\r\ndev_id_2 = mdio_read(np, port,\r\nNIU_PCS_DEV_ADDR, MII_PHYSID2);\r\nerr = phy_record(parent, info, dev_id_1, dev_id_2, port,\r\nPHY_TYPE_PCS);\r\nif (err)\r\nbreak;\r\ndev_id_1 = mii_read(np, port, MII_PHYSID1);\r\ndev_id_2 = mii_read(np, port, MII_PHYSID2);\r\nerr = phy_record(parent, info, dev_id_1, dev_id_2, port,\r\nPHY_TYPE_MII);\r\nif (err)\r\nbreak;\r\n}\r\nniu_unlock_parent(np, flags);\r\nreturn err;\r\n}\r\nstatic int walk_phys(struct niu *np, struct niu_parent *parent)\r\n{\r\nstruct phy_probe_info *info = &parent->phy_probe_info;\r\nint lowest_10g, lowest_1g;\r\nint num_10g, num_1g;\r\nu32 val;\r\nint err;\r\nnum_10g = num_1g = 0;\r\nif (!strcmp(np->vpd.model, NIU_ALONSO_MDL_STR) ||\r\n!strcmp(np->vpd.model, NIU_KIMI_MDL_STR)) {\r\nnum_10g = 0;\r\nnum_1g = 2;\r\nparent->plat_type = PLAT_TYPE_ATCA_CP3220;\r\nparent->num_ports = 4;\r\nval = (phy_encode(PORT_TYPE_1G, 0) |\r\nphy_encode(PORT_TYPE_1G, 1) |\r\nphy_encode(PORT_TYPE_1G, 2) |\r\nphy_encode(PORT_TYPE_1G, 3));\r\n} else if (!strcmp(np->vpd.model, NIU_FOXXY_MDL_STR)) {\r\nnum_10g = 2;\r\nnum_1g = 0;\r\nparent->num_ports = 2;\r\nval = (phy_encode(PORT_TYPE_10G, 0) |\r\nphy_encode(PORT_TYPE_10G, 1));\r\n} else if ((np->flags & NIU_FLAGS_XCVR_SERDES) &&\r\n(parent->plat_type == PLAT_TYPE_NIU)) {\r\nif (np->flags & NIU_FLAGS_10G) {\r\nval = (phy_encode(PORT_TYPE_10G, 0) |\r\nphy_encode(PORT_TYPE_10G, 1));\r\n} else {\r\nval = (phy_encode(PORT_TYPE_1G, 0) |\r\nphy_encode(PORT_TYPE_1G, 1));\r\n}\r\n} else {\r\nerr = fill_phy_probe_info(np, parent, info);\r\nif (err)\r\nreturn err;\r\nnum_10g = count_10g_ports(info, &lowest_10g);\r\nnum_1g = count_1g_ports(info, &lowest_1g);\r\nswitch ((num_10g << 4) | num_1g) {\r\ncase 0x24:\r\nif (lowest_1g == 10)\r\nparent->plat_type = PLAT_TYPE_VF_P0;\r\nelse if (lowest_1g == 26)\r\nparent->plat_type = PLAT_TYPE_VF_P1;\r\nelse\r\ngoto unknown_vg_1g_port;\r\ncase 0x22:\r\nval = (phy_encode(PORT_TYPE_10G, 0) |\r\nphy_encode(PORT_TYPE_10G, 1) |\r\nphy_encode(PORT_TYPE_1G, 2) |\r\nphy_encode(PORT_TYPE_1G, 3));\r\nbreak;\r\ncase 0x20:\r\nval = (phy_encode(PORT_TYPE_10G, 0) |\r\nphy_encode(PORT_TYPE_10G, 1));\r\nbreak;\r\ncase 0x10:\r\nval = phy_encode(PORT_TYPE_10G, np->port);\r\nbreak;\r\ncase 0x14:\r\nif (lowest_1g == 10)\r\nparent->plat_type = PLAT_TYPE_VF_P0;\r\nelse if (lowest_1g == 26)\r\nparent->plat_type = PLAT_TYPE_VF_P1;\r\nelse\r\ngoto unknown_vg_1g_port;\r\ncase 0x13:\r\nif ((lowest_10g & 0x7) == 0)\r\nval = (phy_encode(PORT_TYPE_10G, 0) |\r\nphy_encode(PORT_TYPE_1G, 1) |\r\nphy_encode(PORT_TYPE_1G, 2) |\r\nphy_encode(PORT_TYPE_1G, 3));\r\nelse\r\nval = (phy_encode(PORT_TYPE_1G, 0) |\r\nphy_encode(PORT_TYPE_10G, 1) |\r\nphy_encode(PORT_TYPE_1G, 2) |\r\nphy_encode(PORT_TYPE_1G, 3));\r\nbreak;\r\ncase 0x04:\r\nif (lowest_1g == 10)\r\nparent->plat_type = PLAT_TYPE_VF_P0;\r\nelse if (lowest_1g == 26)\r\nparent->plat_type = PLAT_TYPE_VF_P1;\r\nelse\r\ngoto unknown_vg_1g_port;\r\nval = (phy_encode(PORT_TYPE_1G, 0) |\r\nphy_encode(PORT_TYPE_1G, 1) |\r\nphy_encode(PORT_TYPE_1G, 2) |\r\nphy_encode(PORT_TYPE_1G, 3));\r\nbreak;\r\ndefault:\r\npr_err("Unsupported port config 10G[%d] 1G[%d]\n",\r\nnum_10g, num_1g);\r\nreturn -EINVAL;\r\n}\r\n}\r\nparent->port_phy = val;\r\nif (parent->plat_type == PLAT_TYPE_NIU)\r\nniu_n2_divide_channels(parent);\r\nelse\r\nniu_divide_channels(parent, num_10g, num_1g);\r\nniu_divide_rdc_groups(parent, num_10g, num_1g);\r\nreturn 0;\r\nunknown_vg_1g_port:\r\npr_err("Cannot identify platform type, 1gport=%d\n", lowest_1g);\r\nreturn -EINVAL;\r\n}\r\nstatic int niu_probe_ports(struct niu *np)\r\n{\r\nstruct niu_parent *parent = np->parent;\r\nint err, i;\r\nif (parent->port_phy == PORT_PHY_UNKNOWN) {\r\nerr = walk_phys(np, parent);\r\nif (err)\r\nreturn err;\r\nniu_set_ldg_timer_res(np, 2);\r\nfor (i = 0; i <= LDN_MAX; i++)\r\nniu_ldn_irq_enable(np, i, 0);\r\n}\r\nif (parent->port_phy == PORT_PHY_INVALID)\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\nstatic int niu_classifier_swstate_init(struct niu *np)\r\n{\r\nstruct niu_classifier *cp = &np->clas;\r\ncp->tcam_top = (u16) np->port;\r\ncp->tcam_sz = np->parent->tcam_num_entries / np->parent->num_ports;\r\ncp->h1_init = 0xffffffff;\r\ncp->h2_init = 0xffff;\r\nreturn fflp_early_init(np);\r\n}\r\nstatic void niu_link_config_init(struct niu *np)\r\n{\r\nstruct niu_link_config *lp = &np->link_config;\r\nlp->advertising = (ADVERTISED_10baseT_Half |\r\nADVERTISED_10baseT_Full |\r\nADVERTISED_100baseT_Half |\r\nADVERTISED_100baseT_Full |\r\nADVERTISED_1000baseT_Half |\r\nADVERTISED_1000baseT_Full |\r\nADVERTISED_10000baseT_Full |\r\nADVERTISED_Autoneg);\r\nlp->speed = lp->active_speed = SPEED_INVALID;\r\nlp->duplex = DUPLEX_FULL;\r\nlp->active_duplex = DUPLEX_INVALID;\r\nlp->autoneg = 1;\r\n#if 0\r\nlp->loopback_mode = LOOPBACK_MAC;\r\nlp->active_speed = SPEED_10000;\r\nlp->active_duplex = DUPLEX_FULL;\r\n#else\r\nlp->loopback_mode = LOOPBACK_DISABLED;\r\n#endif\r\n}\r\nstatic int niu_init_mac_ipp_pcs_base(struct niu *np)\r\n{\r\nswitch (np->port) {\r\ncase 0:\r\nnp->mac_regs = np->regs + XMAC_PORT0_OFF;\r\nnp->ipp_off = 0x00000;\r\nnp->pcs_off = 0x04000;\r\nnp->xpcs_off = 0x02000;\r\nbreak;\r\ncase 1:\r\nnp->mac_regs = np->regs + XMAC_PORT1_OFF;\r\nnp->ipp_off = 0x08000;\r\nnp->pcs_off = 0x0a000;\r\nnp->xpcs_off = 0x08000;\r\nbreak;\r\ncase 2:\r\nnp->mac_regs = np->regs + BMAC_PORT2_OFF;\r\nnp->ipp_off = 0x04000;\r\nnp->pcs_off = 0x0e000;\r\nnp->xpcs_off = ~0UL;\r\nbreak;\r\ncase 3:\r\nnp->mac_regs = np->regs + BMAC_PORT3_OFF;\r\nnp->ipp_off = 0x0c000;\r\nnp->pcs_off = 0x12000;\r\nnp->xpcs_off = ~0UL;\r\nbreak;\r\ndefault:\r\ndev_err(np->device, "Port %u is invalid, cannot compute MAC block offset\n", np->port);\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic void niu_try_msix(struct niu *np, u8 *ldg_num_map)\r\n{\r\nstruct msix_entry msi_vec[NIU_NUM_LDG];\r\nstruct niu_parent *parent = np->parent;\r\nstruct pci_dev *pdev = np->pdev;\r\nint i, num_irqs;\r\nu8 first_ldg;\r\nfirst_ldg = (NIU_NUM_LDG / parent->num_ports) * np->port;\r\nfor (i = 0; i < (NIU_NUM_LDG / parent->num_ports); i++)\r\nldg_num_map[i] = first_ldg + i;\r\nnum_irqs = (parent->rxchan_per_port[np->port] +\r\nparent->txchan_per_port[np->port] +\r\n(np->port == 0 ? 3 : 1));\r\nBUG_ON(num_irqs > (NIU_NUM_LDG / parent->num_ports));\r\nfor (i = 0; i < num_irqs; i++) {\r\nmsi_vec[i].vector = 0;\r\nmsi_vec[i].entry = i;\r\n}\r\nnum_irqs = pci_enable_msix_range(pdev, msi_vec, 1, num_irqs);\r\nif (num_irqs < 0) {\r\nnp->flags &= ~NIU_FLAGS_MSIX;\r\nreturn;\r\n}\r\nnp->flags |= NIU_FLAGS_MSIX;\r\nfor (i = 0; i < num_irqs; i++)\r\nnp->ldg[i].irq = msi_vec[i].vector;\r\nnp->num_ldg = num_irqs;\r\n}\r\nstatic int niu_n2_irq_init(struct niu *np, u8 *ldg_num_map)\r\n{\r\n#ifdef CONFIG_SPARC64\r\nstruct platform_device *op = np->op;\r\nconst u32 *int_prop;\r\nint i;\r\nint_prop = of_get_property(op->dev.of_node, "interrupts", NULL);\r\nif (!int_prop)\r\nreturn -ENODEV;\r\nfor (i = 0; i < op->archdata.num_irqs; i++) {\r\nldg_num_map[i] = int_prop[i];\r\nnp->ldg[i].irq = op->archdata.irqs[i];\r\n}\r\nnp->num_ldg = op->archdata.num_irqs;\r\nreturn 0;\r\n#else\r\nreturn -EINVAL;\r\n#endif\r\n}\r\nstatic int niu_ldg_init(struct niu *np)\r\n{\r\nstruct niu_parent *parent = np->parent;\r\nu8 ldg_num_map[NIU_NUM_LDG];\r\nint first_chan, num_chan;\r\nint i, err, ldg_rotor;\r\nu8 port;\r\nnp->num_ldg = 1;\r\nnp->ldg[0].irq = np->dev->irq;\r\nif (parent->plat_type == PLAT_TYPE_NIU) {\r\nerr = niu_n2_irq_init(np, ldg_num_map);\r\nif (err)\r\nreturn err;\r\n} else\r\nniu_try_msix(np, ldg_num_map);\r\nport = np->port;\r\nfor (i = 0; i < np->num_ldg; i++) {\r\nstruct niu_ldg *lp = &np->ldg[i];\r\nnetif_napi_add(np->dev, &lp->napi, niu_poll, 64);\r\nlp->np = np;\r\nlp->ldg_num = ldg_num_map[i];\r\nlp->timer = 2;\r\nif (np->parent->plat_type != PLAT_TYPE_NIU) {\r\nerr = niu_set_ldg_sid(np, lp->ldg_num, port, i);\r\nif (err)\r\nreturn err;\r\n}\r\n}\r\nldg_rotor = 0;\r\nerr = niu_ldg_assign_ldn(np, parent, ldg_num_map[ldg_rotor],\r\nLDN_MAC(port));\r\nif (err)\r\nreturn err;\r\nldg_rotor++;\r\nif (ldg_rotor == np->num_ldg)\r\nldg_rotor = 0;\r\nif (port == 0) {\r\nerr = niu_ldg_assign_ldn(np, parent,\r\nldg_num_map[ldg_rotor],\r\nLDN_MIF);\r\nif (err)\r\nreturn err;\r\nldg_rotor++;\r\nif (ldg_rotor == np->num_ldg)\r\nldg_rotor = 0;\r\nerr = niu_ldg_assign_ldn(np, parent,\r\nldg_num_map[ldg_rotor],\r\nLDN_DEVICE_ERROR);\r\nif (err)\r\nreturn err;\r\nldg_rotor++;\r\nif (ldg_rotor == np->num_ldg)\r\nldg_rotor = 0;\r\n}\r\nfirst_chan = 0;\r\nfor (i = 0; i < port; i++)\r\nfirst_chan += parent->rxchan_per_port[i];\r\nnum_chan = parent->rxchan_per_port[port];\r\nfor (i = first_chan; i < (first_chan + num_chan); i++) {\r\nerr = niu_ldg_assign_ldn(np, parent,\r\nldg_num_map[ldg_rotor],\r\nLDN_RXDMA(i));\r\nif (err)\r\nreturn err;\r\nldg_rotor++;\r\nif (ldg_rotor == np->num_ldg)\r\nldg_rotor = 0;\r\n}\r\nfirst_chan = 0;\r\nfor (i = 0; i < port; i++)\r\nfirst_chan += parent->txchan_per_port[i];\r\nnum_chan = parent->txchan_per_port[port];\r\nfor (i = first_chan; i < (first_chan + num_chan); i++) {\r\nerr = niu_ldg_assign_ldn(np, parent,\r\nldg_num_map[ldg_rotor],\r\nLDN_TXDMA(i));\r\nif (err)\r\nreturn err;\r\nldg_rotor++;\r\nif (ldg_rotor == np->num_ldg)\r\nldg_rotor = 0;\r\n}\r\nreturn 0;\r\n}\r\nstatic void niu_ldg_free(struct niu *np)\r\n{\r\nif (np->flags & NIU_FLAGS_MSIX)\r\npci_disable_msix(np->pdev);\r\n}\r\nstatic int niu_get_of_props(struct niu *np)\r\n{\r\n#ifdef CONFIG_SPARC64\r\nstruct net_device *dev = np->dev;\r\nstruct device_node *dp;\r\nconst char *phy_type;\r\nconst u8 *mac_addr;\r\nconst char *model;\r\nint prop_len;\r\nif (np->parent->plat_type == PLAT_TYPE_NIU)\r\ndp = np->op->dev.of_node;\r\nelse\r\ndp = pci_device_to_OF_node(np->pdev);\r\nphy_type = of_get_property(dp, "phy-type", &prop_len);\r\nif (!phy_type) {\r\nnetdev_err(dev, "%s: OF node lacks phy-type property\n",\r\ndp->full_name);\r\nreturn -EINVAL;\r\n}\r\nif (!strcmp(phy_type, "none"))\r\nreturn -ENODEV;\r\nstrcpy(np->vpd.phy_type, phy_type);\r\nif (niu_phy_type_prop_decode(np, np->vpd.phy_type)) {\r\nnetdev_err(dev, "%s: Illegal phy string [%s]\n",\r\ndp->full_name, np->vpd.phy_type);\r\nreturn -EINVAL;\r\n}\r\nmac_addr = of_get_property(dp, "local-mac-address", &prop_len);\r\nif (!mac_addr) {\r\nnetdev_err(dev, "%s: OF node lacks local-mac-address property\n",\r\ndp->full_name);\r\nreturn -EINVAL;\r\n}\r\nif (prop_len != dev->addr_len) {\r\nnetdev_err(dev, "%s: OF MAC address prop len (%d) is wrong\n",\r\ndp->full_name, prop_len);\r\n}\r\nmemcpy(dev->dev_addr, mac_addr, dev->addr_len);\r\nif (!is_valid_ether_addr(&dev->dev_addr[0])) {\r\nnetdev_err(dev, "%s: OF MAC address is invalid\n",\r\ndp->full_name);\r\nnetdev_err(dev, "%s: [ %pM ]\n", dp->full_name, dev->dev_addr);\r\nreturn -EINVAL;\r\n}\r\nmodel = of_get_property(dp, "model", &prop_len);\r\nif (model)\r\nstrcpy(np->vpd.model, model);\r\nif (of_find_property(dp, "hot-swappable-phy", &prop_len)) {\r\nnp->flags |= (NIU_FLAGS_10G | NIU_FLAGS_FIBER |\r\nNIU_FLAGS_HOTPLUG_PHY);\r\n}\r\nreturn 0;\r\n#else\r\nreturn -EINVAL;\r\n#endif\r\n}\r\nstatic int niu_get_invariants(struct niu *np)\r\n{\r\nint err, have_props;\r\nu32 offset;\r\nerr = niu_get_of_props(np);\r\nif (err == -ENODEV)\r\nreturn err;\r\nhave_props = !err;\r\nerr = niu_init_mac_ipp_pcs_base(np);\r\nif (err)\r\nreturn err;\r\nif (have_props) {\r\nerr = niu_get_and_validate_port(np);\r\nif (err)\r\nreturn err;\r\n} else {\r\nif (np->parent->plat_type == PLAT_TYPE_NIU)\r\nreturn -EINVAL;\r\nnw64(ESPC_PIO_EN, ESPC_PIO_EN_ENABLE);\r\noffset = niu_pci_vpd_offset(np);\r\nnetif_printk(np, probe, KERN_DEBUG, np->dev,\r\n"%s() VPD offset [%08x]\n", __func__, offset);\r\nif (offset)\r\nniu_pci_vpd_fetch(np, offset);\r\nnw64(ESPC_PIO_EN, 0);\r\nif (np->flags & NIU_FLAGS_VPD_VALID) {\r\nniu_pci_vpd_validate(np);\r\nerr = niu_get_and_validate_port(np);\r\nif (err)\r\nreturn err;\r\n}\r\nif (!(np->flags & NIU_FLAGS_VPD_VALID)) {\r\nerr = niu_get_and_validate_port(np);\r\nif (err)\r\nreturn err;\r\nerr = niu_pci_probe_sprom(np);\r\nif (err)\r\nreturn err;\r\n}\r\n}\r\nerr = niu_probe_ports(np);\r\nif (err)\r\nreturn err;\r\nniu_ldg_init(np);\r\nniu_classifier_swstate_init(np);\r\nniu_link_config_init(np);\r\nerr = niu_determine_phy_disposition(np);\r\nif (!err)\r\nerr = niu_init_link(np);\r\nreturn err;\r\n}\r\nstatic ssize_t show_port_phy(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct platform_device *plat_dev = to_platform_device(dev);\r\nstruct niu_parent *p = dev_get_platdata(&plat_dev->dev);\r\nu32 port_phy = p->port_phy;\r\nchar *orig_buf = buf;\r\nint i;\r\nif (port_phy == PORT_PHY_UNKNOWN ||\r\nport_phy == PORT_PHY_INVALID)\r\nreturn 0;\r\nfor (i = 0; i < p->num_ports; i++) {\r\nconst char *type_str;\r\nint type;\r\ntype = phy_decode(port_phy, i);\r\nif (type == PORT_TYPE_10G)\r\ntype_str = "10G";\r\nelse\r\ntype_str = "1G";\r\nbuf += sprintf(buf,\r\n(i == 0) ? "%s" : " %s",\r\ntype_str);\r\n}\r\nbuf += sprintf(buf, "\n");\r\nreturn buf - orig_buf;\r\n}\r\nstatic ssize_t show_plat_type(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct platform_device *plat_dev = to_platform_device(dev);\r\nstruct niu_parent *p = dev_get_platdata(&plat_dev->dev);\r\nconst char *type_str;\r\nswitch (p->plat_type) {\r\ncase PLAT_TYPE_ATLAS:\r\ntype_str = "atlas";\r\nbreak;\r\ncase PLAT_TYPE_NIU:\r\ntype_str = "niu";\r\nbreak;\r\ncase PLAT_TYPE_VF_P0:\r\ntype_str = "vf_p0";\r\nbreak;\r\ncase PLAT_TYPE_VF_P1:\r\ntype_str = "vf_p1";\r\nbreak;\r\ndefault:\r\ntype_str = "unknown";\r\nbreak;\r\n}\r\nreturn sprintf(buf, "%s\n", type_str);\r\n}\r\nstatic ssize_t __show_chan_per_port(struct device *dev,\r\nstruct device_attribute *attr, char *buf,\r\nint rx)\r\n{\r\nstruct platform_device *plat_dev = to_platform_device(dev);\r\nstruct niu_parent *p = dev_get_platdata(&plat_dev->dev);\r\nchar *orig_buf = buf;\r\nu8 *arr;\r\nint i;\r\narr = (rx ? p->rxchan_per_port : p->txchan_per_port);\r\nfor (i = 0; i < p->num_ports; i++) {\r\nbuf += sprintf(buf,\r\n(i == 0) ? "%d" : " %d",\r\narr[i]);\r\n}\r\nbuf += sprintf(buf, "\n");\r\nreturn buf - orig_buf;\r\n}\r\nstatic ssize_t show_rxchan_per_port(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nreturn __show_chan_per_port(dev, attr, buf, 1);\r\n}\r\nstatic ssize_t show_txchan_per_port(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nreturn __show_chan_per_port(dev, attr, buf, 1);\r\n}\r\nstatic ssize_t show_num_ports(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct platform_device *plat_dev = to_platform_device(dev);\r\nstruct niu_parent *p = dev_get_platdata(&plat_dev->dev);\r\nreturn sprintf(buf, "%d\n", p->num_ports);\r\n}\r\nstatic struct niu_parent *niu_new_parent(struct niu *np,\r\nunion niu_parent_id *id, u8 ptype)\r\n{\r\nstruct platform_device *plat_dev;\r\nstruct niu_parent *p;\r\nint i;\r\nplat_dev = platform_device_register_simple("niu-board", niu_parent_index,\r\nNULL, 0);\r\nif (IS_ERR(plat_dev))\r\nreturn NULL;\r\nfor (i = 0; niu_parent_attributes[i].attr.name; i++) {\r\nint err = device_create_file(&plat_dev->dev,\r\n&niu_parent_attributes[i]);\r\nif (err)\r\ngoto fail_unregister;\r\n}\r\np = kzalloc(sizeof(*p), GFP_KERNEL);\r\nif (!p)\r\ngoto fail_unregister;\r\np->index = niu_parent_index++;\r\nplat_dev->dev.platform_data = p;\r\np->plat_dev = plat_dev;\r\nmemcpy(&p->id, id, sizeof(*id));\r\np->plat_type = ptype;\r\nINIT_LIST_HEAD(&p->list);\r\natomic_set(&p->refcnt, 0);\r\nlist_add(&p->list, &niu_parent_list);\r\nspin_lock_init(&p->lock);\r\np->rxdma_clock_divider = 7500;\r\np->tcam_num_entries = NIU_PCI_TCAM_ENTRIES;\r\nif (p->plat_type == PLAT_TYPE_NIU)\r\np->tcam_num_entries = NIU_NONPCI_TCAM_ENTRIES;\r\nfor (i = CLASS_CODE_USER_PROG1; i <= CLASS_CODE_SCTP_IPV6; i++) {\r\nint index = i - CLASS_CODE_USER_PROG1;\r\np->tcam_key[index] = TCAM_KEY_TSEL;\r\np->flow_key[index] = (FLOW_KEY_IPSA |\r\nFLOW_KEY_IPDA |\r\nFLOW_KEY_PROTO |\r\n(FLOW_KEY_L4_BYTE12 <<\r\nFLOW_KEY_L4_0_SHIFT) |\r\n(FLOW_KEY_L4_BYTE12 <<\r\nFLOW_KEY_L4_1_SHIFT));\r\n}\r\nfor (i = 0; i < LDN_MAX + 1; i++)\r\np->ldg_map[i] = LDG_INVALID;\r\nreturn p;\r\nfail_unregister:\r\nplatform_device_unregister(plat_dev);\r\nreturn NULL;\r\n}\r\nstatic struct niu_parent *niu_get_parent(struct niu *np,\r\nunion niu_parent_id *id, u8 ptype)\r\n{\r\nstruct niu_parent *p, *tmp;\r\nint port = np->port;\r\nmutex_lock(&niu_parent_lock);\r\np = NULL;\r\nlist_for_each_entry(tmp, &niu_parent_list, list) {\r\nif (!memcmp(id, &tmp->id, sizeof(*id))) {\r\np = tmp;\r\nbreak;\r\n}\r\n}\r\nif (!p)\r\np = niu_new_parent(np, id, ptype);\r\nif (p) {\r\nchar port_name[6];\r\nint err;\r\nsprintf(port_name, "port%d", port);\r\nerr = sysfs_create_link(&p->plat_dev->dev.kobj,\r\n&np->device->kobj,\r\nport_name);\r\nif (!err) {\r\np->ports[port] = np;\r\natomic_inc(&p->refcnt);\r\n}\r\n}\r\nmutex_unlock(&niu_parent_lock);\r\nreturn p;\r\n}\r\nstatic void niu_put_parent(struct niu *np)\r\n{\r\nstruct niu_parent *p = np->parent;\r\nu8 port = np->port;\r\nchar port_name[6];\r\nBUG_ON(!p || p->ports[port] != np);\r\nnetif_printk(np, probe, KERN_DEBUG, np->dev,\r\n"%s() port[%u]\n", __func__, port);\r\nsprintf(port_name, "port%d", port);\r\nmutex_lock(&niu_parent_lock);\r\nsysfs_remove_link(&p->plat_dev->dev.kobj, port_name);\r\np->ports[port] = NULL;\r\nnp->parent = NULL;\r\nif (atomic_dec_and_test(&p->refcnt)) {\r\nlist_del(&p->list);\r\nplatform_device_unregister(p->plat_dev);\r\n}\r\nmutex_unlock(&niu_parent_lock);\r\n}\r\nstatic void *niu_pci_alloc_coherent(struct device *dev, size_t size,\r\nu64 *handle, gfp_t flag)\r\n{\r\ndma_addr_t dh;\r\nvoid *ret;\r\nret = dma_alloc_coherent(dev, size, &dh, flag);\r\nif (ret)\r\n*handle = dh;\r\nreturn ret;\r\n}\r\nstatic void niu_pci_free_coherent(struct device *dev, size_t size,\r\nvoid *cpu_addr, u64 handle)\r\n{\r\ndma_free_coherent(dev, size, cpu_addr, handle);\r\n}\r\nstatic u64 niu_pci_map_page(struct device *dev, struct page *page,\r\nunsigned long offset, size_t size,\r\nenum dma_data_direction direction)\r\n{\r\nreturn dma_map_page(dev, page, offset, size, direction);\r\n}\r\nstatic void niu_pci_unmap_page(struct device *dev, u64 dma_address,\r\nsize_t size, enum dma_data_direction direction)\r\n{\r\ndma_unmap_page(dev, dma_address, size, direction);\r\n}\r\nstatic u64 niu_pci_map_single(struct device *dev, void *cpu_addr,\r\nsize_t size,\r\nenum dma_data_direction direction)\r\n{\r\nreturn dma_map_single(dev, cpu_addr, size, direction);\r\n}\r\nstatic void niu_pci_unmap_single(struct device *dev, u64 dma_address,\r\nsize_t size,\r\nenum dma_data_direction direction)\r\n{\r\ndma_unmap_single(dev, dma_address, size, direction);\r\n}\r\nstatic void niu_driver_version(void)\r\n{\r\nstatic int niu_version_printed;\r\nif (niu_version_printed++ == 0)\r\npr_info("%s", version);\r\n}\r\nstatic struct net_device *niu_alloc_and_init(struct device *gen_dev,\r\nstruct pci_dev *pdev,\r\nstruct platform_device *op,\r\nconst struct niu_ops *ops, u8 port)\r\n{\r\nstruct net_device *dev;\r\nstruct niu *np;\r\ndev = alloc_etherdev_mq(sizeof(struct niu), NIU_NUM_TXCHAN);\r\nif (!dev)\r\nreturn NULL;\r\nSET_NETDEV_DEV(dev, gen_dev);\r\nnp = netdev_priv(dev);\r\nnp->dev = dev;\r\nnp->pdev = pdev;\r\nnp->op = op;\r\nnp->device = gen_dev;\r\nnp->ops = ops;\r\nnp->msg_enable = niu_debug;\r\nspin_lock_init(&np->lock);\r\nINIT_WORK(&np->reset_task, niu_reset_task);\r\nnp->port = port;\r\nreturn dev;\r\n}\r\nstatic void niu_assign_netdev_ops(struct net_device *dev)\r\n{\r\ndev->netdev_ops = &niu_netdev_ops;\r\ndev->ethtool_ops = &niu_ethtool_ops;\r\ndev->watchdog_timeo = NIU_TX_TIMEOUT;\r\n}\r\nstatic void niu_device_announce(struct niu *np)\r\n{\r\nstruct net_device *dev = np->dev;\r\npr_info("%s: NIU Ethernet %pM\n", dev->name, dev->dev_addr);\r\nif (np->parent->plat_type == PLAT_TYPE_ATCA_CP3220) {\r\npr_info("%s: Port type[%s] mode[%s:%s] XCVR[%s] phy[%s]\n",\r\ndev->name,\r\n(np->flags & NIU_FLAGS_XMAC ? "XMAC" : "BMAC"),\r\n(np->flags & NIU_FLAGS_10G ? "10G" : "1G"),\r\n(np->flags & NIU_FLAGS_FIBER ? "RGMII FIBER" : "SERDES"),\r\n(np->mac_xcvr == MAC_XCVR_MII ? "MII" :\r\n(np->mac_xcvr == MAC_XCVR_PCS ? "PCS" : "XPCS")),\r\nnp->vpd.phy_type);\r\n} else {\r\npr_info("%s: Port type[%s] mode[%s:%s] XCVR[%s] phy[%s]\n",\r\ndev->name,\r\n(np->flags & NIU_FLAGS_XMAC ? "XMAC" : "BMAC"),\r\n(np->flags & NIU_FLAGS_10G ? "10G" : "1G"),\r\n(np->flags & NIU_FLAGS_FIBER ? "FIBER" :\r\n(np->flags & NIU_FLAGS_XCVR_SERDES ? "SERDES" :\r\n"COPPER")),\r\n(np->mac_xcvr == MAC_XCVR_MII ? "MII" :\r\n(np->mac_xcvr == MAC_XCVR_PCS ? "PCS" : "XPCS")),\r\nnp->vpd.phy_type);\r\n}\r\n}\r\nstatic void niu_set_basic_features(struct net_device *dev)\r\n{\r\ndev->hw_features = NETIF_F_SG | NETIF_F_HW_CSUM | NETIF_F_RXHASH;\r\ndev->features |= dev->hw_features | NETIF_F_RXCSUM;\r\n}\r\nstatic int niu_pci_init_one(struct pci_dev *pdev,\r\nconst struct pci_device_id *ent)\r\n{\r\nunion niu_parent_id parent_id;\r\nstruct net_device *dev;\r\nstruct niu *np;\r\nint err;\r\nu64 dma_mask;\r\nniu_driver_version();\r\nerr = pci_enable_device(pdev);\r\nif (err) {\r\ndev_err(&pdev->dev, "Cannot enable PCI device, aborting\n");\r\nreturn err;\r\n}\r\nif (!(pci_resource_flags(pdev, 0) & IORESOURCE_MEM) ||\r\n!(pci_resource_flags(pdev, 2) & IORESOURCE_MEM)) {\r\ndev_err(&pdev->dev, "Cannot find proper PCI device base addresses, aborting\n");\r\nerr = -ENODEV;\r\ngoto err_out_disable_pdev;\r\n}\r\nerr = pci_request_regions(pdev, DRV_MODULE_NAME);\r\nif (err) {\r\ndev_err(&pdev->dev, "Cannot obtain PCI resources, aborting\n");\r\ngoto err_out_disable_pdev;\r\n}\r\nif (!pci_is_pcie(pdev)) {\r\ndev_err(&pdev->dev, "Cannot find PCI Express capability, aborting\n");\r\nerr = -ENODEV;\r\ngoto err_out_free_res;\r\n}\r\ndev = niu_alloc_and_init(&pdev->dev, pdev, NULL,\r\n&niu_pci_ops, PCI_FUNC(pdev->devfn));\r\nif (!dev) {\r\nerr = -ENOMEM;\r\ngoto err_out_free_res;\r\n}\r\nnp = netdev_priv(dev);\r\nmemset(&parent_id, 0, sizeof(parent_id));\r\nparent_id.pci.domain = pci_domain_nr(pdev->bus);\r\nparent_id.pci.bus = pdev->bus->number;\r\nparent_id.pci.device = PCI_SLOT(pdev->devfn);\r\nnp->parent = niu_get_parent(np, &parent_id,\r\nPLAT_TYPE_ATLAS);\r\nif (!np->parent) {\r\nerr = -ENOMEM;\r\ngoto err_out_free_dev;\r\n}\r\npcie_capability_clear_and_set_word(pdev, PCI_EXP_DEVCTL,\r\nPCI_EXP_DEVCTL_NOSNOOP_EN,\r\nPCI_EXP_DEVCTL_CERE | PCI_EXP_DEVCTL_NFERE |\r\nPCI_EXP_DEVCTL_FERE | PCI_EXP_DEVCTL_URRE |\r\nPCI_EXP_DEVCTL_RELAX_EN);\r\ndma_mask = DMA_BIT_MASK(44);\r\nerr = pci_set_dma_mask(pdev, dma_mask);\r\nif (!err) {\r\ndev->features |= NETIF_F_HIGHDMA;\r\nerr = pci_set_consistent_dma_mask(pdev, dma_mask);\r\nif (err) {\r\ndev_err(&pdev->dev, "Unable to obtain 44 bit DMA for consistent allocations, aborting\n");\r\ngoto err_out_release_parent;\r\n}\r\n}\r\nif (err) {\r\nerr = pci_set_dma_mask(pdev, DMA_BIT_MASK(32));\r\nif (err) {\r\ndev_err(&pdev->dev, "No usable DMA configuration, aborting\n");\r\ngoto err_out_release_parent;\r\n}\r\n}\r\nniu_set_basic_features(dev);\r\ndev->priv_flags |= IFF_UNICAST_FLT;\r\nnp->regs = pci_ioremap_bar(pdev, 0);\r\nif (!np->regs) {\r\ndev_err(&pdev->dev, "Cannot map device registers, aborting\n");\r\nerr = -ENOMEM;\r\ngoto err_out_release_parent;\r\n}\r\npci_set_master(pdev);\r\npci_save_state(pdev);\r\ndev->irq = pdev->irq;\r\nniu_assign_netdev_ops(dev);\r\nerr = niu_get_invariants(np);\r\nif (err) {\r\nif (err != -ENODEV)\r\ndev_err(&pdev->dev, "Problem fetching invariants of chip, aborting\n");\r\ngoto err_out_iounmap;\r\n}\r\nerr = register_netdev(dev);\r\nif (err) {\r\ndev_err(&pdev->dev, "Cannot register net device, aborting\n");\r\ngoto err_out_iounmap;\r\n}\r\npci_set_drvdata(pdev, dev);\r\nniu_device_announce(np);\r\nreturn 0;\r\nerr_out_iounmap:\r\nif (np->regs) {\r\niounmap(np->regs);\r\nnp->regs = NULL;\r\n}\r\nerr_out_release_parent:\r\nniu_put_parent(np);\r\nerr_out_free_dev:\r\nfree_netdev(dev);\r\nerr_out_free_res:\r\npci_release_regions(pdev);\r\nerr_out_disable_pdev:\r\npci_disable_device(pdev);\r\nreturn err;\r\n}\r\nstatic void niu_pci_remove_one(struct pci_dev *pdev)\r\n{\r\nstruct net_device *dev = pci_get_drvdata(pdev);\r\nif (dev) {\r\nstruct niu *np = netdev_priv(dev);\r\nunregister_netdev(dev);\r\nif (np->regs) {\r\niounmap(np->regs);\r\nnp->regs = NULL;\r\n}\r\nniu_ldg_free(np);\r\nniu_put_parent(np);\r\nfree_netdev(dev);\r\npci_release_regions(pdev);\r\npci_disable_device(pdev);\r\n}\r\n}\r\nstatic int niu_suspend(struct pci_dev *pdev, pm_message_t state)\r\n{\r\nstruct net_device *dev = pci_get_drvdata(pdev);\r\nstruct niu *np = netdev_priv(dev);\r\nunsigned long flags;\r\nif (!netif_running(dev))\r\nreturn 0;\r\nflush_work(&np->reset_task);\r\nniu_netif_stop(np);\r\ndel_timer_sync(&np->timer);\r\nspin_lock_irqsave(&np->lock, flags);\r\nniu_enable_interrupts(np, 0);\r\nspin_unlock_irqrestore(&np->lock, flags);\r\nnetif_device_detach(dev);\r\nspin_lock_irqsave(&np->lock, flags);\r\nniu_stop_hw(np);\r\nspin_unlock_irqrestore(&np->lock, flags);\r\npci_save_state(pdev);\r\nreturn 0;\r\n}\r\nstatic int niu_resume(struct pci_dev *pdev)\r\n{\r\nstruct net_device *dev = pci_get_drvdata(pdev);\r\nstruct niu *np = netdev_priv(dev);\r\nunsigned long flags;\r\nint err;\r\nif (!netif_running(dev))\r\nreturn 0;\r\npci_restore_state(pdev);\r\nnetif_device_attach(dev);\r\nspin_lock_irqsave(&np->lock, flags);\r\nerr = niu_init_hw(np);\r\nif (!err) {\r\nnp->timer.expires = jiffies + HZ;\r\nadd_timer(&np->timer);\r\nniu_netif_start(np);\r\n}\r\nspin_unlock_irqrestore(&np->lock, flags);\r\nreturn err;\r\n}\r\nstatic void *niu_phys_alloc_coherent(struct device *dev, size_t size,\r\nu64 *dma_addr, gfp_t flag)\r\n{\r\nunsigned long order = get_order(size);\r\nunsigned long page = __get_free_pages(flag, order);\r\nif (page == 0UL)\r\nreturn NULL;\r\nmemset((char *)page, 0, PAGE_SIZE << order);\r\n*dma_addr = __pa(page);\r\nreturn (void *) page;\r\n}\r\nstatic void niu_phys_free_coherent(struct device *dev, size_t size,\r\nvoid *cpu_addr, u64 handle)\r\n{\r\nunsigned long order = get_order(size);\r\nfree_pages((unsigned long) cpu_addr, order);\r\n}\r\nstatic u64 niu_phys_map_page(struct device *dev, struct page *page,\r\nunsigned long offset, size_t size,\r\nenum dma_data_direction direction)\r\n{\r\nreturn page_to_phys(page) + offset;\r\n}\r\nstatic void niu_phys_unmap_page(struct device *dev, u64 dma_address,\r\nsize_t size, enum dma_data_direction direction)\r\n{\r\n}\r\nstatic u64 niu_phys_map_single(struct device *dev, void *cpu_addr,\r\nsize_t size,\r\nenum dma_data_direction direction)\r\n{\r\nreturn __pa(cpu_addr);\r\n}\r\nstatic void niu_phys_unmap_single(struct device *dev, u64 dma_address,\r\nsize_t size,\r\nenum dma_data_direction direction)\r\n{\r\n}\r\nstatic int niu_of_probe(struct platform_device *op)\r\n{\r\nunion niu_parent_id parent_id;\r\nstruct net_device *dev;\r\nstruct niu *np;\r\nconst u32 *reg;\r\nint err;\r\nniu_driver_version();\r\nreg = of_get_property(op->dev.of_node, "reg", NULL);\r\nif (!reg) {\r\ndev_err(&op->dev, "%s: No 'reg' property, aborting\n",\r\nop->dev.of_node->full_name);\r\nreturn -ENODEV;\r\n}\r\ndev = niu_alloc_and_init(&op->dev, NULL, op,\r\n&niu_phys_ops, reg[0] & 0x1);\r\nif (!dev) {\r\nerr = -ENOMEM;\r\ngoto err_out;\r\n}\r\nnp = netdev_priv(dev);\r\nmemset(&parent_id, 0, sizeof(parent_id));\r\nparent_id.of = of_get_parent(op->dev.of_node);\r\nnp->parent = niu_get_parent(np, &parent_id,\r\nPLAT_TYPE_NIU);\r\nif (!np->parent) {\r\nerr = -ENOMEM;\r\ngoto err_out_free_dev;\r\n}\r\nniu_set_basic_features(dev);\r\nnp->regs = of_ioremap(&op->resource[1], 0,\r\nresource_size(&op->resource[1]),\r\n"niu regs");\r\nif (!np->regs) {\r\ndev_err(&op->dev, "Cannot map device registers, aborting\n");\r\nerr = -ENOMEM;\r\ngoto err_out_release_parent;\r\n}\r\nnp->vir_regs_1 = of_ioremap(&op->resource[2], 0,\r\nresource_size(&op->resource[2]),\r\n"niu vregs-1");\r\nif (!np->vir_regs_1) {\r\ndev_err(&op->dev, "Cannot map device vir registers 1, aborting\n");\r\nerr = -ENOMEM;\r\ngoto err_out_iounmap;\r\n}\r\nnp->vir_regs_2 = of_ioremap(&op->resource[3], 0,\r\nresource_size(&op->resource[3]),\r\n"niu vregs-2");\r\nif (!np->vir_regs_2) {\r\ndev_err(&op->dev, "Cannot map device vir registers 2, aborting\n");\r\nerr = -ENOMEM;\r\ngoto err_out_iounmap;\r\n}\r\nniu_assign_netdev_ops(dev);\r\nerr = niu_get_invariants(np);\r\nif (err) {\r\nif (err != -ENODEV)\r\ndev_err(&op->dev, "Problem fetching invariants of chip, aborting\n");\r\ngoto err_out_iounmap;\r\n}\r\nerr = register_netdev(dev);\r\nif (err) {\r\ndev_err(&op->dev, "Cannot register net device, aborting\n");\r\ngoto err_out_iounmap;\r\n}\r\nplatform_set_drvdata(op, dev);\r\nniu_device_announce(np);\r\nreturn 0;\r\nerr_out_iounmap:\r\nif (np->vir_regs_1) {\r\nof_iounmap(&op->resource[2], np->vir_regs_1,\r\nresource_size(&op->resource[2]));\r\nnp->vir_regs_1 = NULL;\r\n}\r\nif (np->vir_regs_2) {\r\nof_iounmap(&op->resource[3], np->vir_regs_2,\r\nresource_size(&op->resource[3]));\r\nnp->vir_regs_2 = NULL;\r\n}\r\nif (np->regs) {\r\nof_iounmap(&op->resource[1], np->regs,\r\nresource_size(&op->resource[1]));\r\nnp->regs = NULL;\r\n}\r\nerr_out_release_parent:\r\nniu_put_parent(np);\r\nerr_out_free_dev:\r\nfree_netdev(dev);\r\nerr_out:\r\nreturn err;\r\n}\r\nstatic int niu_of_remove(struct platform_device *op)\r\n{\r\nstruct net_device *dev = platform_get_drvdata(op);\r\nif (dev) {\r\nstruct niu *np = netdev_priv(dev);\r\nunregister_netdev(dev);\r\nif (np->vir_regs_1) {\r\nof_iounmap(&op->resource[2], np->vir_regs_1,\r\nresource_size(&op->resource[2]));\r\nnp->vir_regs_1 = NULL;\r\n}\r\nif (np->vir_regs_2) {\r\nof_iounmap(&op->resource[3], np->vir_regs_2,\r\nresource_size(&op->resource[3]));\r\nnp->vir_regs_2 = NULL;\r\n}\r\nif (np->regs) {\r\nof_iounmap(&op->resource[1], np->regs,\r\nresource_size(&op->resource[1]));\r\nnp->regs = NULL;\r\n}\r\nniu_ldg_free(np);\r\nniu_put_parent(np);\r\nfree_netdev(dev);\r\n}\r\nreturn 0;\r\n}\r\nstatic int __init niu_init(void)\r\n{\r\nint err = 0;\r\nBUILD_BUG_ON(PAGE_SIZE < 4 * 1024);\r\nniu_debug = netif_msg_init(debug, NIU_MSG_DEFAULT);\r\n#ifdef CONFIG_SPARC64\r\nerr = platform_driver_register(&niu_of_driver);\r\n#endif\r\nif (!err) {\r\nerr = pci_register_driver(&niu_pci_driver);\r\n#ifdef CONFIG_SPARC64\r\nif (err)\r\nplatform_driver_unregister(&niu_of_driver);\r\n#endif\r\n}\r\nreturn err;\r\n}\r\nstatic void __exit niu_exit(void)\r\n{\r\npci_unregister_driver(&niu_pci_driver);\r\n#ifdef CONFIG_SPARC64\r\nplatform_driver_unregister(&niu_of_driver);\r\n#endif\r\n}
