static int tcf_pedit_init(struct net *net, struct nlattr *nla,\r\nstruct nlattr *est, struct tc_action *a,\r\nint ovr, int bind)\r\n{\r\nstruct nlattr *tb[TCA_PEDIT_MAX + 1];\r\nstruct tc_pedit *parm;\r\nint ret = 0, err;\r\nstruct tcf_pedit *p;\r\nstruct tc_pedit_key *keys = NULL;\r\nint ksize;\r\nif (nla == NULL)\r\nreturn -EINVAL;\r\nerr = nla_parse_nested(tb, TCA_PEDIT_MAX, nla, pedit_policy);\r\nif (err < 0)\r\nreturn err;\r\nif (tb[TCA_PEDIT_PARMS] == NULL)\r\nreturn -EINVAL;\r\nparm = nla_data(tb[TCA_PEDIT_PARMS]);\r\nksize = parm->nkeys * sizeof(struct tc_pedit_key);\r\nif (nla_len(tb[TCA_PEDIT_PARMS]) < sizeof(*parm) + ksize)\r\nreturn -EINVAL;\r\nif (!tcf_hash_check(parm->index, a, bind)) {\r\nif (!parm->nkeys)\r\nreturn -EINVAL;\r\nret = tcf_hash_create(parm->index, est, a, sizeof(*p),\r\nbind, false);\r\nif (ret)\r\nreturn ret;\r\np = to_pedit(a);\r\nkeys = kmalloc(ksize, GFP_KERNEL);\r\nif (keys == NULL) {\r\ntcf_hash_cleanup(a, est);\r\nreturn -ENOMEM;\r\n}\r\nret = ACT_P_CREATED;\r\n} else {\r\nif (bind)\r\nreturn 0;\r\ntcf_hash_release(a, bind);\r\nif (!ovr)\r\nreturn -EEXIST;\r\np = to_pedit(a);\r\nif (p->tcfp_nkeys && p->tcfp_nkeys != parm->nkeys) {\r\nkeys = kmalloc(ksize, GFP_KERNEL);\r\nif (keys == NULL)\r\nreturn -ENOMEM;\r\n}\r\n}\r\nspin_lock_bh(&p->tcf_lock);\r\np->tcfp_flags = parm->flags;\r\np->tcf_action = parm->action;\r\nif (keys) {\r\nkfree(p->tcfp_keys);\r\np->tcfp_keys = keys;\r\np->tcfp_nkeys = parm->nkeys;\r\n}\r\nmemcpy(p->tcfp_keys, parm->keys, ksize);\r\nspin_unlock_bh(&p->tcf_lock);\r\nif (ret == ACT_P_CREATED)\r\ntcf_hash_insert(a);\r\nreturn ret;\r\n}\r\nstatic void tcf_pedit_cleanup(struct tc_action *a, int bind)\r\n{\r\nstruct tcf_pedit *p = a->priv;\r\nstruct tc_pedit_key *keys = p->tcfp_keys;\r\nkfree(keys);\r\n}\r\nstatic int tcf_pedit(struct sk_buff *skb, const struct tc_action *a,\r\nstruct tcf_result *res)\r\n{\r\nstruct tcf_pedit *p = a->priv;\r\nint i;\r\nunsigned int off;\r\nif (skb_unclone(skb, GFP_ATOMIC))\r\nreturn p->tcf_action;\r\noff = skb_network_offset(skb);\r\nspin_lock(&p->tcf_lock);\r\np->tcf_tm.lastuse = jiffies;\r\nif (p->tcfp_nkeys > 0) {\r\nstruct tc_pedit_key *tkey = p->tcfp_keys;\r\nfor (i = p->tcfp_nkeys; i > 0; i--, tkey++) {\r\nu32 *ptr, _data;\r\nint offset = tkey->off;\r\nif (tkey->offmask) {\r\nchar *d, _d;\r\nd = skb_header_pointer(skb, off + tkey->at, 1,\r\n&_d);\r\nif (!d)\r\ngoto bad;\r\noffset += (*d & tkey->offmask) >> tkey->shift;\r\n}\r\nif (offset % 4) {\r\npr_info("tc filter pedit"\r\n" offset must be on 32 bit boundaries\n");\r\ngoto bad;\r\n}\r\nif (offset > 0 && offset > skb->len) {\r\npr_info("tc filter pedit"\r\n" offset %d can't exceed pkt length %d\n",\r\noffset, skb->len);\r\ngoto bad;\r\n}\r\nptr = skb_header_pointer(skb, off + offset, 4, &_data);\r\nif (!ptr)\r\ngoto bad;\r\n*ptr = ((*ptr & tkey->mask) ^ tkey->val);\r\nif (ptr == &_data)\r\nskb_store_bits(skb, off + offset, ptr, 4);\r\n}\r\ngoto done;\r\n} else\r\nWARN(1, "pedit BUG: index %d\n", p->tcf_index);\r\nbad:\r\np->tcf_qstats.overlimits++;\r\ndone:\r\nbstats_update(&p->tcf_bstats, skb);\r\nspin_unlock(&p->tcf_lock);\r\nreturn p->tcf_action;\r\n}\r\nstatic int tcf_pedit_dump(struct sk_buff *skb, struct tc_action *a,\r\nint bind, int ref)\r\n{\r\nunsigned char *b = skb_tail_pointer(skb);\r\nstruct tcf_pedit *p = a->priv;\r\nstruct tc_pedit *opt;\r\nstruct tcf_t t;\r\nint s;\r\ns = sizeof(*opt) + p->tcfp_nkeys * sizeof(struct tc_pedit_key);\r\nopt = kzalloc(s, GFP_ATOMIC);\r\nif (unlikely(!opt))\r\nreturn -ENOBUFS;\r\nmemcpy(opt->keys, p->tcfp_keys,\r\np->tcfp_nkeys * sizeof(struct tc_pedit_key));\r\nopt->index = p->tcf_index;\r\nopt->nkeys = p->tcfp_nkeys;\r\nopt->flags = p->tcfp_flags;\r\nopt->action = p->tcf_action;\r\nopt->refcnt = p->tcf_refcnt - ref;\r\nopt->bindcnt = p->tcf_bindcnt - bind;\r\nif (nla_put(skb, TCA_PEDIT_PARMS, s, opt))\r\ngoto nla_put_failure;\r\nt.install = jiffies_to_clock_t(jiffies - p->tcf_tm.install);\r\nt.lastuse = jiffies_to_clock_t(jiffies - p->tcf_tm.lastuse);\r\nt.expires = jiffies_to_clock_t(p->tcf_tm.expires);\r\nif (nla_put(skb, TCA_PEDIT_TM, sizeof(t), &t))\r\ngoto nla_put_failure;\r\nkfree(opt);\r\nreturn skb->len;\r\nnla_put_failure:\r\nnlmsg_trim(skb, b);\r\nkfree(opt);\r\nreturn -1;\r\n}\r\nstatic int __init pedit_init_module(void)\r\n{\r\nreturn tcf_register_action(&act_pedit_ops, PEDIT_TAB_MASK);\r\n}\r\nstatic void __exit pedit_cleanup_module(void)\r\n{\r\ntcf_unregister_action(&act_pedit_ops);\r\n}
