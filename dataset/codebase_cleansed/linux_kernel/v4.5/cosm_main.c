static void cosm_hw_reset(struct cosm_device *cdev, bool force)\r\n{\r\nint i;\r\n#define MIC_RESET_TO (45)\r\nif (force && cdev->hw_ops->force_reset)\r\ncdev->hw_ops->force_reset(cdev);\r\nelse\r\ncdev->hw_ops->reset(cdev);\r\nfor (i = 0; i < MIC_RESET_TO; i++) {\r\nif (cdev->hw_ops->ready(cdev)) {\r\ncosm_set_state(cdev, MIC_READY);\r\nreturn;\r\n}\r\nmsleep(1000);\r\n}\r\ncosm_set_state(cdev, MIC_RESET_FAILED);\r\n}\r\nint cosm_start(struct cosm_device *cdev)\r\n{\r\nconst struct cred *orig_cred;\r\nstruct cred *override_cred;\r\nint rc;\r\nmutex_lock(&cdev->cosm_mutex);\r\nif (!cdev->bootmode) {\r\ndev_err(&cdev->dev, "%s %d bootmode not set\n",\r\n__func__, __LINE__);\r\nrc = -EINVAL;\r\ngoto unlock_ret;\r\n}\r\nretry:\r\nif (cdev->state != MIC_READY) {\r\ndev_err(&cdev->dev, "%s %d MIC state not READY\n",\r\n__func__, __LINE__);\r\nrc = -EINVAL;\r\ngoto unlock_ret;\r\n}\r\nif (!cdev->hw_ops->ready(cdev)) {\r\ncosm_hw_reset(cdev, false);\r\ngoto retry;\r\n}\r\noverride_cred = prepare_creds();\r\nif (!override_cred) {\r\ndev_err(&cdev->dev, "%s %d prepare_creds failed\n",\r\n__func__, __LINE__);\r\nrc = -ENOMEM;\r\ngoto unlock_ret;\r\n}\r\noverride_cred->fsuid = GLOBAL_ROOT_UID;\r\norig_cred = override_creds(override_cred);\r\nrc = cdev->hw_ops->start(cdev, cdev->index);\r\nrevert_creds(orig_cred);\r\nput_cred(override_cred);\r\nif (rc)\r\ngoto unlock_ret;\r\nif (!strcmp(cdev->bootmode, "linux"))\r\ncosm_set_state(cdev, MIC_BOOTING);\r\nelse\r\ncosm_set_state(cdev, MIC_ONLINE);\r\nunlock_ret:\r\nmutex_unlock(&cdev->cosm_mutex);\r\nif (rc)\r\ndev_err(&cdev->dev, "cosm_start failed rc %d\n", rc);\r\nreturn rc;\r\n}\r\nvoid cosm_stop(struct cosm_device *cdev, bool force)\r\n{\r\nmutex_lock(&cdev->cosm_mutex);\r\nif (cdev->state != MIC_READY || force) {\r\nbool call_hw_ops = cdev->state != MIC_RESET_FAILED &&\r\ncdev->state != MIC_READY;\r\nif (cdev->state != MIC_RESETTING)\r\ncosm_set_state(cdev, MIC_RESETTING);\r\ncdev->heartbeat_watchdog_enable = false;\r\nif (call_hw_ops)\r\ncdev->hw_ops->stop(cdev, force);\r\ncosm_hw_reset(cdev, force);\r\ncosm_set_shutdown_status(cdev, MIC_NOP);\r\nif (call_hw_ops && cdev->hw_ops->post_reset)\r\ncdev->hw_ops->post_reset(cdev, cdev->state);\r\n}\r\nmutex_unlock(&cdev->cosm_mutex);\r\nflush_work(&cdev->scif_work);\r\n}\r\nstatic void cosm_reset_trigger_work(struct work_struct *work)\r\n{\r\nstruct cosm_device *cdev = container_of(work, struct cosm_device,\r\nreset_trigger_work);\r\ncosm_stop(cdev, false);\r\n}\r\nint cosm_reset(struct cosm_device *cdev)\r\n{\r\nint rc = 0;\r\nmutex_lock(&cdev->cosm_mutex);\r\nif (cdev->state != MIC_READY) {\r\ncosm_set_state(cdev, MIC_RESETTING);\r\nschedule_work(&cdev->reset_trigger_work);\r\n} else {\r\ndev_err(&cdev->dev, "%s %d MIC is READY\n", __func__, __LINE__);\r\nrc = -EINVAL;\r\n}\r\nmutex_unlock(&cdev->cosm_mutex);\r\nreturn rc;\r\n}\r\nint cosm_shutdown(struct cosm_device *cdev)\r\n{\r\nstruct cosm_msg msg = { .id = COSM_MSG_SHUTDOWN };\r\nint rc = 0;\r\nmutex_lock(&cdev->cosm_mutex);\r\nif (cdev->state != MIC_ONLINE) {\r\nrc = -EINVAL;\r\ndev_err(&cdev->dev, "%s %d skipping shutdown in state: %s\n",\r\n__func__, __LINE__, cosm_state_string[cdev->state]);\r\ngoto err;\r\n}\r\nif (!cdev->epd) {\r\nrc = -ENOTCONN;\r\ndev_err(&cdev->dev, "%s %d scif endpoint not connected rc %d\n",\r\n__func__, __LINE__, rc);\r\ngoto err;\r\n}\r\nrc = scif_send(cdev->epd, &msg, sizeof(msg), SCIF_SEND_BLOCK);\r\nif (rc < 0) {\r\ndev_err(&cdev->dev, "%s %d scif_send failed rc %d\n",\r\n__func__, __LINE__, rc);\r\ngoto err;\r\n}\r\ncdev->heartbeat_watchdog_enable = false;\r\ncosm_set_state(cdev, MIC_SHUTTING_DOWN);\r\nrc = 0;\r\nerr:\r\nmutex_unlock(&cdev->cosm_mutex);\r\nreturn rc;\r\n}\r\nstatic int cosm_driver_probe(struct cosm_device *cdev)\r\n{\r\nint rc;\r\nif (atomic_add_return(1, &g_num_dev) == 1) {\r\nrc = cosm_scif_init();\r\nif (rc)\r\ngoto scif_exit;\r\n}\r\nmutex_init(&cdev->cosm_mutex);\r\nINIT_WORK(&cdev->reset_trigger_work, cosm_reset_trigger_work);\r\nINIT_WORK(&cdev->scif_work, cosm_scif_work);\r\ncdev->sysfs_heartbeat_enable = true;\r\ncosm_sysfs_init(cdev);\r\ncdev->sdev = device_create_with_groups(g_cosm_class, cdev->dev.parent,\r\nMKDEV(0, cdev->index), cdev, cdev->attr_group,\r\n"mic%d", cdev->index);\r\nif (IS_ERR(cdev->sdev)) {\r\nrc = PTR_ERR(cdev->sdev);\r\ndev_err(&cdev->dev, "device_create_with_groups failed rc %d\n",\r\nrc);\r\ngoto scif_exit;\r\n}\r\ncdev->state_sysfs = sysfs_get_dirent(cdev->sdev->kobj.sd,\r\n"state");\r\nif (!cdev->state_sysfs) {\r\nrc = -ENODEV;\r\ndev_err(&cdev->dev, "sysfs_get_dirent failed rc %d\n", rc);\r\ngoto destroy_device;\r\n}\r\ncosm_create_debug_dir(cdev);\r\nreturn 0;\r\ndestroy_device:\r\ndevice_destroy(g_cosm_class, MKDEV(0, cdev->index));\r\nscif_exit:\r\nif (atomic_dec_and_test(&g_num_dev))\r\ncosm_scif_exit();\r\nreturn rc;\r\n}\r\nstatic void cosm_driver_remove(struct cosm_device *cdev)\r\n{\r\ncosm_delete_debug_dir(cdev);\r\nsysfs_put(cdev->state_sysfs);\r\ndevice_destroy(g_cosm_class, MKDEV(0, cdev->index));\r\nflush_work(&cdev->reset_trigger_work);\r\ncosm_stop(cdev, false);\r\nif (atomic_dec_and_test(&g_num_dev))\r\ncosm_scif_exit();\r\nkfree(cdev->cmdline);\r\nkfree(cdev->firmware);\r\nkfree(cdev->ramdisk);\r\nkfree(cdev->bootmode);\r\n}\r\nstatic int cosm_suspend(struct device *dev)\r\n{\r\nstruct cosm_device *cdev = dev_to_cosm(dev);\r\nmutex_lock(&cdev->cosm_mutex);\r\nswitch (cdev->state) {\r\ncase MIC_ONLINE:\r\ncase MIC_BOOTING:\r\ncase MIC_SHUTTING_DOWN:\r\nmutex_unlock(&cdev->cosm_mutex);\r\ncosm_stop(cdev, false);\r\nbreak;\r\ndefault:\r\nmutex_unlock(&cdev->cosm_mutex);\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic int __init cosm_init(void)\r\n{\r\nint ret;\r\ncosm_init_debugfs();\r\ng_cosm_class = class_create(THIS_MODULE, cosm_driver_name);\r\nif (IS_ERR(g_cosm_class)) {\r\nret = PTR_ERR(g_cosm_class);\r\npr_err("class_create failed ret %d\n", ret);\r\ngoto cleanup_debugfs;\r\n}\r\nida_init(&g_cosm_ida);\r\nret = cosm_register_driver(&cosm_driver);\r\nif (ret) {\r\npr_err("cosm_register_driver failed ret %d\n", ret);\r\ngoto ida_destroy;\r\n}\r\nreturn 0;\r\nida_destroy:\r\nida_destroy(&g_cosm_ida);\r\nclass_destroy(g_cosm_class);\r\ncleanup_debugfs:\r\ncosm_exit_debugfs();\r\nreturn ret;\r\n}\r\nstatic void __exit cosm_exit(void)\r\n{\r\ncosm_unregister_driver(&cosm_driver);\r\nida_destroy(&g_cosm_ida);\r\nclass_destroy(g_cosm_class);\r\ncosm_exit_debugfs();\r\n}
