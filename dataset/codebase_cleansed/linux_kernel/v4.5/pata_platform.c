static int pata_platform_set_mode(struct ata_link *link, struct ata_device **unused)\r\n{\r\nstruct ata_device *dev;\r\nata_for_each_dev(dev, link, ENABLED) {\r\ndev->pio_mode = dev->xfer_mode = XFER_PIO_0;\r\ndev->xfer_shift = ATA_SHIFT_PIO;\r\ndev->flags |= ATA_DFLAG_PIO;\r\nata_dev_info(dev, "configured for PIO\n");\r\n}\r\nreturn 0;\r\n}\r\nstatic void pata_platform_setup_port(struct ata_ioports *ioaddr,\r\nunsigned int shift)\r\n{\r\nioaddr->data_addr = ioaddr->cmd_addr + (ATA_REG_DATA << shift);\r\nioaddr->error_addr = ioaddr->cmd_addr + (ATA_REG_ERR << shift);\r\nioaddr->feature_addr = ioaddr->cmd_addr + (ATA_REG_FEATURE << shift);\r\nioaddr->nsect_addr = ioaddr->cmd_addr + (ATA_REG_NSECT << shift);\r\nioaddr->lbal_addr = ioaddr->cmd_addr + (ATA_REG_LBAL << shift);\r\nioaddr->lbam_addr = ioaddr->cmd_addr + (ATA_REG_LBAM << shift);\r\nioaddr->lbah_addr = ioaddr->cmd_addr + (ATA_REG_LBAH << shift);\r\nioaddr->device_addr = ioaddr->cmd_addr + (ATA_REG_DEVICE << shift);\r\nioaddr->status_addr = ioaddr->cmd_addr + (ATA_REG_STATUS << shift);\r\nioaddr->command_addr = ioaddr->cmd_addr + (ATA_REG_CMD << shift);\r\n}\r\nint __pata_platform_probe(struct device *dev, struct resource *io_res,\r\nstruct resource *ctl_res, struct resource *irq_res,\r\nunsigned int ioport_shift, int __pio_mask,\r\nstruct scsi_host_template *sht)\r\n{\r\nstruct ata_host *host;\r\nstruct ata_port *ap;\r\nunsigned int mmio;\r\nint irq = 0;\r\nint irq_flags = 0;\r\nmmio = (( io_res->flags == IORESOURCE_MEM) &&\r\n(ctl_res->flags == IORESOURCE_MEM));\r\nif (irq_res && irq_res->start > 0) {\r\nirq = irq_res->start;\r\nirq_flags = irq_res->flags & IRQF_TRIGGER_MASK;\r\n}\r\nhost = ata_host_alloc(dev, 1);\r\nif (!host)\r\nreturn -ENOMEM;\r\nap = host->ports[0];\r\nap->ops = &pata_platform_port_ops;\r\nap->pio_mask = __pio_mask;\r\nap->flags |= ATA_FLAG_SLAVE_POSS;\r\nif (!irq) {\r\nap->flags |= ATA_FLAG_PIO_POLLING;\r\nata_port_desc(ap, "no IRQ, using PIO polling");\r\n}\r\nif (mmio) {\r\nap->ioaddr.cmd_addr = devm_ioremap(dev, io_res->start,\r\nresource_size(io_res));\r\nap->ioaddr.ctl_addr = devm_ioremap(dev, ctl_res->start,\r\nresource_size(ctl_res));\r\n} else {\r\nap->ioaddr.cmd_addr = devm_ioport_map(dev, io_res->start,\r\nresource_size(io_res));\r\nap->ioaddr.ctl_addr = devm_ioport_map(dev, ctl_res->start,\r\nresource_size(ctl_res));\r\n}\r\nif (!ap->ioaddr.cmd_addr || !ap->ioaddr.ctl_addr) {\r\ndev_err(dev, "failed to map IO/CTL base\n");\r\nreturn -ENOMEM;\r\n}\r\nap->ioaddr.altstatus_addr = ap->ioaddr.ctl_addr;\r\npata_platform_setup_port(&ap->ioaddr, ioport_shift);\r\nata_port_desc(ap, "%s cmd 0x%llx ctl 0x%llx", mmio ? "mmio" : "ioport",\r\n(unsigned long long)io_res->start,\r\n(unsigned long long)ctl_res->start);\r\nreturn ata_host_activate(host, irq, irq ? ata_sff_interrupt : NULL,\r\nirq_flags, sht);\r\n}\r\nstatic int pata_platform_probe(struct platform_device *pdev)\r\n{\r\nstruct resource *io_res;\r\nstruct resource *ctl_res;\r\nstruct resource *irq_res;\r\nstruct pata_platform_info *pp_info = dev_get_platdata(&pdev->dev);\r\nif ((pdev->num_resources != 3) && (pdev->num_resources != 2)) {\r\ndev_err(&pdev->dev, "invalid number of resources\n");\r\nreturn -EINVAL;\r\n}\r\nio_res = platform_get_resource(pdev, IORESOURCE_IO, 0);\r\nif (io_res == NULL) {\r\nio_res = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nif (unlikely(io_res == NULL))\r\nreturn -EINVAL;\r\n}\r\nctl_res = platform_get_resource(pdev, IORESOURCE_IO, 1);\r\nif (ctl_res == NULL) {\r\nctl_res = platform_get_resource(pdev, IORESOURCE_MEM, 1);\r\nif (unlikely(ctl_res == NULL))\r\nreturn -EINVAL;\r\n}\r\nirq_res = platform_get_resource(pdev, IORESOURCE_IRQ, 0);\r\nreturn __pata_platform_probe(&pdev->dev, io_res, ctl_res, irq_res,\r\npp_info ? pp_info->ioport_shift : 0,\r\npio_mask, &pata_platform_sht);\r\n}
