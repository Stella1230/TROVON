int build_id__mark_dso_hit(struct perf_tool *tool __maybe_unused,\r\nunion perf_event *event,\r\nstruct perf_sample *sample,\r\nstruct perf_evsel *evsel __maybe_unused,\r\nstruct machine *machine)\r\n{\r\nstruct addr_location al;\r\nu8 cpumode = event->header.misc & PERF_RECORD_MISC_CPUMODE_MASK;\r\nstruct thread *thread = machine__findnew_thread(machine, sample->pid,\r\nsample->tid);\r\nif (thread == NULL) {\r\npr_err("problem processing %d event, skipping it.\n",\r\nevent->header.type);\r\nreturn -1;\r\n}\r\nthread__find_addr_map(thread, cpumode, MAP__FUNCTION, sample->ip, &al);\r\nif (al.map != NULL)\r\nal.map->dso->hit = 1;\r\nthread__put(thread);\r\nreturn 0;\r\n}\r\nstatic int perf_event__exit_del_thread(struct perf_tool *tool __maybe_unused,\r\nunion perf_event *event,\r\nstruct perf_sample *sample\r\n__maybe_unused,\r\nstruct machine *machine)\r\n{\r\nstruct thread *thread = machine__findnew_thread(machine,\r\nevent->fork.pid,\r\nevent->fork.tid);\r\ndump_printf("(%d:%d):(%d:%d)\n", event->fork.pid, event->fork.tid,\r\nevent->fork.ppid, event->fork.ptid);\r\nif (thread) {\r\nmachine__remove_thread(machine, thread);\r\nthread__put(thread);\r\n}\r\nreturn 0;\r\n}\r\nint build_id__sprintf(const u8 *build_id, int len, char *bf)\r\n{\r\nchar *bid = bf;\r\nconst u8 *raw = build_id;\r\nint i;\r\nfor (i = 0; i < len; ++i) {\r\nsprintf(bid, "%02x", *raw);\r\n++raw;\r\nbid += 2;\r\n}\r\nreturn (bid - bf) + 1;\r\n}\r\nint sysfs__sprintf_build_id(const char *root_dir, char *sbuild_id)\r\n{\r\nchar notes[PATH_MAX];\r\nu8 build_id[BUILD_ID_SIZE];\r\nint ret;\r\nif (!root_dir)\r\nroot_dir = "";\r\nscnprintf(notes, sizeof(notes), "%s/sys/kernel/notes", root_dir);\r\nret = sysfs__read_build_id(notes, build_id, sizeof(build_id));\r\nif (ret < 0)\r\nreturn ret;\r\nreturn build_id__sprintf(build_id, sizeof(build_id), sbuild_id);\r\n}\r\nint filename__sprintf_build_id(const char *pathname, char *sbuild_id)\r\n{\r\nu8 build_id[BUILD_ID_SIZE];\r\nint ret;\r\nret = filename__read_build_id(pathname, build_id, sizeof(build_id));\r\nif (ret < 0)\r\nreturn ret;\r\nelse if (ret != sizeof(build_id))\r\nreturn -EINVAL;\r\nreturn build_id__sprintf(build_id, sizeof(build_id), sbuild_id);\r\n}\r\nstatic int asnprintf(char **strp, size_t size, const char *fmt, ...)\r\n{\r\nva_list ap;\r\nint ret;\r\nif (!strp)\r\nreturn -EINVAL;\r\nva_start(ap, fmt);\r\nif (*strp)\r\nret = vsnprintf(*strp, size, fmt, ap);\r\nelse\r\nret = vasprintf(strp, fmt, ap);\r\nva_end(ap);\r\nreturn ret;\r\n}\r\nstatic char *build_id__filename(const char *sbuild_id, char *bf, size_t size)\r\n{\r\nchar *tmp = bf;\r\nint ret = asnprintf(&bf, size, "%s/.build-id/%.2s/%s", buildid_dir,\r\nsbuild_id, sbuild_id + 2);\r\nif (ret < 0 || (tmp && size < (unsigned int)ret))\r\nreturn NULL;\r\nreturn bf;\r\n}\r\nchar *dso__build_id_filename(const struct dso *dso, char *bf, size_t size)\r\n{\r\nchar build_id_hex[SBUILD_ID_SIZE];\r\nif (!dso->has_build_id)\r\nreturn NULL;\r\nbuild_id__sprintf(dso->build_id, sizeof(dso->build_id), build_id_hex);\r\nreturn build_id__filename(build_id_hex, bf, size);\r\n}\r\nstatic int write_buildid(const char *name, size_t name_len, u8 *build_id,\r\npid_t pid, u16 misc, int fd)\r\n{\r\nint err;\r\nstruct build_id_event b;\r\nsize_t len;\r\nlen = name_len + 1;\r\nlen = PERF_ALIGN(len, NAME_ALIGN);\r\nmemset(&b, 0, sizeof(b));\r\nmemcpy(&b.build_id, build_id, BUILD_ID_SIZE);\r\nb.pid = pid;\r\nb.header.misc = misc;\r\nb.header.size = sizeof(b) + len;\r\nerr = writen(fd, &b, sizeof(b));\r\nif (err < 0)\r\nreturn err;\r\nreturn write_padded(fd, name, name_len + 1, len);\r\n}\r\nstatic int machine__write_buildid_table(struct machine *machine, int fd)\r\n{\r\nint err = 0;\r\nchar nm[PATH_MAX];\r\nstruct dso *pos;\r\nu16 kmisc = PERF_RECORD_MISC_KERNEL,\r\numisc = PERF_RECORD_MISC_USER;\r\nif (!machine__is_host(machine)) {\r\nkmisc = PERF_RECORD_MISC_GUEST_KERNEL;\r\numisc = PERF_RECORD_MISC_GUEST_USER;\r\n}\r\ndsos__for_each_with_build_id(pos, &machine->dsos.head) {\r\nconst char *name;\r\nsize_t name_len;\r\nif (!pos->hit)\r\ncontinue;\r\nif (dso__is_vdso(pos)) {\r\nname = pos->short_name;\r\nname_len = pos->short_name_len + 1;\r\n} else if (dso__is_kcore(pos)) {\r\nmachine__mmap_name(machine, nm, sizeof(nm));\r\nname = nm;\r\nname_len = strlen(nm) + 1;\r\n} else {\r\nname = pos->long_name;\r\nname_len = pos->long_name_len + 1;\r\n}\r\nerr = write_buildid(name, name_len, pos->build_id, machine->pid,\r\npos->kernel ? kmisc : umisc, fd);\r\nif (err)\r\nbreak;\r\n}\r\nreturn err;\r\n}\r\nint perf_session__write_buildid_table(struct perf_session *session, int fd)\r\n{\r\nstruct rb_node *nd;\r\nint err = machine__write_buildid_table(&session->machines.host, fd);\r\nif (err)\r\nreturn err;\r\nfor (nd = rb_first(&session->machines.guests); nd; nd = rb_next(nd)) {\r\nstruct machine *pos = rb_entry(nd, struct machine, rb_node);\r\nerr = machine__write_buildid_table(pos, fd);\r\nif (err)\r\nbreak;\r\n}\r\nreturn err;\r\n}\r\nstatic int __dsos__hit_all(struct list_head *head)\r\n{\r\nstruct dso *pos;\r\nlist_for_each_entry(pos, head, node)\r\npos->hit = true;\r\nreturn 0;\r\n}\r\nstatic int machine__hit_all_dsos(struct machine *machine)\r\n{\r\nreturn __dsos__hit_all(&machine->dsos.head);\r\n}\r\nint dsos__hit_all(struct perf_session *session)\r\n{\r\nstruct rb_node *nd;\r\nint err;\r\nerr = machine__hit_all_dsos(&session->machines.host);\r\nif (err)\r\nreturn err;\r\nfor (nd = rb_first(&session->machines.guests); nd; nd = rb_next(nd)) {\r\nstruct machine *pos = rb_entry(nd, struct machine, rb_node);\r\nerr = machine__hit_all_dsos(pos);\r\nif (err)\r\nreturn err;\r\n}\r\nreturn 0;\r\n}\r\nvoid disable_buildid_cache(void)\r\n{\r\nno_buildid_cache = true;\r\n}\r\nstatic char *build_id_cache__dirname_from_path(const char *name,\r\nbool is_kallsyms, bool is_vdso)\r\n{\r\nchar *realname = (char *)name, *filename;\r\nbool slash = is_kallsyms || is_vdso;\r\nif (!slash) {\r\nrealname = realpath(name, NULL);\r\nif (!realname)\r\nreturn NULL;\r\n}\r\nif (asprintf(&filename, "%s%s%s", buildid_dir, slash ? "/" : "",\r\nis_vdso ? DSO__NAME_VDSO : realname) < 0)\r\nfilename = NULL;\r\nif (!slash)\r\nfree(realname);\r\nreturn filename;\r\n}\r\nint build_id_cache__list_build_ids(const char *pathname,\r\nstruct strlist **result)\r\n{\r\nstruct strlist *list;\r\nchar *dir_name;\r\nDIR *dir;\r\nstruct dirent *d;\r\nint ret = 0;\r\nlist = strlist__new(NULL, NULL);\r\ndir_name = build_id_cache__dirname_from_path(pathname, false, false);\r\nif (!list || !dir_name) {\r\nret = -ENOMEM;\r\ngoto out;\r\n}\r\ndir = opendir(dir_name);\r\nif (!dir) {\r\nret = -errno;\r\ngoto out;\r\n}\r\nwhile ((d = readdir(dir)) != NULL) {\r\nif (!strcmp(d->d_name, ".") || !strcmp(d->d_name, ".."))\r\ncontinue;\r\nstrlist__add(list, d->d_name);\r\n}\r\nclosedir(dir);\r\nout:\r\nfree(dir_name);\r\nif (ret)\r\nstrlist__delete(list);\r\nelse\r\n*result = list;\r\nreturn ret;\r\n}\r\nint build_id_cache__add_s(const char *sbuild_id, const char *name,\r\nbool is_kallsyms, bool is_vdso)\r\n{\r\nconst size_t size = PATH_MAX;\r\nchar *realname = NULL, *filename = NULL, *dir_name = NULL,\r\n*linkname = zalloc(size), *targetname, *tmp;\r\nint err = -1;\r\nif (!is_kallsyms) {\r\nrealname = realpath(name, NULL);\r\nif (!realname)\r\ngoto out_free;\r\n}\r\ndir_name = build_id_cache__dirname_from_path(name, is_kallsyms, is_vdso);\r\nif (!dir_name)\r\ngoto out_free;\r\nif (mkdir_p(dir_name, 0755))\r\ngoto out_free;\r\nif (asprintf(&filename, "%s/%s", dir_name, sbuild_id) < 0) {\r\nfilename = NULL;\r\ngoto out_free;\r\n}\r\nif (access(filename, F_OK)) {\r\nif (is_kallsyms) {\r\nif (copyfile("/proc/kallsyms", filename))\r\ngoto out_free;\r\n} else if (link(realname, filename) && errno != EEXIST &&\r\ncopyfile(name, filename))\r\ngoto out_free;\r\n}\r\nif (!build_id__filename(sbuild_id, linkname, size))\r\ngoto out_free;\r\ntmp = strrchr(linkname, '/');\r\n*tmp = '\0';\r\nif (access(linkname, X_OK) && mkdir_p(linkname, 0755))\r\ngoto out_free;\r\n*tmp = '/';\r\ntargetname = filename + strlen(buildid_dir) - 5;\r\nmemcpy(targetname, "../..", 5);\r\nif (symlink(targetname, linkname) == 0)\r\nerr = 0;\r\nout_free:\r\nif (!is_kallsyms)\r\nfree(realname);\r\nfree(filename);\r\nfree(dir_name);\r\nfree(linkname);\r\nreturn err;\r\n}\r\nstatic int build_id_cache__add_b(const u8 *build_id, size_t build_id_size,\r\nconst char *name, bool is_kallsyms,\r\nbool is_vdso)\r\n{\r\nchar sbuild_id[SBUILD_ID_SIZE];\r\nbuild_id__sprintf(build_id, build_id_size, sbuild_id);\r\nreturn build_id_cache__add_s(sbuild_id, name, is_kallsyms, is_vdso);\r\n}\r\nbool build_id_cache__cached(const char *sbuild_id)\r\n{\r\nbool ret = false;\r\nchar *filename = build_id__filename(sbuild_id, NULL, 0);\r\nif (filename && !access(filename, F_OK))\r\nret = true;\r\nfree(filename);\r\nreturn ret;\r\n}\r\nint build_id_cache__remove_s(const char *sbuild_id)\r\n{\r\nconst size_t size = PATH_MAX;\r\nchar *filename = zalloc(size),\r\n*linkname = zalloc(size), *tmp;\r\nint err = -1;\r\nif (filename == NULL || linkname == NULL)\r\ngoto out_free;\r\nif (!build_id__filename(sbuild_id, linkname, size))\r\ngoto out_free;\r\nif (access(linkname, F_OK))\r\ngoto out_free;\r\nif (readlink(linkname, filename, size - 1) < 0)\r\ngoto out_free;\r\nif (unlink(linkname))\r\ngoto out_free;\r\ntmp = strrchr(linkname, '/') + 1;\r\nsnprintf(tmp, size - (tmp - linkname), "%s", filename);\r\nif (unlink(linkname))\r\ngoto out_free;\r\nerr = 0;\r\nout_free:\r\nfree(filename);\r\nfree(linkname);\r\nreturn err;\r\n}\r\nstatic int dso__cache_build_id(struct dso *dso, struct machine *machine)\r\n{\r\nbool is_kallsyms = dso->kernel && dso->long_name[0] != '/';\r\nbool is_vdso = dso__is_vdso(dso);\r\nconst char *name = dso->long_name;\r\nchar nm[PATH_MAX];\r\nif (dso__is_kcore(dso)) {\r\nis_kallsyms = true;\r\nmachine__mmap_name(machine, nm, sizeof(nm));\r\nname = nm;\r\n}\r\nreturn build_id_cache__add_b(dso->build_id, sizeof(dso->build_id), name,\r\nis_kallsyms, is_vdso);\r\n}\r\nstatic int __dsos__cache_build_ids(struct list_head *head,\r\nstruct machine *machine)\r\n{\r\nstruct dso *pos;\r\nint err = 0;\r\ndsos__for_each_with_build_id(pos, head)\r\nif (dso__cache_build_id(pos, machine))\r\nerr = -1;\r\nreturn err;\r\n}\r\nstatic int machine__cache_build_ids(struct machine *machine)\r\n{\r\nreturn __dsos__cache_build_ids(&machine->dsos.head, machine);\r\n}\r\nint perf_session__cache_build_ids(struct perf_session *session)\r\n{\r\nstruct rb_node *nd;\r\nint ret;\r\nif (no_buildid_cache)\r\nreturn 0;\r\nif (mkdir(buildid_dir, 0755) != 0 && errno != EEXIST)\r\nreturn -1;\r\nret = machine__cache_build_ids(&session->machines.host);\r\nfor (nd = rb_first(&session->machines.guests); nd; nd = rb_next(nd)) {\r\nstruct machine *pos = rb_entry(nd, struct machine, rb_node);\r\nret |= machine__cache_build_ids(pos);\r\n}\r\nreturn ret ? -1 : 0;\r\n}\r\nstatic bool machine__read_build_ids(struct machine *machine, bool with_hits)\r\n{\r\nreturn __dsos__read_build_ids(&machine->dsos.head, with_hits);\r\n}\r\nbool perf_session__read_build_ids(struct perf_session *session, bool with_hits)\r\n{\r\nstruct rb_node *nd;\r\nbool ret = machine__read_build_ids(&session->machines.host, with_hits);\r\nfor (nd = rb_first(&session->machines.guests); nd; nd = rb_next(nd)) {\r\nstruct machine *pos = rb_entry(nd, struct machine, rb_node);\r\nret |= machine__read_build_ids(pos, with_hits);\r\n}\r\nreturn ret;\r\n}
