static void smc_reset( int ioaddr )\r\n{\r\nSMC_SELECT_BANK( 0 );\r\noutw( RCR_SOFTRESET, ioaddr + RCR );\r\nSMC_DELAY( );\r\noutw( RCR_CLEAR, ioaddr + RCR );\r\noutw( TCR_CLEAR, ioaddr + TCR );\r\nSMC_SELECT_BANK( 1 );\r\noutw( inw( ioaddr + CONTROL ) | CTL_AUTO_RELEASE , ioaddr + CONTROL );\r\nSMC_SELECT_BANK( 2 );\r\noutw( MC_RESET, ioaddr + MMU_CMD );\r\noutb( 0, ioaddr + INT_MASK );\r\n}\r\nstatic void smc_enable( int ioaddr )\r\n{\r\nSMC_SELECT_BANK( 0 );\r\noutw( TCR_NORMAL, ioaddr + TCR );\r\noutw( RCR_NORMAL, ioaddr + RCR );\r\nSMC_SELECT_BANK( 2 );\r\noutb( SMC_INTERRUPT_MASK, ioaddr + INT_MASK );\r\n}\r\nstatic void smc_shutdown( int ioaddr )\r\n{\r\nSMC_SELECT_BANK( 2 );\r\noutb( 0, ioaddr + INT_MASK );\r\nSMC_SELECT_BANK( 0 );\r\noutb( RCR_CLEAR, ioaddr + RCR );\r\noutb( TCR_CLEAR, ioaddr + TCR );\r\n#if 0\r\nSMC_SELECT_BANK( 1 );\r\noutw( inw( ioaddr + CONTROL ), CTL_POWERDOWN, ioaddr + CONTROL );\r\n#endif\r\n}\r\nstatic void smc_setmulticast(int ioaddr, struct net_device *dev)\r\n{\r\nint i;\r\nunsigned char multicast_table[ 8 ];\r\nstruct netdev_hw_addr *ha;\r\nunsigned char invert3[] = { 0, 4, 2, 6, 1, 5, 3, 7 };\r\nmemset( multicast_table, 0, sizeof( multicast_table ) );\r\nnetdev_for_each_mc_addr(ha, dev) {\r\nint position;\r\nposition = ether_crc_le(6, ha->addr) & 0x3f;\r\nmulticast_table[invert3[position&7]] |=\r\n(1<<invert3[(position>>3)&7]);\r\n}\r\nSMC_SELECT_BANK( 3 );\r\nfor ( i = 0; i < 8 ; i++ ) {\r\noutb( multicast_table[i], ioaddr + MULTICAST1 + i );\r\n}\r\n}\r\nstatic netdev_tx_t smc_wait_to_send_packet(struct sk_buff *skb,\r\nstruct net_device *dev)\r\n{\r\nstruct smc_local *lp = netdev_priv(dev);\r\nunsigned int ioaddr = dev->base_addr;\r\nword length;\r\nunsigned short numPages;\r\nword time_out;\r\nnetif_stop_queue(dev);\r\nif ( lp->saved_skb) {\r\ndev->stats.tx_aborted_errors++;\r\nprintk(CARDNAME": Bad Craziness - sent packet while busy.\n" );\r\nreturn NETDEV_TX_BUSY;\r\n}\r\nlp->saved_skb = skb;\r\nlength = skb->len;\r\nif (length < ETH_ZLEN) {\r\nif (skb_padto(skb, ETH_ZLEN)) {\r\nnetif_wake_queue(dev);\r\nreturn NETDEV_TX_OK;\r\n}\r\nlength = ETH_ZLEN;\r\n}\r\nnumPages = ((length & 0xfffe) + 6) / 256;\r\nif (numPages > 7 ) {\r\nprintk(CARDNAME": Far too big packet error.\n");\r\ndev_kfree_skb (skb);\r\nlp->saved_skb = NULL;\r\nnetif_wake_queue(dev);\r\nreturn NETDEV_TX_OK;\r\n}\r\nlp->packets_waiting++;\r\nSMC_SELECT_BANK( 2 );\r\noutw( MC_ALLOC | numPages, ioaddr + MMU_CMD );\r\ntime_out = MEMORY_WAIT_TIME;\r\ndo {\r\nword status;\r\nstatus = inb( ioaddr + INTERRUPT );\r\nif ( status & IM_ALLOC_INT ) {\r\noutb( IM_ALLOC_INT, ioaddr + INTERRUPT );\r\nbreak;\r\n}\r\n} while ( -- time_out );\r\nif ( !time_out ) {\r\nSMC_ENABLE_INT( IM_ALLOC_INT );\r\nPRINTK2((CARDNAME": memory allocation deferred.\n"));\r\nreturn NETDEV_TX_OK;\r\n}\r\nsmc_hardware_send_packet(dev);\r\nnetif_wake_queue(dev);\r\nreturn NETDEV_TX_OK;\r\n}\r\nstatic void smc_hardware_send_packet( struct net_device * dev )\r\n{\r\nstruct smc_local *lp = netdev_priv(dev);\r\nbyte packet_no;\r\nstruct sk_buff * skb = lp->saved_skb;\r\nword length;\r\nunsigned int ioaddr;\r\nbyte * buf;\r\nioaddr = dev->base_addr;\r\nif ( !skb ) {\r\nPRINTK((CARDNAME": In XMIT with no packet to send\n"));\r\nreturn;\r\n}\r\nlength = ETH_ZLEN < skb->len ? skb->len : ETH_ZLEN;\r\nbuf = skb->data;\r\npacket_no = inb( ioaddr + PNR_ARR + 1 );\r\nif ( packet_no & 0x80 ) {\r\nnetdev_dbg(dev, CARDNAME": Memory allocation failed.\n");\r\ndev_kfree_skb_any(skb);\r\nlp->saved_skb = NULL;\r\nnetif_wake_queue(dev);\r\nreturn;\r\n}\r\noutb( packet_no, ioaddr + PNR_ARR );\r\noutw( PTR_AUTOINC , ioaddr + POINTER );\r\nPRINTK3((CARDNAME": Trying to xmit packet of length %x\n", length));\r\n#if SMC_DEBUG > 2\r\nprint_packet( buf, length );\r\n#endif\r\n#ifdef USE_32_BIT\r\noutl( (length +6 ) << 16 , ioaddr + DATA_1 );\r\n#else\r\noutw( 0, ioaddr + DATA_1 );\r\noutb( (length+6) & 0xFF,ioaddr + DATA_1 );\r\noutb( (length+6) >> 8 , ioaddr + DATA_1 );\r\n#endif\r\n#ifdef USE_32_BIT\r\nif ( length & 0x2 ) {\r\noutsl(ioaddr + DATA_1, buf, length >> 2 );\r\noutw( *((word *)(buf + (length & 0xFFFFFFFC))),ioaddr +DATA_1);\r\n}\r\nelse\r\noutsl(ioaddr + DATA_1, buf, length >> 2 );\r\n#else\r\noutsw(ioaddr + DATA_1 , buf, (length ) >> 1);\r\n#endif\r\nif ( (length & 1) == 0 ) {\r\noutw( 0, ioaddr + DATA_1 );\r\n} else {\r\noutb( buf[length -1 ], ioaddr + DATA_1 );\r\noutb( 0x20, ioaddr + DATA_1);\r\n}\r\nSMC_ENABLE_INT( (IM_TX_INT | IM_TX_EMPTY_INT) );\r\noutw( MC_ENQUEUE , ioaddr + MMU_CMD );\r\nPRINTK2((CARDNAME": Sent packet of length %d\n", length));\r\nlp->saved_skb = NULL;\r\ndev_kfree_skb_any (skb);\r\ndev->trans_start = jiffies;\r\nnetif_wake_queue(dev);\r\n}\r\nstruct net_device * __init smc_init(int unit)\r\n{\r\nstruct net_device *dev = alloc_etherdev(sizeof(struct smc_local));\r\nstruct devlist *smcdev = smc_devlist;\r\nint err = 0;\r\nif (!dev)\r\nreturn ERR_PTR(-ENODEV);\r\nif (unit >= 0) {\r\nsprintf(dev->name, "eth%d", unit);\r\nnetdev_boot_setup_check(dev);\r\nio = dev->base_addr;\r\nirq = dev->irq;\r\n}\r\nif (io > 0x1ff) {\r\nerr = smc_probe(dev, io);\r\n} else if (io != 0) {\r\nerr = -ENXIO;\r\n} else {\r\nfor (;smcdev->port; smcdev++) {\r\nif (smc_probe(dev, smcdev->port) == 0)\r\nbreak;\r\n}\r\nif (!smcdev->port)\r\nerr = -ENODEV;\r\n}\r\nif (err)\r\ngoto out;\r\nerr = register_netdev(dev);\r\nif (err)\r\ngoto out1;\r\nreturn dev;\r\nout1:\r\nfree_irq(dev->irq, dev);\r\nrelease_region(dev->base_addr, SMC_IO_EXTENT);\r\nout:\r\nfree_netdev(dev);\r\nreturn ERR_PTR(err);\r\n}\r\nstatic int __init smc_findirq(int ioaddr)\r\n{\r\n#ifndef NO_AUTOPROBE\r\nint timeout = 20;\r\nunsigned long cookie;\r\ncookie = probe_irq_on();\r\nSMC_SELECT_BANK(2);\r\noutb( IM_ALLOC_INT, ioaddr + INT_MASK );\r\noutw( MC_ALLOC | 1, ioaddr + MMU_CMD );\r\nwhile ( timeout ) {\r\nbyte int_status;\r\nint_status = inb( ioaddr + INTERRUPT );\r\nif ( int_status & IM_ALLOC_INT )\r\nbreak;\r\ntimeout--;\r\n}\r\nSMC_DELAY();\r\nSMC_DELAY();\r\noutb( 0, ioaddr + INT_MASK );\r\nreturn probe_irq_off(cookie);\r\n#else\r\nstruct devlist *smcdev;\r\nfor (smcdev = smc_devlist; smcdev->port; smcdev++) {\r\nif (smcdev->port == ioaddr)\r\nreturn smcdev->irq;\r\n}\r\nreturn 0;\r\n#endif\r\n}\r\nstatic int __init smc_probe(struct net_device *dev, int ioaddr)\r\n{\r\nint i, memory, retval;\r\nunsigned int bank;\r\nconst char *version_string;\r\nconst char *if_string;\r\nword revision_register;\r\nword base_address_register;\r\nword configuration_register;\r\nword memory_info_register;\r\nword memory_cfg_register;\r\nif (!request_region(ioaddr, SMC_IO_EXTENT, DRV_NAME))\r\nreturn -EBUSY;\r\ndev->irq = irq;\r\ndev->if_port = ifport;\r\nbank = inw( ioaddr + BANK_SELECT );\r\nif ( (bank & 0xFF00) != 0x3300 ) {\r\nretval = -ENODEV;\r\ngoto err_out;\r\n}\r\noutw( 0x0, ioaddr + BANK_SELECT );\r\nbank = inw( ioaddr + BANK_SELECT );\r\nif ( (bank & 0xFF00 ) != 0x3300 ) {\r\nretval = -ENODEV;\r\ngoto err_out;\r\n}\r\nSMC_SELECT_BANK(1);\r\nbase_address_register = inw( ioaddr + BASE );\r\nif ( ioaddr != ( base_address_register >> 3 & 0x3E0 ) ) {\r\nprintk(CARDNAME ": IOADDR %x doesn't match configuration (%x). "\r\n"Probably not a SMC chip\n",\r\nioaddr, base_address_register >> 3 & 0x3E0 );\r\nretval = -ENODEV;\r\ngoto err_out;\r\n}\r\nSMC_SELECT_BANK(3);\r\nrevision_register = inw( ioaddr + REVISION );\r\nif ( !chip_ids[ ( revision_register >> 4 ) & 0xF ] ) {\r\nprintk(CARDNAME ": IO %x: Unrecognized revision register:"\r\n" %x, Contact author.\n", ioaddr, revision_register);\r\nretval = -ENODEV;\r\ngoto err_out;\r\n}\r\npr_info_once("%s\n", version);\r\ndev->base_addr = ioaddr;\r\nSMC_SELECT_BANK( 1 );\r\nfor ( i = 0; i < 6; i += 2 ) {\r\nword address;\r\naddress = inw( ioaddr + ADDR0 + i );\r\ndev->dev_addr[ i + 1] = address >> 8;\r\ndev->dev_addr[ i ] = address & 0xFF;\r\n}\r\nSMC_SELECT_BANK( 0 );\r\nmemory_info_register = inw( ioaddr + MIR );\r\nmemory_cfg_register = inw( ioaddr + MCR );\r\nmemory = ( memory_cfg_register >> 9 ) & 0x7;\r\nmemory *= 256 * ( memory_info_register & 0xFF );\r\nSMC_SELECT_BANK(3);\r\nrevision_register = inw( ioaddr + REVISION );\r\nversion_string = chip_ids[ ( revision_register >> 4 ) & 0xF ];\r\nif ( !version_string ) {\r\nretval = -ENODEV;\r\ngoto err_out;\r\n}\r\nif ( dev->if_port == 0 ) {\r\nSMC_SELECT_BANK(1);\r\nconfiguration_register = inw( ioaddr + CONFIG );\r\nif ( configuration_register & CFG_AUI_SELECT )\r\ndev->if_port = 2;\r\nelse\r\ndev->if_port = 1;\r\n}\r\nif_string = interfaces[ dev->if_port - 1 ];\r\nsmc_reset( ioaddr );\r\nif ( dev->irq < 2 ) {\r\nint trials;\r\ntrials = 3;\r\nwhile ( trials-- ) {\r\ndev->irq = smc_findirq( ioaddr );\r\nif ( dev->irq )\r\nbreak;\r\nsmc_reset( ioaddr );\r\n}\r\n}\r\nif (dev->irq == 0 ) {\r\nprintk(CARDNAME": Couldn't autodetect your IRQ. Use irq=xx.\n");\r\nretval = -ENODEV;\r\ngoto err_out;\r\n}\r\nnetdev_info(dev, "%s(r:%d) at %#3x IRQ:%d INTF:%s MEM:%db ",\r\nversion_string, revision_register & 0xF, ioaddr, dev->irq,\r\nif_string, memory);\r\nnetdev_info(dev, "ADDR: %pM\n", dev->dev_addr);\r\nretval = request_irq(dev->irq, smc_interrupt, 0, DRV_NAME, dev);\r\nif (retval) {\r\nnetdev_warn(dev, "%s: unable to get IRQ %d (irqval=%d).\n",\r\nDRV_NAME, dev->irq, retval);\r\ngoto err_out;\r\n}\r\ndev->netdev_ops = &smc_netdev_ops;\r\ndev->watchdog_timeo = HZ/20;\r\nreturn 0;\r\nerr_out:\r\nrelease_region(ioaddr, SMC_IO_EXTENT);\r\nreturn retval;\r\n}\r\nstatic void print_packet( byte * buf, int length )\r\n{\r\n#if 0\r\nprint_hex_dump_debug(DRV_NAME, DUMP_PREFIX_OFFSET, 16, 1,\r\nbuf, length, true);\r\n#endif\r\n}\r\nstatic int smc_open(struct net_device *dev)\r\n{\r\nint ioaddr = dev->base_addr;\r\nint i;\r\nmemset(netdev_priv(dev), 0, sizeof(struct smc_local));\r\nsmc_reset( ioaddr );\r\nsmc_enable( ioaddr );\r\nSMC_SELECT_BANK( 1 );\r\nif ( dev->if_port == 1 ) {\r\noutw( inw( ioaddr + CONFIG ) & ~CFG_AUI_SELECT,\r\nioaddr + CONFIG );\r\n}\r\nelse if ( dev->if_port == 2 ) {\r\noutw( inw( ioaddr + CONFIG ) | CFG_AUI_SELECT,\r\nioaddr + CONFIG );\r\n}\r\nSMC_SELECT_BANK( 1 );\r\nfor ( i = 0; i < 6; i += 2 ) {\r\nword address;\r\naddress = dev->dev_addr[ i + 1 ] << 8 ;\r\naddress |= dev->dev_addr[ i ];\r\noutw( address, ioaddr + ADDR0 + i );\r\n}\r\nnetif_start_queue(dev);\r\nreturn 0;\r\n}\r\nstatic void smc_timeout(struct net_device *dev)\r\n{\r\nnetdev_warn(dev, CARDNAME": transmit timed out, %s?\n",\r\ntx_done(dev) ? "IRQ conflict" : "network cable problem");\r\nsmc_reset( dev->base_addr );\r\nsmc_enable( dev->base_addr );\r\ndev->trans_start = jiffies;\r\n((struct smc_local *)netdev_priv(dev))->saved_skb = NULL;\r\nnetif_wake_queue(dev);\r\n}\r\nstatic void smc_rcv(struct net_device *dev)\r\n{\r\nint ioaddr = dev->base_addr;\r\nint packet_number;\r\nword status;\r\nword packet_length;\r\npacket_number = inw( ioaddr + FIFO_PORTS );\r\nif ( packet_number & FP_RXEMPTY ) {\r\nPRINTK((CARDNAME ": WARNING: smc_rcv with nothing on FIFO.\n"));\r\nreturn;\r\n}\r\noutw( PTR_READ | PTR_RCV | PTR_AUTOINC, ioaddr + POINTER );\r\nstatus = inw( ioaddr + DATA_1 );\r\npacket_length = inw( ioaddr + DATA_1 );\r\npacket_length &= 0x07ff;\r\nPRINTK2(("RCV: STATUS %4x LENGTH %4x\n", status, packet_length ));\r\npacket_length -= 6;\r\nif ( !(status & RS_ERRORS ) ){\r\nstruct sk_buff * skb;\r\nbyte * data;\r\nif ( status & RS_ODDFRAME )\r\npacket_length++;\r\nif ( status & RS_MULTICAST )\r\ndev->stats.multicast++;\r\nskb = netdev_alloc_skb(dev, packet_length + 5);\r\nif ( skb == NULL ) {\r\ndev->stats.rx_dropped++;\r\ngoto done;\r\n}\r\nskb_reserve( skb, 2 );\r\ndata = skb_put( skb, packet_length);\r\n#ifdef USE_32_BIT\r\nPRINTK3((" Reading %d dwords (and %d bytes)\n",\r\npacket_length >> 2, packet_length & 3 ));\r\ninsl(ioaddr + DATA_1 , data, packet_length >> 2 );\r\ninsb( ioaddr + DATA_1, data + (packet_length & 0xFFFFFC),\r\npacket_length & 0x3 );\r\n#else\r\nPRINTK3((" Reading %d words and %d byte(s)\n",\r\n(packet_length >> 1 ), packet_length & 1 ));\r\ninsw(ioaddr + DATA_1 , data, packet_length >> 1);\r\nif ( packet_length & 1 ) {\r\ndata += packet_length & ~1;\r\n*(data++) = inb( ioaddr + DATA_1 );\r\n}\r\n#endif\r\n#if SMC_DEBUG > 2\r\nprint_packet( data, packet_length );\r\n#endif\r\nskb->protocol = eth_type_trans(skb, dev );\r\nnetif_rx(skb);\r\ndev->stats.rx_packets++;\r\ndev->stats.rx_bytes += packet_length;\r\n} else {\r\ndev->stats.rx_errors++;\r\nif ( status & RS_ALGNERR ) dev->stats.rx_frame_errors++;\r\nif ( status & (RS_TOOSHORT | RS_TOOLONG ) )\r\ndev->stats.rx_length_errors++;\r\nif ( status & RS_BADCRC) dev->stats.rx_crc_errors++;\r\n}\r\ndone:\r\noutw( MC_RELEASE, ioaddr + MMU_CMD );\r\n}\r\nstatic void smc_tx( struct net_device * dev )\r\n{\r\nint ioaddr = dev->base_addr;\r\nstruct smc_local *lp = netdev_priv(dev);\r\nbyte saved_packet;\r\nbyte packet_no;\r\nword tx_status;\r\nsaved_packet = inb( ioaddr + PNR_ARR );\r\npacket_no = inw( ioaddr + FIFO_PORTS );\r\npacket_no &= 0x7F;\r\noutb( packet_no, ioaddr + PNR_ARR );\r\noutw( PTR_AUTOINC | PTR_READ, ioaddr + POINTER );\r\ntx_status = inw( ioaddr + DATA_1 );\r\nPRINTK3((CARDNAME": TX DONE STATUS: %4x\n", tx_status));\r\ndev->stats.tx_errors++;\r\nif ( tx_status & TS_LOSTCAR ) dev->stats.tx_carrier_errors++;\r\nif ( tx_status & TS_LATCOL ) {\r\nnetdev_dbg(dev, CARDNAME": Late collision occurred on last xmit.\n");\r\ndev->stats.tx_window_errors++;\r\n}\r\n#if 0\r\nif ( tx_status & TS_16COL ) { ... }\r\n#endif\r\nif ( tx_status & TS_SUCCESS ) {\r\nnetdev_info(dev, CARDNAME": Successful packet caused interrupt\n");\r\n}\r\nSMC_SELECT_BANK( 0 );\r\noutw( inw( ioaddr + TCR ) | TCR_ENABLE, ioaddr + TCR );\r\nSMC_SELECT_BANK( 2 );\r\noutw( MC_FREEPKT, ioaddr + MMU_CMD );\r\nlp->packets_waiting--;\r\noutb( saved_packet, ioaddr + PNR_ARR );\r\n}\r\nstatic irqreturn_t smc_interrupt(int irq, void * dev_id)\r\n{\r\nstruct net_device *dev = dev_id;\r\nint ioaddr = dev->base_addr;\r\nstruct smc_local *lp = netdev_priv(dev);\r\nbyte status;\r\nword card_stats;\r\nbyte mask;\r\nint timeout;\r\nword saved_bank;\r\nword saved_pointer;\r\nint handled = 0;\r\nPRINTK3((CARDNAME": SMC interrupt started\n"));\r\nsaved_bank = inw( ioaddr + BANK_SELECT );\r\nSMC_SELECT_BANK(2);\r\nsaved_pointer = inw( ioaddr + POINTER );\r\nmask = inb( ioaddr + INT_MASK );\r\noutb( 0, ioaddr + INT_MASK );\r\ntimeout = 4;\r\nPRINTK2((KERN_WARNING CARDNAME ": MASK IS %x\n", mask));\r\ndo {\r\nstatus = inb( ioaddr + INTERRUPT ) & mask;\r\nif (!status )\r\nbreak;\r\nhandled = 1;\r\nPRINTK3((KERN_WARNING CARDNAME\r\n": Handling interrupt status %x\n", status));\r\nif (status & IM_RCV_INT) {\r\nPRINTK2((KERN_WARNING CARDNAME\r\n": Receive Interrupt\n"));\r\nsmc_rcv(dev);\r\n} else if (status & IM_TX_INT ) {\r\nPRINTK2((KERN_WARNING CARDNAME\r\n": TX ERROR handled\n"));\r\nsmc_tx(dev);\r\noutb(IM_TX_INT, ioaddr + INTERRUPT );\r\n} else if (status & IM_TX_EMPTY_INT ) {\r\nSMC_SELECT_BANK( 0 );\r\ncard_stats = inw( ioaddr + COUNTER );\r\ndev->stats.collisions += card_stats & 0xF;\r\ncard_stats >>= 4;\r\ndev->stats.collisions += card_stats & 0xF;\r\nSMC_SELECT_BANK( 2 );\r\nPRINTK2((KERN_WARNING CARDNAME\r\n": TX_BUFFER_EMPTY handled\n"));\r\noutb( IM_TX_EMPTY_INT, ioaddr + INTERRUPT );\r\nmask &= ~IM_TX_EMPTY_INT;\r\ndev->stats.tx_packets += lp->packets_waiting;\r\nlp->packets_waiting = 0;\r\n} else if (status & IM_ALLOC_INT ) {\r\nPRINTK2((KERN_DEBUG CARDNAME\r\n": Allocation interrupt\n"));\r\nmask &= ~IM_ALLOC_INT;\r\nsmc_hardware_send_packet( dev );\r\nmask |= ( IM_TX_EMPTY_INT | IM_TX_INT );\r\nnetif_wake_queue(dev);\r\nPRINTK2((CARDNAME": Handoff done successfully.\n"));\r\n} else if (status & IM_RX_OVRN_INT ) {\r\ndev->stats.rx_errors++;\r\ndev->stats.rx_fifo_errors++;\r\noutb( IM_RX_OVRN_INT, ioaddr + INTERRUPT );\r\n} else if (status & IM_EPH_INT ) {\r\nPRINTK((CARDNAME ": UNSUPPORTED: EPH INTERRUPT\n"));\r\n} else if (status & IM_ERCV_INT ) {\r\nPRINTK((CARDNAME ": UNSUPPORTED: ERCV INTERRUPT\n"));\r\noutb( IM_ERCV_INT, ioaddr + INTERRUPT );\r\n}\r\n} while ( timeout -- );\r\nSMC_SELECT_BANK( 2 );\r\noutb( mask, ioaddr + INT_MASK );\r\nPRINTK3((KERN_WARNING CARDNAME ": MASK is now %x\n", mask));\r\noutw( saved_pointer, ioaddr + POINTER );\r\nSMC_SELECT_BANK( saved_bank );\r\nPRINTK3((CARDNAME ": Interrupt done\n"));\r\nreturn IRQ_RETVAL(handled);\r\n}\r\nstatic int smc_close(struct net_device *dev)\r\n{\r\nnetif_stop_queue(dev);\r\nsmc_shutdown( dev->base_addr );\r\nreturn 0;\r\n}\r\nstatic void smc_set_multicast_list(struct net_device *dev)\r\n{\r\nshort ioaddr = dev->base_addr;\r\nSMC_SELECT_BANK(0);\r\nif ( dev->flags & IFF_PROMISC )\r\noutw( inw(ioaddr + RCR ) | RCR_PROMISC, ioaddr + RCR );\r\nelse if (dev->flags & IFF_ALLMULTI)\r\noutw( inw(ioaddr + RCR ) | RCR_ALMUL, ioaddr + RCR );\r\nelse if (!netdev_mc_empty(dev)) {\r\noutw( inw( ioaddr + RCR ) & ~(RCR_PROMISC | RCR_ALMUL),\r\nioaddr + RCR );\r\nsmc_setmulticast(ioaddr, dev);\r\n}\r\nelse {\r\noutw( inw( ioaddr + RCR ) & ~(RCR_PROMISC | RCR_ALMUL),\r\nioaddr + RCR );\r\nSMC_SELECT_BANK( 3 );\r\noutw( 0, ioaddr + MULTICAST1 );\r\noutw( 0, ioaddr + MULTICAST2 );\r\noutw( 0, ioaddr + MULTICAST3 );\r\noutw( 0, ioaddr + MULTICAST4 );\r\n}\r\n}\r\nint __init init_module(void)\r\n{\r\nif (io == 0)\r\nprintk(KERN_WARNING\r\nCARDNAME": You shouldn't use auto-probing with insmod!\n" );\r\ndevSMC9194 = smc_init(-1);\r\nreturn PTR_ERR_OR_ZERO(devSMC9194);\r\n}\r\nvoid __exit cleanup_module(void)\r\n{\r\nunregister_netdev(devSMC9194);\r\nfree_irq(devSMC9194->irq, devSMC9194);\r\nrelease_region(devSMC9194->base_addr, SMC_IO_EXTENT);\r\nfree_netdev(devSMC9194);\r\n}
