static inline s64 mul_frac(s64 x, s64 y)\r\n{\r\nreturn (x * y) >> FRAC_BITS;\r\n}\r\nstatic inline s64 div_frac(s64 x, s64 y)\r\n{\r\nreturn div_s64(x << FRAC_BITS, y);\r\n}\r\nstatic u32 estimate_sustainable_power(struct thermal_zone_device *tz)\r\n{\r\nu32 sustainable_power = 0;\r\nstruct thermal_instance *instance;\r\nstruct power_allocator_params *params = tz->governor_data;\r\nlist_for_each_entry(instance, &tz->thermal_instances, tz_node) {\r\nstruct thermal_cooling_device *cdev = instance->cdev;\r\nu32 min_power;\r\nif (instance->trip != params->trip_max_desired_temperature)\r\ncontinue;\r\nif (power_actor_get_min_power(cdev, tz, &min_power))\r\ncontinue;\r\nsustainable_power += min_power;\r\n}\r\nreturn sustainable_power;\r\n}\r\nstatic void estimate_pid_constants(struct thermal_zone_device *tz,\r\nu32 sustainable_power, int trip_switch_on,\r\nint control_temp, bool force)\r\n{\r\nint ret;\r\nint switch_on_temp;\r\nu32 temperature_threshold;\r\nret = tz->ops->get_trip_temp(tz, trip_switch_on, &switch_on_temp);\r\nif (ret)\r\nswitch_on_temp = 0;\r\ntemperature_threshold = control_temp - switch_on_temp;\r\nif (!temperature_threshold)\r\nreturn;\r\nif (!tz->tzp->k_po || force)\r\ntz->tzp->k_po = int_to_frac(sustainable_power) /\r\ntemperature_threshold;\r\nif (!tz->tzp->k_pu || force)\r\ntz->tzp->k_pu = int_to_frac(2 * sustainable_power) /\r\ntemperature_threshold;\r\nif (!tz->tzp->k_i || force)\r\ntz->tzp->k_i = int_to_frac(10) / 1000;\r\n}\r\nstatic u32 pid_controller(struct thermal_zone_device *tz,\r\nint control_temp,\r\nu32 max_allocatable_power)\r\n{\r\ns64 p, i, d, power_range;\r\ns32 err, max_power_frac;\r\nu32 sustainable_power;\r\nstruct power_allocator_params *params = tz->governor_data;\r\nmax_power_frac = int_to_frac(max_allocatable_power);\r\nif (tz->tzp->sustainable_power) {\r\nsustainable_power = tz->tzp->sustainable_power;\r\n} else {\r\nsustainable_power = estimate_sustainable_power(tz);\r\nestimate_pid_constants(tz, sustainable_power,\r\nparams->trip_switch_on, control_temp,\r\ntrue);\r\n}\r\nerr = control_temp - tz->temperature;\r\nerr = int_to_frac(err);\r\np = mul_frac(err < 0 ? tz->tzp->k_po : tz->tzp->k_pu, err);\r\ni = mul_frac(tz->tzp->k_i, params->err_integral);\r\nif (err < int_to_frac(tz->tzp->integral_cutoff)) {\r\ns64 i_next = i + mul_frac(tz->tzp->k_i, err);\r\nif (abs(i_next) < max_power_frac) {\r\ni = i_next;\r\nparams->err_integral += err;\r\n}\r\n}\r\nd = mul_frac(tz->tzp->k_d, err - params->prev_err);\r\nd = div_frac(d, tz->passive_delay);\r\nparams->prev_err = err;\r\npower_range = p + i + d;\r\npower_range = sustainable_power + frac_to_int(power_range);\r\npower_range = clamp(power_range, (s64)0, (s64)max_allocatable_power);\r\ntrace_thermal_power_allocator_pid(tz, frac_to_int(err),\r\nfrac_to_int(params->err_integral),\r\nfrac_to_int(p), frac_to_int(i),\r\nfrac_to_int(d), power_range);\r\nreturn power_range;\r\n}\r\nstatic void divvy_up_power(u32 *req_power, u32 *max_power, int num_actors,\r\nu32 total_req_power, u32 power_range,\r\nu32 *granted_power, u32 *extra_actor_power)\r\n{\r\nu32 extra_power, capped_extra_power;\r\nint i;\r\nif (!total_req_power)\r\ntotal_req_power = 1;\r\ncapped_extra_power = 0;\r\nextra_power = 0;\r\nfor (i = 0; i < num_actors; i++) {\r\nu64 req_range = req_power[i] * power_range;\r\ngranted_power[i] = DIV_ROUND_CLOSEST_ULL(req_range,\r\ntotal_req_power);\r\nif (granted_power[i] > max_power[i]) {\r\nextra_power += granted_power[i] - max_power[i];\r\ngranted_power[i] = max_power[i];\r\n}\r\nextra_actor_power[i] = max_power[i] - granted_power[i];\r\ncapped_extra_power += extra_actor_power[i];\r\n}\r\nif (!extra_power)\r\nreturn;\r\nextra_power = min(extra_power, capped_extra_power);\r\nif (capped_extra_power > 0)\r\nfor (i = 0; i < num_actors; i++)\r\ngranted_power[i] += (extra_actor_power[i] *\r\nextra_power) / capped_extra_power;\r\n}\r\nstatic int allocate_power(struct thermal_zone_device *tz,\r\nint control_temp)\r\n{\r\nstruct thermal_instance *instance;\r\nstruct power_allocator_params *params = tz->governor_data;\r\nu32 *req_power, *max_power, *granted_power, *extra_actor_power;\r\nu32 *weighted_req_power;\r\nu32 total_req_power, max_allocatable_power, total_weighted_req_power;\r\nu32 total_granted_power, power_range;\r\nint i, num_actors, total_weight, ret = 0;\r\nint trip_max_desired_temperature = params->trip_max_desired_temperature;\r\nmutex_lock(&tz->lock);\r\nnum_actors = 0;\r\ntotal_weight = 0;\r\nlist_for_each_entry(instance, &tz->thermal_instances, tz_node) {\r\nif ((instance->trip == trip_max_desired_temperature) &&\r\ncdev_is_power_actor(instance->cdev)) {\r\nnum_actors++;\r\ntotal_weight += instance->weight;\r\n}\r\n}\r\nif (!num_actors) {\r\nret = -ENODEV;\r\ngoto unlock;\r\n}\r\nBUILD_BUG_ON(sizeof(*req_power) != sizeof(*max_power));\r\nBUILD_BUG_ON(sizeof(*req_power) != sizeof(*granted_power));\r\nBUILD_BUG_ON(sizeof(*req_power) != sizeof(*extra_actor_power));\r\nBUILD_BUG_ON(sizeof(*req_power) != sizeof(*weighted_req_power));\r\nreq_power = kcalloc(num_actors * 5, sizeof(*req_power), GFP_KERNEL);\r\nif (!req_power) {\r\nret = -ENOMEM;\r\ngoto unlock;\r\n}\r\nmax_power = &req_power[num_actors];\r\ngranted_power = &req_power[2 * num_actors];\r\nextra_actor_power = &req_power[3 * num_actors];\r\nweighted_req_power = &req_power[4 * num_actors];\r\ni = 0;\r\ntotal_weighted_req_power = 0;\r\ntotal_req_power = 0;\r\nmax_allocatable_power = 0;\r\nlist_for_each_entry(instance, &tz->thermal_instances, tz_node) {\r\nint weight;\r\nstruct thermal_cooling_device *cdev = instance->cdev;\r\nif (instance->trip != trip_max_desired_temperature)\r\ncontinue;\r\nif (!cdev_is_power_actor(cdev))\r\ncontinue;\r\nif (cdev->ops->get_requested_power(cdev, tz, &req_power[i]))\r\ncontinue;\r\nif (!total_weight)\r\nweight = 1 << FRAC_BITS;\r\nelse\r\nweight = instance->weight;\r\nweighted_req_power[i] = frac_to_int(weight * req_power[i]);\r\nif (power_actor_get_max_power(cdev, tz, &max_power[i]))\r\ncontinue;\r\ntotal_req_power += req_power[i];\r\nmax_allocatable_power += max_power[i];\r\ntotal_weighted_req_power += weighted_req_power[i];\r\ni++;\r\n}\r\npower_range = pid_controller(tz, control_temp, max_allocatable_power);\r\ndivvy_up_power(weighted_req_power, max_power, num_actors,\r\ntotal_weighted_req_power, power_range, granted_power,\r\nextra_actor_power);\r\ntotal_granted_power = 0;\r\ni = 0;\r\nlist_for_each_entry(instance, &tz->thermal_instances, tz_node) {\r\nif (instance->trip != trip_max_desired_temperature)\r\ncontinue;\r\nif (!cdev_is_power_actor(instance->cdev))\r\ncontinue;\r\npower_actor_set_power(instance->cdev, instance,\r\ngranted_power[i]);\r\ntotal_granted_power += granted_power[i];\r\ni++;\r\n}\r\ntrace_thermal_power_allocator(tz, req_power, total_req_power,\r\ngranted_power, total_granted_power,\r\nnum_actors, power_range,\r\nmax_allocatable_power, tz->temperature,\r\ncontrol_temp - tz->temperature);\r\nkfree(req_power);\r\nunlock:\r\nmutex_unlock(&tz->lock);\r\nreturn ret;\r\n}\r\nstatic void get_governor_trips(struct thermal_zone_device *tz,\r\nstruct power_allocator_params *params)\r\n{\r\nint i, last_active, last_passive;\r\nbool found_first_passive;\r\nfound_first_passive = false;\r\nlast_active = INVALID_TRIP;\r\nlast_passive = INVALID_TRIP;\r\nfor (i = 0; i < tz->trips; i++) {\r\nenum thermal_trip_type type;\r\nint ret;\r\nret = tz->ops->get_trip_type(tz, i, &type);\r\nif (ret) {\r\ndev_warn(&tz->device,\r\n"Failed to get trip point %d type: %d\n", i,\r\nret);\r\ncontinue;\r\n}\r\nif (type == THERMAL_TRIP_PASSIVE) {\r\nif (!found_first_passive) {\r\nparams->trip_switch_on = i;\r\nfound_first_passive = true;\r\n} else {\r\nlast_passive = i;\r\n}\r\n} else if (type == THERMAL_TRIP_ACTIVE) {\r\nlast_active = i;\r\n} else {\r\nbreak;\r\n}\r\n}\r\nif (last_passive != INVALID_TRIP) {\r\nparams->trip_max_desired_temperature = last_passive;\r\n} else if (found_first_passive) {\r\nparams->trip_max_desired_temperature = params->trip_switch_on;\r\nparams->trip_switch_on = INVALID_TRIP;\r\n} else {\r\nparams->trip_switch_on = INVALID_TRIP;\r\nparams->trip_max_desired_temperature = last_active;\r\n}\r\n}\r\nstatic void reset_pid_controller(struct power_allocator_params *params)\r\n{\r\nparams->err_integral = 0;\r\nparams->prev_err = 0;\r\n}\r\nstatic void allow_maximum_power(struct thermal_zone_device *tz)\r\n{\r\nstruct thermal_instance *instance;\r\nstruct power_allocator_params *params = tz->governor_data;\r\nlist_for_each_entry(instance, &tz->thermal_instances, tz_node) {\r\nif ((instance->trip != params->trip_max_desired_temperature) ||\r\n(!cdev_is_power_actor(instance->cdev)))\r\ncontinue;\r\ninstance->target = 0;\r\ninstance->cdev->updated = false;\r\nthermal_cdev_update(instance->cdev);\r\n}\r\n}\r\nstatic int power_allocator_bind(struct thermal_zone_device *tz)\r\n{\r\nint ret;\r\nstruct power_allocator_params *params;\r\nint control_temp;\r\nparams = kzalloc(sizeof(*params), GFP_KERNEL);\r\nif (!params)\r\nreturn -ENOMEM;\r\nif (!tz->tzp) {\r\ntz->tzp = kzalloc(sizeof(*tz->tzp), GFP_KERNEL);\r\nif (!tz->tzp) {\r\nret = -ENOMEM;\r\ngoto free_params;\r\n}\r\nparams->allocated_tzp = true;\r\n}\r\nif (!tz->tzp->sustainable_power)\r\ndev_warn(&tz->device, "power_allocator: sustainable_power will be estimated\n");\r\nget_governor_trips(tz, params);\r\nif (tz->trips > 0) {\r\nret = tz->ops->get_trip_temp(tz,\r\nparams->trip_max_desired_temperature,\r\n&control_temp);\r\nif (!ret)\r\nestimate_pid_constants(tz, tz->tzp->sustainable_power,\r\nparams->trip_switch_on,\r\ncontrol_temp, false);\r\n}\r\nreset_pid_controller(params);\r\ntz->governor_data = params;\r\nreturn 0;\r\nfree_params:\r\nkfree(params);\r\nreturn ret;\r\n}\r\nstatic void power_allocator_unbind(struct thermal_zone_device *tz)\r\n{\r\nstruct power_allocator_params *params = tz->governor_data;\r\ndev_dbg(&tz->device, "Unbinding from thermal zone %d\n", tz->id);\r\nif (params->allocated_tzp) {\r\nkfree(tz->tzp);\r\ntz->tzp = NULL;\r\n}\r\nkfree(tz->governor_data);\r\ntz->governor_data = NULL;\r\n}\r\nstatic int power_allocator_throttle(struct thermal_zone_device *tz, int trip)\r\n{\r\nint ret;\r\nint switch_on_temp, control_temp;\r\nstruct power_allocator_params *params = tz->governor_data;\r\nif (trip != params->trip_max_desired_temperature)\r\nreturn 0;\r\nret = tz->ops->get_trip_temp(tz, params->trip_switch_on,\r\n&switch_on_temp);\r\nif (!ret && (tz->temperature < switch_on_temp)) {\r\ntz->passive = 0;\r\nreset_pid_controller(params);\r\nallow_maximum_power(tz);\r\nreturn 0;\r\n}\r\ntz->passive = 1;\r\nret = tz->ops->get_trip_temp(tz, params->trip_max_desired_temperature,\r\n&control_temp);\r\nif (ret) {\r\ndev_warn(&tz->device,\r\n"Failed to get the maximum desired temperature: %d\n",\r\nret);\r\nreturn ret;\r\n}\r\nreturn allocate_power(tz, control_temp);\r\n}\r\nint thermal_gov_power_allocator_register(void)\r\n{\r\nreturn thermal_register_governor(&thermal_gov_power_allocator);\r\n}\r\nvoid thermal_gov_power_allocator_unregister(void)\r\n{\r\nthermal_unregister_governor(&thermal_gov_power_allocator);\r\n}
