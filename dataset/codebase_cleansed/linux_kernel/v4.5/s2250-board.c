static inline struct s2250 *to_state(struct v4l2_subdev *sd)\r\n{\r\nreturn container_of(sd, struct s2250, sd);\r\n}\r\nstatic int go7007_usb_vendor_request(struct go7007 *go, u16 request,\r\nu16 value, u16 index, void *transfer_buffer, int length, int in)\r\n{\r\nstruct go7007_usb *usb = go->hpi_context;\r\nint timeout = 5000;\r\nif (in) {\r\nreturn usb_control_msg(usb->usbdev,\r\nusb_rcvctrlpipe(usb->usbdev, 0), request,\r\nUSB_TYPE_VENDOR | USB_RECIP_DEVICE | USB_DIR_IN,\r\nvalue, index, transfer_buffer, length, timeout);\r\n} else {\r\nreturn usb_control_msg(usb->usbdev,\r\nusb_sndctrlpipe(usb->usbdev, 0), request,\r\nUSB_TYPE_VENDOR | USB_RECIP_DEVICE,\r\nvalue, index, transfer_buffer, length, timeout);\r\n}\r\n}\r\nstatic int write_reg(struct i2c_client *client, u8 reg, u8 value)\r\n{\r\nstruct go7007 *go = i2c_get_adapdata(client->adapter);\r\nstruct go7007_usb *usb;\r\nint rc;\r\nint dev_addr = client->addr << 1;\r\nu8 *buf;\r\nif (go == NULL)\r\nreturn -ENODEV;\r\nif (go->status == STATUS_SHUTDOWN)\r\nreturn -EBUSY;\r\nbuf = kzalloc(16, GFP_KERNEL);\r\nif (buf == NULL)\r\nreturn -ENOMEM;\r\nusb = go->hpi_context;\r\nif (mutex_lock_interruptible(&usb->i2c_lock) != 0) {\r\ndev_info(&client->dev, "i2c lock failed\n");\r\nkfree(buf);\r\nreturn -EINTR;\r\n}\r\nrc = go7007_usb_vendor_request(go, 0x55, dev_addr,\r\n(reg<<8 | value),\r\nbuf,\r\n16, 1);\r\nmutex_unlock(&usb->i2c_lock);\r\nkfree(buf);\r\nreturn rc;\r\n}\r\nstatic int write_reg_fp(struct i2c_client *client, u16 addr, u16 val)\r\n{\r\nstruct go7007 *go = i2c_get_adapdata(client->adapter);\r\nstruct go7007_usb *usb;\r\nint rc;\r\nu8 *buf;\r\nstruct s2250 *dec = i2c_get_clientdata(client);\r\nif (go == NULL)\r\nreturn -ENODEV;\r\nif (go->status == STATUS_SHUTDOWN)\r\nreturn -EBUSY;\r\nbuf = kzalloc(16, GFP_KERNEL);\r\nif (buf == NULL)\r\nreturn -ENOMEM;\r\nmemset(buf, 0xcd, 6);\r\nusb = go->hpi_context;\r\nif (mutex_lock_interruptible(&usb->i2c_lock) != 0) {\r\ndev_info(&client->dev, "i2c lock failed\n");\r\nkfree(buf);\r\nreturn -EINTR;\r\n}\r\nrc = go7007_usb_vendor_request(go, 0x57, addr, val, buf, 16, 1);\r\nmutex_unlock(&usb->i2c_lock);\r\nif (rc < 0) {\r\nkfree(buf);\r\nreturn rc;\r\n}\r\nif (buf[0] == 0) {\r\nunsigned int subaddr, val_read;\r\nsubaddr = (buf[4] << 8) + buf[5];\r\nval_read = (buf[2] << 8) + buf[3];\r\nkfree(buf);\r\nif (val_read != val) {\r\ndev_info(&client->dev, "invalid fp write %x %x\n",\r\nval_read, val);\r\nreturn -EFAULT;\r\n}\r\nif (subaddr != addr) {\r\ndev_info(&client->dev, "invalid fp write addr %x %x\n",\r\nsubaddr, addr);\r\nreturn -EFAULT;\r\n}\r\n} else {\r\nkfree(buf);\r\nreturn -EFAULT;\r\n}\r\nif (addr == 0x12b)\r\ndec->reg12b_val = val;\r\nreturn 0;\r\n}\r\nstatic int read_reg_fp(struct i2c_client *client, u16 addr, u16 *val)\r\n{\r\nstruct go7007 *go = i2c_get_adapdata(client->adapter);\r\nstruct go7007_usb *usb;\r\nint rc;\r\nu8 *buf;\r\nif (go == NULL)\r\nreturn -ENODEV;\r\nif (go->status == STATUS_SHUTDOWN)\r\nreturn -EBUSY;\r\nbuf = kzalloc(16, GFP_KERNEL);\r\nif (buf == NULL)\r\nreturn -ENOMEM;\r\nmemset(buf, 0xcd, 6);\r\nusb = go->hpi_context;\r\nif (mutex_lock_interruptible(&usb->i2c_lock) != 0) {\r\ndev_info(&client->dev, "i2c lock failed\n");\r\nkfree(buf);\r\nreturn -EINTR;\r\n}\r\nrc = go7007_usb_vendor_request(go, 0x58, addr, 0, buf, 16, 1);\r\nmutex_unlock(&usb->i2c_lock);\r\nif (rc < 0) {\r\nkfree(buf);\r\nreturn rc;\r\n}\r\n*val = (buf[0] << 8) | buf[1];\r\nkfree(buf);\r\nreturn 0;\r\n}\r\nstatic int write_regs(struct i2c_client *client, u8 *regs)\r\n{\r\nint i;\r\nfor (i = 0; !((regs[i] == 0x00) && (regs[i+1] == 0x00)); i += 2) {\r\nif (write_reg(client, regs[i], regs[i+1]) < 0) {\r\ndev_info(&client->dev, "failed\n");\r\nreturn -1;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int write_regs_fp(struct i2c_client *client, u16 *regs)\r\n{\r\nint i;\r\nfor (i = 0; !((regs[i] == 0x00) && (regs[i+1] == 0x00)); i += 2) {\r\nif (write_reg_fp(client, regs[i], regs[i+1]) < 0) {\r\ndev_info(&client->dev, "failed fp\n");\r\nreturn -1;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int s2250_s_video_routing(struct v4l2_subdev *sd, u32 input, u32 output,\r\nu32 config)\r\n{\r\nstruct s2250 *state = to_state(sd);\r\nstruct i2c_client *client = v4l2_get_subdevdata(sd);\r\nint vidsys;\r\nvidsys = (state->std == V4L2_STD_NTSC) ? 0x01 : 0x00;\r\nif (input == 0) {\r\nwrite_reg_fp(client, 0x20, 0x020 | vidsys);\r\nwrite_reg_fp(client, 0x21, 0x662);\r\nwrite_reg_fp(client, 0x140, 0x060);\r\n} else if (input == 1) {\r\nwrite_reg_fp(client, 0x20, 0x040 | vidsys);\r\nwrite_reg_fp(client, 0x21, 0x666);\r\nwrite_reg_fp(client, 0x140, 0x060);\r\n} else {\r\nreturn -EINVAL;\r\n}\r\nstate->input = input;\r\nreturn 0;\r\n}\r\nstatic int s2250_s_std(struct v4l2_subdev *sd, v4l2_std_id norm)\r\n{\r\nstruct s2250 *state = to_state(sd);\r\nstruct i2c_client *client = v4l2_get_subdevdata(sd);\r\nu16 vidsource;\r\nvidsource = (state->input == 1) ? 0x040 : 0x020;\r\nif (norm & V4L2_STD_625_50) {\r\nwrite_regs_fp(client, vid_regs_fp);\r\nwrite_regs_fp(client, vid_regs_fp_pal);\r\nwrite_reg_fp(client, 0x20, vidsource);\r\n} else {\r\nwrite_regs_fp(client, vid_regs_fp);\r\nwrite_reg_fp(client, 0x20, vidsource | 1);\r\n}\r\nstate->std = norm;\r\nreturn 0;\r\n}\r\nstatic int s2250_s_ctrl(struct v4l2_ctrl *ctrl)\r\n{\r\nstruct s2250 *state = container_of(ctrl->handler, struct s2250, hdl);\r\nstruct i2c_client *client = v4l2_get_subdevdata(&state->sd);\r\nu16 oldvalue;\r\nswitch (ctrl->id) {\r\ncase V4L2_CID_BRIGHTNESS:\r\nread_reg_fp(client, VPX322_ADDR_BRIGHTNESS0, &oldvalue);\r\nwrite_reg_fp(client, VPX322_ADDR_BRIGHTNESS0,\r\nctrl->val | (oldvalue & ~0xff));\r\nread_reg_fp(client, VPX322_ADDR_BRIGHTNESS1, &oldvalue);\r\nwrite_reg_fp(client, VPX322_ADDR_BRIGHTNESS1,\r\nctrl->val | (oldvalue & ~0xff));\r\nwrite_reg_fp(client, 0x140, 0x60);\r\nbreak;\r\ncase V4L2_CID_CONTRAST:\r\nread_reg_fp(client, VPX322_ADDR_CONTRAST0, &oldvalue);\r\nwrite_reg_fp(client, VPX322_ADDR_CONTRAST0,\r\nctrl->val | (oldvalue & ~0x3f));\r\nread_reg_fp(client, VPX322_ADDR_CONTRAST1, &oldvalue);\r\nwrite_reg_fp(client, VPX322_ADDR_CONTRAST1,\r\nctrl->val | (oldvalue & ~0x3f));\r\nwrite_reg_fp(client, 0x140, 0x60);\r\nbreak;\r\ncase V4L2_CID_SATURATION:\r\nwrite_reg_fp(client, VPX322_ADDR_SAT, ctrl->val);\r\nbreak;\r\ncase V4L2_CID_HUE:\r\nwrite_reg_fp(client, VPX322_ADDR_HUE, ctrl->val);\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int s2250_set_fmt(struct v4l2_subdev *sd,\r\nstruct v4l2_subdev_pad_config *cfg,\r\nstruct v4l2_subdev_format *format)\r\n{\r\nstruct v4l2_mbus_framefmt *fmt = &format->format;\r\nstruct s2250 *state = to_state(sd);\r\nstruct i2c_client *client = v4l2_get_subdevdata(sd);\r\nif (format->pad)\r\nreturn -EINVAL;\r\nif (format->which == V4L2_SUBDEV_FORMAT_TRY)\r\nreturn 0;\r\nif (fmt->height < 640) {\r\nwrite_reg_fp(client, 0x12b, state->reg12b_val | 0x400);\r\nwrite_reg_fp(client, 0x140, 0x060);\r\n} else {\r\nwrite_reg_fp(client, 0x12b, state->reg12b_val & ~0x400);\r\nwrite_reg_fp(client, 0x140, 0x060);\r\n}\r\nreturn 0;\r\n}\r\nstatic int s2250_s_audio_routing(struct v4l2_subdev *sd, u32 input, u32 output,\r\nu32 config)\r\n{\r\nstruct s2250 *state = to_state(sd);\r\nswitch (input) {\r\ncase 0:\r\nwrite_reg(state->audio, 0x08, 0x02);\r\nbreak;\r\ncase 1:\r\nwrite_reg(state->audio, 0x08, 0x04);\r\nbreak;\r\ncase 2:\r\nwrite_reg(state->audio, 0x08, 0x05);\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nstate->audio_input = input;\r\nreturn 0;\r\n}\r\nstatic int s2250_log_status(struct v4l2_subdev *sd)\r\n{\r\nstruct s2250 *state = to_state(sd);\r\nv4l2_info(sd, "Standard: %s\n", state->std == V4L2_STD_NTSC ? "NTSC" :\r\nstate->std == V4L2_STD_PAL ? "PAL" :\r\nstate->std == V4L2_STD_SECAM ? "SECAM" :\r\n"unknown");\r\nv4l2_info(sd, "Input: %s\n", state->input == 0 ? "Composite" :\r\nstate->input == 1 ? "S-video" :\r\n"error");\r\nv4l2_info(sd, "Audio input: %s\n", state->audio_input == 0 ? "Line In" :\r\nstate->audio_input == 1 ? "Mic" :\r\nstate->audio_input == 2 ? "Mic Boost" :\r\n"error");\r\nreturn v4l2_ctrl_subdev_log_status(sd);\r\n}\r\nstatic int s2250_probe(struct i2c_client *client,\r\nconst struct i2c_device_id *id)\r\n{\r\nstruct i2c_client *audio;\r\nstruct i2c_adapter *adapter = client->adapter;\r\nstruct s2250 *state;\r\nstruct v4l2_subdev *sd;\r\nu8 *data;\r\nstruct go7007 *go = i2c_get_adapdata(adapter);\r\nstruct go7007_usb *usb = go->hpi_context;\r\naudio = i2c_new_dummy(adapter, TLV320_ADDRESS >> 1);\r\nif (audio == NULL)\r\nreturn -ENOMEM;\r\nstate = kzalloc(sizeof(struct s2250), GFP_KERNEL);\r\nif (state == NULL) {\r\ni2c_unregister_device(audio);\r\nreturn -ENOMEM;\r\n}\r\nsd = &state->sd;\r\nv4l2_i2c_subdev_init(sd, client, &s2250_ops);\r\nv4l2_info(sd, "initializing %s at address 0x%x on %s\n",\r\n"Sensoray 2250/2251", client->addr, client->adapter->name);\r\nv4l2_ctrl_handler_init(&state->hdl, 4);\r\nv4l2_ctrl_new_std(&state->hdl, &s2250_ctrl_ops,\r\nV4L2_CID_BRIGHTNESS, -128, 127, 1, 0);\r\nv4l2_ctrl_new_std(&state->hdl, &s2250_ctrl_ops,\r\nV4L2_CID_CONTRAST, 0, 0x3f, 1, 0x32);\r\nv4l2_ctrl_new_std(&state->hdl, &s2250_ctrl_ops,\r\nV4L2_CID_SATURATION, 0, 4094, 1, 2070);\r\nv4l2_ctrl_new_std(&state->hdl, &s2250_ctrl_ops,\r\nV4L2_CID_HUE, -512, 511, 1, 0);\r\nsd->ctrl_handler = &state->hdl;\r\nif (state->hdl.error) {\r\nint err = state->hdl.error;\r\nv4l2_ctrl_handler_free(&state->hdl);\r\nkfree(state);\r\nreturn err;\r\n}\r\nstate->std = V4L2_STD_NTSC;\r\nstate->brightness = 50;\r\nstate->contrast = 50;\r\nstate->saturation = 50;\r\nstate->hue = 0;\r\nstate->audio = audio;\r\nif (write_regs(audio, aud_regs) < 0) {\r\ndev_err(&client->dev, "error initializing audio\n");\r\ngoto fail;\r\n}\r\nif (write_regs(client, vid_regs) < 0) {\r\ndev_err(&client->dev, "error initializing decoder\n");\r\ngoto fail;\r\n}\r\nif (write_regs_fp(client, vid_regs_fp) < 0) {\r\ndev_err(&client->dev, "error initializing decoder\n");\r\ngoto fail;\r\n}\r\nwrite_reg_fp(client, 0x20, 0x020 | 1);\r\nwrite_reg_fp(client, 0x21, 0x662);\r\nwrite_reg_fp(client, 0x140, 0x060);\r\nstate->audio_input = 0;\r\nwrite_reg(client, 0x08, 0x02);\r\nif (mutex_lock_interruptible(&usb->i2c_lock) == 0) {\r\ndata = kzalloc(16, GFP_KERNEL);\r\nif (data != NULL) {\r\nint rc = go7007_usb_vendor_request(go, 0x41, 0, 0,\r\ndata, 16, 1);\r\nif (rc > 0) {\r\nu8 mask;\r\ndata[0] = 0;\r\nmask = 1<<5;\r\ndata[0] &= ~mask;\r\ndata[1] |= mask;\r\ngo7007_usb_vendor_request(go, 0x40, 0,\r\n(data[1]<<8)\r\n+ data[1],\r\ndata, 16, 0);\r\n}\r\nkfree(data);\r\n}\r\nmutex_unlock(&usb->i2c_lock);\r\n}\r\nv4l2_info(sd, "initialized successfully\n");\r\nreturn 0;\r\nfail:\r\ni2c_unregister_device(audio);\r\nv4l2_ctrl_handler_free(&state->hdl);\r\nkfree(state);\r\nreturn -EIO;\r\n}\r\nstatic int s2250_remove(struct i2c_client *client)\r\n{\r\nstruct s2250 *state = to_state(i2c_get_clientdata(client));\r\nv4l2_device_unregister_subdev(&state->sd);\r\nv4l2_ctrl_handler_free(&state->hdl);\r\nkfree(state);\r\nreturn 0;\r\n}
