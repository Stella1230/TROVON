void insn_init(struct insn *insn, const void *kaddr, int buf_len, int x86_64)\r\n{\r\nif (buf_len > MAX_INSN_SIZE)\r\nbuf_len = MAX_INSN_SIZE;\r\nmemset(insn, 0, sizeof(*insn));\r\ninsn->kaddr = kaddr;\r\ninsn->end_kaddr = kaddr + buf_len;\r\ninsn->next_byte = kaddr;\r\ninsn->x86_64 = x86_64 ? 1 : 0;\r\ninsn->opnd_bytes = 4;\r\nif (x86_64)\r\ninsn->addr_bytes = 8;\r\nelse\r\ninsn->addr_bytes = 4;\r\n}\r\nvoid insn_get_prefixes(struct insn *insn)\r\n{\r\nstruct insn_field *prefixes = &insn->prefixes;\r\ninsn_attr_t attr;\r\ninsn_byte_t b, lb;\r\nint i, nb;\r\nif (prefixes->got)\r\nreturn;\r\nnb = 0;\r\nlb = 0;\r\nb = peek_next(insn_byte_t, insn);\r\nattr = inat_get_opcode_attribute(b);\r\nwhile (inat_is_legacy_prefix(attr)) {\r\nfor (i = 0; i < nb; i++)\r\nif (prefixes->bytes[i] == b)\r\ngoto found;\r\nif (nb == 4)\r\nbreak;\r\nprefixes->bytes[nb++] = b;\r\nif (inat_is_address_size_prefix(attr)) {\r\nif (insn->x86_64)\r\ninsn->addr_bytes ^= 12;\r\nelse\r\ninsn->addr_bytes ^= 6;\r\n} else if (inat_is_operand_size_prefix(attr)) {\r\ninsn->opnd_bytes ^= 6;\r\n}\r\nfound:\r\nprefixes->nbytes++;\r\ninsn->next_byte++;\r\nlb = b;\r\nb = peek_next(insn_byte_t, insn);\r\nattr = inat_get_opcode_attribute(b);\r\n}\r\nif (lb && lb != insn->prefixes.bytes[3]) {\r\nif (unlikely(insn->prefixes.bytes[3])) {\r\nb = insn->prefixes.bytes[3];\r\nfor (i = 0; i < nb; i++)\r\nif (prefixes->bytes[i] == lb)\r\nprefixes->bytes[i] = b;\r\n}\r\ninsn->prefixes.bytes[3] = lb;\r\n}\r\nif (insn->x86_64) {\r\nb = peek_next(insn_byte_t, insn);\r\nattr = inat_get_opcode_attribute(b);\r\nif (inat_is_rex_prefix(attr)) {\r\ninsn->rex_prefix.value = b;\r\ninsn->rex_prefix.nbytes = 1;\r\ninsn->next_byte++;\r\nif (X86_REX_W(b))\r\ninsn->opnd_bytes = 8;\r\n}\r\n}\r\ninsn->rex_prefix.got = 1;\r\nb = peek_next(insn_byte_t, insn);\r\nattr = inat_get_opcode_attribute(b);\r\nif (inat_is_vex_prefix(attr)) {\r\ninsn_byte_t b2 = peek_nbyte_next(insn_byte_t, insn, 1);\r\nif (!insn->x86_64) {\r\nif (X86_MODRM_MOD(b2) != 3)\r\ngoto vex_end;\r\n}\r\ninsn->vex_prefix.bytes[0] = b;\r\ninsn->vex_prefix.bytes[1] = b2;\r\nif (inat_is_vex3_prefix(attr)) {\r\nb2 = peek_nbyte_next(insn_byte_t, insn, 2);\r\ninsn->vex_prefix.bytes[2] = b2;\r\ninsn->vex_prefix.nbytes = 3;\r\ninsn->next_byte += 3;\r\nif (insn->x86_64 && X86_VEX_W(b2))\r\ninsn->opnd_bytes = 8;\r\n} else {\r\ninsn->vex_prefix.bytes[2] = b2 & 0x7f;\r\ninsn->vex_prefix.nbytes = 2;\r\ninsn->next_byte += 2;\r\n}\r\n}\r\nvex_end:\r\ninsn->vex_prefix.got = 1;\r\nprefixes->got = 1;\r\nerr_out:\r\nreturn;\r\n}\r\nvoid insn_get_opcode(struct insn *insn)\r\n{\r\nstruct insn_field *opcode = &insn->opcode;\r\ninsn_byte_t op;\r\nint pfx_id;\r\nif (opcode->got)\r\nreturn;\r\nif (!insn->prefixes.got)\r\ninsn_get_prefixes(insn);\r\nop = get_next(insn_byte_t, insn);\r\nopcode->bytes[0] = op;\r\nopcode->nbytes = 1;\r\nif (insn_is_avx(insn)) {\r\ninsn_byte_t m, p;\r\nm = insn_vex_m_bits(insn);\r\np = insn_vex_p_bits(insn);\r\ninsn->attr = inat_get_avx_attribute(op, m, p);\r\nif (!inat_accept_vex(insn->attr) && !inat_is_group(insn->attr))\r\ninsn->attr = 0;\r\ngoto end;\r\n}\r\ninsn->attr = inat_get_opcode_attribute(op);\r\nwhile (inat_is_escape(insn->attr)) {\r\nop = get_next(insn_byte_t, insn);\r\nopcode->bytes[opcode->nbytes++] = op;\r\npfx_id = insn_last_prefix_id(insn);\r\ninsn->attr = inat_get_escape_attribute(op, pfx_id, insn->attr);\r\n}\r\nif (inat_must_vex(insn->attr))\r\ninsn->attr = 0;\r\nend:\r\nopcode->got = 1;\r\nerr_out:\r\nreturn;\r\n}\r\nvoid insn_get_modrm(struct insn *insn)\r\n{\r\nstruct insn_field *modrm = &insn->modrm;\r\ninsn_byte_t pfx_id, mod;\r\nif (modrm->got)\r\nreturn;\r\nif (!insn->opcode.got)\r\ninsn_get_opcode(insn);\r\nif (inat_has_modrm(insn->attr)) {\r\nmod = get_next(insn_byte_t, insn);\r\nmodrm->value = mod;\r\nmodrm->nbytes = 1;\r\nif (inat_is_group(insn->attr)) {\r\npfx_id = insn_last_prefix_id(insn);\r\ninsn->attr = inat_get_group_attribute(mod, pfx_id,\r\ninsn->attr);\r\nif (insn_is_avx(insn) && !inat_accept_vex(insn->attr))\r\ninsn->attr = 0;\r\n}\r\n}\r\nif (insn->x86_64 && inat_is_force64(insn->attr))\r\ninsn->opnd_bytes = 8;\r\nmodrm->got = 1;\r\nerr_out:\r\nreturn;\r\n}\r\nint insn_rip_relative(struct insn *insn)\r\n{\r\nstruct insn_field *modrm = &insn->modrm;\r\nif (!insn->x86_64)\r\nreturn 0;\r\nif (!modrm->got)\r\ninsn_get_modrm(insn);\r\nreturn (modrm->nbytes && (modrm->value & 0xc7) == 0x5);\r\n}\r\nvoid insn_get_sib(struct insn *insn)\r\n{\r\ninsn_byte_t modrm;\r\nif (insn->sib.got)\r\nreturn;\r\nif (!insn->modrm.got)\r\ninsn_get_modrm(insn);\r\nif (insn->modrm.nbytes) {\r\nmodrm = (insn_byte_t)insn->modrm.value;\r\nif (insn->addr_bytes != 2 &&\r\nX86_MODRM_MOD(modrm) != 3 && X86_MODRM_RM(modrm) == 4) {\r\ninsn->sib.value = get_next(insn_byte_t, insn);\r\ninsn->sib.nbytes = 1;\r\n}\r\n}\r\ninsn->sib.got = 1;\r\nerr_out:\r\nreturn;\r\n}\r\nvoid insn_get_displacement(struct insn *insn)\r\n{\r\ninsn_byte_t mod, rm, base;\r\nif (insn->displacement.got)\r\nreturn;\r\nif (!insn->sib.got)\r\ninsn_get_sib(insn);\r\nif (insn->modrm.nbytes) {\r\nmod = X86_MODRM_MOD(insn->modrm.value);\r\nrm = X86_MODRM_RM(insn->modrm.value);\r\nbase = X86_SIB_BASE(insn->sib.value);\r\nif (mod == 3)\r\ngoto out;\r\nif (mod == 1) {\r\ninsn->displacement.value = get_next(char, insn);\r\ninsn->displacement.nbytes = 1;\r\n} else if (insn->addr_bytes == 2) {\r\nif ((mod == 0 && rm == 6) || mod == 2) {\r\ninsn->displacement.value =\r\nget_next(short, insn);\r\ninsn->displacement.nbytes = 2;\r\n}\r\n} else {\r\nif ((mod == 0 && rm == 5) || mod == 2 ||\r\n(mod == 0 && base == 5)) {\r\ninsn->displacement.value = get_next(int, insn);\r\ninsn->displacement.nbytes = 4;\r\n}\r\n}\r\n}\r\nout:\r\ninsn->displacement.got = 1;\r\nerr_out:\r\nreturn;\r\n}\r\nstatic int __get_moffset(struct insn *insn)\r\n{\r\nswitch (insn->addr_bytes) {\r\ncase 2:\r\ninsn->moffset1.value = get_next(short, insn);\r\ninsn->moffset1.nbytes = 2;\r\nbreak;\r\ncase 4:\r\ninsn->moffset1.value = get_next(int, insn);\r\ninsn->moffset1.nbytes = 4;\r\nbreak;\r\ncase 8:\r\ninsn->moffset1.value = get_next(int, insn);\r\ninsn->moffset1.nbytes = 4;\r\ninsn->moffset2.value = get_next(int, insn);\r\ninsn->moffset2.nbytes = 4;\r\nbreak;\r\ndefault:\r\ngoto err_out;\r\n}\r\ninsn->moffset1.got = insn->moffset2.got = 1;\r\nreturn 1;\r\nerr_out:\r\nreturn 0;\r\n}\r\nstatic int __get_immv32(struct insn *insn)\r\n{\r\nswitch (insn->opnd_bytes) {\r\ncase 2:\r\ninsn->immediate.value = get_next(short, insn);\r\ninsn->immediate.nbytes = 2;\r\nbreak;\r\ncase 4:\r\ncase 8:\r\ninsn->immediate.value = get_next(int, insn);\r\ninsn->immediate.nbytes = 4;\r\nbreak;\r\ndefault:\r\ngoto err_out;\r\n}\r\nreturn 1;\r\nerr_out:\r\nreturn 0;\r\n}\r\nstatic int __get_immv(struct insn *insn)\r\n{\r\nswitch (insn->opnd_bytes) {\r\ncase 2:\r\ninsn->immediate1.value = get_next(short, insn);\r\ninsn->immediate1.nbytes = 2;\r\nbreak;\r\ncase 4:\r\ninsn->immediate1.value = get_next(int, insn);\r\ninsn->immediate1.nbytes = 4;\r\nbreak;\r\ncase 8:\r\ninsn->immediate1.value = get_next(int, insn);\r\ninsn->immediate1.nbytes = 4;\r\ninsn->immediate2.value = get_next(int, insn);\r\ninsn->immediate2.nbytes = 4;\r\nbreak;\r\ndefault:\r\ngoto err_out;\r\n}\r\ninsn->immediate1.got = insn->immediate2.got = 1;\r\nreturn 1;\r\nerr_out:\r\nreturn 0;\r\n}\r\nstatic int __get_immptr(struct insn *insn)\r\n{\r\nswitch (insn->opnd_bytes) {\r\ncase 2:\r\ninsn->immediate1.value = get_next(short, insn);\r\ninsn->immediate1.nbytes = 2;\r\nbreak;\r\ncase 4:\r\ninsn->immediate1.value = get_next(int, insn);\r\ninsn->immediate1.nbytes = 4;\r\nbreak;\r\ncase 8:\r\nreturn 0;\r\ndefault:\r\ngoto err_out;\r\n}\r\ninsn->immediate2.value = get_next(unsigned short, insn);\r\ninsn->immediate2.nbytes = 2;\r\ninsn->immediate1.got = insn->immediate2.got = 1;\r\nreturn 1;\r\nerr_out:\r\nreturn 0;\r\n}\r\nvoid insn_get_immediate(struct insn *insn)\r\n{\r\nif (insn->immediate.got)\r\nreturn;\r\nif (!insn->displacement.got)\r\ninsn_get_displacement(insn);\r\nif (inat_has_moffset(insn->attr)) {\r\nif (!__get_moffset(insn))\r\ngoto err_out;\r\ngoto done;\r\n}\r\nif (!inat_has_immediate(insn->attr))\r\ngoto done;\r\nswitch (inat_immediate_size(insn->attr)) {\r\ncase INAT_IMM_BYTE:\r\ninsn->immediate.value = get_next(char, insn);\r\ninsn->immediate.nbytes = 1;\r\nbreak;\r\ncase INAT_IMM_WORD:\r\ninsn->immediate.value = get_next(short, insn);\r\ninsn->immediate.nbytes = 2;\r\nbreak;\r\ncase INAT_IMM_DWORD:\r\ninsn->immediate.value = get_next(int, insn);\r\ninsn->immediate.nbytes = 4;\r\nbreak;\r\ncase INAT_IMM_QWORD:\r\ninsn->immediate1.value = get_next(int, insn);\r\ninsn->immediate1.nbytes = 4;\r\ninsn->immediate2.value = get_next(int, insn);\r\ninsn->immediate2.nbytes = 4;\r\nbreak;\r\ncase INAT_IMM_PTR:\r\nif (!__get_immptr(insn))\r\ngoto err_out;\r\nbreak;\r\ncase INAT_IMM_VWORD32:\r\nif (!__get_immv32(insn))\r\ngoto err_out;\r\nbreak;\r\ncase INAT_IMM_VWORD:\r\nif (!__get_immv(insn))\r\ngoto err_out;\r\nbreak;\r\ndefault:\r\ngoto err_out;\r\n}\r\nif (inat_has_second_immediate(insn->attr)) {\r\ninsn->immediate2.value = get_next(char, insn);\r\ninsn->immediate2.nbytes = 1;\r\n}\r\ndone:\r\ninsn->immediate.got = 1;\r\nerr_out:\r\nreturn;\r\n}\r\nvoid insn_get_length(struct insn *insn)\r\n{\r\nif (insn->length)\r\nreturn;\r\nif (!insn->immediate.got)\r\ninsn_get_immediate(insn);\r\ninsn->length = (unsigned char)((unsigned long)insn->next_byte\r\n- (unsigned long)insn->kaddr);\r\n}
