struct sk_buff *wimax_msg_alloc(struct wimax_dev *wimax_dev,\r\nconst char *pipe_name,\r\nconst void *msg, size_t size,\r\ngfp_t gfp_flags)\r\n{\r\nint result;\r\nstruct device *dev = wimax_dev_to_dev(wimax_dev);\r\nsize_t msg_size;\r\nvoid *genl_msg;\r\nstruct sk_buff *skb;\r\nmsg_size = nla_total_size(size)\r\n+ nla_total_size(sizeof(u32))\r\n+ (pipe_name ? nla_total_size(strlen(pipe_name)) : 0);\r\nresult = -ENOMEM;\r\nskb = genlmsg_new(msg_size, gfp_flags);\r\nif (skb == NULL)\r\ngoto error_new;\r\ngenl_msg = genlmsg_put(skb, 0, 0, &wimax_gnl_family,\r\n0, WIMAX_GNL_OP_MSG_TO_USER);\r\nif (genl_msg == NULL) {\r\ndev_err(dev, "no memory to create generic netlink message\n");\r\ngoto error_genlmsg_put;\r\n}\r\nresult = nla_put_u32(skb, WIMAX_GNL_MSG_IFIDX,\r\nwimax_dev->net_dev->ifindex);\r\nif (result < 0) {\r\ndev_err(dev, "no memory to add ifindex attribute\n");\r\ngoto error_nla_put;\r\n}\r\nif (pipe_name) {\r\nresult = nla_put_string(skb, WIMAX_GNL_MSG_PIPE_NAME,\r\npipe_name);\r\nif (result < 0) {\r\ndev_err(dev, "no memory to add pipe_name attribute\n");\r\ngoto error_nla_put;\r\n}\r\n}\r\nresult = nla_put(skb, WIMAX_GNL_MSG_DATA, size, msg);\r\nif (result < 0) {\r\ndev_err(dev, "no memory to add payload (msg %p size %zu) in "\r\n"attribute: %d\n", msg, size, result);\r\ngoto error_nla_put;\r\n}\r\ngenlmsg_end(skb, genl_msg);\r\nreturn skb;\r\nerror_nla_put:\r\nerror_genlmsg_put:\r\nerror_new:\r\nnlmsg_free(skb);\r\nreturn ERR_PTR(result);\r\n}\r\nconst void *wimax_msg_data_len(struct sk_buff *msg, size_t *size)\r\n{\r\nstruct nlmsghdr *nlh = (void *) msg->head;\r\nstruct nlattr *nla;\r\nnla = nlmsg_find_attr(nlh, sizeof(struct genlmsghdr),\r\nWIMAX_GNL_MSG_DATA);\r\nif (nla == NULL) {\r\npr_err("Cannot find attribute WIMAX_GNL_MSG_DATA\n");\r\nreturn NULL;\r\n}\r\n*size = nla_len(nla);\r\nreturn nla_data(nla);\r\n}\r\nconst void *wimax_msg_data(struct sk_buff *msg)\r\n{\r\nstruct nlmsghdr *nlh = (void *) msg->head;\r\nstruct nlattr *nla;\r\nnla = nlmsg_find_attr(nlh, sizeof(struct genlmsghdr),\r\nWIMAX_GNL_MSG_DATA);\r\nif (nla == NULL) {\r\npr_err("Cannot find attribute WIMAX_GNL_MSG_DATA\n");\r\nreturn NULL;\r\n}\r\nreturn nla_data(nla);\r\n}\r\nssize_t wimax_msg_len(struct sk_buff *msg)\r\n{\r\nstruct nlmsghdr *nlh = (void *) msg->head;\r\nstruct nlattr *nla;\r\nnla = nlmsg_find_attr(nlh, sizeof(struct genlmsghdr),\r\nWIMAX_GNL_MSG_DATA);\r\nif (nla == NULL) {\r\npr_err("Cannot find attribute WIMAX_GNL_MSG_DATA\n");\r\nreturn -EINVAL;\r\n}\r\nreturn nla_len(nla);\r\n}\r\nint wimax_msg_send(struct wimax_dev *wimax_dev, struct sk_buff *skb)\r\n{\r\nstruct device *dev = wimax_dev_to_dev(wimax_dev);\r\nvoid *msg = skb->data;\r\nsize_t size = skb->len;\r\nmight_sleep();\r\nd_printf(1, dev, "CTX: wimax msg, %zu bytes\n", size);\r\nd_dump(2, dev, msg, size);\r\ngenlmsg_multicast(&wimax_gnl_family, skb, 0, 0, GFP_KERNEL);\r\nd_printf(1, dev, "CTX: genl multicast done\n");\r\nreturn 0;\r\n}\r\nint wimax_msg(struct wimax_dev *wimax_dev, const char *pipe_name,\r\nconst void *buf, size_t size, gfp_t gfp_flags)\r\n{\r\nint result = -ENOMEM;\r\nstruct sk_buff *skb;\r\nskb = wimax_msg_alloc(wimax_dev, pipe_name, buf, size, gfp_flags);\r\nif (IS_ERR(skb))\r\nresult = PTR_ERR(skb);\r\nelse\r\nresult = wimax_msg_send(wimax_dev, skb);\r\nreturn result;\r\n}\r\nint wimax_gnl_doit_msg_from_user(struct sk_buff *skb, struct genl_info *info)\r\n{\r\nint result, ifindex;\r\nstruct wimax_dev *wimax_dev;\r\nstruct device *dev;\r\nstruct nlmsghdr *nlh = info->nlhdr;\r\nchar *pipe_name;\r\nvoid *msg_buf;\r\nsize_t msg_len;\r\nmight_sleep();\r\nd_fnstart(3, NULL, "(skb %p info %p)\n", skb, info);\r\nresult = -ENODEV;\r\nif (info->attrs[WIMAX_GNL_MSG_IFIDX] == NULL) {\r\npr_err("WIMAX_GNL_MSG_FROM_USER: can't find IFIDX attribute\n");\r\ngoto error_no_wimax_dev;\r\n}\r\nifindex = nla_get_u32(info->attrs[WIMAX_GNL_MSG_IFIDX]);\r\nwimax_dev = wimax_dev_get_by_genl_info(info, ifindex);\r\nif (wimax_dev == NULL)\r\ngoto error_no_wimax_dev;\r\ndev = wimax_dev_to_dev(wimax_dev);\r\nresult = -EINVAL;\r\nif (info->attrs[WIMAX_GNL_MSG_DATA] == NULL) {\r\ndev_err(dev, "WIMAX_GNL_MSG_FROM_USER: can't find MSG_DATA "\r\n"attribute\n");\r\ngoto error_no_data;\r\n}\r\nmsg_buf = nla_data(info->attrs[WIMAX_GNL_MSG_DATA]);\r\nmsg_len = nla_len(info->attrs[WIMAX_GNL_MSG_DATA]);\r\nif (info->attrs[WIMAX_GNL_MSG_PIPE_NAME] == NULL)\r\npipe_name = NULL;\r\nelse {\r\nstruct nlattr *attr = info->attrs[WIMAX_GNL_MSG_PIPE_NAME];\r\nsize_t attr_len = nla_len(attr);\r\nresult = -ENOMEM;\r\npipe_name = kstrndup(nla_data(attr), attr_len + 1, GFP_KERNEL);\r\nif (pipe_name == NULL)\r\ngoto error_alloc;\r\npipe_name[attr_len] = 0;\r\n}\r\nmutex_lock(&wimax_dev->mutex);\r\nresult = wimax_dev_is_ready(wimax_dev);\r\nif (result == -ENOMEDIUM)\r\nresult = 0;\r\nif (result < 0)\r\ngoto error_not_ready;\r\nresult = -ENOSYS;\r\nif (wimax_dev->op_msg_from_user == NULL)\r\ngoto error_noop;\r\nd_printf(1, dev,\r\n"CRX: nlmsghdr len %u type %u flags 0x%04x seq 0x%x pid %u\n",\r\nnlh->nlmsg_len, nlh->nlmsg_type, nlh->nlmsg_flags,\r\nnlh->nlmsg_seq, nlh->nlmsg_pid);\r\nd_printf(1, dev, "CRX: wimax message %zu bytes\n", msg_len);\r\nd_dump(2, dev, msg_buf, msg_len);\r\nresult = wimax_dev->op_msg_from_user(wimax_dev, pipe_name,\r\nmsg_buf, msg_len, info);\r\nerror_noop:\r\nerror_not_ready:\r\nmutex_unlock(&wimax_dev->mutex);\r\nerror_alloc:\r\nkfree(pipe_name);\r\nerror_no_data:\r\ndev_put(wimax_dev->net_dev);\r\nerror_no_wimax_dev:\r\nd_fnend(3, NULL, "(skb %p info %p) = %d\n", skb, info, result);\r\nreturn result;\r\n}
