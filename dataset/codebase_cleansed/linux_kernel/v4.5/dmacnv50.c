static void\r\nnv50_disp_dmac_child_del_(struct nvkm_oproxy *base)\r\n{\r\nstruct nv50_disp_dmac_object *object =\r\ncontainer_of(base, typeof(*object), oproxy);\r\nnvkm_ramht_remove(object->root->ramht, object->hash);\r\n}\r\nstatic int\r\nnv50_disp_dmac_child_new_(struct nv50_disp_chan *base,\r\nconst struct nvkm_oclass *oclass,\r\nvoid *data, u32 size, struct nvkm_object **pobject)\r\n{\r\nstruct nv50_disp_dmac *chan = nv50_disp_dmac(base);\r\nstruct nv50_disp_root *root = chan->base.root;\r\nstruct nvkm_device *device = root->disp->base.engine.subdev.device;\r\nconst struct nvkm_device_oclass *sclass = oclass->priv;\r\nstruct nv50_disp_dmac_object *object;\r\nint ret;\r\nif (!(object = kzalloc(sizeof(*object), GFP_KERNEL)))\r\nreturn -ENOMEM;\r\nnvkm_oproxy_ctor(&nv50_disp_dmac_child_func_, oclass, &object->oproxy);\r\nobject->root = root;\r\n*pobject = &object->oproxy.base;\r\nret = sclass->ctor(device, oclass, data, size, &object->oproxy.object);\r\nif (ret)\r\nreturn ret;\r\nobject->hash = chan->func->bind(chan, object->oproxy.object,\r\noclass->handle);\r\nif (object->hash < 0)\r\nreturn object->hash;\r\nreturn 0;\r\n}\r\nstatic int\r\nnv50_disp_dmac_child_get_(struct nv50_disp_chan *base, int index,\r\nstruct nvkm_oclass *sclass)\r\n{\r\nstruct nv50_disp_dmac *chan = nv50_disp_dmac(base);\r\nstruct nv50_disp *disp = chan->base.root->disp;\r\nstruct nvkm_device *device = disp->base.engine.subdev.device;\r\nconst struct nvkm_device_oclass *oclass = NULL;\r\nsclass->engine = nvkm_device_engine(device, NVKM_ENGINE_DMAOBJ);\r\nif (sclass->engine && sclass->engine->func->base.sclass) {\r\nsclass->engine->func->base.sclass(sclass, index, &oclass);\r\nif (oclass) {\r\nsclass->priv = oclass;\r\nreturn 0;\r\n}\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic void\r\nnv50_disp_dmac_fini_(struct nv50_disp_chan *base)\r\n{\r\nstruct nv50_disp_dmac *chan = nv50_disp_dmac(base);\r\nchan->func->fini(chan);\r\n}\r\nstatic int\r\nnv50_disp_dmac_init_(struct nv50_disp_chan *base)\r\n{\r\nstruct nv50_disp_dmac *chan = nv50_disp_dmac(base);\r\nreturn chan->func->init(chan);\r\n}\r\nstatic void *\r\nnv50_disp_dmac_dtor_(struct nv50_disp_chan *base)\r\n{\r\nreturn nv50_disp_dmac(base);\r\n}\r\nint\r\nnv50_disp_dmac_new_(const struct nv50_disp_dmac_func *func,\r\nconst struct nv50_disp_chan_mthd *mthd,\r\nstruct nv50_disp_root *root, int chid, int head, u64 push,\r\nconst struct nvkm_oclass *oclass,\r\nstruct nvkm_object **pobject)\r\n{\r\nstruct nvkm_device *device = root->disp->base.engine.subdev.device;\r\nstruct nvkm_client *client = oclass->client;\r\nstruct nvkm_dmaobj *dmaobj;\r\nstruct nv50_disp_dmac *chan;\r\nint ret;\r\nif (!(chan = kzalloc(sizeof(*chan), GFP_KERNEL)))\r\nreturn -ENOMEM;\r\n*pobject = &chan->base.object;\r\nchan->func = func;\r\nret = nv50_disp_chan_ctor(&nv50_disp_dmac_func_, mthd, root,\r\nchid, head, oclass, &chan->base);\r\nif (ret)\r\nreturn ret;\r\ndmaobj = nvkm_dma_search(device->dma, client, push);\r\nif (!dmaobj)\r\nreturn -ENOENT;\r\nif (dmaobj->limit - dmaobj->start != 0xfff)\r\nreturn -EINVAL;\r\nswitch (dmaobj->target) {\r\ncase NV_MEM_TARGET_VRAM:\r\nchan->push = 0x00000001 | dmaobj->start >> 8;\r\nbreak;\r\ncase NV_MEM_TARGET_PCI_NOSNOOP:\r\nchan->push = 0x00000003 | dmaobj->start >> 8;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nint\r\nnv50_disp_dmac_bind(struct nv50_disp_dmac *chan,\r\nstruct nvkm_object *object, u32 handle)\r\n{\r\nreturn nvkm_ramht_insert(chan->base.root->ramht, object,\r\nchan->base.chid, -10, handle,\r\nchan->base.chid << 28 |\r\nchan->base.chid);\r\n}\r\nstatic void\r\nnv50_disp_dmac_fini(struct nv50_disp_dmac *chan)\r\n{\r\nstruct nv50_disp *disp = chan->base.root->disp;\r\nstruct nvkm_subdev *subdev = &disp->base.engine.subdev;\r\nstruct nvkm_device *device = subdev->device;\r\nint chid = chan->base.chid;\r\nnvkm_mask(device, 0x610200 + (chid * 0x0010), 0x00001010, 0x00001000);\r\nnvkm_mask(device, 0x610200 + (chid * 0x0010), 0x00000003, 0x00000000);\r\nif (nvkm_msec(device, 2000,\r\nif (!(nvkm_rd32(device, 0x610200 + (chid * 0x10)) & 0x001e0000))\r\nbreak;\r\n) < 0) {\r\nnvkm_error(subdev, "ch %d fini timeout, %08x\n", chid,\r\nnvkm_rd32(device, 0x610200 + (chid * 0x10)));\r\n}\r\nnvkm_mask(device, 0x610028, 0x00010001 << chid, 0x00000000 << chid);\r\n}\r\nstatic int\r\nnv50_disp_dmac_init(struct nv50_disp_dmac *chan)\r\n{\r\nstruct nv50_disp *disp = chan->base.root->disp;\r\nstruct nvkm_subdev *subdev = &disp->base.engine.subdev;\r\nstruct nvkm_device *device = subdev->device;\r\nint chid = chan->base.chid;\r\nnvkm_mask(device, 0x610028, 0x00010000 << chid, 0x00010000 << chid);\r\nnvkm_wr32(device, 0x610204 + (chid * 0x0010), chan->push);\r\nnvkm_wr32(device, 0x610208 + (chid * 0x0010), 0x00010000);\r\nnvkm_wr32(device, 0x61020c + (chid * 0x0010), chid);\r\nnvkm_mask(device, 0x610200 + (chid * 0x0010), 0x00000010, 0x00000010);\r\nnvkm_wr32(device, 0x640000 + (chid * 0x1000), 0x00000000);\r\nnvkm_wr32(device, 0x610200 + (chid * 0x0010), 0x00000013);\r\nif (nvkm_msec(device, 2000,\r\nif (!(nvkm_rd32(device, 0x610200 + (chid * 0x10)) & 0x80000000))\r\nbreak;\r\n) < 0) {\r\nnvkm_error(subdev, "ch %d init timeout, %08x\n", chid,\r\nnvkm_rd32(device, 0x610200 + (chid * 0x10)));\r\nreturn -EBUSY;\r\n}\r\nreturn 0;\r\n}
