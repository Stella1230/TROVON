static void amdgpu_fence_write(struct amdgpu_ring *ring, u32 seq)\r\n{\r\nstruct amdgpu_fence_driver *drv = &ring->fence_drv;\r\nif (drv->cpu_addr)\r\n*drv->cpu_addr = cpu_to_le32(seq);\r\n}\r\nstatic u32 amdgpu_fence_read(struct amdgpu_ring *ring)\r\n{\r\nstruct amdgpu_fence_driver *drv = &ring->fence_drv;\r\nu32 seq = 0;\r\nif (drv->cpu_addr)\r\nseq = le32_to_cpu(*drv->cpu_addr);\r\nelse\r\nseq = lower_32_bits(atomic64_read(&drv->last_seq));\r\nreturn seq;\r\n}\r\nint amdgpu_fence_emit(struct amdgpu_ring *ring, void *owner,\r\nstruct amdgpu_fence **fence)\r\n{\r\nstruct amdgpu_device *adev = ring->adev;\r\n*fence = kmem_cache_alloc(amdgpu_fence_slab, GFP_KERNEL);\r\nif ((*fence) == NULL) {\r\nreturn -ENOMEM;\r\n}\r\n(*fence)->seq = ++ring->fence_drv.sync_seq[ring->idx];\r\n(*fence)->ring = ring;\r\n(*fence)->owner = owner;\r\nfence_init(&(*fence)->base, &amdgpu_fence_ops,\r\n&ring->fence_drv.fence_queue.lock,\r\nadev->fence_context + ring->idx,\r\n(*fence)->seq);\r\namdgpu_ring_emit_fence(ring, ring->fence_drv.gpu_addr,\r\n(*fence)->seq,\r\nAMDGPU_FENCE_FLAG_INT);\r\nreturn 0;\r\n}\r\nstatic void amdgpu_fence_schedule_fallback(struct amdgpu_ring *ring)\r\n{\r\nmod_timer(&ring->fence_drv.fallback_timer,\r\njiffies + AMDGPU_FENCE_JIFFIES_TIMEOUT);\r\n}\r\nstatic bool amdgpu_fence_activity(struct amdgpu_ring *ring)\r\n{\r\nuint64_t seq, last_seq, last_emitted;\r\nunsigned count_loop = 0;\r\nbool wake = false;\r\nlast_seq = atomic64_read(&ring->fence_drv.last_seq);\r\ndo {\r\nlast_emitted = ring->fence_drv.sync_seq[ring->idx];\r\nseq = amdgpu_fence_read(ring);\r\nseq |= last_seq & 0xffffffff00000000LL;\r\nif (seq < last_seq) {\r\nseq &= 0xffffffff;\r\nseq |= last_emitted & 0xffffffff00000000LL;\r\n}\r\nif (seq <= last_seq || seq > last_emitted) {\r\nbreak;\r\n}\r\nwake = true;\r\nlast_seq = seq;\r\nif ((count_loop++) > 10) {\r\nbreak;\r\n}\r\n} while (atomic64_xchg(&ring->fence_drv.last_seq, seq) > seq);\r\nif (seq < last_emitted)\r\namdgpu_fence_schedule_fallback(ring);\r\nreturn wake;\r\n}\r\nvoid amdgpu_fence_process(struct amdgpu_ring *ring)\r\n{\r\nif (amdgpu_fence_activity(ring))\r\nwake_up_all(&ring->fence_drv.fence_queue);\r\n}\r\nstatic void amdgpu_fence_fallback(unsigned long arg)\r\n{\r\nstruct amdgpu_ring *ring = (void *)arg;\r\namdgpu_fence_process(ring);\r\n}\r\nstatic bool amdgpu_fence_seq_signaled(struct amdgpu_ring *ring, u64 seq)\r\n{\r\nif (atomic64_read(&ring->fence_drv.last_seq) >= seq)\r\nreturn true;\r\namdgpu_fence_process(ring);\r\nif (atomic64_read(&ring->fence_drv.last_seq) >= seq)\r\nreturn true;\r\nreturn false;\r\n}\r\nstatic int amdgpu_fence_ring_wait_seq(struct amdgpu_ring *ring, uint64_t seq)\r\n{\r\nbool signaled = false;\r\nBUG_ON(!ring);\r\nif (seq > ring->fence_drv.sync_seq[ring->idx])\r\nreturn -EINVAL;\r\nif (atomic64_read(&ring->fence_drv.last_seq) >= seq)\r\nreturn 0;\r\namdgpu_fence_schedule_fallback(ring);\r\nwait_event(ring->fence_drv.fence_queue, (\r\n(signaled = amdgpu_fence_seq_signaled(ring, seq))));\r\nif (signaled)\r\nreturn 0;\r\nelse\r\nreturn -EDEADLK;\r\n}\r\nint amdgpu_fence_wait_next(struct amdgpu_ring *ring)\r\n{\r\nuint64_t seq = atomic64_read(&ring->fence_drv.last_seq) + 1ULL;\r\nif (seq >= ring->fence_drv.sync_seq[ring->idx])\r\nreturn -ENOENT;\r\nreturn amdgpu_fence_ring_wait_seq(ring, seq);\r\n}\r\nint amdgpu_fence_wait_empty(struct amdgpu_ring *ring)\r\n{\r\nuint64_t seq = ring->fence_drv.sync_seq[ring->idx];\r\nif (!seq)\r\nreturn 0;\r\nreturn amdgpu_fence_ring_wait_seq(ring, seq);\r\n}\r\nunsigned amdgpu_fence_count_emitted(struct amdgpu_ring *ring)\r\n{\r\nuint64_t emitted;\r\namdgpu_fence_process(ring);\r\nemitted = ring->fence_drv.sync_seq[ring->idx]\r\n- atomic64_read(&ring->fence_drv.last_seq);\r\nif (emitted > 0x10000000)\r\nemitted = 0x10000000;\r\nreturn (unsigned)emitted;\r\n}\r\nbool amdgpu_fence_need_sync(struct amdgpu_fence *fence,\r\nstruct amdgpu_ring *dst_ring)\r\n{\r\nstruct amdgpu_fence_driver *fdrv;\r\nif (!fence)\r\nreturn false;\r\nif (fence->ring == dst_ring)\r\nreturn false;\r\nfdrv = &dst_ring->fence_drv;\r\nif (fence->seq <= fdrv->sync_seq[fence->ring->idx])\r\nreturn false;\r\nreturn true;\r\n}\r\nvoid amdgpu_fence_note_sync(struct amdgpu_fence *fence,\r\nstruct amdgpu_ring *dst_ring)\r\n{\r\nstruct amdgpu_fence_driver *dst, *src;\r\nunsigned i;\r\nif (!fence)\r\nreturn;\r\nif (fence->ring == dst_ring)\r\nreturn;\r\nsrc = &fence->ring->fence_drv;\r\ndst = &dst_ring->fence_drv;\r\nfor (i = 0; i < AMDGPU_MAX_RINGS; ++i) {\r\nif (i == dst_ring->idx)\r\ncontinue;\r\ndst->sync_seq[i] = max(dst->sync_seq[i], src->sync_seq[i]);\r\n}\r\n}\r\nint amdgpu_fence_driver_start_ring(struct amdgpu_ring *ring,\r\nstruct amdgpu_irq_src *irq_src,\r\nunsigned irq_type)\r\n{\r\nstruct amdgpu_device *adev = ring->adev;\r\nuint64_t index;\r\nif (ring != &adev->uvd.ring) {\r\nring->fence_drv.cpu_addr = &adev->wb.wb[ring->fence_offs];\r\nring->fence_drv.gpu_addr = adev->wb.gpu_addr + (ring->fence_offs * 4);\r\n} else {\r\nindex = ALIGN(adev->uvd.fw->size, 8);\r\nring->fence_drv.cpu_addr = adev->uvd.cpu_addr + index;\r\nring->fence_drv.gpu_addr = adev->uvd.gpu_addr + index;\r\n}\r\namdgpu_fence_write(ring, atomic64_read(&ring->fence_drv.last_seq));\r\namdgpu_irq_get(adev, irq_src, irq_type);\r\nring->fence_drv.irq_src = irq_src;\r\nring->fence_drv.irq_type = irq_type;\r\nring->fence_drv.initialized = true;\r\ndev_info(adev->dev, "fence driver on ring %d use gpu addr 0x%016llx, "\r\n"cpu addr 0x%p\n", ring->idx,\r\nring->fence_drv.gpu_addr, ring->fence_drv.cpu_addr);\r\nreturn 0;\r\n}\r\nint amdgpu_fence_driver_init_ring(struct amdgpu_ring *ring)\r\n{\r\nint i, r;\r\nring->fence_drv.cpu_addr = NULL;\r\nring->fence_drv.gpu_addr = 0;\r\nfor (i = 0; i < AMDGPU_MAX_RINGS; ++i)\r\nring->fence_drv.sync_seq[i] = 0;\r\natomic64_set(&ring->fence_drv.last_seq, 0);\r\nring->fence_drv.initialized = false;\r\nsetup_timer(&ring->fence_drv.fallback_timer, amdgpu_fence_fallback,\r\n(unsigned long)ring);\r\ninit_waitqueue_head(&ring->fence_drv.fence_queue);\r\nif (amdgpu_enable_scheduler) {\r\nlong timeout = msecs_to_jiffies(amdgpu_lockup_timeout);\r\nif (timeout == 0) {\r\ntimeout = MAX_SCHEDULE_TIMEOUT;\r\n}\r\nr = amd_sched_init(&ring->sched, &amdgpu_sched_ops,\r\namdgpu_sched_hw_submission,\r\ntimeout, ring->name);\r\nif (r) {\r\nDRM_ERROR("Failed to create scheduler on ring %s.\n",\r\nring->name);\r\nreturn r;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nint amdgpu_fence_driver_init(struct amdgpu_device *adev)\r\n{\r\nif (atomic_inc_return(&amdgpu_fence_slab_ref) == 1) {\r\namdgpu_fence_slab = kmem_cache_create(\r\n"amdgpu_fence", sizeof(struct amdgpu_fence), 0,\r\nSLAB_HWCACHE_ALIGN, NULL);\r\nif (!amdgpu_fence_slab)\r\nreturn -ENOMEM;\r\n}\r\nif (amdgpu_debugfs_fence_init(adev))\r\ndev_err(adev->dev, "fence debugfs file creation failed\n");\r\nreturn 0;\r\n}\r\nvoid amdgpu_fence_driver_fini(struct amdgpu_device *adev)\r\n{\r\nint i, r;\r\nif (atomic_dec_and_test(&amdgpu_fence_slab_ref))\r\nkmem_cache_destroy(amdgpu_fence_slab);\r\nmutex_lock(&adev->ring_lock);\r\nfor (i = 0; i < AMDGPU_MAX_RINGS; i++) {\r\nstruct amdgpu_ring *ring = adev->rings[i];\r\nif (!ring || !ring->fence_drv.initialized)\r\ncontinue;\r\nr = amdgpu_fence_wait_empty(ring);\r\nif (r) {\r\namdgpu_fence_driver_force_completion(adev);\r\n}\r\nwake_up_all(&ring->fence_drv.fence_queue);\r\namdgpu_irq_put(adev, ring->fence_drv.irq_src,\r\nring->fence_drv.irq_type);\r\namd_sched_fini(&ring->sched);\r\ndel_timer_sync(&ring->fence_drv.fallback_timer);\r\nring->fence_drv.initialized = false;\r\n}\r\nmutex_unlock(&adev->ring_lock);\r\n}\r\nvoid amdgpu_fence_driver_suspend(struct amdgpu_device *adev)\r\n{\r\nint i, r;\r\nmutex_lock(&adev->ring_lock);\r\nfor (i = 0; i < AMDGPU_MAX_RINGS; i++) {\r\nstruct amdgpu_ring *ring = adev->rings[i];\r\nif (!ring || !ring->fence_drv.initialized)\r\ncontinue;\r\nr = amdgpu_fence_wait_empty(ring);\r\nif (r) {\r\namdgpu_fence_driver_force_completion(adev);\r\n}\r\namdgpu_irq_put(adev, ring->fence_drv.irq_src,\r\nring->fence_drv.irq_type);\r\n}\r\nmutex_unlock(&adev->ring_lock);\r\n}\r\nvoid amdgpu_fence_driver_resume(struct amdgpu_device *adev)\r\n{\r\nint i;\r\nmutex_lock(&adev->ring_lock);\r\nfor (i = 0; i < AMDGPU_MAX_RINGS; i++) {\r\nstruct amdgpu_ring *ring = adev->rings[i];\r\nif (!ring || !ring->fence_drv.initialized)\r\ncontinue;\r\namdgpu_irq_get(adev, ring->fence_drv.irq_src,\r\nring->fence_drv.irq_type);\r\n}\r\nmutex_unlock(&adev->ring_lock);\r\n}\r\nvoid amdgpu_fence_driver_force_completion(struct amdgpu_device *adev)\r\n{\r\nint i;\r\nfor (i = 0; i < AMDGPU_MAX_RINGS; i++) {\r\nstruct amdgpu_ring *ring = adev->rings[i];\r\nif (!ring || !ring->fence_drv.initialized)\r\ncontinue;\r\namdgpu_fence_write(ring, ring->fence_drv.sync_seq[i]);\r\n}\r\n}\r\nstatic const char *amdgpu_fence_get_driver_name(struct fence *fence)\r\n{\r\nreturn "amdgpu";\r\n}\r\nstatic const char *amdgpu_fence_get_timeline_name(struct fence *f)\r\n{\r\nstruct amdgpu_fence *fence = to_amdgpu_fence(f);\r\nreturn (const char *)fence->ring->name;\r\n}\r\nstatic bool amdgpu_fence_is_signaled(struct fence *f)\r\n{\r\nstruct amdgpu_fence *fence = to_amdgpu_fence(f);\r\nstruct amdgpu_ring *ring = fence->ring;\r\nif (atomic64_read(&ring->fence_drv.last_seq) >= fence->seq)\r\nreturn true;\r\namdgpu_fence_process(ring);\r\nif (atomic64_read(&ring->fence_drv.last_seq) >= fence->seq)\r\nreturn true;\r\nreturn false;\r\n}\r\nstatic int amdgpu_fence_check_signaled(wait_queue_t *wait, unsigned mode, int flags, void *key)\r\n{\r\nstruct amdgpu_fence *fence;\r\nstruct amdgpu_device *adev;\r\nu64 seq;\r\nint ret;\r\nfence = container_of(wait, struct amdgpu_fence, fence_wake);\r\nadev = fence->ring->adev;\r\nseq = atomic64_read(&fence->ring->fence_drv.last_seq);\r\nif (seq >= fence->seq) {\r\nret = fence_signal_locked(&fence->base);\r\nif (!ret)\r\nFENCE_TRACE(&fence->base, "signaled from irq context\n");\r\nelse\r\nFENCE_TRACE(&fence->base, "was already signaled\n");\r\n__remove_wait_queue(&fence->ring->fence_drv.fence_queue, &fence->fence_wake);\r\nfence_put(&fence->base);\r\n} else\r\nFENCE_TRACE(&fence->base, "pending\n");\r\nreturn 0;\r\n}\r\nstatic bool amdgpu_fence_enable_signaling(struct fence *f)\r\n{\r\nstruct amdgpu_fence *fence = to_amdgpu_fence(f);\r\nstruct amdgpu_ring *ring = fence->ring;\r\nif (atomic64_read(&ring->fence_drv.last_seq) >= fence->seq)\r\nreturn false;\r\nfence->fence_wake.flags = 0;\r\nfence->fence_wake.private = NULL;\r\nfence->fence_wake.func = amdgpu_fence_check_signaled;\r\n__add_wait_queue(&ring->fence_drv.fence_queue, &fence->fence_wake);\r\nfence_get(f);\r\nif (!timer_pending(&ring->fence_drv.fallback_timer))\r\namdgpu_fence_schedule_fallback(ring);\r\nFENCE_TRACE(&fence->base, "armed on ring %i!\n", ring->idx);\r\nreturn true;\r\n}\r\nstatic void amdgpu_fence_release(struct fence *f)\r\n{\r\nstruct amdgpu_fence *fence = to_amdgpu_fence(f);\r\nkmem_cache_free(amdgpu_fence_slab, fence);\r\n}\r\nstatic int amdgpu_debugfs_fence_info(struct seq_file *m, void *data)\r\n{\r\nstruct drm_info_node *node = (struct drm_info_node *)m->private;\r\nstruct drm_device *dev = node->minor->dev;\r\nstruct amdgpu_device *adev = dev->dev_private;\r\nint i, j;\r\nfor (i = 0; i < AMDGPU_MAX_RINGS; ++i) {\r\nstruct amdgpu_ring *ring = adev->rings[i];\r\nif (!ring || !ring->fence_drv.initialized)\r\ncontinue;\r\namdgpu_fence_process(ring);\r\nseq_printf(m, "--- ring %d (%s) ---\n", i, ring->name);\r\nseq_printf(m, "Last signaled fence 0x%016llx\n",\r\n(unsigned long long)atomic64_read(&ring->fence_drv.last_seq));\r\nseq_printf(m, "Last emitted 0x%016llx\n",\r\nring->fence_drv.sync_seq[i]);\r\nfor (j = 0; j < AMDGPU_MAX_RINGS; ++j) {\r\nstruct amdgpu_ring *other = adev->rings[j];\r\nif (i != j && other && other->fence_drv.initialized &&\r\nring->fence_drv.sync_seq[j])\r\nseq_printf(m, "Last sync to ring %d 0x%016llx\n",\r\nj, ring->fence_drv.sync_seq[j]);\r\n}\r\n}\r\nreturn 0;\r\n}\r\nint amdgpu_debugfs_fence_init(struct amdgpu_device *adev)\r\n{\r\n#if defined(CONFIG_DEBUG_FS)\r\nreturn amdgpu_debugfs_add_files(adev, amdgpu_debugfs_fence_list, 1);\r\n#else\r\nreturn 0;\r\n#endif\r\n}
