int ccw_device_set_options_mask(struct ccw_device *cdev, unsigned long flags)\r\n{\r\nif ((flags & CCWDEV_EARLY_NOTIFICATION) &&\r\n(flags & CCWDEV_REPORT_ALL))\r\nreturn -EINVAL;\r\ncdev->private->options.fast = (flags & CCWDEV_EARLY_NOTIFICATION) != 0;\r\ncdev->private->options.repall = (flags & CCWDEV_REPORT_ALL) != 0;\r\ncdev->private->options.pgroup = (flags & CCWDEV_DO_PATHGROUP) != 0;\r\ncdev->private->options.force = (flags & CCWDEV_ALLOW_FORCE) != 0;\r\ncdev->private->options.mpath = (flags & CCWDEV_DO_MULTIPATH) != 0;\r\nreturn 0;\r\n}\r\nint ccw_device_set_options(struct ccw_device *cdev, unsigned long flags)\r\n{\r\nif (((flags & CCWDEV_EARLY_NOTIFICATION) &&\r\n(flags & CCWDEV_REPORT_ALL)) ||\r\n((flags & CCWDEV_EARLY_NOTIFICATION) &&\r\ncdev->private->options.repall) ||\r\n((flags & CCWDEV_REPORT_ALL) &&\r\ncdev->private->options.fast))\r\nreturn -EINVAL;\r\ncdev->private->options.fast |= (flags & CCWDEV_EARLY_NOTIFICATION) != 0;\r\ncdev->private->options.repall |= (flags & CCWDEV_REPORT_ALL) != 0;\r\ncdev->private->options.pgroup |= (flags & CCWDEV_DO_PATHGROUP) != 0;\r\ncdev->private->options.force |= (flags & CCWDEV_ALLOW_FORCE) != 0;\r\ncdev->private->options.mpath |= (flags & CCWDEV_DO_MULTIPATH) != 0;\r\nreturn 0;\r\n}\r\nvoid ccw_device_clear_options(struct ccw_device *cdev, unsigned long flags)\r\n{\r\ncdev->private->options.fast &= (flags & CCWDEV_EARLY_NOTIFICATION) == 0;\r\ncdev->private->options.repall &= (flags & CCWDEV_REPORT_ALL) == 0;\r\ncdev->private->options.pgroup &= (flags & CCWDEV_DO_PATHGROUP) == 0;\r\ncdev->private->options.force &= (flags & CCWDEV_ALLOW_FORCE) == 0;\r\ncdev->private->options.mpath &= (flags & CCWDEV_DO_MULTIPATH) == 0;\r\n}\r\nint ccw_device_is_pathgroup(struct ccw_device *cdev)\r\n{\r\nreturn cdev->private->flags.pgroup;\r\n}\r\nint ccw_device_is_multipath(struct ccw_device *cdev)\r\n{\r\nreturn cdev->private->flags.mpath;\r\n}\r\nint ccw_device_clear(struct ccw_device *cdev, unsigned long intparm)\r\n{\r\nstruct subchannel *sch;\r\nint ret;\r\nif (!cdev || !cdev->dev.parent)\r\nreturn -ENODEV;\r\nsch = to_subchannel(cdev->dev.parent);\r\nif (!sch->schib.pmcw.ena)\r\nreturn -EINVAL;\r\nif (cdev->private->state == DEV_STATE_NOT_OPER)\r\nreturn -ENODEV;\r\nif (cdev->private->state != DEV_STATE_ONLINE &&\r\ncdev->private->state != DEV_STATE_W4SENSE)\r\nreturn -EINVAL;\r\nret = cio_clear(sch);\r\nif (ret == 0)\r\ncdev->private->intparm = intparm;\r\nreturn ret;\r\n}\r\nint ccw_device_start_key(struct ccw_device *cdev, struct ccw1 *cpa,\r\nunsigned long intparm, __u8 lpm, __u8 key,\r\nunsigned long flags)\r\n{\r\nstruct subchannel *sch;\r\nint ret;\r\nif (!cdev || !cdev->dev.parent)\r\nreturn -ENODEV;\r\nsch = to_subchannel(cdev->dev.parent);\r\nif (!sch->schib.pmcw.ena)\r\nreturn -EINVAL;\r\nif (cdev->private->state == DEV_STATE_NOT_OPER)\r\nreturn -ENODEV;\r\nif (cdev->private->state == DEV_STATE_VERIFY) {\r\nif (!cdev->private->flags.fake_irb) {\r\ncdev->private->flags.fake_irb = FAKE_CMD_IRB;\r\ncdev->private->intparm = intparm;\r\nreturn 0;\r\n} else\r\nreturn -EBUSY;\r\n}\r\nif (cdev->private->state != DEV_STATE_ONLINE ||\r\n((sch->schib.scsw.cmd.stctl & SCSW_STCTL_PRIM_STATUS) &&\r\n!(sch->schib.scsw.cmd.stctl & SCSW_STCTL_SEC_STATUS)) ||\r\ncdev->private->flags.doverify)\r\nreturn -EBUSY;\r\nret = cio_set_options (sch, flags);\r\nif (ret)\r\nreturn ret;\r\nif (lpm) {\r\nlpm &= sch->lpm;\r\nif (lpm == 0)\r\nreturn -EACCES;\r\n}\r\nret = cio_start_key (sch, cpa, lpm, key);\r\nswitch (ret) {\r\ncase 0:\r\ncdev->private->intparm = intparm;\r\nbreak;\r\ncase -EACCES:\r\ncase -ENODEV:\r\ndev_fsm_event(cdev, DEV_EVENT_VERIFY);\r\nbreak;\r\n}\r\nreturn ret;\r\n}\r\nint ccw_device_start_timeout_key(struct ccw_device *cdev, struct ccw1 *cpa,\r\nunsigned long intparm, __u8 lpm, __u8 key,\r\nunsigned long flags, int expires)\r\n{\r\nint ret;\r\nif (!cdev)\r\nreturn -ENODEV;\r\nccw_device_set_timeout(cdev, expires);\r\nret = ccw_device_start_key(cdev, cpa, intparm, lpm, key, flags);\r\nif (ret != 0)\r\nccw_device_set_timeout(cdev, 0);\r\nreturn ret;\r\n}\r\nint ccw_device_start(struct ccw_device *cdev, struct ccw1 *cpa,\r\nunsigned long intparm, __u8 lpm, unsigned long flags)\r\n{\r\nreturn ccw_device_start_key(cdev, cpa, intparm, lpm,\r\nPAGE_DEFAULT_KEY, flags);\r\n}\r\nint ccw_device_start_timeout(struct ccw_device *cdev, struct ccw1 *cpa,\r\nunsigned long intparm, __u8 lpm,\r\nunsigned long flags, int expires)\r\n{\r\nreturn ccw_device_start_timeout_key(cdev, cpa, intparm, lpm,\r\nPAGE_DEFAULT_KEY, flags,\r\nexpires);\r\n}\r\nint ccw_device_halt(struct ccw_device *cdev, unsigned long intparm)\r\n{\r\nstruct subchannel *sch;\r\nint ret;\r\nif (!cdev || !cdev->dev.parent)\r\nreturn -ENODEV;\r\nsch = to_subchannel(cdev->dev.parent);\r\nif (!sch->schib.pmcw.ena)\r\nreturn -EINVAL;\r\nif (cdev->private->state == DEV_STATE_NOT_OPER)\r\nreturn -ENODEV;\r\nif (cdev->private->state != DEV_STATE_ONLINE &&\r\ncdev->private->state != DEV_STATE_W4SENSE)\r\nreturn -EINVAL;\r\nret = cio_halt(sch);\r\nif (ret == 0)\r\ncdev->private->intparm = intparm;\r\nreturn ret;\r\n}\r\nint ccw_device_resume(struct ccw_device *cdev)\r\n{\r\nstruct subchannel *sch;\r\nif (!cdev || !cdev->dev.parent)\r\nreturn -ENODEV;\r\nsch = to_subchannel(cdev->dev.parent);\r\nif (!sch->schib.pmcw.ena)\r\nreturn -EINVAL;\r\nif (cdev->private->state == DEV_STATE_NOT_OPER)\r\nreturn -ENODEV;\r\nif (cdev->private->state != DEV_STATE_ONLINE ||\r\n!(sch->schib.scsw.cmd.actl & SCSW_ACTL_SUSPENDED))\r\nreturn -EINVAL;\r\nreturn cio_resume(sch);\r\n}\r\nstruct ciw *ccw_device_get_ciw(struct ccw_device *cdev, __u32 ct)\r\n{\r\nint ciw_cnt;\r\nif (cdev->private->flags.esid == 0)\r\nreturn NULL;\r\nfor (ciw_cnt = 0; ciw_cnt < MAX_CIWS; ciw_cnt++)\r\nif (cdev->private->senseid.ciw[ciw_cnt].ct == ct)\r\nreturn cdev->private->senseid.ciw + ciw_cnt;\r\nreturn NULL;\r\n}\r\n__u8 ccw_device_get_path_mask(struct ccw_device *cdev)\r\n{\r\nstruct subchannel *sch;\r\nif (!cdev->dev.parent)\r\nreturn 0;\r\nsch = to_subchannel(cdev->dev.parent);\r\nreturn sch->lpm;\r\n}\r\nstruct channel_path_desc *ccw_device_get_chp_desc(struct ccw_device *cdev,\r\nint chp_idx)\r\n{\r\nstruct subchannel *sch;\r\nstruct chp_id chpid;\r\nsch = to_subchannel(cdev->dev.parent);\r\nchp_id_init(&chpid);\r\nchpid.id = sch->schib.pmcw.chpid[chp_idx];\r\nreturn chp_get_chp_desc(chpid);\r\n}\r\nvoid ccw_device_get_id(struct ccw_device *cdev, struct ccw_dev_id *dev_id)\r\n{\r\n*dev_id = cdev->private->dev_id;\r\n}\r\nint ccw_device_tm_start_key(struct ccw_device *cdev, struct tcw *tcw,\r\nunsigned long intparm, u8 lpm, u8 key)\r\n{\r\nstruct subchannel *sch;\r\nint rc;\r\nsch = to_subchannel(cdev->dev.parent);\r\nif (!sch->schib.pmcw.ena)\r\nreturn -EINVAL;\r\nif (cdev->private->state == DEV_STATE_VERIFY) {\r\nif (!cdev->private->flags.fake_irb) {\r\ncdev->private->flags.fake_irb = FAKE_TM_IRB;\r\ncdev->private->intparm = intparm;\r\nreturn 0;\r\n} else\r\nreturn -EBUSY;\r\n}\r\nif (cdev->private->state != DEV_STATE_ONLINE)\r\nreturn -EIO;\r\nif (lpm) {\r\nlpm &= sch->lpm;\r\nif (lpm == 0)\r\nreturn -EACCES;\r\n}\r\nrc = cio_tm_start_key(sch, tcw, lpm, key);\r\nif (rc == 0)\r\ncdev->private->intparm = intparm;\r\nreturn rc;\r\n}\r\nint ccw_device_tm_start_timeout_key(struct ccw_device *cdev, struct tcw *tcw,\r\nunsigned long intparm, u8 lpm, u8 key,\r\nint expires)\r\n{\r\nint ret;\r\nccw_device_set_timeout(cdev, expires);\r\nret = ccw_device_tm_start_key(cdev, tcw, intparm, lpm, key);\r\nif (ret != 0)\r\nccw_device_set_timeout(cdev, 0);\r\nreturn ret;\r\n}\r\nint ccw_device_tm_start(struct ccw_device *cdev, struct tcw *tcw,\r\nunsigned long intparm, u8 lpm)\r\n{\r\nreturn ccw_device_tm_start_key(cdev, tcw, intparm, lpm,\r\nPAGE_DEFAULT_KEY);\r\n}\r\nint ccw_device_tm_start_timeout(struct ccw_device *cdev, struct tcw *tcw,\r\nunsigned long intparm, u8 lpm, int expires)\r\n{\r\nreturn ccw_device_tm_start_timeout_key(cdev, tcw, intparm, lpm,\r\nPAGE_DEFAULT_KEY, expires);\r\n}\r\nint ccw_device_get_mdc(struct ccw_device *cdev, u8 mask)\r\n{\r\nstruct subchannel *sch = to_subchannel(cdev->dev.parent);\r\nstruct channel_path *chp;\r\nstruct chp_id chpid;\r\nint mdc = 0, i;\r\nif (mask)\r\nmask &= sch->lpm;\r\nelse\r\nmask = sch->lpm;\r\nchp_id_init(&chpid);\r\nfor (i = 0; i < 8; i++) {\r\nif (!(mask & (0x80 >> i)))\r\ncontinue;\r\nchpid.id = sch->schib.pmcw.chpid[i];\r\nchp = chpid_to_chp(chpid);\r\nif (!chp)\r\ncontinue;\r\nmutex_lock(&chp->lock);\r\nif (!chp->desc_fmt1.f) {\r\nmutex_unlock(&chp->lock);\r\nreturn 0;\r\n}\r\nif (!chp->desc_fmt1.r)\r\nmdc = 1;\r\nmdc = mdc ? min_t(int, mdc, chp->desc_fmt1.mdc) :\r\nchp->desc_fmt1.mdc;\r\nmutex_unlock(&chp->lock);\r\n}\r\nreturn mdc;\r\n}\r\nint ccw_device_tm_intrg(struct ccw_device *cdev)\r\n{\r\nstruct subchannel *sch = to_subchannel(cdev->dev.parent);\r\nif (!sch->schib.pmcw.ena)\r\nreturn -EINVAL;\r\nif (cdev->private->state != DEV_STATE_ONLINE)\r\nreturn -EIO;\r\nif (!scsw_is_tm(&sch->schib.scsw) ||\r\n!(scsw_actl(&sch->schib.scsw) & SCSW_ACTL_START_PEND))\r\nreturn -EINVAL;\r\nreturn cio_tm_intrg(sch);\r\n}\r\nvoid ccw_device_get_schid(struct ccw_device *cdev, struct subchannel_id *schid)\r\n{\r\nstruct subchannel *sch = to_subchannel(cdev->dev.parent);\r\n*schid = sch->schid;\r\n}
