static inline void check_other_closed(struct tty_struct *tty)\r\n{\r\nunsigned long flags, old;\r\nfor (flags = ACCESS_ONCE(tty->flags);\r\ntest_bit(TTY_OTHER_CLOSED, &flags);\r\n) {\r\nold = flags;\r\n__set_bit(TTY_OTHER_DONE, &flags);\r\nflags = cmpxchg(&tty->flags, old, flags);\r\nif (old == flags) {\r\nwake_up_interruptible(&tty->read_wait);\r\nbreak;\r\n}\r\n}\r\n}\r\nvoid tty_buffer_lock_exclusive(struct tty_port *port)\r\n{\r\nstruct tty_bufhead *buf = &port->buf;\r\natomic_inc(&buf->priority);\r\nmutex_lock(&buf->lock);\r\n}\r\nvoid tty_buffer_unlock_exclusive(struct tty_port *port)\r\n{\r\nstruct tty_bufhead *buf = &port->buf;\r\nint restart;\r\nrestart = buf->head->commit != buf->head->read;\r\natomic_dec(&buf->priority);\r\nmutex_unlock(&buf->lock);\r\nif (restart)\r\nqueue_work(system_unbound_wq, &buf->work);\r\n}\r\nint tty_buffer_space_avail(struct tty_port *port)\r\n{\r\nint space = port->buf.mem_limit - atomic_read(&port->buf.mem_used);\r\nreturn max(space, 0);\r\n}\r\nstatic void tty_buffer_reset(struct tty_buffer *p, size_t size)\r\n{\r\np->used = 0;\r\np->size = size;\r\np->next = NULL;\r\np->commit = 0;\r\np->read = 0;\r\np->flags = 0;\r\n}\r\nvoid tty_buffer_free_all(struct tty_port *port)\r\n{\r\nstruct tty_bufhead *buf = &port->buf;\r\nstruct tty_buffer *p, *next;\r\nstruct llist_node *llist;\r\nwhile ((p = buf->head) != NULL) {\r\nbuf->head = p->next;\r\nif (p->size > 0)\r\nkfree(p);\r\n}\r\nllist = llist_del_all(&buf->free);\r\nllist_for_each_entry_safe(p, next, llist, free)\r\nkfree(p);\r\ntty_buffer_reset(&buf->sentinel, 0);\r\nbuf->head = &buf->sentinel;\r\nbuf->tail = &buf->sentinel;\r\natomic_set(&buf->mem_used, 0);\r\n}\r\nstatic struct tty_buffer *tty_buffer_alloc(struct tty_port *port, size_t size)\r\n{\r\nstruct llist_node *free;\r\nstruct tty_buffer *p;\r\nsize = __ALIGN_MASK(size, TTYB_ALIGN_MASK);\r\nif (size <= MIN_TTYB_SIZE) {\r\nfree = llist_del_first(&port->buf.free);\r\nif (free) {\r\np = llist_entry(free, struct tty_buffer, free);\r\ngoto found;\r\n}\r\n}\r\nif (atomic_read(&port->buf.mem_used) > port->buf.mem_limit)\r\nreturn NULL;\r\np = kmalloc(sizeof(struct tty_buffer) + 2 * size, GFP_ATOMIC);\r\nif (p == NULL)\r\nreturn NULL;\r\nfound:\r\ntty_buffer_reset(p, size);\r\natomic_add(size, &port->buf.mem_used);\r\nreturn p;\r\n}\r\nstatic void tty_buffer_free(struct tty_port *port, struct tty_buffer *b)\r\n{\r\nstruct tty_bufhead *buf = &port->buf;\r\nWARN_ON(atomic_sub_return(b->size, &buf->mem_used) < 0);\r\nif (b->size > MIN_TTYB_SIZE)\r\nkfree(b);\r\nelse if (b->size > 0)\r\nllist_add(&b->free, &buf->free);\r\n}\r\nvoid tty_buffer_flush(struct tty_struct *tty, struct tty_ldisc *ld)\r\n{\r\nstruct tty_port *port = tty->port;\r\nstruct tty_bufhead *buf = &port->buf;\r\nstruct tty_buffer *next;\r\natomic_inc(&buf->priority);\r\nmutex_lock(&buf->lock);\r\nwhile ((next = smp_load_acquire(&buf->head->next)) != NULL) {\r\ntty_buffer_free(port, buf->head);\r\nbuf->head = next;\r\n}\r\nbuf->head->read = buf->head->commit;\r\nif (ld && ld->ops->flush_buffer)\r\nld->ops->flush_buffer(tty);\r\ncheck_other_closed(tty);\r\natomic_dec(&buf->priority);\r\nmutex_unlock(&buf->lock);\r\n}\r\nstatic int __tty_buffer_request_room(struct tty_port *port, size_t size,\r\nint flags)\r\n{\r\nstruct tty_bufhead *buf = &port->buf;\r\nstruct tty_buffer *b, *n;\r\nint left, change;\r\nb = buf->tail;\r\nif (b->flags & TTYB_NORMAL)\r\nleft = 2 * b->size - b->used;\r\nelse\r\nleft = b->size - b->used;\r\nchange = (b->flags & TTYB_NORMAL) && (~flags & TTYB_NORMAL);\r\nif (change || left < size) {\r\nn = tty_buffer_alloc(port, size);\r\nif (n != NULL) {\r\nn->flags = flags;\r\nbuf->tail = n;\r\nsmp_store_release(&b->commit, b->used);\r\nsmp_store_release(&b->next, n);\r\n} else if (change)\r\nsize = 0;\r\nelse\r\nsize = left;\r\n}\r\nreturn size;\r\n}\r\nint tty_buffer_request_room(struct tty_port *port, size_t size)\r\n{\r\nreturn __tty_buffer_request_room(port, size, 0);\r\n}\r\nint tty_insert_flip_string_fixed_flag(struct tty_port *port,\r\nconst unsigned char *chars, char flag, size_t size)\r\n{\r\nint copied = 0;\r\ndo {\r\nint goal = min_t(size_t, size - copied, TTY_BUFFER_PAGE);\r\nint flags = (flag == TTY_NORMAL) ? TTYB_NORMAL : 0;\r\nint space = __tty_buffer_request_room(port, goal, flags);\r\nstruct tty_buffer *tb = port->buf.tail;\r\nif (unlikely(space == 0))\r\nbreak;\r\nmemcpy(char_buf_ptr(tb, tb->used), chars, space);\r\nif (~tb->flags & TTYB_NORMAL)\r\nmemset(flag_buf_ptr(tb, tb->used), flag, space);\r\ntb->used += space;\r\ncopied += space;\r\nchars += space;\r\n} while (unlikely(size > copied));\r\nreturn copied;\r\n}\r\nint tty_insert_flip_string_flags(struct tty_port *port,\r\nconst unsigned char *chars, const char *flags, size_t size)\r\n{\r\nint copied = 0;\r\ndo {\r\nint goal = min_t(size_t, size - copied, TTY_BUFFER_PAGE);\r\nint space = tty_buffer_request_room(port, goal);\r\nstruct tty_buffer *tb = port->buf.tail;\r\nif (unlikely(space == 0))\r\nbreak;\r\nmemcpy(char_buf_ptr(tb, tb->used), chars, space);\r\nmemcpy(flag_buf_ptr(tb, tb->used), flags, space);\r\ntb->used += space;\r\ncopied += space;\r\nchars += space;\r\nflags += space;\r\n} while (unlikely(size > copied));\r\nreturn copied;\r\n}\r\nvoid tty_schedule_flip(struct tty_port *port)\r\n{\r\nstruct tty_bufhead *buf = &port->buf;\r\nsmp_store_release(&buf->tail->commit, buf->tail->used);\r\nqueue_work(system_unbound_wq, &buf->work);\r\n}\r\nint tty_prepare_flip_string(struct tty_port *port, unsigned char **chars,\r\nsize_t size)\r\n{\r\nint space = __tty_buffer_request_room(port, size, TTYB_NORMAL);\r\nif (likely(space)) {\r\nstruct tty_buffer *tb = port->buf.tail;\r\n*chars = char_buf_ptr(tb, tb->used);\r\nif (~tb->flags & TTYB_NORMAL)\r\nmemset(flag_buf_ptr(tb, tb->used), TTY_NORMAL, space);\r\ntb->used += space;\r\n}\r\nreturn space;\r\n}\r\nstatic int\r\nreceive_buf(struct tty_struct *tty, struct tty_buffer *head, int count)\r\n{\r\nstruct tty_ldisc *disc = tty->ldisc;\r\nunsigned char *p = char_buf_ptr(head, head->read);\r\nchar *f = NULL;\r\nif (~head->flags & TTYB_NORMAL)\r\nf = flag_buf_ptr(head, head->read);\r\nif (disc->ops->receive_buf2)\r\ncount = disc->ops->receive_buf2(tty, p, f, count);\r\nelse {\r\ncount = min_t(int, count, tty->receive_room);\r\nif (count && disc->ops->receive_buf)\r\ndisc->ops->receive_buf(tty, p, f, count);\r\n}\r\nreturn count;\r\n}\r\nstatic void flush_to_ldisc(struct work_struct *work)\r\n{\r\nstruct tty_port *port = container_of(work, struct tty_port, buf.work);\r\nstruct tty_bufhead *buf = &port->buf;\r\nstruct tty_struct *tty;\r\nstruct tty_ldisc *disc;\r\ntty = READ_ONCE(port->itty);\r\nif (tty == NULL)\r\nreturn;\r\ndisc = tty_ldisc_ref(tty);\r\nif (disc == NULL)\r\nreturn;\r\nmutex_lock(&buf->lock);\r\nwhile (1) {\r\nstruct tty_buffer *head = buf->head;\r\nstruct tty_buffer *next;\r\nint count;\r\nif (atomic_read(&buf->priority))\r\nbreak;\r\nnext = smp_load_acquire(&head->next);\r\ncount = smp_load_acquire(&head->commit) - head->read;\r\nif (!count) {\r\nif (next == NULL) {\r\ncheck_other_closed(tty);\r\nbreak;\r\n}\r\nbuf->head = next;\r\ntty_buffer_free(port, head);\r\ncontinue;\r\n}\r\ncount = receive_buf(tty, head, count);\r\nif (!count)\r\nbreak;\r\nhead->read += count;\r\n}\r\nmutex_unlock(&buf->lock);\r\ntty_ldisc_deref(disc);\r\n}\r\nvoid tty_flip_buffer_push(struct tty_port *port)\r\n{\r\ntty_schedule_flip(port);\r\n}\r\nvoid tty_buffer_init(struct tty_port *port)\r\n{\r\nstruct tty_bufhead *buf = &port->buf;\r\nmutex_init(&buf->lock);\r\ntty_buffer_reset(&buf->sentinel, 0);\r\nbuf->head = &buf->sentinel;\r\nbuf->tail = &buf->sentinel;\r\ninit_llist_head(&buf->free);\r\natomic_set(&buf->mem_used, 0);\r\natomic_set(&buf->priority, 0);\r\nINIT_WORK(&buf->work, flush_to_ldisc);\r\nbuf->mem_limit = TTYB_DEFAULT_MEM_LIMIT;\r\n}\r\nint tty_buffer_set_limit(struct tty_port *port, int limit)\r\n{\r\nif (limit < MIN_TTYB_SIZE)\r\nreturn -EINVAL;\r\nport->buf.mem_limit = limit;\r\nreturn 0;\r\n}\r\nvoid tty_buffer_set_lock_subclass(struct tty_port *port)\r\n{\r\nlockdep_set_subclass(&port->buf.lock, TTY_LOCK_SLAVE);\r\n}\r\nbool tty_buffer_restart_work(struct tty_port *port)\r\n{\r\nreturn queue_work(system_unbound_wq, &port->buf.work);\r\n}\r\nbool tty_buffer_cancel_work(struct tty_port *port)\r\n{\r\nreturn cancel_work_sync(&port->buf.work);\r\n}
