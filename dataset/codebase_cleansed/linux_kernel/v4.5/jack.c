static int snd_jack_dev_disconnect(struct snd_device *device)\r\n{\r\nstruct snd_jack *jack = device->device_data;\r\nif (!jack->input_dev)\r\nreturn 0;\r\nif (jack->registered)\r\ninput_unregister_device(jack->input_dev);\r\nelse\r\ninput_free_device(jack->input_dev);\r\njack->input_dev = NULL;\r\nreturn 0;\r\n}\r\nstatic int snd_jack_dev_free(struct snd_device *device)\r\n{\r\nstruct snd_jack *jack = device->device_data;\r\nstruct snd_card *card = device->card;\r\nstruct snd_jack_kctl *jack_kctl, *tmp_jack_kctl;\r\nlist_for_each_entry_safe(jack_kctl, tmp_jack_kctl, &jack->kctl_list, list) {\r\nlist_del_init(&jack_kctl->list);\r\nsnd_ctl_remove(card, jack_kctl->kctl);\r\n}\r\nif (jack->private_free)\r\njack->private_free(jack);\r\nsnd_jack_dev_disconnect(device);\r\nkfree(jack->id);\r\nkfree(jack);\r\nreturn 0;\r\n}\r\nstatic int snd_jack_dev_register(struct snd_device *device)\r\n{\r\nstruct snd_jack *jack = device->device_data;\r\nstruct snd_card *card = device->card;\r\nint err, i;\r\nsnprintf(jack->name, sizeof(jack->name), "%s %s",\r\ncard->shortname, jack->id);\r\nif (!jack->input_dev)\r\nreturn 0;\r\njack->input_dev->name = jack->name;\r\nif (!jack->input_dev->dev.parent)\r\njack->input_dev->dev.parent = snd_card_get_device_link(card);\r\nfor (i = 0; i < ARRAY_SIZE(jack->key); i++) {\r\nint testbit = SND_JACK_BTN_0 >> i;\r\nif (!(jack->type & testbit))\r\ncontinue;\r\nif (!jack->key[i])\r\njack->key[i] = BTN_0 + i;\r\ninput_set_capability(jack->input_dev, EV_KEY, jack->key[i]);\r\n}\r\nerr = input_register_device(jack->input_dev);\r\nif (err == 0)\r\njack->registered = 1;\r\nreturn err;\r\n}\r\nstatic void snd_jack_kctl_private_free(struct snd_kcontrol *kctl)\r\n{\r\nstruct snd_jack_kctl *jack_kctl;\r\njack_kctl = kctl->private_data;\r\nif (jack_kctl) {\r\nlist_del(&jack_kctl->list);\r\nkfree(jack_kctl);\r\n}\r\n}\r\nstatic void snd_jack_kctl_add(struct snd_jack *jack, struct snd_jack_kctl *jack_kctl)\r\n{\r\nlist_add_tail(&jack_kctl->list, &jack->kctl_list);\r\n}\r\nstatic struct snd_jack_kctl * snd_jack_kctl_new(struct snd_card *card, const char *name, unsigned int mask)\r\n{\r\nstruct snd_kcontrol *kctl;\r\nstruct snd_jack_kctl *jack_kctl;\r\nint err;\r\nkctl = snd_kctl_jack_new(name, card);\r\nif (!kctl)\r\nreturn NULL;\r\nerr = snd_ctl_add(card, kctl);\r\nif (err < 0)\r\nreturn NULL;\r\njack_kctl = kzalloc(sizeof(*jack_kctl), GFP_KERNEL);\r\nif (!jack_kctl)\r\ngoto error;\r\njack_kctl->kctl = kctl;\r\njack_kctl->mask_bits = mask;\r\nkctl->private_data = jack_kctl;\r\nkctl->private_free = snd_jack_kctl_private_free;\r\nreturn jack_kctl;\r\nerror:\r\nsnd_ctl_free_one(kctl);\r\nreturn NULL;\r\n}\r\nint snd_jack_add_new_kctl(struct snd_jack *jack, const char * name, int mask)\r\n{\r\nstruct snd_jack_kctl *jack_kctl;\r\njack_kctl = snd_jack_kctl_new(jack->card, name, mask);\r\nif (!jack_kctl)\r\nreturn -ENOMEM;\r\nsnd_jack_kctl_add(jack, jack_kctl);\r\nreturn 0;\r\n}\r\nint snd_jack_new(struct snd_card *card, const char *id, int type,\r\nstruct snd_jack **jjack, bool initial_kctl, bool phantom_jack)\r\n{\r\nstruct snd_jack *jack;\r\nstruct snd_jack_kctl *jack_kctl = NULL;\r\nint err;\r\nint i;\r\nstatic struct snd_device_ops ops = {\r\n.dev_free = snd_jack_dev_free,\r\n.dev_register = snd_jack_dev_register,\r\n.dev_disconnect = snd_jack_dev_disconnect,\r\n};\r\nif (initial_kctl) {\r\njack_kctl = snd_jack_kctl_new(card, id, type);\r\nif (!jack_kctl)\r\nreturn -ENOMEM;\r\n}\r\njack = kzalloc(sizeof(struct snd_jack), GFP_KERNEL);\r\nif (jack == NULL)\r\nreturn -ENOMEM;\r\njack->id = kstrdup(id, GFP_KERNEL);\r\nif (!phantom_jack) {\r\njack->input_dev = input_allocate_device();\r\nif (jack->input_dev == NULL) {\r\nerr = -ENOMEM;\r\ngoto fail_input;\r\n}\r\njack->input_dev->phys = "ALSA";\r\njack->type = type;\r\nfor (i = 0; i < SND_JACK_SWITCH_TYPES; i++)\r\nif (type & (1 << i))\r\ninput_set_capability(jack->input_dev, EV_SW,\r\njack_switch_types[i]);\r\n}\r\nerr = snd_device_new(card, SNDRV_DEV_JACK, jack, &ops);\r\nif (err < 0)\r\ngoto fail_input;\r\njack->card = card;\r\nINIT_LIST_HEAD(&jack->kctl_list);\r\nif (initial_kctl)\r\nsnd_jack_kctl_add(jack, jack_kctl);\r\n*jjack = jack;\r\nreturn 0;\r\nfail_input:\r\ninput_free_device(jack->input_dev);\r\nkfree(jack->id);\r\nkfree(jack);\r\nreturn err;\r\n}\r\nvoid snd_jack_set_parent(struct snd_jack *jack, struct device *parent)\r\n{\r\nWARN_ON(jack->registered);\r\nif (!jack->input_dev)\r\nreturn;\r\njack->input_dev->dev.parent = parent;\r\n}\r\nint snd_jack_set_key(struct snd_jack *jack, enum snd_jack_types type,\r\nint keytype)\r\n{\r\nint key = fls(SND_JACK_BTN_0) - fls(type);\r\nWARN_ON(jack->registered);\r\nif (!keytype || key >= ARRAY_SIZE(jack->key))\r\nreturn -EINVAL;\r\njack->type |= type;\r\njack->key[key] = keytype;\r\nreturn 0;\r\n}\r\nvoid snd_jack_report(struct snd_jack *jack, int status)\r\n{\r\nstruct snd_jack_kctl *jack_kctl;\r\nint i;\r\nif (!jack)\r\nreturn;\r\nlist_for_each_entry(jack_kctl, &jack->kctl_list, list)\r\nsnd_kctl_jack_report(jack->card, jack_kctl->kctl,\r\nstatus & jack_kctl->mask_bits);\r\nif (!jack->input_dev)\r\nreturn;\r\nfor (i = 0; i < ARRAY_SIZE(jack->key); i++) {\r\nint testbit = SND_JACK_BTN_0 >> i;\r\nif (jack->type & testbit)\r\ninput_report_key(jack->input_dev, jack->key[i],\r\nstatus & testbit);\r\n}\r\nfor (i = 0; i < ARRAY_SIZE(jack_switch_types); i++) {\r\nint testbit = 1 << i;\r\nif (jack->type & testbit)\r\ninput_report_switch(jack->input_dev,\r\njack_switch_types[i],\r\nstatus & testbit);\r\n}\r\ninput_sync(jack->input_dev);\r\n}
