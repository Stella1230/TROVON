struct usb_ep *usb_ep_autoconfig_ss(\r\nstruct usb_gadget *gadget,\r\nstruct usb_endpoint_descriptor *desc,\r\nstruct usb_ss_ep_comp_descriptor *ep_comp\r\n)\r\n{\r\nstruct usb_ep *ep;\r\nu8 type;\r\ntype = desc->bmAttributes & USB_ENDPOINT_XFERTYPE_MASK;\r\nif (gadget->ops->match_ep) {\r\nep = gadget->ops->match_ep(gadget, desc, ep_comp);\r\nif (ep)\r\ngoto found_ep;\r\n}\r\nlist_for_each_entry (ep, &gadget->ep_list, ep_list) {\r\nif (usb_gadget_ep_match_desc(gadget, ep, desc, ep_comp))\r\ngoto found_ep;\r\n}\r\nreturn NULL;\r\nfound_ep:\r\nif (desc->wMaxPacketSize == 0)\r\ndesc->wMaxPacketSize = cpu_to_le16(ep->maxpacket_limit);\r\ndesc->bEndpointAddress &= USB_DIR_IN;\r\nif (isdigit(ep->name[2])) {\r\nu8 num = simple_strtoul(&ep->name[2], NULL, 10);\r\ndesc->bEndpointAddress |= num;\r\n} else if (desc->bEndpointAddress & USB_DIR_IN) {\r\nif (++gadget->in_epnum > 15)\r\nreturn NULL;\r\ndesc->bEndpointAddress = USB_DIR_IN | gadget->in_epnum;\r\n} else {\r\nif (++gadget->out_epnum > 15)\r\nreturn NULL;\r\ndesc->bEndpointAddress |= gadget->out_epnum;\r\n}\r\nif ((type == USB_ENDPOINT_XFER_BULK) && !ep_comp) {\r\nint size = ep->maxpacket_limit;\r\nif (size > 64)\r\nsize = 64;\r\ndesc->wMaxPacketSize = cpu_to_le16(size);\r\n}\r\nep->address = desc->bEndpointAddress;\r\nep->desc = NULL;\r\nep->comp_desc = NULL;\r\nep->claimed = true;\r\nreturn ep;\r\n}\r\nstruct usb_ep *usb_ep_autoconfig(\r\nstruct usb_gadget *gadget,\r\nstruct usb_endpoint_descriptor *desc\r\n)\r\n{\r\nreturn usb_ep_autoconfig_ss(gadget, desc, NULL);\r\n}\r\nvoid usb_ep_autoconfig_release(struct usb_ep *ep)\r\n{\r\nep->claimed = false;\r\nep->driver_data = NULL;\r\n}\r\nvoid usb_ep_autoconfig_reset (struct usb_gadget *gadget)\r\n{\r\nstruct usb_ep *ep;\r\nlist_for_each_entry (ep, &gadget->ep_list, ep_list) {\r\nep->claimed = false;\r\nep->driver_data = NULL;\r\n}\r\ngadget->in_epnum = 0;\r\ngadget->out_epnum = 0;\r\n}
