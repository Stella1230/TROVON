static const struct pata_macio_timing *pata_macio_find_timing(\r\nstruct pata_macio_priv *priv,\r\nint mode)\r\n{\r\nint i;\r\nfor (i = 0; priv->timings[i].mode > 0; i++) {\r\nif (priv->timings[i].mode == mode)\r\nreturn &priv->timings[i];\r\n}\r\nreturn NULL;\r\n}\r\nstatic void pata_macio_apply_timings(struct ata_port *ap, unsigned int device)\r\n{\r\nstruct pata_macio_priv *priv = ap->private_data;\r\nvoid __iomem *rbase = ap->ioaddr.cmd_addr;\r\nif (priv->kind == controller_sh_ata6 ||\r\npriv->kind == controller_un_ata6 ||\r\npriv->kind == controller_k2_ata6) {\r\nwritel(priv->treg[device][0], rbase + IDE_KAUAI_PIO_CONFIG);\r\nwritel(priv->treg[device][1], rbase + IDE_KAUAI_ULTRA_CONFIG);\r\n} else\r\nwritel(priv->treg[device][0], rbase + IDE_TIMING_CONFIG);\r\n}\r\nstatic void pata_macio_dev_select(struct ata_port *ap, unsigned int device)\r\n{\r\nata_sff_dev_select(ap, device);\r\npata_macio_apply_timings(ap, device);\r\n}\r\nstatic void pata_macio_set_timings(struct ata_port *ap,\r\nstruct ata_device *adev)\r\n{\r\nstruct pata_macio_priv *priv = ap->private_data;\r\nconst struct pata_macio_timing *t;\r\ndev_dbg(priv->dev, "Set timings: DEV=%d,PIO=0x%x (%s),DMA=0x%x (%s)\n",\r\nadev->devno,\r\nadev->pio_mode,\r\nata_mode_string(ata_xfer_mode2mask(adev->pio_mode)),\r\nadev->dma_mode,\r\nata_mode_string(ata_xfer_mode2mask(adev->dma_mode)));\r\npriv->treg[adev->devno][0] = priv->treg[adev->devno][1] = 0;\r\nt = pata_macio_find_timing(priv, adev->pio_mode);\r\nif (t == NULL) {\r\ndev_warn(priv->dev, "Invalid PIO timing requested: 0x%x\n",\r\nadev->pio_mode);\r\nt = pata_macio_find_timing(priv, XFER_PIO_0);\r\n}\r\nBUG_ON(t == NULL);\r\npriv->treg[adev->devno][0] |= t->reg1;\r\nt = pata_macio_find_timing(priv, adev->dma_mode);\r\nif (t == NULL || (t->reg1 == 0 && t->reg2 == 0)) {\r\ndev_dbg(priv->dev, "DMA timing not set yet, using MW_DMA_0\n");\r\nt = pata_macio_find_timing(priv, XFER_MW_DMA_0);\r\n}\r\nBUG_ON(t == NULL);\r\npriv->treg[adev->devno][0] |= t->reg1;\r\npriv->treg[adev->devno][1] |= t->reg2;\r\ndev_dbg(priv->dev, " -> %08x %08x\n",\r\npriv->treg[adev->devno][0],\r\npriv->treg[adev->devno][1]);\r\npata_macio_apply_timings(ap, adev->devno);\r\n}\r\nstatic void pata_macio_default_timings(struct pata_macio_priv *priv)\r\n{\r\nunsigned int value, value2 = 0;\r\nswitch(priv->kind) {\r\ncase controller_sh_ata6:\r\nvalue = 0x0a820c97;\r\nvalue2 = 0x00033031;\r\nbreak;\r\ncase controller_un_ata6:\r\ncase controller_k2_ata6:\r\nvalue = 0x08618a92;\r\nvalue2 = 0x00002921;\r\nbreak;\r\ncase controller_kl_ata4:\r\nvalue = 0x0008438c;\r\nbreak;\r\ncase controller_kl_ata3:\r\nvalue = 0x00084526;\r\nbreak;\r\ncase controller_heathrow:\r\ncase controller_ohare:\r\ndefault:\r\nvalue = 0x00074526;\r\nbreak;\r\n}\r\npriv->treg[0][0] = priv->treg[1][0] = value;\r\npriv->treg[0][1] = priv->treg[1][1] = value2;\r\n}\r\nstatic int pata_macio_cable_detect(struct ata_port *ap)\r\n{\r\nstruct pata_macio_priv *priv = ap->private_data;\r\nif (priv->kind == controller_kl_ata4 ||\r\npriv->kind == controller_un_ata6 ||\r\npriv->kind == controller_k2_ata6 ||\r\npriv->kind == controller_sh_ata6) {\r\nconst char* cable = of_get_property(priv->node, "cable-type",\r\nNULL);\r\nstruct device_node *root = of_find_node_by_path("/");\r\nconst char *model = of_get_property(root, "model", NULL);\r\nif (cable && !strncmp(cable, "80-", 3)) {\r\nif (!strncmp(model, "PowerBook", 9))\r\nreturn ATA_CBL_PATA40_SHORT;\r\nelse\r\nreturn ATA_CBL_PATA80;\r\n}\r\n}\r\nif (of_device_is_compatible(priv->node, "K2-UATA") ||\r\nof_device_is_compatible(priv->node, "shasta-ata"))\r\nreturn ATA_CBL_PATA80;\r\nreturn ATA_CBL_PATA40;\r\n}\r\nstatic void pata_macio_qc_prep(struct ata_queued_cmd *qc)\r\n{\r\nunsigned int write = (qc->tf.flags & ATA_TFLAG_WRITE);\r\nstruct ata_port *ap = qc->ap;\r\nstruct pata_macio_priv *priv = ap->private_data;\r\nstruct scatterlist *sg;\r\nstruct dbdma_cmd *table;\r\nunsigned int si, pi;\r\ndev_dbgdma(priv->dev, "%s: qc %p flags %lx, write %d dev %d\n",\r\n__func__, qc, qc->flags, write, qc->dev->devno);\r\nif (!(qc->flags & ATA_QCFLAG_DMAMAP))\r\nreturn;\r\ntable = (struct dbdma_cmd *) priv->dma_table_cpu;\r\npi = 0;\r\nfor_each_sg(qc->sg, sg, qc->n_elem, si) {\r\nu32 addr, sg_len, len;\r\naddr = (u32) sg_dma_address(sg);\r\nsg_len = sg_dma_len(sg);\r\nwhile (sg_len) {\r\nBUG_ON (pi++ >= MAX_DCMDS);\r\nlen = (sg_len < MAX_DBDMA_SEG) ? sg_len : MAX_DBDMA_SEG;\r\ntable->command = cpu_to_le16(write ? OUTPUT_MORE: INPUT_MORE);\r\ntable->req_count = cpu_to_le16(len);\r\ntable->phy_addr = cpu_to_le32(addr);\r\ntable->cmd_dep = 0;\r\ntable->xfer_status = 0;\r\ntable->res_count = 0;\r\naddr += len;\r\nsg_len -= len;\r\n++table;\r\n}\r\n}\r\nBUG_ON(!pi);\r\ntable--;\r\ntable->command = cpu_to_le16(write ? OUTPUT_LAST: INPUT_LAST);\r\ntable++;\r\nmemset(table, 0, sizeof(struct dbdma_cmd));\r\ntable->command = cpu_to_le16(DBDMA_STOP);\r\ndev_dbgdma(priv->dev, "%s: %d DMA list entries\n", __func__, pi);\r\n}\r\nstatic void pata_macio_freeze(struct ata_port *ap)\r\n{\r\nstruct dbdma_regs __iomem *dma_regs = ap->ioaddr.bmdma_addr;\r\nif (dma_regs) {\r\nunsigned int timeout = 1000000;\r\nwritel((RUN|PAUSE|FLUSH|WAKE|DEAD) << 16, &dma_regs->control);\r\nwhile (--timeout && (readl(&dma_regs->status) & RUN))\r\nudelay(1);\r\n}\r\nata_sff_freeze(ap);\r\n}\r\nstatic void pata_macio_bmdma_setup(struct ata_queued_cmd *qc)\r\n{\r\nstruct ata_port *ap = qc->ap;\r\nstruct pata_macio_priv *priv = ap->private_data;\r\nstruct dbdma_regs __iomem *dma_regs = ap->ioaddr.bmdma_addr;\r\nint dev = qc->dev->devno;\r\ndev_dbgdma(priv->dev, "%s: qc %p\n", __func__, qc);\r\nwritel(priv->dma_table_dma, &dma_regs->cmdptr);\r\nif (priv->kind == controller_kl_ata4 &&\r\n(priv->treg[dev][0] & TR_66_UDMA_EN)) {\r\nvoid __iomem *rbase = ap->ioaddr.cmd_addr;\r\nu32 reg = priv->treg[dev][0];\r\nif (!(qc->tf.flags & ATA_TFLAG_WRITE))\r\nreg += 0x00800000;\r\nwritel(reg, rbase + IDE_TIMING_CONFIG);\r\n}\r\nap->ops->sff_exec_command(ap, &qc->tf);\r\n}\r\nstatic void pata_macio_bmdma_start(struct ata_queued_cmd *qc)\r\n{\r\nstruct ata_port *ap = qc->ap;\r\nstruct pata_macio_priv *priv = ap->private_data;\r\nstruct dbdma_regs __iomem *dma_regs = ap->ioaddr.bmdma_addr;\r\ndev_dbgdma(priv->dev, "%s: qc %p\n", __func__, qc);\r\nwritel((RUN << 16) | RUN, &dma_regs->control);\r\n(void)readl(&dma_regs->control);\r\n}\r\nstatic void pata_macio_bmdma_stop(struct ata_queued_cmd *qc)\r\n{\r\nstruct ata_port *ap = qc->ap;\r\nstruct pata_macio_priv *priv = ap->private_data;\r\nstruct dbdma_regs __iomem *dma_regs = ap->ioaddr.bmdma_addr;\r\nunsigned int timeout = 1000000;\r\ndev_dbgdma(priv->dev, "%s: qc %p\n", __func__, qc);\r\nwritel (((RUN|WAKE|DEAD) << 16), &dma_regs->control);\r\nwhile (--timeout && (readl(&dma_regs->status) & RUN))\r\nudelay(1);\r\n}\r\nstatic u8 pata_macio_bmdma_status(struct ata_port *ap)\r\n{\r\nstruct pata_macio_priv *priv = ap->private_data;\r\nstruct dbdma_regs __iomem *dma_regs = ap->ioaddr.bmdma_addr;\r\nu32 dstat, rstat = ATA_DMA_INTR;\r\nunsigned long timeout = 0;\r\ndstat = readl(&dma_regs->status);\r\ndev_dbgdma(priv->dev, "%s: dstat=%x\n", __func__, dstat);\r\nif ((dstat & (RUN|DEAD)) != RUN)\r\nrstat |= ATA_DMA_ERR;\r\nif ((dstat & ACTIVE) == 0)\r\nreturn rstat;\r\ndev_dbgdma(priv->dev, "%s: DMA still active, flushing...\n", __func__);\r\nudelay(1);\r\nwritel((FLUSH << 16) | FLUSH, &dma_regs->control);\r\nfor (;;) {\r\nudelay(1);\r\ndstat = readl(&dma_regs->status);\r\nif ((dstat & FLUSH) == 0)\r\nbreak;\r\nif (++timeout > 1000) {\r\ndev_warn(priv->dev, "timeout flushing DMA\n");\r\nrstat |= ATA_DMA_ERR;\r\nbreak;\r\n}\r\n}\r\nreturn rstat;\r\n}\r\nstatic int pata_macio_port_start(struct ata_port *ap)\r\n{\r\nstruct pata_macio_priv *priv = ap->private_data;\r\nif (ap->ioaddr.bmdma_addr == NULL)\r\nreturn 0;\r\npriv->dma_table_cpu =\r\ndmam_alloc_coherent(priv->dev,\r\n(MAX_DCMDS + 2) * sizeof(struct dbdma_cmd),\r\n&priv->dma_table_dma, GFP_KERNEL);\r\nif (priv->dma_table_cpu == NULL) {\r\ndev_err(priv->dev, "Unable to allocate DMA command list\n");\r\nap->ioaddr.bmdma_addr = NULL;\r\nap->mwdma_mask = 0;\r\nap->udma_mask = 0;\r\n}\r\nreturn 0;\r\n}\r\nstatic void pata_macio_irq_clear(struct ata_port *ap)\r\n{\r\nstruct pata_macio_priv *priv = ap->private_data;\r\ndev_dbgdma(priv->dev, "%s\n", __func__);\r\n}\r\nstatic void pata_macio_reset_hw(struct pata_macio_priv *priv, int resume)\r\n{\r\ndev_dbg(priv->dev, "Enabling & resetting... \n");\r\nif (priv->mediabay)\r\nreturn;\r\nif (priv->kind == controller_ohare && !resume) {\r\nppc_md.feature_call(PMAC_FTR_IDE_ENABLE, priv->node, 0, 1);\r\n} else {\r\nint rc;\r\nrc = ppc_md.feature_call(PMAC_FTR_IDE_RESET,\r\npriv->node, priv->aapl_bus_id, 1);\r\nppc_md.feature_call(PMAC_FTR_IDE_ENABLE,\r\npriv->node, priv->aapl_bus_id, 1);\r\nmsleep(10);\r\nif (rc == 0) {\r\nppc_md.feature_call(PMAC_FTR_IDE_RESET,\r\npriv->node, priv->aapl_bus_id, 0);\r\nmsleep(IDE_WAKEUP_DELAY_MS);\r\n}\r\n}\r\nif (priv->pdev && resume) {\r\nint rc;\r\npci_restore_state(priv->pdev);\r\nrc = pcim_enable_device(priv->pdev);\r\nif (rc)\r\ndev_err(&priv->pdev->dev,\r\n"Failed to enable device after resume (%d)\n",\r\nrc);\r\nelse\r\npci_set_master(priv->pdev);\r\n}\r\nif (priv->kauai_fcr)\r\nwritel(KAUAI_FCR_UATA_MAGIC |\r\nKAUAI_FCR_UATA_RESET_N |\r\nKAUAI_FCR_UATA_ENABLE, priv->kauai_fcr);\r\n}\r\nstatic int pata_macio_slave_config(struct scsi_device *sdev)\r\n{\r\nstruct ata_port *ap = ata_shost_to_port(sdev->host);\r\nstruct pata_macio_priv *priv = ap->private_data;\r\nstruct ata_device *dev;\r\nu16 cmd;\r\nint rc;\r\nrc = ata_scsi_slave_config(sdev);\r\nif (rc)\r\nreturn rc;\r\ndev = &ap->link.device[sdev->id];\r\nif (priv->kind == controller_ohare) {\r\nblk_queue_update_dma_alignment(sdev->request_queue, 31);\r\nblk_queue_update_dma_pad(sdev->request_queue, 31);\r\nata_dev_info(dev, "OHare alignment limits applied\n");\r\nreturn 0;\r\n}\r\nif (dev->class != ATA_DEV_ATAPI)\r\nreturn 0;\r\nif (priv->kind == controller_sh_ata6 || priv->kind == controller_k2_ata6) {\r\nblk_queue_update_dma_alignment(sdev->request_queue, 15);\r\nblk_queue_update_dma_pad(sdev->request_queue, 15);\r\nBUG_ON(!priv->pdev);\r\npci_write_config_byte(priv->pdev, PCI_CACHE_LINE_SIZE, 0x08);\r\npci_read_config_word(priv->pdev, PCI_COMMAND, &cmd);\r\npci_write_config_word(priv->pdev, PCI_COMMAND,\r\ncmd | PCI_COMMAND_INVALIDATE);\r\nata_dev_info(dev, "K2/Shasta alignment limits applied\n");\r\n}\r\nreturn 0;\r\n}\r\nstatic int pata_macio_do_suspend(struct pata_macio_priv *priv, pm_message_t mesg)\r\n{\r\nint rc;\r\nrc = ata_host_suspend(priv->host, mesg);\r\nif (rc)\r\nreturn rc;\r\npata_macio_default_timings(priv);\r\ndisable_irq(priv->irq);\r\nif (priv->mediabay)\r\nreturn 0;\r\nif (priv->kauai_fcr) {\r\nu32 fcr = readl(priv->kauai_fcr);\r\nfcr &= ~(KAUAI_FCR_UATA_RESET_N | KAUAI_FCR_UATA_ENABLE);\r\nwritel(fcr, priv->kauai_fcr);\r\n}\r\nif (priv->pdev) {\r\npci_save_state(priv->pdev);\r\npci_disable_device(priv->pdev);\r\n}\r\nppc_md.feature_call(PMAC_FTR_IDE_ENABLE, priv->node,\r\npriv->aapl_bus_id, 0);\r\nreturn 0;\r\n}\r\nstatic int pata_macio_do_resume(struct pata_macio_priv *priv)\r\n{\r\npata_macio_reset_hw(priv, 1);\r\npata_macio_apply_timings(priv->host->ports[0], 0);\r\nenable_irq(priv->irq);\r\nata_host_resume(priv->host);\r\nreturn 0;\r\n}\r\nstatic void pata_macio_invariants(struct pata_macio_priv *priv)\r\n{\r\nconst int *bidp;\r\nif (of_device_is_compatible(priv->node, "shasta-ata")) {\r\npriv->kind = controller_sh_ata6;\r\npriv->timings = pata_macio_shasta_timings;\r\n} else if (of_device_is_compatible(priv->node, "kauai-ata")) {\r\npriv->kind = controller_un_ata6;\r\npriv->timings = pata_macio_kauai_timings;\r\n} else if (of_device_is_compatible(priv->node, "K2-UATA")) {\r\npriv->kind = controller_k2_ata6;\r\npriv->timings = pata_macio_kauai_timings;\r\n} else if (of_device_is_compatible(priv->node, "keylargo-ata")) {\r\nif (strcmp(priv->node->name, "ata-4") == 0) {\r\npriv->kind = controller_kl_ata4;\r\npriv->timings = pata_macio_kl66_timings;\r\n} else {\r\npriv->kind = controller_kl_ata3;\r\npriv->timings = pata_macio_kl33_timings;\r\n}\r\n} else if (of_device_is_compatible(priv->node, "heathrow-ata")) {\r\npriv->kind = controller_heathrow;\r\npriv->timings = pata_macio_heathrow_timings;\r\n} else {\r\npriv->kind = controller_ohare;\r\npriv->timings = pata_macio_ohare_timings;\r\n}\r\nbidp = of_get_property(priv->node, "AAPL,bus-id", NULL);\r\npriv->aapl_bus_id = bidp ? *bidp : 0;\r\nif (priv->mediabay && bidp == 0)\r\npriv->aapl_bus_id = 1;\r\n}\r\nstatic void pata_macio_setup_ios(struct ata_ioports *ioaddr,\r\nvoid __iomem * base, void __iomem * dma)\r\n{\r\nioaddr->cmd_addr = base;\r\nioaddr->data_addr = base + (ATA_REG_DATA << 4);\r\nioaddr->error_addr = base + (ATA_REG_ERR << 4);\r\nioaddr->feature_addr = base + (ATA_REG_FEATURE << 4);\r\nioaddr->nsect_addr = base + (ATA_REG_NSECT << 4);\r\nioaddr->lbal_addr = base + (ATA_REG_LBAL << 4);\r\nioaddr->lbam_addr = base + (ATA_REG_LBAM << 4);\r\nioaddr->lbah_addr = base + (ATA_REG_LBAH << 4);\r\nioaddr->device_addr = base + (ATA_REG_DEVICE << 4);\r\nioaddr->status_addr = base + (ATA_REG_STATUS << 4);\r\nioaddr->command_addr = base + (ATA_REG_CMD << 4);\r\nioaddr->altstatus_addr = base + 0x160;\r\nioaddr->ctl_addr = base + 0x160;\r\nioaddr->bmdma_addr = dma;\r\n}\r\nstatic void pmac_macio_calc_timing_masks(struct pata_macio_priv *priv,\r\nstruct ata_port_info *pinfo)\r\n{\r\nint i = 0;\r\npinfo->pio_mask = 0;\r\npinfo->mwdma_mask = 0;\r\npinfo->udma_mask = 0;\r\nwhile (priv->timings[i].mode > 0) {\r\nunsigned int mask = 1U << (priv->timings[i].mode & 0x0f);\r\nswitch(priv->timings[i].mode & 0xf0) {\r\ncase 0x00:\r\npinfo->pio_mask |= (mask >> 8);\r\nbreak;\r\ncase 0x20:\r\npinfo->mwdma_mask |= mask;\r\nbreak;\r\ncase 0x40:\r\npinfo->udma_mask |= mask;\r\nbreak;\r\n}\r\ni++;\r\n}\r\ndev_dbg(priv->dev, "Supported masks: PIO=%lx, MWDMA=%lx, UDMA=%lx\n",\r\npinfo->pio_mask, pinfo->mwdma_mask, pinfo->udma_mask);\r\n}\r\nstatic int pata_macio_common_init(struct pata_macio_priv *priv,\r\nresource_size_t tfregs,\r\nresource_size_t dmaregs,\r\nresource_size_t fcregs,\r\nunsigned long irq)\r\n{\r\nstruct ata_port_info pinfo;\r\nconst struct ata_port_info *ppi[] = { &pinfo, NULL };\r\nvoid __iomem *dma_regs = NULL;\r\npata_macio_invariants(priv);\r\npata_macio_default_timings(priv);\r\ndma_set_max_seg_size(priv->dev, MAX_DBDMA_SEG);\r\nmemset(&pinfo, 0, sizeof(struct ata_port_info));\r\npmac_macio_calc_timing_masks(priv, &pinfo);\r\npinfo.flags = ATA_FLAG_SLAVE_POSS;\r\npinfo.port_ops = &pata_macio_ops;\r\npinfo.private_data = priv;\r\npriv->host = ata_host_alloc_pinfo(priv->dev, ppi, 1);\r\nif (priv->host == NULL) {\r\ndev_err(priv->dev, "Failed to allocate ATA port structure\n");\r\nreturn -ENOMEM;\r\n}\r\npriv->host->private_data = priv;\r\npriv->tfregs = devm_ioremap(priv->dev, tfregs, 0x100);\r\nif (priv->tfregs == NULL) {\r\ndev_err(priv->dev, "Failed to map ATA ports\n");\r\nreturn -ENOMEM;\r\n}\r\npriv->host->iomap = &priv->tfregs;\r\nif (dmaregs != 0) {\r\ndma_regs = devm_ioremap(priv->dev, dmaregs,\r\nsizeof(struct dbdma_regs));\r\nif (dma_regs == NULL)\r\ndev_warn(priv->dev, "Failed to map ATA DMA registers\n");\r\n}\r\nif (fcregs != 0) {\r\npriv->kauai_fcr = devm_ioremap(priv->dev, fcregs, 4);\r\nif (priv->kauai_fcr == NULL) {\r\ndev_err(priv->dev, "Failed to map ATA FCR register\n");\r\nreturn -ENOMEM;\r\n}\r\n}\r\npata_macio_setup_ios(&priv->host->ports[0]->ioaddr,\r\npriv->tfregs, dma_regs);\r\npriv->host->ports[0]->private_data = priv;\r\npata_macio_reset_hw(priv, 0);\r\npata_macio_apply_timings(priv->host->ports[0], 0);\r\nif (priv->pdev && dma_regs)\r\npci_set_master(priv->pdev);\r\ndev_info(priv->dev, "Activating pata-macio chipset %s, Apple bus ID %d\n",\r\nmacio_ata_names[priv->kind], priv->aapl_bus_id);\r\npriv->irq = irq;\r\nreturn ata_host_activate(priv->host, irq, ata_bmdma_interrupt, 0,\r\n&pata_macio_sht);\r\n}\r\nstatic int pata_macio_attach(struct macio_dev *mdev,\r\nconst struct of_device_id *match)\r\n{\r\nstruct pata_macio_priv *priv;\r\nresource_size_t tfregs, dmaregs = 0;\r\nunsigned long irq;\r\nint rc;\r\nif (macio_resource_count(mdev) == 0) {\r\ndev_err(&mdev->ofdev.dev,\r\n"No addresses for controller\n");\r\nreturn -ENXIO;\r\n}\r\nmacio_enable_devres(mdev);\r\npriv = devm_kzalloc(&mdev->ofdev.dev,\r\nsizeof(struct pata_macio_priv), GFP_KERNEL);\r\nif (priv == NULL) {\r\ndev_err(&mdev->ofdev.dev,\r\n"Failed to allocate private memory\n");\r\nreturn -ENOMEM;\r\n}\r\npriv->node = of_node_get(mdev->ofdev.dev.of_node);\r\npriv->mdev = mdev;\r\npriv->dev = &mdev->ofdev.dev;\r\nif (macio_request_resource(mdev, 0, "pata-macio")) {\r\ndev_err(&mdev->ofdev.dev,\r\n"Cannot obtain taskfile resource\n");\r\nreturn -EBUSY;\r\n}\r\ntfregs = macio_resource_start(mdev, 0);\r\nif (macio_resource_count(mdev) >= 2) {\r\nif (macio_request_resource(mdev, 1, "pata-macio-dma"))\r\ndev_err(&mdev->ofdev.dev,\r\n"Cannot obtain DMA resource\n");\r\nelse\r\ndmaregs = macio_resource_start(mdev, 1);\r\n}\r\nif (macio_irq_count(mdev) == 0) {\r\ndev_warn(&mdev->ofdev.dev,\r\n"No interrupts for controller, using 13\n");\r\nirq = irq_create_mapping(NULL, 13);\r\n} else\r\nirq = macio_irq(mdev, 0);\r\nlock_media_bay(priv->mdev->media_bay);\r\nrc = pata_macio_common_init(priv,\r\ntfregs,\r\ndmaregs,\r\n0,\r\nirq);\r\nunlock_media_bay(priv->mdev->media_bay);\r\nreturn rc;\r\n}\r\nstatic int pata_macio_detach(struct macio_dev *mdev)\r\n{\r\nstruct ata_host *host = macio_get_drvdata(mdev);\r\nstruct pata_macio_priv *priv = host->private_data;\r\nlock_media_bay(priv->mdev->media_bay);\r\npriv->host->private_data = NULL;\r\nata_host_detach(host);\r\nunlock_media_bay(priv->mdev->media_bay);\r\nreturn 0;\r\n}\r\nstatic int pata_macio_suspend(struct macio_dev *mdev, pm_message_t mesg)\r\n{\r\nstruct ata_host *host = macio_get_drvdata(mdev);\r\nreturn pata_macio_do_suspend(host->private_data, mesg);\r\n}\r\nstatic int pata_macio_resume(struct macio_dev *mdev)\r\n{\r\nstruct ata_host *host = macio_get_drvdata(mdev);\r\nreturn pata_macio_do_resume(host->private_data);\r\n}\r\nstatic void pata_macio_mb_event(struct macio_dev* mdev, int mb_state)\r\n{\r\nstruct ata_host *host = macio_get_drvdata(mdev);\r\nstruct ata_port *ap;\r\nstruct ata_eh_info *ehi;\r\nstruct ata_device *dev;\r\nunsigned long flags;\r\nif (!host || !host->private_data)\r\nreturn;\r\nap = host->ports[0];\r\nspin_lock_irqsave(ap->lock, flags);\r\nehi = &ap->link.eh_info;\r\nif (mb_state == MB_CD) {\r\nata_ehi_push_desc(ehi, "mediabay plug");\r\nata_ehi_hotplugged(ehi);\r\nata_port_freeze(ap);\r\n} else {\r\nata_ehi_push_desc(ehi, "mediabay unplug");\r\nata_for_each_dev(dev, &ap->link, ALL)\r\ndev->flags |= ATA_DFLAG_DETACH;\r\nata_port_abort(ap);\r\n}\r\nspin_unlock_irqrestore(ap->lock, flags);\r\n}\r\nstatic int pata_macio_pci_attach(struct pci_dev *pdev,\r\nconst struct pci_device_id *id)\r\n{\r\nstruct pata_macio_priv *priv;\r\nstruct device_node *np;\r\nresource_size_t rbase;\r\nnp = pci_device_to_OF_node(pdev);\r\nif (np == NULL) {\r\ndev_err(&pdev->dev,\r\n"Cannot find OF device node for controller\n");\r\nreturn -ENODEV;\r\n}\r\nif (pcim_enable_device(pdev)) {\r\ndev_err(&pdev->dev,\r\n"Cannot enable controller PCI device\n");\r\nreturn -ENXIO;\r\n}\r\npriv = devm_kzalloc(&pdev->dev,\r\nsizeof(struct pata_macio_priv), GFP_KERNEL);\r\nif (priv == NULL) {\r\ndev_err(&pdev->dev,\r\n"Failed to allocate private memory\n");\r\nreturn -ENOMEM;\r\n}\r\npriv->node = of_node_get(np);\r\npriv->pdev = pdev;\r\npriv->dev = &pdev->dev;\r\nif (pci_request_regions(pdev, "pata-macio")) {\r\ndev_err(&pdev->dev,\r\n"Cannot obtain PCI resources\n");\r\nreturn -EBUSY;\r\n}\r\nrbase = pci_resource_start(pdev, 0);\r\nif (pata_macio_common_init(priv,\r\nrbase + 0x2000,\r\nrbase + 0x1000,\r\nrbase,\r\npdev->irq))\r\nreturn -ENXIO;\r\nreturn 0;\r\n}\r\nstatic void pata_macio_pci_detach(struct pci_dev *pdev)\r\n{\r\nstruct ata_host *host = pci_get_drvdata(pdev);\r\nata_host_detach(host);\r\n}\r\nstatic int pata_macio_pci_suspend(struct pci_dev *pdev, pm_message_t mesg)\r\n{\r\nstruct ata_host *host = pci_get_drvdata(pdev);\r\nreturn pata_macio_do_suspend(host->private_data, mesg);\r\n}\r\nstatic int pata_macio_pci_resume(struct pci_dev *pdev)\r\n{\r\nstruct ata_host *host = pci_get_drvdata(pdev);\r\nreturn pata_macio_do_resume(host->private_data);\r\n}\r\nstatic int __init pata_macio_init(void)\r\n{\r\nint rc;\r\nif (!machine_is(powermac))\r\nreturn -ENODEV;\r\nrc = pci_register_driver(&pata_macio_pci_driver);\r\nif (rc)\r\nreturn rc;\r\nrc = macio_register_driver(&pata_macio_driver);\r\nif (rc) {\r\npci_unregister_driver(&pata_macio_pci_driver);\r\nreturn rc;\r\n}\r\nreturn 0;\r\n}\r\nstatic void __exit pata_macio_exit(void)\r\n{\r\nmacio_unregister_driver(&pata_macio_driver);\r\npci_unregister_driver(&pata_macio_pci_driver);\r\n}
