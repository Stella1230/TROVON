static struct xlog_ticket *\r\nxlog_cil_ticket_alloc(\r\nstruct xlog *log)\r\n{\r\nstruct xlog_ticket *tic;\r\ntic = xlog_ticket_alloc(log, 0, 1, XFS_TRANSACTION, 0,\r\nKM_SLEEP|KM_NOFS);\r\ntic->t_trans_type = XFS_TRANS_CHECKPOINT;\r\ntic->t_curr_res = 0;\r\nreturn tic;\r\n}\r\nvoid\r\nxlog_cil_init_post_recovery(\r\nstruct xlog *log)\r\n{\r\nlog->l_cilp->xc_ctx->ticket = xlog_cil_ticket_alloc(log);\r\nlog->l_cilp->xc_ctx->sequence = 1;\r\n}\r\nSTATIC void\r\nxfs_cil_prepare_item(\r\nstruct xlog *log,\r\nstruct xfs_log_vec *lv,\r\nstruct xfs_log_vec *old_lv,\r\nint *diff_len,\r\nint *diff_iovecs)\r\n{\r\nif (lv->lv_buf_len != XFS_LOG_VEC_ORDERED) {\r\n*diff_len += lv->lv_bytes;\r\n*diff_iovecs += lv->lv_niovecs;\r\n}\r\nif (!old_lv)\r\nlv->lv_item->li_ops->iop_pin(lv->lv_item);\r\nelse if (old_lv != lv) {\r\nASSERT(lv->lv_buf_len != XFS_LOG_VEC_ORDERED);\r\n*diff_len -= old_lv->lv_bytes;\r\n*diff_iovecs -= old_lv->lv_niovecs;\r\nkmem_free(old_lv);\r\n}\r\nlv->lv_item->li_lv = lv;\r\nif (!lv->lv_item->li_seq)\r\nlv->lv_item->li_seq = log->l_cilp->xc_ctx->sequence;\r\n}\r\nstatic void\r\nxlog_cil_insert_format_items(\r\nstruct xlog *log,\r\nstruct xfs_trans *tp,\r\nint *diff_len,\r\nint *diff_iovecs)\r\n{\r\nstruct xfs_log_item_desc *lidp;\r\nif (list_empty(&tp->t_items)) {\r\nASSERT(0);\r\nreturn;\r\n}\r\nlist_for_each_entry(lidp, &tp->t_items, lid_trans) {\r\nstruct xfs_log_item *lip = lidp->lid_item;\r\nstruct xfs_log_vec *lv;\r\nstruct xfs_log_vec *old_lv;\r\nint niovecs = 0;\r\nint nbytes = 0;\r\nint buf_size;\r\nbool ordered = false;\r\nif (!(lidp->lid_flags & XFS_LID_DIRTY))\r\ncontinue;\r\nlip->li_ops->iop_size(lip, &niovecs, &nbytes);\r\nif (!niovecs)\r\ncontinue;\r\nif (niovecs == XFS_LOG_VEC_ORDERED) {\r\nordered = true;\r\nniovecs = 0;\r\nnbytes = 0;\r\n}\r\nnbytes += niovecs * sizeof(uint64_t);\r\nnbytes = round_up(nbytes, sizeof(uint64_t));\r\nold_lv = lip->li_lv;\r\nbuf_size = nbytes +\r\nround_up((sizeof(struct xfs_log_vec) +\r\nniovecs * sizeof(struct xfs_log_iovec)),\r\nsizeof(uint64_t));\r\nif (lip->li_lv && buf_size <= lip->li_lv->lv_size) {\r\nlv = lip->li_lv;\r\nlv->lv_next = NULL;\r\nif (ordered)\r\ngoto insert;\r\n*diff_iovecs -= lv->lv_niovecs;\r\n*diff_len -= lv->lv_bytes;\r\n} else {\r\nlv = kmem_zalloc(buf_size, KM_SLEEP|KM_NOFS);\r\nlv->lv_item = lip;\r\nlv->lv_size = buf_size;\r\nif (ordered) {\r\nASSERT(lip->li_lv == NULL);\r\nlv->lv_buf_len = XFS_LOG_VEC_ORDERED;\r\ngoto insert;\r\n}\r\nlv->lv_iovecp = (struct xfs_log_iovec *)&lv[1];\r\n}\r\nlv->lv_niovecs = niovecs;\r\nlv->lv_buf_len = 0;\r\nlv->lv_bytes = 0;\r\nlv->lv_buf = (char *)lv + buf_size - nbytes;\r\nASSERT(IS_ALIGNED((unsigned long)lv->lv_buf, sizeof(uint64_t)));\r\nlip->li_ops->iop_format(lip, lv);\r\ninsert:\r\nASSERT(lv->lv_buf_len <= nbytes);\r\nxfs_cil_prepare_item(log, lv, old_lv, diff_len, diff_iovecs);\r\n}\r\n}\r\nstatic void\r\nxlog_cil_insert_items(\r\nstruct xlog *log,\r\nstruct xfs_trans *tp)\r\n{\r\nstruct xfs_cil *cil = log->l_cilp;\r\nstruct xfs_cil_ctx *ctx = cil->xc_ctx;\r\nstruct xfs_log_item_desc *lidp;\r\nint len = 0;\r\nint diff_iovecs = 0;\r\nint iclog_space;\r\nASSERT(tp);\r\nxlog_cil_insert_format_items(log, tp, &len, &diff_iovecs);\r\nspin_lock(&cil->xc_cil_lock);\r\nlist_for_each_entry(lidp, &tp->t_items, lid_trans) {\r\nstruct xfs_log_item *lip = lidp->lid_item;\r\nif (!(lidp->lid_flags & XFS_LID_DIRTY))\r\ncontinue;\r\nif (!list_is_last(&lip->li_cil, &cil->xc_cil))\r\nlist_move_tail(&lip->li_cil, &cil->xc_cil);\r\n}\r\nlen += diff_iovecs * sizeof(xlog_op_header_t);\r\nctx->nvecs += diff_iovecs;\r\nif (!list_empty(&tp->t_busy))\r\nlist_splice_init(&tp->t_busy, &ctx->busy_extents);\r\nif (ctx->ticket->t_curr_res == 0) {\r\nctx->ticket->t_curr_res = ctx->ticket->t_unit_res;\r\ntp->t_ticket->t_curr_res -= ctx->ticket->t_unit_res;\r\n}\r\niclog_space = log->l_iclog_size - log->l_iclog_hsize;\r\nif (len > 0 && (ctx->space_used / iclog_space !=\r\n(ctx->space_used + len) / iclog_space)) {\r\nint hdrs;\r\nhdrs = (len + iclog_space - 1) / iclog_space;\r\nhdrs *= log->l_iclog_hsize + sizeof(struct xlog_op_header);\r\nctx->ticket->t_unit_res += hdrs;\r\nctx->ticket->t_curr_res += hdrs;\r\ntp->t_ticket->t_curr_res -= hdrs;\r\nASSERT(tp->t_ticket->t_curr_res >= len);\r\n}\r\ntp->t_ticket->t_curr_res -= len;\r\nctx->space_used += len;\r\nspin_unlock(&cil->xc_cil_lock);\r\n}\r\nstatic void\r\nxlog_cil_free_logvec(\r\nstruct xfs_log_vec *log_vector)\r\n{\r\nstruct xfs_log_vec *lv;\r\nfor (lv = log_vector; lv; ) {\r\nstruct xfs_log_vec *next = lv->lv_next;\r\nkmem_free(lv);\r\nlv = next;\r\n}\r\n}\r\nstatic void\r\nxlog_cil_committed(\r\nvoid *args,\r\nint abort)\r\n{\r\nstruct xfs_cil_ctx *ctx = args;\r\nstruct xfs_mount *mp = ctx->cil->xc_log->l_mp;\r\nxfs_trans_committed_bulk(ctx->cil->xc_log->l_ailp, ctx->lv_chain,\r\nctx->start_lsn, abort);\r\nxfs_extent_busy_sort(&ctx->busy_extents);\r\nxfs_extent_busy_clear(mp, &ctx->busy_extents,\r\n(mp->m_flags & XFS_MOUNT_DISCARD) && !abort);\r\nspin_lock(&ctx->cil->xc_push_lock);\r\nif (abort)\r\nwake_up_all(&ctx->cil->xc_commit_wait);\r\nlist_del(&ctx->committing);\r\nspin_unlock(&ctx->cil->xc_push_lock);\r\nxlog_cil_free_logvec(ctx->lv_chain);\r\nif (!list_empty(&ctx->busy_extents)) {\r\nASSERT(mp->m_flags & XFS_MOUNT_DISCARD);\r\nxfs_discard_extents(mp, &ctx->busy_extents);\r\nxfs_extent_busy_clear(mp, &ctx->busy_extents, false);\r\n}\r\nkmem_free(ctx);\r\n}\r\nSTATIC int\r\nxlog_cil_push(\r\nstruct xlog *log)\r\n{\r\nstruct xfs_cil *cil = log->l_cilp;\r\nstruct xfs_log_vec *lv;\r\nstruct xfs_cil_ctx *ctx;\r\nstruct xfs_cil_ctx *new_ctx;\r\nstruct xlog_in_core *commit_iclog;\r\nstruct xlog_ticket *tic;\r\nint num_iovecs;\r\nint error = 0;\r\nstruct xfs_trans_header thdr;\r\nstruct xfs_log_iovec lhdr;\r\nstruct xfs_log_vec lvhdr = { NULL };\r\nxfs_lsn_t commit_lsn;\r\nxfs_lsn_t push_seq;\r\nif (!cil)\r\nreturn 0;\r\nnew_ctx = kmem_zalloc(sizeof(*new_ctx), KM_SLEEP|KM_NOFS);\r\nnew_ctx->ticket = xlog_cil_ticket_alloc(log);\r\ndown_write(&cil->xc_ctx_lock);\r\nctx = cil->xc_ctx;\r\nspin_lock(&cil->xc_push_lock);\r\npush_seq = cil->xc_push_seq;\r\nASSERT(push_seq <= ctx->sequence);\r\nif (list_empty(&cil->xc_cil)) {\r\ncil->xc_push_seq = 0;\r\nspin_unlock(&cil->xc_push_lock);\r\ngoto out_skip;\r\n}\r\nif (push_seq < cil->xc_ctx->sequence) {\r\nspin_unlock(&cil->xc_push_lock);\r\ngoto out_skip;\r\n}\r\nlist_add(&ctx->committing, &cil->xc_committing);\r\nspin_unlock(&cil->xc_push_lock);\r\nlv = NULL;\r\nnum_iovecs = 0;\r\nwhile (!list_empty(&cil->xc_cil)) {\r\nstruct xfs_log_item *item;\r\nitem = list_first_entry(&cil->xc_cil,\r\nstruct xfs_log_item, li_cil);\r\nlist_del_init(&item->li_cil);\r\nif (!ctx->lv_chain)\r\nctx->lv_chain = item->li_lv;\r\nelse\r\nlv->lv_next = item->li_lv;\r\nlv = item->li_lv;\r\nitem->li_lv = NULL;\r\nnum_iovecs += lv->lv_niovecs;\r\n}\r\nINIT_LIST_HEAD(&new_ctx->committing);\r\nINIT_LIST_HEAD(&new_ctx->busy_extents);\r\nnew_ctx->sequence = ctx->sequence + 1;\r\nnew_ctx->cil = cil;\r\ncil->xc_ctx = new_ctx;\r\nspin_lock(&cil->xc_push_lock);\r\ncil->xc_current_sequence = new_ctx->sequence;\r\nspin_unlock(&cil->xc_push_lock);\r\nup_write(&cil->xc_ctx_lock);\r\ntic = ctx->ticket;\r\nthdr.th_magic = XFS_TRANS_HEADER_MAGIC;\r\nthdr.th_type = XFS_TRANS_CHECKPOINT;\r\nthdr.th_tid = tic->t_tid;\r\nthdr.th_num_items = num_iovecs;\r\nlhdr.i_addr = &thdr;\r\nlhdr.i_len = sizeof(xfs_trans_header_t);\r\nlhdr.i_type = XLOG_REG_TYPE_TRANSHDR;\r\ntic->t_curr_res -= lhdr.i_len + sizeof(xlog_op_header_t);\r\nlvhdr.lv_niovecs = 1;\r\nlvhdr.lv_iovecp = &lhdr;\r\nlvhdr.lv_next = ctx->lv_chain;\r\nerror = xlog_write(log, &lvhdr, tic, &ctx->start_lsn, NULL, 0);\r\nif (error)\r\ngoto out_abort_free_ticket;\r\nrestart:\r\nspin_lock(&cil->xc_push_lock);\r\nlist_for_each_entry(new_ctx, &cil->xc_committing, committing) {\r\nif (XLOG_FORCED_SHUTDOWN(log)) {\r\nspin_unlock(&cil->xc_push_lock);\r\ngoto out_abort_free_ticket;\r\n}\r\nif (new_ctx->sequence >= ctx->sequence)\r\ncontinue;\r\nif (!new_ctx->commit_lsn) {\r\nxlog_wait(&cil->xc_commit_wait, &cil->xc_push_lock);\r\ngoto restart;\r\n}\r\n}\r\nspin_unlock(&cil->xc_push_lock);\r\ncommit_lsn = xfs_log_done(log->l_mp, tic, &commit_iclog, false);\r\nif (commit_lsn == -1)\r\ngoto out_abort;\r\nctx->log_cb.cb_func = xlog_cil_committed;\r\nctx->log_cb.cb_arg = ctx;\r\nerror = xfs_log_notify(log->l_mp, commit_iclog, &ctx->log_cb);\r\nif (error)\r\ngoto out_abort;\r\nspin_lock(&cil->xc_push_lock);\r\nctx->commit_lsn = commit_lsn;\r\nwake_up_all(&cil->xc_commit_wait);\r\nspin_unlock(&cil->xc_push_lock);\r\nreturn xfs_log_release_iclog(log->l_mp, commit_iclog);\r\nout_skip:\r\nup_write(&cil->xc_ctx_lock);\r\nxfs_log_ticket_put(new_ctx->ticket);\r\nkmem_free(new_ctx);\r\nreturn 0;\r\nout_abort_free_ticket:\r\nxfs_log_ticket_put(tic);\r\nout_abort:\r\nxlog_cil_committed(ctx, XFS_LI_ABORTED);\r\nreturn -EIO;\r\n}\r\nstatic void\r\nxlog_cil_push_work(\r\nstruct work_struct *work)\r\n{\r\nstruct xfs_cil *cil = container_of(work, struct xfs_cil,\r\nxc_push_work);\r\nxlog_cil_push(cil->xc_log);\r\n}\r\nstatic void\r\nxlog_cil_push_background(\r\nstruct xlog *log)\r\n{\r\nstruct xfs_cil *cil = log->l_cilp;\r\nASSERT(!list_empty(&cil->xc_cil));\r\nif (cil->xc_ctx->space_used < XLOG_CIL_SPACE_LIMIT(log))\r\nreturn;\r\nspin_lock(&cil->xc_push_lock);\r\nif (cil->xc_push_seq < cil->xc_current_sequence) {\r\ncil->xc_push_seq = cil->xc_current_sequence;\r\nqueue_work(log->l_mp->m_cil_workqueue, &cil->xc_push_work);\r\n}\r\nspin_unlock(&cil->xc_push_lock);\r\n}\r\nstatic void\r\nxlog_cil_push_now(\r\nstruct xlog *log,\r\nxfs_lsn_t push_seq)\r\n{\r\nstruct xfs_cil *cil = log->l_cilp;\r\nif (!cil)\r\nreturn;\r\nASSERT(push_seq && push_seq <= cil->xc_current_sequence);\r\nflush_work(&cil->xc_push_work);\r\nspin_lock(&cil->xc_push_lock);\r\nif (list_empty(&cil->xc_cil) || push_seq <= cil->xc_push_seq) {\r\nspin_unlock(&cil->xc_push_lock);\r\nreturn;\r\n}\r\ncil->xc_push_seq = push_seq;\r\nqueue_work(log->l_mp->m_cil_workqueue, &cil->xc_push_work);\r\nspin_unlock(&cil->xc_push_lock);\r\n}\r\nbool\r\nxlog_cil_empty(\r\nstruct xlog *log)\r\n{\r\nstruct xfs_cil *cil = log->l_cilp;\r\nbool empty = false;\r\nspin_lock(&cil->xc_push_lock);\r\nif (list_empty(&cil->xc_cil))\r\nempty = true;\r\nspin_unlock(&cil->xc_push_lock);\r\nreturn empty;\r\n}\r\nvoid\r\nxfs_log_commit_cil(\r\nstruct xfs_mount *mp,\r\nstruct xfs_trans *tp,\r\nxfs_lsn_t *commit_lsn,\r\nbool regrant)\r\n{\r\nstruct xlog *log = mp->m_log;\r\nstruct xfs_cil *cil = log->l_cilp;\r\ndown_read(&cil->xc_ctx_lock);\r\nxlog_cil_insert_items(log, tp);\r\nif (tp->t_ticket->t_curr_res < 0)\r\nxlog_print_tic_res(mp, tp->t_ticket);\r\ntp->t_commit_lsn = cil->xc_ctx->sequence;\r\nif (commit_lsn)\r\n*commit_lsn = tp->t_commit_lsn;\r\nxfs_log_done(mp, tp->t_ticket, NULL, regrant);\r\nxfs_trans_unreserve_and_mod_sb(tp);\r\nxfs_trans_free_items(tp, tp->t_commit_lsn, false);\r\nxlog_cil_push_background(log);\r\nup_read(&cil->xc_ctx_lock);\r\n}\r\nxfs_lsn_t\r\nxlog_cil_force_lsn(\r\nstruct xlog *log,\r\nxfs_lsn_t sequence)\r\n{\r\nstruct xfs_cil *cil = log->l_cilp;\r\nstruct xfs_cil_ctx *ctx;\r\nxfs_lsn_t commit_lsn = NULLCOMMITLSN;\r\nASSERT(sequence <= cil->xc_current_sequence);\r\nrestart:\r\nxlog_cil_push_now(log, sequence);\r\nspin_lock(&cil->xc_push_lock);\r\nlist_for_each_entry(ctx, &cil->xc_committing, committing) {\r\nif (XLOG_FORCED_SHUTDOWN(log))\r\ngoto out_shutdown;\r\nif (ctx->sequence > sequence)\r\ncontinue;\r\nif (!ctx->commit_lsn) {\r\nxlog_wait(&cil->xc_commit_wait, &cil->xc_push_lock);\r\ngoto restart;\r\n}\r\nif (ctx->sequence != sequence)\r\ncontinue;\r\ncommit_lsn = ctx->commit_lsn;\r\n}\r\nif (sequence == cil->xc_current_sequence &&\r\n!list_empty(&cil->xc_cil)) {\r\nspin_unlock(&cil->xc_push_lock);\r\ngoto restart;\r\n}\r\nspin_unlock(&cil->xc_push_lock);\r\nreturn commit_lsn;\r\nout_shutdown:\r\nspin_unlock(&cil->xc_push_lock);\r\nreturn 0;\r\n}\r\nbool\r\nxfs_log_item_in_current_chkpt(\r\nstruct xfs_log_item *lip)\r\n{\r\nstruct xfs_cil_ctx *ctx;\r\nif (list_empty(&lip->li_cil))\r\nreturn false;\r\nctx = lip->li_mountp->m_log->l_cilp->xc_ctx;\r\nif (XFS_LSN_CMP(lip->li_seq, ctx->sequence) != 0)\r\nreturn false;\r\nreturn true;\r\n}\r\nint\r\nxlog_cil_init(\r\nstruct xlog *log)\r\n{\r\nstruct xfs_cil *cil;\r\nstruct xfs_cil_ctx *ctx;\r\ncil = kmem_zalloc(sizeof(*cil), KM_SLEEP|KM_MAYFAIL);\r\nif (!cil)\r\nreturn -ENOMEM;\r\nctx = kmem_zalloc(sizeof(*ctx), KM_SLEEP|KM_MAYFAIL);\r\nif (!ctx) {\r\nkmem_free(cil);\r\nreturn -ENOMEM;\r\n}\r\nINIT_WORK(&cil->xc_push_work, xlog_cil_push_work);\r\nINIT_LIST_HEAD(&cil->xc_cil);\r\nINIT_LIST_HEAD(&cil->xc_committing);\r\nspin_lock_init(&cil->xc_cil_lock);\r\nspin_lock_init(&cil->xc_push_lock);\r\ninit_rwsem(&cil->xc_ctx_lock);\r\ninit_waitqueue_head(&cil->xc_commit_wait);\r\nINIT_LIST_HEAD(&ctx->committing);\r\nINIT_LIST_HEAD(&ctx->busy_extents);\r\nctx->sequence = 1;\r\nctx->cil = cil;\r\ncil->xc_ctx = ctx;\r\ncil->xc_current_sequence = ctx->sequence;\r\ncil->xc_log = log;\r\nlog->l_cilp = cil;\r\nreturn 0;\r\n}\r\nvoid\r\nxlog_cil_destroy(\r\nstruct xlog *log)\r\n{\r\nif (log->l_cilp->xc_ctx) {\r\nif (log->l_cilp->xc_ctx->ticket)\r\nxfs_log_ticket_put(log->l_cilp->xc_ctx->ticket);\r\nkmem_free(log->l_cilp->xc_ctx);\r\n}\r\nASSERT(list_empty(&log->l_cilp->xc_cil));\r\nkmem_free(log->l_cilp);\r\n}
