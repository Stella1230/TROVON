static int edp_msg_fifo_tx(struct edp_aux *aux, struct drm_dp_aux_msg *msg)\r\n{\r\nu32 data[4];\r\nu32 reg, len;\r\nbool native = msg->request & (DP_AUX_NATIVE_WRITE & DP_AUX_NATIVE_READ);\r\nbool read = msg->request & (DP_AUX_I2C_READ & DP_AUX_NATIVE_READ);\r\nu8 *msgdata = msg->buffer;\r\nint i;\r\nif (read)\r\nlen = 4;\r\nelse\r\nlen = msg->size + 4;\r\nif (len > AUX_CMD_FIFO_LEN)\r\nreturn -EINVAL;\r\ndata[0] = (msg->address >> 16) & 0xf;\r\nif (read)\r\ndata[0] |= BIT(4);\r\ndata[1] = (msg->address >> 8) & 0xff;\r\ndata[2] = msg->address & 0xff;\r\ndata[3] = (msg->size - 1) & 0xff;\r\nfor (i = 0; i < len; i++) {\r\nreg = (i < 4) ? data[i] : msgdata[i - 4];\r\nreg = EDP_AUX_DATA_DATA(reg);\r\nif (i == 0)\r\nreg |= EDP_AUX_DATA_INDEX_WRITE;\r\nedp_write(aux->base + REG_EDP_AUX_DATA, reg);\r\n}\r\nreg = 0;\r\nif (!native)\r\nreg |= EDP_AUX_TRANS_CTRL_I2C;\r\nreg |= EDP_AUX_TRANS_CTRL_GO;\r\nedp_write(aux->base + REG_EDP_AUX_TRANS_CTRL, reg);\r\nreturn 0;\r\n}\r\nstatic int edp_msg_fifo_rx(struct edp_aux *aux, struct drm_dp_aux_msg *msg)\r\n{\r\nu32 data;\r\nu8 *dp;\r\nint i;\r\nu32 len = msg->size;\r\nedp_write(aux->base + REG_EDP_AUX_DATA,\r\nEDP_AUX_DATA_INDEX_WRITE | EDP_AUX_DATA_READ);\r\ndp = msg->buffer;\r\ndata = edp_read(aux->base + REG_EDP_AUX_DATA);\r\nfor (i = 0; i < len; i++) {\r\ndata = edp_read(aux->base + REG_EDP_AUX_DATA);\r\ndp[i] = (u8)((data >> 8) & 0xff);\r\n}\r\nreturn 0;\r\n}\r\nstatic ssize_t edp_aux_transfer(struct drm_dp_aux *drm_aux,\r\nstruct drm_dp_aux_msg *msg)\r\n{\r\nstruct edp_aux *aux = to_edp_aux(drm_aux);\r\nssize_t ret;\r\nunsigned long time_left;\r\nbool native = msg->request & (DP_AUX_NATIVE_WRITE & DP_AUX_NATIVE_READ);\r\nbool read = msg->request & (DP_AUX_I2C_READ & DP_AUX_NATIVE_READ);\r\nif ((msg->size == 0) || (msg->buffer == NULL)) {\r\nmsg->reply = native ?\r\nDP_AUX_NATIVE_REPLY_ACK : DP_AUX_I2C_REPLY_ACK;\r\nreturn msg->size;\r\n}\r\nif ((native && (msg->size > AUX_CMD_NATIVE_MAX)) ||\r\n(msg->size > AUX_CMD_I2C_MAX)) {\r\npr_err("%s: invalid msg: size(%zu), request(%x)\n",\r\n__func__, msg->size, msg->request);\r\nreturn -EINVAL;\r\n}\r\nmutex_lock(&aux->msg_mutex);\r\naux->msg_err = false;\r\nreinit_completion(&aux->msg_comp);\r\nret = edp_msg_fifo_tx(aux, msg);\r\nif (ret < 0)\r\ngoto unlock_exit;\r\nDBG("wait_for_completion");\r\ntime_left = wait_for_completion_timeout(&aux->msg_comp,\r\nmsecs_to_jiffies(300));\r\nif (!time_left) {\r\nedp_write(aux->base + REG_EDP_AUX_TRANS_CTRL, 0);\r\nmsm_edp_aux_ctrl(aux, 1);\r\npr_err("%s: aux timeout,\n", __func__);\r\nret = -ETIMEDOUT;\r\ngoto unlock_exit;\r\n}\r\nDBG("completion");\r\nif (!aux->msg_err) {\r\nif (read) {\r\nret = edp_msg_fifo_rx(aux, msg);\r\nif (ret < 0)\r\ngoto unlock_exit;\r\n}\r\nmsg->reply = native ?\r\nDP_AUX_NATIVE_REPLY_ACK : DP_AUX_I2C_REPLY_ACK;\r\n} else {\r\nmsg->reply = native ?\r\nDP_AUX_NATIVE_REPLY_DEFER : DP_AUX_I2C_REPLY_DEFER;\r\nmsleep(100);\r\n}\r\nret = msg->size;\r\nunlock_exit:\r\nmutex_unlock(&aux->msg_mutex);\r\nreturn ret;\r\n}\r\nvoid *msm_edp_aux_init(struct device *dev, void __iomem *regbase,\r\nstruct drm_dp_aux **drm_aux)\r\n{\r\nstruct edp_aux *aux = NULL;\r\nint ret;\r\nDBG("");\r\naux = devm_kzalloc(dev, sizeof(*aux), GFP_KERNEL);\r\nif (!aux)\r\nreturn NULL;\r\naux->base = regbase;\r\nmutex_init(&aux->msg_mutex);\r\ninit_completion(&aux->msg_comp);\r\naux->drm_aux.name = "msm_edp_aux";\r\naux->drm_aux.dev = dev;\r\naux->drm_aux.transfer = edp_aux_transfer;\r\nret = drm_dp_aux_register(&aux->drm_aux);\r\nif (ret) {\r\npr_err("%s: failed to register drm aux: %d\n", __func__, ret);\r\nmutex_destroy(&aux->msg_mutex);\r\n}\r\nif (drm_aux && aux)\r\n*drm_aux = &aux->drm_aux;\r\nreturn aux;\r\n}\r\nvoid msm_edp_aux_destroy(struct device *dev, struct edp_aux *aux)\r\n{\r\nif (aux) {\r\ndrm_dp_aux_unregister(&aux->drm_aux);\r\nmutex_destroy(&aux->msg_mutex);\r\n}\r\n}\r\nirqreturn_t msm_edp_aux_irq(struct edp_aux *aux, u32 isr)\r\n{\r\nif (isr & EDP_INTR_TRANS_STATUS) {\r\nDBG("isr=%x", isr);\r\nedp_write(aux->base + REG_EDP_AUX_TRANS_CTRL, 0);\r\nif (isr & EDP_INTR_AUX_I2C_ERR)\r\naux->msg_err = true;\r\nelse\r\naux->msg_err = false;\r\ncomplete(&aux->msg_comp);\r\n}\r\nreturn IRQ_HANDLED;\r\n}\r\nvoid msm_edp_aux_ctrl(struct edp_aux *aux, int enable)\r\n{\r\nu32 data;\r\nDBG("enable=%d", enable);\r\ndata = edp_read(aux->base + REG_EDP_AUX_CTRL);\r\nif (enable) {\r\ndata |= EDP_AUX_CTRL_RESET;\r\nedp_write(aux->base + REG_EDP_AUX_CTRL, data);\r\nwmb();\r\nusleep_range(500, 1000);\r\ndata &= ~EDP_AUX_CTRL_RESET;\r\ndata |= EDP_AUX_CTRL_ENABLE;\r\nedp_write(aux->base + REG_EDP_AUX_CTRL, data);\r\n} else {\r\ndata &= ~EDP_AUX_CTRL_ENABLE;\r\nedp_write(aux->base + REG_EDP_AUX_CTRL, data);\r\n}\r\n}
