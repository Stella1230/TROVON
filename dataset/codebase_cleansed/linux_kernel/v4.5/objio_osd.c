static void\r\nobjio_free_deviceid_node(struct nfs4_deviceid_node *d)\r\n{\r\nstruct objio_dev_ent *de = container_of(d, struct objio_dev_ent, id_node);\r\ndprintk("%s: free od=%p\n", __func__, de->od.od);\r\nosduld_put_device(de->od.od);\r\nkfree_rcu(d, rcu);\r\n}\r\nstatic inline struct objio_segment *\r\nOBJIO_LSEG(struct pnfs_layout_segment *lseg)\r\n{\r\nreturn container_of(lseg, struct objio_segment, lseg);\r\n}\r\nstruct nfs4_deviceid_node *\r\nobjio_alloc_deviceid_node(struct nfs_server *server, struct pnfs_device *pdev,\r\ngfp_t gfp_flags)\r\n{\r\nstruct pnfs_osd_deviceaddr *deviceaddr;\r\nstruct objio_dev_ent *ode = NULL;\r\nstruct osd_dev *od;\r\nstruct osd_dev_info odi;\r\nbool retry_flag = true;\r\n__be32 *p;\r\nint err;\r\ndeviceaddr = kzalloc(sizeof(*deviceaddr), gfp_flags);\r\nif (!deviceaddr)\r\nreturn NULL;\r\np = page_address(pdev->pages[0]);\r\npnfs_osd_xdr_decode_deviceaddr(deviceaddr, p);\r\nodi.systemid_len = deviceaddr->oda_systemid.len;\r\nif (odi.systemid_len > sizeof(odi.systemid)) {\r\ndprintk("%s: odi.systemid_len > sizeof(systemid=%zd)\n",\r\n__func__, sizeof(odi.systemid));\r\nerr = -EINVAL;\r\ngoto out;\r\n} else if (odi.systemid_len)\r\nmemcpy(odi.systemid, deviceaddr->oda_systemid.data,\r\nodi.systemid_len);\r\nodi.osdname_len = deviceaddr->oda_osdname.len;\r\nodi.osdname = (u8 *)deviceaddr->oda_osdname.data;\r\nif (!odi.osdname_len && !odi.systemid_len) {\r\ndprintk("%s: !odi.osdname_len && !odi.systemid_len\n",\r\n__func__);\r\nerr = -ENODEV;\r\ngoto out;\r\n}\r\nretry_lookup:\r\nod = osduld_info_lookup(&odi);\r\nif (IS_ERR(od)) {\r\nerr = PTR_ERR(od);\r\ndprintk("%s: osduld_info_lookup => %d\n", __func__, err);\r\nif (err == -ENODEV && retry_flag) {\r\nerr = objlayout_autologin(deviceaddr);\r\nif (likely(!err)) {\r\nretry_flag = false;\r\ngoto retry_lookup;\r\n}\r\n}\r\ngoto out;\r\n}\r\ndprintk("Adding new dev_id(%llx:%llx)\n",\r\n_DEVID_LO(&pdev->dev_id), _DEVID_HI(&pdev->dev_id));\r\node = kzalloc(sizeof(*ode), gfp_flags);\r\nif (!ode) {\r\ndprintk("%s: -ENOMEM od=%p\n", __func__, od);\r\ngoto out;\r\n}\r\nnfs4_init_deviceid_node(&ode->id_node, server, &pdev->dev_id);\r\nkfree(deviceaddr);\r\node->od.od = od;\r\nreturn &ode->id_node;\r\nout:\r\nkfree(deviceaddr);\r\nreturn NULL;\r\n}\r\nstatic void copy_single_comp(struct ore_components *oc, unsigned c,\r\nstruct pnfs_osd_object_cred *src_comp)\r\n{\r\nstruct ore_comp *ocomp = &oc->comps[c];\r\nWARN_ON(src_comp->oc_cap_key.cred_len > 0);\r\nWARN_ON(src_comp->oc_cap.cred_len > sizeof(ocomp->cred));\r\nocomp->obj.partition = src_comp->oc_object_id.oid_partition_id;\r\nocomp->obj.id = src_comp->oc_object_id.oid_object_id;\r\nmemcpy(ocomp->cred, src_comp->oc_cap.cred, sizeof(ocomp->cred));\r\n}\r\nstatic int __alloc_objio_seg(unsigned numdevs, gfp_t gfp_flags,\r\nstruct objio_segment **pseg)\r\n{\r\nstruct objio_segment *lseg;\r\nsize_t lseg_size = sizeof(*lseg) +\r\nnumdevs * sizeof(lseg->oc.ods[0]) +\r\nnumdevs * sizeof(*lseg->oc.comps);\r\nlseg = kzalloc(lseg_size, gfp_flags);\r\nif (unlikely(!lseg)) {\r\ndprintk("%s: Failed allocation numdevs=%d size=%zd\n", __func__,\r\nnumdevs, lseg_size);\r\nreturn -ENOMEM;\r\n}\r\nlseg->oc.numdevs = numdevs;\r\nlseg->oc.single_comp = EC_MULTPLE_COMPS;\r\nlseg->oc.ods = (void *)(lseg + 1);\r\nlseg->oc.comps = (void *)(lseg->oc.ods + numdevs);\r\n*pseg = lseg;\r\nreturn 0;\r\n}\r\nint objio_alloc_lseg(struct pnfs_layout_segment **outp,\r\nstruct pnfs_layout_hdr *pnfslay,\r\nstruct pnfs_layout_range *range,\r\nstruct xdr_stream *xdr,\r\ngfp_t gfp_flags)\r\n{\r\nstruct nfs_server *server = NFS_SERVER(pnfslay->plh_inode);\r\nstruct objio_segment *objio_seg;\r\nstruct pnfs_osd_xdr_decode_layout_iter iter;\r\nstruct pnfs_osd_layout layout;\r\nstruct pnfs_osd_object_cred src_comp;\r\nunsigned cur_comp;\r\nint err;\r\nerr = pnfs_osd_xdr_decode_layout_map(&layout, &iter, xdr);\r\nif (unlikely(err))\r\nreturn err;\r\nerr = __alloc_objio_seg(layout.olo_num_comps, gfp_flags, &objio_seg);\r\nif (unlikely(err))\r\nreturn err;\r\nobjio_seg->layout.stripe_unit = layout.olo_map.odm_stripe_unit;\r\nobjio_seg->layout.group_width = layout.olo_map.odm_group_width;\r\nobjio_seg->layout.group_depth = layout.olo_map.odm_group_depth;\r\nobjio_seg->layout.mirrors_p1 = layout.olo_map.odm_mirror_cnt + 1;\r\nobjio_seg->layout.raid_algorithm = layout.olo_map.odm_raid_algorithm;\r\nerr = ore_verify_layout(layout.olo_map.odm_num_comps,\r\n&objio_seg->layout);\r\nif (unlikely(err))\r\ngoto err;\r\nobjio_seg->oc.first_dev = layout.olo_comps_index;\r\ncur_comp = 0;\r\nwhile (pnfs_osd_xdr_decode_layout_comp(&src_comp, &iter, xdr, &err)) {\r\nstruct nfs4_deviceid_node *d;\r\nstruct objio_dev_ent *ode;\r\ncopy_single_comp(&objio_seg->oc, cur_comp, &src_comp);\r\nd = nfs4_find_get_deviceid(server,\r\n&src_comp.oc_object_id.oid_device_id,\r\npnfslay->plh_lc_cred, gfp_flags);\r\nif (!d) {\r\nerr = -ENXIO;\r\ngoto err;\r\n}\r\node = container_of(d, struct objio_dev_ent, id_node);\r\nobjio_seg->oc.ods[cur_comp++] = &ode->od;\r\n}\r\nif (unlikely(err))\r\ngoto err;\r\n*outp = &objio_seg->lseg;\r\nreturn 0;\r\nerr:\r\nkfree(objio_seg);\r\ndprintk("%s: Error: return %d\n", __func__, err);\r\n*outp = NULL;\r\nreturn err;\r\n}\r\nvoid objio_free_lseg(struct pnfs_layout_segment *lseg)\r\n{\r\nint i;\r\nstruct objio_segment *objio_seg = OBJIO_LSEG(lseg);\r\nfor (i = 0; i < objio_seg->oc.numdevs; i++) {\r\nstruct ore_dev *od = objio_seg->oc.ods[i];\r\nstruct objio_dev_ent *ode;\r\nif (!od)\r\nbreak;\r\node = container_of(od, typeof(*ode), od);\r\nnfs4_put_deviceid_node(&ode->id_node);\r\n}\r\nkfree(objio_seg);\r\n}\r\nstatic int\r\nobjio_alloc_io_state(struct pnfs_layout_hdr *pnfs_layout_type, bool is_reading,\r\nstruct pnfs_layout_segment *lseg, struct page **pages, unsigned pgbase,\r\nloff_t offset, size_t count, void *rpcdata, gfp_t gfp_flags,\r\nstruct objio_state **outp)\r\n{\r\nstruct objio_segment *objio_seg = OBJIO_LSEG(lseg);\r\nstruct ore_io_state *ios;\r\nint ret;\r\nstruct __alloc_objio_state {\r\nstruct objio_state objios;\r\nstruct pnfs_osd_ioerr ioerrs[objio_seg->oc.numdevs];\r\n} *aos;\r\naos = kzalloc(sizeof(*aos), gfp_flags);\r\nif (unlikely(!aos))\r\nreturn -ENOMEM;\r\nobjlayout_init_ioerrs(&aos->objios.oir, objio_seg->oc.numdevs,\r\naos->ioerrs, rpcdata, pnfs_layout_type);\r\nret = ore_get_rw_state(&objio_seg->layout, &objio_seg->oc, is_reading,\r\noffset, count, &ios);\r\nif (unlikely(ret)) {\r\nkfree(aos);\r\nreturn ret;\r\n}\r\nios->pages = pages;\r\nios->pgbase = pgbase;\r\nios->private = aos;\r\nBUG_ON(ios->nr_pages > (pgbase + count + PAGE_SIZE - 1) >> PAGE_SHIFT);\r\naos->objios.sync = 0;\r\naos->objios.ios = ios;\r\n*outp = &aos->objios;\r\nreturn 0;\r\n}\r\nvoid objio_free_result(struct objlayout_io_res *oir)\r\n{\r\nstruct objio_state *objios = container_of(oir, struct objio_state, oir);\r\nore_put_io_state(objios->ios);\r\nkfree(objios);\r\n}\r\nstatic enum pnfs_osd_errno osd_pri_2_pnfs_err(enum osd_err_priority oep)\r\n{\r\nswitch (oep) {\r\ncase OSD_ERR_PRI_NO_ERROR:\r\nreturn (enum pnfs_osd_errno)0;\r\ncase OSD_ERR_PRI_CLEAR_PAGES:\r\nBUG_ON(1);\r\nreturn 0;\r\ncase OSD_ERR_PRI_RESOURCE:\r\nreturn PNFS_OSD_ERR_RESOURCE;\r\ncase OSD_ERR_PRI_BAD_CRED:\r\nreturn PNFS_OSD_ERR_BAD_CRED;\r\ncase OSD_ERR_PRI_NO_ACCESS:\r\nreturn PNFS_OSD_ERR_NO_ACCESS;\r\ncase OSD_ERR_PRI_UNREACHABLE:\r\nreturn PNFS_OSD_ERR_UNREACHABLE;\r\ncase OSD_ERR_PRI_NOT_FOUND:\r\nreturn PNFS_OSD_ERR_NOT_FOUND;\r\ncase OSD_ERR_PRI_NO_SPACE:\r\nreturn PNFS_OSD_ERR_NO_SPACE;\r\ndefault:\r\nWARN_ON(1);\r\ncase OSD_ERR_PRI_EIO:\r\nreturn PNFS_OSD_ERR_EIO;\r\n}\r\n}\r\nstatic void __on_dev_error(struct ore_io_state *ios,\r\nstruct ore_dev *od, unsigned dev_index, enum osd_err_priority oep,\r\nu64 dev_offset, u64 dev_len)\r\n{\r\nstruct objio_state *objios = ios->private;\r\nstruct pnfs_osd_objid pooid;\r\nstruct objio_dev_ent *ode = container_of(od, typeof(*ode), od);\r\nunsigned comp = dev_index;\r\npooid.oid_device_id = ode->id_node.deviceid;\r\npooid.oid_partition_id = ios->oc->comps[comp].obj.partition;\r\npooid.oid_object_id = ios->oc->comps[comp].obj.id;\r\nobjlayout_io_set_result(&objios->oir, comp,\r\n&pooid, osd_pri_2_pnfs_err(oep),\r\ndev_offset, dev_len, !ios->reading);\r\n}\r\nstatic void _read_done(struct ore_io_state *ios, void *private)\r\n{\r\nstruct objio_state *objios = private;\r\nssize_t status;\r\nint ret = ore_check_io(ios, &__on_dev_error);\r\nif (likely(!ret))\r\nstatus = ios->length;\r\nelse\r\nstatus = ret;\r\nobjlayout_read_done(&objios->oir, status, objios->sync);\r\n}\r\nint objio_read_pagelist(struct nfs_pgio_header *hdr)\r\n{\r\nstruct objio_state *objios;\r\nint ret;\r\nret = objio_alloc_io_state(NFS_I(hdr->inode)->layout, true,\r\nhdr->lseg, hdr->args.pages, hdr->args.pgbase,\r\nhdr->args.offset, hdr->args.count, hdr,\r\nGFP_KERNEL, &objios);\r\nif (unlikely(ret))\r\nreturn ret;\r\nobjios->ios->done = _read_done;\r\ndprintk("%s: offset=0x%llx length=0x%x\n", __func__,\r\nhdr->args.offset, hdr->args.count);\r\nret = ore_read(objios->ios);\r\nif (unlikely(ret))\r\nobjio_free_result(&objios->oir);\r\nreturn ret;\r\n}\r\nstatic void _write_done(struct ore_io_state *ios, void *private)\r\n{\r\nstruct objio_state *objios = private;\r\nssize_t status;\r\nint ret = ore_check_io(ios, &__on_dev_error);\r\nif (likely(!ret)) {\r\nobjios->oir.committed = NFS_FILE_SYNC;\r\nstatus = ios->length;\r\n} else {\r\nstatus = ret;\r\n}\r\nobjlayout_write_done(&objios->oir, status, objios->sync);\r\n}\r\nstatic struct page *__r4w_get_page(void *priv, u64 offset, bool *uptodate)\r\n{\r\nstruct objio_state *objios = priv;\r\nstruct nfs_pgio_header *hdr = objios->oir.rpcdata;\r\nstruct address_space *mapping = hdr->inode->i_mapping;\r\npgoff_t index = offset / PAGE_SIZE;\r\nstruct page *page;\r\nloff_t i_size = i_size_read(hdr->inode);\r\nif (offset >= i_size) {\r\n*uptodate = true;\r\ndprintk("%s: g_zero_page index=0x%lx\n", __func__, index);\r\nreturn ZERO_PAGE(0);\r\n}\r\npage = find_get_page(mapping, index);\r\nif (!page) {\r\npage = find_or_create_page(mapping, index, GFP_NOFS);\r\nif (unlikely(!page)) {\r\ndprintk("%s: grab_cache_page Failed index=0x%lx\n",\r\n__func__, index);\r\nreturn NULL;\r\n}\r\nunlock_page(page);\r\n}\r\n*uptodate = PageUptodate(page);\r\ndprintk("%s: index=0x%lx uptodate=%d\n", __func__, index, *uptodate);\r\nreturn page;\r\n}\r\nstatic void __r4w_put_page(void *priv, struct page *page)\r\n{\r\ndprintk("%s: index=0x%lx\n", __func__,\r\n(page == ZERO_PAGE(0)) ? -1UL : page->index);\r\nif (ZERO_PAGE(0) != page)\r\npage_cache_release(page);\r\nreturn;\r\n}\r\nint objio_write_pagelist(struct nfs_pgio_header *hdr, int how)\r\n{\r\nstruct objio_state *objios;\r\nint ret;\r\nret = objio_alloc_io_state(NFS_I(hdr->inode)->layout, false,\r\nhdr->lseg, hdr->args.pages, hdr->args.pgbase,\r\nhdr->args.offset, hdr->args.count, hdr, GFP_NOFS,\r\n&objios);\r\nif (unlikely(ret))\r\nreturn ret;\r\nobjios->sync = 0 != (how & FLUSH_SYNC);\r\nobjios->ios->r4w = &_r4w_op;\r\nif (!objios->sync)\r\nobjios->ios->done = _write_done;\r\ndprintk("%s: offset=0x%llx length=0x%x\n", __func__,\r\nhdr->args.offset, hdr->args.count);\r\nret = ore_write(objios->ios);\r\nif (unlikely(ret)) {\r\nobjio_free_result(&objios->oir);\r\nreturn ret;\r\n}\r\nif (objios->sync)\r\n_write_done(objios->ios, objios);\r\nreturn 0;\r\n}\r\nstatic size_t objio_pg_test(struct nfs_pageio_descriptor *pgio,\r\nstruct nfs_page *prev, struct nfs_page *req)\r\n{\r\nstruct nfs_pgio_mirror *mirror = nfs_pgio_current_mirror(pgio);\r\nunsigned int size;\r\nsize = pnfs_generic_pg_test(pgio, prev, req);\r\nif (!size || mirror->pg_count + req->wb_bytes >\r\n(unsigned long)pgio->pg_layout_private)\r\nreturn 0;\r\nreturn min(size, req->wb_bytes);\r\n}\r\nstatic void objio_init_read(struct nfs_pageio_descriptor *pgio, struct nfs_page *req)\r\n{\r\npnfs_generic_pg_init_read(pgio, req);\r\nif (unlikely(pgio->pg_lseg == NULL))\r\nreturn;\r\npgio->pg_layout_private = (void *)\r\nOBJIO_LSEG(pgio->pg_lseg)->layout.max_io_length;\r\n}\r\nstatic bool aligned_on_raid_stripe(u64 offset, struct ore_layout *layout,\r\nunsigned long *stripe_end)\r\n{\r\nu32 stripe_off;\r\nunsigned stripe_size;\r\nif (layout->raid_algorithm == PNFS_OSD_RAID_0)\r\nreturn true;\r\nstripe_size = layout->stripe_unit *\r\n(layout->group_width - layout->parity);\r\ndiv_u64_rem(offset, stripe_size, &stripe_off);\r\nif (!stripe_off)\r\nreturn true;\r\n*stripe_end = stripe_size - stripe_off;\r\nreturn false;\r\n}\r\nstatic void objio_init_write(struct nfs_pageio_descriptor *pgio, struct nfs_page *req)\r\n{\r\nunsigned long stripe_end = 0;\r\nu64 wb_size;\r\nif (pgio->pg_dreq == NULL)\r\nwb_size = i_size_read(pgio->pg_inode) - req_offset(req);\r\nelse\r\nwb_size = nfs_dreq_bytes_left(pgio->pg_dreq);\r\npnfs_generic_pg_init_write(pgio, req, wb_size);\r\nif (unlikely(pgio->pg_lseg == NULL))\r\nreturn;\r\nif (req->wb_offset ||\r\n!aligned_on_raid_stripe(req->wb_index * PAGE_SIZE,\r\n&OBJIO_LSEG(pgio->pg_lseg)->layout,\r\n&stripe_end)) {\r\npgio->pg_layout_private = (void *)stripe_end;\r\n} else {\r\npgio->pg_layout_private = (void *)\r\nOBJIO_LSEG(pgio->pg_lseg)->layout.max_io_length;\r\n}\r\n}\r\nstatic int __init\r\nobjlayout_init(void)\r\n{\r\nint ret = pnfs_register_layoutdriver(&objlayout_type);\r\nif (ret)\r\nprintk(KERN_INFO\r\n"NFS: %s: Registering OSD pNFS Layout Driver failed: error=%d\n",\r\n__func__, ret);\r\nelse\r\nprintk(KERN_INFO "NFS: %s: Registered OSD pNFS Layout Driver\n",\r\n__func__);\r\nreturn ret;\r\n}\r\nstatic void __exit\r\nobjlayout_exit(void)\r\n{\r\npnfs_unregister_layoutdriver(&objlayout_type);\r\nprintk(KERN_INFO "NFS: %s: Unregistered OSD pNFS Layout Driver\n",\r\n__func__);\r\n}
