int radeon_vce_init(struct radeon_device *rdev)\r\n{\r\nstatic const char *fw_version = "[ATI LIB=VCEFW,";\r\nstatic const char *fb_version = "[ATI LIB=VCEFWSTATS,";\r\nunsigned long size;\r\nconst char *fw_name, *c;\r\nuint8_t start, mid, end;\r\nint i, r;\r\nINIT_DELAYED_WORK(&rdev->vce.idle_work, radeon_vce_idle_work_handler);\r\nswitch (rdev->family) {\r\ncase CHIP_TAHITI:\r\ncase CHIP_PITCAIRN:\r\ncase CHIP_VERDE:\r\ncase CHIP_OLAND:\r\ncase CHIP_ARUBA:\r\nfw_name = FIRMWARE_TAHITI;\r\nbreak;\r\ncase CHIP_BONAIRE:\r\ncase CHIP_KAVERI:\r\ncase CHIP_KABINI:\r\ncase CHIP_HAWAII:\r\ncase CHIP_MULLINS:\r\nfw_name = FIRMWARE_BONAIRE;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nr = request_firmware(&rdev->vce_fw, fw_name, rdev->dev);\r\nif (r) {\r\ndev_err(rdev->dev, "radeon_vce: Can't load firmware \"%s\"\n",\r\nfw_name);\r\nreturn r;\r\n}\r\nsize = rdev->vce_fw->size - strlen(fw_version) - 9;\r\nc = rdev->vce_fw->data;\r\nfor (;size > 0; --size, ++c)\r\nif (strncmp(c, fw_version, strlen(fw_version)) == 0)\r\nbreak;\r\nif (size == 0)\r\nreturn -EINVAL;\r\nc += strlen(fw_version);\r\nif (sscanf(c, "%2hhd.%2hhd.%2hhd]", &start, &mid, &end) != 3)\r\nreturn -EINVAL;\r\nsize = rdev->vce_fw->size - strlen(fb_version) - 3;\r\nc = rdev->vce_fw->data;\r\nfor (;size > 0; --size, ++c)\r\nif (strncmp(c, fb_version, strlen(fb_version)) == 0)\r\nbreak;\r\nif (size == 0)\r\nreturn -EINVAL;\r\nc += strlen(fb_version);\r\nif (sscanf(c, "%2u]", &rdev->vce.fb_version) != 1)\r\nreturn -EINVAL;\r\nDRM_INFO("Found VCE firmware/feedback version %hhd.%hhd.%hhd / %d!\n",\r\nstart, mid, end, rdev->vce.fb_version);\r\nrdev->vce.fw_version = (start << 24) | (mid << 16) | (end << 8);\r\nif ((rdev->vce.fw_version != ((40 << 24) | (2 << 16) | (2 << 8))) &&\r\n(rdev->vce.fw_version != ((50 << 24) | (0 << 16) | (1 << 8))) &&\r\n(rdev->vce.fw_version != ((50 << 24) | (1 << 16) | (2 << 8))))\r\nreturn -EINVAL;\r\nif (rdev->family < CHIP_BONAIRE)\r\nsize = vce_v1_0_bo_size(rdev);\r\nelse\r\nsize = vce_v2_0_bo_size(rdev);\r\nr = radeon_bo_create(rdev, size, PAGE_SIZE, true,\r\nRADEON_GEM_DOMAIN_VRAM, 0, NULL, NULL,\r\n&rdev->vce.vcpu_bo);\r\nif (r) {\r\ndev_err(rdev->dev, "(%d) failed to allocate VCE bo\n", r);\r\nreturn r;\r\n}\r\nr = radeon_bo_reserve(rdev->vce.vcpu_bo, false);\r\nif (r) {\r\nradeon_bo_unref(&rdev->vce.vcpu_bo);\r\ndev_err(rdev->dev, "(%d) failed to reserve VCE bo\n", r);\r\nreturn r;\r\n}\r\nr = radeon_bo_pin(rdev->vce.vcpu_bo, RADEON_GEM_DOMAIN_VRAM,\r\n&rdev->vce.gpu_addr);\r\nradeon_bo_unreserve(rdev->vce.vcpu_bo);\r\nif (r) {\r\nradeon_bo_unref(&rdev->vce.vcpu_bo);\r\ndev_err(rdev->dev, "(%d) VCE bo pin failed\n", r);\r\nreturn r;\r\n}\r\nfor (i = 0; i < RADEON_MAX_VCE_HANDLES; ++i) {\r\natomic_set(&rdev->vce.handles[i], 0);\r\nrdev->vce.filp[i] = NULL;\r\n}\r\nreturn 0;\r\n}\r\nvoid radeon_vce_fini(struct radeon_device *rdev)\r\n{\r\nif (rdev->vce.vcpu_bo == NULL)\r\nreturn;\r\nradeon_bo_unref(&rdev->vce.vcpu_bo);\r\nrelease_firmware(rdev->vce_fw);\r\n}\r\nint radeon_vce_suspend(struct radeon_device *rdev)\r\n{\r\nint i;\r\nif (rdev->vce.vcpu_bo == NULL)\r\nreturn 0;\r\nfor (i = 0; i < RADEON_MAX_VCE_HANDLES; ++i)\r\nif (atomic_read(&rdev->vce.handles[i]))\r\nbreak;\r\nif (i == RADEON_MAX_VCE_HANDLES)\r\nreturn 0;\r\nreturn -EINVAL;\r\n}\r\nint radeon_vce_resume(struct radeon_device *rdev)\r\n{\r\nvoid *cpu_addr;\r\nint r;\r\nif (rdev->vce.vcpu_bo == NULL)\r\nreturn -EINVAL;\r\nr = radeon_bo_reserve(rdev->vce.vcpu_bo, false);\r\nif (r) {\r\ndev_err(rdev->dev, "(%d) failed to reserve VCE bo\n", r);\r\nreturn r;\r\n}\r\nr = radeon_bo_kmap(rdev->vce.vcpu_bo, &cpu_addr);\r\nif (r) {\r\nradeon_bo_unreserve(rdev->vce.vcpu_bo);\r\ndev_err(rdev->dev, "(%d) VCE map failed\n", r);\r\nreturn r;\r\n}\r\nmemset(cpu_addr, 0, radeon_bo_size(rdev->vce.vcpu_bo));\r\nif (rdev->family < CHIP_BONAIRE)\r\nr = vce_v1_0_load_fw(rdev, cpu_addr);\r\nelse\r\nmemcpy(cpu_addr, rdev->vce_fw->data, rdev->vce_fw->size);\r\nradeon_bo_kunmap(rdev->vce.vcpu_bo);\r\nradeon_bo_unreserve(rdev->vce.vcpu_bo);\r\nreturn r;\r\n}\r\nstatic void radeon_vce_idle_work_handler(struct work_struct *work)\r\n{\r\nstruct radeon_device *rdev =\r\ncontainer_of(work, struct radeon_device, vce.idle_work.work);\r\nif ((radeon_fence_count_emitted(rdev, TN_RING_TYPE_VCE1_INDEX) == 0) &&\r\n(radeon_fence_count_emitted(rdev, TN_RING_TYPE_VCE2_INDEX) == 0)) {\r\nif ((rdev->pm.pm_method == PM_METHOD_DPM) && rdev->pm.dpm_enabled) {\r\nradeon_dpm_enable_vce(rdev, false);\r\n} else {\r\nradeon_set_vce_clocks(rdev, 0, 0);\r\n}\r\n} else {\r\nschedule_delayed_work(&rdev->vce.idle_work,\r\nmsecs_to_jiffies(VCE_IDLE_TIMEOUT_MS));\r\n}\r\n}\r\nvoid radeon_vce_note_usage(struct radeon_device *rdev)\r\n{\r\nbool streams_changed = false;\r\nbool set_clocks = !cancel_delayed_work_sync(&rdev->vce.idle_work);\r\nset_clocks &= schedule_delayed_work(&rdev->vce.idle_work,\r\nmsecs_to_jiffies(VCE_IDLE_TIMEOUT_MS));\r\nif ((rdev->pm.pm_method == PM_METHOD_DPM) && rdev->pm.dpm_enabled) {\r\nstreams_changed = false;\r\n}\r\nif (set_clocks || streams_changed) {\r\nif ((rdev->pm.pm_method == PM_METHOD_DPM) && rdev->pm.dpm_enabled) {\r\nradeon_dpm_enable_vce(rdev, true);\r\n} else {\r\nradeon_set_vce_clocks(rdev, 53300, 40000);\r\n}\r\n}\r\n}\r\nvoid radeon_vce_free_handles(struct radeon_device *rdev, struct drm_file *filp)\r\n{\r\nint i, r;\r\nfor (i = 0; i < RADEON_MAX_VCE_HANDLES; ++i) {\r\nuint32_t handle = atomic_read(&rdev->vce.handles[i]);\r\nif (!handle || rdev->vce.filp[i] != filp)\r\ncontinue;\r\nradeon_vce_note_usage(rdev);\r\nr = radeon_vce_get_destroy_msg(rdev, TN_RING_TYPE_VCE1_INDEX,\r\nhandle, NULL);\r\nif (r)\r\nDRM_ERROR("Error destroying VCE handle (%d)!\n", r);\r\nrdev->vce.filp[i] = NULL;\r\natomic_set(&rdev->vce.handles[i], 0);\r\n}\r\n}\r\nint radeon_vce_get_create_msg(struct radeon_device *rdev, int ring,\r\nuint32_t handle, struct radeon_fence **fence)\r\n{\r\nconst unsigned ib_size_dw = 1024;\r\nstruct radeon_ib ib;\r\nuint64_t dummy;\r\nint i, r;\r\nr = radeon_ib_get(rdev, ring, &ib, NULL, ib_size_dw * 4);\r\nif (r) {\r\nDRM_ERROR("radeon: failed to get ib (%d).\n", r);\r\nreturn r;\r\n}\r\ndummy = ib.gpu_addr + 1024;\r\nib.length_dw = 0;\r\nib.ptr[ib.length_dw++] = cpu_to_le32(0x0000000c);\r\nib.ptr[ib.length_dw++] = cpu_to_le32(0x00000001);\r\nib.ptr[ib.length_dw++] = cpu_to_le32(handle);\r\nib.ptr[ib.length_dw++] = cpu_to_le32(0x00000030);\r\nib.ptr[ib.length_dw++] = cpu_to_le32(0x01000001);\r\nib.ptr[ib.length_dw++] = cpu_to_le32(0x00000000);\r\nib.ptr[ib.length_dw++] = cpu_to_le32(0x00000042);\r\nib.ptr[ib.length_dw++] = cpu_to_le32(0x0000000a);\r\nib.ptr[ib.length_dw++] = cpu_to_le32(0x00000001);\r\nib.ptr[ib.length_dw++] = cpu_to_le32(0x00000080);\r\nib.ptr[ib.length_dw++] = cpu_to_le32(0x00000060);\r\nib.ptr[ib.length_dw++] = cpu_to_le32(0x00000100);\r\nib.ptr[ib.length_dw++] = cpu_to_le32(0x00000100);\r\nib.ptr[ib.length_dw++] = cpu_to_le32(0x0000000c);\r\nib.ptr[ib.length_dw++] = cpu_to_le32(0x00000000);\r\nib.ptr[ib.length_dw++] = cpu_to_le32(0x00000014);\r\nib.ptr[ib.length_dw++] = cpu_to_le32(0x05000005);\r\nib.ptr[ib.length_dw++] = cpu_to_le32(upper_32_bits(dummy));\r\nib.ptr[ib.length_dw++] = cpu_to_le32(dummy);\r\nib.ptr[ib.length_dw++] = cpu_to_le32(0x00000001);\r\nfor (i = ib.length_dw; i < ib_size_dw; ++i)\r\nib.ptr[i] = cpu_to_le32(0x0);\r\nr = radeon_ib_schedule(rdev, &ib, NULL, false);\r\nif (r) {\r\nDRM_ERROR("radeon: failed to schedule ib (%d).\n", r);\r\n}\r\nif (fence)\r\n*fence = radeon_fence_ref(ib.fence);\r\nradeon_ib_free(rdev, &ib);\r\nreturn r;\r\n}\r\nint radeon_vce_get_destroy_msg(struct radeon_device *rdev, int ring,\r\nuint32_t handle, struct radeon_fence **fence)\r\n{\r\nconst unsigned ib_size_dw = 1024;\r\nstruct radeon_ib ib;\r\nuint64_t dummy;\r\nint i, r;\r\nr = radeon_ib_get(rdev, ring, &ib, NULL, ib_size_dw * 4);\r\nif (r) {\r\nDRM_ERROR("radeon: failed to get ib (%d).\n", r);\r\nreturn r;\r\n}\r\ndummy = ib.gpu_addr + 1024;\r\nib.length_dw = 0;\r\nib.ptr[ib.length_dw++] = cpu_to_le32(0x0000000c);\r\nib.ptr[ib.length_dw++] = cpu_to_le32(0x00000001);\r\nib.ptr[ib.length_dw++] = cpu_to_le32(handle);\r\nib.ptr[ib.length_dw++] = cpu_to_le32(0x00000014);\r\nib.ptr[ib.length_dw++] = cpu_to_le32(0x05000005);\r\nib.ptr[ib.length_dw++] = cpu_to_le32(upper_32_bits(dummy));\r\nib.ptr[ib.length_dw++] = cpu_to_le32(dummy);\r\nib.ptr[ib.length_dw++] = cpu_to_le32(0x00000001);\r\nib.ptr[ib.length_dw++] = cpu_to_le32(0x00000008);\r\nib.ptr[ib.length_dw++] = cpu_to_le32(0x02000001);\r\nfor (i = ib.length_dw; i < ib_size_dw; ++i)\r\nib.ptr[i] = cpu_to_le32(0x0);\r\nr = radeon_ib_schedule(rdev, &ib, NULL, false);\r\nif (r) {\r\nDRM_ERROR("radeon: failed to schedule ib (%d).\n", r);\r\n}\r\nif (fence)\r\n*fence = radeon_fence_ref(ib.fence);\r\nradeon_ib_free(rdev, &ib);\r\nreturn r;\r\n}\r\nint radeon_vce_cs_reloc(struct radeon_cs_parser *p, int lo, int hi,\r\nunsigned size)\r\n{\r\nstruct radeon_cs_chunk *relocs_chunk;\r\nstruct radeon_bo_list *reloc;\r\nuint64_t start, end, offset;\r\nunsigned idx;\r\nrelocs_chunk = p->chunk_relocs;\r\noffset = radeon_get_ib_value(p, lo);\r\nidx = radeon_get_ib_value(p, hi);\r\nif (idx >= relocs_chunk->length_dw) {\r\nDRM_ERROR("Relocs at %d after relocations chunk end %d !\n",\r\nidx, relocs_chunk->length_dw);\r\nreturn -EINVAL;\r\n}\r\nreloc = &p->relocs[(idx / 4)];\r\nstart = reloc->gpu_offset;\r\nend = start + radeon_bo_size(reloc->robj);\r\nstart += offset;\r\np->ib.ptr[lo] = start & 0xFFFFFFFF;\r\np->ib.ptr[hi] = start >> 32;\r\nif (end <= start) {\r\nDRM_ERROR("invalid reloc offset %llX!\n", offset);\r\nreturn -EINVAL;\r\n}\r\nif ((end - start) < size) {\r\nDRM_ERROR("buffer to small (%d / %d)!\n",\r\n(unsigned)(end - start), size);\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int radeon_vce_validate_handle(struct radeon_cs_parser *p,\r\nuint32_t handle, bool *allocated)\r\n{\r\nunsigned i;\r\n*allocated = false;\r\nfor (i = 0; i < RADEON_MAX_VCE_HANDLES; ++i) {\r\nif (atomic_read(&p->rdev->vce.handles[i]) == handle) {\r\nif (p->rdev->vce.filp[i] != p->filp) {\r\nDRM_ERROR("VCE handle collision detected!\n");\r\nreturn -EINVAL;\r\n}\r\nreturn i;\r\n}\r\n}\r\nfor (i = 0; i < RADEON_MAX_VCE_HANDLES; ++i) {\r\nif (!atomic_cmpxchg(&p->rdev->vce.handles[i], 0, handle)) {\r\np->rdev->vce.filp[i] = p->filp;\r\np->rdev->vce.img_size[i] = 0;\r\n*allocated = true;\r\nreturn i;\r\n}\r\n}\r\nDRM_ERROR("No more free VCE handles!\n");\r\nreturn -EINVAL;\r\n}\r\nint radeon_vce_cs_parse(struct radeon_cs_parser *p)\r\n{\r\nint session_idx = -1;\r\nbool destroyed = false, created = false, allocated = false;\r\nuint32_t tmp, handle = 0;\r\nuint32_t *size = &tmp;\r\nint i, r = 0;\r\nwhile (p->idx < p->chunk_ib->length_dw) {\r\nuint32_t len = radeon_get_ib_value(p, p->idx);\r\nuint32_t cmd = radeon_get_ib_value(p, p->idx + 1);\r\nif ((len < 8) || (len & 3)) {\r\nDRM_ERROR("invalid VCE command length (%d)!\n", len);\r\nr = -EINVAL;\r\ngoto out;\r\n}\r\nif (destroyed) {\r\nDRM_ERROR("No other command allowed after destroy!\n");\r\nr = -EINVAL;\r\ngoto out;\r\n}\r\nswitch (cmd) {\r\ncase 0x00000001:\r\nhandle = radeon_get_ib_value(p, p->idx + 2);\r\nsession_idx = radeon_vce_validate_handle(p, handle,\r\n&allocated);\r\nif (session_idx < 0)\r\nreturn session_idx;\r\nsize = &p->rdev->vce.img_size[session_idx];\r\nbreak;\r\ncase 0x00000002:\r\nbreak;\r\ncase 0x01000001:\r\ncreated = true;\r\nif (!allocated) {\r\nDRM_ERROR("Handle already in use!\n");\r\nr = -EINVAL;\r\ngoto out;\r\n}\r\n*size = radeon_get_ib_value(p, p->idx + 8) *\r\nradeon_get_ib_value(p, p->idx + 10) *\r\n8 * 3 / 2;\r\nbreak;\r\ncase 0x04000001:\r\ncase 0x04000002:\r\ncase 0x04000005:\r\ncase 0x04000007:\r\ncase 0x04000008:\r\ncase 0x04000009:\r\nbreak;\r\ncase 0x03000001:\r\nr = radeon_vce_cs_reloc(p, p->idx + 10, p->idx + 9,\r\n*size);\r\nif (r)\r\ngoto out;\r\nr = radeon_vce_cs_reloc(p, p->idx + 12, p->idx + 11,\r\n*size / 3);\r\nif (r)\r\ngoto out;\r\nbreak;\r\ncase 0x02000001:\r\ndestroyed = true;\r\nbreak;\r\ncase 0x05000001:\r\nr = radeon_vce_cs_reloc(p, p->idx + 3, p->idx + 2,\r\n*size * 2);\r\nif (r)\r\ngoto out;\r\nbreak;\r\ncase 0x05000004:\r\ntmp = radeon_get_ib_value(p, p->idx + 4);\r\nr = radeon_vce_cs_reloc(p, p->idx + 3, p->idx + 2,\r\ntmp);\r\nif (r)\r\ngoto out;\r\nbreak;\r\ncase 0x05000005:\r\nr = radeon_vce_cs_reloc(p, p->idx + 3, p->idx + 2,\r\n4096);\r\nif (r)\r\ngoto out;\r\nbreak;\r\ndefault:\r\nDRM_ERROR("invalid VCE command (0x%x)!\n", cmd);\r\nr = -EINVAL;\r\ngoto out;\r\n}\r\nif (session_idx == -1) {\r\nDRM_ERROR("no session command at start of IB\n");\r\nr = -EINVAL;\r\ngoto out;\r\n}\r\np->idx += len / 4;\r\n}\r\nif (allocated && !created) {\r\nDRM_ERROR("New session without create command!\n");\r\nr = -ENOENT;\r\n}\r\nout:\r\nif ((!r && destroyed) || (r && allocated)) {\r\nfor (i = 0; i < RADEON_MAX_VCE_HANDLES; ++i)\r\natomic_cmpxchg(&p->rdev->vce.handles[i], handle, 0);\r\n}\r\nreturn r;\r\n}\r\nbool radeon_vce_semaphore_emit(struct radeon_device *rdev,\r\nstruct radeon_ring *ring,\r\nstruct radeon_semaphore *semaphore,\r\nbool emit_wait)\r\n{\r\nuint64_t addr = semaphore->gpu_addr;\r\nradeon_ring_write(ring, cpu_to_le32(VCE_CMD_SEMAPHORE));\r\nradeon_ring_write(ring, cpu_to_le32((addr >> 3) & 0x000FFFFF));\r\nradeon_ring_write(ring, cpu_to_le32((addr >> 23) & 0x000FFFFF));\r\nradeon_ring_write(ring, cpu_to_le32(0x01003000 | (emit_wait ? 1 : 0)));\r\nif (!emit_wait)\r\nradeon_ring_write(ring, cpu_to_le32(VCE_CMD_END));\r\nreturn true;\r\n}\r\nvoid radeon_vce_ib_execute(struct radeon_device *rdev, struct radeon_ib *ib)\r\n{\r\nstruct radeon_ring *ring = &rdev->ring[ib->ring];\r\nradeon_ring_write(ring, cpu_to_le32(VCE_CMD_IB));\r\nradeon_ring_write(ring, cpu_to_le32(ib->gpu_addr));\r\nradeon_ring_write(ring, cpu_to_le32(upper_32_bits(ib->gpu_addr)));\r\nradeon_ring_write(ring, cpu_to_le32(ib->length_dw));\r\n}\r\nvoid radeon_vce_fence_emit(struct radeon_device *rdev,\r\nstruct radeon_fence *fence)\r\n{\r\nstruct radeon_ring *ring = &rdev->ring[fence->ring];\r\nuint64_t addr = rdev->fence_drv[fence->ring].gpu_addr;\r\nradeon_ring_write(ring, cpu_to_le32(VCE_CMD_FENCE));\r\nradeon_ring_write(ring, cpu_to_le32(addr));\r\nradeon_ring_write(ring, cpu_to_le32(upper_32_bits(addr)));\r\nradeon_ring_write(ring, cpu_to_le32(fence->seq));\r\nradeon_ring_write(ring, cpu_to_le32(VCE_CMD_TRAP));\r\nradeon_ring_write(ring, cpu_to_le32(VCE_CMD_END));\r\n}\r\nint radeon_vce_ring_test(struct radeon_device *rdev, struct radeon_ring *ring)\r\n{\r\nuint32_t rptr = vce_v1_0_get_rptr(rdev, ring);\r\nunsigned i;\r\nint r;\r\nr = radeon_ring_lock(rdev, ring, 16);\r\nif (r) {\r\nDRM_ERROR("radeon: vce failed to lock ring %d (%d).\n",\r\nring->idx, r);\r\nreturn r;\r\n}\r\nradeon_ring_write(ring, cpu_to_le32(VCE_CMD_END));\r\nradeon_ring_unlock_commit(rdev, ring, false);\r\nfor (i = 0; i < rdev->usec_timeout; i++) {\r\nif (vce_v1_0_get_rptr(rdev, ring) != rptr)\r\nbreak;\r\nDRM_UDELAY(1);\r\n}\r\nif (i < rdev->usec_timeout) {\r\nDRM_INFO("ring test on %d succeeded in %d usecs\n",\r\nring->idx, i);\r\n} else {\r\nDRM_ERROR("radeon: ring %d test failed\n",\r\nring->idx);\r\nr = -ETIMEDOUT;\r\n}\r\nreturn r;\r\n}\r\nint radeon_vce_ib_test(struct radeon_device *rdev, struct radeon_ring *ring)\r\n{\r\nstruct radeon_fence *fence = NULL;\r\nint r;\r\nr = radeon_vce_get_create_msg(rdev, ring->idx, 1, NULL);\r\nif (r) {\r\nDRM_ERROR("radeon: failed to get create msg (%d).\n", r);\r\ngoto error;\r\n}\r\nr = radeon_vce_get_destroy_msg(rdev, ring->idx, 1, &fence);\r\nif (r) {\r\nDRM_ERROR("radeon: failed to get destroy ib (%d).\n", r);\r\ngoto error;\r\n}\r\nr = radeon_fence_wait(fence, false);\r\nif (r) {\r\nDRM_ERROR("radeon: fence wait failed (%d).\n", r);\r\n} else {\r\nDRM_INFO("ib test on ring %d succeeded\n", ring->idx);\r\n}\r\nerror:\r\nradeon_fence_unref(&fence);\r\nreturn r;\r\n}
