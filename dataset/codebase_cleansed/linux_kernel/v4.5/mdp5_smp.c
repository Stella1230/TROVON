static inline\r\nstruct mdp5_kms *get_kms(struct mdp5_smp *smp)\r\n{\r\nstruct msm_drm_private *priv = smp->dev->dev_private;\r\nreturn to_mdp5_kms(to_mdp_kms(priv->kms));\r\n}\r\nstatic inline u32 pipe2client(enum mdp5_pipe pipe, int plane)\r\n{\r\n#define CID_UNUSED 0\r\nif (WARN_ON(plane >= pipe2nclients(pipe)))\r\nreturn CID_UNUSED;\r\nreturn mdp5_cfg->smp.clients[pipe] + plane;\r\n}\r\nstatic int smp_request_block(struct mdp5_smp *smp,\r\nu32 cid, int nblks)\r\n{\r\nstruct mdp5_kms *mdp5_kms = get_kms(smp);\r\nstruct mdp5_client_smp_state *ps = &smp->client_state[cid];\r\nint i, ret, avail, cur_nblks, cnt = smp->blk_cnt;\r\nuint8_t reserved;\r\nunsigned long flags;\r\nreserved = smp->reserved[cid];\r\nspin_lock_irqsave(&smp->state_lock, flags);\r\nif (reserved) {\r\nnblks = max(0, nblks - reserved);\r\nDBG("%d MMBs allocated (%d reserved)", nblks, reserved);\r\n}\r\navail = cnt - bitmap_weight(smp->state, cnt);\r\nif (nblks > avail) {\r\ndev_err(mdp5_kms->dev->dev, "out of blks (req=%d > avail=%d)\n",\r\nnblks, avail);\r\nret = -ENOSPC;\r\ngoto fail;\r\n}\r\ncur_nblks = bitmap_weight(ps->pending, cnt);\r\nif (nblks > cur_nblks) {\r\nfor (i = cur_nblks; i < nblks; i++) {\r\nint blk = find_first_zero_bit(smp->state, cnt);\r\nset_bit(blk, ps->pending);\r\nset_bit(blk, smp->state);\r\n}\r\n} else {\r\nfor (i = cur_nblks; i > nblks; i--) {\r\nint blk = find_first_bit(ps->pending, cnt);\r\nclear_bit(blk, ps->pending);\r\nif (!test_bit(blk, ps->configured))\r\nclear_bit(blk, smp->state);\r\n}\r\n}\r\nfail:\r\nspin_unlock_irqrestore(&smp->state_lock, flags);\r\nreturn 0;\r\n}\r\nstatic void set_fifo_thresholds(struct mdp5_smp *smp,\r\nenum mdp5_pipe pipe, int nblks)\r\n{\r\nstruct mdp5_kms *mdp5_kms = get_kms(smp);\r\nu32 smp_entries_per_blk = smp->blk_size / (128 / BITS_PER_BYTE);\r\nu32 val;\r\nval = (nblks * smp_entries_per_blk) / 4;\r\nmdp5_write(mdp5_kms, REG_MDP5_PIPE_REQPRIO_FIFO_WM_0(pipe), val * 1);\r\nmdp5_write(mdp5_kms, REG_MDP5_PIPE_REQPRIO_FIFO_WM_1(pipe), val * 2);\r\nmdp5_write(mdp5_kms, REG_MDP5_PIPE_REQPRIO_FIFO_WM_2(pipe), val * 3);\r\n}\r\nint mdp5_smp_request(struct mdp5_smp *smp, enum mdp5_pipe pipe,\r\nconst struct mdp_format *format, u32 width, bool hdecim)\r\n{\r\nstruct mdp5_kms *mdp5_kms = get_kms(smp);\r\nstruct drm_device *dev = mdp5_kms->dev;\r\nint rev = mdp5_cfg_get_hw_rev(mdp5_kms->cfg);\r\nint i, hsub, nplanes, nlines, nblks, ret;\r\nu32 fmt = format->base.pixel_format;\r\nnplanes = drm_format_num_planes(fmt);\r\nhsub = drm_format_horz_chroma_subsampling(fmt);\r\nnlines = 2;\r\nif ((rev > 0) && (format->chroma_sample > CHROMA_FULL)) {\r\nfmt = DRM_FORMAT_NV24;\r\nnplanes = 2;\r\nif (hdecim && (hsub > 1))\r\nhsub = 1;\r\n}\r\nfor (i = 0, nblks = 0; i < nplanes; i++) {\r\nint n, fetch_stride, cpp;\r\ncpp = drm_format_plane_cpp(fmt, i);\r\nfetch_stride = width * cpp / (i ? hsub : 1);\r\nn = DIV_ROUND_UP(fetch_stride * nlines, smp->blk_size);\r\nif (rev == 0)\r\nn = roundup_pow_of_two(n);\r\nDBG("%s[%d]: request %d SMP blocks", pipe2name(pipe), i, n);\r\nret = smp_request_block(smp, pipe2client(pipe, i), n);\r\nif (ret) {\r\ndev_err(dev->dev, "Cannot allocate %d SMP blocks: %d\n",\r\nn, ret);\r\nreturn ret;\r\n}\r\nnblks += n;\r\n}\r\nset_fifo_thresholds(smp, pipe, nblks);\r\nreturn 0;\r\n}\r\nvoid mdp5_smp_release(struct mdp5_smp *smp, enum mdp5_pipe pipe)\r\n{\r\nint i;\r\nunsigned long flags;\r\nint cnt = smp->blk_cnt;\r\nfor (i = 0; i < pipe2nclients(pipe); i++) {\r\nmdp5_smp_state_t assigned;\r\nu32 cid = pipe2client(pipe, i);\r\nstruct mdp5_client_smp_state *ps = &smp->client_state[cid];\r\nspin_lock_irqsave(&smp->state_lock, flags);\r\nbitmap_or(assigned, ps->inuse, ps->configured, cnt);\r\nupdate_smp_state(smp, CID_UNUSED, &assigned);\r\nbitmap_andnot(smp->state, smp->state, ps->pending, cnt);\r\nbitmap_andnot(smp->state, smp->state, assigned, cnt);\r\nbitmap_zero(ps->pending, cnt);\r\nbitmap_zero(ps->configured, cnt);\r\nbitmap_zero(ps->inuse, cnt);\r\nspin_unlock_irqrestore(&smp->state_lock, flags);\r\n}\r\nset_fifo_thresholds(smp, pipe, 0);\r\n}\r\nstatic void update_smp_state(struct mdp5_smp *smp,\r\nu32 cid, mdp5_smp_state_t *assigned)\r\n{\r\nstruct mdp5_kms *mdp5_kms = get_kms(smp);\r\nint cnt = smp->blk_cnt;\r\nu32 blk, val;\r\nfor_each_set_bit(blk, *assigned, cnt) {\r\nint idx = blk / 3;\r\nint fld = blk % 3;\r\nval = mdp5_read(mdp5_kms, REG_MDP5_MDP_SMP_ALLOC_W_REG(0, idx));\r\nswitch (fld) {\r\ncase 0:\r\nval &= ~MDP5_MDP_SMP_ALLOC_W_REG_CLIENT0__MASK;\r\nval |= MDP5_MDP_SMP_ALLOC_W_REG_CLIENT0(cid);\r\nbreak;\r\ncase 1:\r\nval &= ~MDP5_MDP_SMP_ALLOC_W_REG_CLIENT1__MASK;\r\nval |= MDP5_MDP_SMP_ALLOC_W_REG_CLIENT1(cid);\r\nbreak;\r\ncase 2:\r\nval &= ~MDP5_MDP_SMP_ALLOC_W_REG_CLIENT2__MASK;\r\nval |= MDP5_MDP_SMP_ALLOC_W_REG_CLIENT2(cid);\r\nbreak;\r\n}\r\nmdp5_write(mdp5_kms, REG_MDP5_MDP_SMP_ALLOC_W_REG(0, idx), val);\r\nmdp5_write(mdp5_kms, REG_MDP5_MDP_SMP_ALLOC_R_REG(0, idx), val);\r\n}\r\n}\r\nvoid mdp5_smp_configure(struct mdp5_smp *smp, enum mdp5_pipe pipe)\r\n{\r\nint cnt = smp->blk_cnt;\r\nmdp5_smp_state_t assigned;\r\nint i;\r\nfor (i = 0; i < pipe2nclients(pipe); i++) {\r\nu32 cid = pipe2client(pipe, i);\r\nstruct mdp5_client_smp_state *ps = &smp->client_state[cid];\r\nif (!bitmap_equal(ps->inuse, ps->configured, cnt))\r\ncontinue;\r\nbitmap_copy(ps->configured, ps->pending, cnt);\r\nbitmap_or(assigned, ps->inuse, ps->configured, cnt);\r\nupdate_smp_state(smp, cid, &assigned);\r\n}\r\n}\r\nvoid mdp5_smp_commit(struct mdp5_smp *smp, enum mdp5_pipe pipe)\r\n{\r\nint cnt = smp->blk_cnt;\r\nmdp5_smp_state_t released;\r\nint i;\r\nfor (i = 0; i < pipe2nclients(pipe); i++) {\r\nu32 cid = pipe2client(pipe, i);\r\nstruct mdp5_client_smp_state *ps = &smp->client_state[cid];\r\nif (bitmap_andnot(released, ps->inuse, ps->configured, cnt)) {\r\nunsigned long flags;\r\nspin_lock_irqsave(&smp->state_lock, flags);\r\nbitmap_andnot(smp->state, smp->state, released, cnt);\r\nspin_unlock_irqrestore(&smp->state_lock, flags);\r\nupdate_smp_state(smp, CID_UNUSED, &released);\r\n}\r\nbitmap_copy(ps->inuse, ps->configured, cnt);\r\n}\r\n}\r\nvoid mdp5_smp_destroy(struct mdp5_smp *smp)\r\n{\r\nkfree(smp);\r\n}\r\nstruct mdp5_smp *mdp5_smp_init(struct drm_device *dev, const struct mdp5_smp_block *cfg)\r\n{\r\nstruct mdp5_smp *smp = NULL;\r\nint ret;\r\nsmp = kzalloc(sizeof(*smp), GFP_KERNEL);\r\nif (unlikely(!smp)) {\r\nret = -ENOMEM;\r\ngoto fail;\r\n}\r\nsmp->dev = dev;\r\nsmp->blk_cnt = cfg->mmb_count;\r\nsmp->blk_size = cfg->mmb_size;\r\nbitmap_copy(smp->state, cfg->reserved_state, smp->blk_cnt);\r\nmemcpy(smp->reserved, cfg->reserved, sizeof(smp->reserved));\r\nspin_lock_init(&smp->state_lock);\r\nreturn smp;\r\nfail:\r\nif (smp)\r\nmdp5_smp_destroy(smp);\r\nreturn ERR_PTR(ret);\r\n}
