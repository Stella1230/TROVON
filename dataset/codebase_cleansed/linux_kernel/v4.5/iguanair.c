static void process_ir_data(struct iguanair *ir, unsigned len)\r\n{\r\nif (len >= 4 && ir->buf_in[0] == 0 && ir->buf_in[1] == 0) {\r\nswitch (ir->buf_in[3]) {\r\ncase CMD_GET_VERSION:\r\nif (len == 6) {\r\nir->version = (ir->buf_in[5] << 8) |\r\nir->buf_in[4];\r\ncomplete(&ir->completion);\r\n}\r\nbreak;\r\ncase CMD_GET_BUFSIZE:\r\nif (len >= 5) {\r\nir->bufsize = ir->buf_in[4];\r\ncomplete(&ir->completion);\r\n}\r\nbreak;\r\ncase CMD_GET_FEATURES:\r\nif (len > 5) {\r\nir->cycle_overhead = ir->buf_in[5];\r\ncomplete(&ir->completion);\r\n}\r\nbreak;\r\ncase CMD_TX_OVERFLOW:\r\nir->tx_overflow = true;\r\ncase CMD_RECEIVER_OFF:\r\ncase CMD_RECEIVER_ON:\r\ncase CMD_SEND:\r\ncomplete(&ir->completion);\r\nbreak;\r\ncase CMD_RX_OVERFLOW:\r\ndev_warn(ir->dev, "receive overflow\n");\r\nir_raw_event_reset(ir->rc);\r\nbreak;\r\ndefault:\r\ndev_warn(ir->dev, "control code %02x received\n",\r\nir->buf_in[3]);\r\nbreak;\r\n}\r\n} else if (len >= 7) {\r\nDEFINE_IR_RAW_EVENT(rawir);\r\nunsigned i;\r\nbool event = false;\r\ninit_ir_raw_event(&rawir);\r\nfor (i = 0; i < 7; i++) {\r\nif (ir->buf_in[i] == 0x80) {\r\nrawir.pulse = false;\r\nrawir.duration = US_TO_NS(21845);\r\n} else {\r\nrawir.pulse = (ir->buf_in[i] & 0x80) == 0;\r\nrawir.duration = ((ir->buf_in[i] & 0x7f) + 1) *\r\nRX_RESOLUTION;\r\n}\r\nif (ir_raw_event_store_with_filter(ir->rc, &rawir))\r\nevent = true;\r\n}\r\nif (event)\r\nir_raw_event_handle(ir->rc);\r\n}\r\n}\r\nstatic void iguanair_rx(struct urb *urb)\r\n{\r\nstruct iguanair *ir;\r\nint rc;\r\nif (!urb)\r\nreturn;\r\nir = urb->context;\r\nif (!ir) {\r\nusb_unlink_urb(urb);\r\nreturn;\r\n}\r\nswitch (urb->status) {\r\ncase 0:\r\nprocess_ir_data(ir, urb->actual_length);\r\nbreak;\r\ncase -ECONNRESET:\r\ncase -ENOENT:\r\ncase -ESHUTDOWN:\r\nusb_unlink_urb(urb);\r\nreturn;\r\ncase -EPIPE:\r\ndefault:\r\ndev_dbg(ir->dev, "Error: urb status = %d\n", urb->status);\r\nbreak;\r\n}\r\nrc = usb_submit_urb(urb, GFP_ATOMIC);\r\nif (rc && rc != -ENODEV)\r\ndev_warn(ir->dev, "failed to resubmit urb: %d\n", rc);\r\n}\r\nstatic void iguanair_irq_out(struct urb *urb)\r\n{\r\nstruct iguanair *ir = urb->context;\r\nif (urb->status)\r\ndev_dbg(ir->dev, "Error: out urb status = %d\n", urb->status);\r\nif (urb->status == 0 && ir->packet->header.cmd == CMD_NOP)\r\ncomplete(&ir->completion);\r\n}\r\nstatic int iguanair_send(struct iguanair *ir, unsigned size)\r\n{\r\nint rc;\r\nreinit_completion(&ir->completion);\r\nir->urb_out->transfer_buffer_length = size;\r\nrc = usb_submit_urb(ir->urb_out, GFP_KERNEL);\r\nif (rc)\r\nreturn rc;\r\nif (wait_for_completion_timeout(&ir->completion, TIMEOUT) == 0)\r\nreturn -ETIMEDOUT;\r\nreturn rc;\r\n}\r\nstatic int iguanair_get_features(struct iguanair *ir)\r\n{\r\nint rc;\r\nir->packet->header.start = 0;\r\nir->packet->header.direction = DIR_OUT;\r\nir->packet->header.cmd = CMD_NOP;\r\niguanair_send(ir, sizeof(ir->packet->header));\r\nir->packet->header.cmd = CMD_GET_VERSION;\r\nrc = iguanair_send(ir, sizeof(ir->packet->header));\r\nif (rc) {\r\ndev_info(ir->dev, "failed to get version\n");\r\ngoto out;\r\n}\r\nif (ir->version < 0x205) {\r\ndev_err(ir->dev, "firmware 0x%04x is too old\n", ir->version);\r\nrc = -ENODEV;\r\ngoto out;\r\n}\r\nir->bufsize = 150;\r\nir->cycle_overhead = 65;\r\nir->packet->header.cmd = CMD_GET_BUFSIZE;\r\nrc = iguanair_send(ir, sizeof(ir->packet->header));\r\nif (rc) {\r\ndev_info(ir->dev, "failed to get buffer size\n");\r\ngoto out;\r\n}\r\nif (ir->bufsize > BUF_SIZE) {\r\ndev_info(ir->dev, "buffer size %u larger than expected\n",\r\nir->bufsize);\r\nir->bufsize = BUF_SIZE;\r\n}\r\nir->packet->header.cmd = CMD_GET_FEATURES;\r\nrc = iguanair_send(ir, sizeof(ir->packet->header));\r\nif (rc)\r\ndev_info(ir->dev, "failed to get features\n");\r\nout:\r\nreturn rc;\r\n}\r\nstatic int iguanair_receiver(struct iguanair *ir, bool enable)\r\n{\r\nir->packet->header.start = 0;\r\nir->packet->header.direction = DIR_OUT;\r\nir->packet->header.cmd = enable ? CMD_RECEIVER_ON : CMD_RECEIVER_OFF;\r\nif (enable)\r\nir_raw_event_reset(ir->rc);\r\nreturn iguanair_send(ir, sizeof(ir->packet->header));\r\n}\r\nstatic int iguanair_set_tx_carrier(struct rc_dev *dev, uint32_t carrier)\r\n{\r\nstruct iguanair *ir = dev->priv;\r\nif (carrier < 25000 || carrier > 150000)\r\nreturn -EINVAL;\r\nmutex_lock(&ir->lock);\r\nif (carrier != ir->carrier) {\r\nuint32_t cycles, fours, sevens;\r\nir->carrier = carrier;\r\ncycles = DIV_ROUND_CLOSEST(24000000, carrier * 2) -\r\nir->cycle_overhead;\r\nsevens = (4 - cycles) & 3;\r\nfours = (cycles - sevens * 7) / 4;\r\nir->packet->busy7 = (4 - sevens) * 2;\r\nir->packet->busy4 = 110 - fours;\r\n}\r\nmutex_unlock(&ir->lock);\r\nreturn carrier;\r\n}\r\nstatic int iguanair_set_tx_mask(struct rc_dev *dev, uint32_t mask)\r\n{\r\nstruct iguanair *ir = dev->priv;\r\nif (mask > 15)\r\nreturn 4;\r\nmutex_lock(&ir->lock);\r\nir->packet->channels = mask << 4;\r\nmutex_unlock(&ir->lock);\r\nreturn 0;\r\n}\r\nstatic int iguanair_tx(struct rc_dev *dev, unsigned *txbuf, unsigned count)\r\n{\r\nstruct iguanair *ir = dev->priv;\r\nuint8_t space;\r\nunsigned i, size, periods, bytes;\r\nint rc;\r\nmutex_lock(&ir->lock);\r\nfor (i = space = size = 0; i < count; i++) {\r\nperiods = DIV_ROUND_CLOSEST(txbuf[i] * ir->carrier, 1000000);\r\nbytes = DIV_ROUND_UP(periods, 127);\r\nif (size + bytes > ir->bufsize) {\r\nrc = -EINVAL;\r\ngoto out;\r\n}\r\nwhile (periods) {\r\nunsigned p = min(periods, 127u);\r\nir->packet->payload[size++] = p | space;\r\nperiods -= p;\r\n}\r\nspace ^= 0x80;\r\n}\r\nir->packet->header.start = 0;\r\nir->packet->header.direction = DIR_OUT;\r\nir->packet->header.cmd = CMD_SEND;\r\nir->packet->length = size;\r\nir->tx_overflow = false;\r\nrc = iguanair_send(ir, sizeof(*ir->packet) + size);\r\nif (rc == 0 && ir->tx_overflow)\r\nrc = -EOVERFLOW;\r\nout:\r\nmutex_unlock(&ir->lock);\r\nreturn rc ? rc : count;\r\n}\r\nstatic int iguanair_open(struct rc_dev *rdev)\r\n{\r\nstruct iguanair *ir = rdev->priv;\r\nint rc;\r\nmutex_lock(&ir->lock);\r\nrc = iguanair_receiver(ir, true);\r\nif (rc == 0)\r\nir->receiver_on = true;\r\nmutex_unlock(&ir->lock);\r\nreturn rc;\r\n}\r\nstatic void iguanair_close(struct rc_dev *rdev)\r\n{\r\nstruct iguanair *ir = rdev->priv;\r\nint rc;\r\nmutex_lock(&ir->lock);\r\nrc = iguanair_receiver(ir, false);\r\nir->receiver_on = false;\r\nif (rc && rc != -ENODEV)\r\ndev_warn(ir->dev, "failed to disable receiver: %d\n", rc);\r\nmutex_unlock(&ir->lock);\r\n}\r\nstatic int iguanair_probe(struct usb_interface *intf,\r\nconst struct usb_device_id *id)\r\n{\r\nstruct usb_device *udev = interface_to_usbdev(intf);\r\nstruct iguanair *ir;\r\nstruct rc_dev *rc;\r\nint ret, pipein, pipeout;\r\nstruct usb_host_interface *idesc;\r\nir = kzalloc(sizeof(*ir), GFP_KERNEL);\r\nrc = rc_allocate_device();\r\nif (!ir || !rc) {\r\nret = -ENOMEM;\r\ngoto out;\r\n}\r\nir->buf_in = usb_alloc_coherent(udev, MAX_IN_PACKET, GFP_KERNEL,\r\n&ir->dma_in);\r\nir->packet = usb_alloc_coherent(udev, MAX_OUT_PACKET, GFP_KERNEL,\r\n&ir->dma_out);\r\nir->urb_in = usb_alloc_urb(0, GFP_KERNEL);\r\nir->urb_out = usb_alloc_urb(0, GFP_KERNEL);\r\nif (!ir->buf_in || !ir->packet || !ir->urb_in || !ir->urb_out) {\r\nret = -ENOMEM;\r\ngoto out;\r\n}\r\nidesc = intf->altsetting;\r\nif (idesc->desc.bNumEndpoints < 2) {\r\nret = -ENODEV;\r\ngoto out;\r\n}\r\nir->rc = rc;\r\nir->dev = &intf->dev;\r\nir->udev = udev;\r\nmutex_init(&ir->lock);\r\ninit_completion(&ir->completion);\r\npipeout = usb_sndintpipe(udev,\r\nidesc->endpoint[1].desc.bEndpointAddress);\r\nusb_fill_int_urb(ir->urb_out, udev, pipeout, ir->packet, MAX_OUT_PACKET,\r\niguanair_irq_out, ir, 1);\r\nir->urb_out->transfer_dma = ir->dma_out;\r\nir->urb_out->transfer_flags |= URB_NO_TRANSFER_DMA_MAP;\r\npipein = usb_rcvintpipe(udev, idesc->endpoint[0].desc.bEndpointAddress);\r\nusb_fill_int_urb(ir->urb_in, udev, pipein, ir->buf_in, MAX_IN_PACKET,\r\niguanair_rx, ir, 1);\r\nir->urb_in->transfer_dma = ir->dma_in;\r\nir->urb_in->transfer_flags |= URB_NO_TRANSFER_DMA_MAP;\r\nret = usb_submit_urb(ir->urb_in, GFP_KERNEL);\r\nif (ret) {\r\ndev_warn(&intf->dev, "failed to submit urb: %d\n", ret);\r\ngoto out;\r\n}\r\nret = iguanair_get_features(ir);\r\nif (ret)\r\ngoto out2;\r\nsnprintf(ir->name, sizeof(ir->name),\r\n"IguanaWorks USB IR Transceiver version 0x%04x", ir->version);\r\nusb_make_path(ir->udev, ir->phys, sizeof(ir->phys));\r\nrc->input_name = ir->name;\r\nrc->input_phys = ir->phys;\r\nusb_to_input_id(ir->udev, &rc->input_id);\r\nrc->dev.parent = &intf->dev;\r\nrc->driver_type = RC_DRIVER_IR_RAW;\r\nrc->allowed_protocols = RC_BIT_ALL;\r\nrc->priv = ir;\r\nrc->open = iguanair_open;\r\nrc->close = iguanair_close;\r\nrc->s_tx_mask = iguanair_set_tx_mask;\r\nrc->s_tx_carrier = iguanair_set_tx_carrier;\r\nrc->tx_ir = iguanair_tx;\r\nrc->driver_name = DRIVER_NAME;\r\nrc->map_name = RC_MAP_RC6_MCE;\r\nrc->timeout = MS_TO_NS(100);\r\nrc->rx_resolution = RX_RESOLUTION;\r\niguanair_set_tx_carrier(rc, 38000);\r\niguanair_set_tx_mask(rc, 0);\r\nret = rc_register_device(rc);\r\nif (ret < 0) {\r\ndev_err(&intf->dev, "failed to register rc device %d", ret);\r\ngoto out2;\r\n}\r\nusb_set_intfdata(intf, ir);\r\nreturn 0;\r\nout2:\r\nusb_kill_urb(ir->urb_in);\r\nusb_kill_urb(ir->urb_out);\r\nout:\r\nif (ir) {\r\nusb_free_urb(ir->urb_in);\r\nusb_free_urb(ir->urb_out);\r\nusb_free_coherent(udev, MAX_IN_PACKET, ir->buf_in, ir->dma_in);\r\nusb_free_coherent(udev, MAX_OUT_PACKET, ir->packet,\r\nir->dma_out);\r\n}\r\nrc_free_device(rc);\r\nkfree(ir);\r\nreturn ret;\r\n}\r\nstatic void iguanair_disconnect(struct usb_interface *intf)\r\n{\r\nstruct iguanair *ir = usb_get_intfdata(intf);\r\nrc_unregister_device(ir->rc);\r\nusb_set_intfdata(intf, NULL);\r\nusb_kill_urb(ir->urb_in);\r\nusb_kill_urb(ir->urb_out);\r\nusb_free_urb(ir->urb_in);\r\nusb_free_urb(ir->urb_out);\r\nusb_free_coherent(ir->udev, MAX_IN_PACKET, ir->buf_in, ir->dma_in);\r\nusb_free_coherent(ir->udev, MAX_OUT_PACKET, ir->packet, ir->dma_out);\r\nkfree(ir);\r\n}\r\nstatic int iguanair_suspend(struct usb_interface *intf, pm_message_t message)\r\n{\r\nstruct iguanair *ir = usb_get_intfdata(intf);\r\nint rc = 0;\r\nmutex_lock(&ir->lock);\r\nif (ir->receiver_on) {\r\nrc = iguanair_receiver(ir, false);\r\nif (rc)\r\ndev_warn(ir->dev, "failed to disable receiver for suspend\n");\r\n}\r\nusb_kill_urb(ir->urb_in);\r\nusb_kill_urb(ir->urb_out);\r\nmutex_unlock(&ir->lock);\r\nreturn rc;\r\n}\r\nstatic int iguanair_resume(struct usb_interface *intf)\r\n{\r\nstruct iguanair *ir = usb_get_intfdata(intf);\r\nint rc = 0;\r\nmutex_lock(&ir->lock);\r\nrc = usb_submit_urb(ir->urb_in, GFP_KERNEL);\r\nif (rc)\r\ndev_warn(&intf->dev, "failed to submit urb: %d\n", rc);\r\nif (ir->receiver_on) {\r\nrc = iguanair_receiver(ir, true);\r\nif (rc)\r\ndev_warn(ir->dev, "failed to enable receiver after resume\n");\r\n}\r\nmutex_unlock(&ir->lock);\r\nreturn rc;\r\n}
