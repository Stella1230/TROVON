static inline u32 vsp1_uds_read(struct vsp1_uds *uds, u32 reg)\r\n{\r\nreturn vsp1_read(uds->entity.vsp1,\r\nreg + uds->entity.index * VI6_UDS_OFFSET);\r\n}\r\nstatic inline void vsp1_uds_write(struct vsp1_uds *uds, u32 reg, u32 data)\r\n{\r\nvsp1_write(uds->entity.vsp1,\r\nreg + uds->entity.index * VI6_UDS_OFFSET, data);\r\n}\r\nvoid vsp1_uds_set_alpha(struct vsp1_uds *uds, unsigned int alpha)\r\n{\r\nvsp1_uds_write(uds, VI6_UDS_ALPVAL, alpha << VI6_UDS_ALPVAL_VAL0_SHIFT);\r\n}\r\nstatic unsigned int uds_output_size(unsigned int input, unsigned int ratio)\r\n{\r\nif (ratio > 4096) {\r\nunsigned int mp;\r\nmp = ratio / 4096;\r\nmp = mp < 4 ? 1 : (mp < 8 ? 2 : 4);\r\nreturn (input - 1) / mp * mp * 4096 / ratio + 1;\r\n} else {\r\nreturn (input - 1) * 4096 / ratio + 1;\r\n}\r\n}\r\nstatic void uds_output_limits(unsigned int input,\r\nunsigned int *minimum, unsigned int *maximum)\r\n{\r\n*minimum = max(uds_output_size(input, UDS_MAX_FACTOR), UDS_MIN_SIZE);\r\n*maximum = min(uds_output_size(input, UDS_MIN_FACTOR), UDS_MAX_SIZE);\r\n}\r\nstatic unsigned int uds_passband_width(unsigned int ratio)\r\n{\r\nif (ratio >= 4096) {\r\nunsigned int mp;\r\nmp = ratio / 4096;\r\nmp = mp < 4 ? 1 : (mp < 8 ? 2 : 4);\r\nreturn 64 * 4096 * mp / ratio;\r\n} else {\r\nreturn 64;\r\n}\r\n}\r\nstatic unsigned int uds_compute_ratio(unsigned int input, unsigned int output)\r\n{\r\nreturn (input - 1) * 4096 / (output - 1);\r\n}\r\nstatic int uds_s_stream(struct v4l2_subdev *subdev, int enable)\r\n{\r\nstruct vsp1_uds *uds = to_uds(subdev);\r\nconst struct v4l2_mbus_framefmt *output;\r\nconst struct v4l2_mbus_framefmt *input;\r\nunsigned int hscale;\r\nunsigned int vscale;\r\nbool multitap;\r\nif (!enable)\r\nreturn 0;\r\ninput = &uds->entity.formats[UDS_PAD_SINK];\r\noutput = &uds->entity.formats[UDS_PAD_SOURCE];\r\nhscale = uds_compute_ratio(input->width, output->width);\r\nvscale = uds_compute_ratio(input->height, output->height);\r\ndev_dbg(uds->entity.vsp1->dev, "hscale %u vscale %u\n", hscale, vscale);\r\nif (uds->scale_alpha && (hscale >= 8192 || vscale >= 8192))\r\nmultitap = false;\r\nelse\r\nmultitap = true;\r\nvsp1_uds_write(uds, VI6_UDS_CTRL,\r\n(uds->scale_alpha ? VI6_UDS_CTRL_AON : 0) |\r\n(multitap ? VI6_UDS_CTRL_BC : 0));\r\nvsp1_uds_write(uds, VI6_UDS_PASS_BWIDTH,\r\n(uds_passband_width(hscale)\r\n<< VI6_UDS_PASS_BWIDTH_H_SHIFT) |\r\n(uds_passband_width(vscale)\r\n<< VI6_UDS_PASS_BWIDTH_V_SHIFT));\r\nvsp1_uds_write(uds, VI6_UDS_SCALE,\r\n(hscale << VI6_UDS_SCALE_HFRAC_SHIFT) |\r\n(vscale << VI6_UDS_SCALE_VFRAC_SHIFT));\r\nvsp1_uds_write(uds, VI6_UDS_CLIP_SIZE,\r\n(output->width << VI6_UDS_CLIP_SIZE_HSIZE_SHIFT) |\r\n(output->height << VI6_UDS_CLIP_SIZE_VSIZE_SHIFT));\r\nreturn 0;\r\n}\r\nstatic int uds_enum_mbus_code(struct v4l2_subdev *subdev,\r\nstruct v4l2_subdev_pad_config *cfg,\r\nstruct v4l2_subdev_mbus_code_enum *code)\r\n{\r\nstatic const unsigned int codes[] = {\r\nMEDIA_BUS_FMT_ARGB8888_1X32,\r\nMEDIA_BUS_FMT_AYUV8_1X32,\r\n};\r\nstruct vsp1_uds *uds = to_uds(subdev);\r\nif (code->pad == UDS_PAD_SINK) {\r\nif (code->index >= ARRAY_SIZE(codes))\r\nreturn -EINVAL;\r\ncode->code = codes[code->index];\r\n} else {\r\nstruct v4l2_mbus_framefmt *format;\r\nif (code->index)\r\nreturn -EINVAL;\r\nformat = vsp1_entity_get_pad_format(&uds->entity, cfg,\r\nUDS_PAD_SINK, code->which);\r\ncode->code = format->code;\r\n}\r\nreturn 0;\r\n}\r\nstatic int uds_enum_frame_size(struct v4l2_subdev *subdev,\r\nstruct v4l2_subdev_pad_config *cfg,\r\nstruct v4l2_subdev_frame_size_enum *fse)\r\n{\r\nstruct vsp1_uds *uds = to_uds(subdev);\r\nstruct v4l2_mbus_framefmt *format;\r\nformat = vsp1_entity_get_pad_format(&uds->entity, cfg,\r\nUDS_PAD_SINK, fse->which);\r\nif (fse->index || fse->code != format->code)\r\nreturn -EINVAL;\r\nif (fse->pad == UDS_PAD_SINK) {\r\nfse->min_width = UDS_MIN_SIZE;\r\nfse->max_width = UDS_MAX_SIZE;\r\nfse->min_height = UDS_MIN_SIZE;\r\nfse->max_height = UDS_MAX_SIZE;\r\n} else {\r\nuds_output_limits(format->width, &fse->min_width,\r\n&fse->max_width);\r\nuds_output_limits(format->height, &fse->min_height,\r\n&fse->max_height);\r\n}\r\nreturn 0;\r\n}\r\nstatic int uds_get_format(struct v4l2_subdev *subdev, struct v4l2_subdev_pad_config *cfg,\r\nstruct v4l2_subdev_format *fmt)\r\n{\r\nstruct vsp1_uds *uds = to_uds(subdev);\r\nfmt->format = *vsp1_entity_get_pad_format(&uds->entity, cfg, fmt->pad,\r\nfmt->which);\r\nreturn 0;\r\n}\r\nstatic void uds_try_format(struct vsp1_uds *uds, struct v4l2_subdev_pad_config *cfg,\r\nunsigned int pad, struct v4l2_mbus_framefmt *fmt,\r\nenum v4l2_subdev_format_whence which)\r\n{\r\nstruct v4l2_mbus_framefmt *format;\r\nunsigned int minimum;\r\nunsigned int maximum;\r\nswitch (pad) {\r\ncase UDS_PAD_SINK:\r\nif (fmt->code != MEDIA_BUS_FMT_ARGB8888_1X32 &&\r\nfmt->code != MEDIA_BUS_FMT_AYUV8_1X32)\r\nfmt->code = MEDIA_BUS_FMT_AYUV8_1X32;\r\nfmt->width = clamp(fmt->width, UDS_MIN_SIZE, UDS_MAX_SIZE);\r\nfmt->height = clamp(fmt->height, UDS_MIN_SIZE, UDS_MAX_SIZE);\r\nbreak;\r\ncase UDS_PAD_SOURCE:\r\nformat = vsp1_entity_get_pad_format(&uds->entity, cfg,\r\nUDS_PAD_SINK, which);\r\nfmt->code = format->code;\r\nuds_output_limits(format->width, &minimum, &maximum);\r\nfmt->width = clamp(fmt->width, minimum, maximum);\r\nuds_output_limits(format->height, &minimum, &maximum);\r\nfmt->height = clamp(fmt->height, minimum, maximum);\r\nbreak;\r\n}\r\nfmt->field = V4L2_FIELD_NONE;\r\nfmt->colorspace = V4L2_COLORSPACE_SRGB;\r\n}\r\nstatic int uds_set_format(struct v4l2_subdev *subdev, struct v4l2_subdev_pad_config *cfg,\r\nstruct v4l2_subdev_format *fmt)\r\n{\r\nstruct vsp1_uds *uds = to_uds(subdev);\r\nstruct v4l2_mbus_framefmt *format;\r\nuds_try_format(uds, cfg, fmt->pad, &fmt->format, fmt->which);\r\nformat = vsp1_entity_get_pad_format(&uds->entity, cfg, fmt->pad,\r\nfmt->which);\r\n*format = fmt->format;\r\nif (fmt->pad == UDS_PAD_SINK) {\r\nformat = vsp1_entity_get_pad_format(&uds->entity, cfg,\r\nUDS_PAD_SOURCE, fmt->which);\r\n*format = fmt->format;\r\nuds_try_format(uds, cfg, UDS_PAD_SOURCE, format, fmt->which);\r\n}\r\nreturn 0;\r\n}\r\nstruct vsp1_uds *vsp1_uds_create(struct vsp1_device *vsp1, unsigned int index)\r\n{\r\nstruct v4l2_subdev *subdev;\r\nstruct vsp1_uds *uds;\r\nint ret;\r\nuds = devm_kzalloc(vsp1->dev, sizeof(*uds), GFP_KERNEL);\r\nif (uds == NULL)\r\nreturn ERR_PTR(-ENOMEM);\r\nuds->entity.type = VSP1_ENTITY_UDS;\r\nuds->entity.index = index;\r\nret = vsp1_entity_init(vsp1, &uds->entity, 2);\r\nif (ret < 0)\r\nreturn ERR_PTR(ret);\r\nsubdev = &uds->entity.subdev;\r\nv4l2_subdev_init(subdev, &uds_ops);\r\nsubdev->entity.ops = &vsp1_media_ops;\r\nsubdev->internal_ops = &vsp1_subdev_internal_ops;\r\nsnprintf(subdev->name, sizeof(subdev->name), "%s uds.%u",\r\ndev_name(vsp1->dev), index);\r\nv4l2_set_subdevdata(subdev, uds);\r\nsubdev->flags |= V4L2_SUBDEV_FL_HAS_DEVNODE;\r\nvsp1_entity_init_formats(subdev, NULL);\r\nreturn uds;\r\n}
