static inline u32 mic_dma_hw_ring_inc(u32 val)\r\n{\r\nreturn (val + 1) % MIC_DMA_DESC_RX_SIZE;\r\n}\r\nstatic inline u32 mic_dma_hw_ring_dec(u32 val)\r\n{\r\nreturn val ? val - 1 : MIC_DMA_DESC_RX_SIZE - 1;\r\n}\r\nstatic inline void mic_dma_hw_ring_inc_head(struct mic_dma_chan *ch)\r\n{\r\nch->head = mic_dma_hw_ring_inc(ch->head);\r\n}\r\nstatic inline void mic_dma_memcpy_desc(struct mic_dma_desc *desc,\r\ndma_addr_t src_phys, dma_addr_t dst_phys, u64 size)\r\n{\r\nu64 qw0, qw1;\r\nqw0 = src_phys;\r\nqw0 |= (size >> MIC_DMA_ALIGN_SHIFT) << MIC_DMA_MEMCPY_LEN_SHIFT;\r\nqw1 = MIC_DMA_MEMCPY;\r\nqw1 <<= MIC_DMA_DESC_TYPE_SHIFT;\r\nqw1 |= dst_phys;\r\ndesc->qw0 = qw0;\r\ndesc->qw1 = qw1;\r\n}\r\nstatic inline void mic_dma_prep_status_desc(struct mic_dma_desc *desc, u64 data,\r\ndma_addr_t dst_phys, bool generate_intr)\r\n{\r\nu64 qw0, qw1;\r\nqw0 = data;\r\nqw1 = (u64) MIC_DMA_STATUS << MIC_DMA_DESC_TYPE_SHIFT | dst_phys;\r\nif (generate_intr)\r\nqw1 |= (1ULL << MIC_DMA_STAT_INTR_SHIFT);\r\ndesc->qw0 = qw0;\r\ndesc->qw1 = qw1;\r\n}\r\nstatic void mic_dma_cleanup(struct mic_dma_chan *ch)\r\n{\r\nstruct dma_async_tx_descriptor *tx;\r\nu32 tail;\r\nu32 last_tail;\r\nspin_lock(&ch->cleanup_lock);\r\ntail = mic_dma_read_cmp_cnt(ch);\r\nsmp_rmb();\r\nfor (last_tail = ch->last_tail; tail != last_tail;) {\r\ntx = &ch->tx_array[last_tail];\r\nif (tx->cookie) {\r\ndma_cookie_complete(tx);\r\nif (tx->callback) {\r\ntx->callback(tx->callback_param);\r\ntx->callback = NULL;\r\n}\r\n}\r\nlast_tail = mic_dma_hw_ring_inc(last_tail);\r\n}\r\nsmp_mb();\r\nch->last_tail = last_tail;\r\nspin_unlock(&ch->cleanup_lock);\r\n}\r\nstatic u32 mic_dma_ring_count(u32 head, u32 tail)\r\n{\r\nu32 count;\r\nif (head >= tail)\r\ncount = (tail - 0) + (MIC_DMA_DESC_RX_SIZE - head);\r\nelse\r\ncount = tail - head;\r\nreturn count - 1;\r\n}\r\nstatic int mic_dma_avail_desc_ring_space(struct mic_dma_chan *ch, int required)\r\n{\r\nstruct device *dev = mic_dma_ch_to_device(ch);\r\nu32 count;\r\ncount = mic_dma_ring_count(ch->head, ch->last_tail);\r\nif (count < required) {\r\nmic_dma_cleanup(ch);\r\ncount = mic_dma_ring_count(ch->head, ch->last_tail);\r\n}\r\nif (count < required) {\r\ndev_dbg(dev, "Not enough desc space");\r\ndev_dbg(dev, "%s %d required=%u, avail=%u\n",\r\n__func__, __LINE__, required, count);\r\nreturn -ENOMEM;\r\n} else {\r\nreturn count;\r\n}\r\n}\r\nstatic int mic_dma_prog_memcpy_desc(struct mic_dma_chan *ch, dma_addr_t src,\r\ndma_addr_t dst, size_t len)\r\n{\r\nsize_t current_transfer_len;\r\nsize_t max_xfer_size = to_mic_dma_dev(ch)->max_xfer_size;\r\nint num_desc = len / max_xfer_size + 3;\r\nint ret;\r\nif (len % max_xfer_size)\r\nnum_desc++;\r\nret = mic_dma_avail_desc_ring_space(ch, num_desc);\r\nif (ret < 0)\r\nreturn ret;\r\ndo {\r\ncurrent_transfer_len = min(len, max_xfer_size);\r\nmic_dma_memcpy_desc(&ch->desc_ring[ch->head],\r\nsrc, dst, current_transfer_len);\r\nmic_dma_hw_ring_inc_head(ch);\r\nlen -= current_transfer_len;\r\ndst = dst + current_transfer_len;\r\nsrc = src + current_transfer_len;\r\n} while (len > 0);\r\nreturn 0;\r\n}\r\nstatic void mic_dma_prog_intr(struct mic_dma_chan *ch)\r\n{\r\nmic_dma_prep_status_desc(&ch->desc_ring[ch->head], 0,\r\nch->status_dest_micpa, false);\r\nmic_dma_hw_ring_inc_head(ch);\r\nmic_dma_prep_status_desc(&ch->desc_ring[ch->head], 0,\r\nch->status_dest_micpa, true);\r\nmic_dma_hw_ring_inc_head(ch);\r\n}\r\nstatic int mic_dma_do_dma(struct mic_dma_chan *ch, int flags, dma_addr_t src,\r\ndma_addr_t dst, size_t len)\r\n{\r\nif (len && -ENOMEM == mic_dma_prog_memcpy_desc(ch, src, dst, len)) {\r\nreturn -ENOMEM;\r\n} else {\r\nint ret = mic_dma_avail_desc_ring_space(ch, 3);\r\nif (ret < 0)\r\nreturn ret;\r\n}\r\nif (flags & DMA_PREP_FENCE) {\r\nmic_dma_prep_status_desc(&ch->desc_ring[ch->head], 0,\r\nch->status_dest_micpa, false);\r\nmic_dma_hw_ring_inc_head(ch);\r\n}\r\nif (flags & DMA_PREP_INTERRUPT)\r\nmic_dma_prog_intr(ch);\r\nreturn 0;\r\n}\r\nstatic inline void mic_dma_issue_pending(struct dma_chan *ch)\r\n{\r\nstruct mic_dma_chan *mic_ch = to_mic_dma_chan(ch);\r\nspin_lock(&mic_ch->issue_lock);\r\nif (mic_ch->issued == mic_ch->submitted)\r\ngoto out;\r\nmic_ch->issued = mic_ch->submitted;\r\nwmb();\r\nmic_dma_write_reg(mic_ch, MIC_DMA_REG_DHPR, mic_ch->issued);\r\nout:\r\nspin_unlock(&mic_ch->issue_lock);\r\n}\r\nstatic inline void mic_dma_update_pending(struct mic_dma_chan *ch)\r\n{\r\nif (mic_dma_ring_count(ch->issued, ch->submitted)\r\n> mic_dma_pending_level)\r\nmic_dma_issue_pending(&ch->api_ch);\r\n}\r\nstatic dma_cookie_t mic_dma_tx_submit_unlock(struct dma_async_tx_descriptor *tx)\r\n{\r\nstruct mic_dma_chan *mic_ch = to_mic_dma_chan(tx->chan);\r\ndma_cookie_t cookie;\r\ndma_cookie_assign(tx);\r\ncookie = tx->cookie;\r\nsmp_wmb();\r\nmic_ch->submitted = mic_ch->head;\r\nspin_unlock(&mic_ch->prep_lock);\r\nmic_dma_update_pending(mic_ch);\r\nreturn cookie;\r\n}\r\nstatic inline struct dma_async_tx_descriptor *\r\nallocate_tx(struct mic_dma_chan *ch)\r\n{\r\nu32 idx = mic_dma_hw_ring_dec(ch->head);\r\nstruct dma_async_tx_descriptor *tx = &ch->tx_array[idx];\r\ndma_async_tx_descriptor_init(tx, &ch->api_ch);\r\ntx->tx_submit = mic_dma_tx_submit_unlock;\r\nreturn tx;\r\n}\r\nstatic struct dma_async_tx_descriptor *\r\nmic_dma_prep_status_lock(struct dma_chan *ch, dma_addr_t dst, u64 src_val,\r\nunsigned long flags)\r\n{\r\nstruct mic_dma_chan *mic_ch = to_mic_dma_chan(ch);\r\nint result;\r\nspin_lock(&mic_ch->prep_lock);\r\nresult = mic_dma_avail_desc_ring_space(mic_ch, 4);\r\nif (result < 0)\r\ngoto error;\r\nmic_dma_prep_status_desc(&mic_ch->desc_ring[mic_ch->head], src_val, dst,\r\nfalse);\r\nmic_dma_hw_ring_inc_head(mic_ch);\r\nresult = mic_dma_do_dma(mic_ch, flags, 0, 0, 0);\r\nif (result < 0)\r\ngoto error;\r\nreturn allocate_tx(mic_ch);\r\nerror:\r\ndev_err(mic_dma_ch_to_device(mic_ch),\r\n"Error enqueueing dma status descriptor, error=%d\n", result);\r\nspin_unlock(&mic_ch->prep_lock);\r\nreturn NULL;\r\n}\r\nstatic struct dma_async_tx_descriptor *\r\nmic_dma_prep_memcpy_lock(struct dma_chan *ch, dma_addr_t dma_dest,\r\ndma_addr_t dma_src, size_t len, unsigned long flags)\r\n{\r\nstruct mic_dma_chan *mic_ch = to_mic_dma_chan(ch);\r\nstruct device *dev = mic_dma_ch_to_device(mic_ch);\r\nint result;\r\nif (!len && !flags)\r\nreturn NULL;\r\nspin_lock(&mic_ch->prep_lock);\r\nresult = mic_dma_do_dma(mic_ch, flags, dma_src, dma_dest, len);\r\nif (result >= 0)\r\nreturn allocate_tx(mic_ch);\r\ndev_err(dev, "Error enqueueing dma, error=%d\n", result);\r\nspin_unlock(&mic_ch->prep_lock);\r\nreturn NULL;\r\n}\r\nstatic struct dma_async_tx_descriptor *\r\nmic_dma_prep_interrupt_lock(struct dma_chan *ch, unsigned long flags)\r\n{\r\nstruct mic_dma_chan *mic_ch = to_mic_dma_chan(ch);\r\nint ret;\r\nspin_lock(&mic_ch->prep_lock);\r\nret = mic_dma_do_dma(mic_ch, flags, 0, 0, 0);\r\nif (!ret)\r\nreturn allocate_tx(mic_ch);\r\nspin_unlock(&mic_ch->prep_lock);\r\nreturn NULL;\r\n}\r\nstatic enum dma_status\r\nmic_dma_tx_status(struct dma_chan *ch, dma_cookie_t cookie,\r\nstruct dma_tx_state *txstate)\r\n{\r\nstruct mic_dma_chan *mic_ch = to_mic_dma_chan(ch);\r\nif (DMA_COMPLETE != dma_cookie_status(ch, cookie, txstate))\r\nmic_dma_cleanup(mic_ch);\r\nreturn dma_cookie_status(ch, cookie, txstate);\r\n}\r\nstatic irqreturn_t mic_dma_thread_fn(int irq, void *data)\r\n{\r\nmic_dma_cleanup((struct mic_dma_chan *)data);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic irqreturn_t mic_dma_intr_handler(int irq, void *data)\r\n{\r\nstruct mic_dma_chan *ch = ((struct mic_dma_chan *)data);\r\nmic_dma_ack_interrupt(ch);\r\nreturn IRQ_WAKE_THREAD;\r\n}\r\nstatic int mic_dma_alloc_desc_ring(struct mic_dma_chan *ch)\r\n{\r\nu64 desc_ring_size = MIC_DMA_DESC_RX_SIZE * sizeof(*ch->desc_ring);\r\nstruct device *dev = &to_mbus_device(ch)->dev;\r\ndesc_ring_size = ALIGN(desc_ring_size, MIC_DMA_ALIGN_BYTES);\r\nch->desc_ring = kzalloc(desc_ring_size, GFP_KERNEL);\r\nif (!ch->desc_ring)\r\nreturn -ENOMEM;\r\nch->desc_ring_micpa = dma_map_single(dev, ch->desc_ring,\r\ndesc_ring_size, DMA_BIDIRECTIONAL);\r\nif (dma_mapping_error(dev, ch->desc_ring_micpa))\r\ngoto map_error;\r\nch->tx_array = vzalloc(MIC_DMA_DESC_RX_SIZE * sizeof(*ch->tx_array));\r\nif (!ch->tx_array)\r\ngoto tx_error;\r\nreturn 0;\r\ntx_error:\r\ndma_unmap_single(dev, ch->desc_ring_micpa, desc_ring_size,\r\nDMA_BIDIRECTIONAL);\r\nmap_error:\r\nkfree(ch->desc_ring);\r\nreturn -ENOMEM;\r\n}\r\nstatic void mic_dma_free_desc_ring(struct mic_dma_chan *ch)\r\n{\r\nu64 desc_ring_size = MIC_DMA_DESC_RX_SIZE * sizeof(*ch->desc_ring);\r\nvfree(ch->tx_array);\r\ndesc_ring_size = ALIGN(desc_ring_size, MIC_DMA_ALIGN_BYTES);\r\ndma_unmap_single(&to_mbus_device(ch)->dev, ch->desc_ring_micpa,\r\ndesc_ring_size, DMA_BIDIRECTIONAL);\r\nkfree(ch->desc_ring);\r\nch->desc_ring = NULL;\r\n}\r\nstatic void mic_dma_free_status_dest(struct mic_dma_chan *ch)\r\n{\r\ndma_unmap_single(&to_mbus_device(ch)->dev, ch->status_dest_micpa,\r\nL1_CACHE_BYTES, DMA_BIDIRECTIONAL);\r\nkfree(ch->status_dest);\r\n}\r\nstatic int mic_dma_alloc_status_dest(struct mic_dma_chan *ch)\r\n{\r\nstruct device *dev = &to_mbus_device(ch)->dev;\r\nch->status_dest = kzalloc(L1_CACHE_BYTES, GFP_KERNEL);\r\nif (!ch->status_dest)\r\nreturn -ENOMEM;\r\nch->status_dest_micpa = dma_map_single(dev, ch->status_dest,\r\nL1_CACHE_BYTES, DMA_BIDIRECTIONAL);\r\nif (dma_mapping_error(dev, ch->status_dest_micpa)) {\r\nkfree(ch->status_dest);\r\nch->status_dest = NULL;\r\nreturn -ENOMEM;\r\n}\r\nreturn 0;\r\n}\r\nstatic int mic_dma_check_chan(struct mic_dma_chan *ch)\r\n{\r\nif (mic_dma_read_reg(ch, MIC_DMA_REG_DCHERR) ||\r\nmic_dma_read_reg(ch, MIC_DMA_REG_DSTAT) & MIC_DMA_CHAN_QUIESCE) {\r\nmic_dma_disable_chan(ch);\r\nmic_dma_chan_mask_intr(ch);\r\ndev_err(mic_dma_ch_to_device(ch),\r\n"%s %d error setting up mic dma chan %d\n",\r\n__func__, __LINE__, ch->ch_num);\r\nreturn -EBUSY;\r\n}\r\nreturn 0;\r\n}\r\nstatic int mic_dma_chan_setup(struct mic_dma_chan *ch)\r\n{\r\nif (MIC_DMA_CHAN_MIC == ch->owner)\r\nmic_dma_chan_set_owner(ch);\r\nmic_dma_disable_chan(ch);\r\nmic_dma_chan_mask_intr(ch);\r\nmic_dma_write_reg(ch, MIC_DMA_REG_DCHERRMSK, 0);\r\nmic_dma_chan_set_desc_ring(ch);\r\nch->last_tail = mic_dma_read_reg(ch, MIC_DMA_REG_DTPR);\r\nch->head = ch->last_tail;\r\nch->issued = 0;\r\nmic_dma_chan_unmask_intr(ch);\r\nmic_dma_enable_chan(ch);\r\nreturn mic_dma_check_chan(ch);\r\n}\r\nstatic void mic_dma_chan_destroy(struct mic_dma_chan *ch)\r\n{\r\nmic_dma_disable_chan(ch);\r\nmic_dma_chan_mask_intr(ch);\r\n}\r\nstatic void mic_dma_unregister_dma_device(struct mic_dma_device *mic_dma_dev)\r\n{\r\ndma_async_device_unregister(&mic_dma_dev->dma_dev);\r\n}\r\nstatic int mic_dma_setup_irq(struct mic_dma_chan *ch)\r\n{\r\nch->cookie =\r\nto_mbus_hw_ops(ch)->request_threaded_irq(to_mbus_device(ch),\r\nmic_dma_intr_handler, mic_dma_thread_fn,\r\n"mic dma_channel", ch, ch->ch_num);\r\nif (IS_ERR(ch->cookie))\r\nreturn IS_ERR(ch->cookie);\r\nreturn 0;\r\n}\r\nstatic inline void mic_dma_free_irq(struct mic_dma_chan *ch)\r\n{\r\nto_mbus_hw_ops(ch)->free_irq(to_mbus_device(ch), ch->cookie, ch);\r\n}\r\nstatic int mic_dma_chan_init(struct mic_dma_chan *ch)\r\n{\r\nint ret = mic_dma_alloc_desc_ring(ch);\r\nif (ret)\r\ngoto ring_error;\r\nret = mic_dma_alloc_status_dest(ch);\r\nif (ret)\r\ngoto status_error;\r\nret = mic_dma_chan_setup(ch);\r\nif (ret)\r\ngoto chan_error;\r\nreturn ret;\r\nchan_error:\r\nmic_dma_free_status_dest(ch);\r\nstatus_error:\r\nmic_dma_free_desc_ring(ch);\r\nring_error:\r\nreturn ret;\r\n}\r\nstatic int mic_dma_drain_chan(struct mic_dma_chan *ch)\r\n{\r\nstruct dma_async_tx_descriptor *tx;\r\nint err = 0;\r\ndma_cookie_t cookie;\r\ntx = mic_dma_prep_memcpy_lock(&ch->api_ch, 0, 0, 0, DMA_PREP_FENCE);\r\nif (!tx) {\r\nerr = -ENOMEM;\r\ngoto error;\r\n}\r\ncookie = tx->tx_submit(tx);\r\nif (dma_submit_error(cookie))\r\nerr = -ENOMEM;\r\nelse\r\nerr = dma_sync_wait(&ch->api_ch, cookie);\r\nif (err) {\r\ndev_err(mic_dma_ch_to_device(ch), "%s %d TO chan 0x%x\n",\r\n__func__, __LINE__, ch->ch_num);\r\nerr = -EIO;\r\n}\r\nerror:\r\nmic_dma_cleanup(ch);\r\nreturn err;\r\n}\r\nstatic inline void mic_dma_chan_uninit(struct mic_dma_chan *ch)\r\n{\r\nmic_dma_chan_destroy(ch);\r\nmic_dma_cleanup(ch);\r\nmic_dma_free_status_dest(ch);\r\nmic_dma_free_desc_ring(ch);\r\n}\r\nstatic int mic_dma_init(struct mic_dma_device *mic_dma_dev,\r\nenum mic_dma_chan_owner owner)\r\n{\r\nint i, first_chan = mic_dma_dev->start_ch;\r\nstruct mic_dma_chan *ch;\r\nint ret;\r\nfor (i = first_chan; i < first_chan + MIC_DMA_NUM_CHAN; i++) {\r\nunsigned long data;\r\nch = &mic_dma_dev->mic_ch[i];\r\ndata = (unsigned long)ch;\r\nch->ch_num = i;\r\nch->owner = owner;\r\nspin_lock_init(&ch->cleanup_lock);\r\nspin_lock_init(&ch->prep_lock);\r\nspin_lock_init(&ch->issue_lock);\r\nret = mic_dma_setup_irq(ch);\r\nif (ret)\r\ngoto error;\r\n}\r\nreturn 0;\r\nerror:\r\nfor (i = i - 1; i >= first_chan; i--)\r\nmic_dma_free_irq(ch);\r\nreturn ret;\r\n}\r\nstatic void mic_dma_uninit(struct mic_dma_device *mic_dma_dev)\r\n{\r\nint i, first_chan = mic_dma_dev->start_ch;\r\nstruct mic_dma_chan *ch;\r\nfor (i = first_chan; i < first_chan + MIC_DMA_NUM_CHAN; i++) {\r\nch = &mic_dma_dev->mic_ch[i];\r\nmic_dma_free_irq(ch);\r\n}\r\n}\r\nstatic int mic_dma_alloc_chan_resources(struct dma_chan *ch)\r\n{\r\nint ret = mic_dma_chan_init(to_mic_dma_chan(ch));\r\nif (ret)\r\nreturn ret;\r\nreturn MIC_DMA_DESC_RX_SIZE;\r\n}\r\nstatic void mic_dma_free_chan_resources(struct dma_chan *ch)\r\n{\r\nstruct mic_dma_chan *mic_ch = to_mic_dma_chan(ch);\r\nmic_dma_drain_chan(mic_ch);\r\nmic_dma_chan_uninit(mic_ch);\r\n}\r\nstatic int mic_dma_register_dma_device(struct mic_dma_device *mic_dma_dev,\r\nenum mic_dma_chan_owner owner)\r\n{\r\nint i, first_chan = mic_dma_dev->start_ch;\r\ndma_cap_zero(mic_dma_dev->dma_dev.cap_mask);\r\ndma_cap_set(DMA_MEMCPY, mic_dma_dev->dma_dev.cap_mask);\r\nif (MIC_DMA_CHAN_HOST == owner)\r\ndma_cap_set(DMA_PRIVATE, mic_dma_dev->dma_dev.cap_mask);\r\nmic_dma_dev->dma_dev.device_alloc_chan_resources =\r\nmic_dma_alloc_chan_resources;\r\nmic_dma_dev->dma_dev.device_free_chan_resources =\r\nmic_dma_free_chan_resources;\r\nmic_dma_dev->dma_dev.device_tx_status = mic_dma_tx_status;\r\nmic_dma_dev->dma_dev.device_prep_dma_memcpy = mic_dma_prep_memcpy_lock;\r\nmic_dma_dev->dma_dev.device_prep_dma_imm_data =\r\nmic_dma_prep_status_lock;\r\nmic_dma_dev->dma_dev.device_prep_dma_interrupt =\r\nmic_dma_prep_interrupt_lock;\r\nmic_dma_dev->dma_dev.device_issue_pending = mic_dma_issue_pending;\r\nmic_dma_dev->dma_dev.copy_align = MIC_DMA_ALIGN_SHIFT;\r\nINIT_LIST_HEAD(&mic_dma_dev->dma_dev.channels);\r\nfor (i = first_chan; i < first_chan + MIC_DMA_NUM_CHAN; i++) {\r\nmic_dma_dev->mic_ch[i].api_ch.device = &mic_dma_dev->dma_dev;\r\ndma_cookie_init(&mic_dma_dev->mic_ch[i].api_ch);\r\nlist_add_tail(&mic_dma_dev->mic_ch[i].api_ch.device_node,\r\n&mic_dma_dev->dma_dev.channels);\r\n}\r\nreturn dma_async_device_register(&mic_dma_dev->dma_dev);\r\n}\r\nstatic struct mic_dma_device *mic_dma_dev_reg(struct mbus_device *mbdev,\r\nenum mic_dma_chan_owner owner)\r\n{\r\nstruct mic_dma_device *mic_dma_dev;\r\nint ret;\r\nstruct device *dev = &mbdev->dev;\r\nmic_dma_dev = kzalloc(sizeof(*mic_dma_dev), GFP_KERNEL);\r\nif (!mic_dma_dev) {\r\nret = -ENOMEM;\r\ngoto alloc_error;\r\n}\r\nmic_dma_dev->mbdev = mbdev;\r\nmic_dma_dev->dma_dev.dev = dev;\r\nmic_dma_dev->mmio = mbdev->mmio_va;\r\nif (MIC_DMA_CHAN_HOST == owner) {\r\nmic_dma_dev->start_ch = 0;\r\nmic_dma_dev->max_xfer_size = MIC_DMA_MAX_XFER_SIZE_HOST;\r\n} else {\r\nmic_dma_dev->start_ch = 4;\r\nmic_dma_dev->max_xfer_size = MIC_DMA_MAX_XFER_SIZE_CARD;\r\n}\r\nret = mic_dma_init(mic_dma_dev, owner);\r\nif (ret)\r\ngoto init_error;\r\nret = mic_dma_register_dma_device(mic_dma_dev, owner);\r\nif (ret)\r\ngoto reg_error;\r\nreturn mic_dma_dev;\r\nreg_error:\r\nmic_dma_uninit(mic_dma_dev);\r\ninit_error:\r\nkfree(mic_dma_dev);\r\nmic_dma_dev = NULL;\r\nalloc_error:\r\ndev_err(dev, "Error at %s %d ret=%d\n", __func__, __LINE__, ret);\r\nreturn mic_dma_dev;\r\n}\r\nstatic void mic_dma_dev_unreg(struct mic_dma_device *mic_dma_dev)\r\n{\r\nmic_dma_unregister_dma_device(mic_dma_dev);\r\nmic_dma_uninit(mic_dma_dev);\r\nkfree(mic_dma_dev);\r\n}\r\nstatic int mic_dma_reg_seq_show(struct seq_file *s, void *pos)\r\n{\r\nstruct mic_dma_device *mic_dma_dev = s->private;\r\nint i, chan_num, first_chan = mic_dma_dev->start_ch;\r\nstruct mic_dma_chan *ch;\r\nseq_printf(s, "SBOX_DCR: %#x\n",\r\nmic_dma_mmio_read(&mic_dma_dev->mic_ch[first_chan],\r\nMIC_DMA_SBOX_BASE + MIC_DMA_SBOX_DCR));\r\nseq_puts(s, "DMA Channel Registers\n");\r\nseq_printf(s, "%-10s| %-10s %-10s %-10s %-10s %-10s",\r\n"Channel", "DCAR", "DTPR", "DHPR", "DRAR_HI", "DRAR_LO");\r\nseq_printf(s, " %-11s %-14s %-10s\n", "DCHERR", "DCHERRMSK", "DSTAT");\r\nfor (i = first_chan; i < first_chan + MIC_DMA_NUM_CHAN; i++) {\r\nch = &mic_dma_dev->mic_ch[i];\r\nchan_num = ch->ch_num;\r\nseq_printf(s, "%-10i| %-#10x %-#10x %-#10x %-#10x",\r\nchan_num,\r\nmic_dma_read_reg(ch, MIC_DMA_REG_DCAR),\r\nmic_dma_read_reg(ch, MIC_DMA_REG_DTPR),\r\nmic_dma_read_reg(ch, MIC_DMA_REG_DHPR),\r\nmic_dma_read_reg(ch, MIC_DMA_REG_DRAR_HI));\r\nseq_printf(s, " %-#10x %-#10x %-#14x %-#10x\n",\r\nmic_dma_read_reg(ch, MIC_DMA_REG_DRAR_LO),\r\nmic_dma_read_reg(ch, MIC_DMA_REG_DCHERR),\r\nmic_dma_read_reg(ch, MIC_DMA_REG_DCHERRMSK),\r\nmic_dma_read_reg(ch, MIC_DMA_REG_DSTAT));\r\n}\r\nreturn 0;\r\n}\r\nstatic int mic_dma_reg_debug_open(struct inode *inode, struct file *file)\r\n{\r\nreturn single_open(file, mic_dma_reg_seq_show, inode->i_private);\r\n}\r\nstatic int mic_dma_reg_debug_release(struct inode *inode, struct file *file)\r\n{\r\nreturn single_release(inode, file);\r\n}\r\nstatic int mic_dma_driver_probe(struct mbus_device *mbdev)\r\n{\r\nstruct mic_dma_device *mic_dma_dev;\r\nenum mic_dma_chan_owner owner;\r\nif (MBUS_DEV_DMA_MIC == mbdev->id.device)\r\nowner = MIC_DMA_CHAN_MIC;\r\nelse\r\nowner = MIC_DMA_CHAN_HOST;\r\nmic_dma_dev = mic_dma_dev_reg(mbdev, owner);\r\ndev_set_drvdata(&mbdev->dev, mic_dma_dev);\r\nif (mic_dma_dbg) {\r\nmic_dma_dev->dbg_dir = debugfs_create_dir(dev_name(&mbdev->dev),\r\nmic_dma_dbg);\r\nif (mic_dma_dev->dbg_dir)\r\ndebugfs_create_file("mic_dma_reg", 0444,\r\nmic_dma_dev->dbg_dir, mic_dma_dev,\r\n&mic_dma_reg_ops);\r\n}\r\nreturn 0;\r\n}\r\nstatic void mic_dma_driver_remove(struct mbus_device *mbdev)\r\n{\r\nstruct mic_dma_device *mic_dma_dev;\r\nmic_dma_dev = dev_get_drvdata(&mbdev->dev);\r\ndebugfs_remove_recursive(mic_dma_dev->dbg_dir);\r\nmic_dma_dev_unreg(mic_dma_dev);\r\n}\r\nstatic int __init mic_x100_dma_init(void)\r\n{\r\nint rc = mbus_register_driver(&mic_dma_driver);\r\nif (rc)\r\nreturn rc;\r\nmic_dma_dbg = debugfs_create_dir(KBUILD_MODNAME, NULL);\r\nreturn 0;\r\n}\r\nstatic void __exit mic_x100_dma_exit(void)\r\n{\r\ndebugfs_remove_recursive(mic_dma_dbg);\r\nmbus_unregister_driver(&mic_dma_driver);\r\n}
