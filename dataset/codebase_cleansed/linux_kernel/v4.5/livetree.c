void add_label(struct label **labels, char *label)\r\n{\r\nstruct label *new;\r\nfor_each_label_withdel(*labels, new)\r\nif (streq(new->label, label)) {\r\nnew->deleted = 0;\r\nreturn;\r\n}\r\nnew = xmalloc(sizeof(*new));\r\nmemset(new, 0, sizeof(*new));\r\nnew->label = label;\r\nnew->next = *labels;\r\n*labels = new;\r\n}\r\nvoid delete_labels(struct label **labels)\r\n{\r\nstruct label *label;\r\nfor_each_label(*labels, label)\r\nlabel->deleted = 1;\r\n}\r\nstruct property *build_property(char *name, struct data val)\r\n{\r\nstruct property *new = xmalloc(sizeof(*new));\r\nmemset(new, 0, sizeof(*new));\r\nnew->name = name;\r\nnew->val = val;\r\nreturn new;\r\n}\r\nstruct property *build_property_delete(char *name)\r\n{\r\nstruct property *new = xmalloc(sizeof(*new));\r\nmemset(new, 0, sizeof(*new));\r\nnew->name = name;\r\nnew->deleted = 1;\r\nreturn new;\r\n}\r\nstruct property *chain_property(struct property *first, struct property *list)\r\n{\r\nassert(first->next == NULL);\r\nfirst->next = list;\r\nreturn first;\r\n}\r\nstruct property *reverse_properties(struct property *first)\r\n{\r\nstruct property *p = first;\r\nstruct property *head = NULL;\r\nstruct property *next;\r\nwhile (p) {\r\nnext = p->next;\r\np->next = head;\r\nhead = p;\r\np = next;\r\n}\r\nreturn head;\r\n}\r\nstruct node *build_node(struct property *proplist, struct node *children)\r\n{\r\nstruct node *new = xmalloc(sizeof(*new));\r\nstruct node *child;\r\nmemset(new, 0, sizeof(*new));\r\nnew->proplist = reverse_properties(proplist);\r\nnew->children = children;\r\nfor_each_child(new, child) {\r\nchild->parent = new;\r\n}\r\nreturn new;\r\n}\r\nstruct node *build_node_delete(void)\r\n{\r\nstruct node *new = xmalloc(sizeof(*new));\r\nmemset(new, 0, sizeof(*new));\r\nnew->deleted = 1;\r\nreturn new;\r\n}\r\nstruct node *name_node(struct node *node, char *name)\r\n{\r\nassert(node->name == NULL);\r\nnode->name = name;\r\nreturn node;\r\n}\r\nstruct node *merge_nodes(struct node *old_node, struct node *new_node)\r\n{\r\nstruct property *new_prop, *old_prop;\r\nstruct node *new_child, *old_child;\r\nstruct label *l;\r\nold_node->deleted = 0;\r\nfor_each_label_withdel(new_node->labels, l)\r\nadd_label(&old_node->labels, l->label);\r\nwhile (new_node->proplist) {\r\nnew_prop = new_node->proplist;\r\nnew_node->proplist = new_prop->next;\r\nnew_prop->next = NULL;\r\nif (new_prop->deleted) {\r\ndelete_property_by_name(old_node, new_prop->name);\r\nfree(new_prop);\r\ncontinue;\r\n}\r\nfor_each_property_withdel(old_node, old_prop) {\r\nif (streq(old_prop->name, new_prop->name)) {\r\nfor_each_label_withdel(new_prop->labels, l)\r\nadd_label(&old_prop->labels, l->label);\r\nold_prop->val = new_prop->val;\r\nold_prop->deleted = 0;\r\nfree(new_prop);\r\nnew_prop = NULL;\r\nbreak;\r\n}\r\n}\r\nif (new_prop)\r\nadd_property(old_node, new_prop);\r\n}\r\nwhile (new_node->children) {\r\nnew_child = new_node->children;\r\nnew_node->children = new_child->next_sibling;\r\nnew_child->parent = NULL;\r\nnew_child->next_sibling = NULL;\r\nif (new_child->deleted) {\r\ndelete_node_by_name(old_node, new_child->name);\r\nfree(new_child);\r\ncontinue;\r\n}\r\nfor_each_child_withdel(old_node, old_child) {\r\nif (streq(old_child->name, new_child->name)) {\r\nmerge_nodes(old_child, new_child);\r\nnew_child = NULL;\r\nbreak;\r\n}\r\n}\r\nif (new_child)\r\nadd_child(old_node, new_child);\r\n}\r\nfree(new_node);\r\nreturn old_node;\r\n}\r\nstruct node *chain_node(struct node *first, struct node *list)\r\n{\r\nassert(first->next_sibling == NULL);\r\nfirst->next_sibling = list;\r\nreturn first;\r\n}\r\nvoid add_property(struct node *node, struct property *prop)\r\n{\r\nstruct property **p;\r\nprop->next = NULL;\r\np = &node->proplist;\r\nwhile (*p)\r\np = &((*p)->next);\r\n*p = prop;\r\n}\r\nvoid delete_property_by_name(struct node *node, char *name)\r\n{\r\nstruct property *prop = node->proplist;\r\nwhile (prop) {\r\nif (!strcmp(prop->name, name)) {\r\ndelete_property(prop);\r\nreturn;\r\n}\r\nprop = prop->next;\r\n}\r\n}\r\nvoid delete_property(struct property *prop)\r\n{\r\nprop->deleted = 1;\r\ndelete_labels(&prop->labels);\r\n}\r\nvoid add_child(struct node *parent, struct node *child)\r\n{\r\nstruct node **p;\r\nchild->next_sibling = NULL;\r\nchild->parent = parent;\r\np = &parent->children;\r\nwhile (*p)\r\np = &((*p)->next_sibling);\r\n*p = child;\r\n}\r\nvoid delete_node_by_name(struct node *parent, char *name)\r\n{\r\nstruct node *node = parent->children;\r\nwhile (node) {\r\nif (!strcmp(node->name, name)) {\r\ndelete_node(node);\r\nreturn;\r\n}\r\nnode = node->next_sibling;\r\n}\r\n}\r\nvoid delete_node(struct node *node)\r\n{\r\nstruct property *prop;\r\nstruct node *child;\r\nnode->deleted = 1;\r\nfor_each_child(node, child)\r\ndelete_node(child);\r\nfor_each_property(node, prop)\r\ndelete_property(prop);\r\ndelete_labels(&node->labels);\r\n}\r\nstruct reserve_info *build_reserve_entry(uint64_t address, uint64_t size)\r\n{\r\nstruct reserve_info *new = xmalloc(sizeof(*new));\r\nmemset(new, 0, sizeof(*new));\r\nnew->re.address = address;\r\nnew->re.size = size;\r\nreturn new;\r\n}\r\nstruct reserve_info *chain_reserve_entry(struct reserve_info *first,\r\nstruct reserve_info *list)\r\n{\r\nassert(first->next == NULL);\r\nfirst->next = list;\r\nreturn first;\r\n}\r\nstruct reserve_info *add_reserve_entry(struct reserve_info *list,\r\nstruct reserve_info *new)\r\n{\r\nstruct reserve_info *last;\r\nnew->next = NULL;\r\nif (! list)\r\nreturn new;\r\nfor (last = list; last->next; last = last->next)\r\n;\r\nlast->next = new;\r\nreturn list;\r\n}\r\nstruct boot_info *build_boot_info(struct reserve_info *reservelist,\r\nstruct node *tree, uint32_t boot_cpuid_phys)\r\n{\r\nstruct boot_info *bi;\r\nbi = xmalloc(sizeof(*bi));\r\nbi->reservelist = reservelist;\r\nbi->dt = tree;\r\nbi->boot_cpuid_phys = boot_cpuid_phys;\r\nreturn bi;\r\n}\r\nconst char *get_unitname(struct node *node)\r\n{\r\nif (node->name[node->basenamelen] == '\0')\r\nreturn "";\r\nelse\r\nreturn node->name + node->basenamelen + 1;\r\n}\r\nstruct property *get_property(struct node *node, const char *propname)\r\n{\r\nstruct property *prop;\r\nfor_each_property(node, prop)\r\nif (streq(prop->name, propname))\r\nreturn prop;\r\nreturn NULL;\r\n}\r\ncell_t propval_cell(struct property *prop)\r\n{\r\nassert(prop->val.len == sizeof(cell_t));\r\nreturn fdt32_to_cpu(*((cell_t *)prop->val.val));\r\n}\r\nstruct property *get_property_by_label(struct node *tree, const char *label,\r\nstruct node **node)\r\n{\r\nstruct property *prop;\r\nstruct node *c;\r\n*node = tree;\r\nfor_each_property(tree, prop) {\r\nstruct label *l;\r\nfor_each_label(prop->labels, l)\r\nif (streq(l->label, label))\r\nreturn prop;\r\n}\r\nfor_each_child(tree, c) {\r\nprop = get_property_by_label(c, label, node);\r\nif (prop)\r\nreturn prop;\r\n}\r\n*node = NULL;\r\nreturn NULL;\r\n}\r\nstruct marker *get_marker_label(struct node *tree, const char *label,\r\nstruct node **node, struct property **prop)\r\n{\r\nstruct marker *m;\r\nstruct property *p;\r\nstruct node *c;\r\n*node = tree;\r\nfor_each_property(tree, p) {\r\n*prop = p;\r\nm = p->val.markers;\r\nfor_each_marker_of_type(m, LABEL)\r\nif (streq(m->ref, label))\r\nreturn m;\r\n}\r\nfor_each_child(tree, c) {\r\nm = get_marker_label(c, label, node, prop);\r\nif (m)\r\nreturn m;\r\n}\r\n*prop = NULL;\r\n*node = NULL;\r\nreturn NULL;\r\n}\r\nstruct node *get_subnode(struct node *node, const char *nodename)\r\n{\r\nstruct node *child;\r\nfor_each_child(node, child)\r\nif (streq(child->name, nodename))\r\nreturn child;\r\nreturn NULL;\r\n}\r\nstruct node *get_node_by_path(struct node *tree, const char *path)\r\n{\r\nconst char *p;\r\nstruct node *child;\r\nif (!path || ! (*path)) {\r\nif (tree->deleted)\r\nreturn NULL;\r\nreturn tree;\r\n}\r\nwhile (path[0] == '/')\r\npath++;\r\np = strchr(path, '/');\r\nfor_each_child(tree, child) {\r\nif (p && strneq(path, child->name, p-path))\r\nreturn get_node_by_path(child, p+1);\r\nelse if (!p && streq(path, child->name))\r\nreturn child;\r\n}\r\nreturn NULL;\r\n}\r\nstruct node *get_node_by_label(struct node *tree, const char *label)\r\n{\r\nstruct node *child, *node;\r\nstruct label *l;\r\nassert(label && (strlen(label) > 0));\r\nfor_each_label(tree->labels, l)\r\nif (streq(l->label, label))\r\nreturn tree;\r\nfor_each_child(tree, child) {\r\nnode = get_node_by_label(child, label);\r\nif (node)\r\nreturn node;\r\n}\r\nreturn NULL;\r\n}\r\nstruct node *get_node_by_phandle(struct node *tree, cell_t phandle)\r\n{\r\nstruct node *child, *node;\r\nassert((phandle != 0) && (phandle != -1));\r\nif (tree->phandle == phandle) {\r\nif (tree->deleted)\r\nreturn NULL;\r\nreturn tree;\r\n}\r\nfor_each_child(tree, child) {\r\nnode = get_node_by_phandle(child, phandle);\r\nif (node)\r\nreturn node;\r\n}\r\nreturn NULL;\r\n}\r\nstruct node *get_node_by_ref(struct node *tree, const char *ref)\r\n{\r\nif (streq(ref, "/"))\r\nreturn tree;\r\nelse if (ref[0] == '/')\r\nreturn get_node_by_path(tree, ref);\r\nelse\r\nreturn get_node_by_label(tree, ref);\r\n}\r\ncell_t get_node_phandle(struct node *root, struct node *node)\r\n{\r\nstatic cell_t phandle = 1;\r\nif ((node->phandle != 0) && (node->phandle != -1))\r\nreturn node->phandle;\r\nwhile (get_node_by_phandle(root, phandle))\r\nphandle++;\r\nnode->phandle = phandle;\r\nif (!get_property(node, "linux,phandle")\r\n&& (phandle_format & PHANDLE_LEGACY))\r\nadd_property(node,\r\nbuild_property("linux,phandle",\r\ndata_append_cell(empty_data, phandle)));\r\nif (!get_property(node, "phandle")\r\n&& (phandle_format & PHANDLE_EPAPR))\r\nadd_property(node,\r\nbuild_property("phandle",\r\ndata_append_cell(empty_data, phandle)));\r\nreturn node->phandle;\r\n}\r\nuint32_t guess_boot_cpuid(struct node *tree)\r\n{\r\nstruct node *cpus, *bootcpu;\r\nstruct property *reg;\r\ncpus = get_node_by_path(tree, "/cpus");\r\nif (!cpus)\r\nreturn 0;\r\nbootcpu = cpus->children;\r\nif (!bootcpu)\r\nreturn 0;\r\nreg = get_property(bootcpu, "reg");\r\nif (!reg || (reg->val.len != sizeof(uint32_t)))\r\nreturn 0;\r\nreturn propval_cell(reg);\r\n}\r\nstatic int cmp_reserve_info(const void *ax, const void *bx)\r\n{\r\nconst struct reserve_info *a, *b;\r\na = *((const struct reserve_info * const *)ax);\r\nb = *((const struct reserve_info * const *)bx);\r\nif (a->re.address < b->re.address)\r\nreturn -1;\r\nelse if (a->re.address > b->re.address)\r\nreturn 1;\r\nelse if (a->re.size < b->re.size)\r\nreturn -1;\r\nelse if (a->re.size > b->re.size)\r\nreturn 1;\r\nelse\r\nreturn 0;\r\n}\r\nstatic void sort_reserve_entries(struct boot_info *bi)\r\n{\r\nstruct reserve_info *ri, **tbl;\r\nint n = 0, i = 0;\r\nfor (ri = bi->reservelist;\r\nri;\r\nri = ri->next)\r\nn++;\r\nif (n == 0)\r\nreturn;\r\ntbl = xmalloc(n * sizeof(*tbl));\r\nfor (ri = bi->reservelist;\r\nri;\r\nri = ri->next)\r\ntbl[i++] = ri;\r\nqsort(tbl, n, sizeof(*tbl), cmp_reserve_info);\r\nbi->reservelist = tbl[0];\r\nfor (i = 0; i < (n-1); i++)\r\ntbl[i]->next = tbl[i+1];\r\ntbl[n-1]->next = NULL;\r\nfree(tbl);\r\n}\r\nstatic int cmp_prop(const void *ax, const void *bx)\r\n{\r\nconst struct property *a, *b;\r\na = *((const struct property * const *)ax);\r\nb = *((const struct property * const *)bx);\r\nreturn strcmp(a->name, b->name);\r\n}\r\nstatic void sort_properties(struct node *node)\r\n{\r\nint n = 0, i = 0;\r\nstruct property *prop, **tbl;\r\nfor_each_property_withdel(node, prop)\r\nn++;\r\nif (n == 0)\r\nreturn;\r\ntbl = xmalloc(n * sizeof(*tbl));\r\nfor_each_property_withdel(node, prop)\r\ntbl[i++] = prop;\r\nqsort(tbl, n, sizeof(*tbl), cmp_prop);\r\nnode->proplist = tbl[0];\r\nfor (i = 0; i < (n-1); i++)\r\ntbl[i]->next = tbl[i+1];\r\ntbl[n-1]->next = NULL;\r\nfree(tbl);\r\n}\r\nstatic int cmp_subnode(const void *ax, const void *bx)\r\n{\r\nconst struct node *a, *b;\r\na = *((const struct node * const *)ax);\r\nb = *((const struct node * const *)bx);\r\nreturn strcmp(a->name, b->name);\r\n}\r\nstatic void sort_subnodes(struct node *node)\r\n{\r\nint n = 0, i = 0;\r\nstruct node *subnode, **tbl;\r\nfor_each_child_withdel(node, subnode)\r\nn++;\r\nif (n == 0)\r\nreturn;\r\ntbl = xmalloc(n * sizeof(*tbl));\r\nfor_each_child_withdel(node, subnode)\r\ntbl[i++] = subnode;\r\nqsort(tbl, n, sizeof(*tbl), cmp_subnode);\r\nnode->children = tbl[0];\r\nfor (i = 0; i < (n-1); i++)\r\ntbl[i]->next_sibling = tbl[i+1];\r\ntbl[n-1]->next_sibling = NULL;\r\nfree(tbl);\r\n}\r\nstatic void sort_node(struct node *node)\r\n{\r\nstruct node *c;\r\nsort_properties(node);\r\nsort_subnodes(node);\r\nfor_each_child_withdel(node, c)\r\nsort_node(c);\r\n}\r\nvoid sort_tree(struct boot_info *bi)\r\n{\r\nsort_reserve_entries(bi);\r\nsort_node(bi->dt);\r\n}
