static inline int is_double_byte_mode(struct fsl_dspi *dspi)\r\n{\r\nunsigned int val;\r\nregmap_read(dspi->regmap, SPI_CTAR(0), &val);\r\nreturn ((val & SPI_FRAME_BITS_MASK) == SPI_FRAME_BITS(8)) ? 0 : 1;\r\n}\r\nstatic void hz_to_spi_baud(char *pbr, char *br, int speed_hz,\r\nunsigned long clkrate)\r\n{\r\nint pbr_tbl[4] = {2, 3, 5, 7};\r\nint brs[16] = { 2, 4, 6, 8,\r\n16, 32, 64, 128,\r\n256, 512, 1024, 2048,\r\n4096, 8192, 16384, 32768 };\r\nint scale_needed, scale, minscale = INT_MAX;\r\nint i, j;\r\nscale_needed = clkrate / speed_hz;\r\nif (clkrate % speed_hz)\r\nscale_needed++;\r\nfor (i = 0; i < ARRAY_SIZE(brs); i++)\r\nfor (j = 0; j < ARRAY_SIZE(pbr_tbl); j++) {\r\nscale = brs[i] * pbr_tbl[j];\r\nif (scale >= scale_needed) {\r\nif (scale < minscale) {\r\nminscale = scale;\r\n*br = i;\r\n*pbr = j;\r\n}\r\nbreak;\r\n}\r\n}\r\nif (minscale == INT_MAX) {\r\npr_warn("Can not find valid baud rate,speed_hz is %d,clkrate is %ld, we use the max prescaler value.\n",\r\nspeed_hz, clkrate);\r\n*pbr = ARRAY_SIZE(pbr_tbl) - 1;\r\n*br = ARRAY_SIZE(brs) - 1;\r\n}\r\n}\r\nstatic void ns_delay_scale(char *psc, char *sc, int delay_ns,\r\nunsigned long clkrate)\r\n{\r\nint pscale_tbl[4] = {1, 3, 5, 7};\r\nint scale_needed, scale, minscale = INT_MAX;\r\nint i, j;\r\nu32 remainder;\r\nscale_needed = div_u64_rem((u64)delay_ns * clkrate, NSEC_PER_SEC,\r\n&remainder);\r\nif (remainder)\r\nscale_needed++;\r\nfor (i = 0; i < ARRAY_SIZE(pscale_tbl); i++)\r\nfor (j = 0; j <= SPI_CTAR_SCALE_BITS; j++) {\r\nscale = pscale_tbl[i] * (2 << j);\r\nif (scale >= scale_needed) {\r\nif (scale < minscale) {\r\nminscale = scale;\r\n*psc = i;\r\n*sc = j;\r\n}\r\nbreak;\r\n}\r\n}\r\nif (minscale == INT_MAX) {\r\npr_warn("Cannot find correct scale values for %dns delay at clkrate %ld, using max prescaler value",\r\ndelay_ns, clkrate);\r\n*psc = ARRAY_SIZE(pscale_tbl) - 1;\r\n*sc = SPI_CTAR_SCALE_BITS;\r\n}\r\n}\r\nstatic u32 dspi_data_to_pushr(struct fsl_dspi *dspi, int tx_word)\r\n{\r\nu16 d16;\r\nif (!(dspi->dataflags & TRAN_STATE_TX_VOID))\r\nd16 = tx_word ? *(u16 *)dspi->tx : *(u8 *)dspi->tx;\r\nelse\r\nd16 = dspi->void_write_data;\r\ndspi->tx += tx_word + 1;\r\ndspi->len -= tx_word + 1;\r\nreturn SPI_PUSHR_TXDATA(d16) |\r\nSPI_PUSHR_PCS(dspi->cs) |\r\nSPI_PUSHR_CTAS(0) |\r\nSPI_PUSHR_CONT;\r\n}\r\nstatic void dspi_data_from_popr(struct fsl_dspi *dspi, int rx_word)\r\n{\r\nu16 d;\r\nunsigned int val;\r\nregmap_read(dspi->regmap, SPI_POPR, &val);\r\nd = SPI_POPR_RXDATA(val);\r\nif (!(dspi->dataflags & TRAN_STATE_RX_VOID))\r\nrx_word ? (*(u16 *)dspi->rx = d) : (*(u8 *)dspi->rx = d);\r\ndspi->rx += rx_word + 1;\r\n}\r\nstatic int dspi_eoq_write(struct fsl_dspi *dspi)\r\n{\r\nint tx_count = 0;\r\nint tx_word;\r\nu32 dspi_pushr = 0;\r\ntx_word = is_double_byte_mode(dspi);\r\nwhile (dspi->len && (tx_count < DSPI_FIFO_SIZE)) {\r\nif (tx_word && (dspi->len == 1)) {\r\ndspi->dataflags |= TRAN_STATE_WORD_ODD_NUM;\r\nregmap_update_bits(dspi->regmap, SPI_CTAR(0),\r\nSPI_FRAME_BITS_MASK, SPI_FRAME_BITS(8));\r\ntx_word = 0;\r\n}\r\ndspi_pushr = dspi_data_to_pushr(dspi, tx_word);\r\nif (dspi->len == 0 || tx_count == DSPI_FIFO_SIZE - 1) {\r\ndspi_pushr |= SPI_PUSHR_EOQ;\r\nif ((dspi->cs_change) && (!dspi->len))\r\ndspi_pushr &= ~SPI_PUSHR_CONT;\r\n} else if (tx_word && (dspi->len == 1))\r\ndspi_pushr |= SPI_PUSHR_EOQ;\r\nregmap_write(dspi->regmap, SPI_PUSHR, dspi_pushr);\r\ntx_count++;\r\n}\r\nreturn tx_count * (tx_word + 1);\r\n}\r\nstatic int dspi_eoq_read(struct fsl_dspi *dspi)\r\n{\r\nint rx_count = 0;\r\nint rx_word = is_double_byte_mode(dspi);\r\nwhile ((dspi->rx < dspi->rx_end)\r\n&& (rx_count < DSPI_FIFO_SIZE)) {\r\nif (rx_word && (dspi->rx_end - dspi->rx) == 1)\r\nrx_word = 0;\r\ndspi_data_from_popr(dspi, rx_word);\r\nrx_count++;\r\n}\r\nreturn rx_count;\r\n}\r\nstatic int dspi_tcfq_write(struct fsl_dspi *dspi)\r\n{\r\nint tx_word;\r\nu32 dspi_pushr = 0;\r\ntx_word = is_double_byte_mode(dspi);\r\nif (tx_word && (dspi->len == 1)) {\r\ndspi->dataflags |= TRAN_STATE_WORD_ODD_NUM;\r\nregmap_update_bits(dspi->regmap, SPI_CTAR(0),\r\nSPI_FRAME_BITS_MASK, SPI_FRAME_BITS(8));\r\ntx_word = 0;\r\n}\r\ndspi_pushr = dspi_data_to_pushr(dspi, tx_word);\r\nif ((dspi->cs_change) && (!dspi->len))\r\ndspi_pushr &= ~SPI_PUSHR_CONT;\r\nregmap_write(dspi->regmap, SPI_PUSHR, dspi_pushr);\r\nreturn tx_word + 1;\r\n}\r\nstatic void dspi_tcfq_read(struct fsl_dspi *dspi)\r\n{\r\nint rx_word = is_double_byte_mode(dspi);\r\nif (rx_word && (dspi->rx_end - dspi->rx) == 1)\r\nrx_word = 0;\r\ndspi_data_from_popr(dspi, rx_word);\r\n}\r\nstatic int dspi_transfer_one_message(struct spi_master *master,\r\nstruct spi_message *message)\r\n{\r\nstruct fsl_dspi *dspi = spi_master_get_devdata(master);\r\nstruct spi_device *spi = message->spi;\r\nstruct spi_transfer *transfer;\r\nint status = 0;\r\nenum dspi_trans_mode trans_mode;\r\nu32 spi_tcr;\r\nregmap_read(dspi->regmap, SPI_TCR, &spi_tcr);\r\ndspi->spi_tcnt = SPI_TCR_GET_TCNT(spi_tcr);\r\nmessage->actual_length = 0;\r\nlist_for_each_entry(transfer, &message->transfers, transfer_list) {\r\ndspi->cur_transfer = transfer;\r\ndspi->cur_msg = message;\r\ndspi->cur_chip = spi_get_ctldata(spi);\r\ndspi->cs = spi->chip_select;\r\ndspi->cs_change = 0;\r\nif (dspi->cur_transfer->transfer_list.next\r\n== &dspi->cur_msg->transfers)\r\ndspi->cs_change = 1;\r\ndspi->void_write_data = dspi->cur_chip->void_write_data;\r\ndspi->dataflags = 0;\r\ndspi->tx = (void *)transfer->tx_buf;\r\ndspi->tx_end = dspi->tx + transfer->len;\r\ndspi->rx = transfer->rx_buf;\r\ndspi->rx_end = dspi->rx + transfer->len;\r\ndspi->len = transfer->len;\r\nif (!dspi->rx)\r\ndspi->dataflags |= TRAN_STATE_RX_VOID;\r\nif (!dspi->tx)\r\ndspi->dataflags |= TRAN_STATE_TX_VOID;\r\nregmap_write(dspi->regmap, SPI_MCR, dspi->cur_chip->mcr_val);\r\nregmap_update_bits(dspi->regmap, SPI_MCR,\r\nSPI_MCR_CLR_TXF | SPI_MCR_CLR_RXF,\r\nSPI_MCR_CLR_TXF | SPI_MCR_CLR_RXF);\r\nregmap_write(dspi->regmap, SPI_CTAR(0),\r\ndspi->cur_chip->ctar_val);\r\ntrans_mode = dspi->devtype_data->trans_mode;\r\nswitch (trans_mode) {\r\ncase DSPI_EOQ_MODE:\r\nregmap_write(dspi->regmap, SPI_RSER, SPI_RSER_EOQFE);\r\ndspi_eoq_write(dspi);\r\nbreak;\r\ncase DSPI_TCFQ_MODE:\r\nregmap_write(dspi->regmap, SPI_RSER, SPI_RSER_TCFQE);\r\ndspi_tcfq_write(dspi);\r\nbreak;\r\ndefault:\r\ndev_err(&dspi->pdev->dev, "unsupported trans_mode %u\n",\r\ntrans_mode);\r\nstatus = -EINVAL;\r\ngoto out;\r\n}\r\nif (wait_event_interruptible(dspi->waitq, dspi->waitflags))\r\ndev_err(&dspi->pdev->dev, "wait transfer complete fail!\n");\r\ndspi->waitflags = 0;\r\nif (transfer->delay_usecs)\r\nudelay(transfer->delay_usecs);\r\n}\r\nout:\r\nmessage->status = status;\r\nspi_finalize_current_message(master);\r\nreturn status;\r\n}\r\nstatic int dspi_setup(struct spi_device *spi)\r\n{\r\nstruct chip_data *chip;\r\nstruct fsl_dspi *dspi = spi_master_get_devdata(spi->master);\r\nu32 cs_sck_delay = 0, sck_cs_delay = 0;\r\nunsigned char br = 0, pbr = 0, pcssck = 0, cssck = 0;\r\nunsigned char pasc = 0, asc = 0, fmsz = 0;\r\nunsigned long clkrate;\r\nif ((spi->bits_per_word >= 4) && (spi->bits_per_word <= 16)) {\r\nfmsz = spi->bits_per_word - 1;\r\n} else {\r\npr_err("Invalid wordsize\n");\r\nreturn -ENODEV;\r\n}\r\nchip = spi_get_ctldata(spi);\r\nif (chip == NULL) {\r\nchip = kzalloc(sizeof(struct chip_data), GFP_KERNEL);\r\nif (!chip)\r\nreturn -ENOMEM;\r\n}\r\nof_property_read_u32(spi->dev.of_node, "fsl,spi-cs-sck-delay",\r\n&cs_sck_delay);\r\nof_property_read_u32(spi->dev.of_node, "fsl,spi-sck-cs-delay",\r\n&sck_cs_delay);\r\nchip->mcr_val = SPI_MCR_MASTER | SPI_MCR_PCSIS |\r\nSPI_MCR_CLR_TXF | SPI_MCR_CLR_RXF;\r\nchip->void_write_data = 0;\r\nclkrate = clk_get_rate(dspi->clk);\r\nhz_to_spi_baud(&pbr, &br, spi->max_speed_hz, clkrate);\r\nns_delay_scale(&pcssck, &cssck, cs_sck_delay, clkrate);\r\nns_delay_scale(&pasc, &asc, sck_cs_delay, clkrate);\r\nchip->ctar_val = SPI_CTAR_FMSZ(fmsz)\r\n| SPI_CTAR_CPOL(spi->mode & SPI_CPOL ? 1 : 0)\r\n| SPI_CTAR_CPHA(spi->mode & SPI_CPHA ? 1 : 0)\r\n| SPI_CTAR_LSBFE(spi->mode & SPI_LSB_FIRST ? 1 : 0)\r\n| SPI_CTAR_PCSSCK(pcssck)\r\n| SPI_CTAR_CSSCK(cssck)\r\n| SPI_CTAR_PASC(pasc)\r\n| SPI_CTAR_ASC(asc)\r\n| SPI_CTAR_PBR(pbr)\r\n| SPI_CTAR_BR(br);\r\nspi_set_ctldata(spi, chip);\r\nreturn 0;\r\n}\r\nstatic void dspi_cleanup(struct spi_device *spi)\r\n{\r\nstruct chip_data *chip = spi_get_ctldata((struct spi_device *)spi);\r\ndev_dbg(&spi->dev, "spi_device %u.%u cleanup\n",\r\nspi->master->bus_num, spi->chip_select);\r\nkfree(chip);\r\n}\r\nstatic irqreturn_t dspi_interrupt(int irq, void *dev_id)\r\n{\r\nstruct fsl_dspi *dspi = (struct fsl_dspi *)dev_id;\r\nstruct spi_message *msg = dspi->cur_msg;\r\nenum dspi_trans_mode trans_mode;\r\nu32 spi_sr, spi_tcr;\r\nu32 spi_tcnt, tcnt_diff;\r\nint tx_word;\r\nregmap_read(dspi->regmap, SPI_SR, &spi_sr);\r\nregmap_write(dspi->regmap, SPI_SR, spi_sr);\r\nif (spi_sr & (SPI_SR_EOQF | SPI_SR_TCFQF)) {\r\ntx_word = is_double_byte_mode(dspi);\r\nregmap_read(dspi->regmap, SPI_TCR, &spi_tcr);\r\nspi_tcnt = SPI_TCR_GET_TCNT(spi_tcr);\r\ntcnt_diff = ((spi_tcnt + SPI_TCR_TCNT_MAX) - dspi->spi_tcnt)\r\n% SPI_TCR_TCNT_MAX;\r\ntcnt_diff *= (tx_word + 1);\r\nif (dspi->dataflags & TRAN_STATE_WORD_ODD_NUM)\r\ntcnt_diff--;\r\nmsg->actual_length += tcnt_diff;\r\ndspi->spi_tcnt = spi_tcnt;\r\ntrans_mode = dspi->devtype_data->trans_mode;\r\nswitch (trans_mode) {\r\ncase DSPI_EOQ_MODE:\r\ndspi_eoq_read(dspi);\r\nbreak;\r\ncase DSPI_TCFQ_MODE:\r\ndspi_tcfq_read(dspi);\r\nbreak;\r\ndefault:\r\ndev_err(&dspi->pdev->dev, "unsupported trans_mode %u\n",\r\ntrans_mode);\r\nreturn IRQ_HANDLED;\r\n}\r\nif (!dspi->len) {\r\nif (dspi->dataflags & TRAN_STATE_WORD_ODD_NUM) {\r\nregmap_update_bits(dspi->regmap,\r\nSPI_CTAR(0),\r\nSPI_FRAME_BITS_MASK,\r\nSPI_FRAME_BITS(16));\r\ndspi->dataflags &= ~TRAN_STATE_WORD_ODD_NUM;\r\n}\r\ndspi->waitflags = 1;\r\nwake_up_interruptible(&dspi->waitq);\r\n} else {\r\nswitch (trans_mode) {\r\ncase DSPI_EOQ_MODE:\r\ndspi_eoq_write(dspi);\r\nbreak;\r\ncase DSPI_TCFQ_MODE:\r\ndspi_tcfq_write(dspi);\r\nbreak;\r\ndefault:\r\ndev_err(&dspi->pdev->dev,\r\n"unsupported trans_mode %u\n",\r\ntrans_mode);\r\n}\r\n}\r\n}\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int dspi_suspend(struct device *dev)\r\n{\r\nstruct spi_master *master = dev_get_drvdata(dev);\r\nstruct fsl_dspi *dspi = spi_master_get_devdata(master);\r\nspi_master_suspend(master);\r\nclk_disable_unprepare(dspi->clk);\r\npinctrl_pm_select_sleep_state(dev);\r\nreturn 0;\r\n}\r\nstatic int dspi_resume(struct device *dev)\r\n{\r\nstruct spi_master *master = dev_get_drvdata(dev);\r\nstruct fsl_dspi *dspi = spi_master_get_devdata(master);\r\npinctrl_pm_select_default_state(dev);\r\nclk_prepare_enable(dspi->clk);\r\nspi_master_resume(master);\r\nreturn 0;\r\n}\r\nstatic int dspi_probe(struct platform_device *pdev)\r\n{\r\nstruct device_node *np = pdev->dev.of_node;\r\nstruct spi_master *master;\r\nstruct fsl_dspi *dspi;\r\nstruct resource *res;\r\nvoid __iomem *base;\r\nint ret = 0, cs_num, bus_num;\r\nconst struct of_device_id *of_id =\r\nof_match_device(fsl_dspi_dt_ids, &pdev->dev);\r\nmaster = spi_alloc_master(&pdev->dev, sizeof(struct fsl_dspi));\r\nif (!master)\r\nreturn -ENOMEM;\r\ndspi = spi_master_get_devdata(master);\r\ndspi->pdev = pdev;\r\ndspi->master = master;\r\nmaster->transfer = NULL;\r\nmaster->setup = dspi_setup;\r\nmaster->transfer_one_message = dspi_transfer_one_message;\r\nmaster->dev.of_node = pdev->dev.of_node;\r\nmaster->cleanup = dspi_cleanup;\r\nmaster->mode_bits = SPI_CPOL | SPI_CPHA;\r\nmaster->bits_per_word_mask = SPI_BPW_MASK(4) | SPI_BPW_MASK(8) |\r\nSPI_BPW_MASK(16);\r\nret = of_property_read_u32(np, "spi-num-chipselects", &cs_num);\r\nif (ret < 0) {\r\ndev_err(&pdev->dev, "can't get spi-num-chipselects\n");\r\ngoto out_master_put;\r\n}\r\nmaster->num_chipselect = cs_num;\r\nret = of_property_read_u32(np, "bus-num", &bus_num);\r\nif (ret < 0) {\r\ndev_err(&pdev->dev, "can't get bus-num\n");\r\ngoto out_master_put;\r\n}\r\nmaster->bus_num = bus_num;\r\ndspi->devtype_data = (struct fsl_dspi_devtype_data *)of_id->data;\r\nif (!dspi->devtype_data) {\r\ndev_err(&pdev->dev, "can't get devtype_data\n");\r\nret = -EFAULT;\r\ngoto out_master_put;\r\n}\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nbase = devm_ioremap_resource(&pdev->dev, res);\r\nif (IS_ERR(base)) {\r\nret = PTR_ERR(base);\r\ngoto out_master_put;\r\n}\r\ndspi->regmap = devm_regmap_init_mmio_clk(&pdev->dev, NULL, base,\r\n&dspi_regmap_config);\r\nif (IS_ERR(dspi->regmap)) {\r\ndev_err(&pdev->dev, "failed to init regmap: %ld\n",\r\nPTR_ERR(dspi->regmap));\r\nreturn PTR_ERR(dspi->regmap);\r\n}\r\ndspi->irq = platform_get_irq(pdev, 0);\r\nif (dspi->irq < 0) {\r\ndev_err(&pdev->dev, "can't get platform irq\n");\r\nret = dspi->irq;\r\ngoto out_master_put;\r\n}\r\nret = devm_request_irq(&pdev->dev, dspi->irq, dspi_interrupt, 0,\r\npdev->name, dspi);\r\nif (ret < 0) {\r\ndev_err(&pdev->dev, "Unable to attach DSPI interrupt\n");\r\ngoto out_master_put;\r\n}\r\ndspi->clk = devm_clk_get(&pdev->dev, "dspi");\r\nif (IS_ERR(dspi->clk)) {\r\nret = PTR_ERR(dspi->clk);\r\ndev_err(&pdev->dev, "unable to get clock\n");\r\ngoto out_master_put;\r\n}\r\nclk_prepare_enable(dspi->clk);\r\ninit_waitqueue_head(&dspi->waitq);\r\nplatform_set_drvdata(pdev, master);\r\nret = spi_register_master(master);\r\nif (ret != 0) {\r\ndev_err(&pdev->dev, "Problem registering DSPI master\n");\r\ngoto out_clk_put;\r\n}\r\nreturn ret;\r\nout_clk_put:\r\nclk_disable_unprepare(dspi->clk);\r\nout_master_put:\r\nspi_master_put(master);\r\nreturn ret;\r\n}\r\nstatic int dspi_remove(struct platform_device *pdev)\r\n{\r\nstruct spi_master *master = platform_get_drvdata(pdev);\r\nstruct fsl_dspi *dspi = spi_master_get_devdata(master);\r\nclk_disable_unprepare(dspi->clk);\r\nspi_unregister_master(dspi->master);\r\nspi_master_put(dspi->master);\r\nreturn 0;\r\n}
