int enic_is_valid_pp_vf(struct enic *enic, int vf, int *err)\r\n{\r\nif (vf != PORT_SELF_VF) {\r\n#ifdef CONFIG_PCI_IOV\r\nif (enic_sriov_enabled(enic)) {\r\nif (vf < 0 || vf >= enic->num_vfs) {\r\n*err = -EINVAL;\r\ngoto err_out;\r\n}\r\n} else {\r\n*err = -EOPNOTSUPP;\r\ngoto err_out;\r\n}\r\n#else\r\n*err = -EOPNOTSUPP;\r\ngoto err_out;\r\n#endif\r\n}\r\nif (vf == PORT_SELF_VF && !enic_is_dynamic(enic)) {\r\n*err = -EOPNOTSUPP;\r\ngoto err_out;\r\n}\r\n*err = 0;\r\nreturn 1;\r\nerr_out:\r\nreturn 0;\r\n}\r\nstatic int enic_set_port_profile(struct enic *enic, int vf)\r\n{\r\nstruct net_device *netdev = enic->netdev;\r\nstruct enic_port_profile *pp;\r\nstruct vic_provinfo *vp;\r\nconst u8 oui[3] = VIC_PROVINFO_CISCO_OUI;\r\nconst __be16 os_type = htons(VIC_GENERIC_PROV_OS_TYPE_LINUX);\r\nchar uuid_str[38];\r\nchar client_mac_str[18];\r\nu8 *client_mac;\r\nint err;\r\nENIC_PP_BY_INDEX(enic, vf, pp, &err);\r\nif (err)\r\nreturn err;\r\nif (!(pp->set & ENIC_SET_NAME) || !strlen(pp->name))\r\nreturn -EINVAL;\r\nvp = vic_provinfo_alloc(GFP_KERNEL, oui,\r\nVIC_PROVINFO_GENERIC_TYPE);\r\nif (!vp)\r\nreturn -ENOMEM;\r\nVIC_PROVINFO_ADD_TLV(vp,\r\nVIC_GENERIC_PROV_TLV_PORT_PROFILE_NAME_STR,\r\nstrlen(pp->name) + 1, pp->name);\r\nif (!is_zero_ether_addr(pp->mac_addr)) {\r\nclient_mac = pp->mac_addr;\r\n} else if (vf == PORT_SELF_VF) {\r\nclient_mac = netdev->dev_addr;\r\n} else {\r\nnetdev_err(netdev, "Cannot find pp mac address "\r\n"for VF %d\n", vf);\r\nerr = -EINVAL;\r\ngoto add_tlv_failure;\r\n}\r\nVIC_PROVINFO_ADD_TLV(vp,\r\nVIC_GENERIC_PROV_TLV_CLIENT_MAC_ADDR,\r\nETH_ALEN, client_mac);\r\nsnprintf(client_mac_str, sizeof(client_mac_str), "%pM", client_mac);\r\nVIC_PROVINFO_ADD_TLV(vp,\r\nVIC_GENERIC_PROV_TLV_CLUSTER_PORT_UUID_STR,\r\nsizeof(client_mac_str), client_mac_str);\r\nif (pp->set & ENIC_SET_INSTANCE) {\r\nsprintf(uuid_str, "%pUB", pp->instance_uuid);\r\nVIC_PROVINFO_ADD_TLV(vp,\r\nVIC_GENERIC_PROV_TLV_CLIENT_UUID_STR,\r\nsizeof(uuid_str), uuid_str);\r\n}\r\nif (pp->set & ENIC_SET_HOST) {\r\nsprintf(uuid_str, "%pUB", pp->host_uuid);\r\nVIC_PROVINFO_ADD_TLV(vp,\r\nVIC_GENERIC_PROV_TLV_HOST_UUID_STR,\r\nsizeof(uuid_str), uuid_str);\r\n}\r\nVIC_PROVINFO_ADD_TLV(vp,\r\nVIC_GENERIC_PROV_TLV_OS_TYPE,\r\nsizeof(os_type), &os_type);\r\nENIC_DEVCMD_PROXY_BY_INDEX(vf, err, enic, vnic_dev_init_prov2, (u8 *)vp,\r\nvic_provinfo_size(vp));\r\nerr = enic_dev_status_to_errno(err);\r\nadd_tlv_failure:\r\nvic_provinfo_free(vp);\r\nreturn err;\r\n}\r\nstatic int enic_unset_port_profile(struct enic *enic, int vf)\r\n{\r\nint err;\r\nENIC_DEVCMD_PROXY_BY_INDEX(vf, err, enic, vnic_dev_deinit);\r\nif (err)\r\nreturn enic_dev_status_to_errno(err);\r\nif (vf == PORT_SELF_VF)\r\nenic_reset_addr_lists(enic);\r\nreturn 0;\r\n}\r\nstatic int enic_are_pp_different(struct enic_port_profile *pp1,\r\nstruct enic_port_profile *pp2)\r\n{\r\nreturn strcmp(pp1->name, pp2->name) | !!memcmp(pp1->instance_uuid,\r\npp2->instance_uuid, PORT_UUID_MAX) |\r\n!!memcmp(pp1->host_uuid, pp2->host_uuid, PORT_UUID_MAX) |\r\n!ether_addr_equal(pp1->mac_addr, pp2->mac_addr);\r\n}\r\nstatic int enic_pp_preassociate(struct enic *enic, int vf,\r\nstruct enic_port_profile *prev_pp, int *restore_pp)\r\n{\r\nreturn -EOPNOTSUPP;\r\n}\r\nstatic int enic_pp_disassociate(struct enic *enic, int vf,\r\nstruct enic_port_profile *prev_pp, int *restore_pp)\r\n{\r\nstruct net_device *netdev = enic->netdev;\r\nstruct enic_port_profile *pp;\r\nint err;\r\nENIC_PP_BY_INDEX(enic, vf, pp, &err);\r\nif (err)\r\nreturn err;\r\nif (!is_zero_ether_addr(pp->mac_addr))\r\nENIC_DEVCMD_PROXY_BY_INDEX(vf, err, enic, vnic_dev_del_addr,\r\npp->mac_addr);\r\nelse if (vf == PORT_SELF_VF && !is_zero_ether_addr(netdev->dev_addr))\r\nENIC_DEVCMD_PROXY_BY_INDEX(vf, err, enic, vnic_dev_del_addr,\r\nnetdev->dev_addr);\r\nreturn enic_unset_port_profile(enic, vf);\r\n}\r\nstatic int enic_pp_preassociate_rr(struct enic *enic, int vf,\r\nstruct enic_port_profile *prev_pp, int *restore_pp)\r\n{\r\nstruct enic_port_profile *pp;\r\nint err;\r\nint active = 0;\r\nENIC_PP_BY_INDEX(enic, vf, pp, &err);\r\nif (err)\r\nreturn err;\r\nif (pp->request != PORT_REQUEST_ASSOCIATE) {\r\nerr = enic_pp_handlers[PORT_REQUEST_DISASSOCIATE](enic, vf,\r\nprev_pp, restore_pp);\r\nif (err)\r\nreturn err;\r\n*restore_pp = 0;\r\n}\r\n*restore_pp = 0;\r\nerr = enic_set_port_profile(enic, vf);\r\nif (err)\r\nreturn err;\r\nif (pp->request != PORT_REQUEST_ASSOCIATE) {\r\nENIC_DEVCMD_PROXY_BY_INDEX(vf, err, enic, vnic_dev_enable2,\r\nactive);\r\nerr = enic_dev_status_to_errno(err);\r\n}\r\nreturn err;\r\n}\r\nstatic int enic_pp_associate(struct enic *enic, int vf,\r\nstruct enic_port_profile *prev_pp, int *restore_pp)\r\n{\r\nstruct net_device *netdev = enic->netdev;\r\nstruct enic_port_profile *pp;\r\nint err;\r\nint active = 1;\r\nENIC_PP_BY_INDEX(enic, vf, pp, &err);\r\nif (err)\r\nreturn err;\r\nif (prev_pp->request != PORT_REQUEST_PREASSOCIATE_RR ||\r\n(prev_pp->request == PORT_REQUEST_PREASSOCIATE_RR &&\r\nenic_are_pp_different(prev_pp, pp))) {\r\nerr = enic_pp_handlers[PORT_REQUEST_DISASSOCIATE](\r\nenic, vf, prev_pp, restore_pp);\r\nif (err)\r\nreturn err;\r\n*restore_pp = 0;\r\n}\r\nerr = enic_pp_handlers[PORT_REQUEST_PREASSOCIATE_RR](\r\nenic, vf, prev_pp, restore_pp);\r\nif (err)\r\nreturn err;\r\n*restore_pp = 0;\r\nENIC_DEVCMD_PROXY_BY_INDEX(vf, err, enic, vnic_dev_enable2, active);\r\nerr = enic_dev_status_to_errno(err);\r\nif (err)\r\nreturn err;\r\nif (!is_zero_ether_addr(pp->mac_addr))\r\nENIC_DEVCMD_PROXY_BY_INDEX(vf, err, enic, vnic_dev_add_addr,\r\npp->mac_addr);\r\nelse if (vf == PORT_SELF_VF && !is_zero_ether_addr(netdev->dev_addr))\r\nENIC_DEVCMD_PROXY_BY_INDEX(vf, err, enic, vnic_dev_add_addr,\r\nnetdev->dev_addr);\r\nreturn 0;\r\n}\r\nint enic_process_set_pp_request(struct enic *enic, int vf,\r\nstruct enic_port_profile *prev_pp, int *restore_pp)\r\n{\r\nstruct enic_port_profile *pp;\r\nint err;\r\nENIC_PP_BY_INDEX(enic, vf, pp, &err);\r\nif (err)\r\nreturn err;\r\nif (pp->request >= enic_pp_handlers_count\r\n|| !enic_pp_handlers[pp->request])\r\nreturn -EOPNOTSUPP;\r\nreturn enic_pp_handlers[pp->request](enic, vf, prev_pp, restore_pp);\r\n}\r\nint enic_process_get_pp_request(struct enic *enic, int vf,\r\nint request, u16 *response)\r\n{\r\nint err, status = ERR_SUCCESS;\r\nswitch (request) {\r\ncase PORT_REQUEST_PREASSOCIATE_RR:\r\ncase PORT_REQUEST_ASSOCIATE:\r\nENIC_DEVCMD_PROXY_BY_INDEX(vf, err, enic,\r\nvnic_dev_enable2_done, &status);\r\nbreak;\r\ncase PORT_REQUEST_DISASSOCIATE:\r\nENIC_DEVCMD_PROXY_BY_INDEX(vf, err, enic,\r\nvnic_dev_deinit_done, &status);\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nif (err)\r\nstatus = err;\r\nswitch (status) {\r\ncase ERR_SUCCESS:\r\n*response = PORT_PROFILE_RESPONSE_SUCCESS;\r\nbreak;\r\ncase ERR_EINVAL:\r\n*response = PORT_PROFILE_RESPONSE_INVALID;\r\nbreak;\r\ncase ERR_EBADSTATE:\r\n*response = PORT_PROFILE_RESPONSE_BADSTATE;\r\nbreak;\r\ncase ERR_ENOMEM:\r\n*response = PORT_PROFILE_RESPONSE_INSUFFICIENT_RESOURCES;\r\nbreak;\r\ncase ERR_EINPROGRESS:\r\n*response = PORT_PROFILE_RESPONSE_INPROGRESS;\r\nbreak;\r\ndefault:\r\n*response = PORT_PROFILE_RESPONSE_ERROR;\r\nbreak;\r\n}\r\nreturn 0;\r\n}
