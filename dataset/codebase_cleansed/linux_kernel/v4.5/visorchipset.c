static int\r\nvisorchipset_open(struct inode *inode, struct file *file)\r\n{\r\nunsigned minor_number = iminor(inode);\r\nif (minor_number)\r\nreturn -ENODEV;\r\nfile->private_data = NULL;\r\nreturn 0;\r\n}\r\nstatic int\r\nvisorchipset_release(struct inode *inode, struct file *file)\r\n{\r\nreturn 0;\r\n}\r\nstatic void visorchipset_dev_release(struct device *dev)\r\n{\r\n}\r\nstatic struct parser_context *\r\nparser_init_byte_stream(u64 addr, u32 bytes, bool local, bool *retry)\r\n{\r\nint allocbytes = sizeof(struct parser_context) + bytes;\r\nstruct parser_context *rc = NULL;\r\nstruct parser_context *ctx = NULL;\r\nif (retry)\r\n*retry = false;\r\nallocbytes++;\r\nif ((controlvm_payload_bytes_buffered + bytes)\r\n> MAX_CONTROLVM_PAYLOAD_BYTES) {\r\nif (retry)\r\n*retry = true;\r\nrc = NULL;\r\ngoto cleanup;\r\n}\r\nctx = kzalloc(allocbytes, GFP_KERNEL|__GFP_NORETRY);\r\nif (!ctx) {\r\nif (retry)\r\n*retry = true;\r\nrc = NULL;\r\ngoto cleanup;\r\n}\r\nctx->allocbytes = allocbytes;\r\nctx->param_bytes = bytes;\r\nctx->curr = NULL;\r\nctx->bytes_remaining = 0;\r\nctx->byte_stream = false;\r\nif (local) {\r\nvoid *p;\r\nif (addr > virt_to_phys(high_memory - 1)) {\r\nrc = NULL;\r\ngoto cleanup;\r\n}\r\np = __va((unsigned long) (addr));\r\nmemcpy(ctx->data, p, bytes);\r\n} else {\r\nvoid *mapping;\r\nif (!request_mem_region(addr, bytes, "visorchipset")) {\r\nrc = NULL;\r\ngoto cleanup;\r\n}\r\nmapping = memremap(addr, bytes, MEMREMAP_WB);\r\nif (!mapping) {\r\nrelease_mem_region(addr, bytes);\r\nrc = NULL;\r\ngoto cleanup;\r\n}\r\nmemcpy(ctx->data, mapping, bytes);\r\nrelease_mem_region(addr, bytes);\r\nmemunmap(mapping);\r\n}\r\nctx->byte_stream = true;\r\nrc = ctx;\r\ncleanup:\r\nif (rc) {\r\ncontrolvm_payload_bytes_buffered += ctx->param_bytes;\r\n} else {\r\nif (ctx) {\r\nparser_done(ctx);\r\nctx = NULL;\r\n}\r\n}\r\nreturn rc;\r\n}\r\nstatic uuid_le\r\nparser_id_get(struct parser_context *ctx)\r\n{\r\nstruct spar_controlvm_parameters_header *phdr = NULL;\r\nif (ctx == NULL)\r\nreturn NULL_UUID_LE;\r\nphdr = (struct spar_controlvm_parameters_header *)(ctx->data);\r\nreturn phdr->id;\r\n}\r\nstatic void\r\nparser_param_start(struct parser_context *ctx,\r\nenum PARSER_WHICH_STRING which_string)\r\n{\r\nstruct spar_controlvm_parameters_header *phdr = NULL;\r\nif (ctx == NULL)\r\ngoto Away;\r\nphdr = (struct spar_controlvm_parameters_header *)(ctx->data);\r\nswitch (which_string) {\r\ncase PARSERSTRING_INITIATOR:\r\nctx->curr = ctx->data + phdr->initiator_offset;\r\nctx->bytes_remaining = phdr->initiator_length;\r\nbreak;\r\ncase PARSERSTRING_TARGET:\r\nctx->curr = ctx->data + phdr->target_offset;\r\nctx->bytes_remaining = phdr->target_length;\r\nbreak;\r\ncase PARSERSTRING_CONNECTION:\r\nctx->curr = ctx->data + phdr->connection_offset;\r\nctx->bytes_remaining = phdr->connection_length;\r\nbreak;\r\ncase PARSERSTRING_NAME:\r\nctx->curr = ctx->data + phdr->name_offset;\r\nctx->bytes_remaining = phdr->name_length;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nAway:\r\nreturn;\r\n}\r\nstatic void parser_done(struct parser_context *ctx)\r\n{\r\nif (!ctx)\r\nreturn;\r\ncontrolvm_payload_bytes_buffered -= ctx->param_bytes;\r\nkfree(ctx);\r\n}\r\nstatic void *\r\nparser_string_get(struct parser_context *ctx)\r\n{\r\nu8 *pscan;\r\nunsigned long nscan;\r\nint value_length = -1;\r\nvoid *value = NULL;\r\nint i;\r\nif (!ctx)\r\nreturn NULL;\r\npscan = ctx->curr;\r\nnscan = ctx->bytes_remaining;\r\nif (nscan == 0)\r\nreturn NULL;\r\nif (!pscan)\r\nreturn NULL;\r\nfor (i = 0, value_length = -1; i < nscan; i++)\r\nif (pscan[i] == '\0') {\r\nvalue_length = i;\r\nbreak;\r\n}\r\nif (value_length < 0)\r\nvalue_length = nscan;\r\nvalue = kmalloc(value_length + 1, GFP_KERNEL|__GFP_NORETRY);\r\nif (value == NULL)\r\nreturn NULL;\r\nif (value_length > 0)\r\nmemcpy(value, pscan, value_length);\r\n((u8 *) (value))[value_length] = '\0';\r\nreturn value;\r\n}\r\nstatic ssize_t toolaction_show(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nu8 tool_action;\r\nvisorchannel_read(controlvm_channel,\r\noffsetof(struct spar_controlvm_channel_protocol,\r\ntool_action), &tool_action, sizeof(u8));\r\nreturn scnprintf(buf, PAGE_SIZE, "%u\n", tool_action);\r\n}\r\nstatic ssize_t toolaction_store(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nu8 tool_action;\r\nint ret;\r\nif (kstrtou8(buf, 10, &tool_action))\r\nreturn -EINVAL;\r\nret = visorchannel_write(controlvm_channel,\r\noffsetof(struct spar_controlvm_channel_protocol,\r\ntool_action),\r\n&tool_action, sizeof(u8));\r\nif (ret)\r\nreturn ret;\r\nreturn count;\r\n}\r\nstatic ssize_t boottotool_show(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct efi_spar_indication efi_spar_indication;\r\nvisorchannel_read(controlvm_channel,\r\noffsetof(struct spar_controlvm_channel_protocol,\r\nefi_spar_ind), &efi_spar_indication,\r\nsizeof(struct efi_spar_indication));\r\nreturn scnprintf(buf, PAGE_SIZE, "%u\n",\r\nefi_spar_indication.boot_to_tool);\r\n}\r\nstatic ssize_t boottotool_store(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nint val, ret;\r\nstruct efi_spar_indication efi_spar_indication;\r\nif (kstrtoint(buf, 10, &val))\r\nreturn -EINVAL;\r\nefi_spar_indication.boot_to_tool = val;\r\nret = visorchannel_write(controlvm_channel,\r\noffsetof(struct spar_controlvm_channel_protocol,\r\nefi_spar_ind), &(efi_spar_indication),\r\nsizeof(struct efi_spar_indication));\r\nif (ret)\r\nreturn ret;\r\nreturn count;\r\n}\r\nstatic ssize_t error_show(struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nu32 error;\r\nvisorchannel_read(controlvm_channel,\r\noffsetof(struct spar_controlvm_channel_protocol,\r\ninstallation_error),\r\n&error, sizeof(u32));\r\nreturn scnprintf(buf, PAGE_SIZE, "%i\n", error);\r\n}\r\nstatic ssize_t error_store(struct device *dev, struct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nu32 error;\r\nint ret;\r\nif (kstrtou32(buf, 10, &error))\r\nreturn -EINVAL;\r\nret = visorchannel_write(controlvm_channel,\r\noffsetof(struct spar_controlvm_channel_protocol,\r\ninstallation_error),\r\n&error, sizeof(u32));\r\nif (ret)\r\nreturn ret;\r\nreturn count;\r\n}\r\nstatic ssize_t textid_show(struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nu32 text_id;\r\nvisorchannel_read(controlvm_channel,\r\noffsetof(struct spar_controlvm_channel_protocol,\r\ninstallation_text_id),\r\n&text_id, sizeof(u32));\r\nreturn scnprintf(buf, PAGE_SIZE, "%i\n", text_id);\r\n}\r\nstatic ssize_t textid_store(struct device *dev, struct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nu32 text_id;\r\nint ret;\r\nif (kstrtou32(buf, 10, &text_id))\r\nreturn -EINVAL;\r\nret = visorchannel_write(controlvm_channel,\r\noffsetof(struct spar_controlvm_channel_protocol,\r\ninstallation_text_id),\r\n&text_id, sizeof(u32));\r\nif (ret)\r\nreturn ret;\r\nreturn count;\r\n}\r\nstatic ssize_t remaining_steps_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nu16 remaining_steps;\r\nvisorchannel_read(controlvm_channel,\r\noffsetof(struct spar_controlvm_channel_protocol,\r\ninstallation_remaining_steps),\r\n&remaining_steps, sizeof(u16));\r\nreturn scnprintf(buf, PAGE_SIZE, "%hu\n", remaining_steps);\r\n}\r\nstatic ssize_t remaining_steps_store(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nu16 remaining_steps;\r\nint ret;\r\nif (kstrtou16(buf, 10, &remaining_steps))\r\nreturn -EINVAL;\r\nret = visorchannel_write(controlvm_channel,\r\noffsetof(struct spar_controlvm_channel_protocol,\r\ninstallation_remaining_steps),\r\n&remaining_steps, sizeof(u16));\r\nif (ret)\r\nreturn ret;\r\nreturn count;\r\n}\r\nstatic int match_visorbus_dev_by_id(struct device *dev, void *data)\r\n{\r\nstruct visor_device *vdev = to_visor_device(dev);\r\nstruct visor_busdev *id = data;\r\nu32 bus_no = id->bus_no;\r\nu32 dev_no = id->dev_no;\r\nif ((vdev->chipset_bus_no == bus_no) &&\r\n(vdev->chipset_dev_no == dev_no))\r\nreturn 1;\r\nreturn 0;\r\n}\r\nstruct visor_device *visorbus_get_device_by_id(u32 bus_no, u32 dev_no,\r\nstruct visor_device *from)\r\n{\r\nstruct device *dev;\r\nstruct device *dev_start = NULL;\r\nstruct visor_device *vdev = NULL;\r\nstruct visor_busdev id = {\r\n.bus_no = bus_no,\r\n.dev_no = dev_no\r\n};\r\nif (from)\r\ndev_start = &from->device;\r\ndev = bus_find_device(&visorbus_type, dev_start, (void *)&id,\r\nmatch_visorbus_dev_by_id);\r\nif (dev)\r\nvdev = to_visor_device(dev);\r\nreturn vdev;\r\n}\r\nstatic u8\r\ncheck_chipset_events(void)\r\n{\r\nint i;\r\nu8 send_msg = 1;\r\nfor (i = 0; i < MAX_CHIPSET_EVENTS; i++)\r\nsend_msg &= chipset_events[i];\r\nreturn send_msg;\r\n}\r\nstatic void\r\nclear_chipset_events(void)\r\n{\r\nint i;\r\nfor (i = 0; i < MAX_CHIPSET_EVENTS; i++)\r\nchipset_events[i] = 0;\r\n}\r\nvoid\r\nvisorchipset_register_busdev(\r\nstruct visorchipset_busdev_notifiers *notifiers,\r\nstruct visorchipset_busdev_responders *responders,\r\nstruct ultra_vbus_deviceinfo *driver_info)\r\n{\r\ndown(&notifier_lock);\r\nif (!notifiers) {\r\nmemset(&busdev_notifiers, 0,\r\nsizeof(busdev_notifiers));\r\nvisorbusregistered = 0;\r\n} else {\r\nbusdev_notifiers = *notifiers;\r\nvisorbusregistered = 1;\r\n}\r\nif (responders)\r\n*responders = busdev_responders;\r\nif (driver_info)\r\nbus_device_info_init(driver_info, "chipset", "visorchipset",\r\nVERSION, NULL);\r\nup(&notifier_lock);\r\n}\r\nstatic void\r\nchipset_init(struct controlvm_message *inmsg)\r\n{\r\nstatic int chipset_inited;\r\nenum ultra_chipset_feature features = 0;\r\nint rc = CONTROLVM_RESP_SUCCESS;\r\nPOSTCODE_LINUX_2(CHIPSET_INIT_ENTRY_PC, POSTCODE_SEVERITY_INFO);\r\nif (chipset_inited) {\r\nrc = -CONTROLVM_RESP_ERROR_ALREADY_DONE;\r\ngoto cleanup;\r\n}\r\nchipset_inited = 1;\r\nPOSTCODE_LINUX_2(CHIPSET_INIT_EXIT_PC, POSTCODE_SEVERITY_INFO);\r\nfeatures =\r\ninmsg->cmd.init_chipset.\r\nfeatures & ULTRA_CHIPSET_FEATURE_PARA_HOTPLUG;\r\nfeatures |= ULTRA_CHIPSET_FEATURE_REPLY;\r\ncleanup:\r\nif (inmsg->hdr.flags.response_expected)\r\ncontrolvm_respond_chipset_init(&inmsg->hdr, rc, features);\r\n}\r\nstatic void\r\ncontrolvm_init_response(struct controlvm_message *msg,\r\nstruct controlvm_message_header *msg_hdr, int response)\r\n{\r\nmemset(msg, 0, sizeof(struct controlvm_message));\r\nmemcpy(&msg->hdr, msg_hdr, sizeof(struct controlvm_message_header));\r\nmsg->hdr.payload_bytes = 0;\r\nmsg->hdr.payload_vm_offset = 0;\r\nmsg->hdr.payload_max_bytes = 0;\r\nif (response < 0) {\r\nmsg->hdr.flags.failed = 1;\r\nmsg->hdr.completion_status = (u32) (-response);\r\n}\r\n}\r\nstatic void\r\ncontrolvm_respond(struct controlvm_message_header *msg_hdr, int response)\r\n{\r\nstruct controlvm_message outmsg;\r\ncontrolvm_init_response(&outmsg, msg_hdr, response);\r\nif (outmsg.hdr.flags.test_message == 1)\r\nreturn;\r\nif (!visorchannel_signalinsert(controlvm_channel,\r\nCONTROLVM_QUEUE_REQUEST, &outmsg)) {\r\nreturn;\r\n}\r\n}\r\nstatic void\r\ncontrolvm_respond_chipset_init(struct controlvm_message_header *msg_hdr,\r\nint response,\r\nenum ultra_chipset_feature features)\r\n{\r\nstruct controlvm_message outmsg;\r\ncontrolvm_init_response(&outmsg, msg_hdr, response);\r\noutmsg.cmd.init_chipset.features = features;\r\nif (!visorchannel_signalinsert(controlvm_channel,\r\nCONTROLVM_QUEUE_REQUEST, &outmsg)) {\r\nreturn;\r\n}\r\n}\r\nstatic void controlvm_respond_physdev_changestate(\r\nstruct controlvm_message_header *msg_hdr, int response,\r\nstruct spar_segment_state state)\r\n{\r\nstruct controlvm_message outmsg;\r\ncontrolvm_init_response(&outmsg, msg_hdr, response);\r\noutmsg.cmd.device_change_state.state = state;\r\noutmsg.cmd.device_change_state.flags.phys_device = 1;\r\nif (!visorchannel_signalinsert(controlvm_channel,\r\nCONTROLVM_QUEUE_REQUEST, &outmsg)) {\r\nreturn;\r\n}\r\n}\r\nstatic void\r\nbus_responder(enum controlvm_id cmd_id,\r\nstruct controlvm_message_header *pending_msg_hdr,\r\nint response)\r\n{\r\nif (pending_msg_hdr == NULL)\r\nreturn;\r\nif (pending_msg_hdr->id != (u32)cmd_id)\r\nreturn;\r\ncontrolvm_respond(pending_msg_hdr, response);\r\n}\r\nstatic void\r\ndevice_changestate_responder(enum controlvm_id cmd_id,\r\nstruct visor_device *p, int response,\r\nstruct spar_segment_state response_state)\r\n{\r\nstruct controlvm_message outmsg;\r\nu32 bus_no = p->chipset_bus_no;\r\nu32 dev_no = p->chipset_dev_no;\r\nif (p->pending_msg_hdr == NULL)\r\nreturn;\r\nif (p->pending_msg_hdr->id != cmd_id)\r\nreturn;\r\ncontrolvm_init_response(&outmsg, p->pending_msg_hdr, response);\r\noutmsg.cmd.device_change_state.bus_no = bus_no;\r\noutmsg.cmd.device_change_state.dev_no = dev_no;\r\noutmsg.cmd.device_change_state.state = response_state;\r\nif (!visorchannel_signalinsert(controlvm_channel,\r\nCONTROLVM_QUEUE_REQUEST, &outmsg))\r\nreturn;\r\n}\r\nstatic void\r\ndevice_responder(enum controlvm_id cmd_id,\r\nstruct controlvm_message_header *pending_msg_hdr,\r\nint response)\r\n{\r\nif (pending_msg_hdr == NULL)\r\nreturn;\r\nif (pending_msg_hdr->id != (u32)cmd_id)\r\nreturn;\r\ncontrolvm_respond(pending_msg_hdr, response);\r\n}\r\nstatic void\r\nbus_epilog(struct visor_device *bus_info,\r\nu32 cmd, struct controlvm_message_header *msg_hdr,\r\nint response, bool need_response)\r\n{\r\nbool notified = false;\r\nstruct controlvm_message_header *pmsg_hdr = NULL;\r\nif (!bus_info) {\r\npmsg_hdr = msg_hdr;\r\ngoto away;\r\n}\r\nif (bus_info->pending_msg_hdr) {\r\nresponse = -CONTROLVM_RESP_ERROR_MESSAGE_ID_INVALID_FOR_CLIENT;\r\npmsg_hdr = bus_info->pending_msg_hdr;\r\ngoto away;\r\n}\r\nif (need_response) {\r\npmsg_hdr = kzalloc(sizeof(*pmsg_hdr), GFP_KERNEL);\r\nif (!pmsg_hdr) {\r\nresponse = -CONTROLVM_RESP_ERROR_KMALLOC_FAILED;\r\ngoto away;\r\n}\r\nmemcpy(pmsg_hdr, msg_hdr,\r\nsizeof(struct controlvm_message_header));\r\nbus_info->pending_msg_hdr = pmsg_hdr;\r\n}\r\ndown(&notifier_lock);\r\nif (response == CONTROLVM_RESP_SUCCESS) {\r\nswitch (cmd) {\r\ncase CONTROLVM_BUS_CREATE:\r\nif (busdev_notifiers.bus_create) {\r\n(*busdev_notifiers.bus_create) (bus_info);\r\nnotified = true;\r\n}\r\nbreak;\r\ncase CONTROLVM_BUS_DESTROY:\r\nif (busdev_notifiers.bus_destroy) {\r\n(*busdev_notifiers.bus_destroy) (bus_info);\r\nnotified = true;\r\n}\r\nbreak;\r\n}\r\n}\r\naway:\r\nif (notified)\r\n;\r\nelse\r\nbus_responder(cmd, pmsg_hdr, response);\r\nup(&notifier_lock);\r\n}\r\nstatic void\r\ndevice_epilog(struct visor_device *dev_info,\r\nstruct spar_segment_state state, u32 cmd,\r\nstruct controlvm_message_header *msg_hdr, int response,\r\nbool need_response, bool for_visorbus)\r\n{\r\nstruct visorchipset_busdev_notifiers *notifiers;\r\nbool notified = false;\r\nstruct controlvm_message_header *pmsg_hdr = NULL;\r\nnotifiers = &busdev_notifiers;\r\nif (!dev_info) {\r\npmsg_hdr = msg_hdr;\r\ngoto away;\r\n}\r\nif (dev_info->pending_msg_hdr) {\r\nresponse = -CONTROLVM_RESP_ERROR_MESSAGE_ID_INVALID_FOR_CLIENT;\r\npmsg_hdr = dev_info->pending_msg_hdr;\r\ngoto away;\r\n}\r\nif (need_response) {\r\npmsg_hdr = kzalloc(sizeof(*pmsg_hdr), GFP_KERNEL);\r\nif (!pmsg_hdr) {\r\nresponse = -CONTROLVM_RESP_ERROR_KMALLOC_FAILED;\r\ngoto away;\r\n}\r\nmemcpy(pmsg_hdr, msg_hdr,\r\nsizeof(struct controlvm_message_header));\r\ndev_info->pending_msg_hdr = pmsg_hdr;\r\n}\r\ndown(&notifier_lock);\r\nif (response >= 0) {\r\nswitch (cmd) {\r\ncase CONTROLVM_DEVICE_CREATE:\r\nif (notifiers->device_create) {\r\n(*notifiers->device_create) (dev_info);\r\nnotified = true;\r\n}\r\nbreak;\r\ncase CONTROLVM_DEVICE_CHANGESTATE:\r\nif (state.alive == segment_state_running.alive &&\r\nstate.operating ==\r\nsegment_state_running.operating) {\r\nif (notifiers->device_resume) {\r\n(*notifiers->device_resume) (dev_info);\r\nnotified = true;\r\n}\r\n}\r\nelse if (state.alive == segment_state_standby.alive &&\r\nstate.operating ==\r\nsegment_state_standby.operating) {\r\nif (notifiers->device_pause) {\r\n(*notifiers->device_pause) (dev_info);\r\nnotified = true;\r\n}\r\n}\r\nbreak;\r\ncase CONTROLVM_DEVICE_DESTROY:\r\nif (notifiers->device_destroy) {\r\n(*notifiers->device_destroy) (dev_info);\r\nnotified = true;\r\n}\r\nbreak;\r\n}\r\n}\r\naway:\r\nif (notified)\r\n;\r\nelse\r\ndevice_responder(cmd, pmsg_hdr, response);\r\nup(&notifier_lock);\r\n}\r\nstatic void\r\nbus_create(struct controlvm_message *inmsg)\r\n{\r\nstruct controlvm_message_packet *cmd = &inmsg->cmd;\r\nu32 bus_no = cmd->create_bus.bus_no;\r\nint rc = CONTROLVM_RESP_SUCCESS;\r\nstruct visor_device *bus_info;\r\nstruct visorchannel *visorchannel;\r\nbus_info = visorbus_get_device_by_id(bus_no, BUS_ROOT_DEVICE, NULL);\r\nif (bus_info && (bus_info->state.created == 1)) {\r\nPOSTCODE_LINUX_3(BUS_CREATE_FAILURE_PC, bus_no,\r\nPOSTCODE_SEVERITY_ERR);\r\nrc = -CONTROLVM_RESP_ERROR_ALREADY_DONE;\r\ngoto cleanup;\r\n}\r\nbus_info = kzalloc(sizeof(*bus_info), GFP_KERNEL);\r\nif (!bus_info) {\r\nPOSTCODE_LINUX_3(BUS_CREATE_FAILURE_PC, bus_no,\r\nPOSTCODE_SEVERITY_ERR);\r\nrc = -CONTROLVM_RESP_ERROR_KMALLOC_FAILED;\r\ngoto cleanup;\r\n}\r\nINIT_LIST_HEAD(&bus_info->list_all);\r\nbus_info->chipset_bus_no = bus_no;\r\nbus_info->chipset_dev_no = BUS_ROOT_DEVICE;\r\nPOSTCODE_LINUX_3(BUS_CREATE_ENTRY_PC, bus_no, POSTCODE_SEVERITY_INFO);\r\nvisorchannel = visorchannel_create(cmd->create_bus.channel_addr,\r\ncmd->create_bus.channel_bytes,\r\nGFP_KERNEL,\r\ncmd->create_bus.bus_data_type_uuid);\r\nif (!visorchannel) {\r\nPOSTCODE_LINUX_3(BUS_CREATE_FAILURE_PC, bus_no,\r\nPOSTCODE_SEVERITY_ERR);\r\nrc = -CONTROLVM_RESP_ERROR_KMALLOC_FAILED;\r\nkfree(bus_info);\r\nbus_info = NULL;\r\ngoto cleanup;\r\n}\r\nbus_info->visorchannel = visorchannel;\r\nPOSTCODE_LINUX_3(BUS_CREATE_EXIT_PC, bus_no, POSTCODE_SEVERITY_INFO);\r\ncleanup:\r\nbus_epilog(bus_info, CONTROLVM_BUS_CREATE, &inmsg->hdr,\r\nrc, inmsg->hdr.flags.response_expected == 1);\r\n}\r\nstatic void\r\nbus_destroy(struct controlvm_message *inmsg)\r\n{\r\nstruct controlvm_message_packet *cmd = &inmsg->cmd;\r\nu32 bus_no = cmd->destroy_bus.bus_no;\r\nstruct visor_device *bus_info;\r\nint rc = CONTROLVM_RESP_SUCCESS;\r\nbus_info = visorbus_get_device_by_id(bus_no, BUS_ROOT_DEVICE, NULL);\r\nif (!bus_info)\r\nrc = -CONTROLVM_RESP_ERROR_BUS_INVALID;\r\nelse if (bus_info->state.created == 0)\r\nrc = -CONTROLVM_RESP_ERROR_ALREADY_DONE;\r\nbus_epilog(bus_info, CONTROLVM_BUS_DESTROY, &inmsg->hdr,\r\nrc, inmsg->hdr.flags.response_expected == 1);\r\n}\r\nstatic void\r\nbus_configure(struct controlvm_message *inmsg,\r\nstruct parser_context *parser_ctx)\r\n{\r\nstruct controlvm_message_packet *cmd = &inmsg->cmd;\r\nu32 bus_no;\r\nstruct visor_device *bus_info;\r\nint rc = CONTROLVM_RESP_SUCCESS;\r\nbus_no = cmd->configure_bus.bus_no;\r\nPOSTCODE_LINUX_3(BUS_CONFIGURE_ENTRY_PC, bus_no,\r\nPOSTCODE_SEVERITY_INFO);\r\nbus_info = visorbus_get_device_by_id(bus_no, BUS_ROOT_DEVICE, NULL);\r\nif (!bus_info) {\r\nPOSTCODE_LINUX_3(BUS_CONFIGURE_FAILURE_PC, bus_no,\r\nPOSTCODE_SEVERITY_ERR);\r\nrc = -CONTROLVM_RESP_ERROR_BUS_INVALID;\r\n} else if (bus_info->state.created == 0) {\r\nPOSTCODE_LINUX_3(BUS_CONFIGURE_FAILURE_PC, bus_no,\r\nPOSTCODE_SEVERITY_ERR);\r\nrc = -CONTROLVM_RESP_ERROR_BUS_INVALID;\r\n} else if (bus_info->pending_msg_hdr != NULL) {\r\nPOSTCODE_LINUX_3(BUS_CONFIGURE_FAILURE_PC, bus_no,\r\nPOSTCODE_SEVERITY_ERR);\r\nrc = -CONTROLVM_RESP_ERROR_MESSAGE_ID_INVALID_FOR_CLIENT;\r\n} else {\r\nvisorchannel_set_clientpartition(bus_info->visorchannel,\r\ncmd->configure_bus.guest_handle);\r\nbus_info->partition_uuid = parser_id_get(parser_ctx);\r\nparser_param_start(parser_ctx, PARSERSTRING_NAME);\r\nbus_info->name = parser_string_get(parser_ctx);\r\nPOSTCODE_LINUX_3(BUS_CONFIGURE_EXIT_PC, bus_no,\r\nPOSTCODE_SEVERITY_INFO);\r\n}\r\nbus_epilog(bus_info, CONTROLVM_BUS_CONFIGURE, &inmsg->hdr,\r\nrc, inmsg->hdr.flags.response_expected == 1);\r\n}\r\nstatic void\r\nmy_device_create(struct controlvm_message *inmsg)\r\n{\r\nstruct controlvm_message_packet *cmd = &inmsg->cmd;\r\nu32 bus_no = cmd->create_device.bus_no;\r\nu32 dev_no = cmd->create_device.dev_no;\r\nstruct visor_device *dev_info = NULL;\r\nstruct visor_device *bus_info;\r\nstruct visorchannel *visorchannel;\r\nint rc = CONTROLVM_RESP_SUCCESS;\r\nbus_info = visorbus_get_device_by_id(bus_no, BUS_ROOT_DEVICE, NULL);\r\nif (!bus_info) {\r\nPOSTCODE_LINUX_4(DEVICE_CREATE_FAILURE_PC, dev_no, bus_no,\r\nPOSTCODE_SEVERITY_ERR);\r\nrc = -CONTROLVM_RESP_ERROR_BUS_INVALID;\r\ngoto cleanup;\r\n}\r\nif (bus_info->state.created == 0) {\r\nPOSTCODE_LINUX_4(DEVICE_CREATE_FAILURE_PC, dev_no, bus_no,\r\nPOSTCODE_SEVERITY_ERR);\r\nrc = -CONTROLVM_RESP_ERROR_BUS_INVALID;\r\ngoto cleanup;\r\n}\r\ndev_info = visorbus_get_device_by_id(bus_no, dev_no, NULL);\r\nif (dev_info && (dev_info->state.created == 1)) {\r\nPOSTCODE_LINUX_4(DEVICE_CREATE_FAILURE_PC, dev_no, bus_no,\r\nPOSTCODE_SEVERITY_ERR);\r\nrc = -CONTROLVM_RESP_ERROR_ALREADY_DONE;\r\ngoto cleanup;\r\n}\r\ndev_info = kzalloc(sizeof(*dev_info), GFP_KERNEL);\r\nif (!dev_info) {\r\nPOSTCODE_LINUX_4(DEVICE_CREATE_FAILURE_PC, dev_no, bus_no,\r\nPOSTCODE_SEVERITY_ERR);\r\nrc = -CONTROLVM_RESP_ERROR_KMALLOC_FAILED;\r\ngoto cleanup;\r\n}\r\ndev_info->chipset_bus_no = bus_no;\r\ndev_info->chipset_dev_no = dev_no;\r\ndev_info->inst = cmd->create_device.dev_inst_uuid;\r\ndev_info->device.parent = &bus_info->device;\r\nPOSTCODE_LINUX_4(DEVICE_CREATE_ENTRY_PC, dev_no, bus_no,\r\nPOSTCODE_SEVERITY_INFO);\r\nvisorchannel =\r\nvisorchannel_create_with_lock(cmd->create_device.channel_addr,\r\ncmd->create_device.channel_bytes,\r\nGFP_KERNEL,\r\ncmd->create_device.data_type_uuid);\r\nif (!visorchannel) {\r\nPOSTCODE_LINUX_4(DEVICE_CREATE_FAILURE_PC, dev_no, bus_no,\r\nPOSTCODE_SEVERITY_ERR);\r\nrc = -CONTROLVM_RESP_ERROR_KMALLOC_FAILED;\r\nkfree(dev_info);\r\ndev_info = NULL;\r\ngoto cleanup;\r\n}\r\ndev_info->visorchannel = visorchannel;\r\ndev_info->channel_type_guid = cmd->create_device.data_type_uuid;\r\nPOSTCODE_LINUX_4(DEVICE_CREATE_EXIT_PC, dev_no, bus_no,\r\nPOSTCODE_SEVERITY_INFO);\r\ncleanup:\r\ndevice_epilog(dev_info, segment_state_running,\r\nCONTROLVM_DEVICE_CREATE, &inmsg->hdr, rc,\r\ninmsg->hdr.flags.response_expected == 1, 1);\r\n}\r\nstatic void\r\nmy_device_changestate(struct controlvm_message *inmsg)\r\n{\r\nstruct controlvm_message_packet *cmd = &inmsg->cmd;\r\nu32 bus_no = cmd->device_change_state.bus_no;\r\nu32 dev_no = cmd->device_change_state.dev_no;\r\nstruct spar_segment_state state = cmd->device_change_state.state;\r\nstruct visor_device *dev_info;\r\nint rc = CONTROLVM_RESP_SUCCESS;\r\ndev_info = visorbus_get_device_by_id(bus_no, dev_no, NULL);\r\nif (!dev_info) {\r\nPOSTCODE_LINUX_4(DEVICE_CHANGESTATE_FAILURE_PC, dev_no, bus_no,\r\nPOSTCODE_SEVERITY_ERR);\r\nrc = -CONTROLVM_RESP_ERROR_DEVICE_INVALID;\r\n} else if (dev_info->state.created == 0) {\r\nPOSTCODE_LINUX_4(DEVICE_CHANGESTATE_FAILURE_PC, dev_no, bus_no,\r\nPOSTCODE_SEVERITY_ERR);\r\nrc = -CONTROLVM_RESP_ERROR_DEVICE_INVALID;\r\n}\r\nif ((rc >= CONTROLVM_RESP_SUCCESS) && dev_info)\r\ndevice_epilog(dev_info, state,\r\nCONTROLVM_DEVICE_CHANGESTATE, &inmsg->hdr, rc,\r\ninmsg->hdr.flags.response_expected == 1, 1);\r\n}\r\nstatic void\r\nmy_device_destroy(struct controlvm_message *inmsg)\r\n{\r\nstruct controlvm_message_packet *cmd = &inmsg->cmd;\r\nu32 bus_no = cmd->destroy_device.bus_no;\r\nu32 dev_no = cmd->destroy_device.dev_no;\r\nstruct visor_device *dev_info;\r\nint rc = CONTROLVM_RESP_SUCCESS;\r\ndev_info = visorbus_get_device_by_id(bus_no, dev_no, NULL);\r\nif (!dev_info)\r\nrc = -CONTROLVM_RESP_ERROR_DEVICE_INVALID;\r\nelse if (dev_info->state.created == 0)\r\nrc = -CONTROLVM_RESP_ERROR_ALREADY_DONE;\r\nif ((rc >= CONTROLVM_RESP_SUCCESS) && dev_info)\r\ndevice_epilog(dev_info, segment_state_running,\r\nCONTROLVM_DEVICE_DESTROY, &inmsg->hdr, rc,\r\ninmsg->hdr.flags.response_expected == 1, 1);\r\n}\r\nstatic int\r\ninitialize_controlvm_payload_info(u64 phys_addr, u64 offset, u32 bytes,\r\nstruct visor_controlvm_payload_info *info)\r\n{\r\nu8 *payload = NULL;\r\nint rc = CONTROLVM_RESP_SUCCESS;\r\nif (!info) {\r\nrc = -CONTROLVM_RESP_ERROR_PAYLOAD_INVALID;\r\ngoto cleanup;\r\n}\r\nmemset(info, 0, sizeof(struct visor_controlvm_payload_info));\r\nif ((offset == 0) || (bytes == 0)) {\r\nrc = -CONTROLVM_RESP_ERROR_PAYLOAD_INVALID;\r\ngoto cleanup;\r\n}\r\npayload = memremap(phys_addr + offset, bytes, MEMREMAP_WB);\r\nif (!payload) {\r\nrc = -CONTROLVM_RESP_ERROR_IOREMAP_FAILED;\r\ngoto cleanup;\r\n}\r\ninfo->offset = offset;\r\ninfo->bytes = bytes;\r\ninfo->ptr = payload;\r\ncleanup:\r\nif (rc < 0) {\r\nif (payload) {\r\nmemunmap(payload);\r\npayload = NULL;\r\n}\r\n}\r\nreturn rc;\r\n}\r\nstatic void\r\ndestroy_controlvm_payload_info(struct visor_controlvm_payload_info *info)\r\n{\r\nif (info->ptr) {\r\nmemunmap(info->ptr);\r\ninfo->ptr = NULL;\r\n}\r\nmemset(info, 0, sizeof(struct visor_controlvm_payload_info));\r\n}\r\nstatic void\r\ninitialize_controlvm_payload(void)\r\n{\r\nu64 phys_addr = visorchannel_get_physaddr(controlvm_channel);\r\nu64 payload_offset = 0;\r\nu32 payload_bytes = 0;\r\nif (visorchannel_read(controlvm_channel,\r\noffsetof(struct spar_controlvm_channel_protocol,\r\nrequest_payload_offset),\r\n&payload_offset, sizeof(payload_offset)) < 0) {\r\nPOSTCODE_LINUX_2(CONTROLVM_INIT_FAILURE_PC,\r\nPOSTCODE_SEVERITY_ERR);\r\nreturn;\r\n}\r\nif (visorchannel_read(controlvm_channel,\r\noffsetof(struct spar_controlvm_channel_protocol,\r\nrequest_payload_bytes),\r\n&payload_bytes, sizeof(payload_bytes)) < 0) {\r\nPOSTCODE_LINUX_2(CONTROLVM_INIT_FAILURE_PC,\r\nPOSTCODE_SEVERITY_ERR);\r\nreturn;\r\n}\r\ninitialize_controlvm_payload_info(phys_addr,\r\npayload_offset, payload_bytes,\r\n&controlvm_payload_info);\r\n}\r\nstatic int\r\nvisorchipset_chipset_ready(void)\r\n{\r\nkobject_uevent(&visorchipset_platform_device.dev.kobj, KOBJ_ONLINE);\r\nreturn CONTROLVM_RESP_SUCCESS;\r\n}\r\nstatic int\r\nvisorchipset_chipset_selftest(void)\r\n{\r\nchar env_selftest[20];\r\nchar *envp[] = { env_selftest, NULL };\r\nsprintf(env_selftest, "SPARSP_SELFTEST=%d", 1);\r\nkobject_uevent_env(&visorchipset_platform_device.dev.kobj, KOBJ_CHANGE,\r\nenvp);\r\nreturn CONTROLVM_RESP_SUCCESS;\r\n}\r\nstatic int\r\nvisorchipset_chipset_notready(void)\r\n{\r\nkobject_uevent(&visorchipset_platform_device.dev.kobj, KOBJ_OFFLINE);\r\nreturn CONTROLVM_RESP_SUCCESS;\r\n}\r\nstatic void\r\nchipset_ready(struct controlvm_message_header *msg_hdr)\r\n{\r\nint rc = visorchipset_chipset_ready();\r\nif (rc != CONTROLVM_RESP_SUCCESS)\r\nrc = -rc;\r\nif (msg_hdr->flags.response_expected && !visorchipset_holdchipsetready)\r\ncontrolvm_respond(msg_hdr, rc);\r\nif (msg_hdr->flags.response_expected && visorchipset_holdchipsetready) {\r\ng_chipset_msg_hdr = *msg_hdr;\r\n}\r\n}\r\nstatic void\r\nchipset_selftest(struct controlvm_message_header *msg_hdr)\r\n{\r\nint rc = visorchipset_chipset_selftest();\r\nif (rc != CONTROLVM_RESP_SUCCESS)\r\nrc = -rc;\r\nif (msg_hdr->flags.response_expected)\r\ncontrolvm_respond(msg_hdr, rc);\r\n}\r\nstatic void\r\nchipset_notready(struct controlvm_message_header *msg_hdr)\r\n{\r\nint rc = visorchipset_chipset_notready();\r\nif (rc != CONTROLVM_RESP_SUCCESS)\r\nrc = -rc;\r\nif (msg_hdr->flags.response_expected)\r\ncontrolvm_respond(msg_hdr, rc);\r\n}\r\nstatic bool\r\nread_controlvm_event(struct controlvm_message *msg)\r\n{\r\nif (visorchannel_signalremove(controlvm_channel,\r\nCONTROLVM_QUEUE_EVENT, msg)) {\r\nif (msg->hdr.flags.test_message == 1)\r\nreturn false;\r\nreturn true;\r\n}\r\nreturn false;\r\n}\r\nstatic int\r\nparahotplug_next_id(void)\r\n{\r\nstatic atomic_t id = ATOMIC_INIT(0);\r\nreturn atomic_inc_return(&id);\r\n}\r\nstatic unsigned long\r\nparahotplug_next_expiration(void)\r\n{\r\nreturn jiffies + msecs_to_jiffies(PARAHOTPLUG_TIMEOUT_MS);\r\n}\r\nstatic struct parahotplug_request *\r\nparahotplug_request_create(struct controlvm_message *msg)\r\n{\r\nstruct parahotplug_request *req;\r\nreq = kmalloc(sizeof(*req), GFP_KERNEL | __GFP_NORETRY);\r\nif (!req)\r\nreturn NULL;\r\nreq->id = parahotplug_next_id();\r\nreq->expiration = parahotplug_next_expiration();\r\nreq->msg = *msg;\r\nreturn req;\r\n}\r\nstatic void\r\nparahotplug_request_destroy(struct parahotplug_request *req)\r\n{\r\nkfree(req);\r\n}\r\nstatic void\r\nparahotplug_request_kickoff(struct parahotplug_request *req)\r\n{\r\nstruct controlvm_message_packet *cmd = &req->msg.cmd;\r\nchar env_cmd[40], env_id[40], env_state[40], env_bus[40], env_dev[40],\r\nenv_func[40];\r\nchar *envp[] = {\r\nenv_cmd, env_id, env_state, env_bus, env_dev, env_func, NULL\r\n};\r\nsprintf(env_cmd, "SPAR_PARAHOTPLUG=1");\r\nsprintf(env_id, "SPAR_PARAHOTPLUG_ID=%d", req->id);\r\nsprintf(env_state, "SPAR_PARAHOTPLUG_STATE=%d",\r\ncmd->device_change_state.state.active);\r\nsprintf(env_bus, "SPAR_PARAHOTPLUG_BUS=%d",\r\ncmd->device_change_state.bus_no);\r\nsprintf(env_dev, "SPAR_PARAHOTPLUG_DEVICE=%d",\r\ncmd->device_change_state.dev_no >> 3);\r\nsprintf(env_func, "SPAR_PARAHOTPLUG_FUNCTION=%d",\r\ncmd->device_change_state.dev_no & 0x7);\r\nkobject_uevent_env(&visorchipset_platform_device.dev.kobj, KOBJ_CHANGE,\r\nenvp);\r\n}\r\nstatic void\r\nparahotplug_process_list(void)\r\n{\r\nstruct list_head *pos;\r\nstruct list_head *tmp;\r\nspin_lock(&parahotplug_request_list_lock);\r\nlist_for_each_safe(pos, tmp, &parahotplug_request_list) {\r\nstruct parahotplug_request *req =\r\nlist_entry(pos, struct parahotplug_request, list);\r\nif (!time_after_eq(jiffies, req->expiration))\r\ncontinue;\r\nlist_del(pos);\r\nif (req->msg.hdr.flags.response_expected)\r\ncontrolvm_respond_physdev_changestate(\r\n&req->msg.hdr,\r\nCONTROLVM_RESP_ERROR_DEVICE_UDEV_TIMEOUT,\r\nreq->msg.cmd.device_change_state.state);\r\nparahotplug_request_destroy(req);\r\n}\r\nspin_unlock(&parahotplug_request_list_lock);\r\n}\r\nstatic int\r\nparahotplug_request_complete(int id, u16 active)\r\n{\r\nstruct list_head *pos;\r\nstruct list_head *tmp;\r\nspin_lock(&parahotplug_request_list_lock);\r\nlist_for_each_safe(pos, tmp, &parahotplug_request_list) {\r\nstruct parahotplug_request *req =\r\nlist_entry(pos, struct parahotplug_request, list);\r\nif (req->id == id) {\r\nlist_del(pos);\r\nspin_unlock(&parahotplug_request_list_lock);\r\nreq->msg.cmd.device_change_state.state.active = active;\r\nif (req->msg.hdr.flags.response_expected)\r\ncontrolvm_respond_physdev_changestate(\r\n&req->msg.hdr, CONTROLVM_RESP_SUCCESS,\r\nreq->msg.cmd.device_change_state.state);\r\nparahotplug_request_destroy(req);\r\nreturn 0;\r\n}\r\n}\r\nspin_unlock(&parahotplug_request_list_lock);\r\nreturn -1;\r\n}\r\nstatic void\r\nparahotplug_process_message(struct controlvm_message *inmsg)\r\n{\r\nstruct parahotplug_request *req;\r\nreq = parahotplug_request_create(inmsg);\r\nif (!req)\r\nreturn;\r\nif (inmsg->cmd.device_change_state.state.active) {\r\nparahotplug_request_kickoff(req);\r\ncontrolvm_respond_physdev_changestate(&inmsg->hdr,\r\nCONTROLVM_RESP_SUCCESS,\r\ninmsg->cmd.device_change_state.state);\r\nparahotplug_request_destroy(req);\r\n} else {\r\nspin_lock(&parahotplug_request_list_lock);\r\nlist_add_tail(&req->list, &parahotplug_request_list);\r\nspin_unlock(&parahotplug_request_list_lock);\r\nparahotplug_request_kickoff(req);\r\n}\r\n}\r\nstatic bool\r\nhandle_command(struct controlvm_message inmsg, u64 channel_addr)\r\n{\r\nstruct controlvm_message_packet *cmd = &inmsg.cmd;\r\nu64 parm_addr;\r\nu32 parm_bytes;\r\nstruct parser_context *parser_ctx = NULL;\r\nbool local_addr;\r\nstruct controlvm_message ackmsg;\r\nlocal_addr = (inmsg.hdr.flags.test_message == 1);\r\nif (channel_addr == 0)\r\nreturn true;\r\nparm_addr = channel_addr + inmsg.hdr.payload_vm_offset;\r\nparm_bytes = inmsg.hdr.payload_bytes;\r\nif (parm_addr && parm_bytes) {\r\nbool retry = false;\r\nparser_ctx =\r\nparser_init_byte_stream(parm_addr, parm_bytes,\r\nlocal_addr, &retry);\r\nif (!parser_ctx && retry)\r\nreturn false;\r\n}\r\nif (!local_addr) {\r\ncontrolvm_init_response(&ackmsg, &inmsg.hdr,\r\nCONTROLVM_RESP_SUCCESS);\r\nif (controlvm_channel)\r\nvisorchannel_signalinsert(controlvm_channel,\r\nCONTROLVM_QUEUE_ACK,\r\n&ackmsg);\r\n}\r\nswitch (inmsg.hdr.id) {\r\ncase CONTROLVM_CHIPSET_INIT:\r\nchipset_init(&inmsg);\r\nbreak;\r\ncase CONTROLVM_BUS_CREATE:\r\nbus_create(&inmsg);\r\nbreak;\r\ncase CONTROLVM_BUS_DESTROY:\r\nbus_destroy(&inmsg);\r\nbreak;\r\ncase CONTROLVM_BUS_CONFIGURE:\r\nbus_configure(&inmsg, parser_ctx);\r\nbreak;\r\ncase CONTROLVM_DEVICE_CREATE:\r\nmy_device_create(&inmsg);\r\nbreak;\r\ncase CONTROLVM_DEVICE_CHANGESTATE:\r\nif (cmd->device_change_state.flags.phys_device) {\r\nparahotplug_process_message(&inmsg);\r\n} else {\r\nmy_device_changestate(&inmsg);\r\ng_devicechangestate_packet = inmsg.cmd;\r\nbreak;\r\n}\r\nbreak;\r\ncase CONTROLVM_DEVICE_DESTROY:\r\nmy_device_destroy(&inmsg);\r\nbreak;\r\ncase CONTROLVM_DEVICE_CONFIGURE:\r\nif (inmsg.hdr.flags.response_expected)\r\ncontrolvm_respond(&inmsg.hdr, CONTROLVM_RESP_SUCCESS);\r\nbreak;\r\ncase CONTROLVM_CHIPSET_READY:\r\nchipset_ready(&inmsg.hdr);\r\nbreak;\r\ncase CONTROLVM_CHIPSET_SELFTEST:\r\nchipset_selftest(&inmsg.hdr);\r\nbreak;\r\ncase CONTROLVM_CHIPSET_STOP:\r\nchipset_notready(&inmsg.hdr);\r\nbreak;\r\ndefault:\r\nif (inmsg.hdr.flags.response_expected)\r\ncontrolvm_respond(&inmsg.hdr,\r\n-CONTROLVM_RESP_ERROR_MESSAGE_ID_UNKNOWN);\r\nbreak;\r\n}\r\nif (parser_ctx) {\r\nparser_done(parser_ctx);\r\nparser_ctx = NULL;\r\n}\r\nreturn true;\r\n}\r\nstatic inline unsigned int\r\nissue_vmcall_io_controlvm_addr(u64 *control_addr, u32 *control_bytes)\r\n{\r\nstruct vmcall_io_controlvm_addr_params params;\r\nint result = VMCALL_SUCCESS;\r\nu64 physaddr;\r\nphysaddr = virt_to_phys(&params);\r\nISSUE_IO_VMCALL(VMCALL_IO_CONTROLVM_ADDR, physaddr, result);\r\nif (VMCALL_SUCCESSFUL(result)) {\r\n*control_addr = params.address;\r\n*control_bytes = params.channel_bytes;\r\n}\r\nreturn result;\r\n}\r\nstatic u64 controlvm_get_channel_address(void)\r\n{\r\nu64 addr = 0;\r\nu32 size = 0;\r\nif (!VMCALL_SUCCESSFUL(issue_vmcall_io_controlvm_addr(&addr, &size)))\r\nreturn 0;\r\nreturn addr;\r\n}\r\nstatic void\r\ncontrolvm_periodic_work(struct work_struct *work)\r\n{\r\nstruct controlvm_message inmsg;\r\nbool got_command = false;\r\nbool handle_command_failed = false;\r\nstatic u64 poll_count;\r\nif (visorchipset_visorbusregwait && !visorbusregistered)\r\ngoto cleanup;\r\npoll_count++;\r\nif (poll_count >= 250)\r\n;\r\nelse\r\ngoto cleanup;\r\nif (visorchipset_holdchipsetready &&\r\n(g_chipset_msg_hdr.id != CONTROLVM_INVALID)) {\r\nif (check_chipset_events() == 1) {\r\ncontrolvm_respond(&g_chipset_msg_hdr, 0);\r\nclear_chipset_events();\r\nmemset(&g_chipset_msg_hdr, 0,\r\nsizeof(struct controlvm_message_header));\r\n}\r\n}\r\nwhile (visorchannel_signalremove(controlvm_channel,\r\nCONTROLVM_QUEUE_RESPONSE,\r\n&inmsg))\r\n;\r\nif (!got_command) {\r\nif (controlvm_pending_msg_valid) {\r\ninmsg = controlvm_pending_msg;\r\ncontrolvm_pending_msg_valid = false;\r\ngot_command = true;\r\n} else {\r\ngot_command = read_controlvm_event(&inmsg);\r\n}\r\n}\r\nhandle_command_failed = false;\r\nwhile (got_command && (!handle_command_failed)) {\r\nmost_recent_message_jiffies = jiffies;\r\nif (handle_command(inmsg,\r\nvisorchannel_get_physaddr\r\n(controlvm_channel)))\r\ngot_command = read_controlvm_event(&inmsg);\r\nelse {\r\nhandle_command_failed = true;\r\ncontrolvm_pending_msg = inmsg;\r\ncontrolvm_pending_msg_valid = true;\r\n}\r\n}\r\nparahotplug_process_list();\r\ncleanup:\r\nif (time_after(jiffies,\r\nmost_recent_message_jiffies + (HZ * MIN_IDLE_SECONDS))) {\r\nif (poll_jiffies != POLLJIFFIES_CONTROLVMCHANNEL_SLOW)\r\npoll_jiffies = POLLJIFFIES_CONTROLVMCHANNEL_SLOW;\r\n} else {\r\nif (poll_jiffies != POLLJIFFIES_CONTROLVMCHANNEL_FAST)\r\npoll_jiffies = POLLJIFFIES_CONTROLVMCHANNEL_FAST;\r\n}\r\nqueue_delayed_work(periodic_controlvm_workqueue,\r\n&periodic_controlvm_work, poll_jiffies);\r\n}\r\nstatic void\r\nsetup_crash_devices_work_queue(struct work_struct *work)\r\n{\r\nstruct controlvm_message local_crash_bus_msg;\r\nstruct controlvm_message local_crash_dev_msg;\r\nstruct controlvm_message msg;\r\nu32 local_crash_msg_offset;\r\nu16 local_crash_msg_count;\r\nif (visorchipset_visorbusregwait && !visorbusregistered)\r\ngoto cleanup;\r\nPOSTCODE_LINUX_2(CRASH_DEV_ENTRY_PC, POSTCODE_SEVERITY_INFO);\r\nmsg.hdr.id = CONTROLVM_CHIPSET_INIT;\r\nmsg.cmd.init_chipset.bus_count = 23;\r\nmsg.cmd.init_chipset.switch_count = 0;\r\nchipset_init(&msg);\r\nif (visorchannel_read(controlvm_channel,\r\noffsetof(struct spar_controlvm_channel_protocol,\r\nsaved_crash_message_count),\r\n&local_crash_msg_count, sizeof(u16)) < 0) {\r\nPOSTCODE_LINUX_2(CRASH_DEV_CTRL_RD_FAILURE_PC,\r\nPOSTCODE_SEVERITY_ERR);\r\nreturn;\r\n}\r\nif (local_crash_msg_count != CONTROLVM_CRASHMSG_MAX) {\r\nPOSTCODE_LINUX_3(CRASH_DEV_COUNT_FAILURE_PC,\r\nlocal_crash_msg_count,\r\nPOSTCODE_SEVERITY_ERR);\r\nreturn;\r\n}\r\nif (visorchannel_read(controlvm_channel,\r\noffsetof(struct spar_controlvm_channel_protocol,\r\nsaved_crash_message_offset),\r\n&local_crash_msg_offset, sizeof(u32)) < 0) {\r\nPOSTCODE_LINUX_2(CRASH_DEV_CTRL_RD_FAILURE_PC,\r\nPOSTCODE_SEVERITY_ERR);\r\nreturn;\r\n}\r\nif (visorchannel_read(controlvm_channel,\r\nlocal_crash_msg_offset,\r\n&local_crash_bus_msg,\r\nsizeof(struct controlvm_message)) < 0) {\r\nPOSTCODE_LINUX_2(CRASH_DEV_RD_BUS_FAIULRE_PC,\r\nPOSTCODE_SEVERITY_ERR);\r\nreturn;\r\n}\r\nif (visorchannel_read(controlvm_channel,\r\nlocal_crash_msg_offset +\r\nsizeof(struct controlvm_message),\r\n&local_crash_dev_msg,\r\nsizeof(struct controlvm_message)) < 0) {\r\nPOSTCODE_LINUX_2(CRASH_DEV_RD_DEV_FAIULRE_PC,\r\nPOSTCODE_SEVERITY_ERR);\r\nreturn;\r\n}\r\nif (local_crash_bus_msg.cmd.create_bus.channel_addr) {\r\nbus_create(&local_crash_bus_msg);\r\n} else {\r\nPOSTCODE_LINUX_2(CRASH_DEV_BUS_NULL_FAILURE_PC,\r\nPOSTCODE_SEVERITY_ERR);\r\nreturn;\r\n}\r\nif (local_crash_dev_msg.cmd.create_device.channel_addr) {\r\nmy_device_create(&local_crash_dev_msg);\r\n} else {\r\nPOSTCODE_LINUX_2(CRASH_DEV_DEV_NULL_FAILURE_PC,\r\nPOSTCODE_SEVERITY_ERR);\r\nreturn;\r\n}\r\nPOSTCODE_LINUX_2(CRASH_DEV_EXIT_PC, POSTCODE_SEVERITY_INFO);\r\nreturn;\r\ncleanup:\r\npoll_jiffies = POLLJIFFIES_CONTROLVMCHANNEL_SLOW;\r\nqueue_delayed_work(periodic_controlvm_workqueue,\r\n&periodic_controlvm_work, poll_jiffies);\r\n}\r\nstatic void\r\nbus_create_response(struct visor_device *bus_info, int response)\r\n{\r\nif (response >= 0)\r\nbus_info->state.created = 1;\r\nbus_responder(CONTROLVM_BUS_CREATE, bus_info->pending_msg_hdr,\r\nresponse);\r\nkfree(bus_info->pending_msg_hdr);\r\nbus_info->pending_msg_hdr = NULL;\r\n}\r\nstatic void\r\nbus_destroy_response(struct visor_device *bus_info, int response)\r\n{\r\nbus_responder(CONTROLVM_BUS_DESTROY, bus_info->pending_msg_hdr,\r\nresponse);\r\nkfree(bus_info->pending_msg_hdr);\r\nbus_info->pending_msg_hdr = NULL;\r\n}\r\nstatic void\r\ndevice_create_response(struct visor_device *dev_info, int response)\r\n{\r\nif (response >= 0)\r\ndev_info->state.created = 1;\r\ndevice_responder(CONTROLVM_DEVICE_CREATE, dev_info->pending_msg_hdr,\r\nresponse);\r\nkfree(dev_info->pending_msg_hdr);\r\ndev_info->pending_msg_hdr = NULL;\r\n}\r\nstatic void\r\ndevice_destroy_response(struct visor_device *dev_info, int response)\r\n{\r\ndevice_responder(CONTROLVM_DEVICE_DESTROY, dev_info->pending_msg_hdr,\r\nresponse);\r\nkfree(dev_info->pending_msg_hdr);\r\ndev_info->pending_msg_hdr = NULL;\r\n}\r\nstatic void\r\nvisorchipset_device_pause_response(struct visor_device *dev_info,\r\nint response)\r\n{\r\ndevice_changestate_responder(CONTROLVM_DEVICE_CHANGESTATE,\r\ndev_info, response,\r\nsegment_state_standby);\r\nkfree(dev_info->pending_msg_hdr);\r\ndev_info->pending_msg_hdr = NULL;\r\n}\r\nstatic void\r\ndevice_resume_response(struct visor_device *dev_info, int response)\r\n{\r\ndevice_changestate_responder(CONTROLVM_DEVICE_CHANGESTATE,\r\ndev_info, response,\r\nsegment_state_running);\r\nkfree(dev_info->pending_msg_hdr);\r\ndev_info->pending_msg_hdr = NULL;\r\n}\r\nstatic ssize_t chipsetready_store(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nchar msgtype[64];\r\nif (sscanf(buf, "%63s", msgtype) != 1)\r\nreturn -EINVAL;\r\nif (!strcmp(msgtype, "CALLHOMEDISK_MOUNTED")) {\r\nchipset_events[0] = 1;\r\nreturn count;\r\n} else if (!strcmp(msgtype, "MODULES_LOADED")) {\r\nchipset_events[1] = 1;\r\nreturn count;\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic ssize_t devicedisabled_store(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nunsigned int id;\r\nif (kstrtouint(buf, 10, &id))\r\nreturn -EINVAL;\r\nparahotplug_request_complete(id, 0);\r\nreturn count;\r\n}\r\nstatic ssize_t deviceenabled_store(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nunsigned int id;\r\nif (kstrtouint(buf, 10, &id))\r\nreturn -EINVAL;\r\nparahotplug_request_complete(id, 1);\r\nreturn count;\r\n}\r\nstatic int\r\nvisorchipset_mmap(struct file *file, struct vm_area_struct *vma)\r\n{\r\nunsigned long physaddr = 0;\r\nunsigned long offset = vma->vm_pgoff << PAGE_SHIFT;\r\nu64 addr = 0;\r\nif (offset & (PAGE_SIZE - 1))\r\nreturn -ENXIO;\r\nswitch (offset) {\r\ncase VISORCHIPSET_MMAP_CONTROLCHANOFFSET:\r\nvma->vm_flags |= VM_IO;\r\nif (!*file_controlvm_channel)\r\nreturn -ENXIO;\r\nvisorchannel_read(*file_controlvm_channel,\r\noffsetof(struct spar_controlvm_channel_protocol,\r\ngp_control_channel),\r\n&addr, sizeof(addr));\r\nif (!addr)\r\nreturn -ENXIO;\r\nphysaddr = (unsigned long)addr;\r\nif (remap_pfn_range(vma, vma->vm_start,\r\nphysaddr >> PAGE_SHIFT,\r\nvma->vm_end - vma->vm_start,\r\n(vma->vm_page_prot))) {\r\nreturn -EAGAIN;\r\n}\r\nbreak;\r\ndefault:\r\nreturn -ENXIO;\r\n}\r\nreturn 0;\r\n}\r\nstatic inline s64 issue_vmcall_query_guest_virtual_time_offset(void)\r\n{\r\nu64 result = VMCALL_SUCCESS;\r\nu64 physaddr = 0;\r\nISSUE_IO_VMCALL(VMCALL_QUERY_GUEST_VIRTUAL_TIME_OFFSET, physaddr,\r\nresult);\r\nreturn result;\r\n}\r\nstatic inline int issue_vmcall_update_physical_time(u64 adjustment)\r\n{\r\nint result = VMCALL_SUCCESS;\r\nISSUE_IO_VMCALL(VMCALL_UPDATE_PHYSICAL_TIME, adjustment, result);\r\nreturn result;\r\n}\r\nstatic long visorchipset_ioctl(struct file *file, unsigned int cmd,\r\nunsigned long arg)\r\n{\r\ns64 adjustment;\r\ns64 vrtc_offset;\r\nswitch (cmd) {\r\ncase VMCALL_QUERY_GUEST_VIRTUAL_TIME_OFFSET:\r\nvrtc_offset = issue_vmcall_query_guest_virtual_time_offset();\r\nif (copy_to_user((void __user *)arg, &vrtc_offset,\r\nsizeof(vrtc_offset))) {\r\nreturn -EFAULT;\r\n}\r\nreturn 0;\r\ncase VMCALL_UPDATE_PHYSICAL_TIME:\r\nif (copy_from_user(&adjustment, (void __user *)arg,\r\nsizeof(adjustment))) {\r\nreturn -EFAULT;\r\n}\r\nreturn issue_vmcall_update_physical_time(adjustment);\r\ndefault:\r\nreturn -EFAULT;\r\n}\r\n}\r\nstatic int\r\nvisorchipset_file_init(dev_t major_dev, struct visorchannel **controlvm_channel)\r\n{\r\nint rc = 0;\r\nfile_controlvm_channel = controlvm_channel;\r\ncdev_init(&file_cdev, &visorchipset_fops);\r\nfile_cdev.owner = THIS_MODULE;\r\nif (MAJOR(major_dev) == 0) {\r\nrc = alloc_chrdev_region(&major_dev, 0, 1, "visorchipset");\r\nif (rc < 0)\r\nreturn rc;\r\n} else {\r\nrc = register_chrdev_region(major_dev, 1, "visorchipset");\r\nif (rc < 0)\r\nreturn rc;\r\n}\r\nrc = cdev_add(&file_cdev, MKDEV(MAJOR(major_dev), 0), 1);\r\nif (rc < 0) {\r\nunregister_chrdev_region(major_dev, 1);\r\nreturn rc;\r\n}\r\nreturn 0;\r\n}\r\nstatic int\r\nvisorchipset_init(struct acpi_device *acpi_device)\r\n{\r\nint rc = 0;\r\nu64 addr;\r\nint tmp_sz = sizeof(struct spar_controlvm_channel_protocol);\r\nuuid_le uuid = SPAR_CONTROLVM_CHANNEL_PROTOCOL_UUID;\r\naddr = controlvm_get_channel_address();\r\nif (!addr)\r\nreturn -ENODEV;\r\nmemset(&busdev_notifiers, 0, sizeof(busdev_notifiers));\r\nmemset(&controlvm_payload_info, 0, sizeof(controlvm_payload_info));\r\ncontrolvm_channel = visorchannel_create_with_lock(addr, tmp_sz,\r\nGFP_KERNEL, uuid);\r\nif (SPAR_CONTROLVM_CHANNEL_OK_CLIENT(\r\nvisorchannel_get_header(controlvm_channel))) {\r\ninitialize_controlvm_payload();\r\n} else {\r\nvisorchannel_destroy(controlvm_channel);\r\ncontrolvm_channel = NULL;\r\nreturn -ENODEV;\r\n}\r\nmajor_dev = MKDEV(visorchipset_major, 0);\r\nrc = visorchipset_file_init(major_dev, &controlvm_channel);\r\nif (rc < 0) {\r\nPOSTCODE_LINUX_2(CHIPSET_INIT_FAILURE_PC, DIAG_SEVERITY_ERR);\r\ngoto cleanup;\r\n}\r\nmemset(&g_chipset_msg_hdr, 0, sizeof(struct controlvm_message_header));\r\nif (is_kdump_kernel())\r\nINIT_DELAYED_WORK(&periodic_controlvm_work,\r\nsetup_crash_devices_work_queue);\r\nelse\r\nINIT_DELAYED_WORK(&periodic_controlvm_work,\r\ncontrolvm_periodic_work);\r\nperiodic_controlvm_workqueue =\r\ncreate_singlethread_workqueue("visorchipset_controlvm");\r\nif (!periodic_controlvm_workqueue) {\r\nPOSTCODE_LINUX_2(CREATE_WORKQUEUE_FAILED_PC,\r\nDIAG_SEVERITY_ERR);\r\nrc = -ENOMEM;\r\ngoto cleanup;\r\n}\r\nmost_recent_message_jiffies = jiffies;\r\npoll_jiffies = POLLJIFFIES_CONTROLVMCHANNEL_FAST;\r\nrc = queue_delayed_work(periodic_controlvm_workqueue,\r\n&periodic_controlvm_work, poll_jiffies);\r\nif (rc < 0) {\r\nPOSTCODE_LINUX_2(QUEUE_DELAYED_WORK_PC,\r\nDIAG_SEVERITY_ERR);\r\ngoto cleanup;\r\n}\r\nvisorchipset_platform_device.dev.devt = major_dev;\r\nif (platform_device_register(&visorchipset_platform_device) < 0) {\r\nPOSTCODE_LINUX_2(DEVICE_REGISTER_FAILURE_PC, DIAG_SEVERITY_ERR);\r\nrc = -1;\r\ngoto cleanup;\r\n}\r\nPOSTCODE_LINUX_2(CHIPSET_INIT_SUCCESS_PC, POSTCODE_SEVERITY_INFO);\r\nrc = visorbus_init();\r\ncleanup:\r\nif (rc) {\r\nPOSTCODE_LINUX_3(CHIPSET_INIT_FAILURE_PC, rc,\r\nPOSTCODE_SEVERITY_ERR);\r\n}\r\nreturn rc;\r\n}\r\nstatic void\r\nvisorchipset_file_cleanup(dev_t major_dev)\r\n{\r\nif (file_cdev.ops)\r\ncdev_del(&file_cdev);\r\nfile_cdev.ops = NULL;\r\nunregister_chrdev_region(major_dev, 1);\r\n}\r\nstatic int\r\nvisorchipset_exit(struct acpi_device *acpi_device)\r\n{\r\nPOSTCODE_LINUX_2(DRIVER_EXIT_PC, POSTCODE_SEVERITY_INFO);\r\nvisorbus_exit();\r\ncancel_delayed_work(&periodic_controlvm_work);\r\nflush_workqueue(periodic_controlvm_workqueue);\r\ndestroy_workqueue(periodic_controlvm_workqueue);\r\nperiodic_controlvm_workqueue = NULL;\r\ndestroy_controlvm_payload_info(&controlvm_payload_info);\r\nmemset(&g_chipset_msg_hdr, 0, sizeof(struct controlvm_message_header));\r\nvisorchannel_destroy(controlvm_channel);\r\nvisorchipset_file_cleanup(visorchipset_platform_device.dev.devt);\r\nplatform_device_unregister(&visorchipset_platform_device);\r\nPOSTCODE_LINUX_2(DRIVER_EXIT_PC, POSTCODE_SEVERITY_INFO);\r\nreturn 0;\r\n}\r\nstatic __init uint32_t visorutil_spar_detect(void)\r\n{\r\nunsigned int eax, ebx, ecx, edx;\r\nif (cpu_has_hypervisor) {\r\ncpuid(UNISYS_SPAR_LEAF_ID, &eax, &ebx, &ecx, &edx);\r\nreturn (ebx == UNISYS_SPAR_ID_EBX) &&\r\n(ecx == UNISYS_SPAR_ID_ECX) &&\r\n(edx == UNISYS_SPAR_ID_EDX);\r\n} else {\r\nreturn 0;\r\n}\r\n}\r\nstatic int init_unisys(void)\r\n{\r\nint result;\r\nif (!visorutil_spar_detect())\r\nreturn -ENODEV;\r\nresult = acpi_bus_register_driver(&unisys_acpi_driver);\r\nif (result)\r\nreturn -ENODEV;\r\npr_info("Unisys Visorchipset Driver Loaded.\n");\r\nreturn 0;\r\n}\r\nstatic void exit_unisys(void)\r\n{\r\nacpi_bus_unregister_driver(&unisys_acpi_driver);\r\n}
