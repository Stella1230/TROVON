static int imx_ssi_set_dai_tdm_slot(struct snd_soc_dai *cpu_dai,\r\nunsigned int tx_mask, unsigned int rx_mask, int slots, int slot_width)\r\n{\r\nstruct imx_ssi *ssi = snd_soc_dai_get_drvdata(cpu_dai);\r\nu32 sccr;\r\nsccr = readl(ssi->base + SSI_STCCR);\r\nsccr &= ~SSI_STCCR_DC_MASK;\r\nsccr |= SSI_STCCR_DC(slots - 1);\r\nwritel(sccr, ssi->base + SSI_STCCR);\r\nsccr = readl(ssi->base + SSI_SRCCR);\r\nsccr &= ~SSI_STCCR_DC_MASK;\r\nsccr |= SSI_STCCR_DC(slots - 1);\r\nwritel(sccr, ssi->base + SSI_SRCCR);\r\nwritel(~tx_mask, ssi->base + SSI_STMSK);\r\nwritel(~rx_mask, ssi->base + SSI_SRMSK);\r\nreturn 0;\r\n}\r\nstatic int imx_ssi_set_dai_fmt(struct snd_soc_dai *cpu_dai, unsigned int fmt)\r\n{\r\nstruct imx_ssi *ssi = snd_soc_dai_get_drvdata(cpu_dai);\r\nu32 strcr = 0, scr;\r\nscr = readl(ssi->base + SSI_SCR) & ~(SSI_SCR_SYN | SSI_SCR_NET);\r\nswitch (fmt & SND_SOC_DAIFMT_FORMAT_MASK) {\r\ncase SND_SOC_DAIFMT_I2S:\r\nstrcr |= SSI_STCR_TXBIT0 | SSI_STCR_TSCKP | SSI_STCR_TFSI |\r\nSSI_STCR_TEFS;\r\nscr |= SSI_SCR_NET;\r\nif (ssi->flags & IMX_SSI_USE_I2S_SLAVE) {\r\nscr &= ~SSI_I2S_MODE_MASK;\r\nscr |= SSI_SCR_I2S_MODE_SLAVE;\r\n}\r\nbreak;\r\ncase SND_SOC_DAIFMT_LEFT_J:\r\nstrcr |= SSI_STCR_TXBIT0 | SSI_STCR_TSCKP;\r\nbreak;\r\ncase SND_SOC_DAIFMT_DSP_B:\r\nstrcr |= SSI_STCR_TXBIT0 | SSI_STCR_TSCKP | SSI_STCR_TFSL;\r\nbreak;\r\ncase SND_SOC_DAIFMT_DSP_A:\r\nstrcr |= SSI_STCR_TXBIT0 | SSI_STCR_TSCKP | SSI_STCR_TFSL |\r\nSSI_STCR_TEFS;\r\nbreak;\r\n}\r\nswitch (fmt & SND_SOC_DAIFMT_INV_MASK) {\r\ncase SND_SOC_DAIFMT_IB_IF:\r\nstrcr ^= SSI_STCR_TSCKP | SSI_STCR_TFSI;\r\nbreak;\r\ncase SND_SOC_DAIFMT_IB_NF:\r\nstrcr ^= SSI_STCR_TSCKP;\r\nbreak;\r\ncase SND_SOC_DAIFMT_NB_IF:\r\nstrcr ^= SSI_STCR_TFSI;\r\nbreak;\r\ncase SND_SOC_DAIFMT_NB_NF:\r\nbreak;\r\n}\r\nswitch (fmt & SND_SOC_DAIFMT_MASTER_MASK) {\r\ncase SND_SOC_DAIFMT_CBM_CFM:\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nstrcr |= SSI_STCR_TFEN0;\r\nif (ssi->flags & IMX_SSI_NET)\r\nscr |= SSI_SCR_NET;\r\nif (ssi->flags & IMX_SSI_SYN)\r\nscr |= SSI_SCR_SYN;\r\nwritel(strcr, ssi->base + SSI_STCR);\r\nwritel(strcr, ssi->base + SSI_SRCR);\r\nwritel(scr, ssi->base + SSI_SCR);\r\nreturn 0;\r\n}\r\nstatic int imx_ssi_set_dai_sysclk(struct snd_soc_dai *cpu_dai,\r\nint clk_id, unsigned int freq, int dir)\r\n{\r\nstruct imx_ssi *ssi = snd_soc_dai_get_drvdata(cpu_dai);\r\nu32 scr;\r\nscr = readl(ssi->base + SSI_SCR);\r\nswitch (clk_id) {\r\ncase IMX_SSP_SYS_CLK:\r\nif (dir == SND_SOC_CLOCK_OUT)\r\nscr |= SSI_SCR_SYS_CLK_EN;\r\nelse\r\nscr &= ~SSI_SCR_SYS_CLK_EN;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nwritel(scr, ssi->base + SSI_SCR);\r\nreturn 0;\r\n}\r\nstatic int imx_ssi_set_dai_clkdiv(struct snd_soc_dai *cpu_dai,\r\nint div_id, int div)\r\n{\r\nstruct imx_ssi *ssi = snd_soc_dai_get_drvdata(cpu_dai);\r\nu32 stccr, srccr;\r\nstccr = readl(ssi->base + SSI_STCCR);\r\nsrccr = readl(ssi->base + SSI_SRCCR);\r\nswitch (div_id) {\r\ncase IMX_SSI_TX_DIV_2:\r\nstccr &= ~SSI_STCCR_DIV2;\r\nstccr |= div;\r\nbreak;\r\ncase IMX_SSI_TX_DIV_PSR:\r\nstccr &= ~SSI_STCCR_PSR;\r\nstccr |= div;\r\nbreak;\r\ncase IMX_SSI_TX_DIV_PM:\r\nstccr &= ~0xff;\r\nstccr |= SSI_STCCR_PM(div);\r\nbreak;\r\ncase IMX_SSI_RX_DIV_2:\r\nstccr &= ~SSI_STCCR_DIV2;\r\nstccr |= div;\r\nbreak;\r\ncase IMX_SSI_RX_DIV_PSR:\r\nstccr &= ~SSI_STCCR_PSR;\r\nstccr |= div;\r\nbreak;\r\ncase IMX_SSI_RX_DIV_PM:\r\nstccr &= ~0xff;\r\nstccr |= SSI_STCCR_PM(div);\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nwritel(stccr, ssi->base + SSI_STCCR);\r\nwritel(srccr, ssi->base + SSI_SRCCR);\r\nreturn 0;\r\n}\r\nstatic int imx_ssi_hw_params(struct snd_pcm_substream *substream,\r\nstruct snd_pcm_hw_params *params,\r\nstruct snd_soc_dai *cpu_dai)\r\n{\r\nstruct imx_ssi *ssi = snd_soc_dai_get_drvdata(cpu_dai);\r\nu32 reg, sccr;\r\nif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)\r\nreg = SSI_STCCR;\r\nelse\r\nreg = SSI_SRCCR;\r\nif (ssi->flags & IMX_SSI_SYN)\r\nreg = SSI_STCCR;\r\nsccr = readl(ssi->base + reg) & ~SSI_STCCR_WL_MASK;\r\nswitch (params_format(params)) {\r\ncase SNDRV_PCM_FORMAT_S16_LE:\r\nsccr |= SSI_SRCCR_WL(16);\r\nbreak;\r\ncase SNDRV_PCM_FORMAT_S20_3LE:\r\nsccr |= SSI_SRCCR_WL(20);\r\nbreak;\r\ncase SNDRV_PCM_FORMAT_S24_LE:\r\nsccr |= SSI_SRCCR_WL(24);\r\nbreak;\r\n}\r\nwritel(sccr, ssi->base + reg);\r\nreturn 0;\r\n}\r\nstatic int imx_ssi_trigger(struct snd_pcm_substream *substream, int cmd,\r\nstruct snd_soc_dai *dai)\r\n{\r\nstruct imx_ssi *ssi = snd_soc_dai_get_drvdata(dai);\r\nunsigned int sier_bits, sier;\r\nunsigned int scr;\r\nscr = readl(ssi->base + SSI_SCR);\r\nsier = readl(ssi->base + SSI_SIER);\r\nif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {\r\nif (ssi->flags & IMX_SSI_DMA)\r\nsier_bits = SSI_SIER_TDMAE;\r\nelse\r\nsier_bits = SSI_SIER_TIE | SSI_SIER_TFE0_EN;\r\n} else {\r\nif (ssi->flags & IMX_SSI_DMA)\r\nsier_bits = SSI_SIER_RDMAE;\r\nelse\r\nsier_bits = SSI_SIER_RIE | SSI_SIER_RFF0_EN;\r\n}\r\nswitch (cmd) {\r\ncase SNDRV_PCM_TRIGGER_START:\r\ncase SNDRV_PCM_TRIGGER_RESUME:\r\ncase SNDRV_PCM_TRIGGER_PAUSE_RELEASE:\r\nif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)\r\nscr |= SSI_SCR_TE;\r\nelse\r\nscr |= SSI_SCR_RE;\r\nsier |= sier_bits;\r\nscr |= SSI_SCR_SSIEN;\r\nbreak;\r\ncase SNDRV_PCM_TRIGGER_STOP:\r\ncase SNDRV_PCM_TRIGGER_SUSPEND:\r\ncase SNDRV_PCM_TRIGGER_PAUSE_PUSH:\r\nif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)\r\nscr &= ~SSI_SCR_TE;\r\nelse\r\nscr &= ~SSI_SCR_RE;\r\nsier &= ~sier_bits;\r\nif (!(scr & (SSI_SCR_TE | SSI_SCR_RE)))\r\nscr &= ~SSI_SCR_SSIEN;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nif (!(ssi->flags & IMX_SSI_USE_AC97))\r\nwritel(scr, ssi->base + SSI_SCR);\r\nwritel(sier, ssi->base + SSI_SIER);\r\nreturn 0;\r\n}\r\nstatic int imx_ssi_dai_probe(struct snd_soc_dai *dai)\r\n{\r\nstruct imx_ssi *ssi = dev_get_drvdata(dai->dev);\r\nuint32_t val;\r\nsnd_soc_dai_set_drvdata(dai, ssi);\r\nval = SSI_SFCSR_TFWM0(ssi->dma_params_tx.maxburst) |\r\nSSI_SFCSR_RFWM0(ssi->dma_params_rx.maxburst);\r\nwritel(val, ssi->base + SSI_SFCSR);\r\ndai->playback_dma_data = &ssi->dma_params_tx;\r\ndai->capture_dma_data = &ssi->dma_params_rx;\r\nreturn 0;\r\n}\r\nstatic void setup_channel_to_ac97(struct imx_ssi *imx_ssi)\r\n{\r\nvoid __iomem *base = imx_ssi->base;\r\nwritel(0x0, base + SSI_SCR);\r\nwritel(0x0, base + SSI_STCR);\r\nwritel(0x0, base + SSI_SRCR);\r\nwritel(SSI_SCR_SYN | SSI_SCR_NET, base + SSI_SCR);\r\nwritel(SSI_SFCSR_RFWM0(8) |\r\nSSI_SFCSR_TFWM0(8) |\r\nSSI_SFCSR_RFWM1(8) |\r\nSSI_SFCSR_TFWM1(8), base + SSI_SFCSR);\r\nwritel(SSI_STCCR_WL(16) | SSI_STCCR_DC(12), base + SSI_STCCR);\r\nwritel(SSI_STCCR_WL(16) | SSI_STCCR_DC(12), base + SSI_SRCCR);\r\nwritel(SSI_SCR_SYN | SSI_SCR_NET | SSI_SCR_SSIEN, base + SSI_SCR);\r\nwritel(SSI_SOR_WAIT(3), base + SSI_SOR);\r\nwritel(SSI_SCR_SYN | SSI_SCR_NET | SSI_SCR_SSIEN |\r\nSSI_SCR_TE | SSI_SCR_RE,\r\nbase + SSI_SCR);\r\nwritel(SSI_SACNT_DEFAULT, base + SSI_SACNT);\r\nwritel(0xff, base + SSI_SACCDIS);\r\nwritel(0x300, base + SSI_SACCEN);\r\n}\r\nstatic void imx_ssi_ac97_write(struct snd_ac97 *ac97, unsigned short reg,\r\nunsigned short val)\r\n{\r\nstruct imx_ssi *imx_ssi = ac97_ssi;\r\nvoid __iomem *base = imx_ssi->base;\r\nunsigned int lreg;\r\nunsigned int lval;\r\nif (reg > 0x7f)\r\nreturn;\r\npr_debug("%s: 0x%02x 0x%04x\n", __func__, reg, val);\r\nlreg = reg << 12;\r\nwritel(lreg, base + SSI_SACADD);\r\nlval = val << 4;\r\nwritel(lval , base + SSI_SACDAT);\r\nwritel(SSI_SACNT_DEFAULT | SSI_SACNT_WR, base + SSI_SACNT);\r\nudelay(100);\r\n}\r\nstatic unsigned short imx_ssi_ac97_read(struct snd_ac97 *ac97,\r\nunsigned short reg)\r\n{\r\nstruct imx_ssi *imx_ssi = ac97_ssi;\r\nvoid __iomem *base = imx_ssi->base;\r\nunsigned short val = -1;\r\nunsigned int lreg;\r\nlreg = (reg & 0x7f) << 12 ;\r\nwritel(lreg, base + SSI_SACADD);\r\nwritel(SSI_SACNT_DEFAULT | SSI_SACNT_RD, base + SSI_SACNT);\r\nudelay(100);\r\nval = (readl(base + SSI_SACDAT) >> 4) & 0xffff;\r\npr_debug("%s: 0x%02x 0x%04x\n", __func__, reg, val);\r\nreturn val;\r\n}\r\nstatic void imx_ssi_ac97_reset(struct snd_ac97 *ac97)\r\n{\r\nstruct imx_ssi *imx_ssi = ac97_ssi;\r\nif (imx_ssi->ac97_reset)\r\nimx_ssi->ac97_reset(ac97);\r\nimx_ssi_ac97_read(ac97, 0);\r\n}\r\nstatic void imx_ssi_ac97_warm_reset(struct snd_ac97 *ac97)\r\n{\r\nstruct imx_ssi *imx_ssi = ac97_ssi;\r\nif (imx_ssi->ac97_warm_reset)\r\nimx_ssi->ac97_warm_reset(ac97);\r\nimx_ssi_ac97_read(ac97, 0);\r\n}\r\nstatic int imx_ssi_probe(struct platform_device *pdev)\r\n{\r\nstruct resource *res;\r\nstruct imx_ssi *ssi;\r\nstruct imx_ssi_platform_data *pdata = pdev->dev.platform_data;\r\nint ret = 0;\r\nstruct snd_soc_dai_driver *dai;\r\nssi = devm_kzalloc(&pdev->dev, sizeof(*ssi), GFP_KERNEL);\r\nif (!ssi)\r\nreturn -ENOMEM;\r\ndev_set_drvdata(&pdev->dev, ssi);\r\nif (pdata) {\r\nssi->ac97_reset = pdata->ac97_reset;\r\nssi->ac97_warm_reset = pdata->ac97_warm_reset;\r\nssi->flags = pdata->flags;\r\n}\r\nssi->irq = platform_get_irq(pdev, 0);\r\nssi->clk = devm_clk_get(&pdev->dev, NULL);\r\nif (IS_ERR(ssi->clk)) {\r\nret = PTR_ERR(ssi->clk);\r\ndev_err(&pdev->dev, "Cannot get the clock: %d\n",\r\nret);\r\ngoto failed_clk;\r\n}\r\nret = clk_prepare_enable(ssi->clk);\r\nif (ret)\r\ngoto failed_clk;\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nssi->base = devm_ioremap_resource(&pdev->dev, res);\r\nif (IS_ERR(ssi->base)) {\r\nret = PTR_ERR(ssi->base);\r\ngoto failed_register;\r\n}\r\nif (ssi->flags & IMX_SSI_USE_AC97) {\r\nif (ac97_ssi) {\r\ndev_err(&pdev->dev, "AC'97 SSI already registered\n");\r\nret = -EBUSY;\r\ngoto failed_register;\r\n}\r\nac97_ssi = ssi;\r\nsetup_channel_to_ac97(ssi);\r\ndai = &imx_ac97_dai;\r\n} else\r\ndai = &imx_ssi_dai;\r\nwritel(0x0, ssi->base + SSI_SIER);\r\nssi->dma_params_rx.addr = res->start + SSI_SRX0;\r\nssi->dma_params_tx.addr = res->start + SSI_STX0;\r\nssi->dma_params_tx.maxburst = 6;\r\nssi->dma_params_rx.maxburst = 4;\r\nssi->dma_params_tx.filter_data = &ssi->filter_data_tx;\r\nssi->dma_params_rx.filter_data = &ssi->filter_data_rx;\r\nres = platform_get_resource_byname(pdev, IORESOURCE_DMA, "tx0");\r\nif (res) {\r\nimx_pcm_dma_params_init_data(&ssi->filter_data_tx, res->start,\r\nIMX_DMATYPE_SSI);\r\n}\r\nres = platform_get_resource_byname(pdev, IORESOURCE_DMA, "rx0");\r\nif (res) {\r\nimx_pcm_dma_params_init_data(&ssi->filter_data_rx, res->start,\r\nIMX_DMATYPE_SSI);\r\n}\r\nplatform_set_drvdata(pdev, ssi);\r\nret = snd_soc_set_ac97_ops(&imx_ssi_ac97_ops);\r\nif (ret != 0) {\r\ndev_err(&pdev->dev, "Failed to set AC'97 ops: %d\n", ret);\r\ngoto failed_register;\r\n}\r\nret = snd_soc_register_component(&pdev->dev, &imx_component,\r\ndai, 1);\r\nif (ret) {\r\ndev_err(&pdev->dev, "register DAI failed\n");\r\ngoto failed_register;\r\n}\r\nssi->fiq_params.irq = ssi->irq;\r\nssi->fiq_params.base = ssi->base;\r\nssi->fiq_params.dma_params_rx = &ssi->dma_params_rx;\r\nssi->fiq_params.dma_params_tx = &ssi->dma_params_tx;\r\nssi->fiq_init = imx_pcm_fiq_init(pdev, &ssi->fiq_params);\r\nssi->dma_init = imx_pcm_dma_init(pdev, IMX_SSI_DMABUF_SIZE);\r\nif (ssi->fiq_init && ssi->dma_init) {\r\nret = ssi->fiq_init;\r\ngoto failed_pcm;\r\n}\r\nreturn 0;\r\nfailed_pcm:\r\nsnd_soc_unregister_component(&pdev->dev);\r\nfailed_register:\r\nclk_disable_unprepare(ssi->clk);\r\nfailed_clk:\r\nsnd_soc_set_ac97_ops(NULL);\r\nreturn ret;\r\n}\r\nstatic int imx_ssi_remove(struct platform_device *pdev)\r\n{\r\nstruct imx_ssi *ssi = platform_get_drvdata(pdev);\r\nif (!ssi->fiq_init)\r\nimx_pcm_fiq_exit(pdev);\r\nsnd_soc_unregister_component(&pdev->dev);\r\nif (ssi->flags & IMX_SSI_USE_AC97)\r\nac97_ssi = NULL;\r\nclk_disable_unprepare(ssi->clk);\r\nsnd_soc_set_ac97_ops(NULL);\r\nreturn 0;\r\n}
