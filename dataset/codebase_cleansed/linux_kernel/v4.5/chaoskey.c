static void chaoskey_free(struct chaoskey *dev)\r\n{\r\nusb_dbg(dev->interface, "free");\r\nkfree(dev->name);\r\nkfree(dev->buf);\r\nkfree(dev);\r\n}\r\nstatic int chaoskey_probe(struct usb_interface *interface,\r\nconst struct usb_device_id *id)\r\n{\r\nstruct usb_device *udev = interface_to_usbdev(interface);\r\nstruct usb_host_interface *altsetting = interface->cur_altsetting;\r\nint i;\r\nint in_ep = -1;\r\nstruct chaoskey *dev;\r\nint result;\r\nint size;\r\nusb_dbg(interface, "probe %s-%s", udev->product, udev->serial);\r\nfor (i = 0; i < altsetting->desc.bNumEndpoints; i++) {\r\nif (usb_endpoint_is_bulk_in(&altsetting->endpoint[i].desc)) {\r\nin_ep = usb_endpoint_num(&altsetting->endpoint[i].desc);\r\nsize = usb_endpoint_maxp(&altsetting->endpoint[i].desc);\r\nbreak;\r\n}\r\n}\r\nif (in_ep == -1) {\r\nusb_dbg(interface, "no IN endpoint found");\r\nreturn -ENODEV;\r\n}\r\nif (size <= 0) {\r\nusb_dbg(interface, "invalid size (%d)", size);\r\nreturn -ENODEV;\r\n}\r\nif (size > CHAOSKEY_BUF_LEN) {\r\nusb_dbg(interface, "size reduced from %d to %d\n",\r\nsize, CHAOSKEY_BUF_LEN);\r\nsize = CHAOSKEY_BUF_LEN;\r\n}\r\ndev = kzalloc(sizeof(struct chaoskey), GFP_KERNEL);\r\nif (dev == NULL)\r\nreturn -ENOMEM;\r\ndev->buf = kmalloc(size, GFP_KERNEL);\r\nif (dev->buf == NULL) {\r\nkfree(dev);\r\nreturn -ENOMEM;\r\n}\r\nif (udev->product && udev->serial) {\r\ndev->name = kmalloc(strlen(udev->product) + 1 +\r\nstrlen(udev->serial) + 1, GFP_KERNEL);\r\nif (dev->name == NULL) {\r\nkfree(dev->buf);\r\nkfree(dev);\r\nreturn -ENOMEM;\r\n}\r\nstrcpy(dev->name, udev->product);\r\nstrcat(dev->name, "-");\r\nstrcat(dev->name, udev->serial);\r\n}\r\ndev->interface = interface;\r\ndev->in_ep = in_ep;\r\ndev->size = size;\r\ndev->present = 1;\r\ninit_waitqueue_head(&dev->wait_q);\r\nmutex_init(&dev->lock);\r\nmutex_init(&dev->rng_lock);\r\nusb_set_intfdata(interface, dev);\r\nresult = usb_register_dev(interface, &chaoskey_class);\r\nif (result) {\r\nusb_err(interface, "Unable to allocate minor number.");\r\nusb_set_intfdata(interface, NULL);\r\nchaoskey_free(dev);\r\nreturn result;\r\n}\r\ndev->hwrng.name = dev->name ? dev->name : chaoskey_driver.name;\r\ndev->hwrng.read = chaoskey_rng_read;\r\ndev->hwrng.quality = 1024 + 1023;\r\ndev->hwrng_registered = (hwrng_register(&dev->hwrng) == 0);\r\nif (!dev->hwrng_registered)\r\nusb_err(interface, "Unable to register with hwrng");\r\nusb_enable_autosuspend(udev);\r\nusb_dbg(interface, "chaoskey probe success, size %d", dev->size);\r\nreturn 0;\r\n}\r\nstatic void chaoskey_disconnect(struct usb_interface *interface)\r\n{\r\nstruct chaoskey *dev;\r\nusb_dbg(interface, "disconnect");\r\ndev = usb_get_intfdata(interface);\r\nif (!dev) {\r\nusb_dbg(interface, "disconnect failed - no dev");\r\nreturn;\r\n}\r\nif (dev->hwrng_registered)\r\nhwrng_unregister(&dev->hwrng);\r\nusb_deregister_dev(interface, &chaoskey_class);\r\nusb_set_intfdata(interface, NULL);\r\nmutex_lock(&dev->lock);\r\ndev->present = 0;\r\nif (!dev->open) {\r\nmutex_unlock(&dev->lock);\r\nchaoskey_free(dev);\r\n} else\r\nmutex_unlock(&dev->lock);\r\nusb_dbg(interface, "disconnect done");\r\n}\r\nstatic int chaoskey_open(struct inode *inode, struct file *file)\r\n{\r\nstruct chaoskey *dev;\r\nstruct usb_interface *interface;\r\ninterface = usb_find_interface(&chaoskey_driver, iminor(inode));\r\nif (!interface)\r\nreturn -ENODEV;\r\nusb_dbg(interface, "open");\r\ndev = usb_get_intfdata(interface);\r\nif (!dev) {\r\nusb_dbg(interface, "open (dev)");\r\nreturn -ENODEV;\r\n}\r\nfile->private_data = dev;\r\nmutex_lock(&dev->lock);\r\n++dev->open;\r\nmutex_unlock(&dev->lock);\r\nusb_dbg(interface, "open success");\r\nreturn 0;\r\n}\r\nstatic int chaoskey_release(struct inode *inode, struct file *file)\r\n{\r\nstruct chaoskey *dev = file->private_data;\r\nstruct usb_interface *interface;\r\nif (dev == NULL)\r\nreturn -ENODEV;\r\ninterface = dev->interface;\r\nusb_dbg(interface, "release");\r\nmutex_lock(&dev->lock);\r\nusb_dbg(interface, "open count at release is %d", dev->open);\r\nif (dev->open <= 0) {\r\nusb_dbg(interface, "invalid open count (%d)", dev->open);\r\nmutex_unlock(&dev->lock);\r\nreturn -ENODEV;\r\n}\r\n--dev->open;\r\nif (!dev->present) {\r\nif (dev->open == 0) {\r\nmutex_unlock(&dev->lock);\r\nchaoskey_free(dev);\r\n} else\r\nmutex_unlock(&dev->lock);\r\n} else\r\nmutex_unlock(&dev->lock);\r\nusb_dbg(interface, "release success");\r\nreturn 0;\r\n}\r\nstatic int _chaoskey_fill(struct chaoskey *dev)\r\n{\r\nDEFINE_WAIT(wait);\r\nint result;\r\nint this_read;\r\nstruct usb_device *udev = interface_to_usbdev(dev->interface);\r\nusb_dbg(dev->interface, "fill");\r\nif (dev->valid != dev->used) {\r\nusb_dbg(dev->interface, "not empty yet (valid %d used %d)",\r\ndev->valid, dev->used);\r\nreturn 0;\r\n}\r\nif (!dev->present) {\r\nusb_dbg(dev->interface, "device not present");\r\nreturn -ENODEV;\r\n}\r\nresult = usb_autopm_get_interface(dev->interface);\r\nif (result) {\r\nusb_dbg(dev->interface, "wakeup failed (result %d)", result);\r\nreturn result;\r\n}\r\nresult = usb_bulk_msg(udev,\r\nusb_rcvbulkpipe(udev, dev->in_ep),\r\ndev->buf, dev->size, &this_read,\r\nNAK_TIMEOUT);\r\nusb_autopm_put_interface(dev->interface);\r\nif (result == 0) {\r\ndev->valid = this_read;\r\ndev->used = 0;\r\n}\r\nusb_dbg(dev->interface, "bulk_msg result %d this_read %d",\r\nresult, this_read);\r\nreturn result;\r\n}\r\nstatic ssize_t chaoskey_read(struct file *file,\r\nchar __user *buffer,\r\nsize_t count,\r\nloff_t *ppos)\r\n{\r\nstruct chaoskey *dev;\r\nssize_t read_count = 0;\r\nint this_time;\r\nint result = 0;\r\nunsigned long remain;\r\ndev = file->private_data;\r\nif (dev == NULL || !dev->present)\r\nreturn -ENODEV;\r\nusb_dbg(dev->interface, "read %zu", count);\r\nwhile (count > 0) {\r\nresult = mutex_lock_interruptible(&dev->rng_lock);\r\nif (result)\r\ngoto bail;\r\nmutex_unlock(&dev->rng_lock);\r\nresult = mutex_lock_interruptible(&dev->lock);\r\nif (result)\r\ngoto bail;\r\nif (dev->valid == dev->used) {\r\nresult = _chaoskey_fill(dev);\r\nif (result) {\r\nmutex_unlock(&dev->lock);\r\ngoto bail;\r\n}\r\nif (dev->used == dev->valid) {\r\nmutex_unlock(&dev->lock);\r\ngoto bail;\r\n}\r\n}\r\nthis_time = dev->valid - dev->used;\r\nif (this_time > count)\r\nthis_time = count;\r\nremain = copy_to_user(buffer, dev->buf + dev->used, this_time);\r\nif (remain) {\r\nresult = -EFAULT;\r\ndev->used += this_time - remain;\r\nmutex_unlock(&dev->lock);\r\ngoto bail;\r\n}\r\ncount -= this_time;\r\nread_count += this_time;\r\nbuffer += this_time;\r\ndev->used += this_time;\r\nmutex_unlock(&dev->lock);\r\n}\r\nbail:\r\nif (read_count) {\r\nusb_dbg(dev->interface, "read %zu bytes", read_count);\r\nreturn read_count;\r\n}\r\nusb_dbg(dev->interface, "empty read, result %d", result);\r\nreturn result;\r\n}\r\nstatic int chaoskey_rng_read(struct hwrng *rng, void *data,\r\nsize_t max, bool wait)\r\n{\r\nstruct chaoskey *dev = container_of(rng, struct chaoskey, hwrng);\r\nint this_time;\r\nusb_dbg(dev->interface, "rng_read max %zu wait %d", max, wait);\r\nif (!dev->present) {\r\nusb_dbg(dev->interface, "device not present");\r\nreturn 0;\r\n}\r\nmutex_lock(&dev->rng_lock);\r\nmutex_lock(&dev->lock);\r\nmutex_unlock(&dev->rng_lock);\r\nif (dev->valid == dev->used)\r\n(void) _chaoskey_fill(dev);\r\nthis_time = dev->valid - dev->used;\r\nif (this_time > max)\r\nthis_time = max;\r\nmemcpy(data, dev->buf + dev->used, this_time);\r\ndev->used += this_time;\r\nmutex_unlock(&dev->lock);\r\nusb_dbg(dev->interface, "rng_read this_time %d\n", this_time);\r\nreturn this_time;\r\n}\r\nstatic int chaoskey_suspend(struct usb_interface *interface,\r\npm_message_t message)\r\n{\r\nusb_dbg(interface, "suspend");\r\nreturn 0;\r\n}\r\nstatic int chaoskey_resume(struct usb_interface *interface)\r\n{\r\nusb_dbg(interface, "resume");\r\nreturn 0;\r\n}
