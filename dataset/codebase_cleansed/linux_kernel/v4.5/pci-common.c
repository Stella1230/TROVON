struct pci_controller *pcibios_alloc_controller(struct device_node *dev)\r\n{\r\nstruct pci_controller *phb;\r\nphb = zalloc_maybe_bootmem(sizeof(struct pci_controller), GFP_KERNEL);\r\nif (!phb)\r\nreturn NULL;\r\nspin_lock(&hose_spinlock);\r\nphb->global_number = global_phb_number++;\r\nlist_add_tail(&phb->list_node, &hose_list);\r\nspin_unlock(&hose_spinlock);\r\nphb->dn = dev;\r\nphb->is_dynamic = mem_init_done;\r\nreturn phb;\r\n}\r\nvoid pcibios_free_controller(struct pci_controller *phb)\r\n{\r\nspin_lock(&hose_spinlock);\r\nlist_del(&phb->list_node);\r\nspin_unlock(&hose_spinlock);\r\nif (phb->is_dynamic)\r\nkfree(phb);\r\n}\r\nstatic resource_size_t pcibios_io_size(const struct pci_controller *hose)\r\n{\r\nreturn resource_size(&hose->io_resource);\r\n}\r\nint pcibios_vaddr_is_ioport(void __iomem *address)\r\n{\r\nint ret = 0;\r\nstruct pci_controller *hose;\r\nresource_size_t size;\r\nspin_lock(&hose_spinlock);\r\nlist_for_each_entry(hose, &hose_list, list_node) {\r\nsize = pcibios_io_size(hose);\r\nif (address >= hose->io_base_virt &&\r\naddress < (hose->io_base_virt + size)) {\r\nret = 1;\r\nbreak;\r\n}\r\n}\r\nspin_unlock(&hose_spinlock);\r\nreturn ret;\r\n}\r\nunsigned long pci_address_to_pio(phys_addr_t address)\r\n{\r\nstruct pci_controller *hose;\r\nresource_size_t size;\r\nunsigned long ret = ~0;\r\nspin_lock(&hose_spinlock);\r\nlist_for_each_entry(hose, &hose_list, list_node) {\r\nsize = pcibios_io_size(hose);\r\nif (address >= hose->io_base_phys &&\r\naddress < (hose->io_base_phys + size)) {\r\nunsigned long base =\r\n(unsigned long)hose->io_base_virt - _IO_BASE;\r\nret = base + (address - hose->io_base_phys);\r\nbreak;\r\n}\r\n}\r\nspin_unlock(&hose_spinlock);\r\nreturn ret;\r\n}\r\nint pci_domain_nr(struct pci_bus *bus)\r\n{\r\nstruct pci_controller *hose = pci_bus_to_host(bus);\r\nreturn hose->global_number;\r\n}\r\nstruct pci_controller *pci_find_hose_for_OF_device(struct device_node *node)\r\n{\r\nwhile (node) {\r\nstruct pci_controller *hose, *tmp;\r\nlist_for_each_entry_safe(hose, tmp, &hose_list, list_node)\r\nif (hose->dn == node)\r\nreturn hose;\r\nnode = node->parent;\r\n}\r\nreturn NULL;\r\n}\r\nvoid pcibios_set_master(struct pci_dev *dev)\r\n{\r\n}\r\nstatic struct resource *__pci_mmap_make_offset(struct pci_dev *dev,\r\nresource_size_t *offset,\r\nenum pci_mmap_state mmap_state)\r\n{\r\nstruct pci_controller *hose = pci_bus_to_host(dev->bus);\r\nunsigned long io_offset = 0;\r\nint i, res_bit;\r\nif (!hose)\r\nreturn NULL;\r\nif (mmap_state == pci_mmap_mem) {\r\n#if 0\r\n*offset += hose->pci_mem_offset;\r\n#endif\r\nres_bit = IORESOURCE_MEM;\r\n} else {\r\nio_offset = (unsigned long)hose->io_base_virt - _IO_BASE;\r\n*offset += io_offset;\r\nres_bit = IORESOURCE_IO;\r\n}\r\nfor (i = 0; i <= PCI_ROM_RESOURCE; i++) {\r\nstruct resource *rp = &dev->resource[i];\r\nint flags = rp->flags;\r\nif (i == PCI_ROM_RESOURCE)\r\nflags |= IORESOURCE_MEM;\r\nif ((flags & res_bit) == 0)\r\ncontinue;\r\nif (*offset < (rp->start & PAGE_MASK) || *offset > rp->end)\r\ncontinue;\r\nif (mmap_state == pci_mmap_io)\r\n*offset += hose->io_base_phys - io_offset;\r\nreturn rp;\r\n}\r\nreturn NULL;\r\n}\r\nstatic pgprot_t __pci_mmap_set_pgprot(struct pci_dev *dev, struct resource *rp,\r\npgprot_t protection,\r\nenum pci_mmap_state mmap_state,\r\nint write_combine)\r\n{\r\npgprot_t prot = protection;\r\nif (mmap_state != pci_mmap_mem)\r\nwrite_combine = 0;\r\nelse if (write_combine == 0) {\r\nif (rp->flags & IORESOURCE_PREFETCH)\r\nwrite_combine = 1;\r\n}\r\nreturn pgprot_noncached(prot);\r\n}\r\npgprot_t pci_phys_mem_access_prot(struct file *file,\r\nunsigned long pfn,\r\nunsigned long size,\r\npgprot_t prot)\r\n{\r\nstruct pci_dev *pdev = NULL;\r\nstruct resource *found = NULL;\r\nresource_size_t offset = ((resource_size_t)pfn) << PAGE_SHIFT;\r\nint i;\r\nif (page_is_ram(pfn))\r\nreturn prot;\r\nprot = pgprot_noncached(prot);\r\nfor_each_pci_dev(pdev) {\r\nfor (i = 0; i <= PCI_ROM_RESOURCE; i++) {\r\nstruct resource *rp = &pdev->resource[i];\r\nint flags = rp->flags;\r\nif ((flags & IORESOURCE_MEM) == 0)\r\ncontinue;\r\nif (offset < (rp->start & PAGE_MASK) ||\r\noffset > rp->end)\r\ncontinue;\r\nfound = rp;\r\nbreak;\r\n}\r\nif (found)\r\nbreak;\r\n}\r\nif (found) {\r\nif (found->flags & IORESOURCE_PREFETCH)\r\nprot = pgprot_noncached_wc(prot);\r\npci_dev_put(pdev);\r\n}\r\npr_debug("PCI: Non-PCI map for %llx, prot: %lx\n",\r\n(unsigned long long)offset, pgprot_val(prot));\r\nreturn prot;\r\n}\r\nint pci_mmap_page_range(struct pci_dev *dev, struct vm_area_struct *vma,\r\nenum pci_mmap_state mmap_state, int write_combine)\r\n{\r\nresource_size_t offset =\r\n((resource_size_t)vma->vm_pgoff) << PAGE_SHIFT;\r\nstruct resource *rp;\r\nint ret;\r\nrp = __pci_mmap_make_offset(dev, &offset, mmap_state);\r\nif (rp == NULL)\r\nreturn -EINVAL;\r\nvma->vm_pgoff = offset >> PAGE_SHIFT;\r\nvma->vm_page_prot = __pci_mmap_set_pgprot(dev, rp,\r\nvma->vm_page_prot,\r\nmmap_state, write_combine);\r\nret = remap_pfn_range(vma, vma->vm_start, vma->vm_pgoff,\r\nvma->vm_end - vma->vm_start, vma->vm_page_prot);\r\nreturn ret;\r\n}\r\nint pci_legacy_read(struct pci_bus *bus, loff_t port, u32 *val, size_t size)\r\n{\r\nunsigned long offset;\r\nstruct pci_controller *hose = pci_bus_to_host(bus);\r\nstruct resource *rp = &hose->io_resource;\r\nvoid __iomem *addr;\r\noffset = (unsigned long)hose->io_base_virt - _IO_BASE;\r\noffset += port;\r\nif (!(rp->flags & IORESOURCE_IO))\r\nreturn -ENXIO;\r\nif (offset < rp->start || (offset + size) > rp->end)\r\nreturn -ENXIO;\r\naddr = hose->io_base_virt + port;\r\nswitch (size) {\r\ncase 1:\r\n*((u8 *)val) = in_8(addr);\r\nreturn 1;\r\ncase 2:\r\nif (port & 1)\r\nreturn -EINVAL;\r\n*((u16 *)val) = in_le16(addr);\r\nreturn 2;\r\ncase 4:\r\nif (port & 3)\r\nreturn -EINVAL;\r\n*((u32 *)val) = in_le32(addr);\r\nreturn 4;\r\n}\r\nreturn -EINVAL;\r\n}\r\nint pci_legacy_write(struct pci_bus *bus, loff_t port, u32 val, size_t size)\r\n{\r\nunsigned long offset;\r\nstruct pci_controller *hose = pci_bus_to_host(bus);\r\nstruct resource *rp = &hose->io_resource;\r\nvoid __iomem *addr;\r\noffset = (unsigned long)hose->io_base_virt - _IO_BASE;\r\noffset += port;\r\nif (!(rp->flags & IORESOURCE_IO))\r\nreturn -ENXIO;\r\nif (offset < rp->start || (offset + size) > rp->end)\r\nreturn -ENXIO;\r\naddr = hose->io_base_virt + port;\r\nswitch (size) {\r\ncase 1:\r\nout_8(addr, val >> 24);\r\nreturn 1;\r\ncase 2:\r\nif (port & 1)\r\nreturn -EINVAL;\r\nout_le16(addr, val >> 16);\r\nreturn 2;\r\ncase 4:\r\nif (port & 3)\r\nreturn -EINVAL;\r\nout_le32(addr, val);\r\nreturn 4;\r\n}\r\nreturn -EINVAL;\r\n}\r\nint pci_mmap_legacy_page_range(struct pci_bus *bus,\r\nstruct vm_area_struct *vma,\r\nenum pci_mmap_state mmap_state)\r\n{\r\nstruct pci_controller *hose = pci_bus_to_host(bus);\r\nresource_size_t offset =\r\n((resource_size_t)vma->vm_pgoff) << PAGE_SHIFT;\r\nresource_size_t size = vma->vm_end - vma->vm_start;\r\nstruct resource *rp;\r\npr_debug("pci_mmap_legacy_page_range(%04x:%02x, %s @%llx..%llx)\n",\r\npci_domain_nr(bus), bus->number,\r\nmmap_state == pci_mmap_mem ? "MEM" : "IO",\r\n(unsigned long long)offset,\r\n(unsigned long long)(offset + size - 1));\r\nif (mmap_state == pci_mmap_mem) {\r\nif ((offset + size) > hose->isa_mem_size) {\r\n#ifdef CONFIG_MMU\r\npr_debug("Process %s (pid:%d) mapped non-existing PCI",\r\ncurrent->comm, current->pid);\r\npr_debug("legacy memory for 0%04x:%02x\n",\r\npci_domain_nr(bus), bus->number);\r\n#endif\r\nif (vma->vm_flags & VM_SHARED)\r\nreturn shmem_zero_setup(vma);\r\nreturn 0;\r\n}\r\noffset += hose->isa_mem_phys;\r\n} else {\r\nunsigned long io_offset = (unsigned long)hose->io_base_virt -\r\n_IO_BASE;\r\nunsigned long roffset = offset + io_offset;\r\nrp = &hose->io_resource;\r\nif (!(rp->flags & IORESOURCE_IO))\r\nreturn -ENXIO;\r\nif (roffset < rp->start || (roffset + size) > rp->end)\r\nreturn -ENXIO;\r\noffset += hose->io_base_phys;\r\n}\r\npr_debug(" -> mapping phys %llx\n", (unsigned long long)offset);\r\nvma->vm_pgoff = offset >> PAGE_SHIFT;\r\nvma->vm_page_prot = pgprot_noncached(vma->vm_page_prot);\r\nreturn remap_pfn_range(vma, vma->vm_start, vma->vm_pgoff,\r\nvma->vm_end - vma->vm_start,\r\nvma->vm_page_prot);\r\n}\r\nvoid pci_resource_to_user(const struct pci_dev *dev, int bar,\r\nconst struct resource *rsrc,\r\nresource_size_t *start, resource_size_t *end)\r\n{\r\nstruct pci_controller *hose = pci_bus_to_host(dev->bus);\r\nresource_size_t offset = 0;\r\nif (hose == NULL)\r\nreturn;\r\nif (rsrc->flags & IORESOURCE_IO)\r\noffset = (unsigned long)hose->io_base_virt - _IO_BASE;\r\n#if 0\r\nelse if (rsrc->flags & IORESOURCE_MEM)\r\noffset = hose->pci_mem_offset;\r\n#endif\r\n*start = rsrc->start - offset;\r\n*end = rsrc->end - offset;\r\n}\r\nvoid pci_process_bridge_OF_ranges(struct pci_controller *hose,\r\nstruct device_node *dev, int primary)\r\n{\r\nint memno = 0, isa_hole = -1;\r\nunsigned long long isa_mb = 0;\r\nstruct resource *res;\r\nstruct of_pci_range range;\r\nstruct of_pci_range_parser parser;\r\npr_info("PCI host bridge %s %s ranges:\n",\r\ndev->full_name, primary ? "(primary)" : "");\r\nif (of_pci_range_parser_init(&parser, dev))\r\nreturn;\r\npr_debug("Parsing ranges property...\n");\r\nfor_each_of_pci_range(&parser, &range) {\r\npr_debug("pci_space: 0x%08x pci_addr:0x%016llx ",\r\nrange.pci_space, range.pci_addr);\r\npr_debug("cpu_addr:0x%016llx size:0x%016llx\n",\r\nrange.cpu_addr, range.size);\r\nif (range.cpu_addr == OF_BAD_ADDR || range.size == 0)\r\ncontinue;\r\nres = NULL;\r\nswitch (range.flags & IORESOURCE_TYPE_BITS) {\r\ncase IORESOURCE_IO:\r\npr_info(" IO 0x%016llx..0x%016llx -> 0x%016llx\n",\r\nrange.cpu_addr, range.cpu_addr + range.size - 1,\r\nrange.pci_addr);\r\nif (hose->pci_io_size) {\r\npr_info(" \\--> Skipped (too many) !\n");\r\ncontinue;\r\n}\r\nif (range.size > 0x01000000)\r\nrange.size = 0x01000000;\r\nhose->io_base_virt = ioremap(range.cpu_addr,\r\nrange.size);\r\nif (primary)\r\nisa_io_base =\r\n(unsigned long)hose->io_base_virt;\r\nhose->pci_io_size = range.pci_addr + range.size;\r\nhose->io_base_phys = range.cpu_addr - range.pci_addr;\r\nres = &hose->io_resource;\r\nrange.cpu_addr = range.pci_addr;\r\nbreak;\r\ncase IORESOURCE_MEM:\r\npr_info(" MEM 0x%016llx..0x%016llx -> 0x%016llx %s\n",\r\nrange.cpu_addr, range.cpu_addr + range.size - 1,\r\nrange.pci_addr,\r\n(range.pci_space & 0x40000000) ?\r\n"Prefetch" : "");\r\nif (memno >= 3) {\r\npr_info(" \\--> Skipped (too many) !\n");\r\ncontinue;\r\n}\r\nif (range.pci_addr == 0) {\r\nisa_mb = range.cpu_addr;\r\nisa_hole = memno;\r\nif (primary || isa_mem_base == 0)\r\nisa_mem_base = range.cpu_addr;\r\nhose->isa_mem_phys = range.cpu_addr;\r\nhose->isa_mem_size = range.size;\r\n}\r\nif (memno == 0 ||\r\n(isa_hole >= 0 && range.pci_addr != 0 &&\r\nhose->pci_mem_offset == isa_mb))\r\nhose->pci_mem_offset = range.cpu_addr -\r\nrange.pci_addr;\r\nelse if (range.pci_addr != 0 &&\r\nhose->pci_mem_offset != range.cpu_addr -\r\nrange.pci_addr) {\r\npr_info(" \\--> Skipped (offset mismatch) !\n");\r\ncontinue;\r\n}\r\nres = &hose->mem_resources[memno++];\r\nbreak;\r\n}\r\nif (res != NULL) {\r\nres->name = dev->full_name;\r\nres->flags = range.flags;\r\nres->start = range.cpu_addr;\r\nres->end = range.cpu_addr + range.size - 1;\r\nres->parent = res->child = res->sibling = NULL;\r\n}\r\n}\r\nif (isa_hole >= 0 && hose->pci_mem_offset != isa_mb) {\r\nunsigned int next = isa_hole + 1;\r\npr_info(" Removing ISA hole at 0x%016llx\n", isa_mb);\r\nif (next < memno)\r\nmemmove(&hose->mem_resources[isa_hole],\r\n&hose->mem_resources[next],\r\nsizeof(struct resource) * (memno - next));\r\nhose->mem_resources[--memno].flags = 0;\r\n}\r\n}\r\nint pci_proc_domain(struct pci_bus *bus)\r\n{\r\nreturn 0;\r\n}\r\nstatic void pcibios_fixup_resources(struct pci_dev *dev)\r\n{\r\nstruct pci_controller *hose = pci_bus_to_host(dev->bus);\r\nint i;\r\nif (!hose) {\r\npr_err("No host bridge for PCI dev %s !\n",\r\npci_name(dev));\r\nreturn;\r\n}\r\nfor (i = 0; i < DEVICE_COUNT_RESOURCE; i++) {\r\nstruct resource *res = dev->resource + i;\r\nif (!res->flags)\r\ncontinue;\r\nif (res->start == 0) {\r\npr_debug("PCI:%s Resource %d %016llx-%016llx [%x]",\r\npci_name(dev), i,\r\n(unsigned long long)res->start,\r\n(unsigned long long)res->end,\r\n(unsigned int)res->flags);\r\npr_debug("is unassigned\n");\r\nres->end -= res->start;\r\nres->start = 0;\r\nres->flags |= IORESOURCE_UNSET;\r\ncontinue;\r\n}\r\npr_debug("PCI:%s Resource %d %016llx-%016llx [%x]\n",\r\npci_name(dev), i,\r\n(unsigned long long)res->start,\r\n(unsigned long long)res->end,\r\n(unsigned int)res->flags);\r\n}\r\n}\r\nstatic int pcibios_uninitialized_bridge_resource(struct pci_bus *bus,\r\nstruct resource *res)\r\n{\r\nstruct pci_controller *hose = pci_bus_to_host(bus);\r\nstruct pci_dev *dev = bus->self;\r\nresource_size_t offset;\r\nu16 command;\r\nint i;\r\nif (res->flags & IORESOURCE_MEM) {\r\nif (res->start != hose->pci_mem_offset)\r\nreturn 0;\r\npci_read_config_word(dev, PCI_COMMAND, &command);\r\nif ((command & PCI_COMMAND_MEMORY) == 0)\r\nreturn 1;\r\nfor (i = 0; i < 3; i++) {\r\nif ((hose->mem_resources[i].flags & IORESOURCE_MEM) &&\r\nhose->mem_resources[i].start == hose->pci_mem_offset)\r\nreturn 0;\r\n}\r\nreturn 1;\r\n} else {\r\noffset = (unsigned long)hose->io_base_virt - _IO_BASE;\r\nif (((res->start - offset) & 0xfffffffful) != 0)\r\nreturn 0;\r\npci_read_config_word(dev, PCI_COMMAND, &command);\r\nif (command & PCI_COMMAND_IO)\r\nreturn 0;\r\nreturn 1;\r\n}\r\n}\r\nstatic void pcibios_fixup_bridge(struct pci_bus *bus)\r\n{\r\nstruct resource *res;\r\nint i;\r\nstruct pci_dev *dev = bus->self;\r\npci_bus_for_each_resource(bus, res, i) {\r\nif (!res)\r\ncontinue;\r\nif (!res->flags)\r\ncontinue;\r\nif (i >= 3 && bus->self->transparent)\r\ncontinue;\r\npr_debug("PCI:%s Bus rsrc %d %016llx-%016llx [%x] fixup...\n",\r\npci_name(dev), i,\r\n(unsigned long long)res->start,\r\n(unsigned long long)res->end,\r\n(unsigned int)res->flags);\r\nif (pcibios_uninitialized_bridge_resource(bus, res)) {\r\nres->flags = 0;\r\npr_debug("PCI:%s (unassigned)\n",\r\npci_name(dev));\r\n} else {\r\npr_debug("PCI:%s %016llx-%016llx\n",\r\npci_name(dev),\r\n(unsigned long long)res->start,\r\n(unsigned long long)res->end);\r\n}\r\n}\r\n}\r\nvoid pcibios_setup_bus_self(struct pci_bus *bus)\r\n{\r\nif (bus->self != NULL)\r\npcibios_fixup_bridge(bus);\r\n}\r\nvoid pcibios_setup_bus_devices(struct pci_bus *bus)\r\n{\r\nstruct pci_dev *dev;\r\npr_debug("PCI: Fixup bus devices %d (%s)\n",\r\nbus->number, bus->self ? pci_name(bus->self) : "PHB");\r\nlist_for_each_entry(dev, &bus->devices, bus_list) {\r\ndev->dev.of_node = pci_device_to_OF_node(dev);\r\nset_dev_node(&dev->dev, pcibus_to_node(dev->bus));\r\ndev->irq = of_irq_parse_and_map_pci(dev, 0, 0);\r\n}\r\n}\r\nvoid pcibios_fixup_bus(struct pci_bus *bus)\r\n{\r\nif (bus->self != NULL)\r\npci_read_bridge_bases(bus);\r\npcibios_setup_bus_self(bus);\r\npcibios_setup_bus_devices(bus);\r\n}\r\nstatic int skip_isa_ioresource_align(struct pci_dev *dev)\r\n{\r\nreturn 0;\r\n}\r\nresource_size_t pcibios_align_resource(void *data, const struct resource *res,\r\nresource_size_t size, resource_size_t align)\r\n{\r\nstruct pci_dev *dev = data;\r\nresource_size_t start = res->start;\r\nif (res->flags & IORESOURCE_IO) {\r\nif (skip_isa_ioresource_align(dev))\r\nreturn start;\r\nif (start & 0x300)\r\nstart = (start + 0x3ff) & ~0x3ff;\r\n}\r\nreturn start;\r\n}\r\nstatic int __init reparent_resources(struct resource *parent,\r\nstruct resource *res)\r\n{\r\nstruct resource *p, **pp;\r\nstruct resource **firstpp = NULL;\r\nfor (pp = &parent->child; (p = *pp) != NULL; pp = &p->sibling) {\r\nif (p->end < res->start)\r\ncontinue;\r\nif (res->end < p->start)\r\nbreak;\r\nif (p->start < res->start || p->end > res->end)\r\nreturn -1;\r\nif (firstpp == NULL)\r\nfirstpp = pp;\r\n}\r\nif (firstpp == NULL)\r\nreturn -1;\r\nres->parent = parent;\r\nres->child = *firstpp;\r\nres->sibling = *pp;\r\n*firstpp = res;\r\n*pp = NULL;\r\nfor (p = res->child; p != NULL; p = p->sibling) {\r\np->parent = res;\r\npr_debug("PCI: Reparented %s [%llx..%llx] under %s\n",\r\np->name,\r\n(unsigned long long)p->start,\r\n(unsigned long long)p->end, res->name);\r\n}\r\nreturn 0;\r\n}\r\nstatic void pcibios_allocate_bus_resources(struct pci_bus *bus)\r\n{\r\nstruct pci_bus *b;\r\nint i;\r\nstruct resource *res, *pr;\r\npr_debug("PCI: Allocating bus resources for %04x:%02x...\n",\r\npci_domain_nr(bus), bus->number);\r\npci_bus_for_each_resource(bus, res, i) {\r\nif (!res || !res->flags\r\n|| res->start > res->end || res->parent)\r\ncontinue;\r\nif (bus->parent == NULL)\r\npr = (res->flags & IORESOURCE_IO) ?\r\n&ioport_resource : &iomem_resource;\r\nelse {\r\npr = pci_find_parent_resource(bus->self, res);\r\nif (pr == res) {\r\ncontinue;\r\n}\r\n}\r\npr_debug("PCI: %s (bus %d) bridge rsrc %d: %016llx-%016llx ",\r\nbus->self ? pci_name(bus->self) : "PHB",\r\nbus->number, i,\r\n(unsigned long long)res->start,\r\n(unsigned long long)res->end);\r\npr_debug("[0x%x], parent %p (%s)\n",\r\n(unsigned int)res->flags,\r\npr, (pr && pr->name) ? pr->name : "nil");\r\nif (pr && !(pr->flags & IORESOURCE_UNSET)) {\r\nstruct pci_dev *dev = bus->self;\r\nif (request_resource(pr, res) == 0)\r\ncontinue;\r\nif (reparent_resources(pr, res) == 0)\r\ncontinue;\r\nif (dev && i < PCI_BRIDGE_RESOURCE_NUM &&\r\npci_claim_bridge_resource(dev,\r\ni + PCI_BRIDGE_RESOURCES) == 0)\r\ncontinue;\r\n}\r\npr_warn("PCI: Cannot allocate resource region ");\r\npr_cont("%d of PCI bridge %d, will remap\n", i, bus->number);\r\nres->start = res->end = 0;\r\nres->flags = 0;\r\n}\r\nlist_for_each_entry(b, &bus->children, node)\r\npcibios_allocate_bus_resources(b);\r\n}\r\nstatic inline void alloc_resource(struct pci_dev *dev, int idx)\r\n{\r\nstruct resource *pr, *r = &dev->resource[idx];\r\npr_debug("PCI: Allocating %s: Resource %d: %016llx..%016llx [%x]\n",\r\npci_name(dev), idx,\r\n(unsigned long long)r->start,\r\n(unsigned long long)r->end,\r\n(unsigned int)r->flags);\r\npr = pci_find_parent_resource(dev, r);\r\nif (!pr || (pr->flags & IORESOURCE_UNSET) ||\r\nrequest_resource(pr, r) < 0) {\r\npr_warn("PCI: Cannot allocate resource region %d ", idx);\r\npr_cont("of device %s, will remap\n", pci_name(dev));\r\nif (pr)\r\npr_debug("PCI: parent is %p: %016llx-%016llx [%x]\n",\r\npr,\r\n(unsigned long long)pr->start,\r\n(unsigned long long)pr->end,\r\n(unsigned int)pr->flags);\r\nr->flags |= IORESOURCE_UNSET;\r\nr->end -= r->start;\r\nr->start = 0;\r\n}\r\n}\r\nstatic void __init pcibios_allocate_resources(int pass)\r\n{\r\nstruct pci_dev *dev = NULL;\r\nint idx, disabled;\r\nu16 command;\r\nstruct resource *r;\r\nfor_each_pci_dev(dev) {\r\npci_read_config_word(dev, PCI_COMMAND, &command);\r\nfor (idx = 0; idx <= PCI_ROM_RESOURCE; idx++) {\r\nr = &dev->resource[idx];\r\nif (r->parent)\r\ncontinue;\r\nif (!r->flags || (r->flags & IORESOURCE_UNSET))\r\ncontinue;\r\nif (idx == PCI_ROM_RESOURCE)\r\ndisabled = 1;\r\nif (r->flags & IORESOURCE_IO)\r\ndisabled = !(command & PCI_COMMAND_IO);\r\nelse\r\ndisabled = !(command & PCI_COMMAND_MEMORY);\r\nif (pass == disabled)\r\nalloc_resource(dev, idx);\r\n}\r\nif (pass)\r\ncontinue;\r\nr = &dev->resource[PCI_ROM_RESOURCE];\r\nif (r->flags) {\r\nu32 reg;\r\npci_read_config_dword(dev, dev->rom_base_reg, &reg);\r\nif (reg & PCI_ROM_ADDRESS_ENABLE) {\r\npr_debug("PCI: Switching off ROM of %s\n",\r\npci_name(dev));\r\nr->flags &= ~IORESOURCE_ROM_ENABLE;\r\npci_write_config_dword(dev, dev->rom_base_reg,\r\nreg & ~PCI_ROM_ADDRESS_ENABLE);\r\n}\r\n}\r\n}\r\n}\r\nstatic void __init pcibios_reserve_legacy_regions(struct pci_bus *bus)\r\n{\r\nstruct pci_controller *hose = pci_bus_to_host(bus);\r\nresource_size_t offset;\r\nstruct resource *res, *pres;\r\nint i;\r\npr_debug("Reserving legacy ranges for domain %04x\n",\r\npci_domain_nr(bus));\r\nif (!(hose->io_resource.flags & IORESOURCE_IO))\r\ngoto no_io;\r\noffset = (unsigned long)hose->io_base_virt - _IO_BASE;\r\nres = kzalloc(sizeof(struct resource), GFP_KERNEL);\r\nBUG_ON(res == NULL);\r\nres->name = "Legacy IO";\r\nres->flags = IORESOURCE_IO;\r\nres->start = offset;\r\nres->end = (offset + 0xfff) & 0xfffffffful;\r\npr_debug("Candidate legacy IO: %pR\n", res);\r\nif (request_resource(&hose->io_resource, res)) {\r\npr_debug("PCI %04x:%02x Cannot reserve Legacy IO %pR\n",\r\npci_domain_nr(bus), bus->number, res);\r\nkfree(res);\r\n}\r\nno_io:\r\noffset = hose->pci_mem_offset;\r\npr_debug("hose mem offset: %016llx\n", (unsigned long long)offset);\r\nfor (i = 0; i < 3; i++) {\r\npres = &hose->mem_resources[i];\r\nif (!(pres->flags & IORESOURCE_MEM))\r\ncontinue;\r\npr_debug("hose mem res: %pR\n", pres);\r\nif ((pres->start - offset) <= 0xa0000 &&\r\n(pres->end - offset) >= 0xbffff)\r\nbreak;\r\n}\r\nif (i >= 3)\r\nreturn;\r\nres = kzalloc(sizeof(struct resource), GFP_KERNEL);\r\nBUG_ON(res == NULL);\r\nres->name = "Legacy VGA memory";\r\nres->flags = IORESOURCE_MEM;\r\nres->start = 0xa0000 + offset;\r\nres->end = 0xbffff + offset;\r\npr_debug("Candidate VGA memory: %pR\n", res);\r\nif (request_resource(pres, res)) {\r\npr_debug("PCI %04x:%02x Cannot reserve VGA memory %pR\n",\r\npci_domain_nr(bus), bus->number, res);\r\nkfree(res);\r\n}\r\n}\r\nvoid __init pcibios_resource_survey(void)\r\n{\r\nstruct pci_bus *b;\r\nlist_for_each_entry(b, &pci_root_buses, node)\r\npcibios_allocate_bus_resources(b);\r\npcibios_allocate_resources(0);\r\npcibios_allocate_resources(1);\r\nlist_for_each_entry(b, &pci_root_buses, node)\r\npcibios_reserve_legacy_regions(b);\r\npr_debug("PCI: Assigning unassigned resources...\n");\r\npci_assign_unassigned_resources();\r\n}\r\nvoid pcibios_claim_one_bus(struct pci_bus *bus)\r\n{\r\nstruct pci_dev *dev;\r\nstruct pci_bus *child_bus;\r\nlist_for_each_entry(dev, &bus->devices, bus_list) {\r\nint i;\r\nfor (i = 0; i < PCI_NUM_RESOURCES; i++) {\r\nstruct resource *r = &dev->resource[i];\r\nif (r->parent || !r->start || !r->flags)\r\ncontinue;\r\npr_debug("PCI: Claiming %s: ", pci_name(dev));\r\npr_debug("Resource %d: %016llx..%016llx [%x]\n",\r\ni, (unsigned long long)r->start,\r\n(unsigned long long)r->end,\r\n(unsigned int)r->flags);\r\nif (pci_claim_resource(dev, i) == 0)\r\ncontinue;\r\npci_claim_bridge_resource(dev, i);\r\n}\r\n}\r\nlist_for_each_entry(child_bus, &bus->children, node)\r\npcibios_claim_one_bus(child_bus);\r\n}\r\nvoid pcibios_finish_adding_to_bus(struct pci_bus *bus)\r\n{\r\npr_debug("PCI: Finishing adding to hotplug bus %04x:%02x\n",\r\npci_domain_nr(bus), bus->number);\r\npcibios_allocate_bus_resources(bus);\r\npcibios_claim_one_bus(bus);\r\npci_bus_add_devices(bus);\r\n}\r\nstatic void pcibios_setup_phb_resources(struct pci_controller *hose,\r\nstruct list_head *resources)\r\n{\r\nunsigned long io_offset;\r\nstruct resource *res;\r\nint i;\r\nres = &hose->io_resource;\r\nio_offset = (unsigned long)hose->io_base_virt - isa_io_base;\r\nres->start = (res->start + io_offset) & 0xffffffffu;\r\nres->end = (res->end + io_offset) & 0xffffffffu;\r\nif (!res->flags) {\r\npr_warn("PCI: I/O resource not set for host ");\r\npr_cont("bridge %s (domain %d)\n",\r\nhose->dn->full_name, hose->global_number);\r\nres->start = (unsigned long)hose->io_base_virt - isa_io_base;\r\nres->end = res->start + IO_SPACE_LIMIT;\r\nres->flags = IORESOURCE_IO;\r\n}\r\npci_add_resource_offset(resources, res,\r\n(__force resource_size_t)(hose->io_base_virt - _IO_BASE));\r\npr_debug("PCI: PHB IO resource = %016llx-%016llx [%lx]\n",\r\n(unsigned long long)res->start,\r\n(unsigned long long)res->end,\r\n(unsigned long)res->flags);\r\nfor (i = 0; i < 3; ++i) {\r\nres = &hose->mem_resources[i];\r\nif (!res->flags) {\r\nif (i > 0)\r\ncontinue;\r\npr_err("PCI: Memory resource 0 not set for ");\r\npr_cont("host bridge %s (domain %d)\n",\r\nhose->dn->full_name, hose->global_number);\r\nres->start = hose->pci_mem_offset;\r\nres->end = (resource_size_t)-1LL;\r\nres->flags = IORESOURCE_MEM;\r\n}\r\npci_add_resource_offset(resources, res, hose->pci_mem_offset);\r\npr_debug("PCI: PHB MEM resource %d = %016llx-%016llx [%lx]\n",\r\ni, (unsigned long long)res->start,\r\n(unsigned long long)res->end,\r\n(unsigned long)res->flags);\r\n}\r\npr_debug("PCI: PHB MEM offset = %016llx\n",\r\n(unsigned long long)hose->pci_mem_offset);\r\npr_debug("PCI: PHB IO offset = %08lx\n",\r\n(unsigned long)hose->io_base_virt - _IO_BASE);\r\n}\r\nstruct device_node *pcibios_get_phb_of_node(struct pci_bus *bus)\r\n{\r\nstruct pci_controller *hose = bus->sysdata;\r\nreturn of_node_get(hose->dn);\r\n}\r\nstatic void pcibios_scan_phb(struct pci_controller *hose)\r\n{\r\nLIST_HEAD(resources);\r\nstruct pci_bus *bus;\r\nstruct device_node *node = hose->dn;\r\npr_debug("PCI: Scanning PHB %s\n", of_node_full_name(node));\r\npcibios_setup_phb_resources(hose, &resources);\r\nbus = pci_scan_root_bus(hose->parent, hose->first_busno,\r\nhose->ops, hose, &resources);\r\nif (bus == NULL) {\r\npr_err("Failed to create bus for PCI domain %04x\n",\r\nhose->global_number);\r\npci_free_resource_list(&resources);\r\nreturn;\r\n}\r\nbus->busn_res.start = hose->first_busno;\r\nhose->bus = bus;\r\nhose->last_busno = bus->busn_res.end;\r\n}\r\nstatic int __init pcibios_init(void)\r\n{\r\nstruct pci_controller *hose, *tmp;\r\nint next_busno = 0;\r\npr_info("PCI: Probing PCI hardware\n");\r\nlist_for_each_entry_safe(hose, tmp, &hose_list, list_node) {\r\nhose->last_busno = 0xff;\r\npcibios_scan_phb(hose);\r\nif (next_busno <= hose->last_busno)\r\nnext_busno = hose->last_busno + 1;\r\n}\r\npci_bus_count = next_busno;\r\npcibios_resource_survey();\r\nlist_for_each_entry_safe(hose, tmp, &hose_list, list_node) {\r\nif (hose->bus)\r\npci_bus_add_devices(hose->bus);\r\n}\r\nreturn 0;\r\n}\r\nstatic struct pci_controller *pci_bus_to_hose(int bus)\r\n{\r\nstruct pci_controller *hose, *tmp;\r\nlist_for_each_entry_safe(hose, tmp, &hose_list, list_node)\r\nif (bus >= hose->first_busno && bus <= hose->last_busno)\r\nreturn hose;\r\nreturn NULL;\r\n}\r\nlong sys_pciconfig_iobase(long which, unsigned long bus, unsigned long devfn)\r\n{\r\nstruct pci_controller *hose;\r\nlong result = -EOPNOTSUPP;\r\nhose = pci_bus_to_hose(bus);\r\nif (!hose)\r\nreturn -ENODEV;\r\nswitch (which) {\r\ncase IOBASE_BRIDGE_NUMBER:\r\nreturn (long)hose->first_busno;\r\ncase IOBASE_MEMORY:\r\nreturn (long)hose->pci_mem_offset;\r\ncase IOBASE_IO:\r\nreturn (long)hose->io_base_phys;\r\ncase IOBASE_ISA_IO:\r\nreturn (long)isa_io_base;\r\ncase IOBASE_ISA_MEM:\r\nreturn (long)isa_mem_base;\r\n}\r\nreturn result;\r\n}\r\nstatic int\r\nnull_read_config(struct pci_bus *bus, unsigned int devfn, int offset,\r\nint len, u32 *val)\r\n{\r\nreturn PCIBIOS_DEVICE_NOT_FOUND;\r\n}\r\nstatic int\r\nnull_write_config(struct pci_bus *bus, unsigned int devfn, int offset,\r\nint len, u32 val)\r\n{\r\nreturn PCIBIOS_DEVICE_NOT_FOUND;\r\n}\r\nstatic struct pci_bus *\r\nfake_pci_bus(struct pci_controller *hose, int busnr)\r\n{\r\nstatic struct pci_bus bus;\r\nif (!hose)\r\npr_err("Can't find hose for PCI bus %d!\n", busnr);\r\nbus.number = busnr;\r\nbus.sysdata = hose;\r\nbus.ops = hose ? hose->ops : &null_pci_ops;\r\nreturn &bus;\r\n}\r\nint early_find_capability(struct pci_controller *hose, int bus, int devfn,\r\nint cap)\r\n{\r\nreturn pci_bus_find_capability(fake_pci_bus(hose, bus), devfn, cap);\r\n}
