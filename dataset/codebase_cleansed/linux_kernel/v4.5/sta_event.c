void\r\nmwifiex_reset_connect_state(struct mwifiex_private *priv, u16 reason_code)\r\n{\r\nstruct mwifiex_adapter *adapter = priv->adapter;\r\nif (!priv->media_connected)\r\nreturn;\r\nmwifiex_dbg(adapter, INFO,\r\n"info: handles disconnect event\n");\r\npriv->media_connected = false;\r\npriv->scan_block = false;\r\npriv->port_open = false;\r\nif ((GET_BSS_ROLE(priv) == MWIFIEX_BSS_ROLE_STA) &&\r\nISSUPP_TDLS_ENABLED(priv->adapter->fw_cap_info)) {\r\nmwifiex_disable_all_tdls_links(priv);\r\nif (priv->adapter->auto_tdls)\r\nmwifiex_clean_auto_tdls(priv);\r\n}\r\nmwifiex_clean_txrx(priv);\r\npriv->data_rssi_last = 0;\r\npriv->data_nf_last = 0;\r\npriv->data_rssi_avg = 0;\r\npriv->data_nf_avg = 0;\r\npriv->bcn_rssi_last = 0;\r\npriv->bcn_nf_last = 0;\r\npriv->bcn_rssi_avg = 0;\r\npriv->bcn_nf_avg = 0;\r\npriv->rxpd_rate = 0;\r\npriv->rxpd_htinfo = 0;\r\npriv->sec_info.wpa_enabled = false;\r\npriv->sec_info.wpa2_enabled = false;\r\npriv->wpa_ie_len = 0;\r\npriv->sec_info.wapi_enabled = false;\r\npriv->wapi_ie_len = 0;\r\npriv->sec_info.wapi_key_on = false;\r\npriv->sec_info.encryption_mode = 0;\r\npriv->is_data_rate_auto = true;\r\npriv->data_rate = 0;\r\nif ((GET_BSS_ROLE(priv) == MWIFIEX_BSS_ROLE_STA ||\r\nGET_BSS_ROLE(priv) == MWIFIEX_BSS_ROLE_UAP) && priv->hist_data)\r\nmwifiex_hist_data_reset(priv);\r\nif (priv->bss_mode == NL80211_IFTYPE_ADHOC) {\r\npriv->adhoc_state = ADHOC_IDLE;\r\npriv->adhoc_is_link_sensed = false;\r\n}\r\nmwifiex_dbg(adapter, INFO,\r\n"info: previous SSID=%s, SSID len=%u\n",\r\npriv->prev_ssid.ssid, priv->prev_ssid.ssid_len);\r\nmwifiex_dbg(adapter, INFO,\r\n"info: current SSID=%s, SSID len=%u\n",\r\npriv->curr_bss_params.bss_descriptor.ssid.ssid,\r\npriv->curr_bss_params.bss_descriptor.ssid.ssid_len);\r\nmemcpy(&priv->prev_ssid,\r\n&priv->curr_bss_params.bss_descriptor.ssid,\r\nsizeof(struct cfg80211_ssid));\r\nmemcpy(priv->prev_bssid,\r\npriv->curr_bss_params.bss_descriptor.mac_address, ETH_ALEN);\r\nmemset(&priv->curr_bss_params, 0x00, sizeof(priv->curr_bss_params));\r\nadapter->tx_lock_flag = false;\r\nadapter->pps_uapsd_mode = false;\r\nif (adapter->is_cmd_timedout && adapter->curr_cmd)\r\nreturn;\r\npriv->media_connected = false;\r\nmwifiex_dbg(adapter, MSG,\r\n"info: successfully disconnected from %pM: reason code %d\n",\r\npriv->cfg_bssid, reason_code);\r\nif (priv->bss_mode == NL80211_IFTYPE_STATION ||\r\npriv->bss_mode == NL80211_IFTYPE_P2P_CLIENT) {\r\ncfg80211_disconnected(priv->netdev, reason_code, NULL, 0,\r\nfalse, GFP_KERNEL);\r\n}\r\neth_zero_addr(priv->cfg_bssid);\r\nmwifiex_stop_net_dev_queue(priv->netdev, adapter);\r\nif (netif_carrier_ok(priv->netdev))\r\nnetif_carrier_off(priv->netdev);\r\n}\r\nstatic int mwifiex_parse_tdls_event(struct mwifiex_private *priv,\r\nstruct sk_buff *event_skb)\r\n{\r\nint ret = 0;\r\nstruct mwifiex_adapter *adapter = priv->adapter;\r\nstruct mwifiex_sta_node *sta_ptr;\r\nstruct mwifiex_tdls_generic_event *tdls_evt =\r\n(void *)event_skb->data + sizeof(adapter->event_cause);\r\nu8 *mac = tdls_evt->peer_mac;\r\nif (event_skb->len < (sizeof(struct mwifiex_tdls_generic_event) -\r\nsizeof(u16) - sizeof(adapter->event_cause))) {\r\nmwifiex_dbg(adapter, ERROR, "Invalid event length!\n");\r\nreturn -1;\r\n}\r\nsta_ptr = mwifiex_get_sta_entry(priv, tdls_evt->peer_mac);\r\nif (!sta_ptr) {\r\nmwifiex_dbg(adapter, ERROR, "cannot get sta entry!\n");\r\nreturn -1;\r\n}\r\nswitch (le16_to_cpu(tdls_evt->type)) {\r\ncase TDLS_EVENT_LINK_TEAR_DOWN:\r\ncfg80211_tdls_oper_request(priv->netdev,\r\ntdls_evt->peer_mac,\r\nNL80211_TDLS_TEARDOWN,\r\nle16_to_cpu(tdls_evt->u.reason_code),\r\nGFP_KERNEL);\r\nbreak;\r\ncase TDLS_EVENT_CHAN_SWITCH_RESULT:\r\nmwifiex_dbg(adapter, EVENT, "tdls channel switch result :\n");\r\nmwifiex_dbg(adapter, EVENT,\r\n"status=0x%x, reason=0x%x cur_chan=%d\n",\r\ntdls_evt->u.switch_result.status,\r\ntdls_evt->u.switch_result.reason,\r\ntdls_evt->u.switch_result.cur_chan);\r\nif (tdls_evt->u.switch_result.status != 0) {\r\nswitch (tdls_evt->u.switch_result.cur_chan) {\r\ncase TDLS_BASE_CHANNEL:\r\nsta_ptr->tdls_status = TDLS_IN_BASE_CHAN;\r\nbreak;\r\ncase TDLS_OFF_CHANNEL:\r\nsta_ptr->tdls_status = TDLS_IN_OFF_CHAN;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nreturn ret;\r\n}\r\nswitch (tdls_evt->u.switch_result.cur_chan) {\r\ncase TDLS_BASE_CHANNEL:\r\nif (sta_ptr->tdls_status == TDLS_IN_BASE_CHAN)\r\nbreak;\r\nmwifiex_update_ralist_tx_pause_in_tdls_cs(priv, mac,\r\nfalse);\r\nsta_ptr->tdls_status = TDLS_IN_BASE_CHAN;\r\nbreak;\r\ncase TDLS_OFF_CHANNEL:\r\nif (sta_ptr->tdls_status == TDLS_IN_OFF_CHAN)\r\nbreak;\r\nmwifiex_update_ralist_tx_pause_in_tdls_cs(priv, mac,\r\ntrue);\r\nsta_ptr->tdls_status = TDLS_IN_OFF_CHAN;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nbreak;\r\ncase TDLS_EVENT_START_CHAN_SWITCH:\r\nmwifiex_dbg(adapter, EVENT, "tdls start channel switch...\n");\r\nsta_ptr->tdls_status = TDLS_CHAN_SWITCHING;\r\nbreak;\r\ncase TDLS_EVENT_CHAN_SWITCH_STOPPED:\r\nmwifiex_dbg(adapter, EVENT,\r\n"tdls chan switch stopped, reason=%d\n",\r\ntdls_evt->u.cs_stop_reason);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nreturn ret;\r\n}\r\nstatic void mwifiex_process_uap_tx_pause(struct mwifiex_private *priv,\r\nstruct mwifiex_ie_types_header *tlv)\r\n{\r\nstruct mwifiex_tx_pause_tlv *tp;\r\nstruct mwifiex_sta_node *sta_ptr;\r\nunsigned long flags;\r\ntp = (void *)tlv;\r\nmwifiex_dbg(priv->adapter, EVENT,\r\n"uap tx_pause: %pM pause=%d, pkts=%d\n",\r\ntp->peermac, tp->tx_pause,\r\ntp->pkt_cnt);\r\nif (ether_addr_equal(tp->peermac, priv->netdev->dev_addr)) {\r\nif (tp->tx_pause)\r\npriv->port_open = false;\r\nelse\r\npriv->port_open = true;\r\n} else if (is_multicast_ether_addr(tp->peermac)) {\r\nmwifiex_update_ralist_tx_pause(priv, tp->peermac, tp->tx_pause);\r\n} else {\r\nspin_lock_irqsave(&priv->sta_list_spinlock, flags);\r\nsta_ptr = mwifiex_get_sta_entry(priv, tp->peermac);\r\nspin_unlock_irqrestore(&priv->sta_list_spinlock, flags);\r\nif (sta_ptr && sta_ptr->tx_pause != tp->tx_pause) {\r\nsta_ptr->tx_pause = tp->tx_pause;\r\nmwifiex_update_ralist_tx_pause(priv, tp->peermac,\r\ntp->tx_pause);\r\n}\r\n}\r\n}\r\nstatic void mwifiex_process_sta_tx_pause(struct mwifiex_private *priv,\r\nstruct mwifiex_ie_types_header *tlv)\r\n{\r\nstruct mwifiex_tx_pause_tlv *tp;\r\nstruct mwifiex_sta_node *sta_ptr;\r\nint status;\r\nunsigned long flags;\r\ntp = (void *)tlv;\r\nmwifiex_dbg(priv->adapter, EVENT,\r\n"sta tx_pause: %pM pause=%d, pkts=%d\n",\r\ntp->peermac, tp->tx_pause,\r\ntp->pkt_cnt);\r\nif (ether_addr_equal(tp->peermac, priv->cfg_bssid)) {\r\nif (tp->tx_pause)\r\npriv->port_open = false;\r\nelse\r\npriv->port_open = true;\r\n} else {\r\nif (!ISSUPP_TDLS_ENABLED(priv->adapter->fw_cap_info))\r\nreturn;\r\nstatus = mwifiex_get_tdls_link_status(priv, tp->peermac);\r\nif (mwifiex_is_tdls_link_setup(status)) {\r\nspin_lock_irqsave(&priv->sta_list_spinlock, flags);\r\nsta_ptr = mwifiex_get_sta_entry(priv, tp->peermac);\r\nspin_unlock_irqrestore(&priv->sta_list_spinlock, flags);\r\nif (sta_ptr && sta_ptr->tx_pause != tp->tx_pause) {\r\nsta_ptr->tx_pause = tp->tx_pause;\r\nmwifiex_update_ralist_tx_pause(priv,\r\ntp->peermac,\r\ntp->tx_pause);\r\n}\r\n}\r\n}\r\n}\r\nvoid mwifiex_process_multi_chan_event(struct mwifiex_private *priv,\r\nstruct sk_buff *event_skb)\r\n{\r\nstruct mwifiex_ie_types_multi_chan_info *chan_info;\r\nstruct mwifiex_ie_types_mc_group_info *grp_info;\r\nstruct mwifiex_adapter *adapter = priv->adapter;\r\nstruct mwifiex_ie_types_header *tlv;\r\nu16 tlv_buf_left, tlv_type, tlv_len;\r\nint intf_num, bss_type, bss_num, i;\r\nstruct mwifiex_private *intf_priv;\r\ntlv_buf_left = event_skb->len - sizeof(u32);\r\nchan_info = (void *)event_skb->data + sizeof(u32);\r\nif (le16_to_cpu(chan_info->header.type) != TLV_TYPE_MULTI_CHAN_INFO ||\r\ntlv_buf_left < sizeof(struct mwifiex_ie_types_multi_chan_info)) {\r\nmwifiex_dbg(adapter, ERROR,\r\n"unknown TLV in chan_info event\n");\r\nreturn;\r\n}\r\nadapter->usb_mc_status = le16_to_cpu(chan_info->status);\r\nmwifiex_dbg(adapter, EVENT, "multi chan operation %s\n",\r\nadapter->usb_mc_status ? "started" : "over");\r\ntlv_buf_left -= sizeof(struct mwifiex_ie_types_multi_chan_info);\r\ntlv = (struct mwifiex_ie_types_header *)chan_info->tlv_buffer;\r\nwhile (tlv_buf_left >= (int)sizeof(struct mwifiex_ie_types_header)) {\r\ntlv_type = le16_to_cpu(tlv->type);\r\ntlv_len = le16_to_cpu(tlv->len);\r\nif ((sizeof(struct mwifiex_ie_types_header) + tlv_len) >\r\ntlv_buf_left) {\r\nmwifiex_dbg(adapter, ERROR, "wrong tlv: tlvLen=%d,\t"\r\n"tlvBufLeft=%d\n", tlv_len, tlv_buf_left);\r\nbreak;\r\n}\r\nif (tlv_type != TLV_TYPE_MC_GROUP_INFO) {\r\nmwifiex_dbg(adapter, ERROR, "wrong tlv type: 0x%x\n",\r\ntlv_type);\r\nbreak;\r\n}\r\ngrp_info = (struct mwifiex_ie_types_mc_group_info *)tlv;\r\nintf_num = grp_info->intf_num;\r\nfor (i = 0; i < intf_num; i++) {\r\nbss_type = grp_info->bss_type_numlist[i] >> 4;\r\nbss_num = grp_info->bss_type_numlist[i] & BSS_NUM_MASK;\r\nintf_priv = mwifiex_get_priv_by_id(adapter, bss_num,\r\nbss_type);\r\nif (!intf_priv) {\r\nmwifiex_dbg(adapter, ERROR,\r\n"Invalid bss_type bss_num\t"\r\n"in multi channel event\n");\r\ncontinue;\r\n}\r\nif (adapter->iface_type == MWIFIEX_USB) {\r\nu8 ep;\r\nep = grp_info->hid_num.usb_ep_num;\r\nif (ep == MWIFIEX_USB_EP_DATA ||\r\nep == MWIFIEX_USB_EP_DATA_CH2)\r\nintf_priv->usb_port = ep;\r\n}\r\n}\r\ntlv_buf_left -= sizeof(struct mwifiex_ie_types_header) +\r\ntlv_len;\r\ntlv = (void *)((u8 *)tlv + tlv_len +\r\nsizeof(struct mwifiex_ie_types_header));\r\n}\r\nif (adapter->iface_type == MWIFIEX_USB) {\r\nadapter->tx_lock_flag = true;\r\nadapter->usb_mc_setup = true;\r\nmwifiex_multi_chan_resync(adapter);\r\n}\r\n}\r\nvoid mwifiex_process_tx_pause_event(struct mwifiex_private *priv,\r\nstruct sk_buff *event_skb)\r\n{\r\nstruct mwifiex_ie_types_header *tlv;\r\nu16 tlv_type, tlv_len;\r\nint tlv_buf_left;\r\nif (!priv->media_connected) {\r\nmwifiex_dbg(priv->adapter, ERROR,\r\n"tx_pause event while disconnected; bss_role=%d\n",\r\npriv->bss_role);\r\nreturn;\r\n}\r\ntlv_buf_left = event_skb->len - sizeof(u32);\r\ntlv = (void *)event_skb->data + sizeof(u32);\r\nwhile (tlv_buf_left >= (int)sizeof(struct mwifiex_ie_types_header)) {\r\ntlv_type = le16_to_cpu(tlv->type);\r\ntlv_len = le16_to_cpu(tlv->len);\r\nif ((sizeof(struct mwifiex_ie_types_header) + tlv_len) >\r\ntlv_buf_left) {\r\nmwifiex_dbg(priv->adapter, ERROR,\r\n"wrong tlv: tlvLen=%d, tlvBufLeft=%d\n",\r\ntlv_len, tlv_buf_left);\r\nbreak;\r\n}\r\nif (tlv_type == TLV_TYPE_TX_PAUSE) {\r\nif (GET_BSS_ROLE(priv) == MWIFIEX_BSS_ROLE_STA)\r\nmwifiex_process_sta_tx_pause(priv, tlv);\r\nelse\r\nmwifiex_process_uap_tx_pause(priv, tlv);\r\n}\r\ntlv_buf_left -= sizeof(struct mwifiex_ie_types_header) +\r\ntlv_len;\r\ntlv = (void *)((u8 *)tlv + tlv_len +\r\nsizeof(struct mwifiex_ie_types_header));\r\n}\r\n}\r\nvoid mwifiex_bt_coex_wlan_param_update_event(struct mwifiex_private *priv,\r\nstruct sk_buff *event_skb)\r\n{\r\nstruct mwifiex_adapter *adapter = priv->adapter;\r\nstruct mwifiex_ie_types_header *tlv;\r\nstruct mwifiex_ie_types_btcoex_aggr_win_size *winsizetlv;\r\nstruct mwifiex_ie_types_btcoex_scan_time *scantlv;\r\ns32 len = event_skb->len - sizeof(u32);\r\nu8 *cur_ptr = event_skb->data + sizeof(u32);\r\nu16 tlv_type, tlv_len;\r\nwhile (len >= sizeof(struct mwifiex_ie_types_header)) {\r\ntlv = (struct mwifiex_ie_types_header *)cur_ptr;\r\ntlv_len = le16_to_cpu(tlv->len);\r\ntlv_type = le16_to_cpu(tlv->type);\r\nif ((tlv_len + sizeof(struct mwifiex_ie_types_header)) > len)\r\nbreak;\r\nswitch (tlv_type) {\r\ncase TLV_BTCOEX_WL_AGGR_WINSIZE:\r\nwinsizetlv =\r\n(struct mwifiex_ie_types_btcoex_aggr_win_size *)tlv;\r\nadapter->coex_win_size = winsizetlv->coex_win_size;\r\nadapter->coex_tx_win_size =\r\nwinsizetlv->tx_win_size;\r\nadapter->coex_rx_win_size =\r\nwinsizetlv->rx_win_size;\r\nmwifiex_coex_ampdu_rxwinsize(adapter);\r\nmwifiex_update_ampdu_txwinsize(adapter);\r\nbreak;\r\ncase TLV_BTCOEX_WL_SCANTIME:\r\nscantlv =\r\n(struct mwifiex_ie_types_btcoex_scan_time *)tlv;\r\nadapter->coex_scan = scantlv->coex_scan;\r\nadapter->coex_min_scan_time = scantlv->min_scan_time;\r\nadapter->coex_max_scan_time = scantlv->max_scan_time;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nlen -= tlv_len + sizeof(struct mwifiex_ie_types_header);\r\ncur_ptr += tlv_len +\r\nsizeof(struct mwifiex_ie_types_header);\r\n}\r\ndev_dbg(adapter->dev, "coex_scan=%d min_scan=%d coex_win=%d, tx_win=%d rx_win=%d\n",\r\nadapter->coex_scan, adapter->coex_min_scan_time,\r\nadapter->coex_win_size, adapter->coex_tx_win_size,\r\nadapter->coex_rx_win_size);\r\n}\r\nint mwifiex_process_sta_event(struct mwifiex_private *priv)\r\n{\r\nstruct mwifiex_adapter *adapter = priv->adapter;\r\nint ret = 0;\r\nu32 eventcause = adapter->event_cause;\r\nu16 ctrl, reason_code;\r\nswitch (eventcause) {\r\ncase EVENT_DUMMY_HOST_WAKEUP_SIGNAL:\r\nmwifiex_dbg(adapter, ERROR,\r\n"invalid EVENT: DUMMY_HOST_WAKEUP_SIGNAL, ignore it\n");\r\nbreak;\r\ncase EVENT_LINK_SENSED:\r\nmwifiex_dbg(adapter, EVENT, "event: LINK_SENSED\n");\r\nif (!netif_carrier_ok(priv->netdev))\r\nnetif_carrier_on(priv->netdev);\r\nmwifiex_wake_up_net_dev_queue(priv->netdev, adapter);\r\nbreak;\r\ncase EVENT_DEAUTHENTICATED:\r\nmwifiex_dbg(adapter, EVENT, "event: Deauthenticated\n");\r\nif (priv->wps.session_enable) {\r\nmwifiex_dbg(adapter, INFO,\r\n"info: receive deauth event in wps session\n");\r\nbreak;\r\n}\r\nadapter->dbg.num_event_deauth++;\r\nif (priv->media_connected) {\r\nreason_code =\r\nle16_to_cpu(*(__le16 *)adapter->event_body);\r\nmwifiex_reset_connect_state(priv, reason_code);\r\n}\r\nbreak;\r\ncase EVENT_DISASSOCIATED:\r\nmwifiex_dbg(adapter, EVENT, "event: Disassociated\n");\r\nif (priv->wps.session_enable) {\r\nmwifiex_dbg(adapter, INFO,\r\n"info: receive disassoc event in wps session\n");\r\nbreak;\r\n}\r\nadapter->dbg.num_event_disassoc++;\r\nif (priv->media_connected) {\r\nreason_code =\r\nle16_to_cpu(*(__le16 *)adapter->event_body);\r\nmwifiex_reset_connect_state(priv, reason_code);\r\n}\r\nbreak;\r\ncase EVENT_LINK_LOST:\r\nmwifiex_dbg(adapter, EVENT, "event: Link lost\n");\r\nadapter->dbg.num_event_link_lost++;\r\nif (priv->media_connected) {\r\nreason_code =\r\nle16_to_cpu(*(__le16 *)adapter->event_body);\r\nmwifiex_reset_connect_state(priv, reason_code);\r\n}\r\nbreak;\r\ncase EVENT_PS_SLEEP:\r\nmwifiex_dbg(adapter, EVENT, "info: EVENT: SLEEP\n");\r\nadapter->ps_state = PS_STATE_PRE_SLEEP;\r\nmwifiex_check_ps_cond(adapter);\r\nbreak;\r\ncase EVENT_PS_AWAKE:\r\nmwifiex_dbg(adapter, EVENT, "info: EVENT: AWAKE\n");\r\nif (!adapter->pps_uapsd_mode && priv->port_open &&\r\npriv->media_connected && adapter->sleep_period.period) {\r\nadapter->pps_uapsd_mode = true;\r\nmwifiex_dbg(adapter, EVENT,\r\n"event: PPS/UAPSD mode activated\n");\r\n}\r\nadapter->tx_lock_flag = false;\r\nif (adapter->pps_uapsd_mode && adapter->gen_null_pkt) {\r\nif (mwifiex_check_last_packet_indication(priv)) {\r\nif (adapter->data_sent ||\r\n(adapter->if_ops.is_port_ready &&\r\n!adapter->if_ops.is_port_ready(priv))) {\r\nadapter->ps_state = PS_STATE_AWAKE;\r\nadapter->pm_wakeup_card_req = false;\r\nadapter->pm_wakeup_fw_try = false;\r\ndel_timer(&adapter->wakeup_timer);\r\nbreak;\r\n}\r\nif (!mwifiex_send_null_packet\r\n(priv,\r\nMWIFIEX_TxPD_POWER_MGMT_NULL_PACKET |\r\nMWIFIEX_TxPD_POWER_MGMT_LAST_PACKET))\r\nadapter->ps_state =\r\nPS_STATE_SLEEP;\r\nreturn 0;\r\n}\r\n}\r\nadapter->ps_state = PS_STATE_AWAKE;\r\nadapter->pm_wakeup_card_req = false;\r\nadapter->pm_wakeup_fw_try = false;\r\ndel_timer(&adapter->wakeup_timer);\r\nbreak;\r\ncase EVENT_DEEP_SLEEP_AWAKE:\r\nadapter->if_ops.wakeup_complete(adapter);\r\nmwifiex_dbg(adapter, EVENT, "event: DS_AWAKE\n");\r\nif (adapter->is_deep_sleep)\r\nadapter->is_deep_sleep = false;\r\nbreak;\r\ncase EVENT_HS_ACT_REQ:\r\nmwifiex_dbg(adapter, EVENT, "event: HS_ACT_REQ\n");\r\nret = mwifiex_send_cmd(priv, HostCmd_CMD_802_11_HS_CFG_ENH,\r\n0, 0, NULL, false);\r\nbreak;\r\ncase EVENT_MIC_ERR_UNICAST:\r\nmwifiex_dbg(adapter, EVENT, "event: UNICAST MIC ERROR\n");\r\ncfg80211_michael_mic_failure(priv->netdev, priv->cfg_bssid,\r\nNL80211_KEYTYPE_PAIRWISE,\r\n-1, NULL, GFP_KERNEL);\r\nbreak;\r\ncase EVENT_MIC_ERR_MULTICAST:\r\nmwifiex_dbg(adapter, EVENT, "event: MULTICAST MIC ERROR\n");\r\ncfg80211_michael_mic_failure(priv->netdev, priv->cfg_bssid,\r\nNL80211_KEYTYPE_GROUP,\r\n-1, NULL, GFP_KERNEL);\r\nbreak;\r\ncase EVENT_MIB_CHANGED:\r\ncase EVENT_INIT_DONE:\r\nbreak;\r\ncase EVENT_ADHOC_BCN_LOST:\r\nmwifiex_dbg(adapter, EVENT, "event: ADHOC_BCN_LOST\n");\r\npriv->adhoc_is_link_sensed = false;\r\nmwifiex_clean_txrx(priv);\r\nmwifiex_stop_net_dev_queue(priv->netdev, adapter);\r\nif (netif_carrier_ok(priv->netdev))\r\nnetif_carrier_off(priv->netdev);\r\nbreak;\r\ncase EVENT_BG_SCAN_REPORT:\r\nmwifiex_dbg(adapter, EVENT, "event: BGS_REPORT\n");\r\nret = mwifiex_send_cmd(priv, HostCmd_CMD_802_11_BG_SCAN_QUERY,\r\nHostCmd_ACT_GEN_GET, 0, NULL, false);\r\nbreak;\r\ncase EVENT_PORT_RELEASE:\r\nmwifiex_dbg(adapter, EVENT, "event: PORT RELEASE\n");\r\npriv->port_open = true;\r\nbreak;\r\ncase EVENT_EXT_SCAN_REPORT:\r\nmwifiex_dbg(adapter, EVENT, "event: EXT_SCAN Report\n");\r\nif (adapter->ext_scan)\r\nret = mwifiex_handle_event_ext_scan_report(priv,\r\nadapter->event_skb->data);\r\nbreak;\r\ncase EVENT_WMM_STATUS_CHANGE:\r\nmwifiex_dbg(adapter, EVENT, "event: WMM status changed\n");\r\nret = mwifiex_send_cmd(priv, HostCmd_CMD_WMM_GET_STATUS,\r\n0, 0, NULL, false);\r\nbreak;\r\ncase EVENT_RSSI_LOW:\r\ncfg80211_cqm_rssi_notify(priv->netdev,\r\nNL80211_CQM_RSSI_THRESHOLD_EVENT_LOW,\r\nGFP_KERNEL);\r\nmwifiex_send_cmd(priv, HostCmd_CMD_RSSI_INFO,\r\nHostCmd_ACT_GEN_GET, 0, NULL, false);\r\npriv->subsc_evt_rssi_state = RSSI_LOW_RECVD;\r\nmwifiex_dbg(adapter, EVENT, "event: Beacon RSSI_LOW\n");\r\nbreak;\r\ncase EVENT_SNR_LOW:\r\nmwifiex_dbg(adapter, EVENT, "event: Beacon SNR_LOW\n");\r\nbreak;\r\ncase EVENT_MAX_FAIL:\r\nmwifiex_dbg(adapter, EVENT, "event: MAX_FAIL\n");\r\nbreak;\r\ncase EVENT_RSSI_HIGH:\r\ncfg80211_cqm_rssi_notify(priv->netdev,\r\nNL80211_CQM_RSSI_THRESHOLD_EVENT_HIGH,\r\nGFP_KERNEL);\r\nmwifiex_send_cmd(priv, HostCmd_CMD_RSSI_INFO,\r\nHostCmd_ACT_GEN_GET, 0, NULL, false);\r\npriv->subsc_evt_rssi_state = RSSI_HIGH_RECVD;\r\nmwifiex_dbg(adapter, EVENT, "event: Beacon RSSI_HIGH\n");\r\nbreak;\r\ncase EVENT_SNR_HIGH:\r\nmwifiex_dbg(adapter, EVENT, "event: Beacon SNR_HIGH\n");\r\nbreak;\r\ncase EVENT_DATA_RSSI_LOW:\r\nmwifiex_dbg(adapter, EVENT, "event: Data RSSI_LOW\n");\r\nbreak;\r\ncase EVENT_DATA_SNR_LOW:\r\nmwifiex_dbg(adapter, EVENT, "event: Data SNR_LOW\n");\r\nbreak;\r\ncase EVENT_DATA_RSSI_HIGH:\r\nmwifiex_dbg(adapter, EVENT, "event: Data RSSI_HIGH\n");\r\nbreak;\r\ncase EVENT_DATA_SNR_HIGH:\r\nmwifiex_dbg(adapter, EVENT, "event: Data SNR_HIGH\n");\r\nbreak;\r\ncase EVENT_LINK_QUALITY:\r\nmwifiex_dbg(adapter, EVENT, "event: Link Quality\n");\r\nbreak;\r\ncase EVENT_PRE_BEACON_LOST:\r\nmwifiex_dbg(adapter, EVENT, "event: Pre-Beacon Lost\n");\r\nbreak;\r\ncase EVENT_IBSS_COALESCED:\r\nmwifiex_dbg(adapter, EVENT, "event: IBSS_COALESCED\n");\r\nret = mwifiex_send_cmd(priv,\r\nHostCmd_CMD_802_11_IBSS_COALESCING_STATUS,\r\nHostCmd_ACT_GEN_GET, 0, NULL, false);\r\nbreak;\r\ncase EVENT_ADDBA:\r\nmwifiex_dbg(adapter, EVENT, "event: ADDBA Request\n");\r\nmwifiex_send_cmd(priv, HostCmd_CMD_11N_ADDBA_RSP,\r\nHostCmd_ACT_GEN_SET, 0,\r\nadapter->event_body, false);\r\nbreak;\r\ncase EVENT_DELBA:\r\nmwifiex_dbg(adapter, EVENT, "event: DELBA Request\n");\r\nmwifiex_11n_delete_ba_stream(priv, adapter->event_body);\r\nbreak;\r\ncase EVENT_BA_STREAM_TIEMOUT:\r\nmwifiex_dbg(adapter, EVENT, "event: BA Stream timeout\n");\r\nmwifiex_11n_ba_stream_timeout(priv,\r\n(struct host_cmd_ds_11n_batimeout\r\n*)\r\nadapter->event_body);\r\nbreak;\r\ncase EVENT_AMSDU_AGGR_CTRL:\r\nctrl = le16_to_cpu(*(__le16 *)adapter->event_body);\r\nmwifiex_dbg(adapter, EVENT,\r\n"event: AMSDU_AGGR_CTRL %d\n", ctrl);\r\nadapter->tx_buf_size =\r\nmin_t(u16, adapter->curr_tx_buf_size, ctrl);\r\nmwifiex_dbg(adapter, EVENT, "event: tx_buf_size %d\n",\r\nadapter->tx_buf_size);\r\nbreak;\r\ncase EVENT_WEP_ICV_ERR:\r\nmwifiex_dbg(adapter, EVENT, "event: WEP ICV error\n");\r\nbreak;\r\ncase EVENT_BW_CHANGE:\r\nmwifiex_dbg(adapter, EVENT, "event: BW Change\n");\r\nbreak;\r\ncase EVENT_HOSTWAKE_STAIE:\r\nmwifiex_dbg(adapter, EVENT,\r\n"event: HOSTWAKE_STAIE %d\n", eventcause);\r\nbreak;\r\ncase EVENT_REMAIN_ON_CHAN_EXPIRED:\r\nmwifiex_dbg(adapter, EVENT,\r\n"event: Remain on channel expired\n");\r\ncfg80211_remain_on_channel_expired(&priv->wdev,\r\npriv->roc_cfg.cookie,\r\n&priv->roc_cfg.chan,\r\nGFP_ATOMIC);\r\nmemset(&priv->roc_cfg, 0x00, sizeof(struct mwifiex_roc_cfg));\r\nbreak;\r\ncase EVENT_CHANNEL_SWITCH_ANN:\r\nmwifiex_dbg(adapter, EVENT, "event: Channel Switch Announcement\n");\r\npriv->csa_expire_time =\r\njiffies + msecs_to_jiffies(DFS_CHAN_MOVE_TIME);\r\npriv->csa_chan = priv->curr_bss_params.bss_descriptor.channel;\r\nret = mwifiex_send_cmd(priv, HostCmd_CMD_802_11_DEAUTHENTICATE,\r\nHostCmd_ACT_GEN_SET, 0,\r\npriv->curr_bss_params.bss_descriptor.mac_address,\r\nfalse);\r\nbreak;\r\ncase EVENT_TDLS_GENERIC_EVENT:\r\nret = mwifiex_parse_tdls_event(priv, adapter->event_skb);\r\nbreak;\r\ncase EVENT_TX_DATA_PAUSE:\r\nmwifiex_dbg(adapter, EVENT, "event: TX DATA PAUSE\n");\r\nmwifiex_process_tx_pause_event(priv, adapter->event_skb);\r\nbreak;\r\ncase EVENT_MULTI_CHAN_INFO:\r\nmwifiex_dbg(adapter, EVENT, "event: multi-chan info\n");\r\nmwifiex_process_multi_chan_event(priv, adapter->event_skb);\r\nbreak;\r\ncase EVENT_TX_STATUS_REPORT:\r\nmwifiex_dbg(adapter, EVENT, "event: TX_STATUS Report\n");\r\nmwifiex_parse_tx_status_event(priv, adapter->event_body);\r\nbreak;\r\ncase EVENT_CHANNEL_REPORT_RDY:\r\nmwifiex_dbg(adapter, EVENT, "event: Channel Report\n");\r\nret = mwifiex_11h_handle_chanrpt_ready(priv,\r\nadapter->event_skb);\r\nbreak;\r\ncase EVENT_RADAR_DETECTED:\r\nmwifiex_dbg(adapter, EVENT, "event: Radar detected\n");\r\nret = mwifiex_11h_handle_radar_detected(priv,\r\nadapter->event_skb);\r\nbreak;\r\ncase EVENT_BT_COEX_WLAN_PARA_CHANGE:\r\ndev_dbg(adapter->dev, "EVENT: BT coex wlan param update\n");\r\nmwifiex_bt_coex_wlan_param_update_event(priv,\r\nadapter->event_skb);\r\nbreak;\r\ndefault:\r\nmwifiex_dbg(adapter, ERROR, "event: unknown event id: %#x\n",\r\neventcause);\r\nbreak;\r\n}\r\nreturn ret;\r\n}
