static int lpass_cpu_daiops_set_sysclk(struct snd_soc_dai *dai, int clk_id,\r\nunsigned int freq, int dir)\r\n{\r\nstruct lpass_data *drvdata = snd_soc_dai_get_drvdata(dai);\r\nint ret;\r\nif (IS_ERR(drvdata->mi2s_osr_clk[dai->driver->id]))\r\nreturn 0;\r\nret = clk_set_rate(drvdata->mi2s_osr_clk[dai->driver->id], freq);\r\nif (ret)\r\ndev_err(dai->dev, "%s() error setting mi2s osrclk to %u: %d\n",\r\n__func__, freq, ret);\r\nreturn ret;\r\n}\r\nstatic int lpass_cpu_daiops_startup(struct snd_pcm_substream *substream,\r\nstruct snd_soc_dai *dai)\r\n{\r\nstruct lpass_data *drvdata = snd_soc_dai_get_drvdata(dai);\r\nint ret;\r\nif (!IS_ERR(drvdata->mi2s_osr_clk[dai->driver->id])) {\r\nret = clk_prepare_enable(\r\ndrvdata->mi2s_osr_clk[dai->driver->id]);\r\nif (ret) {\r\ndev_err(dai->dev, "%s() error in enabling mi2s osr clk: %d\n",\r\n__func__, ret);\r\nreturn ret;\r\n}\r\n}\r\nret = clk_prepare_enable(drvdata->mi2s_bit_clk[dai->driver->id]);\r\nif (ret) {\r\ndev_err(dai->dev, "%s() error in enabling mi2s bit clk: %d\n",\r\n__func__, ret);\r\nif (!IS_ERR(drvdata->mi2s_osr_clk[dai->driver->id]))\r\nclk_disable_unprepare(\r\ndrvdata->mi2s_osr_clk[dai->driver->id]);\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic void lpass_cpu_daiops_shutdown(struct snd_pcm_substream *substream,\r\nstruct snd_soc_dai *dai)\r\n{\r\nstruct lpass_data *drvdata = snd_soc_dai_get_drvdata(dai);\r\nclk_disable_unprepare(drvdata->mi2s_bit_clk[dai->driver->id]);\r\nif (!IS_ERR(drvdata->mi2s_osr_clk[dai->driver->id]))\r\nclk_disable_unprepare(drvdata->mi2s_osr_clk[dai->driver->id]);\r\n}\r\nstatic int lpass_cpu_daiops_hw_params(struct snd_pcm_substream *substream,\r\nstruct snd_pcm_hw_params *params, struct snd_soc_dai *dai)\r\n{\r\nstruct lpass_data *drvdata = snd_soc_dai_get_drvdata(dai);\r\nsnd_pcm_format_t format = params_format(params);\r\nunsigned int channels = params_channels(params);\r\nunsigned int rate = params_rate(params);\r\nunsigned int regval;\r\nint bitwidth, ret;\r\nbitwidth = snd_pcm_format_width(format);\r\nif (bitwidth < 0) {\r\ndev_err(dai->dev, "%s() invalid bit width given: %d\n",\r\n__func__, bitwidth);\r\nreturn bitwidth;\r\n}\r\nregval = LPAIF_I2SCTL_LOOPBACK_DISABLE |\r\nLPAIF_I2SCTL_WSSRC_INTERNAL;\r\nswitch (bitwidth) {\r\ncase 16:\r\nregval |= LPAIF_I2SCTL_BITWIDTH_16;\r\nbreak;\r\ncase 24:\r\nregval |= LPAIF_I2SCTL_BITWIDTH_24;\r\nbreak;\r\ncase 32:\r\nregval |= LPAIF_I2SCTL_BITWIDTH_32;\r\nbreak;\r\ndefault:\r\ndev_err(dai->dev, "%s() invalid bitwidth given: %d\n",\r\n__func__, bitwidth);\r\nreturn -EINVAL;\r\n}\r\nswitch (channels) {\r\ncase 1:\r\nregval |= LPAIF_I2SCTL_SPKMODE_SD0;\r\nregval |= LPAIF_I2SCTL_SPKMONO_MONO;\r\nbreak;\r\ncase 2:\r\nregval |= LPAIF_I2SCTL_SPKMODE_SD0;\r\nregval |= LPAIF_I2SCTL_SPKMONO_STEREO;\r\nbreak;\r\ncase 4:\r\nregval |= LPAIF_I2SCTL_SPKMODE_QUAD01;\r\nregval |= LPAIF_I2SCTL_SPKMONO_STEREO;\r\nbreak;\r\ncase 6:\r\nregval |= LPAIF_I2SCTL_SPKMODE_6CH;\r\nregval |= LPAIF_I2SCTL_SPKMONO_STEREO;\r\nbreak;\r\ncase 8:\r\nregval |= LPAIF_I2SCTL_SPKMODE_8CH;\r\nregval |= LPAIF_I2SCTL_SPKMONO_STEREO;\r\nbreak;\r\ndefault:\r\ndev_err(dai->dev, "%s() invalid channels given: %u\n",\r\n__func__, channels);\r\nreturn -EINVAL;\r\n}\r\nret = regmap_write(drvdata->lpaif_map,\r\nLPAIF_I2SCTL_REG(drvdata->variant, dai->driver->id),\r\nregval);\r\nif (ret) {\r\ndev_err(dai->dev, "%s() error writing to i2sctl reg: %d\n",\r\n__func__, ret);\r\nreturn ret;\r\n}\r\nret = clk_set_rate(drvdata->mi2s_bit_clk[dai->driver->id],\r\nrate * bitwidth * 2);\r\nif (ret) {\r\ndev_err(dai->dev, "%s() error setting mi2s bitclk to %u: %d\n",\r\n__func__, rate * bitwidth * 2, ret);\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic int lpass_cpu_daiops_hw_free(struct snd_pcm_substream *substream,\r\nstruct snd_soc_dai *dai)\r\n{\r\nstruct lpass_data *drvdata = snd_soc_dai_get_drvdata(dai);\r\nint ret;\r\nret = regmap_write(drvdata->lpaif_map,\r\nLPAIF_I2SCTL_REG(drvdata->variant, dai->driver->id),\r\n0);\r\nif (ret)\r\ndev_err(dai->dev, "%s() error writing to i2sctl reg: %d\n",\r\n__func__, ret);\r\nreturn ret;\r\n}\r\nstatic int lpass_cpu_daiops_prepare(struct snd_pcm_substream *substream,\r\nstruct snd_soc_dai *dai)\r\n{\r\nstruct lpass_data *drvdata = snd_soc_dai_get_drvdata(dai);\r\nint ret;\r\nret = regmap_update_bits(drvdata->lpaif_map,\r\nLPAIF_I2SCTL_REG(drvdata->variant, dai->driver->id),\r\nLPAIF_I2SCTL_SPKEN_MASK, LPAIF_I2SCTL_SPKEN_ENABLE);\r\nif (ret)\r\ndev_err(dai->dev, "%s() error writing to i2sctl reg: %d\n",\r\n__func__, ret);\r\nreturn ret;\r\n}\r\nstatic int lpass_cpu_daiops_trigger(struct snd_pcm_substream *substream,\r\nint cmd, struct snd_soc_dai *dai)\r\n{\r\nstruct lpass_data *drvdata = snd_soc_dai_get_drvdata(dai);\r\nint ret = -EINVAL;\r\nswitch (cmd) {\r\ncase SNDRV_PCM_TRIGGER_START:\r\ncase SNDRV_PCM_TRIGGER_RESUME:\r\ncase SNDRV_PCM_TRIGGER_PAUSE_RELEASE:\r\nret = regmap_update_bits(drvdata->lpaif_map,\r\nLPAIF_I2SCTL_REG(drvdata->variant,\r\ndai->driver->id),\r\nLPAIF_I2SCTL_SPKEN_MASK,\r\nLPAIF_I2SCTL_SPKEN_ENABLE);\r\nif (ret)\r\ndev_err(dai->dev, "%s() error writing to i2sctl reg: %d\n",\r\n__func__, ret);\r\nbreak;\r\ncase SNDRV_PCM_TRIGGER_STOP:\r\ncase SNDRV_PCM_TRIGGER_SUSPEND:\r\ncase SNDRV_PCM_TRIGGER_PAUSE_PUSH:\r\nret = regmap_update_bits(drvdata->lpaif_map,\r\nLPAIF_I2SCTL_REG(drvdata->variant,\r\ndai->driver->id),\r\nLPAIF_I2SCTL_SPKEN_MASK,\r\nLPAIF_I2SCTL_SPKEN_DISABLE);\r\nif (ret)\r\ndev_err(dai->dev, "%s() error writing to i2sctl reg: %d\n",\r\n__func__, ret);\r\nbreak;\r\n}\r\nreturn ret;\r\n}\r\nint asoc_qcom_lpass_cpu_dai_probe(struct snd_soc_dai *dai)\r\n{\r\nstruct lpass_data *drvdata = snd_soc_dai_get_drvdata(dai);\r\nint ret;\r\nret = regmap_write(drvdata->lpaif_map,\r\nLPAIF_I2SCTL_REG(drvdata->variant, dai->driver->id), 0);\r\nif (ret)\r\ndev_err(dai->dev, "%s() error writing to i2sctl reg: %d\n",\r\n__func__, ret);\r\nreturn ret;\r\n}\r\nstatic bool lpass_cpu_regmap_writeable(struct device *dev, unsigned int reg)\r\n{\r\nstruct lpass_data *drvdata = dev_get_drvdata(dev);\r\nstruct lpass_variant *v = drvdata->variant;\r\nint i;\r\nfor (i = 0; i < v->i2s_ports; ++i)\r\nif (reg == LPAIF_I2SCTL_REG(v, i))\r\nreturn true;\r\nfor (i = 0; i < v->irq_ports; ++i) {\r\nif (reg == LPAIF_IRQEN_REG(v, i))\r\nreturn true;\r\nif (reg == LPAIF_IRQCLEAR_REG(v, i))\r\nreturn true;\r\n}\r\nfor (i = 0; i < v->rdma_channels; ++i) {\r\nif (reg == LPAIF_RDMACTL_REG(v, i))\r\nreturn true;\r\nif (reg == LPAIF_RDMABASE_REG(v, i))\r\nreturn true;\r\nif (reg == LPAIF_RDMABUFF_REG(v, i))\r\nreturn true;\r\nif (reg == LPAIF_RDMAPER_REG(v, i))\r\nreturn true;\r\n}\r\nreturn false;\r\n}\r\nstatic bool lpass_cpu_regmap_readable(struct device *dev, unsigned int reg)\r\n{\r\nstruct lpass_data *drvdata = dev_get_drvdata(dev);\r\nstruct lpass_variant *v = drvdata->variant;\r\nint i;\r\nfor (i = 0; i < v->i2s_ports; ++i)\r\nif (reg == LPAIF_I2SCTL_REG(v, i))\r\nreturn true;\r\nfor (i = 0; i < v->irq_ports; ++i) {\r\nif (reg == LPAIF_IRQEN_REG(v, i))\r\nreturn true;\r\nif (reg == LPAIF_IRQSTAT_REG(v, i))\r\nreturn true;\r\n}\r\nfor (i = 0; i < v->rdma_channels; ++i) {\r\nif (reg == LPAIF_RDMACTL_REG(v, i))\r\nreturn true;\r\nif (reg == LPAIF_RDMABASE_REG(v, i))\r\nreturn true;\r\nif (reg == LPAIF_RDMABUFF_REG(v, i))\r\nreturn true;\r\nif (reg == LPAIF_RDMACURR_REG(v, i))\r\nreturn true;\r\nif (reg == LPAIF_RDMAPER_REG(v, i))\r\nreturn true;\r\n}\r\nreturn false;\r\n}\r\nstatic bool lpass_cpu_regmap_volatile(struct device *dev, unsigned int reg)\r\n{\r\nstruct lpass_data *drvdata = dev_get_drvdata(dev);\r\nstruct lpass_variant *v = drvdata->variant;\r\nint i;\r\nfor (i = 0; i < v->irq_ports; ++i)\r\nif (reg == LPAIF_IRQSTAT_REG(v, i))\r\nreturn true;\r\nfor (i = 0; i < v->rdma_channels; ++i)\r\nif (reg == LPAIF_RDMACURR_REG(v, i))\r\nreturn true;\r\nreturn false;\r\n}\r\nint asoc_qcom_lpass_cpu_platform_probe(struct platform_device *pdev)\r\n{\r\nstruct lpass_data *drvdata;\r\nstruct device_node *dsp_of_node;\r\nstruct resource *res;\r\nstruct lpass_variant *variant;\r\nstruct device *dev = &pdev->dev;\r\nconst struct of_device_id *match;\r\nchar clk_name[16];\r\nint ret, i, dai_id;\r\ndsp_of_node = of_parse_phandle(pdev->dev.of_node, "qcom,adsp", 0);\r\nif (dsp_of_node) {\r\ndev_err(&pdev->dev, "%s() DSP exists and holds audio resources\n",\r\n__func__);\r\nreturn -EBUSY;\r\n}\r\ndrvdata = devm_kzalloc(&pdev->dev, sizeof(struct lpass_data),\r\nGFP_KERNEL);\r\nif (!drvdata)\r\nreturn -ENOMEM;\r\nplatform_set_drvdata(pdev, drvdata);\r\nmatch = of_match_device(dev->driver->of_match_table, dev);\r\nif (!match || !match->data)\r\nreturn -EINVAL;\r\ndrvdata->variant = (struct lpass_variant *)match->data;\r\nvariant = drvdata->variant;\r\nres = platform_get_resource_byname(pdev, IORESOURCE_MEM, "lpass-lpaif");\r\ndrvdata->lpaif = devm_ioremap_resource(&pdev->dev, res);\r\nif (IS_ERR((void const __force *)drvdata->lpaif)) {\r\ndev_err(&pdev->dev, "%s() error mapping reg resource: %ld\n",\r\n__func__,\r\nPTR_ERR((void const __force *)drvdata->lpaif));\r\nreturn PTR_ERR((void const __force *)drvdata->lpaif);\r\n}\r\nlpass_cpu_regmap_config.max_register = LPAIF_RDMAPER_REG(variant,\r\nvariant->rdma_channels);\r\ndrvdata->lpaif_map = devm_regmap_init_mmio(&pdev->dev, drvdata->lpaif,\r\n&lpass_cpu_regmap_config);\r\nif (IS_ERR(drvdata->lpaif_map)) {\r\ndev_err(&pdev->dev, "%s() error initializing regmap: %ld\n",\r\n__func__, PTR_ERR(drvdata->lpaif_map));\r\nreturn PTR_ERR(drvdata->lpaif_map);\r\n}\r\nif (variant->init)\r\nvariant->init(pdev);\r\nfor (i = 0; i < variant->num_dai; i++) {\r\ndai_id = variant->dai_driver[i].id;\r\nif (variant->num_dai > 1)\r\nsprintf(clk_name, "mi2s-osr-clk%d", i);\r\nelse\r\nsprintf(clk_name, "mi2s-osr-clk");\r\ndrvdata->mi2s_osr_clk[dai_id] = devm_clk_get(&pdev->dev,\r\nclk_name);\r\nif (IS_ERR(drvdata->mi2s_osr_clk[dai_id])) {\r\ndev_warn(&pdev->dev,\r\n"%s() error getting mi2s-osr-clk: %ld\n",\r\n__func__,\r\nPTR_ERR(drvdata->mi2s_osr_clk[dai_id]));\r\n}\r\nif (variant->num_dai > 1)\r\nsprintf(clk_name, "mi2s-bit-clk%d", i);\r\nelse\r\nsprintf(clk_name, "mi2s-bit-clk");\r\ndrvdata->mi2s_bit_clk[dai_id] = devm_clk_get(&pdev->dev,\r\nclk_name);\r\nif (IS_ERR(drvdata->mi2s_bit_clk[dai_id])) {\r\ndev_err(&pdev->dev,\r\n"%s() error getting mi2s-bit-clk: %ld\n",\r\n__func__,\r\nPTR_ERR(drvdata->mi2s_bit_clk[dai_id]));\r\nreturn PTR_ERR(drvdata->mi2s_bit_clk[dai_id]);\r\n}\r\n}\r\ndrvdata->ahbix_clk = devm_clk_get(&pdev->dev, "ahbix-clk");\r\nif (IS_ERR(drvdata->ahbix_clk)) {\r\ndev_err(&pdev->dev, "%s() error getting ahbix-clk: %ld\n",\r\n__func__, PTR_ERR(drvdata->ahbix_clk));\r\nreturn PTR_ERR(drvdata->ahbix_clk);\r\n}\r\nret = clk_set_rate(drvdata->ahbix_clk, LPASS_AHBIX_CLOCK_FREQUENCY);\r\nif (ret) {\r\ndev_err(&pdev->dev, "%s() error setting rate on ahbix_clk: %d\n",\r\n__func__, ret);\r\nreturn ret;\r\n}\r\ndev_dbg(&pdev->dev, "%s() set ahbix_clk rate to %lu\n", __func__,\r\nclk_get_rate(drvdata->ahbix_clk));\r\nret = clk_prepare_enable(drvdata->ahbix_clk);\r\nif (ret) {\r\ndev_err(&pdev->dev, "%s() error enabling ahbix_clk: %d\n",\r\n__func__, ret);\r\nreturn ret;\r\n}\r\nret = devm_snd_soc_register_component(&pdev->dev,\r\n&lpass_cpu_comp_driver,\r\nvariant->dai_driver,\r\nvariant->num_dai);\r\nif (ret) {\r\ndev_err(&pdev->dev, "%s() error registering cpu driver: %d\n",\r\n__func__, ret);\r\ngoto err_clk;\r\n}\r\nret = asoc_qcom_lpass_platform_register(pdev);\r\nif (ret) {\r\ndev_err(&pdev->dev, "%s() error registering platform driver: %d\n",\r\n__func__, ret);\r\ngoto err_clk;\r\n}\r\nreturn 0;\r\nerr_clk:\r\nclk_disable_unprepare(drvdata->ahbix_clk);\r\nreturn ret;\r\n}\r\nint asoc_qcom_lpass_cpu_platform_remove(struct platform_device *pdev)\r\n{\r\nstruct lpass_data *drvdata = platform_get_drvdata(pdev);\r\nif (drvdata->variant->exit)\r\ndrvdata->variant->exit(pdev);\r\nclk_disable_unprepare(drvdata->ahbix_clk);\r\nreturn 0;\r\n}
