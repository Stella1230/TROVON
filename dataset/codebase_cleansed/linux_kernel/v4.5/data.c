void data_free(struct data d)\r\n{\r\nstruct marker *m, *nm;\r\nm = d.markers;\r\nwhile (m) {\r\nnm = m->next;\r\nfree(m->ref);\r\nfree(m);\r\nm = nm;\r\n}\r\nif (d.val)\r\nfree(d.val);\r\n}\r\nstruct data data_grow_for(struct data d, int xlen)\r\n{\r\nstruct data nd;\r\nint newsize;\r\nif (xlen == 0)\r\nreturn d;\r\nnd = d;\r\nnewsize = xlen;\r\nwhile ((d.len + xlen) > newsize)\r\nnewsize *= 2;\r\nnd.val = xrealloc(d.val, newsize);\r\nreturn nd;\r\n}\r\nstruct data data_copy_mem(const char *mem, int len)\r\n{\r\nstruct data d;\r\nd = data_grow_for(empty_data, len);\r\nd.len = len;\r\nmemcpy(d.val, mem, len);\r\nreturn d;\r\n}\r\nstruct data data_copy_escape_string(const char *s, int len)\r\n{\r\nint i = 0;\r\nstruct data d;\r\nchar *q;\r\nd = data_grow_for(empty_data, len + 1);\r\nq = d.val;\r\nwhile (i < len) {\r\nchar c = s[i++];\r\nif (c == '\\')\r\nc = get_escape_char(s, &i);\r\nq[d.len++] = c;\r\n}\r\nq[d.len++] = '\0';\r\nreturn d;\r\n}\r\nstruct data data_copy_file(FILE *f, size_t maxlen)\r\n{\r\nstruct data d = empty_data;\r\nwhile (!feof(f) && (d.len < maxlen)) {\r\nsize_t chunksize, ret;\r\nif (maxlen == -1)\r\nchunksize = 4096;\r\nelse\r\nchunksize = maxlen - d.len;\r\nd = data_grow_for(d, chunksize);\r\nret = fread(d.val + d.len, 1, chunksize, f);\r\nif (ferror(f))\r\ndie("Error reading file into data: %s", strerror(errno));\r\nif (d.len + ret < d.len)\r\ndie("Overflow reading file into data\n");\r\nd.len += ret;\r\n}\r\nreturn d;\r\n}\r\nstruct data data_append_data(struct data d, const void *p, int len)\r\n{\r\nd = data_grow_for(d, len);\r\nmemcpy(d.val + d.len, p, len);\r\nd.len += len;\r\nreturn d;\r\n}\r\nstruct data data_insert_at_marker(struct data d, struct marker *m,\r\nconst void *p, int len)\r\n{\r\nd = data_grow_for(d, len);\r\nmemmove(d.val + m->offset + len, d.val + m->offset, d.len - m->offset);\r\nmemcpy(d.val + m->offset, p, len);\r\nd.len += len;\r\nm = m->next;\r\nfor_each_marker(m)\r\nm->offset += len;\r\nreturn d;\r\n}\r\nstatic struct data data_append_markers(struct data d, struct marker *m)\r\n{\r\nstruct marker **mp = &d.markers;\r\nwhile (*mp)\r\nmp = &((*mp)->next);\r\n*mp = m;\r\nreturn d;\r\n}\r\nstruct data data_merge(struct data d1, struct data d2)\r\n{\r\nstruct data d;\r\nstruct marker *m2 = d2.markers;\r\nd = data_append_markers(data_append_data(d1, d2.val, d2.len), m2);\r\nfor_each_marker(m2)\r\nm2->offset += d1.len;\r\nd2.markers = NULL;\r\ndata_free(d2);\r\nreturn d;\r\n}\r\nstruct data data_append_integer(struct data d, uint64_t value, int bits)\r\n{\r\nuint8_t value_8;\r\nuint16_t value_16;\r\nuint32_t value_32;\r\nuint64_t value_64;\r\nswitch (bits) {\r\ncase 8:\r\nvalue_8 = value;\r\nreturn data_append_data(d, &value_8, 1);\r\ncase 16:\r\nvalue_16 = cpu_to_fdt16(value);\r\nreturn data_append_data(d, &value_16, 2);\r\ncase 32:\r\nvalue_32 = cpu_to_fdt32(value);\r\nreturn data_append_data(d, &value_32, 4);\r\ncase 64:\r\nvalue_64 = cpu_to_fdt64(value);\r\nreturn data_append_data(d, &value_64, 8);\r\ndefault:\r\ndie("Invalid literal size (%d)\n", bits);\r\n}\r\n}\r\nstruct data data_append_re(struct data d, const struct fdt_reserve_entry *re)\r\n{\r\nstruct fdt_reserve_entry bere;\r\nbere.address = cpu_to_fdt64(re->address);\r\nbere.size = cpu_to_fdt64(re->size);\r\nreturn data_append_data(d, &bere, sizeof(bere));\r\n}\r\nstruct data data_append_cell(struct data d, cell_t word)\r\n{\r\nreturn data_append_integer(d, word, sizeof(word) * 8);\r\n}\r\nstruct data data_append_addr(struct data d, uint64_t addr)\r\n{\r\nreturn data_append_integer(d, addr, sizeof(addr) * 8);\r\n}\r\nstruct data data_append_byte(struct data d, uint8_t byte)\r\n{\r\nreturn data_append_data(d, &byte, 1);\r\n}\r\nstruct data data_append_zeroes(struct data d, int len)\r\n{\r\nd = data_grow_for(d, len);\r\nmemset(d.val + d.len, 0, len);\r\nd.len += len;\r\nreturn d;\r\n}\r\nstruct data data_append_align(struct data d, int align)\r\n{\r\nint newlen = ALIGN(d.len, align);\r\nreturn data_append_zeroes(d, newlen - d.len);\r\n}\r\nstruct data data_add_marker(struct data d, enum markertype type, char *ref)\r\n{\r\nstruct marker *m;\r\nm = xmalloc(sizeof(*m));\r\nm->offset = d.len;\r\nm->type = type;\r\nm->ref = ref;\r\nm->next = NULL;\r\nreturn data_append_markers(d, m);\r\n}\r\nbool data_is_one_string(struct data d)\r\n{\r\nint i;\r\nint len = d.len;\r\nif (len == 0)\r\nreturn false;\r\nfor (i = 0; i < len-1; i++)\r\nif (d.val[i] == '\0')\r\nreturn false;\r\nif (d.val[len-1] != '\0')\r\nreturn false;\r\nreturn true;\r\n}
