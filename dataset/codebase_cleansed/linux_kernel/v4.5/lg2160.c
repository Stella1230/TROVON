static int lg216x_write_reg(struct lg216x_state *state, u16 reg, u8 val)\r\n{\r\nint ret;\r\nu8 buf[] = { reg >> 8, reg & 0xff, val };\r\nstruct i2c_msg msg = {\r\n.addr = state->cfg->i2c_addr, .flags = 0,\r\n.buf = buf, .len = 3,\r\n};\r\nlg_reg("reg: 0x%04x, val: 0x%02x\n", reg, val);\r\nret = i2c_transfer(state->i2c_adap, &msg, 1);\r\nif (ret != 1) {\r\nlg_err("error (addr %02x %02x <- %02x, err = %i)\n",\r\nmsg.buf[0], msg.buf[1], msg.buf[2], ret);\r\nif (ret < 0)\r\nreturn ret;\r\nelse\r\nreturn -EREMOTEIO;\r\n}\r\nreturn 0;\r\n}\r\nstatic int lg216x_read_reg(struct lg216x_state *state, u16 reg, u8 *val)\r\n{\r\nint ret;\r\nu8 reg_buf[] = { reg >> 8, reg & 0xff };\r\nstruct i2c_msg msg[] = {\r\n{ .addr = state->cfg->i2c_addr,\r\n.flags = 0, .buf = reg_buf, .len = 2 },\r\n{ .addr = state->cfg->i2c_addr,\r\n.flags = I2C_M_RD, .buf = val, .len = 1 },\r\n};\r\nlg_reg("reg: 0x%04x\n", reg);\r\nret = i2c_transfer(state->i2c_adap, msg, 2);\r\nif (ret != 2) {\r\nlg_err("error (addr %02x reg %04x error (ret == %i)\n",\r\nstate->cfg->i2c_addr, reg, ret);\r\nif (ret < 0)\r\nreturn ret;\r\nelse\r\nreturn -EREMOTEIO;\r\n}\r\nreturn 0;\r\n}\r\nstatic int lg216x_write_regs(struct lg216x_state *state,\r\nstruct lg216x_reg *regs, int len)\r\n{\r\nint i, ret;\r\nlg_reg("writing %d registers...\n", len);\r\nfor (i = 0; i < len; i++) {\r\nret = lg216x_write_reg(state, regs[i].reg, regs[i].val);\r\nif (lg_fail(ret))\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic int lg216x_set_reg_bit(struct lg216x_state *state,\r\nu16 reg, int bit, int onoff)\r\n{\r\nu8 val;\r\nint ret;\r\nlg_reg("reg: 0x%04x, bit: %d, level: %d\n", reg, bit, onoff);\r\nret = lg216x_read_reg(state, reg, &val);\r\nif (lg_fail(ret))\r\ngoto fail;\r\nval &= ~(1 << bit);\r\nval |= (onoff & 1) << bit;\r\nret = lg216x_write_reg(state, reg, val);\r\nlg_fail(ret);\r\nfail:\r\nreturn ret;\r\n}\r\nstatic int lg216x_i2c_gate_ctrl(struct dvb_frontend *fe, int enable)\r\n{\r\nstruct lg216x_state *state = fe->demodulator_priv;\r\nint ret;\r\nif (state->cfg->deny_i2c_rptr)\r\nreturn 0;\r\nlg_dbg("(%d)\n", enable);\r\nret = lg216x_set_reg_bit(state, 0x0000, 0, enable ? 0 : 1);\r\nmsleep(1);\r\nreturn ret;\r\n}\r\nstatic int lg216x_soft_reset(struct lg216x_state *state)\r\n{\r\nint ret;\r\nlg_dbg("\n");\r\nret = lg216x_write_reg(state, 0x0002, 0x00);\r\nif (lg_fail(ret))\r\ngoto fail;\r\nmsleep(20);\r\nret = lg216x_write_reg(state, 0x0002, 0x01);\r\nif (lg_fail(ret))\r\ngoto fail;\r\nstate->last_reset = jiffies_to_msecs(jiffies);\r\nfail:\r\nreturn ret;\r\n}\r\nstatic int lg216x_initialize(struct lg216x_state *state)\r\n{\r\nint ret;\r\nstatic struct lg216x_reg lg2160_init[] = {\r\n#if 0\r\n{ .reg = 0x0015, .val = 0xe6 },\r\n#else\r\n{ .reg = 0x0015, .val = 0xf7 },\r\n{ .reg = 0x001b, .val = 0x52 },\r\n{ .reg = 0x0208, .val = 0x00 },\r\n{ .reg = 0x0209, .val = 0x82 },\r\n{ .reg = 0x0210, .val = 0xf9 },\r\n{ .reg = 0x020a, .val = 0x00 },\r\n{ .reg = 0x020b, .val = 0x82 },\r\n{ .reg = 0x020d, .val = 0x28 },\r\n{ .reg = 0x020f, .val = 0x14 },\r\n#endif\r\n};\r\nstatic struct lg216x_reg lg2161_init[] = {\r\n{ .reg = 0x0000, .val = 0x41 },\r\n{ .reg = 0x0001, .val = 0xfb },\r\n{ .reg = 0x0216, .val = 0x00 },\r\n{ .reg = 0x0219, .val = 0x00 },\r\n{ .reg = 0x021b, .val = 0x55 },\r\n{ .reg = 0x0606, .val = 0x0a },\r\n};\r\nswitch (state->cfg->lg_chip) {\r\ncase LG2160:\r\nret = lg216x_write_regs(state,\r\nlg2160_init, ARRAY_SIZE(lg2160_init));\r\nbreak;\r\ncase LG2161:\r\nret = lg216x_write_regs(state,\r\nlg2161_init, ARRAY_SIZE(lg2161_init));\r\nbreak;\r\ndefault:\r\nret = -EINVAL;\r\nbreak;\r\n}\r\nif (lg_fail(ret))\r\ngoto fail;\r\nret = lg216x_soft_reset(state);\r\nlg_fail(ret);\r\nfail:\r\nreturn ret;\r\n}\r\nstatic int lg216x_set_if(struct lg216x_state *state)\r\n{\r\nu8 val;\r\nint ret;\r\nlg_dbg("%d KHz\n", state->cfg->if_khz);\r\nret = lg216x_read_reg(state, 0x0132, &val);\r\nif (lg_fail(ret))\r\ngoto fail;\r\nval &= 0xfb;\r\nval |= (0 == state->cfg->if_khz) ? 0x04 : 0x00;\r\nret = lg216x_write_reg(state, 0x0132, val);\r\nlg_fail(ret);\r\nfail:\r\nreturn ret;\r\n}\r\nstatic int lg2160_agc_fix(struct lg216x_state *state,\r\nint if_agc_fix, int rf_agc_fix)\r\n{\r\nu8 val;\r\nint ret;\r\nret = lg216x_read_reg(state, 0x0100, &val);\r\nif (lg_fail(ret))\r\ngoto fail;\r\nval &= 0xf3;\r\nval |= (if_agc_fix) ? 0x08 : 0x00;\r\nval |= (rf_agc_fix) ? 0x04 : 0x00;\r\nret = lg216x_write_reg(state, 0x0100, val);\r\nlg_fail(ret);\r\nfail:\r\nreturn ret;\r\n}\r\nstatic int lg2160_agc_polarity(struct lg216x_state *state,\r\nint if_agc_polarity, int rf_agc_polarity)\r\n{\r\nu8 val;\r\nint ret;\r\nret = lg216x_read_reg(state, 0x0100, &val);\r\nif (lg_fail(ret))\r\ngoto fail;\r\nval &= 0xfc;\r\nval |= (if_agc_polarity) ? 0x02 : 0x00;\r\nval |= (rf_agc_polarity) ? 0x01 : 0x00;\r\nret = lg216x_write_reg(state, 0x0100, val);\r\nlg_fail(ret);\r\nfail:\r\nreturn ret;\r\n}\r\nstatic int lg2160_tuner_pwr_save_polarity(struct lg216x_state *state,\r\nint polarity)\r\n{\r\nu8 val;\r\nint ret;\r\nret = lg216x_read_reg(state, 0x0008, &val);\r\nif (lg_fail(ret))\r\ngoto fail;\r\nval &= 0xfe;\r\nval |= (polarity) ? 0x01 : 0x00;\r\nret = lg216x_write_reg(state, 0x0008, val);\r\nlg_fail(ret);\r\nfail:\r\nreturn ret;\r\n}\r\nstatic int lg2160_spectrum_polarity(struct lg216x_state *state,\r\nint inverted)\r\n{\r\nu8 val;\r\nint ret;\r\nret = lg216x_read_reg(state, 0x0132, &val);\r\nif (lg_fail(ret))\r\ngoto fail;\r\nval &= 0xfd;\r\nval |= (inverted) ? 0x02 : 0x00;\r\nret = lg216x_write_reg(state, 0x0132, val);\r\nlg_fail(ret);\r\nfail:\r\nreturn lg216x_soft_reset(state);\r\n}\r\nstatic int lg2160_tuner_pwr_save(struct lg216x_state *state, int onoff)\r\n{\r\nu8 val;\r\nint ret;\r\nret = lg216x_read_reg(state, 0x0007, &val);\r\nif (lg_fail(ret))\r\ngoto fail;\r\nval &= 0xbf;\r\nval |= (onoff) ? 0x40 : 0x00;\r\nret = lg216x_write_reg(state, 0x0007, val);\r\nlg_fail(ret);\r\nfail:\r\nreturn ret;\r\n}\r\nstatic int lg216x_set_parade(struct lg216x_state *state, int id)\r\n{\r\nint ret;\r\nret = lg216x_write_reg(state, 0x013e, id & 0x7f);\r\nif (lg_fail(ret))\r\ngoto fail;\r\nstate->parade_id = id & 0x7f;\r\nfail:\r\nreturn ret;\r\n}\r\nstatic int lg216x_set_ensemble(struct lg216x_state *state, int id)\r\n{\r\nint ret;\r\nu16 reg;\r\nu8 val;\r\nswitch (state->cfg->lg_chip) {\r\ncase LG2160:\r\nreg = 0x0400;\r\nbreak;\r\ncase LG2161:\r\ndefault:\r\nreg = 0x0500;\r\nbreak;\r\n}\r\nret = lg216x_read_reg(state, reg, &val);\r\nif (lg_fail(ret))\r\ngoto fail;\r\nval &= 0xfe;\r\nval |= (id) ? 0x01 : 0x00;\r\nret = lg216x_write_reg(state, reg, val);\r\nlg_fail(ret);\r\nfail:\r\nreturn ret;\r\n}\r\nstatic int lg2160_set_spi_clock(struct lg216x_state *state)\r\n{\r\nu8 val;\r\nint ret;\r\nret = lg216x_read_reg(state, 0x0014, &val);\r\nif (lg_fail(ret))\r\ngoto fail;\r\nval &= 0xf3;\r\nval |= (state->cfg->spi_clock << 2);\r\nret = lg216x_write_reg(state, 0x0014, val);\r\nlg_fail(ret);\r\nfail:\r\nreturn ret;\r\n}\r\nstatic int lg2161_set_output_interface(struct lg216x_state *state)\r\n{\r\nu8 val;\r\nint ret;\r\nret = lg216x_read_reg(state, 0x0014, &val);\r\nif (lg_fail(ret))\r\ngoto fail;\r\nval &= ~0x07;\r\nval |= state->cfg->output_if;\r\nret = lg216x_write_reg(state, 0x0014, val);\r\nlg_fail(ret);\r\nfail:\r\nreturn ret;\r\n}\r\nstatic int lg216x_enable_fic(struct lg216x_state *state, int onoff)\r\n{\r\nint ret;\r\nret = lg216x_write_reg(state, 0x0017, 0x23);\r\nif (lg_fail(ret))\r\ngoto fail;\r\nret = lg216x_write_reg(state, 0x0016, 0xfc);\r\nif (lg_fail(ret))\r\ngoto fail;\r\nswitch (state->cfg->lg_chip) {\r\ncase LG2160:\r\nret = lg216x_write_reg(state, 0x0016,\r\n0xfc | ((onoff) ? 0x02 : 0x00));\r\nbreak;\r\ncase LG2161:\r\nret = lg216x_write_reg(state, 0x0016, (onoff) ? 0x10 : 0x00);\r\nbreak;\r\n}\r\nif (lg_fail(ret))\r\ngoto fail;\r\nret = lg216x_initialize(state);\r\nif (lg_fail(ret))\r\ngoto fail;\r\nif (onoff) {\r\nret = lg216x_write_reg(state, 0x0017, 0x03);\r\nlg_fail(ret);\r\n}\r\nfail:\r\nreturn ret;\r\n}\r\nstatic int lg216x_get_fic_version(struct lg216x_state *state, u8 *ficver)\r\n{\r\nu8 val;\r\nint ret;\r\n*ficver = 0xff;\r\nret = lg216x_read_reg(state, 0x0128, &val);\r\nif (lg_fail(ret))\r\ngoto fail;\r\n*ficver = (val >> 3) & 0x1f;\r\nfail:\r\nreturn ret;\r\n}\r\nstatic int lg216x_get_nog(struct lg216x_state *state, u8 *nog)\r\n{\r\nu8 val;\r\nint ret;\r\n*nog = 0xff;\r\nret = lg216x_read_reg(state, 0x0124, &val);\r\nif (lg_fail(ret))\r\ngoto fail;\r\n*nog = ((val >> 4) & 0x07) + 1;\r\nfail:\r\nreturn ret;\r\n}\r\nstatic int lg216x_get_tnog(struct lg216x_state *state, u8 *tnog)\r\n{\r\nu8 val;\r\nint ret;\r\n*tnog = 0xff;\r\nret = lg216x_read_reg(state, 0x0125, &val);\r\nif (lg_fail(ret))\r\ngoto fail;\r\n*tnog = val & 0x1f;\r\nfail:\r\nreturn ret;\r\n}\r\nstatic int lg216x_get_sgn(struct lg216x_state *state, u8 *sgn)\r\n{\r\nu8 val;\r\nint ret;\r\n*sgn = 0xff;\r\nret = lg216x_read_reg(state, 0x0124, &val);\r\nif (lg_fail(ret))\r\ngoto fail;\r\n*sgn = val & 0x0f;\r\nfail:\r\nreturn ret;\r\n}\r\nstatic int lg216x_get_prc(struct lg216x_state *state, u8 *prc)\r\n{\r\nu8 val;\r\nint ret;\r\n*prc = 0xff;\r\nret = lg216x_read_reg(state, 0x0125, &val);\r\nif (lg_fail(ret))\r\ngoto fail;\r\n*prc = ((val >> 5) & 0x07) + 1;\r\nfail:\r\nreturn ret;\r\n}\r\nstatic int lg216x_get_rs_frame_mode(struct lg216x_state *state,\r\nenum atscmh_rs_frame_mode *rs_framemode)\r\n{\r\nu8 val;\r\nint ret;\r\nswitch (state->cfg->lg_chip) {\r\ncase LG2160:\r\nret = lg216x_read_reg(state, 0x0410, &val);\r\nbreak;\r\ncase LG2161:\r\nret = lg216x_read_reg(state, 0x0513, &val);\r\nbreak;\r\ndefault:\r\nret = -EINVAL;\r\n}\r\nif (lg_fail(ret))\r\ngoto fail;\r\nswitch ((val >> 4) & 0x03) {\r\n#if 1\r\ndefault:\r\n#endif\r\ncase 0x00:\r\n*rs_framemode = ATSCMH_RSFRAME_PRI_ONLY;\r\nbreak;\r\ncase 0x01:\r\n*rs_framemode = ATSCMH_RSFRAME_PRI_SEC;\r\nbreak;\r\n#if 0\r\ndefault:\r\n*rs_framemode = ATSCMH_RSFRAME_RES;\r\nbreak;\r\n#endif\r\n}\r\nfail:\r\nreturn ret;\r\n}\r\nstatic\r\nint lg216x_get_rs_frame_ensemble(struct lg216x_state *state,\r\nenum atscmh_rs_frame_ensemble *rs_frame_ens)\r\n{\r\nu8 val;\r\nint ret;\r\nswitch (state->cfg->lg_chip) {\r\ncase LG2160:\r\nret = lg216x_read_reg(state, 0x0400, &val);\r\nbreak;\r\ncase LG2161:\r\nret = lg216x_read_reg(state, 0x0500, &val);\r\nbreak;\r\ndefault:\r\nret = -EINVAL;\r\n}\r\nif (lg_fail(ret))\r\ngoto fail;\r\nval &= 0x01;\r\n*rs_frame_ens = (enum atscmh_rs_frame_ensemble) val;\r\nfail:\r\nreturn ret;\r\n}\r\nstatic int lg216x_get_rs_code_mode(struct lg216x_state *state,\r\nenum atscmh_rs_code_mode *rs_code_pri,\r\nenum atscmh_rs_code_mode *rs_code_sec)\r\n{\r\nu8 val;\r\nint ret;\r\nswitch (state->cfg->lg_chip) {\r\ncase LG2160:\r\nret = lg216x_read_reg(state, 0x0410, &val);\r\nbreak;\r\ncase LG2161:\r\nret = lg216x_read_reg(state, 0x0513, &val);\r\nbreak;\r\ndefault:\r\nret = -EINVAL;\r\n}\r\nif (lg_fail(ret))\r\ngoto fail;\r\n*rs_code_pri = (enum atscmh_rs_code_mode) ((val >> 2) & 0x03);\r\n*rs_code_sec = (enum atscmh_rs_code_mode) (val & 0x03);\r\nfail:\r\nreturn ret;\r\n}\r\nstatic int lg216x_get_sccc_block_mode(struct lg216x_state *state,\r\nenum atscmh_sccc_block_mode *sccc_block)\r\n{\r\nu8 val;\r\nint ret;\r\nswitch (state->cfg->lg_chip) {\r\ncase LG2160:\r\nret = lg216x_read_reg(state, 0x0315, &val);\r\nbreak;\r\ncase LG2161:\r\nret = lg216x_read_reg(state, 0x0511, &val);\r\nbreak;\r\ndefault:\r\nret = -EINVAL;\r\n}\r\nif (lg_fail(ret))\r\ngoto fail;\r\nswitch (val & 0x03) {\r\ncase 0x00:\r\n*sccc_block = ATSCMH_SCCC_BLK_SEP;\r\nbreak;\r\ncase 0x01:\r\n*sccc_block = ATSCMH_SCCC_BLK_COMB;\r\nbreak;\r\ndefault:\r\n*sccc_block = ATSCMH_SCCC_BLK_RES;\r\nbreak;\r\n}\r\nfail:\r\nreturn ret;\r\n}\r\nstatic int lg216x_get_sccc_code_mode(struct lg216x_state *state,\r\nenum atscmh_sccc_code_mode *mode_a,\r\nenum atscmh_sccc_code_mode *mode_b,\r\nenum atscmh_sccc_code_mode *mode_c,\r\nenum atscmh_sccc_code_mode *mode_d)\r\n{\r\nu8 val;\r\nint ret;\r\nswitch (state->cfg->lg_chip) {\r\ncase LG2160:\r\nret = lg216x_read_reg(state, 0x0316, &val);\r\nbreak;\r\ncase LG2161:\r\nret = lg216x_read_reg(state, 0x0512, &val);\r\nbreak;\r\ndefault:\r\nret = -EINVAL;\r\n}\r\nif (lg_fail(ret))\r\ngoto fail;\r\nswitch ((val >> 6) & 0x03) {\r\ncase 0x00:\r\n*mode_a = ATSCMH_SCCC_CODE_HLF;\r\nbreak;\r\ncase 0x01:\r\n*mode_a = ATSCMH_SCCC_CODE_QTR;\r\nbreak;\r\ndefault:\r\n*mode_a = ATSCMH_SCCC_CODE_RES;\r\nbreak;\r\n}\r\nswitch ((val >> 4) & 0x03) {\r\ncase 0x00:\r\n*mode_b = ATSCMH_SCCC_CODE_HLF;\r\nbreak;\r\ncase 0x01:\r\n*mode_b = ATSCMH_SCCC_CODE_QTR;\r\nbreak;\r\ndefault:\r\n*mode_b = ATSCMH_SCCC_CODE_RES;\r\nbreak;\r\n}\r\nswitch ((val >> 2) & 0x03) {\r\ncase 0x00:\r\n*mode_c = ATSCMH_SCCC_CODE_HLF;\r\nbreak;\r\ncase 0x01:\r\n*mode_c = ATSCMH_SCCC_CODE_QTR;\r\nbreak;\r\ndefault:\r\n*mode_c = ATSCMH_SCCC_CODE_RES;\r\nbreak;\r\n}\r\nswitch (val & 0x03) {\r\ncase 0x00:\r\n*mode_d = ATSCMH_SCCC_CODE_HLF;\r\nbreak;\r\ncase 0x01:\r\n*mode_d = ATSCMH_SCCC_CODE_QTR;\r\nbreak;\r\ndefault:\r\n*mode_d = ATSCMH_SCCC_CODE_RES;\r\nbreak;\r\n}\r\nfail:\r\nreturn ret;\r\n}\r\nstatic int lg216x_get_frontend(struct dvb_frontend *fe)\r\n{\r\nstruct lg216x_state *state = fe->demodulator_priv;\r\nint ret;\r\nlg_dbg("\n");\r\nfe->dtv_property_cache.modulation = VSB_8;\r\nfe->dtv_property_cache.frequency = state->current_frequency;\r\nfe->dtv_property_cache.delivery_system = SYS_ATSCMH;\r\nret = lg216x_get_fic_version(state,\r\n&fe->dtv_property_cache.atscmh_fic_ver);\r\nif (lg_fail(ret))\r\ngoto fail;\r\nif (state->fic_ver != fe->dtv_property_cache.atscmh_fic_ver) {\r\nstate->fic_ver = fe->dtv_property_cache.atscmh_fic_ver;\r\n#if 0\r\nret = lg2160_get_parade_id(state,\r\n&fe->dtv_property_cache.atscmh_parade_id);\r\nif (lg_fail(ret))\r\ngoto fail;\r\nfe->dtv_property_cache.atscmh_parade_id = state->parade_id;\r\n#endif\r\nret = lg216x_get_nog(state,\r\n&fe->dtv_property_cache.atscmh_nog);\r\nif (lg_fail(ret))\r\ngoto fail;\r\nret = lg216x_get_tnog(state,\r\n&fe->dtv_property_cache.atscmh_tnog);\r\nif (lg_fail(ret))\r\ngoto fail;\r\nret = lg216x_get_sgn(state,\r\n&fe->dtv_property_cache.atscmh_sgn);\r\nif (lg_fail(ret))\r\ngoto fail;\r\nret = lg216x_get_prc(state,\r\n&fe->dtv_property_cache.atscmh_prc);\r\nif (lg_fail(ret))\r\ngoto fail;\r\nret = lg216x_get_rs_frame_mode(state,\r\n(enum atscmh_rs_frame_mode *)\r\n&fe->dtv_property_cache.atscmh_rs_frame_mode);\r\nif (lg_fail(ret))\r\ngoto fail;\r\nret = lg216x_get_rs_frame_ensemble(state,\r\n(enum atscmh_rs_frame_ensemble *)\r\n&fe->dtv_property_cache.atscmh_rs_frame_ensemble);\r\nif (lg_fail(ret))\r\ngoto fail;\r\nret = lg216x_get_rs_code_mode(state,\r\n(enum atscmh_rs_code_mode *)\r\n&fe->dtv_property_cache.atscmh_rs_code_mode_pri,\r\n(enum atscmh_rs_code_mode *)\r\n&fe->dtv_property_cache.atscmh_rs_code_mode_sec);\r\nif (lg_fail(ret))\r\ngoto fail;\r\nret = lg216x_get_sccc_block_mode(state,\r\n(enum atscmh_sccc_block_mode *)\r\n&fe->dtv_property_cache.atscmh_sccc_block_mode);\r\nif (lg_fail(ret))\r\ngoto fail;\r\nret = lg216x_get_sccc_code_mode(state,\r\n(enum atscmh_sccc_code_mode *)\r\n&fe->dtv_property_cache.atscmh_sccc_code_mode_a,\r\n(enum atscmh_sccc_code_mode *)\r\n&fe->dtv_property_cache.atscmh_sccc_code_mode_b,\r\n(enum atscmh_sccc_code_mode *)\r\n&fe->dtv_property_cache.atscmh_sccc_code_mode_c,\r\n(enum atscmh_sccc_code_mode *)\r\n&fe->dtv_property_cache.atscmh_sccc_code_mode_d);\r\nif (lg_fail(ret))\r\ngoto fail;\r\n}\r\n#if 0\r\nret = lg216x_read_fic_err_count(state,\r\n(u8 *)&fe->dtv_property_cache.atscmh_fic_err);\r\nif (lg_fail(ret))\r\ngoto fail;\r\nret = lg216x_read_crc_err_count(state,\r\n&fe->dtv_property_cache.atscmh_crc_err);\r\nif (lg_fail(ret))\r\ngoto fail;\r\nret = lg216x_read_rs_err_count(state,\r\n&fe->dtv_property_cache.atscmh_rs_err);\r\nif (lg_fail(ret))\r\ngoto fail;\r\nswitch (state->cfg->lg_chip) {\r\ncase LG2160:\r\nif (((fe->dtv_property_cache.atscmh_rs_err >= 240) &&\r\n(fe->dtv_property_cache.atscmh_crc_err >= 240)) &&\r\n((jiffies_to_msecs(jiffies) - state->last_reset) > 6000))\r\nret = lg216x_soft_reset(state);\r\nbreak;\r\ncase LG2161:\r\nret = 0;\r\nbreak;\r\n}\r\nlg_fail(ret);\r\n#endif\r\nfail:\r\nreturn ret;\r\n}\r\nstatic int lg216x_get_property(struct dvb_frontend *fe,\r\nstruct dtv_property *tvp)\r\n{\r\nreturn (DTV_ATSCMH_FIC_VER == tvp->cmd) ?\r\nlg216x_get_frontend(fe) : 0;\r\n}\r\nstatic int lg2160_set_frontend(struct dvb_frontend *fe)\r\n{\r\nstruct lg216x_state *state = fe->demodulator_priv;\r\nint ret;\r\nlg_dbg("(%d)\n", fe->dtv_property_cache.frequency);\r\nif (fe->ops.tuner_ops.set_params) {\r\nret = fe->ops.tuner_ops.set_params(fe);\r\nif (fe->ops.i2c_gate_ctrl)\r\nfe->ops.i2c_gate_ctrl(fe, 0);\r\nif (lg_fail(ret))\r\ngoto fail;\r\nstate->current_frequency = fe->dtv_property_cache.frequency;\r\n}\r\nret = lg2160_agc_fix(state, 0, 0);\r\nif (lg_fail(ret))\r\ngoto fail;\r\nret = lg2160_agc_polarity(state, 0, 0);\r\nif (lg_fail(ret))\r\ngoto fail;\r\nret = lg2160_tuner_pwr_save_polarity(state, 1);\r\nif (lg_fail(ret))\r\ngoto fail;\r\nret = lg216x_set_if(state);\r\nif (lg_fail(ret))\r\ngoto fail;\r\nret = lg2160_spectrum_polarity(state, state->cfg->spectral_inversion);\r\nif (lg_fail(ret))\r\ngoto fail;\r\nret = lg216x_soft_reset(state);\r\nif (lg_fail(ret))\r\ngoto fail;\r\nret = lg2160_tuner_pwr_save(state, 0);\r\nif (lg_fail(ret))\r\ngoto fail;\r\nswitch (state->cfg->lg_chip) {\r\ncase LG2160:\r\nret = lg2160_set_spi_clock(state);\r\nif (lg_fail(ret))\r\ngoto fail;\r\nbreak;\r\ncase LG2161:\r\nret = lg2161_set_output_interface(state);\r\nif (lg_fail(ret))\r\ngoto fail;\r\nbreak;\r\n}\r\nret = lg216x_set_parade(state, fe->dtv_property_cache.atscmh_parade_id);\r\nif (lg_fail(ret))\r\ngoto fail;\r\nret = lg216x_set_ensemble(state,\r\nfe->dtv_property_cache.atscmh_rs_frame_ensemble);\r\nif (lg_fail(ret))\r\ngoto fail;\r\nret = lg216x_initialize(state);\r\nif (lg_fail(ret))\r\ngoto fail;\r\nret = lg216x_enable_fic(state, 1);\r\nlg_fail(ret);\r\nlg216x_get_frontend(fe);\r\nfail:\r\nreturn ret;\r\n}\r\nstatic int lg2160_read_lock_status(struct lg216x_state *state,\r\nint *acq_lock, int *sync_lock)\r\n{\r\nu8 val;\r\nint ret;\r\n*acq_lock = 0;\r\n*sync_lock = 0;\r\nret = lg216x_read_reg(state, 0x011b, &val);\r\nif (lg_fail(ret))\r\ngoto fail;\r\n*sync_lock = (val & 0x20) ? 0 : 1;\r\n*acq_lock = (val & 0x40) ? 0 : 1;\r\nfail:\r\nreturn ret;\r\n}\r\nstatic int lg2161_read_lock_status(struct lg216x_state *state,\r\nint *acq_lock, int *sync_lock)\r\n{\r\nu8 val;\r\nint ret;\r\n*acq_lock = 0;\r\n*sync_lock = 0;\r\nret = lg216x_read_reg(state, 0x0304, &val);\r\nif (lg_fail(ret))\r\ngoto fail;\r\n*sync_lock = (val & 0x80) ? 0 : 1;\r\nret = lg216x_read_reg(state, 0x011b, &val);\r\nif (lg_fail(ret))\r\ngoto fail;\r\n*acq_lock = (val & 0x40) ? 0 : 1;\r\nfail:\r\nreturn ret;\r\n}\r\nstatic int lg216x_read_lock_status(struct lg216x_state *state,\r\nint *acq_lock, int *sync_lock)\r\n{\r\n#ifdef USE_LG2161_LOCK_BITS\r\nint ret;\r\nswitch (state->cfg->lg_chip) {\r\ncase LG2160:\r\nret = lg2160_read_lock_status(state, acq_lock, sync_lock);\r\nbreak;\r\ncase LG2161:\r\nret = lg2161_read_lock_status(state, acq_lock, sync_lock);\r\nbreak;\r\ndefault:\r\nret = -EINVAL;\r\nbreak;\r\n}\r\nreturn ret;\r\n#else\r\nreturn lg2160_read_lock_status(state, acq_lock, sync_lock);\r\n#endif\r\n}\r\nstatic int lg216x_read_status(struct dvb_frontend *fe, enum fe_status *status)\r\n{\r\nstruct lg216x_state *state = fe->demodulator_priv;\r\nint ret, acq_lock, sync_lock;\r\n*status = 0;\r\nret = lg216x_read_lock_status(state, &acq_lock, &sync_lock);\r\nif (lg_fail(ret))\r\ngoto fail;\r\nlg_dbg("%s%s\n",\r\nacq_lock ? "SIGNALEXIST " : "",\r\nsync_lock ? "SYNCLOCK" : "");\r\nif (acq_lock)\r\n*status |= FE_HAS_SIGNAL;\r\nif (sync_lock)\r\n*status |= FE_HAS_SYNC;\r\nif (*status)\r\n*status |= FE_HAS_CARRIER | FE_HAS_VITERBI | FE_HAS_LOCK;\r\nfail:\r\nreturn ret;\r\n}\r\nstatic int lg2160_read_snr(struct dvb_frontend *fe, u16 *snr)\r\n{\r\nstruct lg216x_state *state = fe->demodulator_priv;\r\nu8 snr1, snr2;\r\nint ret;\r\n*snr = 0;\r\nret = lg216x_read_reg(state, 0x0202, &snr1);\r\nif (lg_fail(ret))\r\ngoto fail;\r\nret = lg216x_read_reg(state, 0x0203, &snr2);\r\nif (lg_fail(ret))\r\ngoto fail;\r\nif ((snr1 == 0xba) || (snr2 == 0xdf))\r\n*snr = 0;\r\nelse\r\n#if 1\r\n*snr = ((snr1 >> 4) * 100) + ((snr1 & 0x0f) * 10) + (snr2 >> 4);\r\n#else\r\n*snr = (snr2 | (snr1 << 8));\r\n#endif\r\nfail:\r\nreturn ret;\r\n}\r\nstatic int lg2161_read_snr(struct dvb_frontend *fe, u16 *snr)\r\n{\r\nstruct lg216x_state *state = fe->demodulator_priv;\r\nu8 snr1, snr2;\r\nint ret;\r\n*snr = 0;\r\nret = lg216x_read_reg(state, 0x0302, &snr1);\r\nif (lg_fail(ret))\r\ngoto fail;\r\nret = lg216x_read_reg(state, 0x0303, &snr2);\r\nif (lg_fail(ret))\r\ngoto fail;\r\nif ((snr1 == 0xba) || (snr2 == 0xfd))\r\n*snr = 0;\r\nelse\r\n*snr = ((snr1 >> 4) * 100) + ((snr1 & 0x0f) * 10) + (snr2 & 0x0f);\r\nfail:\r\nreturn ret;\r\n}\r\nstatic int lg216x_read_signal_strength(struct dvb_frontend *fe,\r\nu16 *strength)\r\n{\r\n#if 0\r\nstruct lg216x_state *state = fe->demodulator_priv;\r\nu16 snr;\r\nint ret;\r\n#endif\r\n*strength = 0;\r\n#if 0\r\nret = fe->ops.read_snr(fe, &snr);\r\nif (lg_fail(ret))\r\ngoto fail;\r\nif (state->snr >= 8960 * 0x10000)\r\n*strength = 0xffff;\r\nelse\r\n*strength = state->snr / 8960;\r\nfail:\r\nreturn ret;\r\n#else\r\nreturn 0;\r\n#endif\r\n}\r\nstatic int lg216x_read_ucblocks(struct dvb_frontend *fe, u32 *ucblocks)\r\n{\r\n#if 0\r\nstruct lg216x_state *state = fe->demodulator_priv;\r\nint ret;\r\nret = lg216x_read_rs_err_count(state,\r\n&fe->dtv_property_cache.atscmh_rs_err);\r\nif (lg_fail(ret))\r\ngoto fail;\r\n*ucblocks = fe->dtv_property_cache.atscmh_rs_err;\r\nfail:\r\n#else\r\n*ucblocks = 0;\r\n#endif\r\nreturn 0;\r\n}\r\nstatic int lg216x_get_tune_settings(struct dvb_frontend *fe,\r\nstruct dvb_frontend_tune_settings\r\n*fe_tune_settings)\r\n{\r\nfe_tune_settings->min_delay_ms = 500;\r\nlg_dbg("\n");\r\nreturn 0;\r\n}\r\nstatic void lg216x_release(struct dvb_frontend *fe)\r\n{\r\nstruct lg216x_state *state = fe->demodulator_priv;\r\nlg_dbg("\n");\r\nkfree(state);\r\n}\r\nstruct dvb_frontend *lg2160_attach(const struct lg2160_config *config,\r\nstruct i2c_adapter *i2c_adap)\r\n{\r\nstruct lg216x_state *state = NULL;\r\nlg_dbg("(%d-%04x)\n",\r\ni2c_adap ? i2c_adapter_id(i2c_adap) : 0,\r\nconfig ? config->i2c_addr : 0);\r\nstate = kzalloc(sizeof(struct lg216x_state), GFP_KERNEL);\r\nif (!state)\r\nreturn NULL;\r\nstate->cfg = config;\r\nstate->i2c_adap = i2c_adap;\r\nstate->fic_ver = 0xff;\r\nstate->parade_id = 0xff;\r\nswitch (config->lg_chip) {\r\ndefault:\r\nlg_warn("invalid chip requested, defaulting to LG2160");\r\ncase LG2160:\r\nmemcpy(&state->frontend.ops, &lg2160_ops,\r\nsizeof(struct dvb_frontend_ops));\r\nbreak;\r\ncase LG2161:\r\nmemcpy(&state->frontend.ops, &lg2161_ops,\r\nsizeof(struct dvb_frontend_ops));\r\nbreak;\r\n}\r\nstate->frontend.demodulator_priv = state;\r\nstate->current_frequency = -1;\r\nstate->frontend.dtv_property_cache.atscmh_parade_id = 1;\r\nreturn &state->frontend;\r\n}
