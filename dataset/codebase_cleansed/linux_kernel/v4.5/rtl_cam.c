void rtl92e_cam_reset(struct net_device *dev)\r\n{\r\nu32 ulcommand = 0;\r\nulcommand |= BIT31|BIT30;\r\nrtl92e_writel(dev, RWCAM, ulcommand);\r\n}\r\nvoid rtl92e_enable_hw_security_config(struct net_device *dev)\r\n{\r\nu8 SECR_value = 0x0;\r\nstruct r8192_priv *priv = (struct r8192_priv *)rtllib_priv(dev);\r\nstruct rtllib_device *ieee = priv->rtllib;\r\nSECR_value = SCR_TxEncEnable | SCR_RxDecEnable;\r\nif (((ieee->pairwise_key_type == KEY_TYPE_WEP40) ||\r\n(ieee->pairwise_key_type == KEY_TYPE_WEP104)) &&\r\n(priv->rtllib->auth_mode != 2)) {\r\nSECR_value |= SCR_RxUseDK;\r\nSECR_value |= SCR_TxUseDK;\r\n} else if ((ieee->iw_mode == IW_MODE_ADHOC) &&\r\n(ieee->pairwise_key_type & (KEY_TYPE_CCMP |\r\nKEY_TYPE_TKIP))) {\r\nSECR_value |= SCR_RxUseDK;\r\nSECR_value |= SCR_TxUseDK;\r\n}\r\nieee->hwsec_active = 1;\r\nif ((ieee->pHTInfo->IOTAction&HT_IOT_ACT_PURE_N_MODE) || !hwwep) {\r\nieee->hwsec_active = 0;\r\nSECR_value &= ~SCR_RxDecEnable;\r\n}\r\nRT_TRACE(COMP_SEC, "%s:, hwsec:%d, pairwise_key:%d, SECR_value:%x\n",\r\n__func__, ieee->hwsec_active, ieee->pairwise_key_type,\r\nSECR_value);\r\nrtl92e_writeb(dev, SECR, SECR_value);\r\n}\r\nvoid rtl92e_set_swcam(struct net_device *dev, u8 EntryNo, u8 KeyIndex,\r\nu16 KeyType, const u8 *MacAddr, u8 DefaultKey,\r\nu32 *KeyContent, u8 is_mesh)\r\n{\r\nstruct r8192_priv *priv = rtllib_priv(dev);\r\nstruct rtllib_device *ieee = priv->rtllib;\r\nRT_TRACE(COMP_DBG,\r\n"===========>%s():EntryNo is %d,KeyIndex is %d,KeyType is %d,is_mesh is %d\n",\r\n__func__, EntryNo, KeyIndex, KeyType, is_mesh);\r\nif (EntryNo >= TOTAL_CAM_ENTRY)\r\nreturn;\r\nif (!is_mesh) {\r\nieee->swcamtable[EntryNo].bused = true;\r\nieee->swcamtable[EntryNo].key_index = KeyIndex;\r\nieee->swcamtable[EntryNo].key_type = KeyType;\r\nmemcpy(ieee->swcamtable[EntryNo].macaddr, MacAddr, 6);\r\nieee->swcamtable[EntryNo].useDK = DefaultKey;\r\nmemcpy(ieee->swcamtable[EntryNo].key_buf, (u8 *)KeyContent, 16);\r\n}\r\n}\r\nvoid rtl92e_set_key(struct net_device *dev, u8 EntryNo, u8 KeyIndex,\r\nu16 KeyType, const u8 *MacAddr, u8 DefaultKey,\r\nu32 *KeyContent)\r\n{\r\nu32 TargetCommand = 0;\r\nu32 TargetContent = 0;\r\nu16 usConfig = 0;\r\nu8 i;\r\nstruct r8192_priv *priv = (struct r8192_priv *)rtllib_priv(dev);\r\nenum rt_rf_power_state rtState;\r\nrtState = priv->rtllib->eRFPowerState;\r\nif (priv->rtllib->PowerSaveControl.bInactivePs) {\r\nif (rtState == eRfOff) {\r\nif (priv->rtllib->RfOffReason > RF_CHANGE_BY_IPS) {\r\nnetdev_warn(dev, "%s(): RF is OFF.\n",\r\n__func__);\r\nreturn;\r\n}\r\ndown(&priv->rtllib->ips_sem);\r\nrtl92e_ips_leave(dev);\r\nup(&priv->rtllib->ips_sem);\r\n}\r\n}\r\npriv->rtllib->is_set_key = true;\r\nif (EntryNo >= TOTAL_CAM_ENTRY) {\r\nnetdev_info(dev, "%s(): Invalid CAM entry\n", __func__);\r\nreturn;\r\n}\r\nRT_TRACE(COMP_SEC,\r\n"====>to rtl92e_set_key(), dev:%p, EntryNo:%d, KeyIndex:%d,KeyType:%d, MacAddr %pM\n",\r\ndev, EntryNo, KeyIndex, KeyType, MacAddr);\r\nif (DefaultKey)\r\nusConfig |= BIT15 | (KeyType<<2);\r\nelse\r\nusConfig |= BIT15 | (KeyType<<2) | KeyIndex;\r\nfor (i = 0; i < CAM_CONTENT_COUNT; i++) {\r\nTargetCommand = i + CAM_CONTENT_COUNT * EntryNo;\r\nTargetCommand |= BIT31|BIT16;\r\nif (i == 0) {\r\nTargetContent = (u32)(*(MacAddr+0)) << 16 |\r\n(u32)(*(MacAddr+1)) << 24 |\r\n(u32)usConfig;\r\nrtl92e_writel(dev, WCAMI, TargetContent);\r\nrtl92e_writel(dev, RWCAM, TargetCommand);\r\n} else if (i == 1) {\r\nTargetContent = (u32)(*(MacAddr+2)) |\r\n(u32)(*(MacAddr+3)) << 8 |\r\n(u32)(*(MacAddr+4)) << 16 |\r\n(u32)(*(MacAddr+5)) << 24;\r\nrtl92e_writel(dev, WCAMI, TargetContent);\r\nrtl92e_writel(dev, RWCAM, TargetCommand);\r\n} else {\r\nif (KeyContent != NULL) {\r\nrtl92e_writel(dev, WCAMI,\r\n(u32)(*(KeyContent+i-2)));\r\nrtl92e_writel(dev, RWCAM, TargetCommand);\r\nudelay(100);\r\n}\r\n}\r\n}\r\nRT_TRACE(COMP_SEC, "=========>after set key, usconfig:%x\n", usConfig);\r\n}\r\nvoid rtl92e_cam_restore(struct net_device *dev)\r\n{\r\nu8 EntryId = 0;\r\nstruct r8192_priv *priv = rtllib_priv(dev);\r\nu8 *MacAddr = priv->rtllib->current_network.bssid;\r\nstatic u8 CAM_CONST_ADDR[4][6] = {\r\n{0x00, 0x00, 0x00, 0x00, 0x00, 0x00},\r\n{0x00, 0x00, 0x00, 0x00, 0x00, 0x01},\r\n{0x00, 0x00, 0x00, 0x00, 0x00, 0x02},\r\n{0x00, 0x00, 0x00, 0x00, 0x00, 0x03}\r\n};\r\nstatic u8 CAM_CONST_BROAD[] = {\r\n0xff, 0xff, 0xff, 0xff, 0xff, 0xff\r\n};\r\nRT_TRACE(COMP_SEC, "rtl92e_cam_restore:\n");\r\nif ((priv->rtllib->pairwise_key_type == KEY_TYPE_WEP40) ||\r\n(priv->rtllib->pairwise_key_type == KEY_TYPE_WEP104)) {\r\nfor (EntryId = 0; EntryId < 4; EntryId++) {\r\nMacAddr = CAM_CONST_ADDR[EntryId];\r\nif (priv->rtllib->swcamtable[EntryId].bused) {\r\nrtl92e_set_key(dev, EntryId, EntryId,\r\npriv->rtllib->pairwise_key_type,\r\nMacAddr, 0,\r\n(u32 *)(&priv->rtllib->swcamtable\r\n[EntryId].key_buf[0]));\r\n}\r\n}\r\n} else if (priv->rtllib->pairwise_key_type == KEY_TYPE_TKIP) {\r\nif (priv->rtllib->iw_mode == IW_MODE_ADHOC) {\r\nrtl92e_set_key(dev, 4, 0,\r\npriv->rtllib->pairwise_key_type,\r\n(u8 *)dev->dev_addr, 0,\r\n(u32 *)(&priv->rtllib->swcamtable[4].\r\nkey_buf[0]));\r\n} else {\r\nrtl92e_set_key(dev, 4, 0,\r\npriv->rtllib->pairwise_key_type,\r\nMacAddr, 0,\r\n(u32 *)(&priv->rtllib->swcamtable[4].\r\nkey_buf[0]));\r\n}\r\n} else if (priv->rtllib->pairwise_key_type == KEY_TYPE_CCMP) {\r\nif (priv->rtllib->iw_mode == IW_MODE_ADHOC) {\r\nrtl92e_set_key(dev, 4, 0,\r\npriv->rtllib->pairwise_key_type,\r\n(u8 *)dev->dev_addr, 0,\r\n(u32 *)(&priv->rtllib->swcamtable[4].\r\nkey_buf[0]));\r\n} else {\r\nrtl92e_set_key(dev, 4, 0,\r\npriv->rtllib->pairwise_key_type, MacAddr,\r\n0, (u32 *)(&priv->rtllib->swcamtable[4].\r\nkey_buf[0]));\r\n}\r\n}\r\nif (priv->rtllib->group_key_type == KEY_TYPE_TKIP) {\r\nMacAddr = CAM_CONST_BROAD;\r\nfor (EntryId = 1; EntryId < 4; EntryId++) {\r\nif (priv->rtllib->swcamtable[EntryId].bused) {\r\nrtl92e_set_key(dev, EntryId, EntryId,\r\npriv->rtllib->group_key_type,\r\nMacAddr, 0,\r\n(u32 *)(&priv->rtllib->swcamtable[EntryId].key_buf[0]));\r\n}\r\n}\r\nif (priv->rtllib->iw_mode == IW_MODE_ADHOC) {\r\nif (priv->rtllib->swcamtable[0].bused) {\r\nrtl92e_set_key(dev, 0, 0,\r\npriv->rtllib->group_key_type,\r\nCAM_CONST_ADDR[0], 0,\r\n(u32 *)(&priv->rtllib->swcamtable[0].key_buf[0]));\r\n} else {\r\nnetdev_warn(dev,\r\n"%s(): ADHOC TKIP: missing key entry.\n",\r\n__func__);\r\nreturn;\r\n}\r\n}\r\n} else if (priv->rtllib->group_key_type == KEY_TYPE_CCMP) {\r\nMacAddr = CAM_CONST_BROAD;\r\nfor (EntryId = 1; EntryId < 4; EntryId++) {\r\nif (priv->rtllib->swcamtable[EntryId].bused) {\r\nrtl92e_set_key(dev, EntryId, EntryId,\r\npriv->rtllib->group_key_type,\r\nMacAddr, 0,\r\n(u32 *)(&priv->rtllib->swcamtable[EntryId].key_buf[0]));\r\n}\r\n}\r\nif (priv->rtllib->iw_mode == IW_MODE_ADHOC) {\r\nif (priv->rtllib->swcamtable[0].bused) {\r\nrtl92e_set_key(dev, 0, 0,\r\npriv->rtllib->group_key_type,\r\nCAM_CONST_ADDR[0], 0,\r\n(u32 *)(&priv->rtllib->swcamtable[0].key_buf[0]));\r\n} else {\r\nnetdev_warn(dev,\r\n"%s(): ADHOC CCMP: missing key entry.\n",\r\n__func__);\r\nreturn;\r\n}\r\n}\r\n}\r\n}
