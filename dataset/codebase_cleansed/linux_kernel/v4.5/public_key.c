static void public_key_describe(const struct key *asymmetric_key,\r\nstruct seq_file *m)\r\n{\r\nstruct public_key *key = asymmetric_key->payload.data[asym_crypto];\r\nif (key)\r\nseq_printf(m, "%s.%s",\r\npkey_id_type_name[key->id_type], key->algo->name);\r\n}\r\nvoid public_key_destroy(void *payload)\r\n{\r\nstruct public_key *key = payload;\r\nint i;\r\nif (key) {\r\nfor (i = 0; i < ARRAY_SIZE(key->mpi); i++)\r\nmpi_free(key->mpi[i]);\r\nkfree(key);\r\n}\r\n}\r\nint public_key_verify_signature(const struct public_key *pk,\r\nconst struct public_key_signature *sig)\r\n{\r\nconst struct public_key_algorithm *algo;\r\nBUG_ON(!pk);\r\nBUG_ON(!pk->mpi[0]);\r\nBUG_ON(!pk->mpi[1]);\r\nBUG_ON(!sig);\r\nBUG_ON(!sig->digest);\r\nBUG_ON(!sig->mpi[0]);\r\nalgo = pk->algo;\r\nif (!algo) {\r\nif (pk->pkey_algo >= PKEY_ALGO__LAST)\r\nreturn -ENOPKG;\r\nalgo = pkey_algo[pk->pkey_algo];\r\nif (!algo)\r\nreturn -ENOPKG;\r\n}\r\nif (!algo->verify_signature)\r\nreturn -ENOTSUPP;\r\nif (sig->nr_mpi != algo->n_sig_mpi) {\r\npr_debug("Signature has %u MPI not %u\n",\r\nsig->nr_mpi, algo->n_sig_mpi);\r\nreturn -EINVAL;\r\n}\r\nreturn algo->verify_signature(pk, sig);\r\n}\r\nstatic int public_key_verify_signature_2(const struct key *key,\r\nconst struct public_key_signature *sig)\r\n{\r\nconst struct public_key *pk = key->payload.data[asym_crypto];\r\nreturn public_key_verify_signature(pk, sig);\r\n}
