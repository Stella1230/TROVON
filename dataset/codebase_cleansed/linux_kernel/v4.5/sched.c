static void\r\n__rpc_disable_timer(struct rpc_wait_queue *queue, struct rpc_task *task)\r\n{\r\nif (task->tk_timeout == 0)\r\nreturn;\r\ndprintk("RPC: %5u disabling timer\n", task->tk_pid);\r\ntask->tk_timeout = 0;\r\nlist_del(&task->u.tk_wait.timer_list);\r\nif (list_empty(&queue->timer_list.list))\r\ndel_timer(&queue->timer_list.timer);\r\n}\r\nstatic void\r\nrpc_set_queue_timer(struct rpc_wait_queue *queue, unsigned long expires)\r\n{\r\nqueue->timer_list.expires = expires;\r\nmod_timer(&queue->timer_list.timer, expires);\r\n}\r\nstatic void\r\n__rpc_add_timer(struct rpc_wait_queue *queue, struct rpc_task *task)\r\n{\r\nif (!task->tk_timeout)\r\nreturn;\r\ndprintk("RPC: %5u setting alarm for %u ms\n",\r\ntask->tk_pid, jiffies_to_msecs(task->tk_timeout));\r\ntask->u.tk_wait.expires = jiffies + task->tk_timeout;\r\nif (list_empty(&queue->timer_list.list) || time_before(task->u.tk_wait.expires, queue->timer_list.expires))\r\nrpc_set_queue_timer(queue, task->u.tk_wait.expires);\r\nlist_add(&task->u.tk_wait.timer_list, &queue->timer_list.list);\r\n}\r\nstatic void rpc_rotate_queue_owner(struct rpc_wait_queue *queue)\r\n{\r\nstruct list_head *q = &queue->tasks[queue->priority];\r\nstruct rpc_task *task;\r\nif (!list_empty(q)) {\r\ntask = list_first_entry(q, struct rpc_task, u.tk_wait.list);\r\nif (task->tk_owner == queue->owner)\r\nlist_move_tail(&task->u.tk_wait.list, q);\r\n}\r\n}\r\nstatic void rpc_set_waitqueue_priority(struct rpc_wait_queue *queue, int priority)\r\n{\r\nif (queue->priority != priority) {\r\nrpc_rotate_queue_owner(queue);\r\nqueue->priority = priority;\r\n}\r\n}\r\nstatic void rpc_set_waitqueue_owner(struct rpc_wait_queue *queue, pid_t pid)\r\n{\r\nqueue->owner = pid;\r\nqueue->nr = RPC_BATCH_COUNT;\r\n}\r\nstatic void rpc_reset_waitqueue_priority(struct rpc_wait_queue *queue)\r\n{\r\nrpc_set_waitqueue_priority(queue, queue->maxpriority);\r\nrpc_set_waitqueue_owner(queue, 0);\r\n}\r\nstatic void __rpc_add_wait_queue_priority(struct rpc_wait_queue *queue,\r\nstruct rpc_task *task,\r\nunsigned char queue_priority)\r\n{\r\nstruct list_head *q;\r\nstruct rpc_task *t;\r\nINIT_LIST_HEAD(&task->u.tk_wait.links);\r\nif (unlikely(queue_priority > queue->maxpriority))\r\nqueue_priority = queue->maxpriority;\r\nif (queue_priority > queue->priority)\r\nrpc_set_waitqueue_priority(queue, queue_priority);\r\nq = &queue->tasks[queue_priority];\r\nlist_for_each_entry(t, q, u.tk_wait.list) {\r\nif (t->tk_owner == task->tk_owner) {\r\nlist_add_tail(&task->u.tk_wait.list, &t->u.tk_wait.links);\r\nreturn;\r\n}\r\n}\r\nlist_add_tail(&task->u.tk_wait.list, q);\r\n}\r\nstatic void __rpc_add_wait_queue(struct rpc_wait_queue *queue,\r\nstruct rpc_task *task,\r\nunsigned char queue_priority)\r\n{\r\nWARN_ON_ONCE(RPC_IS_QUEUED(task));\r\nif (RPC_IS_QUEUED(task))\r\nreturn;\r\nif (RPC_IS_PRIORITY(queue))\r\n__rpc_add_wait_queue_priority(queue, task, queue_priority);\r\nelse if (RPC_IS_SWAPPER(task))\r\nlist_add(&task->u.tk_wait.list, &queue->tasks[0]);\r\nelse\r\nlist_add_tail(&task->u.tk_wait.list, &queue->tasks[0]);\r\ntask->tk_waitqueue = queue;\r\nqueue->qlen++;\r\nsmp_wmb();\r\nrpc_set_queued(task);\r\ndprintk("RPC: %5u added to queue %p \"%s\"\n",\r\ntask->tk_pid, queue, rpc_qname(queue));\r\n}\r\nstatic void __rpc_remove_wait_queue_priority(struct rpc_task *task)\r\n{\r\nstruct rpc_task *t;\r\nif (!list_empty(&task->u.tk_wait.links)) {\r\nt = list_entry(task->u.tk_wait.links.next, struct rpc_task, u.tk_wait.list);\r\nlist_move(&t->u.tk_wait.list, &task->u.tk_wait.list);\r\nlist_splice_init(&task->u.tk_wait.links, &t->u.tk_wait.links);\r\n}\r\n}\r\nstatic void __rpc_remove_wait_queue(struct rpc_wait_queue *queue, struct rpc_task *task)\r\n{\r\n__rpc_disable_timer(queue, task);\r\nif (RPC_IS_PRIORITY(queue))\r\n__rpc_remove_wait_queue_priority(task);\r\nlist_del(&task->u.tk_wait.list);\r\nqueue->qlen--;\r\ndprintk("RPC: %5u removed from queue %p \"%s\"\n",\r\ntask->tk_pid, queue, rpc_qname(queue));\r\n}\r\nstatic void __rpc_init_priority_wait_queue(struct rpc_wait_queue *queue, const char *qname, unsigned char nr_queues)\r\n{\r\nint i;\r\nspin_lock_init(&queue->lock);\r\nfor (i = 0; i < ARRAY_SIZE(queue->tasks); i++)\r\nINIT_LIST_HEAD(&queue->tasks[i]);\r\nqueue->maxpriority = nr_queues - 1;\r\nrpc_reset_waitqueue_priority(queue);\r\nqueue->qlen = 0;\r\nsetup_timer(&queue->timer_list.timer, __rpc_queue_timer_fn, (unsigned long)queue);\r\nINIT_LIST_HEAD(&queue->timer_list.list);\r\nrpc_assign_waitqueue_name(queue, qname);\r\n}\r\nvoid rpc_init_priority_wait_queue(struct rpc_wait_queue *queue, const char *qname)\r\n{\r\n__rpc_init_priority_wait_queue(queue, qname, RPC_NR_PRIORITY);\r\n}\r\nvoid rpc_init_wait_queue(struct rpc_wait_queue *queue, const char *qname)\r\n{\r\n__rpc_init_priority_wait_queue(queue, qname, 1);\r\n}\r\nvoid rpc_destroy_wait_queue(struct rpc_wait_queue *queue)\r\n{\r\ndel_timer_sync(&queue->timer_list.timer);\r\n}\r\nstatic int rpc_wait_bit_killable(struct wait_bit_key *key, int mode)\r\n{\r\nfreezable_schedule_unsafe();\r\nif (signal_pending_state(mode, current))\r\nreturn -ERESTARTSYS;\r\nreturn 0;\r\n}\r\nstatic void rpc_task_set_debuginfo(struct rpc_task *task)\r\n{\r\nstatic atomic_t rpc_pid;\r\ntask->tk_pid = atomic_inc_return(&rpc_pid);\r\n}\r\nstatic inline void rpc_task_set_debuginfo(struct rpc_task *task)\r\n{\r\n}\r\nstatic void rpc_set_active(struct rpc_task *task)\r\n{\r\ntrace_rpc_task_begin(task->tk_client, task, NULL);\r\nrpc_task_set_debuginfo(task);\r\nset_bit(RPC_TASK_ACTIVE, &task->tk_runstate);\r\n}\r\nstatic int rpc_complete_task(struct rpc_task *task)\r\n{\r\nvoid *m = &task->tk_runstate;\r\nwait_queue_head_t *wq = bit_waitqueue(m, RPC_TASK_ACTIVE);\r\nstruct wait_bit_key k = __WAIT_BIT_KEY_INITIALIZER(m, RPC_TASK_ACTIVE);\r\nunsigned long flags;\r\nint ret;\r\ntrace_rpc_task_complete(task->tk_client, task, NULL);\r\nspin_lock_irqsave(&wq->lock, flags);\r\nclear_bit(RPC_TASK_ACTIVE, &task->tk_runstate);\r\nret = atomic_dec_and_test(&task->tk_count);\r\nif (waitqueue_active(wq))\r\n__wake_up_locked_key(wq, TASK_NORMAL, &k);\r\nspin_unlock_irqrestore(&wq->lock, flags);\r\nreturn ret;\r\n}\r\nint __rpc_wait_for_completion_task(struct rpc_task *task, wait_bit_action_f *action)\r\n{\r\nif (action == NULL)\r\naction = rpc_wait_bit_killable;\r\nreturn out_of_line_wait_on_bit(&task->tk_runstate, RPC_TASK_ACTIVE,\r\naction, TASK_KILLABLE);\r\n}\r\nstatic void rpc_make_runnable(struct rpc_task *task)\r\n{\r\nbool need_wakeup = !rpc_test_and_set_running(task);\r\nrpc_clear_queued(task);\r\nif (!need_wakeup)\r\nreturn;\r\nif (RPC_IS_ASYNC(task)) {\r\nINIT_WORK(&task->u.tk_work, rpc_async_schedule);\r\nqueue_work(rpciod_workqueue, &task->u.tk_work);\r\n} else\r\nwake_up_bit(&task->tk_runstate, RPC_TASK_QUEUED);\r\n}\r\nstatic void __rpc_sleep_on_priority(struct rpc_wait_queue *q,\r\nstruct rpc_task *task,\r\nrpc_action action,\r\nunsigned char queue_priority)\r\n{\r\ndprintk("RPC: %5u sleep_on(queue \"%s\" time %lu)\n",\r\ntask->tk_pid, rpc_qname(q), jiffies);\r\ntrace_rpc_task_sleep(task->tk_client, task, q);\r\n__rpc_add_wait_queue(q, task, queue_priority);\r\nWARN_ON_ONCE(task->tk_callback != NULL);\r\ntask->tk_callback = action;\r\n__rpc_add_timer(q, task);\r\n}\r\nvoid rpc_sleep_on(struct rpc_wait_queue *q, struct rpc_task *task,\r\nrpc_action action)\r\n{\r\nWARN_ON_ONCE(!RPC_IS_ACTIVATED(task));\r\nif (!RPC_IS_ACTIVATED(task)) {\r\ntask->tk_status = -EIO;\r\nrpc_put_task_async(task);\r\nreturn;\r\n}\r\nspin_lock_bh(&q->lock);\r\n__rpc_sleep_on_priority(q, task, action, task->tk_priority);\r\nspin_unlock_bh(&q->lock);\r\n}\r\nvoid rpc_sleep_on_priority(struct rpc_wait_queue *q, struct rpc_task *task,\r\nrpc_action action, int priority)\r\n{\r\nWARN_ON_ONCE(!RPC_IS_ACTIVATED(task));\r\nif (!RPC_IS_ACTIVATED(task)) {\r\ntask->tk_status = -EIO;\r\nrpc_put_task_async(task);\r\nreturn;\r\n}\r\nspin_lock_bh(&q->lock);\r\n__rpc_sleep_on_priority(q, task, action, priority - RPC_PRIORITY_LOW);\r\nspin_unlock_bh(&q->lock);\r\n}\r\nstatic void __rpc_do_wake_up_task(struct rpc_wait_queue *queue, struct rpc_task *task)\r\n{\r\ndprintk("RPC: %5u __rpc_wake_up_task (now %lu)\n",\r\ntask->tk_pid, jiffies);\r\nif (!RPC_IS_ACTIVATED(task)) {\r\nprintk(KERN_ERR "RPC: Inactive task (%p) being woken up!\n", task);\r\nreturn;\r\n}\r\ntrace_rpc_task_wakeup(task->tk_client, task, queue);\r\n__rpc_remove_wait_queue(queue, task);\r\nrpc_make_runnable(task);\r\ndprintk("RPC: __rpc_wake_up_task done\n");\r\n}\r\nstatic void rpc_wake_up_task_queue_locked(struct rpc_wait_queue *queue, struct rpc_task *task)\r\n{\r\nif (RPC_IS_QUEUED(task)) {\r\nsmp_rmb();\r\nif (task->tk_waitqueue == queue)\r\n__rpc_do_wake_up_task(queue, task);\r\n}\r\n}\r\nvoid rpc_wake_up_queued_task(struct rpc_wait_queue *queue, struct rpc_task *task)\r\n{\r\nspin_lock_bh(&queue->lock);\r\nrpc_wake_up_task_queue_locked(queue, task);\r\nspin_unlock_bh(&queue->lock);\r\n}\r\nstatic struct rpc_task *__rpc_find_next_queued_priority(struct rpc_wait_queue *queue)\r\n{\r\nstruct list_head *q;\r\nstruct rpc_task *task;\r\nq = &queue->tasks[queue->priority];\r\nif (!list_empty(q)) {\r\ntask = list_entry(q->next, struct rpc_task, u.tk_wait.list);\r\nif (queue->owner == task->tk_owner) {\r\nif (--queue->nr)\r\ngoto out;\r\nlist_move_tail(&task->u.tk_wait.list, q);\r\n}\r\ngoto new_owner;\r\n}\r\ndo {\r\nif (q == &queue->tasks[0])\r\nq = &queue->tasks[queue->maxpriority];\r\nelse\r\nq = q - 1;\r\nif (!list_empty(q)) {\r\ntask = list_entry(q->next, struct rpc_task, u.tk_wait.list);\r\ngoto new_queue;\r\n}\r\n} while (q != &queue->tasks[queue->priority]);\r\nrpc_reset_waitqueue_priority(queue);\r\nreturn NULL;\r\nnew_queue:\r\nrpc_set_waitqueue_priority(queue, (unsigned int)(q - &queue->tasks[0]));\r\nnew_owner:\r\nrpc_set_waitqueue_owner(queue, task->tk_owner);\r\nout:\r\nreturn task;\r\n}\r\nstatic struct rpc_task *__rpc_find_next_queued(struct rpc_wait_queue *queue)\r\n{\r\nif (RPC_IS_PRIORITY(queue))\r\nreturn __rpc_find_next_queued_priority(queue);\r\nif (!list_empty(&queue->tasks[0]))\r\nreturn list_first_entry(&queue->tasks[0], struct rpc_task, u.tk_wait.list);\r\nreturn NULL;\r\n}\r\nstruct rpc_task *rpc_wake_up_first(struct rpc_wait_queue *queue,\r\nbool (*func)(struct rpc_task *, void *), void *data)\r\n{\r\nstruct rpc_task *task = NULL;\r\ndprintk("RPC: wake_up_first(%p \"%s\")\n",\r\nqueue, rpc_qname(queue));\r\nspin_lock_bh(&queue->lock);\r\ntask = __rpc_find_next_queued(queue);\r\nif (task != NULL) {\r\nif (func(task, data))\r\nrpc_wake_up_task_queue_locked(queue, task);\r\nelse\r\ntask = NULL;\r\n}\r\nspin_unlock_bh(&queue->lock);\r\nreturn task;\r\n}\r\nstatic bool rpc_wake_up_next_func(struct rpc_task *task, void *data)\r\n{\r\nreturn true;\r\n}\r\nstruct rpc_task *rpc_wake_up_next(struct rpc_wait_queue *queue)\r\n{\r\nreturn rpc_wake_up_first(queue, rpc_wake_up_next_func, NULL);\r\n}\r\nvoid rpc_wake_up(struct rpc_wait_queue *queue)\r\n{\r\nstruct list_head *head;\r\nspin_lock_bh(&queue->lock);\r\nhead = &queue->tasks[queue->maxpriority];\r\nfor (;;) {\r\nwhile (!list_empty(head)) {\r\nstruct rpc_task *task;\r\ntask = list_first_entry(head,\r\nstruct rpc_task,\r\nu.tk_wait.list);\r\nrpc_wake_up_task_queue_locked(queue, task);\r\n}\r\nif (head == &queue->tasks[0])\r\nbreak;\r\nhead--;\r\n}\r\nspin_unlock_bh(&queue->lock);\r\n}\r\nvoid rpc_wake_up_status(struct rpc_wait_queue *queue, int status)\r\n{\r\nstruct list_head *head;\r\nspin_lock_bh(&queue->lock);\r\nhead = &queue->tasks[queue->maxpriority];\r\nfor (;;) {\r\nwhile (!list_empty(head)) {\r\nstruct rpc_task *task;\r\ntask = list_first_entry(head,\r\nstruct rpc_task,\r\nu.tk_wait.list);\r\ntask->tk_status = status;\r\nrpc_wake_up_task_queue_locked(queue, task);\r\n}\r\nif (head == &queue->tasks[0])\r\nbreak;\r\nhead--;\r\n}\r\nspin_unlock_bh(&queue->lock);\r\n}\r\nstatic void __rpc_queue_timer_fn(unsigned long ptr)\r\n{\r\nstruct rpc_wait_queue *queue = (struct rpc_wait_queue *)ptr;\r\nstruct rpc_task *task, *n;\r\nunsigned long expires, now, timeo;\r\nspin_lock(&queue->lock);\r\nexpires = now = jiffies;\r\nlist_for_each_entry_safe(task, n, &queue->timer_list.list, u.tk_wait.timer_list) {\r\ntimeo = task->u.tk_wait.expires;\r\nif (time_after_eq(now, timeo)) {\r\ndprintk("RPC: %5u timeout\n", task->tk_pid);\r\ntask->tk_status = -ETIMEDOUT;\r\nrpc_wake_up_task_queue_locked(queue, task);\r\ncontinue;\r\n}\r\nif (expires == now || time_after(expires, timeo))\r\nexpires = timeo;\r\n}\r\nif (!list_empty(&queue->timer_list.list))\r\nrpc_set_queue_timer(queue, expires);\r\nspin_unlock(&queue->lock);\r\n}\r\nstatic void __rpc_atrun(struct rpc_task *task)\r\n{\r\nif (task->tk_status == -ETIMEDOUT)\r\ntask->tk_status = 0;\r\n}\r\nvoid rpc_delay(struct rpc_task *task, unsigned long delay)\r\n{\r\ntask->tk_timeout = delay;\r\nrpc_sleep_on(&delay_queue, task, __rpc_atrun);\r\n}\r\nvoid rpc_prepare_task(struct rpc_task *task)\r\n{\r\ntask->tk_ops->rpc_call_prepare(task, task->tk_calldata);\r\n}\r\nstatic void\r\nrpc_init_task_statistics(struct rpc_task *task)\r\n{\r\ntask->tk_garb_retry = 2;\r\ntask->tk_cred_retry = 2;\r\ntask->tk_rebind_retry = 2;\r\ntask->tk_start = ktime_get();\r\n}\r\nstatic void\r\nrpc_reset_task_statistics(struct rpc_task *task)\r\n{\r\ntask->tk_timeouts = 0;\r\ntask->tk_flags &= ~(RPC_CALL_MAJORSEEN|RPC_TASK_KILLED|RPC_TASK_SENT);\r\nrpc_init_task_statistics(task);\r\n}\r\nvoid rpc_exit_task(struct rpc_task *task)\r\n{\r\ntask->tk_action = NULL;\r\nif (task->tk_ops->rpc_call_done != NULL) {\r\ntask->tk_ops->rpc_call_done(task, task->tk_calldata);\r\nif (task->tk_action != NULL) {\r\nWARN_ON(RPC_ASSASSINATED(task));\r\nxprt_release(task);\r\nrpc_reset_task_statistics(task);\r\n}\r\n}\r\n}\r\nvoid rpc_exit(struct rpc_task *task, int status)\r\n{\r\ntask->tk_status = status;\r\ntask->tk_action = rpc_exit_task;\r\nif (RPC_IS_QUEUED(task))\r\nrpc_wake_up_queued_task(task->tk_waitqueue, task);\r\n}\r\nvoid rpc_release_calldata(const struct rpc_call_ops *ops, void *calldata)\r\n{\r\nif (ops->rpc_release != NULL)\r\nops->rpc_release(calldata);\r\n}\r\nstatic void __rpc_execute(struct rpc_task *task)\r\n{\r\nstruct rpc_wait_queue *queue;\r\nint task_is_async = RPC_IS_ASYNC(task);\r\nint status = 0;\r\ndprintk("RPC: %5u __rpc_execute flags=0x%x\n",\r\ntask->tk_pid, task->tk_flags);\r\nWARN_ON_ONCE(RPC_IS_QUEUED(task));\r\nif (RPC_IS_QUEUED(task))\r\nreturn;\r\nfor (;;) {\r\nvoid (*do_action)(struct rpc_task *);\r\ndo_action = task->tk_callback;\r\ntask->tk_callback = NULL;\r\nif (do_action == NULL) {\r\ndo_action = task->tk_action;\r\nif (do_action == NULL)\r\nbreak;\r\n}\r\ntrace_rpc_task_run_action(task->tk_client, task, task->tk_action);\r\ndo_action(task);\r\nif (!RPC_IS_QUEUED(task))\r\ncontinue;\r\nqueue = task->tk_waitqueue;\r\nspin_lock_bh(&queue->lock);\r\nif (!RPC_IS_QUEUED(task)) {\r\nspin_unlock_bh(&queue->lock);\r\ncontinue;\r\n}\r\nrpc_clear_running(task);\r\nspin_unlock_bh(&queue->lock);\r\nif (task_is_async)\r\nreturn;\r\ndprintk("RPC: %5u sync task going to sleep\n", task->tk_pid);\r\nstatus = out_of_line_wait_on_bit(&task->tk_runstate,\r\nRPC_TASK_QUEUED, rpc_wait_bit_killable,\r\nTASK_KILLABLE);\r\nif (status == -ERESTARTSYS) {\r\ndprintk("RPC: %5u got signal\n", task->tk_pid);\r\ntask->tk_flags |= RPC_TASK_KILLED;\r\nrpc_exit(task, -ERESTARTSYS);\r\n}\r\ndprintk("RPC: %5u sync task resuming\n", task->tk_pid);\r\n}\r\ndprintk("RPC: %5u return %d, status %d\n", task->tk_pid, status,\r\ntask->tk_status);\r\nrpc_release_task(task);\r\n}\r\nvoid rpc_execute(struct rpc_task *task)\r\n{\r\nbool is_async = RPC_IS_ASYNC(task);\r\nrpc_set_active(task);\r\nrpc_make_runnable(task);\r\nif (!is_async)\r\n__rpc_execute(task);\r\n}\r\nstatic void rpc_async_schedule(struct work_struct *work)\r\n{\r\n__rpc_execute(container_of(work, struct rpc_task, u.tk_work));\r\n}\r\nvoid *rpc_malloc(struct rpc_task *task, size_t size)\r\n{\r\nstruct rpc_buffer *buf;\r\ngfp_t gfp = GFP_NOIO | __GFP_NOWARN;\r\nif (RPC_IS_SWAPPER(task))\r\ngfp = __GFP_MEMALLOC | GFP_NOWAIT | __GFP_NOWARN;\r\nsize += sizeof(struct rpc_buffer);\r\nif (size <= RPC_BUFFER_MAXSIZE)\r\nbuf = mempool_alloc(rpc_buffer_mempool, gfp);\r\nelse\r\nbuf = kmalloc(size, gfp);\r\nif (!buf)\r\nreturn NULL;\r\nbuf->len = size;\r\ndprintk("RPC: %5u allocated buffer of size %zu at %p\n",\r\ntask->tk_pid, size, buf);\r\nreturn &buf->data;\r\n}\r\nvoid rpc_free(void *buffer)\r\n{\r\nsize_t size;\r\nstruct rpc_buffer *buf;\r\nif (!buffer)\r\nreturn;\r\nbuf = container_of(buffer, struct rpc_buffer, data);\r\nsize = buf->len;\r\ndprintk("RPC: freeing buffer of size %zu at %p\n",\r\nsize, buf);\r\nif (size <= RPC_BUFFER_MAXSIZE)\r\nmempool_free(buf, rpc_buffer_mempool);\r\nelse\r\nkfree(buf);\r\n}\r\nstatic void rpc_init_task(struct rpc_task *task, const struct rpc_task_setup *task_setup_data)\r\n{\r\nmemset(task, 0, sizeof(*task));\r\natomic_set(&task->tk_count, 1);\r\ntask->tk_flags = task_setup_data->flags;\r\ntask->tk_ops = task_setup_data->callback_ops;\r\ntask->tk_calldata = task_setup_data->callback_data;\r\nINIT_LIST_HEAD(&task->tk_task);\r\ntask->tk_priority = task_setup_data->priority - RPC_PRIORITY_LOW;\r\ntask->tk_owner = current->tgid;\r\ntask->tk_workqueue = task_setup_data->workqueue;\r\nif (task->tk_ops->rpc_call_prepare != NULL)\r\ntask->tk_action = rpc_prepare_task;\r\nrpc_init_task_statistics(task);\r\ndprintk("RPC: new task initialized, procpid %u\n",\r\ntask_pid_nr(current));\r\n}\r\nstatic struct rpc_task *\r\nrpc_alloc_task(void)\r\n{\r\nreturn (struct rpc_task *)mempool_alloc(rpc_task_mempool, GFP_NOIO);\r\n}\r\nstruct rpc_task *rpc_new_task(const struct rpc_task_setup *setup_data)\r\n{\r\nstruct rpc_task *task = setup_data->task;\r\nunsigned short flags = 0;\r\nif (task == NULL) {\r\ntask = rpc_alloc_task();\r\nif (task == NULL) {\r\nrpc_release_calldata(setup_data->callback_ops,\r\nsetup_data->callback_data);\r\nreturn ERR_PTR(-ENOMEM);\r\n}\r\nflags = RPC_TASK_DYNAMIC;\r\n}\r\nrpc_init_task(task, setup_data);\r\ntask->tk_flags |= flags;\r\ndprintk("RPC: allocated task %p\n", task);\r\nreturn task;\r\n}\r\nstatic void rpc_free_task(struct rpc_task *task)\r\n{\r\nunsigned short tk_flags = task->tk_flags;\r\nrpc_release_calldata(task->tk_ops, task->tk_calldata);\r\nif (tk_flags & RPC_TASK_DYNAMIC) {\r\ndprintk("RPC: %5u freeing task\n", task->tk_pid);\r\nmempool_free(task, rpc_task_mempool);\r\n}\r\n}\r\nstatic void rpc_async_release(struct work_struct *work)\r\n{\r\nrpc_free_task(container_of(work, struct rpc_task, u.tk_work));\r\n}\r\nstatic void rpc_release_resources_task(struct rpc_task *task)\r\n{\r\nxprt_release(task);\r\nif (task->tk_msg.rpc_cred) {\r\nput_rpccred(task->tk_msg.rpc_cred);\r\ntask->tk_msg.rpc_cred = NULL;\r\n}\r\nrpc_task_release_client(task);\r\n}\r\nstatic void rpc_final_put_task(struct rpc_task *task,\r\nstruct workqueue_struct *q)\r\n{\r\nif (q != NULL) {\r\nINIT_WORK(&task->u.tk_work, rpc_async_release);\r\nqueue_work(q, &task->u.tk_work);\r\n} else\r\nrpc_free_task(task);\r\n}\r\nstatic void rpc_do_put_task(struct rpc_task *task, struct workqueue_struct *q)\r\n{\r\nif (atomic_dec_and_test(&task->tk_count)) {\r\nrpc_release_resources_task(task);\r\nrpc_final_put_task(task, q);\r\n}\r\n}\r\nvoid rpc_put_task(struct rpc_task *task)\r\n{\r\nrpc_do_put_task(task, NULL);\r\n}\r\nvoid rpc_put_task_async(struct rpc_task *task)\r\n{\r\nrpc_do_put_task(task, task->tk_workqueue);\r\n}\r\nstatic void rpc_release_task(struct rpc_task *task)\r\n{\r\ndprintk("RPC: %5u release task\n", task->tk_pid);\r\nWARN_ON_ONCE(RPC_IS_QUEUED(task));\r\nrpc_release_resources_task(task);\r\nif (atomic_read(&task->tk_count) != 1 + !RPC_IS_ASYNC(task)) {\r\nif (!rpc_complete_task(task))\r\nreturn;\r\n} else {\r\nif (!atomic_dec_and_test(&task->tk_count))\r\nreturn;\r\n}\r\nrpc_final_put_task(task, task->tk_workqueue);\r\n}\r\nint rpciod_up(void)\r\n{\r\nreturn try_module_get(THIS_MODULE) ? 0 : -EINVAL;\r\n}\r\nvoid rpciod_down(void)\r\n{\r\nmodule_put(THIS_MODULE);\r\n}\r\nstatic int rpciod_start(void)\r\n{\r\nstruct workqueue_struct *wq;\r\ndprintk("RPC: creating workqueue rpciod\n");\r\nwq = alloc_workqueue("rpciod", WQ_MEM_RECLAIM | WQ_HIGHPRI, 0);\r\nrpciod_workqueue = wq;\r\nreturn rpciod_workqueue != NULL;\r\n}\r\nstatic void rpciod_stop(void)\r\n{\r\nstruct workqueue_struct *wq = NULL;\r\nif (rpciod_workqueue == NULL)\r\nreturn;\r\ndprintk("RPC: destroying workqueue rpciod\n");\r\nwq = rpciod_workqueue;\r\nrpciod_workqueue = NULL;\r\ndestroy_workqueue(wq);\r\n}\r\nvoid\r\nrpc_destroy_mempool(void)\r\n{\r\nrpciod_stop();\r\nmempool_destroy(rpc_buffer_mempool);\r\nmempool_destroy(rpc_task_mempool);\r\nkmem_cache_destroy(rpc_task_slabp);\r\nkmem_cache_destroy(rpc_buffer_slabp);\r\nrpc_destroy_wait_queue(&delay_queue);\r\n}\r\nint\r\nrpc_init_mempool(void)\r\n{\r\nrpc_init_wait_queue(&delay_queue, "delayq");\r\nif (!rpciod_start())\r\ngoto err_nomem;\r\nrpc_task_slabp = kmem_cache_create("rpc_tasks",\r\nsizeof(struct rpc_task),\r\n0, SLAB_HWCACHE_ALIGN,\r\nNULL);\r\nif (!rpc_task_slabp)\r\ngoto err_nomem;\r\nrpc_buffer_slabp = kmem_cache_create("rpc_buffers",\r\nRPC_BUFFER_MAXSIZE,\r\n0, SLAB_HWCACHE_ALIGN,\r\nNULL);\r\nif (!rpc_buffer_slabp)\r\ngoto err_nomem;\r\nrpc_task_mempool = mempool_create_slab_pool(RPC_TASK_POOLSIZE,\r\nrpc_task_slabp);\r\nif (!rpc_task_mempool)\r\ngoto err_nomem;\r\nrpc_buffer_mempool = mempool_create_slab_pool(RPC_BUFFER_POOLSIZE,\r\nrpc_buffer_slabp);\r\nif (!rpc_buffer_mempool)\r\ngoto err_nomem;\r\nreturn 0;\r\nerr_nomem:\r\nrpc_destroy_mempool();\r\nreturn -ENOMEM;\r\n}
