int rl6231_get_pre_div(struct regmap *map, unsigned int reg, int sft)\r\n{\r\nint pd, val;\r\nregmap_read(map, reg, &val);\r\nval = (val >> sft) & 0x7;\r\nswitch (val) {\r\ncase 0:\r\ncase 1:\r\ncase 2:\r\ncase 3:\r\npd = val + 1;\r\nbreak;\r\ncase 4:\r\npd = 6;\r\nbreak;\r\ncase 5:\r\npd = 8;\r\nbreak;\r\ncase 6:\r\npd = 12;\r\nbreak;\r\ncase 7:\r\npd = 16;\r\nbreak;\r\ndefault:\r\npd = -EINVAL;\r\nbreak;\r\n}\r\nreturn pd;\r\n}\r\nint rl6231_calc_dmic_clk(int rate)\r\n{\r\nint div[] = {2, 3, 4, 6, 8, 12};\r\nint i;\r\nif (rate < 1000000 * div[0]) {\r\npr_warn("Base clock rate %d is too low\n", rate);\r\nreturn -EINVAL;\r\n}\r\nfor (i = 0; i < ARRAY_SIZE(div); i++) {\r\nif ((div[i] % 3) == 0)\r\ncontinue;\r\nif (3072000 * div[i] >= rate)\r\nreturn i;\r\n}\r\npr_warn("Base clock rate %d is too high\n", rate);\r\nreturn -EINVAL;\r\n}\r\nint rl6231_pll_calc(const unsigned int freq_in,\r\nconst unsigned int freq_out, struct rl6231_pll_code *pll_code)\r\n{\r\nint max_n = RL6231_PLL_N_MAX, max_m = RL6231_PLL_M_MAX;\r\nint i, k, red, n_t, pll_out, in_t, out_t;\r\nint n = 0, m = 0, m_t = 0;\r\nint red_t = abs(freq_out - freq_in);\r\nbool bypass = false;\r\nif (RL6231_PLL_INP_MAX < freq_in || RL6231_PLL_INP_MIN > freq_in)\r\nreturn -EINVAL;\r\nfor (i = 0; i < ARRAY_SIZE(pll_preset_table); i++) {\r\nif (freq_in == pll_preset_table[i].pll_in &&\r\nfreq_out == pll_preset_table[i].pll_out) {\r\nk = pll_preset_table[i].k;\r\nm = pll_preset_table[i].m;\r\nn = pll_preset_table[i].n;\r\nbypass = pll_preset_table[i].m_bp;\r\npr_debug("Use preset PLL parameter table\n");\r\ngoto code_find;\r\n}\r\n}\r\nk = 100000000 / freq_out - 2;\r\nif (k > RL6231_PLL_K_MAX)\r\nk = RL6231_PLL_K_MAX;\r\nfor (n_t = 0; n_t <= max_n; n_t++) {\r\nin_t = freq_in / (k + 2);\r\npll_out = freq_out / (n_t + 2);\r\nif (in_t < 0)\r\ncontinue;\r\nif (in_t == pll_out) {\r\nbypass = true;\r\nn = n_t;\r\ngoto code_find;\r\n}\r\nred = abs(in_t - pll_out);\r\nif (red < red_t) {\r\nbypass = true;\r\nn = n_t;\r\nm = m_t;\r\nif (red == 0)\r\ngoto code_find;\r\nred_t = red;\r\n}\r\nfor (m_t = 0; m_t <= max_m; m_t++) {\r\nout_t = in_t / (m_t + 2);\r\nred = abs(out_t - pll_out);\r\nif (red < red_t) {\r\nbypass = false;\r\nn = n_t;\r\nm = m_t;\r\nif (red == 0)\r\ngoto code_find;\r\nred_t = red;\r\n}\r\n}\r\n}\r\npr_debug("Only get approximation about PLL\n");\r\ncode_find:\r\npll_code->m_bp = bypass;\r\npll_code->m_code = m;\r\npll_code->n_code = n;\r\npll_code->k_code = k;\r\nreturn 0;\r\n}\r\nint rl6231_get_clk_info(int sclk, int rate)\r\n{\r\nint i, pd[] = {1, 2, 3, 4, 6, 8, 12, 16};\r\nif (sclk <= 0 || rate <= 0)\r\nreturn -EINVAL;\r\nrate = rate << 8;\r\nfor (i = 0; i < ARRAY_SIZE(pd); i++)\r\nif (sclk == rate * pd[i])\r\nreturn i;\r\nreturn -EINVAL;\r\n}
