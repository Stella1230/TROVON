int iioutils_break_up_name(const char *full_name, char **generic_name)\r\n{\r\nchar *current;\r\nchar *w, *r;\r\nchar *working, *prefix = "";\r\nint i, ret;\r\nfor (i = 0; i < ARRAY_SIZE(iio_direction); i++)\r\nif (!strncmp(full_name, iio_direction[i],\r\nstrlen(iio_direction[i]))) {\r\nprefix = iio_direction[i];\r\nbreak;\r\n}\r\ncurrent = strdup(full_name + strlen(prefix) + 1);\r\nif (!current)\r\nreturn -ENOMEM;\r\nworking = strtok(current, "_\0");\r\nif (!working) {\r\nfree(current);\r\nreturn -EINVAL;\r\n}\r\nw = working;\r\nr = working;\r\nwhile (*r != '\0') {\r\nif (!isdigit(*r)) {\r\n*w = *r;\r\nw++;\r\n}\r\nr++;\r\n}\r\n*w = '\0';\r\nret = asprintf(generic_name, "%s_%s", prefix, working);\r\nfree(current);\r\nreturn (ret == -1) ? -ENOMEM : 0;\r\n}\r\nint iioutils_get_type(unsigned *is_signed, unsigned *bytes, unsigned *bits_used,\r\nunsigned *shift, uint64_t *mask, unsigned *be,\r\nconst char *device_dir, const char *name,\r\nconst char *generic_name)\r\n{\r\nFILE *sysfsfp;\r\nint ret;\r\nDIR *dp;\r\nchar *scan_el_dir, *builtname, *builtname_generic, *filename = 0;\r\nchar signchar, endianchar;\r\nunsigned padint;\r\nconst struct dirent *ent;\r\nret = asprintf(&scan_el_dir, FORMAT_SCAN_ELEMENTS_DIR, device_dir);\r\nif (ret < 0)\r\nreturn -ENOMEM;\r\nret = asprintf(&builtname, FORMAT_TYPE_FILE, name);\r\nif (ret < 0) {\r\nret = -ENOMEM;\r\ngoto error_free_scan_el_dir;\r\n}\r\nret = asprintf(&builtname_generic, FORMAT_TYPE_FILE, generic_name);\r\nif (ret < 0) {\r\nret = -ENOMEM;\r\ngoto error_free_builtname;\r\n}\r\ndp = opendir(scan_el_dir);\r\nif (!dp) {\r\nret = -errno;\r\ngoto error_free_builtname_generic;\r\n}\r\nret = -ENOENT;\r\nwhile (ent = readdir(dp), ent)\r\nif ((strcmp(builtname, ent->d_name) == 0) ||\r\n(strcmp(builtname_generic, ent->d_name) == 0)) {\r\nret = asprintf(&filename,\r\n"%s/%s", scan_el_dir, ent->d_name);\r\nif (ret < 0) {\r\nret = -ENOMEM;\r\ngoto error_closedir;\r\n}\r\nsysfsfp = fopen(filename, "r");\r\nif (!sysfsfp) {\r\nret = -errno;\r\nfprintf(stderr, "failed to open %s\n",\r\nfilename);\r\ngoto error_free_filename;\r\n}\r\nret = fscanf(sysfsfp,\r\n"%ce:%c%u/%u>>%u",\r\n&endianchar,\r\n&signchar,\r\nbits_used,\r\n&padint, shift);\r\nif (ret < 0) {\r\nret = -errno;\r\nfprintf(stderr,\r\n"failed to pass scan type description\n");\r\ngoto error_close_sysfsfp;\r\n} else if (ret != 5) {\r\nret = -EIO;\r\nfprintf(stderr,\r\n"scan type description didn't match\n");\r\ngoto error_close_sysfsfp;\r\n}\r\n*be = (endianchar == 'b');\r\n*bytes = padint / 8;\r\nif (*bits_used == 64)\r\n*mask = ~0;\r\nelse\r\n*mask = (1ULL << *bits_used) - 1;\r\n*is_signed = (signchar == 's');\r\nif (fclose(sysfsfp)) {\r\nret = -errno;\r\nfprintf(stderr, "Failed to close %s\n",\r\nfilename);\r\ngoto error_free_filename;\r\n}\r\nsysfsfp = 0;\r\nfree(filename);\r\nfilename = 0;\r\n}\r\nerror_close_sysfsfp:\r\nif (sysfsfp)\r\nif (fclose(sysfsfp))\r\nperror("iioutils_get_type(): Failed to close file");\r\nerror_free_filename:\r\nif (filename)\r\nfree(filename);\r\nerror_closedir:\r\nif (closedir(dp) == -1)\r\nperror("iioutils_get_type(): Failed to close directory");\r\nerror_free_builtname_generic:\r\nfree(builtname_generic);\r\nerror_free_builtname:\r\nfree(builtname);\r\nerror_free_scan_el_dir:\r\nfree(scan_el_dir);\r\nreturn ret;\r\n}\r\nint iioutils_get_param_float(float *output, const char *param_name,\r\nconst char *device_dir, const char *name,\r\nconst char *generic_name)\r\n{\r\nFILE *sysfsfp;\r\nint ret;\r\nDIR *dp;\r\nchar *builtname, *builtname_generic;\r\nchar *filename = NULL;\r\nconst struct dirent *ent;\r\nret = asprintf(&builtname, "%s_%s", name, param_name);\r\nif (ret < 0)\r\nreturn -ENOMEM;\r\nret = asprintf(&builtname_generic,\r\n"%s_%s", generic_name, param_name);\r\nif (ret < 0) {\r\nret = -ENOMEM;\r\ngoto error_free_builtname;\r\n}\r\ndp = opendir(device_dir);\r\nif (!dp) {\r\nret = -errno;\r\ngoto error_free_builtname_generic;\r\n}\r\nret = -ENOENT;\r\nwhile (ent = readdir(dp), ent)\r\nif ((strcmp(builtname, ent->d_name) == 0) ||\r\n(strcmp(builtname_generic, ent->d_name) == 0)) {\r\nret = asprintf(&filename,\r\n"%s/%s", device_dir, ent->d_name);\r\nif (ret < 0) {\r\nret = -ENOMEM;\r\ngoto error_closedir;\r\n}\r\nsysfsfp = fopen(filename, "r");\r\nif (!sysfsfp) {\r\nret = -errno;\r\ngoto error_free_filename;\r\n}\r\nerrno = 0;\r\nif (fscanf(sysfsfp, "%f", output) != 1)\r\nret = errno ? -errno : -ENODATA;\r\nbreak;\r\n}\r\nerror_free_filename:\r\nif (filename)\r\nfree(filename);\r\nerror_closedir:\r\nif (closedir(dp) == -1)\r\nperror("iioutils_get_param_float(): Failed to close directory");\r\nerror_free_builtname_generic:\r\nfree(builtname_generic);\r\nerror_free_builtname:\r\nfree(builtname);\r\nreturn ret;\r\n}\r\nvoid bsort_channel_array_by_index(struct iio_channel_info *ci_array, int cnt)\r\n{\r\nstruct iio_channel_info temp;\r\nint x, y;\r\nfor (x = 0; x < cnt; x++)\r\nfor (y = 0; y < (cnt - 1); y++)\r\nif (ci_array[y].index > ci_array[y + 1].index) {\r\ntemp = ci_array[y + 1];\r\nci_array[y + 1] = ci_array[y];\r\nci_array[y] = temp;\r\n}\r\n}\r\nint build_channel_array(const char *device_dir,\r\nstruct iio_channel_info **ci_array, int *counter)\r\n{\r\nDIR *dp;\r\nFILE *sysfsfp;\r\nint count = 0, i;\r\nstruct iio_channel_info *current;\r\nint ret;\r\nconst struct dirent *ent;\r\nchar *scan_el_dir;\r\nchar *filename;\r\n*counter = 0;\r\nret = asprintf(&scan_el_dir, FORMAT_SCAN_ELEMENTS_DIR, device_dir);\r\nif (ret < 0)\r\nreturn -ENOMEM;\r\ndp = opendir(scan_el_dir);\r\nif (!dp) {\r\nret = -errno;\r\ngoto error_free_name;\r\n}\r\nwhile (ent = readdir(dp), ent)\r\nif (strcmp(ent->d_name + strlen(ent->d_name) - strlen("_en"),\r\n"_en") == 0) {\r\nret = asprintf(&filename,\r\n"%s/%s", scan_el_dir, ent->d_name);\r\nif (ret < 0) {\r\nret = -ENOMEM;\r\ngoto error_close_dir;\r\n}\r\nsysfsfp = fopen(filename, "r");\r\nif (!sysfsfp) {\r\nret = -errno;\r\nfree(filename);\r\ngoto error_close_dir;\r\n}\r\nerrno = 0;\r\nif (fscanf(sysfsfp, "%i", &ret) != 1) {\r\nret = errno ? -errno : -ENODATA;\r\nif (fclose(sysfsfp))\r\nperror("build_channel_array(): Failed to close file");\r\nfree(filename);\r\ngoto error_close_dir;\r\n}\r\nif (ret == 1)\r\n(*counter)++;\r\nif (fclose(sysfsfp)) {\r\nret = -errno;\r\nfree(filename);\r\ngoto error_close_dir;\r\n}\r\nfree(filename);\r\n}\r\n*ci_array = malloc(sizeof(**ci_array) * (*counter));\r\nif (!*ci_array) {\r\nret = -ENOMEM;\r\ngoto error_close_dir;\r\n}\r\nseekdir(dp, 0);\r\nwhile (ent = readdir(dp), ent) {\r\nif (strcmp(ent->d_name + strlen(ent->d_name) - strlen("_en"),\r\n"_en") == 0) {\r\nint current_enabled = 0;\r\ncurrent = &(*ci_array)[count++];\r\nret = asprintf(&filename,\r\n"%s/%s", scan_el_dir, ent->d_name);\r\nif (ret < 0) {\r\nret = -ENOMEM;\r\ncount--;\r\ngoto error_cleanup_array;\r\n}\r\nsysfsfp = fopen(filename, "r");\r\nif (!sysfsfp) {\r\nret = -errno;\r\nfree(filename);\r\ncount--;\r\ngoto error_cleanup_array;\r\n}\r\nerrno = 0;\r\nif (fscanf(sysfsfp, "%i", &current_enabled) != 1) {\r\nret = errno ? -errno : -ENODATA;\r\nfree(filename);\r\ncount--;\r\ngoto error_cleanup_array;\r\n}\r\nif (fclose(sysfsfp)) {\r\nret = -errno;\r\nfree(filename);\r\ncount--;\r\ngoto error_cleanup_array;\r\n}\r\nif (!current_enabled) {\r\nfree(filename);\r\ncount--;\r\ncontinue;\r\n}\r\ncurrent->scale = 1.0;\r\ncurrent->offset = 0;\r\ncurrent->name = strndup(ent->d_name,\r\nstrlen(ent->d_name) -\r\nstrlen("_en"));\r\nif (!current->name) {\r\nfree(filename);\r\nret = -ENOMEM;\r\ncount--;\r\ngoto error_cleanup_array;\r\n}\r\nret = iioutils_break_up_name(current->name,\r\n&current->generic_name);\r\nif (ret) {\r\nfree(filename);\r\nfree(current->name);\r\ncount--;\r\ngoto error_cleanup_array;\r\n}\r\nret = asprintf(&filename,\r\n"%s/%s_index",\r\nscan_el_dir,\r\ncurrent->name);\r\nif (ret < 0) {\r\nfree(filename);\r\nret = -ENOMEM;\r\ngoto error_cleanup_array;\r\n}\r\nsysfsfp = fopen(filename, "r");\r\nif (!sysfsfp) {\r\nret = -errno;\r\nfprintf(stderr, "failed to open %s\n",\r\nfilename);\r\nfree(filename);\r\ngoto error_cleanup_array;\r\n}\r\nerrno = 0;\r\nif (fscanf(sysfsfp, "%u", &current->index) != 1) {\r\nret = errno ? -errno : -ENODATA;\r\nif (fclose(sysfsfp))\r\nperror("build_channel_array(): Failed to close file");\r\nfree(filename);\r\ngoto error_cleanup_array;\r\n}\r\nif (fclose(sysfsfp)) {\r\nret = -errno;\r\nfree(filename);\r\ngoto error_cleanup_array;\r\n}\r\nfree(filename);\r\nret = iioutils_get_param_float(&current->scale,\r\n"scale",\r\ndevice_dir,\r\ncurrent->name,\r\ncurrent->generic_name);\r\nif ((ret < 0) && (ret != -ENOENT))\r\ngoto error_cleanup_array;\r\nret = iioutils_get_param_float(&current->offset,\r\n"offset",\r\ndevice_dir,\r\ncurrent->name,\r\ncurrent->generic_name);\r\nif ((ret < 0) && (ret != -ENOENT))\r\ngoto error_cleanup_array;\r\nret = iioutils_get_type(&current->is_signed,\r\n&current->bytes,\r\n&current->bits_used,\r\n&current->shift,\r\n&current->mask,\r\n&current->be,\r\ndevice_dir,\r\ncurrent->name,\r\ncurrent->generic_name);\r\nif (ret < 0)\r\ngoto error_cleanup_array;\r\n}\r\n}\r\nif (closedir(dp) == -1) {\r\nret = -errno;\r\ngoto error_cleanup_array;\r\n}\r\nfree(scan_el_dir);\r\nbsort_channel_array_by_index(*ci_array, *counter);\r\nreturn 0;\r\nerror_cleanup_array:\r\nfor (i = count - 1; i >= 0; i--) {\r\nfree((*ci_array)[i].name);\r\nfree((*ci_array)[i].generic_name);\r\n}\r\nfree(*ci_array);\r\n*ci_array = NULL;\r\n*counter = 0;\r\nerror_close_dir:\r\nif (dp)\r\nif (closedir(dp) == -1)\r\nperror("build_channel_array(): Failed to close dir");\r\nerror_free_name:\r\nfree(scan_el_dir);\r\nreturn ret;\r\n}\r\nstatic int calc_digits(int num)\r\n{\r\nint count = 0;\r\nwhile (num != 0) {\r\nnum /= 10;\r\ncount++;\r\n}\r\nreturn count;\r\n}\r\nint find_type_by_name(const char *name, const char *type)\r\n{\r\nconst struct dirent *ent;\r\nint number, numstrlen, ret;\r\nFILE *namefp;\r\nDIR *dp;\r\nchar thisname[IIO_MAX_NAME_LENGTH];\r\nchar *filename;\r\ndp = opendir(iio_dir);\r\nif (!dp) {\r\nfprintf(stderr, "No industrialio devices available\n");\r\nreturn -ENODEV;\r\n}\r\nwhile (ent = readdir(dp), ent) {\r\nif (strcmp(ent->d_name, ".") != 0 &&\r\nstrcmp(ent->d_name, "..") != 0 &&\r\nstrlen(ent->d_name) > strlen(type) &&\r\nstrncmp(ent->d_name, type, strlen(type)) == 0) {\r\nerrno = 0;\r\nret = sscanf(ent->d_name + strlen(type), "%d", &number);\r\nif (ret < 0) {\r\nret = -errno;\r\nfprintf(stderr,\r\n"failed to read element number\n");\r\ngoto error_close_dir;\r\n} else if (ret != 1) {\r\nret = -EIO;\r\nfprintf(stderr,\r\n"failed to match element number\n");\r\ngoto error_close_dir;\r\n}\r\nnumstrlen = calc_digits(number);\r\nif (strncmp(ent->d_name + strlen(type) + numstrlen,\r\n":", 1) != 0) {\r\nfilename = malloc(strlen(iio_dir) + strlen(type)\r\n+ numstrlen + 6);\r\nif (!filename) {\r\nret = -ENOMEM;\r\ngoto error_close_dir;\r\n}\r\nret = sprintf(filename, "%s%s%d/name", iio_dir,\r\ntype, number);\r\nif (ret < 0) {\r\nfree(filename);\r\ngoto error_close_dir;\r\n}\r\nnamefp = fopen(filename, "r");\r\nif (!namefp) {\r\nfree(filename);\r\ncontinue;\r\n}\r\nfree(filename);\r\nerrno = 0;\r\nif (fscanf(namefp, "%s", thisname) != 1) {\r\nret = errno ? -errno : -ENODATA;\r\ngoto error_close_dir;\r\n}\r\nif (fclose(namefp)) {\r\nret = -errno;\r\ngoto error_close_dir;\r\n}\r\nif (strcmp(name, thisname) == 0) {\r\nif (closedir(dp) == -1)\r\nreturn -errno;\r\nreturn number;\r\n}\r\n}\r\n}\r\n}\r\nif (closedir(dp) == -1)\r\nreturn -errno;\r\nreturn -ENODEV;\r\nerror_close_dir:\r\nif (closedir(dp) == -1)\r\nperror("find_type_by_name(): Failed to close directory");\r\nreturn ret;\r\n}\r\nstatic int _write_sysfs_int(const char *filename, const char *basedir, int val,\r\nint verify)\r\n{\r\nint ret = 0;\r\nFILE *sysfsfp;\r\nint test;\r\nchar *temp = malloc(strlen(basedir) + strlen(filename) + 2);\r\nif (!temp)\r\nreturn -ENOMEM;\r\nret = sprintf(temp, "%s/%s", basedir, filename);\r\nif (ret < 0)\r\ngoto error_free;\r\nsysfsfp = fopen(temp, "w");\r\nif (!sysfsfp) {\r\nret = -errno;\r\nfprintf(stderr, "failed to open %s\n", temp);\r\ngoto error_free;\r\n}\r\nret = fprintf(sysfsfp, "%d", val);\r\nif (ret < 0) {\r\nif (fclose(sysfsfp))\r\nperror("_write_sysfs_int(): Failed to close dir");\r\ngoto error_free;\r\n}\r\nif (fclose(sysfsfp)) {\r\nret = -errno;\r\ngoto error_free;\r\n}\r\nif (verify) {\r\nsysfsfp = fopen(temp, "r");\r\nif (!sysfsfp) {\r\nret = -errno;\r\nfprintf(stderr, "failed to open %s\n", temp);\r\ngoto error_free;\r\n}\r\nif (fscanf(sysfsfp, "%d", &test) != 1) {\r\nret = errno ? -errno : -ENODATA;\r\nif (fclose(sysfsfp))\r\nperror("_write_sysfs_int(): Failed to close dir");\r\ngoto error_free;\r\n}\r\nif (fclose(sysfsfp)) {\r\nret = -errno;\r\ngoto error_free;\r\n}\r\nif (test != val) {\r\nfprintf(stderr,\r\n"Possible failure in int write %d to %s/%s\n",\r\nval, basedir, filename);\r\nret = -1;\r\n}\r\n}\r\nerror_free:\r\nfree(temp);\r\nreturn ret;\r\n}\r\nint write_sysfs_int(const char *filename, const char *basedir, int val)\r\n{\r\nreturn _write_sysfs_int(filename, basedir, val, 0);\r\n}\r\nint write_sysfs_int_and_verify(const char *filename, const char *basedir,\r\nint val)\r\n{\r\nreturn _write_sysfs_int(filename, basedir, val, 1);\r\n}\r\nstatic int _write_sysfs_string(const char *filename, const char *basedir,\r\nconst char *val, int verify)\r\n{\r\nint ret = 0;\r\nFILE *sysfsfp;\r\nchar *temp = malloc(strlen(basedir) + strlen(filename) + 2);\r\nif (!temp) {\r\nfprintf(stderr, "Memory allocation failed\n");\r\nreturn -ENOMEM;\r\n}\r\nret = sprintf(temp, "%s/%s", basedir, filename);\r\nif (ret < 0)\r\ngoto error_free;\r\nsysfsfp = fopen(temp, "w");\r\nif (!sysfsfp) {\r\nret = -errno;\r\nfprintf(stderr, "Could not open %s\n", temp);\r\ngoto error_free;\r\n}\r\nret = fprintf(sysfsfp, "%s", val);\r\nif (ret < 0) {\r\nif (fclose(sysfsfp))\r\nperror("_write_sysfs_string(): Failed to close dir");\r\ngoto error_free;\r\n}\r\nif (fclose(sysfsfp)) {\r\nret = -errno;\r\ngoto error_free;\r\n}\r\nif (verify) {\r\nsysfsfp = fopen(temp, "r");\r\nif (!sysfsfp) {\r\nret = -errno;\r\nfprintf(stderr, "Could not open file to verify\n");\r\ngoto error_free;\r\n}\r\nif (fscanf(sysfsfp, "%s", temp) != 1) {\r\nret = errno ? -errno : -ENODATA;\r\nif (fclose(sysfsfp))\r\nperror("_write_sysfs_string(): Failed to close dir");\r\ngoto error_free;\r\n}\r\nif (fclose(sysfsfp)) {\r\nret = -errno;\r\ngoto error_free;\r\n}\r\nif (strcmp(temp, val) != 0) {\r\nfprintf(stderr,\r\n"Possible failure in string write of %s "\r\n"Should be %s written to %s/%s\n", temp, val,\r\nbasedir, filename);\r\nret = -1;\r\n}\r\n}\r\nerror_free:\r\nfree(temp);\r\nreturn ret;\r\n}\r\nint write_sysfs_string_and_verify(const char *filename, const char *basedir,\r\nconst char *val)\r\n{\r\nreturn _write_sysfs_string(filename, basedir, val, 1);\r\n}\r\nint write_sysfs_string(const char *filename, const char *basedir,\r\nconst char *val)\r\n{\r\nreturn _write_sysfs_string(filename, basedir, val, 0);\r\n}\r\nint read_sysfs_posint(const char *filename, const char *basedir)\r\n{\r\nint ret;\r\nFILE *sysfsfp;\r\nchar *temp = malloc(strlen(basedir) + strlen(filename) + 2);\r\nif (!temp) {\r\nfprintf(stderr, "Memory allocation failed");\r\nreturn -ENOMEM;\r\n}\r\nret = sprintf(temp, "%s/%s", basedir, filename);\r\nif (ret < 0)\r\ngoto error_free;\r\nsysfsfp = fopen(temp, "r");\r\nif (!sysfsfp) {\r\nret = -errno;\r\ngoto error_free;\r\n}\r\nerrno = 0;\r\nif (fscanf(sysfsfp, "%d\n", &ret) != 1) {\r\nret = errno ? -errno : -ENODATA;\r\nif (fclose(sysfsfp))\r\nperror("read_sysfs_posint(): Failed to close dir");\r\ngoto error_free;\r\n}\r\nif (fclose(sysfsfp))\r\nret = -errno;\r\nerror_free:\r\nfree(temp);\r\nreturn ret;\r\n}\r\nint read_sysfs_float(const char *filename, const char *basedir, float *val)\r\n{\r\nint ret = 0;\r\nFILE *sysfsfp;\r\nchar *temp = malloc(strlen(basedir) + strlen(filename) + 2);\r\nif (!temp) {\r\nfprintf(stderr, "Memory allocation failed");\r\nreturn -ENOMEM;\r\n}\r\nret = sprintf(temp, "%s/%s", basedir, filename);\r\nif (ret < 0)\r\ngoto error_free;\r\nsysfsfp = fopen(temp, "r");\r\nif (!sysfsfp) {\r\nret = -errno;\r\ngoto error_free;\r\n}\r\nerrno = 0;\r\nif (fscanf(sysfsfp, "%f\n", val) != 1) {\r\nret = errno ? -errno : -ENODATA;\r\nif (fclose(sysfsfp))\r\nperror("read_sysfs_float(): Failed to close dir");\r\ngoto error_free;\r\n}\r\nif (fclose(sysfsfp))\r\nret = -errno;\r\nerror_free:\r\nfree(temp);\r\nreturn ret;\r\n}\r\nint read_sysfs_string(const char *filename, const char *basedir, char *str)\r\n{\r\nint ret = 0;\r\nFILE *sysfsfp;\r\nchar *temp = malloc(strlen(basedir) + strlen(filename) + 2);\r\nif (!temp) {\r\nfprintf(stderr, "Memory allocation failed");\r\nreturn -ENOMEM;\r\n}\r\nret = sprintf(temp, "%s/%s", basedir, filename);\r\nif (ret < 0)\r\ngoto error_free;\r\nsysfsfp = fopen(temp, "r");\r\nif (!sysfsfp) {\r\nret = -errno;\r\ngoto error_free;\r\n}\r\nerrno = 0;\r\nif (fscanf(sysfsfp, "%s\n", str) != 1) {\r\nret = errno ? -errno : -ENODATA;\r\nif (fclose(sysfsfp))\r\nperror("read_sysfs_string(): Failed to close dir");\r\ngoto error_free;\r\n}\r\nif (fclose(sysfsfp))\r\nret = -errno;\r\nerror_free:\r\nfree(temp);\r\nreturn ret;\r\n}
