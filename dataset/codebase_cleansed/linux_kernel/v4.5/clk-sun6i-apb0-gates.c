static int sun6i_a31_apb0_gates_clk_probe(struct platform_device *pdev)\r\n{\r\nstruct device_node *np = pdev->dev.of_node;\r\nstruct clk_onecell_data *clk_data;\r\nconst struct of_device_id *device;\r\nconst struct gates_data *data;\r\nconst char *clk_parent;\r\nconst char *clk_name;\r\nstruct resource *r;\r\nvoid __iomem *reg;\r\nint ngates;\r\nint i;\r\nint j = 0;\r\nif (!np)\r\nreturn -ENODEV;\r\ndevice = of_match_device(sun6i_a31_apb0_gates_clk_dt_ids, &pdev->dev);\r\nif (!device)\r\nreturn -ENODEV;\r\ndata = device->data;\r\nr = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nreg = devm_ioremap_resource(&pdev->dev, r);\r\nif (IS_ERR(reg))\r\nreturn PTR_ERR(reg);\r\nclk_parent = of_clk_get_parent_name(np, 0);\r\nif (!clk_parent)\r\nreturn -EINVAL;\r\nclk_data = devm_kzalloc(&pdev->dev, sizeof(struct clk_onecell_data),\r\nGFP_KERNEL);\r\nif (!clk_data)\r\nreturn -ENOMEM;\r\nngates = find_last_bit(data->mask, SUN6I_APB0_GATES_MAX_SIZE);\r\nclk_data->clks = devm_kcalloc(&pdev->dev, (ngates + 1),\r\nsizeof(struct clk *), GFP_KERNEL);\r\nif (!clk_data->clks)\r\nreturn -ENOMEM;\r\nfor_each_set_bit(i, data->mask, SUN6I_APB0_GATES_MAX_SIZE) {\r\nof_property_read_string_index(np, "clock-output-names",\r\nj, &clk_name);\r\nclk_data->clks[i] = clk_register_gate(&pdev->dev, clk_name,\r\nclk_parent, 0, reg, i,\r\n0, NULL);\r\nWARN_ON(IS_ERR(clk_data->clks[i]));\r\nclk_register_clkdev(clk_data->clks[i], clk_name, NULL);\r\nj++;\r\n}\r\nclk_data->clk_num = ngates + 1;\r\nreturn of_clk_add_provider(np, of_clk_src_onecell_get, clk_data);\r\n}
