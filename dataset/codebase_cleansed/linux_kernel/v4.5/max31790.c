static struct max31790_data *max31790_update_device(struct device *dev)\r\n{\r\nstruct max31790_data *data = dev_get_drvdata(dev);\r\nstruct i2c_client *client = data->client;\r\nstruct max31790_data *ret = data;\r\nint i;\r\nint rv;\r\nmutex_lock(&data->update_lock);\r\nif (time_after(jiffies, data->last_updated + HZ) || !data->valid) {\r\nrv = i2c_smbus_read_byte_data(client,\r\nMAX31790_REG_FAN_FAULT_STATUS1);\r\nif (rv < 0)\r\ngoto abort;\r\ndata->fault_status = rv & 0x3F;\r\nrv = i2c_smbus_read_byte_data(client,\r\nMAX31790_REG_FAN_FAULT_STATUS2);\r\nif (rv < 0)\r\ngoto abort;\r\ndata->fault_status |= (rv & 0x3F) << 6;\r\nfor (i = 0; i < NR_CHANNEL; i++) {\r\nrv = i2c_smbus_read_word_swapped(client,\r\nMAX31790_REG_TACH_COUNT(i));\r\nif (rv < 0)\r\ngoto abort;\r\ndata->tach[i] = rv;\r\nif (data->fan_config[i]\r\n& MAX31790_FAN_CFG_TACH_INPUT) {\r\nrv = i2c_smbus_read_word_swapped(client,\r\nMAX31790_REG_TACH_COUNT(NR_CHANNEL\r\n+ i));\r\nif (rv < 0)\r\ngoto abort;\r\ndata->tach[NR_CHANNEL + i] = rv;\r\n} else {\r\nrv = i2c_smbus_read_word_swapped(client,\r\nMAX31790_REG_PWMOUT(i));\r\nif (rv < 0)\r\ngoto abort;\r\ndata->pwm[i] = rv;\r\nrv = i2c_smbus_read_word_swapped(client,\r\nMAX31790_REG_TARGET_COUNT(i));\r\nif (rv < 0)\r\ngoto abort;\r\ndata->target_count[i] = rv;\r\n}\r\n}\r\ndata->last_updated = jiffies;\r\ndata->valid = true;\r\n}\r\ngoto done;\r\nabort:\r\ndata->valid = false;\r\nret = ERR_PTR(rv);\r\ndone:\r\nmutex_unlock(&data->update_lock);\r\nreturn ret;\r\n}\r\nstatic u8 get_tach_period(u8 fan_dynamics)\r\n{\r\nreturn tach_period[SR_FROM_REG(fan_dynamics)];\r\n}\r\nstatic u8 bits_for_tach_period(int rpm)\r\n{\r\nu8 bits;\r\nif (rpm < 500)\r\nbits = 0x0;\r\nelse if (rpm < 1000)\r\nbits = 0x1;\r\nelse if (rpm < 2000)\r\nbits = 0x2;\r\nelse if (rpm < 4000)\r\nbits = 0x3;\r\nelse if (rpm < 8000)\r\nbits = 0x4;\r\nelse\r\nbits = 0x5;\r\nreturn bits;\r\n}\r\nstatic ssize_t get_fan(struct device *dev,\r\nstruct device_attribute *devattr, char *buf)\r\n{\r\nstruct sensor_device_attribute *attr = to_sensor_dev_attr(devattr);\r\nstruct max31790_data *data = max31790_update_device(dev);\r\nint sr, rpm;\r\nif (IS_ERR(data))\r\nreturn PTR_ERR(data);\r\nsr = get_tach_period(data->fan_dynamics[attr->index]);\r\nrpm = RPM_FROM_REG(data->tach[attr->index], sr);\r\nreturn sprintf(buf, "%d\n", rpm);\r\n}\r\nstatic ssize_t get_fan_target(struct device *dev,\r\nstruct device_attribute *devattr, char *buf)\r\n{\r\nstruct sensor_device_attribute *attr = to_sensor_dev_attr(devattr);\r\nstruct max31790_data *data = max31790_update_device(dev);\r\nint sr, rpm;\r\nif (IS_ERR(data))\r\nreturn PTR_ERR(data);\r\nsr = get_tach_period(data->fan_dynamics[attr->index]);\r\nrpm = RPM_FROM_REG(data->target_count[attr->index], sr);\r\nreturn sprintf(buf, "%d\n", rpm);\r\n}\r\nstatic ssize_t set_fan_target(struct device *dev,\r\nstruct device_attribute *devattr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct sensor_device_attribute *attr = to_sensor_dev_attr(devattr);\r\nstruct max31790_data *data = dev_get_drvdata(dev);\r\nstruct i2c_client *client = data->client;\r\nu8 bits;\r\nint sr;\r\nint target_count;\r\nunsigned long rpm;\r\nint err;\r\nerr = kstrtoul(buf, 10, &rpm);\r\nif (err)\r\nreturn err;\r\nmutex_lock(&data->update_lock);\r\nrpm = clamp_val(rpm, FAN_RPM_MIN, FAN_RPM_MAX);\r\nbits = bits_for_tach_period(rpm);\r\ndata->fan_dynamics[attr->index] =\r\n((data->fan_dynamics[attr->index]\r\n& ~MAX31790_FAN_DYN_SR_MASK)\r\n| (bits << MAX31790_FAN_DYN_SR_SHIFT));\r\nerr = i2c_smbus_write_byte_data(client,\r\nMAX31790_REG_FAN_DYNAMICS(attr->index),\r\ndata->fan_dynamics[attr->index]);\r\nif (err < 0) {\r\nmutex_unlock(&data->update_lock);\r\nreturn err;\r\n}\r\nsr = get_tach_period(data->fan_dynamics[attr->index]);\r\ntarget_count = RPM_TO_REG(rpm, sr);\r\ntarget_count = clamp_val(target_count, 0x1, 0x7FF);\r\ndata->target_count[attr->index] = target_count << 5;\r\nerr = i2c_smbus_write_word_swapped(client,\r\nMAX31790_REG_TARGET_COUNT(attr->index),\r\ndata->target_count[attr->index]);\r\nmutex_unlock(&data->update_lock);\r\nif (err < 0)\r\nreturn err;\r\nreturn count;\r\n}\r\nstatic ssize_t get_pwm(struct device *dev,\r\nstruct device_attribute *devattr, char *buf)\r\n{\r\nstruct sensor_device_attribute *attr = to_sensor_dev_attr(devattr);\r\nstruct max31790_data *data = max31790_update_device(dev);\r\nint pwm;\r\nif (IS_ERR(data))\r\nreturn PTR_ERR(data);\r\npwm = data->pwm[attr->index] >> 8;\r\nreturn sprintf(buf, "%d\n", pwm);\r\n}\r\nstatic ssize_t set_pwm(struct device *dev,\r\nstruct device_attribute *devattr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct sensor_device_attribute *attr = to_sensor_dev_attr(devattr);\r\nstruct max31790_data *data = dev_get_drvdata(dev);\r\nstruct i2c_client *client = data->client;\r\nunsigned long pwm;\r\nint err;\r\nerr = kstrtoul(buf, 10, &pwm);\r\nif (err)\r\nreturn err;\r\nif (pwm > 255)\r\nreturn -EINVAL;\r\nmutex_lock(&data->update_lock);\r\ndata->pwm[attr->index] = pwm << 8;\r\nerr = i2c_smbus_write_word_swapped(client,\r\nMAX31790_REG_PWMOUT(attr->index),\r\ndata->pwm[attr->index]);\r\nmutex_unlock(&data->update_lock);\r\nif (err < 0)\r\nreturn err;\r\nreturn count;\r\n}\r\nstatic ssize_t get_pwm_enable(struct device *dev,\r\nstruct device_attribute *devattr, char *buf)\r\n{\r\nstruct sensor_device_attribute *attr = to_sensor_dev_attr(devattr);\r\nstruct max31790_data *data = max31790_update_device(dev);\r\nint mode;\r\nif (IS_ERR(data))\r\nreturn PTR_ERR(data);\r\nif (data->fan_config[attr->index] & MAX31790_FAN_CFG_RPM_MODE)\r\nmode = 2;\r\nelse if (data->fan_config[attr->index] & MAX31790_FAN_CFG_TACH_INPUT_EN)\r\nmode = 1;\r\nelse\r\nmode = 0;\r\nreturn sprintf(buf, "%d\n", mode);\r\n}\r\nstatic ssize_t set_pwm_enable(struct device *dev,\r\nstruct device_attribute *devattr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct sensor_device_attribute *attr = to_sensor_dev_attr(devattr);\r\nstruct max31790_data *data = dev_get_drvdata(dev);\r\nstruct i2c_client *client = data->client;\r\nunsigned long mode;\r\nint err;\r\nerr = kstrtoul(buf, 10, &mode);\r\nif (err)\r\nreturn err;\r\nswitch (mode) {\r\ncase 0:\r\ndata->fan_config[attr->index] =\r\ndata->fan_config[attr->index]\r\n& ~(MAX31790_FAN_CFG_TACH_INPUT_EN\r\n| MAX31790_FAN_CFG_RPM_MODE);\r\nbreak;\r\ncase 1:\r\ndata->fan_config[attr->index] =\r\n(data->fan_config[attr->index]\r\n| MAX31790_FAN_CFG_TACH_INPUT_EN)\r\n& ~MAX31790_FAN_CFG_RPM_MODE;\r\nbreak;\r\ncase 2:\r\ndata->fan_config[attr->index] =\r\ndata->fan_config[attr->index]\r\n| MAX31790_FAN_CFG_TACH_INPUT_EN\r\n| MAX31790_FAN_CFG_RPM_MODE;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nmutex_lock(&data->update_lock);\r\nerr = i2c_smbus_write_byte_data(client,\r\nMAX31790_REG_FAN_CONFIG(attr->index),\r\ndata->fan_config[attr->index]);\r\nmutex_unlock(&data->update_lock);\r\nif (err < 0)\r\nreturn err;\r\nreturn count;\r\n}\r\nstatic ssize_t get_fan_fault(struct device *dev,\r\nstruct device_attribute *devattr, char *buf)\r\n{\r\nstruct sensor_device_attribute *attr = to_sensor_dev_attr(devattr);\r\nstruct max31790_data *data = max31790_update_device(dev);\r\nint fault;\r\nif (IS_ERR(data))\r\nreturn PTR_ERR(data);\r\nfault = !!(data->fault_status & (1 << attr->index));\r\nreturn sprintf(buf, "%d\n", fault);\r\n}\r\nstatic umode_t max31790_attrs_visible(struct kobject *kobj,\r\nstruct attribute *a, int n)\r\n{\r\nstruct device *dev = container_of(kobj, struct device, kobj);\r\nstruct max31790_data *data = dev_get_drvdata(dev);\r\nstruct device_attribute *devattr =\r\ncontainer_of(a, struct device_attribute, attr);\r\nint index = to_sensor_dev_attr(devattr)->index % NR_CHANNEL;\r\nu8 fan_config;\r\nfan_config = data->fan_config[index];\r\nif (n >= NR_CHANNEL * 2 && n < NR_CHANNEL * 4 &&\r\n!(fan_config & MAX31790_FAN_CFG_TACH_INPUT))\r\nreturn 0;\r\nif (n >= NR_CHANNEL * 4 && (fan_config & MAX31790_FAN_CFG_TACH_INPUT))\r\nreturn 0;\r\nreturn a->mode;\r\n}\r\nstatic int max31790_init_client(struct i2c_client *client,\r\nstruct max31790_data *data)\r\n{\r\nint i, rv;\r\nfor (i = 0; i < NR_CHANNEL; i++) {\r\nrv = i2c_smbus_read_byte_data(client,\r\nMAX31790_REG_FAN_CONFIG(i));\r\nif (rv < 0)\r\nreturn rv;\r\ndata->fan_config[i] = rv;\r\nrv = i2c_smbus_read_byte_data(client,\r\nMAX31790_REG_FAN_DYNAMICS(i));\r\nif (rv < 0)\r\nreturn rv;\r\ndata->fan_dynamics[i] = rv;\r\n}\r\nreturn 0;\r\n}\r\nstatic int max31790_probe(struct i2c_client *client,\r\nconst struct i2c_device_id *id)\r\n{\r\nstruct i2c_adapter *adapter = client->adapter;\r\nstruct device *dev = &client->dev;\r\nstruct max31790_data *data;\r\nstruct device *hwmon_dev;\r\nint err;\r\nif (!i2c_check_functionality(adapter,\r\nI2C_FUNC_SMBUS_BYTE_DATA | I2C_FUNC_SMBUS_WORD_DATA))\r\nreturn -ENODEV;\r\ndata = devm_kzalloc(dev, sizeof(struct max31790_data), GFP_KERNEL);\r\nif (!data)\r\nreturn -ENOMEM;\r\ndata->client = client;\r\nmutex_init(&data->update_lock);\r\nerr = max31790_init_client(client, data);\r\nif (err)\r\nreturn err;\r\nhwmon_dev = devm_hwmon_device_register_with_groups(dev,\r\nclient->name, data, max31790_groups);\r\nreturn PTR_ERR_OR_ZERO(hwmon_dev);\r\n}
