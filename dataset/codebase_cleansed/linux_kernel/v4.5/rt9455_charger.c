static unsigned int rt9455_find_idx(const int tbl[], int tbl_size, int v)\r\n{\r\nint i;\r\nfor (i = 0; i < tbl_size - 1; i++)\r\nif (v <= tbl[i])\r\nreturn i;\r\nreturn (tbl_size - 1);\r\n}\r\nstatic int rt9455_get_field_val(struct rt9455_info *info,\r\nenum rt9455_fields field,\r\nconst int tbl[], int tbl_size, int *val)\r\n{\r\nunsigned int v;\r\nint ret;\r\nret = regmap_field_read(info->regmap_fields[field], &v);\r\nif (ret)\r\nreturn ret;\r\nv = (v >= tbl_size) ? (tbl_size - 1) : v;\r\n*val = tbl[v];\r\nreturn 0;\r\n}\r\nstatic int rt9455_set_field_val(struct rt9455_info *info,\r\nenum rt9455_fields field,\r\nconst int tbl[], int tbl_size, int val)\r\n{\r\nunsigned int idx = rt9455_find_idx(tbl, tbl_size, val);\r\nreturn regmap_field_write(info->regmap_fields[field], idx);\r\n}\r\nstatic int rt9455_register_reset(struct rt9455_info *info)\r\n{\r\nstruct device *dev = &info->client->dev;\r\nunsigned int v;\r\nint ret, limit = 100;\r\nret = regmap_field_write(info->regmap_fields[F_RST], 0x01);\r\nif (ret) {\r\ndev_err(dev, "Failed to set RST bit\n");\r\nreturn ret;\r\n}\r\ndo {\r\nret = regmap_field_read(info->regmap_fields[F_RST], &v);\r\nif (ret) {\r\ndev_err(dev, "Failed to read RST bit\n");\r\nreturn ret;\r\n}\r\nif (!v)\r\nbreak;\r\nusleep_range(10, 100);\r\n} while (--limit);\r\nif (!limit)\r\nreturn -EIO;\r\nreturn 0;\r\n}\r\nstatic int rt9455_charger_get_status(struct rt9455_info *info,\r\nunion power_supply_propval *val)\r\n{\r\nunsigned int v, pwr_rdy;\r\nint ret;\r\nret = regmap_field_read(info->regmap_fields[F_PWR_RDY],\r\n&pwr_rdy);\r\nif (ret) {\r\ndev_err(&info->client->dev, "Failed to read PWR_RDY bit\n");\r\nreturn ret;\r\n}\r\nif (!pwr_rdy) {\r\nval->intval = POWER_SUPPLY_STATUS_DISCHARGING;\r\nreturn 0;\r\n}\r\nret = regmap_field_read(info->regmap_fields[F_STAT], &v);\r\nif (ret) {\r\ndev_err(&info->client->dev, "Failed to read STAT bits\n");\r\nreturn ret;\r\n}\r\nswitch (v) {\r\ncase 0:\r\nval->intval = POWER_SUPPLY_STATUS_NOT_CHARGING;\r\nreturn 0;\r\ncase 1:\r\nval->intval = POWER_SUPPLY_STATUS_CHARGING;\r\nreturn 0;\r\ncase 2:\r\nval->intval = POWER_SUPPLY_STATUS_FULL;\r\nreturn 0;\r\ndefault:\r\nval->intval = POWER_SUPPLY_STATUS_UNKNOWN;\r\nreturn 0;\r\n}\r\n}\r\nstatic int rt9455_charger_get_health(struct rt9455_info *info,\r\nunion power_supply_propval *val)\r\n{\r\nstruct device *dev = &info->client->dev;\r\nunsigned int v;\r\nint ret;\r\nval->intval = POWER_SUPPLY_HEALTH_GOOD;\r\nret = regmap_read(info->regmap, RT9455_REG_IRQ1, &v);\r\nif (ret) {\r\ndev_err(dev, "Failed to read IRQ1 register\n");\r\nreturn ret;\r\n}\r\nif (v & GET_MASK(F_TSDI)) {\r\nval->intval = POWER_SUPPLY_HEALTH_OVERHEAT;\r\nreturn 0;\r\n}\r\nif (v & GET_MASK(F_VINOVPI)) {\r\nval->intval = POWER_SUPPLY_HEALTH_OVERVOLTAGE;\r\nreturn 0;\r\n}\r\nif (v & GET_MASK(F_BATAB)) {\r\nval->intval = POWER_SUPPLY_HEALTH_UNSPEC_FAILURE;\r\nreturn 0;\r\n}\r\nret = regmap_read(info->regmap, RT9455_REG_IRQ2, &v);\r\nif (ret) {\r\ndev_err(dev, "Failed to read IRQ2 register\n");\r\nreturn ret;\r\n}\r\nif (v & GET_MASK(F_CHBATOVI)) {\r\nval->intval = POWER_SUPPLY_HEALTH_UNSPEC_FAILURE;\r\nreturn 0;\r\n}\r\nif (v & GET_MASK(F_CH32MI)) {\r\nval->intval = POWER_SUPPLY_HEALTH_SAFETY_TIMER_EXPIRE;\r\nreturn 0;\r\n}\r\nret = regmap_read(info->regmap, RT9455_REG_IRQ3, &v);\r\nif (ret) {\r\ndev_err(dev, "Failed to read IRQ3 register\n");\r\nreturn ret;\r\n}\r\nif (v & GET_MASK(F_BSTBUSOVI)) {\r\nval->intval = POWER_SUPPLY_HEALTH_UNSPEC_FAILURE;\r\nreturn 0;\r\n}\r\nif (v & GET_MASK(F_BSTOLI)) {\r\nval->intval = POWER_SUPPLY_HEALTH_OVERVOLTAGE;\r\nreturn 0;\r\n}\r\nif (v & GET_MASK(F_BSTLOWVI)) {\r\nval->intval = POWER_SUPPLY_HEALTH_UNSPEC_FAILURE;\r\nreturn 0;\r\n}\r\nif (v & GET_MASK(F_BST32SI)) {\r\nval->intval = POWER_SUPPLY_HEALTH_SAFETY_TIMER_EXPIRE;\r\nreturn 0;\r\n}\r\nret = regmap_field_read(info->regmap_fields[F_STAT], &v);\r\nif (ret) {\r\ndev_err(dev, "Failed to read STAT bits\n");\r\nreturn ret;\r\n}\r\nif (v == RT9455_FAULT) {\r\nval->intval = POWER_SUPPLY_HEALTH_UNSPEC_FAILURE;\r\nreturn 0;\r\n}\r\nreturn 0;\r\n}\r\nstatic int rt9455_charger_get_battery_presence(struct rt9455_info *info,\r\nunion power_supply_propval *val)\r\n{\r\nunsigned int v;\r\nint ret;\r\nret = regmap_field_read(info->regmap_fields[F_BATAB], &v);\r\nif (ret) {\r\ndev_err(&info->client->dev, "Failed to read BATAB bit\n");\r\nreturn ret;\r\n}\r\nval->intval = !v;\r\nreturn 0;\r\n}\r\nstatic int rt9455_charger_get_online(struct rt9455_info *info,\r\nunion power_supply_propval *val)\r\n{\r\nunsigned int v;\r\nint ret;\r\nret = regmap_field_read(info->regmap_fields[F_PWR_RDY], &v);\r\nif (ret) {\r\ndev_err(&info->client->dev, "Failed to read PWR_RDY bit\n");\r\nreturn ret;\r\n}\r\nval->intval = (int)v;\r\nreturn 0;\r\n}\r\nstatic int rt9455_charger_get_current(struct rt9455_info *info,\r\nunion power_supply_propval *val)\r\n{\r\nint curr;\r\nint ret;\r\nret = rt9455_get_field_val(info, F_ICHRG,\r\nrt9455_ichrg_values,\r\nARRAY_SIZE(rt9455_ichrg_values),\r\n&curr);\r\nif (ret) {\r\ndev_err(&info->client->dev, "Failed to read ICHRG value\n");\r\nreturn ret;\r\n}\r\nval->intval = curr;\r\nreturn 0;\r\n}\r\nstatic int rt9455_charger_get_current_max(struct rt9455_info *info,\r\nunion power_supply_propval *val)\r\n{\r\nint idx = ARRAY_SIZE(rt9455_ichrg_values) - 1;\r\nval->intval = rt9455_ichrg_values[idx];\r\nreturn 0;\r\n}\r\nstatic int rt9455_charger_get_voltage(struct rt9455_info *info,\r\nunion power_supply_propval *val)\r\n{\r\nint voltage;\r\nint ret;\r\nret = rt9455_get_field_val(info, F_VOREG,\r\nrt9455_voreg_values,\r\nARRAY_SIZE(rt9455_voreg_values),\r\n&voltage);\r\nif (ret) {\r\ndev_err(&info->client->dev, "Failed to read VOREG value\n");\r\nreturn ret;\r\n}\r\nval->intval = voltage;\r\nreturn 0;\r\n}\r\nstatic int rt9455_charger_get_voltage_max(struct rt9455_info *info,\r\nunion power_supply_propval *val)\r\n{\r\nint idx = ARRAY_SIZE(rt9455_vmreg_values) - 1;\r\nval->intval = rt9455_vmreg_values[idx];\r\nreturn 0;\r\n}\r\nstatic int rt9455_charger_get_term_current(struct rt9455_info *info,\r\nunion power_supply_propval *val)\r\n{\r\nstruct device *dev = &info->client->dev;\r\nint ichrg, ieoc_percentage, ret;\r\nret = rt9455_get_field_val(info, F_ICHRG,\r\nrt9455_ichrg_values,\r\nARRAY_SIZE(rt9455_ichrg_values),\r\n&ichrg);\r\nif (ret) {\r\ndev_err(dev, "Failed to read ICHRG value\n");\r\nreturn ret;\r\n}\r\nret = rt9455_get_field_val(info, F_IEOC_PERCENTAGE,\r\nrt9455_ieoc_percentage_values,\r\nARRAY_SIZE(rt9455_ieoc_percentage_values),\r\n&ieoc_percentage);\r\nif (ret) {\r\ndev_err(dev, "Failed to read IEOC value\n");\r\nreturn ret;\r\n}\r\nval->intval = ichrg * ieoc_percentage / 100;\r\nreturn 0;\r\n}\r\nstatic int rt9455_charger_get_property(struct power_supply *psy,\r\nenum power_supply_property psp,\r\nunion power_supply_propval *val)\r\n{\r\nstruct rt9455_info *info = power_supply_get_drvdata(psy);\r\nswitch (psp) {\r\ncase POWER_SUPPLY_PROP_STATUS:\r\nreturn rt9455_charger_get_status(info, val);\r\ncase POWER_SUPPLY_PROP_HEALTH:\r\nreturn rt9455_charger_get_health(info, val);\r\ncase POWER_SUPPLY_PROP_PRESENT:\r\nreturn rt9455_charger_get_battery_presence(info, val);\r\ncase POWER_SUPPLY_PROP_ONLINE:\r\nreturn rt9455_charger_get_online(info, val);\r\ncase POWER_SUPPLY_PROP_CONSTANT_CHARGE_CURRENT:\r\nreturn rt9455_charger_get_current(info, val);\r\ncase POWER_SUPPLY_PROP_CONSTANT_CHARGE_CURRENT_MAX:\r\nreturn rt9455_charger_get_current_max(info, val);\r\ncase POWER_SUPPLY_PROP_CONSTANT_CHARGE_VOLTAGE:\r\nreturn rt9455_charger_get_voltage(info, val);\r\ncase POWER_SUPPLY_PROP_CONSTANT_CHARGE_VOLTAGE_MAX:\r\nreturn rt9455_charger_get_voltage_max(info, val);\r\ncase POWER_SUPPLY_PROP_SCOPE:\r\nval->intval = POWER_SUPPLY_SCOPE_SYSTEM;\r\nreturn 0;\r\ncase POWER_SUPPLY_PROP_CHARGE_TERM_CURRENT:\r\nreturn rt9455_charger_get_term_current(info, val);\r\ncase POWER_SUPPLY_PROP_MODEL_NAME:\r\nval->strval = RT9455_MODEL_NAME;\r\nreturn 0;\r\ncase POWER_SUPPLY_PROP_MANUFACTURER:\r\nval->strval = RT9455_MANUFACTURER;\r\nreturn 0;\r\ndefault:\r\nreturn -ENODATA;\r\n}\r\n}\r\nstatic int rt9455_hw_init(struct rt9455_info *info, u32 ichrg,\r\nu32 ieoc_percentage,\r\nu32 mivr, u32 iaicr)\r\n{\r\nstruct device *dev = &info->client->dev;\r\nint idx, ret;\r\nret = rt9455_register_reset(info);\r\nif (ret) {\r\ndev_err(dev, "Power On Reset failed\n");\r\nreturn ret;\r\n}\r\nret = regmap_field_write(info->regmap_fields[F_TE], 1);\r\nif (ret) {\r\ndev_err(dev, "Failed to set TE bit\n");\r\nreturn ret;\r\n}\r\nret = regmap_field_write(info->regmap_fields[F_TE_SHDN_EN], 1);\r\nif (ret) {\r\ndev_err(dev, "Failed to set TE_SHDN_EN bit\n");\r\nreturn ret;\r\n}\r\nret = regmap_field_write(info->regmap_fields[F_BATD_EN], 1);\r\nif (ret) {\r\ndev_err(dev, "Failed to set BATD_EN bit\n");\r\nreturn ret;\r\n}\r\nret = regmap_field_write(info->regmap_fields[F_TMR_EN], 0x00);\r\nif (ret) {\r\ndev_err(dev, "Failed to disable Safety Timer\n");\r\nreturn ret;\r\n}\r\nret = rt9455_set_field_val(info, F_ICHRG,\r\nrt9455_ichrg_values,\r\nARRAY_SIZE(rt9455_ichrg_values), ichrg);\r\nif (ret) {\r\ndev_err(dev, "Failed to set ICHRG value\n");\r\nreturn ret;\r\n}\r\nret = rt9455_set_field_val(info, F_IEOC_PERCENTAGE,\r\nrt9455_ieoc_percentage_values,\r\nARRAY_SIZE(rt9455_ieoc_percentage_values),\r\nieoc_percentage);\r\nif (ret) {\r\ndev_err(dev, "Failed to set IEOC Percentage value\n");\r\nreturn ret;\r\n}\r\nret = rt9455_set_field_val(info, F_VOREG,\r\nrt9455_voreg_values,\r\nARRAY_SIZE(rt9455_voreg_values),\r\ninfo->voreg);\r\nif (ret) {\r\ndev_err(dev, "Failed to set VOREG value\n");\r\nreturn ret;\r\n}\r\nidx = ARRAY_SIZE(rt9455_vmreg_values) - 1;\r\nret = rt9455_set_field_val(info, F_VMREG,\r\nrt9455_vmreg_values,\r\nARRAY_SIZE(rt9455_vmreg_values),\r\nrt9455_vmreg_values[idx]);\r\nif (ret) {\r\ndev_err(dev, "Failed to set VMREG value\n");\r\nreturn ret;\r\n}\r\nif (mivr == -1)\r\nmivr = 4500000;\r\nret = rt9455_set_field_val(info, F_MIVR,\r\nrt9455_mivr_values,\r\nARRAY_SIZE(rt9455_mivr_values), mivr);\r\nif (ret) {\r\ndev_err(dev, "Failed to set MIVR value\n");\r\nreturn ret;\r\n}\r\nif (iaicr == -1)\r\niaicr = 500000;\r\nret = rt9455_set_field_val(info, F_IAICR,\r\nrt9455_iaicr_values,\r\nARRAY_SIZE(rt9455_iaicr_values), iaicr);\r\nif (ret) {\r\ndev_err(dev, "Failed to set IAICR value\n");\r\nreturn ret;\r\n}\r\nret = regmap_field_write(info->regmap_fields[F_IAICR_INT], 0x01);\r\nif (ret) {\r\ndev_err(dev, "Failed to set IAICR_INT bit\n");\r\nreturn ret;\r\n}\r\nret = regmap_field_write(info->regmap_fields[F_CHMIVRIM], 0x01);\r\nif (ret) {\r\ndev_err(dev, "Failed to mask CHMIVRI interrupt\n");\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic int rt9455_set_boost_voltage_before_boost_mode(struct rt9455_info *info)\r\n{\r\nstruct device *dev = &info->client->dev;\r\nint ret;\r\nret = rt9455_set_field_val(info, F_VOREG,\r\nrt9455_boost_voltage_values,\r\nARRAY_SIZE(rt9455_boost_voltage_values),\r\ninfo->boost_voltage);\r\nif (ret) {\r\ndev_err(dev, "Failed to set boost output voltage value\n");\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic int rt9455_set_voreg_before_charge_mode(struct rt9455_info *info)\r\n{\r\nstruct device *dev = &info->client->dev;\r\nint ret;\r\nret = rt9455_set_field_val(info, F_VOREG,\r\nrt9455_voreg_values,\r\nARRAY_SIZE(rt9455_voreg_values),\r\ninfo->voreg);\r\nif (ret) {\r\ndev_err(dev, "Failed to set VOREG value\n");\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic int rt9455_irq_handler_check_irq1_register(struct rt9455_info *info,\r\nbool *_is_battery_absent,\r\nbool *_alert_userspace)\r\n{\r\nunsigned int irq1, mask1, mask2;\r\nstruct device *dev = &info->client->dev;\r\nbool is_battery_absent = false;\r\nbool alert_userspace = false;\r\nint ret;\r\nret = regmap_read(info->regmap, RT9455_REG_IRQ1, &irq1);\r\nif (ret) {\r\ndev_err(dev, "Failed to read IRQ1 register\n");\r\nreturn ret;\r\n}\r\nret = regmap_read(info->regmap, RT9455_REG_MASK1, &mask1);\r\nif (ret) {\r\ndev_err(dev, "Failed to read MASK1 register\n");\r\nreturn ret;\r\n}\r\nif (irq1 & GET_MASK(F_TSDI)) {\r\ndev_err(dev, "Thermal shutdown fault occurred\n");\r\nalert_userspace = true;\r\n}\r\nif (irq1 & GET_MASK(F_VINOVPI)) {\r\ndev_err(dev, "Overvoltage input occurred\n");\r\nalert_userspace = true;\r\n}\r\nif (irq1 & GET_MASK(F_BATAB)) {\r\ndev_err(dev, "Battery absence occurred\n");\r\nis_battery_absent = true;\r\nalert_userspace = true;\r\nif ((mask1 & GET_MASK(F_BATABM)) == 0) {\r\nret = regmap_field_write(info->regmap_fields[F_BATABM],\r\n0x01);\r\nif (ret) {\r\ndev_err(dev, "Failed to mask BATAB interrupt\n");\r\nreturn ret;\r\n}\r\n}\r\nret = regmap_read(info->regmap, RT9455_REG_MASK2, &mask2);\r\nif (ret) {\r\ndev_err(dev, "Failed to read MASK2 register\n");\r\nreturn ret;\r\n}\r\nif (mask2 & GET_MASK(F_CHTERMIM)) {\r\nret = regmap_field_write(\r\ninfo->regmap_fields[F_CHTERMIM], 0x00);\r\nif (ret) {\r\ndev_err(dev, "Failed to unmask CHTERMI interrupt\n");\r\nreturn ret;\r\n}\r\n}\r\nif (mask2 & GET_MASK(F_CHRCHGIM)) {\r\nret = regmap_field_write(\r\ninfo->regmap_fields[F_CHRCHGIM], 0x00);\r\nif (ret) {\r\ndev_err(dev, "Failed to unmask CHRCHGI interrupt\n");\r\nreturn ret;\r\n}\r\n}\r\ncancel_delayed_work_sync(&info->max_charging_time_work);\r\nqueue_delayed_work(system_power_efficient_wq,\r\n&info->batt_presence_work,\r\nRT9455_BATT_PRESENCE_DELAY * HZ);\r\n}\r\n*_is_battery_absent = is_battery_absent;\r\nif (alert_userspace)\r\n*_alert_userspace = alert_userspace;\r\nreturn 0;\r\n}\r\nstatic int rt9455_irq_handler_check_irq2_register(struct rt9455_info *info,\r\nbool is_battery_absent,\r\nbool *_alert_userspace)\r\n{\r\nunsigned int irq2, mask2;\r\nstruct device *dev = &info->client->dev;\r\nbool alert_userspace = false;\r\nint ret;\r\nret = regmap_read(info->regmap, RT9455_REG_IRQ2, &irq2);\r\nif (ret) {\r\ndev_err(dev, "Failed to read IRQ2 register\n");\r\nreturn ret;\r\n}\r\nret = regmap_read(info->regmap, RT9455_REG_MASK2, &mask2);\r\nif (ret) {\r\ndev_err(dev, "Failed to read MASK2 register\n");\r\nreturn ret;\r\n}\r\nif (irq2 & GET_MASK(F_CHRVPI)) {\r\ndev_dbg(dev, "Charger fault occurred\n");\r\nqueue_delayed_work(system_power_efficient_wq,\r\n&info->pwr_rdy_work,\r\nRT9455_PWR_RDY_DELAY * HZ);\r\n}\r\nif (irq2 & GET_MASK(F_CHBATOVI)) {\r\ndev_err(dev, "Battery OVP occurred\n");\r\nalert_userspace = true;\r\n}\r\nif (irq2 & GET_MASK(F_CHTERMI)) {\r\ndev_dbg(dev, "Charge terminated\n");\r\nif (!is_battery_absent) {\r\nif ((mask2 & GET_MASK(F_CHTERMIM)) == 0) {\r\nret = regmap_field_write(\r\ninfo->regmap_fields[F_CHTERMIM], 0x01);\r\nif (ret) {\r\ndev_err(dev, "Failed to mask CHTERMI interrupt\n");\r\nreturn ret;\r\n}\r\nmask2 = mask2 | GET_MASK(F_CHTERMIM);\r\n}\r\ncancel_delayed_work_sync(&info->max_charging_time_work);\r\nalert_userspace = true;\r\n}\r\n}\r\nif (irq2 & GET_MASK(F_CHRCHGI)) {\r\ndev_dbg(dev, "Recharge request\n");\r\nret = regmap_field_write(info->regmap_fields[F_CHG_EN],\r\nRT9455_CHARGE_ENABLE);\r\nif (ret) {\r\ndev_err(dev, "Failed to enable charging\n");\r\nreturn ret;\r\n}\r\nif (mask2 & GET_MASK(F_CHTERMIM)) {\r\nret = regmap_field_write(\r\ninfo->regmap_fields[F_CHTERMIM], 0x00);\r\nif (ret) {\r\ndev_err(dev, "Failed to unmask CHTERMI interrupt\n");\r\nreturn ret;\r\n}\r\nmask2 = mask2 & ~GET_MASK(F_CHTERMIM);\r\n}\r\nif (!is_battery_absent) {\r\nqueue_delayed_work(system_power_efficient_wq,\r\n&info->max_charging_time_work,\r\nRT9455_MAX_CHARGING_TIME * HZ);\r\nalert_userspace = true;\r\n}\r\n}\r\nif (irq2 & GET_MASK(F_CH32MI)) {\r\ndev_err(dev, "Charger fault. 32 mins timeout occurred\n");\r\nalert_userspace = true;\r\n}\r\nif (irq2 & GET_MASK(F_CHTREGI)) {\r\ndev_warn(dev,\r\n"Charger warning. Thermal regulation loop active\n");\r\nalert_userspace = true;\r\n}\r\nif (irq2 & GET_MASK(F_CHMIVRI)) {\r\ndev_dbg(dev,\r\n"Charger warning. Input voltage MIVR loop active\n");\r\n}\r\nif (alert_userspace)\r\n*_alert_userspace = alert_userspace;\r\nreturn 0;\r\n}\r\nstatic int rt9455_irq_handler_check_irq3_register(struct rt9455_info *info,\r\nbool *_alert_userspace)\r\n{\r\nunsigned int irq3, mask3;\r\nstruct device *dev = &info->client->dev;\r\nbool alert_userspace = false;\r\nint ret;\r\nret = regmap_read(info->regmap, RT9455_REG_IRQ3, &irq3);\r\nif (ret) {\r\ndev_err(dev, "Failed to read IRQ3 register\n");\r\nreturn ret;\r\n}\r\nret = regmap_read(info->regmap, RT9455_REG_MASK3, &mask3);\r\nif (ret) {\r\ndev_err(dev, "Failed to read MASK3 register\n");\r\nreturn ret;\r\n}\r\nif (irq3 & GET_MASK(F_BSTBUSOVI)) {\r\ndev_err(dev, "Boost fault. Overvoltage input occurred\n");\r\nalert_userspace = true;\r\n}\r\nif (irq3 & GET_MASK(F_BSTOLI)) {\r\ndev_err(dev, "Boost fault. Overload\n");\r\nalert_userspace = true;\r\n}\r\nif (irq3 & GET_MASK(F_BSTLOWVI)) {\r\ndev_err(dev, "Boost fault. Battery voltage too low\n");\r\nalert_userspace = true;\r\n}\r\nif (irq3 & GET_MASK(F_BST32SI)) {\r\ndev_err(dev, "Boost fault. 32 seconds timeout occurred.\n");\r\nalert_userspace = true;\r\n}\r\nif (alert_userspace) {\r\ndev_info(dev, "Boost fault occurred, therefore the charger goes into charge mode\n");\r\nret = rt9455_set_voreg_before_charge_mode(info);\r\nif (ret) {\r\ndev_err(dev, "Failed to set VOREG before entering charge mode\n");\r\nreturn ret;\r\n}\r\nret = regmap_field_write(info->regmap_fields[F_OPA_MODE],\r\nRT9455_CHARGE_MODE);\r\nif (ret) {\r\ndev_err(dev, "Failed to set charger in charge mode\n");\r\nreturn ret;\r\n}\r\n*_alert_userspace = alert_userspace;\r\n}\r\nreturn 0;\r\n}\r\nstatic irqreturn_t rt9455_irq_handler_thread(int irq, void *data)\r\n{\r\nstruct rt9455_info *info = data;\r\nstruct device *dev;\r\nbool alert_userspace = false;\r\nbool is_battery_absent = false;\r\nunsigned int status;\r\nint ret;\r\nif (!info)\r\nreturn IRQ_NONE;\r\ndev = &info->client->dev;\r\nif (irq != info->client->irq) {\r\ndev_err(dev, "Interrupt is not for RT9455 charger\n");\r\nreturn IRQ_NONE;\r\n}\r\nret = regmap_field_read(info->regmap_fields[F_STAT], &status);\r\nif (ret) {\r\ndev_err(dev, "Failed to read STAT bits\n");\r\nreturn IRQ_HANDLED;\r\n}\r\ndev_dbg(dev, "Charger status is %d\n", status);\r\nret = rt9455_irq_handler_check_irq1_register(info, &is_battery_absent,\r\n&alert_userspace);\r\nif (ret) {\r\ndev_err(dev, "Failed to handle IRQ1 register\n");\r\nreturn IRQ_HANDLED;\r\n}\r\nret = rt9455_irq_handler_check_irq2_register(info, is_battery_absent,\r\n&alert_userspace);\r\nif (ret) {\r\ndev_err(dev, "Failed to handle IRQ2 register\n");\r\nreturn IRQ_HANDLED;\r\n}\r\nret = rt9455_irq_handler_check_irq3_register(info, &alert_userspace);\r\nif (ret) {\r\ndev_err(dev, "Failed to handle IRQ3 register\n");\r\nreturn IRQ_HANDLED;\r\n}\r\nif (alert_userspace) {\r\nif (info->charger)\r\npower_supply_changed(info->charger);\r\n}\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int rt9455_discover_charger(struct rt9455_info *info, u32 *ichrg,\r\nu32 *ieoc_percentage,\r\nu32 *mivr, u32 *iaicr)\r\n{\r\nstruct device *dev = &info->client->dev;\r\nint ret;\r\nif (!dev->of_node && !ACPI_HANDLE(dev)) {\r\ndev_err(dev, "No support for either device tree or ACPI\n");\r\nreturn -EINVAL;\r\n}\r\nret = device_property_read_u32(dev, "richtek,output-charge-current",\r\nichrg);\r\nif (ret) {\r\ndev_err(dev, "Error: missing \"output-charge-current\" property\n");\r\nreturn ret;\r\n}\r\nret = device_property_read_u32(dev, "richtek,end-of-charge-percentage",\r\nieoc_percentage);\r\nif (ret) {\r\ndev_err(dev, "Error: missing \"end-of-charge-percentage\" property\n");\r\nreturn ret;\r\n}\r\nret = device_property_read_u32(dev,\r\n"richtek,battery-regulation-voltage",\r\n&info->voreg);\r\nif (ret) {\r\ndev_err(dev, "Error: missing \"battery-regulation-voltage\" property\n");\r\nreturn ret;\r\n}\r\nret = device_property_read_u32(dev, "richtek,boost-output-voltage",\r\n&info->boost_voltage);\r\nif (ret) {\r\ndev_err(dev, "Error: missing \"boost-output-voltage\" property\n");\r\nreturn ret;\r\n}\r\ndevice_property_read_u32(dev, "richtek,min-input-voltage-regulation",\r\nmivr);\r\ndevice_property_read_u32(dev, "richtek,avg-input-current-regulation",\r\niaicr);\r\nreturn 0;\r\n}\r\nstatic int rt9455_usb_event_none(struct rt9455_info *info,\r\nu8 opa_mode, u8 iaicr)\r\n{\r\nstruct device *dev = &info->client->dev;\r\nint ret;\r\nif (opa_mode == RT9455_BOOST_MODE) {\r\nret = rt9455_set_voreg_before_charge_mode(info);\r\nif (ret) {\r\ndev_err(dev, "Failed to set VOREG before entering charge mode\n");\r\nreturn ret;\r\n}\r\ndev_dbg(dev, "USB_EVENT_NONE received, therefore the charger goes into charge mode\n");\r\nret = regmap_field_write(info->regmap_fields[F_OPA_MODE],\r\nRT9455_CHARGE_MODE);\r\nif (ret) {\r\ndev_err(dev, "Failed to set charger in charge mode\n");\r\nreturn NOTIFY_DONE;\r\n}\r\n}\r\ndev_dbg(dev, "USB_EVENT_NONE received, therefore IAICR is set to its minimum value\n");\r\nif (iaicr != RT9455_IAICR_100MA) {\r\nret = regmap_field_write(info->regmap_fields[F_IAICR],\r\nRT9455_IAICR_100MA);\r\nif (ret) {\r\ndev_err(dev, "Failed to set IAICR value\n");\r\nreturn NOTIFY_DONE;\r\n}\r\n}\r\nreturn NOTIFY_OK;\r\n}\r\nstatic int rt9455_usb_event_vbus(struct rt9455_info *info,\r\nu8 opa_mode, u8 iaicr)\r\n{\r\nstruct device *dev = &info->client->dev;\r\nint ret;\r\nif (opa_mode == RT9455_BOOST_MODE) {\r\nret = rt9455_set_voreg_before_charge_mode(info);\r\nif (ret) {\r\ndev_err(dev, "Failed to set VOREG before entering charge mode\n");\r\nreturn ret;\r\n}\r\ndev_dbg(dev, "USB_EVENT_VBUS received, therefore the charger goes into charge mode\n");\r\nret = regmap_field_write(info->regmap_fields[F_OPA_MODE],\r\nRT9455_CHARGE_MODE);\r\nif (ret) {\r\ndev_err(dev, "Failed to set charger in charge mode\n");\r\nreturn NOTIFY_DONE;\r\n}\r\n}\r\ndev_dbg(dev, "USB_EVENT_VBUS received, therefore IAICR is set to 500 mA\n");\r\nif (iaicr != RT9455_IAICR_500MA) {\r\nret = regmap_field_write(info->regmap_fields[F_IAICR],\r\nRT9455_IAICR_500MA);\r\nif (ret) {\r\ndev_err(dev, "Failed to set IAICR value\n");\r\nreturn NOTIFY_DONE;\r\n}\r\n}\r\nreturn NOTIFY_OK;\r\n}\r\nstatic int rt9455_usb_event_id(struct rt9455_info *info,\r\nu8 opa_mode, u8 iaicr)\r\n{\r\nstruct device *dev = &info->client->dev;\r\nint ret;\r\nif (opa_mode == RT9455_CHARGE_MODE) {\r\nret = rt9455_set_boost_voltage_before_boost_mode(info);\r\nif (ret) {\r\ndev_err(dev, "Failed to set boost output voltage before entering boost mode\n");\r\nreturn ret;\r\n}\r\ndev_dbg(dev, "USB_EVENT_ID received, therefore the charger goes into boost mode\n");\r\nret = regmap_field_write(info->regmap_fields[F_OPA_MODE],\r\nRT9455_BOOST_MODE);\r\nif (ret) {\r\ndev_err(dev, "Failed to set charger in boost mode\n");\r\nreturn NOTIFY_DONE;\r\n}\r\n}\r\ndev_dbg(dev, "USB_EVENT_ID received, therefore IAICR is set to its minimum value\n");\r\nif (iaicr != RT9455_IAICR_100MA) {\r\nret = regmap_field_write(info->regmap_fields[F_IAICR],\r\nRT9455_IAICR_100MA);\r\nif (ret) {\r\ndev_err(dev, "Failed to set IAICR value\n");\r\nreturn NOTIFY_DONE;\r\n}\r\n}\r\nreturn NOTIFY_OK;\r\n}\r\nstatic int rt9455_usb_event_charger(struct rt9455_info *info,\r\nu8 opa_mode, u8 iaicr)\r\n{\r\nstruct device *dev = &info->client->dev;\r\nint ret;\r\nif (opa_mode == RT9455_BOOST_MODE) {\r\nret = rt9455_set_voreg_before_charge_mode(info);\r\nif (ret) {\r\ndev_err(dev, "Failed to set VOREG before entering charge mode\n");\r\nreturn ret;\r\n}\r\ndev_dbg(dev, "USB_EVENT_CHARGER received, therefore the charger goes into charge mode\n");\r\nret = regmap_field_write(info->regmap_fields[F_OPA_MODE],\r\nRT9455_CHARGE_MODE);\r\nif (ret) {\r\ndev_err(dev, "Failed to set charger in charge mode\n");\r\nreturn NOTIFY_DONE;\r\n}\r\n}\r\ndev_dbg(dev, "USB_EVENT_CHARGER received, therefore IAICR is set to no current limit\n");\r\nif (iaicr != RT9455_IAICR_NO_LIMIT) {\r\nret = regmap_field_write(info->regmap_fields[F_IAICR],\r\nRT9455_IAICR_NO_LIMIT);\r\nif (ret) {\r\ndev_err(dev, "Failed to set IAICR value\n");\r\nreturn NOTIFY_DONE;\r\n}\r\n}\r\nreturn NOTIFY_OK;\r\n}\r\nstatic int rt9455_usb_event(struct notifier_block *nb,\r\nunsigned long event, void *power)\r\n{\r\nstruct rt9455_info *info = container_of(nb, struct rt9455_info, nb);\r\nstruct device *dev = &info->client->dev;\r\nunsigned int opa_mode, iaicr;\r\nint ret;\r\nret = regmap_field_read(info->regmap_fields[F_OPA_MODE],\r\n&opa_mode);\r\nif (ret) {\r\ndev_err(dev, "Failed to read OPA_MODE value\n");\r\nreturn NOTIFY_DONE;\r\n}\r\nret = regmap_field_read(info->regmap_fields[F_IAICR],\r\n&iaicr);\r\nif (ret) {\r\ndev_err(dev, "Failed to read IAICR value\n");\r\nreturn NOTIFY_DONE;\r\n}\r\ndev_dbg(dev, "Received USB event %lu\n", event);\r\nswitch (event) {\r\ncase USB_EVENT_NONE:\r\nreturn rt9455_usb_event_none(info, opa_mode, iaicr);\r\ncase USB_EVENT_VBUS:\r\nreturn rt9455_usb_event_vbus(info, opa_mode, iaicr);\r\ncase USB_EVENT_ID:\r\nreturn rt9455_usb_event_id(info, opa_mode, iaicr);\r\ncase USB_EVENT_CHARGER:\r\nreturn rt9455_usb_event_charger(info, opa_mode, iaicr);\r\ndefault:\r\ndev_err(dev, "Unknown USB event\n");\r\n}\r\nreturn NOTIFY_DONE;\r\n}\r\nstatic void rt9455_pwr_rdy_work_callback(struct work_struct *work)\r\n{\r\nstruct rt9455_info *info = container_of(work, struct rt9455_info,\r\npwr_rdy_work.work);\r\nstruct device *dev = &info->client->dev;\r\nunsigned int pwr_rdy;\r\nint ret;\r\nret = regmap_field_read(info->regmap_fields[F_PWR_RDY], &pwr_rdy);\r\nif (ret) {\r\ndev_err(dev, "Failed to read PWR_RDY bit\n");\r\nreturn;\r\n}\r\nswitch (pwr_rdy) {\r\ncase RT9455_PWR_FAULT:\r\ndev_dbg(dev, "Charger disconnected from power source\n");\r\ncancel_delayed_work_sync(&info->max_charging_time_work);\r\nbreak;\r\ncase RT9455_PWR_GOOD:\r\ndev_dbg(dev, "Charger connected to power source\n");\r\nret = regmap_field_write(info->regmap_fields[F_CHG_EN],\r\nRT9455_CHARGE_ENABLE);\r\nif (ret) {\r\ndev_err(dev, "Failed to enable charging\n");\r\nreturn;\r\n}\r\nqueue_delayed_work(system_power_efficient_wq,\r\n&info->max_charging_time_work,\r\nRT9455_MAX_CHARGING_TIME * HZ);\r\nbreak;\r\n}\r\npower_supply_changed(info->charger);\r\n}\r\nstatic void rt9455_max_charging_time_work_callback(struct work_struct *work)\r\n{\r\nstruct rt9455_info *info = container_of(work, struct rt9455_info,\r\nmax_charging_time_work.work);\r\nstruct device *dev = &info->client->dev;\r\nint ret;\r\ndev_err(dev, "Battery has been charging for at least 6 hours and is not yet fully charged. Battery is dead, therefore charging is disabled.\n");\r\nret = regmap_field_write(info->regmap_fields[F_CHG_EN],\r\nRT9455_CHARGE_DISABLE);\r\nif (ret)\r\ndev_err(dev, "Failed to disable charging\n");\r\n}\r\nstatic void rt9455_batt_presence_work_callback(struct work_struct *work)\r\n{\r\nstruct rt9455_info *info = container_of(work, struct rt9455_info,\r\nbatt_presence_work.work);\r\nstruct device *dev = &info->client->dev;\r\nunsigned int irq1, mask1;\r\nint ret;\r\nret = regmap_read(info->regmap, RT9455_REG_IRQ1, &irq1);\r\nif (ret) {\r\ndev_err(dev, "Failed to read IRQ1 register\n");\r\nreturn;\r\n}\r\nif (irq1 & GET_MASK(F_BATAB)) {\r\nqueue_delayed_work(system_power_efficient_wq,\r\n&info->batt_presence_work,\r\nRT9455_BATT_PRESENCE_DELAY * HZ);\r\n} else {\r\nqueue_delayed_work(system_power_efficient_wq,\r\n&info->max_charging_time_work,\r\nRT9455_MAX_CHARGING_TIME * HZ);\r\nret = regmap_read(info->regmap, RT9455_REG_MASK1, &mask1);\r\nif (ret) {\r\ndev_err(dev, "Failed to read MASK1 register\n");\r\nreturn;\r\n}\r\nif (mask1 & GET_MASK(F_BATABM)) {\r\nret = regmap_field_write(info->regmap_fields[F_BATABM],\r\n0x00);\r\nif (ret)\r\ndev_err(dev, "Failed to unmask BATAB interrupt\n");\r\n}\r\npower_supply_changed(info->charger);\r\n}\r\n}\r\nstatic bool rt9455_is_writeable_reg(struct device *dev, unsigned int reg)\r\n{\r\nswitch (reg) {\r\ncase RT9455_REG_DEV_ID:\r\ncase RT9455_REG_IRQ1:\r\ncase RT9455_REG_IRQ2:\r\ncase RT9455_REG_IRQ3:\r\nreturn false;\r\ndefault:\r\nreturn true;\r\n}\r\n}\r\nstatic bool rt9455_is_volatile_reg(struct device *dev, unsigned int reg)\r\n{\r\nswitch (reg) {\r\ncase RT9455_REG_DEV_ID:\r\ncase RT9455_REG_CTRL5:\r\ncase RT9455_REG_CTRL6:\r\nreturn false;\r\ndefault:\r\nreturn true;\r\n}\r\n}\r\nstatic int rt9455_probe(struct i2c_client *client,\r\nconst struct i2c_device_id *id)\r\n{\r\nstruct i2c_adapter *adapter = to_i2c_adapter(client->dev.parent);\r\nstruct device *dev = &client->dev;\r\nstruct rt9455_info *info;\r\nstruct power_supply_config rt9455_charger_config = {};\r\nu32 ichrg, ieoc_percentage;\r\nu32 mivr = -1, iaicr = -1;\r\nint i, ret;\r\nif (!i2c_check_functionality(adapter, I2C_FUNC_SMBUS_BYTE_DATA)) {\r\ndev_err(dev, "No support for SMBUS_BYTE_DATA\n");\r\nreturn -ENODEV;\r\n}\r\ninfo = devm_kzalloc(dev, sizeof(*info), GFP_KERNEL);\r\nif (!info)\r\nreturn -ENOMEM;\r\ninfo->client = client;\r\ni2c_set_clientdata(client, info);\r\ninfo->regmap = devm_regmap_init_i2c(client,\r\n&rt9455_regmap_config);\r\nif (IS_ERR(info->regmap)) {\r\ndev_err(dev, "Failed to initialize register map\n");\r\nreturn -EINVAL;\r\n}\r\nfor (i = 0; i < F_MAX_FIELDS; i++) {\r\ninfo->regmap_fields[i] =\r\ndevm_regmap_field_alloc(dev, info->regmap,\r\nrt9455_reg_fields[i]);\r\nif (IS_ERR(info->regmap_fields[i])) {\r\ndev_err(dev,\r\n"Failed to allocate regmap field = %d\n", i);\r\nreturn PTR_ERR(info->regmap_fields[i]);\r\n}\r\n}\r\nret = rt9455_discover_charger(info, &ichrg, &ieoc_percentage,\r\n&mivr, &iaicr);\r\nif (ret) {\r\ndev_err(dev, "Failed to discover charger\n");\r\nreturn ret;\r\n}\r\n#if IS_ENABLED(CONFIG_USB_PHY)\r\ninfo->usb_phy = devm_usb_get_phy(dev, USB_PHY_TYPE_USB2);\r\nif (IS_ERR(info->usb_phy)) {\r\ndev_err(dev, "Failed to get USB transceiver\n");\r\n} else {\r\ninfo->nb.notifier_call = rt9455_usb_event;\r\nret = usb_register_notifier(info->usb_phy, &info->nb);\r\nif (ret) {\r\ndev_err(dev, "Failed to register USB notifier\n");\r\ninfo->nb.notifier_call = NULL;\r\n}\r\n}\r\n#endif\r\nINIT_DEFERRABLE_WORK(&info->pwr_rdy_work, rt9455_pwr_rdy_work_callback);\r\nINIT_DEFERRABLE_WORK(&info->max_charging_time_work,\r\nrt9455_max_charging_time_work_callback);\r\nINIT_DEFERRABLE_WORK(&info->batt_presence_work,\r\nrt9455_batt_presence_work_callback);\r\nrt9455_charger_config.of_node = dev->of_node;\r\nrt9455_charger_config.drv_data = info;\r\nrt9455_charger_config.supplied_to = rt9455_charger_supplied_to;\r\nrt9455_charger_config.num_supplicants =\r\nARRAY_SIZE(rt9455_charger_supplied_to);\r\nret = devm_request_threaded_irq(dev, client->irq, NULL,\r\nrt9455_irq_handler_thread,\r\nIRQF_TRIGGER_LOW | IRQF_ONESHOT,\r\nRT9455_DRIVER_NAME, info);\r\nif (ret) {\r\ndev_err(dev, "Failed to register IRQ handler\n");\r\ngoto put_usb_notifier;\r\n}\r\nret = rt9455_hw_init(info, ichrg, ieoc_percentage, mivr, iaicr);\r\nif (ret) {\r\ndev_err(dev, "Failed to set charger to its default values\n");\r\ngoto put_usb_notifier;\r\n}\r\ninfo->charger = devm_power_supply_register(dev, &rt9455_charger_desc,\r\n&rt9455_charger_config);\r\nif (IS_ERR(info->charger)) {\r\ndev_err(dev, "Failed to register charger\n");\r\nret = PTR_ERR(info->charger);\r\ngoto put_usb_notifier;\r\n}\r\nreturn 0;\r\nput_usb_notifier:\r\n#if IS_ENABLED(CONFIG_USB_PHY)\r\nif (info->nb.notifier_call) {\r\nusb_unregister_notifier(info->usb_phy, &info->nb);\r\ninfo->nb.notifier_call = NULL;\r\n}\r\n#endif\r\nreturn ret;\r\n}\r\nstatic int rt9455_remove(struct i2c_client *client)\r\n{\r\nint ret;\r\nstruct rt9455_info *info = i2c_get_clientdata(client);\r\nret = rt9455_register_reset(info);\r\nif (ret)\r\ndev_err(&info->client->dev, "Failed to set charger to its default values\n");\r\n#if IS_ENABLED(CONFIG_USB_PHY)\r\nif (info->nb.notifier_call)\r\nusb_unregister_notifier(info->usb_phy, &info->nb);\r\n#endif\r\ncancel_delayed_work_sync(&info->pwr_rdy_work);\r\ncancel_delayed_work_sync(&info->max_charging_time_work);\r\ncancel_delayed_work_sync(&info->batt_presence_work);\r\nreturn ret;\r\n}
