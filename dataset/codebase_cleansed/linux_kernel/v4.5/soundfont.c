static void\r\nlock_preset(struct snd_sf_list *sflist)\r\n{\r\nunsigned long flags;\r\nmutex_lock(&sflist->presets_mutex);\r\nspin_lock_irqsave(&sflist->lock, flags);\r\nsflist->presets_locked = 1;\r\nspin_unlock_irqrestore(&sflist->lock, flags);\r\n}\r\nstatic void\r\nunlock_preset(struct snd_sf_list *sflist)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&sflist->lock, flags);\r\nsflist->presets_locked = 0;\r\nspin_unlock_irqrestore(&sflist->lock, flags);\r\nmutex_unlock(&sflist->presets_mutex);\r\n}\r\nint\r\nsnd_soundfont_close_check(struct snd_sf_list *sflist, int client)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&sflist->lock, flags);\r\nif (sflist->open_client == client) {\r\nspin_unlock_irqrestore(&sflist->lock, flags);\r\nreturn close_patch(sflist);\r\n}\r\nspin_unlock_irqrestore(&sflist->lock, flags);\r\nreturn 0;\r\n}\r\nint\r\nsnd_soundfont_load(struct snd_sf_list *sflist, const void __user *data,\r\nlong count, int client)\r\n{\r\nstruct soundfont_patch_info patch;\r\nunsigned long flags;\r\nint rc;\r\nif (count < (long)sizeof(patch)) {\r\nsnd_printk(KERN_ERR "patch record too small %ld\n", count);\r\nreturn -EINVAL;\r\n}\r\nif (copy_from_user(&patch, data, sizeof(patch)))\r\nreturn -EFAULT;\r\ncount -= sizeof(patch);\r\ndata += sizeof(patch);\r\nif (patch.key != SNDRV_OSS_SOUNDFONT_PATCH) {\r\nsnd_printk(KERN_ERR "The wrong kind of patch %x\n", patch.key);\r\nreturn -EINVAL;\r\n}\r\nif (count < patch.len) {\r\nsnd_printk(KERN_ERR "Patch too short %ld, need %d\n",\r\ncount, patch.len);\r\nreturn -EINVAL;\r\n}\r\nif (patch.len < 0) {\r\nsnd_printk(KERN_ERR "poor length %d\n", patch.len);\r\nreturn -EINVAL;\r\n}\r\nif (patch.type == SNDRV_SFNT_OPEN_PATCH) {\r\nlock_preset(sflist);\r\nrc = open_patch(sflist, data, count, client);\r\nunlock_preset(sflist);\r\nreturn rc;\r\n}\r\nspin_lock_irqsave(&sflist->lock, flags);\r\nif (sflist->open_client != client) {\r\nspin_unlock_irqrestore(&sflist->lock, flags);\r\nreturn -EBUSY;\r\n}\r\nspin_unlock_irqrestore(&sflist->lock, flags);\r\nlock_preset(sflist);\r\nrc = -EINVAL;\r\nswitch (patch.type) {\r\ncase SNDRV_SFNT_LOAD_INFO:\r\nrc = load_info(sflist, data, count);\r\nbreak;\r\ncase SNDRV_SFNT_LOAD_DATA:\r\nrc = load_data(sflist, data, count);\r\nbreak;\r\ncase SNDRV_SFNT_CLOSE_PATCH:\r\nrc = close_patch(sflist);\r\nbreak;\r\ncase SNDRV_SFNT_REPLACE_DATA:\r\nbreak;\r\ncase SNDRV_SFNT_MAP_PRESET:\r\nrc = load_map(sflist, data, count);\r\nbreak;\r\ncase SNDRV_SFNT_PROBE_DATA:\r\nrc = probe_data(sflist, patch.optarg);\r\nbreak;\r\ncase SNDRV_SFNT_REMOVE_INFO:\r\nif (!sflist->currsf) {\r\nsnd_printk(KERN_ERR "soundfont: remove_info: "\r\n"patch not opened\n");\r\nrc = -EINVAL;\r\n} else {\r\nint bank, instr;\r\nbank = ((unsigned short)patch.optarg >> 8) & 0xff;\r\ninstr = (unsigned short)patch.optarg & 0xff;\r\nif (! remove_info(sflist, sflist->currsf, bank, instr))\r\nrc = -EINVAL;\r\nelse\r\nrc = 0;\r\n}\r\nbreak;\r\n}\r\nunlock_preset(sflist);\r\nreturn rc;\r\n}\r\nstatic inline int\r\nis_special_type(int type)\r\n{\r\ntype &= 0x0f;\r\nreturn (type == SNDRV_SFNT_PAT_TYPE_GUS ||\r\ntype == SNDRV_SFNT_PAT_TYPE_MAP);\r\n}\r\nstatic int\r\nopen_patch(struct snd_sf_list *sflist, const char __user *data,\r\nint count, int client)\r\n{\r\nstruct soundfont_open_parm parm;\r\nstruct snd_soundfont *sf;\r\nunsigned long flags;\r\nspin_lock_irqsave(&sflist->lock, flags);\r\nif (sflist->open_client >= 0 || sflist->currsf) {\r\nspin_unlock_irqrestore(&sflist->lock, flags);\r\nreturn -EBUSY;\r\n}\r\nspin_unlock_irqrestore(&sflist->lock, flags);\r\nif (copy_from_user(&parm, data, sizeof(parm)))\r\nreturn -EFAULT;\r\nif (is_special_type(parm.type)) {\r\nparm.type |= SNDRV_SFNT_PAT_SHARED;\r\nsf = newsf(sflist, parm.type, NULL);\r\n} else\r\nsf = newsf(sflist, parm.type, parm.name);\r\nif (sf == NULL) {\r\nreturn -ENOMEM;\r\n}\r\nspin_lock_irqsave(&sflist->lock, flags);\r\nsflist->open_client = client;\r\nsflist->currsf = sf;\r\nspin_unlock_irqrestore(&sflist->lock, flags);\r\nreturn 0;\r\n}\r\nstatic struct snd_soundfont *\r\nnewsf(struct snd_sf_list *sflist, int type, char *name)\r\n{\r\nstruct snd_soundfont *sf;\r\nif (type & SNDRV_SFNT_PAT_SHARED) {\r\nfor (sf = sflist->fonts; sf; sf = sf->next) {\r\nif (is_identical_font(sf, type, name)) {\r\nreturn sf;\r\n}\r\n}\r\n}\r\nsf = kzalloc(sizeof(*sf), GFP_KERNEL);\r\nif (sf == NULL)\r\nreturn NULL;\r\nsf->id = sflist->fonts_size;\r\nsflist->fonts_size++;\r\nsf->next = sflist->fonts;\r\nsflist->fonts = sf;\r\nsf->type = type;\r\nsf->zones = NULL;\r\nsf->samples = NULL;\r\nif (name)\r\nmemcpy(sf->name, name, SNDRV_SFNT_PATCH_NAME_LEN);\r\nreturn sf;\r\n}\r\nstatic int\r\nis_identical_font(struct snd_soundfont *sf, int type, unsigned char *name)\r\n{\r\nreturn ((sf->type & SNDRV_SFNT_PAT_SHARED) &&\r\n(sf->type & 0x0f) == (type & 0x0f) &&\r\n(name == NULL ||\r\nmemcmp(sf->name, name, SNDRV_SFNT_PATCH_NAME_LEN) == 0));\r\n}\r\nstatic int\r\nclose_patch(struct snd_sf_list *sflist)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&sflist->lock, flags);\r\nsflist->currsf = NULL;\r\nsflist->open_client = -1;\r\nspin_unlock_irqrestore(&sflist->lock, flags);\r\nrebuild_presets(sflist);\r\nreturn 0;\r\n}\r\nstatic int\r\nprobe_data(struct snd_sf_list *sflist, int sample_id)\r\n{\r\nif (sflist->currsf) {\r\nif (find_sample(sflist->currsf, sample_id))\r\nreturn 0;\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic void\r\nset_zone_counter(struct snd_sf_list *sflist, struct snd_soundfont *sf,\r\nstruct snd_sf_zone *zp)\r\n{\r\nzp->counter = sflist->zone_counter++;\r\nif (sf->type & SNDRV_SFNT_PAT_LOCKED)\r\nsflist->zone_locked = sflist->zone_counter;\r\n}\r\nstatic struct snd_sf_zone *\r\nsf_zone_new(struct snd_sf_list *sflist, struct snd_soundfont *sf)\r\n{\r\nstruct snd_sf_zone *zp;\r\nif ((zp = kzalloc(sizeof(*zp), GFP_KERNEL)) == NULL)\r\nreturn NULL;\r\nzp->next = sf->zones;\r\nsf->zones = zp;\r\ninit_voice_info(&zp->v);\r\nset_zone_counter(sflist, sf, zp);\r\nreturn zp;\r\n}\r\nstatic void\r\nset_sample_counter(struct snd_sf_list *sflist, struct snd_soundfont *sf,\r\nstruct snd_sf_sample *sp)\r\n{\r\nsp->counter = sflist->sample_counter++;\r\nif (sf->type & SNDRV_SFNT_PAT_LOCKED)\r\nsflist->sample_locked = sflist->sample_counter;\r\n}\r\nstatic struct snd_sf_sample *\r\nsf_sample_new(struct snd_sf_list *sflist, struct snd_soundfont *sf)\r\n{\r\nstruct snd_sf_sample *sp;\r\nif ((sp = kzalloc(sizeof(*sp), GFP_KERNEL)) == NULL)\r\nreturn NULL;\r\nsp->next = sf->samples;\r\nsf->samples = sp;\r\nset_sample_counter(sflist, sf, sp);\r\nreturn sp;\r\n}\r\nstatic void\r\nsf_sample_delete(struct snd_sf_list *sflist, struct snd_soundfont *sf,\r\nstruct snd_sf_sample *sp)\r\n{\r\nif (sp == sf->samples) {\r\nsf->samples = sp->next;\r\nkfree(sp);\r\n}\r\n}\r\nstatic int\r\nload_map(struct snd_sf_list *sflist, const void __user *data, int count)\r\n{\r\nstruct snd_sf_zone *zp, *prevp;\r\nstruct snd_soundfont *sf;\r\nstruct soundfont_voice_map map;\r\nif (count < (int)sizeof(map))\r\nreturn -EINVAL;\r\nif (copy_from_user(&map, data, sizeof(map)))\r\nreturn -EFAULT;\r\nif (map.map_instr < 0 || map.map_instr >= SF_MAX_INSTRUMENTS)\r\nreturn -EINVAL;\r\nsf = newsf(sflist, SNDRV_SFNT_PAT_TYPE_MAP|SNDRV_SFNT_PAT_SHARED, NULL);\r\nif (sf == NULL)\r\nreturn -ENOMEM;\r\nprevp = NULL;\r\nfor (zp = sf->zones; zp; prevp = zp, zp = zp->next) {\r\nif (zp->mapped &&\r\nzp->instr == map.map_instr &&\r\nzp->bank == map.map_bank &&\r\nzp->v.low == map.map_key &&\r\nzp->v.start == map.src_instr &&\r\nzp->v.end == map.src_bank &&\r\nzp->v.fixkey == map.src_key) {\r\nif (prevp) {\r\nprevp->next = zp->next;\r\nzp->next = sf->zones;\r\nsf->zones = zp;\r\n}\r\nset_zone_counter(sflist, sf, zp);\r\nreturn 0;\r\n}\r\n}\r\nif ((zp = sf_zone_new(sflist, sf)) == NULL)\r\nreturn -ENOMEM;\r\nzp->bank = map.map_bank;\r\nzp->instr = map.map_instr;\r\nzp->mapped = 1;\r\nif (map.map_key >= 0) {\r\nzp->v.low = map.map_key;\r\nzp->v.high = map.map_key;\r\n}\r\nzp->v.start = map.src_instr;\r\nzp->v.end = map.src_bank;\r\nzp->v.fixkey = map.src_key;\r\nzp->v.sf_id = sf->id;\r\nadd_preset(sflist, zp);\r\nreturn 0;\r\n}\r\nstatic int\r\nremove_info(struct snd_sf_list *sflist, struct snd_soundfont *sf,\r\nint bank, int instr)\r\n{\r\nstruct snd_sf_zone *prev, *next, *p;\r\nint removed = 0;\r\nprev = NULL;\r\nfor (p = sf->zones; p; p = next) {\r\nnext = p->next;\r\nif (! p->mapped &&\r\np->bank == bank && p->instr == instr) {\r\nif (prev)\r\nprev->next = next;\r\nelse\r\nsf->zones = next;\r\nremoved++;\r\nkfree(p);\r\n} else\r\nprev = p;\r\n}\r\nif (removed)\r\nrebuild_presets(sflist);\r\nreturn removed;\r\n}\r\nstatic int\r\nload_info(struct snd_sf_list *sflist, const void __user *data, long count)\r\n{\r\nstruct snd_soundfont *sf;\r\nstruct snd_sf_zone *zone;\r\nstruct soundfont_voice_rec_hdr hdr;\r\nint i;\r\nif ((sf = sflist->currsf) == NULL)\r\nreturn -EINVAL;\r\nif (is_special_type(sf->type))\r\nreturn -EINVAL;\r\nif (count < (long)sizeof(hdr)) {\r\nprintk(KERN_ERR "Soundfont error: invalid patch zone length\n");\r\nreturn -EINVAL;\r\n}\r\nif (copy_from_user((char*)&hdr, data, sizeof(hdr)))\r\nreturn -EFAULT;\r\ndata += sizeof(hdr);\r\ncount -= sizeof(hdr);\r\nif (hdr.nvoices <= 0 || hdr.nvoices >= 100) {\r\nprintk(KERN_ERR "Soundfont error: Illegal voice number %d\n",\r\nhdr.nvoices);\r\nreturn -EINVAL;\r\n}\r\nif (count < (long)sizeof(struct soundfont_voice_info) * hdr.nvoices) {\r\nprintk(KERN_ERR "Soundfont Error: "\r\n"patch length(%ld) is smaller than nvoices(%d)\n",\r\ncount, hdr.nvoices);\r\nreturn -EINVAL;\r\n}\r\nswitch (hdr.write_mode) {\r\ncase SNDRV_SFNT_WR_EXCLUSIVE:\r\nfor (zone = sf->zones; zone; zone = zone->next) {\r\nif (!zone->mapped &&\r\nzone->bank == hdr.bank &&\r\nzone->instr == hdr.instr)\r\nreturn -EINVAL;\r\n}\r\nbreak;\r\ncase SNDRV_SFNT_WR_REPLACE:\r\nremove_info(sflist, sf, hdr.bank, hdr.instr);\r\nbreak;\r\n}\r\nfor (i = 0; i < hdr.nvoices; i++) {\r\nstruct snd_sf_zone tmpzone;\r\nif (copy_from_user(&tmpzone.v, data, sizeof(tmpzone.v))) {\r\nreturn -EFAULT;\r\n}\r\ndata += sizeof(tmpzone.v);\r\ncount -= sizeof(tmpzone.v);\r\ntmpzone.bank = hdr.bank;\r\ntmpzone.instr = hdr.instr;\r\ntmpzone.mapped = 0;\r\ntmpzone.v.sf_id = sf->id;\r\nif (tmpzone.v.mode & SNDRV_SFNT_MODE_INIT_PARM)\r\ninit_voice_parm(&tmpzone.v.parm);\r\nif ((zone = sf_zone_new(sflist, sf)) == NULL) {\r\nreturn -ENOMEM;\r\n}\r\nzone->bank = tmpzone.bank;\r\nzone->instr = tmpzone.instr;\r\nzone->v = tmpzone.v;\r\nzone->sample = set_sample(sf, &zone->v);\r\n}\r\nreturn 0;\r\n}\r\nstatic void\r\ninit_voice_info(struct soundfont_voice_info *avp)\r\n{\r\nmemset(avp, 0, sizeof(*avp));\r\navp->root = 60;\r\navp->high = 127;\r\navp->velhigh = 127;\r\navp->fixkey = -1;\r\navp->fixvel = -1;\r\navp->fixpan = -1;\r\navp->pan = -1;\r\navp->amplitude = 127;\r\navp->scaleTuning = 100;\r\ninit_voice_parm(&avp->parm);\r\n}\r\nstatic void\r\ninit_voice_parm(struct soundfont_voice_parm *pp)\r\n{\r\nmemset(pp, 0, sizeof(*pp));\r\npp->moddelay = 0x8000;\r\npp->modatkhld = 0x7f7f;\r\npp->moddcysus = 0x7f7f;\r\npp->modrelease = 0x807f;\r\npp->voldelay = 0x8000;\r\npp->volatkhld = 0x7f7f;\r\npp->voldcysus = 0x7f7f;\r\npp->volrelease = 0x807f;\r\npp->lfo1delay = 0x8000;\r\npp->lfo2delay = 0x8000;\r\npp->cutoff = 0xff;\r\n}\r\nstatic struct snd_sf_sample *\r\nset_sample(struct snd_soundfont *sf, struct soundfont_voice_info *avp)\r\n{\r\nstruct snd_sf_sample *sample;\r\nsample = find_sample(sf, avp->sample);\r\nif (sample == NULL)\r\nreturn NULL;\r\navp->start += sample->v.start;\r\navp->end += sample->v.end;\r\navp->loopstart += sample->v.loopstart;\r\navp->loopend += sample->v.loopend;\r\navp->sample_mode = sample->v.mode_flags;\r\nreturn sample;\r\n}\r\nstatic struct snd_sf_sample *\r\nfind_sample(struct snd_soundfont *sf, int sample_id)\r\n{\r\nstruct snd_sf_sample *p;\r\nif (sf == NULL)\r\nreturn NULL;\r\nfor (p = sf->samples; p; p = p->next) {\r\nif (p->v.sample == sample_id)\r\nreturn p;\r\n}\r\nreturn NULL;\r\n}\r\nstatic int\r\nload_data(struct snd_sf_list *sflist, const void __user *data, long count)\r\n{\r\nstruct snd_soundfont *sf;\r\nstruct soundfont_sample_info sample_info;\r\nstruct snd_sf_sample *sp;\r\nlong off;\r\nif ((sf = sflist->currsf) == NULL)\r\nreturn -EINVAL;\r\nif (is_special_type(sf->type))\r\nreturn -EINVAL;\r\nif (copy_from_user(&sample_info, data, sizeof(sample_info)))\r\nreturn -EFAULT;\r\noff = sizeof(sample_info);\r\nif (sample_info.size != (count-off)/2)\r\nreturn -EINVAL;\r\nif (find_sample(sf, sample_info.sample)) {\r\nif (sf->type & SNDRV_SFNT_PAT_SHARED)\r\nreturn 0;\r\nreturn -EINVAL;\r\n}\r\nif ((sp = sf_sample_new(sflist, sf)) == NULL)\r\nreturn -ENOMEM;\r\nsp->v = sample_info;\r\nsp->v.sf_id = sf->id;\r\nsp->v.dummy = 0;\r\nsp->v.truesize = sp->v.size;\r\nif (sp->v.size > 0) {\r\nint rc;\r\nrc = sflist->callback.sample_new\r\n(sflist->callback.private_data, sp, sflist->memhdr,\r\ndata + off, count - off);\r\nif (rc < 0) {\r\nsf_sample_delete(sflist, sf, sp);\r\nreturn rc;\r\n}\r\nsflist->mem_used += sp->v.truesize;\r\n}\r\nreturn count;\r\n}\r\nint\r\nsnd_sf_linear_to_log(unsigned int amount, int offset, int ratio)\r\n{\r\nint v;\r\nint s, low, bit;\r\nif (amount < 2)\r\nreturn 0;\r\nfor (bit = 0; ! (amount & 0x80000000L); bit++)\r\namount <<= 1;\r\ns = (amount >> 24) & 0x7f;\r\nlow = (amount >> 16) & 0xff;\r\nv = (log_tbl[s + 1] * low + log_tbl[s] * (0x100 - low)) >> 8;\r\nv -= offset;\r\nv = (v * ratio) >> 16;\r\nv += (24 - bit) * ratio;\r\nreturn v;\r\n}\r\nstatic int\r\nfreq_to_note(int mhz)\r\n{\r\nreturn snd_sf_linear_to_log(mhz, OFFSET_ABSCENT, ABSCENT_RATIO);\r\n}\r\nstatic int\r\ncalc_rate_offset(int hz)\r\n{\r\nreturn snd_sf_linear_to_log(hz, OFFSET_SAMPLERATE, SAMPLERATE_RATIO);\r\n}\r\nstatic int\r\ncalc_gus_envelope_time(int rate, int start, int end)\r\n{\r\nint r, p, t;\r\nr = (3 - ((rate >> 6) & 3)) * 3;\r\np = rate & 0x3f;\r\nt = end - start;\r\nif (t < 0) t = -t;\r\nif (13 > r)\r\nt = t << (13 - r);\r\nelse\r\nt = t >> (r - 13);\r\nreturn (t * 10) / (p * 441);\r\n}\r\nint\r\nsnd_sf_calc_parm_hold(int msec)\r\n{\r\nint val = (0x7f * 92 - msec) / 92;\r\nif (val < 1) val = 1;\r\nif (val >= 126) val = 126;\r\nreturn val;\r\n}\r\nstatic int\r\ncalc_parm_search(int msec, short *table)\r\n{\r\nint left = 1, right = 127, mid;\r\nwhile (left < right) {\r\nmid = (left + right) / 2;\r\nif (msec < (int)table[mid])\r\nleft = mid + 1;\r\nelse\r\nright = mid;\r\n}\r\nreturn left;\r\n}\r\nint\r\nsnd_sf_calc_parm_attack(int msec)\r\n{\r\nreturn calc_parm_search(msec, attack_time_tbl);\r\n}\r\nint\r\nsnd_sf_calc_parm_decay(int msec)\r\n{\r\nreturn calc_parm_search(msec, decay_time_tbl);\r\n}\r\nstatic int\r\nload_guspatch(struct snd_sf_list *sflist, const char __user *data,\r\nlong count, int client)\r\n{\r\nstruct patch_info patch;\r\nstruct snd_soundfont *sf;\r\nstruct snd_sf_zone *zone;\r\nstruct snd_sf_sample *smp;\r\nint note, sample_id;\r\nint rc;\r\nif (count < (long)sizeof(patch)) {\r\nsnd_printk(KERN_ERR "patch record too small %ld\n", count);\r\nreturn -EINVAL;\r\n}\r\nif (copy_from_user(&patch, data, sizeof(patch)))\r\nreturn -EFAULT;\r\ncount -= sizeof(patch);\r\ndata += sizeof(patch);\r\nsf = newsf(sflist, SNDRV_SFNT_PAT_TYPE_GUS|SNDRV_SFNT_PAT_SHARED, NULL);\r\nif (sf == NULL)\r\nreturn -ENOMEM;\r\nif ((smp = sf_sample_new(sflist, sf)) == NULL)\r\nreturn -ENOMEM;\r\nsample_id = sflist->sample_counter;\r\nsmp->v.sample = sample_id;\r\nsmp->v.start = 0;\r\nsmp->v.end = patch.len;\r\nsmp->v.loopstart = patch.loop_start;\r\nsmp->v.loopend = patch.loop_end;\r\nsmp->v.size = patch.len;\r\nsmp->v.mode_flags = 0;\r\nif (!(patch.mode & WAVE_16_BITS))\r\nsmp->v.mode_flags |= SNDRV_SFNT_SAMPLE_8BITS;\r\nif (patch.mode & WAVE_UNSIGNED)\r\nsmp->v.mode_flags |= SNDRV_SFNT_SAMPLE_UNSIGNED;\r\nsmp->v.mode_flags |= SNDRV_SFNT_SAMPLE_NO_BLANK;\r\nif (!(patch.mode & (WAVE_LOOPING|WAVE_BIDIR_LOOP|WAVE_LOOP_BACK)))\r\nsmp->v.mode_flags |= SNDRV_SFNT_SAMPLE_SINGLESHOT;\r\nif (patch.mode & WAVE_BIDIR_LOOP)\r\nsmp->v.mode_flags |= SNDRV_SFNT_SAMPLE_BIDIR_LOOP;\r\nif (patch.mode & WAVE_LOOP_BACK)\r\nsmp->v.mode_flags |= SNDRV_SFNT_SAMPLE_REVERSE_LOOP;\r\nif (patch.mode & WAVE_16_BITS) {\r\nsmp->v.size /= 2;\r\nsmp->v.end /= 2;\r\nsmp->v.loopstart /= 2;\r\nsmp->v.loopend /= 2;\r\n}\r\nsmp->v.dummy = 0;\r\nsmp->v.truesize = 0;\r\nsmp->v.sf_id = sf->id;\r\nif ((zone = sf_zone_new(sflist, sf)) == NULL) {\r\nsf_sample_delete(sflist, sf, smp);\r\nreturn -ENOMEM;\r\n}\r\nif (sflist->callback.sample_new) {\r\nrc = sflist->callback.sample_new\r\n(sflist->callback.private_data, smp, sflist->memhdr,\r\ndata, count);\r\nif (rc < 0) {\r\nsf_sample_delete(sflist, sf, smp);\r\nkfree(zone);\r\nreturn rc;\r\n}\r\n}\r\nsflist->mem_used += smp->v.truesize;\r\nzone->v.sample = sample_id;\r\nzone->v.rate_offset = calc_rate_offset(patch.base_freq);\r\nnote = freq_to_note(patch.base_note);\r\nzone->v.root = note / 100;\r\nzone->v.tune = -(note % 100);\r\nzone->v.low = (freq_to_note(patch.low_note) + 99) / 100;\r\nzone->v.high = freq_to_note(patch.high_note) / 100;\r\nzone->v.pan = (patch.panning + 128) / 2;\r\n#if 0\r\nsnd_printk(KERN_DEBUG\r\n"gus: basefrq=%d (ofs=%d) root=%d,tune=%d, range:%d-%d\n",\r\n(int)patch.base_freq, zone->v.rate_offset,\r\nzone->v.root, zone->v.tune, zone->v.low, zone->v.high);\r\n#endif\r\nif (patch.mode & WAVE_ENVELOPES) {\r\nint attack, hold, decay, release;\r\nattack = calc_gus_envelope_time\r\n(patch.env_rate[0], 0, patch.env_offset[0]);\r\nhold = calc_gus_envelope_time\r\n(patch.env_rate[1], patch.env_offset[0],\r\npatch.env_offset[1]);\r\ndecay = calc_gus_envelope_time\r\n(patch.env_rate[2], patch.env_offset[1],\r\npatch.env_offset[2]);\r\nrelease = calc_gus_envelope_time\r\n(patch.env_rate[3], patch.env_offset[1],\r\npatch.env_offset[4]);\r\nrelease += calc_gus_envelope_time\r\n(patch.env_rate[4], patch.env_offset[3],\r\npatch.env_offset[4]);\r\nrelease += calc_gus_envelope_time\r\n(patch.env_rate[5], patch.env_offset[4],\r\npatch.env_offset[5]);\r\nzone->v.parm.volatkhld =\r\n(snd_sf_calc_parm_hold(hold) << 8) |\r\nsnd_sf_calc_parm_attack(attack);\r\nzone->v.parm.voldcysus = (calc_gus_sustain(patch.env_offset[2]) << 8) |\r\nsnd_sf_calc_parm_decay(decay);\r\nzone->v.parm.volrelease = 0x8000 | snd_sf_calc_parm_decay(release);\r\nzone->v.attenuation = calc_gus_attenuation(patch.env_offset[0]);\r\n#if 0\r\nsnd_printk(KERN_DEBUG\r\n"gus: atkhld=%x, dcysus=%x, volrel=%x, att=%d\n",\r\nzone->v.parm.volatkhld,\r\nzone->v.parm.voldcysus,\r\nzone->v.parm.volrelease,\r\nzone->v.attenuation);\r\n#endif\r\n}\r\nif (patch.mode & WAVE_FAST_RELEASE) {\r\nzone->v.parm.volrelease = 0x807f;\r\n}\r\nif (patch.mode & WAVE_TREMOLO) {\r\nint rate = (patch.tremolo_rate * 1000 / 38) / 42;\r\nzone->v.parm.tremfrq = ((patch.tremolo_depth / 2) << 8) | rate;\r\n}\r\nif (patch.mode & WAVE_VIBRATO) {\r\nint rate = (patch.vibrato_rate * 1000 / 38) / 42;\r\nzone->v.parm.fm2frq2 = ((patch.vibrato_depth / 6) << 8) | rate;\r\n}\r\nif (!(smp->v.mode_flags & SNDRV_SFNT_SAMPLE_SINGLESHOT))\r\nzone->v.mode = SNDRV_SFNT_MODE_LOOPING;\r\nelse\r\nzone->v.mode = 0;\r\nzone->bank = 0;\r\nzone->instr = patch.instr_no;\r\nzone->mapped = 0;\r\nzone->v.sf_id = sf->id;\r\nzone->sample = set_sample(sf, &zone->v);\r\nadd_preset(sflist, zone);\r\nreturn 0;\r\n}\r\nint\r\nsnd_soundfont_load_guspatch(struct snd_sf_list *sflist, const char __user *data,\r\nlong count, int client)\r\n{\r\nint rc;\r\nlock_preset(sflist);\r\nrc = load_guspatch(sflist, data, count, client);\r\nunlock_preset(sflist);\r\nreturn rc;\r\n}\r\nstatic void\r\nrebuild_presets(struct snd_sf_list *sflist)\r\n{\r\nstruct snd_soundfont *sf;\r\nstruct snd_sf_zone *cur;\r\nmemset(sflist->presets, 0, sizeof(sflist->presets));\r\nfor (sf = sflist->fonts; sf; sf = sf->next) {\r\nfor (cur = sf->zones; cur; cur = cur->next) {\r\nif (! cur->mapped && cur->sample == NULL) {\r\ncur->sample = set_sample(sf, &cur->v);\r\nif (cur->sample == NULL)\r\ncontinue;\r\n}\r\nadd_preset(sflist, cur);\r\n}\r\n}\r\n}\r\nstatic void\r\nadd_preset(struct snd_sf_list *sflist, struct snd_sf_zone *cur)\r\n{\r\nstruct snd_sf_zone *zone;\r\nint index;\r\nzone = search_first_zone(sflist, cur->bank, cur->instr, cur->v.low);\r\nif (zone && zone->v.sf_id != cur->v.sf_id) {\r\nstruct snd_sf_zone *p;\r\nfor (p = zone; p; p = p->next_zone) {\r\nif (p->counter > cur->counter)\r\nreturn;\r\n}\r\ndelete_preset(sflist, zone);\r\nzone = NULL;\r\n}\r\nif ((index = get_index(cur->bank, cur->instr, cur->v.low)) < 0)\r\nreturn;\r\ncur->next_zone = zone;\r\ncur->next_instr = sflist->presets[index];\r\nsflist->presets[index] = cur;\r\n}\r\nstatic void\r\ndelete_preset(struct snd_sf_list *sflist, struct snd_sf_zone *zp)\r\n{\r\nint index;\r\nstruct snd_sf_zone *p;\r\nif ((index = get_index(zp->bank, zp->instr, zp->v.low)) < 0)\r\nreturn;\r\nfor (p = sflist->presets[index]; p; p = p->next_instr) {\r\nwhile (p->next_instr == zp) {\r\np->next_instr = zp->next_instr;\r\nzp = zp->next_zone;\r\nif (zp == NULL)\r\nreturn;\r\n}\r\n}\r\n}\r\nint\r\nsnd_soundfont_search_zone(struct snd_sf_list *sflist, int *notep, int vel,\r\nint preset, int bank,\r\nint def_preset, int def_bank,\r\nstruct snd_sf_zone **table, int max_layers)\r\n{\r\nint nvoices;\r\nunsigned long flags;\r\nspin_lock_irqsave(&sflist->lock, flags);\r\nif (sflist->presets_locked) {\r\nspin_unlock_irqrestore(&sflist->lock, flags);\r\nreturn 0;\r\n}\r\nnvoices = search_zones(sflist, notep, vel, preset, bank,\r\ntable, max_layers, 0);\r\nif (! nvoices) {\r\nif (preset != def_preset || bank != def_bank)\r\nnvoices = search_zones(sflist, notep, vel,\r\ndef_preset, def_bank,\r\ntable, max_layers, 0);\r\n}\r\nspin_unlock_irqrestore(&sflist->lock, flags);\r\nreturn nvoices;\r\n}\r\nstatic struct snd_sf_zone *\r\nsearch_first_zone(struct snd_sf_list *sflist, int bank, int preset, int key)\r\n{\r\nint index;\r\nstruct snd_sf_zone *zp;\r\nif ((index = get_index(bank, preset, key)) < 0)\r\nreturn NULL;\r\nfor (zp = sflist->presets[index]; zp; zp = zp->next_instr) {\r\nif (zp->instr == preset && zp->bank == bank)\r\nreturn zp;\r\n}\r\nreturn NULL;\r\n}\r\nstatic int\r\nsearch_zones(struct snd_sf_list *sflist, int *notep, int vel,\r\nint preset, int bank, struct snd_sf_zone **table,\r\nint max_layers, int level)\r\n{\r\nstruct snd_sf_zone *zp;\r\nint nvoices;\r\nzp = search_first_zone(sflist, bank, preset, *notep);\r\nnvoices = 0;\r\nfor (; zp; zp = zp->next_zone) {\r\nif (*notep >= zp->v.low && *notep <= zp->v.high &&\r\nvel >= zp->v.vellow && vel <= zp->v.velhigh) {\r\nif (zp->mapped) {\r\nint key = zp->v.fixkey;\r\npreset = zp->v.start;\r\nbank = zp->v.end;\r\nif (level > 5)\r\nreturn 0;\r\nif (key < 0)\r\nkey = *notep;\r\nnvoices = search_zones(sflist, &key, vel,\r\npreset, bank, table,\r\nmax_layers, level + 1);\r\nif (nvoices > 0)\r\n*notep = key;\r\nbreak;\r\n}\r\ntable[nvoices++] = zp;\r\nif (nvoices >= max_layers)\r\nbreak;\r\n}\r\n}\r\nreturn nvoices;\r\n}\r\nstatic int\r\nget_index(int bank, int instr, int key)\r\n{\r\nint index;\r\nif (SF_IS_DRUM_BANK(bank))\r\nindex = key + SF_MAX_INSTRUMENTS;\r\nelse\r\nindex = instr;\r\nindex = index % SF_MAX_PRESETS;\r\nif (index < 0)\r\nreturn -1;\r\nreturn index;\r\n}\r\nstatic void\r\nsnd_sf_init(struct snd_sf_list *sflist)\r\n{\r\nmemset(sflist->presets, 0, sizeof(sflist->presets));\r\nsflist->mem_used = 0;\r\nsflist->currsf = NULL;\r\nsflist->open_client = -1;\r\nsflist->fonts = NULL;\r\nsflist->fonts_size = 0;\r\nsflist->zone_counter = 0;\r\nsflist->sample_counter = 0;\r\nsflist->zone_locked = 0;\r\nsflist->sample_locked = 0;\r\n}\r\nstatic void\r\nsnd_sf_clear(struct snd_sf_list *sflist)\r\n{\r\nstruct snd_soundfont *sf, *nextsf;\r\nstruct snd_sf_zone *zp, *nextzp;\r\nstruct snd_sf_sample *sp, *nextsp;\r\nfor (sf = sflist->fonts; sf; sf = nextsf) {\r\nnextsf = sf->next;\r\nfor (zp = sf->zones; zp; zp = nextzp) {\r\nnextzp = zp->next;\r\nkfree(zp);\r\n}\r\nfor (sp = sf->samples; sp; sp = nextsp) {\r\nnextsp = sp->next;\r\nif (sflist->callback.sample_free)\r\nsflist->callback.sample_free(sflist->callback.private_data,\r\nsp, sflist->memhdr);\r\nkfree(sp);\r\n}\r\nkfree(sf);\r\n}\r\nsnd_sf_init(sflist);\r\n}\r\nstruct snd_sf_list *\r\nsnd_sf_new(struct snd_sf_callback *callback, struct snd_util_memhdr *hdr)\r\n{\r\nstruct snd_sf_list *sflist;\r\nif ((sflist = kzalloc(sizeof(*sflist), GFP_KERNEL)) == NULL)\r\nreturn NULL;\r\nmutex_init(&sflist->presets_mutex);\r\nspin_lock_init(&sflist->lock);\r\nsflist->memhdr = hdr;\r\nif (callback)\r\nsflist->callback = *callback;\r\nsnd_sf_init(sflist);\r\nreturn sflist;\r\n}\r\nvoid\r\nsnd_sf_free(struct snd_sf_list *sflist)\r\n{\r\nif (sflist == NULL)\r\nreturn;\r\nlock_preset(sflist);\r\nif (sflist->callback.sample_reset)\r\nsflist->callback.sample_reset(sflist->callback.private_data);\r\nsnd_sf_clear(sflist);\r\nunlock_preset(sflist);\r\nkfree(sflist);\r\n}\r\nint\r\nsnd_soundfont_remove_samples(struct snd_sf_list *sflist)\r\n{\r\nlock_preset(sflist);\r\nif (sflist->callback.sample_reset)\r\nsflist->callback.sample_reset(sflist->callback.private_data);\r\nsnd_sf_clear(sflist);\r\nunlock_preset(sflist);\r\nreturn 0;\r\n}\r\nint\r\nsnd_soundfont_remove_unlocked(struct snd_sf_list *sflist)\r\n{\r\nstruct snd_soundfont *sf;\r\nstruct snd_sf_zone *zp, *nextzp;\r\nstruct snd_sf_sample *sp, *nextsp;\r\nlock_preset(sflist);\r\nif (sflist->callback.sample_reset)\r\nsflist->callback.sample_reset(sflist->callback.private_data);\r\nmemset(sflist->presets, 0, sizeof(sflist->presets));\r\nfor (sf = sflist->fonts; sf; sf = sf->next) {\r\nfor (zp = sf->zones; zp; zp = nextzp) {\r\nif (zp->counter < sflist->zone_locked)\r\nbreak;\r\nnextzp = zp->next;\r\nsf->zones = nextzp;\r\nkfree(zp);\r\n}\r\nfor (sp = sf->samples; sp; sp = nextsp) {\r\nif (sp->counter < sflist->sample_locked)\r\nbreak;\r\nnextsp = sp->next;\r\nsf->samples = nextsp;\r\nsflist->mem_used -= sp->v.truesize;\r\nif (sflist->callback.sample_free)\r\nsflist->callback.sample_free(sflist->callback.private_data,\r\nsp, sflist->memhdr);\r\nkfree(sp);\r\n}\r\n}\r\nsflist->zone_counter = sflist->zone_locked;\r\nsflist->sample_counter = sflist->sample_locked;\r\nrebuild_presets(sflist);\r\nunlock_preset(sflist);\r\nreturn 0;\r\n}
