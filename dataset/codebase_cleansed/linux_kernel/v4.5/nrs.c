static int nrs_policy_init(struct ptlrpc_nrs_policy *policy)\r\n{\r\nreturn policy->pol_desc->pd_ops->op_policy_init != NULL ?\r\npolicy->pol_desc->pd_ops->op_policy_init(policy) : 0;\r\n}\r\nstatic void nrs_policy_fini(struct ptlrpc_nrs_policy *policy)\r\n{\r\nLASSERT(policy->pol_ref == 0);\r\nLASSERT(policy->pol_req_queued == 0);\r\nif (policy->pol_desc->pd_ops->op_policy_fini != NULL)\r\npolicy->pol_desc->pd_ops->op_policy_fini(policy);\r\n}\r\nstatic int nrs_policy_ctl_locked(struct ptlrpc_nrs_policy *policy,\r\nenum ptlrpc_nrs_ctl opc, void *arg)\r\n{\r\nif (policy->pol_state == NRS_POL_STATE_STOPPED)\r\nreturn -ENODEV;\r\nreturn policy->pol_desc->pd_ops->op_policy_ctl != NULL ?\r\npolicy->pol_desc->pd_ops->op_policy_ctl(policy, opc, arg) :\r\n-ENOSYS;\r\n}\r\nstatic void nrs_policy_stop0(struct ptlrpc_nrs_policy *policy)\r\n{\r\nstruct ptlrpc_nrs *nrs = policy->pol_nrs;\r\nif (policy->pol_desc->pd_ops->op_policy_stop != NULL) {\r\nspin_unlock(&nrs->nrs_lock);\r\npolicy->pol_desc->pd_ops->op_policy_stop(policy);\r\nspin_lock(&nrs->nrs_lock);\r\n}\r\nLASSERT(list_empty(&policy->pol_list_queued));\r\nLASSERT(policy->pol_req_queued == 0 &&\r\npolicy->pol_req_started == 0);\r\npolicy->pol_private = NULL;\r\npolicy->pol_state = NRS_POL_STATE_STOPPED;\r\nif (atomic_dec_and_test(&policy->pol_desc->pd_refs))\r\nmodule_put(policy->pol_desc->pd_owner);\r\n}\r\nstatic int nrs_policy_stop_locked(struct ptlrpc_nrs_policy *policy)\r\n{\r\nstruct ptlrpc_nrs *nrs = policy->pol_nrs;\r\nif (nrs->nrs_policy_fallback == policy && !nrs->nrs_stopping)\r\nreturn -EPERM;\r\nif (policy->pol_state == NRS_POL_STATE_STARTING)\r\nreturn -EAGAIN;\r\nif (policy->pol_state != NRS_POL_STATE_STARTED)\r\nreturn 0;\r\npolicy->pol_state = NRS_POL_STATE_STOPPING;\r\nif (nrs->nrs_policy_primary == policy) {\r\nnrs->nrs_policy_primary = NULL;\r\n} else {\r\nLASSERT(nrs->nrs_policy_fallback == policy);\r\nnrs->nrs_policy_fallback = NULL;\r\n}\r\nif (policy->pol_ref == 1)\r\nnrs_policy_stop0(policy);\r\nreturn 0;\r\n}\r\nstatic void nrs_policy_stop_primary(struct ptlrpc_nrs *nrs)\r\n{\r\nstruct ptlrpc_nrs_policy *tmp = nrs->nrs_policy_primary;\r\nif (tmp == NULL)\r\nreturn;\r\nnrs->nrs_policy_primary = NULL;\r\nLASSERT(tmp->pol_state == NRS_POL_STATE_STARTED);\r\ntmp->pol_state = NRS_POL_STATE_STOPPING;\r\nif (tmp->pol_ref == 0)\r\nnrs_policy_stop0(tmp);\r\n}\r\nstatic int nrs_policy_start_locked(struct ptlrpc_nrs_policy *policy)\r\n{\r\nstruct ptlrpc_nrs *nrs = policy->pol_nrs;\r\nint rc = 0;\r\nif (nrs->nrs_policy_starting)\r\nreturn -EAGAIN;\r\nLASSERT(policy->pol_state != NRS_POL_STATE_STARTING);\r\nif (policy->pol_state == NRS_POL_STATE_STOPPING)\r\nreturn -EAGAIN;\r\nif (policy->pol_flags & PTLRPC_NRS_FL_FALLBACK) {\r\nif (policy == nrs->nrs_policy_fallback) {\r\nnrs_policy_stop_primary(nrs);\r\nreturn 0;\r\n}\r\nLASSERT(nrs->nrs_policy_fallback == NULL);\r\n} else {\r\nif (nrs->nrs_policy_fallback == NULL)\r\nreturn -EPERM;\r\nif (policy->pol_state == NRS_POL_STATE_STARTED)\r\nreturn 0;\r\n}\r\nif (atomic_inc_return(&policy->pol_desc->pd_refs) == 1 &&\r\n!try_module_get(policy->pol_desc->pd_owner)) {\r\natomic_dec(&policy->pol_desc->pd_refs);\r\nCERROR("NRS: cannot get module for policy %s; is it alive?\n",\r\npolicy->pol_desc->pd_name);\r\nreturn -ENODEV;\r\n}\r\nnrs->nrs_policy_starting = 1;\r\npolicy->pol_state = NRS_POL_STATE_STARTING;\r\nif (policy->pol_desc->pd_ops->op_policy_start) {\r\nspin_unlock(&nrs->nrs_lock);\r\nrc = policy->pol_desc->pd_ops->op_policy_start(policy);\r\nspin_lock(&nrs->nrs_lock);\r\nif (rc != 0) {\r\nif (atomic_dec_and_test(&policy->pol_desc->pd_refs))\r\nmodule_put(policy->pol_desc->pd_owner);\r\npolicy->pol_state = NRS_POL_STATE_STOPPED;\r\ngoto out;\r\n}\r\n}\r\npolicy->pol_state = NRS_POL_STATE_STARTED;\r\nif (policy->pol_flags & PTLRPC_NRS_FL_FALLBACK) {\r\nnrs->nrs_policy_fallback = policy;\r\n} else {\r\nnrs_policy_stop_primary(nrs);\r\nnrs->nrs_policy_primary = policy;\r\n}\r\nout:\r\nnrs->nrs_policy_starting = 0;\r\nreturn rc;\r\n}\r\nstatic inline void nrs_policy_get_locked(struct ptlrpc_nrs_policy *policy)\r\n{\r\npolicy->pol_ref++;\r\n}\r\nstatic void nrs_policy_put_locked(struct ptlrpc_nrs_policy *policy)\r\n{\r\nLASSERT(policy->pol_ref > 0);\r\npolicy->pol_ref--;\r\nif (unlikely(policy->pol_ref == 0 &&\r\npolicy->pol_state == NRS_POL_STATE_STOPPING))\r\nnrs_policy_stop0(policy);\r\n}\r\nstatic void nrs_policy_put(struct ptlrpc_nrs_policy *policy)\r\n{\r\nspin_lock(&policy->pol_nrs->nrs_lock);\r\nnrs_policy_put_locked(policy);\r\nspin_unlock(&policy->pol_nrs->nrs_lock);\r\n}\r\nstatic struct ptlrpc_nrs_policy *nrs_policy_find_locked(struct ptlrpc_nrs *nrs,\r\nchar *name)\r\n{\r\nstruct ptlrpc_nrs_policy *tmp;\r\nlist_for_each_entry(tmp, &nrs->nrs_policy_list, pol_list) {\r\nif (strncmp(tmp->pol_desc->pd_name, name,\r\nNRS_POL_NAME_MAX) == 0) {\r\nnrs_policy_get_locked(tmp);\r\nreturn tmp;\r\n}\r\n}\r\nreturn NULL;\r\n}\r\nstatic void nrs_resource_put(struct ptlrpc_nrs_resource *res)\r\n{\r\nstruct ptlrpc_nrs_policy *policy = res->res_policy;\r\nif (policy->pol_desc->pd_ops->op_res_put != NULL) {\r\nstruct ptlrpc_nrs_resource *parent;\r\nfor (; res != NULL; res = parent) {\r\nparent = res->res_parent;\r\npolicy->pol_desc->pd_ops->op_res_put(policy, res);\r\n}\r\n}\r\n}\r\nstatic\r\nstruct ptlrpc_nrs_resource *nrs_resource_get(struct ptlrpc_nrs_policy *policy,\r\nstruct ptlrpc_nrs_request *nrq,\r\nbool moving_req)\r\n{\r\nstruct ptlrpc_nrs_resource *res = NULL;\r\nstruct ptlrpc_nrs_resource *tmp = NULL;\r\nint rc;\r\nwhile (1) {\r\nrc = policy->pol_desc->pd_ops->op_res_get(policy, nrq, res,\r\n&tmp, moving_req);\r\nif (rc < 0) {\r\nif (res != NULL)\r\nnrs_resource_put(res);\r\nreturn NULL;\r\n}\r\nLASSERT(tmp != NULL);\r\ntmp->res_parent = res;\r\ntmp->res_policy = policy;\r\nres = tmp;\r\ntmp = NULL;\r\nif (rc > 0)\r\nreturn res;\r\n}\r\n}\r\nstatic void nrs_resource_get_safe(struct ptlrpc_nrs *nrs,\r\nstruct ptlrpc_nrs_request *nrq,\r\nstruct ptlrpc_nrs_resource **resp,\r\nbool moving_req)\r\n{\r\nstruct ptlrpc_nrs_policy *primary = NULL;\r\nstruct ptlrpc_nrs_policy *fallback = NULL;\r\nmemset(resp, 0, sizeof(resp[0]) * NRS_RES_MAX);\r\nspin_lock(&nrs->nrs_lock);\r\nfallback = nrs->nrs_policy_fallback;\r\nnrs_policy_get_locked(fallback);\r\nprimary = nrs->nrs_policy_primary;\r\nif (primary != NULL)\r\nnrs_policy_get_locked(primary);\r\nspin_unlock(&nrs->nrs_lock);\r\nresp[NRS_RES_FALLBACK] = nrs_resource_get(fallback, nrq, moving_req);\r\nLASSERT(resp[NRS_RES_FALLBACK] != NULL);\r\nif (primary != NULL) {\r\nresp[NRS_RES_PRIMARY] = nrs_resource_get(primary, nrq,\r\nmoving_req);\r\nif (resp[NRS_RES_PRIMARY] == NULL)\r\nnrs_policy_put(primary);\r\n}\r\n}\r\nstatic void nrs_resource_put_safe(struct ptlrpc_nrs_resource **resp)\r\n{\r\nstruct ptlrpc_nrs_policy *pols[NRS_RES_MAX];\r\nstruct ptlrpc_nrs *nrs = NULL;\r\nint i;\r\nfor (i = 0; i < NRS_RES_MAX; i++) {\r\nif (resp[i] != NULL) {\r\npols[i] = resp[i]->res_policy;\r\nnrs_resource_put(resp[i]);\r\nresp[i] = NULL;\r\n} else {\r\npols[i] = NULL;\r\n}\r\n}\r\nfor (i = 0; i < NRS_RES_MAX; i++) {\r\nif (pols[i] == NULL)\r\ncontinue;\r\nif (nrs == NULL) {\r\nnrs = pols[i]->pol_nrs;\r\nspin_lock(&nrs->nrs_lock);\r\n}\r\nnrs_policy_put_locked(pols[i]);\r\n}\r\nif (nrs != NULL)\r\nspin_unlock(&nrs->nrs_lock);\r\n}\r\nstatic inline\r\nstruct ptlrpc_nrs_request *nrs_request_get(struct ptlrpc_nrs_policy *policy,\r\nbool peek, bool force)\r\n{\r\nstruct ptlrpc_nrs_request *nrq;\r\nLASSERT(policy->pol_req_queued > 0);\r\nnrq = policy->pol_desc->pd_ops->op_req_get(policy, peek, force);\r\nLASSERT(ergo(nrq != NULL, nrs_request_policy(nrq) == policy));\r\nreturn nrq;\r\n}\r\nstatic inline void nrs_request_enqueue(struct ptlrpc_nrs_request *nrq)\r\n{\r\nstruct ptlrpc_nrs_policy *policy;\r\nint rc;\r\nint i;\r\nfor (i = NRS_RES_MAX - 1; i >= 0; i--) {\r\nif (nrq->nr_res_ptrs[i] == NULL)\r\ncontinue;\r\nnrq->nr_res_idx = i;\r\npolicy = nrq->nr_res_ptrs[i]->res_policy;\r\nrc = policy->pol_desc->pd_ops->op_req_enqueue(policy, nrq);\r\nif (rc == 0) {\r\npolicy->pol_nrs->nrs_req_queued++;\r\npolicy->pol_req_queued++;\r\nreturn;\r\n}\r\n}\r\nLBUG();\r\n}\r\nstatic inline void nrs_request_stop(struct ptlrpc_nrs_request *nrq)\r\n{\r\nstruct ptlrpc_nrs_policy *policy = nrs_request_policy(nrq);\r\nif (policy->pol_desc->pd_ops->op_req_stop)\r\npolicy->pol_desc->pd_ops->op_req_stop(policy, nrq);\r\nLASSERT(policy->pol_nrs->nrs_req_started > 0);\r\nLASSERT(policy->pol_req_started > 0);\r\npolicy->pol_nrs->nrs_req_started--;\r\npolicy->pol_req_started--;\r\n}\r\nstatic int nrs_policy_ctl(struct ptlrpc_nrs *nrs, char *name,\r\nenum ptlrpc_nrs_ctl opc, void *arg)\r\n{\r\nstruct ptlrpc_nrs_policy *policy;\r\nint rc = 0;\r\nspin_lock(&nrs->nrs_lock);\r\npolicy = nrs_policy_find_locked(nrs, name);\r\nif (policy == NULL) {\r\nrc = -ENOENT;\r\ngoto out;\r\n}\r\nswitch (opc) {\r\ndefault:\r\nrc = nrs_policy_ctl_locked(policy, opc, arg);\r\nbreak;\r\ncase PTLRPC_NRS_CTL_START:\r\nrc = nrs_policy_start_locked(policy);\r\nbreak;\r\n}\r\nout:\r\nif (policy != NULL)\r\nnrs_policy_put_locked(policy);\r\nspin_unlock(&nrs->nrs_lock);\r\nreturn rc;\r\n}\r\nstatic int nrs_policy_unregister(struct ptlrpc_nrs *nrs, char *name)\r\n{\r\nstruct ptlrpc_nrs_policy *policy = NULL;\r\nspin_lock(&nrs->nrs_lock);\r\npolicy = nrs_policy_find_locked(nrs, name);\r\nif (policy == NULL) {\r\nspin_unlock(&nrs->nrs_lock);\r\nCERROR("Can't find NRS policy %s\n", name);\r\nreturn -ENOENT;\r\n}\r\nif (policy->pol_ref > 1) {\r\nCERROR("Policy %s is busy with %d references\n", name,\r\n(int)policy->pol_ref);\r\nnrs_policy_put_locked(policy);\r\nspin_unlock(&nrs->nrs_lock);\r\nreturn -EBUSY;\r\n}\r\nLASSERT(policy->pol_req_queued == 0);\r\nLASSERT(policy->pol_req_started == 0);\r\nif (policy->pol_state != NRS_POL_STATE_STOPPED) {\r\nnrs_policy_stop_locked(policy);\r\nLASSERT(policy->pol_state == NRS_POL_STATE_STOPPED);\r\n}\r\nlist_del(&policy->pol_list);\r\nnrs->nrs_num_pols--;\r\nnrs_policy_put_locked(policy);\r\nspin_unlock(&nrs->nrs_lock);\r\nnrs_policy_fini(policy);\r\nLASSERT(policy->pol_private == NULL);\r\nkfree(policy);\r\nreturn 0;\r\n}\r\nstatic int nrs_policy_register(struct ptlrpc_nrs *nrs,\r\nstruct ptlrpc_nrs_pol_desc *desc)\r\n{\r\nstruct ptlrpc_nrs_policy *policy;\r\nstruct ptlrpc_nrs_policy *tmp;\r\nstruct ptlrpc_service_part *svcpt = nrs->nrs_svcpt;\r\nint rc;\r\nLASSERT(svcpt != NULL);\r\nLASSERT(desc->pd_ops != NULL);\r\nLASSERT(desc->pd_ops->op_res_get != NULL);\r\nLASSERT(desc->pd_ops->op_req_get != NULL);\r\nLASSERT(desc->pd_ops->op_req_enqueue != NULL);\r\nLASSERT(desc->pd_ops->op_req_dequeue != NULL);\r\nLASSERT(desc->pd_compat != NULL);\r\npolicy = kzalloc_node(sizeof(*policy), GFP_NOFS,\r\ncfs_cpt_spread_node(svcpt->scp_service->srv_cptable,\r\nsvcpt->scp_cpt));\r\nif (policy == NULL)\r\nreturn -ENOMEM;\r\npolicy->pol_nrs = nrs;\r\npolicy->pol_desc = desc;\r\npolicy->pol_state = NRS_POL_STATE_STOPPED;\r\npolicy->pol_flags = desc->pd_flags;\r\nINIT_LIST_HEAD(&policy->pol_list);\r\nINIT_LIST_HEAD(&policy->pol_list_queued);\r\nrc = nrs_policy_init(policy);\r\nif (rc != 0) {\r\nkfree(policy);\r\nreturn rc;\r\n}\r\nspin_lock(&nrs->nrs_lock);\r\ntmp = nrs_policy_find_locked(nrs, policy->pol_desc->pd_name);\r\nif (tmp != NULL) {\r\nCERROR("NRS policy %s has been registered, can't register it for %s\n",\r\npolicy->pol_desc->pd_name,\r\nsvcpt->scp_service->srv_name);\r\nnrs_policy_put_locked(tmp);\r\nspin_unlock(&nrs->nrs_lock);\r\nnrs_policy_fini(policy);\r\nkfree(policy);\r\nreturn -EEXIST;\r\n}\r\nlist_add_tail(&policy->pol_list, &nrs->nrs_policy_list);\r\nnrs->nrs_num_pols++;\r\nif (policy->pol_flags & PTLRPC_NRS_FL_REG_START)\r\nrc = nrs_policy_start_locked(policy);\r\nspin_unlock(&nrs->nrs_lock);\r\nif (rc != 0)\r\n(void) nrs_policy_unregister(nrs, policy->pol_desc->pd_name);\r\nreturn rc;\r\n}\r\nstatic void ptlrpc_nrs_req_add_nolock(struct ptlrpc_request *req)\r\n{\r\nstruct ptlrpc_nrs_policy *policy;\r\nLASSERT(req->rq_nrq.nr_initialized);\r\nLASSERT(!req->rq_nrq.nr_enqueued);\r\nnrs_request_enqueue(&req->rq_nrq);\r\nreq->rq_nrq.nr_enqueued = 1;\r\npolicy = nrs_request_policy(&req->rq_nrq);\r\nif (unlikely(list_empty(&policy->pol_list_queued)))\r\nlist_add_tail(&policy->pol_list_queued,\r\n&policy->pol_nrs->nrs_policy_queued);\r\n}\r\nstatic void ptlrpc_nrs_hpreq_add_nolock(struct ptlrpc_request *req)\r\n{\r\nint opc = lustre_msg_get_opc(req->rq_reqmsg);\r\nspin_lock(&req->rq_lock);\r\nreq->rq_hp = 1;\r\nptlrpc_nrs_req_add_nolock(req);\r\nif (opc != OBD_PING)\r\nDEBUG_REQ(D_NET, req, "high priority req");\r\nspin_unlock(&req->rq_lock);\r\n}\r\nstatic inline bool nrs_policy_compatible(const struct ptlrpc_service *svc,\r\nconst struct ptlrpc_nrs_pol_desc *desc)\r\n{\r\nreturn desc->pd_compat(svc, desc);\r\n}\r\nstatic int nrs_register_policies_locked(struct ptlrpc_nrs *nrs)\r\n{\r\nstruct ptlrpc_nrs_pol_desc *desc;\r\nstruct ptlrpc_service_part *svcpt = nrs->nrs_svcpt;\r\nstruct ptlrpc_service *svc = svcpt->scp_service;\r\nint rc = -EINVAL;\r\nLASSERT(mutex_is_locked(&nrs_core.nrs_mutex));\r\nlist_for_each_entry(desc, &nrs_core.nrs_policies, pd_list) {\r\nif (nrs_policy_compatible(svc, desc)) {\r\nrc = nrs_policy_register(nrs, desc);\r\nif (rc != 0) {\r\nCERROR("Failed to register NRS policy %s for partition %d of service %s: %d\n",\r\ndesc->pd_name, svcpt->scp_cpt,\r\nsvc->srv_name, rc);\r\nbreak;\r\n}\r\n}\r\n}\r\nreturn rc;\r\n}\r\nstatic int nrs_svcpt_setup_locked0(struct ptlrpc_nrs *nrs,\r\nstruct ptlrpc_service_part *svcpt)\r\n{\r\nenum ptlrpc_nrs_queue_type queue;\r\nLASSERT(mutex_is_locked(&nrs_core.nrs_mutex));\r\nif (nrs == &svcpt->scp_nrs_reg)\r\nqueue = PTLRPC_NRS_QUEUE_REG;\r\nelse if (nrs == svcpt->scp_nrs_hp)\r\nqueue = PTLRPC_NRS_QUEUE_HP;\r\nelse\r\nLBUG();\r\nnrs->nrs_svcpt = svcpt;\r\nnrs->nrs_queue_type = queue;\r\nspin_lock_init(&nrs->nrs_lock);\r\nINIT_LIST_HEAD(&nrs->nrs_policy_list);\r\nINIT_LIST_HEAD(&nrs->nrs_policy_queued);\r\nreturn nrs_register_policies_locked(nrs);\r\n}\r\nstatic int nrs_svcpt_setup_locked(struct ptlrpc_service_part *svcpt)\r\n{\r\nstruct ptlrpc_nrs *nrs;\r\nint rc;\r\nLASSERT(mutex_is_locked(&nrs_core.nrs_mutex));\r\nnrs = nrs_svcpt2nrs(svcpt, false);\r\nrc = nrs_svcpt_setup_locked0(nrs, svcpt);\r\nif (rc < 0)\r\ngoto out;\r\nif (svcpt->scp_service->srv_ops.so_hpreq_handler == NULL)\r\ngoto out;\r\nsvcpt->scp_nrs_hp =\r\nkzalloc_node(sizeof(*svcpt->scp_nrs_hp), GFP_NOFS,\r\ncfs_cpt_spread_node(svcpt->scp_service->srv_cptable,\r\nsvcpt->scp_cpt));\r\nif (svcpt->scp_nrs_hp == NULL) {\r\nrc = -ENOMEM;\r\ngoto out;\r\n}\r\nnrs = nrs_svcpt2nrs(svcpt, true);\r\nrc = nrs_svcpt_setup_locked0(nrs, svcpt);\r\nout:\r\nreturn rc;\r\n}\r\nstatic void nrs_svcpt_cleanup_locked(struct ptlrpc_service_part *svcpt)\r\n{\r\nstruct ptlrpc_nrs *nrs;\r\nstruct ptlrpc_nrs_policy *policy;\r\nstruct ptlrpc_nrs_policy *tmp;\r\nint rc;\r\nbool hp = false;\r\nLASSERT(mutex_is_locked(&nrs_core.nrs_mutex));\r\nagain:\r\nnrs = nrs_svcpt2nrs(svcpt, hp);\r\nnrs->nrs_stopping = 1;\r\nlist_for_each_entry_safe(policy, tmp, &nrs->nrs_policy_list,\r\npol_list) {\r\nrc = nrs_policy_unregister(nrs, policy->pol_desc->pd_name);\r\nLASSERT(rc == 0);\r\n}\r\nif (!hp && nrs_svcpt_has_hp(svcpt)) {\r\nhp = true;\r\ngoto again;\r\n}\r\nif (hp)\r\nkfree(nrs);\r\n}\r\nstatic struct ptlrpc_nrs_pol_desc *nrs_policy_find_desc_locked(const char *name)\r\n{\r\nstruct ptlrpc_nrs_pol_desc *tmp;\r\nlist_for_each_entry(tmp, &nrs_core.nrs_policies, pd_list) {\r\nif (strncmp(tmp->pd_name, name, NRS_POL_NAME_MAX) == 0)\r\nreturn tmp;\r\n}\r\nreturn NULL;\r\n}\r\nstatic int nrs_policy_unregister_locked(struct ptlrpc_nrs_pol_desc *desc)\r\n{\r\nstruct ptlrpc_nrs *nrs;\r\nstruct ptlrpc_service *svc;\r\nstruct ptlrpc_service_part *svcpt;\r\nint i;\r\nint rc = 0;\r\nLASSERT(mutex_is_locked(&nrs_core.nrs_mutex));\r\nLASSERT(mutex_is_locked(&ptlrpc_all_services_mutex));\r\nlist_for_each_entry(svc, &ptlrpc_all_services, srv_list) {\r\nif (!nrs_policy_compatible(svc, desc) ||\r\nunlikely(svc->srv_is_stopping))\r\ncontinue;\r\nptlrpc_service_for_each_part(svcpt, i, svc) {\r\nbool hp = false;\r\nagain:\r\nnrs = nrs_svcpt2nrs(svcpt, hp);\r\nrc = nrs_policy_unregister(nrs, desc->pd_name);\r\nif (rc == -ENOENT) {\r\nrc = 0;\r\n} else if (rc != 0) {\r\nCERROR("Failed to unregister NRS policy %s for partition %d of service %s: %d\n",\r\ndesc->pd_name, svcpt->scp_cpt,\r\nsvcpt->scp_service->srv_name, rc);\r\nreturn rc;\r\n}\r\nif (!hp && nrs_svc_has_hp(svc)) {\r\nhp = true;\r\ngoto again;\r\n}\r\n}\r\nif (desc->pd_ops->op_lprocfs_fini != NULL)\r\ndesc->pd_ops->op_lprocfs_fini(svc);\r\n}\r\nreturn rc;\r\n}\r\nstatic int ptlrpc_nrs_policy_register(struct ptlrpc_nrs_pol_conf *conf)\r\n{\r\nstruct ptlrpc_service *svc;\r\nstruct ptlrpc_nrs_pol_desc *desc;\r\nint rc = 0;\r\nLASSERT(conf != NULL);\r\nLASSERT(conf->nc_ops != NULL);\r\nLASSERT(conf->nc_compat != NULL);\r\nLASSERT(ergo(conf->nc_compat == nrs_policy_compat_one,\r\nconf->nc_compat_svc_name != NULL));\r\nLASSERT(ergo((conf->nc_flags & PTLRPC_NRS_FL_REG_EXTERN) != 0,\r\nconf->nc_owner != NULL));\r\nconf->nc_name[NRS_POL_NAME_MAX - 1] = '\0';\r\nif ((conf->nc_flags & PTLRPC_NRS_FL_REG_EXTERN) &&\r\n(conf->nc_flags & (PTLRPC_NRS_FL_FALLBACK |\r\nPTLRPC_NRS_FL_REG_START))) {\r\nCERROR("NRS: failing to register policy %s. Please check policy flags; external policies cannot act as fallback policies, or be started immediately upon registration without interaction with lprocfs\n",\r\nconf->nc_name);\r\nreturn -EINVAL;\r\n}\r\nmutex_lock(&nrs_core.nrs_mutex);\r\nif (nrs_policy_find_desc_locked(conf->nc_name) != NULL) {\r\nCERROR("NRS: failing to register policy %s which has already been registered with NRS core!\n",\r\nconf->nc_name);\r\nrc = -EEXIST;\r\ngoto fail;\r\n}\r\ndesc = kzalloc(sizeof(*desc), GFP_NOFS);\r\nif (!desc) {\r\nrc = -ENOMEM;\r\ngoto fail;\r\n}\r\nstrncpy(desc->pd_name, conf->nc_name, NRS_POL_NAME_MAX);\r\ndesc->pd_ops = conf->nc_ops;\r\ndesc->pd_compat = conf->nc_compat;\r\ndesc->pd_compat_svc_name = conf->nc_compat_svc_name;\r\nif ((conf->nc_flags & PTLRPC_NRS_FL_REG_EXTERN) != 0)\r\ndesc->pd_owner = conf->nc_owner;\r\ndesc->pd_flags = conf->nc_flags;\r\natomic_set(&desc->pd_refs, 0);\r\nif ((conf->nc_flags & PTLRPC_NRS_FL_REG_EXTERN) == 0)\r\ngoto internal;\r\nmutex_lock(&ptlrpc_all_services_mutex);\r\nlist_for_each_entry(svc, &ptlrpc_all_services, srv_list) {\r\nstruct ptlrpc_service_part *svcpt;\r\nint i;\r\nint rc2;\r\nif (!nrs_policy_compatible(svc, desc) ||\r\nunlikely(svc->srv_is_stopping))\r\ncontinue;\r\nptlrpc_service_for_each_part(svcpt, i, svc) {\r\nstruct ptlrpc_nrs *nrs;\r\nbool hp = false;\r\nagain:\r\nnrs = nrs_svcpt2nrs(svcpt, hp);\r\nrc = nrs_policy_register(nrs, desc);\r\nif (rc != 0) {\r\nCERROR("Failed to register NRS policy %s for partition %d of service %s: %d\n",\r\ndesc->pd_name, svcpt->scp_cpt,\r\nsvcpt->scp_service->srv_name, rc);\r\nrc2 = nrs_policy_unregister_locked(desc);\r\nLASSERT(rc2 == 0);\r\nmutex_unlock(&ptlrpc_all_services_mutex);\r\nkfree(desc);\r\ngoto fail;\r\n}\r\nif (!hp && nrs_svc_has_hp(svc)) {\r\nhp = true;\r\ngoto again;\r\n}\r\n}\r\nif (desc->pd_ops->op_lprocfs_init != NULL) {\r\nrc = desc->pd_ops->op_lprocfs_init(svc);\r\nif (rc != 0) {\r\nrc2 = nrs_policy_unregister_locked(desc);\r\nLASSERT(rc2 == 0);\r\nmutex_unlock(&ptlrpc_all_services_mutex);\r\nkfree(desc);\r\ngoto fail;\r\n}\r\n}\r\n}\r\nmutex_unlock(&ptlrpc_all_services_mutex);\r\ninternal:\r\nlist_add_tail(&desc->pd_list, &nrs_core.nrs_policies);\r\nfail:\r\nmutex_unlock(&nrs_core.nrs_mutex);\r\nreturn rc;\r\n}\r\nint ptlrpc_service_nrs_setup(struct ptlrpc_service *svc)\r\n{\r\nstruct ptlrpc_service_part *svcpt;\r\nconst struct ptlrpc_nrs_pol_desc *desc;\r\nint i;\r\nint rc = 0;\r\nmutex_lock(&nrs_core.nrs_mutex);\r\nptlrpc_service_for_each_part(svcpt, i, svc) {\r\nrc = nrs_svcpt_setup_locked(svcpt);\r\nif (rc != 0)\r\ngoto failed;\r\n}\r\nlist_for_each_entry(desc, &nrs_core.nrs_policies, pd_list) {\r\nif (!nrs_policy_compatible(svc, desc))\r\ncontinue;\r\nif (desc->pd_ops->op_lprocfs_init != NULL) {\r\nrc = desc->pd_ops->op_lprocfs_init(svc);\r\nif (rc != 0)\r\ngoto failed;\r\n}\r\n}\r\nfailed:\r\nmutex_unlock(&nrs_core.nrs_mutex);\r\nreturn rc;\r\n}\r\nvoid ptlrpc_service_nrs_cleanup(struct ptlrpc_service *svc)\r\n{\r\nstruct ptlrpc_service_part *svcpt;\r\nconst struct ptlrpc_nrs_pol_desc *desc;\r\nint i;\r\nmutex_lock(&nrs_core.nrs_mutex);\r\nptlrpc_service_for_each_part(svcpt, i, svc)\r\nnrs_svcpt_cleanup_locked(svcpt);\r\nlist_for_each_entry(desc, &nrs_core.nrs_policies, pd_list) {\r\nif (!nrs_policy_compatible(svc, desc))\r\ncontinue;\r\nif (desc->pd_ops->op_lprocfs_fini != NULL)\r\ndesc->pd_ops->op_lprocfs_fini(svc);\r\n}\r\nmutex_unlock(&nrs_core.nrs_mutex);\r\n}\r\nvoid ptlrpc_nrs_req_initialize(struct ptlrpc_service_part *svcpt,\r\nstruct ptlrpc_request *req, bool hp)\r\n{\r\nstruct ptlrpc_nrs *nrs = nrs_svcpt2nrs(svcpt, hp);\r\nmemset(&req->rq_nrq, 0, sizeof(req->rq_nrq));\r\nnrs_resource_get_safe(nrs, &req->rq_nrq, req->rq_nrq.nr_res_ptrs,\r\nfalse);\r\nreq->rq_nrq.nr_initialized = 1;\r\n}\r\nvoid ptlrpc_nrs_req_finalize(struct ptlrpc_request *req)\r\n{\r\nif (req->rq_nrq.nr_initialized) {\r\nnrs_resource_put_safe(req->rq_nrq.nr_res_ptrs);\r\nreq->rq_nrq.nr_finalized = 1;\r\n}\r\n}\r\nvoid ptlrpc_nrs_req_stop_nolock(struct ptlrpc_request *req)\r\n{\r\nif (req->rq_nrq.nr_started)\r\nnrs_request_stop(&req->rq_nrq);\r\n}\r\nvoid ptlrpc_nrs_req_add(struct ptlrpc_service_part *svcpt,\r\nstruct ptlrpc_request *req, bool hp)\r\n{\r\nspin_lock(&svcpt->scp_req_lock);\r\nif (hp)\r\nptlrpc_nrs_hpreq_add_nolock(req);\r\nelse\r\nptlrpc_nrs_req_add_nolock(req);\r\nspin_unlock(&svcpt->scp_req_lock);\r\n}\r\nstatic void nrs_request_removed(struct ptlrpc_nrs_policy *policy)\r\n{\r\nLASSERT(policy->pol_nrs->nrs_req_queued > 0);\r\nLASSERT(policy->pol_req_queued > 0);\r\npolicy->pol_nrs->nrs_req_queued--;\r\npolicy->pol_req_queued--;\r\nif (unlikely(policy->pol_req_queued == 0)) {\r\nlist_del_init(&policy->pol_list_queued);\r\n} else if (policy->pol_req_queued != policy->pol_nrs->nrs_req_queued) {\r\nLASSERT(policy->pol_req_queued <\r\npolicy->pol_nrs->nrs_req_queued);\r\nlist_move_tail(&policy->pol_list_queued,\r\n&policy->pol_nrs->nrs_policy_queued);\r\n}\r\n}\r\nstruct ptlrpc_request *\r\nptlrpc_nrs_req_get_nolock0(struct ptlrpc_service_part *svcpt, bool hp,\r\nbool peek, bool force)\r\n{\r\nstruct ptlrpc_nrs *nrs = nrs_svcpt2nrs(svcpt, hp);\r\nstruct ptlrpc_nrs_policy *policy;\r\nstruct ptlrpc_nrs_request *nrq;\r\nlist_for_each_entry(policy, &nrs->nrs_policy_queued,\r\npol_list_queued) {\r\nnrq = nrs_request_get(policy, peek, force);\r\nif (nrq != NULL) {\r\nif (likely(!peek)) {\r\nnrq->nr_started = 1;\r\npolicy->pol_req_started++;\r\npolicy->pol_nrs->nrs_req_started++;\r\nnrs_request_removed(policy);\r\n}\r\nreturn container_of(nrq, struct ptlrpc_request, rq_nrq);\r\n}\r\n}\r\nreturn NULL;\r\n}\r\nbool ptlrpc_nrs_req_pending_nolock(struct ptlrpc_service_part *svcpt, bool hp)\r\n{\r\nstruct ptlrpc_nrs *nrs = nrs_svcpt2nrs(svcpt, hp);\r\nreturn nrs->nrs_req_queued > 0;\r\n}\r\nint ptlrpc_nrs_policy_control(const struct ptlrpc_service *svc,\r\nenum ptlrpc_nrs_queue_type queue, char *name,\r\nenum ptlrpc_nrs_ctl opc, bool single, void *arg)\r\n{\r\nstruct ptlrpc_service_part *svcpt;\r\nint i;\r\nint rc = 0;\r\nLASSERT(opc != PTLRPC_NRS_CTL_INVALID);\r\nif ((queue & PTLRPC_NRS_QUEUE_BOTH) == 0)\r\nreturn -EINVAL;\r\nptlrpc_service_for_each_part(svcpt, i, svc) {\r\nif ((queue & PTLRPC_NRS_QUEUE_REG) != 0) {\r\nrc = nrs_policy_ctl(nrs_svcpt2nrs(svcpt, false), name,\r\nopc, arg);\r\nif (rc != 0 || (queue == PTLRPC_NRS_QUEUE_REG &&\r\nsingle))\r\ngoto out;\r\n}\r\nif ((queue & PTLRPC_NRS_QUEUE_HP) != 0) {\r\nrc = nrs_policy_ctl(nrs_svcpt2nrs(svcpt, true), name,\r\nopc, arg);\r\nif (rc != 0 || single)\r\ngoto out;\r\n}\r\n}\r\nout:\r\nreturn rc;\r\n}\r\nint ptlrpc_nrs_init(void)\r\n{\r\nint rc;\r\nmutex_init(&nrs_core.nrs_mutex);\r\nINIT_LIST_HEAD(&nrs_core.nrs_policies);\r\nrc = ptlrpc_nrs_policy_register(&nrs_conf_fifo);\r\nif (rc != 0)\r\ngoto fail;\r\nreturn rc;\r\nfail:\r\nptlrpc_nrs_fini();\r\nreturn rc;\r\n}\r\nvoid ptlrpc_nrs_fini(void)\r\n{\r\nstruct ptlrpc_nrs_pol_desc *desc;\r\nstruct ptlrpc_nrs_pol_desc *tmp;\r\nlist_for_each_entry_safe(desc, tmp, &nrs_core.nrs_policies,\r\npd_list) {\r\nlist_del_init(&desc->pd_list);\r\nkfree(desc);\r\n}\r\n}
