static void dn_dst_destroy(struct dst_entry *dst)\r\n{\r\nstruct dn_route *rt = (struct dn_route *) dst;\r\nif (rt->n)\r\nneigh_release(rt->n);\r\ndst_destroy_metrics_generic(dst);\r\n}\r\nstatic void dn_dst_ifdown(struct dst_entry *dst, struct net_device *dev, int how)\r\n{\r\nif (how) {\r\nstruct dn_route *rt = (struct dn_route *) dst;\r\nstruct neighbour *n = rt->n;\r\nif (n && n->dev == dev) {\r\nn->dev = dev_net(dev)->loopback_dev;\r\ndev_hold(n->dev);\r\ndev_put(dev);\r\n}\r\n}\r\n}\r\nstatic __inline__ unsigned int dn_hash(__le16 src, __le16 dst)\r\n{\r\n__u16 tmp = (__u16 __force)(src ^ dst);\r\ntmp ^= (tmp >> 3);\r\ntmp ^= (tmp >> 5);\r\ntmp ^= (tmp >> 10);\r\nreturn dn_rt_hash_mask & (unsigned int)tmp;\r\n}\r\nstatic inline void dnrt_free(struct dn_route *rt)\r\n{\r\ncall_rcu_bh(&rt->dst.rcu_head, dst_rcu_free);\r\n}\r\nstatic inline void dnrt_drop(struct dn_route *rt)\r\n{\r\ndst_release(&rt->dst);\r\ncall_rcu_bh(&rt->dst.rcu_head, dst_rcu_free);\r\n}\r\nstatic void dn_dst_check_expire(unsigned long dummy)\r\n{\r\nint i;\r\nstruct dn_route *rt;\r\nstruct dn_route __rcu **rtp;\r\nunsigned long now = jiffies;\r\nunsigned long expire = 120 * HZ;\r\nfor (i = 0; i <= dn_rt_hash_mask; i++) {\r\nrtp = &dn_rt_hash_table[i].chain;\r\nspin_lock(&dn_rt_hash_table[i].lock);\r\nwhile ((rt = rcu_dereference_protected(*rtp,\r\nlockdep_is_held(&dn_rt_hash_table[i].lock))) != NULL) {\r\nif (atomic_read(&rt->dst.__refcnt) ||\r\n(now - rt->dst.lastuse) < expire) {\r\nrtp = &rt->dst.dn_next;\r\ncontinue;\r\n}\r\n*rtp = rt->dst.dn_next;\r\nrt->dst.dn_next = NULL;\r\ndnrt_free(rt);\r\n}\r\nspin_unlock(&dn_rt_hash_table[i].lock);\r\nif ((jiffies - now) > 0)\r\nbreak;\r\n}\r\nmod_timer(&dn_route_timer, now + decnet_dst_gc_interval * HZ);\r\n}\r\nstatic int dn_dst_gc(struct dst_ops *ops)\r\n{\r\nstruct dn_route *rt;\r\nstruct dn_route __rcu **rtp;\r\nint i;\r\nunsigned long now = jiffies;\r\nunsigned long expire = 10 * HZ;\r\nfor (i = 0; i <= dn_rt_hash_mask; i++) {\r\nspin_lock_bh(&dn_rt_hash_table[i].lock);\r\nrtp = &dn_rt_hash_table[i].chain;\r\nwhile ((rt = rcu_dereference_protected(*rtp,\r\nlockdep_is_held(&dn_rt_hash_table[i].lock))) != NULL) {\r\nif (atomic_read(&rt->dst.__refcnt) ||\r\n(now - rt->dst.lastuse) < expire) {\r\nrtp = &rt->dst.dn_next;\r\ncontinue;\r\n}\r\n*rtp = rt->dst.dn_next;\r\nrt->dst.dn_next = NULL;\r\ndnrt_drop(rt);\r\nbreak;\r\n}\r\nspin_unlock_bh(&dn_rt_hash_table[i].lock);\r\n}\r\nreturn 0;\r\n}\r\nstatic void dn_dst_update_pmtu(struct dst_entry *dst, struct sock *sk,\r\nstruct sk_buff *skb, u32 mtu)\r\n{\r\nstruct dn_route *rt = (struct dn_route *) dst;\r\nstruct neighbour *n = rt->n;\r\nu32 min_mtu = 230;\r\nstruct dn_dev *dn;\r\ndn = n ? rcu_dereference_raw(n->dev->dn_ptr) : NULL;\r\nif (dn && dn->use_long == 0)\r\nmin_mtu -= 6;\r\nelse\r\nmin_mtu -= 21;\r\nif (dst_metric(dst, RTAX_MTU) > mtu && mtu >= min_mtu) {\r\nif (!(dst_metric_locked(dst, RTAX_MTU))) {\r\ndst_metric_set(dst, RTAX_MTU, mtu);\r\ndst_set_expires(dst, dn_rt_mtu_expires);\r\n}\r\nif (!(dst_metric_locked(dst, RTAX_ADVMSS))) {\r\nu32 mss = mtu - DN_MAX_NSP_DATA_HEADER;\r\nu32 existing_mss = dst_metric_raw(dst, RTAX_ADVMSS);\r\nif (!existing_mss || existing_mss > mss)\r\ndst_metric_set(dst, RTAX_ADVMSS, mss);\r\n}\r\n}\r\n}\r\nstatic void dn_dst_redirect(struct dst_entry *dst, struct sock *sk,\r\nstruct sk_buff *skb)\r\n{\r\n}\r\nstatic struct dst_entry *dn_dst_check(struct dst_entry *dst, __u32 cookie)\r\n{\r\nreturn NULL;\r\n}\r\nstatic struct dst_entry *dn_dst_negative_advice(struct dst_entry *dst)\r\n{\r\ndst_release(dst);\r\nreturn NULL;\r\n}\r\nstatic void dn_dst_link_failure(struct sk_buff *skb)\r\n{\r\n}\r\nstatic inline int compare_keys(struct flowidn *fl1, struct flowidn *fl2)\r\n{\r\nreturn ((fl1->daddr ^ fl2->daddr) |\r\n(fl1->saddr ^ fl2->saddr) |\r\n(fl1->flowidn_mark ^ fl2->flowidn_mark) |\r\n(fl1->flowidn_scope ^ fl2->flowidn_scope) |\r\n(fl1->flowidn_oif ^ fl2->flowidn_oif) |\r\n(fl1->flowidn_iif ^ fl2->flowidn_iif)) == 0;\r\n}\r\nstatic int dn_insert_route(struct dn_route *rt, unsigned int hash, struct dn_route **rp)\r\n{\r\nstruct dn_route *rth;\r\nstruct dn_route __rcu **rthp;\r\nunsigned long now = jiffies;\r\nrthp = &dn_rt_hash_table[hash].chain;\r\nspin_lock_bh(&dn_rt_hash_table[hash].lock);\r\nwhile ((rth = rcu_dereference_protected(*rthp,\r\nlockdep_is_held(&dn_rt_hash_table[hash].lock))) != NULL) {\r\nif (compare_keys(&rth->fld, &rt->fld)) {\r\n*rthp = rth->dst.dn_next;\r\nrcu_assign_pointer(rth->dst.dn_next,\r\ndn_rt_hash_table[hash].chain);\r\nrcu_assign_pointer(dn_rt_hash_table[hash].chain, rth);\r\ndst_use(&rth->dst, now);\r\nspin_unlock_bh(&dn_rt_hash_table[hash].lock);\r\ndnrt_drop(rt);\r\n*rp = rth;\r\nreturn 0;\r\n}\r\nrthp = &rth->dst.dn_next;\r\n}\r\nrcu_assign_pointer(rt->dst.dn_next, dn_rt_hash_table[hash].chain);\r\nrcu_assign_pointer(dn_rt_hash_table[hash].chain, rt);\r\ndst_use(&rt->dst, now);\r\nspin_unlock_bh(&dn_rt_hash_table[hash].lock);\r\n*rp = rt;\r\nreturn 0;\r\n}\r\nstatic void dn_run_flush(unsigned long dummy)\r\n{\r\nint i;\r\nstruct dn_route *rt, *next;\r\nfor (i = 0; i < dn_rt_hash_mask; i++) {\r\nspin_lock_bh(&dn_rt_hash_table[i].lock);\r\nif ((rt = xchg((struct dn_route **)&dn_rt_hash_table[i].chain, NULL)) == NULL)\r\ngoto nothing_to_declare;\r\nfor(; rt; rt = next) {\r\nnext = rcu_dereference_raw(rt->dst.dn_next);\r\nRCU_INIT_POINTER(rt->dst.dn_next, NULL);\r\ndst_free((struct dst_entry *)rt);\r\n}\r\nnothing_to_declare:\r\nspin_unlock_bh(&dn_rt_hash_table[i].lock);\r\n}\r\n}\r\nvoid dn_rt_cache_flush(int delay)\r\n{\r\nunsigned long now = jiffies;\r\nint user_mode = !in_interrupt();\r\nif (delay < 0)\r\ndelay = dn_rt_min_delay;\r\nspin_lock_bh(&dn_rt_flush_lock);\r\nif (del_timer(&dn_rt_flush_timer) && delay > 0 && dn_rt_deadline) {\r\nlong tmo = (long)(dn_rt_deadline - now);\r\nif (user_mode && tmo < dn_rt_max_delay - dn_rt_min_delay)\r\ntmo = 0;\r\nif (delay > tmo)\r\ndelay = tmo;\r\n}\r\nif (delay <= 0) {\r\nspin_unlock_bh(&dn_rt_flush_lock);\r\ndn_run_flush(0);\r\nreturn;\r\n}\r\nif (dn_rt_deadline == 0)\r\ndn_rt_deadline = now + dn_rt_max_delay;\r\ndn_rt_flush_timer.expires = now + delay;\r\nadd_timer(&dn_rt_flush_timer);\r\nspin_unlock_bh(&dn_rt_flush_lock);\r\n}\r\nstatic int dn_return_short(struct sk_buff *skb)\r\n{\r\nstruct dn_skb_cb *cb;\r\nunsigned char *ptr;\r\n__le16 *src;\r\n__le16 *dst;\r\nskb_push(skb, skb->data - skb_network_header(skb));\r\nif ((skb = skb_unshare(skb, GFP_ATOMIC)) == NULL)\r\nreturn NET_RX_DROP;\r\ncb = DN_SKB_CB(skb);\r\nptr = skb->data + 2;\r\n*ptr++ = (cb->rt_flags & ~DN_RT_F_RQR) | DN_RT_F_RTS;\r\ndst = (__le16 *)ptr;\r\nptr += 2;\r\nsrc = (__le16 *)ptr;\r\nptr += 2;\r\n*ptr = 0;\r\nswap(*src, *dst);\r\nskb->pkt_type = PACKET_OUTGOING;\r\ndn_rt_finish_output(skb, NULL, NULL);\r\nreturn NET_RX_SUCCESS;\r\n}\r\nstatic int dn_return_long(struct sk_buff *skb)\r\n{\r\nstruct dn_skb_cb *cb;\r\nunsigned char *ptr;\r\nunsigned char *src_addr, *dst_addr;\r\nunsigned char tmp[ETH_ALEN];\r\nskb_push(skb, skb->data - skb_network_header(skb));\r\nif ((skb = skb_unshare(skb, GFP_ATOMIC)) == NULL)\r\nreturn NET_RX_DROP;\r\ncb = DN_SKB_CB(skb);\r\nptr = skb->data + 2;\r\nif (*ptr & DN_RT_F_PF) {\r\nchar padlen = (*ptr & ~DN_RT_F_PF);\r\nptr += padlen;\r\n}\r\n*ptr++ = (cb->rt_flags & ~DN_RT_F_RQR) | DN_RT_F_RTS;\r\nptr += 2;\r\ndst_addr = ptr;\r\nptr += 8;\r\nsrc_addr = ptr;\r\nptr += 6;\r\n*ptr = 0;\r\nmemcpy(tmp, src_addr, ETH_ALEN);\r\nmemcpy(src_addr, dst_addr, ETH_ALEN);\r\nmemcpy(dst_addr, tmp, ETH_ALEN);\r\nskb->pkt_type = PACKET_OUTGOING;\r\ndn_rt_finish_output(skb, dst_addr, src_addr);\r\nreturn NET_RX_SUCCESS;\r\n}\r\nstatic int dn_route_rx_packet(struct net *net, struct sock *sk, struct sk_buff *skb)\r\n{\r\nstruct dn_skb_cb *cb;\r\nint err;\r\nif ((err = dn_route_input(skb)) == 0)\r\nreturn dst_input(skb);\r\ncb = DN_SKB_CB(skb);\r\nif (decnet_debug_level & 4) {\r\nchar *devname = skb->dev ? skb->dev->name : "???";\r\nprintk(KERN_DEBUG\r\n"DECnet: dn_route_rx_packet: rt_flags=0x%02x dev=%s len=%d src=0x%04hx dst=0x%04hx err=%d type=%d\n",\r\n(int)cb->rt_flags, devname, skb->len,\r\nle16_to_cpu(cb->src), le16_to_cpu(cb->dst),\r\nerr, skb->pkt_type);\r\n}\r\nif ((skb->pkt_type == PACKET_HOST) && (cb->rt_flags & DN_RT_F_RQR)) {\r\nswitch (cb->rt_flags & DN_RT_PKT_MSK) {\r\ncase DN_RT_PKT_SHORT:\r\nreturn dn_return_short(skb);\r\ncase DN_RT_PKT_LONG:\r\nreturn dn_return_long(skb);\r\n}\r\n}\r\nkfree_skb(skb);\r\nreturn NET_RX_DROP;\r\n}\r\nstatic int dn_route_rx_long(struct sk_buff *skb)\r\n{\r\nstruct dn_skb_cb *cb = DN_SKB_CB(skb);\r\nunsigned char *ptr = skb->data;\r\nif (!pskb_may_pull(skb, 21))\r\ngoto drop_it;\r\nskb_pull(skb, 20);\r\nskb_reset_transport_header(skb);\r\nptr += 2;\r\ncb->dst = dn_eth2dn(ptr);\r\nif (memcmp(ptr, dn_hiord_addr, 4) != 0)\r\ngoto drop_it;\r\nptr += 6;\r\nptr += 2;\r\ncb->src = dn_eth2dn(ptr);\r\nif (memcmp(ptr, dn_hiord_addr, 4) != 0)\r\ngoto drop_it;\r\nptr += 6;\r\nptr++;\r\ncb->hops = *ptr++;\r\nreturn NF_HOOK(NFPROTO_DECNET, NF_DN_PRE_ROUTING,\r\n&init_net, NULL, skb, skb->dev, NULL,\r\ndn_route_rx_packet);\r\ndrop_it:\r\nkfree_skb(skb);\r\nreturn NET_RX_DROP;\r\n}\r\nstatic int dn_route_rx_short(struct sk_buff *skb)\r\n{\r\nstruct dn_skb_cb *cb = DN_SKB_CB(skb);\r\nunsigned char *ptr = skb->data;\r\nif (!pskb_may_pull(skb, 6))\r\ngoto drop_it;\r\nskb_pull(skb, 5);\r\nskb_reset_transport_header(skb);\r\ncb->dst = *(__le16 *)ptr;\r\nptr += 2;\r\ncb->src = *(__le16 *)ptr;\r\nptr += 2;\r\ncb->hops = *ptr & 0x3f;\r\nreturn NF_HOOK(NFPROTO_DECNET, NF_DN_PRE_ROUTING,\r\n&init_net, NULL, skb, skb->dev, NULL,\r\ndn_route_rx_packet);\r\ndrop_it:\r\nkfree_skb(skb);\r\nreturn NET_RX_DROP;\r\n}\r\nstatic int dn_route_discard(struct net *net, struct sock *sk, struct sk_buff *skb)\r\n{\r\nkfree_skb(skb);\r\nreturn NET_RX_SUCCESS;\r\n}\r\nstatic int dn_route_ptp_hello(struct net *net, struct sock *sk, struct sk_buff *skb)\r\n{\r\ndn_dev_hello(skb);\r\ndn_neigh_pointopoint_hello(skb);\r\nreturn NET_RX_SUCCESS;\r\n}\r\nint dn_route_rcv(struct sk_buff *skb, struct net_device *dev, struct packet_type *pt, struct net_device *orig_dev)\r\n{\r\nstruct dn_skb_cb *cb;\r\nunsigned char flags = 0;\r\n__u16 len = le16_to_cpu(*(__le16 *)skb->data);\r\nstruct dn_dev *dn = rcu_dereference(dev->dn_ptr);\r\nunsigned char padlen = 0;\r\nif (!net_eq(dev_net(dev), &init_net))\r\ngoto dump_it;\r\nif (dn == NULL)\r\ngoto dump_it;\r\nif ((skb = skb_share_check(skb, GFP_ATOMIC)) == NULL)\r\ngoto out;\r\nif (!pskb_may_pull(skb, 3))\r\ngoto dump_it;\r\nskb_pull(skb, 2);\r\nif (len > skb->len)\r\ngoto dump_it;\r\nskb_trim(skb, len);\r\nflags = *skb->data;\r\ncb = DN_SKB_CB(skb);\r\ncb->stamp = jiffies;\r\ncb->iif = dev->ifindex;\r\nif (flags & DN_RT_F_PF) {\r\npadlen = flags & ~DN_RT_F_PF;\r\nif (!pskb_may_pull(skb, padlen + 1))\r\ngoto dump_it;\r\nskb_pull(skb, padlen);\r\nflags = *skb->data;\r\n}\r\nskb_reset_network_header(skb);\r\nif (flags & DN_RT_F_VER)\r\ngoto dump_it;\r\ncb->rt_flags = flags;\r\nif (decnet_debug_level & 1)\r\nprintk(KERN_DEBUG\r\n"dn_route_rcv: got 0x%02x from %s [%d %d %d]\n",\r\n(int)flags, (dev) ? dev->name : "???", len, skb->len,\r\npadlen);\r\nif (flags & DN_RT_PKT_CNTL) {\r\nif (unlikely(skb_linearize(skb)))\r\ngoto dump_it;\r\nswitch (flags & DN_RT_CNTL_MSK) {\r\ncase DN_RT_PKT_INIT:\r\ndn_dev_init_pkt(skb);\r\nbreak;\r\ncase DN_RT_PKT_VERI:\r\ndn_dev_veri_pkt(skb);\r\nbreak;\r\n}\r\nif (dn->parms.state != DN_DEV_S_RU)\r\ngoto dump_it;\r\nswitch (flags & DN_RT_CNTL_MSK) {\r\ncase DN_RT_PKT_HELO:\r\nreturn NF_HOOK(NFPROTO_DECNET, NF_DN_HELLO,\r\n&init_net, NULL, skb, skb->dev, NULL,\r\ndn_route_ptp_hello);\r\ncase DN_RT_PKT_L1RT:\r\ncase DN_RT_PKT_L2RT:\r\nreturn NF_HOOK(NFPROTO_DECNET, NF_DN_ROUTE,\r\n&init_net, NULL, skb, skb->dev, NULL,\r\ndn_route_discard);\r\ncase DN_RT_PKT_ERTH:\r\nreturn NF_HOOK(NFPROTO_DECNET, NF_DN_HELLO,\r\n&init_net, NULL, skb, skb->dev, NULL,\r\ndn_neigh_router_hello);\r\ncase DN_RT_PKT_EEDH:\r\nreturn NF_HOOK(NFPROTO_DECNET, NF_DN_HELLO,\r\n&init_net, NULL, skb, skb->dev, NULL,\r\ndn_neigh_endnode_hello);\r\n}\r\n} else {\r\nif (dn->parms.state != DN_DEV_S_RU)\r\ngoto dump_it;\r\nskb_pull(skb, 1);\r\nswitch (flags & DN_RT_PKT_MSK) {\r\ncase DN_RT_PKT_LONG:\r\nreturn dn_route_rx_long(skb);\r\ncase DN_RT_PKT_SHORT:\r\nreturn dn_route_rx_short(skb);\r\n}\r\n}\r\ndump_it:\r\nkfree_skb(skb);\r\nout:\r\nreturn NET_RX_DROP;\r\n}\r\nstatic int dn_output(struct net *net, struct sock *sk, struct sk_buff *skb)\r\n{\r\nstruct dst_entry *dst = skb_dst(skb);\r\nstruct dn_route *rt = (struct dn_route *)dst;\r\nstruct net_device *dev = dst->dev;\r\nstruct dn_skb_cb *cb = DN_SKB_CB(skb);\r\nint err = -EINVAL;\r\nif (rt->n == NULL)\r\ngoto error;\r\nskb->dev = dev;\r\ncb->src = rt->rt_saddr;\r\ncb->dst = rt->rt_daddr;\r\ncb->rt_flags &= ~DN_RT_F_RQR;\r\ncb->rt_flags |= DN_RT_F_IE;\r\ncb->hops = 0;\r\nreturn NF_HOOK(NFPROTO_DECNET, NF_DN_LOCAL_OUT,\r\n&init_net, sk, skb, NULL, dev,\r\ndn_to_neigh_output);\r\nerror:\r\nnet_dbg_ratelimited("dn_output: This should not happen\n");\r\nkfree_skb(skb);\r\nreturn err;\r\n}\r\nstatic int dn_forward(struct sk_buff *skb)\r\n{\r\nstruct dn_skb_cb *cb = DN_SKB_CB(skb);\r\nstruct dst_entry *dst = skb_dst(skb);\r\nstruct dn_dev *dn_db = rcu_dereference(dst->dev->dn_ptr);\r\nstruct dn_route *rt;\r\nint header_len;\r\nstruct net_device *dev = skb->dev;\r\nif (skb->pkt_type != PACKET_HOST)\r\ngoto drop;\r\nrt = (struct dn_route *)skb_dst(skb);\r\nheader_len = dn_db->use_long ? 21 : 6;\r\nif (skb_cow(skb, LL_RESERVED_SPACE(rt->dst.dev)+header_len))\r\ngoto drop;\r\nif (++cb->hops > 30)\r\ngoto drop;\r\nskb->dev = rt->dst.dev;\r\ncb->rt_flags &= ~DN_RT_F_IE;\r\nif (rt->rt_flags & RTCF_DOREDIRECT)\r\ncb->rt_flags |= DN_RT_F_IE;\r\nreturn NF_HOOK(NFPROTO_DECNET, NF_DN_FORWARD,\r\n&init_net, NULL, skb, dev, skb->dev,\r\ndn_to_neigh_output);\r\ndrop:\r\nkfree_skb(skb);\r\nreturn NET_RX_DROP;\r\n}\r\nstatic int dn_rt_bug_out(struct net *net, struct sock *sk, struct sk_buff *skb)\r\n{\r\nstruct dn_skb_cb *cb = DN_SKB_CB(skb);\r\nnet_dbg_ratelimited("dn_rt_bug: skb from:%04x to:%04x\n",\r\nle16_to_cpu(cb->src), le16_to_cpu(cb->dst));\r\nkfree_skb(skb);\r\nreturn NET_RX_DROP;\r\n}\r\nstatic int dn_rt_bug(struct sk_buff *skb)\r\n{\r\nstruct dn_skb_cb *cb = DN_SKB_CB(skb);\r\nnet_dbg_ratelimited("dn_rt_bug: skb from:%04x to:%04x\n",\r\nle16_to_cpu(cb->src), le16_to_cpu(cb->dst));\r\nkfree_skb(skb);\r\nreturn NET_RX_DROP;\r\n}\r\nstatic unsigned int dn_dst_default_advmss(const struct dst_entry *dst)\r\n{\r\nreturn dn_mss_from_pmtu(dst->dev, dst_mtu(dst));\r\n}\r\nstatic unsigned int dn_dst_mtu(const struct dst_entry *dst)\r\n{\r\nunsigned int mtu = dst_metric_raw(dst, RTAX_MTU);\r\nreturn mtu ? : dst->dev->mtu;\r\n}\r\nstatic struct neighbour *dn_dst_neigh_lookup(const struct dst_entry *dst,\r\nstruct sk_buff *skb,\r\nconst void *daddr)\r\n{\r\nreturn __neigh_lookup_errno(&dn_neigh_table, daddr, dst->dev);\r\n}\r\nstatic int dn_rt_set_next_hop(struct dn_route *rt, struct dn_fib_res *res)\r\n{\r\nstruct dn_fib_info *fi = res->fi;\r\nstruct net_device *dev = rt->dst.dev;\r\nunsigned int mss_metric;\r\nstruct neighbour *n;\r\nif (fi) {\r\nif (DN_FIB_RES_GW(*res) &&\r\nDN_FIB_RES_NH(*res).nh_scope == RT_SCOPE_LINK)\r\nrt->rt_gateway = DN_FIB_RES_GW(*res);\r\ndst_init_metrics(&rt->dst, fi->fib_metrics, true);\r\n}\r\nrt->rt_type = res->type;\r\nif (dev != NULL && rt->n == NULL) {\r\nn = __neigh_lookup_errno(&dn_neigh_table, &rt->rt_gateway, dev);\r\nif (IS_ERR(n))\r\nreturn PTR_ERR(n);\r\nrt->n = n;\r\n}\r\nif (dst_metric(&rt->dst, RTAX_MTU) > rt->dst.dev->mtu)\r\ndst_metric_set(&rt->dst, RTAX_MTU, rt->dst.dev->mtu);\r\nmss_metric = dst_metric_raw(&rt->dst, RTAX_ADVMSS);\r\nif (mss_metric) {\r\nunsigned int mss = dn_mss_from_pmtu(dev, dst_mtu(&rt->dst));\r\nif (mss_metric > mss)\r\ndst_metric_set(&rt->dst, RTAX_ADVMSS, mss);\r\n}\r\nreturn 0;\r\n}\r\nstatic inline int dn_match_addr(__le16 addr1, __le16 addr2)\r\n{\r\n__u16 tmp = le16_to_cpu(addr1) ^ le16_to_cpu(addr2);\r\nint match = 16;\r\nwhile(tmp) {\r\ntmp >>= 1;\r\nmatch--;\r\n}\r\nreturn match;\r\n}\r\nstatic __le16 dnet_select_source(const struct net_device *dev, __le16 daddr, int scope)\r\n{\r\n__le16 saddr = 0;\r\nstruct dn_dev *dn_db;\r\nstruct dn_ifaddr *ifa;\r\nint best_match = 0;\r\nint ret;\r\nrcu_read_lock();\r\ndn_db = rcu_dereference(dev->dn_ptr);\r\nfor (ifa = rcu_dereference(dn_db->ifa_list);\r\nifa != NULL;\r\nifa = rcu_dereference(ifa->ifa_next)) {\r\nif (ifa->ifa_scope > scope)\r\ncontinue;\r\nif (!daddr) {\r\nsaddr = ifa->ifa_local;\r\nbreak;\r\n}\r\nret = dn_match_addr(daddr, ifa->ifa_local);\r\nif (ret > best_match)\r\nsaddr = ifa->ifa_local;\r\nif (best_match == 0)\r\nsaddr = ifa->ifa_local;\r\n}\r\nrcu_read_unlock();\r\nreturn saddr;\r\n}\r\nstatic inline __le16 __dn_fib_res_prefsrc(struct dn_fib_res *res)\r\n{\r\nreturn dnet_select_source(DN_FIB_RES_DEV(*res), DN_FIB_RES_GW(*res), res->scope);\r\n}\r\nstatic inline __le16 dn_fib_rules_map_destination(__le16 daddr, struct dn_fib_res *res)\r\n{\r\n__le16 mask = dnet_make_mask(res->prefixlen);\r\nreturn (daddr&~mask)|res->fi->fib_nh->nh_gw;\r\n}\r\nstatic int dn_route_output_slow(struct dst_entry **pprt, const struct flowidn *oldflp, int try_hard)\r\n{\r\nstruct flowidn fld = {\r\n.daddr = oldflp->daddr,\r\n.saddr = oldflp->saddr,\r\n.flowidn_scope = RT_SCOPE_UNIVERSE,\r\n.flowidn_mark = oldflp->flowidn_mark,\r\n.flowidn_iif = LOOPBACK_IFINDEX,\r\n.flowidn_oif = oldflp->flowidn_oif,\r\n};\r\nstruct dn_route *rt = NULL;\r\nstruct net_device *dev_out = NULL, *dev;\r\nstruct neighbour *neigh = NULL;\r\nunsigned int hash;\r\nunsigned int flags = 0;\r\nstruct dn_fib_res res = { .fi = NULL, .type = RTN_UNICAST };\r\nint err;\r\nint free_res = 0;\r\n__le16 gateway = 0;\r\nif (decnet_debug_level & 16)\r\nprintk(KERN_DEBUG\r\n"dn_route_output_slow: dst=%04x src=%04x mark=%d"\r\n" iif=%d oif=%d\n", le16_to_cpu(oldflp->daddr),\r\nle16_to_cpu(oldflp->saddr),\r\noldflp->flowidn_mark, LOOPBACK_IFINDEX,\r\noldflp->flowidn_oif);\r\nif (oldflp->flowidn_oif) {\r\ndev_out = dev_get_by_index(&init_net, oldflp->flowidn_oif);\r\nerr = -ENODEV;\r\nif (dev_out && dev_out->dn_ptr == NULL) {\r\ndev_put(dev_out);\r\ndev_out = NULL;\r\n}\r\nif (dev_out == NULL)\r\ngoto out;\r\n}\r\nif (oldflp->saddr) {\r\nerr = -EADDRNOTAVAIL;\r\nif (dev_out) {\r\nif (dn_dev_islocal(dev_out, oldflp->saddr))\r\ngoto source_ok;\r\ndev_put(dev_out);\r\ngoto out;\r\n}\r\nrcu_read_lock();\r\nfor_each_netdev_rcu(&init_net, dev) {\r\nif (!dev->dn_ptr)\r\ncontinue;\r\nif (!dn_dev_islocal(dev, oldflp->saddr))\r\ncontinue;\r\nif ((dev->flags & IFF_LOOPBACK) &&\r\noldflp->daddr &&\r\n!dn_dev_islocal(dev, oldflp->daddr))\r\ncontinue;\r\ndev_out = dev;\r\nbreak;\r\n}\r\nrcu_read_unlock();\r\nif (dev_out == NULL)\r\ngoto out;\r\ndev_hold(dev_out);\r\nsource_ok:\r\n;\r\n}\r\nif (!fld.daddr) {\r\nfld.daddr = fld.saddr;\r\nerr = -EADDRNOTAVAIL;\r\nif (dev_out)\r\ndev_put(dev_out);\r\ndev_out = init_net.loopback_dev;\r\ndev_hold(dev_out);\r\nif (!fld.daddr) {\r\nfld.daddr =\r\nfld.saddr = dnet_select_source(dev_out, 0,\r\nRT_SCOPE_HOST);\r\nif (!fld.daddr)\r\ngoto out;\r\n}\r\nfld.flowidn_oif = LOOPBACK_IFINDEX;\r\nres.type = RTN_LOCAL;\r\ngoto make_route;\r\n}\r\nif (decnet_debug_level & 16)\r\nprintk(KERN_DEBUG\r\n"dn_route_output_slow: initial checks complete."\r\n" dst=%04x src=%04x oif=%d try_hard=%d\n",\r\nle16_to_cpu(fld.daddr), le16_to_cpu(fld.saddr),\r\nfld.flowidn_oif, try_hard);\r\nerr = -ESRCH;\r\nif (try_hard || (err = dn_fib_lookup(&fld, &res)) != 0) {\r\nstruct dn_dev *dn_db;\r\nif (err != -ESRCH)\r\ngoto out;\r\nif (!try_hard) {\r\nneigh = neigh_lookup_nodev(&dn_neigh_table, &init_net, &fld.daddr);\r\nif (neigh) {\r\nif ((oldflp->flowidn_oif &&\r\n(neigh->dev->ifindex != oldflp->flowidn_oif)) ||\r\n(oldflp->saddr &&\r\n(!dn_dev_islocal(neigh->dev,\r\noldflp->saddr)))) {\r\nneigh_release(neigh);\r\nneigh = NULL;\r\n} else {\r\nif (dev_out)\r\ndev_put(dev_out);\r\nif (dn_dev_islocal(neigh->dev, fld.daddr)) {\r\ndev_out = init_net.loopback_dev;\r\nres.type = RTN_LOCAL;\r\n} else {\r\ndev_out = neigh->dev;\r\n}\r\ndev_hold(dev_out);\r\ngoto select_source;\r\n}\r\n}\r\n}\r\nif (dev_out == NULL)\r\ndev_out = dn_dev_get_default();\r\nerr = -ENODEV;\r\nif (dev_out == NULL)\r\ngoto out;\r\ndn_db = rcu_dereference_raw(dev_out->dn_ptr);\r\nif (dn_dev_islocal(dev_out, fld.daddr)) {\r\ndev_put(dev_out);\r\ndev_out = init_net.loopback_dev;\r\ndev_hold(dev_out);\r\nres.type = RTN_LOCAL;\r\ngoto select_source;\r\n}\r\nneigh = neigh_clone(dn_db->router);\r\nBUG_ON(neigh && neigh->dev != dev_out);\r\nselect_source:\r\nif (neigh)\r\ngateway = ((struct dn_neigh *)neigh)->addr;\r\nif (gateway == 0)\r\ngateway = fld.daddr;\r\nif (fld.saddr == 0) {\r\nfld.saddr = dnet_select_source(dev_out, gateway,\r\nres.type == RTN_LOCAL ?\r\nRT_SCOPE_HOST :\r\nRT_SCOPE_LINK);\r\nif (fld.saddr == 0 && res.type != RTN_LOCAL)\r\ngoto e_addr;\r\n}\r\nfld.flowidn_oif = dev_out->ifindex;\r\ngoto make_route;\r\n}\r\nfree_res = 1;\r\nif (res.type == RTN_NAT)\r\ngoto e_inval;\r\nif (res.type == RTN_LOCAL) {\r\nif (!fld.saddr)\r\nfld.saddr = fld.daddr;\r\nif (dev_out)\r\ndev_put(dev_out);\r\ndev_out = init_net.loopback_dev;\r\ndev_hold(dev_out);\r\nfld.flowidn_oif = dev_out->ifindex;\r\nif (res.fi)\r\ndn_fib_info_put(res.fi);\r\nres.fi = NULL;\r\ngoto make_route;\r\n}\r\nif (res.fi->fib_nhs > 1 && fld.flowidn_oif == 0)\r\ndn_fib_select_multipath(&fld, &res);\r\nif (!fld.saddr)\r\nfld.saddr = DN_FIB_RES_PREFSRC(res);\r\nif (dev_out)\r\ndev_put(dev_out);\r\ndev_out = DN_FIB_RES_DEV(res);\r\ndev_hold(dev_out);\r\nfld.flowidn_oif = dev_out->ifindex;\r\ngateway = DN_FIB_RES_GW(res);\r\nmake_route:\r\nif (dev_out->flags & IFF_LOOPBACK)\r\nflags |= RTCF_LOCAL;\r\nrt = dst_alloc(&dn_dst_ops, dev_out, 1, DST_OBSOLETE_NONE, DST_HOST);\r\nif (rt == NULL)\r\ngoto e_nobufs;\r\nmemset(&rt->fld, 0, sizeof(rt->fld));\r\nrt->fld.saddr = oldflp->saddr;\r\nrt->fld.daddr = oldflp->daddr;\r\nrt->fld.flowidn_oif = oldflp->flowidn_oif;\r\nrt->fld.flowidn_iif = 0;\r\nrt->fld.flowidn_mark = oldflp->flowidn_mark;\r\nrt->rt_saddr = fld.saddr;\r\nrt->rt_daddr = fld.daddr;\r\nrt->rt_gateway = gateway ? gateway : fld.daddr;\r\nrt->rt_local_src = fld.saddr;\r\nrt->rt_dst_map = fld.daddr;\r\nrt->rt_src_map = fld.saddr;\r\nrt->n = neigh;\r\nneigh = NULL;\r\nrt->dst.lastuse = jiffies;\r\nrt->dst.output = dn_output;\r\nrt->dst.input = dn_rt_bug;\r\nrt->rt_flags = flags;\r\nif (flags & RTCF_LOCAL)\r\nrt->dst.input = dn_nsp_rx;\r\nerr = dn_rt_set_next_hop(rt, &res);\r\nif (err)\r\ngoto e_neighbour;\r\nhash = dn_hash(rt->fld.saddr, rt->fld.daddr);\r\ndn_insert_route(rt, hash, (struct dn_route **)pprt);\r\ndone:\r\nif (neigh)\r\nneigh_release(neigh);\r\nif (free_res)\r\ndn_fib_res_put(&res);\r\nif (dev_out)\r\ndev_put(dev_out);\r\nout:\r\nreturn err;\r\ne_addr:\r\nerr = -EADDRNOTAVAIL;\r\ngoto done;\r\ne_inval:\r\nerr = -EINVAL;\r\ngoto done;\r\ne_nobufs:\r\nerr = -ENOBUFS;\r\ngoto done;\r\ne_neighbour:\r\ndst_free(&rt->dst);\r\ngoto e_nobufs;\r\n}\r\nstatic int __dn_route_output_key(struct dst_entry **pprt, const struct flowidn *flp, int flags)\r\n{\r\nunsigned int hash = dn_hash(flp->saddr, flp->daddr);\r\nstruct dn_route *rt = NULL;\r\nif (!(flags & MSG_TRYHARD)) {\r\nrcu_read_lock_bh();\r\nfor (rt = rcu_dereference_bh(dn_rt_hash_table[hash].chain); rt;\r\nrt = rcu_dereference_bh(rt->dst.dn_next)) {\r\nif ((flp->daddr == rt->fld.daddr) &&\r\n(flp->saddr == rt->fld.saddr) &&\r\n(flp->flowidn_mark == rt->fld.flowidn_mark) &&\r\ndn_is_output_route(rt) &&\r\n(rt->fld.flowidn_oif == flp->flowidn_oif)) {\r\ndst_use(&rt->dst, jiffies);\r\nrcu_read_unlock_bh();\r\n*pprt = &rt->dst;\r\nreturn 0;\r\n}\r\n}\r\nrcu_read_unlock_bh();\r\n}\r\nreturn dn_route_output_slow(pprt, flp, flags);\r\n}\r\nstatic int dn_route_output_key(struct dst_entry **pprt, struct flowidn *flp, int flags)\r\n{\r\nint err;\r\nerr = __dn_route_output_key(pprt, flp, flags);\r\nif (err == 0 && flp->flowidn_proto) {\r\n*pprt = xfrm_lookup(&init_net, *pprt,\r\nflowidn_to_flowi(flp), NULL, 0);\r\nif (IS_ERR(*pprt)) {\r\nerr = PTR_ERR(*pprt);\r\n*pprt = NULL;\r\n}\r\n}\r\nreturn err;\r\n}\r\nint dn_route_output_sock(struct dst_entry __rcu **pprt, struct flowidn *fl, struct sock *sk, int flags)\r\n{\r\nint err;\r\nerr = __dn_route_output_key(pprt, fl, flags & MSG_TRYHARD);\r\nif (err == 0 && fl->flowidn_proto) {\r\n*pprt = xfrm_lookup(&init_net, *pprt,\r\nflowidn_to_flowi(fl), sk, 0);\r\nif (IS_ERR(*pprt)) {\r\nerr = PTR_ERR(*pprt);\r\n*pprt = NULL;\r\n}\r\n}\r\nreturn err;\r\n}\r\nstatic int dn_route_input_slow(struct sk_buff *skb)\r\n{\r\nstruct dn_route *rt = NULL;\r\nstruct dn_skb_cb *cb = DN_SKB_CB(skb);\r\nstruct net_device *in_dev = skb->dev;\r\nstruct net_device *out_dev = NULL;\r\nstruct dn_dev *dn_db;\r\nstruct neighbour *neigh = NULL;\r\nunsigned int hash;\r\nint flags = 0;\r\n__le16 gateway = 0;\r\n__le16 local_src = 0;\r\nstruct flowidn fld = {\r\n.daddr = cb->dst,\r\n.saddr = cb->src,\r\n.flowidn_scope = RT_SCOPE_UNIVERSE,\r\n.flowidn_mark = skb->mark,\r\n.flowidn_iif = skb->dev->ifindex,\r\n};\r\nstruct dn_fib_res res = { .fi = NULL, .type = RTN_UNREACHABLE };\r\nint err = -EINVAL;\r\nint free_res = 0;\r\ndev_hold(in_dev);\r\nif ((dn_db = rcu_dereference(in_dev->dn_ptr)) == NULL)\r\ngoto out;\r\nif (fld.saddr == 0)\r\ngoto out;\r\nerr = -ENOTUNIQ;\r\nif (dn_dev_islocal(in_dev, cb->src))\r\ngoto out;\r\nerr = dn_fib_lookup(&fld, &res);\r\nif (err) {\r\nif (err != -ESRCH)\r\ngoto out;\r\nif (!dn_dev_islocal(in_dev, cb->dst))\r\ngoto e_inval;\r\nres.type = RTN_LOCAL;\r\n} else {\r\n__le16 src_map = fld.saddr;\r\nfree_res = 1;\r\nout_dev = DN_FIB_RES_DEV(res);\r\nif (out_dev == NULL) {\r\nnet_crit_ratelimited("Bug in dn_route_input_slow() No output device\n");\r\ngoto e_inval;\r\n}\r\ndev_hold(out_dev);\r\nif (res.r)\r\nsrc_map = fld.saddr;\r\ngateway = DN_FIB_RES_GW(res);\r\nif (res.type == RTN_NAT) {\r\nfld.daddr = dn_fib_rules_map_destination(fld.daddr, &res);\r\ndn_fib_res_put(&res);\r\nfree_res = 0;\r\nif (dn_fib_lookup(&fld, &res))\r\ngoto e_inval;\r\nfree_res = 1;\r\nif (res.type != RTN_UNICAST)\r\ngoto e_inval;\r\nflags |= RTCF_DNAT;\r\ngateway = fld.daddr;\r\n}\r\nfld.saddr = src_map;\r\n}\r\nswitch(res.type) {\r\ncase RTN_UNICAST:\r\nif (dn_db->parms.forwarding == 0)\r\ngoto e_inval;\r\nif (res.fi->fib_nhs > 1 && fld.flowidn_oif == 0)\r\ndn_fib_select_multipath(&fld, &res);\r\nif (out_dev == in_dev && !(flags & RTCF_NAT))\r\nflags |= RTCF_DOREDIRECT;\r\nlocal_src = DN_FIB_RES_PREFSRC(res);\r\ncase RTN_BLACKHOLE:\r\ncase RTN_UNREACHABLE:\r\nbreak;\r\ncase RTN_LOCAL:\r\nflags |= RTCF_LOCAL;\r\nfld.saddr = cb->dst;\r\nfld.daddr = cb->src;\r\nif (gateway)\r\ngoto make_route;\r\nif (cb->rt_flags & DN_RT_F_IE) {\r\ngateway = cb->src;\r\ngoto make_route;\r\n}\r\nneigh = neigh_clone(dn_db->router);\r\nif (neigh) {\r\ngateway = ((struct dn_neigh *)neigh)->addr;\r\ngoto make_route;\r\n}\r\ngateway = cb->src;\r\ngoto make_route;\r\ndefault:\r\ngoto e_inval;\r\n}\r\nmake_route:\r\nrt = dst_alloc(&dn_dst_ops, out_dev, 0, DST_OBSOLETE_NONE, DST_HOST);\r\nif (rt == NULL)\r\ngoto e_nobufs;\r\nmemset(&rt->fld, 0, sizeof(rt->fld));\r\nrt->rt_saddr = fld.saddr;\r\nrt->rt_daddr = fld.daddr;\r\nrt->rt_gateway = fld.daddr;\r\nif (gateway)\r\nrt->rt_gateway = gateway;\r\nrt->rt_local_src = local_src ? local_src : rt->rt_saddr;\r\nrt->rt_dst_map = fld.daddr;\r\nrt->rt_src_map = fld.saddr;\r\nrt->fld.saddr = cb->src;\r\nrt->fld.daddr = cb->dst;\r\nrt->fld.flowidn_oif = 0;\r\nrt->fld.flowidn_iif = in_dev->ifindex;\r\nrt->fld.flowidn_mark = fld.flowidn_mark;\r\nrt->n = neigh;\r\nrt->dst.lastuse = jiffies;\r\nrt->dst.output = dn_rt_bug_out;\r\nswitch (res.type) {\r\ncase RTN_UNICAST:\r\nrt->dst.input = dn_forward;\r\nbreak;\r\ncase RTN_LOCAL:\r\nrt->dst.output = dn_output;\r\nrt->dst.input = dn_nsp_rx;\r\nrt->dst.dev = in_dev;\r\nflags |= RTCF_LOCAL;\r\nbreak;\r\ndefault:\r\ncase RTN_UNREACHABLE:\r\ncase RTN_BLACKHOLE:\r\nrt->dst.input = dst_discard;\r\n}\r\nrt->rt_flags = flags;\r\nerr = dn_rt_set_next_hop(rt, &res);\r\nif (err)\r\ngoto e_neighbour;\r\nhash = dn_hash(rt->fld.saddr, rt->fld.daddr);\r\ndn_insert_route(rt, hash, &rt);\r\nskb_dst_set(skb, &rt->dst);\r\ndone:\r\nif (neigh)\r\nneigh_release(neigh);\r\nif (free_res)\r\ndn_fib_res_put(&res);\r\ndev_put(in_dev);\r\nif (out_dev)\r\ndev_put(out_dev);\r\nout:\r\nreturn err;\r\ne_inval:\r\nerr = -EINVAL;\r\ngoto done;\r\ne_nobufs:\r\nerr = -ENOBUFS;\r\ngoto done;\r\ne_neighbour:\r\ndst_free(&rt->dst);\r\ngoto done;\r\n}\r\nstatic int dn_route_input(struct sk_buff *skb)\r\n{\r\nstruct dn_route *rt;\r\nstruct dn_skb_cb *cb = DN_SKB_CB(skb);\r\nunsigned int hash = dn_hash(cb->src, cb->dst);\r\nif (skb_dst(skb))\r\nreturn 0;\r\nrcu_read_lock();\r\nfor(rt = rcu_dereference(dn_rt_hash_table[hash].chain); rt != NULL;\r\nrt = rcu_dereference(rt->dst.dn_next)) {\r\nif ((rt->fld.saddr == cb->src) &&\r\n(rt->fld.daddr == cb->dst) &&\r\n(rt->fld.flowidn_oif == 0) &&\r\n(rt->fld.flowidn_mark == skb->mark) &&\r\n(rt->fld.flowidn_iif == cb->iif)) {\r\ndst_use(&rt->dst, jiffies);\r\nrcu_read_unlock();\r\nskb_dst_set(skb, (struct dst_entry *)rt);\r\nreturn 0;\r\n}\r\n}\r\nrcu_read_unlock();\r\nreturn dn_route_input_slow(skb);\r\n}\r\nstatic int dn_rt_fill_info(struct sk_buff *skb, u32 portid, u32 seq,\r\nint event, int nowait, unsigned int flags)\r\n{\r\nstruct dn_route *rt = (struct dn_route *)skb_dst(skb);\r\nstruct rtmsg *r;\r\nstruct nlmsghdr *nlh;\r\nlong expires;\r\nnlh = nlmsg_put(skb, portid, seq, event, sizeof(*r), flags);\r\nif (!nlh)\r\nreturn -EMSGSIZE;\r\nr = nlmsg_data(nlh);\r\nr->rtm_family = AF_DECnet;\r\nr->rtm_dst_len = 16;\r\nr->rtm_src_len = 0;\r\nr->rtm_tos = 0;\r\nr->rtm_table = RT_TABLE_MAIN;\r\nr->rtm_type = rt->rt_type;\r\nr->rtm_flags = (rt->rt_flags & ~0xFFFF) | RTM_F_CLONED;\r\nr->rtm_scope = RT_SCOPE_UNIVERSE;\r\nr->rtm_protocol = RTPROT_UNSPEC;\r\nif (rt->rt_flags & RTCF_NOTIFY)\r\nr->rtm_flags |= RTM_F_NOTIFY;\r\nif (nla_put_u32(skb, RTA_TABLE, RT_TABLE_MAIN) < 0 ||\r\nnla_put_le16(skb, RTA_DST, rt->rt_daddr) < 0)\r\ngoto errout;\r\nif (rt->fld.saddr) {\r\nr->rtm_src_len = 16;\r\nif (nla_put_le16(skb, RTA_SRC, rt->fld.saddr) < 0)\r\ngoto errout;\r\n}\r\nif (rt->dst.dev &&\r\nnla_put_u32(skb, RTA_OIF, rt->dst.dev->ifindex) < 0)\r\ngoto errout;\r\nif (nla_put_le16(skb, RTA_PREFSRC, rt->rt_local_src) < 0)\r\ngoto errout;\r\nif (rt->rt_daddr != rt->rt_gateway &&\r\nnla_put_le16(skb, RTA_GATEWAY, rt->rt_gateway) < 0)\r\ngoto errout;\r\nif (rtnetlink_put_metrics(skb, dst_metrics_ptr(&rt->dst)) < 0)\r\ngoto errout;\r\nexpires = rt->dst.expires ? rt->dst.expires - jiffies : 0;\r\nif (rtnl_put_cacheinfo(skb, &rt->dst, 0, expires,\r\nrt->dst.error) < 0)\r\ngoto errout;\r\nif (dn_is_input_route(rt) &&\r\nnla_put_u32(skb, RTA_IIF, rt->fld.flowidn_iif) < 0)\r\ngoto errout;\r\nnlmsg_end(skb, nlh);\r\nreturn 0;\r\nerrout:\r\nnlmsg_cancel(skb, nlh);\r\nreturn -EMSGSIZE;\r\n}\r\nstatic int dn_cache_getroute(struct sk_buff *in_skb, struct nlmsghdr *nlh)\r\n{\r\nstruct net *net = sock_net(in_skb->sk);\r\nstruct rtmsg *rtm = nlmsg_data(nlh);\r\nstruct dn_route *rt = NULL;\r\nstruct dn_skb_cb *cb;\r\nint err;\r\nstruct sk_buff *skb;\r\nstruct flowidn fld;\r\nstruct nlattr *tb[RTA_MAX+1];\r\nif (!net_eq(net, &init_net))\r\nreturn -EINVAL;\r\nerr = nlmsg_parse(nlh, sizeof(*rtm), tb, RTA_MAX, rtm_dn_policy);\r\nif (err < 0)\r\nreturn err;\r\nmemset(&fld, 0, sizeof(fld));\r\nfld.flowidn_proto = DNPROTO_NSP;\r\nskb = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);\r\nif (skb == NULL)\r\nreturn -ENOBUFS;\r\nskb_reset_mac_header(skb);\r\ncb = DN_SKB_CB(skb);\r\nif (tb[RTA_SRC])\r\nfld.saddr = nla_get_le16(tb[RTA_SRC]);\r\nif (tb[RTA_DST])\r\nfld.daddr = nla_get_le16(tb[RTA_DST]);\r\nif (tb[RTA_IIF])\r\nfld.flowidn_iif = nla_get_u32(tb[RTA_IIF]);\r\nif (fld.flowidn_iif) {\r\nstruct net_device *dev;\r\ndev = __dev_get_by_index(&init_net, fld.flowidn_iif);\r\nif (!dev || !dev->dn_ptr) {\r\nkfree_skb(skb);\r\nreturn -ENODEV;\r\n}\r\nskb->protocol = htons(ETH_P_DNA_RT);\r\nskb->dev = dev;\r\ncb->src = fld.saddr;\r\ncb->dst = fld.daddr;\r\nlocal_bh_disable();\r\nerr = dn_route_input(skb);\r\nlocal_bh_enable();\r\nmemset(cb, 0, sizeof(struct dn_skb_cb));\r\nrt = (struct dn_route *)skb_dst(skb);\r\nif (!err && -rt->dst.error)\r\nerr = rt->dst.error;\r\n} else {\r\nif (tb[RTA_OIF])\r\nfld.flowidn_oif = nla_get_u32(tb[RTA_OIF]);\r\nerr = dn_route_output_key((struct dst_entry **)&rt, &fld, 0);\r\n}\r\nskb->dev = NULL;\r\nif (err)\r\ngoto out_free;\r\nskb_dst_set(skb, &rt->dst);\r\nif (rtm->rtm_flags & RTM_F_NOTIFY)\r\nrt->rt_flags |= RTCF_NOTIFY;\r\nerr = dn_rt_fill_info(skb, NETLINK_CB(in_skb).portid, nlh->nlmsg_seq, RTM_NEWROUTE, 0, 0);\r\nif (err < 0) {\r\nerr = -EMSGSIZE;\r\ngoto out_free;\r\n}\r\nreturn rtnl_unicast(skb, &init_net, NETLINK_CB(in_skb).portid);\r\nout_free:\r\nkfree_skb(skb);\r\nreturn err;\r\n}\r\nint dn_cache_dump(struct sk_buff *skb, struct netlink_callback *cb)\r\n{\r\nstruct net *net = sock_net(skb->sk);\r\nstruct dn_route *rt;\r\nint h, s_h;\r\nint idx, s_idx;\r\nstruct rtmsg *rtm;\r\nif (!net_eq(net, &init_net))\r\nreturn 0;\r\nif (nlmsg_len(cb->nlh) < sizeof(struct rtmsg))\r\nreturn -EINVAL;\r\nrtm = nlmsg_data(cb->nlh);\r\nif (!(rtm->rtm_flags & RTM_F_CLONED))\r\nreturn 0;\r\ns_h = cb->args[0];\r\ns_idx = idx = cb->args[1];\r\nfor(h = 0; h <= dn_rt_hash_mask; h++) {\r\nif (h < s_h)\r\ncontinue;\r\nif (h > s_h)\r\ns_idx = 0;\r\nrcu_read_lock_bh();\r\nfor(rt = rcu_dereference_bh(dn_rt_hash_table[h].chain), idx = 0;\r\nrt;\r\nrt = rcu_dereference_bh(rt->dst.dn_next), idx++) {\r\nif (idx < s_idx)\r\ncontinue;\r\nskb_dst_set(skb, dst_clone(&rt->dst));\r\nif (dn_rt_fill_info(skb, NETLINK_CB(cb->skb).portid,\r\ncb->nlh->nlmsg_seq, RTM_NEWROUTE,\r\n1, NLM_F_MULTI) < 0) {\r\nskb_dst_drop(skb);\r\nrcu_read_unlock_bh();\r\ngoto done;\r\n}\r\nskb_dst_drop(skb);\r\n}\r\nrcu_read_unlock_bh();\r\n}\r\ndone:\r\ncb->args[0] = h;\r\ncb->args[1] = idx;\r\nreturn skb->len;\r\n}\r\nstatic struct dn_route *dn_rt_cache_get_first(struct seq_file *seq)\r\n{\r\nstruct dn_route *rt = NULL;\r\nstruct dn_rt_cache_iter_state *s = seq->private;\r\nfor(s->bucket = dn_rt_hash_mask; s->bucket >= 0; --s->bucket) {\r\nrcu_read_lock_bh();\r\nrt = rcu_dereference_bh(dn_rt_hash_table[s->bucket].chain);\r\nif (rt)\r\nbreak;\r\nrcu_read_unlock_bh();\r\n}\r\nreturn rt;\r\n}\r\nstatic struct dn_route *dn_rt_cache_get_next(struct seq_file *seq, struct dn_route *rt)\r\n{\r\nstruct dn_rt_cache_iter_state *s = seq->private;\r\nrt = rcu_dereference_bh(rt->dst.dn_next);\r\nwhile (!rt) {\r\nrcu_read_unlock_bh();\r\nif (--s->bucket < 0)\r\nbreak;\r\nrcu_read_lock_bh();\r\nrt = rcu_dereference_bh(dn_rt_hash_table[s->bucket].chain);\r\n}\r\nreturn rt;\r\n}\r\nstatic void *dn_rt_cache_seq_start(struct seq_file *seq, loff_t *pos)\r\n{\r\nstruct dn_route *rt = dn_rt_cache_get_first(seq);\r\nif (rt) {\r\nwhile(*pos && (rt = dn_rt_cache_get_next(seq, rt)))\r\n--*pos;\r\n}\r\nreturn *pos ? NULL : rt;\r\n}\r\nstatic void *dn_rt_cache_seq_next(struct seq_file *seq, void *v, loff_t *pos)\r\n{\r\nstruct dn_route *rt = dn_rt_cache_get_next(seq, v);\r\n++*pos;\r\nreturn rt;\r\n}\r\nstatic void dn_rt_cache_seq_stop(struct seq_file *seq, void *v)\r\n{\r\nif (v)\r\nrcu_read_unlock_bh();\r\n}\r\nstatic int dn_rt_cache_seq_show(struct seq_file *seq, void *v)\r\n{\r\nstruct dn_route *rt = v;\r\nchar buf1[DN_ASCBUF_LEN], buf2[DN_ASCBUF_LEN];\r\nseq_printf(seq, "%-8s %-7s %-7s %04d %04d %04d\n",\r\nrt->dst.dev ? rt->dst.dev->name : "*",\r\ndn_addr2asc(le16_to_cpu(rt->rt_daddr), buf1),\r\ndn_addr2asc(le16_to_cpu(rt->rt_saddr), buf2),\r\natomic_read(&rt->dst.__refcnt),\r\nrt->dst.__use, 0);\r\nreturn 0;\r\n}\r\nstatic int dn_rt_cache_seq_open(struct inode *inode, struct file *file)\r\n{\r\nreturn seq_open_private(file, &dn_rt_cache_seq_ops,\r\nsizeof(struct dn_rt_cache_iter_state));\r\n}\r\nvoid __init dn_route_init(void)\r\n{\r\nint i, goal, order;\r\ndn_dst_ops.kmem_cachep =\r\nkmem_cache_create("dn_dst_cache", sizeof(struct dn_route), 0,\r\nSLAB_HWCACHE_ALIGN|SLAB_PANIC, NULL);\r\ndst_entries_init(&dn_dst_ops);\r\nsetup_timer(&dn_route_timer, dn_dst_check_expire, 0);\r\ndn_route_timer.expires = jiffies + decnet_dst_gc_interval * HZ;\r\nadd_timer(&dn_route_timer);\r\ngoal = totalram_pages >> (26 - PAGE_SHIFT);\r\nfor(order = 0; (1UL << order) < goal; order++)\r\n;\r\nwhile(order && ((((1UL << order) * PAGE_SIZE) /\r\nsizeof(struct dn_rt_hash_bucket)) >= 2048))\r\norder--;\r\ndo {\r\ndn_rt_hash_mask = (1UL << order) * PAGE_SIZE /\r\nsizeof(struct dn_rt_hash_bucket);\r\nwhile(dn_rt_hash_mask & (dn_rt_hash_mask - 1))\r\ndn_rt_hash_mask--;\r\ndn_rt_hash_table = (struct dn_rt_hash_bucket *)\r\n__get_free_pages(GFP_ATOMIC, order);\r\n} while (dn_rt_hash_table == NULL && --order > 0);\r\nif (!dn_rt_hash_table)\r\npanic("Failed to allocate DECnet route cache hash table\n");\r\nprintk(KERN_INFO\r\n"DECnet: Routing cache hash table of %u buckets, %ldKbytes\n",\r\ndn_rt_hash_mask,\r\n(long)(dn_rt_hash_mask*sizeof(struct dn_rt_hash_bucket))/1024);\r\ndn_rt_hash_mask--;\r\nfor(i = 0; i <= dn_rt_hash_mask; i++) {\r\nspin_lock_init(&dn_rt_hash_table[i].lock);\r\ndn_rt_hash_table[i].chain = NULL;\r\n}\r\ndn_dst_ops.gc_thresh = (dn_rt_hash_mask + 1);\r\nproc_create("decnet_cache", S_IRUGO, init_net.proc_net,\r\n&dn_rt_cache_seq_fops);\r\n#ifdef CONFIG_DECNET_ROUTER\r\nrtnl_register(PF_DECnet, RTM_GETROUTE, dn_cache_getroute,\r\ndn_fib_dump, NULL);\r\n#else\r\nrtnl_register(PF_DECnet, RTM_GETROUTE, dn_cache_getroute,\r\ndn_cache_dump, NULL);\r\n#endif\r\n}\r\nvoid __exit dn_route_cleanup(void)\r\n{\r\ndel_timer(&dn_route_timer);\r\ndn_run_flush(0);\r\nremove_proc_entry("decnet_cache", init_net.proc_net);\r\ndst_entries_destroy(&dn_dst_ops);\r\n}
