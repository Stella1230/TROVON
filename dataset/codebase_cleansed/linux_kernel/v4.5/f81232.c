static int calc_baud_divisor(speed_t baudrate)\r\n{\r\nreturn DIV_ROUND_CLOSEST(F81232_MAX_BAUDRATE, baudrate);\r\n}\r\nstatic int f81232_get_register(struct usb_serial_port *port, u16 reg, u8 *val)\r\n{\r\nint status;\r\nu8 *tmp;\r\nstruct usb_device *dev = port->serial->dev;\r\ntmp = kmalloc(sizeof(*val), GFP_KERNEL);\r\nif (!tmp)\r\nreturn -ENOMEM;\r\nstatus = usb_control_msg(dev,\r\nusb_rcvctrlpipe(dev, 0),\r\nF81232_REGISTER_REQUEST,\r\nF81232_GET_REGISTER,\r\nreg,\r\n0,\r\ntmp,\r\nsizeof(*val),\r\nUSB_CTRL_GET_TIMEOUT);\r\nif (status != sizeof(*val)) {\r\ndev_err(&port->dev, "%s failed status: %d\n", __func__, status);\r\nif (status < 0)\r\nstatus = usb_translate_errors(status);\r\nelse\r\nstatus = -EIO;\r\n} else {\r\nstatus = 0;\r\n*val = *tmp;\r\n}\r\nkfree(tmp);\r\nreturn status;\r\n}\r\nstatic int f81232_set_register(struct usb_serial_port *port, u16 reg, u8 val)\r\n{\r\nint status;\r\nu8 *tmp;\r\nstruct usb_device *dev = port->serial->dev;\r\ntmp = kmalloc(sizeof(val), GFP_KERNEL);\r\nif (!tmp)\r\nreturn -ENOMEM;\r\n*tmp = val;\r\nstatus = usb_control_msg(dev,\r\nusb_sndctrlpipe(dev, 0),\r\nF81232_REGISTER_REQUEST,\r\nF81232_SET_REGISTER,\r\nreg,\r\n0,\r\ntmp,\r\nsizeof(val),\r\nUSB_CTRL_SET_TIMEOUT);\r\nif (status != sizeof(val)) {\r\ndev_err(&port->dev, "%s failed status: %d\n", __func__, status);\r\nif (status < 0)\r\nstatus = usb_translate_errors(status);\r\nelse\r\nstatus = -EIO;\r\n} else {\r\nstatus = 0;\r\n}\r\nkfree(tmp);\r\nreturn status;\r\n}\r\nstatic void f81232_read_msr(struct usb_serial_port *port)\r\n{\r\nint status;\r\nu8 current_msr;\r\nstruct tty_struct *tty;\r\nstruct f81232_private *priv = usb_get_serial_port_data(port);\r\nmutex_lock(&priv->lock);\r\nstatus = f81232_get_register(port, MODEM_STATUS_REGISTER,\r\n&current_msr);\r\nif (status) {\r\ndev_err(&port->dev, "%s fail, status: %d\n", __func__, status);\r\nmutex_unlock(&priv->lock);\r\nreturn;\r\n}\r\nif (!(current_msr & UART_MSR_ANY_DELTA)) {\r\nmutex_unlock(&priv->lock);\r\nreturn;\r\n}\r\npriv->modem_status = current_msr;\r\nif (current_msr & UART_MSR_DCTS)\r\nport->icount.cts++;\r\nif (current_msr & UART_MSR_DDSR)\r\nport->icount.dsr++;\r\nif (current_msr & UART_MSR_TERI)\r\nport->icount.rng++;\r\nif (current_msr & UART_MSR_DDCD) {\r\nport->icount.dcd++;\r\ntty = tty_port_tty_get(&port->port);\r\nif (tty) {\r\nusb_serial_handle_dcd_change(port, tty,\r\ncurrent_msr & UART_MSR_DCD);\r\ntty_kref_put(tty);\r\n}\r\n}\r\nwake_up_interruptible(&port->port.delta_msr_wait);\r\nmutex_unlock(&priv->lock);\r\n}\r\nstatic int f81232_set_mctrl(struct usb_serial_port *port,\r\nunsigned int set, unsigned int clear)\r\n{\r\nu8 val;\r\nint status;\r\nstruct f81232_private *priv = usb_get_serial_port_data(port);\r\nif (((set | clear) & (TIOCM_DTR | TIOCM_RTS)) == 0)\r\nreturn 0;\r\nclear &= ~set;\r\nmutex_lock(&priv->lock);\r\nval = UART_MCR_OUT2 | priv->modem_control;\r\nif (clear & TIOCM_DTR)\r\nval &= ~UART_MCR_DTR;\r\nif (clear & TIOCM_RTS)\r\nval &= ~UART_MCR_RTS;\r\nif (set & TIOCM_DTR)\r\nval |= UART_MCR_DTR;\r\nif (set & TIOCM_RTS)\r\nval |= UART_MCR_RTS;\r\ndev_dbg(&port->dev, "%s new:%02x old:%02x\n", __func__,\r\nval, priv->modem_control);\r\nstatus = f81232_set_register(port, MODEM_CONTROL_REGISTER, val);\r\nif (status) {\r\ndev_err(&port->dev, "%s set MCR status < 0\n", __func__);\r\nmutex_unlock(&priv->lock);\r\nreturn status;\r\n}\r\npriv->modem_control = val;\r\nmutex_unlock(&priv->lock);\r\nreturn 0;\r\n}\r\nstatic void f81232_update_line_status(struct usb_serial_port *port,\r\nunsigned char *data,\r\nsize_t actual_length)\r\n{\r\nstruct f81232_private *priv = usb_get_serial_port_data(port);\r\nif (!actual_length)\r\nreturn;\r\nswitch (data[0] & 0x07) {\r\ncase 0x00:\r\ndev_dbg(&port->dev, "IIR: MSR Change: %02x\n", data[0]);\r\nschedule_work(&priv->interrupt_work);\r\nbreak;\r\ncase 0x02:\r\nbreak;\r\ncase 0x04:\r\nbreak;\r\ncase 0x06:\r\ndev_dbg(&port->dev, "IIR: LSR Change: %02x\n", data[0]);\r\nbreak;\r\n}\r\n}\r\nstatic void f81232_read_int_callback(struct urb *urb)\r\n{\r\nstruct usb_serial_port *port = urb->context;\r\nunsigned char *data = urb->transfer_buffer;\r\nunsigned int actual_length = urb->actual_length;\r\nint status = urb->status;\r\nint retval;\r\nswitch (status) {\r\ncase 0:\r\nbreak;\r\ncase -ECONNRESET:\r\ncase -ENOENT:\r\ncase -ESHUTDOWN:\r\ndev_dbg(&port->dev, "%s - urb shutting down with status: %d\n",\r\n__func__, status);\r\nreturn;\r\ndefault:\r\ndev_dbg(&port->dev, "%s - nonzero urb status received: %d\n",\r\n__func__, status);\r\ngoto exit;\r\n}\r\nusb_serial_debug_data(&port->dev, __func__,\r\nurb->actual_length, urb->transfer_buffer);\r\nf81232_update_line_status(port, data, actual_length);\r\nexit:\r\nretval = usb_submit_urb(urb, GFP_ATOMIC);\r\nif (retval)\r\ndev_err(&urb->dev->dev,\r\n"%s - usb_submit_urb failed with result %d\n",\r\n__func__, retval);\r\n}\r\nstatic void f81232_process_read_urb(struct urb *urb)\r\n{\r\nstruct usb_serial_port *port = urb->context;\r\nunsigned char *data = urb->transfer_buffer;\r\nchar tty_flag;\r\nunsigned int i;\r\nu8 lsr;\r\nif ((urb->actual_length < 2) || (urb->actual_length % 2))\r\nreturn;\r\nfor (i = 0; i < urb->actual_length; i += 2) {\r\ntty_flag = TTY_NORMAL;\r\nlsr = data[i];\r\nif (lsr & UART_LSR_BRK_ERROR_BITS) {\r\nif (lsr & UART_LSR_BI) {\r\ntty_flag = TTY_BREAK;\r\nport->icount.brk++;\r\nusb_serial_handle_break(port);\r\n} else if (lsr & UART_LSR_PE) {\r\ntty_flag = TTY_PARITY;\r\nport->icount.parity++;\r\n} else if (lsr & UART_LSR_FE) {\r\ntty_flag = TTY_FRAME;\r\nport->icount.frame++;\r\n}\r\nif (lsr & UART_LSR_OE) {\r\nport->icount.overrun++;\r\ntty_insert_flip_char(&port->port, 0,\r\nTTY_OVERRUN);\r\n}\r\n}\r\nif (port->port.console && port->sysrq) {\r\nif (usb_serial_handle_sysrq_char(port, data[i + 1]))\r\ncontinue;\r\n}\r\ntty_insert_flip_char(&port->port, data[i + 1], tty_flag);\r\n}\r\ntty_flip_buffer_push(&port->port);\r\n}\r\nstatic void f81232_break_ctl(struct tty_struct *tty, int break_state)\r\n{\r\n}\r\nstatic void f81232_set_baudrate(struct usb_serial_port *port, speed_t baudrate)\r\n{\r\nu8 lcr;\r\nint divisor;\r\nint status = 0;\r\ndivisor = calc_baud_divisor(baudrate);\r\nstatus = f81232_get_register(port, LINE_CONTROL_REGISTER,\r\n&lcr);\r\nif (status) {\r\ndev_err(&port->dev, "%s failed to get LCR: %d\n",\r\n__func__, status);\r\nreturn;\r\n}\r\nstatus = f81232_set_register(port, LINE_CONTROL_REGISTER,\r\nlcr | UART_LCR_DLAB);\r\nif (status) {\r\ndev_err(&port->dev, "%s failed to set DLAB: %d\n",\r\n__func__, status);\r\nreturn;\r\n}\r\nstatus = f81232_set_register(port, RECEIVE_BUFFER_REGISTER,\r\ndivisor & 0x00ff);\r\nif (status) {\r\ndev_err(&port->dev, "%s failed to set baudrate MSB: %d\n",\r\n__func__, status);\r\ngoto reapply_lcr;\r\n}\r\nstatus = f81232_set_register(port, INTERRUPT_ENABLE_REGISTER,\r\n(divisor & 0xff00) >> 8);\r\nif (status) {\r\ndev_err(&port->dev, "%s failed to set baudrate LSB: %d\n",\r\n__func__, status);\r\n}\r\nreapply_lcr:\r\nstatus = f81232_set_register(port, LINE_CONTROL_REGISTER,\r\nlcr & ~UART_LCR_DLAB);\r\nif (status) {\r\ndev_err(&port->dev, "%s failed to set DLAB: %d\n",\r\n__func__, status);\r\n}\r\n}\r\nstatic int f81232_port_enable(struct usb_serial_port *port)\r\n{\r\nu8 val;\r\nint status;\r\nval = UART_FCR_TRIGGER_8 | UART_FCR_ENABLE_FIFO | UART_FCR_CLEAR_RCVR |\r\nUART_FCR_CLEAR_XMIT;\r\nstatus = f81232_set_register(port, FIFO_CONTROL_REGISTER, val);\r\nif (status) {\r\ndev_err(&port->dev, "%s failed to set FCR: %d\n",\r\n__func__, status);\r\nreturn status;\r\n}\r\nstatus = f81232_set_register(port, INTERRUPT_ENABLE_REGISTER,\r\nUART_IER_MSI);\r\nif (status) {\r\ndev_err(&port->dev, "%s failed to set IER: %d\n",\r\n__func__, status);\r\nreturn status;\r\n}\r\nreturn 0;\r\n}\r\nstatic int f81232_port_disable(struct usb_serial_port *port)\r\n{\r\nint status;\r\nstatus = f81232_set_register(port, INTERRUPT_ENABLE_REGISTER, 0);\r\nif (status) {\r\ndev_err(&port->dev, "%s failed to set IER: %d\n",\r\n__func__, status);\r\nreturn status;\r\n}\r\nreturn 0;\r\n}\r\nstatic void f81232_set_termios(struct tty_struct *tty,\r\nstruct usb_serial_port *port, struct ktermios *old_termios)\r\n{\r\nu8 new_lcr = 0;\r\nint status = 0;\r\nspeed_t baudrate;\r\nif (old_termios && !tty_termios_hw_change(&tty->termios, old_termios))\r\nreturn;\r\nif (C_BAUD(tty) == B0)\r\nf81232_set_mctrl(port, 0, TIOCM_DTR | TIOCM_RTS);\r\nelse if (old_termios && (old_termios->c_cflag & CBAUD) == B0)\r\nf81232_set_mctrl(port, TIOCM_DTR | TIOCM_RTS, 0);\r\nbaudrate = tty_get_baud_rate(tty);\r\nif (baudrate > 0) {\r\nif (baudrate > F81232_MAX_BAUDRATE) {\r\nbaudrate = F81232_MAX_BAUDRATE;\r\ntty_encode_baud_rate(tty, baudrate, baudrate);\r\n}\r\nf81232_set_baudrate(port, baudrate);\r\n}\r\nif (C_PARENB(tty)) {\r\nnew_lcr |= UART_LCR_PARITY;\r\nif (!C_PARODD(tty))\r\nnew_lcr |= UART_LCR_EPAR;\r\nif (C_CMSPAR(tty))\r\nnew_lcr |= UART_LCR_SPAR;\r\n}\r\nif (C_CSTOPB(tty))\r\nnew_lcr |= UART_LCR_STOP;\r\nswitch (C_CSIZE(tty)) {\r\ncase CS5:\r\nnew_lcr |= UART_LCR_WLEN5;\r\nbreak;\r\ncase CS6:\r\nnew_lcr |= UART_LCR_WLEN6;\r\nbreak;\r\ncase CS7:\r\nnew_lcr |= UART_LCR_WLEN7;\r\nbreak;\r\ndefault:\r\ncase CS8:\r\nnew_lcr |= UART_LCR_WLEN8;\r\nbreak;\r\n}\r\nstatus = f81232_set_register(port, LINE_CONTROL_REGISTER, new_lcr);\r\nif (status) {\r\ndev_err(&port->dev, "%s failed to set LCR: %d\n",\r\n__func__, status);\r\n}\r\n}\r\nstatic int f81232_tiocmget(struct tty_struct *tty)\r\n{\r\nint r;\r\nstruct usb_serial_port *port = tty->driver_data;\r\nstruct f81232_private *port_priv = usb_get_serial_port_data(port);\r\nu8 mcr, msr;\r\nf81232_read_msr(port);\r\nmutex_lock(&port_priv->lock);\r\nmcr = port_priv->modem_control;\r\nmsr = port_priv->modem_status;\r\nmutex_unlock(&port_priv->lock);\r\nr = (mcr & UART_MCR_DTR ? TIOCM_DTR : 0) |\r\n(mcr & UART_MCR_RTS ? TIOCM_RTS : 0) |\r\n(msr & UART_MSR_CTS ? TIOCM_CTS : 0) |\r\n(msr & UART_MSR_DCD ? TIOCM_CAR : 0) |\r\n(msr & UART_MSR_RI ? TIOCM_RI : 0) |\r\n(msr & UART_MSR_DSR ? TIOCM_DSR : 0);\r\nreturn r;\r\n}\r\nstatic int f81232_tiocmset(struct tty_struct *tty,\r\nunsigned int set, unsigned int clear)\r\n{\r\nstruct usb_serial_port *port = tty->driver_data;\r\nreturn f81232_set_mctrl(port, set, clear);\r\n}\r\nstatic int f81232_open(struct tty_struct *tty, struct usb_serial_port *port)\r\n{\r\nint result;\r\nresult = f81232_port_enable(port);\r\nif (result)\r\nreturn result;\r\nif (tty)\r\nf81232_set_termios(tty, port, NULL);\r\nresult = usb_submit_urb(port->interrupt_in_urb, GFP_KERNEL);\r\nif (result) {\r\ndev_err(&port->dev, "%s - failed submitting interrupt urb,"\r\n" error %d\n", __func__, result);\r\nreturn result;\r\n}\r\nresult = usb_serial_generic_open(tty, port);\r\nif (result) {\r\nusb_kill_urb(port->interrupt_in_urb);\r\nreturn result;\r\n}\r\nreturn 0;\r\n}\r\nstatic void f81232_close(struct usb_serial_port *port)\r\n{\r\nf81232_port_disable(port);\r\nusb_serial_generic_close(port);\r\nusb_kill_urb(port->interrupt_in_urb);\r\n}\r\nstatic void f81232_dtr_rts(struct usb_serial_port *port, int on)\r\n{\r\nif (on)\r\nf81232_set_mctrl(port, TIOCM_DTR | TIOCM_RTS, 0);\r\nelse\r\nf81232_set_mctrl(port, 0, TIOCM_DTR | TIOCM_RTS);\r\n}\r\nstatic int f81232_carrier_raised(struct usb_serial_port *port)\r\n{\r\nu8 msr;\r\nstruct f81232_private *priv = usb_get_serial_port_data(port);\r\nmutex_lock(&priv->lock);\r\nmsr = priv->modem_status;\r\nmutex_unlock(&priv->lock);\r\nif (msr & UART_MSR_DCD)\r\nreturn 1;\r\nreturn 0;\r\n}\r\nstatic int f81232_get_serial_info(struct usb_serial_port *port,\r\nunsigned long arg)\r\n{\r\nstruct serial_struct ser;\r\nmemset(&ser, 0, sizeof(ser));\r\nser.type = PORT_16550A;\r\nser.line = port->minor;\r\nser.port = port->port_number;\r\nser.baud_base = F81232_MAX_BAUDRATE;\r\nif (copy_to_user((void __user *)arg, &ser, sizeof(ser)))\r\nreturn -EFAULT;\r\nreturn 0;\r\n}\r\nstatic int f81232_ioctl(struct tty_struct *tty,\r\nunsigned int cmd, unsigned long arg)\r\n{\r\nstruct usb_serial_port *port = tty->driver_data;\r\nswitch (cmd) {\r\ncase TIOCGSERIAL:\r\nreturn f81232_get_serial_info(port, arg);\r\ndefault:\r\nbreak;\r\n}\r\nreturn -ENOIOCTLCMD;\r\n}\r\nstatic void f81232_interrupt_work(struct work_struct *work)\r\n{\r\nstruct f81232_private *priv =\r\ncontainer_of(work, struct f81232_private, interrupt_work);\r\nf81232_read_msr(priv->port);\r\n}\r\nstatic int f81232_port_probe(struct usb_serial_port *port)\r\n{\r\nstruct f81232_private *priv;\r\npriv = kzalloc(sizeof(*priv), GFP_KERNEL);\r\nif (!priv)\r\nreturn -ENOMEM;\r\nmutex_init(&priv->lock);\r\nINIT_WORK(&priv->interrupt_work, f81232_interrupt_work);\r\nusb_set_serial_port_data(port, priv);\r\nport->port.drain_delay = 256;\r\npriv->port = port;\r\nreturn 0;\r\n}\r\nstatic int f81232_port_remove(struct usb_serial_port *port)\r\n{\r\nstruct f81232_private *priv;\r\npriv = usb_get_serial_port_data(port);\r\nkfree(priv);\r\nreturn 0;\r\n}
