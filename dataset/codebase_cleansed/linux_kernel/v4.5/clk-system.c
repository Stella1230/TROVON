static inline int is_pck(int id)\r\n{\r\nreturn (id >= 8) && (id <= 15);\r\n}\r\nstatic irqreturn_t clk_system_irq_handler(int irq, void *dev_id)\r\n{\r\nstruct clk_system *sys = (struct clk_system *)dev_id;\r\nwake_up(&sys->wait);\r\ndisable_irq_nosync(sys->irq);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int clk_system_prepare(struct clk_hw *hw)\r\n{\r\nstruct clk_system *sys = to_clk_system(hw);\r\nstruct at91_pmc *pmc = sys->pmc;\r\nu32 mask = 1 << sys->id;\r\npmc_write(pmc, AT91_PMC_SCER, mask);\r\nif (!is_pck(sys->id))\r\nreturn 0;\r\nwhile (!(pmc_read(pmc, AT91_PMC_SR) & mask)) {\r\nif (sys->irq) {\r\nenable_irq(sys->irq);\r\nwait_event(sys->wait,\r\npmc_read(pmc, AT91_PMC_SR) & mask);\r\n} else\r\ncpu_relax();\r\n}\r\nreturn 0;\r\n}\r\nstatic void clk_system_unprepare(struct clk_hw *hw)\r\n{\r\nstruct clk_system *sys = to_clk_system(hw);\r\nstruct at91_pmc *pmc = sys->pmc;\r\npmc_write(pmc, AT91_PMC_SCDR, 1 << sys->id);\r\n}\r\nstatic int clk_system_is_prepared(struct clk_hw *hw)\r\n{\r\nstruct clk_system *sys = to_clk_system(hw);\r\nstruct at91_pmc *pmc = sys->pmc;\r\nif (!(pmc_read(pmc, AT91_PMC_SCSR) & (1 << sys->id)))\r\nreturn 0;\r\nif (!is_pck(sys->id))\r\nreturn 1;\r\nreturn !!(pmc_read(pmc, AT91_PMC_SR) & (1 << sys->id));\r\n}\r\nstatic struct clk * __init\r\nat91_clk_register_system(struct at91_pmc *pmc, const char *name,\r\nconst char *parent_name, u8 id, int irq)\r\n{\r\nstruct clk_system *sys;\r\nstruct clk *clk = NULL;\r\nstruct clk_init_data init;\r\nint ret;\r\nif (!parent_name || id > SYSTEM_MAX_ID)\r\nreturn ERR_PTR(-EINVAL);\r\nsys = kzalloc(sizeof(*sys), GFP_KERNEL);\r\nif (!sys)\r\nreturn ERR_PTR(-ENOMEM);\r\ninit.name = name;\r\ninit.ops = &system_ops;\r\ninit.parent_names = &parent_name;\r\ninit.num_parents = 1;\r\ninit.flags = CLK_SET_RATE_PARENT;\r\nsys->id = id;\r\nsys->hw.init = &init;\r\nsys->pmc = pmc;\r\nsys->irq = irq;\r\nif (irq) {\r\ninit_waitqueue_head(&sys->wait);\r\nirq_set_status_flags(sys->irq, IRQ_NOAUTOEN);\r\nret = request_irq(sys->irq, clk_system_irq_handler,\r\nIRQF_TRIGGER_HIGH, name, sys);\r\nif (ret) {\r\nkfree(sys);\r\nreturn ERR_PTR(ret);\r\n}\r\n}\r\nclk = clk_register(NULL, &sys->hw);\r\nif (IS_ERR(clk)) {\r\nif (irq)\r\nfree_irq(sys->irq, sys);\r\nkfree(sys);\r\n}\r\nreturn clk;\r\n}\r\nstatic void __init\r\nof_at91_clk_sys_setup(struct device_node *np, struct at91_pmc *pmc)\r\n{\r\nint num;\r\nint irq = 0;\r\nu32 id;\r\nstruct clk *clk;\r\nconst char *name;\r\nstruct device_node *sysclknp;\r\nconst char *parent_name;\r\nnum = of_get_child_count(np);\r\nif (num > (SYSTEM_MAX_ID + 1))\r\nreturn;\r\nfor_each_child_of_node(np, sysclknp) {\r\nif (of_property_read_u32(sysclknp, "reg", &id))\r\ncontinue;\r\nif (of_property_read_string(np, "clock-output-names", &name))\r\nname = sysclknp->name;\r\nif (is_pck(id))\r\nirq = irq_of_parse_and_map(sysclknp, 0);\r\nparent_name = of_clk_get_parent_name(sysclknp, 0);\r\nclk = at91_clk_register_system(pmc, name, parent_name, id, irq);\r\nif (IS_ERR(clk))\r\ncontinue;\r\nof_clk_add_provider(sysclknp, of_clk_src_simple_get, clk);\r\n}\r\n}\r\nvoid __init of_at91rm9200_clk_sys_setup(struct device_node *np,\r\nstruct at91_pmc *pmc)\r\n{\r\nof_at91_clk_sys_setup(np, pmc);\r\n}
