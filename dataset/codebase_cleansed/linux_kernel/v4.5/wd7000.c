static void __init setup_error(char *mesg, int *ints)\r\n{\r\nif (ints[0] == 3)\r\nprintk(KERN_ERR "wd7000_setup: \"wd7000=%d,%d,0x%x\" -> %s\n", ints[1], ints[2], ints[3], mesg);\r\nelse if (ints[0] == 4)\r\nprintk(KERN_ERR "wd7000_setup: \"wd7000=%d,%d,0x%x,%d\" -> %s\n", ints[1], ints[2], ints[3], ints[4], mesg);\r\nelse\r\nprintk(KERN_ERR "wd7000_setup: \"wd7000=%d,%d,0x%x,%d,%d\" -> %s\n", ints[1], ints[2], ints[3], ints[4], ints[5], mesg);\r\n}\r\nstatic int __init wd7000_setup(char *str)\r\n{\r\nstatic short wd7000_card_num;\r\nshort i;\r\nint ints[6];\r\n(void) get_options(str, ARRAY_SIZE(ints), ints);\r\nif (wd7000_card_num >= NUM_CONFIGS) {\r\nprintk(KERN_ERR "%s: Too many \"wd7000=\" configurations in " "command line!\n", __func__);\r\nreturn 0;\r\n}\r\nif ((ints[0] < 3) || (ints[0] > 5)) {\r\nprintk(KERN_ERR "%s: Error in command line! " "Usage: wd7000=<IRQ>,<DMA>,IO>[,<BUS_ON>" "[,<BUS_OFF>]]\n", __func__);\r\n} else {\r\nfor (i = 0; i < NUM_IRQS; i++)\r\nif (ints[1] == wd7000_irq[i])\r\nbreak;\r\nif (i == NUM_IRQS) {\r\nsetup_error("invalid IRQ.", ints);\r\nreturn 0;\r\n} else\r\nconfigs[wd7000_card_num].irq = ints[1];\r\nfor (i = 0; i < NUM_DMAS; i++)\r\nif (ints[2] == wd7000_dma[i])\r\nbreak;\r\nif (i == NUM_DMAS) {\r\nsetup_error("invalid DMA channel.", ints);\r\nreturn 0;\r\n} else\r\nconfigs[wd7000_card_num].dma = ints[2];\r\nfor (i = 0; i < NUM_IOPORTS; i++)\r\nif (ints[3] == wd7000_iobase[i])\r\nbreak;\r\nif (i == NUM_IOPORTS) {\r\nsetup_error("invalid I/O base address.", ints);\r\nreturn 0;\r\n} else\r\nconfigs[wd7000_card_num].iobase = ints[3];\r\nif (ints[0] > 3) {\r\nif ((ints[4] < 500) || (ints[4] > 31875)) {\r\nsetup_error("BUS_ON value is out of range (500" " to 31875 nanoseconds)!", ints);\r\nconfigs[wd7000_card_num].bus_on = BUS_ON;\r\n} else\r\nconfigs[wd7000_card_num].bus_on = ints[4] / 125;\r\n} else\r\nconfigs[wd7000_card_num].bus_on = BUS_ON;\r\nif (ints[0] > 4) {\r\nif ((ints[5] < 500) || (ints[5] > 31875)) {\r\nsetup_error("BUS_OFF value is out of range (500" " to 31875 nanoseconds)!", ints);\r\nconfigs[wd7000_card_num].bus_off = BUS_OFF;\r\n} else\r\nconfigs[wd7000_card_num].bus_off = ints[5] / 125;\r\n} else\r\nconfigs[wd7000_card_num].bus_off = BUS_OFF;\r\nif (wd7000_card_num) {\r\nfor (i = 0; i < (wd7000_card_num - 1); i++) {\r\nint j = i + 1;\r\nfor (; j < wd7000_card_num; j++)\r\nif (configs[i].irq == configs[j].irq) {\r\nsetup_error("duplicated IRQ!", ints);\r\nreturn 0;\r\n}\r\nif (configs[i].dma == configs[j].dma) {\r\nsetup_error("duplicated DMA " "channel!", ints);\r\nreturn 0;\r\n}\r\nif (configs[i].iobase == configs[j].iobase) {\r\nsetup_error("duplicated I/O " "base address!", ints);\r\nreturn 0;\r\n}\r\n}\r\n}\r\ndprintk(KERN_DEBUG "wd7000_setup: IRQ=%d, DMA=%d, I/O=0x%x, "\r\n"BUS_ON=%dns, BUS_OFF=%dns\n", configs[wd7000_card_num].irq, configs[wd7000_card_num].dma, configs[wd7000_card_num].iobase, configs[wd7000_card_num].bus_on * 125, configs[wd7000_card_num].bus_off * 125);\r\nwd7000_card_num++;\r\n}\r\nreturn 1;\r\n}\r\nstatic inline void any2scsi(unchar * scsi, int any)\r\n{\r\n*scsi++ = (unsigned)any >> 16;\r\n*scsi++ = (unsigned)any >> 8;\r\n*scsi++ = any;\r\n}\r\nstatic inline int scsi2int(unchar * scsi)\r\n{\r\nreturn (scsi[0] << 16) | (scsi[1] << 8) | scsi[2];\r\n}\r\nstatic inline void wd7000_enable_intr(Adapter * host)\r\n{\r\nhost->control |= INT_EN;\r\noutb(host->control, host->iobase + ASC_CONTROL);\r\n}\r\nstatic inline void wd7000_enable_dma(Adapter * host)\r\n{\r\nunsigned long flags;\r\nhost->control |= DMA_EN;\r\noutb(host->control, host->iobase + ASC_CONTROL);\r\nflags = claim_dma_lock();\r\nset_dma_mode(host->dma, DMA_MODE_CASCADE);\r\nenable_dma(host->dma);\r\nrelease_dma_lock(flags);\r\n}\r\nstatic inline short WAIT(unsigned port, unsigned mask, unsigned allof, unsigned noneof)\r\n{\r\nunsigned WAITbits;\r\nunsigned long WAITtimeout = jiffies + WAITnexttimeout;\r\nwhile (time_before_eq(jiffies, WAITtimeout)) {\r\nWAITbits = inb(port) & mask;\r\nif (((WAITbits & allof) == allof) && ((WAITbits & noneof) == 0))\r\nreturn (0);\r\n}\r\nreturn (1);\r\n}\r\nstatic inline int command_out(Adapter * host, unchar * cmd, int len)\r\n{\r\nif (!WAIT(host->iobase + ASC_STAT, ASC_STATMASK, CMD_RDY, 0)) {\r\nwhile (len--) {\r\ndo {\r\noutb(*cmd, host->iobase + ASC_COMMAND);\r\nWAIT(host->iobase + ASC_STAT, ASC_STATMASK, CMD_RDY, 0);\r\n} while (inb(host->iobase + ASC_STAT) & CMD_REJ);\r\ncmd++;\r\n}\r\nreturn (1);\r\n}\r\nprintk(KERN_WARNING "wd7000 command_out: WAIT failed(%d)\n", len + 1);\r\nreturn (0);\r\n}\r\nstatic inline Scb *alloc_scbs(struct Scsi_Host *host, int needed)\r\n{\r\nScb *scb, *p = NULL;\r\nunsigned long flags;\r\nunsigned long timeout = jiffies + WAITnexttimeout;\r\nunsigned long now;\r\nint i;\r\nif (needed <= 0)\r\nreturn (NULL);\r\nspin_unlock_irq(host->host_lock);\r\nretry:\r\nwhile (freescbs < needed) {\r\ntimeout = jiffies + WAITnexttimeout;\r\ndo {\r\nfor (now = jiffies; now == jiffies;)\r\ncpu_relax();\r\n} while (freescbs < needed && time_before_eq(jiffies, timeout));\r\nif (freescbs < needed) {\r\nprintk(KERN_ERR "wd7000: can't get enough free SCBs.\n");\r\nreturn (NULL);\r\n}\r\n}\r\nspin_lock_irqsave(&scbpool_lock, flags);\r\nif (freescbs < needed) {\r\nspin_unlock_irqrestore(&scbpool_lock, flags);\r\ngoto retry;\r\n}\r\nscb = scbfree;\r\nfreescbs -= needed;\r\nfor (i = 0; i < needed; i++) {\r\np = scbfree;\r\nscbfree = p->next;\r\n}\r\np->next = NULL;\r\nspin_unlock_irqrestore(&scbpool_lock, flags);\r\nspin_lock_irq(host->host_lock);\r\nreturn (scb);\r\n}\r\nstatic inline void free_scb(Scb * scb)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&scbpool_lock, flags);\r\nmemset(scb, 0, sizeof(Scb));\r\nscb->next = scbfree;\r\nscbfree = scb;\r\nfreescbs++;\r\nspin_unlock_irqrestore(&scbpool_lock, flags);\r\n}\r\nstatic inline void init_scbs(void)\r\n{\r\nint i;\r\nspin_lock_init(&scbpool_lock);\r\nscbfree = &(scbs[0]);\r\nmemset(scbs, 0, sizeof(scbs));\r\nfor (i = 0; i < MAX_SCBS - 1; i++) {\r\nscbs[i].next = &(scbs[i + 1]);\r\nscbs[i].SCpnt = NULL;\r\n}\r\nscbs[MAX_SCBS - 1].next = NULL;\r\nscbs[MAX_SCBS - 1].SCpnt = NULL;\r\n}\r\nstatic int mail_out(Adapter * host, Scb * scbptr)\r\n{\r\nint i, ogmb;\r\nunsigned long flags;\r\nunchar start_ogmb;\r\nMailbox *ogmbs = host->mb.ogmb;\r\nint *next_ogmb = &(host->next_ogmb);\r\ndprintk("wd7000_mail_out: 0x%06lx", (long) scbptr);\r\nspin_lock_irqsave(host->sh->host_lock, flags);\r\nogmb = *next_ogmb;\r\nfor (i = 0; i < OGMB_CNT; i++) {\r\nif (ogmbs[ogmb].status == 0) {\r\ndprintk(" using OGMB 0x%x", ogmb);\r\nogmbs[ogmb].status = 1;\r\nany2scsi((unchar *) ogmbs[ogmb].scbptr, (int) scbptr);\r\n*next_ogmb = (ogmb + 1) % OGMB_CNT;\r\nbreak;\r\n} else\r\nogmb = (ogmb + 1) % OGMB_CNT;\r\n}\r\nspin_unlock_irqrestore(host->sh->host_lock, flags);\r\ndprintk(", scb is 0x%06lx", (long) scbptr);\r\nif (i >= OGMB_CNT) {\r\ndprintk(", no free OGMBs.\n");\r\nreturn (0);\r\n}\r\nwd7000_enable_intr(host);\r\nstart_ogmb = START_OGMB | ogmb;\r\ncommand_out(host, &start_ogmb, 1);\r\ndprintk(", awaiting interrupt.\n");\r\nreturn (1);\r\n}\r\nstatic int make_code(unsigned hosterr, unsigned scsierr)\r\n{\r\n#ifdef WD7000_DEBUG\r\nint in_error = hosterr;\r\n#endif\r\nswitch ((hosterr >> 8) & 0xff) {\r\ncase 0:\r\nhosterr = DID_ERROR;\r\nbreak;\r\ncase 1:\r\nhosterr = DID_OK;\r\nbreak;\r\ncase 2:\r\nhosterr = DID_OK;\r\nbreak;\r\ncase 4:\r\nhosterr = DID_TIME_OUT;\r\nbreak;\r\ncase 5:\r\nhosterr = DID_RESET;\r\nbreak;\r\ncase 6:\r\nhosterr = DID_BAD_TARGET;\r\nbreak;\r\ncase 80:\r\ncase 81:\r\nhosterr = DID_BAD_INTR;\r\nbreak;\r\ncase 82:\r\nhosterr = DID_ABORT;\r\nbreak;\r\ncase 83:\r\ncase 84:\r\nhosterr = DID_RESET;\r\nbreak;\r\ndefault:\r\nhosterr = DID_ERROR;\r\n}\r\n#ifdef WD7000_DEBUG\r\nif (scsierr || hosterr)\r\ndprintk("\nSCSI command error: SCSI 0x%02x host 0x%04x return %d\n", scsierr, in_error, hosterr);\r\n#endif\r\nreturn (scsierr | (hosterr << 16));\r\n}\r\nstatic irqreturn_t wd7000_intr(int irq, void *dev_id)\r\n{\r\nAdapter *host = (Adapter *) dev_id;\r\nint flag, icmb, errstatus, icmb_status;\r\nint host_error, scsi_error;\r\nScb *scb;\r\nIcbAny *icb;\r\nstruct scsi_cmnd *SCpnt;\r\nMailbox *icmbs = host->mb.icmb;\r\nunsigned long flags;\r\nspin_lock_irqsave(host->sh->host_lock, flags);\r\nhost->int_counter++;\r\ndprintk("wd7000_intr: irq = %d, host = 0x%06lx\n", irq, (long) host);\r\nflag = inb(host->iobase + ASC_INTR_STAT);\r\ndprintk("wd7000_intr: intr stat = 0x%02x\n", flag);\r\nif (!(inb(host->iobase + ASC_STAT) & INT_IM)) {\r\ndprintk("wd7000_intr: phantom interrupt...\n");\r\ngoto ack;\r\n}\r\nif (!(flag & MB_INTR))\r\ngoto ack;\r\nif (!(flag & IMB_INTR)) {\r\ndprintk("wd7000_intr: free outgoing mailbox\n");\r\ngoto ack;\r\n}\r\nicmb = flag & MB_MASK;\r\nicmb_status = icmbs[icmb].status;\r\nif (icmb_status & 0x80) {\r\ndprintk("wd7000_intr: unsolicited interrupt 0x%02x\n", icmb_status);\r\ngoto ack;\r\n}\r\nscb = isa_bus_to_virt(scsi2int((unchar *) icmbs[icmb].scbptr));\r\nicmbs[icmb].status = 0;\r\nif (scb->op & ICB_OP_MASK) {\r\nicb = (IcbAny *) scb;\r\nicb->status = icmb_status;\r\nicb->phase = 0;\r\ngoto ack;\r\n}\r\nSCpnt = scb->SCpnt;\r\nif (--(SCpnt->SCp.phase) <= 0) {\r\nhost_error = scb->vue | (icmb_status << 8);\r\nscsi_error = scb->status;\r\nerrstatus = make_code(host_error, scsi_error);\r\nSCpnt->result = errstatus;\r\nfree_scb(scb);\r\nSCpnt->scsi_done(SCpnt);\r\n}\r\nack:\r\ndprintk("wd7000_intr: return from interrupt handler\n");\r\nwd7000_intr_ack(host);\r\nspin_unlock_irqrestore(host->sh->host_lock, flags);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int wd7000_queuecommand_lck(struct scsi_cmnd *SCpnt,\r\nvoid (*done)(struct scsi_cmnd *))\r\n{\r\nScb *scb;\r\nSgb *sgb;\r\nunchar *cdb = (unchar *) SCpnt->cmnd;\r\nunchar idlun;\r\nshort cdblen;\r\nint nseg;\r\nAdapter *host = (Adapter *) SCpnt->device->host->hostdata;\r\ncdblen = SCpnt->cmd_len;\r\nidlun = ((SCpnt->device->id << 5) & 0xe0) | (SCpnt->device->lun & 7);\r\nSCpnt->scsi_done = done;\r\nSCpnt->SCp.phase = 1;\r\nscb = alloc_scbs(SCpnt->device->host, 1);\r\nscb->idlun = idlun;\r\nmemcpy(scb->cdb, cdb, cdblen);\r\nscb->direc = 0x40;\r\nscb->SCpnt = SCpnt;\r\nSCpnt->host_scribble = (unchar *) scb;\r\nscb->host = host;\r\nnseg = scsi_sg_count(SCpnt);\r\nif (nseg > 1) {\r\nstruct scatterlist *sg;\r\nunsigned i;\r\ndprintk("Using scatter/gather with %d elements.\n", nseg);\r\nsgb = scb->sgb;\r\nscb->op = 1;\r\nany2scsi(scb->dataptr, (int) sgb);\r\nany2scsi(scb->maxlen, nseg * sizeof(Sgb));\r\nscsi_for_each_sg(SCpnt, sg, nseg, i) {\r\nany2scsi(sgb[i].ptr, isa_page_to_bus(sg_page(sg)) + sg->offset);\r\nany2scsi(sgb[i].len, sg->length);\r\n}\r\n} else {\r\nscb->op = 0;\r\nif (nseg) {\r\nstruct scatterlist *sg = scsi_sglist(SCpnt);\r\nany2scsi(scb->dataptr, isa_page_to_bus(sg_page(sg)) + sg->offset);\r\n}\r\nany2scsi(scb->maxlen, scsi_bufflen(SCpnt));\r\n}\r\nwhile (!mail_out(host, scb))\r\ncpu_relax();\r\nreturn 0;\r\n}\r\nint wd7000_adapter_reset(Adapter * host)\r\n{\r\nInitCmd init_cmd = {\r\nINITIALIZATION,\r\n7,\r\nhost->bus_on,\r\nhost->bus_off,\r\n0,\r\n{0, 0, 0},\r\nOGMB_CNT,\r\nICMB_CNT\r\n};\r\nint diag;\r\noutb(ASC_RES, host->iobase + ASC_CONTROL);\r\nudelay(40);\r\noutb(0, host->iobase + ASC_CONTROL);\r\nhost->control = 0;\r\nif (WAIT(host->iobase + ASC_STAT, ASC_STATMASK, CMD_RDY, 0)) {\r\nprintk(KERN_ERR "wd7000_init: WAIT timed out.\n");\r\nreturn -1;\r\n}\r\nif ((diag = inb(host->iobase + ASC_INTR_STAT)) != 1) {\r\nprintk("wd7000_init: ");\r\nswitch (diag) {\r\ncase 2:\r\nprintk(KERN_ERR "RAM failure.\n");\r\nbreak;\r\ncase 3:\r\nprintk(KERN_ERR "FIFO R/W failed\n");\r\nbreak;\r\ncase 4:\r\nprintk(KERN_ERR "SBIC register R/W failed\n");\r\nbreak;\r\ncase 5:\r\nprintk(KERN_ERR "Initialization D-FF failed.\n");\r\nbreak;\r\ncase 6:\r\nprintk(KERN_ERR "Host IRQ D-FF failed.\n");\r\nbreak;\r\ncase 7:\r\nprintk(KERN_ERR "ROM checksum error.\n");\r\nbreak;\r\ndefault:\r\nprintk(KERN_ERR "diagnostic code 0x%02Xh received.\n", diag);\r\n}\r\nreturn -1;\r\n}\r\nmemset(&(host->mb), 0, sizeof(host->mb));\r\nany2scsi((unchar *) & (init_cmd.mailboxes), (int) &(host->mb));\r\nif (!command_out(host, (unchar *) & init_cmd, sizeof(init_cmd))) {\r\nprintk(KERN_ERR "wd7000_adapter_reset: adapter initialization failed.\n");\r\nreturn -1;\r\n}\r\nif (WAIT(host->iobase + ASC_STAT, ASC_STATMASK, ASC_INIT, 0)) {\r\nprintk("wd7000_adapter_reset: WAIT timed out.\n");\r\nreturn -1;\r\n}\r\nreturn 0;\r\n}\r\nstatic int wd7000_init(Adapter * host)\r\n{\r\nif (wd7000_adapter_reset(host) == -1)\r\nreturn 0;\r\nif (request_irq(host->irq, wd7000_intr, 0, "wd7000", host)) {\r\nprintk("wd7000_init: can't get IRQ %d.\n", host->irq);\r\nreturn (0);\r\n}\r\nif (request_dma(host->dma, "wd7000")) {\r\nprintk("wd7000_init: can't get DMA channel %d.\n", host->dma);\r\nfree_irq(host->irq, host);\r\nreturn (0);\r\n}\r\nwd7000_enable_dma(host);\r\nwd7000_enable_intr(host);\r\nif (!wd7000_diagnostics(host, ICB_DIAG_FULL)) {\r\nfree_dma(host->dma);\r\nfree_irq(host->irq, NULL);\r\nreturn (0);\r\n}\r\nreturn (1);\r\n}\r\nstatic void wd7000_revision(Adapter * host)\r\n{\r\nstatic IcbRevLvl icb = { ICB_OP_GET_REVISION };\r\nicb.phase = 1;\r\nmail_out(host, (struct scb *) &icb);\r\nwhile (icb.phase) {\r\ncpu_relax();\r\nbarrier();\r\n}\r\nhost->rev1 = icb.primary;\r\nhost->rev2 = icb.secondary;\r\n}\r\nstatic int wd7000_set_info(struct Scsi_Host *host, char *buffer, int length)\r\n{\r\ndprintk("Buffer = <%.*s>, length = %d\n", length, buffer, length);\r\ndprintk("Sorry, this function is currently out of order...\n");\r\nreturn (length);\r\n}\r\nstatic int wd7000_show_info(struct seq_file *m, struct Scsi_Host *host)\r\n{\r\nAdapter *adapter = (Adapter *)host->hostdata;\r\nunsigned long flags;\r\n#ifdef WD7000_DEBUG\r\nMailbox *ogmbs, *icmbs;\r\nshort count;\r\n#endif\r\nspin_lock_irqsave(host->host_lock, flags);\r\nseq_printf(m, "Host scsi%d: Western Digital WD-7000 (rev %d.%d)\n", host->host_no, adapter->rev1, adapter->rev2);\r\nseq_printf(m, " IO base: 0x%x\n", adapter->iobase);\r\nseq_printf(m, " IRQ: %d\n", adapter->irq);\r\nseq_printf(m, " DMA channel: %d\n", adapter->dma);\r\nseq_printf(m, " Interrupts: %d\n", adapter->int_counter);\r\nseq_printf(m, " BUS_ON time: %d nanoseconds\n", adapter->bus_on * 125);\r\nseq_printf(m, " BUS_OFF time: %d nanoseconds\n", adapter->bus_off * 125);\r\n#ifdef WD7000_DEBUG\r\nogmbs = adapter->mb.ogmb;\r\nicmbs = adapter->mb.icmb;\r\nseq_printf(m, "\nControl port value: 0x%x\n", adapter->control);\r\nseq_puts(m, "Incoming mailbox:\n");\r\nseq_printf(m, " size: %d\n", ICMB_CNT);\r\nseq_puts(m, " queued messages: ");\r\nfor (i = count = 0; i < ICMB_CNT; i++)\r\nif (icmbs[i].status) {\r\ncount++;\r\nseq_printf(m, "0x%x ", i);\r\n}\r\nseq_puts(m, count ? "\n" : "none\n");\r\nseq_puts(m, "Outgoing mailbox:\n");\r\nseq_printf(m, " size: %d\n", OGMB_CNT);\r\nseq_printf(m, " next message: 0x%x\n", adapter->next_ogmb);\r\nseq_puts(m, " queued messages: ");\r\nfor (i = count = 0; i < OGMB_CNT; i++)\r\nif (ogmbs[i].status) {\r\ncount++;\r\nseq_printf(m, "0x%x ", i);\r\n}\r\nseq_puts(m, count ? "\n" : "none\n");\r\n#endif\r\nspin_unlock_irqrestore(host->host_lock, flags);\r\nreturn 0;\r\n}\r\nstatic __init int wd7000_detect(struct scsi_host_template *tpnt)\r\n{\r\nshort present = 0, biosaddr_ptr, sig_ptr, i, pass;\r\nshort biosptr[NUM_CONFIGS];\r\nunsigned iobase;\r\nAdapter *host = NULL;\r\nstruct Scsi_Host *sh;\r\nint unit = 0;\r\ndprintk("wd7000_detect: started\n");\r\n#ifdef MODULE\r\nif (wd7000)\r\nwd7000_setup(wd7000);\r\n#endif\r\nfor (i = 0; i < UNITS; wd7000_host[i++] = NULL);\r\nfor (i = 0; i < NUM_CONFIGS; biosptr[i++] = -1);\r\ntpnt->proc_name = "wd7000";\r\ntpnt->show_info = &wd7000_show_info;\r\ntpnt->write_info = wd7000_set_info;\r\ninit_scbs();\r\nfor (pass = 0; pass < NUM_CONFIGS; pass++) {\r\nfor (biosaddr_ptr = 0; biosaddr_ptr < NUM_ADDRS; biosaddr_ptr++)\r\nfor (sig_ptr = 0; sig_ptr < NUM_SIGNATURES; sig_ptr++) {\r\nfor (i = 0; i < pass; i++)\r\nif (biosptr[i] == biosaddr_ptr)\r\nbreak;\r\nif (i == pass) {\r\nvoid __iomem *biosaddr = ioremap(wd7000_biosaddr[biosaddr_ptr] + signatures[sig_ptr].ofs,\r\nsignatures[sig_ptr].len);\r\nshort bios_match = 1;\r\nif (biosaddr)\r\nbios_match = check_signature(biosaddr, signatures[sig_ptr].sig, signatures[sig_ptr].len);\r\niounmap(biosaddr);\r\nif (bios_match)\r\ngoto bios_matched;\r\n}\r\n}\r\nbios_matched:\r\n#ifdef WD7000_DEBUG\r\ndprintk("wd7000_detect: pass %d\n", pass + 1);\r\nif (biosaddr_ptr == NUM_ADDRS)\r\ndprintk("WD-7000 SST BIOS not detected...\n");\r\nelse\r\ndprintk("WD-7000 SST BIOS detected at 0x%lx: checking...\n", wd7000_biosaddr[biosaddr_ptr]);\r\n#endif\r\nif (configs[pass].irq < 0)\r\ncontinue;\r\nif (unit == UNITS)\r\ncontinue;\r\niobase = configs[pass].iobase;\r\ndprintk("wd7000_detect: check IO 0x%x region...\n", iobase);\r\nif (request_region(iobase, 4, "wd7000")) {\r\ndprintk("wd7000_detect: ASC reset (IO 0x%x) ...", iobase);\r\noutb(ASC_RES, iobase + ASC_CONTROL);\r\nmsleep(10);\r\noutb(0, iobase + ASC_CONTROL);\r\nif (WAIT(iobase + ASC_STAT, ASC_STATMASK, CMD_RDY, 0)) {\r\ndprintk("failed!\n");\r\ngoto err_release;\r\n} else\r\ndprintk("ok!\n");\r\nif (inb(iobase + ASC_INTR_STAT) == 1) {\r\nsh = scsi_register(tpnt, sizeof(Adapter));\r\nif (sh == NULL)\r\ngoto err_release;\r\nhost = (Adapter *) sh->hostdata;\r\ndprintk("wd7000_detect: adapter allocated at 0x%x\n", (int) host);\r\nmemset(host, 0, sizeof(Adapter));\r\nhost->irq = configs[pass].irq;\r\nhost->dma = configs[pass].dma;\r\nhost->iobase = iobase;\r\nhost->int_counter = 0;\r\nhost->bus_on = configs[pass].bus_on;\r\nhost->bus_off = configs[pass].bus_off;\r\nhost->sh = wd7000_host[unit] = sh;\r\nunit++;\r\ndprintk("wd7000_detect: Trying init WD-7000 card at IO " "0x%x, IRQ %d, DMA %d...\n", host->iobase, host->irq, host->dma);\r\nif (!wd7000_init(host))\r\ngoto err_unregister;\r\nwd7000_revision(host);\r\nif (host->rev1 < 6)\r\nsh->sg_tablesize = 1;\r\npresent++;\r\nif (biosaddr_ptr != NUM_ADDRS)\r\nbiosptr[pass] = biosaddr_ptr;\r\nprintk(KERN_INFO "Western Digital WD-7000 (rev %d.%d) ", host->rev1, host->rev2);\r\nprintk("using IO 0x%x, IRQ %d, DMA %d.\n", host->iobase, host->irq, host->dma);\r\nprintk(" BUS_ON time: %dns, BUS_OFF time: %dns\n", host->bus_on * 125, host->bus_off * 125);\r\n}\r\n} else\r\ndprintk("wd7000_detect: IO 0x%x region already allocated!\n", iobase);\r\ncontinue;\r\nerr_unregister:\r\nscsi_unregister(sh);\r\nerr_release:\r\nrelease_region(iobase, 4);\r\n}\r\nif (!present)\r\nprintk("Failed initialization of WD-7000 SCSI card!\n");\r\nreturn (present);\r\n}\r\nstatic int wd7000_release(struct Scsi_Host *shost)\r\n{\r\nif (shost->irq)\r\nfree_irq(shost->irq, NULL);\r\nif (shost->io_port && shost->n_io_port)\r\nrelease_region(shost->io_port, shost->n_io_port);\r\nscsi_unregister(shost);\r\nreturn 0;\r\n}\r\nstatic int wd7000_host_reset(struct scsi_cmnd *SCpnt)\r\n{\r\nAdapter *host = (Adapter *) SCpnt->device->host->hostdata;\r\nspin_lock_irq(SCpnt->device->host->host_lock);\r\nif (wd7000_adapter_reset(host) < 0) {\r\nspin_unlock_irq(SCpnt->device->host->host_lock);\r\nreturn FAILED;\r\n}\r\nwd7000_enable_intr(host);\r\nspin_unlock_irq(SCpnt->device->host->host_lock);\r\nreturn SUCCESS;\r\n}\r\nstatic int wd7000_biosparam(struct scsi_device *sdev,\r\nstruct block_device *bdev, sector_t capacity, int *ip)\r\n{\r\nchar b[BDEVNAME_SIZE];\r\ndprintk("wd7000_biosparam: dev=%s, size=%d, ",\r\nbdevname(bdev, b), capacity);\r\n(void)b;\r\nip[0] = 64;\r\nip[1] = 32;\r\nip[2] = capacity >> 11;\r\nif (ip[2] >= 1024) {\r\nint info[3];\r\nif ((scsicam_bios_param(bdev, capacity, info) < 0) || !(((info[0] == 64) && (info[1] == 32)) || ((info[0] == 255) && (info[1] == 63)))) {\r\nprintk("wd7000_biosparam: unable to verify geometry for disk with >1GB.\n" " using extended translation.\n");\r\nip[0] = 255;\r\nip[1] = 63;\r\nip[2] = (unsigned long) capacity / (255 * 63);\r\n} else {\r\nip[0] = info[0];\r\nip[1] = info[1];\r\nip[2] = info[2];\r\nif (info[0] == 255)\r\nprintk(KERN_INFO "%s: current partition table is " "using extended translation.\n", __func__);\r\n}\r\n}\r\ndprintk("bios geometry: head=%d, sec=%d, cyl=%d\n", ip[0], ip[1], ip[2]);\r\ndprintk("WARNING: check, if the bios geometry is correct.\n");\r\nreturn (0);\r\n}
