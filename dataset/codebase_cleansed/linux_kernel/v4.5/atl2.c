static int atl2_sw_init(struct atl2_adapter *adapter)\r\n{\r\nstruct atl2_hw *hw = &adapter->hw;\r\nstruct pci_dev *pdev = adapter->pdev;\r\nhw->vendor_id = pdev->vendor;\r\nhw->device_id = pdev->device;\r\nhw->subsystem_vendor_id = pdev->subsystem_vendor;\r\nhw->subsystem_id = pdev->subsystem_device;\r\nhw->revision_id = pdev->revision;\r\npci_read_config_word(pdev, PCI_COMMAND, &hw->pci_cmd_word);\r\nadapter->wol = 0;\r\nadapter->ict = 50000;\r\nadapter->link_speed = SPEED_0;\r\nadapter->link_duplex = FULL_DUPLEX;\r\nhw->phy_configured = false;\r\nhw->preamble_len = 7;\r\nhw->ipgt = 0x60;\r\nhw->min_ifg = 0x50;\r\nhw->ipgr1 = 0x40;\r\nhw->ipgr2 = 0x60;\r\nhw->retry_buf = 2;\r\nhw->max_retry = 0xf;\r\nhw->lcol = 0x37;\r\nhw->jam_ipg = 7;\r\nhw->fc_rxd_hi = 0;\r\nhw->fc_rxd_lo = 0;\r\nhw->max_frame_size = adapter->netdev->mtu;\r\nspin_lock_init(&adapter->stats_lock);\r\nset_bit(__ATL2_DOWN, &adapter->flags);\r\nreturn 0;\r\n}\r\nstatic void atl2_set_multi(struct net_device *netdev)\r\n{\r\nstruct atl2_adapter *adapter = netdev_priv(netdev);\r\nstruct atl2_hw *hw = &adapter->hw;\r\nstruct netdev_hw_addr *ha;\r\nu32 rctl;\r\nu32 hash_value;\r\nrctl = ATL2_READ_REG(hw, REG_MAC_CTRL);\r\nif (netdev->flags & IFF_PROMISC) {\r\nrctl |= MAC_CTRL_PROMIS_EN;\r\n} else if (netdev->flags & IFF_ALLMULTI) {\r\nrctl |= MAC_CTRL_MC_ALL_EN;\r\nrctl &= ~MAC_CTRL_PROMIS_EN;\r\n} else\r\nrctl &= ~(MAC_CTRL_PROMIS_EN | MAC_CTRL_MC_ALL_EN);\r\nATL2_WRITE_REG(hw, REG_MAC_CTRL, rctl);\r\nATL2_WRITE_REG(hw, REG_RX_HASH_TABLE, 0);\r\nATL2_WRITE_REG_ARRAY(hw, REG_RX_HASH_TABLE, 1, 0);\r\nnetdev_for_each_mc_addr(ha, netdev) {\r\nhash_value = atl2_hash_mc_addr(hw, ha->addr);\r\natl2_hash_set(hw, hash_value);\r\n}\r\n}\r\nstatic void init_ring_ptrs(struct atl2_adapter *adapter)\r\n{\r\nadapter->txd_write_ptr = 0;\r\natomic_set(&adapter->txd_read_ptr, 0);\r\nadapter->rxd_read_ptr = 0;\r\nadapter->rxd_write_ptr = 0;\r\natomic_set(&adapter->txs_write_ptr, 0);\r\nadapter->txs_next_clear = 0;\r\n}\r\nstatic int atl2_configure(struct atl2_adapter *adapter)\r\n{\r\nstruct atl2_hw *hw = &adapter->hw;\r\nu32 value;\r\nATL2_WRITE_REG(&adapter->hw, REG_ISR, 0xffffffff);\r\nvalue = (((u32)hw->mac_addr[2]) << 24) |\r\n(((u32)hw->mac_addr[3]) << 16) |\r\n(((u32)hw->mac_addr[4]) << 8) |\r\n(((u32)hw->mac_addr[5]));\r\nATL2_WRITE_REG(hw, REG_MAC_STA_ADDR, value);\r\nvalue = (((u32)hw->mac_addr[0]) << 8) |\r\n(((u32)hw->mac_addr[1]));\r\nATL2_WRITE_REG(hw, (REG_MAC_STA_ADDR+4), value);\r\nATL2_WRITE_REG(hw, REG_DESC_BASE_ADDR_HI,\r\n(u32)((adapter->ring_dma & 0xffffffff00000000ULL) >> 32));\r\nATL2_WRITE_REG(hw, REG_TXD_BASE_ADDR_LO,\r\n(u32)(adapter->txd_dma & 0x00000000ffffffffULL));\r\nATL2_WRITE_REG(hw, REG_TXS_BASE_ADDR_LO,\r\n(u32)(adapter->txs_dma & 0x00000000ffffffffULL));\r\nATL2_WRITE_REG(hw, REG_RXD_BASE_ADDR_LO,\r\n(u32)(adapter->rxd_dma & 0x00000000ffffffffULL));\r\nATL2_WRITE_REGW(hw, REG_TXD_MEM_SIZE, (u16)(adapter->txd_ring_size/4));\r\nATL2_WRITE_REGW(hw, REG_TXS_MEM_SIZE, (u16)adapter->txs_ring_size);\r\nATL2_WRITE_REGW(hw, REG_RXD_BUF_NUM, (u16)adapter->rxd_ring_size);\r\nvalue = (((u32)hw->ipgt & MAC_IPG_IFG_IPGT_MASK) <<\r\nMAC_IPG_IFG_IPGT_SHIFT) |\r\n(((u32)hw->min_ifg & MAC_IPG_IFG_MIFG_MASK) <<\r\nMAC_IPG_IFG_MIFG_SHIFT) |\r\n(((u32)hw->ipgr1 & MAC_IPG_IFG_IPGR1_MASK) <<\r\nMAC_IPG_IFG_IPGR1_SHIFT)|\r\n(((u32)hw->ipgr2 & MAC_IPG_IFG_IPGR2_MASK) <<\r\nMAC_IPG_IFG_IPGR2_SHIFT);\r\nATL2_WRITE_REG(hw, REG_MAC_IPG_IFG, value);\r\nvalue = ((u32)hw->lcol & MAC_HALF_DUPLX_CTRL_LCOL_MASK) |\r\n(((u32)hw->max_retry & MAC_HALF_DUPLX_CTRL_RETRY_MASK) <<\r\nMAC_HALF_DUPLX_CTRL_RETRY_SHIFT) |\r\nMAC_HALF_DUPLX_CTRL_EXC_DEF_EN |\r\n(0xa << MAC_HALF_DUPLX_CTRL_ABEBT_SHIFT) |\r\n(((u32)hw->jam_ipg & MAC_HALF_DUPLX_CTRL_JAMIPG_MASK) <<\r\nMAC_HALF_DUPLX_CTRL_JAMIPG_SHIFT);\r\nATL2_WRITE_REG(hw, REG_MAC_HALF_DUPLX_CTRL, value);\r\nATL2_WRITE_REGW(hw, REG_IRQ_MODU_TIMER_INIT, adapter->imt);\r\nATL2_WRITE_REG(hw, REG_MASTER_CTRL, MASTER_CTRL_ITIMER_EN);\r\nATL2_WRITE_REGW(hw, REG_CMBDISDMA_TIMER, adapter->ict);\r\nATL2_WRITE_REG(hw, REG_MTU, adapter->netdev->mtu +\r\nENET_HEADER_SIZE + VLAN_SIZE + ETHERNET_FCS_SIZE);\r\nATL2_WRITE_REG(hw, REG_TX_CUT_THRESH, 0x177);\r\nATL2_WRITE_REGW(hw, REG_PAUSE_ON_TH, hw->fc_rxd_hi);\r\nATL2_WRITE_REGW(hw, REG_PAUSE_OFF_TH, hw->fc_rxd_lo);\r\nATL2_WRITE_REGW(hw, REG_MB_TXD_WR_IDX, (u16)adapter->txd_write_ptr);\r\nATL2_WRITE_REGW(hw, REG_MB_RXD_RD_IDX, (u16)adapter->rxd_read_ptr);\r\nATL2_WRITE_REGB(hw, REG_DMAR, DMAR_EN);\r\nATL2_WRITE_REGB(hw, REG_DMAW, DMAW_EN);\r\nvalue = ATL2_READ_REG(&adapter->hw, REG_ISR);\r\nif ((value & ISR_PHY_LINKDOWN) != 0)\r\nvalue = 1;\r\nelse\r\nvalue = 0;\r\nATL2_WRITE_REG(&adapter->hw, REG_ISR, 0x3fffffff);\r\nATL2_WRITE_REG(&adapter->hw, REG_ISR, 0);\r\nreturn value;\r\n}\r\nstatic s32 atl2_setup_ring_resources(struct atl2_adapter *adapter)\r\n{\r\nstruct pci_dev *pdev = adapter->pdev;\r\nint size;\r\nu8 offset = 0;\r\nadapter->ring_size = size =\r\nadapter->txd_ring_size * 1 + 7 +\r\nadapter->txs_ring_size * 4 + 7 +\r\nadapter->rxd_ring_size * 1536 + 127;\r\nadapter->ring_vir_addr = pci_alloc_consistent(pdev, size,\r\n&adapter->ring_dma);\r\nif (!adapter->ring_vir_addr)\r\nreturn -ENOMEM;\r\nmemset(adapter->ring_vir_addr, 0, adapter->ring_size);\r\nadapter->txd_dma = adapter->ring_dma ;\r\noffset = (adapter->txd_dma & 0x7) ? (8 - (adapter->txd_dma & 0x7)) : 0;\r\nadapter->txd_dma += offset;\r\nadapter->txd_ring = adapter->ring_vir_addr + offset;\r\nadapter->txs_dma = adapter->txd_dma + adapter->txd_ring_size;\r\noffset = (adapter->txs_dma & 0x7) ? (8 - (adapter->txs_dma & 0x7)) : 0;\r\nadapter->txs_dma += offset;\r\nadapter->txs_ring = (struct tx_pkt_status *)\r\n(((u8 *)adapter->txd_ring) + (adapter->txd_ring_size + offset));\r\nadapter->rxd_dma = adapter->txs_dma + adapter->txs_ring_size * 4;\r\noffset = (adapter->rxd_dma & 127) ?\r\n(128 - (adapter->rxd_dma & 127)) : 0;\r\nif (offset > 7)\r\noffset -= 8;\r\nelse\r\noffset += (128 - 8);\r\nadapter->rxd_dma += offset;\r\nadapter->rxd_ring = (struct rx_desc *) (((u8 *)adapter->txs_ring) +\r\n(adapter->txs_ring_size * 4 + offset));\r\nreturn 0;\r\n}\r\nstatic inline void atl2_irq_enable(struct atl2_adapter *adapter)\r\n{\r\nATL2_WRITE_REG(&adapter->hw, REG_IMR, IMR_NORMAL_MASK);\r\nATL2_WRITE_FLUSH(&adapter->hw);\r\n}\r\nstatic inline void atl2_irq_disable(struct atl2_adapter *adapter)\r\n{\r\nATL2_WRITE_REG(&adapter->hw, REG_IMR, 0);\r\nATL2_WRITE_FLUSH(&adapter->hw);\r\nsynchronize_irq(adapter->pdev->irq);\r\n}\r\nstatic void __atl2_vlan_mode(netdev_features_t features, u32 *ctrl)\r\n{\r\nif (features & NETIF_F_HW_VLAN_CTAG_RX) {\r\n*ctrl |= MAC_CTRL_RMV_VLAN;\r\n} else {\r\n*ctrl &= ~MAC_CTRL_RMV_VLAN;\r\n}\r\n}\r\nstatic void atl2_vlan_mode(struct net_device *netdev,\r\nnetdev_features_t features)\r\n{\r\nstruct atl2_adapter *adapter = netdev_priv(netdev);\r\nu32 ctrl;\r\natl2_irq_disable(adapter);\r\nctrl = ATL2_READ_REG(&adapter->hw, REG_MAC_CTRL);\r\n__atl2_vlan_mode(features, &ctrl);\r\nATL2_WRITE_REG(&adapter->hw, REG_MAC_CTRL, ctrl);\r\natl2_irq_enable(adapter);\r\n}\r\nstatic void atl2_restore_vlan(struct atl2_adapter *adapter)\r\n{\r\natl2_vlan_mode(adapter->netdev, adapter->netdev->features);\r\n}\r\nstatic netdev_features_t atl2_fix_features(struct net_device *netdev,\r\nnetdev_features_t features)\r\n{\r\nif (features & NETIF_F_HW_VLAN_CTAG_RX)\r\nfeatures |= NETIF_F_HW_VLAN_CTAG_TX;\r\nelse\r\nfeatures &= ~NETIF_F_HW_VLAN_CTAG_TX;\r\nreturn features;\r\n}\r\nstatic int atl2_set_features(struct net_device *netdev,\r\nnetdev_features_t features)\r\n{\r\nnetdev_features_t changed = netdev->features ^ features;\r\nif (changed & NETIF_F_HW_VLAN_CTAG_RX)\r\natl2_vlan_mode(netdev, features);\r\nreturn 0;\r\n}\r\nstatic void atl2_intr_rx(struct atl2_adapter *adapter)\r\n{\r\nstruct net_device *netdev = adapter->netdev;\r\nstruct rx_desc *rxd;\r\nstruct sk_buff *skb;\r\ndo {\r\nrxd = adapter->rxd_ring+adapter->rxd_write_ptr;\r\nif (!rxd->status.update)\r\nbreak;\r\nrxd->status.update = 0;\r\nif (rxd->status.ok && rxd->status.pkt_size >= 60) {\r\nint rx_size = (int)(rxd->status.pkt_size - 4);\r\nskb = netdev_alloc_skb_ip_align(netdev, rx_size);\r\nif (NULL == skb) {\r\nnetdev->stats.rx_dropped++;\r\nbreak;\r\n}\r\nmemcpy(skb->data, rxd->packet, rx_size);\r\nskb_put(skb, rx_size);\r\nskb->protocol = eth_type_trans(skb, netdev);\r\nif (rxd->status.vlan) {\r\nu16 vlan_tag = (rxd->status.vtag>>4) |\r\n((rxd->status.vtag&7) << 13) |\r\n((rxd->status.vtag&8) << 9);\r\n__vlan_hwaccel_put_tag(skb, htons(ETH_P_8021Q), vlan_tag);\r\n}\r\nnetif_rx(skb);\r\nnetdev->stats.rx_bytes += rx_size;\r\nnetdev->stats.rx_packets++;\r\n} else {\r\nnetdev->stats.rx_errors++;\r\nif (rxd->status.ok && rxd->status.pkt_size <= 60)\r\nnetdev->stats.rx_length_errors++;\r\nif (rxd->status.mcast)\r\nnetdev->stats.multicast++;\r\nif (rxd->status.crc)\r\nnetdev->stats.rx_crc_errors++;\r\nif (rxd->status.align)\r\nnetdev->stats.rx_frame_errors++;\r\n}\r\nif (++adapter->rxd_write_ptr == adapter->rxd_ring_size)\r\nadapter->rxd_write_ptr = 0;\r\n} while (1);\r\nadapter->rxd_read_ptr = adapter->rxd_write_ptr;\r\nATL2_WRITE_REGW(&adapter->hw, REG_MB_RXD_RD_IDX, adapter->rxd_read_ptr);\r\n}\r\nstatic void atl2_intr_tx(struct atl2_adapter *adapter)\r\n{\r\nstruct net_device *netdev = adapter->netdev;\r\nu32 txd_read_ptr;\r\nu32 txs_write_ptr;\r\nstruct tx_pkt_status *txs;\r\nstruct tx_pkt_header *txph;\r\nint free_hole = 0;\r\ndo {\r\ntxs_write_ptr = (u32) atomic_read(&adapter->txs_write_ptr);\r\ntxs = adapter->txs_ring + txs_write_ptr;\r\nif (!txs->update)\r\nbreak;\r\nfree_hole = 1;\r\ntxs->update = 0;\r\nif (++txs_write_ptr == adapter->txs_ring_size)\r\ntxs_write_ptr = 0;\r\natomic_set(&adapter->txs_write_ptr, (int)txs_write_ptr);\r\ntxd_read_ptr = (u32) atomic_read(&adapter->txd_read_ptr);\r\ntxph = (struct tx_pkt_header *)\r\n(((u8 *)adapter->txd_ring) + txd_read_ptr);\r\nif (txph->pkt_size != txs->pkt_size) {\r\nstruct tx_pkt_status *old_txs = txs;\r\nprintk(KERN_WARNING\r\n"%s: txs packet size not consistent with txd"\r\n" txd_:0x%08x, txs_:0x%08x!\n",\r\nadapter->netdev->name,\r\n*(u32 *)txph, *(u32 *)txs);\r\nprintk(KERN_WARNING\r\n"txd read ptr: 0x%x\n",\r\ntxd_read_ptr);\r\ntxs = adapter->txs_ring + txs_write_ptr;\r\nprintk(KERN_WARNING\r\n"txs-behind:0x%08x\n",\r\n*(u32 *)txs);\r\nif (txs_write_ptr < 2) {\r\ntxs = adapter->txs_ring +\r\n(adapter->txs_ring_size +\r\ntxs_write_ptr - 2);\r\n} else {\r\ntxs = adapter->txs_ring + (txs_write_ptr - 2);\r\n}\r\nprintk(KERN_WARNING\r\n"txs-before:0x%08x\n",\r\n*(u32 *)txs);\r\ntxs = old_txs;\r\n}\r\ntxd_read_ptr += (((u32)(txph->pkt_size) + 7) & ~3);\r\nif (txd_read_ptr >= adapter->txd_ring_size)\r\ntxd_read_ptr -= adapter->txd_ring_size;\r\natomic_set(&adapter->txd_read_ptr, (int)txd_read_ptr);\r\nif (txs->ok) {\r\nnetdev->stats.tx_bytes += txs->pkt_size;\r\nnetdev->stats.tx_packets++;\r\n}\r\nelse\r\nnetdev->stats.tx_errors++;\r\nif (txs->defer)\r\nnetdev->stats.collisions++;\r\nif (txs->abort_col)\r\nnetdev->stats.tx_aborted_errors++;\r\nif (txs->late_col)\r\nnetdev->stats.tx_window_errors++;\r\nif (txs->underun)\r\nnetdev->stats.tx_fifo_errors++;\r\n} while (1);\r\nif (free_hole) {\r\nif (netif_queue_stopped(adapter->netdev) &&\r\nnetif_carrier_ok(adapter->netdev))\r\nnetif_wake_queue(adapter->netdev);\r\n}\r\n}\r\nstatic void atl2_check_for_link(struct atl2_adapter *adapter)\r\n{\r\nstruct net_device *netdev = adapter->netdev;\r\nu16 phy_data = 0;\r\nspin_lock(&adapter->stats_lock);\r\natl2_read_phy_reg(&adapter->hw, MII_BMSR, &phy_data);\r\natl2_read_phy_reg(&adapter->hw, MII_BMSR, &phy_data);\r\nspin_unlock(&adapter->stats_lock);\r\nif (!(phy_data & BMSR_LSTATUS)) {\r\nif (netif_carrier_ok(netdev)) {\r\nprintk(KERN_INFO "%s: %s NIC Link is Down\n",\r\natl2_driver_name, netdev->name);\r\nadapter->link_speed = SPEED_0;\r\nnetif_carrier_off(netdev);\r\nnetif_stop_queue(netdev);\r\n}\r\n}\r\nschedule_work(&adapter->link_chg_task);\r\n}\r\nstatic inline void atl2_clear_phy_int(struct atl2_adapter *adapter)\r\n{\r\nu16 phy_data;\r\nspin_lock(&adapter->stats_lock);\r\natl2_read_phy_reg(&adapter->hw, 19, &phy_data);\r\nspin_unlock(&adapter->stats_lock);\r\n}\r\nstatic irqreturn_t atl2_intr(int irq, void *data)\r\n{\r\nstruct atl2_adapter *adapter = netdev_priv(data);\r\nstruct atl2_hw *hw = &adapter->hw;\r\nu32 status;\r\nstatus = ATL2_READ_REG(hw, REG_ISR);\r\nif (0 == status)\r\nreturn IRQ_NONE;\r\nif (status & ISR_PHY)\r\natl2_clear_phy_int(adapter);\r\nATL2_WRITE_REG(hw, REG_ISR, status | ISR_DIS_INT);\r\nif (status & ISR_PHY_LINKDOWN) {\r\nif (netif_running(adapter->netdev)) {\r\nATL2_WRITE_REG(hw, REG_ISR, 0);\r\nATL2_WRITE_REG(hw, REG_IMR, 0);\r\nATL2_WRITE_FLUSH(hw);\r\nschedule_work(&adapter->reset_task);\r\nreturn IRQ_HANDLED;\r\n}\r\n}\r\nif (status & (ISR_DMAR_TO_RST | ISR_DMAW_TO_RST)) {\r\nATL2_WRITE_REG(hw, REG_ISR, 0);\r\nATL2_WRITE_REG(hw, REG_IMR, 0);\r\nATL2_WRITE_FLUSH(hw);\r\nschedule_work(&adapter->reset_task);\r\nreturn IRQ_HANDLED;\r\n}\r\nif (status & (ISR_PHY | ISR_MANUAL)) {\r\nadapter->netdev->stats.tx_carrier_errors++;\r\natl2_check_for_link(adapter);\r\n}\r\nif (status & ISR_TX_EVENT)\r\natl2_intr_tx(adapter);\r\nif (status & ISR_RX_EVENT)\r\natl2_intr_rx(adapter);\r\nATL2_WRITE_REG(&adapter->hw, REG_ISR, 0);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int atl2_request_irq(struct atl2_adapter *adapter)\r\n{\r\nstruct net_device *netdev = adapter->netdev;\r\nint flags, err = 0;\r\nflags = IRQF_SHARED;\r\nadapter->have_msi = true;\r\nerr = pci_enable_msi(adapter->pdev);\r\nif (err)\r\nadapter->have_msi = false;\r\nif (adapter->have_msi)\r\nflags &= ~IRQF_SHARED;\r\nreturn request_irq(adapter->pdev->irq, atl2_intr, flags, netdev->name,\r\nnetdev);\r\n}\r\nstatic void atl2_free_ring_resources(struct atl2_adapter *adapter)\r\n{\r\nstruct pci_dev *pdev = adapter->pdev;\r\npci_free_consistent(pdev, adapter->ring_size, adapter->ring_vir_addr,\r\nadapter->ring_dma);\r\n}\r\nstatic int atl2_open(struct net_device *netdev)\r\n{\r\nstruct atl2_adapter *adapter = netdev_priv(netdev);\r\nint err;\r\nu32 val;\r\nif (test_bit(__ATL2_TESTING, &adapter->flags))\r\nreturn -EBUSY;\r\nerr = atl2_setup_ring_resources(adapter);\r\nif (err)\r\nreturn err;\r\nerr = atl2_init_hw(&adapter->hw);\r\nif (err) {\r\nerr = -EIO;\r\ngoto err_init_hw;\r\n}\r\natl2_set_multi(netdev);\r\ninit_ring_ptrs(adapter);\r\natl2_restore_vlan(adapter);\r\nif (atl2_configure(adapter)) {\r\nerr = -EIO;\r\ngoto err_config;\r\n}\r\nerr = atl2_request_irq(adapter);\r\nif (err)\r\ngoto err_req_irq;\r\nclear_bit(__ATL2_DOWN, &adapter->flags);\r\nmod_timer(&adapter->watchdog_timer, round_jiffies(jiffies + 4*HZ));\r\nval = ATL2_READ_REG(&adapter->hw, REG_MASTER_CTRL);\r\nATL2_WRITE_REG(&adapter->hw, REG_MASTER_CTRL,\r\nval | MASTER_CTRL_MANUAL_INT);\r\natl2_irq_enable(adapter);\r\nreturn 0;\r\nerr_init_hw:\r\nerr_req_irq:\r\nerr_config:\r\natl2_free_ring_resources(adapter);\r\natl2_reset_hw(&adapter->hw);\r\nreturn err;\r\n}\r\nstatic void atl2_down(struct atl2_adapter *adapter)\r\n{\r\nstruct net_device *netdev = adapter->netdev;\r\nset_bit(__ATL2_DOWN, &adapter->flags);\r\nnetif_tx_disable(netdev);\r\natl2_reset_hw(&adapter->hw);\r\nmsleep(1);\r\natl2_irq_disable(adapter);\r\ndel_timer_sync(&adapter->watchdog_timer);\r\ndel_timer_sync(&adapter->phy_config_timer);\r\nclear_bit(0, &adapter->cfg_phy);\r\nnetif_carrier_off(netdev);\r\nadapter->link_speed = SPEED_0;\r\nadapter->link_duplex = -1;\r\n}\r\nstatic void atl2_free_irq(struct atl2_adapter *adapter)\r\n{\r\nstruct net_device *netdev = adapter->netdev;\r\nfree_irq(adapter->pdev->irq, netdev);\r\n#ifdef CONFIG_PCI_MSI\r\nif (adapter->have_msi)\r\npci_disable_msi(adapter->pdev);\r\n#endif\r\n}\r\nstatic int atl2_close(struct net_device *netdev)\r\n{\r\nstruct atl2_adapter *adapter = netdev_priv(netdev);\r\nWARN_ON(test_bit(__ATL2_RESETTING, &adapter->flags));\r\natl2_down(adapter);\r\natl2_free_irq(adapter);\r\natl2_free_ring_resources(adapter);\r\nreturn 0;\r\n}\r\nstatic inline int TxsFreeUnit(struct atl2_adapter *adapter)\r\n{\r\nu32 txs_write_ptr = (u32) atomic_read(&adapter->txs_write_ptr);\r\nreturn (adapter->txs_next_clear >= txs_write_ptr) ?\r\n(int) (adapter->txs_ring_size - adapter->txs_next_clear +\r\ntxs_write_ptr - 1) :\r\n(int) (txs_write_ptr - adapter->txs_next_clear - 1);\r\n}\r\nstatic inline int TxdFreeBytes(struct atl2_adapter *adapter)\r\n{\r\nu32 txd_read_ptr = (u32)atomic_read(&adapter->txd_read_ptr);\r\nreturn (adapter->txd_write_ptr >= txd_read_ptr) ?\r\n(int) (adapter->txd_ring_size - adapter->txd_write_ptr +\r\ntxd_read_ptr - 1) :\r\n(int) (txd_read_ptr - adapter->txd_write_ptr - 1);\r\n}\r\nstatic netdev_tx_t atl2_xmit_frame(struct sk_buff *skb,\r\nstruct net_device *netdev)\r\n{\r\nstruct atl2_adapter *adapter = netdev_priv(netdev);\r\nstruct tx_pkt_header *txph;\r\nu32 offset, copy_len;\r\nint txs_unused;\r\nint txbuf_unused;\r\nif (test_bit(__ATL2_DOWN, &adapter->flags)) {\r\ndev_kfree_skb_any(skb);\r\nreturn NETDEV_TX_OK;\r\n}\r\nif (unlikely(skb->len <= 0)) {\r\ndev_kfree_skb_any(skb);\r\nreturn NETDEV_TX_OK;\r\n}\r\ntxs_unused = TxsFreeUnit(adapter);\r\ntxbuf_unused = TxdFreeBytes(adapter);\r\nif (skb->len + sizeof(struct tx_pkt_header) + 4 > txbuf_unused ||\r\ntxs_unused < 1) {\r\nnetif_stop_queue(netdev);\r\nreturn NETDEV_TX_BUSY;\r\n}\r\noffset = adapter->txd_write_ptr;\r\ntxph = (struct tx_pkt_header *) (((u8 *)adapter->txd_ring) + offset);\r\n*(u32 *)txph = 0;\r\ntxph->pkt_size = skb->len;\r\noffset += 4;\r\nif (offset >= adapter->txd_ring_size)\r\noffset -= adapter->txd_ring_size;\r\ncopy_len = adapter->txd_ring_size - offset;\r\nif (copy_len >= skb->len) {\r\nmemcpy(((u8 *)adapter->txd_ring) + offset, skb->data, skb->len);\r\noffset += ((u32)(skb->len + 3) & ~3);\r\n} else {\r\nmemcpy(((u8 *)adapter->txd_ring)+offset, skb->data, copy_len);\r\nmemcpy((u8 *)adapter->txd_ring, skb->data+copy_len,\r\nskb->len-copy_len);\r\noffset = ((u32)(skb->len-copy_len + 3) & ~3);\r\n}\r\n#ifdef NETIF_F_HW_VLAN_CTAG_TX\r\nif (skb_vlan_tag_present(skb)) {\r\nu16 vlan_tag = skb_vlan_tag_get(skb);\r\nvlan_tag = (vlan_tag << 4) |\r\n(vlan_tag >> 13) |\r\n((vlan_tag >> 9) & 0x8);\r\ntxph->ins_vlan = 1;\r\ntxph->vlan = vlan_tag;\r\n}\r\n#endif\r\nif (offset >= adapter->txd_ring_size)\r\noffset -= adapter->txd_ring_size;\r\nadapter->txd_write_ptr = offset;\r\nadapter->txs_ring[adapter->txs_next_clear].update = 0;\r\nif (++adapter->txs_next_clear == adapter->txs_ring_size)\r\nadapter->txs_next_clear = 0;\r\nATL2_WRITE_REGW(&adapter->hw, REG_MB_TXD_WR_IDX,\r\n(adapter->txd_write_ptr >> 2));\r\nmmiowb();\r\ndev_kfree_skb_any(skb);\r\nreturn NETDEV_TX_OK;\r\n}\r\nstatic int atl2_change_mtu(struct net_device *netdev, int new_mtu)\r\n{\r\nstruct atl2_adapter *adapter = netdev_priv(netdev);\r\nstruct atl2_hw *hw = &adapter->hw;\r\nif ((new_mtu < 40) || (new_mtu > (ETH_DATA_LEN + VLAN_SIZE)))\r\nreturn -EINVAL;\r\nif (hw->max_frame_size != new_mtu) {\r\nnetdev->mtu = new_mtu;\r\nATL2_WRITE_REG(hw, REG_MTU, new_mtu + ENET_HEADER_SIZE +\r\nVLAN_SIZE + ETHERNET_FCS_SIZE);\r\n}\r\nreturn 0;\r\n}\r\nstatic int atl2_set_mac(struct net_device *netdev, void *p)\r\n{\r\nstruct atl2_adapter *adapter = netdev_priv(netdev);\r\nstruct sockaddr *addr = p;\r\nif (!is_valid_ether_addr(addr->sa_data))\r\nreturn -EADDRNOTAVAIL;\r\nif (netif_running(netdev))\r\nreturn -EBUSY;\r\nmemcpy(netdev->dev_addr, addr->sa_data, netdev->addr_len);\r\nmemcpy(adapter->hw.mac_addr, addr->sa_data, netdev->addr_len);\r\natl2_set_mac_addr(&adapter->hw);\r\nreturn 0;\r\n}\r\nstatic int atl2_mii_ioctl(struct net_device *netdev, struct ifreq *ifr, int cmd)\r\n{\r\nstruct atl2_adapter *adapter = netdev_priv(netdev);\r\nstruct mii_ioctl_data *data = if_mii(ifr);\r\nunsigned long flags;\r\nswitch (cmd) {\r\ncase SIOCGMIIPHY:\r\ndata->phy_id = 0;\r\nbreak;\r\ncase SIOCGMIIREG:\r\nspin_lock_irqsave(&adapter->stats_lock, flags);\r\nif (atl2_read_phy_reg(&adapter->hw,\r\ndata->reg_num & 0x1F, &data->val_out)) {\r\nspin_unlock_irqrestore(&adapter->stats_lock, flags);\r\nreturn -EIO;\r\n}\r\nspin_unlock_irqrestore(&adapter->stats_lock, flags);\r\nbreak;\r\ncase SIOCSMIIREG:\r\nif (data->reg_num & ~(0x1F))\r\nreturn -EFAULT;\r\nspin_lock_irqsave(&adapter->stats_lock, flags);\r\nif (atl2_write_phy_reg(&adapter->hw, data->reg_num,\r\ndata->val_in)) {\r\nspin_unlock_irqrestore(&adapter->stats_lock, flags);\r\nreturn -EIO;\r\n}\r\nspin_unlock_irqrestore(&adapter->stats_lock, flags);\r\nbreak;\r\ndefault:\r\nreturn -EOPNOTSUPP;\r\n}\r\nreturn 0;\r\n}\r\nstatic int atl2_ioctl(struct net_device *netdev, struct ifreq *ifr, int cmd)\r\n{\r\nswitch (cmd) {\r\ncase SIOCGMIIPHY:\r\ncase SIOCGMIIREG:\r\ncase SIOCSMIIREG:\r\nreturn atl2_mii_ioctl(netdev, ifr, cmd);\r\n#ifdef ETHTOOL_OPS_COMPAT\r\ncase SIOCETHTOOL:\r\nreturn ethtool_ioctl(ifr);\r\n#endif\r\ndefault:\r\nreturn -EOPNOTSUPP;\r\n}\r\n}\r\nstatic void atl2_tx_timeout(struct net_device *netdev)\r\n{\r\nstruct atl2_adapter *adapter = netdev_priv(netdev);\r\nschedule_work(&adapter->reset_task);\r\n}\r\nstatic void atl2_watchdog(unsigned long data)\r\n{\r\nstruct atl2_adapter *adapter = (struct atl2_adapter *) data;\r\nif (!test_bit(__ATL2_DOWN, &adapter->flags)) {\r\nu32 drop_rxd, drop_rxs;\r\nunsigned long flags;\r\nspin_lock_irqsave(&adapter->stats_lock, flags);\r\ndrop_rxd = ATL2_READ_REG(&adapter->hw, REG_STS_RXD_OV);\r\ndrop_rxs = ATL2_READ_REG(&adapter->hw, REG_STS_RXS_OV);\r\nspin_unlock_irqrestore(&adapter->stats_lock, flags);\r\nadapter->netdev->stats.rx_over_errors += drop_rxd + drop_rxs;\r\nmod_timer(&adapter->watchdog_timer,\r\nround_jiffies(jiffies + 4 * HZ));\r\n}\r\n}\r\nstatic void atl2_phy_config(unsigned long data)\r\n{\r\nstruct atl2_adapter *adapter = (struct atl2_adapter *) data;\r\nstruct atl2_hw *hw = &adapter->hw;\r\nunsigned long flags;\r\nspin_lock_irqsave(&adapter->stats_lock, flags);\r\natl2_write_phy_reg(hw, MII_ADVERTISE, hw->mii_autoneg_adv_reg);\r\natl2_write_phy_reg(hw, MII_BMCR, MII_CR_RESET | MII_CR_AUTO_NEG_EN |\r\nMII_CR_RESTART_AUTO_NEG);\r\nspin_unlock_irqrestore(&adapter->stats_lock, flags);\r\nclear_bit(0, &adapter->cfg_phy);\r\n}\r\nstatic int atl2_up(struct atl2_adapter *adapter)\r\n{\r\nstruct net_device *netdev = adapter->netdev;\r\nint err = 0;\r\nu32 val;\r\nerr = atl2_init_hw(&adapter->hw);\r\nif (err) {\r\nerr = -EIO;\r\nreturn err;\r\n}\r\natl2_set_multi(netdev);\r\ninit_ring_ptrs(adapter);\r\natl2_restore_vlan(adapter);\r\nif (atl2_configure(adapter)) {\r\nerr = -EIO;\r\ngoto err_up;\r\n}\r\nclear_bit(__ATL2_DOWN, &adapter->flags);\r\nval = ATL2_READ_REG(&adapter->hw, REG_MASTER_CTRL);\r\nATL2_WRITE_REG(&adapter->hw, REG_MASTER_CTRL, val |\r\nMASTER_CTRL_MANUAL_INT);\r\natl2_irq_enable(adapter);\r\nerr_up:\r\nreturn err;\r\n}\r\nstatic void atl2_reinit_locked(struct atl2_adapter *adapter)\r\n{\r\nWARN_ON(in_interrupt());\r\nwhile (test_and_set_bit(__ATL2_RESETTING, &adapter->flags))\r\nmsleep(1);\r\natl2_down(adapter);\r\natl2_up(adapter);\r\nclear_bit(__ATL2_RESETTING, &adapter->flags);\r\n}\r\nstatic void atl2_reset_task(struct work_struct *work)\r\n{\r\nstruct atl2_adapter *adapter;\r\nadapter = container_of(work, struct atl2_adapter, reset_task);\r\natl2_reinit_locked(adapter);\r\n}\r\nstatic void atl2_setup_mac_ctrl(struct atl2_adapter *adapter)\r\n{\r\nu32 value;\r\nstruct atl2_hw *hw = &adapter->hw;\r\nstruct net_device *netdev = adapter->netdev;\r\nvalue = MAC_CTRL_TX_EN | MAC_CTRL_RX_EN | MAC_CTRL_MACLP_CLK_PHY;\r\nif (FULL_DUPLEX == adapter->link_duplex)\r\nvalue |= MAC_CTRL_DUPLX;\r\nvalue |= (MAC_CTRL_TX_FLOW | MAC_CTRL_RX_FLOW);\r\nvalue |= (MAC_CTRL_ADD_CRC | MAC_CTRL_PAD);\r\nvalue |= (((u32)adapter->hw.preamble_len & MAC_CTRL_PRMLEN_MASK) <<\r\nMAC_CTRL_PRMLEN_SHIFT);\r\n__atl2_vlan_mode(netdev->features, &value);\r\nvalue |= MAC_CTRL_BC_EN;\r\nif (netdev->flags & IFF_PROMISC)\r\nvalue |= MAC_CTRL_PROMIS_EN;\r\nelse if (netdev->flags & IFF_ALLMULTI)\r\nvalue |= MAC_CTRL_MC_ALL_EN;\r\nvalue |= (((u32)(adapter->hw.retry_buf &\r\nMAC_CTRL_HALF_LEFT_BUF_MASK)) << MAC_CTRL_HALF_LEFT_BUF_SHIFT);\r\nATL2_WRITE_REG(hw, REG_MAC_CTRL, value);\r\n}\r\nstatic int atl2_check_link(struct atl2_adapter *adapter)\r\n{\r\nstruct atl2_hw *hw = &adapter->hw;\r\nstruct net_device *netdev = adapter->netdev;\r\nint ret_val;\r\nu16 speed, duplex, phy_data;\r\nint reconfig = 0;\r\natl2_read_phy_reg(hw, MII_BMSR, &phy_data);\r\natl2_read_phy_reg(hw, MII_BMSR, &phy_data);\r\nif (!(phy_data&BMSR_LSTATUS)) {\r\nif (netif_carrier_ok(netdev)) {\r\nu32 value;\r\nvalue = ATL2_READ_REG(hw, REG_MAC_CTRL);\r\nvalue &= ~MAC_CTRL_RX_EN;\r\nATL2_WRITE_REG(hw, REG_MAC_CTRL, value);\r\nadapter->link_speed = SPEED_0;\r\nnetif_carrier_off(netdev);\r\nnetif_stop_queue(netdev);\r\n}\r\nreturn 0;\r\n}\r\nret_val = atl2_get_speed_and_duplex(hw, &speed, &duplex);\r\nif (ret_val)\r\nreturn ret_val;\r\nswitch (hw->MediaType) {\r\ncase MEDIA_TYPE_100M_FULL:\r\nif (speed != SPEED_100 || duplex != FULL_DUPLEX)\r\nreconfig = 1;\r\nbreak;\r\ncase MEDIA_TYPE_100M_HALF:\r\nif (speed != SPEED_100 || duplex != HALF_DUPLEX)\r\nreconfig = 1;\r\nbreak;\r\ncase MEDIA_TYPE_10M_FULL:\r\nif (speed != SPEED_10 || duplex != FULL_DUPLEX)\r\nreconfig = 1;\r\nbreak;\r\ncase MEDIA_TYPE_10M_HALF:\r\nif (speed != SPEED_10 || duplex != HALF_DUPLEX)\r\nreconfig = 1;\r\nbreak;\r\n}\r\nif (reconfig == 0) {\r\nif (adapter->link_speed != speed ||\r\nadapter->link_duplex != duplex) {\r\nadapter->link_speed = speed;\r\nadapter->link_duplex = duplex;\r\natl2_setup_mac_ctrl(adapter);\r\nprintk(KERN_INFO "%s: %s NIC Link is Up<%d Mbps %s>\n",\r\natl2_driver_name, netdev->name,\r\nadapter->link_speed,\r\nadapter->link_duplex == FULL_DUPLEX ?\r\n"Full Duplex" : "Half Duplex");\r\n}\r\nif (!netif_carrier_ok(netdev)) {\r\nnetif_carrier_on(netdev);\r\nnetif_wake_queue(netdev);\r\n}\r\nreturn 0;\r\n}\r\nif (netif_carrier_ok(netdev)) {\r\nu32 value;\r\nvalue = ATL2_READ_REG(hw, REG_MAC_CTRL);\r\nvalue &= ~MAC_CTRL_RX_EN;\r\nATL2_WRITE_REG(hw, REG_MAC_CTRL, value);\r\nadapter->link_speed = SPEED_0;\r\nnetif_carrier_off(netdev);\r\nnetif_stop_queue(netdev);\r\n}\r\nif (!test_bit(__ATL2_DOWN, &adapter->flags)) {\r\nif (!test_and_set_bit(0, &adapter->cfg_phy))\r\nmod_timer(&adapter->phy_config_timer,\r\nround_jiffies(jiffies + 5 * HZ));\r\n}\r\nreturn 0;\r\n}\r\nstatic void atl2_link_chg_task(struct work_struct *work)\r\n{\r\nstruct atl2_adapter *adapter;\r\nunsigned long flags;\r\nadapter = container_of(work, struct atl2_adapter, link_chg_task);\r\nspin_lock_irqsave(&adapter->stats_lock, flags);\r\natl2_check_link(adapter);\r\nspin_unlock_irqrestore(&adapter->stats_lock, flags);\r\n}\r\nstatic void atl2_setup_pcicmd(struct pci_dev *pdev)\r\n{\r\nu16 cmd;\r\npci_read_config_word(pdev, PCI_COMMAND, &cmd);\r\nif (cmd & PCI_COMMAND_INTX_DISABLE)\r\ncmd &= ~PCI_COMMAND_INTX_DISABLE;\r\nif (cmd & PCI_COMMAND_IO)\r\ncmd &= ~PCI_COMMAND_IO;\r\nif (0 == (cmd & PCI_COMMAND_MEMORY))\r\ncmd |= PCI_COMMAND_MEMORY;\r\nif (0 == (cmd & PCI_COMMAND_MASTER))\r\ncmd |= PCI_COMMAND_MASTER;\r\npci_write_config_word(pdev, PCI_COMMAND, cmd);\r\npci_write_config_dword(pdev, REG_PM_CTRLSTAT, 0);\r\n}\r\nstatic void atl2_poll_controller(struct net_device *netdev)\r\n{\r\ndisable_irq(netdev->irq);\r\natl2_intr(netdev->irq, netdev);\r\nenable_irq(netdev->irq);\r\n}\r\nstatic int atl2_probe(struct pci_dev *pdev, const struct pci_device_id *ent)\r\n{\r\nstruct net_device *netdev;\r\nstruct atl2_adapter *adapter;\r\nstatic int cards_found;\r\nunsigned long mmio_start;\r\nint mmio_len;\r\nint err;\r\ncards_found = 0;\r\nerr = pci_enable_device(pdev);\r\nif (err)\r\nreturn err;\r\nif (pci_set_dma_mask(pdev, DMA_BIT_MASK(32)) &&\r\npci_set_consistent_dma_mask(pdev, DMA_BIT_MASK(32))) {\r\nprintk(KERN_ERR "atl2: No usable DMA configuration, aborting\n");\r\ngoto err_dma;\r\n}\r\nerr = pci_request_regions(pdev, atl2_driver_name);\r\nif (err)\r\ngoto err_pci_reg;\r\npci_set_master(pdev);\r\nerr = -ENOMEM;\r\nnetdev = alloc_etherdev(sizeof(struct atl2_adapter));\r\nif (!netdev)\r\ngoto err_alloc_etherdev;\r\nSET_NETDEV_DEV(netdev, &pdev->dev);\r\npci_set_drvdata(pdev, netdev);\r\nadapter = netdev_priv(netdev);\r\nadapter->netdev = netdev;\r\nadapter->pdev = pdev;\r\nadapter->hw.back = adapter;\r\nmmio_start = pci_resource_start(pdev, 0x0);\r\nmmio_len = pci_resource_len(pdev, 0x0);\r\nadapter->hw.mem_rang = (u32)mmio_len;\r\nadapter->hw.hw_addr = ioremap(mmio_start, mmio_len);\r\nif (!adapter->hw.hw_addr) {\r\nerr = -EIO;\r\ngoto err_ioremap;\r\n}\r\natl2_setup_pcicmd(pdev);\r\nnetdev->netdev_ops = &atl2_netdev_ops;\r\nnetdev->ethtool_ops = &atl2_ethtool_ops;\r\nnetdev->watchdog_timeo = 5 * HZ;\r\nstrncpy(netdev->name, pci_name(pdev), sizeof(netdev->name) - 1);\r\nnetdev->mem_start = mmio_start;\r\nnetdev->mem_end = mmio_start + mmio_len;\r\nadapter->bd_number = cards_found;\r\nadapter->pci_using_64 = false;\r\nerr = atl2_sw_init(adapter);\r\nif (err)\r\ngoto err_sw_init;\r\nerr = -EIO;\r\nnetdev->hw_features = NETIF_F_SG | NETIF_F_HW_VLAN_CTAG_RX;\r\nnetdev->features |= (NETIF_F_HW_VLAN_CTAG_TX | NETIF_F_HW_VLAN_CTAG_RX);\r\natl2_phy_init(&adapter->hw);\r\nif (atl2_reset_hw(&adapter->hw)) {\r\nerr = -EIO;\r\ngoto err_reset;\r\n}\r\natl2_read_mac_addr(&adapter->hw);\r\nmemcpy(netdev->dev_addr, adapter->hw.mac_addr, netdev->addr_len);\r\nif (!is_valid_ether_addr(netdev->dev_addr)) {\r\nerr = -EIO;\r\ngoto err_eeprom;\r\n}\r\natl2_check_options(adapter);\r\nsetup_timer(&adapter->watchdog_timer, atl2_watchdog,\r\n(unsigned long)adapter);\r\nsetup_timer(&adapter->phy_config_timer, atl2_phy_config,\r\n(unsigned long)adapter);\r\nINIT_WORK(&adapter->reset_task, atl2_reset_task);\r\nINIT_WORK(&adapter->link_chg_task, atl2_link_chg_task);\r\nstrcpy(netdev->name, "eth%d");\r\nerr = register_netdev(netdev);\r\nif (err)\r\ngoto err_register;\r\nnetif_carrier_off(netdev);\r\nnetif_stop_queue(netdev);\r\ncards_found++;\r\nreturn 0;\r\nerr_reset:\r\nerr_register:\r\nerr_sw_init:\r\nerr_eeprom:\r\niounmap(adapter->hw.hw_addr);\r\nerr_ioremap:\r\nfree_netdev(netdev);\r\nerr_alloc_etherdev:\r\npci_release_regions(pdev);\r\nerr_pci_reg:\r\nerr_dma:\r\npci_disable_device(pdev);\r\nreturn err;\r\n}\r\nstatic void atl2_remove(struct pci_dev *pdev)\r\n{\r\nstruct net_device *netdev = pci_get_drvdata(pdev);\r\nstruct atl2_adapter *adapter = netdev_priv(netdev);\r\nset_bit(__ATL2_DOWN, &adapter->flags);\r\ndel_timer_sync(&adapter->watchdog_timer);\r\ndel_timer_sync(&adapter->phy_config_timer);\r\ncancel_work_sync(&adapter->reset_task);\r\ncancel_work_sync(&adapter->link_chg_task);\r\nunregister_netdev(netdev);\r\natl2_force_ps(&adapter->hw);\r\niounmap(adapter->hw.hw_addr);\r\npci_release_regions(pdev);\r\nfree_netdev(netdev);\r\npci_disable_device(pdev);\r\n}\r\nstatic int atl2_suspend(struct pci_dev *pdev, pm_message_t state)\r\n{\r\nstruct net_device *netdev = pci_get_drvdata(pdev);\r\nstruct atl2_adapter *adapter = netdev_priv(netdev);\r\nstruct atl2_hw *hw = &adapter->hw;\r\nu16 speed, duplex;\r\nu32 ctrl = 0;\r\nu32 wufc = adapter->wol;\r\n#ifdef CONFIG_PM\r\nint retval = 0;\r\n#endif\r\nnetif_device_detach(netdev);\r\nif (netif_running(netdev)) {\r\nWARN_ON(test_bit(__ATL2_RESETTING, &adapter->flags));\r\natl2_down(adapter);\r\n}\r\n#ifdef CONFIG_PM\r\nretval = pci_save_state(pdev);\r\nif (retval)\r\nreturn retval;\r\n#endif\r\natl2_read_phy_reg(hw, MII_BMSR, (u16 *)&ctrl);\r\natl2_read_phy_reg(hw, MII_BMSR, (u16 *)&ctrl);\r\nif (ctrl & BMSR_LSTATUS)\r\nwufc &= ~ATLX_WUFC_LNKC;\r\nif (0 != (ctrl & BMSR_LSTATUS) && 0 != wufc) {\r\nu32 ret_val;\r\nret_val = atl2_get_speed_and_duplex(hw, &speed, &duplex);\r\nif (ret_val) {\r\nprintk(KERN_DEBUG\r\n"%s: get speed&duplex error while suspend\n",\r\natl2_driver_name);\r\ngoto wol_dis;\r\n}\r\nctrl = 0;\r\nif (wufc & ATLX_WUFC_MAG)\r\nctrl |= (WOL_MAGIC_EN | WOL_MAGIC_PME_EN);\r\nATL2_WRITE_REG(hw, REG_WOL_CTRL, ctrl);\r\nctrl = MAC_CTRL_RX_EN | MAC_CTRL_MACLP_CLK_PHY;\r\nif (FULL_DUPLEX == adapter->link_duplex)\r\nctrl |= MAC_CTRL_DUPLX;\r\nctrl |= (MAC_CTRL_ADD_CRC | MAC_CTRL_PAD);\r\nctrl |= (((u32)adapter->hw.preamble_len &\r\nMAC_CTRL_PRMLEN_MASK) << MAC_CTRL_PRMLEN_SHIFT);\r\nctrl |= (((u32)(adapter->hw.retry_buf &\r\nMAC_CTRL_HALF_LEFT_BUF_MASK)) <<\r\nMAC_CTRL_HALF_LEFT_BUF_SHIFT);\r\nif (wufc & ATLX_WUFC_MAG) {\r\nctrl |= MAC_CTRL_BC_EN;\r\n}\r\nATL2_WRITE_REG(hw, REG_MAC_CTRL, ctrl);\r\nctrl = ATL2_READ_REG(hw, REG_PCIE_PHYMISC);\r\nctrl |= PCIE_PHYMISC_FORCE_RCV_DET;\r\nATL2_WRITE_REG(hw, REG_PCIE_PHYMISC, ctrl);\r\nctrl = ATL2_READ_REG(hw, REG_PCIE_DLL_TX_CTRL1);\r\nctrl |= PCIE_DLL_TX_CTRL1_SEL_NOR_CLK;\r\nATL2_WRITE_REG(hw, REG_PCIE_DLL_TX_CTRL1, ctrl);\r\npci_enable_wake(pdev, pci_choose_state(pdev, state), 1);\r\ngoto suspend_exit;\r\n}\r\nif (0 == (ctrl&BMSR_LSTATUS) && 0 != (wufc&ATLX_WUFC_LNKC)) {\r\nctrl |= (WOL_LINK_CHG_EN | WOL_LINK_CHG_PME_EN);\r\nATL2_WRITE_REG(hw, REG_WOL_CTRL, ctrl);\r\nATL2_WRITE_REG(hw, REG_MAC_CTRL, 0);\r\nctrl = ATL2_READ_REG(hw, REG_PCIE_PHYMISC);\r\nctrl |= PCIE_PHYMISC_FORCE_RCV_DET;\r\nATL2_WRITE_REG(hw, REG_PCIE_PHYMISC, ctrl);\r\nctrl = ATL2_READ_REG(hw, REG_PCIE_DLL_TX_CTRL1);\r\nctrl |= PCIE_DLL_TX_CTRL1_SEL_NOR_CLK;\r\nATL2_WRITE_REG(hw, REG_PCIE_DLL_TX_CTRL1, ctrl);\r\nhw->phy_configured = false;\r\npci_enable_wake(pdev, pci_choose_state(pdev, state), 1);\r\ngoto suspend_exit;\r\n}\r\nwol_dis:\r\nATL2_WRITE_REG(hw, REG_WOL_CTRL, 0);\r\nctrl = ATL2_READ_REG(hw, REG_PCIE_PHYMISC);\r\nctrl |= PCIE_PHYMISC_FORCE_RCV_DET;\r\nATL2_WRITE_REG(hw, REG_PCIE_PHYMISC, ctrl);\r\nctrl = ATL2_READ_REG(hw, REG_PCIE_DLL_TX_CTRL1);\r\nctrl |= PCIE_DLL_TX_CTRL1_SEL_NOR_CLK;\r\nATL2_WRITE_REG(hw, REG_PCIE_DLL_TX_CTRL1, ctrl);\r\natl2_force_ps(hw);\r\nhw->phy_configured = false;\r\npci_enable_wake(pdev, pci_choose_state(pdev, state), 0);\r\nsuspend_exit:\r\nif (netif_running(netdev))\r\natl2_free_irq(adapter);\r\npci_disable_device(pdev);\r\npci_set_power_state(pdev, pci_choose_state(pdev, state));\r\nreturn 0;\r\n}\r\nstatic int atl2_resume(struct pci_dev *pdev)\r\n{\r\nstruct net_device *netdev = pci_get_drvdata(pdev);\r\nstruct atl2_adapter *adapter = netdev_priv(netdev);\r\nu32 err;\r\npci_set_power_state(pdev, PCI_D0);\r\npci_restore_state(pdev);\r\nerr = pci_enable_device(pdev);\r\nif (err) {\r\nprintk(KERN_ERR\r\n"atl2: Cannot enable PCI device from suspend\n");\r\nreturn err;\r\n}\r\npci_set_master(pdev);\r\nATL2_READ_REG(&adapter->hw, REG_WOL_CTRL);\r\npci_enable_wake(pdev, PCI_D3hot, 0);\r\npci_enable_wake(pdev, PCI_D3cold, 0);\r\nATL2_WRITE_REG(&adapter->hw, REG_WOL_CTRL, 0);\r\nif (netif_running(netdev)) {\r\nerr = atl2_request_irq(adapter);\r\nif (err)\r\nreturn err;\r\n}\r\natl2_reset_hw(&adapter->hw);\r\nif (netif_running(netdev))\r\natl2_up(adapter);\r\nnetif_device_attach(netdev);\r\nreturn 0;\r\n}\r\nstatic void atl2_shutdown(struct pci_dev *pdev)\r\n{\r\natl2_suspend(pdev, PMSG_SUSPEND);\r\n}\r\nstatic int __init atl2_init_module(void)\r\n{\r\nprintk(KERN_INFO "%s - version %s\n", atl2_driver_string,\r\natl2_driver_version);\r\nprintk(KERN_INFO "%s\n", atl2_copyright);\r\nreturn pci_register_driver(&atl2_driver);\r\n}\r\nstatic void __exit atl2_exit_module(void)\r\n{\r\npci_unregister_driver(&atl2_driver);\r\n}\r\nstatic void atl2_read_pci_cfg(struct atl2_hw *hw, u32 reg, u16 *value)\r\n{\r\nstruct atl2_adapter *adapter = hw->back;\r\npci_read_config_word(adapter->pdev, reg, value);\r\n}\r\nstatic void atl2_write_pci_cfg(struct atl2_hw *hw, u32 reg, u16 *value)\r\n{\r\nstruct atl2_adapter *adapter = hw->back;\r\npci_write_config_word(adapter->pdev, reg, *value);\r\n}\r\nstatic int atl2_get_settings(struct net_device *netdev,\r\nstruct ethtool_cmd *ecmd)\r\n{\r\nstruct atl2_adapter *adapter = netdev_priv(netdev);\r\nstruct atl2_hw *hw = &adapter->hw;\r\necmd->supported = (SUPPORTED_10baseT_Half |\r\nSUPPORTED_10baseT_Full |\r\nSUPPORTED_100baseT_Half |\r\nSUPPORTED_100baseT_Full |\r\nSUPPORTED_Autoneg |\r\nSUPPORTED_TP);\r\necmd->advertising = ADVERTISED_TP;\r\necmd->advertising |= ADVERTISED_Autoneg;\r\necmd->advertising |= hw->autoneg_advertised;\r\necmd->port = PORT_TP;\r\necmd->phy_address = 0;\r\necmd->transceiver = XCVR_INTERNAL;\r\nif (adapter->link_speed != SPEED_0) {\r\nethtool_cmd_speed_set(ecmd, adapter->link_speed);\r\nif (adapter->link_duplex == FULL_DUPLEX)\r\necmd->duplex = DUPLEX_FULL;\r\nelse\r\necmd->duplex = DUPLEX_HALF;\r\n} else {\r\nethtool_cmd_speed_set(ecmd, SPEED_UNKNOWN);\r\necmd->duplex = DUPLEX_UNKNOWN;\r\n}\r\necmd->autoneg = AUTONEG_ENABLE;\r\nreturn 0;\r\n}\r\nstatic int atl2_set_settings(struct net_device *netdev,\r\nstruct ethtool_cmd *ecmd)\r\n{\r\nstruct atl2_adapter *adapter = netdev_priv(netdev);\r\nstruct atl2_hw *hw = &adapter->hw;\r\nwhile (test_and_set_bit(__ATL2_RESETTING, &adapter->flags))\r\nmsleep(1);\r\nif (ecmd->autoneg == AUTONEG_ENABLE) {\r\n#define MY_ADV_MASK (ADVERTISE_10_HALF | \\r\nADVERTISE_10_FULL | \\r\nADVERTISE_100_HALF| \\r\nADVERTISE_100_FULL)\r\nif ((ecmd->advertising & MY_ADV_MASK) == MY_ADV_MASK) {\r\nhw->MediaType = MEDIA_TYPE_AUTO_SENSOR;\r\nhw->autoneg_advertised = MY_ADV_MASK;\r\n} else if ((ecmd->advertising & MY_ADV_MASK) ==\r\nADVERTISE_100_FULL) {\r\nhw->MediaType = MEDIA_TYPE_100M_FULL;\r\nhw->autoneg_advertised = ADVERTISE_100_FULL;\r\n} else if ((ecmd->advertising & MY_ADV_MASK) ==\r\nADVERTISE_100_HALF) {\r\nhw->MediaType = MEDIA_TYPE_100M_HALF;\r\nhw->autoneg_advertised = ADVERTISE_100_HALF;\r\n} else if ((ecmd->advertising & MY_ADV_MASK) ==\r\nADVERTISE_10_FULL) {\r\nhw->MediaType = MEDIA_TYPE_10M_FULL;\r\nhw->autoneg_advertised = ADVERTISE_10_FULL;\r\n} else if ((ecmd->advertising & MY_ADV_MASK) ==\r\nADVERTISE_10_HALF) {\r\nhw->MediaType = MEDIA_TYPE_10M_HALF;\r\nhw->autoneg_advertised = ADVERTISE_10_HALF;\r\n} else {\r\nclear_bit(__ATL2_RESETTING, &adapter->flags);\r\nreturn -EINVAL;\r\n}\r\necmd->advertising = hw->autoneg_advertised |\r\nADVERTISED_TP | ADVERTISED_Autoneg;\r\n} else {\r\nclear_bit(__ATL2_RESETTING, &adapter->flags);\r\nreturn -EINVAL;\r\n}\r\nif (netif_running(adapter->netdev)) {\r\natl2_down(adapter);\r\natl2_up(adapter);\r\n} else\r\natl2_reset_hw(&adapter->hw);\r\nclear_bit(__ATL2_RESETTING, &adapter->flags);\r\nreturn 0;\r\n}\r\nstatic u32 atl2_get_msglevel(struct net_device *netdev)\r\n{\r\nreturn 0;\r\n}\r\nstatic void atl2_set_msglevel(struct net_device *netdev, u32 data)\r\n{\r\n}\r\nstatic int atl2_get_regs_len(struct net_device *netdev)\r\n{\r\n#define ATL2_REGS_LEN 42\r\nreturn sizeof(u32) * ATL2_REGS_LEN;\r\n}\r\nstatic void atl2_get_regs(struct net_device *netdev,\r\nstruct ethtool_regs *regs, void *p)\r\n{\r\nstruct atl2_adapter *adapter = netdev_priv(netdev);\r\nstruct atl2_hw *hw = &adapter->hw;\r\nu32 *regs_buff = p;\r\nu16 phy_data;\r\nmemset(p, 0, sizeof(u32) * ATL2_REGS_LEN);\r\nregs->version = (1 << 24) | (hw->revision_id << 16) | hw->device_id;\r\nregs_buff[0] = ATL2_READ_REG(hw, REG_VPD_CAP);\r\nregs_buff[1] = ATL2_READ_REG(hw, REG_SPI_FLASH_CTRL);\r\nregs_buff[2] = ATL2_READ_REG(hw, REG_SPI_FLASH_CONFIG);\r\nregs_buff[3] = ATL2_READ_REG(hw, REG_TWSI_CTRL);\r\nregs_buff[4] = ATL2_READ_REG(hw, REG_PCIE_DEV_MISC_CTRL);\r\nregs_buff[5] = ATL2_READ_REG(hw, REG_MASTER_CTRL);\r\nregs_buff[6] = ATL2_READ_REG(hw, REG_MANUAL_TIMER_INIT);\r\nregs_buff[7] = ATL2_READ_REG(hw, REG_IRQ_MODU_TIMER_INIT);\r\nregs_buff[8] = ATL2_READ_REG(hw, REG_PHY_ENABLE);\r\nregs_buff[9] = ATL2_READ_REG(hw, REG_CMBDISDMA_TIMER);\r\nregs_buff[10] = ATL2_READ_REG(hw, REG_IDLE_STATUS);\r\nregs_buff[11] = ATL2_READ_REG(hw, REG_MDIO_CTRL);\r\nregs_buff[12] = ATL2_READ_REG(hw, REG_SERDES_LOCK);\r\nregs_buff[13] = ATL2_READ_REG(hw, REG_MAC_CTRL);\r\nregs_buff[14] = ATL2_READ_REG(hw, REG_MAC_IPG_IFG);\r\nregs_buff[15] = ATL2_READ_REG(hw, REG_MAC_STA_ADDR);\r\nregs_buff[16] = ATL2_READ_REG(hw, REG_MAC_STA_ADDR+4);\r\nregs_buff[17] = ATL2_READ_REG(hw, REG_RX_HASH_TABLE);\r\nregs_buff[18] = ATL2_READ_REG(hw, REG_RX_HASH_TABLE+4);\r\nregs_buff[19] = ATL2_READ_REG(hw, REG_MAC_HALF_DUPLX_CTRL);\r\nregs_buff[20] = ATL2_READ_REG(hw, REG_MTU);\r\nregs_buff[21] = ATL2_READ_REG(hw, REG_WOL_CTRL);\r\nregs_buff[22] = ATL2_READ_REG(hw, REG_SRAM_TXRAM_END);\r\nregs_buff[23] = ATL2_READ_REG(hw, REG_DESC_BASE_ADDR_HI);\r\nregs_buff[24] = ATL2_READ_REG(hw, REG_TXD_BASE_ADDR_LO);\r\nregs_buff[25] = ATL2_READ_REG(hw, REG_TXD_MEM_SIZE);\r\nregs_buff[26] = ATL2_READ_REG(hw, REG_TXS_BASE_ADDR_LO);\r\nregs_buff[27] = ATL2_READ_REG(hw, REG_TXS_MEM_SIZE);\r\nregs_buff[28] = ATL2_READ_REG(hw, REG_RXD_BASE_ADDR_LO);\r\nregs_buff[29] = ATL2_READ_REG(hw, REG_RXD_BUF_NUM);\r\nregs_buff[30] = ATL2_READ_REG(hw, REG_DMAR);\r\nregs_buff[31] = ATL2_READ_REG(hw, REG_TX_CUT_THRESH);\r\nregs_buff[32] = ATL2_READ_REG(hw, REG_DMAW);\r\nregs_buff[33] = ATL2_READ_REG(hw, REG_PAUSE_ON_TH);\r\nregs_buff[34] = ATL2_READ_REG(hw, REG_PAUSE_OFF_TH);\r\nregs_buff[35] = ATL2_READ_REG(hw, REG_MB_TXD_WR_IDX);\r\nregs_buff[36] = ATL2_READ_REG(hw, REG_MB_RXD_RD_IDX);\r\nregs_buff[38] = ATL2_READ_REG(hw, REG_ISR);\r\nregs_buff[39] = ATL2_READ_REG(hw, REG_IMR);\r\natl2_read_phy_reg(hw, MII_BMCR, &phy_data);\r\nregs_buff[40] = (u32)phy_data;\r\natl2_read_phy_reg(hw, MII_BMSR, &phy_data);\r\nregs_buff[41] = (u32)phy_data;\r\n}\r\nstatic int atl2_get_eeprom_len(struct net_device *netdev)\r\n{\r\nstruct atl2_adapter *adapter = netdev_priv(netdev);\r\nif (!atl2_check_eeprom_exist(&adapter->hw))\r\nreturn 512;\r\nelse\r\nreturn 0;\r\n}\r\nstatic int atl2_get_eeprom(struct net_device *netdev,\r\nstruct ethtool_eeprom *eeprom, u8 *bytes)\r\n{\r\nstruct atl2_adapter *adapter = netdev_priv(netdev);\r\nstruct atl2_hw *hw = &adapter->hw;\r\nu32 *eeprom_buff;\r\nint first_dword, last_dword;\r\nint ret_val = 0;\r\nint i;\r\nif (eeprom->len == 0)\r\nreturn -EINVAL;\r\nif (atl2_check_eeprom_exist(hw))\r\nreturn -EINVAL;\r\neeprom->magic = hw->vendor_id | (hw->device_id << 16);\r\nfirst_dword = eeprom->offset >> 2;\r\nlast_dword = (eeprom->offset + eeprom->len - 1) >> 2;\r\neeprom_buff = kmalloc(sizeof(u32) * (last_dword - first_dword + 1),\r\nGFP_KERNEL);\r\nif (!eeprom_buff)\r\nreturn -ENOMEM;\r\nfor (i = first_dword; i < last_dword; i++) {\r\nif (!atl2_read_eeprom(hw, i*4, &(eeprom_buff[i-first_dword]))) {\r\nret_val = -EIO;\r\ngoto free;\r\n}\r\n}\r\nmemcpy(bytes, (u8 *)eeprom_buff + (eeprom->offset & 3),\r\neeprom->len);\r\nfree:\r\nkfree(eeprom_buff);\r\nreturn ret_val;\r\n}\r\nstatic int atl2_set_eeprom(struct net_device *netdev,\r\nstruct ethtool_eeprom *eeprom, u8 *bytes)\r\n{\r\nstruct atl2_adapter *adapter = netdev_priv(netdev);\r\nstruct atl2_hw *hw = &adapter->hw;\r\nu32 *eeprom_buff;\r\nu32 *ptr;\r\nint max_len, first_dword, last_dword, ret_val = 0;\r\nint i;\r\nif (eeprom->len == 0)\r\nreturn -EOPNOTSUPP;\r\nif (eeprom->magic != (hw->vendor_id | (hw->device_id << 16)))\r\nreturn -EFAULT;\r\nmax_len = 512;\r\nfirst_dword = eeprom->offset >> 2;\r\nlast_dword = (eeprom->offset + eeprom->len - 1) >> 2;\r\neeprom_buff = kmalloc(max_len, GFP_KERNEL);\r\nif (!eeprom_buff)\r\nreturn -ENOMEM;\r\nptr = eeprom_buff;\r\nif (eeprom->offset & 3) {\r\nif (!atl2_read_eeprom(hw, first_dword*4, &(eeprom_buff[0]))) {\r\nret_val = -EIO;\r\ngoto out;\r\n}\r\nptr++;\r\n}\r\nif (((eeprom->offset + eeprom->len) & 3)) {\r\nif (!atl2_read_eeprom(hw, last_dword * 4,\r\n&(eeprom_buff[last_dword - first_dword]))) {\r\nret_val = -EIO;\r\ngoto out;\r\n}\r\n}\r\nmemcpy(ptr, bytes, eeprom->len);\r\nfor (i = 0; i < last_dword - first_dword + 1; i++) {\r\nif (!atl2_write_eeprom(hw, ((first_dword+i)*4), eeprom_buff[i])) {\r\nret_val = -EIO;\r\ngoto out;\r\n}\r\n}\r\nout:\r\nkfree(eeprom_buff);\r\nreturn ret_val;\r\n}\r\nstatic void atl2_get_drvinfo(struct net_device *netdev,\r\nstruct ethtool_drvinfo *drvinfo)\r\n{\r\nstruct atl2_adapter *adapter = netdev_priv(netdev);\r\nstrlcpy(drvinfo->driver, atl2_driver_name, sizeof(drvinfo->driver));\r\nstrlcpy(drvinfo->version, atl2_driver_version,\r\nsizeof(drvinfo->version));\r\nstrlcpy(drvinfo->fw_version, "L2", sizeof(drvinfo->fw_version));\r\nstrlcpy(drvinfo->bus_info, pci_name(adapter->pdev),\r\nsizeof(drvinfo->bus_info));\r\n}\r\nstatic void atl2_get_wol(struct net_device *netdev,\r\nstruct ethtool_wolinfo *wol)\r\n{\r\nstruct atl2_adapter *adapter = netdev_priv(netdev);\r\nwol->supported = WAKE_MAGIC;\r\nwol->wolopts = 0;\r\nif (adapter->wol & ATLX_WUFC_EX)\r\nwol->wolopts |= WAKE_UCAST;\r\nif (adapter->wol & ATLX_WUFC_MC)\r\nwol->wolopts |= WAKE_MCAST;\r\nif (adapter->wol & ATLX_WUFC_BC)\r\nwol->wolopts |= WAKE_BCAST;\r\nif (adapter->wol & ATLX_WUFC_MAG)\r\nwol->wolopts |= WAKE_MAGIC;\r\nif (adapter->wol & ATLX_WUFC_LNKC)\r\nwol->wolopts |= WAKE_PHY;\r\n}\r\nstatic int atl2_set_wol(struct net_device *netdev, struct ethtool_wolinfo *wol)\r\n{\r\nstruct atl2_adapter *adapter = netdev_priv(netdev);\r\nif (wol->wolopts & (WAKE_ARP | WAKE_MAGICSECURE))\r\nreturn -EOPNOTSUPP;\r\nif (wol->wolopts & (WAKE_UCAST | WAKE_BCAST | WAKE_MCAST))\r\nreturn -EOPNOTSUPP;\r\nadapter->wol = 0;\r\nif (wol->wolopts & WAKE_MAGIC)\r\nadapter->wol |= ATLX_WUFC_MAG;\r\nif (wol->wolopts & WAKE_PHY)\r\nadapter->wol |= ATLX_WUFC_LNKC;\r\nreturn 0;\r\n}\r\nstatic int atl2_nway_reset(struct net_device *netdev)\r\n{\r\nstruct atl2_adapter *adapter = netdev_priv(netdev);\r\nif (netif_running(netdev))\r\natl2_reinit_locked(adapter);\r\nreturn 0;\r\n}\r\nstatic s32 atl2_reset_hw(struct atl2_hw *hw)\r\n{\r\nu32 icr;\r\nu16 pci_cfg_cmd_word;\r\nint i;\r\natl2_read_pci_cfg(hw, PCI_REG_COMMAND, &pci_cfg_cmd_word);\r\nif ((pci_cfg_cmd_word &\r\n(CMD_IO_SPACE|CMD_MEMORY_SPACE|CMD_BUS_MASTER)) !=\r\n(CMD_IO_SPACE|CMD_MEMORY_SPACE|CMD_BUS_MASTER)) {\r\npci_cfg_cmd_word |=\r\n(CMD_IO_SPACE|CMD_MEMORY_SPACE|CMD_BUS_MASTER);\r\natl2_write_pci_cfg(hw, PCI_REG_COMMAND, &pci_cfg_cmd_word);\r\n}\r\nATL2_WRITE_REG(hw, REG_MASTER_CTRL, MASTER_CTRL_SOFT_RST);\r\nwmb();\r\nmsleep(1);\r\nfor (i = 0; i < 10; i++) {\r\nicr = ATL2_READ_REG(hw, REG_IDLE_STATUS);\r\nif (!icr)\r\nbreak;\r\nmsleep(1);\r\ncpu_relax();\r\n}\r\nif (icr)\r\nreturn icr;\r\nreturn 0;\r\n}\r\nstatic bool atl2_spi_read(struct atl2_hw *hw, u32 addr, u32 *buf)\r\n{\r\nint i;\r\nu32 value;\r\nATL2_WRITE_REG(hw, REG_SPI_DATA, 0);\r\nATL2_WRITE_REG(hw, REG_SPI_ADDR, addr);\r\nvalue = SPI_FLASH_CTRL_WAIT_READY |\r\n(CUSTOM_SPI_CS_SETUP & SPI_FLASH_CTRL_CS_SETUP_MASK) <<\r\nSPI_FLASH_CTRL_CS_SETUP_SHIFT |\r\n(CUSTOM_SPI_CLK_HI & SPI_FLASH_CTRL_CLK_HI_MASK) <<\r\nSPI_FLASH_CTRL_CLK_HI_SHIFT |\r\n(CUSTOM_SPI_CLK_LO & SPI_FLASH_CTRL_CLK_LO_MASK) <<\r\nSPI_FLASH_CTRL_CLK_LO_SHIFT |\r\n(CUSTOM_SPI_CS_HOLD & SPI_FLASH_CTRL_CS_HOLD_MASK) <<\r\nSPI_FLASH_CTRL_CS_HOLD_SHIFT |\r\n(CUSTOM_SPI_CS_HI & SPI_FLASH_CTRL_CS_HI_MASK) <<\r\nSPI_FLASH_CTRL_CS_HI_SHIFT |\r\n(0x1 & SPI_FLASH_CTRL_INS_MASK) << SPI_FLASH_CTRL_INS_SHIFT;\r\nATL2_WRITE_REG(hw, REG_SPI_FLASH_CTRL, value);\r\nvalue |= SPI_FLASH_CTRL_START;\r\nATL2_WRITE_REG(hw, REG_SPI_FLASH_CTRL, value);\r\nfor (i = 0; i < 10; i++) {\r\nmsleep(1);\r\nvalue = ATL2_READ_REG(hw, REG_SPI_FLASH_CTRL);\r\nif (!(value & SPI_FLASH_CTRL_START))\r\nbreak;\r\n}\r\nif (value & SPI_FLASH_CTRL_START)\r\nreturn false;\r\n*buf = ATL2_READ_REG(hw, REG_SPI_DATA);\r\nreturn true;\r\n}\r\nstatic int get_permanent_address(struct atl2_hw *hw)\r\n{\r\nu32 Addr[2];\r\nu32 i, Control;\r\nu16 Register;\r\nu8 EthAddr[ETH_ALEN];\r\nbool KeyValid;\r\nif (is_valid_ether_addr(hw->perm_mac_addr))\r\nreturn 0;\r\nAddr[0] = 0;\r\nAddr[1] = 0;\r\nif (!atl2_check_eeprom_exist(hw)) {\r\nRegister = 0;\r\nKeyValid = false;\r\ni = 0;\r\nwhile (1) {\r\nif (atl2_read_eeprom(hw, i + 0x100, &Control)) {\r\nif (KeyValid) {\r\nif (Register == REG_MAC_STA_ADDR)\r\nAddr[0] = Control;\r\nelse if (Register ==\r\n(REG_MAC_STA_ADDR + 4))\r\nAddr[1] = Control;\r\nKeyValid = false;\r\n} else if ((Control & 0xff) == 0x5A) {\r\nKeyValid = true;\r\nRegister = (u16) (Control >> 16);\r\n} else {\r\nbreak;\r\n}\r\n} else {\r\nbreak;\r\n}\r\ni += 4;\r\n}\r\n*(u32 *) &EthAddr[2] = LONGSWAP(Addr[0]);\r\n*(u16 *) &EthAddr[0] = SHORTSWAP(*(u16 *) &Addr[1]);\r\nif (is_valid_ether_addr(EthAddr)) {\r\nmemcpy(hw->perm_mac_addr, EthAddr, ETH_ALEN);\r\nreturn 0;\r\n}\r\nreturn 1;\r\n}\r\nAddr[0] = 0;\r\nAddr[1] = 0;\r\nRegister = 0;\r\nKeyValid = false;\r\ni = 0;\r\nwhile (1) {\r\nif (atl2_spi_read(hw, i + 0x1f000, &Control)) {\r\nif (KeyValid) {\r\nif (Register == REG_MAC_STA_ADDR)\r\nAddr[0] = Control;\r\nelse if (Register == (REG_MAC_STA_ADDR + 4))\r\nAddr[1] = Control;\r\nKeyValid = false;\r\n} else if ((Control & 0xff) == 0x5A) {\r\nKeyValid = true;\r\nRegister = (u16) (Control >> 16);\r\n} else {\r\nbreak;\r\n}\r\n} else {\r\nbreak;\r\n}\r\ni += 4;\r\n}\r\n*(u32 *) &EthAddr[2] = LONGSWAP(Addr[0]);\r\n*(u16 *) &EthAddr[0] = SHORTSWAP(*(u16 *)&Addr[1]);\r\nif (is_valid_ether_addr(EthAddr)) {\r\nmemcpy(hw->perm_mac_addr, EthAddr, ETH_ALEN);\r\nreturn 0;\r\n}\r\nAddr[0] = ATL2_READ_REG(hw, REG_MAC_STA_ADDR);\r\nAddr[1] = ATL2_READ_REG(hw, REG_MAC_STA_ADDR + 4);\r\n*(u32 *) &EthAddr[2] = LONGSWAP(Addr[0]);\r\n*(u16 *) &EthAddr[0] = SHORTSWAP(*(u16 *) &Addr[1]);\r\nif (is_valid_ether_addr(EthAddr)) {\r\nmemcpy(hw->perm_mac_addr, EthAddr, ETH_ALEN);\r\nreturn 0;\r\n}\r\nreturn 1;\r\n}\r\nstatic s32 atl2_read_mac_addr(struct atl2_hw *hw)\r\n{\r\nif (get_permanent_address(hw)) {\r\nhw->perm_mac_addr[0] = 0x00;\r\nhw->perm_mac_addr[1] = 0x13;\r\nhw->perm_mac_addr[2] = 0x74;\r\nhw->perm_mac_addr[3] = 0x00;\r\nhw->perm_mac_addr[4] = 0x5c;\r\nhw->perm_mac_addr[5] = 0x38;\r\n}\r\nmemcpy(hw->mac_addr, hw->perm_mac_addr, ETH_ALEN);\r\nreturn 0;\r\n}\r\nstatic u32 atl2_hash_mc_addr(struct atl2_hw *hw, u8 *mc_addr)\r\n{\r\nu32 crc32, value;\r\nint i;\r\nvalue = 0;\r\ncrc32 = ether_crc_le(6, mc_addr);\r\nfor (i = 0; i < 32; i++)\r\nvalue |= (((crc32 >> i) & 1) << (31 - i));\r\nreturn value;\r\n}\r\nstatic void atl2_hash_set(struct atl2_hw *hw, u32 hash_value)\r\n{\r\nu32 hash_bit, hash_reg;\r\nu32 mta;\r\nhash_reg = (hash_value >> 31) & 0x1;\r\nhash_bit = (hash_value >> 26) & 0x1F;\r\nmta = ATL2_READ_REG_ARRAY(hw, REG_RX_HASH_TABLE, hash_reg);\r\nmta |= (1 << hash_bit);\r\nATL2_WRITE_REG_ARRAY(hw, REG_RX_HASH_TABLE, hash_reg, mta);\r\n}\r\nstatic void atl2_init_pcie(struct atl2_hw *hw)\r\n{\r\nu32 value;\r\nvalue = LTSSM_TEST_MODE_DEF;\r\nATL2_WRITE_REG(hw, REG_LTSSM_TEST_MODE, value);\r\nvalue = PCIE_DLL_TX_CTRL1_DEF;\r\nATL2_WRITE_REG(hw, REG_PCIE_DLL_TX_CTRL1, value);\r\n}\r\nstatic void atl2_init_flash_opcode(struct atl2_hw *hw)\r\n{\r\nif (hw->flash_vendor >= ARRAY_SIZE(flash_table))\r\nhw->flash_vendor = 0;\r\nATL2_WRITE_REGB(hw, REG_SPI_FLASH_OP_PROGRAM,\r\nflash_table[hw->flash_vendor].cmdPROGRAM);\r\nATL2_WRITE_REGB(hw, REG_SPI_FLASH_OP_SC_ERASE,\r\nflash_table[hw->flash_vendor].cmdSECTOR_ERASE);\r\nATL2_WRITE_REGB(hw, REG_SPI_FLASH_OP_CHIP_ERASE,\r\nflash_table[hw->flash_vendor].cmdCHIP_ERASE);\r\nATL2_WRITE_REGB(hw, REG_SPI_FLASH_OP_RDID,\r\nflash_table[hw->flash_vendor].cmdRDID);\r\nATL2_WRITE_REGB(hw, REG_SPI_FLASH_OP_WREN,\r\nflash_table[hw->flash_vendor].cmdWREN);\r\nATL2_WRITE_REGB(hw, REG_SPI_FLASH_OP_RDSR,\r\nflash_table[hw->flash_vendor].cmdRDSR);\r\nATL2_WRITE_REGB(hw, REG_SPI_FLASH_OP_WRSR,\r\nflash_table[hw->flash_vendor].cmdWRSR);\r\nATL2_WRITE_REGB(hw, REG_SPI_FLASH_OP_READ,\r\nflash_table[hw->flash_vendor].cmdREAD);\r\n}\r\nstatic s32 atl2_init_hw(struct atl2_hw *hw)\r\n{\r\nu32 ret_val = 0;\r\natl2_init_pcie(hw);\r\nATL2_WRITE_REG(hw, REG_RX_HASH_TABLE, 0);\r\nATL2_WRITE_REG_ARRAY(hw, REG_RX_HASH_TABLE, 1, 0);\r\natl2_init_flash_opcode(hw);\r\nret_val = atl2_phy_init(hw);\r\nreturn ret_val;\r\n}\r\nstatic s32 atl2_get_speed_and_duplex(struct atl2_hw *hw, u16 *speed,\r\nu16 *duplex)\r\n{\r\ns32 ret_val;\r\nu16 phy_data;\r\nret_val = atl2_read_phy_reg(hw, MII_ATLX_PSSR, &phy_data);\r\nif (ret_val)\r\nreturn ret_val;\r\nif (!(phy_data & MII_ATLX_PSSR_SPD_DPLX_RESOLVED))\r\nreturn ATLX_ERR_PHY_RES;\r\nswitch (phy_data & MII_ATLX_PSSR_SPEED) {\r\ncase MII_ATLX_PSSR_100MBS:\r\n*speed = SPEED_100;\r\nbreak;\r\ncase MII_ATLX_PSSR_10MBS:\r\n*speed = SPEED_10;\r\nbreak;\r\ndefault:\r\nreturn ATLX_ERR_PHY_SPEED;\r\n}\r\nif (phy_data & MII_ATLX_PSSR_DPLX)\r\n*duplex = FULL_DUPLEX;\r\nelse\r\n*duplex = HALF_DUPLEX;\r\nreturn 0;\r\n}\r\nstatic s32 atl2_read_phy_reg(struct atl2_hw *hw, u16 reg_addr, u16 *phy_data)\r\n{\r\nu32 val;\r\nint i;\r\nval = ((u32)(reg_addr & MDIO_REG_ADDR_MASK)) << MDIO_REG_ADDR_SHIFT |\r\nMDIO_START |\r\nMDIO_SUP_PREAMBLE |\r\nMDIO_RW |\r\nMDIO_CLK_25_4 << MDIO_CLK_SEL_SHIFT;\r\nATL2_WRITE_REG(hw, REG_MDIO_CTRL, val);\r\nwmb();\r\nfor (i = 0; i < MDIO_WAIT_TIMES; i++) {\r\nudelay(2);\r\nval = ATL2_READ_REG(hw, REG_MDIO_CTRL);\r\nif (!(val & (MDIO_START | MDIO_BUSY)))\r\nbreak;\r\nwmb();\r\n}\r\nif (!(val & (MDIO_START | MDIO_BUSY))) {\r\n*phy_data = (u16)val;\r\nreturn 0;\r\n}\r\nreturn ATLX_ERR_PHY;\r\n}\r\nstatic s32 atl2_write_phy_reg(struct atl2_hw *hw, u32 reg_addr, u16 phy_data)\r\n{\r\nint i;\r\nu32 val;\r\nval = ((u32)(phy_data & MDIO_DATA_MASK)) << MDIO_DATA_SHIFT |\r\n(reg_addr & MDIO_REG_ADDR_MASK) << MDIO_REG_ADDR_SHIFT |\r\nMDIO_SUP_PREAMBLE |\r\nMDIO_START |\r\nMDIO_CLK_25_4 << MDIO_CLK_SEL_SHIFT;\r\nATL2_WRITE_REG(hw, REG_MDIO_CTRL, val);\r\nwmb();\r\nfor (i = 0; i < MDIO_WAIT_TIMES; i++) {\r\nudelay(2);\r\nval = ATL2_READ_REG(hw, REG_MDIO_CTRL);\r\nif (!(val & (MDIO_START | MDIO_BUSY)))\r\nbreak;\r\nwmb();\r\n}\r\nif (!(val & (MDIO_START | MDIO_BUSY)))\r\nreturn 0;\r\nreturn ATLX_ERR_PHY;\r\n}\r\nstatic s32 atl2_phy_setup_autoneg_adv(struct atl2_hw *hw)\r\n{\r\ns32 ret_val;\r\ns16 mii_autoneg_adv_reg;\r\nmii_autoneg_adv_reg = MII_AR_DEFAULT_CAP_MASK;\r\nmii_autoneg_adv_reg &= ~MII_AR_SPEED_MASK;\r\nswitch (hw->MediaType) {\r\ncase MEDIA_TYPE_AUTO_SENSOR:\r\nmii_autoneg_adv_reg |=\r\n(MII_AR_10T_HD_CAPS |\r\nMII_AR_10T_FD_CAPS |\r\nMII_AR_100TX_HD_CAPS|\r\nMII_AR_100TX_FD_CAPS);\r\nhw->autoneg_advertised =\r\nADVERTISE_10_HALF |\r\nADVERTISE_10_FULL |\r\nADVERTISE_100_HALF|\r\nADVERTISE_100_FULL;\r\nbreak;\r\ncase MEDIA_TYPE_100M_FULL:\r\nmii_autoneg_adv_reg |= MII_AR_100TX_FD_CAPS;\r\nhw->autoneg_advertised = ADVERTISE_100_FULL;\r\nbreak;\r\ncase MEDIA_TYPE_100M_HALF:\r\nmii_autoneg_adv_reg |= MII_AR_100TX_HD_CAPS;\r\nhw->autoneg_advertised = ADVERTISE_100_HALF;\r\nbreak;\r\ncase MEDIA_TYPE_10M_FULL:\r\nmii_autoneg_adv_reg |= MII_AR_10T_FD_CAPS;\r\nhw->autoneg_advertised = ADVERTISE_10_FULL;\r\nbreak;\r\ndefault:\r\nmii_autoneg_adv_reg |= MII_AR_10T_HD_CAPS;\r\nhw->autoneg_advertised = ADVERTISE_10_HALF;\r\nbreak;\r\n}\r\nmii_autoneg_adv_reg |= (MII_AR_ASM_DIR | MII_AR_PAUSE);\r\nhw->mii_autoneg_adv_reg = mii_autoneg_adv_reg;\r\nret_val = atl2_write_phy_reg(hw, MII_ADVERTISE, mii_autoneg_adv_reg);\r\nif (ret_val)\r\nreturn ret_val;\r\nreturn 0;\r\n}\r\nstatic s32 atl2_phy_commit(struct atl2_hw *hw)\r\n{\r\ns32 ret_val;\r\nu16 phy_data;\r\nphy_data = MII_CR_RESET | MII_CR_AUTO_NEG_EN | MII_CR_RESTART_AUTO_NEG;\r\nret_val = atl2_write_phy_reg(hw, MII_BMCR, phy_data);\r\nif (ret_val) {\r\nu32 val;\r\nint i;\r\nfor (i = 0; i < 25; i++) {\r\nmsleep(1);\r\nval = ATL2_READ_REG(hw, REG_MDIO_CTRL);\r\nif (!(val & (MDIO_START | MDIO_BUSY)))\r\nbreak;\r\n}\r\nif (0 != (val & (MDIO_START | MDIO_BUSY))) {\r\nprintk(KERN_ERR "atl2: PCIe link down for at least 25ms !\n");\r\nreturn ret_val;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic s32 atl2_phy_init(struct atl2_hw *hw)\r\n{\r\ns32 ret_val;\r\nu16 phy_val;\r\nif (hw->phy_configured)\r\nreturn 0;\r\nATL2_WRITE_REGW(hw, REG_PHY_ENABLE, 1);\r\nATL2_WRITE_FLUSH(hw);\r\nmsleep(1);\r\natl2_write_phy_reg(hw, MII_DBG_ADDR, 0);\r\natl2_read_phy_reg(hw, MII_DBG_DATA, &phy_val);\r\nif (phy_val & 0x1000) {\r\nphy_val &= ~0x1000;\r\natl2_write_phy_reg(hw, MII_DBG_DATA, phy_val);\r\n}\r\nmsleep(1);\r\nret_val = atl2_write_phy_reg(hw, 18, 0xC00);\r\nif (ret_val)\r\nreturn ret_val;\r\nret_val = atl2_phy_setup_autoneg_adv(hw);\r\nif (ret_val)\r\nreturn ret_val;\r\nret_val = atl2_phy_commit(hw);\r\nif (ret_val)\r\nreturn ret_val;\r\nhw->phy_configured = true;\r\nreturn ret_val;\r\n}\r\nstatic void atl2_set_mac_addr(struct atl2_hw *hw)\r\n{\r\nu32 value;\r\nvalue = (((u32)hw->mac_addr[2]) << 24) |\r\n(((u32)hw->mac_addr[3]) << 16) |\r\n(((u32)hw->mac_addr[4]) << 8) |\r\n(((u32)hw->mac_addr[5]));\r\nATL2_WRITE_REG_ARRAY(hw, REG_MAC_STA_ADDR, 0, value);\r\nvalue = (((u32)hw->mac_addr[0]) << 8) |\r\n(((u32)hw->mac_addr[1]));\r\nATL2_WRITE_REG_ARRAY(hw, REG_MAC_STA_ADDR, 1, value);\r\n}\r\nstatic int atl2_check_eeprom_exist(struct atl2_hw *hw)\r\n{\r\nu32 value;\r\nvalue = ATL2_READ_REG(hw, REG_SPI_FLASH_CTRL);\r\nif (value & SPI_FLASH_CTRL_EN_VPD) {\r\nvalue &= ~SPI_FLASH_CTRL_EN_VPD;\r\nATL2_WRITE_REG(hw, REG_SPI_FLASH_CTRL, value);\r\n}\r\nvalue = ATL2_READ_REGW(hw, REG_PCIE_CAP_LIST);\r\nreturn ((value & 0xFF00) == 0x6C00) ? 0 : 1;\r\n}\r\nstatic bool atl2_write_eeprom(struct atl2_hw *hw, u32 offset, u32 value)\r\n{\r\nreturn true;\r\n}\r\nstatic bool atl2_read_eeprom(struct atl2_hw *hw, u32 Offset, u32 *pValue)\r\n{\r\nint i;\r\nu32 Control;\r\nif (Offset & 0x3)\r\nreturn false;\r\nATL2_WRITE_REG(hw, REG_VPD_DATA, 0);\r\nControl = (Offset & VPD_CAP_VPD_ADDR_MASK) << VPD_CAP_VPD_ADDR_SHIFT;\r\nATL2_WRITE_REG(hw, REG_VPD_CAP, Control);\r\nfor (i = 0; i < 10; i++) {\r\nmsleep(2);\r\nControl = ATL2_READ_REG(hw, REG_VPD_CAP);\r\nif (Control & VPD_CAP_VPD_FLAG)\r\nbreak;\r\n}\r\nif (Control & VPD_CAP_VPD_FLAG) {\r\n*pValue = ATL2_READ_REG(hw, REG_VPD_DATA);\r\nreturn true;\r\n}\r\nreturn false;\r\n}\r\nstatic void atl2_force_ps(struct atl2_hw *hw)\r\n{\r\nu16 phy_val;\r\natl2_write_phy_reg(hw, MII_DBG_ADDR, 0);\r\natl2_read_phy_reg(hw, MII_DBG_DATA, &phy_val);\r\natl2_write_phy_reg(hw, MII_DBG_DATA, phy_val | 0x1000);\r\natl2_write_phy_reg(hw, MII_DBG_ADDR, 2);\r\natl2_write_phy_reg(hw, MII_DBG_DATA, 0x3000);\r\natl2_write_phy_reg(hw, MII_DBG_ADDR, 3);\r\natl2_write_phy_reg(hw, MII_DBG_DATA, 0);\r\n}\r\nstatic int atl2_validate_option(int *value, struct atl2_option *opt)\r\n{\r\nint i;\r\nstruct atl2_opt_list *ent;\r\nif (*value == OPTION_UNSET) {\r\n*value = opt->def;\r\nreturn 0;\r\n}\r\nswitch (opt->type) {\r\ncase enable_option:\r\nswitch (*value) {\r\ncase OPTION_ENABLED:\r\nprintk(KERN_INFO "%s Enabled\n", opt->name);\r\nreturn 0;\r\ncase OPTION_DISABLED:\r\nprintk(KERN_INFO "%s Disabled\n", opt->name);\r\nreturn 0;\r\n}\r\nbreak;\r\ncase range_option:\r\nif (*value >= opt->arg.r.min && *value <= opt->arg.r.max) {\r\nprintk(KERN_INFO "%s set to %i\n", opt->name, *value);\r\nreturn 0;\r\n}\r\nbreak;\r\ncase list_option:\r\nfor (i = 0; i < opt->arg.l.nr; i++) {\r\nent = &opt->arg.l.p[i];\r\nif (*value == ent->i) {\r\nif (ent->str[0] != '\0')\r\nprintk(KERN_INFO "%s\n", ent->str);\r\nreturn 0;\r\n}\r\n}\r\nbreak;\r\ndefault:\r\nBUG();\r\n}\r\nprintk(KERN_INFO "Invalid %s specified (%i) %s\n",\r\nopt->name, *value, opt->err);\r\n*value = opt->def;\r\nreturn -1;\r\n}\r\nstatic void atl2_check_options(struct atl2_adapter *adapter)\r\n{\r\nint val;\r\nstruct atl2_option opt;\r\nint bd = adapter->bd_number;\r\nif (bd >= ATL2_MAX_NIC) {\r\nprintk(KERN_NOTICE "Warning: no configuration for board #%i\n",\r\nbd);\r\nprintk(KERN_NOTICE "Using defaults for all values\n");\r\n#ifndef module_param_array\r\nbd = ATL2_MAX_NIC;\r\n#endif\r\n}\r\nopt.type = range_option;\r\nopt.name = "Bytes of Transmit Memory";\r\nopt.err = "using default of " __MODULE_STRING(ATL2_DEFAULT_TX_MEMSIZE);\r\nopt.def = ATL2_DEFAULT_TX_MEMSIZE;\r\nopt.arg.r.min = ATL2_MIN_TX_MEMSIZE;\r\nopt.arg.r.max = ATL2_MAX_TX_MEMSIZE;\r\n#ifdef module_param_array\r\nif (num_TxMemSize > bd) {\r\n#endif\r\nval = TxMemSize[bd];\r\natl2_validate_option(&val, &opt);\r\nadapter->txd_ring_size = ((u32) val) * 1024;\r\n#ifdef module_param_array\r\n} else\r\nadapter->txd_ring_size = ((u32)opt.def) * 1024;\r\n#endif\r\nadapter->txs_ring_size = adapter->txd_ring_size / 128;\r\nif (adapter->txs_ring_size > 160)\r\nadapter->txs_ring_size = 160;\r\nopt.type = range_option;\r\nopt.name = "Number of receive memory block";\r\nopt.err = "using default of " __MODULE_STRING(ATL2_DEFAULT_RXD_COUNT);\r\nopt.def = ATL2_DEFAULT_RXD_COUNT;\r\nopt.arg.r.min = ATL2_MIN_RXD_COUNT;\r\nopt.arg.r.max = ATL2_MAX_RXD_COUNT;\r\n#ifdef module_param_array\r\nif (num_RxMemBlock > bd) {\r\n#endif\r\nval = RxMemBlock[bd];\r\natl2_validate_option(&val, &opt);\r\nadapter->rxd_ring_size = (u32)val;\r\n#ifdef module_param_array\r\n} else\r\nadapter->rxd_ring_size = (u32)opt.def;\r\n#endif\r\nadapter->hw.fc_rxd_hi = (adapter->rxd_ring_size / 8) * 7;\r\nadapter->hw.fc_rxd_lo = (ATL2_MIN_RXD_COUNT / 8) >\r\n(adapter->rxd_ring_size / 12) ? (ATL2_MIN_RXD_COUNT / 8) :\r\n(adapter->rxd_ring_size / 12);\r\nopt.type = range_option;\r\nopt.name = "Interrupt Moderate Timer";\r\nopt.err = "using default of " __MODULE_STRING(INT_MOD_DEFAULT_CNT);\r\nopt.def = INT_MOD_DEFAULT_CNT;\r\nopt.arg.r.min = INT_MOD_MIN_CNT;\r\nopt.arg.r.max = INT_MOD_MAX_CNT;\r\n#ifdef module_param_array\r\nif (num_IntModTimer > bd) {\r\n#endif\r\nval = IntModTimer[bd];\r\natl2_validate_option(&val, &opt);\r\nadapter->imt = (u16) val;\r\n#ifdef module_param_array\r\n} else\r\nadapter->imt = (u16)(opt.def);\r\n#endif\r\nopt.type = range_option;\r\nopt.name = "SPI Flash Vendor";\r\nopt.err = "using default of " __MODULE_STRING(FLASH_VENDOR_DEFAULT);\r\nopt.def = FLASH_VENDOR_DEFAULT;\r\nopt.arg.r.min = FLASH_VENDOR_MIN;\r\nopt.arg.r.max = FLASH_VENDOR_MAX;\r\n#ifdef module_param_array\r\nif (num_FlashVendor > bd) {\r\n#endif\r\nval = FlashVendor[bd];\r\natl2_validate_option(&val, &opt);\r\nadapter->hw.flash_vendor = (u8) val;\r\n#ifdef module_param_array\r\n} else\r\nadapter->hw.flash_vendor = (u8)(opt.def);\r\n#endif\r\nopt.type = range_option;\r\nopt.name = "Speed/Duplex Selection";\r\nopt.err = "using default of " __MODULE_STRING(MEDIA_TYPE_AUTO_SENSOR);\r\nopt.def = MEDIA_TYPE_AUTO_SENSOR;\r\nopt.arg.r.min = MEDIA_TYPE_AUTO_SENSOR;\r\nopt.arg.r.max = MEDIA_TYPE_10M_HALF;\r\n#ifdef module_param_array\r\nif (num_MediaType > bd) {\r\n#endif\r\nval = MediaType[bd];\r\natl2_validate_option(&val, &opt);\r\nadapter->hw.MediaType = (u16) val;\r\n#ifdef module_param_array\r\n} else\r\nadapter->hw.MediaType = (u16)(opt.def);\r\n#endif\r\n}
