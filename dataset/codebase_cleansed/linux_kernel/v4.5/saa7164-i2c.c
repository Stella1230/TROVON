static int i2c_xfer(struct i2c_adapter *i2c_adap, struct i2c_msg *msgs, int num)\r\n{\r\nstruct saa7164_i2c *bus = i2c_adap->algo_data;\r\nstruct saa7164_dev *dev = bus->dev;\r\nint i, retval = 0;\r\ndprintk(DBGLVL_I2C, "%s(num = %d)\n", __func__, num);\r\nfor (i = 0 ; i < num; i++) {\r\ndprintk(DBGLVL_I2C, "%s(num = %d) addr = 0x%02x len = 0x%x\n",\r\n__func__, num, msgs[i].addr, msgs[i].len);\r\nif (msgs[i].flags & I2C_M_RD) {\r\nretval = saa7164_api_i2c_read(bus,\r\nmsgs[i].addr,\r\n0 ,\r\nNULL , msgs[i].len, msgs[i].buf);\r\n} else if (i + 1 < num && (msgs[i + 1].flags & I2C_M_RD) &&\r\nmsgs[i].addr == msgs[i + 1].addr) {\r\nretval = saa7164_api_i2c_read(bus, msgs[i].addr,\r\nmsgs[i].len, msgs[i].buf,\r\nmsgs[i+1].len, msgs[i+1].buf\r\n);\r\ni++;\r\nif (retval < 0)\r\ngoto err;\r\n} else {\r\nretval = saa7164_api_i2c_write(bus, msgs[i].addr,\r\nmsgs[i].len, msgs[i].buf);\r\n}\r\nif (retval < 0)\r\ngoto err;\r\n}\r\nreturn num;\r\nerr:\r\nreturn retval;\r\n}\r\nstatic u32 saa7164_functionality(struct i2c_adapter *adap)\r\n{\r\nreturn I2C_FUNC_I2C;\r\n}\r\nint saa7164_i2c_register(struct saa7164_i2c *bus)\r\n{\r\nstruct saa7164_dev *dev = bus->dev;\r\ndprintk(DBGLVL_I2C, "%s(bus = %d)\n", __func__, bus->nr);\r\nbus->i2c_adap = saa7164_i2c_adap_template;\r\nbus->i2c_client = saa7164_i2c_client_template;\r\nbus->i2c_adap.dev.parent = &dev->pci->dev;\r\nstrlcpy(bus->i2c_adap.name, bus->dev->name,\r\nsizeof(bus->i2c_adap.name));\r\nbus->i2c_adap.algo_data = bus;\r\ni2c_set_adapdata(&bus->i2c_adap, bus);\r\ni2c_add_adapter(&bus->i2c_adap);\r\nbus->i2c_client.adapter = &bus->i2c_adap;\r\nif (0 != bus->i2c_rc)\r\nprintk(KERN_ERR "%s: i2c bus %d register FAILED\n",\r\ndev->name, bus->nr);\r\nreturn bus->i2c_rc;\r\n}\r\nint saa7164_i2c_unregister(struct saa7164_i2c *bus)\r\n{\r\ni2c_del_adapter(&bus->i2c_adap);\r\nreturn 0;\r\n}
