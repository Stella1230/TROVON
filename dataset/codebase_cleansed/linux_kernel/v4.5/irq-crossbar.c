static void crossbar_writel(int irq_no, int cb_no)\r\n{\r\nwritel(cb_no, cb->crossbar_base + cb->register_offsets[irq_no]);\r\n}\r\nstatic void crossbar_writew(int irq_no, int cb_no)\r\n{\r\nwritew(cb_no, cb->crossbar_base + cb->register_offsets[irq_no]);\r\n}\r\nstatic void crossbar_writeb(int irq_no, int cb_no)\r\n{\r\nwriteb(cb_no, cb->crossbar_base + cb->register_offsets[irq_no]);\r\n}\r\nstatic int allocate_gic_irq(struct irq_domain *domain, unsigned virq,\r\nirq_hw_number_t hwirq)\r\n{\r\nstruct irq_fwspec fwspec;\r\nint i;\r\nint err;\r\nif (!irq_domain_get_of_node(domain->parent))\r\nreturn -EINVAL;\r\nraw_spin_lock(&cb->lock);\r\nfor (i = cb->int_max - 1; i >= 0; i--) {\r\nif (cb->irq_map[i] == IRQ_FREE) {\r\ncb->irq_map[i] = hwirq;\r\nbreak;\r\n}\r\n}\r\nraw_spin_unlock(&cb->lock);\r\nif (i < 0)\r\nreturn -ENODEV;\r\nfwspec.fwnode = domain->parent->fwnode;\r\nfwspec.param_count = 3;\r\nfwspec.param[0] = 0;\r\nfwspec.param[1] = i;\r\nfwspec.param[2] = IRQ_TYPE_LEVEL_HIGH;\r\nerr = irq_domain_alloc_irqs_parent(domain, virq, 1, &fwspec);\r\nif (err)\r\ncb->irq_map[i] = IRQ_FREE;\r\nelse\r\ncb->write(i, hwirq);\r\nreturn err;\r\n}\r\nstatic int crossbar_domain_alloc(struct irq_domain *d, unsigned int virq,\r\nunsigned int nr_irqs, void *data)\r\n{\r\nstruct irq_fwspec *fwspec = data;\r\nirq_hw_number_t hwirq;\r\nint i;\r\nif (fwspec->param_count != 3)\r\nreturn -EINVAL;\r\nif (fwspec->param[0] != 0)\r\nreturn -EINVAL;\r\nhwirq = fwspec->param[1];\r\nif ((hwirq + nr_irqs) > cb->max_crossbar_sources)\r\nreturn -EINVAL;\r\nfor (i = 0; i < nr_irqs; i++) {\r\nint err = allocate_gic_irq(d, virq + i, hwirq + i);\r\nif (err)\r\nreturn err;\r\nirq_domain_set_hwirq_and_chip(d, virq + i, hwirq + i,\r\n&crossbar_chip, NULL);\r\n}\r\nreturn 0;\r\n}\r\nstatic void crossbar_domain_free(struct irq_domain *domain, unsigned int virq,\r\nunsigned int nr_irqs)\r\n{\r\nint i;\r\nraw_spin_lock(&cb->lock);\r\nfor (i = 0; i < nr_irqs; i++) {\r\nstruct irq_data *d = irq_domain_get_irq_data(domain, virq + i);\r\nirq_domain_reset_irq_data(d);\r\ncb->irq_map[d->hwirq] = IRQ_FREE;\r\ncb->write(d->hwirq, cb->safe_map);\r\n}\r\nraw_spin_unlock(&cb->lock);\r\n}\r\nstatic int crossbar_domain_translate(struct irq_domain *d,\r\nstruct irq_fwspec *fwspec,\r\nunsigned long *hwirq,\r\nunsigned int *type)\r\n{\r\nif (is_of_node(fwspec->fwnode)) {\r\nif (fwspec->param_count != 3)\r\nreturn -EINVAL;\r\nif (fwspec->param[0] != 0)\r\nreturn -EINVAL;\r\n*hwirq = fwspec->param[1];\r\n*type = fwspec->param[2];\r\nreturn 0;\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int __init crossbar_of_init(struct device_node *node)\r\n{\r\nint i, size, max = 0, reserved = 0, entry;\r\nconst __be32 *irqsr;\r\nint ret = -ENOMEM;\r\ncb = kzalloc(sizeof(*cb), GFP_KERNEL);\r\nif (!cb)\r\nreturn ret;\r\ncb->crossbar_base = of_iomap(node, 0);\r\nif (!cb->crossbar_base)\r\ngoto err_cb;\r\nof_property_read_u32(node, "ti,max-crossbar-sources",\r\n&cb->max_crossbar_sources);\r\nif (!cb->max_crossbar_sources) {\r\npr_err("missing 'ti,max-crossbar-sources' property\n");\r\nret = -EINVAL;\r\ngoto err_base;\r\n}\r\nof_property_read_u32(node, "ti,max-irqs", &max);\r\nif (!max) {\r\npr_err("missing 'ti,max-irqs' property\n");\r\nret = -EINVAL;\r\ngoto err_base;\r\n}\r\ncb->irq_map = kcalloc(max, sizeof(int), GFP_KERNEL);\r\nif (!cb->irq_map)\r\ngoto err_base;\r\ncb->int_max = max;\r\nfor (i = 0; i < max; i++)\r\ncb->irq_map[i] = IRQ_FREE;\r\nirqsr = of_get_property(node, "ti,irqs-reserved", &size);\r\nif (irqsr) {\r\nsize /= sizeof(__be32);\r\nfor (i = 0; i < size; i++) {\r\nof_property_read_u32_index(node,\r\n"ti,irqs-reserved",\r\ni, &entry);\r\nif (entry >= max) {\r\npr_err("Invalid reserved entry\n");\r\nret = -EINVAL;\r\ngoto err_irq_map;\r\n}\r\ncb->irq_map[entry] = IRQ_RESERVED;\r\n}\r\n}\r\nirqsr = of_get_property(node, "ti,irqs-skip", &size);\r\nif (irqsr) {\r\nsize /= sizeof(__be32);\r\nfor (i = 0; i < size; i++) {\r\nof_property_read_u32_index(node,\r\n"ti,irqs-skip",\r\ni, &entry);\r\nif (entry >= max) {\r\npr_err("Invalid skip entry\n");\r\nret = -EINVAL;\r\ngoto err_irq_map;\r\n}\r\ncb->irq_map[entry] = IRQ_SKIP;\r\n}\r\n}\r\ncb->register_offsets = kcalloc(max, sizeof(int), GFP_KERNEL);\r\nif (!cb->register_offsets)\r\ngoto err_irq_map;\r\nof_property_read_u32(node, "ti,reg-size", &size);\r\nswitch (size) {\r\ncase 1:\r\ncb->write = crossbar_writeb;\r\nbreak;\r\ncase 2:\r\ncb->write = crossbar_writew;\r\nbreak;\r\ncase 4:\r\ncb->write = crossbar_writel;\r\nbreak;\r\ndefault:\r\npr_err("Invalid reg-size property\n");\r\nret = -EINVAL;\r\ngoto err_reg_offset;\r\nbreak;\r\n}\r\nfor (i = 0; i < max; i++) {\r\nif (cb->irq_map[i] == IRQ_RESERVED)\r\ncontinue;\r\ncb->register_offsets[i] = reserved;\r\nreserved += size;\r\n}\r\nof_property_read_u32(node, "ti,irqs-safe-map", &cb->safe_map);\r\nfor (i = 0; i < max; i++) {\r\nif (cb->irq_map[i] == IRQ_RESERVED ||\r\ncb->irq_map[i] == IRQ_SKIP)\r\ncontinue;\r\ncb->write(i, cb->safe_map);\r\n}\r\nraw_spin_lock_init(&cb->lock);\r\nreturn 0;\r\nerr_reg_offset:\r\nkfree(cb->register_offsets);\r\nerr_irq_map:\r\nkfree(cb->irq_map);\r\nerr_base:\r\niounmap(cb->crossbar_base);\r\nerr_cb:\r\nkfree(cb);\r\ncb = NULL;\r\nreturn ret;\r\n}\r\nstatic int __init irqcrossbar_init(struct device_node *node,\r\nstruct device_node *parent)\r\n{\r\nstruct irq_domain *parent_domain, *domain;\r\nint err;\r\nif (!parent) {\r\npr_err("%s: no parent, giving up\n", node->full_name);\r\nreturn -ENODEV;\r\n}\r\nparent_domain = irq_find_host(parent);\r\nif (!parent_domain) {\r\npr_err("%s: unable to obtain parent domain\n", node->full_name);\r\nreturn -ENXIO;\r\n}\r\nerr = crossbar_of_init(node);\r\nif (err)\r\nreturn err;\r\ndomain = irq_domain_add_hierarchy(parent_domain, 0,\r\ncb->max_crossbar_sources,\r\nnode, &crossbar_domain_ops,\r\nNULL);\r\nif (!domain) {\r\npr_err("%s: failed to allocated domain\n", node->full_name);\r\nreturn -ENOMEM;\r\n}\r\nreturn 0;\r\n}
