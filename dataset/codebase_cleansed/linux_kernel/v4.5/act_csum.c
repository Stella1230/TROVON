static int tcf_csum_init(struct net *n, struct nlattr *nla, struct nlattr *est,\r\nstruct tc_action *a, int ovr, int bind)\r\n{\r\nstruct nlattr *tb[TCA_CSUM_MAX + 1];\r\nstruct tc_csum *parm;\r\nstruct tcf_csum *p;\r\nint ret = 0, err;\r\nif (nla == NULL)\r\nreturn -EINVAL;\r\nerr = nla_parse_nested(tb, TCA_CSUM_MAX, nla, csum_policy);\r\nif (err < 0)\r\nreturn err;\r\nif (tb[TCA_CSUM_PARMS] == NULL)\r\nreturn -EINVAL;\r\nparm = nla_data(tb[TCA_CSUM_PARMS]);\r\nif (!tcf_hash_check(parm->index, a, bind)) {\r\nret = tcf_hash_create(parm->index, est, a, sizeof(*p),\r\nbind, false);\r\nif (ret)\r\nreturn ret;\r\nret = ACT_P_CREATED;\r\n} else {\r\nif (bind)\r\nreturn 0;\r\ntcf_hash_release(a, bind);\r\nif (!ovr)\r\nreturn -EEXIST;\r\n}\r\np = to_tcf_csum(a);\r\nspin_lock_bh(&p->tcf_lock);\r\np->tcf_action = parm->action;\r\np->update_flags = parm->update_flags;\r\nspin_unlock_bh(&p->tcf_lock);\r\nif (ret == ACT_P_CREATED)\r\ntcf_hash_insert(a);\r\nreturn ret;\r\n}\r\nstatic void *tcf_csum_skb_nextlayer(struct sk_buff *skb,\r\nunsigned int ihl, unsigned int ipl,\r\nunsigned int jhl)\r\n{\r\nint ntkoff = skb_network_offset(skb);\r\nint hl = ihl + jhl;\r\nif (!pskb_may_pull(skb, ipl + ntkoff) || (ipl < hl) ||\r\n(skb_cloned(skb) &&\r\n!skb_clone_writable(skb, hl + ntkoff) &&\r\npskb_expand_head(skb, 0, 0, GFP_ATOMIC)))\r\nreturn NULL;\r\nelse\r\nreturn (void *)(skb_network_header(skb) + ihl);\r\n}\r\nstatic int tcf_csum_ipv4_icmp(struct sk_buff *skb,\r\nunsigned int ihl, unsigned int ipl)\r\n{\r\nstruct icmphdr *icmph;\r\nicmph = tcf_csum_skb_nextlayer(skb, ihl, ipl, sizeof(*icmph));\r\nif (icmph == NULL)\r\nreturn 0;\r\nicmph->checksum = 0;\r\nskb->csum = csum_partial(icmph, ipl - ihl, 0);\r\nicmph->checksum = csum_fold(skb->csum);\r\nskb->ip_summed = CHECKSUM_NONE;\r\nreturn 1;\r\n}\r\nstatic int tcf_csum_ipv4_igmp(struct sk_buff *skb,\r\nunsigned int ihl, unsigned int ipl)\r\n{\r\nstruct igmphdr *igmph;\r\nigmph = tcf_csum_skb_nextlayer(skb, ihl, ipl, sizeof(*igmph));\r\nif (igmph == NULL)\r\nreturn 0;\r\nigmph->csum = 0;\r\nskb->csum = csum_partial(igmph, ipl - ihl, 0);\r\nigmph->csum = csum_fold(skb->csum);\r\nskb->ip_summed = CHECKSUM_NONE;\r\nreturn 1;\r\n}\r\nstatic int tcf_csum_ipv6_icmp(struct sk_buff *skb,\r\nunsigned int ihl, unsigned int ipl)\r\n{\r\nstruct icmp6hdr *icmp6h;\r\nconst struct ipv6hdr *ip6h;\r\nicmp6h = tcf_csum_skb_nextlayer(skb, ihl, ipl, sizeof(*icmp6h));\r\nif (icmp6h == NULL)\r\nreturn 0;\r\nip6h = ipv6_hdr(skb);\r\nicmp6h->icmp6_cksum = 0;\r\nskb->csum = csum_partial(icmp6h, ipl - ihl, 0);\r\nicmp6h->icmp6_cksum = csum_ipv6_magic(&ip6h->saddr, &ip6h->daddr,\r\nipl - ihl, IPPROTO_ICMPV6,\r\nskb->csum);\r\nskb->ip_summed = CHECKSUM_NONE;\r\nreturn 1;\r\n}\r\nstatic int tcf_csum_ipv4_tcp(struct sk_buff *skb,\r\nunsigned int ihl, unsigned int ipl)\r\n{\r\nstruct tcphdr *tcph;\r\nconst struct iphdr *iph;\r\ntcph = tcf_csum_skb_nextlayer(skb, ihl, ipl, sizeof(*tcph));\r\nif (tcph == NULL)\r\nreturn 0;\r\niph = ip_hdr(skb);\r\ntcph->check = 0;\r\nskb->csum = csum_partial(tcph, ipl - ihl, 0);\r\ntcph->check = tcp_v4_check(ipl - ihl,\r\niph->saddr, iph->daddr, skb->csum);\r\nskb->ip_summed = CHECKSUM_NONE;\r\nreturn 1;\r\n}\r\nstatic int tcf_csum_ipv6_tcp(struct sk_buff *skb,\r\nunsigned int ihl, unsigned int ipl)\r\n{\r\nstruct tcphdr *tcph;\r\nconst struct ipv6hdr *ip6h;\r\ntcph = tcf_csum_skb_nextlayer(skb, ihl, ipl, sizeof(*tcph));\r\nif (tcph == NULL)\r\nreturn 0;\r\nip6h = ipv6_hdr(skb);\r\ntcph->check = 0;\r\nskb->csum = csum_partial(tcph, ipl - ihl, 0);\r\ntcph->check = csum_ipv6_magic(&ip6h->saddr, &ip6h->daddr,\r\nipl - ihl, IPPROTO_TCP,\r\nskb->csum);\r\nskb->ip_summed = CHECKSUM_NONE;\r\nreturn 1;\r\n}\r\nstatic int tcf_csum_ipv4_udp(struct sk_buff *skb,\r\nunsigned int ihl, unsigned int ipl, int udplite)\r\n{\r\nstruct udphdr *udph;\r\nconst struct iphdr *iph;\r\nu16 ul;\r\nudph = tcf_csum_skb_nextlayer(skb, ihl, ipl, sizeof(*udph));\r\nif (udph == NULL)\r\nreturn 0;\r\niph = ip_hdr(skb);\r\nul = ntohs(udph->len);\r\nif (udplite || udph->check) {\r\nudph->check = 0;\r\nif (udplite) {\r\nif (ul == 0)\r\nskb->csum = csum_partial(udph, ipl - ihl, 0);\r\nelse if ((ul >= sizeof(*udph)) && (ul <= ipl - ihl))\r\nskb->csum = csum_partial(udph, ul, 0);\r\nelse\r\ngoto ignore_obscure_skb;\r\n} else {\r\nif (ul != ipl - ihl)\r\ngoto ignore_obscure_skb;\r\nskb->csum = csum_partial(udph, ul, 0);\r\n}\r\nudph->check = csum_tcpudp_magic(iph->saddr, iph->daddr,\r\nul, iph->protocol,\r\nskb->csum);\r\nif (!udph->check)\r\nudph->check = CSUM_MANGLED_0;\r\n}\r\nskb->ip_summed = CHECKSUM_NONE;\r\nignore_obscure_skb:\r\nreturn 1;\r\n}\r\nstatic int tcf_csum_ipv6_udp(struct sk_buff *skb,\r\nunsigned int ihl, unsigned int ipl, int udplite)\r\n{\r\nstruct udphdr *udph;\r\nconst struct ipv6hdr *ip6h;\r\nu16 ul;\r\nudph = tcf_csum_skb_nextlayer(skb, ihl, ipl, sizeof(*udph));\r\nif (udph == NULL)\r\nreturn 0;\r\nip6h = ipv6_hdr(skb);\r\nul = ntohs(udph->len);\r\nudph->check = 0;\r\nif (udplite) {\r\nif (ul == 0)\r\nskb->csum = csum_partial(udph, ipl - ihl, 0);\r\nelse if ((ul >= sizeof(*udph)) && (ul <= ipl - ihl))\r\nskb->csum = csum_partial(udph, ul, 0);\r\nelse\r\ngoto ignore_obscure_skb;\r\n} else {\r\nif (ul != ipl - ihl)\r\ngoto ignore_obscure_skb;\r\nskb->csum = csum_partial(udph, ul, 0);\r\n}\r\nudph->check = csum_ipv6_magic(&ip6h->saddr, &ip6h->daddr, ul,\r\nudplite ? IPPROTO_UDPLITE : IPPROTO_UDP,\r\nskb->csum);\r\nif (!udph->check)\r\nudph->check = CSUM_MANGLED_0;\r\nskb->ip_summed = CHECKSUM_NONE;\r\nignore_obscure_skb:\r\nreturn 1;\r\n}\r\nstatic int tcf_csum_ipv4(struct sk_buff *skb, u32 update_flags)\r\n{\r\nconst struct iphdr *iph;\r\nint ntkoff;\r\nntkoff = skb_network_offset(skb);\r\nif (!pskb_may_pull(skb, sizeof(*iph) + ntkoff))\r\ngoto fail;\r\niph = ip_hdr(skb);\r\nswitch (iph->frag_off & htons(IP_OFFSET) ? 0 : iph->protocol) {\r\ncase IPPROTO_ICMP:\r\nif (update_flags & TCA_CSUM_UPDATE_FLAG_ICMP)\r\nif (!tcf_csum_ipv4_icmp(skb, iph->ihl * 4,\r\nntohs(iph->tot_len)))\r\ngoto fail;\r\nbreak;\r\ncase IPPROTO_IGMP:\r\nif (update_flags & TCA_CSUM_UPDATE_FLAG_IGMP)\r\nif (!tcf_csum_ipv4_igmp(skb, iph->ihl * 4,\r\nntohs(iph->tot_len)))\r\ngoto fail;\r\nbreak;\r\ncase IPPROTO_TCP:\r\nif (update_flags & TCA_CSUM_UPDATE_FLAG_TCP)\r\nif (!tcf_csum_ipv4_tcp(skb, iph->ihl * 4,\r\nntohs(iph->tot_len)))\r\ngoto fail;\r\nbreak;\r\ncase IPPROTO_UDP:\r\nif (update_flags & TCA_CSUM_UPDATE_FLAG_UDP)\r\nif (!tcf_csum_ipv4_udp(skb, iph->ihl * 4,\r\nntohs(iph->tot_len), 0))\r\ngoto fail;\r\nbreak;\r\ncase IPPROTO_UDPLITE:\r\nif (update_flags & TCA_CSUM_UPDATE_FLAG_UDPLITE)\r\nif (!tcf_csum_ipv4_udp(skb, iph->ihl * 4,\r\nntohs(iph->tot_len), 1))\r\ngoto fail;\r\nbreak;\r\n}\r\nif (update_flags & TCA_CSUM_UPDATE_FLAG_IPV4HDR) {\r\nif (skb_cloned(skb) &&\r\n!skb_clone_writable(skb, sizeof(*iph) + ntkoff) &&\r\npskb_expand_head(skb, 0, 0, GFP_ATOMIC))\r\ngoto fail;\r\nip_send_check(ip_hdr(skb));\r\n}\r\nreturn 1;\r\nfail:\r\nreturn 0;\r\n}\r\nstatic int tcf_csum_ipv6_hopopts(struct ipv6_opt_hdr *ip6xh,\r\nunsigned int ixhl, unsigned int *pl)\r\n{\r\nint off, len, optlen;\r\nunsigned char *xh = (void *)ip6xh;\r\noff = sizeof(*ip6xh);\r\nlen = ixhl - off;\r\nwhile (len > 1) {\r\nswitch (xh[off]) {\r\ncase IPV6_TLV_PAD1:\r\noptlen = 1;\r\nbreak;\r\ncase IPV6_TLV_JUMBO:\r\noptlen = xh[off + 1] + 2;\r\nif (optlen != 6 || len < 6 || (off & 3) != 2)\r\nreturn 0;\r\n*pl = ntohl(*(__be32 *)(xh + off + 2));\r\ngoto done;\r\ndefault:\r\noptlen = xh[off + 1] + 2;\r\nif (optlen > len)\r\ngoto done;\r\nbreak;\r\n}\r\noff += optlen;\r\nlen -= optlen;\r\n}\r\ndone:\r\nreturn 1;\r\n}\r\nstatic int tcf_csum_ipv6(struct sk_buff *skb, u32 update_flags)\r\n{\r\nstruct ipv6hdr *ip6h;\r\nstruct ipv6_opt_hdr *ip6xh;\r\nunsigned int hl, ixhl;\r\nunsigned int pl;\r\nint ntkoff;\r\nu8 nexthdr;\r\nntkoff = skb_network_offset(skb);\r\nhl = sizeof(*ip6h);\r\nif (!pskb_may_pull(skb, hl + ntkoff))\r\ngoto fail;\r\nip6h = ipv6_hdr(skb);\r\npl = ntohs(ip6h->payload_len);\r\nnexthdr = ip6h->nexthdr;\r\ndo {\r\nswitch (nexthdr) {\r\ncase NEXTHDR_FRAGMENT:\r\ngoto ignore_skb;\r\ncase NEXTHDR_ROUTING:\r\ncase NEXTHDR_HOP:\r\ncase NEXTHDR_DEST:\r\nif (!pskb_may_pull(skb, hl + sizeof(*ip6xh) + ntkoff))\r\ngoto fail;\r\nip6xh = (void *)(skb_network_header(skb) + hl);\r\nixhl = ipv6_optlen(ip6xh);\r\nif (!pskb_may_pull(skb, hl + ixhl + ntkoff))\r\ngoto fail;\r\nip6xh = (void *)(skb_network_header(skb) + hl);\r\nif ((nexthdr == NEXTHDR_HOP) &&\r\n!(tcf_csum_ipv6_hopopts(ip6xh, ixhl, &pl)))\r\ngoto fail;\r\nnexthdr = ip6xh->nexthdr;\r\nhl += ixhl;\r\nbreak;\r\ncase IPPROTO_ICMPV6:\r\nif (update_flags & TCA_CSUM_UPDATE_FLAG_ICMP)\r\nif (!tcf_csum_ipv6_icmp(skb,\r\nhl, pl + sizeof(*ip6h)))\r\ngoto fail;\r\ngoto done;\r\ncase IPPROTO_TCP:\r\nif (update_flags & TCA_CSUM_UPDATE_FLAG_TCP)\r\nif (!tcf_csum_ipv6_tcp(skb,\r\nhl, pl + sizeof(*ip6h)))\r\ngoto fail;\r\ngoto done;\r\ncase IPPROTO_UDP:\r\nif (update_flags & TCA_CSUM_UPDATE_FLAG_UDP)\r\nif (!tcf_csum_ipv6_udp(skb, hl,\r\npl + sizeof(*ip6h), 0))\r\ngoto fail;\r\ngoto done;\r\ncase IPPROTO_UDPLITE:\r\nif (update_flags & TCA_CSUM_UPDATE_FLAG_UDPLITE)\r\nif (!tcf_csum_ipv6_udp(skb, hl,\r\npl + sizeof(*ip6h), 1))\r\ngoto fail;\r\ngoto done;\r\ndefault:\r\ngoto ignore_skb;\r\n}\r\n} while (pskb_may_pull(skb, hl + 1 + ntkoff));\r\ndone:\r\nignore_skb:\r\nreturn 1;\r\nfail:\r\nreturn 0;\r\n}\r\nstatic int tcf_csum(struct sk_buff *skb,\r\nconst struct tc_action *a, struct tcf_result *res)\r\n{\r\nstruct tcf_csum *p = a->priv;\r\nint action;\r\nu32 update_flags;\r\nspin_lock(&p->tcf_lock);\r\np->tcf_tm.lastuse = jiffies;\r\nbstats_update(&p->tcf_bstats, skb);\r\naction = p->tcf_action;\r\nupdate_flags = p->update_flags;\r\nspin_unlock(&p->tcf_lock);\r\nif (unlikely(action == TC_ACT_SHOT))\r\ngoto drop;\r\nswitch (tc_skb_protocol(skb)) {\r\ncase cpu_to_be16(ETH_P_IP):\r\nif (!tcf_csum_ipv4(skb, update_flags))\r\ngoto drop;\r\nbreak;\r\ncase cpu_to_be16(ETH_P_IPV6):\r\nif (!tcf_csum_ipv6(skb, update_flags))\r\ngoto drop;\r\nbreak;\r\n}\r\nreturn action;\r\ndrop:\r\nspin_lock(&p->tcf_lock);\r\np->tcf_qstats.drops++;\r\nspin_unlock(&p->tcf_lock);\r\nreturn TC_ACT_SHOT;\r\n}\r\nstatic int tcf_csum_dump(struct sk_buff *skb,\r\nstruct tc_action *a, int bind, int ref)\r\n{\r\nunsigned char *b = skb_tail_pointer(skb);\r\nstruct tcf_csum *p = a->priv;\r\nstruct tc_csum opt = {\r\n.update_flags = p->update_flags,\r\n.index = p->tcf_index,\r\n.action = p->tcf_action,\r\n.refcnt = p->tcf_refcnt - ref,\r\n.bindcnt = p->tcf_bindcnt - bind,\r\n};\r\nstruct tcf_t t;\r\nif (nla_put(skb, TCA_CSUM_PARMS, sizeof(opt), &opt))\r\ngoto nla_put_failure;\r\nt.install = jiffies_to_clock_t(jiffies - p->tcf_tm.install);\r\nt.lastuse = jiffies_to_clock_t(jiffies - p->tcf_tm.lastuse);\r\nt.expires = jiffies_to_clock_t(p->tcf_tm.expires);\r\nif (nla_put(skb, TCA_CSUM_TM, sizeof(t), &t))\r\ngoto nla_put_failure;\r\nreturn skb->len;\r\nnla_put_failure:\r\nnlmsg_trim(skb, b);\r\nreturn -1;\r\n}\r\nstatic int __init csum_init_module(void)\r\n{\r\nreturn tcf_register_action(&act_csum_ops, CSUM_TAB_MASK);\r\n}\r\nstatic void __exit csum_cleanup_module(void)\r\n{\r\ntcf_unregister_action(&act_csum_ops);\r\n}
