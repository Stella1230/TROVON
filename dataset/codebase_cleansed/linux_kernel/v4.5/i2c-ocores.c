static void oc_setreg_8(struct ocores_i2c *i2c, int reg, u8 value)\r\n{\r\niowrite8(value, i2c->base + (reg << i2c->reg_shift));\r\n}\r\nstatic void oc_setreg_16(struct ocores_i2c *i2c, int reg, u8 value)\r\n{\r\niowrite16(value, i2c->base + (reg << i2c->reg_shift));\r\n}\r\nstatic void oc_setreg_32(struct ocores_i2c *i2c, int reg, u8 value)\r\n{\r\niowrite32(value, i2c->base + (reg << i2c->reg_shift));\r\n}\r\nstatic void oc_setreg_16be(struct ocores_i2c *i2c, int reg, u8 value)\r\n{\r\niowrite16be(value, i2c->base + (reg << i2c->reg_shift));\r\n}\r\nstatic void oc_setreg_32be(struct ocores_i2c *i2c, int reg, u8 value)\r\n{\r\niowrite32be(value, i2c->base + (reg << i2c->reg_shift));\r\n}\r\nstatic inline u8 oc_getreg_8(struct ocores_i2c *i2c, int reg)\r\n{\r\nreturn ioread8(i2c->base + (reg << i2c->reg_shift));\r\n}\r\nstatic inline u8 oc_getreg_16(struct ocores_i2c *i2c, int reg)\r\n{\r\nreturn ioread16(i2c->base + (reg << i2c->reg_shift));\r\n}\r\nstatic inline u8 oc_getreg_32(struct ocores_i2c *i2c, int reg)\r\n{\r\nreturn ioread32(i2c->base + (reg << i2c->reg_shift));\r\n}\r\nstatic inline u8 oc_getreg_16be(struct ocores_i2c *i2c, int reg)\r\n{\r\nreturn ioread16be(i2c->base + (reg << i2c->reg_shift));\r\n}\r\nstatic inline u8 oc_getreg_32be(struct ocores_i2c *i2c, int reg)\r\n{\r\nreturn ioread32be(i2c->base + (reg << i2c->reg_shift));\r\n}\r\nstatic inline void oc_setreg(struct ocores_i2c *i2c, int reg, u8 value)\r\n{\r\ni2c->setreg(i2c, reg, value);\r\n}\r\nstatic inline u8 oc_getreg(struct ocores_i2c *i2c, int reg)\r\n{\r\nreturn i2c->getreg(i2c, reg);\r\n}\r\nstatic void ocores_process(struct ocores_i2c *i2c)\r\n{\r\nstruct i2c_msg *msg = i2c->msg;\r\nu8 stat = oc_getreg(i2c, OCI2C_STATUS);\r\nif ((i2c->state == STATE_DONE) || (i2c->state == STATE_ERROR)) {\r\noc_setreg(i2c, OCI2C_CMD, OCI2C_CMD_IACK);\r\nwake_up(&i2c->wait);\r\nreturn;\r\n}\r\nif (stat & OCI2C_STAT_ARBLOST) {\r\ni2c->state = STATE_ERROR;\r\noc_setreg(i2c, OCI2C_CMD, OCI2C_CMD_STOP);\r\nreturn;\r\n}\r\nif ((i2c->state == STATE_START) || (i2c->state == STATE_WRITE)) {\r\ni2c->state =\r\n(msg->flags & I2C_M_RD) ? STATE_READ : STATE_WRITE;\r\nif (stat & OCI2C_STAT_NACK) {\r\ni2c->state = STATE_ERROR;\r\noc_setreg(i2c, OCI2C_CMD, OCI2C_CMD_STOP);\r\nreturn;\r\n}\r\n} else\r\nmsg->buf[i2c->pos++] = oc_getreg(i2c, OCI2C_DATA);\r\nif (i2c->pos == msg->len) {\r\ni2c->nmsgs--;\r\ni2c->msg++;\r\ni2c->pos = 0;\r\nmsg = i2c->msg;\r\nif (i2c->nmsgs) {\r\nif (!(msg->flags & I2C_M_NOSTART)) {\r\nu8 addr = (msg->addr << 1);\r\nif (msg->flags & I2C_M_RD)\r\naddr |= 1;\r\ni2c->state = STATE_START;\r\noc_setreg(i2c, OCI2C_DATA, addr);\r\noc_setreg(i2c, OCI2C_CMD, OCI2C_CMD_START);\r\nreturn;\r\n} else\r\ni2c->state = (msg->flags & I2C_M_RD)\r\n? STATE_READ : STATE_WRITE;\r\n} else {\r\ni2c->state = STATE_DONE;\r\noc_setreg(i2c, OCI2C_CMD, OCI2C_CMD_STOP);\r\nreturn;\r\n}\r\n}\r\nif (i2c->state == STATE_READ) {\r\noc_setreg(i2c, OCI2C_CMD, i2c->pos == (msg->len-1) ?\r\nOCI2C_CMD_READ_NACK : OCI2C_CMD_READ_ACK);\r\n} else {\r\noc_setreg(i2c, OCI2C_DATA, msg->buf[i2c->pos++]);\r\noc_setreg(i2c, OCI2C_CMD, OCI2C_CMD_WRITE);\r\n}\r\n}\r\nstatic irqreturn_t ocores_isr(int irq, void *dev_id)\r\n{\r\nstruct ocores_i2c *i2c = dev_id;\r\nocores_process(i2c);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int ocores_xfer(struct i2c_adapter *adap, struct i2c_msg *msgs, int num)\r\n{\r\nstruct ocores_i2c *i2c = i2c_get_adapdata(adap);\r\ni2c->msg = msgs;\r\ni2c->pos = 0;\r\ni2c->nmsgs = num;\r\ni2c->state = STATE_START;\r\noc_setreg(i2c, OCI2C_DATA,\r\n(i2c->msg->addr << 1) |\r\n((i2c->msg->flags & I2C_M_RD) ? 1:0));\r\noc_setreg(i2c, OCI2C_CMD, OCI2C_CMD_START);\r\nif (wait_event_timeout(i2c->wait, (i2c->state == STATE_ERROR) ||\r\n(i2c->state == STATE_DONE), HZ))\r\nreturn (i2c->state == STATE_DONE) ? num : -EIO;\r\nelse\r\nreturn -ETIMEDOUT;\r\n}\r\nstatic int ocores_init(struct device *dev, struct ocores_i2c *i2c)\r\n{\r\nint prescale;\r\nint diff;\r\nu8 ctrl = oc_getreg(i2c, OCI2C_CONTROL);\r\noc_setreg(i2c, OCI2C_CONTROL, ctrl & ~(OCI2C_CTRL_EN|OCI2C_CTRL_IEN));\r\nprescale = (i2c->ip_clock_khz / (5 * i2c->bus_clock_khz)) - 1;\r\nprescale = clamp(prescale, 0, 0xffff);\r\ndiff = i2c->ip_clock_khz / (5 * (prescale + 1)) - i2c->bus_clock_khz;\r\nif (abs(diff) > i2c->bus_clock_khz / 10) {\r\ndev_err(dev,\r\n"Unsupported clock settings: core: %d KHz, bus: %d KHz\n",\r\ni2c->ip_clock_khz, i2c->bus_clock_khz);\r\nreturn -EINVAL;\r\n}\r\noc_setreg(i2c, OCI2C_PRELOW, prescale & 0xff);\r\noc_setreg(i2c, OCI2C_PREHIGH, prescale >> 8);\r\noc_setreg(i2c, OCI2C_CMD, OCI2C_CMD_IACK);\r\noc_setreg(i2c, OCI2C_CONTROL, ctrl | OCI2C_CTRL_IEN | OCI2C_CTRL_EN);\r\nreturn 0;\r\n}\r\nstatic u32 ocores_func(struct i2c_adapter *adap)\r\n{\r\nreturn I2C_FUNC_I2C | I2C_FUNC_SMBUS_EMUL;\r\n}\r\nstatic u8 oc_getreg_grlib(struct ocores_i2c *i2c, int reg)\r\n{\r\nu32 rd;\r\nint rreg = reg;\r\nif (reg != OCI2C_PRELOW)\r\nrreg--;\r\nrd = ioread32be(i2c->base + (rreg << i2c->reg_shift));\r\nif (reg == OCI2C_PREHIGH)\r\nreturn (u8)(rd >> 8);\r\nelse\r\nreturn (u8)rd;\r\n}\r\nstatic void oc_setreg_grlib(struct ocores_i2c *i2c, int reg, u8 value)\r\n{\r\nu32 curr, wr;\r\nint rreg = reg;\r\nif (reg != OCI2C_PRELOW)\r\nrreg--;\r\nif (reg == OCI2C_PRELOW || reg == OCI2C_PREHIGH) {\r\ncurr = ioread32be(i2c->base + (rreg << i2c->reg_shift));\r\nif (reg == OCI2C_PRELOW)\r\nwr = (curr & 0xff00) | value;\r\nelse\r\nwr = (((u32)value) << 8) | (curr & 0xff);\r\n} else {\r\nwr = value;\r\n}\r\niowrite32be(wr, i2c->base + (rreg << i2c->reg_shift));\r\n}\r\nstatic int ocores_i2c_of_probe(struct platform_device *pdev,\r\nstruct ocores_i2c *i2c)\r\n{\r\nstruct device_node *np = pdev->dev.of_node;\r\nconst struct of_device_id *match;\r\nu32 val;\r\nu32 clock_frequency;\r\nbool clock_frequency_present;\r\nif (of_property_read_u32(np, "reg-shift", &i2c->reg_shift)) {\r\nif (!of_property_read_u32(np, "regstep", &val)) {\r\nif (!is_power_of_2(val)) {\r\ndev_err(&pdev->dev, "invalid regstep %d\n",\r\nval);\r\nreturn -EINVAL;\r\n}\r\ni2c->reg_shift = ilog2(val);\r\ndev_warn(&pdev->dev,\r\n"regstep property deprecated, use reg-shift\n");\r\n}\r\n}\r\nclock_frequency_present = !of_property_read_u32(np, "clock-frequency",\r\n&clock_frequency);\r\ni2c->bus_clock_khz = 100;\r\ni2c->clk = devm_clk_get(&pdev->dev, NULL);\r\nif (!IS_ERR(i2c->clk)) {\r\nint ret = clk_prepare_enable(i2c->clk);\r\nif (ret) {\r\ndev_err(&pdev->dev,\r\n"clk_prepare_enable failed: %d\n", ret);\r\nreturn ret;\r\n}\r\ni2c->ip_clock_khz = clk_get_rate(i2c->clk) / 1000;\r\nif (clock_frequency_present)\r\ni2c->bus_clock_khz = clock_frequency / 1000;\r\n}\r\nif (i2c->ip_clock_khz == 0) {\r\nif (of_property_read_u32(np, "opencores,ip-clock-frequency",\r\n&val)) {\r\nif (!clock_frequency_present) {\r\ndev_err(&pdev->dev,\r\n"Missing required parameter 'opencores,ip-clock-frequency'\n");\r\nreturn -ENODEV;\r\n}\r\ni2c->ip_clock_khz = clock_frequency / 1000;\r\ndev_warn(&pdev->dev,\r\n"Deprecated usage of the 'clock-frequency' property, please update to 'opencores,ip-clock-frequency'\n");\r\n} else {\r\ni2c->ip_clock_khz = val / 1000;\r\nif (clock_frequency_present)\r\ni2c->bus_clock_khz = clock_frequency / 1000;\r\n}\r\n}\r\nof_property_read_u32(pdev->dev.of_node, "reg-io-width",\r\n&i2c->reg_io_width);\r\nmatch = of_match_node(ocores_i2c_match, pdev->dev.of_node);\r\nif (match && (long)match->data == TYPE_GRLIB) {\r\ndev_dbg(&pdev->dev, "GRLIB variant of i2c-ocores\n");\r\ni2c->setreg = oc_setreg_grlib;\r\ni2c->getreg = oc_getreg_grlib;\r\n}\r\nreturn 0;\r\n}\r\nstatic int ocores_i2c_probe(struct platform_device *pdev)\r\n{\r\nstruct ocores_i2c *i2c;\r\nstruct ocores_i2c_platform_data *pdata;\r\nstruct resource *res;\r\nint irq;\r\nint ret;\r\nint i;\r\nirq = platform_get_irq(pdev, 0);\r\nif (irq < 0)\r\nreturn irq;\r\ni2c = devm_kzalloc(&pdev->dev, sizeof(*i2c), GFP_KERNEL);\r\nif (!i2c)\r\nreturn -ENOMEM;\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\ni2c->base = devm_ioremap_resource(&pdev->dev, res);\r\nif (IS_ERR(i2c->base))\r\nreturn PTR_ERR(i2c->base);\r\npdata = dev_get_platdata(&pdev->dev);\r\nif (pdata) {\r\ni2c->reg_shift = pdata->reg_shift;\r\ni2c->reg_io_width = pdata->reg_io_width;\r\ni2c->ip_clock_khz = pdata->clock_khz;\r\ni2c->bus_clock_khz = 100;\r\n} else {\r\nret = ocores_i2c_of_probe(pdev, i2c);\r\nif (ret)\r\nreturn ret;\r\n}\r\nif (i2c->reg_io_width == 0)\r\ni2c->reg_io_width = 1;\r\nif (!i2c->setreg || !i2c->getreg) {\r\nbool be = pdata ? pdata->big_endian :\r\nof_device_is_big_endian(pdev->dev.of_node);\r\nswitch (i2c->reg_io_width) {\r\ncase 1:\r\ni2c->setreg = oc_setreg_8;\r\ni2c->getreg = oc_getreg_8;\r\nbreak;\r\ncase 2:\r\ni2c->setreg = be ? oc_setreg_16be : oc_setreg_16;\r\ni2c->getreg = be ? oc_getreg_16be : oc_getreg_16;\r\nbreak;\r\ncase 4:\r\ni2c->setreg = be ? oc_setreg_32be : oc_setreg_32;\r\ni2c->getreg = be ? oc_getreg_32be : oc_getreg_32;\r\nbreak;\r\ndefault:\r\ndev_err(&pdev->dev, "Unsupported I/O width (%d)\n",\r\ni2c->reg_io_width);\r\nreturn -EINVAL;\r\n}\r\n}\r\nret = ocores_init(&pdev->dev, i2c);\r\nif (ret)\r\nreturn ret;\r\ninit_waitqueue_head(&i2c->wait);\r\nret = devm_request_irq(&pdev->dev, irq, ocores_isr, 0,\r\npdev->name, i2c);\r\nif (ret) {\r\ndev_err(&pdev->dev, "Cannot claim IRQ\n");\r\nreturn ret;\r\n}\r\nplatform_set_drvdata(pdev, i2c);\r\ni2c->adap = ocores_adapter;\r\ni2c_set_adapdata(&i2c->adap, i2c);\r\ni2c->adap.dev.parent = &pdev->dev;\r\ni2c->adap.dev.of_node = pdev->dev.of_node;\r\nret = i2c_add_adapter(&i2c->adap);\r\nif (ret) {\r\ndev_err(&pdev->dev, "Failed to add adapter\n");\r\nreturn ret;\r\n}\r\nif (pdata) {\r\nfor (i = 0; i < pdata->num_devices; i++)\r\ni2c_new_device(&i2c->adap, pdata->devices + i);\r\n}\r\nreturn 0;\r\n}\r\nstatic int ocores_i2c_remove(struct platform_device *pdev)\r\n{\r\nstruct ocores_i2c *i2c = platform_get_drvdata(pdev);\r\noc_setreg(i2c, OCI2C_CONTROL, oc_getreg(i2c, OCI2C_CONTROL)\r\n& ~(OCI2C_CTRL_EN|OCI2C_CTRL_IEN));\r\ni2c_del_adapter(&i2c->adap);\r\nif (!IS_ERR(i2c->clk))\r\nclk_disable_unprepare(i2c->clk);\r\nreturn 0;\r\n}\r\nstatic int ocores_i2c_suspend(struct device *dev)\r\n{\r\nstruct ocores_i2c *i2c = dev_get_drvdata(dev);\r\nu8 ctrl = oc_getreg(i2c, OCI2C_CONTROL);\r\noc_setreg(i2c, OCI2C_CONTROL, ctrl & ~(OCI2C_CTRL_EN|OCI2C_CTRL_IEN));\r\nif (!IS_ERR(i2c->clk))\r\nclk_disable_unprepare(i2c->clk);\r\nreturn 0;\r\n}\r\nstatic int ocores_i2c_resume(struct device *dev)\r\n{\r\nstruct ocores_i2c *i2c = dev_get_drvdata(dev);\r\nif (!IS_ERR(i2c->clk)) {\r\nunsigned long rate;\r\nint ret = clk_prepare_enable(i2c->clk);\r\nif (ret) {\r\ndev_err(dev,\r\n"clk_prepare_enable failed: %d\n", ret);\r\nreturn ret;\r\n}\r\nrate = clk_get_rate(i2c->clk) / 1000;\r\nif (rate)\r\ni2c->ip_clock_khz = rate;\r\n}\r\nreturn ocores_init(dev, i2c);\r\n}
