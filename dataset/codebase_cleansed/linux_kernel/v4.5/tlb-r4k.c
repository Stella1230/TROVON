static inline void flush_itlb(void)\r\n{\r\nswitch (current_cpu_type()) {\r\ncase CPU_LOONGSON2:\r\ncase CPU_LOONGSON3:\r\nwrite_c0_diag(4);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nstatic inline void flush_itlb_vm(struct vm_area_struct *vma)\r\n{\r\nif (vma->vm_flags & VM_EXEC)\r\nflush_itlb();\r\n}\r\nvoid local_flush_tlb_all(void)\r\n{\r\nunsigned long flags;\r\nunsigned long old_ctx;\r\nint entry, ftlbhighset;\r\nlocal_irq_save(flags);\r\nold_ctx = read_c0_entryhi();\r\nhtw_stop();\r\nwrite_c0_entrylo0(0);\r\nwrite_c0_entrylo1(0);\r\nentry = read_c0_wired();\r\nif (cpu_has_tlbinv) {\r\nif (current_cpu_data.tlbsizevtlb) {\r\nwrite_c0_index(0);\r\nmtc0_tlbw_hazard();\r\ntlbinvf();\r\n}\r\nftlbhighset = current_cpu_data.tlbsizevtlb +\r\ncurrent_cpu_data.tlbsizeftlbsets;\r\nfor (entry = current_cpu_data.tlbsizevtlb;\r\nentry < ftlbhighset;\r\nentry++) {\r\nwrite_c0_index(entry);\r\nmtc0_tlbw_hazard();\r\ntlbinvf();\r\n}\r\n} else {\r\nwhile (entry < current_cpu_data.tlbsize) {\r\nwrite_c0_entryhi(UNIQUE_ENTRYHI(entry));\r\nwrite_c0_index(entry);\r\nmtc0_tlbw_hazard();\r\ntlb_write_indexed();\r\nentry++;\r\n}\r\n}\r\ntlbw_use_hazard();\r\nwrite_c0_entryhi(old_ctx);\r\nhtw_start();\r\nflush_itlb();\r\nlocal_irq_restore(flags);\r\n}\r\nvoid local_flush_tlb_mm(struct mm_struct *mm)\r\n{\r\nint cpu;\r\npreempt_disable();\r\ncpu = smp_processor_id();\r\nif (cpu_context(cpu, mm) != 0) {\r\ndrop_mmu_context(mm, cpu);\r\n}\r\npreempt_enable();\r\n}\r\nvoid local_flush_tlb_range(struct vm_area_struct *vma, unsigned long start,\r\nunsigned long end)\r\n{\r\nstruct mm_struct *mm = vma->vm_mm;\r\nint cpu = smp_processor_id();\r\nif (cpu_context(cpu, mm) != 0) {\r\nunsigned long size, flags;\r\nlocal_irq_save(flags);\r\nstart = round_down(start, PAGE_SIZE << 1);\r\nend = round_up(end, PAGE_SIZE << 1);\r\nsize = (end - start) >> (PAGE_SHIFT + 1);\r\nif (size <= (current_cpu_data.tlbsizeftlbsets ?\r\ncurrent_cpu_data.tlbsize / 8 :\r\ncurrent_cpu_data.tlbsize / 2)) {\r\nint oldpid = read_c0_entryhi();\r\nint newpid = cpu_asid(cpu, mm);\r\nhtw_stop();\r\nwhile (start < end) {\r\nint idx;\r\nwrite_c0_entryhi(start | newpid);\r\nstart += (PAGE_SIZE << 1);\r\nmtc0_tlbw_hazard();\r\ntlb_probe();\r\ntlb_probe_hazard();\r\nidx = read_c0_index();\r\nwrite_c0_entrylo0(0);\r\nwrite_c0_entrylo1(0);\r\nif (idx < 0)\r\ncontinue;\r\nwrite_c0_entryhi(UNIQUE_ENTRYHI(idx));\r\nmtc0_tlbw_hazard();\r\ntlb_write_indexed();\r\n}\r\ntlbw_use_hazard();\r\nwrite_c0_entryhi(oldpid);\r\nhtw_start();\r\n} else {\r\ndrop_mmu_context(mm, cpu);\r\n}\r\nflush_itlb();\r\nlocal_irq_restore(flags);\r\n}\r\n}\r\nvoid local_flush_tlb_kernel_range(unsigned long start, unsigned long end)\r\n{\r\nunsigned long size, flags;\r\nlocal_irq_save(flags);\r\nsize = (end - start + (PAGE_SIZE - 1)) >> PAGE_SHIFT;\r\nsize = (size + 1) >> 1;\r\nif (size <= (current_cpu_data.tlbsizeftlbsets ?\r\ncurrent_cpu_data.tlbsize / 8 :\r\ncurrent_cpu_data.tlbsize / 2)) {\r\nint pid = read_c0_entryhi();\r\nstart &= (PAGE_MASK << 1);\r\nend += ((PAGE_SIZE << 1) - 1);\r\nend &= (PAGE_MASK << 1);\r\nhtw_stop();\r\nwhile (start < end) {\r\nint idx;\r\nwrite_c0_entryhi(start);\r\nstart += (PAGE_SIZE << 1);\r\nmtc0_tlbw_hazard();\r\ntlb_probe();\r\ntlb_probe_hazard();\r\nidx = read_c0_index();\r\nwrite_c0_entrylo0(0);\r\nwrite_c0_entrylo1(0);\r\nif (idx < 0)\r\ncontinue;\r\nwrite_c0_entryhi(UNIQUE_ENTRYHI(idx));\r\nmtc0_tlbw_hazard();\r\ntlb_write_indexed();\r\n}\r\ntlbw_use_hazard();\r\nwrite_c0_entryhi(pid);\r\nhtw_start();\r\n} else {\r\nlocal_flush_tlb_all();\r\n}\r\nflush_itlb();\r\nlocal_irq_restore(flags);\r\n}\r\nvoid local_flush_tlb_page(struct vm_area_struct *vma, unsigned long page)\r\n{\r\nint cpu = smp_processor_id();\r\nif (cpu_context(cpu, vma->vm_mm) != 0) {\r\nunsigned long flags;\r\nint oldpid, newpid, idx;\r\nnewpid = cpu_asid(cpu, vma->vm_mm);\r\npage &= (PAGE_MASK << 1);\r\nlocal_irq_save(flags);\r\noldpid = read_c0_entryhi();\r\nhtw_stop();\r\nwrite_c0_entryhi(page | newpid);\r\nmtc0_tlbw_hazard();\r\ntlb_probe();\r\ntlb_probe_hazard();\r\nidx = read_c0_index();\r\nwrite_c0_entrylo0(0);\r\nwrite_c0_entrylo1(0);\r\nif (idx < 0)\r\ngoto finish;\r\nwrite_c0_entryhi(UNIQUE_ENTRYHI(idx));\r\nmtc0_tlbw_hazard();\r\ntlb_write_indexed();\r\ntlbw_use_hazard();\r\nfinish:\r\nwrite_c0_entryhi(oldpid);\r\nhtw_start();\r\nflush_itlb_vm(vma);\r\nlocal_irq_restore(flags);\r\n}\r\n}\r\nvoid local_flush_tlb_one(unsigned long page)\r\n{\r\nunsigned long flags;\r\nint oldpid, idx;\r\nlocal_irq_save(flags);\r\noldpid = read_c0_entryhi();\r\nhtw_stop();\r\npage &= (PAGE_MASK << 1);\r\nwrite_c0_entryhi(page);\r\nmtc0_tlbw_hazard();\r\ntlb_probe();\r\ntlb_probe_hazard();\r\nidx = read_c0_index();\r\nwrite_c0_entrylo0(0);\r\nwrite_c0_entrylo1(0);\r\nif (idx >= 0) {\r\nwrite_c0_entryhi(UNIQUE_ENTRYHI(idx));\r\nmtc0_tlbw_hazard();\r\ntlb_write_indexed();\r\ntlbw_use_hazard();\r\n}\r\nwrite_c0_entryhi(oldpid);\r\nhtw_start();\r\nflush_itlb();\r\nlocal_irq_restore(flags);\r\n}\r\nvoid __update_tlb(struct vm_area_struct * vma, unsigned long address, pte_t pte)\r\n{\r\nunsigned long flags;\r\npgd_t *pgdp;\r\npud_t *pudp;\r\npmd_t *pmdp;\r\npte_t *ptep;\r\nint idx, pid;\r\nif (current->active_mm != vma->vm_mm)\r\nreturn;\r\nlocal_irq_save(flags);\r\nhtw_stop();\r\npid = read_c0_entryhi() & ASID_MASK;\r\naddress &= (PAGE_MASK << 1);\r\nwrite_c0_entryhi(address | pid);\r\npgdp = pgd_offset(vma->vm_mm, address);\r\nmtc0_tlbw_hazard();\r\ntlb_probe();\r\ntlb_probe_hazard();\r\npudp = pud_offset(pgdp, address);\r\npmdp = pmd_offset(pudp, address);\r\nidx = read_c0_index();\r\n#ifdef CONFIG_MIPS_HUGE_TLB_SUPPORT\r\nif (pmd_huge(*pmdp)) {\r\nunsigned long lo;\r\nwrite_c0_pagemask(PM_HUGE_MASK);\r\nptep = (pte_t *)pmdp;\r\nlo = pte_to_entrylo(pte_val(*ptep));\r\nwrite_c0_entrylo0(lo);\r\nwrite_c0_entrylo1(lo + (HPAGE_SIZE >> 7));\r\nmtc0_tlbw_hazard();\r\nif (idx < 0)\r\ntlb_write_random();\r\nelse\r\ntlb_write_indexed();\r\ntlbw_use_hazard();\r\nwrite_c0_pagemask(PM_DEFAULT_MASK);\r\n} else\r\n#endif\r\n{\r\nptep = pte_offset_map(pmdp, address);\r\n#if defined(CONFIG_PHYS_ADDR_T_64BIT) && defined(CONFIG_CPU_MIPS32)\r\n#ifdef CONFIG_XPA\r\nwrite_c0_entrylo0(pte_to_entrylo(ptep->pte_high));\r\nwritex_c0_entrylo0(ptep->pte_low & _PFNX_MASK);\r\nptep++;\r\nwrite_c0_entrylo1(pte_to_entrylo(ptep->pte_high));\r\nwritex_c0_entrylo1(ptep->pte_low & _PFNX_MASK);\r\n#else\r\nwrite_c0_entrylo0(ptep->pte_high);\r\nptep++;\r\nwrite_c0_entrylo1(ptep->pte_high);\r\n#endif\r\n#else\r\nwrite_c0_entrylo0(pte_to_entrylo(pte_val(*ptep++)));\r\nwrite_c0_entrylo1(pte_to_entrylo(pte_val(*ptep)));\r\n#endif\r\nmtc0_tlbw_hazard();\r\nif (idx < 0)\r\ntlb_write_random();\r\nelse\r\ntlb_write_indexed();\r\n}\r\ntlbw_use_hazard();\r\nhtw_start();\r\nflush_itlb_vm(vma);\r\nlocal_irq_restore(flags);\r\n}\r\nvoid add_wired_entry(unsigned long entrylo0, unsigned long entrylo1,\r\nunsigned long entryhi, unsigned long pagemask)\r\n{\r\n#ifdef CONFIG_XPA\r\npanic("Broken for XPA kernels");\r\n#else\r\nunsigned long flags;\r\nunsigned long wired;\r\nunsigned long old_pagemask;\r\nunsigned long old_ctx;\r\nlocal_irq_save(flags);\r\nold_ctx = read_c0_entryhi();\r\nhtw_stop();\r\nold_pagemask = read_c0_pagemask();\r\nwired = read_c0_wired();\r\nwrite_c0_wired(wired + 1);\r\nwrite_c0_index(wired);\r\ntlbw_use_hazard();\r\nwrite_c0_pagemask(pagemask);\r\nwrite_c0_entryhi(entryhi);\r\nwrite_c0_entrylo0(entrylo0);\r\nwrite_c0_entrylo1(entrylo1);\r\nmtc0_tlbw_hazard();\r\ntlb_write_indexed();\r\ntlbw_use_hazard();\r\nwrite_c0_entryhi(old_ctx);\r\ntlbw_use_hazard();\r\nhtw_start();\r\nwrite_c0_pagemask(old_pagemask);\r\nlocal_flush_tlb_all();\r\nlocal_irq_restore(flags);\r\n#endif\r\n}\r\nint __init has_transparent_hugepage(void)\r\n{\r\nunsigned int mask;\r\nunsigned long flags;\r\nlocal_irq_save(flags);\r\nwrite_c0_pagemask(PM_HUGE_MASK);\r\nback_to_back_c0_hazard();\r\nmask = read_c0_pagemask();\r\nwrite_c0_pagemask(PM_DEFAULT_MASK);\r\nlocal_irq_restore(flags);\r\nreturn mask == PM_HUGE_MASK;\r\n}\r\n__init int add_temporary_entry(unsigned long entrylo0, unsigned long entrylo1,\r\nunsigned long entryhi, unsigned long pagemask)\r\n{\r\nint ret = 0;\r\nunsigned long flags;\r\nunsigned long wired;\r\nunsigned long old_pagemask;\r\nunsigned long old_ctx;\r\nlocal_irq_save(flags);\r\nhtw_stop();\r\nold_ctx = read_c0_entryhi();\r\nold_pagemask = read_c0_pagemask();\r\nwired = read_c0_wired();\r\nif (--temp_tlb_entry < wired) {\r\nprintk(KERN_WARNING\r\n"No TLB space left for add_temporary_entry\n");\r\nret = -ENOSPC;\r\ngoto out;\r\n}\r\nwrite_c0_index(temp_tlb_entry);\r\nwrite_c0_pagemask(pagemask);\r\nwrite_c0_entryhi(entryhi);\r\nwrite_c0_entrylo0(entrylo0);\r\nwrite_c0_entrylo1(entrylo1);\r\nmtc0_tlbw_hazard();\r\ntlb_write_indexed();\r\ntlbw_use_hazard();\r\nwrite_c0_entryhi(old_ctx);\r\nwrite_c0_pagemask(old_pagemask);\r\nhtw_start();\r\nout:\r\nlocal_irq_restore(flags);\r\nreturn ret;\r\n}\r\nstatic int __init set_ntlb(char *str)\r\n{\r\nget_option(&str, &ntlb);\r\nreturn 1;\r\n}\r\nstatic void r4k_tlb_configure(void)\r\n{\r\nwrite_c0_pagemask(PM_DEFAULT_MASK);\r\nwrite_c0_wired(0);\r\nif (current_cpu_type() == CPU_R10000 ||\r\ncurrent_cpu_type() == CPU_R12000 ||\r\ncurrent_cpu_type() == CPU_R14000 ||\r\ncurrent_cpu_type() == CPU_R16000)\r\nwrite_c0_framemask(0);\r\nif (cpu_has_rixi) {\r\n#ifdef CONFIG_64BIT\r\nset_c0_pagegrain(PG_RIE | PG_XIE | PG_ELPA);\r\n#else\r\nset_c0_pagegrain(PG_RIE | PG_XIE);\r\n#endif\r\n}\r\ntemp_tlb_entry = current_cpu_data.tlbsize - 1;\r\nlocal_flush_tlb_all();\r\n}\r\nvoid tlb_init(void)\r\n{\r\nr4k_tlb_configure();\r\nif (ntlb) {\r\nif (ntlb > 1 && ntlb <= current_cpu_data.tlbsize) {\r\nint wired = current_cpu_data.tlbsize - ntlb;\r\nwrite_c0_wired(wired);\r\nwrite_c0_index(wired-1);\r\nprintk("Restricting TLB to %d entries\n", ntlb);\r\n} else\r\nprintk("Ignoring invalid argument ntlb=%d\n", ntlb);\r\n}\r\nbuild_tlb_refill_handler();\r\n}\r\nstatic int r4k_tlb_pm_notifier(struct notifier_block *self, unsigned long cmd,\r\nvoid *v)\r\n{\r\nswitch (cmd) {\r\ncase CPU_PM_ENTER_FAILED:\r\ncase CPU_PM_EXIT:\r\nr4k_tlb_configure();\r\nbreak;\r\n}\r\nreturn NOTIFY_OK;\r\n}\r\nstatic int __init r4k_tlb_init_pm(void)\r\n{\r\nreturn cpu_pm_register_notifier(&r4k_tlb_pm_notifier_block);\r\n}
