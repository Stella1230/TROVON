int __init __weak early_init_dt_alloc_reserved_memory_arch(phys_addr_t size,\r\nphys_addr_t align, phys_addr_t start, phys_addr_t end, bool nomap,\r\nphys_addr_t *res_base)\r\n{\r\nphys_addr_t base = __memblock_alloc_base(size, align, end);\r\nif (!base)\r\nreturn -ENOMEM;\r\nif (base < start) {\r\nmemblock_free(base, size);\r\nreturn -ENOMEM;\r\n}\r\n*res_base = base;\r\nif (nomap)\r\nreturn memblock_remove(base, size);\r\nreturn 0;\r\n}\r\nint __init __weak early_init_dt_alloc_reserved_memory_arch(phys_addr_t size,\r\nphys_addr_t align, phys_addr_t start, phys_addr_t end, bool nomap,\r\nphys_addr_t *res_base)\r\n{\r\npr_err("Reserved memory not supported, ignoring region 0x%llx%s\n",\r\nsize, nomap ? " (nomap)" : "");\r\nreturn -ENOSYS;\r\n}\r\nvoid __init fdt_reserved_mem_save_node(unsigned long node, const char *uname,\r\nphys_addr_t base, phys_addr_t size)\r\n{\r\nstruct reserved_mem *rmem = &reserved_mem[reserved_mem_count];\r\nif (reserved_mem_count == ARRAY_SIZE(reserved_mem)) {\r\npr_err("Reserved memory: not enough space all defined regions.\n");\r\nreturn;\r\n}\r\nrmem->fdt_node = node;\r\nrmem->name = uname;\r\nrmem->base = base;\r\nrmem->size = size;\r\nreserved_mem_count++;\r\nreturn;\r\n}\r\nstatic int __init __reserved_mem_alloc_size(unsigned long node,\r\nconst char *uname, phys_addr_t *res_base, phys_addr_t *res_size)\r\n{\r\nint t_len = (dt_root_addr_cells + dt_root_size_cells) * sizeof(__be32);\r\nphys_addr_t start = 0, end = 0;\r\nphys_addr_t base = 0, align = 0, size;\r\nint len;\r\nconst __be32 *prop;\r\nint nomap;\r\nint ret;\r\nprop = of_get_flat_dt_prop(node, "size", &len);\r\nif (!prop)\r\nreturn -EINVAL;\r\nif (len != dt_root_size_cells * sizeof(__be32)) {\r\npr_err("Reserved memory: invalid size property in '%s' node.\n",\r\nuname);\r\nreturn -EINVAL;\r\n}\r\nsize = dt_mem_next_cell(dt_root_size_cells, &prop);\r\nnomap = of_get_flat_dt_prop(node, "no-map", NULL) != NULL;\r\nprop = of_get_flat_dt_prop(node, "alignment", &len);\r\nif (prop) {\r\nif (len != dt_root_addr_cells * sizeof(__be32)) {\r\npr_err("Reserved memory: invalid alignment property in '%s' node.\n",\r\nuname);\r\nreturn -EINVAL;\r\n}\r\nalign = dt_mem_next_cell(dt_root_addr_cells, &prop);\r\n}\r\nif (IS_ENABLED(CONFIG_CMA) && of_flat_dt_is_compatible(node, "shared-dma-pool"))\r\nalign = max(align, (phys_addr_t)PAGE_SIZE << max(MAX_ORDER - 1, pageblock_order));\r\nprop = of_get_flat_dt_prop(node, "alloc-ranges", &len);\r\nif (prop) {\r\nif (len % t_len != 0) {\r\npr_err("Reserved memory: invalid alloc-ranges property in '%s', skipping node.\n",\r\nuname);\r\nreturn -EINVAL;\r\n}\r\nbase = 0;\r\nwhile (len > 0) {\r\nstart = dt_mem_next_cell(dt_root_addr_cells, &prop);\r\nend = start + dt_mem_next_cell(dt_root_size_cells,\r\n&prop);\r\nret = early_init_dt_alloc_reserved_memory_arch(size,\r\nalign, start, end, nomap, &base);\r\nif (ret == 0) {\r\npr_debug("Reserved memory: allocated memory for '%s' node: base %pa, size %ld MiB\n",\r\nuname, &base,\r\n(unsigned long)size / SZ_1M);\r\nbreak;\r\n}\r\nlen -= t_len;\r\n}\r\n} else {\r\nret = early_init_dt_alloc_reserved_memory_arch(size, align,\r\n0, 0, nomap, &base);\r\nif (ret == 0)\r\npr_debug("Reserved memory: allocated memory for '%s' node: base %pa, size %ld MiB\n",\r\nuname, &base, (unsigned long)size / SZ_1M);\r\n}\r\nif (base == 0) {\r\npr_info("Reserved memory: failed to allocate memory for node '%s'\n",\r\nuname);\r\nreturn -ENOMEM;\r\n}\r\n*res_base = base;\r\n*res_size = size;\r\nreturn 0;\r\n}\r\nstatic int __init __reserved_mem_init_node(struct reserved_mem *rmem)\r\n{\r\nextern const struct of_device_id __reservedmem_of_table[];\r\nconst struct of_device_id *i;\r\nfor (i = __reservedmem_of_table; i < &__rmem_of_table_sentinel; i++) {\r\nreservedmem_of_init_fn initfn = i->data;\r\nconst char *compat = i->compatible;\r\nif (!of_flat_dt_is_compatible(rmem->fdt_node, compat))\r\ncontinue;\r\nif (initfn(rmem) == 0) {\r\npr_info("Reserved memory: initialized node %s, compatible id %s\n",\r\nrmem->name, compat);\r\nreturn 0;\r\n}\r\n}\r\nreturn -ENOENT;\r\n}\r\nstatic int __init __rmem_cmp(const void *a, const void *b)\r\n{\r\nconst struct reserved_mem *ra = a, *rb = b;\r\nif (ra->base < rb->base)\r\nreturn -1;\r\nif (ra->base > rb->base)\r\nreturn 1;\r\nreturn 0;\r\n}\r\nstatic void __init __rmem_check_for_overlap(void)\r\n{\r\nint i;\r\nif (reserved_mem_count < 2)\r\nreturn;\r\nsort(reserved_mem, reserved_mem_count, sizeof(reserved_mem[0]),\r\n__rmem_cmp, NULL);\r\nfor (i = 0; i < reserved_mem_count - 1; i++) {\r\nstruct reserved_mem *this, *next;\r\nthis = &reserved_mem[i];\r\nnext = &reserved_mem[i + 1];\r\nif (!(this->base && next->base))\r\ncontinue;\r\nif (this->base + this->size > next->base) {\r\nphys_addr_t this_end, next_end;\r\nthis_end = this->base + this->size;\r\nnext_end = next->base + next->size;\r\npr_err("Reserved memory: OVERLAP DETECTED!\n%s (%pa--%pa) overlaps with %s (%pa--%pa)\n",\r\nthis->name, &this->base, &this_end,\r\nnext->name, &next->base, &next_end);\r\n}\r\n}\r\n}\r\nvoid __init fdt_init_reserved_mem(void)\r\n{\r\nint i;\r\n__rmem_check_for_overlap();\r\nfor (i = 0; i < reserved_mem_count; i++) {\r\nstruct reserved_mem *rmem = &reserved_mem[i];\r\nunsigned long node = rmem->fdt_node;\r\nint len;\r\nconst __be32 *prop;\r\nint err = 0;\r\nprop = of_get_flat_dt_prop(node, "phandle", &len);\r\nif (!prop)\r\nprop = of_get_flat_dt_prop(node, "linux,phandle", &len);\r\nif (prop)\r\nrmem->phandle = of_read_number(prop, len/4);\r\nif (rmem->size == 0)\r\nerr = __reserved_mem_alloc_size(node, rmem->name,\r\n&rmem->base, &rmem->size);\r\nif (err == 0)\r\n__reserved_mem_init_node(rmem);\r\n}\r\n}\r\nstatic inline struct reserved_mem *__find_rmem(struct device_node *node)\r\n{\r\nunsigned int i;\r\nif (!node->phandle)\r\nreturn NULL;\r\nfor (i = 0; i < reserved_mem_count; i++)\r\nif (reserved_mem[i].phandle == node->phandle)\r\nreturn &reserved_mem[i];\r\nreturn NULL;\r\n}\r\nint of_reserved_mem_device_init(struct device *dev)\r\n{\r\nstruct reserved_mem *rmem;\r\nstruct device_node *np;\r\nint ret;\r\nnp = of_parse_phandle(dev->of_node, "memory-region", 0);\r\nif (!np)\r\nreturn -ENODEV;\r\nrmem = __find_rmem(np);\r\nof_node_put(np);\r\nif (!rmem || !rmem->ops || !rmem->ops->device_init)\r\nreturn -EINVAL;\r\nret = rmem->ops->device_init(rmem, dev);\r\nif (ret == 0)\r\ndev_info(dev, "assigned reserved memory node %s\n", rmem->name);\r\nreturn ret;\r\n}\r\nvoid of_reserved_mem_device_release(struct device *dev)\r\n{\r\nstruct reserved_mem *rmem;\r\nstruct device_node *np;\r\nnp = of_parse_phandle(dev->of_node, "memory-region", 0);\r\nif (!np)\r\nreturn;\r\nrmem = __find_rmem(np);\r\nof_node_put(np);\r\nif (!rmem || !rmem->ops || !rmem->ops->device_release)\r\nreturn;\r\nrmem->ops->device_release(rmem, dev);\r\n}
