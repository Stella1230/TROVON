static ssize_t nfsctl_transaction_write(struct file *file, const char __user *buf, size_t size, loff_t *pos)\r\n{\r\nino_t ino = file_inode(file)->i_ino;\r\nchar *data;\r\nssize_t rv;\r\nif (ino >= ARRAY_SIZE(write_op) || !write_op[ino])\r\nreturn -EINVAL;\r\ndata = simple_transaction_get(file, buf, size);\r\nif (IS_ERR(data))\r\nreturn PTR_ERR(data);\r\nrv = write_op[ino](file, data, size);\r\nif (rv >= 0) {\r\nsimple_transaction_set(file, rv);\r\nrv = size;\r\n}\r\nreturn rv;\r\n}\r\nstatic ssize_t nfsctl_transaction_read(struct file *file, char __user *buf, size_t size, loff_t *pos)\r\n{\r\nif (! file->private_data) {\r\nssize_t rv = nfsctl_transaction_write(file, buf, 0, pos);\r\nif (rv < 0)\r\nreturn rv;\r\n}\r\nreturn simple_transaction_read(file, buf, size, pos);\r\n}\r\nstatic int exports_net_open(struct net *net, struct file *file)\r\n{\r\nint err;\r\nstruct seq_file *seq;\r\nstruct nfsd_net *nn = net_generic(net, nfsd_net_id);\r\nerr = seq_open(file, &nfs_exports_op);\r\nif (err)\r\nreturn err;\r\nseq = file->private_data;\r\nseq->private = nn->svc_export_cache;\r\nreturn 0;\r\n}\r\nstatic int exports_proc_open(struct inode *inode, struct file *file)\r\n{\r\nreturn exports_net_open(current->nsproxy->net_ns, file);\r\n}\r\nstatic int exports_nfsd_open(struct inode *inode, struct file *file)\r\n{\r\nreturn exports_net_open(inode->i_sb->s_fs_info, file);\r\n}\r\nstatic int export_features_show(struct seq_file *m, void *v)\r\n{\r\nseq_printf(m, "0x%x 0x%x\n", NFSEXP_ALLFLAGS, NFSEXP_SECINFO_FLAGS);\r\nreturn 0;\r\n}\r\nstatic int export_features_open(struct inode *inode, struct file *file)\r\n{\r\nreturn single_open(file, export_features_show, NULL);\r\n}\r\nstatic int supported_enctypes_show(struct seq_file *m, void *v)\r\n{\r\nseq_printf(m, KRB5_SUPPORTED_ENCTYPES);\r\nreturn 0;\r\n}\r\nstatic int supported_enctypes_open(struct inode *inode, struct file *file)\r\n{\r\nreturn single_open(file, supported_enctypes_show, NULL);\r\n}\r\nstatic inline struct net *netns(struct file *file)\r\n{\r\nreturn file_inode(file)->i_sb->s_fs_info;\r\n}\r\nstatic ssize_t write_unlock_ip(struct file *file, char *buf, size_t size)\r\n{\r\nstruct sockaddr_storage address;\r\nstruct sockaddr *sap = (struct sockaddr *)&address;\r\nsize_t salen = sizeof(address);\r\nchar *fo_path;\r\nstruct net *net = netns(file);\r\nif (size == 0)\r\nreturn -EINVAL;\r\nif (buf[size-1] != '\n')\r\nreturn -EINVAL;\r\nfo_path = buf;\r\nif (qword_get(&buf, fo_path, size) < 0)\r\nreturn -EINVAL;\r\nif (rpc_pton(net, fo_path, size, sap, salen) == 0)\r\nreturn -EINVAL;\r\nreturn nlmsvc_unlock_all_by_ip(sap);\r\n}\r\nstatic ssize_t write_unlock_fs(struct file *file, char *buf, size_t size)\r\n{\r\nstruct path path;\r\nchar *fo_path;\r\nint error;\r\nif (size == 0)\r\nreturn -EINVAL;\r\nif (buf[size-1] != '\n')\r\nreturn -EINVAL;\r\nfo_path = buf;\r\nif (qword_get(&buf, fo_path, size) < 0)\r\nreturn -EINVAL;\r\nerror = kern_path(fo_path, 0, &path);\r\nif (error)\r\nreturn error;\r\nerror = nlmsvc_unlock_all_by_sb(path.dentry->d_sb);\r\npath_put(&path);\r\nreturn error;\r\n}\r\nstatic ssize_t write_filehandle(struct file *file, char *buf, size_t size)\r\n{\r\nchar *dname, *path;\r\nint uninitialized_var(maxsize);\r\nchar *mesg = buf;\r\nint len;\r\nstruct auth_domain *dom;\r\nstruct knfsd_fh fh;\r\nif (size == 0)\r\nreturn -EINVAL;\r\nif (buf[size-1] != '\n')\r\nreturn -EINVAL;\r\nbuf[size-1] = 0;\r\ndname = mesg;\r\nlen = qword_get(&mesg, dname, size);\r\nif (len <= 0)\r\nreturn -EINVAL;\r\npath = dname+len+1;\r\nlen = qword_get(&mesg, path, size);\r\nif (len <= 0)\r\nreturn -EINVAL;\r\nlen = get_int(&mesg, &maxsize);\r\nif (len)\r\nreturn len;\r\nif (maxsize < NFS_FHSIZE)\r\nreturn -EINVAL;\r\nmaxsize = min(maxsize, NFS3_FHSIZE);\r\nif (qword_get(&mesg, mesg, size)>0)\r\nreturn -EINVAL;\r\ndom = unix_domain_find(dname);\r\nif (!dom)\r\nreturn -ENOMEM;\r\nlen = exp_rootfh(netns(file), dom, path, &fh, maxsize);\r\nauth_domain_put(dom);\r\nif (len)\r\nreturn len;\r\nmesg = buf;\r\nlen = SIMPLE_TRANSACTION_LIMIT;\r\nqword_addhex(&mesg, &len, (char*)&fh.fh_base, fh.fh_size);\r\nmesg[-1] = '\n';\r\nreturn mesg - buf;\r\n}\r\nstatic ssize_t write_threads(struct file *file, char *buf, size_t size)\r\n{\r\nchar *mesg = buf;\r\nint rv;\r\nstruct net *net = netns(file);\r\nif (size > 0) {\r\nint newthreads;\r\nrv = get_int(&mesg, &newthreads);\r\nif (rv)\r\nreturn rv;\r\nif (newthreads < 0)\r\nreturn -EINVAL;\r\nrv = nfsd_svc(newthreads, net);\r\nif (rv < 0)\r\nreturn rv;\r\n} else\r\nrv = nfsd_nrthreads(net);\r\nreturn scnprintf(buf, SIMPLE_TRANSACTION_LIMIT, "%d\n", rv);\r\n}\r\nstatic ssize_t write_pool_threads(struct file *file, char *buf, size_t size)\r\n{\r\nchar *mesg = buf;\r\nint i;\r\nint rv;\r\nint len;\r\nint npools;\r\nint *nthreads;\r\nstruct net *net = netns(file);\r\nmutex_lock(&nfsd_mutex);\r\nnpools = nfsd_nrpools(net);\r\nif (npools == 0) {\r\nmutex_unlock(&nfsd_mutex);\r\nstrcpy(buf, "0\n");\r\nreturn strlen(buf);\r\n}\r\nnthreads = kcalloc(npools, sizeof(int), GFP_KERNEL);\r\nrv = -ENOMEM;\r\nif (nthreads == NULL)\r\ngoto out_free;\r\nif (size > 0) {\r\nfor (i = 0; i < npools; i++) {\r\nrv = get_int(&mesg, &nthreads[i]);\r\nif (rv == -ENOENT)\r\nbreak;\r\nif (rv)\r\ngoto out_free;\r\nrv = -EINVAL;\r\nif (nthreads[i] < 0)\r\ngoto out_free;\r\n}\r\nrv = nfsd_set_nrthreads(i, nthreads, net);\r\nif (rv)\r\ngoto out_free;\r\n}\r\nrv = nfsd_get_nrthreads(npools, nthreads, net);\r\nif (rv)\r\ngoto out_free;\r\nmesg = buf;\r\nsize = SIMPLE_TRANSACTION_LIMIT;\r\nfor (i = 0; i < npools && size > 0; i++) {\r\nsnprintf(mesg, size, "%d%c", nthreads[i], (i == npools-1 ? '\n' : ' '));\r\nlen = strlen(mesg);\r\nsize -= len;\r\nmesg += len;\r\n}\r\nrv = mesg - buf;\r\nout_free:\r\nkfree(nthreads);\r\nmutex_unlock(&nfsd_mutex);\r\nreturn rv;\r\n}\r\nstatic ssize_t __write_versions(struct file *file, char *buf, size_t size)\r\n{\r\nchar *mesg = buf;\r\nchar *vers, *minorp, sign;\r\nint len, num, remaining;\r\nunsigned minor;\r\nssize_t tlen = 0;\r\nchar *sep;\r\nstruct nfsd_net *nn = net_generic(netns(file), nfsd_net_id);\r\nif (size>0) {\r\nif (nn->nfsd_serv)\r\nreturn -EBUSY;\r\nif (buf[size-1] != '\n')\r\nreturn -EINVAL;\r\nbuf[size-1] = 0;\r\nvers = mesg;\r\nlen = qword_get(&mesg, vers, size);\r\nif (len <= 0) return -EINVAL;\r\ndo {\r\nsign = *vers;\r\nif (sign == '+' || sign == '-')\r\nnum = simple_strtol((vers+1), &minorp, 0);\r\nelse\r\nnum = simple_strtol(vers, &minorp, 0);\r\nif (*minorp == '.') {\r\nif (num != 4)\r\nreturn -EINVAL;\r\nminor = simple_strtoul(minorp+1, NULL, 0);\r\nif (minor == 0)\r\nreturn -EINVAL;\r\nif (nfsd_minorversion(minor, sign == '-' ?\r\nNFSD_CLEAR : NFSD_SET) < 0)\r\nreturn -EINVAL;\r\ngoto next;\r\n}\r\nswitch(num) {\r\ncase 2:\r\ncase 3:\r\ncase 4:\r\nnfsd_vers(num, sign == '-' ? NFSD_CLEAR : NFSD_SET);\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nnext:\r\nvers += len + 1;\r\n} while ((len = qword_get(&mesg, vers, size)) > 0);\r\nnfsd_reset_versions();\r\n}\r\nlen = 0;\r\nsep = "";\r\nremaining = SIMPLE_TRANSACTION_LIMIT;\r\nfor (num=2 ; num <= 4 ; num++)\r\nif (nfsd_vers(num, NFSD_AVAIL)) {\r\nlen = snprintf(buf, remaining, "%s%c%d", sep,\r\nnfsd_vers(num, NFSD_TEST)?'+':'-',\r\nnum);\r\nsep = " ";\r\nif (len >= remaining)\r\nbreak;\r\nremaining -= len;\r\nbuf += len;\r\ntlen += len;\r\n}\r\nif (nfsd_vers(4, NFSD_AVAIL))\r\nfor (minor = 1; minor <= NFSD_SUPPORTED_MINOR_VERSION;\r\nminor++) {\r\nlen = snprintf(buf, remaining, " %c4.%u",\r\n(nfsd_vers(4, NFSD_TEST) &&\r\nnfsd_minorversion(minor, NFSD_TEST)) ?\r\n'+' : '-',\r\nminor);\r\nif (len >= remaining)\r\nbreak;\r\nremaining -= len;\r\nbuf += len;\r\ntlen += len;\r\n}\r\nlen = snprintf(buf, remaining, "\n");\r\nif (len >= remaining)\r\nreturn -EINVAL;\r\nreturn tlen + len;\r\n}\r\nstatic ssize_t write_versions(struct file *file, char *buf, size_t size)\r\n{\r\nssize_t rv;\r\nmutex_lock(&nfsd_mutex);\r\nrv = __write_versions(file, buf, size);\r\nmutex_unlock(&nfsd_mutex);\r\nreturn rv;\r\n}\r\nstatic ssize_t __write_ports_names(char *buf, struct net *net)\r\n{\r\nstruct nfsd_net *nn = net_generic(net, nfsd_net_id);\r\nif (nn->nfsd_serv == NULL)\r\nreturn 0;\r\nreturn svc_xprt_names(nn->nfsd_serv, buf, SIMPLE_TRANSACTION_LIMIT);\r\n}\r\nstatic ssize_t __write_ports_addfd(char *buf, struct net *net)\r\n{\r\nchar *mesg = buf;\r\nint fd, err;\r\nstruct nfsd_net *nn = net_generic(net, nfsd_net_id);\r\nerr = get_int(&mesg, &fd);\r\nif (err != 0 || fd < 0)\r\nreturn -EINVAL;\r\nif (svc_alien_sock(net, fd)) {\r\nprintk(KERN_ERR "%s: socket net is different to NFSd's one\n", __func__);\r\nreturn -EINVAL;\r\n}\r\nerr = nfsd_create_serv(net);\r\nif (err != 0)\r\nreturn err;\r\nerr = svc_addsock(nn->nfsd_serv, fd, buf, SIMPLE_TRANSACTION_LIMIT);\r\nif (err < 0) {\r\nnfsd_destroy(net);\r\nreturn err;\r\n}\r\nnn->nfsd_serv->sv_nrthreads--;\r\nreturn err;\r\n}\r\nstatic ssize_t __write_ports_addxprt(char *buf, struct net *net)\r\n{\r\nchar transport[16];\r\nstruct svc_xprt *xprt;\r\nint port, err;\r\nstruct nfsd_net *nn = net_generic(net, nfsd_net_id);\r\nif (sscanf(buf, "%15s %5u", transport, &port) != 2)\r\nreturn -EINVAL;\r\nif (port < 1 || port > USHRT_MAX)\r\nreturn -EINVAL;\r\nerr = nfsd_create_serv(net);\r\nif (err != 0)\r\nreturn err;\r\nerr = svc_create_xprt(nn->nfsd_serv, transport, net,\r\nPF_INET, port, SVC_SOCK_ANONYMOUS);\r\nif (err < 0)\r\ngoto out_err;\r\nerr = svc_create_xprt(nn->nfsd_serv, transport, net,\r\nPF_INET6, port, SVC_SOCK_ANONYMOUS);\r\nif (err < 0 && err != -EAFNOSUPPORT)\r\ngoto out_close;\r\nnn->nfsd_serv->sv_nrthreads--;\r\nreturn 0;\r\nout_close:\r\nxprt = svc_find_xprt(nn->nfsd_serv, transport, net, PF_INET, port);\r\nif (xprt != NULL) {\r\nsvc_close_xprt(xprt);\r\nsvc_xprt_put(xprt);\r\n}\r\nout_err:\r\nnfsd_destroy(net);\r\nreturn err;\r\n}\r\nstatic ssize_t __write_ports(struct file *file, char *buf, size_t size,\r\nstruct net *net)\r\n{\r\nif (size == 0)\r\nreturn __write_ports_names(buf, net);\r\nif (isdigit(buf[0]))\r\nreturn __write_ports_addfd(buf, net);\r\nif (isalpha(buf[0]))\r\nreturn __write_ports_addxprt(buf, net);\r\nreturn -EINVAL;\r\n}\r\nstatic ssize_t write_ports(struct file *file, char *buf, size_t size)\r\n{\r\nssize_t rv;\r\nmutex_lock(&nfsd_mutex);\r\nrv = __write_ports(file, buf, size, netns(file));\r\nmutex_unlock(&nfsd_mutex);\r\nreturn rv;\r\n}\r\nstatic ssize_t write_maxblksize(struct file *file, char *buf, size_t size)\r\n{\r\nchar *mesg = buf;\r\nstruct nfsd_net *nn = net_generic(netns(file), nfsd_net_id);\r\nif (size > 0) {\r\nint bsize;\r\nint rv = get_int(&mesg, &bsize);\r\nif (rv)\r\nreturn rv;\r\nbsize = max_t(int, bsize, 1024);\r\nbsize = min_t(int, bsize, NFSSVC_MAXBLKSIZE);\r\nbsize &= ~(1024-1);\r\nmutex_lock(&nfsd_mutex);\r\nif (nn->nfsd_serv) {\r\nmutex_unlock(&nfsd_mutex);\r\nreturn -EBUSY;\r\n}\r\nnfsd_max_blksize = bsize;\r\nmutex_unlock(&nfsd_mutex);\r\n}\r\nreturn scnprintf(buf, SIMPLE_TRANSACTION_LIMIT, "%d\n",\r\nnfsd_max_blksize);\r\n}\r\nstatic ssize_t write_maxconn(struct file *file, char *buf, size_t size)\r\n{\r\nchar *mesg = buf;\r\nstruct nfsd_net *nn = net_generic(netns(file), nfsd_net_id);\r\nunsigned int maxconn = nn->max_connections;\r\nif (size > 0) {\r\nint rv = get_uint(&mesg, &maxconn);\r\nif (rv)\r\nreturn rv;\r\nnn->max_connections = maxconn;\r\n}\r\nreturn scnprintf(buf, SIMPLE_TRANSACTION_LIMIT, "%u\n", maxconn);\r\n}\r\nstatic ssize_t __nfsd4_write_time(struct file *file, char *buf, size_t size,\r\ntime_t *time, struct nfsd_net *nn)\r\n{\r\nchar *mesg = buf;\r\nint rv, i;\r\nif (size > 0) {\r\nif (nn->nfsd_serv)\r\nreturn -EBUSY;\r\nrv = get_int(&mesg, &i);\r\nif (rv)\r\nreturn rv;\r\nif (i < 10 || i > 3600)\r\nreturn -EINVAL;\r\n*time = i;\r\n}\r\nreturn scnprintf(buf, SIMPLE_TRANSACTION_LIMIT, "%ld\n", *time);\r\n}\r\nstatic ssize_t nfsd4_write_time(struct file *file, char *buf, size_t size,\r\ntime_t *time, struct nfsd_net *nn)\r\n{\r\nssize_t rv;\r\nmutex_lock(&nfsd_mutex);\r\nrv = __nfsd4_write_time(file, buf, size, time, nn);\r\nmutex_unlock(&nfsd_mutex);\r\nreturn rv;\r\n}\r\nstatic ssize_t write_leasetime(struct file *file, char *buf, size_t size)\r\n{\r\nstruct nfsd_net *nn = net_generic(netns(file), nfsd_net_id);\r\nreturn nfsd4_write_time(file, buf, size, &nn->nfsd4_lease, nn);\r\n}\r\nstatic ssize_t write_gracetime(struct file *file, char *buf, size_t size)\r\n{\r\nstruct nfsd_net *nn = net_generic(netns(file), nfsd_net_id);\r\nreturn nfsd4_write_time(file, buf, size, &nn->nfsd4_grace, nn);\r\n}\r\nstatic ssize_t __write_recoverydir(struct file *file, char *buf, size_t size,\r\nstruct nfsd_net *nn)\r\n{\r\nchar *mesg = buf;\r\nchar *recdir;\r\nint len, status;\r\nif (size > 0) {\r\nif (nn->nfsd_serv)\r\nreturn -EBUSY;\r\nif (size > PATH_MAX || buf[size-1] != '\n')\r\nreturn -EINVAL;\r\nbuf[size-1] = 0;\r\nrecdir = mesg;\r\nlen = qword_get(&mesg, recdir, size);\r\nif (len <= 0)\r\nreturn -EINVAL;\r\nstatus = nfs4_reset_recoverydir(recdir);\r\nif (status)\r\nreturn status;\r\n}\r\nreturn scnprintf(buf, SIMPLE_TRANSACTION_LIMIT, "%s\n",\r\nnfs4_recoverydir());\r\n}\r\nstatic ssize_t write_recoverydir(struct file *file, char *buf, size_t size)\r\n{\r\nssize_t rv;\r\nstruct nfsd_net *nn = net_generic(netns(file), nfsd_net_id);\r\nmutex_lock(&nfsd_mutex);\r\nrv = __write_recoverydir(file, buf, size, nn);\r\nmutex_unlock(&nfsd_mutex);\r\nreturn rv;\r\n}\r\nstatic ssize_t write_v4_end_grace(struct file *file, char *buf, size_t size)\r\n{\r\nstruct nfsd_net *nn = net_generic(netns(file), nfsd_net_id);\r\nif (size > 0) {\r\nswitch(buf[0]) {\r\ncase 'Y':\r\ncase 'y':\r\ncase '1':\r\nnfsd4_end_grace(nn);\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\n}\r\nreturn scnprintf(buf, SIMPLE_TRANSACTION_LIMIT, "%c\n",\r\nnn->grace_ended ? 'Y' : 'N');\r\n}\r\nstatic int nfsd_fill_super(struct super_block * sb, void * data, int silent)\r\n{\r\nstatic struct tree_descr nfsd_files[] = {\r\n[NFSD_List] = {"exports", &exports_nfsd_operations, S_IRUGO},\r\n[NFSD_Export_features] = {"export_features",\r\n&export_features_operations, S_IRUGO},\r\n[NFSD_FO_UnlockIP] = {"unlock_ip",\r\n&transaction_ops, S_IWUSR|S_IRUSR},\r\n[NFSD_FO_UnlockFS] = {"unlock_filesystem",\r\n&transaction_ops, S_IWUSR|S_IRUSR},\r\n[NFSD_Fh] = {"filehandle", &transaction_ops, S_IWUSR|S_IRUSR},\r\n[NFSD_Threads] = {"threads", &transaction_ops, S_IWUSR|S_IRUSR},\r\n[NFSD_Pool_Threads] = {"pool_threads", &transaction_ops, S_IWUSR|S_IRUSR},\r\n[NFSD_Pool_Stats] = {"pool_stats", &pool_stats_operations, S_IRUGO},\r\n[NFSD_Reply_Cache_Stats] = {"reply_cache_stats", &reply_cache_stats_operations, S_IRUGO},\r\n[NFSD_Versions] = {"versions", &transaction_ops, S_IWUSR|S_IRUSR},\r\n[NFSD_Ports] = {"portlist", &transaction_ops, S_IWUSR|S_IRUGO},\r\n[NFSD_MaxBlkSize] = {"max_block_size", &transaction_ops, S_IWUSR|S_IRUGO},\r\n[NFSD_MaxConnections] = {"max_connections", &transaction_ops, S_IWUSR|S_IRUGO},\r\n#if defined(CONFIG_SUNRPC_GSS) || defined(CONFIG_SUNRPC_GSS_MODULE)\r\n[NFSD_SupportedEnctypes] = {"supported_krb5_enctypes", &supported_enctypes_ops, S_IRUGO},\r\n#endif\r\n#ifdef CONFIG_NFSD_V4\r\n[NFSD_Leasetime] = {"nfsv4leasetime", &transaction_ops, S_IWUSR|S_IRUSR},\r\n[NFSD_Gracetime] = {"nfsv4gracetime", &transaction_ops, S_IWUSR|S_IRUSR},\r\n[NFSD_RecoveryDir] = {"nfsv4recoverydir", &transaction_ops, S_IWUSR|S_IRUSR},\r\n[NFSD_V4EndGrace] = {"v4_end_grace", &transaction_ops, S_IWUSR|S_IRUGO},\r\n#endif\r\n{""}\r\n};\r\nstruct net *net = data;\r\nint ret;\r\nret = simple_fill_super(sb, 0x6e667364, nfsd_files);\r\nif (ret)\r\nreturn ret;\r\nsb->s_fs_info = get_net(net);\r\nreturn 0;\r\n}\r\nstatic struct dentry *nfsd_mount(struct file_system_type *fs_type,\r\nint flags, const char *dev_name, void *data)\r\n{\r\nreturn mount_ns(fs_type, flags, current->nsproxy->net_ns, nfsd_fill_super);\r\n}\r\nstatic void nfsd_umount(struct super_block *sb)\r\n{\r\nstruct net *net = sb->s_fs_info;\r\nkill_litter_super(sb);\r\nput_net(net);\r\n}\r\nstatic int create_proc_exports_entry(void)\r\n{\r\nstruct proc_dir_entry *entry;\r\nentry = proc_mkdir("fs/nfs", NULL);\r\nif (!entry)\r\nreturn -ENOMEM;\r\nentry = proc_create("exports", 0, entry,\r\n&exports_proc_operations);\r\nif (!entry) {\r\nremove_proc_entry("fs/nfs", NULL);\r\nreturn -ENOMEM;\r\n}\r\nreturn 0;\r\n}\r\nstatic int create_proc_exports_entry(void)\r\n{\r\nreturn 0;\r\n}\r\nstatic __net_init int nfsd_init_net(struct net *net)\r\n{\r\nint retval;\r\nstruct nfsd_net *nn = net_generic(net, nfsd_net_id);\r\nretval = nfsd_export_init(net);\r\nif (retval)\r\ngoto out_export_error;\r\nretval = nfsd_idmap_init(net);\r\nif (retval)\r\ngoto out_idmap_error;\r\nnn->nfsd4_lease = 90;\r\nnn->nfsd4_grace = 90;\r\nreturn 0;\r\nout_idmap_error:\r\nnfsd_export_shutdown(net);\r\nout_export_error:\r\nreturn retval;\r\n}\r\nstatic __net_exit void nfsd_exit_net(struct net *net)\r\n{\r\nnfsd_idmap_shutdown(net);\r\nnfsd_export_shutdown(net);\r\n}\r\nstatic int __init init_nfsd(void)\r\n{\r\nint retval;\r\nprintk(KERN_INFO "Installing knfsd (copyright (C) 1996 okir@monad.swb.de).\n");\r\nretval = register_pernet_subsys(&nfsd_net_ops);\r\nif (retval < 0)\r\nreturn retval;\r\nretval = register_cld_notifier();\r\nif (retval)\r\ngoto out_unregister_pernet;\r\nretval = nfsd4_init_slabs();\r\nif (retval)\r\ngoto out_unregister_notifier;\r\nretval = nfsd4_init_pnfs();\r\nif (retval)\r\ngoto out_free_slabs;\r\nretval = nfsd_fault_inject_init();\r\nif (retval)\r\ngoto out_exit_pnfs;\r\nnfsd_stat_init();\r\nretval = nfsd_reply_cache_init();\r\nif (retval)\r\ngoto out_free_stat;\r\nnfsd_lockd_init();\r\nretval = create_proc_exports_entry();\r\nif (retval)\r\ngoto out_free_lockd;\r\nretval = register_filesystem(&nfsd_fs_type);\r\nif (retval)\r\ngoto out_free_all;\r\nreturn 0;\r\nout_free_all:\r\nremove_proc_entry("fs/nfs/exports", NULL);\r\nremove_proc_entry("fs/nfs", NULL);\r\nout_free_lockd:\r\nnfsd_lockd_shutdown();\r\nnfsd_reply_cache_shutdown();\r\nout_free_stat:\r\nnfsd_stat_shutdown();\r\nnfsd_fault_inject_cleanup();\r\nout_exit_pnfs:\r\nnfsd4_exit_pnfs();\r\nout_free_slabs:\r\nnfsd4_free_slabs();\r\nout_unregister_notifier:\r\nunregister_cld_notifier();\r\nout_unregister_pernet:\r\nunregister_pernet_subsys(&nfsd_net_ops);\r\nreturn retval;\r\n}\r\nstatic void __exit exit_nfsd(void)\r\n{\r\nnfsd_reply_cache_shutdown();\r\nremove_proc_entry("fs/nfs/exports", NULL);\r\nremove_proc_entry("fs/nfs", NULL);\r\nnfsd_stat_shutdown();\r\nnfsd_lockd_shutdown();\r\nnfsd4_free_slabs();\r\nnfsd4_exit_pnfs();\r\nnfsd_fault_inject_cleanup();\r\nunregister_filesystem(&nfsd_fs_type);\r\nunregister_cld_notifier();\r\nunregister_pernet_subsys(&nfsd_net_ops);\r\n}
