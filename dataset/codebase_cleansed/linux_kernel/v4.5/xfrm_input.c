int xfrm_input_register_afinfo(struct xfrm_input_afinfo *afinfo)\r\n{\r\nint err = 0;\r\nif (unlikely(afinfo == NULL))\r\nreturn -EINVAL;\r\nif (unlikely(afinfo->family >= NPROTO))\r\nreturn -EAFNOSUPPORT;\r\nspin_lock_bh(&xfrm_input_afinfo_lock);\r\nif (unlikely(xfrm_input_afinfo[afinfo->family] != NULL))\r\nerr = -EEXIST;\r\nelse\r\nrcu_assign_pointer(xfrm_input_afinfo[afinfo->family], afinfo);\r\nspin_unlock_bh(&xfrm_input_afinfo_lock);\r\nreturn err;\r\n}\r\nint xfrm_input_unregister_afinfo(struct xfrm_input_afinfo *afinfo)\r\n{\r\nint err = 0;\r\nif (unlikely(afinfo == NULL))\r\nreturn -EINVAL;\r\nif (unlikely(afinfo->family >= NPROTO))\r\nreturn -EAFNOSUPPORT;\r\nspin_lock_bh(&xfrm_input_afinfo_lock);\r\nif (likely(xfrm_input_afinfo[afinfo->family] != NULL)) {\r\nif (unlikely(xfrm_input_afinfo[afinfo->family] != afinfo))\r\nerr = -EINVAL;\r\nelse\r\nRCU_INIT_POINTER(xfrm_input_afinfo[afinfo->family], NULL);\r\n}\r\nspin_unlock_bh(&xfrm_input_afinfo_lock);\r\nsynchronize_rcu();\r\nreturn err;\r\n}\r\nstatic struct xfrm_input_afinfo *xfrm_input_get_afinfo(unsigned int family)\r\n{\r\nstruct xfrm_input_afinfo *afinfo;\r\nif (unlikely(family >= NPROTO))\r\nreturn NULL;\r\nrcu_read_lock();\r\nafinfo = rcu_dereference(xfrm_input_afinfo[family]);\r\nif (unlikely(!afinfo))\r\nrcu_read_unlock();\r\nreturn afinfo;\r\n}\r\nstatic void xfrm_input_put_afinfo(struct xfrm_input_afinfo *afinfo)\r\n{\r\nrcu_read_unlock();\r\n}\r\nstatic int xfrm_rcv_cb(struct sk_buff *skb, unsigned int family, u8 protocol,\r\nint err)\r\n{\r\nint ret;\r\nstruct xfrm_input_afinfo *afinfo = xfrm_input_get_afinfo(family);\r\nif (!afinfo)\r\nreturn -EAFNOSUPPORT;\r\nret = afinfo->callback(skb, protocol, err);\r\nxfrm_input_put_afinfo(afinfo);\r\nreturn ret;\r\n}\r\nvoid __secpath_destroy(struct sec_path *sp)\r\n{\r\nint i;\r\nfor (i = 0; i < sp->len; i++)\r\nxfrm_state_put(sp->xvec[i]);\r\nkmem_cache_free(secpath_cachep, sp);\r\n}\r\nstruct sec_path *secpath_dup(struct sec_path *src)\r\n{\r\nstruct sec_path *sp;\r\nsp = kmem_cache_alloc(secpath_cachep, GFP_ATOMIC);\r\nif (!sp)\r\nreturn NULL;\r\nsp->len = 0;\r\nif (src) {\r\nint i;\r\nmemcpy(sp, src, sizeof(*sp));\r\nfor (i = 0; i < sp->len; i++)\r\nxfrm_state_hold(sp->xvec[i]);\r\n}\r\natomic_set(&sp->refcnt, 1);\r\nreturn sp;\r\n}\r\nint xfrm_parse_spi(struct sk_buff *skb, u8 nexthdr, __be32 *spi, __be32 *seq)\r\n{\r\nint offset, offset_seq;\r\nint hlen;\r\nswitch (nexthdr) {\r\ncase IPPROTO_AH:\r\nhlen = sizeof(struct ip_auth_hdr);\r\noffset = offsetof(struct ip_auth_hdr, spi);\r\noffset_seq = offsetof(struct ip_auth_hdr, seq_no);\r\nbreak;\r\ncase IPPROTO_ESP:\r\nhlen = sizeof(struct ip_esp_hdr);\r\noffset = offsetof(struct ip_esp_hdr, spi);\r\noffset_seq = offsetof(struct ip_esp_hdr, seq_no);\r\nbreak;\r\ncase IPPROTO_COMP:\r\nif (!pskb_may_pull(skb, sizeof(struct ip_comp_hdr)))\r\nreturn -EINVAL;\r\n*spi = htonl(ntohs(*(__be16 *)(skb_transport_header(skb) + 2)));\r\n*seq = 0;\r\nreturn 0;\r\ndefault:\r\nreturn 1;\r\n}\r\nif (!pskb_may_pull(skb, hlen))\r\nreturn -EINVAL;\r\n*spi = *(__be32 *)(skb_transport_header(skb) + offset);\r\n*seq = *(__be32 *)(skb_transport_header(skb) + offset_seq);\r\nreturn 0;\r\n}\r\nint xfrm_prepare_input(struct xfrm_state *x, struct sk_buff *skb)\r\n{\r\nstruct xfrm_mode *inner_mode = x->inner_mode;\r\nint err;\r\nerr = x->outer_mode->afinfo->extract_input(x, skb);\r\nif (err)\r\nreturn err;\r\nif (x->sel.family == AF_UNSPEC) {\r\ninner_mode = xfrm_ip2inner_mode(x, XFRM_MODE_SKB_CB(skb)->protocol);\r\nif (inner_mode == NULL)\r\nreturn -EAFNOSUPPORT;\r\n}\r\nskb->protocol = inner_mode->afinfo->eth_proto;\r\nreturn inner_mode->input2(x, skb);\r\n}\r\nint xfrm_input(struct sk_buff *skb, int nexthdr, __be32 spi, int encap_type)\r\n{\r\nstruct net *net = dev_net(skb->dev);\r\nint err;\r\n__be32 seq;\r\n__be32 seq_hi;\r\nstruct xfrm_state *x = NULL;\r\nxfrm_address_t *daddr;\r\nstruct xfrm_mode *inner_mode;\r\nu32 mark = skb->mark;\r\nunsigned int family;\r\nint decaps = 0;\r\nint async = 0;\r\nif (encap_type < 0) {\r\nasync = 1;\r\nx = xfrm_input_state(skb);\r\nseq = XFRM_SKB_CB(skb)->seq.input.low;\r\nfamily = x->outer_mode->afinfo->family;\r\ngoto resume;\r\n}\r\ndaddr = (xfrm_address_t *)(skb_network_header(skb) +\r\nXFRM_SPI_SKB_CB(skb)->daddroff);\r\nfamily = XFRM_SPI_SKB_CB(skb)->family;\r\nif (XFRM_TUNNEL_SKB_CB(skb)->tunnel.ip4) {\r\nswitch (family) {\r\ncase AF_INET:\r\nmark = be32_to_cpu(XFRM_TUNNEL_SKB_CB(skb)->tunnel.ip4->parms.i_key);\r\nbreak;\r\ncase AF_INET6:\r\nmark = be32_to_cpu(XFRM_TUNNEL_SKB_CB(skb)->tunnel.ip6->parms.i_key);\r\nbreak;\r\n}\r\n}\r\nif (!skb->sp || atomic_read(&skb->sp->refcnt) != 1) {\r\nstruct sec_path *sp;\r\nsp = secpath_dup(skb->sp);\r\nif (!sp) {\r\nXFRM_INC_STATS(net, LINUX_MIB_XFRMINERROR);\r\ngoto drop;\r\n}\r\nif (skb->sp)\r\nsecpath_put(skb->sp);\r\nskb->sp = sp;\r\n}\r\nseq = 0;\r\nif (!spi && (err = xfrm_parse_spi(skb, nexthdr, &spi, &seq)) != 0) {\r\nXFRM_INC_STATS(net, LINUX_MIB_XFRMINHDRERROR);\r\ngoto drop;\r\n}\r\ndo {\r\nif (skb->sp->len == XFRM_MAX_DEPTH) {\r\nXFRM_INC_STATS(net, LINUX_MIB_XFRMINBUFFERERROR);\r\ngoto drop;\r\n}\r\nx = xfrm_state_lookup(net, mark, daddr, spi, nexthdr, family);\r\nif (x == NULL) {\r\nXFRM_INC_STATS(net, LINUX_MIB_XFRMINNOSTATES);\r\nxfrm_audit_state_notfound(skb, family, spi, seq);\r\ngoto drop;\r\n}\r\nskb->sp->xvec[skb->sp->len++] = x;\r\nspin_lock(&x->lock);\r\nif (unlikely(x->km.state != XFRM_STATE_VALID)) {\r\nif (x->km.state == XFRM_STATE_ACQ)\r\nXFRM_INC_STATS(net, LINUX_MIB_XFRMACQUIREERROR);\r\nelse\r\nXFRM_INC_STATS(net,\r\nLINUX_MIB_XFRMINSTATEINVALID);\r\ngoto drop_unlock;\r\n}\r\nif ((x->encap ? x->encap->encap_type : 0) != encap_type) {\r\nXFRM_INC_STATS(net, LINUX_MIB_XFRMINSTATEMISMATCH);\r\ngoto drop_unlock;\r\n}\r\nif (x->repl->check(x, skb, seq)) {\r\nXFRM_INC_STATS(net, LINUX_MIB_XFRMINSTATESEQERROR);\r\ngoto drop_unlock;\r\n}\r\nif (xfrm_state_check_expire(x)) {\r\nXFRM_INC_STATS(net, LINUX_MIB_XFRMINSTATEEXPIRED);\r\ngoto drop_unlock;\r\n}\r\nspin_unlock(&x->lock);\r\nif (xfrm_tunnel_check(skb, x, family)) {\r\nXFRM_INC_STATS(net, LINUX_MIB_XFRMINSTATEMODEERROR);\r\ngoto drop;\r\n}\r\nseq_hi = htonl(xfrm_replay_seqhi(x, seq));\r\nXFRM_SKB_CB(skb)->seq.input.low = seq;\r\nXFRM_SKB_CB(skb)->seq.input.hi = seq_hi;\r\nskb_dst_force(skb);\r\nnexthdr = x->type->input(x, skb);\r\nif (nexthdr == -EINPROGRESS)\r\nreturn 0;\r\nresume:\r\nspin_lock(&x->lock);\r\nif (nexthdr <= 0) {\r\nif (nexthdr == -EBADMSG) {\r\nxfrm_audit_state_icvfail(x, skb,\r\nx->type->proto);\r\nx->stats.integrity_failed++;\r\n}\r\nXFRM_INC_STATS(net, LINUX_MIB_XFRMINSTATEPROTOERROR);\r\ngoto drop_unlock;\r\n}\r\nencap_type = 0;\r\nif (async && x->repl->recheck(x, skb, seq)) {\r\nXFRM_INC_STATS(net, LINUX_MIB_XFRMINSTATESEQERROR);\r\ngoto drop_unlock;\r\n}\r\nx->repl->advance(x, seq);\r\nx->curlft.bytes += skb->len;\r\nx->curlft.packets++;\r\nspin_unlock(&x->lock);\r\nXFRM_MODE_SKB_CB(skb)->protocol = nexthdr;\r\ninner_mode = x->inner_mode;\r\nif (x->sel.family == AF_UNSPEC) {\r\ninner_mode = xfrm_ip2inner_mode(x, XFRM_MODE_SKB_CB(skb)->protocol);\r\nif (inner_mode == NULL) {\r\nXFRM_INC_STATS(net, LINUX_MIB_XFRMINSTATEMODEERROR);\r\ngoto drop;\r\n}\r\n}\r\nif (inner_mode->input(x, skb)) {\r\nXFRM_INC_STATS(net, LINUX_MIB_XFRMINSTATEMODEERROR);\r\ngoto drop;\r\n}\r\nif (x->outer_mode->flags & XFRM_MODE_FLAG_TUNNEL) {\r\ndecaps = 1;\r\nbreak;\r\n}\r\ndaddr = &x->id.daddr;\r\nfamily = x->outer_mode->afinfo->family;\r\nerr = xfrm_parse_spi(skb, nexthdr, &spi, &seq);\r\nif (err < 0) {\r\nXFRM_INC_STATS(net, LINUX_MIB_XFRMINHDRERROR);\r\ngoto drop;\r\n}\r\n} while (!err);\r\nerr = xfrm_rcv_cb(skb, family, x->type->proto, 0);\r\nif (err)\r\ngoto drop;\r\nnf_reset(skb);\r\nif (decaps) {\r\nskb_dst_drop(skb);\r\nnetif_rx(skb);\r\nreturn 0;\r\n} else {\r\nreturn x->inner_mode->afinfo->transport_finish(skb, async);\r\n}\r\ndrop_unlock:\r\nspin_unlock(&x->lock);\r\ndrop:\r\nxfrm_rcv_cb(skb, family, x && x->type ? x->type->proto : nexthdr, -1);\r\nkfree_skb(skb);\r\nreturn 0;\r\n}\r\nint xfrm_input_resume(struct sk_buff *skb, int nexthdr)\r\n{\r\nreturn xfrm_input(skb, nexthdr, 0, -1);\r\n}\r\nvoid __init xfrm_input_init(void)\r\n{\r\nsecpath_cachep = kmem_cache_create("secpath_cache",\r\nsizeof(struct sec_path),\r\n0, SLAB_HWCACHE_ALIGN|SLAB_PANIC,\r\nNULL);\r\n}
