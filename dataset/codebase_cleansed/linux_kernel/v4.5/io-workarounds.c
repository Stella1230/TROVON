static struct iowa_bus *iowa_pci_find(unsigned long vaddr, unsigned long paddr)\r\n{\r\nint i, j;\r\nstruct resource *res;\r\nunsigned long vstart, vend;\r\nfor (i = 0; i < iowa_bus_count; i++) {\r\nstruct iowa_bus *bus = &iowa_busses[i];\r\nstruct pci_controller *phb = bus->phb;\r\nif (vaddr) {\r\nvstart = (unsigned long)phb->io_base_virt;\r\nvend = vstart + phb->pci_io_size - 1;\r\nif ((vaddr >= vstart) && (vaddr <= vend))\r\nreturn bus;\r\n}\r\nif (paddr)\r\nfor (j = 0; j < 3; j++) {\r\nres = &phb->mem_resources[j];\r\nif (paddr >= res->start && paddr <= res->end)\r\nreturn bus;\r\n}\r\n}\r\nreturn NULL;\r\n}\r\nstruct iowa_bus *iowa_mem_find_bus(const PCI_IO_ADDR addr)\r\n{\r\nunsigned hugepage_shift;\r\nstruct iowa_bus *bus;\r\nint token;\r\ntoken = PCI_GET_ADDR_TOKEN(addr);\r\nif (token && token <= iowa_bus_count)\r\nbus = &iowa_busses[token - 1];\r\nelse {\r\nunsigned long vaddr, paddr;\r\npte_t *ptep;\r\nvaddr = (unsigned long)PCI_FIX_ADDR(addr);\r\nif (vaddr < PHB_IO_BASE || vaddr >= PHB_IO_END)\r\nreturn NULL;\r\nptep = __find_linux_pte_or_hugepte(init_mm.pgd, vaddr,\r\nNULL, &hugepage_shift);\r\nif (ptep == NULL)\r\npaddr = 0;\r\nelse {\r\nWARN_ON(hugepage_shift);\r\npaddr = pte_pfn(*ptep) << PAGE_SHIFT;\r\n}\r\nbus = iowa_pci_find(vaddr, paddr);\r\nif (bus == NULL)\r\nreturn NULL;\r\n}\r\nreturn bus;\r\n}\r\nstruct iowa_bus *iowa_mem_find_bus(const PCI_IO_ADDR addr)\r\n{\r\nreturn NULL;\r\n}\r\nstruct iowa_bus *iowa_pio_find_bus(unsigned long port)\r\n{\r\nunsigned long vaddr = (unsigned long)pci_io_base + port;\r\nreturn iowa_pci_find(vaddr, 0);\r\n}\r\nstruct iowa_bus *iowa_pio_find_bus(unsigned long port)\r\n{\r\nreturn NULL;\r\n}\r\nstatic void __iomem *iowa_ioremap(phys_addr_t addr, unsigned long size,\r\nunsigned long flags, void *caller)\r\n{\r\nstruct iowa_bus *bus;\r\nvoid __iomem *res = __ioremap_caller(addr, size, flags, caller);\r\nint busno;\r\nbus = iowa_pci_find(0, (unsigned long)addr);\r\nif (bus != NULL) {\r\nbusno = bus - iowa_busses;\r\nPCI_SET_ADDR_TOKEN(res, busno + 1);\r\n}\r\nreturn res;\r\n}\r\nstatic void io_workaround_init(void)\r\n{\r\nstatic int io_workaround_inited;\r\nif (io_workaround_inited)\r\nreturn;\r\nppc_pci_io = iowa_pci_io;\r\nppc_md.ioremap = iowa_ioremap;\r\nio_workaround_inited = 1;\r\n}\r\nvoid iowa_register_bus(struct pci_controller *phb, struct ppc_pci_io *ops,\r\nint (*initfunc)(struct iowa_bus *, void *), void *data)\r\n{\r\nstruct iowa_bus *bus;\r\nstruct device_node *np = phb->dn;\r\nio_workaround_init();\r\nif (iowa_bus_count >= IOWA_MAX_BUS) {\r\npr_err("IOWA:Too many pci bridges, "\r\n"workarounds disabled for %s\n", np->full_name);\r\nreturn;\r\n}\r\nbus = &iowa_busses[iowa_bus_count];\r\nbus->phb = phb;\r\nbus->ops = ops;\r\nbus->private = data;\r\nif (initfunc)\r\nif ((*initfunc)(bus, data))\r\nreturn;\r\niowa_bus_count++;\r\npr_debug("IOWA:[%d]Add bus, %s.\n", iowa_bus_count-1, np->full_name);\r\n}
