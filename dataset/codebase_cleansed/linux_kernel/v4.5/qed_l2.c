static int qed_sp_vport_start(struct qed_hwfn *p_hwfn,\r\nu32 concrete_fid,\r\nu16 opaque_fid,\r\nu8 vport_id,\r\nu16 mtu,\r\nu8 drop_ttl0_flg,\r\nu8 inner_vlan_removal_en_flg)\r\n{\r\nstruct qed_sp_init_request_params params;\r\nstruct vport_start_ramrod_data *p_ramrod = NULL;\r\nstruct qed_spq_entry *p_ent = NULL;\r\nint rc = -EINVAL;\r\nu16 rx_mode = 0;\r\nu8 abs_vport_id = 0;\r\nrc = qed_fw_vport(p_hwfn, vport_id, &abs_vport_id);\r\nif (rc != 0)\r\nreturn rc;\r\nmemset(&params, 0, sizeof(params));\r\nparams.ramrod_data_size = sizeof(*p_ramrod);\r\nparams.comp_mode = QED_SPQ_MODE_EBLOCK;\r\nrc = qed_sp_init_request(p_hwfn, &p_ent,\r\nqed_spq_get_cid(p_hwfn),\r\nopaque_fid,\r\nETH_RAMROD_VPORT_START,\r\nPROTOCOLID_ETH,\r\n&params);\r\nif (rc)\r\nreturn rc;\r\np_ramrod = &p_ent->ramrod.vport_start;\r\np_ramrod->vport_id = abs_vport_id;\r\np_ramrod->mtu = cpu_to_le16(mtu);\r\np_ramrod->inner_vlan_removal_en = inner_vlan_removal_en_flg;\r\np_ramrod->drop_ttl0_en = drop_ttl0_flg;\r\nSET_FIELD(rx_mode, ETH_VPORT_RX_MODE_UCAST_DROP_ALL, 1);\r\nSET_FIELD(rx_mode, ETH_VPORT_RX_MODE_MCAST_DROP_ALL, 1);\r\np_ramrod->rx_mode.state = cpu_to_le16(rx_mode);\r\nmemset(&p_ramrod->tpa_param, 0,\r\nsizeof(struct eth_vport_tpa_param));\r\np_ramrod->sw_fid = qed_concrete_to_sw_fid(p_hwfn->cdev,\r\nconcrete_fid);\r\nreturn qed_spq_post(p_hwfn, p_ent, NULL);\r\n}\r\nstatic int\r\nqed_sp_vport_update_rss(struct qed_hwfn *p_hwfn,\r\nstruct vport_update_ramrod_data *p_ramrod,\r\nstruct qed_rss_params *p_params)\r\n{\r\nstruct eth_vport_rss_config *rss = &p_ramrod->rss_config;\r\nu16 abs_l2_queue = 0, capabilities = 0;\r\nint rc = 0, i;\r\nif (!p_params) {\r\np_ramrod->common.update_rss_flg = 0;\r\nreturn rc;\r\n}\r\nBUILD_BUG_ON(QED_RSS_IND_TABLE_SIZE !=\r\nETH_RSS_IND_TABLE_ENTRIES_NUM);\r\nrc = qed_fw_rss_eng(p_hwfn, p_params->rss_eng_id, &rss->rss_id);\r\nif (rc)\r\nreturn rc;\r\np_ramrod->common.update_rss_flg = p_params->update_rss_config;\r\nrss->update_rss_capabilities = p_params->update_rss_capabilities;\r\nrss->update_rss_ind_table = p_params->update_rss_ind_table;\r\nrss->update_rss_key = p_params->update_rss_key;\r\nrss->rss_mode = p_params->rss_enable ?\r\nETH_VPORT_RSS_MODE_REGULAR :\r\nETH_VPORT_RSS_MODE_DISABLED;\r\nSET_FIELD(capabilities,\r\nETH_VPORT_RSS_CONFIG_IPV4_CAPABILITY,\r\n!!(p_params->rss_caps & QED_RSS_IPV4));\r\nSET_FIELD(capabilities,\r\nETH_VPORT_RSS_CONFIG_IPV6_CAPABILITY,\r\n!!(p_params->rss_caps & QED_RSS_IPV6));\r\nSET_FIELD(capabilities,\r\nETH_VPORT_RSS_CONFIG_IPV4_TCP_CAPABILITY,\r\n!!(p_params->rss_caps & QED_RSS_IPV4_TCP));\r\nSET_FIELD(capabilities,\r\nETH_VPORT_RSS_CONFIG_IPV6_TCP_CAPABILITY,\r\n!!(p_params->rss_caps & QED_RSS_IPV6_TCP));\r\nSET_FIELD(capabilities,\r\nETH_VPORT_RSS_CONFIG_IPV4_UDP_CAPABILITY,\r\n!!(p_params->rss_caps & QED_RSS_IPV4_UDP));\r\nSET_FIELD(capabilities,\r\nETH_VPORT_RSS_CONFIG_IPV6_UDP_CAPABILITY,\r\n!!(p_params->rss_caps & QED_RSS_IPV6_UDP));\r\nrss->tbl_size = p_params->rss_table_size_log;\r\nrss->capabilities = cpu_to_le16(capabilities);\r\nDP_VERBOSE(p_hwfn, NETIF_MSG_IFUP,\r\n"update rss flag %d, rss_mode = %d, update_caps = %d, capabilities = %d, update_ind = %d, update_rss_key = %d\n",\r\np_ramrod->common.update_rss_flg,\r\nrss->rss_mode, rss->update_rss_capabilities,\r\ncapabilities, rss->update_rss_ind_table,\r\nrss->update_rss_key);\r\nfor (i = 0; i < QED_RSS_IND_TABLE_SIZE; i++) {\r\nrc = qed_fw_l2_queue(p_hwfn,\r\n(u8)p_params->rss_ind_table[i],\r\n&abs_l2_queue);\r\nif (rc)\r\nreturn rc;\r\nrss->indirection_table[i] = cpu_to_le16(abs_l2_queue);\r\nDP_VERBOSE(p_hwfn, NETIF_MSG_IFUP, "i= %d, queue = %d\n",\r\ni, rss->indirection_table[i]);\r\n}\r\nfor (i = 0; i < 10; i++)\r\nrss->rss_key[i] = cpu_to_le32(p_params->rss_key[i]);\r\nreturn rc;\r\n}\r\nstatic void\r\nqed_sp_update_accept_mode(struct qed_hwfn *p_hwfn,\r\nstruct vport_update_ramrod_data *p_ramrod,\r\nstruct qed_filter_accept_flags accept_flags)\r\n{\r\np_ramrod->common.update_rx_mode_flg =\r\naccept_flags.update_rx_mode_config;\r\np_ramrod->common.update_tx_mode_flg =\r\naccept_flags.update_tx_mode_config;\r\nif (p_ramrod->common.update_rx_mode_flg) {\r\nu8 accept_filter = accept_flags.rx_accept_filter;\r\nu16 state = 0;\r\nSET_FIELD(state, ETH_VPORT_RX_MODE_UCAST_DROP_ALL,\r\n!(!!(accept_filter & QED_ACCEPT_UCAST_MATCHED) ||\r\n!!(accept_filter & QED_ACCEPT_UCAST_UNMATCHED)));\r\nSET_FIELD(state, ETH_VPORT_RX_MODE_UCAST_ACCEPT_UNMATCHED,\r\n!!(accept_filter & QED_ACCEPT_UCAST_UNMATCHED));\r\nSET_FIELD(state, ETH_VPORT_RX_MODE_MCAST_DROP_ALL,\r\n!(!!(accept_filter & QED_ACCEPT_MCAST_MATCHED) ||\r\n!!(accept_filter & QED_ACCEPT_MCAST_UNMATCHED)));\r\nSET_FIELD(state, ETH_VPORT_RX_MODE_MCAST_ACCEPT_ALL,\r\n(!!(accept_filter & QED_ACCEPT_MCAST_MATCHED) &&\r\n!!(accept_filter & QED_ACCEPT_MCAST_UNMATCHED)));\r\nSET_FIELD(state, ETH_VPORT_RX_MODE_BCAST_ACCEPT_ALL,\r\n!!(accept_filter & QED_ACCEPT_BCAST));\r\np_ramrod->rx_mode.state = cpu_to_le16(state);\r\nDP_VERBOSE(p_hwfn, QED_MSG_SP,\r\n"p_ramrod->rx_mode.state = 0x%x\n", state);\r\n}\r\nif (p_ramrod->common.update_tx_mode_flg) {\r\nu8 accept_filter = accept_flags.tx_accept_filter;\r\nu16 state = 0;\r\nSET_FIELD(state, ETH_VPORT_TX_MODE_UCAST_DROP_ALL,\r\n!!(accept_filter & QED_ACCEPT_NONE));\r\nSET_FIELD(state, ETH_VPORT_TX_MODE_UCAST_ACCEPT_ALL,\r\n(!!(accept_filter & QED_ACCEPT_UCAST_MATCHED) &&\r\n!!(accept_filter & QED_ACCEPT_UCAST_UNMATCHED)));\r\nSET_FIELD(state, ETH_VPORT_TX_MODE_MCAST_DROP_ALL,\r\n!!(accept_filter & QED_ACCEPT_NONE));\r\nSET_FIELD(state, ETH_VPORT_TX_MODE_MCAST_ACCEPT_ALL,\r\n(!!(accept_filter & QED_ACCEPT_MCAST_MATCHED) &&\r\n!!(accept_filter & QED_ACCEPT_MCAST_UNMATCHED)));\r\nSET_FIELD(state, ETH_VPORT_TX_MODE_BCAST_ACCEPT_ALL,\r\n!!(accept_filter & QED_ACCEPT_BCAST));\r\np_ramrod->tx_mode.state = cpu_to_le16(state);\r\nDP_VERBOSE(p_hwfn, QED_MSG_SP,\r\n"p_ramrod->tx_mode.state = 0x%x\n", state);\r\n}\r\n}\r\nstatic void\r\nqed_sp_update_mcast_bin(struct qed_hwfn *p_hwfn,\r\nstruct vport_update_ramrod_data *p_ramrod,\r\nstruct qed_sp_vport_update_params *p_params)\r\n{\r\nint i;\r\nmemset(&p_ramrod->approx_mcast.bins, 0,\r\nsizeof(p_ramrod->approx_mcast.bins));\r\nif (p_params->update_approx_mcast_flg) {\r\np_ramrod->common.update_approx_mcast_flg = 1;\r\nfor (i = 0; i < ETH_MULTICAST_MAC_BINS_IN_REGS; i++) {\r\nu32 *p_bins = (u32 *)p_params->bins;\r\n__le32 val = cpu_to_le32(p_bins[i]);\r\np_ramrod->approx_mcast.bins[i] = val;\r\n}\r\n}\r\n}\r\nstatic int\r\nqed_sp_vport_update(struct qed_hwfn *p_hwfn,\r\nstruct qed_sp_vport_update_params *p_params,\r\nenum spq_mode comp_mode,\r\nstruct qed_spq_comp_cb *p_comp_data)\r\n{\r\nstruct qed_rss_params *p_rss_params = p_params->rss_params;\r\nstruct vport_update_ramrod_data_cmn *p_cmn;\r\nstruct qed_sp_init_request_params sp_params;\r\nstruct vport_update_ramrod_data *p_ramrod = NULL;\r\nstruct qed_spq_entry *p_ent = NULL;\r\nu8 abs_vport_id = 0;\r\nint rc = -EINVAL;\r\nrc = qed_fw_vport(p_hwfn, p_params->vport_id, &abs_vport_id);\r\nif (rc != 0)\r\nreturn rc;\r\nmemset(&sp_params, 0, sizeof(sp_params));\r\nsp_params.ramrod_data_size = sizeof(*p_ramrod);\r\nsp_params.comp_mode = comp_mode;\r\nsp_params.p_comp_data = p_comp_data;\r\nrc = qed_sp_init_request(p_hwfn, &p_ent,\r\nqed_spq_get_cid(p_hwfn),\r\np_params->opaque_fid,\r\nETH_RAMROD_VPORT_UPDATE,\r\nPROTOCOLID_ETH,\r\n&sp_params);\r\nif (rc)\r\nreturn rc;\r\np_ramrod = &p_ent->ramrod.vport_update;\r\np_cmn = &p_ramrod->common;\r\np_cmn->vport_id = abs_vport_id;\r\np_cmn->rx_active_flg = p_params->vport_active_rx_flg;\r\np_cmn->update_rx_active_flg = p_params->update_vport_active_rx_flg;\r\np_cmn->tx_active_flg = p_params->vport_active_tx_flg;\r\np_cmn->update_tx_active_flg = p_params->update_vport_active_tx_flg;\r\nrc = qed_sp_vport_update_rss(p_hwfn, p_ramrod, p_rss_params);\r\nif (rc) {\r\nqed_spq_return_entry(p_hwfn, p_ent);\r\nreturn rc;\r\n}\r\nqed_sp_update_mcast_bin(p_hwfn, p_ramrod, p_params);\r\nqed_sp_update_accept_mode(p_hwfn, p_ramrod, p_params->accept_flags);\r\nreturn qed_spq_post(p_hwfn, p_ent, NULL);\r\n}\r\nstatic int qed_sp_vport_stop(struct qed_hwfn *p_hwfn,\r\nu16 opaque_fid,\r\nu8 vport_id)\r\n{\r\nstruct qed_sp_init_request_params sp_params;\r\nstruct vport_stop_ramrod_data *p_ramrod;\r\nstruct qed_spq_entry *p_ent;\r\nu8 abs_vport_id = 0;\r\nint rc;\r\nrc = qed_fw_vport(p_hwfn, vport_id, &abs_vport_id);\r\nif (rc != 0)\r\nreturn rc;\r\nmemset(&sp_params, 0, sizeof(sp_params));\r\nsp_params.ramrod_data_size = sizeof(*p_ramrod);\r\nsp_params.comp_mode = QED_SPQ_MODE_EBLOCK;\r\nrc = qed_sp_init_request(p_hwfn, &p_ent,\r\nqed_spq_get_cid(p_hwfn),\r\nopaque_fid,\r\nETH_RAMROD_VPORT_STOP,\r\nPROTOCOLID_ETH,\r\n&sp_params);\r\nif (rc)\r\nreturn rc;\r\np_ramrod = &p_ent->ramrod.vport_stop;\r\np_ramrod->vport_id = abs_vport_id;\r\nreturn qed_spq_post(p_hwfn, p_ent, NULL);\r\n}\r\nstatic int qed_filter_accept_cmd(struct qed_dev *cdev,\r\nu8 vport,\r\nstruct qed_filter_accept_flags accept_flags,\r\nenum spq_mode comp_mode,\r\nstruct qed_spq_comp_cb *p_comp_data)\r\n{\r\nstruct qed_sp_vport_update_params vport_update_params;\r\nint i, rc;\r\nmemset(&vport_update_params, 0, sizeof(vport_update_params));\r\nvport_update_params.vport_id = vport;\r\nvport_update_params.accept_flags = accept_flags;\r\nfor_each_hwfn(cdev, i) {\r\nstruct qed_hwfn *p_hwfn = &cdev->hwfns[i];\r\nvport_update_params.opaque_fid = p_hwfn->hw_info.opaque_fid;\r\nrc = qed_sp_vport_update(p_hwfn, &vport_update_params,\r\ncomp_mode, p_comp_data);\r\nif (rc != 0) {\r\nDP_ERR(cdev, "Update rx_mode failed %d\n", rc);\r\nreturn rc;\r\n}\r\nDP_VERBOSE(p_hwfn, QED_MSG_SP,\r\n"Accept filter configured, flags = [Rx]%x [Tx]%x\n",\r\naccept_flags.rx_accept_filter,\r\naccept_flags.tx_accept_filter);\r\n}\r\nreturn 0;\r\n}\r\nstatic int qed_sp_release_queue_cid(\r\nstruct qed_hwfn *p_hwfn,\r\nstruct qed_hw_cid_data *p_cid_data)\r\n{\r\nif (!p_cid_data->b_cid_allocated)\r\nreturn 0;\r\nqed_cxt_release_cid(p_hwfn, p_cid_data->cid);\r\np_cid_data->b_cid_allocated = false;\r\nreturn 0;\r\n}\r\nstatic int\r\nqed_sp_eth_rxq_start_ramrod(struct qed_hwfn *p_hwfn,\r\nu16 opaque_fid,\r\nu32 cid,\r\nstruct qed_queue_start_common_params *params,\r\nu8 stats_id,\r\nu16 bd_max_bytes,\r\ndma_addr_t bd_chain_phys_addr,\r\ndma_addr_t cqe_pbl_addr,\r\nu16 cqe_pbl_size)\r\n{\r\nstruct rx_queue_start_ramrod_data *p_ramrod = NULL;\r\nstruct qed_sp_init_request_params sp_params;\r\nstruct qed_spq_entry *p_ent = NULL;\r\nstruct qed_hw_cid_data *p_rx_cid;\r\nu16 abs_rx_q_id = 0;\r\nu8 abs_vport_id = 0;\r\nint rc = -EINVAL;\r\np_rx_cid = &p_hwfn->p_rx_cids[params->queue_id];\r\np_rx_cid->cid = cid;\r\np_rx_cid->opaque_fid = opaque_fid;\r\np_rx_cid->vport_id = params->vport_id;\r\nrc = qed_fw_vport(p_hwfn, params->vport_id, &abs_vport_id);\r\nif (rc != 0)\r\nreturn rc;\r\nrc = qed_fw_l2_queue(p_hwfn, params->queue_id, &abs_rx_q_id);\r\nif (rc != 0)\r\nreturn rc;\r\nDP_VERBOSE(p_hwfn, QED_MSG_SP,\r\n"opaque_fid=0x%x, cid=0x%x, rx_qid=0x%x, vport_id=0x%x, sb_id=0x%x\n",\r\nopaque_fid, cid, params->queue_id, params->vport_id,\r\nparams->sb);\r\nmemset(&sp_params, 0, sizeof(params));\r\nsp_params.comp_mode = QED_SPQ_MODE_EBLOCK;\r\nsp_params.ramrod_data_size = sizeof(*p_ramrod);\r\nrc = qed_sp_init_request(p_hwfn, &p_ent,\r\ncid, opaque_fid,\r\nETH_RAMROD_RX_QUEUE_START,\r\nPROTOCOLID_ETH,\r\n&sp_params);\r\nif (rc)\r\nreturn rc;\r\np_ramrod = &p_ent->ramrod.rx_queue_start;\r\np_ramrod->sb_id = cpu_to_le16(params->sb);\r\np_ramrod->sb_index = params->sb_idx;\r\np_ramrod->vport_id = abs_vport_id;\r\np_ramrod->stats_counter_id = stats_id;\r\np_ramrod->rx_queue_id = cpu_to_le16(abs_rx_q_id);\r\np_ramrod->complete_cqe_flg = 0;\r\np_ramrod->complete_event_flg = 1;\r\np_ramrod->bd_max_bytes = cpu_to_le16(bd_max_bytes);\r\np_ramrod->bd_base.hi = DMA_HI_LE(bd_chain_phys_addr);\r\np_ramrod->bd_base.lo = DMA_LO_LE(bd_chain_phys_addr);\r\np_ramrod->num_of_pbl_pages = cpu_to_le16(cqe_pbl_size);\r\np_ramrod->cqe_pbl_addr.hi = DMA_HI_LE(cqe_pbl_addr);\r\np_ramrod->cqe_pbl_addr.lo = DMA_LO_LE(cqe_pbl_addr);\r\nrc = qed_spq_post(p_hwfn, p_ent, NULL);\r\nreturn rc;\r\n}\r\nstatic int\r\nqed_sp_eth_rx_queue_start(struct qed_hwfn *p_hwfn,\r\nu16 opaque_fid,\r\nstruct qed_queue_start_common_params *params,\r\nu16 bd_max_bytes,\r\ndma_addr_t bd_chain_phys_addr,\r\ndma_addr_t cqe_pbl_addr,\r\nu16 cqe_pbl_size,\r\nvoid __iomem **pp_prod)\r\n{\r\nstruct qed_hw_cid_data *p_rx_cid;\r\nu64 init_prod_val = 0;\r\nu16 abs_l2_queue = 0;\r\nu8 abs_stats_id = 0;\r\nint rc;\r\nrc = qed_fw_l2_queue(p_hwfn, params->queue_id, &abs_l2_queue);\r\nif (rc != 0)\r\nreturn rc;\r\nrc = qed_fw_vport(p_hwfn, params->vport_id, &abs_stats_id);\r\nif (rc != 0)\r\nreturn rc;\r\n*pp_prod = (u8 __iomem *)p_hwfn->regview +\r\nGTT_BAR0_MAP_REG_MSDM_RAM +\r\nMSTORM_PRODS_OFFSET(abs_l2_queue);\r\n__internal_ram_wr(p_hwfn, *pp_prod, sizeof(u64),\r\n(u32 *)(&init_prod_val));\r\np_rx_cid = &p_hwfn->p_rx_cids[params->queue_id];\r\nrc = qed_cxt_acquire_cid(p_hwfn, PROTOCOLID_ETH,\r\n&p_rx_cid->cid);\r\nif (rc) {\r\nDP_NOTICE(p_hwfn, "Failed to acquire cid\n");\r\nreturn rc;\r\n}\r\np_rx_cid->b_cid_allocated = true;\r\nrc = qed_sp_eth_rxq_start_ramrod(p_hwfn,\r\nopaque_fid,\r\np_rx_cid->cid,\r\nparams,\r\nabs_stats_id,\r\nbd_max_bytes,\r\nbd_chain_phys_addr,\r\ncqe_pbl_addr,\r\ncqe_pbl_size);\r\nif (rc != 0)\r\nqed_sp_release_queue_cid(p_hwfn, p_rx_cid);\r\nreturn rc;\r\n}\r\nstatic int qed_sp_eth_rx_queue_stop(struct qed_hwfn *p_hwfn,\r\nu16 rx_queue_id,\r\nbool eq_completion_only,\r\nbool cqe_completion)\r\n{\r\nstruct qed_hw_cid_data *p_rx_cid = &p_hwfn->p_rx_cids[rx_queue_id];\r\nstruct rx_queue_stop_ramrod_data *p_ramrod = NULL;\r\nstruct qed_sp_init_request_params sp_params;\r\nstruct qed_spq_entry *p_ent = NULL;\r\nu16 abs_rx_q_id = 0;\r\nint rc = -EINVAL;\r\nmemset(&sp_params, 0, sizeof(sp_params));\r\nsp_params.ramrod_data_size = sizeof(*p_ramrod);\r\nsp_params.comp_mode = QED_SPQ_MODE_EBLOCK;\r\nrc = qed_sp_init_request(p_hwfn, &p_ent,\r\np_rx_cid->cid,\r\np_rx_cid->opaque_fid,\r\nETH_RAMROD_RX_QUEUE_STOP,\r\nPROTOCOLID_ETH,\r\n&sp_params);\r\nif (rc)\r\nreturn rc;\r\np_ramrod = &p_ent->ramrod.rx_queue_stop;\r\nqed_fw_vport(p_hwfn, p_rx_cid->vport_id, &p_ramrod->vport_id);\r\nqed_fw_l2_queue(p_hwfn, rx_queue_id, &abs_rx_q_id);\r\np_ramrod->rx_queue_id = cpu_to_le16(abs_rx_q_id);\r\np_ramrod->complete_cqe_flg =\r\n(!!(p_rx_cid->opaque_fid == p_hwfn->hw_info.opaque_fid) &&\r\n!eq_completion_only) || cqe_completion;\r\np_ramrod->complete_event_flg =\r\n!(p_rx_cid->opaque_fid == p_hwfn->hw_info.opaque_fid) ||\r\neq_completion_only;\r\nrc = qed_spq_post(p_hwfn, p_ent, NULL);\r\nif (rc)\r\nreturn rc;\r\nreturn qed_sp_release_queue_cid(p_hwfn, p_rx_cid);\r\n}\r\nstatic int\r\nqed_sp_eth_txq_start_ramrod(struct qed_hwfn *p_hwfn,\r\nu16 opaque_fid,\r\nu32 cid,\r\nstruct qed_queue_start_common_params *p_params,\r\nu8 stats_id,\r\ndma_addr_t pbl_addr,\r\nu16 pbl_size,\r\nunion qed_qm_pq_params *p_pq_params)\r\n{\r\nstruct tx_queue_start_ramrod_data *p_ramrod = NULL;\r\nstruct qed_sp_init_request_params sp_params;\r\nstruct qed_spq_entry *p_ent = NULL;\r\nstruct qed_hw_cid_data *p_tx_cid;\r\nu8 abs_vport_id;\r\nint rc = -EINVAL;\r\nu16 pq_id;\r\np_tx_cid = &p_hwfn->p_tx_cids[p_params->queue_id];\r\np_tx_cid->cid = cid;\r\np_tx_cid->opaque_fid = opaque_fid;\r\nrc = qed_fw_vport(p_hwfn, p_params->vport_id, &abs_vport_id);\r\nif (rc)\r\nreturn rc;\r\nmemset(&sp_params, 0, sizeof(sp_params));\r\nsp_params.ramrod_data_size = sizeof(*p_ramrod);\r\nsp_params.comp_mode = QED_SPQ_MODE_EBLOCK;\r\nrc = qed_sp_init_request(p_hwfn, &p_ent, cid,\r\nopaque_fid,\r\nETH_RAMROD_TX_QUEUE_START,\r\nPROTOCOLID_ETH,\r\n&sp_params);\r\nif (rc)\r\nreturn rc;\r\np_ramrod = &p_ent->ramrod.tx_queue_start;\r\np_ramrod->vport_id = abs_vport_id;\r\np_ramrod->sb_id = cpu_to_le16(p_params->sb);\r\np_ramrod->sb_index = p_params->sb_idx;\r\np_ramrod->stats_counter_id = stats_id;\r\np_ramrod->tc = p_pq_params->eth.tc;\r\np_ramrod->pbl_size = cpu_to_le16(pbl_size);\r\np_ramrod->pbl_base_addr.hi = DMA_HI_LE(pbl_addr);\r\np_ramrod->pbl_base_addr.lo = DMA_LO_LE(pbl_addr);\r\npq_id = qed_get_qm_pq(p_hwfn,\r\nPROTOCOLID_ETH,\r\np_pq_params);\r\np_ramrod->qm_pq_id = cpu_to_le16(pq_id);\r\nreturn qed_spq_post(p_hwfn, p_ent, NULL);\r\n}\r\nstatic int\r\nqed_sp_eth_tx_queue_start(struct qed_hwfn *p_hwfn,\r\nu16 opaque_fid,\r\nstruct qed_queue_start_common_params *p_params,\r\ndma_addr_t pbl_addr,\r\nu16 pbl_size,\r\nvoid __iomem **pp_doorbell)\r\n{\r\nstruct qed_hw_cid_data *p_tx_cid;\r\nunion qed_qm_pq_params pq_params;\r\nu8 abs_stats_id = 0;\r\nint rc;\r\nrc = qed_fw_vport(p_hwfn, p_params->vport_id, &abs_stats_id);\r\nif (rc)\r\nreturn rc;\r\np_tx_cid = &p_hwfn->p_tx_cids[p_params->queue_id];\r\nmemset(p_tx_cid, 0, sizeof(*p_tx_cid));\r\nmemset(&pq_params, 0, sizeof(pq_params));\r\nrc = qed_cxt_acquire_cid(p_hwfn, PROTOCOLID_ETH,\r\n&p_tx_cid->cid);\r\nif (rc) {\r\nDP_NOTICE(p_hwfn, "Failed to acquire cid\n");\r\nreturn rc;\r\n}\r\np_tx_cid->b_cid_allocated = true;\r\nDP_VERBOSE(p_hwfn, QED_MSG_SP,\r\n"opaque_fid=0x%x, cid=0x%x, tx_qid=0x%x, vport_id=0x%x, sb_id=0x%x\n",\r\nopaque_fid, p_tx_cid->cid,\r\np_params->queue_id, p_params->vport_id, p_params->sb);\r\nrc = qed_sp_eth_txq_start_ramrod(p_hwfn,\r\nopaque_fid,\r\np_tx_cid->cid,\r\np_params,\r\nabs_stats_id,\r\npbl_addr,\r\npbl_size,\r\n&pq_params);\r\n*pp_doorbell = (u8 __iomem *)p_hwfn->doorbells +\r\nqed_db_addr(p_tx_cid->cid, DQ_DEMS_LEGACY);\r\nif (rc)\r\nqed_sp_release_queue_cid(p_hwfn, p_tx_cid);\r\nreturn rc;\r\n}\r\nstatic int qed_sp_eth_tx_queue_stop(struct qed_hwfn *p_hwfn,\r\nu16 tx_queue_id)\r\n{\r\nstruct qed_hw_cid_data *p_tx_cid = &p_hwfn->p_tx_cids[tx_queue_id];\r\nstruct qed_sp_init_request_params sp_params;\r\nstruct qed_spq_entry *p_ent = NULL;\r\nint rc = -EINVAL;\r\nmemset(&sp_params, 0, sizeof(sp_params));\r\nsp_params.ramrod_data_size = sizeof(struct tx_queue_stop_ramrod_data);\r\nsp_params.comp_mode = QED_SPQ_MODE_EBLOCK;\r\nrc = qed_sp_init_request(p_hwfn, &p_ent,\r\np_tx_cid->cid,\r\np_tx_cid->opaque_fid,\r\nETH_RAMROD_TX_QUEUE_STOP,\r\nPROTOCOLID_ETH,\r\n&sp_params);\r\nif (rc)\r\nreturn rc;\r\nrc = qed_spq_post(p_hwfn, p_ent, NULL);\r\nif (rc)\r\nreturn rc;\r\nreturn qed_sp_release_queue_cid(p_hwfn, p_tx_cid);\r\n}\r\nstatic enum eth_filter_action\r\nqed_filter_action(enum qed_filter_opcode opcode)\r\n{\r\nenum eth_filter_action action = MAX_ETH_FILTER_ACTION;\r\nswitch (opcode) {\r\ncase QED_FILTER_ADD:\r\naction = ETH_FILTER_ACTION_ADD;\r\nbreak;\r\ncase QED_FILTER_REMOVE:\r\naction = ETH_FILTER_ACTION_REMOVE;\r\nbreak;\r\ncase QED_FILTER_REPLACE:\r\ncase QED_FILTER_FLUSH:\r\naction = ETH_FILTER_ACTION_REPLACE;\r\nbreak;\r\ndefault:\r\naction = MAX_ETH_FILTER_ACTION;\r\n}\r\nreturn action;\r\n}\r\nstatic void qed_set_fw_mac_addr(__le16 *fw_msb,\r\n__le16 *fw_mid,\r\n__le16 *fw_lsb,\r\nu8 *mac)\r\n{\r\n((u8 *)fw_msb)[0] = mac[1];\r\n((u8 *)fw_msb)[1] = mac[0];\r\n((u8 *)fw_mid)[0] = mac[3];\r\n((u8 *)fw_mid)[1] = mac[2];\r\n((u8 *)fw_lsb)[0] = mac[5];\r\n((u8 *)fw_lsb)[1] = mac[4];\r\n}\r\nstatic int\r\nqed_filter_ucast_common(struct qed_hwfn *p_hwfn,\r\nu16 opaque_fid,\r\nstruct qed_filter_ucast *p_filter_cmd,\r\nstruct vport_filter_update_ramrod_data **pp_ramrod,\r\nstruct qed_spq_entry **pp_ent,\r\nenum spq_mode comp_mode,\r\nstruct qed_spq_comp_cb *p_comp_data)\r\n{\r\nu8 vport_to_add_to = 0, vport_to_remove_from = 0;\r\nstruct vport_filter_update_ramrod_data *p_ramrod;\r\nstruct qed_sp_init_request_params sp_params;\r\nstruct eth_filter_cmd *p_first_filter;\r\nstruct eth_filter_cmd *p_second_filter;\r\nenum eth_filter_action action;\r\nint rc;\r\nrc = qed_fw_vport(p_hwfn, p_filter_cmd->vport_to_remove_from,\r\n&vport_to_remove_from);\r\nif (rc)\r\nreturn rc;\r\nrc = qed_fw_vport(p_hwfn, p_filter_cmd->vport_to_add_to,\r\n&vport_to_add_to);\r\nif (rc)\r\nreturn rc;\r\nmemset(&sp_params, 0, sizeof(sp_params));\r\nsp_params.ramrod_data_size = sizeof(**pp_ramrod);\r\nsp_params.comp_mode = comp_mode;\r\nsp_params.p_comp_data = p_comp_data;\r\nrc = qed_sp_init_request(p_hwfn, pp_ent,\r\nqed_spq_get_cid(p_hwfn),\r\nopaque_fid,\r\nETH_RAMROD_FILTERS_UPDATE,\r\nPROTOCOLID_ETH,\r\n&sp_params);\r\nif (rc)\r\nreturn rc;\r\n*pp_ramrod = &(*pp_ent)->ramrod.vport_filter_update;\r\np_ramrod = *pp_ramrod;\r\np_ramrod->filter_cmd_hdr.rx = p_filter_cmd->is_rx_filter ? 1 : 0;\r\np_ramrod->filter_cmd_hdr.tx = p_filter_cmd->is_tx_filter ? 1 : 0;\r\nswitch (p_filter_cmd->opcode) {\r\ncase QED_FILTER_FLUSH:\r\np_ramrod->filter_cmd_hdr.cmd_cnt = 0; break;\r\ncase QED_FILTER_MOVE:\r\np_ramrod->filter_cmd_hdr.cmd_cnt = 2; break;\r\ndefault:\r\np_ramrod->filter_cmd_hdr.cmd_cnt = 1; break;\r\n}\r\np_first_filter = &p_ramrod->filter_cmds[0];\r\np_second_filter = &p_ramrod->filter_cmds[1];\r\nswitch (p_filter_cmd->type) {\r\ncase QED_FILTER_MAC:\r\np_first_filter->type = ETH_FILTER_TYPE_MAC; break;\r\ncase QED_FILTER_VLAN:\r\np_first_filter->type = ETH_FILTER_TYPE_VLAN; break;\r\ncase QED_FILTER_MAC_VLAN:\r\np_first_filter->type = ETH_FILTER_TYPE_PAIR; break;\r\ncase QED_FILTER_INNER_MAC:\r\np_first_filter->type = ETH_FILTER_TYPE_INNER_MAC; break;\r\ncase QED_FILTER_INNER_VLAN:\r\np_first_filter->type = ETH_FILTER_TYPE_INNER_VLAN; break;\r\ncase QED_FILTER_INNER_PAIR:\r\np_first_filter->type = ETH_FILTER_TYPE_INNER_PAIR; break;\r\ncase QED_FILTER_INNER_MAC_VNI_PAIR:\r\np_first_filter->type = ETH_FILTER_TYPE_INNER_MAC_VNI_PAIR;\r\nbreak;\r\ncase QED_FILTER_MAC_VNI_PAIR:\r\np_first_filter->type = ETH_FILTER_TYPE_MAC_VNI_PAIR; break;\r\ncase QED_FILTER_VNI:\r\np_first_filter->type = ETH_FILTER_TYPE_VNI; break;\r\n}\r\nif ((p_first_filter->type == ETH_FILTER_TYPE_MAC) ||\r\n(p_first_filter->type == ETH_FILTER_TYPE_PAIR) ||\r\n(p_first_filter->type == ETH_FILTER_TYPE_INNER_MAC) ||\r\n(p_first_filter->type == ETH_FILTER_TYPE_INNER_PAIR) ||\r\n(p_first_filter->type == ETH_FILTER_TYPE_INNER_MAC_VNI_PAIR) ||\r\n(p_first_filter->type == ETH_FILTER_TYPE_MAC_VNI_PAIR)) {\r\nqed_set_fw_mac_addr(&p_first_filter->mac_msb,\r\n&p_first_filter->mac_mid,\r\n&p_first_filter->mac_lsb,\r\n(u8 *)p_filter_cmd->mac);\r\n}\r\nif ((p_first_filter->type == ETH_FILTER_TYPE_VLAN) ||\r\n(p_first_filter->type == ETH_FILTER_TYPE_PAIR) ||\r\n(p_first_filter->type == ETH_FILTER_TYPE_INNER_VLAN) ||\r\n(p_first_filter->type == ETH_FILTER_TYPE_INNER_PAIR))\r\np_first_filter->vlan_id = cpu_to_le16(p_filter_cmd->vlan);\r\nif ((p_first_filter->type == ETH_FILTER_TYPE_INNER_MAC_VNI_PAIR) ||\r\n(p_first_filter->type == ETH_FILTER_TYPE_MAC_VNI_PAIR) ||\r\n(p_first_filter->type == ETH_FILTER_TYPE_VNI))\r\np_first_filter->vni = cpu_to_le32(p_filter_cmd->vni);\r\nif (p_filter_cmd->opcode == QED_FILTER_MOVE) {\r\np_second_filter->type = p_first_filter->type;\r\np_second_filter->mac_msb = p_first_filter->mac_msb;\r\np_second_filter->mac_mid = p_first_filter->mac_mid;\r\np_second_filter->mac_lsb = p_first_filter->mac_lsb;\r\np_second_filter->vlan_id = p_first_filter->vlan_id;\r\np_second_filter->vni = p_first_filter->vni;\r\np_first_filter->action = ETH_FILTER_ACTION_REMOVE;\r\np_first_filter->vport_id = vport_to_remove_from;\r\np_second_filter->action = ETH_FILTER_ACTION_ADD;\r\np_second_filter->vport_id = vport_to_add_to;\r\n} else {\r\naction = qed_filter_action(p_filter_cmd->opcode);\r\nif (action == MAX_ETH_FILTER_ACTION) {\r\nDP_NOTICE(p_hwfn,\r\n"%d is not supported yet\n",\r\np_filter_cmd->opcode);\r\nreturn -EINVAL;\r\n}\r\np_first_filter->action = action;\r\np_first_filter->vport_id = (p_filter_cmd->opcode ==\r\nQED_FILTER_REMOVE) ?\r\nvport_to_remove_from :\r\nvport_to_add_to;\r\n}\r\nreturn 0;\r\n}\r\nstatic int qed_sp_eth_filter_ucast(struct qed_hwfn *p_hwfn,\r\nu16 opaque_fid,\r\nstruct qed_filter_ucast *p_filter_cmd,\r\nenum spq_mode comp_mode,\r\nstruct qed_spq_comp_cb *p_comp_data)\r\n{\r\nstruct vport_filter_update_ramrod_data *p_ramrod = NULL;\r\nstruct qed_spq_entry *p_ent = NULL;\r\nstruct eth_filter_cmd_header *p_header;\r\nint rc;\r\nrc = qed_filter_ucast_common(p_hwfn, opaque_fid, p_filter_cmd,\r\n&p_ramrod, &p_ent,\r\ncomp_mode, p_comp_data);\r\nif (rc != 0) {\r\nDP_ERR(p_hwfn, "Uni. filter command failed %d\n", rc);\r\nreturn rc;\r\n}\r\np_header = &p_ramrod->filter_cmd_hdr;\r\np_header->assert_on_error = p_filter_cmd->assert_on_error;\r\nrc = qed_spq_post(p_hwfn, p_ent, NULL);\r\nif (rc != 0) {\r\nDP_ERR(p_hwfn,\r\n"Unicast filter ADD command failed %d\n",\r\nrc);\r\nreturn rc;\r\n}\r\nDP_VERBOSE(p_hwfn, QED_MSG_SP,\r\n"Unicast filter configured, opcode = %s, type = %s, cmd_cnt = %d, is_rx_filter = %d, is_tx_filter = %d\n",\r\n(p_filter_cmd->opcode == QED_FILTER_ADD) ? "ADD" :\r\n((p_filter_cmd->opcode == QED_FILTER_REMOVE) ?\r\n"REMOVE" :\r\n((p_filter_cmd->opcode == QED_FILTER_MOVE) ?\r\n"MOVE" : "REPLACE")),\r\n(p_filter_cmd->type == QED_FILTER_MAC) ? "MAC" :\r\n((p_filter_cmd->type == QED_FILTER_VLAN) ?\r\n"VLAN" : "MAC & VLAN"),\r\np_ramrod->filter_cmd_hdr.cmd_cnt,\r\np_filter_cmd->is_rx_filter,\r\np_filter_cmd->is_tx_filter);\r\nDP_VERBOSE(p_hwfn, QED_MSG_SP,\r\n"vport_to_add_to = %d, vport_to_remove_from = %d, mac = %2x:%2x:%2x:%2x:%2x:%2x, vlan = %d\n",\r\np_filter_cmd->vport_to_add_to,\r\np_filter_cmd->vport_to_remove_from,\r\np_filter_cmd->mac[0],\r\np_filter_cmd->mac[1],\r\np_filter_cmd->mac[2],\r\np_filter_cmd->mac[3],\r\np_filter_cmd->mac[4],\r\np_filter_cmd->mac[5],\r\np_filter_cmd->vlan);\r\nreturn 0;\r\n}\r\nstatic u32 qed_calc_crc32c(u8 *crc32_packet,\r\nu32 crc32_length,\r\nu32 crc32_seed,\r\nu8 complement)\r\n{\r\nu32 byte = 0;\r\nu32 bit = 0;\r\nu8 msb = 0;\r\nu8 current_byte = 0;\r\nu32 crc32_result = crc32_seed;\r\nif ((!crc32_packet) ||\r\n(crc32_length == 0) ||\r\n((crc32_length % 8) != 0))\r\nreturn crc32_result;\r\nfor (byte = 0; byte < crc32_length; byte++) {\r\ncurrent_byte = crc32_packet[byte];\r\nfor (bit = 0; bit < 8; bit++) {\r\nmsb = (u8)(crc32_result >> 31);\r\ncrc32_result = crc32_result << 1;\r\nif (msb != (0x1 & (current_byte >> bit))) {\r\ncrc32_result = crc32_result ^ CRC32_POLY;\r\ncrc32_result |= 1;\r\n}\r\n}\r\n}\r\nreturn crc32_result;\r\n}\r\nstatic inline u32 qed_crc32c_le(u32 seed,\r\nu8 *mac,\r\nu32 len)\r\n{\r\nu32 packet_buf[2] = { 0 };\r\nmemcpy((u8 *)(&packet_buf[0]), &mac[0], 6);\r\nreturn qed_calc_crc32c((u8 *)packet_buf, 8, seed, 0);\r\n}\r\nstatic u8 qed_mcast_bin_from_mac(u8 *mac)\r\n{\r\nu32 crc = qed_crc32c_le(ETH_MULTICAST_BIN_FROM_MAC_SEED,\r\nmac, ETH_ALEN);\r\nreturn crc & 0xff;\r\n}\r\nstatic int\r\nqed_sp_eth_filter_mcast(struct qed_hwfn *p_hwfn,\r\nu16 opaque_fid,\r\nstruct qed_filter_mcast *p_filter_cmd,\r\nenum spq_mode comp_mode,\r\nstruct qed_spq_comp_cb *p_comp_data)\r\n{\r\nunsigned long bins[ETH_MULTICAST_MAC_BINS_IN_REGS];\r\nstruct vport_update_ramrod_data *p_ramrod = NULL;\r\nstruct qed_sp_init_request_params sp_params;\r\nstruct qed_spq_entry *p_ent = NULL;\r\nu8 abs_vport_id = 0;\r\nint rc, i;\r\nif (p_filter_cmd->opcode == QED_FILTER_ADD) {\r\nrc = qed_fw_vport(p_hwfn, p_filter_cmd->vport_to_add_to,\r\n&abs_vport_id);\r\nif (rc)\r\nreturn rc;\r\n} else {\r\nrc = qed_fw_vport(p_hwfn, p_filter_cmd->vport_to_remove_from,\r\n&abs_vport_id);\r\nif (rc)\r\nreturn rc;\r\n}\r\nmemset(&sp_params, 0, sizeof(sp_params));\r\nsp_params.ramrod_data_size = sizeof(*p_ramrod);\r\nsp_params.comp_mode = comp_mode;\r\nsp_params.p_comp_data = p_comp_data;\r\nrc = qed_sp_init_request(p_hwfn, &p_ent,\r\nqed_spq_get_cid(p_hwfn),\r\np_hwfn->hw_info.opaque_fid,\r\nETH_RAMROD_VPORT_UPDATE,\r\nPROTOCOLID_ETH,\r\n&sp_params);\r\nif (rc) {\r\nDP_ERR(p_hwfn, "Multi-cast command failed %d\n", rc);\r\nreturn rc;\r\n}\r\np_ramrod = &p_ent->ramrod.vport_update;\r\np_ramrod->common.update_approx_mcast_flg = 1;\r\nmemset(&p_ramrod->approx_mcast.bins, 0,\r\nsizeof(p_ramrod->approx_mcast.bins));\r\nmemset(bins, 0, sizeof(unsigned long) *\r\nETH_MULTICAST_MAC_BINS_IN_REGS);\r\nif (p_filter_cmd->opcode == QED_FILTER_ADD) {\r\nfor (i = 0; i < p_filter_cmd->num_mc_addrs; i++) {\r\nu32 bit;\r\nbit = qed_mcast_bin_from_mac(p_filter_cmd->mac[i]);\r\n__set_bit(bit, bins);\r\n}\r\nfor (i = 0; i < ETH_MULTICAST_MAC_BINS_IN_REGS; i++) {\r\nu32 *p_bins = (u32 *)bins;\r\nstruct vport_update_ramrod_mcast *approx_mcast;\r\napprox_mcast = &p_ramrod->approx_mcast;\r\napprox_mcast->bins[i] = cpu_to_le32(p_bins[i]);\r\n}\r\n}\r\np_ramrod->common.vport_id = abs_vport_id;\r\nreturn qed_spq_post(p_hwfn, p_ent, NULL);\r\n}\r\nstatic int\r\nqed_filter_mcast_cmd(struct qed_dev *cdev,\r\nstruct qed_filter_mcast *p_filter_cmd,\r\nenum spq_mode comp_mode,\r\nstruct qed_spq_comp_cb *p_comp_data)\r\n{\r\nint rc = 0;\r\nint i;\r\nif ((p_filter_cmd->opcode != QED_FILTER_ADD &&\r\n(p_filter_cmd->opcode != QED_FILTER_REMOVE)) ||\r\n(p_filter_cmd->num_mc_addrs > QED_MAX_MC_ADDRS))\r\nreturn -EINVAL;\r\nfor_each_hwfn(cdev, i) {\r\nstruct qed_hwfn *p_hwfn = &cdev->hwfns[i];\r\nu16 opaque_fid;\r\nif (rc != 0)\r\nbreak;\r\nopaque_fid = p_hwfn->hw_info.opaque_fid;\r\nrc = qed_sp_eth_filter_mcast(p_hwfn,\r\nopaque_fid,\r\np_filter_cmd,\r\ncomp_mode,\r\np_comp_data);\r\n}\r\nreturn rc;\r\n}\r\nstatic int qed_filter_ucast_cmd(struct qed_dev *cdev,\r\nstruct qed_filter_ucast *p_filter_cmd,\r\nenum spq_mode comp_mode,\r\nstruct qed_spq_comp_cb *p_comp_data)\r\n{\r\nint rc = 0;\r\nint i;\r\nfor_each_hwfn(cdev, i) {\r\nstruct qed_hwfn *p_hwfn = &cdev->hwfns[i];\r\nu16 opaque_fid;\r\nif (rc != 0)\r\nbreak;\r\nopaque_fid = p_hwfn->hw_info.opaque_fid;\r\nrc = qed_sp_eth_filter_ucast(p_hwfn,\r\nopaque_fid,\r\np_filter_cmd,\r\ncomp_mode,\r\np_comp_data);\r\n}\r\nreturn rc;\r\n}\r\nstatic int qed_fill_eth_dev_info(struct qed_dev *cdev,\r\nstruct qed_dev_eth_info *info)\r\n{\r\nint i;\r\nmemset(info, 0, sizeof(*info));\r\ninfo->num_tc = 1;\r\nif (cdev->int_params.out.int_mode == QED_INT_MODE_MSIX) {\r\nfor_each_hwfn(cdev, i)\r\ninfo->num_queues += FEAT_NUM(&cdev->hwfns[i],\r\nQED_PF_L2_QUE);\r\nif (cdev->int_params.fp_msix_cnt)\r\ninfo->num_queues = min_t(u8, info->num_queues,\r\ncdev->int_params.fp_msix_cnt);\r\n} else {\r\ninfo->num_queues = cdev->num_hwfns;\r\n}\r\ninfo->num_vlan_filters = RESC_NUM(&cdev->hwfns[0], QED_VLAN);\r\nether_addr_copy(info->port_mac,\r\ncdev->hwfns[0].hw_info.hw_mac_addr);\r\nqed_fill_dev_info(cdev, &info->common);\r\nreturn 0;\r\n}\r\nstatic void qed_register_eth_ops(struct qed_dev *cdev,\r\nstruct qed_eth_cb_ops *ops,\r\nvoid *cookie)\r\n{\r\ncdev->protocol_ops.eth = ops;\r\ncdev->ops_cookie = cookie;\r\n}\r\nstatic int qed_start_vport(struct qed_dev *cdev,\r\nu8 vport_id,\r\nu16 mtu,\r\nu8 drop_ttl0_flg,\r\nu8 inner_vlan_removal_en_flg)\r\n{\r\nint rc, i;\r\nfor_each_hwfn(cdev, i) {\r\nstruct qed_hwfn *p_hwfn = &cdev->hwfns[i];\r\nrc = qed_sp_vport_start(p_hwfn,\r\np_hwfn->hw_info.concrete_fid,\r\np_hwfn->hw_info.opaque_fid,\r\nvport_id,\r\nmtu,\r\ndrop_ttl0_flg,\r\ninner_vlan_removal_en_flg);\r\nif (rc) {\r\nDP_ERR(cdev, "Failed to start VPORT\n");\r\nreturn rc;\r\n}\r\nqed_hw_start_fastpath(p_hwfn);\r\nDP_VERBOSE(cdev, (QED_MSG_SPQ | NETIF_MSG_IFUP),\r\n"Started V-PORT %d with MTU %d\n",\r\nvport_id, mtu);\r\n}\r\nqed_reset_vport_stats(cdev);\r\nreturn 0;\r\n}\r\nstatic int qed_stop_vport(struct qed_dev *cdev,\r\nu8 vport_id)\r\n{\r\nint rc, i;\r\nfor_each_hwfn(cdev, i) {\r\nstruct qed_hwfn *p_hwfn = &cdev->hwfns[i];\r\nrc = qed_sp_vport_stop(p_hwfn,\r\np_hwfn->hw_info.opaque_fid,\r\nvport_id);\r\nif (rc) {\r\nDP_ERR(cdev, "Failed to stop VPORT\n");\r\nreturn rc;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int qed_update_vport(struct qed_dev *cdev,\r\nstruct qed_update_vport_params *params)\r\n{\r\nstruct qed_sp_vport_update_params sp_params;\r\nstruct qed_rss_params sp_rss_params;\r\nint rc, i;\r\nif (!cdev)\r\nreturn -ENODEV;\r\nmemset(&sp_params, 0, sizeof(sp_params));\r\nmemset(&sp_rss_params, 0, sizeof(sp_rss_params));\r\nsp_params.vport_id = params->vport_id;\r\nsp_params.update_vport_active_rx_flg =\r\nparams->update_vport_active_flg;\r\nsp_params.update_vport_active_tx_flg =\r\nparams->update_vport_active_flg;\r\nsp_params.vport_active_rx_flg = params->vport_active_flg;\r\nsp_params.vport_active_tx_flg = params->vport_active_flg;\r\nif (cdev->num_hwfns > 1 && params->update_rss_flg) {\r\nstruct qed_update_vport_rss_params *rss =\r\n&params->rss_params;\r\nint k, max = 0;\r\nfor (k = 0; k < QED_RSS_IND_TABLE_SIZE; k++)\r\nmax = (max > rss->rss_ind_table[k]) ?\r\nmax : rss->rss_ind_table[k];\r\nif (cdev->num_hwfns < max + 1) {\r\nint divisor = (max + cdev->num_hwfns - 1) /\r\ncdev->num_hwfns;\r\nDP_VERBOSE(cdev, (QED_MSG_SPQ | NETIF_MSG_IFUP),\r\n"CMT - fixing RSS values (modulo %02x)\n",\r\ndivisor);\r\nfor (k = 0; k < QED_RSS_IND_TABLE_SIZE; k++)\r\nrss->rss_ind_table[k] =\r\nrss->rss_ind_table[k] % divisor;\r\n} else {\r\nDP_VERBOSE(cdev, (QED_MSG_SPQ | NETIF_MSG_IFUP),\r\n"CMT - 1 queue per-hwfn; Disabling RSS\n");\r\nparams->update_rss_flg = 0;\r\n}\r\n}\r\nif (params->update_rss_flg) {\r\nsp_rss_params.update_rss_config = 1;\r\nsp_rss_params.rss_enable = 1;\r\nsp_rss_params.update_rss_capabilities = 1;\r\nsp_rss_params.update_rss_ind_table = 1;\r\nsp_rss_params.update_rss_key = 1;\r\nsp_rss_params.rss_caps = QED_RSS_IPV4 |\r\nQED_RSS_IPV6 |\r\nQED_RSS_IPV4_TCP | QED_RSS_IPV6_TCP;\r\nsp_rss_params.rss_table_size_log = 7;\r\nmemcpy(sp_rss_params.rss_ind_table,\r\nparams->rss_params.rss_ind_table,\r\nQED_RSS_IND_TABLE_SIZE * sizeof(u16));\r\nmemcpy(sp_rss_params.rss_key, params->rss_params.rss_key,\r\nQED_RSS_KEY_SIZE * sizeof(u32));\r\n}\r\nsp_params.rss_params = &sp_rss_params;\r\nfor_each_hwfn(cdev, i) {\r\nstruct qed_hwfn *p_hwfn = &cdev->hwfns[i];\r\nsp_params.opaque_fid = p_hwfn->hw_info.opaque_fid;\r\nrc = qed_sp_vport_update(p_hwfn, &sp_params,\r\nQED_SPQ_MODE_EBLOCK,\r\nNULL);\r\nif (rc) {\r\nDP_ERR(cdev, "Failed to update VPORT\n");\r\nreturn rc;\r\n}\r\nDP_VERBOSE(cdev, (QED_MSG_SPQ | NETIF_MSG_IFUP),\r\n"Updated V-PORT %d: active_flag %d [update %d]\n",\r\nparams->vport_id, params->vport_active_flg,\r\nparams->update_vport_active_flg);\r\n}\r\nreturn 0;\r\n}\r\nstatic int qed_start_rxq(struct qed_dev *cdev,\r\nstruct qed_queue_start_common_params *params,\r\nu16 bd_max_bytes,\r\ndma_addr_t bd_chain_phys_addr,\r\ndma_addr_t cqe_pbl_addr,\r\nu16 cqe_pbl_size,\r\nvoid __iomem **pp_prod)\r\n{\r\nint rc, hwfn_index;\r\nstruct qed_hwfn *p_hwfn;\r\nhwfn_index = params->rss_id % cdev->num_hwfns;\r\np_hwfn = &cdev->hwfns[hwfn_index];\r\nparams->queue_id /= cdev->num_hwfns;\r\nrc = qed_sp_eth_rx_queue_start(p_hwfn,\r\np_hwfn->hw_info.opaque_fid,\r\nparams,\r\nbd_max_bytes,\r\nbd_chain_phys_addr,\r\ncqe_pbl_addr,\r\ncqe_pbl_size,\r\npp_prod);\r\nif (rc) {\r\nDP_ERR(cdev, "Failed to start RXQ#%d\n", params->queue_id);\r\nreturn rc;\r\n}\r\nDP_VERBOSE(cdev, (QED_MSG_SPQ | NETIF_MSG_IFUP),\r\n"Started RX-Q %d [rss %d] on V-PORT %d and SB %d\n",\r\nparams->queue_id, params->rss_id, params->vport_id,\r\nparams->sb);\r\nreturn 0;\r\n}\r\nstatic int qed_stop_rxq(struct qed_dev *cdev,\r\nstruct qed_stop_rxq_params *params)\r\n{\r\nint rc, hwfn_index;\r\nstruct qed_hwfn *p_hwfn;\r\nhwfn_index = params->rss_id % cdev->num_hwfns;\r\np_hwfn = &cdev->hwfns[hwfn_index];\r\nrc = qed_sp_eth_rx_queue_stop(p_hwfn,\r\nparams->rx_queue_id / cdev->num_hwfns,\r\nparams->eq_completion_only,\r\nfalse);\r\nif (rc) {\r\nDP_ERR(cdev, "Failed to stop RXQ#%d\n", params->rx_queue_id);\r\nreturn rc;\r\n}\r\nreturn 0;\r\n}\r\nstatic int qed_start_txq(struct qed_dev *cdev,\r\nstruct qed_queue_start_common_params *p_params,\r\ndma_addr_t pbl_addr,\r\nu16 pbl_size,\r\nvoid __iomem **pp_doorbell)\r\n{\r\nstruct qed_hwfn *p_hwfn;\r\nint rc, hwfn_index;\r\nhwfn_index = p_params->rss_id % cdev->num_hwfns;\r\np_hwfn = &cdev->hwfns[hwfn_index];\r\np_params->queue_id /= cdev->num_hwfns;\r\nrc = qed_sp_eth_tx_queue_start(p_hwfn,\r\np_hwfn->hw_info.opaque_fid,\r\np_params,\r\npbl_addr,\r\npbl_size,\r\npp_doorbell);\r\nif (rc) {\r\nDP_ERR(cdev, "Failed to start TXQ#%d\n", p_params->queue_id);\r\nreturn rc;\r\n}\r\nDP_VERBOSE(cdev, (QED_MSG_SPQ | NETIF_MSG_IFUP),\r\n"Started TX-Q %d [rss %d] on V-PORT %d and SB %d\n",\r\np_params->queue_id, p_params->rss_id, p_params->vport_id,\r\np_params->sb);\r\nreturn 0;\r\n}\r\nstatic int qed_fastpath_stop(struct qed_dev *cdev)\r\n{\r\nqed_hw_stop_fastpath(cdev);\r\nreturn 0;\r\n}\r\nstatic int qed_stop_txq(struct qed_dev *cdev,\r\nstruct qed_stop_txq_params *params)\r\n{\r\nstruct qed_hwfn *p_hwfn;\r\nint rc, hwfn_index;\r\nhwfn_index = params->rss_id % cdev->num_hwfns;\r\np_hwfn = &cdev->hwfns[hwfn_index];\r\nrc = qed_sp_eth_tx_queue_stop(p_hwfn,\r\nparams->tx_queue_id / cdev->num_hwfns);\r\nif (rc) {\r\nDP_ERR(cdev, "Failed to stop TXQ#%d\n", params->tx_queue_id);\r\nreturn rc;\r\n}\r\nreturn 0;\r\n}\r\nstatic int qed_configure_filter_rx_mode(struct qed_dev *cdev,\r\nenum qed_filter_rx_mode_type type)\r\n{\r\nstruct qed_filter_accept_flags accept_flags;\r\nmemset(&accept_flags, 0, sizeof(accept_flags));\r\naccept_flags.update_rx_mode_config = 1;\r\naccept_flags.update_tx_mode_config = 1;\r\naccept_flags.rx_accept_filter = QED_ACCEPT_UCAST_MATCHED |\r\nQED_ACCEPT_MCAST_MATCHED |\r\nQED_ACCEPT_BCAST;\r\naccept_flags.tx_accept_filter = QED_ACCEPT_UCAST_MATCHED |\r\nQED_ACCEPT_MCAST_MATCHED |\r\nQED_ACCEPT_BCAST;\r\nif (type == QED_FILTER_RX_MODE_TYPE_PROMISC)\r\naccept_flags.rx_accept_filter |= QED_ACCEPT_UCAST_UNMATCHED |\r\nQED_ACCEPT_MCAST_UNMATCHED;\r\nelse if (type == QED_FILTER_RX_MODE_TYPE_MULTI_PROMISC)\r\naccept_flags.rx_accept_filter |= QED_ACCEPT_MCAST_UNMATCHED;\r\nreturn qed_filter_accept_cmd(cdev, 0, accept_flags,\r\nQED_SPQ_MODE_CB, NULL);\r\n}\r\nstatic int qed_configure_filter_ucast(struct qed_dev *cdev,\r\nstruct qed_filter_ucast_params *params)\r\n{\r\nstruct qed_filter_ucast ucast;\r\nif (!params->vlan_valid && !params->mac_valid) {\r\nDP_NOTICE(\r\ncdev,\r\n"Tried configuring a unicast filter, but both MAC and VLAN are not set\n");\r\nreturn -EINVAL;\r\n}\r\nmemset(&ucast, 0, sizeof(ucast));\r\nswitch (params->type) {\r\ncase QED_FILTER_XCAST_TYPE_ADD:\r\nucast.opcode = QED_FILTER_ADD;\r\nbreak;\r\ncase QED_FILTER_XCAST_TYPE_DEL:\r\nucast.opcode = QED_FILTER_REMOVE;\r\nbreak;\r\ncase QED_FILTER_XCAST_TYPE_REPLACE:\r\nucast.opcode = QED_FILTER_REPLACE;\r\nbreak;\r\ndefault:\r\nDP_NOTICE(cdev, "Unknown unicast filter type %d\n",\r\nparams->type);\r\n}\r\nif (params->vlan_valid && params->mac_valid) {\r\nucast.type = QED_FILTER_MAC_VLAN;\r\nether_addr_copy(ucast.mac, params->mac);\r\nucast.vlan = params->vlan;\r\n} else if (params->mac_valid) {\r\nucast.type = QED_FILTER_MAC;\r\nether_addr_copy(ucast.mac, params->mac);\r\n} else {\r\nucast.type = QED_FILTER_VLAN;\r\nucast.vlan = params->vlan;\r\n}\r\nucast.is_rx_filter = true;\r\nucast.is_tx_filter = true;\r\nreturn qed_filter_ucast_cmd(cdev, &ucast, QED_SPQ_MODE_CB, NULL);\r\n}\r\nstatic int qed_configure_filter_mcast(struct qed_dev *cdev,\r\nstruct qed_filter_mcast_params *params)\r\n{\r\nstruct qed_filter_mcast mcast;\r\nint i;\r\nmemset(&mcast, 0, sizeof(mcast));\r\nswitch (params->type) {\r\ncase QED_FILTER_XCAST_TYPE_ADD:\r\nmcast.opcode = QED_FILTER_ADD;\r\nbreak;\r\ncase QED_FILTER_XCAST_TYPE_DEL:\r\nmcast.opcode = QED_FILTER_REMOVE;\r\nbreak;\r\ndefault:\r\nDP_NOTICE(cdev, "Unknown multicast filter type %d\n",\r\nparams->type);\r\n}\r\nmcast.num_mc_addrs = params->num;\r\nfor (i = 0; i < mcast.num_mc_addrs; i++)\r\nether_addr_copy(mcast.mac[i], params->mac[i]);\r\nreturn qed_filter_mcast_cmd(cdev, &mcast,\r\nQED_SPQ_MODE_CB, NULL);\r\n}\r\nstatic int qed_configure_filter(struct qed_dev *cdev,\r\nstruct qed_filter_params *params)\r\n{\r\nenum qed_filter_rx_mode_type accept_flags;\r\nswitch (params->type) {\r\ncase QED_FILTER_TYPE_UCAST:\r\nreturn qed_configure_filter_ucast(cdev, &params->filter.ucast);\r\ncase QED_FILTER_TYPE_MCAST:\r\nreturn qed_configure_filter_mcast(cdev, &params->filter.mcast);\r\ncase QED_FILTER_TYPE_RX_MODE:\r\naccept_flags = params->filter.accept_flags;\r\nreturn qed_configure_filter_rx_mode(cdev, accept_flags);\r\ndefault:\r\nDP_NOTICE(cdev, "Unknown filter type %d\n",\r\n(int)params->type);\r\nreturn -EINVAL;\r\n}\r\n}\r\nstatic int qed_fp_cqe_completion(struct qed_dev *dev,\r\nu8 rss_id,\r\nstruct eth_slow_path_rx_cqe *cqe)\r\n{\r\nreturn qed_eth_cqe_completion(&dev->hwfns[rss_id % dev->num_hwfns],\r\ncqe);\r\n}\r\nconst struct qed_eth_ops *qed_get_eth_ops(u32 version)\r\n{\r\nif (version != QED_ETH_INTERFACE_VERSION) {\r\npr_notice("Cannot supply ethtool operations [%08x != %08x]\n",\r\nversion, QED_ETH_INTERFACE_VERSION);\r\nreturn NULL;\r\n}\r\nreturn &qed_eth_ops_pass;\r\n}\r\nvoid qed_put_eth_ops(void)\r\n{\r\n}
