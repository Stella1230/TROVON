static void rds_iw_set_protocol(struct rds_connection *conn, unsigned int version)\r\n{\r\nconn->c_version = version;\r\n}\r\nstatic void rds_iw_set_flow_control(struct rds_connection *conn, u32 credits)\r\n{\r\nstruct rds_iw_connection *ic = conn->c_transport_data;\r\nif (rds_iw_sysctl_flow_control && credits != 0) {\r\nic->i_flowctl = 1;\r\nrds_iw_send_add_credits(conn, credits);\r\n} else {\r\nic->i_flowctl = 0;\r\n}\r\n}\r\nvoid rds_iw_cm_connect_complete(struct rds_connection *conn, struct rdma_cm_event *event)\r\n{\r\nconst struct rds_iw_connect_private *dp = NULL;\r\nstruct rds_iw_connection *ic = conn->c_transport_data;\r\nstruct rds_iw_device *rds_iwdev;\r\nint err;\r\nif (event->param.conn.private_data_len) {\r\ndp = event->param.conn.private_data;\r\nrds_iw_set_protocol(conn,\r\nRDS_PROTOCOL(dp->dp_protocol_major,\r\ndp->dp_protocol_minor));\r\nrds_iw_set_flow_control(conn, be32_to_cpu(dp->dp_credit));\r\n}\r\nrds_iwdev = ib_get_client_data(ic->i_cm_id->device, &rds_iw_client);\r\nerr = rds_iw_update_cm_id(rds_iwdev, ic->i_cm_id);\r\nif (err)\r\nprintk(KERN_ERR "rds_iw_update_ipaddr failed (%d)\n", err);\r\nrds_iw_add_conn(rds_iwdev, conn);\r\nif (dp && dp->dp_ack_seq)\r\nrds_send_drop_acked(conn, be64_to_cpu(dp->dp_ack_seq), NULL);\r\nprintk(KERN_NOTICE "RDS/IW: connected to %pI4<->%pI4 version %u.%u%s\n",\r\n&conn->c_laddr, &conn->c_faddr,\r\nRDS_PROTOCOL_MAJOR(conn->c_version),\r\nRDS_PROTOCOL_MINOR(conn->c_version),\r\nic->i_flowctl ? ", flow control" : "");\r\nrds_connect_complete(conn);\r\n}\r\nstatic void rds_iw_cm_fill_conn_param(struct rds_connection *conn,\r\nstruct rdma_conn_param *conn_param,\r\nstruct rds_iw_connect_private *dp,\r\nu32 protocol_version)\r\n{\r\nstruct rds_iw_connection *ic = conn->c_transport_data;\r\nmemset(conn_param, 0, sizeof(struct rdma_conn_param));\r\nconn_param->responder_resources = 1;\r\nconn_param->initiator_depth = 1;\r\nif (dp) {\r\nmemset(dp, 0, sizeof(*dp));\r\ndp->dp_saddr = conn->c_laddr;\r\ndp->dp_daddr = conn->c_faddr;\r\ndp->dp_protocol_major = RDS_PROTOCOL_MAJOR(protocol_version);\r\ndp->dp_protocol_minor = RDS_PROTOCOL_MINOR(protocol_version);\r\ndp->dp_protocol_minor_mask = cpu_to_be16(RDS_IW_SUPPORTED_PROTOCOLS);\r\ndp->dp_ack_seq = rds_iw_piggyb_ack(ic);\r\nif (ic->i_flowctl) {\r\nunsigned int credits;\r\ncredits = IB_GET_POST_CREDITS(atomic_read(&ic->i_credits));\r\ndp->dp_credit = cpu_to_be32(credits);\r\natomic_sub(IB_SET_POST_CREDITS(credits), &ic->i_credits);\r\n}\r\nconn_param->private_data = dp;\r\nconn_param->private_data_len = sizeof(*dp);\r\n}\r\n}\r\nstatic void rds_iw_cq_event_handler(struct ib_event *event, void *data)\r\n{\r\nrdsdebug("event %u data %p\n", event->event, data);\r\n}\r\nstatic void rds_iw_qp_event_handler(struct ib_event *event, void *data)\r\n{\r\nstruct rds_connection *conn = data;\r\nstruct rds_iw_connection *ic = conn->c_transport_data;\r\nrdsdebug("conn %p ic %p event %u\n", conn, ic, event->event);\r\nswitch (event->event) {\r\ncase IB_EVENT_COMM_EST:\r\nrdma_notify(ic->i_cm_id, IB_EVENT_COMM_EST);\r\nbreak;\r\ncase IB_EVENT_QP_REQ_ERR:\r\ncase IB_EVENT_QP_FATAL:\r\ndefault:\r\nrdsdebug("Fatal QP Event %u "\r\n"- connection %pI4->%pI4, reconnecting\n",\r\nevent->event, &conn->c_laddr,\r\n&conn->c_faddr);\r\nrds_conn_drop(conn);\r\nbreak;\r\n}\r\n}\r\nstatic int rds_iw_init_qp_attrs(struct ib_qp_init_attr *attr,\r\nstruct rds_iw_device *rds_iwdev,\r\nstruct rds_iw_work_ring *send_ring,\r\nvoid (*send_cq_handler)(struct ib_cq *, void *),\r\nstruct rds_iw_work_ring *recv_ring,\r\nvoid (*recv_cq_handler)(struct ib_cq *, void *),\r\nvoid *context)\r\n{\r\nstruct ib_device *dev = rds_iwdev->dev;\r\nstruct ib_cq_init_attr cq_attr = {};\r\nunsigned int send_size, recv_size;\r\nint ret;\r\nsend_size = min_t(unsigned int, rds_iwdev->max_wrs, rds_iw_sysctl_max_send_wr + 1);\r\nrecv_size = min_t(unsigned int, rds_iwdev->max_wrs, rds_iw_sysctl_max_recv_wr + 1);\r\nrds_iw_ring_resize(send_ring, send_size - 1);\r\nrds_iw_ring_resize(recv_ring, recv_size - 1);\r\nmemset(attr, 0, sizeof(*attr));\r\nattr->event_handler = rds_iw_qp_event_handler;\r\nattr->qp_context = context;\r\nattr->cap.max_send_wr = send_size;\r\nattr->cap.max_recv_wr = recv_size;\r\nattr->cap.max_send_sge = rds_iwdev->max_sge;\r\nattr->cap.max_recv_sge = RDS_IW_RECV_SGE;\r\nattr->sq_sig_type = IB_SIGNAL_REQ_WR;\r\nattr->qp_type = IB_QPT_RC;\r\ncq_attr.cqe = send_size;\r\nattr->send_cq = ib_create_cq(dev, send_cq_handler,\r\nrds_iw_cq_event_handler,\r\ncontext, &cq_attr);\r\nif (IS_ERR(attr->send_cq)) {\r\nret = PTR_ERR(attr->send_cq);\r\nattr->send_cq = NULL;\r\nrdsdebug("ib_create_cq send failed: %d\n", ret);\r\ngoto out;\r\n}\r\ncq_attr.cqe = recv_size;\r\nattr->recv_cq = ib_create_cq(dev, recv_cq_handler,\r\nrds_iw_cq_event_handler,\r\ncontext, &cq_attr);\r\nif (IS_ERR(attr->recv_cq)) {\r\nret = PTR_ERR(attr->recv_cq);\r\nattr->recv_cq = NULL;\r\nrdsdebug("ib_create_cq send failed: %d\n", ret);\r\ngoto out;\r\n}\r\nret = ib_req_notify_cq(attr->send_cq, IB_CQ_NEXT_COMP);\r\nif (ret) {\r\nrdsdebug("ib_req_notify_cq send failed: %d\n", ret);\r\ngoto out;\r\n}\r\nret = ib_req_notify_cq(attr->recv_cq, IB_CQ_SOLICITED);\r\nif (ret) {\r\nrdsdebug("ib_req_notify_cq recv failed: %d\n", ret);\r\ngoto out;\r\n}\r\nout:\r\nif (ret) {\r\nif (attr->send_cq)\r\nib_destroy_cq(attr->send_cq);\r\nif (attr->recv_cq)\r\nib_destroy_cq(attr->recv_cq);\r\n}\r\nreturn ret;\r\n}\r\nstatic int rds_iw_setup_qp(struct rds_connection *conn)\r\n{\r\nstruct rds_iw_connection *ic = conn->c_transport_data;\r\nstruct ib_device *dev = ic->i_cm_id->device;\r\nstruct ib_qp_init_attr attr;\r\nstruct rds_iw_device *rds_iwdev;\r\nint ret;\r\nrds_iwdev = ib_get_client_data(dev, &rds_iw_client);\r\nif (!rds_iwdev) {\r\nprintk_ratelimited(KERN_NOTICE "RDS/IW: No client_data for device %s\n",\r\ndev->name);\r\nreturn -EOPNOTSUPP;\r\n}\r\nic->i_pd = rds_iwdev->pd;\r\nic->i_mr = rds_iwdev->mr;\r\nret = rds_iw_init_qp_attrs(&attr, rds_iwdev,\r\n&ic->i_send_ring, rds_iw_send_cq_comp_handler,\r\n&ic->i_recv_ring, rds_iw_recv_cq_comp_handler,\r\nconn);\r\nif (ret < 0)\r\ngoto out;\r\nic->i_send_cq = attr.send_cq;\r\nic->i_recv_cq = attr.recv_cq;\r\nret = rdma_create_qp(ic->i_cm_id, ic->i_pd, &attr);\r\nif (ret) {\r\nrdsdebug("rdma_create_qp failed: %d\n", ret);\r\ngoto out;\r\n}\r\nic->i_send_hdrs = ib_dma_alloc_coherent(dev,\r\nic->i_send_ring.w_nr *\r\nsizeof(struct rds_header),\r\n&ic->i_send_hdrs_dma, GFP_KERNEL);\r\nif (!ic->i_send_hdrs) {\r\nret = -ENOMEM;\r\nrdsdebug("ib_dma_alloc_coherent send failed\n");\r\ngoto out;\r\n}\r\nic->i_recv_hdrs = ib_dma_alloc_coherent(dev,\r\nic->i_recv_ring.w_nr *\r\nsizeof(struct rds_header),\r\n&ic->i_recv_hdrs_dma, GFP_KERNEL);\r\nif (!ic->i_recv_hdrs) {\r\nret = -ENOMEM;\r\nrdsdebug("ib_dma_alloc_coherent recv failed\n");\r\ngoto out;\r\n}\r\nic->i_ack = ib_dma_alloc_coherent(dev, sizeof(struct rds_header),\r\n&ic->i_ack_dma, GFP_KERNEL);\r\nif (!ic->i_ack) {\r\nret = -ENOMEM;\r\nrdsdebug("ib_dma_alloc_coherent ack failed\n");\r\ngoto out;\r\n}\r\nic->i_sends = vmalloc(ic->i_send_ring.w_nr * sizeof(struct rds_iw_send_work));\r\nif (!ic->i_sends) {\r\nret = -ENOMEM;\r\nrdsdebug("send allocation failed\n");\r\ngoto out;\r\n}\r\nrds_iw_send_init_ring(ic);\r\nic->i_recvs = vmalloc(ic->i_recv_ring.w_nr * sizeof(struct rds_iw_recv_work));\r\nif (!ic->i_recvs) {\r\nret = -ENOMEM;\r\nrdsdebug("recv allocation failed\n");\r\ngoto out;\r\n}\r\nrds_iw_recv_init_ring(ic);\r\nrds_iw_recv_init_ack(ic);\r\nrds_iw_recv_refill(conn, GFP_KERNEL, GFP_HIGHUSER, 1);\r\nrdsdebug("conn %p pd %p mr %p cq %p %p\n", conn, ic->i_pd, ic->i_mr,\r\nic->i_send_cq, ic->i_recv_cq);\r\nout:\r\nreturn ret;\r\n}\r\nstatic u32 rds_iw_protocol_compatible(const struct rds_iw_connect_private *dp)\r\n{\r\nu16 common;\r\nu32 version = 0;\r\nif (dp->dp_protocol_major == 0)\r\nreturn RDS_PROTOCOL_3_0;\r\ncommon = be16_to_cpu(dp->dp_protocol_minor_mask) & RDS_IW_SUPPORTED_PROTOCOLS;\r\nif (dp->dp_protocol_major == 3 && common) {\r\nversion = RDS_PROTOCOL_3_0;\r\nwhile ((common >>= 1) != 0)\r\nversion++;\r\n}\r\nprintk_ratelimited(KERN_NOTICE "RDS: Connection from %pI4 using "\r\n"incompatible protocol version %u.%u\n",\r\n&dp->dp_saddr,\r\ndp->dp_protocol_major,\r\ndp->dp_protocol_minor);\r\nreturn version;\r\n}\r\nint rds_iw_cm_handle_connect(struct rdma_cm_id *cm_id,\r\nstruct rdma_cm_event *event)\r\n{\r\nconst struct rds_iw_connect_private *dp = event->param.conn.private_data;\r\nstruct rds_iw_connect_private dp_rep;\r\nstruct rds_connection *conn = NULL;\r\nstruct rds_iw_connection *ic = NULL;\r\nstruct rdma_conn_param conn_param;\r\nstruct rds_iw_device *rds_iwdev;\r\nu32 version;\r\nint err, destroy = 1;\r\nversion = rds_iw_protocol_compatible(dp);\r\nif (!version)\r\ngoto out;\r\nrdsdebug("saddr %pI4 daddr %pI4 RDSv%u.%u\n",\r\n&dp->dp_saddr, &dp->dp_daddr,\r\nRDS_PROTOCOL_MAJOR(version), RDS_PROTOCOL_MINOR(version));\r\nconn = rds_conn_create(&init_net, dp->dp_daddr, dp->dp_saddr,\r\n&rds_iw_transport, GFP_KERNEL);\r\nif (IS_ERR(conn)) {\r\nrdsdebug("rds_conn_create failed (%ld)\n", PTR_ERR(conn));\r\nconn = NULL;\r\ngoto out;\r\n}\r\nmutex_lock(&conn->c_cm_lock);\r\nif (!rds_conn_transition(conn, RDS_CONN_DOWN, RDS_CONN_CONNECTING)) {\r\nif (rds_conn_state(conn) == RDS_CONN_UP) {\r\nrdsdebug("incoming connect while connecting\n");\r\nrds_conn_drop(conn);\r\nrds_iw_stats_inc(s_iw_listen_closed_stale);\r\n} else\r\nif (rds_conn_state(conn) == RDS_CONN_CONNECTING) {\r\nrds_iw_stats_inc(s_iw_connect_raced);\r\n}\r\nmutex_unlock(&conn->c_cm_lock);\r\ngoto out;\r\n}\r\nic = conn->c_transport_data;\r\nrds_iw_set_protocol(conn, version);\r\nrds_iw_set_flow_control(conn, be32_to_cpu(dp->dp_credit));\r\nif (dp->dp_ack_seq)\r\nrds_send_drop_acked(conn, be64_to_cpu(dp->dp_ack_seq), NULL);\r\nBUG_ON(cm_id->context);\r\nBUG_ON(ic->i_cm_id);\r\nic->i_cm_id = cm_id;\r\ncm_id->context = conn;\r\nrds_iwdev = ib_get_client_data(cm_id->device, &rds_iw_client);\r\nic->i_dma_local_lkey = rds_iwdev->dma_local_lkey;\r\ndestroy = 0;\r\nerr = rds_iw_setup_qp(conn);\r\nif (err) {\r\nrds_iw_conn_error(conn, "rds_iw_setup_qp failed (%d)\n", err);\r\nmutex_unlock(&conn->c_cm_lock);\r\ngoto out;\r\n}\r\nrds_iw_cm_fill_conn_param(conn, &conn_param, &dp_rep, version);\r\nerr = rdma_accept(cm_id, &conn_param);\r\nmutex_unlock(&conn->c_cm_lock);\r\nif (err) {\r\nrds_iw_conn_error(conn, "rdma_accept failed (%d)\n", err);\r\ngoto out;\r\n}\r\nreturn 0;\r\nout:\r\nrdma_reject(cm_id, NULL, 0);\r\nreturn destroy;\r\n}\r\nint rds_iw_cm_initiate_connect(struct rdma_cm_id *cm_id)\r\n{\r\nstruct rds_connection *conn = cm_id->context;\r\nstruct rds_iw_connection *ic = conn->c_transport_data;\r\nstruct rdma_conn_param conn_param;\r\nstruct rds_iw_connect_private dp;\r\nint ret;\r\nrds_iw_set_protocol(conn, RDS_PROTOCOL_3_0);\r\nic->i_flowctl = rds_iw_sysctl_flow_control;\r\nret = rds_iw_setup_qp(conn);\r\nif (ret) {\r\nrds_iw_conn_error(conn, "rds_iw_setup_qp failed (%d)\n", ret);\r\ngoto out;\r\n}\r\nrds_iw_cm_fill_conn_param(conn, &conn_param, &dp, RDS_PROTOCOL_VERSION);\r\nret = rdma_connect(cm_id, &conn_param);\r\nif (ret)\r\nrds_iw_conn_error(conn, "rdma_connect failed (%d)\n", ret);\r\nout:\r\nif (ret) {\r\nstruct rds_iw_connection *ic = conn->c_transport_data;\r\nif (ic->i_cm_id == cm_id)\r\nret = 0;\r\n}\r\nreturn ret;\r\n}\r\nint rds_iw_conn_connect(struct rds_connection *conn)\r\n{\r\nstruct rds_iw_connection *ic = conn->c_transport_data;\r\nstruct rds_iw_device *rds_iwdev;\r\nstruct sockaddr_in src, dest;\r\nint ret;\r\nic->i_cm_id = rdma_create_id(&init_net, rds_rdma_cm_event_handler, conn,\r\nRDMA_PS_TCP, IB_QPT_RC);\r\nif (IS_ERR(ic->i_cm_id)) {\r\nret = PTR_ERR(ic->i_cm_id);\r\nic->i_cm_id = NULL;\r\nrdsdebug("rdma_create_id() failed: %d\n", ret);\r\ngoto out;\r\n}\r\nrdsdebug("created cm id %p for conn %p\n", ic->i_cm_id, conn);\r\nsrc.sin_family = AF_INET;\r\nsrc.sin_addr.s_addr = (__force u32)conn->c_laddr;\r\nsrc.sin_port = (__force u16)htons(0);\r\nret = rdma_bind_addr(ic->i_cm_id, (struct sockaddr *) &src);\r\nif (ret) {\r\nrdsdebug("rdma_bind_addr(%pI4) failed: %d\n",\r\n&conn->c_laddr, ret);\r\nrdma_destroy_id(ic->i_cm_id);\r\nic->i_cm_id = NULL;\r\ngoto out;\r\n}\r\nrds_iwdev = ib_get_client_data(ic->i_cm_id->device, &rds_iw_client);\r\nic->i_dma_local_lkey = rds_iwdev->dma_local_lkey;\r\ndest.sin_family = AF_INET;\r\ndest.sin_addr.s_addr = (__force u32)conn->c_faddr;\r\ndest.sin_port = (__force u16)htons(RDS_PORT);\r\nret = rdma_resolve_addr(ic->i_cm_id, (struct sockaddr *)&src,\r\n(struct sockaddr *)&dest,\r\nRDS_RDMA_RESOLVE_TIMEOUT_MS);\r\nif (ret) {\r\nrdsdebug("addr resolve failed for cm id %p: %d\n", ic->i_cm_id,\r\nret);\r\nrdma_destroy_id(ic->i_cm_id);\r\nic->i_cm_id = NULL;\r\n}\r\nout:\r\nreturn ret;\r\n}\r\nvoid rds_iw_conn_shutdown(struct rds_connection *conn)\r\n{\r\nstruct rds_iw_connection *ic = conn->c_transport_data;\r\nint err = 0;\r\nstruct ib_qp_attr qp_attr;\r\nrdsdebug("cm %p pd %p cq %p %p qp %p\n", ic->i_cm_id,\r\nic->i_pd, ic->i_send_cq, ic->i_recv_cq,\r\nic->i_cm_id ? ic->i_cm_id->qp : NULL);\r\nif (ic->i_cm_id) {\r\nstruct ib_device *dev = ic->i_cm_id->device;\r\nrdsdebug("disconnecting cm %p\n", ic->i_cm_id);\r\nerr = rdma_disconnect(ic->i_cm_id);\r\nif (err) {\r\nrdsdebug("failed to disconnect, cm: %p err %d\n",\r\nic->i_cm_id, err);\r\n}\r\nif (ic->i_cm_id->qp) {\r\nqp_attr.qp_state = IB_QPS_ERR;\r\nib_modify_qp(ic->i_cm_id->qp, &qp_attr, IB_QP_STATE);\r\n}\r\nwait_event(rds_iw_ring_empty_wait,\r\nrds_iw_ring_empty(&ic->i_send_ring) &&\r\nrds_iw_ring_empty(&ic->i_recv_ring));\r\nif (ic->i_send_hdrs)\r\nib_dma_free_coherent(dev,\r\nic->i_send_ring.w_nr *\r\nsizeof(struct rds_header),\r\nic->i_send_hdrs,\r\nic->i_send_hdrs_dma);\r\nif (ic->i_recv_hdrs)\r\nib_dma_free_coherent(dev,\r\nic->i_recv_ring.w_nr *\r\nsizeof(struct rds_header),\r\nic->i_recv_hdrs,\r\nic->i_recv_hdrs_dma);\r\nif (ic->i_ack)\r\nib_dma_free_coherent(dev, sizeof(struct rds_header),\r\nic->i_ack, ic->i_ack_dma);\r\nif (ic->i_sends)\r\nrds_iw_send_clear_ring(ic);\r\nif (ic->i_recvs)\r\nrds_iw_recv_clear_ring(ic);\r\nif (ic->i_cm_id->qp)\r\nrdma_destroy_qp(ic->i_cm_id);\r\nif (ic->i_send_cq)\r\nib_destroy_cq(ic->i_send_cq);\r\nif (ic->i_recv_cq)\r\nib_destroy_cq(ic->i_recv_cq);\r\nif (ic->rds_iwdev)\r\nrds_iw_remove_conn(ic->rds_iwdev, conn);\r\nrdma_destroy_id(ic->i_cm_id);\r\nic->i_cm_id = NULL;\r\nic->i_pd = NULL;\r\nic->i_mr = NULL;\r\nic->i_send_cq = NULL;\r\nic->i_recv_cq = NULL;\r\nic->i_send_hdrs = NULL;\r\nic->i_recv_hdrs = NULL;\r\nic->i_ack = NULL;\r\n}\r\nBUG_ON(ic->rds_iwdev);\r\nif (ic->i_rm) {\r\nrds_message_put(ic->i_rm);\r\nic->i_rm = NULL;\r\n}\r\nclear_bit(IB_ACK_IN_FLIGHT, &ic->i_ack_flags);\r\n#ifdef KERNEL_HAS_ATOMIC64\r\natomic64_set(&ic->i_ack_next, 0);\r\n#else\r\nic->i_ack_next = 0;\r\n#endif\r\nic->i_ack_recv = 0;\r\nic->i_flowctl = 0;\r\natomic_set(&ic->i_credits, 0);\r\nrds_iw_ring_init(&ic->i_send_ring, rds_iw_sysctl_max_send_wr);\r\nrds_iw_ring_init(&ic->i_recv_ring, rds_iw_sysctl_max_recv_wr);\r\nif (ic->i_iwinc) {\r\nrds_inc_put(&ic->i_iwinc->ii_inc);\r\nic->i_iwinc = NULL;\r\n}\r\nvfree(ic->i_sends);\r\nic->i_sends = NULL;\r\nvfree(ic->i_recvs);\r\nic->i_recvs = NULL;\r\nrdsdebug("shutdown complete\n");\r\n}\r\nint rds_iw_conn_alloc(struct rds_connection *conn, gfp_t gfp)\r\n{\r\nstruct rds_iw_connection *ic;\r\nunsigned long flags;\r\nic = kzalloc(sizeof(struct rds_iw_connection), gfp);\r\nif (!ic)\r\nreturn -ENOMEM;\r\nINIT_LIST_HEAD(&ic->iw_node);\r\ntasklet_init(&ic->i_recv_tasklet, rds_iw_recv_tasklet_fn,\r\n(unsigned long) ic);\r\nmutex_init(&ic->i_recv_mutex);\r\n#ifndef KERNEL_HAS_ATOMIC64\r\nspin_lock_init(&ic->i_ack_lock);\r\n#endif\r\nrds_iw_ring_init(&ic->i_send_ring, rds_iw_sysctl_max_send_wr);\r\nrds_iw_ring_init(&ic->i_recv_ring, rds_iw_sysctl_max_recv_wr);\r\nic->conn = conn;\r\nconn->c_transport_data = ic;\r\nspin_lock_irqsave(&iw_nodev_conns_lock, flags);\r\nlist_add_tail(&ic->iw_node, &iw_nodev_conns);\r\nspin_unlock_irqrestore(&iw_nodev_conns_lock, flags);\r\nrdsdebug("conn %p conn ic %p\n", conn, conn->c_transport_data);\r\nreturn 0;\r\n}\r\nvoid rds_iw_conn_free(void *arg)\r\n{\r\nstruct rds_iw_connection *ic = arg;\r\nspinlock_t *lock_ptr;\r\nrdsdebug("ic %p\n", ic);\r\nlock_ptr = ic->rds_iwdev ? &ic->rds_iwdev->spinlock : &iw_nodev_conns_lock;\r\nspin_lock_irq(lock_ptr);\r\nlist_del(&ic->iw_node);\r\nspin_unlock_irq(lock_ptr);\r\nkfree(ic);\r\n}\r\nvoid\r\n__rds_iw_conn_error(struct rds_connection *conn, const char *fmt, ...)\r\n{\r\nva_list ap;\r\nrds_conn_drop(conn);\r\nva_start(ap, fmt);\r\nvprintk(fmt, ap);\r\nva_end(ap);\r\n}
