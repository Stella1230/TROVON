static void lower_case(char *str)\r\n{\r\nif (!str)\r\nreturn;\r\nfor (; *str; str++)\r\n*str = tolower(*str);\r\n}\r\nstatic int update_option_value(struct pevent_plugin_option *op, const char *val)\r\n{\r\nchar *op_val;\r\nif (!val) {\r\nif (op->value)\r\nreturn 0;\r\nop->set ^= 1;\r\nreturn 0;\r\n}\r\nif (op->value) {\r\nop->value = val;\r\nreturn 0;\r\n}\r\nop_val = strdup(val);\r\nif (!op_val)\r\nreturn -1;\r\nlower_case(op_val);\r\nif (strcmp(val, "1") == 0 || strcmp(val, "true") == 0)\r\nop->set = 1;\r\nelse if (strcmp(val, "0") == 0 || strcmp(val, "false") == 0)\r\nop->set = 0;\r\nfree(op_val);\r\nreturn 0;\r\n}\r\nchar **traceevent_plugin_list_options(void)\r\n{\r\nstruct registered_plugin_options *reg;\r\nstruct pevent_plugin_option *op;\r\nchar **list = NULL;\r\nchar *name;\r\nint count = 0;\r\nfor (reg = registered_options; reg; reg = reg->next) {\r\nfor (op = reg->options; op->name; op++) {\r\nchar *alias = op->plugin_alias ? op->plugin_alias : op->file;\r\nchar **temp = list;\r\nname = malloc(strlen(op->name) + strlen(alias) + 2);\r\nif (!name)\r\ngoto err;\r\nsprintf(name, "%s:%s", alias, op->name);\r\nlist = realloc(list, count + 2);\r\nif (!list) {\r\nlist = temp;\r\nfree(name);\r\ngoto err;\r\n}\r\nlist[count++] = name;\r\nlist[count] = NULL;\r\n}\r\n}\r\nreturn list;\r\nerr:\r\nwhile (--count >= 0)\r\nfree(list[count]);\r\nfree(list);\r\nreturn INVALID_PLUGIN_LIST_OPTION;\r\n}\r\nvoid traceevent_plugin_free_options_list(char **list)\r\n{\r\nint i;\r\nif (!list)\r\nreturn;\r\nif (list == INVALID_PLUGIN_LIST_OPTION)\r\nreturn;\r\nfor (i = 0; list[i]; i++)\r\nfree(list[i]);\r\nfree(list);\r\n}\r\nstatic int\r\nupdate_option(const char *file, struct pevent_plugin_option *option)\r\n{\r\nstruct trace_plugin_options *op;\r\nchar *plugin;\r\nint ret = 0;\r\nif (option->plugin_alias) {\r\nplugin = strdup(option->plugin_alias);\r\nif (!plugin)\r\nreturn -1;\r\n} else {\r\nchar *p;\r\nplugin = strdup(file);\r\nif (!plugin)\r\nreturn -1;\r\np = strstr(plugin, ".");\r\nif (p)\r\n*p = '\0';\r\n}\r\nfor (op = trace_plugin_options; op; op = op->next) {\r\nif (!op->plugin)\r\ncontinue;\r\nif (strcmp(op->plugin, plugin) != 0)\r\ncontinue;\r\nif (strcmp(op->option, option->name) != 0)\r\ncontinue;\r\nret = update_option_value(option, op->value);\r\nif (ret)\r\ngoto out;\r\nbreak;\r\n}\r\nfor (op = trace_plugin_options; op; op = op->next) {\r\nif (op->plugin)\r\ncontinue;\r\nif (strcmp(op->option, option->name) != 0)\r\ncontinue;\r\nret = update_option_value(option, op->value);\r\nbreak;\r\n}\r\nout:\r\nfree(plugin);\r\nreturn ret;\r\n}\r\nint traceevent_plugin_add_options(const char *name,\r\nstruct pevent_plugin_option *options)\r\n{\r\nstruct registered_plugin_options *reg;\r\nreg = malloc(sizeof(*reg));\r\nif (!reg)\r\nreturn -1;\r\nreg->next = registered_options;\r\nreg->options = options;\r\nregistered_options = reg;\r\nwhile (options->name) {\r\nupdate_option(name, options);\r\noptions++;\r\n}\r\nreturn 0;\r\n}\r\nvoid traceevent_plugin_remove_options(struct pevent_plugin_option *options)\r\n{\r\nstruct registered_plugin_options **last;\r\nstruct registered_plugin_options *reg;\r\nfor (last = &registered_options; *last; last = &(*last)->next) {\r\nif ((*last)->options == options) {\r\nreg = *last;\r\n*last = reg->next;\r\nfree(reg);\r\nreturn;\r\n}\r\n}\r\n}\r\nvoid traceevent_print_plugins(struct trace_seq *s,\r\nconst char *prefix, const char *suffix,\r\nconst struct plugin_list *list)\r\n{\r\nwhile (list) {\r\ntrace_seq_printf(s, "%s%s%s", prefix, list->name, suffix);\r\nlist = list->next;\r\n}\r\n}\r\nstatic void\r\nload_plugin(struct pevent *pevent, const char *path,\r\nconst char *file, void *data)\r\n{\r\nstruct plugin_list **plugin_list = data;\r\npevent_plugin_load_func func;\r\nstruct plugin_list *list;\r\nconst char *alias;\r\nchar *plugin;\r\nvoid *handle;\r\nplugin = malloc(strlen(path) + strlen(file) + 2);\r\nif (!plugin) {\r\nwarning("could not allocate plugin memory\n");\r\nreturn;\r\n}\r\nstrcpy(plugin, path);\r\nstrcat(plugin, "/");\r\nstrcat(plugin, file);\r\nhandle = dlopen(plugin, RTLD_NOW | RTLD_GLOBAL);\r\nif (!handle) {\r\nwarning("could not load plugin '%s'\n%s\n",\r\nplugin, dlerror());\r\ngoto out_free;\r\n}\r\nalias = dlsym(handle, PEVENT_PLUGIN_ALIAS_NAME);\r\nif (!alias)\r\nalias = file;\r\nfunc = dlsym(handle, PEVENT_PLUGIN_LOADER_NAME);\r\nif (!func) {\r\nwarning("could not find func '%s' in plugin '%s'\n%s\n",\r\nPEVENT_PLUGIN_LOADER_NAME, plugin, dlerror());\r\ngoto out_free;\r\n}\r\nlist = malloc(sizeof(*list));\r\nif (!list) {\r\nwarning("could not allocate plugin memory\n");\r\ngoto out_free;\r\n}\r\nlist->next = *plugin_list;\r\nlist->handle = handle;\r\nlist->name = plugin;\r\n*plugin_list = list;\r\npr_stat("registering plugin: %s", plugin);\r\nfunc(pevent);\r\nreturn;\r\nout_free:\r\nfree(plugin);\r\n}\r\nstatic void\r\nload_plugins_dir(struct pevent *pevent, const char *suffix,\r\nconst char *path,\r\nvoid (*load_plugin)(struct pevent *pevent,\r\nconst char *path,\r\nconst char *name,\r\nvoid *data),\r\nvoid *data)\r\n{\r\nstruct dirent *dent;\r\nstruct stat st;\r\nDIR *dir;\r\nint ret;\r\nret = stat(path, &st);\r\nif (ret < 0)\r\nreturn;\r\nif (!S_ISDIR(st.st_mode))\r\nreturn;\r\ndir = opendir(path);\r\nif (!dir)\r\nreturn;\r\nwhile ((dent = readdir(dir))) {\r\nconst char *name = dent->d_name;\r\nif (strcmp(name, ".") == 0 ||\r\nstrcmp(name, "..") == 0)\r\ncontinue;\r\nif (strcmp(name + (strlen(name) - strlen(suffix)), suffix) != 0)\r\ncontinue;\r\nload_plugin(pevent, path, name, data);\r\n}\r\nclosedir(dir);\r\n}\r\nstatic void\r\nload_plugins(struct pevent *pevent, const char *suffix,\r\nvoid (*load_plugin)(struct pevent *pevent,\r\nconst char *path,\r\nconst char *name,\r\nvoid *data),\r\nvoid *data)\r\n{\r\nchar *home;\r\nchar *path;\r\nchar *envdir;\r\nif (pevent->flags & PEVENT_DISABLE_PLUGINS)\r\nreturn;\r\n#ifdef PLUGIN_DIR\r\nif (!(pevent->flags & PEVENT_DISABLE_SYS_PLUGINS))\r\nload_plugins_dir(pevent, suffix, PLUGIN_DIR,\r\nload_plugin, data);\r\n#endif\r\nenvdir = getenv("TRACEEVENT_PLUGIN_DIR");\r\nif (envdir)\r\nload_plugins_dir(pevent, suffix, envdir, load_plugin, data);\r\nhome = getenv("HOME");\r\nif (!home)\r\nreturn;\r\npath = malloc(strlen(home) + strlen(LOCAL_PLUGIN_DIR) + 2);\r\nif (!path) {\r\nwarning("could not allocate plugin memory\n");\r\nreturn;\r\n}\r\nstrcpy(path, home);\r\nstrcat(path, "/");\r\nstrcat(path, LOCAL_PLUGIN_DIR);\r\nload_plugins_dir(pevent, suffix, path, load_plugin, data);\r\nfree(path);\r\n}\r\nstruct plugin_list*\r\ntraceevent_load_plugins(struct pevent *pevent)\r\n{\r\nstruct plugin_list *list = NULL;\r\nload_plugins(pevent, ".so", load_plugin, &list);\r\nreturn list;\r\n}\r\nvoid\r\ntraceevent_unload_plugins(struct plugin_list *plugin_list, struct pevent *pevent)\r\n{\r\npevent_plugin_unload_func func;\r\nstruct plugin_list *list;\r\nwhile (plugin_list) {\r\nlist = plugin_list;\r\nplugin_list = list->next;\r\nfunc = dlsym(list->handle, PEVENT_PLUGIN_UNLOADER_NAME);\r\nif (func)\r\nfunc(pevent);\r\ndlclose(list->handle);\r\nfree(list->name);\r\nfree(list);\r\n}\r\n}
