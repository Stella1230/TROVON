static void default_release(struct device *dev)\r\n{\r\nsnd_hdac_device_exit(container_of(dev, struct hdac_device, dev));\r\n}\r\nint snd_hdac_device_init(struct hdac_device *codec, struct hdac_bus *bus,\r\nconst char *name, unsigned int addr)\r\n{\r\nstruct device *dev;\r\nhda_nid_t fg;\r\nint err;\r\ndev = &codec->dev;\r\ndevice_initialize(dev);\r\ndev->parent = bus->dev;\r\ndev->bus = &snd_hda_bus_type;\r\ndev->release = default_release;\r\ndev->groups = hdac_dev_attr_groups;\r\ndev_set_name(dev, "%s", name);\r\ndevice_enable_async_suspend(dev);\r\ncodec->bus = bus;\r\ncodec->addr = addr;\r\ncodec->type = HDA_DEV_CORE;\r\npm_runtime_set_active(&codec->dev);\r\npm_runtime_get_noresume(&codec->dev);\r\natomic_set(&codec->in_pm, 0);\r\nerr = snd_hdac_bus_add_device(bus, codec);\r\nif (err < 0)\r\ngoto error;\r\ncodec->vendor_id = snd_hdac_read_parm(codec, AC_NODE_ROOT,\r\nAC_PAR_VENDOR_ID);\r\nif (codec->vendor_id == -1) {\r\ncodec->vendor_id = snd_hdac_read_parm(codec, AC_NODE_ROOT,\r\nAC_PAR_VENDOR_ID);\r\n}\r\ncodec->subsystem_id = snd_hdac_read_parm(codec, AC_NODE_ROOT,\r\nAC_PAR_SUBSYSTEM_ID);\r\ncodec->revision_id = snd_hdac_read_parm(codec, AC_NODE_ROOT,\r\nAC_PAR_REV_ID);\r\nsetup_fg_nodes(codec);\r\nif (!codec->afg && !codec->mfg) {\r\ndev_err(dev, "no AFG or MFG node found\n");\r\nerr = -ENODEV;\r\ngoto error;\r\n}\r\nfg = codec->afg ? codec->afg : codec->mfg;\r\nerr = snd_hdac_refresh_widgets(codec);\r\nif (err < 0)\r\ngoto error;\r\ncodec->power_caps = snd_hdac_read_parm(codec, fg, AC_PAR_POWER_STATE);\r\nif (codec->subsystem_id == -1 || codec->subsystem_id == 0)\r\nsnd_hdac_read(codec, fg, AC_VERB_GET_SUBSYSTEM_ID, 0,\r\n&codec->subsystem_id);\r\nerr = get_codec_vendor_name(codec);\r\nif (err < 0)\r\ngoto error;\r\ncodec->chip_name = kasprintf(GFP_KERNEL, "ID %x",\r\ncodec->vendor_id & 0xffff);\r\nif (!codec->chip_name) {\r\nerr = -ENOMEM;\r\ngoto error;\r\n}\r\nreturn 0;\r\nerror:\r\nput_device(&codec->dev);\r\nreturn err;\r\n}\r\nvoid snd_hdac_device_exit(struct hdac_device *codec)\r\n{\r\npm_runtime_put_noidle(&codec->dev);\r\nsnd_hdac_bus_remove_device(codec->bus, codec);\r\nkfree(codec->vendor_name);\r\nkfree(codec->chip_name);\r\n}\r\nint snd_hdac_device_register(struct hdac_device *codec)\r\n{\r\nint err;\r\nerr = device_add(&codec->dev);\r\nif (err < 0)\r\nreturn err;\r\nerr = hda_widget_sysfs_init(codec);\r\nif (err < 0) {\r\ndevice_del(&codec->dev);\r\nreturn err;\r\n}\r\nreturn 0;\r\n}\r\nvoid snd_hdac_device_unregister(struct hdac_device *codec)\r\n{\r\nif (device_is_registered(&codec->dev)) {\r\nhda_widget_sysfs_exit(codec);\r\ndevice_del(&codec->dev);\r\n}\r\n}\r\nint snd_hdac_device_set_chip_name(struct hdac_device *codec, const char *name)\r\n{\r\nchar *newname;\r\nif (!name)\r\nreturn 0;\r\nnewname = kstrdup(name, GFP_KERNEL);\r\nif (!newname)\r\nreturn -ENOMEM;\r\nkfree(codec->chip_name);\r\ncodec->chip_name = newname;\r\nreturn 0;\r\n}\r\nint snd_hdac_codec_modalias(struct hdac_device *codec, char *buf, size_t size)\r\n{\r\nreturn snprintf(buf, size, "hdaudio:v%08Xr%08Xa%02X\n",\r\ncodec->vendor_id, codec->revision_id, codec->type);\r\n}\r\nunsigned int snd_hdac_make_cmd(struct hdac_device *codec, hda_nid_t nid,\r\nunsigned int verb, unsigned int parm)\r\n{\r\nu32 val, addr;\r\naddr = codec->addr;\r\nif ((addr & ~0xf) || (nid & ~0x7f) ||\r\n(verb & ~0xfff) || (parm & ~0xffff)) {\r\ndev_err(&codec->dev, "out of range cmd %x:%x:%x:%x\n",\r\naddr, nid, verb, parm);\r\nreturn -1;\r\n}\r\nval = addr << 28;\r\nval |= (u32)nid << 20;\r\nval |= verb << 8;\r\nval |= parm;\r\nreturn val;\r\n}\r\nint snd_hdac_exec_verb(struct hdac_device *codec, unsigned int cmd,\r\nunsigned int flags, unsigned int *res)\r\n{\r\nif (codec->exec_verb)\r\nreturn codec->exec_verb(codec, cmd, flags, res);\r\nreturn snd_hdac_bus_exec_verb(codec->bus, codec->addr, cmd, res);\r\n}\r\nint snd_hdac_read(struct hdac_device *codec, hda_nid_t nid,\r\nunsigned int verb, unsigned int parm, unsigned int *res)\r\n{\r\nunsigned int cmd = snd_hdac_make_cmd(codec, nid, verb, parm);\r\nreturn snd_hdac_exec_verb(codec, cmd, 0, res);\r\n}\r\nint _snd_hdac_read_parm(struct hdac_device *codec, hda_nid_t nid, int parm,\r\nunsigned int *res)\r\n{\r\nunsigned int cmd;\r\ncmd = snd_hdac_regmap_encode_verb(nid, AC_VERB_PARAMETERS) | parm;\r\nreturn snd_hdac_regmap_read_raw(codec, cmd, res);\r\n}\r\nint snd_hdac_read_parm_uncached(struct hdac_device *codec, hda_nid_t nid,\r\nint parm)\r\n{\r\nint val;\r\nif (codec->regmap)\r\nregcache_cache_bypass(codec->regmap, true);\r\nval = snd_hdac_read_parm(codec, nid, parm);\r\nif (codec->regmap)\r\nregcache_cache_bypass(codec->regmap, false);\r\nreturn val;\r\n}\r\nint snd_hdac_override_parm(struct hdac_device *codec, hda_nid_t nid,\r\nunsigned int parm, unsigned int val)\r\n{\r\nunsigned int verb = (AC_VERB_PARAMETERS << 8) | (nid << 20) | parm;\r\nint err;\r\nif (!codec->regmap)\r\nreturn -EINVAL;\r\ncodec->caps_overwriting = true;\r\nerr = snd_hdac_regmap_write_raw(codec, verb, val);\r\ncodec->caps_overwriting = false;\r\nreturn err;\r\n}\r\nint snd_hdac_get_sub_nodes(struct hdac_device *codec, hda_nid_t nid,\r\nhda_nid_t *start_id)\r\n{\r\nunsigned int parm;\r\nparm = snd_hdac_read_parm_uncached(codec, nid, AC_PAR_NODE_COUNT);\r\nif (parm == -1) {\r\n*start_id = 0;\r\nreturn 0;\r\n}\r\n*start_id = (parm >> 16) & 0x7fff;\r\nreturn (int)(parm & 0x7fff);\r\n}\r\nstatic void setup_fg_nodes(struct hdac_device *codec)\r\n{\r\nint i, total_nodes, function_id;\r\nhda_nid_t nid;\r\ntotal_nodes = snd_hdac_get_sub_nodes(codec, AC_NODE_ROOT, &nid);\r\nfor (i = 0; i < total_nodes; i++, nid++) {\r\nfunction_id = snd_hdac_read_parm(codec, nid,\r\nAC_PAR_FUNCTION_TYPE);\r\nswitch (function_id & 0xff) {\r\ncase AC_GRP_AUDIO_FUNCTION:\r\ncodec->afg = nid;\r\ncodec->afg_function_id = function_id & 0xff;\r\ncodec->afg_unsol = (function_id >> 8) & 1;\r\nbreak;\r\ncase AC_GRP_MODEM_FUNCTION:\r\ncodec->mfg = nid;\r\ncodec->mfg_function_id = function_id & 0xff;\r\ncodec->mfg_unsol = (function_id >> 8) & 1;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\n}\r\nint snd_hdac_refresh_widgets(struct hdac_device *codec)\r\n{\r\nhda_nid_t start_nid;\r\nint nums;\r\nnums = snd_hdac_get_sub_nodes(codec, codec->afg, &start_nid);\r\nif (!start_nid || nums <= 0 || nums >= 0xff) {\r\ndev_err(&codec->dev, "cannot read sub nodes for FG 0x%02x\n",\r\ncodec->afg);\r\nreturn -EINVAL;\r\n}\r\ncodec->num_nodes = nums;\r\ncodec->start_nid = start_nid;\r\ncodec->end_nid = start_nid + nums;\r\nreturn 0;\r\n}\r\nint snd_hdac_refresh_widget_sysfs(struct hdac_device *codec)\r\n{\r\nint ret;\r\nif (device_is_registered(&codec->dev))\r\nhda_widget_sysfs_exit(codec);\r\nret = snd_hdac_refresh_widgets(codec);\r\nif (ret) {\r\ndev_err(&codec->dev, "failed to refresh widget: %d\n", ret);\r\nreturn ret;\r\n}\r\nif (device_is_registered(&codec->dev)) {\r\nret = hda_widget_sysfs_init(codec);\r\nif (ret) {\r\ndev_err(&codec->dev, "failed to init sysfs: %d\n", ret);\r\nreturn ret;\r\n}\r\n}\r\nreturn ret;\r\n}\r\nstatic unsigned int get_num_conns(struct hdac_device *codec, hda_nid_t nid)\r\n{\r\nunsigned int wcaps = get_wcaps(codec, nid);\r\nunsigned int parm;\r\nif (!(wcaps & AC_WCAP_CONN_LIST) &&\r\nget_wcaps_type(wcaps) != AC_WID_VOL_KNB)\r\nreturn 0;\r\nparm = snd_hdac_read_parm(codec, nid, AC_PAR_CONNLIST_LEN);\r\nif (parm == -1)\r\nparm = 0;\r\nreturn parm;\r\n}\r\nint snd_hdac_get_connections(struct hdac_device *codec, hda_nid_t nid,\r\nhda_nid_t *conn_list, int max_conns)\r\n{\r\nunsigned int parm;\r\nint i, conn_len, conns, err;\r\nunsigned int shift, num_elems, mask;\r\nhda_nid_t prev_nid;\r\nint null_count = 0;\r\nparm = get_num_conns(codec, nid);\r\nif (!parm)\r\nreturn 0;\r\nif (parm & AC_CLIST_LONG) {\r\nshift = 16;\r\nnum_elems = 2;\r\n} else {\r\nshift = 8;\r\nnum_elems = 4;\r\n}\r\nconn_len = parm & AC_CLIST_LENGTH;\r\nmask = (1 << (shift-1)) - 1;\r\nif (!conn_len)\r\nreturn 0;\r\nif (conn_len == 1) {\r\nerr = snd_hdac_read(codec, nid, AC_VERB_GET_CONNECT_LIST, 0,\r\n&parm);\r\nif (err < 0)\r\nreturn err;\r\nif (conn_list)\r\nconn_list[0] = parm & mask;\r\nreturn 1;\r\n}\r\nconns = 0;\r\nprev_nid = 0;\r\nfor (i = 0; i < conn_len; i++) {\r\nint range_val;\r\nhda_nid_t val, n;\r\nif (i % num_elems == 0) {\r\nerr = snd_hdac_read(codec, nid,\r\nAC_VERB_GET_CONNECT_LIST, i,\r\n&parm);\r\nif (err < 0)\r\nreturn -EIO;\r\n}\r\nrange_val = !!(parm & (1 << (shift-1)));\r\nval = parm & mask;\r\nif (val == 0 && null_count++) {\r\ndev_dbg(&codec->dev,\r\n"invalid CONNECT_LIST verb %x[%i]:%x\n",\r\nnid, i, parm);\r\nreturn 0;\r\n}\r\nparm >>= shift;\r\nif (range_val) {\r\nif (!prev_nid || prev_nid >= val) {\r\ndev_warn(&codec->dev,\r\n"invalid dep_range_val %x:%x\n",\r\nprev_nid, val);\r\ncontinue;\r\n}\r\nfor (n = prev_nid + 1; n <= val; n++) {\r\nif (conn_list) {\r\nif (conns >= max_conns)\r\nreturn -ENOSPC;\r\nconn_list[conns] = n;\r\n}\r\nconns++;\r\n}\r\n} else {\r\nif (conn_list) {\r\nif (conns >= max_conns)\r\nreturn -ENOSPC;\r\nconn_list[conns] = val;\r\n}\r\nconns++;\r\n}\r\nprev_nid = val;\r\n}\r\nreturn conns;\r\n}\r\nint snd_hdac_power_up(struct hdac_device *codec)\r\n{\r\nreturn pm_runtime_get_sync(&codec->dev);\r\n}\r\nint snd_hdac_power_down(struct hdac_device *codec)\r\n{\r\nstruct device *dev = &codec->dev;\r\npm_runtime_mark_last_busy(dev);\r\nreturn pm_runtime_put_autosuspend(dev);\r\n}\r\nint snd_hdac_power_up_pm(struct hdac_device *codec)\r\n{\r\nif (!atomic_inc_not_zero(&codec->in_pm))\r\nreturn snd_hdac_power_up(codec);\r\nreturn 0;\r\n}\r\nint snd_hdac_power_down_pm(struct hdac_device *codec)\r\n{\r\nif (atomic_dec_if_positive(&codec->in_pm) < 0)\r\nreturn snd_hdac_power_down(codec);\r\nreturn 0;\r\n}\r\nint snd_hdac_link_power(struct hdac_device *codec, bool enable)\r\n{\r\nif (!codec->link_power_control)\r\nreturn 0;\r\nif (codec->bus->ops->link_power)\r\nreturn codec->bus->ops->link_power(codec->bus, enable);\r\nelse\r\nreturn -EINVAL;\r\n}\r\nstatic int get_codec_vendor_name(struct hdac_device *codec)\r\n{\r\nconst struct hda_vendor_id *c;\r\nu16 vendor_id = codec->vendor_id >> 16;\r\nfor (c = hda_vendor_ids; c->id; c++) {\r\nif (c->id == vendor_id) {\r\ncodec->vendor_name = kstrdup(c->name, GFP_KERNEL);\r\nreturn codec->vendor_name ? 0 : -ENOMEM;\r\n}\r\n}\r\ncodec->vendor_name = kasprintf(GFP_KERNEL, "Generic %04x", vendor_id);\r\nreturn codec->vendor_name ? 0 : -ENOMEM;\r\n}\r\nunsigned int snd_hdac_calc_stream_format(unsigned int rate,\r\nunsigned int channels,\r\nunsigned int format,\r\nunsigned int maxbps,\r\nunsigned short spdif_ctls)\r\n{\r\nint i;\r\nunsigned int val = 0;\r\nfor (i = 0; rate_bits[i].hz; i++)\r\nif (rate_bits[i].hz == rate) {\r\nval = rate_bits[i].hda_fmt;\r\nbreak;\r\n}\r\nif (!rate_bits[i].hz)\r\nreturn 0;\r\nif (channels == 0 || channels > 8)\r\nreturn 0;\r\nval |= channels - 1;\r\nswitch (snd_pcm_format_width(format)) {\r\ncase 8:\r\nval |= AC_FMT_BITS_8;\r\nbreak;\r\ncase 16:\r\nval |= AC_FMT_BITS_16;\r\nbreak;\r\ncase 20:\r\ncase 24:\r\ncase 32:\r\nif (maxbps >= 32 || format == SNDRV_PCM_FORMAT_FLOAT_LE)\r\nval |= AC_FMT_BITS_32;\r\nelse if (maxbps >= 24)\r\nval |= AC_FMT_BITS_24;\r\nelse\r\nval |= AC_FMT_BITS_20;\r\nbreak;\r\ndefault:\r\nreturn 0;\r\n}\r\nif (spdif_ctls & AC_DIG1_NONAUDIO)\r\nval |= AC_FMT_TYPE_NON_PCM;\r\nreturn val;\r\n}\r\nstatic unsigned int query_pcm_param(struct hdac_device *codec, hda_nid_t nid)\r\n{\r\nunsigned int val = 0;\r\nif (nid != codec->afg &&\r\n(get_wcaps(codec, nid) & AC_WCAP_FORMAT_OVRD))\r\nval = snd_hdac_read_parm(codec, nid, AC_PAR_PCM);\r\nif (!val || val == -1)\r\nval = snd_hdac_read_parm(codec, codec->afg, AC_PAR_PCM);\r\nif (!val || val == -1)\r\nreturn 0;\r\nreturn val;\r\n}\r\nstatic unsigned int query_stream_param(struct hdac_device *codec, hda_nid_t nid)\r\n{\r\nunsigned int streams = snd_hdac_read_parm(codec, nid, AC_PAR_STREAM);\r\nif (!streams || streams == -1)\r\nstreams = snd_hdac_read_parm(codec, codec->afg, AC_PAR_STREAM);\r\nif (!streams || streams == -1)\r\nreturn 0;\r\nreturn streams;\r\n}\r\nint snd_hdac_query_supported_pcm(struct hdac_device *codec, hda_nid_t nid,\r\nu32 *ratesp, u64 *formatsp, unsigned int *bpsp)\r\n{\r\nunsigned int i, val, wcaps;\r\nwcaps = get_wcaps(codec, nid);\r\nval = query_pcm_param(codec, nid);\r\nif (ratesp) {\r\nu32 rates = 0;\r\nfor (i = 0; i < AC_PAR_PCM_RATE_BITS; i++) {\r\nif (val & (1 << i))\r\nrates |= rate_bits[i].alsa_bits;\r\n}\r\nif (rates == 0) {\r\ndev_err(&codec->dev,\r\n"rates == 0 (nid=0x%x, val=0x%x, ovrd=%i)\n",\r\nnid, val,\r\n(wcaps & AC_WCAP_FORMAT_OVRD) ? 1 : 0);\r\nreturn -EIO;\r\n}\r\n*ratesp = rates;\r\n}\r\nif (formatsp || bpsp) {\r\nu64 formats = 0;\r\nunsigned int streams, bps;\r\nstreams = query_stream_param(codec, nid);\r\nif (!streams)\r\nreturn -EIO;\r\nbps = 0;\r\nif (streams & AC_SUPFMT_PCM) {\r\nif (val & AC_SUPPCM_BITS_8) {\r\nformats |= SNDRV_PCM_FMTBIT_U8;\r\nbps = 8;\r\n}\r\nif (val & AC_SUPPCM_BITS_16) {\r\nformats |= SNDRV_PCM_FMTBIT_S16_LE;\r\nbps = 16;\r\n}\r\nif (wcaps & AC_WCAP_DIGITAL) {\r\nif (val & AC_SUPPCM_BITS_32)\r\nformats |= SNDRV_PCM_FMTBIT_IEC958_SUBFRAME_LE;\r\nif (val & (AC_SUPPCM_BITS_20|AC_SUPPCM_BITS_24))\r\nformats |= SNDRV_PCM_FMTBIT_S32_LE;\r\nif (val & AC_SUPPCM_BITS_24)\r\nbps = 24;\r\nelse if (val & AC_SUPPCM_BITS_20)\r\nbps = 20;\r\n} else if (val & (AC_SUPPCM_BITS_20|AC_SUPPCM_BITS_24|\r\nAC_SUPPCM_BITS_32)) {\r\nformats |= SNDRV_PCM_FMTBIT_S32_LE;\r\nif (val & AC_SUPPCM_BITS_32)\r\nbps = 32;\r\nelse if (val & AC_SUPPCM_BITS_24)\r\nbps = 24;\r\nelse if (val & AC_SUPPCM_BITS_20)\r\nbps = 20;\r\n}\r\n}\r\n#if 0\r\nif (streams & AC_SUPFMT_FLOAT32) {\r\nformats |= SNDRV_PCM_FMTBIT_FLOAT_LE;\r\nif (!bps)\r\nbps = 32;\r\n}\r\n#endif\r\nif (streams == AC_SUPFMT_AC3) {\r\nformats |= SNDRV_PCM_FMTBIT_U8;\r\nbps = 8;\r\n}\r\nif (formats == 0) {\r\ndev_err(&codec->dev,\r\n"formats == 0 (nid=0x%x, val=0x%x, ovrd=%i, streams=0x%x)\n",\r\nnid, val,\r\n(wcaps & AC_WCAP_FORMAT_OVRD) ? 1 : 0,\r\nstreams);\r\nreturn -EIO;\r\n}\r\nif (formatsp)\r\n*formatsp = formats;\r\nif (bpsp)\r\n*bpsp = bps;\r\n}\r\nreturn 0;\r\n}\r\nbool snd_hdac_is_supported_format(struct hdac_device *codec, hda_nid_t nid,\r\nunsigned int format)\r\n{\r\nint i;\r\nunsigned int val = 0, rate, stream;\r\nval = query_pcm_param(codec, nid);\r\nif (!val)\r\nreturn false;\r\nrate = format & 0xff00;\r\nfor (i = 0; i < AC_PAR_PCM_RATE_BITS; i++)\r\nif (rate_bits[i].hda_fmt == rate) {\r\nif (val & (1 << i))\r\nbreak;\r\nreturn false;\r\n}\r\nif (i >= AC_PAR_PCM_RATE_BITS)\r\nreturn false;\r\nstream = query_stream_param(codec, nid);\r\nif (!stream)\r\nreturn false;\r\nif (stream & AC_SUPFMT_PCM) {\r\nswitch (format & 0xf0) {\r\ncase 0x00:\r\nif (!(val & AC_SUPPCM_BITS_8))\r\nreturn false;\r\nbreak;\r\ncase 0x10:\r\nif (!(val & AC_SUPPCM_BITS_16))\r\nreturn false;\r\nbreak;\r\ncase 0x20:\r\nif (!(val & AC_SUPPCM_BITS_20))\r\nreturn false;\r\nbreak;\r\ncase 0x30:\r\nif (!(val & AC_SUPPCM_BITS_24))\r\nreturn false;\r\nbreak;\r\ncase 0x40:\r\nif (!(val & AC_SUPPCM_BITS_32))\r\nreturn false;\r\nbreak;\r\ndefault:\r\nreturn false;\r\n}\r\n} else {\r\n}\r\nreturn true;\r\n}\r\nstatic unsigned int codec_read(struct hdac_device *hdac, hda_nid_t nid,\r\nint flags, unsigned int verb, unsigned int parm)\r\n{\r\nunsigned int cmd = snd_hdac_make_cmd(hdac, nid, verb, parm);\r\nunsigned int res;\r\nif (snd_hdac_exec_verb(hdac, cmd, flags, &res))\r\nreturn -1;\r\nreturn res;\r\n}\r\nstatic int codec_write(struct hdac_device *hdac, hda_nid_t nid,\r\nint flags, unsigned int verb, unsigned int parm)\r\n{\r\nunsigned int cmd = snd_hdac_make_cmd(hdac, nid, verb, parm);\r\nreturn snd_hdac_exec_verb(hdac, cmd, flags, NULL);\r\n}\r\nint snd_hdac_codec_read(struct hdac_device *hdac, hda_nid_t nid,\r\nint flags, unsigned int verb, unsigned int parm)\r\n{\r\nreturn codec_read(hdac, nid, flags, verb, parm);\r\n}\r\nint snd_hdac_codec_write(struct hdac_device *hdac, hda_nid_t nid,\r\nint flags, unsigned int verb, unsigned int parm)\r\n{\r\nreturn codec_write(hdac, nid, flags, verb, parm);\r\n}\r\nbool snd_hdac_check_power_state(struct hdac_device *hdac,\r\nhda_nid_t nid, unsigned int target_state)\r\n{\r\nunsigned int state = codec_read(hdac, nid, 0,\r\nAC_VERB_GET_POWER_STATE, 0);\r\nif (state & AC_PWRST_ERROR)\r\nreturn true;\r\nstate = (state >> 4) & 0x0f;\r\nreturn (state == target_state);\r\n}
