int cmd_idle_set(int argc, char **argv)\r\n{\r\nextern char *optarg;\r\nextern int optind, opterr, optopt;\r\nint ret = 0, cont = 1, param = 0, disabled;\r\nunsigned long long latency = 0, state_latency;\r\nunsigned int cpu = 0, idlestate = 0, idlestates = 0;\r\nchar *endptr;\r\ndo {\r\nret = getopt_long(argc, argv, "d:e:ED:", info_opts, NULL);\r\nif (ret == -1)\r\nbreak;\r\nswitch (ret) {\r\ncase '?':\r\nparam = '?';\r\ncont = 0;\r\nbreak;\r\ncase 'd':\r\nif (param) {\r\nparam = -1;\r\ncont = 0;\r\nbreak;\r\n}\r\nparam = ret;\r\nidlestate = atoi(optarg);\r\nbreak;\r\ncase 'e':\r\nif (param) {\r\nparam = -1;\r\ncont = 0;\r\nbreak;\r\n}\r\nparam = ret;\r\nidlestate = atoi(optarg);\r\nbreak;\r\ncase 'D':\r\nif (param) {\r\nparam = -1;\r\ncont = 0;\r\nbreak;\r\n}\r\nparam = ret;\r\nlatency = strtoull(optarg, &endptr, 10);\r\nif (*endptr != '\0') {\r\nprintf(_("Bad latency value: %s\n"), optarg);\r\nexit(EXIT_FAILURE);\r\n}\r\nbreak;\r\ncase 'E':\r\nif (param) {\r\nparam = -1;\r\ncont = 0;\r\nbreak;\r\n}\r\nparam = ret;\r\nbreak;\r\ncase -1:\r\ncont = 0;\r\nbreak;\r\n}\r\n} while (cont);\r\nswitch (param) {\r\ncase -1:\r\nprintf(_("You can't specify more than one "\r\n"output-specific argument\n"));\r\nexit(EXIT_FAILURE);\r\ncase '?':\r\nprintf(_("invalid or unknown argument\n"));\r\nexit(EXIT_FAILURE);\r\n}\r\nif (bitmask_isallclear(cpus_chosen))\r\nbitmask_setall(cpus_chosen);\r\nfor (cpu = bitmask_first(cpus_chosen);\r\ncpu <= bitmask_last(cpus_chosen); cpu++) {\r\nif (!bitmask_isbitset(cpus_chosen, cpu))\r\ncontinue;\r\nif (sysfs_is_cpu_online(cpu) != 1)\r\ncontinue;\r\nidlestates = sysfs_get_idlestate_count(cpu);\r\nif (idlestates <= 0)\r\ncontinue;\r\nswitch (param) {\r\ncase 'd':\r\nret = sysfs_idlestate_disable(cpu, idlestate, 1);\r\nif (ret == 0)\r\nprintf(_("Idlestate %u disabled on CPU %u\n"), idlestate, cpu);\r\nelse if (ret == -1)\r\nprintf(_("Idlestate %u not available on CPU %u\n"),\r\nidlestate, cpu);\r\nelse if (ret == -2)\r\nprintf(_("Idlestate disabling not supported by kernel\n"));\r\nelse\r\nprintf(_("Idlestate %u not disabled on CPU %u\n"),\r\nidlestate, cpu);\r\nbreak;\r\ncase 'e':\r\nret = sysfs_idlestate_disable(cpu, idlestate, 0);\r\nif (ret == 0)\r\nprintf(_("Idlestate %u enabled on CPU %u\n"), idlestate, cpu);\r\nelse if (ret == -1)\r\nprintf(_("Idlestate %u not available on CPU %u\n"),\r\nidlestate, cpu);\r\nelse if (ret == -2)\r\nprintf(_("Idlestate enabling not supported by kernel\n"));\r\nelse\r\nprintf(_("Idlestate %u not enabled on CPU %u\n"),\r\nidlestate, cpu);\r\nbreak;\r\ncase 'D':\r\nfor (idlestate = 0; idlestate < idlestates; idlestate++) {\r\ndisabled = sysfs_is_idlestate_disabled\r\n(cpu, idlestate);\r\nstate_latency = sysfs_get_idlestate_latency\r\n(cpu, idlestate);\r\nif (disabled == 1) {\r\nif (latency > state_latency){\r\nret = sysfs_idlestate_disable\r\n(cpu, idlestate, 0);\r\nif (ret == 0)\r\nprintf(_("Idlestate %u enabled on CPU %u\n"), idlestate, cpu);\r\n}\r\ncontinue;\r\n}\r\nif (latency <= state_latency){\r\nret = sysfs_idlestate_disable\r\n(cpu, idlestate, 1);\r\nif (ret == 0)\r\nprintf(_("Idlestate %u disabled on CPU %u\n"), idlestate, cpu);\r\n}\r\n}\r\nbreak;\r\ncase 'E':\r\nfor (idlestate = 0; idlestate < idlestates; idlestate++) {\r\ndisabled = sysfs_is_idlestate_disabled\r\n(cpu, idlestate);\r\nif (disabled == 1) {\r\nret = sysfs_idlestate_disable\r\n(cpu, idlestate, 0);\r\nif (ret == 0)\r\nprintf(_("Idlestate %u enabled on CPU %u\n"), idlestate, cpu);\r\n}\r\n}\r\nbreak;\r\ndefault:\r\nprintf(_("Invalid or unknown argument\n"));\r\nexit(EXIT_FAILURE);\r\nbreak;\r\n}\r\n}\r\nreturn EXIT_SUCCESS;\r\n}
