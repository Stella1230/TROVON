blkcnt_t dirty_cnt(struct inode *inode)\r\n{\r\nblkcnt_t cnt = 0;\r\nstruct ccc_object *vob = cl_inode2ccc(inode);\r\nvoid *results[1];\r\nif (inode->i_mapping)\r\ncnt += radix_tree_gang_lookup_tag(&inode->i_mapping->page_tree,\r\nresults, 0, 1,\r\nPAGECACHE_TAG_DIRTY);\r\nif (cnt == 0 && atomic_read(&vob->cob_mmap_cnt) > 0)\r\ncnt = 1;\r\nreturn (cnt > 0) ? 1 : 0;\r\n}\r\nint cl_glimpse_lock(const struct lu_env *env, struct cl_io *io,\r\nstruct inode *inode, struct cl_object *clob, int agl)\r\n{\r\nstruct cl_lock_descr *descr = &ccc_env_info(env)->cti_descr;\r\nstruct cl_inode_info *lli = cl_i2info(inode);\r\nconst struct lu_fid *fid = lu_object_fid(&clob->co_lu);\r\nstruct ccc_io *cio = ccc_env_io(env);\r\nstruct cl_lock *lock;\r\nint result;\r\nresult = 0;\r\nif (!(lli->lli_flags & LLIF_MDS_SIZE_LOCK)) {\r\nCDEBUG(D_DLMTRACE, "Glimpsing inode "DFID"\n", PFID(fid));\r\nif (lli->lli_has_smd) {\r\n*descr = whole_file;\r\ndescr->cld_obj = clob;\r\ndescr->cld_mode = CLM_PHANTOM;\r\ndescr->cld_enq_flags = CEF_ASYNC | CEF_MUST;\r\nif (agl)\r\ndescr->cld_enq_flags |= CEF_AGL;\r\ncio->cui_glimpse = 1;\r\nlock = cl_lock_request(env, io, descr, "glimpse",\r\ncurrent);\r\ncio->cui_glimpse = 0;\r\nif (!lock)\r\nreturn 0;\r\nif (IS_ERR(lock))\r\nreturn PTR_ERR(lock);\r\nLASSERT(agl == 0);\r\nresult = cl_wait(env, lock);\r\nif (result == 0) {\r\ncl_merge_lvb(env, inode);\r\nif (cl_isize_read(inode) > 0 &&\r\ninode->i_blocks == 0) {\r\ninode->i_blocks = dirty_cnt(inode);\r\n}\r\ncl_unuse(env, lock);\r\n}\r\ncl_lock_release(env, lock, "glimpse", current);\r\n} else {\r\nCDEBUG(D_DLMTRACE, "No objects for inode\n");\r\ncl_merge_lvb(env, inode);\r\n}\r\n}\r\nreturn result;\r\n}\r\nstatic int cl_io_get(struct inode *inode, struct lu_env **envout,\r\nstruct cl_io **ioout, int *refcheck)\r\n{\r\nstruct lu_env *env;\r\nstruct cl_io *io;\r\nstruct cl_inode_info *lli = cl_i2info(inode);\r\nstruct cl_object *clob = lli->lli_clob;\r\nint result;\r\nif (S_ISREG(cl_inode_mode(inode))) {\r\nenv = cl_env_get(refcheck);\r\nif (!IS_ERR(env)) {\r\nio = ccc_env_thread_io(env);\r\nio->ci_obj = clob;\r\n*envout = env;\r\n*ioout = io;\r\nresult = 1;\r\n} else\r\nresult = PTR_ERR(env);\r\n} else\r\nresult = 0;\r\nreturn result;\r\n}\r\nint cl_glimpse_size0(struct inode *inode, int agl)\r\n{\r\nstruct lu_env *env = NULL;\r\nstruct cl_io *io = NULL;\r\nint result;\r\nint refcheck;\r\nresult = cl_io_get(inode, &env, &io, &refcheck);\r\nif (result > 0) {\r\nagain:\r\nio->ci_verify_layout = 1;\r\nresult = cl_io_init(env, io, CIT_MISC, io->ci_obj);\r\nif (result > 0)\r\nresult = io->ci_result;\r\nelse if (result == 0)\r\nresult = cl_glimpse_lock(env, io, inode, io->ci_obj,\r\nagl);\r\nOBD_FAIL_TIMEOUT(OBD_FAIL_GLIMPSE_DELAY, 2);\r\ncl_io_fini(env, io);\r\nif (unlikely(io->ci_need_restart))\r\ngoto again;\r\ncl_env_put(env, &refcheck);\r\n}\r\nreturn result;\r\n}\r\nint cl_local_size(struct inode *inode)\r\n{\r\nstruct lu_env *env = NULL;\r\nstruct cl_io *io = NULL;\r\nstruct ccc_thread_info *cti;\r\nstruct cl_object *clob;\r\nstruct cl_lock_descr *descr;\r\nstruct cl_lock *lock;\r\nint result;\r\nint refcheck;\r\nif (!cl_i2info(inode)->lli_has_smd)\r\nreturn 0;\r\nresult = cl_io_get(inode, &env, &io, &refcheck);\r\nif (result <= 0)\r\nreturn result;\r\nclob = io->ci_obj;\r\nresult = cl_io_init(env, io, CIT_MISC, clob);\r\nif (result > 0)\r\nresult = io->ci_result;\r\nelse if (result == 0) {\r\ncti = ccc_env_info(env);\r\ndescr = &cti->cti_descr;\r\n*descr = whole_file;\r\ndescr->cld_obj = clob;\r\nlock = cl_lock_peek(env, io, descr, "localsize", current);\r\nif (lock) {\r\ncl_merge_lvb(env, inode);\r\ncl_unuse(env, lock);\r\ncl_lock_release(env, lock, "localsize", current);\r\nresult = 0;\r\n} else\r\nresult = -ENODATA;\r\n}\r\ncl_io_fini(env, io);\r\ncl_env_put(env, &refcheck);\r\nreturn result;\r\n}
