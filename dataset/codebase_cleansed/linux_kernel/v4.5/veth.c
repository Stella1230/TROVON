static int veth_get_settings(struct net_device *dev, struct ethtool_cmd *cmd)\r\n{\r\ncmd->supported = 0;\r\ncmd->advertising = 0;\r\nethtool_cmd_speed_set(cmd, SPEED_10000);\r\ncmd->duplex = DUPLEX_FULL;\r\ncmd->port = PORT_TP;\r\ncmd->phy_address = 0;\r\ncmd->transceiver = XCVR_INTERNAL;\r\ncmd->autoneg = AUTONEG_DISABLE;\r\ncmd->maxtxpkt = 0;\r\ncmd->maxrxpkt = 0;\r\nreturn 0;\r\n}\r\nstatic void veth_get_drvinfo(struct net_device *dev, struct ethtool_drvinfo *info)\r\n{\r\nstrlcpy(info->driver, DRV_NAME, sizeof(info->driver));\r\nstrlcpy(info->version, DRV_VERSION, sizeof(info->version));\r\n}\r\nstatic void veth_get_strings(struct net_device *dev, u32 stringset, u8 *buf)\r\n{\r\nswitch(stringset) {\r\ncase ETH_SS_STATS:\r\nmemcpy(buf, &ethtool_stats_keys, sizeof(ethtool_stats_keys));\r\nbreak;\r\n}\r\n}\r\nstatic int veth_get_sset_count(struct net_device *dev, int sset)\r\n{\r\nswitch (sset) {\r\ncase ETH_SS_STATS:\r\nreturn ARRAY_SIZE(ethtool_stats_keys);\r\ndefault:\r\nreturn -EOPNOTSUPP;\r\n}\r\n}\r\nstatic void veth_get_ethtool_stats(struct net_device *dev,\r\nstruct ethtool_stats *stats, u64 *data)\r\n{\r\nstruct veth_priv *priv = netdev_priv(dev);\r\nstruct net_device *peer = rtnl_dereference(priv->peer);\r\ndata[0] = peer ? peer->ifindex : 0;\r\n}\r\nstatic netdev_tx_t veth_xmit(struct sk_buff *skb, struct net_device *dev)\r\n{\r\nstruct veth_priv *priv = netdev_priv(dev);\r\nstruct net_device *rcv;\r\nint length = skb->len;\r\nrcu_read_lock();\r\nrcv = rcu_dereference(priv->peer);\r\nif (unlikely(!rcv)) {\r\nkfree_skb(skb);\r\ngoto drop;\r\n}\r\nif (likely(dev_forward_skb(rcv, skb) == NET_RX_SUCCESS)) {\r\nstruct pcpu_vstats *stats = this_cpu_ptr(dev->vstats);\r\nu64_stats_update_begin(&stats->syncp);\r\nstats->bytes += length;\r\nstats->packets++;\r\nu64_stats_update_end(&stats->syncp);\r\n} else {\r\ndrop:\r\natomic64_inc(&priv->dropped);\r\n}\r\nrcu_read_unlock();\r\nreturn NETDEV_TX_OK;\r\n}\r\nstatic u64 veth_stats_one(struct pcpu_vstats *result, struct net_device *dev)\r\n{\r\nstruct veth_priv *priv = netdev_priv(dev);\r\nint cpu;\r\nresult->packets = 0;\r\nresult->bytes = 0;\r\nfor_each_possible_cpu(cpu) {\r\nstruct pcpu_vstats *stats = per_cpu_ptr(dev->vstats, cpu);\r\nu64 packets, bytes;\r\nunsigned int start;\r\ndo {\r\nstart = u64_stats_fetch_begin_irq(&stats->syncp);\r\npackets = stats->packets;\r\nbytes = stats->bytes;\r\n} while (u64_stats_fetch_retry_irq(&stats->syncp, start));\r\nresult->packets += packets;\r\nresult->bytes += bytes;\r\n}\r\nreturn atomic64_read(&priv->dropped);\r\n}\r\nstatic struct rtnl_link_stats64 *veth_get_stats64(struct net_device *dev,\r\nstruct rtnl_link_stats64 *tot)\r\n{\r\nstruct veth_priv *priv = netdev_priv(dev);\r\nstruct net_device *peer;\r\nstruct pcpu_vstats one;\r\ntot->tx_dropped = veth_stats_one(&one, dev);\r\ntot->tx_bytes = one.bytes;\r\ntot->tx_packets = one.packets;\r\nrcu_read_lock();\r\npeer = rcu_dereference(priv->peer);\r\nif (peer) {\r\ntot->rx_dropped = veth_stats_one(&one, peer);\r\ntot->rx_bytes = one.bytes;\r\ntot->rx_packets = one.packets;\r\n}\r\nrcu_read_unlock();\r\nreturn tot;\r\n}\r\nstatic void veth_set_multicast_list(struct net_device *dev)\r\n{\r\n}\r\nstatic int veth_open(struct net_device *dev)\r\n{\r\nstruct veth_priv *priv = netdev_priv(dev);\r\nstruct net_device *peer = rtnl_dereference(priv->peer);\r\nif (!peer)\r\nreturn -ENOTCONN;\r\nif (peer->flags & IFF_UP) {\r\nnetif_carrier_on(dev);\r\nnetif_carrier_on(peer);\r\n}\r\nreturn 0;\r\n}\r\nstatic int veth_close(struct net_device *dev)\r\n{\r\nstruct veth_priv *priv = netdev_priv(dev);\r\nstruct net_device *peer = rtnl_dereference(priv->peer);\r\nnetif_carrier_off(dev);\r\nif (peer)\r\nnetif_carrier_off(peer);\r\nreturn 0;\r\n}\r\nstatic int is_valid_veth_mtu(int new_mtu)\r\n{\r\nreturn new_mtu >= MIN_MTU && new_mtu <= MAX_MTU;\r\n}\r\nstatic int veth_change_mtu(struct net_device *dev, int new_mtu)\r\n{\r\nif (!is_valid_veth_mtu(new_mtu))\r\nreturn -EINVAL;\r\ndev->mtu = new_mtu;\r\nreturn 0;\r\n}\r\nstatic int veth_dev_init(struct net_device *dev)\r\n{\r\ndev->vstats = netdev_alloc_pcpu_stats(struct pcpu_vstats);\r\nif (!dev->vstats)\r\nreturn -ENOMEM;\r\nreturn 0;\r\n}\r\nstatic void veth_dev_free(struct net_device *dev)\r\n{\r\nfree_percpu(dev->vstats);\r\nfree_netdev(dev);\r\n}\r\nstatic void veth_poll_controller(struct net_device *dev)\r\n{\r\n}\r\nstatic int veth_get_iflink(const struct net_device *dev)\r\n{\r\nstruct veth_priv *priv = netdev_priv(dev);\r\nstruct net_device *peer;\r\nint iflink;\r\nrcu_read_lock();\r\npeer = rcu_dereference(priv->peer);\r\niflink = peer ? peer->ifindex : 0;\r\nrcu_read_unlock();\r\nreturn iflink;\r\n}\r\nstatic void veth_setup(struct net_device *dev)\r\n{\r\nether_setup(dev);\r\ndev->priv_flags &= ~IFF_TX_SKB_SHARING;\r\ndev->priv_flags |= IFF_LIVE_ADDR_CHANGE;\r\ndev->priv_flags |= IFF_NO_QUEUE;\r\ndev->netdev_ops = &veth_netdev_ops;\r\ndev->ethtool_ops = &veth_ethtool_ops;\r\ndev->features |= NETIF_F_LLTX;\r\ndev->features |= VETH_FEATURES;\r\ndev->vlan_features = dev->features &\r\n~(NETIF_F_HW_VLAN_CTAG_TX |\r\nNETIF_F_HW_VLAN_STAG_TX |\r\nNETIF_F_HW_VLAN_CTAG_RX |\r\nNETIF_F_HW_VLAN_STAG_RX);\r\ndev->destructor = veth_dev_free;\r\ndev->hw_features = VETH_FEATURES;\r\ndev->hw_enc_features = VETH_FEATURES;\r\n}\r\nstatic int veth_validate(struct nlattr *tb[], struct nlattr *data[])\r\n{\r\nif (tb[IFLA_ADDRESS]) {\r\nif (nla_len(tb[IFLA_ADDRESS]) != ETH_ALEN)\r\nreturn -EINVAL;\r\nif (!is_valid_ether_addr(nla_data(tb[IFLA_ADDRESS])))\r\nreturn -EADDRNOTAVAIL;\r\n}\r\nif (tb[IFLA_MTU]) {\r\nif (!is_valid_veth_mtu(nla_get_u32(tb[IFLA_MTU])))\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int veth_newlink(struct net *src_net, struct net_device *dev,\r\nstruct nlattr *tb[], struct nlattr *data[])\r\n{\r\nint err;\r\nstruct net_device *peer;\r\nstruct veth_priv *priv;\r\nchar ifname[IFNAMSIZ];\r\nstruct nlattr *peer_tb[IFLA_MAX + 1], **tbp;\r\nunsigned char name_assign_type;\r\nstruct ifinfomsg *ifmp;\r\nstruct net *net;\r\nif (data != NULL && data[VETH_INFO_PEER] != NULL) {\r\nstruct nlattr *nla_peer;\r\nnla_peer = data[VETH_INFO_PEER];\r\nifmp = nla_data(nla_peer);\r\nerr = rtnl_nla_parse_ifla(peer_tb,\r\nnla_data(nla_peer) + sizeof(struct ifinfomsg),\r\nnla_len(nla_peer) - sizeof(struct ifinfomsg));\r\nif (err < 0)\r\nreturn err;\r\nerr = veth_validate(peer_tb, NULL);\r\nif (err < 0)\r\nreturn err;\r\ntbp = peer_tb;\r\n} else {\r\nifmp = NULL;\r\ntbp = tb;\r\n}\r\nif (tbp[IFLA_IFNAME]) {\r\nnla_strlcpy(ifname, tbp[IFLA_IFNAME], IFNAMSIZ);\r\nname_assign_type = NET_NAME_USER;\r\n} else {\r\nsnprintf(ifname, IFNAMSIZ, DRV_NAME "%%d");\r\nname_assign_type = NET_NAME_ENUM;\r\n}\r\nnet = rtnl_link_get_net(src_net, tbp);\r\nif (IS_ERR(net))\r\nreturn PTR_ERR(net);\r\npeer = rtnl_create_link(net, ifname, name_assign_type,\r\n&veth_link_ops, tbp);\r\nif (IS_ERR(peer)) {\r\nput_net(net);\r\nreturn PTR_ERR(peer);\r\n}\r\nif (tbp[IFLA_ADDRESS] == NULL)\r\neth_hw_addr_random(peer);\r\nif (ifmp && (dev->ifindex != 0))\r\npeer->ifindex = ifmp->ifi_index;\r\nerr = register_netdevice(peer);\r\nput_net(net);\r\nnet = NULL;\r\nif (err < 0)\r\ngoto err_register_peer;\r\nnetif_carrier_off(peer);\r\nerr = rtnl_configure_link(peer, ifmp);\r\nif (err < 0)\r\ngoto err_configure_peer;\r\nif (tb[IFLA_ADDRESS] == NULL)\r\neth_hw_addr_random(dev);\r\nif (tb[IFLA_IFNAME])\r\nnla_strlcpy(dev->name, tb[IFLA_IFNAME], IFNAMSIZ);\r\nelse\r\nsnprintf(dev->name, IFNAMSIZ, DRV_NAME "%%d");\r\nerr = register_netdevice(dev);\r\nif (err < 0)\r\ngoto err_register_dev;\r\nnetif_carrier_off(dev);\r\npriv = netdev_priv(dev);\r\nrcu_assign_pointer(priv->peer, peer);\r\npriv = netdev_priv(peer);\r\nrcu_assign_pointer(priv->peer, dev);\r\nreturn 0;\r\nerr_register_dev:\r\nerr_configure_peer:\r\nunregister_netdevice(peer);\r\nreturn err;\r\nerr_register_peer:\r\nfree_netdev(peer);\r\nreturn err;\r\n}\r\nstatic void veth_dellink(struct net_device *dev, struct list_head *head)\r\n{\r\nstruct veth_priv *priv;\r\nstruct net_device *peer;\r\npriv = netdev_priv(dev);\r\npeer = rtnl_dereference(priv->peer);\r\nRCU_INIT_POINTER(priv->peer, NULL);\r\nunregister_netdevice_queue(dev, head);\r\nif (peer) {\r\npriv = netdev_priv(peer);\r\nRCU_INIT_POINTER(priv->peer, NULL);\r\nunregister_netdevice_queue(peer, head);\r\n}\r\n}\r\nstatic struct net *veth_get_link_net(const struct net_device *dev)\r\n{\r\nstruct veth_priv *priv = netdev_priv(dev);\r\nstruct net_device *peer = rtnl_dereference(priv->peer);\r\nreturn peer ? dev_net(peer) : dev_net(dev);\r\n}\r\nstatic __init int veth_init(void)\r\n{\r\nreturn rtnl_link_register(&veth_link_ops);\r\n}\r\nstatic __exit void veth_exit(void)\r\n{\r\nrtnl_link_unregister(&veth_link_ops);\r\n}
