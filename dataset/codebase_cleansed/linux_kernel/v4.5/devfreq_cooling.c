static int get_idr(struct idr *idr, int *id)\r\n{\r\nint ret;\r\nmutex_lock(&devfreq_lock);\r\nret = idr_alloc(idr, NULL, 0, 0, GFP_KERNEL);\r\nmutex_unlock(&devfreq_lock);\r\nif (unlikely(ret < 0))\r\nreturn ret;\r\n*id = ret;\r\nreturn 0;\r\n}\r\nstatic void release_idr(struct idr *idr, int id)\r\n{\r\nmutex_lock(&devfreq_lock);\r\nidr_remove(idr, id);\r\nmutex_unlock(&devfreq_lock);\r\n}\r\nstatic int partition_enable_opps(struct devfreq_cooling_device *dfc,\r\nunsigned long cdev_state)\r\n{\r\nint i;\r\nstruct device *dev = dfc->devfreq->dev.parent;\r\nfor (i = 0; i < dfc->freq_table_size; i++) {\r\nstruct dev_pm_opp *opp;\r\nint ret = 0;\r\nunsigned int freq = dfc->freq_table[i];\r\nbool want_enable = i >= cdev_state ? true : false;\r\nrcu_read_lock();\r\nopp = dev_pm_opp_find_freq_exact(dev, freq, !want_enable);\r\nrcu_read_unlock();\r\nif (PTR_ERR(opp) == -ERANGE)\r\ncontinue;\r\nelse if (IS_ERR(opp))\r\nreturn PTR_ERR(opp);\r\nif (want_enable)\r\nret = dev_pm_opp_enable(dev, freq);\r\nelse\r\nret = dev_pm_opp_disable(dev, freq);\r\nif (ret)\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic int devfreq_cooling_get_max_state(struct thermal_cooling_device *cdev,\r\nunsigned long *state)\r\n{\r\nstruct devfreq_cooling_device *dfc = cdev->devdata;\r\n*state = dfc->freq_table_size - 1;\r\nreturn 0;\r\n}\r\nstatic int devfreq_cooling_get_cur_state(struct thermal_cooling_device *cdev,\r\nunsigned long *state)\r\n{\r\nstruct devfreq_cooling_device *dfc = cdev->devdata;\r\n*state = dfc->cooling_state;\r\nreturn 0;\r\n}\r\nstatic int devfreq_cooling_set_cur_state(struct thermal_cooling_device *cdev,\r\nunsigned long state)\r\n{\r\nstruct devfreq_cooling_device *dfc = cdev->devdata;\r\nstruct devfreq *df = dfc->devfreq;\r\nstruct device *dev = df->dev.parent;\r\nint ret;\r\nif (state == dfc->cooling_state)\r\nreturn 0;\r\ndev_dbg(dev, "Setting cooling state %lu\n", state);\r\nif (state >= dfc->freq_table_size)\r\nreturn -EINVAL;\r\nret = partition_enable_opps(dfc, state);\r\nif (ret)\r\nreturn ret;\r\ndfc->cooling_state = state;\r\nreturn 0;\r\n}\r\nstatic unsigned long\r\nfreq_get_state(struct devfreq_cooling_device *dfc, unsigned long freq)\r\n{\r\nint i;\r\nfor (i = 0; i < dfc->freq_table_size; i++) {\r\nif (dfc->freq_table[i] == freq)\r\nreturn i;\r\n}\r\nreturn THERMAL_CSTATE_INVALID;\r\n}\r\nstatic unsigned long\r\nget_static_power(struct devfreq_cooling_device *dfc, unsigned long freq)\r\n{\r\nstruct devfreq *df = dfc->devfreq;\r\nstruct device *dev = df->dev.parent;\r\nunsigned long voltage;\r\nstruct dev_pm_opp *opp;\r\nif (!dfc->power_ops->get_static_power)\r\nreturn 0;\r\nrcu_read_lock();\r\nopp = dev_pm_opp_find_freq_exact(dev, freq, true);\r\nif (IS_ERR(opp) && (PTR_ERR(opp) == -ERANGE))\r\nopp = dev_pm_opp_find_freq_exact(dev, freq, false);\r\nvoltage = dev_pm_opp_get_voltage(opp) / 1000;\r\nrcu_read_unlock();\r\nif (voltage == 0) {\r\ndev_warn_ratelimited(dev,\r\n"Failed to get voltage for frequency %lu: %ld\n",\r\nfreq, IS_ERR(opp) ? PTR_ERR(opp) : 0);\r\nreturn 0;\r\n}\r\nreturn dfc->power_ops->get_static_power(voltage);\r\n}\r\nstatic unsigned long\r\nget_dynamic_power(struct devfreq_cooling_device *dfc, unsigned long freq,\r\nunsigned long voltage)\r\n{\r\nu64 power;\r\nu32 freq_mhz;\r\nstruct devfreq_cooling_power *dfc_power = dfc->power_ops;\r\nif (dfc_power->get_dynamic_power)\r\nreturn dfc_power->get_dynamic_power(freq, voltage);\r\nfreq_mhz = freq / 1000000;\r\npower = (u64)dfc_power->dyn_power_coeff * freq_mhz * voltage * voltage;\r\ndo_div(power, 1000000000);\r\nreturn power;\r\n}\r\nstatic int devfreq_cooling_get_requested_power(struct thermal_cooling_device *cdev,\r\nstruct thermal_zone_device *tz,\r\nu32 *power)\r\n{\r\nstruct devfreq_cooling_device *dfc = cdev->devdata;\r\nstruct devfreq *df = dfc->devfreq;\r\nstruct devfreq_dev_status *status = &df->last_status;\r\nunsigned long state;\r\nunsigned long freq = status->current_frequency;\r\nu32 dyn_power, static_power;\r\nstate = freq_get_state(dfc, freq);\r\nif (state == THERMAL_CSTATE_INVALID)\r\nreturn -EAGAIN;\r\ndyn_power = dfc->power_table[state];\r\ndyn_power = (dyn_power * status->busy_time) / status->total_time;\r\nstatic_power = get_static_power(dfc, freq);\r\ntrace_thermal_power_devfreq_get_power(cdev, status, freq, dyn_power,\r\nstatic_power);\r\n*power = dyn_power + static_power;\r\nreturn 0;\r\n}\r\nstatic int devfreq_cooling_state2power(struct thermal_cooling_device *cdev,\r\nstruct thermal_zone_device *tz,\r\nunsigned long state,\r\nu32 *power)\r\n{\r\nstruct devfreq_cooling_device *dfc = cdev->devdata;\r\nunsigned long freq;\r\nu32 static_power;\r\nif (state < 0 || state >= dfc->freq_table_size)\r\nreturn -EINVAL;\r\nfreq = dfc->freq_table[state];\r\nstatic_power = get_static_power(dfc, freq);\r\n*power = dfc->power_table[state] + static_power;\r\nreturn 0;\r\n}\r\nstatic int devfreq_cooling_power2state(struct thermal_cooling_device *cdev,\r\nstruct thermal_zone_device *tz,\r\nu32 power, unsigned long *state)\r\n{\r\nstruct devfreq_cooling_device *dfc = cdev->devdata;\r\nstruct devfreq *df = dfc->devfreq;\r\nstruct devfreq_dev_status *status = &df->last_status;\r\nunsigned long freq = status->current_frequency;\r\nunsigned long busy_time;\r\ns32 dyn_power;\r\nu32 static_power;\r\nint i;\r\nstatic_power = get_static_power(dfc, freq);\r\ndyn_power = power - static_power;\r\ndyn_power = dyn_power > 0 ? dyn_power : 0;\r\nbusy_time = status->busy_time ?: 1;\r\ndyn_power = (dyn_power * status->total_time) / busy_time;\r\nfor (i = 0; i < dfc->freq_table_size - 1; i++)\r\nif (dyn_power >= dfc->power_table[i])\r\nbreak;\r\n*state = i;\r\ntrace_thermal_power_devfreq_limit(cdev, freq, *state, power);\r\nreturn 0;\r\n}\r\nstatic int devfreq_cooling_gen_tables(struct devfreq_cooling_device *dfc)\r\n{\r\nstruct devfreq *df = dfc->devfreq;\r\nstruct device *dev = df->dev.parent;\r\nint ret, num_opps;\r\nunsigned long freq;\r\nu32 *power_table = NULL;\r\nu32 *freq_table;\r\nint i;\r\nnum_opps = dev_pm_opp_get_opp_count(dev);\r\nif (dfc->power_ops) {\r\npower_table = kcalloc(num_opps, sizeof(*power_table),\r\nGFP_KERNEL);\r\nif (!power_table)\r\nreturn -ENOMEM;\r\n}\r\nfreq_table = kcalloc(num_opps, sizeof(*freq_table),\r\nGFP_KERNEL);\r\nif (!freq_table) {\r\nret = -ENOMEM;\r\ngoto free_power_table;\r\n}\r\nfor (i = 0, freq = ULONG_MAX; i < num_opps; i++, freq--) {\r\nunsigned long power_dyn, voltage;\r\nstruct dev_pm_opp *opp;\r\nrcu_read_lock();\r\nopp = dev_pm_opp_find_freq_floor(dev, &freq);\r\nif (IS_ERR(opp)) {\r\nrcu_read_unlock();\r\nret = PTR_ERR(opp);\r\ngoto free_tables;\r\n}\r\nvoltage = dev_pm_opp_get_voltage(opp) / 1000;\r\nrcu_read_unlock();\r\nif (dfc->power_ops) {\r\npower_dyn = get_dynamic_power(dfc, freq, voltage);\r\ndev_dbg(dev, "Dynamic power table: %lu MHz @ %lu mV: %lu = %lu mW\n",\r\nfreq / 1000000, voltage, power_dyn, power_dyn);\r\npower_table[i] = power_dyn;\r\n}\r\nfreq_table[i] = freq;\r\n}\r\nif (dfc->power_ops)\r\ndfc->power_table = power_table;\r\ndfc->freq_table = freq_table;\r\ndfc->freq_table_size = num_opps;\r\nreturn 0;\r\nfree_tables:\r\nkfree(freq_table);\r\nfree_power_table:\r\nkfree(power_table);\r\nreturn ret;\r\n}\r\nstruct thermal_cooling_device *\r\nof_devfreq_cooling_register_power(struct device_node *np, struct devfreq *df,\r\nstruct devfreq_cooling_power *dfc_power)\r\n{\r\nstruct thermal_cooling_device *cdev;\r\nstruct devfreq_cooling_device *dfc;\r\nchar dev_name[THERMAL_NAME_LENGTH];\r\nint err;\r\ndfc = kzalloc(sizeof(*dfc), GFP_KERNEL);\r\nif (!dfc)\r\nreturn ERR_PTR(-ENOMEM);\r\ndfc->devfreq = df;\r\nif (dfc_power) {\r\ndfc->power_ops = dfc_power;\r\ndevfreq_cooling_ops.get_requested_power =\r\ndevfreq_cooling_get_requested_power;\r\ndevfreq_cooling_ops.state2power = devfreq_cooling_state2power;\r\ndevfreq_cooling_ops.power2state = devfreq_cooling_power2state;\r\n}\r\nerr = devfreq_cooling_gen_tables(dfc);\r\nif (err)\r\ngoto free_dfc;\r\nerr = get_idr(&devfreq_idr, &dfc->id);\r\nif (err)\r\ngoto free_tables;\r\nsnprintf(dev_name, sizeof(dev_name), "thermal-devfreq-%d", dfc->id);\r\ncdev = thermal_of_cooling_device_register(np, dev_name, dfc,\r\n&devfreq_cooling_ops);\r\nif (IS_ERR(cdev)) {\r\nerr = PTR_ERR(cdev);\r\ndev_err(df->dev.parent,\r\n"Failed to register devfreq cooling device (%d)\n",\r\nerr);\r\ngoto release_idr;\r\n}\r\ndfc->cdev = cdev;\r\nreturn cdev;\r\nrelease_idr:\r\nrelease_idr(&devfreq_idr, dfc->id);\r\nfree_tables:\r\nkfree(dfc->power_table);\r\nkfree(dfc->freq_table);\r\nfree_dfc:\r\nkfree(dfc);\r\nreturn ERR_PTR(err);\r\n}\r\nstruct thermal_cooling_device *\r\nof_devfreq_cooling_register(struct device_node *np, struct devfreq *df)\r\n{\r\nreturn of_devfreq_cooling_register_power(np, df, NULL);\r\n}\r\nstruct thermal_cooling_device *devfreq_cooling_register(struct devfreq *df)\r\n{\r\nreturn of_devfreq_cooling_register(NULL, df);\r\n}\r\nvoid devfreq_cooling_unregister(struct thermal_cooling_device *cdev)\r\n{\r\nstruct devfreq_cooling_device *dfc;\r\nif (!cdev)\r\nreturn;\r\ndfc = cdev->devdata;\r\nthermal_cooling_device_unregister(dfc->cdev);\r\nrelease_idr(&devfreq_idr, dfc->id);\r\nkfree(dfc->power_table);\r\nkfree(dfc->freq_table);\r\nkfree(dfc);\r\n}
