static int uda134x_regmap_write(void *context, unsigned int reg,\r\nunsigned int value)\r\n{\r\nstruct uda134x_platform_data *pd = context;\r\nint ret;\r\nu8 addr;\r\nu8 data = value;\r\nswitch (reg) {\r\ncase UDA134X_STATUS0:\r\ncase UDA134X_STATUS1:\r\naddr = UDA134X_STATUS_ADDR;\r\ndata |= (reg - UDA134X_STATUS0) << 7;\r\nbreak;\r\ncase UDA134X_DATA000:\r\ncase UDA134X_DATA001:\r\ncase UDA134X_DATA010:\r\ncase UDA134X_DATA011:\r\naddr = UDA134X_DATA0_ADDR;\r\ndata |= (reg - UDA134X_DATA000) << 6;\r\nbreak;\r\ncase UDA134X_DATA1:\r\naddr = UDA134X_DATA1_ADDR;\r\nbreak;\r\ndefault:\r\naddr = (reg | UDA134X_EXTADDR_PREFIX);\r\nret = l3_write(&pd->l3,\r\nUDA134X_DATA0_ADDR, &addr, 1);\r\nif (ret != 1)\r\nreturn -EIO;\r\naddr = UDA134X_DATA0_ADDR;\r\ndata = (value | UDA134X_EXTDATA_PREFIX);\r\nbreak;\r\n}\r\nret = l3_write(&pd->l3,\r\naddr, &data, 1);\r\nif (ret != 1)\r\nreturn -EIO;\r\nreturn 0;\r\n}\r\nstatic inline void uda134x_reset(struct snd_soc_codec *codec)\r\n{\r\nstruct uda134x_priv *uda134x = snd_soc_codec_get_drvdata(codec);\r\nunsigned int mask = 1<<6;\r\nregmap_update_bits(uda134x->regmap, UDA134X_STATUS0, mask, mask);\r\nmsleep(1);\r\nregmap_update_bits(uda134x->regmap, UDA134X_STATUS0, mask, 0);\r\n}\r\nstatic int uda134x_mute(struct snd_soc_dai *dai, int mute)\r\n{\r\nstruct uda134x_priv *uda134x = snd_soc_codec_get_drvdata(dai->codec);\r\nunsigned int mask = 1<<2;\r\nunsigned int val;\r\npr_debug("%s mute: %d\n", __func__, mute);\r\nif (mute)\r\nval = mask;\r\nelse\r\nval = 0;\r\nreturn regmap_update_bits(uda134x->regmap, UDA134X_DATA010, mask, val);\r\n}\r\nstatic int uda134x_startup(struct snd_pcm_substream *substream,\r\nstruct snd_soc_dai *dai)\r\n{\r\nstruct snd_soc_codec *codec = dai->codec;\r\nstruct uda134x_priv *uda134x = snd_soc_codec_get_drvdata(codec);\r\nstruct snd_pcm_runtime *master_runtime;\r\nif (uda134x->master_substream) {\r\nmaster_runtime = uda134x->master_substream->runtime;\r\npr_debug("%s constraining to %d bits at %d\n", __func__,\r\nmaster_runtime->sample_bits,\r\nmaster_runtime->rate);\r\nsnd_pcm_hw_constraint_single(substream->runtime,\r\nSNDRV_PCM_HW_PARAM_RATE,\r\nmaster_runtime->rate);\r\nsnd_pcm_hw_constraint_single(substream->runtime,\r\nSNDRV_PCM_HW_PARAM_SAMPLE_BITS,\r\nmaster_runtime->sample_bits);\r\nuda134x->slave_substream = substream;\r\n} else\r\nuda134x->master_substream = substream;\r\nreturn 0;\r\n}\r\nstatic void uda134x_shutdown(struct snd_pcm_substream *substream,\r\nstruct snd_soc_dai *dai)\r\n{\r\nstruct snd_soc_codec *codec = dai->codec;\r\nstruct uda134x_priv *uda134x = snd_soc_codec_get_drvdata(codec);\r\nif (uda134x->master_substream == substream)\r\nuda134x->master_substream = uda134x->slave_substream;\r\nuda134x->slave_substream = NULL;\r\n}\r\nstatic int uda134x_hw_params(struct snd_pcm_substream *substream,\r\nstruct snd_pcm_hw_params *params,\r\nstruct snd_soc_dai *dai)\r\n{\r\nstruct snd_soc_codec *codec = dai->codec;\r\nstruct uda134x_priv *uda134x = snd_soc_codec_get_drvdata(codec);\r\nunsigned int hw_params = 0;\r\nif (substream == uda134x->slave_substream) {\r\npr_debug("%s ignoring hw_params for slave substream\n",\r\n__func__);\r\nreturn 0;\r\n}\r\npr_debug("%s sysclk: %d, rate:%d\n", __func__,\r\nuda134x->sysclk, params_rate(params));\r\nswitch (uda134x->sysclk / params_rate(params)) {\r\ncase 512:\r\nbreak;\r\ncase 384:\r\nhw_params |= (1<<4);\r\nbreak;\r\ncase 256:\r\nhw_params |= (1<<5);\r\nbreak;\r\ndefault:\r\nprintk(KERN_ERR "%s unsupported fs\n", __func__);\r\nreturn -EINVAL;\r\n}\r\npr_debug("%s dai_fmt: %d, params_format:%d\n", __func__,\r\nuda134x->dai_fmt, params_format(params));\r\nswitch (uda134x->dai_fmt & SND_SOC_DAIFMT_FORMAT_MASK) {\r\ncase SND_SOC_DAIFMT_I2S:\r\nbreak;\r\ncase SND_SOC_DAIFMT_RIGHT_J:\r\nswitch (params_width(params)) {\r\ncase 16:\r\nhw_params |= (1<<1);\r\nbreak;\r\ncase 18:\r\nhw_params |= (1<<2);\r\nbreak;\r\ncase 20:\r\nhw_params |= ((1<<2) | (1<<1));\r\nbreak;\r\ndefault:\r\nprintk(KERN_ERR "%s unsupported format (right)\n",\r\n__func__);\r\nreturn -EINVAL;\r\n}\r\nbreak;\r\ncase SND_SOC_DAIFMT_LEFT_J:\r\nhw_params |= (1<<3);\r\nbreak;\r\ndefault:\r\nprintk(KERN_ERR "%s unsupported format\n", __func__);\r\nreturn -EINVAL;\r\n}\r\nreturn regmap_update_bits(uda134x->regmap, UDA134X_STATUS0,\r\nSTATUS0_SYSCLK_MASK | STATUS0_DAIFMT_MASK, hw_params);\r\n}\r\nstatic int uda134x_set_dai_sysclk(struct snd_soc_dai *codec_dai,\r\nint clk_id, unsigned int freq, int dir)\r\n{\r\nstruct snd_soc_codec *codec = codec_dai->codec;\r\nstruct uda134x_priv *uda134x = snd_soc_codec_get_drvdata(codec);\r\npr_debug("%s clk_id: %d, freq: %u, dir: %d\n", __func__,\r\nclk_id, freq, dir);\r\nif ((freq >= (256 * 8000)) && (freq <= (512 * 48000))) {\r\nuda134x->sysclk = freq;\r\nreturn 0;\r\n}\r\nprintk(KERN_ERR "%s unsupported sysclk\n", __func__);\r\nreturn -EINVAL;\r\n}\r\nstatic int uda134x_set_dai_fmt(struct snd_soc_dai *codec_dai,\r\nunsigned int fmt)\r\n{\r\nstruct snd_soc_codec *codec = codec_dai->codec;\r\nstruct uda134x_priv *uda134x = snd_soc_codec_get_drvdata(codec);\r\npr_debug("%s fmt: %08X\n", __func__, fmt);\r\nif ((fmt & SND_SOC_DAIFMT_MASTER_MASK) != SND_SOC_DAIFMT_CBS_CFS) {\r\nprintk(KERN_ERR "%s unsupported slave mode\n", __func__);\r\nreturn -EINVAL;\r\n}\r\nif ((fmt & SND_SOC_DAIFMT_INV_MASK) != SND_SOC_DAIFMT_NB_NF) {\r\nprintk(KERN_ERR "%s unsupported clock inversion\n", __func__);\r\nreturn -EINVAL;\r\n}\r\nuda134x->dai_fmt = fmt;\r\nreturn 0;\r\n}\r\nstatic int uda134x_set_bias_level(struct snd_soc_codec *codec,\r\nenum snd_soc_bias_level level)\r\n{\r\nstruct uda134x_priv *uda134x = snd_soc_codec_get_drvdata(codec);\r\nstruct uda134x_platform_data *pd = uda134x->pd;\r\npr_debug("%s bias level %d\n", __func__, level);\r\nswitch (level) {\r\ncase SND_SOC_BIAS_ON:\r\nbreak;\r\ncase SND_SOC_BIAS_PREPARE:\r\nif (pd->power) {\r\npd->power(1);\r\nregcache_sync(uda134x->regmap);\r\n}\r\nbreak;\r\ncase SND_SOC_BIAS_STANDBY:\r\nbreak;\r\ncase SND_SOC_BIAS_OFF:\r\nif (pd->power) {\r\npd->power(0);\r\nregcache_mark_dirty(uda134x->regmap);\r\n}\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic int uda134x_soc_probe(struct snd_soc_codec *codec)\r\n{\r\nstruct snd_soc_dapm_context *dapm = snd_soc_codec_get_dapm(codec);\r\nstruct uda134x_priv *uda134x = snd_soc_codec_get_drvdata(codec);\r\nstruct uda134x_platform_data *pd = uda134x->pd;\r\nconst struct snd_soc_dapm_widget *widgets;\r\nunsigned num_widgets;\r\nint ret;\r\nprintk(KERN_INFO "UDA134X SoC Audio Codec\n");\r\nswitch (pd->model) {\r\ncase UDA134X_UDA1340:\r\ncase UDA134X_UDA1341:\r\ncase UDA134X_UDA1344:\r\ncase UDA134X_UDA1345:\r\nbreak;\r\ndefault:\r\nprintk(KERN_ERR "UDA134X SoC codec: "\r\n"unsupported model %d\n",\r\npd->model);\r\nreturn -EINVAL;\r\n}\r\nif (pd->power)\r\npd->power(1);\r\nuda134x_reset(codec);\r\nif (pd->model == UDA134X_UDA1341) {\r\nwidgets = uda1341_dapm_widgets;\r\nnum_widgets = ARRAY_SIZE(uda1341_dapm_widgets);\r\n} else {\r\nwidgets = uda1340_dapm_widgets;\r\nnum_widgets = ARRAY_SIZE(uda1340_dapm_widgets);\r\n}\r\nret = snd_soc_dapm_new_controls(dapm, widgets, num_widgets);\r\nif (ret) {\r\nprintk(KERN_ERR "%s failed to register dapm controls: %d",\r\n__func__, ret);\r\nreturn ret;\r\n}\r\nswitch (pd->model) {\r\ncase UDA134X_UDA1340:\r\ncase UDA134X_UDA1344:\r\nret = snd_soc_add_codec_controls(codec, uda1340_snd_controls,\r\nARRAY_SIZE(uda1340_snd_controls));\r\nbreak;\r\ncase UDA134X_UDA1341:\r\nret = snd_soc_add_codec_controls(codec, uda1341_snd_controls,\r\nARRAY_SIZE(uda1341_snd_controls));\r\nbreak;\r\ncase UDA134X_UDA1345:\r\nret = snd_soc_add_codec_controls(codec, uda1345_snd_controls,\r\nARRAY_SIZE(uda1345_snd_controls));\r\nbreak;\r\ndefault:\r\nprintk(KERN_ERR "%s unknown codec type: %d",\r\n__func__, pd->model);\r\nreturn -EINVAL;\r\n}\r\nif (ret < 0) {\r\nprintk(KERN_ERR "UDA134X: failed to register controls\n");\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic int uda134x_codec_probe(struct platform_device *pdev)\r\n{\r\nstruct uda134x_platform_data *pd = pdev->dev.platform_data;\r\nstruct uda134x_priv *uda134x;\r\nif (!pd) {\r\ndev_err(&pdev->dev, "Missing L3 bitbang function\n");\r\nreturn -ENODEV;\r\n}\r\nuda134x = devm_kzalloc(&pdev->dev, sizeof(*uda134x), GFP_KERNEL);\r\nif (!uda134x)\r\nreturn -ENOMEM;\r\nuda134x->pd = pd;\r\nplatform_set_drvdata(pdev, uda134x);\r\nuda134x->regmap = devm_regmap_init(&pdev->dev, NULL, pd,\r\n&uda134x_regmap_config);\r\nif (IS_ERR(uda134x->regmap))\r\nreturn PTR_ERR(uda134x->regmap);\r\nreturn snd_soc_register_codec(&pdev->dev,\r\n&soc_codec_dev_uda134x, &uda134x_dai, 1);\r\n}\r\nstatic int uda134x_codec_remove(struct platform_device *pdev)\r\n{\r\nsnd_soc_unregister_codec(&pdev->dev);\r\nreturn 0;\r\n}
