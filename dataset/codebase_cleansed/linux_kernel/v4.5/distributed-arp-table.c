static void batadv_dat_start_timer(struct batadv_priv *bat_priv)\r\n{\r\nINIT_DELAYED_WORK(&bat_priv->dat.work, batadv_dat_purge);\r\nqueue_delayed_work(batadv_event_workqueue, &bat_priv->dat.work,\r\nmsecs_to_jiffies(10000));\r\n}\r\nstatic void batadv_dat_entry_free_ref(struct batadv_dat_entry *dat_entry)\r\n{\r\nif (atomic_dec_and_test(&dat_entry->refcount))\r\nkfree_rcu(dat_entry, rcu);\r\n}\r\nstatic bool batadv_dat_to_purge(struct batadv_dat_entry *dat_entry)\r\n{\r\nreturn batadv_has_timed_out(dat_entry->last_update,\r\nBATADV_DAT_ENTRY_TIMEOUT);\r\n}\r\nstatic void __batadv_dat_purge(struct batadv_priv *bat_priv,\r\nbool (*to_purge)(struct batadv_dat_entry *))\r\n{\r\nspinlock_t *list_lock;\r\nstruct batadv_dat_entry *dat_entry;\r\nstruct hlist_node *node_tmp;\r\nstruct hlist_head *head;\r\nu32 i;\r\nif (!bat_priv->dat.hash)\r\nreturn;\r\nfor (i = 0; i < bat_priv->dat.hash->size; i++) {\r\nhead = &bat_priv->dat.hash->table[i];\r\nlist_lock = &bat_priv->dat.hash->list_locks[i];\r\nspin_lock_bh(list_lock);\r\nhlist_for_each_entry_safe(dat_entry, node_tmp, head,\r\nhash_entry) {\r\nif (to_purge && !to_purge(dat_entry))\r\ncontinue;\r\nhlist_del_rcu(&dat_entry->hash_entry);\r\nbatadv_dat_entry_free_ref(dat_entry);\r\n}\r\nspin_unlock_bh(list_lock);\r\n}\r\n}\r\nstatic void batadv_dat_purge(struct work_struct *work)\r\n{\r\nstruct delayed_work *delayed_work;\r\nstruct batadv_priv_dat *priv_dat;\r\nstruct batadv_priv *bat_priv;\r\ndelayed_work = container_of(work, struct delayed_work, work);\r\npriv_dat = container_of(delayed_work, struct batadv_priv_dat, work);\r\nbat_priv = container_of(priv_dat, struct batadv_priv, dat);\r\n__batadv_dat_purge(bat_priv, batadv_dat_to_purge);\r\nbatadv_dat_start_timer(bat_priv);\r\n}\r\nstatic int batadv_compare_dat(const struct hlist_node *node, const void *data2)\r\n{\r\nconst void *data1 = container_of(node, struct batadv_dat_entry,\r\nhash_entry);\r\nreturn memcmp(data1, data2, sizeof(__be32)) == 0 ? 1 : 0;\r\n}\r\nstatic u8 *batadv_arp_hw_src(struct sk_buff *skb, int hdr_size)\r\n{\r\nu8 *addr;\r\naddr = (u8 *)(skb->data + hdr_size);\r\naddr += ETH_HLEN + sizeof(struct arphdr);\r\nreturn addr;\r\n}\r\nstatic __be32 batadv_arp_ip_src(struct sk_buff *skb, int hdr_size)\r\n{\r\nreturn *(__be32 *)(batadv_arp_hw_src(skb, hdr_size) + ETH_ALEN);\r\n}\r\nstatic u8 *batadv_arp_hw_dst(struct sk_buff *skb, int hdr_size)\r\n{\r\nreturn batadv_arp_hw_src(skb, hdr_size) + ETH_ALEN + 4;\r\n}\r\nstatic __be32 batadv_arp_ip_dst(struct sk_buff *skb, int hdr_size)\r\n{\r\nreturn *(__be32 *)(batadv_arp_hw_src(skb, hdr_size) + ETH_ALEN * 2 + 4);\r\n}\r\nstatic u32 batadv_hash_dat(const void *data, u32 size)\r\n{\r\nu32 hash = 0;\r\nconst struct batadv_dat_entry *dat = data;\r\nconst unsigned char *key;\r\nu32 i;\r\nkey = (const unsigned char *)&dat->ip;\r\nfor (i = 0; i < sizeof(dat->ip); i++) {\r\nhash += key[i];\r\nhash += (hash << 10);\r\nhash ^= (hash >> 6);\r\n}\r\nkey = (const unsigned char *)&dat->vid;\r\nfor (i = 0; i < sizeof(dat->vid); i++) {\r\nhash += key[i];\r\nhash += (hash << 10);\r\nhash ^= (hash >> 6);\r\n}\r\nhash += (hash << 3);\r\nhash ^= (hash >> 11);\r\nhash += (hash << 15);\r\nreturn hash % size;\r\n}\r\nstatic struct batadv_dat_entry *\r\nbatadv_dat_entry_hash_find(struct batadv_priv *bat_priv, __be32 ip,\r\nunsigned short vid)\r\n{\r\nstruct hlist_head *head;\r\nstruct batadv_dat_entry to_find, *dat_entry, *dat_entry_tmp = NULL;\r\nstruct batadv_hashtable *hash = bat_priv->dat.hash;\r\nu32 index;\r\nif (!hash)\r\nreturn NULL;\r\nto_find.ip = ip;\r\nto_find.vid = vid;\r\nindex = batadv_hash_dat(&to_find, hash->size);\r\nhead = &hash->table[index];\r\nrcu_read_lock();\r\nhlist_for_each_entry_rcu(dat_entry, head, hash_entry) {\r\nif (dat_entry->ip != ip)\r\ncontinue;\r\nif (!atomic_inc_not_zero(&dat_entry->refcount))\r\ncontinue;\r\ndat_entry_tmp = dat_entry;\r\nbreak;\r\n}\r\nrcu_read_unlock();\r\nreturn dat_entry_tmp;\r\n}\r\nstatic void batadv_dat_entry_add(struct batadv_priv *bat_priv, __be32 ip,\r\nu8 *mac_addr, unsigned short vid)\r\n{\r\nstruct batadv_dat_entry *dat_entry;\r\nint hash_added;\r\ndat_entry = batadv_dat_entry_hash_find(bat_priv, ip, vid);\r\nif (dat_entry) {\r\nif (!batadv_compare_eth(dat_entry->mac_addr, mac_addr))\r\nether_addr_copy(dat_entry->mac_addr, mac_addr);\r\ndat_entry->last_update = jiffies;\r\nbatadv_dbg(BATADV_DBG_DAT, bat_priv,\r\n"Entry updated: %pI4 %pM (vid: %d)\n",\r\n&dat_entry->ip, dat_entry->mac_addr,\r\nBATADV_PRINT_VID(vid));\r\ngoto out;\r\n}\r\ndat_entry = kmalloc(sizeof(*dat_entry), GFP_ATOMIC);\r\nif (!dat_entry)\r\ngoto out;\r\ndat_entry->ip = ip;\r\ndat_entry->vid = vid;\r\nether_addr_copy(dat_entry->mac_addr, mac_addr);\r\ndat_entry->last_update = jiffies;\r\natomic_set(&dat_entry->refcount, 2);\r\nhash_added = batadv_hash_add(bat_priv->dat.hash, batadv_compare_dat,\r\nbatadv_hash_dat, dat_entry,\r\n&dat_entry->hash_entry);\r\nif (unlikely(hash_added != 0)) {\r\nbatadv_dat_entry_free_ref(dat_entry);\r\ngoto out;\r\n}\r\nbatadv_dbg(BATADV_DBG_DAT, bat_priv, "New entry added: %pI4 %pM (vid: %d)\n",\r\n&dat_entry->ip, dat_entry->mac_addr, BATADV_PRINT_VID(vid));\r\nout:\r\nif (dat_entry)\r\nbatadv_dat_entry_free_ref(dat_entry);\r\n}\r\nstatic void batadv_dbg_arp(struct batadv_priv *bat_priv, struct sk_buff *skb,\r\nu16 type, int hdr_size, char *msg)\r\n{\r\nstruct batadv_unicast_4addr_packet *unicast_4addr_packet;\r\nstruct batadv_bcast_packet *bcast_pkt;\r\nu8 *orig_addr;\r\n__be32 ip_src, ip_dst;\r\nif (msg)\r\nbatadv_dbg(BATADV_DBG_DAT, bat_priv, "%s\n", msg);\r\nip_src = batadv_arp_ip_src(skb, hdr_size);\r\nip_dst = batadv_arp_ip_dst(skb, hdr_size);\r\nbatadv_dbg(BATADV_DBG_DAT, bat_priv,\r\n"ARP MSG = [src: %pM-%pI4 dst: %pM-%pI4]\n",\r\nbatadv_arp_hw_src(skb, hdr_size), &ip_src,\r\nbatadv_arp_hw_dst(skb, hdr_size), &ip_dst);\r\nif (hdr_size == 0)\r\nreturn;\r\nunicast_4addr_packet = (struct batadv_unicast_4addr_packet *)skb->data;\r\nswitch (unicast_4addr_packet->u.packet_type) {\r\ncase BATADV_UNICAST:\r\nbatadv_dbg(BATADV_DBG_DAT, bat_priv,\r\n"* encapsulated within a UNICAST packet\n");\r\nbreak;\r\ncase BATADV_UNICAST_4ADDR:\r\nbatadv_dbg(BATADV_DBG_DAT, bat_priv,\r\n"* encapsulated within a UNICAST_4ADDR packet (src: %pM)\n",\r\nunicast_4addr_packet->src);\r\nswitch (unicast_4addr_packet->subtype) {\r\ncase BATADV_P_DAT_DHT_PUT:\r\nbatadv_dbg(BATADV_DBG_DAT, bat_priv, "* type: DAT_DHT_PUT\n");\r\nbreak;\r\ncase BATADV_P_DAT_DHT_GET:\r\nbatadv_dbg(BATADV_DBG_DAT, bat_priv, "* type: DAT_DHT_GET\n");\r\nbreak;\r\ncase BATADV_P_DAT_CACHE_REPLY:\r\nbatadv_dbg(BATADV_DBG_DAT, bat_priv,\r\n"* type: DAT_CACHE_REPLY\n");\r\nbreak;\r\ncase BATADV_P_DATA:\r\nbatadv_dbg(BATADV_DBG_DAT, bat_priv, "* type: DATA\n");\r\nbreak;\r\ndefault:\r\nbatadv_dbg(BATADV_DBG_DAT, bat_priv, "* type: Unknown (%u)!\n",\r\nunicast_4addr_packet->u.packet_type);\r\n}\r\nbreak;\r\ncase BATADV_BCAST:\r\nbcast_pkt = (struct batadv_bcast_packet *)unicast_4addr_packet;\r\norig_addr = bcast_pkt->orig;\r\nbatadv_dbg(BATADV_DBG_DAT, bat_priv,\r\n"* encapsulated within a BCAST packet (src: %pM)\n",\r\norig_addr);\r\nbreak;\r\ndefault:\r\nbatadv_dbg(BATADV_DBG_DAT, bat_priv,\r\n"* encapsulated within an unknown packet type (0x%x)\n",\r\nunicast_4addr_packet->u.packet_type);\r\n}\r\n}\r\nstatic void batadv_dbg_arp(struct batadv_priv *bat_priv, struct sk_buff *skb,\r\nu16 type, int hdr_size, char *msg)\r\n{\r\n}\r\nstatic bool batadv_is_orig_node_eligible(struct batadv_dat_candidate *res,\r\nint select, batadv_dat_addr_t tmp_max,\r\nbatadv_dat_addr_t max,\r\nbatadv_dat_addr_t last_max,\r\nstruct batadv_orig_node *candidate,\r\nstruct batadv_orig_node *max_orig_node)\r\n{\r\nbool ret = false;\r\nint j;\r\nif (!test_bit(BATADV_ORIG_CAPA_HAS_DAT, &candidate->capabilities))\r\ngoto out;\r\nfor (j = 0; j < select; j++)\r\nif (res[j].orig_node == candidate)\r\nbreak;\r\nif (j < select)\r\ngoto out;\r\nif (tmp_max > last_max)\r\ngoto out;\r\nif (tmp_max < max)\r\ngoto out;\r\nif ((tmp_max == max) && max_orig_node &&\r\n(batadv_compare_eth(candidate->orig, max_orig_node->orig) > 0))\r\ngoto out;\r\nret = true;\r\nout:\r\nreturn ret;\r\n}\r\nstatic void batadv_choose_next_candidate(struct batadv_priv *bat_priv,\r\nstruct batadv_dat_candidate *cands,\r\nint select, batadv_dat_addr_t ip_key,\r\nbatadv_dat_addr_t *last_max)\r\n{\r\nbatadv_dat_addr_t max = 0;\r\nbatadv_dat_addr_t tmp_max = 0;\r\nstruct batadv_orig_node *orig_node, *max_orig_node = NULL;\r\nstruct batadv_hashtable *hash = bat_priv->orig_hash;\r\nstruct hlist_head *head;\r\nint i;\r\ncands[select].type = BATADV_DAT_CANDIDATE_NOT_FOUND;\r\nfor (i = 0; i < hash->size; i++) {\r\nhead = &hash->table[i];\r\nrcu_read_lock();\r\nhlist_for_each_entry_rcu(orig_node, head, hash_entry) {\r\ntmp_max = BATADV_DAT_ADDR_MAX - orig_node->dat_addr +\r\nip_key;\r\nif (!batadv_is_orig_node_eligible(cands, select,\r\ntmp_max, max,\r\n*last_max, orig_node,\r\nmax_orig_node))\r\ncontinue;\r\nif (!atomic_inc_not_zero(&orig_node->refcount))\r\ncontinue;\r\nmax = tmp_max;\r\nif (max_orig_node)\r\nbatadv_orig_node_free_ref(max_orig_node);\r\nmax_orig_node = orig_node;\r\n}\r\nrcu_read_unlock();\r\n}\r\nif (max_orig_node) {\r\ncands[select].type = BATADV_DAT_CANDIDATE_ORIG;\r\ncands[select].orig_node = max_orig_node;\r\nbatadv_dbg(BATADV_DBG_DAT, bat_priv,\r\n"dat_select_candidates() %d: selected %pM addr=%u dist=%u\n",\r\nselect, max_orig_node->orig, max_orig_node->dat_addr,\r\nmax);\r\n}\r\n*last_max = max;\r\n}\r\nstatic struct batadv_dat_candidate *\r\nbatadv_dat_select_candidates(struct batadv_priv *bat_priv, __be32 ip_dst)\r\n{\r\nint select;\r\nbatadv_dat_addr_t last_max = BATADV_DAT_ADDR_MAX, ip_key;\r\nstruct batadv_dat_candidate *res;\r\nstruct batadv_dat_entry dat;\r\nif (!bat_priv->orig_hash)\r\nreturn NULL;\r\nres = kmalloc_array(BATADV_DAT_CANDIDATES_NUM, sizeof(*res),\r\nGFP_ATOMIC);\r\nif (!res)\r\nreturn NULL;\r\ndat.ip = ip_dst;\r\ndat.vid = 0;\r\nip_key = (batadv_dat_addr_t)batadv_hash_dat(&dat,\r\nBATADV_DAT_ADDR_MAX);\r\nbatadv_dbg(BATADV_DBG_DAT, bat_priv,\r\n"dat_select_candidates(): IP=%pI4 hash(IP)=%u\n", &ip_dst,\r\nip_key);\r\nfor (select = 0; select < BATADV_DAT_CANDIDATES_NUM; select++)\r\nbatadv_choose_next_candidate(bat_priv, res, select, ip_key,\r\n&last_max);\r\nreturn res;\r\n}\r\nstatic bool batadv_dat_send_data(struct batadv_priv *bat_priv,\r\nstruct sk_buff *skb, __be32 ip,\r\nint packet_subtype)\r\n{\r\nint i;\r\nbool ret = false;\r\nint send_status;\r\nstruct batadv_neigh_node *neigh_node = NULL;\r\nstruct sk_buff *tmp_skb;\r\nstruct batadv_dat_candidate *cand;\r\ncand = batadv_dat_select_candidates(bat_priv, ip);\r\nif (!cand)\r\ngoto out;\r\nbatadv_dbg(BATADV_DBG_DAT, bat_priv, "DHT_SEND for %pI4\n", &ip);\r\nfor (i = 0; i < BATADV_DAT_CANDIDATES_NUM; i++) {\r\nif (cand[i].type == BATADV_DAT_CANDIDATE_NOT_FOUND)\r\ncontinue;\r\nneigh_node = batadv_orig_router_get(cand[i].orig_node,\r\nBATADV_IF_DEFAULT);\r\nif (!neigh_node)\r\ngoto free_orig;\r\ntmp_skb = pskb_copy_for_clone(skb, GFP_ATOMIC);\r\nif (!batadv_send_skb_prepare_unicast_4addr(bat_priv, tmp_skb,\r\ncand[i].orig_node,\r\npacket_subtype)) {\r\nkfree_skb(tmp_skb);\r\ngoto free_neigh;\r\n}\r\nsend_status = batadv_send_skb_packet(tmp_skb,\r\nneigh_node->if_incoming,\r\nneigh_node->addr);\r\nif (send_status == NET_XMIT_SUCCESS) {\r\nswitch (packet_subtype) {\r\ncase BATADV_P_DAT_DHT_GET:\r\nbatadv_inc_counter(bat_priv,\r\nBATADV_CNT_DAT_GET_TX);\r\nbreak;\r\ncase BATADV_P_DAT_DHT_PUT:\r\nbatadv_inc_counter(bat_priv,\r\nBATADV_CNT_DAT_PUT_TX);\r\nbreak;\r\n}\r\nret = true;\r\n}\r\nfree_neigh:\r\nbatadv_neigh_node_free_ref(neigh_node);\r\nfree_orig:\r\nbatadv_orig_node_free_ref(cand[i].orig_node);\r\n}\r\nout:\r\nkfree(cand);\r\nreturn ret;\r\n}\r\nstatic void batadv_dat_tvlv_container_update(struct batadv_priv *bat_priv)\r\n{\r\nchar dat_mode;\r\ndat_mode = atomic_read(&bat_priv->distributed_arp_table);\r\nswitch (dat_mode) {\r\ncase 0:\r\nbatadv_tvlv_container_unregister(bat_priv, BATADV_TVLV_DAT, 1);\r\nbreak;\r\ncase 1:\r\nbatadv_tvlv_container_register(bat_priv, BATADV_TVLV_DAT, 1,\r\nNULL, 0);\r\nbreak;\r\n}\r\n}\r\nvoid batadv_dat_status_update(struct net_device *net_dev)\r\n{\r\nstruct batadv_priv *bat_priv = netdev_priv(net_dev);\r\nbatadv_dat_tvlv_container_update(bat_priv);\r\n}\r\nstatic void batadv_dat_tvlv_ogm_handler_v1(struct batadv_priv *bat_priv,\r\nstruct batadv_orig_node *orig,\r\nu8 flags,\r\nvoid *tvlv_value, u16 tvlv_value_len)\r\n{\r\nif (flags & BATADV_TVLV_HANDLER_OGM_CIFNOTFND)\r\nclear_bit(BATADV_ORIG_CAPA_HAS_DAT, &orig->capabilities);\r\nelse\r\nset_bit(BATADV_ORIG_CAPA_HAS_DAT, &orig->capabilities);\r\n}\r\nstatic void batadv_dat_hash_free(struct batadv_priv *bat_priv)\r\n{\r\nif (!bat_priv->dat.hash)\r\nreturn;\r\n__batadv_dat_purge(bat_priv, NULL);\r\nbatadv_hash_destroy(bat_priv->dat.hash);\r\nbat_priv->dat.hash = NULL;\r\n}\r\nint batadv_dat_init(struct batadv_priv *bat_priv)\r\n{\r\nif (bat_priv->dat.hash)\r\nreturn 0;\r\nbat_priv->dat.hash = batadv_hash_new(1024);\r\nif (!bat_priv->dat.hash)\r\nreturn -ENOMEM;\r\nbatadv_dat_start_timer(bat_priv);\r\nbatadv_tvlv_handler_register(bat_priv, batadv_dat_tvlv_ogm_handler_v1,\r\nNULL, BATADV_TVLV_DAT, 1,\r\nBATADV_TVLV_HANDLER_OGM_CIFNOTFND);\r\nbatadv_dat_tvlv_container_update(bat_priv);\r\nreturn 0;\r\n}\r\nvoid batadv_dat_free(struct batadv_priv *bat_priv)\r\n{\r\nbatadv_tvlv_container_unregister(bat_priv, BATADV_TVLV_DAT, 1);\r\nbatadv_tvlv_handler_unregister(bat_priv, BATADV_TVLV_DAT, 1);\r\ncancel_delayed_work_sync(&bat_priv->dat.work);\r\nbatadv_dat_hash_free(bat_priv);\r\n}\r\nint batadv_dat_cache_seq_print_text(struct seq_file *seq, void *offset)\r\n{\r\nstruct net_device *net_dev = (struct net_device *)seq->private;\r\nstruct batadv_priv *bat_priv = netdev_priv(net_dev);\r\nstruct batadv_hashtable *hash = bat_priv->dat.hash;\r\nstruct batadv_dat_entry *dat_entry;\r\nstruct batadv_hard_iface *primary_if;\r\nstruct hlist_head *head;\r\nunsigned long last_seen_jiffies;\r\nint last_seen_msecs, last_seen_secs, last_seen_mins;\r\nu32 i;\r\nprimary_if = batadv_seq_print_text_primary_if_get(seq);\r\nif (!primary_if)\r\ngoto out;\r\nseq_printf(seq, "Distributed ARP Table (%s):\n", net_dev->name);\r\nseq_printf(seq, " %-7s %-9s %4s %11s\n", "IPv4",\r\n"MAC", "VID", "last-seen");\r\nfor (i = 0; i < hash->size; i++) {\r\nhead = &hash->table[i];\r\nrcu_read_lock();\r\nhlist_for_each_entry_rcu(dat_entry, head, hash_entry) {\r\nlast_seen_jiffies = jiffies - dat_entry->last_update;\r\nlast_seen_msecs = jiffies_to_msecs(last_seen_jiffies);\r\nlast_seen_mins = last_seen_msecs / 60000;\r\nlast_seen_msecs = last_seen_msecs % 60000;\r\nlast_seen_secs = last_seen_msecs / 1000;\r\nseq_printf(seq, " * %15pI4 %14pM %4i %6i:%02i\n",\r\n&dat_entry->ip, dat_entry->mac_addr,\r\nBATADV_PRINT_VID(dat_entry->vid),\r\nlast_seen_mins, last_seen_secs);\r\n}\r\nrcu_read_unlock();\r\n}\r\nout:\r\nif (primary_if)\r\nbatadv_hardif_free_ref(primary_if);\r\nreturn 0;\r\n}\r\nstatic u16 batadv_arp_get_type(struct batadv_priv *bat_priv,\r\nstruct sk_buff *skb, int hdr_size)\r\n{\r\nstruct arphdr *arphdr;\r\nstruct ethhdr *ethhdr;\r\n__be32 ip_src, ip_dst;\r\nu8 *hw_src, *hw_dst;\r\nu16 type = 0;\r\nif (unlikely(!pskb_may_pull(skb, hdr_size + ETH_HLEN)))\r\ngoto out;\r\nethhdr = (struct ethhdr *)(skb->data + hdr_size);\r\nif (ethhdr->h_proto != htons(ETH_P_ARP))\r\ngoto out;\r\nif (unlikely(!pskb_may_pull(skb, hdr_size + ETH_HLEN +\r\narp_hdr_len(skb->dev))))\r\ngoto out;\r\narphdr = (struct arphdr *)(skb->data + hdr_size + ETH_HLEN);\r\nif (arphdr->ar_hrd != htons(ARPHRD_ETHER))\r\ngoto out;\r\nif (arphdr->ar_pro != htons(ETH_P_IP))\r\ngoto out;\r\nif (arphdr->ar_hln != ETH_ALEN)\r\ngoto out;\r\nif (arphdr->ar_pln != 4)\r\ngoto out;\r\nip_src = batadv_arp_ip_src(skb, hdr_size);\r\nip_dst = batadv_arp_ip_dst(skb, hdr_size);\r\nif (ipv4_is_loopback(ip_src) || ipv4_is_multicast(ip_src) ||\r\nipv4_is_loopback(ip_dst) || ipv4_is_multicast(ip_dst) ||\r\nipv4_is_zeronet(ip_src) || ipv4_is_lbcast(ip_src) ||\r\nipv4_is_zeronet(ip_dst) || ipv4_is_lbcast(ip_dst))\r\ngoto out;\r\nhw_src = batadv_arp_hw_src(skb, hdr_size);\r\nif (is_zero_ether_addr(hw_src) || is_multicast_ether_addr(hw_src))\r\ngoto out;\r\nif (arphdr->ar_op != htons(ARPOP_REQUEST)) {\r\nhw_dst = batadv_arp_hw_dst(skb, hdr_size);\r\nif (is_zero_ether_addr(hw_dst) ||\r\nis_multicast_ether_addr(hw_dst))\r\ngoto out;\r\n}\r\ntype = ntohs(arphdr->ar_op);\r\nout:\r\nreturn type;\r\n}\r\nstatic unsigned short batadv_dat_get_vid(struct sk_buff *skb, int *hdr_size)\r\n{\r\nunsigned short vid;\r\nvid = batadv_get_vid(skb, *hdr_size);\r\nif (vid & BATADV_VLAN_HAS_TAG)\r\n*hdr_size += VLAN_HLEN;\r\nreturn vid;\r\n}\r\nbool batadv_dat_snoop_outgoing_arp_request(struct batadv_priv *bat_priv,\r\nstruct sk_buff *skb)\r\n{\r\nu16 type = 0;\r\n__be32 ip_dst, ip_src;\r\nu8 *hw_src;\r\nbool ret = false;\r\nstruct batadv_dat_entry *dat_entry = NULL;\r\nstruct sk_buff *skb_new;\r\nint hdr_size = 0;\r\nunsigned short vid;\r\nif (!atomic_read(&bat_priv->distributed_arp_table))\r\ngoto out;\r\nvid = batadv_dat_get_vid(skb, &hdr_size);\r\ntype = batadv_arp_get_type(bat_priv, skb, hdr_size);\r\nif (type != ARPOP_REQUEST)\r\ngoto out;\r\nbatadv_dbg_arp(bat_priv, skb, type, hdr_size,\r\n"Parsing outgoing ARP REQUEST");\r\nip_src = batadv_arp_ip_src(skb, hdr_size);\r\nhw_src = batadv_arp_hw_src(skb, hdr_size);\r\nip_dst = batadv_arp_ip_dst(skb, hdr_size);\r\nbatadv_dat_entry_add(bat_priv, ip_src, hw_src, vid);\r\ndat_entry = batadv_dat_entry_hash_find(bat_priv, ip_dst, vid);\r\nif (dat_entry) {\r\nif (batadv_is_my_client(bat_priv, dat_entry->mac_addr, vid)) {\r\nret = true;\r\ngoto out;\r\n}\r\nskb_new = arp_create(ARPOP_REPLY, ETH_P_ARP, ip_src,\r\nbat_priv->soft_iface, ip_dst, hw_src,\r\ndat_entry->mac_addr, hw_src);\r\nif (!skb_new)\r\ngoto out;\r\nif (vid & BATADV_VLAN_HAS_TAG)\r\nskb_new = vlan_insert_tag(skb_new, htons(ETH_P_8021Q),\r\nvid & VLAN_VID_MASK);\r\nskb_reset_mac_header(skb_new);\r\nskb_new->protocol = eth_type_trans(skb_new,\r\nbat_priv->soft_iface);\r\nbat_priv->stats.rx_packets++;\r\nbat_priv->stats.rx_bytes += skb->len + ETH_HLEN + hdr_size;\r\nbat_priv->soft_iface->last_rx = jiffies;\r\nnetif_rx(skb_new);\r\nbatadv_dbg(BATADV_DBG_DAT, bat_priv, "ARP request replied locally\n");\r\nret = true;\r\n} else {\r\nret = batadv_dat_send_data(bat_priv, skb, ip_dst,\r\nBATADV_P_DAT_DHT_GET);\r\n}\r\nout:\r\nif (dat_entry)\r\nbatadv_dat_entry_free_ref(dat_entry);\r\nreturn ret;\r\n}\r\nbool batadv_dat_snoop_incoming_arp_request(struct batadv_priv *bat_priv,\r\nstruct sk_buff *skb, int hdr_size)\r\n{\r\nu16 type;\r\n__be32 ip_src, ip_dst;\r\nu8 *hw_src;\r\nstruct sk_buff *skb_new;\r\nstruct batadv_dat_entry *dat_entry = NULL;\r\nbool ret = false;\r\nunsigned short vid;\r\nint err;\r\nif (!atomic_read(&bat_priv->distributed_arp_table))\r\ngoto out;\r\nvid = batadv_dat_get_vid(skb, &hdr_size);\r\ntype = batadv_arp_get_type(bat_priv, skb, hdr_size);\r\nif (type != ARPOP_REQUEST)\r\ngoto out;\r\nhw_src = batadv_arp_hw_src(skb, hdr_size);\r\nip_src = batadv_arp_ip_src(skb, hdr_size);\r\nip_dst = batadv_arp_ip_dst(skb, hdr_size);\r\nbatadv_dbg_arp(bat_priv, skb, type, hdr_size,\r\n"Parsing incoming ARP REQUEST");\r\nbatadv_dat_entry_add(bat_priv, ip_src, hw_src, vid);\r\ndat_entry = batadv_dat_entry_hash_find(bat_priv, ip_dst, vid);\r\nif (!dat_entry)\r\ngoto out;\r\nskb_new = arp_create(ARPOP_REPLY, ETH_P_ARP, ip_src,\r\nbat_priv->soft_iface, ip_dst, hw_src,\r\ndat_entry->mac_addr, hw_src);\r\nif (!skb_new)\r\ngoto out;\r\nskb_reset_mac_header(skb_new);\r\nif (vid & BATADV_VLAN_HAS_TAG)\r\nskb_new = vlan_insert_tag(skb_new, htons(ETH_P_8021Q),\r\nvid & VLAN_VID_MASK);\r\nif (hdr_size == sizeof(struct batadv_unicast_4addr_packet))\r\nerr = batadv_send_skb_via_tt_4addr(bat_priv, skb_new,\r\nBATADV_P_DAT_CACHE_REPLY,\r\nNULL, vid);\r\nelse\r\nerr = batadv_send_skb_via_tt(bat_priv, skb_new, NULL, vid);\r\nif (err != NET_XMIT_DROP) {\r\nbatadv_inc_counter(bat_priv, BATADV_CNT_DAT_CACHED_REPLY_TX);\r\nret = true;\r\n}\r\nout:\r\nif (dat_entry)\r\nbatadv_dat_entry_free_ref(dat_entry);\r\nif (ret)\r\nkfree_skb(skb);\r\nreturn ret;\r\n}\r\nvoid batadv_dat_snoop_outgoing_arp_reply(struct batadv_priv *bat_priv,\r\nstruct sk_buff *skb)\r\n{\r\nu16 type;\r\n__be32 ip_src, ip_dst;\r\nu8 *hw_src, *hw_dst;\r\nint hdr_size = 0;\r\nunsigned short vid;\r\nif (!atomic_read(&bat_priv->distributed_arp_table))\r\nreturn;\r\nvid = batadv_dat_get_vid(skb, &hdr_size);\r\ntype = batadv_arp_get_type(bat_priv, skb, hdr_size);\r\nif (type != ARPOP_REPLY)\r\nreturn;\r\nbatadv_dbg_arp(bat_priv, skb, type, hdr_size,\r\n"Parsing outgoing ARP REPLY");\r\nhw_src = batadv_arp_hw_src(skb, hdr_size);\r\nip_src = batadv_arp_ip_src(skb, hdr_size);\r\nhw_dst = batadv_arp_hw_dst(skb, hdr_size);\r\nip_dst = batadv_arp_ip_dst(skb, hdr_size);\r\nbatadv_dat_entry_add(bat_priv, ip_src, hw_src, vid);\r\nbatadv_dat_entry_add(bat_priv, ip_dst, hw_dst, vid);\r\nbatadv_dat_send_data(bat_priv, skb, ip_src, BATADV_P_DAT_DHT_PUT);\r\nbatadv_dat_send_data(bat_priv, skb, ip_dst, BATADV_P_DAT_DHT_PUT);\r\n}\r\nbool batadv_dat_snoop_incoming_arp_reply(struct batadv_priv *bat_priv,\r\nstruct sk_buff *skb, int hdr_size)\r\n{\r\nu16 type;\r\n__be32 ip_src, ip_dst;\r\nu8 *hw_src, *hw_dst;\r\nbool dropped = false;\r\nunsigned short vid;\r\nif (!atomic_read(&bat_priv->distributed_arp_table))\r\ngoto out;\r\nvid = batadv_dat_get_vid(skb, &hdr_size);\r\ntype = batadv_arp_get_type(bat_priv, skb, hdr_size);\r\nif (type != ARPOP_REPLY)\r\ngoto out;\r\nbatadv_dbg_arp(bat_priv, skb, type, hdr_size,\r\n"Parsing incoming ARP REPLY");\r\nhw_src = batadv_arp_hw_src(skb, hdr_size);\r\nip_src = batadv_arp_ip_src(skb, hdr_size);\r\nhw_dst = batadv_arp_hw_dst(skb, hdr_size);\r\nip_dst = batadv_arp_ip_dst(skb, hdr_size);\r\nbatadv_dat_entry_add(bat_priv, ip_src, hw_src, vid);\r\nbatadv_dat_entry_add(bat_priv, ip_dst, hw_dst, vid);\r\ndropped = !batadv_is_my_client(bat_priv, hw_dst, vid);\r\ndropped |= batadv_is_my_client(bat_priv, hw_src, vid);\r\nout:\r\nif (dropped)\r\nkfree_skb(skb);\r\nreturn dropped;\r\n}\r\nbool batadv_dat_drop_broadcast_packet(struct batadv_priv *bat_priv,\r\nstruct batadv_forw_packet *forw_packet)\r\n{\r\nu16 type;\r\n__be32 ip_dst;\r\nstruct batadv_dat_entry *dat_entry = NULL;\r\nbool ret = false;\r\nint hdr_size = sizeof(struct batadv_bcast_packet);\r\nunsigned short vid;\r\nif (!atomic_read(&bat_priv->distributed_arp_table))\r\ngoto out;\r\nif (forw_packet->num_packets)\r\ngoto out;\r\nvid = batadv_dat_get_vid(forw_packet->skb, &hdr_size);\r\ntype = batadv_arp_get_type(bat_priv, forw_packet->skb, hdr_size);\r\nif (type != ARPOP_REQUEST)\r\ngoto out;\r\nip_dst = batadv_arp_ip_dst(forw_packet->skb, hdr_size);\r\ndat_entry = batadv_dat_entry_hash_find(bat_priv, ip_dst, vid);\r\nif (!dat_entry) {\r\nbatadv_dbg(BATADV_DBG_DAT, bat_priv,\r\n"ARP Request for %pI4: fallback\n", &ip_dst);\r\ngoto out;\r\n}\r\nbatadv_dbg(BATADV_DBG_DAT, bat_priv,\r\n"ARP Request for %pI4: fallback prevented\n", &ip_dst);\r\nret = true;\r\nout:\r\nif (dat_entry)\r\nbatadv_dat_entry_free_ref(dat_entry);\r\nreturn ret;\r\n}
