static ssize_t sram_read(struct file *filp, struct kobject *kobj,\r\nstruct bin_attribute *attr,\r\nchar *buf, loff_t pos, size_t count)\r\n{\r\nstruct sram_partition *part;\r\npart = container_of(attr, struct sram_partition, battr);\r\nmutex_lock(&part->lock);\r\nmemcpy_fromio(buf, part->base + pos, count);\r\nmutex_unlock(&part->lock);\r\nreturn count;\r\n}\r\nstatic ssize_t sram_write(struct file *filp, struct kobject *kobj,\r\nstruct bin_attribute *attr,\r\nchar *buf, loff_t pos, size_t count)\r\n{\r\nstruct sram_partition *part;\r\npart = container_of(attr, struct sram_partition, battr);\r\nmutex_lock(&part->lock);\r\nmemcpy_toio(part->base + pos, buf, count);\r\nmutex_unlock(&part->lock);\r\nreturn count;\r\n}\r\nstatic int sram_add_pool(struct sram_dev *sram, struct sram_reserve *block,\r\nphys_addr_t start, struct sram_partition *part)\r\n{\r\nint ret;\r\npart->pool = devm_gen_pool_create(sram->dev, ilog2(SRAM_GRANULARITY),\r\nNUMA_NO_NODE, block->label);\r\nif (IS_ERR(part->pool))\r\nreturn PTR_ERR(part->pool);\r\nret = gen_pool_add_virt(part->pool, (unsigned long)part->base, start,\r\nblock->size, NUMA_NO_NODE);\r\nif (ret < 0) {\r\ndev_err(sram->dev, "failed to register subpool: %d\n", ret);\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic int sram_add_export(struct sram_dev *sram, struct sram_reserve *block,\r\nphys_addr_t start, struct sram_partition *part)\r\n{\r\nsysfs_bin_attr_init(&part->battr);\r\npart->battr.attr.name = devm_kasprintf(sram->dev, GFP_KERNEL,\r\n"%llx.sram",\r\n(unsigned long long)start);\r\nif (!part->battr.attr.name)\r\nreturn -ENOMEM;\r\npart->battr.attr.mode = S_IRUSR | S_IWUSR;\r\npart->battr.read = sram_read;\r\npart->battr.write = sram_write;\r\npart->battr.size = block->size;\r\nreturn device_create_bin_file(sram->dev, &part->battr);\r\n}\r\nstatic int sram_add_partition(struct sram_dev *sram, struct sram_reserve *block,\r\nphys_addr_t start)\r\n{\r\nint ret;\r\nstruct sram_partition *part = &sram->partition[sram->partitions];\r\nmutex_init(&part->lock);\r\npart->base = sram->virt_base + block->start;\r\nif (block->pool) {\r\nret = sram_add_pool(sram, block, start, part);\r\nif (ret)\r\nreturn ret;\r\n}\r\nif (block->export) {\r\nret = sram_add_export(sram, block, start, part);\r\nif (ret)\r\nreturn ret;\r\n}\r\nsram->partitions++;\r\nreturn 0;\r\n}\r\nstatic void sram_free_partitions(struct sram_dev *sram)\r\n{\r\nstruct sram_partition *part;\r\nif (!sram->partitions)\r\nreturn;\r\npart = &sram->partition[sram->partitions - 1];\r\nfor (; sram->partitions; sram->partitions--, part--) {\r\nif (part->battr.size)\r\ndevice_remove_bin_file(sram->dev, &part->battr);\r\nif (part->pool &&\r\ngen_pool_avail(part->pool) < gen_pool_size(part->pool))\r\ndev_err(sram->dev, "removed pool while SRAM allocated\n");\r\n}\r\n}\r\nstatic int sram_reserve_cmp(void *priv, struct list_head *a,\r\nstruct list_head *b)\r\n{\r\nstruct sram_reserve *ra = list_entry(a, struct sram_reserve, list);\r\nstruct sram_reserve *rb = list_entry(b, struct sram_reserve, list);\r\nreturn ra->start - rb->start;\r\n}\r\nstatic int sram_reserve_regions(struct sram_dev *sram, struct resource *res)\r\n{\r\nstruct device_node *np = sram->dev->of_node, *child;\r\nunsigned long size, cur_start, cur_size;\r\nstruct sram_reserve *rblocks, *block;\r\nstruct list_head reserve_list;\r\nunsigned int nblocks, exports = 0;\r\nconst char *label;\r\nint ret = 0;\r\nINIT_LIST_HEAD(&reserve_list);\r\nsize = resource_size(res);\r\nnblocks = (np) ? of_get_available_child_count(np) + 1 : 1;\r\nrblocks = kzalloc((nblocks) * sizeof(*rblocks), GFP_KERNEL);\r\nif (!rblocks)\r\nreturn -ENOMEM;\r\nblock = &rblocks[0];\r\nfor_each_available_child_of_node(np, child) {\r\nstruct resource child_res;\r\nret = of_address_to_resource(child, 0, &child_res);\r\nif (ret < 0) {\r\ndev_err(sram->dev,\r\n"could not get address for node %s\n",\r\nchild->full_name);\r\ngoto err_chunks;\r\n}\r\nif (child_res.start < res->start || child_res.end > res->end) {\r\ndev_err(sram->dev,\r\n"reserved block %s outside the sram area\n",\r\nchild->full_name);\r\nret = -EINVAL;\r\ngoto err_chunks;\r\n}\r\nblock->start = child_res.start - res->start;\r\nblock->size = resource_size(&child_res);\r\nlist_add_tail(&block->list, &reserve_list);\r\nif (of_find_property(child, "export", NULL))\r\nblock->export = true;\r\nif (of_find_property(child, "pool", NULL))\r\nblock->pool = true;\r\nif ((block->export || block->pool) && block->size) {\r\nexports++;\r\nlabel = NULL;\r\nret = of_property_read_string(child, "label", &label);\r\nif (ret && ret != -EINVAL) {\r\ndev_err(sram->dev,\r\n"%s has invalid label name\n",\r\nchild->full_name);\r\ngoto err_chunks;\r\n}\r\nif (!label)\r\nlabel = child->name;\r\nblock->label = devm_kstrdup(sram->dev,\r\nlabel, GFP_KERNEL);\r\nif (!block->label)\r\ngoto err_chunks;\r\ndev_dbg(sram->dev, "found %sblock '%s' 0x%x-0x%x\n",\r\nblock->export ? "exported " : "", block->label,\r\nblock->start, block->start + block->size);\r\n} else {\r\ndev_dbg(sram->dev, "found reserved block 0x%x-0x%x\n",\r\nblock->start, block->start + block->size);\r\n}\r\nblock++;\r\n}\r\nchild = NULL;\r\nrblocks[nblocks - 1].start = size;\r\nrblocks[nblocks - 1].size = 0;\r\nlist_add_tail(&rblocks[nblocks - 1].list, &reserve_list);\r\nlist_sort(NULL, &reserve_list, sram_reserve_cmp);\r\nif (exports) {\r\nsram->partition = devm_kzalloc(sram->dev,\r\nexports * sizeof(*sram->partition),\r\nGFP_KERNEL);\r\nif (!sram->partition) {\r\nret = -ENOMEM;\r\ngoto err_chunks;\r\n}\r\n}\r\ncur_start = 0;\r\nlist_for_each_entry(block, &reserve_list, list) {\r\nif (block->start < cur_start) {\r\ndev_err(sram->dev,\r\n"block at 0x%x starts after current offset 0x%lx\n",\r\nblock->start, cur_start);\r\nret = -EINVAL;\r\nsram_free_partitions(sram);\r\ngoto err_chunks;\r\n}\r\nif ((block->export || block->pool) && block->size) {\r\nret = sram_add_partition(sram, block,\r\nres->start + block->start);\r\nif (ret) {\r\nsram_free_partitions(sram);\r\ngoto err_chunks;\r\n}\r\n}\r\nif (block->start == cur_start) {\r\ncur_start = block->start + block->size;\r\ncontinue;\r\n}\r\ncur_size = block->start - cur_start;\r\ndev_dbg(sram->dev, "adding chunk 0x%lx-0x%lx\n",\r\ncur_start, cur_start + cur_size);\r\nret = gen_pool_add_virt(sram->pool,\r\n(unsigned long)sram->virt_base + cur_start,\r\nres->start + cur_start, cur_size, -1);\r\nif (ret < 0) {\r\nsram_free_partitions(sram);\r\ngoto err_chunks;\r\n}\r\ncur_start = block->start + block->size;\r\n}\r\nerr_chunks:\r\nif (child)\r\nof_node_put(child);\r\nkfree(rblocks);\r\nreturn ret;\r\n}\r\nstatic int sram_probe(struct platform_device *pdev)\r\n{\r\nstruct sram_dev *sram;\r\nstruct resource *res;\r\nsize_t size;\r\nint ret;\r\nsram = devm_kzalloc(&pdev->dev, sizeof(*sram), GFP_KERNEL);\r\nif (!sram)\r\nreturn -ENOMEM;\r\nsram->dev = &pdev->dev;\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nif (!res) {\r\ndev_err(sram->dev, "found no memory resource\n");\r\nreturn -EINVAL;\r\n}\r\nsize = resource_size(res);\r\nif (!devm_request_mem_region(sram->dev, res->start, size, pdev->name)) {\r\ndev_err(sram->dev, "could not request region for resource\n");\r\nreturn -EBUSY;\r\n}\r\nsram->virt_base = devm_ioremap_wc(sram->dev, res->start, size);\r\nif (IS_ERR(sram->virt_base))\r\nreturn PTR_ERR(sram->virt_base);\r\nsram->pool = devm_gen_pool_create(sram->dev, ilog2(SRAM_GRANULARITY),\r\nNUMA_NO_NODE, NULL);\r\nif (IS_ERR(sram->pool))\r\nreturn PTR_ERR(sram->pool);\r\nret = sram_reserve_regions(sram, res);\r\nif (ret)\r\nreturn ret;\r\nsram->clk = devm_clk_get(sram->dev, NULL);\r\nif (IS_ERR(sram->clk))\r\nsram->clk = NULL;\r\nelse\r\nclk_prepare_enable(sram->clk);\r\nplatform_set_drvdata(pdev, sram);\r\ndev_dbg(sram->dev, "SRAM pool: %zu KiB @ 0x%p\n",\r\ngen_pool_size(sram->pool) / 1024, sram->virt_base);\r\nreturn 0;\r\n}\r\nstatic int sram_remove(struct platform_device *pdev)\r\n{\r\nstruct sram_dev *sram = platform_get_drvdata(pdev);\r\nsram_free_partitions(sram);\r\nif (gen_pool_avail(sram->pool) < gen_pool_size(sram->pool))\r\ndev_err(sram->dev, "removed while SRAM allocated\n");\r\nif (sram->clk)\r\nclk_disable_unprepare(sram->clk);\r\nreturn 0;\r\n}\r\nstatic int __init sram_init(void)\r\n{\r\nreturn platform_driver_register(&sram_driver);\r\n}
