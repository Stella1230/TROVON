static int iio_trig_periodic_rtc_set_state(struct iio_trigger *trig, bool state)\r\n{\r\nstruct iio_prtc_trigger_info *trig_info = iio_trigger_get_drvdata(trig);\r\nint ret;\r\nif (trig_info->frequency == 0 && state)\r\nreturn -EINVAL;\r\ndev_dbg(&trig_info->rtc->dev, "trigger frequency is %u\n",\r\ntrig_info->frequency);\r\nret = rtc_irq_set_state(trig_info->rtc, &trig_info->task, state);\r\nif (!ret)\r\ntrig_info->state = state;\r\nreturn ret;\r\n}\r\nstatic ssize_t iio_trig_periodic_read_freq(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct iio_trigger *trig = to_iio_trigger(dev);\r\nstruct iio_prtc_trigger_info *trig_info = iio_trigger_get_drvdata(trig);\r\nreturn sprintf(buf, "%u\n", trig_info->frequency);\r\n}\r\nstatic ssize_t iio_trig_periodic_write_freq(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf,\r\nsize_t len)\r\n{\r\nstruct iio_trigger *trig = to_iio_trigger(dev);\r\nstruct iio_prtc_trigger_info *trig_info = iio_trigger_get_drvdata(trig);\r\nunsigned int val;\r\nint ret;\r\nret = kstrtouint(buf, 10, &val);\r\nif (ret)\r\ngoto error_ret;\r\nif (val > 0) {\r\nret = rtc_irq_set_freq(trig_info->rtc, &trig_info->task, val);\r\nif (ret == 0 && trig_info->state && trig_info->frequency == 0)\r\nret = rtc_irq_set_state(trig_info->rtc,\r\n&trig_info->task, 1);\r\n} else {\r\nret = rtc_irq_set_state(trig_info->rtc, &trig_info->task, 0);\r\n}\r\nif (ret)\r\ngoto error_ret;\r\ntrig_info->frequency = val;\r\nreturn len;\r\nerror_ret:\r\nreturn ret;\r\n}\r\nstatic void iio_prtc_trigger_poll(void *private_data)\r\n{\r\niio_trigger_poll(private_data);\r\n}\r\nstatic int iio_trig_periodic_rtc_probe(struct platform_device *dev)\r\n{\r\nchar **pdata = dev->dev.platform_data;\r\nstruct iio_prtc_trigger_info *trig_info;\r\nstruct iio_trigger *trig, *trig2;\r\nint i, ret;\r\nfor (i = 0;; i++) {\r\nif (!pdata[i])\r\nbreak;\r\ntrig = iio_trigger_alloc("periodic%s", pdata[i]);\r\nif (!trig) {\r\nret = -ENOMEM;\r\ngoto error_free_completed_registrations;\r\n}\r\nlist_add(&trig->alloc_list, &iio_prtc_trigger_list);\r\ntrig_info = kzalloc(sizeof(*trig_info), GFP_KERNEL);\r\nif (!trig_info) {\r\nret = -ENOMEM;\r\ngoto error_put_trigger_and_remove_from_list;\r\n}\r\niio_trigger_set_drvdata(trig, trig_info);\r\ntrig->ops = &iio_prtc_trigger_ops;\r\ntrig_info->rtc = rtc_class_open(pdata[i]);\r\nif (!trig_info->rtc) {\r\nret = -EINVAL;\r\ngoto error_free_trig_info;\r\n}\r\ntrig_info->task.func = iio_prtc_trigger_poll;\r\ntrig_info->task.private_data = trig;\r\nret = rtc_irq_register(trig_info->rtc, &trig_info->task);\r\nif (ret)\r\ngoto error_close_rtc;\r\ntrig->dev.groups = iio_trig_prtc_attr_groups;\r\nret = iio_trigger_register(trig);\r\nif (ret)\r\ngoto error_unregister_rtc_irq;\r\n}\r\nreturn 0;\r\nerror_unregister_rtc_irq:\r\nrtc_irq_unregister(trig_info->rtc, &trig_info->task);\r\nerror_close_rtc:\r\nrtc_class_close(trig_info->rtc);\r\nerror_free_trig_info:\r\nkfree(trig_info);\r\nerror_put_trigger_and_remove_from_list:\r\nlist_del(&trig->alloc_list);\r\niio_trigger_put(trig);\r\nerror_free_completed_registrations:\r\nlist_for_each_entry_safe(trig,\r\ntrig2,\r\n&iio_prtc_trigger_list,\r\nalloc_list) {\r\ntrig_info = iio_trigger_get_drvdata(trig);\r\nrtc_irq_unregister(trig_info->rtc, &trig_info->task);\r\nrtc_class_close(trig_info->rtc);\r\nkfree(trig_info);\r\niio_trigger_unregister(trig);\r\n}\r\nreturn ret;\r\n}\r\nstatic int iio_trig_periodic_rtc_remove(struct platform_device *dev)\r\n{\r\nstruct iio_trigger *trig, *trig2;\r\nstruct iio_prtc_trigger_info *trig_info;\r\nmutex_lock(&iio_prtc_trigger_list_lock);\r\nlist_for_each_entry_safe(trig,\r\ntrig2,\r\n&iio_prtc_trigger_list,\r\nalloc_list) {\r\ntrig_info = iio_trigger_get_drvdata(trig);\r\nrtc_irq_unregister(trig_info->rtc, &trig_info->task);\r\nrtc_class_close(trig_info->rtc);\r\nkfree(trig_info);\r\niio_trigger_unregister(trig);\r\n}\r\nmutex_unlock(&iio_prtc_trigger_list_lock);\r\nreturn 0;\r\n}
