static int output_select_apply(struct oxygen *chip)\r\n{\r\nstruct dg *data = chip->model_data;\r\ndata->cs4245_shadow[CS4245_SIGNAL_SEL] &= ~CS4245_A_OUT_SEL_MASK;\r\nif (data->output_sel == PLAYBACK_DST_HP) {\r\noxygen_set_bits8(chip, OXYGEN_GPIO_DATA, GPIO_HP_REAR);\r\n} else if (data->output_sel == PLAYBACK_DST_HP_FP) {\r\noxygen_clear_bits8(chip, OXYGEN_GPIO_DATA, GPIO_HP_REAR);\r\ndata->cs4245_shadow[CS4245_SIGNAL_SEL] |= CS4245_A_OUT_SEL_DAC;\r\n} else {\r\noxygen_clear_bits8(chip, OXYGEN_GPIO_DATA, GPIO_HP_REAR);\r\n}\r\nreturn cs4245_write_spi(chip, CS4245_SIGNAL_SEL);\r\n}\r\nstatic int output_select_info(struct snd_kcontrol *ctl,\r\nstruct snd_ctl_elem_info *info)\r\n{\r\nstatic const char *const names[3] = {\r\n"Stereo Headphones",\r\n"Stereo Headphones FP",\r\n"Multichannel",\r\n};\r\nreturn snd_ctl_enum_info(info, 1, 3, names);\r\n}\r\nstatic int output_select_get(struct snd_kcontrol *ctl,\r\nstruct snd_ctl_elem_value *value)\r\n{\r\nstruct oxygen *chip = ctl->private_data;\r\nstruct dg *data = chip->model_data;\r\nmutex_lock(&chip->mutex);\r\nvalue->value.enumerated.item[0] = data->output_sel;\r\nmutex_unlock(&chip->mutex);\r\nreturn 0;\r\n}\r\nstatic int output_select_put(struct snd_kcontrol *ctl,\r\nstruct snd_ctl_elem_value *value)\r\n{\r\nstruct oxygen *chip = ctl->private_data;\r\nstruct dg *data = chip->model_data;\r\nunsigned int new = value->value.enumerated.item[0];\r\nint changed = 0;\r\nint ret;\r\nmutex_lock(&chip->mutex);\r\nif (data->output_sel != new) {\r\ndata->output_sel = new;\r\nret = output_select_apply(chip);\r\nchanged = ret >= 0 ? 1 : ret;\r\noxygen_update_dac_routing(chip);\r\n}\r\nmutex_unlock(&chip->mutex);\r\nreturn changed;\r\n}\r\nstatic int hp_stereo_volume_info(struct snd_kcontrol *ctl,\r\nstruct snd_ctl_elem_info *info)\r\n{\r\ninfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;\r\ninfo->count = 2;\r\ninfo->value.integer.min = 0;\r\ninfo->value.integer.max = 255;\r\nreturn 0;\r\n}\r\nstatic int hp_stereo_volume_get(struct snd_kcontrol *ctl,\r\nstruct snd_ctl_elem_value *val)\r\n{\r\nstruct oxygen *chip = ctl->private_data;\r\nstruct dg *data = chip->model_data;\r\nunsigned int tmp;\r\nmutex_lock(&chip->mutex);\r\ntmp = (~data->cs4245_shadow[CS4245_DAC_A_CTRL]) & 255;\r\nval->value.integer.value[0] = tmp;\r\ntmp = (~data->cs4245_shadow[CS4245_DAC_B_CTRL]) & 255;\r\nval->value.integer.value[1] = tmp;\r\nmutex_unlock(&chip->mutex);\r\nreturn 0;\r\n}\r\nstatic int hp_stereo_volume_put(struct snd_kcontrol *ctl,\r\nstruct snd_ctl_elem_value *val)\r\n{\r\nstruct oxygen *chip = ctl->private_data;\r\nstruct dg *data = chip->model_data;\r\nint ret;\r\nint changed = 0;\r\nlong new1 = val->value.integer.value[0];\r\nlong new2 = val->value.integer.value[1];\r\nif ((new1 > 255) || (new1 < 0) || (new2 > 255) || (new2 < 0))\r\nreturn -EINVAL;\r\nmutex_lock(&chip->mutex);\r\nif ((data->cs4245_shadow[CS4245_DAC_A_CTRL] != ~new1) ||\r\n(data->cs4245_shadow[CS4245_DAC_B_CTRL] != ~new2)) {\r\ndata->cs4245_shadow[CS4245_DAC_A_CTRL] = ~new1;\r\ndata->cs4245_shadow[CS4245_DAC_B_CTRL] = ~new2;\r\nret = cs4245_write_spi(chip, CS4245_DAC_A_CTRL);\r\nif (ret >= 0)\r\nret = cs4245_write_spi(chip, CS4245_DAC_B_CTRL);\r\nchanged = ret >= 0 ? 1 : ret;\r\n}\r\nmutex_unlock(&chip->mutex);\r\nreturn changed;\r\n}\r\nstatic int hp_mute_get(struct snd_kcontrol *ctl,\r\nstruct snd_ctl_elem_value *val)\r\n{\r\nstruct oxygen *chip = ctl->private_data;\r\nstruct dg *data = chip->model_data;\r\nmutex_lock(&chip->mutex);\r\nval->value.integer.value[0] =\r\n!(data->cs4245_shadow[CS4245_DAC_CTRL_1] & CS4245_MUTE_DAC);\r\nmutex_unlock(&chip->mutex);\r\nreturn 0;\r\n}\r\nstatic int hp_mute_put(struct snd_kcontrol *ctl,\r\nstruct snd_ctl_elem_value *val)\r\n{\r\nstruct oxygen *chip = ctl->private_data;\r\nstruct dg *data = chip->model_data;\r\nint ret;\r\nint changed;\r\nif (val->value.integer.value[0] > 1)\r\nreturn -EINVAL;\r\nmutex_lock(&chip->mutex);\r\ndata->cs4245_shadow[CS4245_DAC_CTRL_1] &= ~CS4245_MUTE_DAC;\r\ndata->cs4245_shadow[CS4245_DAC_CTRL_1] |=\r\n(~val->value.integer.value[0] << 2) & CS4245_MUTE_DAC;\r\nret = cs4245_write_spi(chip, CS4245_DAC_CTRL_1);\r\nchanged = ret >= 0 ? 1 : ret;\r\nmutex_unlock(&chip->mutex);\r\nreturn changed;\r\n}\r\nstatic int input_volume_apply(struct oxygen *chip, char left, char right)\r\n{\r\nstruct dg *data = chip->model_data;\r\nint ret;\r\ndata->cs4245_shadow[CS4245_PGA_A_CTRL] = left;\r\ndata->cs4245_shadow[CS4245_PGA_B_CTRL] = right;\r\nret = cs4245_write_spi(chip, CS4245_PGA_A_CTRL);\r\nif (ret < 0)\r\nreturn ret;\r\nreturn cs4245_write_spi(chip, CS4245_PGA_B_CTRL);\r\n}\r\nstatic int input_vol_info(struct snd_kcontrol *ctl,\r\nstruct snd_ctl_elem_info *info)\r\n{\r\ninfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;\r\ninfo->count = 2;\r\ninfo->value.integer.min = 2 * -12;\r\ninfo->value.integer.max = 2 * 12;\r\nreturn 0;\r\n}\r\nstatic int input_vol_get(struct snd_kcontrol *ctl,\r\nstruct snd_ctl_elem_value *value)\r\n{\r\nstruct oxygen *chip = ctl->private_data;\r\nstruct dg *data = chip->model_data;\r\nunsigned int idx = ctl->private_value;\r\nmutex_lock(&chip->mutex);\r\nvalue->value.integer.value[0] = data->input_vol[idx][0];\r\nvalue->value.integer.value[1] = data->input_vol[idx][1];\r\nmutex_unlock(&chip->mutex);\r\nreturn 0;\r\n}\r\nstatic int input_vol_put(struct snd_kcontrol *ctl,\r\nstruct snd_ctl_elem_value *value)\r\n{\r\nstruct oxygen *chip = ctl->private_data;\r\nstruct dg *data = chip->model_data;\r\nunsigned int idx = ctl->private_value;\r\nint changed = 0;\r\nint ret = 0;\r\nif (value->value.integer.value[0] < 2 * -12 ||\r\nvalue->value.integer.value[0] > 2 * 12 ||\r\nvalue->value.integer.value[1] < 2 * -12 ||\r\nvalue->value.integer.value[1] > 2 * 12)\r\nreturn -EINVAL;\r\nmutex_lock(&chip->mutex);\r\nchanged = data->input_vol[idx][0] != value->value.integer.value[0] ||\r\ndata->input_vol[idx][1] != value->value.integer.value[1];\r\nif (changed) {\r\ndata->input_vol[idx][0] = value->value.integer.value[0];\r\ndata->input_vol[idx][1] = value->value.integer.value[1];\r\nif (idx == data->input_sel) {\r\nret = input_volume_apply(chip,\r\ndata->input_vol[idx][0],\r\ndata->input_vol[idx][1]);\r\n}\r\nchanged = ret >= 0 ? 1 : ret;\r\n}\r\nmutex_unlock(&chip->mutex);\r\nreturn changed;\r\n}\r\nstatic int input_source_apply(struct oxygen *chip)\r\n{\r\nstruct dg *data = chip->model_data;\r\ndata->cs4245_shadow[CS4245_ANALOG_IN] &= ~CS4245_SEL_MASK;\r\nif (data->input_sel == CAPTURE_SRC_FP_MIC)\r\ndata->cs4245_shadow[CS4245_ANALOG_IN] |= CS4245_SEL_INPUT_2;\r\nelse if (data->input_sel == CAPTURE_SRC_LINE)\r\ndata->cs4245_shadow[CS4245_ANALOG_IN] |= CS4245_SEL_INPUT_4;\r\nelse if (data->input_sel != CAPTURE_SRC_MIC)\r\ndata->cs4245_shadow[CS4245_ANALOG_IN] |= CS4245_SEL_INPUT_1;\r\nreturn cs4245_write_spi(chip, CS4245_ANALOG_IN);\r\n}\r\nstatic int input_sel_info(struct snd_kcontrol *ctl,\r\nstruct snd_ctl_elem_info *info)\r\n{\r\nstatic const char *const names[4] = {\r\n"Mic", "Front Mic", "Line", "Aux"\r\n};\r\nreturn snd_ctl_enum_info(info, 1, 4, names);\r\n}\r\nstatic int input_sel_get(struct snd_kcontrol *ctl,\r\nstruct snd_ctl_elem_value *value)\r\n{\r\nstruct oxygen *chip = ctl->private_data;\r\nstruct dg *data = chip->model_data;\r\nmutex_lock(&chip->mutex);\r\nvalue->value.enumerated.item[0] = data->input_sel;\r\nmutex_unlock(&chip->mutex);\r\nreturn 0;\r\n}\r\nstatic int input_sel_put(struct snd_kcontrol *ctl,\r\nstruct snd_ctl_elem_value *value)\r\n{\r\nstruct oxygen *chip = ctl->private_data;\r\nstruct dg *data = chip->model_data;\r\nint changed;\r\nint ret;\r\nif (value->value.enumerated.item[0] > 3)\r\nreturn -EINVAL;\r\nmutex_lock(&chip->mutex);\r\nchanged = value->value.enumerated.item[0] != data->input_sel;\r\nif (changed) {\r\ndata->input_sel = value->value.enumerated.item[0];\r\nret = input_source_apply(chip);\r\nif (ret >= 0)\r\nret = input_volume_apply(chip,\r\ndata->input_vol[data->input_sel][0],\r\ndata->input_vol[data->input_sel][1]);\r\nchanged = ret >= 0 ? 1 : ret;\r\n}\r\nmutex_unlock(&chip->mutex);\r\nreturn changed;\r\n}\r\nstatic int hpf_info(struct snd_kcontrol *ctl, struct snd_ctl_elem_info *info)\r\n{\r\nstatic const char *const names[2] = { "Active", "Frozen" };\r\nreturn snd_ctl_enum_info(info, 1, 2, names);\r\n}\r\nstatic int hpf_get(struct snd_kcontrol *ctl, struct snd_ctl_elem_value *value)\r\n{\r\nstruct oxygen *chip = ctl->private_data;\r\nstruct dg *data = chip->model_data;\r\nvalue->value.enumerated.item[0] =\r\n!!(data->cs4245_shadow[CS4245_ADC_CTRL] & CS4245_HPF_FREEZE);\r\nreturn 0;\r\n}\r\nstatic int hpf_put(struct snd_kcontrol *ctl, struct snd_ctl_elem_value *value)\r\n{\r\nstruct oxygen *chip = ctl->private_data;\r\nstruct dg *data = chip->model_data;\r\nu8 reg;\r\nint changed;\r\nmutex_lock(&chip->mutex);\r\nreg = data->cs4245_shadow[CS4245_ADC_CTRL] & ~CS4245_HPF_FREEZE;\r\nif (value->value.enumerated.item[0])\r\nreg |= CS4245_HPF_FREEZE;\r\nchanged = reg != data->cs4245_shadow[CS4245_ADC_CTRL];\r\nif (changed) {\r\ndata->cs4245_shadow[CS4245_ADC_CTRL] = reg;\r\ncs4245_write_spi(chip, CS4245_ADC_CTRL);\r\n}\r\nmutex_unlock(&chip->mutex);\r\nreturn changed;\r\n}\r\nstatic int dg_control_filter(struct snd_kcontrol_new *template)\r\n{\r\nif (!strncmp(template->name, "Master Playback ", 16))\r\nreturn 1;\r\nreturn 0;\r\n}\r\nstatic int dg_mixer_init(struct oxygen *chip)\r\n{\r\nunsigned int i;\r\nint err;\r\noutput_select_apply(chip);\r\ninput_source_apply(chip);\r\noxygen_update_dac_routing(chip);\r\nfor (i = 0; i < ARRAY_SIZE(dg_controls); ++i) {\r\nerr = snd_ctl_add(chip->card,\r\nsnd_ctl_new1(&dg_controls[i], chip));\r\nif (err < 0)\r\nreturn err;\r\n}\r\nreturn 0;\r\n}
