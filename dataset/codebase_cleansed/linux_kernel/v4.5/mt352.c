static int mt352_single_write(struct dvb_frontend *fe, u8 reg, u8 val)\r\n{\r\nstruct mt352_state* state = fe->demodulator_priv;\r\nu8 buf[2] = { reg, val };\r\nstruct i2c_msg msg = { .addr = state->config.demod_address, .flags = 0,\r\n.buf = buf, .len = 2 };\r\nint err = i2c_transfer(state->i2c, &msg, 1);\r\nif (err != 1) {\r\nprintk("mt352_write() to reg %x failed (err = %d)!\n", reg, err);\r\nreturn err;\r\n}\r\nreturn 0;\r\n}\r\nstatic int _mt352_write(struct dvb_frontend* fe, const u8 ibuf[], int ilen)\r\n{\r\nint err,i;\r\nfor (i=0; i < ilen-1; i++)\r\nif ((err = mt352_single_write(fe,ibuf[0]+i,ibuf[i+1])))\r\nreturn err;\r\nreturn 0;\r\n}\r\nstatic int mt352_read_register(struct mt352_state* state, u8 reg)\r\n{\r\nint ret;\r\nu8 b0 [] = { reg };\r\nu8 b1 [] = { 0 };\r\nstruct i2c_msg msg [] = { { .addr = state->config.demod_address,\r\n.flags = 0,\r\n.buf = b0, .len = 1 },\r\n{ .addr = state->config.demod_address,\r\n.flags = I2C_M_RD,\r\n.buf = b1, .len = 1 } };\r\nret = i2c_transfer(state->i2c, msg, 2);\r\nif (ret != 2) {\r\nprintk("%s: readreg error (reg=%d, ret==%i)\n",\r\n__func__, reg, ret);\r\nreturn ret;\r\n}\r\nreturn b1[0];\r\n}\r\nstatic int mt352_sleep(struct dvb_frontend* fe)\r\n{\r\nstatic u8 mt352_softdown[] = { CLOCK_CTL, 0x20, 0x08 };\r\n_mt352_write(fe, mt352_softdown, sizeof(mt352_softdown));\r\nreturn 0;\r\n}\r\nstatic void mt352_calc_nominal_rate(struct mt352_state* state,\r\nu32 bandwidth,\r\nunsigned char *buf)\r\n{\r\nu32 adc_clock = 20480;\r\nu32 bw,value;\r\nswitch (bandwidth) {\r\ncase 6000000:\r\nbw = 6;\r\nbreak;\r\ncase 7000000:\r\nbw = 7;\r\nbreak;\r\ncase 8000000:\r\ndefault:\r\nbw = 8;\r\nbreak;\r\n}\r\nif (state->config.adc_clock)\r\nadc_clock = state->config.adc_clock;\r\nvalue = 64 * bw * (1<<16) / (7 * 8);\r\nvalue = value * 1000 / adc_clock;\r\ndprintk("%s: bw %d, adc_clock %d => 0x%x\n",\r\n__func__, bw, adc_clock, value);\r\nbuf[0] = msb(value);\r\nbuf[1] = lsb(value);\r\n}\r\nstatic void mt352_calc_input_freq(struct mt352_state* state,\r\nunsigned char *buf)\r\n{\r\nint adc_clock = 20480;\r\nint if2 = 36167;\r\nint ife,value;\r\nif (state->config.adc_clock)\r\nadc_clock = state->config.adc_clock;\r\nif (state->config.if2)\r\nif2 = state->config.if2;\r\nif (adc_clock >= if2 * 2)\r\nife = if2;\r\nelse {\r\nife = adc_clock - (if2 % adc_clock);\r\nif (ife > adc_clock / 2)\r\nife = adc_clock - ife;\r\n}\r\nvalue = -16374 * ife / adc_clock;\r\ndprintk("%s: if2 %d, ife %d, adc_clock %d => %d / 0x%x\n",\r\n__func__, if2, ife, adc_clock, value, value & 0x3fff);\r\nbuf[0] = msb(value);\r\nbuf[1] = lsb(value);\r\n}\r\nstatic int mt352_set_parameters(struct dvb_frontend *fe)\r\n{\r\nstruct dtv_frontend_properties *op = &fe->dtv_property_cache;\r\nstruct mt352_state* state = fe->demodulator_priv;\r\nunsigned char buf[13];\r\nstatic unsigned char tuner_go[] = { 0x5d, 0x01 };\r\nstatic unsigned char fsm_go[] = { 0x5e, 0x01 };\r\nunsigned int tps = 0;\r\nswitch (op->code_rate_HP) {\r\ncase FEC_2_3:\r\ntps |= (1 << 7);\r\nbreak;\r\ncase FEC_3_4:\r\ntps |= (2 << 7);\r\nbreak;\r\ncase FEC_5_6:\r\ntps |= (3 << 7);\r\nbreak;\r\ncase FEC_7_8:\r\ntps |= (4 << 7);\r\nbreak;\r\ncase FEC_1_2:\r\ncase FEC_AUTO:\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nswitch (op->code_rate_LP) {\r\ncase FEC_2_3:\r\ntps |= (1 << 4);\r\nbreak;\r\ncase FEC_3_4:\r\ntps |= (2 << 4);\r\nbreak;\r\ncase FEC_5_6:\r\ntps |= (3 << 4);\r\nbreak;\r\ncase FEC_7_8:\r\ntps |= (4 << 4);\r\nbreak;\r\ncase FEC_1_2:\r\ncase FEC_AUTO:\r\nbreak;\r\ncase FEC_NONE:\r\nif (op->hierarchy == HIERARCHY_AUTO ||\r\nop->hierarchy == HIERARCHY_NONE)\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nswitch (op->modulation) {\r\ncase QPSK:\r\nbreak;\r\ncase QAM_AUTO:\r\ncase QAM_16:\r\ntps |= (1 << 13);\r\nbreak;\r\ncase QAM_64:\r\ntps |= (2 << 13);\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nswitch (op->transmission_mode) {\r\ncase TRANSMISSION_MODE_2K:\r\ncase TRANSMISSION_MODE_AUTO:\r\nbreak;\r\ncase TRANSMISSION_MODE_8K:\r\ntps |= (1 << 0);\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nswitch (op->guard_interval) {\r\ncase GUARD_INTERVAL_1_32:\r\ncase GUARD_INTERVAL_AUTO:\r\nbreak;\r\ncase GUARD_INTERVAL_1_16:\r\ntps |= (1 << 2);\r\nbreak;\r\ncase GUARD_INTERVAL_1_8:\r\ntps |= (2 << 2);\r\nbreak;\r\ncase GUARD_INTERVAL_1_4:\r\ntps |= (3 << 2);\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nswitch (op->hierarchy) {\r\ncase HIERARCHY_AUTO:\r\ncase HIERARCHY_NONE:\r\nbreak;\r\ncase HIERARCHY_1:\r\ntps |= (1 << 10);\r\nbreak;\r\ncase HIERARCHY_2:\r\ntps |= (2 << 10);\r\nbreak;\r\ncase HIERARCHY_4:\r\ntps |= (3 << 10);\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nbuf[0] = TPS_GIVEN_1;\r\nbuf[1] = msb(tps);\r\nbuf[2] = lsb(tps);\r\nbuf[3] = 0x50;\r\nmt352_calc_nominal_rate(state, op->bandwidth_hz, buf+4);\r\nmt352_calc_input_freq(state, buf+6);\r\nif (state->config.no_tuner) {\r\nif (fe->ops.tuner_ops.set_params) {\r\nfe->ops.tuner_ops.set_params(fe);\r\nif (fe->ops.i2c_gate_ctrl)\r\nfe->ops.i2c_gate_ctrl(fe, 0);\r\n}\r\n_mt352_write(fe, buf, 8);\r\n_mt352_write(fe, fsm_go, 2);\r\n} else {\r\nif (fe->ops.tuner_ops.calc_regs) {\r\nfe->ops.tuner_ops.calc_regs(fe, buf+8, 5);\r\nbuf[8] <<= 1;\r\n_mt352_write(fe, buf, sizeof(buf));\r\n_mt352_write(fe, tuner_go, 2);\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int mt352_get_parameters(struct dvb_frontend* fe)\r\n{\r\nstruct dtv_frontend_properties *op = &fe->dtv_property_cache;\r\nstruct mt352_state* state = fe->demodulator_priv;\r\nu16 tps;\r\nu16 div;\r\nu8 trl;\r\nstatic const u8 tps_fec_to_api[8] =\r\n{\r\nFEC_1_2,\r\nFEC_2_3,\r\nFEC_3_4,\r\nFEC_5_6,\r\nFEC_7_8,\r\nFEC_AUTO,\r\nFEC_AUTO,\r\nFEC_AUTO\r\n};\r\nif ( (mt352_read_register(state,0x00) & 0xC0) != 0xC0 )\r\nreturn -EINVAL;\r\ntps = (mt352_read_register(state, TPS_RECEIVED_1) << 8) | mt352_read_register(state, TPS_RECEIVED_0);\r\ndiv = (mt352_read_register(state, CHAN_START_1) << 8) | mt352_read_register(state, CHAN_START_0);\r\ntrl = mt352_read_register(state, TRL_NOMINAL_RATE_1);\r\nop->code_rate_HP = tps_fec_to_api[(tps >> 7) & 7];\r\nop->code_rate_LP = tps_fec_to_api[(tps >> 4) & 7];\r\nswitch ( (tps >> 13) & 3)\r\n{\r\ncase 0:\r\nop->modulation = QPSK;\r\nbreak;\r\ncase 1:\r\nop->modulation = QAM_16;\r\nbreak;\r\ncase 2:\r\nop->modulation = QAM_64;\r\nbreak;\r\ndefault:\r\nop->modulation = QAM_AUTO;\r\nbreak;\r\n}\r\nop->transmission_mode = (tps & 0x01) ? TRANSMISSION_MODE_8K : TRANSMISSION_MODE_2K;\r\nswitch ( (tps >> 2) & 3)\r\n{\r\ncase 0:\r\nop->guard_interval = GUARD_INTERVAL_1_32;\r\nbreak;\r\ncase 1:\r\nop->guard_interval = GUARD_INTERVAL_1_16;\r\nbreak;\r\ncase 2:\r\nop->guard_interval = GUARD_INTERVAL_1_8;\r\nbreak;\r\ncase 3:\r\nop->guard_interval = GUARD_INTERVAL_1_4;\r\nbreak;\r\ndefault:\r\nop->guard_interval = GUARD_INTERVAL_AUTO;\r\nbreak;\r\n}\r\nswitch ( (tps >> 10) & 7)\r\n{\r\ncase 0:\r\nop->hierarchy = HIERARCHY_NONE;\r\nbreak;\r\ncase 1:\r\nop->hierarchy = HIERARCHY_1;\r\nbreak;\r\ncase 2:\r\nop->hierarchy = HIERARCHY_2;\r\nbreak;\r\ncase 3:\r\nop->hierarchy = HIERARCHY_4;\r\nbreak;\r\ndefault:\r\nop->hierarchy = HIERARCHY_AUTO;\r\nbreak;\r\n}\r\nop->frequency = (500 * (div - IF_FREQUENCYx6)) / 3 * 1000;\r\nif (trl == 0x72)\r\nop->bandwidth_hz = 8000000;\r\nelse if (trl == 0x64)\r\nop->bandwidth_hz = 7000000;\r\nelse\r\nop->bandwidth_hz = 6000000;\r\nif (mt352_read_register(state, STATUS_2) & 0x02)\r\nop->inversion = INVERSION_OFF;\r\nelse\r\nop->inversion = INVERSION_ON;\r\nreturn 0;\r\n}\r\nstatic int mt352_read_status(struct dvb_frontend *fe, enum fe_status *status)\r\n{\r\nstruct mt352_state* state = fe->demodulator_priv;\r\nint s0, s1, s3;\r\nif ((s0 = mt352_read_register(state, STATUS_0)) < 0)\r\nreturn -EREMOTEIO;\r\nif ((s1 = mt352_read_register(state, STATUS_1)) < 0)\r\nreturn -EREMOTEIO;\r\nif ((s3 = mt352_read_register(state, STATUS_3)) < 0)\r\nreturn -EREMOTEIO;\r\n*status = 0;\r\nif (s0 & (1 << 4))\r\n*status |= FE_HAS_CARRIER;\r\nif (s0 & (1 << 1))\r\n*status |= FE_HAS_VITERBI;\r\nif (s0 & (1 << 5))\r\n*status |= FE_HAS_LOCK;\r\nif (s1 & (1 << 1))\r\n*status |= FE_HAS_SYNC;\r\nif (s3 & (1 << 6))\r\n*status |= FE_HAS_SIGNAL;\r\nif ((*status & (FE_HAS_CARRIER | FE_HAS_VITERBI | FE_HAS_SYNC)) !=\r\n(FE_HAS_CARRIER | FE_HAS_VITERBI | FE_HAS_SYNC))\r\n*status &= ~FE_HAS_LOCK;\r\nreturn 0;\r\n}\r\nstatic int mt352_read_ber(struct dvb_frontend* fe, u32* ber)\r\n{\r\nstruct mt352_state* state = fe->demodulator_priv;\r\n*ber = (mt352_read_register (state, RS_ERR_CNT_2) << 16) |\r\n(mt352_read_register (state, RS_ERR_CNT_1) << 8) |\r\n(mt352_read_register (state, RS_ERR_CNT_0));\r\nreturn 0;\r\n}\r\nstatic int mt352_read_signal_strength(struct dvb_frontend* fe, u16* strength)\r\n{\r\nstruct mt352_state* state = fe->demodulator_priv;\r\nu16 signal = ((mt352_read_register(state, AGC_GAIN_1) & 0x0f) << 12) |\r\n(mt352_read_register(state, AGC_GAIN_0) << 4);\r\n*strength = ~signal;\r\nreturn 0;\r\n}\r\nstatic int mt352_read_snr(struct dvb_frontend* fe, u16* snr)\r\n{\r\nstruct mt352_state* state = fe->demodulator_priv;\r\nu8 _snr = mt352_read_register (state, SNR);\r\n*snr = (_snr << 8) | _snr;\r\nreturn 0;\r\n}\r\nstatic int mt352_read_ucblocks(struct dvb_frontend* fe, u32* ucblocks)\r\n{\r\nstruct mt352_state* state = fe->demodulator_priv;\r\n*ucblocks = (mt352_read_register (state, RS_UBC_1) << 8) |\r\n(mt352_read_register (state, RS_UBC_0));\r\nreturn 0;\r\n}\r\nstatic int mt352_get_tune_settings(struct dvb_frontend* fe, struct dvb_frontend_tune_settings* fe_tune_settings)\r\n{\r\nfe_tune_settings->min_delay_ms = 800;\r\nfe_tune_settings->step_size = 0;\r\nfe_tune_settings->max_drift = 0;\r\nreturn 0;\r\n}\r\nstatic int mt352_init(struct dvb_frontend* fe)\r\n{\r\nstruct mt352_state* state = fe->demodulator_priv;\r\nstatic u8 mt352_reset_attach [] = { RESET, 0xC0 };\r\ndprintk("%s: hello\n",__func__);\r\nif ((mt352_read_register(state, CLOCK_CTL) & 0x10) == 0 ||\r\n(mt352_read_register(state, CONFIG) & 0x20) == 0) {\r\n_mt352_write(fe, mt352_reset_attach, sizeof(mt352_reset_attach));\r\nreturn state->config.demod_init(fe);\r\n}\r\nreturn 0;\r\n}\r\nstatic void mt352_release(struct dvb_frontend* fe)\r\n{\r\nstruct mt352_state* state = fe->demodulator_priv;\r\nkfree(state);\r\n}\r\nstruct dvb_frontend* mt352_attach(const struct mt352_config* config,\r\nstruct i2c_adapter* i2c)\r\n{\r\nstruct mt352_state* state = NULL;\r\nstate = kzalloc(sizeof(struct mt352_state), GFP_KERNEL);\r\nif (state == NULL) goto error;\r\nstate->i2c = i2c;\r\nmemcpy(&state->config,config,sizeof(struct mt352_config));\r\nif (mt352_read_register(state, CHIP_ID) != ID_MT352) goto error;\r\nmemcpy(&state->frontend.ops, &mt352_ops, sizeof(struct dvb_frontend_ops));\r\nstate->frontend.demodulator_priv = state;\r\nreturn &state->frontend;\r\nerror:\r\nkfree(state);\r\nreturn NULL;\r\n}
