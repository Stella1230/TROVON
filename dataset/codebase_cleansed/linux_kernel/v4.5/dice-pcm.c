static int dice_rate_constraint(struct snd_pcm_hw_params *params,\r\nstruct snd_pcm_hw_rule *rule)\r\n{\r\nstruct snd_pcm_substream *substream = rule->private;\r\nstruct snd_dice *dice = substream->private_data;\r\nconst struct snd_interval *c =\r\nhw_param_interval_c(params, SNDRV_PCM_HW_PARAM_CHANNELS);\r\nstruct snd_interval *r =\r\nhw_param_interval(params, SNDRV_PCM_HW_PARAM_RATE);\r\nstruct snd_interval rates = {\r\n.min = UINT_MAX, .max = 0, .integer = 1\r\n};\r\nunsigned int i, rate, mode, *pcm_channels;\r\nif (substream->stream == SNDRV_PCM_STREAM_CAPTURE)\r\npcm_channels = dice->tx_channels;\r\nelse\r\npcm_channels = dice->rx_channels;\r\nfor (i = 0; i < ARRAY_SIZE(snd_dice_rates); ++i) {\r\nrate = snd_dice_rates[i];\r\nif (snd_dice_stream_get_rate_mode(dice, rate, &mode) < 0)\r\ncontinue;\r\nif (!snd_interval_test(c, pcm_channels[mode]))\r\ncontinue;\r\nrates.min = min(rates.min, rate);\r\nrates.max = max(rates.max, rate);\r\n}\r\nreturn snd_interval_refine(r, &rates);\r\n}\r\nstatic int dice_channels_constraint(struct snd_pcm_hw_params *params,\r\nstruct snd_pcm_hw_rule *rule)\r\n{\r\nstruct snd_pcm_substream *substream = rule->private;\r\nstruct snd_dice *dice = substream->private_data;\r\nconst struct snd_interval *r =\r\nhw_param_interval_c(params, SNDRV_PCM_HW_PARAM_RATE);\r\nstruct snd_interval *c =\r\nhw_param_interval(params, SNDRV_PCM_HW_PARAM_CHANNELS);\r\nstruct snd_interval channels = {\r\n.min = UINT_MAX, .max = 0, .integer = 1\r\n};\r\nunsigned int i, rate, mode, *pcm_channels;\r\nif (substream->stream == SNDRV_PCM_STREAM_CAPTURE)\r\npcm_channels = dice->tx_channels;\r\nelse\r\npcm_channels = dice->rx_channels;\r\nfor (i = 0; i < ARRAY_SIZE(snd_dice_rates); ++i) {\r\nrate = snd_dice_rates[i];\r\nif (snd_dice_stream_get_rate_mode(dice, rate, &mode) < 0)\r\ncontinue;\r\nif (!snd_interval_test(r, rate))\r\ncontinue;\r\nchannels.min = min(channels.min, pcm_channels[mode]);\r\nchannels.max = max(channels.max, pcm_channels[mode]);\r\n}\r\nreturn snd_interval_refine(c, &channels);\r\n}\r\nstatic void limit_channels_and_rates(struct snd_dice *dice,\r\nstruct snd_pcm_runtime *runtime,\r\nunsigned int *pcm_channels)\r\n{\r\nstruct snd_pcm_hardware *hw = &runtime->hw;\r\nunsigned int i, rate, mode;\r\nhw->channels_min = UINT_MAX;\r\nhw->channels_max = 0;\r\nfor (i = 0; i < ARRAY_SIZE(snd_dice_rates); ++i) {\r\nrate = snd_dice_rates[i];\r\nif (snd_dice_stream_get_rate_mode(dice, rate, &mode) < 0)\r\ncontinue;\r\nhw->rates |= snd_pcm_rate_to_rate_bit(rate);\r\nif (pcm_channels[mode] == 0)\r\ncontinue;\r\nhw->channels_min = min(hw->channels_min, pcm_channels[mode]);\r\nhw->channels_max = max(hw->channels_max, pcm_channels[mode]);\r\n}\r\nsnd_pcm_limit_hw_rates(runtime);\r\n}\r\nstatic void limit_period_and_buffer(struct snd_pcm_hardware *hw)\r\n{\r\nhw->periods_min = 2;\r\nhw->periods_max = UINT_MAX;\r\nhw->period_bytes_min = 4 * hw->channels_max;\r\nhw->period_bytes_max = hw->period_bytes_min * 2048;\r\nhw->buffer_bytes_max = hw->period_bytes_max * hw->periods_min;\r\n}\r\nstatic int init_hw_info(struct snd_dice *dice,\r\nstruct snd_pcm_substream *substream)\r\n{\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nstruct snd_pcm_hardware *hw = &runtime->hw;\r\nstruct amdtp_stream *stream;\r\nunsigned int *pcm_channels;\r\nint err;\r\nhw->info = SNDRV_PCM_INFO_MMAP |\r\nSNDRV_PCM_INFO_MMAP_VALID |\r\nSNDRV_PCM_INFO_BATCH |\r\nSNDRV_PCM_INFO_INTERLEAVED |\r\nSNDRV_PCM_INFO_JOINT_DUPLEX |\r\nSNDRV_PCM_INFO_BLOCK_TRANSFER;\r\nif (substream->stream == SNDRV_PCM_STREAM_CAPTURE) {\r\nhw->formats = AM824_IN_PCM_FORMAT_BITS;\r\nstream = &dice->tx_stream;\r\npcm_channels = dice->tx_channels;\r\n} else {\r\nhw->formats = AM824_OUT_PCM_FORMAT_BITS;\r\nstream = &dice->rx_stream;\r\npcm_channels = dice->rx_channels;\r\n}\r\nlimit_channels_and_rates(dice, runtime, pcm_channels);\r\nlimit_period_and_buffer(hw);\r\nerr = snd_pcm_hw_rule_add(runtime, 0, SNDRV_PCM_HW_PARAM_RATE,\r\ndice_rate_constraint, substream,\r\nSNDRV_PCM_HW_PARAM_CHANNELS, -1);\r\nif (err < 0)\r\ngoto end;\r\nerr = snd_pcm_hw_rule_add(runtime, 0, SNDRV_PCM_HW_PARAM_CHANNELS,\r\ndice_channels_constraint, substream,\r\nSNDRV_PCM_HW_PARAM_RATE, -1);\r\nif (err < 0)\r\ngoto end;\r\nerr = amdtp_am824_add_pcm_hw_constraints(stream, runtime);\r\nend:\r\nreturn err;\r\n}\r\nstatic int pcm_open(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_dice *dice = substream->private_data;\r\nunsigned int source, rate;\r\nbool internal;\r\nint err;\r\nerr = snd_dice_stream_lock_try(dice);\r\nif (err < 0)\r\ngoto end;\r\nerr = init_hw_info(dice, substream);\r\nif (err < 0)\r\ngoto err_locked;\r\nerr = snd_dice_transaction_get_clock_source(dice, &source);\r\nif (err < 0)\r\ngoto err_locked;\r\nswitch (source) {\r\ncase CLOCK_SOURCE_AES1:\r\ncase CLOCK_SOURCE_AES2:\r\ncase CLOCK_SOURCE_AES3:\r\ncase CLOCK_SOURCE_AES4:\r\ncase CLOCK_SOURCE_AES_ANY:\r\ncase CLOCK_SOURCE_ADAT:\r\ncase CLOCK_SOURCE_TDIF:\r\ncase CLOCK_SOURCE_WC:\r\ninternal = false;\r\nbreak;\r\ndefault:\r\ninternal = true;\r\nbreak;\r\n}\r\nif (!internal ||\r\namdtp_stream_pcm_running(&dice->tx_stream) ||\r\namdtp_stream_pcm_running(&dice->rx_stream)) {\r\nerr = snd_dice_transaction_get_rate(dice, &rate);\r\nif (err < 0)\r\ngoto err_locked;\r\nsubstream->runtime->hw.rate_min = rate;\r\nsubstream->runtime->hw.rate_max = rate;\r\n}\r\nsnd_pcm_set_sync(substream);\r\nend:\r\nreturn err;\r\nerr_locked:\r\nsnd_dice_stream_lock_release(dice);\r\nreturn err;\r\n}\r\nstatic int pcm_close(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_dice *dice = substream->private_data;\r\nsnd_dice_stream_lock_release(dice);\r\nreturn 0;\r\n}\r\nstatic int capture_hw_params(struct snd_pcm_substream *substream,\r\nstruct snd_pcm_hw_params *hw_params)\r\n{\r\nstruct snd_dice *dice = substream->private_data;\r\nint err;\r\nerr = snd_pcm_lib_alloc_vmalloc_buffer(substream,\r\nparams_buffer_bytes(hw_params));\r\nif (err < 0)\r\nreturn err;\r\nif (substream->runtime->status->state == SNDRV_PCM_STATE_OPEN) {\r\nmutex_lock(&dice->mutex);\r\ndice->substreams_counter++;\r\nmutex_unlock(&dice->mutex);\r\n}\r\namdtp_am824_set_pcm_format(&dice->tx_stream, params_format(hw_params));\r\nreturn 0;\r\n}\r\nstatic int playback_hw_params(struct snd_pcm_substream *substream,\r\nstruct snd_pcm_hw_params *hw_params)\r\n{\r\nstruct snd_dice *dice = substream->private_data;\r\nint err;\r\nerr = snd_pcm_lib_alloc_vmalloc_buffer(substream,\r\nparams_buffer_bytes(hw_params));\r\nif (err < 0)\r\nreturn err;\r\nif (substream->runtime->status->state == SNDRV_PCM_STATE_OPEN) {\r\nmutex_lock(&dice->mutex);\r\ndice->substreams_counter++;\r\nmutex_unlock(&dice->mutex);\r\n}\r\namdtp_am824_set_pcm_format(&dice->rx_stream, params_format(hw_params));\r\nreturn 0;\r\n}\r\nstatic int capture_hw_free(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_dice *dice = substream->private_data;\r\nmutex_lock(&dice->mutex);\r\nif (substream->runtime->status->state != SNDRV_PCM_STATE_OPEN)\r\ndice->substreams_counter--;\r\nsnd_dice_stream_stop_duplex(dice);\r\nmutex_unlock(&dice->mutex);\r\nreturn snd_pcm_lib_free_vmalloc_buffer(substream);\r\n}\r\nstatic int playback_hw_free(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_dice *dice = substream->private_data;\r\nmutex_lock(&dice->mutex);\r\nif (substream->runtime->status->state != SNDRV_PCM_STATE_OPEN)\r\ndice->substreams_counter--;\r\nsnd_dice_stream_stop_duplex(dice);\r\nmutex_unlock(&dice->mutex);\r\nreturn snd_pcm_lib_free_vmalloc_buffer(substream);\r\n}\r\nstatic int capture_prepare(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_dice *dice = substream->private_data;\r\nint err;\r\nmutex_lock(&dice->mutex);\r\nerr = snd_dice_stream_start_duplex(dice, substream->runtime->rate);\r\nmutex_unlock(&dice->mutex);\r\nif (err >= 0)\r\namdtp_stream_pcm_prepare(&dice->tx_stream);\r\nreturn 0;\r\n}\r\nstatic int playback_prepare(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_dice *dice = substream->private_data;\r\nint err;\r\nmutex_lock(&dice->mutex);\r\nerr = snd_dice_stream_start_duplex(dice, substream->runtime->rate);\r\nmutex_unlock(&dice->mutex);\r\nif (err >= 0)\r\namdtp_stream_pcm_prepare(&dice->rx_stream);\r\nreturn err;\r\n}\r\nstatic int capture_trigger(struct snd_pcm_substream *substream, int cmd)\r\n{\r\nstruct snd_dice *dice = substream->private_data;\r\nswitch (cmd) {\r\ncase SNDRV_PCM_TRIGGER_START:\r\namdtp_stream_pcm_trigger(&dice->tx_stream, substream);\r\nbreak;\r\ncase SNDRV_PCM_TRIGGER_STOP:\r\namdtp_stream_pcm_trigger(&dice->tx_stream, NULL);\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int playback_trigger(struct snd_pcm_substream *substream, int cmd)\r\n{\r\nstruct snd_dice *dice = substream->private_data;\r\nswitch (cmd) {\r\ncase SNDRV_PCM_TRIGGER_START:\r\namdtp_stream_pcm_trigger(&dice->rx_stream, substream);\r\nbreak;\r\ncase SNDRV_PCM_TRIGGER_STOP:\r\namdtp_stream_pcm_trigger(&dice->rx_stream, NULL);\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic snd_pcm_uframes_t capture_pointer(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_dice *dice = substream->private_data;\r\nreturn amdtp_stream_pcm_pointer(&dice->tx_stream);\r\n}\r\nstatic snd_pcm_uframes_t playback_pointer(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_dice *dice = substream->private_data;\r\nreturn amdtp_stream_pcm_pointer(&dice->rx_stream);\r\n}\r\nint snd_dice_create_pcm(struct snd_dice *dice)\r\n{\r\nstatic struct snd_pcm_ops capture_ops = {\r\n.open = pcm_open,\r\n.close = pcm_close,\r\n.ioctl = snd_pcm_lib_ioctl,\r\n.hw_params = capture_hw_params,\r\n.hw_free = capture_hw_free,\r\n.prepare = capture_prepare,\r\n.trigger = capture_trigger,\r\n.pointer = capture_pointer,\r\n.page = snd_pcm_lib_get_vmalloc_page,\r\n.mmap = snd_pcm_lib_mmap_vmalloc,\r\n};\r\nstatic struct snd_pcm_ops playback_ops = {\r\n.open = pcm_open,\r\n.close = pcm_close,\r\n.ioctl = snd_pcm_lib_ioctl,\r\n.hw_params = playback_hw_params,\r\n.hw_free = playback_hw_free,\r\n.prepare = playback_prepare,\r\n.trigger = playback_trigger,\r\n.pointer = playback_pointer,\r\n.page = snd_pcm_lib_get_vmalloc_page,\r\n.mmap = snd_pcm_lib_mmap_vmalloc,\r\n};\r\nstruct snd_pcm *pcm;\r\nunsigned int i, capture, playback;\r\nint err;\r\ncapture = playback = 0;\r\nfor (i = 0; i < 3; i++) {\r\nif (dice->tx_channels[i] > 0)\r\ncapture = 1;\r\nif (dice->rx_channels[i] > 0)\r\nplayback = 1;\r\n}\r\nerr = snd_pcm_new(dice->card, "DICE", 0, playback, capture, &pcm);\r\nif (err < 0)\r\nreturn err;\r\npcm->private_data = dice;\r\nstrcpy(pcm->name, dice->card->shortname);\r\nif (capture > 0)\r\nsnd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_CAPTURE, &capture_ops);\r\nif (playback > 0)\r\nsnd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_PLAYBACK, &playback_ops);\r\nreturn 0;\r\n}
