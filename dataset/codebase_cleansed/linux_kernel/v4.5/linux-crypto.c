static int cfs_crypto_hash_alloc(unsigned char alg_id,\r\nconst struct cfs_crypto_hash_type **type,\r\nstruct hash_desc *desc, unsigned char *key,\r\nunsigned int key_len)\r\n{\r\nint err = 0;\r\n*type = cfs_crypto_hash_type(alg_id);\r\nif (*type == NULL) {\r\nCWARN("Unsupported hash algorithm id = %d, max id is %d\n",\r\nalg_id, CFS_HASH_ALG_MAX);\r\nreturn -EINVAL;\r\n}\r\ndesc->tfm = crypto_alloc_hash((*type)->cht_name, 0, 0);\r\nif (desc->tfm == NULL)\r\nreturn -EINVAL;\r\nif (IS_ERR(desc->tfm)) {\r\nCDEBUG(D_INFO, "Failed to alloc crypto hash %s\n",\r\n(*type)->cht_name);\r\nreturn PTR_ERR(desc->tfm);\r\n}\r\ndesc->flags = 0;\r\nif (key != NULL)\r\nerr = crypto_hash_setkey(desc->tfm, key, key_len);\r\nelse if ((*type)->cht_key != 0)\r\nerr = crypto_hash_setkey(desc->tfm,\r\n(unsigned char *)&((*type)->cht_key),\r\n(*type)->cht_size);\r\nif (err != 0) {\r\ncrypto_free_hash(desc->tfm);\r\nreturn err;\r\n}\r\nCDEBUG(D_INFO, "Using crypto hash: %s (%s) speed %d MB/s\n",\r\n(crypto_hash_tfm(desc->tfm))->__crt_alg->cra_name,\r\n(crypto_hash_tfm(desc->tfm))->__crt_alg->cra_driver_name,\r\ncfs_crypto_hash_speeds[alg_id]);\r\nreturn crypto_hash_init(desc);\r\n}\r\nint cfs_crypto_hash_digest(unsigned char alg_id,\r\nconst void *buf, unsigned int buf_len,\r\nunsigned char *key, unsigned int key_len,\r\nunsigned char *hash, unsigned int *hash_len)\r\n{\r\nstruct scatterlist sl;\r\nstruct hash_desc hdesc;\r\nint err;\r\nconst struct cfs_crypto_hash_type *type;\r\nif (buf == NULL || buf_len == 0 || hash_len == NULL)\r\nreturn -EINVAL;\r\nerr = cfs_crypto_hash_alloc(alg_id, &type, &hdesc, key, key_len);\r\nif (err != 0)\r\nreturn err;\r\nif (hash == NULL || *hash_len < type->cht_size) {\r\n*hash_len = type->cht_size;\r\ncrypto_free_hash(hdesc.tfm);\r\nreturn -ENOSPC;\r\n}\r\nsg_init_one(&sl, buf, buf_len);\r\nhdesc.flags = 0;\r\nerr = crypto_hash_digest(&hdesc, &sl, sl.length, hash);\r\ncrypto_free_hash(hdesc.tfm);\r\nreturn err;\r\n}\r\nstruct cfs_crypto_hash_desc *\r\ncfs_crypto_hash_init(unsigned char alg_id,\r\nunsigned char *key, unsigned int key_len)\r\n{\r\nstruct hash_desc *hdesc;\r\nint err;\r\nconst struct cfs_crypto_hash_type *type;\r\nhdesc = kmalloc(sizeof(*hdesc), 0);\r\nif (hdesc == NULL)\r\nreturn ERR_PTR(-ENOMEM);\r\nerr = cfs_crypto_hash_alloc(alg_id, &type, hdesc, key, key_len);\r\nif (err) {\r\nkfree(hdesc);\r\nreturn ERR_PTR(err);\r\n}\r\nreturn (struct cfs_crypto_hash_desc *)hdesc;\r\n}\r\nint cfs_crypto_hash_update_page(struct cfs_crypto_hash_desc *hdesc,\r\nstruct page *page, unsigned int offset,\r\nunsigned int len)\r\n{\r\nstruct scatterlist sl;\r\nsg_init_table(&sl, 1);\r\nsg_set_page(&sl, page, len, offset & ~CFS_PAGE_MASK);\r\nreturn crypto_hash_update((struct hash_desc *)hdesc, &sl, sl.length);\r\n}\r\nint cfs_crypto_hash_update(struct cfs_crypto_hash_desc *hdesc,\r\nconst void *buf, unsigned int buf_len)\r\n{\r\nstruct scatterlist sl;\r\nsg_init_one(&sl, buf, buf_len);\r\nreturn crypto_hash_update((struct hash_desc *)hdesc, &sl, sl.length);\r\n}\r\nint cfs_crypto_hash_final(struct cfs_crypto_hash_desc *hdesc,\r\nunsigned char *hash, unsigned int *hash_len)\r\n{\r\nint err;\r\nint size = crypto_hash_digestsize(((struct hash_desc *)hdesc)->tfm);\r\nif (hash_len == NULL) {\r\ncrypto_free_hash(((struct hash_desc *)hdesc)->tfm);\r\nkfree(hdesc);\r\nreturn 0;\r\n}\r\nif (hash == NULL || *hash_len < size) {\r\n*hash_len = size;\r\nreturn -ENOSPC;\r\n}\r\nerr = crypto_hash_final((struct hash_desc *) hdesc, hash);\r\nif (err < 0) {\r\nreturn err;\r\n}\r\ncrypto_free_hash(((struct hash_desc *)hdesc)->tfm);\r\nkfree(hdesc);\r\nreturn err;\r\n}\r\nstatic void cfs_crypto_performance_test(unsigned char alg_id,\r\nconst unsigned char *buf,\r\nunsigned int buf_len)\r\n{\r\nunsigned long start, end;\r\nint bcount, err = 0;\r\nint sec = 1;\r\nunsigned char hash[64];\r\nunsigned int hash_len = 64;\r\nfor (start = jiffies, end = start + sec * HZ, bcount = 0;\r\ntime_before(jiffies, end); bcount++) {\r\nerr = cfs_crypto_hash_digest(alg_id, buf, buf_len, NULL, 0,\r\nhash, &hash_len);\r\nif (err)\r\nbreak;\r\n}\r\nend = jiffies;\r\nif (err) {\r\ncfs_crypto_hash_speeds[alg_id] = -1;\r\nCDEBUG(D_INFO, "Crypto hash algorithm %s, err = %d\n",\r\ncfs_crypto_hash_name(alg_id), err);\r\n} else {\r\nunsigned long tmp;\r\ntmp = ((bcount * buf_len / jiffies_to_msecs(end - start)) *\r\n1000) / (1024 * 1024);\r\ncfs_crypto_hash_speeds[alg_id] = (int)tmp;\r\n}\r\nCDEBUG(D_INFO, "Crypto hash algorithm %s speed = %d MB/s\n",\r\ncfs_crypto_hash_name(alg_id), cfs_crypto_hash_speeds[alg_id]);\r\n}\r\nint cfs_crypto_hash_speed(unsigned char hash_alg)\r\n{\r\nif (hash_alg < CFS_HASH_ALG_MAX)\r\nreturn cfs_crypto_hash_speeds[hash_alg];\r\nelse\r\nreturn -1;\r\n}\r\nstatic int cfs_crypto_test_hashes(void)\r\n{\r\nunsigned char i;\r\nunsigned char *data;\r\nunsigned int j;\r\nunsigned int data_len = 1 * 128 * 1024;\r\ndata = kmalloc(data_len, 0);\r\nif (data == NULL) {\r\nCERROR("Failed to allocate mem\n");\r\nreturn -ENOMEM;\r\n}\r\nfor (j = 0; j < data_len; j++)\r\ndata[j] = j & 0xff;\r\nfor (i = 0; i < CFS_HASH_ALG_MAX; i++)\r\ncfs_crypto_performance_test(i, data, data_len);\r\nkfree(data);\r\nreturn 0;\r\n}\r\nint cfs_crypto_register(void)\r\n{\r\nrequest_module("crc32c");\r\nadler32 = cfs_crypto_adler32_register();\r\ncfs_crypto_test_hashes();\r\nreturn 0;\r\n}\r\nvoid cfs_crypto_unregister(void)\r\n{\r\nif (adler32 == 0)\r\ncfs_crypto_adler32_unregister();\r\nreturn;\r\n}
