static inline void atl_write(struct dra7_atl_clock_info *cinfo, u32 reg,\r\nu32 val)\r\n{\r\n__raw_writel(val, cinfo->iobase + reg);\r\n}\r\nstatic inline int atl_read(struct dra7_atl_clock_info *cinfo, u32 reg)\r\n{\r\nreturn __raw_readl(cinfo->iobase + reg);\r\n}\r\nstatic int atl_clk_enable(struct clk_hw *hw)\r\n{\r\nstruct dra7_atl_desc *cdesc = to_atl_desc(hw);\r\nif (!cdesc->probed)\r\ngoto out;\r\nif (unlikely(!cdesc->valid))\r\ndev_warn(cdesc->cinfo->dev, "atl%d has not been configured\n",\r\ncdesc->id);\r\npm_runtime_get_sync(cdesc->cinfo->dev);\r\natl_write(cdesc->cinfo, DRA7_ATL_ATLCR_REG(cdesc->id),\r\ncdesc->divider - 1);\r\natl_write(cdesc->cinfo, DRA7_ATL_SWEN_REG(cdesc->id), DRA7_ATL_SWEN);\r\nout:\r\ncdesc->enabled = true;\r\nreturn 0;\r\n}\r\nstatic void atl_clk_disable(struct clk_hw *hw)\r\n{\r\nstruct dra7_atl_desc *cdesc = to_atl_desc(hw);\r\nif (!cdesc->probed)\r\ngoto out;\r\natl_write(cdesc->cinfo, DRA7_ATL_SWEN_REG(cdesc->id), 0);\r\npm_runtime_put_sync(cdesc->cinfo->dev);\r\nout:\r\ncdesc->enabled = false;\r\n}\r\nstatic int atl_clk_is_enabled(struct clk_hw *hw)\r\n{\r\nstruct dra7_atl_desc *cdesc = to_atl_desc(hw);\r\nreturn cdesc->enabled;\r\n}\r\nstatic unsigned long atl_clk_recalc_rate(struct clk_hw *hw,\r\nunsigned long parent_rate)\r\n{\r\nstruct dra7_atl_desc *cdesc = to_atl_desc(hw);\r\nreturn parent_rate / cdesc->divider;\r\n}\r\nstatic long atl_clk_round_rate(struct clk_hw *hw, unsigned long rate,\r\nunsigned long *parent_rate)\r\n{\r\nunsigned divider;\r\ndivider = (*parent_rate + rate / 2) / rate;\r\nif (divider > DRA7_ATL_DIVIDER_MASK + 1)\r\ndivider = DRA7_ATL_DIVIDER_MASK + 1;\r\nreturn *parent_rate / divider;\r\n}\r\nstatic int atl_clk_set_rate(struct clk_hw *hw, unsigned long rate,\r\nunsigned long parent_rate)\r\n{\r\nstruct dra7_atl_desc *cdesc;\r\nu32 divider;\r\nif (!hw || !rate)\r\nreturn -EINVAL;\r\ncdesc = to_atl_desc(hw);\r\ndivider = ((parent_rate + rate / 2) / rate) - 1;\r\nif (divider > DRA7_ATL_DIVIDER_MASK)\r\ndivider = DRA7_ATL_DIVIDER_MASK;\r\ncdesc->divider = divider + 1;\r\nreturn 0;\r\n}\r\nstatic void __init of_dra7_atl_clock_setup(struct device_node *node)\r\n{\r\nstruct dra7_atl_desc *clk_hw = NULL;\r\nstruct clk_init_data init = { NULL };\r\nconst char **parent_names = NULL;\r\nstruct clk *clk;\r\nclk_hw = kzalloc(sizeof(*clk_hw), GFP_KERNEL);\r\nif (!clk_hw) {\r\npr_err("%s: could not allocate dra7_atl_desc\n", __func__);\r\nreturn;\r\n}\r\nclk_hw->hw.init = &init;\r\nclk_hw->divider = 1;\r\ninit.name = node->name;\r\ninit.ops = &atl_clk_ops;\r\ninit.flags = CLK_IGNORE_UNUSED;\r\ninit.num_parents = of_clk_get_parent_count(node);\r\nif (init.num_parents != 1) {\r\npr_err("%s: atl clock %s must have 1 parent\n", __func__,\r\nnode->name);\r\ngoto cleanup;\r\n}\r\nparent_names = kzalloc(sizeof(char *), GFP_KERNEL);\r\nif (!parent_names)\r\ngoto cleanup;\r\nparent_names[0] = of_clk_get_parent_name(node, 0);\r\ninit.parent_names = parent_names;\r\nclk = clk_register(NULL, &clk_hw->hw);\r\nif (!IS_ERR(clk)) {\r\nof_clk_add_provider(node, of_clk_src_simple_get, clk);\r\nkfree(parent_names);\r\nreturn;\r\n}\r\ncleanup:\r\nkfree(parent_names);\r\nkfree(clk_hw);\r\n}\r\nstatic int of_dra7_atl_clk_probe(struct platform_device *pdev)\r\n{\r\nstruct device_node *node = pdev->dev.of_node;\r\nstruct dra7_atl_clock_info *cinfo;\r\nint i;\r\nint ret = 0;\r\nif (!node)\r\nreturn -ENODEV;\r\ncinfo = devm_kzalloc(&pdev->dev, sizeof(*cinfo), GFP_KERNEL);\r\nif (!cinfo)\r\nreturn -ENOMEM;\r\ncinfo->iobase = of_iomap(node, 0);\r\ncinfo->dev = &pdev->dev;\r\npm_runtime_enable(cinfo->dev);\r\npm_runtime_irq_safe(cinfo->dev);\r\npm_runtime_get_sync(cinfo->dev);\r\natl_write(cinfo, DRA7_ATL_PCLKMUX_REG(0), DRA7_ATL_PCLKMUX);\r\nfor (i = 0; i < DRA7_ATL_INSTANCES; i++) {\r\nstruct device_node *cfg_node;\r\nchar prop[5];\r\nstruct dra7_atl_desc *cdesc;\r\nstruct of_phandle_args clkspec;\r\nstruct clk *clk;\r\nint rc;\r\nrc = of_parse_phandle_with_args(node, "ti,provided-clocks",\r\nNULL, i, &clkspec);\r\nif (rc) {\r\npr_err("%s: failed to lookup atl clock %d\n", __func__,\r\ni);\r\nreturn -EINVAL;\r\n}\r\nclk = of_clk_get_from_provider(&clkspec);\r\nif (IS_ERR(clk)) {\r\npr_err("%s: failed to get atl clock %d from provider\n",\r\n__func__, i);\r\nreturn PTR_ERR(clk);\r\n}\r\ncdesc = to_atl_desc(__clk_get_hw(clk));\r\ncdesc->cinfo = cinfo;\r\ncdesc->id = i;\r\nsnprintf(prop, sizeof(prop), "atl%u", i);\r\ncfg_node = of_find_node_by_name(node, prop);\r\nif (cfg_node) {\r\nret = of_property_read_u32(cfg_node, "bws",\r\n&cdesc->bws);\r\nret |= of_property_read_u32(cfg_node, "aws",\r\n&cdesc->aws);\r\nif (!ret) {\r\ncdesc->valid = true;\r\natl_write(cinfo, DRA7_ATL_BWSMUX_REG(i),\r\ncdesc->bws);\r\natl_write(cinfo, DRA7_ATL_AWSMUX_REG(i),\r\ncdesc->aws);\r\n}\r\n}\r\ncdesc->probed = true;\r\nif (cdesc->enabled)\r\natl_clk_enable(__clk_get_hw(clk));\r\n}\r\npm_runtime_put_sync(cinfo->dev);\r\nreturn ret;\r\n}\r\nstatic int of_dra7_atl_clk_remove(struct platform_device *pdev)\r\n{\r\npm_runtime_disable(&pdev->dev);\r\nreturn 0;\r\n}
