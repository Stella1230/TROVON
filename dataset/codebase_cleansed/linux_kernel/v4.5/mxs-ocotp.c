static int mxs_ocotp_wait(struct mxs_ocotp *otp)\r\n{\r\nint timeout = OCOTP_TIMEOUT;\r\nunsigned int status = 0;\r\nwhile (timeout--) {\r\nstatus = readl(otp->base);\r\nif (!(status & (BM_OCOTP_CTRL_BUSY | BM_OCOTP_CTRL_ERROR)))\r\nbreak;\r\ncpu_relax();\r\n}\r\nif (status & BM_OCOTP_CTRL_BUSY)\r\nreturn -EBUSY;\r\nelse if (status & BM_OCOTP_CTRL_ERROR)\r\nreturn -EIO;\r\nreturn 0;\r\n}\r\nstatic int mxs_ocotp_read(void *context, const void *reg, size_t reg_size,\r\nvoid *val, size_t val_size)\r\n{\r\nstruct mxs_ocotp *otp = context;\r\nunsigned int offset = *(u32 *)reg;\r\nu32 *buf = val;\r\nint ret;\r\nret = clk_enable(otp->clk);\r\nif (ret)\r\nreturn ret;\r\nwritel(BM_OCOTP_CTRL_ERROR, otp->base + STMP_OFFSET_REG_CLR);\r\nret = mxs_ocotp_wait(otp);\r\nif (ret)\r\ngoto disable_clk;\r\nwritel(BM_OCOTP_CTRL_RD_BANK_OPEN, otp->base + STMP_OFFSET_REG_SET);\r\nudelay(1);\r\nret = mxs_ocotp_wait(otp);\r\nif (ret)\r\ngoto close_banks;\r\nwhile (val_size) {\r\nif ((offset < OCOTP_DATA_OFFSET) || (offset % 16)) {\r\n*buf = 0;\r\n} else {\r\n*buf = readl(otp->base + offset);\r\n}\r\nbuf++;\r\nval_size--;\r\noffset += reg_size;\r\n}\r\nclose_banks:\r\nwritel(BM_OCOTP_CTRL_RD_BANK_OPEN, otp->base + STMP_OFFSET_REG_CLR);\r\ndisable_clk:\r\nclk_disable(otp->clk);\r\nreturn ret;\r\n}\r\nstatic int mxs_ocotp_write(void *context, const void *data, size_t count)\r\n{\r\nreturn 0;\r\n}\r\nstatic bool mxs_ocotp_writeable_reg(struct device *dev, unsigned int reg)\r\n{\r\nreturn false;\r\n}\r\nstatic int mxs_ocotp_probe(struct platform_device *pdev)\r\n{\r\nstruct device *dev = &pdev->dev;\r\nstruct mxs_ocotp *otp;\r\nstruct resource *res;\r\nconst struct of_device_id *match;\r\nstruct regmap *regmap;\r\nconst struct regmap_access_table *access;\r\nint ret;\r\nmatch = of_match_device(dev->driver->of_match_table, dev);\r\nif (!match || !match->data)\r\nreturn -EINVAL;\r\notp = devm_kzalloc(dev, sizeof(*otp), GFP_KERNEL);\r\nif (!otp)\r\nreturn -ENOMEM;\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\notp->base = devm_ioremap_resource(dev, res);\r\nif (IS_ERR(otp->base))\r\nreturn PTR_ERR(otp->base);\r\notp->clk = devm_clk_get(&pdev->dev, NULL);\r\nif (IS_ERR(otp->clk))\r\nreturn PTR_ERR(otp->clk);\r\nret = clk_prepare(otp->clk);\r\nif (ret < 0) {\r\ndev_err(dev, "failed to prepare clk: %d\n", ret);\r\nreturn ret;\r\n}\r\naccess = match->data;\r\nmxs_ocotp_config.rd_table = access;\r\nmxs_ocotp_config.max_register = access->yes_ranges[0].range_max;\r\nregmap = devm_regmap_init(dev, &mxs_ocotp_bus, otp, &mxs_ocotp_config);\r\nif (IS_ERR(regmap)) {\r\ndev_err(dev, "regmap init failed\n");\r\nret = PTR_ERR(regmap);\r\ngoto err_clk;\r\n}\r\nocotp_config.dev = dev;\r\notp->nvmem = nvmem_register(&ocotp_config);\r\nif (IS_ERR(otp->nvmem)) {\r\nret = PTR_ERR(otp->nvmem);\r\ngoto err_clk;\r\n}\r\nplatform_set_drvdata(pdev, otp);\r\nreturn 0;\r\nerr_clk:\r\nclk_unprepare(otp->clk);\r\nreturn ret;\r\n}\r\nstatic int mxs_ocotp_remove(struct platform_device *pdev)\r\n{\r\nstruct mxs_ocotp *otp = platform_get_drvdata(pdev);\r\nclk_unprepare(otp->clk);\r\nreturn nvmem_unregister(otp->nvmem);\r\n}
