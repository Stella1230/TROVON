static inline u32\r\nks8695_readreg(struct ks8695_priv *ksp, int reg)\r\n{\r\nreturn readl(ksp->io_regs + reg);\r\n}\r\nstatic inline void\r\nks8695_writereg(struct ks8695_priv *ksp, int reg, u32 value)\r\n{\r\nwritel(value, ksp->io_regs + reg);\r\n}\r\nstatic const char *\r\nks8695_port_type(struct ks8695_priv *ksp)\r\n{\r\nswitch (ksp->dtype) {\r\ncase KS8695_DTYPE_LAN:\r\nreturn "LAN";\r\ncase KS8695_DTYPE_WAN:\r\nreturn "WAN";\r\ncase KS8695_DTYPE_HPNA:\r\nreturn "HPNA";\r\n}\r\nreturn "UNKNOWN";\r\n}\r\nstatic void\r\nks8695_update_mac(struct ks8695_priv *ksp)\r\n{\r\nstruct net_device *ndev = ksp->ndev;\r\nu32 machigh, maclow;\r\nmaclow = ((ndev->dev_addr[2] << 24) | (ndev->dev_addr[3] << 16) |\r\n(ndev->dev_addr[4] << 8) | (ndev->dev_addr[5] << 0));\r\nmachigh = ((ndev->dev_addr[0] << 8) | (ndev->dev_addr[1] << 0));\r\nks8695_writereg(ksp, KS8695_MAL, maclow);\r\nks8695_writereg(ksp, KS8695_MAH, machigh);\r\n}\r\nstatic void\r\nks8695_refill_rxbuffers(struct ks8695_priv *ksp)\r\n{\r\nint buff_n;\r\nfor (buff_n = 0; buff_n < MAX_RX_DESC; ++buff_n) {\r\nif (!ksp->rx_buffers[buff_n].skb) {\r\nstruct sk_buff *skb =\r\nnetdev_alloc_skb(ksp->ndev, MAX_RXBUF_SIZE);\r\ndma_addr_t mapping;\r\nksp->rx_buffers[buff_n].skb = skb;\r\nif (skb == NULL) {\r\nbreak;\r\n}\r\nmapping = dma_map_single(ksp->dev, skb->data,\r\nMAX_RXBUF_SIZE,\r\nDMA_FROM_DEVICE);\r\nif (unlikely(dma_mapping_error(ksp->dev, mapping))) {\r\ndev_kfree_skb_irq(skb);\r\nksp->rx_buffers[buff_n].skb = NULL;\r\nbreak;\r\n}\r\nksp->rx_buffers[buff_n].dma_ptr = mapping;\r\nksp->rx_buffers[buff_n].length = MAX_RXBUF_SIZE;\r\nksp->rx_ring[buff_n].data_ptr = cpu_to_le32(mapping);\r\nksp->rx_ring[buff_n].length =\r\ncpu_to_le32(MAX_RXBUF_SIZE);\r\nwmb();\r\nksp->rx_ring[buff_n].status = cpu_to_le32(RDES_OWN);\r\n}\r\n}\r\n}\r\nstatic void\r\nks8695_init_partial_multicast(struct ks8695_priv *ksp,\r\nstruct net_device *ndev)\r\n{\r\nu32 low, high;\r\nint i;\r\nstruct netdev_hw_addr *ha;\r\ni = 0;\r\nnetdev_for_each_mc_addr(ha, ndev) {\r\nBUG_ON(i == KS8695_NR_ADDRESSES);\r\nlow = (ha->addr[2] << 24) | (ha->addr[3] << 16) |\r\n(ha->addr[4] << 8) | (ha->addr[5]);\r\nhigh = (ha->addr[0] << 8) | (ha->addr[1]);\r\nks8695_writereg(ksp, KS8695_AAL_(i), low);\r\nks8695_writereg(ksp, KS8695_AAH_(i), AAH_E | high);\r\ni++;\r\n}\r\nfor (; i < KS8695_NR_ADDRESSES; i++) {\r\nks8695_writereg(ksp, KS8695_AAL_(i), 0);\r\nks8695_writereg(ksp, KS8695_AAH_(i), 0);\r\n}\r\n}\r\nstatic irqreturn_t\r\nks8695_tx_irq(int irq, void *dev_id)\r\n{\r\nstruct net_device *ndev = (struct net_device *)dev_id;\r\nstruct ks8695_priv *ksp = netdev_priv(ndev);\r\nint buff_n;\r\nfor (buff_n = 0; buff_n < MAX_TX_DESC; ++buff_n) {\r\nif (ksp->tx_buffers[buff_n].skb &&\r\n!(ksp->tx_ring[buff_n].owner & cpu_to_le32(TDES_OWN))) {\r\nrmb();\r\nndev->stats.tx_packets++;\r\nndev->stats.tx_bytes += ksp->tx_buffers[buff_n].length;\r\nksp->tx_ring[buff_n].data_ptr = 0;\r\ndma_unmap_single(ksp->dev,\r\nksp->tx_buffers[buff_n].dma_ptr,\r\nksp->tx_buffers[buff_n].length,\r\nDMA_TO_DEVICE);\r\ndev_kfree_skb_irq(ksp->tx_buffers[buff_n].skb);\r\nksp->tx_buffers[buff_n].skb = NULL;\r\nksp->tx_ring_used--;\r\n}\r\n}\r\nnetif_wake_queue(ndev);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic inline u32 ks8695_get_rx_enable_bit(struct ks8695_priv *ksp)\r\n{\r\nreturn ksp->rx_irq;\r\n}\r\nstatic irqreturn_t\r\nks8695_rx_irq(int irq, void *dev_id)\r\n{\r\nstruct net_device *ndev = (struct net_device *)dev_id;\r\nstruct ks8695_priv *ksp = netdev_priv(ndev);\r\nspin_lock(&ksp->rx_lock);\r\nif (napi_schedule_prep(&ksp->napi)) {\r\nunsigned long status = readl(KS8695_IRQ_VA + KS8695_INTEN);\r\nunsigned long mask_bit = 1 << ks8695_get_rx_enable_bit(ksp);\r\nstatus &= ~mask_bit;\r\nwritel(status , KS8695_IRQ_VA + KS8695_INTEN);\r\n__napi_schedule(&ksp->napi);\r\n}\r\nspin_unlock(&ksp->rx_lock);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int ks8695_rx(struct ks8695_priv *ksp, int budget)\r\n{\r\nstruct net_device *ndev = ksp->ndev;\r\nstruct sk_buff *skb;\r\nint buff_n;\r\nu32 flags;\r\nint pktlen;\r\nint received = 0;\r\nbuff_n = ksp->next_rx_desc_read;\r\nwhile (received < budget\r\n&& ksp->rx_buffers[buff_n].skb\r\n&& (!(ksp->rx_ring[buff_n].status &\r\ncpu_to_le32(RDES_OWN)))) {\r\nrmb();\r\nflags = le32_to_cpu(ksp->rx_ring[buff_n].status);\r\nif ((flags & (RDES_FS | RDES_LS)) !=\r\n(RDES_FS | RDES_LS)) {\r\ngoto rx_failure;\r\n}\r\nif (flags & (RDES_ES | RDES_RE)) {\r\nndev->stats.rx_errors++;\r\nif (flags & RDES_TL)\r\nndev->stats.rx_length_errors++;\r\nif (flags & RDES_RF)\r\nndev->stats.rx_length_errors++;\r\nif (flags & RDES_CE)\r\nndev->stats.rx_crc_errors++;\r\nif (flags & RDES_RE)\r\nndev->stats.rx_missed_errors++;\r\ngoto rx_failure;\r\n}\r\npktlen = flags & RDES_FLEN;\r\npktlen -= 4;\r\nskb = ksp->rx_buffers[buff_n].skb;\r\nksp->rx_buffers[buff_n].skb = NULL;\r\nksp->rx_ring[buff_n].data_ptr = 0;\r\ndma_unmap_single(ksp->dev,\r\nksp->rx_buffers[buff_n].dma_ptr,\r\nksp->rx_buffers[buff_n].length,\r\nDMA_FROM_DEVICE);\r\nskb_put(skb, pktlen);\r\nskb->protocol = eth_type_trans(skb, ndev);\r\nnetif_receive_skb(skb);\r\nndev->stats.rx_packets++;\r\nndev->stats.rx_bytes += pktlen;\r\ngoto rx_finished;\r\nrx_failure:\r\nksp->rx_ring[buff_n].status = cpu_to_le32(RDES_OWN);\r\nrx_finished:\r\nreceived++;\r\nbuff_n = (buff_n + 1) & MAX_RX_DESC_MASK;\r\n}\r\nksp->next_rx_desc_read = buff_n;\r\nks8695_refill_rxbuffers(ksp);\r\nks8695_writereg(ksp, KS8695_DRSC, 0);\r\nreturn received;\r\n}\r\nstatic int ks8695_poll(struct napi_struct *napi, int budget)\r\n{\r\nstruct ks8695_priv *ksp = container_of(napi, struct ks8695_priv, napi);\r\nunsigned long work_done;\r\nunsigned long isr = readl(KS8695_IRQ_VA + KS8695_INTEN);\r\nunsigned long mask_bit = 1 << ks8695_get_rx_enable_bit(ksp);\r\nwork_done = ks8695_rx(ksp, budget);\r\nif (work_done < budget) {\r\nunsigned long flags;\r\nspin_lock_irqsave(&ksp->rx_lock, flags);\r\n__napi_complete(napi);\r\nwritel(isr | mask_bit, KS8695_IRQ_VA + KS8695_INTEN);\r\nspin_unlock_irqrestore(&ksp->rx_lock, flags);\r\n}\r\nreturn work_done;\r\n}\r\nstatic irqreturn_t\r\nks8695_link_irq(int irq, void *dev_id)\r\n{\r\nstruct net_device *ndev = (struct net_device *)dev_id;\r\nstruct ks8695_priv *ksp = netdev_priv(ndev);\r\nu32 ctrl;\r\nctrl = readl(ksp->phyiface_regs + KS8695_WMC);\r\nif (ctrl & WMC_WLS) {\r\nnetif_carrier_on(ndev);\r\nif (netif_msg_link(ksp))\r\ndev_info(ksp->dev,\r\n"%s: Link is now up (10%sMbps/%s-duplex)\n",\r\nndev->name,\r\n(ctrl & WMC_WSS) ? "0" : "",\r\n(ctrl & WMC_WDS) ? "Full" : "Half");\r\n} else {\r\nnetif_carrier_off(ndev);\r\nif (netif_msg_link(ksp))\r\ndev_info(ksp->dev, "%s: Link is now down.\n",\r\nndev->name);\r\n}\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void\r\nks8695_reset(struct ks8695_priv *ksp)\r\n{\r\nint reset_timeout = watchdog;\r\nks8695_writereg(ksp, KS8695_DTXC, DTXC_TRST);\r\nwhile (reset_timeout--) {\r\nif (!(ks8695_readreg(ksp, KS8695_DTXC) & DTXC_TRST))\r\nbreak;\r\nmsleep(1);\r\n}\r\nif (reset_timeout < 0) {\r\ndev_crit(ksp->dev,\r\n"Timeout waiting for DMA engines to reset\n");\r\n}\r\nmsleep(10);\r\nks8695_writereg(ksp, KS8695_DRXC, DRXC_RU | DRXC_RB);\r\nks8695_writereg(ksp, KS8695_DTXC, DTXC_TEP | DTXC_TAC);\r\n}\r\nstatic void\r\nks8695_shutdown(struct ks8695_priv *ksp)\r\n{\r\nu32 ctrl;\r\nint buff_n;\r\nctrl = ks8695_readreg(ksp, KS8695_DTXC);\r\nks8695_writereg(ksp, KS8695_DTXC, ctrl & ~DTXC_TE);\r\nctrl = ks8695_readreg(ksp, KS8695_DRXC);\r\nks8695_writereg(ksp, KS8695_DRXC, ctrl & ~DRXC_RE);\r\nfree_irq(ksp->rx_irq, ksp->ndev);\r\nfree_irq(ksp->tx_irq, ksp->ndev);\r\nif (ksp->link_irq != -1)\r\nfree_irq(ksp->link_irq, ksp->ndev);\r\nfor (buff_n = 0; buff_n < MAX_TX_DESC; ++buff_n) {\r\nif (ksp->tx_buffers[buff_n].skb) {\r\nksp->tx_ring[buff_n].owner = 0;\r\nksp->tx_ring[buff_n].status = 0;\r\nksp->tx_ring[buff_n].data_ptr = 0;\r\ndma_unmap_single(ksp->dev,\r\nksp->tx_buffers[buff_n].dma_ptr,\r\nksp->tx_buffers[buff_n].length,\r\nDMA_TO_DEVICE);\r\ndev_kfree_skb_irq(ksp->tx_buffers[buff_n].skb);\r\nksp->tx_buffers[buff_n].skb = NULL;\r\n}\r\n}\r\nfor (buff_n = 0; buff_n < MAX_RX_DESC; ++buff_n) {\r\nif (ksp->rx_buffers[buff_n].skb) {\r\nksp->rx_ring[buff_n].status = 0;\r\nksp->rx_ring[buff_n].data_ptr = 0;\r\ndma_unmap_single(ksp->dev,\r\nksp->rx_buffers[buff_n].dma_ptr,\r\nksp->rx_buffers[buff_n].length,\r\nDMA_FROM_DEVICE);\r\ndev_kfree_skb_irq(ksp->rx_buffers[buff_n].skb);\r\nksp->rx_buffers[buff_n].skb = NULL;\r\n}\r\n}\r\n}\r\nstatic int\r\nks8695_setup_irq(int irq, const char *irq_name,\r\nirq_handler_t handler, struct net_device *ndev)\r\n{\r\nint ret;\r\nret = request_irq(irq, handler, IRQF_SHARED, irq_name, ndev);\r\nif (ret) {\r\ndev_err(&ndev->dev, "failure to request IRQ %d\n", irq);\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic int\r\nks8695_init_net(struct ks8695_priv *ksp)\r\n{\r\nint ret;\r\nu32 ctrl;\r\nks8695_refill_rxbuffers(ksp);\r\nks8695_writereg(ksp, KS8695_RDLB, (u32) ksp->rx_ring_dma);\r\nks8695_writereg(ksp, KS8695_TDLB, (u32) ksp->tx_ring_dma);\r\nret = ks8695_setup_irq(ksp->rx_irq, ksp->rx_irq_name,\r\nks8695_rx_irq, ksp->ndev);\r\nif (ret)\r\nreturn ret;\r\nret = ks8695_setup_irq(ksp->tx_irq, ksp->tx_irq_name,\r\nks8695_tx_irq, ksp->ndev);\r\nif (ret)\r\nreturn ret;\r\nif (ksp->link_irq != -1) {\r\nret = ks8695_setup_irq(ksp->link_irq, ksp->link_irq_name,\r\nks8695_link_irq, ksp->ndev);\r\nif (ret)\r\nreturn ret;\r\n}\r\nksp->next_rx_desc_read = 0;\r\nksp->tx_ring_next_slot = 0;\r\nksp->tx_ring_used = 0;\r\nctrl = ks8695_readreg(ksp, KS8695_DTXC);\r\nks8695_writereg(ksp, KS8695_DTXC, ctrl | DTXC_TE);\r\nctrl = ks8695_readreg(ksp, KS8695_DRXC);\r\nks8695_writereg(ksp, KS8695_DRXC, ctrl | DRXC_RE);\r\nks8695_writereg(ksp, KS8695_DRSC, 0);\r\nreturn 0;\r\n}\r\nstatic void\r\nks8695_release_device(struct ks8695_priv *ksp)\r\n{\r\niounmap(ksp->io_regs);\r\nif (ksp->phyiface_regs)\r\niounmap(ksp->phyiface_regs);\r\nrelease_resource(ksp->regs_req);\r\nkfree(ksp->regs_req);\r\nif (ksp->phyiface_req) {\r\nrelease_resource(ksp->phyiface_req);\r\nkfree(ksp->phyiface_req);\r\n}\r\ndma_free_coherent(ksp->dev, RING_DMA_SIZE,\r\nksp->ring_base, ksp->ring_base_dma);\r\n}\r\nstatic u32\r\nks8695_get_msglevel(struct net_device *ndev)\r\n{\r\nstruct ks8695_priv *ksp = netdev_priv(ndev);\r\nreturn ksp->msg_enable;\r\n}\r\nstatic void\r\nks8695_set_msglevel(struct net_device *ndev, u32 value)\r\n{\r\nstruct ks8695_priv *ksp = netdev_priv(ndev);\r\nksp->msg_enable = value;\r\n}\r\nstatic int\r\nks8695_wan_get_settings(struct net_device *ndev, struct ethtool_cmd *cmd)\r\n{\r\nstruct ks8695_priv *ksp = netdev_priv(ndev);\r\nu32 ctrl;\r\ncmd->supported = (SUPPORTED_10baseT_Half | SUPPORTED_10baseT_Full |\r\nSUPPORTED_100baseT_Half | SUPPORTED_100baseT_Full |\r\nSUPPORTED_TP | SUPPORTED_MII);\r\ncmd->transceiver = XCVR_INTERNAL;\r\ncmd->advertising = ADVERTISED_TP | ADVERTISED_MII;\r\ncmd->port = PORT_MII;\r\ncmd->supported |= (SUPPORTED_Autoneg | SUPPORTED_Pause);\r\ncmd->phy_address = 0;\r\nctrl = readl(ksp->phyiface_regs + KS8695_WMC);\r\nif ((ctrl & WMC_WAND) == 0) {\r\ncmd->advertising |= ADVERTISED_Autoneg;\r\nif (ctrl & WMC_WANA100F)\r\ncmd->advertising |= ADVERTISED_100baseT_Full;\r\nif (ctrl & WMC_WANA100H)\r\ncmd->advertising |= ADVERTISED_100baseT_Half;\r\nif (ctrl & WMC_WANA10F)\r\ncmd->advertising |= ADVERTISED_10baseT_Full;\r\nif (ctrl & WMC_WANA10H)\r\ncmd->advertising |= ADVERTISED_10baseT_Half;\r\nif (ctrl & WMC_WANAP)\r\ncmd->advertising |= ADVERTISED_Pause;\r\ncmd->autoneg = AUTONEG_ENABLE;\r\nethtool_cmd_speed_set(cmd,\r\n(ctrl & WMC_WSS) ? SPEED_100 : SPEED_10);\r\ncmd->duplex = (ctrl & WMC_WDS) ?\r\nDUPLEX_FULL : DUPLEX_HALF;\r\n} else {\r\ncmd->autoneg = AUTONEG_DISABLE;\r\nethtool_cmd_speed_set(cmd, ((ctrl & WMC_WANF100) ?\r\nSPEED_100 : SPEED_10));\r\ncmd->duplex = (ctrl & WMC_WANFF) ?\r\nDUPLEX_FULL : DUPLEX_HALF;\r\n}\r\nreturn 0;\r\n}\r\nstatic int\r\nks8695_wan_set_settings(struct net_device *ndev, struct ethtool_cmd *cmd)\r\n{\r\nstruct ks8695_priv *ksp = netdev_priv(ndev);\r\nu32 ctrl;\r\nif ((cmd->speed != SPEED_10) && (cmd->speed != SPEED_100))\r\nreturn -EINVAL;\r\nif ((cmd->duplex != DUPLEX_HALF) && (cmd->duplex != DUPLEX_FULL))\r\nreturn -EINVAL;\r\nif (cmd->port != PORT_MII)\r\nreturn -EINVAL;\r\nif (cmd->transceiver != XCVR_INTERNAL)\r\nreturn -EINVAL;\r\nif ((cmd->autoneg != AUTONEG_DISABLE) &&\r\n(cmd->autoneg != AUTONEG_ENABLE))\r\nreturn -EINVAL;\r\nif (cmd->autoneg == AUTONEG_ENABLE) {\r\nif ((cmd->advertising & (ADVERTISED_10baseT_Half |\r\nADVERTISED_10baseT_Full |\r\nADVERTISED_100baseT_Half |\r\nADVERTISED_100baseT_Full)) == 0)\r\nreturn -EINVAL;\r\nctrl = readl(ksp->phyiface_regs + KS8695_WMC);\r\nctrl &= ~(WMC_WAND | WMC_WANA100F | WMC_WANA100H |\r\nWMC_WANA10F | WMC_WANA10H);\r\nif (cmd->advertising & ADVERTISED_100baseT_Full)\r\nctrl |= WMC_WANA100F;\r\nif (cmd->advertising & ADVERTISED_100baseT_Half)\r\nctrl |= WMC_WANA100H;\r\nif (cmd->advertising & ADVERTISED_10baseT_Full)\r\nctrl |= WMC_WANA10F;\r\nif (cmd->advertising & ADVERTISED_10baseT_Half)\r\nctrl |= WMC_WANA10H;\r\nctrl |= WMC_WANR;\r\nwritel(ctrl, ksp->phyiface_regs + KS8695_WMC);\r\n} else {\r\nctrl = readl(ksp->phyiface_regs + KS8695_WMC);\r\nctrl |= WMC_WAND;\r\nctrl &= ~(WMC_WANF100 | WMC_WANFF);\r\nif (cmd->speed == SPEED_100)\r\nctrl |= WMC_WANF100;\r\nif (cmd->duplex == DUPLEX_FULL)\r\nctrl |= WMC_WANFF;\r\nwritel(ctrl, ksp->phyiface_regs + KS8695_WMC);\r\n}\r\nreturn 0;\r\n}\r\nstatic int\r\nks8695_wan_nwayreset(struct net_device *ndev)\r\n{\r\nstruct ks8695_priv *ksp = netdev_priv(ndev);\r\nu32 ctrl;\r\nctrl = readl(ksp->phyiface_regs + KS8695_WMC);\r\nif ((ctrl & WMC_WAND) == 0)\r\nwritel(ctrl | WMC_WANR,\r\nksp->phyiface_regs + KS8695_WMC);\r\nelse\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\nstatic void\r\nks8695_wan_get_pause(struct net_device *ndev, struct ethtool_pauseparam *param)\r\n{\r\nstruct ks8695_priv *ksp = netdev_priv(ndev);\r\nu32 ctrl;\r\nctrl = readl(ksp->phyiface_regs + KS8695_WMC);\r\nparam->autoneg = (ctrl & WMC_WANAP);\r\nctrl = ks8695_readreg(ksp, KS8695_DRXC);\r\nparam->rx_pause = (ctrl & DRXC_RFCE);\r\nctrl = ks8695_readreg(ksp, KS8695_DTXC);\r\nparam->tx_pause = (ctrl & DTXC_TFCE);\r\n}\r\nstatic void\r\nks8695_get_drvinfo(struct net_device *ndev, struct ethtool_drvinfo *info)\r\n{\r\nstrlcpy(info->driver, MODULENAME, sizeof(info->driver));\r\nstrlcpy(info->version, MODULEVERSION, sizeof(info->version));\r\nstrlcpy(info->bus_info, dev_name(ndev->dev.parent),\r\nsizeof(info->bus_info));\r\n}\r\nstatic int\r\nks8695_set_mac(struct net_device *ndev, void *addr)\r\n{\r\nstruct ks8695_priv *ksp = netdev_priv(ndev);\r\nstruct sockaddr *address = addr;\r\nif (!is_valid_ether_addr(address->sa_data))\r\nreturn -EADDRNOTAVAIL;\r\nmemcpy(ndev->dev_addr, address->sa_data, ndev->addr_len);\r\nks8695_update_mac(ksp);\r\ndev_dbg(ksp->dev, "%s: Updated MAC address to %pM\n",\r\nndev->name, ndev->dev_addr);\r\nreturn 0;\r\n}\r\nstatic void\r\nks8695_set_multicast(struct net_device *ndev)\r\n{\r\nstruct ks8695_priv *ksp = netdev_priv(ndev);\r\nu32 ctrl;\r\nctrl = ks8695_readreg(ksp, KS8695_DRXC);\r\nif (ndev->flags & IFF_PROMISC) {\r\nctrl |= DRXC_RA;\r\n} else if (ndev->flags & ~IFF_PROMISC) {\r\nctrl &= ~DRXC_RA;\r\n}\r\nif (ndev->flags & IFF_ALLMULTI) {\r\nctrl |= DRXC_RM;\r\n} else if (netdev_mc_count(ndev) > KS8695_NR_ADDRESSES) {\r\nctrl |= DRXC_RM;\r\n} else {\r\nctrl &= ~DRXC_RM;\r\nks8695_init_partial_multicast(ksp, ndev);\r\n}\r\nks8695_writereg(ksp, KS8695_DRXC, ctrl);\r\n}\r\nstatic void\r\nks8695_timeout(struct net_device *ndev)\r\n{\r\nstruct ks8695_priv *ksp = netdev_priv(ndev);\r\nnetif_stop_queue(ndev);\r\nks8695_shutdown(ksp);\r\nks8695_reset(ksp);\r\nks8695_update_mac(ksp);\r\nks8695_init_net(ksp);\r\nks8695_set_multicast(ndev);\r\nnetif_start_queue(ndev);\r\n}\r\nstatic int\r\nks8695_start_xmit(struct sk_buff *skb, struct net_device *ndev)\r\n{\r\nstruct ks8695_priv *ksp = netdev_priv(ndev);\r\nint buff_n;\r\ndma_addr_t dmap;\r\nspin_lock_irq(&ksp->txq_lock);\r\nif (ksp->tx_ring_used == MAX_TX_DESC) {\r\nspin_unlock_irq(&ksp->txq_lock);\r\nreturn NETDEV_TX_BUSY;\r\n}\r\nbuff_n = ksp->tx_ring_next_slot;\r\nBUG_ON(ksp->tx_buffers[buff_n].skb);\r\ndmap = dma_map_single(ksp->dev, skb->data, skb->len, DMA_TO_DEVICE);\r\nif (unlikely(dma_mapping_error(ksp->dev, dmap))) {\r\nspin_unlock_irq(&ksp->txq_lock);\r\ndev_dbg(ksp->dev, "%s: Could not map DMA memory for "\\r\n"transmission, trying later\n", ndev->name);\r\nreturn NETDEV_TX_BUSY;\r\n}\r\nksp->tx_buffers[buff_n].dma_ptr = dmap;\r\nksp->tx_buffers[buff_n].skb = skb;\r\nksp->tx_buffers[buff_n].length = skb->len;\r\nksp->tx_ring[buff_n].data_ptr =\r\ncpu_to_le32(ksp->tx_buffers[buff_n].dma_ptr);\r\nksp->tx_ring[buff_n].status =\r\ncpu_to_le32(TDES_IC | TDES_FS | TDES_LS |\r\n(skb->len & TDES_TBS));\r\nwmb();\r\nksp->tx_ring[buff_n].owner = cpu_to_le32(TDES_OWN);\r\nif (++ksp->tx_ring_used == MAX_TX_DESC)\r\nnetif_stop_queue(ndev);\r\nks8695_writereg(ksp, KS8695_DTSC, 0);\r\nksp->tx_ring_next_slot = (buff_n + 1) & MAX_TX_DESC_MASK;\r\nspin_unlock_irq(&ksp->txq_lock);\r\nreturn NETDEV_TX_OK;\r\n}\r\nstatic int\r\nks8695_stop(struct net_device *ndev)\r\n{\r\nstruct ks8695_priv *ksp = netdev_priv(ndev);\r\nnetif_stop_queue(ndev);\r\nnapi_disable(&ksp->napi);\r\nks8695_shutdown(ksp);\r\nreturn 0;\r\n}\r\nstatic int\r\nks8695_open(struct net_device *ndev)\r\n{\r\nstruct ks8695_priv *ksp = netdev_priv(ndev);\r\nint ret;\r\nks8695_reset(ksp);\r\nks8695_update_mac(ksp);\r\nret = ks8695_init_net(ksp);\r\nif (ret) {\r\nks8695_shutdown(ksp);\r\nreturn ret;\r\n}\r\nnapi_enable(&ksp->napi);\r\nnetif_start_queue(ndev);\r\nreturn 0;\r\n}\r\nstatic void\r\nks8695_init_switch(struct ks8695_priv *ksp)\r\n{\r\nu32 ctrl;\r\nctrl = 0x40819e00;\r\nctrl &= ~(SEC0_LLED1S | SEC0_LLED0S);\r\nctrl |= (LLED0S_LINK | LLED1S_LINK_ACTIVITY);\r\nctrl |= SEC0_ENABLE;\r\nwritel(ctrl, ksp->phyiface_regs + KS8695_SEC0);\r\nwritel(0x9400100, ksp->phyiface_regs + KS8695_SEC1);\r\n}\r\nstatic void\r\nks8695_init_wan_phy(struct ks8695_priv *ksp)\r\n{\r\nu32 ctrl;\r\nctrl = (WMC_WANAP | WMC_WANA100F | WMC_WANA100H |\r\nWMC_WANA10F | WMC_WANA10H);\r\nctrl |= (WLED0S_ACTIVITY | WLED1S_LINK);\r\nctrl |= WMC_WANR;\r\nwritel(ctrl, ksp->phyiface_regs + KS8695_WMC);\r\nwritel(0, ksp->phyiface_regs + KS8695_WPPM);\r\nwritel(0, ksp->phyiface_regs + KS8695_PPS);\r\n}\r\nstatic int\r\nks8695_probe(struct platform_device *pdev)\r\n{\r\nstruct ks8695_priv *ksp;\r\nstruct net_device *ndev;\r\nstruct resource *regs_res, *phyiface_res;\r\nstruct resource *rxirq_res, *txirq_res, *linkirq_res;\r\nint ret = 0;\r\nint buff_n;\r\nu32 machigh, maclow;\r\nndev = alloc_etherdev(sizeof(struct ks8695_priv));\r\nif (!ndev)\r\nreturn -ENOMEM;\r\nSET_NETDEV_DEV(ndev, &pdev->dev);\r\ndev_dbg(&pdev->dev, "ks8695_probe() called\n");\r\nksp = netdev_priv(ndev);\r\nksp->dev = &pdev->dev;\r\nksp->ndev = ndev;\r\nksp->msg_enable = NETIF_MSG_LINK;\r\nregs_res = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nphyiface_res = platform_get_resource(pdev, IORESOURCE_MEM, 1);\r\nrxirq_res = platform_get_resource(pdev, IORESOURCE_IRQ, 0);\r\ntxirq_res = platform_get_resource(pdev, IORESOURCE_IRQ, 1);\r\nlinkirq_res = platform_get_resource(pdev, IORESOURCE_IRQ, 2);\r\nif (!(regs_res && rxirq_res && txirq_res)) {\r\ndev_err(ksp->dev, "insufficient resources\n");\r\nret = -ENOENT;\r\ngoto failure;\r\n}\r\nksp->regs_req = request_mem_region(regs_res->start,\r\nresource_size(regs_res),\r\npdev->name);\r\nif (!ksp->regs_req) {\r\ndev_err(ksp->dev, "cannot claim register space\n");\r\nret = -EIO;\r\ngoto failure;\r\n}\r\nksp->io_regs = ioremap(regs_res->start, resource_size(regs_res));\r\nif (!ksp->io_regs) {\r\ndev_err(ksp->dev, "failed to ioremap registers\n");\r\nret = -EINVAL;\r\ngoto failure;\r\n}\r\nif (phyiface_res) {\r\nksp->phyiface_req =\r\nrequest_mem_region(phyiface_res->start,\r\nresource_size(phyiface_res),\r\nphyiface_res->name);\r\nif (!ksp->phyiface_req) {\r\ndev_err(ksp->dev,\r\n"cannot claim switch register space\n");\r\nret = -EIO;\r\ngoto failure;\r\n}\r\nksp->phyiface_regs = ioremap(phyiface_res->start,\r\nresource_size(phyiface_res));\r\nif (!ksp->phyiface_regs) {\r\ndev_err(ksp->dev,\r\n"failed to ioremap switch registers\n");\r\nret = -EINVAL;\r\ngoto failure;\r\n}\r\n}\r\nksp->rx_irq = rxirq_res->start;\r\nksp->rx_irq_name = rxirq_res->name ? rxirq_res->name : "Ethernet RX";\r\nksp->tx_irq = txirq_res->start;\r\nksp->tx_irq_name = txirq_res->name ? txirq_res->name : "Ethernet TX";\r\nksp->link_irq = (linkirq_res ? linkirq_res->start : -1);\r\nksp->link_irq_name = (linkirq_res && linkirq_res->name) ?\r\nlinkirq_res->name : "Ethernet Link";\r\nndev->netdev_ops = &ks8695_netdev_ops;\r\nndev->watchdog_timeo = msecs_to_jiffies(watchdog);\r\nnetif_napi_add(ndev, &ksp->napi, ks8695_poll, NAPI_WEIGHT);\r\nmachigh = ks8695_readreg(ksp, KS8695_MAH);\r\nmaclow = ks8695_readreg(ksp, KS8695_MAL);\r\nndev->dev_addr[0] = (machigh >> 8) & 0xFF;\r\nndev->dev_addr[1] = machigh & 0xFF;\r\nndev->dev_addr[2] = (maclow >> 24) & 0xFF;\r\nndev->dev_addr[3] = (maclow >> 16) & 0xFF;\r\nndev->dev_addr[4] = (maclow >> 8) & 0xFF;\r\nndev->dev_addr[5] = maclow & 0xFF;\r\nif (!is_valid_ether_addr(ndev->dev_addr))\r\ndev_warn(ksp->dev, "%s: Invalid ethernet MAC address. Please "\r\n"set using ifconfig\n", ndev->name);\r\nksp->ring_base = dma_alloc_coherent(&pdev->dev, RING_DMA_SIZE,\r\n&ksp->ring_base_dma, GFP_KERNEL);\r\nif (!ksp->ring_base) {\r\nret = -ENOMEM;\r\ngoto failure;\r\n}\r\nksp->tx_ring = ksp->ring_base;\r\nksp->tx_ring_dma = ksp->ring_base_dma;\r\nspin_lock_init(&ksp->txq_lock);\r\nspin_lock_init(&ksp->rx_lock);\r\nksp->rx_ring = ksp->ring_base + TX_RING_DMA_SIZE;\r\nksp->rx_ring_dma = ksp->ring_base_dma + TX_RING_DMA_SIZE;\r\nmemset(ksp->tx_ring, 0, TX_RING_DMA_SIZE);\r\nmemset(ksp->rx_ring, 0, RX_RING_DMA_SIZE);\r\nfor (buff_n = 0; buff_n < MAX_TX_DESC; ++buff_n) {\r\nksp->tx_ring[buff_n].next_desc =\r\ncpu_to_le32(ksp->tx_ring_dma +\r\n(sizeof(struct tx_ring_desc) *\r\n((buff_n + 1) & MAX_TX_DESC_MASK)));\r\n}\r\nfor (buff_n = 0; buff_n < MAX_RX_DESC; ++buff_n) {\r\nksp->rx_ring[buff_n].next_desc =\r\ncpu_to_le32(ksp->rx_ring_dma +\r\n(sizeof(struct rx_ring_desc) *\r\n((buff_n + 1) & MAX_RX_DESC_MASK)));\r\n}\r\nif (ksp->phyiface_regs && ksp->link_irq == -1) {\r\nks8695_init_switch(ksp);\r\nksp->dtype = KS8695_DTYPE_LAN;\r\nndev->ethtool_ops = &ks8695_ethtool_ops;\r\n} else if (ksp->phyiface_regs && ksp->link_irq != -1) {\r\nks8695_init_wan_phy(ksp);\r\nksp->dtype = KS8695_DTYPE_WAN;\r\nndev->ethtool_ops = &ks8695_wan_ethtool_ops;\r\n} else {\r\nksp->dtype = KS8695_DTYPE_HPNA;\r\nndev->ethtool_ops = &ks8695_ethtool_ops;\r\n}\r\nplatform_set_drvdata(pdev, ndev);\r\nret = register_netdev(ndev);\r\nif (ret == 0) {\r\ndev_info(ksp->dev, "ks8695 ethernet (%s) MAC: %pM\n",\r\nks8695_port_type(ksp), ndev->dev_addr);\r\n} else {\r\ndev_err(ksp->dev, "ks8695net: failed to register netdev.\n");\r\ngoto failure;\r\n}\r\nreturn 0;\r\nfailure:\r\nks8695_release_device(ksp);\r\nfree_netdev(ndev);\r\nreturn ret;\r\n}\r\nstatic int\r\nks8695_drv_suspend(struct platform_device *pdev, pm_message_t state)\r\n{\r\nstruct net_device *ndev = platform_get_drvdata(pdev);\r\nstruct ks8695_priv *ksp = netdev_priv(ndev);\r\nksp->in_suspend = 1;\r\nif (netif_running(ndev)) {\r\nnetif_device_detach(ndev);\r\nks8695_shutdown(ksp);\r\n}\r\nreturn 0;\r\n}\r\nstatic int\r\nks8695_drv_resume(struct platform_device *pdev)\r\n{\r\nstruct net_device *ndev = platform_get_drvdata(pdev);\r\nstruct ks8695_priv *ksp = netdev_priv(ndev);\r\nif (netif_running(ndev)) {\r\nks8695_reset(ksp);\r\nks8695_init_net(ksp);\r\nks8695_set_multicast(ndev);\r\nnetif_device_attach(ndev);\r\n}\r\nksp->in_suspend = 0;\r\nreturn 0;\r\n}\r\nstatic int\r\nks8695_drv_remove(struct platform_device *pdev)\r\n{\r\nstruct net_device *ndev = platform_get_drvdata(pdev);\r\nstruct ks8695_priv *ksp = netdev_priv(ndev);\r\nnetif_napi_del(&ksp->napi);\r\nunregister_netdev(ndev);\r\nks8695_release_device(ksp);\r\nfree_netdev(ndev);\r\ndev_dbg(&pdev->dev, "released and freed device\n");\r\nreturn 0;\r\n}
