static void *bond_info_seq_start(struct seq_file *seq, loff_t *pos)\r\n__acquires(RCU)\r\n{\r\nstruct bonding *bond = seq->private;\r\nstruct list_head *iter;\r\nstruct slave *slave;\r\nloff_t off = 0;\r\nrcu_read_lock();\r\nif (*pos == 0)\r\nreturn SEQ_START_TOKEN;\r\nbond_for_each_slave_rcu(bond, slave, iter)\r\nif (++off == *pos)\r\nreturn slave;\r\nreturn NULL;\r\n}\r\nstatic void *bond_info_seq_next(struct seq_file *seq, void *v, loff_t *pos)\r\n{\r\nstruct bonding *bond = seq->private;\r\nstruct list_head *iter;\r\nstruct slave *slave;\r\nbool found = false;\r\n++*pos;\r\nif (v == SEQ_START_TOKEN)\r\nreturn bond_first_slave_rcu(bond);\r\nbond_for_each_slave_rcu(bond, slave, iter) {\r\nif (found)\r\nreturn slave;\r\nif (slave == v)\r\nfound = true;\r\n}\r\nreturn NULL;\r\n}\r\nstatic void bond_info_seq_stop(struct seq_file *seq, void *v)\r\n__releases(RCU)\r\n{\r\nrcu_read_unlock();\r\n}\r\nstatic void bond_info_show_master(struct seq_file *seq)\r\n{\r\nstruct bonding *bond = seq->private;\r\nconst struct bond_opt_value *optval;\r\nstruct slave *curr, *primary;\r\nint i;\r\ncurr = rcu_dereference(bond->curr_active_slave);\r\nseq_printf(seq, "Bonding Mode: %s",\r\nbond_mode_name(BOND_MODE(bond)));\r\nif (BOND_MODE(bond) == BOND_MODE_ACTIVEBACKUP &&\r\nbond->params.fail_over_mac) {\r\noptval = bond_opt_get_val(BOND_OPT_FAIL_OVER_MAC,\r\nbond->params.fail_over_mac);\r\nseq_printf(seq, " (fail_over_mac %s)", optval->string);\r\n}\r\nseq_printf(seq, "\n");\r\nif (bond_mode_uses_xmit_hash(bond)) {\r\noptval = bond_opt_get_val(BOND_OPT_XMIT_HASH,\r\nbond->params.xmit_policy);\r\nseq_printf(seq, "Transmit Hash Policy: %s (%d)\n",\r\noptval->string, bond->params.xmit_policy);\r\n}\r\nif (bond_uses_primary(bond)) {\r\nprimary = rcu_dereference(bond->primary_slave);\r\nseq_printf(seq, "Primary Slave: %s",\r\nprimary ? primary->dev->name : "None");\r\nif (primary) {\r\noptval = bond_opt_get_val(BOND_OPT_PRIMARY_RESELECT,\r\nbond->params.primary_reselect);\r\nseq_printf(seq, " (primary_reselect %s)",\r\noptval->string);\r\n}\r\nseq_printf(seq, "\nCurrently Active Slave: %s\n",\r\n(curr) ? curr->dev->name : "None");\r\n}\r\nseq_printf(seq, "MII Status: %s\n", netif_carrier_ok(bond->dev) ?\r\n"up" : "down");\r\nseq_printf(seq, "MII Polling Interval (ms): %d\n", bond->params.miimon);\r\nseq_printf(seq, "Up Delay (ms): %d\n",\r\nbond->params.updelay * bond->params.miimon);\r\nseq_printf(seq, "Down Delay (ms): %d\n",\r\nbond->params.downdelay * bond->params.miimon);\r\nif (bond->params.arp_interval > 0) {\r\nint printed = 0;\r\nseq_printf(seq, "ARP Polling Interval (ms): %d\n",\r\nbond->params.arp_interval);\r\nseq_printf(seq, "ARP IP target/s (n.n.n.n form):");\r\nfor (i = 0; (i < BOND_MAX_ARP_TARGETS); i++) {\r\nif (!bond->params.arp_targets[i])\r\nbreak;\r\nif (printed)\r\nseq_printf(seq, ",");\r\nseq_printf(seq, " %pI4", &bond->params.arp_targets[i]);\r\nprinted = 1;\r\n}\r\nseq_printf(seq, "\n");\r\n}\r\nif (BOND_MODE(bond) == BOND_MODE_8023AD) {\r\nstruct ad_info ad_info;\r\nseq_puts(seq, "\n802.3ad info\n");\r\nseq_printf(seq, "LACP rate: %s\n",\r\n(bond->params.lacp_fast) ? "fast" : "slow");\r\nseq_printf(seq, "Min links: %d\n", bond->params.min_links);\r\noptval = bond_opt_get_val(BOND_OPT_AD_SELECT,\r\nbond->params.ad_select);\r\nseq_printf(seq, "Aggregator selection policy (ad_select): %s\n",\r\noptval->string);\r\nif (capable(CAP_NET_ADMIN)) {\r\nseq_printf(seq, "System priority: %d\n",\r\nBOND_AD_INFO(bond).system.sys_priority);\r\nseq_printf(seq, "System MAC address: %pM\n",\r\n&BOND_AD_INFO(bond).system.sys_mac_addr);\r\nif (__bond_3ad_get_active_agg_info(bond, &ad_info)) {\r\nseq_printf(seq,\r\n"bond %s has no active aggregator\n",\r\nbond->dev->name);\r\n} else {\r\nseq_printf(seq, "Active Aggregator Info:\n");\r\nseq_printf(seq, "\tAggregator ID: %d\n",\r\nad_info.aggregator_id);\r\nseq_printf(seq, "\tNumber of ports: %d\n",\r\nad_info.ports);\r\nseq_printf(seq, "\tActor Key: %d\n",\r\nad_info.actor_key);\r\nseq_printf(seq, "\tPartner Key: %d\n",\r\nad_info.partner_key);\r\nseq_printf(seq, "\tPartner Mac Address: %pM\n",\r\nad_info.partner_system);\r\n}\r\n}\r\n}\r\n}\r\nstatic void bond_info_show_slave(struct seq_file *seq,\r\nconst struct slave *slave)\r\n{\r\nstruct bonding *bond = seq->private;\r\nseq_printf(seq, "\nSlave Interface: %s\n", slave->dev->name);\r\nseq_printf(seq, "MII Status: %s\n", bond_slave_link_status(slave->link));\r\nif (slave->speed == SPEED_UNKNOWN)\r\nseq_printf(seq, "Speed: %s\n", "Unknown");\r\nelse\r\nseq_printf(seq, "Speed: %d Mbps\n", slave->speed);\r\nif (slave->duplex == DUPLEX_UNKNOWN)\r\nseq_printf(seq, "Duplex: %s\n", "Unknown");\r\nelse\r\nseq_printf(seq, "Duplex: %s\n", slave->duplex ? "full" : "half");\r\nseq_printf(seq, "Link Failure Count: %u\n",\r\nslave->link_failure_count);\r\nseq_printf(seq, "Permanent HW addr: %pM\n", slave->perm_hwaddr);\r\nseq_printf(seq, "Slave queue ID: %d\n", slave->queue_id);\r\nif (BOND_MODE(bond) == BOND_MODE_8023AD) {\r\nconst struct port *port = &SLAVE_AD_INFO(slave)->port;\r\nconst struct aggregator *agg = port->aggregator;\r\nif (agg) {\r\nseq_printf(seq, "Aggregator ID: %d\n",\r\nagg->aggregator_identifier);\r\nseq_printf(seq, "Actor Churn State: %s\n",\r\nbond_3ad_churn_desc(port->sm_churn_actor_state));\r\nseq_printf(seq, "Partner Churn State: %s\n",\r\nbond_3ad_churn_desc(port->sm_churn_partner_state));\r\nseq_printf(seq, "Actor Churned Count: %d\n",\r\nport->churn_actor_count);\r\nseq_printf(seq, "Partner Churned Count: %d\n",\r\nport->churn_partner_count);\r\nif (capable(CAP_NET_ADMIN)) {\r\nseq_puts(seq, "details actor lacp pdu:\n");\r\nseq_printf(seq, " system priority: %d\n",\r\nport->actor_system_priority);\r\nseq_printf(seq, " system mac address: %pM\n",\r\n&port->actor_system);\r\nseq_printf(seq, " port key: %d\n",\r\nport->actor_oper_port_key);\r\nseq_printf(seq, " port priority: %d\n",\r\nport->actor_port_priority);\r\nseq_printf(seq, " port number: %d\n",\r\nport->actor_port_number);\r\nseq_printf(seq, " port state: %d\n",\r\nport->actor_oper_port_state);\r\nseq_puts(seq, "details partner lacp pdu:\n");\r\nseq_printf(seq, " system priority: %d\n",\r\nport->partner_oper.system_priority);\r\nseq_printf(seq, " system mac address: %pM\n",\r\n&port->partner_oper.system);\r\nseq_printf(seq, " oper key: %d\n",\r\nport->partner_oper.key);\r\nseq_printf(seq, " port priority: %d\n",\r\nport->partner_oper.port_priority);\r\nseq_printf(seq, " port number: %d\n",\r\nport->partner_oper.port_number);\r\nseq_printf(seq, " port state: %d\n",\r\nport->partner_oper.port_state);\r\n}\r\n} else {\r\nseq_puts(seq, "Aggregator ID: N/A\n");\r\n}\r\n}\r\n}\r\nstatic int bond_info_seq_show(struct seq_file *seq, void *v)\r\n{\r\nif (v == SEQ_START_TOKEN) {\r\nseq_printf(seq, "%s\n", bond_version);\r\nbond_info_show_master(seq);\r\n} else\r\nbond_info_show_slave(seq, v);\r\nreturn 0;\r\n}\r\nstatic int bond_info_open(struct inode *inode, struct file *file)\r\n{\r\nstruct seq_file *seq;\r\nint res;\r\nres = seq_open(file, &bond_info_seq_ops);\r\nif (!res) {\r\nseq = file->private_data;\r\nseq->private = PDE_DATA(inode);\r\n}\r\nreturn res;\r\n}\r\nvoid bond_create_proc_entry(struct bonding *bond)\r\n{\r\nstruct net_device *bond_dev = bond->dev;\r\nstruct bond_net *bn = net_generic(dev_net(bond_dev), bond_net_id);\r\nif (bn->proc_dir) {\r\nbond->proc_entry = proc_create_data(bond_dev->name,\r\nS_IRUGO, bn->proc_dir,\r\n&bond_info_fops, bond);\r\nif (bond->proc_entry == NULL)\r\nnetdev_warn(bond_dev, "Cannot create /proc/net/%s/%s\n",\r\nDRV_NAME, bond_dev->name);\r\nelse\r\nmemcpy(bond->proc_file_name, bond_dev->name, IFNAMSIZ);\r\n}\r\n}\r\nvoid bond_remove_proc_entry(struct bonding *bond)\r\n{\r\nstruct net_device *bond_dev = bond->dev;\r\nstruct bond_net *bn = net_generic(dev_net(bond_dev), bond_net_id);\r\nif (bn->proc_dir && bond->proc_entry) {\r\nremove_proc_entry(bond->proc_file_name, bn->proc_dir);\r\nmemset(bond->proc_file_name, 0, IFNAMSIZ);\r\nbond->proc_entry = NULL;\r\n}\r\n}\r\nvoid __net_init bond_create_proc_dir(struct bond_net *bn)\r\n{\r\nif (!bn->proc_dir) {\r\nbn->proc_dir = proc_mkdir(DRV_NAME, bn->net->proc_net);\r\nif (!bn->proc_dir)\r\npr_warn("Warning: Cannot create /proc/net/%s\n",\r\nDRV_NAME);\r\n}\r\n}\r\nvoid __net_exit bond_destroy_proc_dir(struct bond_net *bn)\r\n{\r\nif (bn->proc_dir) {\r\nremove_proc_entry(DRV_NAME, bn->net->proc_net);\r\nbn->proc_dir = NULL;\r\n}\r\n}
