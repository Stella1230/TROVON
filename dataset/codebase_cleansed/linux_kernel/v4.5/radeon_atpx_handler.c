bool radeon_has_atpx(void) {\r\nreturn radeon_atpx_priv.atpx_detected;\r\n}\r\nstatic union acpi_object *radeon_atpx_call(acpi_handle handle, int function,\r\nstruct acpi_buffer *params)\r\n{\r\nacpi_status status;\r\nunion acpi_object atpx_arg_elements[2];\r\nstruct acpi_object_list atpx_arg;\r\nstruct acpi_buffer buffer = { ACPI_ALLOCATE_BUFFER, NULL };\r\natpx_arg.count = 2;\r\natpx_arg.pointer = &atpx_arg_elements[0];\r\natpx_arg_elements[0].type = ACPI_TYPE_INTEGER;\r\natpx_arg_elements[0].integer.value = function;\r\nif (params) {\r\natpx_arg_elements[1].type = ACPI_TYPE_BUFFER;\r\natpx_arg_elements[1].buffer.length = params->length;\r\natpx_arg_elements[1].buffer.pointer = params->pointer;\r\n} else {\r\natpx_arg_elements[1].type = ACPI_TYPE_INTEGER;\r\natpx_arg_elements[1].integer.value = 0;\r\n}\r\nstatus = acpi_evaluate_object(handle, NULL, &atpx_arg, &buffer);\r\nif (ACPI_FAILURE(status) && status != AE_NOT_FOUND) {\r\nprintk("failed to evaluate ATPX got %s\n",\r\nacpi_format_exception(status));\r\nkfree(buffer.pointer);\r\nreturn NULL;\r\n}\r\nreturn buffer.pointer;\r\n}\r\nstatic void radeon_atpx_parse_functions(struct radeon_atpx_functions *f, u32 mask)\r\n{\r\nf->px_params = mask & ATPX_GET_PX_PARAMETERS_SUPPORTED;\r\nf->power_cntl = mask & ATPX_POWER_CONTROL_SUPPORTED;\r\nf->disp_mux_cntl = mask & ATPX_DISPLAY_MUX_CONTROL_SUPPORTED;\r\nf->i2c_mux_cntl = mask & ATPX_I2C_MUX_CONTROL_SUPPORTED;\r\nf->switch_start = mask & ATPX_GRAPHICS_DEVICE_SWITCH_START_NOTIFICATION_SUPPORTED;\r\nf->switch_end = mask & ATPX_GRAPHICS_DEVICE_SWITCH_END_NOTIFICATION_SUPPORTED;\r\nf->disp_connectors_mapping = mask & ATPX_GET_DISPLAY_CONNECTORS_MAPPING_SUPPORTED;\r\nf->disp_detetion_ports = mask & ATPX_GET_DISPLAY_DETECTION_PORTS_SUPPORTED;\r\n}\r\nstatic int radeon_atpx_validate(struct radeon_atpx *atpx)\r\n{\r\natpx->functions.power_cntl = true;\r\nif (atpx->functions.px_params) {\r\nunion acpi_object *info;\r\nstruct atpx_px_params output;\r\nsize_t size;\r\nu32 valid_bits;\r\ninfo = radeon_atpx_call(atpx->handle, ATPX_FUNCTION_GET_PX_PARAMETERS, NULL);\r\nif (!info)\r\nreturn -EIO;\r\nmemset(&output, 0, sizeof(output));\r\nsize = *(u16 *) info->buffer.pointer;\r\nif (size < 10) {\r\nprintk("ATPX buffer is too small: %zu\n", size);\r\nkfree(info);\r\nreturn -EINVAL;\r\n}\r\nsize = min(sizeof(output), size);\r\nmemcpy(&output, info->buffer.pointer, size);\r\nvalid_bits = output.flags & output.valid_flags;\r\nif (valid_bits & ATPX_SEPARATE_MUX_FOR_I2C) {\r\natpx->functions.i2c_mux_cntl = true;\r\natpx->functions.disp_mux_cntl = true;\r\n}\r\nif (valid_bits & (ATPX_CRT1_RGB_SIGNAL_MUXED |\r\nATPX_TV_SIGNAL_MUXED |\r\nATPX_DFP_SIGNAL_MUXED))\r\natpx->functions.disp_mux_cntl = true;\r\nkfree(info);\r\n}\r\nreturn 0;\r\n}\r\nstatic int radeon_atpx_verify_interface(struct radeon_atpx *atpx)\r\n{\r\nunion acpi_object *info;\r\nstruct atpx_verify_interface output;\r\nsize_t size;\r\nint err = 0;\r\ninfo = radeon_atpx_call(atpx->handle, ATPX_FUNCTION_VERIFY_INTERFACE, NULL);\r\nif (!info)\r\nreturn -EIO;\r\nmemset(&output, 0, sizeof(output));\r\nsize = *(u16 *) info->buffer.pointer;\r\nif (size < 8) {\r\nprintk("ATPX buffer is too small: %zu\n", size);\r\nerr = -EINVAL;\r\ngoto out;\r\n}\r\nsize = min(sizeof(output), size);\r\nmemcpy(&output, info->buffer.pointer, size);\r\nprintk("ATPX version %u, functions 0x%08x\n",\r\noutput.version, output.function_bits);\r\nradeon_atpx_parse_functions(&atpx->functions, output.function_bits);\r\nout:\r\nkfree(info);\r\nreturn err;\r\n}\r\nstatic int radeon_atpx_set_discrete_state(struct radeon_atpx *atpx, u8 state)\r\n{\r\nstruct acpi_buffer params;\r\nunion acpi_object *info;\r\nstruct atpx_power_control input;\r\nif (atpx->functions.power_cntl) {\r\ninput.size = 3;\r\ninput.dgpu_state = state;\r\nparams.length = input.size;\r\nparams.pointer = &input;\r\ninfo = radeon_atpx_call(atpx->handle,\r\nATPX_FUNCTION_POWER_CONTROL,\r\n&params);\r\nif (!info)\r\nreturn -EIO;\r\nkfree(info);\r\n}\r\nreturn 0;\r\n}\r\nstatic int radeon_atpx_switch_disp_mux(struct radeon_atpx *atpx, u16 mux_id)\r\n{\r\nstruct acpi_buffer params;\r\nunion acpi_object *info;\r\nstruct atpx_mux input;\r\nif (atpx->functions.disp_mux_cntl) {\r\ninput.size = 4;\r\ninput.mux = mux_id;\r\nparams.length = input.size;\r\nparams.pointer = &input;\r\ninfo = radeon_atpx_call(atpx->handle,\r\nATPX_FUNCTION_DISPLAY_MUX_CONTROL,\r\n&params);\r\nif (!info)\r\nreturn -EIO;\r\nkfree(info);\r\n}\r\nreturn 0;\r\n}\r\nstatic int radeon_atpx_switch_i2c_mux(struct radeon_atpx *atpx, u16 mux_id)\r\n{\r\nstruct acpi_buffer params;\r\nunion acpi_object *info;\r\nstruct atpx_mux input;\r\nif (atpx->functions.i2c_mux_cntl) {\r\ninput.size = 4;\r\ninput.mux = mux_id;\r\nparams.length = input.size;\r\nparams.pointer = &input;\r\ninfo = radeon_atpx_call(atpx->handle,\r\nATPX_FUNCTION_I2C_MUX_CONTROL,\r\n&params);\r\nif (!info)\r\nreturn -EIO;\r\nkfree(info);\r\n}\r\nreturn 0;\r\n}\r\nstatic int radeon_atpx_switch_start(struct radeon_atpx *atpx, u16 mux_id)\r\n{\r\nstruct acpi_buffer params;\r\nunion acpi_object *info;\r\nstruct atpx_mux input;\r\nif (atpx->functions.switch_start) {\r\ninput.size = 4;\r\ninput.mux = mux_id;\r\nparams.length = input.size;\r\nparams.pointer = &input;\r\ninfo = radeon_atpx_call(atpx->handle,\r\nATPX_FUNCTION_GRAPHICS_DEVICE_SWITCH_START_NOTIFICATION,\r\n&params);\r\nif (!info)\r\nreturn -EIO;\r\nkfree(info);\r\n}\r\nreturn 0;\r\n}\r\nstatic int radeon_atpx_switch_end(struct radeon_atpx *atpx, u16 mux_id)\r\n{\r\nstruct acpi_buffer params;\r\nunion acpi_object *info;\r\nstruct atpx_mux input;\r\nif (atpx->functions.switch_end) {\r\ninput.size = 4;\r\ninput.mux = mux_id;\r\nparams.length = input.size;\r\nparams.pointer = &input;\r\ninfo = radeon_atpx_call(atpx->handle,\r\nATPX_FUNCTION_GRAPHICS_DEVICE_SWITCH_END_NOTIFICATION,\r\n&params);\r\nif (!info)\r\nreturn -EIO;\r\nkfree(info);\r\n}\r\nreturn 0;\r\n}\r\nstatic int radeon_atpx_switchto(enum vga_switcheroo_client_id id)\r\n{\r\nu16 gpu_id;\r\nif (id == VGA_SWITCHEROO_IGD)\r\ngpu_id = ATPX_INTEGRATED_GPU;\r\nelse\r\ngpu_id = ATPX_DISCRETE_GPU;\r\nradeon_atpx_switch_start(&radeon_atpx_priv.atpx, gpu_id);\r\nradeon_atpx_switch_disp_mux(&radeon_atpx_priv.atpx, gpu_id);\r\nradeon_atpx_switch_i2c_mux(&radeon_atpx_priv.atpx, gpu_id);\r\nradeon_atpx_switch_end(&radeon_atpx_priv.atpx, gpu_id);\r\nreturn 0;\r\n}\r\nstatic int radeon_atpx_power_state(enum vga_switcheroo_client_id id,\r\nenum vga_switcheroo_state state)\r\n{\r\nif (id == VGA_SWITCHEROO_IGD)\r\nreturn 0;\r\nradeon_atpx_set_discrete_state(&radeon_atpx_priv.atpx, state);\r\nreturn 0;\r\n}\r\nstatic bool radeon_atpx_pci_probe_handle(struct pci_dev *pdev)\r\n{\r\nacpi_handle dhandle, atpx_handle;\r\nacpi_status status;\r\ndhandle = ACPI_HANDLE(&pdev->dev);\r\nif (!dhandle)\r\nreturn false;\r\nstatus = acpi_get_handle(dhandle, "ATPX", &atpx_handle);\r\nif (ACPI_FAILURE(status))\r\nreturn false;\r\nradeon_atpx_priv.dhandle = dhandle;\r\nradeon_atpx_priv.atpx.handle = atpx_handle;\r\nreturn true;\r\n}\r\nstatic int radeon_atpx_init(void)\r\n{\r\nint r;\r\nr = radeon_atpx_verify_interface(&radeon_atpx_priv.atpx);\r\nif (r)\r\nreturn r;\r\nr = radeon_atpx_validate(&radeon_atpx_priv.atpx);\r\nif (r)\r\nreturn r;\r\nreturn 0;\r\n}\r\nstatic int radeon_atpx_get_client_id(struct pci_dev *pdev)\r\n{\r\nif (radeon_atpx_priv.dhandle == ACPI_HANDLE(&pdev->dev))\r\nreturn VGA_SWITCHEROO_IGD;\r\nelse\r\nreturn VGA_SWITCHEROO_DIS;\r\n}\r\nstatic bool radeon_atpx_detect(void)\r\n{\r\nchar acpi_method_name[255] = { 0 };\r\nstruct acpi_buffer buffer = {sizeof(acpi_method_name), acpi_method_name};\r\nstruct pci_dev *pdev = NULL;\r\nbool has_atpx = false;\r\nint vga_count = 0;\r\nwhile ((pdev = pci_get_class(PCI_CLASS_DISPLAY_VGA << 8, pdev)) != NULL) {\r\nvga_count++;\r\nhas_atpx |= (radeon_atpx_pci_probe_handle(pdev) == true);\r\n}\r\nwhile ((pdev = pci_get_class(PCI_CLASS_DISPLAY_OTHER << 8, pdev)) != NULL) {\r\nvga_count++;\r\nhas_atpx |= (radeon_atpx_pci_probe_handle(pdev) == true);\r\n}\r\nif (has_atpx && vga_count == 2) {\r\nacpi_get_name(radeon_atpx_priv.atpx.handle, ACPI_FULL_PATHNAME, &buffer);\r\nprintk(KERN_INFO "vga_switcheroo: detected switching method %s handle\n",\r\nacpi_method_name);\r\nradeon_atpx_priv.atpx_detected = true;\r\nreturn true;\r\n}\r\nreturn false;\r\n}\r\nvoid radeon_register_atpx_handler(void)\r\n{\r\nbool r;\r\nr = radeon_atpx_detect();\r\nif (!r)\r\nreturn;\r\nvga_switcheroo_register_handler(&radeon_atpx_handler);\r\n}\r\nvoid radeon_unregister_atpx_handler(void)\r\n{\r\nvga_switcheroo_unregister_handler();\r\n}
