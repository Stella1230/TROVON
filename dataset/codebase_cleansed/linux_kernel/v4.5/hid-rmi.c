static int rmi_set_page(struct hid_device *hdev, u8 page)\r\n{\r\nstruct rmi_data *data = hid_get_drvdata(hdev);\r\nint retval;\r\ndata->writeReport[0] = RMI_WRITE_REPORT_ID;\r\ndata->writeReport[1] = 1;\r\ndata->writeReport[2] = 0xFF;\r\ndata->writeReport[4] = page;\r\nretval = rmi_write_report(hdev, data->writeReport,\r\ndata->output_report_size);\r\nif (retval != data->output_report_size) {\r\ndev_err(&hdev->dev,\r\n"%s: set page failed: %d.", __func__, retval);\r\nreturn retval;\r\n}\r\ndata->page = page;\r\nreturn 0;\r\n}\r\nstatic int rmi_set_mode(struct hid_device *hdev, u8 mode)\r\n{\r\nint ret;\r\nu8 txbuf[2] = {RMI_SET_RMI_MODE_REPORT_ID, mode};\r\nret = hid_hw_raw_request(hdev, RMI_SET_RMI_MODE_REPORT_ID, txbuf,\r\nsizeof(txbuf), HID_FEATURE_REPORT, HID_REQ_SET_REPORT);\r\nif (ret < 0) {\r\ndev_err(&hdev->dev, "unable to set rmi mode to %d (%d)\n", mode,\r\nret);\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic int rmi_write_report(struct hid_device *hdev, u8 *report, int len)\r\n{\r\nint ret;\r\nret = hid_hw_output_report(hdev, (void *)report, len);\r\nif (ret < 0) {\r\ndev_err(&hdev->dev, "failed to write hid report (%d)\n", ret);\r\nreturn ret;\r\n}\r\nreturn ret;\r\n}\r\nstatic int rmi_read_block(struct hid_device *hdev, u16 addr, void *buf,\r\nconst int len)\r\n{\r\nstruct rmi_data *data = hid_get_drvdata(hdev);\r\nint ret;\r\nint bytes_read;\r\nint bytes_needed;\r\nint retries;\r\nint read_input_count;\r\nmutex_lock(&data->page_mutex);\r\nif (RMI_PAGE(addr) != data->page) {\r\nret = rmi_set_page(hdev, RMI_PAGE(addr));\r\nif (ret < 0)\r\ngoto exit;\r\n}\r\nfor (retries = 5; retries > 0; retries--) {\r\ndata->writeReport[0] = RMI_READ_ADDR_REPORT_ID;\r\ndata->writeReport[1] = 0;\r\ndata->writeReport[2] = addr & 0xFF;\r\ndata->writeReport[3] = (addr >> 8) & 0xFF;\r\ndata->writeReport[4] = len & 0xFF;\r\ndata->writeReport[5] = (len >> 8) & 0xFF;\r\nset_bit(RMI_READ_REQUEST_PENDING, &data->flags);\r\nret = rmi_write_report(hdev, data->writeReport,\r\ndata->output_report_size);\r\nif (ret != data->output_report_size) {\r\nclear_bit(RMI_READ_REQUEST_PENDING, &data->flags);\r\ndev_err(&hdev->dev,\r\n"failed to write request output report (%d)\n",\r\nret);\r\ngoto exit;\r\n}\r\nbytes_read = 0;\r\nbytes_needed = len;\r\nwhile (bytes_read < len) {\r\nif (!wait_event_timeout(data->wait,\r\ntest_bit(RMI_READ_DATA_PENDING, &data->flags),\r\nmsecs_to_jiffies(1000))) {\r\nhid_warn(hdev, "%s: timeout elapsed\n",\r\n__func__);\r\nret = -EAGAIN;\r\nbreak;\r\n}\r\nread_input_count = data->readReport[1];\r\nmemcpy(buf + bytes_read, &data->readReport[2],\r\nread_input_count < bytes_needed ?\r\nread_input_count : bytes_needed);\r\nbytes_read += read_input_count;\r\nbytes_needed -= read_input_count;\r\nclear_bit(RMI_READ_DATA_PENDING, &data->flags);\r\n}\r\nif (ret >= 0) {\r\nret = 0;\r\nbreak;\r\n}\r\n}\r\nexit:\r\nclear_bit(RMI_READ_REQUEST_PENDING, &data->flags);\r\nmutex_unlock(&data->page_mutex);\r\nreturn ret;\r\n}\r\nstatic inline int rmi_read(struct hid_device *hdev, u16 addr, void *buf)\r\n{\r\nreturn rmi_read_block(hdev, addr, buf, 1);\r\n}\r\nstatic int rmi_write_block(struct hid_device *hdev, u16 addr, void *buf,\r\nconst int len)\r\n{\r\nstruct rmi_data *data = hid_get_drvdata(hdev);\r\nint ret;\r\nmutex_lock(&data->page_mutex);\r\nif (RMI_PAGE(addr) != data->page) {\r\nret = rmi_set_page(hdev, RMI_PAGE(addr));\r\nif (ret < 0)\r\ngoto exit;\r\n}\r\ndata->writeReport[0] = RMI_WRITE_REPORT_ID;\r\ndata->writeReport[1] = len;\r\ndata->writeReport[2] = addr & 0xFF;\r\ndata->writeReport[3] = (addr >> 8) & 0xFF;\r\nmemcpy(&data->writeReport[4], buf, len);\r\nret = rmi_write_report(hdev, data->writeReport,\r\ndata->output_report_size);\r\nif (ret < 0) {\r\ndev_err(&hdev->dev,\r\n"failed to write request output report (%d)\n",\r\nret);\r\ngoto exit;\r\n}\r\nret = 0;\r\nexit:\r\nmutex_unlock(&data->page_mutex);\r\nreturn ret;\r\n}\r\nstatic inline int rmi_write(struct hid_device *hdev, u16 addr, void *buf)\r\n{\r\nreturn rmi_write_block(hdev, addr, buf, 1);\r\n}\r\nstatic void rmi_f11_process_touch(struct rmi_data *hdata, int slot,\r\nu8 finger_state, u8 *touch_data)\r\n{\r\nint x, y, wx, wy;\r\nint wide, major, minor;\r\nint z;\r\ninput_mt_slot(hdata->input, slot);\r\ninput_mt_report_slot_state(hdata->input, MT_TOOL_FINGER,\r\nfinger_state == 0x01);\r\nif (finger_state == 0x01) {\r\nx = (touch_data[0] << 4) | (touch_data[2] & 0x0F);\r\ny = (touch_data[1] << 4) | (touch_data[2] >> 4);\r\nwx = touch_data[3] & 0x0F;\r\nwy = touch_data[3] >> 4;\r\nwide = (wx > wy);\r\nmajor = max(wx, wy);\r\nminor = min(wx, wy);\r\nz = touch_data[4];\r\ny = hdata->max_y - y;\r\ninput_event(hdata->input, EV_ABS, ABS_MT_POSITION_X, x);\r\ninput_event(hdata->input, EV_ABS, ABS_MT_POSITION_Y, y);\r\ninput_event(hdata->input, EV_ABS, ABS_MT_ORIENTATION, wide);\r\ninput_event(hdata->input, EV_ABS, ABS_MT_PRESSURE, z);\r\ninput_event(hdata->input, EV_ABS, ABS_MT_TOUCH_MAJOR, major);\r\ninput_event(hdata->input, EV_ABS, ABS_MT_TOUCH_MINOR, minor);\r\n}\r\n}\r\nstatic int rmi_reset_attn_mode(struct hid_device *hdev)\r\n{\r\nstruct rmi_data *data = hid_get_drvdata(hdev);\r\nint ret;\r\nret = rmi_set_mode(hdev, RMI_MODE_ATTN_REPORTS);\r\nif (ret)\r\nreturn ret;\r\nif (data->restore_interrupt_mask) {\r\nret = rmi_write(hdev, data->f01.control_base_addr + 1,\r\n&data->interrupt_enable_mask);\r\nif (ret) {\r\nhid_err(hdev, "can not write F01 control register\n");\r\nreturn ret;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic void rmi_reset_work(struct work_struct *work)\r\n{\r\nstruct rmi_data *hdata = container_of(work, struct rmi_data,\r\nreset_work);\r\nrmi_reset_attn_mode(hdata->hdev);\r\n}\r\nstatic inline int rmi_schedule_reset(struct hid_device *hdev)\r\n{\r\nstruct rmi_data *hdata = hid_get_drvdata(hdev);\r\nreturn schedule_work(&hdata->reset_work);\r\n}\r\nstatic int rmi_f11_input_event(struct hid_device *hdev, u8 irq, u8 *data,\r\nint size)\r\n{\r\nstruct rmi_data *hdata = hid_get_drvdata(hdev);\r\nint offset;\r\nint i;\r\nif (!(irq & hdata->f11.irq_mask) || size <= 0)\r\nreturn 0;\r\noffset = (hdata->max_fingers >> 2) + 1;\r\nfor (i = 0; i < hdata->max_fingers; i++) {\r\nint fs_byte_position = i >> 2;\r\nint fs_bit_position = (i & 0x3) << 1;\r\nint finger_state = (data[fs_byte_position] >> fs_bit_position) &\r\n0x03;\r\nint position = offset + 5 * i;\r\nif (position + 5 > size) {\r\nprintk_once(KERN_WARNING\r\n"%s %s: Detected incomplete finger report. Finger reports may occasionally get dropped on this platform.\n",\r\ndev_driver_string(&hdev->dev),\r\ndev_name(&hdev->dev));\r\nhid_dbg(hdev, "Incomplete finger report\n");\r\nbreak;\r\n}\r\nrmi_f11_process_touch(hdata, i, finger_state, &data[position]);\r\n}\r\ninput_mt_sync_frame(hdata->input);\r\ninput_sync(hdata->input);\r\nreturn hdata->f11.report_size;\r\n}\r\nstatic int rmi_f30_input_event(struct hid_device *hdev, u8 irq, u8 *data,\r\nint size)\r\n{\r\nstruct rmi_data *hdata = hid_get_drvdata(hdev);\r\nint i;\r\nint button = 0;\r\nbool value;\r\nif (!(irq & hdata->f30.irq_mask))\r\nreturn 0;\r\nif (size < (int)hdata->f30.report_size) {\r\nhid_warn(hdev, "Click Button pressed, but the click data is missing\n");\r\nreturn 0;\r\n}\r\nfor (i = 0; i < hdata->gpio_led_count; i++) {\r\nif (test_bit(i, &hdata->button_mask)) {\r\nvalue = (data[i / 8] >> (i & 0x07)) & BIT(0);\r\nif (test_bit(i, &hdata->button_state_mask))\r\nvalue = !value;\r\ninput_event(hdata->input, EV_KEY, BTN_LEFT + button++,\r\nvalue);\r\n}\r\n}\r\nreturn hdata->f30.report_size;\r\n}\r\nstatic int rmi_input_event(struct hid_device *hdev, u8 *data, int size)\r\n{\r\nstruct rmi_data *hdata = hid_get_drvdata(hdev);\r\nunsigned long irq_mask = 0;\r\nunsigned index = 2;\r\nif (!(test_bit(RMI_STARTED, &hdata->flags)))\r\nreturn 0;\r\nirq_mask |= hdata->f11.irq_mask;\r\nirq_mask |= hdata->f30.irq_mask;\r\nif (data[1] & ~irq_mask)\r\nhid_dbg(hdev, "unknown intr source:%02lx %s:%d\n",\r\ndata[1] & ~irq_mask, __FILE__, __LINE__);\r\nif (hdata->f11.interrupt_base < hdata->f30.interrupt_base) {\r\nindex += rmi_f11_input_event(hdev, data[1], &data[index],\r\nsize - index);\r\nindex += rmi_f30_input_event(hdev, data[1], &data[index],\r\nsize - index);\r\n} else {\r\nindex += rmi_f30_input_event(hdev, data[1], &data[index],\r\nsize - index);\r\nindex += rmi_f11_input_event(hdev, data[1], &data[index],\r\nsize - index);\r\n}\r\nreturn 1;\r\n}\r\nstatic int rmi_read_data_event(struct hid_device *hdev, u8 *data, int size)\r\n{\r\nstruct rmi_data *hdata = hid_get_drvdata(hdev);\r\nif (!test_bit(RMI_READ_REQUEST_PENDING, &hdata->flags)) {\r\nhid_dbg(hdev, "no read request pending\n");\r\nreturn 0;\r\n}\r\nmemcpy(hdata->readReport, data, size < hdata->input_report_size ?\r\nsize : hdata->input_report_size);\r\nset_bit(RMI_READ_DATA_PENDING, &hdata->flags);\r\nwake_up(&hdata->wait);\r\nreturn 1;\r\n}\r\nstatic int rmi_check_sanity(struct hid_device *hdev, u8 *data, int size)\r\n{\r\nint valid_size = size;\r\nwhile ((data[valid_size - 1] == 0xff) && valid_size > 0)\r\nvalid_size--;\r\nreturn valid_size;\r\n}\r\nstatic int rmi_raw_event(struct hid_device *hdev,\r\nstruct hid_report *report, u8 *data, int size)\r\n{\r\nsize = rmi_check_sanity(hdev, data, size);\r\nif (size < 2)\r\nreturn 0;\r\nswitch (data[0]) {\r\ncase RMI_READ_DATA_REPORT_ID:\r\nreturn rmi_read_data_event(hdev, data, size);\r\ncase RMI_ATTN_REPORT_ID:\r\nreturn rmi_input_event(hdev, data, size);\r\ndefault:\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}\r\nstatic int rmi_event(struct hid_device *hdev, struct hid_field *field,\r\nstruct hid_usage *usage, __s32 value)\r\n{\r\nstruct rmi_data *data = hid_get_drvdata(hdev);\r\nif ((data->device_flags & RMI_DEVICE) &&\r\n(field->application == HID_GD_POINTER ||\r\nfield->application == HID_GD_MOUSE)) {\r\nif (data->device_flags & RMI_DEVICE_HAS_PHYS_BUTTONS) {\r\nif ((usage->hid & HID_USAGE_PAGE) == HID_UP_BUTTON)\r\nreturn 0;\r\nif ((usage->hid == HID_GD_X || usage->hid == HID_GD_Y)\r\n&& !value)\r\nreturn 1;\r\n}\r\nrmi_schedule_reset(hdev);\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}\r\nstatic int rmi_set_sleep_mode(struct hid_device *hdev, int sleep_mode)\r\n{\r\nstruct rmi_data *data = hid_get_drvdata(hdev);\r\nint ret;\r\nu8 f01_ctrl0;\r\nf01_ctrl0 = (data->f01_ctrl0 & ~0x3) | sleep_mode;\r\nret = rmi_write(hdev, data->f01.control_base_addr,\r\n&f01_ctrl0);\r\nif (ret) {\r\nhid_err(hdev, "can not write sleep mode\n");\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic int rmi_suspend(struct hid_device *hdev, pm_message_t message)\r\n{\r\nstruct rmi_data *data = hid_get_drvdata(hdev);\r\nint ret;\r\nu8 buf[RMI_F11_CTRL_REG_COUNT];\r\nret = rmi_read_block(hdev, data->f11.control_base_addr, buf,\r\nRMI_F11_CTRL_REG_COUNT);\r\nif (ret)\r\nhid_warn(hdev, "can not read F11 control registers\n");\r\nelse\r\nmemcpy(data->f11_ctrl_regs, buf, RMI_F11_CTRL_REG_COUNT);\r\nif (!device_may_wakeup(hdev->dev.parent))\r\nreturn rmi_set_sleep_mode(hdev, RMI_SLEEP_DEEP_SLEEP);\r\nreturn 0;\r\n}\r\nstatic int rmi_post_reset(struct hid_device *hdev)\r\n{\r\nstruct rmi_data *data = hid_get_drvdata(hdev);\r\nint ret;\r\nret = rmi_reset_attn_mode(hdev);\r\nif (ret) {\r\nhid_err(hdev, "can not set rmi mode\n");\r\nreturn ret;\r\n}\r\nif (data->read_f11_ctrl_regs) {\r\nret = rmi_write_block(hdev, data->f11.control_base_addr,\r\ndata->f11_ctrl_regs, RMI_F11_CTRL_REG_COUNT);\r\nif (ret)\r\nhid_warn(hdev,\r\n"can not write F11 control registers after reset\n");\r\n}\r\nif (!device_may_wakeup(hdev->dev.parent)) {\r\nret = rmi_set_sleep_mode(hdev, RMI_SLEEP_NORMAL);\r\nif (ret) {\r\nhid_err(hdev, "can not write sleep mode\n");\r\nreturn ret;\r\n}\r\n}\r\nreturn ret;\r\n}\r\nstatic int rmi_post_resume(struct hid_device *hdev)\r\n{\r\nreturn rmi_reset_attn_mode(hdev);\r\n}\r\nstatic inline unsigned long rmi_gen_mask(unsigned irq_base, unsigned irq_count)\r\n{\r\nreturn GENMASK(irq_count + irq_base - 1, irq_base);\r\n}\r\nstatic void rmi_register_function(struct rmi_data *data,\r\nstruct pdt_entry *pdt_entry, int page, unsigned interrupt_count)\r\n{\r\nstruct rmi_function *f = NULL;\r\nu16 page_base = page << 8;\r\nswitch (pdt_entry->function_number) {\r\ncase 0x01:\r\nf = &data->f01;\r\nbreak;\r\ncase 0x11:\r\nf = &data->f11;\r\nbreak;\r\ncase 0x30:\r\nf = &data->f30;\r\nbreak;\r\n}\r\nif (f) {\r\nf->page = page;\r\nf->query_base_addr = page_base | pdt_entry->query_base_addr;\r\nf->command_base_addr = page_base | pdt_entry->command_base_addr;\r\nf->control_base_addr = page_base | pdt_entry->control_base_addr;\r\nf->data_base_addr = page_base | pdt_entry->data_base_addr;\r\nf->interrupt_base = interrupt_count;\r\nf->interrupt_count = pdt_entry->interrupt_source_count;\r\nf->irq_mask = rmi_gen_mask(f->interrupt_base,\r\nf->interrupt_count);\r\ndata->interrupt_enable_mask |= f->irq_mask;\r\n}\r\n}\r\nstatic int rmi_scan_pdt(struct hid_device *hdev)\r\n{\r\nstruct rmi_data *data = hid_get_drvdata(hdev);\r\nstruct pdt_entry entry;\r\nint page;\r\nbool page_has_function;\r\nint i;\r\nint retval;\r\nint interrupt = 0;\r\nu16 page_start, pdt_start , pdt_end;\r\nhid_info(hdev, "Scanning PDT...\n");\r\nfor (page = 0; (page <= RMI4_MAX_PAGE); page++) {\r\npage_start = RMI4_PAGE_SIZE * page;\r\npdt_start = page_start + PDT_START_SCAN_LOCATION;\r\npdt_end = page_start + PDT_END_SCAN_LOCATION;\r\npage_has_function = false;\r\nfor (i = pdt_start; i >= pdt_end; i -= sizeof(entry)) {\r\nretval = rmi_read_block(hdev, i, &entry, sizeof(entry));\r\nif (retval) {\r\nhid_err(hdev,\r\n"Read of PDT entry at %#06x failed.\n",\r\ni);\r\ngoto error_exit;\r\n}\r\nif (RMI4_END_OF_PDT(entry.function_number))\r\nbreak;\r\npage_has_function = true;\r\nhid_info(hdev, "Found F%02X on page %#04x\n",\r\nentry.function_number, page);\r\nrmi_register_function(data, &entry, page, interrupt);\r\ninterrupt += entry.interrupt_source_count;\r\n}\r\nif (!page_has_function)\r\nbreak;\r\n}\r\nhid_info(hdev, "%s: Done with PDT scan.\n", __func__);\r\nretval = 0;\r\nerror_exit:\r\nreturn retval;\r\n}\r\nstatic int rmi_populate_f01(struct hid_device *hdev)\r\n{\r\nstruct rmi_data *data = hid_get_drvdata(hdev);\r\nu8 basic_queries[RMI_DEVICE_F01_BASIC_QUERY_LEN];\r\nu8 info[3];\r\nint ret;\r\nbool has_query42;\r\nbool has_lts;\r\nbool has_sensor_id;\r\nbool has_ds4_queries = false;\r\nbool has_build_id_query = false;\r\nbool has_package_id_query = false;\r\nu16 query_offset = data->f01.query_base_addr;\r\nu16 prod_info_addr;\r\nu8 ds4_query_len;\r\nret = rmi_read_block(hdev, query_offset, basic_queries,\r\nRMI_DEVICE_F01_BASIC_QUERY_LEN);\r\nif (ret) {\r\nhid_err(hdev, "Can not read basic queries from Function 0x1.\n");\r\nreturn ret;\r\n}\r\nhas_lts = !!(basic_queries[0] & BIT(2));\r\nhas_sensor_id = !!(basic_queries[1] & BIT(3));\r\nhas_query42 = !!(basic_queries[1] & BIT(7));\r\nquery_offset += 11;\r\nprod_info_addr = query_offset + 6;\r\nquery_offset += 10;\r\nif (has_lts)\r\nquery_offset += 20;\r\nif (has_sensor_id)\r\nquery_offset++;\r\nif (has_query42) {\r\nret = rmi_read(hdev, query_offset, info);\r\nif (ret) {\r\nhid_err(hdev, "Can not read query42.\n");\r\nreturn ret;\r\n}\r\nhas_ds4_queries = !!(info[0] & BIT(0));\r\nquery_offset++;\r\n}\r\nif (has_ds4_queries) {\r\nret = rmi_read(hdev, query_offset, &ds4_query_len);\r\nif (ret) {\r\nhid_err(hdev, "Can not read DS4 Query length.\n");\r\nreturn ret;\r\n}\r\nquery_offset++;\r\nif (ds4_query_len > 0) {\r\nret = rmi_read(hdev, query_offset, info);\r\nif (ret) {\r\nhid_err(hdev, "Can not read DS4 query.\n");\r\nreturn ret;\r\n}\r\nhas_package_id_query = !!(info[0] & BIT(0));\r\nhas_build_id_query = !!(info[0] & BIT(1));\r\n}\r\n}\r\nif (has_package_id_query)\r\nprod_info_addr++;\r\nif (has_build_id_query) {\r\nret = rmi_read_block(hdev, prod_info_addr, info, 3);\r\nif (ret) {\r\nhid_err(hdev, "Can not read product info.\n");\r\nreturn ret;\r\n}\r\ndata->firmware_id = info[1] << 8 | info[0];\r\ndata->firmware_id += info[2] * 65536;\r\n}\r\nret = rmi_read_block(hdev, data->f01.control_base_addr, info,\r\n2);\r\nif (ret) {\r\nhid_err(hdev, "can not read f01 ctrl registers\n");\r\nreturn ret;\r\n}\r\ndata->f01_ctrl0 = info[0];\r\nif (!info[1]) {\r\ndata->restore_interrupt_mask = true;\r\nret = rmi_write(hdev, data->f01.control_base_addr + 1,\r\n&data->interrupt_enable_mask);\r\nif (ret) {\r\nhid_err(hdev, "can not write to control reg 1: %d.\n",\r\nret);\r\nreturn ret;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int rmi_populate_f11(struct hid_device *hdev)\r\n{\r\nstruct rmi_data *data = hid_get_drvdata(hdev);\r\nu8 buf[20];\r\nint ret;\r\nbool has_query9;\r\nbool has_query10 = false;\r\nbool has_query11;\r\nbool has_query12;\r\nbool has_query27;\r\nbool has_query28;\r\nbool has_query36 = false;\r\nbool has_physical_props;\r\nbool has_gestures;\r\nbool has_rel;\r\nbool has_data40 = false;\r\nbool has_dribble = false;\r\nbool has_palm_detect = false;\r\nunsigned x_size, y_size;\r\nu16 query_offset;\r\nif (!data->f11.query_base_addr) {\r\nhid_err(hdev, "No 2D sensor found, giving up.\n");\r\nreturn -ENODEV;\r\n}\r\nret = rmi_read(hdev, data->f11.query_base_addr, buf);\r\nif (ret) {\r\nhid_err(hdev, "can not get query 0: %d.\n", ret);\r\nreturn ret;\r\n}\r\nhas_query9 = !!(buf[0] & BIT(3));\r\nhas_query11 = !!(buf[0] & BIT(4));\r\nhas_query12 = !!(buf[0] & BIT(5));\r\nhas_query27 = !!(buf[0] & BIT(6));\r\nhas_query28 = !!(buf[0] & BIT(7));\r\nret = rmi_read(hdev, data->f11.query_base_addr + 1, buf);\r\nif (ret) {\r\nhid_err(hdev, "can not get NumberOfFingers: %d.\n", ret);\r\nreturn ret;\r\n}\r\ndata->max_fingers = (buf[0] & 0x07) + 1;\r\nif (data->max_fingers > 5)\r\ndata->max_fingers = 10;\r\ndata->f11.report_size = data->max_fingers * 5 +\r\nDIV_ROUND_UP(data->max_fingers, 4);\r\nif (!(buf[0] & BIT(4))) {\r\nhid_err(hdev, "No absolute events, giving up.\n");\r\nreturn -ENODEV;\r\n}\r\nhas_rel = !!(buf[0] & BIT(3));\r\nhas_gestures = !!(buf[0] & BIT(5));\r\nret = rmi_read(hdev, data->f11.query_base_addr + 5, buf);\r\nif (ret) {\r\nhid_err(hdev, "can not get absolute data sources: %d.\n", ret);\r\nreturn ret;\r\n}\r\nhas_dribble = !!(buf[0] & BIT(4));\r\nquery_offset = 6;\r\nif (has_rel)\r\n++query_offset;\r\nif (has_gestures) {\r\nret = rmi_read(hdev,\r\ndata->f11.query_base_addr + query_offset + 1, buf);\r\nif (ret) {\r\nhid_err(hdev, "can not read gesture information: %d.\n",\r\nret);\r\nreturn ret;\r\n}\r\nhas_palm_detect = !!(buf[0] & BIT(0));\r\nhas_query10 = !!(buf[0] & BIT(2));\r\nquery_offset += 2;\r\n}\r\nif (has_query9)\r\n++query_offset;\r\nif (has_query10)\r\n++query_offset;\r\nif (has_query11)\r\n++query_offset;\r\nif (has_query12) {\r\nret = rmi_read(hdev, data->f11.query_base_addr\r\n+ query_offset, buf);\r\nif (ret) {\r\nhid_err(hdev, "can not get query 12: %d.\n", ret);\r\nreturn ret;\r\n}\r\nhas_physical_props = !!(buf[0] & BIT(5));\r\nif (has_physical_props) {\r\nquery_offset += 1;\r\nret = rmi_read_block(hdev,\r\ndata->f11.query_base_addr\r\n+ query_offset, buf, 4);\r\nif (ret) {\r\nhid_err(hdev, "can not read query 15-18: %d.\n",\r\nret);\r\nreturn ret;\r\n}\r\nx_size = buf[0] | (buf[1] << 8);\r\ny_size = buf[2] | (buf[3] << 8);\r\ndata->x_size_mm = DIV_ROUND_CLOSEST(x_size, 10);\r\ndata->y_size_mm = DIV_ROUND_CLOSEST(y_size, 10);\r\nhid_info(hdev, "%s: size in mm: %d x %d\n",\r\n__func__, data->x_size_mm, data->y_size_mm);\r\nquery_offset += 12;\r\n}\r\n}\r\nif (has_query27)\r\n++query_offset;\r\nif (has_query28) {\r\nret = rmi_read(hdev, data->f11.query_base_addr\r\n+ query_offset, buf);\r\nif (ret) {\r\nhid_err(hdev, "can not get query 28: %d.\n", ret);\r\nreturn ret;\r\n}\r\nhas_query36 = !!(buf[0] & BIT(6));\r\n}\r\nif (has_query36) {\r\nquery_offset += 2;\r\nret = rmi_read(hdev, data->f11.query_base_addr\r\n+ query_offset, buf);\r\nif (ret) {\r\nhid_err(hdev, "can not get query 36: %d.\n", ret);\r\nreturn ret;\r\n}\r\nhas_data40 = !!(buf[0] & BIT(5));\r\n}\r\nif (has_data40)\r\ndata->f11.report_size += data->max_fingers * 2;\r\nret = rmi_read_block(hdev, data->f11.control_base_addr,\r\ndata->f11_ctrl_regs, RMI_F11_CTRL_REG_COUNT);\r\nif (ret) {\r\nhid_err(hdev, "can not read ctrl block of size 11: %d.\n", ret);\r\nreturn ret;\r\n}\r\ndata->read_f11_ctrl_regs = true;\r\ndata->max_x = data->f11_ctrl_regs[6] | (data->f11_ctrl_regs[7] << 8);\r\ndata->max_y = data->f11_ctrl_regs[8] | (data->f11_ctrl_regs[9] << 8);\r\nif (has_dribble) {\r\ndata->f11_ctrl_regs[0] = data->f11_ctrl_regs[0] & ~BIT(6);\r\nret = rmi_write(hdev, data->f11.control_base_addr,\r\ndata->f11_ctrl_regs);\r\nif (ret) {\r\nhid_err(hdev, "can not write to control reg 0: %d.\n",\r\nret);\r\nreturn ret;\r\n}\r\n}\r\nif (has_palm_detect) {\r\ndata->f11_ctrl_regs[11] = data->f11_ctrl_regs[11] & ~BIT(0);\r\nret = rmi_write(hdev, data->f11.control_base_addr + 11,\r\n&data->f11_ctrl_regs[11]);\r\nif (ret) {\r\nhid_err(hdev, "can not write to control reg 11: %d.\n",\r\nret);\r\nreturn ret;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int rmi_populate_f30(struct hid_device *hdev)\r\n{\r\nstruct rmi_data *data = hid_get_drvdata(hdev);\r\nu8 buf[20];\r\nint ret;\r\nbool has_gpio, has_led;\r\nunsigned bytes_per_ctrl;\r\nu8 ctrl2_addr;\r\nint ctrl2_3_length;\r\nint i;\r\nif (!data->f30.query_base_addr) {\r\nhid_err(hdev, "No GPIO/LEDs found, giving up.\n");\r\nreturn -ENODEV;\r\n}\r\nret = rmi_read_block(hdev, data->f30.query_base_addr, buf, 2);\r\nif (ret) {\r\nhid_err(hdev, "can not get F30 query registers: %d.\n", ret);\r\nreturn ret;\r\n}\r\nhas_gpio = !!(buf[0] & BIT(3));\r\nhas_led = !!(buf[0] & BIT(2));\r\ndata->gpio_led_count = buf[1] & 0x1f;\r\nbytes_per_ctrl = (data->gpio_led_count + 7) / 8;\r\nctrl2_addr = (has_gpio && has_led) ? bytes_per_ctrl : 0;\r\nctrl2_addr += bytes_per_ctrl;\r\nctrl2_3_length = 2 * bytes_per_ctrl;\r\ndata->f30.report_size = bytes_per_ctrl;\r\nret = rmi_read_block(hdev, data->f30.control_base_addr + ctrl2_addr,\r\nbuf, ctrl2_3_length);\r\nif (ret) {\r\nhid_err(hdev, "can not read ctrl 2&3 block of size %d: %d.\n",\r\nctrl2_3_length, ret);\r\nreturn ret;\r\n}\r\nfor (i = 0; i < data->gpio_led_count; i++) {\r\nint byte_position = i >> 3;\r\nint bit_position = i & 0x07;\r\nu8 dir_byte = buf[byte_position];\r\nu8 data_byte = buf[byte_position + bytes_per_ctrl];\r\nbool dir = (dir_byte >> bit_position) & BIT(0);\r\nbool dat = (data_byte >> bit_position) & BIT(0);\r\nif (dir == 0) {\r\nif (dat) {\r\ndata->button_count++;\r\nset_bit(i, &data->button_mask);\r\nset_bit(i, &data->button_state_mask);\r\n}\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int rmi_populate(struct hid_device *hdev)\r\n{\r\nstruct rmi_data *data = hid_get_drvdata(hdev);\r\nint ret;\r\nret = rmi_scan_pdt(hdev);\r\nif (ret) {\r\nhid_err(hdev, "PDT scan failed with code %d.\n", ret);\r\nreturn ret;\r\n}\r\nret = rmi_populate_f01(hdev);\r\nif (ret) {\r\nhid_err(hdev, "Error while initializing F01 (%d).\n", ret);\r\nreturn ret;\r\n}\r\nret = rmi_populate_f11(hdev);\r\nif (ret) {\r\nhid_err(hdev, "Error while initializing F11 (%d).\n", ret);\r\nreturn ret;\r\n}\r\nif (!(data->device_flags & RMI_DEVICE_HAS_PHYS_BUTTONS)) {\r\nret = rmi_populate_f30(hdev);\r\nif (ret)\r\nhid_warn(hdev, "Error while initializing F30 (%d).\n", ret);\r\n}\r\nreturn 0;\r\n}\r\nstatic int rmi_input_configured(struct hid_device *hdev, struct hid_input *hi)\r\n{\r\nstruct rmi_data *data = hid_get_drvdata(hdev);\r\nstruct input_dev *input = hi->input;\r\nint ret;\r\nint res_x, res_y, i;\r\ndata->input = input;\r\nhid_dbg(hdev, "Opening low level driver\n");\r\nret = hid_hw_open(hdev);\r\nif (ret)\r\nreturn ret;\r\nif (!(data->device_flags & RMI_DEVICE))\r\nreturn 0;\r\nhid_device_io_start(hdev);\r\nret = rmi_set_mode(hdev, RMI_MODE_ATTN_REPORTS);\r\nif (ret < 0) {\r\ndev_err(&hdev->dev, "failed to set rmi mode\n");\r\ngoto exit;\r\n}\r\nret = rmi_set_page(hdev, 0);\r\nif (ret < 0) {\r\ndev_err(&hdev->dev, "failed to set page select to 0.\n");\r\ngoto exit;\r\n}\r\nret = rmi_populate(hdev);\r\nif (ret)\r\ngoto exit;\r\nhid_info(hdev, "firmware id: %ld\n", data->firmware_id);\r\n__set_bit(EV_ABS, input->evbit);\r\ninput_set_abs_params(input, ABS_MT_POSITION_X, 1, data->max_x, 0, 0);\r\ninput_set_abs_params(input, ABS_MT_POSITION_Y, 1, data->max_y, 0, 0);\r\nif (data->x_size_mm && data->y_size_mm) {\r\nres_x = (data->max_x - 1) / data->x_size_mm;\r\nres_y = (data->max_y - 1) / data->y_size_mm;\r\ninput_abs_set_res(input, ABS_MT_POSITION_X, res_x);\r\ninput_abs_set_res(input, ABS_MT_POSITION_Y, res_y);\r\n}\r\ninput_set_abs_params(input, ABS_MT_ORIENTATION, 0, 1, 0, 0);\r\ninput_set_abs_params(input, ABS_MT_PRESSURE, 0, 0xff, 0, 0);\r\ninput_set_abs_params(input, ABS_MT_TOUCH_MAJOR, 0, 0x0f, 0, 0);\r\ninput_set_abs_params(input, ABS_MT_TOUCH_MINOR, 0, 0x0f, 0, 0);\r\nret = input_mt_init_slots(input, data->max_fingers, INPUT_MT_POINTER);\r\nif (ret < 0)\r\ngoto exit;\r\nif (data->button_count) {\r\n__set_bit(EV_KEY, input->evbit);\r\nfor (i = 0; i < data->button_count; i++)\r\n__set_bit(BTN_LEFT + i, input->keybit);\r\nif (data->button_count == 1)\r\n__set_bit(INPUT_PROP_BUTTONPAD, input->propbit);\r\n}\r\nset_bit(RMI_STARTED, &data->flags);\r\nexit:\r\nhid_device_io_stop(hdev);\r\nhid_hw_close(hdev);\r\nreturn ret;\r\n}\r\nstatic int rmi_input_mapping(struct hid_device *hdev,\r\nstruct hid_input *hi, struct hid_field *field,\r\nstruct hid_usage *usage, unsigned long **bit, int *max)\r\n{\r\nstruct rmi_data *data = hid_get_drvdata(hdev);\r\nif (data->device_flags & RMI_DEVICE) {\r\nif ((data->device_flags & RMI_DEVICE_HAS_PHYS_BUTTONS) &&\r\n((usage->hid & HID_USAGE_PAGE) == HID_UP_BUTTON))\r\nreturn 0;\r\nreturn -1;\r\n}\r\nreturn 0;\r\n}\r\nstatic int rmi_check_valid_report_id(struct hid_device *hdev, unsigned type,\r\nunsigned id, struct hid_report **report)\r\n{\r\nint i;\r\n*report = hdev->report_enum[type].report_id_hash[id];\r\nif (*report) {\r\nfor (i = 0; i < (*report)->maxfield; i++) {\r\nunsigned app = (*report)->field[i]->application;\r\nif ((app & HID_USAGE_PAGE) >= HID_UP_MSVENDOR)\r\nreturn 1;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int rmi_probe(struct hid_device *hdev, const struct hid_device_id *id)\r\n{\r\nstruct rmi_data *data = NULL;\r\nint ret;\r\nsize_t alloc_size;\r\nstruct hid_report *input_report;\r\nstruct hid_report *output_report;\r\nstruct hid_report *feature_report;\r\ndata = devm_kzalloc(&hdev->dev, sizeof(struct rmi_data), GFP_KERNEL);\r\nif (!data)\r\nreturn -ENOMEM;\r\nINIT_WORK(&data->reset_work, rmi_reset_work);\r\ndata->hdev = hdev;\r\nhid_set_drvdata(hdev, data);\r\nhdev->quirks |= HID_QUIRK_NO_INIT_REPORTS;\r\nret = hid_parse(hdev);\r\nif (ret) {\r\nhid_err(hdev, "parse failed\n");\r\nreturn ret;\r\n}\r\nif (id->driver_data)\r\ndata->device_flags = id->driver_data;\r\nif (!rmi_check_valid_report_id(hdev, HID_FEATURE_REPORT,\r\nRMI_SET_RMI_MODE_REPORT_ID, &feature_report)) {\r\nhid_dbg(hdev, "device does not have set mode feature report\n");\r\ngoto start;\r\n}\r\nif (!rmi_check_valid_report_id(hdev, HID_INPUT_REPORT,\r\nRMI_ATTN_REPORT_ID, &input_report)) {\r\nhid_dbg(hdev, "device does not have attention input report\n");\r\ngoto start;\r\n}\r\ndata->input_report_size = hid_report_len(input_report);\r\nif (!rmi_check_valid_report_id(hdev, HID_OUTPUT_REPORT,\r\nRMI_WRITE_REPORT_ID, &output_report)) {\r\nhid_dbg(hdev,\r\n"device does not have rmi write output report\n");\r\ngoto start;\r\n}\r\ndata->output_report_size = hid_report_len(output_report);\r\ndata->device_flags |= RMI_DEVICE;\r\nalloc_size = data->output_report_size + data->input_report_size;\r\ndata->writeReport = devm_kzalloc(&hdev->dev, alloc_size, GFP_KERNEL);\r\nif (!data->writeReport) {\r\nret = -ENOMEM;\r\nreturn ret;\r\n}\r\ndata->readReport = data->writeReport + data->output_report_size;\r\ninit_waitqueue_head(&data->wait);\r\nmutex_init(&data->page_mutex);\r\nstart:\r\nret = hid_hw_start(hdev, HID_CONNECT_DEFAULT);\r\nif (ret) {\r\nhid_err(hdev, "hw start failed\n");\r\nreturn ret;\r\n}\r\nif ((data->device_flags & RMI_DEVICE) &&\r\n!test_bit(RMI_STARTED, &data->flags))\r\nhid_err(hdev, "Device failed to be properly configured\n");\r\nreturn 0;\r\n}\r\nstatic void rmi_remove(struct hid_device *hdev)\r\n{\r\nstruct rmi_data *hdata = hid_get_drvdata(hdev);\r\nclear_bit(RMI_STARTED, &hdata->flags);\r\nhid_hw_stop(hdev);\r\n}
