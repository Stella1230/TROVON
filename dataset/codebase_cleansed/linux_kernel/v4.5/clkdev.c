static struct clk *__of_clk_get(struct device_node *np, int index,\r\nconst char *dev_id, const char *con_id)\r\n{\r\nstruct of_phandle_args clkspec;\r\nstruct clk *clk;\r\nint rc;\r\nif (index < 0)\r\nreturn ERR_PTR(-EINVAL);\r\nrc = of_parse_phandle_with_args(np, "clocks", "#clock-cells", index,\r\n&clkspec);\r\nif (rc)\r\nreturn ERR_PTR(rc);\r\nclk = __of_clk_get_from_provider(&clkspec, dev_id, con_id);\r\nof_node_put(clkspec.np);\r\nreturn clk;\r\n}\r\nstruct clk *of_clk_get(struct device_node *np, int index)\r\n{\r\nreturn __of_clk_get(np, index, np->full_name, NULL);\r\n}\r\nstatic struct clk *__of_clk_get_by_name(struct device_node *np,\r\nconst char *dev_id,\r\nconst char *name)\r\n{\r\nstruct clk *clk = ERR_PTR(-ENOENT);\r\nwhile (np) {\r\nint index = 0;\r\nif (name)\r\nindex = of_property_match_string(np, "clock-names", name);\r\nclk = __of_clk_get(np, index, dev_id, name);\r\nif (!IS_ERR(clk)) {\r\nbreak;\r\n} else if (name && index >= 0) {\r\nif (PTR_ERR(clk) != -EPROBE_DEFER)\r\npr_err("ERROR: could not get clock %s:%s(%i)\n",\r\nnp->full_name, name ? name : "", index);\r\nreturn clk;\r\n}\r\nnp = np->parent;\r\nif (np && !of_get_property(np, "clock-ranges", NULL))\r\nbreak;\r\n}\r\nreturn clk;\r\n}\r\nstruct clk *of_clk_get_by_name(struct device_node *np, const char *name)\r\n{\r\nif (!np)\r\nreturn ERR_PTR(-ENOENT);\r\nreturn __of_clk_get_by_name(np, np->full_name, name);\r\n}\r\nstatic struct clk *__of_clk_get_by_name(struct device_node *np,\r\nconst char *dev_id,\r\nconst char *name)\r\n{\r\nreturn ERR_PTR(-ENOENT);\r\n}\r\nstatic struct clk_lookup *clk_find(const char *dev_id, const char *con_id)\r\n{\r\nstruct clk_lookup *p, *cl = NULL;\r\nint match, best_found = 0, best_possible = 0;\r\nif (dev_id)\r\nbest_possible += 2;\r\nif (con_id)\r\nbest_possible += 1;\r\nlist_for_each_entry(p, &clocks, node) {\r\nmatch = 0;\r\nif (p->dev_id) {\r\nif (!dev_id || strcmp(p->dev_id, dev_id))\r\ncontinue;\r\nmatch += 2;\r\n}\r\nif (p->con_id) {\r\nif (!con_id || strcmp(p->con_id, con_id))\r\ncontinue;\r\nmatch += 1;\r\n}\r\nif (match > best_found) {\r\ncl = p;\r\nif (match != best_possible)\r\nbest_found = match;\r\nelse\r\nbreak;\r\n}\r\n}\r\nreturn cl;\r\n}\r\nstruct clk *clk_get_sys(const char *dev_id, const char *con_id)\r\n{\r\nstruct clk_lookup *cl;\r\nstruct clk *clk = NULL;\r\nmutex_lock(&clocks_mutex);\r\ncl = clk_find(dev_id, con_id);\r\nif (!cl)\r\ngoto out;\r\nclk = __clk_create_clk(cl->clk_hw, dev_id, con_id);\r\nif (IS_ERR(clk))\r\ngoto out;\r\nif (!__clk_get(clk)) {\r\n__clk_free_clk(clk);\r\ncl = NULL;\r\ngoto out;\r\n}\r\nout:\r\nmutex_unlock(&clocks_mutex);\r\nreturn cl ? clk : ERR_PTR(-ENOENT);\r\n}\r\nstruct clk *clk_get(struct device *dev, const char *con_id)\r\n{\r\nconst char *dev_id = dev ? dev_name(dev) : NULL;\r\nstruct clk *clk;\r\nif (dev) {\r\nclk = __of_clk_get_by_name(dev->of_node, dev_id, con_id);\r\nif (!IS_ERR(clk) || PTR_ERR(clk) == -EPROBE_DEFER)\r\nreturn clk;\r\n}\r\nreturn clk_get_sys(dev_id, con_id);\r\n}\r\nvoid clk_put(struct clk *clk)\r\n{\r\n__clk_put(clk);\r\n}\r\nstatic void __clkdev_add(struct clk_lookup *cl)\r\n{\r\nmutex_lock(&clocks_mutex);\r\nlist_add_tail(&cl->node, &clocks);\r\nmutex_unlock(&clocks_mutex);\r\n}\r\nvoid clkdev_add(struct clk_lookup *cl)\r\n{\r\nif (!cl->clk_hw)\r\ncl->clk_hw = __clk_get_hw(cl->clk);\r\n__clkdev_add(cl);\r\n}\r\nvoid clkdev_add_table(struct clk_lookup *cl, size_t num)\r\n{\r\nmutex_lock(&clocks_mutex);\r\nwhile (num--) {\r\ncl->clk_hw = __clk_get_hw(cl->clk);\r\nlist_add_tail(&cl->node, &clocks);\r\ncl++;\r\n}\r\nmutex_unlock(&clocks_mutex);\r\n}\r\nstatic struct clk_lookup * __init_refok\r\nvclkdev_alloc(struct clk_hw *hw, const char *con_id, const char *dev_fmt,\r\nva_list ap)\r\n{\r\nstruct clk_lookup_alloc *cla;\r\ncla = __clkdev_alloc(sizeof(*cla));\r\nif (!cla)\r\nreturn NULL;\r\ncla->cl.clk_hw = hw;\r\nif (con_id) {\r\nstrlcpy(cla->con_id, con_id, sizeof(cla->con_id));\r\ncla->cl.con_id = cla->con_id;\r\n}\r\nif (dev_fmt) {\r\nvscnprintf(cla->dev_id, sizeof(cla->dev_id), dev_fmt, ap);\r\ncla->cl.dev_id = cla->dev_id;\r\n}\r\nreturn &cla->cl;\r\n}\r\nstatic struct clk_lookup *\r\nvclkdev_create(struct clk_hw *hw, const char *con_id, const char *dev_fmt,\r\nva_list ap)\r\n{\r\nstruct clk_lookup *cl;\r\ncl = vclkdev_alloc(hw, con_id, dev_fmt, ap);\r\nif (cl)\r\n__clkdev_add(cl);\r\nreturn cl;\r\n}\r\nstruct clk_lookup * __init_refok\r\nclkdev_alloc(struct clk *clk, const char *con_id, const char *dev_fmt, ...)\r\n{\r\nstruct clk_lookup *cl;\r\nva_list ap;\r\nva_start(ap, dev_fmt);\r\ncl = vclkdev_alloc(__clk_get_hw(clk), con_id, dev_fmt, ap);\r\nva_end(ap);\r\nreturn cl;\r\n}\r\nstruct clk_lookup *clkdev_create(struct clk *clk, const char *con_id,\r\nconst char *dev_fmt, ...)\r\n{\r\nstruct clk_lookup *cl;\r\nva_list ap;\r\nva_start(ap, dev_fmt);\r\ncl = vclkdev_create(__clk_get_hw(clk), con_id, dev_fmt, ap);\r\nva_end(ap);\r\nreturn cl;\r\n}\r\nint clk_add_alias(const char *alias, const char *alias_dev_name,\r\nconst char *con_id, struct device *dev)\r\n{\r\nstruct clk *r = clk_get(dev, con_id);\r\nstruct clk_lookup *l;\r\nif (IS_ERR(r))\r\nreturn PTR_ERR(r);\r\nl = clkdev_create(r, alias, alias_dev_name ? "%s" : NULL,\r\nalias_dev_name);\r\nclk_put(r);\r\nreturn l ? 0 : -ENODEV;\r\n}\r\nvoid clkdev_drop(struct clk_lookup *cl)\r\n{\r\nmutex_lock(&clocks_mutex);\r\nlist_del(&cl->node);\r\nmutex_unlock(&clocks_mutex);\r\nkfree(cl);\r\n}\r\nint clk_register_clkdev(struct clk *clk, const char *con_id,\r\nconst char *dev_fmt, ...)\r\n{\r\nstruct clk_lookup *cl;\r\nva_list ap;\r\nif (IS_ERR(clk))\r\nreturn PTR_ERR(clk);\r\nva_start(ap, dev_fmt);\r\ncl = vclkdev_create(__clk_get_hw(clk), con_id, dev_fmt, ap);\r\nva_end(ap);\r\nreturn cl ? 0 : -ENOMEM;\r\n}\r\nint clk_register_clkdevs(struct clk *clk, struct clk_lookup *cl, size_t num)\r\n{\r\nunsigned i;\r\nif (IS_ERR(clk))\r\nreturn PTR_ERR(clk);\r\nfor (i = 0; i < num; i++, cl++) {\r\ncl->clk_hw = __clk_get_hw(clk);\r\n__clkdev_add(cl);\r\n}\r\nreturn 0;\r\n}
