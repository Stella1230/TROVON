static void acpi_processor_notify(acpi_handle handle, u32 event, void *data)\r\n{\r\nstruct acpi_device *device = data;\r\nstruct acpi_processor *pr;\r\nint saved;\r\nif (device->handle != handle)\r\nreturn;\r\npr = acpi_driver_data(device);\r\nif (!pr)\r\nreturn;\r\nswitch (event) {\r\ncase ACPI_PROCESSOR_NOTIFY_PERFORMANCE:\r\nsaved = pr->performance_platform_limit;\r\nacpi_processor_ppc_has_changed(pr, 1);\r\nif (saved == pr->performance_platform_limit)\r\nbreak;\r\nacpi_bus_generate_netlink_event(device->pnp.device_class,\r\ndev_name(&device->dev), event,\r\npr->performance_platform_limit);\r\nbreak;\r\ncase ACPI_PROCESSOR_NOTIFY_POWER:\r\nacpi_processor_cst_has_changed(pr);\r\nacpi_bus_generate_netlink_event(device->pnp.device_class,\r\ndev_name(&device->dev), event, 0);\r\nbreak;\r\ncase ACPI_PROCESSOR_NOTIFY_THROTTLING:\r\nacpi_processor_tstate_has_changed(pr);\r\nacpi_bus_generate_netlink_event(device->pnp.device_class,\r\ndev_name(&device->dev), event, 0);\r\nbreak;\r\ndefault:\r\nACPI_DEBUG_PRINT((ACPI_DB_INFO,\r\n"Unsupported event [0x%x]\n", event));\r\nbreak;\r\n}\r\nreturn;\r\n}\r\nstatic int acpi_cpu_soft_notify(struct notifier_block *nfb,\r\nunsigned long action, void *hcpu)\r\n{\r\nunsigned int cpu = (unsigned long)hcpu;\r\nstruct acpi_processor *pr = per_cpu(processors, cpu);\r\nstruct acpi_device *device;\r\naction &= ~CPU_TASKS_FROZEN;\r\nif (action == CPU_STARTING || action == CPU_DYING)\r\nreturn NOTIFY_DONE;\r\nif (!pr || acpi_bus_get_device(pr->handle, &device))\r\nreturn NOTIFY_DONE;\r\nif (action == CPU_ONLINE) {\r\nif (pr->flags.need_hotplug_init) {\r\nint ret;\r\npr_info("Will online and init hotplugged CPU: %d\n",\r\npr->id);\r\npr->flags.need_hotplug_init = 0;\r\nret = __acpi_processor_start(device);\r\nWARN(ret, "Failed to start CPU: %d\n", pr->id);\r\n} else {\r\nacpi_processor_ppc_has_changed(pr, 0);\r\nacpi_processor_hotplug(pr);\r\nacpi_processor_reevaluate_tstate(pr, action);\r\nacpi_processor_tstate_has_changed(pr);\r\n}\r\n} else if (action == CPU_DEAD) {\r\nacpi_processor_reevaluate_tstate(pr, action);\r\n}\r\nreturn NOTIFY_OK;\r\n}\r\nstatic int acpi_pss_perf_init(struct acpi_processor *pr,\r\nstruct acpi_device *device)\r\n{\r\nint result = 0;\r\nacpi_processor_ppc_has_changed(pr, 0);\r\nacpi_processor_get_throttling_info(pr);\r\nif (pr->flags.throttling)\r\npr->flags.limit = 1;\r\npr->cdev = thermal_cooling_device_register("Processor", device,\r\n&processor_cooling_ops);\r\nif (IS_ERR(pr->cdev)) {\r\nresult = PTR_ERR(pr->cdev);\r\nreturn result;\r\n}\r\ndev_dbg(&device->dev, "registered as cooling_device%d\n",\r\npr->cdev->id);\r\nresult = sysfs_create_link(&device->dev.kobj,\r\n&pr->cdev->device.kobj,\r\n"thermal_cooling");\r\nif (result) {\r\ndev_err(&device->dev,\r\n"Failed to create sysfs link 'thermal_cooling'\n");\r\ngoto err_thermal_unregister;\r\n}\r\nresult = sysfs_create_link(&pr->cdev->device.kobj,\r\n&device->dev.kobj,\r\n"device");\r\nif (result) {\r\ndev_err(&pr->cdev->device,\r\n"Failed to create sysfs link 'device'\n");\r\ngoto err_remove_sysfs_thermal;\r\n}\r\nreturn 0;\r\nerr_remove_sysfs_thermal:\r\nsysfs_remove_link(&device->dev.kobj, "thermal_cooling");\r\nerr_thermal_unregister:\r\nthermal_cooling_device_unregister(pr->cdev);\r\nreturn result;\r\n}\r\nstatic void acpi_pss_perf_exit(struct acpi_processor *pr,\r\nstruct acpi_device *device)\r\n{\r\nif (pr->cdev) {\r\nsysfs_remove_link(&device->dev.kobj, "thermal_cooling");\r\nsysfs_remove_link(&pr->cdev->device.kobj, "device");\r\nthermal_cooling_device_unregister(pr->cdev);\r\npr->cdev = NULL;\r\n}\r\n}\r\nstatic inline int acpi_pss_perf_init(struct acpi_processor *pr,\r\nstruct acpi_device *device)\r\n{\r\nreturn 0;\r\n}\r\nstatic inline void acpi_pss_perf_exit(struct acpi_processor *pr,\r\nstruct acpi_device *device) {}\r\nstatic int __acpi_processor_start(struct acpi_device *device)\r\n{\r\nstruct acpi_processor *pr = acpi_driver_data(device);\r\nacpi_status status;\r\nint result = 0;\r\nif (!pr)\r\nreturn -ENODEV;\r\nif (pr->flags.need_hotplug_init)\r\nreturn 0;\r\nresult = acpi_cppc_processor_probe(pr);\r\nif (result)\r\nreturn -ENODEV;\r\nif (!cpuidle_get_driver() || cpuidle_get_driver() == &acpi_idle_driver)\r\nacpi_processor_power_init(pr);\r\nresult = acpi_pss_perf_init(pr, device);\r\nif (result)\r\ngoto err_power_exit;\r\nstatus = acpi_install_notify_handler(device->handle, ACPI_DEVICE_NOTIFY,\r\nacpi_processor_notify, device);\r\nif (ACPI_SUCCESS(status))\r\nreturn 0;\r\nerr_power_exit:\r\nacpi_processor_power_exit(pr);\r\nreturn result;\r\n}\r\nstatic int acpi_processor_start(struct device *dev)\r\n{\r\nstruct acpi_device *device = ACPI_COMPANION(dev);\r\nif (!device)\r\nreturn -ENODEV;\r\nreturn __acpi_processor_start(device);\r\n}\r\nstatic int acpi_processor_stop(struct device *dev)\r\n{\r\nstruct acpi_device *device = ACPI_COMPANION(dev);\r\nstruct acpi_processor *pr;\r\nif (!device)\r\nreturn 0;\r\nacpi_remove_notify_handler(device->handle, ACPI_DEVICE_NOTIFY,\r\nacpi_processor_notify);\r\npr = acpi_driver_data(device);\r\nif (!pr)\r\nreturn 0;\r\nacpi_processor_power_exit(pr);\r\nacpi_pss_perf_exit(pr, device);\r\nacpi_cppc_processor_exit(pr);\r\nreturn 0;\r\n}\r\nstatic int __init acpi_processor_driver_init(void)\r\n{\r\nint result = 0;\r\nif (acpi_disabled)\r\nreturn 0;\r\nresult = driver_register(&acpi_processor_driver);\r\nif (result < 0)\r\nreturn result;\r\nacpi_processor_syscore_init();\r\nregister_hotcpu_notifier(&acpi_cpu_notifier);\r\nacpi_thermal_cpufreq_init();\r\nacpi_processor_ppc_init();\r\nacpi_processor_throttling_init();\r\nreturn 0;\r\n}\r\nstatic void __exit acpi_processor_driver_exit(void)\r\n{\r\nif (acpi_disabled)\r\nreturn;\r\nacpi_processor_ppc_exit();\r\nacpi_thermal_cpufreq_exit();\r\nunregister_hotcpu_notifier(&acpi_cpu_notifier);\r\nacpi_processor_syscore_exit();\r\ndriver_unregister(&acpi_processor_driver);\r\n}
