static int w1_therm_add_slave(struct w1_slave *sl)\r\n{\r\nsl->family_data = kzalloc(sizeof(struct w1_therm_family_data),\r\nGFP_KERNEL);\r\nif (!sl->family_data)\r\nreturn -ENOMEM;\r\natomic_set(THERM_REFCNT(sl->family_data), 1);\r\nreturn 0;\r\n}\r\nstatic void w1_therm_remove_slave(struct w1_slave *sl)\r\n{\r\nint refcnt = atomic_sub_return(1, THERM_REFCNT(sl->family_data));\r\nwhile(refcnt) {\r\nmsleep(1000);\r\nrefcnt = atomic_read(THERM_REFCNT(sl->family_data));\r\n}\r\nkfree(sl->family_data);\r\nsl->family_data = NULL;\r\n}\r\nstatic inline int w1_DS18B20_convert_temp(u8 rom[9])\r\n{\r\ns16 t = le16_to_cpup((__le16 *)rom);\r\nreturn t*1000/16;\r\n}\r\nstatic inline int w1_DS18S20_convert_temp(u8 rom[9])\r\n{\r\nint t, h;\r\nif (!rom[7])\r\nreturn 0;\r\nif (rom[1] == 0)\r\nt = ((s32)rom[0] >> 1)*1000;\r\nelse\r\nt = 1000*(-1*(s32)(0x100-rom[0]) >> 1);\r\nt -= 250;\r\nh = 1000*((s32)rom[7] - (s32)rom[6]);\r\nh /= (s32)rom[7];\r\nt += h;\r\nreturn t;\r\n}\r\nstatic inline int w1_convert_temp(u8 rom[9], u8 fid)\r\n{\r\nint i;\r\nfor (i = 0; i < ARRAY_SIZE(w1_therm_families); ++i)\r\nif (w1_therm_families[i].f->fid == fid)\r\nreturn w1_therm_families[i].convert(rom);\r\nreturn 0;\r\n}\r\nstatic ssize_t w1_slave_show(struct device *device,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct w1_slave *sl = dev_to_w1_slave(device);\r\nstruct w1_master *dev = sl->master;\r\nu8 rom[9], crc, verdict, external_power;\r\nint i, ret, max_trying = 10;\r\nssize_t c = PAGE_SIZE;\r\nu8 *family_data = sl->family_data;\r\nret = mutex_lock_interruptible(&dev->bus_mutex);\r\nif (ret != 0)\r\ngoto post_unlock;\r\nif(!sl->family_data)\r\n{\r\nret = -ENODEV;\r\ngoto pre_unlock;\r\n}\r\natomic_inc(THERM_REFCNT(family_data));\r\nmemset(rom, 0, sizeof(rom));\r\nwhile (max_trying--) {\r\nverdict = 0;\r\ncrc = 0;\r\nif (!w1_reset_select_slave(sl)) {\r\nint count = 0;\r\nunsigned int tm = 750;\r\nunsigned long sleep_rem;\r\nw1_write_8(dev, W1_READ_PSUPPLY);\r\nexternal_power = w1_read_8(dev);\r\nif (w1_reset_select_slave(sl))\r\ncontinue;\r\nif (w1_strong_pullup == 2 ||\r\n(!external_power && w1_strong_pullup))\r\nw1_next_pullup(dev, tm);\r\nw1_write_8(dev, W1_CONVERT_TEMP);\r\nif (external_power) {\r\nmutex_unlock(&dev->bus_mutex);\r\nsleep_rem = msleep_interruptible(tm);\r\nif (sleep_rem != 0) {\r\nret = -EINTR;\r\ngoto post_unlock;\r\n}\r\nret = mutex_lock_interruptible(&dev->bus_mutex);\r\nif (ret != 0)\r\ngoto post_unlock;\r\n} else if (!w1_strong_pullup) {\r\nsleep_rem = msleep_interruptible(tm);\r\nif (sleep_rem != 0) {\r\nret = -EINTR;\r\ngoto pre_unlock;\r\n}\r\n}\r\nif (!w1_reset_select_slave(sl)) {\r\nw1_write_8(dev, W1_READ_SCRATCHPAD);\r\nif ((count = w1_read_block(dev, rom, 9)) != 9) {\r\ndev_warn(device, "w1_read_block() "\r\n"returned %u instead of 9.\n",\r\ncount);\r\n}\r\ncrc = w1_calc_crc8(rom, 8);\r\nif (rom[8] == crc)\r\nverdict = 1;\r\n}\r\n}\r\nif (verdict)\r\nbreak;\r\n}\r\nfor (i = 0; i < 9; ++i)\r\nc -= snprintf(buf + PAGE_SIZE - c, c, "%02x ", rom[i]);\r\nc -= snprintf(buf + PAGE_SIZE - c, c, ": crc=%02x %s\n",\r\ncrc, (verdict) ? "YES" : "NO");\r\nif (verdict)\r\nmemcpy(family_data, rom, sizeof(rom));\r\nelse\r\ndev_warn(device, "Read failed CRC check\n");\r\nfor (i = 0; i < 9; ++i)\r\nc -= snprintf(buf + PAGE_SIZE - c, c, "%02x ",\r\n((u8 *)family_data)[i]);\r\nc -= snprintf(buf + PAGE_SIZE - c, c, "t=%d\n",\r\nw1_convert_temp(rom, sl->family->fid));\r\nret = PAGE_SIZE - c;\r\npre_unlock:\r\nmutex_unlock(&dev->bus_mutex);\r\npost_unlock:\r\natomic_dec(THERM_REFCNT(family_data));\r\nreturn ret;\r\n}\r\nstatic ssize_t w1_seq_show(struct device *device,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct w1_slave *sl = dev_to_w1_slave(device);\r\nssize_t c = PAGE_SIZE;\r\nint rv;\r\nint i;\r\nu8 ack;\r\nu64 rn;\r\nstruct w1_reg_num *reg_num;\r\nint seq = 0;\r\nmutex_lock(&sl->master->bus_mutex);\r\nif (w1_reset_bus(sl->master))\r\ngoto error;\r\nw1_write_8(sl->master, W1_SKIP_ROM);\r\nw1_write_8(sl->master, W1_42_CHAIN);\r\nw1_write_8(sl->master, W1_42_CHAIN_ON);\r\nw1_write_8(sl->master, W1_42_CHAIN_ON_INV);\r\nmsleep(sl->master->pullup_duration);\r\nack = w1_read_8(sl->master);\r\nif (ack != W1_42_SUCCESS_CONFIRM_BYTE)\r\ngoto error;\r\nfor (i = 0; i <= 64; i++) {\r\nif (w1_reset_bus(sl->master))\r\ngoto error;\r\nw1_write_8(sl->master, W1_42_COND_READ);\r\nrv = w1_read_block(sl->master, (u8 *)&rn, 8);\r\nreg_num = (struct w1_reg_num *) &rn;\r\nif (reg_num->family == W1_42_FINISHED_BYTE)\r\nbreak;\r\nif (sl->reg_num.id == reg_num->id)\r\nseq = i;\r\nw1_write_8(sl->master, W1_42_CHAIN);\r\nw1_write_8(sl->master, W1_42_CHAIN_DONE);\r\nw1_write_8(sl->master, W1_42_CHAIN_DONE_INV);\r\nw1_read_block(sl->master, &ack, sizeof(ack));\r\nack = w1_read_8(sl->master);\r\nif (ack != W1_42_SUCCESS_CONFIRM_BYTE)\r\ngoto error;\r\n}\r\nif (w1_reset_bus(sl->master))\r\ngoto error;\r\nw1_write_8(sl->master, W1_SKIP_ROM);\r\nw1_write_8(sl->master, W1_42_CHAIN);\r\nw1_write_8(sl->master, W1_42_CHAIN_OFF);\r\nw1_write_8(sl->master, W1_42_CHAIN_OFF_INV);\r\nack = w1_read_8(sl->master);\r\nif (ack != W1_42_SUCCESS_CONFIRM_BYTE)\r\ngoto error;\r\nmutex_unlock(&sl->master->bus_mutex);\r\nc -= snprintf(buf + PAGE_SIZE - c, c, "%d\n", seq);\r\nreturn PAGE_SIZE - c;\r\nerror:\r\nmutex_unlock(&sl->master->bus_mutex);\r\nreturn -EIO;\r\n}\r\nstatic int __init w1_therm_init(void)\r\n{\r\nint err, i;\r\nfor (i = 0; i < ARRAY_SIZE(w1_therm_families); ++i) {\r\nerr = w1_register_family(w1_therm_families[i].f);\r\nif (err)\r\nw1_therm_families[i].broken = 1;\r\n}\r\nreturn 0;\r\n}\r\nstatic void __exit w1_therm_fini(void)\r\n{\r\nint i;\r\nfor (i = 0; i < ARRAY_SIZE(w1_therm_families); ++i)\r\nif (!w1_therm_families[i].broken)\r\nw1_unregister_family(w1_therm_families[i].f);\r\n}
