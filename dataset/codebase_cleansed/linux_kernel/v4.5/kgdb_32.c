void pt_regs_to_gdb_regs(unsigned long *gdb_regs, struct pt_regs *regs)\r\n{\r\nstruct reg_window32 *win;\r\nint i;\r\ngdb_regs[GDB_G0] = 0;\r\nfor (i = 0; i < 15; i++)\r\ngdb_regs[GDB_G1 + i] = regs->u_regs[UREG_G1 + i];\r\nwin = (struct reg_window32 *) regs->u_regs[UREG_FP];\r\nfor (i = 0; i < 8; i++)\r\ngdb_regs[GDB_L0 + i] = win->locals[i];\r\nfor (i = 0; i < 8; i++)\r\ngdb_regs[GDB_I0 + i] = win->ins[i];\r\nfor (i = GDB_F0; i <= GDB_F31; i++)\r\ngdb_regs[i] = 0;\r\ngdb_regs[GDB_Y] = regs->y;\r\ngdb_regs[GDB_PSR] = regs->psr;\r\ngdb_regs[GDB_WIM] = 0;\r\ngdb_regs[GDB_TBR] = (unsigned long) &trapbase;\r\ngdb_regs[GDB_PC] = regs->pc;\r\ngdb_regs[GDB_NPC] = regs->npc;\r\ngdb_regs[GDB_FSR] = 0;\r\ngdb_regs[GDB_CSR] = 0;\r\n}\r\nvoid sleeping_thread_to_gdb_regs(unsigned long *gdb_regs, struct task_struct *p)\r\n{\r\nstruct thread_info *t = task_thread_info(p);\r\nstruct reg_window32 *win;\r\nint i;\r\nfor (i = GDB_G0; i < GDB_G6; i++)\r\ngdb_regs[i] = 0;\r\ngdb_regs[GDB_G6] = (unsigned long) t;\r\ngdb_regs[GDB_G7] = 0;\r\nfor (i = GDB_O0; i < GDB_SP; i++)\r\ngdb_regs[i] = 0;\r\ngdb_regs[GDB_SP] = t->ksp;\r\ngdb_regs[GDB_O7] = 0;\r\nwin = (struct reg_window32 *) t->ksp;\r\nfor (i = 0; i < 8; i++)\r\ngdb_regs[GDB_L0 + i] = win->locals[i];\r\nfor (i = 0; i < 8; i++)\r\ngdb_regs[GDB_I0 + i] = win->ins[i];\r\nfor (i = GDB_F0; i <= GDB_F31; i++)\r\ngdb_regs[i] = 0;\r\ngdb_regs[GDB_Y] = 0;\r\ngdb_regs[GDB_PSR] = t->kpsr;\r\ngdb_regs[GDB_WIM] = t->kwim;\r\ngdb_regs[GDB_TBR] = (unsigned long) &trapbase;\r\ngdb_regs[GDB_PC] = t->kpc;\r\ngdb_regs[GDB_NPC] = t->kpc + 4;\r\ngdb_regs[GDB_FSR] = 0;\r\ngdb_regs[GDB_CSR] = 0;\r\n}\r\nvoid gdb_regs_to_pt_regs(unsigned long *gdb_regs, struct pt_regs *regs)\r\n{\r\nstruct reg_window32 *win;\r\nint i;\r\nfor (i = 0; i < 15; i++)\r\nregs->u_regs[UREG_G1 + i] = gdb_regs[GDB_G1 + i];\r\nif (regs->psr != gdb_regs[GDB_PSR]) {\r\nunsigned long cwp = regs->psr & PSR_CWP;\r\nregs->psr = (gdb_regs[GDB_PSR] & ~PSR_CWP) | cwp;\r\n}\r\nregs->pc = gdb_regs[GDB_PC];\r\nregs->npc = gdb_regs[GDB_NPC];\r\nregs->y = gdb_regs[GDB_Y];\r\nwin = (struct reg_window32 *) regs->u_regs[UREG_FP];\r\nfor (i = 0; i < 8; i++)\r\nwin->locals[i] = gdb_regs[GDB_L0 + i];\r\nfor (i = 0; i < 8; i++)\r\nwin->ins[i] = gdb_regs[GDB_I0 + i];\r\n}\r\nint kgdb_arch_handle_exception(int e_vector, int signo, int err_code,\r\nchar *remcomInBuffer, char *remcomOutBuffer,\r\nstruct pt_regs *linux_regs)\r\n{\r\nunsigned long addr;\r\nchar *ptr;\r\nswitch (remcomInBuffer[0]) {\r\ncase 'c':\r\nptr = &remcomInBuffer[1];\r\nif (kgdb_hex2long(&ptr, &addr)) {\r\nlinux_regs->pc = addr;\r\nlinux_regs->npc = addr + 4;\r\n}\r\ncase 'D':\r\ncase 'k':\r\nif (linux_regs->pc == (unsigned long) arch_kgdb_breakpoint) {\r\nlinux_regs->pc = linux_regs->npc;\r\nlinux_regs->npc += 4;\r\n}\r\nreturn 0;\r\n}\r\nreturn -1;\r\n}\r\nasmlinkage void kgdb_trap(struct pt_regs *regs)\r\n{\r\nunsigned long flags;\r\nif (user_mode(regs)) {\r\ndo_hw_interrupt(regs, 0xfd);\r\nreturn;\r\n}\r\nflushw_all();\r\nlocal_irq_save(flags);\r\nkgdb_handle_exception(0x172, SIGTRAP, 0, regs);\r\nlocal_irq_restore(flags);\r\n}\r\nint kgdb_arch_init(void)\r\n{\r\nreturn 0;\r\n}\r\nvoid kgdb_arch_exit(void)\r\n{\r\n}\r\nvoid kgdb_arch_set_pc(struct pt_regs *regs, unsigned long ip)\r\n{\r\nregs->pc = ip;\r\nregs->npc = regs->pc + 4;\r\n}
