static void salsa20_wordtobyte(u8 output[64], const u32 input[16])\r\n{\r\nu32 x[16];\r\nint i;\r\nmemcpy(x, input, sizeof(x));\r\nfor (i = 20; i > 0; i -= 2) {\r\nx[ 4] ^= rol32((x[ 0] + x[12]), 7);\r\nx[ 8] ^= rol32((x[ 4] + x[ 0]), 9);\r\nx[12] ^= rol32((x[ 8] + x[ 4]), 13);\r\nx[ 0] ^= rol32((x[12] + x[ 8]), 18);\r\nx[ 9] ^= rol32((x[ 5] + x[ 1]), 7);\r\nx[13] ^= rol32((x[ 9] + x[ 5]), 9);\r\nx[ 1] ^= rol32((x[13] + x[ 9]), 13);\r\nx[ 5] ^= rol32((x[ 1] + x[13]), 18);\r\nx[14] ^= rol32((x[10] + x[ 6]), 7);\r\nx[ 2] ^= rol32((x[14] + x[10]), 9);\r\nx[ 6] ^= rol32((x[ 2] + x[14]), 13);\r\nx[10] ^= rol32((x[ 6] + x[ 2]), 18);\r\nx[ 3] ^= rol32((x[15] + x[11]), 7);\r\nx[ 7] ^= rol32((x[ 3] + x[15]), 9);\r\nx[11] ^= rol32((x[ 7] + x[ 3]), 13);\r\nx[15] ^= rol32((x[11] + x[ 7]), 18);\r\nx[ 1] ^= rol32((x[ 0] + x[ 3]), 7);\r\nx[ 2] ^= rol32((x[ 1] + x[ 0]), 9);\r\nx[ 3] ^= rol32((x[ 2] + x[ 1]), 13);\r\nx[ 0] ^= rol32((x[ 3] + x[ 2]), 18);\r\nx[ 6] ^= rol32((x[ 5] + x[ 4]), 7);\r\nx[ 7] ^= rol32((x[ 6] + x[ 5]), 9);\r\nx[ 4] ^= rol32((x[ 7] + x[ 6]), 13);\r\nx[ 5] ^= rol32((x[ 4] + x[ 7]), 18);\r\nx[11] ^= rol32((x[10] + x[ 9]), 7);\r\nx[ 8] ^= rol32((x[11] + x[10]), 9);\r\nx[ 9] ^= rol32((x[ 8] + x[11]), 13);\r\nx[10] ^= rol32((x[ 9] + x[ 8]), 18);\r\nx[12] ^= rol32((x[15] + x[14]), 7);\r\nx[13] ^= rol32((x[12] + x[15]), 9);\r\nx[14] ^= rol32((x[13] + x[12]), 13);\r\nx[15] ^= rol32((x[14] + x[13]), 18);\r\n}\r\nfor (i = 0; i < 16; ++i)\r\nx[i] += input[i];\r\nfor (i = 0; i < 16; ++i)\r\nU32TO8_LITTLE(output + 4 * i,x[i]);\r\n}\r\nstatic void salsa20_keysetup(struct salsa20_ctx *ctx, const u8 *k, u32 kbytes)\r\n{\r\nconst char *constants;\r\nctx->input[1] = U8TO32_LITTLE(k + 0);\r\nctx->input[2] = U8TO32_LITTLE(k + 4);\r\nctx->input[3] = U8TO32_LITTLE(k + 8);\r\nctx->input[4] = U8TO32_LITTLE(k + 12);\r\nif (kbytes == 32) {\r\nk += 16;\r\nconstants = sigma;\r\n} else {\r\nconstants = tau;\r\n}\r\nctx->input[11] = U8TO32_LITTLE(k + 0);\r\nctx->input[12] = U8TO32_LITTLE(k + 4);\r\nctx->input[13] = U8TO32_LITTLE(k + 8);\r\nctx->input[14] = U8TO32_LITTLE(k + 12);\r\nctx->input[0] = U8TO32_LITTLE(constants + 0);\r\nctx->input[5] = U8TO32_LITTLE(constants + 4);\r\nctx->input[10] = U8TO32_LITTLE(constants + 8);\r\nctx->input[15] = U8TO32_LITTLE(constants + 12);\r\n}\r\nstatic void salsa20_ivsetup(struct salsa20_ctx *ctx, const u8 *iv)\r\n{\r\nctx->input[6] = U8TO32_LITTLE(iv + 0);\r\nctx->input[7] = U8TO32_LITTLE(iv + 4);\r\nctx->input[8] = 0;\r\nctx->input[9] = 0;\r\n}\r\nstatic void salsa20_encrypt_bytes(struct salsa20_ctx *ctx, u8 *dst,\r\nconst u8 *src, unsigned int bytes)\r\n{\r\nu8 buf[64];\r\nif (dst != src)\r\nmemcpy(dst, src, bytes);\r\nwhile (bytes) {\r\nsalsa20_wordtobyte(buf, ctx->input);\r\nctx->input[8]++;\r\nif (!ctx->input[8])\r\nctx->input[9]++;\r\nif (bytes <= 64) {\r\ncrypto_xor(dst, buf, bytes);\r\nreturn;\r\n}\r\ncrypto_xor(dst, buf, 64);\r\nbytes -= 64;\r\ndst += 64;\r\n}\r\n}\r\nstatic int setkey(struct crypto_tfm *tfm, const u8 *key,\r\nunsigned int keysize)\r\n{\r\nstruct salsa20_ctx *ctx = crypto_tfm_ctx(tfm);\r\nsalsa20_keysetup(ctx, key, keysize);\r\nreturn 0;\r\n}\r\nstatic int encrypt(struct blkcipher_desc *desc,\r\nstruct scatterlist *dst, struct scatterlist *src,\r\nunsigned int nbytes)\r\n{\r\nstruct blkcipher_walk walk;\r\nstruct crypto_blkcipher *tfm = desc->tfm;\r\nstruct salsa20_ctx *ctx = crypto_blkcipher_ctx(tfm);\r\nint err;\r\nblkcipher_walk_init(&walk, dst, src, nbytes);\r\nerr = blkcipher_walk_virt_block(desc, &walk, 64);\r\nsalsa20_ivsetup(ctx, walk.iv);\r\nif (likely(walk.nbytes == nbytes))\r\n{\r\nsalsa20_encrypt_bytes(ctx, walk.dst.virt.addr,\r\nwalk.src.virt.addr, nbytes);\r\nreturn blkcipher_walk_done(desc, &walk, 0);\r\n}\r\nwhile (walk.nbytes >= 64) {\r\nsalsa20_encrypt_bytes(ctx, walk.dst.virt.addr,\r\nwalk.src.virt.addr,\r\nwalk.nbytes - (walk.nbytes % 64));\r\nerr = blkcipher_walk_done(desc, &walk, walk.nbytes % 64);\r\n}\r\nif (walk.nbytes) {\r\nsalsa20_encrypt_bytes(ctx, walk.dst.virt.addr,\r\nwalk.src.virt.addr, walk.nbytes);\r\nerr = blkcipher_walk_done(desc, &walk, 0);\r\n}\r\nreturn err;\r\n}\r\nstatic int __init salsa20_generic_mod_init(void)\r\n{\r\nreturn crypto_register_alg(&alg);\r\n}\r\nstatic void __exit salsa20_generic_mod_fini(void)\r\n{\r\ncrypto_unregister_alg(&alg);\r\n}
