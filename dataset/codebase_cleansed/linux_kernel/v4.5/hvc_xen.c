static struct xencons_info *vtermno_to_xencons(int vtermno)\r\n{\r\nstruct xencons_info *entry, *n, *ret = NULL;\r\nif (list_empty(&xenconsoles))\r\nreturn NULL;\r\nlist_for_each_entry_safe(entry, n, &xenconsoles, list) {\r\nif (entry->vtermno == vtermno) {\r\nret = entry;\r\nbreak;\r\n}\r\n}\r\nreturn ret;\r\n}\r\nstatic inline int xenbus_devid_to_vtermno(int devid)\r\n{\r\nreturn devid + HVC_COOKIE;\r\n}\r\nstatic inline void notify_daemon(struct xencons_info *cons)\r\n{\r\nnotify_remote_via_evtchn(cons->evtchn);\r\n}\r\nstatic int __write_console(struct xencons_info *xencons,\r\nconst char *data, int len)\r\n{\r\nXENCONS_RING_IDX cons, prod;\r\nstruct xencons_interface *intf = xencons->intf;\r\nint sent = 0;\r\ncons = intf->out_cons;\r\nprod = intf->out_prod;\r\nmb();\r\nBUG_ON((prod - cons) > sizeof(intf->out));\r\nwhile ((sent < len) && ((prod - cons) < sizeof(intf->out)))\r\nintf->out[MASK_XENCONS_IDX(prod++, intf->out)] = data[sent++];\r\nwmb();\r\nintf->out_prod = prod;\r\nif (sent)\r\nnotify_daemon(xencons);\r\nreturn sent;\r\n}\r\nstatic int domU_write_console(uint32_t vtermno, const char *data, int len)\r\n{\r\nint ret = len;\r\nstruct xencons_info *cons = vtermno_to_xencons(vtermno);\r\nif (cons == NULL)\r\nreturn -EINVAL;\r\nwhile (len) {\r\nint sent = __write_console(cons, data, len);\r\ndata += sent;\r\nlen -= sent;\r\nif (unlikely(len))\r\nHYPERVISOR_sched_op(SCHEDOP_yield, NULL);\r\n}\r\nreturn ret;\r\n}\r\nstatic int domU_read_console(uint32_t vtermno, char *buf, int len)\r\n{\r\nstruct xencons_interface *intf;\r\nXENCONS_RING_IDX cons, prod;\r\nint recv = 0;\r\nstruct xencons_info *xencons = vtermno_to_xencons(vtermno);\r\nif (xencons == NULL)\r\nreturn -EINVAL;\r\nintf = xencons->intf;\r\ncons = intf->in_cons;\r\nprod = intf->in_prod;\r\nmb();\r\nBUG_ON((prod - cons) > sizeof(intf->in));\r\nwhile (cons != prod && recv < len)\r\nbuf[recv++] = intf->in[MASK_XENCONS_IDX(cons++, intf->in)];\r\nmb();\r\nintf->in_cons = cons;\r\nnotify_daemon(xencons);\r\nreturn recv;\r\n}\r\nstatic int dom0_read_console(uint32_t vtermno, char *buf, int len)\r\n{\r\nreturn HYPERVISOR_console_io(CONSOLEIO_read, len, buf);\r\n}\r\nstatic int dom0_write_console(uint32_t vtermno, const char *str, int len)\r\n{\r\nint rc = HYPERVISOR_console_io(CONSOLEIO_write, len, (char *)str);\r\nif (rc < 0)\r\nreturn rc;\r\nreturn len;\r\n}\r\nstatic int xen_hvm_console_init(void)\r\n{\r\nint r;\r\nuint64_t v = 0;\r\nunsigned long gfn;\r\nstruct xencons_info *info;\r\nif (!xen_hvm_domain())\r\nreturn -ENODEV;\r\ninfo = vtermno_to_xencons(HVC_COOKIE);\r\nif (!info) {\r\ninfo = kzalloc(sizeof(struct xencons_info), GFP_KERNEL);\r\nif (!info)\r\nreturn -ENOMEM;\r\n} else if (info->intf != NULL) {\r\nreturn 0;\r\n}\r\nr = hvm_get_parameter(HVM_PARAM_CONSOLE_EVTCHN, &v);\r\nif (r < 0 || v == 0)\r\ngoto err;\r\ninfo->evtchn = v;\r\nv = 0;\r\nr = hvm_get_parameter(HVM_PARAM_CONSOLE_PFN, &v);\r\nif (r < 0 || v == 0)\r\ngoto err;\r\ngfn = v;\r\ninfo->intf = xen_remap(gfn << XEN_PAGE_SHIFT, XEN_PAGE_SIZE);\r\nif (info->intf == NULL)\r\ngoto err;\r\ninfo->vtermno = HVC_COOKIE;\r\nspin_lock(&xencons_lock);\r\nlist_add_tail(&info->list, &xenconsoles);\r\nspin_unlock(&xencons_lock);\r\nreturn 0;\r\nerr:\r\nkfree(info);\r\nreturn -ENODEV;\r\n}\r\nstatic int xen_pv_console_init(void)\r\n{\r\nstruct xencons_info *info;\r\nif (!xen_pv_domain())\r\nreturn -ENODEV;\r\nif (!xen_start_info->console.domU.evtchn)\r\nreturn -ENODEV;\r\ninfo = vtermno_to_xencons(HVC_COOKIE);\r\nif (!info) {\r\ninfo = kzalloc(sizeof(struct xencons_info), GFP_KERNEL);\r\nif (!info)\r\nreturn -ENOMEM;\r\n} else if (info->intf != NULL) {\r\nreturn 0;\r\n}\r\ninfo->evtchn = xen_start_info->console.domU.evtchn;\r\ninfo->intf = gfn_to_virt(xen_start_info->console.domU.mfn);\r\ninfo->vtermno = HVC_COOKIE;\r\nspin_lock(&xencons_lock);\r\nlist_add_tail(&info->list, &xenconsoles);\r\nspin_unlock(&xencons_lock);\r\nreturn 0;\r\n}\r\nstatic int xen_initial_domain_console_init(void)\r\n{\r\nstruct xencons_info *info;\r\nif (!xen_initial_domain())\r\nreturn -ENODEV;\r\ninfo = vtermno_to_xencons(HVC_COOKIE);\r\nif (!info) {\r\ninfo = kzalloc(sizeof(struct xencons_info), GFP_KERNEL);\r\nif (!info)\r\nreturn -ENOMEM;\r\n}\r\ninfo->irq = bind_virq_to_irq(VIRQ_CONSOLE, 0, false);\r\ninfo->vtermno = HVC_COOKIE;\r\nspin_lock(&xencons_lock);\r\nlist_add_tail(&info->list, &xenconsoles);\r\nspin_unlock(&xencons_lock);\r\nreturn 0;\r\n}\r\nstatic void xen_console_update_evtchn(struct xencons_info *info)\r\n{\r\nif (xen_hvm_domain()) {\r\nuint64_t v = 0;\r\nint err;\r\nerr = hvm_get_parameter(HVM_PARAM_CONSOLE_EVTCHN, &v);\r\nif (!err && v)\r\ninfo->evtchn = v;\r\n} else\r\ninfo->evtchn = xen_start_info->console.domU.evtchn;\r\n}\r\nvoid xen_console_resume(void)\r\n{\r\nstruct xencons_info *info = vtermno_to_xencons(HVC_COOKIE);\r\nif (info != NULL && info->irq) {\r\nif (!xen_initial_domain())\r\nxen_console_update_evtchn(info);\r\nrebind_evtchn_irq(info->evtchn, info->irq);\r\n}\r\n}\r\nstatic void xencons_disconnect_backend(struct xencons_info *info)\r\n{\r\nif (info->irq > 0)\r\nunbind_from_irqhandler(info->irq, NULL);\r\ninfo->irq = 0;\r\nif (info->evtchn > 0)\r\nxenbus_free_evtchn(info->xbdev, info->evtchn);\r\ninfo->evtchn = 0;\r\nif (info->gntref > 0)\r\ngnttab_free_grant_references(info->gntref);\r\ninfo->gntref = 0;\r\nif (info->hvc != NULL)\r\nhvc_remove(info->hvc);\r\ninfo->hvc = NULL;\r\n}\r\nstatic void xencons_free(struct xencons_info *info)\r\n{\r\nfree_page((unsigned long)info->intf);\r\ninfo->intf = NULL;\r\ninfo->vtermno = 0;\r\nkfree(info);\r\n}\r\nstatic int xen_console_remove(struct xencons_info *info)\r\n{\r\nxencons_disconnect_backend(info);\r\nspin_lock(&xencons_lock);\r\nlist_del(&info->list);\r\nspin_unlock(&xencons_lock);\r\nif (info->xbdev != NULL)\r\nxencons_free(info);\r\nelse {\r\nif (xen_hvm_domain())\r\niounmap(info->intf);\r\nkfree(info);\r\n}\r\nreturn 0;\r\n}\r\nstatic int xencons_remove(struct xenbus_device *dev)\r\n{\r\nreturn xen_console_remove(dev_get_drvdata(&dev->dev));\r\n}\r\nstatic int xencons_connect_backend(struct xenbus_device *dev,\r\nstruct xencons_info *info)\r\n{\r\nint ret, evtchn, devid, ref, irq;\r\nstruct xenbus_transaction xbt;\r\ngrant_ref_t gref_head;\r\nret = xenbus_alloc_evtchn(dev, &evtchn);\r\nif (ret)\r\nreturn ret;\r\ninfo->evtchn = evtchn;\r\nirq = bind_evtchn_to_irq(evtchn);\r\nif (irq < 0)\r\nreturn irq;\r\ninfo->irq = irq;\r\ndevid = dev->nodename[strlen(dev->nodename) - 1] - '0';\r\ninfo->hvc = hvc_alloc(xenbus_devid_to_vtermno(devid),\r\nirq, &domU_hvc_ops, 256);\r\nif (IS_ERR(info->hvc))\r\nreturn PTR_ERR(info->hvc);\r\nret = gnttab_alloc_grant_references(1, &gref_head);\r\nif (ret < 0)\r\nreturn ret;\r\ninfo->gntref = gref_head;\r\nref = gnttab_claim_grant_reference(&gref_head);\r\nif (ref < 0)\r\nreturn ref;\r\ngnttab_grant_foreign_access_ref(ref, info->xbdev->otherend_id,\r\nvirt_to_gfn(info->intf), 0);\r\nagain:\r\nret = xenbus_transaction_start(&xbt);\r\nif (ret) {\r\nxenbus_dev_fatal(dev, ret, "starting transaction");\r\nreturn ret;\r\n}\r\nret = xenbus_printf(xbt, dev->nodename, "ring-ref", "%d", ref);\r\nif (ret)\r\ngoto error_xenbus;\r\nret = xenbus_printf(xbt, dev->nodename, "port", "%u",\r\nevtchn);\r\nif (ret)\r\ngoto error_xenbus;\r\nret = xenbus_transaction_end(xbt, 0);\r\nif (ret) {\r\nif (ret == -EAGAIN)\r\ngoto again;\r\nxenbus_dev_fatal(dev, ret, "completing transaction");\r\nreturn ret;\r\n}\r\nxenbus_switch_state(dev, XenbusStateInitialised);\r\nreturn 0;\r\nerror_xenbus:\r\nxenbus_transaction_end(xbt, 1);\r\nxenbus_dev_fatal(dev, ret, "writing xenstore");\r\nreturn ret;\r\n}\r\nstatic int xencons_probe(struct xenbus_device *dev,\r\nconst struct xenbus_device_id *id)\r\n{\r\nint ret, devid;\r\nstruct xencons_info *info;\r\ndevid = dev->nodename[strlen(dev->nodename) - 1] - '0';\r\nif (devid == 0)\r\nreturn -ENODEV;\r\ninfo = kzalloc(sizeof(struct xencons_info), GFP_KERNEL);\r\nif (!info)\r\nreturn -ENOMEM;\r\ndev_set_drvdata(&dev->dev, info);\r\ninfo->xbdev = dev;\r\ninfo->vtermno = xenbus_devid_to_vtermno(devid);\r\ninfo->intf = (void *)__get_free_page(GFP_KERNEL | __GFP_ZERO);\r\nif (!info->intf)\r\ngoto error_nomem;\r\nret = xencons_connect_backend(dev, info);\r\nif (ret < 0)\r\ngoto error;\r\nspin_lock(&xencons_lock);\r\nlist_add_tail(&info->list, &xenconsoles);\r\nspin_unlock(&xencons_lock);\r\nreturn 0;\r\nerror_nomem:\r\nret = -ENOMEM;\r\nxenbus_dev_fatal(dev, ret, "allocating device memory");\r\nerror:\r\nxencons_disconnect_backend(info);\r\nxencons_free(info);\r\nreturn ret;\r\n}\r\nstatic int xencons_resume(struct xenbus_device *dev)\r\n{\r\nstruct xencons_info *info = dev_get_drvdata(&dev->dev);\r\nxencons_disconnect_backend(info);\r\nmemset(info->intf, 0, XEN_PAGE_SIZE);\r\nreturn xencons_connect_backend(dev, info);\r\n}\r\nstatic void xencons_backend_changed(struct xenbus_device *dev,\r\nenum xenbus_state backend_state)\r\n{\r\nswitch (backend_state) {\r\ncase XenbusStateReconfiguring:\r\ncase XenbusStateReconfigured:\r\ncase XenbusStateInitialising:\r\ncase XenbusStateInitialised:\r\ncase XenbusStateUnknown:\r\nbreak;\r\ncase XenbusStateInitWait:\r\nbreak;\r\ncase XenbusStateConnected:\r\nxenbus_switch_state(dev, XenbusStateConnected);\r\nbreak;\r\ncase XenbusStateClosed:\r\nif (dev->state == XenbusStateClosed)\r\nbreak;\r\ncase XenbusStateClosing:\r\nxenbus_frontend_closed(dev);\r\nbreak;\r\n}\r\n}\r\nstatic int __init xen_hvc_init(void)\r\n{\r\nint r;\r\nstruct xencons_info *info;\r\nconst struct hv_ops *ops;\r\nif (!xen_domain())\r\nreturn -ENODEV;\r\nif (xen_initial_domain()) {\r\nops = &dom0_hvc_ops;\r\nr = xen_initial_domain_console_init();\r\nif (r < 0)\r\nreturn r;\r\ninfo = vtermno_to_xencons(HVC_COOKIE);\r\n} else {\r\nops = &domU_hvc_ops;\r\nif (xen_hvm_domain())\r\nr = xen_hvm_console_init();\r\nelse\r\nr = xen_pv_console_init();\r\nif (r < 0)\r\nreturn r;\r\ninfo = vtermno_to_xencons(HVC_COOKIE);\r\ninfo->irq = bind_evtchn_to_irq(info->evtchn);\r\n}\r\nif (info->irq < 0)\r\ninfo->irq = 0;\r\nelse\r\nirq_set_noprobe(info->irq);\r\ninfo->hvc = hvc_alloc(HVC_COOKIE, info->irq, ops, 256);\r\nif (IS_ERR(info->hvc)) {\r\nr = PTR_ERR(info->hvc);\r\nspin_lock(&xencons_lock);\r\nlist_del(&info->list);\r\nspin_unlock(&xencons_lock);\r\nif (info->irq)\r\nunbind_from_irqhandler(info->irq, NULL);\r\nkfree(info);\r\nreturn r;\r\n}\r\nr = 0;\r\n#ifdef CONFIG_HVC_XEN_FRONTEND\r\nr = xenbus_register_frontend(&xencons_driver);\r\n#endif\r\nreturn r;\r\n}\r\nstatic int xen_cons_init(void)\r\n{\r\nconst struct hv_ops *ops;\r\nif (!xen_domain())\r\nreturn 0;\r\nif (xen_initial_domain())\r\nops = &dom0_hvc_ops;\r\nelse {\r\nint r;\r\nops = &domU_hvc_ops;\r\nif (xen_hvm_domain())\r\nr = xen_hvm_console_init();\r\nelse\r\nr = xen_pv_console_init();\r\nif (r < 0)\r\nreturn r;\r\n}\r\nhvc_instantiate(HVC_COOKIE, 0, ops);\r\nreturn 0;\r\n}\r\nstatic void xenboot_write_console(struct console *console, const char *string,\r\nunsigned len)\r\n{\r\nunsigned int linelen, off = 0;\r\nconst char *pos;\r\nif (!xen_pv_domain())\r\nreturn;\r\ndom0_write_console(0, string, len);\r\nif (xen_initial_domain())\r\nreturn;\r\ndomU_write_console(0, "(early) ", 8);\r\nwhile (off < len && NULL != (pos = strchr(string+off, '\n'))) {\r\nlinelen = pos-string+off;\r\nif (off + linelen > len)\r\nbreak;\r\ndomU_write_console(0, string+off, linelen);\r\ndomU_write_console(0, "\r\n", 2);\r\noff += linelen + 1;\r\n}\r\nif (off < len)\r\ndomU_write_console(0, string+off, len-off);\r\n}\r\nvoid xen_raw_console_write(const char *str)\r\n{\r\nssize_t len = strlen(str);\r\nint rc = 0;\r\nif (xen_domain()) {\r\nrc = dom0_write_console(0, str, len);\r\n#ifdef CONFIG_X86\r\nif (rc == -ENOSYS && xen_hvm_domain())\r\ngoto outb_print;\r\n} else if (xen_cpuid_base()) {\r\nint i;\r\noutb_print:\r\nfor (i = 0; i < len; i++)\r\noutb(str[i], 0xe9);\r\n#endif\r\n}\r\n}\r\nvoid xen_raw_printk(const char *fmt, ...)\r\n{\r\nstatic char buf[512];\r\nva_list ap;\r\nva_start(ap, fmt);\r\nvsnprintf(buf, sizeof(buf), fmt, ap);\r\nva_end(ap);\r\nxen_raw_console_write(buf);\r\n}
