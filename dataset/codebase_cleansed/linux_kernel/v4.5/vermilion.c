static int vmlfb_alloc_vram_area(struct vram_area *va, unsigned max_order,\r\nunsigned min_order)\r\n{\r\ngfp_t flags;\r\nunsigned long i;\r\nmax_order++;\r\ndo {\r\nflags = __GFP_DMA | __GFP_HIGH | __GFP_KSWAPD_RECLAIM;\r\nva->logical =\r\n__get_free_pages(flags, --max_order);\r\n} while (va->logical == 0 && max_order > min_order);\r\nif (!va->logical)\r\nreturn -ENOMEM;\r\nva->phys = virt_to_phys((void *)va->logical);\r\nva->size = PAGE_SIZE << max_order;\r\nva->order = max_order;\r\nmemset((void *)va->logical, 0x00, va->size);\r\nfor (i = va->logical; i < va->logical + va->size; i += PAGE_SIZE) {\r\nget_page(virt_to_page(i));\r\n}\r\nset_pages_uc(virt_to_page(va->logical), va->size >> PAGE_SHIFT);\r\nprintk(KERN_DEBUG MODULE_NAME\r\n": Allocated %ld bytes vram area at 0x%08lx\n",\r\nva->size, va->phys);\r\nreturn 0;\r\n}\r\nstatic void vmlfb_free_vram_area(struct vram_area *va)\r\n{\r\nunsigned long j;\r\nif (va->logical) {\r\nset_pages_wb(virt_to_page(va->logical),\r\nva->size >> PAGE_SHIFT);\r\nfor (j = va->logical; j < va->logical + va->size;\r\nj += PAGE_SIZE) {\r\n(void)put_page_testzero(virt_to_page(j));\r\n}\r\nprintk(KERN_DEBUG MODULE_NAME\r\n": Freeing %ld bytes vram area at 0x%08lx\n",\r\nva->size, va->phys);\r\nfree_pages(va->logical, va->order);\r\nva->logical = 0;\r\n}\r\n}\r\nstatic void vmlfb_free_vram(struct vml_info *vinfo)\r\n{\r\nint i;\r\nfor (i = 0; i < vinfo->num_areas; ++i) {\r\nvmlfb_free_vram_area(&vinfo->vram[i]);\r\n}\r\nvinfo->num_areas = 0;\r\n}\r\nstatic int vmlfb_alloc_vram(struct vml_info *vinfo,\r\nsize_t requested,\r\nsize_t min_total, size_t min_contig)\r\n{\r\nint i, j;\r\nint order;\r\nint contiguous;\r\nint err;\r\nstruct vram_area *va;\r\nstruct vram_area *va2;\r\nvinfo->num_areas = 0;\r\nfor (i = 0; i < VML_VRAM_AREAS; ++i) {\r\nva = &vinfo->vram[i];\r\norder = 0;\r\nwhile (requested > (PAGE_SIZE << order) && order < MAX_ORDER)\r\norder++;\r\nerr = vmlfb_alloc_vram_area(va, order, 0);\r\nif (err)\r\nbreak;\r\nif (i == 0) {\r\nvinfo->vram_start = va->phys;\r\nvinfo->vram_logical = (void __iomem *) va->logical;\r\nvinfo->vram_contig_size = va->size;\r\nvinfo->num_areas = 1;\r\n} else {\r\ncontiguous = 0;\r\nfor (j = 0; j < i; ++j) {\r\nva2 = &vinfo->vram[j];\r\nif (va->phys + va->size == va2->phys ||\r\nva2->phys + va2->size == va->phys) {\r\ncontiguous = 1;\r\nbreak;\r\n}\r\n}\r\nif (contiguous) {\r\nvinfo->num_areas++;\r\nif (va->phys < vinfo->vram_start) {\r\nvinfo->vram_start = va->phys;\r\nvinfo->vram_logical =\r\n(void __iomem *)va->logical;\r\n}\r\nvinfo->vram_contig_size += va->size;\r\n} else {\r\nvmlfb_free_vram_area(va);\r\nbreak;\r\n}\r\n}\r\nif (requested < va->size)\r\nbreak;\r\nelse\r\nrequested -= va->size;\r\n}\r\nif (vinfo->vram_contig_size > min_total &&\r\nvinfo->vram_contig_size > min_contig) {\r\nprintk(KERN_DEBUG MODULE_NAME\r\n": Contiguous vram: %ld bytes at physical 0x%08lx.\n",\r\n(unsigned long)vinfo->vram_contig_size,\r\n(unsigned long)vinfo->vram_start);\r\nreturn 0;\r\n}\r\nprintk(KERN_ERR MODULE_NAME\r\n": Could not allocate requested minimal amount of vram.\n");\r\nvmlfb_free_vram(vinfo);\r\nreturn -ENOMEM;\r\n}\r\nstatic int vmlfb_get_gpu(struct vml_par *par)\r\n{\r\nmutex_lock(&vml_mutex);\r\npar->gpu = pci_get_device(PCI_VENDOR_ID_INTEL, VML_DEVICE_GPU, NULL);\r\nif (!par->gpu) {\r\nmutex_unlock(&vml_mutex);\r\nreturn -ENODEV;\r\n}\r\nmutex_unlock(&vml_mutex);\r\nif (pci_enable_device(par->gpu) < 0)\r\nreturn -ENODEV;\r\nreturn 0;\r\n}\r\nstatic int vmlfb_vram_offset(struct vml_info *vinfo, unsigned long offset)\r\n{\r\nunsigned long aoffset;\r\nunsigned i;\r\nfor (i = 0; i < vinfo->num_areas; ++i) {\r\naoffset = offset - (vinfo->vram[i].phys - vinfo->vram_start);\r\nif (aoffset < vinfo->vram[i].size) {\r\nreturn 0;\r\n}\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int vmlfb_enable_mmio(struct vml_par *par)\r\n{\r\nint err;\r\npar->vdc_mem_base = pci_resource_start(par->vdc, 0);\r\npar->vdc_mem_size = pci_resource_len(par->vdc, 0);\r\nif (!request_mem_region(par->vdc_mem_base, par->vdc_mem_size, "vmlfb")) {\r\nprintk(KERN_ERR MODULE_NAME\r\n": Could not claim display controller MMIO.\n");\r\nreturn -EBUSY;\r\n}\r\npar->vdc_mem = ioremap_nocache(par->vdc_mem_base, par->vdc_mem_size);\r\nif (par->vdc_mem == NULL) {\r\nprintk(KERN_ERR MODULE_NAME\r\n": Could not map display controller MMIO.\n");\r\nerr = -ENOMEM;\r\ngoto out_err_0;\r\n}\r\npar->gpu_mem_base = pci_resource_start(par->gpu, 0);\r\npar->gpu_mem_size = pci_resource_len(par->gpu, 0);\r\nif (!request_mem_region(par->gpu_mem_base, par->gpu_mem_size, "vmlfb")) {\r\nprintk(KERN_ERR MODULE_NAME ": Could not claim GPU MMIO.\n");\r\nerr = -EBUSY;\r\ngoto out_err_1;\r\n}\r\npar->gpu_mem = ioremap_nocache(par->gpu_mem_base, par->gpu_mem_size);\r\nif (par->gpu_mem == NULL) {\r\nprintk(KERN_ERR MODULE_NAME ": Could not map GPU MMIO.\n");\r\nerr = -ENOMEM;\r\ngoto out_err_2;\r\n}\r\nreturn 0;\r\nout_err_2:\r\nrelease_mem_region(par->gpu_mem_base, par->gpu_mem_size);\r\nout_err_1:\r\niounmap(par->vdc_mem);\r\nout_err_0:\r\nrelease_mem_region(par->vdc_mem_base, par->vdc_mem_size);\r\nreturn err;\r\n}\r\nstatic void vmlfb_disable_mmio(struct vml_par *par)\r\n{\r\niounmap(par->gpu_mem);\r\nrelease_mem_region(par->gpu_mem_base, par->gpu_mem_size);\r\niounmap(par->vdc_mem);\r\nrelease_mem_region(par->vdc_mem_base, par->vdc_mem_size);\r\n}\r\nstatic void vmlfb_release_devices(struct vml_par *par)\r\n{\r\nif (atomic_dec_and_test(&par->refcount)) {\r\npci_disable_device(par->gpu);\r\npci_disable_device(par->vdc);\r\n}\r\n}\r\nstatic void vml_pci_remove(struct pci_dev *dev)\r\n{\r\nstruct fb_info *info;\r\nstruct vml_info *vinfo;\r\nstruct vml_par *par;\r\ninfo = pci_get_drvdata(dev);\r\nif (info) {\r\nvinfo = container_of(info, struct vml_info, info);\r\npar = vinfo->par;\r\nmutex_lock(&vml_mutex);\r\nunregister_framebuffer(info);\r\nfb_dealloc_cmap(&info->cmap);\r\nvmlfb_free_vram(vinfo);\r\nvmlfb_disable_mmio(par);\r\nvmlfb_release_devices(par);\r\nkfree(vinfo);\r\nkfree(par);\r\nmutex_unlock(&vml_mutex);\r\n}\r\n}\r\nstatic void vmlfb_set_pref_pixel_format(struct fb_var_screeninfo *var)\r\n{\r\nswitch (var->bits_per_pixel) {\r\ncase 16:\r\nvar->blue.offset = 0;\r\nvar->blue.length = 5;\r\nvar->green.offset = 5;\r\nvar->green.length = 5;\r\nvar->red.offset = 10;\r\nvar->red.length = 5;\r\nvar->transp.offset = 15;\r\nvar->transp.length = 1;\r\nbreak;\r\ncase 32:\r\nvar->blue.offset = 0;\r\nvar->blue.length = 8;\r\nvar->green.offset = 8;\r\nvar->green.length = 8;\r\nvar->red.offset = 16;\r\nvar->red.length = 8;\r\nvar->transp.offset = 24;\r\nvar->transp.length = 0;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nvar->blue.msb_right = var->green.msb_right =\r\nvar->red.msb_right = var->transp.msb_right = 0;\r\n}\r\nstatic int vml_pci_probe(struct pci_dev *dev, const struct pci_device_id *id)\r\n{\r\nstruct vml_info *vinfo;\r\nstruct fb_info *info;\r\nstruct vml_par *par;\r\nint err = 0;\r\npar = kzalloc(sizeof(*par), GFP_KERNEL);\r\nif (par == NULL)\r\nreturn -ENOMEM;\r\nvinfo = kzalloc(sizeof(*vinfo), GFP_KERNEL);\r\nif (vinfo == NULL) {\r\nerr = -ENOMEM;\r\ngoto out_err_0;\r\n}\r\nvinfo->par = par;\r\npar->vdc = dev;\r\natomic_set(&par->refcount, 1);\r\nswitch (id->device) {\r\ncase VML_DEVICE_VDC:\r\nif ((err = vmlfb_get_gpu(par)))\r\ngoto out_err_1;\r\npci_set_drvdata(dev, &vinfo->info);\r\nbreak;\r\ndefault:\r\nerr = -ENODEV;\r\ngoto out_err_1;\r\n}\r\ninfo = &vinfo->info;\r\ninfo->flags = FBINFO_DEFAULT | FBINFO_PARTIAL_PAN_OK;\r\nerr = vmlfb_enable_mmio(par);\r\nif (err)\r\ngoto out_err_2;\r\nerr = vmlfb_alloc_vram(vinfo, vml_mem_requested,\r\nvml_mem_contig, vml_mem_min);\r\nif (err)\r\ngoto out_err_3;\r\nstrcpy(info->fix.id, "Vermilion Range");\r\ninfo->fix.mmio_start = 0;\r\ninfo->fix.mmio_len = 0;\r\ninfo->fix.smem_start = vinfo->vram_start;\r\ninfo->fix.smem_len = vinfo->vram_contig_size;\r\ninfo->fix.type = FB_TYPE_PACKED_PIXELS;\r\ninfo->fix.visual = FB_VISUAL_TRUECOLOR;\r\ninfo->fix.ypanstep = 1;\r\ninfo->fix.xpanstep = 1;\r\ninfo->fix.ywrapstep = 0;\r\ninfo->fix.accel = FB_ACCEL_NONE;\r\ninfo->screen_base = vinfo->vram_logical;\r\ninfo->pseudo_palette = vinfo->pseudo_palette;\r\ninfo->par = par;\r\ninfo->fbops = &vmlfb_ops;\r\ninfo->device = &dev->dev;\r\nINIT_LIST_HEAD(&vinfo->head);\r\nvinfo->pipe_disabled = 1;\r\nvinfo->cur_blank_mode = FB_BLANK_UNBLANK;\r\ninfo->var.grayscale = 0;\r\ninfo->var.bits_per_pixel = 16;\r\nvmlfb_set_pref_pixel_format(&info->var);\r\nif (!fb_find_mode\r\n(&info->var, info, vml_default_mode, NULL, 0, &defaultmode, 16)) {\r\nprintk(KERN_ERR MODULE_NAME ": Could not find initial mode\n");\r\n}\r\nif (fb_alloc_cmap(&info->cmap, 256, 1) < 0) {\r\nerr = -ENOMEM;\r\ngoto out_err_4;\r\n}\r\nerr = register_framebuffer(info);\r\nif (err) {\r\nprintk(KERN_ERR MODULE_NAME ": Register framebuffer error.\n");\r\ngoto out_err_5;\r\n}\r\nprintk("Initialized vmlfb\n");\r\nreturn 0;\r\nout_err_5:\r\nfb_dealloc_cmap(&info->cmap);\r\nout_err_4:\r\nvmlfb_free_vram(vinfo);\r\nout_err_3:\r\nvmlfb_disable_mmio(par);\r\nout_err_2:\r\nvmlfb_release_devices(par);\r\nout_err_1:\r\nkfree(vinfo);\r\nout_err_0:\r\nkfree(par);\r\nreturn err;\r\n}\r\nstatic int vmlfb_open(struct fb_info *info, int user)\r\n{\r\nreturn 0;\r\n}\r\nstatic int vmlfb_release(struct fb_info *info, int user)\r\n{\r\nreturn 0;\r\n}\r\nstatic int vml_nearest_clock(int clock)\r\n{\r\nint i;\r\nint cur_index;\r\nint cur_diff;\r\nint diff;\r\ncur_index = 0;\r\ncur_diff = clock - vml_clocks[0];\r\ncur_diff = (cur_diff < 0) ? -cur_diff : cur_diff;\r\nfor (i = 1; i < vml_num_clocks; ++i) {\r\ndiff = clock - vml_clocks[i];\r\ndiff = (diff < 0) ? -diff : diff;\r\nif (diff < cur_diff) {\r\ncur_index = i;\r\ncur_diff = diff;\r\n}\r\n}\r\nreturn vml_clocks[cur_index];\r\n}\r\nstatic int vmlfb_check_var_locked(struct fb_var_screeninfo *var,\r\nstruct vml_info *vinfo)\r\n{\r\nu32 pitch;\r\nu64 mem;\r\nint nearest_clock;\r\nint clock;\r\nint clock_diff;\r\nstruct fb_var_screeninfo v;\r\nv = *var;\r\nclock = PICOS2KHZ(var->pixclock);\r\nif (subsys && subsys->nearest_clock) {\r\nnearest_clock = subsys->nearest_clock(subsys, clock);\r\n} else {\r\nnearest_clock = vml_nearest_clock(clock);\r\n}\r\nclock_diff = nearest_clock - clock;\r\nclock_diff = (clock_diff < 0) ? -clock_diff : clock_diff;\r\nif (clock_diff > clock / 5) {\r\n#if 0\r\nprintk(KERN_DEBUG MODULE_NAME ": Diff failure. %d %d\n",clock_diff,clock);\r\n#endif\r\nreturn -EINVAL;\r\n}\r\nv.pixclock = KHZ2PICOS(nearest_clock);\r\nif (var->xres > VML_MAX_XRES || var->yres > VML_MAX_YRES) {\r\nprintk(KERN_DEBUG MODULE_NAME ": Resolution failure.\n");\r\nreturn -EINVAL;\r\n}\r\nif (var->xres_virtual > VML_MAX_XRES_VIRTUAL) {\r\nprintk(KERN_DEBUG MODULE_NAME\r\n": Virtual resolution failure.\n");\r\nreturn -EINVAL;\r\n}\r\nswitch (v.bits_per_pixel) {\r\ncase 0 ... 16:\r\nv.bits_per_pixel = 16;\r\nbreak;\r\ncase 17 ... 32:\r\nv.bits_per_pixel = 32;\r\nbreak;\r\ndefault:\r\nprintk(KERN_DEBUG MODULE_NAME ": Invalid bpp: %d.\n",\r\nvar->bits_per_pixel);\r\nreturn -EINVAL;\r\n}\r\npitch = ALIGN((var->xres * var->bits_per_pixel) >> 3, 0x40);\r\nmem = pitch * var->yres_virtual;\r\nif (mem > vinfo->vram_contig_size) {\r\nreturn -ENOMEM;\r\n}\r\nswitch (v.bits_per_pixel) {\r\ncase 16:\r\nif (var->blue.offset != 0 ||\r\nvar->blue.length != 5 ||\r\nvar->green.offset != 5 ||\r\nvar->green.length != 5 ||\r\nvar->red.offset != 10 ||\r\nvar->red.length != 5 ||\r\nvar->transp.offset != 15 || var->transp.length != 1) {\r\nvmlfb_set_pref_pixel_format(&v);\r\n}\r\nbreak;\r\ncase 32:\r\nif (var->blue.offset != 0 ||\r\nvar->blue.length != 8 ||\r\nvar->green.offset != 8 ||\r\nvar->green.length != 8 ||\r\nvar->red.offset != 16 ||\r\nvar->red.length != 8 ||\r\n(var->transp.length != 0 && var->transp.length != 8) ||\r\n(var->transp.length == 8 && var->transp.offset != 24)) {\r\nvmlfb_set_pref_pixel_format(&v);\r\n}\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\n*var = v;\r\nreturn 0;\r\n}\r\nstatic int vmlfb_check_var(struct fb_var_screeninfo *var, struct fb_info *info)\r\n{\r\nstruct vml_info *vinfo = container_of(info, struct vml_info, info);\r\nint ret;\r\nmutex_lock(&vml_mutex);\r\nret = vmlfb_check_var_locked(var, vinfo);\r\nmutex_unlock(&vml_mutex);\r\nreturn ret;\r\n}\r\nstatic void vml_wait_vblank(struct vml_info *vinfo)\r\n{\r\nmdelay(20);\r\n}\r\nstatic void vmlfb_disable_pipe(struct vml_info *vinfo)\r\n{\r\nstruct vml_par *par = vinfo->par;\r\nVML_WRITE32(par, VML_RCOMPSTAT, 0);\r\nwhile (!(VML_READ32(par, VML_RCOMPSTAT) & VML_MDVO_VDC_I_RCOMP)) ;\r\nVML_WRITE32(par, VML_DSPCCNTR,\r\nVML_READ32(par, VML_DSPCCNTR) & ~VML_GFX_ENABLE);\r\n(void)VML_READ32(par, VML_DSPCCNTR);\r\nvml_wait_vblank(vinfo);\r\nVML_WRITE32(par, VML_PIPEACONF, 0);\r\n(void)VML_READ32(par, VML_PIPEACONF);\r\nvinfo->pipe_disabled = 1;\r\n}\r\nstatic void vml_dump_regs(struct vml_info *vinfo)\r\n{\r\nstruct vml_par *par = vinfo->par;\r\nprintk(KERN_DEBUG MODULE_NAME ": Modesetting register dump:\n");\r\nprintk(KERN_DEBUG MODULE_NAME ": \tHTOTAL_A : 0x%08x\n",\r\n(unsigned)VML_READ32(par, VML_HTOTAL_A));\r\nprintk(KERN_DEBUG MODULE_NAME ": \tHBLANK_A : 0x%08x\n",\r\n(unsigned)VML_READ32(par, VML_HBLANK_A));\r\nprintk(KERN_DEBUG MODULE_NAME ": \tHSYNC_A : 0x%08x\n",\r\n(unsigned)VML_READ32(par, VML_HSYNC_A));\r\nprintk(KERN_DEBUG MODULE_NAME ": \tVTOTAL_A : 0x%08x\n",\r\n(unsigned)VML_READ32(par, VML_VTOTAL_A));\r\nprintk(KERN_DEBUG MODULE_NAME ": \tVBLANK_A : 0x%08x\n",\r\n(unsigned)VML_READ32(par, VML_VBLANK_A));\r\nprintk(KERN_DEBUG MODULE_NAME ": \tVSYNC_A : 0x%08x\n",\r\n(unsigned)VML_READ32(par, VML_VSYNC_A));\r\nprintk(KERN_DEBUG MODULE_NAME ": \tDSPCSTRIDE : 0x%08x\n",\r\n(unsigned)VML_READ32(par, VML_DSPCSTRIDE));\r\nprintk(KERN_DEBUG MODULE_NAME ": \tDSPCSIZE : 0x%08x\n",\r\n(unsigned)VML_READ32(par, VML_DSPCSIZE));\r\nprintk(KERN_DEBUG MODULE_NAME ": \tDSPCPOS : 0x%08x\n",\r\n(unsigned)VML_READ32(par, VML_DSPCPOS));\r\nprintk(KERN_DEBUG MODULE_NAME ": \tDSPARB : 0x%08x\n",\r\n(unsigned)VML_READ32(par, VML_DSPARB));\r\nprintk(KERN_DEBUG MODULE_NAME ": \tDSPCADDR : 0x%08x\n",\r\n(unsigned)VML_READ32(par, VML_DSPCADDR));\r\nprintk(KERN_DEBUG MODULE_NAME ": \tBCLRPAT_A : 0x%08x\n",\r\n(unsigned)VML_READ32(par, VML_BCLRPAT_A));\r\nprintk(KERN_DEBUG MODULE_NAME ": \tCANVSCLR_A : 0x%08x\n",\r\n(unsigned)VML_READ32(par, VML_CANVSCLR_A));\r\nprintk(KERN_DEBUG MODULE_NAME ": \tPIPEASRC : 0x%08x\n",\r\n(unsigned)VML_READ32(par, VML_PIPEASRC));\r\nprintk(KERN_DEBUG MODULE_NAME ": \tPIPEACONF : 0x%08x\n",\r\n(unsigned)VML_READ32(par, VML_PIPEACONF));\r\nprintk(KERN_DEBUG MODULE_NAME ": \tDSPCCNTR : 0x%08x\n",\r\n(unsigned)VML_READ32(par, VML_DSPCCNTR));\r\nprintk(KERN_DEBUG MODULE_NAME ": \tRCOMPSTAT : 0x%08x\n",\r\n(unsigned)VML_READ32(par, VML_RCOMPSTAT));\r\nprintk(KERN_DEBUG MODULE_NAME ": End of modesetting register dump.\n");\r\n}\r\nstatic int vmlfb_set_par_locked(struct vml_info *vinfo)\r\n{\r\nstruct vml_par *par = vinfo->par;\r\nstruct fb_info *info = &vinfo->info;\r\nstruct fb_var_screeninfo *var = &info->var;\r\nu32 htotal, hactive, hblank_start, hblank_end, hsync_start, hsync_end;\r\nu32 vtotal, vactive, vblank_start, vblank_end, vsync_start, vsync_end;\r\nu32 dspcntr;\r\nint clock;\r\nvinfo->bytes_per_pixel = var->bits_per_pixel >> 3;\r\nvinfo->stride = ALIGN(var->xres_virtual * vinfo->bytes_per_pixel, 0x40);\r\ninfo->fix.line_length = vinfo->stride;\r\nif (!subsys)\r\nreturn 0;\r\nhtotal =\r\nvar->xres + var->right_margin + var->hsync_len + var->left_margin;\r\nhactive = var->xres;\r\nhblank_start = var->xres;\r\nhblank_end = htotal;\r\nhsync_start = hactive + var->right_margin;\r\nhsync_end = hsync_start + var->hsync_len;\r\nvtotal =\r\nvar->yres + var->lower_margin + var->vsync_len + var->upper_margin;\r\nvactive = var->yres;\r\nvblank_start = var->yres;\r\nvblank_end = vtotal;\r\nvsync_start = vactive + var->lower_margin;\r\nvsync_end = vsync_start + var->vsync_len;\r\ndspcntr = VML_GFX_ENABLE | VML_GFX_GAMMABYPASS;\r\nclock = PICOS2KHZ(var->pixclock);\r\nif (subsys->nearest_clock) {\r\nclock = subsys->nearest_clock(subsys, clock);\r\n} else {\r\nclock = vml_nearest_clock(clock);\r\n}\r\nprintk(KERN_DEBUG MODULE_NAME\r\n": Set mode Hfreq : %d kHz, Vfreq : %d Hz.\n", clock / htotal,\r\n((clock / htotal) * 1000) / vtotal);\r\nswitch (var->bits_per_pixel) {\r\ncase 16:\r\ndspcntr |= VML_GFX_ARGB1555;\r\nbreak;\r\ncase 32:\r\nif (var->transp.length == 8)\r\ndspcntr |= VML_GFX_ARGB8888 | VML_GFX_ALPHAMULT;\r\nelse\r\ndspcntr |= VML_GFX_RGB0888;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nvmlfb_disable_pipe(vinfo);\r\nmb();\r\nif (subsys->set_clock)\r\nsubsys->set_clock(subsys, clock);\r\nelse\r\nreturn -EINVAL;\r\nVML_WRITE32(par, VML_HTOTAL_A, ((htotal - 1) << 16) | (hactive - 1));\r\nVML_WRITE32(par, VML_HBLANK_A,\r\n((hblank_end - 1) << 16) | (hblank_start - 1));\r\nVML_WRITE32(par, VML_HSYNC_A,\r\n((hsync_end - 1) << 16) | (hsync_start - 1));\r\nVML_WRITE32(par, VML_VTOTAL_A, ((vtotal - 1) << 16) | (vactive - 1));\r\nVML_WRITE32(par, VML_VBLANK_A,\r\n((vblank_end - 1) << 16) | (vblank_start - 1));\r\nVML_WRITE32(par, VML_VSYNC_A,\r\n((vsync_end - 1) << 16) | (vsync_start - 1));\r\nVML_WRITE32(par, VML_DSPCSTRIDE, vinfo->stride);\r\nVML_WRITE32(par, VML_DSPCSIZE,\r\n((var->yres - 1) << 16) | (var->xres - 1));\r\nVML_WRITE32(par, VML_DSPCPOS, 0x00000000);\r\nVML_WRITE32(par, VML_DSPARB, VML_FIFO_DEFAULT);\r\nVML_WRITE32(par, VML_BCLRPAT_A, 0x00000000);\r\nVML_WRITE32(par, VML_CANVSCLR_A, 0x00000000);\r\nVML_WRITE32(par, VML_PIPEASRC,\r\n((var->xres - 1) << 16) | (var->yres - 1));\r\nwmb();\r\nVML_WRITE32(par, VML_PIPEACONF, VML_PIPE_ENABLE);\r\nwmb();\r\nVML_WRITE32(par, VML_DSPCCNTR, dspcntr);\r\nwmb();\r\nVML_WRITE32(par, VML_DSPCADDR, (u32) vinfo->vram_start +\r\nvar->yoffset * vinfo->stride +\r\nvar->xoffset * vinfo->bytes_per_pixel);\r\nVML_WRITE32(par, VML_RCOMPSTAT, VML_MDVO_PAD_ENABLE);\r\nwhile (!(VML_READ32(par, VML_RCOMPSTAT) &\r\n(VML_MDVO_VDC_I_RCOMP | VML_MDVO_PAD_ENABLE))) ;\r\nvinfo->pipe_disabled = 0;\r\n#ifdef VERMILION_DEBUG\r\nvml_dump_regs(vinfo);\r\n#endif\r\nreturn 0;\r\n}\r\nstatic int vmlfb_set_par(struct fb_info *info)\r\n{\r\nstruct vml_info *vinfo = container_of(info, struct vml_info, info);\r\nint ret;\r\nmutex_lock(&vml_mutex);\r\nlist_move(&vinfo->head, (subsys) ? &global_has_mode : &global_no_mode);\r\nret = vmlfb_set_par_locked(vinfo);\r\nmutex_unlock(&vml_mutex);\r\nreturn ret;\r\n}\r\nstatic int vmlfb_blank_locked(struct vml_info *vinfo)\r\n{\r\nstruct vml_par *par = vinfo->par;\r\nu32 cur = VML_READ32(par, VML_PIPEACONF);\r\nswitch (vinfo->cur_blank_mode) {\r\ncase FB_BLANK_UNBLANK:\r\nif (vinfo->pipe_disabled) {\r\nvmlfb_set_par_locked(vinfo);\r\n}\r\nVML_WRITE32(par, VML_PIPEACONF, cur & ~VML_PIPE_FORCE_BORDER);\r\n(void)VML_READ32(par, VML_PIPEACONF);\r\nbreak;\r\ncase FB_BLANK_NORMAL:\r\nif (vinfo->pipe_disabled) {\r\nvmlfb_set_par_locked(vinfo);\r\n}\r\nVML_WRITE32(par, VML_PIPEACONF, cur | VML_PIPE_FORCE_BORDER);\r\n(void)VML_READ32(par, VML_PIPEACONF);\r\nbreak;\r\ncase FB_BLANK_VSYNC_SUSPEND:\r\ncase FB_BLANK_HSYNC_SUSPEND:\r\nif (!vinfo->pipe_disabled) {\r\nvmlfb_disable_pipe(vinfo);\r\n}\r\nbreak;\r\ncase FB_BLANK_POWERDOWN:\r\nif (!vinfo->pipe_disabled) {\r\nvmlfb_disable_pipe(vinfo);\r\n}\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int vmlfb_blank(int blank_mode, struct fb_info *info)\r\n{\r\nstruct vml_info *vinfo = container_of(info, struct vml_info, info);\r\nint ret;\r\nmutex_lock(&vml_mutex);\r\nvinfo->cur_blank_mode = blank_mode;\r\nret = vmlfb_blank_locked(vinfo);\r\nmutex_unlock(&vml_mutex);\r\nreturn ret;\r\n}\r\nstatic int vmlfb_pan_display(struct fb_var_screeninfo *var,\r\nstruct fb_info *info)\r\n{\r\nstruct vml_info *vinfo = container_of(info, struct vml_info, info);\r\nstruct vml_par *par = vinfo->par;\r\nmutex_lock(&vml_mutex);\r\nVML_WRITE32(par, VML_DSPCADDR, (u32) vinfo->vram_start +\r\nvar->yoffset * vinfo->stride +\r\nvar->xoffset * vinfo->bytes_per_pixel);\r\n(void)VML_READ32(par, VML_DSPCADDR);\r\nmutex_unlock(&vml_mutex);\r\nreturn 0;\r\n}\r\nstatic int vmlfb_setcolreg(u_int regno, u_int red, u_int green, u_int blue,\r\nu_int transp, struct fb_info *info)\r\n{\r\nu32 v;\r\nif (regno >= 16)\r\nreturn -EINVAL;\r\nif (info->var.grayscale) {\r\nred = green = blue = (red * 77 + green * 151 + blue * 28) >> 8;\r\n}\r\nif (info->fix.visual != FB_VISUAL_TRUECOLOR)\r\nreturn -EINVAL;\r\nred = VML_TOHW(red, info->var.red.length);\r\nblue = VML_TOHW(blue, info->var.blue.length);\r\ngreen = VML_TOHW(green, info->var.green.length);\r\ntransp = VML_TOHW(transp, info->var.transp.length);\r\nv = (red << info->var.red.offset) |\r\n(green << info->var.green.offset) |\r\n(blue << info->var.blue.offset) |\r\n(transp << info->var.transp.offset);\r\nswitch (info->var.bits_per_pixel) {\r\ncase 16:\r\n((u32 *) info->pseudo_palette)[regno] = v;\r\nbreak;\r\ncase 24:\r\ncase 32:\r\n((u32 *) info->pseudo_palette)[regno] = v;\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic int vmlfb_mmap(struct fb_info *info, struct vm_area_struct *vma)\r\n{\r\nstruct vml_info *vinfo = container_of(info, struct vml_info, info);\r\nunsigned long offset = vma->vm_pgoff << PAGE_SHIFT;\r\nint ret;\r\nunsigned long prot;\r\nret = vmlfb_vram_offset(vinfo, offset);\r\nif (ret)\r\nreturn -EINVAL;\r\nprot = pgprot_val(vma->vm_page_prot) & ~_PAGE_CACHE_MASK;\r\npgprot_val(vma->vm_page_prot) =\r\nprot | cachemode2protval(_PAGE_CACHE_MODE_UC_MINUS);\r\nreturn vm_iomap_memory(vma, vinfo->vram_start,\r\nvinfo->vram_contig_size);\r\n}\r\nstatic int vmlfb_sync(struct fb_info *info)\r\n{\r\nreturn 0;\r\n}\r\nstatic int vmlfb_cursor(struct fb_info *info, struct fb_cursor *cursor)\r\n{\r\nreturn -EINVAL;\r\n}\r\nstatic void __exit vmlfb_cleanup(void)\r\n{\r\npci_unregister_driver(&vmlfb_pci_driver);\r\n}\r\nstatic int __init vmlfb_init(void)\r\n{\r\n#ifndef MODULE\r\nchar *option = NULL;\r\nif (fb_get_options(MODULE_NAME, &option))\r\nreturn -ENODEV;\r\n#endif\r\nprintk(KERN_DEBUG MODULE_NAME ": initializing\n");\r\nmutex_init(&vml_mutex);\r\nINIT_LIST_HEAD(&global_no_mode);\r\nINIT_LIST_HEAD(&global_has_mode);\r\nreturn pci_register_driver(&vmlfb_pci_driver);\r\n}\r\nint vmlfb_register_subsys(struct vml_sys *sys)\r\n{\r\nstruct vml_info *entry;\r\nstruct list_head *list;\r\nu32 save_activate;\r\nmutex_lock(&vml_mutex);\r\nif (subsys != NULL) {\r\nsubsys->restore(subsys);\r\n}\r\nsubsys = sys;\r\nsubsys->save(subsys);\r\nlist = global_no_mode.next;\r\nwhile (list != &global_no_mode) {\r\nlist_del_init(list);\r\nentry = list_entry(list, struct vml_info, head);\r\nif (!vmlfb_check_var_locked(&entry->info.var, entry)) {\r\nvmlfb_set_par_locked(entry);\r\nlist_add_tail(list, &global_has_mode);\r\n} else {\r\nmutex_unlock(&vml_mutex);\r\nsave_activate = entry->info.var.activate;\r\nentry->info.var.bits_per_pixel = 16;\r\nvmlfb_set_pref_pixel_format(&entry->info.var);\r\nif (fb_find_mode(&entry->info.var,\r\n&entry->info,\r\nvml_default_mode, NULL, 0, NULL, 16)) {\r\nentry->info.var.activate |=\r\nFB_ACTIVATE_FORCE | FB_ACTIVATE_NOW;\r\nfb_set_var(&entry->info, &entry->info.var);\r\n} else {\r\nprintk(KERN_ERR MODULE_NAME\r\n": Sorry. no mode found for this subsys.\n");\r\n}\r\nentry->info.var.activate = save_activate;\r\nmutex_lock(&vml_mutex);\r\n}\r\nvmlfb_blank_locked(entry);\r\nlist = global_no_mode.next;\r\n}\r\nmutex_unlock(&vml_mutex);\r\nprintk(KERN_DEBUG MODULE_NAME ": Registered %s subsystem.\n",\r\nsubsys->name ? subsys->name : "unknown");\r\nreturn 0;\r\n}\r\nvoid vmlfb_unregister_subsys(struct vml_sys *sys)\r\n{\r\nstruct vml_info *entry, *next;\r\nmutex_lock(&vml_mutex);\r\nif (subsys != sys) {\r\nmutex_unlock(&vml_mutex);\r\nreturn;\r\n}\r\nsubsys->restore(subsys);\r\nsubsys = NULL;\r\nlist_for_each_entry_safe(entry, next, &global_has_mode, head) {\r\nprintk(KERN_DEBUG MODULE_NAME ": subsys disable pipe\n");\r\nvmlfb_disable_pipe(entry);\r\nlist_move_tail(&entry->head, &global_no_mode);\r\n}\r\nmutex_unlock(&vml_mutex);\r\n}
