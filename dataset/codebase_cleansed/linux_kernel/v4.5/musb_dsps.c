static inline u8 dsps_readb(const void __iomem *addr, unsigned offset)\r\n{\r\nreturn __raw_readb(addr + offset);\r\n}\r\nstatic inline u32 dsps_readl(const void __iomem *addr, unsigned offset)\r\n{\r\nreturn __raw_readl(addr + offset);\r\n}\r\nstatic inline void dsps_writeb(void __iomem *addr, unsigned offset, u8 data)\r\n{\r\n__raw_writeb(data, addr + offset);\r\n}\r\nstatic inline void dsps_writel(void __iomem *addr, unsigned offset, u32 data)\r\n{\r\n__raw_writel(data, addr + offset);\r\n}\r\nstatic void dsps_musb_try_idle(struct musb *musb, unsigned long timeout)\r\n{\r\nstruct device *dev = musb->controller;\r\nstruct dsps_glue *glue = dev_get_drvdata(dev->parent);\r\nif (timeout == 0)\r\ntimeout = jiffies + msecs_to_jiffies(3);\r\nif (musb->is_active || (musb->a_wait_bcon == 0 &&\r\nmusb->xceiv->otg->state == OTG_STATE_A_WAIT_BCON)) {\r\ndev_dbg(musb->controller, "%s active, deleting timer\n",\r\nusb_otg_state_string(musb->xceiv->otg->state));\r\ndel_timer(&glue->timer);\r\nglue->last_timer = jiffies;\r\nreturn;\r\n}\r\nif (musb->port_mode != MUSB_PORT_MODE_DUAL_ROLE)\r\nreturn;\r\nif (!musb->g.dev.driver)\r\nreturn;\r\nif (time_after(glue->last_timer, timeout) &&\r\ntimer_pending(&glue->timer)) {\r\ndev_dbg(musb->controller,\r\n"Longer idle timer already pending, ignoring...\n");\r\nreturn;\r\n}\r\nglue->last_timer = timeout;\r\ndev_dbg(musb->controller, "%s inactive, starting idle timer for %u ms\n",\r\nusb_otg_state_string(musb->xceiv->otg->state),\r\njiffies_to_msecs(timeout - jiffies));\r\nmod_timer(&glue->timer, timeout);\r\n}\r\nstatic void dsps_musb_enable(struct musb *musb)\r\n{\r\nstruct device *dev = musb->controller;\r\nstruct platform_device *pdev = to_platform_device(dev->parent);\r\nstruct dsps_glue *glue = platform_get_drvdata(pdev);\r\nconst struct dsps_musb_wrapper *wrp = glue->wrp;\r\nvoid __iomem *reg_base = musb->ctrl_base;\r\nu32 epmask, coremask;\r\nepmask = ((musb->epmask & wrp->txep_mask) << wrp->txep_shift) |\r\n((musb->epmask & wrp->rxep_mask) << wrp->rxep_shift);\r\ncoremask = (wrp->usb_bitmap & ~MUSB_INTR_SOF);\r\ndsps_writel(reg_base, wrp->epintr_set, epmask);\r\ndsps_writel(reg_base, wrp->coreintr_set, coremask);\r\nif (musb->xceiv->otg->state == OTG_STATE_B_IDLE &&\r\nmusb->port_mode == MUSB_PORT_MODE_DUAL_ROLE)\r\nmod_timer(&glue->timer, jiffies +\r\nmsecs_to_jiffies(wrp->poll_timeout));\r\ndsps_musb_try_idle(musb, 0);\r\n}\r\nstatic void dsps_musb_disable(struct musb *musb)\r\n{\r\nstruct device *dev = musb->controller;\r\nstruct platform_device *pdev = to_platform_device(dev->parent);\r\nstruct dsps_glue *glue = platform_get_drvdata(pdev);\r\nconst struct dsps_musb_wrapper *wrp = glue->wrp;\r\nvoid __iomem *reg_base = musb->ctrl_base;\r\ndsps_writel(reg_base, wrp->coreintr_clear, wrp->usb_bitmap);\r\ndsps_writel(reg_base, wrp->epintr_clear,\r\nwrp->txep_bitmap | wrp->rxep_bitmap);\r\ndsps_writeb(musb->mregs, MUSB_DEVCTL, 0);\r\n}\r\nstatic void otg_timer(unsigned long _musb)\r\n{\r\nstruct musb *musb = (void *)_musb;\r\nvoid __iomem *mregs = musb->mregs;\r\nstruct device *dev = musb->controller;\r\nstruct dsps_glue *glue = dev_get_drvdata(dev->parent);\r\nconst struct dsps_musb_wrapper *wrp = glue->wrp;\r\nu8 devctl;\r\nunsigned long flags;\r\nint skip_session = 0;\r\ndevctl = dsps_readb(mregs, MUSB_DEVCTL);\r\ndev_dbg(musb->controller, "Poll devctl %02x (%s)\n", devctl,\r\nusb_otg_state_string(musb->xceiv->otg->state));\r\nspin_lock_irqsave(&musb->lock, flags);\r\nswitch (musb->xceiv->otg->state) {\r\ncase OTG_STATE_A_WAIT_BCON:\r\ndsps_writeb(musb->mregs, MUSB_DEVCTL, 0);\r\nskip_session = 1;\r\ncase OTG_STATE_A_IDLE:\r\ncase OTG_STATE_B_IDLE:\r\nif (devctl & MUSB_DEVCTL_BDEVICE) {\r\nmusb->xceiv->otg->state = OTG_STATE_B_IDLE;\r\nMUSB_DEV_MODE(musb);\r\n} else {\r\nmusb->xceiv->otg->state = OTG_STATE_A_IDLE;\r\nMUSB_HST_MODE(musb);\r\n}\r\nif (!(devctl & MUSB_DEVCTL_SESSION) && !skip_session)\r\ndsps_writeb(mregs, MUSB_DEVCTL, MUSB_DEVCTL_SESSION);\r\nmod_timer(&glue->timer, jiffies +\r\nmsecs_to_jiffies(wrp->poll_timeout));\r\nbreak;\r\ncase OTG_STATE_A_WAIT_VFALL:\r\nmusb->xceiv->otg->state = OTG_STATE_A_WAIT_VRISE;\r\ndsps_writel(musb->ctrl_base, wrp->coreintr_set,\r\nMUSB_INTR_VBUSERROR << wrp->usb_shift);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nspin_unlock_irqrestore(&musb->lock, flags);\r\n}\r\nstatic irqreturn_t dsps_interrupt(int irq, void *hci)\r\n{\r\nstruct musb *musb = hci;\r\nvoid __iomem *reg_base = musb->ctrl_base;\r\nstruct device *dev = musb->controller;\r\nstruct dsps_glue *glue = dev_get_drvdata(dev->parent);\r\nconst struct dsps_musb_wrapper *wrp = glue->wrp;\r\nunsigned long flags;\r\nirqreturn_t ret = IRQ_NONE;\r\nu32 epintr, usbintr;\r\nspin_lock_irqsave(&musb->lock, flags);\r\nepintr = dsps_readl(reg_base, wrp->epintr_status);\r\nmusb->int_rx = (epintr & wrp->rxep_bitmap) >> wrp->rxep_shift;\r\nmusb->int_tx = (epintr & wrp->txep_bitmap) >> wrp->txep_shift;\r\nif (epintr)\r\ndsps_writel(reg_base, wrp->epintr_status, epintr);\r\nusbintr = dsps_readl(reg_base, wrp->coreintr_status);\r\nif (!usbintr && !epintr)\r\ngoto out;\r\nmusb->int_usb = (usbintr & wrp->usb_bitmap) >> wrp->usb_shift;\r\nif (usbintr)\r\ndsps_writel(reg_base, wrp->coreintr_status, usbintr);\r\ndev_dbg(musb->controller, "usbintr (%x) epintr(%x)\n",\r\nusbintr, epintr);\r\nif (usbintr & ((1 << wrp->drvvbus) << wrp->usb_shift)) {\r\nint drvvbus = dsps_readl(reg_base, wrp->status);\r\nvoid __iomem *mregs = musb->mregs;\r\nu8 devctl = dsps_readb(mregs, MUSB_DEVCTL);\r\nint err;\r\nerr = musb->int_usb & MUSB_INTR_VBUSERROR;\r\nif (err) {\r\nmusb->int_usb &= ~MUSB_INTR_VBUSERROR;\r\nmusb->xceiv->otg->state = OTG_STATE_A_WAIT_VFALL;\r\nmod_timer(&glue->timer, jiffies +\r\nmsecs_to_jiffies(wrp->poll_timeout));\r\nWARNING("VBUS error workaround (delay coming)\n");\r\n} else if (drvvbus) {\r\nMUSB_HST_MODE(musb);\r\nmusb->xceiv->otg->default_a = 1;\r\nmusb->xceiv->otg->state = OTG_STATE_A_WAIT_VRISE;\r\ndel_timer(&glue->timer);\r\n} else {\r\nmusb->is_active = 0;\r\nMUSB_DEV_MODE(musb);\r\nmusb->xceiv->otg->default_a = 0;\r\nmusb->xceiv->otg->state = OTG_STATE_B_IDLE;\r\n}\r\ndev_dbg(musb->controller, "VBUS %s (%s)%s, devctl %02x\n",\r\ndrvvbus ? "on" : "off",\r\nusb_otg_state_string(musb->xceiv->otg->state),\r\nerr ? " ERROR" : "",\r\ndevctl);\r\nret = IRQ_HANDLED;\r\n}\r\nif (musb->int_tx || musb->int_rx || musb->int_usb)\r\nret |= musb_interrupt(musb);\r\nif (musb->xceiv->otg->state == OTG_STATE_B_IDLE &&\r\nmusb->port_mode == MUSB_PORT_MODE_DUAL_ROLE)\r\nmod_timer(&glue->timer, jiffies +\r\nmsecs_to_jiffies(wrp->poll_timeout));\r\nout:\r\nspin_unlock_irqrestore(&musb->lock, flags);\r\nreturn ret;\r\n}\r\nstatic int dsps_musb_dbg_init(struct musb *musb, struct dsps_glue *glue)\r\n{\r\nstruct dentry *root;\r\nstruct dentry *file;\r\nchar buf[128];\r\nsprintf(buf, "%s.dsps", dev_name(musb->controller));\r\nroot = debugfs_create_dir(buf, NULL);\r\nif (!root)\r\nreturn -ENOMEM;\r\nglue->dbgfs_root = root;\r\nglue->regset.regs = dsps_musb_regs;\r\nglue->regset.nregs = ARRAY_SIZE(dsps_musb_regs);\r\nglue->regset.base = musb->ctrl_base;\r\nfile = debugfs_create_regset32("regdump", S_IRUGO, root, &glue->regset);\r\nif (!file) {\r\ndebugfs_remove_recursive(root);\r\nreturn -ENOMEM;\r\n}\r\nreturn 0;\r\n}\r\nstatic int dsps_musb_init(struct musb *musb)\r\n{\r\nstruct device *dev = musb->controller;\r\nstruct dsps_glue *glue = dev_get_drvdata(dev->parent);\r\nstruct platform_device *parent = to_platform_device(dev->parent);\r\nconst struct dsps_musb_wrapper *wrp = glue->wrp;\r\nvoid __iomem *reg_base;\r\nstruct resource *r;\r\nu32 rev, val;\r\nint ret;\r\nr = platform_get_resource_byname(parent, IORESOURCE_MEM, "control");\r\nreg_base = devm_ioremap_resource(dev, r);\r\nif (IS_ERR(reg_base))\r\nreturn PTR_ERR(reg_base);\r\nmusb->ctrl_base = reg_base;\r\nmusb->xceiv = devm_usb_get_phy_by_phandle(dev->parent, "phys", 0);\r\nif (IS_ERR(musb->xceiv))\r\nreturn PTR_ERR(musb->xceiv);\r\nmusb->phy = devm_phy_get(dev->parent, "usb2-phy");\r\nrev = dsps_readl(reg_base, wrp->revision);\r\nif (!rev)\r\nreturn -ENODEV;\r\nusb_phy_init(musb->xceiv);\r\nif (IS_ERR(musb->phy)) {\r\nmusb->phy = NULL;\r\n} else {\r\nret = phy_init(musb->phy);\r\nif (ret < 0)\r\nreturn ret;\r\nret = phy_power_on(musb->phy);\r\nif (ret) {\r\nphy_exit(musb->phy);\r\nreturn ret;\r\n}\r\n}\r\nsetup_timer(&glue->timer, otg_timer, (unsigned long) musb);\r\ndsps_writel(reg_base, wrp->control, (1 << wrp->reset));\r\nmusb->isr = dsps_interrupt;\r\nval = dsps_readl(reg_base, wrp->phy_utmi);\r\nval &= ~(1 << wrp->otg_disable);\r\ndsps_writel(musb->ctrl_base, wrp->phy_utmi, val);\r\nval = dsps_readb(musb->mregs, MUSB_BABBLE_CTL);\r\nif (val & MUSB_BABBLE_RCV_DISABLE) {\r\nglue->sw_babble_enabled = true;\r\nval |= MUSB_BABBLE_SW_SESSION_CTRL;\r\ndsps_writeb(musb->mregs, MUSB_BABBLE_CTL, val);\r\n}\r\nreturn dsps_musb_dbg_init(musb, glue);\r\n}\r\nstatic int dsps_musb_exit(struct musb *musb)\r\n{\r\nstruct device *dev = musb->controller;\r\nstruct dsps_glue *glue = dev_get_drvdata(dev->parent);\r\ndel_timer_sync(&glue->timer);\r\nusb_phy_shutdown(musb->xceiv);\r\nphy_power_off(musb->phy);\r\nphy_exit(musb->phy);\r\ndebugfs_remove_recursive(glue->dbgfs_root);\r\nreturn 0;\r\n}\r\nstatic int dsps_musb_set_mode(struct musb *musb, u8 mode)\r\n{\r\nstruct device *dev = musb->controller;\r\nstruct dsps_glue *glue = dev_get_drvdata(dev->parent);\r\nconst struct dsps_musb_wrapper *wrp = glue->wrp;\r\nvoid __iomem *ctrl_base = musb->ctrl_base;\r\nu32 reg;\r\nreg = dsps_readl(ctrl_base, wrp->mode);\r\nswitch (mode) {\r\ncase MUSB_HOST:\r\nreg &= ~(1 << wrp->iddig);\r\nreg |= (1 << wrp->iddig_mux);\r\ndsps_writel(ctrl_base, wrp->mode, reg);\r\ndsps_writel(ctrl_base, wrp->phy_utmi, 0x02);\r\nbreak;\r\ncase MUSB_PERIPHERAL:\r\nreg |= (1 << wrp->iddig);\r\nreg |= (1 << wrp->iddig_mux);\r\ndsps_writel(ctrl_base, wrp->mode, reg);\r\nbreak;\r\ncase MUSB_OTG:\r\ndsps_writel(ctrl_base, wrp->phy_utmi, 0x02);\r\nbreak;\r\ndefault:\r\ndev_err(glue->dev, "unsupported mode %d\n", mode);\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic bool dsps_sw_babble_control(struct musb *musb)\r\n{\r\nu8 babble_ctl;\r\nbool session_restart = false;\r\nbabble_ctl = dsps_readb(musb->mregs, MUSB_BABBLE_CTL);\r\ndev_dbg(musb->controller, "babble: MUSB_BABBLE_CTL value %x\n",\r\nbabble_ctl);\r\ndev_dbg(musb->controller, "STUCK_J is %s\n",\r\nbabble_ctl & MUSB_BABBLE_STUCK_J ? "set" : "reset");\r\nif (babble_ctl & MUSB_BABBLE_STUCK_J) {\r\nint timeout = 10;\r\nbabble_ctl = dsps_readb(musb->mregs, MUSB_BABBLE_CTL);\r\nbabble_ctl |= MUSB_BABBLE_FORCE_TXIDLE;\r\ndsps_writeb(musb->mregs, MUSB_BABBLE_CTL, babble_ctl);\r\ndev_dbg(musb->controller, "Set TXIDLE, wait J to clear\n");\r\ndo {\r\nbabble_ctl = dsps_readb(musb->mregs, MUSB_BABBLE_CTL);\r\nudelay(1);\r\n} while ((babble_ctl & MUSB_BABBLE_STUCK_J) && timeout--);\r\nif (babble_ctl & MUSB_BABBLE_STUCK_J) {\r\ndev_dbg(musb->controller, "J not cleared, misc (%x)\n",\r\nbabble_ctl);\r\nsession_restart = true;\r\n}\r\n} else {\r\nsession_restart = true;\r\n}\r\nreturn session_restart;\r\n}\r\nstatic int dsps_musb_recover(struct musb *musb)\r\n{\r\nstruct device *dev = musb->controller;\r\nstruct dsps_glue *glue = dev_get_drvdata(dev->parent);\r\nint session_restart = 0;\r\nif (glue->sw_babble_enabled)\r\nsession_restart = dsps_sw_babble_control(musb);\r\nelse\r\nsession_restart = 1;\r\nreturn session_restart ? 0 : -EPIPE;\r\n}\r\nstatic void dsps_read_fifo32(struct musb_hw_ep *hw_ep, u16 len, u8 *dst)\r\n{\r\nvoid __iomem *fifo = hw_ep->fifo;\r\nif (len >= 4) {\r\nioread32_rep(fifo, dst, len >> 2);\r\ndst += len & ~0x03;\r\nlen &= 0x03;\r\n}\r\nif (len > 0) {\r\nu32 val = musb_readl(fifo, 0);\r\nmemcpy(dst, &val, len);\r\n}\r\n}\r\nstatic int get_int_prop(struct device_node *dn, const char *s)\r\n{\r\nint ret;\r\nu32 val;\r\nret = of_property_read_u32(dn, s, &val);\r\nif (ret)\r\nreturn 0;\r\nreturn val;\r\n}\r\nstatic int get_musb_port_mode(struct device *dev)\r\n{\r\nenum usb_dr_mode mode;\r\nmode = usb_get_dr_mode(dev);\r\nswitch (mode) {\r\ncase USB_DR_MODE_HOST:\r\nreturn MUSB_PORT_MODE_HOST;\r\ncase USB_DR_MODE_PERIPHERAL:\r\nreturn MUSB_PORT_MODE_GADGET;\r\ncase USB_DR_MODE_UNKNOWN:\r\ncase USB_DR_MODE_OTG:\r\ndefault:\r\nreturn MUSB_PORT_MODE_DUAL_ROLE;\r\n}\r\n}\r\nstatic int dsps_create_musb_pdev(struct dsps_glue *glue,\r\nstruct platform_device *parent)\r\n{\r\nstruct musb_hdrc_platform_data pdata;\r\nstruct resource resources[2];\r\nstruct resource *res;\r\nstruct device *dev = &parent->dev;\r\nstruct musb_hdrc_config *config;\r\nstruct platform_device *musb;\r\nstruct device_node *dn = parent->dev.of_node;\r\nint ret, val;\r\nmemset(resources, 0, sizeof(resources));\r\nres = platform_get_resource_byname(parent, IORESOURCE_MEM, "mc");\r\nif (!res) {\r\ndev_err(dev, "failed to get memory.\n");\r\nreturn -EINVAL;\r\n}\r\nresources[0] = *res;\r\nres = platform_get_resource_byname(parent, IORESOURCE_IRQ, "mc");\r\nif (!res) {\r\ndev_err(dev, "failed to get irq.\n");\r\nreturn -EINVAL;\r\n}\r\nresources[1] = *res;\r\nmusb = platform_device_alloc("musb-hdrc", PLATFORM_DEVID_AUTO);\r\nif (!musb) {\r\ndev_err(dev, "failed to allocate musb device\n");\r\nreturn -ENOMEM;\r\n}\r\nmusb->dev.parent = dev;\r\nmusb->dev.dma_mask = &musb_dmamask;\r\nmusb->dev.coherent_dma_mask = musb_dmamask;\r\nglue->musb = musb;\r\nret = platform_device_add_resources(musb, resources,\r\nARRAY_SIZE(resources));\r\nif (ret) {\r\ndev_err(dev, "failed to add resources\n");\r\ngoto err;\r\n}\r\nconfig = devm_kzalloc(&parent->dev, sizeof(*config), GFP_KERNEL);\r\nif (!config) {\r\nret = -ENOMEM;\r\ngoto err;\r\n}\r\npdata.config = config;\r\npdata.platform_ops = &dsps_ops;\r\nconfig->num_eps = get_int_prop(dn, "mentor,num-eps");\r\nconfig->ram_bits = get_int_prop(dn, "mentor,ram-bits");\r\nconfig->host_port_deassert_reset_at_resume = 1;\r\npdata.mode = get_musb_port_mode(dev);\r\npdata.power = get_int_prop(dn, "mentor,power") / 2;\r\nret = of_property_read_u32(dn, "mentor,multipoint", &val);\r\nif (!ret && val)\r\nconfig->multipoint = true;\r\nconfig->maximum_speed = usb_get_maximum_speed(&parent->dev);\r\nswitch (config->maximum_speed) {\r\ncase USB_SPEED_LOW:\r\ncase USB_SPEED_FULL:\r\nbreak;\r\ncase USB_SPEED_SUPER:\r\ndev_warn(dev, "ignore incorrect maximum_speed "\r\n"(super-speed) setting in dts");\r\ndefault:\r\nconfig->maximum_speed = USB_SPEED_HIGH;\r\n}\r\nret = platform_device_add_data(musb, &pdata, sizeof(pdata));\r\nif (ret) {\r\ndev_err(dev, "failed to add platform_data\n");\r\ngoto err;\r\n}\r\nret = platform_device_add(musb);\r\nif (ret) {\r\ndev_err(dev, "failed to register musb device\n");\r\ngoto err;\r\n}\r\nreturn 0;\r\nerr:\r\nplatform_device_put(musb);\r\nreturn ret;\r\n}\r\nstatic int dsps_probe(struct platform_device *pdev)\r\n{\r\nconst struct of_device_id *match;\r\nconst struct dsps_musb_wrapper *wrp;\r\nstruct dsps_glue *glue;\r\nint ret;\r\nif (!strcmp(pdev->name, "musb-hdrc"))\r\nreturn -ENODEV;\r\nmatch = of_match_node(musb_dsps_of_match, pdev->dev.of_node);\r\nif (!match) {\r\ndev_err(&pdev->dev, "fail to get matching of_match struct\n");\r\nreturn -EINVAL;\r\n}\r\nwrp = match->data;\r\nif (of_device_is_compatible(pdev->dev.of_node, "ti,musb-dm816"))\r\ndsps_ops.read_fifo = dsps_read_fifo32;\r\nglue = devm_kzalloc(&pdev->dev, sizeof(*glue), GFP_KERNEL);\r\nif (!glue)\r\nreturn -ENOMEM;\r\nglue->dev = &pdev->dev;\r\nglue->wrp = wrp;\r\nplatform_set_drvdata(pdev, glue);\r\npm_runtime_enable(&pdev->dev);\r\nret = pm_runtime_get_sync(&pdev->dev);\r\nif (ret < 0) {\r\ndev_err(&pdev->dev, "pm_runtime_get_sync FAILED");\r\ngoto err2;\r\n}\r\nret = dsps_create_musb_pdev(glue, pdev);\r\nif (ret)\r\ngoto err3;\r\nreturn 0;\r\nerr3:\r\npm_runtime_put(&pdev->dev);\r\nerr2:\r\npm_runtime_disable(&pdev->dev);\r\nreturn ret;\r\n}\r\nstatic int dsps_remove(struct platform_device *pdev)\r\n{\r\nstruct dsps_glue *glue = platform_get_drvdata(pdev);\r\nplatform_device_unregister(glue->musb);\r\npm_runtime_put(&pdev->dev);\r\npm_runtime_disable(&pdev->dev);\r\nreturn 0;\r\n}\r\nstatic int dsps_suspend(struct device *dev)\r\n{\r\nstruct dsps_glue *glue = dev_get_drvdata(dev);\r\nconst struct dsps_musb_wrapper *wrp = glue->wrp;\r\nstruct musb *musb = platform_get_drvdata(glue->musb);\r\nvoid __iomem *mbase;\r\ndel_timer_sync(&glue->timer);\r\nif (!musb)\r\nreturn 0;\r\nmbase = musb->ctrl_base;\r\nglue->context.control = dsps_readl(mbase, wrp->control);\r\nglue->context.epintr = dsps_readl(mbase, wrp->epintr_set);\r\nglue->context.coreintr = dsps_readl(mbase, wrp->coreintr_set);\r\nglue->context.phy_utmi = dsps_readl(mbase, wrp->phy_utmi);\r\nglue->context.mode = dsps_readl(mbase, wrp->mode);\r\nglue->context.tx_mode = dsps_readl(mbase, wrp->tx_mode);\r\nglue->context.rx_mode = dsps_readl(mbase, wrp->rx_mode);\r\nreturn 0;\r\n}\r\nstatic int dsps_resume(struct device *dev)\r\n{\r\nstruct dsps_glue *glue = dev_get_drvdata(dev);\r\nconst struct dsps_musb_wrapper *wrp = glue->wrp;\r\nstruct musb *musb = platform_get_drvdata(glue->musb);\r\nvoid __iomem *mbase;\r\nif (!musb)\r\nreturn 0;\r\nmbase = musb->ctrl_base;\r\ndsps_writel(mbase, wrp->control, glue->context.control);\r\ndsps_writel(mbase, wrp->epintr_set, glue->context.epintr);\r\ndsps_writel(mbase, wrp->coreintr_set, glue->context.coreintr);\r\ndsps_writel(mbase, wrp->phy_utmi, glue->context.phy_utmi);\r\ndsps_writel(mbase, wrp->mode, glue->context.mode);\r\ndsps_writel(mbase, wrp->tx_mode, glue->context.tx_mode);\r\ndsps_writel(mbase, wrp->rx_mode, glue->context.rx_mode);\r\nif (musb->xceiv->otg->state == OTG_STATE_B_IDLE &&\r\nmusb->port_mode == MUSB_PORT_MODE_DUAL_ROLE)\r\nmod_timer(&glue->timer, jiffies +\r\nmsecs_to_jiffies(wrp->poll_timeout));\r\nreturn 0;\r\n}
