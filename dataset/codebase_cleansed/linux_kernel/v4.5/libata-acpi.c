static void ata_acpi_clear_gtf(struct ata_device *dev)\r\n{\r\nkfree(dev->gtf_cache);\r\ndev->gtf_cache = NULL;\r\n}\r\nacpi_handle ata_dev_acpi_handle(struct ata_device *dev)\r\n{\r\nreturn dev->flags & ATA_DFLAG_ACPI_DISABLED ?\r\nNULL : ACPI_HANDLE(&dev->tdev);\r\n}\r\nstatic void ata_acpi_detach_device(struct ata_port *ap, struct ata_device *dev)\r\n{\r\nif (dev)\r\ndev->flags |= ATA_DFLAG_DETACH;\r\nelse {\r\nstruct ata_link *tlink;\r\nstruct ata_device *tdev;\r\nata_for_each_link(tlink, ap, EDGE)\r\nata_for_each_dev(tdev, tlink, ALL)\r\ntdev->flags |= ATA_DFLAG_DETACH;\r\n}\r\nata_port_schedule_eh(ap);\r\n}\r\nstatic void ata_acpi_handle_hotplug(struct ata_port *ap, struct ata_device *dev,\r\nu32 event)\r\n{\r\nstruct ata_eh_info *ehi = &ap->link.eh_info;\r\nint wait = 0;\r\nunsigned long flags;\r\nspin_lock_irqsave(ap->lock, flags);\r\nswitch (event) {\r\ncase ACPI_NOTIFY_BUS_CHECK:\r\ncase ACPI_NOTIFY_DEVICE_CHECK:\r\nata_ehi_push_desc(ehi, "ACPI event");\r\nata_ehi_hotplugged(ehi);\r\nata_port_freeze(ap);\r\nbreak;\r\ncase ACPI_NOTIFY_EJECT_REQUEST:\r\nata_ehi_push_desc(ehi, "ACPI event");\r\nata_acpi_detach_device(ap, dev);\r\nwait = 1;\r\nbreak;\r\n}\r\nspin_unlock_irqrestore(ap->lock, flags);\r\nif (wait)\r\nata_port_wait_eh(ap);\r\n}\r\nstatic int ata_acpi_dev_notify_dock(struct acpi_device *adev, u32 event)\r\n{\r\nstruct ata_device *dev = ata_hotplug_data(adev->hp).dev;\r\nata_acpi_handle_hotplug(dev->link->ap, dev, event);\r\nreturn 0;\r\n}\r\nstatic int ata_acpi_ap_notify_dock(struct acpi_device *adev, u32 event)\r\n{\r\nata_acpi_handle_hotplug(ata_hotplug_data(adev->hp).ap, NULL, event);\r\nreturn 0;\r\n}\r\nstatic void ata_acpi_uevent(struct ata_port *ap, struct ata_device *dev,\r\nu32 event)\r\n{\r\nstruct kobject *kobj = NULL;\r\nchar event_string[20];\r\nchar *envp[] = { event_string, NULL };\r\nif (dev) {\r\nif (dev->sdev)\r\nkobj = &dev->sdev->sdev_gendev.kobj;\r\n} else\r\nkobj = &ap->dev->kobj;\r\nif (kobj) {\r\nsnprintf(event_string, 20, "BAY_EVENT=%d", event);\r\nkobject_uevent_env(kobj, KOBJ_CHANGE, envp);\r\n}\r\n}\r\nstatic void ata_acpi_ap_uevent(struct acpi_device *adev, u32 event)\r\n{\r\nata_acpi_uevent(ata_hotplug_data(adev->hp).ap, NULL, event);\r\n}\r\nstatic void ata_acpi_dev_uevent(struct acpi_device *adev, u32 event)\r\n{\r\nstruct ata_device *dev = ata_hotplug_data(adev->hp).dev;\r\nata_acpi_uevent(dev->link->ap, dev, event);\r\n}\r\nvoid ata_acpi_bind_port(struct ata_port *ap)\r\n{\r\nstruct acpi_device *host_companion = ACPI_COMPANION(ap->host->dev);\r\nstruct acpi_device *adev;\r\nstruct ata_acpi_hotplug_context *context;\r\nif (libata_noacpi || ap->flags & ATA_FLAG_ACPI_SATA || !host_companion)\r\nreturn;\r\nacpi_preset_companion(&ap->tdev, host_companion, ap->port_no);\r\nif (ata_acpi_gtm(ap, &ap->__acpi_init_gtm) == 0)\r\nap->pflags |= ATA_PFLAG_INIT_GTM_VALID;\r\nadev = ACPI_COMPANION(&ap->tdev);\r\nif (!adev || adev->hp)\r\nreturn;\r\ncontext = kzalloc(sizeof(*context), GFP_KERNEL);\r\nif (!context)\r\nreturn;\r\ncontext->data.ap = ap;\r\nacpi_initialize_hp_context(adev, &context->hp, ata_acpi_ap_notify_dock,\r\nata_acpi_ap_uevent);\r\n}\r\nvoid ata_acpi_bind_dev(struct ata_device *dev)\r\n{\r\nstruct ata_port *ap = dev->link->ap;\r\nstruct acpi_device *port_companion = ACPI_COMPANION(&ap->tdev);\r\nstruct acpi_device *host_companion = ACPI_COMPANION(ap->host->dev);\r\nstruct acpi_device *parent, *adev;\r\nstruct ata_acpi_hotplug_context *context;\r\nu64 adr;\r\nif (libata_noacpi || !host_companion ||\r\n(!(ap->flags & ATA_FLAG_ACPI_SATA) && !port_companion))\r\nreturn;\r\nif (ap->flags & ATA_FLAG_ACPI_SATA) {\r\nif (!sata_pmp_attached(ap))\r\nadr = SATA_ADR(ap->port_no, NO_PORT_MULT);\r\nelse\r\nadr = SATA_ADR(ap->port_no, dev->link->pmp);\r\nparent = host_companion;\r\n} else {\r\nadr = dev->devno;\r\nparent = port_companion;\r\n}\r\nacpi_preset_companion(&dev->tdev, parent, adr);\r\nadev = ACPI_COMPANION(&dev->tdev);\r\nif (!adev || adev->hp)\r\nreturn;\r\ncontext = kzalloc(sizeof(*context), GFP_KERNEL);\r\nif (!context)\r\nreturn;\r\ncontext->data.dev = dev;\r\nacpi_initialize_hp_context(adev, &context->hp, ata_acpi_dev_notify_dock,\r\nata_acpi_dev_uevent);\r\n}\r\nvoid ata_acpi_dissociate(struct ata_host *host)\r\n{\r\nint i;\r\nfor (i = 0; i < host->n_ports; i++) {\r\nstruct ata_port *ap = host->ports[i];\r\nconst struct ata_acpi_gtm *gtm = ata_acpi_init_gtm(ap);\r\nif (ACPI_HANDLE(&ap->tdev) && gtm)\r\nata_acpi_stm(ap, gtm);\r\n}\r\n}\r\nint ata_acpi_gtm(struct ata_port *ap, struct ata_acpi_gtm *gtm)\r\n{\r\nstruct acpi_buffer output = { .length = ACPI_ALLOCATE_BUFFER };\r\nunion acpi_object *out_obj;\r\nacpi_status status;\r\nint rc = 0;\r\nacpi_handle handle = ACPI_HANDLE(&ap->tdev);\r\nif (!handle)\r\nreturn -EINVAL;\r\nstatus = acpi_evaluate_object(handle, "_GTM", NULL, &output);\r\nrc = -ENOENT;\r\nif (status == AE_NOT_FOUND)\r\ngoto out_free;\r\nrc = -EINVAL;\r\nif (ACPI_FAILURE(status)) {\r\nata_port_err(ap, "ACPI get timing mode failed (AE 0x%x)\n",\r\nstatus);\r\ngoto out_free;\r\n}\r\nout_obj = output.pointer;\r\nif (out_obj->type != ACPI_TYPE_BUFFER) {\r\nata_port_warn(ap, "_GTM returned unexpected object type 0x%x\n",\r\nout_obj->type);\r\ngoto out_free;\r\n}\r\nif (out_obj->buffer.length != sizeof(struct ata_acpi_gtm)) {\r\nata_port_err(ap, "_GTM returned invalid length %d\n",\r\nout_obj->buffer.length);\r\ngoto out_free;\r\n}\r\nmemcpy(gtm, out_obj->buffer.pointer, sizeof(struct ata_acpi_gtm));\r\nrc = 0;\r\nout_free:\r\nkfree(output.pointer);\r\nreturn rc;\r\n}\r\nint ata_acpi_stm(struct ata_port *ap, const struct ata_acpi_gtm *stm)\r\n{\r\nacpi_status status;\r\nstruct ata_acpi_gtm stm_buf = *stm;\r\nstruct acpi_object_list input;\r\nunion acpi_object in_params[3];\r\nin_params[0].type = ACPI_TYPE_BUFFER;\r\nin_params[0].buffer.length = sizeof(struct ata_acpi_gtm);\r\nin_params[0].buffer.pointer = (u8 *)&stm_buf;\r\nin_params[1].type = ACPI_TYPE_BUFFER;\r\nin_params[1].buffer.length = 512;\r\nin_params[1].buffer.pointer = (u8 *)ap->link.device[0].id;\r\nin_params[2].type = ACPI_TYPE_BUFFER;\r\nin_params[2].buffer.length = 512;\r\nin_params[2].buffer.pointer = (u8 *)ap->link.device[1].id;\r\ninput.count = 3;\r\ninput.pointer = in_params;\r\nstatus = acpi_evaluate_object(ACPI_HANDLE(&ap->tdev), "_STM",\r\n&input, NULL);\r\nif (status == AE_NOT_FOUND)\r\nreturn -ENOENT;\r\nif (ACPI_FAILURE(status)) {\r\nata_port_err(ap, "ACPI set timing mode failed (status=0x%x)\n",\r\nstatus);\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int ata_dev_get_GTF(struct ata_device *dev, struct ata_acpi_gtf **gtf)\r\n{\r\nstruct ata_port *ap = dev->link->ap;\r\nacpi_status status;\r\nstruct acpi_buffer output;\r\nunion acpi_object *out_obj;\r\nint rc = 0;\r\nif (dev->gtf_cache) {\r\nout_obj = dev->gtf_cache;\r\ngoto done;\r\n}\r\noutput.length = ACPI_ALLOCATE_BUFFER;\r\noutput.pointer = NULL;\r\nif (ata_msg_probe(ap))\r\nata_dev_dbg(dev, "%s: ENTER: port#: %d\n",\r\n__func__, ap->port_no);\r\nstatus = acpi_evaluate_object(ata_dev_acpi_handle(dev), "_GTF", NULL,\r\n&output);\r\nout_obj = dev->gtf_cache = output.pointer;\r\nif (ACPI_FAILURE(status)) {\r\nif (status != AE_NOT_FOUND) {\r\nata_dev_warn(dev, "_GTF evaluation failed (AE 0x%x)\n",\r\nstatus);\r\nrc = -EINVAL;\r\n}\r\ngoto out_free;\r\n}\r\nif (!output.length || !output.pointer) {\r\nif (ata_msg_probe(ap))\r\nata_dev_dbg(dev, "%s: Run _GTF: length or ptr is NULL (0x%llx, 0x%p)\n",\r\n__func__,\r\n(unsigned long long)output.length,\r\noutput.pointer);\r\nrc = -EINVAL;\r\ngoto out_free;\r\n}\r\nif (out_obj->type != ACPI_TYPE_BUFFER) {\r\nata_dev_warn(dev, "_GTF unexpected object type 0x%x\n",\r\nout_obj->type);\r\nrc = -EINVAL;\r\ngoto out_free;\r\n}\r\nif (out_obj->buffer.length % REGS_PER_GTF) {\r\nata_dev_warn(dev, "unexpected _GTF length (%d)\n",\r\nout_obj->buffer.length);\r\nrc = -EINVAL;\r\ngoto out_free;\r\n}\r\ndone:\r\nrc = out_obj->buffer.length / REGS_PER_GTF;\r\nif (gtf) {\r\n*gtf = (void *)out_obj->buffer.pointer;\r\nif (ata_msg_probe(ap))\r\nata_dev_dbg(dev, "%s: returning gtf=%p, gtf_count=%d\n",\r\n__func__, *gtf, rc);\r\n}\r\nreturn rc;\r\nout_free:\r\nata_acpi_clear_gtf(dev);\r\nreturn rc;\r\n}\r\nunsigned long ata_acpi_gtm_xfermask(struct ata_device *dev,\r\nconst struct ata_acpi_gtm *gtm)\r\n{\r\nunsigned long xfer_mask = 0;\r\nunsigned int type;\r\nint unit;\r\nu8 mode;\r\nunit = dev->devno;\r\nif (!(gtm->flags & 0x10))\r\nunit = 0;\r\nmode = ata_timing_cycle2mode(ATA_SHIFT_PIO, gtm->drive[unit].pio);\r\nxfer_mask |= ata_xfer_mode2mask(mode);\r\nif (!(gtm->flags & (1 << (2 * unit))))\r\ntype = ATA_SHIFT_MWDMA;\r\nelse\r\ntype = ATA_SHIFT_UDMA;\r\nmode = ata_timing_cycle2mode(type, gtm->drive[unit].dma);\r\nxfer_mask |= ata_xfer_mode2mask(mode);\r\nreturn xfer_mask;\r\n}\r\nint ata_acpi_cbl_80wire(struct ata_port *ap, const struct ata_acpi_gtm *gtm)\r\n{\r\nstruct ata_device *dev;\r\nata_for_each_dev(dev, &ap->link, ENABLED) {\r\nunsigned long xfer_mask, udma_mask;\r\nxfer_mask = ata_acpi_gtm_xfermask(dev, gtm);\r\nata_unpack_xfermask(xfer_mask, NULL, NULL, &udma_mask);\r\nif (udma_mask & ~ATA_UDMA_MASK_40C)\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}\r\nstatic void ata_acpi_gtf_to_tf(struct ata_device *dev,\r\nconst struct ata_acpi_gtf *gtf,\r\nstruct ata_taskfile *tf)\r\n{\r\nata_tf_init(dev, tf);\r\ntf->flags |= ATA_TFLAG_ISADDR | ATA_TFLAG_DEVICE;\r\ntf->protocol = ATA_PROT_NODATA;\r\ntf->feature = gtf->tf[0];\r\ntf->nsect = gtf->tf[1];\r\ntf->lbal = gtf->tf[2];\r\ntf->lbam = gtf->tf[3];\r\ntf->lbah = gtf->tf[4];\r\ntf->device = gtf->tf[5];\r\ntf->command = gtf->tf[6];\r\n}\r\nstatic int ata_acpi_filter_tf(struct ata_device *dev,\r\nconst struct ata_taskfile *tf,\r\nconst struct ata_taskfile *ptf)\r\n{\r\nif (dev->gtf_filter & ATA_ACPI_FILTER_SETXFER) {\r\nif (tf->command == ATA_CMD_SET_FEATURES &&\r\ntf->feature == SETFEATURES_XFER)\r\nreturn 1;\r\n}\r\nif (dev->gtf_filter & ATA_ACPI_FILTER_LOCK) {\r\nif (tf->command == ATA_CMD_CONF_OVERLAY &&\r\ntf->feature == ATA_DCO_FREEZE_LOCK)\r\nreturn 1;\r\nif (tf->command == ATA_CMD_SEC_FREEZE_LOCK)\r\nreturn 1;\r\nif ((!ptf || ptf->command != ATA_CMD_READ_NATIVE_MAX) &&\r\ntf->command == ATA_CMD_SET_MAX &&\r\n(tf->feature == ATA_SET_MAX_LOCK ||\r\ntf->feature == ATA_SET_MAX_FREEZE_LOCK))\r\nreturn 1;\r\n}\r\nif (tf->command == ATA_CMD_SET_FEATURES &&\r\ntf->feature == SETFEATURES_SATA_ENABLE) {\r\nif (dev->gtf_filter & ATA_ACPI_FILTER_DIPM &&\r\ntf->nsect == SATA_DIPM)\r\nreturn 1;\r\nif (dev->gtf_filter & ATA_ACPI_FILTER_FPDMA_OFFSET &&\r\n(tf->nsect == SATA_FPDMA_OFFSET ||\r\ntf->nsect == SATA_FPDMA_IN_ORDER))\r\nreturn 1;\r\nif (dev->gtf_filter & ATA_ACPI_FILTER_FPDMA_AA &&\r\ntf->nsect == SATA_FPDMA_AA)\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}\r\nstatic int ata_acpi_run_tf(struct ata_device *dev,\r\nconst struct ata_acpi_gtf *gtf,\r\nconst struct ata_acpi_gtf *prev_gtf)\r\n{\r\nstruct ata_taskfile *pptf = NULL;\r\nstruct ata_taskfile tf, ptf, rtf;\r\nunsigned int err_mask;\r\nconst char *level;\r\nconst char *descr;\r\nchar msg[60];\r\nint rc;\r\nif ((gtf->tf[0] == 0) && (gtf->tf[1] == 0) && (gtf->tf[2] == 0)\r\n&& (gtf->tf[3] == 0) && (gtf->tf[4] == 0) && (gtf->tf[5] == 0)\r\n&& (gtf->tf[6] == 0))\r\nreturn 0;\r\nata_acpi_gtf_to_tf(dev, gtf, &tf);\r\nif (prev_gtf) {\r\nata_acpi_gtf_to_tf(dev, prev_gtf, &ptf);\r\npptf = &ptf;\r\n}\r\nif (!ata_acpi_filter_tf(dev, &tf, pptf)) {\r\nrtf = tf;\r\nerr_mask = ata_exec_internal(dev, &rtf, NULL,\r\nDMA_NONE, NULL, 0, 0);\r\nswitch (err_mask) {\r\ncase 0:\r\nlevel = KERN_DEBUG;\r\nsnprintf(msg, sizeof(msg), "succeeded");\r\nrc = 1;\r\nbreak;\r\ncase AC_ERR_DEV:\r\nlevel = KERN_INFO;\r\nsnprintf(msg, sizeof(msg),\r\n"rejected by device (Stat=0x%02x Err=0x%02x)",\r\nrtf.command, rtf.feature);\r\nrc = 0;\r\nbreak;\r\ndefault:\r\nlevel = KERN_ERR;\r\nsnprintf(msg, sizeof(msg),\r\n"failed (Emask=0x%x Stat=0x%02x Err=0x%02x)",\r\nerr_mask, rtf.command, rtf.feature);\r\nrc = -EIO;\r\nbreak;\r\n}\r\n} else {\r\nlevel = KERN_INFO;\r\nsnprintf(msg, sizeof(msg), "filtered out");\r\nrc = 0;\r\n}\r\ndescr = ata_get_cmd_descript(tf.command);\r\nata_dev_printk(dev, level,\r\n"ACPI cmd %02x/%02x:%02x:%02x:%02x:%02x:%02x (%s) %s\n",\r\ntf.command, tf.feature, tf.nsect, tf.lbal,\r\ntf.lbam, tf.lbah, tf.device,\r\n(descr ? descr : "unknown"), msg);\r\nreturn rc;\r\n}\r\nstatic int ata_acpi_exec_tfs(struct ata_device *dev, int *nr_executed)\r\n{\r\nstruct ata_acpi_gtf *gtf = NULL, *pgtf = NULL;\r\nint gtf_count, i, rc;\r\nrc = ata_dev_get_GTF(dev, &gtf);\r\nif (rc < 0)\r\nreturn rc;\r\ngtf_count = rc;\r\nfor (i = 0; i < gtf_count; i++, gtf++) {\r\nrc = ata_acpi_run_tf(dev, gtf, pgtf);\r\nif (rc < 0)\r\nbreak;\r\nif (rc) {\r\n(*nr_executed)++;\r\npgtf = gtf;\r\n}\r\n}\r\nata_acpi_clear_gtf(dev);\r\nif (rc < 0)\r\nreturn rc;\r\nreturn 0;\r\n}\r\nstatic int ata_acpi_push_id(struct ata_device *dev)\r\n{\r\nstruct ata_port *ap = dev->link->ap;\r\nacpi_status status;\r\nstruct acpi_object_list input;\r\nunion acpi_object in_params[1];\r\nif (ata_msg_probe(ap))\r\nata_dev_dbg(dev, "%s: ix = %d, port#: %d\n",\r\n__func__, dev->devno, ap->port_no);\r\ninput.count = 1;\r\ninput.pointer = in_params;\r\nin_params[0].type = ACPI_TYPE_BUFFER;\r\nin_params[0].buffer.length = sizeof(dev->id[0]) * ATA_ID_WORDS;\r\nin_params[0].buffer.pointer = (u8 *)dev->id;\r\nswap_buf_le16(dev->id, ATA_ID_WORDS);\r\nstatus = acpi_evaluate_object(ata_dev_acpi_handle(dev), "_SDD", &input,\r\nNULL);\r\nswap_buf_le16(dev->id, ATA_ID_WORDS);\r\nif (status == AE_NOT_FOUND)\r\nreturn -ENOENT;\r\nif (ACPI_FAILURE(status)) {\r\nata_dev_warn(dev, "ACPI _SDD failed (AE 0x%x)\n", status);\r\nreturn -EIO;\r\n}\r\nreturn 0;\r\n}\r\nint ata_acpi_on_suspend(struct ata_port *ap)\r\n{\r\nreturn 0;\r\n}\r\nvoid ata_acpi_on_resume(struct ata_port *ap)\r\n{\r\nconst struct ata_acpi_gtm *gtm = ata_acpi_init_gtm(ap);\r\nstruct ata_device *dev;\r\nif (ACPI_HANDLE(&ap->tdev) && gtm) {\r\nata_acpi_stm(ap, gtm);\r\nata_for_each_dev(dev, &ap->link, ALL) {\r\nata_acpi_clear_gtf(dev);\r\nif (ata_dev_enabled(dev) &&\r\nata_dev_acpi_handle(dev) &&\r\nata_dev_get_GTF(dev, NULL) >= 0)\r\ndev->flags |= ATA_DFLAG_ACPI_PENDING;\r\n}\r\n} else {\r\nata_for_each_dev(dev, &ap->link, ALL) {\r\nata_acpi_clear_gtf(dev);\r\nif (ata_dev_enabled(dev))\r\ndev->flags |= ATA_DFLAG_ACPI_PENDING;\r\n}\r\n}\r\n}\r\nstatic int ata_acpi_choose_suspend_state(struct ata_device *dev, bool runtime)\r\n{\r\nint d_max_in = ACPI_STATE_D3_COLD;\r\nif (!runtime)\r\ngoto out;\r\nif (dev->class == ATA_DEV_ATAPI &&\r\n!(zpodd_dev_enabled(dev) && zpodd_zpready(dev)))\r\nd_max_in = ACPI_STATE_D3_HOT;\r\nout:\r\nreturn acpi_pm_device_sleep_state(&dev->tdev, NULL, d_max_in);\r\n}\r\nstatic void sata_acpi_set_state(struct ata_port *ap, pm_message_t state)\r\n{\r\nbool runtime = PMSG_IS_AUTO(state);\r\nstruct ata_device *dev;\r\nacpi_handle handle;\r\nint acpi_state;\r\nata_for_each_dev(dev, &ap->link, ENABLED) {\r\nhandle = ata_dev_acpi_handle(dev);\r\nif (!handle)\r\ncontinue;\r\nif (!(state.event & PM_EVENT_RESUME)) {\r\nacpi_state = ata_acpi_choose_suspend_state(dev, runtime);\r\nif (acpi_state == ACPI_STATE_D0)\r\ncontinue;\r\nif (runtime && zpodd_dev_enabled(dev) &&\r\nacpi_state == ACPI_STATE_D3_COLD)\r\nzpodd_enable_run_wake(dev);\r\nacpi_bus_set_power(handle, acpi_state);\r\n} else {\r\nif (runtime && zpodd_dev_enabled(dev))\r\nzpodd_disable_run_wake(dev);\r\nacpi_bus_set_power(handle, ACPI_STATE_D0);\r\n}\r\n}\r\n}\r\nstatic void pata_acpi_set_state(struct ata_port *ap, pm_message_t state)\r\n{\r\nstruct ata_device *dev;\r\nacpi_handle port_handle;\r\nport_handle = ACPI_HANDLE(&ap->tdev);\r\nif (!port_handle)\r\nreturn;\r\nif (state.event & PM_EVENT_RESUME)\r\nacpi_bus_set_power(port_handle, ACPI_STATE_D0);\r\nata_for_each_dev(dev, &ap->link, ENABLED) {\r\nacpi_handle dev_handle = ata_dev_acpi_handle(dev);\r\nif (!dev_handle)\r\ncontinue;\r\nacpi_bus_set_power(dev_handle, state.event & PM_EVENT_RESUME ?\r\nACPI_STATE_D0 : ACPI_STATE_D3_COLD);\r\n}\r\nif (!(state.event & PM_EVENT_RESUME))\r\nacpi_bus_set_power(port_handle, ACPI_STATE_D3_COLD);\r\n}\r\nvoid ata_acpi_set_state(struct ata_port *ap, pm_message_t state)\r\n{\r\nif (ap->flags & ATA_FLAG_ACPI_SATA)\r\nsata_acpi_set_state(ap, state);\r\nelse\r\npata_acpi_set_state(ap, state);\r\n}\r\nint ata_acpi_on_devcfg(struct ata_device *dev)\r\n{\r\nstruct ata_port *ap = dev->link->ap;\r\nstruct ata_eh_context *ehc = &ap->link.eh_context;\r\nint acpi_sata = ap->flags & ATA_FLAG_ACPI_SATA;\r\nint nr_executed = 0;\r\nint rc;\r\nif (!ata_dev_acpi_handle(dev))\r\nreturn 0;\r\nif (!(dev->flags & ATA_DFLAG_ACPI_PENDING) &&\r\n!(acpi_sata && (ehc->i.flags & ATA_EHI_DID_HARDRESET)))\r\nreturn 0;\r\nif (acpi_sata) {\r\nrc = ata_acpi_push_id(dev);\r\nif (rc && rc != -ENOENT)\r\ngoto acpi_err;\r\n}\r\nrc = ata_acpi_exec_tfs(dev, &nr_executed);\r\nif (rc)\r\ngoto acpi_err;\r\ndev->flags &= ~ATA_DFLAG_ACPI_PENDING;\r\nif (nr_executed) {\r\nrc = ata_dev_reread_id(dev, 0);\r\nif (rc < 0) {\r\nata_dev_err(dev,\r\n"failed to IDENTIFY after ACPI commands\n");\r\nreturn rc;\r\n}\r\n}\r\nreturn 0;\r\nacpi_err:\r\nif (rc == -EINVAL && !nr_executed && !(ap->pflags & ATA_PFLAG_FROZEN))\r\nreturn 0;\r\nif (!(dev->flags & ATA_DFLAG_ACPI_FAILED)) {\r\ndev->flags |= ATA_DFLAG_ACPI_FAILED;\r\nreturn rc;\r\n}\r\ndev->flags |= ATA_DFLAG_ACPI_DISABLED;\r\nata_dev_warn(dev, "ACPI: failed the second time, disabled\n");\r\nif (!nr_executed && !(ap->pflags & ATA_PFLAG_FROZEN))\r\nreturn 0;\r\nreturn rc;\r\n}\r\nvoid ata_acpi_on_disable(struct ata_device *dev)\r\n{\r\nata_acpi_clear_gtf(dev);\r\n}
