static enum led_brightness input_leds_brightness_get(struct led_classdev *cdev)\r\n{\r\nstruct input_led *led = container_of(cdev, struct input_led, cdev);\r\nstruct input_dev *input = led->handle->dev;\r\nreturn test_bit(led->code, input->led) ? cdev->max_brightness : 0;\r\n}\r\nstatic void input_leds_brightness_set(struct led_classdev *cdev,\r\nenum led_brightness brightness)\r\n{\r\nstruct input_led *led = container_of(cdev, struct input_led, cdev);\r\ninput_inject_event(led->handle, EV_LED, led->code, !!brightness);\r\n}\r\nstatic void input_leds_event(struct input_handle *handle, unsigned int type,\r\nunsigned int code, int value)\r\n{\r\n}\r\nstatic int input_leds_get_count(struct input_dev *dev)\r\n{\r\nunsigned int led_code;\r\nint count = 0;\r\nfor_each_set_bit(led_code, dev->ledbit, LED_CNT)\r\nif (input_led_info[led_code].name)\r\ncount++;\r\nreturn count;\r\n}\r\nstatic int input_leds_connect(struct input_handler *handler,\r\nstruct input_dev *dev,\r\nconst struct input_device_id *id)\r\n{\r\nstruct input_leds *leds;\r\nunsigned int num_leds;\r\nunsigned int led_code;\r\nint led_no;\r\nint error;\r\nnum_leds = input_leds_get_count(dev);\r\nif (!num_leds)\r\nreturn -ENXIO;\r\nleds = kzalloc(sizeof(*leds) + num_leds * sizeof(*leds->leds),\r\nGFP_KERNEL);\r\nif (!leds)\r\nreturn -ENOMEM;\r\nleds->num_leds = num_leds;\r\nleds->handle.dev = dev;\r\nleds->handle.handler = handler;\r\nleds->handle.name = "leds";\r\nleds->handle.private = leds;\r\nerror = input_register_handle(&leds->handle);\r\nif (error)\r\ngoto err_free_mem;\r\nerror = input_open_device(&leds->handle);\r\nif (error)\r\ngoto err_unregister_handle;\r\nled_no = 0;\r\nfor_each_set_bit(led_code, dev->ledbit, LED_CNT) {\r\nstruct input_led *led = &leds->leds[led_no];\r\nled->handle = &leds->handle;\r\nled->code = led_code;\r\nif (!input_led_info[led_code].name)\r\ncontinue;\r\nled->cdev.name = kasprintf(GFP_KERNEL, "%s::%s",\r\ndev_name(&dev->dev),\r\ninput_led_info[led_code].name);\r\nif (!led->cdev.name) {\r\nerror = -ENOMEM;\r\ngoto err_unregister_leds;\r\n}\r\nled->cdev.max_brightness = 1;\r\nled->cdev.brightness_get = input_leds_brightness_get;\r\nled->cdev.brightness_set = input_leds_brightness_set;\r\nled->cdev.default_trigger = input_led_info[led_code].trigger;\r\nerror = led_classdev_register(&dev->dev, &led->cdev);\r\nif (error) {\r\ndev_err(&dev->dev, "failed to register LED %s: %d\n",\r\nled->cdev.name, error);\r\nkfree(led->cdev.name);\r\ngoto err_unregister_leds;\r\n}\r\nled_no++;\r\n}\r\nreturn 0;\r\nerr_unregister_leds:\r\nwhile (--led_no >= 0) {\r\nstruct input_led *led = &leds->leds[led_no];\r\nled_classdev_unregister(&led->cdev);\r\nkfree(led->cdev.name);\r\n}\r\ninput_close_device(&leds->handle);\r\nerr_unregister_handle:\r\ninput_unregister_handle(&leds->handle);\r\nerr_free_mem:\r\nkfree(leds);\r\nreturn error;\r\n}\r\nstatic void input_leds_disconnect(struct input_handle *handle)\r\n{\r\nstruct input_leds *leds = handle->private;\r\nint i;\r\nfor (i = 0; i < leds->num_leds; i++) {\r\nstruct input_led *led = &leds->leds[i];\r\nled_classdev_unregister(&led->cdev);\r\nkfree(led->cdev.name);\r\n}\r\ninput_close_device(handle);\r\ninput_unregister_handle(handle);\r\nkfree(leds);\r\n}\r\nstatic int __init input_leds_init(void)\r\n{\r\nreturn input_register_handler(&input_leds_handler);\r\n}\r\nstatic void __exit input_leds_exit(void)\r\n{\r\ninput_unregister_handler(&input_leds_handler);\r\n}
