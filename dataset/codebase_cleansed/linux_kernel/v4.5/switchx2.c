static void mlxsw_sx_txhdr_construct(struct sk_buff *skb,\r\nconst struct mlxsw_tx_info *tx_info)\r\n{\r\nchar *txhdr = skb_push(skb, MLXSW_TXHDR_LEN);\r\nbool is_emad = tx_info->is_emad;\r\nmemset(txhdr, 0, MLXSW_TXHDR_LEN);\r\nmlxsw_tx_hdr_version_set(txhdr, MLXSW_TXHDR_VERSION_0);\r\nmlxsw_tx_hdr_ctl_set(txhdr, MLXSW_TXHDR_ETH_CTL);\r\nmlxsw_tx_hdr_proto_set(txhdr, MLXSW_TXHDR_PROTO_ETH);\r\nmlxsw_tx_hdr_etclass_set(txhdr, is_emad ? MLXSW_TXHDR_ETCLASS_6 :\r\nMLXSW_TXHDR_ETCLASS_5);\r\nmlxsw_tx_hdr_swid_set(txhdr, 0);\r\nmlxsw_tx_hdr_port_mid_set(txhdr, tx_info->local_port);\r\nmlxsw_tx_hdr_ctclass3_set(txhdr, MLXSW_TXHDR_CTCLASS3);\r\nmlxsw_tx_hdr_rdq_set(txhdr, is_emad ? MLXSW_TXHDR_RDQ_EMAD :\r\nMLXSW_TXHDR_RDQ_OTHER);\r\nmlxsw_tx_hdr_cpu_sig_set(txhdr, MLXSW_TXHDR_CPU_SIG);\r\nmlxsw_tx_hdr_sig_set(txhdr, MLXSW_TXHDR_SIG);\r\nmlxsw_tx_hdr_stclass_set(txhdr, MLXSW_TXHDR_STCLASS_NONE);\r\nmlxsw_tx_hdr_emad_set(txhdr, is_emad ? MLXSW_TXHDR_EMAD :\r\nMLXSW_TXHDR_NOT_EMAD);\r\nmlxsw_tx_hdr_type_set(txhdr, MLXSW_TXHDR_TYPE_CONTROL);\r\n}\r\nstatic int mlxsw_sx_port_admin_status_set(struct mlxsw_sx_port *mlxsw_sx_port,\r\nbool is_up)\r\n{\r\nstruct mlxsw_sx *mlxsw_sx = mlxsw_sx_port->mlxsw_sx;\r\nchar paos_pl[MLXSW_REG_PAOS_LEN];\r\nmlxsw_reg_paos_pack(paos_pl, mlxsw_sx_port->local_port,\r\nis_up ? MLXSW_PORT_ADMIN_STATUS_UP :\r\nMLXSW_PORT_ADMIN_STATUS_DOWN);\r\nreturn mlxsw_reg_write(mlxsw_sx->core, MLXSW_REG(paos), paos_pl);\r\n}\r\nstatic int mlxsw_sx_port_oper_status_get(struct mlxsw_sx_port *mlxsw_sx_port,\r\nbool *p_is_up)\r\n{\r\nstruct mlxsw_sx *mlxsw_sx = mlxsw_sx_port->mlxsw_sx;\r\nchar paos_pl[MLXSW_REG_PAOS_LEN];\r\nu8 oper_status;\r\nint err;\r\nmlxsw_reg_paos_pack(paos_pl, mlxsw_sx_port->local_port, 0);\r\nerr = mlxsw_reg_query(mlxsw_sx->core, MLXSW_REG(paos), paos_pl);\r\nif (err)\r\nreturn err;\r\noper_status = mlxsw_reg_paos_oper_status_get(paos_pl);\r\n*p_is_up = oper_status == MLXSW_PORT_ADMIN_STATUS_UP ? true : false;\r\nreturn 0;\r\n}\r\nstatic int mlxsw_sx_port_mtu_set(struct mlxsw_sx_port *mlxsw_sx_port, u16 mtu)\r\n{\r\nstruct mlxsw_sx *mlxsw_sx = mlxsw_sx_port->mlxsw_sx;\r\nchar pmtu_pl[MLXSW_REG_PMTU_LEN];\r\nint max_mtu;\r\nint err;\r\nmtu += MLXSW_TXHDR_LEN + ETH_HLEN;\r\nmlxsw_reg_pmtu_pack(pmtu_pl, mlxsw_sx_port->local_port, 0);\r\nerr = mlxsw_reg_query(mlxsw_sx->core, MLXSW_REG(pmtu), pmtu_pl);\r\nif (err)\r\nreturn err;\r\nmax_mtu = mlxsw_reg_pmtu_max_mtu_get(pmtu_pl);\r\nif (mtu > max_mtu)\r\nreturn -EINVAL;\r\nmlxsw_reg_pmtu_pack(pmtu_pl, mlxsw_sx_port->local_port, mtu);\r\nreturn mlxsw_reg_write(mlxsw_sx->core, MLXSW_REG(pmtu), pmtu_pl);\r\n}\r\nstatic int mlxsw_sx_port_swid_set(struct mlxsw_sx_port *mlxsw_sx_port, u8 swid)\r\n{\r\nstruct mlxsw_sx *mlxsw_sx = mlxsw_sx_port->mlxsw_sx;\r\nchar pspa_pl[MLXSW_REG_PSPA_LEN];\r\nmlxsw_reg_pspa_pack(pspa_pl, swid, mlxsw_sx_port->local_port);\r\nreturn mlxsw_reg_write(mlxsw_sx->core, MLXSW_REG(pspa), pspa_pl);\r\n}\r\nstatic int\r\nmlxsw_sx_port_system_port_mapping_set(struct mlxsw_sx_port *mlxsw_sx_port)\r\n{\r\nstruct mlxsw_sx *mlxsw_sx = mlxsw_sx_port->mlxsw_sx;\r\nchar sspr_pl[MLXSW_REG_SSPR_LEN];\r\nmlxsw_reg_sspr_pack(sspr_pl, mlxsw_sx_port->local_port);\r\nreturn mlxsw_reg_write(mlxsw_sx->core, MLXSW_REG(sspr), sspr_pl);\r\n}\r\nstatic int mlxsw_sx_port_module_check(struct mlxsw_sx_port *mlxsw_sx_port,\r\nbool *p_usable)\r\n{\r\nstruct mlxsw_sx *mlxsw_sx = mlxsw_sx_port->mlxsw_sx;\r\nchar pmlp_pl[MLXSW_REG_PMLP_LEN];\r\nint err;\r\nmlxsw_reg_pmlp_pack(pmlp_pl, mlxsw_sx_port->local_port);\r\nerr = mlxsw_reg_query(mlxsw_sx->core, MLXSW_REG(pmlp), pmlp_pl);\r\nif (err)\r\nreturn err;\r\n*p_usable = mlxsw_reg_pmlp_width_get(pmlp_pl) ? true : false;\r\nreturn 0;\r\n}\r\nstatic int mlxsw_sx_port_open(struct net_device *dev)\r\n{\r\nstruct mlxsw_sx_port *mlxsw_sx_port = netdev_priv(dev);\r\nint err;\r\nerr = mlxsw_sx_port_admin_status_set(mlxsw_sx_port, true);\r\nif (err)\r\nreturn err;\r\nnetif_start_queue(dev);\r\nreturn 0;\r\n}\r\nstatic int mlxsw_sx_port_stop(struct net_device *dev)\r\n{\r\nstruct mlxsw_sx_port *mlxsw_sx_port = netdev_priv(dev);\r\nnetif_stop_queue(dev);\r\nreturn mlxsw_sx_port_admin_status_set(mlxsw_sx_port, false);\r\n}\r\nstatic netdev_tx_t mlxsw_sx_port_xmit(struct sk_buff *skb,\r\nstruct net_device *dev)\r\n{\r\nstruct mlxsw_sx_port *mlxsw_sx_port = netdev_priv(dev);\r\nstruct mlxsw_sx *mlxsw_sx = mlxsw_sx_port->mlxsw_sx;\r\nstruct mlxsw_sx_port_pcpu_stats *pcpu_stats;\r\nconst struct mlxsw_tx_info tx_info = {\r\n.local_port = mlxsw_sx_port->local_port,\r\n.is_emad = false,\r\n};\r\nu64 len;\r\nint err;\r\nif (mlxsw_core_skb_transmit_busy(mlxsw_sx, &tx_info))\r\nreturn NETDEV_TX_BUSY;\r\nif (unlikely(skb_headroom(skb) < MLXSW_TXHDR_LEN)) {\r\nstruct sk_buff *skb_orig = skb;\r\nskb = skb_realloc_headroom(skb, MLXSW_TXHDR_LEN);\r\nif (!skb) {\r\nthis_cpu_inc(mlxsw_sx_port->pcpu_stats->tx_dropped);\r\ndev_kfree_skb_any(skb_orig);\r\nreturn NETDEV_TX_OK;\r\n}\r\n}\r\nmlxsw_sx_txhdr_construct(skb, &tx_info);\r\nlen = skb->len;\r\nerr = mlxsw_core_skb_transmit(mlxsw_sx, skb, &tx_info);\r\nif (!err) {\r\npcpu_stats = this_cpu_ptr(mlxsw_sx_port->pcpu_stats);\r\nu64_stats_update_begin(&pcpu_stats->syncp);\r\npcpu_stats->tx_packets++;\r\npcpu_stats->tx_bytes += len;\r\nu64_stats_update_end(&pcpu_stats->syncp);\r\n} else {\r\nthis_cpu_inc(mlxsw_sx_port->pcpu_stats->tx_dropped);\r\ndev_kfree_skb_any(skb);\r\n}\r\nreturn NETDEV_TX_OK;\r\n}\r\nstatic int mlxsw_sx_port_change_mtu(struct net_device *dev, int mtu)\r\n{\r\nstruct mlxsw_sx_port *mlxsw_sx_port = netdev_priv(dev);\r\nint err;\r\nerr = mlxsw_sx_port_mtu_set(mlxsw_sx_port, mtu);\r\nif (err)\r\nreturn err;\r\ndev->mtu = mtu;\r\nreturn 0;\r\n}\r\nstatic struct rtnl_link_stats64 *\r\nmlxsw_sx_port_get_stats64(struct net_device *dev,\r\nstruct rtnl_link_stats64 *stats)\r\n{\r\nstruct mlxsw_sx_port *mlxsw_sx_port = netdev_priv(dev);\r\nstruct mlxsw_sx_port_pcpu_stats *p;\r\nu64 rx_packets, rx_bytes, tx_packets, tx_bytes;\r\nu32 tx_dropped = 0;\r\nunsigned int start;\r\nint i;\r\nfor_each_possible_cpu(i) {\r\np = per_cpu_ptr(mlxsw_sx_port->pcpu_stats, i);\r\ndo {\r\nstart = u64_stats_fetch_begin_irq(&p->syncp);\r\nrx_packets = p->rx_packets;\r\nrx_bytes = p->rx_bytes;\r\ntx_packets = p->tx_packets;\r\ntx_bytes = p->tx_bytes;\r\n} while (u64_stats_fetch_retry_irq(&p->syncp, start));\r\nstats->rx_packets += rx_packets;\r\nstats->rx_bytes += rx_bytes;\r\nstats->tx_packets += tx_packets;\r\nstats->tx_bytes += tx_bytes;\r\ntx_dropped += p->tx_dropped;\r\n}\r\nstats->tx_dropped = tx_dropped;\r\nreturn stats;\r\n}\r\nstatic void mlxsw_sx_port_get_drvinfo(struct net_device *dev,\r\nstruct ethtool_drvinfo *drvinfo)\r\n{\r\nstruct mlxsw_sx_port *mlxsw_sx_port = netdev_priv(dev);\r\nstruct mlxsw_sx *mlxsw_sx = mlxsw_sx_port->mlxsw_sx;\r\nstrlcpy(drvinfo->driver, mlxsw_sx_driver_name, sizeof(drvinfo->driver));\r\nstrlcpy(drvinfo->version, mlxsw_sx_driver_version,\r\nsizeof(drvinfo->version));\r\nsnprintf(drvinfo->fw_version, sizeof(drvinfo->fw_version),\r\n"%d.%d.%d",\r\nmlxsw_sx->bus_info->fw_rev.major,\r\nmlxsw_sx->bus_info->fw_rev.minor,\r\nmlxsw_sx->bus_info->fw_rev.subminor);\r\nstrlcpy(drvinfo->bus_info, mlxsw_sx->bus_info->device_name,\r\nsizeof(drvinfo->bus_info));\r\n}\r\nstatic void mlxsw_sx_port_get_strings(struct net_device *dev,\r\nu32 stringset, u8 *data)\r\n{\r\nu8 *p = data;\r\nint i;\r\nswitch (stringset) {\r\ncase ETH_SS_STATS:\r\nfor (i = 0; i < MLXSW_SX_PORT_HW_STATS_LEN; i++) {\r\nmemcpy(p, mlxsw_sx_port_hw_stats[i].str,\r\nETH_GSTRING_LEN);\r\np += ETH_GSTRING_LEN;\r\n}\r\nbreak;\r\n}\r\n}\r\nstatic void mlxsw_sx_port_get_stats(struct net_device *dev,\r\nstruct ethtool_stats *stats, u64 *data)\r\n{\r\nstruct mlxsw_sx_port *mlxsw_sx_port = netdev_priv(dev);\r\nstruct mlxsw_sx *mlxsw_sx = mlxsw_sx_port->mlxsw_sx;\r\nchar ppcnt_pl[MLXSW_REG_PPCNT_LEN];\r\nint i;\r\nint err;\r\nmlxsw_reg_ppcnt_pack(ppcnt_pl, mlxsw_sx_port->local_port);\r\nerr = mlxsw_reg_query(mlxsw_sx->core, MLXSW_REG(ppcnt), ppcnt_pl);\r\nfor (i = 0; i < MLXSW_SX_PORT_HW_STATS_LEN; i++)\r\ndata[i] = !err ? mlxsw_sx_port_hw_stats[i].getter(ppcnt_pl) : 0;\r\n}\r\nstatic int mlxsw_sx_port_get_sset_count(struct net_device *dev, int sset)\r\n{\r\nswitch (sset) {\r\ncase ETH_SS_STATS:\r\nreturn MLXSW_SX_PORT_HW_STATS_LEN;\r\ndefault:\r\nreturn -EOPNOTSUPP;\r\n}\r\n}\r\nstatic u32 mlxsw_sx_from_ptys_supported_port(u32 ptys_eth_proto)\r\n{\r\nif (ptys_eth_proto & (MLXSW_REG_PTYS_ETH_SPEED_10GBASE_CR |\r\nMLXSW_REG_PTYS_ETH_SPEED_10GBASE_SR |\r\nMLXSW_REG_PTYS_ETH_SPEED_40GBASE_CR4 |\r\nMLXSW_REG_PTYS_ETH_SPEED_40GBASE_SR4 |\r\nMLXSW_REG_PTYS_ETH_SPEED_100GBASE_SR4 |\r\nMLXSW_REG_PTYS_ETH_SPEED_SGMII))\r\nreturn SUPPORTED_FIBRE;\r\nif (ptys_eth_proto & (MLXSW_REG_PTYS_ETH_SPEED_10GBASE_KR |\r\nMLXSW_REG_PTYS_ETH_SPEED_10GBASE_KX4 |\r\nMLXSW_REG_PTYS_ETH_SPEED_40GBASE_KR4 |\r\nMLXSW_REG_PTYS_ETH_SPEED_100GBASE_KR4 |\r\nMLXSW_REG_PTYS_ETH_SPEED_1000BASE_KX))\r\nreturn SUPPORTED_Backplane;\r\nreturn 0;\r\n}\r\nstatic u32 mlxsw_sx_from_ptys_supported_link(u32 ptys_eth_proto)\r\n{\r\nu32 modes = 0;\r\nint i;\r\nfor (i = 0; i < MLXSW_SX_PORT_LINK_MODE_LEN; i++) {\r\nif (ptys_eth_proto & mlxsw_sx_port_link_mode[i].mask)\r\nmodes |= mlxsw_sx_port_link_mode[i].supported;\r\n}\r\nreturn modes;\r\n}\r\nstatic u32 mlxsw_sx_from_ptys_advert_link(u32 ptys_eth_proto)\r\n{\r\nu32 modes = 0;\r\nint i;\r\nfor (i = 0; i < MLXSW_SX_PORT_LINK_MODE_LEN; i++) {\r\nif (ptys_eth_proto & mlxsw_sx_port_link_mode[i].mask)\r\nmodes |= mlxsw_sx_port_link_mode[i].advertised;\r\n}\r\nreturn modes;\r\n}\r\nstatic void mlxsw_sx_from_ptys_speed_duplex(bool carrier_ok, u32 ptys_eth_proto,\r\nstruct ethtool_cmd *cmd)\r\n{\r\nu32 speed = SPEED_UNKNOWN;\r\nu8 duplex = DUPLEX_UNKNOWN;\r\nint i;\r\nif (!carrier_ok)\r\ngoto out;\r\nfor (i = 0; i < MLXSW_SX_PORT_LINK_MODE_LEN; i++) {\r\nif (ptys_eth_proto & mlxsw_sx_port_link_mode[i].mask) {\r\nspeed = mlxsw_sx_port_link_mode[i].speed;\r\nduplex = DUPLEX_FULL;\r\nbreak;\r\n}\r\n}\r\nout:\r\nethtool_cmd_speed_set(cmd, speed);\r\ncmd->duplex = duplex;\r\n}\r\nstatic u8 mlxsw_sx_port_connector_port(u32 ptys_eth_proto)\r\n{\r\nif (ptys_eth_proto & (MLXSW_REG_PTYS_ETH_SPEED_10GBASE_SR |\r\nMLXSW_REG_PTYS_ETH_SPEED_40GBASE_SR4 |\r\nMLXSW_REG_PTYS_ETH_SPEED_100GBASE_SR4 |\r\nMLXSW_REG_PTYS_ETH_SPEED_SGMII))\r\nreturn PORT_FIBRE;\r\nif (ptys_eth_proto & (MLXSW_REG_PTYS_ETH_SPEED_10GBASE_CR |\r\nMLXSW_REG_PTYS_ETH_SPEED_40GBASE_CR4 |\r\nMLXSW_REG_PTYS_ETH_SPEED_100GBASE_CR4))\r\nreturn PORT_DA;\r\nif (ptys_eth_proto & (MLXSW_REG_PTYS_ETH_SPEED_10GBASE_KR |\r\nMLXSW_REG_PTYS_ETH_SPEED_10GBASE_KX4 |\r\nMLXSW_REG_PTYS_ETH_SPEED_40GBASE_KR4 |\r\nMLXSW_REG_PTYS_ETH_SPEED_100GBASE_KR4))\r\nreturn PORT_NONE;\r\nreturn PORT_OTHER;\r\n}\r\nstatic int mlxsw_sx_port_get_settings(struct net_device *dev,\r\nstruct ethtool_cmd *cmd)\r\n{\r\nstruct mlxsw_sx_port *mlxsw_sx_port = netdev_priv(dev);\r\nstruct mlxsw_sx *mlxsw_sx = mlxsw_sx_port->mlxsw_sx;\r\nchar ptys_pl[MLXSW_REG_PTYS_LEN];\r\nu32 eth_proto_cap;\r\nu32 eth_proto_admin;\r\nu32 eth_proto_oper;\r\nint err;\r\nmlxsw_reg_ptys_pack(ptys_pl, mlxsw_sx_port->local_port, 0);\r\nerr = mlxsw_reg_query(mlxsw_sx->core, MLXSW_REG(ptys), ptys_pl);\r\nif (err) {\r\nnetdev_err(dev, "Failed to get proto");\r\nreturn err;\r\n}\r\nmlxsw_reg_ptys_unpack(ptys_pl, &eth_proto_cap,\r\n&eth_proto_admin, &eth_proto_oper);\r\ncmd->supported = mlxsw_sx_from_ptys_supported_port(eth_proto_cap) |\r\nmlxsw_sx_from_ptys_supported_link(eth_proto_cap) |\r\nSUPPORTED_Pause | SUPPORTED_Asym_Pause;\r\ncmd->advertising = mlxsw_sx_from_ptys_advert_link(eth_proto_admin);\r\nmlxsw_sx_from_ptys_speed_duplex(netif_carrier_ok(dev),\r\neth_proto_oper, cmd);\r\neth_proto_oper = eth_proto_oper ? eth_proto_oper : eth_proto_cap;\r\ncmd->port = mlxsw_sx_port_connector_port(eth_proto_oper);\r\ncmd->lp_advertising = mlxsw_sx_from_ptys_advert_link(eth_proto_oper);\r\ncmd->transceiver = XCVR_INTERNAL;\r\nreturn 0;\r\n}\r\nstatic u32 mlxsw_sx_to_ptys_advert_link(u32 advertising)\r\n{\r\nu32 ptys_proto = 0;\r\nint i;\r\nfor (i = 0; i < MLXSW_SX_PORT_LINK_MODE_LEN; i++) {\r\nif (advertising & mlxsw_sx_port_link_mode[i].advertised)\r\nptys_proto |= mlxsw_sx_port_link_mode[i].mask;\r\n}\r\nreturn ptys_proto;\r\n}\r\nstatic u32 mlxsw_sx_to_ptys_speed(u32 speed)\r\n{\r\nu32 ptys_proto = 0;\r\nint i;\r\nfor (i = 0; i < MLXSW_SX_PORT_LINK_MODE_LEN; i++) {\r\nif (speed == mlxsw_sx_port_link_mode[i].speed)\r\nptys_proto |= mlxsw_sx_port_link_mode[i].mask;\r\n}\r\nreturn ptys_proto;\r\n}\r\nstatic int mlxsw_sx_port_set_settings(struct net_device *dev,\r\nstruct ethtool_cmd *cmd)\r\n{\r\nstruct mlxsw_sx_port *mlxsw_sx_port = netdev_priv(dev);\r\nstruct mlxsw_sx *mlxsw_sx = mlxsw_sx_port->mlxsw_sx;\r\nchar ptys_pl[MLXSW_REG_PTYS_LEN];\r\nu32 speed;\r\nu32 eth_proto_new;\r\nu32 eth_proto_cap;\r\nu32 eth_proto_admin;\r\nbool is_up;\r\nint err;\r\nspeed = ethtool_cmd_speed(cmd);\r\neth_proto_new = cmd->autoneg == AUTONEG_ENABLE ?\r\nmlxsw_sx_to_ptys_advert_link(cmd->advertising) :\r\nmlxsw_sx_to_ptys_speed(speed);\r\nmlxsw_reg_ptys_pack(ptys_pl, mlxsw_sx_port->local_port, 0);\r\nerr = mlxsw_reg_query(mlxsw_sx->core, MLXSW_REG(ptys), ptys_pl);\r\nif (err) {\r\nnetdev_err(dev, "Failed to get proto");\r\nreturn err;\r\n}\r\nmlxsw_reg_ptys_unpack(ptys_pl, &eth_proto_cap, &eth_proto_admin, NULL);\r\neth_proto_new = eth_proto_new & eth_proto_cap;\r\nif (!eth_proto_new) {\r\nnetdev_err(dev, "Not supported proto admin requested");\r\nreturn -EINVAL;\r\n}\r\nif (eth_proto_new == eth_proto_admin)\r\nreturn 0;\r\nmlxsw_reg_ptys_pack(ptys_pl, mlxsw_sx_port->local_port, eth_proto_new);\r\nerr = mlxsw_reg_write(mlxsw_sx->core, MLXSW_REG(ptys), ptys_pl);\r\nif (err) {\r\nnetdev_err(dev, "Failed to set proto admin");\r\nreturn err;\r\n}\r\nerr = mlxsw_sx_port_oper_status_get(mlxsw_sx_port, &is_up);\r\nif (err) {\r\nnetdev_err(dev, "Failed to get oper status");\r\nreturn err;\r\n}\r\nif (!is_up)\r\nreturn 0;\r\nerr = mlxsw_sx_port_admin_status_set(mlxsw_sx_port, false);\r\nif (err) {\r\nnetdev_err(dev, "Failed to set admin status");\r\nreturn err;\r\n}\r\nerr = mlxsw_sx_port_admin_status_set(mlxsw_sx_port, true);\r\nif (err) {\r\nnetdev_err(dev, "Failed to set admin status");\r\nreturn err;\r\n}\r\nreturn 0;\r\n}\r\nstatic int mlxsw_sx_port_attr_get(struct net_device *dev,\r\nstruct switchdev_attr *attr)\r\n{\r\nstruct mlxsw_sx_port *mlxsw_sx_port = netdev_priv(dev);\r\nstruct mlxsw_sx *mlxsw_sx = mlxsw_sx_port->mlxsw_sx;\r\nswitch (attr->id) {\r\ncase SWITCHDEV_ATTR_ID_PORT_PARENT_ID:\r\nattr->u.ppid.id_len = sizeof(mlxsw_sx->hw_id);\r\nmemcpy(&attr->u.ppid.id, &mlxsw_sx->hw_id, attr->u.ppid.id_len);\r\nbreak;\r\ndefault:\r\nreturn -EOPNOTSUPP;\r\n}\r\nreturn 0;\r\n}\r\nstatic int mlxsw_sx_hw_id_get(struct mlxsw_sx *mlxsw_sx)\r\n{\r\nchar spad_pl[MLXSW_REG_SPAD_LEN];\r\nint err;\r\nerr = mlxsw_reg_query(mlxsw_sx->core, MLXSW_REG(spad), spad_pl);\r\nif (err)\r\nreturn err;\r\nmlxsw_reg_spad_base_mac_memcpy_from(spad_pl, mlxsw_sx->hw_id);\r\nreturn 0;\r\n}\r\nstatic int mlxsw_sx_port_dev_addr_get(struct mlxsw_sx_port *mlxsw_sx_port)\r\n{\r\nstruct mlxsw_sx *mlxsw_sx = mlxsw_sx_port->mlxsw_sx;\r\nstruct net_device *dev = mlxsw_sx_port->dev;\r\nchar ppad_pl[MLXSW_REG_PPAD_LEN];\r\nint err;\r\nmlxsw_reg_ppad_pack(ppad_pl, false, 0);\r\nerr = mlxsw_reg_query(mlxsw_sx->core, MLXSW_REG(ppad), ppad_pl);\r\nif (err)\r\nreturn err;\r\nmlxsw_reg_ppad_mac_memcpy_from(ppad_pl, dev->dev_addr);\r\ndev->dev_addr[ETH_ALEN - 1] += mlxsw_sx_port->local_port;\r\nreturn 0;\r\n}\r\nstatic int mlxsw_sx_port_stp_state_set(struct mlxsw_sx_port *mlxsw_sx_port,\r\nu16 vid, enum mlxsw_reg_spms_state state)\r\n{\r\nstruct mlxsw_sx *mlxsw_sx = mlxsw_sx_port->mlxsw_sx;\r\nchar *spms_pl;\r\nint err;\r\nspms_pl = kmalloc(MLXSW_REG_SPMS_LEN, GFP_KERNEL);\r\nif (!spms_pl)\r\nreturn -ENOMEM;\r\nmlxsw_reg_spms_pack(spms_pl, mlxsw_sx_port->local_port);\r\nmlxsw_reg_spms_vid_pack(spms_pl, vid, state);\r\nerr = mlxsw_reg_write(mlxsw_sx->core, MLXSW_REG(spms), spms_pl);\r\nkfree(spms_pl);\r\nreturn err;\r\n}\r\nstatic int mlxsw_sx_port_speed_set(struct mlxsw_sx_port *mlxsw_sx_port,\r\nu32 speed)\r\n{\r\nstruct mlxsw_sx *mlxsw_sx = mlxsw_sx_port->mlxsw_sx;\r\nchar ptys_pl[MLXSW_REG_PTYS_LEN];\r\nmlxsw_reg_ptys_pack(ptys_pl, mlxsw_sx_port->local_port, speed);\r\nreturn mlxsw_reg_write(mlxsw_sx->core, MLXSW_REG(ptys), ptys_pl);\r\n}\r\nstatic int\r\nmlxsw_sx_port_mac_learning_mode_set(struct mlxsw_sx_port *mlxsw_sx_port,\r\nenum mlxsw_reg_spmlr_learn_mode mode)\r\n{\r\nstruct mlxsw_sx *mlxsw_sx = mlxsw_sx_port->mlxsw_sx;\r\nchar spmlr_pl[MLXSW_REG_SPMLR_LEN];\r\nmlxsw_reg_spmlr_pack(spmlr_pl, mlxsw_sx_port->local_port, mode);\r\nreturn mlxsw_reg_write(mlxsw_sx->core, MLXSW_REG(spmlr), spmlr_pl);\r\n}\r\nstatic int mlxsw_sx_port_create(struct mlxsw_sx *mlxsw_sx, u8 local_port)\r\n{\r\nstruct mlxsw_sx_port *mlxsw_sx_port;\r\nstruct net_device *dev;\r\nbool usable;\r\nint err;\r\ndev = alloc_etherdev(sizeof(struct mlxsw_sx_port));\r\nif (!dev)\r\nreturn -ENOMEM;\r\nmlxsw_sx_port = netdev_priv(dev);\r\nmlxsw_sx_port->dev = dev;\r\nmlxsw_sx_port->mlxsw_sx = mlxsw_sx;\r\nmlxsw_sx_port->local_port = local_port;\r\nmlxsw_sx_port->pcpu_stats =\r\nnetdev_alloc_pcpu_stats(struct mlxsw_sx_port_pcpu_stats);\r\nif (!mlxsw_sx_port->pcpu_stats) {\r\nerr = -ENOMEM;\r\ngoto err_alloc_stats;\r\n}\r\ndev->netdev_ops = &mlxsw_sx_port_netdev_ops;\r\ndev->ethtool_ops = &mlxsw_sx_port_ethtool_ops;\r\ndev->switchdev_ops = &mlxsw_sx_port_switchdev_ops;\r\nerr = mlxsw_sx_port_dev_addr_get(mlxsw_sx_port);\r\nif (err) {\r\ndev_err(mlxsw_sx->bus_info->dev, "Port %d: Unable to get port mac address\n",\r\nmlxsw_sx_port->local_port);\r\ngoto err_dev_addr_get;\r\n}\r\nnetif_carrier_off(dev);\r\ndev->features |= NETIF_F_NETNS_LOCAL | NETIF_F_LLTX | NETIF_F_SG |\r\nNETIF_F_VLAN_CHALLENGED;\r\ndev->hard_header_len += MLXSW_TXHDR_LEN;\r\nerr = mlxsw_sx_port_module_check(mlxsw_sx_port, &usable);\r\nif (err) {\r\ndev_err(mlxsw_sx->bus_info->dev, "Port %d: Failed to check module\n",\r\nmlxsw_sx_port->local_port);\r\ngoto err_port_module_check;\r\n}\r\nif (!usable) {\r\ndev_dbg(mlxsw_sx->bus_info->dev, "Port %d: Not usable, skipping initialization\n",\r\nmlxsw_sx_port->local_port);\r\ngoto port_not_usable;\r\n}\r\nerr = mlxsw_sx_port_system_port_mapping_set(mlxsw_sx_port);\r\nif (err) {\r\ndev_err(mlxsw_sx->bus_info->dev, "Port %d: Failed to set system port mapping\n",\r\nmlxsw_sx_port->local_port);\r\ngoto err_port_system_port_mapping_set;\r\n}\r\nerr = mlxsw_sx_port_swid_set(mlxsw_sx_port, 0);\r\nif (err) {\r\ndev_err(mlxsw_sx->bus_info->dev, "Port %d: Failed to set SWID\n",\r\nmlxsw_sx_port->local_port);\r\ngoto err_port_swid_set;\r\n}\r\nerr = mlxsw_sx_port_speed_set(mlxsw_sx_port,\r\nMLXSW_REG_PTYS_ETH_SPEED_40GBASE_CR4);\r\nif (err) {\r\ndev_err(mlxsw_sx->bus_info->dev, "Port %d: Failed to set speed\n",\r\nmlxsw_sx_port->local_port);\r\ngoto err_port_speed_set;\r\n}\r\nerr = mlxsw_sx_port_mtu_set(mlxsw_sx_port, ETH_DATA_LEN);\r\nif (err) {\r\ndev_err(mlxsw_sx->bus_info->dev, "Port %d: Failed to set MTU\n",\r\nmlxsw_sx_port->local_port);\r\ngoto err_port_mtu_set;\r\n}\r\nerr = mlxsw_sx_port_admin_status_set(mlxsw_sx_port, false);\r\nif (err)\r\ngoto err_port_admin_status_set;\r\nerr = mlxsw_sx_port_stp_state_set(mlxsw_sx_port,\r\nMLXSW_PORT_DEFAULT_VID,\r\nMLXSW_REG_SPMS_STATE_FORWARDING);\r\nif (err) {\r\ndev_err(mlxsw_sx->bus_info->dev, "Port %d: Failed to set STP state\n",\r\nmlxsw_sx_port->local_port);\r\ngoto err_port_stp_state_set;\r\n}\r\nerr = mlxsw_sx_port_mac_learning_mode_set(mlxsw_sx_port,\r\nMLXSW_REG_SPMLR_LEARN_MODE_DISABLE);\r\nif (err) {\r\ndev_err(mlxsw_sx->bus_info->dev, "Port %d: Failed to set MAC learning mode\n",\r\nmlxsw_sx_port->local_port);\r\ngoto err_port_mac_learning_mode_set;\r\n}\r\nerr = register_netdev(dev);\r\nif (err) {\r\ndev_err(mlxsw_sx->bus_info->dev, "Port %d: Failed to register netdev\n",\r\nmlxsw_sx_port->local_port);\r\ngoto err_register_netdev;\r\n}\r\nmlxsw_sx->ports[local_port] = mlxsw_sx_port;\r\nreturn 0;\r\nerr_register_netdev:\r\nerr_port_mac_learning_mode_set:\r\nerr_port_stp_state_set:\r\nerr_port_admin_status_set:\r\nerr_port_mtu_set:\r\nerr_port_speed_set:\r\nerr_port_swid_set:\r\nerr_port_system_port_mapping_set:\r\nport_not_usable:\r\nerr_port_module_check:\r\nerr_dev_addr_get:\r\nfree_percpu(mlxsw_sx_port->pcpu_stats);\r\nerr_alloc_stats:\r\nfree_netdev(dev);\r\nreturn err;\r\n}\r\nstatic void mlxsw_sx_port_remove(struct mlxsw_sx *mlxsw_sx, u8 local_port)\r\n{\r\nstruct mlxsw_sx_port *mlxsw_sx_port = mlxsw_sx->ports[local_port];\r\nif (!mlxsw_sx_port)\r\nreturn;\r\nunregister_netdev(mlxsw_sx_port->dev);\r\nmlxsw_sx_port_swid_set(mlxsw_sx_port, MLXSW_PORT_SWID_DISABLED_PORT);\r\nfree_percpu(mlxsw_sx_port->pcpu_stats);\r\nfree_netdev(mlxsw_sx_port->dev);\r\n}\r\nstatic void mlxsw_sx_ports_remove(struct mlxsw_sx *mlxsw_sx)\r\n{\r\nint i;\r\nfor (i = 1; i < MLXSW_PORT_MAX_PORTS; i++)\r\nmlxsw_sx_port_remove(mlxsw_sx, i);\r\nkfree(mlxsw_sx->ports);\r\n}\r\nstatic int mlxsw_sx_ports_create(struct mlxsw_sx *mlxsw_sx)\r\n{\r\nsize_t alloc_size;\r\nint i;\r\nint err;\r\nalloc_size = sizeof(struct mlxsw_sx_port *) * MLXSW_PORT_MAX_PORTS;\r\nmlxsw_sx->ports = kzalloc(alloc_size, GFP_KERNEL);\r\nif (!mlxsw_sx->ports)\r\nreturn -ENOMEM;\r\nfor (i = 1; i < MLXSW_PORT_MAX_PORTS; i++) {\r\nerr = mlxsw_sx_port_create(mlxsw_sx, i);\r\nif (err)\r\ngoto err_port_create;\r\n}\r\nreturn 0;\r\nerr_port_create:\r\nfor (i--; i >= 1; i--)\r\nmlxsw_sx_port_remove(mlxsw_sx, i);\r\nkfree(mlxsw_sx->ports);\r\nreturn err;\r\n}\r\nstatic void mlxsw_sx_pude_event_func(const struct mlxsw_reg_info *reg,\r\nchar *pude_pl, void *priv)\r\n{\r\nstruct mlxsw_sx *mlxsw_sx = priv;\r\nstruct mlxsw_sx_port *mlxsw_sx_port;\r\nenum mlxsw_reg_pude_oper_status status;\r\nu8 local_port;\r\nlocal_port = mlxsw_reg_pude_local_port_get(pude_pl);\r\nmlxsw_sx_port = mlxsw_sx->ports[local_port];\r\nif (!mlxsw_sx_port) {\r\ndev_warn(mlxsw_sx->bus_info->dev, "Port %d: Link event received for non-existent port\n",\r\nlocal_port);\r\nreturn;\r\n}\r\nstatus = mlxsw_reg_pude_oper_status_get(pude_pl);\r\nif (status == MLXSW_PORT_OPER_STATUS_UP) {\r\nnetdev_info(mlxsw_sx_port->dev, "link up\n");\r\nnetif_carrier_on(mlxsw_sx_port->dev);\r\n} else {\r\nnetdev_info(mlxsw_sx_port->dev, "link down\n");\r\nnetif_carrier_off(mlxsw_sx_port->dev);\r\n}\r\n}\r\nstatic int mlxsw_sx_event_register(struct mlxsw_sx *mlxsw_sx,\r\nenum mlxsw_event_trap_id trap_id)\r\n{\r\nstruct mlxsw_event_listener *el;\r\nchar hpkt_pl[MLXSW_REG_HPKT_LEN];\r\nint err;\r\nswitch (trap_id) {\r\ncase MLXSW_TRAP_ID_PUDE:\r\nel = &mlxsw_sx_pude_event;\r\nbreak;\r\n}\r\nerr = mlxsw_core_event_listener_register(mlxsw_sx->core, el, mlxsw_sx);\r\nif (err)\r\nreturn err;\r\nmlxsw_reg_hpkt_pack(hpkt_pl, MLXSW_REG_HPKT_ACTION_FORWARD, trap_id);\r\nerr = mlxsw_reg_write(mlxsw_sx->core, MLXSW_REG(hpkt), hpkt_pl);\r\nif (err)\r\ngoto err_event_trap_set;\r\nreturn 0;\r\nerr_event_trap_set:\r\nmlxsw_core_event_listener_unregister(mlxsw_sx->core, el, mlxsw_sx);\r\nreturn err;\r\n}\r\nstatic void mlxsw_sx_event_unregister(struct mlxsw_sx *mlxsw_sx,\r\nenum mlxsw_event_trap_id trap_id)\r\n{\r\nstruct mlxsw_event_listener *el;\r\nswitch (trap_id) {\r\ncase MLXSW_TRAP_ID_PUDE:\r\nel = &mlxsw_sx_pude_event;\r\nbreak;\r\n}\r\nmlxsw_core_event_listener_unregister(mlxsw_sx->core, el, mlxsw_sx);\r\n}\r\nstatic void mlxsw_sx_rx_listener_func(struct sk_buff *skb, u8 local_port,\r\nvoid *priv)\r\n{\r\nstruct mlxsw_sx *mlxsw_sx = priv;\r\nstruct mlxsw_sx_port *mlxsw_sx_port = mlxsw_sx->ports[local_port];\r\nstruct mlxsw_sx_port_pcpu_stats *pcpu_stats;\r\nif (unlikely(!mlxsw_sx_port)) {\r\ndev_warn_ratelimited(mlxsw_sx->bus_info->dev, "Port %d: skb received for non-existent port\n",\r\nlocal_port);\r\nreturn;\r\n}\r\nskb->dev = mlxsw_sx_port->dev;\r\npcpu_stats = this_cpu_ptr(mlxsw_sx_port->pcpu_stats);\r\nu64_stats_update_begin(&pcpu_stats->syncp);\r\npcpu_stats->rx_packets++;\r\npcpu_stats->rx_bytes += skb->len;\r\nu64_stats_update_end(&pcpu_stats->syncp);\r\nskb->protocol = eth_type_trans(skb, skb->dev);\r\nnetif_receive_skb(skb);\r\n}\r\nstatic int mlxsw_sx_traps_init(struct mlxsw_sx *mlxsw_sx)\r\n{\r\nchar htgt_pl[MLXSW_REG_HTGT_LEN];\r\nchar hpkt_pl[MLXSW_REG_HPKT_LEN];\r\nint i;\r\nint err;\r\nmlxsw_reg_htgt_pack(htgt_pl, MLXSW_REG_HTGT_TRAP_GROUP_RX);\r\nerr = mlxsw_reg_write(mlxsw_sx->core, MLXSW_REG(htgt), htgt_pl);\r\nif (err)\r\nreturn err;\r\nmlxsw_reg_htgt_pack(htgt_pl, MLXSW_REG_HTGT_TRAP_GROUP_CTRL);\r\nerr = mlxsw_reg_write(mlxsw_sx->core, MLXSW_REG(htgt), htgt_pl);\r\nif (err)\r\nreturn err;\r\nfor (i = 0; i < ARRAY_SIZE(mlxsw_sx_rx_listener); i++) {\r\nerr = mlxsw_core_rx_listener_register(mlxsw_sx->core,\r\n&mlxsw_sx_rx_listener[i],\r\nmlxsw_sx);\r\nif (err)\r\ngoto err_rx_listener_register;\r\nmlxsw_reg_hpkt_pack(hpkt_pl, MLXSW_REG_HPKT_ACTION_TRAP_TO_CPU,\r\nmlxsw_sx_rx_listener[i].trap_id);\r\nerr = mlxsw_reg_write(mlxsw_sx->core, MLXSW_REG(hpkt), hpkt_pl);\r\nif (err)\r\ngoto err_rx_trap_set;\r\n}\r\nreturn 0;\r\nerr_rx_trap_set:\r\nmlxsw_core_rx_listener_unregister(mlxsw_sx->core,\r\n&mlxsw_sx_rx_listener[i],\r\nmlxsw_sx);\r\nerr_rx_listener_register:\r\nfor (i--; i >= 0; i--) {\r\nmlxsw_reg_hpkt_pack(hpkt_pl, MLXSW_REG_HPKT_ACTION_FORWARD,\r\nmlxsw_sx_rx_listener[i].trap_id);\r\nmlxsw_reg_write(mlxsw_sx->core, MLXSW_REG(hpkt), hpkt_pl);\r\nmlxsw_core_rx_listener_unregister(mlxsw_sx->core,\r\n&mlxsw_sx_rx_listener[i],\r\nmlxsw_sx);\r\n}\r\nreturn err;\r\n}\r\nstatic void mlxsw_sx_traps_fini(struct mlxsw_sx *mlxsw_sx)\r\n{\r\nchar hpkt_pl[MLXSW_REG_HPKT_LEN];\r\nint i;\r\nfor (i = 0; i < ARRAY_SIZE(mlxsw_sx_rx_listener); i++) {\r\nmlxsw_reg_hpkt_pack(hpkt_pl, MLXSW_REG_HPKT_ACTION_FORWARD,\r\nmlxsw_sx_rx_listener[i].trap_id);\r\nmlxsw_reg_write(mlxsw_sx->core, MLXSW_REG(hpkt), hpkt_pl);\r\nmlxsw_core_rx_listener_unregister(mlxsw_sx->core,\r\n&mlxsw_sx_rx_listener[i],\r\nmlxsw_sx);\r\n}\r\n}\r\nstatic int mlxsw_sx_flood_init(struct mlxsw_sx *mlxsw_sx)\r\n{\r\nchar sfgc_pl[MLXSW_REG_SFGC_LEN];\r\nchar sgcr_pl[MLXSW_REG_SGCR_LEN];\r\nchar *sftr_pl;\r\nint err;\r\nsftr_pl = kmalloc(MLXSW_REG_SFTR_LEN, GFP_KERNEL);\r\nif (!sftr_pl)\r\nreturn -ENOMEM;\r\nmlxsw_reg_sftr_pack(sftr_pl, 0, 0, MLXSW_REG_SFGC_TABLE_TYPE_SINGLE, 0,\r\nMLXSW_PORT_CPU_PORT, true);\r\nerr = mlxsw_reg_write(mlxsw_sx->core, MLXSW_REG(sftr), sftr_pl);\r\nkfree(sftr_pl);\r\nif (err)\r\nreturn err;\r\nmlxsw_reg_sfgc_pack(sfgc_pl,\r\nMLXSW_REG_SFGC_TYPE_UNKNOWN_UNICAST,\r\nMLXSW_REG_SFGC_BRIDGE_TYPE_1Q_FID,\r\nMLXSW_REG_SFGC_TABLE_TYPE_SINGLE,\r\n0);\r\nerr = mlxsw_reg_write(mlxsw_sx->core, MLXSW_REG(sfgc), sfgc_pl);\r\nif (err)\r\nreturn err;\r\nmlxsw_reg_sfgc_pack(sfgc_pl,\r\nMLXSW_REG_SFGC_TYPE_BROADCAST,\r\nMLXSW_REG_SFGC_BRIDGE_TYPE_1Q_FID,\r\nMLXSW_REG_SFGC_TABLE_TYPE_SINGLE,\r\n0);\r\nerr = mlxsw_reg_write(mlxsw_sx->core, MLXSW_REG(sfgc), sfgc_pl);\r\nif (err)\r\nreturn err;\r\nmlxsw_reg_sfgc_pack(sfgc_pl,\r\nMLXSW_REG_SFGC_TYPE_UNREGISTERED_MULTICAST_NON_IP,\r\nMLXSW_REG_SFGC_BRIDGE_TYPE_1Q_FID,\r\nMLXSW_REG_SFGC_TABLE_TYPE_SINGLE,\r\n0);\r\nerr = mlxsw_reg_write(mlxsw_sx->core, MLXSW_REG(sfgc), sfgc_pl);\r\nif (err)\r\nreturn err;\r\nmlxsw_reg_sfgc_pack(sfgc_pl,\r\nMLXSW_REG_SFGC_TYPE_UNREGISTERED_MULTICAST_IPV6,\r\nMLXSW_REG_SFGC_BRIDGE_TYPE_1Q_FID,\r\nMLXSW_REG_SFGC_TABLE_TYPE_SINGLE,\r\n0);\r\nerr = mlxsw_reg_write(mlxsw_sx->core, MLXSW_REG(sfgc), sfgc_pl);\r\nif (err)\r\nreturn err;\r\nmlxsw_reg_sfgc_pack(sfgc_pl,\r\nMLXSW_REG_SFGC_TYPE_UNREGISTERED_MULTICAST_IPV4,\r\nMLXSW_REG_SFGC_BRIDGE_TYPE_1Q_FID,\r\nMLXSW_REG_SFGC_TABLE_TYPE_SINGLE,\r\n0);\r\nerr = mlxsw_reg_write(mlxsw_sx->core, MLXSW_REG(sfgc), sfgc_pl);\r\nif (err)\r\nreturn err;\r\nmlxsw_reg_sgcr_pack(sgcr_pl, true);\r\nreturn mlxsw_reg_write(mlxsw_sx->core, MLXSW_REG(sgcr), sgcr_pl);\r\n}\r\nstatic int mlxsw_sx_init(void *priv, struct mlxsw_core *mlxsw_core,\r\nconst struct mlxsw_bus_info *mlxsw_bus_info)\r\n{\r\nstruct mlxsw_sx *mlxsw_sx = priv;\r\nint err;\r\nmlxsw_sx->core = mlxsw_core;\r\nmlxsw_sx->bus_info = mlxsw_bus_info;\r\nerr = mlxsw_sx_hw_id_get(mlxsw_sx);\r\nif (err) {\r\ndev_err(mlxsw_sx->bus_info->dev, "Failed to get switch HW ID\n");\r\nreturn err;\r\n}\r\nerr = mlxsw_sx_ports_create(mlxsw_sx);\r\nif (err) {\r\ndev_err(mlxsw_sx->bus_info->dev, "Failed to create ports\n");\r\nreturn err;\r\n}\r\nerr = mlxsw_sx_event_register(mlxsw_sx, MLXSW_TRAP_ID_PUDE);\r\nif (err) {\r\ndev_err(mlxsw_sx->bus_info->dev, "Failed to register for PUDE events\n");\r\ngoto err_event_register;\r\n}\r\nerr = mlxsw_sx_traps_init(mlxsw_sx);\r\nif (err) {\r\ndev_err(mlxsw_sx->bus_info->dev, "Failed to set traps for RX\n");\r\ngoto err_rx_listener_register;\r\n}\r\nerr = mlxsw_sx_flood_init(mlxsw_sx);\r\nif (err) {\r\ndev_err(mlxsw_sx->bus_info->dev, "Failed to initialize flood tables\n");\r\ngoto err_flood_init;\r\n}\r\nreturn 0;\r\nerr_flood_init:\r\nmlxsw_sx_traps_fini(mlxsw_sx);\r\nerr_rx_listener_register:\r\nmlxsw_sx_event_unregister(mlxsw_sx, MLXSW_TRAP_ID_PUDE);\r\nerr_event_register:\r\nmlxsw_sx_ports_remove(mlxsw_sx);\r\nreturn err;\r\n}\r\nstatic void mlxsw_sx_fini(void *priv)\r\n{\r\nstruct mlxsw_sx *mlxsw_sx = priv;\r\nmlxsw_sx_traps_fini(mlxsw_sx);\r\nmlxsw_sx_event_unregister(mlxsw_sx, MLXSW_TRAP_ID_PUDE);\r\nmlxsw_sx_ports_remove(mlxsw_sx);\r\n}\r\nstatic int __init mlxsw_sx_module_init(void)\r\n{\r\nreturn mlxsw_core_driver_register(&mlxsw_sx_driver);\r\n}\r\nstatic void __exit mlxsw_sx_module_exit(void)\r\n{\r\nmlxsw_core_driver_unregister(&mlxsw_sx_driver);\r\n}
