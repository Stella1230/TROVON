static int early_page_owner_param(char *buf)\r\n{\r\nif (!buf)\r\nreturn -EINVAL;\r\nif (strcmp(buf, "on") == 0)\r\npage_owner_disabled = false;\r\nreturn 0;\r\n}\r\nstatic bool need_page_owner(void)\r\n{\r\nif (page_owner_disabled)\r\nreturn false;\r\nreturn true;\r\n}\r\nstatic void init_page_owner(void)\r\n{\r\nif (page_owner_disabled)\r\nreturn;\r\npage_owner_inited = true;\r\ninit_early_allocated_pages();\r\n}\r\nvoid __reset_page_owner(struct page *page, unsigned int order)\r\n{\r\nint i;\r\nstruct page_ext *page_ext;\r\nfor (i = 0; i < (1 << order); i++) {\r\npage_ext = lookup_page_ext(page + i);\r\n__clear_bit(PAGE_EXT_OWNER, &page_ext->flags);\r\n}\r\n}\r\nvoid __set_page_owner(struct page *page, unsigned int order, gfp_t gfp_mask)\r\n{\r\nstruct page_ext *page_ext = lookup_page_ext(page);\r\nstruct stack_trace trace = {\r\n.nr_entries = 0,\r\n.max_entries = ARRAY_SIZE(page_ext->trace_entries),\r\n.entries = &page_ext->trace_entries[0],\r\n.skip = 3,\r\n};\r\nsave_stack_trace(&trace);\r\npage_ext->order = order;\r\npage_ext->gfp_mask = gfp_mask;\r\npage_ext->nr_entries = trace.nr_entries;\r\n__set_bit(PAGE_EXT_OWNER, &page_ext->flags);\r\n}\r\ngfp_t __get_page_owner_gfp(struct page *page)\r\n{\r\nstruct page_ext *page_ext = lookup_page_ext(page);\r\nreturn page_ext->gfp_mask;\r\n}\r\nstatic ssize_t\r\nprint_page_owner(char __user *buf, size_t count, unsigned long pfn,\r\nstruct page *page, struct page_ext *page_ext)\r\n{\r\nint ret;\r\nint pageblock_mt, page_mt;\r\nchar *kbuf;\r\nstruct stack_trace trace = {\r\n.nr_entries = page_ext->nr_entries,\r\n.entries = &page_ext->trace_entries[0],\r\n};\r\nkbuf = kmalloc(count, GFP_KERNEL);\r\nif (!kbuf)\r\nreturn -ENOMEM;\r\nret = snprintf(kbuf, count,\r\n"Page allocated via order %u, mask 0x%x\n",\r\npage_ext->order, page_ext->gfp_mask);\r\nif (ret >= count)\r\ngoto err;\r\npageblock_mt = get_pfnblock_migratetype(page, pfn);\r\npage_mt = gfpflags_to_migratetype(page_ext->gfp_mask);\r\nret += snprintf(kbuf + ret, count - ret,\r\n"PFN %lu Block %lu type %d %s Flags %s%s%s%s%s%s%s%s%s%s%s%s\n",\r\npfn,\r\npfn >> pageblock_order,\r\npageblock_mt,\r\npageblock_mt != page_mt ? "Fallback" : " ",\r\nPageLocked(page) ? "K" : " ",\r\nPageError(page) ? "E" : " ",\r\nPageReferenced(page) ? "R" : " ",\r\nPageUptodate(page) ? "U" : " ",\r\nPageDirty(page) ? "D" : " ",\r\nPageLRU(page) ? "L" : " ",\r\nPageActive(page) ? "A" : " ",\r\nPageSlab(page) ? "S" : " ",\r\nPageWriteback(page) ? "W" : " ",\r\nPageCompound(page) ? "C" : " ",\r\nPageSwapCache(page) ? "B" : " ",\r\nPageMappedToDisk(page) ? "M" : " ");\r\nif (ret >= count)\r\ngoto err;\r\nret += snprint_stack_trace(kbuf + ret, count - ret, &trace, 0);\r\nif (ret >= count)\r\ngoto err;\r\nret += snprintf(kbuf + ret, count - ret, "\n");\r\nif (ret >= count)\r\ngoto err;\r\nif (copy_to_user(buf, kbuf, ret))\r\nret = -EFAULT;\r\nkfree(kbuf);\r\nreturn ret;\r\nerr:\r\nkfree(kbuf);\r\nreturn -ENOMEM;\r\n}\r\nstatic ssize_t\r\nread_page_owner(struct file *file, char __user *buf, size_t count, loff_t *ppos)\r\n{\r\nunsigned long pfn;\r\nstruct page *page;\r\nstruct page_ext *page_ext;\r\nif (!page_owner_inited)\r\nreturn -EINVAL;\r\npage = NULL;\r\npfn = min_low_pfn + *ppos;\r\nwhile (!pfn_valid(pfn) && (pfn & (MAX_ORDER_NR_PAGES - 1)) != 0)\r\npfn++;\r\ndrain_all_pages(NULL);\r\nfor (; pfn < max_pfn; pfn++) {\r\nif ((pfn & (MAX_ORDER_NR_PAGES - 1)) == 0 && !pfn_valid(pfn)) {\r\npfn += MAX_ORDER_NR_PAGES - 1;\r\ncontinue;\r\n}\r\nif (!pfn_valid_within(pfn))\r\ncontinue;\r\npage = pfn_to_page(pfn);\r\nif (PageBuddy(page)) {\r\nunsigned long freepage_order = page_order_unsafe(page);\r\nif (freepage_order < MAX_ORDER)\r\npfn += (1UL << freepage_order) - 1;\r\ncontinue;\r\n}\r\npage_ext = lookup_page_ext(page);\r\nif (!test_bit(PAGE_EXT_OWNER, &page_ext->flags))\r\ncontinue;\r\n*ppos = (pfn - min_low_pfn) + 1;\r\nreturn print_page_owner(buf, count, pfn, page, page_ext);\r\n}\r\nreturn 0;\r\n}\r\nstatic void init_pages_in_zone(pg_data_t *pgdat, struct zone *zone)\r\n{\r\nstruct page *page;\r\nstruct page_ext *page_ext;\r\nunsigned long pfn = zone->zone_start_pfn, block_end_pfn;\r\nunsigned long end_pfn = pfn + zone->spanned_pages;\r\nunsigned long count = 0;\r\npfn = zone->zone_start_pfn;\r\nfor (; pfn < end_pfn; ) {\r\nif (!pfn_valid(pfn)) {\r\npfn = ALIGN(pfn + 1, MAX_ORDER_NR_PAGES);\r\ncontinue;\r\n}\r\nblock_end_pfn = ALIGN(pfn + 1, pageblock_nr_pages);\r\nblock_end_pfn = min(block_end_pfn, end_pfn);\r\npage = pfn_to_page(pfn);\r\nfor (; pfn < block_end_pfn; pfn++) {\r\nif (!pfn_valid_within(pfn))\r\ncontinue;\r\npage = pfn_to_page(pfn);\r\nif (PageBuddy(page)) {\r\npfn += (1UL << page_order(page)) - 1;\r\ncontinue;\r\n}\r\nif (PageReserved(page))\r\ncontinue;\r\npage_ext = lookup_page_ext(page);\r\nif (test_bit(PAGE_EXT_OWNER, &page_ext->flags))\r\ncontinue;\r\nset_page_owner(page, 0, 0);\r\ncount++;\r\n}\r\n}\r\npr_info("Node %d, zone %8s: page owner found early allocated %lu pages\n",\r\npgdat->node_id, zone->name, count);\r\n}\r\nstatic void init_zones_in_node(pg_data_t *pgdat)\r\n{\r\nstruct zone *zone;\r\nstruct zone *node_zones = pgdat->node_zones;\r\nunsigned long flags;\r\nfor (zone = node_zones; zone - node_zones < MAX_NR_ZONES; ++zone) {\r\nif (!populated_zone(zone))\r\ncontinue;\r\nspin_lock_irqsave(&zone->lock, flags);\r\ninit_pages_in_zone(pgdat, zone);\r\nspin_unlock_irqrestore(&zone->lock, flags);\r\n}\r\n}\r\nstatic void init_early_allocated_pages(void)\r\n{\r\npg_data_t *pgdat;\r\ndrain_all_pages(NULL);\r\nfor_each_online_pgdat(pgdat)\r\ninit_zones_in_node(pgdat);\r\n}\r\nstatic int __init pageowner_init(void)\r\n{\r\nstruct dentry *dentry;\r\nif (!page_owner_inited) {\r\npr_info("page_owner is disabled\n");\r\nreturn 0;\r\n}\r\ndentry = debugfs_create_file("page_owner", S_IRUSR, NULL,\r\nNULL, &proc_page_owner_operations);\r\nif (IS_ERR(dentry))\r\nreturn PTR_ERR(dentry);\r\nreturn 0;\r\n}
