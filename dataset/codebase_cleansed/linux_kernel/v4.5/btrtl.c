static int rtl_read_rom_version(struct hci_dev *hdev, u8 *version)\r\n{\r\nstruct rtl_rom_version_evt *rom_version;\r\nstruct sk_buff *skb;\r\nskb = __hci_cmd_sync(hdev, 0xfc6d, 0, NULL, HCI_INIT_TIMEOUT);\r\nif (IS_ERR(skb)) {\r\nBT_ERR("%s: Read ROM version failed (%ld)",\r\nhdev->name, PTR_ERR(skb));\r\nreturn PTR_ERR(skb);\r\n}\r\nif (skb->len != sizeof(*rom_version)) {\r\nBT_ERR("%s: RTL version event length mismatch", hdev->name);\r\nkfree_skb(skb);\r\nreturn -EIO;\r\n}\r\nrom_version = (struct rtl_rom_version_evt *)skb->data;\r\nBT_INFO("%s: rom_version status=%x version=%x",\r\nhdev->name, rom_version->status, rom_version->version);\r\n*version = rom_version->version;\r\nkfree_skb(skb);\r\nreturn 0;\r\n}\r\nstatic int rtl8723b_parse_firmware(struct hci_dev *hdev, u16 lmp_subver,\r\nconst struct firmware *fw,\r\nunsigned char **_buf)\r\n{\r\nconst u8 extension_sig[] = { 0x51, 0x04, 0xfd, 0x77 };\r\nstruct rtl_epatch_header *epatch_info;\r\nunsigned char *buf;\r\nint i, ret, len;\r\nsize_t min_size;\r\nu8 opcode, length, data, rom_version = 0;\r\nint project_id = -1;\r\nconst unsigned char *fwptr, *chip_id_base;\r\nconst unsigned char *patch_length_base, *patch_offset_base;\r\nu32 patch_offset = 0;\r\nu16 patch_length, num_patches;\r\nconst u16 project_id_to_lmp_subver[] = {\r\nRTL_ROM_LMP_8723A,\r\nRTL_ROM_LMP_8723B,\r\nRTL_ROM_LMP_8821A,\r\nRTL_ROM_LMP_8761A\r\n};\r\nret = rtl_read_rom_version(hdev, &rom_version);\r\nif (ret)\r\nreturn ret;\r\nmin_size = sizeof(struct rtl_epatch_header) + sizeof(extension_sig) + 3;\r\nif (fw->size < min_size)\r\nreturn -EINVAL;\r\nfwptr = fw->data + fw->size - sizeof(extension_sig);\r\nif (memcmp(fwptr, extension_sig, sizeof(extension_sig)) != 0) {\r\nBT_ERR("%s: extension section signature mismatch", hdev->name);\r\nreturn -EINVAL;\r\n}\r\nwhile (fwptr >= fw->data + (sizeof(struct rtl_epatch_header) + 3)) {\r\nopcode = *--fwptr;\r\nlength = *--fwptr;\r\ndata = *--fwptr;\r\nBT_DBG("check op=%x len=%x data=%x", opcode, length, data);\r\nif (opcode == 0xff)\r\nbreak;\r\nif (length == 0) {\r\nBT_ERR("%s: found instruction with length 0",\r\nhdev->name);\r\nreturn -EINVAL;\r\n}\r\nif (opcode == 0 && length == 1) {\r\nproject_id = data;\r\nbreak;\r\n}\r\nfwptr -= length;\r\n}\r\nif (project_id < 0) {\r\nBT_ERR("%s: failed to find version instruction", hdev->name);\r\nreturn -EINVAL;\r\n}\r\nif (project_id >= ARRAY_SIZE(project_id_to_lmp_subver)) {\r\nBT_ERR("%s: unknown project id %d", hdev->name, project_id);\r\nreturn -EINVAL;\r\n}\r\nif (lmp_subver != project_id_to_lmp_subver[project_id]) {\r\nBT_ERR("%s: firmware is for %x but this is a %x", hdev->name,\r\nproject_id_to_lmp_subver[project_id], lmp_subver);\r\nreturn -EINVAL;\r\n}\r\nepatch_info = (struct rtl_epatch_header *)fw->data;\r\nif (memcmp(epatch_info->signature, RTL_EPATCH_SIGNATURE, 8) != 0) {\r\nBT_ERR("%s: bad EPATCH signature", hdev->name);\r\nreturn -EINVAL;\r\n}\r\nnum_patches = le16_to_cpu(epatch_info->num_patches);\r\nBT_DBG("fw_version=%x, num_patches=%d",\r\nle32_to_cpu(epatch_info->fw_version), num_patches);\r\nmin_size += 8 * num_patches;\r\nif (fw->size < min_size)\r\nreturn -EINVAL;\r\nchip_id_base = fw->data + sizeof(struct rtl_epatch_header);\r\npatch_length_base = chip_id_base + (sizeof(u16) * num_patches);\r\npatch_offset_base = patch_length_base + (sizeof(u16) * num_patches);\r\nfor (i = 0; i < num_patches; i++) {\r\nu16 chip_id = get_unaligned_le16(chip_id_base +\r\n(i * sizeof(u16)));\r\nif (chip_id == rom_version + 1) {\r\npatch_length = get_unaligned_le16(patch_length_base +\r\n(i * sizeof(u16)));\r\npatch_offset = get_unaligned_le32(patch_offset_base +\r\n(i * sizeof(u32)));\r\nbreak;\r\n}\r\n}\r\nif (!patch_offset) {\r\nBT_ERR("%s: didn't find patch for chip id %d",\r\nhdev->name, rom_version);\r\nreturn -EINVAL;\r\n}\r\nBT_DBG("length=%x offset=%x index %d", patch_length, patch_offset, i);\r\nmin_size = patch_offset + patch_length;\r\nif (fw->size < min_size)\r\nreturn -EINVAL;\r\nlen = patch_length;\r\nbuf = kmemdup(fw->data + patch_offset, patch_length, GFP_KERNEL);\r\nif (!buf)\r\nreturn -ENOMEM;\r\nmemcpy(buf + patch_length - 4, &epatch_info->fw_version, 4);\r\n*_buf = buf;\r\nreturn len;\r\n}\r\nstatic int rtl_download_firmware(struct hci_dev *hdev,\r\nconst unsigned char *data, int fw_len)\r\n{\r\nstruct rtl_download_cmd *dl_cmd;\r\nint frag_num = fw_len / RTL_FRAG_LEN + 1;\r\nint frag_len = RTL_FRAG_LEN;\r\nint ret = 0;\r\nint i;\r\ndl_cmd = kmalloc(sizeof(struct rtl_download_cmd), GFP_KERNEL);\r\nif (!dl_cmd)\r\nreturn -ENOMEM;\r\nfor (i = 0; i < frag_num; i++) {\r\nstruct sk_buff *skb;\r\nBT_DBG("download fw (%d/%d)", i, frag_num);\r\ndl_cmd->index = i;\r\nif (i == (frag_num - 1)) {\r\ndl_cmd->index |= 0x80;\r\nfrag_len = fw_len % RTL_FRAG_LEN;\r\n}\r\nmemcpy(dl_cmd->data, data, frag_len);\r\nskb = __hci_cmd_sync(hdev, 0xfc20, frag_len + 1, dl_cmd,\r\nHCI_INIT_TIMEOUT);\r\nif (IS_ERR(skb)) {\r\nBT_ERR("%s: download fw command failed (%ld)",\r\nhdev->name, PTR_ERR(skb));\r\nret = -PTR_ERR(skb);\r\ngoto out;\r\n}\r\nif (skb->len != sizeof(struct rtl_download_response)) {\r\nBT_ERR("%s: download fw event length mismatch",\r\nhdev->name);\r\nkfree_skb(skb);\r\nret = -EIO;\r\ngoto out;\r\n}\r\nkfree_skb(skb);\r\ndata += RTL_FRAG_LEN;\r\n}\r\nout:\r\nkfree(dl_cmd);\r\nreturn ret;\r\n}\r\nstatic int btrtl_setup_rtl8723a(struct hci_dev *hdev)\r\n{\r\nconst struct firmware *fw;\r\nint ret;\r\nBT_INFO("%s: rtl: loading rtl_bt/rtl8723a_fw.bin", hdev->name);\r\nret = request_firmware(&fw, "rtl_bt/rtl8723a_fw.bin", &hdev->dev);\r\nif (ret < 0) {\r\nBT_ERR("%s: Failed to load rtl_bt/rtl8723a_fw.bin", hdev->name);\r\nreturn ret;\r\n}\r\nif (fw->size < 8) {\r\nret = -EINVAL;\r\ngoto out;\r\n}\r\nif (!memcmp(fw->data, RTL_EPATCH_SIGNATURE, 8)) {\r\nBT_ERR("%s: unexpected EPATCH signature!", hdev->name);\r\nret = -EINVAL;\r\ngoto out;\r\n}\r\nret = rtl_download_firmware(hdev, fw->data, fw->size);\r\nout:\r\nrelease_firmware(fw);\r\nreturn ret;\r\n}\r\nstatic int btrtl_setup_rtl8723b(struct hci_dev *hdev, u16 lmp_subver,\r\nconst char *fw_name)\r\n{\r\nunsigned char *fw_data = NULL;\r\nconst struct firmware *fw;\r\nint ret;\r\nBT_INFO("%s: rtl: loading %s", hdev->name, fw_name);\r\nret = request_firmware(&fw, fw_name, &hdev->dev);\r\nif (ret < 0) {\r\nBT_ERR("%s: Failed to load %s", hdev->name, fw_name);\r\nreturn ret;\r\n}\r\nret = rtl8723b_parse_firmware(hdev, lmp_subver, fw, &fw_data);\r\nif (ret < 0)\r\ngoto out;\r\nret = rtl_download_firmware(hdev, fw_data, ret);\r\nkfree(fw_data);\r\nif (ret < 0)\r\ngoto out;\r\nout:\r\nrelease_firmware(fw);\r\nreturn ret;\r\n}\r\nstatic struct sk_buff *btrtl_read_local_version(struct hci_dev *hdev)\r\n{\r\nstruct sk_buff *skb;\r\nskb = __hci_cmd_sync(hdev, HCI_OP_READ_LOCAL_VERSION, 0, NULL,\r\nHCI_INIT_TIMEOUT);\r\nif (IS_ERR(skb)) {\r\nBT_ERR("%s: HCI_OP_READ_LOCAL_VERSION failed (%ld)",\r\nhdev->name, PTR_ERR(skb));\r\nreturn skb;\r\n}\r\nif (skb->len != sizeof(struct hci_rp_read_local_version)) {\r\nBT_ERR("%s: HCI_OP_READ_LOCAL_VERSION event length mismatch",\r\nhdev->name);\r\nkfree_skb(skb);\r\nreturn ERR_PTR(-EIO);\r\n}\r\nreturn skb;\r\n}\r\nint btrtl_setup_realtek(struct hci_dev *hdev)\r\n{\r\nstruct sk_buff *skb;\r\nstruct hci_rp_read_local_version *resp;\r\nu16 lmp_subver;\r\nskb = btrtl_read_local_version(hdev);\r\nif (IS_ERR(skb))\r\nreturn -PTR_ERR(skb);\r\nresp = (struct hci_rp_read_local_version *)skb->data;\r\nBT_INFO("%s: rtl: examining hci_ver=%02x hci_rev=%04x lmp_ver=%02x "\r\n"lmp_subver=%04x", hdev->name, resp->hci_ver, resp->hci_rev,\r\nresp->lmp_ver, resp->lmp_subver);\r\nlmp_subver = le16_to_cpu(resp->lmp_subver);\r\nkfree_skb(skb);\r\nswitch (lmp_subver) {\r\ncase RTL_ROM_LMP_8723A:\r\ncase RTL_ROM_LMP_3499:\r\nreturn btrtl_setup_rtl8723a(hdev);\r\ncase RTL_ROM_LMP_8723B:\r\nreturn btrtl_setup_rtl8723b(hdev, lmp_subver,\r\n"rtl_bt/rtl8723b_fw.bin");\r\ncase RTL_ROM_LMP_8821A:\r\nreturn btrtl_setup_rtl8723b(hdev, lmp_subver,\r\n"rtl_bt/rtl8821a_fw.bin");\r\ncase RTL_ROM_LMP_8761A:\r\nreturn btrtl_setup_rtl8723b(hdev, lmp_subver,\r\n"rtl_bt/rtl8761a_fw.bin");\r\ndefault:\r\nBT_INFO("rtl: assuming no firmware upload needed.");\r\nreturn 0;\r\n}\r\n}
