static int pistachio_usb_phy_power_on(struct phy *phy)\r\n{\r\nstruct pistachio_usb_phy *p_phy = phy_get_drvdata(phy);\r\nunsigned long timeout, rate;\r\nunsigned int i;\r\nint ret;\r\nret = clk_prepare_enable(p_phy->phy_clk);\r\nif (ret < 0) {\r\ndev_err(p_phy->dev, "Failed to enable PHY clock: %d\n", ret);\r\nreturn ret;\r\n}\r\nregmap_update_bits(p_phy->cr_top, USB_PHY_STRAP_CONTROL,\r\nUSB_PHY_STRAP_CONTROL_REFCLK_MASK <<\r\nUSB_PHY_STRAP_CONTROL_REFCLK_SHIFT,\r\np_phy->refclk << USB_PHY_STRAP_CONTROL_REFCLK_SHIFT);\r\nrate = clk_get_rate(p_phy->phy_clk);\r\nif (p_phy->refclk == REFCLK_XO_CRYSTAL && rate != 12000000) {\r\ndev_err(p_phy->dev, "Unsupported rate for XO crystal: %ld\n",\r\nrate);\r\nret = -EINVAL;\r\ngoto disable_clk;\r\n}\r\nfor (i = 0; i < ARRAY_SIZE(fsel_rate_map); i++) {\r\nif (rate == fsel_rate_map[i])\r\nbreak;\r\n}\r\nif (i == ARRAY_SIZE(fsel_rate_map)) {\r\ndev_err(p_phy->dev, "Unsupported clock rate: %lu\n", rate);\r\nret = -EINVAL;\r\ngoto disable_clk;\r\n}\r\nregmap_update_bits(p_phy->cr_top, USB_PHY_CONTROL1,\r\nUSB_PHY_CONTROL1_FSEL_MASK <<\r\nUSB_PHY_CONTROL1_FSEL_SHIFT,\r\ni << USB_PHY_CONTROL1_FSEL_SHIFT);\r\ntimeout = jiffies + msecs_to_jiffies(200);\r\nwhile (time_before(jiffies, timeout)) {\r\nunsigned int val;\r\nregmap_read(p_phy->cr_top, USB_PHY_STATUS, &val);\r\nif (val & USB_PHY_STATUS_VBUS_FAULT) {\r\ndev_err(p_phy->dev, "VBUS fault detected\n");\r\nret = -EIO;\r\ngoto disable_clk;\r\n}\r\nif ((val & USB_PHY_STATUS_RX_PHY_CLK) &&\r\n(val & USB_PHY_STATUS_RX_UTMI_CLK))\r\nreturn 0;\r\nusleep_range(1000, 1500);\r\n}\r\ndev_err(p_phy->dev, "Timed out waiting for PHY to power on\n");\r\nret = -ETIMEDOUT;\r\ndisable_clk:\r\nclk_disable_unprepare(p_phy->phy_clk);\r\nreturn ret;\r\n}\r\nstatic int pistachio_usb_phy_power_off(struct phy *phy)\r\n{\r\nstruct pistachio_usb_phy *p_phy = phy_get_drvdata(phy);\r\nclk_disable_unprepare(p_phy->phy_clk);\r\nreturn 0;\r\n}\r\nstatic int pistachio_usb_phy_probe(struct platform_device *pdev)\r\n{\r\nstruct pistachio_usb_phy *p_phy;\r\nstruct phy_provider *provider;\r\nstruct phy *phy;\r\nint ret;\r\np_phy = devm_kzalloc(&pdev->dev, sizeof(*p_phy), GFP_KERNEL);\r\nif (!p_phy)\r\nreturn -ENOMEM;\r\np_phy->dev = &pdev->dev;\r\nplatform_set_drvdata(pdev, p_phy);\r\np_phy->cr_top = syscon_regmap_lookup_by_phandle(p_phy->dev->of_node,\r\n"img,cr-top");\r\nif (IS_ERR(p_phy->cr_top)) {\r\ndev_err(p_phy->dev, "Failed to get CR_TOP registers: %ld\n",\r\nPTR_ERR(p_phy->cr_top));\r\nreturn PTR_ERR(p_phy->cr_top);\r\n}\r\np_phy->phy_clk = devm_clk_get(p_phy->dev, "usb_phy");\r\nif (IS_ERR(p_phy->phy_clk)) {\r\ndev_err(p_phy->dev, "Failed to get usb_phy clock: %ld\n",\r\nPTR_ERR(p_phy->phy_clk));\r\nreturn PTR_ERR(p_phy->phy_clk);\r\n}\r\nret = of_property_read_u32(p_phy->dev->of_node, "img,refclk",\r\n&p_phy->refclk);\r\nif (ret < 0) {\r\ndev_err(p_phy->dev, "No reference clock selector specified\n");\r\nreturn ret;\r\n}\r\nphy = devm_phy_create(p_phy->dev, NULL, &pistachio_usb_phy_ops);\r\nif (IS_ERR(phy)) {\r\ndev_err(p_phy->dev, "Failed to create PHY: %ld\n",\r\nPTR_ERR(phy));\r\nreturn PTR_ERR(phy);\r\n}\r\nphy_set_drvdata(phy, p_phy);\r\nprovider = devm_of_phy_provider_register(p_phy->dev,\r\nof_phy_simple_xlate);\r\nif (IS_ERR(provider)) {\r\ndev_err(p_phy->dev, "Failed to register PHY provider: %ld\n",\r\nPTR_ERR(provider));\r\nreturn PTR_ERR(provider);\r\n}\r\nreturn 0;\r\n}
