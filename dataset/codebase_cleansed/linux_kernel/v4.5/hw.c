static void _rtl8821ae_return_beacon_queue_skb(struct ieee80211_hw *hw)\r\n{\r\nstruct rtl_priv *rtlpriv = rtl_priv(hw);\r\nstruct rtl_pci *rtlpci = rtl_pcidev(rtl_pcipriv(hw));\r\nstruct rtl8192_tx_ring *ring = &rtlpci->tx_ring[BEACON_QUEUE];\r\nunsigned long flags;\r\nspin_lock_irqsave(&rtlpriv->locks.irq_th_lock, flags);\r\nwhile (skb_queue_len(&ring->queue)) {\r\nstruct rtl_tx_desc *entry = &ring->desc[ring->idx];\r\nstruct sk_buff *skb = __skb_dequeue(&ring->queue);\r\npci_unmap_single(rtlpci->pdev,\r\nrtlpriv->cfg->ops->get_desc(\r\n(u8 *)entry, true, HW_DESC_TXBUFF_ADDR),\r\nskb->len, PCI_DMA_TODEVICE);\r\nkfree_skb(skb);\r\nring->idx = (ring->idx + 1) % ring->entries;\r\n}\r\nspin_unlock_irqrestore(&rtlpriv->locks.irq_th_lock, flags);\r\n}\r\nstatic void _rtl8821ae_set_bcn_ctrl_reg(struct ieee80211_hw *hw,\r\nu8 set_bits, u8 clear_bits)\r\n{\r\nstruct rtl_pci *rtlpci = rtl_pcidev(rtl_pcipriv(hw));\r\nstruct rtl_priv *rtlpriv = rtl_priv(hw);\r\nrtlpci->reg_bcn_ctrl_val |= set_bits;\r\nrtlpci->reg_bcn_ctrl_val &= ~clear_bits;\r\nrtl_write_byte(rtlpriv, REG_BCN_CTRL, (u8)rtlpci->reg_bcn_ctrl_val);\r\n}\r\nvoid _rtl8821ae_stop_tx_beacon(struct ieee80211_hw *hw)\r\n{\r\nstruct rtl_priv *rtlpriv = rtl_priv(hw);\r\nu8 tmp1byte;\r\ntmp1byte = rtl_read_byte(rtlpriv, REG_FWHW_TXQ_CTRL + 2);\r\nrtl_write_byte(rtlpriv, REG_FWHW_TXQ_CTRL + 2, tmp1byte & (~BIT(6)));\r\nrtl_write_byte(rtlpriv, REG_TBTT_PROHIBIT + 1, 0x64);\r\ntmp1byte = rtl_read_byte(rtlpriv, REG_TBTT_PROHIBIT + 2);\r\ntmp1byte &= ~(BIT(0));\r\nrtl_write_byte(rtlpriv, REG_TBTT_PROHIBIT + 2, tmp1byte);\r\n}\r\nvoid _rtl8821ae_resume_tx_beacon(struct ieee80211_hw *hw)\r\n{\r\nstruct rtl_priv *rtlpriv = rtl_priv(hw);\r\nu8 tmp1byte;\r\ntmp1byte = rtl_read_byte(rtlpriv, REG_FWHW_TXQ_CTRL + 2);\r\nrtl_write_byte(rtlpriv, REG_FWHW_TXQ_CTRL + 2, tmp1byte | BIT(6));\r\nrtl_write_byte(rtlpriv, REG_TBTT_PROHIBIT + 1, 0xff);\r\ntmp1byte = rtl_read_byte(rtlpriv, REG_TBTT_PROHIBIT + 2);\r\ntmp1byte |= BIT(0);\r\nrtl_write_byte(rtlpriv, REG_TBTT_PROHIBIT + 2, tmp1byte);\r\n}\r\nstatic void _rtl8821ae_enable_bcn_sub_func(struct ieee80211_hw *hw)\r\n{\r\n_rtl8821ae_set_bcn_ctrl_reg(hw, 0, BIT(1));\r\n}\r\nstatic void _rtl8821ae_disable_bcn_sub_func(struct ieee80211_hw *hw)\r\n{\r\n_rtl8821ae_set_bcn_ctrl_reg(hw, BIT(1), 0);\r\n}\r\nstatic void _rtl8821ae_set_fw_clock_on(struct ieee80211_hw *hw,\r\nu8 rpwm_val, bool b_need_turn_off_ckk)\r\n{\r\nstruct rtl_priv *rtlpriv = rtl_priv(hw);\r\nstruct rtl_hal *rtlhal = rtl_hal(rtl_priv(hw));\r\nbool b_support_remote_wake_up;\r\nu32 count = 0, isr_regaddr, content;\r\nbool b_schedule_timer = b_need_turn_off_ckk;\r\nrtlpriv->cfg->ops->get_hw_reg(hw, HAL_DEF_WOWLAN,\r\n(u8 *)(&b_support_remote_wake_up));\r\nif (!rtlhal->fw_ready)\r\nreturn;\r\nif (!rtlpriv->psc.fw_current_inpsmode)\r\nreturn;\r\nwhile (1) {\r\nspin_lock_bh(&rtlpriv->locks.fw_ps_lock);\r\nif (rtlhal->fw_clk_change_in_progress) {\r\nwhile (rtlhal->fw_clk_change_in_progress) {\r\nspin_unlock_bh(&rtlpriv->locks.fw_ps_lock);\r\ncount++;\r\nudelay(100);\r\nif (count > 1000)\r\ngoto change_done;\r\nspin_lock_bh(&rtlpriv->locks.fw_ps_lock);\r\n}\r\nspin_unlock_bh(&rtlpriv->locks.fw_ps_lock);\r\n} else {\r\nrtlhal->fw_clk_change_in_progress = false;\r\nspin_unlock_bh(&rtlpriv->locks.fw_ps_lock);\r\ngoto change_done;\r\n}\r\n}\r\nchange_done:\r\nif (IS_IN_LOW_POWER_STATE_8821AE(rtlhal->fw_ps_state)) {\r\nrtlpriv->cfg->ops->get_hw_reg(hw, HW_VAR_SET_RPWM,\r\n(u8 *)(&rpwm_val));\r\nif (FW_PS_IS_ACK(rpwm_val)) {\r\nisr_regaddr = REG_HISR;\r\ncontent = rtl_read_dword(rtlpriv, isr_regaddr);\r\nwhile (!(content & IMR_CPWM) && (count < 500)) {\r\nudelay(50);\r\ncount++;\r\ncontent = rtl_read_dword(rtlpriv, isr_regaddr);\r\n}\r\nif (content & IMR_CPWM) {\r\nrtl_write_word(rtlpriv, isr_regaddr, 0x0100);\r\nrtlhal->fw_ps_state = FW_PS_STATE_RF_ON_8821AE;\r\nRT_TRACE(rtlpriv, COMP_POWER, DBG_LOUD,\r\n"Receive CPWM INT!!! Set rtlhal->FwPSState = %X\n",\r\nrtlhal->fw_ps_state);\r\n}\r\n}\r\nspin_lock_bh(&rtlpriv->locks.fw_ps_lock);\r\nrtlhal->fw_clk_change_in_progress = false;\r\nspin_unlock_bh(&rtlpriv->locks.fw_ps_lock);\r\nif (b_schedule_timer)\r\nmod_timer(&rtlpriv->works.fw_clockoff_timer,\r\njiffies + MSECS(10));\r\n} else {\r\nspin_lock_bh(&rtlpriv->locks.fw_ps_lock);\r\nrtlhal->fw_clk_change_in_progress = false;\r\nspin_unlock_bh(&rtlpriv->locks.fw_ps_lock);\r\n}\r\n}\r\nstatic void _rtl8821ae_set_fw_clock_off(struct ieee80211_hw *hw,\r\nu8 rpwm_val)\r\n{\r\nstruct rtl_priv *rtlpriv = rtl_priv(hw);\r\nstruct rtl_hal *rtlhal = rtl_hal(rtl_priv(hw));\r\nstruct rtl_pci *rtlpci = rtl_pcidev(rtl_pcipriv(hw));\r\nstruct rtl8192_tx_ring *ring;\r\nenum rf_pwrstate rtstate;\r\nbool b_schedule_timer = false;\r\nu8 queue;\r\nif (!rtlhal->fw_ready)\r\nreturn;\r\nif (!rtlpriv->psc.fw_current_inpsmode)\r\nreturn;\r\nif (!rtlhal->allow_sw_to_change_hwclc)\r\nreturn;\r\nrtlpriv->cfg->ops->get_hw_reg(hw, HW_VAR_RF_STATE, (u8 *)(&rtstate));\r\nif (rtstate == ERFOFF || rtlpriv->psc.inactive_pwrstate == ERFOFF)\r\nreturn;\r\nfor (queue = 0; queue < RTL_PCI_MAX_TX_QUEUE_COUNT; queue++) {\r\nring = &rtlpci->tx_ring[queue];\r\nif (skb_queue_len(&ring->queue)) {\r\nb_schedule_timer = true;\r\nbreak;\r\n}\r\n}\r\nif (b_schedule_timer) {\r\nmod_timer(&rtlpriv->works.fw_clockoff_timer,\r\njiffies + MSECS(10));\r\nreturn;\r\n}\r\nif (FW_PS_STATE(rtlhal->fw_ps_state) !=\r\nFW_PS_STATE_RF_OFF_LOW_PWR_8821AE) {\r\nspin_lock_bh(&rtlpriv->locks.fw_ps_lock);\r\nif (!rtlhal->fw_clk_change_in_progress) {\r\nrtlhal->fw_clk_change_in_progress = true;\r\nspin_unlock_bh(&rtlpriv->locks.fw_ps_lock);\r\nrtlhal->fw_ps_state = FW_PS_STATE(rpwm_val);\r\nrtl_write_word(rtlpriv, REG_HISR, 0x0100);\r\nrtlpriv->cfg->ops->set_hw_reg(hw, HW_VAR_SET_RPWM,\r\n(u8 *)(&rpwm_val));\r\nspin_lock_bh(&rtlpriv->locks.fw_ps_lock);\r\nrtlhal->fw_clk_change_in_progress = false;\r\nspin_unlock_bh(&rtlpriv->locks.fw_ps_lock);\r\n} else {\r\nspin_unlock_bh(&rtlpriv->locks.fw_ps_lock);\r\nmod_timer(&rtlpriv->works.fw_clockoff_timer,\r\njiffies + MSECS(10));\r\n}\r\n}\r\n}\r\nstatic void _rtl8821ae_set_fw_ps_rf_on(struct ieee80211_hw *hw)\r\n{\r\nu8 rpwm_val = 0;\r\nrpwm_val |= (FW_PS_STATE_RF_OFF_8821AE | FW_PS_ACK);\r\n_rtl8821ae_set_fw_clock_on(hw, rpwm_val, true);\r\n}\r\nstatic void _rtl8821ae_fwlps_leave(struct ieee80211_hw *hw)\r\n{\r\nstruct rtl_priv *rtlpriv = rtl_priv(hw);\r\nstruct rtl_ps_ctl *ppsc = rtl_psc(rtl_priv(hw));\r\nstruct rtl_hal *rtlhal = rtl_hal(rtl_priv(hw));\r\nbool fw_current_inps = false;\r\nu8 rpwm_val = 0, fw_pwrmode = FW_PS_ACTIVE_MODE;\r\nif (ppsc->low_power_enable) {\r\nrpwm_val = (FW_PS_STATE_ALL_ON_8821AE|FW_PS_ACK);\r\n_rtl8821ae_set_fw_clock_on(hw, rpwm_val, false);\r\nrtlhal->allow_sw_to_change_hwclc = false;\r\nrtlpriv->cfg->ops->set_hw_reg(hw, HW_VAR_H2C_FW_PWRMODE,\r\n(u8 *)(&fw_pwrmode));\r\nrtlpriv->cfg->ops->set_hw_reg(hw, HW_VAR_FW_PSMODE_STATUS,\r\n(u8 *)(&fw_current_inps));\r\n} else {\r\nrpwm_val = FW_PS_STATE_ALL_ON_8821AE;\r\nrtlpriv->cfg->ops->set_hw_reg(hw, HW_VAR_SET_RPWM,\r\n(u8 *)(&rpwm_val));\r\nrtlpriv->cfg->ops->set_hw_reg(hw, HW_VAR_H2C_FW_PWRMODE,\r\n(u8 *)(&fw_pwrmode));\r\nrtlpriv->cfg->ops->set_hw_reg(hw, HW_VAR_FW_PSMODE_STATUS,\r\n(u8 *)(&fw_current_inps));\r\n}\r\n}\r\nstatic void _rtl8821ae_fwlps_enter(struct ieee80211_hw *hw)\r\n{\r\nstruct rtl_priv *rtlpriv = rtl_priv(hw);\r\nstruct rtl_ps_ctl *ppsc = rtl_psc(rtl_priv(hw));\r\nstruct rtl_hal *rtlhal = rtl_hal(rtl_priv(hw));\r\nbool fw_current_inps = true;\r\nu8 rpwm_val;\r\nif (ppsc->low_power_enable) {\r\nrpwm_val = FW_PS_STATE_RF_OFF_LOW_PWR_8821AE;\r\nrtlpriv->cfg->ops->set_hw_reg(hw,\r\nHW_VAR_FW_PSMODE_STATUS,\r\n(u8 *)(&fw_current_inps));\r\nrtlpriv->cfg->ops->set_hw_reg(hw,\r\nHW_VAR_H2C_FW_PWRMODE,\r\n(u8 *)(&ppsc->fwctrl_psmode));\r\nrtlhal->allow_sw_to_change_hwclc = true;\r\n_rtl8821ae_set_fw_clock_off(hw, rpwm_val);\r\n} else {\r\nrpwm_val = FW_PS_STATE_RF_OFF_8821AE;\r\nrtlpriv->cfg->ops->set_hw_reg(hw,\r\nHW_VAR_FW_PSMODE_STATUS,\r\n(u8 *)(&fw_current_inps));\r\nrtlpriv->cfg->ops->set_hw_reg(hw,\r\nHW_VAR_H2C_FW_PWRMODE,\r\n(u8 *)(&ppsc->fwctrl_psmode));\r\nrtlpriv->cfg->ops->set_hw_reg(hw,\r\nHW_VAR_SET_RPWM,\r\n(u8 *)(&rpwm_val));\r\n}\r\n}\r\nstatic void _rtl8821ae_download_rsvd_page(struct ieee80211_hw *hw,\r\nbool dl_whole_packets)\r\n{\r\nstruct rtl_priv *rtlpriv = rtl_priv(hw);\r\nstruct rtl_hal *rtlhal = rtl_hal(rtlpriv);\r\nu8 tmp_regcr, tmp_reg422, bcnvalid_reg;\r\nu8 count = 0, dlbcn_count = 0;\r\nbool send_beacon = false;\r\ntmp_regcr = rtl_read_byte(rtlpriv, REG_CR + 1);\r\nrtl_write_byte(rtlpriv, REG_CR + 1, (tmp_regcr | BIT(0)));\r\n_rtl8821ae_set_bcn_ctrl_reg(hw, 0, BIT(3));\r\n_rtl8821ae_set_bcn_ctrl_reg(hw, BIT(4), 0);\r\ntmp_reg422 = rtl_read_byte(rtlpriv, REG_FWHW_TXQ_CTRL + 2);\r\nrtl_write_byte(rtlpriv, REG_FWHW_TXQ_CTRL + 2,\r\ntmp_reg422 & (~BIT(6)));\r\nif (tmp_reg422 & BIT(6))\r\nsend_beacon = true;\r\ndo {\r\nbcnvalid_reg = rtl_read_byte(rtlpriv, REG_TDECTRL + 2);\r\nrtl_write_byte(rtlpriv, REG_TDECTRL + 2,\r\n(bcnvalid_reg | BIT(0)));\r\n_rtl8821ae_return_beacon_queue_skb(hw);\r\nif (rtlhal->hw_type == HARDWARE_TYPE_RTL8812AE)\r\nrtl8812ae_set_fw_rsvdpagepkt(hw, false,\r\ndl_whole_packets);\r\nelse\r\nrtl8821ae_set_fw_rsvdpagepkt(hw, false,\r\ndl_whole_packets);\r\nbcnvalid_reg = rtl_read_byte(rtlpriv, REG_TDECTRL + 2);\r\ncount = 0;\r\nwhile (!(bcnvalid_reg & BIT(0)) && count < 20) {\r\ncount++;\r\nudelay(10);\r\nbcnvalid_reg = rtl_read_byte(rtlpriv, REG_TDECTRL + 2);\r\n}\r\ndlbcn_count++;\r\n} while (!(bcnvalid_reg & BIT(0)) && dlbcn_count < 5);\r\nif (!(bcnvalid_reg & BIT(0)))\r\nRT_TRACE(rtlpriv, COMP_INIT, DBG_LOUD,\r\n"Download RSVD page failed!\n");\r\nif (bcnvalid_reg & BIT(0) && rtlhal->enter_pnp_sleep) {\r\nrtl_write_byte(rtlpriv, REG_TDECTRL + 2, bcnvalid_reg | BIT(0));\r\n_rtl8821ae_return_beacon_queue_skb(hw);\r\nif (send_beacon) {\r\ndlbcn_count = 0;\r\ndo {\r\nrtl_write_byte(rtlpriv, REG_TDECTRL + 2,\r\nbcnvalid_reg | BIT(0));\r\n_rtl8821ae_return_beacon_queue_skb(hw);\r\nif (rtlhal->hw_type == HARDWARE_TYPE_RTL8812AE)\r\nrtl8812ae_set_fw_rsvdpagepkt(hw, true,\r\nfalse);\r\nelse\r\nrtl8821ae_set_fw_rsvdpagepkt(hw, true,\r\nfalse);\r\nbcnvalid_reg = rtl_read_byte(rtlpriv,\r\nREG_TDECTRL + 2);\r\ncount = 0;\r\nwhile (!(bcnvalid_reg & BIT(0)) && count < 20) {\r\ncount++;\r\nudelay(10);\r\nbcnvalid_reg =\r\nrtl_read_byte(rtlpriv,\r\nREG_TDECTRL + 2);\r\n}\r\ndlbcn_count++;\r\n} while (!(bcnvalid_reg & BIT(0)) && dlbcn_count < 5);\r\nif (!(bcnvalid_reg & BIT(0)))\r\nRT_TRACE(rtlpriv, COMP_INIT, DBG_LOUD,\r\n"2 Download RSVD page failed!\n");\r\n}\r\n}\r\nif (bcnvalid_reg & BIT(0))\r\nrtl_write_byte(rtlpriv, REG_TDECTRL + 2, BIT(0));\r\n_rtl8821ae_set_bcn_ctrl_reg(hw, BIT(3), 0);\r\n_rtl8821ae_set_bcn_ctrl_reg(hw, 0, BIT(4));\r\nif (send_beacon)\r\nrtl_write_byte(rtlpriv, REG_FWHW_TXQ_CTRL + 2, tmp_reg422);\r\nif (!rtlhal->enter_pnp_sleep) {\r\ntmp_regcr = rtl_read_byte(rtlpriv, REG_CR + 1);\r\nrtl_write_byte(rtlpriv, REG_CR + 1, (tmp_regcr & ~(BIT(0))));\r\n}\r\n}\r\nvoid rtl8821ae_get_hw_reg(struct ieee80211_hw *hw, u8 variable, u8 *val)\r\n{\r\nstruct rtl_priv *rtlpriv = rtl_priv(hw);\r\nstruct rtl_ps_ctl *ppsc = rtl_psc(rtl_priv(hw));\r\nstruct rtl_pci *rtlpci = rtl_pcidev(rtl_pcipriv(hw));\r\nstruct rtl_mac *mac = rtl_mac(rtl_priv(hw));\r\nswitch (variable) {\r\ncase HW_VAR_ETHER_ADDR:\r\n*((u32 *)(val)) = rtl_read_dword(rtlpriv, REG_MACID);\r\n*((u16 *)(val+4)) = rtl_read_word(rtlpriv, REG_MACID + 4);\r\nbreak;\r\ncase HW_VAR_BSSID:\r\n*((u32 *)(val)) = rtl_read_dword(rtlpriv, REG_BSSID);\r\n*((u16 *)(val+4)) = rtl_read_word(rtlpriv, REG_BSSID+4);\r\nbreak;\r\ncase HW_VAR_MEDIA_STATUS:\r\nval[0] = rtl_read_byte(rtlpriv, MSR) & 0x3;\r\nbreak;\r\ncase HW_VAR_SLOT_TIME:\r\n*((u8 *)(val)) = mac->slot_time;\r\nbreak;\r\ncase HW_VAR_BEACON_INTERVAL:\r\n*((u16 *)(val)) = rtl_read_word(rtlpriv, REG_BCN_INTERVAL);\r\nbreak;\r\ncase HW_VAR_ATIM_WINDOW:\r\n*((u16 *)(val)) = rtl_read_word(rtlpriv, REG_ATIMWND);\r\nbreak;\r\ncase HW_VAR_RCR:\r\n*((u32 *)(val)) = rtlpci->receive_config;\r\nbreak;\r\ncase HW_VAR_RF_STATE:\r\n*((enum rf_pwrstate *)(val)) = ppsc->rfpwr_state;\r\nbreak;\r\ncase HW_VAR_FWLPS_RF_ON:{\r\nenum rf_pwrstate rfstate;\r\nu32 val_rcr;\r\nrtlpriv->cfg->ops->get_hw_reg(hw,\r\nHW_VAR_RF_STATE,\r\n(u8 *)(&rfstate));\r\nif (rfstate == ERFOFF) {\r\n*((bool *)(val)) = true;\r\n} else {\r\nval_rcr = rtl_read_dword(rtlpriv, REG_RCR);\r\nval_rcr &= 0x00070000;\r\nif (val_rcr)\r\n*((bool *)(val)) = false;\r\nelse\r\n*((bool *)(val)) = true;\r\n}\r\nbreak; }\r\ncase HW_VAR_FW_PSMODE_STATUS:\r\n*((bool *)(val)) = ppsc->fw_current_inpsmode;\r\nbreak;\r\ncase HW_VAR_CORRECT_TSF:{\r\nu64 tsf;\r\nu32 *ptsf_low = (u32 *)&tsf;\r\nu32 *ptsf_high = ((u32 *)&tsf) + 1;\r\n*ptsf_high = rtl_read_dword(rtlpriv, (REG_TSFTR + 4));\r\n*ptsf_low = rtl_read_dword(rtlpriv, REG_TSFTR);\r\n*((u64 *)(val)) = tsf;\r\nbreak; }\r\ncase HAL_DEF_WOWLAN:\r\nif (ppsc->wo_wlan_mode)\r\n*((bool *)(val)) = true;\r\nelse\r\n*((bool *)(val)) = false;\r\nbreak;\r\ndefault:\r\nRT_TRACE(rtlpriv, COMP_ERR, DBG_LOUD,\r\n"switch case not process %x\n", variable);\r\nbreak;\r\n}\r\n}\r\nvoid rtl8821ae_set_hw_reg(struct ieee80211_hw *hw, u8 variable, u8 *val)\r\n{\r\nstruct rtl_priv *rtlpriv = rtl_priv(hw);\r\nstruct rtl_pci *rtlpci = rtl_pcidev(rtl_pcipriv(hw));\r\nstruct rtl_mac *mac = rtl_mac(rtl_priv(hw));\r\nstruct rtl_efuse *rtlefuse = rtl_efuse(rtl_priv(hw));\r\nstruct rtl_ps_ctl *ppsc = rtl_psc(rtl_priv(hw));\r\nstruct rtl_hal *rtlhal = rtl_hal(rtl_priv(hw));\r\nu8 idx;\r\nswitch (variable) {\r\ncase HW_VAR_ETHER_ADDR:{\r\nfor (idx = 0; idx < ETH_ALEN; idx++) {\r\nrtl_write_byte(rtlpriv, (REG_MACID + idx),\r\nval[idx]);\r\n}\r\nbreak;\r\n}\r\ncase HW_VAR_BASIC_RATE:{\r\nu16 b_rate_cfg = ((u16 *)val)[0];\r\nb_rate_cfg = b_rate_cfg & 0x15f;\r\nrtl_write_word(rtlpriv, REG_RRSR, b_rate_cfg);\r\nbreak;\r\n}\r\ncase HW_VAR_BSSID:{\r\nfor (idx = 0; idx < ETH_ALEN; idx++) {\r\nrtl_write_byte(rtlpriv, (REG_BSSID + idx),\r\nval[idx]);\r\n}\r\nbreak;\r\n}\r\ncase HW_VAR_SIFS:\r\nrtl_write_byte(rtlpriv, REG_SIFS_CTX + 1, val[0]);\r\nrtl_write_byte(rtlpriv, REG_SIFS_TRX + 1, val[0]);\r\nrtl_write_byte(rtlpriv, REG_SPEC_SIFS + 1, val[0]);\r\nrtl_write_byte(rtlpriv, REG_MAC_SPEC_SIFS + 1, val[0]);\r\nrtl_write_byte(rtlpriv, REG_RESP_SIFS_OFDM + 1, val[0]);\r\nrtl_write_byte(rtlpriv, REG_RESP_SIFS_OFDM, val[0]);\r\nbreak;\r\ncase HW_VAR_R2T_SIFS:\r\nrtl_write_byte(rtlpriv, REG_RESP_SIFS_OFDM + 1, val[0]);\r\nbreak;\r\ncase HW_VAR_SLOT_TIME:{\r\nu8 e_aci;\r\nRT_TRACE(rtlpriv, COMP_MLME, DBG_LOUD,\r\n"HW_VAR_SLOT_TIME %x\n", val[0]);\r\nrtl_write_byte(rtlpriv, REG_SLOT, val[0]);\r\nfor (e_aci = 0; e_aci < AC_MAX; e_aci++) {\r\nrtlpriv->cfg->ops->set_hw_reg(hw,\r\nHW_VAR_AC_PARAM,\r\n(u8 *)(&e_aci));\r\n}\r\nbreak; }\r\ncase HW_VAR_ACK_PREAMBLE:{\r\nu8 reg_tmp;\r\nu8 short_preamble = (bool)(*(u8 *)val);\r\nreg_tmp = rtl_read_byte(rtlpriv, REG_TRXPTCL_CTL+2);\r\nif (short_preamble) {\r\nreg_tmp |= BIT(1);\r\nrtl_write_byte(rtlpriv, REG_TRXPTCL_CTL + 2,\r\nreg_tmp);\r\n} else {\r\nreg_tmp &= (~BIT(1));\r\nrtl_write_byte(rtlpriv,\r\nREG_TRXPTCL_CTL + 2,\r\nreg_tmp);\r\n}\r\nbreak; }\r\ncase HW_VAR_WPA_CONFIG:\r\nrtl_write_byte(rtlpriv, REG_SECCFG, *((u8 *)val));\r\nbreak;\r\ncase HW_VAR_AMPDU_MIN_SPACE:{\r\nu8 min_spacing_to_set;\r\nu8 sec_min_space;\r\nmin_spacing_to_set = *((u8 *)val);\r\nif (min_spacing_to_set <= 7) {\r\nsec_min_space = 0;\r\nif (min_spacing_to_set < sec_min_space)\r\nmin_spacing_to_set = sec_min_space;\r\nmac->min_space_cfg = ((mac->min_space_cfg &\r\n0xf8) |\r\nmin_spacing_to_set);\r\n*val = min_spacing_to_set;\r\nRT_TRACE(rtlpriv, COMP_MLME, DBG_LOUD,\r\n"Set HW_VAR_AMPDU_MIN_SPACE: %#x\n",\r\nmac->min_space_cfg);\r\nrtl_write_byte(rtlpriv, REG_AMPDU_MIN_SPACE,\r\nmac->min_space_cfg);\r\n}\r\nbreak; }\r\ncase HW_VAR_SHORTGI_DENSITY:{\r\nu8 density_to_set;\r\ndensity_to_set = *((u8 *)val);\r\nmac->min_space_cfg |= (density_to_set << 3);\r\nRT_TRACE(rtlpriv, COMP_MLME, DBG_LOUD,\r\n"Set HW_VAR_SHORTGI_DENSITY: %#x\n",\r\nmac->min_space_cfg);\r\nrtl_write_byte(rtlpriv, REG_AMPDU_MIN_SPACE,\r\nmac->min_space_cfg);\r\nbreak; }\r\ncase HW_VAR_AMPDU_FACTOR:{\r\nu32 ampdu_len = (*((u8 *)val));\r\nif (rtlhal->hw_type == HARDWARE_TYPE_RTL8812AE) {\r\nif (ampdu_len < VHT_AGG_SIZE_128K)\r\nampdu_len =\r\n(0x2000 << (*((u8 *)val))) - 1;\r\nelse\r\nampdu_len = 0x1ffff;\r\n} else if (rtlhal->hw_type == HARDWARE_TYPE_RTL8821AE) {\r\nif (ampdu_len < HT_AGG_SIZE_64K)\r\nampdu_len =\r\n(0x2000 << (*((u8 *)val))) - 1;\r\nelse\r\nampdu_len = 0xffff;\r\n}\r\nampdu_len |= BIT(31);\r\nrtl_write_dword(rtlpriv,\r\nREG_AMPDU_MAX_LENGTH_8812, ampdu_len);\r\nbreak; }\r\ncase HW_VAR_AC_PARAM:{\r\nu8 e_aci = *((u8 *)val);\r\nrtl8821ae_dm_init_edca_turbo(hw);\r\nif (rtlpci->acm_method != EACMWAY2_SW)\r\nrtlpriv->cfg->ops->set_hw_reg(hw,\r\nHW_VAR_ACM_CTRL,\r\n(u8 *)(&e_aci));\r\nbreak; }\r\ncase HW_VAR_ACM_CTRL:{\r\nu8 e_aci = *((u8 *)val);\r\nunion aci_aifsn *p_aci_aifsn =\r\n(union aci_aifsn *)(&mac->ac[0].aifs);\r\nu8 acm = p_aci_aifsn->f.acm;\r\nu8 acm_ctrl = rtl_read_byte(rtlpriv, REG_ACMHWCTRL);\r\nacm_ctrl =\r\nacm_ctrl | ((rtlpci->acm_method == 2) ? 0x0 : 0x1);\r\nif (acm) {\r\nswitch (e_aci) {\r\ncase AC0_BE:\r\nacm_ctrl |= ACMHW_BEQEN;\r\nbreak;\r\ncase AC2_VI:\r\nacm_ctrl |= ACMHW_VIQEN;\r\nbreak;\r\ncase AC3_VO:\r\nacm_ctrl |= ACMHW_VOQEN;\r\nbreak;\r\ndefault:\r\nRT_TRACE(rtlpriv, COMP_ERR, DBG_WARNING,\r\n"HW_VAR_ACM_CTRL acm set failed: eACI is %d\n",\r\nacm);\r\nbreak;\r\n}\r\n} else {\r\nswitch (e_aci) {\r\ncase AC0_BE:\r\nacm_ctrl &= (~ACMHW_BEQEN);\r\nbreak;\r\ncase AC2_VI:\r\nacm_ctrl &= (~ACMHW_VIQEN);\r\nbreak;\r\ncase AC3_VO:\r\nacm_ctrl &= (~ACMHW_VOQEN);\r\nbreak;\r\ndefault:\r\nRT_TRACE(rtlpriv, COMP_ERR, DBG_LOUD,\r\n"switch case not process\n");\r\nbreak;\r\n}\r\n}\r\nRT_TRACE(rtlpriv, COMP_QOS, DBG_TRACE,\r\n"SetHwReg8190pci(): [HW_VAR_ACM_CTRL] Write 0x%X\n",\r\nacm_ctrl);\r\nrtl_write_byte(rtlpriv, REG_ACMHWCTRL, acm_ctrl);\r\nbreak; }\r\ncase HW_VAR_RCR:\r\nrtl_write_dword(rtlpriv, REG_RCR, ((u32 *)(val))[0]);\r\nrtlpci->receive_config = ((u32 *)(val))[0];\r\nbreak;\r\ncase HW_VAR_RETRY_LIMIT:{\r\nu8 retry_limit = ((u8 *)(val))[0];\r\nrtl_write_word(rtlpriv, REG_RL,\r\nretry_limit << RETRY_LIMIT_SHORT_SHIFT |\r\nretry_limit << RETRY_LIMIT_LONG_SHIFT);\r\nbreak; }\r\ncase HW_VAR_DUAL_TSF_RST:\r\nrtl_write_byte(rtlpriv, REG_DUAL_TSF_RST, (BIT(0) | BIT(1)));\r\nbreak;\r\ncase HW_VAR_EFUSE_BYTES:\r\nrtlefuse->efuse_usedbytes = *((u16 *)val);\r\nbreak;\r\ncase HW_VAR_EFUSE_USAGE:\r\nrtlefuse->efuse_usedpercentage = *((u8 *)val);\r\nbreak;\r\ncase HW_VAR_IO_CMD:\r\nrtl8821ae_phy_set_io_cmd(hw, (*(enum io_type *)val));\r\nbreak;\r\ncase HW_VAR_SET_RPWM:{\r\nu8 rpwm_val;\r\nrpwm_val = rtl_read_byte(rtlpriv, REG_PCIE_HRPWM);\r\nudelay(1);\r\nif (rpwm_val & BIT(7)) {\r\nrtl_write_byte(rtlpriv, REG_PCIE_HRPWM,\r\n(*(u8 *)val));\r\n} else {\r\nrtl_write_byte(rtlpriv, REG_PCIE_HRPWM,\r\n((*(u8 *)val) | BIT(7)));\r\n}\r\nbreak; }\r\ncase HW_VAR_H2C_FW_PWRMODE:\r\nrtl8821ae_set_fw_pwrmode_cmd(hw, (*(u8 *)val));\r\nbreak;\r\ncase HW_VAR_FW_PSMODE_STATUS:\r\nppsc->fw_current_inpsmode = *((bool *)val);\r\nbreak;\r\ncase HW_VAR_INIT_RTS_RATE:\r\nbreak;\r\ncase HW_VAR_RESUME_CLK_ON:\r\n_rtl8821ae_set_fw_ps_rf_on(hw);\r\nbreak;\r\ncase HW_VAR_FW_LPS_ACTION:{\r\nbool b_enter_fwlps = *((bool *)val);\r\nif (b_enter_fwlps)\r\n_rtl8821ae_fwlps_enter(hw);\r\nelse\r\n_rtl8821ae_fwlps_leave(hw);\r\nbreak; }\r\ncase HW_VAR_H2C_FW_JOINBSSRPT:{\r\nu8 mstatus = (*(u8 *)val);\r\nif (mstatus == RT_MEDIA_CONNECT) {\r\nrtlpriv->cfg->ops->set_hw_reg(hw, HW_VAR_AID,\r\nNULL);\r\n_rtl8821ae_download_rsvd_page(hw, false);\r\n}\r\nrtl8821ae_set_fw_media_status_rpt_cmd(hw, mstatus);\r\nbreak; }\r\ncase HW_VAR_H2C_FW_P2P_PS_OFFLOAD:\r\nrtl8821ae_set_p2p_ps_offload_cmd(hw, (*(u8 *)val));\r\nbreak;\r\ncase HW_VAR_AID:{\r\nu16 u2btmp;\r\nu2btmp = rtl_read_word(rtlpriv, REG_BCN_PSR_RPT);\r\nu2btmp &= 0xC000;\r\nrtl_write_word(rtlpriv, REG_BCN_PSR_RPT, (u2btmp |\r\nmac->assoc_id));\r\nbreak; }\r\ncase HW_VAR_CORRECT_TSF:{\r\nu8 btype_ibss = ((u8 *)(val))[0];\r\nif (btype_ibss)\r\n_rtl8821ae_stop_tx_beacon(hw);\r\n_rtl8821ae_set_bcn_ctrl_reg(hw, 0, BIT(3));\r\nrtl_write_dword(rtlpriv, REG_TSFTR,\r\n(u32)(mac->tsf & 0xffffffff));\r\nrtl_write_dword(rtlpriv, REG_TSFTR + 4,\r\n(u32)((mac->tsf >> 32) & 0xffffffff));\r\n_rtl8821ae_set_bcn_ctrl_reg(hw, BIT(3), 0);\r\nif (btype_ibss)\r\n_rtl8821ae_resume_tx_beacon(hw);\r\nbreak; }\r\ncase HW_VAR_NAV_UPPER: {\r\nu32 us_nav_upper = ((u32)*val);\r\nif (us_nav_upper > HAL_92C_NAV_UPPER_UNIT * 0xFF) {\r\nRT_TRACE(rtlpriv, COMP_INIT , DBG_WARNING,\r\n"The setting value (0x%08X us) of NAV_UPPER is larger than (%d * 0xFF)!!!\n",\r\nus_nav_upper, HAL_92C_NAV_UPPER_UNIT);\r\nbreak;\r\n}\r\nrtl_write_byte(rtlpriv, REG_NAV_UPPER,\r\n((u8)((us_nav_upper +\r\nHAL_92C_NAV_UPPER_UNIT - 1) /\r\nHAL_92C_NAV_UPPER_UNIT)));\r\nbreak; }\r\ncase HW_VAR_KEEP_ALIVE: {\r\nu8 array[2];\r\narray[0] = 0xff;\r\narray[1] = *((u8 *)val);\r\nrtl8821ae_fill_h2c_cmd(hw, H2C_8821AE_KEEP_ALIVE_CTRL, 2,\r\narray);\r\nbreak; }\r\ndefault:\r\nRT_TRACE(rtlpriv, COMP_ERR, DBG_LOUD,\r\n"switch case not process %x\n", variable);\r\nbreak;\r\n}\r\n}\r\nstatic bool _rtl8821ae_llt_write(struct ieee80211_hw *hw, u32 address, u32 data)\r\n{\r\nstruct rtl_priv *rtlpriv = rtl_priv(hw);\r\nbool status = true;\r\nlong count = 0;\r\nu32 value = _LLT_INIT_ADDR(address) | _LLT_INIT_DATA(data) |\r\n_LLT_OP(_LLT_WRITE_ACCESS);\r\nrtl_write_dword(rtlpriv, REG_LLT_INIT, value);\r\ndo {\r\nvalue = rtl_read_dword(rtlpriv, REG_LLT_INIT);\r\nif (_LLT_NO_ACTIVE == _LLT_OP_VALUE(value))\r\nbreak;\r\nif (count > POLLING_LLT_THRESHOLD) {\r\nRT_TRACE(rtlpriv, COMP_ERR, DBG_EMERG,\r\n"Failed to polling write LLT done at address %d!\n",\r\naddress);\r\nstatus = false;\r\nbreak;\r\n}\r\n} while (++count);\r\nreturn status;\r\n}\r\nstatic bool _rtl8821ae_llt_table_init(struct ieee80211_hw *hw)\r\n{\r\nstruct rtl_priv *rtlpriv = rtl_priv(hw);\r\nunsigned short i;\r\nu8 txpktbuf_bndy;\r\nu32 rqpn;\r\nu8 maxpage;\r\nbool status;\r\nmaxpage = 255;\r\ntxpktbuf_bndy = 0xF8;\r\nrqpn = 0x80e70808;\r\nif (rtlpriv->rtlhal.hw_type == HARDWARE_TYPE_RTL8812AE) {\r\ntxpktbuf_bndy = 0xFA;\r\nrqpn = 0x80e90808;\r\n}\r\nrtl_write_byte(rtlpriv, REG_TRXFF_BNDY, txpktbuf_bndy);\r\nrtl_write_word(rtlpriv, REG_TRXFF_BNDY + 2, MAX_RX_DMA_BUFFER_SIZE - 1);\r\nrtl_write_byte(rtlpriv, REG_TDECTRL + 1, txpktbuf_bndy);\r\nrtl_write_byte(rtlpriv, REG_TXPKTBUF_BCNQ_BDNY, txpktbuf_bndy);\r\nrtl_write_byte(rtlpriv, REG_TXPKTBUF_MGQ_BDNY, txpktbuf_bndy);\r\nrtl_write_byte(rtlpriv, REG_PBP, 0x31);\r\nrtl_write_byte(rtlpriv, REG_RX_DRVINFO_SZ, 0x4);\r\nfor (i = 0; i < (txpktbuf_bndy - 1); i++) {\r\nstatus = _rtl8821ae_llt_write(hw, i, i + 1);\r\nif (!status)\r\nreturn status;\r\n}\r\nstatus = _rtl8821ae_llt_write(hw, (txpktbuf_bndy - 1), 0xFF);\r\nif (!status)\r\nreturn status;\r\nfor (i = txpktbuf_bndy; i < maxpage; i++) {\r\nstatus = _rtl8821ae_llt_write(hw, i, (i + 1));\r\nif (!status)\r\nreturn status;\r\n}\r\nstatus = _rtl8821ae_llt_write(hw, maxpage, txpktbuf_bndy);\r\nif (!status)\r\nreturn status;\r\nrtl_write_dword(rtlpriv, REG_RQPN, rqpn);\r\nrtl_write_byte(rtlpriv, REG_RQPN_NPQ, 0x00);\r\nreturn true;\r\n}\r\nstatic void _rtl8821ae_gen_refresh_led_state(struct ieee80211_hw *hw)\r\n{\r\nstruct rtl_priv *rtlpriv = rtl_priv(hw);\r\nstruct rtl_pci_priv *pcipriv = rtl_pcipriv(hw);\r\nstruct rtl_ps_ctl *ppsc = rtl_psc(rtl_priv(hw));\r\nstruct rtl_led *pled0 = &pcipriv->ledctl.sw_led0;\r\nstruct rtl_hal *rtlhal = rtl_hal(rtl_priv(hw));\r\nif (rtlpriv->rtlhal.up_first_time)\r\nreturn;\r\nif (ppsc->rfoff_reason == RF_CHANGE_BY_IPS)\r\nif (rtlhal->hw_type == HARDWARE_TYPE_RTL8812AE)\r\nrtl8812ae_sw_led_on(hw, pled0);\r\nelse\r\nrtl8821ae_sw_led_on(hw, pled0);\r\nelse if (ppsc->rfoff_reason == RF_CHANGE_BY_INIT)\r\nif (rtlhal->hw_type == HARDWARE_TYPE_RTL8812AE)\r\nrtl8812ae_sw_led_on(hw, pled0);\r\nelse\r\nrtl8821ae_sw_led_on(hw, pled0);\r\nelse\r\nif (rtlhal->hw_type == HARDWARE_TYPE_RTL8812AE)\r\nrtl8812ae_sw_led_off(hw, pled0);\r\nelse\r\nrtl8821ae_sw_led_off(hw, pled0);\r\n}\r\nstatic bool _rtl8821ae_init_mac(struct ieee80211_hw *hw)\r\n{\r\nstruct rtl_priv *rtlpriv = rtl_priv(hw);\r\nstruct rtl_pci *rtlpci = rtl_pcidev(rtl_pcipriv(hw));\r\nstruct rtl_hal *rtlhal = rtl_hal(rtl_priv(hw));\r\nu8 bytetmp = 0;\r\nu16 wordtmp = 0;\r\nbool mac_func_enable = rtlhal->mac_func_enable;\r\nrtl_write_byte(rtlpriv, REG_RSV_CTRL, 0x00);\r\nbytetmp = rtl_read_byte(rtlpriv, REG_APS_FSMCO + 1) & (~BIT(7));\r\nrtl_write_byte(rtlpriv, REG_APS_FSMCO + 1, bytetmp);\r\nif (rtlhal->hw_type == HARDWARE_TYPE_RTL8812AE) {\r\nif (!rtl_hal_pwrseqcmdparsing(rtlpriv, PWR_CUT_ALL_MSK,\r\nPWR_FAB_ALL_MSK, PWR_INTF_PCI_MSK,\r\nRTL8812_NIC_ENABLE_FLOW)) {\r\nRT_TRACE(rtlpriv, COMP_INIT, DBG_LOUD,\r\n"init 8812 MAC Fail as power on failure\n");\r\nreturn false;\r\n}\r\n} else {\r\nif (!rtl_hal_pwrseqcmdparsing(rtlpriv, PWR_CUT_A_MSK,\r\nPWR_FAB_ALL_MSK, PWR_INTF_PCI_MSK,\r\nRTL8821A_NIC_ENABLE_FLOW)){\r\nRT_TRACE(rtlpriv, COMP_INIT, DBG_LOUD,\r\n"init 8821 MAC Fail as power on failure\n");\r\nreturn false;\r\n}\r\n}\r\nbytetmp = rtl_read_byte(rtlpriv, REG_APS_FSMCO) | BIT(4);\r\nrtl_write_byte(rtlpriv, REG_APS_FSMCO, bytetmp);\r\nbytetmp = rtl_read_byte(rtlpriv, REG_CR);\r\nbytetmp = 0xff;\r\nrtl_write_byte(rtlpriv, REG_CR, bytetmp);\r\nmdelay(2);\r\nbytetmp = 0xff;\r\nrtl_write_byte(rtlpriv, REG_HWSEQ_CTRL, bytetmp);\r\nmdelay(2);\r\nif (rtlhal->hw_type == HARDWARE_TYPE_RTL8821AE) {\r\nbytetmp = rtl_read_byte(rtlpriv, REG_SYS_CFG + 3);\r\nif (bytetmp & BIT(0)) {\r\nbytetmp = rtl_read_byte(rtlpriv, 0x7c);\r\nbytetmp |= BIT(6);\r\nrtl_write_byte(rtlpriv, 0x7c, bytetmp);\r\n}\r\n}\r\nbytetmp = rtl_read_byte(rtlpriv, REG_GPIO_MUXCFG + 1);\r\nbytetmp &= ~BIT(4);\r\nrtl_write_byte(rtlpriv, REG_GPIO_MUXCFG + 1, bytetmp);\r\nrtl_write_word(rtlpriv, REG_CR, 0x2ff);\r\nif (!mac_func_enable) {\r\nif (!_rtl8821ae_llt_table_init(hw))\r\nreturn false;\r\n}\r\nrtl_write_dword(rtlpriv, REG_HISR, 0xffffffff);\r\nrtl_write_dword(rtlpriv, REG_HISRE, 0xffffffff);\r\nbytetmp = rtl_read_byte(rtlpriv, REG_FWIMR + 3);\r\nrtl_write_byte(rtlpriv, REG_FWIMR + 3, bytetmp | BIT(6));\r\nwordtmp = rtl_read_word(rtlpriv, REG_TRXDMA_CTRL);\r\nwordtmp &= 0xf;\r\nwordtmp |= 0xF5B1;\r\nrtl_write_word(rtlpriv, REG_TRXDMA_CTRL, wordtmp);\r\nrtl_write_byte(rtlpriv, REG_FWHW_TXQ_CTRL + 1, 0x1F);\r\nrtl_write_dword(rtlpriv, REG_RCR, rtlpci->receive_config);\r\nrtl_write_word(rtlpriv, REG_RXFLTMAP2, 0xFFFF);\r\nrtl_write_dword(rtlpriv, REG_BCNQ_DESA,\r\nrtlpci->tx_ring[BEACON_QUEUE].dma & DMA_BIT_MASK(32));\r\nrtl_write_dword(rtlpriv, REG_MGQ_DESA,\r\nrtlpci->tx_ring[MGNT_QUEUE].dma & DMA_BIT_MASK(32));\r\nrtl_write_dword(rtlpriv, REG_VOQ_DESA,\r\nrtlpci->tx_ring[VO_QUEUE].dma & DMA_BIT_MASK(32));\r\nrtl_write_dword(rtlpriv, REG_VIQ_DESA,\r\nrtlpci->tx_ring[VI_QUEUE].dma & DMA_BIT_MASK(32));\r\nrtl_write_dword(rtlpriv, REG_BEQ_DESA,\r\nrtlpci->tx_ring[BE_QUEUE].dma & DMA_BIT_MASK(32));\r\nrtl_write_dword(rtlpriv, REG_BKQ_DESA,\r\nrtlpci->tx_ring[BK_QUEUE].dma & DMA_BIT_MASK(32));\r\nrtl_write_dword(rtlpriv, REG_HQ_DESA,\r\nrtlpci->tx_ring[HIGH_QUEUE].dma & DMA_BIT_MASK(32));\r\nrtl_write_dword(rtlpriv, REG_RX_DESA,\r\nrtlpci->rx_ring[RX_MPDU_QUEUE].dma & DMA_BIT_MASK(32));\r\nrtl_write_byte(rtlpriv, REG_PCIE_CTRL_REG + 3, 0x77);\r\nrtl_write_dword(rtlpriv, REG_INT_MIG, 0);\r\nrtl_write_dword(rtlpriv, REG_MCUTST_1, 0);\r\nrtl_write_byte(rtlpriv, REG_SECONDARY_CCA_CTRL, 0x3);\r\n_rtl8821ae_gen_refresh_led_state(hw);\r\nreturn true;\r\n}\r\nstatic void _rtl8821ae_hw_configure(struct ieee80211_hw *hw)\r\n{\r\nstruct rtl_priv *rtlpriv = rtl_priv(hw);\r\nstruct rtl_pci *rtlpci = rtl_pcidev(rtl_pcipriv(hw));\r\nu32 reg_rrsr;\r\nreg_rrsr = RATE_ALL_CCK | RATE_ALL_OFDM_AG;\r\nrtl_write_dword(rtlpriv, REG_RRSR, reg_rrsr);\r\nrtl_write_dword(rtlpriv, REG_ARFR0 + 4, 0xfffff000);\r\nrtl_write_dword(rtlpriv, REG_ARFR1 + 4, 0x003ff000);\r\nrtl_write_dword(rtlpriv, REG_ARFR2, 0x00000015);\r\nrtl_write_dword(rtlpriv, REG_ARFR2 + 4, 0x003ff000);\r\nrtl_write_dword(rtlpriv, REG_ARFR3, 0x00000015);\r\nrtl_write_dword(rtlpriv, REG_ARFR3 + 4, 0xffcff000);\r\nrtl_write_word(rtlpriv, REG_FWHW_TXQ_CTRL, 0x1F00);\r\nrtl_write_byte(rtlpriv, REG_AMPDU_MAX_TIME, 0x70);\r\nrtl_write_word(rtlpriv, REG_RL, 0x0707);\r\nrtl_write_dword(rtlpriv, REG_DARFRC, 0x01000000);\r\nrtl_write_dword(rtlpriv, REG_DARFRC + 4, 0x07060504);\r\nrtl_write_dword(rtlpriv, REG_RARFRC, 0x01000000);\r\nrtl_write_dword(rtlpriv, REG_RARFRC + 4, 0x07060504);\r\nrtlpci->reg_bcn_ctrl_val = 0x1d;\r\nrtl_write_byte(rtlpriv, REG_BCN_CTRL, rtlpci->reg_bcn_ctrl_val);\r\nrtl_write_byte(rtlpriv, REG_TBTT_PROHIBIT + 1, 0xff);\r\nrtl_write_word(rtlpriv, REG_NAV_PROT_LEN, 0x0040);\r\nrtl_write_dword(rtlpriv, REG_FAST_EDCA_CTRL, 0x03086666);\r\nrtl_write_byte(rtlpriv, REG_HT_SINGLE_AMPDU, 0x80);\r\nrtl_write_byte(rtlpriv, REG_RX_PKT_LIMIT, 0x20);\r\nrtl_write_word(rtlpriv, REG_MAX_AGGR_NUM, 0x1F1F);\r\n}\r\nstatic u16 _rtl8821ae_mdio_read(struct rtl_priv *rtlpriv, u8 addr)\r\n{\r\nu16 ret = 0;\r\nu8 tmp = 0, count = 0;\r\nrtl_write_byte(rtlpriv, REG_MDIO_CTL, addr | BIT(6));\r\ntmp = rtl_read_byte(rtlpriv, REG_MDIO_CTL) & BIT(6);\r\ncount = 0;\r\nwhile (tmp && count < 20) {\r\nudelay(10);\r\ntmp = rtl_read_byte(rtlpriv, REG_MDIO_CTL) & BIT(6);\r\ncount++;\r\n}\r\nif (0 == tmp)\r\nret = rtl_read_word(rtlpriv, REG_MDIO_RDATA);\r\nreturn ret;\r\n}\r\nstatic void _rtl8821ae_mdio_write(struct rtl_priv *rtlpriv, u8 addr, u16 data)\r\n{\r\nu8 tmp = 0, count = 0;\r\nrtl_write_word(rtlpriv, REG_MDIO_WDATA, data);\r\nrtl_write_byte(rtlpriv, REG_MDIO_CTL, addr | BIT(5));\r\ntmp = rtl_read_byte(rtlpriv, REG_MDIO_CTL) & BIT(5);\r\ncount = 0;\r\nwhile (tmp && count < 20) {\r\nudelay(10);\r\ntmp = rtl_read_byte(rtlpriv, REG_MDIO_CTL) & BIT(5);\r\ncount++;\r\n}\r\n}\r\nstatic u8 _rtl8821ae_dbi_read(struct rtl_priv *rtlpriv, u16 addr)\r\n{\r\nu16 read_addr = addr & 0xfffc;\r\nu8 tmp = 0, count = 0, ret = 0;\r\nrtl_write_word(rtlpriv, REG_DBI_ADDR, read_addr);\r\nrtl_write_byte(rtlpriv, REG_DBI_FLAG, 0x2);\r\ntmp = rtl_read_byte(rtlpriv, REG_DBI_FLAG);\r\ncount = 0;\r\nwhile (tmp && count < 20) {\r\nudelay(10);\r\ntmp = rtl_read_byte(rtlpriv, REG_DBI_FLAG);\r\ncount++;\r\n}\r\nif (0 == tmp) {\r\nread_addr = REG_DBI_RDATA + addr % 4;\r\nret = rtl_read_word(rtlpriv, read_addr);\r\n}\r\nreturn ret;\r\n}\r\nstatic void _rtl8821ae_dbi_write(struct rtl_priv *rtlpriv, u16 addr, u8 data)\r\n{\r\nu8 tmp = 0, count = 0;\r\nu16 wrtie_addr, remainder = addr % 4;\r\nwrtie_addr = REG_DBI_WDATA + remainder;\r\nrtl_write_byte(rtlpriv, wrtie_addr, data);\r\nwrtie_addr = (addr & 0xfffc) | (BIT(0) << (remainder + 12));\r\nrtl_write_word(rtlpriv, REG_DBI_ADDR, wrtie_addr);\r\nrtl_write_byte(rtlpriv, REG_DBI_FLAG, 0x1);\r\ntmp = rtl_read_byte(rtlpriv, REG_DBI_FLAG);\r\ncount = 0;\r\nwhile (tmp && count < 20) {\r\nudelay(10);\r\ntmp = rtl_read_byte(rtlpriv, REG_DBI_FLAG);\r\ncount++;\r\n}\r\n}\r\nstatic void _rtl8821ae_enable_aspm_back_door(struct ieee80211_hw *hw)\r\n{\r\nstruct rtl_priv *rtlpriv = rtl_priv(hw);\r\nstruct rtl_hal *rtlhal = rtl_hal(rtl_priv(hw));\r\nu8 tmp;\r\nif (rtlhal->hw_type == HARDWARE_TYPE_RTL8821AE) {\r\nif (_rtl8821ae_mdio_read(rtlpriv, 0x04) != 0x8544)\r\n_rtl8821ae_mdio_write(rtlpriv, 0x04, 0x8544);\r\nif (_rtl8821ae_mdio_read(rtlpriv, 0x0b) != 0x0070)\r\n_rtl8821ae_mdio_write(rtlpriv, 0x0b, 0x0070);\r\n}\r\ntmp = _rtl8821ae_dbi_read(rtlpriv, 0x70f);\r\n_rtl8821ae_dbi_write(rtlpriv, 0x70f, tmp | BIT(7));\r\ntmp = _rtl8821ae_dbi_read(rtlpriv, 0x719);\r\n_rtl8821ae_dbi_write(rtlpriv, 0x719, tmp | BIT(3) | BIT(4));\r\nif (rtlhal->hw_type == HARDWARE_TYPE_RTL8812AE) {\r\ntmp = _rtl8821ae_dbi_read(rtlpriv, 0x718);\r\n_rtl8821ae_dbi_write(rtlpriv, 0x718, tmp|BIT(4));\r\n}\r\n}\r\nvoid rtl8821ae_enable_hw_security_config(struct ieee80211_hw *hw)\r\n{\r\nstruct rtl_priv *rtlpriv = rtl_priv(hw);\r\nu8 sec_reg_value;\r\nu8 tmp;\r\nRT_TRACE(rtlpriv, COMP_INIT, DBG_DMESG,\r\n"PairwiseEncAlgorithm = %d GroupEncAlgorithm = %d\n",\r\nrtlpriv->sec.pairwise_enc_algorithm,\r\nrtlpriv->sec.group_enc_algorithm);\r\nif (rtlpriv->cfg->mod_params->sw_crypto || rtlpriv->sec.use_sw_sec) {\r\nRT_TRACE(rtlpriv, COMP_SEC, DBG_DMESG,\r\n"not open hw encryption\n");\r\nreturn;\r\n}\r\nsec_reg_value = SCR_TXENCENABLE | SCR_RXDECENABLE;\r\nif (rtlpriv->sec.use_defaultkey) {\r\nsec_reg_value |= SCR_TXUSEDK;\r\nsec_reg_value |= SCR_RXUSEDK;\r\n}\r\nsec_reg_value |= (SCR_RXBCUSEDK | SCR_TXBCUSEDK);\r\ntmp = rtl_read_byte(rtlpriv, REG_CR + 1);\r\nrtl_write_byte(rtlpriv, REG_CR + 1, tmp | BIT(1));\r\nRT_TRACE(rtlpriv, COMP_SEC, DBG_DMESG,\r\n"The SECR-value %x\n", sec_reg_value);\r\nrtlpriv->cfg->ops->set_hw_reg(hw, HW_VAR_WPA_CONFIG, &sec_reg_value);\r\n}\r\nstatic void rtl8821ae_macid_initialize_mediastatus(struct ieee80211_hw *hw)\r\n{\r\nstruct rtl_priv *rtlpriv = rtl_priv(hw);\r\nu8 media_rpt[4] = {RT_MEDIA_CONNECT, 1,\r\nMAC_ID_STATIC_FOR_BROADCAST_MULTICAST,\r\nMAC_ID_STATIC_FOR_BT_CLIENT_END};\r\nrtlpriv->cfg->ops->set_hw_reg(hw,\r\nHW_VAR_H2C_FW_MEDIASTATUSRPT, media_rpt);\r\nRT_TRACE(rtlpriv, COMP_INIT, DBG_LOUD,\r\n"Initialize MacId media status: from %d to %d\n",\r\nMAC_ID_STATIC_FOR_BROADCAST_MULTICAST,\r\nMAC_ID_STATIC_FOR_BT_CLIENT_END);\r\n}\r\nstatic bool _rtl8821ae_check_pcie_dma_hang(struct ieee80211_hw *hw)\r\n{\r\nstruct rtl_priv *rtlpriv = rtl_priv(hw);\r\nu8 tmp;\r\ntmp = rtl_read_byte(rtlpriv, REG_DBI_CTRL + 3);\r\nif (!(tmp & BIT(2))) {\r\nrtl_write_byte(rtlpriv, REG_DBI_CTRL + 3, (tmp | BIT(2)));\r\nmdelay(100);\r\n}\r\ntmp = rtl_read_byte(rtlpriv, REG_DBI_CTRL + 3);\r\nif ((tmp & BIT(0)) || (tmp & BIT(1))) {\r\nRT_TRACE(rtlpriv, COMP_INIT, DBG_LOUD,\r\n"CheckPcieDMAHang8821AE(): true! Reset PCIE DMA!\n");\r\nreturn true;\r\n} else {\r\nreturn false;\r\n}\r\n}\r\nstatic bool _rtl8821ae_reset_pcie_interface_dma(struct ieee80211_hw *hw,\r\nbool mac_power_on,\r\nbool in_watchdog)\r\n{\r\nstruct rtl_priv *rtlpriv = rtl_priv(hw);\r\nstruct rtl_hal *rtlhal = rtl_hal(rtl_priv(hw));\r\nu8 tmp;\r\nbool release_mac_rx_pause;\r\nu8 backup_pcie_dma_pause;\r\nRT_TRACE(rtlpriv, COMP_INIT, DBG_LOUD, "\n");\r\ntmp = rtl_read_byte(rtlpriv, REG_RSV_CTRL);\r\ntmp &= ~(BIT(1));\r\nrtl_write_byte(rtlpriv, REG_RSV_CTRL, tmp);\r\nif (rtlhal->hw_type == HARDWARE_TYPE_RTL8821AE) {\r\ntmp = rtl_read_byte(rtlpriv, REG_PMC_DBG_CTRL2);\r\ntmp |= BIT(2);\r\nrtl_write_byte(rtlpriv, REG_PMC_DBG_CTRL2, tmp);\r\n}\r\ntmp = rtl_read_byte(rtlpriv, REG_RXDMA_CONTROL);\r\nif (tmp & BIT(2)) {\r\nrelease_mac_rx_pause = false;\r\n} else {\r\nrtl_write_byte(rtlpriv, REG_RXDMA_CONTROL, (tmp | BIT(2)));\r\nrelease_mac_rx_pause = true;\r\n}\r\nbackup_pcie_dma_pause = rtl_read_byte(rtlpriv, REG_PCIE_CTRL_REG + 1);\r\nif (backup_pcie_dma_pause != 0xFF)\r\nrtl_write_byte(rtlpriv, REG_PCIE_CTRL_REG + 1, 0xFF);\r\nif (mac_power_on) {\r\nrtl_write_byte(rtlpriv, REG_CR, 0);\r\n}\r\ntmp = rtl_read_byte(rtlpriv, REG_SYS_FUNC_EN + 1);\r\ntmp &= ~(BIT(0));\r\nrtl_write_byte(rtlpriv, REG_SYS_FUNC_EN + 1, tmp);\r\ntmp = rtl_read_byte(rtlpriv, REG_SYS_FUNC_EN + 1);\r\ntmp |= BIT(0);\r\nrtl_write_byte(rtlpriv, REG_SYS_FUNC_EN + 1, tmp);\r\nif (mac_power_on) {\r\nrtl_write_byte(rtlpriv, REG_CR, 0xFF);\r\n}\r\nif (rtlhal->hw_type == HARDWARE_TYPE_RTL8821AE) {\r\ntmp = rtl_read_byte(rtlpriv, REG_MAC_PHY_CTRL_NORMAL + 2);\r\ntmp |= BIT(1);\r\nrtl_write_byte(rtlpriv, REG_MAC_PHY_CTRL_NORMAL + 2, tmp);\r\n}\r\nif (!mac_power_on) {\r\nif (release_mac_rx_pause) {\r\ntmp = rtl_read_byte(rtlpriv, REG_RXDMA_CONTROL);\r\nrtl_write_byte(rtlpriv, REG_RXDMA_CONTROL,\r\ntmp & (~BIT(2)));\r\n}\r\nrtl_write_byte(rtlpriv, REG_PCIE_CTRL_REG + 1,\r\nbackup_pcie_dma_pause);\r\n}\r\nif (rtlhal->hw_type == HARDWARE_TYPE_RTL8821AE) {\r\ntmp = rtl_read_byte(rtlpriv, REG_PMC_DBG_CTRL2);\r\ntmp &= ~(BIT(2));\r\nrtl_write_byte(rtlpriv, REG_PMC_DBG_CTRL2, tmp);\r\n}\r\nreturn true;\r\n}\r\nstatic void _rtl8821ae_get_wakeup_reason(struct ieee80211_hw *hw)\r\n{\r\nstruct rtl_priv *rtlpriv = rtl_priv(hw);\r\nstruct rtl_hal *rtlhal = rtl_hal(rtl_priv(hw));\r\nstruct rtl_ps_ctl *ppsc = rtl_psc(rtlpriv);\r\nu8 fw_reason = 0;\r\nstruct timeval ts;\r\nfw_reason = rtl_read_byte(rtlpriv, REG_MCUTST_WOWLAN);\r\nRT_TRACE(rtlpriv, COMP_POWER, DBG_LOUD, "WOL Read 0x1c7 = %02X\n",\r\nfw_reason);\r\nppsc->wakeup_reason = 0;\r\nrtlhal->last_suspend_sec = ts.tv_sec;\r\nswitch (fw_reason) {\r\ncase FW_WOW_V2_PTK_UPDATE_EVENT:\r\nppsc->wakeup_reason = WOL_REASON_PTK_UPDATE;\r\ndo_gettimeofday(&ts);\r\nppsc->last_wakeup_time = ts.tv_sec*1000 + ts.tv_usec/1000;\r\nRT_TRACE(rtlpriv, COMP_POWER, DBG_DMESG,\r\n"It's a WOL PTK Key update event!\n");\r\nbreak;\r\ncase FW_WOW_V2_GTK_UPDATE_EVENT:\r\nppsc->wakeup_reason = WOL_REASON_GTK_UPDATE;\r\ndo_gettimeofday(&ts);\r\nppsc->last_wakeup_time = ts.tv_sec*1000 + ts.tv_usec/1000;\r\nRT_TRACE(rtlpriv, COMP_POWER, DBG_DMESG,\r\n"It's a WOL GTK Key update event!\n");\r\nbreak;\r\ncase FW_WOW_V2_DISASSOC_EVENT:\r\nppsc->wakeup_reason = WOL_REASON_DISASSOC;\r\nRT_TRACE(rtlpriv, COMP_POWER, DBG_DMESG,\r\n"It's a disassociation event!\n");\r\nbreak;\r\ncase FW_WOW_V2_DEAUTH_EVENT:\r\nppsc->wakeup_reason = WOL_REASON_DEAUTH;\r\nRT_TRACE(rtlpriv, COMP_POWER, DBG_DMESG,\r\n"It's a deauth event!\n");\r\nbreak;\r\ncase FW_WOW_V2_FW_DISCONNECT_EVENT:\r\nppsc->wakeup_reason = WOL_REASON_AP_LOST;\r\nRT_TRACE(rtlpriv, COMP_POWER, DBG_DMESG,\r\n"It's a Fw disconnect decision (AP lost) event!\n");\r\nbreak;\r\ncase FW_WOW_V2_MAGIC_PKT_EVENT:\r\nppsc->wakeup_reason = WOL_REASON_MAGIC_PKT;\r\nRT_TRACE(rtlpriv, COMP_POWER, DBG_DMESG,\r\n"It's a magic packet event!\n");\r\nbreak;\r\ncase FW_WOW_V2_UNICAST_PKT_EVENT:\r\nppsc->wakeup_reason = WOL_REASON_UNICAST_PKT;\r\nRT_TRACE(rtlpriv, COMP_POWER, DBG_DMESG,\r\n"It's an unicast packet event!\n");\r\nbreak;\r\ncase FW_WOW_V2_PATTERN_PKT_EVENT:\r\nppsc->wakeup_reason = WOL_REASON_PATTERN_PKT;\r\nRT_TRACE(rtlpriv, COMP_POWER, DBG_DMESG,\r\n"It's a pattern match event!\n");\r\nbreak;\r\ncase FW_WOW_V2_RTD3_SSID_MATCH_EVENT:\r\nppsc->wakeup_reason = WOL_REASON_RTD3_SSID_MATCH;\r\nRT_TRACE(rtlpriv, COMP_POWER, DBG_DMESG,\r\n"It's an RTD3 Ssid match event!\n");\r\nbreak;\r\ncase FW_WOW_V2_REALWOW_V2_WAKEUPPKT:\r\nppsc->wakeup_reason = WOL_REASON_REALWOW_V2_WAKEUPPKT;\r\nRT_TRACE(rtlpriv, COMP_POWER, DBG_DMESG,\r\n"It's an RealWoW wake packet event!\n");\r\nbreak;\r\ncase FW_WOW_V2_REALWOW_V2_ACKLOST:\r\nppsc->wakeup_reason = WOL_REASON_REALWOW_V2_ACKLOST;\r\nRT_TRACE(rtlpriv, COMP_POWER, DBG_DMESG,\r\n"It's an RealWoW ack lost event!\n");\r\nbreak;\r\ndefault:\r\nRT_TRACE(rtlpriv, COMP_POWER, DBG_DMESG,\r\n"WOL Read 0x1c7 = %02X, Unknown reason!\n",\r\nfw_reason);\r\nbreak;\r\n}\r\n}\r\nstatic void _rtl8821ae_init_trx_desc_hw_address(struct ieee80211_hw *hw)\r\n{\r\nstruct rtl_priv *rtlpriv = rtl_priv(hw);\r\nstruct rtl_pci *rtlpci = rtl_pcidev(rtl_pcipriv(hw));\r\nrtl_write_dword(rtlpriv, REG_BCNQ_DESA,\r\nrtlpci->tx_ring[BEACON_QUEUE].dma & DMA_BIT_MASK(32));\r\nrtl_write_dword(rtlpriv, REG_MGQ_DESA,\r\nrtlpci->tx_ring[MGNT_QUEUE].dma & DMA_BIT_MASK(32));\r\nrtl_write_dword(rtlpriv, REG_VOQ_DESA,\r\nrtlpci->tx_ring[VO_QUEUE].dma & DMA_BIT_MASK(32));\r\nrtl_write_dword(rtlpriv, REG_VIQ_DESA,\r\nrtlpci->tx_ring[VI_QUEUE].dma & DMA_BIT_MASK(32));\r\nrtl_write_dword(rtlpriv, REG_BEQ_DESA,\r\nrtlpci->tx_ring[BE_QUEUE].dma & DMA_BIT_MASK(32));\r\nrtl_write_dword(rtlpriv, REG_BKQ_DESA,\r\nrtlpci->tx_ring[BK_QUEUE].dma & DMA_BIT_MASK(32));\r\nrtl_write_dword(rtlpriv, REG_HQ_DESA,\r\nrtlpci->tx_ring[HIGH_QUEUE].dma & DMA_BIT_MASK(32));\r\nrtl_write_dword(rtlpriv, REG_RX_DESA,\r\nrtlpci->rx_ring[RX_MPDU_QUEUE].dma & DMA_BIT_MASK(32));\r\n}\r\nstatic bool _rtl8821ae_init_llt_table(struct ieee80211_hw *hw, u32 boundary)\r\n{\r\nbool status = true;\r\nu32 i;\r\nu32 txpktbuf_bndy = boundary;\r\nu32 last_entry_of_txpktbuf = LAST_ENTRY_OF_TX_PKT_BUFFER;\r\nfor (i = 0 ; i < (txpktbuf_bndy - 1) ; i++) {\r\nstatus = _rtl8821ae_llt_write(hw, i , i + 1);\r\nif (!status)\r\nreturn status;\r\n}\r\nstatus = _rtl8821ae_llt_write(hw, (txpktbuf_bndy - 1), 0xFF);\r\nif (!status)\r\nreturn status;\r\nfor (i = txpktbuf_bndy ; i < last_entry_of_txpktbuf ; i++) {\r\nstatus = _rtl8821ae_llt_write(hw, i, (i + 1));\r\nif (!status)\r\nreturn status;\r\n}\r\nstatus = _rtl8821ae_llt_write(hw, last_entry_of_txpktbuf,\r\ntxpktbuf_bndy);\r\nif (!status)\r\nreturn status;\r\nreturn status;\r\n}\r\nstatic bool _rtl8821ae_dynamic_rqpn(struct ieee80211_hw *hw, u32 boundary,\r\nu16 npq_rqpn_value, u32 rqpn_val)\r\n{\r\nstruct rtl_priv *rtlpriv = rtl_priv(hw);\r\nu8 tmp;\r\nbool ret = true;\r\nu16 count = 0, tmp16;\r\nbool support_remote_wakeup;\r\nrtlpriv->cfg->ops->get_hw_reg(hw, HAL_DEF_WOWLAN,\r\n(u8 *)(&support_remote_wakeup));\r\nRT_TRACE(rtlpriv, COMP_INIT, DBG_LOUD,\r\n"boundary=%#X, NPQ_RQPNValue=%#X, RQPNValue=%#X\n",\r\nboundary, npq_rqpn_value, rqpn_val);\r\nrtl_write_byte(rtlpriv, REG_PCIE_CTRL_REG + 1, 0xFE);\r\ntmp16 = rtl_read_word(rtlpriv, REG_TXPKT_EMPTY);\r\nwhile ((tmp16 & 0x07FF) != 0x07FF) {\r\nudelay(100);\r\ntmp16 = rtl_read_word(rtlpriv, REG_TXPKT_EMPTY);\r\ncount++;\r\nif ((count % 200) == 0) {\r\nRT_TRACE(rtlpriv, COMP_INIT, DBG_LOUD,\r\n"Tx queue is not empty for 20ms!\n");\r\n}\r\nif (count >= 1000) {\r\nRT_TRACE(rtlpriv, COMP_INIT, DBG_LOUD,\r\n"Wait for Tx FIFO empty timeout!\n");\r\nbreak;\r\n}\r\n}\r\nrtl_write_byte(rtlpriv, REG_TXPAUSE, 0xFF);\r\ncount = 0;\r\nwhile (rtl_read_byte(rtlpriv, REG_SCH_TXCMD) != 0) {\r\nudelay(100);\r\ncount++;\r\nif (count >= 500) {\r\nRT_TRACE(rtlpriv, COMP_INIT, DBG_LOUD,\r\n"Wait for TX State Machine ready timeout !!\n");\r\nbreak;\r\n}\r\n}\r\ncount = 0;\r\ntmp = rtl_read_byte(rtlpriv, REG_RXDMA_CONTROL);\r\nrtl_write_byte(rtlpriv, REG_RXDMA_CONTROL, (tmp | BIT(2)));\r\ndo {\r\ntmp = rtl_read_byte(rtlpriv, REG_RXDMA_CONTROL);\r\nudelay(10);\r\ncount++;\r\n} while (!(tmp & BIT(1)) && count < 100);\r\nRT_TRACE(rtlpriv, COMP_INIT, DBG_LOUD,\r\n"Wait until Rx DMA Idle. count=%d REG[0x286]=0x%x\n",\r\ncount, tmp);\r\ntmp = rtl_read_byte(rtlpriv, REG_SYS_FUNC_EN);\r\ntmp &= ~(BIT(0));\r\nrtl_write_byte(rtlpriv, REG_SYS_FUNC_EN, tmp);\r\nrtl_write_byte(rtlpriv, REG_CR, 0x00);\r\nudelay(1000);\r\ntmp = rtl_read_byte(rtlpriv, REG_CR + 1);\r\ntmp &= ~(BIT(1));\r\nrtl_write_byte(rtlpriv, REG_CR + 1, tmp);\r\ntmp = rtl_read_byte(rtlpriv, REG_DUAL_TSF_RST);\r\nrtl_write_byte(rtlpriv, REG_DUAL_TSF_RST, (tmp | BIT(5)));\r\ntmp = rtl_read_byte(rtlpriv, REG_CR + 1);\r\nrtl_write_byte(rtlpriv, REG_CR + 1, (tmp | BIT(1)));\r\nrtl_write_byte(rtlpriv, REG_CR, 0xFF);\r\nudelay(1000);\r\ntmp = rtl_read_byte(rtlpriv, REG_SYS_FUNC_EN);\r\nrtl_write_byte(rtlpriv, REG_SYS_FUNC_EN, (tmp | BIT(0)));\r\nrtl_write_byte(rtlpriv, REG_TDECTRL + 1, (u8)boundary);\r\nrtl_write_byte(rtlpriv, REG_TXPKTBUF_BCNQ_BDNY, (u8)boundary);\r\nrtl_write_byte(rtlpriv, REG_TXPKTBUF_MGQ_BDNY, (u8)boundary);\r\nrtl_write_byte(rtlpriv, REG_TXPKTBUF_WMAC_LBK_BF_HD,\r\n(u8)boundary);\r\nrtl_write_word(rtlpriv, REG_TRXFF_BNDY, boundary);\r\nif (!_rtl8821ae_init_llt_table(hw, boundary)) {\r\nRT_TRACE(rtlpriv, COMP_INIT, DBG_WARNING,\r\n"Failed to init LLT table!\n");\r\nreturn false;\r\n}\r\nrtl_write_word(rtlpriv, REG_RQPN_NPQ, npq_rqpn_value);\r\nrtl_write_dword(rtlpriv, REG_RQPN, rqpn_val);\r\nrtl_write_byte(rtlpriv, REG_TXPAUSE, 0x00);\r\nrtl_write_byte(rtlpriv, REG_PCIE_CTRL_REG + 1, 0x00);\r\ntmp = rtl_read_byte(rtlpriv, REG_RXDMA_CONTROL);\r\nrtl_write_byte(rtlpriv, REG_RXDMA_CONTROL, (tmp&~BIT(2)));\r\nRT_TRACE(rtlpriv, COMP_INIT, DBG_LOUD, "End.\n");\r\nreturn ret;\r\n}\r\nstatic void _rtl8821ae_simple_initialize_adapter(struct ieee80211_hw *hw)\r\n{\r\nstruct rtl_priv *rtlpriv = rtl_priv(hw);\r\nstruct rtl_hal *rtlhal = rtl_hal(rtlpriv);\r\nstruct rtl_ps_ctl *ppsc = rtl_psc(rtlpriv);\r\n#if (USE_SPECIFIC_FW_TO_SUPPORT_WOWLAN == 1)\r\nrtl8821ae_set_fw_related_for_wowlan(hw, false);\r\n#endif\r\nif (rtlhal->re_init_llt_table) {\r\nu32 rqpn = 0x80e70808;\r\nu8 rqpn_npq = 0, boundary = 0xF8;\r\nif (rtlhal->hw_type == HARDWARE_TYPE_RTL8812AE) {\r\nrqpn = 0x80e90808;\r\nboundary = 0xFA;\r\n}\r\nif (_rtl8821ae_dynamic_rqpn(hw, boundary, rqpn_npq, rqpn))\r\nrtlhal->re_init_llt_table = false;\r\n}\r\nppsc->rfpwr_state = ERFON;\r\n}\r\nstatic void _rtl8821ae_enable_l1off(struct ieee80211_hw *hw)\r\n{\r\nu8 tmp = 0;\r\nstruct rtl_priv *rtlpriv = rtl_priv(hw);\r\nRT_TRACE(rtlpriv, COMP_INIT, DBG_LOUD, "--->\n");\r\ntmp = _rtl8821ae_dbi_read(rtlpriv, 0x160);\r\nif (!(tmp & (BIT(2) | BIT(3)))) {\r\nRT_TRACE(rtlpriv, COMP_POWER | COMP_INIT, DBG_LOUD,\r\n"0x160(%#x)return!!\n", tmp);\r\nreturn;\r\n}\r\ntmp = _rtl8821ae_mdio_read(rtlpriv, 0x1b);\r\n_rtl8821ae_mdio_write(rtlpriv, 0x1b, (tmp | BIT(4)));\r\ntmp = _rtl8821ae_dbi_read(rtlpriv, 0x718);\r\n_rtl8821ae_dbi_write(rtlpriv, 0x718, tmp | BIT(5));\r\nRT_TRACE(rtlpriv, COMP_INIT, DBG_LOUD, "<---\n");\r\n}\r\nstatic void _rtl8821ae_enable_ltr(struct ieee80211_hw *hw)\r\n{\r\nu8 tmp = 0;\r\nstruct rtl_priv *rtlpriv = rtl_priv(hw);\r\nRT_TRACE(rtlpriv, COMP_INIT, DBG_LOUD, "--->\n");\r\ntmp = _rtl8821ae_dbi_read(rtlpriv, 0x99);\r\nif (!(tmp & BIT(2))) {\r\nRT_TRACE(rtlpriv, COMP_INIT, DBG_LOUD,\r\n"<---0x99(%#x) return!!\n", tmp);\r\nreturn;\r\n}\r\nrtl_write_dword(rtlpriv, 0x798, 0x88908890);\r\nrtl_write_dword(rtlpriv, 0x79c, 0x883c883c);\r\ntmp = rtl_read_byte(rtlpriv, 0x7a4);\r\nrtl_write_byte(rtlpriv, 0x7a4, (tmp | BIT(4)));\r\ntmp = rtl_read_byte(rtlpriv, 0x7a4);\r\nrtl_write_byte(rtlpriv, 0x7a4, (tmp & (~BIT(0))));\r\nrtl_write_byte(rtlpriv, 0x7a4, (tmp | BIT(0)));\r\nRT_TRACE(rtlpriv, COMP_INIT, DBG_LOUD, "<---\n");\r\n}\r\nstatic bool _rtl8821ae_wowlan_initialize_adapter(struct ieee80211_hw *hw)\r\n{\r\nstruct rtl_priv *rtlpriv = rtl_priv(hw);\r\nstruct rtl_hal *rtlhal = rtl_hal(rtlpriv);\r\nbool init_finished = true;\r\nu8 tmp = 0;\r\n_rtl8821ae_get_wakeup_reason(hw);\r\nif (_rtl8821ae_check_pcie_dma_hang(hw))\r\n_rtl8821ae_reset_pcie_interface_dma(hw, true, false);\r\n_rtl8821ae_init_trx_desc_hw_address(hw);\r\nrtl_write_byte(rtlpriv, REG_PCIE_CTRL_REG + 1, 0xFE);\r\nRT_TRACE(rtlpriv, COMP_POWER, DBG_LOUD, "Enable PCIE Rx DMA.\n");\r\ntmp = rtl_read_byte(rtlpriv, REG_FTISR + 3);\r\nRT_TRACE(rtlpriv, COMP_POWER, DBG_LOUD,\r\n"Read REG_FTISR 0x13f = %#X\n", tmp);\r\nrtl8821ae_set_fw_wowlan_mode(hw, false);\r\nrtl8821ae_set_fw_remote_wake_ctrl_cmd(hw, 0);\r\nif (rtlhal->hw_rof_enable) {\r\ntmp = rtl_read_byte(rtlpriv, REG_HSISR + 3);\r\nif (tmp & BIT(1)) {\r\nrtl_write_byte(rtlpriv, REG_HSISR + 3, tmp | BIT(1));\r\ninit_finished = false;\r\n} else {\r\ninit_finished = true;\r\n}\r\n}\r\nif (init_finished) {\r\n_rtl8821ae_simple_initialize_adapter(hw);\r\nrtl_write_byte(rtlpriv, REG_PCIE_CTRL_REG + 1, 0x00);\r\nrtl_write_byte(rtlpriv, REG_RXDMA_CONTROL, 0x02);\r\ntmp = rtl_read_byte(rtlpriv, REG_CR + 1);\r\nrtl_write_byte(rtlpriv, REG_CR + 1, (tmp & (~BIT(0))));\r\n_rtl8821ae_enable_l1off(hw);\r\n_rtl8821ae_enable_ltr(hw);\r\n}\r\nreturn init_finished;\r\n}\r\nstatic void _rtl8812ae_bb8812_config_1t(struct ieee80211_hw *hw)\r\n{\r\nrtl_set_bbreg(hw, 0x808, 0xff, 0x11);\r\nrtl_set_bbreg(hw, 0x80c, MASKLWORD, 0x1111);\r\nrtl_set_bbreg(hw, 0xa04, 0x0c000000, 0x0);\r\nrtl_set_bbreg(hw, 0x8bc, 0xc0000060, 0x4);\r\nrtl_set_bbreg(hw, 0xe00, 0xf, 0x4);\r\nrtl_set_bbreg(hw, 0xe90, MASKDWORD, 0);\r\nrtl_set_bbreg(hw, 0xe60, MASKDWORD, 0);\r\nrtl_set_bbreg(hw, 0xe64, MASKDWORD, 0);\r\n}\r\nstatic void _rtl8821ae_poweroff_adapter(struct ieee80211_hw *hw)\r\n{\r\nstruct rtl_priv *rtlpriv = rtl_priv(hw);\r\nstruct rtl_hal *rtlhal = rtl_hal(rtl_priv(hw));\r\nu8 u1b_tmp;\r\nrtlhal->mac_func_enable = false;\r\nif (rtlhal->hw_type == HARDWARE_TYPE_RTL8821AE) {\r\nrtl_hal_pwrseqcmdparsing(rtlpriv,\r\nPWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK,\r\nPWR_INTF_PCI_MSK, RTL8821A_NIC_LPS_ENTER_FLOW);\r\n}\r\nif ((rtl_read_byte(rtlpriv, REG_MCUFWDL) & BIT(7)) &&\r\nrtlhal->fw_ready) {\r\nrtl8821ae_firmware_selfreset(hw);\r\n}\r\nu1b_tmp = rtl_read_byte(rtlpriv, REG_SYS_FUNC_EN+1);\r\nrtl_write_byte(rtlpriv, REG_SYS_FUNC_EN+1, (u1b_tmp & (~BIT(2))));\r\nrtl_write_byte(rtlpriv, REG_MCUFWDL, 0x00);\r\nif (rtlhal->hw_type == HARDWARE_TYPE_RTL8821AE) {\r\nrtl_hal_pwrseqcmdparsing(rtlpriv, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK,\r\nPWR_INTF_PCI_MSK, RTL8821A_NIC_DISABLE_FLOW);\r\n} else {\r\nrtl_hal_pwrseqcmdparsing(rtlpriv, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK,\r\nPWR_INTF_PCI_MSK, RTL8812_NIC_DISABLE_FLOW);\r\n}\r\nu1b_tmp = rtl_read_byte(rtlpriv, REG_RSV_CTRL + 1);\r\nrtl_write_byte(rtlpriv, REG_RSV_CTRL + 1, (u1b_tmp & (~BIT(0))));\r\nu1b_tmp = rtl_read_byte(rtlpriv, REG_RSV_CTRL + 1);\r\nrtl_write_byte(rtlpriv, REG_RSV_CTRL + 1, u1b_tmp | BIT(0));\r\nrtl_write_byte(rtlpriv, REG_RSV_CTRL, 0x0e);\r\n}\r\nint rtl8821ae_hw_init(struct ieee80211_hw *hw)\r\n{\r\nstruct rtl_priv *rtlpriv = rtl_priv(hw);\r\nstruct rtl_hal *rtlhal = rtl_hal(rtl_priv(hw));\r\nstruct rtl_mac *mac = rtl_mac(rtl_priv(hw));\r\nstruct rtl_ps_ctl *ppsc = rtl_psc(rtl_priv(hw));\r\nbool rtstatus = true;\r\nint err;\r\nu8 tmp_u1b;\r\nbool support_remote_wakeup;\r\nu32 nav_upper = WIFI_NAV_UPPER_US;\r\nrtlhal->being_init_adapter = true;\r\nrtlpriv->cfg->ops->get_hw_reg(hw, HAL_DEF_WOWLAN,\r\n(u8 *)(&support_remote_wakeup));\r\nrtlpriv->intf_ops->disable_aspm(hw);\r\ntmp_u1b = rtl_read_byte(rtlpriv, REG_CR);\r\nif (tmp_u1b != 0 && tmp_u1b != 0xEA) {\r\nrtlhal->mac_func_enable = true;\r\nRT_TRACE(rtlpriv, COMP_INIT, DBG_LOUD,\r\n"MAC has already power on.\n");\r\n} else {\r\nrtlhal->mac_func_enable = false;\r\nrtlhal->fw_ps_state = FW_PS_STATE_ALL_ON_8821AE;\r\n}\r\nif (support_remote_wakeup &&\r\nrtlhal->wake_from_pnp_sleep &&\r\nrtlhal->mac_func_enable) {\r\nif (_rtl8821ae_wowlan_initialize_adapter(hw)) {\r\nrtlhal->being_init_adapter = false;\r\nreturn 0;\r\n}\r\n}\r\nif (_rtl8821ae_check_pcie_dma_hang(hw)) {\r\n_rtl8821ae_reset_pcie_interface_dma(hw,\r\nrtlhal->mac_func_enable,\r\nfalse);\r\nrtlhal->mac_func_enable = false;\r\n}\r\nif (rtlhal->mac_func_enable) {\r\n_rtl8821ae_poweroff_adapter(hw);\r\nrtlhal->mac_func_enable = false;\r\n}\r\nrtstatus = _rtl8821ae_init_mac(hw);\r\nif (rtstatus != true) {\r\nRT_TRACE(rtlpriv, COMP_ERR, DBG_EMERG, "Init MAC failed\n");\r\nerr = 1;\r\nreturn err;\r\n}\r\ntmp_u1b = rtl_read_byte(rtlpriv, REG_SYS_CFG);\r\ntmp_u1b &= 0x7F;\r\nrtl_write_byte(rtlpriv, REG_SYS_CFG, tmp_u1b);\r\nerr = rtl8821ae_download_fw(hw, false);\r\nif (err) {\r\nRT_TRACE(rtlpriv, COMP_ERR, DBG_WARNING,\r\n"Failed to download FW. Init HW without FW now\n");\r\nerr = 1;\r\nrtlhal->fw_ready = false;\r\nreturn err;\r\n} else {\r\nrtlhal->fw_ready = true;\r\n}\r\nppsc->fw_current_inpsmode = false;\r\nrtlhal->fw_ps_state = FW_PS_STATE_ALL_ON_8821AE;\r\nrtlhal->fw_clk_change_in_progress = false;\r\nrtlhal->allow_sw_to_change_hwclc = false;\r\nrtlhal->last_hmeboxnum = 0;\r\nrtl8821ae_phy_mac_config(hw);\r\nrtl8821ae_phy_bb_config(hw);\r\nrtl8821ae_phy_rf_config(hw);\r\nif (rtlpriv->phy.rf_type == RF_1T1R &&\r\nrtlhal->hw_type == HARDWARE_TYPE_RTL8812AE)\r\n_rtl8812ae_bb8812_config_1t(hw);\r\n_rtl8821ae_hw_configure(hw);\r\nrtl8821ae_phy_switch_wirelessband(hw, BAND_ON_2_4G);\r\nrtlhal->mac_func_enable = true;\r\nrtl_cam_reset_all_entry(hw);\r\nrtl8821ae_enable_hw_security_config(hw);\r\nppsc->rfpwr_state = ERFON;\r\nrtlpriv->cfg->ops->set_hw_reg(hw, HW_VAR_ETHER_ADDR, mac->mac_addr);\r\n_rtl8821ae_enable_aspm_back_door(hw);\r\nrtlpriv->intf_ops->enable_aspm(hw);\r\nif (rtlhal->hw_type == HARDWARE_TYPE_RTL8812AE &&\r\n(rtlhal->rfe_type == 1 || rtlhal->rfe_type == 5))\r\nrtl_set_bbreg(hw, 0x900, 0x00000303, 0x0302);\r\nrtl8821ae_bt_hw_init(hw);\r\nrtlpriv->rtlhal.being_init_adapter = false;\r\nrtlpriv->cfg->ops->set_hw_reg(hw, HW_VAR_NAV_UPPER, (u8 *)&nav_upper);\r\nif (support_remote_wakeup)\r\nrtl_write_byte(rtlpriv, REG_WOW_CTRL, 0);\r\ntmp_u1b = rtl_read_byte(rtlpriv, REG_RXDMA_CONTROL);\r\nif (tmp_u1b & BIT(2)) {\r\ntmp_u1b &= ~BIT(2);\r\nrtl_write_byte(rtlpriv, REG_RXDMA_CONTROL, tmp_u1b);\r\n}\r\nrtl_write_byte(rtlpriv, REG_PCIE_CTRL_REG + 1, 0);\r\nrtl8821ae_dm_init(hw);\r\nrtl8821ae_macid_initialize_mediastatus(hw);\r\nRT_TRACE(rtlpriv, COMP_INIT, DBG_LOUD, "rtl8821ae_hw_init() <====\n");\r\nreturn err;\r\n}\r\nstatic enum version_8821ae _rtl8821ae_read_chip_version(struct ieee80211_hw *hw)\r\n{\r\nstruct rtl_priv *rtlpriv = rtl_priv(hw);\r\nstruct rtl_phy *rtlphy = &rtlpriv->phy;\r\nstruct rtl_hal *rtlhal = rtl_hal(rtl_priv(hw));\r\nenum version_8821ae version = VERSION_UNKNOWN;\r\nu32 value32;\r\nvalue32 = rtl_read_dword(rtlpriv, REG_SYS_CFG);\r\nRT_TRACE(rtlpriv, COMP_INIT, DBG_LOUD,\r\n"ReadChipVersion8812A 0xF0 = 0x%x\n", value32);\r\nif (rtlhal->hw_type == HARDWARE_TYPE_RTL8812AE)\r\nrtlphy->rf_type = RF_2T2R;\r\nelse if (rtlhal->hw_type == HARDWARE_TYPE_RTL8821AE)\r\nrtlphy->rf_type = RF_1T1R;\r\nRT_TRACE(rtlpriv, COMP_INIT, DBG_LOUD,\r\n"RF_Type is %x!!\n", rtlphy->rf_type);\r\nif (value32 & TRP_VAUX_EN) {\r\nif (rtlhal->hw_type == HARDWARE_TYPE_RTL8812AE) {\r\nif (rtlphy->rf_type == RF_2T2R)\r\nversion = VERSION_TEST_CHIP_2T2R_8812;\r\nelse\r\nversion = VERSION_TEST_CHIP_1T1R_8812;\r\n} else\r\nversion = VERSION_TEST_CHIP_8821;\r\n} else {\r\nif (rtlhal->hw_type == HARDWARE_TYPE_RTL8812AE) {\r\nu32 rtl_id = ((value32 & CHIP_VER_RTL_MASK) >> 12) + 1;\r\nif (rtlphy->rf_type == RF_2T2R)\r\nversion =\r\n(enum version_8821ae)(CHIP_8812\r\n| NORMAL_CHIP |\r\nRF_TYPE_2T2R);\r\nelse\r\nversion = (enum version_8821ae)(CHIP_8812\r\n| NORMAL_CHIP);\r\nversion = (enum version_8821ae)(version | (rtl_id << 12));\r\n} else if (rtlhal->hw_type == HARDWARE_TYPE_RTL8821AE) {\r\nu32 rtl_id = value32 & CHIP_VER_RTL_MASK;\r\nversion = (enum version_8821ae)(CHIP_8821\r\n| NORMAL_CHIP | rtl_id);\r\n}\r\n}\r\nif (rtlhal->hw_type == HARDWARE_TYPE_RTL8821AE) {\r\nvalue32 = rtl_read_dword(rtlpriv, REG_MULTI_FUNC_CTRL);\r\nrtlhal->hw_rof_enable = ((value32 & WL_HWROF_EN) ? 1 : 0);\r\n}\r\nswitch (version) {\r\ncase VERSION_TEST_CHIP_1T1R_8812:\r\nRT_TRACE(rtlpriv, COMP_INIT, DBG_LOUD,\r\n"Chip Version ID: VERSION_TEST_CHIP_1T1R_8812\n");\r\nbreak;\r\ncase VERSION_TEST_CHIP_2T2R_8812:\r\nRT_TRACE(rtlpriv, COMP_INIT, DBG_LOUD,\r\n"Chip Version ID: VERSION_TEST_CHIP_2T2R_8812\n");\r\nbreak;\r\ncase VERSION_NORMAL_TSMC_CHIP_1T1R_8812:\r\nRT_TRACE(rtlpriv, COMP_INIT, DBG_LOUD,\r\n"Chip Version ID:VERSION_NORMAL_TSMC_CHIP_1T1R_8812\n");\r\nbreak;\r\ncase VERSION_NORMAL_TSMC_CHIP_2T2R_8812:\r\nRT_TRACE(rtlpriv, COMP_INIT, DBG_LOUD,\r\n"Chip Version ID: VERSION_NORMAL_TSMC_CHIP_2T2R_8812\n");\r\nbreak;\r\ncase VERSION_NORMAL_TSMC_CHIP_1T1R_8812_C_CUT:\r\nRT_TRACE(rtlpriv, COMP_INIT, DBG_LOUD,\r\n"Chip Version ID: VERSION_NORMAL_TSMC_CHIP_1T1R_8812 C CUT\n");\r\nbreak;\r\ncase VERSION_NORMAL_TSMC_CHIP_2T2R_8812_C_CUT:\r\nRT_TRACE(rtlpriv, COMP_INIT, DBG_LOUD,\r\n"Chip Version ID: VERSION_NORMAL_TSMC_CHIP_2T2R_8812 C CUT\n");\r\nbreak;\r\ncase VERSION_TEST_CHIP_8821:\r\nRT_TRACE(rtlpriv, COMP_INIT, DBG_LOUD,\r\n"Chip Version ID: VERSION_TEST_CHIP_8821\n");\r\nbreak;\r\ncase VERSION_NORMAL_TSMC_CHIP_8821:\r\nRT_TRACE(rtlpriv, COMP_INIT, DBG_LOUD,\r\n"Chip Version ID: VERSION_NORMAL_TSMC_CHIP_8821 A CUT\n");\r\nbreak;\r\ncase VERSION_NORMAL_TSMC_CHIP_8821_B_CUT:\r\nRT_TRACE(rtlpriv, COMP_INIT, DBG_LOUD,\r\n"Chip Version ID: VERSION_NORMAL_TSMC_CHIP_8821 B CUT\n");\r\nbreak;\r\ndefault:\r\nRT_TRACE(rtlpriv, COMP_INIT, DBG_LOUD,\r\n"Chip Version ID: Unknow (0x%X)\n", version);\r\nbreak;\r\n}\r\nreturn version;\r\n}\r\nstatic int _rtl8821ae_set_media_status(struct ieee80211_hw *hw,\r\nenum nl80211_iftype type)\r\n{\r\nstruct rtl_priv *rtlpriv = rtl_priv(hw);\r\nu8 bt_msr = rtl_read_byte(rtlpriv, MSR);\r\nenum led_ctl_mode ledaction = LED_CTL_NO_LINK;\r\nbt_msr &= 0xfc;\r\nrtl_write_dword(rtlpriv, REG_BCN_CTRL, 0);\r\nRT_TRACE(rtlpriv, COMP_BEACON, DBG_LOUD,\r\n"clear 0x550 when set HW_VAR_MEDIA_STATUS\n");\r\nif (type == NL80211_IFTYPE_UNSPECIFIED ||\r\ntype == NL80211_IFTYPE_STATION) {\r\n_rtl8821ae_stop_tx_beacon(hw);\r\n_rtl8821ae_enable_bcn_sub_func(hw);\r\n} else if (type == NL80211_IFTYPE_ADHOC ||\r\ntype == NL80211_IFTYPE_AP) {\r\n_rtl8821ae_resume_tx_beacon(hw);\r\n_rtl8821ae_disable_bcn_sub_func(hw);\r\n} else {\r\nRT_TRACE(rtlpriv, COMP_ERR, DBG_WARNING,\r\n"Set HW_VAR_MEDIA_STATUS: No such media status(%x).\n",\r\ntype);\r\n}\r\nswitch (type) {\r\ncase NL80211_IFTYPE_UNSPECIFIED:\r\nbt_msr |= MSR_NOLINK;\r\nledaction = LED_CTL_LINK;\r\nRT_TRACE(rtlpriv, COMP_INIT, DBG_TRACE,\r\n"Set Network type to NO LINK!\n");\r\nbreak;\r\ncase NL80211_IFTYPE_ADHOC:\r\nbt_msr |= MSR_ADHOC;\r\nRT_TRACE(rtlpriv, COMP_INIT, DBG_TRACE,\r\n"Set Network type to Ad Hoc!\n");\r\nbreak;\r\ncase NL80211_IFTYPE_STATION:\r\nbt_msr |= MSR_INFRA;\r\nledaction = LED_CTL_LINK;\r\nRT_TRACE(rtlpriv, COMP_INIT, DBG_TRACE,\r\n"Set Network type to STA!\n");\r\nbreak;\r\ncase NL80211_IFTYPE_AP:\r\nbt_msr |= MSR_AP;\r\nRT_TRACE(rtlpriv, COMP_INIT, DBG_TRACE,\r\n"Set Network type to AP!\n");\r\nbreak;\r\ndefault:\r\nRT_TRACE(rtlpriv, COMP_ERR, DBG_EMERG,\r\n"Network type %d not support!\n", type);\r\nreturn 1;\r\n}\r\nrtl_write_byte(rtlpriv, MSR, bt_msr);\r\nrtlpriv->cfg->ops->led_control(hw, ledaction);\r\nif ((bt_msr & MSR_MASK) == MSR_AP)\r\nrtl_write_byte(rtlpriv, REG_BCNTCFG + 1, 0x00);\r\nelse\r\nrtl_write_byte(rtlpriv, REG_BCNTCFG + 1, 0x66);\r\nreturn 0;\r\n}\r\nvoid rtl8821ae_set_check_bssid(struct ieee80211_hw *hw, bool check_bssid)\r\n{\r\nstruct rtl_priv *rtlpriv = rtl_priv(hw);\r\nstruct rtl_pci *rtlpci = rtl_pcidev(rtl_pcipriv(hw));\r\nu32 reg_rcr = rtlpci->receive_config;\r\nif (rtlpriv->psc.rfpwr_state != ERFON)\r\nreturn;\r\nif (check_bssid) {\r\nreg_rcr |= (RCR_CBSSID_DATA | RCR_CBSSID_BCN);\r\nrtlpriv->cfg->ops->set_hw_reg(hw, HW_VAR_RCR,\r\n(u8 *)(&reg_rcr));\r\n_rtl8821ae_set_bcn_ctrl_reg(hw, 0, BIT(4));\r\n} else if (!check_bssid) {\r\nreg_rcr &= (~(RCR_CBSSID_DATA | RCR_CBSSID_BCN));\r\n_rtl8821ae_set_bcn_ctrl_reg(hw, BIT(4), 0);\r\nrtlpriv->cfg->ops->set_hw_reg(hw,\r\nHW_VAR_RCR, (u8 *)(&reg_rcr));\r\n}\r\n}\r\nint rtl8821ae_set_network_type(struct ieee80211_hw *hw, enum nl80211_iftype type)\r\n{\r\nstruct rtl_priv *rtlpriv = rtl_priv(hw);\r\nRT_TRACE(rtlpriv, COMP_INIT, DBG_LOUD, "rtl8821ae_set_network_type!\n");\r\nif (_rtl8821ae_set_media_status(hw, type))\r\nreturn -EOPNOTSUPP;\r\nif (rtlpriv->mac80211.link_state == MAC80211_LINKED) {\r\nif (type != NL80211_IFTYPE_AP)\r\nrtl8821ae_set_check_bssid(hw, true);\r\n} else {\r\nrtl8821ae_set_check_bssid(hw, false);\r\n}\r\nreturn 0;\r\n}\r\nvoid rtl8821ae_set_qos(struct ieee80211_hw *hw, int aci)\r\n{\r\nstruct rtl_priv *rtlpriv = rtl_priv(hw);\r\nrtl8821ae_dm_init_edca_turbo(hw);\r\nswitch (aci) {\r\ncase AC1_BK:\r\nrtl_write_dword(rtlpriv, REG_EDCA_BK_PARAM, 0xa44f);\r\nbreak;\r\ncase AC0_BE:\r\nbreak;\r\ncase AC2_VI:\r\nrtl_write_dword(rtlpriv, REG_EDCA_VI_PARAM, 0x5e4322);\r\nbreak;\r\ncase AC3_VO:\r\nrtl_write_dword(rtlpriv, REG_EDCA_VO_PARAM, 0x2f3222);\r\nbreak;\r\ndefault:\r\nRT_ASSERT(false, "invalid aci: %d !\n", aci);\r\nbreak;\r\n}\r\n}\r\nstatic void rtl8821ae_clear_interrupt(struct ieee80211_hw *hw)\r\n{\r\nstruct rtl_priv *rtlpriv = rtl_priv(hw);\r\nu32 tmp = rtl_read_dword(rtlpriv, REG_HISR);\r\nrtl_write_dword(rtlpriv, REG_HISR, tmp);\r\ntmp = rtl_read_dword(rtlpriv, REG_HISRE);\r\nrtl_write_dword(rtlpriv, REG_HISRE, tmp);\r\ntmp = rtl_read_dword(rtlpriv, REG_HSISR);\r\nrtl_write_dword(rtlpriv, REG_HSISR, tmp);\r\n}\r\nvoid rtl8821ae_enable_interrupt(struct ieee80211_hw *hw)\r\n{\r\nstruct rtl_priv *rtlpriv = rtl_priv(hw);\r\nstruct rtl_pci *rtlpci = rtl_pcidev(rtl_pcipriv(hw));\r\nif (rtlpci->int_clear)\r\nrtl8821ae_clear_interrupt(hw);\r\nrtl_write_dword(rtlpriv, REG_HIMR, rtlpci->irq_mask[0] & 0xFFFFFFFF);\r\nrtl_write_dword(rtlpriv, REG_HIMRE, rtlpci->irq_mask[1] & 0xFFFFFFFF);\r\nrtlpci->irq_enabled = true;\r\nrtl_write_dword(rtlpriv, REG_HSIMR, rtlpci->sys_irq_mask & 0xFFFFFFFF);\r\n}\r\nvoid rtl8821ae_disable_interrupt(struct ieee80211_hw *hw)\r\n{\r\nstruct rtl_priv *rtlpriv = rtl_priv(hw);\r\nstruct rtl_pci *rtlpci = rtl_pcidev(rtl_pcipriv(hw));\r\nrtl_write_dword(rtlpriv, REG_HIMR, IMR_DISABLED);\r\nrtl_write_dword(rtlpriv, REG_HIMRE, IMR_DISABLED);\r\nrtlpci->irq_enabled = false;\r\n}\r\nstatic void _rtl8821ae_clear_pci_pme_status(struct ieee80211_hw *hw)\r\n{\r\nstruct rtl_priv *rtlpriv = rtl_priv(hw);\r\nstruct rtl_pci *rtlpci = rtl_pcidev(rtl_pcipriv(hw));\r\nu16 cap_hdr;\r\nu8 cap_pointer;\r\nu8 cap_id = 0xff;\r\nu8 pmcs_reg;\r\nu8 cnt = 0;\r\npci_read_config_byte(rtlpci->pdev, 0x34, &cap_pointer);\r\nRT_TRACE(rtlpriv, COMP_INIT, DBG_LOUD,\r\n"PCI configration 0x34 = 0x%2x\n", cap_pointer);\r\ndo {\r\npci_read_config_word(rtlpci->pdev, cap_pointer, &cap_hdr);\r\ncap_id = cap_hdr & 0xFF;\r\nRT_TRACE(rtlpriv, COMP_INIT, DBG_LOUD,\r\n"in pci configration, cap_pointer%x = %x\n",\r\ncap_pointer, cap_id);\r\nif (cap_id == 0x01) {\r\nbreak;\r\n} else {\r\ncap_pointer = (cap_hdr >> 8) & 0xFF;\r\nif (cap_pointer == 0x00 || cap_pointer == 0xff) {\r\ncap_id = 0xff;\r\nbreak;\r\n}\r\n}\r\n} while (cnt++ < 200);\r\nif (cap_id == 0x01) {\r\npci_read_config_byte(rtlpci->pdev, cap_pointer + 5, &pmcs_reg);\r\nif (pmcs_reg & BIT(7)) {\r\npmcs_reg = pmcs_reg | BIT(7);\r\npci_write_config_byte(rtlpci->pdev, cap_pointer + 5,\r\npmcs_reg);\r\npci_read_config_byte(rtlpci->pdev, cap_pointer + 5,\r\n&pmcs_reg);\r\nRT_TRACE(rtlpriv, COMP_INIT, DBG_DMESG,\r\n"Clear PME status 0x%2x to 0x%2x\n",\r\ncap_pointer + 5, pmcs_reg);\r\n} else {\r\nRT_TRACE(rtlpriv, COMP_INIT, DBG_DMESG,\r\n"PME status(0x%2x) = 0x%2x\n",\r\ncap_pointer + 5, pmcs_reg);\r\n}\r\n} else {\r\nRT_TRACE(rtlpriv, COMP_INIT, DBG_WARNING,\r\n"Cannot find PME Capability\n");\r\n}\r\n}\r\nvoid rtl8821ae_card_disable(struct ieee80211_hw *hw)\r\n{\r\nstruct rtl_priv *rtlpriv = rtl_priv(hw);\r\nstruct rtl_hal *rtlhal = rtl_hal(rtlpriv);\r\nstruct rtl_ps_ctl *ppsc = rtl_psc(rtlpriv);\r\nstruct rtl_mac *mac = rtl_mac(rtlpriv);\r\nenum nl80211_iftype opmode;\r\nbool support_remote_wakeup;\r\nu8 tmp;\r\nu32 count = 0;\r\nrtlpriv->cfg->ops->get_hw_reg(hw, HAL_DEF_WOWLAN,\r\n(u8 *)(&support_remote_wakeup));\r\nRT_SET_PS_LEVEL(ppsc, RT_RF_OFF_LEVL_HALT_NIC);\r\nif (!(support_remote_wakeup && mac->opmode == NL80211_IFTYPE_STATION)\r\n|| !rtlhal->enter_pnp_sleep) {\r\nRT_TRACE(rtlpriv, COMP_INIT, DBG_DMESG, "Normal Power off\n");\r\nmac->link_state = MAC80211_NOLINK;\r\nopmode = NL80211_IFTYPE_UNSPECIFIED;\r\n_rtl8821ae_set_media_status(hw, opmode);\r\n_rtl8821ae_poweroff_adapter(hw);\r\n} else {\r\nRT_TRACE(rtlpriv, COMP_INIT, DBG_DMESG, "Wowlan Supported.\n");\r\nrtl_write_byte(rtlpriv, REG_MCUTST_WOWLAN, 0x0);\r\n#if (USE_SPECIFIC_FW_TO_SUPPORT_WOWLAN == 1)\r\nrtl8821ae_set_fw_related_for_wowlan(hw, true);\r\n#endif\r\nif (_rtl8821ae_dynamic_rqpn(hw, 0xE0, 0x3, 0x80c20d0d))\r\nrtlhal->re_init_llt_table = true;\r\nrtl8821ae_set_fw_global_info_cmd(hw);\r\n_rtl8821ae_download_rsvd_page(hw, true);\r\nprintk("mac->link_state = %d\n", mac->link_state);\r\nif (mac->link_state >= MAC80211_LINKED &&\r\nmac->opmode == NL80211_IFTYPE_STATION) {\r\nrtlpriv->cfg->ops->set_hw_reg(hw, HW_VAR_AID, NULL);\r\nrtl8821ae_set_fw_media_status_rpt_cmd(hw,\r\nRT_MEDIA_CONNECT);\r\nrtl8821ae_set_fw_wowlan_mode(hw, true);\r\nrtl8821ae_set_fw_keep_alive_cmd(hw, true);\r\nrtl8821ae_set_fw_disconnect_decision_ctrl_cmd(hw, true);\r\n}\r\nrtl_write_byte(rtlpriv, REG_RXDMA_CONTROL, BIT(2));\r\ntmp = rtl_read_byte(rtlpriv, REG_RXDMA_CONTROL);\r\ncount = 0;\r\nwhile (!(tmp & BIT(1)) && (count++ < 100)) {\r\nudelay(10);\r\ntmp = rtl_read_byte(rtlpriv, REG_RXDMA_CONTROL);\r\n}\r\nRT_TRACE(rtlpriv, COMP_INIT, DBG_LOUD,\r\n"Wait Rx DMA Finished before host sleep. count=%d\n",\r\ncount);\r\nrtlpriv->intf_ops->reset_trx_ring(hw);\r\nrtl_write_byte(rtlpriv, REG_APS_FSMCO + 1, 0x0);\r\n_rtl8821ae_clear_pci_pme_status(hw);\r\ntmp = rtl_read_byte(rtlpriv, REG_SYS_CLKR);\r\nrtl_write_byte(rtlpriv, REG_SYS_CLKR, tmp | BIT(3));\r\nrtl_write_byte(rtlpriv, REG_RSV_CTRL, 0x20);\r\nrtl_write_byte(rtlpriv, REG_RSV_CTRL, 0x60);\r\n}\r\nif (rtlpriv->rtlhal.driver_is_goingto_unload ||\r\nppsc->rfoff_reason > RF_CHANGE_BY_PS)\r\nrtlpriv->cfg->ops->led_control(hw, LED_CTL_POWER_OFF);\r\nif (support_remote_wakeup && rtlhal->enter_pnp_sleep) {\r\nrtl8821ae_set_fw_remote_wake_ctrl_cmd(hw, 1);\r\nrtl_write_byte(rtlpriv, REG_PCIE_CTRL_REG + 1, 0xff);\r\nRT_TRACE(rtlpriv, COMP_POWER, DBG_LOUD, "Stop PCIE Tx DMA.\n");\r\ncount = 0;\r\ndo {\r\ntmp = rtl_read_byte(rtlpriv, REG_PCIE_CTRL_REG);\r\nudelay(10);\r\ncount++;\r\n} while ((tmp != 0) && (count < 100));\r\nRT_TRACE(rtlpriv, COMP_INIT, DBG_LOUD,\r\n"Wait Tx DMA Finished before host sleep. count=%d\n",\r\ncount);\r\nif (rtlhal->hw_rof_enable) {\r\nprintk("hw_rof_enable\n");\r\ntmp = rtl_read_byte(rtlpriv, REG_HSISR + 3);\r\nrtl_write_byte(rtlpriv, REG_HSISR + 3, tmp | BIT(1));\r\n}\r\n}\r\nrtlpriv->phy.iqk_initialized = false;\r\n}\r\nvoid rtl8821ae_interrupt_recognized(struct ieee80211_hw *hw,\r\nu32 *p_inta, u32 *p_intb)\r\n{\r\nstruct rtl_priv *rtlpriv = rtl_priv(hw);\r\nstruct rtl_pci *rtlpci = rtl_pcidev(rtl_pcipriv(hw));\r\n*p_inta = rtl_read_dword(rtlpriv, ISR) & rtlpci->irq_mask[0];\r\nrtl_write_dword(rtlpriv, ISR, *p_inta);\r\n*p_intb = rtl_read_dword(rtlpriv, REG_HISRE) & rtlpci->irq_mask[1];\r\nrtl_write_dword(rtlpriv, REG_HISRE, *p_intb);\r\n}\r\nvoid rtl8821ae_set_beacon_related_registers(struct ieee80211_hw *hw)\r\n{\r\nstruct rtl_priv *rtlpriv = rtl_priv(hw);\r\nstruct rtl_mac *mac = rtl_mac(rtl_priv(hw));\r\nstruct rtl_pci *rtlpci = rtl_pcidev(rtl_pcipriv(hw));\r\nu16 bcn_interval, atim_window;\r\nbcn_interval = mac->beacon_interval;\r\natim_window = 2;\r\nrtl8821ae_disable_interrupt(hw);\r\nrtl_write_word(rtlpriv, REG_ATIMWND, atim_window);\r\nrtl_write_word(rtlpriv, REG_BCN_INTERVAL, bcn_interval);\r\nrtl_write_word(rtlpriv, REG_BCNTCFG, 0x660f);\r\nrtl_write_byte(rtlpriv, REG_RXTSF_OFFSET_CCK, 0x18);\r\nrtl_write_byte(rtlpriv, REG_RXTSF_OFFSET_OFDM, 0x18);\r\nrtl_write_byte(rtlpriv, 0x606, 0x30);\r\nrtlpci->reg_bcn_ctrl_val |= BIT(3);\r\nrtl_write_byte(rtlpriv, REG_BCN_CTRL, (u8)rtlpci->reg_bcn_ctrl_val);\r\nrtl8821ae_enable_interrupt(hw);\r\n}\r\nvoid rtl8821ae_set_beacon_interval(struct ieee80211_hw *hw)\r\n{\r\nstruct rtl_priv *rtlpriv = rtl_priv(hw);\r\nstruct rtl_mac *mac = rtl_mac(rtl_priv(hw));\r\nu16 bcn_interval = mac->beacon_interval;\r\nRT_TRACE(rtlpriv, COMP_BEACON, DBG_DMESG,\r\n"beacon_interval:%d\n", bcn_interval);\r\nrtl8821ae_disable_interrupt(hw);\r\nrtl_write_word(rtlpriv, REG_BCN_INTERVAL, bcn_interval);\r\nrtl8821ae_enable_interrupt(hw);\r\n}\r\nvoid rtl8821ae_update_interrupt_mask(struct ieee80211_hw *hw,\r\nu32 add_msr, u32 rm_msr)\r\n{\r\nstruct rtl_priv *rtlpriv = rtl_priv(hw);\r\nstruct rtl_pci *rtlpci = rtl_pcidev(rtl_pcipriv(hw));\r\nRT_TRACE(rtlpriv, COMP_INTR, DBG_LOUD,\r\n"add_msr:%x, rm_msr:%x\n", add_msr, rm_msr);\r\nif (add_msr)\r\nrtlpci->irq_mask[0] |= add_msr;\r\nif (rm_msr)\r\nrtlpci->irq_mask[0] &= (~rm_msr);\r\nrtl8821ae_disable_interrupt(hw);\r\nrtl8821ae_enable_interrupt(hw);\r\n}\r\nstatic u8 _rtl8821ae_get_chnl_group(u8 chnl)\r\n{\r\nu8 group = 0;\r\nif (chnl <= 14) {\r\nif (1 <= chnl && chnl <= 2)\r\ngroup = 0;\r\nelse if (3 <= chnl && chnl <= 5)\r\ngroup = 1;\r\nelse if (6 <= chnl && chnl <= 8)\r\ngroup = 2;\r\nelse if (9 <= chnl && chnl <= 11)\r\ngroup = 3;\r\nelse\r\ngroup = 4;\r\n} else {\r\nif (36 <= chnl && chnl <= 42)\r\ngroup = 0;\r\nelse if (44 <= chnl && chnl <= 48)\r\ngroup = 1;\r\nelse if (50 <= chnl && chnl <= 58)\r\ngroup = 2;\r\nelse if (60 <= chnl && chnl <= 64)\r\ngroup = 3;\r\nelse if (100 <= chnl && chnl <= 106)\r\ngroup = 4;\r\nelse if (108 <= chnl && chnl <= 114)\r\ngroup = 5;\r\nelse if (116 <= chnl && chnl <= 122)\r\ngroup = 6;\r\nelse if (124 <= chnl && chnl <= 130)\r\ngroup = 7;\r\nelse if (132 <= chnl && chnl <= 138)\r\ngroup = 8;\r\nelse if (140 <= chnl && chnl <= 144)\r\ngroup = 9;\r\nelse if (149 <= chnl && chnl <= 155)\r\ngroup = 10;\r\nelse if (157 <= chnl && chnl <= 161)\r\ngroup = 11;\r\nelse if (165 <= chnl && chnl <= 171)\r\ngroup = 12;\r\nelse if (173 <= chnl && chnl <= 177)\r\ngroup = 13;\r\nelse\r\nRT_ASSERT(!COMP_EFUSE,\r\n"5G, Channel %d in Group not found\n", chnl);\r\n}\r\nreturn group;\r\n}\r\nstatic void _rtl8821ae_read_power_value_fromprom(struct ieee80211_hw *hw,\r\nstruct txpower_info_2g *pwrinfo24g,\r\nstruct txpower_info_5g *pwrinfo5g,\r\nbool autoload_fail,\r\nu8 *hwinfo)\r\n{\r\nstruct rtl_priv *rtlpriv = rtl_priv(hw);\r\nu32 rfPath, eeAddr = EEPROM_TX_PWR_INX, group, TxCount = 0;\r\nRT_TRACE(rtlpriv, COMP_INIT, DBG_LOUD,\r\n"hal_ReadPowerValueFromPROM8821ae(): hwinfo[0x%x]=0x%x\n",\r\n(eeAddr+1), hwinfo[eeAddr+1]);\r\nif (0xFF == hwinfo[eeAddr+1])\r\nautoload_fail = true;\r\nif (autoload_fail) {\r\nRT_TRACE(rtlpriv, COMP_INIT, DBG_LOUD,\r\n"auto load fail : Use Default value!\n");\r\nfor (rfPath = 0 ; rfPath < MAX_RF_PATH ; rfPath++) {\r\nfor (group = 0 ; group < MAX_CHNL_GROUP_24G; group++) {\r\npwrinfo24g->index_cck_base[rfPath][group] = 0x2D;\r\npwrinfo24g->index_bw40_base[rfPath][group] = 0x2D;\r\n}\r\nfor (TxCount = 0; TxCount < MAX_TX_COUNT; TxCount++) {\r\nif (TxCount == 0) {\r\npwrinfo24g->bw20_diff[rfPath][0] = 0x02;\r\npwrinfo24g->ofdm_diff[rfPath][0] = 0x04;\r\n} else {\r\npwrinfo24g->bw20_diff[rfPath][TxCount] = 0xFE;\r\npwrinfo24g->bw40_diff[rfPath][TxCount] = 0xFE;\r\npwrinfo24g->cck_diff[rfPath][TxCount] = 0xFE;\r\npwrinfo24g->ofdm_diff[rfPath][TxCount] = 0xFE;\r\n}\r\n}\r\nfor (group = 0 ; group < MAX_CHNL_GROUP_5G; group++)\r\npwrinfo5g->index_bw40_base[rfPath][group] = 0x2A;\r\nfor (TxCount = 0; TxCount < MAX_TX_COUNT; TxCount++) {\r\nif (TxCount == 0) {\r\npwrinfo5g->ofdm_diff[rfPath][0] = 0x04;\r\npwrinfo5g->bw20_diff[rfPath][0] = 0x00;\r\npwrinfo5g->bw80_diff[rfPath][0] = 0xFE;\r\npwrinfo5g->bw160_diff[rfPath][0] = 0xFE;\r\n} else {\r\npwrinfo5g->ofdm_diff[rfPath][0] = 0xFE;\r\npwrinfo5g->bw20_diff[rfPath][0] = 0xFE;\r\npwrinfo5g->bw40_diff[rfPath][0] = 0xFE;\r\npwrinfo5g->bw80_diff[rfPath][0] = 0xFE;\r\npwrinfo5g->bw160_diff[rfPath][0] = 0xFE;\r\n}\r\n}\r\n}\r\nreturn;\r\n}\r\nrtl_priv(hw)->efuse.txpwr_fromeprom = true;\r\nfor (rfPath = 0 ; rfPath < MAX_RF_PATH ; rfPath++) {\r\nfor (group = 0 ; group < MAX_CHNL_GROUP_24G; group++) {\r\npwrinfo24g->index_cck_base[rfPath][group] = hwinfo[eeAddr++];\r\nif (pwrinfo24g->index_cck_base[rfPath][group] == 0xFF)\r\npwrinfo24g->index_cck_base[rfPath][group] = 0x2D;\r\n}\r\nfor (group = 0 ; group < MAX_CHNL_GROUP_24G - 1; group++) {\r\npwrinfo24g->index_bw40_base[rfPath][group] = hwinfo[eeAddr++];\r\nif (pwrinfo24g->index_bw40_base[rfPath][group] == 0xFF)\r\npwrinfo24g->index_bw40_base[rfPath][group] = 0x2D;\r\n}\r\nfor (TxCount = 0; TxCount < MAX_TX_COUNT; TxCount++) {\r\nif (TxCount == 0) {\r\npwrinfo24g->bw40_diff[rfPath][TxCount] = 0;\r\npwrinfo24g->bw20_diff[rfPath][TxCount] = (hwinfo[eeAddr] & 0xf0) >> 4;\r\nif (pwrinfo24g->bw20_diff[rfPath][TxCount] & BIT(3))\r\npwrinfo24g->bw20_diff[rfPath][TxCount] |= 0xF0;\r\npwrinfo24g->ofdm_diff[rfPath][TxCount] = (hwinfo[eeAddr] & 0x0f);\r\nif (pwrinfo24g->ofdm_diff[rfPath][TxCount] & BIT(3))\r\npwrinfo24g->ofdm_diff[rfPath][TxCount] |= 0xF0;\r\npwrinfo24g->cck_diff[rfPath][TxCount] = 0;\r\neeAddr++;\r\n} else {\r\npwrinfo24g->bw40_diff[rfPath][TxCount] = (hwinfo[eeAddr]&0xf0) >> 4;\r\nif (pwrinfo24g->bw40_diff[rfPath][TxCount] & BIT(3))\r\npwrinfo24g->bw40_diff[rfPath][TxCount] |= 0xF0;\r\npwrinfo24g->bw20_diff[rfPath][TxCount] = (hwinfo[eeAddr] & 0x0f);\r\nif (pwrinfo24g->bw20_diff[rfPath][TxCount] & BIT(3))\r\npwrinfo24g->bw20_diff[rfPath][TxCount] |= 0xF0;\r\neeAddr++;\r\npwrinfo24g->ofdm_diff[rfPath][TxCount] = (hwinfo[eeAddr] & 0xf0) >> 4;\r\nif (pwrinfo24g->ofdm_diff[rfPath][TxCount] & BIT(3))\r\npwrinfo24g->ofdm_diff[rfPath][TxCount] |= 0xF0;\r\npwrinfo24g->cck_diff[rfPath][TxCount] = (hwinfo[eeAddr] & 0x0f);\r\nif (pwrinfo24g->cck_diff[rfPath][TxCount] & BIT(3))\r\npwrinfo24g->cck_diff[rfPath][TxCount] |= 0xF0;\r\neeAddr++;\r\n}\r\n}\r\nfor (group = 0 ; group < MAX_CHNL_GROUP_5G; group++) {\r\npwrinfo5g->index_bw40_base[rfPath][group] = hwinfo[eeAddr++];\r\nif (pwrinfo5g->index_bw40_base[rfPath][group] == 0xFF)\r\npwrinfo5g->index_bw40_base[rfPath][group] = 0xFE;\r\n}\r\nfor (TxCount = 0; TxCount < MAX_TX_COUNT; TxCount++) {\r\nif (TxCount == 0) {\r\npwrinfo5g->bw40_diff[rfPath][TxCount] = 0;\r\npwrinfo5g->bw20_diff[rfPath][0] = (hwinfo[eeAddr] & 0xf0) >> 4;\r\nif (pwrinfo5g->bw20_diff[rfPath][TxCount] & BIT(3))\r\npwrinfo5g->bw20_diff[rfPath][TxCount] |= 0xF0;\r\npwrinfo5g->ofdm_diff[rfPath][0] = (hwinfo[eeAddr] & 0x0f);\r\nif (pwrinfo5g->ofdm_diff[rfPath][TxCount] & BIT(3))\r\npwrinfo5g->ofdm_diff[rfPath][TxCount] |= 0xF0;\r\neeAddr++;\r\n} else {\r\npwrinfo5g->bw40_diff[rfPath][TxCount] = (hwinfo[eeAddr] & 0xf0) >> 4;\r\nif (pwrinfo5g->bw40_diff[rfPath][TxCount] & BIT(3))\r\npwrinfo5g->bw40_diff[rfPath][TxCount] |= 0xF0;\r\npwrinfo5g->bw20_diff[rfPath][TxCount] = (hwinfo[eeAddr] & 0x0f);\r\nif (pwrinfo5g->bw20_diff[rfPath][TxCount] & BIT(3))\r\npwrinfo5g->bw20_diff[rfPath][TxCount] |= 0xF0;\r\neeAddr++;\r\n}\r\n}\r\npwrinfo5g->ofdm_diff[rfPath][1] = (hwinfo[eeAddr] & 0xf0) >> 4;\r\npwrinfo5g->ofdm_diff[rfPath][2] = (hwinfo[eeAddr] & 0x0f);\r\neeAddr++;\r\npwrinfo5g->ofdm_diff[rfPath][3] = (hwinfo[eeAddr] & 0x0f);\r\neeAddr++;\r\nfor (TxCount = 1; TxCount < MAX_TX_COUNT; TxCount++) {\r\nif (pwrinfo5g->ofdm_diff[rfPath][TxCount] & BIT(3))\r\npwrinfo5g->ofdm_diff[rfPath][TxCount] |= 0xF0;\r\n}\r\nfor (TxCount = 0; TxCount < MAX_TX_COUNT; TxCount++) {\r\npwrinfo5g->bw80_diff[rfPath][TxCount] = (hwinfo[eeAddr] & 0xf0) >> 4;\r\nif (pwrinfo5g->bw80_diff[rfPath][TxCount] & BIT(3))\r\npwrinfo5g->bw80_diff[rfPath][TxCount] |= 0xF0;\r\npwrinfo5g->bw160_diff[rfPath][TxCount] = (hwinfo[eeAddr] & 0x0f);\r\nif (pwrinfo5g->bw160_diff[rfPath][TxCount] & BIT(3))\r\npwrinfo5g->bw160_diff[rfPath][TxCount] |= 0xF0;\r\neeAddr++;\r\n}\r\n}\r\n}\r\nstatic void _rtl8821ae_read_txpower_info_from_hwpg(struct ieee80211_hw *hw,\r\nbool autoload_fail,\r\nu8 *hwinfo)\r\n{\r\nstruct rtl_priv *rtlpriv = rtl_priv(hw);\r\nstruct rtl_efuse *rtlefuse = rtl_efuse(rtl_priv(hw));\r\nstruct txpower_info_2g pwrinfo24g;\r\nstruct txpower_info_5g pwrinfo5g;\r\nu8 channel5g[CHANNEL_MAX_NUMBER_5G] = {\r\n36, 38, 40, 42, 44, 46, 48, 50, 52, 54,\r\n56, 58, 60, 62, 64, 100, 102, 104, 106,\r\n108, 110, 112, 114, 116, 118, 120, 122,\r\n124, 126, 128, 130, 132, 134, 136, 138,\r\n140, 142, 144, 149, 151, 153, 155, 157,\r\n159, 161, 163, 165, 167, 168, 169, 171,\r\n173, 175, 177};\r\nu8 channel5g_80m[CHANNEL_MAX_NUMBER_5G_80M] = {\r\n42, 58, 106, 122, 138, 155, 171};\r\nu8 rf_path, index;\r\nu8 i;\r\n_rtl8821ae_read_power_value_fromprom(hw, &pwrinfo24g,\r\n&pwrinfo5g, autoload_fail, hwinfo);\r\nfor (rf_path = 0; rf_path < 2; rf_path++) {\r\nfor (i = 0; i < CHANNEL_MAX_NUMBER_2G; i++) {\r\nindex = _rtl8821ae_get_chnl_group(i + 1);\r\nif (i == CHANNEL_MAX_NUMBER_2G - 1) {\r\nrtlefuse->txpwrlevel_cck[rf_path][i] =\r\npwrinfo24g.index_cck_base[rf_path][5];\r\nrtlefuse->txpwrlevel_ht40_1s[rf_path][i] =\r\npwrinfo24g.index_bw40_base[rf_path][index];\r\n} else {\r\nrtlefuse->txpwrlevel_cck[rf_path][i] =\r\npwrinfo24g.index_cck_base[rf_path][index];\r\nrtlefuse->txpwrlevel_ht40_1s[rf_path][i] =\r\npwrinfo24g.index_bw40_base[rf_path][index];\r\n}\r\n}\r\nfor (i = 0; i < CHANNEL_MAX_NUMBER_5G; i++) {\r\nindex = _rtl8821ae_get_chnl_group(channel5g[i]);\r\nrtlefuse->txpwr_5g_bw40base[rf_path][i] =\r\npwrinfo5g.index_bw40_base[rf_path][index];\r\n}\r\nfor (i = 0; i < CHANNEL_MAX_NUMBER_5G_80M; i++) {\r\nu8 upper, lower;\r\nindex = _rtl8821ae_get_chnl_group(channel5g_80m[i]);\r\nupper = pwrinfo5g.index_bw40_base[rf_path][index];\r\nlower = pwrinfo5g.index_bw40_base[rf_path][index + 1];\r\nrtlefuse->txpwr_5g_bw80base[rf_path][i] = (upper + lower) / 2;\r\n}\r\nfor (i = 0; i < MAX_TX_COUNT; i++) {\r\nrtlefuse->txpwr_cckdiff[rf_path][i] =\r\npwrinfo24g.cck_diff[rf_path][i];\r\nrtlefuse->txpwr_legacyhtdiff[rf_path][i] =\r\npwrinfo24g.ofdm_diff[rf_path][i];\r\nrtlefuse->txpwr_ht20diff[rf_path][i] =\r\npwrinfo24g.bw20_diff[rf_path][i];\r\nrtlefuse->txpwr_ht40diff[rf_path][i] =\r\npwrinfo24g.bw40_diff[rf_path][i];\r\nrtlefuse->txpwr_5g_ofdmdiff[rf_path][i] =\r\npwrinfo5g.ofdm_diff[rf_path][i];\r\nrtlefuse->txpwr_5g_bw20diff[rf_path][i] =\r\npwrinfo5g.bw20_diff[rf_path][i];\r\nrtlefuse->txpwr_5g_bw40diff[rf_path][i] =\r\npwrinfo5g.bw40_diff[rf_path][i];\r\nrtlefuse->txpwr_5g_bw80diff[rf_path][i] =\r\npwrinfo5g.bw80_diff[rf_path][i];\r\n}\r\n}\r\nif (!autoload_fail) {\r\nrtlefuse->eeprom_regulatory = hwinfo[EEPROM_RF_BOARD_OPTION] & 0x07;\r\nif (hwinfo[EEPROM_RF_BOARD_OPTION] == 0xFF)\r\nrtlefuse->eeprom_regulatory = 0;\r\n} else {\r\nrtlefuse->eeprom_regulatory = 0;\r\n}\r\nRTPRINT(rtlpriv, FINIT, INIT_TXPOWER,\r\n"eeprom_regulatory = 0x%x\n", rtlefuse->eeprom_regulatory);\r\n}\r\nstatic void _rtl8812ae_read_pa_type(struct ieee80211_hw *hw, u8 *hwinfo,\r\nbool autoload_fail)\r\n{\r\nstruct rtl_priv *rtlpriv = rtl_priv(hw);\r\nstruct rtl_hal *rtlhal = rtl_hal(rtlpriv);\r\nif (!autoload_fail) {\r\nrtlhal->pa_type_2g = hwinfo[0xBC];\r\nrtlhal->lna_type_2g = hwinfo[0xBD];\r\nif (rtlhal->pa_type_2g == 0xFF && rtlhal->lna_type_2g == 0xFF) {\r\nrtlhal->pa_type_2g = 0;\r\nrtlhal->lna_type_2g = 0;\r\n}\r\nrtlhal->external_pa_2g = ((rtlhal->pa_type_2g & BIT(5)) &&\r\n(rtlhal->pa_type_2g & BIT(4))) ?\r\n1 : 0;\r\nrtlhal->external_lna_2g = ((rtlhal->lna_type_2g & BIT(7)) &&\r\n(rtlhal->lna_type_2g & BIT(3))) ?\r\n1 : 0;\r\nrtlhal->pa_type_5g = hwinfo[0xBC];\r\nrtlhal->lna_type_5g = hwinfo[0xBF];\r\nif (rtlhal->pa_type_5g == 0xFF && rtlhal->lna_type_5g == 0xFF) {\r\nrtlhal->pa_type_5g = 0;\r\nrtlhal->lna_type_5g = 0;\r\n}\r\nrtlhal->external_pa_5g = ((rtlhal->pa_type_5g & BIT(1)) &&\r\n(rtlhal->pa_type_5g & BIT(0))) ?\r\n1 : 0;\r\nrtlhal->external_lna_5g = ((rtlhal->lna_type_5g & BIT(7)) &&\r\n(rtlhal->lna_type_5g & BIT(3))) ?\r\n1 : 0;\r\n} else {\r\nrtlhal->external_pa_2g = 0;\r\nrtlhal->external_lna_2g = 0;\r\nrtlhal->external_pa_5g = 0;\r\nrtlhal->external_lna_5g = 0;\r\n}\r\n}\r\nstatic void _rtl8821ae_read_pa_type(struct ieee80211_hw *hw, u8 *hwinfo,\r\nbool autoload_fail)\r\n{\r\nstruct rtl_priv *rtlpriv = rtl_priv(hw);\r\nstruct rtl_hal *rtlhal = rtl_hal(rtlpriv);\r\nif (!autoload_fail) {\r\nrtlhal->pa_type_2g = hwinfo[0xBC];\r\nrtlhal->lna_type_2g = hwinfo[0xBD];\r\nif (rtlhal->pa_type_2g == 0xFF && rtlhal->lna_type_2g == 0xFF) {\r\nrtlhal->pa_type_2g = 0;\r\nrtlhal->lna_type_2g = 0;\r\n}\r\nrtlhal->external_pa_2g = (rtlhal->pa_type_2g & BIT(5)) ? 1 : 0;\r\nrtlhal->external_lna_2g = (rtlhal->lna_type_2g & BIT(7)) ? 1 : 0;\r\nrtlhal->pa_type_5g = hwinfo[0xBC];\r\nrtlhal->lna_type_5g = hwinfo[0xBF];\r\nif (rtlhal->pa_type_5g == 0xFF && rtlhal->lna_type_5g == 0xFF) {\r\nrtlhal->pa_type_5g = 0;\r\nrtlhal->lna_type_5g = 0;\r\n}\r\nrtlhal->external_pa_5g = (rtlhal->pa_type_5g & BIT(1)) ? 1 : 0;\r\nrtlhal->external_lna_5g = (rtlhal->lna_type_5g & BIT(7)) ? 1 : 0;\r\n} else {\r\nrtlhal->external_pa_2g = 0;\r\nrtlhal->external_lna_2g = 0;\r\nrtlhal->external_pa_5g = 0;\r\nrtlhal->external_lna_5g = 0;\r\n}\r\n}\r\nstatic void _rtl8821ae_read_rfe_type(struct ieee80211_hw *hw, u8 *hwinfo,\r\nbool autoload_fail)\r\n{\r\nstruct rtl_priv *rtlpriv = rtl_priv(hw);\r\nstruct rtl_hal *rtlhal = rtl_hal(rtlpriv);\r\nif (!autoload_fail) {\r\nif (hwinfo[EEPROM_RFE_OPTION] & BIT(7)) {\r\nif (rtlhal->external_lna_5g) {\r\nif (rtlhal->external_pa_5g) {\r\nif (rtlhal->external_lna_2g &&\r\nrtlhal->external_pa_2g)\r\nrtlhal->rfe_type = 3;\r\nelse\r\nrtlhal->rfe_type = 0;\r\n} else {\r\nrtlhal->rfe_type = 2;\r\n}\r\n} else {\r\nrtlhal->rfe_type = 4;\r\n}\r\n} else {\r\nrtlhal->rfe_type = hwinfo[EEPROM_RFE_OPTION] & 0x3F;\r\nif (rtlhal->rfe_type == 4 &&\r\n(rtlhal->external_pa_5g ||\r\nrtlhal->external_pa_2g ||\r\nrtlhal->external_lna_5g ||\r\nrtlhal->external_lna_2g)) {\r\nif (rtlhal->hw_type == HARDWARE_TYPE_RTL8812AE)\r\nrtlhal->rfe_type = 2;\r\n}\r\n}\r\n} else {\r\nrtlhal->rfe_type = 0x04;\r\n}\r\nRT_TRACE(rtlpriv, COMP_INIT, DBG_LOUD,\r\n"RFE Type: 0x%2x\n", rtlhal->rfe_type);\r\n}\r\nstatic void _rtl8812ae_read_bt_coexist_info_from_hwpg(struct ieee80211_hw *hw,\r\nbool auto_load_fail, u8 *hwinfo)\r\n{\r\nstruct rtl_priv *rtlpriv = rtl_priv(hw);\r\nu8 value;\r\nif (!auto_load_fail) {\r\nvalue = *(u8 *)&hwinfo[EEPROM_RF_BOARD_OPTION];\r\nif (((value & 0xe0) >> 5) == 0x1)\r\nrtlpriv->btcoexist.btc_info.btcoexist = 1;\r\nelse\r\nrtlpriv->btcoexist.btc_info.btcoexist = 0;\r\nrtlpriv->btcoexist.btc_info.bt_type = BT_RTL8812A;\r\nvalue = hwinfo[EEPROM_RF_BT_SETTING];\r\nrtlpriv->btcoexist.btc_info.ant_num = (value & 0x1);\r\n} else {\r\nrtlpriv->btcoexist.btc_info.btcoexist = 0;\r\nrtlpriv->btcoexist.btc_info.bt_type = BT_RTL8812A;\r\nrtlpriv->btcoexist.btc_info.ant_num = ANT_X2;\r\n}\r\n}\r\nstatic void _rtl8821ae_read_bt_coexist_info_from_hwpg(struct ieee80211_hw *hw,\r\nbool auto_load_fail, u8 *hwinfo)\r\n{\r\nstruct rtl_priv *rtlpriv = rtl_priv(hw);\r\nu8 value;\r\nu32 tmpu_32;\r\nif (!auto_load_fail) {\r\ntmpu_32 = rtl_read_dword(rtlpriv, REG_MULTI_FUNC_CTRL);\r\nif (tmpu_32 & BIT(18))\r\nrtlpriv->btcoexist.btc_info.btcoexist = 1;\r\nelse\r\nrtlpriv->btcoexist.btc_info.btcoexist = 0;\r\nrtlpriv->btcoexist.btc_info.bt_type = BT_RTL8821A;\r\nvalue = hwinfo[EEPROM_RF_BT_SETTING];\r\nrtlpriv->btcoexist.btc_info.ant_num = (value & 0x1);\r\n} else {\r\nrtlpriv->btcoexist.btc_info.btcoexist = 0;\r\nrtlpriv->btcoexist.btc_info.bt_type = BT_RTL8821A;\r\nrtlpriv->btcoexist.btc_info.ant_num = ANT_X2;\r\n}\r\n}\r\nstatic void _rtl8821ae_read_adapter_info(struct ieee80211_hw *hw, bool b_pseudo_test)\r\n{\r\nstruct rtl_priv *rtlpriv = rtl_priv(hw);\r\nstruct rtl_efuse *rtlefuse = rtl_efuse(rtl_priv(hw));\r\nstruct rtl_hal *rtlhal = rtl_hal(rtl_priv(hw));\r\nstruct rtl_pci_priv *pcipriv = rtl_pcipriv(hw);\r\nu16 i, usvalue;\r\nu8 hwinfo[HWSET_MAX_SIZE];\r\nu16 eeprom_id;\r\nif (b_pseudo_test) {\r\n;\r\n}\r\nif (rtlefuse->epromtype == EEPROM_BOOT_EFUSE) {\r\nrtl_efuse_shadow_map_update(hw);\r\nmemcpy(hwinfo, &rtlefuse->efuse_map[EFUSE_INIT_MAP][0],\r\nHWSET_MAX_SIZE);\r\n} else if (rtlefuse->epromtype == EEPROM_93C46) {\r\nRT_TRACE(rtlpriv, COMP_ERR, DBG_EMERG,\r\n"RTL819X Not boot from eeprom, check it !!");\r\n}\r\nRT_PRINT_DATA(rtlpriv, COMP_INIT, DBG_DMESG, "MAP\n",\r\nhwinfo, HWSET_MAX_SIZE);\r\neeprom_id = *((u16 *)&hwinfo[0]);\r\nif (eeprom_id != RTL_EEPROM_ID) {\r\nRT_TRACE(rtlpriv, COMP_ERR, DBG_WARNING,\r\n"EEPROM ID(%#x) is invalid!!\n", eeprom_id);\r\nrtlefuse->autoload_failflag = true;\r\n} else {\r\nRT_TRACE(rtlpriv, COMP_INIT, DBG_LOUD, "Autoload OK\n");\r\nrtlefuse->autoload_failflag = false;\r\n}\r\nif (rtlefuse->autoload_failflag) {\r\nRT_TRACE(rtlpriv, COMP_ERR, DBG_EMERG,\r\n"RTL8812AE autoload_failflag, check it !!");\r\nreturn;\r\n}\r\nrtlefuse->eeprom_version = *(u8 *)&hwinfo[EEPROM_VERSION];\r\nif (rtlefuse->eeprom_version == 0xff)\r\nrtlefuse->eeprom_version = 0;\r\nRT_TRACE(rtlpriv, COMP_INIT, DBG_LOUD,\r\n"EEPROM version: 0x%2x\n", rtlefuse->eeprom_version);\r\nrtlefuse->eeprom_vid = *(u16 *)&hwinfo[EEPROM_VID];\r\nrtlefuse->eeprom_did = *(u16 *)&hwinfo[EEPROM_DID];\r\nrtlefuse->eeprom_svid = *(u16 *)&hwinfo[EEPROM_SVID];\r\nrtlefuse->eeprom_smid = *(u16 *)&hwinfo[EEPROM_SMID];\r\nRT_TRACE(rtlpriv, COMP_INIT, DBG_LOUD,\r\n"EEPROMId = 0x%4x\n", eeprom_id);\r\nRT_TRACE(rtlpriv, COMP_INIT, DBG_LOUD,\r\n"EEPROM VID = 0x%4x\n", rtlefuse->eeprom_vid);\r\nRT_TRACE(rtlpriv, COMP_INIT, DBG_LOUD,\r\n"EEPROM DID = 0x%4x\n", rtlefuse->eeprom_did);\r\nRT_TRACE(rtlpriv, COMP_INIT, DBG_LOUD,\r\n"EEPROM SVID = 0x%4x\n", rtlefuse->eeprom_svid);\r\nRT_TRACE(rtlpriv, COMP_INIT, DBG_LOUD,\r\n"EEPROM SMID = 0x%4x\n", rtlefuse->eeprom_smid);\r\nrtlefuse->eeprom_oemid = *(u8 *)&hwinfo[EEPROM_CUSTOMER_ID];\r\nif (rtlefuse->eeprom_oemid == 0xFF)\r\nrtlefuse->eeprom_oemid = 0;\r\nRT_TRACE(rtlpriv, COMP_INIT, DBG_LOUD,\r\n"EEPROM Customer ID: 0x%2x\n", rtlefuse->eeprom_oemid);\r\nfor (i = 0; i < 6; i += 2) {\r\nusvalue = *(u16 *)&hwinfo[EEPROM_MAC_ADDR + i];\r\n*((u16 *)(&rtlefuse->dev_addr[i])) = usvalue;\r\n}\r\nRT_TRACE(rtlpriv, COMP_INIT, DBG_DMESG,\r\n"dev_addr: %pM\n", rtlefuse->dev_addr);\r\n_rtl8821ae_read_txpower_info_from_hwpg(hw, rtlefuse->autoload_failflag,\r\nhwinfo);\r\nif (rtlhal->hw_type == HARDWARE_TYPE_RTL8812AE) {\r\n_rtl8812ae_read_pa_type(hw, hwinfo, rtlefuse->autoload_failflag);\r\n_rtl8812ae_read_bt_coexist_info_from_hwpg(hw,\r\nrtlefuse->autoload_failflag, hwinfo);\r\n} else {\r\n_rtl8821ae_read_pa_type(hw, hwinfo, rtlefuse->autoload_failflag);\r\n_rtl8821ae_read_bt_coexist_info_from_hwpg(hw,\r\nrtlefuse->autoload_failflag, hwinfo);\r\n}\r\n_rtl8821ae_read_rfe_type(hw, hwinfo, rtlefuse->autoload_failflag);\r\nrtlefuse->board_type = ODM_BOARD_DEFAULT;\r\nif (rtlhal->external_lna_2g != 0)\r\nrtlefuse->board_type |= ODM_BOARD_EXT_LNA;\r\nif (rtlhal->external_lna_5g != 0)\r\nrtlefuse->board_type |= ODM_BOARD_EXT_LNA_5G;\r\nif (rtlhal->external_pa_2g != 0)\r\nrtlefuse->board_type |= ODM_BOARD_EXT_PA;\r\nif (rtlhal->external_pa_5g != 0)\r\nrtlefuse->board_type |= ODM_BOARD_EXT_PA_5G;\r\nif (rtlpriv->btcoexist.btc_info.btcoexist == 1)\r\nrtlefuse->board_type |= ODM_BOARD_BT;\r\nrtlhal->board_type = rtlefuse->board_type;\r\nRT_TRACE(rtlpriv, COMP_INIT, DBG_LOUD,\r\n"board_type = 0x%x\n", rtlefuse->board_type);\r\nrtlefuse->eeprom_channelplan = *(u8 *)&hwinfo[EEPROM_CHANNELPLAN];\r\nif (rtlefuse->eeprom_channelplan == 0xff)\r\nrtlefuse->eeprom_channelplan = 0x7F;\r\nrtlefuse->channel_plan = rtlefuse->eeprom_channelplan;\r\nrtlefuse->crystalcap = hwinfo[EEPROM_XTAL_8821AE];\r\nif (rtlefuse->crystalcap == 0xFF)\r\nrtlefuse->crystalcap = 0x20;\r\nrtlefuse->eeprom_thermalmeter = *(u8 *)&hwinfo[EEPROM_THERMAL_METER];\r\nif ((rtlefuse->eeprom_thermalmeter == 0xff) ||\r\nrtlefuse->autoload_failflag) {\r\nrtlefuse->apk_thermalmeterignore = true;\r\nrtlefuse->eeprom_thermalmeter = 0xff;\r\n}\r\nrtlefuse->thermalmeter[0] = rtlefuse->eeprom_thermalmeter;\r\nRT_TRACE(rtlpriv, COMP_INIT, DBG_LOUD,\r\n"thermalmeter = 0x%x\n", rtlefuse->eeprom_thermalmeter);\r\nif (!rtlefuse->autoload_failflag) {\r\nrtlefuse->antenna_div_cfg =\r\n(hwinfo[EEPROM_RF_BOARD_OPTION] & 0x18) >> 3;\r\nif (hwinfo[EEPROM_RF_BOARD_OPTION] == 0xff)\r\nrtlefuse->antenna_div_cfg = 0;\r\nif (rtlpriv->btcoexist.btc_info.btcoexist == 1 &&\r\nrtlpriv->btcoexist.btc_info.ant_num == ANT_X1)\r\nrtlefuse->antenna_div_cfg = 0;\r\nrtlefuse->antenna_div_type = hwinfo[EEPROM_RF_ANTENNA_OPT_88E];\r\nif (rtlefuse->antenna_div_type == 0xff)\r\nrtlefuse->antenna_div_type = FIXED_HW_ANTDIV;\r\n} else {\r\nrtlefuse->antenna_div_cfg = 0;\r\nrtlefuse->antenna_div_type = 0;\r\n}\r\nRT_TRACE(rtlpriv, COMP_INIT, DBG_LOUD,\r\n"SWAS: bHwAntDiv = %x, TRxAntDivType = %x\n",\r\nrtlefuse->antenna_div_cfg, rtlefuse->antenna_div_type);\r\npcipriv->ledctl.led_opendrain = true;\r\nif (rtlhal->oem_id == RT_CID_DEFAULT) {\r\nswitch (rtlefuse->eeprom_oemid) {\r\ncase RT_CID_DEFAULT:\r\nbreak;\r\ncase EEPROM_CID_TOSHIBA:\r\nrtlhal->oem_id = RT_CID_TOSHIBA;\r\nbreak;\r\ncase EEPROM_CID_CCX:\r\nrtlhal->oem_id = RT_CID_CCX;\r\nbreak;\r\ncase EEPROM_CID_QMI:\r\nrtlhal->oem_id = RT_CID_819X_QMI;\r\nbreak;\r\ncase EEPROM_CID_WHQL:\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\n}\r\nvoid rtl8821ae_read_eeprom_info(struct ieee80211_hw *hw)\r\n{\r\nstruct rtl_priv *rtlpriv = rtl_priv(hw);\r\nstruct rtl_efuse *rtlefuse = rtl_efuse(rtl_priv(hw));\r\nstruct rtl_phy *rtlphy = &rtlpriv->phy;\r\nstruct rtl_hal *rtlhal = rtl_hal(rtl_priv(hw));\r\nu8 tmp_u1b;\r\nrtlhal->version = _rtl8821ae_read_chip_version(hw);\r\nif (get_rf_type(rtlphy) == RF_1T1R)\r\nrtlpriv->dm.rfpath_rxenable[0] = true;\r\nelse\r\nrtlpriv->dm.rfpath_rxenable[0] =\r\nrtlpriv->dm.rfpath_rxenable[1] = true;\r\nRT_TRACE(rtlpriv, COMP_INIT, DBG_LOUD, "VersionID = 0x%4x\n",\r\nrtlhal->version);\r\ntmp_u1b = rtl_read_byte(rtlpriv, REG_9346CR);\r\nif (tmp_u1b & BIT(4)) {\r\nRT_TRACE(rtlpriv, COMP_INIT, DBG_DMESG, "Boot from EEPROM\n");\r\nrtlefuse->epromtype = EEPROM_93C46;\r\n} else {\r\nRT_TRACE(rtlpriv, COMP_INIT, DBG_DMESG, "Boot from EFUSE\n");\r\nrtlefuse->epromtype = EEPROM_BOOT_EFUSE;\r\n}\r\nif (tmp_u1b & BIT(5)) {\r\nRT_TRACE(rtlpriv, COMP_INIT, DBG_LOUD, "Autoload OK\n");\r\nrtlefuse->autoload_failflag = false;\r\n_rtl8821ae_read_adapter_info(hw, false);\r\n} else {\r\nRT_TRACE(rtlpriv, COMP_ERR, DBG_EMERG, "Autoload ERR!!\n");\r\n}\r\n}\r\nstatic void rtl8821ae_update_hal_rate_table(struct ieee80211_hw *hw,\r\nstruct ieee80211_sta *sta)\r\n{\r\nstruct rtl_priv *rtlpriv = rtl_priv(hw);\r\nstruct rtl_phy *rtlphy = &rtlpriv->phy;\r\nstruct rtl_mac *mac = rtl_mac(rtl_priv(hw));\r\nstruct rtl_hal *rtlhal = rtl_hal(rtl_priv(hw));\r\nu32 ratr_value;\r\nu8 ratr_index = 0;\r\nu8 b_nmode = mac->ht_enable;\r\nu8 mimo_ps = IEEE80211_SMPS_OFF;\r\nu16 shortgi_rate;\r\nu32 tmp_ratr_value;\r\nu8 curtxbw_40mhz = mac->bw_40;\r\nu8 b_curshortgi_40mhz = (sta->ht_cap.cap & IEEE80211_HT_CAP_SGI_40) ?\r\n1 : 0;\r\nu8 b_curshortgi_20mhz = (sta->ht_cap.cap & IEEE80211_HT_CAP_SGI_20) ?\r\n1 : 0;\r\nenum wireless_mode wirelessmode = mac->mode;\r\nif (rtlhal->current_bandtype == BAND_ON_5G)\r\nratr_value = sta->supp_rates[1] << 4;\r\nelse\r\nratr_value = sta->supp_rates[0];\r\nif (mac->opmode == NL80211_IFTYPE_ADHOC)\r\nratr_value = 0xfff;\r\nratr_value |= (sta->ht_cap.mcs.rx_mask[1] << 20 |\r\nsta->ht_cap.mcs.rx_mask[0] << 12);\r\nswitch (wirelessmode) {\r\ncase WIRELESS_MODE_B:\r\nif (ratr_value & 0x0000000c)\r\nratr_value &= 0x0000000d;\r\nelse\r\nratr_value &= 0x0000000f;\r\nbreak;\r\ncase WIRELESS_MODE_G:\r\nratr_value &= 0x00000FF5;\r\nbreak;\r\ncase WIRELESS_MODE_N_24G:\r\ncase WIRELESS_MODE_N_5G:\r\nb_nmode = 1;\r\nif (mimo_ps == IEEE80211_SMPS_STATIC) {\r\nratr_value &= 0x0007F005;\r\n} else {\r\nu32 ratr_mask;\r\nif (get_rf_type(rtlphy) == RF_1T2R ||\r\nget_rf_type(rtlphy) == RF_1T1R)\r\nratr_mask = 0x000ff005;\r\nelse\r\nratr_mask = 0x0f0ff005;\r\nratr_value &= ratr_mask;\r\n}\r\nbreak;\r\ndefault:\r\nif (rtlphy->rf_type == RF_1T2R)\r\nratr_value &= 0x000ff0ff;\r\nelse\r\nratr_value &= 0x0f0ff0ff;\r\nbreak;\r\n}\r\nif ((rtlpriv->btcoexist.bt_coexistence) &&\r\n(rtlpriv->btcoexist.bt_coexist_type == BT_CSR_BC4) &&\r\n(rtlpriv->btcoexist.bt_cur_state) &&\r\n(rtlpriv->btcoexist.bt_ant_isolation) &&\r\n((rtlpriv->btcoexist.bt_service == BT_SCO) ||\r\n(rtlpriv->btcoexist.bt_service == BT_BUSY)))\r\nratr_value &= 0x0fffcfc0;\r\nelse\r\nratr_value &= 0x0FFFFFFF;\r\nif (b_nmode && ((curtxbw_40mhz &&\r\nb_curshortgi_40mhz) || (!curtxbw_40mhz &&\r\nb_curshortgi_20mhz))) {\r\nratr_value |= 0x10000000;\r\ntmp_ratr_value = (ratr_value >> 12);\r\nfor (shortgi_rate = 15; shortgi_rate > 0; shortgi_rate--) {\r\nif ((1 << shortgi_rate) & tmp_ratr_value)\r\nbreak;\r\n}\r\nshortgi_rate = (shortgi_rate << 12) | (shortgi_rate << 8) |\r\n(shortgi_rate << 4) | (shortgi_rate);\r\n}\r\nrtl_write_dword(rtlpriv, REG_ARFR0 + ratr_index * 4, ratr_value);\r\nRT_TRACE(rtlpriv, COMP_RATR, DBG_DMESG,\r\n"%x\n", rtl_read_dword(rtlpriv, REG_ARFR0));\r\n}\r\nstatic u8 _rtl8821ae_mrate_idx_to_arfr_id(\r\nstruct ieee80211_hw *hw, u8 rate_index,\r\nenum wireless_mode wirelessmode)\r\n{\r\nstruct rtl_priv *rtlpriv = rtl_priv(hw);\r\nstruct rtl_phy *rtlphy = &rtlpriv->phy;\r\nu8 ret = 0;\r\nswitch (rate_index) {\r\ncase RATR_INX_WIRELESS_NGB:\r\nif (rtlphy->rf_type == RF_1T1R)\r\nret = 1;\r\nelse\r\nret = 0;\r\n; break;\r\ncase RATR_INX_WIRELESS_N:\r\ncase RATR_INX_WIRELESS_NG:\r\nif (rtlphy->rf_type == RF_1T1R)\r\nret = 5;\r\nelse\r\nret = 4;\r\n; break;\r\ncase RATR_INX_WIRELESS_NB:\r\nif (rtlphy->rf_type == RF_1T1R)\r\nret = 3;\r\nelse\r\nret = 2;\r\n; break;\r\ncase RATR_INX_WIRELESS_GB:\r\nret = 6;\r\nbreak;\r\ncase RATR_INX_WIRELESS_G:\r\nret = 7;\r\nbreak;\r\ncase RATR_INX_WIRELESS_B:\r\nret = 8;\r\nbreak;\r\ncase RATR_INX_WIRELESS_MC:\r\nif ((wirelessmode == WIRELESS_MODE_B)\r\n|| (wirelessmode == WIRELESS_MODE_G)\r\n|| (wirelessmode == WIRELESS_MODE_N_24G)\r\n|| (wirelessmode == WIRELESS_MODE_AC_24G))\r\nret = 6;\r\nelse\r\nret = 7;\r\ncase RATR_INX_WIRELESS_AC_5N:\r\nif (rtlphy->rf_type == RF_1T1R)\r\nret = 10;\r\nelse\r\nret = 9;\r\nbreak;\r\ncase RATR_INX_WIRELESS_AC_24N:\r\nif (rtlphy->current_chan_bw == HT_CHANNEL_WIDTH_80) {\r\nif (rtlphy->rf_type == RF_1T1R)\r\nret = 10;\r\nelse\r\nret = 9;\r\n} else {\r\nif (rtlphy->rf_type == RF_1T1R)\r\nret = 11;\r\nelse\r\nret = 12;\r\n}\r\nbreak;\r\ndefault:\r\nret = 0; break;\r\n}\r\nreturn ret;\r\n}\r\nstatic u32 _rtl8821ae_rate_to_bitmap_2ssvht(__le16 vht_rate)\r\n{\r\nu8 i, j, tmp_rate;\r\nu32 rate_bitmap = 0;\r\nfor (i = j = 0; i < 4; i += 2, j += 10) {\r\ntmp_rate = (le16_to_cpu(vht_rate) >> i) & 3;\r\nswitch (tmp_rate) {\r\ncase 2:\r\nrate_bitmap = rate_bitmap | (0x03ff << j);\r\nbreak;\r\ncase 1:\r\nrate_bitmap = rate_bitmap | (0x01ff << j);\r\nbreak;\r\ncase 0:\r\nrate_bitmap = rate_bitmap | (0x00ff << j);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nreturn rate_bitmap;\r\n}\r\nstatic u32 _rtl8821ae_set_ra_vht_ratr_bitmap(struct ieee80211_hw *hw,\r\nenum wireless_mode wirelessmode,\r\nu32 ratr_bitmap)\r\n{\r\nstruct rtl_priv *rtlpriv = rtl_priv(hw);\r\nstruct rtl_phy *rtlphy = &rtlpriv->phy;\r\nu32 ret_bitmap = ratr_bitmap;\r\nif (rtlphy->current_chan_bw == HT_CHANNEL_WIDTH_20_40\r\n|| rtlphy->current_chan_bw == HT_CHANNEL_WIDTH_80)\r\nret_bitmap = ratr_bitmap;\r\nelse if (wirelessmode == WIRELESS_MODE_AC_5G\r\n|| wirelessmode == WIRELESS_MODE_AC_24G) {\r\nif (rtlphy->rf_type == RF_1T1R)\r\nret_bitmap = ratr_bitmap & (~BIT21);\r\nelse\r\nret_bitmap = ratr_bitmap & (~(BIT31|BIT21));\r\n}\r\nreturn ret_bitmap;\r\n}\r\nstatic u8 _rtl8821ae_get_vht_eni(enum wireless_mode wirelessmode,\r\nu32 ratr_bitmap)\r\n{\r\nu8 ret = 0;\r\nif (wirelessmode < WIRELESS_MODE_N_24G)\r\nret = 0;\r\nelse if (wirelessmode == WIRELESS_MODE_AC_24G) {\r\nif (ratr_bitmap & 0xfff00000)\r\nret = 3;\r\nelse\r\nret = 2;\r\n} else if (wirelessmode == WIRELESS_MODE_AC_5G) {\r\nret = 1;\r\n}\r\nreturn ret << 4;\r\n}\r\nstatic u8 _rtl8821ae_get_ra_ldpc(struct ieee80211_hw *hw,\r\nu8 mac_id, struct rtl_sta_info *sta_entry,\r\nenum wireless_mode wirelessmode)\r\n{\r\nu8 b_ldpc = 0;\r\nreturn b_ldpc << 2;\r\n}\r\nstatic u8 _rtl8821ae_get_ra_rftype(struct ieee80211_hw *hw,\r\nenum wireless_mode wirelessmode,\r\nu32 ratr_bitmap)\r\n{\r\nstruct rtl_priv *rtlpriv = rtl_priv(hw);\r\nstruct rtl_phy *rtlphy = &rtlpriv->phy;\r\nu8 rf_type = RF_1T1R;\r\nif (rtlphy->rf_type == RF_1T1R)\r\nrf_type = RF_1T1R;\r\nelse if (wirelessmode == WIRELESS_MODE_AC_5G\r\n|| wirelessmode == WIRELESS_MODE_AC_24G\r\n|| wirelessmode == WIRELESS_MODE_AC_ONLY) {\r\nif (ratr_bitmap & 0xffc00000)\r\nrf_type = RF_2T2R;\r\n} else if (wirelessmode == WIRELESS_MODE_N_5G\r\n|| wirelessmode == WIRELESS_MODE_N_24G) {\r\nif (ratr_bitmap & 0xfff00000)\r\nrf_type = RF_2T2R;\r\n}\r\nreturn rf_type;\r\n}\r\nstatic bool _rtl8821ae_get_ra_shortgi(struct ieee80211_hw *hw, struct ieee80211_sta *sta,\r\nu8 mac_id)\r\n{\r\nbool b_short_gi = false;\r\nu8 b_curshortgi_40mhz = (sta->ht_cap.cap & IEEE80211_HT_CAP_SGI_40) ?\r\n1 : 0;\r\nu8 b_curshortgi_20mhz = (sta->ht_cap.cap & IEEE80211_HT_CAP_SGI_20) ?\r\n1 : 0;\r\nu8 b_curshortgi_80mhz = 0;\r\nb_curshortgi_80mhz = (sta->vht_cap.cap &\r\nIEEE80211_VHT_CAP_SHORT_GI_80) ? 1 : 0;\r\nif (mac_id == MAC_ID_STATIC_FOR_BROADCAST_MULTICAST)\r\nb_short_gi = false;\r\nif (b_curshortgi_40mhz || b_curshortgi_80mhz\r\n|| b_curshortgi_20mhz)\r\nb_short_gi = true;\r\nreturn b_short_gi;\r\n}\r\nstatic void rtl8821ae_update_hal_rate_mask(struct ieee80211_hw *hw,\r\nstruct ieee80211_sta *sta, u8 rssi_level)\r\n{\r\nstruct rtl_priv *rtlpriv = rtl_priv(hw);\r\nstruct rtl_phy *rtlphy = &rtlpriv->phy;\r\nstruct rtl_mac *mac = rtl_mac(rtl_priv(hw));\r\nstruct rtl_sta_info *sta_entry = NULL;\r\nu32 ratr_bitmap;\r\nu8 ratr_index;\r\nenum wireless_mode wirelessmode = 0;\r\nu8 curtxbw_40mhz = (sta->ht_cap.cap & IEEE80211_HT_CAP_SUP_WIDTH_20_40)\r\n? 1 : 0;\r\nbool b_shortgi = false;\r\nu8 rate_mask[7];\r\nu8 macid = 0;\r\nu8 mimo_ps = IEEE80211_SMPS_OFF;\r\nu8 rf_type;\r\nsta_entry = (struct rtl_sta_info *)sta->drv_priv;\r\nwirelessmode = sta_entry->wireless_mode;\r\nRT_TRACE(rtlpriv, COMP_RATR, DBG_LOUD,\r\n"wireless mode = 0x%x\n", wirelessmode);\r\nif (mac->opmode == NL80211_IFTYPE_STATION ||\r\nmac->opmode == NL80211_IFTYPE_MESH_POINT) {\r\ncurtxbw_40mhz = mac->bw_40;\r\n} else if (mac->opmode == NL80211_IFTYPE_AP ||\r\nmac->opmode == NL80211_IFTYPE_ADHOC)\r\nmacid = sta->aid + 1;\r\nif (wirelessmode == WIRELESS_MODE_N_5G ||\r\nwirelessmode == WIRELESS_MODE_AC_5G ||\r\nwirelessmode == WIRELESS_MODE_A)\r\nratr_bitmap = sta->supp_rates[NL80211_BAND_5GHZ] << 4;\r\nelse\r\nratr_bitmap = sta->supp_rates[NL80211_BAND_2GHZ];\r\nif (mac->opmode == NL80211_IFTYPE_ADHOC)\r\nratr_bitmap = 0xfff;\r\nif (wirelessmode == WIRELESS_MODE_N_24G\r\n|| wirelessmode == WIRELESS_MODE_N_5G)\r\nratr_bitmap |= (sta->ht_cap.mcs.rx_mask[1] << 20 |\r\nsta->ht_cap.mcs.rx_mask[0] << 12);\r\nelse if (wirelessmode == WIRELESS_MODE_AC_24G\r\n|| wirelessmode == WIRELESS_MODE_AC_5G\r\n|| wirelessmode == WIRELESS_MODE_AC_ONLY)\r\nratr_bitmap |= _rtl8821ae_rate_to_bitmap_2ssvht(\r\nsta->vht_cap.vht_mcs.rx_mcs_map) << 12;\r\nb_shortgi = _rtl8821ae_get_ra_shortgi(hw, sta, macid);\r\nrf_type = _rtl8821ae_get_ra_rftype(hw, wirelessmode, ratr_bitmap);\r\nswitch (wirelessmode) {\r\ncase WIRELESS_MODE_B:\r\nratr_index = RATR_INX_WIRELESS_B;\r\nif (ratr_bitmap & 0x0000000c)\r\nratr_bitmap &= 0x0000000d;\r\nelse\r\nratr_bitmap &= 0x0000000f;\r\nbreak;\r\ncase WIRELESS_MODE_G:\r\nratr_index = RATR_INX_WIRELESS_GB;\r\nif (rssi_level == 1)\r\nratr_bitmap &= 0x00000f00;\r\nelse if (rssi_level == 2)\r\nratr_bitmap &= 0x00000ff0;\r\nelse\r\nratr_bitmap &= 0x00000ff5;\r\nbreak;\r\ncase WIRELESS_MODE_A:\r\nratr_index = RATR_INX_WIRELESS_G;\r\nratr_bitmap &= 0x00000ff0;\r\nbreak;\r\ncase WIRELESS_MODE_N_24G:\r\ncase WIRELESS_MODE_N_5G:\r\nif (wirelessmode == WIRELESS_MODE_N_24G)\r\nratr_index = RATR_INX_WIRELESS_NGB;\r\nelse\r\nratr_index = RATR_INX_WIRELESS_NG;\r\nif (mimo_ps == IEEE80211_SMPS_STATIC\r\n|| mimo_ps == IEEE80211_SMPS_DYNAMIC) {\r\nif (rssi_level == 1)\r\nratr_bitmap &= 0x000f0000;\r\nelse if (rssi_level == 2)\r\nratr_bitmap &= 0x000ff000;\r\nelse\r\nratr_bitmap &= 0x000ff005;\r\n} else {\r\nif (rf_type == RF_1T1R) {\r\nif (curtxbw_40mhz) {\r\nif (rssi_level == 1)\r\nratr_bitmap &= 0x000f0000;\r\nelse if (rssi_level == 2)\r\nratr_bitmap &= 0x000ff000;\r\nelse\r\nratr_bitmap &= 0x000ff015;\r\n} else {\r\nif (rssi_level == 1)\r\nratr_bitmap &= 0x000f0000;\r\nelse if (rssi_level == 2)\r\nratr_bitmap &= 0x000ff000;\r\nelse\r\nratr_bitmap &= 0x000ff005;\r\n}\r\n} else {\r\nif (curtxbw_40mhz) {\r\nif (rssi_level == 1)\r\nratr_bitmap &= 0x0fff0000;\r\nelse if (rssi_level == 2)\r\nratr_bitmap &= 0x0ffff000;\r\nelse\r\nratr_bitmap &= 0x0ffff015;\r\n} else {\r\nif (rssi_level == 1)\r\nratr_bitmap &= 0x0fff0000;\r\nelse if (rssi_level == 2)\r\nratr_bitmap &= 0x0ffff000;\r\nelse\r\nratr_bitmap &= 0x0ffff005;\r\n}\r\n}\r\n}\r\nbreak;\r\ncase WIRELESS_MODE_AC_24G:\r\nratr_index = RATR_INX_WIRELESS_AC_24N;\r\nif (rssi_level == 1)\r\nratr_bitmap &= 0xfc3f0000;\r\nelse if (rssi_level == 2)\r\nratr_bitmap &= 0xfffff000;\r\nelse\r\nratr_bitmap &= 0xffffffff;\r\nbreak;\r\ncase WIRELESS_MODE_AC_5G:\r\nratr_index = RATR_INX_WIRELESS_AC_5N;\r\nif (rf_type == RF_1T1R) {\r\nif (rssi_level == 1)\r\nratr_bitmap &= 0x003f8000;\r\nelse if (rssi_level == 2)\r\nratr_bitmap &= 0x003ff000;\r\nelse\r\nratr_bitmap &= 0x003ff010;\r\n} else {\r\nif (rssi_level == 1)\r\nratr_bitmap &= 0xfe3f8000;\r\nelse if (rssi_level == 2)\r\nratr_bitmap &= 0xfffff000;\r\nelse\r\nratr_bitmap &= 0xfffff010;\r\n}\r\nbreak;\r\ndefault:\r\nratr_index = RATR_INX_WIRELESS_NGB;\r\nif (rf_type == RF_1T2R)\r\nratr_bitmap &= 0x000ff0ff;\r\nelse\r\nratr_bitmap &= 0x0f8ff0ff;\r\nbreak;\r\n}\r\nratr_index = _rtl8821ae_mrate_idx_to_arfr_id(hw, ratr_index, wirelessmode);\r\nsta_entry->ratr_index = ratr_index;\r\nratr_bitmap = _rtl8821ae_set_ra_vht_ratr_bitmap(hw, wirelessmode,\r\nratr_bitmap);\r\nRT_TRACE(rtlpriv, COMP_RATR, DBG_LOUD,\r\n"ratr_bitmap :%x\n", ratr_bitmap);\r\nrate_mask[0] = macid;\r\nrate_mask[1] = ratr_index | (b_shortgi ? 0x80 : 0x00);\r\nrate_mask[2] = rtlphy->current_chan_bw\r\n| _rtl8821ae_get_vht_eni(wirelessmode, ratr_bitmap)\r\n| _rtl8821ae_get_ra_ldpc(hw, macid, sta_entry, wirelessmode);\r\nrate_mask[3] = (u8)(ratr_bitmap & 0x000000ff);\r\nrate_mask[4] = (u8)((ratr_bitmap & 0x0000ff00) >> 8);\r\nrate_mask[5] = (u8)((ratr_bitmap & 0x00ff0000) >> 16);\r\nrate_mask[6] = (u8)((ratr_bitmap & 0xff000000) >> 24);\r\nRT_TRACE(rtlpriv, COMP_RATR, DBG_DMESG,\r\n"Rate_index:%x, ratr_val:%x, %x:%x:%x:%x:%x:%x:%x\n",\r\nratr_index, ratr_bitmap,\r\nrate_mask[0], rate_mask[1],\r\nrate_mask[2], rate_mask[3],\r\nrate_mask[4], rate_mask[5],\r\nrate_mask[6]);\r\nrtl8821ae_fill_h2c_cmd(hw, H2C_8821AE_RA_MASK, 7, rate_mask);\r\n_rtl8821ae_set_bcn_ctrl_reg(hw, BIT(3), 0);\r\n}\r\nvoid rtl8821ae_update_hal_rate_tbl(struct ieee80211_hw *hw,\r\nstruct ieee80211_sta *sta, u8 rssi_level)\r\n{\r\nstruct rtl_priv *rtlpriv = rtl_priv(hw);\r\nif (rtlpriv->dm.useramask)\r\nrtl8821ae_update_hal_rate_mask(hw, sta, rssi_level);\r\nelse\r\nrtl8821ae_update_hal_rate_table(hw, sta);\r\n}\r\nvoid rtl8821ae_update_channel_access_setting(struct ieee80211_hw *hw)\r\n{\r\nstruct rtl_priv *rtlpriv = rtl_priv(hw);\r\nstruct rtl_mac *mac = rtl_mac(rtl_priv(hw));\r\nu8 wireless_mode = mac->mode;\r\nu8 sifs_timer, r2t_sifs;\r\nrtlpriv->cfg->ops->set_hw_reg(hw, HW_VAR_SLOT_TIME,\r\n(u8 *)&mac->slot_time);\r\nif (wireless_mode == WIRELESS_MODE_G)\r\nsifs_timer = 0x0a;\r\nelse\r\nsifs_timer = 0x0e;\r\nrtlpriv->cfg->ops->set_hw_reg(hw, HW_VAR_SIFS, (u8 *)&sifs_timer);\r\nr2t_sifs = 0xa;\r\nif (wireless_mode == WIRELESS_MODE_AC_5G &&\r\n(mac->vht_ldpc_cap & LDPC_VHT_ENABLE_RX) &&\r\n(mac->vht_stbc_cap & STBC_VHT_ENABLE_RX)) {\r\nif (mac->vendor == PEER_ATH)\r\nr2t_sifs = 0x8;\r\nelse\r\nr2t_sifs = 0xa;\r\n} else if (wireless_mode == WIRELESS_MODE_AC_5G) {\r\nr2t_sifs = 0xa;\r\n}\r\nrtlpriv->cfg->ops->set_hw_reg(hw, HW_VAR_R2T_SIFS, (u8 *)&r2t_sifs);\r\n}\r\nbool rtl8821ae_gpio_radio_on_off_checking(struct ieee80211_hw *hw, u8 *valid)\r\n{\r\nstruct rtl_priv *rtlpriv = rtl_priv(hw);\r\nstruct rtl_ps_ctl *ppsc = rtl_psc(rtl_priv(hw));\r\nstruct rtl_phy *rtlphy = &rtlpriv->phy;\r\nenum rf_pwrstate e_rfpowerstate_toset, cur_rfstate;\r\nu8 u1tmp = 0;\r\nbool b_actuallyset = false;\r\nif (rtlpriv->rtlhal.being_init_adapter)\r\nreturn false;\r\nif (ppsc->swrf_processing)\r\nreturn false;\r\nspin_lock(&rtlpriv->locks.rf_ps_lock);\r\nif (ppsc->rfchange_inprogress) {\r\nspin_unlock(&rtlpriv->locks.rf_ps_lock);\r\nreturn false;\r\n} else {\r\nppsc->rfchange_inprogress = true;\r\nspin_unlock(&rtlpriv->locks.rf_ps_lock);\r\n}\r\ncur_rfstate = ppsc->rfpwr_state;\r\nrtl_write_byte(rtlpriv, REG_GPIO_IO_SEL_2,\r\nrtl_read_byte(rtlpriv,\r\nREG_GPIO_IO_SEL_2) & ~(BIT(1)));\r\nu1tmp = rtl_read_byte(rtlpriv, REG_GPIO_PIN_CTRL_2);\r\nif (rtlphy->polarity_ctl)\r\ne_rfpowerstate_toset = (u1tmp & BIT(1)) ? ERFOFF : ERFON;\r\nelse\r\ne_rfpowerstate_toset = (u1tmp & BIT(1)) ? ERFON : ERFOFF;\r\nif ((ppsc->hwradiooff) && (e_rfpowerstate_toset == ERFON)) {\r\nRT_TRACE(rtlpriv, COMP_RF, DBG_DMESG,\r\n"GPIOChangeRF - HW Radio ON, RF ON\n");\r\ne_rfpowerstate_toset = ERFON;\r\nppsc->hwradiooff = false;\r\nb_actuallyset = true;\r\n} else if ((!ppsc->hwradiooff)\r\n&& (e_rfpowerstate_toset == ERFOFF)) {\r\nRT_TRACE(rtlpriv, COMP_RF, DBG_DMESG,\r\n"GPIOChangeRF - HW Radio OFF, RF OFF\n");\r\ne_rfpowerstate_toset = ERFOFF;\r\nppsc->hwradiooff = true;\r\nb_actuallyset = true;\r\n}\r\nif (b_actuallyset) {\r\nspin_lock(&rtlpriv->locks.rf_ps_lock);\r\nppsc->rfchange_inprogress = false;\r\nspin_unlock(&rtlpriv->locks.rf_ps_lock);\r\n} else {\r\nif (ppsc->reg_rfps_level & RT_RF_OFF_LEVL_HALT_NIC)\r\nRT_SET_PS_LEVEL(ppsc, RT_RF_OFF_LEVL_HALT_NIC);\r\nspin_lock(&rtlpriv->locks.rf_ps_lock);\r\nppsc->rfchange_inprogress = false;\r\nspin_unlock(&rtlpriv->locks.rf_ps_lock);\r\n}\r\n*valid = 1;\r\nreturn !ppsc->hwradiooff;\r\n}\r\nvoid rtl8821ae_set_key(struct ieee80211_hw *hw, u32 key_index,\r\nu8 *p_macaddr, bool is_group, u8 enc_algo,\r\nbool is_wepkey, bool clear_all)\r\n{\r\nstruct rtl_priv *rtlpriv = rtl_priv(hw);\r\nstruct rtl_mac *mac = rtl_mac(rtl_priv(hw));\r\nstruct rtl_efuse *rtlefuse = rtl_efuse(rtl_priv(hw));\r\nu8 *macaddr = p_macaddr;\r\nu32 entry_id = 0;\r\nbool is_pairwise = false;\r\nstatic u8 cam_const_addr[4][6] = {\r\n{0x00, 0x00, 0x00, 0x00, 0x00, 0x00},\r\n{0x00, 0x00, 0x00, 0x00, 0x00, 0x01},\r\n{0x00, 0x00, 0x00, 0x00, 0x00, 0x02},\r\n{0x00, 0x00, 0x00, 0x00, 0x00, 0x03}\r\n};\r\nstatic u8 cam_const_broad[] = {\r\n0xff, 0xff, 0xff, 0xff, 0xff, 0xff\r\n};\r\nif (clear_all) {\r\nu8 idx = 0;\r\nu8 cam_offset = 0;\r\nu8 clear_number = 5;\r\nRT_TRACE(rtlpriv, COMP_SEC, DBG_DMESG, "clear_all\n");\r\nfor (idx = 0; idx < clear_number; idx++) {\r\nrtl_cam_mark_invalid(hw, cam_offset + idx);\r\nrtl_cam_empty_entry(hw, cam_offset + idx);\r\nif (idx < 5) {\r\nmemset(rtlpriv->sec.key_buf[idx], 0,\r\nMAX_KEY_LEN);\r\nrtlpriv->sec.key_len[idx] = 0;\r\n}\r\n}\r\n} else {\r\nswitch (enc_algo) {\r\ncase WEP40_ENCRYPTION:\r\nenc_algo = CAM_WEP40;\r\nbreak;\r\ncase WEP104_ENCRYPTION:\r\nenc_algo = CAM_WEP104;\r\nbreak;\r\ncase TKIP_ENCRYPTION:\r\nenc_algo = CAM_TKIP;\r\nbreak;\r\ncase AESCCMP_ENCRYPTION:\r\nenc_algo = CAM_AES;\r\nbreak;\r\ndefault:\r\nRT_TRACE(rtlpriv, COMP_ERR, DBG_LOUD,\r\n"switch case not process\n");\r\nenc_algo = CAM_TKIP;\r\nbreak;\r\n}\r\nif (is_wepkey || rtlpriv->sec.use_defaultkey) {\r\nmacaddr = cam_const_addr[key_index];\r\nentry_id = key_index;\r\n} else {\r\nif (is_group) {\r\nmacaddr = cam_const_broad;\r\nentry_id = key_index;\r\n} else {\r\nif (mac->opmode == NL80211_IFTYPE_AP) {\r\nentry_id = rtl_cam_get_free_entry(hw, p_macaddr);\r\nif (entry_id >= TOTAL_CAM_ENTRY) {\r\nRT_TRACE(rtlpriv, COMP_SEC, DBG_EMERG,\r\n"Can not find free hwsecurity cam entry\n");\r\nreturn;\r\n}\r\n} else {\r\nentry_id = CAM_PAIRWISE_KEY_POSITION;\r\n}\r\nkey_index = PAIRWISE_KEYIDX;\r\nis_pairwise = true;\r\n}\r\n}\r\nif (rtlpriv->sec.key_len[key_index] == 0) {\r\nRT_TRACE(rtlpriv, COMP_SEC, DBG_DMESG,\r\n"delete one entry, entry_id is %d\n",\r\nentry_id);\r\nif (mac->opmode == NL80211_IFTYPE_AP)\r\nrtl_cam_del_entry(hw, p_macaddr);\r\nrtl_cam_delete_one_entry(hw, p_macaddr, entry_id);\r\n} else {\r\nRT_TRACE(rtlpriv, COMP_SEC, DBG_DMESG,\r\n"add one entry\n");\r\nif (is_pairwise) {\r\nRT_TRACE(rtlpriv, COMP_SEC, DBG_DMESG,\r\n"set Pairwise key\n");\r\nrtl_cam_add_one_entry(hw, macaddr, key_index,\r\nentry_id, enc_algo,\r\nCAM_CONFIG_NO_USEDK,\r\nrtlpriv->sec.key_buf[key_index]);\r\n} else {\r\nRT_TRACE(rtlpriv, COMP_SEC, DBG_DMESG,\r\n"set group key\n");\r\nif (mac->opmode == NL80211_IFTYPE_ADHOC) {\r\nrtl_cam_add_one_entry(hw,\r\nrtlefuse->dev_addr,\r\nPAIRWISE_KEYIDX,\r\nCAM_PAIRWISE_KEY_POSITION,\r\nenc_algo,\r\nCAM_CONFIG_NO_USEDK,\r\nrtlpriv->sec.key_buf\r\n[entry_id]);\r\n}\r\nrtl_cam_add_one_entry(hw, macaddr, key_index,\r\nentry_id, enc_algo,\r\nCAM_CONFIG_NO_USEDK,\r\nrtlpriv->sec.key_buf[entry_id]);\r\n}\r\n}\r\n}\r\n}\r\nvoid rtl8821ae_bt_reg_init(struct ieee80211_hw *hw)\r\n{\r\nstruct rtl_priv *rtlpriv = rtl_priv(hw);\r\nrtlpriv->btcoexist.reg_bt_iso = 2;\r\nrtlpriv->btcoexist.reg_bt_sco = 3;\r\nrtlpriv->btcoexist.reg_bt_sco = 0;\r\n}\r\nvoid rtl8821ae_bt_hw_init(struct ieee80211_hw *hw)\r\n{\r\nstruct rtl_priv *rtlpriv = rtl_priv(hw);\r\nif (rtlpriv->cfg->ops->get_btc_status())\r\nrtlpriv->btcoexist.btc_ops->btc_init_hw_config(rtlpriv);\r\n}\r\nvoid rtl8821ae_suspend(struct ieee80211_hw *hw)\r\n{\r\n}\r\nvoid rtl8821ae_resume(struct ieee80211_hw *hw)\r\n{\r\n}\r\nvoid rtl8821ae_allow_all_destaddr(struct ieee80211_hw *hw,\r\nbool allow_all_da, bool write_into_reg)\r\n{\r\nstruct rtl_priv *rtlpriv = rtl_priv(hw);\r\nstruct rtl_pci *rtlpci = rtl_pcidev(rtl_pcipriv(hw));\r\nif (allow_all_da)\r\nrtlpci->receive_config |= RCR_AAP;\r\nelse\r\nrtlpci->receive_config &= ~RCR_AAP;\r\nif (write_into_reg)\r\nrtl_write_dword(rtlpriv, REG_RCR, rtlpci->receive_config);\r\nRT_TRACE(rtlpriv, COMP_TURBO | COMP_INIT, DBG_LOUD,\r\n"receive_config=0x%08X, write_into_reg=%d\n",\r\nrtlpci->receive_config, write_into_reg);\r\n}\r\nvoid rtl8821ae_add_wowlan_pattern(struct ieee80211_hw *hw,\r\nstruct rtl_wow_pattern *rtl_pattern,\r\nu8 index)\r\n{\r\nstruct rtl_priv *rtlpriv = rtl_priv(hw);\r\nu32 cam = 0;\r\nu8 addr = 0;\r\nu16 rxbuf_addr;\r\nu8 tmp, count = 0;\r\nu16 cam_start;\r\nu16 offset;\r\noffset = MAX_RX_DMA_BUFFER_SIZE_8812 / 128;\r\ncam_start = offset * 128;\r\nrtl_write_byte(rtlpriv, REG_PKT_BUFF_ACCESS_CTRL, RXPKT_BUF_SELECT);\r\nfor (addr = 0; addr < WKFMCAM_ADDR_NUM; addr++) {\r\nrxbuf_addr = (cam_start + index * WKFMCAM_SIZE + addr * 4) >> 3;\r\nrtl_write_word(rtlpriv, REG_PKTBUF_DBG_CTRL, rxbuf_addr);\r\nif (addr == 0) {\r\ncam = BIT(31) | rtl_pattern->crc;\r\nif (rtl_pattern->type == UNICAST_PATTERN)\r\ncam |= BIT(24);\r\nelse if (rtl_pattern->type == MULTICAST_PATTERN)\r\ncam |= BIT(25);\r\nelse if (rtl_pattern->type == BROADCAST_PATTERN)\r\ncam |= BIT(26);\r\nrtl_write_dword(rtlpriv, REG_PKTBUF_DBG_DATA_L, cam);\r\nRT_TRACE(rtlpriv, COMP_POWER, DBG_TRACE,\r\n"WRITE entry[%d] 0x%x: %x\n", addr,\r\nREG_PKTBUF_DBG_DATA_L, cam);\r\nrtl_write_word(rtlpriv, REG_RXPKTBUF_CTRL, 0x0f01);\r\n} else if (addr == 2 || addr == 4) {\r\ncam = rtl_pattern->mask[addr - 2];\r\nrtl_write_dword(rtlpriv, REG_PKTBUF_DBG_DATA_L, cam);\r\nRT_TRACE(rtlpriv, COMP_POWER, DBG_TRACE,\r\n"WRITE entry[%d] 0x%x: %x\n", addr,\r\nREG_PKTBUF_DBG_DATA_L, cam);\r\nrtl_write_word(rtlpriv, REG_RXPKTBUF_CTRL, 0x0f01);\r\n} else if (addr == 3 || addr == 5) {\r\ncam = rtl_pattern->mask[addr - 2];\r\nrtl_write_dword(rtlpriv, REG_PKTBUF_DBG_DATA_H, cam);\r\nRT_TRACE(rtlpriv, COMP_POWER, DBG_TRACE,\r\n"WRITE entry[%d] 0x%x: %x\n", addr,\r\nREG_PKTBUF_DBG_DATA_H, cam);\r\nrtl_write_word(rtlpriv, REG_RXPKTBUF_CTRL, 0xf001);\r\n}\r\ncount = 0;\r\ndo {\r\ntmp = rtl_read_byte(rtlpriv, REG_RXPKTBUF_CTRL);\r\nudelay(2);\r\ncount++;\r\n} while (tmp && count < 100);\r\nRT_ASSERT((count < 100),\r\n"Write wake up frame mask FAIL %d value!\n", tmp);\r\n}\r\nrtl_write_byte(rtlpriv, REG_PKT_BUFF_ACCESS_CTRL,\r\nDISABLE_TRXPKT_BUF_ACCESS);\r\n}
