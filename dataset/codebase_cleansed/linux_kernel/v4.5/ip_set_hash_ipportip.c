static inline bool\r\nhash_ipportip4_data_equal(const struct hash_ipportip4_elem *ip1,\r\nconst struct hash_ipportip4_elem *ip2,\r\nu32 *multi)\r\n{\r\nreturn ip1->ip == ip2->ip &&\r\nip1->ip2 == ip2->ip2 &&\r\nip1->port == ip2->port &&\r\nip1->proto == ip2->proto;\r\n}\r\nstatic bool\r\nhash_ipportip4_data_list(struct sk_buff *skb,\r\nconst struct hash_ipportip4_elem *data)\r\n{\r\nif (nla_put_ipaddr4(skb, IPSET_ATTR_IP, data->ip) ||\r\nnla_put_ipaddr4(skb, IPSET_ATTR_IP2, data->ip2) ||\r\nnla_put_net16(skb, IPSET_ATTR_PORT, data->port) ||\r\nnla_put_u8(skb, IPSET_ATTR_PROTO, data->proto))\r\ngoto nla_put_failure;\r\nreturn false;\r\nnla_put_failure:\r\nreturn true;\r\n}\r\nstatic inline void\r\nhash_ipportip4_data_next(struct hash_ipportip4_elem *next,\r\nconst struct hash_ipportip4_elem *d)\r\n{\r\nnext->ip = d->ip;\r\nnext->port = d->port;\r\n}\r\nstatic int\r\nhash_ipportip4_kadt(struct ip_set *set, const struct sk_buff *skb,\r\nconst struct xt_action_param *par,\r\nenum ipset_adt adt, struct ip_set_adt_opt *opt)\r\n{\r\nipset_adtfn adtfn = set->variant->adt[adt];\r\nstruct hash_ipportip4_elem e = { .ip = 0 };\r\nstruct ip_set_ext ext = IP_SET_INIT_KEXT(skb, opt, set);\r\nif (!ip_set_get_ip4_port(skb, opt->flags & IPSET_DIM_TWO_SRC,\r\n&e.port, &e.proto))\r\nreturn -EINVAL;\r\nip4addrptr(skb, opt->flags & IPSET_DIM_ONE_SRC, &e.ip);\r\nip4addrptr(skb, opt->flags & IPSET_DIM_THREE_SRC, &e.ip2);\r\nreturn adtfn(set, &e, &ext, &opt->ext, opt->cmdflags);\r\n}\r\nstatic int\r\nhash_ipportip4_uadt(struct ip_set *set, struct nlattr *tb[],\r\nenum ipset_adt adt, u32 *lineno, u32 flags, bool retried)\r\n{\r\nconst struct hash_ipportip *h = set->data;\r\nipset_adtfn adtfn = set->variant->adt[adt];\r\nstruct hash_ipportip4_elem e = { .ip = 0 };\r\nstruct ip_set_ext ext = IP_SET_INIT_UEXT(set);\r\nu32 ip, ip_to = 0, p = 0, port, port_to;\r\nbool with_ports = false;\r\nint ret;\r\nif (tb[IPSET_ATTR_LINENO])\r\n*lineno = nla_get_u32(tb[IPSET_ATTR_LINENO]);\r\nif (unlikely(!tb[IPSET_ATTR_IP] || !tb[IPSET_ATTR_IP2] ||\r\n!ip_set_attr_netorder(tb, IPSET_ATTR_PORT) ||\r\n!ip_set_optattr_netorder(tb, IPSET_ATTR_PORT_TO)))\r\nreturn -IPSET_ERR_PROTOCOL;\r\nret = ip_set_get_ipaddr4(tb[IPSET_ATTR_IP], &e.ip);\r\nif (ret)\r\nreturn ret;\r\nret = ip_set_get_extensions(set, tb, &ext);\r\nif (ret)\r\nreturn ret;\r\nret = ip_set_get_ipaddr4(tb[IPSET_ATTR_IP2], &e.ip2);\r\nif (ret)\r\nreturn ret;\r\ne.port = nla_get_be16(tb[IPSET_ATTR_PORT]);\r\nif (tb[IPSET_ATTR_PROTO]) {\r\ne.proto = nla_get_u8(tb[IPSET_ATTR_PROTO]);\r\nwith_ports = ip_set_proto_with_ports(e.proto);\r\nif (e.proto == 0)\r\nreturn -IPSET_ERR_INVALID_PROTO;\r\n} else {\r\nreturn -IPSET_ERR_MISSING_PROTO;\r\n}\r\nif (!(with_ports || e.proto == IPPROTO_ICMP))\r\ne.port = 0;\r\nif (adt == IPSET_TEST ||\r\n!(tb[IPSET_ATTR_IP_TO] || tb[IPSET_ATTR_CIDR] ||\r\ntb[IPSET_ATTR_PORT_TO])) {\r\nret = adtfn(set, &e, &ext, &ext, flags);\r\nreturn ip_set_eexist(ret, flags) ? 0 : ret;\r\n}\r\nip_to = ip = ntohl(e.ip);\r\nif (tb[IPSET_ATTR_IP_TO]) {\r\nret = ip_set_get_hostipaddr4(tb[IPSET_ATTR_IP_TO], &ip_to);\r\nif (ret)\r\nreturn ret;\r\nif (ip > ip_to)\r\nswap(ip, ip_to);\r\n} else if (tb[IPSET_ATTR_CIDR]) {\r\nu8 cidr = nla_get_u8(tb[IPSET_ATTR_CIDR]);\r\nif (!cidr || cidr > HOST_MASK)\r\nreturn -IPSET_ERR_INVALID_CIDR;\r\nip_set_mask_from_to(ip, ip_to, cidr);\r\n}\r\nport_to = port = ntohs(e.port);\r\nif (with_ports && tb[IPSET_ATTR_PORT_TO]) {\r\nport_to = ip_set_get_h16(tb[IPSET_ATTR_PORT_TO]);\r\nif (port > port_to)\r\nswap(port, port_to);\r\n}\r\nif (retried)\r\nip = ntohl(h->next.ip);\r\nfor (; !before(ip_to, ip); ip++) {\r\np = retried && ip == ntohl(h->next.ip) ? ntohs(h->next.port)\r\n: port;\r\nfor (; p <= port_to; p++) {\r\ne.ip = htonl(ip);\r\ne.port = htons(p);\r\nret = adtfn(set, &e, &ext, &ext, flags);\r\nif (ret && !ip_set_eexist(ret, flags))\r\nreturn ret;\r\nret = 0;\r\n}\r\n}\r\nreturn ret;\r\n}\r\nstatic inline bool\r\nhash_ipportip6_data_equal(const struct hash_ipportip6_elem *ip1,\r\nconst struct hash_ipportip6_elem *ip2,\r\nu32 *multi)\r\n{\r\nreturn ipv6_addr_equal(&ip1->ip.in6, &ip2->ip.in6) &&\r\nipv6_addr_equal(&ip1->ip2.in6, &ip2->ip2.in6) &&\r\nip1->port == ip2->port &&\r\nip1->proto == ip2->proto;\r\n}\r\nstatic bool\r\nhash_ipportip6_data_list(struct sk_buff *skb,\r\nconst struct hash_ipportip6_elem *data)\r\n{\r\nif (nla_put_ipaddr6(skb, IPSET_ATTR_IP, &data->ip.in6) ||\r\nnla_put_ipaddr6(skb, IPSET_ATTR_IP2, &data->ip2.in6) ||\r\nnla_put_net16(skb, IPSET_ATTR_PORT, data->port) ||\r\nnla_put_u8(skb, IPSET_ATTR_PROTO, data->proto))\r\ngoto nla_put_failure;\r\nreturn false;\r\nnla_put_failure:\r\nreturn true;\r\n}\r\nstatic inline void\r\nhash_ipportip6_data_next(struct hash_ipportip4_elem *next,\r\nconst struct hash_ipportip6_elem *d)\r\n{\r\nnext->port = d->port;\r\n}\r\nstatic int\r\nhash_ipportip6_kadt(struct ip_set *set, const struct sk_buff *skb,\r\nconst struct xt_action_param *par,\r\nenum ipset_adt adt, struct ip_set_adt_opt *opt)\r\n{\r\nipset_adtfn adtfn = set->variant->adt[adt];\r\nstruct hash_ipportip6_elem e = { .ip = { .all = { 0 } } };\r\nstruct ip_set_ext ext = IP_SET_INIT_KEXT(skb, opt, set);\r\nif (!ip_set_get_ip6_port(skb, opt->flags & IPSET_DIM_TWO_SRC,\r\n&e.port, &e.proto))\r\nreturn -EINVAL;\r\nip6addrptr(skb, opt->flags & IPSET_DIM_ONE_SRC, &e.ip.in6);\r\nip6addrptr(skb, opt->flags & IPSET_DIM_THREE_SRC, &e.ip2.in6);\r\nreturn adtfn(set, &e, &ext, &opt->ext, opt->cmdflags);\r\n}\r\nstatic int\r\nhash_ipportip6_uadt(struct ip_set *set, struct nlattr *tb[],\r\nenum ipset_adt adt, u32 *lineno, u32 flags, bool retried)\r\n{\r\nconst struct hash_ipportip *h = set->data;\r\nipset_adtfn adtfn = set->variant->adt[adt];\r\nstruct hash_ipportip6_elem e = { .ip = { .all = { 0 } } };\r\nstruct ip_set_ext ext = IP_SET_INIT_UEXT(set);\r\nu32 port, port_to;\r\nbool with_ports = false;\r\nint ret;\r\nif (tb[IPSET_ATTR_LINENO])\r\n*lineno = nla_get_u32(tb[IPSET_ATTR_LINENO]);\r\nif (unlikely(!tb[IPSET_ATTR_IP] || !tb[IPSET_ATTR_IP2] ||\r\n!ip_set_attr_netorder(tb, IPSET_ATTR_PORT) ||\r\n!ip_set_optattr_netorder(tb, IPSET_ATTR_PORT_TO)))\r\nreturn -IPSET_ERR_PROTOCOL;\r\nif (unlikely(tb[IPSET_ATTR_IP_TO]))\r\nreturn -IPSET_ERR_HASH_RANGE_UNSUPPORTED;\r\nif (unlikely(tb[IPSET_ATTR_CIDR])) {\r\nu8 cidr = nla_get_u8(tb[IPSET_ATTR_CIDR]);\r\nif (cidr != HOST_MASK)\r\nreturn -IPSET_ERR_INVALID_CIDR;\r\n}\r\nret = ip_set_get_ipaddr6(tb[IPSET_ATTR_IP], &e.ip);\r\nif (ret)\r\nreturn ret;\r\nret = ip_set_get_extensions(set, tb, &ext);\r\nif (ret)\r\nreturn ret;\r\nret = ip_set_get_ipaddr6(tb[IPSET_ATTR_IP2], &e.ip2);\r\nif (ret)\r\nreturn ret;\r\ne.port = nla_get_be16(tb[IPSET_ATTR_PORT]);\r\nif (tb[IPSET_ATTR_PROTO]) {\r\ne.proto = nla_get_u8(tb[IPSET_ATTR_PROTO]);\r\nwith_ports = ip_set_proto_with_ports(e.proto);\r\nif (e.proto == 0)\r\nreturn -IPSET_ERR_INVALID_PROTO;\r\n} else {\r\nreturn -IPSET_ERR_MISSING_PROTO;\r\n}\r\nif (!(with_ports || e.proto == IPPROTO_ICMPV6))\r\ne.port = 0;\r\nif (adt == IPSET_TEST || !with_ports || !tb[IPSET_ATTR_PORT_TO]) {\r\nret = adtfn(set, &e, &ext, &ext, flags);\r\nreturn ip_set_eexist(ret, flags) ? 0 : ret;\r\n}\r\nport = ntohs(e.port);\r\nport_to = ip_set_get_h16(tb[IPSET_ATTR_PORT_TO]);\r\nif (port > port_to)\r\nswap(port, port_to);\r\nif (retried)\r\nport = ntohs(h->next.port);\r\nfor (; port <= port_to; port++) {\r\ne.port = htons(port);\r\nret = adtfn(set, &e, &ext, &ext, flags);\r\nif (ret && !ip_set_eexist(ret, flags))\r\nreturn ret;\r\nret = 0;\r\n}\r\nreturn ret;\r\n}\r\nstatic int __init\r\nhash_ipportip_init(void)\r\n{\r\nreturn ip_set_type_register(&hash_ipportip_type);\r\n}\r\nstatic void __exit\r\nhash_ipportip_fini(void)\r\n{\r\nrcu_barrier();\r\nip_set_type_unregister(&hash_ipportip_type);\r\n}
