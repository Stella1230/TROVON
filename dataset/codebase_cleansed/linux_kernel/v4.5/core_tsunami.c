static int\r\nmk_conf_addr(struct pci_bus *pbus, unsigned int device_fn, int where,\r\nunsigned long *pci_addr, unsigned char *type1)\r\n{\r\nstruct pci_controller *hose = pbus->sysdata;\r\nunsigned long addr;\r\nu8 bus = pbus->number;\r\nDBG_CFG(("mk_conf_addr(bus=%d ,device_fn=0x%x, where=0x%x, "\r\n"pci_addr=0x%p, type1=0x%p)\n",\r\nbus, device_fn, where, pci_addr, type1));\r\nif (!pbus->parent)\r\nbus = 0;\r\n*type1 = (bus != 0);\r\naddr = (bus << 16) | (device_fn << 8) | where;\r\naddr |= hose->config_space_base;\r\n*pci_addr = addr;\r\nDBG_CFG(("mk_conf_addr: returning pci_addr 0x%lx\n", addr));\r\nreturn 0;\r\n}\r\nstatic int\r\ntsunami_read_config(struct pci_bus *bus, unsigned int devfn, int where,\r\nint size, u32 *value)\r\n{\r\nunsigned long addr;\r\nunsigned char type1;\r\nif (mk_conf_addr(bus, devfn, where, &addr, &type1))\r\nreturn PCIBIOS_DEVICE_NOT_FOUND;\r\nswitch (size) {\r\ncase 1:\r\n*value = __kernel_ldbu(*(vucp)addr);\r\nbreak;\r\ncase 2:\r\n*value = __kernel_ldwu(*(vusp)addr);\r\nbreak;\r\ncase 4:\r\n*value = *(vuip)addr;\r\nbreak;\r\n}\r\nreturn PCIBIOS_SUCCESSFUL;\r\n}\r\nstatic int\r\ntsunami_write_config(struct pci_bus *bus, unsigned int devfn, int where,\r\nint size, u32 value)\r\n{\r\nunsigned long addr;\r\nunsigned char type1;\r\nif (mk_conf_addr(bus, devfn, where, &addr, &type1))\r\nreturn PCIBIOS_DEVICE_NOT_FOUND;\r\nswitch (size) {\r\ncase 1:\r\n__kernel_stb(value, *(vucp)addr);\r\nmb();\r\n__kernel_ldbu(*(vucp)addr);\r\nbreak;\r\ncase 2:\r\n__kernel_stw(value, *(vusp)addr);\r\nmb();\r\n__kernel_ldwu(*(vusp)addr);\r\nbreak;\r\ncase 4:\r\n*(vuip)addr = value;\r\nmb();\r\n*(vuip)addr;\r\nbreak;\r\n}\r\nreturn PCIBIOS_SUCCESSFUL;\r\n}\r\nvoid\r\ntsunami_pci_tbi(struct pci_controller *hose, dma_addr_t start, dma_addr_t end)\r\n{\r\ntsunami_pchip *pchip = hose->index ? TSUNAMI_pchip1 : TSUNAMI_pchip0;\r\nvolatile unsigned long *csr;\r\nunsigned long value;\r\ncsr = &pchip->tlbia.csr;\r\nif (((start ^ end) & 0xffff0000) == 0)\r\ncsr = &pchip->tlbiv.csr;\r\nvalue = (start & 0xffff0000) >> 12;\r\n*csr = value;\r\nmb();\r\n*csr;\r\n}\r\nstatic long __init\r\ntsunami_probe_read(volatile unsigned long *vaddr)\r\n{\r\nlong dont_care, probe_result;\r\nint cpu = smp_processor_id();\r\nint s = swpipl(IPL_MCHECK - 1);\r\nmcheck_taken(cpu) = 0;\r\nmcheck_expected(cpu) = 1;\r\nmb();\r\ndont_care = *vaddr;\r\ndraina();\r\nmcheck_expected(cpu) = 0;\r\nprobe_result = !mcheck_taken(cpu);\r\nmcheck_taken(cpu) = 0;\r\nsetipl(s);\r\nprintk("dont_care == 0x%lx\n", dont_care);\r\nreturn probe_result;\r\n}\r\nstatic long __init\r\ntsunami_probe_write(volatile unsigned long *vaddr)\r\n{\r\nlong true_contents, probe_result = 1;\r\nTSUNAMI_cchip->misc.csr |= (1L << 28);\r\ntrue_contents = *vaddr;\r\n*vaddr = 0;\r\ndraina();\r\nif (TSUNAMI_cchip->misc.csr & (1L << 28)) {\r\nint source = (TSUNAMI_cchip->misc.csr >> 29) & 7;\r\nTSUNAMI_cchip->misc.csr |= (1L << 28);\r\nprobe_result = 0;\r\nprintk("tsunami_probe_write: unit %d at 0x%016lx\n", source,\r\n(unsigned long)vaddr);\r\n}\r\nif (probe_result)\r\n*vaddr = true_contents;\r\nreturn probe_result;\r\n}\r\nstatic void __init\r\ntsunami_init_one_pchip(tsunami_pchip *pchip, int index)\r\n{\r\nstruct pci_controller *hose;\r\nif (tsunami_probe_read(&pchip->pctl.csr) == 0)\r\nreturn;\r\nhose = alloc_pci_controller();\r\nif (index == 0)\r\npci_isa_hose = hose;\r\nhose->io_space = alloc_resource();\r\nhose->mem_space = alloc_resource();\r\nhose->sparse_mem_base = 0;\r\nhose->sparse_io_base = 0;\r\nhose->dense_mem_base\r\n= (TSUNAMI_MEM(index) & 0xffffffffffL) | 0x80000000000L;\r\nhose->dense_io_base\r\n= (TSUNAMI_IO(index) & 0xffffffffffL) | 0x80000000000L;\r\nhose->config_space_base = TSUNAMI_CONF(index);\r\nhose->index = index;\r\nhose->io_space->start = TSUNAMI_IO(index) - TSUNAMI_IO_BIAS;\r\nhose->io_space->end = hose->io_space->start + TSUNAMI_IO_SPACE - 1;\r\nhose->io_space->name = pci_io_names[index];\r\nhose->io_space->flags = IORESOURCE_IO;\r\nhose->mem_space->start = TSUNAMI_MEM(index) - TSUNAMI_MEM_BIAS;\r\nhose->mem_space->end = hose->mem_space->start + 0xffffffff;\r\nhose->mem_space->name = pci_mem_names[index];\r\nhose->mem_space->flags = IORESOURCE_MEM;\r\nif (request_resource(&ioport_resource, hose->io_space) < 0)\r\nprintk(KERN_ERR "Failed to request IO on hose %d\n", index);\r\nif (request_resource(&iomem_resource, hose->mem_space) < 0)\r\nprintk(KERN_ERR "Failed to request MEM on hose %d\n", index);\r\nsaved_config[index].wsba[0] = pchip->wsba[0].csr;\r\nsaved_config[index].wsm[0] = pchip->wsm[0].csr;\r\nsaved_config[index].tba[0] = pchip->tba[0].csr;\r\nsaved_config[index].wsba[1] = pchip->wsba[1].csr;\r\nsaved_config[index].wsm[1] = pchip->wsm[1].csr;\r\nsaved_config[index].tba[1] = pchip->tba[1].csr;\r\nsaved_config[index].wsba[2] = pchip->wsba[2].csr;\r\nsaved_config[index].wsm[2] = pchip->wsm[2].csr;\r\nsaved_config[index].tba[2] = pchip->tba[2].csr;\r\nsaved_config[index].wsba[3] = pchip->wsba[3].csr;\r\nsaved_config[index].wsm[3] = pchip->wsm[3].csr;\r\nsaved_config[index].tba[3] = pchip->tba[3].csr;\r\nhose->sg_isa = iommu_arena_new(hose, 0x00800000, 0x00800000, 0);\r\nhose->sg_isa->align_entry = 4;\r\nhose->sg_pci = iommu_arena_new(hose, 0x40000000,\r\nsize_for_memory(0x40000000), 0);\r\nhose->sg_pci->align_entry = 4;\r\n__direct_map_base = 0x80000000;\r\n__direct_map_size = 0x80000000;\r\npchip->wsba[0].csr = hose->sg_isa->dma_base | 3;\r\npchip->wsm[0].csr = (hose->sg_isa->size - 1) & 0xfff00000;\r\npchip->tba[0].csr = virt_to_phys(hose->sg_isa->ptes);\r\npchip->wsba[1].csr = hose->sg_pci->dma_base | 3;\r\npchip->wsm[1].csr = (hose->sg_pci->size - 1) & 0xfff00000;\r\npchip->tba[1].csr = virt_to_phys(hose->sg_pci->ptes);\r\npchip->wsba[2].csr = 0x80000000 | 1;\r\npchip->wsm[2].csr = (0x80000000 - 1) & 0xfff00000;\r\npchip->tba[2].csr = 0;\r\npchip->wsba[3].csr = 0;\r\npchip->pctl.csr |= pctl_m_mwin;\r\ntsunami_pci_tbi(hose, 0, -1);\r\n}\r\nvoid __iomem *\r\ntsunami_ioportmap(unsigned long addr)\r\n{\r\nFIXUP_IOADDR_VGA(addr);\r\nreturn (void __iomem *)(addr + TSUNAMI_IO_BIAS);\r\n}\r\nvoid __iomem *\r\ntsunami_ioremap(unsigned long addr, unsigned long size)\r\n{\r\nFIXUP_MEMADDR_VGA(addr);\r\nreturn (void __iomem *)(addr + TSUNAMI_MEM_BIAS);\r\n}\r\nvoid __init\r\ntsunami_init_arch(void)\r\n{\r\n#ifdef NXM_MACHINE_CHECKS_ON_TSUNAMI\r\nunsigned long tmp;\r\nwrent(entInt, 0);\r\ntmp = (unsigned long)(TSUNAMI_cchip - 1);\r\nprintk("%s: probing bogus address: 0x%016lx\n", __func__, bogus_addr);\r\nprintk("\tprobe %s\n",\r\ntsunami_probe_write((unsigned long *)bogus_addr)\r\n? "succeeded" : "failed");\r\n#endif\r\n#if 0\r\nprintk("%s: CChip registers:\n", __func__);\r\nprintk("%s: CSR_CSC 0x%lx\n", __func__, TSUNAMI_cchip->csc.csr);\r\nprintk("%s: CSR_MTR 0x%lx\n", __func__, TSUNAMI_cchip.mtr.csr);\r\nprintk("%s: CSR_MISC 0x%lx\n", __func__, TSUNAMI_cchip->misc.csr);\r\nprintk("%s: CSR_DIM0 0x%lx\n", __func__, TSUNAMI_cchip->dim0.csr);\r\nprintk("%s: CSR_DIM1 0x%lx\n", __func__, TSUNAMI_cchip->dim1.csr);\r\nprintk("%s: CSR_DIR0 0x%lx\n", __func__, TSUNAMI_cchip->dir0.csr);\r\nprintk("%s: CSR_DIR1 0x%lx\n", __func__, TSUNAMI_cchip->dir1.csr);\r\nprintk("%s: CSR_DRIR 0x%lx\n", __func__, TSUNAMI_cchip->drir.csr);\r\nprintk("%s: DChip registers:\n");\r\nprintk("%s: CSR_DSC 0x%lx\n", __func__, TSUNAMI_dchip->dsc.csr);\r\nprintk("%s: CSR_STR 0x%lx\n", __func__, TSUNAMI_dchip->str.csr);\r\nprintk("%s: CSR_DREV 0x%lx\n", __func__, TSUNAMI_dchip->drev.csr);\r\n#endif\r\nioport_resource.end = ~0UL;\r\ntsunami_init_one_pchip(TSUNAMI_pchip0, 0);\r\nif (TSUNAMI_cchip->csc.csr & 1L<<14)\r\ntsunami_init_one_pchip(TSUNAMI_pchip1, 1);\r\nfind_console_vga_hose();\r\n}\r\nstatic void\r\ntsunami_kill_one_pchip(tsunami_pchip *pchip, int index)\r\n{\r\npchip->wsba[0].csr = saved_config[index].wsba[0];\r\npchip->wsm[0].csr = saved_config[index].wsm[0];\r\npchip->tba[0].csr = saved_config[index].tba[0];\r\npchip->wsba[1].csr = saved_config[index].wsba[1];\r\npchip->wsm[1].csr = saved_config[index].wsm[1];\r\npchip->tba[1].csr = saved_config[index].tba[1];\r\npchip->wsba[2].csr = saved_config[index].wsba[2];\r\npchip->wsm[2].csr = saved_config[index].wsm[2];\r\npchip->tba[2].csr = saved_config[index].tba[2];\r\npchip->wsba[3].csr = saved_config[index].wsba[3];\r\npchip->wsm[3].csr = saved_config[index].wsm[3];\r\npchip->tba[3].csr = saved_config[index].tba[3];\r\n}\r\nvoid\r\ntsunami_kill_arch(int mode)\r\n{\r\ntsunami_kill_one_pchip(TSUNAMI_pchip0, 0);\r\nif (TSUNAMI_cchip->csc.csr & 1L<<14)\r\ntsunami_kill_one_pchip(TSUNAMI_pchip1, 1);\r\n}\r\nstatic inline void\r\ntsunami_pci_clr_err_1(tsunami_pchip *pchip)\r\n{\r\npchip->perror.csr;\r\npchip->perror.csr = 0x040;\r\nmb();\r\npchip->perror.csr;\r\n}\r\nstatic inline void\r\ntsunami_pci_clr_err(void)\r\n{\r\ntsunami_pci_clr_err_1(TSUNAMI_pchip0);\r\nif (TSUNAMI_cchip->csc.csr & 1L<<14)\r\ntsunami_pci_clr_err_1(TSUNAMI_pchip1);\r\n}\r\nvoid\r\ntsunami_machine_check(unsigned long vector, unsigned long la_ptr)\r\n{\r\nmb();\r\nmb();\r\ndraina();\r\ntsunami_pci_clr_err();\r\nwrmces(0x7);\r\nmb();\r\nprocess_mcheck_info(vector, la_ptr, "TSUNAMI",\r\nmcheck_expected(smp_processor_id()));\r\n}
