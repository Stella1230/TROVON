void convert_null_to_semi(char *buf, int len)\r\n{\r\nint i;\r\nfor (i = 0; i < len; i++)\r\nif (buf[i] == '\0')\r\nbuf[i] = ';';\r\n}\r\nstatic int strlen_semi(char *buf)\r\n{\r\nint i = 0;\r\nwhile (buf[i] != '\0') {\r\nif (buf[i] == ';')\r\nreturn i;\r\ni++;\r\n}\r\nreturn -1;\r\n}\r\nint extract_param(\r\nconst char *in_buf,\r\nconst char *pattern,\r\nunsigned int max_length,\r\nchar *out_buf,\r\nunsigned char *type)\r\n{\r\nchar *ptr;\r\nint len;\r\nif (!in_buf || !pattern || !out_buf || !type)\r\nreturn -1;\r\nptr = strstr(in_buf, pattern);\r\nif (!ptr)\r\nreturn -1;\r\nptr = strstr(ptr, "=");\r\nif (!ptr)\r\nreturn -1;\r\nptr += 1;\r\nif (*ptr == '0' && (*(ptr+1) == 'x' || *(ptr+1) == 'X')) {\r\nptr += 2;\r\n*type = HEX;\r\n} else\r\n*type = DECIMAL;\r\nlen = strlen_semi(ptr);\r\nif (len < 0)\r\nreturn -1;\r\nif (len >= max_length) {\r\npr_err("Length of input: %d exceeds max_length:"\r\n" %d\n", len, max_length);\r\nreturn -1;\r\n}\r\nmemcpy(out_buf, ptr, len);\r\nout_buf[len] = '\0';\r\nreturn 0;\r\n}\r\nstatic u32 iscsi_handle_authentication(\r\nstruct iscsi_conn *conn,\r\nchar *in_buf,\r\nchar *out_buf,\r\nint in_length,\r\nint *out_length,\r\nunsigned char *authtype)\r\n{\r\nstruct iscsi_session *sess = conn->sess;\r\nstruct iscsi_node_auth *auth;\r\nstruct iscsi_node_acl *iscsi_nacl;\r\nstruct iscsi_portal_group *iscsi_tpg;\r\nstruct se_node_acl *se_nacl;\r\nif (!sess->sess_ops->SessionType) {\r\nse_nacl = conn->sess->se_sess->se_node_acl;\r\nif (!se_nacl) {\r\npr_err("Unable to locate struct se_node_acl for"\r\n" CHAP auth\n");\r\nreturn -1;\r\n}\r\niscsi_nacl = container_of(se_nacl, struct iscsi_node_acl,\r\nse_node_acl);\r\nif (!iscsi_nacl) {\r\npr_err("Unable to locate struct iscsi_node_acl for"\r\n" CHAP auth\n");\r\nreturn -1;\r\n}\r\nif (se_nacl->dynamic_node_acl) {\r\niscsi_tpg = container_of(se_nacl->se_tpg,\r\nstruct iscsi_portal_group, tpg_se_tpg);\r\nauth = &iscsi_tpg->tpg_demo_auth;\r\n} else {\r\niscsi_nacl = container_of(se_nacl, struct iscsi_node_acl,\r\nse_node_acl);\r\nauth = &iscsi_nacl->node_auth;\r\n}\r\n} else {\r\nauth = &iscsit_global->discovery_acl.node_auth;\r\n}\r\nif (strstr("CHAP", authtype))\r\nstrcpy(conn->sess->auth_type, "CHAP");\r\nelse\r\nstrcpy(conn->sess->auth_type, NONE);\r\nif (strstr("None", authtype))\r\nreturn 1;\r\n#ifdef CANSRP\r\nelse if (strstr("SRP", authtype))\r\nreturn srp_main_loop(conn, auth, in_buf, out_buf,\r\n&in_length, out_length);\r\n#endif\r\nelse if (strstr("CHAP", authtype))\r\nreturn chap_main_loop(conn, auth, in_buf, out_buf,\r\n&in_length, out_length);\r\nelse if (strstr("SPKM1", authtype))\r\nreturn 2;\r\nelse if (strstr("SPKM2", authtype))\r\nreturn 2;\r\nelse if (strstr("KRB5", authtype))\r\nreturn 2;\r\nelse\r\nreturn 2;\r\n}\r\nstatic void iscsi_remove_failed_auth_entry(struct iscsi_conn *conn)\r\n{\r\nkfree(conn->auth_protocol);\r\n}\r\nint iscsi_target_check_login_request(\r\nstruct iscsi_conn *conn,\r\nstruct iscsi_login *login)\r\n{\r\nint req_csg, req_nsg;\r\nu32 payload_length;\r\nstruct iscsi_login_req *login_req;\r\nlogin_req = (struct iscsi_login_req *) login->req;\r\npayload_length = ntoh24(login_req->dlength);\r\nswitch (login_req->opcode & ISCSI_OPCODE_MASK) {\r\ncase ISCSI_OP_LOGIN:\r\nbreak;\r\ndefault:\r\npr_err("Received unknown opcode 0x%02x.\n",\r\nlogin_req->opcode & ISCSI_OPCODE_MASK);\r\niscsit_tx_login_rsp(conn, ISCSI_STATUS_CLS_INITIATOR_ERR,\r\nISCSI_LOGIN_STATUS_INIT_ERR);\r\nreturn -1;\r\n}\r\nif ((login_req->flags & ISCSI_FLAG_LOGIN_CONTINUE) &&\r\n(login_req->flags & ISCSI_FLAG_LOGIN_TRANSIT)) {\r\npr_err("Login request has both ISCSI_FLAG_LOGIN_CONTINUE"\r\n" and ISCSI_FLAG_LOGIN_TRANSIT set, protocol error.\n");\r\niscsit_tx_login_rsp(conn, ISCSI_STATUS_CLS_INITIATOR_ERR,\r\nISCSI_LOGIN_STATUS_INIT_ERR);\r\nreturn -1;\r\n}\r\nreq_csg = ISCSI_LOGIN_CURRENT_STAGE(login_req->flags);\r\nreq_nsg = ISCSI_LOGIN_NEXT_STAGE(login_req->flags);\r\nif (req_csg != login->current_stage) {\r\npr_err("Initiator unexpectedly changed login stage"\r\n" from %d to %d, login failed.\n", login->current_stage,\r\nreq_csg);\r\niscsit_tx_login_rsp(conn, ISCSI_STATUS_CLS_INITIATOR_ERR,\r\nISCSI_LOGIN_STATUS_INIT_ERR);\r\nreturn -1;\r\n}\r\nif ((req_nsg == 2) || (req_csg >= 2) ||\r\n((login_req->flags & ISCSI_FLAG_LOGIN_TRANSIT) &&\r\n(req_nsg <= req_csg))) {\r\npr_err("Illegal login_req->flags Combination, CSG: %d,"\r\n" NSG: %d, ISCSI_FLAG_LOGIN_TRANSIT: %d.\n", req_csg,\r\nreq_nsg, (login_req->flags & ISCSI_FLAG_LOGIN_TRANSIT));\r\niscsit_tx_login_rsp(conn, ISCSI_STATUS_CLS_INITIATOR_ERR,\r\nISCSI_LOGIN_STATUS_INIT_ERR);\r\nreturn -1;\r\n}\r\nif ((login_req->max_version != login->version_max) ||\r\n(login_req->min_version != login->version_min)) {\r\npr_err("Login request changed Version Max/Nin"\r\n" unexpectedly to 0x%02x/0x%02x, protocol error\n",\r\nlogin_req->max_version, login_req->min_version);\r\niscsit_tx_login_rsp(conn, ISCSI_STATUS_CLS_INITIATOR_ERR,\r\nISCSI_LOGIN_STATUS_INIT_ERR);\r\nreturn -1;\r\n}\r\nif (memcmp(login_req->isid, login->isid, 6) != 0) {\r\npr_err("Login request changed ISID unexpectedly,"\r\n" protocol error.\n");\r\niscsit_tx_login_rsp(conn, ISCSI_STATUS_CLS_INITIATOR_ERR,\r\nISCSI_LOGIN_STATUS_INIT_ERR);\r\nreturn -1;\r\n}\r\nif (login_req->itt != login->init_task_tag) {\r\npr_err("Login request changed ITT unexpectedly to"\r\n" 0x%08x, protocol error.\n", login_req->itt);\r\niscsit_tx_login_rsp(conn, ISCSI_STATUS_CLS_INITIATOR_ERR,\r\nISCSI_LOGIN_STATUS_INIT_ERR);\r\nreturn -1;\r\n}\r\nif (payload_length > MAX_KEY_VALUE_PAIRS) {\r\npr_err("Login request payload exceeds default"\r\n" MaxRecvDataSegmentLength: %u, protocol error.\n",\r\nMAX_KEY_VALUE_PAIRS);\r\nreturn -1;\r\n}\r\nreturn 0;\r\n}\r\nstatic int iscsi_target_check_first_request(\r\nstruct iscsi_conn *conn,\r\nstruct iscsi_login *login)\r\n{\r\nstruct iscsi_param *param = NULL;\r\nstruct se_node_acl *se_nacl;\r\nlogin->first_request = 0;\r\nlist_for_each_entry(param, &conn->param_list->param_list, p_list) {\r\nif (!strncmp(param->name, SESSIONTYPE, 11)) {\r\nif (!IS_PSTATE_ACCEPTOR(param)) {\r\npr_err("SessionType key not received"\r\n" in first login request.\n");\r\niscsit_tx_login_rsp(conn, ISCSI_STATUS_CLS_INITIATOR_ERR,\r\nISCSI_LOGIN_STATUS_MISSING_FIELDS);\r\nreturn -1;\r\n}\r\nif (!strncmp(param->value, DISCOVERY, 9))\r\nreturn 0;\r\n}\r\nif (!strncmp(param->name, INITIATORNAME, 13)) {\r\nif (!IS_PSTATE_ACCEPTOR(param)) {\r\nif (!login->leading_connection)\r\ncontinue;\r\npr_err("InitiatorName key not received"\r\n" in first login request.\n");\r\niscsit_tx_login_rsp(conn, ISCSI_STATUS_CLS_INITIATOR_ERR,\r\nISCSI_LOGIN_STATUS_MISSING_FIELDS);\r\nreturn -1;\r\n}\r\nif (!login->leading_connection) {\r\nse_nacl = conn->sess->se_sess->se_node_acl;\r\nif (!se_nacl) {\r\npr_err("Unable to locate"\r\n" struct se_node_acl\n");\r\niscsit_tx_login_rsp(conn,\r\nISCSI_STATUS_CLS_INITIATOR_ERR,\r\nISCSI_LOGIN_STATUS_TGT_NOT_FOUND);\r\nreturn -1;\r\n}\r\nif (strcmp(param->value,\r\nse_nacl->initiatorname)) {\r\npr_err("Incorrect"\r\n" InitiatorName: %s for this"\r\n" iSCSI Initiator Node.\n",\r\nparam->value);\r\niscsit_tx_login_rsp(conn,\r\nISCSI_STATUS_CLS_INITIATOR_ERR,\r\nISCSI_LOGIN_STATUS_TGT_NOT_FOUND);\r\nreturn -1;\r\n}\r\n}\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int iscsi_target_do_tx_login_io(struct iscsi_conn *conn, struct iscsi_login *login)\r\n{\r\nu32 padding = 0;\r\nstruct iscsi_login_rsp *login_rsp;\r\nlogin_rsp = (struct iscsi_login_rsp *) login->rsp;\r\nlogin_rsp->opcode = ISCSI_OP_LOGIN_RSP;\r\nhton24(login_rsp->dlength, login->rsp_length);\r\nmemcpy(login_rsp->isid, login->isid, 6);\r\nlogin_rsp->tsih = cpu_to_be16(login->tsih);\r\nlogin_rsp->itt = login->init_task_tag;\r\nlogin_rsp->statsn = cpu_to_be32(conn->stat_sn++);\r\nlogin_rsp->exp_cmdsn = cpu_to_be32(conn->sess->exp_cmd_sn);\r\nlogin_rsp->max_cmdsn = cpu_to_be32((u32) atomic_read(&conn->sess->max_cmd_sn));\r\npr_debug("Sending Login Response, Flags: 0x%02x, ITT: 0x%08x,"\r\n" ExpCmdSN; 0x%08x, MaxCmdSN: 0x%08x, StatSN: 0x%08x, Length:"\r\n" %u\n", login_rsp->flags, (__force u32)login_rsp->itt,\r\nntohl(login_rsp->exp_cmdsn), ntohl(login_rsp->max_cmdsn),\r\nntohl(login_rsp->statsn), login->rsp_length);\r\npadding = ((-login->rsp_length) & 3);\r\nif (login->login_complete) {\r\nint rc = iscsit_start_kthreads(conn);\r\nif (rc) {\r\niscsit_tx_login_rsp(conn, ISCSI_STATUS_CLS_TARGET_ERR,\r\nISCSI_LOGIN_STATUS_NO_RESOURCES);\r\nreturn -1;\r\n}\r\n}\r\nif (conn->conn_transport->iscsit_put_login_tx(conn, login,\r\nlogin->rsp_length + padding) < 0)\r\ngoto err;\r\nlogin->rsp_length = 0;\r\nreturn 0;\r\nerr:\r\nif (login->login_complete) {\r\nif (conn->rx_thread && conn->rx_thread_active) {\r\nsend_sig(SIGINT, conn->rx_thread, 1);\r\ncomplete(&conn->rx_login_comp);\r\nkthread_stop(conn->rx_thread);\r\n}\r\nif (conn->tx_thread && conn->tx_thread_active) {\r\nsend_sig(SIGINT, conn->tx_thread, 1);\r\nkthread_stop(conn->tx_thread);\r\n}\r\nspin_lock(&iscsit_global->ts_bitmap_lock);\r\nbitmap_release_region(iscsit_global->ts_bitmap, conn->bitmap_id,\r\nget_order(1));\r\nspin_unlock(&iscsit_global->ts_bitmap_lock);\r\n}\r\nreturn -1;\r\n}\r\nstatic void iscsi_target_sk_data_ready(struct sock *sk)\r\n{\r\nstruct iscsi_conn *conn = sk->sk_user_data;\r\nbool rc;\r\npr_debug("Entering iscsi_target_sk_data_ready: conn: %p\n", conn);\r\nwrite_lock_bh(&sk->sk_callback_lock);\r\nif (!sk->sk_user_data) {\r\nwrite_unlock_bh(&sk->sk_callback_lock);\r\nreturn;\r\n}\r\nif (!test_bit(LOGIN_FLAGS_READY, &conn->login_flags)) {\r\nwrite_unlock_bh(&sk->sk_callback_lock);\r\npr_debug("Got LOGIN_FLAGS_READY=0, conn: %p >>>>\n", conn);\r\nreturn;\r\n}\r\nif (test_bit(LOGIN_FLAGS_CLOSED, &conn->login_flags)) {\r\nwrite_unlock_bh(&sk->sk_callback_lock);\r\npr_debug("Got LOGIN_FLAGS_CLOSED=1, conn: %p >>>>\n", conn);\r\nreturn;\r\n}\r\nif (test_and_set_bit(LOGIN_FLAGS_READ_ACTIVE, &conn->login_flags)) {\r\nwrite_unlock_bh(&sk->sk_callback_lock);\r\npr_debug("Got LOGIN_FLAGS_READ_ACTIVE=1, conn: %p >>>>\n", conn);\r\nreturn;\r\n}\r\nrc = schedule_delayed_work(&conn->login_work, 0);\r\nif (!rc) {\r\npr_debug("iscsi_target_sk_data_ready, schedule_delayed_work"\r\n" got false\n");\r\n}\r\nwrite_unlock_bh(&sk->sk_callback_lock);\r\n}\r\nstatic void iscsi_target_set_sock_callbacks(struct iscsi_conn *conn)\r\n{\r\nstruct sock *sk;\r\nif (!conn->sock)\r\nreturn;\r\nsk = conn->sock->sk;\r\npr_debug("Entering iscsi_target_set_sock_callbacks: conn: %p\n", conn);\r\nwrite_lock_bh(&sk->sk_callback_lock);\r\nsk->sk_user_data = conn;\r\nconn->orig_data_ready = sk->sk_data_ready;\r\nconn->orig_state_change = sk->sk_state_change;\r\nsk->sk_data_ready = iscsi_target_sk_data_ready;\r\nsk->sk_state_change = iscsi_target_sk_state_change;\r\nwrite_unlock_bh(&sk->sk_callback_lock);\r\nsk->sk_sndtimeo = TA_LOGIN_TIMEOUT * HZ;\r\nsk->sk_rcvtimeo = TA_LOGIN_TIMEOUT * HZ;\r\n}\r\nstatic void iscsi_target_restore_sock_callbacks(struct iscsi_conn *conn)\r\n{\r\nstruct sock *sk;\r\nif (!conn->sock)\r\nreturn;\r\nsk = conn->sock->sk;\r\npr_debug("Entering iscsi_target_restore_sock_callbacks: conn: %p\n", conn);\r\nwrite_lock_bh(&sk->sk_callback_lock);\r\nif (!sk->sk_user_data) {\r\nwrite_unlock_bh(&sk->sk_callback_lock);\r\nreturn;\r\n}\r\nsk->sk_user_data = NULL;\r\nsk->sk_data_ready = conn->orig_data_ready;\r\nsk->sk_state_change = conn->orig_state_change;\r\nwrite_unlock_bh(&sk->sk_callback_lock);\r\nsk->sk_sndtimeo = MAX_SCHEDULE_TIMEOUT;\r\nsk->sk_rcvtimeo = MAX_SCHEDULE_TIMEOUT;\r\n}\r\nstatic bool iscsi_target_sk_state_check(struct sock *sk)\r\n{\r\nif (sk->sk_state == TCP_CLOSE_WAIT || sk->sk_state == TCP_CLOSE) {\r\npr_debug("iscsi_target_sk_state_check: TCP_CLOSE_WAIT|TCP_CLOSE,"\r\n"returning FALSE\n");\r\nreturn false;\r\n}\r\nreturn true;\r\n}\r\nstatic void iscsi_target_login_drop(struct iscsi_conn *conn, struct iscsi_login *login)\r\n{\r\nstruct iscsi_np *np = login->np;\r\nbool zero_tsih = login->zero_tsih;\r\niscsi_remove_failed_auth_entry(conn);\r\niscsi_target_nego_release(conn);\r\niscsi_target_login_sess_out(conn, np, zero_tsih, true);\r\n}\r\nstatic void iscsi_target_login_timeout(unsigned long data)\r\n{\r\nstruct iscsi_conn *conn = (struct iscsi_conn *)data;\r\npr_debug("Entering iscsi_target_login_timeout >>>>>>>>>>>>>>>>>>>\n");\r\nif (conn->login_kworker) {\r\npr_debug("Sending SIGINT to conn->login_kworker %s/%d\n",\r\nconn->login_kworker->comm, conn->login_kworker->pid);\r\nsend_sig(SIGINT, conn->login_kworker, 1);\r\n}\r\n}\r\nstatic void iscsi_target_do_login_rx(struct work_struct *work)\r\n{\r\nstruct iscsi_conn *conn = container_of(work,\r\nstruct iscsi_conn, login_work.work);\r\nstruct iscsi_login *login = conn->login;\r\nstruct iscsi_np *np = login->np;\r\nstruct iscsi_portal_group *tpg = conn->tpg;\r\nstruct iscsi_tpg_np *tpg_np = conn->tpg_np;\r\nstruct timer_list login_timer;\r\nint rc, zero_tsih = login->zero_tsih;\r\nbool state;\r\npr_debug("entering iscsi_target_do_login_rx, conn: %p, %s:%d\n",\r\nconn, current->comm, current->pid);\r\nspin_lock(&tpg->tpg_state_lock);\r\nstate = (tpg->tpg_state == TPG_STATE_ACTIVE);\r\nspin_unlock(&tpg->tpg_state_lock);\r\nif (!state) {\r\npr_debug("iscsi_target_do_login_rx: tpg_state != TPG_STATE_ACTIVE\n");\r\niscsi_target_restore_sock_callbacks(conn);\r\niscsi_target_login_drop(conn, login);\r\niscsit_deaccess_np(np, tpg, tpg_np);\r\nreturn;\r\n}\r\nif (conn->sock) {\r\nstruct sock *sk = conn->sock->sk;\r\nread_lock_bh(&sk->sk_callback_lock);\r\nstate = iscsi_target_sk_state_check(sk);\r\nread_unlock_bh(&sk->sk_callback_lock);\r\nif (!state) {\r\npr_debug("iscsi_target_do_login_rx, TCP state CLOSE\n");\r\niscsi_target_restore_sock_callbacks(conn);\r\niscsi_target_login_drop(conn, login);\r\niscsit_deaccess_np(np, tpg, tpg_np);\r\nreturn;\r\n}\r\n}\r\nconn->login_kworker = current;\r\nallow_signal(SIGINT);\r\ninit_timer(&login_timer);\r\nlogin_timer.expires = (get_jiffies_64() + TA_LOGIN_TIMEOUT * HZ);\r\nlogin_timer.data = (unsigned long)conn;\r\nlogin_timer.function = iscsi_target_login_timeout;\r\nadd_timer(&login_timer);\r\npr_debug("Starting login_timer for %s/%d\n", current->comm, current->pid);\r\nrc = conn->conn_transport->iscsit_get_login_rx(conn, login);\r\ndel_timer_sync(&login_timer);\r\nflush_signals(current);\r\nconn->login_kworker = NULL;\r\nif (rc < 0) {\r\niscsi_target_restore_sock_callbacks(conn);\r\niscsi_target_login_drop(conn, login);\r\niscsit_deaccess_np(np, tpg, tpg_np);\r\nreturn;\r\n}\r\npr_debug("iscsi_target_do_login_rx after rx_login_io, %p, %s:%d\n",\r\nconn, current->comm, current->pid);\r\nrc = iscsi_target_do_login(conn, login);\r\nif (rc < 0) {\r\niscsi_target_restore_sock_callbacks(conn);\r\niscsi_target_login_drop(conn, login);\r\niscsit_deaccess_np(np, tpg, tpg_np);\r\n} else if (!rc) {\r\nif (conn->sock) {\r\nstruct sock *sk = conn->sock->sk;\r\nwrite_lock_bh(&sk->sk_callback_lock);\r\nclear_bit(LOGIN_FLAGS_READ_ACTIVE, &conn->login_flags);\r\nwrite_unlock_bh(&sk->sk_callback_lock);\r\n}\r\n} else if (rc == 1) {\r\niscsi_target_nego_release(conn);\r\niscsi_post_login_handler(np, conn, zero_tsih);\r\niscsit_deaccess_np(np, tpg, tpg_np);\r\n}\r\n}\r\nstatic void iscsi_target_do_cleanup(struct work_struct *work)\r\n{\r\nstruct iscsi_conn *conn = container_of(work,\r\nstruct iscsi_conn, login_cleanup_work.work);\r\nstruct sock *sk = conn->sock->sk;\r\nstruct iscsi_login *login = conn->login;\r\nstruct iscsi_np *np = login->np;\r\nstruct iscsi_portal_group *tpg = conn->tpg;\r\nstruct iscsi_tpg_np *tpg_np = conn->tpg_np;\r\npr_debug("Entering iscsi_target_do_cleanup\n");\r\ncancel_delayed_work_sync(&conn->login_work);\r\nconn->orig_state_change(sk);\r\niscsi_target_restore_sock_callbacks(conn);\r\niscsi_target_login_drop(conn, login);\r\niscsit_deaccess_np(np, tpg, tpg_np);\r\npr_debug("iscsi_target_do_cleanup done()\n");\r\n}\r\nstatic void iscsi_target_sk_state_change(struct sock *sk)\r\n{\r\nstruct iscsi_conn *conn;\r\nvoid (*orig_state_change)(struct sock *);\r\nbool state;\r\npr_debug("Entering iscsi_target_sk_state_change\n");\r\nwrite_lock_bh(&sk->sk_callback_lock);\r\nconn = sk->sk_user_data;\r\nif (!conn) {\r\nwrite_unlock_bh(&sk->sk_callback_lock);\r\nreturn;\r\n}\r\norig_state_change = conn->orig_state_change;\r\nif (!test_bit(LOGIN_FLAGS_READY, &conn->login_flags)) {\r\npr_debug("Got LOGIN_FLAGS_READY=0 sk_state_change conn: %p\n",\r\nconn);\r\nwrite_unlock_bh(&sk->sk_callback_lock);\r\norig_state_change(sk);\r\nreturn;\r\n}\r\nif (test_bit(LOGIN_FLAGS_READ_ACTIVE, &conn->login_flags)) {\r\npr_debug("Got LOGIN_FLAGS_READ_ACTIVE=1 sk_state_change"\r\n" conn: %p\n", conn);\r\nwrite_unlock_bh(&sk->sk_callback_lock);\r\norig_state_change(sk);\r\nreturn;\r\n}\r\nif (test_and_set_bit(LOGIN_FLAGS_CLOSED, &conn->login_flags)) {\r\npr_debug("Got LOGIN_FLAGS_CLOSED=1 sk_state_change conn: %p\n",\r\nconn);\r\nwrite_unlock_bh(&sk->sk_callback_lock);\r\norig_state_change(sk);\r\nreturn;\r\n}\r\nstate = iscsi_target_sk_state_check(sk);\r\nwrite_unlock_bh(&sk->sk_callback_lock);\r\npr_debug("iscsi_target_sk_state_change: state: %d\n", state);\r\nif (!state) {\r\npr_debug("iscsi_target_sk_state_change got failed state\n");\r\nschedule_delayed_work(&conn->login_cleanup_work, 0);\r\nreturn;\r\n}\r\norig_state_change(sk);\r\n}\r\nstatic int iscsi_target_check_for_existing_instances(\r\nstruct iscsi_conn *conn,\r\nstruct iscsi_login *login)\r\n{\r\nif (login->checked_for_existing)\r\nreturn 0;\r\nlogin->checked_for_existing = 1;\r\nif (!login->tsih)\r\nreturn iscsi_check_for_session_reinstatement(conn);\r\nelse\r\nreturn iscsi_login_post_auth_non_zero_tsih(conn, login->cid,\r\nlogin->initial_exp_statsn);\r\n}\r\nstatic int iscsi_target_do_authentication(\r\nstruct iscsi_conn *conn,\r\nstruct iscsi_login *login)\r\n{\r\nint authret;\r\nu32 payload_length;\r\nstruct iscsi_param *param;\r\nstruct iscsi_login_req *login_req;\r\nstruct iscsi_login_rsp *login_rsp;\r\nlogin_req = (struct iscsi_login_req *) login->req;\r\nlogin_rsp = (struct iscsi_login_rsp *) login->rsp;\r\npayload_length = ntoh24(login_req->dlength);\r\nparam = iscsi_find_param_from_key(AUTHMETHOD, conn->param_list);\r\nif (!param)\r\nreturn -1;\r\nauthret = iscsi_handle_authentication(\r\nconn,\r\nlogin->req_buf,\r\nlogin->rsp_buf,\r\npayload_length,\r\n&login->rsp_length,\r\nparam->value);\r\nswitch (authret) {\r\ncase 0:\r\npr_debug("Received OK response"\r\n" from LIO Authentication, continuing.\n");\r\nbreak;\r\ncase 1:\r\npr_debug("iSCSI security negotiation"\r\n" completed successfully.\n");\r\nlogin->auth_complete = 1;\r\nif ((login_req->flags & ISCSI_FLAG_LOGIN_NEXT_STAGE1) &&\r\n(login_req->flags & ISCSI_FLAG_LOGIN_TRANSIT)) {\r\nlogin_rsp->flags |= (ISCSI_FLAG_LOGIN_NEXT_STAGE1 |\r\nISCSI_FLAG_LOGIN_TRANSIT);\r\nlogin->current_stage = 1;\r\n}\r\nreturn iscsi_target_check_for_existing_instances(\r\nconn, login);\r\ncase 2:\r\npr_err("Security negotiation"\r\n" failed.\n");\r\niscsit_tx_login_rsp(conn, ISCSI_STATUS_CLS_INITIATOR_ERR,\r\nISCSI_LOGIN_STATUS_AUTH_FAILED);\r\nreturn -1;\r\ndefault:\r\npr_err("Received unknown error %d from LIO"\r\n" Authentication\n", authret);\r\niscsit_tx_login_rsp(conn, ISCSI_STATUS_CLS_TARGET_ERR,\r\nISCSI_LOGIN_STATUS_TARGET_ERROR);\r\nreturn -1;\r\n}\r\nreturn 0;\r\n}\r\nstatic int iscsi_target_handle_csg_zero(\r\nstruct iscsi_conn *conn,\r\nstruct iscsi_login *login)\r\n{\r\nint ret;\r\nu32 payload_length;\r\nstruct iscsi_param *param;\r\nstruct iscsi_login_req *login_req;\r\nstruct iscsi_login_rsp *login_rsp;\r\nlogin_req = (struct iscsi_login_req *) login->req;\r\nlogin_rsp = (struct iscsi_login_rsp *) login->rsp;\r\npayload_length = ntoh24(login_req->dlength);\r\nparam = iscsi_find_param_from_key(AUTHMETHOD, conn->param_list);\r\nif (!param)\r\nreturn -1;\r\nret = iscsi_decode_text_input(\r\nPHASE_SECURITY|PHASE_DECLARATIVE,\r\nSENDER_INITIATOR|SENDER_RECEIVER,\r\nlogin->req_buf,\r\npayload_length,\r\nconn);\r\nif (ret < 0)\r\nreturn -1;\r\nif (ret > 0) {\r\nif (login->auth_complete) {\r\npr_err("Initiator has already been"\r\n" successfully authenticated, but is still"\r\n" sending %s keys.\n", param->value);\r\niscsit_tx_login_rsp(conn, ISCSI_STATUS_CLS_INITIATOR_ERR,\r\nISCSI_LOGIN_STATUS_INIT_ERR);\r\nreturn -1;\r\n}\r\ngoto do_auth;\r\n} else if (!payload_length) {\r\npr_err("Initiator sent zero length security payload,"\r\n" login failed\n");\r\niscsit_tx_login_rsp(conn, ISCSI_STATUS_CLS_INITIATOR_ERR,\r\nISCSI_LOGIN_STATUS_AUTH_FAILED);\r\nreturn -1;\r\n}\r\nif (login->first_request)\r\nif (iscsi_target_check_first_request(conn, login) < 0)\r\nreturn -1;\r\nret = iscsi_encode_text_output(\r\nPHASE_SECURITY|PHASE_DECLARATIVE,\r\nSENDER_TARGET,\r\nlogin->rsp_buf,\r\n&login->rsp_length,\r\nconn->param_list);\r\nif (ret < 0)\r\nreturn -1;\r\nif (!iscsi_check_negotiated_keys(conn->param_list)) {\r\nif (conn->tpg->tpg_attrib.authentication &&\r\n!strncmp(param->value, NONE, 4)) {\r\npr_err("Initiator sent AuthMethod=None but"\r\n" Target is enforcing iSCSI Authentication,"\r\n" login failed.\n");\r\niscsit_tx_login_rsp(conn, ISCSI_STATUS_CLS_INITIATOR_ERR,\r\nISCSI_LOGIN_STATUS_AUTH_FAILED);\r\nreturn -1;\r\n}\r\nif (conn->tpg->tpg_attrib.authentication &&\r\n!login->auth_complete)\r\nreturn 0;\r\nif (strncmp(param->value, NONE, 4) && !login->auth_complete)\r\nreturn 0;\r\nif ((login_req->flags & ISCSI_FLAG_LOGIN_NEXT_STAGE1) &&\r\n(login_req->flags & ISCSI_FLAG_LOGIN_TRANSIT)) {\r\nlogin_rsp->flags |= ISCSI_FLAG_LOGIN_NEXT_STAGE1 |\r\nISCSI_FLAG_LOGIN_TRANSIT;\r\nlogin->current_stage = 1;\r\n}\r\n}\r\nreturn 0;\r\ndo_auth:\r\nreturn iscsi_target_do_authentication(conn, login);\r\n}\r\nstatic int iscsi_target_handle_csg_one(struct iscsi_conn *conn, struct iscsi_login *login)\r\n{\r\nint ret;\r\nu32 payload_length;\r\nstruct iscsi_login_req *login_req;\r\nstruct iscsi_login_rsp *login_rsp;\r\nlogin_req = (struct iscsi_login_req *) login->req;\r\nlogin_rsp = (struct iscsi_login_rsp *) login->rsp;\r\npayload_length = ntoh24(login_req->dlength);\r\nret = iscsi_decode_text_input(\r\nPHASE_OPERATIONAL|PHASE_DECLARATIVE,\r\nSENDER_INITIATOR|SENDER_RECEIVER,\r\nlogin->req_buf,\r\npayload_length,\r\nconn);\r\nif (ret < 0) {\r\niscsit_tx_login_rsp(conn, ISCSI_STATUS_CLS_INITIATOR_ERR,\r\nISCSI_LOGIN_STATUS_INIT_ERR);\r\nreturn -1;\r\n}\r\nif (login->first_request)\r\nif (iscsi_target_check_first_request(conn, login) < 0)\r\nreturn -1;\r\nif (iscsi_target_check_for_existing_instances(conn, login) < 0)\r\nreturn -1;\r\nret = iscsi_encode_text_output(\r\nPHASE_OPERATIONAL|PHASE_DECLARATIVE,\r\nSENDER_TARGET,\r\nlogin->rsp_buf,\r\n&login->rsp_length,\r\nconn->param_list);\r\nif (ret < 0) {\r\niscsit_tx_login_rsp(conn, ISCSI_STATUS_CLS_INITIATOR_ERR,\r\nISCSI_LOGIN_STATUS_INIT_ERR);\r\nreturn -1;\r\n}\r\nif (!login->auth_complete &&\r\nconn->tpg->tpg_attrib.authentication) {\r\npr_err("Initiator is requesting CSG: 1, has not been"\r\n" successfully authenticated, and the Target is"\r\n" enforcing iSCSI Authentication, login failed.\n");\r\niscsit_tx_login_rsp(conn, ISCSI_STATUS_CLS_INITIATOR_ERR,\r\nISCSI_LOGIN_STATUS_AUTH_FAILED);\r\nreturn -1;\r\n}\r\nif (!iscsi_check_negotiated_keys(conn->param_list))\r\nif ((login_req->flags & ISCSI_FLAG_LOGIN_NEXT_STAGE3) &&\r\n(login_req->flags & ISCSI_FLAG_LOGIN_TRANSIT))\r\nlogin_rsp->flags |= ISCSI_FLAG_LOGIN_NEXT_STAGE3 |\r\nISCSI_FLAG_LOGIN_TRANSIT;\r\nreturn 0;\r\n}\r\nstatic int iscsi_target_do_login(struct iscsi_conn *conn, struct iscsi_login *login)\r\n{\r\nint pdu_count = 0;\r\nstruct iscsi_login_req *login_req;\r\nstruct iscsi_login_rsp *login_rsp;\r\nlogin_req = (struct iscsi_login_req *) login->req;\r\nlogin_rsp = (struct iscsi_login_rsp *) login->rsp;\r\nwhile (1) {\r\nif (++pdu_count > MAX_LOGIN_PDUS) {\r\npr_err("MAX_LOGIN_PDUS count reached.\n");\r\niscsit_tx_login_rsp(conn, ISCSI_STATUS_CLS_TARGET_ERR,\r\nISCSI_LOGIN_STATUS_TARGET_ERROR);\r\nreturn -1;\r\n}\r\nswitch (ISCSI_LOGIN_CURRENT_STAGE(login_req->flags)) {\r\ncase 0:\r\nlogin_rsp->flags &= ~ISCSI_FLAG_LOGIN_CURRENT_STAGE_MASK;\r\nif (iscsi_target_handle_csg_zero(conn, login) < 0)\r\nreturn -1;\r\nbreak;\r\ncase 1:\r\nlogin_rsp->flags |= ISCSI_FLAG_LOGIN_CURRENT_STAGE1;\r\nif (iscsi_target_handle_csg_one(conn, login) < 0)\r\nreturn -1;\r\nif (login_rsp->flags & ISCSI_FLAG_LOGIN_TRANSIT) {\r\nlogin->tsih = conn->sess->tsih;\r\nlogin->login_complete = 1;\r\niscsi_target_restore_sock_callbacks(conn);\r\nif (iscsi_target_do_tx_login_io(conn,\r\nlogin) < 0)\r\nreturn -1;\r\nreturn 1;\r\n}\r\nbreak;\r\ndefault:\r\npr_err("Illegal CSG: %d received from"\r\n" Initiator, protocol error.\n",\r\nISCSI_LOGIN_CURRENT_STAGE(login_req->flags));\r\nbreak;\r\n}\r\nif (iscsi_target_do_tx_login_io(conn, login) < 0)\r\nreturn -1;\r\nif (login_rsp->flags & ISCSI_FLAG_LOGIN_TRANSIT) {\r\nlogin_rsp->flags &= ~ISCSI_FLAG_LOGIN_TRANSIT;\r\nlogin_rsp->flags &= ~ISCSI_FLAG_LOGIN_NEXT_STAGE_MASK;\r\n}\r\nbreak;\r\n}\r\nif (conn->sock) {\r\nstruct sock *sk = conn->sock->sk;\r\nbool state;\r\nread_lock_bh(&sk->sk_callback_lock);\r\nstate = iscsi_target_sk_state_check(sk);\r\nread_unlock_bh(&sk->sk_callback_lock);\r\nif (!state) {\r\npr_debug("iscsi_target_do_login() failed state for"\r\n" conn: %p\n", conn);\r\nreturn -1;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic void iscsi_initiatorname_tolower(\r\nchar *param_buf)\r\n{\r\nchar *c;\r\nu32 iqn_size = strlen(param_buf), i;\r\nfor (i = 0; i < iqn_size; i++) {\r\nc = &param_buf[i];\r\nif (!isupper(*c))\r\ncontinue;\r\n*c = tolower(*c);\r\n}\r\n}\r\nint iscsi_target_locate_portal(\r\nstruct iscsi_np *np,\r\nstruct iscsi_conn *conn,\r\nstruct iscsi_login *login)\r\n{\r\nchar *i_buf = NULL, *s_buf = NULL, *t_buf = NULL;\r\nchar *tmpbuf, *start = NULL, *end = NULL, *key, *value;\r\nstruct iscsi_session *sess = conn->sess;\r\nstruct iscsi_tiqn *tiqn;\r\nstruct iscsi_tpg_np *tpg_np = NULL;\r\nstruct iscsi_login_req *login_req;\r\nstruct se_node_acl *se_nacl;\r\nu32 payload_length, queue_depth = 0;\r\nint sessiontype = 0, ret = 0, tag_num, tag_size;\r\nINIT_DELAYED_WORK(&conn->login_work, iscsi_target_do_login_rx);\r\nINIT_DELAYED_WORK(&conn->login_cleanup_work, iscsi_target_do_cleanup);\r\niscsi_target_set_sock_callbacks(conn);\r\nlogin->np = np;\r\nlogin_req = (struct iscsi_login_req *) login->req;\r\npayload_length = ntoh24(login_req->dlength);\r\ntmpbuf = kzalloc(payload_length + 1, GFP_KERNEL);\r\nif (!tmpbuf) {\r\npr_err("Unable to allocate memory for tmpbuf.\n");\r\nreturn -1;\r\n}\r\nmemcpy(tmpbuf, login->req_buf, payload_length);\r\ntmpbuf[payload_length] = '\0';\r\nstart = tmpbuf;\r\nend = (start + payload_length);\r\nwhile (start < end) {\r\nif (iscsi_extract_key_value(start, &key, &value) < 0) {\r\nret = -1;\r\ngoto out;\r\n}\r\nif (!strncmp(key, "InitiatorName", 13))\r\ni_buf = value;\r\nelse if (!strncmp(key, "SessionType", 11))\r\ns_buf = value;\r\nelse if (!strncmp(key, "TargetName", 10))\r\nt_buf = value;\r\nstart += strlen(key) + strlen(value) + 2;\r\n}\r\nif (!i_buf) {\r\npr_err("InitiatorName key not received"\r\n" in first login request.\n");\r\niscsit_tx_login_rsp(conn, ISCSI_STATUS_CLS_INITIATOR_ERR,\r\nISCSI_LOGIN_STATUS_MISSING_FIELDS);\r\nret = -1;\r\ngoto out;\r\n}\r\niscsi_initiatorname_tolower(i_buf);\r\nif (!s_buf) {\r\nif (!login->leading_connection)\r\ngoto get_target;\r\npr_err("SessionType key not received"\r\n" in first login request.\n");\r\niscsit_tx_login_rsp(conn, ISCSI_STATUS_CLS_INITIATOR_ERR,\r\nISCSI_LOGIN_STATUS_MISSING_FIELDS);\r\nret = -1;\r\ngoto out;\r\n}\r\nsessiontype = strncmp(s_buf, DISCOVERY, 9);\r\nif (!sessiontype) {\r\nconn->tpg = iscsit_global->discovery_tpg;\r\nif (!login->leading_connection)\r\ngoto get_target;\r\nsess->sess_ops->SessionType = 1;\r\nif (iscsi_login_setup_crypto(conn) < 0) {\r\npr_err("iscsi_login_setup_crypto() failed\n");\r\nret = -1;\r\ngoto out;\r\n}\r\nif (iscsit_access_np(np, conn->tpg) < 0) {\r\niscsit_tx_login_rsp(conn, ISCSI_STATUS_CLS_TARGET_ERR,\r\nISCSI_LOGIN_STATUS_SVC_UNAVAILABLE);\r\nret = -1;\r\ngoto out;\r\n}\r\nret = 0;\r\ngoto alloc_tags;\r\n}\r\nget_target:\r\nif (!t_buf) {\r\npr_err("TargetName key not received"\r\n" in first login request while"\r\n" SessionType=Normal.\n");\r\niscsit_tx_login_rsp(conn, ISCSI_STATUS_CLS_INITIATOR_ERR,\r\nISCSI_LOGIN_STATUS_MISSING_FIELDS);\r\nret = -1;\r\ngoto out;\r\n}\r\ntiqn = iscsit_get_tiqn_for_login(t_buf);\r\nif (!tiqn) {\r\npr_err("Unable to locate Target IQN: %s in"\r\n" Storage Node\n", t_buf);\r\niscsit_tx_login_rsp(conn, ISCSI_STATUS_CLS_TARGET_ERR,\r\nISCSI_LOGIN_STATUS_SVC_UNAVAILABLE);\r\nret = -1;\r\ngoto out;\r\n}\r\npr_debug("Located Storage Object: %s\n", tiqn->tiqn);\r\nconn->tpg = iscsit_get_tpg_from_np(tiqn, np, &tpg_np);\r\nif (!conn->tpg) {\r\npr_err("Unable to locate Target Portal Group"\r\n" on %s\n", tiqn->tiqn);\r\niscsit_put_tiqn_for_login(tiqn);\r\niscsit_tx_login_rsp(conn, ISCSI_STATUS_CLS_TARGET_ERR,\r\nISCSI_LOGIN_STATUS_SVC_UNAVAILABLE);\r\nret = -1;\r\ngoto out;\r\n}\r\nconn->tpg_np = tpg_np;\r\npr_debug("Located Portal Group Object: %hu\n", conn->tpg->tpgt);\r\nif (iscsi_login_setup_crypto(conn) < 0) {\r\npr_err("iscsi_login_setup_crypto() failed\n");\r\nkref_put(&tpg_np->tpg_np_kref, iscsit_login_kref_put);\r\niscsit_put_tiqn_for_login(tiqn);\r\nconn->tpg = NULL;\r\nret = -1;\r\ngoto out;\r\n}\r\nif (iscsit_access_np(np, conn->tpg) < 0) {\r\nkref_put(&tpg_np->tpg_np_kref, iscsit_login_kref_put);\r\niscsit_put_tiqn_for_login(tiqn);\r\niscsit_tx_login_rsp(conn, ISCSI_STATUS_CLS_TARGET_ERR,\r\nISCSI_LOGIN_STATUS_SVC_UNAVAILABLE);\r\nconn->tpg = NULL;\r\nret = -1;\r\ngoto out;\r\n}\r\nif (!login->leading_connection) {\r\nret = 0;\r\ngoto out;\r\n}\r\nsess->sess_ops->SessionType = 0;\r\nsess->se_sess->se_node_acl = core_tpg_check_initiator_node_acl(\r\n&conn->tpg->tpg_se_tpg, i_buf);\r\nif (!sess->se_sess->se_node_acl) {\r\npr_err("iSCSI Initiator Node: %s is not authorized to"\r\n" access iSCSI target portal group: %hu.\n",\r\ni_buf, conn->tpg->tpgt);\r\niscsit_tx_login_rsp(conn, ISCSI_STATUS_CLS_INITIATOR_ERR,\r\nISCSI_LOGIN_STATUS_TGT_FORBIDDEN);\r\nret = -1;\r\ngoto out;\r\n}\r\nse_nacl = sess->se_sess->se_node_acl;\r\nqueue_depth = se_nacl->queue_depth;\r\nalloc_tags:\r\ntag_num = max_t(u32, ISCSIT_MIN_TAGS, queue_depth);\r\ntag_num = (tag_num * 2) + ISCSIT_EXTRA_TAGS;\r\ntag_size = sizeof(struct iscsi_cmd) + conn->conn_transport->priv_size;\r\nret = transport_alloc_session_tags(sess->se_sess, tag_num, tag_size);\r\nif (ret < 0) {\r\niscsit_tx_login_rsp(conn, ISCSI_STATUS_CLS_TARGET_ERR,\r\nISCSI_LOGIN_STATUS_NO_RESOURCES);\r\nret = -1;\r\n}\r\nout:\r\nkfree(tmpbuf);\r\nreturn ret;\r\n}\r\nint iscsi_target_start_negotiation(\r\nstruct iscsi_login *login,\r\nstruct iscsi_conn *conn)\r\n{\r\nint ret;\r\nret = iscsi_target_do_login(conn, login);\r\nif (!ret) {\r\nif (conn->sock) {\r\nstruct sock *sk = conn->sock->sk;\r\nwrite_lock_bh(&sk->sk_callback_lock);\r\nset_bit(LOGIN_FLAGS_READY, &conn->login_flags);\r\nwrite_unlock_bh(&sk->sk_callback_lock);\r\n}\r\n} else if (ret < 0) {\r\ncancel_delayed_work_sync(&conn->login_work);\r\ncancel_delayed_work_sync(&conn->login_cleanup_work);\r\niscsi_target_restore_sock_callbacks(conn);\r\niscsi_remove_failed_auth_entry(conn);\r\n}\r\nif (ret != 0)\r\niscsi_target_nego_release(conn);\r\nreturn ret;\r\n}\r\nvoid iscsi_target_nego_release(struct iscsi_conn *conn)\r\n{\r\nstruct iscsi_login *login = conn->conn_login;\r\nif (!login)\r\nreturn;\r\nkfree(login->req_buf);\r\nkfree(login->rsp_buf);\r\nkfree(login);\r\nconn->conn_login = NULL;\r\n}
