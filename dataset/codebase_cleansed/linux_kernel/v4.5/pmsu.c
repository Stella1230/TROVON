void mvebu_pmsu_set_cpu_boot_addr(int hw_cpu, void *boot_addr)\r\n{\r\nwritel(virt_to_phys(boot_addr), pmsu_mp_base +\r\nPMSU_BOOT_ADDR_REDIRECT_OFFSET(hw_cpu));\r\n}\r\nint mvebu_setup_boot_addr_wa(unsigned int crypto_eng_target,\r\nunsigned int crypto_eng_attribute,\r\nphys_addr_t resume_addr_reg)\r\n{\r\nvoid __iomem *sram_virt_base;\r\nu32 code_len = &mvebu_boot_wa_end - &mvebu_boot_wa_start;\r\nmvebu_mbus_del_window(BOOTROM_BASE, BOOTROM_SIZE);\r\nmvebu_mbus_add_window_by_id(crypto_eng_target, crypto_eng_attribute,\r\nSRAM_PHYS_BASE, SZ_64K);\r\nsram_virt_base = ioremap(SRAM_PHYS_BASE, SZ_64K);\r\nif (!sram_virt_base) {\r\npr_err("Unable to map SRAM to setup the boot address WA\n");\r\nreturn -ENOMEM;\r\n}\r\nmemcpy(sram_virt_base, &mvebu_boot_wa_start, code_len);\r\n__raw_writel((unsigned long)resume_addr_reg,\r\nsram_virt_base + code_len - 4);\r\niounmap(sram_virt_base);\r\nreturn 0;\r\n}\r\nstatic int __init mvebu_v7_pmsu_init(void)\r\n{\r\nstruct device_node *np;\r\nstruct resource res;\r\nint ret = 0;\r\nnp = of_find_matching_node(NULL, of_pmsu_table);\r\nif (!np)\r\nreturn 0;\r\npr_info("Initializing Power Management Service Unit\n");\r\nif (of_address_to_resource(np, 0, &res)) {\r\npr_err("unable to get resource\n");\r\nret = -ENOENT;\r\ngoto out;\r\n}\r\nif (of_device_is_compatible(np, "marvell,armada-370-xp-pmsu")) {\r\npr_warn(FW_WARN "deprecated pmsu binding\n");\r\nres.start = res.start - PMSU_BASE_OFFSET;\r\nres.end = res.start + PMSU_REG_SIZE - 1;\r\n}\r\nif (!request_mem_region(res.start, resource_size(&res),\r\nnp->full_name)) {\r\npr_err("unable to request region\n");\r\nret = -EBUSY;\r\ngoto out;\r\n}\r\npmsu_mp_phys_base = res.start;\r\npmsu_mp_base = ioremap(res.start, resource_size(&res));\r\nif (!pmsu_mp_base) {\r\npr_err("unable to map registers\n");\r\nrelease_mem_region(res.start, resource_size(&res));\r\nret = -ENOMEM;\r\ngoto out;\r\n}\r\nout:\r\nof_node_put(np);\r\nreturn ret;\r\n}\r\nstatic void mvebu_v7_pmsu_enable_l2_powerdown_onidle(void)\r\n{\r\nu32 reg;\r\nif (pmsu_mp_base == NULL)\r\nreturn;\r\nreg = readl(pmsu_mp_base + L2C_NFABRIC_PM_CTL);\r\nreg |= L2C_NFABRIC_PM_CTL_PWR_DOWN;\r\nwritel(reg, pmsu_mp_base + L2C_NFABRIC_PM_CTL);\r\n}\r\nstatic int mvebu_v7_pmsu_idle_prepare(unsigned long flags)\r\n{\r\nunsigned int hw_cpu = cpu_logical_map(smp_processor_id());\r\nu32 reg;\r\nif (pmsu_mp_base == NULL)\r\nreturn -EINVAL;\r\nreg = readl(pmsu_mp_base + PMSU_STATUS_AND_MASK(hw_cpu));\r\nreg |= PMSU_STATUS_AND_MASK_CPU_IDLE_WAIT |\r\nPMSU_STATUS_AND_MASK_IRQ_WAKEUP |\r\nPMSU_STATUS_AND_MASK_FIQ_WAKEUP |\r\nPMSU_STATUS_AND_MASK_SNP_Q_EMPTY_WAIT |\r\nPMSU_STATUS_AND_MASK_IRQ_MASK |\r\nPMSU_STATUS_AND_MASK_FIQ_MASK;\r\nwritel(reg, pmsu_mp_base + PMSU_STATUS_AND_MASK(hw_cpu));\r\nreg = readl(pmsu_mp_base + PMSU_CONTROL_AND_CONFIG(hw_cpu));\r\nif (flags & PMSU_PREPARE_DEEP_IDLE)\r\nreg |= PMSU_CONTROL_AND_CONFIG_L2_PWDDN;\r\nreg |= PMSU_CONTROL_AND_CONFIG_PWDDN_REQ;\r\nwritel(reg, pmsu_mp_base + PMSU_CONTROL_AND_CONFIG(hw_cpu));\r\nif (flags & PMSU_PREPARE_SNOOP_DISABLE) {\r\nreg = readl(pmsu_mp_base + PMSU_CPU_POWER_DOWN_CONTROL(hw_cpu));\r\nreg |= PMSU_CPU_POWER_DOWN_DIS_SNP_Q_SKIP;\r\nwritel(reg, pmsu_mp_base + PMSU_CPU_POWER_DOWN_CONTROL(hw_cpu));\r\n}\r\nreturn 0;\r\n}\r\nint armada_370_xp_pmsu_idle_enter(unsigned long deepidle)\r\n{\r\nunsigned long flags = PMSU_PREPARE_SNOOP_DISABLE;\r\nint ret;\r\nif (deepidle)\r\nflags |= PMSU_PREPARE_DEEP_IDLE;\r\nret = mvebu_v7_pmsu_idle_prepare(flags);\r\nif (ret)\r\nreturn ret;\r\nv7_exit_coherency_flush(all);\r\nll_disable_coherency();\r\ndsb();\r\nwfi();\r\nlocal_flush_tlb_all();\r\nll_enable_coherency();\r\nasm volatile(\r\n"mrc p15, 0, r0, c1, c0, 0 \n\t"\r\n"tst r0, %0 \n\t"\r\n"orreq r0, r0, #(1 << 2) \n\t"\r\n"mcreq p15, 0, r0, c1, c0, 0 \n\t"\r\n"isb "\r\n: : "Ir" (CR_C) : "r0");\r\npr_debug("Failed to suspend the system\n");\r\nreturn 0;\r\n}\r\nstatic int armada_370_xp_cpu_suspend(unsigned long deepidle)\r\n{\r\nreturn cpu_suspend(deepidle, armada_370_xp_pmsu_idle_enter);\r\n}\r\nint armada_38x_do_cpu_suspend(unsigned long deepidle)\r\n{\r\nunsigned long flags = 0;\r\nif (deepidle)\r\nflags |= PMSU_PREPARE_DEEP_IDLE;\r\nmvebu_v7_pmsu_idle_prepare(flags);\r\nv7_exit_coherency_flush(louis);\r\nscu_power_mode(mvebu_get_scu_base(), SCU_PM_POWEROFF);\r\ncpu_do_idle();\r\nreturn 1;\r\n}\r\nstatic int armada_38x_cpu_suspend(unsigned long deepidle)\r\n{\r\nreturn cpu_suspend(false, armada_38x_do_cpu_suspend);\r\n}\r\nvoid mvebu_v7_pmsu_idle_exit(void)\r\n{\r\nunsigned int hw_cpu = cpu_logical_map(smp_processor_id());\r\nu32 reg;\r\nif (pmsu_mp_base == NULL)\r\nreturn;\r\nreg = readl(pmsu_mp_base + PMSU_CONTROL_AND_CONFIG(hw_cpu));\r\nreg &= ~PMSU_CONTROL_AND_CONFIG_L2_PWDDN;\r\nwritel(reg, pmsu_mp_base + PMSU_CONTROL_AND_CONFIG(hw_cpu));\r\nreg = readl(pmsu_mp_base + PMSU_STATUS_AND_MASK(hw_cpu));\r\nreg &= ~(PMSU_STATUS_AND_MASK_IRQ_WAKEUP | PMSU_STATUS_AND_MASK_FIQ_WAKEUP);\r\nreg &= ~PMSU_STATUS_AND_MASK_CPU_IDLE_WAIT;\r\nreg &= ~PMSU_STATUS_AND_MASK_SNP_Q_EMPTY_WAIT;\r\nreg &= ~(PMSU_STATUS_AND_MASK_IRQ_MASK | PMSU_STATUS_AND_MASK_FIQ_MASK);\r\nwritel(reg, pmsu_mp_base + PMSU_STATUS_AND_MASK(hw_cpu));\r\n}\r\nstatic int mvebu_v7_cpu_pm_notify(struct notifier_block *self,\r\nunsigned long action, void *hcpu)\r\n{\r\nif (action == CPU_PM_ENTER) {\r\nunsigned int hw_cpu = cpu_logical_map(smp_processor_id());\r\nmvebu_pmsu_set_cpu_boot_addr(hw_cpu, mvebu_cpu_resume);\r\n} else if (action == CPU_PM_EXIT) {\r\nmvebu_v7_pmsu_idle_exit();\r\n}\r\nreturn NOTIFY_OK;\r\n}\r\nstatic int broken_idle(struct device_node *np)\r\n{\r\nif (of_property_read_bool(np, "broken-idle")) {\r\npr_warn("CPU idle is currently broken: disabling\n");\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}\r\nstatic __init int armada_370_cpuidle_init(void)\r\n{\r\nstruct device_node *np;\r\nphys_addr_t redirect_reg;\r\nnp = of_find_compatible_node(NULL, NULL, "marvell,coherency-fabric");\r\nif (!np)\r\nreturn -ENODEV;\r\nif (broken_idle(np))\r\ngoto end;\r\nredirect_reg = pmsu_mp_phys_base + PMSU_BOOT_ADDR_REDIRECT_OFFSET(0);\r\nmvebu_setup_boot_addr_wa(ARMADA_370_CRYPT0_ENG_TARGET,\r\nARMADA_370_CRYPT0_ENG_ATTR,\r\nredirect_reg);\r\nmvebu_cpu_resume = armada_370_xp_cpu_resume;\r\nmvebu_v7_cpuidle_device.dev.platform_data = armada_370_xp_cpu_suspend;\r\nmvebu_v7_cpuidle_device.name = "cpuidle-armada-370";\r\nend:\r\nof_node_put(np);\r\nreturn 0;\r\n}\r\nstatic __init int armada_38x_cpuidle_init(void)\r\n{\r\nstruct device_node *np;\r\nvoid __iomem *mpsoc_base;\r\nu32 reg;\r\npr_warn("CPU idle is currently broken on Armada 38x: disabling\n");\r\nreturn 0;\r\nnp = of_find_compatible_node(NULL, NULL,\r\n"marvell,armada-380-coherency-fabric");\r\nif (!np)\r\nreturn -ENODEV;\r\nif (broken_idle(np))\r\ngoto end;\r\nof_node_put(np);\r\nnp = of_find_compatible_node(NULL, NULL,\r\n"marvell,armada-380-mpcore-soc-ctrl");\r\nif (!np)\r\nreturn -ENODEV;\r\nmpsoc_base = of_iomap(np, 0);\r\nBUG_ON(!mpsoc_base);\r\nreg = readl(mpsoc_base + MPCORE_RESET_CTL);\r\nreg |= MPCORE_RESET_CTL_L2;\r\nreg |= MPCORE_RESET_CTL_DEBUG;\r\nwritel(reg, mpsoc_base + MPCORE_RESET_CTL);\r\niounmap(mpsoc_base);\r\nreg = readl(pmsu_mp_base + PMSU_POWERDOWN_DELAY);\r\nreg &= ~PMSU_POWERDOWN_DELAY_MASK;\r\nreg |= PMSU_DFLT_ARMADA38X_DELAY;\r\nreg |= PMSU_POWERDOWN_DELAY_PMU;\r\nwritel(reg, pmsu_mp_base + PMSU_POWERDOWN_DELAY);\r\nmvebu_cpu_resume = armada_38x_cpu_resume;\r\nmvebu_v7_cpuidle_device.dev.platform_data = armada_38x_cpu_suspend;\r\nmvebu_v7_cpuidle_device.name = "cpuidle-armada-38x";\r\nend:\r\nof_node_put(np);\r\nreturn 0;\r\n}\r\nstatic __init int armada_xp_cpuidle_init(void)\r\n{\r\nstruct device_node *np;\r\nnp = of_find_compatible_node(NULL, NULL, "marvell,coherency-fabric");\r\nif (!np)\r\nreturn -ENODEV;\r\nif (broken_idle(np))\r\ngoto end;\r\nmvebu_cpu_resume = armada_370_xp_cpu_resume;\r\nmvebu_v7_cpuidle_device.dev.platform_data = armada_370_xp_cpu_suspend;\r\nmvebu_v7_cpuidle_device.name = "cpuidle-armada-xp";\r\nend:\r\nof_node_put(np);\r\nreturn 0;\r\n}\r\nstatic int __init mvebu_v7_cpu_pm_init(void)\r\n{\r\nstruct device_node *np;\r\nint ret;\r\nnp = of_find_matching_node(NULL, of_pmsu_table);\r\nif (!np)\r\nreturn 0;\r\nof_node_put(np);\r\nif (of_machine_is_compatible("marvell,armada380")) {\r\ncpu_hotplug_disable();\r\npr_warn("CPU hotplug support is currently broken on Armada 38x: disabling\n");\r\n}\r\nif (of_machine_is_compatible("marvell,armadaxp"))\r\nret = armada_xp_cpuidle_init();\r\nelse if (of_machine_is_compatible("marvell,armada370"))\r\nret = armada_370_cpuidle_init();\r\nelse if (of_machine_is_compatible("marvell,armada380"))\r\nret = armada_38x_cpuidle_init();\r\nelse\r\nreturn 0;\r\nif (ret)\r\nreturn ret;\r\nmvebu_v7_pmsu_enable_l2_powerdown_onidle();\r\nif (mvebu_v7_cpuidle_device.name)\r\nplatform_device_register(&mvebu_v7_cpuidle_device);\r\ncpu_pm_register_notifier(&mvebu_v7_cpu_pm_notifier);\r\nreturn 0;\r\n}\r\nstatic void mvebu_pmsu_dfs_request_local(void *data)\r\n{\r\nu32 reg;\r\nu32 cpu = smp_processor_id();\r\nunsigned long flags;\r\nlocal_irq_save(flags);\r\nreg = readl(pmsu_mp_base + PMSU_STATUS_AND_MASK(cpu));\r\nreg |= PMSU_STATUS_AND_MASK_CPU_IDLE_WAIT |\r\nPMSU_STATUS_AND_MASK_IRQ_MASK |\r\nPMSU_STATUS_AND_MASK_FIQ_MASK;\r\nwritel(reg, pmsu_mp_base + PMSU_STATUS_AND_MASK(cpu));\r\nreg = readl(pmsu_mp_base + PMSU_CONTROL_AND_CONFIG(cpu));\r\nreg |= PMSU_CONTROL_AND_CONFIG_DFS_REQ;\r\nwritel(reg, pmsu_mp_base + PMSU_CONTROL_AND_CONFIG(cpu));\r\nwfi();\r\nreg = readl(pmsu_mp_base + PMSU_STATUS_AND_MASK(cpu));\r\nreg &= ~PMSU_STATUS_AND_MASK_CPU_IDLE_WAIT;\r\nwritel(reg, pmsu_mp_base + PMSU_STATUS_AND_MASK(cpu));\r\nlocal_irq_restore(flags);\r\n}\r\nint mvebu_pmsu_dfs_request(int cpu)\r\n{\r\nunsigned long timeout;\r\nint hwcpu = cpu_logical_map(cpu);\r\nu32 reg;\r\nreg = readl(pmsu_mp_base + PMSU_EVENT_STATUS_AND_MASK(hwcpu));\r\nreg &= ~PMSU_EVENT_STATUS_AND_MASK_DFS_DONE;\r\nwritel(reg, pmsu_mp_base + PMSU_EVENT_STATUS_AND_MASK(hwcpu));\r\nreg = readl(pmsu_mp_base + PMSU_EVENT_STATUS_AND_MASK(hwcpu));\r\nreg |= PMSU_EVENT_STATUS_AND_MASK_DFS_DONE_MASK;\r\nwritel(reg, pmsu_mp_base + PMSU_EVENT_STATUS_AND_MASK(hwcpu));\r\nsmp_call_function_single(cpu, mvebu_pmsu_dfs_request_local,\r\nNULL, false);\r\ntimeout = jiffies + HZ;\r\nwhile (time_before(jiffies, timeout)) {\r\nreg = readl(pmsu_mp_base + PMSU_EVENT_STATUS_AND_MASK(hwcpu));\r\nif (reg & PMSU_EVENT_STATUS_AND_MASK_DFS_DONE)\r\nbreak;\r\nudelay(10);\r\n}\r\nif (time_after(jiffies, timeout))\r\nreturn -ETIME;\r\nreg = readl(pmsu_mp_base + PMSU_EVENT_STATUS_AND_MASK(hwcpu));\r\nreg &= ~PMSU_EVENT_STATUS_AND_MASK_DFS_DONE_MASK;\r\nwritel(reg, pmsu_mp_base + PMSU_EVENT_STATUS_AND_MASK(hwcpu));\r\nreturn 0;\r\n}\r\nstatic int __init armada_xp_pmsu_cpufreq_init(void)\r\n{\r\nstruct device_node *np;\r\nstruct resource res;\r\nint ret, cpu;\r\nif (!of_machine_is_compatible("marvell,armadaxp"))\r\nreturn 0;\r\nnp = of_find_compatible_node(NULL, NULL, "marvell,armada-xp-cpu-clock");\r\nif (!np)\r\nreturn 0;\r\nret = of_address_to_resource(np, 1, &res);\r\nif (ret) {\r\npr_warn(FW_WARN "not enabling cpufreq, deprecated armada-xp-cpu-clock binding\n");\r\nof_node_put(np);\r\nreturn 0;\r\n}\r\nof_node_put(np);\r\nfor_each_possible_cpu(cpu) {\r\nstruct device *cpu_dev;\r\nstruct clk *clk;\r\nint ret;\r\ncpu_dev = get_cpu_device(cpu);\r\nif (!cpu_dev) {\r\npr_err("Cannot get CPU %d\n", cpu);\r\ncontinue;\r\n}\r\nclk = clk_get(cpu_dev, 0);\r\nif (IS_ERR(clk)) {\r\npr_err("Cannot get clock for CPU %d\n", cpu);\r\nreturn PTR_ERR(clk);\r\n}\r\nret = dev_pm_opp_add(cpu_dev, clk_get_rate(clk), 0);\r\nif (ret) {\r\nclk_put(clk);\r\nreturn ret;\r\n}\r\nret = dev_pm_opp_add(cpu_dev, clk_get_rate(clk) / 2, 0);\r\nif (ret) {\r\nclk_put(clk);\r\nreturn ret;\r\n}\r\n}\r\nplatform_device_register_data(NULL, "cpufreq-dt", -1,\r\n&cpufreq_dt_pd, sizeof(cpufreq_dt_pd));\r\nreturn 0;\r\n}
