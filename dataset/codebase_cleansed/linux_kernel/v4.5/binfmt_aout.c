static int aout_core_dump(struct coredump_params *cprm)\r\n{\r\nmm_segment_t fs;\r\nint has_dumped = 0;\r\nvoid __user *dump_start;\r\nint dump_size;\r\nstruct user dump;\r\n#ifdef __alpha__\r\n# define START_DATA(u) ((void __user *)u.start_data)\r\n#else\r\n# define START_DATA(u) ((void __user *)((u.u_tsize << PAGE_SHIFT) + \\r\nu.start_code))\r\n#endif\r\n# define START_STACK(u) ((void __user *)u.start_stack)\r\nfs = get_fs();\r\nset_fs(KERNEL_DS);\r\nhas_dumped = 1;\r\nstrncpy(dump.u_comm, current->comm, sizeof(dump.u_comm));\r\ndump.u_ar0 = offsetof(struct user, regs);\r\ndump.signal = cprm->siginfo->si_signo;\r\naout_dump_thread(cprm->regs, &dump);\r\nif ((dump.u_dsize + dump.u_ssize+1) * PAGE_SIZE > cprm->limit)\r\ndump.u_dsize = 0;\r\nif ((dump.u_ssize + 1) * PAGE_SIZE > cprm->limit)\r\ndump.u_ssize = 0;\r\nset_fs(USER_DS);\r\nif (!access_ok(VERIFY_READ, START_DATA(dump), dump.u_dsize << PAGE_SHIFT))\r\ndump.u_dsize = 0;\r\nif (!access_ok(VERIFY_READ, START_STACK(dump), dump.u_ssize << PAGE_SHIFT))\r\ndump.u_ssize = 0;\r\nset_fs(KERNEL_DS);\r\nif (!dump_emit(cprm, &dump, sizeof(dump)))\r\ngoto end_coredump;\r\nif (!dump_skip(cprm, PAGE_SIZE - sizeof(dump)))\r\ngoto end_coredump;\r\nset_fs(USER_DS);\r\nif (dump.u_dsize != 0) {\r\ndump_start = START_DATA(dump);\r\ndump_size = dump.u_dsize << PAGE_SHIFT;\r\nif (!dump_emit(cprm, dump_start, dump_size))\r\ngoto end_coredump;\r\n}\r\nif (dump.u_ssize != 0) {\r\ndump_start = START_STACK(dump);\r\ndump_size = dump.u_ssize << PAGE_SHIFT;\r\nif (!dump_emit(cprm, dump_start, dump_size))\r\ngoto end_coredump;\r\n}\r\nend_coredump:\r\nset_fs(fs);\r\nreturn has_dumped;\r\n}\r\nstatic int set_brk(unsigned long start, unsigned long end)\r\n{\r\nstart = PAGE_ALIGN(start);\r\nend = PAGE_ALIGN(end);\r\nif (end > start) {\r\nunsigned long addr;\r\naddr = vm_brk(start, end - start);\r\nif (BAD_ADDR(addr))\r\nreturn addr;\r\n}\r\nreturn 0;\r\n}\r\nstatic unsigned long __user *create_aout_tables(char __user *p, struct linux_binprm * bprm)\r\n{\r\nchar __user * __user *argv;\r\nchar __user * __user *envp;\r\nunsigned long __user *sp;\r\nint argc = bprm->argc;\r\nint envc = bprm->envc;\r\nsp = (void __user *)((-(unsigned long)sizeof(char *)) & (unsigned long) p);\r\n#ifdef __alpha__\r\nput_user(0, --sp);\r\nput_user(0, --sp);\r\nif (bprm->loader) {\r\nput_user(0, --sp);\r\nput_user(1003, --sp);\r\nput_user(bprm->loader, --sp);\r\nput_user(1002, --sp);\r\n}\r\nput_user(bprm->exec, --sp);\r\nput_user(1001, --sp);\r\n#endif\r\nsp -= envc+1;\r\nenvp = (char __user * __user *) sp;\r\nsp -= argc+1;\r\nargv = (char __user * __user *) sp;\r\n#ifndef __alpha__\r\nput_user((unsigned long) envp,--sp);\r\nput_user((unsigned long) argv,--sp);\r\n#endif\r\nput_user(argc,--sp);\r\ncurrent->mm->arg_start = (unsigned long) p;\r\nwhile (argc-->0) {\r\nchar c;\r\nput_user(p,argv++);\r\ndo {\r\nget_user(c,p++);\r\n} while (c);\r\n}\r\nput_user(NULL,argv);\r\ncurrent->mm->arg_end = current->mm->env_start = (unsigned long) p;\r\nwhile (envc-->0) {\r\nchar c;\r\nput_user(p,envp++);\r\ndo {\r\nget_user(c,p++);\r\n} while (c);\r\n}\r\nput_user(NULL,envp);\r\ncurrent->mm->env_end = (unsigned long) p;\r\nreturn sp;\r\n}\r\nstatic int load_aout_binary(struct linux_binprm * bprm)\r\n{\r\nstruct pt_regs *regs = current_pt_regs();\r\nstruct exec ex;\r\nunsigned long error;\r\nunsigned long fd_offset;\r\nunsigned long rlim;\r\nint retval;\r\nex = *((struct exec *) bprm->buf);\r\nif ((N_MAGIC(ex) != ZMAGIC && N_MAGIC(ex) != OMAGIC &&\r\nN_MAGIC(ex) != QMAGIC && N_MAGIC(ex) != NMAGIC) ||\r\nN_TRSIZE(ex) || N_DRSIZE(ex) ||\r\ni_size_read(file_inode(bprm->file)) < ex.a_text+ex.a_data+N_SYMSIZE(ex)+N_TXTOFF(ex)) {\r\nreturn -ENOEXEC;\r\n}\r\nif (!bprm->file->f_op->mmap)\r\nreturn -ENOEXEC;\r\nfd_offset = N_TXTOFF(ex);\r\nrlim = rlimit(RLIMIT_DATA);\r\nif (rlim >= RLIM_INFINITY)\r\nrlim = ~0;\r\nif (ex.a_data + ex.a_bss > rlim)\r\nreturn -ENOMEM;\r\nretval = flush_old_exec(bprm);\r\nif (retval)\r\nreturn retval;\r\n#ifdef __alpha__\r\nSET_AOUT_PERSONALITY(bprm, ex);\r\n#else\r\nset_personality(PER_LINUX);\r\n#endif\r\nsetup_new_exec(bprm);\r\ncurrent->mm->end_code = ex.a_text +\r\n(current->mm->start_code = N_TXTADDR(ex));\r\ncurrent->mm->end_data = ex.a_data +\r\n(current->mm->start_data = N_DATADDR(ex));\r\ncurrent->mm->brk = ex.a_bss +\r\n(current->mm->start_brk = N_BSSADDR(ex));\r\nretval = setup_arg_pages(bprm, STACK_TOP, EXSTACK_DEFAULT);\r\nif (retval < 0)\r\nreturn retval;\r\ninstall_exec_creds(bprm);\r\nif (N_MAGIC(ex) == OMAGIC) {\r\nunsigned long text_addr, map_size;\r\nloff_t pos;\r\ntext_addr = N_TXTADDR(ex);\r\n#ifdef __alpha__\r\npos = fd_offset;\r\nmap_size = ex.a_text+ex.a_data + PAGE_SIZE - 1;\r\n#else\r\npos = 32;\r\nmap_size = ex.a_text+ex.a_data;\r\n#endif\r\nerror = vm_brk(text_addr & PAGE_MASK, map_size);\r\nif (error != (text_addr & PAGE_MASK))\r\nreturn error;\r\nerror = read_code(bprm->file, text_addr, pos,\r\nex.a_text+ex.a_data);\r\nif ((signed long)error < 0)\r\nreturn error;\r\n} else {\r\nif ((ex.a_text & 0xfff || ex.a_data & 0xfff) &&\r\n(N_MAGIC(ex) != NMAGIC) && printk_ratelimit())\r\n{\r\nprintk(KERN_NOTICE "executable not page aligned\n");\r\n}\r\nif ((fd_offset & ~PAGE_MASK) != 0 && printk_ratelimit())\r\n{\r\nprintk(KERN_WARNING\r\n"fd_offset is not page aligned. Please convert program: %pD\n",\r\nbprm->file);\r\n}\r\nif (!bprm->file->f_op->mmap||((fd_offset & ~PAGE_MASK) != 0)) {\r\nvm_brk(N_TXTADDR(ex), ex.a_text+ex.a_data);\r\nread_code(bprm->file, N_TXTADDR(ex), fd_offset,\r\nex.a_text + ex.a_data);\r\ngoto beyond_if;\r\n}\r\nerror = vm_mmap(bprm->file, N_TXTADDR(ex), ex.a_text,\r\nPROT_READ | PROT_EXEC,\r\nMAP_FIXED | MAP_PRIVATE | MAP_DENYWRITE | MAP_EXECUTABLE,\r\nfd_offset);\r\nif (error != N_TXTADDR(ex))\r\nreturn error;\r\nerror = vm_mmap(bprm->file, N_DATADDR(ex), ex.a_data,\r\nPROT_READ | PROT_WRITE | PROT_EXEC,\r\nMAP_FIXED | MAP_PRIVATE | MAP_DENYWRITE | MAP_EXECUTABLE,\r\nfd_offset + ex.a_text);\r\nif (error != N_DATADDR(ex))\r\nreturn error;\r\n}\r\nbeyond_if:\r\nset_binfmt(&aout_format);\r\nretval = set_brk(current->mm->start_brk, current->mm->brk);\r\nif (retval < 0)\r\nreturn retval;\r\ncurrent->mm->start_stack =\r\n(unsigned long) create_aout_tables((char __user *) bprm->p, bprm);\r\n#ifdef __alpha__\r\nregs->gp = ex.a_gpvalue;\r\n#endif\r\nstart_thread(regs, ex.a_entry, current->mm->start_stack);\r\nreturn 0;\r\n}\r\nstatic int load_aout_library(struct file *file)\r\n{\r\nstruct inode * inode;\r\nunsigned long bss, start_addr, len;\r\nunsigned long error;\r\nint retval;\r\nstruct exec ex;\r\ninode = file_inode(file);\r\nretval = -ENOEXEC;\r\nerror = kernel_read(file, 0, (char *) &ex, sizeof(ex));\r\nif (error != sizeof(ex))\r\ngoto out;\r\nif ((N_MAGIC(ex) != ZMAGIC && N_MAGIC(ex) != QMAGIC) || N_TRSIZE(ex) ||\r\nN_DRSIZE(ex) || ((ex.a_entry & 0xfff) && N_MAGIC(ex) == ZMAGIC) ||\r\ni_size_read(inode) < ex.a_text+ex.a_data+N_SYMSIZE(ex)+N_TXTOFF(ex)) {\r\ngoto out;\r\n}\r\nif (!file->f_op->mmap)\r\ngoto out;\r\nif (N_FLAGS(ex))\r\ngoto out;\r\nstart_addr = ex.a_entry & 0xfffff000;\r\nif ((N_TXTOFF(ex) & ~PAGE_MASK) != 0) {\r\nif (printk_ratelimit())\r\n{\r\nprintk(KERN_WARNING\r\n"N_TXTOFF is not page aligned. Please convert library: %pD\n",\r\nfile);\r\n}\r\nvm_brk(start_addr, ex.a_text + ex.a_data + ex.a_bss);\r\nread_code(file, start_addr, N_TXTOFF(ex),\r\nex.a_text + ex.a_data);\r\nretval = 0;\r\ngoto out;\r\n}\r\nerror = vm_mmap(file, start_addr, ex.a_text + ex.a_data,\r\nPROT_READ | PROT_WRITE | PROT_EXEC,\r\nMAP_FIXED | MAP_PRIVATE | MAP_DENYWRITE,\r\nN_TXTOFF(ex));\r\nretval = error;\r\nif (error != start_addr)\r\ngoto out;\r\nlen = PAGE_ALIGN(ex.a_text + ex.a_data);\r\nbss = ex.a_text + ex.a_data + ex.a_bss;\r\nif (bss > len) {\r\nerror = vm_brk(start_addr + len, bss - len);\r\nretval = error;\r\nif (error != start_addr + len)\r\ngoto out;\r\n}\r\nretval = 0;\r\nout:\r\nreturn retval;\r\n}\r\nstatic int __init init_aout_binfmt(void)\r\n{\r\nregister_binfmt(&aout_format);\r\nreturn 0;\r\n}\r\nstatic void __exit exit_aout_binfmt(void)\r\n{\r\nunregister_binfmt(&aout_format);\r\n}
