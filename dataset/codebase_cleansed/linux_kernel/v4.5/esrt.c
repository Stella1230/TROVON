static struct esre_entry *to_entry(struct kobject *kobj)\r\n{\r\nreturn container_of(kobj, struct esre_entry, kobj);\r\n}\r\nstatic struct esre_attribute *to_attr(struct attribute *attr)\r\n{\r\nreturn container_of(attr, struct esre_attribute, attr);\r\n}\r\nstatic ssize_t esre_attr_show(struct kobject *kobj,\r\nstruct attribute *_attr, char *buf)\r\n{\r\nstruct esre_entry *entry = to_entry(kobj);\r\nstruct esre_attribute *attr = to_attr(_attr);\r\nif (!capable(CAP_SYS_ADMIN))\r\nreturn -EACCES;\r\nreturn attr->show(entry, buf);\r\n}\r\nstatic ssize_t esre_fw_class_show(struct esre_entry *entry, char *buf)\r\n{\r\nchar *str = buf;\r\nefi_guid_to_str(&entry->esre.esre1->fw_class, str);\r\nstr += strlen(str);\r\nstr += sprintf(str, "\n");\r\nreturn str - buf;\r\n}\r\nstatic void esre_release(struct kobject *kobj)\r\n{\r\nstruct esre_entry *entry = to_entry(kobj);\r\nlist_del(&entry->list);\r\nkfree(entry);\r\n}\r\nstatic int esre_create_sysfs_entry(void *esre, int entry_num)\r\n{\r\nstruct esre_entry *entry;\r\nchar name[20];\r\nentry = kzalloc(sizeof(*entry), GFP_KERNEL);\r\nif (!entry)\r\nreturn -ENOMEM;\r\nsprintf(name, "entry%d", entry_num);\r\nentry->kobj.kset = esrt_kset;\r\nif (esrt->fw_resource_version == 1) {\r\nint rc = 0;\r\nentry->esre.esre1 = esre;\r\nrc = kobject_init_and_add(&entry->kobj, &esre1_ktype, NULL,\r\n"%s", name);\r\nif (rc) {\r\nkfree(entry);\r\nreturn rc;\r\n}\r\n}\r\nlist_add_tail(&entry->list, &entry_list);\r\nreturn 0;\r\n}\r\nstatic inline int esrt_table_exists(void)\r\n{\r\nif (!efi_enabled(EFI_CONFIG_TABLES))\r\nreturn 0;\r\nif (efi.esrt == EFI_INVALID_TABLE_ADDR)\r\nreturn 0;\r\nreturn 1;\r\n}\r\nstatic umode_t esrt_attr_is_visible(struct kobject *kobj,\r\nstruct attribute *attr, int n)\r\n{\r\nif (!esrt_table_exists())\r\nreturn 0;\r\nreturn attr->mode;\r\n}\r\nvoid __init efi_esrt_init(void)\r\n{\r\nvoid *va;\r\nstruct efi_system_resource_table tmpesrt;\r\nstruct efi_system_resource_entry_v1 *v1_entries;\r\nsize_t size, max, entry_size, entries_size;\r\nefi_memory_desc_t md;\r\nint rc;\r\nphys_addr_t end;\r\npr_debug("esrt-init: loading.\n");\r\nif (!esrt_table_exists())\r\nreturn;\r\nrc = efi_mem_desc_lookup(efi.esrt, &md);\r\nif (rc < 0) {\r\npr_err("ESRT header is not in the memory map.\n");\r\nreturn;\r\n}\r\nmax = efi_mem_desc_end(&md);\r\nif (max < efi.esrt) {\r\npr_err("EFI memory descriptor is invalid. (esrt: %p max: %p)\n",\r\n(void *)efi.esrt, (void *)max);\r\nreturn;\r\n}\r\nsize = sizeof(*esrt);\r\nmax -= efi.esrt;\r\nif (max < size) {\r\npr_err("ESRT header doen't fit on single memory map entry. (size: %zu max: %zu)\n",\r\nsize, max);\r\nreturn;\r\n}\r\nva = early_memremap(efi.esrt, size);\r\nif (!va) {\r\npr_err("early_memremap(%p, %zu) failed.\n", (void *)efi.esrt,\r\nsize);\r\nreturn;\r\n}\r\nmemcpy(&tmpesrt, va, sizeof(tmpesrt));\r\nif (tmpesrt.fw_resource_version == 1) {\r\nentry_size = sizeof (*v1_entries);\r\n} else {\r\npr_err("Unsupported ESRT version %lld.\n",\r\ntmpesrt.fw_resource_version);\r\nreturn;\r\n}\r\nif (tmpesrt.fw_resource_count > 0 && max - size < entry_size) {\r\npr_err("ESRT memory map entry can only hold the header. (max: %zu size: %zu)\n",\r\nmax - size, entry_size);\r\ngoto err_memunmap;\r\n}\r\nif (tmpesrt.fw_resource_count > 128) {\r\npr_err("ESRT says fw_resource_count has very large value %d.\n",\r\ntmpesrt.fw_resource_count);\r\ngoto err_memunmap;\r\n}\r\nentries_size = tmpesrt.fw_resource_count * entry_size;\r\nif (max < size + entries_size) {\r\npr_err("ESRT does not fit on single memory map entry (size: %zu max: %zu)\n",\r\nsize, max);\r\ngoto err_memunmap;\r\n}\r\nearly_memunmap(va, size);\r\nsize += entries_size;\r\nva = early_memremap(efi.esrt, size);\r\nif (!va) {\r\npr_err("early_memremap(%p, %zu) failed.\n", (void *)efi.esrt,\r\nsize);\r\nreturn;\r\n}\r\nesrt_data = (phys_addr_t)efi.esrt;\r\nesrt_data_size = size;\r\nend = esrt_data + size;\r\npr_info("Reserving ESRT space from %pa to %pa.\n", &esrt_data, &end);\r\nmemblock_reserve(esrt_data, esrt_data_size);\r\npr_debug("esrt-init: loaded.\n");\r\nerr_memunmap:\r\nearly_memunmap(va, size);\r\n}\r\nstatic int __init register_entries(void)\r\n{\r\nstruct efi_system_resource_entry_v1 *v1_entries = (void *)esrt->entries;\r\nint i, rc;\r\nif (!esrt_table_exists())\r\nreturn 0;\r\nfor (i = 0; i < le32_to_cpu(esrt->fw_resource_count); i++) {\r\nvoid *esre = NULL;\r\nif (esrt->fw_resource_version == 1) {\r\nesre = &v1_entries[i];\r\n} else {\r\npr_err("Unsupported ESRT version %lld.\n",\r\nesrt->fw_resource_version);\r\nreturn -EINVAL;\r\n}\r\nrc = esre_create_sysfs_entry(esre, i);\r\nif (rc < 0) {\r\npr_err("ESRT entry creation failed with error %d.\n",\r\nrc);\r\nreturn rc;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic void cleanup_entry_list(void)\r\n{\r\nstruct esre_entry *entry, *next;\r\nlist_for_each_entry_safe(entry, next, &entry_list, list) {\r\nkobject_put(&entry->kobj);\r\n}\r\n}\r\nstatic int __init esrt_sysfs_init(void)\r\n{\r\nint error;\r\nstruct efi_system_resource_table __iomem *ioesrt;\r\npr_debug("esrt-sysfs: loading.\n");\r\nif (!esrt_data || !esrt_data_size)\r\nreturn -ENOSYS;\r\nioesrt = ioremap(esrt_data, esrt_data_size);\r\nif (!ioesrt) {\r\npr_err("ioremap(%pa, %zu) failed.\n", &esrt_data,\r\nesrt_data_size);\r\nreturn -ENOMEM;\r\n}\r\nesrt = kmalloc(esrt_data_size, GFP_KERNEL);\r\nif (!esrt) {\r\npr_err("kmalloc failed. (wanted %zu bytes)\n", esrt_data_size);\r\niounmap(ioesrt);\r\nreturn -ENOMEM;\r\n}\r\nmemcpy_fromio(esrt, ioesrt, esrt_data_size);\r\nesrt_kobj = kobject_create_and_add("esrt", efi_kobj);\r\nif (!esrt_kobj) {\r\npr_err("Firmware table registration failed.\n");\r\nerror = -ENOMEM;\r\ngoto err;\r\n}\r\nerror = sysfs_create_group(esrt_kobj, &esrt_attr_group);\r\nif (error) {\r\npr_err("Sysfs attribute export failed with error %d.\n",\r\nerror);\r\ngoto err_remove_esrt;\r\n}\r\nesrt_kset = kset_create_and_add("entries", NULL, esrt_kobj);\r\nif (!esrt_kset) {\r\npr_err("kset creation failed.\n");\r\nerror = -ENOMEM;\r\ngoto err_remove_group;\r\n}\r\nerror = register_entries();\r\nif (error)\r\ngoto err_cleanup_list;\r\nmemblock_remove(esrt_data, esrt_data_size);\r\npr_debug("esrt-sysfs: loaded.\n");\r\nreturn 0;\r\nerr_cleanup_list:\r\ncleanup_entry_list();\r\nkset_unregister(esrt_kset);\r\nerr_remove_group:\r\nsysfs_remove_group(esrt_kobj, &esrt_attr_group);\r\nerr_remove_esrt:\r\nkobject_put(esrt_kobj);\r\nerr:\r\nkfree(esrt);\r\nesrt = NULL;\r\nreturn error;\r\n}
