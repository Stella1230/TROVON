int batadv_skb_head_push(struct sk_buff *skb, unsigned int len)\r\n{\r\nint result;\r\nresult = skb_cow_head(skb, len);\r\nif (result < 0)\r\nreturn result;\r\nskb_push(skb, len);\r\nreturn 0;\r\n}\r\nstatic int batadv_interface_open(struct net_device *dev)\r\n{\r\nnetif_start_queue(dev);\r\nreturn 0;\r\n}\r\nstatic int batadv_interface_release(struct net_device *dev)\r\n{\r\nnetif_stop_queue(dev);\r\nreturn 0;\r\n}\r\nstatic struct net_device_stats *batadv_interface_stats(struct net_device *dev)\r\n{\r\nstruct batadv_priv *bat_priv = netdev_priv(dev);\r\nstruct net_device_stats *stats = &bat_priv->stats;\r\nstats->tx_packets = batadv_sum_counter(bat_priv, BATADV_CNT_TX);\r\nstats->tx_bytes = batadv_sum_counter(bat_priv, BATADV_CNT_TX_BYTES);\r\nstats->tx_dropped = batadv_sum_counter(bat_priv, BATADV_CNT_TX_DROPPED);\r\nstats->rx_packets = batadv_sum_counter(bat_priv, BATADV_CNT_RX);\r\nstats->rx_bytes = batadv_sum_counter(bat_priv, BATADV_CNT_RX_BYTES);\r\nreturn stats;\r\n}\r\nstatic int batadv_interface_set_mac_addr(struct net_device *dev, void *p)\r\n{\r\nstruct batadv_priv *bat_priv = netdev_priv(dev);\r\nstruct batadv_softif_vlan *vlan;\r\nstruct sockaddr *addr = p;\r\nu8 old_addr[ETH_ALEN];\r\nif (!is_valid_ether_addr(addr->sa_data))\r\nreturn -EADDRNOTAVAIL;\r\nether_addr_copy(old_addr, dev->dev_addr);\r\nether_addr_copy(dev->dev_addr, addr->sa_data);\r\nif (atomic_read(&bat_priv->mesh_state) != BATADV_MESH_ACTIVE)\r\nreturn 0;\r\nrcu_read_lock();\r\nhlist_for_each_entry_rcu(vlan, &bat_priv->softif_vlan_list, list) {\r\nbatadv_tt_local_remove(bat_priv, old_addr, vlan->vid,\r\n"mac address changed", false);\r\nbatadv_tt_local_add(dev, addr->sa_data, vlan->vid,\r\nBATADV_NULL_IFINDEX, BATADV_NO_MARK);\r\n}\r\nrcu_read_unlock();\r\nreturn 0;\r\n}\r\nstatic int batadv_interface_change_mtu(struct net_device *dev, int new_mtu)\r\n{\r\nif ((new_mtu < 68) || (new_mtu > batadv_hardif_min_mtu(dev)))\r\nreturn -EINVAL;\r\ndev->mtu = new_mtu;\r\nreturn 0;\r\n}\r\nstatic void batadv_interface_set_rx_mode(struct net_device *dev)\r\n{\r\n}\r\nstatic int batadv_interface_tx(struct sk_buff *skb,\r\nstruct net_device *soft_iface)\r\n{\r\nstruct ethhdr *ethhdr;\r\nstruct batadv_priv *bat_priv = netdev_priv(soft_iface);\r\nstruct batadv_hard_iface *primary_if = NULL;\r\nstruct batadv_bcast_packet *bcast_packet;\r\n__be16 ethertype = htons(ETH_P_BATMAN);\r\nstatic const u8 stp_addr[ETH_ALEN] = {0x01, 0x80, 0xC2, 0x00,\r\n0x00, 0x00};\r\nstatic const u8 ectp_addr[ETH_ALEN] = {0xCF, 0x00, 0x00, 0x00,\r\n0x00, 0x00};\r\nenum batadv_dhcp_recipient dhcp_rcp = BATADV_DHCP_NO;\r\nu8 *dst_hint = NULL, chaddr[ETH_ALEN];\r\nstruct vlan_ethhdr *vhdr;\r\nunsigned int header_len = 0;\r\nint data_len = skb->len, ret;\r\nunsigned long brd_delay = 1;\r\nbool do_bcast = false, client_added;\r\nunsigned short vid;\r\nu32 seqno;\r\nint gw_mode;\r\nenum batadv_forw_mode forw_mode;\r\nstruct batadv_orig_node *mcast_single_orig = NULL;\r\nint network_offset = ETH_HLEN;\r\nif (atomic_read(&bat_priv->mesh_state) != BATADV_MESH_ACTIVE)\r\ngoto dropped;\r\nsoft_iface->trans_start = jiffies;\r\nvid = batadv_get_vid(skb, 0);\r\nethhdr = eth_hdr(skb);\r\nswitch (ntohs(ethhdr->h_proto)) {\r\ncase ETH_P_8021Q:\r\nvhdr = vlan_eth_hdr(skb);\r\nif (vhdr->h_vlan_encapsulated_proto != ethertype) {\r\nnetwork_offset += VLAN_HLEN;\r\nbreak;\r\n}\r\ncase ETH_P_BATMAN:\r\ngoto dropped;\r\n}\r\nskb_set_network_header(skb, network_offset);\r\nif (batadv_bla_tx(bat_priv, skb, vid))\r\ngoto dropped;\r\nethhdr = eth_hdr(skb);\r\nif (!is_multicast_ether_addr(ethhdr->h_source)) {\r\nclient_added = batadv_tt_local_add(soft_iface, ethhdr->h_source,\r\nvid, skb->skb_iif,\r\nskb->mark);\r\nif (!client_added)\r\ngoto dropped;\r\n}\r\nif (batadv_compare_eth(ethhdr->h_dest, stp_addr))\r\ngoto dropped;\r\nif (batadv_compare_eth(ethhdr->h_dest, ectp_addr))\r\ngoto dropped;\r\ngw_mode = atomic_read(&bat_priv->gw_mode);\r\nif (is_multicast_ether_addr(ethhdr->h_dest)) {\r\nif (gw_mode == BATADV_GW_MODE_OFF) {\r\ndo_bcast = true;\r\ngoto send;\r\n}\r\ndhcp_rcp = batadv_gw_dhcp_recipient_get(skb, &header_len,\r\nchaddr);\r\nethhdr = eth_hdr(skb);\r\nif (dhcp_rcp == BATADV_DHCP_NO) {\r\ndo_bcast = true;\r\ngoto send;\r\n}\r\nif (dhcp_rcp == BATADV_DHCP_TO_CLIENT)\r\ndst_hint = chaddr;\r\nelse if ((gw_mode == BATADV_GW_MODE_SERVER) &&\r\n(dhcp_rcp == BATADV_DHCP_TO_SERVER))\r\ngoto dropped;\r\nsend:\r\nif (do_bcast && !is_broadcast_ether_addr(ethhdr->h_dest)) {\r\nforw_mode = batadv_mcast_forw_mode(bat_priv, skb,\r\n&mcast_single_orig);\r\nif (forw_mode == BATADV_FORW_NONE)\r\ngoto dropped;\r\nif (forw_mode == BATADV_FORW_SINGLE)\r\ndo_bcast = false;\r\n}\r\n}\r\nbatadv_skb_set_priority(skb, 0);\r\nif (do_bcast) {\r\nprimary_if = batadv_primary_if_get_selected(bat_priv);\r\nif (!primary_if)\r\ngoto dropped;\r\nif (batadv_dat_snoop_outgoing_arp_request(bat_priv, skb))\r\nbrd_delay = msecs_to_jiffies(ARP_REQ_DELAY);\r\nif (batadv_skb_head_push(skb, sizeof(*bcast_packet)) < 0)\r\ngoto dropped;\r\nbcast_packet = (struct batadv_bcast_packet *)skb->data;\r\nbcast_packet->version = BATADV_COMPAT_VERSION;\r\nbcast_packet->ttl = BATADV_TTL;\r\nbcast_packet->packet_type = BATADV_BCAST;\r\nbcast_packet->reserved = 0;\r\nether_addr_copy(bcast_packet->orig,\r\nprimary_if->net_dev->dev_addr);\r\nseqno = atomic_inc_return(&bat_priv->bcast_seqno);\r\nbcast_packet->seqno = htonl(seqno);\r\nbatadv_add_bcast_packet_to_list(bat_priv, skb, brd_delay);\r\nkfree_skb(skb);\r\n} else {\r\nif (dhcp_rcp == BATADV_DHCP_TO_SERVER) {\r\nret = batadv_gw_out_of_range(bat_priv, skb);\r\nif (ret)\r\ngoto dropped;\r\nret = batadv_send_skb_via_gw(bat_priv, skb, vid);\r\n} else if (mcast_single_orig) {\r\nret = batadv_send_skb_unicast(bat_priv, skb,\r\nBATADV_UNICAST, 0,\r\nmcast_single_orig, vid);\r\n} else {\r\nif (batadv_dat_snoop_outgoing_arp_request(bat_priv,\r\nskb))\r\ngoto dropped;\r\nbatadv_dat_snoop_outgoing_arp_reply(bat_priv, skb);\r\nret = batadv_send_skb_via_tt(bat_priv, skb, dst_hint,\r\nvid);\r\n}\r\nif (ret == NET_XMIT_DROP)\r\ngoto dropped_freed;\r\n}\r\nbatadv_inc_counter(bat_priv, BATADV_CNT_TX);\r\nbatadv_add_counter(bat_priv, BATADV_CNT_TX_BYTES, data_len);\r\ngoto end;\r\ndropped:\r\nkfree_skb(skb);\r\ndropped_freed:\r\nbatadv_inc_counter(bat_priv, BATADV_CNT_TX_DROPPED);\r\nend:\r\nif (primary_if)\r\nbatadv_hardif_free_ref(primary_if);\r\nreturn NETDEV_TX_OK;\r\n}\r\nvoid batadv_interface_rx(struct net_device *soft_iface,\r\nstruct sk_buff *skb, struct batadv_hard_iface *recv_if,\r\nint hdr_size, struct batadv_orig_node *orig_node)\r\n{\r\nstruct batadv_bcast_packet *batadv_bcast_packet;\r\nstruct batadv_priv *bat_priv = netdev_priv(soft_iface);\r\n__be16 ethertype = htons(ETH_P_BATMAN);\r\nstruct vlan_ethhdr *vhdr;\r\nstruct ethhdr *ethhdr;\r\nunsigned short vid;\r\nbool is_bcast;\r\nbatadv_bcast_packet = (struct batadv_bcast_packet *)skb->data;\r\nis_bcast = (batadv_bcast_packet->packet_type == BATADV_BCAST);\r\nif (!pskb_may_pull(skb, hdr_size))\r\ngoto dropped;\r\nskb_pull_rcsum(skb, hdr_size);\r\nskb_reset_mac_header(skb);\r\nnf_reset(skb);\r\nvid = batadv_get_vid(skb, 0);\r\nethhdr = eth_hdr(skb);\r\nswitch (ntohs(ethhdr->h_proto)) {\r\ncase ETH_P_8021Q:\r\nvhdr = (struct vlan_ethhdr *)skb->data;\r\nif (vhdr->h_vlan_encapsulated_proto != ethertype)\r\nbreak;\r\ncase ETH_P_BATMAN:\r\ngoto dropped;\r\n}\r\nif (unlikely(!pskb_may_pull(skb, ETH_HLEN)))\r\ngoto dropped;\r\nskb->protocol = eth_type_trans(skb, soft_iface);\r\nbatadv_inc_counter(bat_priv, BATADV_CNT_RX);\r\nbatadv_add_counter(bat_priv, BATADV_CNT_RX_BYTES,\r\nskb->len + ETH_HLEN);\r\nsoft_iface->last_rx = jiffies;\r\nif (batadv_bla_rx(bat_priv, skb, vid, is_bcast))\r\ngoto out;\r\nif (orig_node)\r\nbatadv_tt_add_temporary_global_entry(bat_priv, orig_node,\r\nethhdr->h_source, vid);\r\nif (is_multicast_ether_addr(ethhdr->h_dest)) {\r\nif (batadv_vlan_ap_isola_get(bat_priv, vid) &&\r\nbatadv_tt_global_is_isolated(bat_priv, ethhdr->h_source,\r\nvid)) {\r\nskb->mark &= ~bat_priv->isolation_mark_mask;\r\nskb->mark |= bat_priv->isolation_mark;\r\n}\r\n} else if (batadv_is_ap_isolated(bat_priv, ethhdr->h_source,\r\nethhdr->h_dest, vid)) {\r\ngoto dropped;\r\n}\r\nnetif_rx(skb);\r\ngoto out;\r\ndropped:\r\nkfree_skb(skb);\r\nout:\r\nreturn;\r\n}\r\nvoid batadv_softif_vlan_free_ref(struct batadv_softif_vlan *vlan)\r\n{\r\nif (!vlan)\r\nreturn;\r\nif (atomic_dec_and_test(&vlan->refcount)) {\r\nspin_lock_bh(&vlan->bat_priv->softif_vlan_list_lock);\r\nhlist_del_rcu(&vlan->list);\r\nspin_unlock_bh(&vlan->bat_priv->softif_vlan_list_lock);\r\nkfree_rcu(vlan, rcu);\r\n}\r\n}\r\nstruct batadv_softif_vlan *batadv_softif_vlan_get(struct batadv_priv *bat_priv,\r\nunsigned short vid)\r\n{\r\nstruct batadv_softif_vlan *vlan_tmp, *vlan = NULL;\r\nrcu_read_lock();\r\nhlist_for_each_entry_rcu(vlan_tmp, &bat_priv->softif_vlan_list, list) {\r\nif (vlan_tmp->vid != vid)\r\ncontinue;\r\nif (!atomic_inc_not_zero(&vlan_tmp->refcount))\r\ncontinue;\r\nvlan = vlan_tmp;\r\nbreak;\r\n}\r\nrcu_read_unlock();\r\nreturn vlan;\r\n}\r\nint batadv_softif_create_vlan(struct batadv_priv *bat_priv, unsigned short vid)\r\n{\r\nstruct batadv_softif_vlan *vlan;\r\nint err;\r\nvlan = batadv_softif_vlan_get(bat_priv, vid);\r\nif (vlan) {\r\nbatadv_softif_vlan_free_ref(vlan);\r\nreturn -EEXIST;\r\n}\r\nvlan = kzalloc(sizeof(*vlan), GFP_ATOMIC);\r\nif (!vlan)\r\nreturn -ENOMEM;\r\nvlan->bat_priv = bat_priv;\r\nvlan->vid = vid;\r\natomic_set(&vlan->refcount, 1);\r\natomic_set(&vlan->ap_isolation, 0);\r\nerr = batadv_sysfs_add_vlan(bat_priv->soft_iface, vlan);\r\nif (err) {\r\nkfree(vlan);\r\nreturn err;\r\n}\r\nspin_lock_bh(&bat_priv->softif_vlan_list_lock);\r\nhlist_add_head_rcu(&vlan->list, &bat_priv->softif_vlan_list);\r\nspin_unlock_bh(&bat_priv->softif_vlan_list_lock);\r\nbatadv_tt_local_add(bat_priv->soft_iface,\r\nbat_priv->soft_iface->dev_addr, vid,\r\nBATADV_NULL_IFINDEX, BATADV_NO_MARK);\r\nreturn 0;\r\n}\r\nstatic void batadv_softif_destroy_vlan(struct batadv_priv *bat_priv,\r\nstruct batadv_softif_vlan *vlan)\r\n{\r\nbatadv_tt_local_remove(bat_priv, bat_priv->soft_iface->dev_addr,\r\nvlan->vid, "vlan interface destroyed", false);\r\nbatadv_sysfs_del_vlan(bat_priv, vlan);\r\nbatadv_softif_vlan_free_ref(vlan);\r\n}\r\nstatic int batadv_interface_add_vid(struct net_device *dev, __be16 proto,\r\nunsigned short vid)\r\n{\r\nstruct batadv_priv *bat_priv = netdev_priv(dev);\r\nstruct batadv_softif_vlan *vlan;\r\nint ret;\r\nif (proto != htons(ETH_P_8021Q))\r\nreturn -EINVAL;\r\nvid |= BATADV_VLAN_HAS_TAG;\r\nvlan = batadv_softif_vlan_get(bat_priv, vid);\r\nif (!vlan)\r\nreturn batadv_softif_create_vlan(bat_priv, vid);\r\nif (!vlan->kobj) {\r\nret = batadv_sysfs_add_vlan(bat_priv->soft_iface, vlan);\r\nif (ret) {\r\nbatadv_softif_vlan_free_ref(vlan);\r\nreturn ret;\r\n}\r\n}\r\nbatadv_tt_local_add(bat_priv->soft_iface,\r\nbat_priv->soft_iface->dev_addr, vid,\r\nBATADV_NULL_IFINDEX, BATADV_NO_MARK);\r\nreturn 0;\r\n}\r\nstatic int batadv_interface_kill_vid(struct net_device *dev, __be16 proto,\r\nunsigned short vid)\r\n{\r\nstruct batadv_priv *bat_priv = netdev_priv(dev);\r\nstruct batadv_softif_vlan *vlan;\r\nif (proto != htons(ETH_P_8021Q))\r\nreturn -EINVAL;\r\nvlan = batadv_softif_vlan_get(bat_priv, vid | BATADV_VLAN_HAS_TAG);\r\nif (!vlan)\r\nreturn -ENOENT;\r\nbatadv_softif_destroy_vlan(bat_priv, vlan);\r\nbatadv_softif_vlan_free_ref(vlan);\r\nreturn 0;\r\n}\r\nstatic void batadv_set_lockdep_class_one(struct net_device *dev,\r\nstruct netdev_queue *txq,\r\nvoid *_unused)\r\n{\r\nlockdep_set_class(&txq->_xmit_lock, &batadv_netdev_xmit_lock_key);\r\n}\r\nstatic void batadv_set_lockdep_class(struct net_device *dev)\r\n{\r\nlockdep_set_class(&dev->addr_list_lock, &batadv_netdev_addr_lock_key);\r\nnetdev_for_each_tx_queue(dev, batadv_set_lockdep_class_one, NULL);\r\n}\r\nstatic void batadv_softif_destroy_finish(struct work_struct *work)\r\n{\r\nstruct batadv_softif_vlan *vlan;\r\nstruct batadv_priv *bat_priv;\r\nstruct net_device *soft_iface;\r\nbat_priv = container_of(work, struct batadv_priv,\r\ncleanup_work);\r\nsoft_iface = bat_priv->soft_iface;\r\nvlan = batadv_softif_vlan_get(bat_priv, BATADV_NO_FLAGS);\r\nif (vlan) {\r\nbatadv_softif_destroy_vlan(bat_priv, vlan);\r\nbatadv_softif_vlan_free_ref(vlan);\r\n}\r\nbatadv_sysfs_del_meshif(soft_iface);\r\nunregister_netdev(soft_iface);\r\n}\r\nstatic int batadv_softif_init_late(struct net_device *dev)\r\n{\r\nstruct batadv_priv *bat_priv;\r\nu32 random_seqno;\r\nint ret;\r\nsize_t cnt_len = sizeof(u64) * BATADV_CNT_NUM;\r\nbatadv_set_lockdep_class(dev);\r\nbat_priv = netdev_priv(dev);\r\nbat_priv->soft_iface = dev;\r\nINIT_WORK(&bat_priv->cleanup_work, batadv_softif_destroy_finish);\r\nbat_priv->bat_counters = __alloc_percpu(cnt_len, __alignof__(u64));\r\nif (!bat_priv->bat_counters)\r\nreturn -ENOMEM;\r\natomic_set(&bat_priv->aggregated_ogms, 1);\r\natomic_set(&bat_priv->bonding, 0);\r\n#ifdef CONFIG_BATMAN_ADV_BLA\r\natomic_set(&bat_priv->bridge_loop_avoidance, 1);\r\n#endif\r\n#ifdef CONFIG_BATMAN_ADV_DAT\r\natomic_set(&bat_priv->distributed_arp_table, 1);\r\n#endif\r\n#ifdef CONFIG_BATMAN_ADV_MCAST\r\nbat_priv->mcast.flags = BATADV_NO_FLAGS;\r\natomic_set(&bat_priv->multicast_mode, 1);\r\natomic_set(&bat_priv->mcast.num_disabled, 0);\r\natomic_set(&bat_priv->mcast.num_want_all_unsnoopables, 0);\r\natomic_set(&bat_priv->mcast.num_want_all_ipv4, 0);\r\natomic_set(&bat_priv->mcast.num_want_all_ipv6, 0);\r\n#endif\r\natomic_set(&bat_priv->gw_mode, BATADV_GW_MODE_OFF);\r\natomic_set(&bat_priv->gw_sel_class, 20);\r\natomic_set(&bat_priv->gw.bandwidth_down, 100);\r\natomic_set(&bat_priv->gw.bandwidth_up, 20);\r\natomic_set(&bat_priv->orig_interval, 1000);\r\natomic_set(&bat_priv->hop_penalty, 30);\r\n#ifdef CONFIG_BATMAN_ADV_DEBUG\r\natomic_set(&bat_priv->log_level, 0);\r\n#endif\r\natomic_set(&bat_priv->fragmentation, 1);\r\natomic_set(&bat_priv->packet_size_max, ETH_DATA_LEN);\r\natomic_set(&bat_priv->bcast_queue_left, BATADV_BCAST_QUEUE_LEN);\r\natomic_set(&bat_priv->batman_queue_left, BATADV_BATMAN_QUEUE_LEN);\r\natomic_set(&bat_priv->mesh_state, BATADV_MESH_INACTIVE);\r\natomic_set(&bat_priv->bcast_seqno, 1);\r\natomic_set(&bat_priv->tt.vn, 0);\r\natomic_set(&bat_priv->tt.local_changes, 0);\r\natomic_set(&bat_priv->tt.ogm_append_cnt, 0);\r\n#ifdef CONFIG_BATMAN_ADV_BLA\r\natomic_set(&bat_priv->bla.num_requests, 0);\r\n#endif\r\nbat_priv->tt.last_changeset = NULL;\r\nbat_priv->tt.last_changeset_len = 0;\r\nbat_priv->isolation_mark = 0;\r\nbat_priv->isolation_mark_mask = 0;\r\nget_random_bytes(&random_seqno, sizeof(random_seqno));\r\natomic_set(&bat_priv->frag_seqno, random_seqno);\r\nbat_priv->primary_if = NULL;\r\nbat_priv->num_ifaces = 0;\r\nbatadv_nc_init_bat_priv(bat_priv);\r\nret = batadv_algo_select(bat_priv, batadv_routing_algo);\r\nif (ret < 0)\r\ngoto free_bat_counters;\r\nret = batadv_debugfs_add_meshif(dev);\r\nif (ret < 0)\r\ngoto free_bat_counters;\r\nret = batadv_mesh_init(dev);\r\nif (ret < 0)\r\ngoto unreg_debugfs;\r\nreturn 0;\r\nunreg_debugfs:\r\nbatadv_debugfs_del_meshif(dev);\r\nfree_bat_counters:\r\nfree_percpu(bat_priv->bat_counters);\r\nbat_priv->bat_counters = NULL;\r\nreturn ret;\r\n}\r\nstatic int batadv_softif_slave_add(struct net_device *dev,\r\nstruct net_device *slave_dev)\r\n{\r\nstruct batadv_hard_iface *hard_iface;\r\nint ret = -EINVAL;\r\nhard_iface = batadv_hardif_get_by_netdev(slave_dev);\r\nif (!hard_iface || hard_iface->soft_iface)\r\ngoto out;\r\nret = batadv_hardif_enable_interface(hard_iface, dev->name);\r\nout:\r\nif (hard_iface)\r\nbatadv_hardif_free_ref(hard_iface);\r\nreturn ret;\r\n}\r\nstatic int batadv_softif_slave_del(struct net_device *dev,\r\nstruct net_device *slave_dev)\r\n{\r\nstruct batadv_hard_iface *hard_iface;\r\nint ret = -EINVAL;\r\nhard_iface = batadv_hardif_get_by_netdev(slave_dev);\r\nif (!hard_iface || hard_iface->soft_iface != dev)\r\ngoto out;\r\nbatadv_hardif_disable_interface(hard_iface, BATADV_IF_CLEANUP_KEEP);\r\nret = 0;\r\nout:\r\nif (hard_iface)\r\nbatadv_hardif_free_ref(hard_iface);\r\nreturn ret;\r\n}\r\nstatic void batadv_softif_free(struct net_device *dev)\r\n{\r\nbatadv_debugfs_del_meshif(dev);\r\nbatadv_mesh_free(dev);\r\nrcu_barrier();\r\nfree_netdev(dev);\r\n}\r\nstatic void batadv_softif_init_early(struct net_device *dev)\r\n{\r\nstruct batadv_priv *priv = netdev_priv(dev);\r\nether_setup(dev);\r\ndev->netdev_ops = &batadv_netdev_ops;\r\ndev->destructor = batadv_softif_free;\r\ndev->features |= NETIF_F_HW_VLAN_CTAG_FILTER;\r\ndev->priv_flags |= IFF_NO_QUEUE;\r\ndev->mtu = ETH_DATA_LEN;\r\neth_hw_addr_random(dev);\r\ndev->ethtool_ops = &batadv_ethtool_ops;\r\nmemset(priv, 0, sizeof(*priv));\r\n}\r\nstruct net_device *batadv_softif_create(const char *name)\r\n{\r\nstruct net_device *soft_iface;\r\nint ret;\r\nsoft_iface = alloc_netdev(sizeof(struct batadv_priv), name,\r\nNET_NAME_UNKNOWN, batadv_softif_init_early);\r\nif (!soft_iface)\r\nreturn NULL;\r\nsoft_iface->rtnl_link_ops = &batadv_link_ops;\r\nret = register_netdevice(soft_iface);\r\nif (ret < 0) {\r\npr_err("Unable to register the batman interface '%s': %i\n",\r\nname, ret);\r\nfree_netdev(soft_iface);\r\nreturn NULL;\r\n}\r\nreturn soft_iface;\r\n}\r\nvoid batadv_softif_destroy_sysfs(struct net_device *soft_iface)\r\n{\r\nstruct batadv_priv *bat_priv = netdev_priv(soft_iface);\r\nqueue_work(batadv_event_workqueue, &bat_priv->cleanup_work);\r\n}\r\nstatic void batadv_softif_destroy_netlink(struct net_device *soft_iface,\r\nstruct list_head *head)\r\n{\r\nstruct batadv_hard_iface *hard_iface;\r\nlist_for_each_entry(hard_iface, &batadv_hardif_list, list) {\r\nif (hard_iface->soft_iface == soft_iface)\r\nbatadv_hardif_disable_interface(hard_iface,\r\nBATADV_IF_CLEANUP_KEEP);\r\n}\r\nbatadv_sysfs_del_meshif(soft_iface);\r\nunregister_netdevice_queue(soft_iface, head);\r\n}\r\nint batadv_softif_is_valid(const struct net_device *net_dev)\r\n{\r\nif (net_dev->netdev_ops->ndo_start_xmit == batadv_interface_tx)\r\nreturn 1;\r\nreturn 0;\r\n}\r\nstatic int batadv_get_settings(struct net_device *dev, struct ethtool_cmd *cmd)\r\n{\r\ncmd->supported = 0;\r\ncmd->advertising = 0;\r\nethtool_cmd_speed_set(cmd, SPEED_10);\r\ncmd->duplex = DUPLEX_FULL;\r\ncmd->port = PORT_TP;\r\ncmd->phy_address = 0;\r\ncmd->transceiver = XCVR_INTERNAL;\r\ncmd->autoneg = AUTONEG_DISABLE;\r\ncmd->maxtxpkt = 0;\r\ncmd->maxrxpkt = 0;\r\nreturn 0;\r\n}\r\nstatic void batadv_get_drvinfo(struct net_device *dev,\r\nstruct ethtool_drvinfo *info)\r\n{\r\nstrlcpy(info->driver, "B.A.T.M.A.N. advanced", sizeof(info->driver));\r\nstrlcpy(info->version, BATADV_SOURCE_VERSION, sizeof(info->version));\r\nstrlcpy(info->fw_version, "N/A", sizeof(info->fw_version));\r\nstrlcpy(info->bus_info, "batman", sizeof(info->bus_info));\r\n}\r\nstatic u32 batadv_get_msglevel(struct net_device *dev)\r\n{\r\nreturn -EOPNOTSUPP;\r\n}\r\nstatic void batadv_set_msglevel(struct net_device *dev, u32 value)\r\n{\r\n}\r\nstatic u32 batadv_get_link(struct net_device *dev)\r\n{\r\nreturn 1;\r\n}\r\nstatic void batadv_get_strings(struct net_device *dev, u32 stringset, u8 *data)\r\n{\r\nif (stringset == ETH_SS_STATS)\r\nmemcpy(data, batadv_counters_strings,\r\nsizeof(batadv_counters_strings));\r\n}\r\nstatic void batadv_get_ethtool_stats(struct net_device *dev,\r\nstruct ethtool_stats *stats, u64 *data)\r\n{\r\nstruct batadv_priv *bat_priv = netdev_priv(dev);\r\nint i;\r\nfor (i = 0; i < BATADV_CNT_NUM; i++)\r\ndata[i] = batadv_sum_counter(bat_priv, i);\r\n}\r\nstatic int batadv_get_sset_count(struct net_device *dev, int stringset)\r\n{\r\nif (stringset == ETH_SS_STATS)\r\nreturn BATADV_CNT_NUM;\r\nreturn -EOPNOTSUPP;\r\n}
