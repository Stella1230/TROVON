static u32 __init kirkwood_get_tclk_freq(void __iomem *sar)\r\n{\r\nu32 opt = (readl(sar) >> SAR_KIRKWOOD_TCLK_FREQ) &\r\nSAR_KIRKWOOD_TCLK_FREQ_MASK;\r\nreturn (opt) ? 166666667 : 200000000;\r\n}\r\nstatic u32 __init kirkwood_get_cpu_freq(void __iomem *sar)\r\n{\r\nu32 opt = SAR_KIRKWOOD_CPU_FREQ(readl(sar));\r\nreturn kirkwood_cpu_freqs[opt];\r\n}\r\nstatic void __init kirkwood_get_clk_ratio(\r\nvoid __iomem *sar, int id, int *mult, int *div)\r\n{\r\nswitch (id) {\r\ncase KIRKWOOD_CPU_TO_L2:\r\n{\r\nu32 opt = SAR_KIRKWOOD_L2_RATIO(readl(sar));\r\n*mult = kirkwood_cpu_l2_ratios[opt][0];\r\n*div = kirkwood_cpu_l2_ratios[opt][1];\r\nbreak;\r\n}\r\ncase KIRKWOOD_CPU_TO_DDR:\r\n{\r\nu32 opt = (readl(sar) >> SAR_KIRKWOOD_DDR_RATIO) &\r\nSAR_KIRKWOOD_DDR_RATIO_MASK;\r\n*mult = kirkwood_cpu_ddr_ratios[opt][0];\r\n*div = kirkwood_cpu_ddr_ratios[opt][1];\r\nbreak;\r\n}\r\n}\r\n}\r\nstatic u32 __init mv88f6180_get_cpu_freq(void __iomem *sar)\r\n{\r\nu32 opt = (readl(sar) >> SAR_MV88F6180_CLK) & SAR_MV88F6180_CLK_MASK;\r\nreturn mv88f6180_cpu_freqs[opt];\r\n}\r\nstatic void __init mv88f6180_get_clk_ratio(\r\nvoid __iomem *sar, int id, int *mult, int *div)\r\n{\r\nswitch (id) {\r\ncase KIRKWOOD_CPU_TO_L2:\r\n{\r\n*mult = 1;\r\n*div = 2;\r\nbreak;\r\n}\r\ncase KIRKWOOD_CPU_TO_DDR:\r\n{\r\nu32 opt = (readl(sar) >> SAR_MV88F6180_CLK) &\r\nSAR_MV88F6180_CLK_MASK;\r\n*mult = mv88f6180_cpu_ddr_ratios[opt][0];\r\n*div = mv88f6180_cpu_ddr_ratios[opt][1];\r\nbreak;\r\n}\r\n}\r\n}\r\nstatic struct clk *clk_muxing_get_src(\r\nstruct of_phandle_args *clkspec, void *data)\r\n{\r\nstruct clk_muxing_ctrl *ctrl = (struct clk_muxing_ctrl *)data;\r\nint n;\r\nif (clkspec->args_count < 1)\r\nreturn ERR_PTR(-EINVAL);\r\nfor (n = 0; n < ctrl->num_muxes; n++) {\r\nstruct clk_mux *mux =\r\nto_clk_mux(__clk_get_hw(ctrl->muxes[n]));\r\nif (clkspec->args[0] == mux->shift)\r\nreturn ctrl->muxes[n];\r\n}\r\nreturn ERR_PTR(-ENODEV);\r\n}\r\nstatic void __init kirkwood_clk_muxing_setup(struct device_node *np,\r\nconst struct clk_muxing_soc_desc *desc)\r\n{\r\nstruct clk_muxing_ctrl *ctrl;\r\nvoid __iomem *base;\r\nint n;\r\nbase = of_iomap(np, 0);\r\nif (WARN_ON(!base))\r\nreturn;\r\nctrl = kzalloc(sizeof(*ctrl), GFP_KERNEL);\r\nif (WARN_ON(!ctrl))\r\ngoto ctrl_out;\r\nctrl->lock = &ctrl_gating_lock;\r\nfor (n = 0; desc[n].name;)\r\nn++;\r\nctrl->num_muxes = n;\r\nctrl->muxes = kcalloc(ctrl->num_muxes, sizeof(struct clk *),\r\nGFP_KERNEL);\r\nif (WARN_ON(!ctrl->muxes))\r\ngoto muxes_out;\r\nfor (n = 0; n < ctrl->num_muxes; n++) {\r\nctrl->muxes[n] = clk_register_mux(NULL, desc[n].name,\r\ndesc[n].parents, desc[n].num_parents,\r\ndesc[n].flags, base, desc[n].shift,\r\ndesc[n].width, desc[n].flags, ctrl->lock);\r\nWARN_ON(IS_ERR(ctrl->muxes[n]));\r\n}\r\nof_clk_add_provider(np, clk_muxing_get_src, ctrl);\r\nreturn;\r\nmuxes_out:\r\nkfree(ctrl);\r\nctrl_out:\r\niounmap(base);\r\n}\r\nstatic void __init kirkwood_clk_init(struct device_node *np)\r\n{\r\nstruct device_node *cgnp =\r\nof_find_compatible_node(NULL, NULL, "marvell,kirkwood-gating-clock");\r\nif (of_device_is_compatible(np, "marvell,mv88f6180-core-clock"))\r\nmvebu_coreclk_setup(np, &mv88f6180_coreclks);\r\nelse\r\nmvebu_coreclk_setup(np, &kirkwood_coreclks);\r\nif (cgnp) {\r\nmvebu_clk_gating_setup(cgnp, kirkwood_gating_desc);\r\nkirkwood_clk_muxing_setup(cgnp, kirkwood_mux_desc);\r\n}\r\n}
