static void fail(const char *fmt, ...)\r\n{\r\nva_list ap;\r\nfailed = 1;\r\nfprintf(stderr, "%s: ", argv0);\r\nva_start(ap, fmt);\r\nvfprintf(stderr, fmt, ap);\r\nva_end(ap);\r\nexit(EXIT_FAILURE);\r\n}\r\nstatic void cleanup(void)\r\n{\r\nif (failed && outfile != NULL)\r\nunlink(outfile);\r\n}\r\nstatic Elf32_Word read_elf_word(Elf32_Word word, bool swap)\r\n{\r\nreturn swap ? swab32(word) : word;\r\n}\r\nstatic Elf32_Half read_elf_half(Elf32_Half half, bool swap)\r\n{\r\nreturn swap ? swab16(half) : half;\r\n}\r\nstatic void write_elf_word(Elf32_Word val, Elf32_Word *dst, bool swap)\r\n{\r\n*dst = swap ? swab32(val) : val;\r\n}\r\nint main(int argc, char **argv)\r\n{\r\nconst Elf32_Ehdr *inhdr;\r\nbool clear_soft_float;\r\nconst char *infile;\r\nElf32_Word e_flags;\r\nconst void *inbuf;\r\nstruct stat stat;\r\nvoid *outbuf;\r\nbool swap;\r\nint outfd;\r\nint infd;\r\natexit(cleanup);\r\nargv0 = argv[0];\r\nif (argc != 3)\r\nfail("Usage: %s [infile] [outfile]\n", argv[0]);\r\ninfile = argv[1];\r\noutfile = argv[2];\r\ninfd = open(infile, O_RDONLY);\r\nif (infd < 0)\r\nfail("Cannot open %s: %s\n", infile, strerror(errno));\r\nif (fstat(infd, &stat) != 0)\r\nfail("Failed stat for %s: %s\n", infile, strerror(errno));\r\ninbuf = mmap(NULL, stat.st_size, PROT_READ, MAP_PRIVATE, infd, 0);\r\nif (inbuf == MAP_FAILED)\r\nfail("Failed to map %s: %s\n", infile, strerror(errno));\r\nclose(infd);\r\ninhdr = inbuf;\r\nif (memcmp(&inhdr->e_ident, ELFMAG, SELFMAG) != 0)\r\nfail("Not an ELF file\n");\r\nif (inhdr->e_ident[EI_CLASS] != ELFCLASS32)\r\nfail("Unsupported ELF class\n");\r\nswap = inhdr->e_ident[EI_DATA] != HOST_ORDER;\r\nif (read_elf_half(inhdr->e_type, swap) != ET_DYN)\r\nfail("Not a shared object\n");\r\nif (read_elf_half(inhdr->e_machine, swap) != EM_ARM)\r\nfail("Unsupported architecture %#x\n", inhdr->e_machine);\r\ne_flags = read_elf_word(inhdr->e_flags, swap);\r\nif (EF_ARM_EABI_VERSION(e_flags) != EF_ARM_EABI_VER5) {\r\nfail("Unsupported EABI version %#x\n",\r\nEF_ARM_EABI_VERSION(e_flags));\r\n}\r\nif (e_flags & EF_ARM_ABI_FLOAT_HARD)\r\nfail("Unexpected hard-float flag set in e_flags\n");\r\nclear_soft_float = !!(e_flags & EF_ARM_ABI_FLOAT_SOFT);\r\noutfd = open(outfile, O_RDWR | O_CREAT | O_TRUNC, S_IRUSR | S_IWUSR);\r\nif (outfd < 0)\r\nfail("Cannot open %s: %s\n", outfile, strerror(errno));\r\nif (ftruncate(outfd, stat.st_size) != 0)\r\nfail("Cannot truncate %s: %s\n", outfile, strerror(errno));\r\noutbuf = mmap(NULL, stat.st_size, PROT_READ | PROT_WRITE, MAP_SHARED,\r\noutfd, 0);\r\nif (outbuf == MAP_FAILED)\r\nfail("Failed to map %s: %s\n", outfile, strerror(errno));\r\nclose(outfd);\r\nmemcpy(outbuf, inbuf, stat.st_size);\r\nif (clear_soft_float) {\r\nElf32_Ehdr *outhdr;\r\nouthdr = outbuf;\r\ne_flags &= ~EF_ARM_ABI_FLOAT_SOFT;\r\nwrite_elf_word(e_flags, &outhdr->e_flags, swap);\r\n}\r\nif (msync(outbuf, stat.st_size, MS_SYNC) != 0)\r\nfail("Failed to sync %s: %s\n", outfile, strerror(errno));\r\nreturn EXIT_SUCCESS;\r\n}
