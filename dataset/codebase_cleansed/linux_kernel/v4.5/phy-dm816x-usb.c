static int dm816x_usb_phy_set_host(struct usb_otg *otg, struct usb_bus *host)\r\n{\r\notg->host = host;\r\nif (!host)\r\notg->state = OTG_STATE_UNDEFINED;\r\nreturn 0;\r\n}\r\nstatic int dm816x_usb_phy_set_peripheral(struct usb_otg *otg,\r\nstruct usb_gadget *gadget)\r\n{\r\notg->gadget = gadget;\r\nif (!gadget)\r\notg->state = OTG_STATE_UNDEFINED;\r\nreturn 0;\r\n}\r\nstatic int dm816x_usb_phy_init(struct phy *x)\r\n{\r\nstruct dm816x_usb_phy *phy = phy_get_drvdata(x);\r\nunsigned int val;\r\nint error;\r\nif (clk_get_rate(phy->refclk) != 24000000)\r\ndev_warn(phy->dev, "nonstandard phy refclk\n");\r\nerror = regmap_update_bits(phy->syscon, phy->usb_ctrl,\r\nDM816X_USB_CTRL_PHYCLKSRC |\r\nDM816X_USB_CTRL_PHYSLEEP1 |\r\nDM816X_USB_CTRL_PHYSLEEP0,\r\n0);\r\nregmap_read(phy->syscon, phy->usb_ctrl, &val);\r\nif ((val & 3) != 0)\r\ndev_info(phy->dev,\r\n"Working dm816x USB_CTRL! (0x%08x)\n",\r\nval);\r\nregmap_read(phy->syscon, phy->usbphy_ctrl, &val);\r\nval |= DM816X_USBPHY_CTRL_TXRISETUNE |\r\nDM816X_USBPHY_CTRL_TXVREFTUNE |\r\nDM816X_USBPHY_CTRL_TXPREEMTUNE;\r\nregmap_write(phy->syscon, phy->usbphy_ctrl, val);\r\nreturn 0;\r\n}\r\nstatic int dm816x_usb_phy_runtime_suspend(struct device *dev)\r\n{\r\nstruct dm816x_usb_phy *phy = dev_get_drvdata(dev);\r\nunsigned int mask, val;\r\nint error = 0;\r\nmask = BIT(phy->instance);\r\nval = ~BIT(phy->instance);\r\nerror = regmap_update_bits(phy->syscon, phy->usb_ctrl,\r\nmask, val);\r\nif (error)\r\ndev_err(phy->dev, "phy%i failed to power off\n",\r\nphy->instance);\r\nclk_disable(phy->refclk);\r\nreturn 0;\r\n}\r\nstatic int dm816x_usb_phy_runtime_resume(struct device *dev)\r\n{\r\nstruct dm816x_usb_phy *phy = dev_get_drvdata(dev);\r\nunsigned int mask, val;\r\nint error;\r\nerror = clk_enable(phy->refclk);\r\nif (error)\r\nreturn error;\r\nmask = BIT(phy->instance);\r\nval = BIT(phy->instance);\r\nerror = regmap_update_bits(phy->syscon, phy->usb_ctrl,\r\nmask, val);\r\nif (error) {\r\ndev_err(phy->dev, "phy%i failed to power on\n",\r\nphy->instance);\r\nclk_disable(phy->refclk);\r\nreturn error;\r\n}\r\nreturn 0;\r\n}\r\nstatic int dm816x_usb_phy_probe(struct platform_device *pdev)\r\n{\r\nstruct dm816x_usb_phy *phy;\r\nstruct resource *res;\r\nstruct phy *generic_phy;\r\nstruct phy_provider *phy_provider;\r\nstruct usb_otg *otg;\r\nconst struct of_device_id *of_id;\r\nconst struct usb_phy_data *phy_data;\r\nint error;\r\nof_id = of_match_device(of_match_ptr(dm816x_usb_phy_id_table),\r\n&pdev->dev);\r\nif (!of_id)\r\nreturn -EINVAL;\r\nphy = devm_kzalloc(&pdev->dev, sizeof(*phy), GFP_KERNEL);\r\nif (!phy)\r\nreturn -ENOMEM;\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nif (!res)\r\nreturn -ENOENT;\r\nphy->syscon = syscon_regmap_lookup_by_phandle(pdev->dev.of_node,\r\n"syscon");\r\nif (IS_ERR(phy->syscon))\r\nreturn PTR_ERR(phy->syscon);\r\nphy->usb_ctrl = 0x20;\r\nphy->usbphy_ctrl = (res->start & 0xff) + 4;\r\nif (phy->usbphy_ctrl == 0x2c)\r\nphy->instance = 1;\r\nphy_data = of_id->data;\r\notg = devm_kzalloc(&pdev->dev, sizeof(*otg), GFP_KERNEL);\r\nif (!otg)\r\nreturn -ENOMEM;\r\nphy->dev = &pdev->dev;\r\nphy->phy.dev = phy->dev;\r\nphy->phy.label = "dm8168_usb_phy";\r\nphy->phy.otg = otg;\r\nphy->phy.type = USB_PHY_TYPE_USB2;\r\notg->set_host = dm816x_usb_phy_set_host;\r\notg->set_peripheral = dm816x_usb_phy_set_peripheral;\r\notg->usb_phy = &phy->phy;\r\nplatform_set_drvdata(pdev, phy);\r\nphy->refclk = devm_clk_get(phy->dev, "refclk");\r\nif (IS_ERR(phy->refclk))\r\nreturn PTR_ERR(phy->refclk);\r\nerror = clk_prepare(phy->refclk);\r\nif (error)\r\nreturn error;\r\npm_runtime_enable(phy->dev);\r\ngeneric_phy = devm_phy_create(phy->dev, NULL, &ops);\r\nif (IS_ERR(generic_phy))\r\nreturn PTR_ERR(generic_phy);\r\nphy_set_drvdata(generic_phy, phy);\r\nphy_provider = devm_of_phy_provider_register(phy->dev,\r\nof_phy_simple_xlate);\r\nif (IS_ERR(phy_provider))\r\nreturn PTR_ERR(phy_provider);\r\nusb_add_phy_dev(&phy->phy);\r\nreturn 0;\r\n}\r\nstatic int dm816x_usb_phy_remove(struct platform_device *pdev)\r\n{\r\nstruct dm816x_usb_phy *phy = platform_get_drvdata(pdev);\r\nusb_remove_phy(&phy->phy);\r\npm_runtime_disable(phy->dev);\r\nclk_unprepare(phy->refclk);\r\nreturn 0;\r\n}
