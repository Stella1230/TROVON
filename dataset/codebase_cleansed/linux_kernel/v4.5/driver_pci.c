u32 bcma_pcie_read(struct bcma_drv_pci *pc, u32 address)\r\n{\r\npcicore_write32(pc, BCMA_CORE_PCI_PCIEIND_ADDR, address);\r\npcicore_read32(pc, BCMA_CORE_PCI_PCIEIND_ADDR);\r\nreturn pcicore_read32(pc, BCMA_CORE_PCI_PCIEIND_DATA);\r\n}\r\nstatic void bcma_pcie_write(struct bcma_drv_pci *pc, u32 address, u32 data)\r\n{\r\npcicore_write32(pc, BCMA_CORE_PCI_PCIEIND_ADDR, address);\r\npcicore_read32(pc, BCMA_CORE_PCI_PCIEIND_ADDR);\r\npcicore_write32(pc, BCMA_CORE_PCI_PCIEIND_DATA, data);\r\n}\r\nstatic void bcma_pcie_mdio_set_phy(struct bcma_drv_pci *pc, u16 phy)\r\n{\r\nu32 v;\r\nint i;\r\nv = BCMA_CORE_PCI_MDIODATA_START;\r\nv |= BCMA_CORE_PCI_MDIODATA_WRITE;\r\nv |= (BCMA_CORE_PCI_MDIODATA_DEV_ADDR <<\r\nBCMA_CORE_PCI_MDIODATA_DEVADDR_SHF);\r\nv |= (BCMA_CORE_PCI_MDIODATA_BLK_ADDR <<\r\nBCMA_CORE_PCI_MDIODATA_REGADDR_SHF);\r\nv |= BCMA_CORE_PCI_MDIODATA_TA;\r\nv |= (phy << 4);\r\npcicore_write32(pc, BCMA_CORE_PCI_MDIO_DATA, v);\r\nudelay(10);\r\nfor (i = 0; i < 200; i++) {\r\nv = pcicore_read32(pc, BCMA_CORE_PCI_MDIO_CONTROL);\r\nif (v & BCMA_CORE_PCI_MDIOCTL_ACCESS_DONE)\r\nbreak;\r\nusleep_range(1000, 2000);\r\n}\r\n}\r\nstatic u16 bcma_pcie_mdio_read(struct bcma_drv_pci *pc, u16 device, u8 address)\r\n{\r\nint max_retries = 10;\r\nu16 ret = 0;\r\nu32 v;\r\nint i;\r\nv = BCMA_CORE_PCI_MDIOCTL_PREAM_EN;\r\nv |= BCMA_CORE_PCI_MDIOCTL_DIVISOR_VAL;\r\npcicore_write32(pc, BCMA_CORE_PCI_MDIO_CONTROL, v);\r\nif (pc->core->id.rev >= 10) {\r\nmax_retries = 200;\r\nbcma_pcie_mdio_set_phy(pc, device);\r\nv = (BCMA_CORE_PCI_MDIODATA_DEV_ADDR <<\r\nBCMA_CORE_PCI_MDIODATA_DEVADDR_SHF);\r\nv |= (address << BCMA_CORE_PCI_MDIODATA_REGADDR_SHF);\r\n} else {\r\nv = (device << BCMA_CORE_PCI_MDIODATA_DEVADDR_SHF_OLD);\r\nv |= (address << BCMA_CORE_PCI_MDIODATA_REGADDR_SHF_OLD);\r\n}\r\nv = BCMA_CORE_PCI_MDIODATA_START;\r\nv |= BCMA_CORE_PCI_MDIODATA_READ;\r\nv |= BCMA_CORE_PCI_MDIODATA_TA;\r\npcicore_write32(pc, BCMA_CORE_PCI_MDIO_DATA, v);\r\nudelay(10);\r\nfor (i = 0; i < max_retries; i++) {\r\nv = pcicore_read32(pc, BCMA_CORE_PCI_MDIO_CONTROL);\r\nif (v & BCMA_CORE_PCI_MDIOCTL_ACCESS_DONE) {\r\nudelay(10);\r\nret = pcicore_read32(pc, BCMA_CORE_PCI_MDIO_DATA);\r\nbreak;\r\n}\r\nusleep_range(1000, 2000);\r\n}\r\npcicore_write32(pc, BCMA_CORE_PCI_MDIO_CONTROL, 0);\r\nreturn ret;\r\n}\r\nstatic void bcma_pcie_mdio_write(struct bcma_drv_pci *pc, u16 device,\r\nu8 address, u16 data)\r\n{\r\nint max_retries = 10;\r\nu32 v;\r\nint i;\r\nv = BCMA_CORE_PCI_MDIOCTL_PREAM_EN;\r\nv |= BCMA_CORE_PCI_MDIOCTL_DIVISOR_VAL;\r\npcicore_write32(pc, BCMA_CORE_PCI_MDIO_CONTROL, v);\r\nif (pc->core->id.rev >= 10) {\r\nmax_retries = 200;\r\nbcma_pcie_mdio_set_phy(pc, device);\r\nv = (BCMA_CORE_PCI_MDIODATA_DEV_ADDR <<\r\nBCMA_CORE_PCI_MDIODATA_DEVADDR_SHF);\r\nv |= (address << BCMA_CORE_PCI_MDIODATA_REGADDR_SHF);\r\n} else {\r\nv = (device << BCMA_CORE_PCI_MDIODATA_DEVADDR_SHF_OLD);\r\nv |= (address << BCMA_CORE_PCI_MDIODATA_REGADDR_SHF_OLD);\r\n}\r\nv = BCMA_CORE_PCI_MDIODATA_START;\r\nv |= BCMA_CORE_PCI_MDIODATA_WRITE;\r\nv |= BCMA_CORE_PCI_MDIODATA_TA;\r\nv |= data;\r\npcicore_write32(pc, BCMA_CORE_PCI_MDIO_DATA, v);\r\nudelay(10);\r\nfor (i = 0; i < max_retries; i++) {\r\nv = pcicore_read32(pc, BCMA_CORE_PCI_MDIO_CONTROL);\r\nif (v & BCMA_CORE_PCI_MDIOCTL_ACCESS_DONE)\r\nbreak;\r\nusleep_range(1000, 2000);\r\n}\r\npcicore_write32(pc, BCMA_CORE_PCI_MDIO_CONTROL, 0);\r\n}\r\nstatic u16 bcma_pcie_mdio_writeread(struct bcma_drv_pci *pc, u16 device,\r\nu8 address, u16 data)\r\n{\r\nbcma_pcie_mdio_write(pc, device, address, data);\r\nreturn bcma_pcie_mdio_read(pc, device, address);\r\n}\r\nstatic void bcma_core_pci_fixcfg(struct bcma_drv_pci *pc)\r\n{\r\nstruct bcma_device *core = pc->core;\r\nu16 val16, core_index;\r\nuint regoff;\r\nregoff = BCMA_CORE_PCI_SPROM(BCMA_CORE_PCI_SPROM_PI_OFFSET);\r\ncore_index = (u16)core->core_index;\r\nval16 = pcicore_read16(pc, regoff);\r\nif (((val16 & BCMA_CORE_PCI_SPROM_PI_MASK) >> BCMA_CORE_PCI_SPROM_PI_SHIFT)\r\n!= core_index) {\r\nval16 = (core_index << BCMA_CORE_PCI_SPROM_PI_SHIFT) |\r\n(val16 & ~BCMA_CORE_PCI_SPROM_PI_MASK);\r\npcicore_write16(pc, regoff, val16);\r\n}\r\n}\r\nvoid bcma_core_pci_early_init(struct bcma_drv_pci *pc)\r\n{\r\nif (pc->early_setup_done)\r\nreturn;\r\npc->hostmode = bcma_core_pci_is_in_hostmode(pc);\r\nif (pc->hostmode)\r\ngoto out;\r\nbcma_core_pci_fixcfg(pc);\r\nout:\r\npc->early_setup_done = true;\r\n}\r\nstatic u8 bcma_pcicore_polarity_workaround(struct bcma_drv_pci *pc)\r\n{\r\nu32 tmp;\r\ntmp = bcma_pcie_read(pc, BCMA_CORE_PCI_PLP_STATUSREG);\r\nif (tmp & BCMA_CORE_PCI_PLP_POLARITYINV_STAT)\r\nreturn BCMA_CORE_PCI_SERDES_RX_CTRL_FORCE |\r\nBCMA_CORE_PCI_SERDES_RX_CTRL_POLARITY;\r\nelse\r\nreturn BCMA_CORE_PCI_SERDES_RX_CTRL_FORCE;\r\n}\r\nstatic void bcma_pcicore_serdes_workaround(struct bcma_drv_pci *pc)\r\n{\r\nu16 tmp;\r\nbcma_pcie_mdio_write(pc, BCMA_CORE_PCI_MDIODATA_DEV_RX,\r\nBCMA_CORE_PCI_SERDES_RX_CTRL,\r\nbcma_pcicore_polarity_workaround(pc));\r\ntmp = bcma_pcie_mdio_read(pc, BCMA_CORE_PCI_MDIODATA_DEV_PLL,\r\nBCMA_CORE_PCI_SERDES_PLL_CTRL);\r\nif (tmp & BCMA_CORE_PCI_PLL_CTRL_FREQDET_EN)\r\nbcma_pcie_mdio_write(pc, BCMA_CORE_PCI_MDIODATA_DEV_PLL,\r\nBCMA_CORE_PCI_SERDES_PLL_CTRL,\r\ntmp & ~BCMA_CORE_PCI_PLL_CTRL_FREQDET_EN);\r\n}\r\nstatic void bcma_core_pci_config_fixup(struct bcma_drv_pci *pc)\r\n{\r\nu16 val16;\r\nuint regoff;\r\nregoff = BCMA_CORE_PCI_SPROM(BCMA_CORE_PCI_SPROM_MISC_CONFIG);\r\nval16 = pcicore_read16(pc, regoff);\r\nif (!(val16 & BCMA_CORE_PCI_SPROM_L23READY_EXIT_NOPERST)) {\r\nval16 |= BCMA_CORE_PCI_SPROM_L23READY_EXIT_NOPERST;\r\npcicore_write16(pc, regoff, val16);\r\n}\r\n}\r\nstatic void bcma_core_pci_clientmode_init(struct bcma_drv_pci *pc)\r\n{\r\nbcma_pcicore_serdes_workaround(pc);\r\nbcma_core_pci_config_fixup(pc);\r\n}\r\nvoid bcma_core_pci_init(struct bcma_drv_pci *pc)\r\n{\r\nif (pc->setup_done)\r\nreturn;\r\nbcma_core_pci_early_init(pc);\r\nif (pc->hostmode)\r\nbcma_core_pci_hostmode_init(pc);\r\nelse\r\nbcma_core_pci_clientmode_init(pc);\r\n}\r\nvoid bcma_core_pci_power_save(struct bcma_bus *bus, bool up)\r\n{\r\nstruct bcma_drv_pci *pc;\r\nu16 data;\r\nif (bus->hosttype != BCMA_HOSTTYPE_PCI)\r\nreturn;\r\npc = &bus->drv_pci[0];\r\nif (pc->core->id.rev >= 15 && pc->core->id.rev <= 20) {\r\ndata = up ? 0x74 : 0x7C;\r\nbcma_pcie_mdio_writeread(pc, BCMA_CORE_PCI_MDIO_BLK1,\r\nBCMA_CORE_PCI_MDIO_BLK1_MGMT1, 0x7F64);\r\nbcma_pcie_mdio_writeread(pc, BCMA_CORE_PCI_MDIO_BLK1,\r\nBCMA_CORE_PCI_MDIO_BLK1_MGMT3, data);\r\n} else if (pc->core->id.rev >= 21 && pc->core->id.rev <= 22) {\r\ndata = up ? 0x75 : 0x7D;\r\nbcma_pcie_mdio_writeread(pc, BCMA_CORE_PCI_MDIO_BLK1,\r\nBCMA_CORE_PCI_MDIO_BLK1_MGMT1, 0x7E65);\r\nbcma_pcie_mdio_writeread(pc, BCMA_CORE_PCI_MDIO_BLK1,\r\nBCMA_CORE_PCI_MDIO_BLK1_MGMT3, data);\r\n}\r\n}\r\nstatic void bcma_core_pci_extend_L1timer(struct bcma_drv_pci *pc, bool extend)\r\n{\r\nu32 w;\r\nw = bcma_pcie_read(pc, BCMA_CORE_PCI_DLLP_PMTHRESHREG);\r\nif (extend)\r\nw |= BCMA_CORE_PCI_ASPMTIMER_EXTEND;\r\nelse\r\nw &= ~BCMA_CORE_PCI_ASPMTIMER_EXTEND;\r\nbcma_pcie_write(pc, BCMA_CORE_PCI_DLLP_PMTHRESHREG, w);\r\nbcma_pcie_read(pc, BCMA_CORE_PCI_DLLP_PMTHRESHREG);\r\n}\r\nvoid bcma_core_pci_up(struct bcma_drv_pci *pc)\r\n{\r\nbcma_core_pci_extend_L1timer(pc, true);\r\n}\r\nvoid bcma_core_pci_down(struct bcma_drv_pci *pc)\r\n{\r\nbcma_core_pci_extend_L1timer(pc, false);\r\n}
