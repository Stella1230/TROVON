void class_init_uuidlist(void)\r\n{\r\nINIT_LIST_HEAD(&g_uuid_list);\r\nspin_lock_init(&g_uuid_lock);\r\n}\r\nvoid class_exit_uuidlist(void)\r\n{\r\nclass_del_uuid(NULL);\r\n}\r\nint lustre_uuid_to_peer(const char *uuid, lnet_nid_t *peer_nid, int index)\r\n{\r\nstruct uuid_nid_data *data;\r\nstruct obd_uuid tmp;\r\nint rc = -ENOENT;\r\nobd_str2uuid(&tmp, uuid);\r\nspin_lock(&g_uuid_lock);\r\nlist_for_each_entry(data, &g_uuid_list, un_list) {\r\nif (obd_uuid_equals(&data->un_uuid, &tmp)) {\r\nif (index >= data->un_nid_count)\r\nbreak;\r\nrc = 0;\r\n*peer_nid = data->un_nids[index];\r\nbreak;\r\n}\r\n}\r\nspin_unlock(&g_uuid_lock);\r\nreturn rc;\r\n}\r\nint class_add_uuid(const char *uuid, __u64 nid)\r\n{\r\nstruct uuid_nid_data *data, *entry;\r\nint found = 0;\r\nLASSERT(nid != 0);\r\nif (strlen(uuid) > UUID_MAX - 1)\r\nreturn -EOVERFLOW;\r\ndata = kzalloc(sizeof(*data), GFP_NOFS);\r\nif (!data)\r\nreturn -ENOMEM;\r\nobd_str2uuid(&data->un_uuid, uuid);\r\ndata->un_nids[0] = nid;\r\ndata->un_nid_count = 1;\r\nspin_lock(&g_uuid_lock);\r\nlist_for_each_entry(entry, &g_uuid_list, un_list) {\r\nif (obd_uuid_equals(&entry->un_uuid, &data->un_uuid)) {\r\nint i;\r\nfound = 1;\r\nfor (i = 0; i < entry->un_nid_count; i++)\r\nif (nid == entry->un_nids[i])\r\nbreak;\r\nif (i == entry->un_nid_count) {\r\nLASSERT(entry->un_nid_count < NIDS_MAX);\r\nentry->un_nids[entry->un_nid_count++] = nid;\r\n}\r\nbreak;\r\n}\r\n}\r\nif (!found)\r\nlist_add(&data->un_list, &g_uuid_list);\r\nspin_unlock(&g_uuid_lock);\r\nif (found) {\r\nCDEBUG(D_INFO, "found uuid %s %s cnt=%d\n", uuid,\r\nlibcfs_nid2str(nid), entry->un_nid_count);\r\nkfree(data);\r\n} else {\r\nCDEBUG(D_INFO, "add uuid %s %s\n", uuid, libcfs_nid2str(nid));\r\n}\r\nreturn 0;\r\n}\r\nint class_del_uuid(const char *uuid)\r\n{\r\nLIST_HEAD(deathrow);\r\nstruct uuid_nid_data *data;\r\nspin_lock(&g_uuid_lock);\r\nif (uuid != NULL) {\r\nstruct obd_uuid tmp;\r\nobd_str2uuid(&tmp, uuid);\r\nlist_for_each_entry(data, &g_uuid_list, un_list) {\r\nif (obd_uuid_equals(&data->un_uuid, &tmp)) {\r\nlist_move(&data->un_list, &deathrow);\r\nbreak;\r\n}\r\n}\r\n} else\r\nlist_splice_init(&g_uuid_list, &deathrow);\r\nspin_unlock(&g_uuid_lock);\r\nif (uuid != NULL && list_empty(&deathrow)) {\r\nCDEBUG(D_INFO, "Try to delete a non-existent uuid %s\n", uuid);\r\nreturn -EINVAL;\r\n}\r\nwhile (!list_empty(&deathrow)) {\r\ndata = list_entry(deathrow.next, struct uuid_nid_data,\r\nun_list);\r\nlist_del(&data->un_list);\r\nCDEBUG(D_INFO, "del uuid %s %s/%d\n",\r\nobd_uuid2str(&data->un_uuid),\r\nlibcfs_nid2str(data->un_nids[0]),\r\ndata->un_nid_count);\r\nkfree(data);\r\n}\r\nreturn 0;\r\n}\r\nint class_check_uuid(struct obd_uuid *uuid, __u64 nid)\r\n{\r\nstruct uuid_nid_data *entry;\r\nint found = 0;\r\nCDEBUG(D_INFO, "check if uuid %s has %s.\n",\r\nobd_uuid2str(uuid), libcfs_nid2str(nid));\r\nspin_lock(&g_uuid_lock);\r\nlist_for_each_entry(entry, &g_uuid_list, un_list) {\r\nint i;\r\nif (!obd_uuid_equals(&entry->un_uuid, uuid))\r\ncontinue;\r\nfor (i = 0; i < entry->un_nid_count; i++) {\r\nif (entry->un_nids[i] == nid) {\r\nfound = 1;\r\nbreak;\r\n}\r\n}\r\nbreak;\r\n}\r\nspin_unlock(&g_uuid_lock);\r\nreturn found;\r\n}
