static inline void vf610_adc_calculate_rates(struct vf610_adc *info)\r\n{\r\nstruct vf610_adc_feature *adc_feature = &info->adc_feature;\r\nunsigned long adck_rate, ipg_rate = clk_get_rate(info->clk);\r\nu32 adck_period, lst_addr_min;\r\nint divisor, i;\r\nadck_rate = info->max_adck_rate[adc_feature->conv_mode];\r\nif (adck_rate) {\r\ndivisor = ipg_rate / adck_rate;\r\nadc_feature->clk_div = 1 << fls(divisor + 1);\r\n} else {\r\nadc_feature->clk_div = 8;\r\n}\r\nadck_rate = ipg_rate / adc_feature->clk_div;\r\nadck_period = NSEC_PER_SEC / adck_rate;\r\nlst_addr_min = adc_feature->default_sample_time / adck_period;\r\nfor (i = 0; i < ARRAY_SIZE(vf610_lst_adder); i++) {\r\nif (vf610_lst_adder[i] > lst_addr_min) {\r\nadc_feature->lst_adder_index = i;\r\nbreak;\r\n}\r\n}\r\nfor (i = 0; i < ARRAY_SIZE(vf610_hw_avgs); i++)\r\ninfo->sample_freq_avail[i] =\r\nadck_rate / (6 + vf610_hw_avgs[i] *\r\n(25 + vf610_lst_adder[adc_feature->lst_adder_index]));\r\n}\r\nstatic inline void vf610_adc_cfg_init(struct vf610_adc *info)\r\n{\r\nstruct vf610_adc_feature *adc_feature = &info->adc_feature;\r\nadc_feature->clk_sel = VF610_ADCIOC_BUSCLK_SET;\r\nadc_feature->vol_ref = VF610_ADCIOC_VR_VREF_SET;\r\nadc_feature->calibration = true;\r\nadc_feature->ovwren = true;\r\nadc_feature->res_mode = 12;\r\nadc_feature->sample_rate = 1;\r\nadc_feature->conv_mode = VF610_ADC_CONV_LOW_POWER;\r\nvf610_adc_calculate_rates(info);\r\n}\r\nstatic void vf610_adc_cfg_post_set(struct vf610_adc *info)\r\n{\r\nstruct vf610_adc_feature *adc_feature = &info->adc_feature;\r\nint cfg_data = 0;\r\nint gc_data = 0;\r\nswitch (adc_feature->clk_sel) {\r\ncase VF610_ADCIOC_ALTCLK_SET:\r\ncfg_data |= VF610_ADC_ALTCLK_SEL;\r\nbreak;\r\ncase VF610_ADCIOC_ADACK_SET:\r\ncfg_data |= VF610_ADC_ADACK_SEL;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\ncfg_data |= VF610_ADC_ADLPC_EN;\r\ncfg_data |= VF610_ADC_ADHSC_EN;\r\nswitch (adc_feature->vol_ref) {\r\ncase VF610_ADCIOC_VR_VREF_SET:\r\nbreak;\r\ncase VF610_ADCIOC_VR_VALT_SET:\r\ncfg_data |= VF610_ADC_REFSEL_VALT;\r\nbreak;\r\ncase VF610_ADCIOC_VR_VBG_SET:\r\ncfg_data |= VF610_ADC_REFSEL_VBG;\r\nbreak;\r\ndefault:\r\ndev_err(info->dev, "error voltage reference\n");\r\n}\r\nif (adc_feature->ovwren)\r\ncfg_data |= VF610_ADC_OVWREN;\r\nwritel(cfg_data, info->regs + VF610_REG_ADC_CFG);\r\nwritel(gc_data, info->regs + VF610_REG_ADC_GC);\r\n}\r\nstatic void vf610_adc_calibration(struct vf610_adc *info)\r\n{\r\nint adc_gc, hc_cfg;\r\nif (!info->adc_feature.calibration)\r\nreturn;\r\nhc_cfg = VF610_ADC_AIEN | VF610_ADC_CONV_DISABLE;\r\nwritel(hc_cfg, info->regs + VF610_REG_ADC_HC0);\r\nadc_gc = readl(info->regs + VF610_REG_ADC_GC);\r\nwritel(adc_gc | VF610_ADC_CAL, info->regs + VF610_REG_ADC_GC);\r\nif (!wait_for_completion_timeout(&info->completion, VF610_ADC_TIMEOUT))\r\ndev_err(info->dev, "Timeout for adc calibration\n");\r\nadc_gc = readl(info->regs + VF610_REG_ADC_GS);\r\nif (adc_gc & VF610_ADC_CALF)\r\ndev_err(info->dev, "ADC calibration failed\n");\r\ninfo->adc_feature.calibration = false;\r\n}\r\nstatic void vf610_adc_cfg_set(struct vf610_adc *info)\r\n{\r\nstruct vf610_adc_feature *adc_feature = &(info->adc_feature);\r\nint cfg_data;\r\ncfg_data = readl(info->regs + VF610_REG_ADC_CFG);\r\ncfg_data &= ~VF610_ADC_ADLPC_EN;\r\nif (adc_feature->conv_mode == VF610_ADC_CONV_LOW_POWER)\r\ncfg_data |= VF610_ADC_ADLPC_EN;\r\ncfg_data &= ~VF610_ADC_ADHSC_EN;\r\nif (adc_feature->conv_mode == VF610_ADC_CONV_HIGH_SPEED)\r\ncfg_data |= VF610_ADC_ADHSC_EN;\r\nwritel(cfg_data, info->regs + VF610_REG_ADC_CFG);\r\n}\r\nstatic void vf610_adc_sample_set(struct vf610_adc *info)\r\n{\r\nstruct vf610_adc_feature *adc_feature = &(info->adc_feature);\r\nint cfg_data, gc_data;\r\ncfg_data = readl(info->regs + VF610_REG_ADC_CFG);\r\ngc_data = readl(info->regs + VF610_REG_ADC_GC);\r\ncfg_data &= ~VF610_ADC_MODE_MASK;\r\nswitch (adc_feature->res_mode) {\r\ncase 8:\r\ncfg_data |= VF610_ADC_MODE_BIT8;\r\nbreak;\r\ncase 10:\r\ncfg_data |= VF610_ADC_MODE_BIT10;\r\nbreak;\r\ncase 12:\r\ncfg_data |= VF610_ADC_MODE_BIT12;\r\nbreak;\r\ndefault:\r\ndev_err(info->dev, "error resolution mode\n");\r\nbreak;\r\n}\r\ncfg_data &= ~(VF610_ADC_CLK_MASK | VF610_ADC_ADCCLK_MASK);\r\nswitch (adc_feature->clk_div) {\r\ncase 1:\r\nbreak;\r\ncase 2:\r\ncfg_data |= VF610_ADC_CLK_DIV2;\r\nbreak;\r\ncase 4:\r\ncfg_data |= VF610_ADC_CLK_DIV4;\r\nbreak;\r\ncase 8:\r\ncfg_data |= VF610_ADC_CLK_DIV8;\r\nbreak;\r\ncase 16:\r\nswitch (adc_feature->clk_sel) {\r\ncase VF610_ADCIOC_BUSCLK_SET:\r\ncfg_data |= VF610_ADC_BUSCLK2_SEL | VF610_ADC_CLK_DIV8;\r\nbreak;\r\ndefault:\r\ndev_err(info->dev, "error clk divider\n");\r\nbreak;\r\n}\r\nbreak;\r\n}\r\nswitch (adc_feature->lst_adder_index) {\r\ncase VF610_ADCK_CYCLES_3:\r\nbreak;\r\ncase VF610_ADCK_CYCLES_5:\r\ncfg_data |= VF610_ADC_ADSTS_SHORT;\r\nbreak;\r\ncase VF610_ADCK_CYCLES_7:\r\ncfg_data |= VF610_ADC_ADSTS_NORMAL;\r\nbreak;\r\ncase VF610_ADCK_CYCLES_9:\r\ncfg_data |= VF610_ADC_ADSTS_LONG;\r\nbreak;\r\ncase VF610_ADCK_CYCLES_13:\r\ncfg_data |= VF610_ADC_ADLSMP_LONG;\r\nbreak;\r\ncase VF610_ADCK_CYCLES_17:\r\ncfg_data |= VF610_ADC_ADLSMP_LONG;\r\ncfg_data |= VF610_ADC_ADSTS_SHORT;\r\nbreak;\r\ncase VF610_ADCK_CYCLES_21:\r\ncfg_data |= VF610_ADC_ADLSMP_LONG;\r\ncfg_data |= VF610_ADC_ADSTS_NORMAL;\r\nbreak;\r\ncase VF610_ADCK_CYCLES_25:\r\ncfg_data |= VF610_ADC_ADLSMP_LONG;\r\ncfg_data |= VF610_ADC_ADSTS_NORMAL;\r\nbreak;\r\ndefault:\r\ndev_err(info->dev, "error in sample time select\n");\r\n}\r\ncfg_data &= ~VF610_ADC_AVGS_MASK;\r\ngc_data &= ~VF610_ADC_AVGEN;\r\nswitch (adc_feature->sample_rate) {\r\ncase VF610_ADC_SAMPLE_1:\r\nbreak;\r\ncase VF610_ADC_SAMPLE_4:\r\ngc_data |= VF610_ADC_AVGEN;\r\nbreak;\r\ncase VF610_ADC_SAMPLE_8:\r\ngc_data |= VF610_ADC_AVGEN;\r\ncfg_data |= VF610_ADC_AVGS_8;\r\nbreak;\r\ncase VF610_ADC_SAMPLE_16:\r\ngc_data |= VF610_ADC_AVGEN;\r\ncfg_data |= VF610_ADC_AVGS_16;\r\nbreak;\r\ncase VF610_ADC_SAMPLE_32:\r\ngc_data |= VF610_ADC_AVGEN;\r\ncfg_data |= VF610_ADC_AVGS_32;\r\nbreak;\r\ndefault:\r\ndev_err(info->dev,\r\n"error hardware sample average select\n");\r\n}\r\nwritel(cfg_data, info->regs + VF610_REG_ADC_CFG);\r\nwritel(gc_data, info->regs + VF610_REG_ADC_GC);\r\n}\r\nstatic void vf610_adc_hw_init(struct vf610_adc *info)\r\n{\r\nvf610_adc_cfg_post_set(info);\r\nvf610_adc_sample_set(info);\r\nvf610_adc_calibration(info);\r\nvf610_adc_cfg_set(info);\r\n}\r\nstatic int vf610_set_conversion_mode(struct iio_dev *indio_dev,\r\nconst struct iio_chan_spec *chan,\r\nunsigned int mode)\r\n{\r\nstruct vf610_adc *info = iio_priv(indio_dev);\r\nmutex_lock(&indio_dev->mlock);\r\ninfo->adc_feature.conv_mode = mode;\r\nvf610_adc_calculate_rates(info);\r\nvf610_adc_hw_init(info);\r\nmutex_unlock(&indio_dev->mlock);\r\nreturn 0;\r\n}\r\nstatic int vf610_get_conversion_mode(struct iio_dev *indio_dev,\r\nconst struct iio_chan_spec *chan)\r\n{\r\nstruct vf610_adc *info = iio_priv(indio_dev);\r\nreturn info->adc_feature.conv_mode;\r\n}\r\nstatic int vf610_adc_read_data(struct vf610_adc *info)\r\n{\r\nint result;\r\nresult = readl(info->regs + VF610_REG_ADC_R0);\r\nswitch (info->adc_feature.res_mode) {\r\ncase 8:\r\nresult &= 0xFF;\r\nbreak;\r\ncase 10:\r\nresult &= 0x3FF;\r\nbreak;\r\ncase 12:\r\nresult &= 0xFFF;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nreturn result;\r\n}\r\nstatic irqreturn_t vf610_adc_isr(int irq, void *dev_id)\r\n{\r\nstruct iio_dev *indio_dev = (struct iio_dev *)dev_id;\r\nstruct vf610_adc *info = iio_priv(indio_dev);\r\nint coco;\r\ncoco = readl(info->regs + VF610_REG_ADC_HS);\r\nif (coco & VF610_ADC_HS_COCO0) {\r\ninfo->value = vf610_adc_read_data(info);\r\nif (iio_buffer_enabled(indio_dev)) {\r\ninfo->buffer[0] = info->value;\r\niio_push_to_buffers_with_timestamp(indio_dev,\r\ninfo->buffer, iio_get_time_ns());\r\niio_trigger_notify_done(indio_dev->trig);\r\n} else\r\ncomplete(&info->completion);\r\n}\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic ssize_t vf610_show_samp_freq_avail(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct vf610_adc *info = iio_priv(dev_to_iio_dev(dev));\r\nsize_t len = 0;\r\nint i;\r\nfor (i = 0; i < ARRAY_SIZE(info->sample_freq_avail); i++)\r\nlen += scnprintf(buf + len, PAGE_SIZE - len,\r\n"%u ", info->sample_freq_avail[i]);\r\nbuf[len - 1] = '\n';\r\nreturn len;\r\n}\r\nstatic int vf610_read_raw(struct iio_dev *indio_dev,\r\nstruct iio_chan_spec const *chan,\r\nint *val,\r\nint *val2,\r\nlong mask)\r\n{\r\nstruct vf610_adc *info = iio_priv(indio_dev);\r\nunsigned int hc_cfg;\r\nlong ret;\r\nswitch (mask) {\r\ncase IIO_CHAN_INFO_RAW:\r\ncase IIO_CHAN_INFO_PROCESSED:\r\nmutex_lock(&indio_dev->mlock);\r\nif (iio_buffer_enabled(indio_dev)) {\r\nmutex_unlock(&indio_dev->mlock);\r\nreturn -EBUSY;\r\n}\r\nreinit_completion(&info->completion);\r\nhc_cfg = VF610_ADC_ADCHC(chan->channel);\r\nhc_cfg |= VF610_ADC_AIEN;\r\nwritel(hc_cfg, info->regs + VF610_REG_ADC_HC0);\r\nret = wait_for_completion_interruptible_timeout\r\n(&info->completion, VF610_ADC_TIMEOUT);\r\nif (ret == 0) {\r\nmutex_unlock(&indio_dev->mlock);\r\nreturn -ETIMEDOUT;\r\n}\r\nif (ret < 0) {\r\nmutex_unlock(&indio_dev->mlock);\r\nreturn ret;\r\n}\r\nswitch (chan->type) {\r\ncase IIO_VOLTAGE:\r\n*val = info->value;\r\nbreak;\r\ncase IIO_TEMP:\r\n*val = 25000 - ((int)info->value - VF610_VTEMP25_3V3) *\r\n1000000 / VF610_TEMP_SLOPE_COEFF;\r\nbreak;\r\ndefault:\r\nmutex_unlock(&indio_dev->mlock);\r\nreturn -EINVAL;\r\n}\r\nmutex_unlock(&indio_dev->mlock);\r\nreturn IIO_VAL_INT;\r\ncase IIO_CHAN_INFO_SCALE:\r\n*val = info->vref_uv / 1000;\r\n*val2 = info->adc_feature.res_mode;\r\nreturn IIO_VAL_FRACTIONAL_LOG2;\r\ncase IIO_CHAN_INFO_SAMP_FREQ:\r\n*val = info->sample_freq_avail[info->adc_feature.sample_rate];\r\n*val2 = 0;\r\nreturn IIO_VAL_INT;\r\ndefault:\r\nbreak;\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int vf610_write_raw(struct iio_dev *indio_dev,\r\nstruct iio_chan_spec const *chan,\r\nint val,\r\nint val2,\r\nlong mask)\r\n{\r\nstruct vf610_adc *info = iio_priv(indio_dev);\r\nint i;\r\nswitch (mask) {\r\ncase IIO_CHAN_INFO_SAMP_FREQ:\r\nfor (i = 0;\r\ni < ARRAY_SIZE(info->sample_freq_avail);\r\ni++)\r\nif (val == info->sample_freq_avail[i]) {\r\ninfo->adc_feature.sample_rate = i;\r\nvf610_adc_sample_set(info);\r\nreturn 0;\r\n}\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int vf610_adc_buffer_postenable(struct iio_dev *indio_dev)\r\n{\r\nstruct vf610_adc *info = iio_priv(indio_dev);\r\nunsigned int channel;\r\nint ret;\r\nint val;\r\nret = iio_triggered_buffer_postenable(indio_dev);\r\nif (ret)\r\nreturn ret;\r\nval = readl(info->regs + VF610_REG_ADC_GC);\r\nval |= VF610_ADC_ADCON;\r\nwritel(val, info->regs + VF610_REG_ADC_GC);\r\nchannel = find_first_bit(indio_dev->active_scan_mask,\r\nindio_dev->masklength);\r\nval = VF610_ADC_ADCHC(channel);\r\nval |= VF610_ADC_AIEN;\r\nwritel(val, info->regs + VF610_REG_ADC_HC0);\r\nreturn 0;\r\n}\r\nstatic int vf610_adc_buffer_predisable(struct iio_dev *indio_dev)\r\n{\r\nstruct vf610_adc *info = iio_priv(indio_dev);\r\nunsigned int hc_cfg = 0;\r\nint val;\r\nval = readl(info->regs + VF610_REG_ADC_GC);\r\nval &= ~VF610_ADC_ADCON;\r\nwritel(val, info->regs + VF610_REG_ADC_GC);\r\nhc_cfg |= VF610_ADC_CONV_DISABLE;\r\nhc_cfg &= ~VF610_ADC_AIEN;\r\nwritel(hc_cfg, info->regs + VF610_REG_ADC_HC0);\r\nreturn iio_triggered_buffer_predisable(indio_dev);\r\n}\r\nstatic int vf610_adc_reg_access(struct iio_dev *indio_dev,\r\nunsigned reg, unsigned writeval,\r\nunsigned *readval)\r\n{\r\nstruct vf610_adc *info = iio_priv(indio_dev);\r\nif ((readval == NULL) ||\r\n((reg % 4) || (reg > VF610_REG_ADC_PCTL)))\r\nreturn -EINVAL;\r\n*readval = readl(info->regs + reg);\r\nreturn 0;\r\n}\r\nstatic int vf610_adc_probe(struct platform_device *pdev)\r\n{\r\nstruct vf610_adc *info;\r\nstruct iio_dev *indio_dev;\r\nstruct resource *mem;\r\nint irq;\r\nint ret;\r\nindio_dev = devm_iio_device_alloc(&pdev->dev, sizeof(struct vf610_adc));\r\nif (!indio_dev) {\r\ndev_err(&pdev->dev, "Failed allocating iio device\n");\r\nreturn -ENOMEM;\r\n}\r\ninfo = iio_priv(indio_dev);\r\ninfo->dev = &pdev->dev;\r\nmem = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\ninfo->regs = devm_ioremap_resource(&pdev->dev, mem);\r\nif (IS_ERR(info->regs))\r\nreturn PTR_ERR(info->regs);\r\nirq = platform_get_irq(pdev, 0);\r\nif (irq < 0) {\r\ndev_err(&pdev->dev, "no irq resource?\n");\r\nreturn irq;\r\n}\r\nret = devm_request_irq(info->dev, irq,\r\nvf610_adc_isr, 0,\r\ndev_name(&pdev->dev), indio_dev);\r\nif (ret < 0) {\r\ndev_err(&pdev->dev, "failed requesting irq, irq = %d\n", irq);\r\nreturn ret;\r\n}\r\ninfo->clk = devm_clk_get(&pdev->dev, "adc");\r\nif (IS_ERR(info->clk)) {\r\ndev_err(&pdev->dev, "failed getting clock, err = %ld\n",\r\nPTR_ERR(info->clk));\r\nreturn PTR_ERR(info->clk);\r\n}\r\ninfo->vref = devm_regulator_get(&pdev->dev, "vref");\r\nif (IS_ERR(info->vref))\r\nreturn PTR_ERR(info->vref);\r\nret = regulator_enable(info->vref);\r\nif (ret)\r\nreturn ret;\r\ninfo->vref_uv = regulator_get_voltage(info->vref);\r\nof_property_read_u32_array(pdev->dev.of_node, "fsl,adck-max-frequency",\r\ninfo->max_adck_rate, 3);\r\nret = of_property_read_u32(pdev->dev.of_node, "min-sample-time",\r\n&info->adc_feature.default_sample_time);\r\nif (ret)\r\ninfo->adc_feature.default_sample_time = DEFAULT_SAMPLE_TIME;\r\nplatform_set_drvdata(pdev, indio_dev);\r\ninit_completion(&info->completion);\r\nindio_dev->name = dev_name(&pdev->dev);\r\nindio_dev->dev.parent = &pdev->dev;\r\nindio_dev->dev.of_node = pdev->dev.of_node;\r\nindio_dev->info = &vf610_adc_iio_info;\r\nindio_dev->modes = INDIO_DIRECT_MODE;\r\nindio_dev->channels = vf610_adc_iio_channels;\r\nindio_dev->num_channels = ARRAY_SIZE(vf610_adc_iio_channels);\r\nret = clk_prepare_enable(info->clk);\r\nif (ret) {\r\ndev_err(&pdev->dev,\r\n"Could not prepare or enable the clock.\n");\r\ngoto error_adc_clk_enable;\r\n}\r\nvf610_adc_cfg_init(info);\r\nvf610_adc_hw_init(info);\r\nret = iio_triggered_buffer_setup(indio_dev, &iio_pollfunc_store_time,\r\nNULL, &iio_triggered_buffer_setup_ops);\r\nif (ret < 0) {\r\ndev_err(&pdev->dev, "Couldn't initialise the buffer\n");\r\ngoto error_iio_device_register;\r\n}\r\nret = iio_device_register(indio_dev);\r\nif (ret) {\r\ndev_err(&pdev->dev, "Couldn't register the device.\n");\r\ngoto error_adc_buffer_init;\r\n}\r\nreturn 0;\r\nerror_adc_buffer_init:\r\niio_triggered_buffer_cleanup(indio_dev);\r\nerror_iio_device_register:\r\nclk_disable_unprepare(info->clk);\r\nerror_adc_clk_enable:\r\nregulator_disable(info->vref);\r\nreturn ret;\r\n}\r\nstatic int vf610_adc_remove(struct platform_device *pdev)\r\n{\r\nstruct iio_dev *indio_dev = platform_get_drvdata(pdev);\r\nstruct vf610_adc *info = iio_priv(indio_dev);\r\niio_device_unregister(indio_dev);\r\niio_triggered_buffer_cleanup(indio_dev);\r\nregulator_disable(info->vref);\r\nclk_disable_unprepare(info->clk);\r\nreturn 0;\r\n}\r\nstatic int vf610_adc_suspend(struct device *dev)\r\n{\r\nstruct iio_dev *indio_dev = dev_get_drvdata(dev);\r\nstruct vf610_adc *info = iio_priv(indio_dev);\r\nint hc_cfg;\r\nhc_cfg = readl(info->regs + VF610_REG_ADC_HC0);\r\nhc_cfg |= VF610_ADC_CONV_DISABLE;\r\nwritel(hc_cfg, info->regs + VF610_REG_ADC_HC0);\r\nclk_disable_unprepare(info->clk);\r\nregulator_disable(info->vref);\r\nreturn 0;\r\n}\r\nstatic int vf610_adc_resume(struct device *dev)\r\n{\r\nstruct iio_dev *indio_dev = dev_get_drvdata(dev);\r\nstruct vf610_adc *info = iio_priv(indio_dev);\r\nint ret;\r\nret = regulator_enable(info->vref);\r\nif (ret)\r\nreturn ret;\r\nret = clk_prepare_enable(info->clk);\r\nif (ret)\r\ngoto disable_reg;\r\nvf610_adc_hw_init(info);\r\nreturn 0;\r\ndisable_reg:\r\nregulator_disable(info->vref);\r\nreturn ret;\r\n}
