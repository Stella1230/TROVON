static inline struct vmw_overlay *vmw_overlay(struct drm_device *dev)\r\n{\r\nstruct vmw_private *dev_priv = vmw_priv(dev);\r\nreturn dev_priv ? dev_priv->overlay_priv : NULL;\r\n}\r\nstatic inline void fill_escape(struct vmw_escape_header *header,\r\nuint32_t size)\r\n{\r\nheader->cmd = SVGA_CMD_ESCAPE;\r\nheader->body.nsid = SVGA_ESCAPE_NSID_VMWARE;\r\nheader->body.size = size;\r\n}\r\nstatic inline void fill_flush(struct vmw_escape_video_flush *cmd,\r\nuint32_t stream_id)\r\n{\r\nfill_escape(&cmd->escape, sizeof(cmd->flush));\r\ncmd->flush.cmdType = SVGA_ESCAPE_VMWARE_VIDEO_FLUSH;\r\ncmd->flush.streamId = stream_id;\r\n}\r\nstatic int vmw_overlay_send_put(struct vmw_private *dev_priv,\r\nstruct vmw_dma_buffer *buf,\r\nstruct drm_vmw_control_stream_arg *arg,\r\nbool interruptible)\r\n{\r\nstruct vmw_escape_video_flush *flush;\r\nsize_t fifo_size;\r\nbool have_so = (dev_priv->active_display_unit == vmw_du_screen_object);\r\nint i, num_items;\r\nSVGAGuestPtr ptr;\r\nstruct {\r\nstruct vmw_escape_header escape;\r\nstruct {\r\nuint32_t cmdType;\r\nuint32_t streamId;\r\n} header;\r\n} *cmds;\r\nstruct {\r\nuint32_t registerId;\r\nuint32_t value;\r\n} *items;\r\nif (have_so)\r\nnum_items = SVGA_VIDEO_DST_SCREEN_ID + 1;\r\nelse\r\nnum_items = SVGA_VIDEO_PITCH_3 + 1;\r\nfifo_size = sizeof(*cmds) + sizeof(*flush) + sizeof(*items) * num_items;\r\ncmds = vmw_fifo_reserve(dev_priv, fifo_size);\r\nif (!cmds)\r\nreturn -ENOMEM;\r\nitems = (typeof(items))&cmds[1];\r\nflush = (struct vmw_escape_video_flush *)&items[num_items];\r\nfill_escape(&cmds->escape, sizeof(*items) * (num_items + 1));\r\ncmds->header.cmdType = SVGA_ESCAPE_VMWARE_VIDEO_SET_REGS;\r\ncmds->header.streamId = arg->stream_id;\r\nfor (i = 0; i < num_items; i++)\r\nitems[i].registerId = i;\r\nvmw_bo_get_guest_ptr(&buf->base, &ptr);\r\nptr.offset += arg->offset;\r\nitems[SVGA_VIDEO_ENABLED].value = true;\r\nitems[SVGA_VIDEO_FLAGS].value = arg->flags;\r\nitems[SVGA_VIDEO_DATA_OFFSET].value = ptr.offset;\r\nitems[SVGA_VIDEO_FORMAT].value = arg->format;\r\nitems[SVGA_VIDEO_COLORKEY].value = arg->color_key;\r\nitems[SVGA_VIDEO_SIZE].value = arg->size;\r\nitems[SVGA_VIDEO_WIDTH].value = arg->width;\r\nitems[SVGA_VIDEO_HEIGHT].value = arg->height;\r\nitems[SVGA_VIDEO_SRC_X].value = arg->src.x;\r\nitems[SVGA_VIDEO_SRC_Y].value = arg->src.y;\r\nitems[SVGA_VIDEO_SRC_WIDTH].value = arg->src.w;\r\nitems[SVGA_VIDEO_SRC_HEIGHT].value = arg->src.h;\r\nitems[SVGA_VIDEO_DST_X].value = arg->dst.x;\r\nitems[SVGA_VIDEO_DST_Y].value = arg->dst.y;\r\nitems[SVGA_VIDEO_DST_WIDTH].value = arg->dst.w;\r\nitems[SVGA_VIDEO_DST_HEIGHT].value = arg->dst.h;\r\nitems[SVGA_VIDEO_PITCH_1].value = arg->pitch[0];\r\nitems[SVGA_VIDEO_PITCH_2].value = arg->pitch[1];\r\nitems[SVGA_VIDEO_PITCH_3].value = arg->pitch[2];\r\nif (have_so) {\r\nitems[SVGA_VIDEO_DATA_GMRID].value = ptr.gmrId;\r\nitems[SVGA_VIDEO_DST_SCREEN_ID].value = SVGA_ID_INVALID;\r\n}\r\nfill_flush(flush, arg->stream_id);\r\nvmw_fifo_commit(dev_priv, fifo_size);\r\nreturn 0;\r\n}\r\nstatic int vmw_overlay_send_stop(struct vmw_private *dev_priv,\r\nuint32_t stream_id,\r\nbool interruptible)\r\n{\r\nstruct {\r\nstruct vmw_escape_header escape;\r\nSVGAEscapeVideoSetRegs body;\r\nstruct vmw_escape_video_flush flush;\r\n} *cmds;\r\nint ret;\r\nfor (;;) {\r\ncmds = vmw_fifo_reserve(dev_priv, sizeof(*cmds));\r\nif (cmds)\r\nbreak;\r\nret = vmw_fallback_wait(dev_priv, false, true, 0,\r\ninterruptible, 3*HZ);\r\nif (interruptible && ret == -ERESTARTSYS)\r\nreturn ret;\r\nelse\r\nBUG_ON(ret != 0);\r\n}\r\nfill_escape(&cmds->escape, sizeof(cmds->body));\r\ncmds->body.header.cmdType = SVGA_ESCAPE_VMWARE_VIDEO_SET_REGS;\r\ncmds->body.header.streamId = stream_id;\r\ncmds->body.items[0].registerId = SVGA_VIDEO_ENABLED;\r\ncmds->body.items[0].value = false;\r\nfill_flush(&cmds->flush, stream_id);\r\nvmw_fifo_commit(dev_priv, sizeof(*cmds));\r\nreturn 0;\r\n}\r\nstatic int vmw_overlay_move_buffer(struct vmw_private *dev_priv,\r\nstruct vmw_dma_buffer *buf,\r\nbool pin, bool inter)\r\n{\r\nif (!pin)\r\nreturn vmw_dmabuf_unpin(dev_priv, buf, inter);\r\nif (dev_priv->active_display_unit == vmw_du_legacy)\r\nreturn vmw_dmabuf_pin_in_vram(dev_priv, buf, inter);\r\nreturn vmw_dmabuf_pin_in_vram_or_gmr(dev_priv, buf, inter);\r\n}\r\nstatic int vmw_overlay_stop(struct vmw_private *dev_priv,\r\nuint32_t stream_id, bool pause,\r\nbool interruptible)\r\n{\r\nstruct vmw_overlay *overlay = dev_priv->overlay_priv;\r\nstruct vmw_stream *stream = &overlay->stream[stream_id];\r\nint ret;\r\nif (!stream->buf)\r\nreturn 0;\r\nif (!stream->paused) {\r\nret = vmw_overlay_send_stop(dev_priv, stream_id,\r\ninterruptible);\r\nif (ret)\r\nreturn ret;\r\nret = vmw_overlay_move_buffer(dev_priv, stream->buf, false,\r\ninterruptible);\r\nif (interruptible && ret == -ERESTARTSYS)\r\nreturn ret;\r\nelse\r\nBUG_ON(ret != 0);\r\n}\r\nif (!pause) {\r\nvmw_dmabuf_unreference(&stream->buf);\r\nstream->paused = false;\r\n} else {\r\nstream->paused = true;\r\n}\r\nreturn 0;\r\n}\r\nstatic int vmw_overlay_update_stream(struct vmw_private *dev_priv,\r\nstruct vmw_dma_buffer *buf,\r\nstruct drm_vmw_control_stream_arg *arg,\r\nbool interruptible)\r\n{\r\nstruct vmw_overlay *overlay = dev_priv->overlay_priv;\r\nstruct vmw_stream *stream = &overlay->stream[arg->stream_id];\r\nint ret = 0;\r\nif (!buf)\r\nreturn -EINVAL;\r\nDRM_DEBUG(" %s: old %p, new %p, %spaused\n", __func__,\r\nstream->buf, buf, stream->paused ? "" : "not ");\r\nif (stream->buf != buf) {\r\nret = vmw_overlay_stop(dev_priv, arg->stream_id,\r\nfalse, interruptible);\r\nif (ret)\r\nreturn ret;\r\n} else if (!stream->paused) {\r\nret = vmw_overlay_send_put(dev_priv, buf, arg, interruptible);\r\nif (ret == 0)\r\nstream->saved = *arg;\r\nelse\r\nBUG_ON(!interruptible);\r\nreturn ret;\r\n}\r\nret = vmw_overlay_move_buffer(dev_priv, buf, true, interruptible);\r\nif (ret)\r\nreturn ret;\r\nret = vmw_overlay_send_put(dev_priv, buf, arg, interruptible);\r\nif (ret) {\r\nBUG_ON(vmw_overlay_move_buffer(dev_priv, buf, false, false)\r\n!= 0);\r\nreturn ret;\r\n}\r\nif (stream->buf != buf)\r\nstream->buf = vmw_dmabuf_reference(buf);\r\nstream->saved = *arg;\r\nstream->paused = false;\r\nreturn 0;\r\n}\r\nint vmw_overlay_stop_all(struct vmw_private *dev_priv)\r\n{\r\nstruct vmw_overlay *overlay = dev_priv->overlay_priv;\r\nint i, ret;\r\nif (!overlay)\r\nreturn 0;\r\nmutex_lock(&overlay->mutex);\r\nfor (i = 0; i < VMW_MAX_NUM_STREAMS; i++) {\r\nstruct vmw_stream *stream = &overlay->stream[i];\r\nif (!stream->buf)\r\ncontinue;\r\nret = vmw_overlay_stop(dev_priv, i, false, false);\r\nWARN_ON(ret != 0);\r\n}\r\nmutex_unlock(&overlay->mutex);\r\nreturn 0;\r\n}\r\nint vmw_overlay_resume_all(struct vmw_private *dev_priv)\r\n{\r\nstruct vmw_overlay *overlay = dev_priv->overlay_priv;\r\nint i, ret;\r\nif (!overlay)\r\nreturn 0;\r\nmutex_lock(&overlay->mutex);\r\nfor (i = 0; i < VMW_MAX_NUM_STREAMS; i++) {\r\nstruct vmw_stream *stream = &overlay->stream[i];\r\nif (!stream->paused)\r\ncontinue;\r\nret = vmw_overlay_update_stream(dev_priv, stream->buf,\r\n&stream->saved, false);\r\nif (ret != 0)\r\nDRM_INFO("%s: *warning* failed to resume stream %i\n",\r\n__func__, i);\r\n}\r\nmutex_unlock(&overlay->mutex);\r\nreturn 0;\r\n}\r\nint vmw_overlay_pause_all(struct vmw_private *dev_priv)\r\n{\r\nstruct vmw_overlay *overlay = dev_priv->overlay_priv;\r\nint i, ret;\r\nif (!overlay)\r\nreturn 0;\r\nmutex_lock(&overlay->mutex);\r\nfor (i = 0; i < VMW_MAX_NUM_STREAMS; i++) {\r\nif (overlay->stream[i].paused)\r\nDRM_INFO("%s: *warning* stream %i already paused\n",\r\n__func__, i);\r\nret = vmw_overlay_stop(dev_priv, i, true, false);\r\nWARN_ON(ret != 0);\r\n}\r\nmutex_unlock(&overlay->mutex);\r\nreturn 0;\r\n}\r\nstatic bool vmw_overlay_available(const struct vmw_private *dev_priv)\r\n{\r\nreturn (dev_priv->overlay_priv != NULL &&\r\n((dev_priv->fifo.capabilities & VMW_OVERLAY_CAP_MASK) ==\r\nVMW_OVERLAY_CAP_MASK));\r\n}\r\nint vmw_overlay_ioctl(struct drm_device *dev, void *data,\r\nstruct drm_file *file_priv)\r\n{\r\nstruct ttm_object_file *tfile = vmw_fpriv(file_priv)->tfile;\r\nstruct vmw_private *dev_priv = vmw_priv(dev);\r\nstruct vmw_overlay *overlay = dev_priv->overlay_priv;\r\nstruct drm_vmw_control_stream_arg *arg =\r\n(struct drm_vmw_control_stream_arg *)data;\r\nstruct vmw_dma_buffer *buf;\r\nstruct vmw_resource *res;\r\nint ret;\r\nif (!vmw_overlay_available(dev_priv))\r\nreturn -ENOSYS;\r\nret = vmw_user_stream_lookup(dev_priv, tfile, &arg->stream_id, &res);\r\nif (ret)\r\nreturn ret;\r\nmutex_lock(&overlay->mutex);\r\nif (!arg->enabled) {\r\nret = vmw_overlay_stop(dev_priv, arg->stream_id, false, true);\r\ngoto out_unlock;\r\n}\r\nret = vmw_user_dmabuf_lookup(tfile, arg->handle, &buf, NULL);\r\nif (ret)\r\ngoto out_unlock;\r\nret = vmw_overlay_update_stream(dev_priv, buf, arg, true);\r\nvmw_dmabuf_unreference(&buf);\r\nout_unlock:\r\nmutex_unlock(&overlay->mutex);\r\nvmw_resource_unreference(&res);\r\nreturn ret;\r\n}\r\nint vmw_overlay_num_overlays(struct vmw_private *dev_priv)\r\n{\r\nif (!vmw_overlay_available(dev_priv))\r\nreturn 0;\r\nreturn VMW_MAX_NUM_STREAMS;\r\n}\r\nint vmw_overlay_num_free_overlays(struct vmw_private *dev_priv)\r\n{\r\nstruct vmw_overlay *overlay = dev_priv->overlay_priv;\r\nint i, k;\r\nif (!vmw_overlay_available(dev_priv))\r\nreturn 0;\r\nmutex_lock(&overlay->mutex);\r\nfor (i = 0, k = 0; i < VMW_MAX_NUM_STREAMS; i++)\r\nif (!overlay->stream[i].claimed)\r\nk++;\r\nmutex_unlock(&overlay->mutex);\r\nreturn k;\r\n}\r\nint vmw_overlay_claim(struct vmw_private *dev_priv, uint32_t *out)\r\n{\r\nstruct vmw_overlay *overlay = dev_priv->overlay_priv;\r\nint i;\r\nif (!overlay)\r\nreturn -ENOSYS;\r\nmutex_lock(&overlay->mutex);\r\nfor (i = 0; i < VMW_MAX_NUM_STREAMS; i++) {\r\nif (overlay->stream[i].claimed)\r\ncontinue;\r\noverlay->stream[i].claimed = true;\r\n*out = i;\r\nmutex_unlock(&overlay->mutex);\r\nreturn 0;\r\n}\r\nmutex_unlock(&overlay->mutex);\r\nreturn -ESRCH;\r\n}\r\nint vmw_overlay_unref(struct vmw_private *dev_priv, uint32_t stream_id)\r\n{\r\nstruct vmw_overlay *overlay = dev_priv->overlay_priv;\r\nBUG_ON(stream_id >= VMW_MAX_NUM_STREAMS);\r\nif (!overlay)\r\nreturn -ENOSYS;\r\nmutex_lock(&overlay->mutex);\r\nWARN_ON(!overlay->stream[stream_id].claimed);\r\nvmw_overlay_stop(dev_priv, stream_id, false, false);\r\noverlay->stream[stream_id].claimed = false;\r\nmutex_unlock(&overlay->mutex);\r\nreturn 0;\r\n}\r\nint vmw_overlay_init(struct vmw_private *dev_priv)\r\n{\r\nstruct vmw_overlay *overlay;\r\nint i;\r\nif (dev_priv->overlay_priv)\r\nreturn -EINVAL;\r\noverlay = kzalloc(sizeof(*overlay), GFP_KERNEL);\r\nif (!overlay)\r\nreturn -ENOMEM;\r\nmutex_init(&overlay->mutex);\r\nfor (i = 0; i < VMW_MAX_NUM_STREAMS; i++) {\r\noverlay->stream[i].buf = NULL;\r\noverlay->stream[i].paused = false;\r\noverlay->stream[i].claimed = false;\r\n}\r\ndev_priv->overlay_priv = overlay;\r\nreturn 0;\r\n}\r\nint vmw_overlay_close(struct vmw_private *dev_priv)\r\n{\r\nstruct vmw_overlay *overlay = dev_priv->overlay_priv;\r\nbool forgotten_buffer = false;\r\nint i;\r\nif (!overlay)\r\nreturn -ENOSYS;\r\nfor (i = 0; i < VMW_MAX_NUM_STREAMS; i++) {\r\nif (overlay->stream[i].buf) {\r\nforgotten_buffer = true;\r\nvmw_overlay_stop(dev_priv, i, false, false);\r\n}\r\n}\r\nWARN_ON(forgotten_buffer);\r\ndev_priv->overlay_priv = NULL;\r\nkfree(overlay);\r\nreturn 0;\r\n}
