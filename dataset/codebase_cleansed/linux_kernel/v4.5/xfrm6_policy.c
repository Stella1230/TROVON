static struct dst_entry *xfrm6_dst_lookup(struct net *net, int tos, int oif,\r\nconst xfrm_address_t *saddr,\r\nconst xfrm_address_t *daddr)\r\n{\r\nstruct flowi6 fl6;\r\nstruct dst_entry *dst;\r\nint err;\r\nmemset(&fl6, 0, sizeof(fl6));\r\nfl6.flowi6_oif = oif;\r\nfl6.flowi6_flags = FLOWI_FLAG_SKIP_NH_OIF;\r\nmemcpy(&fl6.daddr, daddr, sizeof(fl6.daddr));\r\nif (saddr)\r\nmemcpy(&fl6.saddr, saddr, sizeof(fl6.saddr));\r\ndst = ip6_route_output(net, NULL, &fl6);\r\nerr = dst->error;\r\nif (dst->error) {\r\ndst_release(dst);\r\ndst = ERR_PTR(err);\r\n}\r\nreturn dst;\r\n}\r\nstatic int xfrm6_get_saddr(struct net *net, int oif,\r\nxfrm_address_t *saddr, xfrm_address_t *daddr)\r\n{\r\nstruct dst_entry *dst;\r\nstruct net_device *dev;\r\ndst = xfrm6_dst_lookup(net, 0, oif, NULL, daddr);\r\nif (IS_ERR(dst))\r\nreturn -EHOSTUNREACH;\r\ndev = ip6_dst_idev(dst)->dev;\r\nipv6_dev_get_saddr(dev_net(dev), dev, &daddr->in6, 0, &saddr->in6);\r\ndst_release(dst);\r\nreturn 0;\r\n}\r\nstatic int xfrm6_get_tos(const struct flowi *fl)\r\n{\r\nreturn 0;\r\n}\r\nstatic int xfrm6_init_path(struct xfrm_dst *path, struct dst_entry *dst,\r\nint nfheader_len)\r\n{\r\nif (dst->ops->family == AF_INET6) {\r\nstruct rt6_info *rt = (struct rt6_info *)dst;\r\npath->path_cookie = rt6_get_cookie(rt);\r\n}\r\npath->u.rt6.rt6i_nfheader_len = nfheader_len;\r\nreturn 0;\r\n}\r\nstatic int xfrm6_fill_dst(struct xfrm_dst *xdst, struct net_device *dev,\r\nconst struct flowi *fl)\r\n{\r\nstruct rt6_info *rt = (struct rt6_info *)xdst->route;\r\nxdst->u.dst.dev = dev;\r\ndev_hold(dev);\r\nxdst->u.rt6.rt6i_idev = in6_dev_get(dev);\r\nif (!xdst->u.rt6.rt6i_idev) {\r\ndev_put(dev);\r\nreturn -ENODEV;\r\n}\r\nxdst->u.rt6.rt6i_flags = rt->rt6i_flags & (RTF_ANYCAST |\r\nRTF_LOCAL);\r\nxdst->u.rt6.rt6i_metric = rt->rt6i_metric;\r\nxdst->u.rt6.rt6i_node = rt->rt6i_node;\r\nxdst->route_cookie = rt6_get_cookie(rt);\r\nxdst->u.rt6.rt6i_gateway = rt->rt6i_gateway;\r\nxdst->u.rt6.rt6i_dst = rt->rt6i_dst;\r\nxdst->u.rt6.rt6i_src = rt->rt6i_src;\r\nreturn 0;\r\n}\r\nstatic inline void\r\n_decode_session6(struct sk_buff *skb, struct flowi *fl, int reverse)\r\n{\r\nstruct flowi6 *fl6 = &fl->u.ip6;\r\nint onlyproto = 0;\r\nconst struct ipv6hdr *hdr = ipv6_hdr(skb);\r\nu16 offset = sizeof(*hdr);\r\nstruct ipv6_opt_hdr *exthdr;\r\nconst unsigned char *nh = skb_network_header(skb);\r\nu16 nhoff = IP6CB(skb)->nhoff;\r\nint oif = 0;\r\nu8 nexthdr;\r\nif (!nhoff)\r\nnhoff = offsetof(struct ipv6hdr, nexthdr);\r\nnexthdr = nh[nhoff];\r\nif (skb_dst(skb))\r\noif = l3mdev_fib_oif(skb_dst(skb)->dev);\r\nmemset(fl6, 0, sizeof(struct flowi6));\r\nfl6->flowi6_mark = skb->mark;\r\nfl6->flowi6_oif = reverse ? skb->skb_iif : oif;\r\nfl6->daddr = reverse ? hdr->saddr : hdr->daddr;\r\nfl6->saddr = reverse ? hdr->daddr : hdr->saddr;\r\nwhile (nh + offset + 1 < skb->data ||\r\npskb_may_pull(skb, nh + offset + 1 - skb->data)) {\r\nnh = skb_network_header(skb);\r\nexthdr = (struct ipv6_opt_hdr *)(nh + offset);\r\nswitch (nexthdr) {\r\ncase NEXTHDR_FRAGMENT:\r\nonlyproto = 1;\r\ncase NEXTHDR_ROUTING:\r\ncase NEXTHDR_HOP:\r\ncase NEXTHDR_DEST:\r\noffset += ipv6_optlen(exthdr);\r\nnexthdr = exthdr->nexthdr;\r\nexthdr = (struct ipv6_opt_hdr *)(nh + offset);\r\nbreak;\r\ncase IPPROTO_UDP:\r\ncase IPPROTO_UDPLITE:\r\ncase IPPROTO_TCP:\r\ncase IPPROTO_SCTP:\r\ncase IPPROTO_DCCP:\r\nif (!onlyproto && (nh + offset + 4 < skb->data ||\r\npskb_may_pull(skb, nh + offset + 4 - skb->data))) {\r\n__be16 *ports;\r\nnh = skb_network_header(skb);\r\nports = (__be16 *)(nh + offset);\r\nfl6->fl6_sport = ports[!!reverse];\r\nfl6->fl6_dport = ports[!reverse];\r\n}\r\nfl6->flowi6_proto = nexthdr;\r\nreturn;\r\ncase IPPROTO_ICMPV6:\r\nif (!onlyproto && (nh + offset + 2 < skb->data ||\r\npskb_may_pull(skb, nh + offset + 2 - skb->data))) {\r\nu8 *icmp;\r\nnh = skb_network_header(skb);\r\nicmp = (u8 *)(nh + offset);\r\nfl6->fl6_icmp_type = icmp[0];\r\nfl6->fl6_icmp_code = icmp[1];\r\n}\r\nfl6->flowi6_proto = nexthdr;\r\nreturn;\r\n#if IS_ENABLED(CONFIG_IPV6_MIP6)\r\ncase IPPROTO_MH:\r\noffset += ipv6_optlen(exthdr);\r\nif (!onlyproto && (nh + offset + 3 < skb->data ||\r\npskb_may_pull(skb, nh + offset + 3 - skb->data))) {\r\nstruct ip6_mh *mh;\r\nnh = skb_network_header(skb);\r\nmh = (struct ip6_mh *)(nh + offset);\r\nfl6->fl6_mh_type = mh->ip6mh_type;\r\n}\r\nfl6->flowi6_proto = nexthdr;\r\nreturn;\r\n#endif\r\ncase IPPROTO_AH:\r\ncase IPPROTO_ESP:\r\ncase IPPROTO_COMP:\r\ndefault:\r\nfl6->fl6_ipsec_spi = 0;\r\nfl6->flowi6_proto = nexthdr;\r\nreturn;\r\n}\r\n}\r\n}\r\nstatic inline int xfrm6_garbage_collect(struct dst_ops *ops)\r\n{\r\nstruct net *net = container_of(ops, struct net, xfrm.xfrm6_dst_ops);\r\nxfrm6_policy_afinfo.garbage_collect(net);\r\nreturn dst_entries_get_fast(ops) > ops->gc_thresh * 2;\r\n}\r\nstatic void xfrm6_update_pmtu(struct dst_entry *dst, struct sock *sk,\r\nstruct sk_buff *skb, u32 mtu)\r\n{\r\nstruct xfrm_dst *xdst = (struct xfrm_dst *)dst;\r\nstruct dst_entry *path = xdst->route;\r\npath->ops->update_pmtu(path, sk, skb, mtu);\r\n}\r\nstatic void xfrm6_redirect(struct dst_entry *dst, struct sock *sk,\r\nstruct sk_buff *skb)\r\n{\r\nstruct xfrm_dst *xdst = (struct xfrm_dst *)dst;\r\nstruct dst_entry *path = xdst->route;\r\npath->ops->redirect(path, sk, skb);\r\n}\r\nstatic void xfrm6_dst_destroy(struct dst_entry *dst)\r\n{\r\nstruct xfrm_dst *xdst = (struct xfrm_dst *)dst;\r\nif (likely(xdst->u.rt6.rt6i_idev))\r\nin6_dev_put(xdst->u.rt6.rt6i_idev);\r\ndst_destroy_metrics_generic(dst);\r\nxfrm_dst_destroy(xdst);\r\n}\r\nstatic void xfrm6_dst_ifdown(struct dst_entry *dst, struct net_device *dev,\r\nint unregister)\r\n{\r\nstruct xfrm_dst *xdst;\r\nif (!unregister)\r\nreturn;\r\nxdst = (struct xfrm_dst *)dst;\r\nif (xdst->u.rt6.rt6i_idev->dev == dev) {\r\nstruct inet6_dev *loopback_idev =\r\nin6_dev_get(dev_net(dev)->loopback_dev);\r\nBUG_ON(!loopback_idev);\r\ndo {\r\nin6_dev_put(xdst->u.rt6.rt6i_idev);\r\nxdst->u.rt6.rt6i_idev = loopback_idev;\r\nin6_dev_hold(loopback_idev);\r\nxdst = (struct xfrm_dst *)xdst->u.dst.child;\r\n} while (xdst->u.dst.xfrm);\r\n__in6_dev_put(loopback_idev);\r\n}\r\nxfrm_dst_ifdown(dst, dev);\r\n}\r\nstatic int __init xfrm6_policy_init(void)\r\n{\r\nreturn xfrm_policy_register_afinfo(&xfrm6_policy_afinfo);\r\n}\r\nstatic void xfrm6_policy_fini(void)\r\n{\r\nxfrm_policy_unregister_afinfo(&xfrm6_policy_afinfo);\r\n}\r\nstatic int __net_init xfrm6_net_sysctl_init(struct net *net)\r\n{\r\nstruct ctl_table *table;\r\nstruct ctl_table_header *hdr;\r\ntable = xfrm6_policy_table;\r\nif (!net_eq(net, &init_net)) {\r\ntable = kmemdup(table, sizeof(xfrm6_policy_table), GFP_KERNEL);\r\nif (!table)\r\ngoto err_alloc;\r\ntable[0].data = &net->xfrm.xfrm6_dst_ops.gc_thresh;\r\n}\r\nhdr = register_net_sysctl(net, "net/ipv6", table);\r\nif (!hdr)\r\ngoto err_reg;\r\nnet->ipv6.sysctl.xfrm6_hdr = hdr;\r\nreturn 0;\r\nerr_reg:\r\nif (!net_eq(net, &init_net))\r\nkfree(table);\r\nerr_alloc:\r\nreturn -ENOMEM;\r\n}\r\nstatic void __net_exit xfrm6_net_sysctl_exit(struct net *net)\r\n{\r\nstruct ctl_table *table;\r\nif (!net->ipv6.sysctl.xfrm6_hdr)\r\nreturn;\r\ntable = net->ipv6.sysctl.xfrm6_hdr->ctl_table_arg;\r\nunregister_net_sysctl_table(net->ipv6.sysctl.xfrm6_hdr);\r\nif (!net_eq(net, &init_net))\r\nkfree(table);\r\n}\r\nstatic int inline xfrm6_net_sysctl_init(struct net *net)\r\n{\r\nreturn 0;\r\n}\r\nstatic void inline xfrm6_net_sysctl_exit(struct net *net)\r\n{\r\n}\r\nstatic int __net_init xfrm6_net_init(struct net *net)\r\n{\r\nint ret;\r\nmemcpy(&net->xfrm.xfrm6_dst_ops, &xfrm6_dst_ops_template,\r\nsizeof(xfrm6_dst_ops_template));\r\nret = dst_entries_init(&net->xfrm.xfrm6_dst_ops);\r\nif (ret)\r\nreturn ret;\r\nret = xfrm6_net_sysctl_init(net);\r\nif (ret)\r\ndst_entries_destroy(&net->xfrm.xfrm6_dst_ops);\r\nreturn ret;\r\n}\r\nstatic void __net_exit xfrm6_net_exit(struct net *net)\r\n{\r\nxfrm6_net_sysctl_exit(net);\r\ndst_entries_destroy(&net->xfrm.xfrm6_dst_ops);\r\n}\r\nint __init xfrm6_init(void)\r\n{\r\nint ret;\r\nret = xfrm6_policy_init();\r\nif (ret)\r\ngoto out;\r\nret = xfrm6_state_init();\r\nif (ret)\r\ngoto out_policy;\r\nret = xfrm6_protocol_init();\r\nif (ret)\r\ngoto out_state;\r\nregister_pernet_subsys(&xfrm6_net_ops);\r\nout:\r\nreturn ret;\r\nout_state:\r\nxfrm6_state_fini();\r\nout_policy:\r\nxfrm6_policy_fini();\r\ngoto out;\r\n}\r\nvoid xfrm6_fini(void)\r\n{\r\nunregister_pernet_subsys(&xfrm6_net_ops);\r\nxfrm6_protocol_fini();\r\nxfrm6_policy_fini();\r\nxfrm6_state_fini();\r\n}
