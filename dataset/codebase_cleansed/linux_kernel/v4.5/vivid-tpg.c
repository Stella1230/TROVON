void tpg_set_font(const u8 *f)\r\n{\r\nfont8x16 = f;\r\n}\r\nvoid tpg_init(struct tpg_data *tpg, unsigned w, unsigned h)\r\n{\r\nmemset(tpg, 0, sizeof(*tpg));\r\ntpg->scaled_width = tpg->src_width = w;\r\ntpg->src_height = tpg->buf_height = h;\r\ntpg->crop.width = tpg->compose.width = w;\r\ntpg->crop.height = tpg->compose.height = h;\r\ntpg->recalc_colors = true;\r\ntpg->recalc_square_border = true;\r\ntpg->brightness = 128;\r\ntpg->contrast = 128;\r\ntpg->saturation = 128;\r\ntpg->hue = 0;\r\ntpg->mv_hor_mode = TPG_MOVE_NONE;\r\ntpg->mv_vert_mode = TPG_MOVE_NONE;\r\ntpg->field = V4L2_FIELD_NONE;\r\ntpg_s_fourcc(tpg, V4L2_PIX_FMT_RGB24);\r\ntpg->colorspace = V4L2_COLORSPACE_SRGB;\r\ntpg->perc_fill = 100;\r\n}\r\nint tpg_alloc(struct tpg_data *tpg, unsigned max_w)\r\n{\r\nunsigned pat;\r\nunsigned plane;\r\ntpg->max_line_width = max_w;\r\nfor (pat = 0; pat < TPG_MAX_PAT_LINES; pat++) {\r\nfor (plane = 0; plane < TPG_MAX_PLANES; plane++) {\r\nunsigned pixelsz = plane ? 2 : 4;\r\ntpg->lines[pat][plane] = vzalloc(max_w * 2 * pixelsz);\r\nif (!tpg->lines[pat][plane])\r\nreturn -ENOMEM;\r\nif (plane == 0)\r\ncontinue;\r\ntpg->downsampled_lines[pat][plane] = vzalloc(max_w * 2 * pixelsz);\r\nif (!tpg->downsampled_lines[pat][plane])\r\nreturn -ENOMEM;\r\n}\r\n}\r\nfor (plane = 0; plane < TPG_MAX_PLANES; plane++) {\r\nunsigned pixelsz = plane ? 2 : 4;\r\ntpg->contrast_line[plane] = vzalloc(max_w * pixelsz);\r\nif (!tpg->contrast_line[plane])\r\nreturn -ENOMEM;\r\ntpg->black_line[plane] = vzalloc(max_w * pixelsz);\r\nif (!tpg->black_line[plane])\r\nreturn -ENOMEM;\r\ntpg->random_line[plane] = vzalloc(max_w * 2 * pixelsz);\r\nif (!tpg->random_line[plane])\r\nreturn -ENOMEM;\r\n}\r\nreturn 0;\r\n}\r\nvoid tpg_free(struct tpg_data *tpg)\r\n{\r\nunsigned pat;\r\nunsigned plane;\r\nfor (pat = 0; pat < TPG_MAX_PAT_LINES; pat++)\r\nfor (plane = 0; plane < TPG_MAX_PLANES; plane++) {\r\nvfree(tpg->lines[pat][plane]);\r\ntpg->lines[pat][plane] = NULL;\r\nif (plane == 0)\r\ncontinue;\r\nvfree(tpg->downsampled_lines[pat][plane]);\r\ntpg->downsampled_lines[pat][plane] = NULL;\r\n}\r\nfor (plane = 0; plane < TPG_MAX_PLANES; plane++) {\r\nvfree(tpg->contrast_line[plane]);\r\nvfree(tpg->black_line[plane]);\r\nvfree(tpg->random_line[plane]);\r\ntpg->contrast_line[plane] = NULL;\r\ntpg->black_line[plane] = NULL;\r\ntpg->random_line[plane] = NULL;\r\n}\r\n}\r\nbool tpg_s_fourcc(struct tpg_data *tpg, u32 fourcc)\r\n{\r\ntpg->fourcc = fourcc;\r\ntpg->planes = 1;\r\ntpg->buffers = 1;\r\ntpg->recalc_colors = true;\r\ntpg->interleaved = false;\r\ntpg->vdownsampling[0] = 1;\r\ntpg->hdownsampling[0] = 1;\r\ntpg->hmask[0] = ~0;\r\ntpg->hmask[1] = ~0;\r\ntpg->hmask[2] = ~0;\r\nswitch (fourcc) {\r\ncase V4L2_PIX_FMT_SBGGR8:\r\ncase V4L2_PIX_FMT_SGBRG8:\r\ncase V4L2_PIX_FMT_SGRBG8:\r\ncase V4L2_PIX_FMT_SRGGB8:\r\ncase V4L2_PIX_FMT_SBGGR10:\r\ncase V4L2_PIX_FMT_SGBRG10:\r\ncase V4L2_PIX_FMT_SGRBG10:\r\ncase V4L2_PIX_FMT_SRGGB10:\r\ncase V4L2_PIX_FMT_SBGGR12:\r\ncase V4L2_PIX_FMT_SGBRG12:\r\ncase V4L2_PIX_FMT_SGRBG12:\r\ncase V4L2_PIX_FMT_SRGGB12:\r\ntpg->interleaved = true;\r\ntpg->vdownsampling[1] = 1;\r\ntpg->hdownsampling[1] = 1;\r\ntpg->planes = 2;\r\ncase V4L2_PIX_FMT_RGB332:\r\ncase V4L2_PIX_FMT_RGB565:\r\ncase V4L2_PIX_FMT_RGB565X:\r\ncase V4L2_PIX_FMT_RGB444:\r\ncase V4L2_PIX_FMT_XRGB444:\r\ncase V4L2_PIX_FMT_ARGB444:\r\ncase V4L2_PIX_FMT_RGB555:\r\ncase V4L2_PIX_FMT_XRGB555:\r\ncase V4L2_PIX_FMT_ARGB555:\r\ncase V4L2_PIX_FMT_RGB555X:\r\ncase V4L2_PIX_FMT_XRGB555X:\r\ncase V4L2_PIX_FMT_ARGB555X:\r\ncase V4L2_PIX_FMT_BGR666:\r\ncase V4L2_PIX_FMT_RGB24:\r\ncase V4L2_PIX_FMT_BGR24:\r\ncase V4L2_PIX_FMT_RGB32:\r\ncase V4L2_PIX_FMT_BGR32:\r\ncase V4L2_PIX_FMT_XRGB32:\r\ncase V4L2_PIX_FMT_XBGR32:\r\ncase V4L2_PIX_FMT_ARGB32:\r\ncase V4L2_PIX_FMT_ABGR32:\r\ncase V4L2_PIX_FMT_GREY:\r\ncase V4L2_PIX_FMT_Y16:\r\ncase V4L2_PIX_FMT_Y16_BE:\r\ntpg->is_yuv = false;\r\nbreak;\r\ncase V4L2_PIX_FMT_YUV444:\r\ncase V4L2_PIX_FMT_YUV555:\r\ncase V4L2_PIX_FMT_YUV565:\r\ncase V4L2_PIX_FMT_YUV32:\r\ntpg->is_yuv = true;\r\nbreak;\r\ncase V4L2_PIX_FMT_YUV420M:\r\ncase V4L2_PIX_FMT_YVU420M:\r\ntpg->buffers = 3;\r\ncase V4L2_PIX_FMT_YUV420:\r\ncase V4L2_PIX_FMT_YVU420:\r\ntpg->vdownsampling[1] = 2;\r\ntpg->vdownsampling[2] = 2;\r\ntpg->hdownsampling[1] = 2;\r\ntpg->hdownsampling[2] = 2;\r\ntpg->planes = 3;\r\ntpg->is_yuv = true;\r\nbreak;\r\ncase V4L2_PIX_FMT_YUV422P:\r\ntpg->vdownsampling[1] = 1;\r\ntpg->vdownsampling[2] = 1;\r\ntpg->hdownsampling[1] = 2;\r\ntpg->hdownsampling[2] = 2;\r\ntpg->planes = 3;\r\ntpg->is_yuv = true;\r\nbreak;\r\ncase V4L2_PIX_FMT_NV16M:\r\ncase V4L2_PIX_FMT_NV61M:\r\ntpg->buffers = 2;\r\ncase V4L2_PIX_FMT_NV16:\r\ncase V4L2_PIX_FMT_NV61:\r\ntpg->vdownsampling[1] = 1;\r\ntpg->hdownsampling[1] = 1;\r\ntpg->hmask[1] = ~1;\r\ntpg->planes = 2;\r\ntpg->is_yuv = true;\r\nbreak;\r\ncase V4L2_PIX_FMT_NV12M:\r\ncase V4L2_PIX_FMT_NV21M:\r\ntpg->buffers = 2;\r\ncase V4L2_PIX_FMT_NV12:\r\ncase V4L2_PIX_FMT_NV21:\r\ntpg->vdownsampling[1] = 2;\r\ntpg->hdownsampling[1] = 1;\r\ntpg->hmask[1] = ~1;\r\ntpg->planes = 2;\r\ntpg->is_yuv = true;\r\nbreak;\r\ncase V4L2_PIX_FMT_NV24:\r\ncase V4L2_PIX_FMT_NV42:\r\ntpg->vdownsampling[1] = 1;\r\ntpg->hdownsampling[1] = 1;\r\ntpg->planes = 2;\r\ntpg->is_yuv = true;\r\nbreak;\r\ncase V4L2_PIX_FMT_YUYV:\r\ncase V4L2_PIX_FMT_UYVY:\r\ncase V4L2_PIX_FMT_YVYU:\r\ncase V4L2_PIX_FMT_VYUY:\r\ntpg->hmask[0] = ~1;\r\ntpg->is_yuv = true;\r\nbreak;\r\ndefault:\r\nreturn false;\r\n}\r\nswitch (fourcc) {\r\ncase V4L2_PIX_FMT_GREY:\r\ncase V4L2_PIX_FMT_RGB332:\r\ntpg->twopixelsize[0] = 2;\r\nbreak;\r\ncase V4L2_PIX_FMT_RGB565:\r\ncase V4L2_PIX_FMT_RGB565X:\r\ncase V4L2_PIX_FMT_RGB444:\r\ncase V4L2_PIX_FMT_XRGB444:\r\ncase V4L2_PIX_FMT_ARGB444:\r\ncase V4L2_PIX_FMT_RGB555:\r\ncase V4L2_PIX_FMT_XRGB555:\r\ncase V4L2_PIX_FMT_ARGB555:\r\ncase V4L2_PIX_FMT_RGB555X:\r\ncase V4L2_PIX_FMT_XRGB555X:\r\ncase V4L2_PIX_FMT_ARGB555X:\r\ncase V4L2_PIX_FMT_YUYV:\r\ncase V4L2_PIX_FMT_UYVY:\r\ncase V4L2_PIX_FMT_YVYU:\r\ncase V4L2_PIX_FMT_VYUY:\r\ncase V4L2_PIX_FMT_YUV444:\r\ncase V4L2_PIX_FMT_YUV555:\r\ncase V4L2_PIX_FMT_YUV565:\r\ncase V4L2_PIX_FMT_Y16:\r\ncase V4L2_PIX_FMT_Y16_BE:\r\ntpg->twopixelsize[0] = 2 * 2;\r\nbreak;\r\ncase V4L2_PIX_FMT_RGB24:\r\ncase V4L2_PIX_FMT_BGR24:\r\ntpg->twopixelsize[0] = 2 * 3;\r\nbreak;\r\ncase V4L2_PIX_FMT_BGR666:\r\ncase V4L2_PIX_FMT_RGB32:\r\ncase V4L2_PIX_FMT_BGR32:\r\ncase V4L2_PIX_FMT_XRGB32:\r\ncase V4L2_PIX_FMT_XBGR32:\r\ncase V4L2_PIX_FMT_ARGB32:\r\ncase V4L2_PIX_FMT_ABGR32:\r\ncase V4L2_PIX_FMT_YUV32:\r\ntpg->twopixelsize[0] = 2 * 4;\r\nbreak;\r\ncase V4L2_PIX_FMT_NV12:\r\ncase V4L2_PIX_FMT_NV21:\r\ncase V4L2_PIX_FMT_NV12M:\r\ncase V4L2_PIX_FMT_NV21M:\r\ncase V4L2_PIX_FMT_NV16:\r\ncase V4L2_PIX_FMT_NV61:\r\ncase V4L2_PIX_FMT_NV16M:\r\ncase V4L2_PIX_FMT_NV61M:\r\ncase V4L2_PIX_FMT_SBGGR8:\r\ncase V4L2_PIX_FMT_SGBRG8:\r\ncase V4L2_PIX_FMT_SGRBG8:\r\ncase V4L2_PIX_FMT_SRGGB8:\r\ntpg->twopixelsize[0] = 2;\r\ntpg->twopixelsize[1] = 2;\r\nbreak;\r\ncase V4L2_PIX_FMT_SRGGB10:\r\ncase V4L2_PIX_FMT_SGRBG10:\r\ncase V4L2_PIX_FMT_SGBRG10:\r\ncase V4L2_PIX_FMT_SBGGR10:\r\ncase V4L2_PIX_FMT_SRGGB12:\r\ncase V4L2_PIX_FMT_SGRBG12:\r\ncase V4L2_PIX_FMT_SGBRG12:\r\ncase V4L2_PIX_FMT_SBGGR12:\r\ntpg->twopixelsize[0] = 4;\r\ntpg->twopixelsize[1] = 4;\r\nbreak;\r\ncase V4L2_PIX_FMT_YUV422P:\r\ncase V4L2_PIX_FMT_YUV420:\r\ncase V4L2_PIX_FMT_YVU420:\r\ncase V4L2_PIX_FMT_YUV420M:\r\ncase V4L2_PIX_FMT_YVU420M:\r\ntpg->twopixelsize[0] = 2;\r\ntpg->twopixelsize[1] = 2;\r\ntpg->twopixelsize[2] = 2;\r\nbreak;\r\ncase V4L2_PIX_FMT_NV24:\r\ncase V4L2_PIX_FMT_NV42:\r\ntpg->twopixelsize[0] = 2;\r\ntpg->twopixelsize[1] = 4;\r\nbreak;\r\n}\r\nreturn true;\r\n}\r\nvoid tpg_s_crop_compose(struct tpg_data *tpg, const struct v4l2_rect *crop,\r\nconst struct v4l2_rect *compose)\r\n{\r\ntpg->crop = *crop;\r\ntpg->compose = *compose;\r\ntpg->scaled_width = (tpg->src_width * tpg->compose.width +\r\ntpg->crop.width - 1) / tpg->crop.width;\r\ntpg->scaled_width &= ~1;\r\nif (tpg->scaled_width > tpg->max_line_width)\r\ntpg->scaled_width = tpg->max_line_width;\r\nif (tpg->scaled_width < 2)\r\ntpg->scaled_width = 2;\r\ntpg->recalc_lines = true;\r\n}\r\nvoid tpg_reset_source(struct tpg_data *tpg, unsigned width, unsigned height,\r\nu32 field)\r\n{\r\nunsigned p;\r\ntpg->src_width = width;\r\ntpg->src_height = height;\r\ntpg->field = field;\r\ntpg->buf_height = height;\r\nif (V4L2_FIELD_HAS_T_OR_B(field))\r\ntpg->buf_height /= 2;\r\ntpg->scaled_width = width;\r\ntpg->crop.top = tpg->crop.left = 0;\r\ntpg->crop.width = width;\r\ntpg->crop.height = height;\r\ntpg->compose.top = tpg->compose.left = 0;\r\ntpg->compose.width = width;\r\ntpg->compose.height = tpg->buf_height;\r\nfor (p = 0; p < tpg->planes; p++)\r\ntpg->bytesperline[p] = (width * tpg->twopixelsize[p]) /\r\n(2 * tpg->hdownsampling[p]);\r\ntpg->recalc_square_border = true;\r\n}\r\nstatic enum tpg_color tpg_get_textbg_color(struct tpg_data *tpg)\r\n{\r\nswitch (tpg->pattern) {\r\ncase TPG_PAT_BLACK:\r\nreturn TPG_COLOR_100_WHITE;\r\ncase TPG_PAT_CSC_COLORBAR:\r\nreturn TPG_COLOR_CSC_BLACK;\r\ndefault:\r\nreturn TPG_COLOR_100_BLACK;\r\n}\r\n}\r\nstatic enum tpg_color tpg_get_textfg_color(struct tpg_data *tpg)\r\n{\r\nswitch (tpg->pattern) {\r\ncase TPG_PAT_75_COLORBAR:\r\ncase TPG_PAT_CSC_COLORBAR:\r\nreturn TPG_COLOR_CSC_WHITE;\r\ncase TPG_PAT_BLACK:\r\nreturn TPG_COLOR_100_BLACK;\r\ndefault:\r\nreturn TPG_COLOR_100_WHITE;\r\n}\r\n}\r\nstatic inline int rec709_to_linear(int v)\r\n{\r\nv = clamp(v, 0, 0xff0);\r\nreturn tpg_rec709_to_linear[v];\r\n}\r\nstatic inline int linear_to_rec709(int v)\r\n{\r\nv = clamp(v, 0, 0xff0);\r\nreturn tpg_linear_to_rec709[v];\r\n}\r\nstatic void rgb2ycbcr(const int m[3][3], int r, int g, int b,\r\nint y_offset, int *y, int *cb, int *cr)\r\n{\r\n*y = ((m[0][0] * r + m[0][1] * g + m[0][2] * b) >> 16) + (y_offset << 4);\r\n*cb = ((m[1][0] * r + m[1][1] * g + m[1][2] * b) >> 16) + (128 << 4);\r\n*cr = ((m[2][0] * r + m[2][1] * g + m[2][2] * b) >> 16) + (128 << 4);\r\n}\r\nstatic void color_to_ycbcr(struct tpg_data *tpg, int r, int g, int b,\r\nint *y, int *cb, int *cr)\r\n{\r\n#define COEFF(v, r) ((int)(0.5 + (v) * (r) * 256.0))\r\nstatic const int bt601[3][3] = {\r\n{ COEFF(0.299, 219), COEFF(0.587, 219), COEFF(0.114, 219) },\r\n{ COEFF(-0.169, 224), COEFF(-0.331, 224), COEFF(0.5, 224) },\r\n{ COEFF(0.5, 224), COEFF(-0.419, 224), COEFF(-0.081, 224) },\r\n};\r\nstatic const int bt601_full[3][3] = {\r\n{ COEFF(0.299, 255), COEFF(0.587, 255), COEFF(0.114, 255) },\r\n{ COEFF(-0.169, 255), COEFF(-0.331, 255), COEFF(0.5, 255) },\r\n{ COEFF(0.5, 255), COEFF(-0.419, 255), COEFF(-0.081, 255) },\r\n};\r\nstatic const int rec709[3][3] = {\r\n{ COEFF(0.2126, 219), COEFF(0.7152, 219), COEFF(0.0722, 219) },\r\n{ COEFF(-0.1146, 224), COEFF(-0.3854, 224), COEFF(0.5, 224) },\r\n{ COEFF(0.5, 224), COEFF(-0.4542, 224), COEFF(-0.0458, 224) },\r\n};\r\nstatic const int rec709_full[3][3] = {\r\n{ COEFF(0.2126, 255), COEFF(0.7152, 255), COEFF(0.0722, 255) },\r\n{ COEFF(-0.1146, 255), COEFF(-0.3854, 255), COEFF(0.5, 255) },\r\n{ COEFF(0.5, 255), COEFF(-0.4542, 255), COEFF(-0.0458, 255) },\r\n};\r\nstatic const int smpte240m[3][3] = {\r\n{ COEFF(0.212, 219), COEFF(0.701, 219), COEFF(0.087, 219) },\r\n{ COEFF(-0.116, 224), COEFF(-0.384, 224), COEFF(0.5, 224) },\r\n{ COEFF(0.5, 224), COEFF(-0.445, 224), COEFF(-0.055, 224) },\r\n};\r\nstatic const int smpte240m_full[3][3] = {\r\n{ COEFF(0.212, 255), COEFF(0.701, 255), COEFF(0.087, 255) },\r\n{ COEFF(-0.116, 255), COEFF(-0.384, 255), COEFF(0.5, 255) },\r\n{ COEFF(0.5, 255), COEFF(-0.445, 255), COEFF(-0.055, 255) },\r\n};\r\nstatic const int bt2020[3][3] = {\r\n{ COEFF(0.2627, 219), COEFF(0.6780, 219), COEFF(0.0593, 219) },\r\n{ COEFF(-0.1396, 224), COEFF(-0.3604, 224), COEFF(0.5, 224) },\r\n{ COEFF(0.5, 224), COEFF(-0.4598, 224), COEFF(-0.0402, 224) },\r\n};\r\nstatic const int bt2020_full[3][3] = {\r\n{ COEFF(0.2627, 255), COEFF(0.6780, 255), COEFF(0.0593, 255) },\r\n{ COEFF(-0.1396, 255), COEFF(-0.3604, 255), COEFF(0.5, 255) },\r\n{ COEFF(0.5, 255), COEFF(-0.4698, 255), COEFF(-0.0402, 255) },\r\n};\r\nstatic const int bt2020c[4] = {\r\nCOEFF(1.0 / 1.9404, 224), COEFF(1.0 / 1.5816, 224),\r\nCOEFF(1.0 / 1.7184, 224), COEFF(1.0 / 0.9936, 224),\r\n};\r\nstatic const int bt2020c_full[4] = {\r\nCOEFF(1.0 / 1.9404, 255), COEFF(1.0 / 1.5816, 255),\r\nCOEFF(1.0 / 1.7184, 255), COEFF(1.0 / 0.9936, 255),\r\n};\r\nbool full = tpg->real_quantization == V4L2_QUANTIZATION_FULL_RANGE;\r\nunsigned y_offset = full ? 0 : 16;\r\nint lin_y, yc;\r\nswitch (tpg->real_ycbcr_enc) {\r\ncase V4L2_YCBCR_ENC_601:\r\ncase V4L2_YCBCR_ENC_SYCC:\r\nrgb2ycbcr(full ? bt601_full : bt601, r, g, b, y_offset, y, cb, cr);\r\nbreak;\r\ncase V4L2_YCBCR_ENC_XV601:\r\nrgb2ycbcr(bt601, r, g, b, 16, y, cb, cr);\r\nbreak;\r\ncase V4L2_YCBCR_ENC_XV709:\r\nrgb2ycbcr(rec709, r, g, b, 16, y, cb, cr);\r\nbreak;\r\ncase V4L2_YCBCR_ENC_BT2020:\r\nrgb2ycbcr(full ? bt2020_full : bt2020, r, g, b, y_offset, y, cb, cr);\r\nbreak;\r\ncase V4L2_YCBCR_ENC_BT2020_CONST_LUM:\r\nlin_y = (COEFF(0.2627, 255) * rec709_to_linear(r) +\r\nCOEFF(0.6780, 255) * rec709_to_linear(g) +\r\nCOEFF(0.0593, 255) * rec709_to_linear(b)) >> 16;\r\nyc = linear_to_rec709(lin_y);\r\n*y = full ? yc : (yc * 219) / 255 + (16 << 4);\r\nif (b <= yc)\r\n*cb = (((b - yc) * (full ? bt2020c_full[0] : bt2020c[0])) >> 16) + (128 << 4);\r\nelse\r\n*cb = (((b - yc) * (full ? bt2020c_full[1] : bt2020c[1])) >> 16) + (128 << 4);\r\nif (r <= yc)\r\n*cr = (((r - yc) * (full ? bt2020c_full[2] : bt2020c[2])) >> 16) + (128 << 4);\r\nelse\r\n*cr = (((r - yc) * (full ? bt2020c_full[3] : bt2020c[3])) >> 16) + (128 << 4);\r\nbreak;\r\ncase V4L2_YCBCR_ENC_SMPTE240M:\r\nrgb2ycbcr(full ? smpte240m_full : smpte240m, r, g, b, y_offset, y, cb, cr);\r\nbreak;\r\ncase V4L2_YCBCR_ENC_709:\r\ndefault:\r\nrgb2ycbcr(full ? rec709_full : rec709, r, g, b, y_offset, y, cb, cr);\r\nbreak;\r\n}\r\n}\r\nstatic void ycbcr2rgb(const int m[3][3], int y, int cb, int cr,\r\nint y_offset, int *r, int *g, int *b)\r\n{\r\ny -= y_offset << 4;\r\ncb -= 128 << 4;\r\ncr -= 128 << 4;\r\n*r = m[0][0] * y + m[0][1] * cb + m[0][2] * cr;\r\n*g = m[1][0] * y + m[1][1] * cb + m[1][2] * cr;\r\n*b = m[2][0] * y + m[2][1] * cb + m[2][2] * cr;\r\n*r = clamp(*r >> 12, 0, 0xff0);\r\n*g = clamp(*g >> 12, 0, 0xff0);\r\n*b = clamp(*b >> 12, 0, 0xff0);\r\n}\r\nstatic void ycbcr_to_color(struct tpg_data *tpg, int y, int cb, int cr,\r\nint *r, int *g, int *b)\r\n{\r\n#undef COEFF\r\n#define COEFF(v, r) ((int)(0.5 + (v) * ((255.0 * 255.0 * 16.0) / (r))))\r\nstatic const int bt601[3][3] = {\r\n{ COEFF(1, 219), COEFF(0, 224), COEFF(1.4020, 224) },\r\n{ COEFF(1, 219), COEFF(-0.3441, 224), COEFF(-0.7141, 224) },\r\n{ COEFF(1, 219), COEFF(1.7720, 224), COEFF(0, 224) },\r\n};\r\nstatic const int bt601_full[3][3] = {\r\n{ COEFF(1, 255), COEFF(0, 255), COEFF(1.4020, 255) },\r\n{ COEFF(1, 255), COEFF(-0.3441, 255), COEFF(-0.7141, 255) },\r\n{ COEFF(1, 255), COEFF(1.7720, 255), COEFF(0, 255) },\r\n};\r\nstatic const int rec709[3][3] = {\r\n{ COEFF(1, 219), COEFF(0, 224), COEFF(1.5748, 224) },\r\n{ COEFF(1, 219), COEFF(-0.1873, 224), COEFF(-0.4681, 224) },\r\n{ COEFF(1, 219), COEFF(1.8556, 224), COEFF(0, 224) },\r\n};\r\nstatic const int rec709_full[3][3] = {\r\n{ COEFF(1, 255), COEFF(0, 255), COEFF(1.5748, 255) },\r\n{ COEFF(1, 255), COEFF(-0.1873, 255), COEFF(-0.4681, 255) },\r\n{ COEFF(1, 255), COEFF(1.8556, 255), COEFF(0, 255) },\r\n};\r\nstatic const int smpte240m[3][3] = {\r\n{ COEFF(1, 219), COEFF(0, 224), COEFF(1.5756, 224) },\r\n{ COEFF(1, 219), COEFF(-0.2253, 224), COEFF(-0.4767, 224) },\r\n{ COEFF(1, 219), COEFF(1.8270, 224), COEFF(0, 224) },\r\n};\r\nstatic const int smpte240m_full[3][3] = {\r\n{ COEFF(1, 255), COEFF(0, 255), COEFF(1.5756, 255) },\r\n{ COEFF(1, 255), COEFF(-0.2253, 255), COEFF(-0.4767, 255) },\r\n{ COEFF(1, 255), COEFF(1.8270, 255), COEFF(0, 255) },\r\n};\r\nstatic const int bt2020[3][3] = {\r\n{ COEFF(1, 219), COEFF(0, 224), COEFF(1.4746, 224) },\r\n{ COEFF(1, 219), COEFF(-0.1646, 224), COEFF(-0.5714, 224) },\r\n{ COEFF(1, 219), COEFF(1.8814, 224), COEFF(0, 224) },\r\n};\r\nstatic const int bt2020_full[3][3] = {\r\n{ COEFF(1, 255), COEFF(0, 255), COEFF(1.4746, 255) },\r\n{ COEFF(1, 255), COEFF(-0.1646, 255), COEFF(-0.5714, 255) },\r\n{ COEFF(1, 255), COEFF(1.8814, 255), COEFF(0, 255) },\r\n};\r\nstatic const int bt2020c[4] = {\r\nCOEFF(1.9404, 224), COEFF(1.5816, 224),\r\nCOEFF(1.7184, 224), COEFF(0.9936, 224),\r\n};\r\nstatic const int bt2020c_full[4] = {\r\nCOEFF(1.9404, 255), COEFF(1.5816, 255),\r\nCOEFF(1.7184, 255), COEFF(0.9936, 255),\r\n};\r\nbool full = tpg->real_quantization == V4L2_QUANTIZATION_FULL_RANGE;\r\nunsigned y_offset = full ? 0 : 16;\r\nint y_fac = full ? COEFF(1.0, 255) : COEFF(1.0, 219);\r\nint lin_r, lin_g, lin_b, lin_y;\r\nswitch (tpg->real_ycbcr_enc) {\r\ncase V4L2_YCBCR_ENC_601:\r\ncase V4L2_YCBCR_ENC_SYCC:\r\nycbcr2rgb(full ? bt601_full : bt601, y, cb, cr, y_offset, r, g, b);\r\nbreak;\r\ncase V4L2_YCBCR_ENC_XV601:\r\nycbcr2rgb(bt601, y, cb, cr, 16, r, g, b);\r\nbreak;\r\ncase V4L2_YCBCR_ENC_XV709:\r\nycbcr2rgb(rec709, y, cb, cr, 16, r, g, b);\r\nbreak;\r\ncase V4L2_YCBCR_ENC_BT2020:\r\nycbcr2rgb(full ? bt2020_full : bt2020, y, cb, cr, y_offset, r, g, b);\r\nbreak;\r\ncase V4L2_YCBCR_ENC_BT2020_CONST_LUM:\r\ny -= full ? 0 : 16 << 4;\r\ncb -= 128 << 4;\r\ncr -= 128 << 4;\r\nif (cb <= 0)\r\n*b = y_fac * y + (full ? bt2020c_full[0] : bt2020c[0]) * cb;\r\nelse\r\n*b = y_fac * y + (full ? bt2020c_full[1] : bt2020c[1]) * cb;\r\n*b = *b >> 12;\r\nif (cr <= 0)\r\n*r = y_fac * y + (full ? bt2020c_full[2] : bt2020c[2]) * cr;\r\nelse\r\n*r = y_fac * y + (full ? bt2020c_full[3] : bt2020c[3]) * cr;\r\n*r = *r >> 12;\r\nlin_r = rec709_to_linear(*r);\r\nlin_b = rec709_to_linear(*b);\r\nlin_y = rec709_to_linear((y * 255) / (full ? 255 : 219));\r\nlin_g = COEFF(1.0 / 0.6780, 255) * lin_y -\r\nCOEFF(0.2627 / 0.6780, 255) * lin_r -\r\nCOEFF(0.0593 / 0.6780, 255) * lin_b;\r\n*g = linear_to_rec709(lin_g >> 12);\r\nbreak;\r\ncase V4L2_YCBCR_ENC_SMPTE240M:\r\nycbcr2rgb(full ? smpte240m_full : smpte240m, y, cb, cr, y_offset, r, g, b);\r\nbreak;\r\ncase V4L2_YCBCR_ENC_709:\r\ndefault:\r\nycbcr2rgb(full ? rec709_full : rec709, y, cb, cr, y_offset, r, g, b);\r\nbreak;\r\n}\r\n}\r\nstatic void precalculate_color(struct tpg_data *tpg, int k)\r\n{\r\nint col = k;\r\nint r = tpg_colors[col].r;\r\nint g = tpg_colors[col].g;\r\nint b = tpg_colors[col].b;\r\nif (k == TPG_COLOR_TEXTBG) {\r\ncol = tpg_get_textbg_color(tpg);\r\nr = tpg_colors[col].r;\r\ng = tpg_colors[col].g;\r\nb = tpg_colors[col].b;\r\n} else if (k == TPG_COLOR_TEXTFG) {\r\ncol = tpg_get_textfg_color(tpg);\r\nr = tpg_colors[col].r;\r\ng = tpg_colors[col].g;\r\nb = tpg_colors[col].b;\r\n} else if (tpg->pattern == TPG_PAT_NOISE) {\r\nr = g = b = prandom_u32_max(256);\r\n} else if (k == TPG_COLOR_RANDOM) {\r\nr = g = b = tpg->qual_offset + prandom_u32_max(196);\r\n} else if (k >= TPG_COLOR_RAMP) {\r\nr = g = b = k - TPG_COLOR_RAMP;\r\n}\r\nif (tpg->pattern == TPG_PAT_CSC_COLORBAR && col <= TPG_COLOR_CSC_BLACK) {\r\nr = tpg_csc_colors[tpg->colorspace][tpg->real_xfer_func][col].r;\r\ng = tpg_csc_colors[tpg->colorspace][tpg->real_xfer_func][col].g;\r\nb = tpg_csc_colors[tpg->colorspace][tpg->real_xfer_func][col].b;\r\n} else {\r\nr <<= 4;\r\ng <<= 4;\r\nb <<= 4;\r\n}\r\nif (tpg->qual == TPG_QUAL_GRAY || tpg->fourcc == V4L2_PIX_FMT_GREY ||\r\ntpg->fourcc == V4L2_PIX_FMT_Y16 ||\r\ntpg->fourcc == V4L2_PIX_FMT_Y16_BE) {\r\nr = g = b = (13879 * r + 46688 * g + 4713 * b) >> 16;\r\n}\r\nif (tpg->real_rgb_range == V4L2_DV_RGB_RANGE_LIMITED &&\r\ntpg->rgb_range == V4L2_DV_RGB_RANGE_FULL) {\r\nr = (r * 219) / 255 + (16 << 4);\r\ng = (g * 219) / 255 + (16 << 4);\r\nb = (b * 219) / 255 + (16 << 4);\r\n} else if (tpg->real_rgb_range != V4L2_DV_RGB_RANGE_LIMITED &&\r\ntpg->rgb_range == V4L2_DV_RGB_RANGE_LIMITED) {\r\nr = clamp(r, 16 << 4, 235 << 4);\r\ng = clamp(g, 16 << 4, 235 << 4);\r\nb = clamp(b, 16 << 4, 235 << 4);\r\nr = (r - (16 << 4)) * 255 / 219;\r\ng = (g - (16 << 4)) * 255 / 219;\r\nb = (b - (16 << 4)) * 255 / 219;\r\n}\r\nif (tpg->brightness != 128 || tpg->contrast != 128 ||\r\ntpg->saturation != 128 || tpg->hue) {\r\nint y, cb, cr;\r\nint tmp_cb, tmp_cr;\r\ncolor_to_ycbcr(tpg, r, g, b, &y, &cb, &cr);\r\ny = (16 << 4) + ((y - (16 << 4)) * tpg->contrast) / 128;\r\ny += (tpg->brightness << 4) - (128 << 4);\r\ncb -= 128 << 4;\r\ncr -= 128 << 4;\r\ntmp_cb = (cb * cos(128 + tpg->hue)) / 127 + (cr * sin[128 + tpg->hue]) / 127;\r\ntmp_cr = (cr * cos(128 + tpg->hue)) / 127 - (cb * sin[128 + tpg->hue]) / 127;\r\ncb = (128 << 4) + (tmp_cb * tpg->contrast * tpg->saturation) / (128 * 128);\r\ncr = (128 << 4) + (tmp_cr * tpg->contrast * tpg->saturation) / (128 * 128);\r\nif (tpg->is_yuv) {\r\ntpg->colors[k][0] = clamp(y >> 4, 1, 254);\r\ntpg->colors[k][1] = clamp(cb >> 4, 1, 254);\r\ntpg->colors[k][2] = clamp(cr >> 4, 1, 254);\r\nreturn;\r\n}\r\nycbcr_to_color(tpg, y, cb, cr, &r, &g, &b);\r\n}\r\nif (tpg->is_yuv) {\r\nint y, cb, cr;\r\ncolor_to_ycbcr(tpg, r, g, b, &y, &cb, &cr);\r\nif (tpg->real_quantization == V4L2_QUANTIZATION_LIM_RANGE) {\r\ny = clamp(y, 16 << 4, 235 << 4);\r\ncb = clamp(cb, 16 << 4, 240 << 4);\r\ncr = clamp(cr, 16 << 4, 240 << 4);\r\n}\r\ny = clamp(y >> 4, 1, 254);\r\ncb = clamp(cb >> 4, 1, 254);\r\ncr = clamp(cr >> 4, 1, 254);\r\nswitch (tpg->fourcc) {\r\ncase V4L2_PIX_FMT_YUV444:\r\ny >>= 4;\r\ncb >>= 4;\r\ncr >>= 4;\r\nbreak;\r\ncase V4L2_PIX_FMT_YUV555:\r\ny >>= 3;\r\ncb >>= 3;\r\ncr >>= 3;\r\nbreak;\r\ncase V4L2_PIX_FMT_YUV565:\r\ny >>= 3;\r\ncb >>= 2;\r\ncr >>= 3;\r\nbreak;\r\n}\r\ntpg->colors[k][0] = y;\r\ntpg->colors[k][1] = cb;\r\ntpg->colors[k][2] = cr;\r\n} else {\r\nif (tpg->real_quantization == V4L2_QUANTIZATION_LIM_RANGE) {\r\nr = (r * 219) / 255 + (16 << 4);\r\ng = (g * 219) / 255 + (16 << 4);\r\nb = (b * 219) / 255 + (16 << 4);\r\n}\r\nswitch (tpg->fourcc) {\r\ncase V4L2_PIX_FMT_RGB332:\r\nr >>= 9;\r\ng >>= 9;\r\nb >>= 10;\r\nbreak;\r\ncase V4L2_PIX_FMT_RGB565:\r\ncase V4L2_PIX_FMT_RGB565X:\r\nr >>= 7;\r\ng >>= 6;\r\nb >>= 7;\r\nbreak;\r\ncase V4L2_PIX_FMT_RGB444:\r\ncase V4L2_PIX_FMT_XRGB444:\r\ncase V4L2_PIX_FMT_ARGB444:\r\nr >>= 8;\r\ng >>= 8;\r\nb >>= 8;\r\nbreak;\r\ncase V4L2_PIX_FMT_RGB555:\r\ncase V4L2_PIX_FMT_XRGB555:\r\ncase V4L2_PIX_FMT_ARGB555:\r\ncase V4L2_PIX_FMT_RGB555X:\r\ncase V4L2_PIX_FMT_XRGB555X:\r\ncase V4L2_PIX_FMT_ARGB555X:\r\nr >>= 7;\r\ng >>= 7;\r\nb >>= 7;\r\nbreak;\r\ncase V4L2_PIX_FMT_BGR666:\r\nr >>= 6;\r\ng >>= 6;\r\nb >>= 6;\r\nbreak;\r\ndefault:\r\nr >>= 4;\r\ng >>= 4;\r\nb >>= 4;\r\nbreak;\r\n}\r\ntpg->colors[k][0] = r;\r\ntpg->colors[k][1] = g;\r\ntpg->colors[k][2] = b;\r\n}\r\n}\r\nstatic void tpg_precalculate_colors(struct tpg_data *tpg)\r\n{\r\nint k;\r\nfor (k = 0; k < TPG_COLOR_MAX; k++)\r\nprecalculate_color(tpg, k);\r\n}\r\nstatic void gen_twopix(struct tpg_data *tpg,\r\nu8 buf[TPG_MAX_PLANES][8], int color, bool odd)\r\n{\r\nunsigned offset = odd * tpg->twopixelsize[0] / 2;\r\nu8 alpha = tpg->alpha_component;\r\nu8 r_y, g_u, b_v;\r\nif (tpg->alpha_red_only && color != TPG_COLOR_CSC_RED &&\r\ncolor != TPG_COLOR_100_RED &&\r\ncolor != TPG_COLOR_75_RED)\r\nalpha = 0;\r\nif (color == TPG_COLOR_RANDOM)\r\nprecalculate_color(tpg, color);\r\nr_y = tpg->colors[color][0];\r\ng_u = tpg->colors[color][1];\r\nb_v = tpg->colors[color][2];\r\nswitch (tpg->fourcc) {\r\ncase V4L2_PIX_FMT_GREY:\r\nbuf[0][offset] = r_y;\r\nbreak;\r\ncase V4L2_PIX_FMT_Y16:\r\nbuf[0][offset] = r_y == 0xff ? r_y : 0;\r\nbuf[0][offset+1] = r_y;\r\nbreak;\r\ncase V4L2_PIX_FMT_Y16_BE:\r\nbuf[0][offset] = r_y;\r\nbuf[0][offset+1] = r_y == 0xff ? r_y : 0;\r\nbreak;\r\ncase V4L2_PIX_FMT_YUV422P:\r\ncase V4L2_PIX_FMT_YUV420:\r\ncase V4L2_PIX_FMT_YUV420M:\r\nbuf[0][offset] = r_y;\r\nif (odd) {\r\nbuf[1][0] = (buf[1][0] + g_u) / 2;\r\nbuf[2][0] = (buf[2][0] + b_v) / 2;\r\nbuf[1][1] = buf[1][0];\r\nbuf[2][1] = buf[2][0];\r\nbreak;\r\n}\r\nbuf[1][0] = g_u;\r\nbuf[2][0] = b_v;\r\nbreak;\r\ncase V4L2_PIX_FMT_YVU420:\r\ncase V4L2_PIX_FMT_YVU420M:\r\nbuf[0][offset] = r_y;\r\nif (odd) {\r\nbuf[1][0] = (buf[1][0] + b_v) / 2;\r\nbuf[2][0] = (buf[2][0] + g_u) / 2;\r\nbuf[1][1] = buf[1][0];\r\nbuf[2][1] = buf[2][0];\r\nbreak;\r\n}\r\nbuf[1][0] = b_v;\r\nbuf[2][0] = g_u;\r\nbreak;\r\ncase V4L2_PIX_FMT_NV12:\r\ncase V4L2_PIX_FMT_NV12M:\r\ncase V4L2_PIX_FMT_NV16:\r\ncase V4L2_PIX_FMT_NV16M:\r\nbuf[0][offset] = r_y;\r\nif (odd) {\r\nbuf[1][0] = (buf[1][0] + g_u) / 2;\r\nbuf[1][1] = (buf[1][1] + b_v) / 2;\r\nbreak;\r\n}\r\nbuf[1][0] = g_u;\r\nbuf[1][1] = b_v;\r\nbreak;\r\ncase V4L2_PIX_FMT_NV21:\r\ncase V4L2_PIX_FMT_NV21M:\r\ncase V4L2_PIX_FMT_NV61:\r\ncase V4L2_PIX_FMT_NV61M:\r\nbuf[0][offset] = r_y;\r\nif (odd) {\r\nbuf[1][0] = (buf[1][0] + b_v) / 2;\r\nbuf[1][1] = (buf[1][1] + g_u) / 2;\r\nbreak;\r\n}\r\nbuf[1][0] = b_v;\r\nbuf[1][1] = g_u;\r\nbreak;\r\ncase V4L2_PIX_FMT_NV24:\r\nbuf[0][offset] = r_y;\r\nbuf[1][2 * offset] = g_u;\r\nbuf[1][2 * offset + 1] = b_v;\r\nbreak;\r\ncase V4L2_PIX_FMT_NV42:\r\nbuf[0][offset] = r_y;\r\nbuf[1][2 * offset] = b_v;\r\nbuf[1][2 * offset + 1] = g_u;\r\nbreak;\r\ncase V4L2_PIX_FMT_YUYV:\r\nbuf[0][offset] = r_y;\r\nif (odd) {\r\nbuf[0][1] = (buf[0][1] + g_u) / 2;\r\nbuf[0][3] = (buf[0][3] + b_v) / 2;\r\nbreak;\r\n}\r\nbuf[0][1] = g_u;\r\nbuf[0][3] = b_v;\r\nbreak;\r\ncase V4L2_PIX_FMT_UYVY:\r\nbuf[0][offset + 1] = r_y;\r\nif (odd) {\r\nbuf[0][0] = (buf[0][0] + g_u) / 2;\r\nbuf[0][2] = (buf[0][2] + b_v) / 2;\r\nbreak;\r\n}\r\nbuf[0][0] = g_u;\r\nbuf[0][2] = b_v;\r\nbreak;\r\ncase V4L2_PIX_FMT_YVYU:\r\nbuf[0][offset] = r_y;\r\nif (odd) {\r\nbuf[0][1] = (buf[0][1] + b_v) / 2;\r\nbuf[0][3] = (buf[0][3] + g_u) / 2;\r\nbreak;\r\n}\r\nbuf[0][1] = b_v;\r\nbuf[0][3] = g_u;\r\nbreak;\r\ncase V4L2_PIX_FMT_VYUY:\r\nbuf[0][offset + 1] = r_y;\r\nif (odd) {\r\nbuf[0][0] = (buf[0][0] + b_v) / 2;\r\nbuf[0][2] = (buf[0][2] + g_u) / 2;\r\nbreak;\r\n}\r\nbuf[0][0] = b_v;\r\nbuf[0][2] = g_u;\r\nbreak;\r\ncase V4L2_PIX_FMT_RGB332:\r\nbuf[0][offset] = (r_y << 5) | (g_u << 2) | b_v;\r\nbreak;\r\ncase V4L2_PIX_FMT_YUV565:\r\ncase V4L2_PIX_FMT_RGB565:\r\nbuf[0][offset] = (g_u << 5) | b_v;\r\nbuf[0][offset + 1] = (r_y << 3) | (g_u >> 3);\r\nbreak;\r\ncase V4L2_PIX_FMT_RGB565X:\r\nbuf[0][offset] = (r_y << 3) | (g_u >> 3);\r\nbuf[0][offset + 1] = (g_u << 5) | b_v;\r\nbreak;\r\ncase V4L2_PIX_FMT_RGB444:\r\ncase V4L2_PIX_FMT_XRGB444:\r\nalpha = 0;\r\ncase V4L2_PIX_FMT_YUV444:\r\ncase V4L2_PIX_FMT_ARGB444:\r\nbuf[0][offset] = (g_u << 4) | b_v;\r\nbuf[0][offset + 1] = (alpha & 0xf0) | r_y;\r\nbreak;\r\ncase V4L2_PIX_FMT_RGB555:\r\ncase V4L2_PIX_FMT_XRGB555:\r\nalpha = 0;\r\ncase V4L2_PIX_FMT_YUV555:\r\ncase V4L2_PIX_FMT_ARGB555:\r\nbuf[0][offset] = (g_u << 5) | b_v;\r\nbuf[0][offset + 1] = (alpha & 0x80) | (r_y << 2) | (g_u >> 3);\r\nbreak;\r\ncase V4L2_PIX_FMT_RGB555X:\r\ncase V4L2_PIX_FMT_XRGB555X:\r\nalpha = 0;\r\ncase V4L2_PIX_FMT_ARGB555X:\r\nbuf[0][offset] = (alpha & 0x80) | (r_y << 2) | (g_u >> 3);\r\nbuf[0][offset + 1] = (g_u << 5) | b_v;\r\nbreak;\r\ncase V4L2_PIX_FMT_RGB24:\r\nbuf[0][offset] = r_y;\r\nbuf[0][offset + 1] = g_u;\r\nbuf[0][offset + 2] = b_v;\r\nbreak;\r\ncase V4L2_PIX_FMT_BGR24:\r\nbuf[0][offset] = b_v;\r\nbuf[0][offset + 1] = g_u;\r\nbuf[0][offset + 2] = r_y;\r\nbreak;\r\ncase V4L2_PIX_FMT_BGR666:\r\nbuf[0][offset] = (b_v << 2) | (g_u >> 4);\r\nbuf[0][offset + 1] = (g_u << 4) | (r_y >> 2);\r\nbuf[0][offset + 2] = r_y << 6;\r\nbuf[0][offset + 3] = 0;\r\nbreak;\r\ncase V4L2_PIX_FMT_RGB32:\r\ncase V4L2_PIX_FMT_XRGB32:\r\nalpha = 0;\r\ncase V4L2_PIX_FMT_YUV32:\r\ncase V4L2_PIX_FMT_ARGB32:\r\nbuf[0][offset] = alpha;\r\nbuf[0][offset + 1] = r_y;\r\nbuf[0][offset + 2] = g_u;\r\nbuf[0][offset + 3] = b_v;\r\nbreak;\r\ncase V4L2_PIX_FMT_BGR32:\r\ncase V4L2_PIX_FMT_XBGR32:\r\nalpha = 0;\r\ncase V4L2_PIX_FMT_ABGR32:\r\nbuf[0][offset] = b_v;\r\nbuf[0][offset + 1] = g_u;\r\nbuf[0][offset + 2] = r_y;\r\nbuf[0][offset + 3] = alpha;\r\nbreak;\r\ncase V4L2_PIX_FMT_SBGGR8:\r\nbuf[0][offset] = odd ? g_u : b_v;\r\nbuf[1][offset] = odd ? r_y : g_u;\r\nbreak;\r\ncase V4L2_PIX_FMT_SGBRG8:\r\nbuf[0][offset] = odd ? b_v : g_u;\r\nbuf[1][offset] = odd ? g_u : r_y;\r\nbreak;\r\ncase V4L2_PIX_FMT_SGRBG8:\r\nbuf[0][offset] = odd ? r_y : g_u;\r\nbuf[1][offset] = odd ? g_u : b_v;\r\nbreak;\r\ncase V4L2_PIX_FMT_SRGGB8:\r\nbuf[0][offset] = odd ? g_u : r_y;\r\nbuf[1][offset] = odd ? b_v : g_u;\r\nbreak;\r\ncase V4L2_PIX_FMT_SBGGR10:\r\nbuf[0][offset] = odd ? g_u << 2 : b_v << 2;\r\nbuf[0][offset + 1] = odd ? g_u >> 6 : b_v >> 6;\r\nbuf[1][offset] = odd ? r_y << 2 : g_u << 2;\r\nbuf[1][offset + 1] = odd ? r_y >> 6 : g_u >> 6;\r\nbuf[0][offset] |= (buf[0][offset] >> 2) & 3;\r\nbuf[1][offset] |= (buf[1][offset] >> 2) & 3;\r\nbreak;\r\ncase V4L2_PIX_FMT_SGBRG10:\r\nbuf[0][offset] = odd ? b_v << 2 : g_u << 2;\r\nbuf[0][offset + 1] = odd ? b_v >> 6 : g_u >> 6;\r\nbuf[1][offset] = odd ? g_u << 2 : r_y << 2;\r\nbuf[1][offset + 1] = odd ? g_u >> 6 : r_y >> 6;\r\nbuf[0][offset] |= (buf[0][offset] >> 2) & 3;\r\nbuf[1][offset] |= (buf[1][offset] >> 2) & 3;\r\nbreak;\r\ncase V4L2_PIX_FMT_SGRBG10:\r\nbuf[0][offset] = odd ? r_y << 2 : g_u << 2;\r\nbuf[0][offset + 1] = odd ? r_y >> 6 : g_u >> 6;\r\nbuf[1][offset] = odd ? g_u << 2 : b_v << 2;\r\nbuf[1][offset + 1] = odd ? g_u >> 6 : b_v >> 6;\r\nbuf[0][offset] |= (buf[0][offset] >> 2) & 3;\r\nbuf[1][offset] |= (buf[1][offset] >> 2) & 3;\r\nbreak;\r\ncase V4L2_PIX_FMT_SRGGB10:\r\nbuf[0][offset] = odd ? g_u << 2 : r_y << 2;\r\nbuf[0][offset + 1] = odd ? g_u >> 6 : r_y >> 6;\r\nbuf[1][offset] = odd ? b_v << 2 : g_u << 2;\r\nbuf[1][offset + 1] = odd ? b_v >> 6 : g_u >> 6;\r\nbuf[0][offset] |= (buf[0][offset] >> 2) & 3;\r\nbuf[1][offset] |= (buf[1][offset] >> 2) & 3;\r\nbreak;\r\ncase V4L2_PIX_FMT_SBGGR12:\r\nbuf[0][offset] = odd ? g_u << 4 : b_v << 4;\r\nbuf[0][offset + 1] = odd ? g_u >> 4 : b_v >> 4;\r\nbuf[1][offset] = odd ? r_y << 4 : g_u << 4;\r\nbuf[1][offset + 1] = odd ? r_y >> 4 : g_u >> 4;\r\nbuf[0][offset] |= (buf[0][offset] >> 4) & 0xf;\r\nbuf[1][offset] |= (buf[1][offset] >> 4) & 0xf;\r\nbreak;\r\ncase V4L2_PIX_FMT_SGBRG12:\r\nbuf[0][offset] = odd ? b_v << 4 : g_u << 4;\r\nbuf[0][offset + 1] = odd ? b_v >> 4 : g_u >> 4;\r\nbuf[1][offset] = odd ? g_u << 4 : r_y << 4;\r\nbuf[1][offset + 1] = odd ? g_u >> 4 : r_y >> 4;\r\nbuf[0][offset] |= (buf[0][offset] >> 4) & 0xf;\r\nbuf[1][offset] |= (buf[1][offset] >> 4) & 0xf;\r\nbreak;\r\ncase V4L2_PIX_FMT_SGRBG12:\r\nbuf[0][offset] = odd ? r_y << 4 : g_u << 4;\r\nbuf[0][offset + 1] = odd ? r_y >> 4 : g_u >> 4;\r\nbuf[1][offset] = odd ? g_u << 4 : b_v << 4;\r\nbuf[1][offset + 1] = odd ? g_u >> 4 : b_v >> 4;\r\nbuf[0][offset] |= (buf[0][offset] >> 4) & 0xf;\r\nbuf[1][offset] |= (buf[1][offset] >> 4) & 0xf;\r\nbreak;\r\ncase V4L2_PIX_FMT_SRGGB12:\r\nbuf[0][offset] = odd ? g_u << 4 : r_y << 4;\r\nbuf[0][offset + 1] = odd ? g_u >> 4 : r_y >> 4;\r\nbuf[1][offset] = odd ? b_v << 4 : g_u << 4;\r\nbuf[1][offset + 1] = odd ? b_v >> 4 : g_u >> 4;\r\nbuf[0][offset] |= (buf[0][offset] >> 4) & 0xf;\r\nbuf[1][offset] |= (buf[1][offset] >> 4) & 0xf;\r\nbreak;\r\n}\r\n}\r\nunsigned tpg_g_interleaved_plane(const struct tpg_data *tpg, unsigned buf_line)\r\n{\r\nswitch (tpg->fourcc) {\r\ncase V4L2_PIX_FMT_SBGGR8:\r\ncase V4L2_PIX_FMT_SGBRG8:\r\ncase V4L2_PIX_FMT_SGRBG8:\r\ncase V4L2_PIX_FMT_SRGGB8:\r\ncase V4L2_PIX_FMT_SBGGR10:\r\ncase V4L2_PIX_FMT_SGBRG10:\r\ncase V4L2_PIX_FMT_SGRBG10:\r\ncase V4L2_PIX_FMT_SRGGB10:\r\ncase V4L2_PIX_FMT_SBGGR12:\r\ncase V4L2_PIX_FMT_SGBRG12:\r\ncase V4L2_PIX_FMT_SGRBG12:\r\ncase V4L2_PIX_FMT_SRGGB12:\r\nreturn buf_line & 1;\r\ndefault:\r\nreturn 0;\r\n}\r\n}\r\nstatic unsigned tpg_get_pat_lines(const struct tpg_data *tpg)\r\n{\r\nswitch (tpg->pattern) {\r\ncase TPG_PAT_CHECKERS_16X16:\r\ncase TPG_PAT_CHECKERS_2X2:\r\ncase TPG_PAT_CHECKERS_1X1:\r\ncase TPG_PAT_COLOR_CHECKERS_2X2:\r\ncase TPG_PAT_COLOR_CHECKERS_1X1:\r\ncase TPG_PAT_ALTERNATING_HLINES:\r\ncase TPG_PAT_CROSS_1_PIXEL:\r\ncase TPG_PAT_CROSS_2_PIXELS:\r\ncase TPG_PAT_CROSS_10_PIXELS:\r\nreturn 2;\r\ncase TPG_PAT_100_COLORSQUARES:\r\ncase TPG_PAT_100_HCOLORBAR:\r\nreturn 8;\r\ndefault:\r\nreturn 1;\r\n}\r\n}\r\nstatic unsigned tpg_get_pat_line(const struct tpg_data *tpg, unsigned line)\r\n{\r\nswitch (tpg->pattern) {\r\ncase TPG_PAT_CHECKERS_16X16:\r\nreturn (line >> 4) & 1;\r\ncase TPG_PAT_CHECKERS_1X1:\r\ncase TPG_PAT_COLOR_CHECKERS_1X1:\r\ncase TPG_PAT_ALTERNATING_HLINES:\r\nreturn line & 1;\r\ncase TPG_PAT_CHECKERS_2X2:\r\ncase TPG_PAT_COLOR_CHECKERS_2X2:\r\nreturn (line & 2) >> 1;\r\ncase TPG_PAT_100_COLORSQUARES:\r\ncase TPG_PAT_100_HCOLORBAR:\r\nreturn (line * 8) / tpg->src_height;\r\ncase TPG_PAT_CROSS_1_PIXEL:\r\nreturn line == tpg->src_height / 2;\r\ncase TPG_PAT_CROSS_2_PIXELS:\r\nreturn (line + 1) / 2 == tpg->src_height / 4;\r\ncase TPG_PAT_CROSS_10_PIXELS:\r\nreturn (line + 10) / 20 == tpg->src_height / 40;\r\ndefault:\r\nreturn 0;\r\n}\r\n}\r\nstatic enum tpg_color tpg_get_color(const struct tpg_data *tpg,\r\nunsigned pat_line, unsigned x)\r\n{\r\nstatic const enum tpg_color bars[3][8] = {\r\n{ TPG_COLOR_CSC_WHITE, TPG_COLOR_75_YELLOW,\r\nTPG_COLOR_75_CYAN, TPG_COLOR_75_GREEN,\r\nTPG_COLOR_75_MAGENTA, TPG_COLOR_75_RED,\r\nTPG_COLOR_75_BLUE, TPG_COLOR_100_BLACK, },\r\n{ TPG_COLOR_100_WHITE, TPG_COLOR_100_YELLOW,\r\nTPG_COLOR_100_CYAN, TPG_COLOR_100_GREEN,\r\nTPG_COLOR_100_MAGENTA, TPG_COLOR_100_RED,\r\nTPG_COLOR_100_BLUE, TPG_COLOR_100_BLACK, },\r\n{ TPG_COLOR_CSC_WHITE, TPG_COLOR_CSC_YELLOW,\r\nTPG_COLOR_CSC_CYAN, TPG_COLOR_CSC_GREEN,\r\nTPG_COLOR_CSC_MAGENTA, TPG_COLOR_CSC_RED,\r\nTPG_COLOR_CSC_BLUE, TPG_COLOR_CSC_BLACK, },\r\n};\r\nswitch (tpg->pattern) {\r\ncase TPG_PAT_75_COLORBAR:\r\ncase TPG_PAT_100_COLORBAR:\r\ncase TPG_PAT_CSC_COLORBAR:\r\nreturn bars[tpg->pattern][((x * 8) / tpg->src_width) % 8];\r\ncase TPG_PAT_100_COLORSQUARES:\r\nreturn bars[1][(pat_line + (x * 8) / tpg->src_width) % 8];\r\ncase TPG_PAT_100_HCOLORBAR:\r\nreturn bars[1][pat_line];\r\ncase TPG_PAT_BLACK:\r\nreturn TPG_COLOR_100_BLACK;\r\ncase TPG_PAT_WHITE:\r\nreturn TPG_COLOR_100_WHITE;\r\ncase TPG_PAT_RED:\r\nreturn TPG_COLOR_100_RED;\r\ncase TPG_PAT_GREEN:\r\nreturn TPG_COLOR_100_GREEN;\r\ncase TPG_PAT_BLUE:\r\nreturn TPG_COLOR_100_BLUE;\r\ncase TPG_PAT_CHECKERS_16X16:\r\nreturn (((x >> 4) & 1) ^ (pat_line & 1)) ?\r\nTPG_COLOR_100_BLACK : TPG_COLOR_100_WHITE;\r\ncase TPG_PAT_CHECKERS_1X1:\r\nreturn ((x & 1) ^ (pat_line & 1)) ?\r\nTPG_COLOR_100_WHITE : TPG_COLOR_100_BLACK;\r\ncase TPG_PAT_COLOR_CHECKERS_1X1:\r\nreturn ((x & 1) ^ (pat_line & 1)) ?\r\nTPG_COLOR_100_RED : TPG_COLOR_100_BLUE;\r\ncase TPG_PAT_CHECKERS_2X2:\r\nreturn (((x >> 1) & 1) ^ (pat_line & 1)) ?\r\nTPG_COLOR_100_WHITE : TPG_COLOR_100_BLACK;\r\ncase TPG_PAT_COLOR_CHECKERS_2X2:\r\nreturn (((x >> 1) & 1) ^ (pat_line & 1)) ?\r\nTPG_COLOR_100_RED : TPG_COLOR_100_BLUE;\r\ncase TPG_PAT_ALTERNATING_HLINES:\r\nreturn pat_line ? TPG_COLOR_100_WHITE : TPG_COLOR_100_BLACK;\r\ncase TPG_PAT_ALTERNATING_VLINES:\r\nreturn (x & 1) ? TPG_COLOR_100_WHITE : TPG_COLOR_100_BLACK;\r\ncase TPG_PAT_CROSS_1_PIXEL:\r\nif (pat_line || (x % tpg->src_width) == tpg->src_width / 2)\r\nreturn TPG_COLOR_100_BLACK;\r\nreturn TPG_COLOR_100_WHITE;\r\ncase TPG_PAT_CROSS_2_PIXELS:\r\nif (pat_line || ((x % tpg->src_width) + 1) / 2 == tpg->src_width / 4)\r\nreturn TPG_COLOR_100_BLACK;\r\nreturn TPG_COLOR_100_WHITE;\r\ncase TPG_PAT_CROSS_10_PIXELS:\r\nif (pat_line || ((x % tpg->src_width) + 10) / 20 == tpg->src_width / 40)\r\nreturn TPG_COLOR_100_BLACK;\r\nreturn TPG_COLOR_100_WHITE;\r\ncase TPG_PAT_GRAY_RAMP:\r\nreturn TPG_COLOR_RAMP + ((x % tpg->src_width) * 256) / tpg->src_width;\r\ndefault:\r\nreturn TPG_COLOR_100_RED;\r\n}\r\n}\r\nstatic void tpg_calculate_square_border(struct tpg_data *tpg)\r\n{\r\nunsigned w = tpg->src_width;\r\nunsigned h = tpg->src_height;\r\nunsigned sq_w, sq_h;\r\nsq_w = (w * 2 / 5) & ~1;\r\nif (((w - sq_w) / 2) & 1)\r\nsq_w += 2;\r\nsq_h = sq_w;\r\ntpg->square.width = sq_w;\r\nif (tpg->vid_aspect == TPG_VIDEO_ASPECT_16X9_ANAMORPHIC) {\r\nunsigned ana_sq_w = (sq_w / 4) * 3;\r\nif (((w - ana_sq_w) / 2) & 1)\r\nana_sq_w += 2;\r\ntpg->square.width = ana_sq_w;\r\n}\r\ntpg->square.left = (w - tpg->square.width) / 2;\r\nif (tpg->pix_aspect == TPG_PIXEL_ASPECT_NTSC)\r\nsq_h = sq_w * 10 / 11;\r\nelse if (tpg->pix_aspect == TPG_PIXEL_ASPECT_PAL)\r\nsq_h = sq_w * 59 / 54;\r\ntpg->square.height = sq_h;\r\ntpg->square.top = (h - sq_h) / 2;\r\ntpg->border.left = 0;\r\ntpg->border.width = w;\r\ntpg->border.top = 0;\r\ntpg->border.height = h;\r\nswitch (tpg->vid_aspect) {\r\ncase TPG_VIDEO_ASPECT_4X3:\r\nif (tpg->pix_aspect)\r\nreturn;\r\nif (3 * w >= 4 * h) {\r\ntpg->border.width = ((4 * h) / 3) & ~1;\r\nif (((w - tpg->border.width) / 2) & ~1)\r\ntpg->border.width -= 2;\r\ntpg->border.left = (w - tpg->border.width) / 2;\r\nbreak;\r\n}\r\ntpg->border.height = ((3 * w) / 4) & ~1;\r\ntpg->border.top = (h - tpg->border.height) / 2;\r\nbreak;\r\ncase TPG_VIDEO_ASPECT_14X9_CENTRE:\r\nif (tpg->pix_aspect) {\r\ntpg->border.height = tpg->pix_aspect == TPG_PIXEL_ASPECT_NTSC ? 420 : 506;\r\ntpg->border.top = (h - tpg->border.height) / 2;\r\nbreak;\r\n}\r\nif (9 * w >= 14 * h) {\r\ntpg->border.width = ((14 * h) / 9) & ~1;\r\nif (((w - tpg->border.width) / 2) & ~1)\r\ntpg->border.width -= 2;\r\ntpg->border.left = (w - tpg->border.width) / 2;\r\nbreak;\r\n}\r\ntpg->border.height = ((9 * w) / 14) & ~1;\r\ntpg->border.top = (h - tpg->border.height) / 2;\r\nbreak;\r\ncase TPG_VIDEO_ASPECT_16X9_CENTRE:\r\nif (tpg->pix_aspect) {\r\ntpg->border.height = tpg->pix_aspect == TPG_PIXEL_ASPECT_NTSC ? 368 : 442;\r\ntpg->border.top = (h - tpg->border.height) / 2;\r\nbreak;\r\n}\r\nif (9 * w >= 16 * h) {\r\ntpg->border.width = ((16 * h) / 9) & ~1;\r\nif (((w - tpg->border.width) / 2) & ~1)\r\ntpg->border.width -= 2;\r\ntpg->border.left = (w - tpg->border.width) / 2;\r\nbreak;\r\n}\r\ntpg->border.height = ((9 * w) / 16) & ~1;\r\ntpg->border.top = (h - tpg->border.height) / 2;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nstatic void tpg_precalculate_line(struct tpg_data *tpg)\r\n{\r\nenum tpg_color contrast;\r\nu8 pix[TPG_MAX_PLANES][8];\r\nunsigned pat;\r\nunsigned p;\r\nunsigned x;\r\nswitch (tpg->pattern) {\r\ncase TPG_PAT_GREEN:\r\ncontrast = TPG_COLOR_100_RED;\r\nbreak;\r\ncase TPG_PAT_CSC_COLORBAR:\r\ncontrast = TPG_COLOR_CSC_GREEN;\r\nbreak;\r\ndefault:\r\ncontrast = TPG_COLOR_100_GREEN;\r\nbreak;\r\n}\r\nfor (pat = 0; pat < tpg_get_pat_lines(tpg); pat++) {\r\nunsigned int_part = tpg->src_width / tpg->scaled_width;\r\nunsigned fract_part = tpg->src_width % tpg->scaled_width;\r\nunsigned src_x = 0;\r\nunsigned error = 0;\r\nfor (x = 0; x < tpg->scaled_width * 2; x += 2) {\r\nunsigned real_x = src_x;\r\nenum tpg_color color1, color2;\r\nreal_x = tpg->hflip ? tpg->src_width * 2 - real_x - 2 : real_x;\r\ncolor1 = tpg_get_color(tpg, pat, real_x);\r\nsrc_x += int_part;\r\nerror += fract_part;\r\nif (error >= tpg->scaled_width) {\r\nerror -= tpg->scaled_width;\r\nsrc_x++;\r\n}\r\nreal_x = src_x;\r\nreal_x = tpg->hflip ? tpg->src_width * 2 - real_x - 2 : real_x;\r\ncolor2 = tpg_get_color(tpg, pat, real_x);\r\nsrc_x += int_part;\r\nerror += fract_part;\r\nif (error >= tpg->scaled_width) {\r\nerror -= tpg->scaled_width;\r\nsrc_x++;\r\n}\r\ngen_twopix(tpg, pix, tpg->hflip ? color2 : color1, 0);\r\ngen_twopix(tpg, pix, tpg->hflip ? color1 : color2, 1);\r\nfor (p = 0; p < tpg->planes; p++) {\r\nunsigned twopixsize = tpg->twopixelsize[p];\r\nunsigned hdiv = tpg->hdownsampling[p];\r\nu8 *pos = tpg->lines[pat][p] + tpg_hdiv(tpg, p, x);\r\nmemcpy(pos, pix[p], twopixsize / hdiv);\r\n}\r\n}\r\n}\r\nif (tpg->vdownsampling[tpg->planes - 1] > 1) {\r\nunsigned pat_lines = tpg_get_pat_lines(tpg);\r\nfor (pat = 0; pat < pat_lines; pat++) {\r\nunsigned next_pat = (pat + 1) % pat_lines;\r\nfor (p = 1; p < tpg->planes; p++) {\r\nunsigned w = tpg_hdiv(tpg, p, tpg->scaled_width * 2);\r\nu8 *pos1 = tpg->lines[pat][p];\r\nu8 *pos2 = tpg->lines[next_pat][p];\r\nu8 *dest = tpg->downsampled_lines[pat][p];\r\nfor (x = 0; x < w; x++, pos1++, pos2++, dest++)\r\n*dest = ((u16)*pos1 + (u16)*pos2) / 2;\r\n}\r\n}\r\n}\r\ngen_twopix(tpg, pix, contrast, 0);\r\ngen_twopix(tpg, pix, contrast, 1);\r\nfor (p = 0; p < tpg->planes; p++) {\r\nunsigned twopixsize = tpg->twopixelsize[p];\r\nu8 *pos = tpg->contrast_line[p];\r\nfor (x = 0; x < tpg->scaled_width; x += 2, pos += twopixsize)\r\nmemcpy(pos, pix[p], twopixsize);\r\n}\r\ngen_twopix(tpg, pix, TPG_COLOR_100_BLACK, 0);\r\ngen_twopix(tpg, pix, TPG_COLOR_100_BLACK, 1);\r\nfor (p = 0; p < tpg->planes; p++) {\r\nunsigned twopixsize = tpg->twopixelsize[p];\r\nu8 *pos = tpg->black_line[p];\r\nfor (x = 0; x < tpg->scaled_width; x += 2, pos += twopixsize)\r\nmemcpy(pos, pix[p], twopixsize);\r\n}\r\nfor (x = 0; x < tpg->scaled_width * 2; x += 2) {\r\ngen_twopix(tpg, pix, TPG_COLOR_RANDOM, 0);\r\ngen_twopix(tpg, pix, TPG_COLOR_RANDOM, 1);\r\nfor (p = 0; p < tpg->planes; p++) {\r\nunsigned twopixsize = tpg->twopixelsize[p];\r\nu8 *pos = tpg->random_line[p] + x * twopixsize / 2;\r\nmemcpy(pos, pix[p], twopixsize);\r\n}\r\n}\r\ngen_twopix(tpg, tpg->textbg, TPG_COLOR_TEXTBG, 0);\r\ngen_twopix(tpg, tpg->textbg, TPG_COLOR_TEXTBG, 1);\r\ngen_twopix(tpg, tpg->textfg, TPG_COLOR_TEXTFG, 0);\r\ngen_twopix(tpg, tpg->textfg, TPG_COLOR_TEXTFG, 1);\r\n}\r\nstatic noinline void tpg_print_str_2(const struct tpg_data *tpg, u8 *basep[TPG_MAX_PLANES][2],\r\nunsigned p, unsigned first, unsigned div, unsigned step,\r\nint y, int x, char *text, unsigned len)\r\n{\r\nPRINTSTR(u8);\r\n}\r\nstatic noinline void tpg_print_str_4(const struct tpg_data *tpg, u8 *basep[TPG_MAX_PLANES][2],\r\nunsigned p, unsigned first, unsigned div, unsigned step,\r\nint y, int x, char *text, unsigned len)\r\n{\r\nPRINTSTR(u16);\r\n}\r\nstatic noinline void tpg_print_str_6(const struct tpg_data *tpg, u8 *basep[TPG_MAX_PLANES][2],\r\nunsigned p, unsigned first, unsigned div, unsigned step,\r\nint y, int x, char *text, unsigned len)\r\n{\r\nPRINTSTR(x24);\r\n}\r\nstatic noinline void tpg_print_str_8(const struct tpg_data *tpg, u8 *basep[TPG_MAX_PLANES][2],\r\nunsigned p, unsigned first, unsigned div, unsigned step,\r\nint y, int x, char *text, unsigned len)\r\n{\r\nPRINTSTR(u32);\r\n}\r\nvoid tpg_gen_text(const struct tpg_data *tpg, u8 *basep[TPG_MAX_PLANES][2],\r\nint y, int x, char *text)\r\n{\r\nunsigned step = V4L2_FIELD_HAS_T_OR_B(tpg->field) ? 2 : 1;\r\nunsigned div = step;\r\nunsigned first = 0;\r\nunsigned len = strlen(text);\r\nunsigned p;\r\nif (font8x16 == NULL || basep == NULL)\r\nreturn;\r\nif (y + 16 >= tpg->compose.height || x + 8 >= tpg->compose.width)\r\nreturn;\r\nif (len > (tpg->compose.width - x) / 8)\r\nlen = (tpg->compose.width - x) / 8;\r\nif (tpg->vflip)\r\ny = tpg->compose.height - y - 16;\r\nif (tpg->hflip)\r\nx = tpg->compose.width - x - 8;\r\ny += tpg->compose.top;\r\nx += tpg->compose.left;\r\nif (tpg->field == V4L2_FIELD_BOTTOM)\r\nfirst = 1;\r\nelse if (tpg->field == V4L2_FIELD_SEQ_TB || tpg->field == V4L2_FIELD_SEQ_BT)\r\ndiv = 2;\r\nfor (p = 0; p < tpg->planes; p++) {\r\nswitch (tpg->twopixelsize[p]) {\r\ncase 2:\r\ntpg_print_str_2(tpg, basep, p, first, div, step, y, x,\r\ntext, len);\r\nbreak;\r\ncase 4:\r\ntpg_print_str_4(tpg, basep, p, first, div, step, y, x,\r\ntext, len);\r\nbreak;\r\ncase 6:\r\ntpg_print_str_6(tpg, basep, p, first, div, step, y, x,\r\ntext, len);\r\nbreak;\r\ncase 8:\r\ntpg_print_str_8(tpg, basep, p, first, div, step, y, x,\r\ntext, len);\r\nbreak;\r\n}\r\n}\r\n}\r\nvoid tpg_update_mv_step(struct tpg_data *tpg)\r\n{\r\nint factor = tpg->mv_hor_mode > TPG_MOVE_NONE ? -1 : 1;\r\nif (tpg->hflip)\r\nfactor = -factor;\r\nswitch (tpg->mv_hor_mode) {\r\ncase TPG_MOVE_NEG_FAST:\r\ncase TPG_MOVE_POS_FAST:\r\ntpg->mv_hor_step = ((tpg->src_width + 319) / 320) * 4;\r\nbreak;\r\ncase TPG_MOVE_NEG:\r\ncase TPG_MOVE_POS:\r\ntpg->mv_hor_step = ((tpg->src_width + 639) / 640) * 4;\r\nbreak;\r\ncase TPG_MOVE_NEG_SLOW:\r\ncase TPG_MOVE_POS_SLOW:\r\ntpg->mv_hor_step = 2;\r\nbreak;\r\ncase TPG_MOVE_NONE:\r\ntpg->mv_hor_step = 0;\r\nbreak;\r\n}\r\nif (factor < 0)\r\ntpg->mv_hor_step = tpg->src_width - tpg->mv_hor_step;\r\nfactor = tpg->mv_vert_mode > TPG_MOVE_NONE ? -1 : 1;\r\nswitch (tpg->mv_vert_mode) {\r\ncase TPG_MOVE_NEG_FAST:\r\ncase TPG_MOVE_POS_FAST:\r\ntpg->mv_vert_step = ((tpg->src_width + 319) / 320) * 4;\r\nbreak;\r\ncase TPG_MOVE_NEG:\r\ncase TPG_MOVE_POS:\r\ntpg->mv_vert_step = ((tpg->src_width + 639) / 640) * 4;\r\nbreak;\r\ncase TPG_MOVE_NEG_SLOW:\r\ncase TPG_MOVE_POS_SLOW:\r\ntpg->mv_vert_step = 1;\r\nbreak;\r\ncase TPG_MOVE_NONE:\r\ntpg->mv_vert_step = 0;\r\nbreak;\r\n}\r\nif (factor < 0)\r\ntpg->mv_vert_step = tpg->src_height - tpg->mv_vert_step;\r\n}\r\nstatic unsigned tpg_calc_frameline(const struct tpg_data *tpg, unsigned src_y,\r\nunsigned field)\r\n{\r\nswitch (field) {\r\ncase V4L2_FIELD_TOP:\r\nreturn tpg->crop.top + src_y * 2;\r\ncase V4L2_FIELD_BOTTOM:\r\nreturn tpg->crop.top + src_y * 2 + 1;\r\ndefault:\r\nreturn src_y + tpg->crop.top;\r\n}\r\n}\r\nstatic unsigned tpg_calc_buffer_line(const struct tpg_data *tpg, unsigned y,\r\nunsigned field)\r\n{\r\ny += tpg->compose.top;\r\nswitch (field) {\r\ncase V4L2_FIELD_SEQ_TB:\r\nif (y & 1)\r\nreturn tpg->buf_height / 2 + y / 2;\r\nreturn y / 2;\r\ncase V4L2_FIELD_SEQ_BT:\r\nif (y & 1)\r\nreturn y / 2;\r\nreturn tpg->buf_height / 2 + y / 2;\r\ndefault:\r\nreturn y;\r\n}\r\n}\r\nstatic void tpg_recalc(struct tpg_data *tpg)\r\n{\r\nif (tpg->recalc_colors) {\r\ntpg->recalc_colors = false;\r\ntpg->recalc_lines = true;\r\ntpg->real_xfer_func = tpg->xfer_func;\r\ntpg->real_ycbcr_enc = tpg->ycbcr_enc;\r\ntpg->real_quantization = tpg->quantization;\r\nif (tpg->xfer_func == V4L2_XFER_FUNC_DEFAULT)\r\ntpg->real_xfer_func =\r\nV4L2_MAP_XFER_FUNC_DEFAULT(tpg->colorspace);\r\nif (tpg->ycbcr_enc == V4L2_YCBCR_ENC_DEFAULT)\r\ntpg->real_ycbcr_enc =\r\nV4L2_MAP_YCBCR_ENC_DEFAULT(tpg->colorspace);\r\nif (tpg->quantization == V4L2_QUANTIZATION_DEFAULT)\r\ntpg->real_quantization =\r\nV4L2_MAP_QUANTIZATION_DEFAULT(!tpg->is_yuv,\r\ntpg->colorspace, tpg->real_ycbcr_enc);\r\ntpg_precalculate_colors(tpg);\r\n}\r\nif (tpg->recalc_square_border) {\r\ntpg->recalc_square_border = false;\r\ntpg_calculate_square_border(tpg);\r\n}\r\nif (tpg->recalc_lines) {\r\ntpg->recalc_lines = false;\r\ntpg_precalculate_line(tpg);\r\n}\r\n}\r\nvoid tpg_calc_text_basep(struct tpg_data *tpg,\r\nu8 *basep[TPG_MAX_PLANES][2], unsigned p, u8 *vbuf)\r\n{\r\nunsigned stride = tpg->bytesperline[p];\r\nunsigned h = tpg->buf_height;\r\ntpg_recalc(tpg);\r\nbasep[p][0] = vbuf;\r\nbasep[p][1] = vbuf;\r\nh /= tpg->vdownsampling[p];\r\nif (tpg->field == V4L2_FIELD_SEQ_TB)\r\nbasep[p][1] += h * stride / 2;\r\nelse if (tpg->field == V4L2_FIELD_SEQ_BT)\r\nbasep[p][0] += h * stride / 2;\r\nif (p == 0 && tpg->interleaved)\r\ntpg_calc_text_basep(tpg, basep, 1, vbuf);\r\n}\r\nstatic int tpg_pattern_avg(const struct tpg_data *tpg,\r\nunsigned pat1, unsigned pat2)\r\n{\r\nunsigned pat_lines = tpg_get_pat_lines(tpg);\r\nif (pat1 == (pat2 + 1) % pat_lines)\r\nreturn pat2;\r\nif (pat2 == (pat1 + 1) % pat_lines)\r\nreturn pat1;\r\nreturn -1;\r\n}\r\nvoid tpg_log_status(struct tpg_data *tpg)\r\n{\r\npr_info("tpg source WxH: %ux%u (%s)\n",\r\ntpg->src_width, tpg->src_height,\r\ntpg->is_yuv ? "YCbCr" : "RGB");\r\npr_info("tpg field: %u\n", tpg->field);\r\npr_info("tpg crop: %ux%u@%dx%d\n", tpg->crop.width, tpg->crop.height,\r\ntpg->crop.left, tpg->crop.top);\r\npr_info("tpg compose: %ux%u@%dx%d\n", tpg->compose.width, tpg->compose.height,\r\ntpg->compose.left, tpg->compose.top);\r\npr_info("tpg colorspace: %d\n", tpg->colorspace);\r\npr_info("tpg transfer function: %d/%d\n", tpg->xfer_func, tpg->real_xfer_func);\r\npr_info("tpg Y'CbCr encoding: %d/%d\n", tpg->ycbcr_enc, tpg->real_ycbcr_enc);\r\npr_info("tpg quantization: %d/%d\n", tpg->quantization, tpg->real_quantization);\r\npr_info("tpg RGB range: %d/%d\n", tpg->rgb_range, tpg->real_rgb_range);\r\n}\r\nstatic void tpg_fill_params_pattern(const struct tpg_data *tpg, unsigned p,\r\nstruct tpg_draw_params *params)\r\n{\r\nparams->mv_hor_old =\r\ntpg_hscale_div(tpg, p, tpg->mv_hor_count % tpg->src_width);\r\nparams->mv_hor_new =\r\ntpg_hscale_div(tpg, p, (tpg->mv_hor_count + tpg->mv_hor_step) %\r\ntpg->src_width);\r\nparams->mv_vert_old = tpg->mv_vert_count % tpg->src_height;\r\nparams->mv_vert_new =\r\n(tpg->mv_vert_count + tpg->mv_vert_step) % tpg->src_height;\r\n}\r\nstatic void tpg_fill_params_extras(const struct tpg_data *tpg,\r\nunsigned p,\r\nstruct tpg_draw_params *params)\r\n{\r\nunsigned left_pillar_width = 0;\r\nunsigned right_pillar_start = params->img_width;\r\nparams->wss_width = tpg->crop.left < tpg->src_width / 2 ?\r\ntpg->src_width / 2 - tpg->crop.left : 0;\r\nif (params->wss_width > tpg->crop.width)\r\nparams->wss_width = tpg->crop.width;\r\nparams->wss_width = tpg_hscale_div(tpg, p, params->wss_width);\r\nparams->wss_random_offset =\r\nparams->twopixsize * prandom_u32_max(tpg->src_width / 2);\r\nif (tpg->crop.left < tpg->border.left) {\r\nleft_pillar_width = tpg->border.left - tpg->crop.left;\r\nif (left_pillar_width > tpg->crop.width)\r\nleft_pillar_width = tpg->crop.width;\r\nleft_pillar_width = tpg_hscale_div(tpg, p, left_pillar_width);\r\n}\r\nparams->left_pillar_width = left_pillar_width;\r\nif (tpg->crop.left + tpg->crop.width >\r\ntpg->border.left + tpg->border.width) {\r\nright_pillar_start =\r\ntpg->border.left + tpg->border.width - tpg->crop.left;\r\nright_pillar_start =\r\ntpg_hscale_div(tpg, p, right_pillar_start);\r\nif (right_pillar_start > params->img_width)\r\nright_pillar_start = params->img_width;\r\n}\r\nparams->right_pillar_start = right_pillar_start;\r\nparams->sav_eav_f = tpg->field ==\r\n(params->is_60hz ? V4L2_FIELD_TOP : V4L2_FIELD_BOTTOM);\r\n}\r\nstatic void tpg_fill_plane_extras(const struct tpg_data *tpg,\r\nconst struct tpg_draw_params *params,\r\nunsigned p, unsigned h, u8 *vbuf)\r\n{\r\nunsigned twopixsize = params->twopixsize;\r\nunsigned img_width = params->img_width;\r\nunsigned frame_line = params->frame_line;\r\nconst struct v4l2_rect *sq = &tpg->square;\r\nconst struct v4l2_rect *b = &tpg->border;\r\nconst struct v4l2_rect *c = &tpg->crop;\r\nif (params->is_tv && !params->is_60hz &&\r\nframe_line == 0 && params->wss_width) {\r\nu8 *wss = tpg->random_line[p] + params->wss_random_offset;\r\nmemcpy(vbuf, wss, params->wss_width);\r\n}\r\nif (tpg->show_border && frame_line >= b->top &&\r\nframe_line < b->top + b->height) {\r\nunsigned bottom = b->top + b->height - 1;\r\nunsigned left = params->left_pillar_width;\r\nunsigned right = params->right_pillar_start;\r\nif (frame_line == b->top || frame_line == b->top + 1 ||\r\nframe_line == bottom || frame_line == bottom - 1) {\r\nmemcpy(vbuf + left, tpg->contrast_line[p],\r\nright - left);\r\n} else {\r\nif (b->left >= c->left &&\r\nb->left < c->left + c->width)\r\nmemcpy(vbuf + left,\r\ntpg->contrast_line[p], twopixsize);\r\nif (b->left + b->width > c->left &&\r\nb->left + b->width <= c->left + c->width)\r\nmemcpy(vbuf + right - twopixsize,\r\ntpg->contrast_line[p], twopixsize);\r\n}\r\n}\r\nif (tpg->qual != TPG_QUAL_NOISE && frame_line >= b->top &&\r\nframe_line < b->top + b->height) {\r\nmemcpy(vbuf, tpg->black_line[p], params->left_pillar_width);\r\nmemcpy(vbuf + params->right_pillar_start, tpg->black_line[p],\r\nimg_width - params->right_pillar_start);\r\n}\r\nif (tpg->show_square && frame_line >= sq->top &&\r\nframe_line < sq->top + sq->height &&\r\nsq->left < c->left + c->width &&\r\nsq->left + sq->width >= c->left) {\r\nunsigned left = sq->left;\r\nunsigned width = sq->width;\r\nif (c->left > left) {\r\nwidth -= c->left - left;\r\nleft = c->left;\r\n}\r\nif (c->left + c->width < left + width)\r\nwidth -= left + width - c->left - c->width;\r\nleft -= c->left;\r\nleft = tpg_hscale_div(tpg, p, left);\r\nwidth = tpg_hscale_div(tpg, p, width);\r\nmemcpy(vbuf + left, tpg->contrast_line[p], width);\r\n}\r\nif (tpg->insert_sav) {\r\nunsigned offset = tpg_hdiv(tpg, p, tpg->compose.width / 3);\r\nu8 *p = vbuf + offset;\r\nunsigned vact = 0, hact = 0;\r\np[0] = 0xff;\r\np[1] = 0;\r\np[2] = 0;\r\np[3] = 0x80 | (params->sav_eav_f << 6) |\r\n(vact << 5) | (hact << 4) |\r\n((hact ^ vact) << 3) |\r\n((hact ^ params->sav_eav_f) << 2) |\r\n((params->sav_eav_f ^ vact) << 1) |\r\n(hact ^ vact ^ params->sav_eav_f);\r\n}\r\nif (tpg->insert_eav) {\r\nunsigned offset = tpg_hdiv(tpg, p, tpg->compose.width * 2 / 3);\r\nu8 *p = vbuf + offset;\r\nunsigned vact = 0, hact = 1;\r\np[0] = 0xff;\r\np[1] = 0;\r\np[2] = 0;\r\np[3] = 0x80 | (params->sav_eav_f << 6) |\r\n(vact << 5) | (hact << 4) |\r\n((hact ^ vact) << 3) |\r\n((hact ^ params->sav_eav_f) << 2) |\r\n((params->sav_eav_f ^ vact) << 1) |\r\n(hact ^ vact ^ params->sav_eav_f);\r\n}\r\n}\r\nstatic void tpg_fill_plane_pattern(const struct tpg_data *tpg,\r\nconst struct tpg_draw_params *params,\r\nunsigned p, unsigned h, u8 *vbuf)\r\n{\r\nunsigned twopixsize = params->twopixsize;\r\nunsigned img_width = params->img_width;\r\nunsigned mv_hor_old = params->mv_hor_old;\r\nunsigned mv_hor_new = params->mv_hor_new;\r\nunsigned mv_vert_old = params->mv_vert_old;\r\nunsigned mv_vert_new = params->mv_vert_new;\r\nunsigned frame_line = params->frame_line;\r\nunsigned frame_line_next = params->frame_line_next;\r\nunsigned line_offset = tpg_hscale_div(tpg, p, tpg->crop.left);\r\nbool even;\r\nbool fill_blank = false;\r\nunsigned pat_line_old;\r\nunsigned pat_line_new;\r\nu8 *linestart_older;\r\nu8 *linestart_newer;\r\nu8 *linestart_top;\r\nu8 *linestart_bottom;\r\neven = !(frame_line & 1);\r\nif (h >= params->hmax) {\r\nif (params->hmax == tpg->compose.height)\r\nreturn;\r\nif (!tpg->perc_fill_blank)\r\nreturn;\r\nfill_blank = true;\r\n}\r\nif (tpg->vflip) {\r\nframe_line = tpg->src_height - frame_line - 1;\r\nframe_line_next = tpg->src_height - frame_line_next - 1;\r\n}\r\nif (fill_blank) {\r\nlinestart_older = tpg->contrast_line[p];\r\nlinestart_newer = tpg->contrast_line[p];\r\n} else if (tpg->qual != TPG_QUAL_NOISE &&\r\n(frame_line < tpg->border.top ||\r\nframe_line >= tpg->border.top + tpg->border.height)) {\r\nlinestart_older = tpg->black_line[p];\r\nlinestart_newer = tpg->black_line[p];\r\n} else if (tpg->pattern == TPG_PAT_NOISE || tpg->qual == TPG_QUAL_NOISE) {\r\nlinestart_older = tpg->random_line[p] +\r\ntwopixsize * prandom_u32_max(tpg->src_width / 2);\r\nlinestart_newer = tpg->random_line[p] +\r\ntwopixsize * prandom_u32_max(tpg->src_width / 2);\r\n} else {\r\nunsigned frame_line_old =\r\n(frame_line + mv_vert_old) % tpg->src_height;\r\nunsigned frame_line_new =\r\n(frame_line + mv_vert_new) % tpg->src_height;\r\nunsigned pat_line_next_old;\r\nunsigned pat_line_next_new;\r\npat_line_old = tpg_get_pat_line(tpg, frame_line_old);\r\npat_line_new = tpg_get_pat_line(tpg, frame_line_new);\r\nlinestart_older = tpg->lines[pat_line_old][p] + mv_hor_old;\r\nlinestart_newer = tpg->lines[pat_line_new][p] + mv_hor_new;\r\nif (tpg->vdownsampling[p] > 1 && frame_line != frame_line_next) {\r\nint avg_pat;\r\npat_line_next_old = tpg_get_pat_line(tpg,\r\n(frame_line_next + mv_vert_old) % tpg->src_height);\r\npat_line_next_new = tpg_get_pat_line(tpg,\r\n(frame_line_next + mv_vert_new) % tpg->src_height);\r\nswitch (tpg->field) {\r\ncase V4L2_FIELD_INTERLACED:\r\ncase V4L2_FIELD_INTERLACED_BT:\r\ncase V4L2_FIELD_INTERLACED_TB:\r\navg_pat = tpg_pattern_avg(tpg, pat_line_old, pat_line_new);\r\nif (avg_pat < 0)\r\nbreak;\r\nlinestart_older = tpg->downsampled_lines[avg_pat][p] + mv_hor_old;\r\nlinestart_newer = linestart_older;\r\nbreak;\r\ncase V4L2_FIELD_NONE:\r\ncase V4L2_FIELD_TOP:\r\ncase V4L2_FIELD_BOTTOM:\r\ncase V4L2_FIELD_SEQ_BT:\r\ncase V4L2_FIELD_SEQ_TB:\r\navg_pat = tpg_pattern_avg(tpg, pat_line_old, pat_line_next_old);\r\nif (avg_pat >= 0)\r\nlinestart_older = tpg->downsampled_lines[avg_pat][p] +\r\nmv_hor_old;\r\navg_pat = tpg_pattern_avg(tpg, pat_line_new, pat_line_next_new);\r\nif (avg_pat >= 0)\r\nlinestart_newer = tpg->downsampled_lines[avg_pat][p] +\r\nmv_hor_new;\r\nbreak;\r\n}\r\n}\r\nlinestart_older += line_offset;\r\nlinestart_newer += line_offset;\r\n}\r\nif (tpg->field_alternate) {\r\nlinestart_top = linestart_bottom = linestart_older;\r\n} else if (params->is_60hz) {\r\nlinestart_top = linestart_newer;\r\nlinestart_bottom = linestart_older;\r\n} else {\r\nlinestart_top = linestart_older;\r\nlinestart_bottom = linestart_newer;\r\n}\r\nswitch (tpg->field) {\r\ncase V4L2_FIELD_INTERLACED:\r\ncase V4L2_FIELD_INTERLACED_TB:\r\ncase V4L2_FIELD_SEQ_TB:\r\ncase V4L2_FIELD_SEQ_BT:\r\nif (even)\r\nmemcpy(vbuf, linestart_top, img_width);\r\nelse\r\nmemcpy(vbuf, linestart_bottom, img_width);\r\nbreak;\r\ncase V4L2_FIELD_INTERLACED_BT:\r\nif (even)\r\nmemcpy(vbuf, linestart_bottom, img_width);\r\nelse\r\nmemcpy(vbuf, linestart_top, img_width);\r\nbreak;\r\ncase V4L2_FIELD_TOP:\r\nmemcpy(vbuf, linestart_top, img_width);\r\nbreak;\r\ncase V4L2_FIELD_BOTTOM:\r\nmemcpy(vbuf, linestart_bottom, img_width);\r\nbreak;\r\ncase V4L2_FIELD_NONE:\r\ndefault:\r\nmemcpy(vbuf, linestart_older, img_width);\r\nbreak;\r\n}\r\n}\r\nvoid tpg_fill_plane_buffer(struct tpg_data *tpg, v4l2_std_id std,\r\nunsigned p, u8 *vbuf)\r\n{\r\nstruct tpg_draw_params params;\r\nunsigned factor = V4L2_FIELD_HAS_T_OR_B(tpg->field) ? 2 : 1;\r\nunsigned int_part = (tpg->crop.height / factor) / tpg->compose.height;\r\nunsigned fract_part = (tpg->crop.height / factor) % tpg->compose.height;\r\nunsigned src_y = 0;\r\nunsigned error = 0;\r\nunsigned h;\r\ntpg_recalc(tpg);\r\nparams.is_tv = std;\r\nparams.is_60hz = std & V4L2_STD_525_60;\r\nparams.twopixsize = tpg->twopixelsize[p];\r\nparams.img_width = tpg_hdiv(tpg, p, tpg->compose.width);\r\nparams.stride = tpg->bytesperline[p];\r\nparams.hmax = (tpg->compose.height * tpg->perc_fill) / 100;\r\ntpg_fill_params_pattern(tpg, p, &params);\r\ntpg_fill_params_extras(tpg, p, &params);\r\nvbuf += tpg_hdiv(tpg, p, tpg->compose.left);\r\nfor (h = 0; h < tpg->compose.height; h++) {\r\nunsigned buf_line;\r\nparams.frame_line = tpg_calc_frameline(tpg, src_y, tpg->field);\r\nparams.frame_line_next = params.frame_line;\r\nbuf_line = tpg_calc_buffer_line(tpg, h, tpg->field);\r\nsrc_y += int_part;\r\nerror += fract_part;\r\nif (error >= tpg->compose.height) {\r\nerror -= tpg->compose.height;\r\nsrc_y++;\r\n}\r\nif (tpg_g_interleaved(tpg))\r\np = tpg_g_interleaved_plane(tpg, buf_line);\r\nif (tpg->vdownsampling[p] > 1) {\r\nif (tpg->field == V4L2_FIELD_SEQ_BT ||\r\ntpg->field == V4L2_FIELD_SEQ_TB) {\r\nunsigned next_src_y = src_y;\r\nif ((h & 3) >= 2)\r\ncontinue;\r\nnext_src_y += int_part;\r\nif (error + fract_part >= tpg->compose.height)\r\nnext_src_y++;\r\nparams.frame_line_next =\r\ntpg_calc_frameline(tpg, next_src_y, tpg->field);\r\n} else {\r\nif (h & 1)\r\ncontinue;\r\nparams.frame_line_next =\r\ntpg_calc_frameline(tpg, src_y, tpg->field);\r\n}\r\nbuf_line /= tpg->vdownsampling[p];\r\n}\r\ntpg_fill_plane_pattern(tpg, &params, p, h,\r\nvbuf + buf_line * params.stride);\r\ntpg_fill_plane_extras(tpg, &params, p, h,\r\nvbuf + buf_line * params.stride);\r\n}\r\n}\r\nvoid tpg_fillbuffer(struct tpg_data *tpg, v4l2_std_id std, unsigned p, u8 *vbuf)\r\n{\r\nunsigned offset = 0;\r\nunsigned i;\r\nif (tpg->buffers > 1) {\r\ntpg_fill_plane_buffer(tpg, std, p, vbuf);\r\nreturn;\r\n}\r\nfor (i = 0; i < tpg_g_planes(tpg); i++) {\r\ntpg_fill_plane_buffer(tpg, std, i, vbuf + offset);\r\noffset += tpg_calc_plane_size(tpg, i);\r\n}\r\n}
