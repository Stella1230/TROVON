static int cpg_mstp_clock_endisable(struct clk_hw *hw, bool enable)\r\n{\r\nstruct mstp_clock *clock = to_mstp_clock(hw);\r\nstruct mstp_clock_group *group = clock->group;\r\nu32 bitmask = BIT(clock->bit_index);\r\nunsigned long flags;\r\nunsigned int i;\r\nu32 value;\r\nspin_lock_irqsave(&group->lock, flags);\r\nvalue = clk_readl(group->smstpcr);\r\nif (enable)\r\nvalue &= ~bitmask;\r\nelse\r\nvalue |= bitmask;\r\nclk_writel(value, group->smstpcr);\r\nspin_unlock_irqrestore(&group->lock, flags);\r\nif (!enable || !group->mstpsr)\r\nreturn 0;\r\nfor (i = 1000; i > 0; --i) {\r\nif (!(clk_readl(group->mstpsr) & bitmask))\r\nbreak;\r\ncpu_relax();\r\n}\r\nif (!i) {\r\npr_err("%s: failed to enable %p[%d]\n", __func__,\r\ngroup->smstpcr, clock->bit_index);\r\nreturn -ETIMEDOUT;\r\n}\r\nreturn 0;\r\n}\r\nstatic int cpg_mstp_clock_enable(struct clk_hw *hw)\r\n{\r\nreturn cpg_mstp_clock_endisable(hw, true);\r\n}\r\nstatic void cpg_mstp_clock_disable(struct clk_hw *hw)\r\n{\r\ncpg_mstp_clock_endisable(hw, false);\r\n}\r\nstatic int cpg_mstp_clock_is_enabled(struct clk_hw *hw)\r\n{\r\nstruct mstp_clock *clock = to_mstp_clock(hw);\r\nstruct mstp_clock_group *group = clock->group;\r\nu32 value;\r\nif (group->mstpsr)\r\nvalue = clk_readl(group->mstpsr);\r\nelse\r\nvalue = clk_readl(group->smstpcr);\r\nreturn !(value & BIT(clock->bit_index));\r\n}\r\nstatic struct clk * __init\r\ncpg_mstp_clock_register(const char *name, const char *parent_name,\r\nunsigned int index, struct mstp_clock_group *group)\r\n{\r\nstruct clk_init_data init;\r\nstruct mstp_clock *clock;\r\nstruct clk *clk;\r\nclock = kzalloc(sizeof(*clock), GFP_KERNEL);\r\nif (!clock) {\r\npr_err("%s: failed to allocate MSTP clock.\n", __func__);\r\nreturn ERR_PTR(-ENOMEM);\r\n}\r\ninit.name = name;\r\ninit.ops = &cpg_mstp_clock_ops;\r\ninit.flags = CLK_IS_BASIC | CLK_SET_RATE_PARENT;\r\ninit.parent_names = &parent_name;\r\ninit.num_parents = 1;\r\nclock->bit_index = index;\r\nclock->group = group;\r\nclock->hw.init = &init;\r\nclk = clk_register(NULL, &clock->hw);\r\nif (IS_ERR(clk))\r\nkfree(clock);\r\nreturn clk;\r\n}\r\nstatic void __init cpg_mstp_clocks_init(struct device_node *np)\r\n{\r\nstruct mstp_clock_group *group;\r\nconst char *idxname;\r\nstruct clk **clks;\r\nunsigned int i;\r\ngroup = kzalloc(sizeof(*group), GFP_KERNEL);\r\nclks = kmalloc(MSTP_MAX_CLOCKS * sizeof(*clks), GFP_KERNEL);\r\nif (group == NULL || clks == NULL) {\r\nkfree(group);\r\nkfree(clks);\r\npr_err("%s: failed to allocate group\n", __func__);\r\nreturn;\r\n}\r\nspin_lock_init(&group->lock);\r\ngroup->data.clks = clks;\r\ngroup->smstpcr = of_iomap(np, 0);\r\ngroup->mstpsr = of_iomap(np, 1);\r\nif (group->smstpcr == NULL) {\r\npr_err("%s: failed to remap SMSTPCR\n", __func__);\r\nkfree(group);\r\nkfree(clks);\r\nreturn;\r\n}\r\nfor (i = 0; i < MSTP_MAX_CLOCKS; ++i)\r\nclks[i] = ERR_PTR(-ENOENT);\r\nif (of_find_property(np, "clock-indices", &i))\r\nidxname = "clock-indices";\r\nelse\r\nidxname = "renesas,clock-indices";\r\nfor (i = 0; i < MSTP_MAX_CLOCKS; ++i) {\r\nconst char *parent_name;\r\nconst char *name;\r\nu32 clkidx;\r\nint ret;\r\nret = of_property_read_string_index(np, "clock-output-names",\r\ni, &name);\r\nif (ret < 0 || strlen(name) == 0)\r\ncontinue;\r\nparent_name = of_clk_get_parent_name(np, i);\r\nret = of_property_read_u32_index(np, idxname, i, &clkidx);\r\nif (parent_name == NULL || ret < 0)\r\nbreak;\r\nif (clkidx >= MSTP_MAX_CLOCKS) {\r\npr_err("%s: invalid clock %s %s index %u\n",\r\n__func__, np->name, name, clkidx);\r\ncontinue;\r\n}\r\nclks[clkidx] = cpg_mstp_clock_register(name, parent_name,\r\nclkidx, group);\r\nif (!IS_ERR(clks[clkidx])) {\r\ngroup->data.clk_num = max(group->data.clk_num,\r\nclkidx + 1);\r\nclk_register_clkdev(clks[clkidx], name, NULL);\r\n} else {\r\npr_err("%s: failed to register %s %s clock (%ld)\n",\r\n__func__, np->name, name, PTR_ERR(clks[clkidx]));\r\n}\r\n}\r\nof_clk_add_provider(np, of_clk_src_onecell_get, &group->data);\r\n}\r\nint cpg_mstp_attach_dev(struct generic_pm_domain *domain, struct device *dev)\r\n{\r\nstruct device_node *np = dev->of_node;\r\nstruct of_phandle_args clkspec;\r\nstruct clk *clk;\r\nint i = 0;\r\nint error;\r\nwhile (!of_parse_phandle_with_args(np, "clocks", "#clock-cells", i,\r\n&clkspec)) {\r\nif (of_device_is_compatible(clkspec.np,\r\n"renesas,cpg-mstp-clocks"))\r\ngoto found;\r\nif (!strcmp(clkspec.np->name, "zb_clk"))\r\ngoto found;\r\nof_node_put(clkspec.np);\r\ni++;\r\n}\r\nreturn 0;\r\nfound:\r\nclk = of_clk_get_from_provider(&clkspec);\r\nof_node_put(clkspec.np);\r\nif (IS_ERR(clk))\r\nreturn PTR_ERR(clk);\r\nerror = pm_clk_create(dev);\r\nif (error) {\r\ndev_err(dev, "pm_clk_create failed %d\n", error);\r\ngoto fail_put;\r\n}\r\nerror = pm_clk_add_clk(dev, clk);\r\nif (error) {\r\ndev_err(dev, "pm_clk_add_clk %pC failed %d\n", clk, error);\r\ngoto fail_destroy;\r\n}\r\nreturn 0;\r\nfail_destroy:\r\npm_clk_destroy(dev);\r\nfail_put:\r\nclk_put(clk);\r\nreturn error;\r\n}\r\nvoid cpg_mstp_detach_dev(struct generic_pm_domain *domain, struct device *dev)\r\n{\r\nif (!list_empty(&dev->power.subsys_data->clock_list))\r\npm_clk_destroy(dev);\r\n}\r\nvoid __init cpg_mstp_add_clk_domain(struct device_node *np)\r\n{\r\nstruct generic_pm_domain *pd;\r\nu32 ncells;\r\nif (of_property_read_u32(np, "#power-domain-cells", &ncells)) {\r\npr_warn("%s lacks #power-domain-cells\n", np->full_name);\r\nreturn;\r\n}\r\npd = kzalloc(sizeof(*pd), GFP_KERNEL);\r\nif (!pd)\r\nreturn;\r\npd->name = np->name;\r\npd->flags = GENPD_FLAG_PM_CLK;\r\npm_genpd_init(pd, &simple_qos_governor, false);\r\npd->attach_dev = cpg_mstp_attach_dev;\r\npd->detach_dev = cpg_mstp_detach_dev;\r\nof_genpd_add_provider_simple(np, pd);\r\n}
