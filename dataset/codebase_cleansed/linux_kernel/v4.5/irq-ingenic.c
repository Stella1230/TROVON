static irqreturn_t intc_cascade(int irq, void *data)\r\n{\r\nstruct ingenic_intc_data *intc = irq_get_handler_data(irq);\r\nuint32_t irq_reg;\r\nunsigned i;\r\nfor (i = 0; i < intc->num_chips; i++) {\r\nirq_reg = readl(intc->base + (i * CHIP_SIZE) +\r\nJZ_REG_INTC_PENDING);\r\nif (!irq_reg)\r\ncontinue;\r\ngeneric_handle_irq(__fls(irq_reg) + (i * 32) + JZ4740_IRQ_BASE);\r\n}\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void intc_irq_set_mask(struct irq_chip_generic *gc, uint32_t mask)\r\n{\r\nstruct irq_chip_regs *regs = &gc->chip_types->regs;\r\nwritel(mask, gc->reg_base + regs->enable);\r\nwritel(~mask, gc->reg_base + regs->disable);\r\n}\r\nvoid ingenic_intc_irq_suspend(struct irq_data *data)\r\n{\r\nstruct irq_chip_generic *gc = irq_data_get_irq_chip_data(data);\r\nintc_irq_set_mask(gc, gc->wake_active);\r\n}\r\nvoid ingenic_intc_irq_resume(struct irq_data *data)\r\n{\r\nstruct irq_chip_generic *gc = irq_data_get_irq_chip_data(data);\r\nintc_irq_set_mask(gc, gc->mask_cache);\r\n}\r\nstatic int __init ingenic_intc_of_init(struct device_node *node,\r\nunsigned num_chips)\r\n{\r\nstruct ingenic_intc_data *intc;\r\nstruct irq_chip_generic *gc;\r\nstruct irq_chip_type *ct;\r\nstruct irq_domain *domain;\r\nint parent_irq, err = 0;\r\nunsigned i;\r\nintc = kzalloc(sizeof(*intc), GFP_KERNEL);\r\nif (!intc) {\r\nerr = -ENOMEM;\r\ngoto out_err;\r\n}\r\nparent_irq = irq_of_parse_and_map(node, 0);\r\nif (!parent_irq) {\r\nerr = -EINVAL;\r\ngoto out_free;\r\n}\r\nerr = irq_set_handler_data(parent_irq, intc);\r\nif (err)\r\ngoto out_unmap_irq;\r\nintc->num_chips = num_chips;\r\nintc->base = of_iomap(node, 0);\r\nif (!intc->base) {\r\nerr = -ENODEV;\r\ngoto out_unmap_irq;\r\n}\r\nfor (i = 0; i < num_chips; i++) {\r\nwritel(0xffffffff, intc->base + (i * CHIP_SIZE) +\r\nJZ_REG_INTC_SET_MASK);\r\ngc = irq_alloc_generic_chip("INTC", 1,\r\nJZ4740_IRQ_BASE + (i * 32),\r\nintc->base + (i * CHIP_SIZE),\r\nhandle_level_irq);\r\ngc->wake_enabled = IRQ_MSK(32);\r\nct = gc->chip_types;\r\nct->regs.enable = JZ_REG_INTC_CLEAR_MASK;\r\nct->regs.disable = JZ_REG_INTC_SET_MASK;\r\nct->chip.irq_unmask = irq_gc_unmask_enable_reg;\r\nct->chip.irq_mask = irq_gc_mask_disable_reg;\r\nct->chip.irq_mask_ack = irq_gc_mask_disable_reg;\r\nct->chip.irq_set_wake = irq_gc_set_wake;\r\nct->chip.irq_suspend = ingenic_intc_irq_suspend;\r\nct->chip.irq_resume = ingenic_intc_irq_resume;\r\nirq_setup_generic_chip(gc, IRQ_MSK(32), 0, 0,\r\nIRQ_NOPROBE | IRQ_LEVEL);\r\n}\r\ndomain = irq_domain_add_legacy(node, num_chips * 32, JZ4740_IRQ_BASE, 0,\r\n&irq_domain_simple_ops, NULL);\r\nif (!domain)\r\npr_warn("unable to register IRQ domain\n");\r\nsetup_irq(parent_irq, &intc_cascade_action);\r\nreturn 0;\r\nout_unmap_irq:\r\nirq_dispose_mapping(parent_irq);\r\nout_free:\r\nkfree(intc);\r\nout_err:\r\nreturn err;\r\n}\r\nstatic int __init intc_1chip_of_init(struct device_node *node,\r\nstruct device_node *parent)\r\n{\r\nreturn ingenic_intc_of_init(node, 1);\r\n}\r\nstatic int __init intc_2chip_of_init(struct device_node *node,\r\nstruct device_node *parent)\r\n{\r\nreturn ingenic_intc_of_init(node, 2);\r\n}
