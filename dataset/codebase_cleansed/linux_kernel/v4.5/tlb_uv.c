static int __init\r\nsetup_nobau(char *arg)\r\n{\r\nnobau = 1;\r\nreturn 0;\r\n}\r\nstatic void\r\nset_bau_on(void)\r\n{\r\nint cpu;\r\nstruct bau_control *bcp;\r\nif (nobau_perm) {\r\npr_info("BAU not initialized; cannot be turned on\n");\r\nreturn;\r\n}\r\nnobau = 0;\r\nfor_each_present_cpu(cpu) {\r\nbcp = &per_cpu(bau_control, cpu);\r\nbcp->nobau = 0;\r\n}\r\npr_info("BAU turned on\n");\r\nreturn;\r\n}\r\nstatic void\r\nset_bau_off(void)\r\n{\r\nint cpu;\r\nstruct bau_control *bcp;\r\nnobau = 1;\r\nfor_each_present_cpu(cpu) {\r\nbcp = &per_cpu(bau_control, cpu);\r\nbcp->nobau = 1;\r\n}\r\npr_info("BAU turned off\n");\r\nreturn;\r\n}\r\nstatic int __init uvhub_to_first_node(int uvhub)\r\n{\r\nint node, b;\r\nfor_each_online_node(node) {\r\nb = uv_node_to_blade_id(node);\r\nif (uvhub == b)\r\nreturn node;\r\n}\r\nreturn -1;\r\n}\r\nstatic int __init uvhub_to_first_apicid(int uvhub)\r\n{\r\nint cpu;\r\nfor_each_present_cpu(cpu)\r\nif (uvhub == uv_cpu_to_blade_id(cpu))\r\nreturn per_cpu(x86_cpu_to_apicid, cpu);\r\nreturn -1;\r\n}\r\nstatic void reply_to_message(struct msg_desc *mdp, struct bau_control *bcp,\r\nint do_acknowledge)\r\n{\r\nunsigned long dw;\r\nstruct bau_pq_entry *msg;\r\nmsg = mdp->msg;\r\nif (!msg->canceled && do_acknowledge) {\r\ndw = (msg->swack_vec << UV_SW_ACK_NPENDING) | msg->swack_vec;\r\nwrite_mmr_sw_ack(dw);\r\n}\r\nmsg->replied_to = 1;\r\nmsg->swack_vec = 0;\r\n}\r\nstatic void bau_process_retry_msg(struct msg_desc *mdp,\r\nstruct bau_control *bcp)\r\n{\r\nint i;\r\nint cancel_count = 0;\r\nunsigned long msg_res;\r\nunsigned long mmr = 0;\r\nstruct bau_pq_entry *msg = mdp->msg;\r\nstruct bau_pq_entry *msg2;\r\nstruct ptc_stats *stat = bcp->statp;\r\nstat->d_retries++;\r\nfor (msg2 = msg+1, i = 0; i < DEST_Q_SIZE; msg2++, i++) {\r\nif (msg2 > mdp->queue_last)\r\nmsg2 = mdp->queue_first;\r\nif (msg2 == msg)\r\nbreak;\r\nif ((msg2->replied_to == 0) && (msg2->canceled == 0) &&\r\n(msg2->swack_vec) && ((msg2->swack_vec &\r\nmsg->swack_vec) == 0) &&\r\n(msg2->sending_cpu == msg->sending_cpu) &&\r\n(msg2->msg_type != MSG_NOOP)) {\r\nmmr = read_mmr_sw_ack();\r\nmsg_res = msg2->swack_vec;\r\nif (mmr & (msg_res << UV_SW_ACK_NPENDING)) {\r\nunsigned long mr;\r\nmsg2->canceled = 1;\r\nstat->d_canceled++;\r\ncancel_count++;\r\nmr = (msg_res << UV_SW_ACK_NPENDING) | msg_res;\r\nwrite_mmr_sw_ack(mr);\r\n}\r\n}\r\n}\r\nif (!cancel_count)\r\nstat->d_nocanceled++;\r\n}\r\nstatic void bau_process_message(struct msg_desc *mdp, struct bau_control *bcp,\r\nint do_acknowledge)\r\n{\r\nshort socket_ack_count = 0;\r\nshort *sp;\r\nstruct atomic_short *asp;\r\nstruct ptc_stats *stat = bcp->statp;\r\nstruct bau_pq_entry *msg = mdp->msg;\r\nstruct bau_control *smaster = bcp->socket_master;\r\nif (msg->address == TLB_FLUSH_ALL) {\r\nlocal_flush_tlb();\r\nstat->d_alltlb++;\r\n} else {\r\n__flush_tlb_one(msg->address);\r\nstat->d_onetlb++;\r\n}\r\nstat->d_requestee++;\r\nif (msg->msg_type == MSG_RETRY && bcp == bcp->uvhub_master)\r\nbau_process_retry_msg(mdp, bcp);\r\nsp = &smaster->socket_acknowledge_count[mdp->msg_slot];\r\nasp = (struct atomic_short *)sp;\r\nsocket_ack_count = atom_asr(1, asp);\r\nif (socket_ack_count == bcp->cpus_in_socket) {\r\nint msg_ack_count;\r\n*sp = 0;\r\nasp = (struct atomic_short *)&msg->acknowledge_count;\r\nmsg_ack_count = atom_asr(socket_ack_count, asp);\r\nif (msg_ack_count == bcp->cpus_in_uvhub) {\r\nreply_to_message(mdp, bcp, do_acknowledge);\r\n}\r\n}\r\nreturn;\r\n}\r\nstatic int pnode_to_first_cpu(int pnode, struct bau_control *smaster)\r\n{\r\nint cpu;\r\nstruct hub_and_pnode *hpp;\r\nfor_each_present_cpu(cpu) {\r\nhpp = &smaster->thp[cpu];\r\nif (pnode == hpp->pnode)\r\nreturn cpu;\r\n}\r\nreturn -1;\r\n}\r\nstatic void do_reset(void *ptr)\r\n{\r\nint i;\r\nstruct bau_control *bcp = &per_cpu(bau_control, smp_processor_id());\r\nstruct reset_args *rap = (struct reset_args *)ptr;\r\nstruct bau_pq_entry *msg;\r\nstruct ptc_stats *stat = bcp->statp;\r\nstat->d_resets++;\r\nfor (msg = bcp->queue_first, i = 0; i < DEST_Q_SIZE; msg++, i++) {\r\nunsigned long msg_res;\r\nif ((msg->replied_to == 0) &&\r\n(msg->canceled == 0) &&\r\n(msg->sending_cpu == rap->sender) &&\r\n(msg->swack_vec) &&\r\n(msg->msg_type != MSG_NOOP)) {\r\nunsigned long mmr;\r\nunsigned long mr;\r\nmsg->canceled = 1;\r\nmmr = read_mmr_sw_ack();\r\nmsg_res = msg->swack_vec;\r\nmr = (msg_res << UV_SW_ACK_NPENDING) | msg_res;\r\nif (mmr & msg_res) {\r\nstat->d_rcanceled++;\r\nwrite_mmr_sw_ack(mr);\r\n}\r\n}\r\n}\r\nreturn;\r\n}\r\nstatic void reset_with_ipi(struct pnmask *distribution, struct bau_control *bcp)\r\n{\r\nint pnode;\r\nint apnode;\r\nint maskbits;\r\nint sender = bcp->cpu;\r\ncpumask_t *mask = bcp->uvhub_master->cpumask;\r\nstruct bau_control *smaster = bcp->socket_master;\r\nstruct reset_args reset_args;\r\nreset_args.sender = sender;\r\ncpumask_clear(mask);\r\nmaskbits = sizeof(struct pnmask) * BITSPERBYTE;\r\nfor (pnode = 0; pnode < maskbits; pnode++) {\r\nint cpu;\r\nif (!bau_uvhub_isset(pnode, distribution))\r\ncontinue;\r\napnode = pnode + bcp->partition_base_pnode;\r\ncpu = pnode_to_first_cpu(apnode, smaster);\r\ncpumask_set_cpu(cpu, mask);\r\n}\r\nsmp_call_function_many(mask, do_reset, (void *)&reset_args, 1);\r\nreturn;\r\n}\r\nstatic inline unsigned long long cycles_2_ns(unsigned long long cyc)\r\n{\r\nstruct cyc2ns_data *data = cyc2ns_read_begin();\r\nunsigned long long ns;\r\nns = mul_u64_u32_shr(cyc, data->cyc2ns_mul, data->cyc2ns_shift);\r\ncyc2ns_read_end(data);\r\nreturn ns;\r\n}\r\nstatic inline unsigned long long ns_2_cycles(unsigned long long ns)\r\n{\r\nstruct cyc2ns_data *data = cyc2ns_read_begin();\r\nunsigned long long cyc;\r\ncyc = (ns << data->cyc2ns_shift) / data->cyc2ns_mul;\r\ncyc2ns_read_end(data);\r\nreturn cyc;\r\n}\r\nstatic inline unsigned long cycles_2_us(unsigned long long cyc)\r\n{\r\nreturn cycles_2_ns(cyc) / NSEC_PER_USEC;\r\n}\r\nstatic inline cycles_t sec_2_cycles(unsigned long sec)\r\n{\r\nreturn ns_2_cycles(sec * NSEC_PER_SEC);\r\n}\r\nstatic inline unsigned long long usec_2_cycles(unsigned long usec)\r\n{\r\nreturn ns_2_cycles(usec * NSEC_PER_USEC);\r\n}\r\nstatic inline void quiesce_local_uvhub(struct bau_control *hmaster)\r\n{\r\natom_asr(1, (struct atomic_short *)&hmaster->uvhub_quiesce);\r\n}\r\nstatic inline void end_uvhub_quiesce(struct bau_control *hmaster)\r\n{\r\natom_asr(-1, (struct atomic_short *)&hmaster->uvhub_quiesce);\r\n}\r\nstatic unsigned long uv1_read_status(unsigned long mmr_offset, int right_shift)\r\n{\r\nunsigned long descriptor_status;\r\ndescriptor_status = uv_read_local_mmr(mmr_offset);\r\ndescriptor_status >>= right_shift;\r\ndescriptor_status &= UV_ACT_STATUS_MASK;\r\nreturn descriptor_status;\r\n}\r\nstatic int uv1_wait_completion(struct bau_desc *bau_desc,\r\nunsigned long mmr_offset, int right_shift,\r\nstruct bau_control *bcp, long try)\r\n{\r\nunsigned long descriptor_status;\r\ncycles_t ttm;\r\nstruct ptc_stats *stat = bcp->statp;\r\ndescriptor_status = uv1_read_status(mmr_offset, right_shift);\r\nwhile ((descriptor_status != DS_IDLE)) {\r\nif (descriptor_status == DS_SOURCE_TIMEOUT) {\r\nstat->s_stimeout++;\r\nreturn FLUSH_GIVEUP;\r\n} else if (descriptor_status == DS_DESTINATION_TIMEOUT) {\r\nstat->s_dtimeout++;\r\nttm = get_cycles();\r\nif (cycles_2_us(ttm - bcp->send_message) < timeout_us) {\r\nbcp->conseccompletes = 0;\r\nreturn FLUSH_RETRY_PLUGGED;\r\n}\r\nbcp->conseccompletes = 0;\r\nreturn FLUSH_RETRY_TIMEOUT;\r\n} else {\r\ncpu_relax();\r\n}\r\ndescriptor_status = uv1_read_status(mmr_offset, right_shift);\r\n}\r\nbcp->conseccompletes++;\r\nreturn FLUSH_COMPLETE;\r\n}\r\nstatic unsigned long uv2_3_read_status(unsigned long offset, int rshft, int desc)\r\n{\r\nunsigned long descriptor_status;\r\ndescriptor_status =\r\n((read_lmmr(offset) >> rshft) & UV_ACT_STATUS_MASK) << 1;\r\nreturn descriptor_status;\r\n}\r\nint normal_busy(struct bau_control *bcp)\r\n{\r\nint cpu = bcp->uvhub_cpu;\r\nint mmr_offset;\r\nint right_shift;\r\nmmr_offset = UVH_LB_BAU_SB_ACTIVATION_STATUS_0;\r\nright_shift = cpu * UV_ACT_STATUS_SIZE;\r\nreturn (((((read_lmmr(mmr_offset) >> right_shift) &\r\nUV_ACT_STATUS_MASK)) << 1) == UV2H_DESC_BUSY);\r\n}\r\nint handle_uv2_busy(struct bau_control *bcp)\r\n{\r\nstruct ptc_stats *stat = bcp->statp;\r\nstat->s_uv2_wars++;\r\nbcp->busy = 1;\r\nreturn FLUSH_GIVEUP;\r\n}\r\nstatic int uv2_3_wait_completion(struct bau_desc *bau_desc,\r\nunsigned long mmr_offset, int right_shift,\r\nstruct bau_control *bcp, long try)\r\n{\r\nunsigned long descriptor_stat;\r\ncycles_t ttm;\r\nint desc = bcp->uvhub_cpu;\r\nlong busy_reps = 0;\r\nstruct ptc_stats *stat = bcp->statp;\r\ndescriptor_stat = uv2_3_read_status(mmr_offset, right_shift, desc);\r\nwhile (descriptor_stat != UV2H_DESC_IDLE) {\r\nif ((descriptor_stat == UV2H_DESC_SOURCE_TIMEOUT)) {\r\nstat->s_stimeout++;\r\nreturn FLUSH_GIVEUP;\r\n} else if (descriptor_stat == UV2H_DESC_DEST_TIMEOUT) {\r\nttm = get_cycles();\r\nif (cycles_2_us(ttm - bcp->send_message) < timeout_us) {\r\nbcp->conseccompletes = 0;\r\nstat->s_plugged++;\r\nreturn FLUSH_GIVEUP;\r\n}\r\nstat->s_dtimeout++;\r\nbcp->conseccompletes = 0;\r\nreturn FLUSH_GIVEUP;\r\n} else {\r\nbusy_reps++;\r\nif (busy_reps > 1000000) {\r\nbusy_reps = 0;\r\nttm = get_cycles();\r\nif ((ttm - bcp->send_message) > bcp->timeout_interval)\r\nreturn handle_uv2_busy(bcp);\r\n}\r\ncpu_relax();\r\n}\r\ndescriptor_stat = uv2_3_read_status(mmr_offset, right_shift, desc);\r\n}\r\nbcp->conseccompletes++;\r\nreturn FLUSH_COMPLETE;\r\n}\r\nstatic int wait_completion(struct bau_desc *bau_desc, struct bau_control *bcp, long try)\r\n{\r\nint right_shift;\r\nunsigned long mmr_offset;\r\nint desc = bcp->uvhub_cpu;\r\nif (desc < UV_CPUS_PER_AS) {\r\nmmr_offset = UVH_LB_BAU_SB_ACTIVATION_STATUS_0;\r\nright_shift = desc * UV_ACT_STATUS_SIZE;\r\n} else {\r\nmmr_offset = UVH_LB_BAU_SB_ACTIVATION_STATUS_1;\r\nright_shift = ((desc - UV_CPUS_PER_AS) * UV_ACT_STATUS_SIZE);\r\n}\r\nif (bcp->uvhub_version == 1)\r\nreturn uv1_wait_completion(bau_desc, mmr_offset, right_shift, bcp, try);\r\nelse\r\nreturn uv2_3_wait_completion(bau_desc, mmr_offset, right_shift, bcp, try);\r\n}\r\nstatic void destination_plugged(struct bau_desc *bau_desc,\r\nstruct bau_control *bcp,\r\nstruct bau_control *hmaster, struct ptc_stats *stat)\r\n{\r\nudelay(bcp->plugged_delay);\r\nbcp->plugged_tries++;\r\nif (bcp->plugged_tries >= bcp->plugsb4reset) {\r\nbcp->plugged_tries = 0;\r\nquiesce_local_uvhub(hmaster);\r\nspin_lock(&hmaster->queue_lock);\r\nreset_with_ipi(&bau_desc->distribution, bcp);\r\nspin_unlock(&hmaster->queue_lock);\r\nend_uvhub_quiesce(hmaster);\r\nbcp->ipi_attempts++;\r\nstat->s_resets_plug++;\r\n}\r\n}\r\nstatic void destination_timeout(struct bau_desc *bau_desc,\r\nstruct bau_control *bcp, struct bau_control *hmaster,\r\nstruct ptc_stats *stat)\r\n{\r\nhmaster->max_concurr = 1;\r\nbcp->timeout_tries++;\r\nif (bcp->timeout_tries >= bcp->timeoutsb4reset) {\r\nbcp->timeout_tries = 0;\r\nquiesce_local_uvhub(hmaster);\r\nspin_lock(&hmaster->queue_lock);\r\nreset_with_ipi(&bau_desc->distribution, bcp);\r\nspin_unlock(&hmaster->queue_lock);\r\nend_uvhub_quiesce(hmaster);\r\nbcp->ipi_attempts++;\r\nstat->s_resets_timeout++;\r\n}\r\n}\r\nstatic void disable_for_period(struct bau_control *bcp, struct ptc_stats *stat)\r\n{\r\nint tcpu;\r\nstruct bau_control *tbcp;\r\nstruct bau_control *hmaster;\r\ncycles_t tm1;\r\nhmaster = bcp->uvhub_master;\r\nspin_lock(&hmaster->disable_lock);\r\nif (!bcp->baudisabled) {\r\nstat->s_bau_disabled++;\r\ntm1 = get_cycles();\r\nfor_each_present_cpu(tcpu) {\r\ntbcp = &per_cpu(bau_control, tcpu);\r\nif (tbcp->uvhub_master == hmaster) {\r\ntbcp->baudisabled = 1;\r\ntbcp->set_bau_on_time =\r\ntm1 + bcp->disabled_period;\r\n}\r\n}\r\n}\r\nspin_unlock(&hmaster->disable_lock);\r\n}\r\nstatic void count_max_concurr(int stat, struct bau_control *bcp,\r\nstruct bau_control *hmaster)\r\n{\r\nbcp->plugged_tries = 0;\r\nbcp->timeout_tries = 0;\r\nif (stat != FLUSH_COMPLETE)\r\nreturn;\r\nif (bcp->conseccompletes <= bcp->complete_threshold)\r\nreturn;\r\nif (hmaster->max_concurr >= hmaster->max_concurr_const)\r\nreturn;\r\nhmaster->max_concurr++;\r\n}\r\nstatic void record_send_stats(cycles_t time1, cycles_t time2,\r\nstruct bau_control *bcp, struct ptc_stats *stat,\r\nint completion_status, int try)\r\n{\r\ncycles_t elapsed;\r\nif (time2 > time1) {\r\nelapsed = time2 - time1;\r\nstat->s_time += elapsed;\r\nif ((completion_status == FLUSH_COMPLETE) && (try == 1)) {\r\nbcp->period_requests++;\r\nbcp->period_time += elapsed;\r\nif ((elapsed > congested_cycles) &&\r\n(bcp->period_requests > bcp->cong_reps) &&\r\n((bcp->period_time / bcp->period_requests) >\r\ncongested_cycles)) {\r\nstat->s_congested++;\r\ndisable_for_period(bcp, stat);\r\n}\r\n}\r\n} else\r\nstat->s_requestor--;\r\nif (completion_status == FLUSH_COMPLETE && try > 1)\r\nstat->s_retriesok++;\r\nelse if (completion_status == FLUSH_GIVEUP) {\r\nstat->s_giveup++;\r\nif (get_cycles() > bcp->period_end)\r\nbcp->period_giveups = 0;\r\nbcp->period_giveups++;\r\nif (bcp->period_giveups == 1)\r\nbcp->period_end = get_cycles() + bcp->disabled_period;\r\nif (bcp->period_giveups > bcp->giveup_limit) {\r\ndisable_for_period(bcp, stat);\r\nstat->s_giveuplimit++;\r\n}\r\n}\r\n}\r\nstatic void uv1_throttle(struct bau_control *hmaster, struct ptc_stats *stat)\r\n{\r\nspinlock_t *lock = &hmaster->uvhub_lock;\r\natomic_t *v;\r\nv = &hmaster->active_descriptor_count;\r\nif (!atomic_inc_unless_ge(lock, v, hmaster->max_concurr)) {\r\nstat->s_throttles++;\r\ndo {\r\ncpu_relax();\r\n} while (!atomic_inc_unless_ge(lock, v, hmaster->max_concurr));\r\n}\r\n}\r\nstatic void handle_cmplt(int completion_status, struct bau_desc *bau_desc,\r\nstruct bau_control *bcp, struct bau_control *hmaster,\r\nstruct ptc_stats *stat)\r\n{\r\nif (completion_status == FLUSH_RETRY_PLUGGED)\r\ndestination_plugged(bau_desc, bcp, hmaster, stat);\r\nelse if (completion_status == FLUSH_RETRY_TIMEOUT)\r\ndestination_timeout(bau_desc, bcp, hmaster, stat);\r\n}\r\nint uv_flush_send_and_wait(struct cpumask *flush_mask, struct bau_control *bcp,\r\nstruct bau_desc *bau_desc)\r\n{\r\nint seq_number = 0;\r\nint completion_stat = 0;\r\nint uv1 = 0;\r\nlong try = 0;\r\nunsigned long index;\r\ncycles_t time1;\r\ncycles_t time2;\r\nstruct ptc_stats *stat = bcp->statp;\r\nstruct bau_control *hmaster = bcp->uvhub_master;\r\nstruct uv1_bau_msg_header *uv1_hdr = NULL;\r\nstruct uv2_3_bau_msg_header *uv2_3_hdr = NULL;\r\nif (bcp->uvhub_version == 1) {\r\nuv1 = 1;\r\nuv1_throttle(hmaster, stat);\r\n}\r\nwhile (hmaster->uvhub_quiesce)\r\ncpu_relax();\r\ntime1 = get_cycles();\r\nif (uv1)\r\nuv1_hdr = &bau_desc->header.uv1_hdr;\r\nelse\r\nuv2_3_hdr = &bau_desc->header.uv2_3_hdr;\r\ndo {\r\nif (try == 0) {\r\nif (uv1)\r\nuv1_hdr->msg_type = MSG_REGULAR;\r\nelse\r\nuv2_3_hdr->msg_type = MSG_REGULAR;\r\nseq_number = bcp->message_number++;\r\n} else {\r\nif (uv1)\r\nuv1_hdr->msg_type = MSG_RETRY;\r\nelse\r\nuv2_3_hdr->msg_type = MSG_RETRY;\r\nstat->s_retry_messages++;\r\n}\r\nif (uv1)\r\nuv1_hdr->sequence = seq_number;\r\nelse\r\nuv2_3_hdr->sequence = seq_number;\r\nindex = (1UL << AS_PUSH_SHIFT) | bcp->uvhub_cpu;\r\nbcp->send_message = get_cycles();\r\nwrite_mmr_activation(index);\r\ntry++;\r\ncompletion_stat = wait_completion(bau_desc, bcp, try);\r\nhandle_cmplt(completion_stat, bau_desc, bcp, hmaster, stat);\r\nif (bcp->ipi_attempts >= bcp->ipi_reset_limit) {\r\nbcp->ipi_attempts = 0;\r\nstat->s_overipilimit++;\r\ncompletion_stat = FLUSH_GIVEUP;\r\nbreak;\r\n}\r\ncpu_relax();\r\n} while ((completion_stat == FLUSH_RETRY_PLUGGED) ||\r\n(completion_stat == FLUSH_RETRY_TIMEOUT));\r\ntime2 = get_cycles();\r\ncount_max_concurr(completion_stat, bcp, hmaster);\r\nwhile (hmaster->uvhub_quiesce)\r\ncpu_relax();\r\natomic_dec(&hmaster->active_descriptor_count);\r\nrecord_send_stats(time1, time2, bcp, stat, completion_stat, try);\r\nif (completion_stat == FLUSH_GIVEUP)\r\nreturn 1;\r\nreturn 0;\r\n}\r\nstatic int check_enable(struct bau_control *bcp, struct ptc_stats *stat)\r\n{\r\nint tcpu;\r\nstruct bau_control *tbcp;\r\nstruct bau_control *hmaster;\r\nhmaster = bcp->uvhub_master;\r\nspin_lock(&hmaster->disable_lock);\r\nif (bcp->baudisabled && (get_cycles() >= bcp->set_bau_on_time)) {\r\nstat->s_bau_reenabled++;\r\nfor_each_present_cpu(tcpu) {\r\ntbcp = &per_cpu(bau_control, tcpu);\r\nif (tbcp->uvhub_master == hmaster) {\r\ntbcp->baudisabled = 0;\r\ntbcp->period_requests = 0;\r\ntbcp->period_time = 0;\r\ntbcp->period_giveups = 0;\r\n}\r\n}\r\nspin_unlock(&hmaster->disable_lock);\r\nreturn 0;\r\n}\r\nspin_unlock(&hmaster->disable_lock);\r\nreturn -1;\r\n}\r\nstatic void record_send_statistics(struct ptc_stats *stat, int locals, int hubs,\r\nint remotes, struct bau_desc *bau_desc)\r\n{\r\nstat->s_requestor++;\r\nstat->s_ntargcpu += remotes + locals;\r\nstat->s_ntargremotes += remotes;\r\nstat->s_ntarglocals += locals;\r\nhubs = bau_uvhub_weight(&bau_desc->distribution);\r\nif (locals) {\r\nstat->s_ntarglocaluvhub++;\r\nstat->s_ntargremoteuvhub += (hubs - 1);\r\n} else\r\nstat->s_ntargremoteuvhub += hubs;\r\nstat->s_ntarguvhub += hubs;\r\nif (hubs >= 16)\r\nstat->s_ntarguvhub16++;\r\nelse if (hubs >= 8)\r\nstat->s_ntarguvhub8++;\r\nelse if (hubs >= 4)\r\nstat->s_ntarguvhub4++;\r\nelse if (hubs >= 2)\r\nstat->s_ntarguvhub2++;\r\nelse\r\nstat->s_ntarguvhub1++;\r\n}\r\nstatic int set_distrib_bits(struct cpumask *flush_mask, struct bau_control *bcp,\r\nstruct bau_desc *bau_desc, int *localsp, int *remotesp)\r\n{\r\nint cpu;\r\nint pnode;\r\nint cnt = 0;\r\nstruct hub_and_pnode *hpp;\r\nfor_each_cpu(cpu, flush_mask) {\r\nhpp = &bcp->socket_master->thp[cpu];\r\npnode = hpp->pnode - bcp->partition_base_pnode;\r\nbau_uvhub_set(pnode, &bau_desc->distribution);\r\ncnt++;\r\nif (hpp->uvhub == bcp->uvhub)\r\n(*localsp)++;\r\nelse\r\n(*remotesp)++;\r\n}\r\nif (!cnt)\r\nreturn 1;\r\nreturn 0;\r\n}\r\nconst struct cpumask *uv_flush_tlb_others(const struct cpumask *cpumask,\r\nstruct mm_struct *mm,\r\nunsigned long start,\r\nunsigned long end,\r\nunsigned int cpu)\r\n{\r\nint locals = 0;\r\nint remotes = 0;\r\nint hubs = 0;\r\nstruct bau_desc *bau_desc;\r\nstruct cpumask *flush_mask;\r\nstruct ptc_stats *stat;\r\nstruct bau_control *bcp;\r\nunsigned long descriptor_status;\r\nunsigned long status;\r\nbcp = &per_cpu(bau_control, cpu);\r\nif (bcp->nobau)\r\nreturn cpumask;\r\nstat = bcp->statp;\r\nstat->s_enters++;\r\nif (bcp->busy) {\r\ndescriptor_status =\r\nread_lmmr(UVH_LB_BAU_SB_ACTIVATION_STATUS_0);\r\nstatus = ((descriptor_status >> (bcp->uvhub_cpu *\r\nUV_ACT_STATUS_SIZE)) & UV_ACT_STATUS_MASK) << 1;\r\nif (status == UV2H_DESC_BUSY)\r\nreturn cpumask;\r\nbcp->busy = 0;\r\n}\r\nif (bcp->baudisabled) {\r\nif (check_enable(bcp, stat)) {\r\nstat->s_ipifordisabled++;\r\nreturn cpumask;\r\n}\r\n}\r\nflush_mask = (struct cpumask *)per_cpu(uv_flush_tlb_mask, cpu);\r\ncpumask_andnot(flush_mask, cpumask, cpumask_of(cpu));\r\nif (cpumask_test_cpu(cpu, cpumask))\r\nstat->s_ntargself++;\r\nbau_desc = bcp->descriptor_base;\r\nbau_desc += (ITEMS_PER_DESC * bcp->uvhub_cpu);\r\nbau_uvhubs_clear(&bau_desc->distribution, UV_DISTRIBUTION_SIZE);\r\nif (set_distrib_bits(flush_mask, bcp, bau_desc, &locals, &remotes))\r\nreturn NULL;\r\nrecord_send_statistics(stat, locals, hubs, remotes, bau_desc);\r\nif (!end || (end - start) <= PAGE_SIZE)\r\nbau_desc->payload.address = start;\r\nelse\r\nbau_desc->payload.address = TLB_FLUSH_ALL;\r\nbau_desc->payload.sending_cpu = cpu;\r\nif (!uv_flush_send_and_wait(flush_mask, bcp, bau_desc))\r\nreturn NULL;\r\nelse\r\nreturn cpumask;\r\n}\r\nstruct bau_pq_entry *find_another_by_swack(struct bau_pq_entry *msg,\r\nstruct bau_control *bcp)\r\n{\r\nstruct bau_pq_entry *msg_next = msg + 1;\r\nunsigned char swack_vec = msg->swack_vec;\r\nif (msg_next > bcp->queue_last)\r\nmsg_next = bcp->queue_first;\r\nwhile (msg_next != msg) {\r\nif ((msg_next->canceled == 0) && (msg_next->replied_to == 0) &&\r\n(msg_next->swack_vec == swack_vec))\r\nreturn msg_next;\r\nmsg_next++;\r\nif (msg_next > bcp->queue_last)\r\nmsg_next = bcp->queue_first;\r\n}\r\nreturn NULL;\r\n}\r\nvoid process_uv2_message(struct msg_desc *mdp, struct bau_control *bcp)\r\n{\r\nunsigned long mmr_image;\r\nunsigned char swack_vec;\r\nstruct bau_pq_entry *msg = mdp->msg;\r\nstruct bau_pq_entry *other_msg;\r\nmmr_image = read_mmr_sw_ack();\r\nswack_vec = msg->swack_vec;\r\nif ((swack_vec & mmr_image) == 0) {\r\nother_msg = find_another_by_swack(msg, bcp);\r\nif (other_msg) {\r\nbau_process_message(mdp, bcp, 0);\r\nreturn;\r\n}\r\n}\r\nbau_process_message(mdp, bcp, 1);\r\nreturn;\r\n}\r\nvoid uv_bau_message_interrupt(struct pt_regs *regs)\r\n{\r\nint count = 0;\r\ncycles_t time_start;\r\nstruct bau_pq_entry *msg;\r\nstruct bau_control *bcp;\r\nstruct ptc_stats *stat;\r\nstruct msg_desc msgdesc;\r\nack_APIC_irq();\r\ntime_start = get_cycles();\r\nbcp = &per_cpu(bau_control, smp_processor_id());\r\nstat = bcp->statp;\r\nmsgdesc.queue_first = bcp->queue_first;\r\nmsgdesc.queue_last = bcp->queue_last;\r\nmsg = bcp->bau_msg_head;\r\nwhile (msg->swack_vec) {\r\ncount++;\r\nmsgdesc.msg_slot = msg - msgdesc.queue_first;\r\nmsgdesc.msg = msg;\r\nif (bcp->uvhub_version == 2)\r\nprocess_uv2_message(&msgdesc, bcp);\r\nelse\r\nbau_process_message(&msgdesc, bcp, 1);\r\nmsg++;\r\nif (msg > msgdesc.queue_last)\r\nmsg = msgdesc.queue_first;\r\nbcp->bau_msg_head = msg;\r\n}\r\nstat->d_time += (get_cycles() - time_start);\r\nif (!count)\r\nstat->d_nomsg++;\r\nelse if (count > 1)\r\nstat->d_multmsg++;\r\n}\r\nstatic void __init enable_timeouts(void)\r\n{\r\nint uvhub;\r\nint nuvhubs;\r\nint pnode;\r\nunsigned long mmr_image;\r\nnuvhubs = uv_num_possible_blades();\r\nfor (uvhub = 0; uvhub < nuvhubs; uvhub++) {\r\nif (!uv_blade_nr_possible_cpus(uvhub))\r\ncontinue;\r\npnode = uv_blade_to_pnode(uvhub);\r\nmmr_image = read_mmr_misc_control(pnode);\r\nmmr_image &= ~(1L << SOFTACK_MSHIFT);\r\nwrite_mmr_misc_control(pnode, mmr_image);\r\nmmr_image &= ~((unsigned long)0xf << SOFTACK_PSHIFT);\r\nmmr_image |= (SOFTACK_TIMEOUT_PERIOD << SOFTACK_PSHIFT);\r\nwrite_mmr_misc_control(pnode, mmr_image);\r\nmmr_image |= (1L << SOFTACK_MSHIFT);\r\nif (is_uv2_hub()) {\r\nmmr_image &= ~(1L << UV2_EXT_SHFT);\r\n} else if (is_uv3_hub()) {\r\nmmr_image &= ~(1L << PREFETCH_HINT_SHFT);\r\nmmr_image |= (1L << SB_STATUS_SHFT);\r\n}\r\nwrite_mmr_misc_control(pnode, mmr_image);\r\n}\r\n}\r\nstatic void *ptc_seq_start(struct seq_file *file, loff_t *offset)\r\n{\r\nif (*offset < num_possible_cpus())\r\nreturn offset;\r\nreturn NULL;\r\n}\r\nstatic void *ptc_seq_next(struct seq_file *file, void *data, loff_t *offset)\r\n{\r\n(*offset)++;\r\nif (*offset < num_possible_cpus())\r\nreturn offset;\r\nreturn NULL;\r\n}\r\nstatic void ptc_seq_stop(struct seq_file *file, void *data)\r\n{\r\n}\r\nstatic int ptc_seq_show(struct seq_file *file, void *data)\r\n{\r\nstruct ptc_stats *stat;\r\nstruct bau_control *bcp;\r\nint cpu;\r\ncpu = *(loff_t *)data;\r\nif (!cpu) {\r\nseq_puts(file,\r\n"# cpu bauoff sent stime self locals remotes ncpus localhub ");\r\nseq_puts(file, "remotehub numuvhubs numuvhubs16 numuvhubs8 ");\r\nseq_puts(file,\r\n"numuvhubs4 numuvhubs2 numuvhubs1 dto snacks retries ");\r\nseq_puts(file,\r\n"rok resetp resett giveup sto bz throt disable ");\r\nseq_puts(file,\r\n"enable wars warshw warwaits enters ipidis plugged ");\r\nseq_puts(file,\r\n"ipiover glim cong swack recv rtime all one mult ");\r\nseq_puts(file, "none retry canc nocan reset rcan\n");\r\n}\r\nif (cpu < num_possible_cpus() && cpu_online(cpu)) {\r\nbcp = &per_cpu(bau_control, cpu);\r\nif (bcp->nobau) {\r\nseq_printf(file, "cpu %d bau disabled\n", cpu);\r\nreturn 0;\r\n}\r\nstat = bcp->statp;\r\nseq_printf(file,\r\n"cpu %d %d %ld %ld %ld %ld %ld %ld %ld %ld %ld %ld ",\r\ncpu, bcp->nobau, stat->s_requestor,\r\ncycles_2_us(stat->s_time),\r\nstat->s_ntargself, stat->s_ntarglocals,\r\nstat->s_ntargremotes, stat->s_ntargcpu,\r\nstat->s_ntarglocaluvhub, stat->s_ntargremoteuvhub,\r\nstat->s_ntarguvhub, stat->s_ntarguvhub16);\r\nseq_printf(file, "%ld %ld %ld %ld %ld %ld ",\r\nstat->s_ntarguvhub8, stat->s_ntarguvhub4,\r\nstat->s_ntarguvhub2, stat->s_ntarguvhub1,\r\nstat->s_dtimeout, stat->s_strongnacks);\r\nseq_printf(file, "%ld %ld %ld %ld %ld %ld %ld %ld ",\r\nstat->s_retry_messages, stat->s_retriesok,\r\nstat->s_resets_plug, stat->s_resets_timeout,\r\nstat->s_giveup, stat->s_stimeout,\r\nstat->s_busy, stat->s_throttles);\r\nseq_printf(file, "%ld %ld %ld %ld %ld %ld %ld %ld %ld %ld %ld ",\r\nstat->s_bau_disabled, stat->s_bau_reenabled,\r\nstat->s_uv2_wars, stat->s_uv2_wars_hw,\r\nstat->s_uv2_war_waits, stat->s_enters,\r\nstat->s_ipifordisabled, stat->s_plugged,\r\nstat->s_overipilimit, stat->s_giveuplimit,\r\nstat->s_congested);\r\nseq_printf(file,\r\n"%lx %ld %ld %ld %ld %ld %ld %ld %ld %ld %ld %ld\n",\r\nread_gmmr_sw_ack(uv_cpu_to_pnode(cpu)),\r\nstat->d_requestee, cycles_2_us(stat->d_time),\r\nstat->d_alltlb, stat->d_onetlb, stat->d_multmsg,\r\nstat->d_nomsg, stat->d_retries, stat->d_canceled,\r\nstat->d_nocanceled, stat->d_resets,\r\nstat->d_rcanceled);\r\n}\r\nreturn 0;\r\n}\r\nstatic ssize_t tunables_read(struct file *file, char __user *userbuf,\r\nsize_t count, loff_t *ppos)\r\n{\r\nchar *buf;\r\nint ret;\r\nbuf = kasprintf(GFP_KERNEL, "%s %s %s\n%d %d %d %d %d %d %d %d %d %d\n",\r\n"max_concur plugged_delay plugsb4reset timeoutsb4reset",\r\n"ipi_reset_limit complete_threshold congested_response_us",\r\n"congested_reps disabled_period giveup_limit",\r\nmax_concurr, plugged_delay, plugsb4reset,\r\ntimeoutsb4reset, ipi_reset_limit, complete_threshold,\r\ncongested_respns_us, congested_reps, disabled_period,\r\ngiveup_limit);\r\nif (!buf)\r\nreturn -ENOMEM;\r\nret = simple_read_from_buffer(userbuf, count, ppos, buf, strlen(buf));\r\nkfree(buf);\r\nreturn ret;\r\n}\r\nstatic ssize_t ptc_proc_write(struct file *file, const char __user *user,\r\nsize_t count, loff_t *data)\r\n{\r\nint cpu;\r\nint i;\r\nint elements;\r\nlong input_arg;\r\nchar optstr[64];\r\nstruct ptc_stats *stat;\r\nif (count == 0 || count > sizeof(optstr))\r\nreturn -EINVAL;\r\nif (copy_from_user(optstr, user, count))\r\nreturn -EFAULT;\r\noptstr[count - 1] = '\0';\r\nif (!strcmp(optstr, "on")) {\r\nset_bau_on();\r\nreturn count;\r\n} else if (!strcmp(optstr, "off")) {\r\nset_bau_off();\r\nreturn count;\r\n}\r\nif (kstrtol(optstr, 10, &input_arg) < 0) {\r\nprintk(KERN_DEBUG "%s is invalid\n", optstr);\r\nreturn -EINVAL;\r\n}\r\nif (input_arg == 0) {\r\nelements = ARRAY_SIZE(stat_description);\r\nprintk(KERN_DEBUG "# cpu: cpu number\n");\r\nprintk(KERN_DEBUG "Sender statistics:\n");\r\nfor (i = 0; i < elements; i++)\r\nprintk(KERN_DEBUG "%s\n", stat_description[i]);\r\n} else if (input_arg == -1) {\r\nfor_each_present_cpu(cpu) {\r\nstat = &per_cpu(ptcstats, cpu);\r\nmemset(stat, 0, sizeof(struct ptc_stats));\r\n}\r\n}\r\nreturn count;\r\n}\r\nstatic int local_atoi(const char *name)\r\n{\r\nint val = 0;\r\nfor (;; name++) {\r\nswitch (*name) {\r\ncase '0' ... '9':\r\nval = 10*val+(*name-'0');\r\nbreak;\r\ndefault:\r\nreturn val;\r\n}\r\n}\r\n}\r\nstatic int parse_tunables_write(struct bau_control *bcp, char *instr,\r\nint count)\r\n{\r\nchar *p;\r\nchar *q;\r\nint cnt = 0;\r\nint val;\r\nint e = ARRAY_SIZE(tunables);\r\np = instr + strspn(instr, WHITESPACE);\r\nq = p;\r\nfor (; *p; p = q + strspn(q, WHITESPACE)) {\r\nq = p + strcspn(p, WHITESPACE);\r\ncnt++;\r\nif (q == p)\r\nbreak;\r\n}\r\nif (cnt != e) {\r\nprintk(KERN_INFO "bau tunable error: should be %d values\n", e);\r\nreturn -EINVAL;\r\n}\r\np = instr + strspn(instr, WHITESPACE);\r\nq = p;\r\nfor (cnt = 0; *p; p = q + strspn(q, WHITESPACE), cnt++) {\r\nq = p + strcspn(p, WHITESPACE);\r\nval = local_atoi(p);\r\nswitch (cnt) {\r\ncase 0:\r\nif (val == 0) {\r\nmax_concurr = MAX_BAU_CONCURRENT;\r\nmax_concurr_const = MAX_BAU_CONCURRENT;\r\ncontinue;\r\n}\r\nif (val < 1 || val > bcp->cpus_in_uvhub) {\r\nprintk(KERN_DEBUG\r\n"Error: BAU max concurrent %d is invalid\n",\r\nval);\r\nreturn -EINVAL;\r\n}\r\nmax_concurr = val;\r\nmax_concurr_const = val;\r\ncontinue;\r\ndefault:\r\nif (val == 0)\r\n*tunables[cnt].tunp = tunables[cnt].deflt;\r\nelse\r\n*tunables[cnt].tunp = val;\r\ncontinue;\r\n}\r\nif (q == p)\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic ssize_t tunables_write(struct file *file, const char __user *user,\r\nsize_t count, loff_t *data)\r\n{\r\nint cpu;\r\nint ret;\r\nchar instr[100];\r\nstruct bau_control *bcp;\r\nif (count == 0 || count > sizeof(instr)-1)\r\nreturn -EINVAL;\r\nif (copy_from_user(instr, user, count))\r\nreturn -EFAULT;\r\ninstr[count] = '\0';\r\ncpu = get_cpu();\r\nbcp = &per_cpu(bau_control, cpu);\r\nret = parse_tunables_write(bcp, instr, count);\r\nput_cpu();\r\nif (ret)\r\nreturn ret;\r\nfor_each_present_cpu(cpu) {\r\nbcp = &per_cpu(bau_control, cpu);\r\nbcp->max_concurr = max_concurr;\r\nbcp->max_concurr_const = max_concurr;\r\nbcp->plugged_delay = plugged_delay;\r\nbcp->plugsb4reset = plugsb4reset;\r\nbcp->timeoutsb4reset = timeoutsb4reset;\r\nbcp->ipi_reset_limit = ipi_reset_limit;\r\nbcp->complete_threshold = complete_threshold;\r\nbcp->cong_response_us = congested_respns_us;\r\nbcp->cong_reps = congested_reps;\r\nbcp->disabled_period = sec_2_cycles(disabled_period);\r\nbcp->giveup_limit = giveup_limit;\r\n}\r\nreturn count;\r\n}\r\nstatic int ptc_proc_open(struct inode *inode, struct file *file)\r\n{\r\nreturn seq_open(file, &uv_ptc_seq_ops);\r\n}\r\nstatic int tunables_open(struct inode *inode, struct file *file)\r\n{\r\nreturn 0;\r\n}\r\nstatic int __init uv_ptc_init(void)\r\n{\r\nstruct proc_dir_entry *proc_uv_ptc;\r\nif (!is_uv_system())\r\nreturn 0;\r\nproc_uv_ptc = proc_create(UV_PTC_BASENAME, 0444, NULL,\r\n&proc_uv_ptc_operations);\r\nif (!proc_uv_ptc) {\r\nprintk(KERN_ERR "unable to create %s proc entry\n",\r\nUV_PTC_BASENAME);\r\nreturn -EINVAL;\r\n}\r\ntunables_dir = debugfs_create_dir(UV_BAU_TUNABLES_DIR, NULL);\r\nif (!tunables_dir) {\r\nprintk(KERN_ERR "unable to create debugfs directory %s\n",\r\nUV_BAU_TUNABLES_DIR);\r\nreturn -EINVAL;\r\n}\r\ntunables_file = debugfs_create_file(UV_BAU_TUNABLES_FILE, 0600,\r\ntunables_dir, NULL, &tunables_fops);\r\nif (!tunables_file) {\r\nprintk(KERN_ERR "unable to create debugfs file %s\n",\r\nUV_BAU_TUNABLES_FILE);\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic void activation_descriptor_init(int node, int pnode, int base_pnode)\r\n{\r\nint i;\r\nint cpu;\r\nint uv1 = 0;\r\nunsigned long gpa;\r\nunsigned long m;\r\nunsigned long n;\r\nsize_t dsize;\r\nstruct bau_desc *bau_desc;\r\nstruct bau_desc *bd2;\r\nstruct uv1_bau_msg_header *uv1_hdr;\r\nstruct uv2_3_bau_msg_header *uv2_3_hdr;\r\nstruct bau_control *bcp;\r\ndsize = sizeof(struct bau_desc) * ADP_SZ * ITEMS_PER_DESC;\r\nbau_desc = kmalloc_node(dsize, GFP_KERNEL, node);\r\nBUG_ON(!bau_desc);\r\ngpa = uv_gpa(bau_desc);\r\nn = uv_gpa_to_gnode(gpa);\r\nm = uv_gpa_to_offset(gpa);\r\nif (is_uv1_hub())\r\nuv1 = 1;\r\nwrite_mmr_descriptor_base(pnode, (n << UV_DESC_PSHIFT | m));\r\nfor (i = 0, bd2 = bau_desc; i < (ADP_SZ * ITEMS_PER_DESC); i++, bd2++) {\r\nmemset(bd2, 0, sizeof(struct bau_desc));\r\nif (uv1) {\r\nuv1_hdr = &bd2->header.uv1_hdr;\r\nuv1_hdr->swack_flag = 1;\r\nuv1_hdr->base_dest_nasid =\r\nUV_PNODE_TO_NASID(base_pnode);\r\nuv1_hdr->dest_subnodeid = UV_LB_SUBNODEID;\r\nuv1_hdr->command = UV_NET_ENDPOINT_INTD;\r\nuv1_hdr->int_both = 1;\r\n} else {\r\nuv2_3_hdr = &bd2->header.uv2_3_hdr;\r\nuv2_3_hdr->swack_flag = 1;\r\nuv2_3_hdr->base_dest_nasid =\r\nUV_PNODE_TO_NASID(base_pnode);\r\nuv2_3_hdr->dest_subnodeid = UV_LB_SUBNODEID;\r\nuv2_3_hdr->command = UV_NET_ENDPOINT_INTD;\r\n}\r\n}\r\nfor_each_present_cpu(cpu) {\r\nif (pnode != uv_blade_to_pnode(uv_cpu_to_blade_id(cpu)))\r\ncontinue;\r\nbcp = &per_cpu(bau_control, cpu);\r\nbcp->descriptor_base = bau_desc;\r\n}\r\n}\r\nstatic void pq_init(int node, int pnode)\r\n{\r\nint cpu;\r\nsize_t plsize;\r\nchar *cp;\r\nvoid *vp;\r\nunsigned long pn;\r\nunsigned long first;\r\nunsigned long pn_first;\r\nunsigned long last;\r\nstruct bau_pq_entry *pqp;\r\nstruct bau_control *bcp;\r\nplsize = (DEST_Q_SIZE + 1) * sizeof(struct bau_pq_entry);\r\nvp = kmalloc_node(plsize, GFP_KERNEL, node);\r\npqp = (struct bau_pq_entry *)vp;\r\nBUG_ON(!pqp);\r\ncp = (char *)pqp + 31;\r\npqp = (struct bau_pq_entry *)(((unsigned long)cp >> 5) << 5);\r\nfor_each_present_cpu(cpu) {\r\nif (pnode != uv_cpu_to_pnode(cpu))\r\ncontinue;\r\nbcp = &per_cpu(bau_control, cpu);\r\nbcp->queue_first = pqp;\r\nbcp->bau_msg_head = pqp;\r\nbcp->queue_last = pqp + (DEST_Q_SIZE - 1);\r\n}\r\npn = uv_gpa_to_gnode(uv_gpa(pqp));\r\nfirst = uv_physnodeaddr(pqp);\r\npn_first = ((unsigned long)pn << UV_PAYLOADQ_PNODE_SHIFT) | first;\r\nlast = uv_physnodeaddr(pqp + (DEST_Q_SIZE - 1));\r\nwrite_mmr_payload_first(pnode, pn_first);\r\nwrite_mmr_payload_tail(pnode, first);\r\nwrite_mmr_payload_last(pnode, last);\r\nwrite_gmmr_sw_ack(pnode, 0xffffUL);\r\nmemset(pqp, 0, sizeof(struct bau_pq_entry) * DEST_Q_SIZE);\r\n}\r\nstatic void __init init_uvhub(int uvhub, int vector, int base_pnode)\r\n{\r\nint node;\r\nint pnode;\r\nunsigned long apicid;\r\nnode = uvhub_to_first_node(uvhub);\r\npnode = uv_blade_to_pnode(uvhub);\r\nactivation_descriptor_init(node, pnode, base_pnode);\r\npq_init(node, pnode);\r\napicid = uvhub_to_first_apicid(uvhub) | uv_apicid_hibits;\r\nwrite_mmr_data_config(pnode, ((apicid << 32) | vector));\r\n}\r\nstatic int calculate_destination_timeout(void)\r\n{\r\nunsigned long mmr_image;\r\nint mult1;\r\nint mult2;\r\nint index;\r\nint base;\r\nint ret;\r\nunsigned long ts_ns;\r\nif (is_uv1_hub()) {\r\nmult1 = SOFTACK_TIMEOUT_PERIOD & BAU_MISC_CONTROL_MULT_MASK;\r\nmmr_image = uv_read_local_mmr(UVH_AGING_PRESCALE_SEL);\r\nindex = (mmr_image >> BAU_URGENCY_7_SHIFT) & BAU_URGENCY_7_MASK;\r\nmmr_image = uv_read_local_mmr(UVH_TRANSACTION_TIMEOUT);\r\nmult2 = (mmr_image >> BAU_TRANS_SHIFT) & BAU_TRANS_MASK;\r\nts_ns = timeout_base_ns[index];\r\nts_ns *= (mult1 * mult2);\r\nret = ts_ns / 1000;\r\n} else {\r\nmmr_image = uv_read_local_mmr(UVH_LB_BAU_MISC_CONTROL);\r\nmmr_image = (mmr_image & UV_SA_MASK) >> UV_SA_SHFT;\r\nif (mmr_image & (1L << UV2_ACK_UNITS_SHFT))\r\nbase = 80;\r\nelse\r\nbase = 10;\r\nmult1 = mmr_image & UV2_ACK_MASK;\r\nret = mult1 * base;\r\n}\r\nreturn ret;\r\n}\r\nstatic void __init init_per_cpu_tunables(void)\r\n{\r\nint cpu;\r\nstruct bau_control *bcp;\r\nfor_each_present_cpu(cpu) {\r\nbcp = &per_cpu(bau_control, cpu);\r\nbcp->baudisabled = 0;\r\nif (nobau)\r\nbcp->nobau = 1;\r\nbcp->statp = &per_cpu(ptcstats, cpu);\r\nbcp->timeout_interval = usec_2_cycles(2*timeout_us);\r\nbcp->max_concurr = max_concurr;\r\nbcp->max_concurr_const = max_concurr;\r\nbcp->plugged_delay = plugged_delay;\r\nbcp->plugsb4reset = plugsb4reset;\r\nbcp->timeoutsb4reset = timeoutsb4reset;\r\nbcp->ipi_reset_limit = ipi_reset_limit;\r\nbcp->complete_threshold = complete_threshold;\r\nbcp->cong_response_us = congested_respns_us;\r\nbcp->cong_reps = congested_reps;\r\nbcp->disabled_period = sec_2_cycles(disabled_period);\r\nbcp->giveup_limit = giveup_limit;\r\nspin_lock_init(&bcp->queue_lock);\r\nspin_lock_init(&bcp->uvhub_lock);\r\nspin_lock_init(&bcp->disable_lock);\r\n}\r\n}\r\nstatic int __init get_cpu_topology(int base_pnode,\r\nstruct uvhub_desc *uvhub_descs,\r\nunsigned char *uvhub_mask)\r\n{\r\nint cpu;\r\nint pnode;\r\nint uvhub;\r\nint socket;\r\nstruct bau_control *bcp;\r\nstruct uvhub_desc *bdp;\r\nstruct socket_desc *sdp;\r\nfor_each_present_cpu(cpu) {\r\nbcp = &per_cpu(bau_control, cpu);\r\nmemset(bcp, 0, sizeof(struct bau_control));\r\npnode = uv_cpu_hub_info(cpu)->pnode;\r\nif ((pnode - base_pnode) >= UV_DISTRIBUTION_SIZE) {\r\nprintk(KERN_EMERG\r\n"cpu %d pnode %d-%d beyond %d; BAU disabled\n",\r\ncpu, pnode, base_pnode, UV_DISTRIBUTION_SIZE);\r\nreturn 1;\r\n}\r\nbcp->osnode = cpu_to_node(cpu);\r\nbcp->partition_base_pnode = base_pnode;\r\nuvhub = uv_cpu_hub_info(cpu)->numa_blade_id;\r\n*(uvhub_mask + (uvhub/8)) |= (1 << (uvhub%8));\r\nbdp = &uvhub_descs[uvhub];\r\nbdp->num_cpus++;\r\nbdp->uvhub = uvhub;\r\nbdp->pnode = pnode;\r\nsocket = bcp->osnode & 1;\r\nbdp->socket_mask |= (1 << socket);\r\nsdp = &bdp->socket[socket];\r\nsdp->cpu_number[sdp->num_cpus] = cpu;\r\nsdp->num_cpus++;\r\nif (sdp->num_cpus > MAX_CPUS_PER_SOCKET) {\r\nprintk(KERN_EMERG "%d cpus per socket invalid\n",\r\nsdp->num_cpus);\r\nreturn 1;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic void make_per_cpu_thp(struct bau_control *smaster)\r\n{\r\nint cpu;\r\nsize_t hpsz = sizeof(struct hub_and_pnode) * num_possible_cpus();\r\nsmaster->thp = kmalloc_node(hpsz, GFP_KERNEL, smaster->osnode);\r\nmemset(smaster->thp, 0, hpsz);\r\nfor_each_present_cpu(cpu) {\r\nsmaster->thp[cpu].pnode = uv_cpu_hub_info(cpu)->pnode;\r\nsmaster->thp[cpu].uvhub = uv_cpu_hub_info(cpu)->numa_blade_id;\r\n}\r\n}\r\nstatic void make_per_hub_cpumask(struct bau_control *hmaster)\r\n{\r\nint sz = sizeof(cpumask_t);\r\nhmaster->cpumask = kzalloc_node(sz, GFP_KERNEL, hmaster->osnode);\r\n}\r\nstatic int scan_sock(struct socket_desc *sdp, struct uvhub_desc *bdp,\r\nstruct bau_control **smasterp,\r\nstruct bau_control **hmasterp)\r\n{\r\nint i;\r\nint cpu;\r\nstruct bau_control *bcp;\r\nfor (i = 0; i < sdp->num_cpus; i++) {\r\ncpu = sdp->cpu_number[i];\r\nbcp = &per_cpu(bau_control, cpu);\r\nbcp->cpu = cpu;\r\nif (i == 0) {\r\n*smasterp = bcp;\r\nif (!(*hmasterp))\r\n*hmasterp = bcp;\r\n}\r\nbcp->cpus_in_uvhub = bdp->num_cpus;\r\nbcp->cpus_in_socket = sdp->num_cpus;\r\nbcp->socket_master = *smasterp;\r\nbcp->uvhub = bdp->uvhub;\r\nif (is_uv1_hub())\r\nbcp->uvhub_version = 1;\r\nelse if (is_uv2_hub())\r\nbcp->uvhub_version = 2;\r\nelse if (is_uv3_hub())\r\nbcp->uvhub_version = 3;\r\nelse {\r\nprintk(KERN_EMERG "uvhub version not 1, 2 or 3\n");\r\nreturn 1;\r\n}\r\nbcp->uvhub_master = *hmasterp;\r\nbcp->uvhub_cpu = uv_cpu_hub_info(cpu)->blade_processor_id;\r\nif (bcp->uvhub_cpu >= MAX_CPUS_PER_UVHUB) {\r\nprintk(KERN_EMERG "%d cpus per uvhub invalid\n",\r\nbcp->uvhub_cpu);\r\nreturn 1;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int __init summarize_uvhub_sockets(int nuvhubs,\r\nstruct uvhub_desc *uvhub_descs,\r\nunsigned char *uvhub_mask)\r\n{\r\nint socket;\r\nint uvhub;\r\nunsigned short socket_mask;\r\nfor (uvhub = 0; uvhub < nuvhubs; uvhub++) {\r\nstruct uvhub_desc *bdp;\r\nstruct bau_control *smaster = NULL;\r\nstruct bau_control *hmaster = NULL;\r\nif (!(*(uvhub_mask + (uvhub/8)) & (1 << (uvhub%8))))\r\ncontinue;\r\nbdp = &uvhub_descs[uvhub];\r\nsocket_mask = bdp->socket_mask;\r\nsocket = 0;\r\nwhile (socket_mask) {\r\nstruct socket_desc *sdp;\r\nif ((socket_mask & 1)) {\r\nsdp = &bdp->socket[socket];\r\nif (scan_sock(sdp, bdp, &smaster, &hmaster))\r\nreturn 1;\r\nmake_per_cpu_thp(smaster);\r\n}\r\nsocket++;\r\nsocket_mask = (socket_mask >> 1);\r\n}\r\nmake_per_hub_cpumask(hmaster);\r\n}\r\nreturn 0;\r\n}\r\nstatic int __init init_per_cpu(int nuvhubs, int base_part_pnode)\r\n{\r\nunsigned char *uvhub_mask;\r\nvoid *vp;\r\nstruct uvhub_desc *uvhub_descs;\r\ntimeout_us = calculate_destination_timeout();\r\nvp = kmalloc(nuvhubs * sizeof(struct uvhub_desc), GFP_KERNEL);\r\nuvhub_descs = (struct uvhub_desc *)vp;\r\nmemset(uvhub_descs, 0, nuvhubs * sizeof(struct uvhub_desc));\r\nuvhub_mask = kzalloc((nuvhubs+7)/8, GFP_KERNEL);\r\nif (get_cpu_topology(base_part_pnode, uvhub_descs, uvhub_mask))\r\ngoto fail;\r\nif (summarize_uvhub_sockets(nuvhubs, uvhub_descs, uvhub_mask))\r\ngoto fail;\r\nkfree(uvhub_descs);\r\nkfree(uvhub_mask);\r\ninit_per_cpu_tunables();\r\nreturn 0;\r\nfail:\r\nkfree(uvhub_descs);\r\nkfree(uvhub_mask);\r\nreturn 1;\r\n}\r\nstatic int __init uv_bau_init(void)\r\n{\r\nint uvhub;\r\nint pnode;\r\nint nuvhubs;\r\nint cur_cpu;\r\nint cpus;\r\nint vector;\r\ncpumask_var_t *mask;\r\nif (!is_uv_system())\r\nreturn 0;\r\nfor_each_possible_cpu(cur_cpu) {\r\nmask = &per_cpu(uv_flush_tlb_mask, cur_cpu);\r\nzalloc_cpumask_var_node(mask, GFP_KERNEL, cpu_to_node(cur_cpu));\r\n}\r\nnuvhubs = uv_num_possible_blades();\r\ncongested_cycles = usec_2_cycles(congested_respns_us);\r\nuv_base_pnode = 0x7fffffff;\r\nfor (uvhub = 0; uvhub < nuvhubs; uvhub++) {\r\ncpus = uv_blade_nr_possible_cpus(uvhub);\r\nif (cpus && (uv_blade_to_pnode(uvhub) < uv_base_pnode))\r\nuv_base_pnode = uv_blade_to_pnode(uvhub);\r\n}\r\nenable_timeouts();\r\nif (init_per_cpu(nuvhubs, uv_base_pnode)) {\r\nset_bau_off();\r\nnobau_perm = 1;\r\nreturn 0;\r\n}\r\nvector = UV_BAU_MESSAGE;\r\nfor_each_possible_blade(uvhub) {\r\nif (uv_blade_nr_possible_cpus(uvhub))\r\ninit_uvhub(uvhub, vector, uv_base_pnode);\r\n}\r\nalloc_intr_gate(vector, uv_bau_message_intr1);\r\nfor_each_possible_blade(uvhub) {\r\nif (uv_blade_nr_possible_cpus(uvhub)) {\r\nunsigned long val;\r\nunsigned long mmr;\r\npnode = uv_blade_to_pnode(uvhub);\r\nval = 1L << 63;\r\nwrite_gmmr_activation(pnode, val);\r\nmmr = 1;\r\nif (!is_uv1_hub())\r\nwrite_mmr_data_broadcast(pnode, mmr);\r\n}\r\n}\r\nreturn 0;\r\n}
