static void usb_urb_complete(struct urb *urb)\r\n{\r\nstruct usb_data_stream *stream = urb->context;\r\nint ptype = usb_pipetype(urb->pipe);\r\nint i;\r\nu8 *b;\r\ndev_dbg_ratelimited(&stream->udev->dev,\r\n"%s: %s urb completed status=%d length=%d/%d pack_num=%d errors=%d\n",\r\n__func__, ptype == PIPE_ISOCHRONOUS ? "isoc" : "bulk",\r\nurb->status, urb->actual_length,\r\nurb->transfer_buffer_length,\r\nurb->number_of_packets, urb->error_count);\r\nswitch (urb->status) {\r\ncase 0:\r\ncase -ETIMEDOUT:\r\nbreak;\r\ncase -ECONNRESET:\r\ncase -ENOENT:\r\ncase -ESHUTDOWN:\r\nreturn;\r\ndefault:\r\ndev_dbg_ratelimited(&stream->udev->dev,\r\n"%s: urb completition failed=%d\n",\r\n__func__, urb->status);\r\nbreak;\r\n}\r\nb = (u8 *) urb->transfer_buffer;\r\nswitch (ptype) {\r\ncase PIPE_ISOCHRONOUS:\r\nfor (i = 0; i < urb->number_of_packets; i++) {\r\nif (urb->iso_frame_desc[i].status != 0)\r\ndev_dbg(&stream->udev->dev,\r\n"%s: iso frame descriptor has an error=%d\n",\r\n__func__,\r\nurb->iso_frame_desc[i].status);\r\nelse if (urb->iso_frame_desc[i].actual_length > 0)\r\nstream->complete(stream,\r\nb + urb->iso_frame_desc[i].offset,\r\nurb->iso_frame_desc[i].actual_length);\r\nurb->iso_frame_desc[i].status = 0;\r\nurb->iso_frame_desc[i].actual_length = 0;\r\n}\r\nbreak;\r\ncase PIPE_BULK:\r\nif (urb->actual_length > 0)\r\nstream->complete(stream, b, urb->actual_length);\r\nbreak;\r\ndefault:\r\ndev_err(&stream->udev->dev,\r\n"%s: unknown endpoint type in completition handler\n",\r\nKBUILD_MODNAME);\r\nreturn;\r\n}\r\nusb_submit_urb(urb, GFP_ATOMIC);\r\n}\r\nint usb_urb_killv2(struct usb_data_stream *stream)\r\n{\r\nint i;\r\nfor (i = 0; i < stream->urbs_submitted; i++) {\r\ndev_dbg(&stream->udev->dev, "%s: kill urb=%d\n", __func__, i);\r\nusb_kill_urb(stream->urb_list[i]);\r\n}\r\nstream->urbs_submitted = 0;\r\nreturn 0;\r\n}\r\nint usb_urb_submitv2(struct usb_data_stream *stream,\r\nstruct usb_data_stream_properties *props)\r\n{\r\nint i, ret;\r\nif (props) {\r\nret = usb_urb_reconfig(stream, props);\r\nif (ret < 0)\r\nreturn ret;\r\n}\r\nfor (i = 0; i < stream->urbs_initialized; i++) {\r\ndev_dbg(&stream->udev->dev, "%s: submit urb=%d\n", __func__, i);\r\nret = usb_submit_urb(stream->urb_list[i], GFP_ATOMIC);\r\nif (ret) {\r\ndev_err(&stream->udev->dev,\r\n"%s: could not submit urb no. %d - get them all back\n",\r\nKBUILD_MODNAME, i);\r\nusb_urb_killv2(stream);\r\nreturn ret;\r\n}\r\nstream->urbs_submitted++;\r\n}\r\nreturn 0;\r\n}\r\nstatic int usb_urb_free_urbs(struct usb_data_stream *stream)\r\n{\r\nint i;\r\nusb_urb_killv2(stream);\r\nfor (i = stream->urbs_initialized - 1; i >= 0; i--) {\r\nif (stream->urb_list[i]) {\r\ndev_dbg(&stream->udev->dev, "%s: free urb=%d\n",\r\n__func__, i);\r\nusb_free_urb(stream->urb_list[i]);\r\n}\r\n}\r\nstream->urbs_initialized = 0;\r\nreturn 0;\r\n}\r\nstatic int usb_urb_alloc_bulk_urbs(struct usb_data_stream *stream)\r\n{\r\nint i, j;\r\nfor (i = 0; i < stream->props.count; i++) {\r\ndev_dbg(&stream->udev->dev, "%s: alloc urb=%d\n", __func__, i);\r\nstream->urb_list[i] = usb_alloc_urb(0, GFP_ATOMIC);\r\nif (!stream->urb_list[i]) {\r\ndev_dbg(&stream->udev->dev, "%s: failed\n", __func__);\r\nfor (j = 0; j < i; j++)\r\nusb_free_urb(stream->urb_list[j]);\r\nreturn -ENOMEM;\r\n}\r\nusb_fill_bulk_urb(stream->urb_list[i],\r\nstream->udev,\r\nusb_rcvbulkpipe(stream->udev,\r\nstream->props.endpoint),\r\nstream->buf_list[i],\r\nstream->props.u.bulk.buffersize,\r\nusb_urb_complete, stream);\r\nstream->urb_list[i]->transfer_flags = URB_NO_TRANSFER_DMA_MAP;\r\nstream->urb_list[i]->transfer_dma = stream->dma_addr[i];\r\nstream->urbs_initialized++;\r\n}\r\nreturn 0;\r\n}\r\nstatic int usb_urb_alloc_isoc_urbs(struct usb_data_stream *stream)\r\n{\r\nint i, j;\r\nfor (i = 0; i < stream->props.count; i++) {\r\nstruct urb *urb;\r\nint frame_offset = 0;\r\ndev_dbg(&stream->udev->dev, "%s: alloc urb=%d\n", __func__, i);\r\nstream->urb_list[i] = usb_alloc_urb(\r\nstream->props.u.isoc.framesperurb, GFP_ATOMIC);\r\nif (!stream->urb_list[i]) {\r\ndev_dbg(&stream->udev->dev, "%s: failed\n", __func__);\r\nfor (j = 0; j < i; j++)\r\nusb_free_urb(stream->urb_list[j]);\r\nreturn -ENOMEM;\r\n}\r\nurb = stream->urb_list[i];\r\nurb->dev = stream->udev;\r\nurb->context = stream;\r\nurb->complete = usb_urb_complete;\r\nurb->pipe = usb_rcvisocpipe(stream->udev,\r\nstream->props.endpoint);\r\nurb->transfer_flags = URB_ISO_ASAP | URB_NO_TRANSFER_DMA_MAP;\r\nurb->interval = stream->props.u.isoc.interval;\r\nurb->number_of_packets = stream->props.u.isoc.framesperurb;\r\nurb->transfer_buffer_length = stream->props.u.isoc.framesize *\r\nstream->props.u.isoc.framesperurb;\r\nurb->transfer_buffer = stream->buf_list[i];\r\nurb->transfer_dma = stream->dma_addr[i];\r\nfor (j = 0; j < stream->props.u.isoc.framesperurb; j++) {\r\nurb->iso_frame_desc[j].offset = frame_offset;\r\nurb->iso_frame_desc[j].length =\r\nstream->props.u.isoc.framesize;\r\nframe_offset += stream->props.u.isoc.framesize;\r\n}\r\nstream->urbs_initialized++;\r\n}\r\nreturn 0;\r\n}\r\nstatic int usb_free_stream_buffers(struct usb_data_stream *stream)\r\n{\r\nif (stream->state & USB_STATE_URB_BUF) {\r\nwhile (stream->buf_num) {\r\nstream->buf_num--;\r\ndev_dbg(&stream->udev->dev, "%s: free buf=%d\n",\r\n__func__, stream->buf_num);\r\nusb_free_coherent(stream->udev, stream->buf_size,\r\nstream->buf_list[stream->buf_num],\r\nstream->dma_addr[stream->buf_num]);\r\n}\r\n}\r\nstream->state &= ~USB_STATE_URB_BUF;\r\nreturn 0;\r\n}\r\nstatic int usb_alloc_stream_buffers(struct usb_data_stream *stream, int num,\r\nunsigned long size)\r\n{\r\nstream->buf_num = 0;\r\nstream->buf_size = size;\r\ndev_dbg(&stream->udev->dev,\r\n"%s: all in all I will use %lu bytes for streaming\n",\r\n__func__, num * size);\r\nfor (stream->buf_num = 0; stream->buf_num < num; stream->buf_num++) {\r\nstream->buf_list[stream->buf_num] = usb_alloc_coherent(\r\nstream->udev, size, GFP_ATOMIC,\r\n&stream->dma_addr[stream->buf_num]);\r\nif (!stream->buf_list[stream->buf_num]) {\r\ndev_dbg(&stream->udev->dev, "%s: alloc buf=%d failed\n",\r\n__func__, stream->buf_num);\r\nusb_free_stream_buffers(stream);\r\nreturn -ENOMEM;\r\n}\r\ndev_dbg(&stream->udev->dev, "%s: alloc buf=%d %p (dma %llu)\n",\r\n__func__, stream->buf_num,\r\nstream->buf_list[stream->buf_num],\r\n(long long)stream->dma_addr[stream->buf_num]);\r\nmemset(stream->buf_list[stream->buf_num], 0, size);\r\nstream->state |= USB_STATE_URB_BUF;\r\n}\r\nreturn 0;\r\n}\r\nint usb_urb_reconfig(struct usb_data_stream *stream,\r\nstruct usb_data_stream_properties *props)\r\n{\r\nint buf_size;\r\nif (!props)\r\nreturn 0;\r\nif (props->type == USB_BULK) {\r\nbuf_size = stream->props.u.bulk.buffersize;\r\n} else if (props->type == USB_ISOC) {\r\nbuf_size = props->u.isoc.framesize * props->u.isoc.framesperurb;\r\n} else {\r\ndev_err(&stream->udev->dev, "%s: invalid endpoint type=%d\n",\r\nKBUILD_MODNAME, props->type);\r\nreturn -EINVAL;\r\n}\r\nif (stream->buf_num < props->count || stream->buf_size < buf_size) {\r\ndev_err(&stream->udev->dev,\r\n"%s: cannot reconfigure as allocated buffers are too small\n",\r\nKBUILD_MODNAME);\r\nreturn -EINVAL;\r\n}\r\nif (stream->props.type == props->type &&\r\nstream->props.count == props->count &&\r\nstream->props.endpoint == props->endpoint) {\r\nif (props->type == USB_BULK &&\r\nprops->u.bulk.buffersize ==\r\nstream->props.u.bulk.buffersize)\r\nreturn 0;\r\nelse if (props->type == USB_ISOC &&\r\nprops->u.isoc.framesperurb ==\r\nstream->props.u.isoc.framesperurb &&\r\nprops->u.isoc.framesize ==\r\nstream->props.u.isoc.framesize &&\r\nprops->u.isoc.interval ==\r\nstream->props.u.isoc.interval)\r\nreturn 0;\r\n}\r\ndev_dbg(&stream->udev->dev, "%s: re-alloc urbs\n", __func__);\r\nusb_urb_free_urbs(stream);\r\nmemcpy(&stream->props, props, sizeof(*props));\r\nif (props->type == USB_BULK)\r\nreturn usb_urb_alloc_bulk_urbs(stream);\r\nelse if (props->type == USB_ISOC)\r\nreturn usb_urb_alloc_isoc_urbs(stream);\r\nreturn 0;\r\n}\r\nint usb_urb_initv2(struct usb_data_stream *stream,\r\nconst struct usb_data_stream_properties *props)\r\n{\r\nint ret;\r\nif (!stream || !props)\r\nreturn -EINVAL;\r\nmemcpy(&stream->props, props, sizeof(*props));\r\nif (!stream->complete) {\r\ndev_err(&stream->udev->dev,\r\n"%s: there is no data callback - this doesn't make sense\n",\r\nKBUILD_MODNAME);\r\nreturn -EINVAL;\r\n}\r\nswitch (stream->props.type) {\r\ncase USB_BULK:\r\nret = usb_alloc_stream_buffers(stream, stream->props.count,\r\nstream->props.u.bulk.buffersize);\r\nif (ret < 0)\r\nreturn ret;\r\nreturn usb_urb_alloc_bulk_urbs(stream);\r\ncase USB_ISOC:\r\nret = usb_alloc_stream_buffers(stream, stream->props.count,\r\nstream->props.u.isoc.framesize *\r\nstream->props.u.isoc.framesperurb);\r\nif (ret < 0)\r\nreturn ret;\r\nreturn usb_urb_alloc_isoc_urbs(stream);\r\ndefault:\r\ndev_err(&stream->udev->dev,\r\n"%s: unknown urb-type for data transfer\n",\r\nKBUILD_MODNAME);\r\nreturn -EINVAL;\r\n}\r\n}\r\nint usb_urb_exitv2(struct usb_data_stream *stream)\r\n{\r\nusb_urb_free_urbs(stream);\r\nusb_free_stream_buffers(stream);\r\nreturn 0;\r\n}
