static int ec_get_version(struct cros_ec_dev *ec, char *str, int maxlen)\r\n{\r\nstruct ec_response_get_version *resp;\r\nstatic const char * const current_image_name[] = {\r\n"unknown", "read-only", "read-write", "invalid",\r\n};\r\nstruct cros_ec_command *msg;\r\nint ret;\r\nmsg = kmalloc(sizeof(*msg) + sizeof(*resp), GFP_KERNEL);\r\nif (!msg)\r\nreturn -ENOMEM;\r\nmsg->version = 0;\r\nmsg->command = EC_CMD_GET_VERSION + ec->cmd_offset;\r\nmsg->insize = sizeof(*resp);\r\nmsg->outsize = 0;\r\nret = cros_ec_cmd_xfer(ec->ec_dev, msg);\r\nif (ret < 0)\r\ngoto exit;\r\nif (msg->result != EC_RES_SUCCESS) {\r\nsnprintf(str, maxlen,\r\n"%s\nUnknown EC version: EC returned %d\n",\r\nCROS_EC_DEV_VERSION, msg->result);\r\nret = -EINVAL;\r\ngoto exit;\r\n}\r\nresp = (struct ec_response_get_version *)msg->data;\r\nif (resp->current_image >= ARRAY_SIZE(current_image_name))\r\nresp->current_image = 3;\r\nsnprintf(str, maxlen, "%s\n%s\n%s\n%s\n", CROS_EC_DEV_VERSION,\r\nresp->version_string_ro, resp->version_string_rw,\r\ncurrent_image_name[resp->current_image]);\r\nret = 0;\r\nexit:\r\nkfree(msg);\r\nreturn ret;\r\n}\r\nstatic int ec_device_open(struct inode *inode, struct file *filp)\r\n{\r\nstruct cros_ec_dev *ec = container_of(inode->i_cdev,\r\nstruct cros_ec_dev, cdev);\r\nfilp->private_data = ec;\r\nnonseekable_open(inode, filp);\r\nreturn 0;\r\n}\r\nstatic int ec_device_release(struct inode *inode, struct file *filp)\r\n{\r\nreturn 0;\r\n}\r\nstatic ssize_t ec_device_read(struct file *filp, char __user *buffer,\r\nsize_t length, loff_t *offset)\r\n{\r\nstruct cros_ec_dev *ec = filp->private_data;\r\nchar msg[sizeof(struct ec_response_get_version) +\r\nsizeof(CROS_EC_DEV_VERSION)];\r\nsize_t count;\r\nint ret;\r\nif (*offset != 0)\r\nreturn 0;\r\nret = ec_get_version(ec, msg, sizeof(msg));\r\nif (ret)\r\nreturn ret;\r\ncount = min(length, strlen(msg));\r\nif (copy_to_user(buffer, msg, count))\r\nreturn -EFAULT;\r\n*offset = count;\r\nreturn count;\r\n}\r\nstatic long ec_device_ioctl_xcmd(struct cros_ec_dev *ec, void __user *arg)\r\n{\r\nlong ret;\r\nstruct cros_ec_command u_cmd;\r\nstruct cros_ec_command *s_cmd;\r\nif (copy_from_user(&u_cmd, arg, sizeof(u_cmd)))\r\nreturn -EFAULT;\r\ns_cmd = kmalloc(sizeof(*s_cmd) + max(u_cmd.outsize, u_cmd.insize),\r\nGFP_KERNEL);\r\nif (!s_cmd)\r\nreturn -ENOMEM;\r\nif (copy_from_user(s_cmd, arg, sizeof(*s_cmd) + u_cmd.outsize)) {\r\nret = -EFAULT;\r\ngoto exit;\r\n}\r\ns_cmd->command += ec->cmd_offset;\r\nret = cros_ec_cmd_xfer(ec->ec_dev, s_cmd);\r\nif (ret < 0)\r\ngoto exit;\r\nif (copy_to_user(arg, s_cmd, sizeof(*s_cmd) + u_cmd.insize))\r\nret = -EFAULT;\r\nexit:\r\nkfree(s_cmd);\r\nreturn ret;\r\n}\r\nstatic long ec_device_ioctl_readmem(struct cros_ec_dev *ec, void __user *arg)\r\n{\r\nstruct cros_ec_device *ec_dev = ec->ec_dev;\r\nstruct cros_ec_readmem s_mem = { };\r\nlong num;\r\nif (!ec_dev->cmd_readmem)\r\nreturn -ENOTTY;\r\nif (copy_from_user(&s_mem, arg, sizeof(s_mem)))\r\nreturn -EFAULT;\r\nnum = ec_dev->cmd_readmem(ec_dev, s_mem.offset, s_mem.bytes,\r\ns_mem.buffer);\r\nif (num <= 0)\r\nreturn num;\r\nif (copy_to_user((void __user *)arg, &s_mem, sizeof(s_mem)))\r\nreturn -EFAULT;\r\nreturn 0;\r\n}\r\nstatic long ec_device_ioctl(struct file *filp, unsigned int cmd,\r\nunsigned long arg)\r\n{\r\nstruct cros_ec_dev *ec = filp->private_data;\r\nif (_IOC_TYPE(cmd) != CROS_EC_DEV_IOC)\r\nreturn -ENOTTY;\r\nswitch (cmd) {\r\ncase CROS_EC_DEV_IOCXCMD:\r\nreturn ec_device_ioctl_xcmd(ec, (void __user *)arg);\r\ncase CROS_EC_DEV_IOCRDMEM:\r\nreturn ec_device_ioctl_readmem(ec, (void __user *)arg);\r\n}\r\nreturn -ENOTTY;\r\n}\r\nstatic void __remove(struct device *dev)\r\n{\r\nstruct cros_ec_dev *ec = container_of(dev, struct cros_ec_dev,\r\nclass_dev);\r\nkfree(ec);\r\n}\r\nstatic int ec_device_probe(struct platform_device *pdev)\r\n{\r\nint retval = -ENOMEM;\r\nstruct device *dev = &pdev->dev;\r\nstruct cros_ec_platform *ec_platform = dev_get_platdata(dev);\r\ndev_t devno = MKDEV(ec_major, pdev->id);\r\nstruct cros_ec_dev *ec = kzalloc(sizeof(*ec), GFP_KERNEL);\r\nif (!ec)\r\nreturn retval;\r\ndev_set_drvdata(dev, ec);\r\nec->ec_dev = dev_get_drvdata(dev->parent);\r\nec->dev = dev;\r\nec->cmd_offset = ec_platform->cmd_offset;\r\ndevice_initialize(&ec->class_dev);\r\ncdev_init(&ec->cdev, &fops);\r\nec->cdev.kobj.parent = &ec->class_dev.kobj;\r\nretval = cdev_add(&ec->cdev, devno, 1);\r\nif (retval) {\r\ndev_err(dev, ": failed to add character device\n");\r\ngoto cdev_add_failed;\r\n}\r\nec->class_dev.devt = ec->cdev.dev;\r\nec->class_dev.class = &cros_class;\r\nec->class_dev.parent = dev;\r\nec->class_dev.release = __remove;\r\nretval = dev_set_name(&ec->class_dev, "%s", ec_platform->ec_name);\r\nif (retval) {\r\ndev_err(dev, "dev_set_name failed => %d\n", retval);\r\ngoto set_named_failed;\r\n}\r\nretval = device_add(&ec->class_dev);\r\nif (retval) {\r\ndev_err(dev, "device_register failed => %d\n", retval);\r\ngoto dev_reg_failed;\r\n}\r\nreturn 0;\r\ndev_reg_failed:\r\nset_named_failed:\r\ndev_set_drvdata(dev, NULL);\r\ncdev_del(&ec->cdev);\r\ncdev_add_failed:\r\nkfree(ec);\r\nreturn retval;\r\n}\r\nstatic int ec_device_remove(struct platform_device *pdev)\r\n{\r\nstruct cros_ec_dev *ec = dev_get_drvdata(&pdev->dev);\r\ncdev_del(&ec->cdev);\r\ndevice_unregister(&ec->class_dev);\r\nreturn 0;\r\n}\r\nstatic int __init cros_ec_dev_init(void)\r\n{\r\nint ret;\r\ndev_t dev = 0;\r\nret = class_register(&cros_class);\r\nif (ret) {\r\npr_err(CROS_EC_DEV_NAME ": failed to register device class\n");\r\nreturn ret;\r\n}\r\nret = alloc_chrdev_region(&dev, 0, CROS_MAX_DEV, CROS_EC_DEV_NAME);\r\nif (ret < 0) {\r\npr_err(CROS_EC_DEV_NAME ": alloc_chrdev_region() failed\n");\r\ngoto failed_chrdevreg;\r\n}\r\nec_major = MAJOR(dev);\r\nret = platform_driver_register(&cros_ec_dev_driver);\r\nif (ret < 0) {\r\npr_warn(CROS_EC_DEV_NAME ": can't register driver: %d\n", ret);\r\ngoto failed_devreg;\r\n}\r\nreturn 0;\r\nfailed_devreg:\r\nunregister_chrdev_region(MKDEV(ec_major, 0), CROS_MAX_DEV);\r\nfailed_chrdevreg:\r\nclass_unregister(&cros_class);\r\nreturn ret;\r\n}\r\nstatic void __exit cros_ec_dev_exit(void)\r\n{\r\nplatform_driver_unregister(&cros_ec_dev_driver);\r\nunregister_chrdev(ec_major, CROS_EC_DEV_NAME);\r\nclass_unregister(&cros_class);\r\n}
