static int update_param(struct nx842_crypto_param *p,\r\nunsigned int slen, unsigned int dlen)\r\n{\r\nif (p->iremain < slen)\r\nreturn -EOVERFLOW;\r\nif (p->oremain < dlen)\r\nreturn -ENOSPC;\r\np->in += slen;\r\np->iremain -= slen;\r\np->out += dlen;\r\np->oremain -= dlen;\r\np->ototal += dlen;\r\nreturn 0;\r\n}\r\nint nx842_crypto_init(struct crypto_tfm *tfm, struct nx842_driver *driver)\r\n{\r\nstruct nx842_crypto_ctx *ctx = crypto_tfm_ctx(tfm);\r\nspin_lock_init(&ctx->lock);\r\nctx->driver = driver;\r\nctx->wmem = kmalloc(driver->workmem_size, GFP_KERNEL);\r\nctx->sbounce = (u8 *)__get_free_pages(GFP_KERNEL, BOUNCE_BUFFER_ORDER);\r\nctx->dbounce = (u8 *)__get_free_pages(GFP_KERNEL, BOUNCE_BUFFER_ORDER);\r\nif (!ctx->wmem || !ctx->sbounce || !ctx->dbounce) {\r\nkfree(ctx->wmem);\r\nfree_page((unsigned long)ctx->sbounce);\r\nfree_page((unsigned long)ctx->dbounce);\r\nreturn -ENOMEM;\r\n}\r\nreturn 0;\r\n}\r\nvoid nx842_crypto_exit(struct crypto_tfm *tfm)\r\n{\r\nstruct nx842_crypto_ctx *ctx = crypto_tfm_ctx(tfm);\r\nkfree(ctx->wmem);\r\nfree_page((unsigned long)ctx->sbounce);\r\nfree_page((unsigned long)ctx->dbounce);\r\n}\r\nstatic void check_constraints(struct nx842_constraints *c)\r\n{\r\nif (c->maximum > BOUNCE_BUFFER_SIZE)\r\nc->maximum = BOUNCE_BUFFER_SIZE;\r\n}\r\nstatic int nx842_crypto_add_header(struct nx842_crypto_header *hdr, u8 *buf)\r\n{\r\nint s = NX842_CRYPTO_HEADER_SIZE(hdr->groups);\r\nif (s > be16_to_cpu(hdr->group[0].padding)) {\r\npr_err("Internal error: no space for header\n");\r\nreturn -EINVAL;\r\n}\r\nmemcpy(buf, hdr, s);\r\nprint_hex_dump_debug("header ", DUMP_PREFIX_OFFSET, 16, 1, buf, s, 0);\r\nreturn 0;\r\n}\r\nstatic int compress(struct nx842_crypto_ctx *ctx,\r\nstruct nx842_crypto_param *p,\r\nstruct nx842_crypto_header_group *g,\r\nstruct nx842_constraints *c,\r\nu16 *ignore,\r\nunsigned int hdrsize)\r\n{\r\nunsigned int slen = p->iremain, dlen = p->oremain, tmplen;\r\nunsigned int adj_slen = slen;\r\nu8 *src = p->in, *dst = p->out;\r\nint ret, dskip = 0;\r\nktime_t timeout;\r\nif (p->iremain == 0)\r\nreturn -EOVERFLOW;\r\nif (p->oremain == 0 || hdrsize + c->minimum > dlen)\r\nreturn -ENOSPC;\r\nif (slen % c->multiple)\r\nadj_slen = round_up(slen, c->multiple);\r\nif (slen < c->minimum)\r\nadj_slen = c->minimum;\r\nif (slen > c->maximum)\r\nadj_slen = slen = c->maximum;\r\nif (adj_slen > slen || (u64)src % c->alignment) {\r\nadj_slen = min(adj_slen, BOUNCE_BUFFER_SIZE);\r\nslen = min(slen, BOUNCE_BUFFER_SIZE);\r\nif (adj_slen > slen)\r\nmemset(ctx->sbounce + slen, 0, adj_slen - slen);\r\nmemcpy(ctx->sbounce, src, slen);\r\nsrc = ctx->sbounce;\r\nslen = adj_slen;\r\npr_debug("using comp sbounce buffer, len %x\n", slen);\r\n}\r\ndst += hdrsize;\r\ndlen -= hdrsize;\r\nif ((u64)dst % c->alignment) {\r\ndskip = (int)(PTR_ALIGN(dst, c->alignment) - dst);\r\ndst += dskip;\r\ndlen -= dskip;\r\n}\r\nif (dlen % c->multiple)\r\ndlen = round_down(dlen, c->multiple);\r\nif (dlen < c->minimum) {\r\nnospc:\r\ndst = ctx->dbounce;\r\ndlen = min(p->oremain, BOUNCE_BUFFER_SIZE);\r\ndlen = round_down(dlen, c->multiple);\r\ndskip = 0;\r\npr_debug("using comp dbounce buffer, len %x\n", dlen);\r\n}\r\nif (dlen > c->maximum)\r\ndlen = c->maximum;\r\ntmplen = dlen;\r\ntimeout = ktime_add_ms(ktime_get(), COMP_BUSY_TIMEOUT);\r\ndo {\r\ndlen = tmplen;\r\nret = ctx->driver->compress(src, slen, dst, &dlen, ctx->wmem);\r\nif (ret == -ENOSPC && dst != ctx->dbounce)\r\ngoto nospc;\r\n} while (ret == -EBUSY && ktime_before(ktime_get(), timeout));\r\nif (ret)\r\nreturn ret;\r\ndskip += hdrsize;\r\nif (dst == ctx->dbounce)\r\nmemcpy(p->out + dskip, dst, dlen);\r\ng->padding = cpu_to_be16(dskip);\r\ng->compressed_length = cpu_to_be32(dlen);\r\ng->uncompressed_length = cpu_to_be32(slen);\r\nif (p->iremain < slen) {\r\n*ignore = slen - p->iremain;\r\nslen = p->iremain;\r\n}\r\npr_debug("compress slen %x ignore %x dlen %x padding %x\n",\r\nslen, *ignore, dlen, dskip);\r\nreturn update_param(p, slen, dskip + dlen);\r\n}\r\nint nx842_crypto_compress(struct crypto_tfm *tfm,\r\nconst u8 *src, unsigned int slen,\r\nu8 *dst, unsigned int *dlen)\r\n{\r\nstruct nx842_crypto_ctx *ctx = crypto_tfm_ctx(tfm);\r\nstruct nx842_crypto_header *hdr = &ctx->header;\r\nstruct nx842_crypto_param p;\r\nstruct nx842_constraints c = *ctx->driver->constraints;\r\nunsigned int groups, hdrsize, h;\r\nint ret, n;\r\nbool add_header;\r\nu16 ignore = 0;\r\ncheck_constraints(&c);\r\np.in = (u8 *)src;\r\np.iremain = slen;\r\np.out = dst;\r\np.oremain = *dlen;\r\np.ototal = 0;\r\n*dlen = 0;\r\ngroups = min_t(unsigned int, NX842_CRYPTO_GROUP_MAX,\r\nDIV_ROUND_UP(p.iremain, c.maximum));\r\nhdrsize = NX842_CRYPTO_HEADER_SIZE(groups);\r\nspin_lock_bh(&ctx->lock);\r\nadd_header = (p.iremain % c.multiple ||\r\np.iremain < c.minimum ||\r\np.iremain > c.maximum ||\r\n(u64)p.in % c.alignment ||\r\np.oremain % c.multiple ||\r\np.oremain < c.minimum ||\r\np.oremain > c.maximum ||\r\n(u64)p.out % c.alignment);\r\nhdr->magic = cpu_to_be16(NX842_CRYPTO_MAGIC);\r\nhdr->groups = 0;\r\nhdr->ignore = 0;\r\nwhile (p.iremain > 0) {\r\nn = hdr->groups++;\r\nret = -ENOSPC;\r\nif (hdr->groups > NX842_CRYPTO_GROUP_MAX)\r\ngoto unlock;\r\nh = !n && add_header ? hdrsize : 0;\r\nif (ignore)\r\npr_warn("interal error, ignore is set %x\n", ignore);\r\nret = compress(ctx, &p, &hdr->group[n], &c, &ignore, h);\r\nif (ret)\r\ngoto unlock;\r\n}\r\nif (!add_header && hdr->groups > 1) {\r\npr_err("Internal error: No header but multiple groups\n");\r\nret = -EINVAL;\r\ngoto unlock;\r\n}\r\nhdr->ignore = cpu_to_be16(ignore);\r\nif (ignore)\r\npr_debug("marked %d bytes as ignore\n", ignore);\r\nif (add_header)\r\nret = nx842_crypto_add_header(hdr, dst);\r\nif (ret)\r\ngoto unlock;\r\n*dlen = p.ototal;\r\npr_debug("compress total slen %x dlen %x\n", slen, *dlen);\r\nunlock:\r\nspin_unlock_bh(&ctx->lock);\r\nreturn ret;\r\n}\r\nstatic int decompress(struct nx842_crypto_ctx *ctx,\r\nstruct nx842_crypto_param *p,\r\nstruct nx842_crypto_header_group *g,\r\nstruct nx842_constraints *c,\r\nu16 ignore)\r\n{\r\nunsigned int slen = be32_to_cpu(g->compressed_length);\r\nunsigned int required_len = be32_to_cpu(g->uncompressed_length);\r\nunsigned int dlen = p->oremain, tmplen;\r\nunsigned int adj_slen = slen;\r\nu8 *src = p->in, *dst = p->out;\r\nu16 padding = be16_to_cpu(g->padding);\r\nint ret, spadding = 0, dpadding = 0;\r\nktime_t timeout;\r\nif (!slen || !required_len)\r\nreturn -EINVAL;\r\nif (p->iremain <= 0 || padding + slen > p->iremain)\r\nreturn -EOVERFLOW;\r\nif (p->oremain <= 0 || required_len - ignore > p->oremain)\r\nreturn -ENOSPC;\r\nsrc += padding;\r\nif (slen % c->multiple)\r\nadj_slen = round_up(slen, c->multiple);\r\nif (slen < c->minimum)\r\nadj_slen = c->minimum;\r\nif (slen > c->maximum)\r\ngoto usesw;\r\nif (slen < adj_slen || (u64)src % c->alignment) {\r\nif (slen < adj_slen)\r\nmemset(ctx->sbounce + slen, 0, adj_slen - slen);\r\nmemcpy(ctx->sbounce, src, slen);\r\nsrc = ctx->sbounce;\r\nspadding = adj_slen - slen;\r\nslen = adj_slen;\r\npr_debug("using decomp sbounce buffer, len %x\n", slen);\r\n}\r\nif (dlen % c->multiple)\r\ndlen = round_down(dlen, c->multiple);\r\nif (dlen < required_len || (u64)dst % c->alignment) {\r\ndst = ctx->dbounce;\r\ndlen = min(required_len, BOUNCE_BUFFER_SIZE);\r\npr_debug("using decomp dbounce buffer, len %x\n", dlen);\r\n}\r\nif (dlen < c->minimum)\r\ngoto usesw;\r\nif (dlen > c->maximum)\r\ndlen = c->maximum;\r\ntmplen = dlen;\r\ntimeout = ktime_add_ms(ktime_get(), DECOMP_BUSY_TIMEOUT);\r\ndo {\r\ndlen = tmplen;\r\nret = ctx->driver->decompress(src, slen, dst, &dlen, ctx->wmem);\r\n} while (ret == -EBUSY && ktime_before(ktime_get(), timeout));\r\nif (ret) {\r\nusesw:\r\nsrc = p->in + padding;\r\nslen = be32_to_cpu(g->compressed_length);\r\nspadding = 0;\r\ndst = p->out;\r\ndlen = p->oremain;\r\ndpadding = 0;\r\nif (dlen < required_len) {\r\ndst = ctx->dbounce;\r\ndlen = BOUNCE_BUFFER_SIZE;\r\n}\r\npr_info_ratelimited("using software 842 decompression\n");\r\nret = sw842_decompress(src, slen, dst, &dlen);\r\n}\r\nif (ret)\r\nreturn ret;\r\nslen -= spadding;\r\ndlen -= ignore;\r\nif (ignore)\r\npr_debug("ignoring last %x bytes\n", ignore);\r\nif (dst == ctx->dbounce)\r\nmemcpy(p->out, dst, dlen);\r\npr_debug("decompress slen %x padding %x dlen %x ignore %x\n",\r\nslen, padding, dlen, ignore);\r\nreturn update_param(p, slen + padding, dlen);\r\n}\r\nint nx842_crypto_decompress(struct crypto_tfm *tfm,\r\nconst u8 *src, unsigned int slen,\r\nu8 *dst, unsigned int *dlen)\r\n{\r\nstruct nx842_crypto_ctx *ctx = crypto_tfm_ctx(tfm);\r\nstruct nx842_crypto_header *hdr;\r\nstruct nx842_crypto_param p;\r\nstruct nx842_constraints c = *ctx->driver->constraints;\r\nint n, ret, hdr_len;\r\nu16 ignore = 0;\r\ncheck_constraints(&c);\r\np.in = (u8 *)src;\r\np.iremain = slen;\r\np.out = dst;\r\np.oremain = *dlen;\r\np.ototal = 0;\r\n*dlen = 0;\r\nhdr = (struct nx842_crypto_header *)src;\r\nspin_lock_bh(&ctx->lock);\r\nif (be16_to_cpu(hdr->magic) != NX842_CRYPTO_MAGIC) {\r\nstruct nx842_crypto_header_group g = {\r\n.padding = 0,\r\n.compressed_length = cpu_to_be32(p.iremain),\r\n.uncompressed_length = cpu_to_be32(p.oremain),\r\n};\r\nret = decompress(ctx, &p, &g, &c, 0);\r\nif (ret)\r\ngoto unlock;\r\ngoto success;\r\n}\r\nif (!hdr->groups) {\r\npr_err("header has no groups\n");\r\nret = -EINVAL;\r\ngoto unlock;\r\n}\r\nif (hdr->groups > NX842_CRYPTO_GROUP_MAX) {\r\npr_err("header has too many groups %x, max %x\n",\r\nhdr->groups, NX842_CRYPTO_GROUP_MAX);\r\nret = -EINVAL;\r\ngoto unlock;\r\n}\r\nhdr_len = NX842_CRYPTO_HEADER_SIZE(hdr->groups);\r\nif (hdr_len > slen) {\r\nret = -EOVERFLOW;\r\ngoto unlock;\r\n}\r\nmemcpy(&ctx->header, src, hdr_len);\r\nhdr = &ctx->header;\r\nfor (n = 0; n < hdr->groups; n++) {\r\nif (n + 1 == hdr->groups)\r\nignore = be16_to_cpu(hdr->ignore);\r\nret = decompress(ctx, &p, &hdr->group[n], &c, ignore);\r\nif (ret)\r\ngoto unlock;\r\n}\r\nsuccess:\r\n*dlen = p.ototal;\r\npr_debug("decompress total slen %x dlen %x\n", slen, *dlen);\r\nret = 0;\r\nunlock:\r\nspin_unlock_bh(&ctx->lock);\r\nreturn ret;\r\n}
