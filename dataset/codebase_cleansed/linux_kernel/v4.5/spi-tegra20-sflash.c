static inline u32 tegra_sflash_readl(struct tegra_sflash_data *tsd,\r\nunsigned long reg)\r\n{\r\nreturn readl(tsd->base + reg);\r\n}\r\nstatic inline void tegra_sflash_writel(struct tegra_sflash_data *tsd,\r\nu32 val, unsigned long reg)\r\n{\r\nwritel(val, tsd->base + reg);\r\n}\r\nstatic void tegra_sflash_clear_status(struct tegra_sflash_data *tsd)\r\n{\r\ntegra_sflash_writel(tsd, SPI_RDY | SPI_FIFO_ERROR, SPI_STATUS);\r\n}\r\nstatic unsigned tegra_sflash_calculate_curr_xfer_param(\r\nstruct spi_device *spi, struct tegra_sflash_data *tsd,\r\nstruct spi_transfer *t)\r\n{\r\nunsigned remain_len = t->len - tsd->cur_pos;\r\nunsigned max_word;\r\ntsd->bytes_per_word = DIV_ROUND_UP(t->bits_per_word, 8);\r\nmax_word = remain_len / tsd->bytes_per_word;\r\nif (max_word > SPI_FIFO_DEPTH)\r\nmax_word = SPI_FIFO_DEPTH;\r\ntsd->curr_xfer_words = max_word;\r\nreturn max_word;\r\n}\r\nstatic unsigned tegra_sflash_fill_tx_fifo_from_client_txbuf(\r\nstruct tegra_sflash_data *tsd, struct spi_transfer *t)\r\n{\r\nunsigned nbytes;\r\nu32 status;\r\nunsigned max_n_32bit = tsd->curr_xfer_words;\r\nu8 *tx_buf = (u8 *)t->tx_buf + tsd->cur_tx_pos;\r\nif (max_n_32bit > SPI_FIFO_DEPTH)\r\nmax_n_32bit = SPI_FIFO_DEPTH;\r\nnbytes = max_n_32bit * tsd->bytes_per_word;\r\nstatus = tegra_sflash_readl(tsd, SPI_STATUS);\r\nwhile (!(status & SPI_TXF_FULL)) {\r\nint i;\r\nu32 x = 0;\r\nfor (i = 0; nbytes && (i < tsd->bytes_per_word);\r\ni++, nbytes--)\r\nx |= (u32)(*tx_buf++) << (i * 8);\r\ntegra_sflash_writel(tsd, x, SPI_TX_FIFO);\r\nif (!nbytes)\r\nbreak;\r\nstatus = tegra_sflash_readl(tsd, SPI_STATUS);\r\n}\r\ntsd->cur_tx_pos += max_n_32bit * tsd->bytes_per_word;\r\nreturn max_n_32bit;\r\n}\r\nstatic int tegra_sflash_read_rx_fifo_to_client_rxbuf(\r\nstruct tegra_sflash_data *tsd, struct spi_transfer *t)\r\n{\r\nu32 status;\r\nunsigned int read_words = 0;\r\nu8 *rx_buf = (u8 *)t->rx_buf + tsd->cur_rx_pos;\r\nstatus = tegra_sflash_readl(tsd, SPI_STATUS);\r\nwhile (!(status & SPI_RXF_EMPTY)) {\r\nint i;\r\nu32 x = tegra_sflash_readl(tsd, SPI_RX_FIFO);\r\nfor (i = 0; (i < tsd->bytes_per_word); i++)\r\n*rx_buf++ = (x >> (i*8)) & 0xFF;\r\nread_words++;\r\nstatus = tegra_sflash_readl(tsd, SPI_STATUS);\r\n}\r\ntsd->cur_rx_pos += read_words * tsd->bytes_per_word;\r\nreturn 0;\r\n}\r\nstatic int tegra_sflash_start_cpu_based_transfer(\r\nstruct tegra_sflash_data *tsd, struct spi_transfer *t)\r\n{\r\nu32 val = 0;\r\nunsigned cur_words;\r\nif (tsd->cur_direction & DATA_DIR_TX)\r\nval |= SPI_IE_TXC;\r\nif (tsd->cur_direction & DATA_DIR_RX)\r\nval |= SPI_IE_RXC;\r\ntegra_sflash_writel(tsd, val, SPI_DMA_CTL);\r\ntsd->dma_control_reg = val;\r\nif (tsd->cur_direction & DATA_DIR_TX)\r\ncur_words = tegra_sflash_fill_tx_fifo_from_client_txbuf(tsd, t);\r\nelse\r\ncur_words = tsd->curr_xfer_words;\r\nval |= SPI_DMA_BLK_COUNT(cur_words);\r\ntegra_sflash_writel(tsd, val, SPI_DMA_CTL);\r\ntsd->dma_control_reg = val;\r\nval |= SPI_DMA_EN;\r\ntegra_sflash_writel(tsd, val, SPI_DMA_CTL);\r\nreturn 0;\r\n}\r\nstatic int tegra_sflash_start_transfer_one(struct spi_device *spi,\r\nstruct spi_transfer *t, bool is_first_of_msg,\r\nbool is_single_xfer)\r\n{\r\nstruct tegra_sflash_data *tsd = spi_master_get_devdata(spi->master);\r\nu32 speed;\r\nu32 command;\r\nspeed = t->speed_hz;\r\nif (speed != tsd->cur_speed) {\r\nclk_set_rate(tsd->clk, speed);\r\ntsd->cur_speed = speed;\r\n}\r\ntsd->cur_spi = spi;\r\ntsd->cur_pos = 0;\r\ntsd->cur_rx_pos = 0;\r\ntsd->cur_tx_pos = 0;\r\ntsd->curr_xfer = t;\r\ntegra_sflash_calculate_curr_xfer_param(spi, tsd, t);\r\nif (is_first_of_msg) {\r\ncommand = tsd->def_command_reg;\r\ncommand |= SPI_BIT_LENGTH(t->bits_per_word - 1);\r\ncommand |= SPI_CS_VAL_HIGH;\r\ncommand &= ~SPI_MODES;\r\nif (spi->mode & SPI_CPHA)\r\ncommand |= SPI_CK_SDA_FALLING;\r\nif (spi->mode & SPI_CPOL)\r\ncommand |= SPI_ACTIVE_SCLK_DRIVE_HIGH;\r\nelse\r\ncommand |= SPI_ACTIVE_SCLK_DRIVE_LOW;\r\ncommand |= SPI_CS0_EN << spi->chip_select;\r\n} else {\r\ncommand = tsd->command_reg;\r\ncommand &= ~SPI_BIT_LENGTH(~0);\r\ncommand |= SPI_BIT_LENGTH(t->bits_per_word - 1);\r\ncommand &= ~(SPI_RX_EN | SPI_TX_EN);\r\n}\r\ntsd->cur_direction = 0;\r\nif (t->rx_buf) {\r\ncommand |= SPI_RX_EN;\r\ntsd->cur_direction |= DATA_DIR_RX;\r\n}\r\nif (t->tx_buf) {\r\ncommand |= SPI_TX_EN;\r\ntsd->cur_direction |= DATA_DIR_TX;\r\n}\r\ntegra_sflash_writel(tsd, command, SPI_COMMAND);\r\ntsd->command_reg = command;\r\nreturn tegra_sflash_start_cpu_based_transfer(tsd, t);\r\n}\r\nstatic int tegra_sflash_transfer_one_message(struct spi_master *master,\r\nstruct spi_message *msg)\r\n{\r\nbool is_first_msg = true;\r\nint single_xfer;\r\nstruct tegra_sflash_data *tsd = spi_master_get_devdata(master);\r\nstruct spi_transfer *xfer;\r\nstruct spi_device *spi = msg->spi;\r\nint ret;\r\nmsg->status = 0;\r\nmsg->actual_length = 0;\r\nsingle_xfer = list_is_singular(&msg->transfers);\r\nlist_for_each_entry(xfer, &msg->transfers, transfer_list) {\r\nreinit_completion(&tsd->xfer_completion);\r\nret = tegra_sflash_start_transfer_one(spi, xfer,\r\nis_first_msg, single_xfer);\r\nif (ret < 0) {\r\ndev_err(tsd->dev,\r\n"spi can not start transfer, err %d\n", ret);\r\ngoto exit;\r\n}\r\nis_first_msg = false;\r\nret = wait_for_completion_timeout(&tsd->xfer_completion,\r\nSPI_DMA_TIMEOUT);\r\nif (WARN_ON(ret == 0)) {\r\ndev_err(tsd->dev,\r\n"spi trasfer timeout, err %d\n", ret);\r\nret = -EIO;\r\ngoto exit;\r\n}\r\nif (tsd->tx_status || tsd->rx_status) {\r\ndev_err(tsd->dev, "Error in Transfer\n");\r\nret = -EIO;\r\ngoto exit;\r\n}\r\nmsg->actual_length += xfer->len;\r\nif (xfer->cs_change && xfer->delay_usecs) {\r\ntegra_sflash_writel(tsd, tsd->def_command_reg,\r\nSPI_COMMAND);\r\nudelay(xfer->delay_usecs);\r\n}\r\n}\r\nret = 0;\r\nexit:\r\ntegra_sflash_writel(tsd, tsd->def_command_reg, SPI_COMMAND);\r\nmsg->status = ret;\r\nspi_finalize_current_message(master);\r\nreturn ret;\r\n}\r\nstatic irqreturn_t handle_cpu_based_xfer(struct tegra_sflash_data *tsd)\r\n{\r\nstruct spi_transfer *t = tsd->curr_xfer;\r\nunsigned long flags;\r\nspin_lock_irqsave(&tsd->lock, flags);\r\nif (tsd->tx_status || tsd->rx_status || (tsd->status_reg & SPI_BSY)) {\r\ndev_err(tsd->dev,\r\n"CpuXfer ERROR bit set 0x%x\n", tsd->status_reg);\r\ndev_err(tsd->dev,\r\n"CpuXfer 0x%08x:0x%08x\n", tsd->command_reg,\r\ntsd->dma_control_reg);\r\nreset_control_assert(tsd->rst);\r\nudelay(2);\r\nreset_control_deassert(tsd->rst);\r\ncomplete(&tsd->xfer_completion);\r\ngoto exit;\r\n}\r\nif (tsd->cur_direction & DATA_DIR_RX)\r\ntegra_sflash_read_rx_fifo_to_client_rxbuf(tsd, t);\r\nif (tsd->cur_direction & DATA_DIR_TX)\r\ntsd->cur_pos = tsd->cur_tx_pos;\r\nelse\r\ntsd->cur_pos = tsd->cur_rx_pos;\r\nif (tsd->cur_pos == t->len) {\r\ncomplete(&tsd->xfer_completion);\r\ngoto exit;\r\n}\r\ntegra_sflash_calculate_curr_xfer_param(tsd->cur_spi, tsd, t);\r\ntegra_sflash_start_cpu_based_transfer(tsd, t);\r\nexit:\r\nspin_unlock_irqrestore(&tsd->lock, flags);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic irqreturn_t tegra_sflash_isr(int irq, void *context_data)\r\n{\r\nstruct tegra_sflash_data *tsd = context_data;\r\ntsd->status_reg = tegra_sflash_readl(tsd, SPI_STATUS);\r\nif (tsd->cur_direction & DATA_DIR_TX)\r\ntsd->tx_status = tsd->status_reg & SPI_TX_OVF;\r\nif (tsd->cur_direction & DATA_DIR_RX)\r\ntsd->rx_status = tsd->status_reg & SPI_RX_UNF;\r\ntegra_sflash_clear_status(tsd);\r\nreturn handle_cpu_based_xfer(tsd);\r\n}\r\nstatic int tegra_sflash_probe(struct platform_device *pdev)\r\n{\r\nstruct spi_master *master;\r\nstruct tegra_sflash_data *tsd;\r\nstruct resource *r;\r\nint ret;\r\nconst struct of_device_id *match;\r\nmatch = of_match_device(tegra_sflash_of_match, &pdev->dev);\r\nif (!match) {\r\ndev_err(&pdev->dev, "Error: No device match found\n");\r\nreturn -ENODEV;\r\n}\r\nmaster = spi_alloc_master(&pdev->dev, sizeof(*tsd));\r\nif (!master) {\r\ndev_err(&pdev->dev, "master allocation failed\n");\r\nreturn -ENOMEM;\r\n}\r\nmaster->mode_bits = SPI_CPOL | SPI_CPHA;\r\nmaster->transfer_one_message = tegra_sflash_transfer_one_message;\r\nmaster->auto_runtime_pm = true;\r\nmaster->num_chipselect = MAX_CHIP_SELECT;\r\nplatform_set_drvdata(pdev, master);\r\ntsd = spi_master_get_devdata(master);\r\ntsd->master = master;\r\ntsd->dev = &pdev->dev;\r\nspin_lock_init(&tsd->lock);\r\nif (of_property_read_u32(tsd->dev->of_node, "spi-max-frequency",\r\n&master->max_speed_hz))\r\nmaster->max_speed_hz = 25000000;\r\nr = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\ntsd->base = devm_ioremap_resource(&pdev->dev, r);\r\nif (IS_ERR(tsd->base)) {\r\nret = PTR_ERR(tsd->base);\r\ngoto exit_free_master;\r\n}\r\ntsd->irq = platform_get_irq(pdev, 0);\r\nret = request_irq(tsd->irq, tegra_sflash_isr, 0,\r\ndev_name(&pdev->dev), tsd);\r\nif (ret < 0) {\r\ndev_err(&pdev->dev, "Failed to register ISR for IRQ %d\n",\r\ntsd->irq);\r\ngoto exit_free_master;\r\n}\r\ntsd->clk = devm_clk_get(&pdev->dev, NULL);\r\nif (IS_ERR(tsd->clk)) {\r\ndev_err(&pdev->dev, "can not get clock\n");\r\nret = PTR_ERR(tsd->clk);\r\ngoto exit_free_irq;\r\n}\r\ntsd->rst = devm_reset_control_get(&pdev->dev, "spi");\r\nif (IS_ERR(tsd->rst)) {\r\ndev_err(&pdev->dev, "can not get reset\n");\r\nret = PTR_ERR(tsd->rst);\r\ngoto exit_free_irq;\r\n}\r\ninit_completion(&tsd->xfer_completion);\r\npm_runtime_enable(&pdev->dev);\r\nif (!pm_runtime_enabled(&pdev->dev)) {\r\nret = tegra_sflash_runtime_resume(&pdev->dev);\r\nif (ret)\r\ngoto exit_pm_disable;\r\n}\r\nret = pm_runtime_get_sync(&pdev->dev);\r\nif (ret < 0) {\r\ndev_err(&pdev->dev, "pm runtime get failed, e = %d\n", ret);\r\ngoto exit_pm_disable;\r\n}\r\nreset_control_assert(tsd->rst);\r\nudelay(2);\r\nreset_control_deassert(tsd->rst);\r\ntsd->def_command_reg = SPI_M_S | SPI_CS_SW;\r\ntegra_sflash_writel(tsd, tsd->def_command_reg, SPI_COMMAND);\r\npm_runtime_put(&pdev->dev);\r\nmaster->dev.of_node = pdev->dev.of_node;\r\nret = devm_spi_register_master(&pdev->dev, master);\r\nif (ret < 0) {\r\ndev_err(&pdev->dev, "can not register to master err %d\n", ret);\r\ngoto exit_pm_disable;\r\n}\r\nreturn ret;\r\nexit_pm_disable:\r\npm_runtime_disable(&pdev->dev);\r\nif (!pm_runtime_status_suspended(&pdev->dev))\r\ntegra_sflash_runtime_suspend(&pdev->dev);\r\nexit_free_irq:\r\nfree_irq(tsd->irq, tsd);\r\nexit_free_master:\r\nspi_master_put(master);\r\nreturn ret;\r\n}\r\nstatic int tegra_sflash_remove(struct platform_device *pdev)\r\n{\r\nstruct spi_master *master = platform_get_drvdata(pdev);\r\nstruct tegra_sflash_data *tsd = spi_master_get_devdata(master);\r\nfree_irq(tsd->irq, tsd);\r\npm_runtime_disable(&pdev->dev);\r\nif (!pm_runtime_status_suspended(&pdev->dev))\r\ntegra_sflash_runtime_suspend(&pdev->dev);\r\nreturn 0;\r\n}\r\nstatic int tegra_sflash_suspend(struct device *dev)\r\n{\r\nstruct spi_master *master = dev_get_drvdata(dev);\r\nreturn spi_master_suspend(master);\r\n}\r\nstatic int tegra_sflash_resume(struct device *dev)\r\n{\r\nstruct spi_master *master = dev_get_drvdata(dev);\r\nstruct tegra_sflash_data *tsd = spi_master_get_devdata(master);\r\nint ret;\r\nret = pm_runtime_get_sync(dev);\r\nif (ret < 0) {\r\ndev_err(dev, "pm runtime failed, e = %d\n", ret);\r\nreturn ret;\r\n}\r\ntegra_sflash_writel(tsd, tsd->command_reg, SPI_COMMAND);\r\npm_runtime_put(dev);\r\nreturn spi_master_resume(master);\r\n}\r\nstatic int tegra_sflash_runtime_suspend(struct device *dev)\r\n{\r\nstruct spi_master *master = dev_get_drvdata(dev);\r\nstruct tegra_sflash_data *tsd = spi_master_get_devdata(master);\r\ntegra_sflash_readl(tsd, SPI_COMMAND);\r\nclk_disable_unprepare(tsd->clk);\r\nreturn 0;\r\n}\r\nstatic int tegra_sflash_runtime_resume(struct device *dev)\r\n{\r\nstruct spi_master *master = dev_get_drvdata(dev);\r\nstruct tegra_sflash_data *tsd = spi_master_get_devdata(master);\r\nint ret;\r\nret = clk_prepare_enable(tsd->clk);\r\nif (ret < 0) {\r\ndev_err(tsd->dev, "clk_prepare failed: %d\n", ret);\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}
