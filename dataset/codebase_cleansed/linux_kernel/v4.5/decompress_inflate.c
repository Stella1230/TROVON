static long INIT nofill(void *buffer, unsigned long len)\r\n{\r\nreturn -1;\r\n}\r\nSTATIC int INIT __gunzip(unsigned char *buf, long len,\r\nlong (*fill)(void*, unsigned long),\r\nlong (*flush)(void*, unsigned long),\r\nunsigned char *out_buf, long out_len,\r\nlong *pos,\r\nvoid(*error)(char *x)) {\r\nu8 *zbuf;\r\nstruct z_stream_s *strm;\r\nint rc;\r\nrc = -1;\r\nif (flush) {\r\nout_len = 0x8000;\r\nout_buf = malloc(out_len);\r\n} else {\r\nif (!out_len)\r\nout_len = ((size_t)~0) - (size_t)out_buf;\r\n}\r\nif (!out_buf) {\r\nerror("Out of memory while allocating output buffer");\r\ngoto gunzip_nomem1;\r\n}\r\nif (buf)\r\nzbuf = buf;\r\nelse {\r\nzbuf = malloc(GZIP_IOBUF_SIZE);\r\nlen = 0;\r\n}\r\nif (!zbuf) {\r\nerror("Out of memory while allocating input buffer");\r\ngoto gunzip_nomem2;\r\n}\r\nstrm = malloc(sizeof(*strm));\r\nif (strm == NULL) {\r\nerror("Out of memory while allocating z_stream");\r\ngoto gunzip_nomem3;\r\n}\r\nstrm->workspace = malloc(flush ? zlib_inflate_workspacesize() :\r\nsizeof(struct inflate_state));\r\nif (strm->workspace == NULL) {\r\nerror("Out of memory while allocating workspace");\r\ngoto gunzip_nomem4;\r\n}\r\nif (!fill)\r\nfill = nofill;\r\nif (len == 0)\r\nlen = fill(zbuf, GZIP_IOBUF_SIZE);\r\nif (len < 10 ||\r\nzbuf[0] != 0x1f || zbuf[1] != 0x8b || zbuf[2] != 0x08) {\r\nif (pos)\r\n*pos = 0;\r\nerror("Not a gzip file");\r\ngoto gunzip_5;\r\n}\r\nstrm->next_in = zbuf + 10;\r\nstrm->avail_in = len - 10;\r\nif (zbuf[3] & 0x8) {\r\ndo {\r\nif (strm->avail_in == 0) {\r\nerror("header error");\r\ngoto gunzip_5;\r\n}\r\n--strm->avail_in;\r\n} while (*strm->next_in++);\r\n}\r\nstrm->next_out = out_buf;\r\nstrm->avail_out = out_len;\r\nrc = zlib_inflateInit2(strm, -MAX_WBITS);\r\nif (!flush) {\r\nWS(strm)->inflate_state.wsize = 0;\r\nWS(strm)->inflate_state.window = NULL;\r\n}\r\nwhile (rc == Z_OK) {\r\nif (strm->avail_in == 0) {\r\nlen = fill(zbuf, GZIP_IOBUF_SIZE);\r\nif (len < 0) {\r\nrc = -1;\r\nerror("read error");\r\nbreak;\r\n}\r\nstrm->next_in = zbuf;\r\nstrm->avail_in = len;\r\n}\r\nrc = zlib_inflate(strm, 0);\r\nif (flush && strm->next_out > out_buf) {\r\nlong l = strm->next_out - out_buf;\r\nif (l != flush(out_buf, l)) {\r\nrc = -1;\r\nerror("write error");\r\nbreak;\r\n}\r\nstrm->next_out = out_buf;\r\nstrm->avail_out = out_len;\r\n}\r\nif (rc == Z_STREAM_END) {\r\nrc = 0;\r\nbreak;\r\n} else if (rc != Z_OK) {\r\nerror("uncompression error");\r\nrc = -1;\r\n}\r\n}\r\nzlib_inflateEnd(strm);\r\nif (pos)\r\n*pos = strm->next_in - zbuf+8;\r\ngunzip_5:\r\nfree(strm->workspace);\r\ngunzip_nomem4:\r\nfree(strm);\r\ngunzip_nomem3:\r\nif (!buf)\r\nfree(zbuf);\r\ngunzip_nomem2:\r\nif (flush)\r\nfree(out_buf);\r\ngunzip_nomem1:\r\nreturn rc;\r\n}\r\nSTATIC int INIT gunzip(unsigned char *buf, long len,\r\nlong (*fill)(void*, unsigned long),\r\nlong (*flush)(void*, unsigned long),\r\nunsigned char *out_buf,\r\nlong *pos,\r\nvoid (*error)(char *x))\r\n{\r\nreturn __gunzip(buf, len, fill, flush, out_buf, 0, pos, error);\r\n}\r\nSTATIC int INIT __decompress(unsigned char *buf, long len,\r\nlong (*fill)(void*, unsigned long),\r\nlong (*flush)(void*, unsigned long),\r\nunsigned char *out_buf, long out_len,\r\nlong *pos,\r\nvoid (*error)(char *x))\r\n{\r\nreturn __gunzip(buf, len, fill, flush, out_buf, out_len, pos, error);\r\n}
