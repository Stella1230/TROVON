static int shmob_drm_init_interface(struct shmob_drm_device *sdev)\r\n{\r\nstatic const u32 ldmt1r[] = {\r\n[SHMOB_DRM_IFACE_RGB8] = LDMT1R_MIFTYP_RGB8,\r\n[SHMOB_DRM_IFACE_RGB9] = LDMT1R_MIFTYP_RGB9,\r\n[SHMOB_DRM_IFACE_RGB12A] = LDMT1R_MIFTYP_RGB12A,\r\n[SHMOB_DRM_IFACE_RGB12B] = LDMT1R_MIFTYP_RGB12B,\r\n[SHMOB_DRM_IFACE_RGB16] = LDMT1R_MIFTYP_RGB16,\r\n[SHMOB_DRM_IFACE_RGB18] = LDMT1R_MIFTYP_RGB18,\r\n[SHMOB_DRM_IFACE_RGB24] = LDMT1R_MIFTYP_RGB24,\r\n[SHMOB_DRM_IFACE_YUV422] = LDMT1R_MIFTYP_YCBCR,\r\n[SHMOB_DRM_IFACE_SYS8A] = LDMT1R_IFM | LDMT1R_MIFTYP_SYS8A,\r\n[SHMOB_DRM_IFACE_SYS8B] = LDMT1R_IFM | LDMT1R_MIFTYP_SYS8B,\r\n[SHMOB_DRM_IFACE_SYS8C] = LDMT1R_IFM | LDMT1R_MIFTYP_SYS8C,\r\n[SHMOB_DRM_IFACE_SYS8D] = LDMT1R_IFM | LDMT1R_MIFTYP_SYS8D,\r\n[SHMOB_DRM_IFACE_SYS9] = LDMT1R_IFM | LDMT1R_MIFTYP_SYS9,\r\n[SHMOB_DRM_IFACE_SYS12] = LDMT1R_IFM | LDMT1R_MIFTYP_SYS12,\r\n[SHMOB_DRM_IFACE_SYS16A] = LDMT1R_IFM | LDMT1R_MIFTYP_SYS16A,\r\n[SHMOB_DRM_IFACE_SYS16B] = LDMT1R_IFM | LDMT1R_MIFTYP_SYS16B,\r\n[SHMOB_DRM_IFACE_SYS16C] = LDMT1R_IFM | LDMT1R_MIFTYP_SYS16C,\r\n[SHMOB_DRM_IFACE_SYS18] = LDMT1R_IFM | LDMT1R_MIFTYP_SYS18,\r\n[SHMOB_DRM_IFACE_SYS24] = LDMT1R_IFM | LDMT1R_MIFTYP_SYS24,\r\n};\r\nif (sdev->pdata->iface.interface >= ARRAY_SIZE(ldmt1r)) {\r\ndev_err(sdev->dev, "invalid interface type %u\n",\r\nsdev->pdata->iface.interface);\r\nreturn -EINVAL;\r\n}\r\nsdev->ldmt1r = ldmt1r[sdev->pdata->iface.interface];\r\nreturn 0;\r\n}\r\nstatic int shmob_drm_setup_clocks(struct shmob_drm_device *sdev,\r\nenum shmob_drm_clk_source clksrc)\r\n{\r\nstruct clk *clk;\r\nchar *clkname;\r\nswitch (clksrc) {\r\ncase SHMOB_DRM_CLK_BUS:\r\nclkname = "bus_clk";\r\nsdev->lddckr = LDDCKR_ICKSEL_BUS;\r\nbreak;\r\ncase SHMOB_DRM_CLK_PERIPHERAL:\r\nclkname = "peripheral_clk";\r\nsdev->lddckr = LDDCKR_ICKSEL_MIPI;\r\nbreak;\r\ncase SHMOB_DRM_CLK_EXTERNAL:\r\nclkname = NULL;\r\nsdev->lddckr = LDDCKR_ICKSEL_HDMI;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nclk = devm_clk_get(sdev->dev, clkname);\r\nif (IS_ERR(clk)) {\r\ndev_err(sdev->dev, "cannot get dot clock %s\n", clkname);\r\nreturn PTR_ERR(clk);\r\n}\r\nsdev->clock = clk;\r\nreturn 0;\r\n}\r\nstatic int shmob_drm_unload(struct drm_device *dev)\r\n{\r\ndrm_kms_helper_poll_fini(dev);\r\ndrm_mode_config_cleanup(dev);\r\ndrm_vblank_cleanup(dev);\r\ndrm_irq_uninstall(dev);\r\ndev->dev_private = NULL;\r\nreturn 0;\r\n}\r\nstatic int shmob_drm_load(struct drm_device *dev, unsigned long flags)\r\n{\r\nstruct shmob_drm_platform_data *pdata = dev->dev->platform_data;\r\nstruct platform_device *pdev = dev->platformdev;\r\nstruct shmob_drm_device *sdev;\r\nstruct resource *res;\r\nunsigned int i;\r\nint ret;\r\nif (pdata == NULL) {\r\ndev_err(dev->dev, "no platform data\n");\r\nreturn -EINVAL;\r\n}\r\nsdev = devm_kzalloc(&pdev->dev, sizeof(*sdev), GFP_KERNEL);\r\nif (sdev == NULL) {\r\ndev_err(dev->dev, "failed to allocate private data\n");\r\nreturn -ENOMEM;\r\n}\r\nsdev->dev = &pdev->dev;\r\nsdev->pdata = pdata;\r\nspin_lock_init(&sdev->irq_lock);\r\nsdev->ddev = dev;\r\ndev->dev_private = sdev;\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nif (res == NULL) {\r\ndev_err(&pdev->dev, "failed to get memory resource\n");\r\nreturn -EINVAL;\r\n}\r\nsdev->mmio = devm_ioremap_nocache(&pdev->dev, res->start,\r\nresource_size(res));\r\nif (sdev->mmio == NULL) {\r\ndev_err(&pdev->dev, "failed to remap memory resource\n");\r\nreturn -ENOMEM;\r\n}\r\nret = shmob_drm_setup_clocks(sdev, pdata->clk_source);\r\nif (ret < 0)\r\nreturn ret;\r\nret = shmob_drm_init_interface(sdev);\r\nif (ret < 0)\r\nreturn ret;\r\nret = shmob_drm_modeset_init(sdev);\r\nif (ret < 0) {\r\ndev_err(&pdev->dev, "failed to initialize mode setting\n");\r\nreturn ret;\r\n}\r\nfor (i = 0; i < 4; ++i) {\r\nret = shmob_drm_plane_create(sdev, i);\r\nif (ret < 0) {\r\ndev_err(&pdev->dev, "failed to create plane %u\n", i);\r\ngoto done;\r\n}\r\n}\r\nret = drm_vblank_init(dev, 1);\r\nif (ret < 0) {\r\ndev_err(&pdev->dev, "failed to initialize vblank\n");\r\ngoto done;\r\n}\r\nret = drm_irq_install(dev, platform_get_irq(dev->platformdev, 0));\r\nif (ret < 0) {\r\ndev_err(&pdev->dev, "failed to install IRQ handler\n");\r\ngoto done;\r\n}\r\nplatform_set_drvdata(pdev, sdev);\r\ndone:\r\nif (ret)\r\nshmob_drm_unload(dev);\r\nreturn ret;\r\n}\r\nstatic void shmob_drm_preclose(struct drm_device *dev, struct drm_file *file)\r\n{\r\nstruct shmob_drm_device *sdev = dev->dev_private;\r\nshmob_drm_crtc_cancel_page_flip(&sdev->crtc, file);\r\n}\r\nstatic irqreturn_t shmob_drm_irq(int irq, void *arg)\r\n{\r\nstruct drm_device *dev = arg;\r\nstruct shmob_drm_device *sdev = dev->dev_private;\r\nunsigned long flags;\r\nu32 status;\r\nspin_lock_irqsave(&sdev->irq_lock, flags);\r\nstatus = lcdc_read(sdev, LDINTR);\r\nlcdc_write(sdev, LDINTR, status ^ LDINTR_STATUS_MASK);\r\nspin_unlock_irqrestore(&sdev->irq_lock, flags);\r\nif (status & LDINTR_VES) {\r\ndrm_handle_vblank(dev, 0);\r\nshmob_drm_crtc_finish_page_flip(&sdev->crtc);\r\n}\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int shmob_drm_enable_vblank(struct drm_device *dev, unsigned int pipe)\r\n{\r\nstruct shmob_drm_device *sdev = dev->dev_private;\r\nshmob_drm_crtc_enable_vblank(sdev, true);\r\nreturn 0;\r\n}\r\nstatic void shmob_drm_disable_vblank(struct drm_device *dev, unsigned int pipe)\r\n{\r\nstruct shmob_drm_device *sdev = dev->dev_private;\r\nshmob_drm_crtc_enable_vblank(sdev, false);\r\n}\r\nstatic int shmob_drm_pm_suspend(struct device *dev)\r\n{\r\nstruct shmob_drm_device *sdev = dev_get_drvdata(dev);\r\ndrm_kms_helper_poll_disable(sdev->ddev);\r\nshmob_drm_crtc_suspend(&sdev->crtc);\r\nreturn 0;\r\n}\r\nstatic int shmob_drm_pm_resume(struct device *dev)\r\n{\r\nstruct shmob_drm_device *sdev = dev_get_drvdata(dev);\r\ndrm_modeset_lock_all(sdev->ddev);\r\nshmob_drm_crtc_resume(&sdev->crtc);\r\ndrm_modeset_unlock_all(sdev->ddev);\r\ndrm_kms_helper_poll_enable(sdev->ddev);\r\nreturn 0;\r\n}\r\nstatic int shmob_drm_probe(struct platform_device *pdev)\r\n{\r\nreturn drm_platform_init(&shmob_drm_driver, pdev);\r\n}\r\nstatic int shmob_drm_remove(struct platform_device *pdev)\r\n{\r\nstruct shmob_drm_device *sdev = platform_get_drvdata(pdev);\r\ndrm_put_dev(sdev->ddev);\r\nreturn 0;\r\n}
