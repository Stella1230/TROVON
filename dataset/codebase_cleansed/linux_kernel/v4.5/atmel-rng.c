static int atmel_trng_read(struct hwrng *rng, void *buf, size_t max,\r\nbool wait)\r\n{\r\nstruct atmel_trng *trng = container_of(rng, struct atmel_trng, rng);\r\nu32 *data = buf;\r\nif (readl(trng->base + TRNG_ISR) & 1) {\r\n*data = readl(trng->base + TRNG_ODATA);\r\nreadl(trng->base + TRNG_ISR);\r\nreturn 4;\r\n} else\r\nreturn 0;\r\n}\r\nstatic int atmel_trng_probe(struct platform_device *pdev)\r\n{\r\nstruct atmel_trng *trng;\r\nstruct resource *res;\r\nint ret;\r\ntrng = devm_kzalloc(&pdev->dev, sizeof(*trng), GFP_KERNEL);\r\nif (!trng)\r\nreturn -ENOMEM;\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\ntrng->base = devm_ioremap_resource(&pdev->dev, res);\r\nif (IS_ERR(trng->base))\r\nreturn PTR_ERR(trng->base);\r\ntrng->clk = devm_clk_get(&pdev->dev, NULL);\r\nif (IS_ERR(trng->clk))\r\nreturn PTR_ERR(trng->clk);\r\nret = clk_prepare_enable(trng->clk);\r\nif (ret)\r\nreturn ret;\r\nwritel(TRNG_KEY | 1, trng->base + TRNG_CR);\r\ntrng->rng.name = pdev->name;\r\ntrng->rng.read = atmel_trng_read;\r\nret = hwrng_register(&trng->rng);\r\nif (ret)\r\ngoto err_register;\r\nplatform_set_drvdata(pdev, trng);\r\nreturn 0;\r\nerr_register:\r\nclk_disable(trng->clk);\r\nreturn ret;\r\n}\r\nstatic int atmel_trng_remove(struct platform_device *pdev)\r\n{\r\nstruct atmel_trng *trng = platform_get_drvdata(pdev);\r\nhwrng_unregister(&trng->rng);\r\nwritel(TRNG_KEY, trng->base + TRNG_CR);\r\nclk_disable_unprepare(trng->clk);\r\nreturn 0;\r\n}\r\nstatic int atmel_trng_suspend(struct device *dev)\r\n{\r\nstruct atmel_trng *trng = dev_get_drvdata(dev);\r\nclk_disable_unprepare(trng->clk);\r\nreturn 0;\r\n}\r\nstatic int atmel_trng_resume(struct device *dev)\r\n{\r\nstruct atmel_trng *trng = dev_get_drvdata(dev);\r\nreturn clk_prepare_enable(trng->clk);\r\n}
