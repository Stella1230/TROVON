static u8 get_nic_interface(struct mlx5_core_dev *dev)\r\n{\r\nreturn (ioread32be(&dev->iseg->cmdq_addr_l_sz) >> 8) & 3;\r\n}\r\nstatic void trigger_cmd_completions(struct mlx5_core_dev *dev)\r\n{\r\nunsigned long flags;\r\nu64 vector;\r\nsynchronize_irq(dev->priv.msix_arr[MLX5_EQ_VEC_CMD].vector);\r\nspin_lock_irqsave(&dev->cmd.alloc_lock, flags);\r\nvector = ~dev->cmd.bitmask & ((1ul << (1 << dev->cmd.log_sz)) - 1);\r\nif (!vector)\r\ngoto no_trig;\r\nvector |= MLX5_TRIGGERED_CMD_COMP;\r\nspin_unlock_irqrestore(&dev->cmd.alloc_lock, flags);\r\nmlx5_core_dbg(dev, "vector 0x%llx\n", vector);\r\nmlx5_cmd_comp_handler(dev, vector);\r\nreturn;\r\nno_trig:\r\nspin_unlock_irqrestore(&dev->cmd.alloc_lock, flags);\r\n}\r\nstatic int in_fatal(struct mlx5_core_dev *dev)\r\n{\r\nstruct mlx5_core_health *health = &dev->priv.health;\r\nstruct health_buffer __iomem *h = health->health;\r\nif (get_nic_interface(dev) == MLX5_NIC_IFC_DISABLED)\r\nreturn 1;\r\nif (ioread32be(&h->fw_ver) == 0xffffffff)\r\nreturn 1;\r\nreturn 0;\r\n}\r\nvoid mlx5_enter_error_state(struct mlx5_core_dev *dev)\r\n{\r\nif (dev->state == MLX5_DEVICE_STATE_INTERNAL_ERROR)\r\nreturn;\r\nmlx5_core_err(dev, "start\n");\r\nif (pci_channel_offline(dev->pdev) || in_fatal(dev))\r\ndev->state = MLX5_DEVICE_STATE_INTERNAL_ERROR;\r\nmlx5_core_event(dev, MLX5_DEV_EVENT_SYS_ERROR, 0);\r\nmlx5_core_err(dev, "end\n");\r\n}\r\nstatic void mlx5_handle_bad_state(struct mlx5_core_dev *dev)\r\n{\r\nu8 nic_interface = get_nic_interface(dev);\r\nswitch (nic_interface) {\r\ncase MLX5_NIC_IFC_FULL:\r\nmlx5_core_warn(dev, "Expected to see disabled NIC but it is full driver\n");\r\nbreak;\r\ncase MLX5_NIC_IFC_DISABLED:\r\nmlx5_core_warn(dev, "starting teardown\n");\r\nbreak;\r\ncase MLX5_NIC_IFC_NO_DRAM_NIC:\r\nmlx5_core_warn(dev, "Expected to see disabled NIC but it is no dram nic\n");\r\nbreak;\r\ndefault:\r\nmlx5_core_warn(dev, "Expected to see disabled NIC but it is has invalid value %d\n",\r\nnic_interface);\r\n}\r\nmlx5_disable_device(dev);\r\n}\r\nstatic void health_care(struct work_struct *work)\r\n{\r\nstruct mlx5_core_health *health;\r\nstruct mlx5_core_dev *dev;\r\nstruct mlx5_priv *priv;\r\nhealth = container_of(work, struct mlx5_core_health, work);\r\npriv = container_of(health, struct mlx5_priv, health);\r\ndev = container_of(priv, struct mlx5_core_dev, priv);\r\nmlx5_core_warn(dev, "handling bad device here\n");\r\nmlx5_handle_bad_state(dev);\r\n}\r\nstatic const char *hsynd_str(u8 synd)\r\n{\r\nswitch (synd) {\r\ncase MLX5_HEALTH_SYNDR_FW_ERR:\r\nreturn "firmware internal error";\r\ncase MLX5_HEALTH_SYNDR_IRISC_ERR:\r\nreturn "irisc not responding";\r\ncase MLX5_HEALTH_SYNDR_HW_UNRECOVERABLE_ERR:\r\nreturn "unrecoverable hardware error";\r\ncase MLX5_HEALTH_SYNDR_CRC_ERR:\r\nreturn "firmware CRC error";\r\ncase MLX5_HEALTH_SYNDR_FETCH_PCI_ERR:\r\nreturn "ICM fetch PCI error";\r\ncase MLX5_HEALTH_SYNDR_HW_FTL_ERR:\r\nreturn "HW fatal error\n";\r\ncase MLX5_HEALTH_SYNDR_ASYNC_EQ_OVERRUN_ERR:\r\nreturn "async EQ buffer overrun";\r\ncase MLX5_HEALTH_SYNDR_EQ_ERR:\r\nreturn "EQ error";\r\ncase MLX5_HEALTH_SYNDR_EQ_INV:\r\nreturn "Invalid EQ refrenced";\r\ncase MLX5_HEALTH_SYNDR_FFSER_ERR:\r\nreturn "FFSER error";\r\ncase MLX5_HEALTH_SYNDR_HIGH_TEMP:\r\nreturn "High temprature";\r\ndefault:\r\nreturn "unrecognized error";\r\n}\r\n}\r\nstatic u16 get_maj(u32 fw)\r\n{\r\nreturn fw >> 28;\r\n}\r\nstatic u16 get_min(u32 fw)\r\n{\r\nreturn fw >> 16 & 0xfff;\r\n}\r\nstatic u16 get_sub(u32 fw)\r\n{\r\nreturn fw & 0xffff;\r\n}\r\nstatic void print_health_info(struct mlx5_core_dev *dev)\r\n{\r\nstruct mlx5_core_health *health = &dev->priv.health;\r\nstruct health_buffer __iomem *h = health->health;\r\nchar fw_str[18];\r\nu32 fw;\r\nint i;\r\nif (!ioread8(&h->synd))\r\nreturn;\r\nfor (i = 0; i < ARRAY_SIZE(h->assert_var); i++)\r\ndev_err(&dev->pdev->dev, "assert_var[%d] 0x%08x\n", i, ioread32be(h->assert_var + i));\r\ndev_err(&dev->pdev->dev, "assert_exit_ptr 0x%08x\n", ioread32be(&h->assert_exit_ptr));\r\ndev_err(&dev->pdev->dev, "assert_callra 0x%08x\n", ioread32be(&h->assert_callra));\r\nfw = ioread32be(&h->fw_ver);\r\nsprintf(fw_str, "%d.%d.%d", get_maj(fw), get_min(fw), get_sub(fw));\r\ndev_err(&dev->pdev->dev, "fw_ver %s\n", fw_str);\r\ndev_err(&dev->pdev->dev, "hw_id 0x%08x\n", ioread32be(&h->hw_id));\r\ndev_err(&dev->pdev->dev, "irisc_index %d\n", ioread8(&h->irisc_index));\r\ndev_err(&dev->pdev->dev, "synd 0x%x: %s\n", ioread8(&h->synd), hsynd_str(ioread8(&h->synd)));\r\ndev_err(&dev->pdev->dev, "ext_synd 0x%04x\n", ioread16be(&h->ext_synd));\r\n}\r\nstatic unsigned long get_next_poll_jiffies(void)\r\n{\r\nunsigned long next;\r\nget_random_bytes(&next, sizeof(next));\r\nnext %= HZ;\r\nnext += jiffies + MLX5_HEALTH_POLL_INTERVAL;\r\nreturn next;\r\n}\r\nstatic void poll_health(unsigned long data)\r\n{\r\nstruct mlx5_core_dev *dev = (struct mlx5_core_dev *)data;\r\nstruct mlx5_core_health *health = &dev->priv.health;\r\nu32 count;\r\nif (dev->state == MLX5_DEVICE_STATE_INTERNAL_ERROR) {\r\ntrigger_cmd_completions(dev);\r\nmod_timer(&health->timer, get_next_poll_jiffies());\r\nreturn;\r\n}\r\ncount = ioread32be(health->health_counter);\r\nif (count == health->prev)\r\n++health->miss_counter;\r\nelse\r\nhealth->miss_counter = 0;\r\nhealth->prev = count;\r\nif (health->miss_counter == MAX_MISSES) {\r\ndev_err(&dev->pdev->dev, "device's health compromised - reached miss count\n");\r\nprint_health_info(dev);\r\n} else {\r\nmod_timer(&health->timer, get_next_poll_jiffies());\r\n}\r\nif (in_fatal(dev) && !health->sick) {\r\nhealth->sick = true;\r\nprint_health_info(dev);\r\nqueue_work(health->wq, &health->work);\r\n}\r\n}\r\nvoid mlx5_start_health_poll(struct mlx5_core_dev *dev)\r\n{\r\nstruct mlx5_core_health *health = &dev->priv.health;\r\ninit_timer(&health->timer);\r\nhealth->health = &dev->iseg->health;\r\nhealth->health_counter = &dev->iseg->health_counter;\r\nhealth->timer.data = (unsigned long)dev;\r\nhealth->timer.function = poll_health;\r\nhealth->timer.expires = round_jiffies(jiffies + MLX5_HEALTH_POLL_INTERVAL);\r\nadd_timer(&health->timer);\r\n}\r\nvoid mlx5_stop_health_poll(struct mlx5_core_dev *dev)\r\n{\r\nstruct mlx5_core_health *health = &dev->priv.health;\r\ndel_timer_sync(&health->timer);\r\n}\r\nvoid mlx5_health_cleanup(struct mlx5_core_dev *dev)\r\n{\r\nstruct mlx5_core_health *health = &dev->priv.health;\r\ndestroy_workqueue(health->wq);\r\n}\r\nint mlx5_health_init(struct mlx5_core_dev *dev)\r\n{\r\nstruct mlx5_core_health *health;\r\nchar *name;\r\nhealth = &dev->priv.health;\r\nname = kmalloc(64, GFP_KERNEL);\r\nif (!name)\r\nreturn -ENOMEM;\r\nstrcpy(name, "mlx5_health");\r\nstrcat(name, dev_name(&dev->pdev->dev));\r\nhealth->wq = create_singlethread_workqueue(name);\r\nkfree(name);\r\nif (!health->wq)\r\nreturn -ENOMEM;\r\nINIT_WORK(&health->work, health_care);\r\nreturn 0;\r\n}
