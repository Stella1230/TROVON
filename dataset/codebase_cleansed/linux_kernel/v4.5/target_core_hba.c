int transport_backend_register(const struct target_backend_ops *ops)\r\n{\r\nstruct target_backend *tb, *old;\r\ntb = kzalloc(sizeof(*tb), GFP_KERNEL);\r\nif (!tb)\r\nreturn -ENOMEM;\r\ntb->ops = ops;\r\nmutex_lock(&backend_mutex);\r\nlist_for_each_entry(old, &backend_list, list) {\r\nif (!strcmp(old->ops->name, ops->name)) {\r\npr_err("backend %s already registered.\n", ops->name);\r\nmutex_unlock(&backend_mutex);\r\nkfree(tb);\r\nreturn -EEXIST;\r\n}\r\n}\r\ntarget_setup_backend_cits(tb);\r\nlist_add_tail(&tb->list, &backend_list);\r\nmutex_unlock(&backend_mutex);\r\npr_debug("TCM: Registered subsystem plugin: %s struct module: %p\n",\r\nops->name, ops->owner);\r\nreturn 0;\r\n}\r\nvoid target_backend_unregister(const struct target_backend_ops *ops)\r\n{\r\nstruct target_backend *tb;\r\nmutex_lock(&backend_mutex);\r\nlist_for_each_entry(tb, &backend_list, list) {\r\nif (tb->ops == ops) {\r\nlist_del(&tb->list);\r\nmutex_unlock(&backend_mutex);\r\nrcu_barrier();\r\nkfree(tb);\r\nreturn;\r\n}\r\n}\r\nmutex_unlock(&backend_mutex);\r\n}\r\nstatic struct target_backend *core_get_backend(const char *name)\r\n{\r\nstruct target_backend *tb;\r\nmutex_lock(&backend_mutex);\r\nlist_for_each_entry(tb, &backend_list, list) {\r\nif (!strcmp(tb->ops->name, name))\r\ngoto found;\r\n}\r\nmutex_unlock(&backend_mutex);\r\nreturn NULL;\r\nfound:\r\nif (tb->ops->owner && !try_module_get(tb->ops->owner))\r\ntb = NULL;\r\nmutex_unlock(&backend_mutex);\r\nreturn tb;\r\n}\r\nstruct se_hba *\r\ncore_alloc_hba(const char *plugin_name, u32 plugin_dep_id, u32 hba_flags)\r\n{\r\nstruct se_hba *hba;\r\nint ret = 0;\r\nhba = kzalloc(sizeof(*hba), GFP_KERNEL);\r\nif (!hba) {\r\npr_err("Unable to allocate struct se_hba\n");\r\nreturn ERR_PTR(-ENOMEM);\r\n}\r\nspin_lock_init(&hba->device_lock);\r\nmutex_init(&hba->hba_access_mutex);\r\nhba->hba_index = scsi_get_new_index(SCSI_INST_INDEX);\r\nhba->hba_flags |= hba_flags;\r\nhba->backend = core_get_backend(plugin_name);\r\nif (!hba->backend) {\r\nret = -EINVAL;\r\ngoto out_free_hba;\r\n}\r\nret = hba->backend->ops->attach_hba(hba, plugin_dep_id);\r\nif (ret < 0)\r\ngoto out_module_put;\r\nspin_lock(&hba_lock);\r\nhba->hba_id = hba_id_counter++;\r\nlist_add_tail(&hba->hba_node, &hba_list);\r\nspin_unlock(&hba_lock);\r\npr_debug("CORE_HBA[%d] - Attached HBA to Generic Target"\r\n" Core\n", hba->hba_id);\r\nreturn hba;\r\nout_module_put:\r\nmodule_put(hba->backend->ops->owner);\r\nhba->backend = NULL;\r\nout_free_hba:\r\nkfree(hba);\r\nreturn ERR_PTR(ret);\r\n}\r\nint\r\ncore_delete_hba(struct se_hba *hba)\r\n{\r\nWARN_ON(hba->dev_count);\r\nhba->backend->ops->detach_hba(hba);\r\nspin_lock(&hba_lock);\r\nlist_del(&hba->hba_node);\r\nspin_unlock(&hba_lock);\r\npr_debug("CORE_HBA[%d] - Detached HBA from Generic Target"\r\n" Core\n", hba->hba_id);\r\nmodule_put(hba->backend->ops->owner);\r\nhba->backend = NULL;\r\nkfree(hba);\r\nreturn 0;\r\n}\r\nbool target_sense_desc_format(struct se_device *dev)\r\n{\r\nreturn (dev) ? dev->transport->get_blocks(dev) > U32_MAX : false;\r\n}
