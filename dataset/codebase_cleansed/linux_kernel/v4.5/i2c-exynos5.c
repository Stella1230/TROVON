static inline struct exynos_hsi2c_variant *exynos5_i2c_get_variant\r\n(struct platform_device *pdev)\r\n{\r\nconst struct of_device_id *match;\r\nmatch = of_match_node(exynos5_i2c_match, pdev->dev.of_node);\r\nreturn (struct exynos_hsi2c_variant *)match->data;\r\n}\r\nstatic void exynos5_i2c_clr_pend_irq(struct exynos5_i2c *i2c)\r\n{\r\nwritel(readl(i2c->regs + HSI2C_INT_STATUS),\r\ni2c->regs + HSI2C_INT_STATUS);\r\n}\r\nstatic int exynos5_i2c_set_timing(struct exynos5_i2c *i2c, int mode)\r\n{\r\nu32 i2c_timing_s1;\r\nu32 i2c_timing_s2;\r\nu32 i2c_timing_s3;\r\nu32 i2c_timing_sla;\r\nunsigned int t_start_su, t_start_hd;\r\nunsigned int t_stop_su;\r\nunsigned int t_data_su, t_data_hd;\r\nunsigned int t_scl_l, t_scl_h;\r\nunsigned int t_sr_release;\r\nunsigned int t_ftl_cycle;\r\nunsigned int clkin = clk_get_rate(i2c->clk);\r\nunsigned int div, utemp0 = 0, utemp1 = 0, clk_cycle;\r\nunsigned int op_clk = (mode == HSI2C_HIGH_SPD) ?\r\ni2c->hs_clock : i2c->fs_clock;\r\nt_ftl_cycle = (readl(i2c->regs + HSI2C_CONF) >> 16) & 0x7;\r\nutemp0 = (clkin / op_clk) - 8;\r\nif (i2c->variant->hw == HSI2C_EXYNOS7)\r\nutemp0 -= t_ftl_cycle;\r\nelse\r\nutemp0 -= 2 * t_ftl_cycle;\r\nfor (div = 0; div < 256; div++) {\r\nutemp1 = utemp0 / (div + 1);\r\nif ((utemp1 < 512) && (utemp1 > 4)) {\r\nclk_cycle = utemp1 - 2;\r\nbreak;\r\n} else if (div == 255) {\r\ndev_warn(i2c->dev, "Failed to calculate divisor");\r\nreturn -EINVAL;\r\n}\r\n}\r\nt_scl_l = clk_cycle / 2;\r\nt_scl_h = clk_cycle / 2;\r\nt_start_su = t_scl_l;\r\nt_start_hd = t_scl_l;\r\nt_stop_su = t_scl_l;\r\nt_data_su = t_scl_l / 2;\r\nt_data_hd = t_scl_l / 2;\r\nt_sr_release = clk_cycle;\r\ni2c_timing_s1 = t_start_su << 24 | t_start_hd << 16 | t_stop_su << 8;\r\ni2c_timing_s2 = t_data_su << 24 | t_scl_l << 8 | t_scl_h << 0;\r\ni2c_timing_s3 = div << 16 | t_sr_release << 0;\r\ni2c_timing_sla = t_data_hd << 0;\r\ndev_dbg(i2c->dev, "tSTART_SU: %X, tSTART_HD: %X, tSTOP_SU: %X\n",\r\nt_start_su, t_start_hd, t_stop_su);\r\ndev_dbg(i2c->dev, "tDATA_SU: %X, tSCL_L: %X, tSCL_H: %X\n",\r\nt_data_su, t_scl_l, t_scl_h);\r\ndev_dbg(i2c->dev, "nClkDiv: %X, tSR_RELEASE: %X\n",\r\ndiv, t_sr_release);\r\ndev_dbg(i2c->dev, "tDATA_HD: %X\n", t_data_hd);\r\nif (mode == HSI2C_HIGH_SPD) {\r\nwritel(i2c_timing_s1, i2c->regs + HSI2C_TIMING_HS1);\r\nwritel(i2c_timing_s2, i2c->regs + HSI2C_TIMING_HS2);\r\nwritel(i2c_timing_s3, i2c->regs + HSI2C_TIMING_HS3);\r\n} else {\r\nwritel(i2c_timing_s1, i2c->regs + HSI2C_TIMING_FS1);\r\nwritel(i2c_timing_s2, i2c->regs + HSI2C_TIMING_FS2);\r\nwritel(i2c_timing_s3, i2c->regs + HSI2C_TIMING_FS3);\r\n}\r\nwritel(i2c_timing_sla, i2c->regs + HSI2C_TIMING_SLA);\r\nreturn 0;\r\n}\r\nstatic int exynos5_hsi2c_clock_setup(struct exynos5_i2c *i2c)\r\n{\r\nif (exynos5_i2c_set_timing(i2c, HSI2C_FAST_SPD)) {\r\ndev_err(i2c->dev, "HSI2C FS Clock set up failed\n");\r\nreturn -EINVAL;\r\n}\r\nif (i2c->speed_mode == HSI2C_HIGH_SPD) {\r\nif (exynos5_i2c_set_timing(i2c, HSI2C_HIGH_SPD)) {\r\ndev_err(i2c->dev, "HSI2C HS Clock set up failed\n");\r\nreturn -EINVAL;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic void exynos5_i2c_init(struct exynos5_i2c *i2c)\r\n{\r\nu32 i2c_conf = readl(i2c->regs + HSI2C_CONF);\r\nu32 i2c_timeout = readl(i2c->regs + HSI2C_TIMEOUT);\r\ni2c_timeout &= ~HSI2C_TIMEOUT_EN;\r\nwritel(i2c_timeout, i2c->regs + HSI2C_TIMEOUT);\r\nwritel((HSI2C_FUNC_MODE_I2C | HSI2C_MASTER),\r\ni2c->regs + HSI2C_CTL);\r\nwritel(HSI2C_TRAILING_COUNT, i2c->regs + HSI2C_TRAILIG_CTL);\r\nif (i2c->speed_mode == HSI2C_HIGH_SPD) {\r\nwritel(HSI2C_MASTER_ID(MASTER_ID(i2c->adap.nr)),\r\ni2c->regs + HSI2C_ADDR);\r\ni2c_conf |= HSI2C_HS_MODE;\r\n}\r\nwritel(i2c_conf | HSI2C_AUTO_MODE, i2c->regs + HSI2C_CONF);\r\n}\r\nstatic void exynos5_i2c_reset(struct exynos5_i2c *i2c)\r\n{\r\nu32 i2c_ctl;\r\ni2c_ctl = readl(i2c->regs + HSI2C_CTL);\r\ni2c_ctl |= HSI2C_SW_RST;\r\nwritel(i2c_ctl, i2c->regs + HSI2C_CTL);\r\ni2c_ctl = readl(i2c->regs + HSI2C_CTL);\r\ni2c_ctl &= ~HSI2C_SW_RST;\r\nwritel(i2c_ctl, i2c->regs + HSI2C_CTL);\r\nexynos5_hsi2c_clock_setup(i2c);\r\nexynos5_i2c_init(i2c);\r\n}\r\nstatic irqreturn_t exynos5_i2c_irq(int irqno, void *dev_id)\r\n{\r\nstruct exynos5_i2c *i2c = dev_id;\r\nu32 fifo_level, int_status, fifo_status, trans_status;\r\nunsigned char byte;\r\nint len = 0;\r\ni2c->state = -EINVAL;\r\nspin_lock(&i2c->lock);\r\nint_status = readl(i2c->regs + HSI2C_INT_STATUS);\r\nwritel(int_status, i2c->regs + HSI2C_INT_STATUS);\r\nif (i2c->variant->hw == HSI2C_EXYNOS7) {\r\nif (int_status & HSI2C_INT_TRANS_DONE) {\r\ni2c->trans_done = 1;\r\ni2c->state = 0;\r\n} else if (int_status & HSI2C_INT_TRANS_ABORT) {\r\ndev_dbg(i2c->dev, "Deal with arbitration lose\n");\r\ni2c->state = -EAGAIN;\r\ngoto stop;\r\n} else if (int_status & HSI2C_INT_NO_DEV_ACK) {\r\ndev_dbg(i2c->dev, "No ACK from device\n");\r\ni2c->state = -ENXIO;\r\ngoto stop;\r\n} else if (int_status & HSI2C_INT_NO_DEV) {\r\ndev_dbg(i2c->dev, "No device\n");\r\ni2c->state = -ENXIO;\r\ngoto stop;\r\n} else if (int_status & HSI2C_INT_TIMEOUT) {\r\ndev_dbg(i2c->dev, "Accessing device timed out\n");\r\ni2c->state = -ETIMEDOUT;\r\ngoto stop;\r\n}\r\n} else if (int_status & HSI2C_INT_I2C) {\r\ntrans_status = readl(i2c->regs + HSI2C_TRANS_STATUS);\r\nif (trans_status & HSI2C_NO_DEV_ACK) {\r\ndev_dbg(i2c->dev, "No ACK from device\n");\r\ni2c->state = -ENXIO;\r\ngoto stop;\r\n} else if (trans_status & HSI2C_NO_DEV) {\r\ndev_dbg(i2c->dev, "No device\n");\r\ni2c->state = -ENXIO;\r\ngoto stop;\r\n} else if (trans_status & HSI2C_TRANS_ABORT) {\r\ndev_dbg(i2c->dev, "Deal with arbitration lose\n");\r\ni2c->state = -EAGAIN;\r\ngoto stop;\r\n} else if (trans_status & HSI2C_TIMEOUT_AUTO) {\r\ndev_dbg(i2c->dev, "Accessing device timed out\n");\r\ni2c->state = -ETIMEDOUT;\r\ngoto stop;\r\n} else if (trans_status & HSI2C_TRANS_DONE) {\r\ni2c->trans_done = 1;\r\ni2c->state = 0;\r\n}\r\n}\r\nif ((i2c->msg->flags & I2C_M_RD) && (int_status &\r\n(HSI2C_INT_TRAILING | HSI2C_INT_RX_ALMOSTFULL))) {\r\nfifo_status = readl(i2c->regs + HSI2C_FIFO_STATUS);\r\nfifo_level = HSI2C_RX_FIFO_LVL(fifo_status);\r\nlen = min(fifo_level, i2c->msg->len - i2c->msg_ptr);\r\nwhile (len > 0) {\r\nbyte = (unsigned char)\r\nreadl(i2c->regs + HSI2C_RX_DATA);\r\ni2c->msg->buf[i2c->msg_ptr++] = byte;\r\nlen--;\r\n}\r\ni2c->state = 0;\r\n} else if (int_status & HSI2C_INT_TX_ALMOSTEMPTY) {\r\nfifo_status = readl(i2c->regs + HSI2C_FIFO_STATUS);\r\nfifo_level = HSI2C_TX_FIFO_LVL(fifo_status);\r\nlen = i2c->variant->fifo_depth - fifo_level;\r\nif (len > (i2c->msg->len - i2c->msg_ptr))\r\nlen = i2c->msg->len - i2c->msg_ptr;\r\nwhile (len > 0) {\r\nbyte = i2c->msg->buf[i2c->msg_ptr++];\r\nwritel(byte, i2c->regs + HSI2C_TX_DATA);\r\nlen--;\r\n}\r\ni2c->state = 0;\r\n}\r\nstop:\r\nif ((i2c->trans_done && (i2c->msg->len == i2c->msg_ptr)) ||\r\n(i2c->state < 0)) {\r\nwritel(0, i2c->regs + HSI2C_INT_ENABLE);\r\nexynos5_i2c_clr_pend_irq(i2c);\r\ncomplete(&i2c->msg_complete);\r\n}\r\nspin_unlock(&i2c->lock);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int exynos5_i2c_wait_bus_idle(struct exynos5_i2c *i2c)\r\n{\r\nunsigned long stop_time;\r\nu32 trans_status;\r\nstop_time = jiffies + msecs_to_jiffies(100) + 1;\r\ndo {\r\ntrans_status = readl(i2c->regs + HSI2C_TRANS_STATUS);\r\nif (!(trans_status & HSI2C_MASTER_BUSY))\r\nreturn 0;\r\nusleep_range(50, 200);\r\n} while (time_before(jiffies, stop_time));\r\nreturn -EBUSY;\r\n}\r\nstatic void exynos5_i2c_message_start(struct exynos5_i2c *i2c, int stop)\r\n{\r\nu32 i2c_ctl;\r\nu32 int_en = 0;\r\nu32 i2c_auto_conf = 0;\r\nu32 fifo_ctl;\r\nunsigned long flags;\r\nunsigned short trig_lvl;\r\nif (i2c->variant->hw == HSI2C_EXYNOS7)\r\nint_en |= HSI2C_INT_I2C_TRANS;\r\nelse\r\nint_en |= HSI2C_INT_I2C;\r\ni2c_ctl = readl(i2c->regs + HSI2C_CTL);\r\ni2c_ctl &= ~(HSI2C_TXCHON | HSI2C_RXCHON);\r\nfifo_ctl = HSI2C_RXFIFO_EN | HSI2C_TXFIFO_EN;\r\nif (i2c->msg->flags & I2C_M_RD) {\r\ni2c_ctl |= HSI2C_RXCHON;\r\ni2c_auto_conf |= HSI2C_READ_WRITE;\r\ntrig_lvl = (i2c->msg->len > i2c->variant->fifo_depth) ?\r\n(i2c->variant->fifo_depth * 3 / 4) : i2c->msg->len;\r\nfifo_ctl |= HSI2C_RXFIFO_TRIGGER_LEVEL(trig_lvl);\r\nint_en |= (HSI2C_INT_RX_ALMOSTFULL_EN |\r\nHSI2C_INT_TRAILING_EN);\r\n} else {\r\ni2c_ctl |= HSI2C_TXCHON;\r\ntrig_lvl = (i2c->msg->len > i2c->variant->fifo_depth) ?\r\n(i2c->variant->fifo_depth * 1 / 4) : i2c->msg->len;\r\nfifo_ctl |= HSI2C_TXFIFO_TRIGGER_LEVEL(trig_lvl);\r\nint_en |= HSI2C_INT_TX_ALMOSTEMPTY_EN;\r\n}\r\nwritel(HSI2C_SLV_ADDR_MAS(i2c->msg->addr), i2c->regs + HSI2C_ADDR);\r\nwritel(fifo_ctl, i2c->regs + HSI2C_FIFO_CTL);\r\nwritel(i2c_ctl, i2c->regs + HSI2C_CTL);\r\nspin_lock_irqsave(&i2c->lock, flags);\r\nwritel(int_en, i2c->regs + HSI2C_INT_ENABLE);\r\nif (stop == 1)\r\ni2c_auto_conf |= HSI2C_STOP_AFTER_TRANS;\r\ni2c_auto_conf |= i2c->msg->len;\r\ni2c_auto_conf |= HSI2C_MASTER_RUN;\r\nwritel(i2c_auto_conf, i2c->regs + HSI2C_AUTO_CONF);\r\nspin_unlock_irqrestore(&i2c->lock, flags);\r\n}\r\nstatic int exynos5_i2c_xfer_msg(struct exynos5_i2c *i2c,\r\nstruct i2c_msg *msgs, int stop)\r\n{\r\nunsigned long timeout;\r\nint ret;\r\ni2c->msg = msgs;\r\ni2c->msg_ptr = 0;\r\ni2c->trans_done = 0;\r\nreinit_completion(&i2c->msg_complete);\r\nexynos5_i2c_message_start(i2c, stop);\r\ntimeout = wait_for_completion_timeout(&i2c->msg_complete,\r\nEXYNOS5_I2C_TIMEOUT);\r\nif (timeout == 0)\r\nret = -ETIMEDOUT;\r\nelse\r\nret = i2c->state;\r\nif (ret == 0 && stop)\r\nret = exynos5_i2c_wait_bus_idle(i2c);\r\nif (ret < 0) {\r\nexynos5_i2c_reset(i2c);\r\nif (ret == -ETIMEDOUT)\r\ndev_warn(i2c->dev, "%s timeout\n",\r\n(msgs->flags & I2C_M_RD) ? "rx" : "tx");\r\n}\r\nreturn ret;\r\n}\r\nstatic int exynos5_i2c_xfer(struct i2c_adapter *adap,\r\nstruct i2c_msg *msgs, int num)\r\n{\r\nstruct exynos5_i2c *i2c = adap->algo_data;\r\nint i = 0, ret = 0, stop = 0;\r\nif (i2c->suspended) {\r\ndev_err(i2c->dev, "HS-I2C is not initialized.\n");\r\nreturn -EIO;\r\n}\r\nclk_prepare_enable(i2c->clk);\r\nfor (i = 0; i < num; i++, msgs++) {\r\nstop = (i == num - 1);\r\nret = exynos5_i2c_xfer_msg(i2c, msgs, stop);\r\nif (ret < 0)\r\ngoto out;\r\n}\r\nif (i == num) {\r\nret = num;\r\n} else {\r\nif (i == 1)\r\nret = -EREMOTEIO;\r\nelse\r\nret = i;\r\ndev_warn(i2c->dev, "xfer message failed\n");\r\n}\r\nout:\r\nclk_disable_unprepare(i2c->clk);\r\nreturn ret;\r\n}\r\nstatic u32 exynos5_i2c_func(struct i2c_adapter *adap)\r\n{\r\nreturn I2C_FUNC_I2C | (I2C_FUNC_SMBUS_EMUL & ~I2C_FUNC_SMBUS_QUICK);\r\n}\r\nstatic int exynos5_i2c_probe(struct platform_device *pdev)\r\n{\r\nstruct device_node *np = pdev->dev.of_node;\r\nstruct exynos5_i2c *i2c;\r\nstruct resource *mem;\r\nunsigned int op_clock;\r\nint ret;\r\ni2c = devm_kzalloc(&pdev->dev, sizeof(struct exynos5_i2c), GFP_KERNEL);\r\nif (!i2c)\r\nreturn -ENOMEM;\r\nif (of_property_read_u32(np, "clock-frequency", &op_clock)) {\r\ni2c->speed_mode = HSI2C_FAST_SPD;\r\ni2c->fs_clock = HSI2C_FS_TX_CLOCK;\r\n} else {\r\nif (op_clock >= HSI2C_HS_TX_CLOCK) {\r\ni2c->speed_mode = HSI2C_HIGH_SPD;\r\ni2c->fs_clock = HSI2C_FS_TX_CLOCK;\r\ni2c->hs_clock = op_clock;\r\n} else {\r\ni2c->speed_mode = HSI2C_FAST_SPD;\r\ni2c->fs_clock = op_clock;\r\n}\r\n}\r\nstrlcpy(i2c->adap.name, "exynos5-i2c", sizeof(i2c->adap.name));\r\ni2c->adap.owner = THIS_MODULE;\r\ni2c->adap.algo = &exynos5_i2c_algorithm;\r\ni2c->adap.retries = 3;\r\ni2c->dev = &pdev->dev;\r\ni2c->clk = devm_clk_get(&pdev->dev, "hsi2c");\r\nif (IS_ERR(i2c->clk)) {\r\ndev_err(&pdev->dev, "cannot get clock\n");\r\nreturn -ENOENT;\r\n}\r\nclk_prepare_enable(i2c->clk);\r\nmem = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\ni2c->regs = devm_ioremap_resource(&pdev->dev, mem);\r\nif (IS_ERR(i2c->regs)) {\r\nret = PTR_ERR(i2c->regs);\r\ngoto err_clk;\r\n}\r\ni2c->adap.dev.of_node = np;\r\ni2c->adap.algo_data = i2c;\r\ni2c->adap.dev.parent = &pdev->dev;\r\nexynos5_i2c_clr_pend_irq(i2c);\r\nspin_lock_init(&i2c->lock);\r\ninit_completion(&i2c->msg_complete);\r\ni2c->irq = ret = platform_get_irq(pdev, 0);\r\nif (ret <= 0) {\r\ndev_err(&pdev->dev, "cannot find HS-I2C IRQ\n");\r\nret = -EINVAL;\r\ngoto err_clk;\r\n}\r\nret = devm_request_irq(&pdev->dev, i2c->irq, exynos5_i2c_irq,\r\nIRQF_NO_SUSPEND | IRQF_ONESHOT,\r\ndev_name(&pdev->dev), i2c);\r\nif (ret != 0) {\r\ndev_err(&pdev->dev, "cannot request HS-I2C IRQ %d\n", i2c->irq);\r\ngoto err_clk;\r\n}\r\ni2c->variant = exynos5_i2c_get_variant(pdev);\r\nret = exynos5_hsi2c_clock_setup(i2c);\r\nif (ret)\r\ngoto err_clk;\r\nexynos5_i2c_reset(i2c);\r\nret = i2c_add_adapter(&i2c->adap);\r\nif (ret < 0) {\r\ndev_err(&pdev->dev, "failed to add bus to i2c core\n");\r\ngoto err_clk;\r\n}\r\nplatform_set_drvdata(pdev, i2c);\r\nerr_clk:\r\nclk_disable_unprepare(i2c->clk);\r\nreturn ret;\r\n}\r\nstatic int exynos5_i2c_remove(struct platform_device *pdev)\r\n{\r\nstruct exynos5_i2c *i2c = platform_get_drvdata(pdev);\r\ni2c_del_adapter(&i2c->adap);\r\nreturn 0;\r\n}\r\nstatic int exynos5_i2c_suspend_noirq(struct device *dev)\r\n{\r\nstruct platform_device *pdev = to_platform_device(dev);\r\nstruct exynos5_i2c *i2c = platform_get_drvdata(pdev);\r\ni2c->suspended = 1;\r\nreturn 0;\r\n}\r\nstatic int exynos5_i2c_resume_noirq(struct device *dev)\r\n{\r\nstruct platform_device *pdev = to_platform_device(dev);\r\nstruct exynos5_i2c *i2c = platform_get_drvdata(pdev);\r\nint ret = 0;\r\nclk_prepare_enable(i2c->clk);\r\nret = exynos5_hsi2c_clock_setup(i2c);\r\nif (ret) {\r\nclk_disable_unprepare(i2c->clk);\r\nreturn ret;\r\n}\r\nexynos5_i2c_init(i2c);\r\nclk_disable_unprepare(i2c->clk);\r\ni2c->suspended = 0;\r\nreturn 0;\r\n}
