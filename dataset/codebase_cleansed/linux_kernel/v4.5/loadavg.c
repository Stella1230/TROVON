void get_avenrun(unsigned long *loads, unsigned long offset, int shift)\r\n{\r\nloads[0] = (avenrun[0] + offset) << shift;\r\nloads[1] = (avenrun[1] + offset) << shift;\r\nloads[2] = (avenrun[2] + offset) << shift;\r\n}\r\nlong calc_load_fold_active(struct rq *this_rq)\r\n{\r\nlong nr_active, delta = 0;\r\nnr_active = this_rq->nr_running;\r\nnr_active += (long)this_rq->nr_uninterruptible;\r\nif (nr_active != this_rq->calc_load_active) {\r\ndelta = nr_active - this_rq->calc_load_active;\r\nthis_rq->calc_load_active = nr_active;\r\n}\r\nreturn delta;\r\n}\r\nstatic unsigned long\r\ncalc_load(unsigned long load, unsigned long exp, unsigned long active)\r\n{\r\nload *= exp;\r\nload += active * (FIXED_1 - exp);\r\nload += 1UL << (FSHIFT - 1);\r\nreturn load >> FSHIFT;\r\n}\r\nstatic inline int calc_load_write_idx(void)\r\n{\r\nint idx = calc_load_idx;\r\nsmp_rmb();\r\nif (!time_before(jiffies, calc_load_update))\r\nidx++;\r\nreturn idx & 1;\r\n}\r\nstatic inline int calc_load_read_idx(void)\r\n{\r\nreturn calc_load_idx & 1;\r\n}\r\nvoid calc_load_enter_idle(void)\r\n{\r\nstruct rq *this_rq = this_rq();\r\nlong delta;\r\ndelta = calc_load_fold_active(this_rq);\r\nif (delta) {\r\nint idx = calc_load_write_idx();\r\natomic_long_add(delta, &calc_load_idle[idx]);\r\n}\r\n}\r\nvoid calc_load_exit_idle(void)\r\n{\r\nstruct rq *this_rq = this_rq();\r\nif (time_before(jiffies, this_rq->calc_load_update))\r\nreturn;\r\nthis_rq->calc_load_update = calc_load_update;\r\nif (time_before(jiffies, this_rq->calc_load_update + 10))\r\nthis_rq->calc_load_update += LOAD_FREQ;\r\n}\r\nstatic long calc_load_fold_idle(void)\r\n{\r\nint idx = calc_load_read_idx();\r\nlong delta = 0;\r\nif (atomic_long_read(&calc_load_idle[idx]))\r\ndelta = atomic_long_xchg(&calc_load_idle[idx], 0);\r\nreturn delta;\r\n}\r\nstatic unsigned long\r\nfixed_power_int(unsigned long x, unsigned int frac_bits, unsigned int n)\r\n{\r\nunsigned long result = 1UL << frac_bits;\r\nif (n) {\r\nfor (;;) {\r\nif (n & 1) {\r\nresult *= x;\r\nresult += 1UL << (frac_bits - 1);\r\nresult >>= frac_bits;\r\n}\r\nn >>= 1;\r\nif (!n)\r\nbreak;\r\nx *= x;\r\nx += 1UL << (frac_bits - 1);\r\nx >>= frac_bits;\r\n}\r\n}\r\nreturn result;\r\n}\r\nstatic unsigned long\r\ncalc_load_n(unsigned long load, unsigned long exp,\r\nunsigned long active, unsigned int n)\r\n{\r\nreturn calc_load(load, fixed_power_int(exp, FSHIFT, n), active);\r\n}\r\nstatic void calc_global_nohz(void)\r\n{\r\nlong delta, active, n;\r\nif (!time_before(jiffies, calc_load_update + 10)) {\r\ndelta = jiffies - calc_load_update - 10;\r\nn = 1 + (delta / LOAD_FREQ);\r\nactive = atomic_long_read(&calc_load_tasks);\r\nactive = active > 0 ? active * FIXED_1 : 0;\r\navenrun[0] = calc_load_n(avenrun[0], EXP_1, active, n);\r\navenrun[1] = calc_load_n(avenrun[1], EXP_5, active, n);\r\navenrun[2] = calc_load_n(avenrun[2], EXP_15, active, n);\r\ncalc_load_update += n * LOAD_FREQ;\r\n}\r\nsmp_wmb();\r\ncalc_load_idx++;\r\n}\r\nstatic inline long calc_load_fold_idle(void) { return 0; }\r\nstatic inline void calc_global_nohz(void) { }\r\nvoid calc_global_load(unsigned long ticks)\r\n{\r\nlong active, delta;\r\nif (time_before(jiffies, calc_load_update + 10))\r\nreturn;\r\ndelta = calc_load_fold_idle();\r\nif (delta)\r\natomic_long_add(delta, &calc_load_tasks);\r\nactive = atomic_long_read(&calc_load_tasks);\r\nactive = active > 0 ? active * FIXED_1 : 0;\r\navenrun[0] = calc_load(avenrun[0], EXP_1, active);\r\navenrun[1] = calc_load(avenrun[1], EXP_5, active);\r\navenrun[2] = calc_load(avenrun[2], EXP_15, active);\r\ncalc_load_update += LOAD_FREQ;\r\ncalc_global_nohz();\r\n}\r\nvoid calc_global_load_tick(struct rq *this_rq)\r\n{\r\nlong delta;\r\nif (time_before(jiffies, this_rq->calc_load_update))\r\nreturn;\r\ndelta = calc_load_fold_active(this_rq);\r\nif (delta)\r\natomic_long_add(delta, &calc_load_tasks);\r\nthis_rq->calc_load_update += LOAD_FREQ;\r\n}
