static inline int __fsg_is_set(struct fsg_common *common,\r\nconst char *func, unsigned line)\r\n{\r\nif (common->fsg)\r\nreturn 1;\r\nERROR(common, "common->fsg is NULL in %s at %u\n", func, line);\r\nWARN_ON(1);\r\nreturn 0;\r\n}\r\nstatic inline struct fsg_dev *fsg_from_func(struct usb_function *f)\r\n{\r\nreturn container_of(f, struct fsg_dev, function);\r\n}\r\nstatic int exception_in_progress(struct fsg_common *common)\r\n{\r\nreturn common->state > FSG_STATE_IDLE;\r\n}\r\nstatic void set_bulk_out_req_length(struct fsg_common *common,\r\nstruct fsg_buffhd *bh, unsigned int length)\r\n{\r\nunsigned int rem;\r\nbh->bulk_out_intended_length = length;\r\nrem = length % common->bulk_out_maxpacket;\r\nif (rem > 0)\r\nlength += common->bulk_out_maxpacket - rem;\r\nbh->outreq->length = length;\r\n}\r\nstatic int fsg_set_halt(struct fsg_dev *fsg, struct usb_ep *ep)\r\n{\r\nconst char *name;\r\nif (ep == fsg->bulk_in)\r\nname = "bulk-in";\r\nelse if (ep == fsg->bulk_out)\r\nname = "bulk-out";\r\nelse\r\nname = ep->name;\r\nDBG(fsg, "%s set halt\n", name);\r\nreturn usb_ep_set_halt(ep);\r\n}\r\nstatic void wakeup_thread(struct fsg_common *common)\r\n{\r\nsmp_wmb();\r\ncommon->thread_wakeup_needed = 1;\r\nif (common->thread_task)\r\nwake_up_process(common->thread_task);\r\n}\r\nstatic void raise_exception(struct fsg_common *common, enum fsg_state new_state)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&common->lock, flags);\r\nif (common->state <= new_state) {\r\ncommon->exception_req_tag = common->ep0_req_tag;\r\ncommon->state = new_state;\r\nif (common->thread_task)\r\nsend_sig_info(SIGUSR1, SEND_SIG_FORCED,\r\ncommon->thread_task);\r\n}\r\nspin_unlock_irqrestore(&common->lock, flags);\r\n}\r\nstatic int ep0_queue(struct fsg_common *common)\r\n{\r\nint rc;\r\nrc = usb_ep_queue(common->ep0, common->ep0req, GFP_ATOMIC);\r\ncommon->ep0->driver_data = common;\r\nif (rc != 0 && rc != -ESHUTDOWN) {\r\nWARNING(common, "error in submission: %s --> %d\n",\r\ncommon->ep0->name, rc);\r\n}\r\nreturn rc;\r\n}\r\nstatic void bulk_in_complete(struct usb_ep *ep, struct usb_request *req)\r\n{\r\nstruct fsg_common *common = ep->driver_data;\r\nstruct fsg_buffhd *bh = req->context;\r\nif (req->status || req->actual != req->length)\r\nDBG(common, "%s --> %d, %u/%u\n", __func__,\r\nreq->status, req->actual, req->length);\r\nif (req->status == -ECONNRESET)\r\nusb_ep_fifo_flush(ep);\r\nsmp_wmb();\r\nspin_lock(&common->lock);\r\nbh->inreq_busy = 0;\r\nbh->state = BUF_STATE_EMPTY;\r\nwakeup_thread(common);\r\nspin_unlock(&common->lock);\r\n}\r\nstatic void bulk_out_complete(struct usb_ep *ep, struct usb_request *req)\r\n{\r\nstruct fsg_common *common = ep->driver_data;\r\nstruct fsg_buffhd *bh = req->context;\r\ndump_msg(common, "bulk-out", req->buf, req->actual);\r\nif (req->status || req->actual != bh->bulk_out_intended_length)\r\nDBG(common, "%s --> %d, %u/%u\n", __func__,\r\nreq->status, req->actual, bh->bulk_out_intended_length);\r\nif (req->status == -ECONNRESET)\r\nusb_ep_fifo_flush(ep);\r\nsmp_wmb();\r\nspin_lock(&common->lock);\r\nbh->outreq_busy = 0;\r\nbh->state = BUF_STATE_FULL;\r\nwakeup_thread(common);\r\nspin_unlock(&common->lock);\r\n}\r\nstatic int _fsg_common_get_max_lun(struct fsg_common *common)\r\n{\r\nint i = ARRAY_SIZE(common->luns) - 1;\r\nwhile (i >= 0 && !common->luns[i])\r\n--i;\r\nreturn i;\r\n}\r\nstatic int fsg_setup(struct usb_function *f,\r\nconst struct usb_ctrlrequest *ctrl)\r\n{\r\nstruct fsg_dev *fsg = fsg_from_func(f);\r\nstruct usb_request *req = fsg->common->ep0req;\r\nu16 w_index = le16_to_cpu(ctrl->wIndex);\r\nu16 w_value = le16_to_cpu(ctrl->wValue);\r\nu16 w_length = le16_to_cpu(ctrl->wLength);\r\nif (!fsg_is_set(fsg->common))\r\nreturn -EOPNOTSUPP;\r\n++fsg->common->ep0_req_tag;\r\nreq->context = NULL;\r\nreq->length = 0;\r\ndump_msg(fsg, "ep0-setup", (u8 *) ctrl, sizeof(*ctrl));\r\nswitch (ctrl->bRequest) {\r\ncase US_BULK_RESET_REQUEST:\r\nif (ctrl->bRequestType !=\r\n(USB_DIR_OUT | USB_TYPE_CLASS | USB_RECIP_INTERFACE))\r\nbreak;\r\nif (w_index != fsg->interface_number || w_value != 0 ||\r\nw_length != 0)\r\nreturn -EDOM;\r\nDBG(fsg, "bulk reset request\n");\r\nraise_exception(fsg->common, FSG_STATE_RESET);\r\nreturn USB_GADGET_DELAYED_STATUS;\r\ncase US_BULK_GET_MAX_LUN:\r\nif (ctrl->bRequestType !=\r\n(USB_DIR_IN | USB_TYPE_CLASS | USB_RECIP_INTERFACE))\r\nbreak;\r\nif (w_index != fsg->interface_number || w_value != 0 ||\r\nw_length != 1)\r\nreturn -EDOM;\r\nVDBG(fsg, "get max LUN\n");\r\n*(u8 *)req->buf = _fsg_common_get_max_lun(fsg->common);\r\nreq->length = min((u16)1, w_length);\r\nreturn ep0_queue(fsg->common);\r\n}\r\nVDBG(fsg,\r\n"unknown class-specific control req %02x.%02x v%04x i%04x l%u\n",\r\nctrl->bRequestType, ctrl->bRequest,\r\nle16_to_cpu(ctrl->wValue), w_index, w_length);\r\nreturn -EOPNOTSUPP;\r\n}\r\nstatic void start_transfer(struct fsg_dev *fsg, struct usb_ep *ep,\r\nstruct usb_request *req, int *pbusy,\r\nenum fsg_buffer_state *state)\r\n{\r\nint rc;\r\nif (ep == fsg->bulk_in)\r\ndump_msg(fsg, "bulk-in", req->buf, req->length);\r\nspin_lock_irq(&fsg->common->lock);\r\n*pbusy = 1;\r\n*state = BUF_STATE_BUSY;\r\nspin_unlock_irq(&fsg->common->lock);\r\nrc = usb_ep_queue(ep, req, GFP_KERNEL);\r\nif (rc == 0)\r\nreturn;\r\n*pbusy = 0;\r\n*state = BUF_STATE_EMPTY;\r\nif (rc != -ESHUTDOWN && !(rc == -EOPNOTSUPP && req->length == 0))\r\nWARNING(fsg, "error in submission: %s --> %d\n", ep->name, rc);\r\n}\r\nstatic bool start_in_transfer(struct fsg_common *common, struct fsg_buffhd *bh)\r\n{\r\nif (!fsg_is_set(common))\r\nreturn false;\r\nstart_transfer(common->fsg, common->fsg->bulk_in,\r\nbh->inreq, &bh->inreq_busy, &bh->state);\r\nreturn true;\r\n}\r\nstatic bool start_out_transfer(struct fsg_common *common, struct fsg_buffhd *bh)\r\n{\r\nif (!fsg_is_set(common))\r\nreturn false;\r\nstart_transfer(common->fsg, common->fsg->bulk_out,\r\nbh->outreq, &bh->outreq_busy, &bh->state);\r\nreturn true;\r\n}\r\nstatic int sleep_thread(struct fsg_common *common, bool can_freeze)\r\n{\r\nint rc = 0;\r\nfor (;;) {\r\nif (can_freeze)\r\ntry_to_freeze();\r\nset_current_state(TASK_INTERRUPTIBLE);\r\nif (signal_pending(current)) {\r\nrc = -EINTR;\r\nbreak;\r\n}\r\nif (common->thread_wakeup_needed)\r\nbreak;\r\nschedule();\r\n}\r\n__set_current_state(TASK_RUNNING);\r\ncommon->thread_wakeup_needed = 0;\r\nsmp_rmb();\r\nreturn rc;\r\n}\r\nstatic int do_read(struct fsg_common *common)\r\n{\r\nstruct fsg_lun *curlun = common->curlun;\r\nu32 lba;\r\nstruct fsg_buffhd *bh;\r\nint rc;\r\nu32 amount_left;\r\nloff_t file_offset, file_offset_tmp;\r\nunsigned int amount;\r\nssize_t nread;\r\nif (common->cmnd[0] == READ_6)\r\nlba = get_unaligned_be24(&common->cmnd[1]);\r\nelse {\r\nlba = get_unaligned_be32(&common->cmnd[2]);\r\nif ((common->cmnd[1] & ~0x18) != 0) {\r\ncurlun->sense_data = SS_INVALID_FIELD_IN_CDB;\r\nreturn -EINVAL;\r\n}\r\n}\r\nif (lba >= curlun->num_sectors) {\r\ncurlun->sense_data = SS_LOGICAL_BLOCK_ADDRESS_OUT_OF_RANGE;\r\nreturn -EINVAL;\r\n}\r\nfile_offset = ((loff_t) lba) << curlun->blkbits;\r\namount_left = common->data_size_from_cmnd;\r\nif (unlikely(amount_left == 0))\r\nreturn -EIO;\r\nfor (;;) {\r\namount = min(amount_left, FSG_BUFLEN);\r\namount = min((loff_t)amount,\r\ncurlun->file_length - file_offset);\r\nbh = common->next_buffhd_to_fill;\r\nwhile (bh->state != BUF_STATE_EMPTY) {\r\nrc = sleep_thread(common, false);\r\nif (rc)\r\nreturn rc;\r\n}\r\nif (amount == 0) {\r\ncurlun->sense_data =\r\nSS_LOGICAL_BLOCK_ADDRESS_OUT_OF_RANGE;\r\ncurlun->sense_data_info =\r\nfile_offset >> curlun->blkbits;\r\ncurlun->info_valid = 1;\r\nbh->inreq->length = 0;\r\nbh->state = BUF_STATE_FULL;\r\nbreak;\r\n}\r\nfile_offset_tmp = file_offset;\r\nnread = vfs_read(curlun->filp,\r\n(char __user *)bh->buf,\r\namount, &file_offset_tmp);\r\nVLDBG(curlun, "file read %u @ %llu -> %d\n", amount,\r\n(unsigned long long)file_offset, (int)nread);\r\nif (signal_pending(current))\r\nreturn -EINTR;\r\nif (nread < 0) {\r\nLDBG(curlun, "error in file read: %d\n", (int)nread);\r\nnread = 0;\r\n} else if (nread < amount) {\r\nLDBG(curlun, "partial file read: %d/%u\n",\r\n(int)nread, amount);\r\nnread = round_down(nread, curlun->blksize);\r\n}\r\nfile_offset += nread;\r\namount_left -= nread;\r\ncommon->residue -= nread;\r\nbh->inreq->length = nread;\r\nbh->state = BUF_STATE_FULL;\r\nif (nread < amount) {\r\ncurlun->sense_data = SS_UNRECOVERED_READ_ERROR;\r\ncurlun->sense_data_info =\r\nfile_offset >> curlun->blkbits;\r\ncurlun->info_valid = 1;\r\nbreak;\r\n}\r\nif (amount_left == 0)\r\nbreak;\r\nbh->inreq->zero = 0;\r\nif (!start_in_transfer(common, bh))\r\nreturn -EIO;\r\ncommon->next_buffhd_to_fill = bh->next;\r\n}\r\nreturn -EIO;\r\n}\r\nstatic int do_write(struct fsg_common *common)\r\n{\r\nstruct fsg_lun *curlun = common->curlun;\r\nu32 lba;\r\nstruct fsg_buffhd *bh;\r\nint get_some_more;\r\nu32 amount_left_to_req, amount_left_to_write;\r\nloff_t usb_offset, file_offset, file_offset_tmp;\r\nunsigned int amount;\r\nssize_t nwritten;\r\nint rc;\r\nif (curlun->ro) {\r\ncurlun->sense_data = SS_WRITE_PROTECTED;\r\nreturn -EINVAL;\r\n}\r\nspin_lock(&curlun->filp->f_lock);\r\ncurlun->filp->f_flags &= ~O_SYNC;\r\nspin_unlock(&curlun->filp->f_lock);\r\nif (common->cmnd[0] == WRITE_6)\r\nlba = get_unaligned_be24(&common->cmnd[1]);\r\nelse {\r\nlba = get_unaligned_be32(&common->cmnd[2]);\r\nif (common->cmnd[1] & ~0x18) {\r\ncurlun->sense_data = SS_INVALID_FIELD_IN_CDB;\r\nreturn -EINVAL;\r\n}\r\nif (!curlun->nofua && (common->cmnd[1] & 0x08)) {\r\nspin_lock(&curlun->filp->f_lock);\r\ncurlun->filp->f_flags |= O_SYNC;\r\nspin_unlock(&curlun->filp->f_lock);\r\n}\r\n}\r\nif (lba >= curlun->num_sectors) {\r\ncurlun->sense_data = SS_LOGICAL_BLOCK_ADDRESS_OUT_OF_RANGE;\r\nreturn -EINVAL;\r\n}\r\nget_some_more = 1;\r\nfile_offset = usb_offset = ((loff_t) lba) << curlun->blkbits;\r\namount_left_to_req = common->data_size_from_cmnd;\r\namount_left_to_write = common->data_size_from_cmnd;\r\nwhile (amount_left_to_write > 0) {\r\nbh = common->next_buffhd_to_fill;\r\nif (bh->state == BUF_STATE_EMPTY && get_some_more) {\r\namount = min(amount_left_to_req, FSG_BUFLEN);\r\nif (usb_offset >= curlun->file_length) {\r\nget_some_more = 0;\r\ncurlun->sense_data =\r\nSS_LOGICAL_BLOCK_ADDRESS_OUT_OF_RANGE;\r\ncurlun->sense_data_info =\r\nusb_offset >> curlun->blkbits;\r\ncurlun->info_valid = 1;\r\ncontinue;\r\n}\r\nusb_offset += amount;\r\ncommon->usb_amount_left -= amount;\r\namount_left_to_req -= amount;\r\nif (amount_left_to_req == 0)\r\nget_some_more = 0;\r\nset_bulk_out_req_length(common, bh, amount);\r\nif (!start_out_transfer(common, bh))\r\nreturn -EIO;\r\ncommon->next_buffhd_to_fill = bh->next;\r\ncontinue;\r\n}\r\nbh = common->next_buffhd_to_drain;\r\nif (bh->state == BUF_STATE_EMPTY && !get_some_more)\r\nbreak;\r\nif (bh->state == BUF_STATE_FULL) {\r\nsmp_rmb();\r\ncommon->next_buffhd_to_drain = bh->next;\r\nbh->state = BUF_STATE_EMPTY;\r\nif (bh->outreq->status != 0) {\r\ncurlun->sense_data = SS_COMMUNICATION_FAILURE;\r\ncurlun->sense_data_info =\r\nfile_offset >> curlun->blkbits;\r\ncurlun->info_valid = 1;\r\nbreak;\r\n}\r\namount = bh->outreq->actual;\r\nif (curlun->file_length - file_offset < amount) {\r\nLERROR(curlun,\r\n"write %u @ %llu beyond end %llu\n",\r\namount, (unsigned long long)file_offset,\r\n(unsigned long long)curlun->file_length);\r\namount = curlun->file_length - file_offset;\r\n}\r\namount = min(amount, bh->bulk_out_intended_length);\r\namount = round_down(amount, curlun->blksize);\r\nif (amount == 0)\r\ngoto empty_write;\r\nfile_offset_tmp = file_offset;\r\nnwritten = vfs_write(curlun->filp,\r\n(char __user *)bh->buf,\r\namount, &file_offset_tmp);\r\nVLDBG(curlun, "file write %u @ %llu -> %d\n", amount,\r\n(unsigned long long)file_offset, (int)nwritten);\r\nif (signal_pending(current))\r\nreturn -EINTR;\r\nif (nwritten < 0) {\r\nLDBG(curlun, "error in file write: %d\n",\r\n(int)nwritten);\r\nnwritten = 0;\r\n} else if (nwritten < amount) {\r\nLDBG(curlun, "partial file write: %d/%u\n",\r\n(int)nwritten, amount);\r\nnwritten = round_down(nwritten, curlun->blksize);\r\n}\r\nfile_offset += nwritten;\r\namount_left_to_write -= nwritten;\r\ncommon->residue -= nwritten;\r\nif (nwritten < amount) {\r\ncurlun->sense_data = SS_WRITE_ERROR;\r\ncurlun->sense_data_info =\r\nfile_offset >> curlun->blkbits;\r\ncurlun->info_valid = 1;\r\nbreak;\r\n}\r\nempty_write:\r\nif (bh->outreq->actual < bh->bulk_out_intended_length) {\r\ncommon->short_packet_received = 1;\r\nbreak;\r\n}\r\ncontinue;\r\n}\r\nrc = sleep_thread(common, false);\r\nif (rc)\r\nreturn rc;\r\n}\r\nreturn -EIO;\r\n}\r\nstatic int do_synchronize_cache(struct fsg_common *common)\r\n{\r\nstruct fsg_lun *curlun = common->curlun;\r\nint rc;\r\nrc = fsg_lun_fsync_sub(curlun);\r\nif (rc)\r\ncurlun->sense_data = SS_WRITE_ERROR;\r\nreturn 0;\r\n}\r\nstatic void invalidate_sub(struct fsg_lun *curlun)\r\n{\r\nstruct file *filp = curlun->filp;\r\nstruct inode *inode = file_inode(filp);\r\nunsigned long rc;\r\nrc = invalidate_mapping_pages(inode->i_mapping, 0, -1);\r\nVLDBG(curlun, "invalidate_mapping_pages -> %ld\n", rc);\r\n}\r\nstatic int do_verify(struct fsg_common *common)\r\n{\r\nstruct fsg_lun *curlun = common->curlun;\r\nu32 lba;\r\nu32 verification_length;\r\nstruct fsg_buffhd *bh = common->next_buffhd_to_fill;\r\nloff_t file_offset, file_offset_tmp;\r\nu32 amount_left;\r\nunsigned int amount;\r\nssize_t nread;\r\nlba = get_unaligned_be32(&common->cmnd[2]);\r\nif (lba >= curlun->num_sectors) {\r\ncurlun->sense_data = SS_LOGICAL_BLOCK_ADDRESS_OUT_OF_RANGE;\r\nreturn -EINVAL;\r\n}\r\nif (common->cmnd[1] & ~0x10) {\r\ncurlun->sense_data = SS_INVALID_FIELD_IN_CDB;\r\nreturn -EINVAL;\r\n}\r\nverification_length = get_unaligned_be16(&common->cmnd[7]);\r\nif (unlikely(verification_length == 0))\r\nreturn -EIO;\r\namount_left = verification_length << curlun->blkbits;\r\nfile_offset = ((loff_t) lba) << curlun->blkbits;\r\nfsg_lun_fsync_sub(curlun);\r\nif (signal_pending(current))\r\nreturn -EINTR;\r\ninvalidate_sub(curlun);\r\nif (signal_pending(current))\r\nreturn -EINTR;\r\nwhile (amount_left > 0) {\r\namount = min(amount_left, FSG_BUFLEN);\r\namount = min((loff_t)amount,\r\ncurlun->file_length - file_offset);\r\nif (amount == 0) {\r\ncurlun->sense_data =\r\nSS_LOGICAL_BLOCK_ADDRESS_OUT_OF_RANGE;\r\ncurlun->sense_data_info =\r\nfile_offset >> curlun->blkbits;\r\ncurlun->info_valid = 1;\r\nbreak;\r\n}\r\nfile_offset_tmp = file_offset;\r\nnread = vfs_read(curlun->filp,\r\n(char __user *) bh->buf,\r\namount, &file_offset_tmp);\r\nVLDBG(curlun, "file read %u @ %llu -> %d\n", amount,\r\n(unsigned long long) file_offset,\r\n(int) nread);\r\nif (signal_pending(current))\r\nreturn -EINTR;\r\nif (nread < 0) {\r\nLDBG(curlun, "error in file verify: %d\n", (int)nread);\r\nnread = 0;\r\n} else if (nread < amount) {\r\nLDBG(curlun, "partial file verify: %d/%u\n",\r\n(int)nread, amount);\r\nnread = round_down(nread, curlun->blksize);\r\n}\r\nif (nread == 0) {\r\ncurlun->sense_data = SS_UNRECOVERED_READ_ERROR;\r\ncurlun->sense_data_info =\r\nfile_offset >> curlun->blkbits;\r\ncurlun->info_valid = 1;\r\nbreak;\r\n}\r\nfile_offset += nread;\r\namount_left -= nread;\r\n}\r\nreturn 0;\r\n}\r\nstatic int do_inquiry(struct fsg_common *common, struct fsg_buffhd *bh)\r\n{\r\nstruct fsg_lun *curlun = common->curlun;\r\nu8 *buf = (u8 *) bh->buf;\r\nif (!curlun) {\r\ncommon->bad_lun_okay = 1;\r\nmemset(buf, 0, 36);\r\nbuf[0] = TYPE_NO_LUN;\r\nbuf[4] = 31;\r\nreturn 36;\r\n}\r\nbuf[0] = curlun->cdrom ? TYPE_ROM : TYPE_DISK;\r\nbuf[1] = curlun->removable ? 0x80 : 0;\r\nbuf[2] = 2;\r\nbuf[3] = 2;\r\nbuf[4] = 31;\r\nbuf[5] = 0;\r\nbuf[6] = 0;\r\nbuf[7] = 0;\r\nmemcpy(buf + 8, common->inquiry_string, sizeof common->inquiry_string);\r\nreturn 36;\r\n}\r\nstatic int do_request_sense(struct fsg_common *common, struct fsg_buffhd *bh)\r\n{\r\nstruct fsg_lun *curlun = common->curlun;\r\nu8 *buf = (u8 *) bh->buf;\r\nu32 sd, sdinfo;\r\nint valid;\r\n#if 0\r\nif (curlun && curlun->unit_attention_data != SS_NO_SENSE) {\r\ncurlun->sense_data = curlun->unit_attention_data;\r\ncurlun->unit_attention_data = SS_NO_SENSE;\r\n}\r\n#endif\r\nif (!curlun) {\r\ncommon->bad_lun_okay = 1;\r\nsd = SS_LOGICAL_UNIT_NOT_SUPPORTED;\r\nsdinfo = 0;\r\nvalid = 0;\r\n} else {\r\nsd = curlun->sense_data;\r\nsdinfo = curlun->sense_data_info;\r\nvalid = curlun->info_valid << 7;\r\ncurlun->sense_data = SS_NO_SENSE;\r\ncurlun->sense_data_info = 0;\r\ncurlun->info_valid = 0;\r\n}\r\nmemset(buf, 0, 18);\r\nbuf[0] = valid | 0x70;\r\nbuf[2] = SK(sd);\r\nput_unaligned_be32(sdinfo, &buf[3]);\r\nbuf[7] = 18 - 8;\r\nbuf[12] = ASC(sd);\r\nbuf[13] = ASCQ(sd);\r\nreturn 18;\r\n}\r\nstatic int do_read_capacity(struct fsg_common *common, struct fsg_buffhd *bh)\r\n{\r\nstruct fsg_lun *curlun = common->curlun;\r\nu32 lba = get_unaligned_be32(&common->cmnd[2]);\r\nint pmi = common->cmnd[8];\r\nu8 *buf = (u8 *)bh->buf;\r\nif (pmi > 1 || (pmi == 0 && lba != 0)) {\r\ncurlun->sense_data = SS_INVALID_FIELD_IN_CDB;\r\nreturn -EINVAL;\r\n}\r\nput_unaligned_be32(curlun->num_sectors - 1, &buf[0]);\r\nput_unaligned_be32(curlun->blksize, &buf[4]);\r\nreturn 8;\r\n}\r\nstatic int do_read_header(struct fsg_common *common, struct fsg_buffhd *bh)\r\n{\r\nstruct fsg_lun *curlun = common->curlun;\r\nint msf = common->cmnd[1] & 0x02;\r\nu32 lba = get_unaligned_be32(&common->cmnd[2]);\r\nu8 *buf = (u8 *)bh->buf;\r\nif (common->cmnd[1] & ~0x02) {\r\ncurlun->sense_data = SS_INVALID_FIELD_IN_CDB;\r\nreturn -EINVAL;\r\n}\r\nif (lba >= curlun->num_sectors) {\r\ncurlun->sense_data = SS_LOGICAL_BLOCK_ADDRESS_OUT_OF_RANGE;\r\nreturn -EINVAL;\r\n}\r\nmemset(buf, 0, 8);\r\nbuf[0] = 0x01;\r\nstore_cdrom_address(&buf[4], msf, lba);\r\nreturn 8;\r\n}\r\nstatic int do_read_toc(struct fsg_common *common, struct fsg_buffhd *bh)\r\n{\r\nstruct fsg_lun *curlun = common->curlun;\r\nint msf = common->cmnd[1] & 0x02;\r\nint start_track = common->cmnd[6];\r\nu8 *buf = (u8 *)bh->buf;\r\nif ((common->cmnd[1] & ~0x02) != 0 ||\r\nstart_track > 1) {\r\ncurlun->sense_data = SS_INVALID_FIELD_IN_CDB;\r\nreturn -EINVAL;\r\n}\r\nmemset(buf, 0, 20);\r\nbuf[1] = (20-2);\r\nbuf[2] = 1;\r\nbuf[3] = 1;\r\nbuf[5] = 0x16;\r\nbuf[6] = 0x01;\r\nstore_cdrom_address(&buf[8], msf, 0);\r\nbuf[13] = 0x16;\r\nbuf[14] = 0xAA;\r\nstore_cdrom_address(&buf[16], msf, curlun->num_sectors);\r\nreturn 20;\r\n}\r\nstatic int do_mode_sense(struct fsg_common *common, struct fsg_buffhd *bh)\r\n{\r\nstruct fsg_lun *curlun = common->curlun;\r\nint mscmnd = common->cmnd[0];\r\nu8 *buf = (u8 *) bh->buf;\r\nu8 *buf0 = buf;\r\nint pc, page_code;\r\nint changeable_values, all_pages;\r\nint valid_page = 0;\r\nint len, limit;\r\nif ((common->cmnd[1] & ~0x08) != 0) {\r\ncurlun->sense_data = SS_INVALID_FIELD_IN_CDB;\r\nreturn -EINVAL;\r\n}\r\npc = common->cmnd[2] >> 6;\r\npage_code = common->cmnd[2] & 0x3f;\r\nif (pc == 3) {\r\ncurlun->sense_data = SS_SAVING_PARAMETERS_NOT_SUPPORTED;\r\nreturn -EINVAL;\r\n}\r\nchangeable_values = (pc == 1);\r\nall_pages = (page_code == 0x3f);\r\nmemset(buf, 0, 8);\r\nif (mscmnd == MODE_SENSE) {\r\nbuf[2] = (curlun->ro ? 0x80 : 0x00);\r\nbuf += 4;\r\nlimit = 255;\r\n} else {\r\nbuf[3] = (curlun->ro ? 0x80 : 0x00);\r\nbuf += 8;\r\nlimit = 65535;\r\n}\r\nif (page_code == 0x08 || all_pages) {\r\nvalid_page = 1;\r\nbuf[0] = 0x08;\r\nbuf[1] = 10;\r\nmemset(buf+2, 0, 10);\r\nif (!changeable_values) {\r\nbuf[2] = 0x04;\r\nput_unaligned_be16(0xffff, &buf[4]);\r\nput_unaligned_be16(0xffff, &buf[8]);\r\nput_unaligned_be16(0xffff, &buf[10]);\r\n}\r\nbuf += 12;\r\n}\r\nlen = buf - buf0;\r\nif (!valid_page || len > limit) {\r\ncurlun->sense_data = SS_INVALID_FIELD_IN_CDB;\r\nreturn -EINVAL;\r\n}\r\nif (mscmnd == MODE_SENSE)\r\nbuf0[0] = len - 1;\r\nelse\r\nput_unaligned_be16(len - 2, buf0);\r\nreturn len;\r\n}\r\nstatic int do_start_stop(struct fsg_common *common)\r\n{\r\nstruct fsg_lun *curlun = common->curlun;\r\nint loej, start;\r\nif (!curlun) {\r\nreturn -EINVAL;\r\n} else if (!curlun->removable) {\r\ncurlun->sense_data = SS_INVALID_COMMAND;\r\nreturn -EINVAL;\r\n} else if ((common->cmnd[1] & ~0x01) != 0 ||\r\n(common->cmnd[4] & ~0x03) != 0) {\r\ncurlun->sense_data = SS_INVALID_FIELD_IN_CDB;\r\nreturn -EINVAL;\r\n}\r\nloej = common->cmnd[4] & 0x02;\r\nstart = common->cmnd[4] & 0x01;\r\nif (start) {\r\nif (!fsg_lun_is_open(curlun)) {\r\ncurlun->sense_data = SS_MEDIUM_NOT_PRESENT;\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nif (curlun->prevent_medium_removal) {\r\nLDBG(curlun, "unload attempt prevented\n");\r\ncurlun->sense_data = SS_MEDIUM_REMOVAL_PREVENTED;\r\nreturn -EINVAL;\r\n}\r\nif (!loej)\r\nreturn 0;\r\nup_read(&common->filesem);\r\ndown_write(&common->filesem);\r\nfsg_lun_close(curlun);\r\nup_write(&common->filesem);\r\ndown_read(&common->filesem);\r\nreturn 0;\r\n}\r\nstatic int do_prevent_allow(struct fsg_common *common)\r\n{\r\nstruct fsg_lun *curlun = common->curlun;\r\nint prevent;\r\nif (!common->curlun) {\r\nreturn -EINVAL;\r\n} else if (!common->curlun->removable) {\r\ncommon->curlun->sense_data = SS_INVALID_COMMAND;\r\nreturn -EINVAL;\r\n}\r\nprevent = common->cmnd[4] & 0x01;\r\nif ((common->cmnd[4] & ~0x01) != 0) {\r\ncurlun->sense_data = SS_INVALID_FIELD_IN_CDB;\r\nreturn -EINVAL;\r\n}\r\nif (curlun->prevent_medium_removal && !prevent)\r\nfsg_lun_fsync_sub(curlun);\r\ncurlun->prevent_medium_removal = prevent;\r\nreturn 0;\r\n}\r\nstatic int do_read_format_capacities(struct fsg_common *common,\r\nstruct fsg_buffhd *bh)\r\n{\r\nstruct fsg_lun *curlun = common->curlun;\r\nu8 *buf = (u8 *) bh->buf;\r\nbuf[0] = buf[1] = buf[2] = 0;\r\nbuf[3] = 8;\r\nbuf += 4;\r\nput_unaligned_be32(curlun->num_sectors, &buf[0]);\r\nput_unaligned_be32(curlun->blksize, &buf[4]);\r\nbuf[4] = 0x02;\r\nreturn 12;\r\n}\r\nstatic int do_mode_select(struct fsg_common *common, struct fsg_buffhd *bh)\r\n{\r\nstruct fsg_lun *curlun = common->curlun;\r\nif (curlun)\r\ncurlun->sense_data = SS_INVALID_COMMAND;\r\nreturn -EINVAL;\r\n}\r\nstatic int halt_bulk_in_endpoint(struct fsg_dev *fsg)\r\n{\r\nint rc;\r\nrc = fsg_set_halt(fsg, fsg->bulk_in);\r\nif (rc == -EAGAIN)\r\nVDBG(fsg, "delayed bulk-in endpoint halt\n");\r\nwhile (rc != 0) {\r\nif (rc != -EAGAIN) {\r\nWARNING(fsg, "usb_ep_set_halt -> %d\n", rc);\r\nrc = 0;\r\nbreak;\r\n}\r\nif (msleep_interruptible(100) != 0)\r\nreturn -EINTR;\r\nrc = usb_ep_set_halt(fsg->bulk_in);\r\n}\r\nreturn rc;\r\n}\r\nstatic int wedge_bulk_in_endpoint(struct fsg_dev *fsg)\r\n{\r\nint rc;\r\nDBG(fsg, "bulk-in set wedge\n");\r\nrc = usb_ep_set_wedge(fsg->bulk_in);\r\nif (rc == -EAGAIN)\r\nVDBG(fsg, "delayed bulk-in endpoint wedge\n");\r\nwhile (rc != 0) {\r\nif (rc != -EAGAIN) {\r\nWARNING(fsg, "usb_ep_set_wedge -> %d\n", rc);\r\nrc = 0;\r\nbreak;\r\n}\r\nif (msleep_interruptible(100) != 0)\r\nreturn -EINTR;\r\nrc = usb_ep_set_wedge(fsg->bulk_in);\r\n}\r\nreturn rc;\r\n}\r\nstatic int throw_away_data(struct fsg_common *common)\r\n{\r\nstruct fsg_buffhd *bh;\r\nu32 amount;\r\nint rc;\r\nfor (bh = common->next_buffhd_to_drain;\r\nbh->state != BUF_STATE_EMPTY || common->usb_amount_left > 0;\r\nbh = common->next_buffhd_to_drain) {\r\nif (bh->state == BUF_STATE_FULL) {\r\nsmp_rmb();\r\nbh->state = BUF_STATE_EMPTY;\r\ncommon->next_buffhd_to_drain = bh->next;\r\nif (bh->outreq->actual < bh->bulk_out_intended_length ||\r\nbh->outreq->status != 0) {\r\nraise_exception(common,\r\nFSG_STATE_ABORT_BULK_OUT);\r\nreturn -EINTR;\r\n}\r\ncontinue;\r\n}\r\nbh = common->next_buffhd_to_fill;\r\nif (bh->state == BUF_STATE_EMPTY\r\n&& common->usb_amount_left > 0) {\r\namount = min(common->usb_amount_left, FSG_BUFLEN);\r\nset_bulk_out_req_length(common, bh, amount);\r\nif (!start_out_transfer(common, bh))\r\nreturn -EIO;\r\ncommon->next_buffhd_to_fill = bh->next;\r\ncommon->usb_amount_left -= amount;\r\ncontinue;\r\n}\r\nrc = sleep_thread(common, true);\r\nif (rc)\r\nreturn rc;\r\n}\r\nreturn 0;\r\n}\r\nstatic int finish_reply(struct fsg_common *common)\r\n{\r\nstruct fsg_buffhd *bh = common->next_buffhd_to_fill;\r\nint rc = 0;\r\nswitch (common->data_dir) {\r\ncase DATA_DIR_NONE:\r\nbreak;\r\ncase DATA_DIR_UNKNOWN:\r\nif (!common->can_stall) {\r\n} else if (fsg_is_set(common)) {\r\nfsg_set_halt(common->fsg, common->fsg->bulk_out);\r\nrc = halt_bulk_in_endpoint(common->fsg);\r\n} else {\r\nrc = -EIO;\r\n}\r\nbreak;\r\ncase DATA_DIR_TO_HOST:\r\nif (common->data_size == 0) {\r\n} else if (!fsg_is_set(common)) {\r\nrc = -EIO;\r\n} else if (common->residue == 0) {\r\nbh->inreq->zero = 0;\r\nif (!start_in_transfer(common, bh))\r\nreturn -EIO;\r\ncommon->next_buffhd_to_fill = bh->next;\r\n} else {\r\nbh->inreq->zero = 1;\r\nif (!start_in_transfer(common, bh))\r\nrc = -EIO;\r\ncommon->next_buffhd_to_fill = bh->next;\r\nif (common->can_stall)\r\nrc = halt_bulk_in_endpoint(common->fsg);\r\n}\r\nbreak;\r\ncase DATA_DIR_FROM_HOST:\r\nif (common->residue == 0) {\r\n} else if (common->short_packet_received) {\r\nraise_exception(common, FSG_STATE_ABORT_BULK_OUT);\r\nrc = -EINTR;\r\n#if 0\r\n} else if (common->can_stall) {\r\nif (fsg_is_set(common))\r\nfsg_set_halt(common->fsg,\r\ncommon->fsg->bulk_out);\r\nraise_exception(common, FSG_STATE_ABORT_BULK_OUT);\r\nrc = -EINTR;\r\n#endif\r\n} else {\r\nrc = throw_away_data(common);\r\n}\r\nbreak;\r\n}\r\nreturn rc;\r\n}\r\nstatic int send_status(struct fsg_common *common)\r\n{\r\nstruct fsg_lun *curlun = common->curlun;\r\nstruct fsg_buffhd *bh;\r\nstruct bulk_cs_wrap *csw;\r\nint rc;\r\nu8 status = US_BULK_STAT_OK;\r\nu32 sd, sdinfo = 0;\r\nbh = common->next_buffhd_to_fill;\r\nwhile (bh->state != BUF_STATE_EMPTY) {\r\nrc = sleep_thread(common, true);\r\nif (rc)\r\nreturn rc;\r\n}\r\nif (curlun) {\r\nsd = curlun->sense_data;\r\nsdinfo = curlun->sense_data_info;\r\n} else if (common->bad_lun_okay)\r\nsd = SS_NO_SENSE;\r\nelse\r\nsd = SS_LOGICAL_UNIT_NOT_SUPPORTED;\r\nif (common->phase_error) {\r\nDBG(common, "sending phase-error status\n");\r\nstatus = US_BULK_STAT_PHASE;\r\nsd = SS_INVALID_COMMAND;\r\n} else if (sd != SS_NO_SENSE) {\r\nDBG(common, "sending command-failure status\n");\r\nstatus = US_BULK_STAT_FAIL;\r\nVDBG(common, " sense data: SK x%02x, ASC x%02x, ASCQ x%02x;"\r\n" info x%x\n",\r\nSK(sd), ASC(sd), ASCQ(sd), sdinfo);\r\n}\r\ncsw = (void *)bh->buf;\r\ncsw->Signature = cpu_to_le32(US_BULK_CS_SIGN);\r\ncsw->Tag = common->tag;\r\ncsw->Residue = cpu_to_le32(common->residue);\r\ncsw->Status = status;\r\nbh->inreq->length = US_BULK_CS_WRAP_LEN;\r\nbh->inreq->zero = 0;\r\nif (!start_in_transfer(common, bh))\r\nreturn -EIO;\r\ncommon->next_buffhd_to_fill = bh->next;\r\nreturn 0;\r\n}\r\nstatic int check_command(struct fsg_common *common, int cmnd_size,\r\nenum data_direction data_dir, unsigned int mask,\r\nint needs_medium, const char *name)\r\n{\r\nint i;\r\nunsigned int lun = common->cmnd[1] >> 5;\r\nstatic const char dirletter[4] = {'u', 'o', 'i', 'n'};\r\nchar hdlen[20];\r\nstruct fsg_lun *curlun;\r\nhdlen[0] = 0;\r\nif (common->data_dir != DATA_DIR_UNKNOWN)\r\nsprintf(hdlen, ", H%c=%u", dirletter[(int) common->data_dir],\r\ncommon->data_size);\r\nVDBG(common, "SCSI command: %s; Dc=%d, D%c=%u; Hc=%d%s\n",\r\nname, cmnd_size, dirletter[(int) data_dir],\r\ncommon->data_size_from_cmnd, common->cmnd_size, hdlen);\r\nif (common->data_size_from_cmnd == 0)\r\ndata_dir = DATA_DIR_NONE;\r\nif (common->data_size < common->data_size_from_cmnd) {\r\ncommon->data_size_from_cmnd = common->data_size;\r\ncommon->phase_error = 1;\r\n}\r\ncommon->residue = common->data_size;\r\ncommon->usb_amount_left = common->data_size;\r\nif (common->data_dir != data_dir && common->data_size_from_cmnd > 0) {\r\ncommon->phase_error = 1;\r\nreturn -EINVAL;\r\n}\r\nif (cmnd_size != common->cmnd_size) {\r\nif (cmnd_size <= common->cmnd_size) {\r\nDBG(common, "%s is buggy! Expected length %d "\r\n"but we got %d\n", name,\r\ncmnd_size, common->cmnd_size);\r\ncmnd_size = common->cmnd_size;\r\n} else {\r\ncommon->phase_error = 1;\r\nreturn -EINVAL;\r\n}\r\n}\r\nif (common->lun != lun)\r\nDBG(common, "using LUN %u from CBW, not LUN %u from CDB\n",\r\ncommon->lun, lun);\r\ncurlun = common->curlun;\r\nif (curlun) {\r\nif (common->cmnd[0] != REQUEST_SENSE) {\r\ncurlun->sense_data = SS_NO_SENSE;\r\ncurlun->sense_data_info = 0;\r\ncurlun->info_valid = 0;\r\n}\r\n} else {\r\ncommon->bad_lun_okay = 0;\r\nif (common->cmnd[0] != INQUIRY &&\r\ncommon->cmnd[0] != REQUEST_SENSE) {\r\nDBG(common, "unsupported LUN %u\n", common->lun);\r\nreturn -EINVAL;\r\n}\r\n}\r\nif (curlun && curlun->unit_attention_data != SS_NO_SENSE &&\r\ncommon->cmnd[0] != INQUIRY &&\r\ncommon->cmnd[0] != REQUEST_SENSE) {\r\ncurlun->sense_data = curlun->unit_attention_data;\r\ncurlun->unit_attention_data = SS_NO_SENSE;\r\nreturn -EINVAL;\r\n}\r\ncommon->cmnd[1] &= 0x1f;\r\nfor (i = 1; i < cmnd_size; ++i) {\r\nif (common->cmnd[i] && !(mask & (1 << i))) {\r\nif (curlun)\r\ncurlun->sense_data = SS_INVALID_FIELD_IN_CDB;\r\nreturn -EINVAL;\r\n}\r\n}\r\nif (curlun && !fsg_lun_is_open(curlun) && needs_medium) {\r\ncurlun->sense_data = SS_MEDIUM_NOT_PRESENT;\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int check_command_size_in_blocks(struct fsg_common *common,\r\nint cmnd_size, enum data_direction data_dir,\r\nunsigned int mask, int needs_medium, const char *name)\r\n{\r\nif (common->curlun)\r\ncommon->data_size_from_cmnd <<= common->curlun->blkbits;\r\nreturn check_command(common, cmnd_size, data_dir,\r\nmask, needs_medium, name);\r\n}\r\nstatic int do_scsi_command(struct fsg_common *common)\r\n{\r\nstruct fsg_buffhd *bh;\r\nint rc;\r\nint reply = -EINVAL;\r\nint i;\r\nstatic char unknown[16];\r\ndump_cdb(common);\r\nbh = common->next_buffhd_to_fill;\r\ncommon->next_buffhd_to_drain = bh;\r\nwhile (bh->state != BUF_STATE_EMPTY) {\r\nrc = sleep_thread(common, true);\r\nif (rc)\r\nreturn rc;\r\n}\r\ncommon->phase_error = 0;\r\ncommon->short_packet_received = 0;\r\ndown_read(&common->filesem);\r\nswitch (common->cmnd[0]) {\r\ncase INQUIRY:\r\ncommon->data_size_from_cmnd = common->cmnd[4];\r\nreply = check_command(common, 6, DATA_DIR_TO_HOST,\r\n(1<<4), 0,\r\n"INQUIRY");\r\nif (reply == 0)\r\nreply = do_inquiry(common, bh);\r\nbreak;\r\ncase MODE_SELECT:\r\ncommon->data_size_from_cmnd = common->cmnd[4];\r\nreply = check_command(common, 6, DATA_DIR_FROM_HOST,\r\n(1<<1) | (1<<4), 0,\r\n"MODE SELECT(6)");\r\nif (reply == 0)\r\nreply = do_mode_select(common, bh);\r\nbreak;\r\ncase MODE_SELECT_10:\r\ncommon->data_size_from_cmnd =\r\nget_unaligned_be16(&common->cmnd[7]);\r\nreply = check_command(common, 10, DATA_DIR_FROM_HOST,\r\n(1<<1) | (3<<7), 0,\r\n"MODE SELECT(10)");\r\nif (reply == 0)\r\nreply = do_mode_select(common, bh);\r\nbreak;\r\ncase MODE_SENSE:\r\ncommon->data_size_from_cmnd = common->cmnd[4];\r\nreply = check_command(common, 6, DATA_DIR_TO_HOST,\r\n(1<<1) | (1<<2) | (1<<4), 0,\r\n"MODE SENSE(6)");\r\nif (reply == 0)\r\nreply = do_mode_sense(common, bh);\r\nbreak;\r\ncase MODE_SENSE_10:\r\ncommon->data_size_from_cmnd =\r\nget_unaligned_be16(&common->cmnd[7]);\r\nreply = check_command(common, 10, DATA_DIR_TO_HOST,\r\n(1<<1) | (1<<2) | (3<<7), 0,\r\n"MODE SENSE(10)");\r\nif (reply == 0)\r\nreply = do_mode_sense(common, bh);\r\nbreak;\r\ncase ALLOW_MEDIUM_REMOVAL:\r\ncommon->data_size_from_cmnd = 0;\r\nreply = check_command(common, 6, DATA_DIR_NONE,\r\n(1<<4), 0,\r\n"PREVENT-ALLOW MEDIUM REMOVAL");\r\nif (reply == 0)\r\nreply = do_prevent_allow(common);\r\nbreak;\r\ncase READ_6:\r\ni = common->cmnd[4];\r\ncommon->data_size_from_cmnd = (i == 0) ? 256 : i;\r\nreply = check_command_size_in_blocks(common, 6,\r\nDATA_DIR_TO_HOST,\r\n(7<<1) | (1<<4), 1,\r\n"READ(6)");\r\nif (reply == 0)\r\nreply = do_read(common);\r\nbreak;\r\ncase READ_10:\r\ncommon->data_size_from_cmnd =\r\nget_unaligned_be16(&common->cmnd[7]);\r\nreply = check_command_size_in_blocks(common, 10,\r\nDATA_DIR_TO_HOST,\r\n(1<<1) | (0xf<<2) | (3<<7), 1,\r\n"READ(10)");\r\nif (reply == 0)\r\nreply = do_read(common);\r\nbreak;\r\ncase READ_12:\r\ncommon->data_size_from_cmnd =\r\nget_unaligned_be32(&common->cmnd[6]);\r\nreply = check_command_size_in_blocks(common, 12,\r\nDATA_DIR_TO_HOST,\r\n(1<<1) | (0xf<<2) | (0xf<<6), 1,\r\n"READ(12)");\r\nif (reply == 0)\r\nreply = do_read(common);\r\nbreak;\r\ncase READ_CAPACITY:\r\ncommon->data_size_from_cmnd = 8;\r\nreply = check_command(common, 10, DATA_DIR_TO_HOST,\r\n(0xf<<2) | (1<<8), 1,\r\n"READ CAPACITY");\r\nif (reply == 0)\r\nreply = do_read_capacity(common, bh);\r\nbreak;\r\ncase READ_HEADER:\r\nif (!common->curlun || !common->curlun->cdrom)\r\ngoto unknown_cmnd;\r\ncommon->data_size_from_cmnd =\r\nget_unaligned_be16(&common->cmnd[7]);\r\nreply = check_command(common, 10, DATA_DIR_TO_HOST,\r\n(3<<7) | (0x1f<<1), 1,\r\n"READ HEADER");\r\nif (reply == 0)\r\nreply = do_read_header(common, bh);\r\nbreak;\r\ncase READ_TOC:\r\nif (!common->curlun || !common->curlun->cdrom)\r\ngoto unknown_cmnd;\r\ncommon->data_size_from_cmnd =\r\nget_unaligned_be16(&common->cmnd[7]);\r\nreply = check_command(common, 10, DATA_DIR_TO_HOST,\r\n(7<<6) | (1<<1), 1,\r\n"READ TOC");\r\nif (reply == 0)\r\nreply = do_read_toc(common, bh);\r\nbreak;\r\ncase READ_FORMAT_CAPACITIES:\r\ncommon->data_size_from_cmnd =\r\nget_unaligned_be16(&common->cmnd[7]);\r\nreply = check_command(common, 10, DATA_DIR_TO_HOST,\r\n(3<<7), 1,\r\n"READ FORMAT CAPACITIES");\r\nif (reply == 0)\r\nreply = do_read_format_capacities(common, bh);\r\nbreak;\r\ncase REQUEST_SENSE:\r\ncommon->data_size_from_cmnd = common->cmnd[4];\r\nreply = check_command(common, 6, DATA_DIR_TO_HOST,\r\n(1<<4), 0,\r\n"REQUEST SENSE");\r\nif (reply == 0)\r\nreply = do_request_sense(common, bh);\r\nbreak;\r\ncase START_STOP:\r\ncommon->data_size_from_cmnd = 0;\r\nreply = check_command(common, 6, DATA_DIR_NONE,\r\n(1<<1) | (1<<4), 0,\r\n"START-STOP UNIT");\r\nif (reply == 0)\r\nreply = do_start_stop(common);\r\nbreak;\r\ncase SYNCHRONIZE_CACHE:\r\ncommon->data_size_from_cmnd = 0;\r\nreply = check_command(common, 10, DATA_DIR_NONE,\r\n(0xf<<2) | (3<<7), 1,\r\n"SYNCHRONIZE CACHE");\r\nif (reply == 0)\r\nreply = do_synchronize_cache(common);\r\nbreak;\r\ncase TEST_UNIT_READY:\r\ncommon->data_size_from_cmnd = 0;\r\nreply = check_command(common, 6, DATA_DIR_NONE,\r\n0, 1,\r\n"TEST UNIT READY");\r\nbreak;\r\ncase VERIFY:\r\ncommon->data_size_from_cmnd = 0;\r\nreply = check_command(common, 10, DATA_DIR_NONE,\r\n(1<<1) | (0xf<<2) | (3<<7), 1,\r\n"VERIFY");\r\nif (reply == 0)\r\nreply = do_verify(common);\r\nbreak;\r\ncase WRITE_6:\r\ni = common->cmnd[4];\r\ncommon->data_size_from_cmnd = (i == 0) ? 256 : i;\r\nreply = check_command_size_in_blocks(common, 6,\r\nDATA_DIR_FROM_HOST,\r\n(7<<1) | (1<<4), 1,\r\n"WRITE(6)");\r\nif (reply == 0)\r\nreply = do_write(common);\r\nbreak;\r\ncase WRITE_10:\r\ncommon->data_size_from_cmnd =\r\nget_unaligned_be16(&common->cmnd[7]);\r\nreply = check_command_size_in_blocks(common, 10,\r\nDATA_DIR_FROM_HOST,\r\n(1<<1) | (0xf<<2) | (3<<7), 1,\r\n"WRITE(10)");\r\nif (reply == 0)\r\nreply = do_write(common);\r\nbreak;\r\ncase WRITE_12:\r\ncommon->data_size_from_cmnd =\r\nget_unaligned_be32(&common->cmnd[6]);\r\nreply = check_command_size_in_blocks(common, 12,\r\nDATA_DIR_FROM_HOST,\r\n(1<<1) | (0xf<<2) | (0xf<<6), 1,\r\n"WRITE(12)");\r\nif (reply == 0)\r\nreply = do_write(common);\r\nbreak;\r\ncase FORMAT_UNIT:\r\ncase RELEASE:\r\ncase RESERVE:\r\ncase SEND_DIAGNOSTIC:\r\ndefault:\r\nunknown_cmnd:\r\ncommon->data_size_from_cmnd = 0;\r\nsprintf(unknown, "Unknown x%02x", common->cmnd[0]);\r\nreply = check_command(common, common->cmnd_size,\r\nDATA_DIR_UNKNOWN, ~0, 0, unknown);\r\nif (reply == 0) {\r\ncommon->curlun->sense_data = SS_INVALID_COMMAND;\r\nreply = -EINVAL;\r\n}\r\nbreak;\r\n}\r\nup_read(&common->filesem);\r\nif (reply == -EINTR || signal_pending(current))\r\nreturn -EINTR;\r\nif (reply == -EINVAL)\r\nreply = 0;\r\nif (reply >= 0 && common->data_dir == DATA_DIR_TO_HOST) {\r\nreply = min((u32)reply, common->data_size_from_cmnd);\r\nbh->inreq->length = reply;\r\nbh->state = BUF_STATE_FULL;\r\ncommon->residue -= reply;\r\n}\r\nreturn 0;\r\n}\r\nstatic int received_cbw(struct fsg_dev *fsg, struct fsg_buffhd *bh)\r\n{\r\nstruct usb_request *req = bh->outreq;\r\nstruct bulk_cb_wrap *cbw = req->buf;\r\nstruct fsg_common *common = fsg->common;\r\nif (req->status || test_bit(IGNORE_BULK_OUT, &fsg->atomic_bitflags))\r\nreturn -EINVAL;\r\nif (req->actual != US_BULK_CB_WRAP_LEN ||\r\ncbw->Signature != cpu_to_le32(\r\nUS_BULK_CB_SIGN)) {\r\nDBG(fsg, "invalid CBW: len %u sig 0x%x\n",\r\nreq->actual,\r\nle32_to_cpu(cbw->Signature));\r\nwedge_bulk_in_endpoint(fsg);\r\nset_bit(IGNORE_BULK_OUT, &fsg->atomic_bitflags);\r\nreturn -EINVAL;\r\n}\r\nif (cbw->Lun >= ARRAY_SIZE(common->luns) ||\r\ncbw->Flags & ~US_BULK_FLAG_IN || cbw->Length <= 0 ||\r\ncbw->Length > MAX_COMMAND_SIZE) {\r\nDBG(fsg, "non-meaningful CBW: lun = %u, flags = 0x%x, "\r\n"cmdlen %u\n",\r\ncbw->Lun, cbw->Flags, cbw->Length);\r\nif (common->can_stall) {\r\nfsg_set_halt(fsg, fsg->bulk_out);\r\nhalt_bulk_in_endpoint(fsg);\r\n}\r\nreturn -EINVAL;\r\n}\r\ncommon->cmnd_size = cbw->Length;\r\nmemcpy(common->cmnd, cbw->CDB, common->cmnd_size);\r\nif (cbw->Flags & US_BULK_FLAG_IN)\r\ncommon->data_dir = DATA_DIR_TO_HOST;\r\nelse\r\ncommon->data_dir = DATA_DIR_FROM_HOST;\r\ncommon->data_size = le32_to_cpu(cbw->DataTransferLength);\r\nif (common->data_size == 0)\r\ncommon->data_dir = DATA_DIR_NONE;\r\ncommon->lun = cbw->Lun;\r\nif (common->lun < ARRAY_SIZE(common->luns))\r\ncommon->curlun = common->luns[common->lun];\r\nelse\r\ncommon->curlun = NULL;\r\ncommon->tag = cbw->Tag;\r\nreturn 0;\r\n}\r\nstatic int get_next_command(struct fsg_common *common)\r\n{\r\nstruct fsg_buffhd *bh;\r\nint rc = 0;\r\nbh = common->next_buffhd_to_fill;\r\nwhile (bh->state != BUF_STATE_EMPTY) {\r\nrc = sleep_thread(common, true);\r\nif (rc)\r\nreturn rc;\r\n}\r\nset_bulk_out_req_length(common, bh, US_BULK_CB_WRAP_LEN);\r\nif (!start_out_transfer(common, bh))\r\nreturn -EIO;\r\nwhile (bh->state != BUF_STATE_FULL) {\r\nrc = sleep_thread(common, true);\r\nif (rc)\r\nreturn rc;\r\n}\r\nsmp_rmb();\r\nrc = fsg_is_set(common) ? received_cbw(common->fsg, bh) : -EIO;\r\nbh->state = BUF_STATE_EMPTY;\r\nreturn rc;\r\n}\r\nstatic int alloc_request(struct fsg_common *common, struct usb_ep *ep,\r\nstruct usb_request **preq)\r\n{\r\n*preq = usb_ep_alloc_request(ep, GFP_ATOMIC);\r\nif (*preq)\r\nreturn 0;\r\nERROR(common, "can't allocate request for %s\n", ep->name);\r\nreturn -ENOMEM;\r\n}\r\nstatic int do_set_interface(struct fsg_common *common, struct fsg_dev *new_fsg)\r\n{\r\nstruct fsg_dev *fsg;\r\nint i, rc = 0;\r\nif (common->running)\r\nDBG(common, "reset interface\n");\r\nreset:\r\nif (common->fsg) {\r\nfsg = common->fsg;\r\nfor (i = 0; i < common->fsg_num_buffers; ++i) {\r\nstruct fsg_buffhd *bh = &common->buffhds[i];\r\nif (bh->inreq) {\r\nusb_ep_free_request(fsg->bulk_in, bh->inreq);\r\nbh->inreq = NULL;\r\n}\r\nif (bh->outreq) {\r\nusb_ep_free_request(fsg->bulk_out, bh->outreq);\r\nbh->outreq = NULL;\r\n}\r\n}\r\nif (fsg->bulk_in_enabled) {\r\nusb_ep_disable(fsg->bulk_in);\r\nfsg->bulk_in_enabled = 0;\r\n}\r\nif (fsg->bulk_out_enabled) {\r\nusb_ep_disable(fsg->bulk_out);\r\nfsg->bulk_out_enabled = 0;\r\n}\r\ncommon->fsg = NULL;\r\nwake_up(&common->fsg_wait);\r\n}\r\ncommon->running = 0;\r\nif (!new_fsg || rc)\r\nreturn rc;\r\ncommon->fsg = new_fsg;\r\nfsg = common->fsg;\r\nrc = config_ep_by_speed(common->gadget, &(fsg->function), fsg->bulk_in);\r\nif (rc)\r\ngoto reset;\r\nrc = usb_ep_enable(fsg->bulk_in);\r\nif (rc)\r\ngoto reset;\r\nfsg->bulk_in->driver_data = common;\r\nfsg->bulk_in_enabled = 1;\r\nrc = config_ep_by_speed(common->gadget, &(fsg->function),\r\nfsg->bulk_out);\r\nif (rc)\r\ngoto reset;\r\nrc = usb_ep_enable(fsg->bulk_out);\r\nif (rc)\r\ngoto reset;\r\nfsg->bulk_out->driver_data = common;\r\nfsg->bulk_out_enabled = 1;\r\ncommon->bulk_out_maxpacket = usb_endpoint_maxp(fsg->bulk_out->desc);\r\nclear_bit(IGNORE_BULK_OUT, &fsg->atomic_bitflags);\r\nfor (i = 0; i < common->fsg_num_buffers; ++i) {\r\nstruct fsg_buffhd *bh = &common->buffhds[i];\r\nrc = alloc_request(common, fsg->bulk_in, &bh->inreq);\r\nif (rc)\r\ngoto reset;\r\nrc = alloc_request(common, fsg->bulk_out, &bh->outreq);\r\nif (rc)\r\ngoto reset;\r\nbh->inreq->buf = bh->outreq->buf = bh->buf;\r\nbh->inreq->context = bh->outreq->context = bh;\r\nbh->inreq->complete = bulk_in_complete;\r\nbh->outreq->complete = bulk_out_complete;\r\n}\r\ncommon->running = 1;\r\nfor (i = 0; i < ARRAY_SIZE(common->luns); ++i)\r\nif (common->luns[i])\r\ncommon->luns[i]->unit_attention_data =\r\nSS_RESET_OCCURRED;\r\nreturn rc;\r\n}\r\nstatic int fsg_set_alt(struct usb_function *f, unsigned intf, unsigned alt)\r\n{\r\nstruct fsg_dev *fsg = fsg_from_func(f);\r\nfsg->common->new_fsg = fsg;\r\nraise_exception(fsg->common, FSG_STATE_CONFIG_CHANGE);\r\nreturn USB_GADGET_DELAYED_STATUS;\r\n}\r\nstatic void fsg_disable(struct usb_function *f)\r\n{\r\nstruct fsg_dev *fsg = fsg_from_func(f);\r\nfsg->common->new_fsg = NULL;\r\nraise_exception(fsg->common, FSG_STATE_CONFIG_CHANGE);\r\n}\r\nstatic void handle_exception(struct fsg_common *common)\r\n{\r\nint i;\r\nstruct fsg_buffhd *bh;\r\nenum fsg_state old_state;\r\nstruct fsg_lun *curlun;\r\nunsigned int exception_req_tag;\r\nfor (;;) {\r\nint sig = kernel_dequeue_signal(NULL);\r\nif (!sig)\r\nbreak;\r\nif (sig != SIGUSR1) {\r\nif (common->state < FSG_STATE_EXIT)\r\nDBG(common, "Main thread exiting on signal\n");\r\nraise_exception(common, FSG_STATE_EXIT);\r\n}\r\n}\r\nif (likely(common->fsg)) {\r\nfor (i = 0; i < common->fsg_num_buffers; ++i) {\r\nbh = &common->buffhds[i];\r\nif (bh->inreq_busy)\r\nusb_ep_dequeue(common->fsg->bulk_in, bh->inreq);\r\nif (bh->outreq_busy)\r\nusb_ep_dequeue(common->fsg->bulk_out,\r\nbh->outreq);\r\n}\r\nfor (;;) {\r\nint num_active = 0;\r\nfor (i = 0; i < common->fsg_num_buffers; ++i) {\r\nbh = &common->buffhds[i];\r\nnum_active += bh->inreq_busy + bh->outreq_busy;\r\n}\r\nif (num_active == 0)\r\nbreak;\r\nif (sleep_thread(common, true))\r\nreturn;\r\n}\r\nif (common->fsg->bulk_in_enabled)\r\nusb_ep_fifo_flush(common->fsg->bulk_in);\r\nif (common->fsg->bulk_out_enabled)\r\nusb_ep_fifo_flush(common->fsg->bulk_out);\r\n}\r\nspin_lock_irq(&common->lock);\r\nfor (i = 0; i < common->fsg_num_buffers; ++i) {\r\nbh = &common->buffhds[i];\r\nbh->state = BUF_STATE_EMPTY;\r\n}\r\ncommon->next_buffhd_to_fill = &common->buffhds[0];\r\ncommon->next_buffhd_to_drain = &common->buffhds[0];\r\nexception_req_tag = common->exception_req_tag;\r\nold_state = common->state;\r\nif (old_state == FSG_STATE_ABORT_BULK_OUT)\r\ncommon->state = FSG_STATE_STATUS_PHASE;\r\nelse {\r\nfor (i = 0; i < ARRAY_SIZE(common->luns); ++i) {\r\ncurlun = common->luns[i];\r\nif (!curlun)\r\ncontinue;\r\ncurlun->prevent_medium_removal = 0;\r\ncurlun->sense_data = SS_NO_SENSE;\r\ncurlun->unit_attention_data = SS_NO_SENSE;\r\ncurlun->sense_data_info = 0;\r\ncurlun->info_valid = 0;\r\n}\r\ncommon->state = FSG_STATE_IDLE;\r\n}\r\nspin_unlock_irq(&common->lock);\r\nswitch (old_state) {\r\ncase FSG_STATE_ABORT_BULK_OUT:\r\nsend_status(common);\r\nspin_lock_irq(&common->lock);\r\nif (common->state == FSG_STATE_STATUS_PHASE)\r\ncommon->state = FSG_STATE_IDLE;\r\nspin_unlock_irq(&common->lock);\r\nbreak;\r\ncase FSG_STATE_RESET:\r\nif (!fsg_is_set(common))\r\nbreak;\r\nif (test_and_clear_bit(IGNORE_BULK_OUT,\r\n&common->fsg->atomic_bitflags))\r\nusb_ep_clear_halt(common->fsg->bulk_in);\r\nif (common->ep0_req_tag == exception_req_tag)\r\nep0_queue(common);\r\nbreak;\r\ncase FSG_STATE_CONFIG_CHANGE:\r\ndo_set_interface(common, common->new_fsg);\r\nif (common->new_fsg)\r\nusb_composite_setup_continue(common->cdev);\r\nbreak;\r\ncase FSG_STATE_EXIT:\r\ncase FSG_STATE_TERMINATED:\r\ndo_set_interface(common, NULL);\r\nspin_lock_irq(&common->lock);\r\ncommon->state = FSG_STATE_TERMINATED;\r\nspin_unlock_irq(&common->lock);\r\nbreak;\r\ncase FSG_STATE_INTERFACE_CHANGE:\r\ncase FSG_STATE_DISCONNECT:\r\ncase FSG_STATE_COMMAND_PHASE:\r\ncase FSG_STATE_DATA_PHASE:\r\ncase FSG_STATE_STATUS_PHASE:\r\ncase FSG_STATE_IDLE:\r\nbreak;\r\n}\r\n}\r\nstatic int fsg_main_thread(void *common_)\r\n{\r\nstruct fsg_common *common = common_;\r\nallow_signal(SIGINT);\r\nallow_signal(SIGTERM);\r\nallow_signal(SIGKILL);\r\nallow_signal(SIGUSR1);\r\nset_freezable();\r\nset_fs(get_ds());\r\nwhile (common->state != FSG_STATE_TERMINATED) {\r\nif (exception_in_progress(common) || signal_pending(current)) {\r\nhandle_exception(common);\r\ncontinue;\r\n}\r\nif (!common->running) {\r\nsleep_thread(common, true);\r\ncontinue;\r\n}\r\nif (get_next_command(common))\r\ncontinue;\r\nspin_lock_irq(&common->lock);\r\nif (!exception_in_progress(common))\r\ncommon->state = FSG_STATE_DATA_PHASE;\r\nspin_unlock_irq(&common->lock);\r\nif (do_scsi_command(common) || finish_reply(common))\r\ncontinue;\r\nspin_lock_irq(&common->lock);\r\nif (!exception_in_progress(common))\r\ncommon->state = FSG_STATE_STATUS_PHASE;\r\nspin_unlock_irq(&common->lock);\r\nif (send_status(common))\r\ncontinue;\r\nspin_lock_irq(&common->lock);\r\nif (!exception_in_progress(common))\r\ncommon->state = FSG_STATE_IDLE;\r\nspin_unlock_irq(&common->lock);\r\n}\r\nspin_lock_irq(&common->lock);\r\ncommon->thread_task = NULL;\r\nspin_unlock_irq(&common->lock);\r\nif (!common->ops || !common->ops->thread_exits\r\n|| common->ops->thread_exits(common) < 0) {\r\nint i;\r\ndown_write(&common->filesem);\r\nfor (i = 0; i < ARRAY_SIZE(common->luns); --i) {\r\nstruct fsg_lun *curlun = common->luns[i];\r\nif (!curlun || !fsg_lun_is_open(curlun))\r\ncontinue;\r\nfsg_lun_close(curlun);\r\ncurlun->unit_attention_data = SS_MEDIUM_NOT_PRESENT;\r\n}\r\nup_write(&common->filesem);\r\n}\r\ncomplete_and_exit(&common->thread_notifier, 0);\r\n}\r\nstatic ssize_t ro_show(struct device *dev, struct device_attribute *attr, char *buf)\r\n{\r\nstruct fsg_lun *curlun = fsg_lun_from_dev(dev);\r\nreturn fsg_show_ro(curlun, buf);\r\n}\r\nstatic ssize_t nofua_show(struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct fsg_lun *curlun = fsg_lun_from_dev(dev);\r\nreturn fsg_show_nofua(curlun, buf);\r\n}\r\nstatic ssize_t file_show(struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct fsg_lun *curlun = fsg_lun_from_dev(dev);\r\nstruct rw_semaphore *filesem = dev_get_drvdata(dev);\r\nreturn fsg_show_file(curlun, filesem, buf);\r\n}\r\nstatic ssize_t ro_store(struct device *dev, struct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct fsg_lun *curlun = fsg_lun_from_dev(dev);\r\nstruct rw_semaphore *filesem = dev_get_drvdata(dev);\r\nreturn fsg_store_ro(curlun, filesem, buf, count);\r\n}\r\nstatic ssize_t nofua_store(struct device *dev, struct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct fsg_lun *curlun = fsg_lun_from_dev(dev);\r\nreturn fsg_store_nofua(curlun, buf, count);\r\n}\r\nstatic ssize_t file_store(struct device *dev, struct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct fsg_lun *curlun = fsg_lun_from_dev(dev);\r\nstruct rw_semaphore *filesem = dev_get_drvdata(dev);\r\nreturn fsg_store_file(curlun, filesem, buf, count);\r\n}\r\nstatic void fsg_lun_release(struct device *dev)\r\n{\r\n}\r\nvoid fsg_common_get(struct fsg_common *common)\r\n{\r\nkref_get(&common->ref);\r\n}\r\nvoid fsg_common_put(struct fsg_common *common)\r\n{\r\nkref_put(&common->ref, fsg_common_release);\r\n}\r\nstatic inline int fsg_num_buffers_validate(unsigned int fsg_num_buffers)\r\n{\r\n#define FSG_MAX_NUM_BUFFERS 32\r\nif (fsg_num_buffers >= 2 && fsg_num_buffers <= FSG_MAX_NUM_BUFFERS)\r\nreturn 0;\r\npr_err("fsg_num_buffers %u is out of range (%d to %d)\n",\r\nfsg_num_buffers, 2, FSG_MAX_NUM_BUFFERS);\r\nreturn -EINVAL;\r\n}\r\nstatic struct fsg_common *fsg_common_setup(struct fsg_common *common)\r\n{\r\nif (!common) {\r\ncommon = kzalloc(sizeof(*common), GFP_KERNEL);\r\nif (!common)\r\nreturn ERR_PTR(-ENOMEM);\r\ncommon->free_storage_on_release = 1;\r\n} else {\r\ncommon->free_storage_on_release = 0;\r\n}\r\ninit_rwsem(&common->filesem);\r\nspin_lock_init(&common->lock);\r\nkref_init(&common->ref);\r\ninit_completion(&common->thread_notifier);\r\ninit_waitqueue_head(&common->fsg_wait);\r\ncommon->state = FSG_STATE_TERMINATED;\r\nmemset(common->luns, 0, sizeof(common->luns));\r\nreturn common;\r\n}\r\nvoid fsg_common_set_sysfs(struct fsg_common *common, bool sysfs)\r\n{\r\ncommon->sysfs = sysfs;\r\n}\r\nstatic void _fsg_common_free_buffers(struct fsg_buffhd *buffhds, unsigned n)\r\n{\r\nif (buffhds) {\r\nstruct fsg_buffhd *bh = buffhds;\r\nwhile (n--) {\r\nkfree(bh->buf);\r\n++bh;\r\n}\r\nkfree(buffhds);\r\n}\r\n}\r\nint fsg_common_set_num_buffers(struct fsg_common *common, unsigned int n)\r\n{\r\nstruct fsg_buffhd *bh, *buffhds;\r\nint i, rc;\r\nrc = fsg_num_buffers_validate(n);\r\nif (rc != 0)\r\nreturn rc;\r\nbuffhds = kcalloc(n, sizeof(*buffhds), GFP_KERNEL);\r\nif (!buffhds)\r\nreturn -ENOMEM;\r\nbh = buffhds;\r\ni = n;\r\ngoto buffhds_first_it;\r\ndo {\r\nbh->next = bh + 1;\r\n++bh;\r\nbuffhds_first_it:\r\nbh->buf = kmalloc(FSG_BUFLEN, GFP_KERNEL);\r\nif (unlikely(!bh->buf))\r\ngoto error_release;\r\n} while (--i);\r\nbh->next = buffhds;\r\n_fsg_common_free_buffers(common->buffhds, common->fsg_num_buffers);\r\ncommon->fsg_num_buffers = n;\r\ncommon->buffhds = buffhds;\r\nreturn 0;\r\nerror_release:\r\n_fsg_common_free_buffers(buffhds, n);\r\nreturn -ENOMEM;\r\n}\r\nvoid fsg_common_remove_lun(struct fsg_lun *lun)\r\n{\r\nif (device_is_registered(&lun->dev))\r\ndevice_unregister(&lun->dev);\r\nfsg_lun_close(lun);\r\nkfree(lun);\r\n}\r\nstatic void _fsg_common_remove_luns(struct fsg_common *common, int n)\r\n{\r\nint i;\r\nfor (i = 0; i < n; ++i)\r\nif (common->luns[i]) {\r\nfsg_common_remove_lun(common->luns[i]);\r\ncommon->luns[i] = NULL;\r\n}\r\n}\r\nvoid fsg_common_remove_luns(struct fsg_common *common)\r\n{\r\n_fsg_common_remove_luns(common, ARRAY_SIZE(common->luns));\r\n}\r\nvoid fsg_common_set_ops(struct fsg_common *common,\r\nconst struct fsg_operations *ops)\r\n{\r\ncommon->ops = ops;\r\n}\r\nvoid fsg_common_free_buffers(struct fsg_common *common)\r\n{\r\n_fsg_common_free_buffers(common->buffhds, common->fsg_num_buffers);\r\ncommon->buffhds = NULL;\r\n}\r\nint fsg_common_set_cdev(struct fsg_common *common,\r\nstruct usb_composite_dev *cdev, bool can_stall)\r\n{\r\nstruct usb_string *us;\r\ncommon->gadget = cdev->gadget;\r\ncommon->ep0 = cdev->gadget->ep0;\r\ncommon->ep0req = cdev->req;\r\ncommon->cdev = cdev;\r\nus = usb_gstrings_attach(cdev, fsg_strings_array,\r\nARRAY_SIZE(fsg_strings));\r\nif (IS_ERR(us))\r\nreturn PTR_ERR(us);\r\nfsg_intf_desc.iInterface = us[FSG_STRING_INTERFACE].id;\r\ncommon->can_stall = can_stall &&\r\ngadget_is_stall_supported(common->gadget);\r\nreturn 0;\r\n}\r\nstatic umode_t fsg_lun_dev_is_visible(struct kobject *kobj,\r\nstruct attribute *attr, int idx)\r\n{\r\nstruct device *dev = kobj_to_dev(kobj);\r\nstruct fsg_lun *lun = fsg_lun_from_dev(dev);\r\nif (attr == &dev_attr_ro.attr)\r\nreturn lun->cdrom ? S_IRUGO : (S_IWUSR | S_IRUGO);\r\nif (attr == &dev_attr_file.attr)\r\nreturn lun->removable ? (S_IWUSR | S_IRUGO) : S_IRUGO;\r\nreturn attr->mode;\r\n}\r\nint fsg_common_create_lun(struct fsg_common *common, struct fsg_lun_config *cfg,\r\nunsigned int id, const char *name,\r\nconst char **name_pfx)\r\n{\r\nstruct fsg_lun *lun;\r\nchar *pathbuf, *p;\r\nint rc = -ENOMEM;\r\nif (id >= ARRAY_SIZE(common->luns))\r\nreturn -ENODEV;\r\nif (common->luns[id])\r\nreturn -EBUSY;\r\nif (!cfg->filename && !cfg->removable) {\r\npr_err("no file given for LUN%d\n", id);\r\nreturn -EINVAL;\r\n}\r\nlun = kzalloc(sizeof(*lun), GFP_KERNEL);\r\nif (!lun)\r\nreturn -ENOMEM;\r\nlun->name_pfx = name_pfx;\r\nlun->cdrom = !!cfg->cdrom;\r\nlun->ro = cfg->cdrom || cfg->ro;\r\nlun->initially_ro = lun->ro;\r\nlun->removable = !!cfg->removable;\r\nif (!common->sysfs) {\r\nlun->name = name;\r\n} else {\r\nlun->dev.release = fsg_lun_release;\r\nlun->dev.parent = &common->gadget->dev;\r\nlun->dev.groups = fsg_lun_dev_groups;\r\ndev_set_drvdata(&lun->dev, &common->filesem);\r\ndev_set_name(&lun->dev, "%s", name);\r\nlun->name = dev_name(&lun->dev);\r\nrc = device_register(&lun->dev);\r\nif (rc) {\r\npr_info("failed to register LUN%d: %d\n", id, rc);\r\nput_device(&lun->dev);\r\ngoto error_sysfs;\r\n}\r\n}\r\ncommon->luns[id] = lun;\r\nif (cfg->filename) {\r\nrc = fsg_lun_open(lun, cfg->filename);\r\nif (rc)\r\ngoto error_lun;\r\n}\r\npathbuf = kmalloc(PATH_MAX, GFP_KERNEL);\r\np = "(no medium)";\r\nif (fsg_lun_is_open(lun)) {\r\np = "(error)";\r\nif (pathbuf) {\r\np = file_path(lun->filp, pathbuf, PATH_MAX);\r\nif (IS_ERR(p))\r\np = "(error)";\r\n}\r\n}\r\npr_info("LUN: %s%s%sfile: %s\n",\r\nlun->removable ? "removable " : "",\r\nlun->ro ? "read only " : "",\r\nlun->cdrom ? "CD-ROM " : "",\r\np);\r\nkfree(pathbuf);\r\nreturn 0;\r\nerror_lun:\r\nif (device_is_registered(&lun->dev))\r\ndevice_unregister(&lun->dev);\r\nfsg_lun_close(lun);\r\ncommon->luns[id] = NULL;\r\nerror_sysfs:\r\nkfree(lun);\r\nreturn rc;\r\n}\r\nint fsg_common_create_luns(struct fsg_common *common, struct fsg_config *cfg)\r\n{\r\nchar buf[8];\r\nint i, rc;\r\nfsg_common_remove_luns(common);\r\nfor (i = 0; i < cfg->nluns; ++i) {\r\nsnprintf(buf, sizeof(buf), "lun%d", i);\r\nrc = fsg_common_create_lun(common, &cfg->luns[i], i, buf, NULL);\r\nif (rc)\r\ngoto fail;\r\n}\r\npr_info("Number of LUNs=%d\n", cfg->nluns);\r\nreturn 0;\r\nfail:\r\n_fsg_common_remove_luns(common, i);\r\nreturn rc;\r\n}\r\nvoid fsg_common_set_inquiry_string(struct fsg_common *common, const char *vn,\r\nconst char *pn)\r\n{\r\nint i;\r\ni = get_default_bcdDevice();\r\nsnprintf(common->inquiry_string, sizeof(common->inquiry_string),\r\n"%-8s%-16s%04x", vn ?: "Linux",\r\npn ?: ((*common->luns)->cdrom\r\n? "File-CD Gadget"\r\n: "File-Stor Gadget"),\r\ni);\r\n}\r\nint fsg_common_run_thread(struct fsg_common *common)\r\n{\r\ncommon->state = FSG_STATE_IDLE;\r\ncommon->thread_task =\r\nkthread_create(fsg_main_thread, common, "file-storage");\r\nif (IS_ERR(common->thread_task)) {\r\ncommon->state = FSG_STATE_TERMINATED;\r\nreturn PTR_ERR(common->thread_task);\r\n}\r\nDBG(common, "I/O thread pid: %d\n", task_pid_nr(common->thread_task));\r\nwake_up_process(common->thread_task);\r\nreturn 0;\r\n}\r\nstatic void fsg_common_release(struct kref *ref)\r\n{\r\nstruct fsg_common *common = container_of(ref, struct fsg_common, ref);\r\nint i;\r\nif (common->state != FSG_STATE_TERMINATED) {\r\nraise_exception(common, FSG_STATE_EXIT);\r\nwait_for_completion(&common->thread_notifier);\r\n}\r\nfor (i = 0; i < ARRAY_SIZE(common->luns); ++i) {\r\nstruct fsg_lun *lun = common->luns[i];\r\nif (!lun)\r\ncontinue;\r\nfsg_lun_close(lun);\r\nif (device_is_registered(&lun->dev))\r\ndevice_unregister(&lun->dev);\r\nkfree(lun);\r\n}\r\n_fsg_common_free_buffers(common->buffhds, common->fsg_num_buffers);\r\nif (common->free_storage_on_release)\r\nkfree(common);\r\n}\r\nstatic int fsg_bind(struct usb_configuration *c, struct usb_function *f)\r\n{\r\nstruct fsg_dev *fsg = fsg_from_func(f);\r\nstruct fsg_common *common = fsg->common;\r\nstruct usb_gadget *gadget = c->cdev->gadget;\r\nint i;\r\nstruct usb_ep *ep;\r\nunsigned max_burst;\r\nint ret;\r\nstruct fsg_opts *opts;\r\nret = _fsg_common_get_max_lun(common);\r\nif (ret < 0) {\r\npr_err("There should be at least one LUN.\n");\r\nreturn -EINVAL;\r\n}\r\nopts = fsg_opts_from_func_inst(f->fi);\r\nif (!opts->no_configfs) {\r\nret = fsg_common_set_cdev(fsg->common, c->cdev,\r\nfsg->common->can_stall);\r\nif (ret)\r\nreturn ret;\r\nfsg_common_set_inquiry_string(fsg->common, NULL, NULL);\r\nret = fsg_common_run_thread(fsg->common);\r\nif (ret)\r\nreturn ret;\r\n}\r\nfsg->gadget = gadget;\r\ni = usb_interface_id(c, f);\r\nif (i < 0)\r\ngoto fail;\r\nfsg_intf_desc.bInterfaceNumber = i;\r\nfsg->interface_number = i;\r\nep = usb_ep_autoconfig(gadget, &fsg_fs_bulk_in_desc);\r\nif (!ep)\r\ngoto autoconf_fail;\r\nfsg->bulk_in = ep;\r\nep = usb_ep_autoconfig(gadget, &fsg_fs_bulk_out_desc);\r\nif (!ep)\r\ngoto autoconf_fail;\r\nfsg->bulk_out = ep;\r\nfsg_hs_bulk_in_desc.bEndpointAddress =\r\nfsg_fs_bulk_in_desc.bEndpointAddress;\r\nfsg_hs_bulk_out_desc.bEndpointAddress =\r\nfsg_fs_bulk_out_desc.bEndpointAddress;\r\nmax_burst = min_t(unsigned, FSG_BUFLEN / 1024, 15);\r\nfsg_ss_bulk_in_desc.bEndpointAddress =\r\nfsg_fs_bulk_in_desc.bEndpointAddress;\r\nfsg_ss_bulk_in_comp_desc.bMaxBurst = max_burst;\r\nfsg_ss_bulk_out_desc.bEndpointAddress =\r\nfsg_fs_bulk_out_desc.bEndpointAddress;\r\nfsg_ss_bulk_out_comp_desc.bMaxBurst = max_burst;\r\nret = usb_assign_descriptors(f, fsg_fs_function, fsg_hs_function,\r\nfsg_ss_function);\r\nif (ret)\r\ngoto autoconf_fail;\r\nreturn 0;\r\nautoconf_fail:\r\nERROR(fsg, "unable to autoconfigure all endpoints\n");\r\ni = -ENOTSUPP;\r\nfail:\r\nif (fsg->common->state != FSG_STATE_TERMINATED) {\r\nraise_exception(fsg->common, FSG_STATE_EXIT);\r\nwait_for_completion(&fsg->common->thread_notifier);\r\n}\r\nreturn i;\r\n}\r\nstatic void fsg_unbind(struct usb_configuration *c, struct usb_function *f)\r\n{\r\nstruct fsg_dev *fsg = fsg_from_func(f);\r\nstruct fsg_common *common = fsg->common;\r\nDBG(fsg, "unbind\n");\r\nif (fsg->common->fsg == fsg) {\r\nfsg->common->new_fsg = NULL;\r\nraise_exception(fsg->common, FSG_STATE_CONFIG_CHANGE);\r\nwait_event(common->fsg_wait, common->fsg != fsg);\r\n}\r\nusb_free_all_descriptors(&fsg->function);\r\n}\r\nstatic inline struct fsg_lun_opts *to_fsg_lun_opts(struct config_item *item)\r\n{\r\nreturn container_of(to_config_group(item), struct fsg_lun_opts, group);\r\n}\r\nstatic inline struct fsg_opts *to_fsg_opts(struct config_item *item)\r\n{\r\nreturn container_of(to_config_group(item), struct fsg_opts,\r\nfunc_inst.group);\r\n}\r\nstatic void fsg_lun_attr_release(struct config_item *item)\r\n{\r\nstruct fsg_lun_opts *lun_opts;\r\nlun_opts = to_fsg_lun_opts(item);\r\nkfree(lun_opts);\r\n}\r\nstatic ssize_t fsg_lun_opts_file_show(struct config_item *item, char *page)\r\n{\r\nstruct fsg_lun_opts *opts = to_fsg_lun_opts(item);\r\nstruct fsg_opts *fsg_opts = to_fsg_opts(opts->group.cg_item.ci_parent);\r\nreturn fsg_show_file(opts->lun, &fsg_opts->common->filesem, page);\r\n}\r\nstatic ssize_t fsg_lun_opts_file_store(struct config_item *item,\r\nconst char *page, size_t len)\r\n{\r\nstruct fsg_lun_opts *opts = to_fsg_lun_opts(item);\r\nstruct fsg_opts *fsg_opts = to_fsg_opts(opts->group.cg_item.ci_parent);\r\nreturn fsg_store_file(opts->lun, &fsg_opts->common->filesem, page, len);\r\n}\r\nstatic ssize_t fsg_lun_opts_ro_show(struct config_item *item, char *page)\r\n{\r\nreturn fsg_show_ro(to_fsg_lun_opts(item)->lun, page);\r\n}\r\nstatic ssize_t fsg_lun_opts_ro_store(struct config_item *item,\r\nconst char *page, size_t len)\r\n{\r\nstruct fsg_lun_opts *opts = to_fsg_lun_opts(item);\r\nstruct fsg_opts *fsg_opts = to_fsg_opts(opts->group.cg_item.ci_parent);\r\nreturn fsg_store_ro(opts->lun, &fsg_opts->common->filesem, page, len);\r\n}\r\nstatic ssize_t fsg_lun_opts_removable_show(struct config_item *item,\r\nchar *page)\r\n{\r\nreturn fsg_show_removable(to_fsg_lun_opts(item)->lun, page);\r\n}\r\nstatic ssize_t fsg_lun_opts_removable_store(struct config_item *item,\r\nconst char *page, size_t len)\r\n{\r\nreturn fsg_store_removable(to_fsg_lun_opts(item)->lun, page, len);\r\n}\r\nstatic ssize_t fsg_lun_opts_cdrom_show(struct config_item *item, char *page)\r\n{\r\nreturn fsg_show_cdrom(to_fsg_lun_opts(item)->lun, page);\r\n}\r\nstatic ssize_t fsg_lun_opts_cdrom_store(struct config_item *item,\r\nconst char *page, size_t len)\r\n{\r\nstruct fsg_lun_opts *opts = to_fsg_lun_opts(item);\r\nstruct fsg_opts *fsg_opts = to_fsg_opts(opts->group.cg_item.ci_parent);\r\nreturn fsg_store_cdrom(opts->lun, &fsg_opts->common->filesem, page,\r\nlen);\r\n}\r\nstatic ssize_t fsg_lun_opts_nofua_show(struct config_item *item, char *page)\r\n{\r\nreturn fsg_show_nofua(to_fsg_lun_opts(item)->lun, page);\r\n}\r\nstatic ssize_t fsg_lun_opts_nofua_store(struct config_item *item,\r\nconst char *page, size_t len)\r\n{\r\nreturn fsg_store_nofua(to_fsg_lun_opts(item)->lun, page, len);\r\n}\r\nstatic struct config_group *fsg_lun_make(struct config_group *group,\r\nconst char *name)\r\n{\r\nstruct fsg_lun_opts *opts;\r\nstruct fsg_opts *fsg_opts;\r\nstruct fsg_lun_config config;\r\nchar *num_str;\r\nu8 num;\r\nint ret;\r\nnum_str = strchr(name, '.');\r\nif (!num_str) {\r\npr_err("Unable to locate . in LUN.NUMBER\n");\r\nreturn ERR_PTR(-EINVAL);\r\n}\r\nnum_str++;\r\nret = kstrtou8(num_str, 0, &num);\r\nif (ret)\r\nreturn ERR_PTR(ret);\r\nfsg_opts = to_fsg_opts(&group->cg_item);\r\nif (num >= FSG_MAX_LUNS)\r\nreturn ERR_PTR(-ERANGE);\r\nmutex_lock(&fsg_opts->lock);\r\nif (fsg_opts->refcnt || fsg_opts->common->luns[num]) {\r\nret = -EBUSY;\r\ngoto out;\r\n}\r\nopts = kzalloc(sizeof(*opts), GFP_KERNEL);\r\nif (!opts) {\r\nret = -ENOMEM;\r\ngoto out;\r\n}\r\nmemset(&config, 0, sizeof(config));\r\nconfig.removable = true;\r\nret = fsg_common_create_lun(fsg_opts->common, &config, num, name,\r\n(const char **)&group->cg_item.ci_name);\r\nif (ret) {\r\nkfree(opts);\r\ngoto out;\r\n}\r\nopts->lun = fsg_opts->common->luns[num];\r\nopts->lun_id = num;\r\nmutex_unlock(&fsg_opts->lock);\r\nconfig_group_init_type_name(&opts->group, name, &fsg_lun_type);\r\nreturn &opts->group;\r\nout:\r\nmutex_unlock(&fsg_opts->lock);\r\nreturn ERR_PTR(ret);\r\n}\r\nstatic void fsg_lun_drop(struct config_group *group, struct config_item *item)\r\n{\r\nstruct fsg_lun_opts *lun_opts;\r\nstruct fsg_opts *fsg_opts;\r\nlun_opts = to_fsg_lun_opts(item);\r\nfsg_opts = to_fsg_opts(&group->cg_item);\r\nmutex_lock(&fsg_opts->lock);\r\nif (fsg_opts->refcnt) {\r\nstruct config_item *gadget;\r\ngadget = group->cg_item.ci_parent->ci_parent;\r\nunregister_gadget_item(gadget);\r\n}\r\nfsg_common_remove_lun(lun_opts->lun);\r\nfsg_opts->common->luns[lun_opts->lun_id] = NULL;\r\nlun_opts->lun_id = 0;\r\nmutex_unlock(&fsg_opts->lock);\r\nconfig_item_put(item);\r\n}\r\nstatic void fsg_attr_release(struct config_item *item)\r\n{\r\nstruct fsg_opts *opts = to_fsg_opts(item);\r\nusb_put_function_instance(&opts->func_inst);\r\n}\r\nstatic ssize_t fsg_opts_stall_show(struct config_item *item, char *page)\r\n{\r\nstruct fsg_opts *opts = to_fsg_opts(item);\r\nint result;\r\nmutex_lock(&opts->lock);\r\nresult = sprintf(page, "%d", opts->common->can_stall);\r\nmutex_unlock(&opts->lock);\r\nreturn result;\r\n}\r\nstatic ssize_t fsg_opts_stall_store(struct config_item *item, const char *page,\r\nsize_t len)\r\n{\r\nstruct fsg_opts *opts = to_fsg_opts(item);\r\nint ret;\r\nbool stall;\r\nmutex_lock(&opts->lock);\r\nif (opts->refcnt) {\r\nmutex_unlock(&opts->lock);\r\nreturn -EBUSY;\r\n}\r\nret = strtobool(page, &stall);\r\nif (!ret) {\r\nopts->common->can_stall = stall;\r\nret = len;\r\n}\r\nmutex_unlock(&opts->lock);\r\nreturn ret;\r\n}\r\nstatic ssize_t fsg_opts_num_buffers_show(struct config_item *item, char *page)\r\n{\r\nstruct fsg_opts *opts = to_fsg_opts(item);\r\nint result;\r\nmutex_lock(&opts->lock);\r\nresult = sprintf(page, "%d", opts->common->fsg_num_buffers);\r\nmutex_unlock(&opts->lock);\r\nreturn result;\r\n}\r\nstatic ssize_t fsg_opts_num_buffers_store(struct config_item *item,\r\nconst char *page, size_t len)\r\n{\r\nstruct fsg_opts *opts = to_fsg_opts(item);\r\nint ret;\r\nu8 num;\r\nmutex_lock(&opts->lock);\r\nif (opts->refcnt) {\r\nret = -EBUSY;\r\ngoto end;\r\n}\r\nret = kstrtou8(page, 0, &num);\r\nif (ret)\r\ngoto end;\r\nret = fsg_num_buffers_validate(num);\r\nif (ret)\r\ngoto end;\r\nfsg_common_set_num_buffers(opts->common, num);\r\nret = len;\r\nend:\r\nmutex_unlock(&opts->lock);\r\nreturn ret;\r\n}\r\nstatic void fsg_free_inst(struct usb_function_instance *fi)\r\n{\r\nstruct fsg_opts *opts;\r\nopts = fsg_opts_from_func_inst(fi);\r\nfsg_common_put(opts->common);\r\nkfree(opts);\r\n}\r\nstatic struct usb_function_instance *fsg_alloc_inst(void)\r\n{\r\nstruct fsg_opts *opts;\r\nstruct fsg_lun_config config;\r\nint rc;\r\nopts = kzalloc(sizeof(*opts), GFP_KERNEL);\r\nif (!opts)\r\nreturn ERR_PTR(-ENOMEM);\r\nmutex_init(&opts->lock);\r\nopts->func_inst.free_func_inst = fsg_free_inst;\r\nopts->common = fsg_common_setup(opts->common);\r\nif (IS_ERR(opts->common)) {\r\nrc = PTR_ERR(opts->common);\r\ngoto release_opts;\r\n}\r\nrc = fsg_common_set_num_buffers(opts->common,\r\nCONFIG_USB_GADGET_STORAGE_NUM_BUFFERS);\r\nif (rc)\r\ngoto release_opts;\r\npr_info(FSG_DRIVER_DESC ", version: " FSG_DRIVER_VERSION "\n");\r\nmemset(&config, 0, sizeof(config));\r\nconfig.removable = true;\r\nrc = fsg_common_create_lun(opts->common, &config, 0, "lun.0",\r\n(const char **)&opts->func_inst.group.cg_item.ci_name);\r\nif (rc)\r\ngoto release_buffers;\r\nopts->lun0.lun = opts->common->luns[0];\r\nopts->lun0.lun_id = 0;\r\nconfig_group_init_type_name(&opts->lun0.group, "lun.0", &fsg_lun_type);\r\nopts->default_groups[0] = &opts->lun0.group;\r\nopts->func_inst.group.default_groups = opts->default_groups;\r\nconfig_group_init_type_name(&opts->func_inst.group, "", &fsg_func_type);\r\nreturn &opts->func_inst;\r\nrelease_buffers:\r\nfsg_common_free_buffers(opts->common);\r\nrelease_opts:\r\nkfree(opts);\r\nreturn ERR_PTR(rc);\r\n}\r\nstatic void fsg_free(struct usb_function *f)\r\n{\r\nstruct fsg_dev *fsg;\r\nstruct fsg_opts *opts;\r\nfsg = container_of(f, struct fsg_dev, function);\r\nopts = container_of(f->fi, struct fsg_opts, func_inst);\r\nmutex_lock(&opts->lock);\r\nopts->refcnt--;\r\nmutex_unlock(&opts->lock);\r\nkfree(fsg);\r\n}\r\nstatic struct usb_function *fsg_alloc(struct usb_function_instance *fi)\r\n{\r\nstruct fsg_opts *opts = fsg_opts_from_func_inst(fi);\r\nstruct fsg_common *common = opts->common;\r\nstruct fsg_dev *fsg;\r\nfsg = kzalloc(sizeof(*fsg), GFP_KERNEL);\r\nif (unlikely(!fsg))\r\nreturn ERR_PTR(-ENOMEM);\r\nmutex_lock(&opts->lock);\r\nopts->refcnt++;\r\nmutex_unlock(&opts->lock);\r\nfsg->function.name = FSG_DRIVER_DESC;\r\nfsg->function.bind = fsg_bind;\r\nfsg->function.unbind = fsg_unbind;\r\nfsg->function.setup = fsg_setup;\r\nfsg->function.set_alt = fsg_set_alt;\r\nfsg->function.disable = fsg_disable;\r\nfsg->function.free_func = fsg_free;\r\nfsg->common = common;\r\nreturn &fsg->function;\r\n}\r\nvoid fsg_config_from_params(struct fsg_config *cfg,\r\nconst struct fsg_module_parameters *params,\r\nunsigned int fsg_num_buffers)\r\n{\r\nstruct fsg_lun_config *lun;\r\nunsigned i;\r\ncfg->nluns =\r\nmin(params->luns ?: (params->file_count ?: 1u),\r\n(unsigned)FSG_MAX_LUNS);\r\nfor (i = 0, lun = cfg->luns; i < cfg->nluns; ++i, ++lun) {\r\nlun->ro = !!params->ro[i];\r\nlun->cdrom = !!params->cdrom[i];\r\nlun->removable = !!params->removable[i];\r\nlun->filename =\r\nparams->file_count > i && params->file[i][0]\r\n? params->file[i]\r\n: NULL;\r\n}\r\ncfg->vendor_name = NULL;\r\ncfg->product_name = NULL;\r\ncfg->ops = NULL;\r\ncfg->private_data = NULL;\r\ncfg->can_stall = params->stall;\r\ncfg->fsg_num_buffers = fsg_num_buffers;\r\n}
