static void imx_imx_snvs_check_for_events(unsigned long data)\r\n{\r\nstruct pwrkey_drv_data *pdata = (struct pwrkey_drv_data *) data;\r\nstruct input_dev *input = pdata->input;\r\nu32 state;\r\nregmap_read(pdata->snvs, SNVS_HPSR_REG, &state);\r\nstate = state & SNVS_HPSR_BTN ? 1 : 0;\r\nif (state ^ pdata->keystate) {\r\npdata->keystate = state;\r\ninput_event(input, EV_KEY, pdata->keycode, state);\r\ninput_sync(input);\r\npm_relax(pdata->input->dev.parent);\r\n}\r\nif (state) {\r\nmod_timer(&pdata->check_timer,\r\njiffies + msecs_to_jiffies(REPEAT_INTERVAL));\r\n}\r\n}\r\nstatic irqreturn_t imx_snvs_pwrkey_interrupt(int irq, void *dev_id)\r\n{\r\nstruct platform_device *pdev = dev_id;\r\nstruct pwrkey_drv_data *pdata = platform_get_drvdata(pdev);\r\nu32 lp_status;\r\npm_wakeup_event(pdata->input->dev.parent, 0);\r\nregmap_read(pdata->snvs, SNVS_LPSR_REG, &lp_status);\r\nif (lp_status & SNVS_LPSR_SPO)\r\nmod_timer(&pdata->check_timer, jiffies + msecs_to_jiffies(DEBOUNCE_TIME));\r\nregmap_write(pdata->snvs, SNVS_LPSR_REG, SNVS_LPSR_SPO);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void imx_snvs_pwrkey_act(void *pdata)\r\n{\r\nstruct pwrkey_drv_data *pd = pdata;\r\ndel_timer_sync(&pd->check_timer);\r\n}\r\nstatic int imx_snvs_pwrkey_probe(struct platform_device *pdev)\r\n{\r\nstruct pwrkey_drv_data *pdata = NULL;\r\nstruct input_dev *input = NULL;\r\nstruct device_node *np;\r\nint error;\r\nnp = pdev->dev.of_node;\r\nif (!np)\r\nreturn -ENODEV;\r\npdata = devm_kzalloc(&pdev->dev, sizeof(*pdata), GFP_KERNEL);\r\nif (!pdata)\r\nreturn -ENOMEM;\r\npdata->snvs = syscon_regmap_lookup_by_phandle(np, "regmap");\r\nif (!pdata->snvs) {\r\ndev_err(&pdev->dev, "Can't get snvs syscon\n");\r\nreturn -ENODEV;\r\n}\r\nif (of_property_read_u32(np, "linux,keycode", &pdata->keycode)) {\r\npdata->keycode = KEY_POWER;\r\ndev_warn(&pdev->dev, "KEY_POWER without setting in dts\n");\r\n}\r\npdata->wakeup = of_property_read_bool(np, "wakeup-source");\r\npdata->irq = platform_get_irq(pdev, 0);\r\nif (pdata->irq < 0) {\r\ndev_err(&pdev->dev, "no irq defined in platform data\n");\r\nreturn -EINVAL;\r\n}\r\nregmap_update_bits(pdata->snvs, SNVS_LPCR_REG, SNVS_LPCR_DEP_EN, SNVS_LPCR_DEP_EN);\r\nregmap_write(pdata->snvs, SNVS_LPSR_REG, SNVS_LPSR_SPO);\r\nsetup_timer(&pdata->check_timer,\r\nimx_imx_snvs_check_for_events, (unsigned long) pdata);\r\ninput = devm_input_allocate_device(&pdev->dev);\r\nif (!input) {\r\ndev_err(&pdev->dev, "failed to allocate the input device\n");\r\nreturn -ENOMEM;\r\n}\r\ninput->name = pdev->name;\r\ninput->phys = "snvs-pwrkey/input0";\r\ninput->id.bustype = BUS_HOST;\r\ninput_set_capability(input, EV_KEY, pdata->keycode);\r\nerror = devm_add_action(&pdev->dev, imx_snvs_pwrkey_act, pdata);\r\nif (error) {\r\ndev_err(&pdev->dev, "failed to register remove action\n");\r\nreturn error;\r\n}\r\nerror = devm_request_irq(&pdev->dev, pdata->irq,\r\nimx_snvs_pwrkey_interrupt,\r\n0, pdev->name, pdev);\r\nif (error) {\r\ndev_err(&pdev->dev, "interrupt not available.\n");\r\nreturn error;\r\n}\r\nerror = input_register_device(input);\r\nif (error < 0) {\r\ndev_err(&pdev->dev, "failed to register input device\n");\r\ninput_free_device(input);\r\nreturn error;\r\n}\r\npdata->input = input;\r\nplatform_set_drvdata(pdev, pdata);\r\ndevice_init_wakeup(&pdev->dev, pdata->wakeup);\r\nreturn 0;\r\n}\r\nstatic int imx_snvs_pwrkey_suspend(struct device *dev)\r\n{\r\nstruct platform_device *pdev = to_platform_device(dev);\r\nstruct pwrkey_drv_data *pdata = platform_get_drvdata(pdev);\r\nif (device_may_wakeup(&pdev->dev))\r\nenable_irq_wake(pdata->irq);\r\nreturn 0;\r\n}\r\nstatic int imx_snvs_pwrkey_resume(struct device *dev)\r\n{\r\nstruct platform_device *pdev = to_platform_device(dev);\r\nstruct pwrkey_drv_data *pdata = platform_get_drvdata(pdev);\r\nif (device_may_wakeup(&pdev->dev))\r\ndisable_irq_wake(pdata->irq);\r\nreturn 0;\r\n}
