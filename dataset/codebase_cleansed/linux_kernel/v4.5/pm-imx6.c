void imx6q_set_int_mem_clk_lpm(bool enable)\r\n{\r\nu32 val = readl_relaxed(ccm_base + CGPR);\r\nval &= ~BM_CGPR_INT_MEM_CLK_LPM;\r\nif (enable)\r\nval |= BM_CGPR_INT_MEM_CLK_LPM;\r\nwritel_relaxed(val, ccm_base + CGPR);\r\n}\r\nvoid imx6_enable_rbc(bool enable)\r\n{\r\nu32 val;\r\nimx_gpc_mask_all();\r\nval = readl_relaxed(ccm_base + CCR);\r\nval &= ~BM_CCR_RBC_EN;\r\nval |= enable ? BM_CCR_RBC_EN : 0;\r\nwritel_relaxed(val, ccm_base + CCR);\r\nval = readl_relaxed(ccm_base + CCR);\r\nval &= ~BM_CCR_RBC_BYPASS_COUNT;\r\nval |= enable ? BM_CCR_RBC_BYPASS_COUNT : 0;\r\nwritel(val, ccm_base + CCR);\r\nudelay(65);\r\nimx_gpc_restore_all();\r\n}\r\nstatic void imx6q_enable_wb(bool enable)\r\n{\r\nu32 val;\r\nval = readl_relaxed(ccm_base + CLPCR);\r\nval &= ~BM_CLPCR_WB_PER_AT_LPM;\r\nval |= enable ? BM_CLPCR_WB_PER_AT_LPM : 0;\r\nwritel_relaxed(val, ccm_base + CLPCR);\r\nval = readl_relaxed(ccm_base + CCR);\r\nval &= ~BM_CCR_WB_COUNT;\r\nval |= enable ? BM_CCR_WB_COUNT : 0;\r\nwritel_relaxed(val, ccm_base + CCR);\r\n}\r\nint imx6_set_lpm(enum mxc_cpu_pwr_mode mode)\r\n{\r\nu32 val = readl_relaxed(ccm_base + CLPCR);\r\nval &= ~BM_CLPCR_LPM;\r\nswitch (mode) {\r\ncase WAIT_CLOCKED:\r\nbreak;\r\ncase WAIT_UNCLOCKED:\r\nval |= 0x1 << BP_CLPCR_LPM;\r\nval |= BM_CLPCR_ARM_CLK_DIS_ON_LPM;\r\nbreak;\r\ncase STOP_POWER_ON:\r\nval |= 0x2 << BP_CLPCR_LPM;\r\nval &= ~BM_CLPCR_VSTBY;\r\nval &= ~BM_CLPCR_SBYOS;\r\nif (cpu_is_imx6sl())\r\nval |= BM_CLPCR_BYPASS_PMIC_READY;\r\nif (cpu_is_imx6sl() || cpu_is_imx6sx())\r\nval |= BM_CLPCR_BYP_MMDC_CH0_LPM_HS;\r\nelse\r\nval |= BM_CLPCR_BYP_MMDC_CH1_LPM_HS;\r\nbreak;\r\ncase WAIT_UNCLOCKED_POWER_OFF:\r\nval |= 0x1 << BP_CLPCR_LPM;\r\nval &= ~BM_CLPCR_VSTBY;\r\nval &= ~BM_CLPCR_SBYOS;\r\nbreak;\r\ncase STOP_POWER_OFF:\r\nval |= 0x2 << BP_CLPCR_LPM;\r\nval |= 0x3 << BP_CLPCR_STBY_COUNT;\r\nval |= BM_CLPCR_VSTBY;\r\nval |= BM_CLPCR_SBYOS;\r\nif (cpu_is_imx6sl())\r\nval |= BM_CLPCR_BYPASS_PMIC_READY;\r\nif (cpu_is_imx6sl() || cpu_is_imx6sx() || cpu_is_imx6ul())\r\nval |= BM_CLPCR_BYP_MMDC_CH0_LPM_HS;\r\nelse\r\nval |= BM_CLPCR_BYP_MMDC_CH1_LPM_HS;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nimx_gpc_hwirq_unmask(0);\r\nwritel_relaxed(val, ccm_base + CLPCR);\r\nimx_gpc_hwirq_mask(0);\r\nreturn 0;\r\n}\r\nstatic int imx6q_suspend_finish(unsigned long val)\r\n{\r\nif (!imx6_suspend_in_ocram_fn) {\r\ncpu_do_idle();\r\n} else {\r\nlocal_flush_tlb_all();\r\nif (!((struct imx6_cpu_pm_info *)\r\nsuspend_ocram_base)->l2_base.vbase)\r\nflush_cache_all();\r\nimx6_suspend_in_ocram_fn(suspend_ocram_base);\r\n}\r\nreturn 0;\r\n}\r\nstatic int imx6q_pm_enter(suspend_state_t state)\r\n{\r\nswitch (state) {\r\ncase PM_SUSPEND_STANDBY:\r\nimx6_set_lpm(STOP_POWER_ON);\r\nimx6q_set_int_mem_clk_lpm(true);\r\nimx_gpc_pre_suspend(false);\r\nif (cpu_is_imx6sl())\r\nimx6sl_set_wait_clk(true);\r\ncpu_do_idle();\r\nif (cpu_is_imx6sl())\r\nimx6sl_set_wait_clk(false);\r\nimx_gpc_post_resume();\r\nimx6_set_lpm(WAIT_CLOCKED);\r\nbreak;\r\ncase PM_SUSPEND_MEM:\r\nimx6_set_lpm(STOP_POWER_OFF);\r\nimx6q_set_int_mem_clk_lpm(false);\r\nimx6q_enable_wb(true);\r\nif (!imx6_suspend_in_ocram_fn)\r\nimx6_enable_rbc(true);\r\nimx_gpc_pre_suspend(true);\r\nimx_anatop_pre_suspend();\r\ncpu_suspend(0, imx6q_suspend_finish);\r\nif (cpu_is_imx6q() || cpu_is_imx6dl())\r\nimx_smp_prepare();\r\nimx_anatop_post_resume();\r\nimx_gpc_post_resume();\r\nimx6_enable_rbc(false);\r\nimx6q_enable_wb(false);\r\nimx6q_set_int_mem_clk_lpm(true);\r\nimx6_set_lpm(WAIT_CLOCKED);\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int imx6q_pm_valid(suspend_state_t state)\r\n{\r\nreturn (state == PM_SUSPEND_STANDBY || state == PM_SUSPEND_MEM);\r\n}\r\nstatic int __init imx6_pm_get_base(struct imx6_pm_base *base,\r\nconst char *compat)\r\n{\r\nstruct device_node *node;\r\nstruct resource res;\r\nint ret = 0;\r\nnode = of_find_compatible_node(NULL, NULL, compat);\r\nif (!node) {\r\nret = -ENODEV;\r\ngoto out;\r\n}\r\nret = of_address_to_resource(node, 0, &res);\r\nif (ret)\r\ngoto put_node;\r\nbase->pbase = res.start;\r\nbase->vbase = ioremap(res.start, resource_size(&res));\r\nif (!base->vbase)\r\nret = -ENOMEM;\r\nput_node:\r\nof_node_put(node);\r\nout:\r\nreturn ret;\r\n}\r\nstatic int __init imx6q_suspend_init(const struct imx6_pm_socdata *socdata)\r\n{\r\nphys_addr_t ocram_pbase;\r\nstruct device_node *node;\r\nstruct platform_device *pdev;\r\nstruct imx6_cpu_pm_info *pm_info;\r\nstruct gen_pool *ocram_pool;\r\nunsigned long ocram_base;\r\nint i, ret = 0;\r\nconst u32 *mmdc_offset_array;\r\nsuspend_set_ops(&imx6q_pm_ops);\r\nif (!socdata) {\r\npr_warn("%s: invalid argument!\n", __func__);\r\nreturn -EINVAL;\r\n}\r\nnode = of_find_compatible_node(NULL, NULL, "mmio-sram");\r\nif (!node) {\r\npr_warn("%s: failed to find ocram node!\n", __func__);\r\nreturn -ENODEV;\r\n}\r\npdev = of_find_device_by_node(node);\r\nif (!pdev) {\r\npr_warn("%s: failed to find ocram device!\n", __func__);\r\nret = -ENODEV;\r\ngoto put_node;\r\n}\r\nocram_pool = gen_pool_get(&pdev->dev, NULL);\r\nif (!ocram_pool) {\r\npr_warn("%s: ocram pool unavailable!\n", __func__);\r\nret = -ENODEV;\r\ngoto put_node;\r\n}\r\nocram_base = gen_pool_alloc(ocram_pool, MX6Q_SUSPEND_OCRAM_SIZE);\r\nif (!ocram_base) {\r\npr_warn("%s: unable to alloc ocram!\n", __func__);\r\nret = -ENOMEM;\r\ngoto put_node;\r\n}\r\nocram_pbase = gen_pool_virt_to_phys(ocram_pool, ocram_base);\r\nsuspend_ocram_base = __arm_ioremap_exec(ocram_pbase,\r\nMX6Q_SUSPEND_OCRAM_SIZE, false);\r\nmemset(suspend_ocram_base, 0, sizeof(*pm_info));\r\npm_info = suspend_ocram_base;\r\npm_info->pbase = ocram_pbase;\r\npm_info->resume_addr = virt_to_phys(v7_cpu_resume);\r\npm_info->pm_info_size = sizeof(*pm_info);\r\npm_info->ccm_base.vbase = ccm_base;\r\nret = imx6_pm_get_base(&pm_info->mmdc_base, socdata->mmdc_compat);\r\nif (ret) {\r\npr_warn("%s: failed to get mmdc base %d!\n", __func__, ret);\r\ngoto put_node;\r\n}\r\nret = imx6_pm_get_base(&pm_info->src_base, socdata->src_compat);\r\nif (ret) {\r\npr_warn("%s: failed to get src base %d!\n", __func__, ret);\r\ngoto src_map_failed;\r\n}\r\nret = imx6_pm_get_base(&pm_info->iomuxc_base, socdata->iomuxc_compat);\r\nif (ret) {\r\npr_warn("%s: failed to get iomuxc base %d!\n", __func__, ret);\r\ngoto iomuxc_map_failed;\r\n}\r\nret = imx6_pm_get_base(&pm_info->gpc_base, socdata->gpc_compat);\r\nif (ret) {\r\npr_warn("%s: failed to get gpc base %d!\n", __func__, ret);\r\ngoto gpc_map_failed;\r\n}\r\nif (socdata->pl310_compat) {\r\nret = imx6_pm_get_base(&pm_info->l2_base, socdata->pl310_compat);\r\nif (ret) {\r\npr_warn("%s: failed to get pl310-cache base %d!\n",\r\n__func__, ret);\r\ngoto pl310_cache_map_failed;\r\n}\r\n}\r\npm_info->ddr_type = imx_mmdc_get_ddr_type();\r\npm_info->mmdc_io_num = socdata->mmdc_io_num;\r\nmmdc_offset_array = socdata->mmdc_io_offset;\r\nfor (i = 0; i < pm_info->mmdc_io_num; i++) {\r\npm_info->mmdc_io_val[i][0] =\r\nmmdc_offset_array[i];\r\npm_info->mmdc_io_val[i][1] =\r\nreadl_relaxed(pm_info->iomuxc_base.vbase +\r\nmmdc_offset_array[i]);\r\n}\r\nimx6_suspend_in_ocram_fn = fncpy(\r\nsuspend_ocram_base + sizeof(*pm_info),\r\n&imx6_suspend,\r\nMX6Q_SUSPEND_OCRAM_SIZE - sizeof(*pm_info));\r\ngoto put_node;\r\npl310_cache_map_failed:\r\niounmap(&pm_info->gpc_base.vbase);\r\ngpc_map_failed:\r\niounmap(&pm_info->iomuxc_base.vbase);\r\niomuxc_map_failed:\r\niounmap(&pm_info->src_base.vbase);\r\nsrc_map_failed:\r\niounmap(&pm_info->mmdc_base.vbase);\r\nput_node:\r\nof_node_put(node);\r\nreturn ret;\r\n}\r\nstatic void __init imx6_pm_common_init(const struct imx6_pm_socdata\r\n*socdata)\r\n{\r\nstruct regmap *gpr;\r\nint ret;\r\nWARN_ON(!ccm_base);\r\nif (IS_ENABLED(CONFIG_SUSPEND)) {\r\nret = imx6q_suspend_init(socdata);\r\nif (ret)\r\npr_warn("%s: No DDR LPM support with suspend %d!\n",\r\n__func__, ret);\r\n}\r\ngpr = syscon_regmap_lookup_by_compatible("fsl,imx6q-iomuxc-gpr");\r\nif (!IS_ERR(gpr))\r\nregmap_update_bits(gpr, IOMUXC_GPR1, IMX6Q_GPR1_GINT,\r\nIMX6Q_GPR1_GINT);\r\n}\r\nvoid __init imx6_pm_ccm_init(const char *ccm_compat)\r\n{\r\nstruct device_node *np;\r\nu32 val;\r\nnp = of_find_compatible_node(NULL, NULL, ccm_compat);\r\nccm_base = of_iomap(np, 0);\r\nBUG_ON(!ccm_base);\r\nval = readl_relaxed(ccm_base + CLPCR);\r\nval &= ~BM_CLPCR_LPM;\r\nwritel_relaxed(val, ccm_base + CLPCR);\r\n}\r\nvoid __init imx6q_pm_init(void)\r\n{\r\nimx6_pm_common_init(&imx6q_pm_data);\r\n}\r\nvoid __init imx6dl_pm_init(void)\r\n{\r\nimx6_pm_common_init(&imx6dl_pm_data);\r\n}\r\nvoid __init imx6sl_pm_init(void)\r\n{\r\nimx6_pm_common_init(&imx6sl_pm_data);\r\n}\r\nvoid __init imx6sx_pm_init(void)\r\n{\r\nimx6_pm_common_init(&imx6sx_pm_data);\r\n}\r\nvoid __init imx6ul_pm_init(void)\r\n{\r\nimx6_pm_common_init(&imx6ul_pm_data);\r\n}
