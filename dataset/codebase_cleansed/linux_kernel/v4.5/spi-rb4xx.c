static inline u32 rb4xx_read(struct rb4xx_spi *rbspi, u32 reg)\r\n{\r\nreturn __raw_readl(rbspi->base + reg);\r\n}\r\nstatic inline void rb4xx_write(struct rb4xx_spi *rbspi, u32 reg, u32 value)\r\n{\r\n__raw_writel(value, rbspi->base + reg);\r\n}\r\nstatic inline void do_spi_clk(struct rb4xx_spi *rbspi, u32 spi_ioc, int value)\r\n{\r\nu32 regval;\r\nregval = spi_ioc;\r\nif (value & BIT(0))\r\nregval |= AR71XX_SPI_IOC_DO;\r\nrb4xx_write(rbspi, AR71XX_SPI_REG_IOC, regval);\r\nrb4xx_write(rbspi, AR71XX_SPI_REG_IOC, regval | AR71XX_SPI_IOC_CLK);\r\n}\r\nstatic void do_spi_byte(struct rb4xx_spi *rbspi, u32 spi_ioc, u8 byte)\r\n{\r\nint i;\r\nfor (i = 7; i >= 0; i--)\r\ndo_spi_clk(rbspi, spi_ioc, byte >> i);\r\n}\r\nstatic inline void do_spi_clk_two(struct rb4xx_spi *rbspi, u32 spi_ioc,\r\nu8 value)\r\n{\r\nu32 regval;\r\nregval = spi_ioc;\r\nif (value & BIT(1))\r\nregval |= AR71XX_SPI_IOC_DO;\r\nif (value & BIT(0))\r\nregval |= AR71XX_SPI_IOC_CS2;\r\nrb4xx_write(rbspi, AR71XX_SPI_REG_IOC, regval);\r\nrb4xx_write(rbspi, AR71XX_SPI_REG_IOC, regval | AR71XX_SPI_IOC_CLK);\r\n}\r\nstatic void do_spi_byte_two(struct rb4xx_spi *rbspi, u32 spi_ioc, u8 byte)\r\n{\r\ndo_spi_clk_two(rbspi, spi_ioc, byte >> 6);\r\ndo_spi_clk_two(rbspi, spi_ioc, byte >> 4);\r\ndo_spi_clk_two(rbspi, spi_ioc, byte >> 2);\r\ndo_spi_clk_two(rbspi, spi_ioc, byte >> 0);\r\n}\r\nstatic void rb4xx_set_cs(struct spi_device *spi, bool enable)\r\n{\r\nstruct rb4xx_spi *rbspi = spi_master_get_devdata(spi->master);\r\nif (enable)\r\nrb4xx_write(rbspi, AR71XX_SPI_REG_IOC,\r\nAR71XX_SPI_IOC_CS0 | AR71XX_SPI_IOC_CS1);\r\n}\r\nstatic int rb4xx_transfer_one(struct spi_master *master,\r\nstruct spi_device *spi, struct spi_transfer *t)\r\n{\r\nstruct rb4xx_spi *rbspi = spi_master_get_devdata(master);\r\nint i;\r\nu32 spi_ioc;\r\nu8 *rx_buf;\r\nconst u8 *tx_buf;\r\nif (spi->chip_select == 2)\r\nspi_ioc = AR71XX_SPI_IOC_CS0;\r\nelse\r\nspi_ioc = AR71XX_SPI_IOC_CS1;\r\ntx_buf = t->tx_buf;\r\nrx_buf = t->rx_buf;\r\nfor (i = 0; i < t->len; ++i) {\r\nif (t->tx_nbits == SPI_NBITS_DUAL)\r\ndo_spi_byte_two(rbspi, spi_ioc, tx_buf[i]);\r\nelse\r\ndo_spi_byte(rbspi, spi_ioc, tx_buf[i]);\r\nif (!rx_buf)\r\ncontinue;\r\nrx_buf[i] = rb4xx_read(rbspi, AR71XX_SPI_REG_RDS);\r\n}\r\nspi_finalize_current_transfer(master);\r\nreturn 0;\r\n}\r\nstatic int rb4xx_spi_probe(struct platform_device *pdev)\r\n{\r\nstruct spi_master *master;\r\nstruct clk *ahb_clk;\r\nstruct rb4xx_spi *rbspi;\r\nstruct resource *r;\r\nint err;\r\nvoid __iomem *spi_base;\r\nr = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nspi_base = devm_ioremap_resource(&pdev->dev, r);\r\nif (IS_ERR(spi_base))\r\nreturn PTR_ERR(spi_base);\r\nmaster = spi_alloc_master(&pdev->dev, sizeof(*rbspi));\r\nif (!master)\r\nreturn -ENOMEM;\r\nahb_clk = devm_clk_get(&pdev->dev, "ahb");\r\nif (IS_ERR(ahb_clk))\r\nreturn PTR_ERR(ahb_clk);\r\nmaster->bus_num = 0;\r\nmaster->num_chipselect = 3;\r\nmaster->mode_bits = SPI_TX_DUAL;\r\nmaster->bits_per_word_mask = BIT(7);\r\nmaster->flags = SPI_MASTER_MUST_TX;\r\nmaster->transfer_one = rb4xx_transfer_one;\r\nmaster->set_cs = rb4xx_set_cs;\r\nerr = devm_spi_register_master(&pdev->dev, master);\r\nif (err) {\r\ndev_err(&pdev->dev, "failed to register SPI master\n");\r\nreturn err;\r\n}\r\nerr = clk_prepare_enable(ahb_clk);\r\nif (err)\r\nreturn err;\r\nrbspi = spi_master_get_devdata(master);\r\nrbspi->base = spi_base;\r\nrbspi->clk = ahb_clk;\r\nplatform_set_drvdata(pdev, rbspi);\r\nrb4xx_write(rbspi, AR71XX_SPI_REG_FS, AR71XX_SPI_FS_GPIO);\r\nreturn 0;\r\n}\r\nstatic int rb4xx_spi_remove(struct platform_device *pdev)\r\n{\r\nstruct rb4xx_spi *rbspi = platform_get_drvdata(pdev);\r\nclk_disable_unprepare(rbspi->clk);\r\nreturn 0;\r\n}
