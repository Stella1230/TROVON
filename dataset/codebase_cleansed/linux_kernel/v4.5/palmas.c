int palmas_ext_control_req_config(struct palmas *palmas,\r\nenum palmas_external_requestor_id id, int ext_ctrl, bool enable)\r\n{\r\nstruct palmas_pmic_driver_data *pmic_ddata = palmas->pmic_ddata;\r\nint preq_mask_bit = 0;\r\nint reg_add = 0;\r\nint bit_pos, ret;\r\nif (!(ext_ctrl & PALMAS_EXT_REQ))\r\nreturn 0;\r\nif (id >= PALMAS_EXTERNAL_REQSTR_ID_MAX)\r\nreturn 0;\r\nif (ext_ctrl & PALMAS_EXT_CONTROL_NSLEEP) {\r\nreg_add = PALMAS_NSLEEP_RES_ASSIGN;\r\npreq_mask_bit = 0;\r\n} else if (ext_ctrl & PALMAS_EXT_CONTROL_ENABLE1) {\r\nreg_add = PALMAS_ENABLE1_RES_ASSIGN;\r\npreq_mask_bit = 1;\r\n} else if (ext_ctrl & PALMAS_EXT_CONTROL_ENABLE2) {\r\nreg_add = PALMAS_ENABLE2_RES_ASSIGN;\r\npreq_mask_bit = 2;\r\n}\r\nbit_pos = pmic_ddata->sleep_req_info[id].bit_pos;\r\nreg_add += pmic_ddata->sleep_req_info[id].reg_offset;\r\nif (enable)\r\nret = palmas_update_bits(palmas, PALMAS_RESOURCE_BASE,\r\nreg_add, BIT(bit_pos), BIT(bit_pos));\r\nelse\r\nret = palmas_update_bits(palmas, PALMAS_RESOURCE_BASE,\r\nreg_add, BIT(bit_pos), 0);\r\nif (ret < 0) {\r\ndev_err(palmas->dev, "Resource reg 0x%02x update failed %d\n",\r\nreg_add, ret);\r\nreturn ret;\r\n}\r\nret = palmas_update_bits(palmas, PALMAS_PMU_CONTROL_BASE,\r\nPALMAS_POWER_CTRL, BIT(preq_mask_bit), 0);\r\nif (ret < 0) {\r\ndev_err(palmas->dev, "POWER_CTRL register update failed %d\n",\r\nret);\r\nreturn ret;\r\n}\r\nreturn ret;\r\n}\r\nstatic int palmas_set_pdata_irq_flag(struct i2c_client *i2c,\r\nstruct palmas_platform_data *pdata)\r\n{\r\nstruct irq_data *irq_data = irq_get_irq_data(i2c->irq);\r\nif (!irq_data) {\r\ndev_err(&i2c->dev, "Invalid IRQ: %d\n", i2c->irq);\r\nreturn -EINVAL;\r\n}\r\npdata->irq_flags = irqd_get_trigger_type(irq_data);\r\ndev_info(&i2c->dev, "Irq flag is 0x%08x\n", pdata->irq_flags);\r\nreturn 0;\r\n}\r\nstatic void palmas_dt_to_pdata(struct i2c_client *i2c,\r\nstruct palmas_platform_data *pdata)\r\n{\r\nstruct device_node *node = i2c->dev.of_node;\r\nint ret;\r\nu32 prop;\r\nret = of_property_read_u32(node, "ti,mux-pad1", &prop);\r\nif (!ret) {\r\npdata->mux_from_pdata = 1;\r\npdata->pad1 = prop;\r\n}\r\nret = of_property_read_u32(node, "ti,mux-pad2", &prop);\r\nif (!ret) {\r\npdata->mux_from_pdata = 1;\r\npdata->pad2 = prop;\r\n}\r\nret = of_property_read_u32(node, "ti,power-ctrl", &prop);\r\nif (!ret)\r\npdata->power_ctrl = prop;\r\nelse\r\npdata->power_ctrl = PALMAS_POWER_CTRL_NSLEEP_MASK |\r\nPALMAS_POWER_CTRL_ENABLE1_MASK |\r\nPALMAS_POWER_CTRL_ENABLE2_MASK;\r\nif (i2c->irq)\r\npalmas_set_pdata_irq_flag(i2c, pdata);\r\npdata->pm_off = of_property_read_bool(node,\r\n"ti,system-power-controller");\r\n}\r\nstatic void palmas_power_off(void)\r\n{\r\nunsigned int addr;\r\nint ret, slave;\r\nif (!palmas_dev)\r\nreturn;\r\nslave = PALMAS_BASE_TO_SLAVE(PALMAS_PMU_CONTROL_BASE);\r\naddr = PALMAS_BASE_TO_REG(PALMAS_PMU_CONTROL_BASE, PALMAS_DEV_CTRL);\r\nret = regmap_update_bits(\r\npalmas_dev->regmap[slave],\r\naddr,\r\nPALMAS_DEV_CTRL_DEV_ON,\r\n0);\r\nif (ret)\r\npr_err("%s: Unable to write to DEV_CTRL_DEV_ON: %d\n",\r\n__func__, ret);\r\n}\r\nstatic int palmas_i2c_probe(struct i2c_client *i2c,\r\nconst struct i2c_device_id *id)\r\n{\r\nstruct palmas *palmas;\r\nstruct palmas_platform_data *pdata;\r\nstruct palmas_driver_data *driver_data;\r\nstruct device_node *node = i2c->dev.of_node;\r\nint ret = 0, i;\r\nunsigned int reg, addr;\r\nint slave;\r\nconst struct of_device_id *match;\r\npdata = dev_get_platdata(&i2c->dev);\r\nif (node && !pdata) {\r\npdata = devm_kzalloc(&i2c->dev, sizeof(*pdata), GFP_KERNEL);\r\nif (!pdata)\r\nreturn -ENOMEM;\r\npalmas_dt_to_pdata(i2c, pdata);\r\n}\r\nif (!pdata)\r\nreturn -EINVAL;\r\npalmas = devm_kzalloc(&i2c->dev, sizeof(struct palmas), GFP_KERNEL);\r\nif (palmas == NULL)\r\nreturn -ENOMEM;\r\ni2c_set_clientdata(i2c, palmas);\r\npalmas->dev = &i2c->dev;\r\npalmas->irq = i2c->irq;\r\nmatch = of_match_device(of_palmas_match_tbl, &i2c->dev);\r\nif (!match)\r\nreturn -ENODATA;\r\ndriver_data = (struct palmas_driver_data *)match->data;\r\npalmas->features = *driver_data->features;\r\nfor (i = 0; i < PALMAS_NUM_CLIENTS; i++) {\r\nif (i == 0)\r\npalmas->i2c_clients[i] = i2c;\r\nelse {\r\npalmas->i2c_clients[i] =\r\ni2c_new_dummy(i2c->adapter,\r\ni2c->addr + i);\r\nif (!palmas->i2c_clients[i]) {\r\ndev_err(palmas->dev,\r\n"can't attach client %d\n", i);\r\nret = -ENOMEM;\r\ngoto err_i2c;\r\n}\r\npalmas->i2c_clients[i]->dev.of_node = of_node_get(node);\r\n}\r\npalmas->regmap[i] = devm_regmap_init_i2c(palmas->i2c_clients[i],\r\n&palmas_regmap_config[i]);\r\nif (IS_ERR(palmas->regmap[i])) {\r\nret = PTR_ERR(palmas->regmap[i]);\r\ndev_err(palmas->dev,\r\n"Failed to allocate regmap %d, err: %d\n",\r\ni, ret);\r\ngoto err_i2c;\r\n}\r\n}\r\nif (!palmas->irq) {\r\ndev_warn(palmas->dev, "IRQ missing: skipping irq request\n");\r\ngoto no_irq;\r\n}\r\nif (pdata->irq_flags & IRQ_TYPE_LEVEL_HIGH)\r\nreg = PALMAS_POLARITY_CTRL_INT_POLARITY;\r\nelse\r\nreg = 0;\r\nret = palmas_update_bits(palmas, PALMAS_PU_PD_OD_BASE,\r\nPALMAS_POLARITY_CTRL, PALMAS_POLARITY_CTRL_INT_POLARITY,\r\nreg);\r\nif (ret < 0) {\r\ndev_err(palmas->dev, "POLARITY_CTRL updat failed: %d\n", ret);\r\ngoto err_i2c;\r\n}\r\nslave = PALMAS_BASE_TO_SLAVE(PALMAS_INTERRUPT_BASE);\r\naddr = PALMAS_BASE_TO_REG(PALMAS_INTERRUPT_BASE, PALMAS_INT_CTRL);\r\nreg = PALMAS_INT_CTRL_INT_CLEAR;\r\nregmap_write(palmas->regmap[slave], addr, reg);\r\nret = regmap_add_irq_chip(palmas->regmap[slave], palmas->irq,\r\nIRQF_ONESHOT | pdata->irq_flags, 0,\r\ndriver_data->irq_chip, &palmas->irq_data);\r\nif (ret < 0)\r\ngoto err_i2c;\r\nno_irq:\r\nslave = PALMAS_BASE_TO_SLAVE(PALMAS_PU_PD_OD_BASE);\r\naddr = PALMAS_BASE_TO_REG(PALMAS_PU_PD_OD_BASE,\r\nPALMAS_PRIMARY_SECONDARY_PAD1);\r\nif (pdata->mux_from_pdata) {\r\nreg = pdata->pad1;\r\nret = regmap_write(palmas->regmap[slave], addr, reg);\r\nif (ret)\r\ngoto err_irq;\r\n} else {\r\nret = regmap_read(palmas->regmap[slave], addr, &reg);\r\nif (ret)\r\ngoto err_irq;\r\n}\r\nif (!(reg & PALMAS_PRIMARY_SECONDARY_PAD1_GPIO_0))\r\npalmas->gpio_muxed |= PALMAS_GPIO_0_MUXED;\r\nif (!(reg & PALMAS_PRIMARY_SECONDARY_PAD1_GPIO_1_MASK))\r\npalmas->gpio_muxed |= PALMAS_GPIO_1_MUXED;\r\nelse if ((reg & PALMAS_PRIMARY_SECONDARY_PAD1_GPIO_1_MASK) ==\r\n(2 << PALMAS_PRIMARY_SECONDARY_PAD1_GPIO_1_SHIFT))\r\npalmas->led_muxed |= PALMAS_LED1_MUXED;\r\nelse if ((reg & PALMAS_PRIMARY_SECONDARY_PAD1_GPIO_1_MASK) ==\r\n(3 << PALMAS_PRIMARY_SECONDARY_PAD1_GPIO_1_SHIFT))\r\npalmas->pwm_muxed |= PALMAS_PWM1_MUXED;\r\nif (!(reg & PALMAS_PRIMARY_SECONDARY_PAD1_GPIO_2_MASK))\r\npalmas->gpio_muxed |= PALMAS_GPIO_2_MUXED;\r\nelse if ((reg & PALMAS_PRIMARY_SECONDARY_PAD1_GPIO_2_MASK) ==\r\n(2 << PALMAS_PRIMARY_SECONDARY_PAD1_GPIO_2_SHIFT))\r\npalmas->led_muxed |= PALMAS_LED2_MUXED;\r\nelse if ((reg & PALMAS_PRIMARY_SECONDARY_PAD1_GPIO_2_MASK) ==\r\n(3 << PALMAS_PRIMARY_SECONDARY_PAD1_GPIO_2_SHIFT))\r\npalmas->pwm_muxed |= PALMAS_PWM2_MUXED;\r\nif (!(reg & PALMAS_PRIMARY_SECONDARY_PAD1_GPIO_3))\r\npalmas->gpio_muxed |= PALMAS_GPIO_3_MUXED;\r\naddr = PALMAS_BASE_TO_REG(PALMAS_PU_PD_OD_BASE,\r\nPALMAS_PRIMARY_SECONDARY_PAD2);\r\nif (pdata->mux_from_pdata) {\r\nreg = pdata->pad2;\r\nret = regmap_write(palmas->regmap[slave], addr, reg);\r\nif (ret)\r\ngoto err_irq;\r\n} else {\r\nret = regmap_read(palmas->regmap[slave], addr, &reg);\r\nif (ret)\r\ngoto err_irq;\r\n}\r\nif (!(reg & PALMAS_PRIMARY_SECONDARY_PAD2_GPIO_4))\r\npalmas->gpio_muxed |= PALMAS_GPIO_4_MUXED;\r\nif (!(reg & PALMAS_PRIMARY_SECONDARY_PAD2_GPIO_5_MASK))\r\npalmas->gpio_muxed |= PALMAS_GPIO_5_MUXED;\r\nif (!(reg & PALMAS_PRIMARY_SECONDARY_PAD2_GPIO_6))\r\npalmas->gpio_muxed |= PALMAS_GPIO_6_MUXED;\r\nif (!(reg & PALMAS_PRIMARY_SECONDARY_PAD2_GPIO_7_MASK))\r\npalmas->gpio_muxed |= PALMAS_GPIO_7_MUXED;\r\ndev_info(palmas->dev, "Muxing GPIO %x, PWM %x, LED %x\n",\r\npalmas->gpio_muxed, palmas->pwm_muxed,\r\npalmas->led_muxed);\r\nreg = pdata->power_ctrl;\r\nslave = PALMAS_BASE_TO_SLAVE(PALMAS_PMU_CONTROL_BASE);\r\naddr = PALMAS_BASE_TO_REG(PALMAS_PMU_CONTROL_BASE, PALMAS_POWER_CTRL);\r\nret = regmap_write(palmas->regmap[slave], addr, reg);\r\nif (ret)\r\ngoto err_irq;\r\nif (node) {\r\nret = of_platform_populate(node, NULL, NULL, &i2c->dev);\r\nif (ret < 0) {\r\ngoto err_irq;\r\n} else if (pdata->pm_off && !pm_power_off) {\r\npalmas_dev = palmas;\r\npm_power_off = palmas_power_off;\r\n}\r\n}\r\nreturn ret;\r\nerr_irq:\r\nregmap_del_irq_chip(palmas->irq, palmas->irq_data);\r\nerr_i2c:\r\nfor (i = 1; i < PALMAS_NUM_CLIENTS; i++) {\r\nif (palmas->i2c_clients[i])\r\ni2c_unregister_device(palmas->i2c_clients[i]);\r\n}\r\nreturn ret;\r\n}\r\nstatic int palmas_i2c_remove(struct i2c_client *i2c)\r\n{\r\nstruct palmas *palmas = i2c_get_clientdata(i2c);\r\nint i;\r\nregmap_del_irq_chip(palmas->irq, palmas->irq_data);\r\nfor (i = 1; i < PALMAS_NUM_CLIENTS; i++) {\r\nif (palmas->i2c_clients[i])\r\ni2c_unregister_device(palmas->i2c_clients[i]);\r\n}\r\nif (palmas == palmas_dev) {\r\npm_power_off = NULL;\r\npalmas_dev = NULL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int __init palmas_i2c_init(void)\r\n{\r\nreturn i2c_add_driver(&palmas_i2c_driver);\r\n}\r\nstatic void __exit palmas_i2c_exit(void)\r\n{\r\ni2c_del_driver(&palmas_i2c_driver);\r\n}
