irqreturn_t netup_ci_interrupt(struct netup_unidvb_dev *ndev)\r\n{\r\nwritew(0x101, ndev->bmmio0 + CAM_CTRLSTAT_CLR);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int netup_unidvb_ci_slot_ts_ctl(struct dvb_ca_en50221 *en50221,\r\nint slot)\r\n{\r\nstruct netup_ci_state *state = en50221->data;\r\nstruct netup_unidvb_dev *dev = state->dev;\r\nu16 shift = (state->nr == 1) ? CAM1_SHIFT : 0;\r\ndev_dbg(&dev->pci_dev->dev, "%s(): CAM_CTRLSTAT=0x%x\n",\r\n__func__, readw(dev->bmmio0 + CAM_CTRLSTAT_READ_SET));\r\nif (slot != 0)\r\nreturn -EINVAL;\r\nwritew(BIT_CAM_BYPASS << shift, dev->bmmio0 + CAM_CTRLSTAT_CLR);\r\ndev_dbg(&dev->pci_dev->dev, "%s(): CAM_CTRLSTAT=0x%x done\n",\r\n__func__, readw(dev->bmmio0 + CAM_CTRLSTAT_READ_SET));\r\nreturn 0;\r\n}\r\nstatic int netup_unidvb_ci_slot_shutdown(struct dvb_ca_en50221 *en50221,\r\nint slot)\r\n{\r\nstruct netup_ci_state *state = en50221->data;\r\nstruct netup_unidvb_dev *dev = state->dev;\r\ndev_dbg(&dev->pci_dev->dev, "%s()\n", __func__);\r\nreturn 0;\r\n}\r\nstatic int netup_unidvb_ci_slot_reset(struct dvb_ca_en50221 *en50221,\r\nint slot)\r\n{\r\nstruct netup_ci_state *state = en50221->data;\r\nstruct netup_unidvb_dev *dev = state->dev;\r\nunsigned long timeout = 0;\r\nu16 shift = (state->nr == 1) ? CAM1_SHIFT : 0;\r\nu16 ci_stat = 0;\r\nint reset_counter = 3;\r\ndev_dbg(&dev->pci_dev->dev, "%s(): CAM_CTRLSTAT_READ_SET=0x%x\n",\r\n__func__, readw(dev->bmmio0 + CAM_CTRLSTAT_READ_SET));\r\nreset:\r\ntimeout = jiffies + msecs_to_jiffies(5000);\r\nwritew(BIT_CAM_RESET << shift, dev->bmmio0 + CAM_CTRLSTAT_READ_SET);\r\ndev_dbg(&dev->pci_dev->dev, "%s(): waiting for reset\n", __func__);\r\nwhile (time_before(jiffies, timeout)) {\r\nci_stat = readw(dev->bmmio0 + CAM_CTRLSTAT_READ_SET);\r\nif (ci_stat & (BIT_CAM_READY << shift))\r\nbreak;\r\nudelay(1000);\r\n}\r\nif (!(ci_stat & (BIT_CAM_READY << shift)) && reset_counter > 0) {\r\ndev_dbg(&dev->pci_dev->dev,\r\n"%s(): CAMP reset timeout! Will try again..\n",\r\n__func__);\r\nreset_counter--;\r\ngoto reset;\r\n}\r\nreturn 0;\r\n}\r\nstatic int netup_unidvb_poll_ci_slot_status(struct dvb_ca_en50221 *en50221,\r\nint slot, int open)\r\n{\r\nstruct netup_ci_state *state = en50221->data;\r\nstruct netup_unidvb_dev *dev = state->dev;\r\nu16 shift = (state->nr == 1) ? CAM1_SHIFT : 0;\r\nu16 ci_stat = 0;\r\ndev_dbg(&dev->pci_dev->dev, "%s(): CAM_CTRLSTAT_READ_SET=0x%x\n",\r\n__func__, readw(dev->bmmio0 + CAM_CTRLSTAT_READ_SET));\r\nci_stat = readw(dev->bmmio0 + CAM_CTRLSTAT_READ_SET);\r\nif (ci_stat & (BIT_CAM_READY << shift)) {\r\nstate->status = DVB_CA_EN50221_POLL_CAM_PRESENT |\r\nDVB_CA_EN50221_POLL_CAM_READY;\r\n} else if (ci_stat & (BIT_CAM_PRESENT << shift)) {\r\nstate->status = DVB_CA_EN50221_POLL_CAM_PRESENT;\r\n} else {\r\nstate->status = 0;\r\n}\r\nreturn state->status;\r\n}\r\nstatic int netup_unidvb_ci_read_attribute_mem(struct dvb_ca_en50221 *en50221,\r\nint slot, int addr)\r\n{\r\nstruct netup_ci_state *state = en50221->data;\r\nstruct netup_unidvb_dev *dev = state->dev;\r\nu8 val = *((u8 __force *)state->membase8_io + addr);\r\ndev_dbg(&dev->pci_dev->dev,\r\n"%s(): addr=0x%x val=0x%x\n", __func__, addr, val);\r\nreturn val;\r\n}\r\nstatic int netup_unidvb_ci_write_attribute_mem(struct dvb_ca_en50221 *en50221,\r\nint slot, int addr, u8 data)\r\n{\r\nstruct netup_ci_state *state = en50221->data;\r\nstruct netup_unidvb_dev *dev = state->dev;\r\ndev_dbg(&dev->pci_dev->dev,\r\n"%s(): addr=0x%x data=0x%x\n", __func__, addr, data);\r\n*((u8 __force *)state->membase8_io + addr) = data;\r\nreturn 0;\r\n}\r\nstatic int netup_unidvb_ci_read_cam_ctl(struct dvb_ca_en50221 *en50221,\r\nint slot, u8 addr)\r\n{\r\nstruct netup_ci_state *state = en50221->data;\r\nstruct netup_unidvb_dev *dev = state->dev;\r\nu8 val = *((u8 __force *)state->membase8_io + addr);\r\ndev_dbg(&dev->pci_dev->dev,\r\n"%s(): addr=0x%x val=0x%x\n", __func__, addr, val);\r\nreturn val;\r\n}\r\nstatic int netup_unidvb_ci_write_cam_ctl(struct dvb_ca_en50221 *en50221,\r\nint slot, u8 addr, u8 data)\r\n{\r\nstruct netup_ci_state *state = en50221->data;\r\nstruct netup_unidvb_dev *dev = state->dev;\r\ndev_dbg(&dev->pci_dev->dev,\r\n"%s(): addr=0x%x data=0x%x\n", __func__, addr, data);\r\n*((u8 __force *)state->membase8_io + addr) = data;\r\nreturn 0;\r\n}\r\nint netup_unidvb_ci_register(struct netup_unidvb_dev *dev,\r\nint num, struct pci_dev *pci_dev)\r\n{\r\nint result;\r\nstruct netup_ci_state *state;\r\nif (num < 0 || num > 1) {\r\ndev_err(&pci_dev->dev, "%s(): invalid CI adapter %d\n",\r\n__func__, num);\r\nreturn -EINVAL;\r\n}\r\nstate = &dev->ci[num];\r\nstate->nr = num;\r\nstate->membase8_config = dev->bmmio1 +\r\n((num == 0) ? CAM0_CONFIG : CAM1_CONFIG);\r\nstate->membase8_io = dev->bmmio1 +\r\n((num == 0) ? CAM0_IO : CAM1_IO);\r\nstate->dev = dev;\r\nstate->ca.owner = THIS_MODULE;\r\nstate->ca.read_attribute_mem = netup_unidvb_ci_read_attribute_mem;\r\nstate->ca.write_attribute_mem = netup_unidvb_ci_write_attribute_mem;\r\nstate->ca.read_cam_control = netup_unidvb_ci_read_cam_ctl;\r\nstate->ca.write_cam_control = netup_unidvb_ci_write_cam_ctl;\r\nstate->ca.slot_reset = netup_unidvb_ci_slot_reset;\r\nstate->ca.slot_shutdown = netup_unidvb_ci_slot_shutdown;\r\nstate->ca.slot_ts_enable = netup_unidvb_ci_slot_ts_ctl;\r\nstate->ca.poll_slot_status = netup_unidvb_poll_ci_slot_status;\r\nstate->ca.data = state;\r\nresult = dvb_ca_en50221_init(&dev->frontends[num].adapter,\r\n&state->ca, 0, 1);\r\nif (result < 0) {\r\ndev_err(&pci_dev->dev,\r\n"%s(): dvb_ca_en50221_init result %d\n",\r\n__func__, result);\r\nreturn result;\r\n}\r\nwritew(NETUP_UNIDVB_IRQ_CI, dev->bmmio0 + REG_IMASK_SET);\r\ndev_info(&pci_dev->dev,\r\n"%s(): CI adapter %d init done\n", __func__, num);\r\nreturn 0;\r\n}\r\nvoid netup_unidvb_ci_unregister(struct netup_unidvb_dev *dev, int num)\r\n{\r\nstruct netup_ci_state *state;\r\ndev_dbg(&dev->pci_dev->dev, "%s()\n", __func__);\r\nif (num < 0 || num > 1) {\r\ndev_err(&dev->pci_dev->dev, "%s(): invalid CI adapter %d\n",\r\n__func__, num);\r\nreturn;\r\n}\r\nstate = &dev->ci[num];\r\ndvb_ca_en50221_release(&state->ca);\r\n}
