static void blk_mq_sysfs_release(struct kobject *kobj)\r\n{\r\n}\r\nstatic ssize_t blk_mq_sysfs_show(struct kobject *kobj, struct attribute *attr,\r\nchar *page)\r\n{\r\nstruct blk_mq_ctx_sysfs_entry *entry;\r\nstruct blk_mq_ctx *ctx;\r\nstruct request_queue *q;\r\nssize_t res;\r\nentry = container_of(attr, struct blk_mq_ctx_sysfs_entry, attr);\r\nctx = container_of(kobj, struct blk_mq_ctx, kobj);\r\nq = ctx->queue;\r\nif (!entry->show)\r\nreturn -EIO;\r\nres = -ENOENT;\r\nmutex_lock(&q->sysfs_lock);\r\nif (!blk_queue_dying(q))\r\nres = entry->show(ctx, page);\r\nmutex_unlock(&q->sysfs_lock);\r\nreturn res;\r\n}\r\nstatic ssize_t blk_mq_sysfs_store(struct kobject *kobj, struct attribute *attr,\r\nconst char *page, size_t length)\r\n{\r\nstruct blk_mq_ctx_sysfs_entry *entry;\r\nstruct blk_mq_ctx *ctx;\r\nstruct request_queue *q;\r\nssize_t res;\r\nentry = container_of(attr, struct blk_mq_ctx_sysfs_entry, attr);\r\nctx = container_of(kobj, struct blk_mq_ctx, kobj);\r\nq = ctx->queue;\r\nif (!entry->store)\r\nreturn -EIO;\r\nres = -ENOENT;\r\nmutex_lock(&q->sysfs_lock);\r\nif (!blk_queue_dying(q))\r\nres = entry->store(ctx, page, length);\r\nmutex_unlock(&q->sysfs_lock);\r\nreturn res;\r\n}\r\nstatic ssize_t blk_mq_hw_sysfs_show(struct kobject *kobj,\r\nstruct attribute *attr, char *page)\r\n{\r\nstruct blk_mq_hw_ctx_sysfs_entry *entry;\r\nstruct blk_mq_hw_ctx *hctx;\r\nstruct request_queue *q;\r\nssize_t res;\r\nentry = container_of(attr, struct blk_mq_hw_ctx_sysfs_entry, attr);\r\nhctx = container_of(kobj, struct blk_mq_hw_ctx, kobj);\r\nq = hctx->queue;\r\nif (!entry->show)\r\nreturn -EIO;\r\nres = -ENOENT;\r\nmutex_lock(&q->sysfs_lock);\r\nif (!blk_queue_dying(q))\r\nres = entry->show(hctx, page);\r\nmutex_unlock(&q->sysfs_lock);\r\nreturn res;\r\n}\r\nstatic ssize_t blk_mq_hw_sysfs_store(struct kobject *kobj,\r\nstruct attribute *attr, const char *page,\r\nsize_t length)\r\n{\r\nstruct blk_mq_hw_ctx_sysfs_entry *entry;\r\nstruct blk_mq_hw_ctx *hctx;\r\nstruct request_queue *q;\r\nssize_t res;\r\nentry = container_of(attr, struct blk_mq_hw_ctx_sysfs_entry, attr);\r\nhctx = container_of(kobj, struct blk_mq_hw_ctx, kobj);\r\nq = hctx->queue;\r\nif (!entry->store)\r\nreturn -EIO;\r\nres = -ENOENT;\r\nmutex_lock(&q->sysfs_lock);\r\nif (!blk_queue_dying(q))\r\nres = entry->store(hctx, page, length);\r\nmutex_unlock(&q->sysfs_lock);\r\nreturn res;\r\n}\r\nstatic ssize_t blk_mq_sysfs_dispatched_show(struct blk_mq_ctx *ctx, char *page)\r\n{\r\nreturn sprintf(page, "%lu %lu\n", ctx->rq_dispatched[1],\r\nctx->rq_dispatched[0]);\r\n}\r\nstatic ssize_t blk_mq_sysfs_merged_show(struct blk_mq_ctx *ctx, char *page)\r\n{\r\nreturn sprintf(page, "%lu\n", ctx->rq_merged);\r\n}\r\nstatic ssize_t blk_mq_sysfs_completed_show(struct blk_mq_ctx *ctx, char *page)\r\n{\r\nreturn sprintf(page, "%lu %lu\n", ctx->rq_completed[1],\r\nctx->rq_completed[0]);\r\n}\r\nstatic ssize_t sysfs_list_show(char *page, struct list_head *list, char *msg)\r\n{\r\nstruct request *rq;\r\nint len = snprintf(page, PAGE_SIZE - 1, "%s:\n", msg);\r\nlist_for_each_entry(rq, list, queuelist) {\r\nconst int rq_len = 2 * sizeof(rq) + 2;\r\nif (PAGE_SIZE - 1 < len + rq_len) {\r\nif (PAGE_SIZE - 1 < len + 5)\r\nlen -= rq_len;\r\nlen += snprintf(page + len, PAGE_SIZE - 1 - len,\r\n"\t...\n");\r\nbreak;\r\n}\r\nlen += snprintf(page + len, PAGE_SIZE - 1 - len,\r\n"\t%p\n", rq);\r\n}\r\nreturn len;\r\n}\r\nstatic ssize_t blk_mq_sysfs_rq_list_show(struct blk_mq_ctx *ctx, char *page)\r\n{\r\nssize_t ret;\r\nspin_lock(&ctx->lock);\r\nret = sysfs_list_show(page, &ctx->rq_list, "CTX pending");\r\nspin_unlock(&ctx->lock);\r\nreturn ret;\r\n}\r\nstatic ssize_t blk_mq_hw_sysfs_poll_show(struct blk_mq_hw_ctx *hctx, char *page)\r\n{\r\nreturn sprintf(page, "invoked=%lu, success=%lu\n", hctx->poll_invoked, hctx->poll_success);\r\n}\r\nstatic ssize_t blk_mq_hw_sysfs_queued_show(struct blk_mq_hw_ctx *hctx,\r\nchar *page)\r\n{\r\nreturn sprintf(page, "%lu\n", hctx->queued);\r\n}\r\nstatic ssize_t blk_mq_hw_sysfs_run_show(struct blk_mq_hw_ctx *hctx, char *page)\r\n{\r\nreturn sprintf(page, "%lu\n", hctx->run);\r\n}\r\nstatic ssize_t blk_mq_hw_sysfs_dispatched_show(struct blk_mq_hw_ctx *hctx,\r\nchar *page)\r\n{\r\nchar *start_page = page;\r\nint i;\r\npage += sprintf(page, "%8u\t%lu\n", 0U, hctx->dispatched[0]);\r\nfor (i = 1; i < BLK_MQ_MAX_DISPATCH_ORDER; i++) {\r\nunsigned long d = 1U << (i - 1);\r\npage += sprintf(page, "%8lu\t%lu\n", d, hctx->dispatched[i]);\r\n}\r\nreturn page - start_page;\r\n}\r\nstatic ssize_t blk_mq_hw_sysfs_rq_list_show(struct blk_mq_hw_ctx *hctx,\r\nchar *page)\r\n{\r\nssize_t ret;\r\nspin_lock(&hctx->lock);\r\nret = sysfs_list_show(page, &hctx->dispatch, "HCTX pending");\r\nspin_unlock(&hctx->lock);\r\nreturn ret;\r\n}\r\nstatic ssize_t blk_mq_hw_sysfs_tags_show(struct blk_mq_hw_ctx *hctx, char *page)\r\n{\r\nreturn blk_mq_tag_sysfs_show(hctx->tags, page);\r\n}\r\nstatic ssize_t blk_mq_hw_sysfs_active_show(struct blk_mq_hw_ctx *hctx, char *page)\r\n{\r\nreturn sprintf(page, "%u\n", atomic_read(&hctx->nr_active));\r\n}\r\nstatic ssize_t blk_mq_hw_sysfs_cpus_show(struct blk_mq_hw_ctx *hctx, char *page)\r\n{\r\nunsigned int i, first = 1;\r\nssize_t ret = 0;\r\nfor_each_cpu(i, hctx->cpumask) {\r\nif (first)\r\nret += sprintf(ret + page, "%u", i);\r\nelse\r\nret += sprintf(ret + page, ", %u", i);\r\nfirst = 0;\r\n}\r\nret += sprintf(ret + page, "\n");\r\nreturn ret;\r\n}\r\nstatic void blk_mq_unregister_hctx(struct blk_mq_hw_ctx *hctx)\r\n{\r\nstruct blk_mq_ctx *ctx;\r\nint i;\r\nif (!hctx->nr_ctx)\r\nreturn;\r\nhctx_for_each_ctx(hctx, ctx, i)\r\nkobject_del(&ctx->kobj);\r\nkobject_del(&hctx->kobj);\r\n}\r\nstatic int blk_mq_register_hctx(struct blk_mq_hw_ctx *hctx)\r\n{\r\nstruct request_queue *q = hctx->queue;\r\nstruct blk_mq_ctx *ctx;\r\nint i, ret;\r\nif (!hctx->nr_ctx)\r\nreturn 0;\r\nret = kobject_add(&hctx->kobj, &q->mq_kobj, "%u", hctx->queue_num);\r\nif (ret)\r\nreturn ret;\r\nhctx_for_each_ctx(hctx, ctx, i) {\r\nret = kobject_add(&ctx->kobj, &hctx->kobj, "cpu%u", ctx->cpu);\r\nif (ret)\r\nbreak;\r\n}\r\nreturn ret;\r\n}\r\nvoid blk_mq_unregister_disk(struct gendisk *disk)\r\n{\r\nstruct request_queue *q = disk->queue;\r\nstruct blk_mq_hw_ctx *hctx;\r\nstruct blk_mq_ctx *ctx;\r\nint i, j;\r\nblk_mq_disable_hotplug();\r\nqueue_for_each_hw_ctx(q, hctx, i) {\r\nblk_mq_unregister_hctx(hctx);\r\nhctx_for_each_ctx(hctx, ctx, j)\r\nkobject_put(&ctx->kobj);\r\nkobject_put(&hctx->kobj);\r\n}\r\nkobject_uevent(&q->mq_kobj, KOBJ_REMOVE);\r\nkobject_del(&q->mq_kobj);\r\nkobject_put(&q->mq_kobj);\r\nkobject_put(&disk_to_dev(disk)->kobj);\r\nq->mq_sysfs_init_done = false;\r\nblk_mq_enable_hotplug();\r\n}\r\nstatic void blk_mq_sysfs_init(struct request_queue *q)\r\n{\r\nstruct blk_mq_hw_ctx *hctx;\r\nstruct blk_mq_ctx *ctx;\r\nint i;\r\nkobject_init(&q->mq_kobj, &blk_mq_ktype);\r\nqueue_for_each_hw_ctx(q, hctx, i)\r\nkobject_init(&hctx->kobj, &blk_mq_hw_ktype);\r\nqueue_for_each_ctx(q, ctx, i)\r\nkobject_init(&ctx->kobj, &blk_mq_ctx_ktype);\r\n}\r\nint blk_mq_register_disk(struct gendisk *disk)\r\n{\r\nstruct device *dev = disk_to_dev(disk);\r\nstruct request_queue *q = disk->queue;\r\nstruct blk_mq_hw_ctx *hctx;\r\nint ret, i;\r\nblk_mq_disable_hotplug();\r\nblk_mq_sysfs_init(q);\r\nret = kobject_add(&q->mq_kobj, kobject_get(&dev->kobj), "%s", "mq");\r\nif (ret < 0)\r\ngoto out;\r\nkobject_uevent(&q->mq_kobj, KOBJ_ADD);\r\nqueue_for_each_hw_ctx(q, hctx, i) {\r\nret = blk_mq_register_hctx(hctx);\r\nif (ret)\r\nbreak;\r\n}\r\nif (ret)\r\nblk_mq_unregister_disk(disk);\r\nelse\r\nq->mq_sysfs_init_done = true;\r\nout:\r\nblk_mq_enable_hotplug();\r\nreturn ret;\r\n}\r\nvoid blk_mq_sysfs_unregister(struct request_queue *q)\r\n{\r\nstruct blk_mq_hw_ctx *hctx;\r\nint i;\r\nif (!q->mq_sysfs_init_done)\r\nreturn;\r\nqueue_for_each_hw_ctx(q, hctx, i)\r\nblk_mq_unregister_hctx(hctx);\r\n}\r\nint blk_mq_sysfs_register(struct request_queue *q)\r\n{\r\nstruct blk_mq_hw_ctx *hctx;\r\nint i, ret = 0;\r\nif (!q->mq_sysfs_init_done)\r\nreturn ret;\r\nqueue_for_each_hw_ctx(q, hctx, i) {\r\nret = blk_mq_register_hctx(hctx);\r\nif (ret)\r\nbreak;\r\n}\r\nreturn ret;\r\n}
