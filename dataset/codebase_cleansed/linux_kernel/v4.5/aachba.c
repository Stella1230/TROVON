static inline int aac_valid_context(struct scsi_cmnd *scsicmd,\r\nstruct fib *fibptr) {\r\nstruct scsi_device *device;\r\nif (unlikely(!scsicmd || !scsicmd->scsi_done)) {\r\ndprintk((KERN_WARNING "aac_valid_context: scsi command corrupt\n"));\r\naac_fib_complete(fibptr);\r\naac_fib_free(fibptr);\r\nreturn 0;\r\n}\r\nscsicmd->SCp.phase = AAC_OWNER_MIDLEVEL;\r\ndevice = scsicmd->device;\r\nif (unlikely(!device || !scsi_device_online(device))) {\r\ndprintk((KERN_WARNING "aac_valid_context: scsi device corrupt\n"));\r\naac_fib_complete(fibptr);\r\naac_fib_free(fibptr);\r\nreturn 0;\r\n}\r\nreturn 1;\r\n}\r\nint aac_get_config_status(struct aac_dev *dev, int commit_flag)\r\n{\r\nint status = 0;\r\nstruct fib * fibptr;\r\nif (!(fibptr = aac_fib_alloc(dev)))\r\nreturn -ENOMEM;\r\naac_fib_init(fibptr);\r\n{\r\nstruct aac_get_config_status *dinfo;\r\ndinfo = (struct aac_get_config_status *) fib_data(fibptr);\r\ndinfo->command = cpu_to_le32(VM_ContainerConfig);\r\ndinfo->type = cpu_to_le32(CT_GET_CONFIG_STATUS);\r\ndinfo->count = cpu_to_le32(sizeof(((struct aac_get_config_status_resp *)NULL)->data));\r\n}\r\nstatus = aac_fib_send(ContainerCommand,\r\nfibptr,\r\nsizeof (struct aac_get_config_status),\r\nFsaNormal,\r\n1, 1,\r\nNULL, NULL);\r\nif (status < 0) {\r\nprintk(KERN_WARNING "aac_get_config_status: SendFIB failed.\n");\r\n} else {\r\nstruct aac_get_config_status_resp *reply\r\n= (struct aac_get_config_status_resp *) fib_data(fibptr);\r\ndprintk((KERN_WARNING\r\n"aac_get_config_status: response=%d status=%d action=%d\n",\r\nle32_to_cpu(reply->response),\r\nle32_to_cpu(reply->status),\r\nle32_to_cpu(reply->data.action)));\r\nif ((le32_to_cpu(reply->response) != ST_OK) ||\r\n(le32_to_cpu(reply->status) != CT_OK) ||\r\n(le32_to_cpu(reply->data.action) > CFACT_PAUSE)) {\r\nprintk(KERN_WARNING "aac_get_config_status: Will not issue the Commit Configuration\n");\r\nstatus = -EINVAL;\r\n}\r\n}\r\nif (status >= 0)\r\naac_fib_complete(fibptr);\r\nif (status >= 0) {\r\nif ((aac_commit == 1) || commit_flag) {\r\nstruct aac_commit_config * dinfo;\r\naac_fib_init(fibptr);\r\ndinfo = (struct aac_commit_config *) fib_data(fibptr);\r\ndinfo->command = cpu_to_le32(VM_ContainerConfig);\r\ndinfo->type = cpu_to_le32(CT_COMMIT_CONFIG);\r\nstatus = aac_fib_send(ContainerCommand,\r\nfibptr,\r\nsizeof (struct aac_commit_config),\r\nFsaNormal,\r\n1, 1,\r\nNULL, NULL);\r\nif (status >= 0)\r\naac_fib_complete(fibptr);\r\n} else if (aac_commit == 0) {\r\nprintk(KERN_WARNING\r\n"aac_get_config_status: Foreign device configurations are being ignored\n");\r\n}\r\n}\r\nif (status != -ERESTARTSYS)\r\naac_fib_free(fibptr);\r\nreturn status;\r\n}\r\nstatic void aac_expose_phy_device(struct scsi_cmnd *scsicmd)\r\n{\r\nchar inq_data;\r\nscsi_sg_copy_to_buffer(scsicmd, &inq_data, sizeof(inq_data));\r\nif ((inq_data & 0x20) && (inq_data & 0x1f) == TYPE_DISK) {\r\ninq_data &= 0xdf;\r\nscsi_sg_copy_from_buffer(scsicmd, &inq_data, sizeof(inq_data));\r\n}\r\n}\r\nint aac_get_containers(struct aac_dev *dev)\r\n{\r\nstruct fsa_dev_info *fsa_dev_ptr;\r\nu32 index;\r\nint status = 0;\r\nstruct fib * fibptr;\r\nstruct aac_get_container_count *dinfo;\r\nstruct aac_get_container_count_resp *dresp;\r\nint maximum_num_containers = MAXIMUM_NUM_CONTAINERS;\r\nif (!(fibptr = aac_fib_alloc(dev)))\r\nreturn -ENOMEM;\r\naac_fib_init(fibptr);\r\ndinfo = (struct aac_get_container_count *) fib_data(fibptr);\r\ndinfo->command = cpu_to_le32(VM_ContainerConfig);\r\ndinfo->type = cpu_to_le32(CT_GET_CONTAINER_COUNT);\r\nstatus = aac_fib_send(ContainerCommand,\r\nfibptr,\r\nsizeof (struct aac_get_container_count),\r\nFsaNormal,\r\n1, 1,\r\nNULL, NULL);\r\nif (status >= 0) {\r\ndresp = (struct aac_get_container_count_resp *)fib_data(fibptr);\r\nmaximum_num_containers = le32_to_cpu(dresp->ContainerSwitchEntries);\r\nif (fibptr->dev->supplement_adapter_info.SupportedOptions2 &\r\nAAC_OPTION_SUPPORTED_240_VOLUMES) {\r\nmaximum_num_containers =\r\nle32_to_cpu(dresp->MaxSimpleVolumes);\r\n}\r\naac_fib_complete(fibptr);\r\n}\r\nif (status != -ERESTARTSYS)\r\naac_fib_free(fibptr);\r\nif (maximum_num_containers < MAXIMUM_NUM_CONTAINERS)\r\nmaximum_num_containers = MAXIMUM_NUM_CONTAINERS;\r\nfsa_dev_ptr = kzalloc(sizeof(*fsa_dev_ptr) * maximum_num_containers,\r\nGFP_KERNEL);\r\nif (!fsa_dev_ptr)\r\nreturn -ENOMEM;\r\ndev->fsa_dev = fsa_dev_ptr;\r\ndev->maximum_num_containers = maximum_num_containers;\r\nfor (index = 0; index < dev->maximum_num_containers; ) {\r\nfsa_dev_ptr[index].devname[0] = '\0';\r\nstatus = aac_probe_container(dev, index);\r\nif (status < 0) {\r\nprintk(KERN_WARNING "aac_get_containers: SendFIB failed.\n");\r\nbreak;\r\n}\r\nif (++index >= status)\r\nbreak;\r\n}\r\nreturn status;\r\n}\r\nstatic void get_container_name_callback(void *context, struct fib * fibptr)\r\n{\r\nstruct aac_get_name_resp * get_name_reply;\r\nstruct scsi_cmnd * scsicmd;\r\nscsicmd = (struct scsi_cmnd *) context;\r\nif (!aac_valid_context(scsicmd, fibptr))\r\nreturn;\r\ndprintk((KERN_DEBUG "get_container_name_callback[cpu %d]: t = %ld.\n", smp_processor_id(), jiffies));\r\nBUG_ON(fibptr == NULL);\r\nget_name_reply = (struct aac_get_name_resp *) fib_data(fibptr);\r\nif ((le32_to_cpu(get_name_reply->status) == CT_OK)\r\n&& (get_name_reply->data[0] != '\0')) {\r\nchar *sp = get_name_reply->data;\r\nsp[sizeof(((struct aac_get_name_resp *)NULL)->data\r\nint aac_get_container_name(struct scsi_cmnd * scsicmd)\r\n{\r\nint status;\r\nstruct aac_get_name *dinfo;\r\nstruct fib * cmd_fibcontext;\r\nstruct aac_dev * dev;\r\ndev = (struct aac_dev *)scsicmd->device->host->hostdata;\r\nif (!(cmd_fibcontext = aac_fib_alloc(dev)))\r\nreturn -ENOMEM;\r\naac_fib_init(cmd_fibcontext);\r\ndinfo = (struct aac_get_name *) fib_data(cmd_fibcontext);\r\ndinfo->command = cpu_to_le32(VM_ContainerConfig);\r\ndinfo->type = cpu_to_le32(CT_READ_NAME);\r\ndinfo->cid = cpu_to_le32(scmd_id(scsicmd));\r\ndinfo->count = cpu_to_le32(sizeof(((struct aac_get_name_resp *)NULL)->data));\r\nstatus = aac_fib_send(ContainerCommand,\r\ncmd_fibcontext,\r\nsizeof(struct aac_get_name_resp),\r\nFsaNormal,\r\n0, 1,\r\n(fib_callback)get_container_name_callback,\r\n(void *) scsicmd);\r\nif (status == -EINPROGRESS) {\r\nscsicmd->SCp.phase = AAC_OWNER_FIRMWARE;\r\nreturn 0;\r\n}\r\nprintk(KERN_WARNING "aac_get_container_name: aac_fib_send failed with status: %d.\n", status);\r\naac_fib_complete(cmd_fibcontext);\r\naac_fib_free(cmd_fibcontext);\r\nreturn -1;\r\n}\r\nstatic int aac_probe_container_callback2(struct scsi_cmnd * scsicmd)\r\n{\r\nstruct fsa_dev_info *fsa_dev_ptr = ((struct aac_dev *)(scsicmd->device->host->hostdata))->fsa_dev;\r\nif ((fsa_dev_ptr[scmd_id(scsicmd)].valid & 1))\r\nreturn aac_scsi_cmd(scsicmd);\r\nscsicmd->result = DID_NO_CONNECT << 16;\r\nscsicmd->scsi_done(scsicmd);\r\nreturn 0;\r\n}\r\nstatic void _aac_probe_container2(void * context, struct fib * fibptr)\r\n{\r\nstruct fsa_dev_info *fsa_dev_ptr;\r\nint (*callback)(struct scsi_cmnd *);\r\nstruct scsi_cmnd * scsicmd = (struct scsi_cmnd *)context;\r\nif (!aac_valid_context(scsicmd, fibptr))\r\nreturn;\r\nscsicmd->SCp.Status = 0;\r\nfsa_dev_ptr = fibptr->dev->fsa_dev;\r\nif (fsa_dev_ptr) {\r\nstruct aac_mount * dresp = (struct aac_mount *) fib_data(fibptr);\r\nfsa_dev_ptr += scmd_id(scsicmd);\r\nif ((le32_to_cpu(dresp->status) == ST_OK) &&\r\n(le32_to_cpu(dresp->mnt[0].vol) != CT_NONE) &&\r\n(le32_to_cpu(dresp->mnt[0].state) != FSCS_HIDDEN)) {\r\nif (!(fibptr->dev->supplement_adapter_info.SupportedOptions2 &\r\nAAC_OPTION_VARIABLE_BLOCK_SIZE)) {\r\ndresp->mnt[0].fileinfo.bdevinfo.block_size = 0x200;\r\nfsa_dev_ptr->block_size = 0x200;\r\n} else {\r\nfsa_dev_ptr->block_size =\r\nle32_to_cpu(dresp->mnt[0].fileinfo.bdevinfo.block_size);\r\n}\r\nfsa_dev_ptr->valid = 1;\r\nif (dresp->mnt[0].state & cpu_to_le32(FSCS_NOT_READY))\r\nfsa_dev_ptr->sense_data.sense_key = NOT_READY;\r\nelse if (fsa_dev_ptr->sense_data.sense_key == NOT_READY)\r\nfsa_dev_ptr->sense_data.sense_key = NO_SENSE;\r\nfsa_dev_ptr->type = le32_to_cpu(dresp->mnt[0].vol);\r\nfsa_dev_ptr->size\r\n= ((u64)le32_to_cpu(dresp->mnt[0].capacity)) +\r\n(((u64)le32_to_cpu(dresp->mnt[0].capacityhigh)) << 32);\r\nfsa_dev_ptr->ro = ((le32_to_cpu(dresp->mnt[0].state) & FSCS_READONLY) != 0);\r\n}\r\nif ((fsa_dev_ptr->valid & 1) == 0)\r\nfsa_dev_ptr->valid = 0;\r\nscsicmd->SCp.Status = le32_to_cpu(dresp->count);\r\n}\r\naac_fib_complete(fibptr);\r\naac_fib_free(fibptr);\r\ncallback = (int (*)(struct scsi_cmnd *))(scsicmd->SCp.ptr);\r\nscsicmd->SCp.ptr = NULL;\r\n(*callback)(scsicmd);\r\nreturn;\r\n}\r\nstatic void _aac_probe_container1(void * context, struct fib * fibptr)\r\n{\r\nstruct scsi_cmnd * scsicmd;\r\nstruct aac_mount * dresp;\r\nstruct aac_query_mount *dinfo;\r\nint status;\r\ndresp = (struct aac_mount *) fib_data(fibptr);\r\nif (!(fibptr->dev->supplement_adapter_info.SupportedOptions2 &\r\nAAC_OPTION_VARIABLE_BLOCK_SIZE))\r\ndresp->mnt[0].capacityhigh = 0;\r\nif ((le32_to_cpu(dresp->status) != ST_OK) ||\r\n(le32_to_cpu(dresp->mnt[0].vol) != CT_NONE)) {\r\n_aac_probe_container2(context, fibptr);\r\nreturn;\r\n}\r\nscsicmd = (struct scsi_cmnd *) context;\r\nif (!aac_valid_context(scsicmd, fibptr))\r\nreturn;\r\naac_fib_init(fibptr);\r\ndinfo = (struct aac_query_mount *)fib_data(fibptr);\r\nif (fibptr->dev->supplement_adapter_info.SupportedOptions2 &\r\nAAC_OPTION_VARIABLE_BLOCK_SIZE)\r\ndinfo->command = cpu_to_le32(VM_NameServeAllBlk);\r\nelse\r\ndinfo->command = cpu_to_le32(VM_NameServe64);\r\ndinfo->count = cpu_to_le32(scmd_id(scsicmd));\r\ndinfo->type = cpu_to_le32(FT_FILESYS);\r\nstatus = aac_fib_send(ContainerCommand,\r\nfibptr,\r\nsizeof(struct aac_query_mount),\r\nFsaNormal,\r\n0, 1,\r\n_aac_probe_container2,\r\n(void *) scsicmd);\r\nif (status == -EINPROGRESS)\r\nscsicmd->SCp.phase = AAC_OWNER_FIRMWARE;\r\nelse if (status < 0) {\r\ndresp->status = cpu_to_le32(ST_OK);\r\n_aac_probe_container2(context, fibptr);\r\n}\r\n}\r\nstatic int _aac_probe_container(struct scsi_cmnd * scsicmd, int (*callback)(struct scsi_cmnd *))\r\n{\r\nstruct fib * fibptr;\r\nint status = -ENOMEM;\r\nif ((fibptr = aac_fib_alloc((struct aac_dev *)scsicmd->device->host->hostdata))) {\r\nstruct aac_query_mount *dinfo;\r\naac_fib_init(fibptr);\r\ndinfo = (struct aac_query_mount *)fib_data(fibptr);\r\nif (fibptr->dev->supplement_adapter_info.SupportedOptions2 &\r\nAAC_OPTION_VARIABLE_BLOCK_SIZE)\r\ndinfo->command = cpu_to_le32(VM_NameServeAllBlk);\r\nelse\r\ndinfo->command = cpu_to_le32(VM_NameServe);\r\ndinfo->count = cpu_to_le32(scmd_id(scsicmd));\r\ndinfo->type = cpu_to_le32(FT_FILESYS);\r\nscsicmd->SCp.ptr = (char *)callback;\r\nstatus = aac_fib_send(ContainerCommand,\r\nfibptr,\r\nsizeof(struct aac_query_mount),\r\nFsaNormal,\r\n0, 1,\r\n_aac_probe_container1,\r\n(void *) scsicmd);\r\nif (status == -EINPROGRESS) {\r\nscsicmd->SCp.phase = AAC_OWNER_FIRMWARE;\r\nreturn 0;\r\n}\r\nif (status < 0) {\r\nscsicmd->SCp.ptr = NULL;\r\naac_fib_complete(fibptr);\r\naac_fib_free(fibptr);\r\n}\r\n}\r\nif (status < 0) {\r\nstruct fsa_dev_info *fsa_dev_ptr = ((struct aac_dev *)(scsicmd->device->host->hostdata))->fsa_dev;\r\nif (fsa_dev_ptr) {\r\nfsa_dev_ptr += scmd_id(scsicmd);\r\nif ((fsa_dev_ptr->valid & 1) == 0) {\r\nfsa_dev_ptr->valid = 0;\r\nreturn (*callback)(scsicmd);\r\n}\r\n}\r\n}\r\nreturn status;\r\n}\r\nstatic int aac_probe_container_callback1(struct scsi_cmnd * scsicmd)\r\n{\r\nscsicmd->device = NULL;\r\nreturn 0;\r\n}\r\nint aac_probe_container(struct aac_dev *dev, int cid)\r\n{\r\nstruct scsi_cmnd *scsicmd = kmalloc(sizeof(*scsicmd), GFP_KERNEL);\r\nstruct scsi_device *scsidev = kmalloc(sizeof(*scsidev), GFP_KERNEL);\r\nint status;\r\nif (!scsicmd || !scsidev) {\r\nkfree(scsicmd);\r\nkfree(scsidev);\r\nreturn -ENOMEM;\r\n}\r\nscsicmd->list.next = NULL;\r\nscsicmd->scsi_done = (void (*)(struct scsi_cmnd*))aac_probe_container_callback1;\r\nscsicmd->device = scsidev;\r\nscsidev->sdev_state = 0;\r\nscsidev->id = cid;\r\nscsidev->host = dev->scsi_host_ptr;\r\nif (_aac_probe_container(scsicmd, aac_probe_container_callback1) == 0)\r\nwhile (scsicmd->device == scsidev)\r\nschedule();\r\nkfree(scsidev);\r\nstatus = scsicmd->SCp.Status;\r\nkfree(scsicmd);\r\nreturn status;\r\n}\r\nstatic void inqstrcpy(char *a, char *b)\r\n{\r\nwhile (*a != (char)0)\r\n*b++ = *a++;\r\n}\r\nchar * get_container_type(unsigned tindex)\r\n{\r\nif (tindex >= ARRAY_SIZE(container_types))\r\ntindex = ARRAY_SIZE(container_types) - 1;\r\nreturn container_types[tindex];\r\n}\r\nstatic void setinqstr(struct aac_dev *dev, void *data, int tindex)\r\n{\r\nstruct scsi_inq *str;\r\nstr = (struct scsi_inq *)(data);\r\nmemset(str, ' ', sizeof(*str));\r\nif (dev->supplement_adapter_info.AdapterTypeText[0]) {\r\nchar * cp = dev->supplement_adapter_info.AdapterTypeText;\r\nint c;\r\nif ((cp[0] == 'A') && (cp[1] == 'O') && (cp[2] == 'C'))\r\ninqstrcpy("SMC", str->vid);\r\nelse {\r\nc = sizeof(str->vid);\r\nwhile (*cp && *cp != ' ' && --c)\r\n++cp;\r\nc = *cp;\r\n*cp = '\0';\r\ninqstrcpy (dev->supplement_adapter_info.AdapterTypeText,\r\nstr->vid);\r\n*cp = c;\r\nwhile (*cp && *cp != ' ')\r\n++cp;\r\n}\r\nwhile (*cp == ' ')\r\n++cp;\r\nc = 0;\r\nif (strlen(cp) > sizeof(str->pid)) {\r\nc = cp[sizeof(str->pid)];\r\ncp[sizeof(str->pid)] = '\0';\r\n}\r\ninqstrcpy (cp, str->pid);\r\nif (c)\r\ncp[sizeof(str->pid)] = c;\r\n} else {\r\nstruct aac_driver_ident *mp = aac_get_driver_ident(dev->cardtype);\r\ninqstrcpy (mp->vname, str->vid);\r\ninqstrcpy (mp->model, str->pid);\r\n}\r\nif (tindex < ARRAY_SIZE(container_types)){\r\nchar *findit = str->pid;\r\nfor ( ; *findit != ' '; findit++);\r\nif (memcmp(findit-4, "RAID", 4) == 0)\r\n*(findit -= 4) = ' ';\r\nif (((findit - str->pid) + strlen(container_types[tindex]))\r\n< (sizeof(str->pid) + sizeof(str->prl)))\r\ninqstrcpy (container_types[tindex], findit + 1);\r\n}\r\ninqstrcpy ("V1.0", str->prl);\r\n}\r\nstatic void get_container_serial_callback(void *context, struct fib * fibptr)\r\n{\r\nstruct aac_get_serial_resp * get_serial_reply;\r\nstruct scsi_cmnd * scsicmd;\r\nBUG_ON(fibptr == NULL);\r\nscsicmd = (struct scsi_cmnd *) context;\r\nif (!aac_valid_context(scsicmd, fibptr))\r\nreturn;\r\nget_serial_reply = (struct aac_get_serial_resp *) fib_data(fibptr);\r\nif (le32_to_cpu(get_serial_reply->status) == CT_OK) {\r\nif (scsicmd->cmnd[2] == 0x83) {\r\nint i;\r\nTVPD_Page83 VPDPage83Data;\r\nmemset(((u8 *)&VPDPage83Data), 0,\r\nsizeof(VPDPage83Data));\r\nVPDPage83Data.DeviceType = 0;\r\nVPDPage83Data.DeviceTypeQualifier = 0;\r\nVPDPage83Data.PageCode = 0x83;\r\nVPDPage83Data.Reserved = 0;\r\nVPDPage83Data.PageLength =\r\nsizeof(VPDPage83Data.IdDescriptorType1) +\r\nsizeof(VPDPage83Data.IdDescriptorType2);\r\nVPDPage83Data.IdDescriptorType1.CodeSet = 2;\r\nVPDPage83Data.IdDescriptorType1.IdentifierType = 1;\r\nVPDPage83Data.IdDescriptorType1.IdentifierLength =\r\nsizeof(VPDPage83Data.IdDescriptorType1) - 4;\r\nmemcpy(VPDPage83Data.IdDescriptorType1.VendId,\r\n"ADAPTEC ",\r\nsizeof(VPDPage83Data.IdDescriptorType1.VendId));\r\nmemcpy(VPDPage83Data.IdDescriptorType1.ProductId,\r\n"ARRAY ",\r\nsizeof(\r\nVPDPage83Data.IdDescriptorType1.ProductId));\r\nfor (i = 0; i < 8; i++) {\r\nu8 temp =\r\n(u8)((get_serial_reply->uid >> ((7 - i) * 4)) & 0xF);\r\nif (temp > 0x9) {\r\nVPDPage83Data.IdDescriptorType1.SerialNumber[i] =\r\n'A' + (temp - 0xA);\r\n} else {\r\nVPDPage83Data.IdDescriptorType1.SerialNumber[i] =\r\n'0' + temp;\r\n}\r\n}\r\nVPDPage83Data.IdDescriptorType2.CodeSet = 1;\r\nVPDPage83Data.IdDescriptorType2.IdentifierType = 2;\r\nVPDPage83Data.IdDescriptorType2.IdentifierLength =\r\nsizeof(VPDPage83Data.IdDescriptorType2) - 4;\r\nVPDPage83Data.IdDescriptorType2.EU64Id.VendId[0] = 0xD0;\r\nVPDPage83Data.IdDescriptorType2.EU64Id.VendId[1] = 0;\r\nVPDPage83Data.IdDescriptorType2.EU64Id.VendId[2] = 0;\r\nVPDPage83Data.IdDescriptorType2.EU64Id.Serial =\r\nget_serial_reply->uid;\r\nVPDPage83Data.IdDescriptorType2.EU64Id.Reserved = 0;\r\nscsi_sg_copy_from_buffer(scsicmd, &VPDPage83Data,\r\nsizeof(VPDPage83Data));\r\n} else {\r\nchar sp[13];\r\nsp[0] = INQD_PDT_DA;\r\nsp[1] = scsicmd->cmnd[2];\r\nsp[2] = 0;\r\nsp[3] = snprintf(sp+4, sizeof(sp)-4, "%08X",\r\nle32_to_cpu(get_serial_reply->uid));\r\nscsi_sg_copy_from_buffer(scsicmd, sp,\r\nsizeof(sp));\r\n}\r\n}\r\nscsicmd->result = DID_OK << 16 | COMMAND_COMPLETE << 8 | SAM_STAT_GOOD;\r\naac_fib_complete(fibptr);\r\naac_fib_free(fibptr);\r\nscsicmd->scsi_done(scsicmd);\r\n}\r\nstatic int aac_get_container_serial(struct scsi_cmnd * scsicmd)\r\n{\r\nint status;\r\nstruct aac_get_serial *dinfo;\r\nstruct fib * cmd_fibcontext;\r\nstruct aac_dev * dev;\r\ndev = (struct aac_dev *)scsicmd->device->host->hostdata;\r\nif (!(cmd_fibcontext = aac_fib_alloc(dev)))\r\nreturn -ENOMEM;\r\naac_fib_init(cmd_fibcontext);\r\ndinfo = (struct aac_get_serial *) fib_data(cmd_fibcontext);\r\ndinfo->command = cpu_to_le32(VM_ContainerConfig);\r\ndinfo->type = cpu_to_le32(CT_CID_TO_32BITS_UID);\r\ndinfo->cid = cpu_to_le32(scmd_id(scsicmd));\r\nstatus = aac_fib_send(ContainerCommand,\r\ncmd_fibcontext,\r\nsizeof(struct aac_get_serial_resp),\r\nFsaNormal,\r\n0, 1,\r\n(fib_callback) get_container_serial_callback,\r\n(void *) scsicmd);\r\nif (status == -EINPROGRESS) {\r\nscsicmd->SCp.phase = AAC_OWNER_FIRMWARE;\r\nreturn 0;\r\n}\r\nprintk(KERN_WARNING "aac_get_container_serial: aac_fib_send failed with status: %d.\n", status);\r\naac_fib_complete(cmd_fibcontext);\r\naac_fib_free(cmd_fibcontext);\r\nreturn -1;\r\n}\r\nstatic int setinqserial(struct aac_dev *dev, void *data, int cid)\r\n{\r\nreturn snprintf((char *)(data), sizeof(struct scsi_inq) - 4, "%08X%02X",\r\nle32_to_cpu(dev->adapter_info.serial[0]), cid);\r\n}\r\nstatic inline void set_sense(struct sense_data *sense_data, u8 sense_key,\r\nu8 sense_code, u8 a_sense_code, u8 bit_pointer, u16 field_pointer)\r\n{\r\nu8 *sense_buf = (u8 *)sense_data;\r\nsense_buf[0] = 0x70;\r\nsense_buf[1] = 0;\r\nsense_buf[2] = sense_key;\r\nsense_buf[12] = sense_code;\r\nsense_buf[13] = a_sense_code;\r\nif (sense_key == ILLEGAL_REQUEST) {\r\nsense_buf[7] = 10;\r\nsense_buf[15] = bit_pointer;\r\nif (sense_code == SENCODE_INVALID_CDB_FIELD)\r\nsense_buf[15] |= 0xc0;\r\nsense_buf[16] = field_pointer >> 8;\r\nsense_buf[17] = field_pointer;\r\n} else\r\nsense_buf[7] = 6;\r\n}\r\nstatic int aac_bounds_32(struct aac_dev * dev, struct scsi_cmnd * cmd, u64 lba)\r\n{\r\nif (lba & 0xffffffff00000000LL) {\r\nint cid = scmd_id(cmd);\r\ndprintk((KERN_DEBUG "aacraid: Illegal lba\n"));\r\ncmd->result = DID_OK << 16 | COMMAND_COMPLETE << 8 |\r\nSAM_STAT_CHECK_CONDITION;\r\nset_sense(&dev->fsa_dev[cid].sense_data,\r\nHARDWARE_ERROR, SENCODE_INTERNAL_TARGET_FAILURE,\r\nASENCODE_INTERNAL_TARGET_FAILURE, 0, 0);\r\nmemcpy(cmd->sense_buffer, &dev->fsa_dev[cid].sense_data,\r\nmin_t(size_t, sizeof(dev->fsa_dev[cid].sense_data),\r\nSCSI_SENSE_BUFFERSIZE));\r\ncmd->scsi_done(cmd);\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}\r\nstatic int aac_bounds_64(struct aac_dev * dev, struct scsi_cmnd * cmd, u64 lba)\r\n{\r\nreturn 0;\r\n}\r\nstatic int aac_read_raw_io(struct fib * fib, struct scsi_cmnd * cmd, u64 lba, u32 count)\r\n{\r\nstruct aac_dev *dev = fib->dev;\r\nu16 fibsize, command;\r\nlong ret;\r\naac_fib_init(fib);\r\nif (dev->comm_interface == AAC_COMM_MESSAGE_TYPE2 && !dev->sync_mode) {\r\nstruct aac_raw_io2 *readcmd2;\r\nreadcmd2 = (struct aac_raw_io2 *) fib_data(fib);\r\nmemset(readcmd2, 0, sizeof(struct aac_raw_io2));\r\nreadcmd2->blockLow = cpu_to_le32((u32)(lba&0xffffffff));\r\nreadcmd2->blockHigh = cpu_to_le32((u32)((lba&0xffffffff00000000LL)>>32));\r\nreadcmd2->byteCount = cpu_to_le32(count *\r\ndev->fsa_dev[scmd_id(cmd)].block_size);\r\nreadcmd2->cid = cpu_to_le16(scmd_id(cmd));\r\nreadcmd2->flags = cpu_to_le16(RIO2_IO_TYPE_READ);\r\nret = aac_build_sgraw2(cmd, readcmd2,\r\ndev->scsi_host_ptr->sg_tablesize);\r\nif (ret < 0)\r\nreturn ret;\r\ncommand = ContainerRawIo2;\r\nfibsize = sizeof(struct aac_raw_io2) +\r\n((le32_to_cpu(readcmd2->sgeCnt)-1) * sizeof(struct sge_ieee1212));\r\n} else {\r\nstruct aac_raw_io *readcmd;\r\nreadcmd = (struct aac_raw_io *) fib_data(fib);\r\nreadcmd->block[0] = cpu_to_le32((u32)(lba&0xffffffff));\r\nreadcmd->block[1] = cpu_to_le32((u32)((lba&0xffffffff00000000LL)>>32));\r\nreadcmd->count = cpu_to_le32(count *\r\ndev->fsa_dev[scmd_id(cmd)].block_size);\r\nreadcmd->cid = cpu_to_le16(scmd_id(cmd));\r\nreadcmd->flags = cpu_to_le16(RIO_TYPE_READ);\r\nreadcmd->bpTotal = 0;\r\nreadcmd->bpComplete = 0;\r\nret = aac_build_sgraw(cmd, &readcmd->sg);\r\nif (ret < 0)\r\nreturn ret;\r\ncommand = ContainerRawIo;\r\nfibsize = sizeof(struct aac_raw_io) +\r\n((le32_to_cpu(readcmd->sg.count)-1) * sizeof(struct sgentryraw));\r\n}\r\nBUG_ON(fibsize > (fib->dev->max_fib_size - sizeof(struct aac_fibhdr)));\r\nreturn aac_fib_send(command,\r\nfib,\r\nfibsize,\r\nFsaNormal,\r\n0, 1,\r\n(fib_callback) io_callback,\r\n(void *) cmd);\r\n}\r\nstatic int aac_read_block64(struct fib * fib, struct scsi_cmnd * cmd, u64 lba, u32 count)\r\n{\r\nu16 fibsize;\r\nstruct aac_read64 *readcmd;\r\nlong ret;\r\naac_fib_init(fib);\r\nreadcmd = (struct aac_read64 *) fib_data(fib);\r\nreadcmd->command = cpu_to_le32(VM_CtHostRead64);\r\nreadcmd->cid = cpu_to_le16(scmd_id(cmd));\r\nreadcmd->sector_count = cpu_to_le16(count);\r\nreadcmd->block = cpu_to_le32((u32)(lba&0xffffffff));\r\nreadcmd->pad = 0;\r\nreadcmd->flags = 0;\r\nret = aac_build_sg64(cmd, &readcmd->sg);\r\nif (ret < 0)\r\nreturn ret;\r\nfibsize = sizeof(struct aac_read64) +\r\n((le32_to_cpu(readcmd->sg.count) - 1) *\r\nsizeof (struct sgentry64));\r\nBUG_ON (fibsize > (fib->dev->max_fib_size -\r\nsizeof(struct aac_fibhdr)));\r\nreturn aac_fib_send(ContainerCommand64,\r\nfib,\r\nfibsize,\r\nFsaNormal,\r\n0, 1,\r\n(fib_callback) io_callback,\r\n(void *) cmd);\r\n}\r\nstatic int aac_read_block(struct fib * fib, struct scsi_cmnd * cmd, u64 lba, u32 count)\r\n{\r\nu16 fibsize;\r\nstruct aac_read *readcmd;\r\nstruct aac_dev *dev = fib->dev;\r\nlong ret;\r\naac_fib_init(fib);\r\nreadcmd = (struct aac_read *) fib_data(fib);\r\nreadcmd->command = cpu_to_le32(VM_CtBlockRead);\r\nreadcmd->cid = cpu_to_le32(scmd_id(cmd));\r\nreadcmd->block = cpu_to_le32((u32)(lba&0xffffffff));\r\nreadcmd->count = cpu_to_le32(count *\r\ndev->fsa_dev[scmd_id(cmd)].block_size);\r\nret = aac_build_sg(cmd, &readcmd->sg);\r\nif (ret < 0)\r\nreturn ret;\r\nfibsize = sizeof(struct aac_read) +\r\n((le32_to_cpu(readcmd->sg.count) - 1) *\r\nsizeof (struct sgentry));\r\nBUG_ON (fibsize > (fib->dev->max_fib_size -\r\nsizeof(struct aac_fibhdr)));\r\nreturn aac_fib_send(ContainerCommand,\r\nfib,\r\nfibsize,\r\nFsaNormal,\r\n0, 1,\r\n(fib_callback) io_callback,\r\n(void *) cmd);\r\n}\r\nstatic int aac_write_raw_io(struct fib * fib, struct scsi_cmnd * cmd, u64 lba, u32 count, int fua)\r\n{\r\nstruct aac_dev *dev = fib->dev;\r\nu16 fibsize, command;\r\nlong ret;\r\naac_fib_init(fib);\r\nif (dev->comm_interface == AAC_COMM_MESSAGE_TYPE2 && !dev->sync_mode) {\r\nstruct aac_raw_io2 *writecmd2;\r\nwritecmd2 = (struct aac_raw_io2 *) fib_data(fib);\r\nmemset(writecmd2, 0, sizeof(struct aac_raw_io2));\r\nwritecmd2->blockLow = cpu_to_le32((u32)(lba&0xffffffff));\r\nwritecmd2->blockHigh = cpu_to_le32((u32)((lba&0xffffffff00000000LL)>>32));\r\nwritecmd2->byteCount = cpu_to_le32(count *\r\ndev->fsa_dev[scmd_id(cmd)].block_size);\r\nwritecmd2->cid = cpu_to_le16(scmd_id(cmd));\r\nwritecmd2->flags = (fua && ((aac_cache & 5) != 1) &&\r\n(((aac_cache & 5) != 5) || !fib->dev->cache_protected)) ?\r\ncpu_to_le16(RIO2_IO_TYPE_WRITE|RIO2_IO_SUREWRITE) :\r\ncpu_to_le16(RIO2_IO_TYPE_WRITE);\r\nret = aac_build_sgraw2(cmd, writecmd2,\r\ndev->scsi_host_ptr->sg_tablesize);\r\nif (ret < 0)\r\nreturn ret;\r\ncommand = ContainerRawIo2;\r\nfibsize = sizeof(struct aac_raw_io2) +\r\n((le32_to_cpu(writecmd2->sgeCnt)-1) * sizeof(struct sge_ieee1212));\r\n} else {\r\nstruct aac_raw_io *writecmd;\r\nwritecmd = (struct aac_raw_io *) fib_data(fib);\r\nwritecmd->block[0] = cpu_to_le32((u32)(lba&0xffffffff));\r\nwritecmd->block[1] = cpu_to_le32((u32)((lba&0xffffffff00000000LL)>>32));\r\nwritecmd->count = cpu_to_le32(count *\r\ndev->fsa_dev[scmd_id(cmd)].block_size);\r\nwritecmd->cid = cpu_to_le16(scmd_id(cmd));\r\nwritecmd->flags = (fua && ((aac_cache & 5) != 1) &&\r\n(((aac_cache & 5) != 5) || !fib->dev->cache_protected)) ?\r\ncpu_to_le16(RIO_TYPE_WRITE|RIO_SUREWRITE) :\r\ncpu_to_le16(RIO_TYPE_WRITE);\r\nwritecmd->bpTotal = 0;\r\nwritecmd->bpComplete = 0;\r\nret = aac_build_sgraw(cmd, &writecmd->sg);\r\nif (ret < 0)\r\nreturn ret;\r\ncommand = ContainerRawIo;\r\nfibsize = sizeof(struct aac_raw_io) +\r\n((le32_to_cpu(writecmd->sg.count)-1) * sizeof (struct sgentryraw));\r\n}\r\nBUG_ON(fibsize > (fib->dev->max_fib_size - sizeof(struct aac_fibhdr)));\r\nreturn aac_fib_send(command,\r\nfib,\r\nfibsize,\r\nFsaNormal,\r\n0, 1,\r\n(fib_callback) io_callback,\r\n(void *) cmd);\r\n}\r\nstatic int aac_write_block64(struct fib * fib, struct scsi_cmnd * cmd, u64 lba, u32 count, int fua)\r\n{\r\nu16 fibsize;\r\nstruct aac_write64 *writecmd;\r\nlong ret;\r\naac_fib_init(fib);\r\nwritecmd = (struct aac_write64 *) fib_data(fib);\r\nwritecmd->command = cpu_to_le32(VM_CtHostWrite64);\r\nwritecmd->cid = cpu_to_le16(scmd_id(cmd));\r\nwritecmd->sector_count = cpu_to_le16(count);\r\nwritecmd->block = cpu_to_le32((u32)(lba&0xffffffff));\r\nwritecmd->pad = 0;\r\nwritecmd->flags = 0;\r\nret = aac_build_sg64(cmd, &writecmd->sg);\r\nif (ret < 0)\r\nreturn ret;\r\nfibsize = sizeof(struct aac_write64) +\r\n((le32_to_cpu(writecmd->sg.count) - 1) *\r\nsizeof (struct sgentry64));\r\nBUG_ON (fibsize > (fib->dev->max_fib_size -\r\nsizeof(struct aac_fibhdr)));\r\nreturn aac_fib_send(ContainerCommand64,\r\nfib,\r\nfibsize,\r\nFsaNormal,\r\n0, 1,\r\n(fib_callback) io_callback,\r\n(void *) cmd);\r\n}\r\nstatic int aac_write_block(struct fib * fib, struct scsi_cmnd * cmd, u64 lba, u32 count, int fua)\r\n{\r\nu16 fibsize;\r\nstruct aac_write *writecmd;\r\nstruct aac_dev *dev = fib->dev;\r\nlong ret;\r\naac_fib_init(fib);\r\nwritecmd = (struct aac_write *) fib_data(fib);\r\nwritecmd->command = cpu_to_le32(VM_CtBlockWrite);\r\nwritecmd->cid = cpu_to_le32(scmd_id(cmd));\r\nwritecmd->block = cpu_to_le32((u32)(lba&0xffffffff));\r\nwritecmd->count = cpu_to_le32(count *\r\ndev->fsa_dev[scmd_id(cmd)].block_size);\r\nwritecmd->sg.count = cpu_to_le32(1);\r\nret = aac_build_sg(cmd, &writecmd->sg);\r\nif (ret < 0)\r\nreturn ret;\r\nfibsize = sizeof(struct aac_write) +\r\n((le32_to_cpu(writecmd->sg.count) - 1) *\r\nsizeof (struct sgentry));\r\nBUG_ON (fibsize > (fib->dev->max_fib_size -\r\nsizeof(struct aac_fibhdr)));\r\nreturn aac_fib_send(ContainerCommand,\r\nfib,\r\nfibsize,\r\nFsaNormal,\r\n0, 1,\r\n(fib_callback) io_callback,\r\n(void *) cmd);\r\n}\r\nstatic struct aac_srb * aac_scsi_common(struct fib * fib, struct scsi_cmnd * cmd)\r\n{\r\nstruct aac_srb * srbcmd;\r\nu32 flag;\r\nu32 timeout;\r\naac_fib_init(fib);\r\nswitch(cmd->sc_data_direction){\r\ncase DMA_TO_DEVICE:\r\nflag = SRB_DataOut;\r\nbreak;\r\ncase DMA_BIDIRECTIONAL:\r\nflag = SRB_DataIn | SRB_DataOut;\r\nbreak;\r\ncase DMA_FROM_DEVICE:\r\nflag = SRB_DataIn;\r\nbreak;\r\ncase DMA_NONE:\r\ndefault:\r\nflag = SRB_NoDataXfer;\r\nbreak;\r\n}\r\nsrbcmd = (struct aac_srb*) fib_data(fib);\r\nsrbcmd->function = cpu_to_le32(SRBF_ExecuteScsi);\r\nsrbcmd->channel = cpu_to_le32(aac_logical_to_phys(scmd_channel(cmd)));\r\nsrbcmd->id = cpu_to_le32(scmd_id(cmd));\r\nsrbcmd->lun = cpu_to_le32(cmd->device->lun);\r\nsrbcmd->flags = cpu_to_le32(flag);\r\ntimeout = cmd->request->timeout/HZ;\r\nif (timeout == 0)\r\ntimeout = 1;\r\nsrbcmd->timeout = cpu_to_le32(timeout);\r\nsrbcmd->retry_limit = 0;\r\nsrbcmd->cdb_size = cpu_to_le32(cmd->cmd_len);\r\nreturn srbcmd;\r\n}\r\nstatic int aac_scsi_64(struct fib * fib, struct scsi_cmnd * cmd)\r\n{\r\nu16 fibsize;\r\nstruct aac_srb * srbcmd = aac_scsi_common(fib, cmd);\r\nlong ret;\r\nret = aac_build_sg64(cmd, (struct sgmap64 *) &srbcmd->sg);\r\nif (ret < 0)\r\nreturn ret;\r\nsrbcmd->count = cpu_to_le32(scsi_bufflen(cmd));\r\nmemset(srbcmd->cdb, 0, sizeof(srbcmd->cdb));\r\nmemcpy(srbcmd->cdb, cmd->cmnd, cmd->cmd_len);\r\nfibsize = sizeof (struct aac_srb) - sizeof (struct sgentry) +\r\n((le32_to_cpu(srbcmd->sg.count) & 0xff) *\r\nsizeof (struct sgentry64));\r\nBUG_ON (fibsize > (fib->dev->max_fib_size -\r\nsizeof(struct aac_fibhdr)));\r\nreturn aac_fib_send(ScsiPortCommand64, fib,\r\nfibsize, FsaNormal, 0, 1,\r\n(fib_callback) aac_srb_callback,\r\n(void *) cmd);\r\n}\r\nstatic int aac_scsi_32(struct fib * fib, struct scsi_cmnd * cmd)\r\n{\r\nu16 fibsize;\r\nstruct aac_srb * srbcmd = aac_scsi_common(fib, cmd);\r\nlong ret;\r\nret = aac_build_sg(cmd, (struct sgmap *)&srbcmd->sg);\r\nif (ret < 0)\r\nreturn ret;\r\nsrbcmd->count = cpu_to_le32(scsi_bufflen(cmd));\r\nmemset(srbcmd->cdb, 0, sizeof(srbcmd->cdb));\r\nmemcpy(srbcmd->cdb, cmd->cmnd, cmd->cmd_len);\r\nfibsize = sizeof (struct aac_srb) +\r\n(((le32_to_cpu(srbcmd->sg.count) & 0xff) - 1) *\r\nsizeof (struct sgentry));\r\nBUG_ON (fibsize > (fib->dev->max_fib_size -\r\nsizeof(struct aac_fibhdr)));\r\nreturn aac_fib_send(ScsiPortCommand, fib, fibsize, FsaNormal, 0, 1,\r\n(fib_callback) aac_srb_callback, (void *) cmd);\r\n}\r\nstatic int aac_scsi_32_64(struct fib * fib, struct scsi_cmnd * cmd)\r\n{\r\nif ((sizeof(dma_addr_t) > 4) && fib->dev->needs_dac &&\r\n(fib->dev->adapter_info.options & AAC_OPT_SGMAP_HOST64))\r\nreturn FAILED;\r\nreturn aac_scsi_32(fib, cmd);\r\n}\r\nint aac_get_adapter_info(struct aac_dev* dev)\r\n{\r\nstruct fib* fibptr;\r\nint rcode;\r\nu32 tmp;\r\nstruct aac_adapter_info *info;\r\nstruct aac_bus_info *command;\r\nstruct aac_bus_info_response *bus_info;\r\nif (!(fibptr = aac_fib_alloc(dev)))\r\nreturn -ENOMEM;\r\naac_fib_init(fibptr);\r\ninfo = (struct aac_adapter_info *) fib_data(fibptr);\r\nmemset(info,0,sizeof(*info));\r\nrcode = aac_fib_send(RequestAdapterInfo,\r\nfibptr,\r\nsizeof(*info),\r\nFsaNormal,\r\n-1, 1,\r\nNULL,\r\nNULL);\r\nif (rcode < 0) {\r\nif (rcode != -ERESTARTSYS) {\r\naac_fib_complete(fibptr);\r\naac_fib_free(fibptr);\r\n}\r\nreturn rcode;\r\n}\r\nmemcpy(&dev->adapter_info, info, sizeof(*info));\r\nif (dev->adapter_info.options & AAC_OPT_SUPPLEMENT_ADAPTER_INFO) {\r\nstruct aac_supplement_adapter_info * sinfo;\r\naac_fib_init(fibptr);\r\nsinfo = (struct aac_supplement_adapter_info *) fib_data(fibptr);\r\nmemset(sinfo,0,sizeof(*sinfo));\r\nrcode = aac_fib_send(RequestSupplementAdapterInfo,\r\nfibptr,\r\nsizeof(*sinfo),\r\nFsaNormal,\r\n1, 1,\r\nNULL,\r\nNULL);\r\nif (rcode >= 0)\r\nmemcpy(&dev->supplement_adapter_info, sinfo, sizeof(*sinfo));\r\nif (rcode == -ERESTARTSYS) {\r\nfibptr = aac_fib_alloc(dev);\r\nif (!fibptr)\r\nreturn -ENOMEM;\r\n}\r\n}\r\naac_fib_init(fibptr);\r\nbus_info = (struct aac_bus_info_response *) fib_data(fibptr);\r\nmemset(bus_info, 0, sizeof(*bus_info));\r\ncommand = (struct aac_bus_info *)bus_info;\r\ncommand->Command = cpu_to_le32(VM_Ioctl);\r\ncommand->ObjType = cpu_to_le32(FT_DRIVE);\r\ncommand->MethodId = cpu_to_le32(1);\r\ncommand->CtlCmd = cpu_to_le32(GetBusInfo);\r\nrcode = aac_fib_send(ContainerCommand,\r\nfibptr,\r\nsizeof (*bus_info),\r\nFsaNormal,\r\n1, 1,\r\nNULL, NULL);\r\ndev->maximum_num_physicals = 16;\r\nif (rcode >= 0 && le32_to_cpu(bus_info->Status) == ST_OK) {\r\ndev->maximum_num_physicals = le32_to_cpu(bus_info->TargetsPerBus);\r\ndev->maximum_num_channels = le32_to_cpu(bus_info->BusCount);\r\n}\r\nif (!dev->in_reset) {\r\nchar buffer[16];\r\ntmp = le32_to_cpu(dev->adapter_info.kernelrev);\r\nprintk(KERN_INFO "%s%d: kernel %d.%d-%d[%d] %.*s\n",\r\ndev->name,\r\ndev->id,\r\ntmp>>24,\r\n(tmp>>16)&0xff,\r\ntmp&0xff,\r\nle32_to_cpu(dev->adapter_info.kernelbuild),\r\n(int)sizeof(dev->supplement_adapter_info.BuildDate),\r\ndev->supplement_adapter_info.BuildDate);\r\ntmp = le32_to_cpu(dev->adapter_info.monitorrev);\r\nprintk(KERN_INFO "%s%d: monitor %d.%d-%d[%d]\n",\r\ndev->name, dev->id,\r\ntmp>>24,(tmp>>16)&0xff,tmp&0xff,\r\nle32_to_cpu(dev->adapter_info.monitorbuild));\r\ntmp = le32_to_cpu(dev->adapter_info.biosrev);\r\nprintk(KERN_INFO "%s%d: bios %d.%d-%d[%d]\n",\r\ndev->name, dev->id,\r\ntmp>>24,(tmp>>16)&0xff,tmp&0xff,\r\nle32_to_cpu(dev->adapter_info.biosbuild));\r\nbuffer[0] = '\0';\r\nif (aac_get_serial_number(\r\nshost_to_class(dev->scsi_host_ptr), buffer))\r\nprintk(KERN_INFO "%s%d: serial %s",\r\ndev->name, dev->id, buffer);\r\nif (dev->supplement_adapter_info.VpdInfo.Tsid[0]) {\r\nprintk(KERN_INFO "%s%d: TSID %.*s\n",\r\ndev->name, dev->id,\r\n(int)sizeof(dev->supplement_adapter_info.VpdInfo.Tsid),\r\ndev->supplement_adapter_info.VpdInfo.Tsid);\r\n}\r\nif (!aac_check_reset || ((aac_check_reset == 1) &&\r\n(dev->supplement_adapter_info.SupportedOptions2 &\r\nAAC_OPTION_IGNORE_RESET))) {\r\nprintk(KERN_INFO "%s%d: Reset Adapter Ignored\n",\r\ndev->name, dev->id);\r\n}\r\n}\r\ndev->cache_protected = 0;\r\ndev->jbod = ((dev->supplement_adapter_info.FeatureBits &\r\nAAC_FEATURE_JBOD) != 0);\r\ndev->nondasd_support = 0;\r\ndev->raid_scsi_mode = 0;\r\nif(dev->adapter_info.options & AAC_OPT_NONDASD)\r\ndev->nondasd_support = 1;\r\nif ((dev->adapter_info.options & AAC_OPT_SCSI_MANAGED) &&\r\n(dev->adapter_info.options & AAC_OPT_RAID_SCSI_MODE)) {\r\ndev->nondasd_support = 1;\r\ndev->raid_scsi_mode = 1;\r\n}\r\nif (dev->raid_scsi_mode != 0)\r\nprintk(KERN_INFO "%s%d: ROMB RAID/SCSI mode enabled\n",\r\ndev->name, dev->id);\r\nif (nondasd != -1)\r\ndev->nondasd_support = (nondasd!=0);\r\nif (dev->nondasd_support && !dev->in_reset)\r\nprintk(KERN_INFO "%s%d: Non-DASD support enabled.\n",dev->name, dev->id);\r\nif (dma_get_required_mask(&dev->pdev->dev) > DMA_BIT_MASK(32))\r\ndev->needs_dac = 1;\r\ndev->dac_support = 0;\r\nif ((sizeof(dma_addr_t) > 4) && dev->needs_dac &&\r\n(dev->adapter_info.options & AAC_OPT_SGMAP_HOST64)) {\r\nif (!dev->in_reset)\r\nprintk(KERN_INFO "%s%d: 64bit support enabled.\n",\r\ndev->name, dev->id);\r\ndev->dac_support = 1;\r\n}\r\nif(dacmode != -1) {\r\ndev->dac_support = (dacmode!=0);\r\n}\r\nif (dev->dac_support && (aac_get_driver_ident(dev->cardtype)->quirks\r\n& AAC_QUIRK_SCSI_32)) {\r\ndev->nondasd_support = 0;\r\ndev->jbod = 0;\r\nexpose_physicals = 0;\r\n}\r\nif(dev->dac_support != 0) {\r\nif (!pci_set_dma_mask(dev->pdev, DMA_BIT_MASK(64)) &&\r\n!pci_set_consistent_dma_mask(dev->pdev, DMA_BIT_MASK(64))) {\r\nif (!dev->in_reset)\r\nprintk(KERN_INFO"%s%d: 64 Bit DAC enabled\n",\r\ndev->name, dev->id);\r\n} else if (!pci_set_dma_mask(dev->pdev, DMA_BIT_MASK(32)) &&\r\n!pci_set_consistent_dma_mask(dev->pdev, DMA_BIT_MASK(32))) {\r\nprintk(KERN_INFO"%s%d: DMA mask set failed, 64 Bit DAC disabled\n",\r\ndev->name, dev->id);\r\ndev->dac_support = 0;\r\n} else {\r\nprintk(KERN_WARNING"%s%d: No suitable DMA available.\n",\r\ndev->name, dev->id);\r\nrcode = -ENOMEM;\r\n}\r\n}\r\ndev->a_ops.adapter_scsi = (dev->dac_support)\r\n? ((aac_get_driver_ident(dev->cardtype)->quirks & AAC_QUIRK_SCSI_32)\r\n? aac_scsi_32_64\r\n: aac_scsi_64)\r\n: aac_scsi_32;\r\nif (dev->raw_io_interface) {\r\ndev->a_ops.adapter_bounds = (dev->raw_io_64)\r\n? aac_bounds_64\r\n: aac_bounds_32;\r\ndev->a_ops.adapter_read = aac_read_raw_io;\r\ndev->a_ops.adapter_write = aac_write_raw_io;\r\n} else {\r\ndev->a_ops.adapter_bounds = aac_bounds_32;\r\ndev->scsi_host_ptr->sg_tablesize = (dev->max_fib_size -\r\nsizeof(struct aac_fibhdr) -\r\nsizeof(struct aac_write) + sizeof(struct sgentry)) /\r\nsizeof(struct sgentry);\r\nif (dev->dac_support) {\r\ndev->a_ops.adapter_read = aac_read_block64;\r\ndev->a_ops.adapter_write = aac_write_block64;\r\ndev->scsi_host_ptr->sg_tablesize =\r\n(dev->max_fib_size -\r\nsizeof(struct aac_fibhdr) -\r\nsizeof(struct aac_write64) +\r\nsizeof(struct sgentry64)) /\r\nsizeof(struct sgentry64);\r\n} else {\r\ndev->a_ops.adapter_read = aac_read_block;\r\ndev->a_ops.adapter_write = aac_write_block;\r\n}\r\ndev->scsi_host_ptr->max_sectors = AAC_MAX_32BIT_SGBCOUNT;\r\nif (!(dev->adapter_info.options & AAC_OPT_NEW_COMM)) {\r\ndev->scsi_host_ptr->max_sectors =\r\n(dev->scsi_host_ptr->sg_tablesize * 8) + 112;\r\n}\r\n}\r\nif (rcode != -ERESTARTSYS) {\r\naac_fib_complete(fibptr);\r\naac_fib_free(fibptr);\r\n}\r\nreturn rcode;\r\n}\r\nstatic void io_callback(void *context, struct fib * fibptr)\r\n{\r\nstruct aac_dev *dev;\r\nstruct aac_read_reply *readreply;\r\nstruct scsi_cmnd *scsicmd;\r\nu32 cid;\r\nscsicmd = (struct scsi_cmnd *) context;\r\nif (!aac_valid_context(scsicmd, fibptr))\r\nreturn;\r\ndev = fibptr->dev;\r\ncid = scmd_id(scsicmd);\r\nif (nblank(dprintk(x))) {\r\nu64 lba;\r\nswitch (scsicmd->cmnd[0]) {\r\ncase WRITE_6:\r\ncase READ_6:\r\nlba = ((scsicmd->cmnd[1] & 0x1F) << 16) |\r\n(scsicmd->cmnd[2] << 8) | scsicmd->cmnd[3];\r\nbreak;\r\ncase WRITE_16:\r\ncase READ_16:\r\nlba = ((u64)scsicmd->cmnd[2] << 56) |\r\n((u64)scsicmd->cmnd[3] << 48) |\r\n((u64)scsicmd->cmnd[4] << 40) |\r\n((u64)scsicmd->cmnd[5] << 32) |\r\n((u64)scsicmd->cmnd[6] << 24) |\r\n(scsicmd->cmnd[7] << 16) |\r\n(scsicmd->cmnd[8] << 8) | scsicmd->cmnd[9];\r\nbreak;\r\ncase WRITE_12:\r\ncase READ_12:\r\nlba = ((u64)scsicmd->cmnd[2] << 24) |\r\n(scsicmd->cmnd[3] << 16) |\r\n(scsicmd->cmnd[4] << 8) | scsicmd->cmnd[5];\r\nbreak;\r\ndefault:\r\nlba = ((u64)scsicmd->cmnd[2] << 24) |\r\n(scsicmd->cmnd[3] << 16) |\r\n(scsicmd->cmnd[4] << 8) | scsicmd->cmnd[5];\r\nbreak;\r\n}\r\nprintk(KERN_DEBUG\r\n"io_callback[cpu %d]: lba = %llu, t = %ld.\n",\r\nsmp_processor_id(), (unsigned long long)lba, jiffies);\r\n}\r\nBUG_ON(fibptr == NULL);\r\nscsi_dma_unmap(scsicmd);\r\nreadreply = (struct aac_read_reply *)fib_data(fibptr);\r\nswitch (le32_to_cpu(readreply->status)) {\r\ncase ST_OK:\r\nscsicmd->result = DID_OK << 16 | COMMAND_COMPLETE << 8 |\r\nSAM_STAT_GOOD;\r\ndev->fsa_dev[cid].sense_data.sense_key = NO_SENSE;\r\nbreak;\r\ncase ST_NOT_READY:\r\nscsicmd->result = DID_OK << 16 | COMMAND_COMPLETE << 8 |\r\nSAM_STAT_CHECK_CONDITION;\r\nset_sense(&dev->fsa_dev[cid].sense_data, NOT_READY,\r\nSENCODE_BECOMING_READY, ASENCODE_BECOMING_READY, 0, 0);\r\nmemcpy(scsicmd->sense_buffer, &dev->fsa_dev[cid].sense_data,\r\nmin_t(size_t, sizeof(dev->fsa_dev[cid].sense_data),\r\nSCSI_SENSE_BUFFERSIZE));\r\nbreak;\r\ndefault:\r\n#ifdef AAC_DETAILED_STATUS_INFO\r\nprintk(KERN_WARNING "io_callback: io failed, status = %d\n",\r\nle32_to_cpu(readreply->status));\r\n#endif\r\nscsicmd->result = DID_OK << 16 | COMMAND_COMPLETE << 8 |\r\nSAM_STAT_CHECK_CONDITION;\r\nset_sense(&dev->fsa_dev[cid].sense_data,\r\nHARDWARE_ERROR, SENCODE_INTERNAL_TARGET_FAILURE,\r\nASENCODE_INTERNAL_TARGET_FAILURE, 0, 0);\r\nmemcpy(scsicmd->sense_buffer, &dev->fsa_dev[cid].sense_data,\r\nmin_t(size_t, sizeof(dev->fsa_dev[cid].sense_data),\r\nSCSI_SENSE_BUFFERSIZE));\r\nbreak;\r\n}\r\naac_fib_complete(fibptr);\r\naac_fib_free(fibptr);\r\nscsicmd->scsi_done(scsicmd);\r\n}\r\nstatic int aac_read(struct scsi_cmnd * scsicmd)\r\n{\r\nu64 lba;\r\nu32 count;\r\nint status;\r\nstruct aac_dev *dev;\r\nstruct fib * cmd_fibcontext;\r\nint cid;\r\ndev = (struct aac_dev *)scsicmd->device->host->hostdata;\r\nswitch (scsicmd->cmnd[0]) {\r\ncase READ_6:\r\ndprintk((KERN_DEBUG "aachba: received a read(6) command on id %d.\n", scmd_id(scsicmd)));\r\nlba = ((scsicmd->cmnd[1] & 0x1F) << 16) |\r\n(scsicmd->cmnd[2] << 8) | scsicmd->cmnd[3];\r\ncount = scsicmd->cmnd[4];\r\nif (count == 0)\r\ncount = 256;\r\nbreak;\r\ncase READ_16:\r\ndprintk((KERN_DEBUG "aachba: received a read(16) command on id %d.\n", scmd_id(scsicmd)));\r\nlba = ((u64)scsicmd->cmnd[2] << 56) |\r\n((u64)scsicmd->cmnd[3] << 48) |\r\n((u64)scsicmd->cmnd[4] << 40) |\r\n((u64)scsicmd->cmnd[5] << 32) |\r\n((u64)scsicmd->cmnd[6] << 24) |\r\n(scsicmd->cmnd[7] << 16) |\r\n(scsicmd->cmnd[8] << 8) | scsicmd->cmnd[9];\r\ncount = (scsicmd->cmnd[10] << 24) |\r\n(scsicmd->cmnd[11] << 16) |\r\n(scsicmd->cmnd[12] << 8) | scsicmd->cmnd[13];\r\nbreak;\r\ncase READ_12:\r\ndprintk((KERN_DEBUG "aachba: received a read(12) command on id %d.\n", scmd_id(scsicmd)));\r\nlba = ((u64)scsicmd->cmnd[2] << 24) |\r\n(scsicmd->cmnd[3] << 16) |\r\n(scsicmd->cmnd[4] << 8) | scsicmd->cmnd[5];\r\ncount = (scsicmd->cmnd[6] << 24) |\r\n(scsicmd->cmnd[7] << 16) |\r\n(scsicmd->cmnd[8] << 8) | scsicmd->cmnd[9];\r\nbreak;\r\ndefault:\r\ndprintk((KERN_DEBUG "aachba: received a read(10) command on id %d.\n", scmd_id(scsicmd)));\r\nlba = ((u64)scsicmd->cmnd[2] << 24) |\r\n(scsicmd->cmnd[3] << 16) |\r\n(scsicmd->cmnd[4] << 8) | scsicmd->cmnd[5];\r\ncount = (scsicmd->cmnd[7] << 8) | scsicmd->cmnd[8];\r\nbreak;\r\n}\r\nif ((lba + count) > (dev->fsa_dev[scmd_id(scsicmd)].size)) {\r\ncid = scmd_id(scsicmd);\r\ndprintk((KERN_DEBUG "aacraid: Illegal lba\n"));\r\nscsicmd->result = DID_OK << 16 | COMMAND_COMPLETE << 8 |\r\nSAM_STAT_CHECK_CONDITION;\r\nset_sense(&dev->fsa_dev[cid].sense_data,\r\nHARDWARE_ERROR, SENCODE_INTERNAL_TARGET_FAILURE,\r\nASENCODE_INTERNAL_TARGET_FAILURE, 0, 0);\r\nmemcpy(scsicmd->sense_buffer, &dev->fsa_dev[cid].sense_data,\r\nmin_t(size_t, sizeof(dev->fsa_dev[cid].sense_data),\r\nSCSI_SENSE_BUFFERSIZE));\r\nscsicmd->scsi_done(scsicmd);\r\nreturn 1;\r\n}\r\ndprintk((KERN_DEBUG "aac_read[cpu %d]: lba = %llu, t = %ld.\n",\r\nsmp_processor_id(), (unsigned long long)lba, jiffies));\r\nif (aac_adapter_bounds(dev,scsicmd,lba))\r\nreturn 0;\r\nif (!(cmd_fibcontext = aac_fib_alloc(dev))) {\r\nprintk(KERN_WARNING "aac_read: fib allocation failed\n");\r\nreturn -1;\r\n}\r\nstatus = aac_adapter_read(cmd_fibcontext, scsicmd, lba, count);\r\nif (status == -EINPROGRESS) {\r\nscsicmd->SCp.phase = AAC_OWNER_FIRMWARE;\r\nreturn 0;\r\n}\r\nprintk(KERN_WARNING "aac_read: aac_fib_send failed with status: %d.\n", status);\r\nscsicmd->result = DID_OK << 16 | COMMAND_COMPLETE << 8 | SAM_STAT_TASK_SET_FULL;\r\nscsicmd->scsi_done(scsicmd);\r\naac_fib_complete(cmd_fibcontext);\r\naac_fib_free(cmd_fibcontext);\r\nreturn 0;\r\n}\r\nstatic int aac_write(struct scsi_cmnd * scsicmd)\r\n{\r\nu64 lba;\r\nu32 count;\r\nint fua;\r\nint status;\r\nstruct aac_dev *dev;\r\nstruct fib * cmd_fibcontext;\r\nint cid;\r\ndev = (struct aac_dev *)scsicmd->device->host->hostdata;\r\nif (scsicmd->cmnd[0] == WRITE_6)\r\n{\r\nlba = ((scsicmd->cmnd[1] & 0x1F) << 16) | (scsicmd->cmnd[2] << 8) | scsicmd->cmnd[3];\r\ncount = scsicmd->cmnd[4];\r\nif (count == 0)\r\ncount = 256;\r\nfua = 0;\r\n} else if (scsicmd->cmnd[0] == WRITE_16) {\r\ndprintk((KERN_DEBUG "aachba: received a write(16) command on id %d.\n", scmd_id(scsicmd)));\r\nlba = ((u64)scsicmd->cmnd[2] << 56) |\r\n((u64)scsicmd->cmnd[3] << 48) |\r\n((u64)scsicmd->cmnd[4] << 40) |\r\n((u64)scsicmd->cmnd[5] << 32) |\r\n((u64)scsicmd->cmnd[6] << 24) |\r\n(scsicmd->cmnd[7] << 16) |\r\n(scsicmd->cmnd[8] << 8) | scsicmd->cmnd[9];\r\ncount = (scsicmd->cmnd[10] << 24) | (scsicmd->cmnd[11] << 16) |\r\n(scsicmd->cmnd[12] << 8) | scsicmd->cmnd[13];\r\nfua = scsicmd->cmnd[1] & 0x8;\r\n} else if (scsicmd->cmnd[0] == WRITE_12) {\r\ndprintk((KERN_DEBUG "aachba: received a write(12) command on id %d.\n", scmd_id(scsicmd)));\r\nlba = ((u64)scsicmd->cmnd[2] << 24) | (scsicmd->cmnd[3] << 16)\r\n| (scsicmd->cmnd[4] << 8) | scsicmd->cmnd[5];\r\ncount = (scsicmd->cmnd[6] << 24) | (scsicmd->cmnd[7] << 16)\r\n| (scsicmd->cmnd[8] << 8) | scsicmd->cmnd[9];\r\nfua = scsicmd->cmnd[1] & 0x8;\r\n} else {\r\ndprintk((KERN_DEBUG "aachba: received a write(10) command on id %d.\n", scmd_id(scsicmd)));\r\nlba = ((u64)scsicmd->cmnd[2] << 24) | (scsicmd->cmnd[3] << 16) | (scsicmd->cmnd[4] << 8) | scsicmd->cmnd[5];\r\ncount = (scsicmd->cmnd[7] << 8) | scsicmd->cmnd[8];\r\nfua = scsicmd->cmnd[1] & 0x8;\r\n}\r\nif ((lba + count) > (dev->fsa_dev[scmd_id(scsicmd)].size)) {\r\ncid = scmd_id(scsicmd);\r\ndprintk((KERN_DEBUG "aacraid: Illegal lba\n"));\r\nscsicmd->result = DID_OK << 16 | COMMAND_COMPLETE << 8 |\r\nSAM_STAT_CHECK_CONDITION;\r\nset_sense(&dev->fsa_dev[cid].sense_data,\r\nHARDWARE_ERROR, SENCODE_INTERNAL_TARGET_FAILURE,\r\nASENCODE_INTERNAL_TARGET_FAILURE, 0, 0);\r\nmemcpy(scsicmd->sense_buffer, &dev->fsa_dev[cid].sense_data,\r\nmin_t(size_t, sizeof(dev->fsa_dev[cid].sense_data),\r\nSCSI_SENSE_BUFFERSIZE));\r\nscsicmd->scsi_done(scsicmd);\r\nreturn 1;\r\n}\r\ndprintk((KERN_DEBUG "aac_write[cpu %d]: lba = %llu, t = %ld.\n",\r\nsmp_processor_id(), (unsigned long long)lba, jiffies));\r\nif (aac_adapter_bounds(dev,scsicmd,lba))\r\nreturn 0;\r\nif (!(cmd_fibcontext = aac_fib_alloc(dev))) {\r\nprintk(KERN_WARNING "aac_write: fib allocation failed\n");\r\nreturn -1;\r\n}\r\nstatus = aac_adapter_write(cmd_fibcontext, scsicmd, lba, count, fua);\r\nif (status == -EINPROGRESS) {\r\nscsicmd->SCp.phase = AAC_OWNER_FIRMWARE;\r\nreturn 0;\r\n}\r\nprintk(KERN_WARNING "aac_write: aac_fib_send failed with status: %d\n", status);\r\nscsicmd->result = DID_OK << 16 | COMMAND_COMPLETE << 8 | SAM_STAT_TASK_SET_FULL;\r\nscsicmd->scsi_done(scsicmd);\r\naac_fib_complete(cmd_fibcontext);\r\naac_fib_free(cmd_fibcontext);\r\nreturn 0;\r\n}\r\nstatic void synchronize_callback(void *context, struct fib *fibptr)\r\n{\r\nstruct aac_synchronize_reply *synchronizereply;\r\nstruct scsi_cmnd *cmd;\r\ncmd = context;\r\nif (!aac_valid_context(cmd, fibptr))\r\nreturn;\r\ndprintk((KERN_DEBUG "synchronize_callback[cpu %d]: t = %ld.\n",\r\nsmp_processor_id(), jiffies));\r\nBUG_ON(fibptr == NULL);\r\nsynchronizereply = fib_data(fibptr);\r\nif (le32_to_cpu(synchronizereply->status) == CT_OK)\r\ncmd->result = DID_OK << 16 |\r\nCOMMAND_COMPLETE << 8 | SAM_STAT_GOOD;\r\nelse {\r\nstruct scsi_device *sdev = cmd->device;\r\nstruct aac_dev *dev = fibptr->dev;\r\nu32 cid = sdev_id(sdev);\r\nprintk(KERN_WARNING\r\n"synchronize_callback: synchronize failed, status = %d\n",\r\nle32_to_cpu(synchronizereply->status));\r\ncmd->result = DID_OK << 16 |\r\nCOMMAND_COMPLETE << 8 | SAM_STAT_CHECK_CONDITION;\r\nset_sense(&dev->fsa_dev[cid].sense_data,\r\nHARDWARE_ERROR, SENCODE_INTERNAL_TARGET_FAILURE,\r\nASENCODE_INTERNAL_TARGET_FAILURE, 0, 0);\r\nmemcpy(cmd->sense_buffer, &dev->fsa_dev[cid].sense_data,\r\nmin_t(size_t, sizeof(dev->fsa_dev[cid].sense_data),\r\nSCSI_SENSE_BUFFERSIZE));\r\n}\r\naac_fib_complete(fibptr);\r\naac_fib_free(fibptr);\r\ncmd->scsi_done(cmd);\r\n}\r\nstatic int aac_synchronize(struct scsi_cmnd *scsicmd)\r\n{\r\nint status;\r\nstruct fib *cmd_fibcontext;\r\nstruct aac_synchronize *synchronizecmd;\r\nstruct scsi_cmnd *cmd;\r\nstruct scsi_device *sdev = scsicmd->device;\r\nint active = 0;\r\nstruct aac_dev *aac;\r\nu64 lba = ((u64)scsicmd->cmnd[2] << 24) | (scsicmd->cmnd[3] << 16) |\r\n(scsicmd->cmnd[4] << 8) | scsicmd->cmnd[5];\r\nu32 count = (scsicmd->cmnd[7] << 8) | scsicmd->cmnd[8];\r\nunsigned long flags;\r\nspin_lock_irqsave(&sdev->list_lock, flags);\r\nlist_for_each_entry(cmd, &sdev->cmd_list, list)\r\nif (cmd->SCp.phase == AAC_OWNER_FIRMWARE) {\r\nu64 cmnd_lba;\r\nu32 cmnd_count;\r\nif (cmd->cmnd[0] == WRITE_6) {\r\ncmnd_lba = ((cmd->cmnd[1] & 0x1F) << 16) |\r\n(cmd->cmnd[2] << 8) |\r\ncmd->cmnd[3];\r\ncmnd_count = cmd->cmnd[4];\r\nif (cmnd_count == 0)\r\ncmnd_count = 256;\r\n} else if (cmd->cmnd[0] == WRITE_16) {\r\ncmnd_lba = ((u64)cmd->cmnd[2] << 56) |\r\n((u64)cmd->cmnd[3] << 48) |\r\n((u64)cmd->cmnd[4] << 40) |\r\n((u64)cmd->cmnd[5] << 32) |\r\n((u64)cmd->cmnd[6] << 24) |\r\n(cmd->cmnd[7] << 16) |\r\n(cmd->cmnd[8] << 8) |\r\ncmd->cmnd[9];\r\ncmnd_count = (cmd->cmnd[10] << 24) |\r\n(cmd->cmnd[11] << 16) |\r\n(cmd->cmnd[12] << 8) |\r\ncmd->cmnd[13];\r\n} else if (cmd->cmnd[0] == WRITE_12) {\r\ncmnd_lba = ((u64)cmd->cmnd[2] << 24) |\r\n(cmd->cmnd[3] << 16) |\r\n(cmd->cmnd[4] << 8) |\r\ncmd->cmnd[5];\r\ncmnd_count = (cmd->cmnd[6] << 24) |\r\n(cmd->cmnd[7] << 16) |\r\n(cmd->cmnd[8] << 8) |\r\ncmd->cmnd[9];\r\n} else if (cmd->cmnd[0] == WRITE_10) {\r\ncmnd_lba = ((u64)cmd->cmnd[2] << 24) |\r\n(cmd->cmnd[3] << 16) |\r\n(cmd->cmnd[4] << 8) |\r\ncmd->cmnd[5];\r\ncmnd_count = (cmd->cmnd[7] << 8) |\r\ncmd->cmnd[8];\r\n} else\r\ncontinue;\r\nif (((cmnd_lba + cmnd_count) < lba) ||\r\n(count && ((lba + count) < cmnd_lba)))\r\ncontinue;\r\n++active;\r\nbreak;\r\n}\r\nspin_unlock_irqrestore(&sdev->list_lock, flags);\r\nif (active)\r\nreturn SCSI_MLQUEUE_DEVICE_BUSY;\r\naac = (struct aac_dev *)sdev->host->hostdata;\r\nif (aac->in_reset)\r\nreturn SCSI_MLQUEUE_HOST_BUSY;\r\nif (!(cmd_fibcontext = aac_fib_alloc(aac)))\r\nreturn SCSI_MLQUEUE_HOST_BUSY;\r\naac_fib_init(cmd_fibcontext);\r\nsynchronizecmd = fib_data(cmd_fibcontext);\r\nsynchronizecmd->command = cpu_to_le32(VM_ContainerConfig);\r\nsynchronizecmd->type = cpu_to_le32(CT_FLUSH_CACHE);\r\nsynchronizecmd->cid = cpu_to_le32(scmd_id(scsicmd));\r\nsynchronizecmd->count =\r\ncpu_to_le32(sizeof(((struct aac_synchronize_reply *)NULL)->data));\r\nstatus = aac_fib_send(ContainerCommand,\r\ncmd_fibcontext,\r\nsizeof(struct aac_synchronize),\r\nFsaNormal,\r\n0, 1,\r\n(fib_callback)synchronize_callback,\r\n(void *)scsicmd);\r\nif (status == -EINPROGRESS) {\r\nscsicmd->SCp.phase = AAC_OWNER_FIRMWARE;\r\nreturn 0;\r\n}\r\nprintk(KERN_WARNING\r\n"aac_synchronize: aac_fib_send failed with status: %d.\n", status);\r\naac_fib_complete(cmd_fibcontext);\r\naac_fib_free(cmd_fibcontext);\r\nreturn SCSI_MLQUEUE_HOST_BUSY;\r\n}\r\nstatic void aac_start_stop_callback(void *context, struct fib *fibptr)\r\n{\r\nstruct scsi_cmnd *scsicmd = context;\r\nif (!aac_valid_context(scsicmd, fibptr))\r\nreturn;\r\nBUG_ON(fibptr == NULL);\r\nscsicmd->result = DID_OK << 16 | COMMAND_COMPLETE << 8 | SAM_STAT_GOOD;\r\naac_fib_complete(fibptr);\r\naac_fib_free(fibptr);\r\nscsicmd->scsi_done(scsicmd);\r\n}\r\nstatic int aac_start_stop(struct scsi_cmnd *scsicmd)\r\n{\r\nint status;\r\nstruct fib *cmd_fibcontext;\r\nstruct aac_power_management *pmcmd;\r\nstruct scsi_device *sdev = scsicmd->device;\r\nstruct aac_dev *aac = (struct aac_dev *)sdev->host->hostdata;\r\nif (!(aac->supplement_adapter_info.SupportedOptions2 &\r\nAAC_OPTION_POWER_MANAGEMENT)) {\r\nscsicmd->result = DID_OK << 16 | COMMAND_COMPLETE << 8 |\r\nSAM_STAT_GOOD;\r\nscsicmd->scsi_done(scsicmd);\r\nreturn 0;\r\n}\r\nif (aac->in_reset)\r\nreturn SCSI_MLQUEUE_HOST_BUSY;\r\ncmd_fibcontext = aac_fib_alloc(aac);\r\nif (!cmd_fibcontext)\r\nreturn SCSI_MLQUEUE_HOST_BUSY;\r\naac_fib_init(cmd_fibcontext);\r\npmcmd = fib_data(cmd_fibcontext);\r\npmcmd->command = cpu_to_le32(VM_ContainerConfig);\r\npmcmd->type = cpu_to_le32(CT_POWER_MANAGEMENT);\r\npmcmd->sub = (scsicmd->cmnd[4] & 1) ?\r\ncpu_to_le32(CT_PM_START_UNIT) : cpu_to_le32(CT_PM_STOP_UNIT);\r\npmcmd->cid = cpu_to_le32(sdev_id(sdev));\r\npmcmd->parm = (scsicmd->cmnd[1] & 1) ?\r\ncpu_to_le32(CT_PM_UNIT_IMMEDIATE) : 0;\r\nstatus = aac_fib_send(ContainerCommand,\r\ncmd_fibcontext,\r\nsizeof(struct aac_power_management),\r\nFsaNormal,\r\n0, 1,\r\n(fib_callback)aac_start_stop_callback,\r\n(void *)scsicmd);\r\nif (status == -EINPROGRESS) {\r\nscsicmd->SCp.phase = AAC_OWNER_FIRMWARE;\r\nreturn 0;\r\n}\r\naac_fib_complete(cmd_fibcontext);\r\naac_fib_free(cmd_fibcontext);\r\nreturn SCSI_MLQUEUE_HOST_BUSY;\r\n}\r\nint aac_scsi_cmd(struct scsi_cmnd * scsicmd)\r\n{\r\nu32 cid;\r\nstruct Scsi_Host *host = scsicmd->device->host;\r\nstruct aac_dev *dev = (struct aac_dev *)host->hostdata;\r\nstruct fsa_dev_info *fsa_dev_ptr = dev->fsa_dev;\r\nif (fsa_dev_ptr == NULL)\r\nreturn -1;\r\ncid = scmd_id(scsicmd);\r\nif (cid != host->this_id) {\r\nif (scmd_channel(scsicmd) == CONTAINER_CHANNEL) {\r\nif((cid >= dev->maximum_num_containers) ||\r\n(scsicmd->device->lun != 0)) {\r\nscsicmd->result = DID_NO_CONNECT << 16;\r\nscsicmd->scsi_done(scsicmd);\r\nreturn 0;\r\n}\r\nif (((fsa_dev_ptr[cid].valid & 1) == 0) ||\r\n(fsa_dev_ptr[cid].sense_data.sense_key ==\r\nNOT_READY)) {\r\nswitch (scsicmd->cmnd[0]) {\r\ncase SERVICE_ACTION_IN_16:\r\nif (!(dev->raw_io_interface) ||\r\n!(dev->raw_io_64) ||\r\n((scsicmd->cmnd[1] & 0x1f) != SAI_READ_CAPACITY_16))\r\nbreak;\r\ncase INQUIRY:\r\ncase READ_CAPACITY:\r\ncase TEST_UNIT_READY:\r\nif (dev->in_reset)\r\nreturn -1;\r\nreturn _aac_probe_container(scsicmd,\r\naac_probe_container_callback2);\r\ndefault:\r\nbreak;\r\n}\r\n}\r\n} else {\r\nif (dev->nondasd_support || expose_physicals ||\r\ndev->jbod) {\r\nif (dev->in_reset)\r\nreturn -1;\r\nreturn aac_send_srb_fib(scsicmd);\r\n} else {\r\nscsicmd->result = DID_NO_CONNECT << 16;\r\nscsicmd->scsi_done(scsicmd);\r\nreturn 0;\r\n}\r\n}\r\n}\r\nelse if ((scsicmd->cmnd[0] != INQUIRY) &&\r\n(scsicmd->cmnd[0] != TEST_UNIT_READY))\r\n{\r\ndprintk((KERN_WARNING "Only INQUIRY & TUR command supported for controller, rcvd = 0x%x.\n", scsicmd->cmnd[0]));\r\nscsicmd->result = DID_OK << 16 | COMMAND_COMPLETE << 8 | SAM_STAT_CHECK_CONDITION;\r\nset_sense(&dev->fsa_dev[cid].sense_data,\r\nILLEGAL_REQUEST, SENCODE_INVALID_COMMAND,\r\nASENCODE_INVALID_COMMAND, 0, 0);\r\nmemcpy(scsicmd->sense_buffer, &dev->fsa_dev[cid].sense_data,\r\nmin_t(size_t, sizeof(dev->fsa_dev[cid].sense_data),\r\nSCSI_SENSE_BUFFERSIZE));\r\nscsicmd->scsi_done(scsicmd);\r\nreturn 0;\r\n}\r\nswitch (scsicmd->cmnd[0]) {\r\ncase INQUIRY:\r\n{\r\nstruct inquiry_data inq_data;\r\ndprintk((KERN_DEBUG "INQUIRY command, ID: %d.\n", cid));\r\nmemset(&inq_data, 0, sizeof (struct inquiry_data));\r\nif ((scsicmd->cmnd[1] & 0x1) && aac_wwn) {\r\nchar *arr = (char *)&inq_data;\r\narr[0] = (scmd_id(scsicmd) == host->this_id) ?\r\nINQD_PDT_PROC : INQD_PDT_DA;\r\nif (scsicmd->cmnd[2] == 0) {\r\narr[3] = 3;\r\narr[4] = 0x0;\r\narr[5] = 0x80;\r\narr[6] = 0x83;\r\narr[1] = scsicmd->cmnd[2];\r\nscsi_sg_copy_from_buffer(scsicmd, &inq_data,\r\nsizeof(inq_data));\r\nscsicmd->result = DID_OK << 16 |\r\nCOMMAND_COMPLETE << 8 | SAM_STAT_GOOD;\r\n} else if (scsicmd->cmnd[2] == 0x80) {\r\narr[3] = setinqserial(dev, &arr[4],\r\nscmd_id(scsicmd));\r\narr[1] = scsicmd->cmnd[2];\r\nscsi_sg_copy_from_buffer(scsicmd, &inq_data,\r\nsizeof(inq_data));\r\nif (aac_wwn != 2)\r\nreturn aac_get_container_serial(\r\nscsicmd);\r\nscsicmd->result = DID_OK << 16 |\r\nCOMMAND_COMPLETE << 8 | SAM_STAT_GOOD;\r\n} else if (scsicmd->cmnd[2] == 0x83) {\r\nchar *sno = (char *)&inq_data;\r\nsno[3] = setinqserial(dev, &sno[4],\r\nscmd_id(scsicmd));\r\nif (aac_wwn != 2)\r\nreturn aac_get_container_serial(\r\nscsicmd);\r\nscsicmd->result = DID_OK << 16 |\r\nCOMMAND_COMPLETE << 8 | SAM_STAT_GOOD;\r\n} else {\r\nscsicmd->result = DID_OK << 16 |\r\nCOMMAND_COMPLETE << 8 |\r\nSAM_STAT_CHECK_CONDITION;\r\nset_sense(&dev->fsa_dev[cid].sense_data,\r\nILLEGAL_REQUEST, SENCODE_INVALID_CDB_FIELD,\r\nASENCODE_NO_SENSE, 7, 2);\r\nmemcpy(scsicmd->sense_buffer,\r\n&dev->fsa_dev[cid].sense_data,\r\nmin_t(size_t,\r\nsizeof(dev->fsa_dev[cid].sense_data),\r\nSCSI_SENSE_BUFFERSIZE));\r\n}\r\nscsicmd->scsi_done(scsicmd);\r\nreturn 0;\r\n}\r\ninq_data.inqd_ver = 2;\r\ninq_data.inqd_rdf = 2;\r\ninq_data.inqd_len = 31;\r\ninq_data.inqd_pad2= 0x32 ;\r\nif (cid == host->this_id) {\r\nsetinqstr(dev, (void *) (inq_data.inqd_vid), ARRAY_SIZE(container_types));\r\ninq_data.inqd_pdt = INQD_PDT_PROC;\r\nscsi_sg_copy_from_buffer(scsicmd, &inq_data,\r\nsizeof(inq_data));\r\nscsicmd->result = DID_OK << 16 | COMMAND_COMPLETE << 8 | SAM_STAT_GOOD;\r\nscsicmd->scsi_done(scsicmd);\r\nreturn 0;\r\n}\r\nif (dev->in_reset)\r\nreturn -1;\r\nsetinqstr(dev, (void *) (inq_data.inqd_vid), fsa_dev_ptr[cid].type);\r\ninq_data.inqd_pdt = INQD_PDT_DA;\r\nscsi_sg_copy_from_buffer(scsicmd, &inq_data, sizeof(inq_data));\r\nreturn aac_get_container_name(scsicmd);\r\n}\r\ncase SERVICE_ACTION_IN_16:\r\nif (!(dev->raw_io_interface) ||\r\n!(dev->raw_io_64) ||\r\n((scsicmd->cmnd[1] & 0x1f) != SAI_READ_CAPACITY_16))\r\nbreak;\r\n{\r\nu64 capacity;\r\nchar cp[13];\r\nunsigned int alloc_len;\r\ndprintk((KERN_DEBUG "READ CAPACITY_16 command.\n"));\r\ncapacity = fsa_dev_ptr[cid].size - 1;\r\ncp[0] = (capacity >> 56) & 0xff;\r\ncp[1] = (capacity >> 48) & 0xff;\r\ncp[2] = (capacity >> 40) & 0xff;\r\ncp[3] = (capacity >> 32) & 0xff;\r\ncp[4] = (capacity >> 24) & 0xff;\r\ncp[5] = (capacity >> 16) & 0xff;\r\ncp[6] = (capacity >> 8) & 0xff;\r\ncp[7] = (capacity >> 0) & 0xff;\r\ncp[8] = (fsa_dev_ptr[cid].block_size >> 24) & 0xff;\r\ncp[9] = (fsa_dev_ptr[cid].block_size >> 16) & 0xff;\r\ncp[10] = (fsa_dev_ptr[cid].block_size >> 8) & 0xff;\r\ncp[11] = (fsa_dev_ptr[cid].block_size) & 0xff;\r\ncp[12] = 0;\r\nalloc_len = ((scsicmd->cmnd[10] << 24)\r\n+ (scsicmd->cmnd[11] << 16)\r\n+ (scsicmd->cmnd[12] << 8) + scsicmd->cmnd[13]);\r\nalloc_len = min_t(size_t, alloc_len, sizeof(cp));\r\nscsi_sg_copy_from_buffer(scsicmd, cp, alloc_len);\r\nif (alloc_len < scsi_bufflen(scsicmd))\r\nscsi_set_resid(scsicmd,\r\nscsi_bufflen(scsicmd) - alloc_len);\r\nscsicmd->device->removable = 1;\r\nscsicmd->result = DID_OK << 16 | COMMAND_COMPLETE << 8 | SAM_STAT_GOOD;\r\nscsicmd->scsi_done(scsicmd);\r\nreturn 0;\r\n}\r\ncase READ_CAPACITY:\r\n{\r\nu32 capacity;\r\nchar cp[8];\r\ndprintk((KERN_DEBUG "READ CAPACITY command.\n"));\r\nif (fsa_dev_ptr[cid].size <= 0x100000000ULL)\r\ncapacity = fsa_dev_ptr[cid].size - 1;\r\nelse\r\ncapacity = (u32)-1;\r\ncp[0] = (capacity >> 24) & 0xff;\r\ncp[1] = (capacity >> 16) & 0xff;\r\ncp[2] = (capacity >> 8) & 0xff;\r\ncp[3] = (capacity >> 0) & 0xff;\r\ncp[4] = (fsa_dev_ptr[cid].block_size >> 24) & 0xff;\r\ncp[5] = (fsa_dev_ptr[cid].block_size >> 16) & 0xff;\r\ncp[6] = (fsa_dev_ptr[cid].block_size >> 8) & 0xff;\r\ncp[7] = (fsa_dev_ptr[cid].block_size) & 0xff;\r\nscsi_sg_copy_from_buffer(scsicmd, cp, sizeof(cp));\r\nscsicmd->device->removable = 1;\r\nscsicmd->result = DID_OK << 16 | COMMAND_COMPLETE << 8 |\r\nSAM_STAT_GOOD;\r\nscsicmd->scsi_done(scsicmd);\r\nreturn 0;\r\n}\r\ncase MODE_SENSE:\r\n{\r\nint mode_buf_length = 4;\r\nu32 capacity;\r\naac_modep_data mpd;\r\nif (fsa_dev_ptr[cid].size <= 0x100000000ULL)\r\ncapacity = fsa_dev_ptr[cid].size - 1;\r\nelse\r\ncapacity = (u32)-1;\r\ndprintk((KERN_DEBUG "MODE SENSE command.\n"));\r\nmemset((char *)&mpd, 0, sizeof(aac_modep_data));\r\nmpd.hd.data_length = sizeof(mpd.hd) - 1;\r\nmpd.hd.med_type = 0;\r\nmpd.hd.dev_par = 0;\r\nif (dev->raw_io_interface && ((aac_cache & 5) != 1))\r\nmpd.hd.dev_par = 0x10;\r\nif (scsicmd->cmnd[1] & 0x8)\r\nmpd.hd.bd_length = 0;\r\nelse {\r\nmpd.hd.bd_length = sizeof(mpd.bd);\r\nmpd.hd.data_length += mpd.hd.bd_length;\r\nmpd.bd.block_length[0] =\r\n(fsa_dev_ptr[cid].block_size >> 16) & 0xff;\r\nmpd.bd.block_length[1] =\r\n(fsa_dev_ptr[cid].block_size >> 8) & 0xff;\r\nmpd.bd.block_length[2] =\r\nfsa_dev_ptr[cid].block_size & 0xff;\r\nmpd.mpc_buf[0] = scsicmd->cmnd[2];\r\nif (scsicmd->cmnd[2] == 0x1C) {\r\nmpd.mpc_buf[1] = 0xa;\r\nmpd.hd.data_length = 23;\r\n} else {\r\nmpd.hd.data_length = 15;\r\n}\r\nif (capacity > 0xffffff) {\r\nmpd.bd.block_count[0] = 0xff;\r\nmpd.bd.block_count[1] = 0xff;\r\nmpd.bd.block_count[2] = 0xff;\r\n} else {\r\nmpd.bd.block_count[0] = (capacity >> 16) & 0xff;\r\nmpd.bd.block_count[1] = (capacity >> 8) & 0xff;\r\nmpd.bd.block_count[2] = capacity & 0xff;\r\n}\r\n}\r\nif (((scsicmd->cmnd[2] & 0x3f) == 8) ||\r\n((scsicmd->cmnd[2] & 0x3f) == 0x3f)) {\r\nmpd.hd.data_length += 3;\r\nmpd.mpc_buf[0] = 8;\r\nmpd.mpc_buf[1] = 1;\r\nmpd.mpc_buf[2] = ((aac_cache & 6) == 2)\r\n? 0 : 0x04;\r\nmode_buf_length = sizeof(mpd);\r\n}\r\nif (mode_buf_length > scsicmd->cmnd[4])\r\nmode_buf_length = scsicmd->cmnd[4];\r\nelse\r\nmode_buf_length = sizeof(mpd);\r\nscsi_sg_copy_from_buffer(scsicmd,\r\n(char *)&mpd,\r\nmode_buf_length);\r\nscsicmd->result = DID_OK << 16 | COMMAND_COMPLETE << 8 | SAM_STAT_GOOD;\r\nscsicmd->scsi_done(scsicmd);\r\nreturn 0;\r\n}\r\ncase MODE_SENSE_10:\r\n{\r\nu32 capacity;\r\nint mode_buf_length = 8;\r\naac_modep10_data mpd10;\r\nif (fsa_dev_ptr[cid].size <= 0x100000000ULL)\r\ncapacity = fsa_dev_ptr[cid].size - 1;\r\nelse\r\ncapacity = (u32)-1;\r\ndprintk((KERN_DEBUG "MODE SENSE 10 byte command.\n"));\r\nmemset((char *)&mpd10, 0, sizeof(aac_modep10_data));\r\nmpd10.hd.data_length[0] = 0;\r\nmpd10.hd.data_length[1] = sizeof(mpd10.hd) - 1;\r\nmpd10.hd.med_type = 0;\r\nmpd10.hd.dev_par = 0;\r\nif (dev->raw_io_interface && ((aac_cache & 5) != 1))\r\nmpd10.hd.dev_par = 0x10;\r\nmpd10.hd.rsrvd[0] = 0;\r\nmpd10.hd.rsrvd[1] = 0;\r\nif (scsicmd->cmnd[1] & 0x8) {\r\nmpd10.hd.bd_length[0] = 0;\r\nmpd10.hd.bd_length[1] = 0;\r\n} else {\r\nmpd10.hd.bd_length[0] = 0;\r\nmpd10.hd.bd_length[1] = sizeof(mpd10.bd);\r\nmpd10.hd.data_length[1] += mpd10.hd.bd_length[1];\r\nmpd10.bd.block_length[0] =\r\n(fsa_dev_ptr[cid].block_size >> 16) & 0xff;\r\nmpd10.bd.block_length[1] =\r\n(fsa_dev_ptr[cid].block_size >> 8) & 0xff;\r\nmpd10.bd.block_length[2] =\r\nfsa_dev_ptr[cid].block_size & 0xff;\r\nif (capacity > 0xffffff) {\r\nmpd10.bd.block_count[0] = 0xff;\r\nmpd10.bd.block_count[1] = 0xff;\r\nmpd10.bd.block_count[2] = 0xff;\r\n} else {\r\nmpd10.bd.block_count[0] =\r\n(capacity >> 16) & 0xff;\r\nmpd10.bd.block_count[1] =\r\n(capacity >> 8) & 0xff;\r\nmpd10.bd.block_count[2] =\r\ncapacity & 0xff;\r\n}\r\n}\r\nif (((scsicmd->cmnd[2] & 0x3f) == 8) ||\r\n((scsicmd->cmnd[2] & 0x3f) == 0x3f)) {\r\nmpd10.hd.data_length[1] += 3;\r\nmpd10.mpc_buf[0] = 8;\r\nmpd10.mpc_buf[1] = 1;\r\nmpd10.mpc_buf[2] = ((aac_cache & 6) == 2)\r\n? 0 : 0x04;\r\nmode_buf_length = sizeof(mpd10);\r\nif (mode_buf_length > scsicmd->cmnd[8])\r\nmode_buf_length = scsicmd->cmnd[8];\r\n}\r\nscsi_sg_copy_from_buffer(scsicmd,\r\n(char *)&mpd10,\r\nmode_buf_length);\r\nscsicmd->result = DID_OK << 16 | COMMAND_COMPLETE << 8 | SAM_STAT_GOOD;\r\nscsicmd->scsi_done(scsicmd);\r\nreturn 0;\r\n}\r\ncase REQUEST_SENSE:\r\ndprintk((KERN_DEBUG "REQUEST SENSE command.\n"));\r\nmemcpy(scsicmd->sense_buffer, &dev->fsa_dev[cid].sense_data, sizeof (struct sense_data));\r\nmemset(&dev->fsa_dev[cid].sense_data, 0, sizeof (struct sense_data));\r\nscsicmd->result = DID_OK << 16 | COMMAND_COMPLETE << 8 | SAM_STAT_GOOD;\r\nscsicmd->scsi_done(scsicmd);\r\nreturn 0;\r\ncase ALLOW_MEDIUM_REMOVAL:\r\ndprintk((KERN_DEBUG "LOCK command.\n"));\r\nif (scsicmd->cmnd[4])\r\nfsa_dev_ptr[cid].locked = 1;\r\nelse\r\nfsa_dev_ptr[cid].locked = 0;\r\nscsicmd->result = DID_OK << 16 | COMMAND_COMPLETE << 8 | SAM_STAT_GOOD;\r\nscsicmd->scsi_done(scsicmd);\r\nreturn 0;\r\ncase TEST_UNIT_READY:\r\nif (fsa_dev_ptr[cid].sense_data.sense_key == NOT_READY) {\r\nscsicmd->result = DID_OK << 16 | COMMAND_COMPLETE << 8 |\r\nSAM_STAT_CHECK_CONDITION;\r\nset_sense(&dev->fsa_dev[cid].sense_data,\r\nNOT_READY, SENCODE_BECOMING_READY,\r\nASENCODE_BECOMING_READY, 0, 0);\r\nmemcpy(scsicmd->sense_buffer,\r\n&dev->fsa_dev[cid].sense_data,\r\nmin_t(size_t,\r\nsizeof(dev->fsa_dev[cid].sense_data),\r\nSCSI_SENSE_BUFFERSIZE));\r\nscsicmd->scsi_done(scsicmd);\r\nreturn 0;\r\n}\r\ncase RESERVE:\r\ncase RELEASE:\r\ncase REZERO_UNIT:\r\ncase REASSIGN_BLOCKS:\r\ncase SEEK_10:\r\nscsicmd->result = DID_OK << 16 | COMMAND_COMPLETE << 8 | SAM_STAT_GOOD;\r\nscsicmd->scsi_done(scsicmd);\r\nreturn 0;\r\ncase START_STOP:\r\nreturn aac_start_stop(scsicmd);\r\n}\r\nswitch (scsicmd->cmnd[0])\r\n{\r\ncase READ_6:\r\ncase READ_10:\r\ncase READ_12:\r\ncase READ_16:\r\nif (dev->in_reset)\r\nreturn -1;\r\nif (scsicmd->request->rq_disk)\r\nstrlcpy(fsa_dev_ptr[cid].devname,\r\nscsicmd->request->rq_disk->disk_name,\r\nmin(sizeof(fsa_dev_ptr[cid].devname),\r\nsizeof(scsicmd->request->rq_disk->disk_name) + 1));\r\nreturn aac_read(scsicmd);\r\ncase WRITE_6:\r\ncase WRITE_10:\r\ncase WRITE_12:\r\ncase WRITE_16:\r\nif (dev->in_reset)\r\nreturn -1;\r\nreturn aac_write(scsicmd);\r\ncase SYNCHRONIZE_CACHE:\r\nif (((aac_cache & 6) == 6) && dev->cache_protected) {\r\nscsicmd->result = DID_OK << 16 |\r\nCOMMAND_COMPLETE << 8 | SAM_STAT_GOOD;\r\nscsicmd->scsi_done(scsicmd);\r\nreturn 0;\r\n}\r\nif ((aac_cache & 6) != 2)\r\nreturn aac_synchronize(scsicmd);\r\ndefault:\r\ndprintk((KERN_WARNING "Unhandled SCSI Command: 0x%x.\n", scsicmd->cmnd[0]));\r\nscsicmd->result = DID_OK << 16 | COMMAND_COMPLETE << 8 | SAM_STAT_CHECK_CONDITION;\r\nset_sense(&dev->fsa_dev[cid].sense_data,\r\nILLEGAL_REQUEST, SENCODE_INVALID_COMMAND,\r\nASENCODE_INVALID_COMMAND, 0, 0);\r\nmemcpy(scsicmd->sense_buffer, &dev->fsa_dev[cid].sense_data,\r\nmin_t(size_t,\r\nsizeof(dev->fsa_dev[cid].sense_data),\r\nSCSI_SENSE_BUFFERSIZE));\r\nscsicmd->scsi_done(scsicmd);\r\nreturn 0;\r\n}\r\n}\r\nstatic int query_disk(struct aac_dev *dev, void __user *arg)\r\n{\r\nstruct aac_query_disk qd;\r\nstruct fsa_dev_info *fsa_dev_ptr;\r\nfsa_dev_ptr = dev->fsa_dev;\r\nif (!fsa_dev_ptr)\r\nreturn -EBUSY;\r\nif (copy_from_user(&qd, arg, sizeof (struct aac_query_disk)))\r\nreturn -EFAULT;\r\nif (qd.cnum == -1)\r\nqd.cnum = qd.id;\r\nelse if ((qd.bus == -1) && (qd.id == -1) && (qd.lun == -1))\r\n{\r\nif (qd.cnum < 0 || qd.cnum >= dev->maximum_num_containers)\r\nreturn -EINVAL;\r\nqd.instance = dev->scsi_host_ptr->host_no;\r\nqd.bus = 0;\r\nqd.id = CONTAINER_TO_ID(qd.cnum);\r\nqd.lun = CONTAINER_TO_LUN(qd.cnum);\r\n}\r\nelse return -EINVAL;\r\nqd.valid = fsa_dev_ptr[qd.cnum].valid != 0;\r\nqd.locked = fsa_dev_ptr[qd.cnum].locked;\r\nqd.deleted = fsa_dev_ptr[qd.cnum].deleted;\r\nif (fsa_dev_ptr[qd.cnum].devname[0] == '\0')\r\nqd.unmapped = 1;\r\nelse\r\nqd.unmapped = 0;\r\nstrlcpy(qd.name, fsa_dev_ptr[qd.cnum].devname,\r\nmin(sizeof(qd.name), sizeof(fsa_dev_ptr[qd.cnum].devname) + 1));\r\nif (copy_to_user(arg, &qd, sizeof (struct aac_query_disk)))\r\nreturn -EFAULT;\r\nreturn 0;\r\n}\r\nstatic int force_delete_disk(struct aac_dev *dev, void __user *arg)\r\n{\r\nstruct aac_delete_disk dd;\r\nstruct fsa_dev_info *fsa_dev_ptr;\r\nfsa_dev_ptr = dev->fsa_dev;\r\nif (!fsa_dev_ptr)\r\nreturn -EBUSY;\r\nif (copy_from_user(&dd, arg, sizeof (struct aac_delete_disk)))\r\nreturn -EFAULT;\r\nif (dd.cnum >= dev->maximum_num_containers)\r\nreturn -EINVAL;\r\nfsa_dev_ptr[dd.cnum].deleted = 1;\r\nfsa_dev_ptr[dd.cnum].valid = 0;\r\nreturn 0;\r\n}\r\nstatic int delete_disk(struct aac_dev *dev, void __user *arg)\r\n{\r\nstruct aac_delete_disk dd;\r\nstruct fsa_dev_info *fsa_dev_ptr;\r\nfsa_dev_ptr = dev->fsa_dev;\r\nif (!fsa_dev_ptr)\r\nreturn -EBUSY;\r\nif (copy_from_user(&dd, arg, sizeof (struct aac_delete_disk)))\r\nreturn -EFAULT;\r\nif (dd.cnum >= dev->maximum_num_containers)\r\nreturn -EINVAL;\r\nif (fsa_dev_ptr[dd.cnum].locked)\r\nreturn -EBUSY;\r\nelse {\r\nfsa_dev_ptr[dd.cnum].valid = 0;\r\nfsa_dev_ptr[dd.cnum].devname[0] = '\0';\r\nreturn 0;\r\n}\r\n}\r\nint aac_dev_ioctl(struct aac_dev *dev, int cmd, void __user *arg)\r\n{\r\nswitch (cmd) {\r\ncase FSACTL_QUERY_DISK:\r\nreturn query_disk(dev, arg);\r\ncase FSACTL_DELETE_DISK:\r\nreturn delete_disk(dev, arg);\r\ncase FSACTL_FORCE_DELETE_DISK:\r\nreturn force_delete_disk(dev, arg);\r\ncase FSACTL_GET_CONTAINERS:\r\nreturn aac_get_containers(dev);\r\ndefault:\r\nreturn -ENOTTY;\r\n}\r\n}\r\nstatic void aac_srb_callback(void *context, struct fib * fibptr)\r\n{\r\nstruct aac_dev *dev;\r\nstruct aac_srb_reply *srbreply;\r\nstruct scsi_cmnd *scsicmd;\r\nscsicmd = (struct scsi_cmnd *) context;\r\nif (!aac_valid_context(scsicmd, fibptr))\r\nreturn;\r\nBUG_ON(fibptr == NULL);\r\ndev = fibptr->dev;\r\nscsi_dma_unmap(scsicmd);\r\nif (scsicmd->cmnd[0] == INQUIRY && !(scsicmd->cmnd[1] & 0x01)\r\n&& expose_physicals > 0)\r\naac_expose_phy_device(scsicmd);\r\nsrbreply = (struct aac_srb_reply *) fib_data(fibptr);\r\nscsicmd->sense_buffer[0] = '\0';\r\nif (fibptr->flags & FIB_CONTEXT_FLAG_FASTRESP) {\r\nsrbreply->srb_status = cpu_to_le32(SRB_STATUS_SUCCESS);\r\nsrbreply->scsi_status = cpu_to_le32(SAM_STAT_GOOD);\r\n} else {\r\nscsi_set_resid(scsicmd, scsi_bufflen(scsicmd)\r\n- le32_to_cpu(srbreply->data_xfer_length));\r\nif (le32_to_cpu(srbreply->status) != ST_OK) {\r\nint len;\r\nprintk(KERN_WARNING "aac_srb_callback: srb failed, status = %d\n", le32_to_cpu(srbreply->status));\r\nlen = min_t(u32, le32_to_cpu(srbreply->sense_data_size),\r\nSCSI_SENSE_BUFFERSIZE);\r\nscsicmd->result = DID_ERROR << 16\r\n| COMMAND_COMPLETE << 8\r\n| SAM_STAT_CHECK_CONDITION;\r\nmemcpy(scsicmd->sense_buffer,\r\nsrbreply->sense_data, len);\r\n}\r\nswitch ((le32_to_cpu(srbreply->srb_status))&0x3f) {\r\ncase SRB_STATUS_ERROR_RECOVERY:\r\ncase SRB_STATUS_PENDING:\r\ncase SRB_STATUS_SUCCESS:\r\nscsicmd->result = DID_OK << 16 | COMMAND_COMPLETE << 8;\r\nbreak;\r\ncase SRB_STATUS_DATA_OVERRUN:\r\nswitch (scsicmd->cmnd[0]) {\r\ncase READ_6:\r\ncase WRITE_6:\r\ncase READ_10:\r\ncase WRITE_10:\r\ncase READ_12:\r\ncase WRITE_12:\r\ncase READ_16:\r\ncase WRITE_16:\r\nif (le32_to_cpu(srbreply->data_xfer_length)\r\n< scsicmd->underflow)\r\nprintk(KERN_WARNING"aacraid: SCSI CMD underflow\n");\r\nelse\r\nprintk(KERN_WARNING"aacraid: SCSI CMD Data Overrun\n");\r\nscsicmd->result = DID_ERROR << 16\r\n| COMMAND_COMPLETE << 8;\r\nbreak;\r\ncase INQUIRY: {\r\nscsicmd->result = DID_OK << 16\r\n| COMMAND_COMPLETE << 8;\r\nbreak;\r\n}\r\ndefault:\r\nscsicmd->result = DID_OK << 16 | COMMAND_COMPLETE << 8;\r\nbreak;\r\n}\r\nbreak;\r\ncase SRB_STATUS_ABORTED:\r\nscsicmd->result = DID_ABORT << 16 | ABORT << 8;\r\nbreak;\r\ncase SRB_STATUS_ABORT_FAILED:\r\nscsicmd->result = DID_ERROR << 16 | ABORT << 8;\r\nbreak;\r\ncase SRB_STATUS_PARITY_ERROR:\r\nscsicmd->result = DID_PARITY << 16\r\n| MSG_PARITY_ERROR << 8;\r\nbreak;\r\ncase SRB_STATUS_NO_DEVICE:\r\ncase SRB_STATUS_INVALID_PATH_ID:\r\ncase SRB_STATUS_INVALID_TARGET_ID:\r\ncase SRB_STATUS_INVALID_LUN:\r\ncase SRB_STATUS_SELECTION_TIMEOUT:\r\nscsicmd->result = DID_NO_CONNECT << 16\r\n| COMMAND_COMPLETE << 8;\r\nbreak;\r\ncase SRB_STATUS_COMMAND_TIMEOUT:\r\ncase SRB_STATUS_TIMEOUT:\r\nscsicmd->result = DID_TIME_OUT << 16\r\n| COMMAND_COMPLETE << 8;\r\nbreak;\r\ncase SRB_STATUS_BUSY:\r\nscsicmd->result = DID_BUS_BUSY << 16\r\n| COMMAND_COMPLETE << 8;\r\nbreak;\r\ncase SRB_STATUS_BUS_RESET:\r\nscsicmd->result = DID_RESET << 16\r\n| COMMAND_COMPLETE << 8;\r\nbreak;\r\ncase SRB_STATUS_MESSAGE_REJECTED:\r\nscsicmd->result = DID_ERROR << 16\r\n| MESSAGE_REJECT << 8;\r\nbreak;\r\ncase SRB_STATUS_REQUEST_FLUSHED:\r\ncase SRB_STATUS_ERROR:\r\ncase SRB_STATUS_INVALID_REQUEST:\r\ncase SRB_STATUS_REQUEST_SENSE_FAILED:\r\ncase SRB_STATUS_NO_HBA:\r\ncase SRB_STATUS_UNEXPECTED_BUS_FREE:\r\ncase SRB_STATUS_PHASE_SEQUENCE_FAILURE:\r\ncase SRB_STATUS_BAD_SRB_BLOCK_LENGTH:\r\ncase SRB_STATUS_DELAYED_RETRY:\r\ncase SRB_STATUS_BAD_FUNCTION:\r\ncase SRB_STATUS_NOT_STARTED:\r\ncase SRB_STATUS_NOT_IN_USE:\r\ncase SRB_STATUS_FORCE_ABORT:\r\ncase SRB_STATUS_DOMAIN_VALIDATION_FAIL:\r\ndefault:\r\n#ifdef AAC_DETAILED_STATUS_INFO\r\nprintk(KERN_INFO "aacraid: SRB ERROR(%u) %s scsi cmd 0x%x - scsi status 0x%x\n",\r\nle32_to_cpu(srbreply->srb_status) & 0x3F,\r\naac_get_status_string(\r\nle32_to_cpu(srbreply->srb_status) & 0x3F),\r\nscsicmd->cmnd[0],\r\nle32_to_cpu(srbreply->scsi_status));\r\n#endif\r\nif ((scsicmd->cmnd[0] == ATA_12)\r\n|| (scsicmd->cmnd[0] == ATA_16)) {\r\nif (scsicmd->cmnd[2] & (0x01 << 5)) {\r\nscsicmd->result = DID_OK << 16\r\n| COMMAND_COMPLETE << 8;\r\nbreak;\r\n} else {\r\nscsicmd->result = DID_ERROR << 16\r\n| COMMAND_COMPLETE << 8;\r\nbreak;\r\n}\r\n} else {\r\nscsicmd->result = DID_ERROR << 16\r\n| COMMAND_COMPLETE << 8;\r\nbreak;\r\n}\r\n}\r\nif (le32_to_cpu(srbreply->scsi_status)\r\n== SAM_STAT_CHECK_CONDITION) {\r\nint len;\r\nscsicmd->result |= SAM_STAT_CHECK_CONDITION;\r\nlen = min_t(u32, le32_to_cpu(srbreply->sense_data_size),\r\nSCSI_SENSE_BUFFERSIZE);\r\n#ifdef AAC_DETAILED_STATUS_INFO\r\nprintk(KERN_WARNING "aac_srb_callback: check condition, status = %d len=%d\n",\r\nle32_to_cpu(srbreply->status), len);\r\n#endif\r\nmemcpy(scsicmd->sense_buffer,\r\nsrbreply->sense_data, len);\r\n}\r\n}\r\nscsicmd->result |= le32_to_cpu(srbreply->scsi_status);\r\naac_fib_complete(fibptr);\r\naac_fib_free(fibptr);\r\nscsicmd->scsi_done(scsicmd);\r\n}\r\nstatic int aac_send_srb_fib(struct scsi_cmnd* scsicmd)\r\n{\r\nstruct fib* cmd_fibcontext;\r\nstruct aac_dev* dev;\r\nint status;\r\ndev = (struct aac_dev *)scsicmd->device->host->hostdata;\r\nif (scmd_id(scsicmd) >= dev->maximum_num_physicals ||\r\nscsicmd->device->lun > 7) {\r\nscsicmd->result = DID_NO_CONNECT << 16;\r\nscsicmd->scsi_done(scsicmd);\r\nreturn 0;\r\n}\r\nif (!(cmd_fibcontext = aac_fib_alloc(dev))) {\r\nreturn -1;\r\n}\r\nstatus = aac_adapter_scsi(cmd_fibcontext, scsicmd);\r\nif (status == -EINPROGRESS) {\r\nscsicmd->SCp.phase = AAC_OWNER_FIRMWARE;\r\nreturn 0;\r\n}\r\nprintk(KERN_WARNING "aac_srb: aac_fib_send failed with status: %d\n", status);\r\naac_fib_complete(cmd_fibcontext);\r\naac_fib_free(cmd_fibcontext);\r\nreturn -1;\r\n}\r\nstatic long aac_build_sg(struct scsi_cmnd *scsicmd, struct sgmap *psg)\r\n{\r\nstruct aac_dev *dev;\r\nunsigned long byte_count = 0;\r\nint nseg;\r\ndev = (struct aac_dev *)scsicmd->device->host->hostdata;\r\npsg->count = 0;\r\npsg->sg[0].addr = 0;\r\npsg->sg[0].count = 0;\r\nnseg = scsi_dma_map(scsicmd);\r\nif (nseg < 0)\r\nreturn nseg;\r\nif (nseg) {\r\nstruct scatterlist *sg;\r\nint i;\r\npsg->count = cpu_to_le32(nseg);\r\nscsi_for_each_sg(scsicmd, sg, nseg, i) {\r\npsg->sg[i].addr = cpu_to_le32(sg_dma_address(sg));\r\npsg->sg[i].count = cpu_to_le32(sg_dma_len(sg));\r\nbyte_count += sg_dma_len(sg);\r\n}\r\nif (byte_count > scsi_bufflen(scsicmd)) {\r\nu32 temp = le32_to_cpu(psg->sg[i-1].count) -\r\n(byte_count - scsi_bufflen(scsicmd));\r\npsg->sg[i-1].count = cpu_to_le32(temp);\r\nbyte_count = scsi_bufflen(scsicmd);\r\n}\r\nif(scsicmd->underflow && (byte_count < scsicmd->underflow)){\r\nprintk(KERN_WARNING"aacraid: cmd len %08lX cmd underflow %08X\n",\r\nbyte_count, scsicmd->underflow);\r\n}\r\n}\r\nreturn byte_count;\r\n}\r\nstatic long aac_build_sg64(struct scsi_cmnd *scsicmd, struct sgmap64 *psg)\r\n{\r\nstruct aac_dev *dev;\r\nunsigned long byte_count = 0;\r\nu64 addr;\r\nint nseg;\r\ndev = (struct aac_dev *)scsicmd->device->host->hostdata;\r\npsg->count = 0;\r\npsg->sg[0].addr[0] = 0;\r\npsg->sg[0].addr[1] = 0;\r\npsg->sg[0].count = 0;\r\nnseg = scsi_dma_map(scsicmd);\r\nif (nseg < 0)\r\nreturn nseg;\r\nif (nseg) {\r\nstruct scatterlist *sg;\r\nint i;\r\nscsi_for_each_sg(scsicmd, sg, nseg, i) {\r\nint count = sg_dma_len(sg);\r\naddr = sg_dma_address(sg);\r\npsg->sg[i].addr[0] = cpu_to_le32(addr & 0xffffffff);\r\npsg->sg[i].addr[1] = cpu_to_le32(addr>>32);\r\npsg->sg[i].count = cpu_to_le32(count);\r\nbyte_count += count;\r\n}\r\npsg->count = cpu_to_le32(nseg);\r\nif (byte_count > scsi_bufflen(scsicmd)) {\r\nu32 temp = le32_to_cpu(psg->sg[i-1].count) -\r\n(byte_count - scsi_bufflen(scsicmd));\r\npsg->sg[i-1].count = cpu_to_le32(temp);\r\nbyte_count = scsi_bufflen(scsicmd);\r\n}\r\nif(scsicmd->underflow && (byte_count < scsicmd->underflow)){\r\nprintk(KERN_WARNING"aacraid: cmd len %08lX cmd underflow %08X\n",\r\nbyte_count, scsicmd->underflow);\r\n}\r\n}\r\nreturn byte_count;\r\n}\r\nstatic long aac_build_sgraw(struct scsi_cmnd *scsicmd, struct sgmapraw *psg)\r\n{\r\nunsigned long byte_count = 0;\r\nint nseg;\r\npsg->count = 0;\r\npsg->sg[0].next = 0;\r\npsg->sg[0].prev = 0;\r\npsg->sg[0].addr[0] = 0;\r\npsg->sg[0].addr[1] = 0;\r\npsg->sg[0].count = 0;\r\npsg->sg[0].flags = 0;\r\nnseg = scsi_dma_map(scsicmd);\r\nif (nseg < 0)\r\nreturn nseg;\r\nif (nseg) {\r\nstruct scatterlist *sg;\r\nint i;\r\nscsi_for_each_sg(scsicmd, sg, nseg, i) {\r\nint count = sg_dma_len(sg);\r\nu64 addr = sg_dma_address(sg);\r\npsg->sg[i].next = 0;\r\npsg->sg[i].prev = 0;\r\npsg->sg[i].addr[1] = cpu_to_le32((u32)(addr>>32));\r\npsg->sg[i].addr[0] = cpu_to_le32((u32)(addr & 0xffffffff));\r\npsg->sg[i].count = cpu_to_le32(count);\r\npsg->sg[i].flags = 0;\r\nbyte_count += count;\r\n}\r\npsg->count = cpu_to_le32(nseg);\r\nif (byte_count > scsi_bufflen(scsicmd)) {\r\nu32 temp = le32_to_cpu(psg->sg[i-1].count) -\r\n(byte_count - scsi_bufflen(scsicmd));\r\npsg->sg[i-1].count = cpu_to_le32(temp);\r\nbyte_count = scsi_bufflen(scsicmd);\r\n}\r\nif(scsicmd->underflow && (byte_count < scsicmd->underflow)){\r\nprintk(KERN_WARNING"aacraid: cmd len %08lX cmd underflow %08X\n",\r\nbyte_count, scsicmd->underflow);\r\n}\r\n}\r\nreturn byte_count;\r\n}\r\nstatic long aac_build_sgraw2(struct scsi_cmnd *scsicmd,\r\nstruct aac_raw_io2 *rio2, int sg_max)\r\n{\r\nunsigned long byte_count = 0;\r\nint nseg;\r\nnseg = scsi_dma_map(scsicmd);\r\nif (nseg < 0)\r\nreturn nseg;\r\nif (nseg) {\r\nstruct scatterlist *sg;\r\nint i, conformable = 0;\r\nu32 min_size = PAGE_SIZE, cur_size;\r\nscsi_for_each_sg(scsicmd, sg, nseg, i) {\r\nint count = sg_dma_len(sg);\r\nu64 addr = sg_dma_address(sg);\r\nBUG_ON(i >= sg_max);\r\nrio2->sge[i].addrHigh = cpu_to_le32((u32)(addr>>32));\r\nrio2->sge[i].addrLow = cpu_to_le32((u32)(addr & 0xffffffff));\r\ncur_size = cpu_to_le32(count);\r\nrio2->sge[i].length = cur_size;\r\nrio2->sge[i].flags = 0;\r\nif (i == 0) {\r\nconformable = 1;\r\nrio2->sgeFirstSize = cur_size;\r\n} else if (i == 1) {\r\nrio2->sgeNominalSize = cur_size;\r\nmin_size = cur_size;\r\n} else if ((i+1) < nseg && cur_size != rio2->sgeNominalSize) {\r\nconformable = 0;\r\nif (cur_size < min_size)\r\nmin_size = cur_size;\r\n}\r\nbyte_count += count;\r\n}\r\nif (byte_count > scsi_bufflen(scsicmd)) {\r\nu32 temp = le32_to_cpu(rio2->sge[i-1].length) -\r\n(byte_count - scsi_bufflen(scsicmd));\r\nrio2->sge[i-1].length = cpu_to_le32(temp);\r\nbyte_count = scsi_bufflen(scsicmd);\r\n}\r\nrio2->sgeCnt = cpu_to_le32(nseg);\r\nrio2->flags |= cpu_to_le16(RIO2_SG_FORMAT_IEEE1212);\r\nif (!conformable) {\r\nint j, nseg_new = nseg, err_found;\r\nfor (i = min_size / PAGE_SIZE; i >= 1; --i) {\r\nerr_found = 0;\r\nnseg_new = 2;\r\nfor (j = 1; j < nseg - 1; ++j) {\r\nif (rio2->sge[j].length % (i*PAGE_SIZE)) {\r\nerr_found = 1;\r\nbreak;\r\n}\r\nnseg_new += (rio2->sge[j].length / (i*PAGE_SIZE));\r\n}\r\nif (!err_found)\r\nbreak;\r\n}\r\nif (i > 0 && nseg_new <= sg_max)\r\naac_convert_sgraw2(rio2, i, nseg, nseg_new);\r\n} else\r\nrio2->flags |= cpu_to_le16(RIO2_SGL_CONFORMANT);\r\nif (scsicmd->underflow && (byte_count < scsicmd->underflow)) {\r\nprintk(KERN_WARNING"aacraid: cmd len %08lX cmd underflow %08X\n",\r\nbyte_count, scsicmd->underflow);\r\n}\r\n}\r\nreturn byte_count;\r\n}\r\nstatic int aac_convert_sgraw2(struct aac_raw_io2 *rio2, int pages, int nseg, int nseg_new)\r\n{\r\nstruct sge_ieee1212 *sge;\r\nint i, j, pos;\r\nu32 addr_low;\r\nif (aac_convert_sgl == 0)\r\nreturn 0;\r\nsge = kmalloc(nseg_new * sizeof(struct sge_ieee1212), GFP_ATOMIC);\r\nif (sge == NULL)\r\nreturn -1;\r\nfor (i = 1, pos = 1; i < nseg-1; ++i) {\r\nfor (j = 0; j < rio2->sge[i].length / (pages * PAGE_SIZE); ++j) {\r\naddr_low = rio2->sge[i].addrLow + j * pages * PAGE_SIZE;\r\nsge[pos].addrLow = addr_low;\r\nsge[pos].addrHigh = rio2->sge[i].addrHigh;\r\nif (addr_low < rio2->sge[i].addrLow)\r\nsge[pos].addrHigh++;\r\nsge[pos].length = pages * PAGE_SIZE;\r\nsge[pos].flags = 0;\r\npos++;\r\n}\r\n}\r\nsge[pos] = rio2->sge[nseg-1];\r\nmemcpy(&rio2->sge[1], &sge[1], (nseg_new-1)*sizeof(struct sge_ieee1212));\r\nkfree(sge);\r\nrio2->sgeCnt = cpu_to_le32(nseg_new);\r\nrio2->flags |= cpu_to_le16(RIO2_SGL_CONFORMANT);\r\nrio2->sgeNominalSize = pages * PAGE_SIZE;\r\nreturn 0;\r\n}\r\nchar *aac_get_status_string(u32 status)\r\n{\r\nint i;\r\nfor (i = 0; i < ARRAY_SIZE(srb_status_info); i++)\r\nif (srb_status_info[i].status == status)\r\nreturn srb_status_info[i].str;\r\nreturn "Bad Status Code";\r\n}
