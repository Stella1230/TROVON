static bool initialize(struct kernel_queue *kq, struct kfd_dev *dev,\r\nenum kfd_queue_type type, unsigned int queue_size)\r\n{\r\nstruct queue_properties prop;\r\nint retval;\r\nunion PM4_MES_TYPE_3_HEADER nop;\r\nBUG_ON(!kq || !dev);\r\nBUG_ON(type != KFD_QUEUE_TYPE_DIQ && type != KFD_QUEUE_TYPE_HIQ);\r\npr_debug("amdkfd: In func %s initializing queue type %d size %d\n",\r\n__func__, KFD_QUEUE_TYPE_HIQ, queue_size);\r\nnop.opcode = IT_NOP;\r\nnop.type = PM4_TYPE_3;\r\nnop.u32all |= PM4_COUNT_ZERO;\r\nkq->dev = dev;\r\nkq->nop_packet = nop.u32all;\r\nswitch (type) {\r\ncase KFD_QUEUE_TYPE_DIQ:\r\ncase KFD_QUEUE_TYPE_HIQ:\r\nkq->mqd = dev->dqm->ops.get_mqd_manager(dev->dqm,\r\nKFD_MQD_TYPE_HIQ);\r\nbreak;\r\ndefault:\r\nBUG();\r\nbreak;\r\n}\r\nif (kq->mqd == NULL)\r\nreturn false;\r\nprop.doorbell_ptr = kfd_get_kernel_doorbell(dev, &prop.doorbell_off);\r\nif (prop.doorbell_ptr == NULL) {\r\npr_err("amdkfd: error init doorbell");\r\ngoto err_get_kernel_doorbell;\r\n}\r\nretval = kfd_gtt_sa_allocate(dev, queue_size, &kq->pq);\r\nif (retval != 0) {\r\npr_err("amdkfd: error init pq queues size (%d)\n", queue_size);\r\ngoto err_pq_allocate_vidmem;\r\n}\r\nkq->pq_kernel_addr = kq->pq->cpu_ptr;\r\nkq->pq_gpu_addr = kq->pq->gpu_addr;\r\nretval = kq->ops_asic_specific.initialize(kq, dev, type, queue_size);\r\nif (retval == false)\r\ngoto err_eop_allocate_vidmem;\r\nretval = kfd_gtt_sa_allocate(dev, sizeof(*kq->rptr_kernel),\r\n&kq->rptr_mem);\r\nif (retval != 0)\r\ngoto err_rptr_allocate_vidmem;\r\nkq->rptr_kernel = kq->rptr_mem->cpu_ptr;\r\nkq->rptr_gpu_addr = kq->rptr_mem->gpu_addr;\r\nretval = kfd_gtt_sa_allocate(dev, sizeof(*kq->wptr_kernel),\r\n&kq->wptr_mem);\r\nif (retval != 0)\r\ngoto err_wptr_allocate_vidmem;\r\nkq->wptr_kernel = kq->wptr_mem->cpu_ptr;\r\nkq->wptr_gpu_addr = kq->wptr_mem->gpu_addr;\r\nmemset(kq->pq_kernel_addr, 0, queue_size);\r\nmemset(kq->rptr_kernel, 0, sizeof(*kq->rptr_kernel));\r\nmemset(kq->wptr_kernel, 0, sizeof(*kq->wptr_kernel));\r\nprop.queue_size = queue_size;\r\nprop.is_interop = false;\r\nprop.priority = 1;\r\nprop.queue_percent = 100;\r\nprop.type = type;\r\nprop.vmid = 0;\r\nprop.queue_address = kq->pq_gpu_addr;\r\nprop.read_ptr = (uint32_t *) kq->rptr_gpu_addr;\r\nprop.write_ptr = (uint32_t *) kq->wptr_gpu_addr;\r\nprop.eop_ring_buffer_address = kq->eop_gpu_addr;\r\nprop.eop_ring_buffer_size = PAGE_SIZE;\r\nif (init_queue(&kq->queue, prop) != 0)\r\ngoto err_init_queue;\r\nkq->queue->device = dev;\r\nkq->queue->process = kfd_get_process(current);\r\nretval = kq->mqd->init_mqd(kq->mqd, &kq->queue->mqd,\r\n&kq->queue->mqd_mem_obj,\r\n&kq->queue->gart_mqd_addr,\r\n&kq->queue->properties);\r\nif (retval != 0)\r\ngoto err_init_mqd;\r\nif (type == KFD_QUEUE_TYPE_HIQ) {\r\npr_debug("assigning hiq to hqd\n");\r\nkq->queue->pipe = KFD_CIK_HIQ_PIPE;\r\nkq->queue->queue = KFD_CIK_HIQ_QUEUE;\r\nkq->mqd->load_mqd(kq->mqd, kq->queue->mqd, kq->queue->pipe,\r\nkq->queue->queue, NULL);\r\n} else {\r\nretval = kfd_gtt_sa_allocate(dev, sizeof(uint32_t),\r\n&kq->fence_mem_obj);\r\nif (retval != 0)\r\ngoto err_alloc_fence;\r\nkq->fence_kernel_address = kq->fence_mem_obj->cpu_ptr;\r\nkq->fence_gpu_addr = kq->fence_mem_obj->gpu_addr;\r\n}\r\nprint_queue(kq->queue);\r\nreturn true;\r\nerr_alloc_fence:\r\nerr_init_mqd:\r\nuninit_queue(kq->queue);\r\nerr_init_queue:\r\nkfd_gtt_sa_free(dev, kq->wptr_mem);\r\nerr_wptr_allocate_vidmem:\r\nkfd_gtt_sa_free(dev, kq->rptr_mem);\r\nerr_rptr_allocate_vidmem:\r\nkfd_gtt_sa_free(dev, kq->eop_mem);\r\nerr_eop_allocate_vidmem:\r\nkfd_gtt_sa_free(dev, kq->pq);\r\nerr_pq_allocate_vidmem:\r\nkfd_release_kernel_doorbell(dev, prop.doorbell_ptr);\r\nerr_get_kernel_doorbell:\r\nreturn false;\r\n}\r\nstatic void uninitialize(struct kernel_queue *kq)\r\n{\r\nBUG_ON(!kq);\r\nif (kq->queue->properties.type == KFD_QUEUE_TYPE_HIQ)\r\nkq->mqd->destroy_mqd(kq->mqd,\r\nNULL,\r\nfalse,\r\nQUEUE_PREEMPT_DEFAULT_TIMEOUT_MS,\r\nkq->queue->pipe,\r\nkq->queue->queue);\r\nelse if (kq->queue->properties.type == KFD_QUEUE_TYPE_DIQ)\r\nkfd_gtt_sa_free(kq->dev, kq->fence_mem_obj);\r\nkq->mqd->uninit_mqd(kq->mqd, kq->queue->mqd, kq->queue->mqd_mem_obj);\r\nkfd_gtt_sa_free(kq->dev, kq->rptr_mem);\r\nkfd_gtt_sa_free(kq->dev, kq->wptr_mem);\r\nkq->ops_asic_specific.uninitialize(kq);\r\nkfd_gtt_sa_free(kq->dev, kq->pq);\r\nkfd_release_kernel_doorbell(kq->dev,\r\nkq->queue->properties.doorbell_ptr);\r\nuninit_queue(kq->queue);\r\n}\r\nstatic int acquire_packet_buffer(struct kernel_queue *kq,\r\nsize_t packet_size_in_dwords, unsigned int **buffer_ptr)\r\n{\r\nsize_t available_size;\r\nsize_t queue_size_dwords;\r\nuint32_t wptr, rptr;\r\nunsigned int *queue_address;\r\nBUG_ON(!kq || !buffer_ptr);\r\nrptr = *kq->rptr_kernel;\r\nwptr = *kq->wptr_kernel;\r\nqueue_address = (unsigned int *)kq->pq_kernel_addr;\r\nqueue_size_dwords = kq->queue->properties.queue_size / sizeof(uint32_t);\r\npr_debug("rptr: %d\n", rptr);\r\npr_debug("wptr: %d\n", wptr);\r\npr_debug("queue_address 0x%p\n", queue_address);\r\navailable_size = (rptr - 1 - wptr + queue_size_dwords) %\r\nqueue_size_dwords;\r\nif (packet_size_in_dwords >= queue_size_dwords ||\r\npacket_size_in_dwords >= available_size) {\r\n*buffer_ptr = NULL;\r\nreturn -ENOMEM;\r\n}\r\nif (wptr + packet_size_in_dwords >= queue_size_dwords) {\r\nwhile (wptr > 0) {\r\nqueue_address[wptr] = kq->nop_packet;\r\nwptr = (wptr + 1) % queue_size_dwords;\r\n}\r\n}\r\n*buffer_ptr = &queue_address[wptr];\r\nkq->pending_wptr = wptr + packet_size_in_dwords;\r\nreturn 0;\r\n}\r\nstatic void submit_packet(struct kernel_queue *kq)\r\n{\r\n#ifdef DEBUG\r\nint i;\r\n#endif\r\nBUG_ON(!kq);\r\n#ifdef DEBUG\r\nfor (i = *kq->wptr_kernel; i < kq->pending_wptr; i++) {\r\npr_debug("0x%2X ", kq->pq_kernel_addr[i]);\r\nif (i % 15 == 0)\r\npr_debug("\n");\r\n}\r\npr_debug("\n");\r\n#endif\r\n*kq->wptr_kernel = kq->pending_wptr;\r\nwrite_kernel_doorbell(kq->queue->properties.doorbell_ptr,\r\nkq->pending_wptr);\r\n}\r\nstatic void rollback_packet(struct kernel_queue *kq)\r\n{\r\nBUG_ON(!kq);\r\nkq->pending_wptr = *kq->queue->properties.write_ptr;\r\n}\r\nstruct kernel_queue *kernel_queue_init(struct kfd_dev *dev,\r\nenum kfd_queue_type type)\r\n{\r\nstruct kernel_queue *kq;\r\nBUG_ON(!dev);\r\nkq = kzalloc(sizeof(struct kernel_queue), GFP_KERNEL);\r\nif (!kq)\r\nreturn NULL;\r\nkq->ops.initialize = initialize;\r\nkq->ops.uninitialize = uninitialize;\r\nkq->ops.acquire_packet_buffer = acquire_packet_buffer;\r\nkq->ops.submit_packet = submit_packet;\r\nkq->ops.rollback_packet = rollback_packet;\r\nswitch (dev->device_info->asic_family) {\r\ncase CHIP_CARRIZO:\r\nkernel_queue_init_vi(&kq->ops_asic_specific);\r\nbreak;\r\ncase CHIP_KAVERI:\r\nkernel_queue_init_cik(&kq->ops_asic_specific);\r\nbreak;\r\n}\r\nif (kq->ops.initialize(kq, dev, type, KFD_KERNEL_QUEUE_SIZE) == false) {\r\npr_err("amdkfd: failed to init kernel queue\n");\r\nkfree(kq);\r\nreturn NULL;\r\n}\r\nreturn kq;\r\n}\r\nvoid kernel_queue_uninit(struct kernel_queue *kq)\r\n{\r\nBUG_ON(!kq);\r\nkq->ops.uninitialize(kq);\r\nkfree(kq);\r\n}
