static void usage(void)\r\n{\r\nprintf("Usage: fds_example [...]\n");\r\nprintf(" -F <file> File to pin/get object\n");\r\nprintf(" -P |- pin object\n");\r\nprintf(" -G `- get object\n");\r\nprintf(" -m eBPF map mode\n");\r\nprintf(" -k <key> |- map key\n");\r\nprintf(" -v <value> `- map value\n");\r\nprintf(" -p eBPF prog mode\n");\r\nprintf(" -o <object> `- object file\n");\r\nprintf(" -h Display this help.\n");\r\n}\r\nstatic int bpf_map_create(void)\r\n{\r\nreturn bpf_create_map(BPF_MAP_TYPE_ARRAY, sizeof(uint32_t),\r\nsizeof(uint32_t), 1024);\r\n}\r\nstatic int bpf_prog_create(const char *object)\r\n{\r\nstatic const struct bpf_insn insns[] = {\r\nBPF_MOV64_IMM(BPF_REG_0, 1),\r\nBPF_EXIT_INSN(),\r\n};\r\nif (object) {\r\nassert(!load_bpf_file((char *)object));\r\nreturn prog_fd[0];\r\n} else {\r\nreturn bpf_prog_load(BPF_PROG_TYPE_SOCKET_FILTER,\r\ninsns, sizeof(insns), "GPL", 0);\r\n}\r\n}\r\nstatic int bpf_do_map(const char *file, uint32_t flags, uint32_t key,\r\nuint32_t value)\r\n{\r\nint fd, ret;\r\nif (flags & BPF_F_PIN) {\r\nfd = bpf_map_create();\r\nprintf("bpf: map fd:%d (%s)\n", fd, strerror(errno));\r\nassert(fd > 0);\r\nret = bpf_obj_pin(fd, file);\r\nprintf("bpf: pin ret:(%d,%s)\n", ret, strerror(errno));\r\nassert(ret == 0);\r\n} else {\r\nfd = bpf_obj_get(file);\r\nprintf("bpf: get fd:%d (%s)\n", fd, strerror(errno));\r\nassert(fd > 0);\r\n}\r\nif ((flags & BPF_F_KEY_VAL) == BPF_F_KEY_VAL) {\r\nret = bpf_update_elem(fd, &key, &value, 0);\r\nprintf("bpf: fd:%d u->(%u:%u) ret:(%d,%s)\n", fd, key, value,\r\nret, strerror(errno));\r\nassert(ret == 0);\r\n} else if (flags & BPF_F_KEY) {\r\nret = bpf_lookup_elem(fd, &key, &value);\r\nprintf("bpf: fd:%d l->(%u):%u ret:(%d,%s)\n", fd, key, value,\r\nret, strerror(errno));\r\nassert(ret == 0);\r\n}\r\nreturn 0;\r\n}\r\nstatic int bpf_do_prog(const char *file, uint32_t flags, const char *object)\r\n{\r\nint fd, sock, ret;\r\nif (flags & BPF_F_PIN) {\r\nfd = bpf_prog_create(object);\r\nprintf("bpf: prog fd:%d (%s)\n", fd, strerror(errno));\r\nassert(fd > 0);\r\nret = bpf_obj_pin(fd, file);\r\nprintf("bpf: pin ret:(%d,%s)\n", ret, strerror(errno));\r\nassert(ret == 0);\r\n} else {\r\nfd = bpf_obj_get(file);\r\nprintf("bpf: get fd:%d (%s)\n", fd, strerror(errno));\r\nassert(fd > 0);\r\n}\r\nsock = open_raw_sock("lo");\r\nassert(sock > 0);\r\nret = setsockopt(sock, SOL_SOCKET, SO_ATTACH_BPF, &fd, sizeof(fd));\r\nprintf("bpf: sock:%d <- fd:%d attached ret:(%d,%s)\n", sock, fd,\r\nret, strerror(errno));\r\nassert(ret == 0);\r\nreturn 0;\r\n}\r\nint main(int argc, char **argv)\r\n{\r\nconst char *file = NULL, *object = NULL;\r\nuint32_t key = 0, value = 0, flags = 0;\r\nint opt, mode = BPF_M_UNSPEC;\r\nwhile ((opt = getopt(argc, argv, "F:PGmk:v:po:")) != -1) {\r\nswitch (opt) {\r\ncase 'F':\r\nfile = optarg;\r\nbreak;\r\ncase 'P':\r\nflags |= BPF_F_PIN;\r\nbreak;\r\ncase 'G':\r\nflags |= BPF_F_GET;\r\nbreak;\r\ncase 'm':\r\nmode = BPF_M_MAP;\r\nbreak;\r\ncase 'k':\r\nkey = strtoul(optarg, NULL, 0);\r\nflags |= BPF_F_KEY;\r\nbreak;\r\ncase 'v':\r\nvalue = strtoul(optarg, NULL, 0);\r\nflags |= BPF_F_VAL;\r\nbreak;\r\ncase 'p':\r\nmode = BPF_M_PROG;\r\nbreak;\r\ncase 'o':\r\nobject = optarg;\r\nbreak;\r\ndefault:\r\ngoto out;\r\n}\r\n}\r\nif (!(flags & BPF_F_PIN_GET) || !file)\r\ngoto out;\r\nswitch (mode) {\r\ncase BPF_M_MAP:\r\nreturn bpf_do_map(file, flags, key, value);\r\ncase BPF_M_PROG:\r\nreturn bpf_do_prog(file, flags, object);\r\n}\r\nout:\r\nusage();\r\nreturn -1;\r\n}
