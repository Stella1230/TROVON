void *\r\nocteon_alloc_soft_command_resp(struct octeon_device *oct,\r\nstruct octeon_instr_64B *cmd,\r\nsize_t rdatasize)\r\n{\r\nstruct octeon_soft_command *sc;\r\nstruct octeon_instr_ih *ih;\r\nstruct octeon_instr_irh *irh;\r\nstruct octeon_instr_rdp *rdp;\r\nsc = (struct octeon_soft_command *)\r\nocteon_alloc_soft_command(oct, 0, rdatasize, 0);\r\nif (!sc)\r\nreturn NULL;\r\nmemcpy(&sc->cmd, cmd, sizeof(struct octeon_instr_64B));\r\nih = (struct octeon_instr_ih *)&sc->cmd.ih;\r\nih->fsz = 40;\r\nirh = (struct octeon_instr_irh *)&sc->cmd.irh;\r\nirh->rflag = 1;\r\nirh->len = 4;\r\nrdp = (struct octeon_instr_rdp *)&sc->cmd.rdp;\r\nrdp->pcie_port = oct->pcie_port;\r\nrdp->rlen = rdatasize;\r\n*sc->status_word = COMPLETION_WORD_INIT;\r\nsc->wait_time = 1000;\r\nsc->timeout = jiffies + sc->wait_time;\r\nreturn sc;\r\n}\r\nint octnet_send_nic_data_pkt(struct octeon_device *oct,\r\nstruct octnic_data_pkt *ndata,\r\nu32 xmit_more)\r\n{\r\nint ring_doorbell;\r\nring_doorbell = !xmit_more;\r\nreturn octeon_send_command(oct, ndata->q_no, ring_doorbell, &ndata->cmd,\r\nndata->buf, ndata->datasize,\r\nndata->reqtype);\r\n}\r\nstatic void octnet_link_ctrl_callback(struct octeon_device *oct,\r\nu32 status,\r\nvoid *sc_ptr)\r\n{\r\nstruct octeon_soft_command *sc = (struct octeon_soft_command *)sc_ptr;\r\nstruct octnic_ctrl_pkt *nctrl;\r\nnctrl = (struct octnic_ctrl_pkt *)sc->ctxptr;\r\nif (!status && nctrl->cb_fn)\r\nnctrl->cb_fn(nctrl);\r\nocteon_free_soft_command(oct, sc);\r\n}\r\nstatic inline struct octeon_soft_command\r\n*octnic_alloc_ctrl_pkt_sc(struct octeon_device *oct,\r\nstruct octnic_ctrl_pkt *nctrl,\r\nstruct octnic_ctrl_params nparams)\r\n{\r\nstruct octeon_soft_command *sc = NULL;\r\nu8 *data;\r\nsize_t rdatasize;\r\nu32 uddsize = 0, datasize = 0;\r\nuddsize = (u32)(nctrl->ncmd.s.more * 8);\r\ndatasize = OCTNET_CMD_SIZE + uddsize;\r\nrdatasize = (nctrl->wait_time) ? 16 : 0;\r\nsc = (struct octeon_soft_command *)\r\nocteon_alloc_soft_command(oct, datasize, rdatasize,\r\nsizeof(struct octnic_ctrl_pkt));\r\nif (!sc)\r\nreturn NULL;\r\nmemcpy(sc->ctxptr, nctrl, sizeof(struct octnic_ctrl_pkt));\r\ndata = (u8 *)sc->virtdptr;\r\nmemcpy(data, &nctrl->ncmd, OCTNET_CMD_SIZE);\r\nocteon_swap_8B_data((u64 *)data, (OCTNET_CMD_SIZE >> 3));\r\nif (uddsize) {\r\nmemcpy(data + OCTNET_CMD_SIZE, nctrl->udd, uddsize);\r\n}\r\nocteon_prepare_soft_command(oct, sc, OPCODE_NIC, OPCODE_NIC_CMD,\r\n0, 0, 0);\r\nsc->callback = octnet_link_ctrl_callback;\r\nsc->callback_arg = sc;\r\nsc->wait_time = nctrl->wait_time;\r\nreturn sc;\r\n}\r\nint\r\noctnet_send_nic_ctrl_pkt(struct octeon_device *oct,\r\nstruct octnic_ctrl_pkt *nctrl,\r\nstruct octnic_ctrl_params nparams)\r\n{\r\nint retval;\r\nstruct octeon_soft_command *sc = NULL;\r\nsc = octnic_alloc_ctrl_pkt_sc(oct, nctrl, nparams);\r\nif (!sc) {\r\ndev_err(&oct->pci_dev->dev, "%s soft command alloc failed\n",\r\n__func__);\r\nreturn -1;\r\n}\r\nretval = octeon_send_soft_command(oct, sc);\r\nif (retval) {\r\nocteon_free_soft_command(oct, sc);\r\ndev_err(&oct->pci_dev->dev, "%s soft command send failed status: %x\n",\r\n__func__, retval);\r\nreturn -1;\r\n}\r\nreturn retval;\r\n}
