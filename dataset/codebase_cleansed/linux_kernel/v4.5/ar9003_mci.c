static void ar9003_mci_reset_req_wakeup(struct ath_hw *ah)\r\n{\r\nREG_RMW_FIELD(ah, AR_MCI_COMMAND2,\r\nAR_MCI_COMMAND2_RESET_REQ_WAKEUP, 1);\r\nudelay(1);\r\nREG_RMW_FIELD(ah, AR_MCI_COMMAND2,\r\nAR_MCI_COMMAND2_RESET_REQ_WAKEUP, 0);\r\n}\r\nstatic int ar9003_mci_wait_for_interrupt(struct ath_hw *ah, u32 address,\r\nu32 bit_position, int time_out)\r\n{\r\nstruct ath_common *common = ath9k_hw_common(ah);\r\nwhile (time_out) {\r\nif (!(REG_READ(ah, address) & bit_position)) {\r\nudelay(10);\r\ntime_out -= 10;\r\nif (time_out < 0)\r\nbreak;\r\nelse\r\ncontinue;\r\n}\r\nREG_WRITE(ah, address, bit_position);\r\nif (address != AR_MCI_INTERRUPT_RX_MSG_RAW)\r\nbreak;\r\nif (bit_position & AR_MCI_INTERRUPT_RX_MSG_REQ_WAKE)\r\nar9003_mci_reset_req_wakeup(ah);\r\nif (bit_position & (AR_MCI_INTERRUPT_RX_MSG_SYS_SLEEPING |\r\nAR_MCI_INTERRUPT_RX_MSG_SYS_WAKING))\r\nREG_WRITE(ah, AR_MCI_INTERRUPT_RAW,\r\nAR_MCI_INTERRUPT_REMOTE_SLEEP_UPDATE);\r\nREG_WRITE(ah, AR_MCI_INTERRUPT_RAW, AR_MCI_INTERRUPT_RX_MSG);\r\nbreak;\r\n}\r\nif (time_out <= 0) {\r\nath_dbg(common, MCI,\r\n"MCI Wait for Reg 0x%08x = 0x%08x timeout\n",\r\naddress, bit_position);\r\nath_dbg(common, MCI,\r\n"MCI INT_RAW = 0x%08x, RX_MSG_RAW = 0x%08x\n",\r\nREG_READ(ah, AR_MCI_INTERRUPT_RAW),\r\nREG_READ(ah, AR_MCI_INTERRUPT_RX_MSG_RAW));\r\ntime_out = 0;\r\n}\r\nreturn time_out;\r\n}\r\nstatic void ar9003_mci_remote_reset(struct ath_hw *ah, bool wait_done)\r\n{\r\nu32 payload[4] = { 0xffffffff, 0xffffffff, 0xffffffff, 0xffffff00};\r\nar9003_mci_send_message(ah, MCI_REMOTE_RESET, 0, payload, 16,\r\nwait_done, false);\r\nudelay(5);\r\n}\r\nstatic void ar9003_mci_send_lna_transfer(struct ath_hw *ah, bool wait_done)\r\n{\r\nu32 payload = 0x00000000;\r\nar9003_mci_send_message(ah, MCI_LNA_TRANS, 0, &payload, 1,\r\nwait_done, false);\r\n}\r\nstatic void ar9003_mci_send_req_wake(struct ath_hw *ah, bool wait_done)\r\n{\r\nar9003_mci_send_message(ah, MCI_REQ_WAKE, MCI_FLAG_DISABLE_TIMESTAMP,\r\nNULL, 0, wait_done, false);\r\nudelay(5);\r\n}\r\nstatic void ar9003_mci_send_sys_waking(struct ath_hw *ah, bool wait_done)\r\n{\r\nar9003_mci_send_message(ah, MCI_SYS_WAKING, MCI_FLAG_DISABLE_TIMESTAMP,\r\nNULL, 0, wait_done, false);\r\n}\r\nstatic void ar9003_mci_send_lna_take(struct ath_hw *ah, bool wait_done)\r\n{\r\nu32 payload = 0x70000000;\r\nar9003_mci_send_message(ah, MCI_LNA_TAKE, 0, &payload, 1,\r\nwait_done, false);\r\n}\r\nstatic void ar9003_mci_send_sys_sleeping(struct ath_hw *ah, bool wait_done)\r\n{\r\nar9003_mci_send_message(ah, MCI_SYS_SLEEPING,\r\nMCI_FLAG_DISABLE_TIMESTAMP,\r\nNULL, 0, wait_done, false);\r\n}\r\nstatic void ar9003_mci_send_coex_version_query(struct ath_hw *ah,\r\nbool wait_done)\r\n{\r\nstruct ath9k_hw_mci *mci = &ah->btcoex_hw.mci;\r\nu32 payload[4] = {0, 0, 0, 0};\r\nif (mci->bt_version_known ||\r\n(mci->bt_state == MCI_BT_SLEEP))\r\nreturn;\r\nMCI_GPM_SET_TYPE_OPCODE(payload, MCI_GPM_COEX_AGENT,\r\nMCI_GPM_COEX_VERSION_QUERY);\r\nar9003_mci_send_message(ah, MCI_GPM, 0, payload, 16, wait_done, true);\r\n}\r\nstatic void ar9003_mci_send_coex_version_response(struct ath_hw *ah,\r\nbool wait_done)\r\n{\r\nstruct ath9k_hw_mci *mci = &ah->btcoex_hw.mci;\r\nu32 payload[4] = {0, 0, 0, 0};\r\nMCI_GPM_SET_TYPE_OPCODE(payload, MCI_GPM_COEX_AGENT,\r\nMCI_GPM_COEX_VERSION_RESPONSE);\r\n*(((u8 *)payload) + MCI_GPM_COEX_B_MAJOR_VERSION) =\r\nmci->wlan_ver_major;\r\n*(((u8 *)payload) + MCI_GPM_COEX_B_MINOR_VERSION) =\r\nmci->wlan_ver_minor;\r\nar9003_mci_send_message(ah, MCI_GPM, 0, payload, 16, wait_done, true);\r\n}\r\nstatic void ar9003_mci_send_coex_wlan_channels(struct ath_hw *ah,\r\nbool wait_done)\r\n{\r\nstruct ath9k_hw_mci *mci = &ah->btcoex_hw.mci;\r\nu32 *payload = &mci->wlan_channels[0];\r\nif (!mci->wlan_channels_update ||\r\n(mci->bt_state == MCI_BT_SLEEP))\r\nreturn;\r\nMCI_GPM_SET_TYPE_OPCODE(payload, MCI_GPM_COEX_AGENT,\r\nMCI_GPM_COEX_WLAN_CHANNELS);\r\nar9003_mci_send_message(ah, MCI_GPM, 0, payload, 16, wait_done, true);\r\nMCI_GPM_SET_TYPE_OPCODE(payload, 0xff, 0xff);\r\n}\r\nstatic void ar9003_mci_send_coex_bt_status_query(struct ath_hw *ah,\r\nbool wait_done, u8 query_type)\r\n{\r\nstruct ath9k_hw_mci *mci = &ah->btcoex_hw.mci;\r\nu32 payload[4] = {0, 0, 0, 0};\r\nbool query_btinfo;\r\nif (mci->bt_state == MCI_BT_SLEEP)\r\nreturn;\r\nquery_btinfo = !!(query_type & (MCI_GPM_COEX_QUERY_BT_ALL_INFO |\r\nMCI_GPM_COEX_QUERY_BT_TOPOLOGY));\r\nMCI_GPM_SET_TYPE_OPCODE(payload, MCI_GPM_COEX_AGENT,\r\nMCI_GPM_COEX_STATUS_QUERY);\r\n*(((u8 *)payload) + MCI_GPM_COEX_B_BT_BITMAP) = query_type;\r\nif (!ar9003_mci_send_message(ah, MCI_GPM, 0, payload, 16,\r\nwait_done, true)) {\r\nif (query_btinfo)\r\nmci->need_flush_btinfo = true;\r\n}\r\nif (query_btinfo)\r\nmci->query_bt = false;\r\n}\r\nstatic void ar9003_mci_send_coex_halt_bt_gpm(struct ath_hw *ah, bool halt,\r\nbool wait_done)\r\n{\r\nstruct ath9k_hw_mci *mci = &ah->btcoex_hw.mci;\r\nu32 payload[4] = {0, 0, 0, 0};\r\nMCI_GPM_SET_TYPE_OPCODE(payload, MCI_GPM_COEX_AGENT,\r\nMCI_GPM_COEX_HALT_BT_GPM);\r\nif (halt) {\r\nmci->query_bt = true;\r\nmci->unhalt_bt_gpm = true;\r\nmci->need_flush_btinfo = true;\r\n*(((u8 *)payload) + MCI_GPM_COEX_B_HALT_STATE) =\r\nMCI_GPM_COEX_BT_GPM_HALT;\r\n} else\r\n*(((u8 *)payload) + MCI_GPM_COEX_B_HALT_STATE) =\r\nMCI_GPM_COEX_BT_GPM_UNHALT;\r\nar9003_mci_send_message(ah, MCI_GPM, 0, payload, 16, wait_done, true);\r\n}\r\nstatic void ar9003_mci_prep_interface(struct ath_hw *ah)\r\n{\r\nstruct ath_common *common = ath9k_hw_common(ah);\r\nstruct ath9k_hw_mci *mci = &ah->btcoex_hw.mci;\r\nu32 saved_mci_int_en;\r\nu32 mci_timeout = 150;\r\nmci->bt_state = MCI_BT_SLEEP;\r\nsaved_mci_int_en = REG_READ(ah, AR_MCI_INTERRUPT_EN);\r\nREG_WRITE(ah, AR_MCI_INTERRUPT_EN, 0);\r\nREG_WRITE(ah, AR_MCI_INTERRUPT_RX_MSG_RAW,\r\nREG_READ(ah, AR_MCI_INTERRUPT_RX_MSG_RAW));\r\nREG_WRITE(ah, AR_MCI_INTERRUPT_RAW,\r\nREG_READ(ah, AR_MCI_INTERRUPT_RAW));\r\nar9003_mci_remote_reset(ah, true);\r\nar9003_mci_send_req_wake(ah, true);\r\nif (!ar9003_mci_wait_for_interrupt(ah, AR_MCI_INTERRUPT_RX_MSG_RAW,\r\nAR_MCI_INTERRUPT_RX_MSG_SYS_WAKING, 500))\r\ngoto clear_redunt;\r\nmci->bt_state = MCI_BT_AWAKE;\r\nar9003_mci_send_sys_waking(ah, true);\r\nudelay(10);\r\nREG_WRITE(ah, AR_MCI_BT_PRI0, 0xFFFFFFFF);\r\nREG_WRITE(ah, AR_MCI_BT_PRI1, 0xFFFFFFFF);\r\nREG_WRITE(ah, AR_MCI_BT_PRI2, 0xFFFFFFFF);\r\nREG_WRITE(ah, AR_MCI_BT_PRI3, 0xFFFFFFFF);\r\nREG_WRITE(ah, AR_MCI_BT_PRI, 0X000000FF);\r\nREG_WRITE(ah, AR_MCI_INTERRUPT_RX_MSG_RAW,\r\nAR_MCI_INTERRUPT_RX_MSG_CONT_RST);\r\nREG_WRITE(ah, AR_MCI_INTERRUPT_RAW, AR_MCI_INTERRUPT_BT_PRI);\r\nif (mci->is_2g && MCI_ANT_ARCH_PA_LNA_SHARED(mci)) {\r\nar9003_mci_send_lna_transfer(ah, true);\r\nudelay(5);\r\n}\r\nif (mci->is_2g && !mci->update_2g5g && MCI_ANT_ARCH_PA_LNA_SHARED(mci)) {\r\nif (ar9003_mci_wait_for_interrupt(ah,\r\nAR_MCI_INTERRUPT_RX_MSG_RAW,\r\nAR_MCI_INTERRUPT_RX_MSG_LNA_INFO,\r\nmci_timeout))\r\nath_dbg(common, MCI,\r\n"MCI WLAN has control over the LNA & BT obeys it\n");\r\nelse\r\nath_dbg(common, MCI,\r\n"MCI BT didn't respond to LNA_TRANS\n");\r\n}\r\nclear_redunt:\r\nif ((mci->bt_state == MCI_BT_AWAKE) &&\r\n(REG_READ_FIELD(ah, AR_MCI_INTERRUPT_RX_MSG_RAW,\r\nAR_MCI_INTERRUPT_RX_MSG_SYS_WAKING)) &&\r\n(REG_READ_FIELD(ah, AR_MCI_INTERRUPT_RX_MSG_RAW,\r\nAR_MCI_INTERRUPT_RX_MSG_SYS_SLEEPING) == 0)) {\r\nREG_WRITE(ah, AR_MCI_INTERRUPT_RX_MSG_RAW,\r\nAR_MCI_INTERRUPT_RX_MSG_SYS_WAKING);\r\nREG_WRITE(ah, AR_MCI_INTERRUPT_RAW,\r\nAR_MCI_INTERRUPT_REMOTE_SLEEP_UPDATE);\r\n}\r\nREG_WRITE(ah, AR_MCI_INTERRUPT_EN, saved_mci_int_en);\r\n}\r\nvoid ar9003_mci_set_full_sleep(struct ath_hw *ah)\r\n{\r\nstruct ath9k_hw_mci *mci = &ah->btcoex_hw.mci;\r\nif (ar9003_mci_state(ah, MCI_STATE_ENABLE) &&\r\n(mci->bt_state != MCI_BT_SLEEP) &&\r\n!mci->halted_bt_gpm) {\r\nar9003_mci_send_coex_halt_bt_gpm(ah, true, true);\r\n}\r\nmci->ready = false;\r\n}\r\nstatic void ar9003_mci_disable_interrupt(struct ath_hw *ah)\r\n{\r\nREG_WRITE(ah, AR_MCI_INTERRUPT_EN, 0);\r\nREG_WRITE(ah, AR_MCI_INTERRUPT_RX_MSG_EN, 0);\r\n}\r\nstatic void ar9003_mci_enable_interrupt(struct ath_hw *ah)\r\n{\r\nREG_WRITE(ah, AR_MCI_INTERRUPT_EN, AR_MCI_INTERRUPT_DEFAULT);\r\nREG_WRITE(ah, AR_MCI_INTERRUPT_RX_MSG_EN,\r\nAR_MCI_INTERRUPT_RX_MSG_DEFAULT);\r\n}\r\nstatic bool ar9003_mci_check_int(struct ath_hw *ah, u32 ints)\r\n{\r\nu32 intr;\r\nintr = REG_READ(ah, AR_MCI_INTERRUPT_RX_MSG_RAW);\r\nreturn ((intr & ints) == ints);\r\n}\r\nvoid ar9003_mci_get_interrupt(struct ath_hw *ah, u32 *raw_intr,\r\nu32 *rx_msg_intr)\r\n{\r\nstruct ath9k_hw_mci *mci = &ah->btcoex_hw.mci;\r\n*raw_intr = mci->raw_intr;\r\n*rx_msg_intr = mci->rx_msg_intr;\r\nmci->raw_intr = 0;\r\nmci->rx_msg_intr = 0;\r\n}\r\nvoid ar9003_mci_get_isr(struct ath_hw *ah, enum ath9k_int *masked)\r\n{\r\nstruct ath_common *common = ath9k_hw_common(ah);\r\nstruct ath9k_hw_mci *mci = &ah->btcoex_hw.mci;\r\nu32 raw_intr, rx_msg_intr;\r\nrx_msg_intr = REG_READ(ah, AR_MCI_INTERRUPT_RX_MSG_RAW);\r\nraw_intr = REG_READ(ah, AR_MCI_INTERRUPT_RAW);\r\nif ((raw_intr == 0xdeadbeef) || (rx_msg_intr == 0xdeadbeef)) {\r\nath_dbg(common, MCI,\r\n"MCI gets 0xdeadbeef during int processing\n");\r\n} else {\r\nmci->rx_msg_intr |= rx_msg_intr;\r\nmci->raw_intr |= raw_intr;\r\n*masked |= ATH9K_INT_MCI;\r\nif (rx_msg_intr & AR_MCI_INTERRUPT_RX_MSG_CONT_INFO)\r\nmci->cont_status = REG_READ(ah, AR_MCI_CONT_STATUS);\r\nREG_WRITE(ah, AR_MCI_INTERRUPT_RX_MSG_RAW, rx_msg_intr);\r\nREG_WRITE(ah, AR_MCI_INTERRUPT_RAW, raw_intr);\r\n}\r\n}\r\nstatic void ar9003_mci_2g5g_changed(struct ath_hw *ah, bool is_2g)\r\n{\r\nstruct ath9k_hw_mci *mci = &ah->btcoex_hw.mci;\r\nif (!mci->update_2g5g &&\r\n(mci->is_2g != is_2g))\r\nmci->update_2g5g = true;\r\nmci->is_2g = is_2g;\r\n}\r\nstatic bool ar9003_mci_is_gpm_valid(struct ath_hw *ah, u32 msg_index)\r\n{\r\nstruct ath9k_hw_mci *mci = &ah->btcoex_hw.mci;\r\nu32 *payload;\r\nu32 recv_type, offset;\r\nif (msg_index == MCI_GPM_INVALID)\r\nreturn false;\r\noffset = msg_index << 4;\r\npayload = (u32 *)(mci->gpm_buf + offset);\r\nrecv_type = MCI_GPM_TYPE(payload);\r\nif (recv_type == MCI_GPM_RSVD_PATTERN)\r\nreturn false;\r\nreturn true;\r\n}\r\nstatic void ar9003_mci_observation_set_up(struct ath_hw *ah)\r\n{\r\nstruct ath9k_hw_mci *mci = &ah->btcoex_hw.mci;\r\nif (mci->config & ATH_MCI_CONFIG_MCI_OBS_MCI) {\r\nath9k_hw_cfg_output(ah, 3, AR_GPIO_OUTPUT_MUX_AS_MCI_WLAN_DATA);\r\nath9k_hw_cfg_output(ah, 2, AR_GPIO_OUTPUT_MUX_AS_MCI_WLAN_CLK);\r\nath9k_hw_cfg_output(ah, 1, AR_GPIO_OUTPUT_MUX_AS_MCI_BT_DATA);\r\nath9k_hw_cfg_output(ah, 0, AR_GPIO_OUTPUT_MUX_AS_MCI_BT_CLK);\r\n} else if (mci->config & ATH_MCI_CONFIG_MCI_OBS_TXRX) {\r\nath9k_hw_cfg_output(ah, 3, AR_GPIO_OUTPUT_MUX_AS_WL_IN_TX);\r\nath9k_hw_cfg_output(ah, 2, AR_GPIO_OUTPUT_MUX_AS_WL_IN_RX);\r\nath9k_hw_cfg_output(ah, 1, AR_GPIO_OUTPUT_MUX_AS_BT_IN_TX);\r\nath9k_hw_cfg_output(ah, 0, AR_GPIO_OUTPUT_MUX_AS_BT_IN_RX);\r\nath9k_hw_cfg_output(ah, 5, AR_GPIO_OUTPUT_MUX_AS_OUTPUT);\r\n} else if (mci->config & ATH_MCI_CONFIG_MCI_OBS_BT) {\r\nath9k_hw_cfg_output(ah, 3, AR_GPIO_OUTPUT_MUX_AS_BT_IN_TX);\r\nath9k_hw_cfg_output(ah, 2, AR_GPIO_OUTPUT_MUX_AS_BT_IN_RX);\r\nath9k_hw_cfg_output(ah, 1, AR_GPIO_OUTPUT_MUX_AS_MCI_BT_DATA);\r\nath9k_hw_cfg_output(ah, 0, AR_GPIO_OUTPUT_MUX_AS_MCI_BT_CLK);\r\n} else\r\nreturn;\r\nREG_SET_BIT(ah, AR_GPIO_INPUT_EN_VAL, AR_GPIO_JTAG_DISABLE);\r\nREG_RMW_FIELD(ah, AR_PHY_GLB_CONTROL, AR_GLB_DS_JTAG_DISABLE, 1);\r\nREG_RMW_FIELD(ah, AR_PHY_GLB_CONTROL, AR_GLB_WLAN_UART_INTF_EN, 0);\r\nREG_SET_BIT(ah, AR_GLB_GPIO_CONTROL, ATH_MCI_CONFIG_MCI_OBS_GPIO);\r\nREG_RMW_FIELD(ah, AR_BTCOEX_CTRL2, AR_BTCOEX_CTRL2_GPIO_OBS_SEL, 0);\r\nREG_RMW_FIELD(ah, AR_BTCOEX_CTRL2, AR_BTCOEX_CTRL2_MAC_BB_OBS_SEL, 1);\r\nREG_WRITE(ah, AR_OBS, 0x4b);\r\nREG_RMW_FIELD(ah, AR_DIAG_SW, AR_DIAG_OBS_PT_SEL1, 0x03);\r\nREG_RMW_FIELD(ah, AR_DIAG_SW, AR_DIAG_OBS_PT_SEL2, 0x01);\r\nREG_RMW_FIELD(ah, AR_MACMISC, AR_MACMISC_MISC_OBS_BUS_LSB, 0x02);\r\nREG_RMW_FIELD(ah, AR_MACMISC, AR_MACMISC_MISC_OBS_BUS_MSB, 0x03);\r\nREG_RMW_FIELD(ah, AR_PHY_TEST_CTL_STATUS,\r\nAR_PHY_TEST_CTL_DEBUGPORT_SEL, 0x07);\r\n}\r\nstatic bool ar9003_mci_send_coex_bt_flags(struct ath_hw *ah, bool wait_done,\r\nu8 opcode, u32 bt_flags)\r\n{\r\nu32 pld[4] = {0, 0, 0, 0};\r\nMCI_GPM_SET_TYPE_OPCODE(pld, MCI_GPM_COEX_AGENT,\r\nMCI_GPM_COEX_BT_UPDATE_FLAGS);\r\n*(((u8 *)pld) + MCI_GPM_COEX_B_BT_FLAGS_OP) = opcode;\r\n*(((u8 *)pld) + MCI_GPM_COEX_W_BT_FLAGS + 0) = bt_flags & 0xFF;\r\n*(((u8 *)pld) + MCI_GPM_COEX_W_BT_FLAGS + 1) = (bt_flags >> 8) & 0xFF;\r\n*(((u8 *)pld) + MCI_GPM_COEX_W_BT_FLAGS + 2) = (bt_flags >> 16) & 0xFF;\r\n*(((u8 *)pld) + MCI_GPM_COEX_W_BT_FLAGS + 3) = (bt_flags >> 24) & 0xFF;\r\nreturn ar9003_mci_send_message(ah, MCI_GPM, 0, pld, 16,\r\nwait_done, true);\r\n}\r\nstatic void ar9003_mci_sync_bt_state(struct ath_hw *ah)\r\n{\r\nstruct ath9k_hw_mci *mci = &ah->btcoex_hw.mci;\r\nu32 cur_bt_state;\r\ncur_bt_state = ar9003_mci_state(ah, MCI_STATE_REMOTE_SLEEP);\r\nif (mci->bt_state != cur_bt_state)\r\nmci->bt_state = cur_bt_state;\r\nif (mci->bt_state != MCI_BT_SLEEP) {\r\nar9003_mci_send_coex_version_query(ah, true);\r\nar9003_mci_send_coex_wlan_channels(ah, true);\r\nif (mci->unhalt_bt_gpm == true)\r\nar9003_mci_send_coex_halt_bt_gpm(ah, false, true);\r\n}\r\n}\r\nvoid ar9003_mci_check_bt(struct ath_hw *ah)\r\n{\r\nstruct ath9k_hw_mci *mci_hw = &ah->btcoex_hw.mci;\r\nif (!mci_hw->ready)\r\nreturn;\r\nar9003_mci_sync_bt_state(ah);\r\nar9003_mci_2g5g_switch(ah, true);\r\nif ((mci_hw->bt_state == MCI_BT_AWAKE) &&\r\n(mci_hw->query_bt == true)) {\r\nmci_hw->need_flush_btinfo = true;\r\n}\r\n}\r\nstatic void ar9003_mci_process_gpm_extra(struct ath_hw *ah, u8 gpm_type,\r\nu8 gpm_opcode, u32 *p_gpm)\r\n{\r\nstruct ath_common *common = ath9k_hw_common(ah);\r\nstruct ath9k_hw_mci *mci = &ah->btcoex_hw.mci;\r\nu8 *p_data = (u8 *) p_gpm;\r\nif (gpm_type != MCI_GPM_COEX_AGENT)\r\nreturn;\r\nswitch (gpm_opcode) {\r\ncase MCI_GPM_COEX_VERSION_QUERY:\r\nath_dbg(common, MCI, "MCI Recv GPM COEX Version Query\n");\r\nar9003_mci_send_coex_version_response(ah, true);\r\nbreak;\r\ncase MCI_GPM_COEX_VERSION_RESPONSE:\r\nath_dbg(common, MCI, "MCI Recv GPM COEX Version Response\n");\r\nmci->bt_ver_major =\r\n*(p_data + MCI_GPM_COEX_B_MAJOR_VERSION);\r\nmci->bt_ver_minor =\r\n*(p_data + MCI_GPM_COEX_B_MINOR_VERSION);\r\nmci->bt_version_known = true;\r\nath_dbg(common, MCI, "MCI BT Coex version: %d.%d\n",\r\nmci->bt_ver_major, mci->bt_ver_minor);\r\nbreak;\r\ncase MCI_GPM_COEX_STATUS_QUERY:\r\nath_dbg(common, MCI,\r\n"MCI Recv GPM COEX Status Query = 0x%02X\n",\r\n*(p_data + MCI_GPM_COEX_B_WLAN_BITMAP));\r\nmci->wlan_channels_update = true;\r\nar9003_mci_send_coex_wlan_channels(ah, true);\r\nbreak;\r\ncase MCI_GPM_COEX_BT_PROFILE_INFO:\r\nmci->query_bt = true;\r\nath_dbg(common, MCI, "MCI Recv GPM COEX BT_Profile_Info\n");\r\nbreak;\r\ncase MCI_GPM_COEX_BT_STATUS_UPDATE:\r\nmci->query_bt = true;\r\nath_dbg(common, MCI,\r\n"MCI Recv GPM COEX BT_Status_Update SEQ=%d (drop&query)\n",\r\n*(p_gpm + 3));\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nstatic u32 ar9003_mci_wait_for_gpm(struct ath_hw *ah, u8 gpm_type,\r\nu8 gpm_opcode, int time_out)\r\n{\r\nstruct ath_common *common = ath9k_hw_common(ah);\r\nstruct ath9k_hw_mci *mci = &ah->btcoex_hw.mci;\r\nu32 *p_gpm = NULL, mismatch = 0, more_data;\r\nu32 offset;\r\nu8 recv_type = 0, recv_opcode = 0;\r\nbool b_is_bt_cal_done = (gpm_type == MCI_GPM_BT_CAL_DONE);\r\nmore_data = time_out ? MCI_GPM_NOMORE : MCI_GPM_MORE;\r\nwhile (time_out > 0) {\r\nif (p_gpm) {\r\nMCI_GPM_RECYCLE(p_gpm);\r\np_gpm = NULL;\r\n}\r\nif (more_data != MCI_GPM_MORE)\r\ntime_out = ar9003_mci_wait_for_interrupt(ah,\r\nAR_MCI_INTERRUPT_RX_MSG_RAW,\r\nAR_MCI_INTERRUPT_RX_MSG_GPM,\r\ntime_out);\r\nif (!time_out)\r\nbreak;\r\noffset = ar9003_mci_get_next_gpm_offset(ah, &more_data);\r\nif (offset == MCI_GPM_INVALID)\r\ncontinue;\r\np_gpm = (u32 *) (mci->gpm_buf + offset);\r\nrecv_type = MCI_GPM_TYPE(p_gpm);\r\nrecv_opcode = MCI_GPM_OPCODE(p_gpm);\r\nif (MCI_GPM_IS_CAL_TYPE(recv_type)) {\r\nif (recv_type == gpm_type) {\r\nif ((gpm_type == MCI_GPM_BT_CAL_DONE) &&\r\n!b_is_bt_cal_done) {\r\ngpm_type = MCI_GPM_BT_CAL_GRANT;\r\ncontinue;\r\n}\r\nbreak;\r\n}\r\n} else if ((recv_type == gpm_type) &&\r\n(recv_opcode == gpm_opcode))\r\nbreak;\r\nif ((gpm_type == MCI_GPM_BT_CAL_GRANT) &&\r\n(recv_type == MCI_GPM_BT_CAL_REQ)) {\r\nu32 payload[4] = {0, 0, 0, 0};\r\ngpm_type = MCI_GPM_BT_CAL_DONE;\r\nMCI_GPM_SET_CAL_TYPE(payload,\r\nMCI_GPM_WLAN_CAL_GRANT);\r\nar9003_mci_send_message(ah, MCI_GPM, 0, payload, 16,\r\nfalse, false);\r\ncontinue;\r\n} else {\r\nath_dbg(common, MCI, "MCI GPM subtype not match 0x%x\n",\r\n*(p_gpm + 1));\r\nmismatch++;\r\nar9003_mci_process_gpm_extra(ah, recv_type,\r\nrecv_opcode, p_gpm);\r\n}\r\n}\r\nif (p_gpm) {\r\nMCI_GPM_RECYCLE(p_gpm);\r\np_gpm = NULL;\r\n}\r\nif (time_out <= 0)\r\ntime_out = 0;\r\nwhile (more_data == MCI_GPM_MORE) {\r\noffset = ar9003_mci_get_next_gpm_offset(ah, &more_data);\r\nif (offset == MCI_GPM_INVALID)\r\nbreak;\r\np_gpm = (u32 *) (mci->gpm_buf + offset);\r\nrecv_type = MCI_GPM_TYPE(p_gpm);\r\nrecv_opcode = MCI_GPM_OPCODE(p_gpm);\r\nif (!MCI_GPM_IS_CAL_TYPE(recv_type))\r\nar9003_mci_process_gpm_extra(ah, recv_type,\r\nrecv_opcode, p_gpm);\r\nMCI_GPM_RECYCLE(p_gpm);\r\n}\r\nreturn time_out;\r\n}\r\nbool ar9003_mci_start_reset(struct ath_hw *ah, struct ath9k_channel *chan)\r\n{\r\nstruct ath_common *common = ath9k_hw_common(ah);\r\nstruct ath9k_hw_mci *mci_hw = &ah->btcoex_hw.mci;\r\nu32 payload[4] = {0, 0, 0, 0};\r\nar9003_mci_2g5g_changed(ah, IS_CHAN_2GHZ(chan));\r\nif (mci_hw->bt_state != MCI_BT_CAL_START)\r\nreturn false;\r\nmci_hw->bt_state = MCI_BT_CAL;\r\nar9003_mci_disable_interrupt(ah);\r\nMCI_GPM_SET_CAL_TYPE(payload, MCI_GPM_WLAN_CAL_GRANT);\r\nar9003_mci_send_message(ah, MCI_GPM, 0, payload,\r\n16, true, false);\r\nif (ar9003_mci_wait_for_gpm(ah, MCI_GPM_BT_CAL_DONE,\r\n0, 25000))\r\nath_dbg(common, MCI, "MCI BT_CAL_DONE received\n");\r\nelse\r\nath_dbg(common, MCI,\r\n"MCI BT_CAL_DONE not received\n");\r\nmci_hw->bt_state = MCI_BT_AWAKE;\r\nar9003_mci_enable_interrupt(ah);\r\nreturn true;\r\n}\r\nint ar9003_mci_end_reset(struct ath_hw *ah, struct ath9k_channel *chan,\r\nstruct ath9k_hw_cal_data *caldata)\r\n{\r\nstruct ath9k_hw_mci *mci_hw = &ah->btcoex_hw.mci;\r\nif (!mci_hw->ready)\r\nreturn 0;\r\nif (!IS_CHAN_2GHZ(chan) || (mci_hw->bt_state != MCI_BT_SLEEP))\r\ngoto exit;\r\nif (!ar9003_mci_check_int(ah, AR_MCI_INTERRUPT_RX_MSG_REMOTE_RESET) &&\r\n!ar9003_mci_check_int(ah, AR_MCI_INTERRUPT_RX_MSG_REQ_WAKE))\r\ngoto exit;\r\nREG_WRITE(ah, AR_MCI_INTERRUPT_RX_MSG_RAW,\r\n(AR_MCI_INTERRUPT_RX_MSG_REMOTE_RESET |\r\nAR_MCI_INTERRUPT_RX_MSG_REQ_WAKE));\r\nar9003_mci_remote_reset(ah, true);\r\nar9003_mci_send_sys_waking(ah, true);\r\nudelay(1);\r\nif (IS_CHAN_2GHZ(chan))\r\nar9003_mci_send_lna_transfer(ah, true);\r\nmci_hw->bt_state = MCI_BT_AWAKE;\r\nREG_CLR_BIT(ah, AR_PHY_TIMING4,\r\n1 << AR_PHY_TIMING_CONTROL4_DO_GAIN_DC_IQ_CAL_SHIFT);\r\nif (caldata) {\r\nclear_bit(TXIQCAL_DONE, &caldata->cal_flags);\r\nclear_bit(TXCLCAL_DONE, &caldata->cal_flags);\r\nclear_bit(RTT_DONE, &caldata->cal_flags);\r\n}\r\nif (!ath9k_hw_init_cal(ah, chan))\r\nreturn -EIO;\r\nREG_SET_BIT(ah, AR_PHY_TIMING4,\r\n1 << AR_PHY_TIMING_CONTROL4_DO_GAIN_DC_IQ_CAL_SHIFT);\r\nexit:\r\nar9003_mci_enable_interrupt(ah);\r\nreturn 0;\r\n}\r\nstatic void ar9003_mci_mute_bt(struct ath_hw *ah)\r\n{\r\nstruct ath9k_hw_mci *mci = &ah->btcoex_hw.mci;\r\nREG_WRITE(ah, AR_MCI_MSG_ATTRIBUTES_TABLE, 0xffff0000);\r\nREG_WRITE(ah, AR_BTCOEX_WL_WEIGHTS0, 0xffffffff);\r\nREG_WRITE(ah, AR_BTCOEX_WL_WEIGHTS1, 0xffffffff);\r\nREG_WRITE(ah, AR_BTCOEX_WL_WEIGHTS2, 0xffffffff);\r\nREG_WRITE(ah, AR_BTCOEX_WL_WEIGHTS3, 0xffffffff);\r\nREG_SET_BIT(ah, AR_MCI_TX_CTRL, AR_MCI_TX_CTRL_DISABLE_LNA_UPDATE);\r\nudelay(10);\r\nif (MCI_ANT_ARCH_PA_LNA_SHARED(mci)) {\r\nar9003_mci_send_lna_take(ah, true);\r\nudelay(5);\r\n}\r\nar9003_mci_send_sys_sleeping(ah, true);\r\n}\r\nstatic void ar9003_mci_osla_setup(struct ath_hw *ah, bool enable)\r\n{\r\nstruct ath9k_hw_mci *mci = &ah->btcoex_hw.mci;\r\nu32 thresh;\r\nif (!enable) {\r\nREG_CLR_BIT(ah, AR_BTCOEX_CTRL,\r\nAR_BTCOEX_CTRL_ONE_STEP_LOOK_AHEAD_EN);\r\nreturn;\r\n}\r\nREG_RMW_FIELD(ah, AR_MCI_SCHD_TABLE_2, AR_MCI_SCHD_TABLE_2_HW_BASED, 1);\r\nREG_RMW_FIELD(ah, AR_MCI_SCHD_TABLE_2,\r\nAR_MCI_SCHD_TABLE_2_MEM_BASED, 1);\r\nif (AR_SREV_9565(ah))\r\nREG_RMW_FIELD(ah, AR_MCI_MISC, AR_MCI_MISC_HW_FIX_EN, 1);\r\nif (!(mci->config & ATH_MCI_CONFIG_DISABLE_AGGR_THRESH)) {\r\nthresh = MS(mci->config, ATH_MCI_CONFIG_AGGR_THRESH);\r\nREG_RMW_FIELD(ah, AR_BTCOEX_CTRL,\r\nAR_BTCOEX_CTRL_AGGR_THRESH, thresh);\r\nREG_RMW_FIELD(ah, AR_BTCOEX_CTRL,\r\nAR_BTCOEX_CTRL_TIME_TO_NEXT_BT_THRESH_EN, 1);\r\n} else\r\nREG_RMW_FIELD(ah, AR_BTCOEX_CTRL,\r\nAR_BTCOEX_CTRL_TIME_TO_NEXT_BT_THRESH_EN, 0);\r\nREG_RMW_FIELD(ah, AR_BTCOEX_CTRL,\r\nAR_BTCOEX_CTRL_ONE_STEP_LOOK_AHEAD_EN, 1);\r\n}\r\nstatic void ar9003_mci_stat_setup(struct ath_hw *ah)\r\n{\r\nstruct ath9k_hw_mci *mci = &ah->btcoex_hw.mci;\r\nif (!AR_SREV_9565(ah))\r\nreturn;\r\nif (mci->config & ATH_MCI_CONFIG_MCI_STAT_DBG) {\r\nREG_RMW_FIELD(ah, AR_MCI_DBG_CNT_CTRL,\r\nAR_MCI_DBG_CNT_CTRL_ENABLE, 1);\r\nREG_RMW_FIELD(ah, AR_MCI_DBG_CNT_CTRL,\r\nAR_MCI_DBG_CNT_CTRL_BT_LINKID,\r\nMCI_STAT_ALL_BT_LINKID);\r\n} else {\r\nREG_RMW_FIELD(ah, AR_MCI_DBG_CNT_CTRL,\r\nAR_MCI_DBG_CNT_CTRL_ENABLE, 0);\r\n}\r\n}\r\nstatic void ar9003_mci_set_btcoex_ctrl_9565_1ANT(struct ath_hw *ah)\r\n{\r\nu32 regval;\r\nregval = SM(1, AR_BTCOEX_CTRL_AR9462_MODE) |\r\nSM(1, AR_BTCOEX_CTRL_WBTIMER_EN) |\r\nSM(1, AR_BTCOEX_CTRL_PA_SHARED) |\r\nSM(1, AR_BTCOEX_CTRL_LNA_SHARED) |\r\nSM(1, AR_BTCOEX_CTRL_NUM_ANTENNAS) |\r\nSM(1, AR_BTCOEX_CTRL_RX_CHAIN_MASK) |\r\nSM(0, AR_BTCOEX_CTRL_1_CHAIN_ACK) |\r\nSM(0, AR_BTCOEX_CTRL_1_CHAIN_BCN) |\r\nSM(0, AR_BTCOEX_CTRL_ONE_STEP_LOOK_AHEAD_EN);\r\nREG_RMW_FIELD(ah, AR_BTCOEX_CTRL2,\r\nAR_BTCOEX_CTRL2_TX_CHAIN_MASK, 0x1);\r\nREG_WRITE(ah, AR_BTCOEX_CTRL, regval);\r\n}\r\nstatic void ar9003_mci_set_btcoex_ctrl_9565_2ANT(struct ath_hw *ah)\r\n{\r\nu32 regval;\r\nregval = SM(1, AR_BTCOEX_CTRL_AR9462_MODE) |\r\nSM(1, AR_BTCOEX_CTRL_WBTIMER_EN) |\r\nSM(0, AR_BTCOEX_CTRL_PA_SHARED) |\r\nSM(0, AR_BTCOEX_CTRL_LNA_SHARED) |\r\nSM(2, AR_BTCOEX_CTRL_NUM_ANTENNAS) |\r\nSM(1, AR_BTCOEX_CTRL_RX_CHAIN_MASK) |\r\nSM(0, AR_BTCOEX_CTRL_1_CHAIN_ACK) |\r\nSM(0, AR_BTCOEX_CTRL_1_CHAIN_BCN) |\r\nSM(0, AR_BTCOEX_CTRL_ONE_STEP_LOOK_AHEAD_EN);\r\nREG_RMW_FIELD(ah, AR_BTCOEX_CTRL2,\r\nAR_BTCOEX_CTRL2_TX_CHAIN_MASK, 0x0);\r\nREG_WRITE(ah, AR_BTCOEX_CTRL, regval);\r\n}\r\nstatic void ar9003_mci_set_btcoex_ctrl_9462(struct ath_hw *ah)\r\n{\r\nu32 regval;\r\nregval = SM(1, AR_BTCOEX_CTRL_AR9462_MODE) |\r\nSM(1, AR_BTCOEX_CTRL_WBTIMER_EN) |\r\nSM(1, AR_BTCOEX_CTRL_PA_SHARED) |\r\nSM(1, AR_BTCOEX_CTRL_LNA_SHARED) |\r\nSM(2, AR_BTCOEX_CTRL_NUM_ANTENNAS) |\r\nSM(3, AR_BTCOEX_CTRL_RX_CHAIN_MASK) |\r\nSM(0, AR_BTCOEX_CTRL_1_CHAIN_ACK) |\r\nSM(0, AR_BTCOEX_CTRL_1_CHAIN_BCN) |\r\nSM(0, AR_BTCOEX_CTRL_ONE_STEP_LOOK_AHEAD_EN);\r\nREG_WRITE(ah, AR_BTCOEX_CTRL, regval);\r\n}\r\nint ar9003_mci_reset(struct ath_hw *ah, bool en_int, bool is_2g,\r\nbool is_full_sleep)\r\n{\r\nstruct ath_common *common = ath9k_hw_common(ah);\r\nstruct ath9k_hw_mci *mci = &ah->btcoex_hw.mci;\r\nu32 regval, i;\r\nath_dbg(common, MCI, "MCI Reset (full_sleep = %d, is_2g = %d)\n",\r\nis_full_sleep, is_2g);\r\nif (REG_READ(ah, AR_BTCOEX_CTRL) == 0xdeadbeef) {\r\nath_err(common, "BTCOEX control register is dead\n");\r\nreturn -EINVAL;\r\n}\r\nREG_WRITE(ah, AR_MCI_GPM_0, mci->gpm_addr);\r\nREG_WRITE(ah, AR_MCI_GPM_1, mci->gpm_len);\r\nREG_WRITE(ah, AR_MCI_SCHD_TABLE_0, mci->sched_addr);\r\nif (AR_SREV_9565(ah)) {\r\nu8 ant = MS(mci->config, ATH_MCI_CONFIG_ANT_ARCH);\r\nif (ant == ATH_MCI_ANT_ARCH_1_ANT_PA_LNA_SHARED)\r\nar9003_mci_set_btcoex_ctrl_9565_1ANT(ah);\r\nelse\r\nar9003_mci_set_btcoex_ctrl_9565_2ANT(ah);\r\n} else {\r\nar9003_mci_set_btcoex_ctrl_9462(ah);\r\n}\r\nif (is_2g && !(mci->config & ATH_MCI_CONFIG_DISABLE_OSLA))\r\nar9003_mci_osla_setup(ah, true);\r\nelse\r\nar9003_mci_osla_setup(ah, false);\r\nREG_SET_BIT(ah, AR_PHY_GLB_CONTROL,\r\nAR_BTCOEX_CTRL_SPDT_ENABLE);\r\nREG_RMW_FIELD(ah, AR_BTCOEX_CTRL3,\r\nAR_BTCOEX_CTRL3_CONT_INFO_TIMEOUT, 20);\r\nREG_RMW_FIELD(ah, AR_BTCOEX_CTRL2, AR_BTCOEX_CTRL2_RX_DEWEIGHT, 0);\r\nREG_RMW_FIELD(ah, AR_PCU_MISC, AR_PCU_BT_ANT_PREVENT_RX, 0);\r\nREG_RMW_FIELD(ah, AR_BTCOEX_WL_LNA, AR_BTCOEX_WL_LNA_TIMEOUT, 0x3D090);\r\nif (mci->config & ATH_MCI_CONFIG_CONCUR_TX) {\r\nREG_RMW_FIELD(ah, AR_BTCOEX_CTRL2,\r\nAR_BTCOEX_CTRL2_DESC_BASED_TXPWR_ENABLE, 0);\r\nREG_RMW_FIELD(ah, AR_BTCOEX_CTRL2,\r\nAR_BTCOEX_CTRL2_TXPWR_THRESH, 0x7f);\r\nREG_RMW_FIELD(ah, AR_BTCOEX_CTRL,\r\nAR_BTCOEX_CTRL_REDUCE_TXPWR, 0);\r\nfor (i = 0; i < 8; i++)\r\nREG_WRITE(ah, AR_BTCOEX_MAX_TXPWR(i), 0x7f7f7f7f);\r\n}\r\nregval = MS(mci->config, ATH_MCI_CONFIG_CLK_DIV);\r\nREG_RMW_FIELD(ah, AR_MCI_TX_CTRL, AR_MCI_TX_CTRL_CLK_DIV, regval);\r\nREG_SET_BIT(ah, AR_BTCOEX_CTRL, AR_BTCOEX_CTRL_MCI_MODE_EN);\r\nregval = REG_READ(ah, AR_MCI_COMMAND2);\r\nregval |= SM(1, AR_MCI_COMMAND2_RESET_TX);\r\nREG_WRITE(ah, AR_MCI_COMMAND2, regval);\r\nudelay(1);\r\nregval &= ~SM(1, AR_MCI_COMMAND2_RESET_TX);\r\nREG_WRITE(ah, AR_MCI_COMMAND2, regval);\r\nif (is_full_sleep) {\r\nar9003_mci_mute_bt(ah);\r\nudelay(100);\r\n}\r\nar9003_mci_check_gpm_offset(ah);\r\nregval |= SM(1, AR_MCI_COMMAND2_RESET_RX);\r\nREG_WRITE(ah, AR_MCI_COMMAND2, regval);\r\nudelay(1);\r\nregval &= ~SM(1, AR_MCI_COMMAND2_RESET_RX);\r\nREG_WRITE(ah, AR_MCI_COMMAND2, regval);\r\nar9003_mci_state(ah, MCI_STATE_INIT_GPM_OFFSET);\r\nREG_WRITE(ah, AR_MCI_MSG_ATTRIBUTES_TABLE,\r\n(SM(0xe801, AR_MCI_MSG_ATTRIBUTES_TABLE_INVALID_HDR) |\r\nSM(0x0000, AR_MCI_MSG_ATTRIBUTES_TABLE_CHECKSUM)));\r\nif (MCI_ANT_ARCH_PA_LNA_SHARED(mci))\r\nREG_CLR_BIT(ah, AR_MCI_TX_CTRL,\r\nAR_MCI_TX_CTRL_DISABLE_LNA_UPDATE);\r\nelse\r\nREG_SET_BIT(ah, AR_MCI_TX_CTRL,\r\nAR_MCI_TX_CTRL_DISABLE_LNA_UPDATE);\r\nar9003_mci_observation_set_up(ah);\r\nmci->ready = true;\r\nar9003_mci_prep_interface(ah);\r\nar9003_mci_stat_setup(ah);\r\nif (en_int)\r\nar9003_mci_enable_interrupt(ah);\r\nif (ath9k_hw_is_aic_enabled(ah))\r\nar9003_aic_start_normal(ah);\r\nreturn 0;\r\n}\r\nvoid ar9003_mci_stop_bt(struct ath_hw *ah, bool save_fullsleep)\r\n{\r\nstruct ath9k_hw_mci *mci_hw = &ah->btcoex_hw.mci;\r\nar9003_mci_disable_interrupt(ah);\r\nif (mci_hw->ready && !save_fullsleep) {\r\nar9003_mci_mute_bt(ah);\r\nudelay(20);\r\nREG_WRITE(ah, AR_BTCOEX_CTRL, 0);\r\n}\r\nmci_hw->bt_state = MCI_BT_SLEEP;\r\nmci_hw->ready = false;\r\n}\r\nstatic void ar9003_mci_send_2g5g_status(struct ath_hw *ah, bool wait_done)\r\n{\r\nstruct ath9k_hw_mci *mci = &ah->btcoex_hw.mci;\r\nu32 new_flags, to_set, to_clear;\r\nif (!mci->update_2g5g || (mci->bt_state == MCI_BT_SLEEP))\r\nreturn;\r\nif (mci->is_2g) {\r\nnew_flags = MCI_2G_FLAGS;\r\nto_clear = MCI_2G_FLAGS_CLEAR_MASK;\r\nto_set = MCI_2G_FLAGS_SET_MASK;\r\n} else {\r\nnew_flags = MCI_5G_FLAGS;\r\nto_clear = MCI_5G_FLAGS_CLEAR_MASK;\r\nto_set = MCI_5G_FLAGS_SET_MASK;\r\n}\r\nif (to_clear)\r\nar9003_mci_send_coex_bt_flags(ah, wait_done,\r\nMCI_GPM_COEX_BT_FLAGS_CLEAR,\r\nto_clear);\r\nif (to_set)\r\nar9003_mci_send_coex_bt_flags(ah, wait_done,\r\nMCI_GPM_COEX_BT_FLAGS_SET,\r\nto_set);\r\n}\r\nstatic void ar9003_mci_queue_unsent_gpm(struct ath_hw *ah, u8 header,\r\nu32 *payload, bool queue)\r\n{\r\nstruct ath9k_hw_mci *mci = &ah->btcoex_hw.mci;\r\nu8 type, opcode;\r\nif (header != MCI_GPM)\r\nreturn;\r\ntype = MCI_GPM_TYPE(payload);\r\nopcode = MCI_GPM_OPCODE(payload);\r\nif (type != MCI_GPM_COEX_AGENT)\r\nreturn;\r\nswitch (opcode) {\r\ncase MCI_GPM_COEX_BT_UPDATE_FLAGS:\r\nif (*(((u8 *)payload) + MCI_GPM_COEX_B_BT_FLAGS_OP) ==\r\nMCI_GPM_COEX_BT_FLAGS_READ)\r\nbreak;\r\nmci->update_2g5g = queue;\r\nbreak;\r\ncase MCI_GPM_COEX_WLAN_CHANNELS:\r\nmci->wlan_channels_update = queue;\r\nbreak;\r\ncase MCI_GPM_COEX_HALT_BT_GPM:\r\nif (*(((u8 *)payload) + MCI_GPM_COEX_B_HALT_STATE) ==\r\nMCI_GPM_COEX_BT_GPM_UNHALT) {\r\nmci->unhalt_bt_gpm = queue;\r\nif (!queue)\r\nmci->halted_bt_gpm = false;\r\n}\r\nif (*(((u8 *)payload) + MCI_GPM_COEX_B_HALT_STATE) ==\r\nMCI_GPM_COEX_BT_GPM_HALT) {\r\nmci->halted_bt_gpm = !queue;\r\n}\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nvoid ar9003_mci_2g5g_switch(struct ath_hw *ah, bool force)\r\n{\r\nstruct ath9k_hw_mci *mci = &ah->btcoex_hw.mci;\r\nif (!mci->update_2g5g && !force)\r\nreturn;\r\nif (mci->is_2g) {\r\nar9003_mci_send_2g5g_status(ah, true);\r\nar9003_mci_send_lna_transfer(ah, true);\r\nudelay(5);\r\nREG_CLR_BIT(ah, AR_MCI_TX_CTRL,\r\nAR_MCI_TX_CTRL_DISABLE_LNA_UPDATE);\r\nREG_CLR_BIT(ah, AR_PHY_GLB_CONTROL,\r\nAR_BTCOEX_CTRL_BT_OWN_SPDT_CTRL);\r\nif (!(mci->config & ATH_MCI_CONFIG_DISABLE_OSLA))\r\nar9003_mci_osla_setup(ah, true);\r\nif (AR_SREV_9462(ah))\r\nREG_WRITE(ah, AR_SELFGEN_MASK, 0x02);\r\n} else {\r\nar9003_mci_send_lna_take(ah, true);\r\nudelay(5);\r\nREG_SET_BIT(ah, AR_MCI_TX_CTRL,\r\nAR_MCI_TX_CTRL_DISABLE_LNA_UPDATE);\r\nREG_SET_BIT(ah, AR_PHY_GLB_CONTROL,\r\nAR_BTCOEX_CTRL_BT_OWN_SPDT_CTRL);\r\nar9003_mci_osla_setup(ah, false);\r\nar9003_mci_send_2g5g_status(ah, true);\r\n}\r\n}\r\nbool ar9003_mci_send_message(struct ath_hw *ah, u8 header, u32 flag,\r\nu32 *payload, u8 len, bool wait_done,\r\nbool check_bt)\r\n{\r\nstruct ath_common *common = ath9k_hw_common(ah);\r\nstruct ath9k_hw_mci *mci = &ah->btcoex_hw.mci;\r\nbool msg_sent = false;\r\nu32 regval;\r\nu32 saved_mci_int_en;\r\nint i;\r\nsaved_mci_int_en = REG_READ(ah, AR_MCI_INTERRUPT_EN);\r\nregval = REG_READ(ah, AR_BTCOEX_CTRL);\r\nif ((regval == 0xdeadbeef) || !(regval & AR_BTCOEX_CTRL_MCI_MODE_EN)) {\r\nath_dbg(common, MCI,\r\n"MCI Not sending 0x%x. MCI is not enabled. full_sleep = %d\n",\r\nheader, (ah->power_mode == ATH9K_PM_FULL_SLEEP) ? 1 : 0);\r\nar9003_mci_queue_unsent_gpm(ah, header, payload, true);\r\nreturn false;\r\n} else if (check_bt && (mci->bt_state == MCI_BT_SLEEP)) {\r\nath_dbg(common, MCI,\r\n"MCI Don't send message 0x%x. BT is in sleep state\n",\r\nheader);\r\nar9003_mci_queue_unsent_gpm(ah, header, payload, true);\r\nreturn false;\r\n}\r\nif (wait_done)\r\nREG_WRITE(ah, AR_MCI_INTERRUPT_EN, 0);\r\nREG_WRITE(ah, AR_MCI_INTERRUPT_RAW,\r\n(AR_MCI_INTERRUPT_SW_MSG_DONE |\r\nAR_MCI_INTERRUPT_MSG_FAIL_MASK));\r\nif (payload) {\r\nfor (i = 0; (i * 4) < len; i++)\r\nREG_WRITE(ah, (AR_MCI_TX_PAYLOAD0 + i * 4),\r\n*(payload + i));\r\n}\r\nREG_WRITE(ah, AR_MCI_COMMAND0,\r\n(SM((flag & MCI_FLAG_DISABLE_TIMESTAMP),\r\nAR_MCI_COMMAND0_DISABLE_TIMESTAMP) |\r\nSM(len, AR_MCI_COMMAND0_LEN) |\r\nSM(header, AR_MCI_COMMAND0_HEADER)));\r\nif (wait_done &&\r\n!(ar9003_mci_wait_for_interrupt(ah, AR_MCI_INTERRUPT_RAW,\r\nAR_MCI_INTERRUPT_SW_MSG_DONE, 500)))\r\nar9003_mci_queue_unsent_gpm(ah, header, payload, true);\r\nelse {\r\nar9003_mci_queue_unsent_gpm(ah, header, payload, false);\r\nmsg_sent = true;\r\n}\r\nif (wait_done)\r\nREG_WRITE(ah, AR_MCI_INTERRUPT_EN, saved_mci_int_en);\r\nreturn msg_sent;\r\n}\r\nvoid ar9003_mci_init_cal_req(struct ath_hw *ah, bool *is_reusable)\r\n{\r\nstruct ath_common *common = ath9k_hw_common(ah);\r\nstruct ath9k_hw_mci *mci_hw = &ah->btcoex_hw.mci;\r\nu32 pld[4] = {0, 0, 0, 0};\r\nif ((mci_hw->bt_state != MCI_BT_AWAKE) ||\r\n(mci_hw->config & ATH_MCI_CONFIG_DISABLE_MCI_CAL))\r\nreturn;\r\nMCI_GPM_SET_CAL_TYPE(pld, MCI_GPM_WLAN_CAL_REQ);\r\npld[MCI_GPM_WLAN_CAL_W_SEQUENCE] = mci_hw->wlan_cal_seq++;\r\nar9003_mci_send_message(ah, MCI_GPM, 0, pld, 16, true, false);\r\nif (ar9003_mci_wait_for_gpm(ah, MCI_GPM_BT_CAL_GRANT, 0, 50000)) {\r\nath_dbg(common, MCI, "MCI BT_CAL_GRANT received\n");\r\n} else {\r\n*is_reusable = false;\r\nath_dbg(common, MCI, "MCI BT_CAL_GRANT not received\n");\r\n}\r\n}\r\nvoid ar9003_mci_init_cal_done(struct ath_hw *ah)\r\n{\r\nstruct ath9k_hw_mci *mci_hw = &ah->btcoex_hw.mci;\r\nu32 pld[4] = {0, 0, 0, 0};\r\nif ((mci_hw->bt_state != MCI_BT_AWAKE) ||\r\n(mci_hw->config & ATH_MCI_CONFIG_DISABLE_MCI_CAL))\r\nreturn;\r\nMCI_GPM_SET_CAL_TYPE(pld, MCI_GPM_WLAN_CAL_DONE);\r\npld[MCI_GPM_WLAN_CAL_W_SEQUENCE] = mci_hw->wlan_cal_done++;\r\nar9003_mci_send_message(ah, MCI_GPM, 0, pld, 16, true, false);\r\n}\r\nint ar9003_mci_setup(struct ath_hw *ah, u32 gpm_addr, void *gpm_buf,\r\nu16 len, u32 sched_addr)\r\n{\r\nstruct ath9k_hw_mci *mci = &ah->btcoex_hw.mci;\r\nmci->gpm_addr = gpm_addr;\r\nmci->gpm_buf = gpm_buf;\r\nmci->gpm_len = len;\r\nmci->sched_addr = sched_addr;\r\nreturn ar9003_mci_reset(ah, true, true, true);\r\n}\r\nvoid ar9003_mci_cleanup(struct ath_hw *ah)\r\n{\r\nREG_WRITE(ah, AR_BTCOEX_CTRL, 0x00);\r\nar9003_mci_disable_interrupt(ah);\r\n}\r\nu32 ar9003_mci_state(struct ath_hw *ah, u32 state_type)\r\n{\r\nstruct ath9k_hw_mci *mci = &ah->btcoex_hw.mci;\r\nu32 value = 0, tsf;\r\nu8 query_type;\r\nswitch (state_type) {\r\ncase MCI_STATE_ENABLE:\r\nif (mci->ready) {\r\nvalue = REG_READ(ah, AR_BTCOEX_CTRL);\r\nif ((value == 0xdeadbeef) || (value == 0xffffffff))\r\nvalue = 0;\r\n}\r\nvalue &= AR_BTCOEX_CTRL_MCI_MODE_EN;\r\nbreak;\r\ncase MCI_STATE_INIT_GPM_OFFSET:\r\nvalue = MS(REG_READ(ah, AR_MCI_GPM_1), AR_MCI_GPM_WRITE_PTR);\r\nif (value < mci->gpm_len)\r\nmci->gpm_idx = value;\r\nelse\r\nmci->gpm_idx = 0;\r\nbreak;\r\ncase MCI_STATE_LAST_SCHD_MSG_OFFSET:\r\nvalue = MS(REG_READ(ah, AR_MCI_RX_STATUS),\r\nAR_MCI_RX_LAST_SCHD_MSG_INDEX);\r\nvalue <<= 4;\r\nbreak;\r\ncase MCI_STATE_REMOTE_SLEEP:\r\nvalue = MS(REG_READ(ah, AR_MCI_RX_STATUS),\r\nAR_MCI_RX_REMOTE_SLEEP) ?\r\nMCI_BT_SLEEP : MCI_BT_AWAKE;\r\nbreak;\r\ncase MCI_STATE_SET_BT_AWAKE:\r\nmci->bt_state = MCI_BT_AWAKE;\r\nar9003_mci_send_coex_version_query(ah, true);\r\nar9003_mci_send_coex_wlan_channels(ah, true);\r\nif (mci->unhalt_bt_gpm)\r\nar9003_mci_send_coex_halt_bt_gpm(ah, false, true);\r\nar9003_mci_2g5g_switch(ah, false);\r\nbreak;\r\ncase MCI_STATE_RESET_REQ_WAKE:\r\nar9003_mci_reset_req_wakeup(ah);\r\nmci->update_2g5g = true;\r\nif (mci->config & ATH_MCI_CONFIG_MCI_OBS_MASK) {\r\nif ((REG_READ(ah, AR_GLB_GPIO_CONTROL) &\r\nATH_MCI_CONFIG_MCI_OBS_GPIO) !=\r\nATH_MCI_CONFIG_MCI_OBS_GPIO) {\r\nar9003_mci_observation_set_up(ah);\r\n}\r\n}\r\nbreak;\r\ncase MCI_STATE_SEND_WLAN_COEX_VERSION:\r\nar9003_mci_send_coex_version_response(ah, true);\r\nbreak;\r\ncase MCI_STATE_SEND_VERSION_QUERY:\r\nar9003_mci_send_coex_version_query(ah, true);\r\nbreak;\r\ncase MCI_STATE_SEND_STATUS_QUERY:\r\nquery_type = MCI_GPM_COEX_QUERY_BT_TOPOLOGY;\r\nar9003_mci_send_coex_bt_status_query(ah, true, query_type);\r\nbreak;\r\ncase MCI_STATE_RECOVER_RX:\r\ntsf = ath9k_hw_gettsf32(ah);\r\nif ((tsf - mci->last_recovery) <= MCI_RECOVERY_DUR_TSF) {\r\nath_dbg(ath9k_hw_common(ah), MCI,\r\n"(MCI) ignore Rx recovery\n");\r\nbreak;\r\n}\r\nath_dbg(ath9k_hw_common(ah), MCI, "(MCI) RECOVER RX\n");\r\nmci->last_recovery = tsf;\r\nar9003_mci_prep_interface(ah);\r\nmci->query_bt = true;\r\nmci->need_flush_btinfo = true;\r\nar9003_mci_send_coex_wlan_channels(ah, true);\r\nar9003_mci_2g5g_switch(ah, false);\r\nbreak;\r\ncase MCI_STATE_NEED_FTP_STOMP:\r\nvalue = !(mci->config & ATH_MCI_CONFIG_DISABLE_FTP_STOMP);\r\nbreak;\r\ncase MCI_STATE_NEED_FLUSH_BT_INFO:\r\nvalue = (!mci->unhalt_bt_gpm && mci->need_flush_btinfo) ? 1 : 0;\r\nmci->need_flush_btinfo = false;\r\nbreak;\r\ncase MCI_STATE_AIC_CAL:\r\nif (ath9k_hw_is_aic_enabled(ah))\r\nvalue = ar9003_aic_calibration(ah);\r\nbreak;\r\ncase MCI_STATE_AIC_START:\r\nif (ath9k_hw_is_aic_enabled(ah))\r\nar9003_aic_start_normal(ah);\r\nbreak;\r\ncase MCI_STATE_AIC_CAL_RESET:\r\nif (ath9k_hw_is_aic_enabled(ah))\r\nvalue = ar9003_aic_cal_reset(ah);\r\nbreak;\r\ncase MCI_STATE_AIC_CAL_SINGLE:\r\nif (ath9k_hw_is_aic_enabled(ah))\r\nvalue = ar9003_aic_calibration_single(ah);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nreturn value;\r\n}\r\nvoid ar9003_mci_bt_gain_ctrl(struct ath_hw *ah)\r\n{\r\nstruct ath_common *common = ath9k_hw_common(ah);\r\nstruct ath9k_hw_mci *mci = &ah->btcoex_hw.mci;\r\nath_dbg(common, MCI, "Give LNA and SPDT control to BT\n");\r\nar9003_mci_send_lna_take(ah, true);\r\nudelay(50);\r\nREG_SET_BIT(ah, AR_PHY_GLB_CONTROL, AR_BTCOEX_CTRL_BT_OWN_SPDT_CTRL);\r\nmci->is_2g = false;\r\nmci->update_2g5g = true;\r\nar9003_mci_send_2g5g_status(ah, true);\r\nmci->update_2g5g = true;\r\n}\r\nvoid ar9003_mci_set_power_awake(struct ath_hw *ah)\r\n{\r\nu32 btcoex_ctrl2, diag_sw;\r\nint i;\r\nu8 lna_ctrl, bt_sleep;\r\nfor (i = 0; i < AH_WAIT_TIMEOUT; i++) {\r\nbtcoex_ctrl2 = REG_READ(ah, AR_BTCOEX_CTRL2);\r\nif (btcoex_ctrl2 != 0xdeadbeef)\r\nbreak;\r\nudelay(AH_TIME_QUANTUM);\r\n}\r\nREG_WRITE(ah, AR_BTCOEX_CTRL2, (btcoex_ctrl2 | BIT(23)));\r\nfor (i = 0; i < AH_WAIT_TIMEOUT; i++) {\r\ndiag_sw = REG_READ(ah, AR_DIAG_SW);\r\nif (diag_sw != 0xdeadbeef)\r\nbreak;\r\nudelay(AH_TIME_QUANTUM);\r\n}\r\nREG_WRITE(ah, AR_DIAG_SW, (diag_sw | BIT(27) | BIT(19) | BIT(18)));\r\nlna_ctrl = REG_READ(ah, AR_OBS_BUS_CTRL) & 0x3;\r\nbt_sleep = MS(REG_READ(ah, AR_MCI_RX_STATUS), AR_MCI_RX_REMOTE_SLEEP);\r\nREG_WRITE(ah, AR_BTCOEX_CTRL2, btcoex_ctrl2);\r\nREG_WRITE(ah, AR_DIAG_SW, diag_sw);\r\nif (bt_sleep && (lna_ctrl == 2)) {\r\nREG_SET_BIT(ah, AR_BTCOEX_RC, 0x1);\r\nREG_CLR_BIT(ah, AR_BTCOEX_RC, 0x1);\r\nudelay(50);\r\n}\r\n}\r\nvoid ar9003_mci_check_gpm_offset(struct ath_hw *ah)\r\n{\r\nstruct ath_common *common = ath9k_hw_common(ah);\r\nstruct ath9k_hw_mci *mci = &ah->btcoex_hw.mci;\r\nu32 offset;\r\noffset = MS(REG_READ(ah, AR_MCI_GPM_1), AR_MCI_GPM_WRITE_PTR);\r\nif (mci->gpm_idx == offset)\r\nreturn;\r\nath_dbg(common, MCI, "GPM cached write pointer mismatch %d %d\n",\r\nmci->gpm_idx, offset);\r\nmci->query_bt = true;\r\nmci->need_flush_btinfo = true;\r\nmci->gpm_idx = 0;\r\n}\r\nu32 ar9003_mci_get_next_gpm_offset(struct ath_hw *ah, u32 *more)\r\n{\r\nstruct ath9k_hw_mci *mci = &ah->btcoex_hw.mci;\r\nu32 offset, more_gpm = 0, gpm_ptr;\r\nREG_WRITE(ah, AR_MCI_INTERRUPT_RX_MSG_RAW,\r\nAR_MCI_INTERRUPT_RX_MSG_GPM);\r\ngpm_ptr = MS(REG_READ(ah, AR_MCI_GPM_1), AR_MCI_GPM_WRITE_PTR);\r\noffset = gpm_ptr;\r\nif (!offset)\r\noffset = mci->gpm_len - 1;\r\nelse if (offset >= mci->gpm_len) {\r\nif (offset != 0xFFFF)\r\noffset = 0;\r\n} else {\r\noffset--;\r\n}\r\nif ((offset == 0xFFFF) || (gpm_ptr == mci->gpm_idx)) {\r\noffset = MCI_GPM_INVALID;\r\nmore_gpm = MCI_GPM_NOMORE;\r\ngoto out;\r\n}\r\nfor (;;) {\r\nu32 temp_index;\r\nif (offset != mci->gpm_idx)\r\nmore_gpm = MCI_GPM_MORE;\r\nelse\r\nmore_gpm = MCI_GPM_NOMORE;\r\ntemp_index = mci->gpm_idx;\r\nif (temp_index >= mci->gpm_len)\r\ntemp_index = 0;\r\nmci->gpm_idx++;\r\nif (mci->gpm_idx >= mci->gpm_len)\r\nmci->gpm_idx = 0;\r\nif (ar9003_mci_is_gpm_valid(ah, temp_index)) {\r\noffset = temp_index;\r\nbreak;\r\n}\r\nif (more_gpm == MCI_GPM_NOMORE) {\r\noffset = MCI_GPM_INVALID;\r\nbreak;\r\n}\r\n}\r\nif (offset != MCI_GPM_INVALID)\r\noffset <<= 4;\r\nout:\r\nif (more)\r\n*more = more_gpm;\r\nreturn offset;\r\n}\r\nvoid ar9003_mci_set_bt_version(struct ath_hw *ah, u8 major, u8 minor)\r\n{\r\nstruct ath9k_hw_mci *mci = &ah->btcoex_hw.mci;\r\nmci->bt_ver_major = major;\r\nmci->bt_ver_minor = minor;\r\nmci->bt_version_known = true;\r\nath_dbg(ath9k_hw_common(ah), MCI, "MCI BT version set: %d.%d\n",\r\nmci->bt_ver_major, mci->bt_ver_minor);\r\n}\r\nvoid ar9003_mci_send_wlan_channels(struct ath_hw *ah)\r\n{\r\nstruct ath9k_hw_mci *mci = &ah->btcoex_hw.mci;\r\nmci->wlan_channels_update = true;\r\nar9003_mci_send_coex_wlan_channels(ah, true);\r\n}\r\nu16 ar9003_mci_get_max_txpower(struct ath_hw *ah, u8 ctlmode)\r\n{\r\nif (!ah->btcoex_hw.mci.concur_tx)\r\ngoto out;\r\nif (ctlmode == CTL_2GHT20)\r\nreturn ATH_BTCOEX_HT20_MAX_TXPOWER;\r\nelse if (ctlmode == CTL_2GHT40)\r\nreturn ATH_BTCOEX_HT40_MAX_TXPOWER;\r\nout:\r\nreturn -1;\r\n}
