int hw_sm750_map(struct sm750_dev *sm750_dev, struct pci_dev *pdev)\r\n{\r\nint ret;\r\nret = 0;\r\nsm750_dev->vidreg_start = pci_resource_start(pdev, 1);\r\nsm750_dev->vidreg_size = SZ_2M;\r\npr_info("mmio phyAddr = %lx\n", sm750_dev->vidreg_start);\r\nret = pci_request_region(pdev, 1, "sm750fb");\r\nif (ret) {\r\npr_err("Can not request PCI regions.\n");\r\ngoto exit;\r\n}\r\nsm750_dev->pvReg = ioremap_nocache(sm750_dev->vidreg_start,\r\nsm750_dev->vidreg_size);\r\nif (!sm750_dev->pvReg) {\r\npr_err("mmio failed\n");\r\nret = -EFAULT;\r\ngoto exit;\r\n} else {\r\npr_info("mmio virtual addr = %p\n", sm750_dev->pvReg);\r\n}\r\nsm750_dev->accel.dprBase = sm750_dev->pvReg + DE_BASE_ADDR_TYPE1;\r\nsm750_dev->accel.dpPortBase = sm750_dev->pvReg + DE_PORT_ADDR_TYPE1;\r\nddk750_set_mmio(sm750_dev->pvReg, sm750_dev->devid, sm750_dev->revid);\r\nsm750_dev->vidmem_start = pci_resource_start(pdev, 0);\r\nsm750_dev->vidmem_size = ddk750_getVMSize();\r\npr_info("video memory phyAddr = %lx, size = %u bytes\n",\r\nsm750_dev->vidmem_start, sm750_dev->vidmem_size);\r\nsm750_dev->pvMem = ioremap_wc(sm750_dev->vidmem_start,\r\nsm750_dev->vidmem_size);\r\nif (!sm750_dev->pvMem) {\r\npr_err("Map video memory failed\n");\r\nret = -EFAULT;\r\ngoto exit;\r\n} else {\r\npr_info("video memory vaddr = %p\n", sm750_dev->pvMem);\r\n}\r\nexit:\r\nreturn ret;\r\n}\r\nint hw_sm750_inithw(struct sm750_dev *sm750_dev, struct pci_dev *pdev)\r\n{\r\nstruct init_status *parm;\r\nparm = &sm750_dev->initParm;\r\nif (parm->chip_clk == 0)\r\nparm->chip_clk = (getChipType() == SM750LE) ?\r\nDEFAULT_SM750LE_CHIP_CLOCK :\r\nDEFAULT_SM750_CHIP_CLOCK;\r\nif (parm->mem_clk == 0)\r\nparm->mem_clk = parm->chip_clk;\r\nif (parm->master_clk == 0)\r\nparm->master_clk = parm->chip_clk/3;\r\nddk750_initHw((initchip_param_t *)&sm750_dev->initParm);\r\nif (sm750_dev->devid == 0x718) {\r\nPOKE32(SYSTEM_CTRL,\r\nFIELD_SET(PEEK32(SYSTEM_CTRL), SYSTEM_CTRL, PCI_BURST, ON));\r\n}\r\nif (getChipType() != SM750LE) {\r\nif (sm750_dev->nocrt) {\r\nPOKE32(MISC_CTRL,\r\nFIELD_SET(PEEK32(MISC_CTRL),\r\nMISC_CTRL,\r\nDAC_POWER, OFF));\r\nPOKE32(SYSTEM_CTRL,\r\nFIELD_SET(PEEK32(SYSTEM_CTRL),\r\nSYSTEM_CTRL,\r\nDPMS, VNHN));\r\n} else {\r\nPOKE32(MISC_CTRL,\r\nFIELD_SET(PEEK32(MISC_CTRL),\r\nMISC_CTRL,\r\nDAC_POWER, ON));\r\nPOKE32(SYSTEM_CTRL,\r\nFIELD_SET(PEEK32(SYSTEM_CTRL),\r\nSYSTEM_CTRL,\r\nDPMS, VPHP));\r\n}\r\nswitch (sm750_dev->pnltype) {\r\ncase sm750_doubleTFT:\r\ncase sm750_24TFT:\r\ncase sm750_dualTFT:\r\nPOKE32(PANEL_DISPLAY_CTRL,\r\nFIELD_VALUE(PEEK32(PANEL_DISPLAY_CTRL),\r\nPANEL_DISPLAY_CTRL,\r\nTFT_DISP,\r\nsm750_dev->pnltype));\r\nbreak;\r\n}\r\n} else {\r\nsm750_sw_i2c_init(0, 1);\r\nif (sm750_sw_i2c_read_reg(0xec, 0x4a) == 0x95) {\r\npr_info("yes,CH7301 DVI chip found\n");\r\nsm750_sw_i2c_write_reg(0xec, 0x1d, 0x16);\r\nsm750_sw_i2c_write_reg(0xec, 0x21, 0x9);\r\nsm750_sw_i2c_write_reg(0xec, 0x49, 0xC0);\r\npr_info("okay,CH7301 DVI chip setup done\n");\r\n}\r\n}\r\nif (!sm750_dev->accel_off)\r\nhw_sm750_initAccel(sm750_dev);\r\nreturn 0;\r\n}\r\nint hw_sm750_output_setMode(struct lynxfb_output *output,\r\nstruct fb_var_screeninfo *var, struct fb_fix_screeninfo *fix)\r\n{\r\nint ret;\r\ndisp_output_t dispSet;\r\nint channel;\r\nret = 0;\r\ndispSet = 0;\r\nchannel = *output->channel;\r\nif (getChipType() != SM750LE) {\r\nif (channel == sm750_primary) {\r\npr_info("primary channel\n");\r\nif (output->paths & sm750_panel)\r\ndispSet |= do_LCD1_PRI;\r\nif (output->paths & sm750_crt)\r\ndispSet |= do_CRT_PRI;\r\n} else {\r\npr_info("secondary channel\n");\r\nif (output->paths & sm750_panel)\r\ndispSet |= do_LCD1_SEC;\r\nif (output->paths & sm750_crt)\r\ndispSet |= do_CRT_SEC;\r\n}\r\nddk750_setLogicalDispOut(dispSet);\r\n} else {\r\nu32 reg;\r\nreg = PEEK32(DISPLAY_CONTROL_750LE);\r\nreg |= 0xf;\r\nPOKE32(DISPLAY_CONTROL_750LE, reg);\r\n}\r\npr_info("ddk setlogicdispout done\n");\r\nreturn ret;\r\n}\r\nint hw_sm750_crtc_checkMode(struct lynxfb_crtc *crtc, struct fb_var_screeninfo *var)\r\n{\r\nstruct sm750_dev *sm750_dev;\r\nstruct lynxfb_par *par = container_of(crtc, struct lynxfb_par, crtc);\r\nsm750_dev = par->dev;\r\nswitch (var->bits_per_pixel) {\r\ncase 8:\r\ncase 16:\r\nbreak;\r\ncase 32:\r\nif (sm750_dev->revid == SM750LE_REVISION_ID) {\r\npr_debug("750le do not support 32bpp\n");\r\nreturn -EINVAL;\r\n}\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nint hw_sm750_crtc_setMode(struct lynxfb_crtc *crtc,\r\nstruct fb_var_screeninfo *var,\r\nstruct fb_fix_screeninfo *fix)\r\n{\r\nint ret, fmt;\r\nu32 reg;\r\nmode_parameter_t modparm;\r\nclock_type_t clock;\r\nstruct sm750_dev *sm750_dev;\r\nstruct lynxfb_par *par;\r\nret = 0;\r\npar = container_of(crtc, struct lynxfb_par, crtc);\r\nsm750_dev = par->dev;\r\nif (!sm750_dev->accel_off) {\r\nswitch (var->bits_per_pixel) {\r\ncase 8:\r\nfmt = 0;\r\nbreak;\r\ncase 16:\r\nfmt = 1;\r\nbreak;\r\ncase 32:\r\ndefault:\r\nfmt = 2;\r\nbreak;\r\n}\r\nhw_set2dformat(&sm750_dev->accel, fmt);\r\n}\r\nmodparm.pixel_clock = ps_to_hz(var->pixclock);\r\nmodparm.vertical_sync_polarity = (var->sync & FB_SYNC_HOR_HIGH_ACT) ? POS:NEG;\r\nmodparm.horizontal_sync_polarity = (var->sync & FB_SYNC_VERT_HIGH_ACT) ? POS:NEG;\r\nmodparm.clock_phase_polarity = (var->sync & FB_SYNC_COMP_HIGH_ACT) ? POS:NEG;\r\nmodparm.horizontal_display_end = var->xres;\r\nmodparm.horizontal_sync_width = var->hsync_len;\r\nmodparm.horizontal_sync_start = var->xres + var->right_margin;\r\nmodparm.horizontal_total = var->xres + var->left_margin + var->right_margin + var->hsync_len;\r\nmodparm.vertical_display_end = var->yres;\r\nmodparm.vertical_sync_height = var->vsync_len;\r\nmodparm.vertical_sync_start = var->yres + var->lower_margin;\r\nmodparm.vertical_total = var->yres + var->upper_margin + var->lower_margin + var->vsync_len;\r\nif (crtc->channel != sm750_secondary)\r\nclock = PRIMARY_PLL;\r\nelse\r\nclock = SECONDARY_PLL;\r\npr_debug("Request pixel clock = %lu\n", modparm.pixel_clock);\r\nret = ddk750_setModeTiming(&modparm, clock);\r\nif (ret) {\r\npr_err("Set mode timing failed\n");\r\ngoto exit;\r\n}\r\nif (crtc->channel != sm750_secondary) {\r\nPOKE32(PANEL_FB_ADDRESS,\r\nFIELD_SET(0, PANEL_FB_ADDRESS, STATUS, CURRENT)|\r\nFIELD_SET(0, PANEL_FB_ADDRESS, EXT, LOCAL)|\r\nFIELD_VALUE(0, PANEL_FB_ADDRESS, ADDRESS, crtc->oScreen));\r\nreg = var->xres * (var->bits_per_pixel >> 3);\r\nreg = ALIGN(reg, crtc->line_pad);\r\nPOKE32(PANEL_FB_WIDTH,\r\nFIELD_VALUE(0, PANEL_FB_WIDTH, WIDTH, reg)|\r\nFIELD_VALUE(0, PANEL_FB_WIDTH, OFFSET, fix->line_length));\r\nPOKE32(PANEL_WINDOW_WIDTH,\r\nFIELD_VALUE(0, PANEL_WINDOW_WIDTH, WIDTH, var->xres - 1)|\r\nFIELD_VALUE(0, PANEL_WINDOW_WIDTH, X, var->xoffset));\r\nPOKE32(PANEL_WINDOW_HEIGHT,\r\nFIELD_VALUE(0, PANEL_WINDOW_HEIGHT, HEIGHT, var->yres_virtual - 1)|\r\nFIELD_VALUE(0, PANEL_WINDOW_HEIGHT, Y, var->yoffset));\r\nPOKE32(PANEL_PLANE_TL, 0);\r\nPOKE32(PANEL_PLANE_BR,\r\nFIELD_VALUE(0, PANEL_PLANE_BR, BOTTOM, var->yres - 1)|\r\nFIELD_VALUE(0, PANEL_PLANE_BR, RIGHT, var->xres - 1));\r\nreg = PEEK32(PANEL_DISPLAY_CTRL);\r\nPOKE32(PANEL_DISPLAY_CTRL,\r\nFIELD_VALUE(reg,\r\nPANEL_DISPLAY_CTRL, FORMAT,\r\n(var->bits_per_pixel >> 4)\r\n));\r\n} else {\r\nPOKE32(CRT_FB_ADDRESS, crtc->oScreen);\r\nreg = var->xres * (var->bits_per_pixel >> 3);\r\nreg = ALIGN(reg, crtc->line_pad);\r\nPOKE32(CRT_FB_WIDTH,\r\nFIELD_VALUE(0, CRT_FB_WIDTH, WIDTH, reg)|\r\nFIELD_VALUE(0, CRT_FB_WIDTH, OFFSET, fix->line_length));\r\nreg = PEEK32(CRT_DISPLAY_CTRL);\r\nreg = FIELD_VALUE(reg, CRT_DISPLAY_CTRL, FORMAT, var->bits_per_pixel >> 4);\r\nPOKE32(CRT_DISPLAY_CTRL, reg);\r\n}\r\nexit:\r\nreturn ret;\r\n}\r\nint hw_sm750_setColReg(struct lynxfb_crtc *crtc, ushort index,\r\nushort red, ushort green, ushort blue)\r\n{\r\nstatic unsigned int add[] = {PANEL_PALETTE_RAM, CRT_PALETTE_RAM};\r\nPOKE32(add[crtc->channel] + index*4, (red<<16)|(green<<8)|blue);\r\nreturn 0;\r\n}\r\nint hw_sm750le_setBLANK(struct lynxfb_output *output, int blank)\r\n{\r\nint dpms, crtdb;\r\nswitch (blank) {\r\ncase FB_BLANK_UNBLANK:\r\ndpms = CRT_DISPLAY_CTRL_DPMS_0;\r\ncrtdb = CRT_DISPLAY_CTRL_BLANK_OFF;\r\nbreak;\r\ncase FB_BLANK_NORMAL:\r\ndpms = CRT_DISPLAY_CTRL_DPMS_0;\r\ncrtdb = CRT_DISPLAY_CTRL_BLANK_ON;\r\nbreak;\r\ncase FB_BLANK_VSYNC_SUSPEND:\r\ndpms = CRT_DISPLAY_CTRL_DPMS_2;\r\ncrtdb = CRT_DISPLAY_CTRL_BLANK_ON;\r\nbreak;\r\ncase FB_BLANK_HSYNC_SUSPEND:\r\ndpms = CRT_DISPLAY_CTRL_DPMS_1;\r\ncrtdb = CRT_DISPLAY_CTRL_BLANK_ON;\r\nbreak;\r\ncase FB_BLANK_POWERDOWN:\r\ndpms = CRT_DISPLAY_CTRL_DPMS_3;\r\ncrtdb = CRT_DISPLAY_CTRL_BLANK_ON;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nif (output->paths & sm750_crt) {\r\nPOKE32(CRT_DISPLAY_CTRL, FIELD_VALUE(PEEK32(CRT_DISPLAY_CTRL), CRT_DISPLAY_CTRL, DPMS, dpms));\r\nPOKE32(CRT_DISPLAY_CTRL, FIELD_VALUE(PEEK32(CRT_DISPLAY_CTRL), CRT_DISPLAY_CTRL, BLANK, crtdb));\r\n}\r\nreturn 0;\r\n}\r\nint hw_sm750_setBLANK(struct lynxfb_output *output, int blank)\r\n{\r\nunsigned int dpms, pps, crtdb;\r\ndpms = pps = crtdb = 0;\r\nswitch (blank) {\r\ncase FB_BLANK_UNBLANK:\r\npr_info("flag = FB_BLANK_UNBLANK\n");\r\ndpms = SYSTEM_CTRL_DPMS_VPHP;\r\npps = PANEL_DISPLAY_CTRL_DATA_ENABLE;\r\ncrtdb = CRT_DISPLAY_CTRL_BLANK_OFF;\r\nbreak;\r\ncase FB_BLANK_NORMAL:\r\npr_info("flag = FB_BLANK_NORMAL\n");\r\ndpms = SYSTEM_CTRL_DPMS_VPHP;\r\npps = PANEL_DISPLAY_CTRL_DATA_DISABLE;\r\ncrtdb = CRT_DISPLAY_CTRL_BLANK_ON;\r\nbreak;\r\ncase FB_BLANK_VSYNC_SUSPEND:\r\ndpms = SYSTEM_CTRL_DPMS_VNHP;\r\npps = PANEL_DISPLAY_CTRL_DATA_DISABLE;\r\ncrtdb = CRT_DISPLAY_CTRL_BLANK_ON;\r\nbreak;\r\ncase FB_BLANK_HSYNC_SUSPEND:\r\ndpms = SYSTEM_CTRL_DPMS_VPHN;\r\npps = PANEL_DISPLAY_CTRL_DATA_DISABLE;\r\ncrtdb = CRT_DISPLAY_CTRL_BLANK_ON;\r\nbreak;\r\ncase FB_BLANK_POWERDOWN:\r\ndpms = SYSTEM_CTRL_DPMS_VNHN;\r\npps = PANEL_DISPLAY_CTRL_DATA_DISABLE;\r\ncrtdb = CRT_DISPLAY_CTRL_BLANK_ON;\r\nbreak;\r\n}\r\nif (output->paths & sm750_crt) {\r\nPOKE32(SYSTEM_CTRL, FIELD_VALUE(PEEK32(SYSTEM_CTRL), SYSTEM_CTRL, DPMS, dpms));\r\nPOKE32(CRT_DISPLAY_CTRL, FIELD_VALUE(PEEK32(CRT_DISPLAY_CTRL), CRT_DISPLAY_CTRL, BLANK, crtdb));\r\n}\r\nif (output->paths & sm750_panel)\r\nPOKE32(PANEL_DISPLAY_CTRL, FIELD_VALUE(PEEK32(PANEL_DISPLAY_CTRL), PANEL_DISPLAY_CTRL, DATA, pps));\r\nreturn 0;\r\n}\r\nvoid hw_sm750_initAccel(struct sm750_dev *sm750_dev)\r\n{\r\nu32 reg;\r\nenable2DEngine(1);\r\nif (getChipType() == SM750LE) {\r\nreg = PEEK32(DE_STATE1);\r\nreg = FIELD_SET(reg, DE_STATE1, DE_ABORT, ON);\r\nPOKE32(DE_STATE1, reg);\r\nreg = PEEK32(DE_STATE1);\r\nreg = FIELD_SET(reg, DE_STATE1, DE_ABORT, OFF);\r\nPOKE32(DE_STATE1, reg);\r\n} else {\r\nreg = PEEK32(SYSTEM_CTRL);\r\nreg = FIELD_SET(reg, SYSTEM_CTRL, DE_ABORT, ON);\r\nPOKE32(SYSTEM_CTRL, reg);\r\nreg = PEEK32(SYSTEM_CTRL);\r\nreg = FIELD_SET(reg, SYSTEM_CTRL, DE_ABORT, OFF);\r\nPOKE32(SYSTEM_CTRL, reg);\r\n}\r\nsm750_dev->accel.de_init(&sm750_dev->accel);\r\n}\r\nint hw_sm750le_deWait(void)\r\n{\r\nint i = 0x10000000;\r\nwhile (i--) {\r\nunsigned int dwVal = PEEK32(DE_STATE2);\r\nif ((FIELD_GET(dwVal, DE_STATE2, DE_STATUS) == DE_STATE2_DE_STATUS_IDLE) &&\r\n(FIELD_GET(dwVal, DE_STATE2, DE_FIFO) == DE_STATE2_DE_FIFO_EMPTY) &&\r\n(FIELD_GET(dwVal, DE_STATE2, DE_MEM_FIFO) == DE_STATE2_DE_MEM_FIFO_EMPTY)) {\r\nreturn 0;\r\n}\r\n}\r\nreturn -1;\r\n}\r\nint hw_sm750_deWait(void)\r\n{\r\nint i = 0x10000000;\r\nwhile (i--) {\r\nunsigned int dwVal = PEEK32(SYSTEM_CTRL);\r\nif ((FIELD_GET(dwVal, SYSTEM_CTRL, DE_STATUS) == SYSTEM_CTRL_DE_STATUS_IDLE) &&\r\n(FIELD_GET(dwVal, SYSTEM_CTRL, DE_FIFO) == SYSTEM_CTRL_DE_FIFO_EMPTY) &&\r\n(FIELD_GET(dwVal, SYSTEM_CTRL, DE_MEM_FIFO) == SYSTEM_CTRL_DE_MEM_FIFO_EMPTY)) {\r\nreturn 0;\r\n}\r\n}\r\nreturn -1;\r\n}\r\nint hw_sm750_pan_display(struct lynxfb_crtc *crtc,\r\nconst struct fb_var_screeninfo *var,\r\nconst struct fb_info *info)\r\n{\r\nuint32_t total;\r\nif ((var->xoffset + var->xres > var->xres_virtual) ||\r\n(var->yoffset + var->yres > var->yres_virtual)) {\r\nreturn -EINVAL;\r\n}\r\ntotal = var->yoffset * info->fix.line_length +\r\n((var->xoffset * var->bits_per_pixel) >> 3);\r\ntotal += crtc->oScreen;\r\nif (crtc->channel == sm750_primary) {\r\nPOKE32(PANEL_FB_ADDRESS,\r\nFIELD_VALUE(PEEK32(PANEL_FB_ADDRESS),\r\nPANEL_FB_ADDRESS, ADDRESS, total));\r\n} else {\r\nPOKE32(CRT_FB_ADDRESS,\r\nFIELD_VALUE(PEEK32(CRT_FB_ADDRESS),\r\nCRT_FB_ADDRESS, ADDRESS, total));\r\n}\r\nreturn 0;\r\n}
