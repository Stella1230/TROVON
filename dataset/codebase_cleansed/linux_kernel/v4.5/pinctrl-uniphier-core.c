static int uniphier_pctl_get_groups_count(struct pinctrl_dev *pctldev)\r\n{\r\nstruct uniphier_pinctrl_priv *priv = pinctrl_dev_get_drvdata(pctldev);\r\nreturn priv->socdata->groups_count;\r\n}\r\nstatic const char *uniphier_pctl_get_group_name(struct pinctrl_dev *pctldev,\r\nunsigned selector)\r\n{\r\nstruct uniphier_pinctrl_priv *priv = pinctrl_dev_get_drvdata(pctldev);\r\nreturn priv->socdata->groups[selector].name;\r\n}\r\nstatic int uniphier_pctl_get_group_pins(struct pinctrl_dev *pctldev,\r\nunsigned selector,\r\nconst unsigned **pins,\r\nunsigned *num_pins)\r\n{\r\nstruct uniphier_pinctrl_priv *priv = pinctrl_dev_get_drvdata(pctldev);\r\n*pins = priv->socdata->groups[selector].pins;\r\n*num_pins = priv->socdata->groups[selector].num_pins;\r\nreturn 0;\r\n}\r\nstatic void uniphier_pctl_pin_dbg_show(struct pinctrl_dev *pctldev,\r\nstruct seq_file *s, unsigned offset)\r\n{\r\nconst struct pinctrl_pin_desc *pin = &pctldev->desc->pins[offset];\r\nconst char *pull_dir, *drv_str;\r\nswitch (uniphier_pin_get_pull_dir(pin->drv_data)) {\r\ncase UNIPHIER_PIN_PULL_UP:\r\npull_dir = "UP";\r\nbreak;\r\ncase UNIPHIER_PIN_PULL_DOWN:\r\npull_dir = "DOWN";\r\nbreak;\r\ncase UNIPHIER_PIN_PULL_NONE:\r\npull_dir = "NONE";\r\nbreak;\r\ndefault:\r\nBUG();\r\n}\r\nswitch (uniphier_pin_get_drv_str(pin->drv_data)) {\r\ncase UNIPHIER_PIN_DRV_4_8:\r\ndrv_str = "4/8(mA)";\r\nbreak;\r\ncase UNIPHIER_PIN_DRV_8_12_16_20:\r\ndrv_str = "8/12/16/20(mA)";\r\nbreak;\r\ncase UNIPHIER_PIN_DRV_FIXED_4:\r\ndrv_str = "4(mA)";\r\nbreak;\r\ncase UNIPHIER_PIN_DRV_FIXED_5:\r\ndrv_str = "5(mA)";\r\nbreak;\r\ncase UNIPHIER_PIN_DRV_FIXED_8:\r\ndrv_str = "8(mA)";\r\nbreak;\r\ncase UNIPHIER_PIN_DRV_NONE:\r\ndrv_str = "NONE";\r\nbreak;\r\ndefault:\r\nBUG();\r\n}\r\nseq_printf(s, " PULL_DIR=%s DRV_STR=%s", pull_dir, drv_str);\r\n}\r\nstatic int uniphier_conf_pin_bias_get(struct pinctrl_dev *pctldev,\r\nconst struct pinctrl_pin_desc *pin,\r\nenum pin_config_param param)\r\n{\r\nstruct uniphier_pinctrl_priv *priv = pinctrl_dev_get_drvdata(pctldev);\r\nenum uniphier_pin_pull_dir pull_dir =\r\nuniphier_pin_get_pull_dir(pin->drv_data);\r\nunsigned int pupdctrl, reg, shift, val;\r\nunsigned int expected = 1;\r\nint ret;\r\nswitch (param) {\r\ncase PIN_CONFIG_BIAS_DISABLE:\r\nif (pull_dir == UNIPHIER_PIN_PULL_NONE)\r\nreturn 0;\r\nif (pull_dir == UNIPHIER_PIN_PULL_UP_FIXED ||\r\npull_dir == UNIPHIER_PIN_PULL_DOWN_FIXED)\r\nreturn -EINVAL;\r\nexpected = 0;\r\nbreak;\r\ncase PIN_CONFIG_BIAS_PULL_UP:\r\nif (pull_dir == UNIPHIER_PIN_PULL_UP_FIXED)\r\nreturn 0;\r\nif (pull_dir != UNIPHIER_PIN_PULL_UP)\r\nreturn -EINVAL;\r\nbreak;\r\ncase PIN_CONFIG_BIAS_PULL_DOWN:\r\nif (pull_dir == UNIPHIER_PIN_PULL_DOWN_FIXED)\r\nreturn 0;\r\nif (pull_dir != UNIPHIER_PIN_PULL_DOWN)\r\nreturn -EINVAL;\r\nbreak;\r\ndefault:\r\nBUG();\r\n}\r\npupdctrl = uniphier_pin_get_pupdctrl(pin->drv_data);\r\nreg = UNIPHIER_PINCTRL_PUPDCTRL_BASE + pupdctrl / 32 * 4;\r\nshift = pupdctrl % 32;\r\nret = regmap_read(priv->regmap, reg, &val);\r\nif (ret)\r\nreturn ret;\r\nval = (val >> shift) & 1;\r\nreturn (val == expected) ? 0 : -EINVAL;\r\n}\r\nstatic int uniphier_conf_pin_drive_get(struct pinctrl_dev *pctldev,\r\nconst struct pinctrl_pin_desc *pin,\r\nu16 *strength)\r\n{\r\nstruct uniphier_pinctrl_priv *priv = pinctrl_dev_get_drvdata(pctldev);\r\nenum uniphier_pin_drv_str drv_str =\r\nuniphier_pin_get_drv_str(pin->drv_data);\r\nconst unsigned int strength_4_8[] = {4, 8};\r\nconst unsigned int strength_8_12_16_20[] = {8, 12, 16, 20};\r\nconst unsigned int *supported_strength;\r\nunsigned int drvctrl, reg, shift, mask, width, val;\r\nint ret;\r\nswitch (drv_str) {\r\ncase UNIPHIER_PIN_DRV_4_8:\r\nsupported_strength = strength_4_8;\r\nwidth = 1;\r\nbreak;\r\ncase UNIPHIER_PIN_DRV_8_12_16_20:\r\nsupported_strength = strength_8_12_16_20;\r\nwidth = 2;\r\nbreak;\r\ncase UNIPHIER_PIN_DRV_FIXED_4:\r\n*strength = 4;\r\nreturn 0;\r\ncase UNIPHIER_PIN_DRV_FIXED_5:\r\n*strength = 5;\r\nreturn 0;\r\ncase UNIPHIER_PIN_DRV_FIXED_8:\r\n*strength = 8;\r\nreturn 0;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\ndrvctrl = uniphier_pin_get_drvctrl(pin->drv_data);\r\ndrvctrl *= width;\r\nreg = (width == 2) ? UNIPHIER_PINCTRL_DRV2CTRL_BASE :\r\nUNIPHIER_PINCTRL_DRVCTRL_BASE;\r\nreg += drvctrl / 32 * 4;\r\nshift = drvctrl % 32;\r\nmask = (1U << width) - 1;\r\nret = regmap_read(priv->regmap, reg, &val);\r\nif (ret)\r\nreturn ret;\r\n*strength = supported_strength[(val >> shift) & mask];\r\nreturn 0;\r\n}\r\nstatic int uniphier_conf_pin_input_enable_get(struct pinctrl_dev *pctldev,\r\nconst struct pinctrl_pin_desc *pin)\r\n{\r\nstruct uniphier_pinctrl_priv *priv = pinctrl_dev_get_drvdata(pctldev);\r\nunsigned int iectrl = uniphier_pin_get_iectrl(pin->drv_data);\r\nunsigned int val;\r\nint ret;\r\nif (iectrl == UNIPHIER_PIN_IECTRL_NONE)\r\nreturn 0;\r\nret = regmap_read(priv->regmap, UNIPHIER_PINCTRL_IECTRL, &val);\r\nif (ret)\r\nreturn ret;\r\nreturn val & BIT(iectrl) ? 0 : -EINVAL;\r\n}\r\nstatic int uniphier_conf_pin_config_get(struct pinctrl_dev *pctldev,\r\nunsigned pin,\r\nunsigned long *configs)\r\n{\r\nconst struct pinctrl_pin_desc *pin_desc = &pctldev->desc->pins[pin];\r\nenum pin_config_param param = pinconf_to_config_param(*configs);\r\nbool has_arg = false;\r\nu16 arg;\r\nint ret;\r\nswitch (param) {\r\ncase PIN_CONFIG_BIAS_DISABLE:\r\ncase PIN_CONFIG_BIAS_PULL_UP:\r\ncase PIN_CONFIG_BIAS_PULL_DOWN:\r\nret = uniphier_conf_pin_bias_get(pctldev, pin_desc, param);\r\nbreak;\r\ncase PIN_CONFIG_DRIVE_STRENGTH:\r\nret = uniphier_conf_pin_drive_get(pctldev, pin_desc, &arg);\r\nhas_arg = true;\r\nbreak;\r\ncase PIN_CONFIG_INPUT_ENABLE:\r\nret = uniphier_conf_pin_input_enable_get(pctldev, pin_desc);\r\nbreak;\r\ndefault:\r\nret = -EINVAL;\r\nbreak;\r\n}\r\nif (ret == 0 && has_arg)\r\n*configs = pinconf_to_config_packed(param, arg);\r\nreturn ret;\r\n}\r\nstatic int uniphier_conf_pin_bias_set(struct pinctrl_dev *pctldev,\r\nconst struct pinctrl_pin_desc *pin,\r\nenum pin_config_param param,\r\nu16 arg)\r\n{\r\nstruct uniphier_pinctrl_priv *priv = pinctrl_dev_get_drvdata(pctldev);\r\nenum uniphier_pin_pull_dir pull_dir =\r\nuniphier_pin_get_pull_dir(pin->drv_data);\r\nunsigned int pupdctrl, reg, shift;\r\nunsigned int val = 1;\r\nswitch (param) {\r\ncase PIN_CONFIG_BIAS_DISABLE:\r\nif (pull_dir == UNIPHIER_PIN_PULL_NONE)\r\nreturn 0;\r\nif (pull_dir == UNIPHIER_PIN_PULL_UP_FIXED ||\r\npull_dir == UNIPHIER_PIN_PULL_DOWN_FIXED) {\r\ndev_err(pctldev->dev,\r\n"can not disable pull register for pin %u (%s)\n",\r\npin->number, pin->name);\r\nreturn -EINVAL;\r\n}\r\nval = 0;\r\nbreak;\r\ncase PIN_CONFIG_BIAS_PULL_UP:\r\nif (pull_dir == UNIPHIER_PIN_PULL_UP_FIXED && arg != 0)\r\nreturn 0;\r\nif (pull_dir != UNIPHIER_PIN_PULL_UP) {\r\ndev_err(pctldev->dev,\r\n"pull-up is unsupported for pin %u (%s)\n",\r\npin->number, pin->name);\r\nreturn -EINVAL;\r\n}\r\nif (arg == 0) {\r\ndev_err(pctldev->dev, "pull-up can not be total\n");\r\nreturn -EINVAL;\r\n}\r\nbreak;\r\ncase PIN_CONFIG_BIAS_PULL_DOWN:\r\nif (pull_dir == UNIPHIER_PIN_PULL_DOWN_FIXED && arg != 0)\r\nreturn 0;\r\nif (pull_dir != UNIPHIER_PIN_PULL_DOWN) {\r\ndev_err(pctldev->dev,\r\n"pull-down is unsupported for pin %u (%s)\n",\r\npin->number, pin->name);\r\nreturn -EINVAL;\r\n}\r\nif (arg == 0) {\r\ndev_err(pctldev->dev, "pull-down can not be total\n");\r\nreturn -EINVAL;\r\n}\r\nbreak;\r\ncase PIN_CONFIG_BIAS_PULL_PIN_DEFAULT:\r\nif (pull_dir == UNIPHIER_PIN_PULL_NONE) {\r\ndev_err(pctldev->dev,\r\n"pull-up/down is unsupported for pin %u (%s)\n",\r\npin->number, pin->name);\r\nreturn -EINVAL;\r\n}\r\nif (arg == 0)\r\nreturn 0;\r\nbreak;\r\ndefault:\r\nBUG();\r\n}\r\npupdctrl = uniphier_pin_get_pupdctrl(pin->drv_data);\r\nreg = UNIPHIER_PINCTRL_PUPDCTRL_BASE + pupdctrl / 32 * 4;\r\nshift = pupdctrl % 32;\r\nreturn regmap_update_bits(priv->regmap, reg, 1 << shift, val << shift);\r\n}\r\nstatic int uniphier_conf_pin_drive_set(struct pinctrl_dev *pctldev,\r\nconst struct pinctrl_pin_desc *pin,\r\nu16 strength)\r\n{\r\nstruct uniphier_pinctrl_priv *priv = pinctrl_dev_get_drvdata(pctldev);\r\nenum uniphier_pin_drv_str drv_str =\r\nuniphier_pin_get_drv_str(pin->drv_data);\r\nconst unsigned int strength_4_8[] = {4, 8, -1};\r\nconst unsigned int strength_8_12_16_20[] = {8, 12, 16, 20, -1};\r\nconst unsigned int *supported_strength;\r\nunsigned int drvctrl, reg, shift, mask, width, val;\r\nswitch (drv_str) {\r\ncase UNIPHIER_PIN_DRV_4_8:\r\nsupported_strength = strength_4_8;\r\nwidth = 1;\r\nbreak;\r\ncase UNIPHIER_PIN_DRV_8_12_16_20:\r\nsupported_strength = strength_8_12_16_20;\r\nwidth = 2;\r\nbreak;\r\ndefault:\r\ndev_err(pctldev->dev,\r\n"cannot change drive strength for pin %u (%s)\n",\r\npin->number, pin->name);\r\nreturn -EINVAL;\r\n}\r\nfor (val = 0; supported_strength[val] > 0; val++) {\r\nif (supported_strength[val] > strength)\r\nbreak;\r\n}\r\nif (val == 0) {\r\ndev_err(pctldev->dev,\r\n"unsupported drive strength %u mA for pin %u (%s)\n",\r\nstrength, pin->number, pin->name);\r\nreturn -EINVAL;\r\n}\r\nval--;\r\ndrvctrl = uniphier_pin_get_drvctrl(pin->drv_data);\r\ndrvctrl *= width;\r\nreg = (width == 2) ? UNIPHIER_PINCTRL_DRV2CTRL_BASE :\r\nUNIPHIER_PINCTRL_DRVCTRL_BASE;\r\nreg += drvctrl / 32 * 4;\r\nshift = drvctrl % 32;\r\nmask = (1U << width) - 1;\r\nreturn regmap_update_bits(priv->regmap, reg,\r\nmask << shift, val << shift);\r\n}\r\nstatic int uniphier_conf_pin_input_enable(struct pinctrl_dev *pctldev,\r\nconst struct pinctrl_pin_desc *pin,\r\nu16 enable)\r\n{\r\nstruct uniphier_pinctrl_priv *priv = pinctrl_dev_get_drvdata(pctldev);\r\nunsigned int iectrl = uniphier_pin_get_iectrl(pin->drv_data);\r\nif (enable == 0) {\r\ndev_err(pctldev->dev, "unable to disable input\n");\r\nreturn -EINVAL;\r\n}\r\nif (iectrl == UNIPHIER_PIN_IECTRL_NONE)\r\nreturn 0;\r\nreturn regmap_update_bits(priv->regmap, UNIPHIER_PINCTRL_IECTRL,\r\nBIT(iectrl), BIT(iectrl));\r\n}\r\nstatic int uniphier_conf_pin_config_set(struct pinctrl_dev *pctldev,\r\nunsigned pin,\r\nunsigned long *configs,\r\nunsigned num_configs)\r\n{\r\nconst struct pinctrl_pin_desc *pin_desc = &pctldev->desc->pins[pin];\r\nint i, ret;\r\nfor (i = 0; i < num_configs; i++) {\r\nenum pin_config_param param =\r\npinconf_to_config_param(configs[i]);\r\nu16 arg = pinconf_to_config_argument(configs[i]);\r\nswitch (param) {\r\ncase PIN_CONFIG_BIAS_DISABLE:\r\ncase PIN_CONFIG_BIAS_PULL_UP:\r\ncase PIN_CONFIG_BIAS_PULL_DOWN:\r\ncase PIN_CONFIG_BIAS_PULL_PIN_DEFAULT:\r\nret = uniphier_conf_pin_bias_set(pctldev, pin_desc,\r\nparam, arg);\r\nbreak;\r\ncase PIN_CONFIG_DRIVE_STRENGTH:\r\nret = uniphier_conf_pin_drive_set(pctldev, pin_desc,\r\narg);\r\nbreak;\r\ncase PIN_CONFIG_INPUT_ENABLE:\r\nret = uniphier_conf_pin_input_enable(pctldev,\r\npin_desc, arg);\r\nbreak;\r\ndefault:\r\ndev_err(pctldev->dev,\r\n"unsupported configuration parameter %u\n",\r\nparam);\r\nreturn -EINVAL;\r\n}\r\nif (ret)\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic int uniphier_conf_pin_config_group_set(struct pinctrl_dev *pctldev,\r\nunsigned selector,\r\nunsigned long *configs,\r\nunsigned num_configs)\r\n{\r\nstruct uniphier_pinctrl_priv *priv = pinctrl_dev_get_drvdata(pctldev);\r\nconst unsigned *pins = priv->socdata->groups[selector].pins;\r\nunsigned num_pins = priv->socdata->groups[selector].num_pins;\r\nint i, ret;\r\nfor (i = 0; i < num_pins; i++) {\r\nret = uniphier_conf_pin_config_set(pctldev, pins[i],\r\nconfigs, num_configs);\r\nif (ret)\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic int uniphier_pmx_get_functions_count(struct pinctrl_dev *pctldev)\r\n{\r\nstruct uniphier_pinctrl_priv *priv = pinctrl_dev_get_drvdata(pctldev);\r\nreturn priv->socdata->functions_count;\r\n}\r\nstatic const char *uniphier_pmx_get_function_name(struct pinctrl_dev *pctldev,\r\nunsigned selector)\r\n{\r\nstruct uniphier_pinctrl_priv *priv = pinctrl_dev_get_drvdata(pctldev);\r\nreturn priv->socdata->functions[selector].name;\r\n}\r\nstatic int uniphier_pmx_get_function_groups(struct pinctrl_dev *pctldev,\r\nunsigned selector,\r\nconst char * const **groups,\r\nunsigned *num_groups)\r\n{\r\nstruct uniphier_pinctrl_priv *priv = pinctrl_dev_get_drvdata(pctldev);\r\n*groups = priv->socdata->functions[selector].groups;\r\n*num_groups = priv->socdata->functions[selector].num_groups;\r\nreturn 0;\r\n}\r\nstatic int uniphier_pmx_set_one_mux(struct pinctrl_dev *pctldev, unsigned pin,\r\nunsigned muxval)\r\n{\r\nstruct uniphier_pinctrl_priv *priv = pinctrl_dev_get_drvdata(pctldev);\r\nunsigned mux_bits = priv->socdata->mux_bits;\r\nunsigned reg_stride = priv->socdata->reg_stride;\r\nunsigned reg, reg_end, shift, mask;\r\nint ret;\r\nret = uniphier_conf_pin_input_enable(pctldev,\r\n&pctldev->desc->pins[pin], 1);\r\nif (ret)\r\nreturn ret;\r\nreg = UNIPHIER_PINCTRL_PINMUX_BASE + pin * mux_bits / 32 * reg_stride;\r\nreg_end = reg + reg_stride;\r\nshift = pin * mux_bits % 32;\r\nmask = (1U << mux_bits) - 1;\r\nfor (; reg < reg_end; reg += 4) {\r\nret = regmap_update_bits(priv->regmap, reg,\r\nmask << shift, muxval << shift);\r\nif (ret)\r\nreturn ret;\r\nmuxval >>= mux_bits;\r\n}\r\nif (priv->socdata->load_pinctrl) {\r\nret = regmap_write(priv->regmap,\r\nUNIPHIER_PINCTRL_LOAD_PINMUX, 1);\r\nif (ret)\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic int uniphier_pmx_set_mux(struct pinctrl_dev *pctldev,\r\nunsigned func_selector,\r\nunsigned group_selector)\r\n{\r\nstruct uniphier_pinctrl_priv *priv = pinctrl_dev_get_drvdata(pctldev);\r\nconst struct uniphier_pinctrl_group *grp =\r\n&priv->socdata->groups[group_selector];\r\nint i;\r\nint ret;\r\nfor (i = 0; i < grp->num_pins; i++) {\r\nret = uniphier_pmx_set_one_mux(pctldev, grp->pins[i],\r\ngrp->muxvals[i]);\r\nif (ret)\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic int uniphier_pmx_gpio_request_enable(struct pinctrl_dev *pctldev,\r\nstruct pinctrl_gpio_range *range,\r\nunsigned offset)\r\n{\r\nstruct uniphier_pinctrl_priv *priv = pinctrl_dev_get_drvdata(pctldev);\r\nconst struct uniphier_pinctrl_group *groups = priv->socdata->groups;\r\nint groups_count = priv->socdata->groups_count;\r\nenum uniphier_pinmux_gpio_range_type range_type;\r\nint i, j;\r\nif (strstr(range->name, "irq"))\r\nrange_type = UNIPHIER_PINMUX_GPIO_RANGE_IRQ;\r\nelse\r\nrange_type = UNIPHIER_PINMUX_GPIO_RANGE_PORT;\r\nfor (i = 0; i < groups_count; i++) {\r\nif (groups[i].range_type != range_type)\r\ncontinue;\r\nfor (j = 0; j < groups[i].num_pins; j++)\r\nif (groups[i].pins[j] == offset)\r\ngoto found;\r\n}\r\ndev_err(pctldev->dev, "pin %u does not support GPIO\n", offset);\r\nreturn -EINVAL;\r\nfound:\r\nreturn uniphier_pmx_set_one_mux(pctldev, offset, groups[i].muxvals[j]);\r\n}\r\nint uniphier_pinctrl_probe(struct platform_device *pdev,\r\nstruct pinctrl_desc *desc,\r\nstruct uniphier_pinctrl_socdata *socdata)\r\n{\r\nstruct device *dev = &pdev->dev;\r\nstruct uniphier_pinctrl_priv *priv;\r\nif (!socdata ||\r\n!socdata->groups ||\r\n!socdata->groups_count ||\r\n!socdata->functions ||\r\n!socdata->functions_count ||\r\n!socdata->mux_bits ||\r\n!socdata->reg_stride) {\r\ndev_err(dev, "pinctrl socdata lacks necessary members\n");\r\nreturn -EINVAL;\r\n}\r\npriv = devm_kzalloc(dev, sizeof(*priv), GFP_KERNEL);\r\nif (!priv)\r\nreturn -ENOMEM;\r\npriv->regmap = syscon_node_to_regmap(dev->of_node);\r\nif (IS_ERR(priv->regmap)) {\r\ndev_err(dev, "failed to get regmap\n");\r\nreturn PTR_ERR(priv->regmap);\r\n}\r\npriv->socdata = socdata;\r\ndesc->pctlops = &uniphier_pctlops;\r\ndesc->pmxops = &uniphier_pmxops;\r\ndesc->confops = &uniphier_confops;\r\npriv->pctldev = pinctrl_register(desc, dev, priv);\r\nif (IS_ERR(priv->pctldev)) {\r\ndev_err(dev, "failed to register UniPhier pinctrl driver\n");\r\nreturn PTR_ERR(priv->pctldev);\r\n}\r\nplatform_set_drvdata(pdev, priv);\r\nreturn 0;\r\n}\r\nint uniphier_pinctrl_remove(struct platform_device *pdev)\r\n{\r\nstruct uniphier_pinctrl_priv *priv = platform_get_drvdata(pdev);\r\npinctrl_unregister(priv->pctldev);\r\nreturn 0;\r\n}
