static int slirp_user_init(void *data, void *dev)\r\n{\r\nstruct slirp_data *pri = data;\r\npri->dev = dev;\r\nreturn 0;\r\n}\r\nstatic void slirp_pre_exec(void *arg)\r\n{\r\nstruct slirp_pre_exec_data *data = arg;\r\nif (data->stdin_fd != -1)\r\ndup2(data->stdin_fd, 0);\r\nif (data->stdout_fd != -1)\r\ndup2(data->stdout_fd, 1);\r\n}\r\nstatic int slirp_tramp(char **argv, int fd)\r\n{\r\nstruct slirp_pre_exec_data pe_data;\r\nint pid;\r\npe_data.stdin_fd = fd;\r\npe_data.stdout_fd = fd;\r\npid = run_helper(slirp_pre_exec, &pe_data, argv);\r\nreturn pid;\r\n}\r\nstatic int slirp_open(void *data)\r\n{\r\nstruct slirp_data *pri = data;\r\nint fds[2], pid, err;\r\nerr = os_pipe(fds, 1, 1);\r\nif (err)\r\nreturn err;\r\nerr = slirp_tramp(pri->argw.argv, fds[1]);\r\nif (err < 0) {\r\nprintk(UM_KERN_ERR "slirp_tramp failed - errno = %d\n", -err);\r\ngoto out;\r\n}\r\npid = err;\r\npri->slave = fds[1];\r\npri->slip.pos = 0;\r\npri->slip.esc = 0;\r\npri->pid = err;\r\nreturn fds[0];\r\nout:\r\nclose(fds[0]);\r\nclose(fds[1]);\r\nreturn err;\r\n}\r\nstatic void slirp_close(int fd, void *data)\r\n{\r\nstruct slirp_data *pri = data;\r\nint err;\r\nclose(fd);\r\nclose(pri->slave);\r\npri->slave = -1;\r\nif (pri->pid<1) {\r\nprintk(UM_KERN_ERR "slirp_close: no child process to shut "\r\n"down\n");\r\nreturn;\r\n}\r\n#if 0\r\nif (kill(pri->pid, SIGHUP)<0) {\r\nprintk(UM_KERN_ERR "slirp_close: sending hangup to %d failed "\r\n"(%d)\n", pri->pid, errno);\r\n}\r\n#endif\r\nerr = helper_wait(pri->pid);\r\nif (err < 0)\r\nreturn;\r\npri->pid = -1;\r\n}\r\nint slirp_user_read(int fd, void *buf, int len, struct slirp_data *pri)\r\n{\r\nreturn slip_proto_read(fd, buf, len, &pri->slip);\r\n}\r\nint slirp_user_write(int fd, void *buf, int len, struct slirp_data *pri)\r\n{\r\nreturn slip_proto_write(fd, buf, len, &pri->slip);\r\n}
