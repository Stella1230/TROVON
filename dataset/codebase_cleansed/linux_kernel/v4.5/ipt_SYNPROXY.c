static struct iphdr *\r\nsynproxy_build_ip(struct sk_buff *skb, __be32 saddr, __be32 daddr)\r\n{\r\nstruct iphdr *iph;\r\nskb_reset_network_header(skb);\r\niph = (struct iphdr *)skb_put(skb, sizeof(*iph));\r\niph->version = 4;\r\niph->ihl = sizeof(*iph) / 4;\r\niph->tos = 0;\r\niph->id = 0;\r\niph->frag_off = htons(IP_DF);\r\niph->ttl = sysctl_ip_default_ttl;\r\niph->protocol = IPPROTO_TCP;\r\niph->check = 0;\r\niph->saddr = saddr;\r\niph->daddr = daddr;\r\nreturn iph;\r\n}\r\nstatic void\r\nsynproxy_send_tcp(const struct synproxy_net *snet,\r\nconst struct sk_buff *skb, struct sk_buff *nskb,\r\nstruct nf_conntrack *nfct, enum ip_conntrack_info ctinfo,\r\nstruct iphdr *niph, struct tcphdr *nth,\r\nunsigned int tcp_hdr_size)\r\n{\r\nstruct net *net = nf_ct_net(snet->tmpl);\r\nnth->check = ~tcp_v4_check(tcp_hdr_size, niph->saddr, niph->daddr, 0);\r\nnskb->ip_summed = CHECKSUM_PARTIAL;\r\nnskb->csum_start = (unsigned char *)nth - nskb->head;\r\nnskb->csum_offset = offsetof(struct tcphdr, check);\r\nskb_dst_set_noref(nskb, skb_dst(skb));\r\nnskb->protocol = htons(ETH_P_IP);\r\nif (ip_route_me_harder(net, nskb, RTN_UNSPEC))\r\ngoto free_nskb;\r\nif (nfct) {\r\nnskb->nfct = nfct;\r\nnskb->nfctinfo = ctinfo;\r\nnf_conntrack_get(nfct);\r\n}\r\nip_local_out(net, nskb->sk, nskb);\r\nreturn;\r\nfree_nskb:\r\nkfree_skb(nskb);\r\n}\r\nstatic void\r\nsynproxy_send_client_synack(const struct synproxy_net *snet,\r\nconst struct sk_buff *skb, const struct tcphdr *th,\r\nconst struct synproxy_options *opts)\r\n{\r\nstruct sk_buff *nskb;\r\nstruct iphdr *iph, *niph;\r\nstruct tcphdr *nth;\r\nunsigned int tcp_hdr_size;\r\nu16 mss = opts->mss;\r\niph = ip_hdr(skb);\r\ntcp_hdr_size = sizeof(*nth) + synproxy_options_size(opts);\r\nnskb = alloc_skb(sizeof(*niph) + tcp_hdr_size + MAX_TCP_HEADER,\r\nGFP_ATOMIC);\r\nif (nskb == NULL)\r\nreturn;\r\nskb_reserve(nskb, MAX_TCP_HEADER);\r\nniph = synproxy_build_ip(nskb, iph->daddr, iph->saddr);\r\nskb_reset_transport_header(nskb);\r\nnth = (struct tcphdr *)skb_put(nskb, tcp_hdr_size);\r\nnth->source = th->dest;\r\nnth->dest = th->source;\r\nnth->seq = htonl(__cookie_v4_init_sequence(iph, th, &mss));\r\nnth->ack_seq = htonl(ntohl(th->seq) + 1);\r\ntcp_flag_word(nth) = TCP_FLAG_SYN | TCP_FLAG_ACK;\r\nif (opts->options & XT_SYNPROXY_OPT_ECN)\r\ntcp_flag_word(nth) |= TCP_FLAG_ECE;\r\nnth->doff = tcp_hdr_size / 4;\r\nnth->window = 0;\r\nnth->check = 0;\r\nnth->urg_ptr = 0;\r\nsynproxy_build_options(nth, opts);\r\nsynproxy_send_tcp(snet, skb, nskb, skb->nfct, IP_CT_ESTABLISHED_REPLY,\r\nniph, nth, tcp_hdr_size);\r\n}\r\nstatic void\r\nsynproxy_send_server_syn(const struct synproxy_net *snet,\r\nconst struct sk_buff *skb, const struct tcphdr *th,\r\nconst struct synproxy_options *opts, u32 recv_seq)\r\n{\r\nstruct sk_buff *nskb;\r\nstruct iphdr *iph, *niph;\r\nstruct tcphdr *nth;\r\nunsigned int tcp_hdr_size;\r\niph = ip_hdr(skb);\r\ntcp_hdr_size = sizeof(*nth) + synproxy_options_size(opts);\r\nnskb = alloc_skb(sizeof(*niph) + tcp_hdr_size + MAX_TCP_HEADER,\r\nGFP_ATOMIC);\r\nif (nskb == NULL)\r\nreturn;\r\nskb_reserve(nskb, MAX_TCP_HEADER);\r\nniph = synproxy_build_ip(nskb, iph->saddr, iph->daddr);\r\nskb_reset_transport_header(nskb);\r\nnth = (struct tcphdr *)skb_put(nskb, tcp_hdr_size);\r\nnth->source = th->source;\r\nnth->dest = th->dest;\r\nnth->seq = htonl(recv_seq - 1);\r\nnth->ack_seq = htonl(ntohl(th->ack_seq) - 1);\r\ntcp_flag_word(nth) = TCP_FLAG_SYN;\r\nif (opts->options & XT_SYNPROXY_OPT_ECN)\r\ntcp_flag_word(nth) |= TCP_FLAG_ECE | TCP_FLAG_CWR;\r\nnth->doff = tcp_hdr_size / 4;\r\nnth->window = th->window;\r\nnth->check = 0;\r\nnth->urg_ptr = 0;\r\nsynproxy_build_options(nth, opts);\r\nsynproxy_send_tcp(snet, skb, nskb, &snet->tmpl->ct_general, IP_CT_NEW,\r\nniph, nth, tcp_hdr_size);\r\n}\r\nstatic void\r\nsynproxy_send_server_ack(const struct synproxy_net *snet,\r\nconst struct ip_ct_tcp *state,\r\nconst struct sk_buff *skb, const struct tcphdr *th,\r\nconst struct synproxy_options *opts)\r\n{\r\nstruct sk_buff *nskb;\r\nstruct iphdr *iph, *niph;\r\nstruct tcphdr *nth;\r\nunsigned int tcp_hdr_size;\r\niph = ip_hdr(skb);\r\ntcp_hdr_size = sizeof(*nth) + synproxy_options_size(opts);\r\nnskb = alloc_skb(sizeof(*niph) + tcp_hdr_size + MAX_TCP_HEADER,\r\nGFP_ATOMIC);\r\nif (nskb == NULL)\r\nreturn;\r\nskb_reserve(nskb, MAX_TCP_HEADER);\r\nniph = synproxy_build_ip(nskb, iph->daddr, iph->saddr);\r\nskb_reset_transport_header(nskb);\r\nnth = (struct tcphdr *)skb_put(nskb, tcp_hdr_size);\r\nnth->source = th->dest;\r\nnth->dest = th->source;\r\nnth->seq = htonl(ntohl(th->ack_seq));\r\nnth->ack_seq = htonl(ntohl(th->seq) + 1);\r\ntcp_flag_word(nth) = TCP_FLAG_ACK;\r\nnth->doff = tcp_hdr_size / 4;\r\nnth->window = htons(state->seen[IP_CT_DIR_ORIGINAL].td_maxwin);\r\nnth->check = 0;\r\nnth->urg_ptr = 0;\r\nsynproxy_build_options(nth, opts);\r\nsynproxy_send_tcp(snet, skb, nskb, NULL, 0, niph, nth, tcp_hdr_size);\r\n}\r\nstatic void\r\nsynproxy_send_client_ack(const struct synproxy_net *snet,\r\nconst struct sk_buff *skb, const struct tcphdr *th,\r\nconst struct synproxy_options *opts)\r\n{\r\nstruct sk_buff *nskb;\r\nstruct iphdr *iph, *niph;\r\nstruct tcphdr *nth;\r\nunsigned int tcp_hdr_size;\r\niph = ip_hdr(skb);\r\ntcp_hdr_size = sizeof(*nth) + synproxy_options_size(opts);\r\nnskb = alloc_skb(sizeof(*niph) + tcp_hdr_size + MAX_TCP_HEADER,\r\nGFP_ATOMIC);\r\nif (nskb == NULL)\r\nreturn;\r\nskb_reserve(nskb, MAX_TCP_HEADER);\r\nniph = synproxy_build_ip(nskb, iph->saddr, iph->daddr);\r\nskb_reset_transport_header(nskb);\r\nnth = (struct tcphdr *)skb_put(nskb, tcp_hdr_size);\r\nnth->source = th->source;\r\nnth->dest = th->dest;\r\nnth->seq = htonl(ntohl(th->seq) + 1);\r\nnth->ack_seq = th->ack_seq;\r\ntcp_flag_word(nth) = TCP_FLAG_ACK;\r\nnth->doff = tcp_hdr_size / 4;\r\nnth->window = htons(ntohs(th->window) >> opts->wscale);\r\nnth->check = 0;\r\nnth->urg_ptr = 0;\r\nsynproxy_build_options(nth, opts);\r\nsynproxy_send_tcp(snet, skb, nskb, skb->nfct, IP_CT_ESTABLISHED_REPLY,\r\nniph, nth, tcp_hdr_size);\r\n}\r\nstatic bool\r\nsynproxy_recv_client_ack(const struct synproxy_net *snet,\r\nconst struct sk_buff *skb, const struct tcphdr *th,\r\nstruct synproxy_options *opts, u32 recv_seq)\r\n{\r\nint mss;\r\nmss = __cookie_v4_check(ip_hdr(skb), th, ntohl(th->ack_seq) - 1);\r\nif (mss == 0) {\r\nthis_cpu_inc(snet->stats->cookie_invalid);\r\nreturn false;\r\n}\r\nthis_cpu_inc(snet->stats->cookie_valid);\r\nopts->mss = mss;\r\nopts->options |= XT_SYNPROXY_OPT_MSS;\r\nif (opts->options & XT_SYNPROXY_OPT_TIMESTAMP)\r\nsynproxy_check_timestamp_cookie(opts);\r\nsynproxy_send_server_syn(snet, skb, th, opts, recv_seq);\r\nreturn true;\r\n}\r\nstatic unsigned int\r\nsynproxy_tg4(struct sk_buff *skb, const struct xt_action_param *par)\r\n{\r\nconst struct xt_synproxy_info *info = par->targinfo;\r\nstruct synproxy_net *snet = synproxy_pernet(par->net);\r\nstruct synproxy_options opts = {};\r\nstruct tcphdr *th, _th;\r\nif (nf_ip_checksum(skb, par->hooknum, par->thoff, IPPROTO_TCP))\r\nreturn NF_DROP;\r\nth = skb_header_pointer(skb, par->thoff, sizeof(_th), &_th);\r\nif (th == NULL)\r\nreturn NF_DROP;\r\nif (!synproxy_parse_options(skb, par->thoff, th, &opts))\r\nreturn NF_DROP;\r\nif (th->syn && !(th->ack || th->fin || th->rst)) {\r\nthis_cpu_inc(snet->stats->syn_received);\r\nif (th->ece && th->cwr)\r\nopts.options |= XT_SYNPROXY_OPT_ECN;\r\nopts.options &= info->options;\r\nif (opts.options & XT_SYNPROXY_OPT_TIMESTAMP)\r\nsynproxy_init_timestamp_cookie(info, &opts);\r\nelse\r\nopts.options &= ~(XT_SYNPROXY_OPT_WSCALE |\r\nXT_SYNPROXY_OPT_SACK_PERM |\r\nXT_SYNPROXY_OPT_ECN);\r\nsynproxy_send_client_synack(snet, skb, th, &opts);\r\nreturn NF_DROP;\r\n} else if (th->ack && !(th->fin || th->rst || th->syn)) {\r\nsynproxy_recv_client_ack(snet, skb, th, &opts, ntohl(th->seq));\r\nreturn NF_DROP;\r\n}\r\nreturn XT_CONTINUE;\r\n}\r\nstatic unsigned int ipv4_synproxy_hook(void *priv,\r\nstruct sk_buff *skb,\r\nconst struct nf_hook_state *nhs)\r\n{\r\nstruct synproxy_net *snet = synproxy_pernet(nhs->net);\r\nenum ip_conntrack_info ctinfo;\r\nstruct nf_conn *ct;\r\nstruct nf_conn_synproxy *synproxy;\r\nstruct synproxy_options opts = {};\r\nconst struct ip_ct_tcp *state;\r\nstruct tcphdr *th, _th;\r\nunsigned int thoff;\r\nct = nf_ct_get(skb, &ctinfo);\r\nif (ct == NULL)\r\nreturn NF_ACCEPT;\r\nsynproxy = nfct_synproxy(ct);\r\nif (synproxy == NULL)\r\nreturn NF_ACCEPT;\r\nif (nf_is_loopback_packet(skb))\r\nreturn NF_ACCEPT;\r\nthoff = ip_hdrlen(skb);\r\nth = skb_header_pointer(skb, thoff, sizeof(_th), &_th);\r\nif (th == NULL)\r\nreturn NF_DROP;\r\nstate = &ct->proto.tcp;\r\nswitch (state->state) {\r\ncase TCP_CONNTRACK_CLOSE:\r\nif (th->rst && !test_bit(IPS_SEEN_REPLY_BIT, &ct->status)) {\r\nnf_ct_seqadj_init(ct, ctinfo, synproxy->isn -\r\nntohl(th->seq) + 1);\r\nbreak;\r\n}\r\nif (!th->syn || th->ack ||\r\nCTINFO2DIR(ctinfo) != IP_CT_DIR_ORIGINAL)\r\nbreak;\r\nnf_ct_seqadj_init(ct, ctinfo, 0);\r\nsynproxy->tsoff = 0;\r\nthis_cpu_inc(snet->stats->conn_reopened);\r\ncase TCP_CONNTRACK_SYN_SENT:\r\nif (!synproxy_parse_options(skb, thoff, th, &opts))\r\nreturn NF_DROP;\r\nif (!th->syn && th->ack &&\r\nCTINFO2DIR(ctinfo) == IP_CT_DIR_ORIGINAL) {\r\nif (synproxy_recv_client_ack(snet, skb, th, &opts,\r\nntohl(th->seq) + 1))\r\nthis_cpu_inc(snet->stats->cookie_retrans);\r\nreturn NF_DROP;\r\n}\r\nsynproxy->isn = ntohl(th->ack_seq);\r\nif (opts.options & XT_SYNPROXY_OPT_TIMESTAMP)\r\nsynproxy->its = opts.tsecr;\r\nbreak;\r\ncase TCP_CONNTRACK_SYN_RECV:\r\nif (!th->syn || !th->ack)\r\nbreak;\r\nif (!synproxy_parse_options(skb, thoff, th, &opts))\r\nreturn NF_DROP;\r\nif (opts.options & XT_SYNPROXY_OPT_TIMESTAMP)\r\nsynproxy->tsoff = opts.tsval - synproxy->its;\r\nopts.options &= ~(XT_SYNPROXY_OPT_MSS |\r\nXT_SYNPROXY_OPT_WSCALE |\r\nXT_SYNPROXY_OPT_SACK_PERM);\r\nswap(opts.tsval, opts.tsecr);\r\nsynproxy_send_server_ack(snet, state, skb, th, &opts);\r\nnf_ct_seqadj_init(ct, ctinfo, synproxy->isn - ntohl(th->seq));\r\nswap(opts.tsval, opts.tsecr);\r\nsynproxy_send_client_ack(snet, skb, th, &opts);\r\nconsume_skb(skb);\r\nreturn NF_STOLEN;\r\ndefault:\r\nbreak;\r\n}\r\nsynproxy_tstamp_adjust(skb, thoff, th, ct, ctinfo, synproxy);\r\nreturn NF_ACCEPT;\r\n}\r\nstatic int synproxy_tg4_check(const struct xt_tgchk_param *par)\r\n{\r\nconst struct ipt_entry *e = par->entryinfo;\r\nif (e->ip.proto != IPPROTO_TCP ||\r\ne->ip.invflags & XT_INV_PROTO)\r\nreturn -EINVAL;\r\nreturn nf_ct_l3proto_try_module_get(par->family);\r\n}\r\nstatic void synproxy_tg4_destroy(const struct xt_tgdtor_param *par)\r\n{\r\nnf_ct_l3proto_module_put(par->family);\r\n}\r\nstatic int __init synproxy_tg4_init(void)\r\n{\r\nint err;\r\nerr = nf_register_hooks(ipv4_synproxy_ops,\r\nARRAY_SIZE(ipv4_synproxy_ops));\r\nif (err < 0)\r\ngoto err1;\r\nerr = xt_register_target(&synproxy_tg4_reg);\r\nif (err < 0)\r\ngoto err2;\r\nreturn 0;\r\nerr2:\r\nnf_unregister_hooks(ipv4_synproxy_ops, ARRAY_SIZE(ipv4_synproxy_ops));\r\nerr1:\r\nreturn err;\r\n}\r\nstatic void __exit synproxy_tg4_exit(void)\r\n{\r\nxt_unregister_target(&synproxy_tg4_reg);\r\nnf_unregister_hooks(ipv4_synproxy_ops, ARRAY_SIZE(ipv4_synproxy_ops));\r\n}
