static inline int is_imx28_auart(struct mxs_auart_port *s)\r\n{\r\nreturn s->devtype == IMX28_AUART;\r\n}\r\nstatic inline bool auart_dma_enabled(struct mxs_auart_port *s)\r\n{\r\nreturn s->flags & MXS_AUART_DMA_ENABLED;\r\n}\r\nstatic void dma_tx_callback(void *param)\r\n{\r\nstruct mxs_auart_port *s = param;\r\nstruct circ_buf *xmit = &s->port.state->xmit;\r\ndma_unmap_sg(s->dev, &s->tx_sgl, 1, DMA_TO_DEVICE);\r\nclear_bit(MXS_AUART_DMA_TX_SYNC, &s->flags);\r\nsmp_mb__after_atomic();\r\nif (uart_circ_chars_pending(xmit) < WAKEUP_CHARS)\r\nuart_write_wakeup(&s->port);\r\nmxs_auart_tx_chars(s);\r\n}\r\nstatic int mxs_auart_dma_tx(struct mxs_auart_port *s, int size)\r\n{\r\nstruct dma_async_tx_descriptor *desc;\r\nstruct scatterlist *sgl = &s->tx_sgl;\r\nstruct dma_chan *channel = s->tx_dma_chan;\r\nu32 pio;\r\npio = AUART_CTRL1_XFER_COUNT(size);\r\ndesc = dmaengine_prep_slave_sg(channel, (struct scatterlist *)&pio,\r\n1, DMA_TRANS_NONE, 0);\r\nif (!desc) {\r\ndev_err(s->dev, "step 1 error\n");\r\nreturn -EINVAL;\r\n}\r\nsg_init_one(sgl, s->tx_dma_buf, size);\r\ndma_map_sg(s->dev, sgl, 1, DMA_TO_DEVICE);\r\ndesc = dmaengine_prep_slave_sg(channel, sgl,\r\n1, DMA_MEM_TO_DEV, DMA_PREP_INTERRUPT | DMA_CTRL_ACK);\r\nif (!desc) {\r\ndev_err(s->dev, "step 2 error\n");\r\nreturn -EINVAL;\r\n}\r\ndesc->callback = dma_tx_callback;\r\ndesc->callback_param = s;\r\ndmaengine_submit(desc);\r\ndma_async_issue_pending(channel);\r\nreturn 0;\r\n}\r\nstatic void mxs_auart_tx_chars(struct mxs_auart_port *s)\r\n{\r\nstruct circ_buf *xmit = &s->port.state->xmit;\r\nif (auart_dma_enabled(s)) {\r\nu32 i = 0;\r\nint size;\r\nvoid *buffer = s->tx_dma_buf;\r\nif (test_and_set_bit(MXS_AUART_DMA_TX_SYNC, &s->flags))\r\nreturn;\r\nwhile (!uart_circ_empty(xmit) && !uart_tx_stopped(&s->port)) {\r\nsize = min_t(u32, UART_XMIT_SIZE - i,\r\nCIRC_CNT_TO_END(xmit->head,\r\nxmit->tail,\r\nUART_XMIT_SIZE));\r\nmemcpy(buffer + i, xmit->buf + xmit->tail, size);\r\nxmit->tail = (xmit->tail + size) & (UART_XMIT_SIZE - 1);\r\ni += size;\r\nif (i >= UART_XMIT_SIZE)\r\nbreak;\r\n}\r\nif (uart_tx_stopped(&s->port))\r\nmxs_auart_stop_tx(&s->port);\r\nif (i) {\r\nmxs_auart_dma_tx(s, i);\r\n} else {\r\nclear_bit(MXS_AUART_DMA_TX_SYNC, &s->flags);\r\nsmp_mb__after_atomic();\r\n}\r\nreturn;\r\n}\r\nwhile (!(readl(s->port.membase + AUART_STAT) &\r\nAUART_STAT_TXFF)) {\r\nif (s->port.x_char) {\r\ns->port.icount.tx++;\r\nwritel(s->port.x_char,\r\ns->port.membase + AUART_DATA);\r\ns->port.x_char = 0;\r\ncontinue;\r\n}\r\nif (!uart_circ_empty(xmit) && !uart_tx_stopped(&s->port)) {\r\ns->port.icount.tx++;\r\nwritel(xmit->buf[xmit->tail],\r\ns->port.membase + AUART_DATA);\r\nxmit->tail = (xmit->tail + 1) & (UART_XMIT_SIZE - 1);\r\n} else\r\nbreak;\r\n}\r\nif (uart_circ_chars_pending(xmit) < WAKEUP_CHARS)\r\nuart_write_wakeup(&s->port);\r\nif (uart_circ_empty(&(s->port.state->xmit)))\r\nwritel(AUART_INTR_TXIEN,\r\ns->port.membase + AUART_INTR_CLR);\r\nelse\r\nwritel(AUART_INTR_TXIEN,\r\ns->port.membase + AUART_INTR_SET);\r\nif (uart_tx_stopped(&s->port))\r\nmxs_auart_stop_tx(&s->port);\r\n}\r\nstatic void mxs_auart_rx_char(struct mxs_auart_port *s)\r\n{\r\nint flag;\r\nu32 stat;\r\nu8 c;\r\nc = readl(s->port.membase + AUART_DATA);\r\nstat = readl(s->port.membase + AUART_STAT);\r\nflag = TTY_NORMAL;\r\ns->port.icount.rx++;\r\nif (stat & AUART_STAT_BERR) {\r\ns->port.icount.brk++;\r\nif (uart_handle_break(&s->port))\r\ngoto out;\r\n} else if (stat & AUART_STAT_PERR) {\r\ns->port.icount.parity++;\r\n} else if (stat & AUART_STAT_FERR) {\r\ns->port.icount.frame++;\r\n}\r\nstat &= s->port.read_status_mask;\r\nif (stat & AUART_STAT_BERR) {\r\nflag = TTY_BREAK;\r\n} else if (stat & AUART_STAT_PERR)\r\nflag = TTY_PARITY;\r\nelse if (stat & AUART_STAT_FERR)\r\nflag = TTY_FRAME;\r\nif (stat & AUART_STAT_OERR)\r\ns->port.icount.overrun++;\r\nif (uart_handle_sysrq_char(&s->port, c))\r\ngoto out;\r\nuart_insert_char(&s->port, stat, AUART_STAT_OERR, c, flag);\r\nout:\r\nwritel(stat, s->port.membase + AUART_STAT);\r\n}\r\nstatic void mxs_auart_rx_chars(struct mxs_auart_port *s)\r\n{\r\nu32 stat = 0;\r\nfor (;;) {\r\nstat = readl(s->port.membase + AUART_STAT);\r\nif (stat & AUART_STAT_RXFE)\r\nbreak;\r\nmxs_auart_rx_char(s);\r\n}\r\nwritel(stat, s->port.membase + AUART_STAT);\r\ntty_flip_buffer_push(&s->port.state->port);\r\n}\r\nstatic int mxs_auart_request_port(struct uart_port *u)\r\n{\r\nreturn 0;\r\n}\r\nstatic int mxs_auart_verify_port(struct uart_port *u,\r\nstruct serial_struct *ser)\r\n{\r\nif (u->type != PORT_UNKNOWN && u->type != PORT_IMX)\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\nstatic void mxs_auart_config_port(struct uart_port *u, int flags)\r\n{\r\n}\r\nstatic const char *mxs_auart_type(struct uart_port *u)\r\n{\r\nstruct mxs_auart_port *s = to_auart_port(u);\r\nreturn dev_name(s->dev);\r\n}\r\nstatic void mxs_auart_release_port(struct uart_port *u)\r\n{\r\n}\r\nstatic void mxs_auart_set_mctrl(struct uart_port *u, unsigned mctrl)\r\n{\r\nstruct mxs_auart_port *s = to_auart_port(u);\r\nu32 ctrl = readl(u->membase + AUART_CTRL2);\r\nctrl &= ~(AUART_CTRL2_RTSEN | AUART_CTRL2_RTS);\r\nif (mctrl & TIOCM_RTS) {\r\nif (uart_cts_enabled(u))\r\nctrl |= AUART_CTRL2_RTSEN;\r\nelse\r\nctrl |= AUART_CTRL2_RTS;\r\n}\r\nwritel(ctrl, u->membase + AUART_CTRL2);\r\nmctrl_gpio_set(s->gpios, mctrl);\r\n}\r\nstatic u32 mxs_auart_modem_status(struct mxs_auart_port *s, u32 mctrl)\r\n{\r\nu32 mctrl_diff;\r\nmctrl_diff = mctrl ^ s->mctrl_prev;\r\ns->mctrl_prev = mctrl;\r\nif (mctrl_diff & MCTRL_ANY_DELTA && s->ms_irq_enabled &&\r\ns->port.state != NULL) {\r\nif (mctrl_diff & TIOCM_RI)\r\ns->port.icount.rng++;\r\nif (mctrl_diff & TIOCM_DSR)\r\ns->port.icount.dsr++;\r\nif (mctrl_diff & TIOCM_CD)\r\nuart_handle_dcd_change(&s->port, mctrl & TIOCM_CD);\r\nif (mctrl_diff & TIOCM_CTS)\r\nuart_handle_cts_change(&s->port, mctrl & TIOCM_CTS);\r\nwake_up_interruptible(&s->port.state->port.delta_msr_wait);\r\n}\r\nreturn mctrl;\r\n}\r\nstatic u32 mxs_auart_get_mctrl(struct uart_port *u)\r\n{\r\nstruct mxs_auart_port *s = to_auart_port(u);\r\nu32 stat = readl(u->membase + AUART_STAT);\r\nu32 mctrl = 0;\r\nif (stat & AUART_STAT_CTS)\r\nmctrl |= TIOCM_CTS;\r\nreturn mctrl_gpio_get(s->gpios, &mctrl);\r\n}\r\nstatic void mxs_auart_enable_ms(struct uart_port *port)\r\n{\r\nstruct mxs_auart_port *s = to_auart_port(port);\r\nif (s->ms_irq_enabled)\r\nreturn;\r\ns->ms_irq_enabled = true;\r\nif (s->gpio_irq[UART_GPIO_CTS] >= 0)\r\nenable_irq(s->gpio_irq[UART_GPIO_CTS]);\r\nif (s->gpio_irq[UART_GPIO_DSR] >= 0)\r\nenable_irq(s->gpio_irq[UART_GPIO_DSR]);\r\nif (s->gpio_irq[UART_GPIO_RI] >= 0)\r\nenable_irq(s->gpio_irq[UART_GPIO_RI]);\r\nif (s->gpio_irq[UART_GPIO_DCD] >= 0)\r\nenable_irq(s->gpio_irq[UART_GPIO_DCD]);\r\n}\r\nstatic void mxs_auart_disable_ms(struct uart_port *port)\r\n{\r\nstruct mxs_auart_port *s = to_auart_port(port);\r\nif (!s->ms_irq_enabled)\r\nreturn;\r\ns->ms_irq_enabled = false;\r\nif (s->gpio_irq[UART_GPIO_CTS] >= 0)\r\ndisable_irq(s->gpio_irq[UART_GPIO_CTS]);\r\nif (s->gpio_irq[UART_GPIO_DSR] >= 0)\r\ndisable_irq(s->gpio_irq[UART_GPIO_DSR]);\r\nif (s->gpio_irq[UART_GPIO_RI] >= 0)\r\ndisable_irq(s->gpio_irq[UART_GPIO_RI]);\r\nif (s->gpio_irq[UART_GPIO_DCD] >= 0)\r\ndisable_irq(s->gpio_irq[UART_GPIO_DCD]);\r\n}\r\nstatic void dma_rx_callback(void *arg)\r\n{\r\nstruct mxs_auart_port *s = (struct mxs_auart_port *) arg;\r\nstruct tty_port *port = &s->port.state->port;\r\nint count;\r\nu32 stat;\r\ndma_unmap_sg(s->dev, &s->rx_sgl, 1, DMA_FROM_DEVICE);\r\nstat = readl(s->port.membase + AUART_STAT);\r\nstat &= ~(AUART_STAT_OERR | AUART_STAT_BERR |\r\nAUART_STAT_PERR | AUART_STAT_FERR);\r\ncount = stat & AUART_STAT_RXCOUNT_MASK;\r\ntty_insert_flip_string(port, s->rx_dma_buf, count);\r\nwritel(stat, s->port.membase + AUART_STAT);\r\ntty_flip_buffer_push(port);\r\nmxs_auart_dma_prep_rx(s);\r\n}\r\nstatic int mxs_auart_dma_prep_rx(struct mxs_auart_port *s)\r\n{\r\nstruct dma_async_tx_descriptor *desc;\r\nstruct scatterlist *sgl = &s->rx_sgl;\r\nstruct dma_chan *channel = s->rx_dma_chan;\r\nu32 pio[1];\r\npio[0] = AUART_CTRL0_RXTO_ENABLE\r\n| AUART_CTRL0_RXTIMEOUT(0x80)\r\n| AUART_CTRL0_XFER_COUNT(UART_XMIT_SIZE);\r\ndesc = dmaengine_prep_slave_sg(channel, (struct scatterlist *)pio,\r\n1, DMA_TRANS_NONE, 0);\r\nif (!desc) {\r\ndev_err(s->dev, "step 1 error\n");\r\nreturn -EINVAL;\r\n}\r\nsg_init_one(sgl, s->rx_dma_buf, UART_XMIT_SIZE);\r\ndma_map_sg(s->dev, sgl, 1, DMA_FROM_DEVICE);\r\ndesc = dmaengine_prep_slave_sg(channel, sgl, 1, DMA_DEV_TO_MEM,\r\nDMA_PREP_INTERRUPT | DMA_CTRL_ACK);\r\nif (!desc) {\r\ndev_err(s->dev, "step 2 error\n");\r\nreturn -1;\r\n}\r\ndesc->callback = dma_rx_callback;\r\ndesc->callback_param = s;\r\ndmaengine_submit(desc);\r\ndma_async_issue_pending(channel);\r\nreturn 0;\r\n}\r\nstatic void mxs_auart_dma_exit_channel(struct mxs_auart_port *s)\r\n{\r\nif (s->tx_dma_chan) {\r\ndma_release_channel(s->tx_dma_chan);\r\ns->tx_dma_chan = NULL;\r\n}\r\nif (s->rx_dma_chan) {\r\ndma_release_channel(s->rx_dma_chan);\r\ns->rx_dma_chan = NULL;\r\n}\r\nkfree(s->tx_dma_buf);\r\nkfree(s->rx_dma_buf);\r\ns->tx_dma_buf = NULL;\r\ns->rx_dma_buf = NULL;\r\n}\r\nstatic void mxs_auart_dma_exit(struct mxs_auart_port *s)\r\n{\r\nwritel(AUART_CTRL2_TXDMAE | AUART_CTRL2_RXDMAE | AUART_CTRL2_DMAONERR,\r\ns->port.membase + AUART_CTRL2_CLR);\r\nmxs_auart_dma_exit_channel(s);\r\ns->flags &= ~MXS_AUART_DMA_ENABLED;\r\nclear_bit(MXS_AUART_DMA_TX_SYNC, &s->flags);\r\nclear_bit(MXS_AUART_DMA_RX_READY, &s->flags);\r\n}\r\nstatic int mxs_auart_dma_init(struct mxs_auart_port *s)\r\n{\r\nif (auart_dma_enabled(s))\r\nreturn 0;\r\ns->rx_dma_chan = dma_request_slave_channel(s->dev, "rx");\r\nif (!s->rx_dma_chan)\r\ngoto err_out;\r\ns->rx_dma_buf = kzalloc(UART_XMIT_SIZE, GFP_KERNEL | GFP_DMA);\r\nif (!s->rx_dma_buf)\r\ngoto err_out;\r\ns->tx_dma_chan = dma_request_slave_channel(s->dev, "tx");\r\nif (!s->tx_dma_chan)\r\ngoto err_out;\r\ns->tx_dma_buf = kzalloc(UART_XMIT_SIZE, GFP_KERNEL | GFP_DMA);\r\nif (!s->tx_dma_buf)\r\ngoto err_out;\r\ns->flags |= MXS_AUART_DMA_ENABLED;\r\ndev_dbg(s->dev, "enabled the DMA support.");\r\ns->port.fifosize = UART_XMIT_SIZE;\r\nreturn 0;\r\nerr_out:\r\nmxs_auart_dma_exit_channel(s);\r\nreturn -EINVAL;\r\n}\r\nstatic void mxs_auart_settermios(struct uart_port *u,\r\nstruct ktermios *termios,\r\nstruct ktermios *old)\r\n{\r\nstruct mxs_auart_port *s = to_auart_port(u);\r\nu32 bm, ctrl, ctrl2, div;\r\nunsigned int cflag, baud, baud_min, baud_max;\r\ncflag = termios->c_cflag;\r\nctrl = AUART_LINECTRL_FEN;\r\nctrl2 = readl(u->membase + AUART_CTRL2);\r\nswitch (cflag & CSIZE) {\r\ncase CS5:\r\nbm = 0;\r\nbreak;\r\ncase CS6:\r\nbm = 1;\r\nbreak;\r\ncase CS7:\r\nbm = 2;\r\nbreak;\r\ncase CS8:\r\nbm = 3;\r\nbreak;\r\ndefault:\r\nreturn;\r\n}\r\nctrl |= AUART_LINECTRL_WLEN(bm);\r\nif (cflag & PARENB) {\r\nctrl |= AUART_LINECTRL_PEN;\r\nif ((cflag & PARODD) == 0)\r\nctrl |= AUART_LINECTRL_EPS;\r\n}\r\nu->read_status_mask = 0;\r\nif (termios->c_iflag & INPCK)\r\nu->read_status_mask |= AUART_STAT_PERR;\r\nif (termios->c_iflag & (IGNBRK | BRKINT | PARMRK))\r\nu->read_status_mask |= AUART_STAT_BERR;\r\nu->ignore_status_mask = 0;\r\nif (termios->c_iflag & IGNPAR)\r\nu->ignore_status_mask |= AUART_STAT_PERR;\r\nif (termios->c_iflag & IGNBRK) {\r\nu->ignore_status_mask |= AUART_STAT_BERR;\r\nif (termios->c_iflag & IGNPAR)\r\nu->ignore_status_mask |= AUART_STAT_OERR;\r\n}\r\nif (cflag & CREAD)\r\nctrl2 |= AUART_CTRL2_RXE;\r\nelse\r\nctrl2 &= ~AUART_CTRL2_RXE;\r\nif (cflag & CSTOPB)\r\nctrl |= AUART_LINECTRL_STP2;\r\nctrl2 &= ~(AUART_CTRL2_CTSEN | AUART_CTRL2_RTSEN);\r\nif (cflag & CRTSCTS) {\r\nif (is_imx28_auart(s)\r\n&& test_bit(MXS_AUART_RTSCTS, &s->flags)) {\r\nif (!mxs_auart_dma_init(s))\r\nctrl2 |= AUART_CTRL2_TXDMAE | AUART_CTRL2_RXDMAE\r\n| AUART_CTRL2_DMAONERR;\r\n}\r\nctrl2 |= AUART_CTRL2_RTSEN;\r\nif (CTS_AT_AUART())\r\nctrl2 |= AUART_CTRL2_CTSEN;\r\n}\r\nbaud_min = DIV_ROUND_UP(u->uartclk * 32, AUART_LINECTRL_BAUD_DIV_MAX);\r\nbaud_max = u->uartclk * 32 / AUART_LINECTRL_BAUD_DIV_MIN;\r\nbaud = uart_get_baud_rate(u, termios, old, baud_min, baud_max);\r\ndiv = u->uartclk * 32 / baud;\r\nctrl |= AUART_LINECTRL_BAUD_DIVFRAC(div & 0x3F);\r\nctrl |= AUART_LINECTRL_BAUD_DIVINT(div >> 6);\r\nwritel(ctrl, u->membase + AUART_LINECTRL);\r\nwritel(ctrl2, u->membase + AUART_CTRL2);\r\nuart_update_timeout(u, termios->c_cflag, baud);\r\nif (auart_dma_enabled(s) &&\r\n!test_and_set_bit(MXS_AUART_DMA_RX_READY, &s->flags)) {\r\nif (!mxs_auart_dma_prep_rx(s)) {\r\nwritel(AUART_INTR_RXIEN | AUART_INTR_RTIEN,\r\nu->membase + AUART_INTR_CLR);\r\n} else {\r\nmxs_auart_dma_exit(s);\r\ndev_err(s->dev, "We can not start up the DMA.\n");\r\n}\r\n}\r\nif (UART_ENABLE_MS(u, termios->c_cflag))\r\nmxs_auart_enable_ms(u);\r\nelse\r\nmxs_auart_disable_ms(u);\r\n}\r\nstatic void mxs_auart_set_ldisc(struct uart_port *port,\r\nstruct ktermios *termios)\r\n{\r\nif (termios->c_line == N_PPS) {\r\nport->flags |= UPF_HARDPPS_CD;\r\nmxs_auart_enable_ms(port);\r\n} else {\r\nport->flags &= ~UPF_HARDPPS_CD;\r\n}\r\n}\r\nstatic irqreturn_t mxs_auart_irq_handle(int irq, void *context)\r\n{\r\nu32 istat;\r\nstruct mxs_auart_port *s = context;\r\nu32 mctrl_temp = s->mctrl_prev;\r\nu32 stat = readl(s->port.membase + AUART_STAT);\r\nistat = readl(s->port.membase + AUART_INTR);\r\nwritel(istat & (AUART_INTR_RTIS\r\n| AUART_INTR_TXIS\r\n| AUART_INTR_RXIS\r\n| AUART_INTR_CTSMIS),\r\ns->port.membase + AUART_INTR_CLR);\r\nif (irq == s->gpio_irq[UART_GPIO_CTS] ||\r\nirq == s->gpio_irq[UART_GPIO_DCD] ||\r\nirq == s->gpio_irq[UART_GPIO_DSR] ||\r\nirq == s->gpio_irq[UART_GPIO_RI])\r\nmxs_auart_modem_status(s,\r\nmctrl_gpio_get(s->gpios, &mctrl_temp));\r\nif (istat & AUART_INTR_CTSMIS) {\r\nif (CTS_AT_AUART() && s->ms_irq_enabled)\r\nuart_handle_cts_change(&s->port,\r\nstat & AUART_STAT_CTS);\r\nwritel(AUART_INTR_CTSMIS,\r\ns->port.membase + AUART_INTR_CLR);\r\nistat &= ~AUART_INTR_CTSMIS;\r\n}\r\nif (istat & (AUART_INTR_RTIS | AUART_INTR_RXIS)) {\r\nif (!auart_dma_enabled(s))\r\nmxs_auart_rx_chars(s);\r\nistat &= ~(AUART_INTR_RTIS | AUART_INTR_RXIS);\r\n}\r\nif (istat & AUART_INTR_TXIS) {\r\nmxs_auart_tx_chars(s);\r\nistat &= ~AUART_INTR_TXIS;\r\n}\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void mxs_auart_reset_deassert(struct uart_port *u)\r\n{\r\nint i;\r\nunsigned int reg;\r\nwritel(AUART_CTRL0_SFTRST, u->membase + AUART_CTRL0_CLR);\r\nfor (i = 0; i < 10000; i++) {\r\nreg = readl(u->membase + AUART_CTRL0);\r\nif (!(reg & AUART_CTRL0_SFTRST))\r\nbreak;\r\nudelay(3);\r\n}\r\nwritel(AUART_CTRL0_CLKGATE, u->membase + AUART_CTRL0_CLR);\r\n}\r\nstatic void mxs_auart_reset_assert(struct uart_port *u)\r\n{\r\nint i;\r\nu32 reg;\r\nreg = readl(u->membase + AUART_CTRL0);\r\nif (reg & AUART_CTRL0_SFTRST)\r\nreturn;\r\nwritel(AUART_CTRL0_CLKGATE, u->membase + AUART_CTRL0_CLR);\r\nwritel(AUART_CTRL0_SFTRST, u->membase + AUART_CTRL0_SET);\r\nfor (i = 0; i < 1000; i++) {\r\nreg = readl(u->membase + AUART_CTRL0);\r\nif (reg & AUART_CTRL0_CLKGATE)\r\nreturn;\r\nudelay(10);\r\n}\r\ndev_err(u->dev, "Failed to reset the unit.");\r\n}\r\nstatic int mxs_auart_startup(struct uart_port *u)\r\n{\r\nint ret;\r\nstruct mxs_auart_port *s = to_auart_port(u);\r\nret = clk_prepare_enable(s->clk);\r\nif (ret)\r\nreturn ret;\r\nif (uart_console(u)) {\r\nwritel(AUART_CTRL0_CLKGATE, u->membase + AUART_CTRL0_CLR);\r\n} else {\r\nmxs_auart_reset_assert(u);\r\nmxs_auart_reset_deassert(u);\r\n}\r\nwritel(AUART_CTRL2_UARTEN, u->membase + AUART_CTRL2_SET);\r\nwritel(AUART_INTR_RXIEN | AUART_INTR_RTIEN | AUART_INTR_CTSMIEN,\r\nu->membase + AUART_INTR);\r\nu->fifosize = MXS_AUART_FIFO_SIZE;\r\nwritel(AUART_LINECTRL_FEN, u->membase + AUART_LINECTRL_SET);\r\nmctrl_gpio_get(s->gpios, &s->mctrl_prev);\r\ns->ms_irq_enabled = false;\r\nreturn 0;\r\n}\r\nstatic void mxs_auart_shutdown(struct uart_port *u)\r\n{\r\nstruct mxs_auart_port *s = to_auart_port(u);\r\nmxs_auart_disable_ms(u);\r\nif (auart_dma_enabled(s))\r\nmxs_auart_dma_exit(s);\r\nif (uart_console(u)) {\r\nwritel(AUART_CTRL2_UARTEN, u->membase + AUART_CTRL2_CLR);\r\nwritel(AUART_INTR_RXIEN | AUART_INTR_RTIEN | AUART_INTR_CTSMIEN,\r\nu->membase + AUART_INTR_CLR);\r\nwritel(AUART_CTRL0_CLKGATE, u->membase + AUART_CTRL0_SET);\r\n} else {\r\nmxs_auart_reset_assert(u);\r\n}\r\nclk_disable_unprepare(s->clk);\r\n}\r\nstatic unsigned int mxs_auart_tx_empty(struct uart_port *u)\r\n{\r\nif ((readl(u->membase + AUART_STAT) &\r\n(AUART_STAT_TXFE | AUART_STAT_BUSY)) == AUART_STAT_TXFE)\r\nreturn TIOCSER_TEMT;\r\nreturn 0;\r\n}\r\nstatic void mxs_auart_start_tx(struct uart_port *u)\r\n{\r\nstruct mxs_auart_port *s = to_auart_port(u);\r\nwritel(AUART_CTRL2_TXE, u->membase + AUART_CTRL2_SET);\r\nmxs_auart_tx_chars(s);\r\n}\r\nstatic void mxs_auart_stop_tx(struct uart_port *u)\r\n{\r\nwritel(AUART_CTRL2_TXE, u->membase + AUART_CTRL2_CLR);\r\n}\r\nstatic void mxs_auart_stop_rx(struct uart_port *u)\r\n{\r\nwritel(AUART_CTRL2_RXE, u->membase + AUART_CTRL2_CLR);\r\n}\r\nstatic void mxs_auart_break_ctl(struct uart_port *u, int ctl)\r\n{\r\nif (ctl)\r\nwritel(AUART_LINECTRL_BRK,\r\nu->membase + AUART_LINECTRL_SET);\r\nelse\r\nwritel(AUART_LINECTRL_BRK,\r\nu->membase + AUART_LINECTRL_CLR);\r\n}\r\nstatic void mxs_auart_console_putchar(struct uart_port *port, int ch)\r\n{\r\nunsigned int to = 1000;\r\nwhile (readl(port->membase + AUART_STAT) & AUART_STAT_TXFF) {\r\nif (!to--)\r\nbreak;\r\nudelay(1);\r\n}\r\nwritel(ch, port->membase + AUART_DATA);\r\n}\r\nstatic void\r\nauart_console_write(struct console *co, const char *str, unsigned int count)\r\n{\r\nstruct mxs_auart_port *s;\r\nstruct uart_port *port;\r\nunsigned int old_ctrl0, old_ctrl2;\r\nunsigned int to = 20000;\r\nif (co->index >= MXS_AUART_PORTS || co->index < 0)\r\nreturn;\r\ns = auart_port[co->index];\r\nport = &s->port;\r\nclk_enable(s->clk);\r\nold_ctrl2 = readl(port->membase + AUART_CTRL2);\r\nold_ctrl0 = readl(port->membase + AUART_CTRL0);\r\nwritel(AUART_CTRL0_CLKGATE,\r\nport->membase + AUART_CTRL0_CLR);\r\nwritel(AUART_CTRL2_UARTEN | AUART_CTRL2_TXE,\r\nport->membase + AUART_CTRL2_SET);\r\nuart_console_write(port, str, count, mxs_auart_console_putchar);\r\nwhile (readl(port->membase + AUART_STAT) & AUART_STAT_BUSY) {\r\nudelay(1);\r\nif (!to--)\r\nbreak;\r\n}\r\nif (!(readl(port->membase + AUART_STAT) & AUART_STAT_BUSY)) {\r\nwritel(old_ctrl0, port->membase + AUART_CTRL0);\r\nwritel(old_ctrl2, port->membase + AUART_CTRL2);\r\n}\r\nclk_disable(s->clk);\r\n}\r\nstatic void __init\r\nauart_console_get_options(struct uart_port *port, int *baud,\r\nint *parity, int *bits)\r\n{\r\nunsigned int lcr_h, quot;\r\nif (!(readl(port->membase + AUART_CTRL2) & AUART_CTRL2_UARTEN))\r\nreturn;\r\nlcr_h = readl(port->membase + AUART_LINECTRL);\r\n*parity = 'n';\r\nif (lcr_h & AUART_LINECTRL_PEN) {\r\nif (lcr_h & AUART_LINECTRL_EPS)\r\n*parity = 'e';\r\nelse\r\n*parity = 'o';\r\n}\r\nif ((lcr_h & AUART_LINECTRL_WLEN_MASK) == AUART_LINECTRL_WLEN(2))\r\n*bits = 7;\r\nelse\r\n*bits = 8;\r\nquot = ((readl(port->membase + AUART_LINECTRL)\r\n& AUART_LINECTRL_BAUD_DIVINT_MASK))\r\n>> (AUART_LINECTRL_BAUD_DIVINT_SHIFT - 6);\r\nquot |= ((readl(port->membase + AUART_LINECTRL)\r\n& AUART_LINECTRL_BAUD_DIVFRAC_MASK))\r\n>> AUART_LINECTRL_BAUD_DIVFRAC_SHIFT;\r\nif (quot == 0)\r\nquot = 1;\r\n*baud = (port->uartclk << 2) / quot;\r\n}\r\nstatic int __init\r\nauart_console_setup(struct console *co, char *options)\r\n{\r\nstruct mxs_auart_port *s;\r\nint baud = 9600;\r\nint bits = 8;\r\nint parity = 'n';\r\nint flow = 'n';\r\nint ret;\r\nif (co->index == -1 || co->index >= ARRAY_SIZE(auart_port))\r\nco->index = 0;\r\ns = auart_port[co->index];\r\nif (!s)\r\nreturn -ENODEV;\r\nret = clk_prepare_enable(s->clk);\r\nif (ret)\r\nreturn ret;\r\nif (options)\r\nuart_parse_options(options, &baud, &parity, &bits, &flow);\r\nelse\r\nauart_console_get_options(&s->port, &baud, &parity, &bits);\r\nret = uart_set_options(&s->port, co, baud, parity, bits, flow);\r\nclk_disable_unprepare(s->clk);\r\nreturn ret;\r\n}\r\nstatic int serial_mxs_probe_dt(struct mxs_auart_port *s,\r\nstruct platform_device *pdev)\r\n{\r\nstruct device_node *np = pdev->dev.of_node;\r\nint ret;\r\nif (!np)\r\nreturn 1;\r\nret = of_alias_get_id(np, "serial");\r\nif (ret < 0) {\r\ndev_err(&pdev->dev, "failed to get alias id: %d\n", ret);\r\nreturn ret;\r\n}\r\ns->port.line = ret;\r\nif (of_get_property(np, "fsl,uart-has-rtscts", NULL))\r\nset_bit(MXS_AUART_RTSCTS, &s->flags);\r\nreturn 0;\r\n}\r\nstatic int mxs_auart_init_gpios(struct mxs_auart_port *s, struct device *dev)\r\n{\r\nenum mctrl_gpio_idx i;\r\nstruct gpio_desc *gpiod;\r\ns->gpios = mctrl_gpio_init_noauto(dev, 0);\r\nif (IS_ERR(s->gpios))\r\nreturn PTR_ERR(s->gpios);\r\nif (!RTS_AT_AUART() || !CTS_AT_AUART()) {\r\nif (test_bit(MXS_AUART_RTSCTS, &s->flags))\r\ndev_warn(dev,\r\n"DMA and flow control via gpio may cause some problems. DMA disabled!\n");\r\nclear_bit(MXS_AUART_RTSCTS, &s->flags);\r\n}\r\nfor (i = 0; i < UART_GPIO_MAX; i++) {\r\ngpiod = mctrl_gpio_to_gpiod(s->gpios, i);\r\nif (gpiod && (gpiod_get_direction(gpiod) == GPIOF_DIR_IN))\r\ns->gpio_irq[i] = gpiod_to_irq(gpiod);\r\nelse\r\ns->gpio_irq[i] = -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic void mxs_auart_free_gpio_irq(struct mxs_auart_port *s)\r\n{\r\nenum mctrl_gpio_idx i;\r\nfor (i = 0; i < UART_GPIO_MAX; i++)\r\nif (s->gpio_irq[i] >= 0)\r\nfree_irq(s->gpio_irq[i], s);\r\n}\r\nstatic int mxs_auart_request_gpio_irq(struct mxs_auart_port *s)\r\n{\r\nint *irq = s->gpio_irq;\r\nenum mctrl_gpio_idx i;\r\nint err = 0;\r\nfor (i = 0; (i < UART_GPIO_MAX) && !err; i++) {\r\nif (irq[i] < 0)\r\ncontinue;\r\nirq_set_status_flags(irq[i], IRQ_NOAUTOEN);\r\nerr = request_irq(irq[i], mxs_auart_irq_handle,\r\nIRQ_TYPE_EDGE_BOTH, dev_name(s->dev), s);\r\nif (err)\r\ndev_err(s->dev, "%s - Can't get %d irq\n",\r\n__func__, irq[i]);\r\n}\r\nwhile (err && (--i >= 0))\r\nif (irq[i] >= 0)\r\nfree_irq(irq[i], s);\r\nreturn err;\r\n}\r\nstatic int mxs_auart_probe(struct platform_device *pdev)\r\n{\r\nconst struct of_device_id *of_id =\r\nof_match_device(mxs_auart_dt_ids, &pdev->dev);\r\nstruct mxs_auart_port *s;\r\nu32 version;\r\nint ret, irq;\r\nstruct resource *r;\r\ns = devm_kzalloc(&pdev->dev, sizeof(*s), GFP_KERNEL);\r\nif (!s)\r\nreturn -ENOMEM;\r\nret = serial_mxs_probe_dt(s, pdev);\r\nif (ret > 0)\r\ns->port.line = pdev->id < 0 ? 0 : pdev->id;\r\nelse if (ret < 0)\r\nreturn ret;\r\nif (of_id) {\r\npdev->id_entry = of_id->data;\r\ns->devtype = pdev->id_entry->driver_data;\r\n}\r\ns->clk = devm_clk_get(&pdev->dev, NULL);\r\nif (IS_ERR(s->clk))\r\nreturn PTR_ERR(s->clk);\r\nr = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nif (!r)\r\nreturn -ENXIO;\r\ns->port.mapbase = r->start;\r\ns->port.membase = ioremap(r->start, resource_size(r));\r\ns->port.ops = &mxs_auart_ops;\r\ns->port.iotype = UPIO_MEM;\r\ns->port.fifosize = MXS_AUART_FIFO_SIZE;\r\ns->port.uartclk = clk_get_rate(s->clk);\r\ns->port.type = PORT_IMX;\r\ns->port.dev = s->dev = &pdev->dev;\r\ns->mctrl_prev = 0;\r\nirq = platform_get_irq(pdev, 0);\r\nif (irq < 0)\r\nreturn irq;\r\ns->port.irq = irq;\r\nret = devm_request_irq(&pdev->dev, irq, mxs_auart_irq_handle, 0,\r\ndev_name(&pdev->dev), s);\r\nif (ret)\r\nreturn ret;\r\nplatform_set_drvdata(pdev, s);\r\nret = mxs_auart_init_gpios(s, &pdev->dev);\r\nif (ret) {\r\ndev_err(&pdev->dev, "Failed to initialize GPIOs.\n");\r\nreturn ret;\r\n}\r\nret = mxs_auart_request_gpio_irq(s);\r\nif (ret)\r\nreturn ret;\r\nauart_port[s->port.line] = s;\r\nmxs_auart_reset_deassert(&s->port);\r\nret = uart_add_one_port(&auart_driver, &s->port);\r\nif (ret)\r\ngoto out_free_gpio_irq;\r\nversion = readl(s->port.membase + AUART_VERSION);\r\ndev_info(&pdev->dev, "Found APPUART %d.%d.%d\n",\r\n(version >> 24) & 0xff,\r\n(version >> 16) & 0xff, version & 0xffff);\r\nreturn 0;\r\nout_free_gpio_irq:\r\nmxs_auart_free_gpio_irq(s);\r\nauart_port[pdev->id] = NULL;\r\nreturn ret;\r\n}\r\nstatic int mxs_auart_remove(struct platform_device *pdev)\r\n{\r\nstruct mxs_auart_port *s = platform_get_drvdata(pdev);\r\nuart_remove_one_port(&auart_driver, &s->port);\r\nauart_port[pdev->id] = NULL;\r\nmxs_auart_free_gpio_irq(s);\r\nreturn 0;\r\n}\r\nstatic int __init mxs_auart_init(void)\r\n{\r\nint r;\r\nr = uart_register_driver(&auart_driver);\r\nif (r)\r\ngoto out;\r\nr = platform_driver_register(&mxs_auart_driver);\r\nif (r)\r\ngoto out_err;\r\nreturn 0;\r\nout_err:\r\nuart_unregister_driver(&auart_driver);\r\nout:\r\nreturn r;\r\n}\r\nstatic void __exit mxs_auart_exit(void)\r\n{\r\nplatform_driver_unregister(&mxs_auart_driver);\r\nuart_unregister_driver(&auart_driver);\r\n}
