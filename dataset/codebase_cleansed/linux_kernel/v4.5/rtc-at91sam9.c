static inline unsigned int gpbr_readl(struct sam9_rtc *rtc)\r\n{\r\nunsigned int val;\r\nregmap_read(rtc->gpbr, rtc->gpbr_offset, &val);\r\nreturn val;\r\n}\r\nstatic inline void gpbr_writel(struct sam9_rtc *rtc, unsigned int val)\r\n{\r\nregmap_write(rtc->gpbr, rtc->gpbr_offset, val);\r\n}\r\nstatic int at91_rtc_readtime(struct device *dev, struct rtc_time *tm)\r\n{\r\nstruct sam9_rtc *rtc = dev_get_drvdata(dev);\r\nu32 secs, secs2;\r\nu32 offset;\r\noffset = gpbr_readl(rtc);\r\nif (offset == 0)\r\nreturn -EILSEQ;\r\nsecs = rtt_readl(rtc, VR);\r\nsecs2 = rtt_readl(rtc, VR);\r\nif (secs != secs2)\r\nsecs = rtt_readl(rtc, VR);\r\nrtc_time_to_tm(offset + secs, tm);\r\ndev_dbg(dev, "%s: %4d-%02d-%02d %02d:%02d:%02d\n", "readtime",\r\n1900 + tm->tm_year, tm->tm_mon, tm->tm_mday,\r\ntm->tm_hour, tm->tm_min, tm->tm_sec);\r\nreturn 0;\r\n}\r\nstatic int at91_rtc_settime(struct device *dev, struct rtc_time *tm)\r\n{\r\nstruct sam9_rtc *rtc = dev_get_drvdata(dev);\r\nint err;\r\nu32 offset, alarm, mr;\r\nunsigned long secs;\r\ndev_dbg(dev, "%s: %4d-%02d-%02d %02d:%02d:%02d\n", "settime",\r\n1900 + tm->tm_year, tm->tm_mon, tm->tm_mday,\r\ntm->tm_hour, tm->tm_min, tm->tm_sec);\r\nerr = rtc_tm_to_time(tm, &secs);\r\nif (err != 0)\r\nreturn err;\r\nmr = rtt_readl(rtc, MR);\r\nrtt_writel(rtc, MR, mr & ~(AT91_RTT_ALMIEN | AT91_RTT_RTTINCIEN));\r\noffset = gpbr_readl(rtc);\r\nsecs += 1;\r\ngpbr_writel(rtc, secs);\r\nalarm = rtt_readl(rtc, AR);\r\nif (alarm != ALARM_DISABLED) {\r\nif (offset > secs) {\r\nalarm += (offset - secs);\r\n} else if ((alarm + offset) > secs) {\r\nalarm -= (secs - offset);\r\n} else {\r\nalarm = ALARM_DISABLED;\r\nmr &= ~AT91_RTT_ALMIEN;\r\n}\r\nrtt_writel(rtc, AR, alarm);\r\n}\r\nrtt_writel(rtc, MR, mr | AT91_RTT_RTTRST);\r\nreturn 0;\r\n}\r\nstatic int at91_rtc_readalarm(struct device *dev, struct rtc_wkalrm *alrm)\r\n{\r\nstruct sam9_rtc *rtc = dev_get_drvdata(dev);\r\nstruct rtc_time *tm = &alrm->time;\r\nu32 alarm = rtt_readl(rtc, AR);\r\nu32 offset;\r\noffset = gpbr_readl(rtc);\r\nif (offset == 0)\r\nreturn -EILSEQ;\r\nmemset(alrm, 0, sizeof(*alrm));\r\nif (alarm != ALARM_DISABLED && offset != 0) {\r\nrtc_time_to_tm(offset + alarm, tm);\r\ndev_dbg(dev, "%s: %4d-%02d-%02d %02d:%02d:%02d\n", "readalarm",\r\n1900 + tm->tm_year, tm->tm_mon, tm->tm_mday,\r\ntm->tm_hour, tm->tm_min, tm->tm_sec);\r\nif (rtt_readl(rtc, MR) & AT91_RTT_ALMIEN)\r\nalrm->enabled = 1;\r\n}\r\nreturn 0;\r\n}\r\nstatic int at91_rtc_setalarm(struct device *dev, struct rtc_wkalrm *alrm)\r\n{\r\nstruct sam9_rtc *rtc = dev_get_drvdata(dev);\r\nstruct rtc_time *tm = &alrm->time;\r\nunsigned long secs;\r\nu32 offset;\r\nu32 mr;\r\nint err;\r\nerr = rtc_tm_to_time(tm, &secs);\r\nif (err != 0)\r\nreturn err;\r\noffset = gpbr_readl(rtc);\r\nif (offset == 0) {\r\nreturn -EILSEQ;\r\n}\r\nmr = rtt_readl(rtc, MR);\r\nrtt_writel(rtc, MR, mr & ~AT91_RTT_ALMIEN);\r\nif (secs <= offset) {\r\nrtt_writel(rtc, AR, ALARM_DISABLED);\r\nreturn 0;\r\n}\r\nrtt_writel(rtc, AR, secs - offset);\r\nif (alrm->enabled)\r\nrtt_writel(rtc, MR, mr | AT91_RTT_ALMIEN);\r\ndev_dbg(dev, "%s: %4d-%02d-%02d %02d:%02d:%02d\n", "setalarm",\r\ntm->tm_year, tm->tm_mon, tm->tm_mday, tm->tm_hour,\r\ntm->tm_min, tm->tm_sec);\r\nreturn 0;\r\n}\r\nstatic int at91_rtc_alarm_irq_enable(struct device *dev, unsigned int enabled)\r\n{\r\nstruct sam9_rtc *rtc = dev_get_drvdata(dev);\r\nu32 mr = rtt_readl(rtc, MR);\r\ndev_dbg(dev, "alarm_irq_enable: enabled=%08x, mr %08x\n", enabled, mr);\r\nif (enabled)\r\nrtt_writel(rtc, MR, mr | AT91_RTT_ALMIEN);\r\nelse\r\nrtt_writel(rtc, MR, mr & ~AT91_RTT_ALMIEN);\r\nreturn 0;\r\n}\r\nstatic int at91_rtc_proc(struct device *dev, struct seq_file *seq)\r\n{\r\nstruct sam9_rtc *rtc = dev_get_drvdata(dev);\r\nu32 mr = mr = rtt_readl(rtc, MR);\r\nseq_printf(seq, "update_IRQ\t: %s\n",\r\n(mr & AT91_RTT_RTTINCIEN) ? "yes" : "no");\r\nreturn 0;\r\n}\r\nstatic irqreturn_t at91_rtc_cache_events(struct sam9_rtc *rtc)\r\n{\r\nu32 sr, mr;\r\nmr = rtt_readl(rtc, MR) & (AT91_RTT_ALMIEN | AT91_RTT_RTTINCIEN);\r\nsr = rtt_readl(rtc, SR) & (mr >> 16);\r\nif (!sr)\r\nreturn IRQ_NONE;\r\nif (sr & AT91_RTT_ALMS)\r\nrtc->events |= (RTC_AF | RTC_IRQF);\r\nif (sr & AT91_RTT_RTTINC)\r\nrtc->events |= (RTC_UF | RTC_IRQF);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void at91_rtc_flush_events(struct sam9_rtc *rtc)\r\n{\r\nif (!rtc->events)\r\nreturn;\r\nrtc_update_irq(rtc->rtcdev, 1, rtc->events);\r\nrtc->events = 0;\r\npr_debug("%s: num=%ld, events=0x%02lx\n", __func__,\r\nrtc->events >> 8, rtc->events & 0x000000FF);\r\n}\r\nstatic irqreturn_t at91_rtc_interrupt(int irq, void *_rtc)\r\n{\r\nstruct sam9_rtc *rtc = _rtc;\r\nint ret;\r\nspin_lock(&rtc->lock);\r\nret = at91_rtc_cache_events(rtc);\r\nif (rtc->suspended) {\r\nrtt_writel(rtc, MR,\r\nrtt_readl(rtc, MR) &\r\n~(AT91_RTT_ALMIEN | AT91_RTT_RTTINCIEN));\r\npm_system_wakeup();\r\n} else {\r\nat91_rtc_flush_events(rtc);\r\n}\r\nspin_unlock(&rtc->lock);\r\nreturn ret;\r\n}\r\nstatic int at91_rtc_probe(struct platform_device *pdev)\r\n{\r\nstruct resource *r;\r\nstruct sam9_rtc *rtc;\r\nint ret, irq;\r\nu32 mr;\r\nunsigned int sclk_rate;\r\nirq = platform_get_irq(pdev, 0);\r\nif (irq < 0) {\r\ndev_err(&pdev->dev, "failed to get interrupt resource\n");\r\nreturn irq;\r\n}\r\nrtc = devm_kzalloc(&pdev->dev, sizeof(*rtc), GFP_KERNEL);\r\nif (!rtc)\r\nreturn -ENOMEM;\r\nrtc->irq = irq;\r\nif (!device_can_wakeup(&pdev->dev))\r\ndevice_init_wakeup(&pdev->dev, 1);\r\nplatform_set_drvdata(pdev, rtc);\r\nr = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nrtc->rtt = devm_ioremap_resource(&pdev->dev, r);\r\nif (IS_ERR(rtc->rtt))\r\nreturn PTR_ERR(rtc->rtt);\r\nif (!pdev->dev.of_node) {\r\nvoid __iomem *gpbr;\r\nr = platform_get_resource(pdev, IORESOURCE_MEM, 1);\r\ngpbr = devm_ioremap_resource(&pdev->dev, r);\r\nif (IS_ERR(gpbr))\r\nreturn PTR_ERR(gpbr);\r\nrtc->gpbr = regmap_init_mmio(NULL, gpbr,\r\n&gpbr_regmap_config);\r\n} else {\r\nstruct of_phandle_args args;\r\nret = of_parse_phandle_with_fixed_args(pdev->dev.of_node,\r\n"atmel,rtt-rtc-time-reg", 1, 0,\r\n&args);\r\nif (ret)\r\nreturn ret;\r\nrtc->gpbr = syscon_node_to_regmap(args.np);\r\nrtc->gpbr_offset = args.args[0];\r\n}\r\nif (IS_ERR(rtc->gpbr)) {\r\ndev_err(&pdev->dev, "failed to retrieve gpbr regmap, aborting.\n");\r\nreturn -ENOMEM;\r\n}\r\nrtc->sclk = devm_clk_get(&pdev->dev, NULL);\r\nif (IS_ERR(rtc->sclk))\r\nreturn PTR_ERR(rtc->sclk);\r\nret = clk_prepare_enable(rtc->sclk);\r\nif (ret) {\r\ndev_err(&pdev->dev, "Could not enable slow clock\n");\r\nreturn ret;\r\n}\r\nsclk_rate = clk_get_rate(rtc->sclk);\r\nif (!sclk_rate || sclk_rate > AT91_RTT_RTPRES) {\r\ndev_err(&pdev->dev, "Invalid slow clock rate\n");\r\nret = -EINVAL;\r\ngoto err_clk;\r\n}\r\nmr = rtt_readl(rtc, MR);\r\nif ((mr & AT91_RTT_RTPRES) != sclk_rate) {\r\nmr = AT91_RTT_RTTRST | (sclk_rate & AT91_RTT_RTPRES);\r\ngpbr_writel(rtc, 0);\r\n}\r\nmr &= ~(AT91_RTT_ALMIEN | AT91_RTT_RTTINCIEN);\r\nrtt_writel(rtc, MR, mr);\r\nrtc->rtcdev = devm_rtc_device_register(&pdev->dev, pdev->name,\r\n&at91_rtc_ops, THIS_MODULE);\r\nif (IS_ERR(rtc->rtcdev)) {\r\nret = PTR_ERR(rtc->rtcdev);\r\ngoto err_clk;\r\n}\r\nret = devm_request_irq(&pdev->dev, rtc->irq, at91_rtc_interrupt,\r\nIRQF_SHARED | IRQF_COND_SUSPEND,\r\ndev_name(&rtc->rtcdev->dev), rtc);\r\nif (ret) {\r\ndev_dbg(&pdev->dev, "can't share IRQ %d?\n", rtc->irq);\r\ngoto err_clk;\r\n}\r\nif (gpbr_readl(rtc) == 0)\r\ndev_warn(&pdev->dev, "%s: SET TIME!\n",\r\ndev_name(&rtc->rtcdev->dev));\r\nreturn 0;\r\nerr_clk:\r\nclk_disable_unprepare(rtc->sclk);\r\nreturn ret;\r\n}\r\nstatic int at91_rtc_remove(struct platform_device *pdev)\r\n{\r\nstruct sam9_rtc *rtc = platform_get_drvdata(pdev);\r\nu32 mr = rtt_readl(rtc, MR);\r\nrtt_writel(rtc, MR, mr & ~(AT91_RTT_ALMIEN | AT91_RTT_RTTINCIEN));\r\nclk_disable_unprepare(rtc->sclk);\r\nreturn 0;\r\n}\r\nstatic void at91_rtc_shutdown(struct platform_device *pdev)\r\n{\r\nstruct sam9_rtc *rtc = platform_get_drvdata(pdev);\r\nu32 mr = rtt_readl(rtc, MR);\r\nrtc->imr = mr & (AT91_RTT_ALMIEN | AT91_RTT_RTTINCIEN);\r\nrtt_writel(rtc, MR, mr & ~rtc->imr);\r\n}\r\nstatic int at91_rtc_suspend(struct device *dev)\r\n{\r\nstruct sam9_rtc *rtc = dev_get_drvdata(dev);\r\nu32 mr = rtt_readl(rtc, MR);\r\nrtc->imr = mr & (AT91_RTT_ALMIEN | AT91_RTT_RTTINCIEN);\r\nif (rtc->imr) {\r\nif (device_may_wakeup(dev) && (mr & AT91_RTT_ALMIEN)) {\r\nunsigned long flags;\r\nenable_irq_wake(rtc->irq);\r\nspin_lock_irqsave(&rtc->lock, flags);\r\nrtc->suspended = true;\r\nspin_unlock_irqrestore(&rtc->lock, flags);\r\nif (mr & AT91_RTT_RTTINCIEN)\r\nrtt_writel(rtc, MR, mr & ~AT91_RTT_RTTINCIEN);\r\n} else\r\nrtt_writel(rtc, MR, mr & ~rtc->imr);\r\n}\r\nreturn 0;\r\n}\r\nstatic int at91_rtc_resume(struct device *dev)\r\n{\r\nstruct sam9_rtc *rtc = dev_get_drvdata(dev);\r\nu32 mr;\r\nif (rtc->imr) {\r\nunsigned long flags;\r\nif (device_may_wakeup(dev))\r\ndisable_irq_wake(rtc->irq);\r\nmr = rtt_readl(rtc, MR);\r\nrtt_writel(rtc, MR, mr | rtc->imr);\r\nspin_lock_irqsave(&rtc->lock, flags);\r\nrtc->suspended = false;\r\nat91_rtc_cache_events(rtc);\r\nat91_rtc_flush_events(rtc);\r\nspin_unlock_irqrestore(&rtc->lock, flags);\r\n}\r\nreturn 0;\r\n}
