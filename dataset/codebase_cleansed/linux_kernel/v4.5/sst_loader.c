void memcpy32_toio(void __iomem *dst, const void *src, int count)\r\n{\r\n__iowrite32_copy(dst, src, count/4);\r\n}\r\nvoid memcpy32_fromio(void *dst, const void __iomem *src, int count)\r\n{\r\n__iowrite32_copy(dst, src, count/4);\r\n}\r\nint intel_sst_reset_dsp_mrfld(struct intel_sst_drv *sst_drv_ctx)\r\n{\r\nunion config_status_reg_mrfld csr;\r\ndev_dbg(sst_drv_ctx->dev, "sst: Resetting the DSP in mrfld\n");\r\ncsr.full = sst_shim_read64(sst_drv_ctx->shim, SST_CSR);\r\ndev_dbg(sst_drv_ctx->dev, "value:0x%llx\n", csr.full);\r\ncsr.full |= 0x7;\r\nsst_shim_write64(sst_drv_ctx->shim, SST_CSR, csr.full);\r\ncsr.full = sst_shim_read64(sst_drv_ctx->shim, SST_CSR);\r\ndev_dbg(sst_drv_ctx->dev, "value:0x%llx\n", csr.full);\r\ncsr.full &= ~(0x1);\r\nsst_shim_write64(sst_drv_ctx->shim, SST_CSR, csr.full);\r\ncsr.full = sst_shim_read64(sst_drv_ctx->shim, SST_CSR);\r\ndev_dbg(sst_drv_ctx->dev, "value:0x%llx\n", csr.full);\r\nreturn 0;\r\n}\r\nint sst_start_mrfld(struct intel_sst_drv *sst_drv_ctx)\r\n{\r\nunion config_status_reg_mrfld csr;\r\ndev_dbg(sst_drv_ctx->dev, "sst: Starting the DSP in mrfld LALALALA\n");\r\ncsr.full = sst_shim_read64(sst_drv_ctx->shim, SST_CSR);\r\ndev_dbg(sst_drv_ctx->dev, "value:0x%llx\n", csr.full);\r\ncsr.full |= 0x7;\r\nsst_shim_write64(sst_drv_ctx->shim, SST_CSR, csr.full);\r\ncsr.full = sst_shim_read64(sst_drv_ctx->shim, SST_CSR);\r\ndev_dbg(sst_drv_ctx->dev, "value:0x%llx\n", csr.full);\r\ncsr.part.xt_snoop = 1;\r\ncsr.full &= ~(0x5);\r\nsst_shim_write64(sst_drv_ctx->shim, SST_CSR, csr.full);\r\ncsr.full = sst_shim_read64(sst_drv_ctx->shim, SST_CSR);\r\ndev_dbg(sst_drv_ctx->dev, "sst: Starting the DSP_merrifield:%llx\n",\r\ncsr.full);\r\nreturn 0;\r\n}\r\nstatic int sst_validate_fw_image(struct intel_sst_drv *ctx, unsigned long size,\r\nstruct fw_module_header **module, u32 *num_modules)\r\n{\r\nstruct sst_fw_header *header;\r\nconst void *sst_fw_in_mem = ctx->fw_in_mem;\r\ndev_dbg(ctx->dev, "Enter\n");\r\nheader = (struct sst_fw_header *)sst_fw_in_mem;\r\ndev_dbg(ctx->dev,\r\n"header sign=%s size=%x modules=%x fmt=%x size=%zx\n",\r\nheader->signature, header->file_size, header->modules,\r\nheader->file_format, sizeof(*header));\r\nif ((strncmp(header->signature, SST_FW_SIGN, 4) != 0) ||\r\n(size != header->file_size + sizeof(*header))) {\r\ndev_err(ctx->dev, "InvalidFW sign/filesize mismatch\n");\r\nreturn -EINVAL;\r\n}\r\n*num_modules = header->modules;\r\n*module = (void *)sst_fw_in_mem + sizeof(*header);\r\nreturn 0;\r\n}\r\nstatic int sst_fill_memcpy_list(struct list_head *memcpy_list,\r\nvoid *destn, const void *src, u32 size, bool is_io)\r\n{\r\nstruct sst_memcpy_list *listnode;\r\nlistnode = kzalloc(sizeof(*listnode), GFP_KERNEL);\r\nif (listnode == NULL)\r\nreturn -ENOMEM;\r\nlistnode->dstn = destn;\r\nlistnode->src = src;\r\nlistnode->size = size;\r\nlistnode->is_io = is_io;\r\nlist_add_tail(&listnode->memcpylist, memcpy_list);\r\nreturn 0;\r\n}\r\nstatic int sst_parse_module_memcpy(struct intel_sst_drv *sst_drv_ctx,\r\nstruct fw_module_header *module, struct list_head *memcpy_list)\r\n{\r\nstruct fw_block_info *block;\r\nu32 count;\r\nint ret_val = 0;\r\nvoid __iomem *ram_iomem;\r\ndev_dbg(sst_drv_ctx->dev, "module sign %s size %x blocks %x type %x\n",\r\nmodule->signature, module->mod_size,\r\nmodule->blocks, module->type);\r\ndev_dbg(sst_drv_ctx->dev, "module entrypoint 0x%x\n", module->entry_point);\r\nblock = (void *)module + sizeof(*module);\r\nfor (count = 0; count < module->blocks; count++) {\r\nif (block->size <= 0) {\r\ndev_err(sst_drv_ctx->dev, "block size invalid\n");\r\nreturn -EINVAL;\r\n}\r\nswitch (block->type) {\r\ncase SST_IRAM:\r\nram_iomem = sst_drv_ctx->iram;\r\nbreak;\r\ncase SST_DRAM:\r\nram_iomem = sst_drv_ctx->dram;\r\nbreak;\r\ncase SST_DDR:\r\nram_iomem = sst_drv_ctx->ddr;\r\nbreak;\r\ncase SST_CUSTOM_INFO:\r\nblock = (void *)block + sizeof(*block) + block->size;\r\ncontinue;\r\ndefault:\r\ndev_err(sst_drv_ctx->dev, "wrong ram type0x%x in block0x%x\n",\r\nblock->type, count);\r\nreturn -EINVAL;\r\n}\r\nret_val = sst_fill_memcpy_list(memcpy_list,\r\nram_iomem + block->ram_offset,\r\n(void *)block + sizeof(*block), block->size, 1);\r\nif (ret_val)\r\nreturn ret_val;\r\nblock = (void *)block + sizeof(*block) + block->size;\r\n}\r\nreturn 0;\r\n}\r\nstatic int sst_parse_fw_memcpy(struct intel_sst_drv *ctx, unsigned long size,\r\nstruct list_head *fw_list)\r\n{\r\nstruct fw_module_header *module;\r\nu32 count, num_modules;\r\nint ret_val;\r\nret_val = sst_validate_fw_image(ctx, size, &module, &num_modules);\r\nif (ret_val)\r\nreturn ret_val;\r\nfor (count = 0; count < num_modules; count++) {\r\nret_val = sst_parse_module_memcpy(ctx, module, fw_list);\r\nif (ret_val)\r\nreturn ret_val;\r\nmodule = (void *)module + sizeof(*module) + module->mod_size;\r\n}\r\nreturn 0;\r\n}\r\nstatic void sst_do_memcpy(struct list_head *memcpy_list)\r\n{\r\nstruct sst_memcpy_list *listnode;\r\nlist_for_each_entry(listnode, memcpy_list, memcpylist) {\r\nif (listnode->is_io == true)\r\nmemcpy32_toio((void __iomem *)listnode->dstn,\r\nlistnode->src, listnode->size);\r\nelse\r\nmemcpy(listnode->dstn, listnode->src, listnode->size);\r\n}\r\n}\r\nvoid sst_memcpy_free_resources(struct intel_sst_drv *sst_drv_ctx)\r\n{\r\nstruct sst_memcpy_list *listnode, *tmplistnode;\r\nif (!list_empty(&sst_drv_ctx->memcpy_list)) {\r\nlist_for_each_entry_safe(listnode, tmplistnode,\r\n&sst_drv_ctx->memcpy_list, memcpylist) {\r\nlist_del(&listnode->memcpylist);\r\nkfree(listnode);\r\n}\r\n}\r\n}\r\nstatic int sst_cache_and_parse_fw(struct intel_sst_drv *sst,\r\nconst struct firmware *fw)\r\n{\r\nint retval = 0;\r\nsst->fw_in_mem = kzalloc(fw->size, GFP_KERNEL);\r\nif (!sst->fw_in_mem) {\r\nretval = -ENOMEM;\r\ngoto end_release;\r\n}\r\ndev_dbg(sst->dev, "copied fw to %p", sst->fw_in_mem);\r\ndev_dbg(sst->dev, "phys: %lx", (unsigned long)virt_to_phys(sst->fw_in_mem));\r\nmemcpy(sst->fw_in_mem, fw->data, fw->size);\r\nretval = sst_parse_fw_memcpy(sst, fw->size, &sst->memcpy_list);\r\nif (retval) {\r\ndev_err(sst->dev, "Failed to parse fw\n");\r\nkfree(sst->fw_in_mem);\r\nsst->fw_in_mem = NULL;\r\n}\r\nend_release:\r\nrelease_firmware(fw);\r\nreturn retval;\r\n}\r\nvoid sst_firmware_load_cb(const struct firmware *fw, void *context)\r\n{\r\nstruct intel_sst_drv *ctx = context;\r\ndev_dbg(ctx->dev, "Enter\n");\r\nif (fw == NULL) {\r\ndev_err(ctx->dev, "request fw failed\n");\r\nreturn;\r\n}\r\nmutex_lock(&ctx->sst_lock);\r\nif (ctx->sst_state != SST_RESET ||\r\nctx->fw_in_mem != NULL) {\r\nrelease_firmware(fw);\r\nmutex_unlock(&ctx->sst_lock);\r\nreturn;\r\n}\r\ndev_dbg(ctx->dev, "Request Fw completed\n");\r\nsst_cache_and_parse_fw(ctx, fw);\r\nmutex_unlock(&ctx->sst_lock);\r\n}\r\nstatic int sst_request_fw(struct intel_sst_drv *sst)\r\n{\r\nint retval = 0;\r\nconst struct firmware *fw;\r\nretval = request_firmware(&fw, sst->firmware_name, sst->dev);\r\nif (fw == NULL) {\r\ndev_err(sst->dev, "fw is returning as null\n");\r\nreturn -EINVAL;\r\n}\r\nif (retval) {\r\ndev_err(sst->dev, "request fw failed %d\n", retval);\r\nreturn retval;\r\n}\r\nmutex_lock(&sst->sst_lock);\r\nretval = sst_cache_and_parse_fw(sst, fw);\r\nmutex_unlock(&sst->sst_lock);\r\nreturn retval;\r\n}\r\nstatic void sst_dccm_config_write(void __iomem *dram_base,\r\nunsigned int ddr_base)\r\n{\r\nvoid __iomem *addr;\r\nu32 bss_reset = 0;\r\naddr = (void __iomem *)(dram_base + MRFLD_FW_DDR_BASE_OFFSET);\r\nmemcpy32_toio(addr, (void *)&ddr_base, sizeof(u32));\r\nbss_reset |= (1 << MRFLD_FW_BSS_RESET_BIT);\r\naddr = (void __iomem *)(dram_base + MRFLD_FW_FEATURE_BASE_OFFSET);\r\nmemcpy32_toio(addr, &bss_reset, sizeof(u32));\r\n}\r\nvoid sst_post_download_mrfld(struct intel_sst_drv *ctx)\r\n{\r\nsst_dccm_config_write(ctx->dram, ctx->ddr_base);\r\ndev_dbg(ctx->dev, "config written to DCCM\n");\r\n}\r\nint sst_load_fw(struct intel_sst_drv *sst_drv_ctx)\r\n{\r\nint ret_val = 0;\r\nstruct sst_block *block;\r\ndev_dbg(sst_drv_ctx->dev, "sst_load_fw\n");\r\nif (sst_drv_ctx->sst_state != SST_RESET ||\r\nsst_drv_ctx->sst_state == SST_SHUTDOWN)\r\nreturn -EAGAIN;\r\nif (!sst_drv_ctx->fw_in_mem) {\r\ndev_dbg(sst_drv_ctx->dev, "sst: FW not in memory retry to download\n");\r\nret_val = sst_request_fw(sst_drv_ctx);\r\nif (ret_val)\r\nreturn ret_val;\r\n}\r\nBUG_ON(!sst_drv_ctx->fw_in_mem);\r\nblock = sst_create_block(sst_drv_ctx, 0, FW_DWNL_ID);\r\nif (block == NULL)\r\nreturn -ENOMEM;\r\npm_qos_update_request(sst_drv_ctx->qos, 0);\r\nsst_drv_ctx->sst_state = SST_FW_LOADING;\r\nret_val = sst_drv_ctx->ops->reset(sst_drv_ctx);\r\nif (ret_val)\r\ngoto restore;\r\nsst_do_memcpy(&sst_drv_ctx->memcpy_list);\r\nif (sst_drv_ctx->ops->post_download)\r\nsst_drv_ctx->ops->post_download(sst_drv_ctx);\r\nret_val = sst_drv_ctx->ops->start(sst_drv_ctx);\r\nif (ret_val)\r\ngoto restore;\r\nret_val = sst_wait_timeout(sst_drv_ctx, block);\r\nif (ret_val) {\r\ndev_err(sst_drv_ctx->dev, "fw download failed %d\n" , ret_val);\r\nret_val = -EBUSY;\r\n}\r\nrestore:\r\npm_qos_update_request(sst_drv_ctx->qos, PM_QOS_DEFAULT_VALUE);\r\nsst_free_block(sst_drv_ctx, block);\r\ndev_dbg(sst_drv_ctx->dev, "fw load successful!!!\n");\r\nif (sst_drv_ctx->ops->restore_dsp_context)\r\nsst_drv_ctx->ops->restore_dsp_context();\r\nsst_drv_ctx->sst_state = SST_FW_RUNNING;\r\nreturn ret_val;\r\n}
