static int hi6421_regulator_enable(struct regulator_dev *rdev)\r\n{\r\nstruct hi6421_regulator_pdata *pdata;\r\npdata = dev_get_drvdata(rdev->dev.parent);\r\nmutex_lock(&pdata->lock);\r\nregulator_enable_regmap(rdev);\r\nmutex_unlock(&pdata->lock);\r\nreturn 0;\r\n}\r\nstatic unsigned int hi6421_regulator_ldo_get_mode(struct regulator_dev *rdev)\r\n{\r\nstruct hi6421_regulator_info *info = rdev_get_drvdata(rdev);\r\nu32 reg_val;\r\nregmap_read(rdev->regmap, rdev->desc->enable_reg, &reg_val);\r\nif (reg_val & info->mode_mask)\r\nreturn REGULATOR_MODE_IDLE;\r\nreturn REGULATOR_MODE_NORMAL;\r\n}\r\nstatic unsigned int hi6421_regulator_buck_get_mode(struct regulator_dev *rdev)\r\n{\r\nstruct hi6421_regulator_info *info = rdev_get_drvdata(rdev);\r\nu32 reg_val;\r\nregmap_read(rdev->regmap, rdev->desc->enable_reg, &reg_val);\r\nif (reg_val & info->mode_mask)\r\nreturn REGULATOR_MODE_STANDBY;\r\nreturn REGULATOR_MODE_NORMAL;\r\n}\r\nstatic int hi6421_regulator_ldo_set_mode(struct regulator_dev *rdev,\r\nunsigned int mode)\r\n{\r\nstruct hi6421_regulator_info *info = rdev_get_drvdata(rdev);\r\nu32 new_mode;\r\nswitch (mode) {\r\ncase REGULATOR_MODE_NORMAL:\r\nnew_mode = 0;\r\nbreak;\r\ncase REGULATOR_MODE_IDLE:\r\nnew_mode = info->mode_mask;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nregmap_update_bits(rdev->regmap, rdev->desc->enable_reg,\r\ninfo->mode_mask, new_mode);\r\nreturn 0;\r\n}\r\nstatic int hi6421_regulator_buck_set_mode(struct regulator_dev *rdev,\r\nunsigned int mode)\r\n{\r\nstruct hi6421_regulator_info *info = rdev_get_drvdata(rdev);\r\nu32 new_mode;\r\nswitch (mode) {\r\ncase REGULATOR_MODE_NORMAL:\r\nnew_mode = 0;\r\nbreak;\r\ncase REGULATOR_MODE_STANDBY:\r\nnew_mode = info->mode_mask;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nregmap_update_bits(rdev->regmap, rdev->desc->enable_reg,\r\ninfo->mode_mask, new_mode);\r\nreturn 0;\r\n}\r\nunsigned int hi6421_regulator_ldo_get_optimum_mode(struct regulator_dev *rdev,\r\nint input_uV, int output_uV, int load_uA)\r\n{\r\nstruct hi6421_regulator_info *info = rdev_get_drvdata(rdev);\r\nif (load_uA > info->eco_microamp)\r\nreturn REGULATOR_MODE_NORMAL;\r\nreturn REGULATOR_MODE_IDLE;\r\n}\r\nstatic int hi6421_regulator_register(struct platform_device *pdev,\r\nstruct regmap *rmap,\r\nstruct regulator_init_data *init_data,\r\nint id, struct device_node *np)\r\n{\r\nstruct hi6421_regulator_info *info = NULL;\r\nstruct regulator_config config = { };\r\nstruct regulator_dev *rdev;\r\ninfo = &hi6421_regulator_info[id];\r\nconfig.dev = &pdev->dev;\r\nconfig.init_data = init_data;\r\nconfig.driver_data = info;\r\nconfig.regmap = rmap;\r\nconfig.of_node = np;\r\nrdev = devm_regulator_register(&pdev->dev, &info->desc, &config);\r\nif (IS_ERR(rdev)) {\r\ndev_err(&pdev->dev, "failed to register regulator %s\n",\r\ninfo->desc.name);\r\nreturn PTR_ERR(rdev);\r\n}\r\nreturn 0;\r\n}\r\nstatic int hi6421_regulator_probe(struct platform_device *pdev)\r\n{\r\nstruct device *dev = &pdev->dev;\r\nstruct device_node *np;\r\nstruct hi6421_pmic *pmic;\r\nstruct hi6421_regulator_pdata *pdata;\r\nint i, ret = 0;\r\npdata = devm_kzalloc(&pdev->dev, sizeof(*pdata), GFP_KERNEL);\r\nif (!pdata)\r\nreturn -ENOMEM;\r\nmutex_init(&pdata->lock);\r\nplatform_set_drvdata(pdev, pdata);\r\nnp = of_get_child_by_name(dev->parent->of_node, "regulators");\r\nif (!np)\r\nreturn -ENODEV;\r\nret = of_regulator_match(dev, np,\r\nhi6421_regulator_match,\r\nARRAY_SIZE(hi6421_regulator_match));\r\nof_node_put(np);\r\nif (ret < 0) {\r\ndev_err(dev, "Error parsing regulator init data: %d\n", ret);\r\nreturn ret;\r\n}\r\npmic = dev_get_drvdata(dev->parent);\r\nfor (i = 0; i < ARRAY_SIZE(hi6421_regulator_info); i++) {\r\nret = hi6421_regulator_register(pdev, pmic->regmap,\r\nhi6421_regulator_match[i].init_data, i,\r\nhi6421_regulator_match[i].of_node);\r\nif (ret)\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}
