static void\r\nsctp_unique_tuple(const struct nf_nat_l3proto *l3proto,\r\nstruct nf_conntrack_tuple *tuple,\r\nconst struct nf_nat_range *range,\r\nenum nf_nat_manip_type maniptype,\r\nconst struct nf_conn *ct)\r\n{\r\nnf_nat_l4proto_unique_tuple(l3proto, tuple, range, maniptype, ct,\r\n&nf_sctp_port_rover);\r\n}\r\nstatic bool\r\nsctp_manip_pkt(struct sk_buff *skb,\r\nconst struct nf_nat_l3proto *l3proto,\r\nunsigned int iphdroff, unsigned int hdroff,\r\nconst struct nf_conntrack_tuple *tuple,\r\nenum nf_nat_manip_type maniptype)\r\n{\r\nsctp_sctphdr_t *hdr;\r\nif (!skb_make_writable(skb, hdroff + sizeof(*hdr)))\r\nreturn false;\r\nhdr = (struct sctphdr *)(skb->data + hdroff);\r\nif (maniptype == NF_NAT_MANIP_SRC) {\r\nhdr->source = tuple->src.u.sctp.port;\r\n} else {\r\nhdr->dest = tuple->dst.u.sctp.port;\r\n}\r\nhdr->checksum = sctp_compute_cksum(skb, hdroff);\r\nreturn true;\r\n}\r\nstatic int __init nf_nat_proto_sctp_init(void)\r\n{\r\nint err;\r\nerr = nf_nat_l4proto_register(NFPROTO_IPV4, &nf_nat_l4proto_sctp);\r\nif (err < 0)\r\ngoto err1;\r\nerr = nf_nat_l4proto_register(NFPROTO_IPV6, &nf_nat_l4proto_sctp);\r\nif (err < 0)\r\ngoto err2;\r\nreturn 0;\r\nerr2:\r\nnf_nat_l4proto_unregister(NFPROTO_IPV4, &nf_nat_l4proto_sctp);\r\nerr1:\r\nreturn err;\r\n}\r\nstatic void __exit nf_nat_proto_sctp_exit(void)\r\n{\r\nnf_nat_l4proto_unregister(NFPROTO_IPV6, &nf_nat_l4proto_sctp);\r\nnf_nat_l4proto_unregister(NFPROTO_IPV4, &nf_nat_l4proto_sctp);\r\n}
