static inline int raw3270_state_ready(struct raw3270 *rp)\r\n{\r\nreturn rp->state == RAW3270_STATE_READY;\r\n}\r\nstatic inline int raw3270_state_final(struct raw3270 *rp)\r\n{\r\nreturn rp->state == RAW3270_STATE_INIT ||\r\nrp->state == RAW3270_STATE_READY;\r\n}\r\nvoid\r\nraw3270_buffer_address(struct raw3270 *rp, char *cp, unsigned short addr)\r\n{\r\nif (test_bit(RAW3270_FLAGS_14BITADDR, &rp->flags)) {\r\ncp[0] = (addr >> 8) & 0x3f;\r\ncp[1] = addr & 0xff;\r\n} else {\r\ncp[0] = raw3270_ebcgraf[(addr >> 6) & 0x3f];\r\ncp[1] = raw3270_ebcgraf[addr & 0x3f];\r\n}\r\n}\r\nstruct raw3270_request *\r\nraw3270_request_alloc(size_t size)\r\n{\r\nstruct raw3270_request *rq;\r\nrq = kzalloc(sizeof(struct raw3270_request), GFP_KERNEL | GFP_DMA);\r\nif (!rq)\r\nreturn ERR_PTR(-ENOMEM);\r\nif (size > 0) {\r\nrq->buffer = kmalloc(size, GFP_KERNEL | GFP_DMA);\r\nif (!rq->buffer) {\r\nkfree(rq);\r\nreturn ERR_PTR(-ENOMEM);\r\n}\r\n}\r\nrq->size = size;\r\nINIT_LIST_HEAD(&rq->list);\r\nrq->ccw.cda = __pa(rq->buffer);\r\nrq->ccw.flags = CCW_FLAG_SLI;\r\nreturn rq;\r\n}\r\nvoid\r\nraw3270_request_free (struct raw3270_request *rq)\r\n{\r\nkfree(rq->buffer);\r\nkfree(rq);\r\n}\r\nvoid\r\nraw3270_request_reset(struct raw3270_request *rq)\r\n{\r\nBUG_ON(!list_empty(&rq->list));\r\nrq->ccw.cmd_code = 0;\r\nrq->ccw.count = 0;\r\nrq->ccw.cda = __pa(rq->buffer);\r\nrq->ccw.flags = CCW_FLAG_SLI;\r\nrq->rescnt = 0;\r\nrq->rc = 0;\r\n}\r\nvoid\r\nraw3270_request_set_cmd(struct raw3270_request *rq, u8 cmd)\r\n{\r\nrq->ccw.cmd_code = cmd;\r\n}\r\nint\r\nraw3270_request_add_data(struct raw3270_request *rq, void *data, size_t size)\r\n{\r\nif (size + rq->ccw.count > rq->size)\r\nreturn -E2BIG;\r\nmemcpy(rq->buffer + rq->ccw.count, data, size);\r\nrq->ccw.count += size;\r\nreturn 0;\r\n}\r\nvoid\r\nraw3270_request_set_data(struct raw3270_request *rq, void *data, size_t size)\r\n{\r\nrq->ccw.cda = __pa(data);\r\nrq->ccw.count = size;\r\n}\r\nvoid\r\nraw3270_request_set_idal(struct raw3270_request *rq, struct idal_buffer *ib)\r\n{\r\nrq->ccw.cda = __pa(ib->data);\r\nrq->ccw.count = ib->size;\r\nrq->ccw.flags |= CCW_FLAG_IDA;\r\n}\r\nstatic int\r\n__raw3270_halt_io(struct raw3270 *rp, struct raw3270_request *rq)\r\n{\r\nint retries;\r\nint rc;\r\nif (raw3270_request_final(rq))\r\nreturn 0;\r\nfor (retries = 0; retries < 5; retries++) {\r\nif (retries < 2)\r\nrc = ccw_device_halt(rp->cdev, (long) rq);\r\nelse\r\nrc = ccw_device_clear(rp->cdev, (long) rq);\r\nif (rc == 0)\r\nbreak;\r\n}\r\nreturn rc;\r\n}\r\nstatic int\r\n__raw3270_start(struct raw3270 *rp, struct raw3270_view *view,\r\nstruct raw3270_request *rq)\r\n{\r\nrq->view = view;\r\nraw3270_get_view(view);\r\nif (list_empty(&rp->req_queue) &&\r\n!test_bit(RAW3270_FLAGS_BUSY, &rp->flags)) {\r\nrq->rc = ccw_device_start(rp->cdev, &rq->ccw,\r\n(unsigned long) rq, 0, 0);\r\nif (rq->rc) {\r\nraw3270_put_view(view);\r\nreturn rq->rc;\r\n}\r\n}\r\nlist_add_tail(&rq->list, &rp->req_queue);\r\nreturn 0;\r\n}\r\nint\r\nraw3270_view_active(struct raw3270_view *view)\r\n{\r\nstruct raw3270 *rp = view->dev;\r\nreturn rp && rp->view == view &&\r\n!test_bit(RAW3270_FLAGS_FROZEN, &rp->flags);\r\n}\r\nint\r\nraw3270_start(struct raw3270_view *view, struct raw3270_request *rq)\r\n{\r\nunsigned long flags;\r\nstruct raw3270 *rp;\r\nint rc;\r\nspin_lock_irqsave(get_ccwdev_lock(view->dev->cdev), flags);\r\nrp = view->dev;\r\nif (!rp || rp->view != view ||\r\ntest_bit(RAW3270_FLAGS_FROZEN, &rp->flags))\r\nrc = -EACCES;\r\nelse if (!raw3270_state_ready(rp))\r\nrc = -EBUSY;\r\nelse\r\nrc = __raw3270_start(rp, view, rq);\r\nspin_unlock_irqrestore(get_ccwdev_lock(view->dev->cdev), flags);\r\nreturn rc;\r\n}\r\nint\r\nraw3270_start_locked(struct raw3270_view *view, struct raw3270_request *rq)\r\n{\r\nstruct raw3270 *rp;\r\nint rc;\r\nrp = view->dev;\r\nif (!rp || rp->view != view ||\r\ntest_bit(RAW3270_FLAGS_FROZEN, &rp->flags))\r\nrc = -EACCES;\r\nelse if (!raw3270_state_ready(rp))\r\nrc = -EBUSY;\r\nelse\r\nrc = __raw3270_start(rp, view, rq);\r\nreturn rc;\r\n}\r\nint\r\nraw3270_start_irq(struct raw3270_view *view, struct raw3270_request *rq)\r\n{\r\nstruct raw3270 *rp;\r\nrp = view->dev;\r\nrq->view = view;\r\nraw3270_get_view(view);\r\nlist_add_tail(&rq->list, &rp->req_queue);\r\nreturn 0;\r\n}\r\nstatic void\r\nraw3270_irq (struct ccw_device *cdev, unsigned long intparm, struct irb *irb)\r\n{\r\nstruct raw3270 *rp;\r\nstruct raw3270_view *view;\r\nstruct raw3270_request *rq;\r\nint rc;\r\nrp = dev_get_drvdata(&cdev->dev);\r\nif (!rp)\r\nreturn;\r\nrq = (struct raw3270_request *) intparm;\r\nview = rq ? rq->view : rp->view;\r\nif (IS_ERR(irb))\r\nrc = RAW3270_IO_RETRY;\r\nelse if (irb->scsw.cmd.fctl & SCSW_FCTL_HALT_FUNC) {\r\nrq->rc = -EIO;\r\nrc = RAW3270_IO_DONE;\r\n} else if (irb->scsw.cmd.dstat == (DEV_STAT_CHN_END | DEV_STAT_DEV_END |\r\nDEV_STAT_UNIT_EXCEP)) {\r\nset_bit(RAW3270_FLAGS_BUSY, &rp->flags);\r\nrc = RAW3270_IO_BUSY;\r\n} else if (test_bit(RAW3270_FLAGS_BUSY, &rp->flags)) {\r\nif (irb->scsw.cmd.dstat & DEV_STAT_DEV_END) {\r\nclear_bit(RAW3270_FLAGS_BUSY, &rp->flags);\r\nrc = RAW3270_IO_RETRY;\r\n} else\r\nrc = RAW3270_IO_BUSY;\r\n} else if (view)\r\nrc = view->fn->intv(view, rq, irb);\r\nelse\r\nrc = RAW3270_IO_DONE;\r\nswitch (rc) {\r\ncase RAW3270_IO_DONE:\r\nbreak;\r\ncase RAW3270_IO_BUSY:\r\nreturn;\r\ncase RAW3270_IO_RETRY:\r\nif (!rq)\r\nbreak;\r\nrq->rc = ccw_device_start(rp->cdev, &rq->ccw,\r\n(unsigned long) rq, 0, 0);\r\nif (rq->rc == 0)\r\nreturn;\r\nbreak;\r\ncase RAW3270_IO_STOP:\r\nif (!rq)\r\nbreak;\r\n__raw3270_halt_io(rp, rq);\r\nrq->rc = -EIO;\r\nbreak;\r\ndefault:\r\nBUG();\r\n}\r\nif (rq) {\r\nBUG_ON(list_empty(&rq->list));\r\nlist_del_init(&rq->list);\r\nif (rq->callback)\r\nrq->callback(rq, rq->callback_data);\r\nraw3270_put_view(view);\r\n}\r\nwhile (!list_empty(&rp->req_queue)) {\r\nrq = list_entry(rp->req_queue.next,struct raw3270_request,list);\r\nrq->rc = ccw_device_start(rp->cdev, &rq->ccw,\r\n(unsigned long) rq, 0, 0);\r\nif (rq->rc == 0)\r\nbreak;\r\nlist_del_init(&rq->list);\r\nif (rq->callback)\r\nrq->callback(rq, rq->callback_data);\r\nraw3270_put_view(view);\r\n}\r\n}\r\nstatic void\r\nraw3270_size_device_vm(struct raw3270 *rp)\r\n{\r\nint rc, model;\r\nstruct ccw_dev_id dev_id;\r\nstruct diag210 diag_data;\r\nccw_device_get_id(rp->cdev, &dev_id);\r\ndiag_data.vrdcdvno = dev_id.devno;\r\ndiag_data.vrdclen = sizeof(struct diag210);\r\nrc = diag210(&diag_data);\r\nmodel = diag_data.vrdccrmd;\r\nif (rc || model < 2 || model > 5)\r\nmodel = 2;\r\nswitch (model) {\r\ncase 2:\r\nrp->model = model;\r\nrp->rows = 24;\r\nrp->cols = 80;\r\nbreak;\r\ncase 3:\r\nrp->model = model;\r\nrp->rows = 32;\r\nrp->cols = 80;\r\nbreak;\r\ncase 4:\r\nrp->model = model;\r\nrp->rows = 43;\r\nrp->cols = 80;\r\nbreak;\r\ncase 5:\r\nrp->model = model;\r\nrp->rows = 27;\r\nrp->cols = 132;\r\nbreak;\r\n}\r\n}\r\nstatic void\r\nraw3270_size_device(struct raw3270 *rp)\r\n{\r\nstruct raw3270_ua *uap;\r\nuap = (struct raw3270_ua *) (rp->init_data + 1);\r\nif (rp->init_readmod.rc || rp->init_data[0] != 0x88 ||\r\nuap->uab.qcode != 0x81) {\r\nrp->model = 2;\r\nrp->rows = 24;\r\nrp->cols = 80;\r\nreturn;\r\n}\r\nrp->rows = uap->uab.h;\r\nrp->cols = uap->uab.w;\r\nif ((uap->uab.flags0 & 0x0d) == 0x01)\r\nset_bit(RAW3270_FLAGS_14BITADDR, &rp->flags);\r\nif (uap->uab.l == sizeof(struct raw3270_ua) &&\r\nuap->aua.sdpid == 0x02) {\r\nrp->rows = uap->aua.hauai;\r\nrp->cols = uap->aua.wauai;\r\n}\r\nrp->model = 0;\r\nif (rp->rows == 24 && rp->cols == 80)\r\nrp->model = 2;\r\nif (rp->rows == 32 && rp->cols == 80)\r\nrp->model = 3;\r\nif (rp->rows == 43 && rp->cols == 80)\r\nrp->model = 4;\r\nif (rp->rows == 27 && rp->cols == 132)\r\nrp->model = 5;\r\n}\r\nstatic void\r\nraw3270_size_device_done(struct raw3270 *rp)\r\n{\r\nstruct raw3270_view *view;\r\nrp->view = NULL;\r\nrp->state = RAW3270_STATE_READY;\r\nlist_for_each_entry(view, &rp->view_list, list)\r\nif (view->fn->resize)\r\nview->fn->resize(view, rp->model, rp->rows, rp->cols);\r\nlist_for_each_entry(view, &rp->view_list, list) {\r\nrp->view = view;\r\nif (view->fn->activate(view) == 0)\r\nbreak;\r\nrp->view = NULL;\r\n}\r\n}\r\nstatic void\r\nraw3270_read_modified_cb(struct raw3270_request *rq, void *data)\r\n{\r\nstruct raw3270 *rp = rq->view->dev;\r\nraw3270_size_device(rp);\r\nraw3270_size_device_done(rp);\r\n}\r\nstatic void\r\nraw3270_read_modified(struct raw3270 *rp)\r\n{\r\nif (rp->state != RAW3270_STATE_W4ATTN)\r\nreturn;\r\nmemset(&rp->init_readmod, 0, sizeof(rp->init_readmod));\r\nmemset(&rp->init_data, 0, sizeof(rp->init_data));\r\nrp->init_readmod.ccw.cmd_code = TC_READMOD;\r\nrp->init_readmod.ccw.flags = CCW_FLAG_SLI;\r\nrp->init_readmod.ccw.count = sizeof(rp->init_data);\r\nrp->init_readmod.ccw.cda = (__u32) __pa(rp->init_data);\r\nrp->init_readmod.callback = raw3270_read_modified_cb;\r\nrp->state = RAW3270_STATE_READMOD;\r\nraw3270_start_irq(&rp->init_view, &rp->init_readmod);\r\n}\r\nstatic void\r\nraw3270_writesf_readpart(struct raw3270 *rp)\r\n{\r\nstatic const unsigned char wbuf[] =\r\n{ 0x00, 0x07, 0x01, 0xff, 0x03, 0x00, 0x81 };\r\nmemset(&rp->init_readpart, 0, sizeof(rp->init_readpart));\r\nmemset(&rp->init_data, 0, sizeof(rp->init_data));\r\nmemcpy(&rp->init_data, wbuf, sizeof(wbuf));\r\nrp->init_readpart.ccw.cmd_code = TC_WRITESF;\r\nrp->init_readpart.ccw.flags = CCW_FLAG_SLI;\r\nrp->init_readpart.ccw.count = sizeof(wbuf);\r\nrp->init_readpart.ccw.cda = (__u32) __pa(&rp->init_data);\r\nrp->state = RAW3270_STATE_W4ATTN;\r\nraw3270_start_irq(&rp->init_view, &rp->init_readpart);\r\n}\r\nstatic void\r\nraw3270_reset_device_cb(struct raw3270_request *rq, void *data)\r\n{\r\nstruct raw3270 *rp = rq->view->dev;\r\nif (rp->state != RAW3270_STATE_RESET)\r\nreturn;\r\nif (rq->rc) {\r\nrp->state = RAW3270_STATE_INIT;\r\n} else if (MACHINE_IS_VM) {\r\nraw3270_size_device_vm(rp);\r\nraw3270_size_device_done(rp);\r\n} else\r\nraw3270_writesf_readpart(rp);\r\nmemset(&rp->init_reset, 0, sizeof(rp->init_reset));\r\n}\r\nstatic int\r\n__raw3270_reset_device(struct raw3270 *rp)\r\n{\r\nint rc;\r\nif (rp->init_reset.view)\r\nreturn -EBUSY;\r\nrp->init_data[0] = TW_KR;\r\nrp->init_reset.ccw.cmd_code = TC_EWRITEA;\r\nrp->init_reset.ccw.flags = CCW_FLAG_SLI;\r\nrp->init_reset.ccw.count = 1;\r\nrp->init_reset.ccw.cda = (__u32) __pa(rp->init_data);\r\nrp->init_reset.callback = raw3270_reset_device_cb;\r\nrc = __raw3270_start(rp, &rp->init_view, &rp->init_reset);\r\nif (rc == 0 && rp->state == RAW3270_STATE_INIT)\r\nrp->state = RAW3270_STATE_RESET;\r\nreturn rc;\r\n}\r\nstatic int\r\nraw3270_reset_device(struct raw3270 *rp)\r\n{\r\nunsigned long flags;\r\nint rc;\r\nspin_lock_irqsave(get_ccwdev_lock(rp->cdev), flags);\r\nrc = __raw3270_reset_device(rp);\r\nspin_unlock_irqrestore(get_ccwdev_lock(rp->cdev), flags);\r\nreturn rc;\r\n}\r\nint\r\nraw3270_reset(struct raw3270_view *view)\r\n{\r\nstruct raw3270 *rp;\r\nint rc;\r\nrp = view->dev;\r\nif (!rp || rp->view != view ||\r\ntest_bit(RAW3270_FLAGS_FROZEN, &rp->flags))\r\nrc = -EACCES;\r\nelse if (!raw3270_state_ready(rp))\r\nrc = -EBUSY;\r\nelse\r\nrc = raw3270_reset_device(view->dev);\r\nreturn rc;\r\n}\r\nstatic int\r\nraw3270_init_irq(struct raw3270_view *view, struct raw3270_request *rq,\r\nstruct irb *irb)\r\n{\r\nstruct raw3270 *rp;\r\nif (irb->scsw.cmd.dstat & DEV_STAT_UNIT_CHECK) {\r\nif (irb->ecw[0] & SNS0_INTERVENTION_REQ) {\r\nset_bit(RAW3270_FLAGS_BUSY, &view->dev->flags);\r\nreturn RAW3270_IO_BUSY;\r\n}\r\n}\r\nif (rq) {\r\nif (irb->scsw.cmd.dstat & DEV_STAT_UNIT_CHECK) {\r\nif (irb->ecw[0] & SNS0_CMD_REJECT)\r\nrq->rc = -EOPNOTSUPP;\r\nelse\r\nrq->rc = -EIO;\r\n}\r\n}\r\nif (irb->scsw.cmd.dstat & DEV_STAT_ATTENTION) {\r\nrp = view->dev;\r\nraw3270_read_modified(rp);\r\n}\r\nreturn RAW3270_IO_DONE;\r\n}\r\nstatic int\r\nraw3270_setup_device(struct ccw_device *cdev, struct raw3270 *rp, char *ascebc)\r\n{\r\nstruct list_head *l;\r\nstruct raw3270 *tmp;\r\nint minor;\r\nmemset(rp, 0, sizeof(struct raw3270));\r\nmemcpy(ascebc, _ascebc, 256);\r\nif (tubxcorrect) {\r\nascebc['['] = 0xad;\r\nascebc[']'] = 0xbd;\r\nascebc['^'] = 0xb0;\r\n}\r\nrp->ascebc = ascebc;\r\nrp->rows = 24;\r\nrp->cols = 80;\r\nINIT_LIST_HEAD(&rp->req_queue);\r\nINIT_LIST_HEAD(&rp->view_list);\r\nrp->init_view.dev = rp;\r\nrp->init_view.fn = &raw3270_init_fn;\r\nrp->view = &rp->init_view;\r\nmutex_lock(&raw3270_mutex);\r\nminor = RAW3270_FIRSTMINOR;\r\nrp->minor = -1;\r\nlist_for_each(l, &raw3270_devices) {\r\ntmp = list_entry(l, struct raw3270, list);\r\nif (tmp->minor > minor) {\r\nrp->minor = minor;\r\n__list_add(&rp->list, l->prev, l);\r\nbreak;\r\n}\r\nminor++;\r\n}\r\nif (rp->minor == -1 && minor < RAW3270_MAXDEVS + RAW3270_FIRSTMINOR) {\r\nrp->minor = minor;\r\nlist_add_tail(&rp->list, &raw3270_devices);\r\n}\r\nmutex_unlock(&raw3270_mutex);\r\nif (rp->minor == -1)\r\nreturn -EUSERS;\r\nrp->cdev = cdev;\r\ndev_set_drvdata(&cdev->dev, rp);\r\ncdev->handler = raw3270_irq;\r\nreturn 0;\r\n}\r\nstruct raw3270 __init *raw3270_setup_console(void)\r\n{\r\nstruct ccw_device *cdev;\r\nunsigned long flags;\r\nstruct raw3270 *rp;\r\nchar *ascebc;\r\nint rc;\r\ncdev = ccw_device_create_console(&raw3270_ccw_driver);\r\nif (IS_ERR(cdev))\r\nreturn ERR_CAST(cdev);\r\nrp = kzalloc(sizeof(struct raw3270), GFP_KERNEL | GFP_DMA);\r\nascebc = kzalloc(256, GFP_KERNEL);\r\nrc = raw3270_setup_device(cdev, rp, ascebc);\r\nif (rc)\r\nreturn ERR_PTR(rc);\r\nset_bit(RAW3270_FLAGS_CONSOLE, &rp->flags);\r\nrc = ccw_device_enable_console(cdev);\r\nif (rc) {\r\nccw_device_destroy_console(cdev);\r\nreturn ERR_PTR(rc);\r\n}\r\nspin_lock_irqsave(get_ccwdev_lock(rp->cdev), flags);\r\ndo {\r\n__raw3270_reset_device(rp);\r\nwhile (!raw3270_state_final(rp)) {\r\nccw_device_wait_idle(rp->cdev);\r\nbarrier();\r\n}\r\n} while (rp->state != RAW3270_STATE_READY);\r\nspin_unlock_irqrestore(get_ccwdev_lock(rp->cdev), flags);\r\nreturn rp;\r\n}\r\nvoid\r\nraw3270_wait_cons_dev(struct raw3270 *rp)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(get_ccwdev_lock(rp->cdev), flags);\r\nccw_device_wait_idle(rp->cdev);\r\nspin_unlock_irqrestore(get_ccwdev_lock(rp->cdev), flags);\r\n}\r\nstatic struct raw3270 *\r\nraw3270_create_device(struct ccw_device *cdev)\r\n{\r\nstruct raw3270 *rp;\r\nchar *ascebc;\r\nint rc;\r\nrp = kzalloc(sizeof(struct raw3270), GFP_KERNEL | GFP_DMA);\r\nif (!rp)\r\nreturn ERR_PTR(-ENOMEM);\r\nascebc = kmalloc(256, GFP_KERNEL);\r\nif (!ascebc) {\r\nkfree(rp);\r\nreturn ERR_PTR(-ENOMEM);\r\n}\r\nrc = raw3270_setup_device(cdev, rp, ascebc);\r\nif (rc) {\r\nkfree(rp->ascebc);\r\nkfree(rp);\r\nrp = ERR_PTR(rc);\r\n}\r\nget_device(&cdev->dev);\r\nreturn rp;\r\n}\r\nint\r\nraw3270_activate_view(struct raw3270_view *view)\r\n{\r\nstruct raw3270 *rp;\r\nstruct raw3270_view *oldview, *nv;\r\nunsigned long flags;\r\nint rc;\r\nrp = view->dev;\r\nif (!rp)\r\nreturn -ENODEV;\r\nspin_lock_irqsave(get_ccwdev_lock(rp->cdev), flags);\r\nif (rp->view == view)\r\nrc = 0;\r\nelse if (!raw3270_state_ready(rp))\r\nrc = -EBUSY;\r\nelse if (test_bit(RAW3270_FLAGS_FROZEN, &rp->flags))\r\nrc = -EACCES;\r\nelse {\r\noldview = NULL;\r\nif (rp->view && rp->view->fn->deactivate) {\r\noldview = rp->view;\r\noldview->fn->deactivate(oldview);\r\n}\r\nrp->view = view;\r\nrc = view->fn->activate(view);\r\nif (rc) {\r\nrp->view = oldview;\r\nif (!oldview || oldview->fn->activate(oldview) != 0) {\r\nlist_for_each_entry(nv, &rp->view_list, list)\r\nif (nv != view && nv != oldview) {\r\nrp->view = nv;\r\nif (nv->fn->activate(nv) == 0)\r\nbreak;\r\nrp->view = NULL;\r\n}\r\n}\r\n}\r\n}\r\nspin_unlock_irqrestore(get_ccwdev_lock(rp->cdev), flags);\r\nreturn rc;\r\n}\r\nvoid\r\nraw3270_deactivate_view(struct raw3270_view *view)\r\n{\r\nunsigned long flags;\r\nstruct raw3270 *rp;\r\nrp = view->dev;\r\nif (!rp)\r\nreturn;\r\nspin_lock_irqsave(get_ccwdev_lock(rp->cdev), flags);\r\nif (rp->view == view) {\r\nview->fn->deactivate(view);\r\nrp->view = NULL;\r\nlist_del_init(&view->list);\r\nlist_add_tail(&view->list, &rp->view_list);\r\nif (raw3270_state_ready(rp) &&\r\n!test_bit(RAW3270_FLAGS_FROZEN, &rp->flags)) {\r\nlist_for_each_entry(view, &rp->view_list, list) {\r\nrp->view = view;\r\nif (view->fn->activate(view) == 0)\r\nbreak;\r\nrp->view = NULL;\r\n}\r\n}\r\n}\r\nspin_unlock_irqrestore(get_ccwdev_lock(rp->cdev), flags);\r\n}\r\nint\r\nraw3270_add_view(struct raw3270_view *view, struct raw3270_fn *fn, int minor)\r\n{\r\nunsigned long flags;\r\nstruct raw3270 *rp;\r\nint rc;\r\nif (minor <= 0)\r\nreturn -ENODEV;\r\nmutex_lock(&raw3270_mutex);\r\nrc = -ENODEV;\r\nlist_for_each_entry(rp, &raw3270_devices, list) {\r\nif (rp->minor != minor)\r\ncontinue;\r\nspin_lock_irqsave(get_ccwdev_lock(rp->cdev), flags);\r\natomic_set(&view->ref_count, 2);\r\nview->dev = rp;\r\nview->fn = fn;\r\nview->model = rp->model;\r\nview->rows = rp->rows;\r\nview->cols = rp->cols;\r\nview->ascebc = rp->ascebc;\r\nspin_lock_init(&view->lock);\r\nlist_add(&view->list, &rp->view_list);\r\nrc = 0;\r\nspin_unlock_irqrestore(get_ccwdev_lock(rp->cdev), flags);\r\nbreak;\r\n}\r\nmutex_unlock(&raw3270_mutex);\r\nreturn rc;\r\n}\r\nstruct raw3270_view *\r\nraw3270_find_view(struct raw3270_fn *fn, int minor)\r\n{\r\nstruct raw3270 *rp;\r\nstruct raw3270_view *view, *tmp;\r\nunsigned long flags;\r\nmutex_lock(&raw3270_mutex);\r\nview = ERR_PTR(-ENODEV);\r\nlist_for_each_entry(rp, &raw3270_devices, list) {\r\nif (rp->minor != minor)\r\ncontinue;\r\nspin_lock_irqsave(get_ccwdev_lock(rp->cdev), flags);\r\nlist_for_each_entry(tmp, &rp->view_list, list) {\r\nif (tmp->fn == fn) {\r\nraw3270_get_view(tmp);\r\nview = tmp;\r\nbreak;\r\n}\r\n}\r\nspin_unlock_irqrestore(get_ccwdev_lock(rp->cdev), flags);\r\nbreak;\r\n}\r\nmutex_unlock(&raw3270_mutex);\r\nreturn view;\r\n}\r\nvoid\r\nraw3270_del_view(struct raw3270_view *view)\r\n{\r\nunsigned long flags;\r\nstruct raw3270 *rp;\r\nstruct raw3270_view *nv;\r\nrp = view->dev;\r\nspin_lock_irqsave(get_ccwdev_lock(rp->cdev), flags);\r\nif (rp->view == view) {\r\nview->fn->deactivate(view);\r\nrp->view = NULL;\r\n}\r\nlist_del_init(&view->list);\r\nif (!rp->view && raw3270_state_ready(rp) &&\r\n!test_bit(RAW3270_FLAGS_FROZEN, &rp->flags)) {\r\nlist_for_each_entry(nv, &rp->view_list, list) {\r\nif (nv->fn->activate(nv) == 0) {\r\nrp->view = nv;\r\nbreak;\r\n}\r\n}\r\n}\r\nspin_unlock_irqrestore(get_ccwdev_lock(rp->cdev), flags);\r\natomic_dec(&view->ref_count);\r\nwait_event(raw3270_wait_queue, atomic_read(&view->ref_count) == 0);\r\nif (view->fn->free)\r\nview->fn->free(view);\r\n}\r\nstatic void\r\nraw3270_delete_device(struct raw3270 *rp)\r\n{\r\nstruct ccw_device *cdev;\r\nmutex_lock(&raw3270_mutex);\r\nlist_del_init(&rp->list);\r\nmutex_unlock(&raw3270_mutex);\r\ncdev = rp->cdev;\r\nrp->cdev = NULL;\r\ndev_set_drvdata(&cdev->dev, NULL);\r\ncdev->handler = NULL;\r\nput_device(&cdev->dev);\r\nkfree(rp->ascebc);\r\nkfree(rp);\r\n}\r\nstatic int\r\nraw3270_probe (struct ccw_device *cdev)\r\n{\r\nreturn 0;\r\n}\r\nstatic ssize_t\r\nraw3270_model_show(struct device *dev, struct device_attribute *attr, char *buf)\r\n{\r\nreturn snprintf(buf, PAGE_SIZE, "%i\n",\r\n((struct raw3270 *) dev_get_drvdata(dev))->model);\r\n}\r\nstatic ssize_t\r\nraw3270_rows_show(struct device *dev, struct device_attribute *attr, char *buf)\r\n{\r\nreturn snprintf(buf, PAGE_SIZE, "%i\n",\r\n((struct raw3270 *) dev_get_drvdata(dev))->rows);\r\n}\r\nstatic ssize_t\r\nraw3270_columns_show(struct device *dev, struct device_attribute *attr, char *buf)\r\n{\r\nreturn snprintf(buf, PAGE_SIZE, "%i\n",\r\n((struct raw3270 *) dev_get_drvdata(dev))->cols);\r\n}\r\nstatic int raw3270_create_attributes(struct raw3270 *rp)\r\n{\r\nreturn sysfs_create_group(&rp->cdev->dev.kobj, &raw3270_attr_group);\r\n}\r\nint raw3270_register_notifier(struct raw3270_notifier *notifier)\r\n{\r\nstruct raw3270 *rp;\r\nmutex_lock(&raw3270_mutex);\r\nlist_add_tail(&notifier->list, &raw3270_notifier);\r\nlist_for_each_entry(rp, &raw3270_devices, list)\r\nnotifier->create(rp->minor);\r\nmutex_unlock(&raw3270_mutex);\r\nreturn 0;\r\n}\r\nvoid raw3270_unregister_notifier(struct raw3270_notifier *notifier)\r\n{\r\nstruct raw3270 *rp;\r\nmutex_lock(&raw3270_mutex);\r\nlist_for_each_entry(rp, &raw3270_devices, list)\r\nnotifier->destroy(rp->minor);\r\nlist_del(&notifier->list);\r\nmutex_unlock(&raw3270_mutex);\r\n}\r\nstatic int\r\nraw3270_set_online (struct ccw_device *cdev)\r\n{\r\nstruct raw3270_notifier *np;\r\nstruct raw3270 *rp;\r\nint rc;\r\nrp = raw3270_create_device(cdev);\r\nif (IS_ERR(rp))\r\nreturn PTR_ERR(rp);\r\nrc = raw3270_create_attributes(rp);\r\nif (rc)\r\ngoto failure;\r\nraw3270_reset_device(rp);\r\nmutex_lock(&raw3270_mutex);\r\nlist_for_each_entry(np, &raw3270_notifier, list)\r\nnp->create(rp->minor);\r\nmutex_unlock(&raw3270_mutex);\r\nreturn 0;\r\nfailure:\r\nraw3270_delete_device(rp);\r\nreturn rc;\r\n}\r\nstatic void\r\nraw3270_remove (struct ccw_device *cdev)\r\n{\r\nunsigned long flags;\r\nstruct raw3270 *rp;\r\nstruct raw3270_view *v;\r\nstruct raw3270_notifier *np;\r\nrp = dev_get_drvdata(&cdev->dev);\r\nif (rp == NULL)\r\nreturn;\r\nsysfs_remove_group(&cdev->dev.kobj, &raw3270_attr_group);\r\nspin_lock_irqsave(get_ccwdev_lock(cdev), flags);\r\nif (rp->view) {\r\nif (rp->view->fn->deactivate)\r\nrp->view->fn->deactivate(rp->view);\r\nrp->view = NULL;\r\n}\r\nwhile (!list_empty(&rp->view_list)) {\r\nv = list_entry(rp->view_list.next, struct raw3270_view, list);\r\nif (v->fn->release)\r\nv->fn->release(v);\r\nspin_unlock_irqrestore(get_ccwdev_lock(cdev), flags);\r\nraw3270_del_view(v);\r\nspin_lock_irqsave(get_ccwdev_lock(cdev), flags);\r\n}\r\nspin_unlock_irqrestore(get_ccwdev_lock(cdev), flags);\r\nmutex_lock(&raw3270_mutex);\r\nlist_for_each_entry(np, &raw3270_notifier, list)\r\nnp->destroy(rp->minor);\r\nmutex_unlock(&raw3270_mutex);\r\nraw3270_reset_device(rp);\r\nraw3270_delete_device(rp);\r\n}\r\nstatic int\r\nraw3270_set_offline (struct ccw_device *cdev)\r\n{\r\nstruct raw3270 *rp;\r\nrp = dev_get_drvdata(&cdev->dev);\r\nif (test_bit(RAW3270_FLAGS_CONSOLE, &rp->flags))\r\nreturn -EBUSY;\r\nraw3270_remove(cdev);\r\nreturn 0;\r\n}\r\nstatic int raw3270_pm_stop(struct ccw_device *cdev)\r\n{\r\nstruct raw3270 *rp;\r\nstruct raw3270_view *view;\r\nunsigned long flags;\r\nrp = dev_get_drvdata(&cdev->dev);\r\nif (!rp)\r\nreturn 0;\r\nspin_lock_irqsave(get_ccwdev_lock(rp->cdev), flags);\r\nif (rp->view && rp->view->fn->deactivate)\r\nrp->view->fn->deactivate(rp->view);\r\nif (!test_bit(RAW3270_FLAGS_CONSOLE, &rp->flags)) {\r\nlist_for_each_entry(view, &rp->view_list, list) {\r\nif (view->fn->release)\r\nview->fn->release(view);\r\n}\r\n}\r\nset_bit(RAW3270_FLAGS_FROZEN, &rp->flags);\r\nspin_unlock_irqrestore(get_ccwdev_lock(rp->cdev), flags);\r\nreturn 0;\r\n}\r\nstatic int raw3270_pm_start(struct ccw_device *cdev)\r\n{\r\nstruct raw3270 *rp;\r\nunsigned long flags;\r\nrp = dev_get_drvdata(&cdev->dev);\r\nif (!rp)\r\nreturn 0;\r\nspin_lock_irqsave(get_ccwdev_lock(rp->cdev), flags);\r\nclear_bit(RAW3270_FLAGS_FROZEN, &rp->flags);\r\nif (rp->view && rp->view->fn->activate)\r\nrp->view->fn->activate(rp->view);\r\nspin_unlock_irqrestore(get_ccwdev_lock(rp->cdev), flags);\r\nreturn 0;\r\n}\r\nvoid raw3270_pm_unfreeze(struct raw3270_view *view)\r\n{\r\n#ifdef CONFIG_TN3270_CONSOLE\r\nstruct raw3270 *rp;\r\nrp = view->dev;\r\nif (rp && test_bit(RAW3270_FLAGS_FROZEN, &rp->flags))\r\nccw_device_force_console(rp->cdev);\r\n#endif\r\n}\r\nstatic int\r\nraw3270_init(void)\r\n{\r\nstruct raw3270 *rp;\r\nint rc;\r\nif (raw3270_registered)\r\nreturn 0;\r\nraw3270_registered = 1;\r\nrc = ccw_driver_register(&raw3270_ccw_driver);\r\nif (rc == 0) {\r\nmutex_lock(&raw3270_mutex);\r\nclass3270 = class_create(THIS_MODULE, "3270");\r\nlist_for_each_entry(rp, &raw3270_devices, list) {\r\nget_device(&rp->cdev->dev);\r\nraw3270_create_attributes(rp);\r\n}\r\nmutex_unlock(&raw3270_mutex);\r\n}\r\nreturn rc;\r\n}\r\nstatic void\r\nraw3270_exit(void)\r\n{\r\nccw_driver_unregister(&raw3270_ccw_driver);\r\nclass_destroy(class3270);\r\n}
