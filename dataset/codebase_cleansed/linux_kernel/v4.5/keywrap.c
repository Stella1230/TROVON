static inline void crypto_kw_cpu_to_be64(u64 val, u8 *buf)\r\n{\r\n__be64 *a = (__be64 *)buf;\r\n*a = cpu_to_be64(val);\r\n}\r\nstatic void crypto_kw_scatterlist_ff(struct scatter_walk *walk,\r\nstruct scatterlist *sg,\r\nunsigned int end)\r\n{\r\nunsigned int skip = 0;\r\nBUG_ON(end < SEMIBSIZE);\r\nskip = end - SEMIBSIZE;\r\nwhile (sg) {\r\nif (sg->length > skip) {\r\nscatterwalk_start(walk, sg);\r\nscatterwalk_advance(walk, skip);\r\nbreak;\r\n} else\r\nskip -= sg->length;\r\nsg = sg_next(sg);\r\n}\r\n}\r\nstatic int crypto_kw_decrypt(struct blkcipher_desc *desc,\r\nstruct scatterlist *dst, struct scatterlist *src,\r\nunsigned int nbytes)\r\n{\r\nstruct crypto_blkcipher *tfm = desc->tfm;\r\nstruct crypto_kw_ctx *ctx = crypto_blkcipher_ctx(tfm);\r\nstruct crypto_cipher *child = ctx->child;\r\nunsigned long alignmask = max_t(unsigned long, SEMIBSIZE,\r\ncrypto_cipher_alignmask(child));\r\nunsigned int i;\r\nu8 blockbuf[sizeof(struct crypto_kw_block) + alignmask];\r\nstruct crypto_kw_block *block = (struct crypto_kw_block *)\r\nPTR_ALIGN(blockbuf + 0, alignmask + 1);\r\nu64 t = 6 * ((nbytes) >> 3);\r\nstruct scatterlist *lsrc, *ldst;\r\nint ret = 0;\r\nif (nbytes < (2 * SEMIBSIZE) || nbytes % SEMIBSIZE)\r\nreturn -EINVAL;\r\nmemcpy(block->A, desc->info, SEMIBSIZE);\r\nlsrc = src;\r\nldst = dst;\r\nfor (i = 0; i < 6; i++) {\r\nu8 tbe_buffer[SEMIBSIZE + alignmask];\r\nu8 *tbe = PTR_ALIGN(tbe_buffer + 0, alignmask + 1);\r\nunsigned int tmp_nbytes = nbytes;\r\nstruct scatter_walk src_walk, dst_walk;\r\nwhile (tmp_nbytes) {\r\ncrypto_kw_scatterlist_ff(&src_walk, lsrc, tmp_nbytes);\r\nscatterwalk_copychunks(block->R, &src_walk, SEMIBSIZE,\r\nfalse);\r\ncrypto_kw_cpu_to_be64(t, tbe);\r\ncrypto_xor(block->A, tbe, SEMIBSIZE);\r\nt--;\r\ncrypto_cipher_decrypt_one(child, (u8*)block,\r\n(u8*)block);\r\ncrypto_kw_scatterlist_ff(&dst_walk, ldst, tmp_nbytes);\r\nscatterwalk_copychunks(block->R, &dst_walk, SEMIBSIZE,\r\ntrue);\r\ntmp_nbytes -= SEMIBSIZE;\r\n}\r\nlsrc = dst;\r\nldst = dst;\r\n}\r\nif (crypto_memneq("\xA6\xA6\xA6\xA6\xA6\xA6\xA6\xA6", block->A,\r\nSEMIBSIZE))\r\nret = -EBADMSG;\r\nmemzero_explicit(&block, sizeof(struct crypto_kw_block));\r\nreturn ret;\r\n}\r\nstatic int crypto_kw_encrypt(struct blkcipher_desc *desc,\r\nstruct scatterlist *dst, struct scatterlist *src,\r\nunsigned int nbytes)\r\n{\r\nstruct crypto_blkcipher *tfm = desc->tfm;\r\nstruct crypto_kw_ctx *ctx = crypto_blkcipher_ctx(tfm);\r\nstruct crypto_cipher *child = ctx->child;\r\nunsigned long alignmask = max_t(unsigned long, SEMIBSIZE,\r\ncrypto_cipher_alignmask(child));\r\nunsigned int i;\r\nu8 blockbuf[sizeof(struct crypto_kw_block) + alignmask];\r\nstruct crypto_kw_block *block = (struct crypto_kw_block *)\r\nPTR_ALIGN(blockbuf + 0, alignmask + 1);\r\nu64 t = 1;\r\nstruct scatterlist *lsrc, *ldst;\r\nif (nbytes < (2 * SEMIBSIZE) || nbytes % SEMIBSIZE)\r\nreturn -EINVAL;\r\nmemcpy(block->A, "\xA6\xA6\xA6\xA6\xA6\xA6\xA6\xA6", SEMIBSIZE);\r\nlsrc = src;\r\nldst = dst;\r\nfor (i = 0; i < 6; i++) {\r\nu8 tbe_buffer[SEMIBSIZE + alignmask];\r\nu8 *tbe = PTR_ALIGN(tbe_buffer + 0, alignmask + 1);\r\nunsigned int tmp_nbytes = nbytes;\r\nstruct scatter_walk src_walk, dst_walk;\r\nscatterwalk_start(&src_walk, lsrc);\r\nscatterwalk_start(&dst_walk, ldst);\r\nwhile (tmp_nbytes) {\r\nscatterwalk_copychunks(block->R, &src_walk, SEMIBSIZE,\r\nfalse);\r\ncrypto_cipher_encrypt_one(child, (u8 *)block,\r\n(u8 *)block);\r\ncrypto_kw_cpu_to_be64(t, tbe);\r\ncrypto_xor(block->A, tbe, SEMIBSIZE);\r\nt++;\r\nscatterwalk_copychunks(block->R, &dst_walk, SEMIBSIZE,\r\ntrue);\r\ntmp_nbytes -= SEMIBSIZE;\r\n}\r\nlsrc = dst;\r\nldst = dst;\r\n}\r\nmemcpy(desc->info, block->A, SEMIBSIZE);\r\nmemzero_explicit(&block, sizeof(struct crypto_kw_block));\r\nreturn 0;\r\n}\r\nstatic int crypto_kw_setkey(struct crypto_tfm *parent, const u8 *key,\r\nunsigned int keylen)\r\n{\r\nstruct crypto_kw_ctx *ctx = crypto_tfm_ctx(parent);\r\nstruct crypto_cipher *child = ctx->child;\r\nint err;\r\ncrypto_cipher_clear_flags(child, CRYPTO_TFM_REQ_MASK);\r\ncrypto_cipher_set_flags(child, crypto_tfm_get_flags(parent) &\r\nCRYPTO_TFM_REQ_MASK);\r\nerr = crypto_cipher_setkey(child, key, keylen);\r\ncrypto_tfm_set_flags(parent, crypto_cipher_get_flags(child) &\r\nCRYPTO_TFM_RES_MASK);\r\nreturn err;\r\n}\r\nstatic int crypto_kw_init_tfm(struct crypto_tfm *tfm)\r\n{\r\nstruct crypto_instance *inst = crypto_tfm_alg_instance(tfm);\r\nstruct crypto_spawn *spawn = crypto_instance_ctx(inst);\r\nstruct crypto_kw_ctx *ctx = crypto_tfm_ctx(tfm);\r\nstruct crypto_cipher *cipher;\r\ncipher = crypto_spawn_cipher(spawn);\r\nif (IS_ERR(cipher))\r\nreturn PTR_ERR(cipher);\r\nctx->child = cipher;\r\nreturn 0;\r\n}\r\nstatic void crypto_kw_exit_tfm(struct crypto_tfm *tfm)\r\n{\r\nstruct crypto_kw_ctx *ctx = crypto_tfm_ctx(tfm);\r\ncrypto_free_cipher(ctx->child);\r\n}\r\nstatic struct crypto_instance *crypto_kw_alloc(struct rtattr **tb)\r\n{\r\nstruct crypto_instance *inst = NULL;\r\nstruct crypto_alg *alg = NULL;\r\nint err;\r\nerr = crypto_check_attr_type(tb, CRYPTO_ALG_TYPE_BLKCIPHER);\r\nif (err)\r\nreturn ERR_PTR(err);\r\nalg = crypto_get_attr_alg(tb, CRYPTO_ALG_TYPE_CIPHER,\r\nCRYPTO_ALG_TYPE_MASK);\r\nif (IS_ERR(alg))\r\nreturn ERR_CAST(alg);\r\ninst = ERR_PTR(-EINVAL);\r\nif (alg->cra_blocksize != sizeof(struct crypto_kw_block))\r\ngoto err;\r\ninst = crypto_alloc_instance("kw", alg);\r\nif (IS_ERR(inst))\r\ngoto err;\r\ninst->alg.cra_flags = CRYPTO_ALG_TYPE_BLKCIPHER;\r\ninst->alg.cra_priority = alg->cra_priority;\r\ninst->alg.cra_blocksize = SEMIBSIZE;\r\ninst->alg.cra_alignmask = 0;\r\ninst->alg.cra_type = &crypto_blkcipher_type;\r\ninst->alg.cra_blkcipher.ivsize = SEMIBSIZE;\r\ninst->alg.cra_blkcipher.min_keysize = alg->cra_cipher.cia_min_keysize;\r\ninst->alg.cra_blkcipher.max_keysize = alg->cra_cipher.cia_max_keysize;\r\ninst->alg.cra_ctxsize = sizeof(struct crypto_kw_ctx);\r\ninst->alg.cra_init = crypto_kw_init_tfm;\r\ninst->alg.cra_exit = crypto_kw_exit_tfm;\r\ninst->alg.cra_blkcipher.setkey = crypto_kw_setkey;\r\ninst->alg.cra_blkcipher.encrypt = crypto_kw_encrypt;\r\ninst->alg.cra_blkcipher.decrypt = crypto_kw_decrypt;\r\nerr:\r\ncrypto_mod_put(alg);\r\nreturn inst;\r\n}\r\nstatic void crypto_kw_free(struct crypto_instance *inst)\r\n{\r\ncrypto_drop_spawn(crypto_instance_ctx(inst));\r\nkfree(inst);\r\n}\r\nstatic int __init crypto_kw_init(void)\r\n{\r\nreturn crypto_register_template(&crypto_kw_tmpl);\r\n}\r\nstatic void __exit crypto_kw_exit(void)\r\n{\r\ncrypto_unregister_template(&crypto_kw_tmpl);\r\n}
