static void armada_xp_clear_shared_l2(void)\r\n{\r\nu32 reg;\r\nif (!cpu_config_base)\r\nreturn;\r\nreg = readl(cpu_config_base);\r\nreg &= ~CPU_CONFIG_SHARED_L2;\r\nwritel(reg, cpu_config_base);\r\n}\r\nstatic int mvebu_hwcc_notifier(struct notifier_block *nb,\r\nunsigned long event, void *__dev)\r\n{\r\nstruct device *dev = __dev;\r\nif (event != BUS_NOTIFY_ADD_DEVICE)\r\nreturn NOTIFY_DONE;\r\nset_dma_ops(dev, &arm_coherent_dma_ops);\r\nreturn NOTIFY_OK;\r\n}\r\nstatic int armada_xp_clear_shared_l2_notifier_func(struct notifier_block *nfb,\r\nunsigned long action, void *hcpu)\r\n{\r\nif (action == CPU_STARTING || action == CPU_STARTING_FROZEN)\r\narmada_xp_clear_shared_l2();\r\nreturn NOTIFY_OK;\r\n}\r\nstatic void __init armada_370_coherency_init(struct device_node *np)\r\n{\r\nstruct resource res;\r\nstruct device_node *cpu_config_np;\r\nof_address_to_resource(np, 0, &res);\r\ncoherency_phys_base = res.start;\r\nsync_cache_w(&coherency_phys_base);\r\ncoherency_base = of_iomap(np, 0);\r\ncoherency_cpu_base = of_iomap(np, 1);\r\ncpu_config_np = of_find_compatible_node(NULL, NULL,\r\n"marvell,armada-xp-cpu-config");\r\nif (!cpu_config_np)\r\ngoto exit;\r\ncpu_config_base = of_iomap(cpu_config_np, 0);\r\nif (!cpu_config_base) {\r\nof_node_put(cpu_config_np);\r\ngoto exit;\r\n}\r\nof_node_put(cpu_config_np);\r\nregister_cpu_notifier(&armada_xp_clear_shared_l2_notifier);\r\nexit:\r\nset_cpu_coherent();\r\n}\r\nstatic void __iomem *\r\narmada_pcie_wa_ioremap_caller(phys_addr_t phys_addr, size_t size,\r\nunsigned int mtype, void *caller)\r\n{\r\nstruct resource pcie_mem;\r\nmvebu_mbus_get_pcie_mem_aperture(&pcie_mem);\r\nif (pcie_mem.start <= phys_addr && (phys_addr + size) <= pcie_mem.end)\r\nmtype = MT_UNCACHED;\r\nreturn __arm_ioremap_caller(phys_addr, size, mtype, caller);\r\n}\r\nstatic void __init armada_375_380_coherency_init(struct device_node *np)\r\n{\r\nstruct device_node *cache_dn;\r\ncoherency_cpu_base = of_iomap(np, 0);\r\narch_ioremap_caller = armada_pcie_wa_ioremap_caller;\r\nif (!coherency_available())\r\nreturn;\r\nfor_each_compatible_node(cache_dn, NULL, "arm,pl310-cache") {\r\nstruct property *p;\r\np = kzalloc(sizeof(*p), GFP_KERNEL);\r\np->name = kstrdup("arm,io-coherent", GFP_KERNEL);\r\nof_add_property(cache_dn, p);\r\n}\r\n}\r\nstatic int coherency_type(void)\r\n{\r\nstruct device_node *np;\r\nconst struct of_device_id *match;\r\nint type;\r\nif (!is_smp())\r\nreturn COHERENCY_FABRIC_TYPE_NONE;\r\nnp = of_find_matching_node_and_match(NULL, of_coherency_table, &match);\r\nif (!np)\r\nreturn COHERENCY_FABRIC_TYPE_NONE;\r\ntype = (int) match->data;\r\nof_node_put(np);\r\nreturn type;\r\n}\r\nint set_cpu_coherent(void)\r\n{\r\nint type = coherency_type();\r\nif (type == COHERENCY_FABRIC_TYPE_ARMADA_370_XP) {\r\nif (!coherency_base) {\r\npr_warn("Can't make current CPU cache coherent.\n");\r\npr_warn("Coherency fabric is not initialized\n");\r\nreturn 1;\r\n}\r\narmada_xp_clear_shared_l2();\r\nll_add_cpu_to_smp_group();\r\nreturn ll_enable_coherency();\r\n}\r\nreturn 0;\r\n}\r\nint coherency_available(void)\r\n{\r\nreturn coherency_type() != COHERENCY_FABRIC_TYPE_NONE;\r\n}\r\nint __init coherency_init(void)\r\n{\r\nint type = coherency_type();\r\nstruct device_node *np;\r\nnp = of_find_matching_node(NULL, of_coherency_table);\r\nif (type == COHERENCY_FABRIC_TYPE_ARMADA_370_XP)\r\narmada_370_coherency_init(np);\r\nelse if (type == COHERENCY_FABRIC_TYPE_ARMADA_375 ||\r\ntype == COHERENCY_FABRIC_TYPE_ARMADA_380)\r\narmada_375_380_coherency_init(np);\r\nof_node_put(np);\r\nreturn 0;\r\n}\r\nstatic int __init coherency_late_init(void)\r\n{\r\nif (coherency_available())\r\nbus_register_notifier(&platform_bus_type,\r\n&mvebu_hwcc_nb);\r\nreturn 0;\r\n}\r\nstatic int __init coherency_pci_init(void)\r\n{\r\nif (coherency_available())\r\nbus_register_notifier(&pci_bus_type,\r\n&mvebu_hwcc_pci_nb);\r\nreturn 0;\r\n}
