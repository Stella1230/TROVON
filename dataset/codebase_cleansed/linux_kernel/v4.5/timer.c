void timers_update_migration(bool update_nohz)\r\n{\r\nbool on = sysctl_timer_migration && tick_nohz_active;\r\nunsigned int cpu;\r\nif (this_cpu_read(tvec_bases.migration_enabled) == on)\r\nreturn;\r\nfor_each_possible_cpu(cpu) {\r\nper_cpu(tvec_bases.migration_enabled, cpu) = on;\r\nper_cpu(hrtimer_bases.migration_enabled, cpu) = on;\r\nif (!update_nohz)\r\ncontinue;\r\nper_cpu(tvec_bases.nohz_active, cpu) = true;\r\nper_cpu(hrtimer_bases.nohz_active, cpu) = true;\r\n}\r\n}\r\nint timer_migration_handler(struct ctl_table *table, int write,\r\nvoid __user *buffer, size_t *lenp,\r\nloff_t *ppos)\r\n{\r\nstatic DEFINE_MUTEX(mutex);\r\nint ret;\r\nmutex_lock(&mutex);\r\nret = proc_dointvec(table, write, buffer, lenp, ppos);\r\nif (!ret && write)\r\ntimers_update_migration(false);\r\nmutex_unlock(&mutex);\r\nreturn ret;\r\n}\r\nstatic inline struct tvec_base *get_target_base(struct tvec_base *base,\r\nint pinned)\r\n{\r\nif (pinned || !base->migration_enabled)\r\nreturn this_cpu_ptr(&tvec_bases);\r\nreturn per_cpu_ptr(&tvec_bases, get_nohz_timer_target());\r\n}\r\nstatic inline struct tvec_base *get_target_base(struct tvec_base *base,\r\nint pinned)\r\n{\r\nreturn this_cpu_ptr(&tvec_bases);\r\n}\r\nstatic unsigned long round_jiffies_common(unsigned long j, int cpu,\r\nbool force_up)\r\n{\r\nint rem;\r\nunsigned long original = j;\r\nj += cpu * 3;\r\nrem = j % HZ;\r\nif (rem < HZ/4 && !force_up)\r\nj = j - rem;\r\nelse\r\nj = j - rem + HZ;\r\nj -= cpu * 3;\r\nreturn time_is_after_jiffies(j) ? j : original;\r\n}\r\nunsigned long __round_jiffies(unsigned long j, int cpu)\r\n{\r\nreturn round_jiffies_common(j, cpu, false);\r\n}\r\nunsigned long __round_jiffies_relative(unsigned long j, int cpu)\r\n{\r\nunsigned long j0 = jiffies;\r\nreturn round_jiffies_common(j + j0, cpu, false) - j0;\r\n}\r\nunsigned long round_jiffies(unsigned long j)\r\n{\r\nreturn round_jiffies_common(j, raw_smp_processor_id(), false);\r\n}\r\nunsigned long round_jiffies_relative(unsigned long j)\r\n{\r\nreturn __round_jiffies_relative(j, raw_smp_processor_id());\r\n}\r\nunsigned long __round_jiffies_up(unsigned long j, int cpu)\r\n{\r\nreturn round_jiffies_common(j, cpu, true);\r\n}\r\nunsigned long __round_jiffies_up_relative(unsigned long j, int cpu)\r\n{\r\nunsigned long j0 = jiffies;\r\nreturn round_jiffies_common(j + j0, cpu, true) - j0;\r\n}\r\nunsigned long round_jiffies_up(unsigned long j)\r\n{\r\nreturn round_jiffies_common(j, raw_smp_processor_id(), true);\r\n}\r\nunsigned long round_jiffies_up_relative(unsigned long j)\r\n{\r\nreturn __round_jiffies_up_relative(j, raw_smp_processor_id());\r\n}\r\nvoid set_timer_slack(struct timer_list *timer, int slack_hz)\r\n{\r\ntimer->slack = slack_hz;\r\n}\r\nstatic void\r\n__internal_add_timer(struct tvec_base *base, struct timer_list *timer)\r\n{\r\nunsigned long expires = timer->expires;\r\nunsigned long idx = expires - base->timer_jiffies;\r\nstruct hlist_head *vec;\r\nif (idx < TVR_SIZE) {\r\nint i = expires & TVR_MASK;\r\nvec = base->tv1.vec + i;\r\n} else if (idx < 1 << (TVR_BITS + TVN_BITS)) {\r\nint i = (expires >> TVR_BITS) & TVN_MASK;\r\nvec = base->tv2.vec + i;\r\n} else if (idx < 1 << (TVR_BITS + 2 * TVN_BITS)) {\r\nint i = (expires >> (TVR_BITS + TVN_BITS)) & TVN_MASK;\r\nvec = base->tv3.vec + i;\r\n} else if (idx < 1 << (TVR_BITS + 3 * TVN_BITS)) {\r\nint i = (expires >> (TVR_BITS + 2 * TVN_BITS)) & TVN_MASK;\r\nvec = base->tv4.vec + i;\r\n} else if ((signed long) idx < 0) {\r\nvec = base->tv1.vec + (base->timer_jiffies & TVR_MASK);\r\n} else {\r\nint i;\r\nif (idx > MAX_TVAL) {\r\nidx = MAX_TVAL;\r\nexpires = idx + base->timer_jiffies;\r\n}\r\ni = (expires >> (TVR_BITS + 3 * TVN_BITS)) & TVN_MASK;\r\nvec = base->tv5.vec + i;\r\n}\r\nhlist_add_head(&timer->entry, vec);\r\n}\r\nstatic void internal_add_timer(struct tvec_base *base, struct timer_list *timer)\r\n{\r\nif (!base->all_timers++)\r\nbase->timer_jiffies = jiffies;\r\n__internal_add_timer(base, timer);\r\nif (!(timer->flags & TIMER_DEFERRABLE)) {\r\nif (!base->active_timers++ ||\r\ntime_before(timer->expires, base->next_timer))\r\nbase->next_timer = timer->expires;\r\n}\r\nif (base->nohz_active) {\r\nif (!(timer->flags & TIMER_DEFERRABLE) ||\r\ntick_nohz_full_cpu(base->cpu))\r\nwake_up_nohz_cpu(base->cpu);\r\n}\r\n}\r\nvoid __timer_stats_timer_set_start_info(struct timer_list *timer, void *addr)\r\n{\r\nif (timer->start_site)\r\nreturn;\r\ntimer->start_site = addr;\r\nmemcpy(timer->start_comm, current->comm, TASK_COMM_LEN);\r\ntimer->start_pid = current->pid;\r\n}\r\nstatic void timer_stats_account_timer(struct timer_list *timer)\r\n{\r\nvoid *site;\r\nsite = READ_ONCE(timer->start_site);\r\nif (likely(!site))\r\nreturn;\r\ntimer_stats_update_stats(timer, timer->start_pid, site,\r\ntimer->function, timer->start_comm,\r\ntimer->flags);\r\n}\r\nstatic void timer_stats_account_timer(struct timer_list *timer) {}\r\nstatic void *timer_debug_hint(void *addr)\r\n{\r\nreturn ((struct timer_list *) addr)->function;\r\n}\r\nstatic int timer_fixup_init(void *addr, enum debug_obj_state state)\r\n{\r\nstruct timer_list *timer = addr;\r\nswitch (state) {\r\ncase ODEBUG_STATE_ACTIVE:\r\ndel_timer_sync(timer);\r\ndebug_object_init(timer, &timer_debug_descr);\r\nreturn 1;\r\ndefault:\r\nreturn 0;\r\n}\r\n}\r\nstatic void stub_timer(unsigned long data)\r\n{\r\nWARN_ON(1);\r\n}\r\nstatic int timer_fixup_activate(void *addr, enum debug_obj_state state)\r\n{\r\nstruct timer_list *timer = addr;\r\nswitch (state) {\r\ncase ODEBUG_STATE_NOTAVAILABLE:\r\nif (timer->entry.pprev == NULL &&\r\ntimer->entry.next == TIMER_ENTRY_STATIC) {\r\ndebug_object_init(timer, &timer_debug_descr);\r\ndebug_object_activate(timer, &timer_debug_descr);\r\nreturn 0;\r\n} else {\r\nsetup_timer(timer, stub_timer, 0);\r\nreturn 1;\r\n}\r\nreturn 0;\r\ncase ODEBUG_STATE_ACTIVE:\r\nWARN_ON(1);\r\ndefault:\r\nreturn 0;\r\n}\r\n}\r\nstatic int timer_fixup_free(void *addr, enum debug_obj_state state)\r\n{\r\nstruct timer_list *timer = addr;\r\nswitch (state) {\r\ncase ODEBUG_STATE_ACTIVE:\r\ndel_timer_sync(timer);\r\ndebug_object_free(timer, &timer_debug_descr);\r\nreturn 1;\r\ndefault:\r\nreturn 0;\r\n}\r\n}\r\nstatic int timer_fixup_assert_init(void *addr, enum debug_obj_state state)\r\n{\r\nstruct timer_list *timer = addr;\r\nswitch (state) {\r\ncase ODEBUG_STATE_NOTAVAILABLE:\r\nif (timer->entry.next == TIMER_ENTRY_STATIC) {\r\ndebug_object_init(timer, &timer_debug_descr);\r\nreturn 0;\r\n} else {\r\nsetup_timer(timer, stub_timer, 0);\r\nreturn 1;\r\n}\r\ndefault:\r\nreturn 0;\r\n}\r\n}\r\nstatic inline void debug_timer_init(struct timer_list *timer)\r\n{\r\ndebug_object_init(timer, &timer_debug_descr);\r\n}\r\nstatic inline void debug_timer_activate(struct timer_list *timer)\r\n{\r\ndebug_object_activate(timer, &timer_debug_descr);\r\n}\r\nstatic inline void debug_timer_deactivate(struct timer_list *timer)\r\n{\r\ndebug_object_deactivate(timer, &timer_debug_descr);\r\n}\r\nstatic inline void debug_timer_free(struct timer_list *timer)\r\n{\r\ndebug_object_free(timer, &timer_debug_descr);\r\n}\r\nstatic inline void debug_timer_assert_init(struct timer_list *timer)\r\n{\r\ndebug_object_assert_init(timer, &timer_debug_descr);\r\n}\r\nvoid init_timer_on_stack_key(struct timer_list *timer, unsigned int flags,\r\nconst char *name, struct lock_class_key *key)\r\n{\r\ndebug_object_init_on_stack(timer, &timer_debug_descr);\r\ndo_init_timer(timer, flags, name, key);\r\n}\r\nvoid destroy_timer_on_stack(struct timer_list *timer)\r\n{\r\ndebug_object_free(timer, &timer_debug_descr);\r\n}\r\nstatic inline void debug_timer_init(struct timer_list *timer) { }\r\nstatic inline void debug_timer_activate(struct timer_list *timer) { }\r\nstatic inline void debug_timer_deactivate(struct timer_list *timer) { }\r\nstatic inline void debug_timer_assert_init(struct timer_list *timer) { }\r\nstatic inline void debug_init(struct timer_list *timer)\r\n{\r\ndebug_timer_init(timer);\r\ntrace_timer_init(timer);\r\n}\r\nstatic inline void\r\ndebug_activate(struct timer_list *timer, unsigned long expires)\r\n{\r\ndebug_timer_activate(timer);\r\ntrace_timer_start(timer, expires, timer->flags);\r\n}\r\nstatic inline void debug_deactivate(struct timer_list *timer)\r\n{\r\ndebug_timer_deactivate(timer);\r\ntrace_timer_cancel(timer);\r\n}\r\nstatic inline void debug_assert_init(struct timer_list *timer)\r\n{\r\ndebug_timer_assert_init(timer);\r\n}\r\nstatic void do_init_timer(struct timer_list *timer, unsigned int flags,\r\nconst char *name, struct lock_class_key *key)\r\n{\r\ntimer->entry.pprev = NULL;\r\ntimer->flags = flags | raw_smp_processor_id();\r\ntimer->slack = -1;\r\n#ifdef CONFIG_TIMER_STATS\r\ntimer->start_site = NULL;\r\ntimer->start_pid = -1;\r\nmemset(timer->start_comm, 0, TASK_COMM_LEN);\r\n#endif\r\nlockdep_init_map(&timer->lockdep_map, name, key, 0);\r\n}\r\nvoid init_timer_key(struct timer_list *timer, unsigned int flags,\r\nconst char *name, struct lock_class_key *key)\r\n{\r\ndebug_init(timer);\r\ndo_init_timer(timer, flags, name, key);\r\n}\r\nstatic inline void detach_timer(struct timer_list *timer, bool clear_pending)\r\n{\r\nstruct hlist_node *entry = &timer->entry;\r\ndebug_deactivate(timer);\r\n__hlist_del(entry);\r\nif (clear_pending)\r\nentry->pprev = NULL;\r\nentry->next = LIST_POISON2;\r\n}\r\nstatic inline void\r\ndetach_expired_timer(struct timer_list *timer, struct tvec_base *base)\r\n{\r\ndetach_timer(timer, true);\r\nif (!(timer->flags & TIMER_DEFERRABLE))\r\nbase->active_timers--;\r\nbase->all_timers--;\r\n}\r\nstatic int detach_if_pending(struct timer_list *timer, struct tvec_base *base,\r\nbool clear_pending)\r\n{\r\nif (!timer_pending(timer))\r\nreturn 0;\r\ndetach_timer(timer, clear_pending);\r\nif (!(timer->flags & TIMER_DEFERRABLE)) {\r\nbase->active_timers--;\r\nif (timer->expires == base->next_timer)\r\nbase->next_timer = base->timer_jiffies;\r\n}\r\nif (!--base->all_timers)\r\nbase->timer_jiffies = jiffies;\r\nreturn 1;\r\n}\r\nstatic struct tvec_base *lock_timer_base(struct timer_list *timer,\r\nunsigned long *flags)\r\n__acquires(timer->base->lock)\r\n{\r\nfor (;;) {\r\nu32 tf = timer->flags;\r\nstruct tvec_base *base;\r\nif (!(tf & TIMER_MIGRATING)) {\r\nbase = per_cpu_ptr(&tvec_bases, tf & TIMER_CPUMASK);\r\nspin_lock_irqsave(&base->lock, *flags);\r\nif (timer->flags == tf)\r\nreturn base;\r\nspin_unlock_irqrestore(&base->lock, *flags);\r\n}\r\ncpu_relax();\r\n}\r\n}\r\nstatic inline int\r\n__mod_timer(struct timer_list *timer, unsigned long expires,\r\nbool pending_only, int pinned)\r\n{\r\nstruct tvec_base *base, *new_base;\r\nunsigned long flags;\r\nint ret = 0;\r\ntimer_stats_timer_set_start_info(timer);\r\nBUG_ON(!timer->function);\r\nbase = lock_timer_base(timer, &flags);\r\nret = detach_if_pending(timer, base, false);\r\nif (!ret && pending_only)\r\ngoto out_unlock;\r\ndebug_activate(timer, expires);\r\nnew_base = get_target_base(base, pinned);\r\nif (base != new_base) {\r\nif (likely(base->running_timer != timer)) {\r\ntimer->flags |= TIMER_MIGRATING;\r\nspin_unlock(&base->lock);\r\nbase = new_base;\r\nspin_lock(&base->lock);\r\nWRITE_ONCE(timer->flags,\r\n(timer->flags & ~TIMER_BASEMASK) | base->cpu);\r\n}\r\n}\r\ntimer->expires = expires;\r\ninternal_add_timer(base, timer);\r\nout_unlock:\r\nspin_unlock_irqrestore(&base->lock, flags);\r\nreturn ret;\r\n}\r\nint mod_timer_pending(struct timer_list *timer, unsigned long expires)\r\n{\r\nreturn __mod_timer(timer, expires, true, TIMER_NOT_PINNED);\r\n}\r\nstatic inline\r\nunsigned long apply_slack(struct timer_list *timer, unsigned long expires)\r\n{\r\nunsigned long expires_limit, mask;\r\nint bit;\r\nif (timer->slack >= 0) {\r\nexpires_limit = expires + timer->slack;\r\n} else {\r\nlong delta = expires - jiffies;\r\nif (delta < 256)\r\nreturn expires;\r\nexpires_limit = expires + delta / 256;\r\n}\r\nmask = expires ^ expires_limit;\r\nif (mask == 0)\r\nreturn expires;\r\nbit = __fls(mask);\r\nmask = (1UL << bit) - 1;\r\nexpires_limit = expires_limit & ~(mask);\r\nreturn expires_limit;\r\n}\r\nint mod_timer(struct timer_list *timer, unsigned long expires)\r\n{\r\nexpires = apply_slack(timer, expires);\r\nif (timer_pending(timer) && timer->expires == expires)\r\nreturn 1;\r\nreturn __mod_timer(timer, expires, false, TIMER_NOT_PINNED);\r\n}\r\nint mod_timer_pinned(struct timer_list *timer, unsigned long expires)\r\n{\r\nif (timer->expires == expires && timer_pending(timer))\r\nreturn 1;\r\nreturn __mod_timer(timer, expires, false, TIMER_PINNED);\r\n}\r\nvoid add_timer(struct timer_list *timer)\r\n{\r\nBUG_ON(timer_pending(timer));\r\nmod_timer(timer, timer->expires);\r\n}\r\nvoid add_timer_on(struct timer_list *timer, int cpu)\r\n{\r\nstruct tvec_base *new_base = per_cpu_ptr(&tvec_bases, cpu);\r\nstruct tvec_base *base;\r\nunsigned long flags;\r\ntimer_stats_timer_set_start_info(timer);\r\nBUG_ON(timer_pending(timer) || !timer->function);\r\nbase = lock_timer_base(timer, &flags);\r\nif (base != new_base) {\r\ntimer->flags |= TIMER_MIGRATING;\r\nspin_unlock(&base->lock);\r\nbase = new_base;\r\nspin_lock(&base->lock);\r\nWRITE_ONCE(timer->flags,\r\n(timer->flags & ~TIMER_BASEMASK) | cpu);\r\n}\r\ndebug_activate(timer, timer->expires);\r\ninternal_add_timer(base, timer);\r\nspin_unlock_irqrestore(&base->lock, flags);\r\n}\r\nint del_timer(struct timer_list *timer)\r\n{\r\nstruct tvec_base *base;\r\nunsigned long flags;\r\nint ret = 0;\r\ndebug_assert_init(timer);\r\ntimer_stats_timer_clear_start_info(timer);\r\nif (timer_pending(timer)) {\r\nbase = lock_timer_base(timer, &flags);\r\nret = detach_if_pending(timer, base, true);\r\nspin_unlock_irqrestore(&base->lock, flags);\r\n}\r\nreturn ret;\r\n}\r\nint try_to_del_timer_sync(struct timer_list *timer)\r\n{\r\nstruct tvec_base *base;\r\nunsigned long flags;\r\nint ret = -1;\r\ndebug_assert_init(timer);\r\nbase = lock_timer_base(timer, &flags);\r\nif (base->running_timer != timer) {\r\ntimer_stats_timer_clear_start_info(timer);\r\nret = detach_if_pending(timer, base, true);\r\n}\r\nspin_unlock_irqrestore(&base->lock, flags);\r\nreturn ret;\r\n}\r\nint del_timer_sync(struct timer_list *timer)\r\n{\r\n#ifdef CONFIG_LOCKDEP\r\nunsigned long flags;\r\nlocal_irq_save(flags);\r\nlock_map_acquire(&timer->lockdep_map);\r\nlock_map_release(&timer->lockdep_map);\r\nlocal_irq_restore(flags);\r\n#endif\r\nWARN_ON(in_irq() && !(timer->flags & TIMER_IRQSAFE));\r\nfor (;;) {\r\nint ret = try_to_del_timer_sync(timer);\r\nif (ret >= 0)\r\nreturn ret;\r\ncpu_relax();\r\n}\r\n}\r\nstatic int cascade(struct tvec_base *base, struct tvec *tv, int index)\r\n{\r\nstruct timer_list *timer;\r\nstruct hlist_node *tmp;\r\nstruct hlist_head tv_list;\r\nhlist_move_list(tv->vec + index, &tv_list);\r\nhlist_for_each_entry_safe(timer, tmp, &tv_list, entry) {\r\n__internal_add_timer(base, timer);\r\n}\r\nreturn index;\r\n}\r\nstatic void call_timer_fn(struct timer_list *timer, void (*fn)(unsigned long),\r\nunsigned long data)\r\n{\r\nint count = preempt_count();\r\n#ifdef CONFIG_LOCKDEP\r\nstruct lockdep_map lockdep_map;\r\nlockdep_copy_map(&lockdep_map, &timer->lockdep_map);\r\n#endif\r\nlock_map_acquire(&lockdep_map);\r\ntrace_timer_expire_entry(timer);\r\nfn(data);\r\ntrace_timer_expire_exit(timer);\r\nlock_map_release(&lockdep_map);\r\nif (count != preempt_count()) {\r\nWARN_ONCE(1, "timer: %pF preempt leak: %08x -> %08x\n",\r\nfn, count, preempt_count());\r\npreempt_count_set(count);\r\n}\r\n}\r\nstatic inline void __run_timers(struct tvec_base *base)\r\n{\r\nstruct timer_list *timer;\r\nspin_lock_irq(&base->lock);\r\nwhile (time_after_eq(jiffies, base->timer_jiffies)) {\r\nstruct hlist_head work_list;\r\nstruct hlist_head *head = &work_list;\r\nint index;\r\nif (!base->all_timers) {\r\nbase->timer_jiffies = jiffies;\r\nbreak;\r\n}\r\nindex = base->timer_jiffies & TVR_MASK;\r\nif (!index &&\r\n(!cascade(base, &base->tv2, INDEX(0))) &&\r\n(!cascade(base, &base->tv3, INDEX(1))) &&\r\n!cascade(base, &base->tv4, INDEX(2)))\r\ncascade(base, &base->tv5, INDEX(3));\r\n++base->timer_jiffies;\r\nhlist_move_list(base->tv1.vec + index, head);\r\nwhile (!hlist_empty(head)) {\r\nvoid (*fn)(unsigned long);\r\nunsigned long data;\r\nbool irqsafe;\r\ntimer = hlist_entry(head->first, struct timer_list, entry);\r\nfn = timer->function;\r\ndata = timer->data;\r\nirqsafe = timer->flags & TIMER_IRQSAFE;\r\ntimer_stats_account_timer(timer);\r\nbase->running_timer = timer;\r\ndetach_expired_timer(timer, base);\r\nif (irqsafe) {\r\nspin_unlock(&base->lock);\r\ncall_timer_fn(timer, fn, data);\r\nspin_lock(&base->lock);\r\n} else {\r\nspin_unlock_irq(&base->lock);\r\ncall_timer_fn(timer, fn, data);\r\nspin_lock_irq(&base->lock);\r\n}\r\n}\r\n}\r\nbase->running_timer = NULL;\r\nspin_unlock_irq(&base->lock);\r\n}\r\nstatic unsigned long __next_timer_interrupt(struct tvec_base *base)\r\n{\r\nunsigned long timer_jiffies = base->timer_jiffies;\r\nunsigned long expires = timer_jiffies + NEXT_TIMER_MAX_DELTA;\r\nint index, slot, array, found = 0;\r\nstruct timer_list *nte;\r\nstruct tvec *varray[4];\r\nindex = slot = timer_jiffies & TVR_MASK;\r\ndo {\r\nhlist_for_each_entry(nte, base->tv1.vec + slot, entry) {\r\nif (nte->flags & TIMER_DEFERRABLE)\r\ncontinue;\r\nfound = 1;\r\nexpires = nte->expires;\r\nif (!index || slot < index)\r\ngoto cascade;\r\nreturn expires;\r\n}\r\nslot = (slot + 1) & TVR_MASK;\r\n} while (slot != index);\r\ncascade:\r\nif (index)\r\ntimer_jiffies += TVR_SIZE - index;\r\ntimer_jiffies >>= TVR_BITS;\r\nvarray[0] = &base->tv2;\r\nvarray[1] = &base->tv3;\r\nvarray[2] = &base->tv4;\r\nvarray[3] = &base->tv5;\r\nfor (array = 0; array < 4; array++) {\r\nstruct tvec *varp = varray[array];\r\nindex = slot = timer_jiffies & TVN_MASK;\r\ndo {\r\nhlist_for_each_entry(nte, varp->vec + slot, entry) {\r\nif (nte->flags & TIMER_DEFERRABLE)\r\ncontinue;\r\nfound = 1;\r\nif (time_before(nte->expires, expires))\r\nexpires = nte->expires;\r\n}\r\nif (found) {\r\nif (!index || slot < index)\r\nbreak;\r\nreturn expires;\r\n}\r\nslot = (slot + 1) & TVN_MASK;\r\n} while (slot != index);\r\nif (index)\r\ntimer_jiffies += TVN_SIZE - index;\r\ntimer_jiffies >>= TVN_BITS;\r\n}\r\nreturn expires;\r\n}\r\nstatic u64 cmp_next_hrtimer_event(u64 basem, u64 expires)\r\n{\r\nu64 nextevt = hrtimer_get_next_event();\r\nif (expires <= nextevt)\r\nreturn expires;\r\nif (nextevt <= basem)\r\nreturn basem;\r\nreturn DIV_ROUND_UP_ULL(nextevt, TICK_NSEC) * TICK_NSEC;\r\n}\r\nu64 get_next_timer_interrupt(unsigned long basej, u64 basem)\r\n{\r\nstruct tvec_base *base = this_cpu_ptr(&tvec_bases);\r\nu64 expires = KTIME_MAX;\r\nunsigned long nextevt;\r\nif (cpu_is_offline(smp_processor_id()))\r\nreturn expires;\r\nspin_lock(&base->lock);\r\nif (base->active_timers) {\r\nif (time_before_eq(base->next_timer, base->timer_jiffies))\r\nbase->next_timer = __next_timer_interrupt(base);\r\nnextevt = base->next_timer;\r\nif (time_before_eq(nextevt, basej))\r\nexpires = basem;\r\nelse\r\nexpires = basem + (nextevt - basej) * TICK_NSEC;\r\n}\r\nspin_unlock(&base->lock);\r\nreturn cmp_next_hrtimer_event(basem, expires);\r\n}\r\nvoid update_process_times(int user_tick)\r\n{\r\nstruct task_struct *p = current;\r\naccount_process_tick(p, user_tick);\r\nrun_local_timers();\r\nrcu_check_callbacks(user_tick);\r\n#ifdef CONFIG_IRQ_WORK\r\nif (in_irq())\r\nirq_work_tick();\r\n#endif\r\nscheduler_tick();\r\nrun_posix_cpu_timers(p);\r\n}\r\nstatic void run_timer_softirq(struct softirq_action *h)\r\n{\r\nstruct tvec_base *base = this_cpu_ptr(&tvec_bases);\r\nif (time_after_eq(jiffies, base->timer_jiffies))\r\n__run_timers(base);\r\n}\r\nvoid run_local_timers(void)\r\n{\r\nhrtimer_run_queues();\r\nraise_softirq(TIMER_SOFTIRQ);\r\n}\r\nstatic void process_timeout(unsigned long __data)\r\n{\r\nwake_up_process((struct task_struct *)__data);\r\n}\r\nsigned long __sched schedule_timeout(signed long timeout)\r\n{\r\nstruct timer_list timer;\r\nunsigned long expire;\r\nswitch (timeout)\r\n{\r\ncase MAX_SCHEDULE_TIMEOUT:\r\nschedule();\r\ngoto out;\r\ndefault:\r\nif (timeout < 0) {\r\nprintk(KERN_ERR "schedule_timeout: wrong timeout "\r\n"value %lx\n", timeout);\r\ndump_stack();\r\ncurrent->state = TASK_RUNNING;\r\ngoto out;\r\n}\r\n}\r\nexpire = timeout + jiffies;\r\nsetup_timer_on_stack(&timer, process_timeout, (unsigned long)current);\r\n__mod_timer(&timer, expire, false, TIMER_NOT_PINNED);\r\nschedule();\r\ndel_singleshot_timer_sync(&timer);\r\ndestroy_timer_on_stack(&timer);\r\ntimeout = expire - jiffies;\r\nout:\r\nreturn timeout < 0 ? 0 : timeout;\r\n}\r\nsigned long __sched schedule_timeout_interruptible(signed long timeout)\r\n{\r\n__set_current_state(TASK_INTERRUPTIBLE);\r\nreturn schedule_timeout(timeout);\r\n}\r\nsigned long __sched schedule_timeout_killable(signed long timeout)\r\n{\r\n__set_current_state(TASK_KILLABLE);\r\nreturn schedule_timeout(timeout);\r\n}\r\nsigned long __sched schedule_timeout_uninterruptible(signed long timeout)\r\n{\r\n__set_current_state(TASK_UNINTERRUPTIBLE);\r\nreturn schedule_timeout(timeout);\r\n}\r\nstatic void migrate_timer_list(struct tvec_base *new_base, struct hlist_head *head)\r\n{\r\nstruct timer_list *timer;\r\nint cpu = new_base->cpu;\r\nwhile (!hlist_empty(head)) {\r\ntimer = hlist_entry(head->first, struct timer_list, entry);\r\ndetach_timer(timer, false);\r\ntimer->flags = (timer->flags & ~TIMER_BASEMASK) | cpu;\r\ninternal_add_timer(new_base, timer);\r\n}\r\n}\r\nstatic void migrate_timers(int cpu)\r\n{\r\nstruct tvec_base *old_base;\r\nstruct tvec_base *new_base;\r\nint i;\r\nBUG_ON(cpu_online(cpu));\r\nold_base = per_cpu_ptr(&tvec_bases, cpu);\r\nnew_base = get_cpu_ptr(&tvec_bases);\r\nspin_lock_irq(&new_base->lock);\r\nspin_lock_nested(&old_base->lock, SINGLE_DEPTH_NESTING);\r\nBUG_ON(old_base->running_timer);\r\nfor (i = 0; i < TVR_SIZE; i++)\r\nmigrate_timer_list(new_base, old_base->tv1.vec + i);\r\nfor (i = 0; i < TVN_SIZE; i++) {\r\nmigrate_timer_list(new_base, old_base->tv2.vec + i);\r\nmigrate_timer_list(new_base, old_base->tv3.vec + i);\r\nmigrate_timer_list(new_base, old_base->tv4.vec + i);\r\nmigrate_timer_list(new_base, old_base->tv5.vec + i);\r\n}\r\nold_base->active_timers = 0;\r\nold_base->all_timers = 0;\r\nspin_unlock(&old_base->lock);\r\nspin_unlock_irq(&new_base->lock);\r\nput_cpu_ptr(&tvec_bases);\r\n}\r\nstatic int timer_cpu_notify(struct notifier_block *self,\r\nunsigned long action, void *hcpu)\r\n{\r\nswitch (action) {\r\ncase CPU_DEAD:\r\ncase CPU_DEAD_FROZEN:\r\nmigrate_timers((long)hcpu);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nreturn NOTIFY_OK;\r\n}\r\nstatic inline void timer_register_cpu_notifier(void)\r\n{\r\ncpu_notifier(timer_cpu_notify, 0);\r\n}\r\nstatic inline void timer_register_cpu_notifier(void) { }\r\nstatic void __init init_timer_cpu(int cpu)\r\n{\r\nstruct tvec_base *base = per_cpu_ptr(&tvec_bases, cpu);\r\nbase->cpu = cpu;\r\nspin_lock_init(&base->lock);\r\nbase->timer_jiffies = jiffies;\r\nbase->next_timer = base->timer_jiffies;\r\n}\r\nstatic void __init init_timer_cpus(void)\r\n{\r\nint cpu;\r\nfor_each_possible_cpu(cpu)\r\ninit_timer_cpu(cpu);\r\n}\r\nvoid __init init_timers(void)\r\n{\r\ninit_timer_cpus();\r\ninit_timer_stats();\r\ntimer_register_cpu_notifier();\r\nopen_softirq(TIMER_SOFTIRQ, run_timer_softirq);\r\n}\r\nvoid msleep(unsigned int msecs)\r\n{\r\nunsigned long timeout = msecs_to_jiffies(msecs) + 1;\r\nwhile (timeout)\r\ntimeout = schedule_timeout_uninterruptible(timeout);\r\n}\r\nunsigned long msleep_interruptible(unsigned int msecs)\r\n{\r\nunsigned long timeout = msecs_to_jiffies(msecs) + 1;\r\nwhile (timeout && !signal_pending(current))\r\ntimeout = schedule_timeout_interruptible(timeout);\r\nreturn jiffies_to_msecs(timeout);\r\n}\r\nstatic void __sched do_usleep_range(unsigned long min, unsigned long max)\r\n{\r\nktime_t kmin;\r\nunsigned long delta;\r\nkmin = ktime_set(0, min * NSEC_PER_USEC);\r\ndelta = (max - min) * NSEC_PER_USEC;\r\nschedule_hrtimeout_range(&kmin, delta, HRTIMER_MODE_REL);\r\n}\r\nvoid __sched usleep_range(unsigned long min, unsigned long max)\r\n{\r\n__set_current_state(TASK_UNINTERRUPTIBLE);\r\ndo_usleep_range(min, max);\r\n}
