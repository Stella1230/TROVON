static inline void ocfs2_control_set_handshake_state(struct file *file,\r\nint state)\r\n{\r\nstruct ocfs2_control_private *p = file->private_data;\r\np->op_state = state;\r\n}\r\nstatic inline int ocfs2_control_get_handshake_state(struct file *file)\r\n{\r\nstruct ocfs2_control_private *p = file->private_data;\r\nreturn p->op_state;\r\n}\r\nstatic struct ocfs2_live_connection *ocfs2_connection_find(const char *name)\r\n{\r\nsize_t len = strlen(name);\r\nstruct ocfs2_live_connection *c;\r\nBUG_ON(!mutex_is_locked(&ocfs2_control_lock));\r\nlist_for_each_entry(c, &ocfs2_live_connection_list, oc_list) {\r\nif ((c->oc_conn->cc_namelen == len) &&\r\n!strncmp(c->oc_conn->cc_name, name, len))\r\nreturn c;\r\n}\r\nreturn NULL;\r\n}\r\nstatic int ocfs2_live_connection_attach(struct ocfs2_cluster_connection *conn,\r\nstruct ocfs2_live_connection *c)\r\n{\r\nint rc = 0;\r\nmutex_lock(&ocfs2_control_lock);\r\nc->oc_conn = conn;\r\nif ((c->oc_type == NO_CONTROLD) || atomic_read(&ocfs2_control_opened))\r\nlist_add(&c->oc_list, &ocfs2_live_connection_list);\r\nelse {\r\nprintk(KERN_ERR\r\n"ocfs2: Userspace control daemon is not present\n");\r\nrc = -ESRCH;\r\n}\r\nmutex_unlock(&ocfs2_control_lock);\r\nreturn rc;\r\n}\r\nstatic void ocfs2_live_connection_drop(struct ocfs2_live_connection *c)\r\n{\r\nmutex_lock(&ocfs2_control_lock);\r\nlist_del_init(&c->oc_list);\r\nc->oc_conn = NULL;\r\nmutex_unlock(&ocfs2_control_lock);\r\nkfree(c);\r\n}\r\nstatic int ocfs2_control_cfu(void *target, size_t target_len,\r\nconst char __user *buf, size_t count)\r\n{\r\nif ((count != target_len) ||\r\n(count > sizeof(union ocfs2_control_message)))\r\nreturn -EINVAL;\r\nif (copy_from_user(target, buf, target_len))\r\nreturn -EFAULT;\r\nreturn 0;\r\n}\r\nstatic ssize_t ocfs2_control_validate_protocol(struct file *file,\r\nconst char __user *buf,\r\nsize_t count)\r\n{\r\nssize_t ret;\r\nchar kbuf[OCFS2_CONTROL_PROTO_LEN];\r\nret = ocfs2_control_cfu(kbuf, OCFS2_CONTROL_PROTO_LEN,\r\nbuf, count);\r\nif (ret)\r\nreturn ret;\r\nif (strncmp(kbuf, OCFS2_CONTROL_PROTO, OCFS2_CONTROL_PROTO_LEN))\r\nreturn -EINVAL;\r\nocfs2_control_set_handshake_state(file,\r\nOCFS2_CONTROL_HANDSHAKE_PROTOCOL);\r\nreturn count;\r\n}\r\nstatic void ocfs2_control_send_down(const char *uuid,\r\nint nodenum)\r\n{\r\nstruct ocfs2_live_connection *c;\r\nmutex_lock(&ocfs2_control_lock);\r\nc = ocfs2_connection_find(uuid);\r\nif (c) {\r\nBUG_ON(c->oc_conn == NULL);\r\nc->oc_conn->cc_recovery_handler(nodenum,\r\nc->oc_conn->cc_recovery_data);\r\n}\r\nmutex_unlock(&ocfs2_control_lock);\r\n}\r\nstatic int ocfs2_control_install_private(struct file *file)\r\n{\r\nint rc = 0;\r\nint set_p = 1;\r\nstruct ocfs2_control_private *p = file->private_data;\r\nBUG_ON(p->op_state != OCFS2_CONTROL_HANDSHAKE_PROTOCOL);\r\nmutex_lock(&ocfs2_control_lock);\r\nif (p->op_this_node < 0) {\r\nset_p = 0;\r\n} else if ((ocfs2_control_this_node >= 0) &&\r\n(ocfs2_control_this_node != p->op_this_node)) {\r\nrc = -EINVAL;\r\ngoto out_unlock;\r\n}\r\nif (!p->op_proto.pv_major) {\r\nset_p = 0;\r\n} else if (!list_empty(&ocfs2_live_connection_list) &&\r\n((running_proto.pv_major != p->op_proto.pv_major) ||\r\n(running_proto.pv_minor != p->op_proto.pv_minor))) {\r\nrc = -EINVAL;\r\ngoto out_unlock;\r\n}\r\nif (set_p) {\r\nocfs2_control_this_node = p->op_this_node;\r\nrunning_proto.pv_major = p->op_proto.pv_major;\r\nrunning_proto.pv_minor = p->op_proto.pv_minor;\r\n}\r\nout_unlock:\r\nmutex_unlock(&ocfs2_control_lock);\r\nif (!rc && set_p) {\r\natomic_inc(&ocfs2_control_opened);\r\nocfs2_control_set_handshake_state(file,\r\nOCFS2_CONTROL_HANDSHAKE_VALID);\r\n}\r\nreturn rc;\r\n}\r\nstatic int ocfs2_control_get_this_node(void)\r\n{\r\nint rc;\r\nmutex_lock(&ocfs2_control_lock);\r\nif (ocfs2_control_this_node < 0)\r\nrc = -EINVAL;\r\nelse\r\nrc = ocfs2_control_this_node;\r\nmutex_unlock(&ocfs2_control_lock);\r\nreturn rc;\r\n}\r\nstatic int ocfs2_control_do_setnode_msg(struct file *file,\r\nstruct ocfs2_control_message_setn *msg)\r\n{\r\nlong nodenum;\r\nchar *ptr = NULL;\r\nstruct ocfs2_control_private *p = file->private_data;\r\nif (ocfs2_control_get_handshake_state(file) !=\r\nOCFS2_CONTROL_HANDSHAKE_PROTOCOL)\r\nreturn -EINVAL;\r\nif (strncmp(msg->tag, OCFS2_CONTROL_MESSAGE_SETNODE_OP,\r\nOCFS2_CONTROL_MESSAGE_OP_LEN))\r\nreturn -EINVAL;\r\nif ((msg->space != ' ') || (msg->newline != '\n'))\r\nreturn -EINVAL;\r\nmsg->space = msg->newline = '\0';\r\nnodenum = simple_strtol(msg->nodestr, &ptr, 16);\r\nif (!ptr || *ptr)\r\nreturn -EINVAL;\r\nif ((nodenum == LONG_MIN) || (nodenum == LONG_MAX) ||\r\n(nodenum > INT_MAX) || (nodenum < 0))\r\nreturn -ERANGE;\r\np->op_this_node = nodenum;\r\nreturn ocfs2_control_install_private(file);\r\n}\r\nstatic int ocfs2_control_do_setversion_msg(struct file *file,\r\nstruct ocfs2_control_message_setv *msg)\r\n{\r\nlong major, minor;\r\nchar *ptr = NULL;\r\nstruct ocfs2_control_private *p = file->private_data;\r\nstruct ocfs2_protocol_version *max =\r\n&ocfs2_user_plugin.sp_max_proto;\r\nif (ocfs2_control_get_handshake_state(file) !=\r\nOCFS2_CONTROL_HANDSHAKE_PROTOCOL)\r\nreturn -EINVAL;\r\nif (strncmp(msg->tag, OCFS2_CONTROL_MESSAGE_SETVERSION_OP,\r\nOCFS2_CONTROL_MESSAGE_OP_LEN))\r\nreturn -EINVAL;\r\nif ((msg->space1 != ' ') || (msg->space2 != ' ') ||\r\n(msg->newline != '\n'))\r\nreturn -EINVAL;\r\nmsg->space1 = msg->space2 = msg->newline = '\0';\r\nmajor = simple_strtol(msg->major, &ptr, 16);\r\nif (!ptr || *ptr)\r\nreturn -EINVAL;\r\nminor = simple_strtol(msg->minor, &ptr, 16);\r\nif (!ptr || *ptr)\r\nreturn -EINVAL;\r\nif ((major == LONG_MIN) || (major == LONG_MAX) ||\r\n(major > (u8)-1) || (major < 1))\r\nreturn -ERANGE;\r\nif ((minor == LONG_MIN) || (minor == LONG_MAX) ||\r\n(minor > (u8)-1) || (minor < 0))\r\nreturn -ERANGE;\r\nif ((major != max->pv_major) ||\r\n(minor > max->pv_minor))\r\nreturn -EINVAL;\r\np->op_proto.pv_major = major;\r\np->op_proto.pv_minor = minor;\r\nreturn ocfs2_control_install_private(file);\r\n}\r\nstatic int ocfs2_control_do_down_msg(struct file *file,\r\nstruct ocfs2_control_message_down *msg)\r\n{\r\nlong nodenum;\r\nchar *p = NULL;\r\nif (ocfs2_control_get_handshake_state(file) !=\r\nOCFS2_CONTROL_HANDSHAKE_VALID)\r\nreturn -EINVAL;\r\nif (strncmp(msg->tag, OCFS2_CONTROL_MESSAGE_DOWN_OP,\r\nOCFS2_CONTROL_MESSAGE_OP_LEN))\r\nreturn -EINVAL;\r\nif ((msg->space1 != ' ') || (msg->space2 != ' ') ||\r\n(msg->newline != '\n'))\r\nreturn -EINVAL;\r\nmsg->space1 = msg->space2 = msg->newline = '\0';\r\nnodenum = simple_strtol(msg->nodestr, &p, 16);\r\nif (!p || *p)\r\nreturn -EINVAL;\r\nif ((nodenum == LONG_MIN) || (nodenum == LONG_MAX) ||\r\n(nodenum > INT_MAX) || (nodenum < 0))\r\nreturn -ERANGE;\r\nocfs2_control_send_down(msg->uuid, nodenum);\r\nreturn 0;\r\n}\r\nstatic ssize_t ocfs2_control_message(struct file *file,\r\nconst char __user *buf,\r\nsize_t count)\r\n{\r\nssize_t ret;\r\nunion ocfs2_control_message msg;\r\nWARN_ON(offsetof(struct ocfs2_control_message_down, uuid) !=\r\n(sizeof(msg.u_down.tag) + sizeof(msg.u_down.space1)));\r\nmemset(&msg, 0, sizeof(union ocfs2_control_message));\r\nret = ocfs2_control_cfu(&msg, count, buf, count);\r\nif (ret)\r\ngoto out;\r\nif ((count == OCFS2_CONTROL_MESSAGE_SETNODE_TOTAL_LEN) &&\r\n!strncmp(msg.tag, OCFS2_CONTROL_MESSAGE_SETNODE_OP,\r\nOCFS2_CONTROL_MESSAGE_OP_LEN))\r\nret = ocfs2_control_do_setnode_msg(file, &msg.u_setn);\r\nelse if ((count == OCFS2_CONTROL_MESSAGE_SETVERSION_TOTAL_LEN) &&\r\n!strncmp(msg.tag, OCFS2_CONTROL_MESSAGE_SETVERSION_OP,\r\nOCFS2_CONTROL_MESSAGE_OP_LEN))\r\nret = ocfs2_control_do_setversion_msg(file, &msg.u_setv);\r\nelse if ((count == OCFS2_CONTROL_MESSAGE_DOWN_TOTAL_LEN) &&\r\n!strncmp(msg.tag, OCFS2_CONTROL_MESSAGE_DOWN_OP,\r\nOCFS2_CONTROL_MESSAGE_OP_LEN))\r\nret = ocfs2_control_do_down_msg(file, &msg.u_down);\r\nelse\r\nret = -EINVAL;\r\nout:\r\nreturn ret ? ret : count;\r\n}\r\nstatic ssize_t ocfs2_control_write(struct file *file,\r\nconst char __user *buf,\r\nsize_t count,\r\nloff_t *ppos)\r\n{\r\nssize_t ret;\r\nswitch (ocfs2_control_get_handshake_state(file)) {\r\ncase OCFS2_CONTROL_HANDSHAKE_INVALID:\r\nret = -EINVAL;\r\nbreak;\r\ncase OCFS2_CONTROL_HANDSHAKE_READ:\r\nret = ocfs2_control_validate_protocol(file, buf,\r\ncount);\r\nbreak;\r\ncase OCFS2_CONTROL_HANDSHAKE_PROTOCOL:\r\ncase OCFS2_CONTROL_HANDSHAKE_VALID:\r\nret = ocfs2_control_message(file, buf, count);\r\nbreak;\r\ndefault:\r\nBUG();\r\nret = -EIO;\r\nbreak;\r\n}\r\nreturn ret;\r\n}\r\nstatic ssize_t ocfs2_control_read(struct file *file,\r\nchar __user *buf,\r\nsize_t count,\r\nloff_t *ppos)\r\n{\r\nssize_t ret;\r\nret = simple_read_from_buffer(buf, count, ppos,\r\nOCFS2_CONTROL_PROTO, OCFS2_CONTROL_PROTO_LEN);\r\nif (ret > 0 && *ppos >= OCFS2_CONTROL_PROTO_LEN)\r\nocfs2_control_set_handshake_state(file,\r\nOCFS2_CONTROL_HANDSHAKE_READ);\r\nreturn ret;\r\n}\r\nstatic int ocfs2_control_release(struct inode *inode, struct file *file)\r\n{\r\nstruct ocfs2_control_private *p = file->private_data;\r\nmutex_lock(&ocfs2_control_lock);\r\nif (ocfs2_control_get_handshake_state(file) !=\r\nOCFS2_CONTROL_HANDSHAKE_VALID)\r\ngoto out;\r\nif (atomic_dec_and_test(&ocfs2_control_opened)) {\r\nif (!list_empty(&ocfs2_live_connection_list)) {\r\nprintk(KERN_ERR\r\n"ocfs2: Unexpected release of ocfs2_control!\n"\r\n" Loss of cluster connection requires "\r\n"an emergency restart!\n");\r\nemergency_restart();\r\n}\r\nocfs2_control_this_node = -1;\r\nrunning_proto.pv_major = 0;\r\nrunning_proto.pv_minor = 0;\r\n}\r\nout:\r\nlist_del_init(&p->op_list);\r\nfile->private_data = NULL;\r\nmutex_unlock(&ocfs2_control_lock);\r\nkfree(p);\r\nreturn 0;\r\n}\r\nstatic int ocfs2_control_open(struct inode *inode, struct file *file)\r\n{\r\nstruct ocfs2_control_private *p;\r\np = kzalloc(sizeof(struct ocfs2_control_private), GFP_KERNEL);\r\nif (!p)\r\nreturn -ENOMEM;\r\np->op_this_node = -1;\r\nmutex_lock(&ocfs2_control_lock);\r\nfile->private_data = p;\r\nlist_add(&p->op_list, &ocfs2_control_private_list);\r\nmutex_unlock(&ocfs2_control_lock);\r\nreturn 0;\r\n}\r\nstatic int ocfs2_control_init(void)\r\n{\r\nint rc;\r\natomic_set(&ocfs2_control_opened, 0);\r\nrc = misc_register(&ocfs2_control_device);\r\nif (rc)\r\nprintk(KERN_ERR\r\n"ocfs2: Unable to register ocfs2_control device "\r\n"(errno %d)\n",\r\n-rc);\r\nreturn rc;\r\n}\r\nstatic void ocfs2_control_exit(void)\r\n{\r\nmisc_deregister(&ocfs2_control_device);\r\n}\r\nstatic void fsdlm_lock_ast_wrapper(void *astarg)\r\n{\r\nstruct ocfs2_dlm_lksb *lksb = astarg;\r\nint status = lksb->lksb_fsdlm.sb_status;\r\nif (status == -DLM_EUNLOCK || status == -DLM_ECANCEL)\r\nlksb->lksb_conn->cc_proto->lp_unlock_ast(lksb, 0);\r\nelse\r\nlksb->lksb_conn->cc_proto->lp_lock_ast(lksb);\r\n}\r\nstatic void fsdlm_blocking_ast_wrapper(void *astarg, int level)\r\n{\r\nstruct ocfs2_dlm_lksb *lksb = astarg;\r\nlksb->lksb_conn->cc_proto->lp_blocking_ast(lksb, level);\r\n}\r\nstatic int user_dlm_lock(struct ocfs2_cluster_connection *conn,\r\nint mode,\r\nstruct ocfs2_dlm_lksb *lksb,\r\nu32 flags,\r\nvoid *name,\r\nunsigned int namelen)\r\n{\r\nint ret;\r\nif (!lksb->lksb_fsdlm.sb_lvbptr)\r\nlksb->lksb_fsdlm.sb_lvbptr = (char *)lksb +\r\nsizeof(struct dlm_lksb);\r\nret = dlm_lock(conn->cc_lockspace, mode, &lksb->lksb_fsdlm,\r\nflags|DLM_LKF_NODLCKWT, name, namelen, 0,\r\nfsdlm_lock_ast_wrapper, lksb,\r\nfsdlm_blocking_ast_wrapper);\r\nreturn ret;\r\n}\r\nstatic int user_dlm_unlock(struct ocfs2_cluster_connection *conn,\r\nstruct ocfs2_dlm_lksb *lksb,\r\nu32 flags)\r\n{\r\nint ret;\r\nret = dlm_unlock(conn->cc_lockspace, lksb->lksb_fsdlm.sb_lkid,\r\nflags, &lksb->lksb_fsdlm, lksb);\r\nreturn ret;\r\n}\r\nstatic int user_dlm_lock_status(struct ocfs2_dlm_lksb *lksb)\r\n{\r\nreturn lksb->lksb_fsdlm.sb_status;\r\n}\r\nstatic int user_dlm_lvb_valid(struct ocfs2_dlm_lksb *lksb)\r\n{\r\nint invalid = lksb->lksb_fsdlm.sb_flags & DLM_SBF_VALNOTVALID;\r\nreturn !invalid;\r\n}\r\nstatic void *user_dlm_lvb(struct ocfs2_dlm_lksb *lksb)\r\n{\r\nif (!lksb->lksb_fsdlm.sb_lvbptr)\r\nlksb->lksb_fsdlm.sb_lvbptr = (char *)lksb +\r\nsizeof(struct dlm_lksb);\r\nreturn (void *)(lksb->lksb_fsdlm.sb_lvbptr);\r\n}\r\nstatic void user_dlm_dump_lksb(struct ocfs2_dlm_lksb *lksb)\r\n{\r\n}\r\nstatic int user_plock(struct ocfs2_cluster_connection *conn,\r\nu64 ino,\r\nstruct file *file,\r\nint cmd,\r\nstruct file_lock *fl)\r\n{\r\nif (cmd == F_CANCELLK) {\r\ncmd = F_SETLK;\r\nfl->fl_type = F_UNLCK;\r\n}\r\nif (IS_GETLK(cmd))\r\nreturn dlm_posix_get(conn->cc_lockspace, ino, file, fl);\r\nelse if (fl->fl_type == F_UNLCK)\r\nreturn dlm_posix_unlock(conn->cc_lockspace, ino, file, fl);\r\nelse\r\nreturn dlm_posix_lock(conn->cc_lockspace, ino, file, cmd, fl);\r\n}\r\nstatic int fs_protocol_compare(struct ocfs2_protocol_version *existing,\r\nstruct ocfs2_protocol_version *request)\r\n{\r\nif (existing->pv_major != request->pv_major)\r\nreturn 1;\r\nif (existing->pv_minor > request->pv_minor)\r\nreturn 1;\r\nif (existing->pv_minor < request->pv_minor)\r\nrequest->pv_minor = existing->pv_minor;\r\nreturn 0;\r\n}\r\nstatic void lvb_to_version(char *lvb, struct ocfs2_protocol_version *ver)\r\n{\r\nstruct ocfs2_protocol_version *pv =\r\n(struct ocfs2_protocol_version *)lvb;\r\nver->pv_major = pv->pv_major;\r\nver->pv_minor = pv->pv_minor;\r\n}\r\nstatic void version_to_lvb(struct ocfs2_protocol_version *ver, char *lvb)\r\n{\r\nstruct ocfs2_protocol_version *pv =\r\n(struct ocfs2_protocol_version *)lvb;\r\npv->pv_major = ver->pv_major;\r\npv->pv_minor = ver->pv_minor;\r\n}\r\nstatic void sync_wait_cb(void *arg)\r\n{\r\nstruct ocfs2_cluster_connection *conn = arg;\r\nstruct ocfs2_live_connection *lc = conn->cc_private;\r\ncomplete(&lc->oc_sync_wait);\r\n}\r\nstatic int sync_unlock(struct ocfs2_cluster_connection *conn,\r\nstruct dlm_lksb *lksb, char *name)\r\n{\r\nint error;\r\nstruct ocfs2_live_connection *lc = conn->cc_private;\r\nerror = dlm_unlock(conn->cc_lockspace, lksb->sb_lkid, 0, lksb, conn);\r\nif (error) {\r\nprintk(KERN_ERR "%s lkid %x error %d\n",\r\nname, lksb->sb_lkid, error);\r\nreturn error;\r\n}\r\nwait_for_completion(&lc->oc_sync_wait);\r\nif (lksb->sb_status != -DLM_EUNLOCK) {\r\nprintk(KERN_ERR "%s lkid %x status %d\n",\r\nname, lksb->sb_lkid, lksb->sb_status);\r\nreturn -1;\r\n}\r\nreturn 0;\r\n}\r\nstatic int sync_lock(struct ocfs2_cluster_connection *conn,\r\nint mode, uint32_t flags,\r\nstruct dlm_lksb *lksb, char *name)\r\n{\r\nint error, status;\r\nstruct ocfs2_live_connection *lc = conn->cc_private;\r\nerror = dlm_lock(conn->cc_lockspace, mode, lksb, flags,\r\nname, strlen(name),\r\n0, sync_wait_cb, conn, NULL);\r\nif (error) {\r\nprintk(KERN_ERR "%s lkid %x flags %x mode %d error %d\n",\r\nname, lksb->sb_lkid, flags, mode, error);\r\nreturn error;\r\n}\r\nwait_for_completion(&lc->oc_sync_wait);\r\nstatus = lksb->sb_status;\r\nif (status && status != -EAGAIN) {\r\nprintk(KERN_ERR "%s lkid %x flags %x mode %d status %d\n",\r\nname, lksb->sb_lkid, flags, mode, status);\r\n}\r\nreturn status;\r\n}\r\nstatic int version_lock(struct ocfs2_cluster_connection *conn, int mode,\r\nint flags)\r\n{\r\nstruct ocfs2_live_connection *lc = conn->cc_private;\r\nreturn sync_lock(conn, mode, flags,\r\n&lc->oc_version_lksb, VERSION_LOCK);\r\n}\r\nstatic int version_unlock(struct ocfs2_cluster_connection *conn)\r\n{\r\nstruct ocfs2_live_connection *lc = conn->cc_private;\r\nreturn sync_unlock(conn, &lc->oc_version_lksb, VERSION_LOCK);\r\n}\r\nstatic int get_protocol_version(struct ocfs2_cluster_connection *conn)\r\n{\r\nint ret;\r\nstruct ocfs2_live_connection *lc = conn->cc_private;\r\nstruct ocfs2_protocol_version pv;\r\nrunning_proto.pv_major =\r\nocfs2_user_plugin.sp_max_proto.pv_major;\r\nrunning_proto.pv_minor =\r\nocfs2_user_plugin.sp_max_proto.pv_minor;\r\nlc->oc_version_lksb.sb_lvbptr = lc->oc_lvb;\r\nret = version_lock(conn, DLM_LOCK_EX,\r\nDLM_LKF_VALBLK|DLM_LKF_NOQUEUE);\r\nif (!ret) {\r\nconn->cc_version.pv_major = running_proto.pv_major;\r\nconn->cc_version.pv_minor = running_proto.pv_minor;\r\nversion_to_lvb(&running_proto, lc->oc_lvb);\r\nversion_lock(conn, DLM_LOCK_PR, DLM_LKF_CONVERT|DLM_LKF_VALBLK);\r\n} else if (ret == -EAGAIN) {\r\nret = version_lock(conn, DLM_LOCK_PR, DLM_LKF_VALBLK);\r\nif (ret)\r\ngoto out;\r\nlvb_to_version(lc->oc_lvb, &pv);\r\nif ((pv.pv_major != running_proto.pv_major) ||\r\n(pv.pv_minor > running_proto.pv_minor)) {\r\nret = -EINVAL;\r\ngoto out;\r\n}\r\nconn->cc_version.pv_major = pv.pv_major;\r\nconn->cc_version.pv_minor = pv.pv_minor;\r\n}\r\nout:\r\nreturn ret;\r\n}\r\nstatic void user_recover_prep(void *arg)\r\n{\r\n}\r\nstatic void user_recover_slot(void *arg, struct dlm_slot *slot)\r\n{\r\nstruct ocfs2_cluster_connection *conn = arg;\r\nprintk(KERN_INFO "ocfs2: Node %d/%d down. Initiating recovery.\n",\r\nslot->nodeid, slot->slot);\r\nconn->cc_recovery_handler(slot->nodeid, conn->cc_recovery_data);\r\n}\r\nstatic void user_recover_done(void *arg, struct dlm_slot *slots,\r\nint num_slots, int our_slot,\r\nuint32_t generation)\r\n{\r\nstruct ocfs2_cluster_connection *conn = arg;\r\nstruct ocfs2_live_connection *lc = conn->cc_private;\r\nint i;\r\nfor (i = 0; i < num_slots; i++)\r\nif (slots[i].slot == our_slot) {\r\natomic_set(&lc->oc_this_node, slots[i].nodeid);\r\nbreak;\r\n}\r\nlc->oc_our_slot = our_slot;\r\nwake_up(&lc->oc_wait);\r\n}\r\nstatic int user_cluster_disconnect(struct ocfs2_cluster_connection *conn)\r\n{\r\nversion_unlock(conn);\r\ndlm_release_lockspace(conn->cc_lockspace, 2);\r\nconn->cc_lockspace = NULL;\r\nocfs2_live_connection_drop(conn->cc_private);\r\nconn->cc_private = NULL;\r\nreturn 0;\r\n}\r\nstatic int user_cluster_connect(struct ocfs2_cluster_connection *conn)\r\n{\r\ndlm_lockspace_t *fsdlm;\r\nstruct ocfs2_live_connection *lc;\r\nint rc, ops_rv;\r\nBUG_ON(conn == NULL);\r\nlc = kzalloc(sizeof(struct ocfs2_live_connection), GFP_KERNEL);\r\nif (!lc)\r\nreturn -ENOMEM;\r\ninit_waitqueue_head(&lc->oc_wait);\r\ninit_completion(&lc->oc_sync_wait);\r\natomic_set(&lc->oc_this_node, 0);\r\nconn->cc_private = lc;\r\nlc->oc_type = NO_CONTROLD;\r\nrc = dlm_new_lockspace(conn->cc_name, conn->cc_cluster_name,\r\nDLM_LSFL_FS, DLM_LVB_LEN,\r\n&ocfs2_ls_ops, conn, &ops_rv, &fsdlm);\r\nif (rc)\r\ngoto out;\r\nif (ops_rv == -EOPNOTSUPP) {\r\nlc->oc_type = WITH_CONTROLD;\r\nprintk(KERN_NOTICE "ocfs2: You seem to be using an older "\r\n"version of dlm_controld and/or ocfs2-tools."\r\n" Please consider upgrading.\n");\r\n} else if (ops_rv) {\r\nrc = ops_rv;\r\ngoto out;\r\n}\r\nconn->cc_lockspace = fsdlm;\r\nrc = ocfs2_live_connection_attach(conn, lc);\r\nif (rc)\r\ngoto out;\r\nif (lc->oc_type == NO_CONTROLD) {\r\nrc = get_protocol_version(conn);\r\nif (rc) {\r\nprintk(KERN_ERR "ocfs2: Could not determine"\r\n" locking version\n");\r\nuser_cluster_disconnect(conn);\r\ngoto out;\r\n}\r\nwait_event(lc->oc_wait, (atomic_read(&lc->oc_this_node) > 0));\r\n}\r\nif (fs_protocol_compare(&running_proto, &conn->cc_version)) {\r\nprintk(KERN_ERR\r\n"Unable to mount with fs locking protocol version "\r\n"%u.%u because negotiated protocol is %u.%u\n",\r\nconn->cc_version.pv_major, conn->cc_version.pv_minor,\r\nrunning_proto.pv_major, running_proto.pv_minor);\r\nrc = -EPROTO;\r\nocfs2_live_connection_drop(lc);\r\nlc = NULL;\r\n}\r\nout:\r\nif (rc)\r\nkfree(lc);\r\nreturn rc;\r\n}\r\nstatic int user_cluster_this_node(struct ocfs2_cluster_connection *conn,\r\nunsigned int *this_node)\r\n{\r\nint rc;\r\nstruct ocfs2_live_connection *lc = conn->cc_private;\r\nif (lc->oc_type == WITH_CONTROLD)\r\nrc = ocfs2_control_get_this_node();\r\nelse if (lc->oc_type == NO_CONTROLD)\r\nrc = atomic_read(&lc->oc_this_node);\r\nelse\r\nrc = -EINVAL;\r\nif (rc < 0)\r\nreturn rc;\r\n*this_node = rc;\r\nreturn 0;\r\n}\r\nstatic int __init ocfs2_user_plugin_init(void)\r\n{\r\nint rc;\r\nrc = ocfs2_control_init();\r\nif (!rc) {\r\nrc = ocfs2_stack_glue_register(&ocfs2_user_plugin);\r\nif (rc)\r\nocfs2_control_exit();\r\n}\r\nreturn rc;\r\n}\r\nstatic void __exit ocfs2_user_plugin_exit(void)\r\n{\r\nocfs2_stack_glue_unregister(&ocfs2_user_plugin);\r\nocfs2_control_exit();\r\n}
