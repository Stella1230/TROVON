static int musb_regdump_show(struct seq_file *s, void *unused)\r\n{\r\nstruct musb *musb = s->private;\r\nunsigned i;\r\nseq_printf(s, "MUSB (M)HDRC Register Dump\n");\r\nfor (i = 0; i < ARRAY_SIZE(musb_regmap); i++) {\r\nswitch (musb_regmap[i].size) {\r\ncase 8:\r\nseq_printf(s, "%-12s: %02x\n", musb_regmap[i].name,\r\nmusb_readb(musb->mregs, musb_regmap[i].offset));\r\nbreak;\r\ncase 16:\r\nseq_printf(s, "%-12s: %04x\n", musb_regmap[i].name,\r\nmusb_readw(musb->mregs, musb_regmap[i].offset));\r\nbreak;\r\ncase 32:\r\nseq_printf(s, "%-12s: %08x\n", musb_regmap[i].name,\r\nmusb_readl(musb->mregs, musb_regmap[i].offset));\r\nbreak;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int musb_regdump_open(struct inode *inode, struct file *file)\r\n{\r\nreturn single_open(file, musb_regdump_show, inode->i_private);\r\n}\r\nstatic int musb_test_mode_show(struct seq_file *s, void *unused)\r\n{\r\nstruct musb *musb = s->private;\r\nunsigned test;\r\ntest = musb_readb(musb->mregs, MUSB_TESTMODE);\r\nif (test & MUSB_TEST_FORCE_HOST)\r\nseq_printf(s, "force host\n");\r\nif (test & MUSB_TEST_FIFO_ACCESS)\r\nseq_printf(s, "fifo access\n");\r\nif (test & MUSB_TEST_FORCE_FS)\r\nseq_printf(s, "force full-speed\n");\r\nif (test & MUSB_TEST_FORCE_HS)\r\nseq_printf(s, "force high-speed\n");\r\nif (test & MUSB_TEST_PACKET)\r\nseq_printf(s, "test packet\n");\r\nif (test & MUSB_TEST_K)\r\nseq_printf(s, "test K\n");\r\nif (test & MUSB_TEST_J)\r\nseq_printf(s, "test J\n");\r\nif (test & MUSB_TEST_SE0_NAK)\r\nseq_printf(s, "test SE0 NAK\n");\r\nreturn 0;\r\n}\r\nstatic int musb_test_mode_open(struct inode *inode, struct file *file)\r\n{\r\nreturn single_open(file, musb_test_mode_show, inode->i_private);\r\n}\r\nstatic ssize_t musb_test_mode_write(struct file *file,\r\nconst char __user *ubuf, size_t count, loff_t *ppos)\r\n{\r\nstruct seq_file *s = file->private_data;\r\nstruct musb *musb = s->private;\r\nu8 test;\r\nchar buf[18];\r\ntest = musb_readb(musb->mregs, MUSB_TESTMODE);\r\nif (test) {\r\ndev_err(musb->controller, "Error: test mode is already set. "\r\n"Please do USB Bus Reset to start a new test.\n");\r\nreturn count;\r\n}\r\nmemset(buf, 0x00, sizeof(buf));\r\nif (copy_from_user(buf, ubuf, min_t(size_t, sizeof(buf) - 1, count)))\r\nreturn -EFAULT;\r\nif (strstarts(buf, "force host"))\r\ntest = MUSB_TEST_FORCE_HOST;\r\nif (strstarts(buf, "fifo access"))\r\ntest = MUSB_TEST_FIFO_ACCESS;\r\nif (strstarts(buf, "force full-speed"))\r\ntest = MUSB_TEST_FORCE_FS;\r\nif (strstarts(buf, "force high-speed"))\r\ntest = MUSB_TEST_FORCE_HS;\r\nif (strstarts(buf, "test packet")) {\r\ntest = MUSB_TEST_PACKET;\r\nmusb_load_testpacket(musb);\r\n}\r\nif (strstarts(buf, "test K"))\r\ntest = MUSB_TEST_K;\r\nif (strstarts(buf, "test J"))\r\ntest = MUSB_TEST_J;\r\nif (strstarts(buf, "test SE0 NAK"))\r\ntest = MUSB_TEST_SE0_NAK;\r\nmusb_writeb(musb->mregs, MUSB_TESTMODE, test);\r\nreturn count;\r\n}\r\nstatic int musb_softconnect_show(struct seq_file *s, void *unused)\r\n{\r\nstruct musb *musb = s->private;\r\nu8 reg;\r\nint connect;\r\nswitch (musb->xceiv->otg->state) {\r\ncase OTG_STATE_A_HOST:\r\ncase OTG_STATE_A_WAIT_BCON:\r\nreg = musb_readb(musb->mregs, MUSB_DEVCTL);\r\nconnect = reg & MUSB_DEVCTL_SESSION ? 1 : 0;\r\nbreak;\r\ndefault:\r\nconnect = -1;\r\n}\r\nseq_printf(s, "%d\n", connect);\r\nreturn 0;\r\n}\r\nstatic int musb_softconnect_open(struct inode *inode, struct file *file)\r\n{\r\nreturn single_open(file, musb_softconnect_show, inode->i_private);\r\n}\r\nstatic ssize_t musb_softconnect_write(struct file *file,\r\nconst char __user *ubuf, size_t count, loff_t *ppos)\r\n{\r\nstruct seq_file *s = file->private_data;\r\nstruct musb *musb = s->private;\r\nchar buf[2];\r\nu8 reg;\r\nmemset(buf, 0x00, sizeof(buf));\r\nif (copy_from_user(&buf, ubuf, min_t(size_t, sizeof(buf) - 1, count)))\r\nreturn -EFAULT;\r\nif (!strncmp(buf, "0", 1)) {\r\nswitch (musb->xceiv->otg->state) {\r\ncase OTG_STATE_A_HOST:\r\nmusb_root_disconnect(musb);\r\nreg = musb_readb(musb->mregs, MUSB_DEVCTL);\r\nreg &= ~MUSB_DEVCTL_SESSION;\r\nmusb_writeb(musb->mregs, MUSB_DEVCTL, reg);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n} else if (!strncmp(buf, "1", 1)) {\r\nswitch (musb->xceiv->otg->state) {\r\ncase OTG_STATE_A_WAIT_BCON:\r\nmusb->context.devctl |= MUSB_DEVCTL_SESSION;\r\nreg = musb_readb(musb->mregs, MUSB_DEVCTL);\r\nreg |= MUSB_DEVCTL_SESSION;\r\nmusb_writeb(musb->mregs, MUSB_DEVCTL, reg);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nreturn count;\r\n}\r\nint musb_init_debugfs(struct musb *musb)\r\n{\r\nstruct dentry *root;\r\nstruct dentry *file;\r\nint ret;\r\nroot = debugfs_create_dir(dev_name(musb->controller), NULL);\r\nif (!root) {\r\nret = -ENOMEM;\r\ngoto err0;\r\n}\r\nfile = debugfs_create_file("regdump", S_IRUGO, root, musb,\r\n&musb_regdump_fops);\r\nif (!file) {\r\nret = -ENOMEM;\r\ngoto err1;\r\n}\r\nfile = debugfs_create_file("testmode", S_IRUGO | S_IWUSR,\r\nroot, musb, &musb_test_mode_fops);\r\nif (!file) {\r\nret = -ENOMEM;\r\ngoto err1;\r\n}\r\nfile = debugfs_create_file("softconnect", S_IRUGO | S_IWUSR,\r\nroot, musb, &musb_softconnect_fops);\r\nif (!file) {\r\nret = -ENOMEM;\r\ngoto err1;\r\n}\r\nmusb->debugfs_root = root;\r\nreturn 0;\r\nerr1:\r\ndebugfs_remove_recursive(root);\r\nerr0:\r\nreturn ret;\r\n}\r\nvoid musb_exit_debugfs(struct musb *musb)\r\n{\r\ndebugfs_remove_recursive(musb->debugfs_root);\r\n}
