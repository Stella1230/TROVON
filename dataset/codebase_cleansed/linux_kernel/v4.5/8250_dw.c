static inline int dw8250_modify_msr(struct uart_port *p, int offset, int value)\r\n{\r\nstruct dw8250_data *d = p->private_data;\r\nif (offset == UART_MSR) {\r\nvalue |= d->msr_mask_on;\r\nvalue &= ~d->msr_mask_off;\r\n}\r\nreturn value;\r\n}\r\nstatic void dw8250_force_idle(struct uart_port *p)\r\n{\r\nstruct uart_8250_port *up = up_to_u8250p(p);\r\nserial8250_clear_and_reinit_fifos(up);\r\n(void)p->serial_in(p, UART_RX);\r\n}\r\nstatic void dw8250_serial_out(struct uart_port *p, int offset, int value)\r\n{\r\nwriteb(value, p->membase + (offset << p->regshift));\r\nif (offset == UART_LCR) {\r\nint tries = 1000;\r\nwhile (tries--) {\r\nunsigned int lcr = p->serial_in(p, UART_LCR);\r\nif ((value & ~UART_LCR_SPAR) == (lcr & ~UART_LCR_SPAR))\r\nreturn;\r\ndw8250_force_idle(p);\r\nwriteb(value, p->membase + (UART_LCR << p->regshift));\r\n}\r\n}\r\n}\r\nstatic unsigned int dw8250_serial_in(struct uart_port *p, int offset)\r\n{\r\nunsigned int value = readb(p->membase + (offset << p->regshift));\r\nreturn dw8250_modify_msr(p, offset, value);\r\n}\r\nstatic unsigned int dw8250_serial_inq(struct uart_port *p, int offset)\r\n{\r\nunsigned int value;\r\nvalue = (u8)__raw_readq(p->membase + (offset << p->regshift));\r\nreturn dw8250_modify_msr(p, offset, value);\r\n}\r\nstatic void dw8250_serial_outq(struct uart_port *p, int offset, int value)\r\n{\r\nvalue &= 0xff;\r\n__raw_writeq(value, p->membase + (offset << p->regshift));\r\n__raw_readq(p->membase + (UART_LCR << p->regshift));\r\nif (offset == UART_LCR) {\r\nint tries = 1000;\r\nwhile (tries--) {\r\nunsigned int lcr = p->serial_in(p, UART_LCR);\r\nif ((value & ~UART_LCR_SPAR) == (lcr & ~UART_LCR_SPAR))\r\nreturn;\r\ndw8250_force_idle(p);\r\n__raw_writeq(value & 0xff,\r\np->membase + (UART_LCR << p->regshift));\r\n}\r\n}\r\n}\r\nstatic void dw8250_serial_out32(struct uart_port *p, int offset, int value)\r\n{\r\nwritel(value, p->membase + (offset << p->regshift));\r\nif (offset == UART_LCR) {\r\nint tries = 1000;\r\nwhile (tries--) {\r\nunsigned int lcr = p->serial_in(p, UART_LCR);\r\nif ((value & ~UART_LCR_SPAR) == (lcr & ~UART_LCR_SPAR))\r\nreturn;\r\ndw8250_force_idle(p);\r\nwritel(value, p->membase + (UART_LCR << p->regshift));\r\n}\r\n}\r\n}\r\nstatic unsigned int dw8250_serial_in32(struct uart_port *p, int offset)\r\n{\r\nunsigned int value = readl(p->membase + (offset << p->regshift));\r\nreturn dw8250_modify_msr(p, offset, value);\r\n}\r\nstatic int dw8250_handle_irq(struct uart_port *p)\r\n{\r\nstruct dw8250_data *d = p->private_data;\r\nunsigned int iir = p->serial_in(p, UART_IIR);\r\nif (serial8250_handle_irq(p, iir)) {\r\nreturn 1;\r\n} else if ((iir & UART_IIR_BUSY) == UART_IIR_BUSY) {\r\n(void)p->serial_in(p, d->usr_reg);\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}\r\nstatic void\r\ndw8250_do_pm(struct uart_port *port, unsigned int state, unsigned int old)\r\n{\r\nif (!state)\r\npm_runtime_get_sync(port->dev);\r\nserial8250_do_pm(port, state, old);\r\nif (state)\r\npm_runtime_put_sync_suspend(port->dev);\r\n}\r\nstatic void dw8250_set_termios(struct uart_port *p, struct ktermios *termios,\r\nstruct ktermios *old)\r\n{\r\nunsigned int baud = tty_termios_baud_rate(termios);\r\nstruct dw8250_data *d = p->private_data;\r\nunsigned int rate;\r\nint ret;\r\nif (IS_ERR(d->clk) || !old)\r\ngoto out;\r\nclk_disable_unprepare(d->clk);\r\nrate = clk_round_rate(d->clk, baud * 16);\r\nret = clk_set_rate(d->clk, rate);\r\nclk_prepare_enable(d->clk);\r\nif (!ret)\r\np->uartclk = rate;\r\np->status &= ~UPSTAT_AUTOCTS;\r\nif (termios->c_cflag & CRTSCTS)\r\np->status |= UPSTAT_AUTOCTS;\r\nout:\r\nserial8250_do_set_termios(p, termios, old);\r\n}\r\nstatic bool dw8250_fallback_dma_filter(struct dma_chan *chan, void *param)\r\n{\r\nreturn false;\r\n}\r\nstatic bool dw8250_idma_filter(struct dma_chan *chan, void *param)\r\n{\r\nreturn param == chan->device->dev->parent;\r\n}\r\nstatic void dw8250_quirks(struct uart_port *p, struct dw8250_data *data)\r\n{\r\nif (p->dev->of_node) {\r\nstruct device_node *np = p->dev->of_node;\r\nint id;\r\nid = of_alias_get_id(np, "serial");\r\nif (id >= 0)\r\np->line = id;\r\n#ifdef CONFIG_64BIT\r\nif (of_device_is_compatible(np, "cavium,octeon-3860-uart")) {\r\np->serial_in = dw8250_serial_inq;\r\np->serial_out = dw8250_serial_outq;\r\np->flags = UPF_SKIP_TEST | UPF_SHARE_IRQ | UPF_FIXED_TYPE;\r\np->type = PORT_OCTEON;\r\ndata->usr_reg = 0x27;\r\ndata->skip_autocfg = true;\r\n}\r\n#endif\r\n} else if (has_acpi_companion(p->dev)) {\r\np->iotype = UPIO_MEM32;\r\np->regshift = 2;\r\np->serial_in = dw8250_serial_in32;\r\np->set_termios = dw8250_set_termios;\r\ndata->uart_16550_compatible = true;\r\n}\r\nif (platform_get_resource_byname(to_platform_device(p->dev),\r\nIORESOURCE_MEM, "lpss_priv")) {\r\np->set_termios = dw8250_set_termios;\r\ndata->dma.rx_param = p->dev->parent;\r\ndata->dma.tx_param = p->dev->parent;\r\ndata->dma.fn = dw8250_idma_filter;\r\n}\r\n}\r\nstatic void dw8250_setup_port(struct uart_port *p)\r\n{\r\nstruct uart_8250_port *up = up_to_u8250p(p);\r\nu32 reg;\r\nreg = readl(p->membase + DW_UART_UCV);\r\nif (!reg)\r\nreturn;\r\ndev_dbg(p->dev, "Designware UART version %c.%c%c\n",\r\n(reg >> 24) & 0xff, (reg >> 16) & 0xff, (reg >> 8) & 0xff);\r\nreg = readl(p->membase + DW_UART_CPR);\r\nif (!reg)\r\nreturn;\r\nif (reg & DW_UART_CPR_FIFO_MODE) {\r\np->type = PORT_16550A;\r\np->flags |= UPF_FIXED_TYPE;\r\np->fifosize = DW_UART_CPR_FIFO_SIZE(reg);\r\nup->capabilities = UART_CAP_FIFO;\r\n}\r\nif (reg & DW_UART_CPR_AFCE_MODE)\r\nup->capabilities |= UART_CAP_AFE;\r\n}\r\nstatic int dw8250_probe(struct platform_device *pdev)\r\n{\r\nstruct uart_8250_port uart = {};\r\nstruct resource *regs = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nint irq = platform_get_irq(pdev, 0);\r\nstruct uart_port *p = &uart.port;\r\nstruct dw8250_data *data;\r\nint err;\r\nu32 val;\r\nif (!regs) {\r\ndev_err(&pdev->dev, "no registers defined\n");\r\nreturn -EINVAL;\r\n}\r\nif (irq < 0) {\r\nif (irq != -EPROBE_DEFER)\r\ndev_err(&pdev->dev, "cannot get irq\n");\r\nreturn irq;\r\n}\r\nspin_lock_init(&p->lock);\r\np->mapbase = regs->start;\r\np->irq = irq;\r\np->handle_irq = dw8250_handle_irq;\r\np->pm = dw8250_do_pm;\r\np->type = PORT_8250;\r\np->flags = UPF_SHARE_IRQ | UPF_FIXED_PORT;\r\np->dev = &pdev->dev;\r\np->iotype = UPIO_MEM;\r\np->serial_in = dw8250_serial_in;\r\np->serial_out = dw8250_serial_out;\r\np->membase = devm_ioremap(&pdev->dev, regs->start, resource_size(regs));\r\nif (!p->membase)\r\nreturn -ENOMEM;\r\ndata = devm_kzalloc(&pdev->dev, sizeof(*data), GFP_KERNEL);\r\nif (!data)\r\nreturn -ENOMEM;\r\ndata->dma.fn = dw8250_fallback_dma_filter;\r\ndata->usr_reg = DW_UART_USR;\r\np->private_data = data;\r\ndata->uart_16550_compatible = device_property_read_bool(p->dev,\r\n"snps,uart-16550-compatible");\r\nerr = device_property_read_u32(p->dev, "reg-shift", &val);\r\nif (!err)\r\np->regshift = val;\r\nerr = device_property_read_u32(p->dev, "reg-io-width", &val);\r\nif (!err && val == 4) {\r\np->iotype = UPIO_MEM32;\r\np->serial_in = dw8250_serial_in32;\r\np->serial_out = dw8250_serial_out32;\r\n}\r\nif (device_property_read_bool(p->dev, "dcd-override")) {\r\ndata->msr_mask_on |= UART_MSR_DCD;\r\ndata->msr_mask_off |= UART_MSR_DDCD;\r\n}\r\nif (device_property_read_bool(p->dev, "dsr-override")) {\r\ndata->msr_mask_on |= UART_MSR_DSR;\r\ndata->msr_mask_off |= UART_MSR_DDSR;\r\n}\r\nif (device_property_read_bool(p->dev, "cts-override")) {\r\ndata->msr_mask_on |= UART_MSR_CTS;\r\ndata->msr_mask_off |= UART_MSR_DCTS;\r\n}\r\nif (device_property_read_bool(p->dev, "ri-override")) {\r\ndata->msr_mask_off |= UART_MSR_RI;\r\ndata->msr_mask_off |= UART_MSR_TERI;\r\n}\r\ndevice_property_read_u32(p->dev, "clock-frequency", &p->uartclk);\r\ndata->clk = devm_clk_get(&pdev->dev, "baudclk");\r\nif (IS_ERR(data->clk) && PTR_ERR(data->clk) != -EPROBE_DEFER)\r\ndata->clk = devm_clk_get(&pdev->dev, NULL);\r\nif (IS_ERR(data->clk) && PTR_ERR(data->clk) == -EPROBE_DEFER)\r\nreturn -EPROBE_DEFER;\r\nif (!IS_ERR_OR_NULL(data->clk)) {\r\nerr = clk_prepare_enable(data->clk);\r\nif (err)\r\ndev_warn(&pdev->dev, "could not enable optional baudclk: %d\n",\r\nerr);\r\nelse\r\np->uartclk = clk_get_rate(data->clk);\r\n}\r\nif (!p->uartclk) {\r\ndev_err(&pdev->dev, "clock rate not defined\n");\r\nreturn -EINVAL;\r\n}\r\ndata->pclk = devm_clk_get(&pdev->dev, "apb_pclk");\r\nif (IS_ERR(data->clk) && PTR_ERR(data->clk) == -EPROBE_DEFER) {\r\nerr = -EPROBE_DEFER;\r\ngoto err_clk;\r\n}\r\nif (!IS_ERR(data->pclk)) {\r\nerr = clk_prepare_enable(data->pclk);\r\nif (err) {\r\ndev_err(&pdev->dev, "could not enable apb_pclk\n");\r\ngoto err_clk;\r\n}\r\n}\r\ndata->rst = devm_reset_control_get_optional(&pdev->dev, NULL);\r\nif (IS_ERR(data->rst) && PTR_ERR(data->rst) == -EPROBE_DEFER) {\r\nerr = -EPROBE_DEFER;\r\ngoto err_pclk;\r\n}\r\nif (!IS_ERR(data->rst))\r\nreset_control_deassert(data->rst);\r\ndw8250_quirks(p, data);\r\nif (data->uart_16550_compatible) {\r\np->serial_out = NULL;\r\np->handle_irq = NULL;\r\n}\r\nif (!data->skip_autocfg)\r\ndw8250_setup_port(p);\r\nif (p->fifosize) {\r\ndata->dma.rxconf.src_maxburst = p->fifosize / 4;\r\ndata->dma.txconf.dst_maxburst = p->fifosize / 4;\r\nuart.dma = &data->dma;\r\n}\r\ndata->line = serial8250_register_8250_port(&uart);\r\nif (data->line < 0) {\r\nerr = data->line;\r\ngoto err_reset;\r\n}\r\nplatform_set_drvdata(pdev, data);\r\npm_runtime_set_active(&pdev->dev);\r\npm_runtime_enable(&pdev->dev);\r\nreturn 0;\r\nerr_reset:\r\nif (!IS_ERR(data->rst))\r\nreset_control_assert(data->rst);\r\nerr_pclk:\r\nif (!IS_ERR(data->pclk))\r\nclk_disable_unprepare(data->pclk);\r\nerr_clk:\r\nif (!IS_ERR(data->clk))\r\nclk_disable_unprepare(data->clk);\r\nreturn err;\r\n}\r\nstatic int dw8250_remove(struct platform_device *pdev)\r\n{\r\nstruct dw8250_data *data = platform_get_drvdata(pdev);\r\npm_runtime_get_sync(&pdev->dev);\r\nserial8250_unregister_port(data->line);\r\nif (!IS_ERR(data->rst))\r\nreset_control_assert(data->rst);\r\nif (!IS_ERR(data->pclk))\r\nclk_disable_unprepare(data->pclk);\r\nif (!IS_ERR(data->clk))\r\nclk_disable_unprepare(data->clk);\r\npm_runtime_disable(&pdev->dev);\r\npm_runtime_put_noidle(&pdev->dev);\r\nreturn 0;\r\n}\r\nstatic int dw8250_suspend(struct device *dev)\r\n{\r\nstruct dw8250_data *data = dev_get_drvdata(dev);\r\nserial8250_suspend_port(data->line);\r\nreturn 0;\r\n}\r\nstatic int dw8250_resume(struct device *dev)\r\n{\r\nstruct dw8250_data *data = dev_get_drvdata(dev);\r\nserial8250_resume_port(data->line);\r\nreturn 0;\r\n}\r\nstatic int dw8250_runtime_suspend(struct device *dev)\r\n{\r\nstruct dw8250_data *data = dev_get_drvdata(dev);\r\nif (!IS_ERR(data->clk))\r\nclk_disable_unprepare(data->clk);\r\nif (!IS_ERR(data->pclk))\r\nclk_disable_unprepare(data->pclk);\r\nreturn 0;\r\n}\r\nstatic int dw8250_runtime_resume(struct device *dev)\r\n{\r\nstruct dw8250_data *data = dev_get_drvdata(dev);\r\nif (!IS_ERR(data->pclk))\r\nclk_prepare_enable(data->pclk);\r\nif (!IS_ERR(data->clk))\r\nclk_prepare_enable(data->clk);\r\nreturn 0;\r\n}
