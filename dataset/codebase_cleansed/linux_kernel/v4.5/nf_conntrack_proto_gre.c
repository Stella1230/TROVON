static inline struct netns_proto_gre *gre_pernet(struct net *net)\r\n{\r\nreturn net_generic(net, proto_gre_net_id);\r\n}\r\nstatic void nf_ct_gre_keymap_flush(struct net *net)\r\n{\r\nstruct netns_proto_gre *net_gre = gre_pernet(net);\r\nstruct nf_ct_gre_keymap *km, *tmp;\r\nwrite_lock_bh(&net_gre->keymap_lock);\r\nlist_for_each_entry_safe(km, tmp, &net_gre->keymap_list, list) {\r\nlist_del(&km->list);\r\nkfree(km);\r\n}\r\nwrite_unlock_bh(&net_gre->keymap_lock);\r\n}\r\nstatic inline int gre_key_cmpfn(const struct nf_ct_gre_keymap *km,\r\nconst struct nf_conntrack_tuple *t)\r\n{\r\nreturn km->tuple.src.l3num == t->src.l3num &&\r\n!memcmp(&km->tuple.src.u3, &t->src.u3, sizeof(t->src.u3)) &&\r\n!memcmp(&km->tuple.dst.u3, &t->dst.u3, sizeof(t->dst.u3)) &&\r\nkm->tuple.dst.protonum == t->dst.protonum &&\r\nkm->tuple.dst.u.all == t->dst.u.all;\r\n}\r\nstatic __be16 gre_keymap_lookup(struct net *net, struct nf_conntrack_tuple *t)\r\n{\r\nstruct netns_proto_gre *net_gre = gre_pernet(net);\r\nstruct nf_ct_gre_keymap *km;\r\n__be16 key = 0;\r\nread_lock_bh(&net_gre->keymap_lock);\r\nlist_for_each_entry(km, &net_gre->keymap_list, list) {\r\nif (gre_key_cmpfn(km, t)) {\r\nkey = km->tuple.src.u.gre.key;\r\nbreak;\r\n}\r\n}\r\nread_unlock_bh(&net_gre->keymap_lock);\r\npr_debug("lookup src key 0x%x for ", key);\r\nnf_ct_dump_tuple(t);\r\nreturn key;\r\n}\r\nint nf_ct_gre_keymap_add(struct nf_conn *ct, enum ip_conntrack_dir dir,\r\nstruct nf_conntrack_tuple *t)\r\n{\r\nstruct net *net = nf_ct_net(ct);\r\nstruct netns_proto_gre *net_gre = gre_pernet(net);\r\nstruct nf_ct_pptp_master *ct_pptp_info = nfct_help_data(ct);\r\nstruct nf_ct_gre_keymap **kmp, *km;\r\nkmp = &ct_pptp_info->keymap[dir];\r\nif (*kmp) {\r\nread_lock_bh(&net_gre->keymap_lock);\r\nlist_for_each_entry(km, &net_gre->keymap_list, list) {\r\nif (gre_key_cmpfn(km, t) && km == *kmp) {\r\nread_unlock_bh(&net_gre->keymap_lock);\r\nreturn 0;\r\n}\r\n}\r\nread_unlock_bh(&net_gre->keymap_lock);\r\npr_debug("trying to override keymap_%s for ct %p\n",\r\ndir == IP_CT_DIR_REPLY ? "reply" : "orig", ct);\r\nreturn -EEXIST;\r\n}\r\nkm = kmalloc(sizeof(*km), GFP_ATOMIC);\r\nif (!km)\r\nreturn -ENOMEM;\r\nmemcpy(&km->tuple, t, sizeof(*t));\r\n*kmp = km;\r\npr_debug("adding new entry %p: ", km);\r\nnf_ct_dump_tuple(&km->tuple);\r\nwrite_lock_bh(&net_gre->keymap_lock);\r\nlist_add_tail(&km->list, &net_gre->keymap_list);\r\nwrite_unlock_bh(&net_gre->keymap_lock);\r\nreturn 0;\r\n}\r\nvoid nf_ct_gre_keymap_destroy(struct nf_conn *ct)\r\n{\r\nstruct net *net = nf_ct_net(ct);\r\nstruct netns_proto_gre *net_gre = gre_pernet(net);\r\nstruct nf_ct_pptp_master *ct_pptp_info = nfct_help_data(ct);\r\nenum ip_conntrack_dir dir;\r\npr_debug("entering for ct %p\n", ct);\r\nwrite_lock_bh(&net_gre->keymap_lock);\r\nfor (dir = IP_CT_DIR_ORIGINAL; dir < IP_CT_DIR_MAX; dir++) {\r\nif (ct_pptp_info->keymap[dir]) {\r\npr_debug("removing %p from list\n",\r\nct_pptp_info->keymap[dir]);\r\nlist_del(&ct_pptp_info->keymap[dir]->list);\r\nkfree(ct_pptp_info->keymap[dir]);\r\nct_pptp_info->keymap[dir] = NULL;\r\n}\r\n}\r\nwrite_unlock_bh(&net_gre->keymap_lock);\r\n}\r\nstatic bool gre_invert_tuple(struct nf_conntrack_tuple *tuple,\r\nconst struct nf_conntrack_tuple *orig)\r\n{\r\ntuple->dst.u.gre.key = orig->src.u.gre.key;\r\ntuple->src.u.gre.key = orig->dst.u.gre.key;\r\nreturn true;\r\n}\r\nstatic bool gre_pkt_to_tuple(const struct sk_buff *skb, unsigned int dataoff,\r\nstruct net *net, struct nf_conntrack_tuple *tuple)\r\n{\r\nconst struct gre_hdr_pptp *pgrehdr;\r\nstruct gre_hdr_pptp _pgrehdr;\r\n__be16 srckey;\r\nconst struct gre_hdr *grehdr;\r\nstruct gre_hdr _grehdr;\r\ngrehdr = skb_header_pointer(skb, dataoff, sizeof(_grehdr), &_grehdr);\r\nif (!grehdr || grehdr->version != GRE_VERSION_PPTP) {\r\ntuple->src.u.all = 0;\r\ntuple->dst.u.all = 0;\r\nreturn true;\r\n}\r\npgrehdr = skb_header_pointer(skb, dataoff, 8, &_pgrehdr);\r\nif (!pgrehdr)\r\nreturn true;\r\nif (ntohs(grehdr->protocol) != GRE_PROTOCOL_PPTP) {\r\npr_debug("GRE_VERSION_PPTP but unknown proto\n");\r\nreturn false;\r\n}\r\ntuple->dst.u.gre.key = pgrehdr->call_id;\r\nsrckey = gre_keymap_lookup(net, tuple);\r\ntuple->src.u.gre.key = srckey;\r\nreturn true;\r\n}\r\nstatic void gre_print_tuple(struct seq_file *s,\r\nconst struct nf_conntrack_tuple *tuple)\r\n{\r\nseq_printf(s, "srckey=0x%x dstkey=0x%x ",\r\nntohs(tuple->src.u.gre.key),\r\nntohs(tuple->dst.u.gre.key));\r\n}\r\nstatic void gre_print_conntrack(struct seq_file *s, struct nf_conn *ct)\r\n{\r\nseq_printf(s, "timeout=%u, stream_timeout=%u ",\r\n(ct->proto.gre.timeout / HZ),\r\n(ct->proto.gre.stream_timeout / HZ));\r\n}\r\nstatic unsigned int *gre_get_timeouts(struct net *net)\r\n{\r\nreturn gre_pernet(net)->gre_timeouts;\r\n}\r\nstatic int gre_packet(struct nf_conn *ct,\r\nconst struct sk_buff *skb,\r\nunsigned int dataoff,\r\nenum ip_conntrack_info ctinfo,\r\nu_int8_t pf,\r\nunsigned int hooknum,\r\nunsigned int *timeouts)\r\n{\r\nif (ct->status & IPS_SEEN_REPLY) {\r\nnf_ct_refresh_acct(ct, ctinfo, skb,\r\nct->proto.gre.stream_timeout);\r\nif (!test_and_set_bit(IPS_ASSURED_BIT, &ct->status))\r\nnf_conntrack_event_cache(IPCT_ASSURED, ct);\r\n} else\r\nnf_ct_refresh_acct(ct, ctinfo, skb,\r\nct->proto.gre.timeout);\r\nreturn NF_ACCEPT;\r\n}\r\nstatic bool gre_new(struct nf_conn *ct, const struct sk_buff *skb,\r\nunsigned int dataoff, unsigned int *timeouts)\r\n{\r\npr_debug(": ");\r\nnf_ct_dump_tuple(&ct->tuplehash[IP_CT_DIR_ORIGINAL].tuple);\r\nct->proto.gre.stream_timeout = timeouts[GRE_CT_REPLIED];\r\nct->proto.gre.timeout = timeouts[GRE_CT_UNREPLIED];\r\nreturn true;\r\n}\r\nstatic void gre_destroy(struct nf_conn *ct)\r\n{\r\nstruct nf_conn *master = ct->master;\r\npr_debug(" entering\n");\r\nif (!master)\r\npr_debug("no master !?!\n");\r\nelse\r\nnf_ct_gre_keymap_destroy(master);\r\n}\r\nstatic int gre_timeout_nlattr_to_obj(struct nlattr *tb[],\r\nstruct net *net, void *data)\r\n{\r\nunsigned int *timeouts = data;\r\nstruct netns_proto_gre *net_gre = gre_pernet(net);\r\ntimeouts[GRE_CT_UNREPLIED] = net_gre->gre_timeouts[GRE_CT_UNREPLIED];\r\ntimeouts[GRE_CT_REPLIED] = net_gre->gre_timeouts[GRE_CT_REPLIED];\r\nif (tb[CTA_TIMEOUT_GRE_UNREPLIED]) {\r\ntimeouts[GRE_CT_UNREPLIED] =\r\nntohl(nla_get_be32(tb[CTA_TIMEOUT_GRE_UNREPLIED])) * HZ;\r\n}\r\nif (tb[CTA_TIMEOUT_GRE_REPLIED]) {\r\ntimeouts[GRE_CT_REPLIED] =\r\nntohl(nla_get_be32(tb[CTA_TIMEOUT_GRE_REPLIED])) * HZ;\r\n}\r\nreturn 0;\r\n}\r\nstatic int\r\ngre_timeout_obj_to_nlattr(struct sk_buff *skb, const void *data)\r\n{\r\nconst unsigned int *timeouts = data;\r\nif (nla_put_be32(skb, CTA_TIMEOUT_GRE_UNREPLIED,\r\nhtonl(timeouts[GRE_CT_UNREPLIED] / HZ)) ||\r\nnla_put_be32(skb, CTA_TIMEOUT_GRE_REPLIED,\r\nhtonl(timeouts[GRE_CT_REPLIED] / HZ)))\r\ngoto nla_put_failure;\r\nreturn 0;\r\nnla_put_failure:\r\nreturn -ENOSPC;\r\n}\r\nstatic int gre_init_net(struct net *net, u_int16_t proto)\r\n{\r\nstruct netns_proto_gre *net_gre = gre_pernet(net);\r\nint i;\r\nrwlock_init(&net_gre->keymap_lock);\r\nINIT_LIST_HEAD(&net_gre->keymap_list);\r\nfor (i = 0; i < GRE_CT_MAX; i++)\r\nnet_gre->gre_timeouts[i] = gre_timeouts[i];\r\nreturn 0;\r\n}\r\nstatic int proto_gre_net_init(struct net *net)\r\n{\r\nint ret = 0;\r\nret = nf_ct_l4proto_pernet_register(net, &nf_conntrack_l4proto_gre4);\r\nif (ret < 0)\r\npr_err("nf_conntrack_gre4: pernet registration failed.\n");\r\nreturn ret;\r\n}\r\nstatic void proto_gre_net_exit(struct net *net)\r\n{\r\nnf_ct_l4proto_pernet_unregister(net, &nf_conntrack_l4proto_gre4);\r\nnf_ct_gre_keymap_flush(net);\r\n}\r\nstatic int __init nf_ct_proto_gre_init(void)\r\n{\r\nint ret;\r\nret = register_pernet_subsys(&proto_gre_net_ops);\r\nif (ret < 0)\r\ngoto out_pernet;\r\nret = nf_ct_l4proto_register(&nf_conntrack_l4proto_gre4);\r\nif (ret < 0)\r\ngoto out_gre4;\r\nreturn 0;\r\nout_gre4:\r\nunregister_pernet_subsys(&proto_gre_net_ops);\r\nout_pernet:\r\nreturn ret;\r\n}\r\nstatic void __exit nf_ct_proto_gre_fini(void)\r\n{\r\nnf_ct_l4proto_unregister(&nf_conntrack_l4proto_gre4);\r\nunregister_pernet_subsys(&proto_gre_net_ops);\r\n}
