static int ad5064_write(struct ad5064_state *st, unsigned int cmd,\r\nunsigned int addr, unsigned int val, unsigned int shift)\r\n{\r\nval <<= shift;\r\nreturn st->write(st, cmd, addr, val);\r\n}\r\nstatic int ad5064_sync_powerdown_mode(struct ad5064_state *st,\r\nconst struct iio_chan_spec *chan)\r\n{\r\nunsigned int val;\r\nint ret;\r\nval = (0x1 << chan->address);\r\nif (st->pwr_down[chan->channel])\r\nval |= st->pwr_down_mode[chan->channel] << 8;\r\nret = ad5064_write(st, AD5064_CMD_POWERDOWN_DAC, 0, val, 0);\r\nreturn ret;\r\n}\r\nstatic int ad5064_get_powerdown_mode(struct iio_dev *indio_dev,\r\nconst struct iio_chan_spec *chan)\r\n{\r\nstruct ad5064_state *st = iio_priv(indio_dev);\r\nreturn st->pwr_down_mode[chan->channel] - 1;\r\n}\r\nstatic int ad5064_set_powerdown_mode(struct iio_dev *indio_dev,\r\nconst struct iio_chan_spec *chan, unsigned int mode)\r\n{\r\nstruct ad5064_state *st = iio_priv(indio_dev);\r\nint ret;\r\nmutex_lock(&indio_dev->mlock);\r\nst->pwr_down_mode[chan->channel] = mode + 1;\r\nret = ad5064_sync_powerdown_mode(st, chan);\r\nmutex_unlock(&indio_dev->mlock);\r\nreturn ret;\r\n}\r\nstatic ssize_t ad5064_read_dac_powerdown(struct iio_dev *indio_dev,\r\nuintptr_t private, const struct iio_chan_spec *chan, char *buf)\r\n{\r\nstruct ad5064_state *st = iio_priv(indio_dev);\r\nreturn sprintf(buf, "%d\n", st->pwr_down[chan->channel]);\r\n}\r\nstatic ssize_t ad5064_write_dac_powerdown(struct iio_dev *indio_dev,\r\nuintptr_t private, const struct iio_chan_spec *chan, const char *buf,\r\nsize_t len)\r\n{\r\nstruct ad5064_state *st = iio_priv(indio_dev);\r\nbool pwr_down;\r\nint ret;\r\nret = strtobool(buf, &pwr_down);\r\nif (ret)\r\nreturn ret;\r\nmutex_lock(&indio_dev->mlock);\r\nst->pwr_down[chan->channel] = pwr_down;\r\nret = ad5064_sync_powerdown_mode(st, chan);\r\nmutex_unlock(&indio_dev->mlock);\r\nreturn ret ? ret : len;\r\n}\r\nstatic int ad5064_get_vref(struct ad5064_state *st,\r\nstruct iio_chan_spec const *chan)\r\n{\r\nunsigned int i;\r\nif (st->use_internal_vref)\r\nreturn st->chip_info->internal_vref;\r\ni = st->chip_info->shared_vref ? 0 : chan->channel;\r\nreturn regulator_get_voltage(st->vref_reg[i].consumer);\r\n}\r\nstatic int ad5064_read_raw(struct iio_dev *indio_dev,\r\nstruct iio_chan_spec const *chan,\r\nint *val,\r\nint *val2,\r\nlong m)\r\n{\r\nstruct ad5064_state *st = iio_priv(indio_dev);\r\nint scale_uv;\r\nswitch (m) {\r\ncase IIO_CHAN_INFO_RAW:\r\n*val = st->dac_cache[chan->channel];\r\nreturn IIO_VAL_INT;\r\ncase IIO_CHAN_INFO_SCALE:\r\nscale_uv = ad5064_get_vref(st, chan);\r\nif (scale_uv < 0)\r\nreturn scale_uv;\r\n*val = scale_uv / 1000;\r\n*val2 = chan->scan_type.realbits;\r\nreturn IIO_VAL_FRACTIONAL_LOG2;\r\ndefault:\r\nbreak;\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int ad5064_write_raw(struct iio_dev *indio_dev,\r\nstruct iio_chan_spec const *chan, int val, int val2, long mask)\r\n{\r\nstruct ad5064_state *st = iio_priv(indio_dev);\r\nint ret;\r\nswitch (mask) {\r\ncase IIO_CHAN_INFO_RAW:\r\nif (val >= (1 << chan->scan_type.realbits) || val < 0)\r\nreturn -EINVAL;\r\nmutex_lock(&indio_dev->mlock);\r\nret = ad5064_write(st, AD5064_CMD_WRITE_INPUT_N_UPDATE_N,\r\nchan->address, val, chan->scan_type.shift);\r\nif (ret == 0)\r\nst->dac_cache[chan->channel] = val;\r\nmutex_unlock(&indio_dev->mlock);\r\nbreak;\r\ndefault:\r\nret = -EINVAL;\r\n}\r\nreturn ret;\r\n}\r\nstatic inline unsigned int ad5064_num_vref(struct ad5064_state *st)\r\n{\r\nreturn st->chip_info->shared_vref ? 1 : st->chip_info->num_channels;\r\n}\r\nstatic const char * const ad5064_vref_name(struct ad5064_state *st,\r\nunsigned int vref)\r\n{\r\nreturn st->chip_info->shared_vref ? "vref" : ad5064_vref_names[vref];\r\n}\r\nstatic int ad5064_probe(struct device *dev, enum ad5064_type type,\r\nconst char *name, ad5064_write_func write)\r\n{\r\nstruct iio_dev *indio_dev;\r\nstruct ad5064_state *st;\r\nunsigned int midscale;\r\nunsigned int i;\r\nint ret;\r\nindio_dev = devm_iio_device_alloc(dev, sizeof(*st));\r\nif (indio_dev == NULL)\r\nreturn -ENOMEM;\r\nst = iio_priv(indio_dev);\r\ndev_set_drvdata(dev, indio_dev);\r\nst->chip_info = &ad5064_chip_info_tbl[type];\r\nst->dev = dev;\r\nst->write = write;\r\nfor (i = 0; i < ad5064_num_vref(st); ++i)\r\nst->vref_reg[i].supply = ad5064_vref_name(st, i);\r\nret = devm_regulator_bulk_get(dev, ad5064_num_vref(st),\r\nst->vref_reg);\r\nif (ret) {\r\nif (!st->chip_info->internal_vref)\r\nreturn ret;\r\nst->use_internal_vref = true;\r\nret = ad5064_write(st, AD5064_CMD_CONFIG, 0,\r\nAD5064_CONFIG_INT_VREF_ENABLE, 0);\r\nif (ret) {\r\ndev_err(dev, "Failed to enable internal vref: %d\n",\r\nret);\r\nreturn ret;\r\n}\r\n} else {\r\nret = regulator_bulk_enable(ad5064_num_vref(st), st->vref_reg);\r\nif (ret)\r\nreturn ret;\r\n}\r\nindio_dev->dev.parent = dev;\r\nindio_dev->name = name;\r\nindio_dev->info = &ad5064_info;\r\nindio_dev->modes = INDIO_DIRECT_MODE;\r\nindio_dev->channels = st->chip_info->channels;\r\nindio_dev->num_channels = st->chip_info->num_channels;\r\nmidscale = (1 << indio_dev->channels[0].scan_type.realbits) / 2;\r\nfor (i = 0; i < st->chip_info->num_channels; ++i) {\r\nst->pwr_down_mode[i] = AD5064_LDAC_PWRDN_1K;\r\nst->dac_cache[i] = midscale;\r\n}\r\nret = iio_device_register(indio_dev);\r\nif (ret)\r\ngoto error_disable_reg;\r\nreturn 0;\r\nerror_disable_reg:\r\nif (!st->use_internal_vref)\r\nregulator_bulk_disable(ad5064_num_vref(st), st->vref_reg);\r\nreturn ret;\r\n}\r\nstatic int ad5064_remove(struct device *dev)\r\n{\r\nstruct iio_dev *indio_dev = dev_get_drvdata(dev);\r\nstruct ad5064_state *st = iio_priv(indio_dev);\r\niio_device_unregister(indio_dev);\r\nif (!st->use_internal_vref)\r\nregulator_bulk_disable(ad5064_num_vref(st), st->vref_reg);\r\nreturn 0;\r\n}\r\nstatic int ad5064_spi_write(struct ad5064_state *st, unsigned int cmd,\r\nunsigned int addr, unsigned int val)\r\n{\r\nstruct spi_device *spi = to_spi_device(st->dev);\r\nst->data.spi = cpu_to_be32(AD5064_CMD(cmd) | AD5064_ADDR(addr) | val);\r\nreturn spi_write(spi, &st->data.spi, sizeof(st->data.spi));\r\n}\r\nstatic int ad5064_spi_probe(struct spi_device *spi)\r\n{\r\nconst struct spi_device_id *id = spi_get_device_id(spi);\r\nreturn ad5064_probe(&spi->dev, id->driver_data, id->name,\r\nad5064_spi_write);\r\n}\r\nstatic int ad5064_spi_remove(struct spi_device *spi)\r\n{\r\nreturn ad5064_remove(&spi->dev);\r\n}\r\nstatic int __init ad5064_spi_register_driver(void)\r\n{\r\nreturn spi_register_driver(&ad5064_spi_driver);\r\n}\r\nstatic void ad5064_spi_unregister_driver(void)\r\n{\r\nspi_unregister_driver(&ad5064_spi_driver);\r\n}\r\nstatic inline int ad5064_spi_register_driver(void) { return 0; }\r\nstatic inline void ad5064_spi_unregister_driver(void) { }\r\nstatic int ad5064_i2c_write(struct ad5064_state *st, unsigned int cmd,\r\nunsigned int addr, unsigned int val)\r\n{\r\nstruct i2c_client *i2c = to_i2c_client(st->dev);\r\nint ret;\r\nst->data.i2c[0] = (cmd << 4) | addr;\r\nput_unaligned_be16(val, &st->data.i2c[1]);\r\nret = i2c_master_send(i2c, st->data.i2c, 3);\r\nif (ret < 0)\r\nreturn ret;\r\nreturn 0;\r\n}\r\nstatic int ad5064_i2c_probe(struct i2c_client *i2c,\r\nconst struct i2c_device_id *id)\r\n{\r\nreturn ad5064_probe(&i2c->dev, id->driver_data, id->name,\r\nad5064_i2c_write);\r\n}\r\nstatic int ad5064_i2c_remove(struct i2c_client *i2c)\r\n{\r\nreturn ad5064_remove(&i2c->dev);\r\n}\r\nstatic int __init ad5064_i2c_register_driver(void)\r\n{\r\nreturn i2c_add_driver(&ad5064_i2c_driver);\r\n}\r\nstatic void __exit ad5064_i2c_unregister_driver(void)\r\n{\r\ni2c_del_driver(&ad5064_i2c_driver);\r\n}\r\nstatic inline int ad5064_i2c_register_driver(void) { return 0; }\r\nstatic inline void ad5064_i2c_unregister_driver(void) { }\r\nstatic int __init ad5064_init(void)\r\n{\r\nint ret;\r\nret = ad5064_spi_register_driver();\r\nif (ret)\r\nreturn ret;\r\nret = ad5064_i2c_register_driver();\r\nif (ret) {\r\nad5064_spi_unregister_driver();\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic void __exit ad5064_exit(void)\r\n{\r\nad5064_i2c_unregister_driver();\r\nad5064_spi_unregister_driver();\r\n}
