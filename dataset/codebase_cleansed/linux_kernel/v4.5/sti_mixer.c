const char *sti_mixer_to_str(struct sti_mixer *mixer)\r\n{\r\nswitch (mixer->id) {\r\ncase STI_MIXER_MAIN:\r\nreturn "MAIN_MIXER";\r\ncase STI_MIXER_AUX:\r\nreturn "AUX_MIXER";\r\ndefault:\r\nreturn "<UNKNOWN MIXER>";\r\n}\r\n}\r\nstatic inline u32 sti_mixer_reg_read(struct sti_mixer *mixer, u32 reg_id)\r\n{\r\nreturn readl(mixer->regs + reg_id);\r\n}\r\nstatic inline void sti_mixer_reg_write(struct sti_mixer *mixer,\r\nu32 reg_id, u32 val)\r\n{\r\nwritel(val, mixer->regs + reg_id);\r\n}\r\nvoid sti_mixer_set_background_status(struct sti_mixer *mixer, bool enable)\r\n{\r\nu32 val = sti_mixer_reg_read(mixer, GAM_MIXER_CTL);\r\nval &= ~GAM_CTL_BACK_MASK;\r\nval |= enable;\r\nsti_mixer_reg_write(mixer, GAM_MIXER_CTL, val);\r\n}\r\nstatic void sti_mixer_set_background_color(struct sti_mixer *mixer,\r\nunsigned int rgb)\r\n{\r\nsti_mixer_reg_write(mixer, GAM_MIXER_BKC, rgb);\r\n}\r\nstatic void sti_mixer_set_background_area(struct sti_mixer *mixer,\r\nstruct drm_display_mode *mode)\r\n{\r\nu32 ydo, xdo, yds, xds;\r\nydo = sti_vtg_get_line_number(*mode, 0);\r\nyds = sti_vtg_get_line_number(*mode, mode->vdisplay - 1);\r\nxdo = sti_vtg_get_pixel_number(*mode, 0);\r\nxds = sti_vtg_get_pixel_number(*mode, mode->hdisplay - 1);\r\nsti_mixer_reg_write(mixer, GAM_MIXER_BCO, ydo << 16 | xdo);\r\nsti_mixer_reg_write(mixer, GAM_MIXER_BCS, yds << 16 | xds);\r\n}\r\nint sti_mixer_set_plane_depth(struct sti_mixer *mixer, struct sti_plane *plane)\r\n{\r\nint plane_id, depth = plane->zorder;\r\nunsigned int i;\r\nu32 mask, val;\r\nif ((depth < 1) || (depth > GAM_MIXER_NB_DEPTH_LEVEL))\r\nreturn 1;\r\nswitch (plane->desc) {\r\ncase STI_GDP_0:\r\nplane_id = GAM_DEPTH_GDP0_ID;\r\nbreak;\r\ncase STI_GDP_1:\r\nplane_id = GAM_DEPTH_GDP1_ID;\r\nbreak;\r\ncase STI_GDP_2:\r\nplane_id = GAM_DEPTH_GDP2_ID;\r\nbreak;\r\ncase STI_GDP_3:\r\nplane_id = GAM_DEPTH_GDP3_ID;\r\nbreak;\r\ncase STI_HQVDP_0:\r\nplane_id = GAM_DEPTH_VID0_ID;\r\nbreak;\r\ncase STI_CURSOR:\r\nreturn 0;\r\ndefault:\r\nDRM_ERROR("Unknown plane %d\n", plane->desc);\r\nreturn 1;\r\n}\r\nval = sti_mixer_reg_read(mixer, GAM_MIXER_CRB);\r\nfor (i = 0; i < GAM_MIXER_NB_DEPTH_LEVEL; i++) {\r\nmask = GAM_DEPTH_MASK_ID << (3 * i);\r\nif ((val & mask) == plane_id << (3 * i))\r\nbreak;\r\n}\r\nmask |= GAM_DEPTH_MASK_ID << (3 * (depth - 1));\r\nplane_id = plane_id << (3 * (depth - 1));\r\nDRM_DEBUG_DRIVER("%s %s depth=%d\n", sti_mixer_to_str(mixer),\r\nsti_plane_to_str(plane), depth);\r\ndev_dbg(mixer->dev, "GAM_MIXER_CRB val 0x%x mask 0x%x\n",\r\nplane_id, mask);\r\nval &= ~mask;\r\nval |= plane_id;\r\nsti_mixer_reg_write(mixer, GAM_MIXER_CRB, val);\r\ndev_dbg(mixer->dev, "Read GAM_MIXER_CRB 0x%x\n",\r\nsti_mixer_reg_read(mixer, GAM_MIXER_CRB));\r\nreturn 0;\r\n}\r\nint sti_mixer_active_video_area(struct sti_mixer *mixer,\r\nstruct drm_display_mode *mode)\r\n{\r\nu32 ydo, xdo, yds, xds;\r\nydo = sti_vtg_get_line_number(*mode, 0);\r\nyds = sti_vtg_get_line_number(*mode, mode->vdisplay - 1);\r\nxdo = sti_vtg_get_pixel_number(*mode, 0);\r\nxds = sti_vtg_get_pixel_number(*mode, mode->hdisplay - 1);\r\nDRM_DEBUG_DRIVER("%s active video area xdo:%d ydo:%d xds:%d yds:%d\n",\r\nsti_mixer_to_str(mixer), xdo, ydo, xds, yds);\r\nsti_mixer_reg_write(mixer, GAM_MIXER_AVO, ydo << 16 | xdo);\r\nsti_mixer_reg_write(mixer, GAM_MIXER_AVS, yds << 16 | xds);\r\nsti_mixer_set_background_color(mixer, bkg_color);\r\nsti_mixer_set_background_area(mixer, mode);\r\nsti_mixer_set_background_status(mixer, true);\r\nreturn 0;\r\n}\r\nstatic u32 sti_mixer_get_plane_mask(struct sti_plane *plane)\r\n{\r\nswitch (plane->desc) {\r\ncase STI_BACK:\r\nreturn GAM_CTL_BACK_MASK;\r\ncase STI_GDP_0:\r\nreturn GAM_CTL_GDP0_MASK;\r\ncase STI_GDP_1:\r\nreturn GAM_CTL_GDP1_MASK;\r\ncase STI_GDP_2:\r\nreturn GAM_CTL_GDP2_MASK;\r\ncase STI_GDP_3:\r\nreturn GAM_CTL_GDP3_MASK;\r\ncase STI_HQVDP_0:\r\nreturn GAM_CTL_VID0_MASK;\r\ncase STI_CURSOR:\r\nreturn GAM_CTL_CURSOR_MASK;\r\ndefault:\r\nreturn 0;\r\n}\r\n}\r\nint sti_mixer_set_plane_status(struct sti_mixer *mixer,\r\nstruct sti_plane *plane, bool status)\r\n{\r\nu32 mask, val;\r\nDRM_DEBUG_DRIVER("%s %s %s\n", status ? "enable" : "disable",\r\nsti_mixer_to_str(mixer), sti_plane_to_str(plane));\r\nmask = sti_mixer_get_plane_mask(plane);\r\nif (!mask) {\r\nDRM_ERROR("Can't find layer mask\n");\r\nreturn -EINVAL;\r\n}\r\nval = sti_mixer_reg_read(mixer, GAM_MIXER_CTL);\r\nval &= ~mask;\r\nval |= status ? mask : 0;\r\nsti_mixer_reg_write(mixer, GAM_MIXER_CTL, val);\r\nreturn 0;\r\n}\r\nvoid sti_mixer_set_matrix(struct sti_mixer *mixer)\r\n{\r\nunsigned int i;\r\nfor (i = 0; i < ARRAY_SIZE(mixerColorSpaceMatIdentity); i++)\r\nsti_mixer_reg_write(mixer, GAM_MIXER_MX0 + (i * 4),\r\nmixerColorSpaceMatIdentity[i]);\r\n}\r\nstruct sti_mixer *sti_mixer_create(struct device *dev, int id,\r\nvoid __iomem *baseaddr)\r\n{\r\nstruct sti_mixer *mixer = devm_kzalloc(dev, sizeof(*mixer), GFP_KERNEL);\r\nstruct device_node *np = dev->of_node;\r\ndev_dbg(dev, "%s\n", __func__);\r\nif (!mixer) {\r\nDRM_ERROR("Failed to allocated memory for mixer\n");\r\nreturn NULL;\r\n}\r\nmixer->regs = baseaddr;\r\nmixer->dev = dev;\r\nmixer->id = id;\r\nif (of_device_is_compatible(np, "st,stih416-compositor"))\r\nsti_mixer_set_matrix(mixer);\r\nDRM_DEBUG_DRIVER("%s created. Regs=%p\n",\r\nsti_mixer_to_str(mixer), mixer->regs);\r\nreturn mixer;\r\n}
