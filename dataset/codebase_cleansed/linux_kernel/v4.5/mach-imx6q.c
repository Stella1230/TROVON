static int ksz9021rn_phy_fixup(struct phy_device *phydev)\r\n{\r\nif (IS_BUILTIN(CONFIG_PHYLIB)) {\r\nphy_write(phydev, MICREL_KSZ9021_EXTREG_CTRL,\r\n0x8000 | MICREL_KSZ9021_RGMII_RX_DATA_PAD_SCEW);\r\nphy_write(phydev, MICREL_KSZ9021_EXTREG_DATA_WRITE, 0x0000);\r\nphy_write(phydev, MICREL_KSZ9021_EXTREG_CTRL,\r\n0x8000 | MICREL_KSZ9021_RGMII_CLK_CTRL_PAD_SCEW);\r\nphy_write(phydev, MICREL_KSZ9021_EXTREG_DATA_WRITE, 0xf0f0);\r\nphy_write(phydev, MICREL_KSZ9021_EXTREG_CTRL,\r\nMICREL_KSZ9021_RGMII_CLK_CTRL_PAD_SCEW);\r\n}\r\nreturn 0;\r\n}\r\nstatic void mmd_write_reg(struct phy_device *dev, int device, int reg, int val)\r\n{\r\nphy_write(dev, 0x0d, device);\r\nphy_write(dev, 0x0e, reg);\r\nphy_write(dev, 0x0d, (1 << 14) | device);\r\nphy_write(dev, 0x0e, val);\r\n}\r\nstatic int ksz9031rn_phy_fixup(struct phy_device *dev)\r\n{\r\nmmd_write_reg(dev, 2, 4, 0);\r\nmmd_write_reg(dev, 2, 5, 0);\r\nmmd_write_reg(dev, 2, 8, 0x003ff);\r\nreturn 0;\r\n}\r\nstatic void ventana_pciesw_early_fixup(struct pci_dev *dev)\r\n{\r\nu32 dw;\r\nif (!of_machine_is_compatible("gw,ventana"))\r\nreturn;\r\nif (dev->devfn != 0)\r\nreturn;\r\npci_read_config_dword(dev, 0x62c, &dw);\r\ndw |= 0xaaa8;\r\npci_write_config_dword(dev, 0x62c, dw);\r\npci_read_config_dword(dev, 0x644, &dw);\r\ndw |= 0xfe;\r\npci_write_config_dword(dev, 0x644, dw);\r\nmsleep(100);\r\n}\r\nstatic int ar8031_phy_fixup(struct phy_device *dev)\r\n{\r\nu16 val;\r\nphy_write(dev, 0xd, 0x7);\r\nphy_write(dev, 0xe, 0x8016);\r\nphy_write(dev, 0xd, 0x4007);\r\nval = phy_read(dev, 0xe);\r\nval &= 0xffe3;\r\nval |= 0x18;\r\nphy_write(dev, 0xe, val);\r\nphy_write(dev, 0x1d, 0x5);\r\nval = phy_read(dev, 0x1e);\r\nval |= 0x0100;\r\nphy_write(dev, 0x1e, val);\r\nreturn 0;\r\n}\r\nstatic int ar8035_phy_fixup(struct phy_device *dev)\r\n{\r\nu16 val;\r\nphy_write(dev, 0xd, 0x3);\r\nphy_write(dev, 0xe, 0x805d);\r\nphy_write(dev, 0xd, 0x4003);\r\nval = phy_read(dev, 0xe);\r\nphy_write(dev, 0xe, val & ~(1 << 8));\r\nar8031_phy_fixup(dev);\r\nval = phy_read(dev, 0x0);\r\nif (val & BMCR_PDOWN)\r\nphy_write(dev, 0x0, val & ~BMCR_PDOWN);\r\nreturn 0;\r\n}\r\nstatic void __init imx6q_enet_phy_init(void)\r\n{\r\nif (IS_BUILTIN(CONFIG_PHYLIB)) {\r\nphy_register_fixup_for_uid(PHY_ID_KSZ9021, MICREL_PHY_ID_MASK,\r\nksz9021rn_phy_fixup);\r\nphy_register_fixup_for_uid(PHY_ID_KSZ9031, MICREL_PHY_ID_MASK,\r\nksz9031rn_phy_fixup);\r\nphy_register_fixup_for_uid(PHY_ID_AR8031, 0xffffffff,\r\nar8031_phy_fixup);\r\nphy_register_fixup_for_uid(PHY_ID_AR8035, 0xffffffef,\r\nar8035_phy_fixup);\r\n}\r\n}\r\nstatic void __init imx6q_1588_init(void)\r\n{\r\nstruct device_node *np;\r\nstruct clk *ptp_clk;\r\nstruct clk *enet_ref;\r\nstruct regmap *gpr;\r\nu32 clksel;\r\nnp = of_find_compatible_node(NULL, NULL, "fsl,imx6q-fec");\r\nif (!np) {\r\npr_warn("%s: failed to find fec node\n", __func__);\r\nreturn;\r\n}\r\nptp_clk = of_clk_get(np, 2);\r\nif (IS_ERR(ptp_clk)) {\r\npr_warn("%s: failed to get ptp clock\n", __func__);\r\ngoto put_node;\r\n}\r\nenet_ref = clk_get_sys(NULL, "enet_ref");\r\nif (IS_ERR(enet_ref)) {\r\npr_warn("%s: failed to get enet clock\n", __func__);\r\ngoto put_ptp_clk;\r\n}\r\nclksel = clk_is_match(ptp_clk, enet_ref) ?\r\nIMX6Q_GPR1_ENET_CLK_SEL_ANATOP :\r\nIMX6Q_GPR1_ENET_CLK_SEL_PAD;\r\ngpr = syscon_regmap_lookup_by_compatible("fsl,imx6q-iomuxc-gpr");\r\nif (!IS_ERR(gpr))\r\nregmap_update_bits(gpr, IOMUXC_GPR1,\r\nIMX6Q_GPR1_ENET_CLK_SEL_MASK,\r\nclksel);\r\nelse\r\npr_err("failed to find fsl,imx6q-iomux-gpr regmap\n");\r\nclk_put(enet_ref);\r\nput_ptp_clk:\r\nclk_put(ptp_clk);\r\nput_node:\r\nof_node_put(np);\r\n}\r\nstatic void __init imx6q_axi_init(void)\r\n{\r\nstruct regmap *gpr;\r\nunsigned int mask;\r\ngpr = syscon_regmap_lookup_by_compatible("fsl,imx6q-iomuxc-gpr");\r\nif (!IS_ERR(gpr)) {\r\nmask = IMX6Q_GPR4_VPU_WR_CACHE_SEL |\r\nIMX6Q_GPR4_VPU_RD_CACHE_SEL |\r\nIMX6Q_GPR4_VPU_P_WR_CACHE_VAL |\r\nIMX6Q_GPR4_VPU_P_RD_CACHE_VAL_MASK |\r\nIMX6Q_GPR4_IPU_WR_CACHE_CTL |\r\nIMX6Q_GPR4_IPU_RD_CACHE_CTL;\r\nregmap_update_bits(gpr, IOMUXC_GPR4, mask, mask);\r\nregmap_update_bits(gpr, IOMUXC_GPR6,\r\nIMX6Q_GPR6_IPU1_ID00_RD_QOS_MASK |\r\nIMX6Q_GPR6_IPU1_ID01_RD_QOS_MASK,\r\n(0xf << 16) | (0x7 << 20));\r\nregmap_update_bits(gpr, IOMUXC_GPR7,\r\nIMX6Q_GPR7_IPU2_ID00_RD_QOS_MASK |\r\nIMX6Q_GPR7_IPU2_ID01_RD_QOS_MASK,\r\n(0xf << 16) | (0x7 << 20));\r\n} else {\r\npr_warn("failed to find fsl,imx6q-iomuxc-gpr regmap\n");\r\n}\r\n}\r\nstatic void __init imx6q_init_machine(void)\r\n{\r\nstruct device *parent;\r\nimx_print_silicon_rev(cpu_is_imx6dl() ? "i.MX6DL" : "i.MX6Q",\r\nimx_get_soc_revision());\r\nparent = imx_soc_device_init();\r\nif (parent == NULL)\r\npr_warn("failed to initialize soc device\n");\r\nimx6q_enet_phy_init();\r\nof_platform_populate(NULL, of_default_bus_match_table, NULL, parent);\r\nimx_anatop_init();\r\ncpu_is_imx6q() ? imx6q_pm_init() : imx6dl_pm_init();\r\nimx6q_1588_init();\r\nimx6q_axi_init();\r\n}\r\nstatic void __init imx6q_opp_check_speed_grading(struct device *cpu_dev)\r\n{\r\nstruct device_node *np;\r\nvoid __iomem *base;\r\nu32 val;\r\nnp = of_find_compatible_node(NULL, NULL, "fsl,imx6q-ocotp");\r\nif (!np) {\r\npr_warn("failed to find ocotp node\n");\r\nreturn;\r\n}\r\nbase = of_iomap(np, 0);\r\nif (!base) {\r\npr_warn("failed to map ocotp\n");\r\ngoto put_node;\r\n}\r\nval = readl_relaxed(base + OCOTP_CFG3);\r\nval >>= OCOTP_CFG3_SPEED_SHIFT;\r\nval &= 0x3;\r\nif ((val != OCOTP_CFG3_SPEED_1P2GHZ) && cpu_is_imx6q())\r\nif (dev_pm_opp_disable(cpu_dev, 1200000000))\r\npr_warn("failed to disable 1.2 GHz OPP\n");\r\nif (val < OCOTP_CFG3_SPEED_996MHZ)\r\nif (dev_pm_opp_disable(cpu_dev, 996000000))\r\npr_warn("failed to disable 996 MHz OPP\n");\r\nif (cpu_is_imx6q()) {\r\nif (val != OCOTP_CFG3_SPEED_852MHZ)\r\nif (dev_pm_opp_disable(cpu_dev, 852000000))\r\npr_warn("failed to disable 852 MHz OPP\n");\r\n}\r\niounmap(base);\r\nput_node:\r\nof_node_put(np);\r\n}\r\nstatic void __init imx6q_opp_init(void)\r\n{\r\nstruct device_node *np;\r\nstruct device *cpu_dev = get_cpu_device(0);\r\nif (!cpu_dev) {\r\npr_warn("failed to get cpu0 device\n");\r\nreturn;\r\n}\r\nnp = of_node_get(cpu_dev->of_node);\r\nif (!np) {\r\npr_warn("failed to find cpu0 node\n");\r\nreturn;\r\n}\r\nif (dev_pm_opp_of_add_table(cpu_dev)) {\r\npr_warn("failed to init OPP table\n");\r\ngoto put_node;\r\n}\r\nimx6q_opp_check_speed_grading(cpu_dev);\r\nput_node:\r\nof_node_put(np);\r\n}\r\nstatic void __init imx6q_init_late(void)\r\n{\r\nif (imx_get_soc_revision() > IMX_CHIP_REVISION_1_1)\r\nimx6q_cpuidle_init();\r\nif (IS_ENABLED(CONFIG_ARM_IMX6Q_CPUFREQ)) {\r\nimx6q_opp_init();\r\nplatform_device_register(&imx6q_cpufreq_pdev);\r\n}\r\n}\r\nstatic void __init imx6q_map_io(void)\r\n{\r\ndebug_ll_io_init();\r\nimx_scu_map_io();\r\n}\r\nstatic void __init imx6q_init_irq(void)\r\n{\r\nimx_gpc_check_dt();\r\nimx_init_revision_from_anatop();\r\nimx_init_l2cache();\r\nimx_src_init();\r\nirqchip_init();\r\nimx6_pm_ccm_init("fsl,imx6q-ccm");\r\n}
