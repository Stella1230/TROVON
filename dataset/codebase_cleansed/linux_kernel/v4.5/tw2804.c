static int write_reg(struct i2c_client *client, u8 reg, u8 value, u8 channel)\r\n{\r\nreturn i2c_smbus_write_byte_data(client, reg | (channel << 6), value);\r\n}\r\nstatic int write_regs(struct i2c_client *client, const u8 *regs, u8 channel)\r\n{\r\nint ret;\r\nint i;\r\nfor (i = 0; regs[i] != 0xff; i += 2) {\r\nret = i2c_smbus_write_byte_data(client,\r\nregs[i] | (channel << 6), regs[i + 1]);\r\nif (ret < 0)\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic int read_reg(struct i2c_client *client, u8 reg, u8 channel)\r\n{\r\nreturn i2c_smbus_read_byte_data(client, (reg) | (channel << 6));\r\n}\r\nstatic inline struct tw2804 *to_state(struct v4l2_subdev *sd)\r\n{\r\nreturn container_of(sd, struct tw2804, sd);\r\n}\r\nstatic inline struct tw2804 *to_state_from_ctrl(struct v4l2_ctrl *ctrl)\r\n{\r\nreturn container_of(ctrl->handler, struct tw2804, hdl);\r\n}\r\nstatic int tw2804_log_status(struct v4l2_subdev *sd)\r\n{\r\nstruct tw2804 *state = to_state(sd);\r\nv4l2_info(sd, "Standard: %s\n",\r\nstate->norm & V4L2_STD_525_60 ? "60 Hz" : "50 Hz");\r\nv4l2_info(sd, "Channel: %d\n", state->channel);\r\nv4l2_info(sd, "Input: %d\n", state->input);\r\nreturn v4l2_ctrl_subdev_log_status(sd);\r\n}\r\nstatic int tw2804_g_volatile_ctrl(struct v4l2_ctrl *ctrl)\r\n{\r\nstruct tw2804 *state = to_state_from_ctrl(ctrl);\r\nstruct i2c_client *client = v4l2_get_subdevdata(&state->sd);\r\nswitch (ctrl->id) {\r\ncase V4L2_CID_GAIN:\r\nctrl->val = read_reg(client, TW2804_REG_GAIN, 0);\r\nreturn 0;\r\ncase V4L2_CID_CHROMA_GAIN:\r\nctrl->val = read_reg(client, TW2804_REG_CHROMA_GAIN, 0);\r\nreturn 0;\r\ncase V4L2_CID_BLUE_BALANCE:\r\nctrl->val = read_reg(client, TW2804_REG_BLUE_BALANCE, 0);\r\nreturn 0;\r\ncase V4L2_CID_RED_BALANCE:\r\nctrl->val = read_reg(client, TW2804_REG_RED_BALANCE, 0);\r\nreturn 0;\r\n}\r\nreturn 0;\r\n}\r\nstatic int tw2804_s_ctrl(struct v4l2_ctrl *ctrl)\r\n{\r\nstruct tw2804 *state = to_state_from_ctrl(ctrl);\r\nstruct i2c_client *client = v4l2_get_subdevdata(&state->sd);\r\nint addr;\r\nint reg;\r\nswitch (ctrl->id) {\r\ncase V4L2_CID_AUTOGAIN:\r\naddr = TW2804_REG_AUTOGAIN;\r\nreg = read_reg(client, addr, state->channel);\r\nif (reg < 0)\r\nreturn reg;\r\nif (ctrl->val == 0)\r\nreg &= ~(1 << 7);\r\nelse\r\nreg |= 1 << 7;\r\nreturn write_reg(client, addr, reg, state->channel);\r\ncase V4L2_CID_COLOR_KILLER:\r\naddr = TW2804_REG_COLOR_KILLER;\r\nreg = read_reg(client, addr, state->channel);\r\nif (reg < 0)\r\nreturn reg;\r\nreg = (reg & ~(0x03)) | (ctrl->val == 0 ? 0x02 : 0x03);\r\nreturn write_reg(client, addr, reg, state->channel);\r\ncase V4L2_CID_GAIN:\r\nreturn write_reg(client, TW2804_REG_GAIN, ctrl->val, 0);\r\ncase V4L2_CID_CHROMA_GAIN:\r\nreturn write_reg(client, TW2804_REG_CHROMA_GAIN, ctrl->val, 0);\r\ncase V4L2_CID_BLUE_BALANCE:\r\nreturn write_reg(client, TW2804_REG_BLUE_BALANCE, ctrl->val, 0);\r\ncase V4L2_CID_RED_BALANCE:\r\nreturn write_reg(client, TW2804_REG_RED_BALANCE, ctrl->val, 0);\r\ncase V4L2_CID_BRIGHTNESS:\r\nreturn write_reg(client, TW2804_REG_BRIGHTNESS,\r\nctrl->val, state->channel);\r\ncase V4L2_CID_CONTRAST:\r\nreturn write_reg(client, TW2804_REG_CONTRAST,\r\nctrl->val, state->channel);\r\ncase V4L2_CID_SATURATION:\r\nreturn write_reg(client, TW2804_REG_SATURATION,\r\nctrl->val, state->channel);\r\ncase V4L2_CID_HUE:\r\nreturn write_reg(client, TW2804_REG_HUE,\r\nctrl->val, state->channel);\r\ndefault:\r\nbreak;\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int tw2804_s_std(struct v4l2_subdev *sd, v4l2_std_id norm)\r\n{\r\nstruct tw2804 *dec = to_state(sd);\r\nstruct i2c_client *client = v4l2_get_subdevdata(sd);\r\nbool is_60hz = norm & V4L2_STD_525_60;\r\nu8 regs[] = {\r\n0x01, is_60hz ? 0xc4 : 0x84,\r\n0x09, is_60hz ? 0x07 : 0x04,\r\n0x0a, is_60hz ? 0xf0 : 0x20,\r\n0x0b, is_60hz ? 0x07 : 0x04,\r\n0x0c, is_60hz ? 0xf0 : 0x20,\r\n0x0d, is_60hz ? 0x40 : 0x4a,\r\n0x16, is_60hz ? 0x00 : 0x40,\r\n0x17, is_60hz ? 0x00 : 0x40,\r\n0x20, is_60hz ? 0x07 : 0x0f,\r\n0x21, is_60hz ? 0x07 : 0x0f,\r\n0xff, 0xff,\r\n};\r\nwrite_regs(client, regs, dec->channel);\r\ndec->norm = norm;\r\nreturn 0;\r\n}\r\nstatic int tw2804_s_video_routing(struct v4l2_subdev *sd, u32 input, u32 output,\r\nu32 config)\r\n{\r\nstruct tw2804 *dec = to_state(sd);\r\nstruct i2c_client *client = v4l2_get_subdevdata(sd);\r\nint reg;\r\nif (config && config - 1 != dec->channel) {\r\nif (config > 4) {\r\ndev_err(&client->dev,\r\n"channel %d is not between 1 and 4!\n", config);\r\nreturn -EINVAL;\r\n}\r\ndec->channel = config - 1;\r\ndev_dbg(&client->dev, "initializing TW2804 channel %d\n",\r\ndec->channel);\r\nif (dec->channel == 0 &&\r\nwrite_regs(client, global_registers, 0) < 0) {\r\ndev_err(&client->dev,\r\n"error initializing TW2804 global registers\n");\r\nreturn -EIO;\r\n}\r\nif (write_regs(client, channel_registers, dec->channel) < 0) {\r\ndev_err(&client->dev,\r\n"error initializing TW2804 channel %d\n",\r\ndec->channel);\r\nreturn -EIO;\r\n}\r\n}\r\nif (input > 1)\r\nreturn -EINVAL;\r\nif (input == dec->input)\r\nreturn 0;\r\nreg = read_reg(client, 0x22, dec->channel);\r\nif (reg >= 0) {\r\nif (input == 0)\r\nreg &= ~(1 << 2);\r\nelse\r\nreg |= 1 << 2;\r\nreg = write_reg(client, 0x22, reg, dec->channel);\r\n}\r\nif (reg >= 0)\r\ndec->input = input;\r\nelse\r\nreturn reg;\r\nreturn 0;\r\n}\r\nstatic int tw2804_probe(struct i2c_client *client,\r\nconst struct i2c_device_id *id)\r\n{\r\nstruct i2c_adapter *adapter = client->adapter;\r\nstruct tw2804 *state;\r\nstruct v4l2_subdev *sd;\r\nstruct v4l2_ctrl *ctrl;\r\nint err;\r\nif (!i2c_check_functionality(adapter, I2C_FUNC_SMBUS_BYTE_DATA))\r\nreturn -ENODEV;\r\nstate = devm_kzalloc(&client->dev, sizeof(*state), GFP_KERNEL);\r\nif (state == NULL)\r\nreturn -ENOMEM;\r\nsd = &state->sd;\r\nv4l2_i2c_subdev_init(sd, client, &tw2804_ops);\r\nstate->channel = -1;\r\nstate->norm = V4L2_STD_NTSC;\r\nv4l2_ctrl_handler_init(&state->hdl, 10);\r\nv4l2_ctrl_new_std(&state->hdl, &tw2804_ctrl_ops,\r\nV4L2_CID_BRIGHTNESS, 0, 255, 1, 128);\r\nv4l2_ctrl_new_std(&state->hdl, &tw2804_ctrl_ops,\r\nV4L2_CID_CONTRAST, 0, 255, 1, 128);\r\nv4l2_ctrl_new_std(&state->hdl, &tw2804_ctrl_ops,\r\nV4L2_CID_SATURATION, 0, 255, 1, 128);\r\nv4l2_ctrl_new_std(&state->hdl, &tw2804_ctrl_ops,\r\nV4L2_CID_HUE, 0, 255, 1, 128);\r\nv4l2_ctrl_new_std(&state->hdl, &tw2804_ctrl_ops,\r\nV4L2_CID_COLOR_KILLER, 0, 1, 1, 0);\r\nv4l2_ctrl_new_std(&state->hdl, &tw2804_ctrl_ops,\r\nV4L2_CID_AUTOGAIN, 0, 1, 1, 0);\r\nctrl = v4l2_ctrl_new_std(&state->hdl, &tw2804_ctrl_ops,\r\nV4L2_CID_GAIN, 0, 255, 1, 128);\r\nif (ctrl)\r\nctrl->flags |= V4L2_CTRL_FLAG_VOLATILE;\r\nctrl = v4l2_ctrl_new_std(&state->hdl, &tw2804_ctrl_ops,\r\nV4L2_CID_CHROMA_GAIN, 0, 255, 1, 128);\r\nif (ctrl)\r\nctrl->flags |= V4L2_CTRL_FLAG_VOLATILE;\r\nctrl = v4l2_ctrl_new_std(&state->hdl, &tw2804_ctrl_ops,\r\nV4L2_CID_BLUE_BALANCE, 0, 255, 1, 122);\r\nif (ctrl)\r\nctrl->flags |= V4L2_CTRL_FLAG_VOLATILE;\r\nctrl = v4l2_ctrl_new_std(&state->hdl, &tw2804_ctrl_ops,\r\nV4L2_CID_RED_BALANCE, 0, 255, 1, 122);\r\nif (ctrl)\r\nctrl->flags |= V4L2_CTRL_FLAG_VOLATILE;\r\nsd->ctrl_handler = &state->hdl;\r\nerr = state->hdl.error;\r\nif (err) {\r\nv4l2_ctrl_handler_free(&state->hdl);\r\nreturn err;\r\n}\r\nv4l_info(client, "chip found @ 0x%02x (%s)\n",\r\nclient->addr << 1, client->adapter->name);\r\nreturn 0;\r\n}\r\nstatic int tw2804_remove(struct i2c_client *client)\r\n{\r\nstruct v4l2_subdev *sd = i2c_get_clientdata(client);\r\nstruct tw2804 *state = to_state(sd);\r\nv4l2_device_unregister_subdev(sd);\r\nv4l2_ctrl_handler_free(&state->hdl);\r\nreturn 0;\r\n}
