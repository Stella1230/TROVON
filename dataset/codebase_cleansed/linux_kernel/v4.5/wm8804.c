static int wm8804_aif_event(struct snd_soc_dapm_widget *w,\r\nstruct snd_kcontrol *kcontrol, int event)\r\n{\r\nstruct snd_soc_codec *codec = snd_soc_dapm_to_codec(w->dapm);\r\nstruct wm8804_priv *wm8804 = snd_soc_codec_get_drvdata(codec);\r\nswitch (event) {\r\ncase SND_SOC_DAPM_POST_PMU:\r\nif (!wm8804->aif_pwr)\r\nsnd_soc_update_bits(codec, WM8804_PWRDN, 0x10, 0x0);\r\nwm8804->aif_pwr++;\r\nbreak;\r\ncase SND_SOC_DAPM_POST_PMD:\r\nwm8804->aif_pwr--;\r\nif (!wm8804->aif_pwr)\r\nsnd_soc_update_bits(codec, WM8804_PWRDN, 0x10, 0x10);\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic int txsrc_put(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_soc_codec *codec = snd_soc_dapm_kcontrol_codec(kcontrol);\r\nstruct snd_soc_dapm_context *dapm = snd_soc_codec_get_dapm(codec);\r\nstruct soc_enum *e = (struct soc_enum *)kcontrol->private_value;\r\nunsigned int val = ucontrol->value.enumerated.item[0] << e->shift_l;\r\nunsigned int mask = 1 << e->shift_l;\r\nunsigned int txpwr;\r\nif (val != 0 && val != mask)\r\nreturn -EINVAL;\r\nsnd_soc_dapm_mutex_lock(dapm);\r\nif (snd_soc_test_bits(codec, e->reg, mask, val)) {\r\ntxpwr = snd_soc_read(codec, WM8804_PWRDN) & 0x4;\r\nsnd_soc_update_bits(codec, WM8804_PWRDN, 0x4, 0x4);\r\nsnd_soc_update_bits(codec, e->reg, mask, val);\r\nsnd_soc_update_bits(codec, WM8804_PWRDN, 0x4, txpwr);\r\n}\r\nsnd_soc_dapm_mutex_unlock(dapm);\r\nreturn 0;\r\n}\r\nstatic bool wm8804_volatile(struct device *dev, unsigned int reg)\r\n{\r\nswitch (reg) {\r\ncase WM8804_RST_DEVID1:\r\ncase WM8804_DEVID2:\r\ncase WM8804_DEVREV:\r\ncase WM8804_INTSTAT:\r\ncase WM8804_SPDSTAT:\r\ncase WM8804_RXCHAN1:\r\ncase WM8804_RXCHAN2:\r\ncase WM8804_RXCHAN3:\r\ncase WM8804_RXCHAN4:\r\ncase WM8804_RXCHAN5:\r\nreturn true;\r\ndefault:\r\nreturn false;\r\n}\r\n}\r\nstatic int wm8804_soft_reset(struct wm8804_priv *wm8804)\r\n{\r\nreturn regmap_write(wm8804->regmap, WM8804_RST_DEVID1, 0x0);\r\n}\r\nstatic int wm8804_set_fmt(struct snd_soc_dai *dai, unsigned int fmt)\r\n{\r\nstruct snd_soc_codec *codec;\r\nu16 format, master, bcp, lrp;\r\ncodec = dai->codec;\r\nswitch (fmt & SND_SOC_DAIFMT_FORMAT_MASK) {\r\ncase SND_SOC_DAIFMT_I2S:\r\nformat = 0x2;\r\nbreak;\r\ncase SND_SOC_DAIFMT_RIGHT_J:\r\nformat = 0x0;\r\nbreak;\r\ncase SND_SOC_DAIFMT_LEFT_J:\r\nformat = 0x1;\r\nbreak;\r\ncase SND_SOC_DAIFMT_DSP_A:\r\ncase SND_SOC_DAIFMT_DSP_B:\r\nformat = 0x3;\r\nbreak;\r\ndefault:\r\ndev_err(dai->dev, "Unknown dai format\n");\r\nreturn -EINVAL;\r\n}\r\nsnd_soc_update_bits(codec, WM8804_AIFTX, 0x3, format);\r\nsnd_soc_update_bits(codec, WM8804_AIFRX, 0x3, format);\r\nswitch (fmt & SND_SOC_DAIFMT_MASTER_MASK) {\r\ncase SND_SOC_DAIFMT_CBM_CFM:\r\nmaster = 1;\r\nbreak;\r\ncase SND_SOC_DAIFMT_CBS_CFS:\r\nmaster = 0;\r\nbreak;\r\ndefault:\r\ndev_err(dai->dev, "Unknown master/slave configuration\n");\r\nreturn -EINVAL;\r\n}\r\nsnd_soc_update_bits(codec, WM8804_AIFRX, 0x40, master << 6);\r\nbcp = lrp = 0;\r\nswitch (fmt & SND_SOC_DAIFMT_INV_MASK) {\r\ncase SND_SOC_DAIFMT_NB_NF:\r\nbreak;\r\ncase SND_SOC_DAIFMT_IB_IF:\r\nbcp = lrp = 1;\r\nbreak;\r\ncase SND_SOC_DAIFMT_IB_NF:\r\nbcp = 1;\r\nbreak;\r\ncase SND_SOC_DAIFMT_NB_IF:\r\nlrp = 1;\r\nbreak;\r\ndefault:\r\ndev_err(dai->dev, "Unknown polarity configuration\n");\r\nreturn -EINVAL;\r\n}\r\nsnd_soc_update_bits(codec, WM8804_AIFTX, 0x10 | 0x20,\r\n(bcp << 4) | (lrp << 5));\r\nsnd_soc_update_bits(codec, WM8804_AIFRX, 0x10 | 0x20,\r\n(bcp << 4) | (lrp << 5));\r\nreturn 0;\r\n}\r\nstatic int wm8804_hw_params(struct snd_pcm_substream *substream,\r\nstruct snd_pcm_hw_params *params,\r\nstruct snd_soc_dai *dai)\r\n{\r\nstruct snd_soc_codec *codec;\r\nu16 blen;\r\ncodec = dai->codec;\r\nswitch (params_width(params)) {\r\ncase 16:\r\nblen = 0x0;\r\nbreak;\r\ncase 20:\r\nblen = 0x1;\r\nbreak;\r\ncase 24:\r\nblen = 0x2;\r\nbreak;\r\ndefault:\r\ndev_err(dai->dev, "Unsupported word length: %u\n",\r\nparams_width(params));\r\nreturn -EINVAL;\r\n}\r\nsnd_soc_update_bits(codec, WM8804_AIFTX, 0xc, blen << 2);\r\nsnd_soc_update_bits(codec, WM8804_AIFRX, 0xc, blen << 2);\r\nreturn 0;\r\n}\r\nstatic int pll_factors(struct pll_div *pll_div, unsigned int target,\r\nunsigned int source, unsigned int mclk_div)\r\n{\r\nu64 Kpart;\r\nunsigned long int K, Ndiv, Nmod, tmp;\r\nint i;\r\nfor (i = 0; i < ARRAY_SIZE(post_table); i++) {\r\ntmp = target * post_table[i].div;\r\nif ((tmp >= 90000000 && tmp <= 100000000) &&\r\n(mclk_div == post_table[i].mclkdiv)) {\r\npll_div->freqmode = post_table[i].freqmode;\r\npll_div->mclkdiv = post_table[i].mclkdiv;\r\ntarget *= post_table[i].div;\r\nbreak;\r\n}\r\n}\r\nif (i == ARRAY_SIZE(post_table)) {\r\npr_err("%s: Unable to scale output frequency: %uHz\n",\r\n__func__, target);\r\nreturn -EINVAL;\r\n}\r\npll_div->prescale = 0;\r\nNdiv = target / source;\r\nif (Ndiv < 5) {\r\nsource >>= 1;\r\npll_div->prescale = 1;\r\nNdiv = target / source;\r\n}\r\nif (Ndiv < 5 || Ndiv > 13) {\r\npr_err("%s: WM8804 N value is not within the recommended range: %lu\n",\r\n__func__, Ndiv);\r\nreturn -EINVAL;\r\n}\r\npll_div->n = Ndiv;\r\nNmod = target % source;\r\nKpart = FIXED_PLL_SIZE * (u64)Nmod;\r\ndo_div(Kpart, source);\r\nK = Kpart & 0xffffffff;\r\nif ((K % 10) >= 5)\r\nK += 5;\r\nK /= 10;\r\npll_div->k = K;\r\nreturn 0;\r\n}\r\nstatic int wm8804_set_pll(struct snd_soc_dai *dai, int pll_id,\r\nint source, unsigned int freq_in,\r\nunsigned int freq_out)\r\n{\r\nstruct snd_soc_codec *codec = dai->codec;\r\nstruct wm8804_priv *wm8804 = snd_soc_codec_get_drvdata(codec);\r\nbool change;\r\nif (!freq_in || !freq_out) {\r\nregmap_update_bits_check(wm8804->regmap, WM8804_PWRDN,\r\n0x1, 0x1, &change);\r\nif (change)\r\npm_runtime_put(wm8804->dev);\r\n} else {\r\nint ret;\r\nstruct pll_div pll_div;\r\nret = pll_factors(&pll_div, freq_out, freq_in,\r\nwm8804->mclk_div);\r\nif (ret)\r\nreturn ret;\r\nregmap_update_bits_check(wm8804->regmap, WM8804_PWRDN,\r\n0x1, 0x1, &change);\r\nif (!change)\r\npm_runtime_get_sync(wm8804->dev);\r\nsnd_soc_update_bits(codec, WM8804_PLL4, 0xf | 0x10,\r\npll_div.n | (pll_div.prescale << 4));\r\nsnd_soc_update_bits(codec, WM8804_PLL5, 0x3 | 0x8,\r\npll_div.freqmode | (pll_div.mclkdiv << 3));\r\nsnd_soc_write(codec, WM8804_PLL1, pll_div.k & 0xff);\r\nsnd_soc_write(codec, WM8804_PLL2, (pll_div.k >> 8) & 0xff);\r\nsnd_soc_write(codec, WM8804_PLL3, pll_div.k >> 16);\r\nsnd_soc_update_bits(codec, WM8804_PWRDN, 0x1, 0);\r\n}\r\nreturn 0;\r\n}\r\nstatic int wm8804_set_sysclk(struct snd_soc_dai *dai,\r\nint clk_id, unsigned int freq, int dir)\r\n{\r\nstruct snd_soc_codec *codec;\r\ncodec = dai->codec;\r\nswitch (clk_id) {\r\ncase WM8804_TX_CLKSRC_MCLK:\r\nif ((freq >= 10000000 && freq <= 14400000)\r\n|| (freq >= 16280000 && freq <= 27000000))\r\nsnd_soc_update_bits(codec, WM8804_PLL6, 0x80, 0x80);\r\nelse {\r\ndev_err(dai->dev, "OSCCLOCK is not within the "\r\n"recommended range: %uHz\n", freq);\r\nreturn -EINVAL;\r\n}\r\nbreak;\r\ncase WM8804_TX_CLKSRC_PLL:\r\nsnd_soc_update_bits(codec, WM8804_PLL6, 0x80, 0);\r\nbreak;\r\ncase WM8804_CLKOUT_SRC_CLK1:\r\nsnd_soc_update_bits(codec, WM8804_PLL6, 0x8, 0);\r\nbreak;\r\ncase WM8804_CLKOUT_SRC_OSCCLK:\r\nsnd_soc_update_bits(codec, WM8804_PLL6, 0x8, 0x8);\r\nbreak;\r\ndefault:\r\ndev_err(dai->dev, "Unknown clock source: %d\n", clk_id);\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int wm8804_set_clkdiv(struct snd_soc_dai *dai,\r\nint div_id, int div)\r\n{\r\nstruct snd_soc_codec *codec;\r\nstruct wm8804_priv *wm8804;\r\ncodec = dai->codec;\r\nswitch (div_id) {\r\ncase WM8804_CLKOUT_DIV:\r\nsnd_soc_update_bits(codec, WM8804_PLL5, 0x30,\r\n(div & 0x3) << 4);\r\nbreak;\r\ncase WM8804_MCLK_DIV:\r\nwm8804 = snd_soc_codec_get_drvdata(codec);\r\nwm8804->mclk_div = div;\r\nbreak;\r\ndefault:\r\ndev_err(dai->dev, "Unknown clock divider: %d\n", div_id);\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nint wm8804_probe(struct device *dev, struct regmap *regmap)\r\n{\r\nstruct wm8804_priv *wm8804;\r\nunsigned int id1, id2;\r\nint i, ret;\r\nwm8804 = devm_kzalloc(dev, sizeof(*wm8804), GFP_KERNEL);\r\nif (!wm8804)\r\nreturn -ENOMEM;\r\ndev_set_drvdata(dev, wm8804);\r\nwm8804->dev = dev;\r\nwm8804->regmap = regmap;\r\nwm8804->reset = devm_gpiod_get_optional(dev, "wlf,reset",\r\nGPIOD_OUT_LOW);\r\nif (IS_ERR(wm8804->reset)) {\r\nret = PTR_ERR(wm8804->reset);\r\ndev_err(dev, "Failed to get reset line: %d\n", ret);\r\nreturn ret;\r\n}\r\nfor (i = 0; i < ARRAY_SIZE(wm8804->supplies); i++)\r\nwm8804->supplies[i].supply = wm8804_supply_names[i];\r\nret = devm_regulator_bulk_get(dev, ARRAY_SIZE(wm8804->supplies),\r\nwm8804->supplies);\r\nif (ret) {\r\ndev_err(dev, "Failed to request supplies: %d\n", ret);\r\nreturn ret;\r\n}\r\nwm8804->disable_nb[0].notifier_call = wm8804_regulator_event_0;\r\nwm8804->disable_nb[1].notifier_call = wm8804_regulator_event_1;\r\nfor (i = 0; i < ARRAY_SIZE(wm8804->supplies); i++) {\r\nstruct regulator *regulator = wm8804->supplies[i].consumer;\r\nret = devm_regulator_register_notifier(regulator,\r\n&wm8804->disable_nb[i]);\r\nif (ret != 0) {\r\ndev_err(dev,\r\n"Failed to register regulator notifier: %d\n",\r\nret);\r\nreturn ret;\r\n}\r\n}\r\nret = regulator_bulk_enable(ARRAY_SIZE(wm8804->supplies),\r\nwm8804->supplies);\r\nif (ret) {\r\ndev_err(dev, "Failed to enable supplies: %d\n", ret);\r\nreturn ret;\r\n}\r\nif (wm8804->reset)\r\ngpiod_set_value_cansleep(wm8804->reset, 1);\r\nret = regmap_read(regmap, WM8804_RST_DEVID1, &id1);\r\nif (ret < 0) {\r\ndev_err(dev, "Failed to read device ID: %d\n", ret);\r\ngoto err_reg_enable;\r\n}\r\nret = regmap_read(regmap, WM8804_DEVID2, &id2);\r\nif (ret < 0) {\r\ndev_err(dev, "Failed to read device ID: %d\n", ret);\r\ngoto err_reg_enable;\r\n}\r\nid2 = (id2 << 8) | id1;\r\nif (id2 != 0x8805) {\r\ndev_err(dev, "Invalid device ID: %#x\n", id2);\r\nret = -EINVAL;\r\ngoto err_reg_enable;\r\n}\r\nret = regmap_read(regmap, WM8804_DEVREV, &id1);\r\nif (ret < 0) {\r\ndev_err(dev, "Failed to read device revision: %d\n",\r\nret);\r\ngoto err_reg_enable;\r\n}\r\ndev_info(dev, "revision %c\n", id1 + 'A');\r\nif (!wm8804->reset) {\r\nret = wm8804_soft_reset(wm8804);\r\nif (ret < 0) {\r\ndev_err(dev, "Failed to issue reset: %d\n", ret);\r\ngoto err_reg_enable;\r\n}\r\n}\r\nret = snd_soc_register_codec(dev, &soc_codec_dev_wm8804,\r\n&wm8804_dai, 1);\r\nif (ret < 0) {\r\ndev_err(dev, "Failed to register CODEC: %d\n", ret);\r\ngoto err_reg_enable;\r\n}\r\npm_runtime_set_active(dev);\r\npm_runtime_enable(dev);\r\npm_runtime_idle(dev);\r\nreturn 0;\r\nerr_reg_enable:\r\nregulator_bulk_disable(ARRAY_SIZE(wm8804->supplies), wm8804->supplies);\r\nreturn ret;\r\n}\r\nvoid wm8804_remove(struct device *dev)\r\n{\r\npm_runtime_disable(dev);\r\nsnd_soc_unregister_codec(dev);\r\n}\r\nstatic int wm8804_runtime_resume(struct device *dev)\r\n{\r\nstruct wm8804_priv *wm8804 = dev_get_drvdata(dev);\r\nint ret;\r\nret = regulator_bulk_enable(ARRAY_SIZE(wm8804->supplies),\r\nwm8804->supplies);\r\nif (ret) {\r\ndev_err(wm8804->dev, "Failed to enable supplies: %d\n", ret);\r\nreturn ret;\r\n}\r\nregcache_sync(wm8804->regmap);\r\nregmap_update_bits(wm8804->regmap, WM8804_PWRDN, 0x8, 0x0);\r\nreturn 0;\r\n}\r\nstatic int wm8804_runtime_suspend(struct device *dev)\r\n{\r\nstruct wm8804_priv *wm8804 = dev_get_drvdata(dev);\r\nregmap_update_bits(wm8804->regmap, WM8804_PWRDN, 0x8, 0x8);\r\nregulator_bulk_disable(ARRAY_SIZE(wm8804->supplies),\r\nwm8804->supplies);\r\nreturn 0;\r\n}
