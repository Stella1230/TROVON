static u8 clear_interruption(struct st33zp24_dev *tpm_dev)\r\n{\r\nu8 interrupt;\r\ntpm_dev->ops->recv(tpm_dev->phy_id, TPM_INT_STATUS, &interrupt, 1);\r\ntpm_dev->ops->send(tpm_dev->phy_id, TPM_INT_STATUS, &interrupt, 1);\r\nreturn interrupt;\r\n}\r\nstatic void st33zp24_cancel(struct tpm_chip *chip)\r\n{\r\nstruct st33zp24_dev *tpm_dev;\r\nu8 data;\r\ntpm_dev = (struct st33zp24_dev *)TPM_VPRIV(chip);\r\ndata = TPM_STS_COMMAND_READY;\r\ntpm_dev->ops->send(tpm_dev->phy_id, TPM_STS, &data, 1);\r\n}\r\nstatic u8 st33zp24_status(struct tpm_chip *chip)\r\n{\r\nstruct st33zp24_dev *tpm_dev;\r\nu8 data;\r\ntpm_dev = (struct st33zp24_dev *)TPM_VPRIV(chip);\r\ntpm_dev->ops->recv(tpm_dev->phy_id, TPM_STS, &data, 1);\r\nreturn data;\r\n}\r\nstatic int check_locality(struct tpm_chip *chip)\r\n{\r\nstruct st33zp24_dev *tpm_dev;\r\nu8 data;\r\nu8 status;\r\ntpm_dev = (struct st33zp24_dev *)TPM_VPRIV(chip);\r\nstatus = tpm_dev->ops->recv(tpm_dev->phy_id, TPM_ACCESS, &data, 1);\r\nif (status && (data &\r\n(TPM_ACCESS_ACTIVE_LOCALITY | TPM_ACCESS_VALID)) ==\r\n(TPM_ACCESS_ACTIVE_LOCALITY | TPM_ACCESS_VALID))\r\nreturn chip->vendor.locality;\r\nreturn -EACCES;\r\n}\r\nstatic int request_locality(struct tpm_chip *chip)\r\n{\r\nunsigned long stop;\r\nlong ret;\r\nstruct st33zp24_dev *tpm_dev;\r\nu8 data;\r\nif (check_locality(chip) == chip->vendor.locality)\r\nreturn chip->vendor.locality;\r\ntpm_dev = (struct st33zp24_dev *)TPM_VPRIV(chip);\r\ndata = TPM_ACCESS_REQUEST_USE;\r\nret = tpm_dev->ops->send(tpm_dev->phy_id, TPM_ACCESS, &data, 1);\r\nif (ret < 0)\r\nreturn ret;\r\nstop = jiffies + chip->vendor.timeout_a;\r\ndo {\r\nif (check_locality(chip) >= 0)\r\nreturn chip->vendor.locality;\r\nmsleep(TPM_TIMEOUT);\r\n} while (time_before(jiffies, stop));\r\nreturn -EACCES;\r\n}\r\nstatic void release_locality(struct tpm_chip *chip)\r\n{\r\nstruct st33zp24_dev *tpm_dev;\r\nu8 data;\r\ntpm_dev = (struct st33zp24_dev *)TPM_VPRIV(chip);\r\ndata = TPM_ACCESS_ACTIVE_LOCALITY;\r\ntpm_dev->ops->send(tpm_dev->phy_id, TPM_ACCESS, &data, 1);\r\n}\r\nstatic int get_burstcount(struct tpm_chip *chip)\r\n{\r\nunsigned long stop;\r\nint burstcnt, status;\r\nu8 tpm_reg, temp;\r\nstruct st33zp24_dev *tpm_dev;\r\ntpm_dev = (struct st33zp24_dev *)TPM_VPRIV(chip);\r\nstop = jiffies + chip->vendor.timeout_d;\r\ndo {\r\ntpm_reg = TPM_STS + 1;\r\nstatus = tpm_dev->ops->recv(tpm_dev->phy_id, tpm_reg, &temp, 1);\r\nif (status < 0)\r\nreturn -EBUSY;\r\ntpm_reg = TPM_STS + 2;\r\nburstcnt = temp;\r\nstatus = tpm_dev->ops->recv(tpm_dev->phy_id, tpm_reg, &temp, 1);\r\nif (status < 0)\r\nreturn -EBUSY;\r\nburstcnt |= temp << 8;\r\nif (burstcnt)\r\nreturn burstcnt;\r\nmsleep(TPM_TIMEOUT);\r\n} while (time_before(jiffies, stop));\r\nreturn -EBUSY;\r\n}\r\nstatic bool wait_for_tpm_stat_cond(struct tpm_chip *chip, u8 mask,\r\nbool check_cancel, bool *canceled)\r\n{\r\nu8 status = chip->ops->status(chip);\r\n*canceled = false;\r\nif ((status & mask) == mask)\r\nreturn true;\r\nif (check_cancel && chip->ops->req_canceled(chip, status)) {\r\n*canceled = true;\r\nreturn true;\r\n}\r\nreturn false;\r\n}\r\nstatic int wait_for_stat(struct tpm_chip *chip, u8 mask, unsigned long timeout,\r\nwait_queue_head_t *queue, bool check_cancel)\r\n{\r\nunsigned long stop;\r\nint ret = 0;\r\nbool canceled = false;\r\nbool condition;\r\nu32 cur_intrs;\r\nu8 status;\r\nstruct st33zp24_dev *tpm_dev;\r\ntpm_dev = (struct st33zp24_dev *)TPM_VPRIV(chip);\r\nstatus = st33zp24_status(chip);\r\nif ((status & mask) == mask)\r\nreturn 0;\r\nstop = jiffies + timeout;\r\nif (chip->vendor.irq) {\r\ncur_intrs = tpm_dev->intrs;\r\nclear_interruption(tpm_dev);\r\nenable_irq(chip->vendor.irq);\r\ndo {\r\nif (ret == -ERESTARTSYS && freezing(current))\r\nclear_thread_flag(TIF_SIGPENDING);\r\ntimeout = stop - jiffies;\r\nif ((long) timeout <= 0)\r\nreturn -1;\r\nret = wait_event_interruptible_timeout(*queue,\r\ncur_intrs != tpm_dev->intrs,\r\ntimeout);\r\nclear_interruption(tpm_dev);\r\ncondition = wait_for_tpm_stat_cond(chip, mask,\r\ncheck_cancel, &canceled);\r\nif (ret >= 0 && condition) {\r\nif (canceled)\r\nreturn -ECANCELED;\r\nreturn 0;\r\n}\r\n} while (ret == -ERESTARTSYS && freezing(current));\r\ndisable_irq_nosync(chip->vendor.irq);\r\n} else {\r\ndo {\r\nmsleep(TPM_TIMEOUT);\r\nstatus = chip->ops->status(chip);\r\nif ((status & mask) == mask)\r\nreturn 0;\r\n} while (time_before(jiffies, stop));\r\n}\r\nreturn -ETIME;\r\n}\r\nstatic int recv_data(struct tpm_chip *chip, u8 *buf, size_t count)\r\n{\r\nint size = 0, burstcnt, len, ret;\r\nstruct st33zp24_dev *tpm_dev;\r\ntpm_dev = (struct st33zp24_dev *)TPM_VPRIV(chip);\r\nwhile (size < count &&\r\nwait_for_stat(chip,\r\nTPM_STS_DATA_AVAIL | TPM_STS_VALID,\r\nchip->vendor.timeout_c,\r\n&chip->vendor.read_queue, true) == 0) {\r\nburstcnt = get_burstcount(chip);\r\nif (burstcnt < 0)\r\nreturn burstcnt;\r\nlen = min_t(int, burstcnt, count - size);\r\nret = tpm_dev->ops->recv(tpm_dev->phy_id, TPM_DATA_FIFO,\r\nbuf + size, len);\r\nif (ret < 0)\r\nreturn ret;\r\nsize += len;\r\n}\r\nreturn size;\r\n}\r\nstatic irqreturn_t tpm_ioserirq_handler(int irq, void *dev_id)\r\n{\r\nstruct tpm_chip *chip = dev_id;\r\nstruct st33zp24_dev *tpm_dev;\r\ntpm_dev = (struct st33zp24_dev *)TPM_VPRIV(chip);\r\ntpm_dev->intrs++;\r\nwake_up_interruptible(&chip->vendor.read_queue);\r\ndisable_irq_nosync(chip->vendor.irq);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int st33zp24_send(struct tpm_chip *chip, unsigned char *buf,\r\nsize_t len)\r\n{\r\nu32 status, i, size, ordinal;\r\nint burstcnt = 0;\r\nint ret;\r\nu8 data;\r\nstruct st33zp24_dev *tpm_dev;\r\nif (!chip)\r\nreturn -EBUSY;\r\nif (len < TPM_HEADER_SIZE)\r\nreturn -EBUSY;\r\ntpm_dev = (struct st33zp24_dev *)TPM_VPRIV(chip);\r\nret = request_locality(chip);\r\nif (ret < 0)\r\nreturn ret;\r\nstatus = st33zp24_status(chip);\r\nif ((status & TPM_STS_COMMAND_READY) == 0) {\r\nst33zp24_cancel(chip);\r\nif (wait_for_stat\r\n(chip, TPM_STS_COMMAND_READY, chip->vendor.timeout_b,\r\n&chip->vendor.read_queue, false) < 0) {\r\nret = -ETIME;\r\ngoto out_err;\r\n}\r\n}\r\nfor (i = 0; i < len - 1;) {\r\nburstcnt = get_burstcount(chip);\r\nif (burstcnt < 0)\r\nreturn burstcnt;\r\nsize = min_t(int, len - i - 1, burstcnt);\r\nret = tpm_dev->ops->send(tpm_dev->phy_id, TPM_DATA_FIFO,\r\nbuf + i, size);\r\nif (ret < 0)\r\ngoto out_err;\r\ni += size;\r\n}\r\nstatus = st33zp24_status(chip);\r\nif ((status & TPM_STS_DATA_EXPECT) == 0) {\r\nret = -EIO;\r\ngoto out_err;\r\n}\r\nret = tpm_dev->ops->send(tpm_dev->phy_id, TPM_DATA_FIFO,\r\nbuf + len - 1, 1);\r\nif (ret < 0)\r\ngoto out_err;\r\nstatus = st33zp24_status(chip);\r\nif ((status & TPM_STS_DATA_EXPECT) != 0) {\r\nret = -EIO;\r\ngoto out_err;\r\n}\r\ndata = TPM_STS_GO;\r\nret = tpm_dev->ops->send(tpm_dev->phy_id, TPM_STS, &data, 1);\r\nif (ret < 0)\r\ngoto out_err;\r\nif (chip->vendor.irq) {\r\nordinal = be32_to_cpu(*((__be32 *) (buf + 6)));\r\nret = wait_for_stat(chip, TPM_STS_DATA_AVAIL | TPM_STS_VALID,\r\ntpm_calc_ordinal_duration(chip, ordinal),\r\n&chip->vendor.read_queue, false);\r\nif (ret < 0)\r\ngoto out_err;\r\n}\r\nreturn len;\r\nout_err:\r\nst33zp24_cancel(chip);\r\nrelease_locality(chip);\r\nreturn ret;\r\n}\r\nstatic int st33zp24_recv(struct tpm_chip *chip, unsigned char *buf,\r\nsize_t count)\r\n{\r\nint size = 0;\r\nint expected;\r\nif (!chip)\r\nreturn -EBUSY;\r\nif (count < TPM_HEADER_SIZE) {\r\nsize = -EIO;\r\ngoto out;\r\n}\r\nsize = recv_data(chip, buf, TPM_HEADER_SIZE);\r\nif (size < TPM_HEADER_SIZE) {\r\ndev_err(&chip->dev, "Unable to read header\n");\r\ngoto out;\r\n}\r\nexpected = be32_to_cpu(*(__be32 *)(buf + 2));\r\nif (expected > count) {\r\nsize = -EIO;\r\ngoto out;\r\n}\r\nsize += recv_data(chip, &buf[TPM_HEADER_SIZE],\r\nexpected - TPM_HEADER_SIZE);\r\nif (size < expected) {\r\ndev_err(&chip->dev, "Unable to read remainder of result\n");\r\nsize = -ETIME;\r\n}\r\nout:\r\nst33zp24_cancel(chip);\r\nrelease_locality(chip);\r\nreturn size;\r\n}\r\nstatic bool st33zp24_req_canceled(struct tpm_chip *chip, u8 status)\r\n{\r\nreturn (status == TPM_STS_COMMAND_READY);\r\n}\r\nint st33zp24_probe(void *phy_id, const struct st33zp24_phy_ops *ops,\r\nstruct device *dev, int irq, int io_lpcpd)\r\n{\r\nint ret;\r\nu8 intmask = 0;\r\nstruct tpm_chip *chip;\r\nstruct st33zp24_dev *tpm_dev;\r\nchip = tpmm_chip_alloc(dev, &st33zp24_tpm);\r\nif (IS_ERR(chip))\r\nreturn PTR_ERR(chip);\r\ntpm_dev = devm_kzalloc(dev, sizeof(struct st33zp24_dev),\r\nGFP_KERNEL);\r\nif (!tpm_dev)\r\nreturn -ENOMEM;\r\nTPM_VPRIV(chip) = tpm_dev;\r\ntpm_dev->phy_id = phy_id;\r\ntpm_dev->ops = ops;\r\nchip->vendor.timeout_a = msecs_to_jiffies(TIS_SHORT_TIMEOUT);\r\nchip->vendor.timeout_b = msecs_to_jiffies(TIS_LONG_TIMEOUT);\r\nchip->vendor.timeout_c = msecs_to_jiffies(TIS_SHORT_TIMEOUT);\r\nchip->vendor.timeout_d = msecs_to_jiffies(TIS_SHORT_TIMEOUT);\r\nchip->vendor.locality = LOCALITY0;\r\nif (irq) {\r\ninit_waitqueue_head(&chip->vendor.read_queue);\r\ntpm_dev->intrs = 0;\r\nif (request_locality(chip) != LOCALITY0) {\r\nret = -ENODEV;\r\ngoto _tpm_clean_answer;\r\n}\r\nclear_interruption(tpm_dev);\r\nret = devm_request_irq(dev, irq, tpm_ioserirq_handler,\r\nIRQF_TRIGGER_HIGH, "TPM SERIRQ management",\r\nchip);\r\nif (ret < 0) {\r\ndev_err(&chip->dev, "TPM SERIRQ signals %d not available\n",\r\nirq);\r\ngoto _tpm_clean_answer;\r\n}\r\nintmask |= TPM_INTF_CMD_READY_INT\r\n| TPM_INTF_STS_VALID_INT\r\n| TPM_INTF_DATA_AVAIL_INT;\r\nret = tpm_dev->ops->send(tpm_dev->phy_id, TPM_INT_ENABLE,\r\n&intmask, 1);\r\nif (ret < 0)\r\ngoto _tpm_clean_answer;\r\nintmask = TPM_GLOBAL_INT_ENABLE;\r\nret = tpm_dev->ops->send(tpm_dev->phy_id, (TPM_INT_ENABLE + 3),\r\n&intmask, 1);\r\nif (ret < 0)\r\ngoto _tpm_clean_answer;\r\nchip->vendor.irq = irq;\r\ndisable_irq_nosync(chip->vendor.irq);\r\ntpm_gen_interrupt(chip);\r\n}\r\ntpm_get_timeouts(chip);\r\ntpm_do_selftest(chip);\r\nreturn tpm_chip_register(chip);\r\n_tpm_clean_answer:\r\ndev_info(&chip->dev, "TPM initialization fail\n");\r\nreturn ret;\r\n}\r\nint st33zp24_remove(struct tpm_chip *chip)\r\n{\r\ntpm_chip_unregister(chip);\r\nreturn 0;\r\n}\r\nint st33zp24_pm_suspend(struct device *dev)\r\n{\r\nstruct tpm_chip *chip = dev_get_drvdata(dev);\r\nstruct st33zp24_dev *tpm_dev;\r\nint ret = 0;\r\ntpm_dev = (struct st33zp24_dev *)TPM_VPRIV(chip);\r\nif (gpio_is_valid(tpm_dev->io_lpcpd))\r\ngpio_set_value(tpm_dev->io_lpcpd, 0);\r\nelse\r\nret = tpm_pm_suspend(dev);\r\nreturn ret;\r\n}\r\nint st33zp24_pm_resume(struct device *dev)\r\n{\r\nstruct tpm_chip *chip = dev_get_drvdata(dev);\r\nstruct st33zp24_dev *tpm_dev;\r\nint ret = 0;\r\ntpm_dev = (struct st33zp24_dev *)TPM_VPRIV(chip);\r\nif (gpio_is_valid(tpm_dev->io_lpcpd)) {\r\ngpio_set_value(tpm_dev->io_lpcpd, 1);\r\nret = wait_for_stat(chip,\r\nTPM_STS_VALID, chip->vendor.timeout_b,\r\n&chip->vendor.read_queue, false);\r\n} else {\r\nret = tpm_pm_resume(dev);\r\nif (!ret)\r\ntpm_do_selftest(chip);\r\n}\r\nreturn ret;\r\n}
