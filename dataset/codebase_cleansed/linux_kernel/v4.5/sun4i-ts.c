static void sun4i_ts_irq_handle_input(struct sun4i_ts_data *ts, u32 reg_val)\r\n{\r\nu32 x, y;\r\nif (reg_val & FIFO_DATA_PENDING) {\r\nx = readl(ts->base + TP_DATA);\r\ny = readl(ts->base + TP_DATA);\r\nif (!ts->ignore_fifo_data) {\r\ninput_report_abs(ts->input, ABS_X, x);\r\ninput_report_abs(ts->input, ABS_Y, y);\r\ninput_report_key(ts->input, BTN_TOUCH, 1);\r\ninput_sync(ts->input);\r\n} else {\r\nts->ignore_fifo_data = false;\r\n}\r\n}\r\nif (reg_val & TP_UP_PENDING) {\r\nts->ignore_fifo_data = true;\r\ninput_report_key(ts->input, BTN_TOUCH, 0);\r\ninput_sync(ts->input);\r\n}\r\n}\r\nstatic irqreturn_t sun4i_ts_irq(int irq, void *dev_id)\r\n{\r\nstruct sun4i_ts_data *ts = dev_id;\r\nu32 reg_val;\r\nreg_val = readl(ts->base + TP_INT_FIFOS);\r\nif (reg_val & TEMP_DATA_PENDING)\r\nts->temp_data = readl(ts->base + TEMP_DATA);\r\nif (ts->input)\r\nsun4i_ts_irq_handle_input(ts, reg_val);\r\nwritel(reg_val, ts->base + TP_INT_FIFOS);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int sun4i_ts_open(struct input_dev *dev)\r\n{\r\nstruct sun4i_ts_data *ts = input_get_drvdata(dev);\r\nwritel(TEMP_IRQ_EN(1) | DATA_IRQ_EN(1) | FIFO_TRIG(1) | FIFO_FLUSH(1) |\r\nTP_UP_IRQ_EN(1), ts->base + TP_INT_FIFOC);\r\nreturn 0;\r\n}\r\nstatic void sun4i_ts_close(struct input_dev *dev)\r\n{\r\nstruct sun4i_ts_data *ts = input_get_drvdata(dev);\r\nwritel(TEMP_IRQ_EN(1), ts->base + TP_INT_FIFOC);\r\n}\r\nstatic int sun4i_get_temp(const struct sun4i_ts_data *ts, int *temp)\r\n{\r\nif (ts->temp_data == -1)\r\nreturn -EAGAIN;\r\n*temp = ts->temp_data * ts->temp_step - ts->temp_offset;\r\nreturn 0;\r\n}\r\nstatic int sun4i_get_tz_temp(void *data, int *temp)\r\n{\r\nreturn sun4i_get_temp(data, temp);\r\n}\r\nstatic ssize_t show_temp(struct device *dev, struct device_attribute *devattr,\r\nchar *buf)\r\n{\r\nstruct sun4i_ts_data *ts = dev_get_drvdata(dev);\r\nint temp;\r\nint error;\r\nerror = sun4i_get_temp(ts, &temp);\r\nif (error)\r\nreturn error;\r\nreturn sprintf(buf, "%d\n", temp);\r\n}\r\nstatic ssize_t show_temp_label(struct device *dev,\r\nstruct device_attribute *devattr, char *buf)\r\n{\r\nreturn sprintf(buf, "SoC temperature\n");\r\n}\r\nstatic int sun4i_ts_probe(struct platform_device *pdev)\r\n{\r\nstruct sun4i_ts_data *ts;\r\nstruct device *dev = &pdev->dev;\r\nstruct device_node *np = dev->of_node;\r\nstruct device *hwmon;\r\nint error;\r\nu32 reg;\r\nbool ts_attached;\r\nu32 tp_sensitive_adjust = 15;\r\nu32 filter_type = 1;\r\nts = devm_kzalloc(dev, sizeof(struct sun4i_ts_data), GFP_KERNEL);\r\nif (!ts)\r\nreturn -ENOMEM;\r\nts->dev = dev;\r\nts->ignore_fifo_data = true;\r\nts->temp_data = -1;\r\nif (of_device_is_compatible(np, "allwinner,sun6i-a31-ts")) {\r\nts->temp_offset = 271000;\r\nts->temp_step = 167;\r\n} else if (of_device_is_compatible(np, "allwinner,sun4i-a10-ts")) {\r\nts->temp_offset = 257000;\r\nts->temp_step = 133;\r\n} else {\r\nts->temp_offset = 144700;\r\nts->temp_step = 100;\r\n}\r\nts_attached = of_property_read_bool(np, "allwinner,ts-attached");\r\nif (ts_attached) {\r\nts->input = devm_input_allocate_device(dev);\r\nif (!ts->input)\r\nreturn -ENOMEM;\r\nts->input->name = pdev->name;\r\nts->input->phys = "sun4i_ts/input0";\r\nts->input->open = sun4i_ts_open;\r\nts->input->close = sun4i_ts_close;\r\nts->input->id.bustype = BUS_HOST;\r\nts->input->id.vendor = 0x0001;\r\nts->input->id.product = 0x0001;\r\nts->input->id.version = 0x0100;\r\nts->input->evbit[0] = BIT(EV_SYN) | BIT(EV_KEY) | BIT(EV_ABS);\r\n__set_bit(BTN_TOUCH, ts->input->keybit);\r\ninput_set_abs_params(ts->input, ABS_X, 0, 4095, 0, 0);\r\ninput_set_abs_params(ts->input, ABS_Y, 0, 4095, 0, 0);\r\ninput_set_drvdata(ts->input, ts);\r\n}\r\nts->base = devm_ioremap_resource(dev,\r\nplatform_get_resource(pdev, IORESOURCE_MEM, 0));\r\nif (IS_ERR(ts->base))\r\nreturn PTR_ERR(ts->base);\r\nts->irq = platform_get_irq(pdev, 0);\r\nerror = devm_request_irq(dev, ts->irq, sun4i_ts_irq, 0, "sun4i-ts", ts);\r\nif (error)\r\nreturn error;\r\nwritel(ADC_CLK_SEL(0) | ADC_CLK_DIV(2) | FS_DIV(7) | T_ACQ(63),\r\nts->base + TP_CTRL0);\r\nof_property_read_u32(np, "allwinner,tp-sensitive-adjust",\r\n&tp_sensitive_adjust);\r\nwritel(TP_SENSITIVE_ADJUST(tp_sensitive_adjust) | TP_MODE_SELECT(0),\r\nts->base + TP_CTRL2);\r\nof_property_read_u32(np, "allwinner,filter-type", &filter_type);\r\nwritel(FILTER_EN(1) | FILTER_TYPE(filter_type), ts->base + TP_CTRL3);\r\nwritel(TEMP_ENABLE(1) | TEMP_PERIOD(1953), ts->base + TP_TPR);\r\nreg = STYLUS_UP_DEBOUN(5) | STYLUS_UP_DEBOUN_EN(1);\r\nif (of_device_is_compatible(np, "allwinner,sun6i-a31-ts"))\r\nreg |= SUN6I_TP_MODE_EN(1);\r\nelse\r\nreg |= TP_MODE_EN(1);\r\nwritel(reg, ts->base + TP_CTRL1);\r\nhwmon = devm_hwmon_device_register_with_groups(ts->dev, "sun4i_ts",\r\nts, sun4i_ts_groups);\r\nif (IS_ERR(hwmon))\r\nreturn PTR_ERR(hwmon);\r\nts->tz = thermal_zone_of_sensor_register(ts->dev, 0, ts,\r\n&sun4i_ts_tz_ops);\r\nif (IS_ERR(ts->tz))\r\nts->tz = NULL;\r\nwritel(TEMP_IRQ_EN(1), ts->base + TP_INT_FIFOC);\r\nif (ts_attached) {\r\nerror = input_register_device(ts->input);\r\nif (error) {\r\nwritel(0, ts->base + TP_INT_FIFOC);\r\nthermal_zone_of_sensor_unregister(ts->dev, ts->tz);\r\nreturn error;\r\n}\r\n}\r\nplatform_set_drvdata(pdev, ts);\r\nreturn 0;\r\n}\r\nstatic int sun4i_ts_remove(struct platform_device *pdev)\r\n{\r\nstruct sun4i_ts_data *ts = platform_get_drvdata(pdev);\r\nif (ts->input)\r\ninput_unregister_device(ts->input);\r\nthermal_zone_of_sensor_unregister(ts->dev, ts->tz);\r\nwritel(0, ts->base + TP_INT_FIFOC);\r\nreturn 0;\r\n}
