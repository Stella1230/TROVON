static u16 range_n_bytes(const struct sw_flow_key_range *range)\r\n{\r\nreturn range->end - range->start;\r\n}\r\nvoid ovs_flow_mask_key(struct sw_flow_key *dst, const struct sw_flow_key *src,\r\nbool full, const struct sw_flow_mask *mask)\r\n{\r\nint start = full ? 0 : mask->range.start;\r\nint len = full ? sizeof *dst : range_n_bytes(&mask->range);\r\nconst long *m = (const long *)((const u8 *)&mask->key + start);\r\nconst long *s = (const long *)((const u8 *)src + start);\r\nlong *d = (long *)((u8 *)dst + start);\r\nint i;\r\nfor (i = 0; i < len; i += sizeof(long))\r\n*d++ = *s++ & *m++;\r\n}\r\nstruct sw_flow *ovs_flow_alloc(void)\r\n{\r\nstruct sw_flow *flow;\r\nstruct flow_stats *stats;\r\nint node;\r\nflow = kmem_cache_alloc(flow_cache, GFP_KERNEL);\r\nif (!flow)\r\nreturn ERR_PTR(-ENOMEM);\r\nflow->sf_acts = NULL;\r\nflow->mask = NULL;\r\nflow->id.unmasked_key = NULL;\r\nflow->id.ufid_len = 0;\r\nflow->stats_last_writer = NUMA_NO_NODE;\r\nstats = kmem_cache_alloc_node(flow_stats_cache,\r\nGFP_KERNEL | __GFP_ZERO,\r\nnode_online(0) ? 0 : NUMA_NO_NODE);\r\nif (!stats)\r\ngoto err;\r\nspin_lock_init(&stats->lock);\r\nRCU_INIT_POINTER(flow->stats[0], stats);\r\nfor_each_node(node)\r\nif (node != 0)\r\nRCU_INIT_POINTER(flow->stats[node], NULL);\r\nreturn flow;\r\nerr:\r\nkmem_cache_free(flow_cache, flow);\r\nreturn ERR_PTR(-ENOMEM);\r\n}\r\nint ovs_flow_tbl_count(const struct flow_table *table)\r\n{\r\nreturn table->count;\r\n}\r\nstatic struct flex_array *alloc_buckets(unsigned int n_buckets)\r\n{\r\nstruct flex_array *buckets;\r\nint i, err;\r\nbuckets = flex_array_alloc(sizeof(struct hlist_head),\r\nn_buckets, GFP_KERNEL);\r\nif (!buckets)\r\nreturn NULL;\r\nerr = flex_array_prealloc(buckets, 0, n_buckets, GFP_KERNEL);\r\nif (err) {\r\nflex_array_free(buckets);\r\nreturn NULL;\r\n}\r\nfor (i = 0; i < n_buckets; i++)\r\nINIT_HLIST_HEAD((struct hlist_head *)\r\nflex_array_get(buckets, i));\r\nreturn buckets;\r\n}\r\nstatic void flow_free(struct sw_flow *flow)\r\n{\r\nint node;\r\nif (ovs_identifier_is_key(&flow->id))\r\nkfree(flow->id.unmasked_key);\r\nif (flow->sf_acts)\r\novs_nla_free_flow_actions((struct sw_flow_actions __force *)flow->sf_acts);\r\nfor_each_node(node)\r\nif (flow->stats[node])\r\nkmem_cache_free(flow_stats_cache,\r\n(struct flow_stats __force *)flow->stats[node]);\r\nkmem_cache_free(flow_cache, flow);\r\n}\r\nstatic void rcu_free_flow_callback(struct rcu_head *rcu)\r\n{\r\nstruct sw_flow *flow = container_of(rcu, struct sw_flow, rcu);\r\nflow_free(flow);\r\n}\r\nvoid ovs_flow_free(struct sw_flow *flow, bool deferred)\r\n{\r\nif (!flow)\r\nreturn;\r\nif (deferred)\r\ncall_rcu(&flow->rcu, rcu_free_flow_callback);\r\nelse\r\nflow_free(flow);\r\n}\r\nstatic void free_buckets(struct flex_array *buckets)\r\n{\r\nflex_array_free(buckets);\r\n}\r\nstatic void __table_instance_destroy(struct table_instance *ti)\r\n{\r\nfree_buckets(ti->buckets);\r\nkfree(ti);\r\n}\r\nstatic struct table_instance *table_instance_alloc(int new_size)\r\n{\r\nstruct table_instance *ti = kmalloc(sizeof(*ti), GFP_KERNEL);\r\nif (!ti)\r\nreturn NULL;\r\nti->buckets = alloc_buckets(new_size);\r\nif (!ti->buckets) {\r\nkfree(ti);\r\nreturn NULL;\r\n}\r\nti->n_buckets = new_size;\r\nti->node_ver = 0;\r\nti->keep_flows = false;\r\nget_random_bytes(&ti->hash_seed, sizeof(u32));\r\nreturn ti;\r\n}\r\nint ovs_flow_tbl_init(struct flow_table *table)\r\n{\r\nstruct table_instance *ti, *ufid_ti;\r\nti = table_instance_alloc(TBL_MIN_BUCKETS);\r\nif (!ti)\r\nreturn -ENOMEM;\r\nufid_ti = table_instance_alloc(TBL_MIN_BUCKETS);\r\nif (!ufid_ti)\r\ngoto free_ti;\r\nrcu_assign_pointer(table->ti, ti);\r\nrcu_assign_pointer(table->ufid_ti, ufid_ti);\r\nINIT_LIST_HEAD(&table->mask_list);\r\ntable->last_rehash = jiffies;\r\ntable->count = 0;\r\ntable->ufid_count = 0;\r\nreturn 0;\r\nfree_ti:\r\n__table_instance_destroy(ti);\r\nreturn -ENOMEM;\r\n}\r\nstatic void flow_tbl_destroy_rcu_cb(struct rcu_head *rcu)\r\n{\r\nstruct table_instance *ti = container_of(rcu, struct table_instance, rcu);\r\n__table_instance_destroy(ti);\r\n}\r\nstatic void table_instance_destroy(struct table_instance *ti,\r\nstruct table_instance *ufid_ti,\r\nbool deferred)\r\n{\r\nint i;\r\nif (!ti)\r\nreturn;\r\nBUG_ON(!ufid_ti);\r\nif (ti->keep_flows)\r\ngoto skip_flows;\r\nfor (i = 0; i < ti->n_buckets; i++) {\r\nstruct sw_flow *flow;\r\nstruct hlist_head *head = flex_array_get(ti->buckets, i);\r\nstruct hlist_node *n;\r\nint ver = ti->node_ver;\r\nint ufid_ver = ufid_ti->node_ver;\r\nhlist_for_each_entry_safe(flow, n, head, flow_table.node[ver]) {\r\nhlist_del_rcu(&flow->flow_table.node[ver]);\r\nif (ovs_identifier_is_ufid(&flow->id))\r\nhlist_del_rcu(&flow->ufid_table.node[ufid_ver]);\r\novs_flow_free(flow, deferred);\r\n}\r\n}\r\nskip_flows:\r\nif (deferred) {\r\ncall_rcu(&ti->rcu, flow_tbl_destroy_rcu_cb);\r\ncall_rcu(&ufid_ti->rcu, flow_tbl_destroy_rcu_cb);\r\n} else {\r\n__table_instance_destroy(ti);\r\n__table_instance_destroy(ufid_ti);\r\n}\r\n}\r\nvoid ovs_flow_tbl_destroy(struct flow_table *table)\r\n{\r\nstruct table_instance *ti = rcu_dereference_raw(table->ti);\r\nstruct table_instance *ufid_ti = rcu_dereference_raw(table->ufid_ti);\r\ntable_instance_destroy(ti, ufid_ti, false);\r\n}\r\nstruct sw_flow *ovs_flow_tbl_dump_next(struct table_instance *ti,\r\nu32 *bucket, u32 *last)\r\n{\r\nstruct sw_flow *flow;\r\nstruct hlist_head *head;\r\nint ver;\r\nint i;\r\nver = ti->node_ver;\r\nwhile (*bucket < ti->n_buckets) {\r\ni = 0;\r\nhead = flex_array_get(ti->buckets, *bucket);\r\nhlist_for_each_entry_rcu(flow, head, flow_table.node[ver]) {\r\nif (i < *last) {\r\ni++;\r\ncontinue;\r\n}\r\n*last = i + 1;\r\nreturn flow;\r\n}\r\n(*bucket)++;\r\n*last = 0;\r\n}\r\nreturn NULL;\r\n}\r\nstatic struct hlist_head *find_bucket(struct table_instance *ti, u32 hash)\r\n{\r\nhash = jhash_1word(hash, ti->hash_seed);\r\nreturn flex_array_get(ti->buckets,\r\n(hash & (ti->n_buckets - 1)));\r\n}\r\nstatic void table_instance_insert(struct table_instance *ti,\r\nstruct sw_flow *flow)\r\n{\r\nstruct hlist_head *head;\r\nhead = find_bucket(ti, flow->flow_table.hash);\r\nhlist_add_head_rcu(&flow->flow_table.node[ti->node_ver], head);\r\n}\r\nstatic void ufid_table_instance_insert(struct table_instance *ti,\r\nstruct sw_flow *flow)\r\n{\r\nstruct hlist_head *head;\r\nhead = find_bucket(ti, flow->ufid_table.hash);\r\nhlist_add_head_rcu(&flow->ufid_table.node[ti->node_ver], head);\r\n}\r\nstatic void flow_table_copy_flows(struct table_instance *old,\r\nstruct table_instance *new, bool ufid)\r\n{\r\nint old_ver;\r\nint i;\r\nold_ver = old->node_ver;\r\nnew->node_ver = !old_ver;\r\nfor (i = 0; i < old->n_buckets; i++) {\r\nstruct sw_flow *flow;\r\nstruct hlist_head *head;\r\nhead = flex_array_get(old->buckets, i);\r\nif (ufid)\r\nhlist_for_each_entry(flow, head,\r\nufid_table.node[old_ver])\r\nufid_table_instance_insert(new, flow);\r\nelse\r\nhlist_for_each_entry(flow, head,\r\nflow_table.node[old_ver])\r\ntable_instance_insert(new, flow);\r\n}\r\nold->keep_flows = true;\r\n}\r\nstatic struct table_instance *table_instance_rehash(struct table_instance *ti,\r\nint n_buckets, bool ufid)\r\n{\r\nstruct table_instance *new_ti;\r\nnew_ti = table_instance_alloc(n_buckets);\r\nif (!new_ti)\r\nreturn NULL;\r\nflow_table_copy_flows(ti, new_ti, ufid);\r\nreturn new_ti;\r\n}\r\nint ovs_flow_tbl_flush(struct flow_table *flow_table)\r\n{\r\nstruct table_instance *old_ti, *new_ti;\r\nstruct table_instance *old_ufid_ti, *new_ufid_ti;\r\nnew_ti = table_instance_alloc(TBL_MIN_BUCKETS);\r\nif (!new_ti)\r\nreturn -ENOMEM;\r\nnew_ufid_ti = table_instance_alloc(TBL_MIN_BUCKETS);\r\nif (!new_ufid_ti)\r\ngoto err_free_ti;\r\nold_ti = ovsl_dereference(flow_table->ti);\r\nold_ufid_ti = ovsl_dereference(flow_table->ufid_ti);\r\nrcu_assign_pointer(flow_table->ti, new_ti);\r\nrcu_assign_pointer(flow_table->ufid_ti, new_ufid_ti);\r\nflow_table->last_rehash = jiffies;\r\nflow_table->count = 0;\r\nflow_table->ufid_count = 0;\r\ntable_instance_destroy(old_ti, old_ufid_ti, true);\r\nreturn 0;\r\nerr_free_ti:\r\n__table_instance_destroy(new_ti);\r\nreturn -ENOMEM;\r\n}\r\nstatic u32 flow_hash(const struct sw_flow_key *key,\r\nconst struct sw_flow_key_range *range)\r\n{\r\nint key_start = range->start;\r\nint key_end = range->end;\r\nconst u32 *hash_key = (const u32 *)((const u8 *)key + key_start);\r\nint hash_u32s = (key_end - key_start) >> 2;\r\nBUILD_BUG_ON(sizeof(long) % sizeof(u32));\r\nreturn jhash2(hash_key, hash_u32s, 0);\r\n}\r\nstatic int flow_key_start(const struct sw_flow_key *key)\r\n{\r\nif (key->tun_proto)\r\nreturn 0;\r\nelse\r\nreturn rounddown(offsetof(struct sw_flow_key, phy),\r\nsizeof(long));\r\n}\r\nstatic bool cmp_key(const struct sw_flow_key *key1,\r\nconst struct sw_flow_key *key2,\r\nint key_start, int key_end)\r\n{\r\nconst long *cp1 = (const long *)((const u8 *)key1 + key_start);\r\nconst long *cp2 = (const long *)((const u8 *)key2 + key_start);\r\nlong diffs = 0;\r\nint i;\r\nfor (i = key_start; i < key_end; i += sizeof(long))\r\ndiffs |= *cp1++ ^ *cp2++;\r\nreturn diffs == 0;\r\n}\r\nstatic bool flow_cmp_masked_key(const struct sw_flow *flow,\r\nconst struct sw_flow_key *key,\r\nconst struct sw_flow_key_range *range)\r\n{\r\nreturn cmp_key(&flow->key, key, range->start, range->end);\r\n}\r\nstatic bool ovs_flow_cmp_unmasked_key(const struct sw_flow *flow,\r\nconst struct sw_flow_match *match)\r\n{\r\nstruct sw_flow_key *key = match->key;\r\nint key_start = flow_key_start(key);\r\nint key_end = match->range.end;\r\nBUG_ON(ovs_identifier_is_ufid(&flow->id));\r\nreturn cmp_key(flow->id.unmasked_key, key, key_start, key_end);\r\n}\r\nstatic struct sw_flow *masked_flow_lookup(struct table_instance *ti,\r\nconst struct sw_flow_key *unmasked,\r\nconst struct sw_flow_mask *mask)\r\n{\r\nstruct sw_flow *flow;\r\nstruct hlist_head *head;\r\nu32 hash;\r\nstruct sw_flow_key masked_key;\r\novs_flow_mask_key(&masked_key, unmasked, false, mask);\r\nhash = flow_hash(&masked_key, &mask->range);\r\nhead = find_bucket(ti, hash);\r\nhlist_for_each_entry_rcu(flow, head, flow_table.node[ti->node_ver]) {\r\nif (flow->mask == mask && flow->flow_table.hash == hash &&\r\nflow_cmp_masked_key(flow, &masked_key, &mask->range))\r\nreturn flow;\r\n}\r\nreturn NULL;\r\n}\r\nstruct sw_flow *ovs_flow_tbl_lookup_stats(struct flow_table *tbl,\r\nconst struct sw_flow_key *key,\r\nu32 *n_mask_hit)\r\n{\r\nstruct table_instance *ti = rcu_dereference_ovsl(tbl->ti);\r\nstruct sw_flow_mask *mask;\r\nstruct sw_flow *flow;\r\n*n_mask_hit = 0;\r\nlist_for_each_entry_rcu(mask, &tbl->mask_list, list) {\r\n(*n_mask_hit)++;\r\nflow = masked_flow_lookup(ti, key, mask);\r\nif (flow)\r\nreturn flow;\r\n}\r\nreturn NULL;\r\n}\r\nstruct sw_flow *ovs_flow_tbl_lookup(struct flow_table *tbl,\r\nconst struct sw_flow_key *key)\r\n{\r\nu32 __always_unused n_mask_hit;\r\nreturn ovs_flow_tbl_lookup_stats(tbl, key, &n_mask_hit);\r\n}\r\nstruct sw_flow *ovs_flow_tbl_lookup_exact(struct flow_table *tbl,\r\nconst struct sw_flow_match *match)\r\n{\r\nstruct table_instance *ti = rcu_dereference_ovsl(tbl->ti);\r\nstruct sw_flow_mask *mask;\r\nstruct sw_flow *flow;\r\nlist_for_each_entry(mask, &tbl->mask_list, list) {\r\nflow = masked_flow_lookup(ti, match->key, mask);\r\nif (flow && ovs_identifier_is_key(&flow->id) &&\r\novs_flow_cmp_unmasked_key(flow, match))\r\nreturn flow;\r\n}\r\nreturn NULL;\r\n}\r\nstatic u32 ufid_hash(const struct sw_flow_id *sfid)\r\n{\r\nreturn jhash(sfid->ufid, sfid->ufid_len, 0);\r\n}\r\nstatic bool ovs_flow_cmp_ufid(const struct sw_flow *flow,\r\nconst struct sw_flow_id *sfid)\r\n{\r\nif (flow->id.ufid_len != sfid->ufid_len)\r\nreturn false;\r\nreturn !memcmp(flow->id.ufid, sfid->ufid, sfid->ufid_len);\r\n}\r\nbool ovs_flow_cmp(const struct sw_flow *flow, const struct sw_flow_match *match)\r\n{\r\nif (ovs_identifier_is_ufid(&flow->id))\r\nreturn flow_cmp_masked_key(flow, match->key, &match->range);\r\nreturn ovs_flow_cmp_unmasked_key(flow, match);\r\n}\r\nstruct sw_flow *ovs_flow_tbl_lookup_ufid(struct flow_table *tbl,\r\nconst struct sw_flow_id *ufid)\r\n{\r\nstruct table_instance *ti = rcu_dereference_ovsl(tbl->ufid_ti);\r\nstruct sw_flow *flow;\r\nstruct hlist_head *head;\r\nu32 hash;\r\nhash = ufid_hash(ufid);\r\nhead = find_bucket(ti, hash);\r\nhlist_for_each_entry_rcu(flow, head, ufid_table.node[ti->node_ver]) {\r\nif (flow->ufid_table.hash == hash &&\r\novs_flow_cmp_ufid(flow, ufid))\r\nreturn flow;\r\n}\r\nreturn NULL;\r\n}\r\nint ovs_flow_tbl_num_masks(const struct flow_table *table)\r\n{\r\nstruct sw_flow_mask *mask;\r\nint num = 0;\r\nlist_for_each_entry(mask, &table->mask_list, list)\r\nnum++;\r\nreturn num;\r\n}\r\nstatic struct table_instance *table_instance_expand(struct table_instance *ti,\r\nbool ufid)\r\n{\r\nreturn table_instance_rehash(ti, ti->n_buckets * 2, ufid);\r\n}\r\nstatic void flow_mask_remove(struct flow_table *tbl, struct sw_flow_mask *mask)\r\n{\r\nif (mask) {\r\nASSERT_OVSL();\r\nBUG_ON(!mask->ref_count);\r\nmask->ref_count--;\r\nif (!mask->ref_count) {\r\nlist_del_rcu(&mask->list);\r\nkfree_rcu(mask, rcu);\r\n}\r\n}\r\n}\r\nvoid ovs_flow_tbl_remove(struct flow_table *table, struct sw_flow *flow)\r\n{\r\nstruct table_instance *ti = ovsl_dereference(table->ti);\r\nstruct table_instance *ufid_ti = ovsl_dereference(table->ufid_ti);\r\nBUG_ON(table->count == 0);\r\nhlist_del_rcu(&flow->flow_table.node[ti->node_ver]);\r\ntable->count--;\r\nif (ovs_identifier_is_ufid(&flow->id)) {\r\nhlist_del_rcu(&flow->ufid_table.node[ufid_ti->node_ver]);\r\ntable->ufid_count--;\r\n}\r\nflow_mask_remove(table, flow->mask);\r\n}\r\nstatic struct sw_flow_mask *mask_alloc(void)\r\n{\r\nstruct sw_flow_mask *mask;\r\nmask = kmalloc(sizeof(*mask), GFP_KERNEL);\r\nif (mask)\r\nmask->ref_count = 1;\r\nreturn mask;\r\n}\r\nstatic bool mask_equal(const struct sw_flow_mask *a,\r\nconst struct sw_flow_mask *b)\r\n{\r\nconst u8 *a_ = (const u8 *)&a->key + a->range.start;\r\nconst u8 *b_ = (const u8 *)&b->key + b->range.start;\r\nreturn (a->range.end == b->range.end)\r\n&& (a->range.start == b->range.start)\r\n&& (memcmp(a_, b_, range_n_bytes(&a->range)) == 0);\r\n}\r\nstatic struct sw_flow_mask *flow_mask_find(const struct flow_table *tbl,\r\nconst struct sw_flow_mask *mask)\r\n{\r\nstruct list_head *ml;\r\nlist_for_each(ml, &tbl->mask_list) {\r\nstruct sw_flow_mask *m;\r\nm = container_of(ml, struct sw_flow_mask, list);\r\nif (mask_equal(mask, m))\r\nreturn m;\r\n}\r\nreturn NULL;\r\n}\r\nstatic int flow_mask_insert(struct flow_table *tbl, struct sw_flow *flow,\r\nconst struct sw_flow_mask *new)\r\n{\r\nstruct sw_flow_mask *mask;\r\nmask = flow_mask_find(tbl, new);\r\nif (!mask) {\r\nmask = mask_alloc();\r\nif (!mask)\r\nreturn -ENOMEM;\r\nmask->key = new->key;\r\nmask->range = new->range;\r\nlist_add_rcu(&mask->list, &tbl->mask_list);\r\n} else {\r\nBUG_ON(!mask->ref_count);\r\nmask->ref_count++;\r\n}\r\nflow->mask = mask;\r\nreturn 0;\r\n}\r\nstatic void flow_key_insert(struct flow_table *table, struct sw_flow *flow)\r\n{\r\nstruct table_instance *new_ti = NULL;\r\nstruct table_instance *ti;\r\nflow->flow_table.hash = flow_hash(&flow->key, &flow->mask->range);\r\nti = ovsl_dereference(table->ti);\r\ntable_instance_insert(ti, flow);\r\ntable->count++;\r\nif (table->count > ti->n_buckets)\r\nnew_ti = table_instance_expand(ti, false);\r\nelse if (time_after(jiffies, table->last_rehash + REHASH_INTERVAL))\r\nnew_ti = table_instance_rehash(ti, ti->n_buckets, false);\r\nif (new_ti) {\r\nrcu_assign_pointer(table->ti, new_ti);\r\ncall_rcu(&ti->rcu, flow_tbl_destroy_rcu_cb);\r\ntable->last_rehash = jiffies;\r\n}\r\n}\r\nstatic void flow_ufid_insert(struct flow_table *table, struct sw_flow *flow)\r\n{\r\nstruct table_instance *ti;\r\nflow->ufid_table.hash = ufid_hash(&flow->id);\r\nti = ovsl_dereference(table->ufid_ti);\r\nufid_table_instance_insert(ti, flow);\r\ntable->ufid_count++;\r\nif (table->ufid_count > ti->n_buckets) {\r\nstruct table_instance *new_ti;\r\nnew_ti = table_instance_expand(ti, true);\r\nif (new_ti) {\r\nrcu_assign_pointer(table->ufid_ti, new_ti);\r\ncall_rcu(&ti->rcu, flow_tbl_destroy_rcu_cb);\r\n}\r\n}\r\n}\r\nint ovs_flow_tbl_insert(struct flow_table *table, struct sw_flow *flow,\r\nconst struct sw_flow_mask *mask)\r\n{\r\nint err;\r\nerr = flow_mask_insert(table, flow, mask);\r\nif (err)\r\nreturn err;\r\nflow_key_insert(table, flow);\r\nif (ovs_identifier_is_ufid(&flow->id))\r\nflow_ufid_insert(table, flow);\r\nreturn 0;\r\n}\r\nint ovs_flow_init(void)\r\n{\r\nBUILD_BUG_ON(__alignof__(struct sw_flow_key) % __alignof__(long));\r\nBUILD_BUG_ON(sizeof(struct sw_flow_key) % sizeof(long));\r\nflow_cache = kmem_cache_create("sw_flow", sizeof(struct sw_flow)\r\n+ (nr_node_ids\r\n* sizeof(struct flow_stats *)),\r\n0, 0, NULL);\r\nif (flow_cache == NULL)\r\nreturn -ENOMEM;\r\nflow_stats_cache\r\n= kmem_cache_create("sw_flow_stats", sizeof(struct flow_stats),\r\n0, SLAB_HWCACHE_ALIGN, NULL);\r\nif (flow_stats_cache == NULL) {\r\nkmem_cache_destroy(flow_cache);\r\nflow_cache = NULL;\r\nreturn -ENOMEM;\r\n}\r\nreturn 0;\r\n}\r\nvoid ovs_flow_exit(void)\r\n{\r\nkmem_cache_destroy(flow_stats_cache);\r\nkmem_cache_destroy(flow_cache);\r\n}
