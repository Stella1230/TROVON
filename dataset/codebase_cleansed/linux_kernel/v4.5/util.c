char *xstrdup(const char *s)\r\n{\r\nint len = strlen(s) + 1;\r\nchar *d = xmalloc(len);\r\nmemcpy(d, s, len);\r\nreturn d;\r\n}\r\nchar *join_path(const char *path, const char *name)\r\n{\r\nint lenp = strlen(path);\r\nint lenn = strlen(name);\r\nint len;\r\nint needslash = 1;\r\nchar *str;\r\nlen = lenp + lenn + 2;\r\nif ((lenp > 0) && (path[lenp-1] == '/')) {\r\nneedslash = 0;\r\nlen--;\r\n}\r\nstr = xmalloc(len);\r\nmemcpy(str, path, lenp);\r\nif (needslash) {\r\nstr[lenp] = '/';\r\nlenp++;\r\n}\r\nmemcpy(str+lenp, name, lenn+1);\r\nreturn str;\r\n}\r\nbool util_is_printable_string(const void *data, int len)\r\n{\r\nconst char *s = data;\r\nconst char *ss, *se;\r\nif (len == 0)\r\nreturn 0;\r\nif (s[len - 1] != '\0')\r\nreturn 0;\r\nse = s + len;\r\nwhile (s < se) {\r\nss = s;\r\nwhile (s < se && *s && isprint((unsigned char)*s))\r\ns++;\r\nif (*s != '\0' || s == ss)\r\nreturn 0;\r\ns++;\r\n}\r\nreturn 1;\r\n}\r\nstatic char get_oct_char(const char *s, int *i)\r\n{\r\nchar x[4];\r\nchar *endx;\r\nlong val;\r\nx[3] = '\0';\r\nstrncpy(x, s + *i, 3);\r\nval = strtol(x, &endx, 8);\r\nassert(endx > x);\r\n(*i) += endx - x;\r\nreturn val;\r\n}\r\nstatic char get_hex_char(const char *s, int *i)\r\n{\r\nchar x[3];\r\nchar *endx;\r\nlong val;\r\nx[2] = '\0';\r\nstrncpy(x, s + *i, 2);\r\nval = strtol(x, &endx, 16);\r\nif (!(endx > x))\r\ndie("\\x used with no following hex digits\n");\r\n(*i) += endx - x;\r\nreturn val;\r\n}\r\nchar get_escape_char(const char *s, int *i)\r\n{\r\nchar c = s[*i];\r\nint j = *i + 1;\r\nchar val;\r\nassert(c);\r\nswitch (c) {\r\ncase 'a':\r\nval = '\a';\r\nbreak;\r\ncase 'b':\r\nval = '\b';\r\nbreak;\r\ncase 't':\r\nval = '\t';\r\nbreak;\r\ncase 'n':\r\nval = '\n';\r\nbreak;\r\ncase 'v':\r\nval = '\v';\r\nbreak;\r\ncase 'f':\r\nval = '\f';\r\nbreak;\r\ncase 'r':\r\nval = '\r';\r\nbreak;\r\ncase '0':\r\ncase '1':\r\ncase '2':\r\ncase '3':\r\ncase '4':\r\ncase '5':\r\ncase '6':\r\ncase '7':\r\nj--;\r\nval = get_oct_char(s, &j);\r\nbreak;\r\ncase 'x':\r\nval = get_hex_char(s, &j);\r\nbreak;\r\ndefault:\r\nval = c;\r\n}\r\n(*i) = j;\r\nreturn val;\r\n}\r\nint utilfdt_read_err_len(const char *filename, char **buffp, off_t *len)\r\n{\r\nint fd = 0;\r\nchar *buf = NULL;\r\noff_t bufsize = 1024, offset = 0;\r\nint ret = 0;\r\n*buffp = NULL;\r\nif (strcmp(filename, "-") != 0) {\r\nfd = open(filename, O_RDONLY);\r\nif (fd < 0)\r\nreturn errno;\r\n}\r\nbuf = xmalloc(bufsize);\r\ndo {\r\nif (offset == bufsize) {\r\nbufsize *= 2;\r\nbuf = xrealloc(buf, bufsize);\r\n}\r\nret = read(fd, &buf[offset], bufsize - offset);\r\nif (ret < 0) {\r\nret = errno;\r\nbreak;\r\n}\r\noffset += ret;\r\n} while (ret != 0);\r\nclose(fd);\r\nif (ret)\r\nfree(buf);\r\nelse\r\n*buffp = buf;\r\n*len = bufsize;\r\nreturn ret;\r\n}\r\nint utilfdt_read_err(const char *filename, char **buffp)\r\n{\r\noff_t len;\r\nreturn utilfdt_read_err_len(filename, buffp, &len);\r\n}\r\nchar *utilfdt_read_len(const char *filename, off_t *len)\r\n{\r\nchar *buff;\r\nint ret = utilfdt_read_err_len(filename, &buff, len);\r\nif (ret) {\r\nfprintf(stderr, "Couldn't open blob from '%s': %s\n", filename,\r\nstrerror(ret));\r\nreturn NULL;\r\n}\r\nreturn buff;\r\n}\r\nchar *utilfdt_read(const char *filename)\r\n{\r\noff_t len;\r\nreturn utilfdt_read_len(filename, &len);\r\n}\r\nint utilfdt_write_err(const char *filename, const void *blob)\r\n{\r\nint fd = 1;\r\nint totalsize;\r\nint offset;\r\nint ret = 0;\r\nconst char *ptr = blob;\r\nif (strcmp(filename, "-") != 0) {\r\nfd = open(filename, O_WRONLY | O_CREAT | O_TRUNC, 0666);\r\nif (fd < 0)\r\nreturn errno;\r\n}\r\ntotalsize = fdt_totalsize(blob);\r\noffset = 0;\r\nwhile (offset < totalsize) {\r\nret = write(fd, ptr + offset, totalsize - offset);\r\nif (ret < 0) {\r\nret = -errno;\r\nbreak;\r\n}\r\noffset += ret;\r\n}\r\nif (fd != 1)\r\nclose(fd);\r\nreturn ret < 0 ? -ret : 0;\r\n}\r\nint utilfdt_write(const char *filename, const void *blob)\r\n{\r\nint ret = utilfdt_write_err(filename, blob);\r\nif (ret) {\r\nfprintf(stderr, "Couldn't write blob to '%s': %s\n", filename,\r\nstrerror(ret));\r\n}\r\nreturn ret ? -1 : 0;\r\n}\r\nint utilfdt_decode_type(const char *fmt, int *type, int *size)\r\n{\r\nint qualifier = 0;\r\nif (!*fmt)\r\nreturn -1;\r\n*size = -1;\r\nif (strchr("hlLb", *fmt)) {\r\nqualifier = *fmt++;\r\nif (qualifier == *fmt) {\r\nswitch (*fmt++) {\r\ncase 'h':\r\nqualifier = 'b';\r\nbreak;\r\n}\r\n}\r\n}\r\nif ((*fmt == '\0') || !strchr("iuxs", *fmt))\r\nreturn -1;\r\nif (*fmt != 's')\r\n*size = qualifier == 'b' ? 1 :\r\nqualifier == 'h' ? 2 :\r\nqualifier == 'l' ? 4 : -1;\r\n*type = *fmt++;\r\nif (*fmt)\r\nreturn -1;\r\nreturn 0;\r\n}\r\nvoid utilfdt_print_data(const char *data, int len)\r\n{\r\nint i;\r\nconst char *p = data;\r\nconst char *s;\r\nif (len == 0)\r\nreturn;\r\nif (util_is_printable_string(data, len)) {\r\nprintf(" = ");\r\ns = data;\r\ndo {\r\nprintf("\"%s\"", s);\r\ns += strlen(s) + 1;\r\nif (s < data + len)\r\nprintf(", ");\r\n} while (s < data + len);\r\n} else if ((len % 4) == 0) {\r\nconst uint32_t *cell = (const uint32_t *)data;\r\nprintf(" = <");\r\nfor (i = 0, len /= 4; i < len; i++)\r\nprintf("0x%08x%s", fdt32_to_cpu(cell[i]),\r\ni < (len - 1) ? " " : "");\r\nprintf(">");\r\n} else {\r\nprintf(" = [");\r\nfor (i = 0; i < len; i++)\r\nprintf("%02x%s", *p++, i < len - 1 ? " " : "");\r\nprintf("]");\r\n}\r\n}\r\nvoid util_version(void)\r\n{\r\nprintf("Version: %s\n", DTC_VERSION);\r\nexit(0);\r\n}\r\nvoid util_usage(const char *errmsg, const char *synopsis,\r\nconst char *short_opts, struct option const long_opts[],\r\nconst char * const opts_help[])\r\n{\r\nFILE *fp = errmsg ? stderr : stdout;\r\nconst char a_arg[] = "<arg>";\r\nsize_t a_arg_len = strlen(a_arg) + 1;\r\nsize_t i;\r\nint optlen;\r\nfprintf(fp,\r\n"Usage: %s\n"\r\n"\n"\r\n"Options: -[%s]\n", synopsis, short_opts);\r\noptlen = 0;\r\nfor (i = 0; long_opts[i].name; ++i) {\r\nint l = strlen(long_opts[i].name) + 1;\r\nif (long_opts[i].has_arg == a_argument)\r\nl += a_arg_len;\r\nif (optlen < l)\r\noptlen = l;\r\n}\r\nfor (i = 0; long_opts[i].name; ++i) {\r\nassert(opts_help[i] != NULL);\r\nif (long_opts[i].val > '~')\r\nfprintf(fp, " ");\r\nelse\r\nfprintf(fp, " -%c, ", long_opts[i].val);\r\nif (long_opts[i].has_arg == no_argument)\r\nfprintf(fp, "--%-*s", optlen, long_opts[i].name);\r\nelse\r\nfprintf(fp, "--%s %s%*s", long_opts[i].name, a_arg,\r\n(int)(optlen - strlen(long_opts[i].name) - a_arg_len), "");\r\nfprintf(fp, "%s\n", opts_help[i]);\r\n}\r\nif (errmsg) {\r\nfprintf(fp, "\nError: %s\n", errmsg);\r\nexit(EXIT_FAILURE);\r\n} else\r\nexit(EXIT_SUCCESS);\r\n}
