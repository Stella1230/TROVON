static inline struct cnic_ulp_ops *cnic_ulp_tbl_prot(int type)\r\n{\r\nreturn rcu_dereference_protected(cnic_ulp_tbl[type],\r\nlockdep_is_held(&cnic_lock));\r\n}\r\nstatic int cnic_uio_open(struct uio_info *uinfo, struct inode *inode)\r\n{\r\nstruct cnic_uio_dev *udev = uinfo->priv;\r\nstruct cnic_dev *dev;\r\nif (!capable(CAP_NET_ADMIN))\r\nreturn -EPERM;\r\nif (udev->uio_dev != -1)\r\nreturn -EBUSY;\r\nrtnl_lock();\r\ndev = udev->dev;\r\nif (!dev || !test_bit(CNIC_F_CNIC_UP, &dev->flags)) {\r\nrtnl_unlock();\r\nreturn -ENODEV;\r\n}\r\nudev->uio_dev = iminor(inode);\r\ncnic_shutdown_rings(dev);\r\ncnic_init_rings(dev);\r\nrtnl_unlock();\r\nreturn 0;\r\n}\r\nstatic int cnic_uio_close(struct uio_info *uinfo, struct inode *inode)\r\n{\r\nstruct cnic_uio_dev *udev = uinfo->priv;\r\nudev->uio_dev = -1;\r\nreturn 0;\r\n}\r\nstatic inline void cnic_hold(struct cnic_dev *dev)\r\n{\r\natomic_inc(&dev->ref_count);\r\n}\r\nstatic inline void cnic_put(struct cnic_dev *dev)\r\n{\r\natomic_dec(&dev->ref_count);\r\n}\r\nstatic inline void csk_hold(struct cnic_sock *csk)\r\n{\r\natomic_inc(&csk->ref_count);\r\n}\r\nstatic inline void csk_put(struct cnic_sock *csk)\r\n{\r\natomic_dec(&csk->ref_count);\r\n}\r\nstatic struct cnic_dev *cnic_from_netdev(struct net_device *netdev)\r\n{\r\nstruct cnic_dev *cdev;\r\nread_lock(&cnic_dev_lock);\r\nlist_for_each_entry(cdev, &cnic_dev_list, list) {\r\nif (netdev == cdev->netdev) {\r\ncnic_hold(cdev);\r\nread_unlock(&cnic_dev_lock);\r\nreturn cdev;\r\n}\r\n}\r\nread_unlock(&cnic_dev_lock);\r\nreturn NULL;\r\n}\r\nstatic inline void ulp_get(struct cnic_ulp_ops *ulp_ops)\r\n{\r\natomic_inc(&ulp_ops->ref_count);\r\n}\r\nstatic inline void ulp_put(struct cnic_ulp_ops *ulp_ops)\r\n{\r\natomic_dec(&ulp_ops->ref_count);\r\n}\r\nstatic void cnic_ctx_wr(struct cnic_dev *dev, u32 cid_addr, u32 off, u32 val)\r\n{\r\nstruct cnic_local *cp = dev->cnic_priv;\r\nstruct cnic_eth_dev *ethdev = cp->ethdev;\r\nstruct drv_ctl_info info;\r\nstruct drv_ctl_io *io = &info.data.io;\r\nmemset(&info, 0, sizeof(struct drv_ctl_info));\r\ninfo.cmd = DRV_CTL_CTX_WR_CMD;\r\nio->cid_addr = cid_addr;\r\nio->offset = off;\r\nio->data = val;\r\nethdev->drv_ctl(dev->netdev, &info);\r\n}\r\nstatic void cnic_ctx_tbl_wr(struct cnic_dev *dev, u32 off, dma_addr_t addr)\r\n{\r\nstruct cnic_local *cp = dev->cnic_priv;\r\nstruct cnic_eth_dev *ethdev = cp->ethdev;\r\nstruct drv_ctl_info info;\r\nstruct drv_ctl_io *io = &info.data.io;\r\nmemset(&info, 0, sizeof(struct drv_ctl_info));\r\ninfo.cmd = DRV_CTL_CTXTBL_WR_CMD;\r\nio->offset = off;\r\nio->dma_addr = addr;\r\nethdev->drv_ctl(dev->netdev, &info);\r\n}\r\nstatic void cnic_ring_ctl(struct cnic_dev *dev, u32 cid, u32 cl_id, int start)\r\n{\r\nstruct cnic_local *cp = dev->cnic_priv;\r\nstruct cnic_eth_dev *ethdev = cp->ethdev;\r\nstruct drv_ctl_info info;\r\nstruct drv_ctl_l2_ring *ring = &info.data.ring;\r\nmemset(&info, 0, sizeof(struct drv_ctl_info));\r\nif (start)\r\ninfo.cmd = DRV_CTL_START_L2_CMD;\r\nelse\r\ninfo.cmd = DRV_CTL_STOP_L2_CMD;\r\nring->cid = cid;\r\nring->client_id = cl_id;\r\nethdev->drv_ctl(dev->netdev, &info);\r\n}\r\nstatic void cnic_reg_wr_ind(struct cnic_dev *dev, u32 off, u32 val)\r\n{\r\nstruct cnic_local *cp = dev->cnic_priv;\r\nstruct cnic_eth_dev *ethdev = cp->ethdev;\r\nstruct drv_ctl_info info;\r\nstruct drv_ctl_io *io = &info.data.io;\r\nmemset(&info, 0, sizeof(struct drv_ctl_info));\r\ninfo.cmd = DRV_CTL_IO_WR_CMD;\r\nio->offset = off;\r\nio->data = val;\r\nethdev->drv_ctl(dev->netdev, &info);\r\n}\r\nstatic u32 cnic_reg_rd_ind(struct cnic_dev *dev, u32 off)\r\n{\r\nstruct cnic_local *cp = dev->cnic_priv;\r\nstruct cnic_eth_dev *ethdev = cp->ethdev;\r\nstruct drv_ctl_info info;\r\nstruct drv_ctl_io *io = &info.data.io;\r\nmemset(&info, 0, sizeof(struct drv_ctl_info));\r\ninfo.cmd = DRV_CTL_IO_RD_CMD;\r\nio->offset = off;\r\nethdev->drv_ctl(dev->netdev, &info);\r\nreturn io->data;\r\n}\r\nstatic void cnic_ulp_ctl(struct cnic_dev *dev, int ulp_type, bool reg, int state)\r\n{\r\nstruct cnic_local *cp = dev->cnic_priv;\r\nstruct cnic_eth_dev *ethdev = cp->ethdev;\r\nstruct drv_ctl_info info;\r\nstruct fcoe_capabilities *fcoe_cap =\r\n&info.data.register_data.fcoe_features;\r\nmemset(&info, 0, sizeof(struct drv_ctl_info));\r\nif (reg) {\r\ninfo.cmd = DRV_CTL_ULP_REGISTER_CMD;\r\nif (ulp_type == CNIC_ULP_FCOE && dev->fcoe_cap)\r\nmemcpy(fcoe_cap, dev->fcoe_cap, sizeof(*fcoe_cap));\r\n} else {\r\ninfo.cmd = DRV_CTL_ULP_UNREGISTER_CMD;\r\n}\r\ninfo.data.ulp_type = ulp_type;\r\ninfo.drv_state = state;\r\nethdev->drv_ctl(dev->netdev, &info);\r\n}\r\nstatic int cnic_in_use(struct cnic_sock *csk)\r\n{\r\nreturn test_bit(SK_F_INUSE, &csk->flags);\r\n}\r\nstatic void cnic_spq_completion(struct cnic_dev *dev, int cmd, u32 count)\r\n{\r\nstruct cnic_local *cp = dev->cnic_priv;\r\nstruct cnic_eth_dev *ethdev = cp->ethdev;\r\nstruct drv_ctl_info info;\r\nmemset(&info, 0, sizeof(struct drv_ctl_info));\r\ninfo.cmd = cmd;\r\ninfo.data.credit.credit_count = count;\r\nethdev->drv_ctl(dev->netdev, &info);\r\n}\r\nstatic int cnic_get_l5_cid(struct cnic_local *cp, u32 cid, u32 *l5_cid)\r\n{\r\nu32 i;\r\nif (!cp->ctx_tbl)\r\nreturn -EINVAL;\r\nfor (i = 0; i < cp->max_cid_space; i++) {\r\nif (cp->ctx_tbl[i].cid == cid) {\r\n*l5_cid = i;\r\nreturn 0;\r\n}\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int cnic_send_nlmsg(struct cnic_local *cp, u32 type,\r\nstruct cnic_sock *csk)\r\n{\r\nstruct iscsi_path path_req;\r\nchar *buf = NULL;\r\nu16 len = 0;\r\nu32 msg_type = ISCSI_KEVENT_IF_DOWN;\r\nstruct cnic_ulp_ops *ulp_ops;\r\nstruct cnic_uio_dev *udev = cp->udev;\r\nint rc = 0, retry = 0;\r\nif (!udev || udev->uio_dev == -1)\r\nreturn -ENODEV;\r\nif (csk) {\r\nlen = sizeof(path_req);\r\nbuf = (char *) &path_req;\r\nmemset(&path_req, 0, len);\r\nmsg_type = ISCSI_KEVENT_PATH_REQ;\r\npath_req.handle = (u64) csk->l5_cid;\r\nif (test_bit(SK_F_IPV6, &csk->flags)) {\r\nmemcpy(&path_req.dst.v6_addr, &csk->dst_ip[0],\r\nsizeof(struct in6_addr));\r\npath_req.ip_addr_len = 16;\r\n} else {\r\nmemcpy(&path_req.dst.v4_addr, &csk->dst_ip[0],\r\nsizeof(struct in_addr));\r\npath_req.ip_addr_len = 4;\r\n}\r\npath_req.vlan_id = csk->vlan_id;\r\npath_req.pmtu = csk->mtu;\r\n}\r\nwhile (retry < 3) {\r\nrc = 0;\r\nrcu_read_lock();\r\nulp_ops = rcu_dereference(cp->ulp_ops[CNIC_ULP_ISCSI]);\r\nif (ulp_ops)\r\nrc = ulp_ops->iscsi_nl_send_msg(\r\ncp->ulp_handle[CNIC_ULP_ISCSI],\r\nmsg_type, buf, len);\r\nrcu_read_unlock();\r\nif (rc == 0 || msg_type != ISCSI_KEVENT_PATH_REQ)\r\nbreak;\r\nmsleep(100);\r\nretry++;\r\n}\r\nreturn rc;\r\n}\r\nstatic int cnic_iscsi_nl_msg_recv(struct cnic_dev *dev, u32 msg_type,\r\nchar *buf, u16 len)\r\n{\r\nint rc = -EINVAL;\r\nswitch (msg_type) {\r\ncase ISCSI_UEVENT_PATH_UPDATE: {\r\nstruct cnic_local *cp;\r\nu32 l5_cid;\r\nstruct cnic_sock *csk;\r\nstruct iscsi_path *path_resp;\r\nif (len < sizeof(*path_resp))\r\nbreak;\r\npath_resp = (struct iscsi_path *) buf;\r\ncp = dev->cnic_priv;\r\nl5_cid = (u32) path_resp->handle;\r\nif (l5_cid >= MAX_CM_SK_TBL_SZ)\r\nbreak;\r\nif (!rcu_access_pointer(cp->ulp_ops[CNIC_ULP_L4])) {\r\nrc = -ENODEV;\r\nbreak;\r\n}\r\ncsk = &cp->csk_tbl[l5_cid];\r\ncsk_hold(csk);\r\nif (cnic_in_use(csk) &&\r\ntest_bit(SK_F_CONNECT_START, &csk->flags)) {\r\ncsk->vlan_id = path_resp->vlan_id;\r\nmemcpy(csk->ha, path_resp->mac_addr, ETH_ALEN);\r\nif (test_bit(SK_F_IPV6, &csk->flags))\r\nmemcpy(&csk->src_ip[0], &path_resp->src.v6_addr,\r\nsizeof(struct in6_addr));\r\nelse\r\nmemcpy(&csk->src_ip[0], &path_resp->src.v4_addr,\r\nsizeof(struct in_addr));\r\nif (is_valid_ether_addr(csk->ha)) {\r\ncnic_cm_set_pg(csk);\r\n} else if (!test_bit(SK_F_OFFLD_SCHED, &csk->flags) &&\r\n!test_bit(SK_F_OFFLD_COMPLETE, &csk->flags)) {\r\ncnic_cm_upcall(cp, csk,\r\nL4_KCQE_OPCODE_VALUE_CONNECT_COMPLETE);\r\nclear_bit(SK_F_CONNECT_START, &csk->flags);\r\n}\r\n}\r\ncsk_put(csk);\r\nrc = 0;\r\n}\r\n}\r\nreturn rc;\r\n}\r\nstatic int cnic_offld_prep(struct cnic_sock *csk)\r\n{\r\nif (test_and_set_bit(SK_F_OFFLD_SCHED, &csk->flags))\r\nreturn 0;\r\nif (!test_bit(SK_F_CONNECT_START, &csk->flags)) {\r\nclear_bit(SK_F_OFFLD_SCHED, &csk->flags);\r\nreturn 0;\r\n}\r\nreturn 1;\r\n}\r\nstatic int cnic_close_prep(struct cnic_sock *csk)\r\n{\r\nclear_bit(SK_F_CONNECT_START, &csk->flags);\r\nsmp_mb__after_atomic();\r\nif (test_and_clear_bit(SK_F_OFFLD_COMPLETE, &csk->flags)) {\r\nwhile (test_and_set_bit(SK_F_OFFLD_SCHED, &csk->flags))\r\nmsleep(1);\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}\r\nstatic int cnic_abort_prep(struct cnic_sock *csk)\r\n{\r\nclear_bit(SK_F_CONNECT_START, &csk->flags);\r\nsmp_mb__after_atomic();\r\nwhile (test_and_set_bit(SK_F_OFFLD_SCHED, &csk->flags))\r\nmsleep(1);\r\nif (test_and_clear_bit(SK_F_OFFLD_COMPLETE, &csk->flags)) {\r\ncsk->state = L4_KCQE_OPCODE_VALUE_RESET_COMP;\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}\r\nint cnic_register_driver(int ulp_type, struct cnic_ulp_ops *ulp_ops)\r\n{\r\nstruct cnic_dev *dev;\r\nif (ulp_type < 0 || ulp_type >= MAX_CNIC_ULP_TYPE) {\r\npr_err("%s: Bad type %d\n", __func__, ulp_type);\r\nreturn -EINVAL;\r\n}\r\nmutex_lock(&cnic_lock);\r\nif (cnic_ulp_tbl_prot(ulp_type)) {\r\npr_err("%s: Type %d has already been registered\n",\r\n__func__, ulp_type);\r\nmutex_unlock(&cnic_lock);\r\nreturn -EBUSY;\r\n}\r\nread_lock(&cnic_dev_lock);\r\nlist_for_each_entry(dev, &cnic_dev_list, list) {\r\nstruct cnic_local *cp = dev->cnic_priv;\r\nclear_bit(ULP_F_INIT, &cp->ulp_flags[ulp_type]);\r\n}\r\nread_unlock(&cnic_dev_lock);\r\natomic_set(&ulp_ops->ref_count, 0);\r\nrcu_assign_pointer(cnic_ulp_tbl[ulp_type], ulp_ops);\r\nmutex_unlock(&cnic_lock);\r\nrtnl_lock();\r\nlist_for_each_entry(dev, &cnic_dev_list, list) {\r\nstruct cnic_local *cp = dev->cnic_priv;\r\nif (!test_and_set_bit(ULP_F_INIT, &cp->ulp_flags[ulp_type]))\r\nulp_ops->cnic_init(dev);\r\n}\r\nrtnl_unlock();\r\nreturn 0;\r\n}\r\nint cnic_unregister_driver(int ulp_type)\r\n{\r\nstruct cnic_dev *dev;\r\nstruct cnic_ulp_ops *ulp_ops;\r\nint i = 0;\r\nif (ulp_type < 0 || ulp_type >= MAX_CNIC_ULP_TYPE) {\r\npr_err("%s: Bad type %d\n", __func__, ulp_type);\r\nreturn -EINVAL;\r\n}\r\nmutex_lock(&cnic_lock);\r\nulp_ops = cnic_ulp_tbl_prot(ulp_type);\r\nif (!ulp_ops) {\r\npr_err("%s: Type %d has not been registered\n",\r\n__func__, ulp_type);\r\ngoto out_unlock;\r\n}\r\nread_lock(&cnic_dev_lock);\r\nlist_for_each_entry(dev, &cnic_dev_list, list) {\r\nstruct cnic_local *cp = dev->cnic_priv;\r\nif (rcu_access_pointer(cp->ulp_ops[ulp_type])) {\r\npr_err("%s: Type %d still has devices registered\n",\r\n__func__, ulp_type);\r\nread_unlock(&cnic_dev_lock);\r\ngoto out_unlock;\r\n}\r\n}\r\nread_unlock(&cnic_dev_lock);\r\nRCU_INIT_POINTER(cnic_ulp_tbl[ulp_type], NULL);\r\nmutex_unlock(&cnic_lock);\r\nsynchronize_rcu();\r\nwhile ((atomic_read(&ulp_ops->ref_count) != 0) && (i < 20)) {\r\nmsleep(100);\r\ni++;\r\n}\r\nif (atomic_read(&ulp_ops->ref_count) != 0)\r\npr_warn("%s: Failed waiting for ref count to go to zero\n",\r\n__func__);\r\nreturn 0;\r\nout_unlock:\r\nmutex_unlock(&cnic_lock);\r\nreturn -EINVAL;\r\n}\r\nstatic int cnic_register_device(struct cnic_dev *dev, int ulp_type,\r\nvoid *ulp_ctx)\r\n{\r\nstruct cnic_local *cp = dev->cnic_priv;\r\nstruct cnic_ulp_ops *ulp_ops;\r\nif (ulp_type < 0 || ulp_type >= MAX_CNIC_ULP_TYPE) {\r\npr_err("%s: Bad type %d\n", __func__, ulp_type);\r\nreturn -EINVAL;\r\n}\r\nmutex_lock(&cnic_lock);\r\nif (cnic_ulp_tbl_prot(ulp_type) == NULL) {\r\npr_err("%s: Driver with type %d has not been registered\n",\r\n__func__, ulp_type);\r\nmutex_unlock(&cnic_lock);\r\nreturn -EAGAIN;\r\n}\r\nif (rcu_access_pointer(cp->ulp_ops[ulp_type])) {\r\npr_err("%s: Type %d has already been registered to this device\n",\r\n__func__, ulp_type);\r\nmutex_unlock(&cnic_lock);\r\nreturn -EBUSY;\r\n}\r\nclear_bit(ULP_F_START, &cp->ulp_flags[ulp_type]);\r\ncp->ulp_handle[ulp_type] = ulp_ctx;\r\nulp_ops = cnic_ulp_tbl_prot(ulp_type);\r\nrcu_assign_pointer(cp->ulp_ops[ulp_type], ulp_ops);\r\ncnic_hold(dev);\r\nif (test_bit(CNIC_F_CNIC_UP, &dev->flags))\r\nif (!test_and_set_bit(ULP_F_START, &cp->ulp_flags[ulp_type]))\r\nulp_ops->cnic_start(cp->ulp_handle[ulp_type]);\r\nmutex_unlock(&cnic_lock);\r\ncnic_ulp_ctl(dev, ulp_type, true, DRV_ACTIVE);\r\nreturn 0;\r\n}\r\nstatic int cnic_unregister_device(struct cnic_dev *dev, int ulp_type)\r\n{\r\nstruct cnic_local *cp = dev->cnic_priv;\r\nint i = 0;\r\nif (ulp_type < 0 || ulp_type >= MAX_CNIC_ULP_TYPE) {\r\npr_err("%s: Bad type %d\n", __func__, ulp_type);\r\nreturn -EINVAL;\r\n}\r\nif (ulp_type == CNIC_ULP_ISCSI)\r\ncnic_send_nlmsg(cp, ISCSI_KEVENT_IF_DOWN, NULL);\r\nmutex_lock(&cnic_lock);\r\nif (rcu_access_pointer(cp->ulp_ops[ulp_type])) {\r\nRCU_INIT_POINTER(cp->ulp_ops[ulp_type], NULL);\r\ncnic_put(dev);\r\n} else {\r\npr_err("%s: device not registered to this ulp type %d\n",\r\n__func__, ulp_type);\r\nmutex_unlock(&cnic_lock);\r\nreturn -EINVAL;\r\n}\r\nmutex_unlock(&cnic_lock);\r\nif (ulp_type == CNIC_ULP_FCOE)\r\ndev->fcoe_cap = NULL;\r\nsynchronize_rcu();\r\nwhile (test_bit(ULP_F_CALL_PENDING, &cp->ulp_flags[ulp_type]) &&\r\ni < 20) {\r\nmsleep(100);\r\ni++;\r\n}\r\nif (test_bit(ULP_F_CALL_PENDING, &cp->ulp_flags[ulp_type]))\r\nnetdev_warn(dev->netdev, "Failed waiting for ULP up call to complete\n");\r\nif (test_bit(ULP_F_INIT, &cp->ulp_flags[ulp_type]))\r\ncnic_ulp_ctl(dev, ulp_type, false, DRV_UNLOADED);\r\nelse\r\ncnic_ulp_ctl(dev, ulp_type, false, DRV_INACTIVE);\r\nreturn 0;\r\n}\r\nstatic int cnic_init_id_tbl(struct cnic_id_tbl *id_tbl, u32 size, u32 start_id,\r\nu32 next)\r\n{\r\nid_tbl->start = start_id;\r\nid_tbl->max = size;\r\nid_tbl->next = next;\r\nspin_lock_init(&id_tbl->lock);\r\nid_tbl->table = kzalloc(DIV_ROUND_UP(size, 32) * 4, GFP_KERNEL);\r\nif (!id_tbl->table)\r\nreturn -ENOMEM;\r\nreturn 0;\r\n}\r\nstatic void cnic_free_id_tbl(struct cnic_id_tbl *id_tbl)\r\n{\r\nkfree(id_tbl->table);\r\nid_tbl->table = NULL;\r\n}\r\nstatic int cnic_alloc_id(struct cnic_id_tbl *id_tbl, u32 id)\r\n{\r\nint ret = -1;\r\nid -= id_tbl->start;\r\nif (id >= id_tbl->max)\r\nreturn ret;\r\nspin_lock(&id_tbl->lock);\r\nif (!test_bit(id, id_tbl->table)) {\r\nset_bit(id, id_tbl->table);\r\nret = 0;\r\n}\r\nspin_unlock(&id_tbl->lock);\r\nreturn ret;\r\n}\r\nstatic u32 cnic_alloc_new_id(struct cnic_id_tbl *id_tbl)\r\n{\r\nu32 id;\r\nspin_lock(&id_tbl->lock);\r\nid = find_next_zero_bit(id_tbl->table, id_tbl->max, id_tbl->next);\r\nif (id >= id_tbl->max) {\r\nid = -1;\r\nif (id_tbl->next != 0) {\r\nid = find_first_zero_bit(id_tbl->table, id_tbl->next);\r\nif (id >= id_tbl->next)\r\nid = -1;\r\n}\r\n}\r\nif (id < id_tbl->max) {\r\nset_bit(id, id_tbl->table);\r\nid_tbl->next = (id + 1) & (id_tbl->max - 1);\r\nid += id_tbl->start;\r\n}\r\nspin_unlock(&id_tbl->lock);\r\nreturn id;\r\n}\r\nstatic void cnic_free_id(struct cnic_id_tbl *id_tbl, u32 id)\r\n{\r\nif (id == -1)\r\nreturn;\r\nid -= id_tbl->start;\r\nif (id >= id_tbl->max)\r\nreturn;\r\nclear_bit(id, id_tbl->table);\r\n}\r\nstatic void cnic_free_dma(struct cnic_dev *dev, struct cnic_dma *dma)\r\n{\r\nint i;\r\nif (!dma->pg_arr)\r\nreturn;\r\nfor (i = 0; i < dma->num_pages; i++) {\r\nif (dma->pg_arr[i]) {\r\ndma_free_coherent(&dev->pcidev->dev, CNIC_PAGE_SIZE,\r\ndma->pg_arr[i], dma->pg_map_arr[i]);\r\ndma->pg_arr[i] = NULL;\r\n}\r\n}\r\nif (dma->pgtbl) {\r\ndma_free_coherent(&dev->pcidev->dev, dma->pgtbl_size,\r\ndma->pgtbl, dma->pgtbl_map);\r\ndma->pgtbl = NULL;\r\n}\r\nkfree(dma->pg_arr);\r\ndma->pg_arr = NULL;\r\ndma->num_pages = 0;\r\n}\r\nstatic void cnic_setup_page_tbl(struct cnic_dev *dev, struct cnic_dma *dma)\r\n{\r\nint i;\r\n__le32 *page_table = (__le32 *) dma->pgtbl;\r\nfor (i = 0; i < dma->num_pages; i++) {\r\n*page_table = cpu_to_le32((u64) dma->pg_map_arr[i] >> 32);\r\npage_table++;\r\n*page_table = cpu_to_le32(dma->pg_map_arr[i] & 0xffffffff);\r\npage_table++;\r\n}\r\n}\r\nstatic void cnic_setup_page_tbl_le(struct cnic_dev *dev, struct cnic_dma *dma)\r\n{\r\nint i;\r\n__le32 *page_table = (__le32 *) dma->pgtbl;\r\nfor (i = 0; i < dma->num_pages; i++) {\r\n*page_table = cpu_to_le32(dma->pg_map_arr[i] & 0xffffffff);\r\npage_table++;\r\n*page_table = cpu_to_le32((u64) dma->pg_map_arr[i] >> 32);\r\npage_table++;\r\n}\r\n}\r\nstatic int cnic_alloc_dma(struct cnic_dev *dev, struct cnic_dma *dma,\r\nint pages, int use_pg_tbl)\r\n{\r\nint i, size;\r\nstruct cnic_local *cp = dev->cnic_priv;\r\nsize = pages * (sizeof(void *) + sizeof(dma_addr_t));\r\ndma->pg_arr = kzalloc(size, GFP_ATOMIC);\r\nif (dma->pg_arr == NULL)\r\nreturn -ENOMEM;\r\ndma->pg_map_arr = (dma_addr_t *) (dma->pg_arr + pages);\r\ndma->num_pages = pages;\r\nfor (i = 0; i < pages; i++) {\r\ndma->pg_arr[i] = dma_alloc_coherent(&dev->pcidev->dev,\r\nCNIC_PAGE_SIZE,\r\n&dma->pg_map_arr[i],\r\nGFP_ATOMIC);\r\nif (dma->pg_arr[i] == NULL)\r\ngoto error;\r\n}\r\nif (!use_pg_tbl)\r\nreturn 0;\r\ndma->pgtbl_size = ((pages * 8) + CNIC_PAGE_SIZE - 1) &\r\n~(CNIC_PAGE_SIZE - 1);\r\ndma->pgtbl = dma_alloc_coherent(&dev->pcidev->dev, dma->pgtbl_size,\r\n&dma->pgtbl_map, GFP_ATOMIC);\r\nif (dma->pgtbl == NULL)\r\ngoto error;\r\ncp->setup_pgtbl(dev, dma);\r\nreturn 0;\r\nerror:\r\ncnic_free_dma(dev, dma);\r\nreturn -ENOMEM;\r\n}\r\nstatic void cnic_free_context(struct cnic_dev *dev)\r\n{\r\nstruct cnic_local *cp = dev->cnic_priv;\r\nint i;\r\nfor (i = 0; i < cp->ctx_blks; i++) {\r\nif (cp->ctx_arr[i].ctx) {\r\ndma_free_coherent(&dev->pcidev->dev, cp->ctx_blk_size,\r\ncp->ctx_arr[i].ctx,\r\ncp->ctx_arr[i].mapping);\r\ncp->ctx_arr[i].ctx = NULL;\r\n}\r\n}\r\n}\r\nstatic void __cnic_free_uio_rings(struct cnic_uio_dev *udev)\r\n{\r\nif (udev->l2_buf) {\r\ndma_free_coherent(&udev->pdev->dev, udev->l2_buf_size,\r\nudev->l2_buf, udev->l2_buf_map);\r\nudev->l2_buf = NULL;\r\n}\r\nif (udev->l2_ring) {\r\ndma_free_coherent(&udev->pdev->dev, udev->l2_ring_size,\r\nudev->l2_ring, udev->l2_ring_map);\r\nudev->l2_ring = NULL;\r\n}\r\n}\r\nstatic void __cnic_free_uio(struct cnic_uio_dev *udev)\r\n{\r\nuio_unregister_device(&udev->cnic_uinfo);\r\n__cnic_free_uio_rings(udev);\r\npci_dev_put(udev->pdev);\r\nkfree(udev);\r\n}\r\nstatic void cnic_free_uio(struct cnic_uio_dev *udev)\r\n{\r\nif (!udev)\r\nreturn;\r\nwrite_lock(&cnic_dev_lock);\r\nlist_del_init(&udev->list);\r\nwrite_unlock(&cnic_dev_lock);\r\n__cnic_free_uio(udev);\r\n}\r\nstatic void cnic_free_resc(struct cnic_dev *dev)\r\n{\r\nstruct cnic_local *cp = dev->cnic_priv;\r\nstruct cnic_uio_dev *udev = cp->udev;\r\nif (udev) {\r\nudev->dev = NULL;\r\ncp->udev = NULL;\r\nif (udev->uio_dev == -1)\r\n__cnic_free_uio_rings(udev);\r\n}\r\ncnic_free_context(dev);\r\nkfree(cp->ctx_arr);\r\ncp->ctx_arr = NULL;\r\ncp->ctx_blks = 0;\r\ncnic_free_dma(dev, &cp->gbl_buf_info);\r\ncnic_free_dma(dev, &cp->kwq_info);\r\ncnic_free_dma(dev, &cp->kwq_16_data_info);\r\ncnic_free_dma(dev, &cp->kcq2.dma);\r\ncnic_free_dma(dev, &cp->kcq1.dma);\r\nkfree(cp->iscsi_tbl);\r\ncp->iscsi_tbl = NULL;\r\nkfree(cp->ctx_tbl);\r\ncp->ctx_tbl = NULL;\r\ncnic_free_id_tbl(&cp->fcoe_cid_tbl);\r\ncnic_free_id_tbl(&cp->cid_tbl);\r\n}\r\nstatic int cnic_alloc_context(struct cnic_dev *dev)\r\n{\r\nstruct cnic_local *cp = dev->cnic_priv;\r\nif (BNX2_CHIP(cp) == BNX2_CHIP_5709) {\r\nint i, k, arr_size;\r\ncp->ctx_blk_size = CNIC_PAGE_SIZE;\r\ncp->cids_per_blk = CNIC_PAGE_SIZE / 128;\r\narr_size = BNX2_MAX_CID / cp->cids_per_blk *\r\nsizeof(struct cnic_ctx);\r\ncp->ctx_arr = kzalloc(arr_size, GFP_KERNEL);\r\nif (cp->ctx_arr == NULL)\r\nreturn -ENOMEM;\r\nk = 0;\r\nfor (i = 0; i < 2; i++) {\r\nu32 j, reg, off, lo, hi;\r\nif (i == 0)\r\noff = BNX2_PG_CTX_MAP;\r\nelse\r\noff = BNX2_ISCSI_CTX_MAP;\r\nreg = cnic_reg_rd_ind(dev, off);\r\nlo = reg >> 16;\r\nhi = reg & 0xffff;\r\nfor (j = lo; j < hi; j += cp->cids_per_blk, k++)\r\ncp->ctx_arr[k].cid = j;\r\n}\r\ncp->ctx_blks = k;\r\nif (cp->ctx_blks >= (BNX2_MAX_CID / cp->cids_per_blk)) {\r\ncp->ctx_blks = 0;\r\nreturn -ENOMEM;\r\n}\r\nfor (i = 0; i < cp->ctx_blks; i++) {\r\ncp->ctx_arr[i].ctx =\r\ndma_alloc_coherent(&dev->pcidev->dev,\r\nCNIC_PAGE_SIZE,\r\n&cp->ctx_arr[i].mapping,\r\nGFP_KERNEL);\r\nif (cp->ctx_arr[i].ctx == NULL)\r\nreturn -ENOMEM;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic u16 cnic_bnx2_next_idx(u16 idx)\r\n{\r\nreturn idx + 1;\r\n}\r\nstatic u16 cnic_bnx2_hw_idx(u16 idx)\r\n{\r\nreturn idx;\r\n}\r\nstatic u16 cnic_bnx2x_next_idx(u16 idx)\r\n{\r\nidx++;\r\nif ((idx & MAX_KCQE_CNT) == MAX_KCQE_CNT)\r\nidx++;\r\nreturn idx;\r\n}\r\nstatic u16 cnic_bnx2x_hw_idx(u16 idx)\r\n{\r\nif ((idx & MAX_KCQE_CNT) == MAX_KCQE_CNT)\r\nidx++;\r\nreturn idx;\r\n}\r\nstatic int cnic_alloc_kcq(struct cnic_dev *dev, struct kcq_info *info,\r\nbool use_pg_tbl)\r\n{\r\nint err, i, use_page_tbl = 0;\r\nstruct kcqe **kcq;\r\nif (use_pg_tbl)\r\nuse_page_tbl = 1;\r\nerr = cnic_alloc_dma(dev, &info->dma, KCQ_PAGE_CNT, use_page_tbl);\r\nif (err)\r\nreturn err;\r\nkcq = (struct kcqe **) info->dma.pg_arr;\r\ninfo->kcq = kcq;\r\ninfo->next_idx = cnic_bnx2_next_idx;\r\ninfo->hw_idx = cnic_bnx2_hw_idx;\r\nif (use_pg_tbl)\r\nreturn 0;\r\ninfo->next_idx = cnic_bnx2x_next_idx;\r\ninfo->hw_idx = cnic_bnx2x_hw_idx;\r\nfor (i = 0; i < KCQ_PAGE_CNT; i++) {\r\nstruct bnx2x_bd_chain_next *next =\r\n(struct bnx2x_bd_chain_next *) &kcq[i][MAX_KCQE_CNT];\r\nint j = i + 1;\r\nif (j >= KCQ_PAGE_CNT)\r\nj = 0;\r\nnext->addr_hi = (u64) info->dma.pg_map_arr[j] >> 32;\r\nnext->addr_lo = info->dma.pg_map_arr[j] & 0xffffffff;\r\n}\r\nreturn 0;\r\n}\r\nstatic int __cnic_alloc_uio_rings(struct cnic_uio_dev *udev, int pages)\r\n{\r\nstruct cnic_local *cp = udev->dev->cnic_priv;\r\nif (udev->l2_ring)\r\nreturn 0;\r\nudev->l2_ring_size = pages * CNIC_PAGE_SIZE;\r\nudev->l2_ring = dma_alloc_coherent(&udev->pdev->dev, udev->l2_ring_size,\r\n&udev->l2_ring_map,\r\nGFP_KERNEL | __GFP_COMP);\r\nif (!udev->l2_ring)\r\nreturn -ENOMEM;\r\nudev->l2_buf_size = (cp->l2_rx_ring_size + 1) * cp->l2_single_buf_size;\r\nudev->l2_buf_size = CNIC_PAGE_ALIGN(udev->l2_buf_size);\r\nudev->l2_buf = dma_alloc_coherent(&udev->pdev->dev, udev->l2_buf_size,\r\n&udev->l2_buf_map,\r\nGFP_KERNEL | __GFP_COMP);\r\nif (!udev->l2_buf) {\r\n__cnic_free_uio_rings(udev);\r\nreturn -ENOMEM;\r\n}\r\nreturn 0;\r\n}\r\nstatic int cnic_alloc_uio_rings(struct cnic_dev *dev, int pages)\r\n{\r\nstruct cnic_local *cp = dev->cnic_priv;\r\nstruct cnic_uio_dev *udev;\r\nlist_for_each_entry(udev, &cnic_udev_list, list) {\r\nif (udev->pdev == dev->pcidev) {\r\nudev->dev = dev;\r\nif (__cnic_alloc_uio_rings(udev, pages)) {\r\nudev->dev = NULL;\r\nreturn -ENOMEM;\r\n}\r\ncp->udev = udev;\r\nreturn 0;\r\n}\r\n}\r\nudev = kzalloc(sizeof(struct cnic_uio_dev), GFP_ATOMIC);\r\nif (!udev)\r\nreturn -ENOMEM;\r\nudev->uio_dev = -1;\r\nudev->dev = dev;\r\nudev->pdev = dev->pcidev;\r\nif (__cnic_alloc_uio_rings(udev, pages))\r\ngoto err_udev;\r\nlist_add(&udev->list, &cnic_udev_list);\r\npci_dev_get(udev->pdev);\r\ncp->udev = udev;\r\nreturn 0;\r\nerr_udev:\r\nkfree(udev);\r\nreturn -ENOMEM;\r\n}\r\nstatic int cnic_init_uio(struct cnic_dev *dev)\r\n{\r\nstruct cnic_local *cp = dev->cnic_priv;\r\nstruct cnic_uio_dev *udev = cp->udev;\r\nstruct uio_info *uinfo;\r\nint ret = 0;\r\nif (!udev)\r\nreturn -ENOMEM;\r\nuinfo = &udev->cnic_uinfo;\r\nuinfo->mem[0].addr = pci_resource_start(dev->pcidev, 0);\r\nuinfo->mem[0].internal_addr = dev->regview;\r\nuinfo->mem[0].memtype = UIO_MEM_PHYS;\r\nif (test_bit(CNIC_F_BNX2_CLASS, &dev->flags)) {\r\nuinfo->mem[0].size = MB_GET_CID_ADDR(TX_TSS_CID +\r\nTX_MAX_TSS_RINGS + 1);\r\nuinfo->mem[1].addr = (unsigned long) cp->status_blk.gen &\r\nCNIC_PAGE_MASK;\r\nif (cp->ethdev->drv_state & CNIC_DRV_STATE_USING_MSIX)\r\nuinfo->mem[1].size = BNX2_SBLK_MSIX_ALIGN_SIZE * 9;\r\nelse\r\nuinfo->mem[1].size = BNX2_SBLK_MSIX_ALIGN_SIZE;\r\nuinfo->name = "bnx2_cnic";\r\n} else if (test_bit(CNIC_F_BNX2X_CLASS, &dev->flags)) {\r\nuinfo->mem[0].size = pci_resource_len(dev->pcidev, 0);\r\nuinfo->mem[1].addr = (unsigned long) cp->bnx2x_def_status_blk &\r\nCNIC_PAGE_MASK;\r\nuinfo->mem[1].size = sizeof(*cp->bnx2x_def_status_blk);\r\nuinfo->name = "bnx2x_cnic";\r\n}\r\nuinfo->mem[1].memtype = UIO_MEM_LOGICAL;\r\nuinfo->mem[2].addr = (unsigned long) udev->l2_ring;\r\nuinfo->mem[2].size = udev->l2_ring_size;\r\nuinfo->mem[2].memtype = UIO_MEM_LOGICAL;\r\nuinfo->mem[3].addr = (unsigned long) udev->l2_buf;\r\nuinfo->mem[3].size = udev->l2_buf_size;\r\nuinfo->mem[3].memtype = UIO_MEM_LOGICAL;\r\nuinfo->version = CNIC_MODULE_VERSION;\r\nuinfo->irq = UIO_IRQ_CUSTOM;\r\nuinfo->open = cnic_uio_open;\r\nuinfo->release = cnic_uio_close;\r\nif (udev->uio_dev == -1) {\r\nif (!uinfo->priv) {\r\nuinfo->priv = udev;\r\nret = uio_register_device(&udev->pdev->dev, uinfo);\r\n}\r\n} else {\r\ncnic_init_rings(dev);\r\n}\r\nreturn ret;\r\n}\r\nstatic int cnic_alloc_bnx2_resc(struct cnic_dev *dev)\r\n{\r\nstruct cnic_local *cp = dev->cnic_priv;\r\nint ret;\r\nret = cnic_alloc_dma(dev, &cp->kwq_info, KWQ_PAGE_CNT, 1);\r\nif (ret)\r\ngoto error;\r\ncp->kwq = (struct kwqe **) cp->kwq_info.pg_arr;\r\nret = cnic_alloc_kcq(dev, &cp->kcq1, true);\r\nif (ret)\r\ngoto error;\r\nret = cnic_alloc_context(dev);\r\nif (ret)\r\ngoto error;\r\nret = cnic_alloc_uio_rings(dev, 2);\r\nif (ret)\r\ngoto error;\r\nret = cnic_init_uio(dev);\r\nif (ret)\r\ngoto error;\r\nreturn 0;\r\nerror:\r\ncnic_free_resc(dev);\r\nreturn ret;\r\n}\r\nstatic int cnic_alloc_bnx2x_context(struct cnic_dev *dev)\r\n{\r\nstruct cnic_local *cp = dev->cnic_priv;\r\nstruct bnx2x *bp = netdev_priv(dev->netdev);\r\nint ctx_blk_size = cp->ethdev->ctx_blk_size;\r\nint total_mem, blks, i;\r\ntotal_mem = BNX2X_CONTEXT_MEM_SIZE * cp->max_cid_space;\r\nblks = total_mem / ctx_blk_size;\r\nif (total_mem % ctx_blk_size)\r\nblks++;\r\nif (blks > cp->ethdev->ctx_tbl_len)\r\nreturn -ENOMEM;\r\ncp->ctx_arr = kcalloc(blks, sizeof(struct cnic_ctx), GFP_KERNEL);\r\nif (cp->ctx_arr == NULL)\r\nreturn -ENOMEM;\r\ncp->ctx_blks = blks;\r\ncp->ctx_blk_size = ctx_blk_size;\r\nif (!CHIP_IS_E1(bp))\r\ncp->ctx_align = 0;\r\nelse\r\ncp->ctx_align = ctx_blk_size;\r\ncp->cids_per_blk = ctx_blk_size / BNX2X_CONTEXT_MEM_SIZE;\r\nfor (i = 0; i < blks; i++) {\r\ncp->ctx_arr[i].ctx =\r\ndma_alloc_coherent(&dev->pcidev->dev, cp->ctx_blk_size,\r\n&cp->ctx_arr[i].mapping,\r\nGFP_KERNEL);\r\nif (cp->ctx_arr[i].ctx == NULL)\r\nreturn -ENOMEM;\r\nif (cp->ctx_align && cp->ctx_blk_size == ctx_blk_size) {\r\nif (cp->ctx_arr[i].mapping & (cp->ctx_align - 1)) {\r\ncnic_free_context(dev);\r\ncp->ctx_blk_size += cp->ctx_align;\r\ni = -1;\r\ncontinue;\r\n}\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int cnic_alloc_bnx2x_resc(struct cnic_dev *dev)\r\n{\r\nstruct cnic_local *cp = dev->cnic_priv;\r\nstruct bnx2x *bp = netdev_priv(dev->netdev);\r\nstruct cnic_eth_dev *ethdev = cp->ethdev;\r\nu32 start_cid = ethdev->starting_cid;\r\nint i, j, n, ret, pages;\r\nstruct cnic_dma *kwq_16_dma = &cp->kwq_16_data_info;\r\ncp->max_cid_space = MAX_ISCSI_TBL_SZ;\r\ncp->iscsi_start_cid = start_cid;\r\ncp->fcoe_start_cid = start_cid + MAX_ISCSI_TBL_SZ;\r\nif (BNX2X_CHIP_IS_E2_PLUS(bp)) {\r\ncp->max_cid_space += dev->max_fcoe_conn;\r\ncp->fcoe_init_cid = ethdev->fcoe_init_cid;\r\nif (!cp->fcoe_init_cid)\r\ncp->fcoe_init_cid = 0x10;\r\n}\r\ncp->iscsi_tbl = kzalloc(sizeof(struct cnic_iscsi) * MAX_ISCSI_TBL_SZ,\r\nGFP_KERNEL);\r\nif (!cp->iscsi_tbl)\r\ngoto error;\r\ncp->ctx_tbl = kzalloc(sizeof(struct cnic_context) *\r\ncp->max_cid_space, GFP_KERNEL);\r\nif (!cp->ctx_tbl)\r\ngoto error;\r\nfor (i = 0; i < MAX_ISCSI_TBL_SZ; i++) {\r\ncp->ctx_tbl[i].proto.iscsi = &cp->iscsi_tbl[i];\r\ncp->ctx_tbl[i].ulp_proto_id = CNIC_ULP_ISCSI;\r\n}\r\nfor (i = MAX_ISCSI_TBL_SZ; i < cp->max_cid_space; i++)\r\ncp->ctx_tbl[i].ulp_proto_id = CNIC_ULP_FCOE;\r\npages = CNIC_PAGE_ALIGN(cp->max_cid_space * CNIC_KWQ16_DATA_SIZE) /\r\nCNIC_PAGE_SIZE;\r\nret = cnic_alloc_dma(dev, kwq_16_dma, pages, 0);\r\nif (ret)\r\nreturn -ENOMEM;\r\nn = CNIC_PAGE_SIZE / CNIC_KWQ16_DATA_SIZE;\r\nfor (i = 0, j = 0; i < cp->max_cid_space; i++) {\r\nlong off = CNIC_KWQ16_DATA_SIZE * (i % n);\r\ncp->ctx_tbl[i].kwqe_data = kwq_16_dma->pg_arr[j] + off;\r\ncp->ctx_tbl[i].kwqe_data_mapping = kwq_16_dma->pg_map_arr[j] +\r\noff;\r\nif ((i % n) == (n - 1))\r\nj++;\r\n}\r\nret = cnic_alloc_kcq(dev, &cp->kcq1, false);\r\nif (ret)\r\ngoto error;\r\nif (CNIC_SUPPORTS_FCOE(bp)) {\r\nret = cnic_alloc_kcq(dev, &cp->kcq2, true);\r\nif (ret)\r\ngoto error;\r\n}\r\npages = CNIC_PAGE_ALIGN(BNX2X_ISCSI_GLB_BUF_SIZE) / CNIC_PAGE_SIZE;\r\nret = cnic_alloc_dma(dev, &cp->gbl_buf_info, pages, 0);\r\nif (ret)\r\ngoto error;\r\nret = cnic_alloc_bnx2x_context(dev);\r\nif (ret)\r\ngoto error;\r\nif (cp->ethdev->drv_state & CNIC_DRV_STATE_NO_ISCSI)\r\nreturn 0;\r\ncp->bnx2x_def_status_blk = cp->ethdev->irq_arr[1].status_blk;\r\ncp->l2_rx_ring_size = 15;\r\nret = cnic_alloc_uio_rings(dev, 4);\r\nif (ret)\r\ngoto error;\r\nret = cnic_init_uio(dev);\r\nif (ret)\r\ngoto error;\r\nreturn 0;\r\nerror:\r\ncnic_free_resc(dev);\r\nreturn -ENOMEM;\r\n}\r\nstatic inline u32 cnic_kwq_avail(struct cnic_local *cp)\r\n{\r\nreturn cp->max_kwq_idx -\r\n((cp->kwq_prod_idx - cp->kwq_con_idx) & cp->max_kwq_idx);\r\n}\r\nstatic int cnic_submit_bnx2_kwqes(struct cnic_dev *dev, struct kwqe *wqes[],\r\nu32 num_wqes)\r\n{\r\nstruct cnic_local *cp = dev->cnic_priv;\r\nstruct kwqe *prod_qe;\r\nu16 prod, sw_prod, i;\r\nif (!test_bit(CNIC_F_CNIC_UP, &dev->flags))\r\nreturn -EAGAIN;\r\nspin_lock_bh(&cp->cnic_ulp_lock);\r\nif (num_wqes > cnic_kwq_avail(cp) &&\r\n!test_bit(CNIC_LCL_FL_KWQ_INIT, &cp->cnic_local_flags)) {\r\nspin_unlock_bh(&cp->cnic_ulp_lock);\r\nreturn -EAGAIN;\r\n}\r\nclear_bit(CNIC_LCL_FL_KWQ_INIT, &cp->cnic_local_flags);\r\nprod = cp->kwq_prod_idx;\r\nsw_prod = prod & MAX_KWQ_IDX;\r\nfor (i = 0; i < num_wqes; i++) {\r\nprod_qe = &cp->kwq[KWQ_PG(sw_prod)][KWQ_IDX(sw_prod)];\r\nmemcpy(prod_qe, wqes[i], sizeof(struct kwqe));\r\nprod++;\r\nsw_prod = prod & MAX_KWQ_IDX;\r\n}\r\ncp->kwq_prod_idx = prod;\r\nCNIC_WR16(dev, cp->kwq_io_addr, cp->kwq_prod_idx);\r\nspin_unlock_bh(&cp->cnic_ulp_lock);\r\nreturn 0;\r\n}\r\nstatic void *cnic_get_kwqe_16_data(struct cnic_local *cp, u32 l5_cid,\r\nunion l5cm_specific_data *l5_data)\r\n{\r\nstruct cnic_context *ctx = &cp->ctx_tbl[l5_cid];\r\ndma_addr_t map;\r\nmap = ctx->kwqe_data_mapping;\r\nl5_data->phy_address.lo = (u64) map & 0xffffffff;\r\nl5_data->phy_address.hi = (u64) map >> 32;\r\nreturn ctx->kwqe_data;\r\n}\r\nstatic int cnic_submit_kwqe_16(struct cnic_dev *dev, u32 cmd, u32 cid,\r\nu32 type, union l5cm_specific_data *l5_data)\r\n{\r\nstruct cnic_local *cp = dev->cnic_priv;\r\nstruct bnx2x *bp = netdev_priv(dev->netdev);\r\nstruct l5cm_spe kwqe;\r\nstruct kwqe_16 *kwq[1];\r\nu16 type_16;\r\nint ret;\r\nkwqe.hdr.conn_and_cmd_data =\r\ncpu_to_le32(((cmd << SPE_HDR_CMD_ID_SHIFT) |\r\nBNX2X_HW_CID(bp, cid)));\r\ntype_16 = (type << SPE_HDR_CONN_TYPE_SHIFT) & SPE_HDR_CONN_TYPE;\r\ntype_16 |= (bp->pfid << SPE_HDR_FUNCTION_ID_SHIFT) &\r\nSPE_HDR_FUNCTION_ID;\r\nkwqe.hdr.type = cpu_to_le16(type_16);\r\nkwqe.hdr.reserved1 = 0;\r\nkwqe.data.phy_address.lo = cpu_to_le32(l5_data->phy_address.lo);\r\nkwqe.data.phy_address.hi = cpu_to_le32(l5_data->phy_address.hi);\r\nkwq[0] = (struct kwqe_16 *) &kwqe;\r\nspin_lock_bh(&cp->cnic_ulp_lock);\r\nret = cp->ethdev->drv_submit_kwqes_16(dev->netdev, kwq, 1);\r\nspin_unlock_bh(&cp->cnic_ulp_lock);\r\nif (ret == 1)\r\nreturn 0;\r\nreturn ret;\r\n}\r\nstatic void cnic_reply_bnx2x_kcqes(struct cnic_dev *dev, int ulp_type,\r\nstruct kcqe *cqes[], u32 num_cqes)\r\n{\r\nstruct cnic_local *cp = dev->cnic_priv;\r\nstruct cnic_ulp_ops *ulp_ops;\r\nrcu_read_lock();\r\nulp_ops = rcu_dereference(cp->ulp_ops[ulp_type]);\r\nif (likely(ulp_ops)) {\r\nulp_ops->indicate_kcqes(cp->ulp_handle[ulp_type],\r\ncqes, num_cqes);\r\n}\r\nrcu_read_unlock();\r\n}\r\nstatic void cnic_bnx2x_set_tcp_options(struct cnic_dev *dev, int time_stamps,\r\nint en_tcp_dack)\r\n{\r\nstruct bnx2x *bp = netdev_priv(dev->netdev);\r\nu8 xstorm_flags = XSTORM_L5CM_TCP_FLAGS_WND_SCL_EN;\r\nu16 tstorm_flags = 0;\r\nif (time_stamps) {\r\nxstorm_flags |= XSTORM_L5CM_TCP_FLAGS_TS_ENABLED;\r\ntstorm_flags |= TSTORM_L5CM_TCP_FLAGS_TS_ENABLED;\r\n}\r\nif (en_tcp_dack)\r\ntstorm_flags |= TSTORM_L5CM_TCP_FLAGS_DELAYED_ACK_EN;\r\nCNIC_WR8(dev, BAR_XSTRORM_INTMEM +\r\nXSTORM_ISCSI_TCP_VARS_FLAGS_OFFSET(bp->pfid), xstorm_flags);\r\nCNIC_WR16(dev, BAR_TSTRORM_INTMEM +\r\nTSTORM_ISCSI_TCP_VARS_FLAGS_OFFSET(bp->pfid), tstorm_flags);\r\n}\r\nstatic int cnic_bnx2x_iscsi_init1(struct cnic_dev *dev, struct kwqe *kwqe)\r\n{\r\nstruct cnic_local *cp = dev->cnic_priv;\r\nstruct bnx2x *bp = netdev_priv(dev->netdev);\r\nstruct iscsi_kwqe_init1 *req1 = (struct iscsi_kwqe_init1 *) kwqe;\r\nint hq_bds, pages;\r\nu32 pfid = bp->pfid;\r\ncp->num_iscsi_tasks = req1->num_tasks_per_conn;\r\ncp->num_ccells = req1->num_ccells_per_conn;\r\ncp->task_array_size = BNX2X_ISCSI_TASK_CONTEXT_SIZE *\r\ncp->num_iscsi_tasks;\r\ncp->r2tq_size = cp->num_iscsi_tasks * BNX2X_ISCSI_MAX_PENDING_R2TS *\r\nBNX2X_ISCSI_R2TQE_SIZE;\r\ncp->hq_size = cp->num_ccells * BNX2X_ISCSI_HQ_BD_SIZE;\r\npages = CNIC_PAGE_ALIGN(cp->hq_size) / CNIC_PAGE_SIZE;\r\nhq_bds = pages * (CNIC_PAGE_SIZE / BNX2X_ISCSI_HQ_BD_SIZE);\r\ncp->num_cqs = req1->num_cqs;\r\nif (!dev->max_iscsi_conn)\r\nreturn 0;\r\nCNIC_WR16(dev, BAR_TSTRORM_INTMEM + TSTORM_ISCSI_RQ_SIZE_OFFSET(pfid),\r\nreq1->rq_num_wqes);\r\nCNIC_WR16(dev, BAR_TSTRORM_INTMEM + TSTORM_ISCSI_PAGE_SIZE_OFFSET(pfid),\r\nCNIC_PAGE_SIZE);\r\nCNIC_WR8(dev, BAR_TSTRORM_INTMEM +\r\nTSTORM_ISCSI_PAGE_SIZE_LOG_OFFSET(pfid), CNIC_PAGE_BITS);\r\nCNIC_WR16(dev, BAR_TSTRORM_INTMEM +\r\nTSTORM_ISCSI_NUM_OF_TASKS_OFFSET(pfid),\r\nreq1->num_tasks_per_conn);\r\nCNIC_WR16(dev, BAR_USTRORM_INTMEM +\r\nUSTORM_ISCSI_RQ_BUFFER_SIZE_OFFSET(pfid),\r\nreq1->rq_buffer_size);\r\nCNIC_WR16(dev, BAR_USTRORM_INTMEM + USTORM_ISCSI_PAGE_SIZE_OFFSET(pfid),\r\nCNIC_PAGE_SIZE);\r\nCNIC_WR8(dev, BAR_USTRORM_INTMEM +\r\nUSTORM_ISCSI_PAGE_SIZE_LOG_OFFSET(pfid), CNIC_PAGE_BITS);\r\nCNIC_WR16(dev, BAR_USTRORM_INTMEM +\r\nUSTORM_ISCSI_NUM_OF_TASKS_OFFSET(pfid),\r\nreq1->num_tasks_per_conn);\r\nCNIC_WR16(dev, BAR_USTRORM_INTMEM + USTORM_ISCSI_RQ_SIZE_OFFSET(pfid),\r\nreq1->rq_num_wqes);\r\nCNIC_WR16(dev, BAR_USTRORM_INTMEM + USTORM_ISCSI_CQ_SIZE_OFFSET(pfid),\r\nreq1->cq_num_wqes);\r\nCNIC_WR16(dev, BAR_USTRORM_INTMEM + USTORM_ISCSI_R2TQ_SIZE_OFFSET(pfid),\r\ncp->num_iscsi_tasks * BNX2X_ISCSI_MAX_PENDING_R2TS);\r\nCNIC_WR16(dev, BAR_XSTRORM_INTMEM + XSTORM_ISCSI_PAGE_SIZE_OFFSET(pfid),\r\nCNIC_PAGE_SIZE);\r\nCNIC_WR8(dev, BAR_XSTRORM_INTMEM +\r\nXSTORM_ISCSI_PAGE_SIZE_LOG_OFFSET(pfid), CNIC_PAGE_BITS);\r\nCNIC_WR16(dev, BAR_XSTRORM_INTMEM +\r\nXSTORM_ISCSI_NUM_OF_TASKS_OFFSET(pfid),\r\nreq1->num_tasks_per_conn);\r\nCNIC_WR16(dev, BAR_XSTRORM_INTMEM + XSTORM_ISCSI_HQ_SIZE_OFFSET(pfid),\r\nhq_bds);\r\nCNIC_WR16(dev, BAR_XSTRORM_INTMEM + XSTORM_ISCSI_SQ_SIZE_OFFSET(pfid),\r\nreq1->num_tasks_per_conn);\r\nCNIC_WR16(dev, BAR_XSTRORM_INTMEM + XSTORM_ISCSI_R2TQ_SIZE_OFFSET(pfid),\r\ncp->num_iscsi_tasks * BNX2X_ISCSI_MAX_PENDING_R2TS);\r\nCNIC_WR16(dev, BAR_CSTRORM_INTMEM + CSTORM_ISCSI_PAGE_SIZE_OFFSET(pfid),\r\nCNIC_PAGE_SIZE);\r\nCNIC_WR8(dev, BAR_CSTRORM_INTMEM +\r\nCSTORM_ISCSI_PAGE_SIZE_LOG_OFFSET(pfid), CNIC_PAGE_BITS);\r\nCNIC_WR16(dev, BAR_CSTRORM_INTMEM +\r\nCSTORM_ISCSI_NUM_OF_TASKS_OFFSET(pfid),\r\nreq1->num_tasks_per_conn);\r\nCNIC_WR16(dev, BAR_CSTRORM_INTMEM + CSTORM_ISCSI_CQ_SIZE_OFFSET(pfid),\r\nreq1->cq_num_wqes);\r\nCNIC_WR16(dev, BAR_CSTRORM_INTMEM + CSTORM_ISCSI_HQ_SIZE_OFFSET(pfid),\r\nhq_bds);\r\ncnic_bnx2x_set_tcp_options(dev,\r\nreq1->flags & ISCSI_KWQE_INIT1_TIME_STAMPS_ENABLE,\r\nreq1->flags & ISCSI_KWQE_INIT1_DELAYED_ACK_ENABLE);\r\nreturn 0;\r\n}\r\nstatic int cnic_bnx2x_iscsi_init2(struct cnic_dev *dev, struct kwqe *kwqe)\r\n{\r\nstruct iscsi_kwqe_init2 *req2 = (struct iscsi_kwqe_init2 *) kwqe;\r\nstruct bnx2x *bp = netdev_priv(dev->netdev);\r\nu32 pfid = bp->pfid;\r\nstruct iscsi_kcqe kcqe;\r\nstruct kcqe *cqes[1];\r\nmemset(&kcqe, 0, sizeof(kcqe));\r\nif (!dev->max_iscsi_conn) {\r\nkcqe.completion_status =\r\nISCSI_KCQE_COMPLETION_STATUS_ISCSI_NOT_SUPPORTED;\r\ngoto done;\r\n}\r\nCNIC_WR(dev, BAR_TSTRORM_INTMEM +\r\nTSTORM_ISCSI_ERROR_BITMAP_OFFSET(pfid), req2->error_bit_map[0]);\r\nCNIC_WR(dev, BAR_TSTRORM_INTMEM +\r\nTSTORM_ISCSI_ERROR_BITMAP_OFFSET(pfid) + 4,\r\nreq2->error_bit_map[1]);\r\nCNIC_WR16(dev, BAR_USTRORM_INTMEM +\r\nUSTORM_ISCSI_CQ_SQN_SIZE_OFFSET(pfid), req2->max_cq_sqn);\r\nCNIC_WR(dev, BAR_USTRORM_INTMEM +\r\nUSTORM_ISCSI_ERROR_BITMAP_OFFSET(pfid), req2->error_bit_map[0]);\r\nCNIC_WR(dev, BAR_USTRORM_INTMEM +\r\nUSTORM_ISCSI_ERROR_BITMAP_OFFSET(pfid) + 4,\r\nreq2->error_bit_map[1]);\r\nCNIC_WR16(dev, BAR_CSTRORM_INTMEM +\r\nCSTORM_ISCSI_CQ_SQN_SIZE_OFFSET(pfid), req2->max_cq_sqn);\r\nkcqe.completion_status = ISCSI_KCQE_COMPLETION_STATUS_SUCCESS;\r\ndone:\r\nkcqe.op_code = ISCSI_KCQE_OPCODE_INIT;\r\ncqes[0] = (struct kcqe *) &kcqe;\r\ncnic_reply_bnx2x_kcqes(dev, CNIC_ULP_ISCSI, cqes, 1);\r\nreturn 0;\r\n}\r\nstatic void cnic_free_bnx2x_conn_resc(struct cnic_dev *dev, u32 l5_cid)\r\n{\r\nstruct cnic_local *cp = dev->cnic_priv;\r\nstruct cnic_context *ctx = &cp->ctx_tbl[l5_cid];\r\nif (ctx->ulp_proto_id == CNIC_ULP_ISCSI) {\r\nstruct cnic_iscsi *iscsi = ctx->proto.iscsi;\r\ncnic_free_dma(dev, &iscsi->hq_info);\r\ncnic_free_dma(dev, &iscsi->r2tq_info);\r\ncnic_free_dma(dev, &iscsi->task_array_info);\r\ncnic_free_id(&cp->cid_tbl, ctx->cid);\r\n} else {\r\ncnic_free_id(&cp->fcoe_cid_tbl, ctx->cid);\r\n}\r\nctx->cid = 0;\r\n}\r\nstatic int cnic_alloc_bnx2x_conn_resc(struct cnic_dev *dev, u32 l5_cid)\r\n{\r\nu32 cid;\r\nint ret, pages;\r\nstruct cnic_local *cp = dev->cnic_priv;\r\nstruct cnic_context *ctx = &cp->ctx_tbl[l5_cid];\r\nstruct cnic_iscsi *iscsi = ctx->proto.iscsi;\r\nif (ctx->ulp_proto_id == CNIC_ULP_FCOE) {\r\ncid = cnic_alloc_new_id(&cp->fcoe_cid_tbl);\r\nif (cid == -1) {\r\nret = -ENOMEM;\r\ngoto error;\r\n}\r\nctx->cid = cid;\r\nreturn 0;\r\n}\r\ncid = cnic_alloc_new_id(&cp->cid_tbl);\r\nif (cid == -1) {\r\nret = -ENOMEM;\r\ngoto error;\r\n}\r\nctx->cid = cid;\r\npages = CNIC_PAGE_ALIGN(cp->task_array_size) / CNIC_PAGE_SIZE;\r\nret = cnic_alloc_dma(dev, &iscsi->task_array_info, pages, 1);\r\nif (ret)\r\ngoto error;\r\npages = CNIC_PAGE_ALIGN(cp->r2tq_size) / CNIC_PAGE_SIZE;\r\nret = cnic_alloc_dma(dev, &iscsi->r2tq_info, pages, 1);\r\nif (ret)\r\ngoto error;\r\npages = CNIC_PAGE_ALIGN(cp->hq_size) / CNIC_PAGE_SIZE;\r\nret = cnic_alloc_dma(dev, &iscsi->hq_info, pages, 1);\r\nif (ret)\r\ngoto error;\r\nreturn 0;\r\nerror:\r\ncnic_free_bnx2x_conn_resc(dev, l5_cid);\r\nreturn ret;\r\n}\r\nstatic void *cnic_get_bnx2x_ctx(struct cnic_dev *dev, u32 cid, int init,\r\nstruct regpair *ctx_addr)\r\n{\r\nstruct cnic_local *cp = dev->cnic_priv;\r\nstruct cnic_eth_dev *ethdev = cp->ethdev;\r\nint blk = (cid - ethdev->starting_cid) / cp->cids_per_blk;\r\nint off = (cid - ethdev->starting_cid) % cp->cids_per_blk;\r\nunsigned long align_off = 0;\r\ndma_addr_t ctx_map;\r\nvoid *ctx;\r\nif (cp->ctx_align) {\r\nunsigned long mask = cp->ctx_align - 1;\r\nif (cp->ctx_arr[blk].mapping & mask)\r\nalign_off = cp->ctx_align -\r\n(cp->ctx_arr[blk].mapping & mask);\r\n}\r\nctx_map = cp->ctx_arr[blk].mapping + align_off +\r\n(off * BNX2X_CONTEXT_MEM_SIZE);\r\nctx = cp->ctx_arr[blk].ctx + align_off +\r\n(off * BNX2X_CONTEXT_MEM_SIZE);\r\nif (init)\r\nmemset(ctx, 0, BNX2X_CONTEXT_MEM_SIZE);\r\nctx_addr->lo = ctx_map & 0xffffffff;\r\nctx_addr->hi = (u64) ctx_map >> 32;\r\nreturn ctx;\r\n}\r\nstatic int cnic_setup_bnx2x_ctx(struct cnic_dev *dev, struct kwqe *wqes[],\r\nu32 num)\r\n{\r\nstruct cnic_local *cp = dev->cnic_priv;\r\nstruct bnx2x *bp = netdev_priv(dev->netdev);\r\nstruct iscsi_kwqe_conn_offload1 *req1 =\r\n(struct iscsi_kwqe_conn_offload1 *) wqes[0];\r\nstruct iscsi_kwqe_conn_offload2 *req2 =\r\n(struct iscsi_kwqe_conn_offload2 *) wqes[1];\r\nstruct iscsi_kwqe_conn_offload3 *req3;\r\nstruct cnic_context *ctx = &cp->ctx_tbl[req1->iscsi_conn_id];\r\nstruct cnic_iscsi *iscsi = ctx->proto.iscsi;\r\nu32 cid = ctx->cid;\r\nu32 hw_cid = BNX2X_HW_CID(bp, cid);\r\nstruct iscsi_context *ictx;\r\nstruct regpair context_addr;\r\nint i, j, n = 2, n_max;\r\nu8 port = BP_PORT(bp);\r\nctx->ctx_flags = 0;\r\nif (!req2->num_additional_wqes)\r\nreturn -EINVAL;\r\nn_max = req2->num_additional_wqes + 2;\r\nictx = cnic_get_bnx2x_ctx(dev, cid, 1, &context_addr);\r\nif (ictx == NULL)\r\nreturn -ENOMEM;\r\nreq3 = (struct iscsi_kwqe_conn_offload3 *) wqes[n++];\r\nictx->xstorm_ag_context.hq_prod = 1;\r\nictx->xstorm_st_context.iscsi.first_burst_length =\r\nISCSI_DEF_FIRST_BURST_LEN;\r\nictx->xstorm_st_context.iscsi.max_send_pdu_length =\r\nISCSI_DEF_MAX_RECV_SEG_LEN;\r\nictx->xstorm_st_context.iscsi.sq_pbl_base.lo =\r\nreq1->sq_page_table_addr_lo;\r\nictx->xstorm_st_context.iscsi.sq_pbl_base.hi =\r\nreq1->sq_page_table_addr_hi;\r\nictx->xstorm_st_context.iscsi.sq_curr_pbe.lo = req2->sq_first_pte.hi;\r\nictx->xstorm_st_context.iscsi.sq_curr_pbe.hi = req2->sq_first_pte.lo;\r\nictx->xstorm_st_context.iscsi.hq_pbl_base.lo =\r\niscsi->hq_info.pgtbl_map & 0xffffffff;\r\nictx->xstorm_st_context.iscsi.hq_pbl_base.hi =\r\n(u64) iscsi->hq_info.pgtbl_map >> 32;\r\nictx->xstorm_st_context.iscsi.hq_curr_pbe_base.lo =\r\niscsi->hq_info.pgtbl[0];\r\nictx->xstorm_st_context.iscsi.hq_curr_pbe_base.hi =\r\niscsi->hq_info.pgtbl[1];\r\nictx->xstorm_st_context.iscsi.r2tq_pbl_base.lo =\r\niscsi->r2tq_info.pgtbl_map & 0xffffffff;\r\nictx->xstorm_st_context.iscsi.r2tq_pbl_base.hi =\r\n(u64) iscsi->r2tq_info.pgtbl_map >> 32;\r\nictx->xstorm_st_context.iscsi.r2tq_curr_pbe_base.lo =\r\niscsi->r2tq_info.pgtbl[0];\r\nictx->xstorm_st_context.iscsi.r2tq_curr_pbe_base.hi =\r\niscsi->r2tq_info.pgtbl[1];\r\nictx->xstorm_st_context.iscsi.task_pbl_base.lo =\r\niscsi->task_array_info.pgtbl_map & 0xffffffff;\r\nictx->xstorm_st_context.iscsi.task_pbl_base.hi =\r\n(u64) iscsi->task_array_info.pgtbl_map >> 32;\r\nictx->xstorm_st_context.iscsi.task_pbl_cache_idx =\r\nBNX2X_ISCSI_PBL_NOT_CACHED;\r\nictx->xstorm_st_context.iscsi.flags.flags |=\r\nXSTORM_ISCSI_CONTEXT_FLAGS_B_IMMEDIATE_DATA;\r\nictx->xstorm_st_context.iscsi.flags.flags |=\r\nXSTORM_ISCSI_CONTEXT_FLAGS_B_INITIAL_R2T;\r\nictx->xstorm_st_context.common.ethernet.reserved_vlan_type =\r\nETH_P_8021Q;\r\nif (BNX2X_CHIP_IS_E2_PLUS(bp) &&\r\nbp->common.chip_port_mode == CHIP_2_PORT_MODE) {\r\nport = 0;\r\n}\r\nictx->xstorm_st_context.common.flags =\r\n1 << XSTORM_COMMON_CONTEXT_SECTION_PHYSQ_INITIALIZED_SHIFT;\r\nictx->xstorm_st_context.common.flags =\r\nport << XSTORM_COMMON_CONTEXT_SECTION_PBF_PORT_SHIFT;\r\nictx->tstorm_st_context.iscsi.hdr_bytes_2_fetch = ISCSI_HEADER_SIZE;\r\nictx->tstorm_st_context.iscsi.rq_db_phy_addr.lo =\r\nreq2->rq_page_table_addr_lo & CNIC_PAGE_MASK;\r\nictx->tstorm_st_context.iscsi.rq_db_phy_addr.hi =\r\nreq2->rq_page_table_addr_hi;\r\nictx->tstorm_st_context.iscsi.iscsi_conn_id = req1->iscsi_conn_id;\r\nictx->tstorm_st_context.tcp.cwnd = 0x5A8;\r\nictx->tstorm_st_context.tcp.flags2 |=\r\nTSTORM_TCP_ST_CONTEXT_SECTION_DA_EN;\r\nictx->tstorm_st_context.tcp.ooo_support_mode =\r\nTCP_TSTORM_OOO_DROP_AND_PROC_ACK;\r\nictx->timers_context.flags |= TIMERS_BLOCK_CONTEXT_CONN_VALID_FLG;\r\nictx->ustorm_st_context.ring.rq.pbl_base.lo =\r\nreq2->rq_page_table_addr_lo;\r\nictx->ustorm_st_context.ring.rq.pbl_base.hi =\r\nreq2->rq_page_table_addr_hi;\r\nictx->ustorm_st_context.ring.rq.curr_pbe.lo = req3->qp_first_pte[0].hi;\r\nictx->ustorm_st_context.ring.rq.curr_pbe.hi = req3->qp_first_pte[0].lo;\r\nictx->ustorm_st_context.ring.r2tq.pbl_base.lo =\r\niscsi->r2tq_info.pgtbl_map & 0xffffffff;\r\nictx->ustorm_st_context.ring.r2tq.pbl_base.hi =\r\n(u64) iscsi->r2tq_info.pgtbl_map >> 32;\r\nictx->ustorm_st_context.ring.r2tq.curr_pbe.lo =\r\niscsi->r2tq_info.pgtbl[0];\r\nictx->ustorm_st_context.ring.r2tq.curr_pbe.hi =\r\niscsi->r2tq_info.pgtbl[1];\r\nictx->ustorm_st_context.ring.cq_pbl_base.lo =\r\nreq1->cq_page_table_addr_lo;\r\nictx->ustorm_st_context.ring.cq_pbl_base.hi =\r\nreq1->cq_page_table_addr_hi;\r\nictx->ustorm_st_context.ring.cq[0].cq_sn = ISCSI_INITIAL_SN;\r\nictx->ustorm_st_context.ring.cq[0].curr_pbe.lo = req2->cq_first_pte.hi;\r\nictx->ustorm_st_context.ring.cq[0].curr_pbe.hi = req2->cq_first_pte.lo;\r\nictx->ustorm_st_context.task_pbe_cache_index =\r\nBNX2X_ISCSI_PBL_NOT_CACHED;\r\nictx->ustorm_st_context.task_pdu_cache_index =\r\nBNX2X_ISCSI_PDU_HEADER_NOT_CACHED;\r\nfor (i = 1, j = 1; i < cp->num_cqs; i++, j++) {\r\nif (j == 3) {\r\nif (n >= n_max)\r\nbreak;\r\nreq3 = (struct iscsi_kwqe_conn_offload3 *) wqes[n++];\r\nj = 0;\r\n}\r\nictx->ustorm_st_context.ring.cq[i].cq_sn = ISCSI_INITIAL_SN;\r\nictx->ustorm_st_context.ring.cq[i].curr_pbe.lo =\r\nreq3->qp_first_pte[j].hi;\r\nictx->ustorm_st_context.ring.cq[i].curr_pbe.hi =\r\nreq3->qp_first_pte[j].lo;\r\n}\r\nictx->ustorm_st_context.task_pbl_base.lo =\r\niscsi->task_array_info.pgtbl_map & 0xffffffff;\r\nictx->ustorm_st_context.task_pbl_base.hi =\r\n(u64) iscsi->task_array_info.pgtbl_map >> 32;\r\nictx->ustorm_st_context.tce_phy_addr.lo =\r\niscsi->task_array_info.pgtbl[0];\r\nictx->ustorm_st_context.tce_phy_addr.hi =\r\niscsi->task_array_info.pgtbl[1];\r\nictx->ustorm_st_context.iscsi_conn_id = req1->iscsi_conn_id;\r\nictx->ustorm_st_context.num_cqs = cp->num_cqs;\r\nictx->ustorm_st_context.negotiated_rx |= ISCSI_DEF_MAX_RECV_SEG_LEN;\r\nictx->ustorm_st_context.negotiated_rx_and_flags |=\r\nISCSI_DEF_MAX_BURST_LEN;\r\nictx->ustorm_st_context.negotiated_rx |=\r\nISCSI_DEFAULT_MAX_OUTSTANDING_R2T <<\r\nUSTORM_ISCSI_ST_CONTEXT_MAX_OUTSTANDING_R2TS_SHIFT;\r\nictx->cstorm_st_context.hq_pbl_base.lo =\r\niscsi->hq_info.pgtbl_map & 0xffffffff;\r\nictx->cstorm_st_context.hq_pbl_base.hi =\r\n(u64) iscsi->hq_info.pgtbl_map >> 32;\r\nictx->cstorm_st_context.hq_curr_pbe.lo = iscsi->hq_info.pgtbl[0];\r\nictx->cstorm_st_context.hq_curr_pbe.hi = iscsi->hq_info.pgtbl[1];\r\nictx->cstorm_st_context.task_pbl_base.lo =\r\niscsi->task_array_info.pgtbl_map & 0xffffffff;\r\nictx->cstorm_st_context.task_pbl_base.hi =\r\n(u64) iscsi->task_array_info.pgtbl_map >> 32;\r\nictx->cstorm_st_context.cq_db_base.lo =\r\nreq1->cq_page_table_addr_lo & CNIC_PAGE_MASK;\r\nictx->cstorm_st_context.cq_db_base.hi = req1->cq_page_table_addr_hi;\r\nictx->cstorm_st_context.iscsi_conn_id = req1->iscsi_conn_id;\r\nictx->cstorm_st_context.cq_proc_en_bit_map = (1 << cp->num_cqs) - 1;\r\nfor (i = 0; i < cp->num_cqs; i++) {\r\nictx->cstorm_st_context.cq_c_prod_sqn_arr.sqn[i] =\r\nISCSI_INITIAL_SN;\r\nictx->cstorm_st_context.cq_c_sqn_2_notify_arr.sqn[i] =\r\nISCSI_INITIAL_SN;\r\n}\r\nictx->xstorm_ag_context.cdu_reserved =\r\nCDU_RSRVD_VALUE_TYPE_A(hw_cid, CDU_REGION_NUMBER_XCM_AG,\r\nISCSI_CONNECTION_TYPE);\r\nictx->ustorm_ag_context.cdu_usage =\r\nCDU_RSRVD_VALUE_TYPE_A(hw_cid, CDU_REGION_NUMBER_UCM_AG,\r\nISCSI_CONNECTION_TYPE);\r\nreturn 0;\r\n}\r\nstatic int cnic_bnx2x_iscsi_ofld1(struct cnic_dev *dev, struct kwqe *wqes[],\r\nu32 num, int *work)\r\n{\r\nstruct iscsi_kwqe_conn_offload1 *req1;\r\nstruct iscsi_kwqe_conn_offload2 *req2;\r\nstruct cnic_local *cp = dev->cnic_priv;\r\nstruct bnx2x *bp = netdev_priv(dev->netdev);\r\nstruct cnic_context *ctx;\r\nstruct iscsi_kcqe kcqe;\r\nstruct kcqe *cqes[1];\r\nu32 l5_cid;\r\nint ret = 0;\r\nif (num < 2) {\r\n*work = num;\r\nreturn -EINVAL;\r\n}\r\nreq1 = (struct iscsi_kwqe_conn_offload1 *) wqes[0];\r\nreq2 = (struct iscsi_kwqe_conn_offload2 *) wqes[1];\r\nif ((num - 2) < req2->num_additional_wqes) {\r\n*work = num;\r\nreturn -EINVAL;\r\n}\r\n*work = 2 + req2->num_additional_wqes;\r\nl5_cid = req1->iscsi_conn_id;\r\nif (l5_cid >= MAX_ISCSI_TBL_SZ)\r\nreturn -EINVAL;\r\nmemset(&kcqe, 0, sizeof(kcqe));\r\nkcqe.op_code = ISCSI_KCQE_OPCODE_OFFLOAD_CONN;\r\nkcqe.iscsi_conn_id = l5_cid;\r\nkcqe.completion_status = ISCSI_KCQE_COMPLETION_STATUS_CTX_ALLOC_FAILURE;\r\nctx = &cp->ctx_tbl[l5_cid];\r\nif (test_bit(CTX_FL_OFFLD_START, &ctx->ctx_flags)) {\r\nkcqe.completion_status =\r\nISCSI_KCQE_COMPLETION_STATUS_CID_BUSY;\r\ngoto done;\r\n}\r\nif (atomic_inc_return(&cp->iscsi_conn) > dev->max_iscsi_conn) {\r\natomic_dec(&cp->iscsi_conn);\r\ngoto done;\r\n}\r\nret = cnic_alloc_bnx2x_conn_resc(dev, l5_cid);\r\nif (ret) {\r\natomic_dec(&cp->iscsi_conn);\r\nret = 0;\r\ngoto done;\r\n}\r\nret = cnic_setup_bnx2x_ctx(dev, wqes, num);\r\nif (ret < 0) {\r\ncnic_free_bnx2x_conn_resc(dev, l5_cid);\r\natomic_dec(&cp->iscsi_conn);\r\ngoto done;\r\n}\r\nkcqe.completion_status = ISCSI_KCQE_COMPLETION_STATUS_SUCCESS;\r\nkcqe.iscsi_conn_context_id = BNX2X_HW_CID(bp, cp->ctx_tbl[l5_cid].cid);\r\ndone:\r\ncqes[0] = (struct kcqe *) &kcqe;\r\ncnic_reply_bnx2x_kcqes(dev, CNIC_ULP_ISCSI, cqes, 1);\r\nreturn 0;\r\n}\r\nstatic int cnic_bnx2x_iscsi_update(struct cnic_dev *dev, struct kwqe *kwqe)\r\n{\r\nstruct cnic_local *cp = dev->cnic_priv;\r\nstruct iscsi_kwqe_conn_update *req =\r\n(struct iscsi_kwqe_conn_update *) kwqe;\r\nvoid *data;\r\nunion l5cm_specific_data l5_data;\r\nu32 l5_cid, cid = BNX2X_SW_CID(req->context_id);\r\nint ret;\r\nif (cnic_get_l5_cid(cp, cid, &l5_cid) != 0)\r\nreturn -EINVAL;\r\ndata = cnic_get_kwqe_16_data(cp, l5_cid, &l5_data);\r\nif (!data)\r\nreturn -ENOMEM;\r\nmemcpy(data, kwqe, sizeof(struct kwqe));\r\nret = cnic_submit_kwqe_16(dev, ISCSI_RAMROD_CMD_ID_UPDATE_CONN,\r\nreq->context_id, ISCSI_CONNECTION_TYPE, &l5_data);\r\nreturn ret;\r\n}\r\nstatic int cnic_bnx2x_destroy_ramrod(struct cnic_dev *dev, u32 l5_cid)\r\n{\r\nstruct cnic_local *cp = dev->cnic_priv;\r\nstruct bnx2x *bp = netdev_priv(dev->netdev);\r\nstruct cnic_context *ctx = &cp->ctx_tbl[l5_cid];\r\nunion l5cm_specific_data l5_data;\r\nint ret;\r\nu32 hw_cid;\r\ninit_waitqueue_head(&ctx->waitq);\r\nctx->wait_cond = 0;\r\nmemset(&l5_data, 0, sizeof(l5_data));\r\nhw_cid = BNX2X_HW_CID(bp, ctx->cid);\r\nret = cnic_submit_kwqe_16(dev, RAMROD_CMD_ID_COMMON_CFC_DEL,\r\nhw_cid, NONE_CONNECTION_TYPE, &l5_data);\r\nif (ret == 0) {\r\nwait_event_timeout(ctx->waitq, ctx->wait_cond, CNIC_RAMROD_TMO);\r\nif (unlikely(test_bit(CTX_FL_CID_ERROR, &ctx->ctx_flags)))\r\nreturn -EBUSY;\r\n}\r\nreturn 0;\r\n}\r\nstatic int cnic_bnx2x_iscsi_destroy(struct cnic_dev *dev, struct kwqe *kwqe)\r\n{\r\nstruct cnic_local *cp = dev->cnic_priv;\r\nstruct iscsi_kwqe_conn_destroy *req =\r\n(struct iscsi_kwqe_conn_destroy *) kwqe;\r\nu32 l5_cid = req->reserved0;\r\nstruct cnic_context *ctx = &cp->ctx_tbl[l5_cid];\r\nint ret = 0;\r\nstruct iscsi_kcqe kcqe;\r\nstruct kcqe *cqes[1];\r\nif (!test_bit(CTX_FL_OFFLD_START, &ctx->ctx_flags))\r\ngoto skip_cfc_delete;\r\nif (!time_after(jiffies, ctx->timestamp + (2 * HZ))) {\r\nunsigned long delta = ctx->timestamp + (2 * HZ) - jiffies;\r\nif (delta > (2 * HZ))\r\ndelta = 0;\r\nset_bit(CTX_FL_DELETE_WAIT, &ctx->ctx_flags);\r\nqueue_delayed_work(cnic_wq, &cp->delete_task, delta);\r\ngoto destroy_reply;\r\n}\r\nret = cnic_bnx2x_destroy_ramrod(dev, l5_cid);\r\nskip_cfc_delete:\r\ncnic_free_bnx2x_conn_resc(dev, l5_cid);\r\nif (!ret) {\r\natomic_dec(&cp->iscsi_conn);\r\nclear_bit(CTX_FL_OFFLD_START, &ctx->ctx_flags);\r\n}\r\ndestroy_reply:\r\nmemset(&kcqe, 0, sizeof(kcqe));\r\nkcqe.op_code = ISCSI_KCQE_OPCODE_DESTROY_CONN;\r\nkcqe.iscsi_conn_id = l5_cid;\r\nkcqe.completion_status = ISCSI_KCQE_COMPLETION_STATUS_SUCCESS;\r\nkcqe.iscsi_conn_context_id = req->context_id;\r\ncqes[0] = (struct kcqe *) &kcqe;\r\ncnic_reply_bnx2x_kcqes(dev, CNIC_ULP_ISCSI, cqes, 1);\r\nreturn 0;\r\n}\r\nstatic void cnic_init_storm_conn_bufs(struct cnic_dev *dev,\r\nstruct l4_kwq_connect_req1 *kwqe1,\r\nstruct l4_kwq_connect_req3 *kwqe3,\r\nstruct l5cm_active_conn_buffer *conn_buf)\r\n{\r\nstruct l5cm_conn_addr_params *conn_addr = &conn_buf->conn_addr_buf;\r\nstruct l5cm_xstorm_conn_buffer *xstorm_buf =\r\n&conn_buf->xstorm_conn_buffer;\r\nstruct l5cm_tstorm_conn_buffer *tstorm_buf =\r\n&conn_buf->tstorm_conn_buffer;\r\nstruct regpair context_addr;\r\nu32 cid = BNX2X_SW_CID(kwqe1->cid);\r\nstruct in6_addr src_ip, dst_ip;\r\nint i;\r\nu32 *addrp;\r\naddrp = (u32 *) &conn_addr->local_ip_addr;\r\nfor (i = 0; i < 4; i++, addrp++)\r\nsrc_ip.in6_u.u6_addr32[i] = cpu_to_be32(*addrp);\r\naddrp = (u32 *) &conn_addr->remote_ip_addr;\r\nfor (i = 0; i < 4; i++, addrp++)\r\ndst_ip.in6_u.u6_addr32[i] = cpu_to_be32(*addrp);\r\ncnic_get_bnx2x_ctx(dev, cid, 0, &context_addr);\r\nxstorm_buf->context_addr.hi = context_addr.hi;\r\nxstorm_buf->context_addr.lo = context_addr.lo;\r\nxstorm_buf->mss = 0xffff;\r\nxstorm_buf->rcv_buf = kwqe3->rcv_buf;\r\nif (kwqe1->tcp_flags & L4_KWQ_CONNECT_REQ1_NAGLE_ENABLE)\r\nxstorm_buf->params |= L5CM_XSTORM_CONN_BUFFER_NAGLE_ENABLE;\r\nxstorm_buf->pseudo_header_checksum =\r\nswab16(~csum_ipv6_magic(&src_ip, &dst_ip, 0, IPPROTO_TCP, 0));\r\nif (kwqe3->ka_timeout) {\r\ntstorm_buf->ka_enable = 1;\r\ntstorm_buf->ka_timeout = kwqe3->ka_timeout;\r\ntstorm_buf->ka_interval = kwqe3->ka_interval;\r\ntstorm_buf->ka_max_probe_count = kwqe3->ka_max_probe_count;\r\n}\r\ntstorm_buf->max_rt_time = 0xffffffff;\r\n}\r\nstatic void cnic_init_bnx2x_mac(struct cnic_dev *dev)\r\n{\r\nstruct bnx2x *bp = netdev_priv(dev->netdev);\r\nu32 pfid = bp->pfid;\r\nu8 *mac = dev->mac_addr;\r\nCNIC_WR8(dev, BAR_XSTRORM_INTMEM +\r\nXSTORM_ISCSI_LOCAL_MAC_ADDR0_OFFSET(pfid), mac[0]);\r\nCNIC_WR8(dev, BAR_XSTRORM_INTMEM +\r\nXSTORM_ISCSI_LOCAL_MAC_ADDR1_OFFSET(pfid), mac[1]);\r\nCNIC_WR8(dev, BAR_XSTRORM_INTMEM +\r\nXSTORM_ISCSI_LOCAL_MAC_ADDR2_OFFSET(pfid), mac[2]);\r\nCNIC_WR8(dev, BAR_XSTRORM_INTMEM +\r\nXSTORM_ISCSI_LOCAL_MAC_ADDR3_OFFSET(pfid), mac[3]);\r\nCNIC_WR8(dev, BAR_XSTRORM_INTMEM +\r\nXSTORM_ISCSI_LOCAL_MAC_ADDR4_OFFSET(pfid), mac[4]);\r\nCNIC_WR8(dev, BAR_XSTRORM_INTMEM +\r\nXSTORM_ISCSI_LOCAL_MAC_ADDR5_OFFSET(pfid), mac[5]);\r\nCNIC_WR8(dev, BAR_TSTRORM_INTMEM +\r\nTSTORM_ISCSI_TCP_VARS_LSB_LOCAL_MAC_ADDR_OFFSET(pfid), mac[5]);\r\nCNIC_WR8(dev, BAR_TSTRORM_INTMEM +\r\nTSTORM_ISCSI_TCP_VARS_LSB_LOCAL_MAC_ADDR_OFFSET(pfid) + 1,\r\nmac[4]);\r\nCNIC_WR8(dev, BAR_TSTRORM_INTMEM +\r\nTSTORM_ISCSI_TCP_VARS_MID_LOCAL_MAC_ADDR_OFFSET(pfid), mac[3]);\r\nCNIC_WR8(dev, BAR_TSTRORM_INTMEM +\r\nTSTORM_ISCSI_TCP_VARS_MID_LOCAL_MAC_ADDR_OFFSET(pfid) + 1,\r\nmac[2]);\r\nCNIC_WR8(dev, BAR_TSTRORM_INTMEM +\r\nTSTORM_ISCSI_TCP_VARS_MSB_LOCAL_MAC_ADDR_OFFSET(pfid), mac[1]);\r\nCNIC_WR8(dev, BAR_TSTRORM_INTMEM +\r\nTSTORM_ISCSI_TCP_VARS_MSB_LOCAL_MAC_ADDR_OFFSET(pfid) + 1,\r\nmac[0]);\r\n}\r\nstatic int cnic_bnx2x_connect(struct cnic_dev *dev, struct kwqe *wqes[],\r\nu32 num, int *work)\r\n{\r\nstruct cnic_local *cp = dev->cnic_priv;\r\nstruct bnx2x *bp = netdev_priv(dev->netdev);\r\nstruct l4_kwq_connect_req1 *kwqe1 =\r\n(struct l4_kwq_connect_req1 *) wqes[0];\r\nstruct l4_kwq_connect_req3 *kwqe3;\r\nstruct l5cm_active_conn_buffer *conn_buf;\r\nstruct l5cm_conn_addr_params *conn_addr;\r\nunion l5cm_specific_data l5_data;\r\nu32 l5_cid = kwqe1->pg_cid;\r\nstruct cnic_sock *csk = &cp->csk_tbl[l5_cid];\r\nstruct cnic_context *ctx = &cp->ctx_tbl[l5_cid];\r\nint ret;\r\nif (num < 2) {\r\n*work = num;\r\nreturn -EINVAL;\r\n}\r\nif (kwqe1->conn_flags & L4_KWQ_CONNECT_REQ1_IP_V6)\r\n*work = 3;\r\nelse\r\n*work = 2;\r\nif (num < *work) {\r\n*work = num;\r\nreturn -EINVAL;\r\n}\r\nif (sizeof(*conn_buf) > CNIC_KWQ16_DATA_SIZE) {\r\nnetdev_err(dev->netdev, "conn_buf size too big\n");\r\nreturn -ENOMEM;\r\n}\r\nconn_buf = cnic_get_kwqe_16_data(cp, l5_cid, &l5_data);\r\nif (!conn_buf)\r\nreturn -ENOMEM;\r\nmemset(conn_buf, 0, sizeof(*conn_buf));\r\nconn_addr = &conn_buf->conn_addr_buf;\r\nconn_addr->remote_addr_0 = csk->ha[0];\r\nconn_addr->remote_addr_1 = csk->ha[1];\r\nconn_addr->remote_addr_2 = csk->ha[2];\r\nconn_addr->remote_addr_3 = csk->ha[3];\r\nconn_addr->remote_addr_4 = csk->ha[4];\r\nconn_addr->remote_addr_5 = csk->ha[5];\r\nif (kwqe1->conn_flags & L4_KWQ_CONNECT_REQ1_IP_V6) {\r\nstruct l4_kwq_connect_req2 *kwqe2 =\r\n(struct l4_kwq_connect_req2 *) wqes[1];\r\nconn_addr->local_ip_addr.ip_addr_hi_hi = kwqe2->src_ip_v6_4;\r\nconn_addr->local_ip_addr.ip_addr_hi_lo = kwqe2->src_ip_v6_3;\r\nconn_addr->local_ip_addr.ip_addr_lo_hi = kwqe2->src_ip_v6_2;\r\nconn_addr->remote_ip_addr.ip_addr_hi_hi = kwqe2->dst_ip_v6_4;\r\nconn_addr->remote_ip_addr.ip_addr_hi_lo = kwqe2->dst_ip_v6_3;\r\nconn_addr->remote_ip_addr.ip_addr_lo_hi = kwqe2->dst_ip_v6_2;\r\nconn_addr->params |= L5CM_CONN_ADDR_PARAMS_IP_VERSION;\r\n}\r\nkwqe3 = (struct l4_kwq_connect_req3 *) wqes[*work - 1];\r\nconn_addr->local_ip_addr.ip_addr_lo_lo = kwqe1->src_ip;\r\nconn_addr->remote_ip_addr.ip_addr_lo_lo = kwqe1->dst_ip;\r\nconn_addr->local_tcp_port = kwqe1->src_port;\r\nconn_addr->remote_tcp_port = kwqe1->dst_port;\r\nconn_addr->pmtu = kwqe3->pmtu;\r\ncnic_init_storm_conn_bufs(dev, kwqe1, kwqe3, conn_buf);\r\nCNIC_WR16(dev, BAR_XSTRORM_INTMEM +\r\nXSTORM_ISCSI_LOCAL_VLAN_OFFSET(bp->pfid), csk->vlan_id);\r\nret = cnic_submit_kwqe_16(dev, L5CM_RAMROD_CMD_ID_TCP_CONNECT,\r\nkwqe1->cid, ISCSI_CONNECTION_TYPE, &l5_data);\r\nif (!ret)\r\nset_bit(CTX_FL_OFFLD_START, &ctx->ctx_flags);\r\nreturn ret;\r\n}\r\nstatic int cnic_bnx2x_close(struct cnic_dev *dev, struct kwqe *kwqe)\r\n{\r\nstruct l4_kwq_close_req *req = (struct l4_kwq_close_req *) kwqe;\r\nunion l5cm_specific_data l5_data;\r\nint ret;\r\nmemset(&l5_data, 0, sizeof(l5_data));\r\nret = cnic_submit_kwqe_16(dev, L5CM_RAMROD_CMD_ID_CLOSE,\r\nreq->cid, ISCSI_CONNECTION_TYPE, &l5_data);\r\nreturn ret;\r\n}\r\nstatic int cnic_bnx2x_reset(struct cnic_dev *dev, struct kwqe *kwqe)\r\n{\r\nstruct l4_kwq_reset_req *req = (struct l4_kwq_reset_req *) kwqe;\r\nunion l5cm_specific_data l5_data;\r\nint ret;\r\nmemset(&l5_data, 0, sizeof(l5_data));\r\nret = cnic_submit_kwqe_16(dev, L5CM_RAMROD_CMD_ID_ABORT,\r\nreq->cid, ISCSI_CONNECTION_TYPE, &l5_data);\r\nreturn ret;\r\n}\r\nstatic int cnic_bnx2x_offload_pg(struct cnic_dev *dev, struct kwqe *kwqe)\r\n{\r\nstruct l4_kwq_offload_pg *req = (struct l4_kwq_offload_pg *) kwqe;\r\nstruct l4_kcq kcqe;\r\nstruct kcqe *cqes[1];\r\nmemset(&kcqe, 0, sizeof(kcqe));\r\nkcqe.pg_host_opaque = req->host_opaque;\r\nkcqe.pg_cid = req->host_opaque;\r\nkcqe.op_code = L4_KCQE_OPCODE_VALUE_OFFLOAD_PG;\r\ncqes[0] = (struct kcqe *) &kcqe;\r\ncnic_reply_bnx2x_kcqes(dev, CNIC_ULP_L4, cqes, 1);\r\nreturn 0;\r\n}\r\nstatic int cnic_bnx2x_update_pg(struct cnic_dev *dev, struct kwqe *kwqe)\r\n{\r\nstruct l4_kwq_update_pg *req = (struct l4_kwq_update_pg *) kwqe;\r\nstruct l4_kcq kcqe;\r\nstruct kcqe *cqes[1];\r\nmemset(&kcqe, 0, sizeof(kcqe));\r\nkcqe.pg_host_opaque = req->pg_host_opaque;\r\nkcqe.pg_cid = req->pg_cid;\r\nkcqe.op_code = L4_KCQE_OPCODE_VALUE_UPDATE_PG;\r\ncqes[0] = (struct kcqe *) &kcqe;\r\ncnic_reply_bnx2x_kcqes(dev, CNIC_ULP_L4, cqes, 1);\r\nreturn 0;\r\n}\r\nstatic int cnic_bnx2x_fcoe_stat(struct cnic_dev *dev, struct kwqe *kwqe)\r\n{\r\nstruct fcoe_kwqe_stat *req;\r\nstruct fcoe_stat_ramrod_params *fcoe_stat;\r\nunion l5cm_specific_data l5_data;\r\nstruct cnic_local *cp = dev->cnic_priv;\r\nstruct bnx2x *bp = netdev_priv(dev->netdev);\r\nint ret;\r\nu32 cid;\r\nreq = (struct fcoe_kwqe_stat *) kwqe;\r\ncid = BNX2X_HW_CID(bp, cp->fcoe_init_cid);\r\nfcoe_stat = cnic_get_kwqe_16_data(cp, BNX2X_FCOE_L5_CID_BASE, &l5_data);\r\nif (!fcoe_stat)\r\nreturn -ENOMEM;\r\nmemset(fcoe_stat, 0, sizeof(*fcoe_stat));\r\nmemcpy(&fcoe_stat->stat_kwqe, req, sizeof(*req));\r\nret = cnic_submit_kwqe_16(dev, FCOE_RAMROD_CMD_ID_STAT_FUNC, cid,\r\nFCOE_CONNECTION_TYPE, &l5_data);\r\nreturn ret;\r\n}\r\nstatic int cnic_bnx2x_fcoe_init1(struct cnic_dev *dev, struct kwqe *wqes[],\r\nu32 num, int *work)\r\n{\r\nint ret;\r\nstruct cnic_local *cp = dev->cnic_priv;\r\nstruct bnx2x *bp = netdev_priv(dev->netdev);\r\nu32 cid;\r\nstruct fcoe_init_ramrod_params *fcoe_init;\r\nstruct fcoe_kwqe_init1 *req1;\r\nstruct fcoe_kwqe_init2 *req2;\r\nstruct fcoe_kwqe_init3 *req3;\r\nunion l5cm_specific_data l5_data;\r\nif (num < 3) {\r\n*work = num;\r\nreturn -EINVAL;\r\n}\r\nreq1 = (struct fcoe_kwqe_init1 *) wqes[0];\r\nreq2 = (struct fcoe_kwqe_init2 *) wqes[1];\r\nreq3 = (struct fcoe_kwqe_init3 *) wqes[2];\r\nif (req2->hdr.op_code != FCOE_KWQE_OPCODE_INIT2) {\r\n*work = 1;\r\nreturn -EINVAL;\r\n}\r\nif (req3->hdr.op_code != FCOE_KWQE_OPCODE_INIT3) {\r\n*work = 2;\r\nreturn -EINVAL;\r\n}\r\nif (sizeof(*fcoe_init) > CNIC_KWQ16_DATA_SIZE) {\r\nnetdev_err(dev->netdev, "fcoe_init size too big\n");\r\nreturn -ENOMEM;\r\n}\r\nfcoe_init = cnic_get_kwqe_16_data(cp, BNX2X_FCOE_L5_CID_BASE, &l5_data);\r\nif (!fcoe_init)\r\nreturn -ENOMEM;\r\nmemset(fcoe_init, 0, sizeof(*fcoe_init));\r\nmemcpy(&fcoe_init->init_kwqe1, req1, sizeof(*req1));\r\nmemcpy(&fcoe_init->init_kwqe2, req2, sizeof(*req2));\r\nmemcpy(&fcoe_init->init_kwqe3, req3, sizeof(*req3));\r\nfcoe_init->eq_pbl_base.lo = cp->kcq2.dma.pgtbl_map & 0xffffffff;\r\nfcoe_init->eq_pbl_base.hi = (u64) cp->kcq2.dma.pgtbl_map >> 32;\r\nfcoe_init->eq_pbl_size = cp->kcq2.dma.num_pages;\r\nfcoe_init->sb_num = cp->status_blk_num;\r\nfcoe_init->eq_prod = MAX_KCQ_IDX;\r\nfcoe_init->sb_id = HC_INDEX_FCOE_EQ_CONS;\r\ncp->kcq2.sw_prod_idx = 0;\r\ncid = BNX2X_HW_CID(bp, cp->fcoe_init_cid);\r\nret = cnic_submit_kwqe_16(dev, FCOE_RAMROD_CMD_ID_INIT_FUNC, cid,\r\nFCOE_CONNECTION_TYPE, &l5_data);\r\n*work = 3;\r\nreturn ret;\r\n}\r\nstatic int cnic_bnx2x_fcoe_ofld1(struct cnic_dev *dev, struct kwqe *wqes[],\r\nu32 num, int *work)\r\n{\r\nint ret = 0;\r\nu32 cid = -1, l5_cid;\r\nstruct cnic_local *cp = dev->cnic_priv;\r\nstruct bnx2x *bp = netdev_priv(dev->netdev);\r\nstruct fcoe_kwqe_conn_offload1 *req1;\r\nstruct fcoe_kwqe_conn_offload2 *req2;\r\nstruct fcoe_kwqe_conn_offload3 *req3;\r\nstruct fcoe_kwqe_conn_offload4 *req4;\r\nstruct fcoe_conn_offload_ramrod_params *fcoe_offload;\r\nstruct cnic_context *ctx;\r\nstruct fcoe_context *fctx;\r\nstruct regpair ctx_addr;\r\nunion l5cm_specific_data l5_data;\r\nstruct fcoe_kcqe kcqe;\r\nstruct kcqe *cqes[1];\r\nif (num < 4) {\r\n*work = num;\r\nreturn -EINVAL;\r\n}\r\nreq1 = (struct fcoe_kwqe_conn_offload1 *) wqes[0];\r\nreq2 = (struct fcoe_kwqe_conn_offload2 *) wqes[1];\r\nreq3 = (struct fcoe_kwqe_conn_offload3 *) wqes[2];\r\nreq4 = (struct fcoe_kwqe_conn_offload4 *) wqes[3];\r\n*work = 4;\r\nl5_cid = req1->fcoe_conn_id;\r\nif (l5_cid >= dev->max_fcoe_conn)\r\ngoto err_reply;\r\nl5_cid += BNX2X_FCOE_L5_CID_BASE;\r\nctx = &cp->ctx_tbl[l5_cid];\r\nif (test_bit(CTX_FL_OFFLD_START, &ctx->ctx_flags))\r\ngoto err_reply;\r\nret = cnic_alloc_bnx2x_conn_resc(dev, l5_cid);\r\nif (ret) {\r\nret = 0;\r\ngoto err_reply;\r\n}\r\ncid = ctx->cid;\r\nfctx = cnic_get_bnx2x_ctx(dev, cid, 1, &ctx_addr);\r\nif (fctx) {\r\nu32 hw_cid = BNX2X_HW_CID(bp, cid);\r\nu32 val;\r\nval = CDU_RSRVD_VALUE_TYPE_A(hw_cid, CDU_REGION_NUMBER_XCM_AG,\r\nFCOE_CONNECTION_TYPE);\r\nfctx->xstorm_ag_context.cdu_reserved = val;\r\nval = CDU_RSRVD_VALUE_TYPE_A(hw_cid, CDU_REGION_NUMBER_UCM_AG,\r\nFCOE_CONNECTION_TYPE);\r\nfctx->ustorm_ag_context.cdu_usage = val;\r\n}\r\nif (sizeof(*fcoe_offload) > CNIC_KWQ16_DATA_SIZE) {\r\nnetdev_err(dev->netdev, "fcoe_offload size too big\n");\r\ngoto err_reply;\r\n}\r\nfcoe_offload = cnic_get_kwqe_16_data(cp, l5_cid, &l5_data);\r\nif (!fcoe_offload)\r\ngoto err_reply;\r\nmemset(fcoe_offload, 0, sizeof(*fcoe_offload));\r\nmemcpy(&fcoe_offload->offload_kwqe1, req1, sizeof(*req1));\r\nmemcpy(&fcoe_offload->offload_kwqe2, req2, sizeof(*req2));\r\nmemcpy(&fcoe_offload->offload_kwqe3, req3, sizeof(*req3));\r\nmemcpy(&fcoe_offload->offload_kwqe4, req4, sizeof(*req4));\r\ncid = BNX2X_HW_CID(bp, cid);\r\nret = cnic_submit_kwqe_16(dev, FCOE_RAMROD_CMD_ID_OFFLOAD_CONN, cid,\r\nFCOE_CONNECTION_TYPE, &l5_data);\r\nif (!ret)\r\nset_bit(CTX_FL_OFFLD_START, &ctx->ctx_flags);\r\nreturn ret;\r\nerr_reply:\r\nif (cid != -1)\r\ncnic_free_bnx2x_conn_resc(dev, l5_cid);\r\nmemset(&kcqe, 0, sizeof(kcqe));\r\nkcqe.op_code = FCOE_KCQE_OPCODE_OFFLOAD_CONN;\r\nkcqe.fcoe_conn_id = req1->fcoe_conn_id;\r\nkcqe.completion_status = FCOE_KCQE_COMPLETION_STATUS_CTX_ALLOC_FAILURE;\r\ncqes[0] = (struct kcqe *) &kcqe;\r\ncnic_reply_bnx2x_kcqes(dev, CNIC_ULP_FCOE, cqes, 1);\r\nreturn ret;\r\n}\r\nstatic int cnic_bnx2x_fcoe_enable(struct cnic_dev *dev, struct kwqe *kwqe)\r\n{\r\nstruct fcoe_kwqe_conn_enable_disable *req;\r\nstruct fcoe_conn_enable_disable_ramrod_params *fcoe_enable;\r\nunion l5cm_specific_data l5_data;\r\nint ret;\r\nu32 cid, l5_cid;\r\nstruct cnic_local *cp = dev->cnic_priv;\r\nreq = (struct fcoe_kwqe_conn_enable_disable *) kwqe;\r\ncid = req->context_id;\r\nl5_cid = req->conn_id + BNX2X_FCOE_L5_CID_BASE;\r\nif (sizeof(*fcoe_enable) > CNIC_KWQ16_DATA_SIZE) {\r\nnetdev_err(dev->netdev, "fcoe_enable size too big\n");\r\nreturn -ENOMEM;\r\n}\r\nfcoe_enable = cnic_get_kwqe_16_data(cp, l5_cid, &l5_data);\r\nif (!fcoe_enable)\r\nreturn -ENOMEM;\r\nmemset(fcoe_enable, 0, sizeof(*fcoe_enable));\r\nmemcpy(&fcoe_enable->enable_disable_kwqe, req, sizeof(*req));\r\nret = cnic_submit_kwqe_16(dev, FCOE_RAMROD_CMD_ID_ENABLE_CONN, cid,\r\nFCOE_CONNECTION_TYPE, &l5_data);\r\nreturn ret;\r\n}\r\nstatic int cnic_bnx2x_fcoe_disable(struct cnic_dev *dev, struct kwqe *kwqe)\r\n{\r\nstruct fcoe_kwqe_conn_enable_disable *req;\r\nstruct fcoe_conn_enable_disable_ramrod_params *fcoe_disable;\r\nunion l5cm_specific_data l5_data;\r\nint ret;\r\nu32 cid, l5_cid;\r\nstruct cnic_local *cp = dev->cnic_priv;\r\nreq = (struct fcoe_kwqe_conn_enable_disable *) kwqe;\r\ncid = req->context_id;\r\nl5_cid = req->conn_id;\r\nif (l5_cid >= dev->max_fcoe_conn)\r\nreturn -EINVAL;\r\nl5_cid += BNX2X_FCOE_L5_CID_BASE;\r\nif (sizeof(*fcoe_disable) > CNIC_KWQ16_DATA_SIZE) {\r\nnetdev_err(dev->netdev, "fcoe_disable size too big\n");\r\nreturn -ENOMEM;\r\n}\r\nfcoe_disable = cnic_get_kwqe_16_data(cp, l5_cid, &l5_data);\r\nif (!fcoe_disable)\r\nreturn -ENOMEM;\r\nmemset(fcoe_disable, 0, sizeof(*fcoe_disable));\r\nmemcpy(&fcoe_disable->enable_disable_kwqe, req, sizeof(*req));\r\nret = cnic_submit_kwqe_16(dev, FCOE_RAMROD_CMD_ID_DISABLE_CONN, cid,\r\nFCOE_CONNECTION_TYPE, &l5_data);\r\nreturn ret;\r\n}\r\nstatic int cnic_bnx2x_fcoe_destroy(struct cnic_dev *dev, struct kwqe *kwqe)\r\n{\r\nstruct fcoe_kwqe_conn_destroy *req;\r\nunion l5cm_specific_data l5_data;\r\nint ret;\r\nu32 cid, l5_cid;\r\nstruct cnic_local *cp = dev->cnic_priv;\r\nstruct cnic_context *ctx;\r\nstruct fcoe_kcqe kcqe;\r\nstruct kcqe *cqes[1];\r\nreq = (struct fcoe_kwqe_conn_destroy *) kwqe;\r\ncid = req->context_id;\r\nl5_cid = req->conn_id;\r\nif (l5_cid >= dev->max_fcoe_conn)\r\nreturn -EINVAL;\r\nl5_cid += BNX2X_FCOE_L5_CID_BASE;\r\nctx = &cp->ctx_tbl[l5_cid];\r\ninit_waitqueue_head(&ctx->waitq);\r\nctx->wait_cond = 0;\r\nmemset(&kcqe, 0, sizeof(kcqe));\r\nkcqe.completion_status = FCOE_KCQE_COMPLETION_STATUS_ERROR;\r\nmemset(&l5_data, 0, sizeof(l5_data));\r\nret = cnic_submit_kwqe_16(dev, FCOE_RAMROD_CMD_ID_TERMINATE_CONN, cid,\r\nFCOE_CONNECTION_TYPE, &l5_data);\r\nif (ret == 0) {\r\nwait_event_timeout(ctx->waitq, ctx->wait_cond, CNIC_RAMROD_TMO);\r\nif (ctx->wait_cond)\r\nkcqe.completion_status = 0;\r\n}\r\nset_bit(CTX_FL_DELETE_WAIT, &ctx->ctx_flags);\r\nqueue_delayed_work(cnic_wq, &cp->delete_task, msecs_to_jiffies(2000));\r\nkcqe.op_code = FCOE_KCQE_OPCODE_DESTROY_CONN;\r\nkcqe.fcoe_conn_id = req->conn_id;\r\nkcqe.fcoe_conn_context_id = cid;\r\ncqes[0] = (struct kcqe *) &kcqe;\r\ncnic_reply_bnx2x_kcqes(dev, CNIC_ULP_FCOE, cqes, 1);\r\nreturn ret;\r\n}\r\nstatic void cnic_bnx2x_delete_wait(struct cnic_dev *dev, u32 start_cid)\r\n{\r\nstruct cnic_local *cp = dev->cnic_priv;\r\nu32 i;\r\nfor (i = start_cid; i < cp->max_cid_space; i++) {\r\nstruct cnic_context *ctx = &cp->ctx_tbl[i];\r\nint j;\r\nwhile (test_bit(CTX_FL_DELETE_WAIT, &ctx->ctx_flags))\r\nmsleep(10);\r\nfor (j = 0; j < 5; j++) {\r\nif (!test_bit(CTX_FL_OFFLD_START, &ctx->ctx_flags))\r\nbreak;\r\nmsleep(20);\r\n}\r\nif (test_bit(CTX_FL_OFFLD_START, &ctx->ctx_flags))\r\nnetdev_warn(dev->netdev, "CID %x not deleted\n",\r\nctx->cid);\r\n}\r\n}\r\nstatic int cnic_bnx2x_fcoe_fw_destroy(struct cnic_dev *dev, struct kwqe *kwqe)\r\n{\r\nstruct fcoe_kwqe_destroy *req;\r\nunion l5cm_specific_data l5_data;\r\nstruct cnic_local *cp = dev->cnic_priv;\r\nstruct bnx2x *bp = netdev_priv(dev->netdev);\r\nint ret;\r\nu32 cid;\r\ncnic_bnx2x_delete_wait(dev, MAX_ISCSI_TBL_SZ);\r\nreq = (struct fcoe_kwqe_destroy *) kwqe;\r\ncid = BNX2X_HW_CID(bp, cp->fcoe_init_cid);\r\nmemset(&l5_data, 0, sizeof(l5_data));\r\nret = cnic_submit_kwqe_16(dev, FCOE_RAMROD_CMD_ID_DESTROY_FUNC, cid,\r\nFCOE_CONNECTION_TYPE, &l5_data);\r\nreturn ret;\r\n}\r\nstatic void cnic_bnx2x_kwqe_err(struct cnic_dev *dev, struct kwqe *kwqe)\r\n{\r\nstruct cnic_local *cp = dev->cnic_priv;\r\nstruct kcqe kcqe;\r\nstruct kcqe *cqes[1];\r\nu32 cid;\r\nu32 opcode = KWQE_OPCODE(kwqe->kwqe_op_flag);\r\nu32 layer_code = kwqe->kwqe_op_flag & KWQE_LAYER_MASK;\r\nu32 kcqe_op;\r\nint ulp_type;\r\ncid = kwqe->kwqe_info0;\r\nmemset(&kcqe, 0, sizeof(kcqe));\r\nif (layer_code == KWQE_FLAGS_LAYER_MASK_L5_FCOE) {\r\nu32 l5_cid = 0;\r\nulp_type = CNIC_ULP_FCOE;\r\nif (opcode == FCOE_KWQE_OPCODE_DISABLE_CONN) {\r\nstruct fcoe_kwqe_conn_enable_disable *req;\r\nreq = (struct fcoe_kwqe_conn_enable_disable *) kwqe;\r\nkcqe_op = FCOE_KCQE_OPCODE_DISABLE_CONN;\r\ncid = req->context_id;\r\nl5_cid = req->conn_id;\r\n} else if (opcode == FCOE_KWQE_OPCODE_DESTROY) {\r\nkcqe_op = FCOE_KCQE_OPCODE_DESTROY_FUNC;\r\n} else {\r\nreturn;\r\n}\r\nkcqe.kcqe_op_flag = kcqe_op << KCQE_FLAGS_OPCODE_SHIFT;\r\nkcqe.kcqe_op_flag |= KCQE_FLAGS_LAYER_MASK_L5_FCOE;\r\nkcqe.kcqe_info1 = FCOE_KCQE_COMPLETION_STATUS_PARITY_ERROR;\r\nkcqe.kcqe_info2 = cid;\r\nkcqe.kcqe_info0 = l5_cid;\r\n} else if (layer_code == KWQE_FLAGS_LAYER_MASK_L5_ISCSI) {\r\nulp_type = CNIC_ULP_ISCSI;\r\nif (opcode == ISCSI_KWQE_OPCODE_UPDATE_CONN)\r\ncid = kwqe->kwqe_info1;\r\nkcqe.kcqe_op_flag = (opcode + 0x10) << KCQE_FLAGS_OPCODE_SHIFT;\r\nkcqe.kcqe_op_flag |= KCQE_FLAGS_LAYER_MASK_L5_ISCSI;\r\nkcqe.kcqe_info1 = ISCSI_KCQE_COMPLETION_STATUS_PARITY_ERR;\r\nkcqe.kcqe_info2 = cid;\r\ncnic_get_l5_cid(cp, BNX2X_SW_CID(cid), &kcqe.kcqe_info0);\r\n} else if (layer_code == KWQE_FLAGS_LAYER_MASK_L4) {\r\nstruct l4_kcq *l4kcqe = (struct l4_kcq *) &kcqe;\r\nulp_type = CNIC_ULP_L4;\r\nif (opcode == L4_KWQE_OPCODE_VALUE_CONNECT1)\r\nkcqe_op = L4_KCQE_OPCODE_VALUE_CONNECT_COMPLETE;\r\nelse if (opcode == L4_KWQE_OPCODE_VALUE_RESET)\r\nkcqe_op = L4_KCQE_OPCODE_VALUE_RESET_COMP;\r\nelse if (opcode == L4_KWQE_OPCODE_VALUE_CLOSE)\r\nkcqe_op = L4_KCQE_OPCODE_VALUE_CLOSE_COMP;\r\nelse\r\nreturn;\r\nkcqe.kcqe_op_flag = (kcqe_op << KCQE_FLAGS_OPCODE_SHIFT) |\r\nKCQE_FLAGS_LAYER_MASK_L4;\r\nl4kcqe->status = L4_KCQE_COMPLETION_STATUS_PARITY_ERROR;\r\nl4kcqe->cid = cid;\r\ncnic_get_l5_cid(cp, BNX2X_SW_CID(cid), &l4kcqe->conn_id);\r\n} else {\r\nreturn;\r\n}\r\ncqes[0] = &kcqe;\r\ncnic_reply_bnx2x_kcqes(dev, ulp_type, cqes, 1);\r\n}\r\nstatic int cnic_submit_bnx2x_iscsi_kwqes(struct cnic_dev *dev,\r\nstruct kwqe *wqes[], u32 num_wqes)\r\n{\r\nint i, work, ret;\r\nu32 opcode;\r\nstruct kwqe *kwqe;\r\nif (!test_bit(CNIC_F_CNIC_UP, &dev->flags))\r\nreturn -EAGAIN;\r\nfor (i = 0; i < num_wqes; ) {\r\nkwqe = wqes[i];\r\nopcode = KWQE_OPCODE(kwqe->kwqe_op_flag);\r\nwork = 1;\r\nswitch (opcode) {\r\ncase ISCSI_KWQE_OPCODE_INIT1:\r\nret = cnic_bnx2x_iscsi_init1(dev, kwqe);\r\nbreak;\r\ncase ISCSI_KWQE_OPCODE_INIT2:\r\nret = cnic_bnx2x_iscsi_init2(dev, kwqe);\r\nbreak;\r\ncase ISCSI_KWQE_OPCODE_OFFLOAD_CONN1:\r\nret = cnic_bnx2x_iscsi_ofld1(dev, &wqes[i],\r\nnum_wqes - i, &work);\r\nbreak;\r\ncase ISCSI_KWQE_OPCODE_UPDATE_CONN:\r\nret = cnic_bnx2x_iscsi_update(dev, kwqe);\r\nbreak;\r\ncase ISCSI_KWQE_OPCODE_DESTROY_CONN:\r\nret = cnic_bnx2x_iscsi_destroy(dev, kwqe);\r\nbreak;\r\ncase L4_KWQE_OPCODE_VALUE_CONNECT1:\r\nret = cnic_bnx2x_connect(dev, &wqes[i], num_wqes - i,\r\n&work);\r\nbreak;\r\ncase L4_KWQE_OPCODE_VALUE_CLOSE:\r\nret = cnic_bnx2x_close(dev, kwqe);\r\nbreak;\r\ncase L4_KWQE_OPCODE_VALUE_RESET:\r\nret = cnic_bnx2x_reset(dev, kwqe);\r\nbreak;\r\ncase L4_KWQE_OPCODE_VALUE_OFFLOAD_PG:\r\nret = cnic_bnx2x_offload_pg(dev, kwqe);\r\nbreak;\r\ncase L4_KWQE_OPCODE_VALUE_UPDATE_PG:\r\nret = cnic_bnx2x_update_pg(dev, kwqe);\r\nbreak;\r\ncase L4_KWQE_OPCODE_VALUE_UPLOAD_PG:\r\nret = 0;\r\nbreak;\r\ndefault:\r\nret = 0;\r\nnetdev_err(dev->netdev, "Unknown type of KWQE(0x%x)\n",\r\nopcode);\r\nbreak;\r\n}\r\nif (ret < 0) {\r\nnetdev_err(dev->netdev, "KWQE(0x%x) failed\n",\r\nopcode);\r\nif (ret == -EIO || ret == -EAGAIN)\r\ncnic_bnx2x_kwqe_err(dev, kwqe);\r\n}\r\ni += work;\r\n}\r\nreturn 0;\r\n}\r\nstatic int cnic_submit_bnx2x_fcoe_kwqes(struct cnic_dev *dev,\r\nstruct kwqe *wqes[], u32 num_wqes)\r\n{\r\nstruct bnx2x *bp = netdev_priv(dev->netdev);\r\nint i, work, ret;\r\nu32 opcode;\r\nstruct kwqe *kwqe;\r\nif (!test_bit(CNIC_F_CNIC_UP, &dev->flags))\r\nreturn -EAGAIN;\r\nif (!BNX2X_CHIP_IS_E2_PLUS(bp))\r\nreturn -EINVAL;\r\nfor (i = 0; i < num_wqes; ) {\r\nkwqe = wqes[i];\r\nopcode = KWQE_OPCODE(kwqe->kwqe_op_flag);\r\nwork = 1;\r\nswitch (opcode) {\r\ncase FCOE_KWQE_OPCODE_INIT1:\r\nret = cnic_bnx2x_fcoe_init1(dev, &wqes[i],\r\nnum_wqes - i, &work);\r\nbreak;\r\ncase FCOE_KWQE_OPCODE_OFFLOAD_CONN1:\r\nret = cnic_bnx2x_fcoe_ofld1(dev, &wqes[i],\r\nnum_wqes - i, &work);\r\nbreak;\r\ncase FCOE_KWQE_OPCODE_ENABLE_CONN:\r\nret = cnic_bnx2x_fcoe_enable(dev, kwqe);\r\nbreak;\r\ncase FCOE_KWQE_OPCODE_DISABLE_CONN:\r\nret = cnic_bnx2x_fcoe_disable(dev, kwqe);\r\nbreak;\r\ncase FCOE_KWQE_OPCODE_DESTROY_CONN:\r\nret = cnic_bnx2x_fcoe_destroy(dev, kwqe);\r\nbreak;\r\ncase FCOE_KWQE_OPCODE_DESTROY:\r\nret = cnic_bnx2x_fcoe_fw_destroy(dev, kwqe);\r\nbreak;\r\ncase FCOE_KWQE_OPCODE_STAT:\r\nret = cnic_bnx2x_fcoe_stat(dev, kwqe);\r\nbreak;\r\ndefault:\r\nret = 0;\r\nnetdev_err(dev->netdev, "Unknown type of KWQE(0x%x)\n",\r\nopcode);\r\nbreak;\r\n}\r\nif (ret < 0) {\r\nnetdev_err(dev->netdev, "KWQE(0x%x) failed\n",\r\nopcode);\r\nif (ret == -EIO || ret == -EAGAIN)\r\ncnic_bnx2x_kwqe_err(dev, kwqe);\r\n}\r\ni += work;\r\n}\r\nreturn 0;\r\n}\r\nstatic int cnic_submit_bnx2x_kwqes(struct cnic_dev *dev, struct kwqe *wqes[],\r\nu32 num_wqes)\r\n{\r\nint ret = -EINVAL;\r\nu32 layer_code;\r\nif (!test_bit(CNIC_F_CNIC_UP, &dev->flags))\r\nreturn -EAGAIN;\r\nif (!num_wqes)\r\nreturn 0;\r\nlayer_code = wqes[0]->kwqe_op_flag & KWQE_LAYER_MASK;\r\nswitch (layer_code) {\r\ncase KWQE_FLAGS_LAYER_MASK_L5_ISCSI:\r\ncase KWQE_FLAGS_LAYER_MASK_L4:\r\ncase KWQE_FLAGS_LAYER_MASK_L2:\r\nret = cnic_submit_bnx2x_iscsi_kwqes(dev, wqes, num_wqes);\r\nbreak;\r\ncase KWQE_FLAGS_LAYER_MASK_L5_FCOE:\r\nret = cnic_submit_bnx2x_fcoe_kwqes(dev, wqes, num_wqes);\r\nbreak;\r\n}\r\nreturn ret;\r\n}\r\nstatic inline u32 cnic_get_kcqe_layer_mask(u32 opflag)\r\n{\r\nif (unlikely(KCQE_OPCODE(opflag) == FCOE_RAMROD_CMD_ID_TERMINATE_CONN))\r\nreturn KCQE_FLAGS_LAYER_MASK_L4;\r\nreturn opflag & KCQE_FLAGS_LAYER_MASK;\r\n}\r\nstatic void service_kcqes(struct cnic_dev *dev, int num_cqes)\r\n{\r\nstruct cnic_local *cp = dev->cnic_priv;\r\nint i, j, comp = 0;\r\ni = 0;\r\nj = 1;\r\nwhile (num_cqes) {\r\nstruct cnic_ulp_ops *ulp_ops;\r\nint ulp_type;\r\nu32 kcqe_op_flag = cp->completed_kcq[i]->kcqe_op_flag;\r\nu32 kcqe_layer = cnic_get_kcqe_layer_mask(kcqe_op_flag);\r\nif (unlikely(kcqe_op_flag & KCQE_RAMROD_COMPLETION))\r\ncomp++;\r\nwhile (j < num_cqes) {\r\nu32 next_op = cp->completed_kcq[i + j]->kcqe_op_flag;\r\nif (cnic_get_kcqe_layer_mask(next_op) != kcqe_layer)\r\nbreak;\r\nif (unlikely(next_op & KCQE_RAMROD_COMPLETION))\r\ncomp++;\r\nj++;\r\n}\r\nif (kcqe_layer == KCQE_FLAGS_LAYER_MASK_L5_RDMA)\r\nulp_type = CNIC_ULP_RDMA;\r\nelse if (kcqe_layer == KCQE_FLAGS_LAYER_MASK_L5_ISCSI)\r\nulp_type = CNIC_ULP_ISCSI;\r\nelse if (kcqe_layer == KCQE_FLAGS_LAYER_MASK_L5_FCOE)\r\nulp_type = CNIC_ULP_FCOE;\r\nelse if (kcqe_layer == KCQE_FLAGS_LAYER_MASK_L4)\r\nulp_type = CNIC_ULP_L4;\r\nelse if (kcqe_layer == KCQE_FLAGS_LAYER_MASK_L2)\r\ngoto end;\r\nelse {\r\nnetdev_err(dev->netdev, "Unknown type of KCQE(0x%x)\n",\r\nkcqe_op_flag);\r\ngoto end;\r\n}\r\nrcu_read_lock();\r\nulp_ops = rcu_dereference(cp->ulp_ops[ulp_type]);\r\nif (likely(ulp_ops)) {\r\nulp_ops->indicate_kcqes(cp->ulp_handle[ulp_type],\r\ncp->completed_kcq + i, j);\r\n}\r\nrcu_read_unlock();\r\nend:\r\nnum_cqes -= j;\r\ni += j;\r\nj = 1;\r\n}\r\nif (unlikely(comp))\r\ncnic_spq_completion(dev, DRV_CTL_RET_L5_SPQ_CREDIT_CMD, comp);\r\n}\r\nstatic int cnic_get_kcqes(struct cnic_dev *dev, struct kcq_info *info)\r\n{\r\nstruct cnic_local *cp = dev->cnic_priv;\r\nu16 i, ri, hw_prod, last;\r\nstruct kcqe *kcqe;\r\nint kcqe_cnt = 0, last_cnt = 0;\r\ni = ri = last = info->sw_prod_idx;\r\nri &= MAX_KCQ_IDX;\r\nhw_prod = *info->hw_prod_idx_ptr;\r\nhw_prod = info->hw_idx(hw_prod);\r\nwhile ((i != hw_prod) && (kcqe_cnt < MAX_COMPLETED_KCQE)) {\r\nkcqe = &info->kcq[KCQ_PG(ri)][KCQ_IDX(ri)];\r\ncp->completed_kcq[kcqe_cnt++] = kcqe;\r\ni = info->next_idx(i);\r\nri = i & MAX_KCQ_IDX;\r\nif (likely(!(kcqe->kcqe_op_flag & KCQE_FLAGS_NEXT))) {\r\nlast_cnt = kcqe_cnt;\r\nlast = i;\r\n}\r\n}\r\ninfo->sw_prod_idx = last;\r\nreturn last_cnt;\r\n}\r\nstatic int cnic_l2_completion(struct cnic_local *cp)\r\n{\r\nu16 hw_cons, sw_cons;\r\nstruct cnic_uio_dev *udev = cp->udev;\r\nunion eth_rx_cqe *cqe, *cqe_ring = (union eth_rx_cqe *)\r\n(udev->l2_ring + (2 * CNIC_PAGE_SIZE));\r\nu32 cmd;\r\nint comp = 0;\r\nif (!test_bit(CNIC_F_BNX2X_CLASS, &cp->dev->flags))\r\nreturn 0;\r\nhw_cons = *cp->rx_cons_ptr;\r\nif ((hw_cons & BNX2X_MAX_RCQ_DESC_CNT) == BNX2X_MAX_RCQ_DESC_CNT)\r\nhw_cons++;\r\nsw_cons = cp->rx_cons;\r\nwhile (sw_cons != hw_cons) {\r\nu8 cqe_fp_flags;\r\ncqe = &cqe_ring[sw_cons & BNX2X_MAX_RCQ_DESC_CNT];\r\ncqe_fp_flags = cqe->fast_path_cqe.type_error_flags;\r\nif (cqe_fp_flags & ETH_FAST_PATH_RX_CQE_TYPE) {\r\ncmd = le32_to_cpu(cqe->ramrod_cqe.conn_and_cmd_data);\r\ncmd >>= COMMON_RAMROD_ETH_RX_CQE_CMD_ID_SHIFT;\r\nif (cmd == RAMROD_CMD_ID_ETH_CLIENT_SETUP ||\r\ncmd == RAMROD_CMD_ID_ETH_HALT)\r\ncomp++;\r\n}\r\nsw_cons = BNX2X_NEXT_RCQE(sw_cons);\r\n}\r\nreturn comp;\r\n}\r\nstatic void cnic_chk_pkt_rings(struct cnic_local *cp)\r\n{\r\nu16 rx_cons, tx_cons;\r\nint comp = 0;\r\nif (!test_bit(CNIC_LCL_FL_RINGS_INITED, &cp->cnic_local_flags))\r\nreturn;\r\nrx_cons = *cp->rx_cons_ptr;\r\ntx_cons = *cp->tx_cons_ptr;\r\nif (cp->tx_cons != tx_cons || cp->rx_cons != rx_cons) {\r\nif (test_bit(CNIC_LCL_FL_L2_WAIT, &cp->cnic_local_flags))\r\ncomp = cnic_l2_completion(cp);\r\ncp->tx_cons = tx_cons;\r\ncp->rx_cons = rx_cons;\r\nif (cp->udev)\r\nuio_event_notify(&cp->udev->cnic_uinfo);\r\n}\r\nif (comp)\r\nclear_bit(CNIC_LCL_FL_L2_WAIT, &cp->cnic_local_flags);\r\n}\r\nstatic u32 cnic_service_bnx2_queues(struct cnic_dev *dev)\r\n{\r\nstruct cnic_local *cp = dev->cnic_priv;\r\nu32 status_idx = (u16) *cp->kcq1.status_idx_ptr;\r\nint kcqe_cnt;\r\nrmb();\r\ncp->kwq_con_idx = *cp->kwq_con_idx_ptr;\r\nwhile ((kcqe_cnt = cnic_get_kcqes(dev, &cp->kcq1))) {\r\nservice_kcqes(dev, kcqe_cnt);\r\nbarrier();\r\nstatus_idx = (u16) *cp->kcq1.status_idx_ptr;\r\nrmb();\r\ncp->kwq_con_idx = *cp->kwq_con_idx_ptr;\r\n}\r\nCNIC_WR16(dev, cp->kcq1.io_addr, cp->kcq1.sw_prod_idx);\r\ncnic_chk_pkt_rings(cp);\r\nreturn status_idx;\r\n}\r\nstatic int cnic_service_bnx2(void *data, void *status_blk)\r\n{\r\nstruct cnic_dev *dev = data;\r\nif (unlikely(!test_bit(CNIC_F_CNIC_UP, &dev->flags))) {\r\nstruct status_block *sblk = status_blk;\r\nreturn sblk->status_idx;\r\n}\r\nreturn cnic_service_bnx2_queues(dev);\r\n}\r\nstatic void cnic_service_bnx2_msix(unsigned long data)\r\n{\r\nstruct cnic_dev *dev = (struct cnic_dev *) data;\r\nstruct cnic_local *cp = dev->cnic_priv;\r\ncp->last_status_idx = cnic_service_bnx2_queues(dev);\r\nCNIC_WR(dev, BNX2_PCICFG_INT_ACK_CMD, cp->int_num |\r\nBNX2_PCICFG_INT_ACK_CMD_INDEX_VALID | cp->last_status_idx);\r\n}\r\nstatic void cnic_doirq(struct cnic_dev *dev)\r\n{\r\nstruct cnic_local *cp = dev->cnic_priv;\r\nif (likely(test_bit(CNIC_F_CNIC_UP, &dev->flags))) {\r\nu16 prod = cp->kcq1.sw_prod_idx & MAX_KCQ_IDX;\r\nprefetch(cp->status_blk.gen);\r\nprefetch(&cp->kcq1.kcq[KCQ_PG(prod)][KCQ_IDX(prod)]);\r\ntasklet_schedule(&cp->cnic_irq_task);\r\n}\r\n}\r\nstatic irqreturn_t cnic_irq(int irq, void *dev_instance)\r\n{\r\nstruct cnic_dev *dev = dev_instance;\r\nstruct cnic_local *cp = dev->cnic_priv;\r\nif (cp->ack_int)\r\ncp->ack_int(dev);\r\ncnic_doirq(dev);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic inline void cnic_ack_bnx2x_int(struct cnic_dev *dev, u8 id, u8 storm,\r\nu16 index, u8 op, u8 update)\r\n{\r\nstruct bnx2x *bp = netdev_priv(dev->netdev);\r\nu32 hc_addr = (HC_REG_COMMAND_REG + BP_PORT(bp) * 32 +\r\nCOMMAND_REG_INT_ACK);\r\nstruct igu_ack_register igu_ack;\r\nigu_ack.status_block_index = index;\r\nigu_ack.sb_id_and_flags =\r\n((id << IGU_ACK_REGISTER_STATUS_BLOCK_ID_SHIFT) |\r\n(storm << IGU_ACK_REGISTER_STORM_ID_SHIFT) |\r\n(update << IGU_ACK_REGISTER_UPDATE_INDEX_SHIFT) |\r\n(op << IGU_ACK_REGISTER_INTERRUPT_MODE_SHIFT));\r\nCNIC_WR(dev, hc_addr, (*(u32 *)&igu_ack));\r\n}\r\nstatic void cnic_ack_igu_sb(struct cnic_dev *dev, u8 igu_sb_id, u8 segment,\r\nu16 index, u8 op, u8 update)\r\n{\r\nstruct igu_regular cmd_data;\r\nu32 igu_addr = BAR_IGU_INTMEM + (IGU_CMD_INT_ACK_BASE + igu_sb_id) * 8;\r\ncmd_data.sb_id_and_flags =\r\n(index << IGU_REGULAR_SB_INDEX_SHIFT) |\r\n(segment << IGU_REGULAR_SEGMENT_ACCESS_SHIFT) |\r\n(update << IGU_REGULAR_BUPDATE_SHIFT) |\r\n(op << IGU_REGULAR_ENABLE_INT_SHIFT);\r\nCNIC_WR(dev, igu_addr, cmd_data.sb_id_and_flags);\r\n}\r\nstatic void cnic_ack_bnx2x_msix(struct cnic_dev *dev)\r\n{\r\nstruct cnic_local *cp = dev->cnic_priv;\r\ncnic_ack_bnx2x_int(dev, cp->bnx2x_igu_sb_id, CSTORM_ID, 0,\r\nIGU_INT_DISABLE, 0);\r\n}\r\nstatic void cnic_ack_bnx2x_e2_msix(struct cnic_dev *dev)\r\n{\r\nstruct cnic_local *cp = dev->cnic_priv;\r\ncnic_ack_igu_sb(dev, cp->bnx2x_igu_sb_id, IGU_SEG_ACCESS_DEF, 0,\r\nIGU_INT_DISABLE, 0);\r\n}\r\nstatic void cnic_arm_bnx2x_msix(struct cnic_dev *dev, u32 idx)\r\n{\r\nstruct cnic_local *cp = dev->cnic_priv;\r\ncnic_ack_bnx2x_int(dev, cp->bnx2x_igu_sb_id, CSTORM_ID, idx,\r\nIGU_INT_ENABLE, 1);\r\n}\r\nstatic void cnic_arm_bnx2x_e2_msix(struct cnic_dev *dev, u32 idx)\r\n{\r\nstruct cnic_local *cp = dev->cnic_priv;\r\ncnic_ack_igu_sb(dev, cp->bnx2x_igu_sb_id, IGU_SEG_ACCESS_DEF, idx,\r\nIGU_INT_ENABLE, 1);\r\n}\r\nstatic u32 cnic_service_bnx2x_kcq(struct cnic_dev *dev, struct kcq_info *info)\r\n{\r\nu32 last_status = *info->status_idx_ptr;\r\nint kcqe_cnt;\r\nrmb();\r\nwhile ((kcqe_cnt = cnic_get_kcqes(dev, info))) {\r\nservice_kcqes(dev, kcqe_cnt);\r\nbarrier();\r\nlast_status = *info->status_idx_ptr;\r\nrmb();\r\n}\r\nreturn last_status;\r\n}\r\nstatic void cnic_service_bnx2x_bh(unsigned long data)\r\n{\r\nstruct cnic_dev *dev = (struct cnic_dev *) data;\r\nstruct cnic_local *cp = dev->cnic_priv;\r\nstruct bnx2x *bp = netdev_priv(dev->netdev);\r\nu32 status_idx, new_status_idx;\r\nif (unlikely(!test_bit(CNIC_F_CNIC_UP, &dev->flags)))\r\nreturn;\r\nwhile (1) {\r\nstatus_idx = cnic_service_bnx2x_kcq(dev, &cp->kcq1);\r\nCNIC_WR16(dev, cp->kcq1.io_addr,\r\ncp->kcq1.sw_prod_idx + MAX_KCQ_IDX);\r\nif (!CNIC_SUPPORTS_FCOE(bp)) {\r\ncp->arm_int(dev, status_idx);\r\nbreak;\r\n}\r\nnew_status_idx = cnic_service_bnx2x_kcq(dev, &cp->kcq2);\r\nif (new_status_idx != status_idx)\r\ncontinue;\r\nCNIC_WR16(dev, cp->kcq2.io_addr, cp->kcq2.sw_prod_idx +\r\nMAX_KCQ_IDX);\r\ncnic_ack_igu_sb(dev, cp->bnx2x_igu_sb_id, IGU_SEG_ACCESS_DEF,\r\nstatus_idx, IGU_INT_ENABLE, 1);\r\nbreak;\r\n}\r\n}\r\nstatic int cnic_service_bnx2x(void *data, void *status_blk)\r\n{\r\nstruct cnic_dev *dev = data;\r\nstruct cnic_local *cp = dev->cnic_priv;\r\nif (!(cp->ethdev->drv_state & CNIC_DRV_STATE_USING_MSIX))\r\ncnic_doirq(dev);\r\ncnic_chk_pkt_rings(cp);\r\nreturn 0;\r\n}\r\nstatic void cnic_ulp_stop_one(struct cnic_local *cp, int if_type)\r\n{\r\nstruct cnic_ulp_ops *ulp_ops;\r\nif (if_type == CNIC_ULP_ISCSI)\r\ncnic_send_nlmsg(cp, ISCSI_KEVENT_IF_DOWN, NULL);\r\nmutex_lock(&cnic_lock);\r\nulp_ops = rcu_dereference_protected(cp->ulp_ops[if_type],\r\nlockdep_is_held(&cnic_lock));\r\nif (!ulp_ops) {\r\nmutex_unlock(&cnic_lock);\r\nreturn;\r\n}\r\nset_bit(ULP_F_CALL_PENDING, &cp->ulp_flags[if_type]);\r\nmutex_unlock(&cnic_lock);\r\nif (test_and_clear_bit(ULP_F_START, &cp->ulp_flags[if_type]))\r\nulp_ops->cnic_stop(cp->ulp_handle[if_type]);\r\nclear_bit(ULP_F_CALL_PENDING, &cp->ulp_flags[if_type]);\r\n}\r\nstatic void cnic_ulp_stop(struct cnic_dev *dev)\r\n{\r\nstruct cnic_local *cp = dev->cnic_priv;\r\nint if_type;\r\nfor (if_type = 0; if_type < MAX_CNIC_ULP_TYPE; if_type++)\r\ncnic_ulp_stop_one(cp, if_type);\r\n}\r\nstatic void cnic_ulp_start(struct cnic_dev *dev)\r\n{\r\nstruct cnic_local *cp = dev->cnic_priv;\r\nint if_type;\r\nfor (if_type = 0; if_type < MAX_CNIC_ULP_TYPE; if_type++) {\r\nstruct cnic_ulp_ops *ulp_ops;\r\nmutex_lock(&cnic_lock);\r\nulp_ops = rcu_dereference_protected(cp->ulp_ops[if_type],\r\nlockdep_is_held(&cnic_lock));\r\nif (!ulp_ops || !ulp_ops->cnic_start) {\r\nmutex_unlock(&cnic_lock);\r\ncontinue;\r\n}\r\nset_bit(ULP_F_CALL_PENDING, &cp->ulp_flags[if_type]);\r\nmutex_unlock(&cnic_lock);\r\nif (!test_and_set_bit(ULP_F_START, &cp->ulp_flags[if_type]))\r\nulp_ops->cnic_start(cp->ulp_handle[if_type]);\r\nclear_bit(ULP_F_CALL_PENDING, &cp->ulp_flags[if_type]);\r\n}\r\n}\r\nstatic int cnic_copy_ulp_stats(struct cnic_dev *dev, int ulp_type)\r\n{\r\nstruct cnic_local *cp = dev->cnic_priv;\r\nstruct cnic_ulp_ops *ulp_ops;\r\nint rc;\r\nmutex_lock(&cnic_lock);\r\nulp_ops = rcu_dereference_protected(cp->ulp_ops[ulp_type],\r\nlockdep_is_held(&cnic_lock));\r\nif (ulp_ops && ulp_ops->cnic_get_stats)\r\nrc = ulp_ops->cnic_get_stats(cp->ulp_handle[ulp_type]);\r\nelse\r\nrc = -ENODEV;\r\nmutex_unlock(&cnic_lock);\r\nreturn rc;\r\n}\r\nstatic int cnic_ctl(void *data, struct cnic_ctl_info *info)\r\n{\r\nstruct cnic_dev *dev = data;\r\nint ulp_type = CNIC_ULP_ISCSI;\r\nswitch (info->cmd) {\r\ncase CNIC_CTL_STOP_CMD:\r\ncnic_hold(dev);\r\ncnic_ulp_stop(dev);\r\ncnic_stop_hw(dev);\r\ncnic_put(dev);\r\nbreak;\r\ncase CNIC_CTL_START_CMD:\r\ncnic_hold(dev);\r\nif (!cnic_start_hw(dev))\r\ncnic_ulp_start(dev);\r\ncnic_put(dev);\r\nbreak;\r\ncase CNIC_CTL_STOP_ISCSI_CMD: {\r\nstruct cnic_local *cp = dev->cnic_priv;\r\nset_bit(CNIC_LCL_FL_STOP_ISCSI, &cp->cnic_local_flags);\r\nqueue_delayed_work(cnic_wq, &cp->delete_task, 0);\r\nbreak;\r\n}\r\ncase CNIC_CTL_COMPLETION_CMD: {\r\nstruct cnic_ctl_completion *comp = &info->data.comp;\r\nu32 cid = BNX2X_SW_CID(comp->cid);\r\nu32 l5_cid;\r\nstruct cnic_local *cp = dev->cnic_priv;\r\nif (!test_bit(CNIC_F_CNIC_UP, &dev->flags))\r\nbreak;\r\nif (cnic_get_l5_cid(cp, cid, &l5_cid) == 0) {\r\nstruct cnic_context *ctx = &cp->ctx_tbl[l5_cid];\r\nif (unlikely(comp->error)) {\r\nset_bit(CTX_FL_CID_ERROR, &ctx->ctx_flags);\r\nnetdev_err(dev->netdev,\r\n"CID %x CFC delete comp error %x\n",\r\ncid, comp->error);\r\n}\r\nctx->wait_cond = 1;\r\nwake_up(&ctx->waitq);\r\n}\r\nbreak;\r\n}\r\ncase CNIC_CTL_FCOE_STATS_GET_CMD:\r\nulp_type = CNIC_ULP_FCOE;\r\ncase CNIC_CTL_ISCSI_STATS_GET_CMD:\r\ncnic_hold(dev);\r\ncnic_copy_ulp_stats(dev, ulp_type);\r\ncnic_put(dev);\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic void cnic_ulp_init(struct cnic_dev *dev)\r\n{\r\nint i;\r\nstruct cnic_local *cp = dev->cnic_priv;\r\nfor (i = 0; i < MAX_CNIC_ULP_TYPE_EXT; i++) {\r\nstruct cnic_ulp_ops *ulp_ops;\r\nmutex_lock(&cnic_lock);\r\nulp_ops = cnic_ulp_tbl_prot(i);\r\nif (!ulp_ops || !ulp_ops->cnic_init) {\r\nmutex_unlock(&cnic_lock);\r\ncontinue;\r\n}\r\nulp_get(ulp_ops);\r\nmutex_unlock(&cnic_lock);\r\nif (!test_and_set_bit(ULP_F_INIT, &cp->ulp_flags[i]))\r\nulp_ops->cnic_init(dev);\r\nulp_put(ulp_ops);\r\n}\r\n}\r\nstatic void cnic_ulp_exit(struct cnic_dev *dev)\r\n{\r\nint i;\r\nstruct cnic_local *cp = dev->cnic_priv;\r\nfor (i = 0; i < MAX_CNIC_ULP_TYPE_EXT; i++) {\r\nstruct cnic_ulp_ops *ulp_ops;\r\nmutex_lock(&cnic_lock);\r\nulp_ops = cnic_ulp_tbl_prot(i);\r\nif (!ulp_ops || !ulp_ops->cnic_exit) {\r\nmutex_unlock(&cnic_lock);\r\ncontinue;\r\n}\r\nulp_get(ulp_ops);\r\nmutex_unlock(&cnic_lock);\r\nif (test_and_clear_bit(ULP_F_INIT, &cp->ulp_flags[i]))\r\nulp_ops->cnic_exit(dev);\r\nulp_put(ulp_ops);\r\n}\r\n}\r\nstatic int cnic_cm_offload_pg(struct cnic_sock *csk)\r\n{\r\nstruct cnic_dev *dev = csk->dev;\r\nstruct l4_kwq_offload_pg *l4kwqe;\r\nstruct kwqe *wqes[1];\r\nl4kwqe = (struct l4_kwq_offload_pg *) &csk->kwqe1;\r\nmemset(l4kwqe, 0, sizeof(*l4kwqe));\r\nwqes[0] = (struct kwqe *) l4kwqe;\r\nl4kwqe->op_code = L4_KWQE_OPCODE_VALUE_OFFLOAD_PG;\r\nl4kwqe->flags =\r\nL4_LAYER_CODE << L4_KWQ_OFFLOAD_PG_LAYER_CODE_SHIFT;\r\nl4kwqe->l2hdr_nbytes = ETH_HLEN;\r\nl4kwqe->da0 = csk->ha[0];\r\nl4kwqe->da1 = csk->ha[1];\r\nl4kwqe->da2 = csk->ha[2];\r\nl4kwqe->da3 = csk->ha[3];\r\nl4kwqe->da4 = csk->ha[4];\r\nl4kwqe->da5 = csk->ha[5];\r\nl4kwqe->sa0 = dev->mac_addr[0];\r\nl4kwqe->sa1 = dev->mac_addr[1];\r\nl4kwqe->sa2 = dev->mac_addr[2];\r\nl4kwqe->sa3 = dev->mac_addr[3];\r\nl4kwqe->sa4 = dev->mac_addr[4];\r\nl4kwqe->sa5 = dev->mac_addr[5];\r\nl4kwqe->etype = ETH_P_IP;\r\nl4kwqe->ipid_start = DEF_IPID_START;\r\nl4kwqe->host_opaque = csk->l5_cid;\r\nif (csk->vlan_id) {\r\nl4kwqe->pg_flags |= L4_KWQ_OFFLOAD_PG_VLAN_TAGGING;\r\nl4kwqe->vlan_tag = csk->vlan_id;\r\nl4kwqe->l2hdr_nbytes += 4;\r\n}\r\nreturn dev->submit_kwqes(dev, wqes, 1);\r\n}\r\nstatic int cnic_cm_update_pg(struct cnic_sock *csk)\r\n{\r\nstruct cnic_dev *dev = csk->dev;\r\nstruct l4_kwq_update_pg *l4kwqe;\r\nstruct kwqe *wqes[1];\r\nl4kwqe = (struct l4_kwq_update_pg *) &csk->kwqe1;\r\nmemset(l4kwqe, 0, sizeof(*l4kwqe));\r\nwqes[0] = (struct kwqe *) l4kwqe;\r\nl4kwqe->opcode = L4_KWQE_OPCODE_VALUE_UPDATE_PG;\r\nl4kwqe->flags =\r\nL4_LAYER_CODE << L4_KWQ_UPDATE_PG_LAYER_CODE_SHIFT;\r\nl4kwqe->pg_cid = csk->pg_cid;\r\nl4kwqe->da0 = csk->ha[0];\r\nl4kwqe->da1 = csk->ha[1];\r\nl4kwqe->da2 = csk->ha[2];\r\nl4kwqe->da3 = csk->ha[3];\r\nl4kwqe->da4 = csk->ha[4];\r\nl4kwqe->da5 = csk->ha[5];\r\nl4kwqe->pg_host_opaque = csk->l5_cid;\r\nl4kwqe->pg_valids = L4_KWQ_UPDATE_PG_VALIDS_DA;\r\nreturn dev->submit_kwqes(dev, wqes, 1);\r\n}\r\nstatic int cnic_cm_upload_pg(struct cnic_sock *csk)\r\n{\r\nstruct cnic_dev *dev = csk->dev;\r\nstruct l4_kwq_upload *l4kwqe;\r\nstruct kwqe *wqes[1];\r\nl4kwqe = (struct l4_kwq_upload *) &csk->kwqe1;\r\nmemset(l4kwqe, 0, sizeof(*l4kwqe));\r\nwqes[0] = (struct kwqe *) l4kwqe;\r\nl4kwqe->opcode = L4_KWQE_OPCODE_VALUE_UPLOAD_PG;\r\nl4kwqe->flags =\r\nL4_LAYER_CODE << L4_KWQ_UPLOAD_LAYER_CODE_SHIFT;\r\nl4kwqe->cid = csk->pg_cid;\r\nreturn dev->submit_kwqes(dev, wqes, 1);\r\n}\r\nstatic int cnic_cm_conn_req(struct cnic_sock *csk)\r\n{\r\nstruct cnic_dev *dev = csk->dev;\r\nstruct l4_kwq_connect_req1 *l4kwqe1;\r\nstruct l4_kwq_connect_req2 *l4kwqe2;\r\nstruct l4_kwq_connect_req3 *l4kwqe3;\r\nstruct kwqe *wqes[3];\r\nu8 tcp_flags = 0;\r\nint num_wqes = 2;\r\nl4kwqe1 = (struct l4_kwq_connect_req1 *) &csk->kwqe1;\r\nl4kwqe2 = (struct l4_kwq_connect_req2 *) &csk->kwqe2;\r\nl4kwqe3 = (struct l4_kwq_connect_req3 *) &csk->kwqe3;\r\nmemset(l4kwqe1, 0, sizeof(*l4kwqe1));\r\nmemset(l4kwqe2, 0, sizeof(*l4kwqe2));\r\nmemset(l4kwqe3, 0, sizeof(*l4kwqe3));\r\nl4kwqe3->op_code = L4_KWQE_OPCODE_VALUE_CONNECT3;\r\nl4kwqe3->flags =\r\nL4_LAYER_CODE << L4_KWQ_CONNECT_REQ3_LAYER_CODE_SHIFT;\r\nl4kwqe3->ka_timeout = csk->ka_timeout;\r\nl4kwqe3->ka_interval = csk->ka_interval;\r\nl4kwqe3->ka_max_probe_count = csk->ka_max_probe_count;\r\nl4kwqe3->tos = csk->tos;\r\nl4kwqe3->ttl = csk->ttl;\r\nl4kwqe3->snd_seq_scale = csk->snd_seq_scale;\r\nl4kwqe3->pmtu = csk->mtu;\r\nl4kwqe3->rcv_buf = csk->rcv_buf;\r\nl4kwqe3->snd_buf = csk->snd_buf;\r\nl4kwqe3->seed = csk->seed;\r\nwqes[0] = (struct kwqe *) l4kwqe1;\r\nif (test_bit(SK_F_IPV6, &csk->flags)) {\r\nwqes[1] = (struct kwqe *) l4kwqe2;\r\nwqes[2] = (struct kwqe *) l4kwqe3;\r\nnum_wqes = 3;\r\nl4kwqe1->conn_flags = L4_KWQ_CONNECT_REQ1_IP_V6;\r\nl4kwqe2->op_code = L4_KWQE_OPCODE_VALUE_CONNECT2;\r\nl4kwqe2->flags =\r\nL4_KWQ_CONNECT_REQ2_LINKED_WITH_NEXT |\r\nL4_LAYER_CODE << L4_KWQ_CONNECT_REQ2_LAYER_CODE_SHIFT;\r\nl4kwqe2->src_ip_v6_2 = be32_to_cpu(csk->src_ip[1]);\r\nl4kwqe2->src_ip_v6_3 = be32_to_cpu(csk->src_ip[2]);\r\nl4kwqe2->src_ip_v6_4 = be32_to_cpu(csk->src_ip[3]);\r\nl4kwqe2->dst_ip_v6_2 = be32_to_cpu(csk->dst_ip[1]);\r\nl4kwqe2->dst_ip_v6_3 = be32_to_cpu(csk->dst_ip[2]);\r\nl4kwqe2->dst_ip_v6_4 = be32_to_cpu(csk->dst_ip[3]);\r\nl4kwqe3->mss = l4kwqe3->pmtu - sizeof(struct ipv6hdr) -\r\nsizeof(struct tcphdr);\r\n} else {\r\nwqes[1] = (struct kwqe *) l4kwqe3;\r\nl4kwqe3->mss = l4kwqe3->pmtu - sizeof(struct iphdr) -\r\nsizeof(struct tcphdr);\r\n}\r\nl4kwqe1->op_code = L4_KWQE_OPCODE_VALUE_CONNECT1;\r\nl4kwqe1->flags =\r\n(L4_LAYER_CODE << L4_KWQ_CONNECT_REQ1_LAYER_CODE_SHIFT) |\r\nL4_KWQ_CONNECT_REQ3_LINKED_WITH_NEXT;\r\nl4kwqe1->cid = csk->cid;\r\nl4kwqe1->pg_cid = csk->pg_cid;\r\nl4kwqe1->src_ip = be32_to_cpu(csk->src_ip[0]);\r\nl4kwqe1->dst_ip = be32_to_cpu(csk->dst_ip[0]);\r\nl4kwqe1->src_port = be16_to_cpu(csk->src_port);\r\nl4kwqe1->dst_port = be16_to_cpu(csk->dst_port);\r\nif (csk->tcp_flags & SK_TCP_NO_DELAY_ACK)\r\ntcp_flags |= L4_KWQ_CONNECT_REQ1_NO_DELAY_ACK;\r\nif (csk->tcp_flags & SK_TCP_KEEP_ALIVE)\r\ntcp_flags |= L4_KWQ_CONNECT_REQ1_KEEP_ALIVE;\r\nif (csk->tcp_flags & SK_TCP_NAGLE)\r\ntcp_flags |= L4_KWQ_CONNECT_REQ1_NAGLE_ENABLE;\r\nif (csk->tcp_flags & SK_TCP_TIMESTAMP)\r\ntcp_flags |= L4_KWQ_CONNECT_REQ1_TIME_STAMP;\r\nif (csk->tcp_flags & SK_TCP_SACK)\r\ntcp_flags |= L4_KWQ_CONNECT_REQ1_SACK;\r\nif (csk->tcp_flags & SK_TCP_SEG_SCALING)\r\ntcp_flags |= L4_KWQ_CONNECT_REQ1_SEG_SCALING;\r\nl4kwqe1->tcp_flags = tcp_flags;\r\nreturn dev->submit_kwqes(dev, wqes, num_wqes);\r\n}\r\nstatic int cnic_cm_close_req(struct cnic_sock *csk)\r\n{\r\nstruct cnic_dev *dev = csk->dev;\r\nstruct l4_kwq_close_req *l4kwqe;\r\nstruct kwqe *wqes[1];\r\nl4kwqe = (struct l4_kwq_close_req *) &csk->kwqe2;\r\nmemset(l4kwqe, 0, sizeof(*l4kwqe));\r\nwqes[0] = (struct kwqe *) l4kwqe;\r\nl4kwqe->op_code = L4_KWQE_OPCODE_VALUE_CLOSE;\r\nl4kwqe->flags = L4_LAYER_CODE << L4_KWQ_CLOSE_REQ_LAYER_CODE_SHIFT;\r\nl4kwqe->cid = csk->cid;\r\nreturn dev->submit_kwqes(dev, wqes, 1);\r\n}\r\nstatic int cnic_cm_abort_req(struct cnic_sock *csk)\r\n{\r\nstruct cnic_dev *dev = csk->dev;\r\nstruct l4_kwq_reset_req *l4kwqe;\r\nstruct kwqe *wqes[1];\r\nl4kwqe = (struct l4_kwq_reset_req *) &csk->kwqe2;\r\nmemset(l4kwqe, 0, sizeof(*l4kwqe));\r\nwqes[0] = (struct kwqe *) l4kwqe;\r\nl4kwqe->op_code = L4_KWQE_OPCODE_VALUE_RESET;\r\nl4kwqe->flags = L4_LAYER_CODE << L4_KWQ_RESET_REQ_LAYER_CODE_SHIFT;\r\nl4kwqe->cid = csk->cid;\r\nreturn dev->submit_kwqes(dev, wqes, 1);\r\n}\r\nstatic int cnic_cm_create(struct cnic_dev *dev, int ulp_type, u32 cid,\r\nu32 l5_cid, struct cnic_sock **csk, void *context)\r\n{\r\nstruct cnic_local *cp = dev->cnic_priv;\r\nstruct cnic_sock *csk1;\r\nif (l5_cid >= MAX_CM_SK_TBL_SZ)\r\nreturn -EINVAL;\r\nif (cp->ctx_tbl) {\r\nstruct cnic_context *ctx = &cp->ctx_tbl[l5_cid];\r\nif (test_bit(CTX_FL_OFFLD_START, &ctx->ctx_flags))\r\nreturn -EAGAIN;\r\n}\r\ncsk1 = &cp->csk_tbl[l5_cid];\r\nif (atomic_read(&csk1->ref_count))\r\nreturn -EAGAIN;\r\nif (test_and_set_bit(SK_F_INUSE, &csk1->flags))\r\nreturn -EBUSY;\r\ncsk1->dev = dev;\r\ncsk1->cid = cid;\r\ncsk1->l5_cid = l5_cid;\r\ncsk1->ulp_type = ulp_type;\r\ncsk1->context = context;\r\ncsk1->ka_timeout = DEF_KA_TIMEOUT;\r\ncsk1->ka_interval = DEF_KA_INTERVAL;\r\ncsk1->ka_max_probe_count = DEF_KA_MAX_PROBE_COUNT;\r\ncsk1->tos = DEF_TOS;\r\ncsk1->ttl = DEF_TTL;\r\ncsk1->snd_seq_scale = DEF_SND_SEQ_SCALE;\r\ncsk1->rcv_buf = DEF_RCV_BUF;\r\ncsk1->snd_buf = DEF_SND_BUF;\r\ncsk1->seed = DEF_SEED;\r\ncsk1->tcp_flags = 0;\r\n*csk = csk1;\r\nreturn 0;\r\n}\r\nstatic void cnic_cm_cleanup(struct cnic_sock *csk)\r\n{\r\nif (csk->src_port) {\r\nstruct cnic_dev *dev = csk->dev;\r\nstruct cnic_local *cp = dev->cnic_priv;\r\ncnic_free_id(&cp->csk_port_tbl, be16_to_cpu(csk->src_port));\r\ncsk->src_port = 0;\r\n}\r\n}\r\nstatic void cnic_close_conn(struct cnic_sock *csk)\r\n{\r\nif (test_bit(SK_F_PG_OFFLD_COMPLETE, &csk->flags)) {\r\ncnic_cm_upload_pg(csk);\r\nclear_bit(SK_F_PG_OFFLD_COMPLETE, &csk->flags);\r\n}\r\ncnic_cm_cleanup(csk);\r\n}\r\nstatic int cnic_cm_destroy(struct cnic_sock *csk)\r\n{\r\nif (!cnic_in_use(csk))\r\nreturn -EINVAL;\r\ncsk_hold(csk);\r\nclear_bit(SK_F_INUSE, &csk->flags);\r\nsmp_mb__after_atomic();\r\nwhile (atomic_read(&csk->ref_count) != 1)\r\nmsleep(1);\r\ncnic_cm_cleanup(csk);\r\ncsk->flags = 0;\r\ncsk_put(csk);\r\nreturn 0;\r\n}\r\nstatic inline u16 cnic_get_vlan(struct net_device *dev,\r\nstruct net_device **vlan_dev)\r\n{\r\nif (dev->priv_flags & IFF_802_1Q_VLAN) {\r\n*vlan_dev = vlan_dev_real_dev(dev);\r\nreturn vlan_dev_vlan_id(dev);\r\n}\r\n*vlan_dev = dev;\r\nreturn 0;\r\n}\r\nstatic int cnic_get_v4_route(struct sockaddr_in *dst_addr,\r\nstruct dst_entry **dst)\r\n{\r\n#if defined(CONFIG_INET)\r\nstruct rtable *rt;\r\nrt = ip_route_output(&init_net, dst_addr->sin_addr.s_addr, 0, 0, 0);\r\nif (!IS_ERR(rt)) {\r\n*dst = &rt->dst;\r\nreturn 0;\r\n}\r\nreturn PTR_ERR(rt);\r\n#else\r\nreturn -ENETUNREACH;\r\n#endif\r\n}\r\nstatic int cnic_get_v6_route(struct sockaddr_in6 *dst_addr,\r\nstruct dst_entry **dst)\r\n{\r\n#if IS_ENABLED(CONFIG_IPV6)\r\nstruct flowi6 fl6;\r\nmemset(&fl6, 0, sizeof(fl6));\r\nfl6.daddr = dst_addr->sin6_addr;\r\nif (ipv6_addr_type(&fl6.daddr) & IPV6_ADDR_LINKLOCAL)\r\nfl6.flowi6_oif = dst_addr->sin6_scope_id;\r\n*dst = ip6_route_output(&init_net, NULL, &fl6);\r\nif ((*dst)->error) {\r\ndst_release(*dst);\r\n*dst = NULL;\r\nreturn -ENETUNREACH;\r\n} else\r\nreturn 0;\r\n#endif\r\nreturn -ENETUNREACH;\r\n}\r\nstatic struct cnic_dev *cnic_cm_select_dev(struct sockaddr_in *dst_addr,\r\nint ulp_type)\r\n{\r\nstruct cnic_dev *dev = NULL;\r\nstruct dst_entry *dst;\r\nstruct net_device *netdev = NULL;\r\nint err = -ENETUNREACH;\r\nif (dst_addr->sin_family == AF_INET)\r\nerr = cnic_get_v4_route(dst_addr, &dst);\r\nelse if (dst_addr->sin_family == AF_INET6) {\r\nstruct sockaddr_in6 *dst_addr6 =\r\n(struct sockaddr_in6 *) dst_addr;\r\nerr = cnic_get_v6_route(dst_addr6, &dst);\r\n} else\r\nreturn NULL;\r\nif (err)\r\nreturn NULL;\r\nif (!dst->dev)\r\ngoto done;\r\ncnic_get_vlan(dst->dev, &netdev);\r\ndev = cnic_from_netdev(netdev);\r\ndone:\r\ndst_release(dst);\r\nif (dev)\r\ncnic_put(dev);\r\nreturn dev;\r\n}\r\nstatic int cnic_resolve_addr(struct cnic_sock *csk, struct cnic_sockaddr *saddr)\r\n{\r\nstruct cnic_dev *dev = csk->dev;\r\nstruct cnic_local *cp = dev->cnic_priv;\r\nreturn cnic_send_nlmsg(cp, ISCSI_KEVENT_PATH_REQ, csk);\r\n}\r\nstatic int cnic_get_route(struct cnic_sock *csk, struct cnic_sockaddr *saddr)\r\n{\r\nstruct cnic_dev *dev = csk->dev;\r\nstruct cnic_local *cp = dev->cnic_priv;\r\nint is_v6, rc = 0;\r\nstruct dst_entry *dst = NULL;\r\nstruct net_device *realdev;\r\n__be16 local_port;\r\nu32 port_id;\r\nif (saddr->local.v6.sin6_family == AF_INET6 &&\r\nsaddr->remote.v6.sin6_family == AF_INET6)\r\nis_v6 = 1;\r\nelse if (saddr->local.v4.sin_family == AF_INET &&\r\nsaddr->remote.v4.sin_family == AF_INET)\r\nis_v6 = 0;\r\nelse\r\nreturn -EINVAL;\r\nclear_bit(SK_F_IPV6, &csk->flags);\r\nif (is_v6) {\r\nset_bit(SK_F_IPV6, &csk->flags);\r\ncnic_get_v6_route(&saddr->remote.v6, &dst);\r\nmemcpy(&csk->dst_ip[0], &saddr->remote.v6.sin6_addr,\r\nsizeof(struct in6_addr));\r\ncsk->dst_port = saddr->remote.v6.sin6_port;\r\nlocal_port = saddr->local.v6.sin6_port;\r\n} else {\r\ncnic_get_v4_route(&saddr->remote.v4, &dst);\r\ncsk->dst_ip[0] = saddr->remote.v4.sin_addr.s_addr;\r\ncsk->dst_port = saddr->remote.v4.sin_port;\r\nlocal_port = saddr->local.v4.sin_port;\r\n}\r\ncsk->vlan_id = 0;\r\ncsk->mtu = dev->netdev->mtu;\r\nif (dst && dst->dev) {\r\nu16 vlan = cnic_get_vlan(dst->dev, &realdev);\r\nif (realdev == dev->netdev) {\r\ncsk->vlan_id = vlan;\r\ncsk->mtu = dst_mtu(dst);\r\n}\r\n}\r\nport_id = be16_to_cpu(local_port);\r\nif (port_id >= CNIC_LOCAL_PORT_MIN &&\r\nport_id < CNIC_LOCAL_PORT_MAX) {\r\nif (cnic_alloc_id(&cp->csk_port_tbl, port_id))\r\nport_id = 0;\r\n} else\r\nport_id = 0;\r\nif (!port_id) {\r\nport_id = cnic_alloc_new_id(&cp->csk_port_tbl);\r\nif (port_id == -1) {\r\nrc = -ENOMEM;\r\ngoto err_out;\r\n}\r\nlocal_port = cpu_to_be16(port_id);\r\n}\r\ncsk->src_port = local_port;\r\nerr_out:\r\ndst_release(dst);\r\nreturn rc;\r\n}\r\nstatic void cnic_init_csk_state(struct cnic_sock *csk)\r\n{\r\ncsk->state = 0;\r\nclear_bit(SK_F_OFFLD_SCHED, &csk->flags);\r\nclear_bit(SK_F_CLOSING, &csk->flags);\r\n}\r\nstatic int cnic_cm_connect(struct cnic_sock *csk, struct cnic_sockaddr *saddr)\r\n{\r\nstruct cnic_local *cp = csk->dev->cnic_priv;\r\nint err = 0;\r\nif (cp->ethdev->drv_state & CNIC_DRV_STATE_NO_ISCSI)\r\nreturn -EOPNOTSUPP;\r\nif (!cnic_in_use(csk))\r\nreturn -EINVAL;\r\nif (test_and_set_bit(SK_F_CONNECT_START, &csk->flags))\r\nreturn -EINVAL;\r\ncnic_init_csk_state(csk);\r\nerr = cnic_get_route(csk, saddr);\r\nif (err)\r\ngoto err_out;\r\nerr = cnic_resolve_addr(csk, saddr);\r\nif (!err)\r\nreturn 0;\r\nerr_out:\r\nclear_bit(SK_F_CONNECT_START, &csk->flags);\r\nreturn err;\r\n}\r\nstatic int cnic_cm_abort(struct cnic_sock *csk)\r\n{\r\nstruct cnic_local *cp = csk->dev->cnic_priv;\r\nu32 opcode = L4_KCQE_OPCODE_VALUE_RESET_COMP;\r\nif (!cnic_in_use(csk))\r\nreturn -EINVAL;\r\nif (cnic_abort_prep(csk))\r\nreturn cnic_cm_abort_req(csk);\r\ncp->close_conn(csk, opcode);\r\nif (csk->state != opcode) {\r\nwhile (test_bit(SK_F_PG_OFFLD_COMPLETE, &csk->flags))\r\nmsleep(1);\r\nreturn -EALREADY;\r\n}\r\nreturn 0;\r\n}\r\nstatic int cnic_cm_close(struct cnic_sock *csk)\r\n{\r\nif (!cnic_in_use(csk))\r\nreturn -EINVAL;\r\nif (cnic_close_prep(csk)) {\r\ncsk->state = L4_KCQE_OPCODE_VALUE_CLOSE_COMP;\r\nreturn cnic_cm_close_req(csk);\r\n} else {\r\nwhile (test_bit(SK_F_PG_OFFLD_COMPLETE, &csk->flags))\r\nmsleep(1);\r\nreturn -EALREADY;\r\n}\r\nreturn 0;\r\n}\r\nstatic void cnic_cm_upcall(struct cnic_local *cp, struct cnic_sock *csk,\r\nu8 opcode)\r\n{\r\nstruct cnic_ulp_ops *ulp_ops;\r\nint ulp_type = csk->ulp_type;\r\nrcu_read_lock();\r\nulp_ops = rcu_dereference(cp->ulp_ops[ulp_type]);\r\nif (ulp_ops) {\r\nif (opcode == L4_KCQE_OPCODE_VALUE_CONNECT_COMPLETE)\r\nulp_ops->cm_connect_complete(csk);\r\nelse if (opcode == L4_KCQE_OPCODE_VALUE_CLOSE_COMP)\r\nulp_ops->cm_close_complete(csk);\r\nelse if (opcode == L4_KCQE_OPCODE_VALUE_RESET_RECEIVED)\r\nulp_ops->cm_remote_abort(csk);\r\nelse if (opcode == L4_KCQE_OPCODE_VALUE_RESET_COMP)\r\nulp_ops->cm_abort_complete(csk);\r\nelse if (opcode == L4_KCQE_OPCODE_VALUE_CLOSE_RECEIVED)\r\nulp_ops->cm_remote_close(csk);\r\n}\r\nrcu_read_unlock();\r\n}\r\nstatic int cnic_cm_set_pg(struct cnic_sock *csk)\r\n{\r\nif (cnic_offld_prep(csk)) {\r\nif (test_bit(SK_F_PG_OFFLD_COMPLETE, &csk->flags))\r\ncnic_cm_update_pg(csk);\r\nelse\r\ncnic_cm_offload_pg(csk);\r\n}\r\nreturn 0;\r\n}\r\nstatic void cnic_cm_process_offld_pg(struct cnic_dev *dev, struct l4_kcq *kcqe)\r\n{\r\nstruct cnic_local *cp = dev->cnic_priv;\r\nu32 l5_cid = kcqe->pg_host_opaque;\r\nu8 opcode = kcqe->op_code;\r\nstruct cnic_sock *csk = &cp->csk_tbl[l5_cid];\r\ncsk_hold(csk);\r\nif (!cnic_in_use(csk))\r\ngoto done;\r\nif (opcode == L4_KCQE_OPCODE_VALUE_UPDATE_PG) {\r\nclear_bit(SK_F_OFFLD_SCHED, &csk->flags);\r\ngoto done;\r\n}\r\nif (kcqe->status == L4_KCQE_COMPLETION_STATUS_CTX_ALLOC_FAIL) {\r\nclear_bit(SK_F_OFFLD_SCHED, &csk->flags);\r\ncnic_cm_upcall(cp, csk,\r\nL4_KCQE_OPCODE_VALUE_CONNECT_COMPLETE);\r\ngoto done;\r\n}\r\ncsk->pg_cid = kcqe->pg_cid;\r\nset_bit(SK_F_PG_OFFLD_COMPLETE, &csk->flags);\r\ncnic_cm_conn_req(csk);\r\ndone:\r\ncsk_put(csk);\r\n}\r\nstatic void cnic_process_fcoe_term_conn(struct cnic_dev *dev, struct kcqe *kcqe)\r\n{\r\nstruct cnic_local *cp = dev->cnic_priv;\r\nstruct fcoe_kcqe *fc_kcqe = (struct fcoe_kcqe *) kcqe;\r\nu32 l5_cid = fc_kcqe->fcoe_conn_id + BNX2X_FCOE_L5_CID_BASE;\r\nstruct cnic_context *ctx = &cp->ctx_tbl[l5_cid];\r\nctx->timestamp = jiffies;\r\nctx->wait_cond = 1;\r\nwake_up(&ctx->waitq);\r\n}\r\nstatic void cnic_cm_process_kcqe(struct cnic_dev *dev, struct kcqe *kcqe)\r\n{\r\nstruct cnic_local *cp = dev->cnic_priv;\r\nstruct l4_kcq *l4kcqe = (struct l4_kcq *) kcqe;\r\nu8 opcode = l4kcqe->op_code;\r\nu32 l5_cid;\r\nstruct cnic_sock *csk;\r\nif (opcode == FCOE_RAMROD_CMD_ID_TERMINATE_CONN) {\r\ncnic_process_fcoe_term_conn(dev, kcqe);\r\nreturn;\r\n}\r\nif (opcode == L4_KCQE_OPCODE_VALUE_OFFLOAD_PG ||\r\nopcode == L4_KCQE_OPCODE_VALUE_UPDATE_PG) {\r\ncnic_cm_process_offld_pg(dev, l4kcqe);\r\nreturn;\r\n}\r\nl5_cid = l4kcqe->conn_id;\r\nif (opcode & 0x80)\r\nl5_cid = l4kcqe->cid;\r\nif (l5_cid >= MAX_CM_SK_TBL_SZ)\r\nreturn;\r\ncsk = &cp->csk_tbl[l5_cid];\r\ncsk_hold(csk);\r\nif (!cnic_in_use(csk)) {\r\ncsk_put(csk);\r\nreturn;\r\n}\r\nswitch (opcode) {\r\ncase L5CM_RAMROD_CMD_ID_TCP_CONNECT:\r\nif (l4kcqe->status != 0) {\r\nclear_bit(SK_F_OFFLD_SCHED, &csk->flags);\r\ncnic_cm_upcall(cp, csk,\r\nL4_KCQE_OPCODE_VALUE_CONNECT_COMPLETE);\r\n}\r\nbreak;\r\ncase L4_KCQE_OPCODE_VALUE_CONNECT_COMPLETE:\r\nif (l4kcqe->status == 0)\r\nset_bit(SK_F_OFFLD_COMPLETE, &csk->flags);\r\nelse if (l4kcqe->status ==\r\nL4_KCQE_COMPLETION_STATUS_PARITY_ERROR)\r\nset_bit(SK_F_HW_ERR, &csk->flags);\r\nsmp_mb__before_atomic();\r\nclear_bit(SK_F_OFFLD_SCHED, &csk->flags);\r\ncnic_cm_upcall(cp, csk, opcode);\r\nbreak;\r\ncase L5CM_RAMROD_CMD_ID_CLOSE: {\r\nstruct iscsi_kcqe *l5kcqe = (struct iscsi_kcqe *) kcqe;\r\nif (l4kcqe->status != 0 || l5kcqe->completion_status != 0) {\r\nnetdev_warn(dev->netdev, "RAMROD CLOSE compl with status 0x%x completion status 0x%x\n",\r\nl4kcqe->status, l5kcqe->completion_status);\r\nopcode = L4_KCQE_OPCODE_VALUE_CLOSE_COMP;\r\n} else {\r\nbreak;\r\n}\r\n}\r\ncase L4_KCQE_OPCODE_VALUE_RESET_RECEIVED:\r\ncase L4_KCQE_OPCODE_VALUE_CLOSE_COMP:\r\ncase L4_KCQE_OPCODE_VALUE_RESET_COMP:\r\ncase L5CM_RAMROD_CMD_ID_SEARCHER_DELETE:\r\ncase L5CM_RAMROD_CMD_ID_TERMINATE_OFFLOAD:\r\nif (l4kcqe->status == L4_KCQE_COMPLETION_STATUS_PARITY_ERROR)\r\nset_bit(SK_F_HW_ERR, &csk->flags);\r\ncp->close_conn(csk, opcode);\r\nbreak;\r\ncase L4_KCQE_OPCODE_VALUE_CLOSE_RECEIVED:\r\nif (test_bit(CNIC_F_BNX2X_CLASS, &dev->flags) &&\r\n!test_bit(SK_F_OFFLD_COMPLETE, &csk->flags) &&\r\ncsk->state == L4_KCQE_OPCODE_VALUE_CLOSE_COMP)\r\ncp->close_conn(csk, L4_KCQE_OPCODE_VALUE_RESET_COMP);\r\nelse\r\ncnic_cm_upcall(cp, csk, opcode);\r\nbreak;\r\n}\r\ncsk_put(csk);\r\n}\r\nstatic void cnic_cm_indicate_kcqe(void *data, struct kcqe *kcqe[], u32 num)\r\n{\r\nstruct cnic_dev *dev = data;\r\nint i;\r\nfor (i = 0; i < num; i++)\r\ncnic_cm_process_kcqe(dev, kcqe[i]);\r\n}\r\nstatic void cnic_cm_free_mem(struct cnic_dev *dev)\r\n{\r\nstruct cnic_local *cp = dev->cnic_priv;\r\nkfree(cp->csk_tbl);\r\ncp->csk_tbl = NULL;\r\ncnic_free_id_tbl(&cp->csk_port_tbl);\r\n}\r\nstatic int cnic_cm_alloc_mem(struct cnic_dev *dev)\r\n{\r\nstruct cnic_local *cp = dev->cnic_priv;\r\nu32 port_id;\r\ncp->csk_tbl = kzalloc(sizeof(struct cnic_sock) * MAX_CM_SK_TBL_SZ,\r\nGFP_KERNEL);\r\nif (!cp->csk_tbl)\r\nreturn -ENOMEM;\r\nport_id = prandom_u32();\r\nport_id %= CNIC_LOCAL_PORT_RANGE;\r\nif (cnic_init_id_tbl(&cp->csk_port_tbl, CNIC_LOCAL_PORT_RANGE,\r\nCNIC_LOCAL_PORT_MIN, port_id)) {\r\ncnic_cm_free_mem(dev);\r\nreturn -ENOMEM;\r\n}\r\nreturn 0;\r\n}\r\nstatic int cnic_ready_to_close(struct cnic_sock *csk, u32 opcode)\r\n{\r\nif (test_and_clear_bit(SK_F_OFFLD_COMPLETE, &csk->flags)) {\r\nopcode = L4_KCQE_OPCODE_VALUE_RESET_RECEIVED;\r\ncsk->state = opcode;\r\n}\r\nif (opcode == csk->state || csk->state == 0 ||\r\ncsk->state == L4_KCQE_OPCODE_VALUE_CLOSE_COMP ||\r\ncsk->state == L4_KCQE_OPCODE_VALUE_RESET_COMP) {\r\nif (!test_and_set_bit(SK_F_CLOSING, &csk->flags)) {\r\nif (csk->state == 0)\r\ncsk->state = opcode;\r\nreturn 1;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic void cnic_close_bnx2_conn(struct cnic_sock *csk, u32 opcode)\r\n{\r\nstruct cnic_dev *dev = csk->dev;\r\nstruct cnic_local *cp = dev->cnic_priv;\r\nif (opcode == L4_KCQE_OPCODE_VALUE_RESET_RECEIVED) {\r\ncnic_cm_upcall(cp, csk, opcode);\r\nreturn;\r\n}\r\nclear_bit(SK_F_CONNECT_START, &csk->flags);\r\ncnic_close_conn(csk);\r\ncsk->state = opcode;\r\ncnic_cm_upcall(cp, csk, opcode);\r\n}\r\nstatic void cnic_cm_stop_bnx2_hw(struct cnic_dev *dev)\r\n{\r\n}\r\nstatic int cnic_cm_init_bnx2_hw(struct cnic_dev *dev)\r\n{\r\nu32 seed;\r\nseed = prandom_u32();\r\ncnic_ctx_wr(dev, 45, 0, seed);\r\nreturn 0;\r\n}\r\nstatic void cnic_close_bnx2x_conn(struct cnic_sock *csk, u32 opcode)\r\n{\r\nstruct cnic_dev *dev = csk->dev;\r\nstruct cnic_local *cp = dev->cnic_priv;\r\nstruct cnic_context *ctx = &cp->ctx_tbl[csk->l5_cid];\r\nunion l5cm_specific_data l5_data;\r\nu32 cmd = 0;\r\nint close_complete = 0;\r\nswitch (opcode) {\r\ncase L4_KCQE_OPCODE_VALUE_RESET_RECEIVED:\r\ncase L4_KCQE_OPCODE_VALUE_CLOSE_COMP:\r\ncase L4_KCQE_OPCODE_VALUE_RESET_COMP:\r\nif (cnic_ready_to_close(csk, opcode)) {\r\nif (test_bit(SK_F_HW_ERR, &csk->flags))\r\nclose_complete = 1;\r\nelse if (test_bit(SK_F_PG_OFFLD_COMPLETE, &csk->flags))\r\ncmd = L5CM_RAMROD_CMD_ID_SEARCHER_DELETE;\r\nelse\r\nclose_complete = 1;\r\n}\r\nbreak;\r\ncase L5CM_RAMROD_CMD_ID_SEARCHER_DELETE:\r\ncmd = L5CM_RAMROD_CMD_ID_TERMINATE_OFFLOAD;\r\nbreak;\r\ncase L5CM_RAMROD_CMD_ID_TERMINATE_OFFLOAD:\r\nclose_complete = 1;\r\nbreak;\r\n}\r\nif (cmd) {\r\nmemset(&l5_data, 0, sizeof(l5_data));\r\ncnic_submit_kwqe_16(dev, cmd, csk->cid, ISCSI_CONNECTION_TYPE,\r\n&l5_data);\r\n} else if (close_complete) {\r\nctx->timestamp = jiffies;\r\ncnic_close_conn(csk);\r\ncnic_cm_upcall(cp, csk, csk->state);\r\n}\r\n}\r\nstatic void cnic_cm_stop_bnx2x_hw(struct cnic_dev *dev)\r\n{\r\nstruct cnic_local *cp = dev->cnic_priv;\r\nif (!cp->ctx_tbl)\r\nreturn;\r\nif (!netif_running(dev->netdev))\r\nreturn;\r\ncnic_bnx2x_delete_wait(dev, 0);\r\ncancel_delayed_work(&cp->delete_task);\r\nflush_workqueue(cnic_wq);\r\nif (atomic_read(&cp->iscsi_conn) != 0)\r\nnetdev_warn(dev->netdev, "%d iSCSI connections not destroyed\n",\r\natomic_read(&cp->iscsi_conn));\r\n}\r\nstatic int cnic_cm_init_bnx2x_hw(struct cnic_dev *dev)\r\n{\r\nstruct bnx2x *bp = netdev_priv(dev->netdev);\r\nu32 pfid = bp->pfid;\r\nu32 port = BP_PORT(bp);\r\ncnic_init_bnx2x_mac(dev);\r\ncnic_bnx2x_set_tcp_options(dev, 0, 1);\r\nCNIC_WR16(dev, BAR_XSTRORM_INTMEM +\r\nXSTORM_ISCSI_LOCAL_VLAN_OFFSET(pfid), 0);\r\nCNIC_WR(dev, BAR_XSTRORM_INTMEM +\r\nXSTORM_TCP_GLOBAL_DEL_ACK_COUNTER_ENABLED_OFFSET(port), 1);\r\nCNIC_WR(dev, BAR_XSTRORM_INTMEM +\r\nXSTORM_TCP_GLOBAL_DEL_ACK_COUNTER_MAX_COUNT_OFFSET(port),\r\nDEF_MAX_DA_COUNT);\r\nCNIC_WR8(dev, BAR_XSTRORM_INTMEM +\r\nXSTORM_ISCSI_TCP_VARS_TTL_OFFSET(pfid), DEF_TTL);\r\nCNIC_WR8(dev, BAR_XSTRORM_INTMEM +\r\nXSTORM_ISCSI_TCP_VARS_TOS_OFFSET(pfid), DEF_TOS);\r\nCNIC_WR8(dev, BAR_XSTRORM_INTMEM +\r\nXSTORM_ISCSI_TCP_VARS_ADV_WND_SCL_OFFSET(pfid), 2);\r\nCNIC_WR(dev, BAR_XSTRORM_INTMEM +\r\nXSTORM_TCP_TX_SWS_TIMER_VAL_OFFSET(pfid), DEF_SWS_TIMER);\r\nCNIC_WR(dev, BAR_TSTRORM_INTMEM + TSTORM_TCP_MAX_CWND_OFFSET(pfid),\r\nDEF_MAX_CWND);\r\nreturn 0;\r\n}\r\nstatic void cnic_delete_task(struct work_struct *work)\r\n{\r\nstruct cnic_local *cp;\r\nstruct cnic_dev *dev;\r\nu32 i;\r\nint need_resched = 0;\r\ncp = container_of(work, struct cnic_local, delete_task.work);\r\ndev = cp->dev;\r\nif (test_and_clear_bit(CNIC_LCL_FL_STOP_ISCSI, &cp->cnic_local_flags)) {\r\nstruct drv_ctl_info info;\r\ncnic_ulp_stop_one(cp, CNIC_ULP_ISCSI);\r\nmemset(&info, 0, sizeof(struct drv_ctl_info));\r\ninfo.cmd = DRV_CTL_ISCSI_STOPPED_CMD;\r\ncp->ethdev->drv_ctl(dev->netdev, &info);\r\n}\r\nfor (i = 0; i < cp->max_cid_space; i++) {\r\nstruct cnic_context *ctx = &cp->ctx_tbl[i];\r\nint err;\r\nif (!test_bit(CTX_FL_OFFLD_START, &ctx->ctx_flags) ||\r\n!test_bit(CTX_FL_DELETE_WAIT, &ctx->ctx_flags))\r\ncontinue;\r\nif (!time_after(jiffies, ctx->timestamp + (2 * HZ))) {\r\nneed_resched = 1;\r\ncontinue;\r\n}\r\nif (!test_and_clear_bit(CTX_FL_DELETE_WAIT, &ctx->ctx_flags))\r\ncontinue;\r\nerr = cnic_bnx2x_destroy_ramrod(dev, i);\r\ncnic_free_bnx2x_conn_resc(dev, i);\r\nif (!err) {\r\nif (ctx->ulp_proto_id == CNIC_ULP_ISCSI)\r\natomic_dec(&cp->iscsi_conn);\r\nclear_bit(CTX_FL_OFFLD_START, &ctx->ctx_flags);\r\n}\r\n}\r\nif (need_resched)\r\nqueue_delayed_work(cnic_wq, &cp->delete_task,\r\nmsecs_to_jiffies(10));\r\n}\r\nstatic int cnic_cm_open(struct cnic_dev *dev)\r\n{\r\nstruct cnic_local *cp = dev->cnic_priv;\r\nint err;\r\nerr = cnic_cm_alloc_mem(dev);\r\nif (err)\r\nreturn err;\r\nerr = cp->start_cm(dev);\r\nif (err)\r\ngoto err_out;\r\nINIT_DELAYED_WORK(&cp->delete_task, cnic_delete_task);\r\ndev->cm_create = cnic_cm_create;\r\ndev->cm_destroy = cnic_cm_destroy;\r\ndev->cm_connect = cnic_cm_connect;\r\ndev->cm_abort = cnic_cm_abort;\r\ndev->cm_close = cnic_cm_close;\r\ndev->cm_select_dev = cnic_cm_select_dev;\r\ncp->ulp_handle[CNIC_ULP_L4] = dev;\r\nrcu_assign_pointer(cp->ulp_ops[CNIC_ULP_L4], &cm_ulp_ops);\r\nreturn 0;\r\nerr_out:\r\ncnic_cm_free_mem(dev);\r\nreturn err;\r\n}\r\nstatic int cnic_cm_shutdown(struct cnic_dev *dev)\r\n{\r\nstruct cnic_local *cp = dev->cnic_priv;\r\nint i;\r\nif (!cp->csk_tbl)\r\nreturn 0;\r\nfor (i = 0; i < MAX_CM_SK_TBL_SZ; i++) {\r\nstruct cnic_sock *csk = &cp->csk_tbl[i];\r\nclear_bit(SK_F_INUSE, &csk->flags);\r\ncnic_cm_cleanup(csk);\r\n}\r\ncnic_cm_free_mem(dev);\r\nreturn 0;\r\n}\r\nstatic void cnic_init_context(struct cnic_dev *dev, u32 cid)\r\n{\r\nu32 cid_addr;\r\nint i;\r\ncid_addr = GET_CID_ADDR(cid);\r\nfor (i = 0; i < CTX_SIZE; i += 4)\r\ncnic_ctx_wr(dev, cid_addr, i, 0);\r\n}\r\nstatic int cnic_setup_5709_context(struct cnic_dev *dev, int valid)\r\n{\r\nstruct cnic_local *cp = dev->cnic_priv;\r\nint ret = 0, i;\r\nu32 valid_bit = valid ? BNX2_CTX_HOST_PAGE_TBL_DATA0_VALID : 0;\r\nif (BNX2_CHIP(cp) != BNX2_CHIP_5709)\r\nreturn 0;\r\nfor (i = 0; i < cp->ctx_blks; i++) {\r\nint j;\r\nu32 idx = cp->ctx_arr[i].cid / cp->cids_per_blk;\r\nu32 val;\r\nmemset(cp->ctx_arr[i].ctx, 0, CNIC_PAGE_SIZE);\r\nCNIC_WR(dev, BNX2_CTX_HOST_PAGE_TBL_DATA0,\r\n(cp->ctx_arr[i].mapping & 0xffffffff) | valid_bit);\r\nCNIC_WR(dev, BNX2_CTX_HOST_PAGE_TBL_DATA1,\r\n(u64) cp->ctx_arr[i].mapping >> 32);\r\nCNIC_WR(dev, BNX2_CTX_HOST_PAGE_TBL_CTRL, idx |\r\nBNX2_CTX_HOST_PAGE_TBL_CTRL_WRITE_REQ);\r\nfor (j = 0; j < 10; j++) {\r\nval = CNIC_RD(dev, BNX2_CTX_HOST_PAGE_TBL_CTRL);\r\nif (!(val & BNX2_CTX_HOST_PAGE_TBL_CTRL_WRITE_REQ))\r\nbreak;\r\nudelay(5);\r\n}\r\nif (val & BNX2_CTX_HOST_PAGE_TBL_CTRL_WRITE_REQ) {\r\nret = -EBUSY;\r\nbreak;\r\n}\r\n}\r\nreturn ret;\r\n}\r\nstatic void cnic_free_irq(struct cnic_dev *dev)\r\n{\r\nstruct cnic_local *cp = dev->cnic_priv;\r\nstruct cnic_eth_dev *ethdev = cp->ethdev;\r\nif (ethdev->drv_state & CNIC_DRV_STATE_USING_MSIX) {\r\ncp->disable_int_sync(dev);\r\ntasklet_kill(&cp->cnic_irq_task);\r\nfree_irq(ethdev->irq_arr[0].vector, dev);\r\n}\r\n}\r\nstatic int cnic_request_irq(struct cnic_dev *dev)\r\n{\r\nstruct cnic_local *cp = dev->cnic_priv;\r\nstruct cnic_eth_dev *ethdev = cp->ethdev;\r\nint err;\r\nerr = request_irq(ethdev->irq_arr[0].vector, cnic_irq, 0, "cnic", dev);\r\nif (err)\r\ntasklet_disable(&cp->cnic_irq_task);\r\nreturn err;\r\n}\r\nstatic int cnic_init_bnx2_irq(struct cnic_dev *dev)\r\n{\r\nstruct cnic_local *cp = dev->cnic_priv;\r\nstruct cnic_eth_dev *ethdev = cp->ethdev;\r\nif (ethdev->drv_state & CNIC_DRV_STATE_USING_MSIX) {\r\nint err, i = 0;\r\nint sblk_num = cp->status_blk_num;\r\nu32 base = ((sblk_num - 1) * BNX2_HC_SB_CONFIG_SIZE) +\r\nBNX2_HC_SB_CONFIG_1;\r\nCNIC_WR(dev, base, BNX2_HC_SB_CONFIG_1_ONE_SHOT);\r\nCNIC_WR(dev, base + BNX2_HC_COMP_PROD_TRIP_OFF, (2 << 16) | 8);\r\nCNIC_WR(dev, base + BNX2_HC_COM_TICKS_OFF, (64 << 16) | 220);\r\nCNIC_WR(dev, base + BNX2_HC_CMD_TICKS_OFF, (64 << 16) | 220);\r\ncp->last_status_idx = cp->status_blk.bnx2->status_idx;\r\ntasklet_init(&cp->cnic_irq_task, cnic_service_bnx2_msix,\r\n(unsigned long) dev);\r\nerr = cnic_request_irq(dev);\r\nif (err)\r\nreturn err;\r\nwhile (cp->status_blk.bnx2->status_completion_producer_index &&\r\ni < 10) {\r\nCNIC_WR(dev, BNX2_HC_COALESCE_NOW,\r\n1 << (11 + sblk_num));\r\nudelay(10);\r\ni++;\r\nbarrier();\r\n}\r\nif (cp->status_blk.bnx2->status_completion_producer_index) {\r\ncnic_free_irq(dev);\r\ngoto failed;\r\n}\r\n} else {\r\nstruct status_block *sblk = cp->status_blk.gen;\r\nu32 hc_cmd = CNIC_RD(dev, BNX2_HC_COMMAND);\r\nint i = 0;\r\nwhile (sblk->status_completion_producer_index && i < 10) {\r\nCNIC_WR(dev, BNX2_HC_COMMAND,\r\nhc_cmd | BNX2_HC_COMMAND_COAL_NOW_WO_INT);\r\nudelay(10);\r\ni++;\r\nbarrier();\r\n}\r\nif (sblk->status_completion_producer_index)\r\ngoto failed;\r\n}\r\nreturn 0;\r\nfailed:\r\nnetdev_err(dev->netdev, "KCQ index not resetting to 0\n");\r\nreturn -EBUSY;\r\n}\r\nstatic void cnic_enable_bnx2_int(struct cnic_dev *dev)\r\n{\r\nstruct cnic_local *cp = dev->cnic_priv;\r\nstruct cnic_eth_dev *ethdev = cp->ethdev;\r\nif (!(ethdev->drv_state & CNIC_DRV_STATE_USING_MSIX))\r\nreturn;\r\nCNIC_WR(dev, BNX2_PCICFG_INT_ACK_CMD, cp->int_num |\r\nBNX2_PCICFG_INT_ACK_CMD_INDEX_VALID | cp->last_status_idx);\r\n}\r\nstatic void cnic_disable_bnx2_int_sync(struct cnic_dev *dev)\r\n{\r\nstruct cnic_local *cp = dev->cnic_priv;\r\nstruct cnic_eth_dev *ethdev = cp->ethdev;\r\nif (!(ethdev->drv_state & CNIC_DRV_STATE_USING_MSIX))\r\nreturn;\r\nCNIC_WR(dev, BNX2_PCICFG_INT_ACK_CMD, cp->int_num |\r\nBNX2_PCICFG_INT_ACK_CMD_MASK_INT);\r\nCNIC_RD(dev, BNX2_PCICFG_INT_ACK_CMD);\r\nsynchronize_irq(ethdev->irq_arr[0].vector);\r\n}\r\nstatic void cnic_init_bnx2_tx_ring(struct cnic_dev *dev)\r\n{\r\nstruct cnic_local *cp = dev->cnic_priv;\r\nstruct cnic_eth_dev *ethdev = cp->ethdev;\r\nstruct cnic_uio_dev *udev = cp->udev;\r\nu32 cid_addr, tx_cid, sb_id;\r\nu32 val, offset0, offset1, offset2, offset3;\r\nint i;\r\nstruct bnx2_tx_bd *txbd;\r\ndma_addr_t buf_map, ring_map = udev->l2_ring_map;\r\nstruct status_block *s_blk = cp->status_blk.gen;\r\nsb_id = cp->status_blk_num;\r\ntx_cid = 20;\r\ncp->tx_cons_ptr = &s_blk->status_tx_quick_consumer_index2;\r\nif (ethdev->drv_state & CNIC_DRV_STATE_USING_MSIX) {\r\nstruct status_block_msix *sblk = cp->status_blk.bnx2;\r\ntx_cid = TX_TSS_CID + sb_id - 1;\r\nCNIC_WR(dev, BNX2_TSCH_TSS_CFG, (sb_id << 24) |\r\n(TX_TSS_CID << 7));\r\ncp->tx_cons_ptr = &sblk->status_tx_quick_consumer_index;\r\n}\r\ncp->tx_cons = *cp->tx_cons_ptr;\r\ncid_addr = GET_CID_ADDR(tx_cid);\r\nif (BNX2_CHIP(cp) == BNX2_CHIP_5709) {\r\nu32 cid_addr2 = GET_CID_ADDR(tx_cid + 4) + 0x40;\r\nfor (i = 0; i < PHY_CTX_SIZE; i += 4)\r\ncnic_ctx_wr(dev, cid_addr2, i, 0);\r\noffset0 = BNX2_L2CTX_TYPE_XI;\r\noffset1 = BNX2_L2CTX_CMD_TYPE_XI;\r\noffset2 = BNX2_L2CTX_TBDR_BHADDR_HI_XI;\r\noffset3 = BNX2_L2CTX_TBDR_BHADDR_LO_XI;\r\n} else {\r\ncnic_init_context(dev, tx_cid);\r\ncnic_init_context(dev, tx_cid + 1);\r\noffset0 = BNX2_L2CTX_TYPE;\r\noffset1 = BNX2_L2CTX_CMD_TYPE;\r\noffset2 = BNX2_L2CTX_TBDR_BHADDR_HI;\r\noffset3 = BNX2_L2CTX_TBDR_BHADDR_LO;\r\n}\r\nval = BNX2_L2CTX_TYPE_TYPE_L2 | BNX2_L2CTX_TYPE_SIZE_L2;\r\ncnic_ctx_wr(dev, cid_addr, offset0, val);\r\nval = BNX2_L2CTX_CMD_TYPE_TYPE_L2 | (8 << 16);\r\ncnic_ctx_wr(dev, cid_addr, offset1, val);\r\ntxbd = udev->l2_ring;\r\nbuf_map = udev->l2_buf_map;\r\nfor (i = 0; i < BNX2_MAX_TX_DESC_CNT; i++, txbd++) {\r\ntxbd->tx_bd_haddr_hi = (u64) buf_map >> 32;\r\ntxbd->tx_bd_haddr_lo = (u64) buf_map & 0xffffffff;\r\n}\r\nval = (u64) ring_map >> 32;\r\ncnic_ctx_wr(dev, cid_addr, offset2, val);\r\ntxbd->tx_bd_haddr_hi = val;\r\nval = (u64) ring_map & 0xffffffff;\r\ncnic_ctx_wr(dev, cid_addr, offset3, val);\r\ntxbd->tx_bd_haddr_lo = val;\r\n}\r\nstatic void cnic_init_bnx2_rx_ring(struct cnic_dev *dev)\r\n{\r\nstruct cnic_local *cp = dev->cnic_priv;\r\nstruct cnic_eth_dev *ethdev = cp->ethdev;\r\nstruct cnic_uio_dev *udev = cp->udev;\r\nu32 cid_addr, sb_id, val, coal_reg, coal_val;\r\nint i;\r\nstruct bnx2_rx_bd *rxbd;\r\nstruct status_block *s_blk = cp->status_blk.gen;\r\ndma_addr_t ring_map = udev->l2_ring_map;\r\nsb_id = cp->status_blk_num;\r\ncnic_init_context(dev, 2);\r\ncp->rx_cons_ptr = &s_blk->status_rx_quick_consumer_index2;\r\ncoal_reg = BNX2_HC_COMMAND;\r\ncoal_val = CNIC_RD(dev, coal_reg);\r\nif (ethdev->drv_state & CNIC_DRV_STATE_USING_MSIX) {\r\nstruct status_block_msix *sblk = cp->status_blk.bnx2;\r\ncp->rx_cons_ptr = &sblk->status_rx_quick_consumer_index;\r\ncoal_reg = BNX2_HC_COALESCE_NOW;\r\ncoal_val = 1 << (11 + sb_id);\r\n}\r\ni = 0;\r\nwhile (!(*cp->rx_cons_ptr != 0) && i < 10) {\r\nCNIC_WR(dev, coal_reg, coal_val);\r\nudelay(10);\r\ni++;\r\nbarrier();\r\n}\r\ncp->rx_cons = *cp->rx_cons_ptr;\r\ncid_addr = GET_CID_ADDR(2);\r\nval = BNX2_L2CTX_CTX_TYPE_CTX_BD_CHN_TYPE_VALUE |\r\nBNX2_L2CTX_CTX_TYPE_SIZE_L2 | (0x02 << 8);\r\ncnic_ctx_wr(dev, cid_addr, BNX2_L2CTX_CTX_TYPE, val);\r\nif (sb_id == 0)\r\nval = 2 << BNX2_L2CTX_L2_STATUSB_NUM_SHIFT;\r\nelse\r\nval = BNX2_L2CTX_L2_STATUSB_NUM(sb_id);\r\ncnic_ctx_wr(dev, cid_addr, BNX2_L2CTX_HOST_BDIDX, val);\r\nrxbd = udev->l2_ring + CNIC_PAGE_SIZE;\r\nfor (i = 0; i < BNX2_MAX_RX_DESC_CNT; i++, rxbd++) {\r\ndma_addr_t buf_map;\r\nint n = (i % cp->l2_rx_ring_size) + 1;\r\nbuf_map = udev->l2_buf_map + (n * cp->l2_single_buf_size);\r\nrxbd->rx_bd_len = cp->l2_single_buf_size;\r\nrxbd->rx_bd_flags = RX_BD_FLAGS_START | RX_BD_FLAGS_END;\r\nrxbd->rx_bd_haddr_hi = (u64) buf_map >> 32;\r\nrxbd->rx_bd_haddr_lo = (u64) buf_map & 0xffffffff;\r\n}\r\nval = (u64) (ring_map + CNIC_PAGE_SIZE) >> 32;\r\ncnic_ctx_wr(dev, cid_addr, BNX2_L2CTX_NX_BDHADDR_HI, val);\r\nrxbd->rx_bd_haddr_hi = val;\r\nval = (u64) (ring_map + CNIC_PAGE_SIZE) & 0xffffffff;\r\ncnic_ctx_wr(dev, cid_addr, BNX2_L2CTX_NX_BDHADDR_LO, val);\r\nrxbd->rx_bd_haddr_lo = val;\r\nval = cnic_reg_rd_ind(dev, BNX2_RXP_SCRATCH_RXP_FLOOD);\r\ncnic_reg_wr_ind(dev, BNX2_RXP_SCRATCH_RXP_FLOOD, val | (1 << 2));\r\n}\r\nstatic void cnic_shutdown_bnx2_rx_ring(struct cnic_dev *dev)\r\n{\r\nstruct kwqe *wqes[1], l2kwqe;\r\nmemset(&l2kwqe, 0, sizeof(l2kwqe));\r\nwqes[0] = &l2kwqe;\r\nl2kwqe.kwqe_op_flag = (L2_LAYER_CODE << KWQE_LAYER_SHIFT) |\r\n(L2_KWQE_OPCODE_VALUE_FLUSH <<\r\nKWQE_OPCODE_SHIFT) | 2;\r\ndev->submit_kwqes(dev, wqes, 1);\r\n}\r\nstatic void cnic_set_bnx2_mac(struct cnic_dev *dev)\r\n{\r\nstruct cnic_local *cp = dev->cnic_priv;\r\nu32 val;\r\nval = cp->func << 2;\r\ncp->shmem_base = cnic_reg_rd_ind(dev, BNX2_SHM_HDR_ADDR_0 + val);\r\nval = cnic_reg_rd_ind(dev, cp->shmem_base +\r\nBNX2_PORT_HW_CFG_ISCSI_MAC_UPPER);\r\ndev->mac_addr[0] = (u8) (val >> 8);\r\ndev->mac_addr[1] = (u8) val;\r\nCNIC_WR(dev, BNX2_EMAC_MAC_MATCH4, val);\r\nval = cnic_reg_rd_ind(dev, cp->shmem_base +\r\nBNX2_PORT_HW_CFG_ISCSI_MAC_LOWER);\r\ndev->mac_addr[2] = (u8) (val >> 24);\r\ndev->mac_addr[3] = (u8) (val >> 16);\r\ndev->mac_addr[4] = (u8) (val >> 8);\r\ndev->mac_addr[5] = (u8) val;\r\nCNIC_WR(dev, BNX2_EMAC_MAC_MATCH5, val);\r\nval = 4 | BNX2_RPM_SORT_USER2_BC_EN;\r\nif (BNX2_CHIP(cp) != BNX2_CHIP_5709)\r\nval |= BNX2_RPM_SORT_USER2_PROM_VLAN;\r\nCNIC_WR(dev, BNX2_RPM_SORT_USER2, 0x0);\r\nCNIC_WR(dev, BNX2_RPM_SORT_USER2, val);\r\nCNIC_WR(dev, BNX2_RPM_SORT_USER2, val | BNX2_RPM_SORT_USER2_ENA);\r\n}\r\nstatic int cnic_start_bnx2_hw(struct cnic_dev *dev)\r\n{\r\nstruct cnic_local *cp = dev->cnic_priv;\r\nstruct cnic_eth_dev *ethdev = cp->ethdev;\r\nstruct status_block *sblk = cp->status_blk.gen;\r\nu32 val, kcq_cid_addr, kwq_cid_addr;\r\nint err;\r\ncnic_set_bnx2_mac(dev);\r\nval = CNIC_RD(dev, BNX2_MQ_CONFIG);\r\nval &= ~BNX2_MQ_CONFIG_KNL_BYP_BLK_SIZE;\r\nif (CNIC_PAGE_BITS > 12)\r\nval |= (12 - 8) << 4;\r\nelse\r\nval |= (CNIC_PAGE_BITS - 8) << 4;\r\nCNIC_WR(dev, BNX2_MQ_CONFIG, val);\r\nCNIC_WR(dev, BNX2_HC_COMP_PROD_TRIP, (2 << 16) | 8);\r\nCNIC_WR(dev, BNX2_HC_COM_TICKS, (64 << 16) | 220);\r\nCNIC_WR(dev, BNX2_HC_CMD_TICKS, (64 << 16) | 220);\r\nerr = cnic_setup_5709_context(dev, 1);\r\nif (err)\r\nreturn err;\r\ncnic_init_context(dev, KWQ_CID);\r\ncnic_init_context(dev, KCQ_CID);\r\nkwq_cid_addr = GET_CID_ADDR(KWQ_CID);\r\ncp->kwq_io_addr = MB_GET_CID_ADDR(KWQ_CID) + L5_KRNLQ_HOST_QIDX;\r\ncp->max_kwq_idx = MAX_KWQ_IDX;\r\ncp->kwq_prod_idx = 0;\r\ncp->kwq_con_idx = 0;\r\nset_bit(CNIC_LCL_FL_KWQ_INIT, &cp->cnic_local_flags);\r\nif (BNX2_CHIP(cp) == BNX2_CHIP_5706 || BNX2_CHIP(cp) == BNX2_CHIP_5708)\r\ncp->kwq_con_idx_ptr = &sblk->status_rx_quick_consumer_index15;\r\nelse\r\ncp->kwq_con_idx_ptr = &sblk->status_cmd_consumer_index;\r\nval = KRNLQ_TYPE_TYPE_KRNLQ | KRNLQ_SIZE_TYPE_SIZE |\r\n(CNIC_PAGE_BITS - 8) | KRNLQ_FLAGS_QE_SELF_SEQ;\r\ncnic_ctx_wr(dev, kwq_cid_addr, L5_KRNLQ_TYPE, val);\r\nval = (CNIC_PAGE_SIZE / sizeof(struct kwqe) - 1) << 16;\r\ncnic_ctx_wr(dev, kwq_cid_addr, L5_KRNLQ_QE_SELF_SEQ_MAX, val);\r\nval = ((CNIC_PAGE_SIZE / sizeof(struct kwqe)) << 16) | KWQ_PAGE_CNT;\r\ncnic_ctx_wr(dev, kwq_cid_addr, L5_KRNLQ_PGTBL_NPAGES, val);\r\nval = (u32) ((u64) cp->kwq_info.pgtbl_map >> 32);\r\ncnic_ctx_wr(dev, kwq_cid_addr, L5_KRNLQ_PGTBL_HADDR_HI, val);\r\nval = (u32) cp->kwq_info.pgtbl_map;\r\ncnic_ctx_wr(dev, kwq_cid_addr, L5_KRNLQ_PGTBL_HADDR_LO, val);\r\nkcq_cid_addr = GET_CID_ADDR(KCQ_CID);\r\ncp->kcq1.io_addr = MB_GET_CID_ADDR(KCQ_CID) + L5_KRNLQ_HOST_QIDX;\r\ncp->kcq1.sw_prod_idx = 0;\r\ncp->kcq1.hw_prod_idx_ptr =\r\n&sblk->status_completion_producer_index;\r\ncp->kcq1.status_idx_ptr = &sblk->status_idx;\r\nval = KRNLQ_TYPE_TYPE_KRNLQ | KRNLQ_SIZE_TYPE_SIZE |\r\n(CNIC_PAGE_BITS - 8) | KRNLQ_FLAGS_QE_SELF_SEQ;\r\ncnic_ctx_wr(dev, kcq_cid_addr, L5_KRNLQ_TYPE, val);\r\nval = (CNIC_PAGE_SIZE / sizeof(struct kcqe) - 1) << 16;\r\ncnic_ctx_wr(dev, kcq_cid_addr, L5_KRNLQ_QE_SELF_SEQ_MAX, val);\r\nval = ((CNIC_PAGE_SIZE / sizeof(struct kcqe)) << 16) | KCQ_PAGE_CNT;\r\ncnic_ctx_wr(dev, kcq_cid_addr, L5_KRNLQ_PGTBL_NPAGES, val);\r\nval = (u32) ((u64) cp->kcq1.dma.pgtbl_map >> 32);\r\ncnic_ctx_wr(dev, kcq_cid_addr, L5_KRNLQ_PGTBL_HADDR_HI, val);\r\nval = (u32) cp->kcq1.dma.pgtbl_map;\r\ncnic_ctx_wr(dev, kcq_cid_addr, L5_KRNLQ_PGTBL_HADDR_LO, val);\r\ncp->int_num = 0;\r\nif (ethdev->drv_state & CNIC_DRV_STATE_USING_MSIX) {\r\nstruct status_block_msix *msblk = cp->status_blk.bnx2;\r\nu32 sb_id = cp->status_blk_num;\r\nu32 sb = BNX2_L2CTX_L5_STATUSB_NUM(sb_id);\r\ncp->kcq1.hw_prod_idx_ptr =\r\n&msblk->status_completion_producer_index;\r\ncp->kcq1.status_idx_ptr = &msblk->status_idx;\r\ncp->kwq_con_idx_ptr = &msblk->status_cmd_consumer_index;\r\ncp->int_num = sb_id << BNX2_PCICFG_INT_ACK_CMD_INT_NUM_SHIFT;\r\ncnic_ctx_wr(dev, kwq_cid_addr, L5_KRNLQ_HOST_QIDX, sb);\r\ncnic_ctx_wr(dev, kcq_cid_addr, L5_KRNLQ_HOST_QIDX, sb);\r\n}\r\nCNIC_WR(dev, BNX2_MQ_KNL_CMD_MASK1, 2);\r\nCNIC_WR(dev, BNX2_MQ_KNL_BYP_CMD_MASK1, 7);\r\nCNIC_WR(dev, BNX2_MQ_KNL_BYP_WRITE_MASK1, 7);\r\nCNIC_WR(dev, BNX2_MQ_KNL_RX_V2P_MASK2, 0x2000);\r\ncnic_reg_wr_ind(dev, BNX2_CP_SCRATCH + 0x20, 1);\r\ncnic_reg_wr_ind(dev, BNX2_COM_SCRATCH + 0x20, 1);\r\ncnic_init_bnx2_tx_ring(dev);\r\ncnic_init_bnx2_rx_ring(dev);\r\nerr = cnic_init_bnx2_irq(dev);\r\nif (err) {\r\nnetdev_err(dev->netdev, "cnic_init_irq failed\n");\r\ncnic_reg_wr_ind(dev, BNX2_CP_SCRATCH + 0x20, 0);\r\ncnic_reg_wr_ind(dev, BNX2_COM_SCRATCH + 0x20, 0);\r\nreturn err;\r\n}\r\nethdev->drv_state |= CNIC_DRV_STATE_HANDLES_IRQ;\r\nreturn 0;\r\n}\r\nstatic void cnic_setup_bnx2x_context(struct cnic_dev *dev)\r\n{\r\nstruct cnic_local *cp = dev->cnic_priv;\r\nstruct cnic_eth_dev *ethdev = cp->ethdev;\r\nu32 start_offset = ethdev->ctx_tbl_offset;\r\nint i;\r\nfor (i = 0; i < cp->ctx_blks; i++) {\r\nstruct cnic_ctx *ctx = &cp->ctx_arr[i];\r\ndma_addr_t map = ctx->mapping;\r\nif (cp->ctx_align) {\r\nunsigned long mask = cp->ctx_align - 1;\r\nmap = (map + mask) & ~mask;\r\n}\r\ncnic_ctx_tbl_wr(dev, start_offset + i, map);\r\n}\r\n}\r\nstatic int cnic_init_bnx2x_irq(struct cnic_dev *dev)\r\n{\r\nstruct cnic_local *cp = dev->cnic_priv;\r\nstruct cnic_eth_dev *ethdev = cp->ethdev;\r\nint err = 0;\r\ntasklet_init(&cp->cnic_irq_task, cnic_service_bnx2x_bh,\r\n(unsigned long) dev);\r\nif (ethdev->drv_state & CNIC_DRV_STATE_USING_MSIX)\r\nerr = cnic_request_irq(dev);\r\nreturn err;\r\n}\r\nstatic inline void cnic_storm_memset_hc_disable(struct cnic_dev *dev,\r\nu16 sb_id, u8 sb_index,\r\nu8 disable)\r\n{\r\nstruct bnx2x *bp = netdev_priv(dev->netdev);\r\nu32 addr = BAR_CSTRORM_INTMEM +\r\nCSTORM_STATUS_BLOCK_DATA_OFFSET(sb_id) +\r\noffsetof(struct hc_status_block_data_e1x, index_data) +\r\nsizeof(struct hc_index_data)*sb_index +\r\noffsetof(struct hc_index_data, flags);\r\nu16 flags = CNIC_RD16(dev, addr);\r\nflags &= ~HC_INDEX_DATA_HC_ENABLED;\r\nflags |= (((~disable) << HC_INDEX_DATA_HC_ENABLED_SHIFT) &\r\nHC_INDEX_DATA_HC_ENABLED);\r\nCNIC_WR16(dev, addr, flags);\r\n}\r\nstatic void cnic_enable_bnx2x_int(struct cnic_dev *dev)\r\n{\r\nstruct cnic_local *cp = dev->cnic_priv;\r\nstruct bnx2x *bp = netdev_priv(dev->netdev);\r\nu8 sb_id = cp->status_blk_num;\r\nCNIC_WR8(dev, BAR_CSTRORM_INTMEM +\r\nCSTORM_STATUS_BLOCK_DATA_OFFSET(sb_id) +\r\noffsetof(struct hc_status_block_data_e1x, index_data) +\r\nsizeof(struct hc_index_data)*HC_INDEX_ISCSI_EQ_CONS +\r\noffsetof(struct hc_index_data, timeout), 64 / 4);\r\ncnic_storm_memset_hc_disable(dev, sb_id, HC_INDEX_ISCSI_EQ_CONS, 0);\r\n}\r\nstatic void cnic_disable_bnx2x_int_sync(struct cnic_dev *dev)\r\n{\r\n}\r\nstatic void cnic_init_bnx2x_tx_ring(struct cnic_dev *dev,\r\nstruct client_init_ramrod_data *data)\r\n{\r\nstruct cnic_local *cp = dev->cnic_priv;\r\nstruct bnx2x *bp = netdev_priv(dev->netdev);\r\nstruct cnic_uio_dev *udev = cp->udev;\r\nunion eth_tx_bd_types *txbd = (union eth_tx_bd_types *) udev->l2_ring;\r\ndma_addr_t buf_map, ring_map = udev->l2_ring_map;\r\nstruct host_sp_status_block *sb = cp->bnx2x_def_status_blk;\r\nint i;\r\nu32 cli = cp->ethdev->iscsi_l2_client_id;\r\nu32 val;\r\nmemset(txbd, 0, CNIC_PAGE_SIZE);\r\nbuf_map = udev->l2_buf_map;\r\nfor (i = 0; i < BNX2_MAX_TX_DESC_CNT; i += 3, txbd += 3) {\r\nstruct eth_tx_start_bd *start_bd = &txbd->start_bd;\r\nstruct eth_tx_parse_bd_e1x *pbd_e1x =\r\n&((txbd + 1)->parse_bd_e1x);\r\nstruct eth_tx_parse_bd_e2 *pbd_e2 = &((txbd + 1)->parse_bd_e2);\r\nstruct eth_tx_bd *reg_bd = &((txbd + 2)->reg_bd);\r\nstart_bd->addr_hi = cpu_to_le32((u64) buf_map >> 32);\r\nstart_bd->addr_lo = cpu_to_le32(buf_map & 0xffffffff);\r\nreg_bd->addr_hi = start_bd->addr_hi;\r\nreg_bd->addr_lo = start_bd->addr_lo + 0x10;\r\nstart_bd->nbytes = cpu_to_le16(0x10);\r\nstart_bd->nbd = cpu_to_le16(3);\r\nstart_bd->bd_flags.as_bitfield = ETH_TX_BD_FLAGS_START_BD;\r\nstart_bd->general_data &= ~ETH_TX_START_BD_PARSE_NBDS;\r\nstart_bd->general_data |= (1 << ETH_TX_START_BD_HDR_NBDS_SHIFT);\r\nif (BNX2X_CHIP_IS_E2_PLUS(bp))\r\npbd_e2->parsing_data = (UNICAST_ADDRESS <<\r\nETH_TX_PARSE_BD_E2_ETH_ADDR_TYPE_SHIFT);\r\nelse\r\npbd_e1x->global_data = (UNICAST_ADDRESS <<\r\nETH_TX_PARSE_BD_E1X_ETH_ADDR_TYPE_SHIFT);\r\n}\r\nval = (u64) ring_map >> 32;\r\ntxbd->next_bd.addr_hi = cpu_to_le32(val);\r\ndata->tx.tx_bd_page_base.hi = cpu_to_le32(val);\r\nval = (u64) ring_map & 0xffffffff;\r\ntxbd->next_bd.addr_lo = cpu_to_le32(val);\r\ndata->tx.tx_bd_page_base.lo = cpu_to_le32(val);\r\ndata->tx.tx_sb_index_number = HC_SP_INDEX_ETH_ISCSI_CQ_CONS;\r\ndata->tx.tx_status_block_id = BNX2X_DEF_SB_ID;\r\nif (cli < MAX_STAT_COUNTER_ID) {\r\ndata->general.statistics_zero_flg = 1;\r\ndata->general.statistics_en_flg = 1;\r\ndata->general.statistics_counter_id = cli;\r\n}\r\ncp->tx_cons_ptr =\r\n&sb->sp_sb.index_values[HC_SP_INDEX_ETH_ISCSI_CQ_CONS];\r\n}\r\nstatic void cnic_init_bnx2x_rx_ring(struct cnic_dev *dev,\r\nstruct client_init_ramrod_data *data)\r\n{\r\nstruct cnic_local *cp = dev->cnic_priv;\r\nstruct bnx2x *bp = netdev_priv(dev->netdev);\r\nstruct cnic_uio_dev *udev = cp->udev;\r\nstruct eth_rx_bd *rxbd = (struct eth_rx_bd *) (udev->l2_ring +\r\nCNIC_PAGE_SIZE);\r\nstruct eth_rx_cqe_next_page *rxcqe = (struct eth_rx_cqe_next_page *)\r\n(udev->l2_ring + (2 * CNIC_PAGE_SIZE));\r\nstruct host_sp_status_block *sb = cp->bnx2x_def_status_blk;\r\nint i;\r\nu32 cli = cp->ethdev->iscsi_l2_client_id;\r\nint cl_qzone_id = BNX2X_CL_QZONE_ID(bp, cli);\r\nu32 val;\r\ndma_addr_t ring_map = udev->l2_ring_map;\r\ndata->general.client_id = cli;\r\ndata->general.activate_flg = 1;\r\ndata->general.sp_client_id = cli;\r\ndata->general.mtu = cpu_to_le16(cp->l2_single_buf_size - 14);\r\ndata->general.func_id = bp->pfid;\r\nfor (i = 0; i < BNX2X_MAX_RX_DESC_CNT; i++, rxbd++) {\r\ndma_addr_t buf_map;\r\nint n = (i % cp->l2_rx_ring_size) + 1;\r\nbuf_map = udev->l2_buf_map + (n * cp->l2_single_buf_size);\r\nrxbd->addr_hi = cpu_to_le32((u64) buf_map >> 32);\r\nrxbd->addr_lo = cpu_to_le32(buf_map & 0xffffffff);\r\n}\r\nval = (u64) (ring_map + CNIC_PAGE_SIZE) >> 32;\r\nrxbd->addr_hi = cpu_to_le32(val);\r\ndata->rx.bd_page_base.hi = cpu_to_le32(val);\r\nval = (u64) (ring_map + CNIC_PAGE_SIZE) & 0xffffffff;\r\nrxbd->addr_lo = cpu_to_le32(val);\r\ndata->rx.bd_page_base.lo = cpu_to_le32(val);\r\nrxcqe += BNX2X_MAX_RCQ_DESC_CNT;\r\nval = (u64) (ring_map + (2 * CNIC_PAGE_SIZE)) >> 32;\r\nrxcqe->addr_hi = cpu_to_le32(val);\r\ndata->rx.cqe_page_base.hi = cpu_to_le32(val);\r\nval = (u64) (ring_map + (2 * CNIC_PAGE_SIZE)) & 0xffffffff;\r\nrxcqe->addr_lo = cpu_to_le32(val);\r\ndata->rx.cqe_page_base.lo = cpu_to_le32(val);\r\ndata->rx.client_qzone_id = cl_qzone_id;\r\ndata->rx.rx_sb_index_number = HC_SP_INDEX_ETH_ISCSI_RX_CQ_CONS;\r\ndata->rx.status_block_id = BNX2X_DEF_SB_ID;\r\ndata->rx.cache_line_alignment_log_size = L1_CACHE_SHIFT;\r\ndata->rx.max_bytes_on_bd = cpu_to_le16(cp->l2_single_buf_size);\r\ndata->rx.outer_vlan_removal_enable_flg = 1;\r\ndata->rx.silent_vlan_removal_flg = 1;\r\ndata->rx.silent_vlan_value = 0;\r\ndata->rx.silent_vlan_mask = 0xffff;\r\ncp->rx_cons_ptr =\r\n&sb->sp_sb.index_values[HC_SP_INDEX_ETH_ISCSI_RX_CQ_CONS];\r\ncp->rx_cons = *cp->rx_cons_ptr;\r\n}\r\nstatic void cnic_init_bnx2x_kcq(struct cnic_dev *dev)\r\n{\r\nstruct cnic_local *cp = dev->cnic_priv;\r\nstruct bnx2x *bp = netdev_priv(dev->netdev);\r\nu32 pfid = bp->pfid;\r\ncp->kcq1.io_addr = BAR_CSTRORM_INTMEM +\r\nCSTORM_ISCSI_EQ_PROD_OFFSET(pfid, 0);\r\ncp->kcq1.sw_prod_idx = 0;\r\nif (BNX2X_CHIP_IS_E2_PLUS(bp)) {\r\nstruct host_hc_status_block_e2 *sb = cp->status_blk.gen;\r\ncp->kcq1.hw_prod_idx_ptr =\r\n&sb->sb.index_values[HC_INDEX_ISCSI_EQ_CONS];\r\ncp->kcq1.status_idx_ptr =\r\n&sb->sb.running_index[SM_RX_ID];\r\n} else {\r\nstruct host_hc_status_block_e1x *sb = cp->status_blk.gen;\r\ncp->kcq1.hw_prod_idx_ptr =\r\n&sb->sb.index_values[HC_INDEX_ISCSI_EQ_CONS];\r\ncp->kcq1.status_idx_ptr =\r\n&sb->sb.running_index[SM_RX_ID];\r\n}\r\nif (BNX2X_CHIP_IS_E2_PLUS(bp)) {\r\nstruct host_hc_status_block_e2 *sb = cp->status_blk.gen;\r\ncp->kcq2.io_addr = BAR_USTRORM_INTMEM +\r\nUSTORM_FCOE_EQ_PROD_OFFSET(pfid);\r\ncp->kcq2.sw_prod_idx = 0;\r\ncp->kcq2.hw_prod_idx_ptr =\r\n&sb->sb.index_values[HC_INDEX_FCOE_EQ_CONS];\r\ncp->kcq2.status_idx_ptr =\r\n&sb->sb.running_index[SM_RX_ID];\r\n}\r\n}\r\nstatic int cnic_start_bnx2x_hw(struct cnic_dev *dev)\r\n{\r\nstruct cnic_local *cp = dev->cnic_priv;\r\nstruct bnx2x *bp = netdev_priv(dev->netdev);\r\nstruct cnic_eth_dev *ethdev = cp->ethdev;\r\nint func, ret;\r\nu32 pfid;\r\ndev->stats_addr = ethdev->addr_drv_info_to_mcp;\r\ncp->func = bp->pf_num;\r\nfunc = CNIC_FUNC(cp);\r\npfid = bp->pfid;\r\nret = cnic_init_id_tbl(&cp->cid_tbl, MAX_ISCSI_TBL_SZ,\r\ncp->iscsi_start_cid, 0);\r\nif (ret)\r\nreturn -ENOMEM;\r\nif (BNX2X_CHIP_IS_E2_PLUS(bp)) {\r\nret = cnic_init_id_tbl(&cp->fcoe_cid_tbl, dev->max_fcoe_conn,\r\ncp->fcoe_start_cid, 0);\r\nif (ret)\r\nreturn -ENOMEM;\r\n}\r\ncp->bnx2x_igu_sb_id = ethdev->irq_arr[0].status_blk_num2;\r\ncnic_init_bnx2x_kcq(dev);\r\nCNIC_WR16(dev, cp->kcq1.io_addr, MAX_KCQ_IDX);\r\nCNIC_WR(dev, BAR_CSTRORM_INTMEM +\r\nCSTORM_ISCSI_EQ_CONS_OFFSET(pfid, 0), 0);\r\nCNIC_WR(dev, BAR_CSTRORM_INTMEM +\r\nCSTORM_ISCSI_EQ_NEXT_PAGE_ADDR_OFFSET(pfid, 0),\r\ncp->kcq1.dma.pg_map_arr[1] & 0xffffffff);\r\nCNIC_WR(dev, BAR_CSTRORM_INTMEM +\r\nCSTORM_ISCSI_EQ_NEXT_PAGE_ADDR_OFFSET(pfid, 0) + 4,\r\n(u64) cp->kcq1.dma.pg_map_arr[1] >> 32);\r\nCNIC_WR(dev, BAR_CSTRORM_INTMEM +\r\nCSTORM_ISCSI_EQ_NEXT_EQE_ADDR_OFFSET(pfid, 0),\r\ncp->kcq1.dma.pg_map_arr[0] & 0xffffffff);\r\nCNIC_WR(dev, BAR_CSTRORM_INTMEM +\r\nCSTORM_ISCSI_EQ_NEXT_EQE_ADDR_OFFSET(pfid, 0) + 4,\r\n(u64) cp->kcq1.dma.pg_map_arr[0] >> 32);\r\nCNIC_WR8(dev, BAR_CSTRORM_INTMEM +\r\nCSTORM_ISCSI_EQ_NEXT_PAGE_ADDR_VALID_OFFSET(pfid, 0), 1);\r\nCNIC_WR16(dev, BAR_CSTRORM_INTMEM +\r\nCSTORM_ISCSI_EQ_SB_NUM_OFFSET(pfid, 0), cp->status_blk_num);\r\nCNIC_WR8(dev, BAR_CSTRORM_INTMEM +\r\nCSTORM_ISCSI_EQ_SB_INDEX_OFFSET(pfid, 0),\r\nHC_INDEX_ISCSI_EQ_CONS);\r\nCNIC_WR(dev, BAR_USTRORM_INTMEM +\r\nUSTORM_ISCSI_GLOBAL_BUF_PHYS_ADDR_OFFSET(pfid),\r\ncp->gbl_buf_info.pg_map_arr[0] & 0xffffffff);\r\nCNIC_WR(dev, BAR_USTRORM_INTMEM +\r\nUSTORM_ISCSI_GLOBAL_BUF_PHYS_ADDR_OFFSET(pfid) + 4,\r\n(u64) cp->gbl_buf_info.pg_map_arr[0] >> 32);\r\nCNIC_WR(dev, BAR_TSTRORM_INTMEM +\r\nTSTORM_ISCSI_TCP_LOCAL_ADV_WND_OFFSET(pfid), DEF_RCV_BUF);\r\ncnic_setup_bnx2x_context(dev);\r\nret = cnic_init_bnx2x_irq(dev);\r\nif (ret)\r\nreturn ret;\r\nethdev->drv_state |= CNIC_DRV_STATE_HANDLES_IRQ;\r\nreturn 0;\r\n}\r\nstatic void cnic_init_rings(struct cnic_dev *dev)\r\n{\r\nstruct cnic_local *cp = dev->cnic_priv;\r\nstruct bnx2x *bp = netdev_priv(dev->netdev);\r\nstruct cnic_uio_dev *udev = cp->udev;\r\nif (test_bit(CNIC_LCL_FL_RINGS_INITED, &cp->cnic_local_flags))\r\nreturn;\r\nif (test_bit(CNIC_F_BNX2_CLASS, &dev->flags)) {\r\ncnic_init_bnx2_tx_ring(dev);\r\ncnic_init_bnx2_rx_ring(dev);\r\nset_bit(CNIC_LCL_FL_RINGS_INITED, &cp->cnic_local_flags);\r\n} else if (test_bit(CNIC_F_BNX2X_CLASS, &dev->flags)) {\r\nu32 cli = cp->ethdev->iscsi_l2_client_id;\r\nu32 cid = cp->ethdev->iscsi_l2_cid;\r\nu32 cl_qzone_id;\r\nstruct client_init_ramrod_data *data;\r\nunion l5cm_specific_data l5_data;\r\nstruct ustorm_eth_rx_producers rx_prods = {0};\r\nu32 off, i, *cid_ptr;\r\nrx_prods.bd_prod = 0;\r\nrx_prods.cqe_prod = BNX2X_MAX_RCQ_DESC_CNT;\r\nbarrier();\r\ncl_qzone_id = BNX2X_CL_QZONE_ID(bp, cli);\r\noff = BAR_USTRORM_INTMEM +\r\n(BNX2X_CHIP_IS_E2_PLUS(bp) ?\r\nUSTORM_RX_PRODS_E2_OFFSET(cl_qzone_id) :\r\nUSTORM_RX_PRODS_E1X_OFFSET(BP_PORT(bp), cli));\r\nfor (i = 0; i < sizeof(struct ustorm_eth_rx_producers) / 4; i++)\r\nCNIC_WR(dev, off + i * 4, ((u32 *) &rx_prods)[i]);\r\nset_bit(CNIC_LCL_FL_L2_WAIT, &cp->cnic_local_flags);\r\ndata = udev->l2_buf;\r\ncid_ptr = udev->l2_buf + 12;\r\nmemset(data, 0, sizeof(*data));\r\ncnic_init_bnx2x_tx_ring(dev, data);\r\ncnic_init_bnx2x_rx_ring(dev, data);\r\nl5_data.phy_address.lo = udev->l2_buf_map & 0xffffffff;\r\nl5_data.phy_address.hi = (u64) udev->l2_buf_map >> 32;\r\nset_bit(CNIC_LCL_FL_RINGS_INITED, &cp->cnic_local_flags);\r\ncnic_submit_kwqe_16(dev, RAMROD_CMD_ID_ETH_CLIENT_SETUP,\r\ncid, ETH_CONNECTION_TYPE, &l5_data);\r\ni = 0;\r\nwhile (test_bit(CNIC_LCL_FL_L2_WAIT, &cp->cnic_local_flags) &&\r\n++i < 10)\r\nmsleep(1);\r\nif (test_bit(CNIC_LCL_FL_L2_WAIT, &cp->cnic_local_flags))\r\nnetdev_err(dev->netdev,\r\n"iSCSI CLIENT_SETUP did not complete\n");\r\ncnic_spq_completion(dev, DRV_CTL_RET_L2_SPQ_CREDIT_CMD, 1);\r\ncnic_ring_ctl(dev, cid, cli, 1);\r\n*cid_ptr = cid >> 4;\r\n*(cid_ptr + 1) = cid * bp->db_size;\r\n*(cid_ptr + 2) = UIO_USE_TX_DOORBELL;\r\n}\r\n}\r\nstatic void cnic_shutdown_rings(struct cnic_dev *dev)\r\n{\r\nstruct cnic_local *cp = dev->cnic_priv;\r\nstruct cnic_uio_dev *udev = cp->udev;\r\nvoid *rx_ring;\r\nif (!test_bit(CNIC_LCL_FL_RINGS_INITED, &cp->cnic_local_flags))\r\nreturn;\r\nif (test_bit(CNIC_F_BNX2_CLASS, &dev->flags)) {\r\ncnic_shutdown_bnx2_rx_ring(dev);\r\n} else if (test_bit(CNIC_F_BNX2X_CLASS, &dev->flags)) {\r\nu32 cli = cp->ethdev->iscsi_l2_client_id;\r\nu32 cid = cp->ethdev->iscsi_l2_cid;\r\nunion l5cm_specific_data l5_data;\r\nint i;\r\ncnic_ring_ctl(dev, cid, cli, 0);\r\nset_bit(CNIC_LCL_FL_L2_WAIT, &cp->cnic_local_flags);\r\nl5_data.phy_address.lo = cli;\r\nl5_data.phy_address.hi = 0;\r\ncnic_submit_kwqe_16(dev, RAMROD_CMD_ID_ETH_HALT,\r\ncid, ETH_CONNECTION_TYPE, &l5_data);\r\ni = 0;\r\nwhile (test_bit(CNIC_LCL_FL_L2_WAIT, &cp->cnic_local_flags) &&\r\n++i < 10)\r\nmsleep(1);\r\nif (test_bit(CNIC_LCL_FL_L2_WAIT, &cp->cnic_local_flags))\r\nnetdev_err(dev->netdev,\r\n"iSCSI CLIENT_HALT did not complete\n");\r\ncnic_spq_completion(dev, DRV_CTL_RET_L2_SPQ_CREDIT_CMD, 1);\r\nmemset(&l5_data, 0, sizeof(l5_data));\r\ncnic_submit_kwqe_16(dev, RAMROD_CMD_ID_COMMON_CFC_DEL,\r\ncid, NONE_CONNECTION_TYPE, &l5_data);\r\nmsleep(10);\r\n}\r\nclear_bit(CNIC_LCL_FL_RINGS_INITED, &cp->cnic_local_flags);\r\nrx_ring = udev->l2_ring + CNIC_PAGE_SIZE;\r\nmemset(rx_ring, 0, CNIC_PAGE_SIZE);\r\n}\r\nstatic int cnic_register_netdev(struct cnic_dev *dev)\r\n{\r\nstruct cnic_local *cp = dev->cnic_priv;\r\nstruct cnic_eth_dev *ethdev = cp->ethdev;\r\nint err;\r\nif (!ethdev)\r\nreturn -ENODEV;\r\nif (ethdev->drv_state & CNIC_DRV_STATE_REGD)\r\nreturn 0;\r\nerr = ethdev->drv_register_cnic(dev->netdev, cp->cnic_ops, dev);\r\nif (err)\r\nnetdev_err(dev->netdev, "register_cnic failed\n");\r\ndev->max_iscsi_conn = ethdev->max_iscsi_conn;\r\nif (ethdev->drv_state & CNIC_DRV_STATE_NO_ISCSI)\r\ndev->max_iscsi_conn = 0;\r\nreturn err;\r\n}\r\nstatic void cnic_unregister_netdev(struct cnic_dev *dev)\r\n{\r\nstruct cnic_local *cp = dev->cnic_priv;\r\nstruct cnic_eth_dev *ethdev = cp->ethdev;\r\nif (!ethdev)\r\nreturn;\r\nethdev->drv_unregister_cnic(dev->netdev);\r\n}\r\nstatic int cnic_start_hw(struct cnic_dev *dev)\r\n{\r\nstruct cnic_local *cp = dev->cnic_priv;\r\nstruct cnic_eth_dev *ethdev = cp->ethdev;\r\nint err;\r\nif (test_bit(CNIC_F_CNIC_UP, &dev->flags))\r\nreturn -EALREADY;\r\ndev->regview = ethdev->io_base;\r\npci_dev_get(dev->pcidev);\r\ncp->func = PCI_FUNC(dev->pcidev->devfn);\r\ncp->status_blk.gen = ethdev->irq_arr[0].status_blk;\r\ncp->status_blk_num = ethdev->irq_arr[0].status_blk_num;\r\nerr = cp->alloc_resc(dev);\r\nif (err) {\r\nnetdev_err(dev->netdev, "allocate resource failure\n");\r\ngoto err1;\r\n}\r\nerr = cp->start_hw(dev);\r\nif (err)\r\ngoto err1;\r\nerr = cnic_cm_open(dev);\r\nif (err)\r\ngoto err1;\r\nset_bit(CNIC_F_CNIC_UP, &dev->flags);\r\ncp->enable_int(dev);\r\nreturn 0;\r\nerr1:\r\ncp->free_resc(dev);\r\npci_dev_put(dev->pcidev);\r\nreturn err;\r\n}\r\nstatic void cnic_stop_bnx2_hw(struct cnic_dev *dev)\r\n{\r\ncnic_disable_bnx2_int_sync(dev);\r\ncnic_reg_wr_ind(dev, BNX2_CP_SCRATCH + 0x20, 0);\r\ncnic_reg_wr_ind(dev, BNX2_COM_SCRATCH + 0x20, 0);\r\ncnic_init_context(dev, KWQ_CID);\r\ncnic_init_context(dev, KCQ_CID);\r\ncnic_setup_5709_context(dev, 0);\r\ncnic_free_irq(dev);\r\ncnic_free_resc(dev);\r\n}\r\nstatic void cnic_stop_bnx2x_hw(struct cnic_dev *dev)\r\n{\r\nstruct cnic_local *cp = dev->cnic_priv;\r\nstruct bnx2x *bp = netdev_priv(dev->netdev);\r\nu32 hc_index = HC_INDEX_ISCSI_EQ_CONS;\r\nu32 sb_id = cp->status_blk_num;\r\nu32 idx_off, syn_off;\r\ncnic_free_irq(dev);\r\nif (BNX2X_CHIP_IS_E2_PLUS(bp)) {\r\nidx_off = offsetof(struct hc_status_block_e2, index_values) +\r\n(hc_index * sizeof(u16));\r\nsyn_off = CSTORM_HC_SYNC_LINE_INDEX_E2_OFFSET(hc_index, sb_id);\r\n} else {\r\nidx_off = offsetof(struct hc_status_block_e1x, index_values) +\r\n(hc_index * sizeof(u16));\r\nsyn_off = CSTORM_HC_SYNC_LINE_INDEX_E1X_OFFSET(hc_index, sb_id);\r\n}\r\nCNIC_WR16(dev, BAR_CSTRORM_INTMEM + syn_off, 0);\r\nCNIC_WR16(dev, BAR_CSTRORM_INTMEM + CSTORM_STATUS_BLOCK_OFFSET(sb_id) +\r\nidx_off, 0);\r\n*cp->kcq1.hw_prod_idx_ptr = 0;\r\nCNIC_WR(dev, BAR_CSTRORM_INTMEM +\r\nCSTORM_ISCSI_EQ_CONS_OFFSET(bp->pfid, 0), 0);\r\nCNIC_WR16(dev, cp->kcq1.io_addr, 0);\r\ncnic_free_resc(dev);\r\n}\r\nstatic void cnic_stop_hw(struct cnic_dev *dev)\r\n{\r\nif (test_bit(CNIC_F_CNIC_UP, &dev->flags)) {\r\nstruct cnic_local *cp = dev->cnic_priv;\r\nint i = 0;\r\nwhile (cp->udev && cp->udev->uio_dev != -1 && i < 15) {\r\nmsleep(100);\r\ni++;\r\n}\r\ncnic_shutdown_rings(dev);\r\ncp->stop_cm(dev);\r\ncp->ethdev->drv_state &= ~CNIC_DRV_STATE_HANDLES_IRQ;\r\nclear_bit(CNIC_F_CNIC_UP, &dev->flags);\r\nRCU_INIT_POINTER(cp->ulp_ops[CNIC_ULP_L4], NULL);\r\nsynchronize_rcu();\r\ncnic_cm_shutdown(dev);\r\ncp->stop_hw(dev);\r\npci_dev_put(dev->pcidev);\r\n}\r\n}\r\nstatic void cnic_free_dev(struct cnic_dev *dev)\r\n{\r\nint i = 0;\r\nwhile ((atomic_read(&dev->ref_count) != 0) && i < 10) {\r\nmsleep(100);\r\ni++;\r\n}\r\nif (atomic_read(&dev->ref_count) != 0)\r\nnetdev_err(dev->netdev, "Failed waiting for ref count to go to zero\n");\r\nnetdev_info(dev->netdev, "Removed CNIC device\n");\r\ndev_put(dev->netdev);\r\nkfree(dev);\r\n}\r\nstatic int cnic_get_fc_npiv_tbl(struct cnic_dev *dev,\r\nstruct cnic_fc_npiv_tbl *npiv_tbl)\r\n{\r\nstruct cnic_local *cp = dev->cnic_priv;\r\nstruct bnx2x *bp = netdev_priv(dev->netdev);\r\nint ret;\r\nif (!test_bit(CNIC_F_CNIC_UP, &dev->flags))\r\nreturn -EAGAIN;\r\nif (!BNX2X_CHIP_IS_E2_PLUS(bp))\r\nreturn -EINVAL;\r\nret = cp->ethdev->drv_get_fc_npiv_tbl(dev->netdev, npiv_tbl);\r\nreturn ret;\r\n}\r\nstatic struct cnic_dev *cnic_alloc_dev(struct net_device *dev,\r\nstruct pci_dev *pdev)\r\n{\r\nstruct cnic_dev *cdev;\r\nstruct cnic_local *cp;\r\nint alloc_size;\r\nalloc_size = sizeof(struct cnic_dev) + sizeof(struct cnic_local);\r\ncdev = kzalloc(alloc_size, GFP_KERNEL);\r\nif (cdev == NULL)\r\nreturn NULL;\r\ncdev->netdev = dev;\r\ncdev->cnic_priv = (char *)cdev + sizeof(struct cnic_dev);\r\ncdev->register_device = cnic_register_device;\r\ncdev->unregister_device = cnic_unregister_device;\r\ncdev->iscsi_nl_msg_recv = cnic_iscsi_nl_msg_recv;\r\ncdev->get_fc_npiv_tbl = cnic_get_fc_npiv_tbl;\r\ncp = cdev->cnic_priv;\r\ncp->dev = cdev;\r\ncp->l2_single_buf_size = 0x400;\r\ncp->l2_rx_ring_size = 3;\r\nspin_lock_init(&cp->cnic_ulp_lock);\r\nnetdev_info(dev, "Added CNIC device\n");\r\nreturn cdev;\r\n}\r\nstatic struct cnic_dev *init_bnx2_cnic(struct net_device *dev)\r\n{\r\nstruct pci_dev *pdev;\r\nstruct cnic_dev *cdev;\r\nstruct cnic_local *cp;\r\nstruct bnx2 *bp = netdev_priv(dev);\r\nstruct cnic_eth_dev *ethdev = NULL;\r\nif (bp->cnic_probe)\r\nethdev = (bp->cnic_probe)(dev);\r\nif (!ethdev)\r\nreturn NULL;\r\npdev = ethdev->pdev;\r\nif (!pdev)\r\nreturn NULL;\r\ndev_hold(dev);\r\npci_dev_get(pdev);\r\nif ((pdev->device == PCI_DEVICE_ID_NX2_5709 ||\r\npdev->device == PCI_DEVICE_ID_NX2_5709S) &&\r\n(pdev->revision < 0x10)) {\r\npci_dev_put(pdev);\r\ngoto cnic_err;\r\n}\r\npci_dev_put(pdev);\r\ncdev = cnic_alloc_dev(dev, pdev);\r\nif (cdev == NULL)\r\ngoto cnic_err;\r\nset_bit(CNIC_F_BNX2_CLASS, &cdev->flags);\r\ncdev->submit_kwqes = cnic_submit_bnx2_kwqes;\r\ncp = cdev->cnic_priv;\r\ncp->ethdev = ethdev;\r\ncdev->pcidev = pdev;\r\ncp->chip_id = ethdev->chip_id;\r\ncdev->max_iscsi_conn = ethdev->max_iscsi_conn;\r\ncp->cnic_ops = &cnic_bnx2_ops;\r\ncp->start_hw = cnic_start_bnx2_hw;\r\ncp->stop_hw = cnic_stop_bnx2_hw;\r\ncp->setup_pgtbl = cnic_setup_page_tbl;\r\ncp->alloc_resc = cnic_alloc_bnx2_resc;\r\ncp->free_resc = cnic_free_resc;\r\ncp->start_cm = cnic_cm_init_bnx2_hw;\r\ncp->stop_cm = cnic_cm_stop_bnx2_hw;\r\ncp->enable_int = cnic_enable_bnx2_int;\r\ncp->disable_int_sync = cnic_disable_bnx2_int_sync;\r\ncp->close_conn = cnic_close_bnx2_conn;\r\nreturn cdev;\r\ncnic_err:\r\ndev_put(dev);\r\nreturn NULL;\r\n}\r\nstatic struct cnic_dev *init_bnx2x_cnic(struct net_device *dev)\r\n{\r\nstruct pci_dev *pdev;\r\nstruct cnic_dev *cdev;\r\nstruct cnic_local *cp;\r\nstruct bnx2x *bp = netdev_priv(dev);\r\nstruct cnic_eth_dev *ethdev = NULL;\r\nif (bp->cnic_probe)\r\nethdev = bp->cnic_probe(dev);\r\nif (!ethdev)\r\nreturn NULL;\r\npdev = ethdev->pdev;\r\nif (!pdev)\r\nreturn NULL;\r\ndev_hold(dev);\r\ncdev = cnic_alloc_dev(dev, pdev);\r\nif (cdev == NULL) {\r\ndev_put(dev);\r\nreturn NULL;\r\n}\r\nset_bit(CNIC_F_BNX2X_CLASS, &cdev->flags);\r\ncdev->submit_kwqes = cnic_submit_bnx2x_kwqes;\r\ncp = cdev->cnic_priv;\r\ncp->ethdev = ethdev;\r\ncdev->pcidev = pdev;\r\ncp->chip_id = ethdev->chip_id;\r\ncdev->stats_addr = ethdev->addr_drv_info_to_mcp;\r\nif (!(ethdev->drv_state & CNIC_DRV_STATE_NO_ISCSI))\r\ncdev->max_iscsi_conn = ethdev->max_iscsi_conn;\r\nif (CNIC_SUPPORTS_FCOE(bp)) {\r\ncdev->max_fcoe_conn = ethdev->max_fcoe_conn;\r\ncdev->max_fcoe_exchanges = ethdev->max_fcoe_exchanges;\r\n}\r\nif (cdev->max_fcoe_conn > BNX2X_FCOE_NUM_CONNECTIONS)\r\ncdev->max_fcoe_conn = BNX2X_FCOE_NUM_CONNECTIONS;\r\nmemcpy(cdev->mac_addr, ethdev->iscsi_mac, ETH_ALEN);\r\ncp->cnic_ops = &cnic_bnx2x_ops;\r\ncp->start_hw = cnic_start_bnx2x_hw;\r\ncp->stop_hw = cnic_stop_bnx2x_hw;\r\ncp->setup_pgtbl = cnic_setup_page_tbl_le;\r\ncp->alloc_resc = cnic_alloc_bnx2x_resc;\r\ncp->free_resc = cnic_free_resc;\r\ncp->start_cm = cnic_cm_init_bnx2x_hw;\r\ncp->stop_cm = cnic_cm_stop_bnx2x_hw;\r\ncp->enable_int = cnic_enable_bnx2x_int;\r\ncp->disable_int_sync = cnic_disable_bnx2x_int_sync;\r\nif (BNX2X_CHIP_IS_E2_PLUS(bp)) {\r\ncp->ack_int = cnic_ack_bnx2x_e2_msix;\r\ncp->arm_int = cnic_arm_bnx2x_e2_msix;\r\n} else {\r\ncp->ack_int = cnic_ack_bnx2x_msix;\r\ncp->arm_int = cnic_arm_bnx2x_msix;\r\n}\r\ncp->close_conn = cnic_close_bnx2x_conn;\r\nreturn cdev;\r\n}\r\nstatic struct cnic_dev *is_cnic_dev(struct net_device *dev)\r\n{\r\nstruct ethtool_drvinfo drvinfo;\r\nstruct cnic_dev *cdev = NULL;\r\nif (dev->ethtool_ops && dev->ethtool_ops->get_drvinfo) {\r\nmemset(&drvinfo, 0, sizeof(drvinfo));\r\ndev->ethtool_ops->get_drvinfo(dev, &drvinfo);\r\nif (!strcmp(drvinfo.driver, "bnx2"))\r\ncdev = init_bnx2_cnic(dev);\r\nif (!strcmp(drvinfo.driver, "bnx2x"))\r\ncdev = init_bnx2x_cnic(dev);\r\nif (cdev) {\r\nwrite_lock(&cnic_dev_lock);\r\nlist_add(&cdev->list, &cnic_dev_list);\r\nwrite_unlock(&cnic_dev_lock);\r\n}\r\n}\r\nreturn cdev;\r\n}\r\nstatic void cnic_rcv_netevent(struct cnic_local *cp, unsigned long event,\r\nu16 vlan_id)\r\n{\r\nint if_type;\r\nfor (if_type = 0; if_type < MAX_CNIC_ULP_TYPE; if_type++) {\r\nstruct cnic_ulp_ops *ulp_ops;\r\nvoid *ctx;\r\nmutex_lock(&cnic_lock);\r\nulp_ops = rcu_dereference_protected(cp->ulp_ops[if_type],\r\nlockdep_is_held(&cnic_lock));\r\nif (!ulp_ops || !ulp_ops->indicate_netevent) {\r\nmutex_unlock(&cnic_lock);\r\ncontinue;\r\n}\r\nctx = cp->ulp_handle[if_type];\r\nset_bit(ULP_F_CALL_PENDING, &cp->ulp_flags[if_type]);\r\nmutex_unlock(&cnic_lock);\r\nulp_ops->indicate_netevent(ctx, event, vlan_id);\r\nclear_bit(ULP_F_CALL_PENDING, &cp->ulp_flags[if_type]);\r\n}\r\n}\r\nstatic int cnic_netdev_event(struct notifier_block *this, unsigned long event,\r\nvoid *ptr)\r\n{\r\nstruct net_device *netdev = netdev_notifier_info_to_dev(ptr);\r\nstruct cnic_dev *dev;\r\nint new_dev = 0;\r\ndev = cnic_from_netdev(netdev);\r\nif (!dev && event == NETDEV_REGISTER) {\r\ndev = is_cnic_dev(netdev);\r\nif (dev) {\r\nnew_dev = 1;\r\ncnic_hold(dev);\r\n}\r\n}\r\nif (dev) {\r\nstruct cnic_local *cp = dev->cnic_priv;\r\nif (new_dev)\r\ncnic_ulp_init(dev);\r\nelse if (event == NETDEV_UNREGISTER)\r\ncnic_ulp_exit(dev);\r\nif (event == NETDEV_UP) {\r\nif (cnic_register_netdev(dev) != 0) {\r\ncnic_put(dev);\r\ngoto done;\r\n}\r\nif (!cnic_start_hw(dev))\r\ncnic_ulp_start(dev);\r\n}\r\ncnic_rcv_netevent(cp, event, 0);\r\nif (event == NETDEV_GOING_DOWN) {\r\ncnic_ulp_stop(dev);\r\ncnic_stop_hw(dev);\r\ncnic_unregister_netdev(dev);\r\n} else if (event == NETDEV_UNREGISTER) {\r\nwrite_lock(&cnic_dev_lock);\r\nlist_del_init(&dev->list);\r\nwrite_unlock(&cnic_dev_lock);\r\ncnic_put(dev);\r\ncnic_free_dev(dev);\r\ngoto done;\r\n}\r\ncnic_put(dev);\r\n} else {\r\nstruct net_device *realdev;\r\nu16 vid;\r\nvid = cnic_get_vlan(netdev, &realdev);\r\nif (realdev) {\r\ndev = cnic_from_netdev(realdev);\r\nif (dev) {\r\nvid |= VLAN_TAG_PRESENT;\r\ncnic_rcv_netevent(dev->cnic_priv, event, vid);\r\ncnic_put(dev);\r\n}\r\n}\r\n}\r\ndone:\r\nreturn NOTIFY_DONE;\r\n}\r\nstatic void cnic_release(void)\r\n{\r\nstruct cnic_uio_dev *udev;\r\nwhile (!list_empty(&cnic_udev_list)) {\r\nudev = list_entry(cnic_udev_list.next, struct cnic_uio_dev,\r\nlist);\r\ncnic_free_uio(udev);\r\n}\r\n}\r\nstatic int __init cnic_init(void)\r\n{\r\nint rc = 0;\r\npr_info("%s", version);\r\nrc = register_netdevice_notifier(&cnic_netdev_notifier);\r\nif (rc) {\r\ncnic_release();\r\nreturn rc;\r\n}\r\ncnic_wq = create_singlethread_workqueue("cnic_wq");\r\nif (!cnic_wq) {\r\ncnic_release();\r\nunregister_netdevice_notifier(&cnic_netdev_notifier);\r\nreturn -ENOMEM;\r\n}\r\nreturn 0;\r\n}\r\nstatic void __exit cnic_exit(void)\r\n{\r\nunregister_netdevice_notifier(&cnic_netdev_notifier);\r\ncnic_release();\r\ndestroy_workqueue(cnic_wq);\r\n}
