static int hym8563_rtc_read_time(struct device *dev, struct rtc_time *tm)\r\n{\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nstruct hym8563 *hym8563 = i2c_get_clientdata(client);\r\nu8 buf[7];\r\nint ret;\r\nif (!hym8563->valid) {\r\ndev_warn(&client->dev, "no valid clock/calendar values available\n");\r\nreturn -EPERM;\r\n}\r\nret = i2c_smbus_read_i2c_block_data(client, HYM8563_SEC, 7, buf);\r\ntm->tm_sec = bcd2bin(buf[0] & HYM8563_SEC_MASK);\r\ntm->tm_min = bcd2bin(buf[1] & HYM8563_MIN_MASK);\r\ntm->tm_hour = bcd2bin(buf[2] & HYM8563_HOUR_MASK);\r\ntm->tm_mday = bcd2bin(buf[3] & HYM8563_DAY_MASK);\r\ntm->tm_wday = bcd2bin(buf[4] & HYM8563_WEEKDAY_MASK);\r\ntm->tm_mon = bcd2bin(buf[5] & HYM8563_MONTH_MASK) - 1;\r\ntm->tm_year = bcd2bin(buf[6]) + 100;\r\nreturn 0;\r\n}\r\nstatic int hym8563_rtc_set_time(struct device *dev, struct rtc_time *tm)\r\n{\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nstruct hym8563 *hym8563 = i2c_get_clientdata(client);\r\nu8 buf[7];\r\nint ret;\r\nif (tm->tm_year < 100 || tm->tm_year >= 200)\r\nreturn -EINVAL;\r\nbuf[0] = bin2bcd(tm->tm_sec);\r\nbuf[1] = bin2bcd(tm->tm_min);\r\nbuf[2] = bin2bcd(tm->tm_hour);\r\nbuf[3] = bin2bcd(tm->tm_mday);\r\nbuf[4] = bin2bcd(tm->tm_wday);\r\nbuf[5] = bin2bcd(tm->tm_mon + 1);\r\nbuf[6] = tm->tm_year - 100;\r\nret = i2c_smbus_write_byte_data(client, HYM8563_CTL1,\r\nHYM8563_CTL1_STOP);\r\nif (ret < 0)\r\nreturn ret;\r\nret = i2c_smbus_write_i2c_block_data(client, HYM8563_SEC, 7, buf);\r\nif (ret < 0)\r\nreturn ret;\r\nret = i2c_smbus_write_byte_data(client, HYM8563_CTL1, 0);\r\nif (ret < 0)\r\nreturn ret;\r\nhym8563->valid = true;\r\nreturn 0;\r\n}\r\nstatic int hym8563_rtc_alarm_irq_enable(struct device *dev,\r\nunsigned int enabled)\r\n{\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nint data;\r\ndata = i2c_smbus_read_byte_data(client, HYM8563_CTL2);\r\nif (data < 0)\r\nreturn data;\r\nif (enabled)\r\ndata |= HYM8563_CTL2_AIE;\r\nelse\r\ndata &= ~HYM8563_CTL2_AIE;\r\nreturn i2c_smbus_write_byte_data(client, HYM8563_CTL2, data);\r\n}\r\nstatic int hym8563_rtc_read_alarm(struct device *dev, struct rtc_wkalrm *alm)\r\n{\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nstruct rtc_time *alm_tm = &alm->time;\r\nu8 buf[4];\r\nint ret;\r\nret = i2c_smbus_read_i2c_block_data(client, HYM8563_ALM_MIN, 4, buf);\r\nif (ret < 0)\r\nreturn ret;\r\nalm_tm->tm_sec = -1;\r\nalm_tm->tm_min = (buf[0] & HYM8563_ALM_BIT_DISABLE) ?\r\n-1 :\r\nbcd2bin(buf[0] & HYM8563_MIN_MASK);\r\nalm_tm->tm_hour = (buf[1] & HYM8563_ALM_BIT_DISABLE) ?\r\n-1 :\r\nbcd2bin(buf[1] & HYM8563_HOUR_MASK);\r\nalm_tm->tm_mday = (buf[2] & HYM8563_ALM_BIT_DISABLE) ?\r\n-1 :\r\nbcd2bin(buf[2] & HYM8563_DAY_MASK);\r\nalm_tm->tm_wday = (buf[3] & HYM8563_ALM_BIT_DISABLE) ?\r\n-1 :\r\nbcd2bin(buf[3] & HYM8563_WEEKDAY_MASK);\r\nalm_tm->tm_mon = -1;\r\nalm_tm->tm_year = -1;\r\nret = i2c_smbus_read_byte_data(client, HYM8563_CTL2);\r\nif (ret < 0)\r\nreturn ret;\r\nif (ret & HYM8563_CTL2_AIE)\r\nalm->enabled = 1;\r\nreturn 0;\r\n}\r\nstatic int hym8563_rtc_set_alarm(struct device *dev, struct rtc_wkalrm *alm)\r\n{\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nstruct rtc_time *alm_tm = &alm->time;\r\nu8 buf[4];\r\nint ret;\r\nif (alm_tm->tm_sec) {\r\nalm_tm->tm_sec = 0;\r\nalm_tm->tm_min++;\r\nif (alm_tm->tm_min >= 60) {\r\nalm_tm->tm_min = 0;\r\nalm_tm->tm_hour++;\r\nif (alm_tm->tm_hour >= 24) {\r\nalm_tm->tm_hour = 0;\r\nalm_tm->tm_mday++;\r\nif (alm_tm->tm_mday > 31)\r\nalm_tm->tm_mday = 0;\r\n}\r\n}\r\n}\r\nret = i2c_smbus_read_byte_data(client, HYM8563_CTL2);\r\nif (ret < 0)\r\nreturn ret;\r\nret &= ~HYM8563_CTL2_AIE;\r\nret = i2c_smbus_write_byte_data(client, HYM8563_CTL2, ret);\r\nif (ret < 0)\r\nreturn ret;\r\nbuf[0] = (alm_tm->tm_min < 60 && alm_tm->tm_min >= 0) ?\r\nbin2bcd(alm_tm->tm_min) : HYM8563_ALM_BIT_DISABLE;\r\nbuf[1] = (alm_tm->tm_hour < 24 && alm_tm->tm_hour >= 0) ?\r\nbin2bcd(alm_tm->tm_hour) : HYM8563_ALM_BIT_DISABLE;\r\nbuf[2] = (alm_tm->tm_mday <= 31 && alm_tm->tm_mday >= 1) ?\r\nbin2bcd(alm_tm->tm_mday) : HYM8563_ALM_BIT_DISABLE;\r\nbuf[3] = (alm_tm->tm_wday < 7 && alm_tm->tm_wday >= 0) ?\r\nbin2bcd(alm_tm->tm_wday) : HYM8563_ALM_BIT_DISABLE;\r\nret = i2c_smbus_write_i2c_block_data(client, HYM8563_ALM_MIN, 4, buf);\r\nif (ret < 0)\r\nreturn ret;\r\nreturn hym8563_rtc_alarm_irq_enable(dev, alm->enabled);\r\n}\r\nstatic unsigned long hym8563_clkout_recalc_rate(struct clk_hw *hw,\r\nunsigned long parent_rate)\r\n{\r\nstruct hym8563 *hym8563 = clkout_hw_to_hym8563(hw);\r\nstruct i2c_client *client = hym8563->client;\r\nint ret = i2c_smbus_read_byte_data(client, HYM8563_CLKOUT);\r\nif (ret < 0)\r\nreturn 0;\r\nret &= HYM8563_CLKOUT_MASK;\r\nreturn clkout_rates[ret];\r\n}\r\nstatic long hym8563_clkout_round_rate(struct clk_hw *hw, unsigned long rate,\r\nunsigned long *prate)\r\n{\r\nint i;\r\nfor (i = 0; i < ARRAY_SIZE(clkout_rates); i++)\r\nif (clkout_rates[i] <= rate)\r\nreturn clkout_rates[i];\r\nreturn 0;\r\n}\r\nstatic int hym8563_clkout_set_rate(struct clk_hw *hw, unsigned long rate,\r\nunsigned long parent_rate)\r\n{\r\nstruct hym8563 *hym8563 = clkout_hw_to_hym8563(hw);\r\nstruct i2c_client *client = hym8563->client;\r\nint ret = i2c_smbus_read_byte_data(client, HYM8563_CLKOUT);\r\nint i;\r\nif (ret < 0)\r\nreturn ret;\r\nfor (i = 0; i < ARRAY_SIZE(clkout_rates); i++)\r\nif (clkout_rates[i] == rate) {\r\nret &= ~HYM8563_CLKOUT_MASK;\r\nret |= i;\r\nreturn i2c_smbus_write_byte_data(client,\r\nHYM8563_CLKOUT, ret);\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int hym8563_clkout_control(struct clk_hw *hw, bool enable)\r\n{\r\nstruct hym8563 *hym8563 = clkout_hw_to_hym8563(hw);\r\nstruct i2c_client *client = hym8563->client;\r\nint ret = i2c_smbus_read_byte_data(client, HYM8563_CLKOUT);\r\nif (ret < 0)\r\nreturn ret;\r\nif (enable)\r\nret |= HYM8563_CLKOUT_ENABLE;\r\nelse\r\nret &= ~HYM8563_CLKOUT_ENABLE;\r\nreturn i2c_smbus_write_byte_data(client, HYM8563_CLKOUT, ret);\r\n}\r\nstatic int hym8563_clkout_prepare(struct clk_hw *hw)\r\n{\r\nreturn hym8563_clkout_control(hw, 1);\r\n}\r\nstatic void hym8563_clkout_unprepare(struct clk_hw *hw)\r\n{\r\nhym8563_clkout_control(hw, 0);\r\n}\r\nstatic int hym8563_clkout_is_prepared(struct clk_hw *hw)\r\n{\r\nstruct hym8563 *hym8563 = clkout_hw_to_hym8563(hw);\r\nstruct i2c_client *client = hym8563->client;\r\nint ret = i2c_smbus_read_byte_data(client, HYM8563_CLKOUT);\r\nif (ret < 0)\r\nreturn ret;\r\nreturn !!(ret & HYM8563_CLKOUT_ENABLE);\r\n}\r\nstatic struct clk *hym8563_clkout_register_clk(struct hym8563 *hym8563)\r\n{\r\nstruct i2c_client *client = hym8563->client;\r\nstruct device_node *node = client->dev.of_node;\r\nstruct clk *clk;\r\nstruct clk_init_data init;\r\nint ret;\r\nret = i2c_smbus_write_byte_data(client, HYM8563_CLKOUT,\r\n0);\r\nif (ret < 0)\r\nreturn ERR_PTR(ret);\r\ninit.name = "hym8563-clkout";\r\ninit.ops = &hym8563_clkout_ops;\r\ninit.flags = CLK_IS_ROOT;\r\ninit.parent_names = NULL;\r\ninit.num_parents = 0;\r\nhym8563->clkout_hw.init = &init;\r\nof_property_read_string(node, "clock-output-names", &init.name);\r\nclk = clk_register(&client->dev, &hym8563->clkout_hw);\r\nif (!IS_ERR(clk))\r\nof_clk_add_provider(node, of_clk_src_simple_get, clk);\r\nreturn clk;\r\n}\r\nstatic irqreturn_t hym8563_irq(int irq, void *dev_id)\r\n{\r\nstruct hym8563 *hym8563 = (struct hym8563 *)dev_id;\r\nstruct i2c_client *client = hym8563->client;\r\nstruct mutex *lock = &hym8563->rtc->ops_lock;\r\nint data, ret;\r\nmutex_lock(lock);\r\ndata = i2c_smbus_read_byte_data(client, HYM8563_CTL2);\r\nif (data < 0) {\r\ndev_err(&client->dev, "%s: error reading i2c data %d\n",\r\n__func__, data);\r\ngoto out;\r\n}\r\ndata &= ~HYM8563_CTL2_AF;\r\nret = i2c_smbus_write_byte_data(client, HYM8563_CTL2, data);\r\nif (ret < 0) {\r\ndev_err(&client->dev, "%s: error writing i2c data %d\n",\r\n__func__, ret);\r\n}\r\nout:\r\nmutex_unlock(lock);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int hym8563_init_device(struct i2c_client *client)\r\n{\r\nint ret;\r\nret = i2c_smbus_write_byte_data(client, HYM8563_CTL1, 0);\r\nif (ret < 0)\r\nreturn ret;\r\nret = i2c_smbus_read_byte_data(client, HYM8563_CTL2);\r\nif (ret < 0)\r\nreturn ret;\r\nret &= ~HYM8563_CTL2_AIE;\r\nret &= ~HYM8563_CTL2_TIE;\r\nif (ret & HYM8563_CTL2_AF)\r\nret &= ~HYM8563_CTL2_AF;\r\nif (ret & HYM8563_CTL2_TF)\r\nret &= ~HYM8563_CTL2_TF;\r\nret &= ~HYM8563_CTL2_TI_TP;\r\nreturn i2c_smbus_write_byte_data(client, HYM8563_CTL2, ret);\r\n}\r\nstatic int hym8563_suspend(struct device *dev)\r\n{\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nint ret;\r\nif (device_may_wakeup(dev)) {\r\nret = enable_irq_wake(client->irq);\r\nif (ret) {\r\ndev_err(dev, "enable_irq_wake failed, %d\n", ret);\r\nreturn ret;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int hym8563_resume(struct device *dev)\r\n{\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nif (device_may_wakeup(dev))\r\ndisable_irq_wake(client->irq);\r\nreturn 0;\r\n}\r\nstatic int hym8563_probe(struct i2c_client *client,\r\nconst struct i2c_device_id *id)\r\n{\r\nstruct hym8563 *hym8563;\r\nint ret;\r\nhym8563 = devm_kzalloc(&client->dev, sizeof(*hym8563), GFP_KERNEL);\r\nif (!hym8563)\r\nreturn -ENOMEM;\r\nhym8563->client = client;\r\ni2c_set_clientdata(client, hym8563);\r\ndevice_set_wakeup_capable(&client->dev, true);\r\nret = hym8563_init_device(client);\r\nif (ret) {\r\ndev_err(&client->dev, "could not init device, %d\n", ret);\r\nreturn ret;\r\n}\r\nif (client->irq > 0) {\r\nret = devm_request_threaded_irq(&client->dev, client->irq,\r\nNULL, hym8563_irq,\r\nIRQF_TRIGGER_LOW | IRQF_ONESHOT,\r\nclient->name, hym8563);\r\nif (ret < 0) {\r\ndev_err(&client->dev, "irq %d request failed, %d\n",\r\nclient->irq, ret);\r\nreturn ret;\r\n}\r\n}\r\nret = i2c_smbus_read_byte_data(client, HYM8563_SEC);\r\nif (ret < 0)\r\nreturn ret;\r\nhym8563->valid = !(ret & HYM8563_SEC_VL);\r\ndev_dbg(&client->dev, "rtc information is %s\n",\r\nhym8563->valid ? "valid" : "invalid");\r\nhym8563->rtc = devm_rtc_device_register(&client->dev, client->name,\r\n&hym8563_rtc_ops, THIS_MODULE);\r\nif (IS_ERR(hym8563->rtc))\r\nreturn PTR_ERR(hym8563->rtc);\r\nhym8563->rtc->uie_unsupported = 1;\r\n#ifdef CONFIG_COMMON_CLK\r\nhym8563_clkout_register_clk(hym8563);\r\n#endif\r\nreturn 0;\r\n}
