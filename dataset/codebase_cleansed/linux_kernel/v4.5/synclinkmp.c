static void* synclinkmp_get_text_ptr(void) {return synclinkmp_get_text_ptr;}\r\nstatic inline int sanity_check(SLMP_INFO *info,\r\nchar *name, const char *routine)\r\n{\r\n#ifdef SANITY_CHECK\r\nstatic const char *badmagic =\r\n"Warning: bad magic number for synclinkmp_struct (%s) in %s\n";\r\nstatic const char *badinfo =\r\n"Warning: null synclinkmp_struct for (%s) in %s\n";\r\nif (!info) {\r\nprintk(badinfo, name, routine);\r\nreturn 1;\r\n}\r\nif (info->magic != MGSL_MAGIC) {\r\nprintk(badmagic, name, routine);\r\nreturn 1;\r\n}\r\n#else\r\nif (!info)\r\nreturn 1;\r\n#endif\r\nreturn 0;\r\n}\r\nstatic void ldisc_receive_buf(struct tty_struct *tty,\r\nconst __u8 *data, char *flags, int count)\r\n{\r\nstruct tty_ldisc *ld;\r\nif (!tty)\r\nreturn;\r\nld = tty_ldisc_ref(tty);\r\nif (ld) {\r\nif (ld->ops->receive_buf)\r\nld->ops->receive_buf(tty, data, flags, count);\r\ntty_ldisc_deref(ld);\r\n}\r\n}\r\nstatic int install(struct tty_driver *driver, struct tty_struct *tty)\r\n{\r\nSLMP_INFO *info;\r\nint line = tty->index;\r\nif (line >= synclinkmp_device_count) {\r\nprintk("%s(%d): open with invalid line #%d.\n",\r\n__FILE__,__LINE__,line);\r\nreturn -ENODEV;\r\n}\r\ninfo = synclinkmp_device_list;\r\nwhile (info && info->line != line)\r\ninfo = info->next_device;\r\nif (sanity_check(info, tty->name, "open"))\r\nreturn -ENODEV;\r\nif (info->init_error) {\r\nprintk("%s(%d):%s device is not allocated, init error=%d\n",\r\n__FILE__, __LINE__, info->device_name,\r\ninfo->init_error);\r\nreturn -ENODEV;\r\n}\r\ntty->driver_data = info;\r\nreturn tty_port_install(&info->port, driver, tty);\r\n}\r\nstatic int open(struct tty_struct *tty, struct file *filp)\r\n{\r\nSLMP_INFO *info = tty->driver_data;\r\nunsigned long flags;\r\nint retval;\r\ninfo->port.tty = tty;\r\nif (debug_level >= DEBUG_LEVEL_INFO)\r\nprintk("%s(%d):%s open(), old ref count = %d\n",\r\n__FILE__,__LINE__,tty->driver->name, info->port.count);\r\ninfo->port.low_latency = (info->port.flags & ASYNC_LOW_LATENCY) ? 1 : 0;\r\nspin_lock_irqsave(&info->netlock, flags);\r\nif (info->netcount) {\r\nretval = -EBUSY;\r\nspin_unlock_irqrestore(&info->netlock, flags);\r\ngoto cleanup;\r\n}\r\ninfo->port.count++;\r\nspin_unlock_irqrestore(&info->netlock, flags);\r\nif (info->port.count == 1) {\r\nretval = startup(info);\r\nif (retval < 0)\r\ngoto cleanup;\r\n}\r\nretval = block_til_ready(tty, filp, info);\r\nif (retval) {\r\nif (debug_level >= DEBUG_LEVEL_INFO)\r\nprintk("%s(%d):%s block_til_ready() returned %d\n",\r\n__FILE__,__LINE__, info->device_name, retval);\r\ngoto cleanup;\r\n}\r\nif (debug_level >= DEBUG_LEVEL_INFO)\r\nprintk("%s(%d):%s open() success\n",\r\n__FILE__,__LINE__, info->device_name);\r\nretval = 0;\r\ncleanup:\r\nif (retval) {\r\nif (tty->count == 1)\r\ninfo->port.tty = NULL;\r\nif(info->port.count)\r\ninfo->port.count--;\r\n}\r\nreturn retval;\r\n}\r\nstatic void close(struct tty_struct *tty, struct file *filp)\r\n{\r\nSLMP_INFO * info = tty->driver_data;\r\nif (sanity_check(info, tty->name, "close"))\r\nreturn;\r\nif (debug_level >= DEBUG_LEVEL_INFO)\r\nprintk("%s(%d):%s close() entry, count=%d\n",\r\n__FILE__,__LINE__, info->device_name, info->port.count);\r\nif (tty_port_close_start(&info->port, tty, filp) == 0)\r\ngoto cleanup;\r\nmutex_lock(&info->port.mutex);\r\nif (info->port.flags & ASYNC_INITIALIZED)\r\nwait_until_sent(tty, info->timeout);\r\nflush_buffer(tty);\r\ntty_ldisc_flush(tty);\r\nshutdown(info);\r\nmutex_unlock(&info->port.mutex);\r\ntty_port_close_end(&info->port, tty);\r\ninfo->port.tty = NULL;\r\ncleanup:\r\nif (debug_level >= DEBUG_LEVEL_INFO)\r\nprintk("%s(%d):%s close() exit, count=%d\n", __FILE__,__LINE__,\r\ntty->driver->name, info->port.count);\r\n}\r\nstatic void hangup(struct tty_struct *tty)\r\n{\r\nSLMP_INFO *info = tty->driver_data;\r\nunsigned long flags;\r\nif (debug_level >= DEBUG_LEVEL_INFO)\r\nprintk("%s(%d):%s hangup()\n",\r\n__FILE__,__LINE__, info->device_name );\r\nif (sanity_check(info, tty->name, "hangup"))\r\nreturn;\r\nmutex_lock(&info->port.mutex);\r\nflush_buffer(tty);\r\nshutdown(info);\r\nspin_lock_irqsave(&info->port.lock, flags);\r\ninfo->port.count = 0;\r\ninfo->port.flags &= ~ASYNC_NORMAL_ACTIVE;\r\ninfo->port.tty = NULL;\r\nspin_unlock_irqrestore(&info->port.lock, flags);\r\nmutex_unlock(&info->port.mutex);\r\nwake_up_interruptible(&info->port.open_wait);\r\n}\r\nstatic void set_termios(struct tty_struct *tty, struct ktermios *old_termios)\r\n{\r\nSLMP_INFO *info = tty->driver_data;\r\nunsigned long flags;\r\nif (debug_level >= DEBUG_LEVEL_INFO)\r\nprintk("%s(%d):%s set_termios()\n", __FILE__,__LINE__,\r\ntty->driver->name );\r\nchange_params(info);\r\nif (old_termios->c_cflag & CBAUD &&\r\n!(tty->termios.c_cflag & CBAUD)) {\r\ninfo->serial_signals &= ~(SerialSignal_RTS | SerialSignal_DTR);\r\nspin_lock_irqsave(&info->lock,flags);\r\nset_signals(info);\r\nspin_unlock_irqrestore(&info->lock,flags);\r\n}\r\nif (!(old_termios->c_cflag & CBAUD) &&\r\ntty->termios.c_cflag & CBAUD) {\r\ninfo->serial_signals |= SerialSignal_DTR;\r\nif (!(tty->termios.c_cflag & CRTSCTS) ||\r\n!test_bit(TTY_THROTTLED, &tty->flags)) {\r\ninfo->serial_signals |= SerialSignal_RTS;\r\n}\r\nspin_lock_irqsave(&info->lock,flags);\r\nset_signals(info);\r\nspin_unlock_irqrestore(&info->lock,flags);\r\n}\r\nif (old_termios->c_cflag & CRTSCTS &&\r\n!(tty->termios.c_cflag & CRTSCTS)) {\r\ntty->hw_stopped = 0;\r\ntx_release(tty);\r\n}\r\n}\r\nstatic int write(struct tty_struct *tty,\r\nconst unsigned char *buf, int count)\r\n{\r\nint c, ret = 0;\r\nSLMP_INFO *info = tty->driver_data;\r\nunsigned long flags;\r\nif (debug_level >= DEBUG_LEVEL_INFO)\r\nprintk("%s(%d):%s write() count=%d\n",\r\n__FILE__,__LINE__,info->device_name,count);\r\nif (sanity_check(info, tty->name, "write"))\r\ngoto cleanup;\r\nif (!info->tx_buf)\r\ngoto cleanup;\r\nif (info->params.mode == MGSL_MODE_HDLC) {\r\nif (count > info->max_frame_size) {\r\nret = -EIO;\r\ngoto cleanup;\r\n}\r\nif (info->tx_active)\r\ngoto cleanup;\r\nif (info->tx_count) {\r\ntx_load_dma_buffer(info, info->tx_buf, info->tx_count);\r\ngoto start;\r\n}\r\nret = info->tx_count = count;\r\ntx_load_dma_buffer(info, buf, count);\r\ngoto start;\r\n}\r\nfor (;;) {\r\nc = min_t(int, count,\r\nmin(info->max_frame_size - info->tx_count - 1,\r\ninfo->max_frame_size - info->tx_put));\r\nif (c <= 0)\r\nbreak;\r\nmemcpy(info->tx_buf + info->tx_put, buf, c);\r\nspin_lock_irqsave(&info->lock,flags);\r\ninfo->tx_put += c;\r\nif (info->tx_put >= info->max_frame_size)\r\ninfo->tx_put -= info->max_frame_size;\r\ninfo->tx_count += c;\r\nspin_unlock_irqrestore(&info->lock,flags);\r\nbuf += c;\r\ncount -= c;\r\nret += c;\r\n}\r\nif (info->params.mode == MGSL_MODE_HDLC) {\r\nif (count) {\r\nret = info->tx_count = 0;\r\ngoto cleanup;\r\n}\r\ntx_load_dma_buffer(info, info->tx_buf, info->tx_count);\r\n}\r\nstart:\r\nif (info->tx_count && !tty->stopped && !tty->hw_stopped) {\r\nspin_lock_irqsave(&info->lock,flags);\r\nif (!info->tx_active)\r\ntx_start(info);\r\nspin_unlock_irqrestore(&info->lock,flags);\r\n}\r\ncleanup:\r\nif (debug_level >= DEBUG_LEVEL_INFO)\r\nprintk( "%s(%d):%s write() returning=%d\n",\r\n__FILE__,__LINE__,info->device_name,ret);\r\nreturn ret;\r\n}\r\nstatic int put_char(struct tty_struct *tty, unsigned char ch)\r\n{\r\nSLMP_INFO *info = tty->driver_data;\r\nunsigned long flags;\r\nint ret = 0;\r\nif ( debug_level >= DEBUG_LEVEL_INFO ) {\r\nprintk( "%s(%d):%s put_char(%d)\n",\r\n__FILE__,__LINE__,info->device_name,ch);\r\n}\r\nif (sanity_check(info, tty->name, "put_char"))\r\nreturn 0;\r\nif (!info->tx_buf)\r\nreturn 0;\r\nspin_lock_irqsave(&info->lock,flags);\r\nif ( (info->params.mode != MGSL_MODE_HDLC) ||\r\n!info->tx_active ) {\r\nif (info->tx_count < info->max_frame_size - 1) {\r\ninfo->tx_buf[info->tx_put++] = ch;\r\nif (info->tx_put >= info->max_frame_size)\r\ninfo->tx_put -= info->max_frame_size;\r\ninfo->tx_count++;\r\nret = 1;\r\n}\r\n}\r\nspin_unlock_irqrestore(&info->lock,flags);\r\nreturn ret;\r\n}\r\nstatic void send_xchar(struct tty_struct *tty, char ch)\r\n{\r\nSLMP_INFO *info = tty->driver_data;\r\nunsigned long flags;\r\nif (debug_level >= DEBUG_LEVEL_INFO)\r\nprintk("%s(%d):%s send_xchar(%d)\n",\r\n__FILE__,__LINE__, info->device_name, ch );\r\nif (sanity_check(info, tty->name, "send_xchar"))\r\nreturn;\r\ninfo->x_char = ch;\r\nif (ch) {\r\nspin_lock_irqsave(&info->lock,flags);\r\nif (!info->tx_enabled)\r\ntx_start(info);\r\nspin_unlock_irqrestore(&info->lock,flags);\r\n}\r\n}\r\nstatic void wait_until_sent(struct tty_struct *tty, int timeout)\r\n{\r\nSLMP_INFO * info = tty->driver_data;\r\nunsigned long orig_jiffies, char_time;\r\nif (!info )\r\nreturn;\r\nif (debug_level >= DEBUG_LEVEL_INFO)\r\nprintk("%s(%d):%s wait_until_sent() entry\n",\r\n__FILE__,__LINE__, info->device_name );\r\nif (sanity_check(info, tty->name, "wait_until_sent"))\r\nreturn;\r\nif (!test_bit(ASYNCB_INITIALIZED, &info->port.flags))\r\ngoto exit;\r\norig_jiffies = jiffies;\r\nif ( info->params.data_rate ) {\r\nchar_time = info->timeout/(32 * 5);\r\nif (!char_time)\r\nchar_time++;\r\n} else\r\nchar_time = 1;\r\nif (timeout)\r\nchar_time = min_t(unsigned long, char_time, timeout);\r\nif ( info->params.mode == MGSL_MODE_HDLC ) {\r\nwhile (info->tx_active) {\r\nmsleep_interruptible(jiffies_to_msecs(char_time));\r\nif (signal_pending(current))\r\nbreak;\r\nif (timeout && time_after(jiffies, orig_jiffies + timeout))\r\nbreak;\r\n}\r\n} else {\r\nwhile ( info->tx_active && info->tx_enabled) {\r\nmsleep_interruptible(jiffies_to_msecs(char_time));\r\nif (signal_pending(current))\r\nbreak;\r\nif (timeout && time_after(jiffies, orig_jiffies + timeout))\r\nbreak;\r\n}\r\n}\r\nexit:\r\nif (debug_level >= DEBUG_LEVEL_INFO)\r\nprintk("%s(%d):%s wait_until_sent() exit\n",\r\n__FILE__,__LINE__, info->device_name );\r\n}\r\nstatic int write_room(struct tty_struct *tty)\r\n{\r\nSLMP_INFO *info = tty->driver_data;\r\nint ret;\r\nif (sanity_check(info, tty->name, "write_room"))\r\nreturn 0;\r\nif (info->params.mode == MGSL_MODE_HDLC) {\r\nret = (info->tx_active) ? 0 : HDLC_MAX_FRAME_SIZE;\r\n} else {\r\nret = info->max_frame_size - info->tx_count - 1;\r\nif (ret < 0)\r\nret = 0;\r\n}\r\nif (debug_level >= DEBUG_LEVEL_INFO)\r\nprintk("%s(%d):%s write_room()=%d\n",\r\n__FILE__, __LINE__, info->device_name, ret);\r\nreturn ret;\r\n}\r\nstatic void flush_chars(struct tty_struct *tty)\r\n{\r\nSLMP_INFO *info = tty->driver_data;\r\nunsigned long flags;\r\nif ( debug_level >= DEBUG_LEVEL_INFO )\r\nprintk( "%s(%d):%s flush_chars() entry tx_count=%d\n",\r\n__FILE__,__LINE__,info->device_name,info->tx_count);\r\nif (sanity_check(info, tty->name, "flush_chars"))\r\nreturn;\r\nif (info->tx_count <= 0 || tty->stopped || tty->hw_stopped ||\r\n!info->tx_buf)\r\nreturn;\r\nif ( debug_level >= DEBUG_LEVEL_INFO )\r\nprintk( "%s(%d):%s flush_chars() entry, starting transmitter\n",\r\n__FILE__,__LINE__,info->device_name );\r\nspin_lock_irqsave(&info->lock,flags);\r\nif (!info->tx_active) {\r\nif ( (info->params.mode == MGSL_MODE_HDLC) &&\r\ninfo->tx_count ) {\r\ntx_load_dma_buffer(info,\r\ninfo->tx_buf,info->tx_count);\r\n}\r\ntx_start(info);\r\n}\r\nspin_unlock_irqrestore(&info->lock,flags);\r\n}\r\nstatic void flush_buffer(struct tty_struct *tty)\r\n{\r\nSLMP_INFO *info = tty->driver_data;\r\nunsigned long flags;\r\nif (debug_level >= DEBUG_LEVEL_INFO)\r\nprintk("%s(%d):%s flush_buffer() entry\n",\r\n__FILE__,__LINE__, info->device_name );\r\nif (sanity_check(info, tty->name, "flush_buffer"))\r\nreturn;\r\nspin_lock_irqsave(&info->lock,flags);\r\ninfo->tx_count = info->tx_put = info->tx_get = 0;\r\ndel_timer(&info->tx_timer);\r\nspin_unlock_irqrestore(&info->lock,flags);\r\ntty_wakeup(tty);\r\n}\r\nstatic void tx_hold(struct tty_struct *tty)\r\n{\r\nSLMP_INFO *info = tty->driver_data;\r\nunsigned long flags;\r\nif (sanity_check(info, tty->name, "tx_hold"))\r\nreturn;\r\nif ( debug_level >= DEBUG_LEVEL_INFO )\r\nprintk("%s(%d):%s tx_hold()\n",\r\n__FILE__,__LINE__,info->device_name);\r\nspin_lock_irqsave(&info->lock,flags);\r\nif (info->tx_enabled)\r\ntx_stop(info);\r\nspin_unlock_irqrestore(&info->lock,flags);\r\n}\r\nstatic void tx_release(struct tty_struct *tty)\r\n{\r\nSLMP_INFO *info = tty->driver_data;\r\nunsigned long flags;\r\nif (sanity_check(info, tty->name, "tx_release"))\r\nreturn;\r\nif ( debug_level >= DEBUG_LEVEL_INFO )\r\nprintk("%s(%d):%s tx_release()\n",\r\n__FILE__,__LINE__,info->device_name);\r\nspin_lock_irqsave(&info->lock,flags);\r\nif (!info->tx_enabled)\r\ntx_start(info);\r\nspin_unlock_irqrestore(&info->lock,flags);\r\n}\r\nstatic int ioctl(struct tty_struct *tty,\r\nunsigned int cmd, unsigned long arg)\r\n{\r\nSLMP_INFO *info = tty->driver_data;\r\nvoid __user *argp = (void __user *)arg;\r\nif (debug_level >= DEBUG_LEVEL_INFO)\r\nprintk("%s(%d):%s ioctl() cmd=%08X\n", __FILE__,__LINE__,\r\ninfo->device_name, cmd );\r\nif (sanity_check(info, tty->name, "ioctl"))\r\nreturn -ENODEV;\r\nif ((cmd != TIOCGSERIAL) && (cmd != TIOCSSERIAL) &&\r\n(cmd != TIOCMIWAIT)) {\r\nif (tty->flags & (1 << TTY_IO_ERROR))\r\nreturn -EIO;\r\n}\r\nswitch (cmd) {\r\ncase MGSL_IOCGPARAMS:\r\nreturn get_params(info, argp);\r\ncase MGSL_IOCSPARAMS:\r\nreturn set_params(info, argp);\r\ncase MGSL_IOCGTXIDLE:\r\nreturn get_txidle(info, argp);\r\ncase MGSL_IOCSTXIDLE:\r\nreturn set_txidle(info, (int)arg);\r\ncase MGSL_IOCTXENABLE:\r\nreturn tx_enable(info, (int)arg);\r\ncase MGSL_IOCRXENABLE:\r\nreturn rx_enable(info, (int)arg);\r\ncase MGSL_IOCTXABORT:\r\nreturn tx_abort(info);\r\ncase MGSL_IOCGSTATS:\r\nreturn get_stats(info, argp);\r\ncase MGSL_IOCWAITEVENT:\r\nreturn wait_mgsl_event(info, argp);\r\ncase MGSL_IOCLOOPTXDONE:\r\nreturn 0;\r\ncase TIOCMIWAIT:\r\nreturn modem_input_wait(info,(int)arg);\r\ndefault:\r\nreturn -ENOIOCTLCMD;\r\n}\r\nreturn 0;\r\n}\r\nstatic int get_icount(struct tty_struct *tty,\r\nstruct serial_icounter_struct *icount)\r\n{\r\nSLMP_INFO *info = tty->driver_data;\r\nstruct mgsl_icount cnow;\r\nunsigned long flags;\r\nspin_lock_irqsave(&info->lock,flags);\r\ncnow = info->icount;\r\nspin_unlock_irqrestore(&info->lock,flags);\r\nicount->cts = cnow.cts;\r\nicount->dsr = cnow.dsr;\r\nicount->rng = cnow.rng;\r\nicount->dcd = cnow.dcd;\r\nicount->rx = cnow.rx;\r\nicount->tx = cnow.tx;\r\nicount->frame = cnow.frame;\r\nicount->overrun = cnow.overrun;\r\nicount->parity = cnow.parity;\r\nicount->brk = cnow.brk;\r\nicount->buf_overrun = cnow.buf_overrun;\r\nreturn 0;\r\n}\r\nstatic inline void line_info(struct seq_file *m, SLMP_INFO *info)\r\n{\r\nchar stat_buf[30];\r\nunsigned long flags;\r\nseq_printf(m, "%s: SCABase=%08x Mem=%08X StatusControl=%08x LCR=%08X\n"\r\n"\tIRQ=%d MaxFrameSize=%u\n",\r\ninfo->device_name,\r\ninfo->phys_sca_base,\r\ninfo->phys_memory_base,\r\ninfo->phys_statctrl_base,\r\ninfo->phys_lcr_base,\r\ninfo->irq_level,\r\ninfo->max_frame_size );\r\nspin_lock_irqsave(&info->lock,flags);\r\nget_signals(info);\r\nspin_unlock_irqrestore(&info->lock,flags);\r\nstat_buf[0] = 0;\r\nstat_buf[1] = 0;\r\nif (info->serial_signals & SerialSignal_RTS)\r\nstrcat(stat_buf, "|RTS");\r\nif (info->serial_signals & SerialSignal_CTS)\r\nstrcat(stat_buf, "|CTS");\r\nif (info->serial_signals & SerialSignal_DTR)\r\nstrcat(stat_buf, "|DTR");\r\nif (info->serial_signals & SerialSignal_DSR)\r\nstrcat(stat_buf, "|DSR");\r\nif (info->serial_signals & SerialSignal_DCD)\r\nstrcat(stat_buf, "|CD");\r\nif (info->serial_signals & SerialSignal_RI)\r\nstrcat(stat_buf, "|RI");\r\nif (info->params.mode == MGSL_MODE_HDLC) {\r\nseq_printf(m, "\tHDLC txok:%d rxok:%d",\r\ninfo->icount.txok, info->icount.rxok);\r\nif (info->icount.txunder)\r\nseq_printf(m, " txunder:%d", info->icount.txunder);\r\nif (info->icount.txabort)\r\nseq_printf(m, " txabort:%d", info->icount.txabort);\r\nif (info->icount.rxshort)\r\nseq_printf(m, " rxshort:%d", info->icount.rxshort);\r\nif (info->icount.rxlong)\r\nseq_printf(m, " rxlong:%d", info->icount.rxlong);\r\nif (info->icount.rxover)\r\nseq_printf(m, " rxover:%d", info->icount.rxover);\r\nif (info->icount.rxcrc)\r\nseq_printf(m, " rxlong:%d", info->icount.rxcrc);\r\n} else {\r\nseq_printf(m, "\tASYNC tx:%d rx:%d",\r\ninfo->icount.tx, info->icount.rx);\r\nif (info->icount.frame)\r\nseq_printf(m, " fe:%d", info->icount.frame);\r\nif (info->icount.parity)\r\nseq_printf(m, " pe:%d", info->icount.parity);\r\nif (info->icount.brk)\r\nseq_printf(m, " brk:%d", info->icount.brk);\r\nif (info->icount.overrun)\r\nseq_printf(m, " oe:%d", info->icount.overrun);\r\n}\r\nseq_printf(m, " %s\n", stat_buf+1);\r\nseq_printf(m, "\ttxactive=%d bh_req=%d bh_run=%d pending_bh=%x\n",\r\ninfo->tx_active,info->bh_requested,info->bh_running,\r\ninfo->pending_bh);\r\n}\r\nstatic int synclinkmp_proc_show(struct seq_file *m, void *v)\r\n{\r\nSLMP_INFO *info;\r\nseq_printf(m, "synclinkmp driver:%s\n", driver_version);\r\ninfo = synclinkmp_device_list;\r\nwhile( info ) {\r\nline_info(m, info);\r\ninfo = info->next_device;\r\n}\r\nreturn 0;\r\n}\r\nstatic int synclinkmp_proc_open(struct inode *inode, struct file *file)\r\n{\r\nreturn single_open(file, synclinkmp_proc_show, NULL);\r\n}\r\nstatic int chars_in_buffer(struct tty_struct *tty)\r\n{\r\nSLMP_INFO *info = tty->driver_data;\r\nif (sanity_check(info, tty->name, "chars_in_buffer"))\r\nreturn 0;\r\nif (debug_level >= DEBUG_LEVEL_INFO)\r\nprintk("%s(%d):%s chars_in_buffer()=%d\n",\r\n__FILE__, __LINE__, info->device_name, info->tx_count);\r\nreturn info->tx_count;\r\n}\r\nstatic void throttle(struct tty_struct * tty)\r\n{\r\nSLMP_INFO *info = tty->driver_data;\r\nunsigned long flags;\r\nif (debug_level >= DEBUG_LEVEL_INFO)\r\nprintk("%s(%d):%s throttle() entry\n",\r\n__FILE__,__LINE__, info->device_name );\r\nif (sanity_check(info, tty->name, "throttle"))\r\nreturn;\r\nif (I_IXOFF(tty))\r\nsend_xchar(tty, STOP_CHAR(tty));\r\nif (tty->termios.c_cflag & CRTSCTS) {\r\nspin_lock_irqsave(&info->lock,flags);\r\ninfo->serial_signals &= ~SerialSignal_RTS;\r\nset_signals(info);\r\nspin_unlock_irqrestore(&info->lock,flags);\r\n}\r\n}\r\nstatic void unthrottle(struct tty_struct * tty)\r\n{\r\nSLMP_INFO *info = tty->driver_data;\r\nunsigned long flags;\r\nif (debug_level >= DEBUG_LEVEL_INFO)\r\nprintk("%s(%d):%s unthrottle() entry\n",\r\n__FILE__,__LINE__, info->device_name );\r\nif (sanity_check(info, tty->name, "unthrottle"))\r\nreturn;\r\nif (I_IXOFF(tty)) {\r\nif (info->x_char)\r\ninfo->x_char = 0;\r\nelse\r\nsend_xchar(tty, START_CHAR(tty));\r\n}\r\nif (tty->termios.c_cflag & CRTSCTS) {\r\nspin_lock_irqsave(&info->lock,flags);\r\ninfo->serial_signals |= SerialSignal_RTS;\r\nset_signals(info);\r\nspin_unlock_irqrestore(&info->lock,flags);\r\n}\r\n}\r\nstatic int set_break(struct tty_struct *tty, int break_state)\r\n{\r\nunsigned char RegValue;\r\nSLMP_INFO * info = tty->driver_data;\r\nunsigned long flags;\r\nif (debug_level >= DEBUG_LEVEL_INFO)\r\nprintk("%s(%d):%s set_break(%d)\n",\r\n__FILE__,__LINE__, info->device_name, break_state);\r\nif (sanity_check(info, tty->name, "set_break"))\r\nreturn -EINVAL;\r\nspin_lock_irqsave(&info->lock,flags);\r\nRegValue = read_reg(info, CTL);\r\nif (break_state == -1)\r\nRegValue |= BIT3;\r\nelse\r\nRegValue &= ~BIT3;\r\nwrite_reg(info, CTL, RegValue);\r\nspin_unlock_irqrestore(&info->lock,flags);\r\nreturn 0;\r\n}\r\nstatic int hdlcdev_attach(struct net_device *dev, unsigned short encoding,\r\nunsigned short parity)\r\n{\r\nSLMP_INFO *info = dev_to_port(dev);\r\nunsigned char new_encoding;\r\nunsigned short new_crctype;\r\nif (info->port.count)\r\nreturn -EBUSY;\r\nswitch (encoding)\r\n{\r\ncase ENCODING_NRZ: new_encoding = HDLC_ENCODING_NRZ; break;\r\ncase ENCODING_NRZI: new_encoding = HDLC_ENCODING_NRZI_SPACE; break;\r\ncase ENCODING_FM_MARK: new_encoding = HDLC_ENCODING_BIPHASE_MARK; break;\r\ncase ENCODING_FM_SPACE: new_encoding = HDLC_ENCODING_BIPHASE_SPACE; break;\r\ncase ENCODING_MANCHESTER: new_encoding = HDLC_ENCODING_BIPHASE_LEVEL; break;\r\ndefault: return -EINVAL;\r\n}\r\nswitch (parity)\r\n{\r\ncase PARITY_NONE: new_crctype = HDLC_CRC_NONE; break;\r\ncase PARITY_CRC16_PR1_CCITT: new_crctype = HDLC_CRC_16_CCITT; break;\r\ncase PARITY_CRC32_PR1_CCITT: new_crctype = HDLC_CRC_32_CCITT; break;\r\ndefault: return -EINVAL;\r\n}\r\ninfo->params.encoding = new_encoding;\r\ninfo->params.crc_type = new_crctype;\r\nif (info->netcount)\r\nprogram_hw(info);\r\nreturn 0;\r\n}\r\nstatic netdev_tx_t hdlcdev_xmit(struct sk_buff *skb,\r\nstruct net_device *dev)\r\n{\r\nSLMP_INFO *info = dev_to_port(dev);\r\nunsigned long flags;\r\nif (debug_level >= DEBUG_LEVEL_INFO)\r\nprintk(KERN_INFO "%s:hdlc_xmit(%s)\n",__FILE__,dev->name);\r\nnetif_stop_queue(dev);\r\ninfo->tx_count = skb->len;\r\ntx_load_dma_buffer(info, skb->data, skb->len);\r\ndev->stats.tx_packets++;\r\ndev->stats.tx_bytes += skb->len;\r\ndev_kfree_skb(skb);\r\ndev->trans_start = jiffies;\r\nspin_lock_irqsave(&info->lock,flags);\r\nif (!info->tx_active)\r\ntx_start(info);\r\nspin_unlock_irqrestore(&info->lock,flags);\r\nreturn NETDEV_TX_OK;\r\n}\r\nstatic int hdlcdev_open(struct net_device *dev)\r\n{\r\nSLMP_INFO *info = dev_to_port(dev);\r\nint rc;\r\nunsigned long flags;\r\nif (debug_level >= DEBUG_LEVEL_INFO)\r\nprintk("%s:hdlcdev_open(%s)\n",__FILE__,dev->name);\r\nrc = hdlc_open(dev);\r\nif (rc)\r\nreturn rc;\r\nspin_lock_irqsave(&info->netlock, flags);\r\nif (info->port.count != 0 || info->netcount != 0) {\r\nprintk(KERN_WARNING "%s: hdlc_open returning busy\n", dev->name);\r\nspin_unlock_irqrestore(&info->netlock, flags);\r\nreturn -EBUSY;\r\n}\r\ninfo->netcount=1;\r\nspin_unlock_irqrestore(&info->netlock, flags);\r\nif ((rc = startup(info)) != 0) {\r\nspin_lock_irqsave(&info->netlock, flags);\r\ninfo->netcount=0;\r\nspin_unlock_irqrestore(&info->netlock, flags);\r\nreturn rc;\r\n}\r\ninfo->serial_signals |= SerialSignal_RTS | SerialSignal_DTR;\r\nprogram_hw(info);\r\ndev->trans_start = jiffies;\r\nnetif_start_queue(dev);\r\nspin_lock_irqsave(&info->lock, flags);\r\nget_signals(info);\r\nspin_unlock_irqrestore(&info->lock, flags);\r\nif (info->serial_signals & SerialSignal_DCD)\r\nnetif_carrier_on(dev);\r\nelse\r\nnetif_carrier_off(dev);\r\nreturn 0;\r\n}\r\nstatic int hdlcdev_close(struct net_device *dev)\r\n{\r\nSLMP_INFO *info = dev_to_port(dev);\r\nunsigned long flags;\r\nif (debug_level >= DEBUG_LEVEL_INFO)\r\nprintk("%s:hdlcdev_close(%s)\n",__FILE__,dev->name);\r\nnetif_stop_queue(dev);\r\nshutdown(info);\r\nhdlc_close(dev);\r\nspin_lock_irqsave(&info->netlock, flags);\r\ninfo->netcount=0;\r\nspin_unlock_irqrestore(&info->netlock, flags);\r\nreturn 0;\r\n}\r\nstatic int hdlcdev_ioctl(struct net_device *dev, struct ifreq *ifr, int cmd)\r\n{\r\nconst size_t size = sizeof(sync_serial_settings);\r\nsync_serial_settings new_line;\r\nsync_serial_settings __user *line = ifr->ifr_settings.ifs_ifsu.sync;\r\nSLMP_INFO *info = dev_to_port(dev);\r\nunsigned int flags;\r\nif (debug_level >= DEBUG_LEVEL_INFO)\r\nprintk("%s:hdlcdev_ioctl(%s)\n",__FILE__,dev->name);\r\nif (info->port.count)\r\nreturn -EBUSY;\r\nif (cmd != SIOCWANDEV)\r\nreturn hdlc_ioctl(dev, ifr, cmd);\r\nswitch(ifr->ifr_settings.type) {\r\ncase IF_GET_IFACE:\r\nifr->ifr_settings.type = IF_IFACE_SYNC_SERIAL;\r\nif (ifr->ifr_settings.size < size) {\r\nifr->ifr_settings.size = size;\r\nreturn -ENOBUFS;\r\n}\r\nflags = info->params.flags & (HDLC_FLAG_RXC_RXCPIN | HDLC_FLAG_RXC_DPLL |\r\nHDLC_FLAG_RXC_BRG | HDLC_FLAG_RXC_TXCPIN |\r\nHDLC_FLAG_TXC_TXCPIN | HDLC_FLAG_TXC_DPLL |\r\nHDLC_FLAG_TXC_BRG | HDLC_FLAG_TXC_RXCPIN);\r\nmemset(&new_line, 0, sizeof(new_line));\r\nswitch (flags){\r\ncase (HDLC_FLAG_RXC_RXCPIN | HDLC_FLAG_TXC_TXCPIN): new_line.clock_type = CLOCK_EXT; break;\r\ncase (HDLC_FLAG_RXC_BRG | HDLC_FLAG_TXC_BRG): new_line.clock_type = CLOCK_INT; break;\r\ncase (HDLC_FLAG_RXC_RXCPIN | HDLC_FLAG_TXC_BRG): new_line.clock_type = CLOCK_TXINT; break;\r\ncase (HDLC_FLAG_RXC_RXCPIN | HDLC_FLAG_TXC_RXCPIN): new_line.clock_type = CLOCK_TXFROMRX; break;\r\ndefault: new_line.clock_type = CLOCK_DEFAULT;\r\n}\r\nnew_line.clock_rate = info->params.clock_speed;\r\nnew_line.loopback = info->params.loopback ? 1:0;\r\nif (copy_to_user(line, &new_line, size))\r\nreturn -EFAULT;\r\nreturn 0;\r\ncase IF_IFACE_SYNC_SERIAL:\r\nif(!capable(CAP_NET_ADMIN))\r\nreturn -EPERM;\r\nif (copy_from_user(&new_line, line, size))\r\nreturn -EFAULT;\r\nswitch (new_line.clock_type)\r\n{\r\ncase CLOCK_EXT: flags = HDLC_FLAG_RXC_RXCPIN | HDLC_FLAG_TXC_TXCPIN; break;\r\ncase CLOCK_TXFROMRX: flags = HDLC_FLAG_RXC_RXCPIN | HDLC_FLAG_TXC_RXCPIN; break;\r\ncase CLOCK_INT: flags = HDLC_FLAG_RXC_BRG | HDLC_FLAG_TXC_BRG; break;\r\ncase CLOCK_TXINT: flags = HDLC_FLAG_RXC_RXCPIN | HDLC_FLAG_TXC_BRG; break;\r\ncase CLOCK_DEFAULT: flags = info->params.flags &\r\n(HDLC_FLAG_RXC_RXCPIN | HDLC_FLAG_RXC_DPLL |\r\nHDLC_FLAG_RXC_BRG | HDLC_FLAG_RXC_TXCPIN |\r\nHDLC_FLAG_TXC_TXCPIN | HDLC_FLAG_TXC_DPLL |\r\nHDLC_FLAG_TXC_BRG | HDLC_FLAG_TXC_RXCPIN); break;\r\ndefault: return -EINVAL;\r\n}\r\nif (new_line.loopback != 0 && new_line.loopback != 1)\r\nreturn -EINVAL;\r\ninfo->params.flags &= ~(HDLC_FLAG_RXC_RXCPIN | HDLC_FLAG_RXC_DPLL |\r\nHDLC_FLAG_RXC_BRG | HDLC_FLAG_RXC_TXCPIN |\r\nHDLC_FLAG_TXC_TXCPIN | HDLC_FLAG_TXC_DPLL |\r\nHDLC_FLAG_TXC_BRG | HDLC_FLAG_TXC_RXCPIN);\r\ninfo->params.flags |= flags;\r\ninfo->params.loopback = new_line.loopback;\r\nif (flags & (HDLC_FLAG_RXC_BRG | HDLC_FLAG_TXC_BRG))\r\ninfo->params.clock_speed = new_line.clock_rate;\r\nelse\r\ninfo->params.clock_speed = 0;\r\nif (info->netcount)\r\nprogram_hw(info);\r\nreturn 0;\r\ndefault:\r\nreturn hdlc_ioctl(dev, ifr, cmd);\r\n}\r\n}\r\nstatic void hdlcdev_tx_timeout(struct net_device *dev)\r\n{\r\nSLMP_INFO *info = dev_to_port(dev);\r\nunsigned long flags;\r\nif (debug_level >= DEBUG_LEVEL_INFO)\r\nprintk("hdlcdev_tx_timeout(%s)\n",dev->name);\r\ndev->stats.tx_errors++;\r\ndev->stats.tx_aborted_errors++;\r\nspin_lock_irqsave(&info->lock,flags);\r\ntx_stop(info);\r\nspin_unlock_irqrestore(&info->lock,flags);\r\nnetif_wake_queue(dev);\r\n}\r\nstatic void hdlcdev_tx_done(SLMP_INFO *info)\r\n{\r\nif (netif_queue_stopped(info->netdev))\r\nnetif_wake_queue(info->netdev);\r\n}\r\nstatic void hdlcdev_rx(SLMP_INFO *info, char *buf, int size)\r\n{\r\nstruct sk_buff *skb = dev_alloc_skb(size);\r\nstruct net_device *dev = info->netdev;\r\nif (debug_level >= DEBUG_LEVEL_INFO)\r\nprintk("hdlcdev_rx(%s)\n",dev->name);\r\nif (skb == NULL) {\r\nprintk(KERN_NOTICE "%s: can't alloc skb, dropping packet\n",\r\ndev->name);\r\ndev->stats.rx_dropped++;\r\nreturn;\r\n}\r\nmemcpy(skb_put(skb, size), buf, size);\r\nskb->protocol = hdlc_type_trans(skb, dev);\r\ndev->stats.rx_packets++;\r\ndev->stats.rx_bytes += size;\r\nnetif_rx(skb);\r\n}\r\nstatic int hdlcdev_init(SLMP_INFO *info)\r\n{\r\nint rc;\r\nstruct net_device *dev;\r\nhdlc_device *hdlc;\r\ndev = alloc_hdlcdev(info);\r\nif (!dev) {\r\nprintk(KERN_ERR "%s:hdlc device allocation failure\n",__FILE__);\r\nreturn -ENOMEM;\r\n}\r\ndev->mem_start = info->phys_sca_base;\r\ndev->mem_end = info->phys_sca_base + SCA_BASE_SIZE - 1;\r\ndev->irq = info->irq_level;\r\ndev->netdev_ops = &hdlcdev_ops;\r\ndev->watchdog_timeo = 10 * HZ;\r\ndev->tx_queue_len = 50;\r\nhdlc = dev_to_hdlc(dev);\r\nhdlc->attach = hdlcdev_attach;\r\nhdlc->xmit = hdlcdev_xmit;\r\nrc = register_hdlc_device(dev);\r\nif (rc) {\r\nprintk(KERN_WARNING "%s:unable to register hdlc device\n",__FILE__);\r\nfree_netdev(dev);\r\nreturn rc;\r\n}\r\ninfo->netdev = dev;\r\nreturn 0;\r\n}\r\nstatic void hdlcdev_exit(SLMP_INFO *info)\r\n{\r\nunregister_hdlc_device(info->netdev);\r\nfree_netdev(info->netdev);\r\ninfo->netdev = NULL;\r\n}\r\nstatic int bh_action(SLMP_INFO *info)\r\n{\r\nunsigned long flags;\r\nint rc = 0;\r\nspin_lock_irqsave(&info->lock,flags);\r\nif (info->pending_bh & BH_RECEIVE) {\r\ninfo->pending_bh &= ~BH_RECEIVE;\r\nrc = BH_RECEIVE;\r\n} else if (info->pending_bh & BH_TRANSMIT) {\r\ninfo->pending_bh &= ~BH_TRANSMIT;\r\nrc = BH_TRANSMIT;\r\n} else if (info->pending_bh & BH_STATUS) {\r\ninfo->pending_bh &= ~BH_STATUS;\r\nrc = BH_STATUS;\r\n}\r\nif (!rc) {\r\ninfo->bh_running = false;\r\ninfo->bh_requested = false;\r\n}\r\nspin_unlock_irqrestore(&info->lock,flags);\r\nreturn rc;\r\n}\r\nstatic void bh_handler(struct work_struct *work)\r\n{\r\nSLMP_INFO *info = container_of(work, SLMP_INFO, task);\r\nint action;\r\nif ( debug_level >= DEBUG_LEVEL_BH )\r\nprintk( "%s(%d):%s bh_handler() entry\n",\r\n__FILE__,__LINE__,info->device_name);\r\ninfo->bh_running = true;\r\nwhile((action = bh_action(info)) != 0) {\r\nif ( debug_level >= DEBUG_LEVEL_BH )\r\nprintk( "%s(%d):%s bh_handler() work item action=%d\n",\r\n__FILE__,__LINE__,info->device_name, action);\r\nswitch (action) {\r\ncase BH_RECEIVE:\r\nbh_receive(info);\r\nbreak;\r\ncase BH_TRANSMIT:\r\nbh_transmit(info);\r\nbreak;\r\ncase BH_STATUS:\r\nbh_status(info);\r\nbreak;\r\ndefault:\r\nprintk("%s(%d):%s Unknown work item ID=%08X!\n",\r\n__FILE__,__LINE__,info->device_name,action);\r\nbreak;\r\n}\r\n}\r\nif ( debug_level >= DEBUG_LEVEL_BH )\r\nprintk( "%s(%d):%s bh_handler() exit\n",\r\n__FILE__,__LINE__,info->device_name);\r\n}\r\nstatic void bh_receive(SLMP_INFO *info)\r\n{\r\nif ( debug_level >= DEBUG_LEVEL_BH )\r\nprintk( "%s(%d):%s bh_receive()\n",\r\n__FILE__,__LINE__,info->device_name);\r\nwhile( rx_get_frame(info) );\r\n}\r\nstatic void bh_transmit(SLMP_INFO *info)\r\n{\r\nstruct tty_struct *tty = info->port.tty;\r\nif ( debug_level >= DEBUG_LEVEL_BH )\r\nprintk( "%s(%d):%s bh_transmit() entry\n",\r\n__FILE__,__LINE__,info->device_name);\r\nif (tty)\r\ntty_wakeup(tty);\r\n}\r\nstatic void bh_status(SLMP_INFO *info)\r\n{\r\nif ( debug_level >= DEBUG_LEVEL_BH )\r\nprintk( "%s(%d):%s bh_status() entry\n",\r\n__FILE__,__LINE__,info->device_name);\r\ninfo->ri_chkcount = 0;\r\ninfo->dsr_chkcount = 0;\r\ninfo->dcd_chkcount = 0;\r\ninfo->cts_chkcount = 0;\r\n}\r\nstatic void isr_timer(SLMP_INFO * info)\r\n{\r\nunsigned char timer = (info->port_num & 1) ? TIMER2 : TIMER0;\r\nwrite_reg(info, IER2, 0);\r\nwrite_reg(info, (unsigned char)(timer + TMCS), 0);\r\ninfo->irq_occurred = true;\r\nif ( debug_level >= DEBUG_LEVEL_ISR )\r\nprintk("%s(%d):%s isr_timer()\n",\r\n__FILE__,__LINE__,info->device_name);\r\n}\r\nstatic void isr_rxint(SLMP_INFO * info)\r\n{\r\nstruct tty_struct *tty = info->port.tty;\r\nstruct mgsl_icount *icount = &info->icount;\r\nunsigned char status = read_reg(info, SR1) & info->ie1_value & (FLGD + IDLD + CDCD + BRKD);\r\nunsigned char status2 = read_reg(info, SR2) & info->ie2_value & OVRN;\r\nif (status)\r\nwrite_reg(info, SR1, status);\r\nif (status2)\r\nwrite_reg(info, SR2, status2);\r\nif ( debug_level >= DEBUG_LEVEL_ISR )\r\nprintk("%s(%d):%s isr_rxint status=%02X %02x\n",\r\n__FILE__,__LINE__,info->device_name,status,status2);\r\nif (info->params.mode == MGSL_MODE_ASYNC) {\r\nif (status & BRKD) {\r\nicount->brk++;\r\nif (!(status & info->ignore_status_mask1)) {\r\nif (info->read_status_mask1 & BRKD) {\r\ntty_insert_flip_char(&info->port, 0, TTY_BREAK);\r\nif (tty && (info->port.flags & ASYNC_SAK))\r\ndo_SAK(tty);\r\n}\r\n}\r\n}\r\n}\r\nelse {\r\nif (status & (FLGD|IDLD)) {\r\nif (status & FLGD)\r\ninfo->icount.exithunt++;\r\nelse if (status & IDLD)\r\ninfo->icount.rxidle++;\r\nwake_up_interruptible(&info->event_wait_q);\r\n}\r\n}\r\nif (status & CDCD) {\r\nget_signals( info );\r\nisr_io_pin(info,\r\nMISCSTATUS_DCD_LATCHED|(info->serial_signals&SerialSignal_DCD));\r\n}\r\n}\r\nstatic void isr_rxrdy(SLMP_INFO * info)\r\n{\r\nu16 status;\r\nunsigned char DataByte;\r\nstruct mgsl_icount *icount = &info->icount;\r\nif ( debug_level >= DEBUG_LEVEL_ISR )\r\nprintk("%s(%d):%s isr_rxrdy\n",\r\n__FILE__,__LINE__,info->device_name);\r\nwhile((status = read_reg(info,CST0)) & BIT0)\r\n{\r\nint flag = 0;\r\nbool over = false;\r\nDataByte = read_reg(info,TRB);\r\nicount->rx++;\r\nif ( status & (PE + FRME + OVRN) ) {\r\nprintk("%s(%d):%s rxerr=%04X\n",\r\n__FILE__,__LINE__,info->device_name,status);\r\nif (status & PE)\r\nicount->parity++;\r\nelse if (status & FRME)\r\nicount->frame++;\r\nelse if (status & OVRN)\r\nicount->overrun++;\r\nif (status & info->ignore_status_mask2)\r\ncontinue;\r\nstatus &= info->read_status_mask2;\r\nif (status & PE)\r\nflag = TTY_PARITY;\r\nelse if (status & FRME)\r\nflag = TTY_FRAME;\r\nif (status & OVRN) {\r\nover = true;\r\n}\r\n}\r\ntty_insert_flip_char(&info->port, DataByte, flag);\r\nif (over)\r\ntty_insert_flip_char(&info->port, 0, TTY_OVERRUN);\r\n}\r\nif ( debug_level >= DEBUG_LEVEL_ISR ) {\r\nprintk("%s(%d):%s rx=%d brk=%d parity=%d frame=%d overrun=%d\n",\r\n__FILE__,__LINE__,info->device_name,\r\nicount->rx,icount->brk,icount->parity,\r\nicount->frame,icount->overrun);\r\n}\r\ntty_flip_buffer_push(&info->port);\r\n}\r\nstatic void isr_txeom(SLMP_INFO * info, unsigned char status)\r\n{\r\nif ( debug_level >= DEBUG_LEVEL_ISR )\r\nprintk("%s(%d):%s isr_txeom status=%02x\n",\r\n__FILE__,__LINE__,info->device_name,status);\r\nwrite_reg(info, TXDMA + DIR, 0x00);\r\nwrite_reg(info, TXDMA + DSR, 0xc0);\r\nwrite_reg(info, TXDMA + DCMD, SWABORT);\r\nif (status & UDRN) {\r\nwrite_reg(info, CMD, TXRESET);\r\nwrite_reg(info, CMD, TXENABLE);\r\n} else\r\nwrite_reg(info, CMD, TXBUFCLR);\r\ninfo->ie0_value &= ~TXRDYE;\r\ninfo->ie1_value &= ~(IDLE + UDRN);\r\nwrite_reg16(info, IE0, (unsigned short)((info->ie1_value << 8) + info->ie0_value));\r\nwrite_reg(info, SR1, (unsigned char)(UDRN + IDLE));\r\nif ( info->tx_active ) {\r\nif (info->params.mode != MGSL_MODE_ASYNC) {\r\nif (status & UDRN)\r\ninfo->icount.txunder++;\r\nelse if (status & IDLE)\r\ninfo->icount.txok++;\r\n}\r\ninfo->tx_active = false;\r\ninfo->tx_count = info->tx_put = info->tx_get = 0;\r\ndel_timer(&info->tx_timer);\r\nif (info->params.mode != MGSL_MODE_ASYNC && info->drop_rts_on_tx_done ) {\r\ninfo->serial_signals &= ~SerialSignal_RTS;\r\ninfo->drop_rts_on_tx_done = false;\r\nset_signals(info);\r\n}\r\n#if SYNCLINK_GENERIC_HDLC\r\nif (info->netcount)\r\nhdlcdev_tx_done(info);\r\nelse\r\n#endif\r\n{\r\nif (info->port.tty && (info->port.tty->stopped || info->port.tty->hw_stopped)) {\r\ntx_stop(info);\r\nreturn;\r\n}\r\ninfo->pending_bh |= BH_TRANSMIT;\r\n}\r\n}\r\n}\r\nstatic void isr_txint(SLMP_INFO * info)\r\n{\r\nunsigned char status = read_reg(info, SR1) & info->ie1_value & (UDRN + IDLE + CCTS);\r\nwrite_reg(info, SR1, status);\r\nif ( debug_level >= DEBUG_LEVEL_ISR )\r\nprintk("%s(%d):%s isr_txint status=%02x\n",\r\n__FILE__,__LINE__,info->device_name,status);\r\nif (status & (UDRN + IDLE))\r\nisr_txeom(info, status);\r\nif (status & CCTS) {\r\nget_signals( info );\r\nisr_io_pin(info,\r\nMISCSTATUS_CTS_LATCHED|(info->serial_signals&SerialSignal_CTS));\r\n}\r\n}\r\nstatic void isr_txrdy(SLMP_INFO * info)\r\n{\r\nif ( debug_level >= DEBUG_LEVEL_ISR )\r\nprintk("%s(%d):%s isr_txrdy() tx_count=%d\n",\r\n__FILE__,__LINE__,info->device_name,info->tx_count);\r\nif (info->params.mode != MGSL_MODE_ASYNC) {\r\ninfo->ie0_value &= ~TXRDYE;\r\ninfo->ie1_value |= IDLE;\r\nwrite_reg16(info, IE0, (unsigned short)((info->ie1_value << 8) + info->ie0_value));\r\nreturn;\r\n}\r\nif (info->port.tty && (info->port.tty->stopped || info->port.tty->hw_stopped)) {\r\ntx_stop(info);\r\nreturn;\r\n}\r\nif ( info->tx_count )\r\ntx_load_fifo( info );\r\nelse {\r\ninfo->tx_active = false;\r\ninfo->ie0_value &= ~TXRDYE;\r\nwrite_reg(info, IE0, info->ie0_value);\r\n}\r\nif (info->tx_count < WAKEUP_CHARS)\r\ninfo->pending_bh |= BH_TRANSMIT;\r\n}\r\nstatic void isr_rxdmaok(SLMP_INFO * info)\r\n{\r\nunsigned char status = read_reg(info,RXDMA + DSR) & 0xc0;\r\nwrite_reg(info, RXDMA + DSR, (unsigned char)(status | 1));\r\nif ( debug_level >= DEBUG_LEVEL_ISR )\r\nprintk("%s(%d):%s isr_rxdmaok(), status=%02x\n",\r\n__FILE__,__LINE__,info->device_name,status);\r\ninfo->pending_bh |= BH_RECEIVE;\r\n}\r\nstatic void isr_rxdmaerror(SLMP_INFO * info)\r\n{\r\nunsigned char status = read_reg(info,RXDMA + DSR) & 0x30;\r\nwrite_reg(info, RXDMA + DSR, (unsigned char)(status | 1));\r\nif ( debug_level >= DEBUG_LEVEL_ISR )\r\nprintk("%s(%d):%s isr_rxdmaerror(), status=%02x\n",\r\n__FILE__,__LINE__,info->device_name,status);\r\ninfo->rx_overflow = true;\r\ninfo->pending_bh |= BH_RECEIVE;\r\n}\r\nstatic void isr_txdmaok(SLMP_INFO * info)\r\n{\r\nunsigned char status_reg1 = read_reg(info, SR1);\r\nwrite_reg(info, TXDMA + DIR, 0x00);\r\nwrite_reg(info, TXDMA + DSR, 0xc0);\r\nwrite_reg(info, TXDMA + DCMD, SWABORT);\r\nif ( debug_level >= DEBUG_LEVEL_ISR )\r\nprintk("%s(%d):%s isr_txdmaok(), status=%02x\n",\r\n__FILE__,__LINE__,info->device_name,status_reg1);\r\nwrite_reg16(info, TRC0, 0);\r\ninfo->ie0_value |= TXRDYE;\r\nwrite_reg(info, IE0, info->ie0_value);\r\n}\r\nstatic void isr_txdmaerror(SLMP_INFO * info)\r\n{\r\nunsigned char status = read_reg(info,TXDMA + DSR) & 0x30;\r\nwrite_reg(info, TXDMA + DSR, (unsigned char)(status | 1));\r\nif ( debug_level >= DEBUG_LEVEL_ISR )\r\nprintk("%s(%d):%s isr_txdmaerror(), status=%02x\n",\r\n__FILE__,__LINE__,info->device_name,status);\r\n}\r\nstatic void isr_io_pin( SLMP_INFO *info, u16 status )\r\n{\r\nstruct mgsl_icount *icount;\r\nif ( debug_level >= DEBUG_LEVEL_ISR )\r\nprintk("%s(%d):isr_io_pin status=%04X\n",\r\n__FILE__,__LINE__,status);\r\nif (status & (MISCSTATUS_CTS_LATCHED | MISCSTATUS_DCD_LATCHED |\r\nMISCSTATUS_DSR_LATCHED | MISCSTATUS_RI_LATCHED) ) {\r\nicount = &info->icount;\r\nif (status & MISCSTATUS_RI_LATCHED) {\r\nicount->rng++;\r\nif ( status & SerialSignal_RI )\r\ninfo->input_signal_events.ri_up++;\r\nelse\r\ninfo->input_signal_events.ri_down++;\r\n}\r\nif (status & MISCSTATUS_DSR_LATCHED) {\r\nicount->dsr++;\r\nif ( status & SerialSignal_DSR )\r\ninfo->input_signal_events.dsr_up++;\r\nelse\r\ninfo->input_signal_events.dsr_down++;\r\n}\r\nif (status & MISCSTATUS_DCD_LATCHED) {\r\nif ((info->dcd_chkcount)++ >= IO_PIN_SHUTDOWN_LIMIT) {\r\ninfo->ie1_value &= ~CDCD;\r\nwrite_reg(info, IE1, info->ie1_value);\r\n}\r\nicount->dcd++;\r\nif (status & SerialSignal_DCD) {\r\ninfo->input_signal_events.dcd_up++;\r\n} else\r\ninfo->input_signal_events.dcd_down++;\r\n#if SYNCLINK_GENERIC_HDLC\r\nif (info->netcount) {\r\nif (status & SerialSignal_DCD)\r\nnetif_carrier_on(info->netdev);\r\nelse\r\nnetif_carrier_off(info->netdev);\r\n}\r\n#endif\r\n}\r\nif (status & MISCSTATUS_CTS_LATCHED)\r\n{\r\nif ((info->cts_chkcount)++ >= IO_PIN_SHUTDOWN_LIMIT) {\r\ninfo->ie1_value &= ~CCTS;\r\nwrite_reg(info, IE1, info->ie1_value);\r\n}\r\nicount->cts++;\r\nif ( status & SerialSignal_CTS )\r\ninfo->input_signal_events.cts_up++;\r\nelse\r\ninfo->input_signal_events.cts_down++;\r\n}\r\nwake_up_interruptible(&info->status_event_wait_q);\r\nwake_up_interruptible(&info->event_wait_q);\r\nif ( (info->port.flags & ASYNC_CHECK_CD) &&\r\n(status & MISCSTATUS_DCD_LATCHED) ) {\r\nif ( debug_level >= DEBUG_LEVEL_ISR )\r\nprintk("%s CD now %s...", info->device_name,\r\n(status & SerialSignal_DCD) ? "on" : "off");\r\nif (status & SerialSignal_DCD)\r\nwake_up_interruptible(&info->port.open_wait);\r\nelse {\r\nif ( debug_level >= DEBUG_LEVEL_ISR )\r\nprintk("doing serial hangup...");\r\nif (info->port.tty)\r\ntty_hangup(info->port.tty);\r\n}\r\n}\r\nif (tty_port_cts_enabled(&info->port) &&\r\n(status & MISCSTATUS_CTS_LATCHED) ) {\r\nif ( info->port.tty ) {\r\nif (info->port.tty->hw_stopped) {\r\nif (status & SerialSignal_CTS) {\r\nif ( debug_level >= DEBUG_LEVEL_ISR )\r\nprintk("CTS tx start...");\r\ninfo->port.tty->hw_stopped = 0;\r\ntx_start(info);\r\ninfo->pending_bh |= BH_TRANSMIT;\r\nreturn;\r\n}\r\n} else {\r\nif (!(status & SerialSignal_CTS)) {\r\nif ( debug_level >= DEBUG_LEVEL_ISR )\r\nprintk("CTS tx stop...");\r\ninfo->port.tty->hw_stopped = 1;\r\ntx_stop(info);\r\n}\r\n}\r\n}\r\n}\r\n}\r\ninfo->pending_bh |= BH_STATUS;\r\n}\r\nstatic irqreturn_t synclinkmp_interrupt(int dummy, void *dev_id)\r\n{\r\nSLMP_INFO *info = dev_id;\r\nunsigned char status, status0, status1=0;\r\nunsigned char dmastatus, dmastatus0, dmastatus1=0;\r\nunsigned char timerstatus0, timerstatus1=0;\r\nunsigned char shift;\r\nunsigned int i;\r\nunsigned short tmp;\r\nif ( debug_level >= DEBUG_LEVEL_ISR )\r\nprintk(KERN_DEBUG "%s(%d): synclinkmp_interrupt(%d)entry.\n",\r\n__FILE__, __LINE__, info->irq_level);\r\nspin_lock(&info->lock);\r\nfor(;;) {\r\ntmp = read_reg16(info, ISR0);\r\nstatus0 = (unsigned char)tmp;\r\ndmastatus0 = (unsigned char)(tmp>>8);\r\ntimerstatus0 = read_reg(info, ISR2);\r\nif ( debug_level >= DEBUG_LEVEL_ISR )\r\nprintk(KERN_DEBUG "%s(%d):%s status0=%02x, dmastatus0=%02x, timerstatus0=%02x\n",\r\n__FILE__, __LINE__, info->device_name,\r\nstatus0, dmastatus0, timerstatus0);\r\nif (info->port_count == 4) {\r\ntmp = read_reg16(info->port_array[2], ISR0);\r\nstatus1 = (unsigned char)tmp;\r\ndmastatus1 = (unsigned char)(tmp>>8);\r\ntimerstatus1 = read_reg(info->port_array[2], ISR2);\r\nif ( debug_level >= DEBUG_LEVEL_ISR )\r\nprintk("%s(%d):%s status1=%02x, dmastatus1=%02x, timerstatus1=%02x\n",\r\n__FILE__,__LINE__,info->device_name,\r\nstatus1,dmastatus1,timerstatus1);\r\n}\r\nif (!status0 && !dmastatus0 && !timerstatus0 &&\r\n!status1 && !dmastatus1 && !timerstatus1)\r\nbreak;\r\nfor(i=0; i < info->port_count ; i++) {\r\nif (info->port_array[i] == NULL)\r\ncontinue;\r\nif (i < 2) {\r\nstatus = status0;\r\ndmastatus = dmastatus0;\r\n} else {\r\nstatus = status1;\r\ndmastatus = dmastatus1;\r\n}\r\nshift = i & 1 ? 4 :0;\r\nif (status & BIT0 << shift)\r\nisr_rxrdy(info->port_array[i]);\r\nif (status & BIT1 << shift)\r\nisr_txrdy(info->port_array[i]);\r\nif (status & BIT2 << shift)\r\nisr_rxint(info->port_array[i]);\r\nif (status & BIT3 << shift)\r\nisr_txint(info->port_array[i]);\r\nif (dmastatus & BIT0 << shift)\r\nisr_rxdmaerror(info->port_array[i]);\r\nif (dmastatus & BIT1 << shift)\r\nisr_rxdmaok(info->port_array[i]);\r\nif (dmastatus & BIT2 << shift)\r\nisr_txdmaerror(info->port_array[i]);\r\nif (dmastatus & BIT3 << shift)\r\nisr_txdmaok(info->port_array[i]);\r\n}\r\nif (timerstatus0 & (BIT5 | BIT4))\r\nisr_timer(info->port_array[0]);\r\nif (timerstatus0 & (BIT7 | BIT6))\r\nisr_timer(info->port_array[1]);\r\nif (timerstatus1 & (BIT5 | BIT4))\r\nisr_timer(info->port_array[2]);\r\nif (timerstatus1 & (BIT7 | BIT6))\r\nisr_timer(info->port_array[3]);\r\n}\r\nfor(i=0; i < info->port_count ; i++) {\r\nSLMP_INFO * port = info->port_array[i];\r\nif ( port && (port->port.count || port->netcount) &&\r\nport->pending_bh && !port->bh_running &&\r\n!port->bh_requested ) {\r\nif ( debug_level >= DEBUG_LEVEL_ISR )\r\nprintk("%s(%d):%s queueing bh task.\n",\r\n__FILE__,__LINE__,port->device_name);\r\nschedule_work(&port->task);\r\nport->bh_requested = true;\r\n}\r\n}\r\nspin_unlock(&info->lock);\r\nif ( debug_level >= DEBUG_LEVEL_ISR )\r\nprintk(KERN_DEBUG "%s(%d):synclinkmp_interrupt(%d)exit.\n",\r\n__FILE__, __LINE__, info->irq_level);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int startup(SLMP_INFO * info)\r\n{\r\nif ( debug_level >= DEBUG_LEVEL_INFO )\r\nprintk("%s(%d):%s tx_releaseup()\n",__FILE__,__LINE__,info->device_name);\r\nif (info->port.flags & ASYNC_INITIALIZED)\r\nreturn 0;\r\nif (!info->tx_buf) {\r\ninfo->tx_buf = kmalloc(info->max_frame_size, GFP_KERNEL);\r\nif (!info->tx_buf) {\r\nprintk(KERN_ERR"%s(%d):%s can't allocate transmit buffer\n",\r\n__FILE__,__LINE__,info->device_name);\r\nreturn -ENOMEM;\r\n}\r\n}\r\ninfo->pending_bh = 0;\r\nmemset(&info->icount, 0, sizeof(info->icount));\r\nreset_port(info);\r\nchange_params(info);\r\nmod_timer(&info->status_timer, jiffies + msecs_to_jiffies(10));\r\nif (info->port.tty)\r\nclear_bit(TTY_IO_ERROR, &info->port.tty->flags);\r\ninfo->port.flags |= ASYNC_INITIALIZED;\r\nreturn 0;\r\n}\r\nstatic void shutdown(SLMP_INFO * info)\r\n{\r\nunsigned long flags;\r\nif (!(info->port.flags & ASYNC_INITIALIZED))\r\nreturn;\r\nif (debug_level >= DEBUG_LEVEL_INFO)\r\nprintk("%s(%d):%s synclinkmp_shutdown()\n",\r\n__FILE__,__LINE__, info->device_name );\r\nwake_up_interruptible(&info->status_event_wait_q);\r\nwake_up_interruptible(&info->event_wait_q);\r\ndel_timer(&info->tx_timer);\r\ndel_timer(&info->status_timer);\r\nkfree(info->tx_buf);\r\ninfo->tx_buf = NULL;\r\nspin_lock_irqsave(&info->lock,flags);\r\nreset_port(info);\r\nif (!info->port.tty || info->port.tty->termios.c_cflag & HUPCL) {\r\ninfo->serial_signals &= ~(SerialSignal_RTS | SerialSignal_DTR);\r\nset_signals(info);\r\n}\r\nspin_unlock_irqrestore(&info->lock,flags);\r\nif (info->port.tty)\r\nset_bit(TTY_IO_ERROR, &info->port.tty->flags);\r\ninfo->port.flags &= ~ASYNC_INITIALIZED;\r\n}\r\nstatic void program_hw(SLMP_INFO *info)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&info->lock,flags);\r\nrx_stop(info);\r\ntx_stop(info);\r\ninfo->tx_count = info->tx_put = info->tx_get = 0;\r\nif (info->params.mode == MGSL_MODE_HDLC || info->netcount)\r\nhdlc_mode(info);\r\nelse\r\nasync_mode(info);\r\nset_signals(info);\r\ninfo->dcd_chkcount = 0;\r\ninfo->cts_chkcount = 0;\r\ninfo->ri_chkcount = 0;\r\ninfo->dsr_chkcount = 0;\r\ninfo->ie1_value |= (CDCD|CCTS);\r\nwrite_reg(info, IE1, info->ie1_value);\r\nget_signals(info);\r\nif (info->netcount || (info->port.tty && info->port.tty->termios.c_cflag & CREAD) )\r\nrx_start(info);\r\nspin_unlock_irqrestore(&info->lock,flags);\r\n}\r\nstatic void change_params(SLMP_INFO *info)\r\n{\r\nunsigned cflag;\r\nint bits_per_char;\r\nif (!info->port.tty)\r\nreturn;\r\nif (debug_level >= DEBUG_LEVEL_INFO)\r\nprintk("%s(%d):%s change_params()\n",\r\n__FILE__,__LINE__, info->device_name );\r\ncflag = info->port.tty->termios.c_cflag;\r\nif (cflag & CBAUD)\r\ninfo->serial_signals |= SerialSignal_RTS | SerialSignal_DTR;\r\nelse\r\ninfo->serial_signals &= ~(SerialSignal_RTS | SerialSignal_DTR);\r\nswitch (cflag & CSIZE) {\r\ncase CS5: info->params.data_bits = 5; break;\r\ncase CS6: info->params.data_bits = 6; break;\r\ncase CS7: info->params.data_bits = 7; break;\r\ncase CS8: info->params.data_bits = 8; break;\r\ndefault: info->params.data_bits = 7; break;\r\n}\r\nif (cflag & CSTOPB)\r\ninfo->params.stop_bits = 2;\r\nelse\r\ninfo->params.stop_bits = 1;\r\ninfo->params.parity = ASYNC_PARITY_NONE;\r\nif (cflag & PARENB) {\r\nif (cflag & PARODD)\r\ninfo->params.parity = ASYNC_PARITY_ODD;\r\nelse\r\ninfo->params.parity = ASYNC_PARITY_EVEN;\r\n#ifdef CMSPAR\r\nif (cflag & CMSPAR)\r\ninfo->params.parity = ASYNC_PARITY_SPACE;\r\n#endif\r\n}\r\nbits_per_char = info->params.data_bits +\r\ninfo->params.stop_bits + 1;\r\nif (info->params.data_rate <= 460800) {\r\ninfo->params.data_rate = tty_get_baud_rate(info->port.tty);\r\n}\r\nif ( info->params.data_rate ) {\r\ninfo->timeout = (32*HZ*bits_per_char) /\r\ninfo->params.data_rate;\r\n}\r\ninfo->timeout += HZ/50;\r\nif (cflag & CRTSCTS)\r\ninfo->port.flags |= ASYNC_CTS_FLOW;\r\nelse\r\ninfo->port.flags &= ~ASYNC_CTS_FLOW;\r\nif (cflag & CLOCAL)\r\ninfo->port.flags &= ~ASYNC_CHECK_CD;\r\nelse\r\ninfo->port.flags |= ASYNC_CHECK_CD;\r\ninfo->read_status_mask2 = OVRN;\r\nif (I_INPCK(info->port.tty))\r\ninfo->read_status_mask2 |= PE | FRME;\r\nif (I_BRKINT(info->port.tty) || I_PARMRK(info->port.tty))\r\ninfo->read_status_mask1 |= BRKD;\r\nif (I_IGNPAR(info->port.tty))\r\ninfo->ignore_status_mask2 |= PE | FRME;\r\nif (I_IGNBRK(info->port.tty)) {\r\ninfo->ignore_status_mask1 |= BRKD;\r\nif (I_IGNPAR(info->port.tty))\r\ninfo->ignore_status_mask2 |= OVRN;\r\n}\r\nprogram_hw(info);\r\n}\r\nstatic int get_stats(SLMP_INFO * info, struct mgsl_icount __user *user_icount)\r\n{\r\nint err;\r\nif (debug_level >= DEBUG_LEVEL_INFO)\r\nprintk("%s(%d):%s get_params()\n",\r\n__FILE__,__LINE__, info->device_name);\r\nif (!user_icount) {\r\nmemset(&info->icount, 0, sizeof(info->icount));\r\n} else {\r\nmutex_lock(&info->port.mutex);\r\nCOPY_TO_USER(err, user_icount, &info->icount, sizeof(struct mgsl_icount));\r\nmutex_unlock(&info->port.mutex);\r\nif (err)\r\nreturn -EFAULT;\r\n}\r\nreturn 0;\r\n}\r\nstatic int get_params(SLMP_INFO * info, MGSL_PARAMS __user *user_params)\r\n{\r\nint err;\r\nif (debug_level >= DEBUG_LEVEL_INFO)\r\nprintk("%s(%d):%s get_params()\n",\r\n__FILE__,__LINE__, info->device_name);\r\nmutex_lock(&info->port.mutex);\r\nCOPY_TO_USER(err,user_params, &info->params, sizeof(MGSL_PARAMS));\r\nmutex_unlock(&info->port.mutex);\r\nif (err) {\r\nif ( debug_level >= DEBUG_LEVEL_INFO )\r\nprintk( "%s(%d):%s get_params() user buffer copy failed\n",\r\n__FILE__,__LINE__,info->device_name);\r\nreturn -EFAULT;\r\n}\r\nreturn 0;\r\n}\r\nstatic int set_params(SLMP_INFO * info, MGSL_PARAMS __user *new_params)\r\n{\r\nunsigned long flags;\r\nMGSL_PARAMS tmp_params;\r\nint err;\r\nif (debug_level >= DEBUG_LEVEL_INFO)\r\nprintk("%s(%d):%s set_params\n",\r\n__FILE__,__LINE__,info->device_name );\r\nCOPY_FROM_USER(err,&tmp_params, new_params, sizeof(MGSL_PARAMS));\r\nif (err) {\r\nif ( debug_level >= DEBUG_LEVEL_INFO )\r\nprintk( "%s(%d):%s set_params() user buffer copy failed\n",\r\n__FILE__,__LINE__,info->device_name);\r\nreturn -EFAULT;\r\n}\r\nmutex_lock(&info->port.mutex);\r\nspin_lock_irqsave(&info->lock,flags);\r\nmemcpy(&info->params,&tmp_params,sizeof(MGSL_PARAMS));\r\nspin_unlock_irqrestore(&info->lock,flags);\r\nchange_params(info);\r\nmutex_unlock(&info->port.mutex);\r\nreturn 0;\r\n}\r\nstatic int get_txidle(SLMP_INFO * info, int __user *idle_mode)\r\n{\r\nint err;\r\nif (debug_level >= DEBUG_LEVEL_INFO)\r\nprintk("%s(%d):%s get_txidle()=%d\n",\r\n__FILE__,__LINE__, info->device_name, info->idle_mode);\r\nCOPY_TO_USER(err,idle_mode, &info->idle_mode, sizeof(int));\r\nif (err) {\r\nif ( debug_level >= DEBUG_LEVEL_INFO )\r\nprintk( "%s(%d):%s get_txidle() user buffer copy failed\n",\r\n__FILE__,__LINE__,info->device_name);\r\nreturn -EFAULT;\r\n}\r\nreturn 0;\r\n}\r\nstatic int set_txidle(SLMP_INFO * info, int idle_mode)\r\n{\r\nunsigned long flags;\r\nif (debug_level >= DEBUG_LEVEL_INFO)\r\nprintk("%s(%d):%s set_txidle(%d)\n",\r\n__FILE__,__LINE__,info->device_name, idle_mode );\r\nspin_lock_irqsave(&info->lock,flags);\r\ninfo->idle_mode = idle_mode;\r\ntx_set_idle( info );\r\nspin_unlock_irqrestore(&info->lock,flags);\r\nreturn 0;\r\n}\r\nstatic int tx_enable(SLMP_INFO * info, int enable)\r\n{\r\nunsigned long flags;\r\nif (debug_level >= DEBUG_LEVEL_INFO)\r\nprintk("%s(%d):%s tx_enable(%d)\n",\r\n__FILE__,__LINE__,info->device_name, enable);\r\nspin_lock_irqsave(&info->lock,flags);\r\nif ( enable ) {\r\nif ( !info->tx_enabled ) {\r\ntx_start(info);\r\n}\r\n} else {\r\nif ( info->tx_enabled )\r\ntx_stop(info);\r\n}\r\nspin_unlock_irqrestore(&info->lock,flags);\r\nreturn 0;\r\n}\r\nstatic int tx_abort(SLMP_INFO * info)\r\n{\r\nunsigned long flags;\r\nif (debug_level >= DEBUG_LEVEL_INFO)\r\nprintk("%s(%d):%s tx_abort()\n",\r\n__FILE__,__LINE__,info->device_name);\r\nspin_lock_irqsave(&info->lock,flags);\r\nif ( info->tx_active && info->params.mode == MGSL_MODE_HDLC ) {\r\ninfo->ie1_value &= ~UDRN;\r\ninfo->ie1_value |= IDLE;\r\nwrite_reg(info, IE1, info->ie1_value);\r\nwrite_reg(info, SR1, (unsigned char)(IDLE + UDRN));\r\nwrite_reg(info, TXDMA + DSR, 0);\r\nwrite_reg(info, TXDMA + DCMD, SWABORT);\r\nwrite_reg(info, CMD, TXABORT);\r\n}\r\nspin_unlock_irqrestore(&info->lock,flags);\r\nreturn 0;\r\n}\r\nstatic int rx_enable(SLMP_INFO * info, int enable)\r\n{\r\nunsigned long flags;\r\nif (debug_level >= DEBUG_LEVEL_INFO)\r\nprintk("%s(%d):%s rx_enable(%d)\n",\r\n__FILE__,__LINE__,info->device_name,enable);\r\nspin_lock_irqsave(&info->lock,flags);\r\nif ( enable ) {\r\nif ( !info->rx_enabled )\r\nrx_start(info);\r\n} else {\r\nif ( info->rx_enabled )\r\nrx_stop(info);\r\n}\r\nspin_unlock_irqrestore(&info->lock,flags);\r\nreturn 0;\r\n}\r\nstatic int wait_mgsl_event(SLMP_INFO * info, int __user *mask_ptr)\r\n{\r\nunsigned long flags;\r\nint s;\r\nint rc=0;\r\nstruct mgsl_icount cprev, cnow;\r\nint events;\r\nint mask;\r\nstruct _input_signal_events oldsigs, newsigs;\r\nDECLARE_WAITQUEUE(wait, current);\r\nCOPY_FROM_USER(rc,&mask, mask_ptr, sizeof(int));\r\nif (rc) {\r\nreturn -EFAULT;\r\n}\r\nif (debug_level >= DEBUG_LEVEL_INFO)\r\nprintk("%s(%d):%s wait_mgsl_event(%d)\n",\r\n__FILE__,__LINE__,info->device_name,mask);\r\nspin_lock_irqsave(&info->lock,flags);\r\nget_signals(info);\r\ns = info->serial_signals;\r\nevents = mask &\r\n( ((s & SerialSignal_DSR) ? MgslEvent_DsrActive:MgslEvent_DsrInactive) +\r\n((s & SerialSignal_DCD) ? MgslEvent_DcdActive:MgslEvent_DcdInactive) +\r\n((s & SerialSignal_CTS) ? MgslEvent_CtsActive:MgslEvent_CtsInactive) +\r\n((s & SerialSignal_RI) ? MgslEvent_RiActive :MgslEvent_RiInactive) );\r\nif (events) {\r\nspin_unlock_irqrestore(&info->lock,flags);\r\ngoto exit;\r\n}\r\ncprev = info->icount;\r\noldsigs = info->input_signal_events;\r\nif (mask & (MgslEvent_ExitHuntMode+MgslEvent_IdleReceived)) {\r\nunsigned char oldval = info->ie1_value;\r\nunsigned char newval = oldval +\r\n(mask & MgslEvent_ExitHuntMode ? FLGD:0) +\r\n(mask & MgslEvent_IdleReceived ? IDLD:0);\r\nif ( oldval != newval ) {\r\ninfo->ie1_value = newval;\r\nwrite_reg(info, IE1, info->ie1_value);\r\n}\r\n}\r\nset_current_state(TASK_INTERRUPTIBLE);\r\nadd_wait_queue(&info->event_wait_q, &wait);\r\nspin_unlock_irqrestore(&info->lock,flags);\r\nfor(;;) {\r\nschedule();\r\nif (signal_pending(current)) {\r\nrc = -ERESTARTSYS;\r\nbreak;\r\n}\r\nspin_lock_irqsave(&info->lock,flags);\r\ncnow = info->icount;\r\nnewsigs = info->input_signal_events;\r\nset_current_state(TASK_INTERRUPTIBLE);\r\nspin_unlock_irqrestore(&info->lock,flags);\r\nif (newsigs.dsr_up == oldsigs.dsr_up &&\r\nnewsigs.dsr_down == oldsigs.dsr_down &&\r\nnewsigs.dcd_up == oldsigs.dcd_up &&\r\nnewsigs.dcd_down == oldsigs.dcd_down &&\r\nnewsigs.cts_up == oldsigs.cts_up &&\r\nnewsigs.cts_down == oldsigs.cts_down &&\r\nnewsigs.ri_up == oldsigs.ri_up &&\r\nnewsigs.ri_down == oldsigs.ri_down &&\r\ncnow.exithunt == cprev.exithunt &&\r\ncnow.rxidle == cprev.rxidle) {\r\nrc = -EIO;\r\nbreak;\r\n}\r\nevents = mask &\r\n( (newsigs.dsr_up != oldsigs.dsr_up ? MgslEvent_DsrActive:0) +\r\n(newsigs.dsr_down != oldsigs.dsr_down ? MgslEvent_DsrInactive:0) +\r\n(newsigs.dcd_up != oldsigs.dcd_up ? MgslEvent_DcdActive:0) +\r\n(newsigs.dcd_down != oldsigs.dcd_down ? MgslEvent_DcdInactive:0) +\r\n(newsigs.cts_up != oldsigs.cts_up ? MgslEvent_CtsActive:0) +\r\n(newsigs.cts_down != oldsigs.cts_down ? MgslEvent_CtsInactive:0) +\r\n(newsigs.ri_up != oldsigs.ri_up ? MgslEvent_RiActive:0) +\r\n(newsigs.ri_down != oldsigs.ri_down ? MgslEvent_RiInactive:0) +\r\n(cnow.exithunt != cprev.exithunt ? MgslEvent_ExitHuntMode:0) +\r\n(cnow.rxidle != cprev.rxidle ? MgslEvent_IdleReceived:0) );\r\nif (events)\r\nbreak;\r\ncprev = cnow;\r\noldsigs = newsigs;\r\n}\r\nremove_wait_queue(&info->event_wait_q, &wait);\r\nset_current_state(TASK_RUNNING);\r\nif (mask & (MgslEvent_ExitHuntMode + MgslEvent_IdleReceived)) {\r\nspin_lock_irqsave(&info->lock,flags);\r\nif (!waitqueue_active(&info->event_wait_q)) {\r\ninfo->ie1_value &= ~(FLGD|IDLD);\r\nwrite_reg(info, IE1, info->ie1_value);\r\n}\r\nspin_unlock_irqrestore(&info->lock,flags);\r\n}\r\nexit:\r\nif ( rc == 0 )\r\nPUT_USER(rc, events, mask_ptr);\r\nreturn rc;\r\n}\r\nstatic int modem_input_wait(SLMP_INFO *info,int arg)\r\n{\r\nunsigned long flags;\r\nint rc;\r\nstruct mgsl_icount cprev, cnow;\r\nDECLARE_WAITQUEUE(wait, current);\r\nspin_lock_irqsave(&info->lock,flags);\r\ncprev = info->icount;\r\nadd_wait_queue(&info->status_event_wait_q, &wait);\r\nset_current_state(TASK_INTERRUPTIBLE);\r\nspin_unlock_irqrestore(&info->lock,flags);\r\nfor(;;) {\r\nschedule();\r\nif (signal_pending(current)) {\r\nrc = -ERESTARTSYS;\r\nbreak;\r\n}\r\nspin_lock_irqsave(&info->lock,flags);\r\ncnow = info->icount;\r\nset_current_state(TASK_INTERRUPTIBLE);\r\nspin_unlock_irqrestore(&info->lock,flags);\r\nif (cnow.rng == cprev.rng && cnow.dsr == cprev.dsr &&\r\ncnow.dcd == cprev.dcd && cnow.cts == cprev.cts) {\r\nrc = -EIO;\r\nbreak;\r\n}\r\nif ((arg & TIOCM_RNG && cnow.rng != cprev.rng) ||\r\n(arg & TIOCM_DSR && cnow.dsr != cprev.dsr) ||\r\n(arg & TIOCM_CD && cnow.dcd != cprev.dcd) ||\r\n(arg & TIOCM_CTS && cnow.cts != cprev.cts)) {\r\nrc = 0;\r\nbreak;\r\n}\r\ncprev = cnow;\r\n}\r\nremove_wait_queue(&info->status_event_wait_q, &wait);\r\nset_current_state(TASK_RUNNING);\r\nreturn rc;\r\n}\r\nstatic int tiocmget(struct tty_struct *tty)\r\n{\r\nSLMP_INFO *info = tty->driver_data;\r\nunsigned int result;\r\nunsigned long flags;\r\nspin_lock_irqsave(&info->lock,flags);\r\nget_signals(info);\r\nspin_unlock_irqrestore(&info->lock,flags);\r\nresult = ((info->serial_signals & SerialSignal_RTS) ? TIOCM_RTS : 0) |\r\n((info->serial_signals & SerialSignal_DTR) ? TIOCM_DTR : 0) |\r\n((info->serial_signals & SerialSignal_DCD) ? TIOCM_CAR : 0) |\r\n((info->serial_signals & SerialSignal_RI) ? TIOCM_RNG : 0) |\r\n((info->serial_signals & SerialSignal_DSR) ? TIOCM_DSR : 0) |\r\n((info->serial_signals & SerialSignal_CTS) ? TIOCM_CTS : 0);\r\nif (debug_level >= DEBUG_LEVEL_INFO)\r\nprintk("%s(%d):%s tiocmget() value=%08X\n",\r\n__FILE__,__LINE__, info->device_name, result );\r\nreturn result;\r\n}\r\nstatic int tiocmset(struct tty_struct *tty,\r\nunsigned int set, unsigned int clear)\r\n{\r\nSLMP_INFO *info = tty->driver_data;\r\nunsigned long flags;\r\nif (debug_level >= DEBUG_LEVEL_INFO)\r\nprintk("%s(%d):%s tiocmset(%x,%x)\n",\r\n__FILE__,__LINE__,info->device_name, set, clear);\r\nif (set & TIOCM_RTS)\r\ninfo->serial_signals |= SerialSignal_RTS;\r\nif (set & TIOCM_DTR)\r\ninfo->serial_signals |= SerialSignal_DTR;\r\nif (clear & TIOCM_RTS)\r\ninfo->serial_signals &= ~SerialSignal_RTS;\r\nif (clear & TIOCM_DTR)\r\ninfo->serial_signals &= ~SerialSignal_DTR;\r\nspin_lock_irqsave(&info->lock,flags);\r\nset_signals(info);\r\nspin_unlock_irqrestore(&info->lock,flags);\r\nreturn 0;\r\n}\r\nstatic int carrier_raised(struct tty_port *port)\r\n{\r\nSLMP_INFO *info = container_of(port, SLMP_INFO, port);\r\nunsigned long flags;\r\nspin_lock_irqsave(&info->lock,flags);\r\nget_signals(info);\r\nspin_unlock_irqrestore(&info->lock,flags);\r\nreturn (info->serial_signals & SerialSignal_DCD) ? 1 : 0;\r\n}\r\nstatic void dtr_rts(struct tty_port *port, int on)\r\n{\r\nSLMP_INFO *info = container_of(port, SLMP_INFO, port);\r\nunsigned long flags;\r\nspin_lock_irqsave(&info->lock,flags);\r\nif (on)\r\ninfo->serial_signals |= SerialSignal_RTS | SerialSignal_DTR;\r\nelse\r\ninfo->serial_signals &= ~(SerialSignal_RTS | SerialSignal_DTR);\r\nset_signals(info);\r\nspin_unlock_irqrestore(&info->lock,flags);\r\n}\r\nstatic int block_til_ready(struct tty_struct *tty, struct file *filp,\r\nSLMP_INFO *info)\r\n{\r\nDECLARE_WAITQUEUE(wait, current);\r\nint retval;\r\nbool do_clocal = false;\r\nunsigned long flags;\r\nint cd;\r\nstruct tty_port *port = &info->port;\r\nif (debug_level >= DEBUG_LEVEL_INFO)\r\nprintk("%s(%d):%s block_til_ready()\n",\r\n__FILE__,__LINE__, tty->driver->name );\r\nif (filp->f_flags & O_NONBLOCK || tty->flags & (1 << TTY_IO_ERROR)){\r\nport->flags |= ASYNC_NORMAL_ACTIVE;\r\nreturn 0;\r\n}\r\nif (tty->termios.c_cflag & CLOCAL)\r\ndo_clocal = true;\r\nretval = 0;\r\nadd_wait_queue(&port->open_wait, &wait);\r\nif (debug_level >= DEBUG_LEVEL_INFO)\r\nprintk("%s(%d):%s block_til_ready() before block, count=%d\n",\r\n__FILE__,__LINE__, tty->driver->name, port->count );\r\nspin_lock_irqsave(&info->lock, flags);\r\nport->count--;\r\nspin_unlock_irqrestore(&info->lock, flags);\r\nport->blocked_open++;\r\nwhile (1) {\r\nif (C_BAUD(tty) && test_bit(ASYNCB_INITIALIZED, &port->flags))\r\ntty_port_raise_dtr_rts(port);\r\nset_current_state(TASK_INTERRUPTIBLE);\r\nif (tty_hung_up_p(filp) || !(port->flags & ASYNC_INITIALIZED)){\r\nretval = (port->flags & ASYNC_HUP_NOTIFY) ?\r\n-EAGAIN : -ERESTARTSYS;\r\nbreak;\r\n}\r\ncd = tty_port_carrier_raised(port);\r\nif (do_clocal || cd)\r\nbreak;\r\nif (signal_pending(current)) {\r\nretval = -ERESTARTSYS;\r\nbreak;\r\n}\r\nif (debug_level >= DEBUG_LEVEL_INFO)\r\nprintk("%s(%d):%s block_til_ready() count=%d\n",\r\n__FILE__,__LINE__, tty->driver->name, port->count );\r\ntty_unlock(tty);\r\nschedule();\r\ntty_lock(tty);\r\n}\r\nset_current_state(TASK_RUNNING);\r\nremove_wait_queue(&port->open_wait, &wait);\r\nif (!tty_hung_up_p(filp))\r\nport->count++;\r\nport->blocked_open--;\r\nif (debug_level >= DEBUG_LEVEL_INFO)\r\nprintk("%s(%d):%s block_til_ready() after, count=%d\n",\r\n__FILE__,__LINE__, tty->driver->name, port->count );\r\nif (!retval)\r\nport->flags |= ASYNC_NORMAL_ACTIVE;\r\nreturn retval;\r\n}\r\nstatic int alloc_dma_bufs(SLMP_INFO *info)\r\n{\r\nunsigned short BuffersPerFrame;\r\nunsigned short BufferCount;\r\ninfo->port_array[0]->last_mem_alloc = (SCA_MEM_SIZE/4) * info->port_num;\r\nBuffersPerFrame = (unsigned short)(info->max_frame_size/SCABUFSIZE);\r\nif ( info->max_frame_size % SCABUFSIZE )\r\nBuffersPerFrame++;\r\nBufferCount = (SCA_MEM_SIZE/4 - BUFFERLISTSIZE)/SCABUFSIZE;\r\nif (BufferCount > BUFFERLISTSIZE/sizeof(SCADESC))\r\nBufferCount = BUFFERLISTSIZE/sizeof(SCADESC);\r\ninfo->tx_buf_count = BuffersPerFrame + 1;\r\nif (info->tx_buf_count > (BufferCount/2))\r\ninfo->tx_buf_count = BufferCount/2;\r\nif (info->tx_buf_count > SCAMAXDESC)\r\ninfo->tx_buf_count = SCAMAXDESC;\r\ninfo->rx_buf_count = BufferCount - info->tx_buf_count;\r\nif (info->rx_buf_count > SCAMAXDESC)\r\ninfo->rx_buf_count = SCAMAXDESC;\r\nif ( debug_level >= DEBUG_LEVEL_INFO )\r\nprintk("%s(%d):%s Allocating %d TX and %d RX DMA buffers.\n",\r\n__FILE__,__LINE__, info->device_name,\r\ninfo->tx_buf_count,info->rx_buf_count);\r\nif ( alloc_buf_list( info ) < 0 ||\r\nalloc_frame_bufs(info,\r\ninfo->rx_buf_list,\r\ninfo->rx_buf_list_ex,\r\ninfo->rx_buf_count) < 0 ||\r\nalloc_frame_bufs(info,\r\ninfo->tx_buf_list,\r\ninfo->tx_buf_list_ex,\r\ninfo->tx_buf_count) < 0 ||\r\nalloc_tmp_rx_buf(info) < 0 ) {\r\nprintk("%s(%d):%s Can't allocate DMA buffer memory\n",\r\n__FILE__,__LINE__, info->device_name);\r\nreturn -ENOMEM;\r\n}\r\nrx_reset_buffers( info );\r\nreturn 0;\r\n}\r\nstatic int alloc_buf_list(SLMP_INFO *info)\r\n{\r\nunsigned int i;\r\ninfo->buffer_list = info->memory_base + info->port_array[0]->last_mem_alloc;\r\ninfo->buffer_list_phys = info->port_array[0]->last_mem_alloc;\r\ninfo->port_array[0]->last_mem_alloc += BUFFERLISTSIZE;\r\nmemset(info->buffer_list, 0, BUFFERLISTSIZE);\r\ninfo->rx_buf_list = (SCADESC *)info->buffer_list;\r\ninfo->tx_buf_list = (SCADESC *)info->buffer_list;\r\ninfo->tx_buf_list += info->rx_buf_count;\r\nfor ( i = 0; i < info->rx_buf_count; i++ ) {\r\ninfo->rx_buf_list_ex[i].phys_entry =\r\ninfo->buffer_list_phys + (i * SCABUFSIZE);\r\ninfo->rx_buf_list[i].next = info->buffer_list_phys;\r\nif ( i < info->rx_buf_count - 1 )\r\ninfo->rx_buf_list[i].next += (i + 1) * sizeof(SCADESC);\r\ninfo->rx_buf_list[i].length = SCABUFSIZE;\r\n}\r\nfor ( i = 0; i < info->tx_buf_count; i++ ) {\r\ninfo->tx_buf_list_ex[i].phys_entry = info->buffer_list_phys +\r\n((info->rx_buf_count + i) * sizeof(SCADESC));\r\ninfo->tx_buf_list[i].next = info->buffer_list_phys +\r\ninfo->rx_buf_count * sizeof(SCADESC);\r\nif ( i < info->tx_buf_count - 1 )\r\ninfo->tx_buf_list[i].next += (i + 1) * sizeof(SCADESC);\r\n}\r\nreturn 0;\r\n}\r\nstatic int alloc_frame_bufs(SLMP_INFO *info, SCADESC *buf_list,SCADESC_EX *buf_list_ex,int count)\r\n{\r\nint i;\r\nunsigned long phys_addr;\r\nfor ( i = 0; i < count; i++ ) {\r\nbuf_list_ex[i].virt_addr = info->memory_base + info->port_array[0]->last_mem_alloc;\r\nphys_addr = info->port_array[0]->last_mem_alloc;\r\ninfo->port_array[0]->last_mem_alloc += SCABUFSIZE;\r\nbuf_list[i].buf_ptr = (unsigned short)phys_addr;\r\nbuf_list[i].buf_base = (unsigned char)(phys_addr >> 16);\r\n}\r\nreturn 0;\r\n}\r\nstatic void free_dma_bufs(SLMP_INFO *info)\r\n{\r\ninfo->buffer_list = NULL;\r\ninfo->rx_buf_list = NULL;\r\ninfo->tx_buf_list = NULL;\r\n}\r\nstatic int alloc_tmp_rx_buf(SLMP_INFO *info)\r\n{\r\ninfo->tmp_rx_buf = kmalloc(info->max_frame_size, GFP_KERNEL);\r\nif (info->tmp_rx_buf == NULL)\r\nreturn -ENOMEM;\r\ninfo->flag_buf = kzalloc(info->max_frame_size, GFP_KERNEL);\r\nif (!info->flag_buf) {\r\nkfree(info->tmp_rx_buf);\r\ninfo->tmp_rx_buf = NULL;\r\nreturn -ENOMEM;\r\n}\r\nreturn 0;\r\n}\r\nstatic void free_tmp_rx_buf(SLMP_INFO *info)\r\n{\r\nkfree(info->tmp_rx_buf);\r\ninfo->tmp_rx_buf = NULL;\r\nkfree(info->flag_buf);\r\ninfo->flag_buf = NULL;\r\n}\r\nstatic int claim_resources(SLMP_INFO *info)\r\n{\r\nif (request_mem_region(info->phys_memory_base,SCA_MEM_SIZE,"synclinkmp") == NULL) {\r\nprintk( "%s(%d):%s mem addr conflict, Addr=%08X\n",\r\n__FILE__,__LINE__,info->device_name, info->phys_memory_base);\r\ninfo->init_error = DiagStatus_AddressConflict;\r\ngoto errout;\r\n}\r\nelse\r\ninfo->shared_mem_requested = true;\r\nif (request_mem_region(info->phys_lcr_base + info->lcr_offset,128,"synclinkmp") == NULL) {\r\nprintk( "%s(%d):%s lcr mem addr conflict, Addr=%08X\n",\r\n__FILE__,__LINE__,info->device_name, info->phys_lcr_base);\r\ninfo->init_error = DiagStatus_AddressConflict;\r\ngoto errout;\r\n}\r\nelse\r\ninfo->lcr_mem_requested = true;\r\nif (request_mem_region(info->phys_sca_base + info->sca_offset,SCA_BASE_SIZE,"synclinkmp") == NULL) {\r\nprintk( "%s(%d):%s sca mem addr conflict, Addr=%08X\n",\r\n__FILE__,__LINE__,info->device_name, info->phys_sca_base);\r\ninfo->init_error = DiagStatus_AddressConflict;\r\ngoto errout;\r\n}\r\nelse\r\ninfo->sca_base_requested = true;\r\nif (request_mem_region(info->phys_statctrl_base + info->statctrl_offset,SCA_REG_SIZE,"synclinkmp") == NULL) {\r\nprintk( "%s(%d):%s stat/ctrl mem addr conflict, Addr=%08X\n",\r\n__FILE__,__LINE__,info->device_name, info->phys_statctrl_base);\r\ninfo->init_error = DiagStatus_AddressConflict;\r\ngoto errout;\r\n}\r\nelse\r\ninfo->sca_statctrl_requested = true;\r\ninfo->memory_base = ioremap_nocache(info->phys_memory_base,\r\nSCA_MEM_SIZE);\r\nif (!info->memory_base) {\r\nprintk( "%s(%d):%s Can't map shared memory, MemAddr=%08X\n",\r\n__FILE__,__LINE__,info->device_name, info->phys_memory_base );\r\ninfo->init_error = DiagStatus_CantAssignPciResources;\r\ngoto errout;\r\n}\r\ninfo->lcr_base = ioremap_nocache(info->phys_lcr_base, PAGE_SIZE);\r\nif (!info->lcr_base) {\r\nprintk( "%s(%d):%s Can't map LCR memory, MemAddr=%08X\n",\r\n__FILE__,__LINE__,info->device_name, info->phys_lcr_base );\r\ninfo->init_error = DiagStatus_CantAssignPciResources;\r\ngoto errout;\r\n}\r\ninfo->lcr_base += info->lcr_offset;\r\ninfo->sca_base = ioremap_nocache(info->phys_sca_base, PAGE_SIZE);\r\nif (!info->sca_base) {\r\nprintk( "%s(%d):%s Can't map SCA memory, MemAddr=%08X\n",\r\n__FILE__,__LINE__,info->device_name, info->phys_sca_base );\r\ninfo->init_error = DiagStatus_CantAssignPciResources;\r\ngoto errout;\r\n}\r\ninfo->sca_base += info->sca_offset;\r\ninfo->statctrl_base = ioremap_nocache(info->phys_statctrl_base,\r\nPAGE_SIZE);\r\nif (!info->statctrl_base) {\r\nprintk( "%s(%d):%s Can't map SCA Status/Control memory, MemAddr=%08X\n",\r\n__FILE__,__LINE__,info->device_name, info->phys_statctrl_base );\r\ninfo->init_error = DiagStatus_CantAssignPciResources;\r\ngoto errout;\r\n}\r\ninfo->statctrl_base += info->statctrl_offset;\r\nif ( !memory_test(info) ) {\r\nprintk( "%s(%d):Shared Memory Test failed for device %s MemAddr=%08X\n",\r\n__FILE__,__LINE__,info->device_name, info->phys_memory_base );\r\ninfo->init_error = DiagStatus_MemoryError;\r\ngoto errout;\r\n}\r\nreturn 0;\r\nerrout:\r\nrelease_resources( info );\r\nreturn -ENODEV;\r\n}\r\nstatic void release_resources(SLMP_INFO *info)\r\n{\r\nif ( debug_level >= DEBUG_LEVEL_INFO )\r\nprintk( "%s(%d):%s release_resources() entry\n",\r\n__FILE__,__LINE__,info->device_name );\r\nif ( info->irq_requested ) {\r\nfree_irq(info->irq_level, info);\r\ninfo->irq_requested = false;\r\n}\r\nif ( info->shared_mem_requested ) {\r\nrelease_mem_region(info->phys_memory_base,SCA_MEM_SIZE);\r\ninfo->shared_mem_requested = false;\r\n}\r\nif ( info->lcr_mem_requested ) {\r\nrelease_mem_region(info->phys_lcr_base + info->lcr_offset,128);\r\ninfo->lcr_mem_requested = false;\r\n}\r\nif ( info->sca_base_requested ) {\r\nrelease_mem_region(info->phys_sca_base + info->sca_offset,SCA_BASE_SIZE);\r\ninfo->sca_base_requested = false;\r\n}\r\nif ( info->sca_statctrl_requested ) {\r\nrelease_mem_region(info->phys_statctrl_base + info->statctrl_offset,SCA_REG_SIZE);\r\ninfo->sca_statctrl_requested = false;\r\n}\r\nif (info->memory_base){\r\niounmap(info->memory_base);\r\ninfo->memory_base = NULL;\r\n}\r\nif (info->sca_base) {\r\niounmap(info->sca_base - info->sca_offset);\r\ninfo->sca_base=NULL;\r\n}\r\nif (info->statctrl_base) {\r\niounmap(info->statctrl_base - info->statctrl_offset);\r\ninfo->statctrl_base=NULL;\r\n}\r\nif (info->lcr_base){\r\niounmap(info->lcr_base - info->lcr_offset);\r\ninfo->lcr_base = NULL;\r\n}\r\nif ( debug_level >= DEBUG_LEVEL_INFO )\r\nprintk( "%s(%d):%s release_resources() exit\n",\r\n__FILE__,__LINE__,info->device_name );\r\n}\r\nstatic void add_device(SLMP_INFO *info)\r\n{\r\ninfo->next_device = NULL;\r\ninfo->line = synclinkmp_device_count;\r\nsprintf(info->device_name,"ttySLM%dp%d",info->adapter_num,info->port_num);\r\nif (info->line < MAX_DEVICES) {\r\nif (maxframe[info->line])\r\ninfo->max_frame_size = maxframe[info->line];\r\n}\r\nsynclinkmp_device_count++;\r\nif ( !synclinkmp_device_list )\r\nsynclinkmp_device_list = info;\r\nelse {\r\nSLMP_INFO *current_dev = synclinkmp_device_list;\r\nwhile( current_dev->next_device )\r\ncurrent_dev = current_dev->next_device;\r\ncurrent_dev->next_device = info;\r\n}\r\nif ( info->max_frame_size < 4096 )\r\ninfo->max_frame_size = 4096;\r\nelse if ( info->max_frame_size > 65535 )\r\ninfo->max_frame_size = 65535;\r\nprintk( "SyncLink MultiPort %s: "\r\n"Mem=(%08x %08X %08x %08X) IRQ=%d MaxFrameSize=%u\n",\r\ninfo->device_name,\r\ninfo->phys_sca_base,\r\ninfo->phys_memory_base,\r\ninfo->phys_statctrl_base,\r\ninfo->phys_lcr_base,\r\ninfo->irq_level,\r\ninfo->max_frame_size );\r\n#if SYNCLINK_GENERIC_HDLC\r\nhdlcdev_init(info);\r\n#endif\r\n}\r\nstatic SLMP_INFO *alloc_dev(int adapter_num, int port_num, struct pci_dev *pdev)\r\n{\r\nSLMP_INFO *info;\r\ninfo = kzalloc(sizeof(SLMP_INFO),\r\nGFP_KERNEL);\r\nif (!info) {\r\nprintk("%s(%d) Error can't allocate device instance data for adapter %d, port %d\n",\r\n__FILE__,__LINE__, adapter_num, port_num);\r\n} else {\r\ntty_port_init(&info->port);\r\ninfo->port.ops = &port_ops;\r\ninfo->magic = MGSL_MAGIC;\r\nINIT_WORK(&info->task, bh_handler);\r\ninfo->max_frame_size = 4096;\r\ninfo->port.close_delay = 5*HZ/10;\r\ninfo->port.closing_wait = 30*HZ;\r\ninit_waitqueue_head(&info->status_event_wait_q);\r\ninit_waitqueue_head(&info->event_wait_q);\r\nspin_lock_init(&info->netlock);\r\nmemcpy(&info->params,&default_params,sizeof(MGSL_PARAMS));\r\ninfo->idle_mode = HDLC_TXIDLE_FLAGS;\r\ninfo->adapter_num = adapter_num;\r\ninfo->port_num = port_num;\r\ninfo->irq_level = pdev->irq;\r\ninfo->phys_lcr_base = pci_resource_start(pdev,0);\r\ninfo->phys_sca_base = pci_resource_start(pdev,2);\r\ninfo->phys_memory_base = pci_resource_start(pdev,3);\r\ninfo->phys_statctrl_base = pci_resource_start(pdev,4);\r\ninfo->lcr_offset = info->phys_lcr_base & (PAGE_SIZE-1);\r\ninfo->phys_lcr_base &= ~(PAGE_SIZE-1);\r\ninfo->sca_offset = info->phys_sca_base & (PAGE_SIZE-1);\r\ninfo->phys_sca_base &= ~(PAGE_SIZE-1);\r\ninfo->statctrl_offset = info->phys_statctrl_base & (PAGE_SIZE-1);\r\ninfo->phys_statctrl_base &= ~(PAGE_SIZE-1);\r\ninfo->bus_type = MGSL_BUS_TYPE_PCI;\r\ninfo->irq_flags = IRQF_SHARED;\r\nsetup_timer(&info->tx_timer, tx_timeout, (unsigned long)info);\r\nsetup_timer(&info->status_timer, status_timeout,\r\n(unsigned long)info);\r\ninfo->misc_ctrl_value = 0x087e4546;\r\ninfo->init_error = -1;\r\n}\r\nreturn info;\r\n}\r\nstatic void device_init(int adapter_num, struct pci_dev *pdev)\r\n{\r\nSLMP_INFO *port_array[SCA_MAX_PORTS];\r\nint port;\r\nfor ( port = 0; port < SCA_MAX_PORTS; ++port ) {\r\nport_array[port] = alloc_dev(adapter_num,port,pdev);\r\nif( port_array[port] == NULL ) {\r\nfor (--port; port >= 0; --port) {\r\ntty_port_destroy(&port_array[port]->port);\r\nkfree(port_array[port]);\r\n}\r\nreturn;\r\n}\r\n}\r\nfor ( port = 0; port < SCA_MAX_PORTS; ++port ) {\r\nmemcpy(port_array[port]->port_array,port_array,sizeof(port_array));\r\nadd_device( port_array[port] );\r\nspin_lock_init(&port_array[port]->lock);\r\n}\r\nif ( !claim_resources(port_array[0]) ) {\r\nalloc_dma_bufs(port_array[0]);\r\nfor ( port = 1; port < SCA_MAX_PORTS; ++port ) {\r\nport_array[port]->lock = port_array[0]->lock;\r\nport_array[port]->irq_level = port_array[0]->irq_level;\r\nport_array[port]->memory_base = port_array[0]->memory_base;\r\nport_array[port]->sca_base = port_array[0]->sca_base;\r\nport_array[port]->statctrl_base = port_array[0]->statctrl_base;\r\nport_array[port]->lcr_base = port_array[0]->lcr_base;\r\nalloc_dma_bufs(port_array[port]);\r\n}\r\nif ( request_irq(port_array[0]->irq_level,\r\nsynclinkmp_interrupt,\r\nport_array[0]->irq_flags,\r\nport_array[0]->device_name,\r\nport_array[0]) < 0 ) {\r\nprintk( "%s(%d):%s Can't request interrupt, IRQ=%d\n",\r\n__FILE__,__LINE__,\r\nport_array[0]->device_name,\r\nport_array[0]->irq_level );\r\n}\r\nelse {\r\nport_array[0]->irq_requested = true;\r\nadapter_test(port_array[0]);\r\n}\r\n}\r\n}\r\nstatic void synclinkmp_cleanup(void)\r\n{\r\nint rc;\r\nSLMP_INFO *info;\r\nSLMP_INFO *tmp;\r\nprintk("Unloading %s %s\n", driver_name, driver_version);\r\nif (serial_driver) {\r\nrc = tty_unregister_driver(serial_driver);\r\nif (rc)\r\nprintk("%s(%d) failed to unregister tty driver err=%d\n",\r\n__FILE__,__LINE__,rc);\r\nput_tty_driver(serial_driver);\r\n}\r\ninfo = synclinkmp_device_list;\r\nwhile(info) {\r\nreset_port(info);\r\ninfo = info->next_device;\r\n}\r\ninfo = synclinkmp_device_list;\r\nwhile(info) {\r\n#if SYNCLINK_GENERIC_HDLC\r\nhdlcdev_exit(info);\r\n#endif\r\nfree_dma_bufs(info);\r\nfree_tmp_rx_buf(info);\r\nif ( info->port_num == 0 ) {\r\nif (info->sca_base)\r\nwrite_reg(info, LPR, 1);\r\nrelease_resources(info);\r\n}\r\ntmp = info;\r\ninfo = info->next_device;\r\ntty_port_destroy(&tmp->port);\r\nkfree(tmp);\r\n}\r\npci_unregister_driver(&synclinkmp_pci_driver);\r\n}\r\nstatic int __init synclinkmp_init(void)\r\n{\r\nint rc;\r\nif (break_on_load) {\r\nsynclinkmp_get_text_ptr();\r\nBREAKPOINT();\r\n}\r\nprintk("%s %s\n", driver_name, driver_version);\r\nif ((rc = pci_register_driver(&synclinkmp_pci_driver)) < 0) {\r\nprintk("%s:failed to register PCI driver, error=%d\n",__FILE__,rc);\r\nreturn rc;\r\n}\r\nserial_driver = alloc_tty_driver(128);\r\nif (!serial_driver) {\r\nrc = -ENOMEM;\r\ngoto error;\r\n}\r\nserial_driver->driver_name = "synclinkmp";\r\nserial_driver->name = "ttySLM";\r\nserial_driver->major = ttymajor;\r\nserial_driver->minor_start = 64;\r\nserial_driver->type = TTY_DRIVER_TYPE_SERIAL;\r\nserial_driver->subtype = SERIAL_TYPE_NORMAL;\r\nserial_driver->init_termios = tty_std_termios;\r\nserial_driver->init_termios.c_cflag =\r\nB9600 | CS8 | CREAD | HUPCL | CLOCAL;\r\nserial_driver->init_termios.c_ispeed = 9600;\r\nserial_driver->init_termios.c_ospeed = 9600;\r\nserial_driver->flags = TTY_DRIVER_REAL_RAW;\r\ntty_set_operations(serial_driver, &ops);\r\nif ((rc = tty_register_driver(serial_driver)) < 0) {\r\nprintk("%s(%d):Couldn't register serial driver\n",\r\n__FILE__,__LINE__);\r\nput_tty_driver(serial_driver);\r\nserial_driver = NULL;\r\ngoto error;\r\n}\r\nprintk("%s %s, tty major#%d\n",\r\ndriver_name, driver_version,\r\nserial_driver->major);\r\nreturn 0;\r\nerror:\r\nsynclinkmp_cleanup();\r\nreturn rc;\r\n}\r\nstatic void __exit synclinkmp_exit(void)\r\n{\r\nsynclinkmp_cleanup();\r\n}\r\nstatic void enable_loopback(SLMP_INFO *info, int enable)\r\n{\r\nif (enable) {\r\nwrite_reg(info, MD2, (unsigned char)(read_reg(info, MD2) | (BIT1 + BIT0)));\r\ninfo->port_array[0]->ctrlreg_value |= (BIT0 << (info->port_num * 2));\r\nwrite_control_reg(info);\r\nwrite_reg(info, RXS, 0x40);\r\nwrite_reg(info, TXS, 0x40);\r\n} else {\r\nwrite_reg(info, MD2, (unsigned char)(read_reg(info, MD2) & ~(BIT1 + BIT0)));\r\nwrite_reg(info, RXS, 0x00);\r\nwrite_reg(info, TXS, 0x00);\r\n}\r\nif (info->params.clock_speed)\r\nset_rate(info, info->params.clock_speed);\r\nelse\r\nset_rate(info, 3686400);\r\n}\r\nstatic void set_rate( SLMP_INFO *info, u32 data_rate )\r\n{\r\nu32 TMCValue;\r\nunsigned char BRValue;\r\nu32 Divisor=0;\r\nif (data_rate != 0) {\r\nDivisor = 14745600/data_rate;\r\nif (!Divisor)\r\nDivisor = 1;\r\nTMCValue = Divisor;\r\nBRValue = 0;\r\nif (TMCValue != 1 && TMCValue != 2) {\r\nBRValue = 1;\r\nTMCValue >>= 1;\r\n}\r\nfor(; TMCValue > 256 && BRValue < 10; BRValue++)\r\nTMCValue >>= 1;\r\nwrite_reg(info, TXS,\r\n(unsigned char)((read_reg(info, TXS) & 0xf0) | BRValue));\r\nwrite_reg(info, RXS,\r\n(unsigned char)((read_reg(info, RXS) & 0xf0) | BRValue));\r\nwrite_reg(info, TMC, (unsigned char)TMCValue);\r\n}\r\nelse {\r\nwrite_reg(info, TXS,0);\r\nwrite_reg(info, RXS,0);\r\nwrite_reg(info, TMC, 0);\r\n}\r\n}\r\nstatic void rx_stop(SLMP_INFO *info)\r\n{\r\nif (debug_level >= DEBUG_LEVEL_ISR)\r\nprintk("%s(%d):%s rx_stop()\n",\r\n__FILE__,__LINE__, info->device_name );\r\nwrite_reg(info, CMD, RXRESET);\r\ninfo->ie0_value &= ~RXRDYE;\r\nwrite_reg(info, IE0, info->ie0_value);\r\nwrite_reg(info, RXDMA + DSR, 0);\r\nwrite_reg(info, RXDMA + DCMD, SWABORT);\r\nwrite_reg(info, RXDMA + DIR, 0);\r\ninfo->rx_enabled = false;\r\ninfo->rx_overflow = false;\r\n}\r\nstatic void rx_start(SLMP_INFO *info)\r\n{\r\nint i;\r\nif (debug_level >= DEBUG_LEVEL_ISR)\r\nprintk("%s(%d):%s rx_start()\n",\r\n__FILE__,__LINE__, info->device_name );\r\nwrite_reg(info, CMD, RXRESET);\r\nif ( info->params.mode == MGSL_MODE_HDLC ) {\r\ninfo->ie0_value &= ~RXRDYE;\r\nwrite_reg(info, IE0, info->ie0_value);\r\nwrite_reg(info, RXDMA + DSR, 0);\r\nwrite_reg(info, RXDMA + DCMD, SWABORT);\r\nfor (i = 0; i < info->rx_buf_count; i++) {\r\ninfo->rx_buf_list[i].status = 0xff;\r\nif (!(i % 4))\r\nread_status_reg(info);\r\n}\r\ninfo->current_rx_buf = 0;\r\nwrite_reg16(info, RXDMA + CDA,\r\ninfo->rx_buf_list_ex[0].phys_entry);\r\nwrite_reg16(info, RXDMA + EDA,\r\ninfo->rx_buf_list_ex[info->rx_buf_count - 1].phys_entry);\r\nwrite_reg16(info, RXDMA + BFL, SCABUFSIZE);\r\nwrite_reg(info, RXDMA + DIR, 0x60);\r\nwrite_reg(info, RXDMA + DSR, 0xf2);\r\n} else {\r\ninfo->ie0_value |= RXRDYE;\r\nwrite_reg(info, IE0, info->ie0_value);\r\n}\r\nwrite_reg(info, CMD, RXENABLE);\r\ninfo->rx_overflow = false;\r\ninfo->rx_enabled = true;\r\n}\r\nstatic void tx_start(SLMP_INFO *info)\r\n{\r\nif (debug_level >= DEBUG_LEVEL_ISR)\r\nprintk("%s(%d):%s tx_start() tx_count=%d\n",\r\n__FILE__,__LINE__, info->device_name,info->tx_count );\r\nif (!info->tx_enabled ) {\r\nwrite_reg(info, CMD, TXRESET);\r\nwrite_reg(info, CMD, TXENABLE);\r\ninfo->tx_enabled = true;\r\n}\r\nif ( info->tx_count ) {\r\ninfo->drop_rts_on_tx_done = false;\r\nif (info->params.mode != MGSL_MODE_ASYNC) {\r\nif ( info->params.flags & HDLC_FLAG_AUTO_RTS ) {\r\nget_signals( info );\r\nif ( !(info->serial_signals & SerialSignal_RTS) ) {\r\ninfo->serial_signals |= SerialSignal_RTS;\r\nset_signals( info );\r\ninfo->drop_rts_on_tx_done = true;\r\n}\r\n}\r\nwrite_reg16(info, TRC0,\r\n(unsigned short)(((tx_negate_fifo_level-1)<<8) + tx_active_fifo_level));\r\nwrite_reg(info, TXDMA + DSR, 0);\r\nwrite_reg(info, TXDMA + DCMD, SWABORT);\r\nwrite_reg16(info, TXDMA + CDA,\r\ninfo->tx_buf_list_ex[0].phys_entry);\r\nwrite_reg16(info, TXDMA + EDA,\r\ninfo->tx_buf_list_ex[info->last_tx_buf].phys_entry);\r\ninfo->ie1_value &= ~IDLE;\r\ninfo->ie1_value |= UDRN;\r\nwrite_reg(info, IE1, info->ie1_value);\r\nwrite_reg(info, SR1, (unsigned char)(IDLE + UDRN));\r\nwrite_reg(info, TXDMA + DIR, 0x40);\r\nwrite_reg(info, TXDMA + DSR, 0xf2);\r\nmod_timer(&info->tx_timer, jiffies +\r\nmsecs_to_jiffies(5000));\r\n}\r\nelse {\r\ntx_load_fifo(info);\r\ninfo->ie0_value |= TXRDYE;\r\nwrite_reg(info, IE0, info->ie0_value);\r\n}\r\ninfo->tx_active = true;\r\n}\r\n}\r\nstatic void tx_stop( SLMP_INFO *info )\r\n{\r\nif (debug_level >= DEBUG_LEVEL_ISR)\r\nprintk("%s(%d):%s tx_stop()\n",\r\n__FILE__,__LINE__, info->device_name );\r\ndel_timer(&info->tx_timer);\r\nwrite_reg(info, TXDMA + DSR, 0);\r\nwrite_reg(info, TXDMA + DCMD, SWABORT);\r\nwrite_reg(info, CMD, TXRESET);\r\ninfo->ie1_value &= ~(UDRN + IDLE);\r\nwrite_reg(info, IE1, info->ie1_value);\r\nwrite_reg(info, SR1, (unsigned char)(IDLE + UDRN));\r\ninfo->ie0_value &= ~TXRDYE;\r\nwrite_reg(info, IE0, info->ie0_value);\r\ninfo->tx_enabled = false;\r\ninfo->tx_active = false;\r\n}\r\nstatic void tx_load_fifo(SLMP_INFO *info)\r\n{\r\nu8 TwoBytes[2];\r\nif ( !info->tx_count && !info->x_char )\r\nreturn;\r\nwhile( info->tx_count && (read_reg(info,SR0) & BIT1) ) {\r\nif ( (info->tx_count > 1) && !info->x_char ) {\r\nTwoBytes[0] = info->tx_buf[info->tx_get++];\r\nif (info->tx_get >= info->max_frame_size)\r\ninfo->tx_get -= info->max_frame_size;\r\nTwoBytes[1] = info->tx_buf[info->tx_get++];\r\nif (info->tx_get >= info->max_frame_size)\r\ninfo->tx_get -= info->max_frame_size;\r\nwrite_reg16(info, TRB, *((u16 *)TwoBytes));\r\ninfo->tx_count -= 2;\r\ninfo->icount.tx += 2;\r\n} else {\r\nif (info->x_char) {\r\nwrite_reg(info, TRB, info->x_char);\r\ninfo->x_char = 0;\r\n} else {\r\nwrite_reg(info, TRB, info->tx_buf[info->tx_get++]);\r\nif (info->tx_get >= info->max_frame_size)\r\ninfo->tx_get -= info->max_frame_size;\r\ninfo->tx_count--;\r\n}\r\ninfo->icount.tx++;\r\n}\r\n}\r\n}\r\nstatic void reset_port(SLMP_INFO *info)\r\n{\r\nif (info->sca_base) {\r\ntx_stop(info);\r\nrx_stop(info);\r\ninfo->serial_signals &= ~(SerialSignal_RTS | SerialSignal_DTR);\r\nset_signals(info);\r\ninfo->ie0_value = 0;\r\ninfo->ie1_value = 0;\r\ninfo->ie2_value = 0;\r\nwrite_reg(info, IE0, info->ie0_value);\r\nwrite_reg(info, IE1, info->ie1_value);\r\nwrite_reg(info, IE2, info->ie2_value);\r\nwrite_reg(info, CMD, CHRESET);\r\n}\r\n}\r\nstatic void reset_adapter(SLMP_INFO *info)\r\n{\r\nint i;\r\nfor ( i=0; i < SCA_MAX_PORTS; ++i) {\r\nif (info->port_array[i])\r\nreset_port(info->port_array[i]);\r\n}\r\n}\r\nstatic void async_mode(SLMP_INFO *info)\r\n{\r\nunsigned char RegValue;\r\ntx_stop(info);\r\nrx_stop(info);\r\nRegValue = 0x00;\r\nif (info->params.stop_bits != 1)\r\nRegValue |= BIT1;\r\nwrite_reg(info, MD0, RegValue);\r\nRegValue = 0x40;\r\nswitch (info->params.data_bits) {\r\ncase 7: RegValue |= BIT4 + BIT2; break;\r\ncase 6: RegValue |= BIT5 + BIT3; break;\r\ncase 5: RegValue |= BIT5 + BIT4 + BIT3 + BIT2; break;\r\n}\r\nif (info->params.parity != ASYNC_PARITY_NONE) {\r\nRegValue |= BIT1;\r\nif (info->params.parity == ASYNC_PARITY_ODD)\r\nRegValue |= BIT0;\r\n}\r\nwrite_reg(info, MD1, RegValue);\r\nRegValue = 0x00;\r\nif (info->params.loopback)\r\nRegValue |= (BIT1 + BIT0);\r\nwrite_reg(info, MD2, RegValue);\r\nRegValue=BIT6;\r\nwrite_reg(info, RXS, RegValue);\r\nRegValue=BIT6;\r\nwrite_reg(info, TXS, RegValue);\r\ninfo->port_array[0]->ctrlreg_value |= (BIT0 << (info->port_num * 2));\r\nwrite_control_reg(info);\r\ntx_set_idle(info);\r\nwrite_reg(info, RRC, 0x00);\r\nwrite_reg(info, TRC0, 0x10);\r\nwrite_reg(info, TRC1, 0x1e);\r\nRegValue = 0x10;\r\nif (!(info->serial_signals & SerialSignal_RTS))\r\nRegValue |= 0x01;\r\nwrite_reg(info, CTL, RegValue);\r\ninfo->ie0_value |= TXINTE + RXINTE;\r\nwrite_reg(info, IE0, info->ie0_value);\r\ninfo->ie1_value = BRKD;\r\nwrite_reg(info, IE1, info->ie1_value);\r\ninfo->ie2_value = OVRN;\r\nwrite_reg(info, IE2, info->ie2_value);\r\nset_rate( info, info->params.data_rate * 16 );\r\n}\r\nstatic void hdlc_mode(SLMP_INFO *info)\r\n{\r\nunsigned char RegValue;\r\nu32 DpllDivisor;\r\ninfo->params.flags &= ~(HDLC_FLAG_TXC_DPLL + HDLC_FLAG_RXC_DPLL);\r\nwrite_reg(info, TXDMA + DIR, 0);\r\nwrite_reg(info, RXDMA + DIR, 0);\r\nRegValue = 0x81;\r\nif (info->params.flags & HDLC_FLAG_AUTO_CTS)\r\nRegValue |= BIT4;\r\nif (info->params.flags & HDLC_FLAG_AUTO_DCD)\r\nRegValue |= BIT4;\r\nif (info->params.crc_type == HDLC_CRC_16_CCITT)\r\nRegValue |= BIT2 + BIT1;\r\nwrite_reg(info, MD0, RegValue);\r\nRegValue = 0x00;\r\nwrite_reg(info, MD1, RegValue);\r\nRegValue = 0x00;\r\nswitch(info->params.encoding) {\r\ncase HDLC_ENCODING_NRZI: RegValue |= BIT5; break;\r\ncase HDLC_ENCODING_BIPHASE_MARK: RegValue |= BIT7 + BIT5; break;\r\ncase HDLC_ENCODING_BIPHASE_SPACE: RegValue |= BIT7 + BIT6; break;\r\ncase HDLC_ENCODING_BIPHASE_LEVEL: RegValue |= BIT7; break;\r\n#if 0\r\ncase HDLC_ENCODING_NRZB:\r\ncase HDLC_ENCODING_NRZI_MARK:\r\ncase HDLC_ENCODING_DIFF_BIPHASE_LEVEL:\r\n#endif\r\n}\r\nif ( info->params.flags & HDLC_FLAG_DPLL_DIV16 ) {\r\nDpllDivisor = 16;\r\nRegValue |= BIT3;\r\n} else if ( info->params.flags & HDLC_FLAG_DPLL_DIV8 ) {\r\nDpllDivisor = 8;\r\n} else {\r\nDpllDivisor = 32;\r\nRegValue |= BIT4;\r\n}\r\nwrite_reg(info, MD2, RegValue);\r\nRegValue=0;\r\nif (info->params.flags & HDLC_FLAG_RXC_BRG)\r\nRegValue |= BIT6;\r\nif (info->params.flags & HDLC_FLAG_RXC_DPLL)\r\nRegValue |= BIT6 + BIT5;\r\nwrite_reg(info, RXS, RegValue);\r\nRegValue=0;\r\nif (info->params.flags & HDLC_FLAG_TXC_BRG)\r\nRegValue |= BIT6;\r\nif (info->params.flags & HDLC_FLAG_TXC_DPLL)\r\nRegValue |= BIT6 + BIT5;\r\nwrite_reg(info, TXS, RegValue);\r\nif (info->params.flags & HDLC_FLAG_RXC_DPLL)\r\nset_rate(info, info->params.clock_speed * DpllDivisor);\r\nelse\r\nset_rate(info, info->params.clock_speed);\r\nif (info->params.flags & HDLC_FLAG_TXC_BRG)\r\ninfo->port_array[0]->ctrlreg_value |= (BIT0 << (info->port_num * 2));\r\nelse\r\ninfo->port_array[0]->ctrlreg_value &= ~(BIT0 << (info->port_num * 2));\r\nwrite_control_reg(info);\r\nwrite_reg(info, RRC, rx_active_fifo_level);\r\nwrite_reg(info, TRC0, tx_active_fifo_level);\r\nwrite_reg(info, TRC1, (unsigned char)(tx_negate_fifo_level - 1));\r\nwrite_reg(info, TXDMA + DMR, 0x14);\r\nwrite_reg(info, RXDMA + DMR, 0x14);\r\nwrite_reg(info, RXDMA + CPB,\r\n(unsigned char)(info->buffer_list_phys >> 16));\r\nwrite_reg(info, TXDMA + CPB,\r\n(unsigned char)(info->buffer_list_phys >> 16));\r\ninfo->ie0_value |= TXINTE + RXINTE;\r\nwrite_reg(info, IE0, info->ie0_value);\r\nRegValue = 0x10;\r\nif (!(info->serial_signals & SerialSignal_RTS))\r\nRegValue |= 0x01;\r\nwrite_reg(info, CTL, RegValue);\r\ntx_set_idle(info);\r\ntx_stop(info);\r\nrx_stop(info);\r\nset_rate(info, info->params.clock_speed);\r\nif (info->params.loopback)\r\nenable_loopback(info,1);\r\n}\r\nstatic void tx_set_idle(SLMP_INFO *info)\r\n{\r\nunsigned char RegValue = 0xff;\r\nswitch(info->idle_mode) {\r\ncase HDLC_TXIDLE_FLAGS: RegValue = 0x7e; break;\r\ncase HDLC_TXIDLE_ALT_ZEROS_ONES: RegValue = 0xaa; break;\r\ncase HDLC_TXIDLE_ZEROS: RegValue = 0x00; break;\r\ncase HDLC_TXIDLE_ONES: RegValue = 0xff; break;\r\ncase HDLC_TXIDLE_ALT_MARK_SPACE: RegValue = 0xaa; break;\r\ncase HDLC_TXIDLE_SPACE: RegValue = 0x00; break;\r\ncase HDLC_TXIDLE_MARK: RegValue = 0xff; break;\r\n}\r\nwrite_reg(info, IDL, RegValue);\r\n}\r\nstatic void get_signals(SLMP_INFO *info)\r\n{\r\nu16 status = read_reg(info, SR3);\r\nu16 gpstatus = read_status_reg(info);\r\nu16 testbit;\r\ninfo->serial_signals &= SerialSignal_RTS | SerialSignal_DTR;\r\nif (!(status & BIT3))\r\ninfo->serial_signals |= SerialSignal_CTS;\r\nif ( !(status & BIT2))\r\ninfo->serial_signals |= SerialSignal_DCD;\r\ntestbit = BIT1 << (info->port_num * 2);\r\nif (!(gpstatus & testbit))\r\ninfo->serial_signals |= SerialSignal_RI;\r\ntestbit = BIT0 << (info->port_num * 2);\r\nif (!(gpstatus & testbit))\r\ninfo->serial_signals |= SerialSignal_DSR;\r\n}\r\nstatic void set_signals(SLMP_INFO *info)\r\n{\r\nunsigned char RegValue;\r\nu16 EnableBit;\r\nRegValue = read_reg(info, CTL);\r\nif (info->serial_signals & SerialSignal_RTS)\r\nRegValue &= ~BIT0;\r\nelse\r\nRegValue |= BIT0;\r\nwrite_reg(info, CTL, RegValue);\r\nEnableBit = BIT1 << (info->port_num*2);\r\nif (info->serial_signals & SerialSignal_DTR)\r\ninfo->port_array[0]->ctrlreg_value &= ~EnableBit;\r\nelse\r\ninfo->port_array[0]->ctrlreg_value |= EnableBit;\r\nwrite_control_reg(info);\r\n}\r\nstatic void rx_reset_buffers(SLMP_INFO *info)\r\n{\r\nrx_free_frame_buffers(info, 0, info->rx_buf_count - 1);\r\n}\r\nstatic void rx_free_frame_buffers(SLMP_INFO *info, unsigned int first, unsigned int last)\r\n{\r\nbool done = false;\r\nwhile(!done) {\r\ninfo->rx_buf_list[first].status = 0xff;\r\nif (first == last) {\r\ndone = true;\r\nwrite_reg16(info, RXDMA + EDA, info->rx_buf_list_ex[first].phys_entry);\r\n}\r\nfirst++;\r\nif (first == info->rx_buf_count)\r\nfirst = 0;\r\n}\r\ninfo->current_rx_buf = first;\r\n}\r\nstatic bool rx_get_frame(SLMP_INFO *info)\r\n{\r\nunsigned int StartIndex, EndIndex;\r\nunsigned short status;\r\nunsigned int framesize = 0;\r\nbool ReturnCode = false;\r\nunsigned long flags;\r\nstruct tty_struct *tty = info->port.tty;\r\nunsigned char addr_field = 0xff;\r\nSCADESC *desc;\r\nSCADESC_EX *desc_ex;\r\nCheckAgain:\r\nframesize = 0;\r\naddr_field = 0xff;\r\nStartIndex = EndIndex = info->current_rx_buf;\r\nfor ( ;; ) {\r\ndesc = &info->rx_buf_list[EndIndex];\r\ndesc_ex = &info->rx_buf_list_ex[EndIndex];\r\nif (desc->status == 0xff)\r\ngoto Cleanup;\r\nif (framesize == 0 && info->params.addr_filter != 0xff)\r\naddr_field = desc_ex->virt_addr[0];\r\nframesize += desc->length;\r\nif (desc->status)\r\nbreak;\r\nEndIndex++;\r\nif (EndIndex == info->rx_buf_count)\r\nEndIndex = 0;\r\nif (EndIndex == info->current_rx_buf) {\r\nif ( info->rx_enabled ){\r\nspin_lock_irqsave(&info->lock,flags);\r\nrx_start(info);\r\nspin_unlock_irqrestore(&info->lock,flags);\r\n}\r\ngoto Cleanup;\r\n}\r\n}\r\nstatus = desc->status;\r\nif (info->params.crc_type == HDLC_CRC_NONE)\r\nstatus &= ~BIT2;\r\nif (framesize == 0 ||\r\n(addr_field != 0xff && addr_field != info->params.addr_filter)) {\r\nrx_free_frame_buffers(info, StartIndex, EndIndex);\r\ngoto CheckAgain;\r\n}\r\nif (framesize < 2)\r\nstatus |= BIT6;\r\nif (status & (BIT6+BIT5+BIT3+BIT2)) {\r\nif (status & BIT6)\r\ninfo->icount.rxshort++;\r\nelse if (status & BIT5)\r\ninfo->icount.rxabort++;\r\nelse if (status & BIT3)\r\ninfo->icount.rxover++;\r\nelse\r\ninfo->icount.rxcrc++;\r\nframesize = 0;\r\n#if SYNCLINK_GENERIC_HDLC\r\n{\r\ninfo->netdev->stats.rx_errors++;\r\ninfo->netdev->stats.rx_frame_errors++;\r\n}\r\n#endif\r\n}\r\nif ( debug_level >= DEBUG_LEVEL_BH )\r\nprintk("%s(%d):%s rx_get_frame() status=%04X size=%d\n",\r\n__FILE__,__LINE__,info->device_name,status,framesize);\r\nif ( debug_level >= DEBUG_LEVEL_DATA )\r\ntrace_block(info,info->rx_buf_list_ex[StartIndex].virt_addr,\r\nmin_t(unsigned int, framesize, SCABUFSIZE), 0);\r\nif (framesize) {\r\nif (framesize > info->max_frame_size)\r\ninfo->icount.rxlong++;\r\nelse {\r\nint copy_count = framesize;\r\nint index = StartIndex;\r\nunsigned char *ptmp = info->tmp_rx_buf;\r\ninfo->tmp_rx_buf_count = framesize;\r\ninfo->icount.rxok++;\r\nwhile(copy_count) {\r\nint partial_count = min(copy_count,SCABUFSIZE);\r\nmemcpy( ptmp,\r\ninfo->rx_buf_list_ex[index].virt_addr,\r\npartial_count );\r\nptmp += partial_count;\r\ncopy_count -= partial_count;\r\nif ( ++index == info->rx_buf_count )\r\nindex = 0;\r\n}\r\n#if SYNCLINK_GENERIC_HDLC\r\nif (info->netcount)\r\nhdlcdev_rx(info,info->tmp_rx_buf,framesize);\r\nelse\r\n#endif\r\nldisc_receive_buf(tty,info->tmp_rx_buf,\r\ninfo->flag_buf, framesize);\r\n}\r\n}\r\nrx_free_frame_buffers( info, StartIndex, EndIndex );\r\nReturnCode = true;\r\nCleanup:\r\nif ( info->rx_enabled && info->rx_overflow ) {\r\nif (info->rx_buf_list[EndIndex].status == 0xff) {\r\nspin_lock_irqsave(&info->lock,flags);\r\nrx_start(info);\r\nspin_unlock_irqrestore(&info->lock,flags);\r\n}\r\n}\r\nreturn ReturnCode;\r\n}\r\nstatic void tx_load_dma_buffer(SLMP_INFO *info, const char *buf, unsigned int count)\r\n{\r\nunsigned short copy_count;\r\nunsigned int i = 0;\r\nSCADESC *desc;\r\nSCADESC_EX *desc_ex;\r\nif ( debug_level >= DEBUG_LEVEL_DATA )\r\ntrace_block(info, buf, min_t(unsigned int, count, SCABUFSIZE), 1);\r\nfor(i=0;;)\r\n{\r\ncopy_count = min_t(unsigned int, count, SCABUFSIZE);\r\ndesc = &info->tx_buf_list[i];\r\ndesc_ex = &info->tx_buf_list_ex[i];\r\nload_pci_memory(info, desc_ex->virt_addr,buf,copy_count);\r\ndesc->length = copy_count;\r\ndesc->status = 0;\r\nbuf += copy_count;\r\ncount -= copy_count;\r\nif (!count)\r\nbreak;\r\ni++;\r\nif (i >= info->tx_buf_count)\r\ni = 0;\r\n}\r\ninfo->tx_buf_list[i].status = 0x81;\r\ninfo->last_tx_buf = ++i;\r\n}\r\nstatic bool register_test(SLMP_INFO *info)\r\n{\r\nstatic unsigned char testval[] = {0x00, 0xff, 0xaa, 0x55, 0x69, 0x96};\r\nstatic unsigned int count = ARRAY_SIZE(testval);\r\nunsigned int i;\r\nbool rc = true;\r\nunsigned long flags;\r\nspin_lock_irqsave(&info->lock,flags);\r\nreset_port(info);\r\ninfo->init_error = DiagStatus_AddressFailure;\r\nfor (i = 0 ; i < count ; i++) {\r\nwrite_reg(info, TMC, testval[i]);\r\nwrite_reg(info, IDL, testval[(i+1)%count]);\r\nwrite_reg(info, SA0, testval[(i+2)%count]);\r\nwrite_reg(info, SA1, testval[(i+3)%count]);\r\nif ( (read_reg(info, TMC) != testval[i]) ||\r\n(read_reg(info, IDL) != testval[(i+1)%count]) ||\r\n(read_reg(info, SA0) != testval[(i+2)%count]) ||\r\n(read_reg(info, SA1) != testval[(i+3)%count]) )\r\n{\r\nrc = false;\r\nbreak;\r\n}\r\n}\r\nreset_port(info);\r\nspin_unlock_irqrestore(&info->lock,flags);\r\nreturn rc;\r\n}\r\nstatic bool irq_test(SLMP_INFO *info)\r\n{\r\nunsigned long timeout;\r\nunsigned long flags;\r\nunsigned char timer = (info->port_num & 1) ? TIMER2 : TIMER0;\r\nspin_lock_irqsave(&info->lock,flags);\r\nreset_port(info);\r\ninfo->init_error = DiagStatus_IrqFailure;\r\ninfo->irq_occurred = false;\r\nwrite_reg(info, IER2, (unsigned char)((info->port_num & 1) ? BIT6 : BIT4));\r\nwrite_reg(info, (unsigned char)(timer + TEPR), 0);\r\nwrite_reg16(info, (unsigned char)(timer + TCONR), 1);\r\nwrite_reg(info, (unsigned char)(timer + TMCS), 0x50);\r\nspin_unlock_irqrestore(&info->lock,flags);\r\ntimeout=100;\r\nwhile( timeout-- && !info->irq_occurred ) {\r\nmsleep_interruptible(10);\r\n}\r\nspin_lock_irqsave(&info->lock,flags);\r\nreset_port(info);\r\nspin_unlock_irqrestore(&info->lock,flags);\r\nreturn info->irq_occurred;\r\n}\r\nstatic bool sca_init(SLMP_INFO *info)\r\n{\r\nwrite_reg(info, PABR0, 0);\r\nwrite_reg(info, PABR1, 0);\r\nwrite_reg(info, WCRL, 0);\r\nwrite_reg(info, WCRM, 0);\r\nwrite_reg(info, WCRH, 0);\r\nwrite_reg(info, DPCR, dma_priority);\r\nwrite_reg(info, DMER, 0x80);\r\nwrite_reg(info, IER0, 0xff);\r\nwrite_reg(info, IER1, 0xff);\r\nwrite_reg(info, IER2, 0xf0);\r\nwrite_reg(info, ITCR, 0);\r\nreturn true;\r\n}\r\nstatic bool init_adapter(SLMP_INFO *info)\r\n{\r\nint i;\r\nvolatile u32 *MiscCtrl = (u32 *)(info->lcr_base + 0x50);\r\nu32 readval;\r\ninfo->misc_ctrl_value |= BIT30;\r\n*MiscCtrl = info->misc_ctrl_value;\r\nfor(i=0;i<10;i++)\r\nreadval = *MiscCtrl;\r\ninfo->misc_ctrl_value &= ~BIT30;\r\n*MiscCtrl = info->misc_ctrl_value;\r\ninfo->ctrlreg_value = 0xaa;\r\nwrite_control_reg(info);\r\n{\r\nvolatile u32 *LCR1BRDR = (u32 *)(info->lcr_base + 0x2c);\r\nlcr1_brdr_value &= ~(BIT5 + BIT4 + BIT3);\r\nswitch(read_ahead_count)\r\n{\r\ncase 16:\r\nlcr1_brdr_value |= BIT5 + BIT4 + BIT3;\r\nbreak;\r\ncase 8:\r\nlcr1_brdr_value |= BIT5 + BIT4;\r\nbreak;\r\ncase 4:\r\nlcr1_brdr_value |= BIT5 + BIT3;\r\nbreak;\r\ncase 0:\r\nlcr1_brdr_value |= BIT5;\r\nbreak;\r\n}\r\n*LCR1BRDR = lcr1_brdr_value;\r\n*MiscCtrl = misc_ctrl_value;\r\n}\r\nsca_init(info->port_array[0]);\r\nsca_init(info->port_array[2]);\r\nreturn true;\r\n}\r\nstatic bool loopback_test(SLMP_INFO *info)\r\n{\r\n#define TESTFRAMESIZE 20\r\nunsigned long timeout;\r\nu16 count = TESTFRAMESIZE;\r\nunsigned char buf[TESTFRAMESIZE];\r\nbool rc = false;\r\nunsigned long flags;\r\nstruct tty_struct *oldtty = info->port.tty;\r\nu32 speed = info->params.clock_speed;\r\ninfo->params.clock_speed = 3686400;\r\ninfo->port.tty = NULL;\r\ninfo->init_error = DiagStatus_DmaFailure;\r\nfor (count = 0; count < TESTFRAMESIZE;++count)\r\nbuf[count] = (unsigned char)count;\r\nmemset(info->tmp_rx_buf,0,TESTFRAMESIZE);\r\nspin_lock_irqsave(&info->lock,flags);\r\nhdlc_mode(info);\r\nenable_loopback(info,1);\r\nrx_start(info);\r\ninfo->tx_count = count;\r\ntx_load_dma_buffer(info,buf,count);\r\ntx_start(info);\r\nspin_unlock_irqrestore(&info->lock,flags);\r\nfor ( timeout = 100; timeout; --timeout ) {\r\nmsleep_interruptible(10);\r\nif (rx_get_frame(info)) {\r\nrc = true;\r\nbreak;\r\n}\r\n}\r\nif (rc &&\r\n( info->tmp_rx_buf_count != count ||\r\nmemcmp(buf, info->tmp_rx_buf,count))) {\r\nrc = false;\r\n}\r\nspin_lock_irqsave(&info->lock,flags);\r\nreset_adapter(info);\r\nspin_unlock_irqrestore(&info->lock,flags);\r\ninfo->params.clock_speed = speed;\r\ninfo->port.tty = oldtty;\r\nreturn rc;\r\n}\r\nstatic int adapter_test( SLMP_INFO *info )\r\n{\r\nunsigned long flags;\r\nif ( debug_level >= DEBUG_LEVEL_INFO )\r\nprintk( "%s(%d):Testing device %s\n",\r\n__FILE__,__LINE__,info->device_name );\r\nspin_lock_irqsave(&info->lock,flags);\r\ninit_adapter(info);\r\nspin_unlock_irqrestore(&info->lock,flags);\r\ninfo->port_array[0]->port_count = 0;\r\nif ( register_test(info->port_array[0]) &&\r\nregister_test(info->port_array[1])) {\r\ninfo->port_array[0]->port_count = 2;\r\nif ( register_test(info->port_array[2]) &&\r\nregister_test(info->port_array[3]) )\r\ninfo->port_array[0]->port_count += 2;\r\n}\r\nelse {\r\nprintk( "%s(%d):Register test failure for device %s Addr=%08lX\n",\r\n__FILE__,__LINE__,info->device_name, (unsigned long)(info->phys_sca_base));\r\nreturn -ENODEV;\r\n}\r\nif ( !irq_test(info->port_array[0]) ||\r\n!irq_test(info->port_array[1]) ||\r\n(info->port_count == 4 && !irq_test(info->port_array[2])) ||\r\n(info->port_count == 4 && !irq_test(info->port_array[3]))) {\r\nprintk( "%s(%d):Interrupt test failure for device %s IRQ=%d\n",\r\n__FILE__,__LINE__,info->device_name, (unsigned short)(info->irq_level) );\r\nreturn -ENODEV;\r\n}\r\nif (!loopback_test(info->port_array[0]) ||\r\n!loopback_test(info->port_array[1]) ||\r\n(info->port_count == 4 && !loopback_test(info->port_array[2])) ||\r\n(info->port_count == 4 && !loopback_test(info->port_array[3]))) {\r\nprintk( "%s(%d):DMA test failure for device %s\n",\r\n__FILE__,__LINE__,info->device_name);\r\nreturn -ENODEV;\r\n}\r\nif ( debug_level >= DEBUG_LEVEL_INFO )\r\nprintk( "%s(%d):device %s passed diagnostics\n",\r\n__FILE__,__LINE__,info->device_name );\r\ninfo->port_array[0]->init_error = 0;\r\ninfo->port_array[1]->init_error = 0;\r\nif ( info->port_count > 2 ) {\r\ninfo->port_array[2]->init_error = 0;\r\ninfo->port_array[3]->init_error = 0;\r\n}\r\nreturn 0;\r\n}\r\nstatic bool memory_test(SLMP_INFO *info)\r\n{\r\nstatic unsigned long testval[] = { 0x0, 0x55555555, 0xaaaaaaaa,\r\n0x66666666, 0x99999999, 0xffffffff, 0x12345678 };\r\nunsigned long count = ARRAY_SIZE(testval);\r\nunsigned long i;\r\nunsigned long limit = SCA_MEM_SIZE/sizeof(unsigned long);\r\nunsigned long * addr = (unsigned long *)info->memory_base;\r\nfor ( i = 0 ; i < count ; i++ ) {\r\n*addr = testval[i];\r\nif ( *addr != testval[i] )\r\nreturn false;\r\n}\r\nfor ( i = 0 ; i < limit ; i++ ) {\r\n*addr = i * 4;\r\naddr++;\r\n}\r\naddr = (unsigned long *)info->memory_base;\r\nfor ( i = 0 ; i < limit ; i++ ) {\r\nif ( *addr != i * 4 )\r\nreturn false;\r\naddr++;\r\n}\r\nmemset( info->memory_base, 0, SCA_MEM_SIZE );\r\nreturn true;\r\n}\r\nstatic void load_pci_memory(SLMP_INFO *info, char* dest, const char* src, unsigned short count)\r\n{\r\nunsigned short interval = count / sca_pci_load_interval;\r\nunsigned short i;\r\nfor ( i = 0 ; i < interval ; i++ )\r\n{\r\nmemcpy(dest, src, sca_pci_load_interval);\r\nread_status_reg(info);\r\ndest += sca_pci_load_interval;\r\nsrc += sca_pci_load_interval;\r\n}\r\nmemcpy(dest, src, count % sca_pci_load_interval);\r\n}\r\nstatic void trace_block(SLMP_INFO *info,const char* data, int count, int xmit)\r\n{\r\nint i;\r\nint linecount;\r\nif (xmit)\r\nprintk("%s tx data:\n",info->device_name);\r\nelse\r\nprintk("%s rx data:\n",info->device_name);\r\nwhile(count) {\r\nif (count > 16)\r\nlinecount = 16;\r\nelse\r\nlinecount = count;\r\nfor(i=0;i<linecount;i++)\r\nprintk("%02X ",(unsigned char)data[i]);\r\nfor(;i<17;i++)\r\nprintk(" ");\r\nfor(i=0;i<linecount;i++) {\r\nif (data[i]>=040 && data[i]<=0176)\r\nprintk("%c",data[i]);\r\nelse\r\nprintk(".");\r\n}\r\nprintk("\n");\r\ndata += linecount;\r\ncount -= linecount;\r\n}\r\n}\r\nstatic void tx_timeout(unsigned long context)\r\n{\r\nSLMP_INFO *info = (SLMP_INFO*)context;\r\nunsigned long flags;\r\nif ( debug_level >= DEBUG_LEVEL_INFO )\r\nprintk( "%s(%d):%s tx_timeout()\n",\r\n__FILE__,__LINE__,info->device_name);\r\nif(info->tx_active && info->params.mode == MGSL_MODE_HDLC) {\r\ninfo->icount.txtimeout++;\r\n}\r\nspin_lock_irqsave(&info->lock,flags);\r\ninfo->tx_active = false;\r\ninfo->tx_count = info->tx_put = info->tx_get = 0;\r\nspin_unlock_irqrestore(&info->lock,flags);\r\n#if SYNCLINK_GENERIC_HDLC\r\nif (info->netcount)\r\nhdlcdev_tx_done(info);\r\nelse\r\n#endif\r\nbh_transmit(info);\r\n}\r\nstatic void status_timeout(unsigned long context)\r\n{\r\nu16 status = 0;\r\nSLMP_INFO *info = (SLMP_INFO*)context;\r\nunsigned long flags;\r\nunsigned char delta;\r\nspin_lock_irqsave(&info->lock,flags);\r\nget_signals(info);\r\nspin_unlock_irqrestore(&info->lock,flags);\r\ndelta = info->old_signals ^ info->serial_signals;\r\ninfo->old_signals = info->serial_signals;\r\nif (delta & SerialSignal_DSR)\r\nstatus |= MISCSTATUS_DSR_LATCHED|(info->serial_signals&SerialSignal_DSR);\r\nif (delta & SerialSignal_RI)\r\nstatus |= MISCSTATUS_RI_LATCHED|(info->serial_signals&SerialSignal_RI);\r\nif (delta & SerialSignal_DCD)\r\nstatus |= MISCSTATUS_DCD_LATCHED|(info->serial_signals&SerialSignal_DCD);\r\nif (delta & SerialSignal_CTS)\r\nstatus |= MISCSTATUS_CTS_LATCHED|(info->serial_signals&SerialSignal_CTS);\r\nif (status)\r\nisr_io_pin(info,status);\r\nmod_timer(&info->status_timer, jiffies + msecs_to_jiffies(10));\r\n}\r\nstatic unsigned char read_reg(SLMP_INFO * info, unsigned char Addr)\r\n{\r\nCALC_REGADDR();\r\nreturn *RegAddr;\r\n}\r\nstatic void write_reg(SLMP_INFO * info, unsigned char Addr, unsigned char Value)\r\n{\r\nCALC_REGADDR();\r\n*RegAddr = Value;\r\n}\r\nstatic u16 read_reg16(SLMP_INFO * info, unsigned char Addr)\r\n{\r\nCALC_REGADDR();\r\nreturn *((u16 *)RegAddr);\r\n}\r\nstatic void write_reg16(SLMP_INFO * info, unsigned char Addr, u16 Value)\r\n{\r\nCALC_REGADDR();\r\n*((u16 *)RegAddr) = Value;\r\n}\r\nstatic unsigned char read_status_reg(SLMP_INFO * info)\r\n{\r\nunsigned char *RegAddr = (unsigned char *)info->statctrl_base;\r\nreturn *RegAddr;\r\n}\r\nstatic void write_control_reg(SLMP_INFO * info)\r\n{\r\nunsigned char *RegAddr = (unsigned char *)info->statctrl_base;\r\n*RegAddr = info->port_array[0]->ctrlreg_value;\r\n}\r\nstatic int synclinkmp_init_one (struct pci_dev *dev,\r\nconst struct pci_device_id *ent)\r\n{\r\nif (pci_enable_device(dev)) {\r\nprintk("error enabling pci device %p\n", dev);\r\nreturn -EIO;\r\n}\r\ndevice_init( ++synclinkmp_adapter_count, dev );\r\nreturn 0;\r\n}\r\nstatic void synclinkmp_remove_one (struct pci_dev *dev)\r\n{\r\n}
