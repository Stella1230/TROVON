static inline int is_imx1_rtc(struct rtc_plat_data *data)\r\n{\r\nreturn data->devtype == IMX1_RTC;\r\n}\r\nstatic time64_t get_alarm_or_time(struct device *dev, int time_alarm)\r\n{\r\nstruct platform_device *pdev = to_platform_device(dev);\r\nstruct rtc_plat_data *pdata = platform_get_drvdata(pdev);\r\nvoid __iomem *ioaddr = pdata->ioaddr;\r\nu32 day = 0, hr = 0, min = 0, sec = 0, hr_min = 0;\r\nswitch (time_alarm) {\r\ncase MXC_RTC_TIME:\r\nday = readw(ioaddr + RTC_DAYR);\r\nhr_min = readw(ioaddr + RTC_HOURMIN);\r\nsec = readw(ioaddr + RTC_SECOND);\r\nbreak;\r\ncase MXC_RTC_ALARM:\r\nday = readw(ioaddr + RTC_DAYALARM);\r\nhr_min = readw(ioaddr + RTC_ALRM_HM) & 0xffff;\r\nsec = readw(ioaddr + RTC_ALRM_SEC);\r\nbreak;\r\n}\r\nhr = hr_min >> 8;\r\nmin = hr_min & 0xff;\r\nreturn ((((time64_t)day * 24 + hr) * 60) + min) * 60 + sec;\r\n}\r\nstatic void set_alarm_or_time(struct device *dev, int time_alarm, time64_t time)\r\n{\r\nu32 tod, day, hr, min, sec, temp;\r\nstruct platform_device *pdev = to_platform_device(dev);\r\nstruct rtc_plat_data *pdata = platform_get_drvdata(pdev);\r\nvoid __iomem *ioaddr = pdata->ioaddr;\r\nday = div_s64_rem(time, 86400, &tod);\r\nhr = tod / 3600;\r\ntod -= hr * 3600;\r\nmin = tod / 60;\r\nsec = tod - min * 60;\r\ntemp = (hr << 8) + min;\r\nswitch (time_alarm) {\r\ncase MXC_RTC_TIME:\r\nwritew(day, ioaddr + RTC_DAYR);\r\nwritew(sec, ioaddr + RTC_SECOND);\r\nwritew(temp, ioaddr + RTC_HOURMIN);\r\nbreak;\r\ncase MXC_RTC_ALARM:\r\nwritew(day, ioaddr + RTC_DAYALARM);\r\nwritew(sec, ioaddr + RTC_ALRM_SEC);\r\nwritew(temp, ioaddr + RTC_ALRM_HM);\r\nbreak;\r\n}\r\n}\r\nstatic void rtc_update_alarm(struct device *dev, struct rtc_time *alrm)\r\n{\r\ntime64_t time;\r\nstruct platform_device *pdev = to_platform_device(dev);\r\nstruct rtc_plat_data *pdata = platform_get_drvdata(pdev);\r\nvoid __iomem *ioaddr = pdata->ioaddr;\r\ntime = rtc_tm_to_time64(alrm);\r\nwritew(readw(ioaddr + RTC_RTCISR), ioaddr + RTC_RTCISR);\r\nset_alarm_or_time(dev, MXC_RTC_ALARM, time);\r\n}\r\nstatic void mxc_rtc_irq_enable(struct device *dev, unsigned int bit,\r\nunsigned int enabled)\r\n{\r\nstruct platform_device *pdev = to_platform_device(dev);\r\nstruct rtc_plat_data *pdata = platform_get_drvdata(pdev);\r\nvoid __iomem *ioaddr = pdata->ioaddr;\r\nu32 reg;\r\nspin_lock_irq(&pdata->rtc->irq_lock);\r\nreg = readw(ioaddr + RTC_RTCIENR);\r\nif (enabled)\r\nreg |= bit;\r\nelse\r\nreg &= ~bit;\r\nwritew(reg, ioaddr + RTC_RTCIENR);\r\nspin_unlock_irq(&pdata->rtc->irq_lock);\r\n}\r\nstatic irqreturn_t mxc_rtc_interrupt(int irq, void *dev_id)\r\n{\r\nstruct platform_device *pdev = dev_id;\r\nstruct rtc_plat_data *pdata = platform_get_drvdata(pdev);\r\nvoid __iomem *ioaddr = pdata->ioaddr;\r\nunsigned long flags;\r\nu32 status;\r\nu32 events = 0;\r\nspin_lock_irqsave(&pdata->rtc->irq_lock, flags);\r\nstatus = readw(ioaddr + RTC_RTCISR) & readw(ioaddr + RTC_RTCIENR);\r\nwritew(status, ioaddr + RTC_RTCISR);\r\nif (status & RTC_ALM_BIT) {\r\nevents |= (RTC_AF | RTC_IRQF);\r\nmxc_rtc_irq_enable(&pdev->dev, RTC_ALM_BIT, 0);\r\n}\r\nif (status & RTC_1HZ_BIT)\r\nevents |= (RTC_UF | RTC_IRQF);\r\nif (status & PIT_ALL_ON)\r\nevents |= (RTC_PF | RTC_IRQF);\r\nrtc_update_irq(pdata->rtc, 1, events);\r\nspin_unlock_irqrestore(&pdata->rtc->irq_lock, flags);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void mxc_rtc_release(struct device *dev)\r\n{\r\nstruct platform_device *pdev = to_platform_device(dev);\r\nstruct rtc_plat_data *pdata = platform_get_drvdata(pdev);\r\nvoid __iomem *ioaddr = pdata->ioaddr;\r\nspin_lock_irq(&pdata->rtc->irq_lock);\r\nwritew(0, ioaddr + RTC_RTCIENR);\r\nwritew(0xffffffff, ioaddr + RTC_RTCISR);\r\nspin_unlock_irq(&pdata->rtc->irq_lock);\r\n}\r\nstatic int mxc_rtc_alarm_irq_enable(struct device *dev, unsigned int enabled)\r\n{\r\nmxc_rtc_irq_enable(dev, RTC_ALM_BIT, enabled);\r\nreturn 0;\r\n}\r\nstatic int mxc_rtc_read_time(struct device *dev, struct rtc_time *tm)\r\n{\r\ntime64_t val;\r\ndo {\r\nval = get_alarm_or_time(dev, MXC_RTC_TIME);\r\n} while (val != get_alarm_or_time(dev, MXC_RTC_TIME));\r\nrtc_time64_to_tm(val, tm);\r\nreturn 0;\r\n}\r\nstatic int mxc_rtc_set_mmss(struct device *dev, time64_t time)\r\n{\r\nstruct platform_device *pdev = to_platform_device(dev);\r\nstruct rtc_plat_data *pdata = platform_get_drvdata(pdev);\r\nif (is_imx1_rtc(pdata)) {\r\nstruct rtc_time tm;\r\nrtc_time64_to_tm(time, &tm);\r\ntm.tm_year = 70;\r\ntime = rtc_tm_to_time64(&tm);\r\n}\r\ndo {\r\nset_alarm_or_time(dev, MXC_RTC_TIME, time);\r\n} while (time != get_alarm_or_time(dev, MXC_RTC_TIME));\r\nreturn 0;\r\n}\r\nstatic int mxc_rtc_read_alarm(struct device *dev, struct rtc_wkalrm *alrm)\r\n{\r\nstruct platform_device *pdev = to_platform_device(dev);\r\nstruct rtc_plat_data *pdata = platform_get_drvdata(pdev);\r\nvoid __iomem *ioaddr = pdata->ioaddr;\r\nrtc_time64_to_tm(get_alarm_or_time(dev, MXC_RTC_ALARM), &alrm->time);\r\nalrm->pending = ((readw(ioaddr + RTC_RTCISR) & RTC_ALM_BIT)) ? 1 : 0;\r\nreturn 0;\r\n}\r\nstatic int mxc_rtc_set_alarm(struct device *dev, struct rtc_wkalrm *alrm)\r\n{\r\nstruct platform_device *pdev = to_platform_device(dev);\r\nstruct rtc_plat_data *pdata = platform_get_drvdata(pdev);\r\nrtc_update_alarm(dev, &alrm->time);\r\nmemcpy(&pdata->g_rtc_alarm, &alrm->time, sizeof(struct rtc_time));\r\nmxc_rtc_irq_enable(dev, RTC_ALM_BIT, alrm->enabled);\r\nreturn 0;\r\n}\r\nstatic int mxc_rtc_probe(struct platform_device *pdev)\r\n{\r\nstruct resource *res;\r\nstruct rtc_device *rtc;\r\nstruct rtc_plat_data *pdata = NULL;\r\nu32 reg;\r\nunsigned long rate;\r\nint ret;\r\nconst struct of_device_id *of_id;\r\npdata = devm_kzalloc(&pdev->dev, sizeof(*pdata), GFP_KERNEL);\r\nif (!pdata)\r\nreturn -ENOMEM;\r\nof_id = of_match_device(imx_rtc_dt_ids, &pdev->dev);\r\nif (of_id)\r\npdata->devtype = (enum imx_rtc_type)of_id->data;\r\nelse\r\npdata->devtype = pdev->id_entry->driver_data;\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\npdata->ioaddr = devm_ioremap_resource(&pdev->dev, res);\r\nif (IS_ERR(pdata->ioaddr))\r\nreturn PTR_ERR(pdata->ioaddr);\r\npdata->clk_ipg = devm_clk_get(&pdev->dev, "ipg");\r\nif (IS_ERR(pdata->clk_ipg)) {\r\ndev_err(&pdev->dev, "unable to get ipg clock!\n");\r\nreturn PTR_ERR(pdata->clk_ipg);\r\n}\r\nret = clk_prepare_enable(pdata->clk_ipg);\r\nif (ret)\r\nreturn ret;\r\npdata->clk_ref = devm_clk_get(&pdev->dev, "ref");\r\nif (IS_ERR(pdata->clk_ref)) {\r\ndev_err(&pdev->dev, "unable to get ref clock!\n");\r\nret = PTR_ERR(pdata->clk_ref);\r\ngoto exit_put_clk_ipg;\r\n}\r\nret = clk_prepare_enable(pdata->clk_ref);\r\nif (ret)\r\ngoto exit_put_clk_ipg;\r\nrate = clk_get_rate(pdata->clk_ref);\r\nif (rate == 32768)\r\nreg = RTC_INPUT_CLK_32768HZ;\r\nelse if (rate == 32000)\r\nreg = RTC_INPUT_CLK_32000HZ;\r\nelse if (rate == 38400)\r\nreg = RTC_INPUT_CLK_38400HZ;\r\nelse {\r\ndev_err(&pdev->dev, "rtc clock is not valid (%lu)\n", rate);\r\nret = -EINVAL;\r\ngoto exit_put_clk_ref;\r\n}\r\nreg |= RTC_ENABLE_BIT;\r\nwritew(reg, (pdata->ioaddr + RTC_RTCCTL));\r\nif (((readw(pdata->ioaddr + RTC_RTCCTL)) & RTC_ENABLE_BIT) == 0) {\r\ndev_err(&pdev->dev, "hardware module can't be enabled!\n");\r\nret = -EIO;\r\ngoto exit_put_clk_ref;\r\n}\r\nplatform_set_drvdata(pdev, pdata);\r\npdata->irq = platform_get_irq(pdev, 0);\r\nif (pdata->irq >= 0 &&\r\ndevm_request_irq(&pdev->dev, pdata->irq, mxc_rtc_interrupt,\r\nIRQF_SHARED, pdev->name, pdev) < 0) {\r\ndev_warn(&pdev->dev, "interrupt not available.\n");\r\npdata->irq = -1;\r\n}\r\nif (pdata->irq >= 0)\r\ndevice_init_wakeup(&pdev->dev, 1);\r\nrtc = devm_rtc_device_register(&pdev->dev, pdev->name, &mxc_rtc_ops,\r\nTHIS_MODULE);\r\nif (IS_ERR(rtc)) {\r\nret = PTR_ERR(rtc);\r\ngoto exit_put_clk_ref;\r\n}\r\npdata->rtc = rtc;\r\nreturn 0;\r\nexit_put_clk_ref:\r\nclk_disable_unprepare(pdata->clk_ref);\r\nexit_put_clk_ipg:\r\nclk_disable_unprepare(pdata->clk_ipg);\r\nreturn ret;\r\n}\r\nstatic int mxc_rtc_remove(struct platform_device *pdev)\r\n{\r\nstruct rtc_plat_data *pdata = platform_get_drvdata(pdev);\r\nclk_disable_unprepare(pdata->clk_ref);\r\nclk_disable_unprepare(pdata->clk_ipg);\r\nreturn 0;\r\n}\r\nstatic int mxc_rtc_suspend(struct device *dev)\r\n{\r\nstruct rtc_plat_data *pdata = dev_get_drvdata(dev);\r\nif (device_may_wakeup(dev))\r\nenable_irq_wake(pdata->irq);\r\nreturn 0;\r\n}\r\nstatic int mxc_rtc_resume(struct device *dev)\r\n{\r\nstruct rtc_plat_data *pdata = dev_get_drvdata(dev);\r\nif (device_may_wakeup(dev))\r\ndisable_irq_wake(pdata->irq);\r\nreturn 0;\r\n}
