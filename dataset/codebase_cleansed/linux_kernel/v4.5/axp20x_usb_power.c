static irqreturn_t axp20x_usb_power_irq(int irq, void *devid)\r\n{\r\nstruct axp20x_usb_power *power = devid;\r\npower_supply_changed(power->supply);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int axp20x_usb_power_get_property(struct power_supply *psy,\r\nenum power_supply_property psp, union power_supply_propval *val)\r\n{\r\nstruct axp20x_usb_power *power = power_supply_get_drvdata(psy);\r\nunsigned int input, v;\r\nint ret;\r\nswitch (psp) {\r\ncase POWER_SUPPLY_PROP_VOLTAGE_MIN:\r\nret = regmap_read(power->regmap, AXP20X_VBUS_IPSOUT_MGMT, &v);\r\nif (ret)\r\nreturn ret;\r\nval->intval = AXP20X_VBUS_VHOLD_uV(v);\r\nreturn 0;\r\ncase POWER_SUPPLY_PROP_VOLTAGE_NOW:\r\nret = axp20x_read_variable_width(power->regmap,\r\nAXP20X_VBUS_V_ADC_H, 12);\r\nif (ret < 0)\r\nreturn ret;\r\nval->intval = ret * 1700;\r\nreturn 0;\r\ncase POWER_SUPPLY_PROP_CURRENT_MAX:\r\nret = regmap_read(power->regmap, AXP20X_VBUS_IPSOUT_MGMT, &v);\r\nif (ret)\r\nreturn ret;\r\nswitch (v & AXP20X_VBUS_CLIMIT_MASK) {\r\ncase AXP20X_VBUC_CLIMIT_100mA:\r\nval->intval = 100000;\r\nbreak;\r\ncase AXP20X_VBUC_CLIMIT_500mA:\r\nval->intval = 500000;\r\nbreak;\r\ncase AXP20X_VBUC_CLIMIT_900mA:\r\nval->intval = 900000;\r\nbreak;\r\ncase AXP20X_VBUC_CLIMIT_NONE:\r\nval->intval = -1;\r\nbreak;\r\n}\r\nreturn 0;\r\ncase POWER_SUPPLY_PROP_CURRENT_NOW:\r\nret = axp20x_read_variable_width(power->regmap,\r\nAXP20X_VBUS_I_ADC_H, 12);\r\nif (ret < 0)\r\nreturn ret;\r\nval->intval = ret * 375;\r\nreturn 0;\r\ndefault:\r\nbreak;\r\n}\r\nret = regmap_read(power->regmap, AXP20X_PWR_INPUT_STATUS, &input);\r\nif (ret)\r\nreturn ret;\r\nswitch (psp) {\r\ncase POWER_SUPPLY_PROP_HEALTH:\r\nif (!(input & AXP20X_PWR_STATUS_VBUS_PRESENT)) {\r\nval->intval = POWER_SUPPLY_HEALTH_UNKNOWN;\r\nbreak;\r\n}\r\nret = regmap_read(power->regmap, AXP20X_USB_OTG_STATUS, &v);\r\nif (ret)\r\nreturn ret;\r\nif (!(v & AXP20X_USB_STATUS_VBUS_VALID)) {\r\nval->intval = POWER_SUPPLY_HEALTH_UNSPEC_FAILURE;\r\nbreak;\r\n}\r\nval->intval = POWER_SUPPLY_HEALTH_GOOD;\r\nbreak;\r\ncase POWER_SUPPLY_PROP_PRESENT:\r\nval->intval = !!(input & AXP20X_PWR_STATUS_VBUS_PRESENT);\r\nbreak;\r\ncase POWER_SUPPLY_PROP_ONLINE:\r\nval->intval = !!(input & AXP20X_PWR_STATUS_VBUS_USED);\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int axp20x_usb_power_probe(struct platform_device *pdev)\r\n{\r\nstruct axp20x_dev *axp20x = dev_get_drvdata(pdev->dev.parent);\r\nstruct power_supply_config psy_cfg = {};\r\nstruct axp20x_usb_power *power;\r\nstatic const char * const irq_names[] = { "VBUS_PLUGIN",\r\n"VBUS_REMOVAL", "VBUS_VALID", "VBUS_NOT_VALID" };\r\nint i, irq, ret;\r\nif (!of_device_is_available(pdev->dev.of_node))\r\nreturn -ENODEV;\r\nif (!axp20x) {\r\ndev_err(&pdev->dev, "Parent drvdata not set\n");\r\nreturn -EINVAL;\r\n}\r\npower = devm_kzalloc(&pdev->dev, sizeof(*power), GFP_KERNEL);\r\nif (!power)\r\nreturn -ENOMEM;\r\npower->regmap = axp20x->regmap;\r\nret = regmap_update_bits(power->regmap, AXP20X_VBUS_MON,\r\nAXP20X_VBUS_MON_VBUS_VALID, AXP20X_VBUS_MON_VBUS_VALID);\r\nif (ret)\r\nreturn ret;\r\nret = regmap_update_bits(power->regmap, AXP20X_ADC_EN1,\r\nAXP20X_ADC_EN1_VBUS_CURR | AXP20X_ADC_EN1_VBUS_VOLT,\r\nAXP20X_ADC_EN1_VBUS_CURR | AXP20X_ADC_EN1_VBUS_VOLT);\r\nif (ret)\r\nreturn ret;\r\npsy_cfg.of_node = pdev->dev.of_node;\r\npsy_cfg.drv_data = power;\r\npower->supply = devm_power_supply_register(&pdev->dev,\r\n&axp20x_usb_power_desc, &psy_cfg);\r\nif (IS_ERR(power->supply))\r\nreturn PTR_ERR(power->supply);\r\nfor (i = 0; i < ARRAY_SIZE(irq_names); i++) {\r\nirq = platform_get_irq_byname(pdev, irq_names[i]);\r\nif (irq < 0) {\r\ndev_warn(&pdev->dev, "No IRQ for %s: %d\n",\r\nirq_names[i], irq);\r\ncontinue;\r\n}\r\nirq = regmap_irq_get_virq(axp20x->regmap_irqc, irq);\r\nret = devm_request_any_context_irq(&pdev->dev, irq,\r\naxp20x_usb_power_irq, 0, DRVNAME, power);\r\nif (ret < 0)\r\ndev_warn(&pdev->dev, "Error requesting %s IRQ: %d\n",\r\nirq_names[i], ret);\r\n}\r\nreturn 0;\r\n}
