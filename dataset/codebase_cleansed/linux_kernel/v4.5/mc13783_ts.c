static irqreturn_t mc13783_ts_handler(int irq, void *data)\r\n{\r\nstruct mc13783_ts_priv *priv = data;\r\nmc13xxx_irq_ack(priv->mc13xxx, irq);\r\nqueue_delayed_work(priv->workq, &priv->work, 0);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void mc13783_ts_report_sample(struct mc13783_ts_priv *priv)\r\n{\r\nstruct input_dev *idev = priv->idev;\r\nint x0, x1, x2, y0, y1, y2;\r\nint cr0, cr1;\r\nx0 = priv->sample[0] & 0xfff;\r\nx1 = priv->sample[1] & 0xfff;\r\nx2 = priv->sample[2] & 0xfff;\r\ny0 = priv->sample[3] & 0xfff;\r\ny1 = (priv->sample[0] >> 12) & 0xfff;\r\ny2 = (priv->sample[1] >> 12) & 0xfff;\r\ncr0 = (priv->sample[2] >> 12) & 0xfff;\r\ncr1 = (priv->sample[3] >> 12) & 0xfff;\r\ndev_dbg(&idev->dev,\r\n"x: (% 4d,% 4d,% 4d) y: (% 4d, % 4d,% 4d) cr: (% 4d, % 4d)\n",\r\nx0, x1, x2, y0, y1, y2, cr0, cr1);\r\nsort3(x0, x1, x2);\r\nsort3(y0, y1, y2);\r\ncr0 = (cr0 + cr1) / 2;\r\nif (!cr0 || !sample_tolerance ||\r\n(x2 - x0 < sample_tolerance &&\r\ny2 - y0 < sample_tolerance)) {\r\nif (cr0) {\r\ninput_report_abs(idev, ABS_X, x1);\r\ninput_report_abs(idev, ABS_Y, y1);\r\ndev_dbg(&idev->dev, "report (%d, %d, %d)\n",\r\nx1, y1, 0x1000 - cr0);\r\nqueue_delayed_work(priv->workq, &priv->work, HZ / 50);\r\n} else\r\ndev_dbg(&idev->dev, "report release\n");\r\ninput_report_abs(idev, ABS_PRESSURE,\r\ncr0 ? 0x1000 - cr0 : cr0);\r\ninput_report_key(idev, BTN_TOUCH, cr0);\r\ninput_sync(idev);\r\n} else\r\ndev_dbg(&idev->dev, "discard event\n");\r\n}\r\nstatic void mc13783_ts_work(struct work_struct *work)\r\n{\r\nstruct mc13783_ts_priv *priv =\r\ncontainer_of(work, struct mc13783_ts_priv, work.work);\r\nunsigned int mode = MC13XXX_ADC_MODE_TS;\r\nunsigned int channel = 12;\r\nif (mc13xxx_adc_do_conversion(priv->mc13xxx,\r\nmode, channel,\r\npriv->touch->ato, priv->touch->atox,\r\npriv->sample) == 0)\r\nmc13783_ts_report_sample(priv);\r\n}\r\nstatic int mc13783_ts_open(struct input_dev *dev)\r\n{\r\nstruct mc13783_ts_priv *priv = input_get_drvdata(dev);\r\nint ret;\r\nmc13xxx_lock(priv->mc13xxx);\r\nmc13xxx_irq_ack(priv->mc13xxx, MC13XXX_IRQ_TS);\r\nret = mc13xxx_irq_request(priv->mc13xxx, MC13XXX_IRQ_TS,\r\nmc13783_ts_handler, MC13783_TS_NAME, priv);\r\nif (ret)\r\ngoto out;\r\nret = mc13xxx_reg_rmw(priv->mc13xxx, MC13XXX_ADC0,\r\nMC13XXX_ADC0_TSMOD_MASK, MC13XXX_ADC0_TSMOD0);\r\nif (ret)\r\nmc13xxx_irq_free(priv->mc13xxx, MC13XXX_IRQ_TS, priv);\r\nout:\r\nmc13xxx_unlock(priv->mc13xxx);\r\nreturn ret;\r\n}\r\nstatic void mc13783_ts_close(struct input_dev *dev)\r\n{\r\nstruct mc13783_ts_priv *priv = input_get_drvdata(dev);\r\nmc13xxx_lock(priv->mc13xxx);\r\nmc13xxx_reg_rmw(priv->mc13xxx, MC13XXX_ADC0,\r\nMC13XXX_ADC0_TSMOD_MASK, 0);\r\nmc13xxx_irq_free(priv->mc13xxx, MC13XXX_IRQ_TS, priv);\r\nmc13xxx_unlock(priv->mc13xxx);\r\ncancel_delayed_work_sync(&priv->work);\r\n}\r\nstatic int __init mc13783_ts_probe(struct platform_device *pdev)\r\n{\r\nstruct mc13783_ts_priv *priv;\r\nstruct input_dev *idev;\r\nint ret = -ENOMEM;\r\npriv = kzalloc(sizeof(*priv), GFP_KERNEL);\r\nidev = input_allocate_device();\r\nif (!priv || !idev)\r\ngoto err_free_mem;\r\nINIT_DELAYED_WORK(&priv->work, mc13783_ts_work);\r\npriv->mc13xxx = dev_get_drvdata(pdev->dev.parent);\r\npriv->idev = idev;\r\npriv->touch = dev_get_platdata(&pdev->dev);\r\nif (!priv->touch) {\r\ndev_err(&pdev->dev, "missing platform data\n");\r\nret = -ENODEV;\r\ngoto err_free_mem;\r\n}\r\npriv->workq = create_singlethread_workqueue("mc13783_ts");\r\nif (!priv->workq)\r\ngoto err_free_mem;\r\nidev->name = MC13783_TS_NAME;\r\nidev->dev.parent = &pdev->dev;\r\nidev->evbit[0] = BIT_MASK(EV_KEY) | BIT_MASK(EV_ABS);\r\nidev->keybit[BIT_WORD(BTN_TOUCH)] = BIT_MASK(BTN_TOUCH);\r\ninput_set_abs_params(idev, ABS_X, 0, 0xfff, 0, 0);\r\ninput_set_abs_params(idev, ABS_Y, 0, 0xfff, 0, 0);\r\ninput_set_abs_params(idev, ABS_PRESSURE, 0, 0xfff, 0, 0);\r\nidev->open = mc13783_ts_open;\r\nidev->close = mc13783_ts_close;\r\ninput_set_drvdata(idev, priv);\r\nret = input_register_device(priv->idev);\r\nif (ret) {\r\ndev_err(&pdev->dev,\r\n"register input device failed with %d\n", ret);\r\ngoto err_destroy_wq;\r\n}\r\nplatform_set_drvdata(pdev, priv);\r\nreturn 0;\r\nerr_destroy_wq:\r\ndestroy_workqueue(priv->workq);\r\nerr_free_mem:\r\ninput_free_device(idev);\r\nkfree(priv);\r\nreturn ret;\r\n}\r\nstatic int mc13783_ts_remove(struct platform_device *pdev)\r\n{\r\nstruct mc13783_ts_priv *priv = platform_get_drvdata(pdev);\r\ndestroy_workqueue(priv->workq);\r\ninput_unregister_device(priv->idev);\r\nkfree(priv);\r\nreturn 0;\r\n}
