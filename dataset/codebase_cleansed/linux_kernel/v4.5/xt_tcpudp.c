static inline bool\r\nport_match(u_int16_t min, u_int16_t max, u_int16_t port, bool invert)\r\n{\r\nreturn (port >= min && port <= max) ^ invert;\r\n}\r\nstatic bool\r\ntcp_find_option(u_int8_t option,\r\nconst struct sk_buff *skb,\r\nunsigned int protoff,\r\nunsigned int optlen,\r\nbool invert,\r\nbool *hotdrop)\r\n{\r\nconst u_int8_t *op;\r\nu_int8_t _opt[60 - sizeof(struct tcphdr)];\r\nunsigned int i;\r\npr_debug("finding option\n");\r\nif (!optlen)\r\nreturn invert;\r\nop = skb_header_pointer(skb, protoff + sizeof(struct tcphdr),\r\noptlen, _opt);\r\nif (op == NULL) {\r\n*hotdrop = true;\r\nreturn false;\r\n}\r\nfor (i = 0; i < optlen; ) {\r\nif (op[i] == option) return !invert;\r\nif (op[i] < 2) i++;\r\nelse i += op[i+1]?:1;\r\n}\r\nreturn invert;\r\n}\r\nstatic bool tcp_mt(const struct sk_buff *skb, struct xt_action_param *par)\r\n{\r\nconst struct tcphdr *th;\r\nstruct tcphdr _tcph;\r\nconst struct xt_tcp *tcpinfo = par->matchinfo;\r\nif (par->fragoff != 0) {\r\nif (par->fragoff == 1) {\r\npr_debug("Dropping evil TCP offset=1 frag.\n");\r\npar->hotdrop = true;\r\n}\r\nreturn false;\r\n}\r\n#define FWINVTCP(bool, invflg) ((bool) ^ !!(tcpinfo->invflags & (invflg)))\r\nth = skb_header_pointer(skb, par->thoff, sizeof(_tcph), &_tcph);\r\nif (th == NULL) {\r\npr_debug("Dropping evil TCP offset=0 tinygram.\n");\r\npar->hotdrop = true;\r\nreturn false;\r\n}\r\nif (!port_match(tcpinfo->spts[0], tcpinfo->spts[1],\r\nntohs(th->source),\r\n!!(tcpinfo->invflags & XT_TCP_INV_SRCPT)))\r\nreturn false;\r\nif (!port_match(tcpinfo->dpts[0], tcpinfo->dpts[1],\r\nntohs(th->dest),\r\n!!(tcpinfo->invflags & XT_TCP_INV_DSTPT)))\r\nreturn false;\r\nif (!FWINVTCP((((unsigned char *)th)[13] & tcpinfo->flg_mask)\r\n== tcpinfo->flg_cmp,\r\nXT_TCP_INV_FLAGS))\r\nreturn false;\r\nif (tcpinfo->option) {\r\nif (th->doff * 4 < sizeof(_tcph)) {\r\npar->hotdrop = true;\r\nreturn false;\r\n}\r\nif (!tcp_find_option(tcpinfo->option, skb, par->thoff,\r\nth->doff*4 - sizeof(_tcph),\r\ntcpinfo->invflags & XT_TCP_INV_OPTION,\r\n&par->hotdrop))\r\nreturn false;\r\n}\r\nreturn true;\r\n}\r\nstatic int tcp_mt_check(const struct xt_mtchk_param *par)\r\n{\r\nconst struct xt_tcp *tcpinfo = par->matchinfo;\r\nreturn (tcpinfo->invflags & ~XT_TCP_INV_MASK) ? -EINVAL : 0;\r\n}\r\nstatic bool udp_mt(const struct sk_buff *skb, struct xt_action_param *par)\r\n{\r\nconst struct udphdr *uh;\r\nstruct udphdr _udph;\r\nconst struct xt_udp *udpinfo = par->matchinfo;\r\nif (par->fragoff != 0)\r\nreturn false;\r\nuh = skb_header_pointer(skb, par->thoff, sizeof(_udph), &_udph);\r\nif (uh == NULL) {\r\npr_debug("Dropping evil UDP tinygram.\n");\r\npar->hotdrop = true;\r\nreturn false;\r\n}\r\nreturn port_match(udpinfo->spts[0], udpinfo->spts[1],\r\nntohs(uh->source),\r\n!!(udpinfo->invflags & XT_UDP_INV_SRCPT))\r\n&& port_match(udpinfo->dpts[0], udpinfo->dpts[1],\r\nntohs(uh->dest),\r\n!!(udpinfo->invflags & XT_UDP_INV_DSTPT));\r\n}\r\nstatic int udp_mt_check(const struct xt_mtchk_param *par)\r\n{\r\nconst struct xt_udp *udpinfo = par->matchinfo;\r\nreturn (udpinfo->invflags & ~XT_UDP_INV_MASK) ? -EINVAL : 0;\r\n}\r\nstatic int __init tcpudp_mt_init(void)\r\n{\r\nreturn xt_register_matches(tcpudp_mt_reg, ARRAY_SIZE(tcpudp_mt_reg));\r\n}\r\nstatic void __exit tcpudp_mt_exit(void)\r\n{\r\nxt_unregister_matches(tcpudp_mt_reg, ARRAY_SIZE(tcpudp_mt_reg));\r\n}
