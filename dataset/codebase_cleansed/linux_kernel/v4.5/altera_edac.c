static irqreturn_t altr_sdram_mc_err_handler(int irq, void *dev_id)\r\n{\r\nstruct mem_ctl_info *mci = dev_id;\r\nstruct altr_sdram_mc_data *drvdata = mci->pvt_info;\r\nconst struct altr_sdram_prv_data *priv = drvdata->data;\r\nu32 status, err_count = 1, err_addr;\r\nregmap_read(drvdata->mc_vbase, priv->ecc_stat_offset, &status);\r\nif (status & priv->ecc_stat_ue_mask) {\r\nregmap_read(drvdata->mc_vbase, priv->ecc_daddr_offset,\r\n&err_addr);\r\nif (priv->ecc_uecnt_offset)\r\nregmap_read(drvdata->mc_vbase, priv->ecc_uecnt_offset,\r\n&err_count);\r\npanic("\nEDAC: [%d Uncorrectable errors @ 0x%08X]\n",\r\nerr_count, err_addr);\r\n}\r\nif (status & priv->ecc_stat_ce_mask) {\r\nregmap_read(drvdata->mc_vbase, priv->ecc_saddr_offset,\r\n&err_addr);\r\nif (priv->ecc_uecnt_offset)\r\nregmap_read(drvdata->mc_vbase, priv->ecc_cecnt_offset,\r\n&err_count);\r\nedac_mc_handle_error(HW_EVENT_ERR_CORRECTED, mci, err_count,\r\nerr_addr >> PAGE_SHIFT,\r\nerr_addr & ~PAGE_MASK, 0,\r\n0, 0, -1, mci->ctl_name, "");\r\nregmap_write(drvdata->mc_vbase, priv->ecc_irq_clr_offset,\r\npriv->ecc_irq_clr_mask);\r\nreturn IRQ_HANDLED;\r\n}\r\nreturn IRQ_NONE;\r\n}\r\nstatic ssize_t altr_sdr_mc_err_inject_write(struct file *file,\r\nconst char __user *data,\r\nsize_t count, loff_t *ppos)\r\n{\r\nstruct mem_ctl_info *mci = file->private_data;\r\nstruct altr_sdram_mc_data *drvdata = mci->pvt_info;\r\nconst struct altr_sdram_prv_data *priv = drvdata->data;\r\nu32 *ptemp;\r\ndma_addr_t dma_handle;\r\nu32 reg, read_reg;\r\nptemp = dma_alloc_coherent(mci->pdev, 16, &dma_handle, GFP_KERNEL);\r\nif (!ptemp) {\r\ndma_free_coherent(mci->pdev, 16, ptemp, dma_handle);\r\nedac_printk(KERN_ERR, EDAC_MC,\r\n"Inject: Buffer Allocation error\n");\r\nreturn -ENOMEM;\r\n}\r\nregmap_read(drvdata->mc_vbase, priv->ce_ue_trgr_offset,\r\n&read_reg);\r\nread_reg &= ~(priv->ce_set_mask | priv->ue_set_mask);\r\nif (count == 3) {\r\nedac_printk(KERN_ALERT, EDAC_MC,\r\n"Inject Double bit error\n");\r\nregmap_write(drvdata->mc_vbase, priv->ce_ue_trgr_offset,\r\n(read_reg | priv->ue_set_mask));\r\n} else {\r\nedac_printk(KERN_ALERT, EDAC_MC,\r\n"Inject Single bit error\n");\r\nregmap_write(drvdata->mc_vbase, priv->ce_ue_trgr_offset,\r\n(read_reg | priv->ce_set_mask));\r\n}\r\nptemp[0] = 0x5A5A5A5A;\r\nptemp[1] = 0xA5A5A5A5;\r\nregmap_write(drvdata->mc_vbase, priv->ce_ue_trgr_offset, read_reg);\r\nwmb();\r\nreg = ACCESS_ONCE(ptemp[0]);\r\nread_reg = ACCESS_ONCE(ptemp[1]);\r\nrmb();\r\nedac_printk(KERN_ALERT, EDAC_MC, "Read Data [0x%X, 0x%X]\n",\r\nreg, read_reg);\r\ndma_free_coherent(mci->pdev, 16, ptemp, dma_handle);\r\nreturn count;\r\n}\r\nstatic void altr_sdr_mc_create_debugfs_nodes(struct mem_ctl_info *mci)\r\n{\r\nif (!IS_ENABLED(CONFIG_EDAC_DEBUG))\r\nreturn;\r\nif (!mci->debugfs)\r\nreturn;\r\nedac_debugfs_create_file("inject_ctrl", S_IWUSR, mci->debugfs, mci,\r\n&altr_sdr_mc_debug_inject_fops);\r\n}\r\nstatic unsigned long get_total_mem(void)\r\n{\r\nstruct device_node *np = NULL;\r\nconst unsigned int *reg, *reg_end;\r\nint len, sw, aw;\r\nunsigned long start, size, total_mem = 0;\r\nfor_each_node_by_type(np, "memory") {\r\naw = of_n_addr_cells(np);\r\nsw = of_n_size_cells(np);\r\nreg = (const unsigned int *)of_get_property(np, "reg", &len);\r\nreg_end = reg + (len / sizeof(u32));\r\ntotal_mem = 0;\r\ndo {\r\nstart = of_read_number(reg, aw);\r\nreg += aw;\r\nsize = of_read_number(reg, sw);\r\nreg += sw;\r\ntotal_mem += size;\r\n} while (reg < reg_end);\r\n}\r\nedac_dbg(0, "total_mem 0x%lx\n", total_mem);\r\nreturn total_mem;\r\n}\r\nstatic int a10_init(struct regmap *mc_vbase)\r\n{\r\nif (regmap_update_bits(mc_vbase, A10_INTMODE_OFST,\r\nA10_INTMODE_SB_INT, A10_INTMODE_SB_INT)) {\r\nedac_printk(KERN_ERR, EDAC_MC,\r\n"Error setting SB IRQ mode\n");\r\nreturn -ENODEV;\r\n}\r\nif (regmap_write(mc_vbase, A10_SERRCNTREG_OFST, 1)) {\r\nedac_printk(KERN_ERR, EDAC_MC,\r\n"Error setting trigger count\n");\r\nreturn -ENODEV;\r\n}\r\nreturn 0;\r\n}\r\nstatic int a10_unmask_irq(struct platform_device *pdev, u32 mask)\r\n{\r\nvoid __iomem *sm_base;\r\nint ret = 0;\r\nif (!request_mem_region(A10_SYMAN_INTMASK_CLR, sizeof(u32),\r\ndev_name(&pdev->dev))) {\r\nedac_printk(KERN_ERR, EDAC_MC,\r\n"Unable to request mem region\n");\r\nreturn -EBUSY;\r\n}\r\nsm_base = ioremap(A10_SYMAN_INTMASK_CLR, sizeof(u32));\r\nif (!sm_base) {\r\nedac_printk(KERN_ERR, EDAC_MC,\r\n"Unable to ioremap device\n");\r\nret = -ENOMEM;\r\ngoto release;\r\n}\r\niowrite32(mask, sm_base);\r\niounmap(sm_base);\r\nrelease:\r\nrelease_mem_region(A10_SYMAN_INTMASK_CLR, sizeof(u32));\r\nreturn ret;\r\n}\r\nstatic int altr_sdram_probe(struct platform_device *pdev)\r\n{\r\nconst struct of_device_id *id;\r\nstruct edac_mc_layer layers[2];\r\nstruct mem_ctl_info *mci;\r\nstruct altr_sdram_mc_data *drvdata;\r\nconst struct altr_sdram_prv_data *priv;\r\nstruct regmap *mc_vbase;\r\nstruct dimm_info *dimm;\r\nu32 read_reg;\r\nint irq, irq2, res = 0;\r\nunsigned long mem_size, irqflags = 0;\r\nid = of_match_device(altr_sdram_ctrl_of_match, &pdev->dev);\r\nif (!id)\r\nreturn -ENODEV;\r\nmc_vbase = syscon_regmap_lookup_by_phandle(pdev->dev.of_node,\r\n"altr,sdr-syscon");\r\nif (IS_ERR(mc_vbase)) {\r\nedac_printk(KERN_ERR, EDAC_MC,\r\n"regmap for altr,sdr-syscon lookup failed.\n");\r\nreturn -ENODEV;\r\n}\r\npriv = of_match_node(altr_sdram_ctrl_of_match,\r\npdev->dev.of_node)->data;\r\nif (regmap_read(mc_vbase, priv->ecc_ctrl_offset, &read_reg) ||\r\n((read_reg & priv->ecc_ctl_en_mask) != priv->ecc_ctl_en_mask)) {\r\nedac_printk(KERN_ERR, EDAC_MC,\r\n"No ECC/ECC disabled [0x%08X]\n", read_reg);\r\nreturn -ENODEV;\r\n}\r\nmem_size = get_total_mem();\r\nif (!mem_size) {\r\nedac_printk(KERN_ERR, EDAC_MC, "Unable to calculate memory size\n");\r\nreturn -ENODEV;\r\n}\r\nif (regmap_update_bits(mc_vbase, priv->ecc_irq_en_offset,\r\npriv->ecc_irq_en_mask, 0)) {\r\nedac_printk(KERN_ERR, EDAC_MC,\r\n"Error disabling SDRAM ECC IRQ\n");\r\nreturn -ENODEV;\r\n}\r\nif (regmap_update_bits(mc_vbase, priv->ecc_cnt_rst_offset,\r\npriv->ecc_cnt_rst_mask,\r\npriv->ecc_cnt_rst_mask)) {\r\nedac_printk(KERN_ERR, EDAC_MC,\r\n"Error clearing SDRAM ECC count\n");\r\nreturn -ENODEV;\r\n}\r\nif (regmap_update_bits(mc_vbase, priv->ecc_cnt_rst_offset,\r\npriv->ecc_cnt_rst_mask, 0)) {\r\nedac_printk(KERN_ERR, EDAC_MC,\r\n"Error clearing SDRAM ECC count\n");\r\nreturn -ENODEV;\r\n}\r\nirq = platform_get_irq(pdev, 0);\r\nif (irq < 0) {\r\nedac_printk(KERN_ERR, EDAC_MC,\r\n"No irq %d in DT\n", irq);\r\nreturn -ENODEV;\r\n}\r\nirq2 = platform_get_irq(pdev, 1);\r\nlayers[0].type = EDAC_MC_LAYER_CHIP_SELECT;\r\nlayers[0].size = 1;\r\nlayers[0].is_virt_csrow = true;\r\nlayers[1].type = EDAC_MC_LAYER_CHANNEL;\r\nlayers[1].size = 1;\r\nlayers[1].is_virt_csrow = false;\r\nmci = edac_mc_alloc(0, ARRAY_SIZE(layers), layers,\r\nsizeof(struct altr_sdram_mc_data));\r\nif (!mci)\r\nreturn -ENOMEM;\r\nmci->pdev = &pdev->dev;\r\ndrvdata = mci->pvt_info;\r\ndrvdata->mc_vbase = mc_vbase;\r\ndrvdata->data = priv;\r\nplatform_set_drvdata(pdev, mci);\r\nif (!devres_open_group(&pdev->dev, NULL, GFP_KERNEL)) {\r\nedac_printk(KERN_ERR, EDAC_MC,\r\n"Unable to get managed device resource\n");\r\nres = -ENOMEM;\r\ngoto free;\r\n}\r\nmci->mtype_cap = MEM_FLAG_DDR3;\r\nmci->edac_ctl_cap = EDAC_FLAG_NONE | EDAC_FLAG_SECDED;\r\nmci->edac_cap = EDAC_FLAG_SECDED;\r\nmci->mod_name = EDAC_MOD_STR;\r\nmci->mod_ver = EDAC_VERSION;\r\nmci->ctl_name = dev_name(&pdev->dev);\r\nmci->scrub_mode = SCRUB_SW_SRC;\r\nmci->dev_name = dev_name(&pdev->dev);\r\ndimm = *mci->dimms;\r\ndimm->nr_pages = ((mem_size - 1) >> PAGE_SHIFT) + 1;\r\ndimm->grain = 8;\r\ndimm->dtype = DEV_X8;\r\ndimm->mtype = MEM_DDR3;\r\ndimm->edac_mode = EDAC_SECDED;\r\nres = edac_mc_add_mc(mci);\r\nif (res < 0)\r\ngoto err;\r\nif (irq2 > 0) {\r\nres = a10_init(mc_vbase);\r\nif (res < 0)\r\ngoto err2;\r\nres = devm_request_irq(&pdev->dev, irq2,\r\naltr_sdram_mc_err_handler,\r\nIRQF_SHARED, dev_name(&pdev->dev), mci);\r\nif (res < 0) {\r\nedac_mc_printk(mci, KERN_ERR,\r\n"Unable to request irq %d\n", irq2);\r\nres = -ENODEV;\r\ngoto err2;\r\n}\r\nres = a10_unmask_irq(pdev, A10_DDR0_IRQ_MASK);\r\nif (res < 0)\r\ngoto err2;\r\nirqflags = IRQF_SHARED;\r\n}\r\nres = devm_request_irq(&pdev->dev, irq, altr_sdram_mc_err_handler,\r\nirqflags, dev_name(&pdev->dev), mci);\r\nif (res < 0) {\r\nedac_mc_printk(mci, KERN_ERR,\r\n"Unable to request irq %d\n", irq);\r\nres = -ENODEV;\r\ngoto err2;\r\n}\r\nif (regmap_update_bits(drvdata->mc_vbase, priv->ecc_irq_en_offset,\r\npriv->ecc_irq_en_mask, priv->ecc_irq_en_mask)) {\r\nedac_mc_printk(mci, KERN_ERR,\r\n"Error enabling SDRAM ECC IRQ\n");\r\nres = -ENODEV;\r\ngoto err2;\r\n}\r\naltr_sdr_mc_create_debugfs_nodes(mci);\r\ndevres_close_group(&pdev->dev, NULL);\r\nreturn 0;\r\nerr2:\r\nedac_mc_del_mc(&pdev->dev);\r\nerr:\r\ndevres_release_group(&pdev->dev, NULL);\r\nfree:\r\nedac_mc_free(mci);\r\nedac_printk(KERN_ERR, EDAC_MC,\r\n"EDAC Probe Failed; Error %d\n", res);\r\nreturn res;\r\n}\r\nstatic int altr_sdram_remove(struct platform_device *pdev)\r\n{\r\nstruct mem_ctl_info *mci = platform_get_drvdata(pdev);\r\nedac_mc_del_mc(&pdev->dev);\r\nedac_mc_free(mci);\r\nplatform_set_drvdata(pdev, NULL);\r\nreturn 0;\r\n}\r\nstatic int altr_sdram_prepare(struct device *dev)\r\n{\r\npr_err("Suspend not allowed when EDAC is enabled.\n");\r\nreturn -EPERM;\r\n}
