static void ide_tf_set_cmd(ide_drive_t *drive, struct ide_cmd *cmd, u8 dma)\r\n{\r\nu8 index, lba48, write;\r\nlba48 = (cmd->tf_flags & IDE_TFLAG_LBA48) ? 2 : 0;\r\nwrite = (cmd->tf_flags & IDE_TFLAG_WRITE) ? 1 : 0;\r\nif (dma) {\r\ncmd->protocol = ATA_PROT_DMA;\r\nindex = 8;\r\n} else {\r\ncmd->protocol = ATA_PROT_PIO;\r\nif (drive->mult_count) {\r\ncmd->tf_flags |= IDE_TFLAG_MULTI_PIO;\r\nindex = 0;\r\n} else\r\nindex = 4;\r\n}\r\ncmd->tf.command = ide_rw_cmds[index + lba48 + write];\r\n}\r\nstatic ide_startstop_t __ide_do_rw_disk(ide_drive_t *drive, struct request *rq,\r\nsector_t block)\r\n{\r\nide_hwif_t *hwif = drive->hwif;\r\nu16 nsectors = (u16)blk_rq_sectors(rq);\r\nu8 lba48 = !!(drive->dev_flags & IDE_DFLAG_LBA48);\r\nu8 dma = !!(drive->dev_flags & IDE_DFLAG_USING_DMA);\r\nstruct ide_cmd cmd;\r\nstruct ide_taskfile *tf = &cmd.tf;\r\nide_startstop_t rc;\r\nif ((hwif->host_flags & IDE_HFLAG_NO_LBA48_DMA) && lba48 && dma) {\r\nif (block + blk_rq_sectors(rq) > 1ULL << 28)\r\ndma = 0;\r\nelse\r\nlba48 = 0;\r\n}\r\nmemset(&cmd, 0, sizeof(cmd));\r\ncmd.valid.out.tf = IDE_VALID_OUT_TF | IDE_VALID_DEVICE;\r\ncmd.valid.in.tf = IDE_VALID_IN_TF | IDE_VALID_DEVICE;\r\nif (drive->dev_flags & IDE_DFLAG_LBA) {\r\nif (lba48) {\r\npr_debug("%s: LBA=0x%012llx\n", drive->name,\r\n(unsigned long long)block);\r\ntf->nsect = nsectors & 0xff;\r\ntf->lbal = (u8) block;\r\ntf->lbam = (u8)(block >> 8);\r\ntf->lbah = (u8)(block >> 16);\r\ntf->device = ATA_LBA;\r\ntf = &cmd.hob;\r\ntf->nsect = (nsectors >> 8) & 0xff;\r\ntf->lbal = (u8)(block >> 24);\r\nif (sizeof(block) != 4) {\r\ntf->lbam = (u8)((u64)block >> 32);\r\ntf->lbah = (u8)((u64)block >> 40);\r\n}\r\ncmd.valid.out.hob = IDE_VALID_OUT_HOB;\r\ncmd.valid.in.hob = IDE_VALID_IN_HOB;\r\ncmd.tf_flags |= IDE_TFLAG_LBA48;\r\n} else {\r\ntf->nsect = nsectors & 0xff;\r\ntf->lbal = block;\r\ntf->lbam = block >>= 8;\r\ntf->lbah = block >>= 8;\r\ntf->device = ((block >> 8) & 0xf) | ATA_LBA;\r\n}\r\n} else {\r\nunsigned int sect, head, cyl, track;\r\ntrack = (int)block / drive->sect;\r\nsect = (int)block % drive->sect + 1;\r\nhead = track % drive->head;\r\ncyl = track / drive->head;\r\npr_debug("%s: CHS=%u/%u/%u\n", drive->name, cyl, head, sect);\r\ntf->nsect = nsectors & 0xff;\r\ntf->lbal = sect;\r\ntf->lbam = cyl;\r\ntf->lbah = cyl >> 8;\r\ntf->device = head;\r\n}\r\ncmd.tf_flags |= IDE_TFLAG_FS;\r\nif (rq_data_dir(rq))\r\ncmd.tf_flags |= IDE_TFLAG_WRITE;\r\nide_tf_set_cmd(drive, &cmd, dma);\r\ncmd.rq = rq;\r\nif (dma == 0) {\r\nide_init_sg_cmd(&cmd, nsectors << 9);\r\nide_map_sg(drive, &cmd);\r\n}\r\nrc = do_rw_taskfile(drive, &cmd);\r\nif (rc == ide_stopped && dma) {\r\ncmd.tf_flags |= IDE_TFLAG_DMA_PIO_FALLBACK;\r\nide_tf_set_cmd(drive, &cmd, 0);\r\nide_init_sg_cmd(&cmd, nsectors << 9);\r\nrc = do_rw_taskfile(drive, &cmd);\r\n}\r\nreturn rc;\r\n}\r\nstatic ide_startstop_t ide_do_rw_disk(ide_drive_t *drive, struct request *rq,\r\nsector_t block)\r\n{\r\nide_hwif_t *hwif = drive->hwif;\r\nBUG_ON(drive->dev_flags & IDE_DFLAG_BLOCKED);\r\nBUG_ON(rq->cmd_type != REQ_TYPE_FS);\r\nledtrig_ide_activity();\r\npr_debug("%s: %sing: block=%llu, sectors=%u\n",\r\ndrive->name, rq_data_dir(rq) == READ ? "read" : "writ",\r\n(unsigned long long)block, blk_rq_sectors(rq));\r\nif (hwif->rw_disk)\r\nhwif->rw_disk(drive, rq);\r\nreturn __ide_do_rw_disk(drive, rq, block);\r\n}\r\nstatic u64 idedisk_read_native_max_address(ide_drive_t *drive, int lba48)\r\n{\r\nstruct ide_cmd cmd;\r\nstruct ide_taskfile *tf = &cmd.tf;\r\nu64 addr = 0;\r\nmemset(&cmd, 0, sizeof(cmd));\r\nif (lba48)\r\ntf->command = ATA_CMD_READ_NATIVE_MAX_EXT;\r\nelse\r\ntf->command = ATA_CMD_READ_NATIVE_MAX;\r\ntf->device = ATA_LBA;\r\ncmd.valid.out.tf = IDE_VALID_OUT_TF | IDE_VALID_DEVICE;\r\ncmd.valid.in.tf = IDE_VALID_IN_TF | IDE_VALID_DEVICE;\r\nif (lba48) {\r\ncmd.valid.out.hob = IDE_VALID_OUT_HOB;\r\ncmd.valid.in.hob = IDE_VALID_IN_HOB;\r\ncmd.tf_flags = IDE_TFLAG_LBA48;\r\n}\r\nide_no_data_taskfile(drive, &cmd);\r\nif (!(tf->status & ATA_ERR))\r\naddr = ide_get_lba_addr(&cmd, lba48) + 1;\r\nreturn addr;\r\n}\r\nstatic u64 idedisk_set_max_address(ide_drive_t *drive, u64 addr_req, int lba48)\r\n{\r\nstruct ide_cmd cmd;\r\nstruct ide_taskfile *tf = &cmd.tf;\r\nu64 addr_set = 0;\r\naddr_req--;\r\nmemset(&cmd, 0, sizeof(cmd));\r\ntf->lbal = (addr_req >> 0) & 0xff;\r\ntf->lbam = (addr_req >>= 8) & 0xff;\r\ntf->lbah = (addr_req >>= 8) & 0xff;\r\nif (lba48) {\r\ncmd.hob.lbal = (addr_req >>= 8) & 0xff;\r\ncmd.hob.lbam = (addr_req >>= 8) & 0xff;\r\ncmd.hob.lbah = (addr_req >>= 8) & 0xff;\r\ntf->command = ATA_CMD_SET_MAX_EXT;\r\n} else {\r\ntf->device = (addr_req >>= 8) & 0x0f;\r\ntf->command = ATA_CMD_SET_MAX;\r\n}\r\ntf->device |= ATA_LBA;\r\ncmd.valid.out.tf = IDE_VALID_OUT_TF | IDE_VALID_DEVICE;\r\ncmd.valid.in.tf = IDE_VALID_IN_TF | IDE_VALID_DEVICE;\r\nif (lba48) {\r\ncmd.valid.out.hob = IDE_VALID_OUT_HOB;\r\ncmd.valid.in.hob = IDE_VALID_IN_HOB;\r\ncmd.tf_flags = IDE_TFLAG_LBA48;\r\n}\r\nide_no_data_taskfile(drive, &cmd);\r\nif (!(tf->status & ATA_ERR))\r\naddr_set = ide_get_lba_addr(&cmd, lba48) + 1;\r\nreturn addr_set;\r\n}\r\nstatic unsigned long long sectors_to_MB(unsigned long long n)\r\n{\r\nn <<= 9;\r\ndo_div(n, 1000000);\r\nreturn n;\r\n}\r\nstatic u64 ide_disk_hpa_get_native_capacity(ide_drive_t *drive, int lba48)\r\n{\r\nu64 capacity, set_max;\r\ncapacity = drive->capacity64;\r\nset_max = idedisk_read_native_max_address(drive, lba48);\r\nif (ide_in_drive_list(drive->id, hpa_list)) {\r\nif (set_max == capacity + 1)\r\nset_max--;\r\n}\r\nreturn set_max;\r\n}\r\nstatic u64 ide_disk_hpa_set_capacity(ide_drive_t *drive, u64 set_max, int lba48)\r\n{\r\nset_max = idedisk_set_max_address(drive, set_max, lba48);\r\nif (set_max)\r\ndrive->capacity64 = set_max;\r\nreturn set_max;\r\n}\r\nstatic void idedisk_check_hpa(ide_drive_t *drive)\r\n{\r\nu64 capacity, set_max;\r\nint lba48 = ata_id_lba48_enabled(drive->id);\r\ncapacity = drive->capacity64;\r\nset_max = ide_disk_hpa_get_native_capacity(drive, lba48);\r\nif (set_max <= capacity)\r\nreturn;\r\ndrive->probed_capacity = set_max;\r\nprintk(KERN_INFO "%s: Host Protected Area detected.\n"\r\n"\tcurrent capacity is %llu sectors (%llu MB)\n"\r\n"\tnative capacity is %llu sectors (%llu MB)\n",\r\ndrive->name,\r\ncapacity, sectors_to_MB(capacity),\r\nset_max, sectors_to_MB(set_max));\r\nif ((drive->dev_flags & IDE_DFLAG_NOHPA) == 0)\r\nreturn;\r\nset_max = ide_disk_hpa_set_capacity(drive, set_max, lba48);\r\nif (set_max)\r\nprintk(KERN_INFO "%s: Host Protected Area disabled.\n",\r\ndrive->name);\r\n}\r\nstatic int ide_disk_get_capacity(ide_drive_t *drive)\r\n{\r\nu16 *id = drive->id;\r\nint lba;\r\nif (ata_id_lba48_enabled(id)) {\r\nlba = 1;\r\ndrive->capacity64 = ata_id_u64(id, ATA_ID_LBA_CAPACITY_2);\r\n} else if (ata_id_has_lba(id) && ata_id_is_lba_capacity_ok(id)) {\r\nlba = 1;\r\ndrive->capacity64 = ata_id_u32(id, ATA_ID_LBA_CAPACITY);\r\n} else {\r\nlba = 0;\r\ndrive->capacity64 = drive->cyl * drive->head * drive->sect;\r\n}\r\ndrive->probed_capacity = drive->capacity64;\r\nif (lba) {\r\ndrive->dev_flags |= IDE_DFLAG_LBA;\r\nif (ata_id_hpa_enabled(id))\r\nidedisk_check_hpa(drive);\r\n}\r\nif ((drive->dev_flags & IDE_DFLAG_LBA48) == 0 &&\r\ndrive->capacity64 > 1ULL << 28) {\r\nprintk(KERN_WARNING "%s: cannot use LBA48 - full capacity "\r\n"%llu sectors (%llu MB)\n",\r\ndrive->name, (unsigned long long)drive->capacity64,\r\nsectors_to_MB(drive->capacity64));\r\ndrive->probed_capacity = drive->capacity64 = 1ULL << 28;\r\n}\r\nif ((drive->hwif->host_flags & IDE_HFLAG_NO_LBA48_DMA) &&\r\n(drive->dev_flags & IDE_DFLAG_LBA48)) {\r\nif (drive->capacity64 > 1ULL << 28) {\r\nprintk(KERN_INFO "%s: cannot use LBA48 DMA - PIO mode"\r\n" will be used for accessing sectors "\r\n"> %u\n", drive->name, 1 << 28);\r\n} else\r\ndrive->dev_flags &= ~IDE_DFLAG_LBA48;\r\n}\r\nreturn 0;\r\n}\r\nstatic void ide_disk_unlock_native_capacity(ide_drive_t *drive)\r\n{\r\nu16 *id = drive->id;\r\nint lba48 = ata_id_lba48_enabled(id);\r\nif ((drive->dev_flags & IDE_DFLAG_LBA) == 0 ||\r\nata_id_hpa_enabled(id) == 0)\r\nreturn;\r\nif (!ide_disk_hpa_get_native_capacity(drive, lba48))\r\nreturn;\r\nif (ide_disk_hpa_set_capacity(drive, drive->probed_capacity, lba48))\r\ndrive->dev_flags |= IDE_DFLAG_NOHPA;\r\n}\r\nstatic int idedisk_prep_fn(struct request_queue *q, struct request *rq)\r\n{\r\nide_drive_t *drive = q->queuedata;\r\nstruct ide_cmd *cmd;\r\nif (!(rq->cmd_flags & REQ_FLUSH))\r\nreturn BLKPREP_OK;\r\nif (rq->special) {\r\ncmd = rq->special;\r\nmemset(cmd, 0, sizeof(*cmd));\r\n} else {\r\ncmd = kzalloc(sizeof(*cmd), GFP_ATOMIC);\r\n}\r\nBUG_ON(cmd == NULL);\r\nif (ata_id_flush_ext_enabled(drive->id) &&\r\n(drive->capacity64 >= (1UL << 28)))\r\ncmd->tf.command = ATA_CMD_FLUSH_EXT;\r\nelse\r\ncmd->tf.command = ATA_CMD_FLUSH;\r\ncmd->valid.out.tf = IDE_VALID_OUT_TF | IDE_VALID_DEVICE;\r\ncmd->tf_flags = IDE_TFLAG_DYN;\r\ncmd->protocol = ATA_PROT_NODATA;\r\nrq->cmd_type = REQ_TYPE_ATA_TASKFILE;\r\nrq->special = cmd;\r\ncmd->rq = rq;\r\nreturn BLKPREP_OK;\r\n}\r\nstatic int set_multcount(ide_drive_t *drive, int arg)\r\n{\r\nstruct request *rq;\r\nint error;\r\nif (arg < 0 || arg > (drive->id[ATA_ID_MAX_MULTSECT] & 0xff))\r\nreturn -EINVAL;\r\nif (drive->special_flags & IDE_SFLAG_SET_MULTMODE)\r\nreturn -EBUSY;\r\nrq = blk_get_request(drive->queue, READ, __GFP_RECLAIM);\r\nrq->cmd_type = REQ_TYPE_ATA_TASKFILE;\r\ndrive->mult_req = arg;\r\ndrive->special_flags |= IDE_SFLAG_SET_MULTMODE;\r\nerror = blk_execute_rq(drive->queue, NULL, rq, 0);\r\nblk_put_request(rq);\r\nreturn (drive->mult_count == arg) ? 0 : -EIO;\r\n}\r\nstatic int set_nowerr(ide_drive_t *drive, int arg)\r\n{\r\nif (arg < 0 || arg > 1)\r\nreturn -EINVAL;\r\nif (arg)\r\ndrive->dev_flags |= IDE_DFLAG_NOWERR;\r\nelse\r\ndrive->dev_flags &= ~IDE_DFLAG_NOWERR;\r\ndrive->bad_wstat = arg ? BAD_R_STAT : BAD_W_STAT;\r\nreturn 0;\r\n}\r\nstatic int ide_do_setfeature(ide_drive_t *drive, u8 feature, u8 nsect)\r\n{\r\nstruct ide_cmd cmd;\r\nmemset(&cmd, 0, sizeof(cmd));\r\ncmd.tf.feature = feature;\r\ncmd.tf.nsect = nsect;\r\ncmd.tf.command = ATA_CMD_SET_FEATURES;\r\ncmd.valid.out.tf = IDE_VALID_OUT_TF | IDE_VALID_DEVICE;\r\ncmd.valid.in.tf = IDE_VALID_IN_TF | IDE_VALID_DEVICE;\r\nreturn ide_no_data_taskfile(drive, &cmd);\r\n}\r\nstatic void update_flush(ide_drive_t *drive)\r\n{\r\nu16 *id = drive->id;\r\nunsigned flush = 0;\r\nif (drive->dev_flags & IDE_DFLAG_WCACHE) {\r\nunsigned long long capacity;\r\nint barrier;\r\ncapacity = ide_gd_capacity(drive);\r\nbarrier = ata_id_flush_enabled(id) &&\r\n(drive->dev_flags & IDE_DFLAG_NOFLUSH) == 0 &&\r\n((drive->dev_flags & IDE_DFLAG_LBA48) == 0 ||\r\ncapacity <= (1ULL << 28) ||\r\nata_id_flush_ext_enabled(id));\r\nprintk(KERN_INFO "%s: cache flushes %ssupported\n",\r\ndrive->name, barrier ? "" : "not ");\r\nif (barrier) {\r\nflush = REQ_FLUSH;\r\nblk_queue_prep_rq(drive->queue, idedisk_prep_fn);\r\n}\r\n}\r\nblk_queue_flush(drive->queue, flush);\r\n}\r\nstatic int set_wcache(ide_drive_t *drive, int arg)\r\n{\r\nint err = 1;\r\nif (arg < 0 || arg > 1)\r\nreturn -EINVAL;\r\nif (ata_id_flush_enabled(drive->id)) {\r\nerr = ide_do_setfeature(drive,\r\narg ? SETFEATURES_WC_ON : SETFEATURES_WC_OFF, 0);\r\nif (err == 0) {\r\nif (arg)\r\ndrive->dev_flags |= IDE_DFLAG_WCACHE;\r\nelse\r\ndrive->dev_flags &= ~IDE_DFLAG_WCACHE;\r\n}\r\n}\r\nupdate_flush(drive);\r\nreturn err;\r\n}\r\nstatic int do_idedisk_flushcache(ide_drive_t *drive)\r\n{\r\nstruct ide_cmd cmd;\r\nmemset(&cmd, 0, sizeof(cmd));\r\nif (ata_id_flush_ext_enabled(drive->id))\r\ncmd.tf.command = ATA_CMD_FLUSH_EXT;\r\nelse\r\ncmd.tf.command = ATA_CMD_FLUSH;\r\ncmd.valid.out.tf = IDE_VALID_OUT_TF | IDE_VALID_DEVICE;\r\ncmd.valid.in.tf = IDE_VALID_IN_TF | IDE_VALID_DEVICE;\r\nreturn ide_no_data_taskfile(drive, &cmd);\r\n}\r\nstatic int set_acoustic(ide_drive_t *drive, int arg)\r\n{\r\nif (arg < 0 || arg > 254)\r\nreturn -EINVAL;\r\nide_do_setfeature(drive,\r\narg ? SETFEATURES_AAM_ON : SETFEATURES_AAM_OFF, arg);\r\ndrive->acoustic = arg;\r\nreturn 0;\r\n}\r\nstatic int set_addressing(ide_drive_t *drive, int arg)\r\n{\r\nif (arg < 0 || arg > 2)\r\nreturn -EINVAL;\r\nif (arg && ((drive->hwif->host_flags & IDE_HFLAG_NO_LBA48) ||\r\nata_id_lba48_enabled(drive->id) == 0))\r\nreturn -EIO;\r\nif (arg == 2)\r\narg = 0;\r\nif (arg)\r\ndrive->dev_flags |= IDE_DFLAG_LBA48;\r\nelse\r\ndrive->dev_flags &= ~IDE_DFLAG_LBA48;\r\nreturn 0;\r\n}\r\nstatic int ide_disk_check(ide_drive_t *drive, const char *s)\r\n{\r\nreturn 1;\r\n}\r\nstatic void ide_disk_setup(ide_drive_t *drive)\r\n{\r\nstruct ide_disk_obj *idkp = drive->driver_data;\r\nstruct request_queue *q = drive->queue;\r\nide_hwif_t *hwif = drive->hwif;\r\nu16 *id = drive->id;\r\nchar *m = (char *)&id[ATA_ID_PROD];\r\nunsigned long long capacity;\r\nide_proc_register_driver(drive, idkp->driver);\r\nif ((drive->dev_flags & IDE_DFLAG_ID_READ) == 0)\r\nreturn;\r\nif (drive->dev_flags & IDE_DFLAG_REMOVABLE) {\r\nif (m[0] != 'W' || m[1] != 'D')\r\ndrive->dev_flags |= IDE_DFLAG_DOORLOCKING;\r\n}\r\n(void)set_addressing(drive, 1);\r\nif (drive->dev_flags & IDE_DFLAG_LBA48) {\r\nint max_s = 2048;\r\nif (max_s > hwif->rqsize)\r\nmax_s = hwif->rqsize;\r\nblk_queue_max_hw_sectors(q, max_s);\r\n}\r\nprintk(KERN_INFO "%s: max request size: %dKiB\n", drive->name,\r\nqueue_max_sectors(q) / 2);\r\nif (ata_id_is_ssd(id)) {\r\nqueue_flag_set_unlocked(QUEUE_FLAG_NONROT, q);\r\nqueue_flag_clear_unlocked(QUEUE_FLAG_ADD_RANDOM, q);\r\n}\r\nide_disk_get_capacity(drive);\r\ncapacity = ide_gd_capacity(drive);\r\nif ((drive->dev_flags & IDE_DFLAG_FORCED_GEOM) == 0) {\r\nif (ata_id_lba48_enabled(drive->id)) {\r\ndrive->bios_sect = 63;\r\ndrive->bios_head = 255;\r\n}\r\nif (drive->bios_sect && drive->bios_head) {\r\nunsigned int cap0 = capacity;\r\nunsigned int cylsz, cyl;\r\nif (cap0 != capacity)\r\ndrive->bios_cyl = 65535;\r\nelse {\r\ncylsz = drive->bios_sect * drive->bios_head;\r\ncyl = cap0 / cylsz;\r\nif (cyl > 65535)\r\ncyl = 65535;\r\nif (cyl > drive->bios_cyl)\r\ndrive->bios_cyl = cyl;\r\n}\r\n}\r\n}\r\nprintk(KERN_INFO "%s: %llu sectors (%llu MB)",\r\ndrive->name, capacity, sectors_to_MB(capacity));\r\nif (id[ATA_ID_BUF_SIZE])\r\nprintk(KERN_CONT " w/%dKiB Cache", id[ATA_ID_BUF_SIZE] / 2);\r\nprintk(KERN_CONT ", CHS=%d/%d/%d\n",\r\ndrive->bios_cyl, drive->bios_head, drive->bios_sect);\r\nif ((id[ATA_ID_CSFO] & 1) || ata_id_wcache_enabled(id))\r\ndrive->dev_flags |= IDE_DFLAG_WCACHE;\r\nset_wcache(drive, 1);\r\nif ((drive->dev_flags & IDE_DFLAG_LBA) == 0 &&\r\n(drive->head == 0 || drive->head > 16)) {\r\nprintk(KERN_ERR "%s: invalid geometry: %d physical heads?\n",\r\ndrive->name, drive->head);\r\ndrive->dev_flags &= ~IDE_DFLAG_ATTACH;\r\n} else\r\ndrive->dev_flags |= IDE_DFLAG_ATTACH;\r\n}\r\nstatic void ide_disk_flush(ide_drive_t *drive)\r\n{\r\nif (ata_id_flush_enabled(drive->id) == 0 ||\r\n(drive->dev_flags & IDE_DFLAG_WCACHE) == 0)\r\nreturn;\r\nif (do_idedisk_flushcache(drive))\r\nprintk(KERN_INFO "%s: wcache flush failed!\n", drive->name);\r\n}\r\nstatic int ide_disk_init_media(ide_drive_t *drive, struct gendisk *disk)\r\n{\r\nreturn 0;\r\n}\r\nstatic int ide_disk_set_doorlock(ide_drive_t *drive, struct gendisk *disk,\r\nint on)\r\n{\r\nstruct ide_cmd cmd;\r\nint ret;\r\nif ((drive->dev_flags & IDE_DFLAG_DOORLOCKING) == 0)\r\nreturn 0;\r\nmemset(&cmd, 0, sizeof(cmd));\r\ncmd.tf.command = on ? ATA_CMD_MEDIA_LOCK : ATA_CMD_MEDIA_UNLOCK;\r\ncmd.valid.out.tf = IDE_VALID_OUT_TF | IDE_VALID_DEVICE;\r\ncmd.valid.in.tf = IDE_VALID_IN_TF | IDE_VALID_DEVICE;\r\nret = ide_no_data_taskfile(drive, &cmd);\r\nif (ret)\r\ndrive->dev_flags &= ~IDE_DFLAG_DOORLOCKING;\r\nreturn ret;\r\n}
