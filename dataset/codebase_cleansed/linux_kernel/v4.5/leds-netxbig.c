static void gpio_ext_set_addr(struct netxbig_gpio_ext *gpio_ext, int addr)\r\n{\r\nint pin;\r\nfor (pin = 0; pin < gpio_ext->num_addr; pin++)\r\ngpio_set_value(gpio_ext->addr[pin], (addr >> pin) & 1);\r\n}\r\nstatic void gpio_ext_set_data(struct netxbig_gpio_ext *gpio_ext, int data)\r\n{\r\nint pin;\r\nfor (pin = 0; pin < gpio_ext->num_data; pin++)\r\ngpio_set_value(gpio_ext->data[pin], (data >> pin) & 1);\r\n}\r\nstatic void gpio_ext_enable_select(struct netxbig_gpio_ext *gpio_ext)\r\n{\r\ngpio_set_value(gpio_ext->enable, 0);\r\ngpio_set_value(gpio_ext->enable, 1);\r\n}\r\nstatic void gpio_ext_set_value(struct netxbig_gpio_ext *gpio_ext,\r\nint addr, int value)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&gpio_ext_lock, flags);\r\ngpio_ext_set_addr(gpio_ext, addr);\r\ngpio_ext_set_data(gpio_ext, value);\r\ngpio_ext_enable_select(gpio_ext);\r\nspin_unlock_irqrestore(&gpio_ext_lock, flags);\r\n}\r\nstatic int gpio_ext_init(struct platform_device *pdev,\r\nstruct netxbig_gpio_ext *gpio_ext)\r\n{\r\nint err;\r\nint i;\r\nif (unlikely(!gpio_ext))\r\nreturn -EINVAL;\r\nfor (i = 0; i < gpio_ext->num_addr; i++) {\r\nerr = devm_gpio_request_one(&pdev->dev, gpio_ext->addr[i],\r\nGPIOF_OUT_INIT_LOW,\r\n"GPIO extension addr");\r\nif (err)\r\nreturn err;\r\n}\r\nfor (i = 0; i < gpio_ext->num_data; i++) {\r\nerr = devm_gpio_request_one(&pdev->dev, gpio_ext->data[i],\r\nGPIOF_OUT_INIT_LOW,\r\n"GPIO extension data");\r\nif (err)\r\nreturn err;\r\n}\r\nerr = devm_gpio_request_one(&pdev->dev, gpio_ext->enable,\r\nGPIOF_OUT_INIT_LOW,\r\n"GPIO extension enable");\r\nif (err)\r\nreturn err;\r\nreturn 0;\r\n}\r\nstatic int netxbig_led_get_timer_mode(enum netxbig_led_mode *mode,\r\nunsigned long delay_on,\r\nunsigned long delay_off,\r\nstruct netxbig_led_timer *timer,\r\nint num_timer)\r\n{\r\nint i;\r\nfor (i = 0; i < num_timer; i++) {\r\nif (timer[i].delay_on == delay_on &&\r\ntimer[i].delay_off == delay_off) {\r\n*mode = timer[i].mode;\r\nreturn 0;\r\n}\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int netxbig_led_blink_set(struct led_classdev *led_cdev,\r\nunsigned long *delay_on,\r\nunsigned long *delay_off)\r\n{\r\nstruct netxbig_led_data *led_dat =\r\ncontainer_of(led_cdev, struct netxbig_led_data, cdev);\r\nenum netxbig_led_mode mode;\r\nint mode_val;\r\nint ret;\r\nret = netxbig_led_get_timer_mode(&mode, *delay_on, *delay_off,\r\nled_dat->timer, led_dat->num_timer);\r\nif (ret < 0)\r\nreturn ret;\r\nmode_val = led_dat->mode_val[mode];\r\nif (mode_val == NETXBIG_LED_INVALID_MODE)\r\nreturn -EINVAL;\r\nspin_lock_irq(&led_dat->lock);\r\ngpio_ext_set_value(led_dat->gpio_ext, led_dat->mode_addr, mode_val);\r\nled_dat->mode = mode;\r\nspin_unlock_irq(&led_dat->lock);\r\nreturn 0;\r\n}\r\nstatic void netxbig_led_set(struct led_classdev *led_cdev,\r\nenum led_brightness value)\r\n{\r\nstruct netxbig_led_data *led_dat =\r\ncontainer_of(led_cdev, struct netxbig_led_data, cdev);\r\nenum netxbig_led_mode mode;\r\nint mode_val;\r\nint set_brightness = 1;\r\nunsigned long flags;\r\nspin_lock_irqsave(&led_dat->lock, flags);\r\nif (value == LED_OFF) {\r\nmode = NETXBIG_LED_OFF;\r\nset_brightness = 0;\r\n} else {\r\nif (led_dat->sata)\r\nmode = NETXBIG_LED_SATA;\r\nelse if (led_dat->mode == NETXBIG_LED_OFF)\r\nmode = NETXBIG_LED_ON;\r\nelse\r\nmode = led_dat->mode;\r\n}\r\nmode_val = led_dat->mode_val[mode];\r\ngpio_ext_set_value(led_dat->gpio_ext, led_dat->mode_addr, mode_val);\r\nled_dat->mode = mode;\r\nif (set_brightness)\r\ngpio_ext_set_value(led_dat->gpio_ext,\r\nled_dat->bright_addr, value);\r\nspin_unlock_irqrestore(&led_dat->lock, flags);\r\n}\r\nstatic ssize_t netxbig_led_sata_store(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buff, size_t count)\r\n{\r\nstruct led_classdev *led_cdev = dev_get_drvdata(dev);\r\nstruct netxbig_led_data *led_dat =\r\ncontainer_of(led_cdev, struct netxbig_led_data, cdev);\r\nunsigned long enable;\r\nenum netxbig_led_mode mode;\r\nint mode_val;\r\nint ret;\r\nret = kstrtoul(buff, 10, &enable);\r\nif (ret < 0)\r\nreturn ret;\r\nenable = !!enable;\r\nspin_lock_irq(&led_dat->lock);\r\nif (led_dat->sata == enable) {\r\nret = count;\r\ngoto exit_unlock;\r\n}\r\nif (led_dat->mode != NETXBIG_LED_ON &&\r\nled_dat->mode != NETXBIG_LED_SATA)\r\nmode = led_dat->mode;\r\nelse if (enable)\r\nmode = NETXBIG_LED_SATA;\r\nelse\r\nmode = NETXBIG_LED_ON;\r\nmode_val = led_dat->mode_val[mode];\r\nif (mode_val == NETXBIG_LED_INVALID_MODE) {\r\nret = -EINVAL;\r\ngoto exit_unlock;\r\n}\r\ngpio_ext_set_value(led_dat->gpio_ext, led_dat->mode_addr, mode_val);\r\nled_dat->mode = mode;\r\nled_dat->sata = enable;\r\nret = count;\r\nexit_unlock:\r\nspin_unlock_irq(&led_dat->lock);\r\nreturn ret;\r\n}\r\nstatic ssize_t netxbig_led_sata_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct led_classdev *led_cdev = dev_get_drvdata(dev);\r\nstruct netxbig_led_data *led_dat =\r\ncontainer_of(led_cdev, struct netxbig_led_data, cdev);\r\nreturn sprintf(buf, "%d\n", led_dat->sata);\r\n}\r\nstatic int create_netxbig_led(struct platform_device *pdev,\r\nstruct netxbig_led_platform_data *pdata,\r\nstruct netxbig_led_data *led_dat,\r\nconst struct netxbig_led *template)\r\n{\r\nspin_lock_init(&led_dat->lock);\r\nled_dat->gpio_ext = pdata->gpio_ext;\r\nled_dat->cdev.name = template->name;\r\nled_dat->cdev.default_trigger = template->default_trigger;\r\nled_dat->cdev.blink_set = netxbig_led_blink_set;\r\nled_dat->cdev.brightness_set = netxbig_led_set;\r\nled_dat->sata = 0;\r\nled_dat->cdev.brightness = LED_OFF;\r\nled_dat->cdev.max_brightness = template->bright_max;\r\nled_dat->cdev.flags |= LED_CORE_SUSPENDRESUME;\r\nled_dat->mode_addr = template->mode_addr;\r\nled_dat->mode_val = template->mode_val;\r\nled_dat->bright_addr = template->bright_addr;\r\nled_dat->timer = pdata->timer;\r\nled_dat->num_timer = pdata->num_timer;\r\nif (led_dat->mode_val[NETXBIG_LED_SATA] != NETXBIG_LED_INVALID_MODE)\r\nled_dat->cdev.groups = netxbig_led_groups;\r\nreturn devm_led_classdev_register(&pdev->dev, &led_dat->cdev);\r\n}\r\nstatic int gpio_ext_get_of_pdata(struct device *dev, struct device_node *np,\r\nstruct netxbig_gpio_ext *gpio_ext)\r\n{\r\nint *addr, *data;\r\nint num_addr, num_data;\r\nint ret;\r\nint i;\r\nret = of_gpio_named_count(np, "addr-gpios");\r\nif (ret < 0) {\r\ndev_err(dev,\r\n"Failed to count GPIOs in DT property addr-gpios\n");\r\nreturn ret;\r\n}\r\nnum_addr = ret;\r\naddr = devm_kzalloc(dev, num_addr * sizeof(*addr), GFP_KERNEL);\r\nif (!addr)\r\nreturn -ENOMEM;\r\nfor (i = 0; i < num_addr; i++) {\r\nret = of_get_named_gpio(np, "addr-gpios", i);\r\nif (ret < 0)\r\nreturn ret;\r\naddr[i] = ret;\r\n}\r\ngpio_ext->addr = addr;\r\ngpio_ext->num_addr = num_addr;\r\nret = of_gpio_named_count(np, "data-gpios");\r\nif (ret < 0) {\r\ndev_err(dev,\r\n"Failed to count GPIOs in DT property data-gpios\n");\r\nreturn ret;\r\n}\r\nnum_data = ret;\r\ndata = devm_kzalloc(dev, num_data * sizeof(*data), GFP_KERNEL);\r\nif (!data)\r\nreturn -ENOMEM;\r\nfor (i = 0; i < num_data; i++) {\r\nret = of_get_named_gpio(np, "data-gpios", i);\r\nif (ret < 0)\r\nreturn ret;\r\ndata[i] = ret;\r\n}\r\ngpio_ext->data = data;\r\ngpio_ext->num_data = num_data;\r\nret = of_get_named_gpio(np, "enable-gpio", 0);\r\nif (ret < 0) {\r\ndev_err(dev,\r\n"Failed to get GPIO from DT property enable-gpio\n");\r\nreturn ret;\r\n}\r\ngpio_ext->enable = ret;\r\nreturn 0;\r\n}\r\nstatic int netxbig_leds_get_of_pdata(struct device *dev,\r\nstruct netxbig_led_platform_data *pdata)\r\n{\r\nstruct device_node *np = dev->of_node;\r\nstruct device_node *gpio_ext_np;\r\nstruct device_node *child;\r\nstruct netxbig_gpio_ext *gpio_ext;\r\nstruct netxbig_led_timer *timers;\r\nstruct netxbig_led *leds, *led;\r\nint num_timers;\r\nint num_leds = 0;\r\nint ret;\r\nint i;\r\ngpio_ext_np = of_parse_phandle(np, "gpio-ext", 0);\r\nif (!gpio_ext_np) {\r\ndev_err(dev, "Failed to get DT handle gpio-ext\n");\r\nreturn -EINVAL;\r\n}\r\ngpio_ext = devm_kzalloc(dev, sizeof(*gpio_ext), GFP_KERNEL);\r\nif (!gpio_ext)\r\nreturn -ENOMEM;\r\nret = gpio_ext_get_of_pdata(dev, gpio_ext_np, gpio_ext);\r\nif (ret)\r\nreturn ret;\r\nof_node_put(gpio_ext_np);\r\npdata->gpio_ext = gpio_ext;\r\nret = of_property_count_u32_elems(np, "timers");\r\nif (ret > 0) {\r\nif (ret % 3)\r\nreturn -EINVAL;\r\nnum_timers = ret / 3;\r\ntimers = devm_kzalloc(dev, num_timers * sizeof(*timers),\r\nGFP_KERNEL);\r\nif (!timers)\r\nreturn -ENOMEM;\r\nfor (i = 0; i < num_timers; i++) {\r\nu32 tmp;\r\nof_property_read_u32_index(np, "timers", 3 * i,\r\n&timers[i].mode);\r\nif (timers[i].mode >= NETXBIG_LED_MODE_NUM)\r\nreturn -EINVAL;\r\nof_property_read_u32_index(np, "timers",\r\n3 * i + 1, &tmp);\r\ntimers[i].delay_on = tmp;\r\nof_property_read_u32_index(np, "timers",\r\n3 * i + 2, &tmp);\r\ntimers[i].delay_off = tmp;\r\n}\r\npdata->timer = timers;\r\npdata->num_timer = num_timers;\r\n}\r\nnum_leds = of_get_child_count(np);\r\nif (!num_leds) {\r\ndev_err(dev, "No LED subnodes found in DT\n");\r\nreturn -ENODEV;\r\n}\r\nleds = devm_kzalloc(dev, num_leds * sizeof(*leds), GFP_KERNEL);\r\nif (!leds)\r\nreturn -ENOMEM;\r\nled = leds;\r\nfor_each_child_of_node(np, child) {\r\nconst char *string;\r\nint *mode_val;\r\nint num_modes;\r\nret = of_property_read_u32(child, "mode-addr",\r\n&led->mode_addr);\r\nif (ret)\r\ngoto err_node_put;\r\nret = of_property_read_u32(child, "bright-addr",\r\n&led->bright_addr);\r\nif (ret)\r\ngoto err_node_put;\r\nret = of_property_read_u32(child, "max-brightness",\r\n&led->bright_max);\r\nif (ret)\r\ngoto err_node_put;\r\nmode_val =\r\ndevm_kzalloc(dev,\r\nNETXBIG_LED_MODE_NUM * sizeof(*mode_val),\r\nGFP_KERNEL);\r\nif (!mode_val) {\r\nret = -ENOMEM;\r\ngoto err_node_put;\r\n}\r\nfor (i = 0; i < NETXBIG_LED_MODE_NUM; i++)\r\nmode_val[i] = NETXBIG_LED_INVALID_MODE;\r\nret = of_property_count_u32_elems(child, "mode-val");\r\nif (ret < 0 || ret % 2) {\r\nret = -EINVAL;\r\ngoto err_node_put;\r\n}\r\nnum_modes = ret / 2;\r\nif (num_modes > NETXBIG_LED_MODE_NUM) {\r\nret = -EINVAL;\r\ngoto err_node_put;\r\n}\r\nfor (i = 0; i < num_modes; i++) {\r\nint mode;\r\nint val;\r\nof_property_read_u32_index(child,\r\n"mode-val", 2 * i, &mode);\r\nof_property_read_u32_index(child,\r\n"mode-val", 2 * i + 1, &val);\r\nif (mode >= NETXBIG_LED_MODE_NUM) {\r\nret = -EINVAL;\r\ngoto err_node_put;\r\n}\r\nmode_val[mode] = val;\r\n}\r\nled->mode_val = mode_val;\r\nif (!of_property_read_string(child, "label", &string))\r\nled->name = string;\r\nelse\r\nled->name = child->name;\r\nif (!of_property_read_string(child,\r\n"linux,default-trigger", &string))\r\nled->default_trigger = string;\r\nled++;\r\n}\r\npdata->leds = leds;\r\npdata->num_leds = num_leds;\r\nreturn 0;\r\nerr_node_put:\r\nof_node_put(child);\r\nreturn ret;\r\n}\r\nstatic inline int\r\nnetxbig_leds_get_of_pdata(struct device *dev,\r\nstruct netxbig_led_platform_data *pdata)\r\n{\r\nreturn -ENODEV;\r\n}\r\nstatic int netxbig_led_probe(struct platform_device *pdev)\r\n{\r\nstruct netxbig_led_platform_data *pdata = dev_get_platdata(&pdev->dev);\r\nstruct netxbig_led_data *leds_data;\r\nint i;\r\nint ret;\r\nif (!pdata) {\r\npdata = devm_kzalloc(&pdev->dev, sizeof(*pdata), GFP_KERNEL);\r\nif (!pdata)\r\nreturn -ENOMEM;\r\nret = netxbig_leds_get_of_pdata(&pdev->dev, pdata);\r\nif (ret)\r\nreturn ret;\r\n}\r\nleds_data = devm_kzalloc(&pdev->dev,\r\npdata->num_leds * sizeof(*leds_data),\r\nGFP_KERNEL);\r\nif (!leds_data)\r\nreturn -ENOMEM;\r\nret = gpio_ext_init(pdev, pdata->gpio_ext);\r\nif (ret < 0)\r\nreturn ret;\r\nfor (i = 0; i < pdata->num_leds; i++) {\r\nret = create_netxbig_led(pdev, pdata,\r\n&leds_data[i], &pdata->leds[i]);\r\nif (ret < 0)\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}
