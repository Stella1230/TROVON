static int sr_read_cmd(struct usbnet *dev, u8 cmd, u16 value, u16 index,\r\nu16 size, void *data)\r\n{\r\nint err;\r\nerr = usbnet_read_cmd(dev, cmd, SR_REQ_RD_REG, value, index,\r\ndata, size);\r\nif ((err != size) && (err >= 0))\r\nerr = -EINVAL;\r\nreturn err;\r\n}\r\nstatic int sr_write_cmd(struct usbnet *dev, u8 cmd, u16 value, u16 index,\r\nu16 size, void *data)\r\n{\r\nint err;\r\nerr = usbnet_write_cmd(dev, cmd, SR_REQ_WR_REG, value, index,\r\ndata, size);\r\nif ((err != size) && (err >= 0))\r\nerr = -EINVAL;\r\nreturn err;\r\n}\r\nstatic void\r\nsr_write_cmd_async(struct usbnet *dev, u8 cmd, u16 value, u16 index,\r\nu16 size, void *data)\r\n{\r\nusbnet_write_cmd_async(dev, cmd, SR_REQ_WR_REG, value, index, data,\r\nsize);\r\n}\r\nstatic int sr_rx_fixup(struct usbnet *dev, struct sk_buff *skb)\r\n{\r\nint offset = 0;\r\nif (skb->len < dev->net->hard_header_len)\r\nreturn 0;\r\nwhile (offset + sizeof(u32) < skb->len) {\r\nstruct sk_buff *sr_skb;\r\nu16 size;\r\nu32 header = get_unaligned_le32(skb->data + offset);\r\noffset += sizeof(u32);\r\nsize = (u16) (header & 0x7ff);\r\nif (size != ((~header >> 16) & 0x07ff)) {\r\nnetdev_err(dev->net, "%s : Bad Header Length\n",\r\n__func__);\r\nreturn 0;\r\n}\r\nif ((size > dev->net->mtu + ETH_HLEN + VLAN_HLEN) ||\r\n(size + offset > skb->len)) {\r\nnetdev_err(dev->net, "%s : Bad RX Length %d\n",\r\n__func__, size);\r\nreturn 0;\r\n}\r\nsr_skb = netdev_alloc_skb_ip_align(dev->net, size);\r\nif (!sr_skb)\r\nreturn 0;\r\nskb_put(sr_skb, size);\r\nmemcpy(sr_skb->data, skb->data + offset, size);\r\nusbnet_skb_return(dev, sr_skb);\r\noffset += (size + 1) & 0xfffe;\r\n}\r\nif (skb->len != offset) {\r\nnetdev_err(dev->net, "%s : Bad SKB Length %d\n", __func__,\r\nskb->len);\r\nreturn 0;\r\n}\r\nreturn 1;\r\n}\r\nstatic struct sk_buff *sr_tx_fixup(struct usbnet *dev, struct sk_buff *skb,\r\ngfp_t flags)\r\n{\r\nint headroom = skb_headroom(skb);\r\nint tailroom = skb_tailroom(skb);\r\nu32 padbytes = 0xffff0000;\r\nu32 packet_len;\r\nint padlen;\r\npadlen = ((skb->len + 4) % (dev->maxpacket - 1)) ? 0 : 4;\r\nif ((!skb_cloned(skb)) && ((headroom + tailroom) >= (4 + padlen))) {\r\nif ((headroom < 4) || (tailroom < padlen)) {\r\nskb->data = memmove(skb->head + 4, skb->data,\r\nskb->len);\r\nskb_set_tail_pointer(skb, skb->len);\r\n}\r\n} else {\r\nstruct sk_buff *skb2;\r\nskb2 = skb_copy_expand(skb, 4, padlen, flags);\r\ndev_kfree_skb_any(skb);\r\nskb = skb2;\r\nif (!skb)\r\nreturn NULL;\r\n}\r\nskb_push(skb, 4);\r\npacket_len = (((skb->len - 4) ^ 0x0000ffff) << 16) + (skb->len - 4);\r\ncpu_to_le32s(&packet_len);\r\nskb_copy_to_linear_data(skb, &packet_len, sizeof(packet_len));\r\nif (padlen) {\r\ncpu_to_le32s(&padbytes);\r\nmemcpy(skb_tail_pointer(skb), &padbytes, sizeof(padbytes));\r\nskb_put(skb, sizeof(padbytes));\r\n}\r\nusbnet_set_skb_tx_stats(skb, 1, 0);\r\nreturn skb;\r\n}\r\nstatic void sr_status(struct usbnet *dev, struct urb *urb)\r\n{\r\nstruct sr9800_int_data *event;\r\nint link;\r\nif (urb->actual_length < 8)\r\nreturn;\r\nevent = urb->transfer_buffer;\r\nlink = event->link & 0x01;\r\nif (netif_carrier_ok(dev->net) != link) {\r\nusbnet_link_change(dev, link, 1);\r\nnetdev_dbg(dev->net, "Link Status is: %d\n", link);\r\n}\r\nreturn;\r\n}\r\nstatic inline int sr_set_sw_mii(struct usbnet *dev)\r\n{\r\nint ret;\r\nret = sr_write_cmd(dev, SR_CMD_SET_SW_MII, 0x0000, 0, 0, NULL);\r\nif (ret < 0)\r\nnetdev_err(dev->net, "Failed to enable software MII access\n");\r\nreturn ret;\r\n}\r\nstatic inline int sr_set_hw_mii(struct usbnet *dev)\r\n{\r\nint ret;\r\nret = sr_write_cmd(dev, SR_CMD_SET_HW_MII, 0x0000, 0, 0, NULL);\r\nif (ret < 0)\r\nnetdev_err(dev->net, "Failed to enable hardware MII access\n");\r\nreturn ret;\r\n}\r\nstatic inline int sr_get_phy_addr(struct usbnet *dev)\r\n{\r\nu8 buf[2];\r\nint ret;\r\nret = sr_read_cmd(dev, SR_CMD_READ_PHY_ID, 0, 0, 2, buf);\r\nif (ret < 0) {\r\nnetdev_err(dev->net, "%s : Error reading PHYID register:%02x\n",\r\n__func__, ret);\r\ngoto out;\r\n}\r\nnetdev_dbg(dev->net, "%s : returning 0x%04x\n", __func__,\r\n*((__le16 *)buf));\r\nret = buf[1];\r\nout:\r\nreturn ret;\r\n}\r\nstatic int sr_sw_reset(struct usbnet *dev, u8 flags)\r\n{\r\nint ret;\r\nret = sr_write_cmd(dev, SR_CMD_SW_RESET, flags, 0, 0, NULL);\r\nif (ret < 0)\r\nnetdev_err(dev->net, "Failed to send software reset:%02x\n",\r\nret);\r\nreturn ret;\r\n}\r\nstatic u16 sr_read_rx_ctl(struct usbnet *dev)\r\n{\r\n__le16 v;\r\nint ret;\r\nret = sr_read_cmd(dev, SR_CMD_READ_RX_CTL, 0, 0, 2, &v);\r\nif (ret < 0) {\r\nnetdev_err(dev->net, "Error reading RX_CTL register:%02x\n",\r\nret);\r\ngoto out;\r\n}\r\nret = le16_to_cpu(v);\r\nout:\r\nreturn ret;\r\n}\r\nstatic int sr_write_rx_ctl(struct usbnet *dev, u16 mode)\r\n{\r\nint ret;\r\nnetdev_dbg(dev->net, "%s : mode = 0x%04x\n", __func__, mode);\r\nret = sr_write_cmd(dev, SR_CMD_WRITE_RX_CTL, mode, 0, 0, NULL);\r\nif (ret < 0)\r\nnetdev_err(dev->net,\r\n"Failed to write RX_CTL mode to 0x%04x:%02x\n",\r\nmode, ret);\r\nreturn ret;\r\n}\r\nstatic u16 sr_read_medium_status(struct usbnet *dev)\r\n{\r\n__le16 v;\r\nint ret;\r\nret = sr_read_cmd(dev, SR_CMD_READ_MEDIUM_STATUS, 0, 0, 2, &v);\r\nif (ret < 0) {\r\nnetdev_err(dev->net,\r\n"Error reading Medium Status register:%02x\n", ret);\r\nreturn ret;\r\n}\r\nreturn le16_to_cpu(v);\r\n}\r\nstatic int sr_write_medium_mode(struct usbnet *dev, u16 mode)\r\n{\r\nint ret;\r\nnetdev_dbg(dev->net, "%s : mode = 0x%04x\n", __func__, mode);\r\nret = sr_write_cmd(dev, SR_CMD_WRITE_MEDIUM_MODE, mode, 0, 0, NULL);\r\nif (ret < 0)\r\nnetdev_err(dev->net,\r\n"Failed to write Medium Mode mode to 0x%04x:%02x\n",\r\nmode, ret);\r\nreturn ret;\r\n}\r\nstatic int sr_write_gpio(struct usbnet *dev, u16 value, int sleep)\r\n{\r\nint ret;\r\nnetdev_dbg(dev->net, "%s : value = 0x%04x\n", __func__, value);\r\nret = sr_write_cmd(dev, SR_CMD_WRITE_GPIOS, value, 0, 0, NULL);\r\nif (ret < 0)\r\nnetdev_err(dev->net, "Failed to write GPIO value 0x%04x:%02x\n",\r\nvalue, ret);\r\nif (sleep)\r\nmsleep(sleep);\r\nreturn ret;\r\n}\r\nstatic void sr_set_multicast(struct net_device *net)\r\n{\r\nstruct usbnet *dev = netdev_priv(net);\r\nstruct sr_data *data = (struct sr_data *)&dev->data;\r\nu16 rx_ctl = SR_DEFAULT_RX_CTL;\r\nif (net->flags & IFF_PROMISC) {\r\nrx_ctl |= SR_RX_CTL_PRO;\r\n} else if (net->flags & IFF_ALLMULTI ||\r\nnetdev_mc_count(net) > SR_MAX_MCAST) {\r\nrx_ctl |= SR_RX_CTL_AMALL;\r\n} else if (netdev_mc_empty(net)) {\r\n} else {\r\nstruct netdev_hw_addr *ha;\r\nu32 crc_bits;\r\nmemset(data->multi_filter, 0, SR_MCAST_FILTER_SIZE);\r\nnetdev_for_each_mc_addr(ha, net) {\r\ncrc_bits = ether_crc(ETH_ALEN, ha->addr) >> 26;\r\ndata->multi_filter[crc_bits >> 3] |=\r\n1 << (crc_bits & 7);\r\n}\r\nsr_write_cmd_async(dev, SR_CMD_WRITE_MULTI_FILTER, 0, 0,\r\nSR_MCAST_FILTER_SIZE, data->multi_filter);\r\nrx_ctl |= SR_RX_CTL_AM;\r\n}\r\nsr_write_cmd_async(dev, SR_CMD_WRITE_RX_CTL, rx_ctl, 0, 0, NULL);\r\n}\r\nstatic int sr_mdio_read(struct net_device *net, int phy_id, int loc)\r\n{\r\nstruct usbnet *dev = netdev_priv(net);\r\n__le16 res;\r\nmutex_lock(&dev->phy_mutex);\r\nsr_set_sw_mii(dev);\r\nsr_read_cmd(dev, SR_CMD_READ_MII_REG, phy_id, (__u16)loc, 2, &res);\r\nsr_set_hw_mii(dev);\r\nmutex_unlock(&dev->phy_mutex);\r\nnetdev_dbg(dev->net,\r\n"%s : phy_id=0x%02x, loc=0x%02x, returns=0x%04x\n", __func__,\r\nphy_id, loc, le16_to_cpu(res));\r\nreturn le16_to_cpu(res);\r\n}\r\nstatic void\r\nsr_mdio_write(struct net_device *net, int phy_id, int loc, int val)\r\n{\r\nstruct usbnet *dev = netdev_priv(net);\r\n__le16 res = cpu_to_le16(val);\r\nnetdev_dbg(dev->net,\r\n"%s : phy_id=0x%02x, loc=0x%02x, val=0x%04x\n", __func__,\r\nphy_id, loc, val);\r\nmutex_lock(&dev->phy_mutex);\r\nsr_set_sw_mii(dev);\r\nsr_write_cmd(dev, SR_CMD_WRITE_MII_REG, phy_id, (__u16)loc, 2, &res);\r\nsr_set_hw_mii(dev);\r\nmutex_unlock(&dev->phy_mutex);\r\n}\r\nstatic u32 sr_get_phyid(struct usbnet *dev)\r\n{\r\nint phy_reg;\r\nu32 phy_id;\r\nint i;\r\nfor (i = 0; i < 100; i++) {\r\nphy_reg = sr_mdio_read(dev->net, dev->mii.phy_id, MII_PHYSID1);\r\nif (phy_reg != 0 && phy_reg != 0xFFFF)\r\nbreak;\r\nmdelay(1);\r\n}\r\nif (phy_reg <= 0 || phy_reg == 0xFFFF)\r\nreturn 0;\r\nphy_id = (phy_reg & 0xffff) << 16;\r\nphy_reg = sr_mdio_read(dev->net, dev->mii.phy_id, MII_PHYSID2);\r\nif (phy_reg < 0)\r\nreturn 0;\r\nphy_id |= (phy_reg & 0xffff);\r\nreturn phy_id;\r\n}\r\nstatic void\r\nsr_get_wol(struct net_device *net, struct ethtool_wolinfo *wolinfo)\r\n{\r\nstruct usbnet *dev = netdev_priv(net);\r\nu8 opt;\r\nif (sr_read_cmd(dev, SR_CMD_READ_MONITOR_MODE, 0, 0, 1, &opt) < 0) {\r\nwolinfo->supported = 0;\r\nwolinfo->wolopts = 0;\r\nreturn;\r\n}\r\nwolinfo->supported = WAKE_PHY | WAKE_MAGIC;\r\nwolinfo->wolopts = 0;\r\nif (opt & SR_MONITOR_LINK)\r\nwolinfo->wolopts |= WAKE_PHY;\r\nif (opt & SR_MONITOR_MAGIC)\r\nwolinfo->wolopts |= WAKE_MAGIC;\r\n}\r\nstatic int\r\nsr_set_wol(struct net_device *net, struct ethtool_wolinfo *wolinfo)\r\n{\r\nstruct usbnet *dev = netdev_priv(net);\r\nu8 opt = 0;\r\nif (wolinfo->wolopts & WAKE_PHY)\r\nopt |= SR_MONITOR_LINK;\r\nif (wolinfo->wolopts & WAKE_MAGIC)\r\nopt |= SR_MONITOR_MAGIC;\r\nif (sr_write_cmd(dev, SR_CMD_WRITE_MONITOR_MODE,\r\nopt, 0, 0, NULL) < 0)\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\nstatic int sr_get_eeprom_len(struct net_device *net)\r\n{\r\nstruct usbnet *dev = netdev_priv(net);\r\nstruct sr_data *data = (struct sr_data *)&dev->data;\r\nreturn data->eeprom_len;\r\n}\r\nstatic int sr_get_eeprom(struct net_device *net,\r\nstruct ethtool_eeprom *eeprom, u8 *data)\r\n{\r\nstruct usbnet *dev = netdev_priv(net);\r\n__le16 *ebuf = (__le16 *)data;\r\nint ret;\r\nint i;\r\nif (eeprom->len % 2)\r\nreturn -EINVAL;\r\neeprom->magic = SR_EEPROM_MAGIC;\r\nfor (i = 0; i < eeprom->len / 2; i++) {\r\nret = sr_read_cmd(dev, SR_CMD_READ_EEPROM, eeprom->offset + i,\r\n0, 2, &ebuf[i]);\r\nif (ret < 0)\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic void sr_get_drvinfo(struct net_device *net,\r\nstruct ethtool_drvinfo *info)\r\n{\r\nusbnet_get_drvinfo(net, info);\r\nstrncpy(info->driver, DRIVER_NAME, sizeof(info->driver));\r\nstrncpy(info->version, DRIVER_VERSION, sizeof(info->version));\r\n}\r\nstatic u32 sr_get_link(struct net_device *net)\r\n{\r\nstruct usbnet *dev = netdev_priv(net);\r\nreturn mii_link_ok(&dev->mii);\r\n}\r\nstatic int sr_ioctl(struct net_device *net, struct ifreq *rq, int cmd)\r\n{\r\nstruct usbnet *dev = netdev_priv(net);\r\nreturn generic_mii_ioctl(&dev->mii, if_mii(rq), cmd, NULL);\r\n}\r\nstatic int sr_set_mac_address(struct net_device *net, void *p)\r\n{\r\nstruct usbnet *dev = netdev_priv(net);\r\nstruct sr_data *data = (struct sr_data *)&dev->data;\r\nstruct sockaddr *addr = p;\r\nif (netif_running(net))\r\nreturn -EBUSY;\r\nif (!is_valid_ether_addr(addr->sa_data))\r\nreturn -EADDRNOTAVAIL;\r\nmemcpy(net->dev_addr, addr->sa_data, ETH_ALEN);\r\nmemcpy(data->mac_addr, addr->sa_data, ETH_ALEN);\r\nsr_write_cmd_async(dev, SR_CMD_WRITE_NODE_ID, 0, 0, ETH_ALEN,\r\ndata->mac_addr);\r\nreturn 0;\r\n}\r\nstatic int sr9800_link_reset(struct usbnet *dev)\r\n{\r\nstruct ethtool_cmd ecmd = { .cmd = ETHTOOL_GSET };\r\nu16 mode;\r\nmii_check_media(&dev->mii, 1, 1);\r\nmii_ethtool_gset(&dev->mii, &ecmd);\r\nmode = SR9800_MEDIUM_DEFAULT;\r\nif (ethtool_cmd_speed(&ecmd) != SPEED_100)\r\nmode &= ~SR_MEDIUM_PS;\r\nif (ecmd.duplex != DUPLEX_FULL)\r\nmode &= ~SR_MEDIUM_FD;\r\nnetdev_dbg(dev->net, "%s : speed: %u duplex: %d mode: 0x%04x\n",\r\n__func__, ethtool_cmd_speed(&ecmd), ecmd.duplex, mode);\r\nsr_write_medium_mode(dev, mode);\r\nreturn 0;\r\n}\r\nstatic int sr9800_set_default_mode(struct usbnet *dev)\r\n{\r\nu16 rx_ctl;\r\nint ret;\r\nsr_mdio_write(dev->net, dev->mii.phy_id, MII_BMCR, BMCR_RESET);\r\nsr_mdio_write(dev->net, dev->mii.phy_id, MII_ADVERTISE,\r\nADVERTISE_ALL | ADVERTISE_CSMA);\r\nmii_nway_restart(&dev->mii);\r\nret = sr_write_medium_mode(dev, SR9800_MEDIUM_DEFAULT);\r\nif (ret < 0)\r\ngoto out;\r\nret = sr_write_cmd(dev, SR_CMD_WRITE_IPG012,\r\nSR9800_IPG0_DEFAULT | SR9800_IPG1_DEFAULT,\r\nSR9800_IPG2_DEFAULT, 0, NULL);\r\nif (ret < 0) {\r\nnetdev_dbg(dev->net, "Write IPG,IPG1,IPG2 failed: %d\n", ret);\r\ngoto out;\r\n}\r\nret = sr_write_rx_ctl(dev, SR_DEFAULT_RX_CTL);\r\nif (ret < 0)\r\ngoto out;\r\nrx_ctl = sr_read_rx_ctl(dev);\r\nnetdev_dbg(dev->net, "RX_CTL is 0x%04x after all initializations\n",\r\nrx_ctl);\r\nrx_ctl = sr_read_medium_status(dev);\r\nnetdev_dbg(dev->net, "Medium Status:0x%04x after all initializations\n",\r\nrx_ctl);\r\nreturn 0;\r\nout:\r\nreturn ret;\r\n}\r\nstatic int sr9800_reset(struct usbnet *dev)\r\n{\r\nstruct sr_data *data = (struct sr_data *)&dev->data;\r\nint ret, embd_phy;\r\nu16 rx_ctl;\r\nret = sr_write_gpio(dev,\r\nSR_GPIO_RSE | SR_GPIO_GPO_2 | SR_GPIO_GPO2EN, 5);\r\nif (ret < 0)\r\ngoto out;\r\nembd_phy = ((sr_get_phy_addr(dev) & 0x1f) == 0x10 ? 1 : 0);\r\nret = sr_write_cmd(dev, SR_CMD_SW_PHY_SELECT, embd_phy, 0, 0, NULL);\r\nif (ret < 0) {\r\nnetdev_dbg(dev->net, "Select PHY #1 failed: %d\n", ret);\r\ngoto out;\r\n}\r\nret = sr_sw_reset(dev, SR_SWRESET_IPPD | SR_SWRESET_PRL);\r\nif (ret < 0)\r\ngoto out;\r\nmsleep(150);\r\nret = sr_sw_reset(dev, SR_SWRESET_CLEAR);\r\nif (ret < 0)\r\ngoto out;\r\nmsleep(150);\r\nif (embd_phy) {\r\nret = sr_sw_reset(dev, SR_SWRESET_IPRL);\r\nif (ret < 0)\r\ngoto out;\r\n} else {\r\nret = sr_sw_reset(dev, SR_SWRESET_PRTE);\r\nif (ret < 0)\r\ngoto out;\r\n}\r\nmsleep(150);\r\nrx_ctl = sr_read_rx_ctl(dev);\r\nnetdev_dbg(dev->net, "RX_CTL is 0x%04x after software reset\n", rx_ctl);\r\nret = sr_write_rx_ctl(dev, 0x0000);\r\nif (ret < 0)\r\ngoto out;\r\nrx_ctl = sr_read_rx_ctl(dev);\r\nnetdev_dbg(dev->net, "RX_CTL is 0x%04x setting to 0x0000\n", rx_ctl);\r\nret = sr_sw_reset(dev, SR_SWRESET_PRL);\r\nif (ret < 0)\r\ngoto out;\r\nmsleep(150);\r\nret = sr_sw_reset(dev, SR_SWRESET_IPRL | SR_SWRESET_PRL);\r\nif (ret < 0)\r\ngoto out;\r\nmsleep(150);\r\nret = sr9800_set_default_mode(dev);\r\nif (ret < 0)\r\ngoto out;\r\nmemcpy(data->mac_addr, dev->net->dev_addr, ETH_ALEN);\r\nret = sr_write_cmd(dev, SR_CMD_WRITE_NODE_ID, 0, 0, ETH_ALEN,\r\ndata->mac_addr);\r\nif (ret < 0)\r\ngoto out;\r\nreturn 0;\r\nout:\r\nreturn ret;\r\n}\r\nstatic int sr9800_phy_powerup(struct usbnet *dev)\r\n{\r\nint ret;\r\nret = sr_sw_reset(dev, SR_SWRESET_IPPD | SR_SWRESET_IPRL);\r\nif (ret < 0) {\r\nnetdev_err(dev->net, "Failed to power down PHY : %d\n", ret);\r\nreturn ret;\r\n}\r\nmsleep(20);\r\nret = sr_sw_reset(dev, SR_SWRESET_IPRL);\r\nif (ret < 0) {\r\nnetdev_err(dev->net, "Failed to reset PHY: %d\n", ret);\r\nreturn ret;\r\n}\r\nmsleep(600);\r\nret = sr_sw_reset(dev, SR_SWRESET_CLEAR);\r\nif (ret < 0) {\r\nnetdev_err(dev->net, "Failed to power up PHY: %d\n", ret);\r\nreturn ret;\r\n}\r\nmsleep(20);\r\nret = sr_sw_reset(dev, SR_SWRESET_IPRL);\r\nif (ret < 0) {\r\nnetdev_err(dev->net, "Failed to reset PHY: %d\n", ret);\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic int sr9800_bind(struct usbnet *dev, struct usb_interface *intf)\r\n{\r\nstruct sr_data *data = (struct sr_data *)&dev->data;\r\nu16 led01_mux, led23_mux;\r\nint ret, embd_phy;\r\nu32 phyid;\r\nu16 rx_ctl;\r\ndata->eeprom_len = SR9800_EEPROM_LEN;\r\nusbnet_get_endpoints(dev, intf);\r\nled01_mux = (SR_LED_MUX_LINK_ACTIVE << 8) | SR_LED_MUX_LINK;\r\nled23_mux = (SR_LED_MUX_LINK_ACTIVE << 8) | SR_LED_MUX_TX_ACTIVE;\r\nret = sr_write_cmd(dev, SR_CMD_LED_MUX, led01_mux, led23_mux, 0, NULL);\r\nif (ret < 0) {\r\nnetdev_err(dev->net, "set LINK LED failed : %d\n", ret);\r\ngoto out;\r\n}\r\nret = sr_read_cmd(dev, SR_CMD_READ_NODE_ID, 0, 0, ETH_ALEN,\r\ndev->net->dev_addr);\r\nif (ret < 0) {\r\nnetdev_dbg(dev->net, "Failed to read MAC address: %d\n", ret);\r\nreturn ret;\r\n}\r\nnetdev_dbg(dev->net, "mac addr : %pM\n", dev->net->dev_addr);\r\ndev->mii.dev = dev->net;\r\ndev->mii.mdio_read = sr_mdio_read;\r\ndev->mii.mdio_write = sr_mdio_write;\r\ndev->mii.phy_id_mask = 0x1f;\r\ndev->mii.reg_num_mask = 0x1f;\r\ndev->mii.phy_id = sr_get_phy_addr(dev);\r\ndev->net->netdev_ops = &sr9800_netdev_ops;\r\ndev->net->ethtool_ops = &sr9800_ethtool_ops;\r\nembd_phy = ((dev->mii.phy_id & 0x1f) == 0x10 ? 1 : 0);\r\nret = sr_write_cmd(dev, SR_CMD_SW_PHY_SELECT, embd_phy, 0, 0, NULL);\r\nif (ret < 0) {\r\nnetdev_dbg(dev->net, "Select PHY #1 failed: %d\n", ret);\r\nreturn ret;\r\n}\r\nret = sr9800_phy_powerup(dev);\r\nif (ret < 0)\r\ngoto out;\r\nrx_ctl = sr_read_rx_ctl(dev);\r\nnetdev_dbg(dev->net, "RX_CTL is 0x%04x after software reset\n", rx_ctl);\r\nret = sr_write_rx_ctl(dev, 0x0000);\r\nif (ret < 0)\r\ngoto out;\r\nrx_ctl = sr_read_rx_ctl(dev);\r\nnetdev_dbg(dev->net, "RX_CTL is 0x%04x setting to 0x0000\n", rx_ctl);\r\nphyid = sr_get_phyid(dev);\r\nnetdev_dbg(dev->net, "PHYID=0x%08x\n", phyid);\r\nret = sr9800_set_default_mode(dev);\r\nif (ret < 0)\r\ngoto out;\r\nif (dev->udev->speed == USB_SPEED_HIGH) {\r\nret = sr_write_cmd(dev, SR_CMD_BULKIN_SIZE,\r\nSR9800_BULKIN_SIZE[SR9800_MAX_BULKIN_4K].byte_cnt,\r\nSR9800_BULKIN_SIZE[SR9800_MAX_BULKIN_4K].threshold,\r\n0, NULL);\r\nif (ret < 0) {\r\nnetdev_err(dev->net, "Reset RX_CTL failed: %d\n", ret);\r\ngoto out;\r\n}\r\ndev->rx_urb_size =\r\nSR9800_BULKIN_SIZE[SR9800_MAX_BULKIN_4K].size;\r\n} else {\r\nret = sr_write_cmd(dev, SR_CMD_BULKIN_SIZE,\r\nSR9800_BULKIN_SIZE[SR9800_MAX_BULKIN_2K].byte_cnt,\r\nSR9800_BULKIN_SIZE[SR9800_MAX_BULKIN_2K].threshold,\r\n0, NULL);\r\nif (ret < 0) {\r\nnetdev_err(dev->net, "Reset RX_CTL failed: %d\n", ret);\r\ngoto out;\r\n}\r\ndev->rx_urb_size =\r\nSR9800_BULKIN_SIZE[SR9800_MAX_BULKIN_2K].size;\r\n}\r\nnetdev_dbg(dev->net, "%s : setting rx_urb_size with : %zu\n", __func__,\r\ndev->rx_urb_size);\r\nreturn 0;\r\nout:\r\nreturn ret;\r\n}
