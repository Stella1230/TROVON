static int tcf_nat_init(struct net *net, struct nlattr *nla, struct nlattr *est,\r\nstruct tc_action *a, int ovr, int bind)\r\n{\r\nstruct nlattr *tb[TCA_NAT_MAX + 1];\r\nstruct tc_nat *parm;\r\nint ret = 0, err;\r\nstruct tcf_nat *p;\r\nif (nla == NULL)\r\nreturn -EINVAL;\r\nerr = nla_parse_nested(tb, TCA_NAT_MAX, nla, nat_policy);\r\nif (err < 0)\r\nreturn err;\r\nif (tb[TCA_NAT_PARMS] == NULL)\r\nreturn -EINVAL;\r\nparm = nla_data(tb[TCA_NAT_PARMS]);\r\nif (!tcf_hash_check(parm->index, a, bind)) {\r\nret = tcf_hash_create(parm->index, est, a, sizeof(*p),\r\nbind, false);\r\nif (ret)\r\nreturn ret;\r\nret = ACT_P_CREATED;\r\n} else {\r\nif (bind)\r\nreturn 0;\r\ntcf_hash_release(a, bind);\r\nif (!ovr)\r\nreturn -EEXIST;\r\n}\r\np = to_tcf_nat(a);\r\nspin_lock_bh(&p->tcf_lock);\r\np->old_addr = parm->old_addr;\r\np->new_addr = parm->new_addr;\r\np->mask = parm->mask;\r\np->flags = parm->flags;\r\np->tcf_action = parm->action;\r\nspin_unlock_bh(&p->tcf_lock);\r\nif (ret == ACT_P_CREATED)\r\ntcf_hash_insert(a);\r\nreturn ret;\r\n}\r\nstatic int tcf_nat(struct sk_buff *skb, const struct tc_action *a,\r\nstruct tcf_result *res)\r\n{\r\nstruct tcf_nat *p = a->priv;\r\nstruct iphdr *iph;\r\n__be32 old_addr;\r\n__be32 new_addr;\r\n__be32 mask;\r\n__be32 addr;\r\nint egress;\r\nint action;\r\nint ihl;\r\nint noff;\r\nspin_lock(&p->tcf_lock);\r\np->tcf_tm.lastuse = jiffies;\r\nold_addr = p->old_addr;\r\nnew_addr = p->new_addr;\r\nmask = p->mask;\r\negress = p->flags & TCA_NAT_FLAG_EGRESS;\r\naction = p->tcf_action;\r\nbstats_update(&p->tcf_bstats, skb);\r\nspin_unlock(&p->tcf_lock);\r\nif (unlikely(action == TC_ACT_SHOT))\r\ngoto drop;\r\nnoff = skb_network_offset(skb);\r\nif (!pskb_may_pull(skb, sizeof(*iph) + noff))\r\ngoto drop;\r\niph = ip_hdr(skb);\r\nif (egress)\r\naddr = iph->saddr;\r\nelse\r\naddr = iph->daddr;\r\nif (!((old_addr ^ addr) & mask)) {\r\nif (skb_cloned(skb) &&\r\n!skb_clone_writable(skb, sizeof(*iph) + noff) &&\r\npskb_expand_head(skb, 0, 0, GFP_ATOMIC))\r\ngoto drop;\r\nnew_addr &= mask;\r\nnew_addr |= addr & ~mask;\r\niph = ip_hdr(skb);\r\nif (egress)\r\niph->saddr = new_addr;\r\nelse\r\niph->daddr = new_addr;\r\ncsum_replace4(&iph->check, addr, new_addr);\r\n} else if ((iph->frag_off & htons(IP_OFFSET)) ||\r\niph->protocol != IPPROTO_ICMP) {\r\ngoto out;\r\n}\r\nihl = iph->ihl * 4;\r\nswitch (iph->frag_off & htons(IP_OFFSET) ? 0 : iph->protocol) {\r\ncase IPPROTO_TCP:\r\n{\r\nstruct tcphdr *tcph;\r\nif (!pskb_may_pull(skb, ihl + sizeof(*tcph) + noff) ||\r\n(skb_cloned(skb) &&\r\n!skb_clone_writable(skb, ihl + sizeof(*tcph) + noff) &&\r\npskb_expand_head(skb, 0, 0, GFP_ATOMIC)))\r\ngoto drop;\r\ntcph = (void *)(skb_network_header(skb) + ihl);\r\ninet_proto_csum_replace4(&tcph->check, skb, addr, new_addr,\r\ntrue);\r\nbreak;\r\n}\r\ncase IPPROTO_UDP:\r\n{\r\nstruct udphdr *udph;\r\nif (!pskb_may_pull(skb, ihl + sizeof(*udph) + noff) ||\r\n(skb_cloned(skb) &&\r\n!skb_clone_writable(skb, ihl + sizeof(*udph) + noff) &&\r\npskb_expand_head(skb, 0, 0, GFP_ATOMIC)))\r\ngoto drop;\r\nudph = (void *)(skb_network_header(skb) + ihl);\r\nif (udph->check || skb->ip_summed == CHECKSUM_PARTIAL) {\r\ninet_proto_csum_replace4(&udph->check, skb, addr,\r\nnew_addr, true);\r\nif (!udph->check)\r\nudph->check = CSUM_MANGLED_0;\r\n}\r\nbreak;\r\n}\r\ncase IPPROTO_ICMP:\r\n{\r\nstruct icmphdr *icmph;\r\nif (!pskb_may_pull(skb, ihl + sizeof(*icmph) + noff))\r\ngoto drop;\r\nicmph = (void *)(skb_network_header(skb) + ihl);\r\nif ((icmph->type != ICMP_DEST_UNREACH) &&\r\n(icmph->type != ICMP_TIME_EXCEEDED) &&\r\n(icmph->type != ICMP_PARAMETERPROB))\r\nbreak;\r\nif (!pskb_may_pull(skb, ihl + sizeof(*icmph) + sizeof(*iph) +\r\nnoff))\r\ngoto drop;\r\nicmph = (void *)(skb_network_header(skb) + ihl);\r\niph = (void *)(icmph + 1);\r\nif (egress)\r\naddr = iph->daddr;\r\nelse\r\naddr = iph->saddr;\r\nif ((old_addr ^ addr) & mask)\r\nbreak;\r\nif (skb_cloned(skb) &&\r\n!skb_clone_writable(skb, ihl + sizeof(*icmph) +\r\nsizeof(*iph) + noff) &&\r\npskb_expand_head(skb, 0, 0, GFP_ATOMIC))\r\ngoto drop;\r\nicmph = (void *)(skb_network_header(skb) + ihl);\r\niph = (void *)(icmph + 1);\r\nnew_addr &= mask;\r\nnew_addr |= addr & ~mask;\r\nif (egress)\r\niph->daddr = new_addr;\r\nelse\r\niph->saddr = new_addr;\r\ninet_proto_csum_replace4(&icmph->checksum, skb, addr, new_addr,\r\nfalse);\r\nbreak;\r\n}\r\ndefault:\r\nbreak;\r\n}\r\nout:\r\nreturn action;\r\ndrop:\r\nspin_lock(&p->tcf_lock);\r\np->tcf_qstats.drops++;\r\nspin_unlock(&p->tcf_lock);\r\nreturn TC_ACT_SHOT;\r\n}\r\nstatic int tcf_nat_dump(struct sk_buff *skb, struct tc_action *a,\r\nint bind, int ref)\r\n{\r\nunsigned char *b = skb_tail_pointer(skb);\r\nstruct tcf_nat *p = a->priv;\r\nstruct tc_nat opt = {\r\n.old_addr = p->old_addr,\r\n.new_addr = p->new_addr,\r\n.mask = p->mask,\r\n.flags = p->flags,\r\n.index = p->tcf_index,\r\n.action = p->tcf_action,\r\n.refcnt = p->tcf_refcnt - ref,\r\n.bindcnt = p->tcf_bindcnt - bind,\r\n};\r\nstruct tcf_t t;\r\nif (nla_put(skb, TCA_NAT_PARMS, sizeof(opt), &opt))\r\ngoto nla_put_failure;\r\nt.install = jiffies_to_clock_t(jiffies - p->tcf_tm.install);\r\nt.lastuse = jiffies_to_clock_t(jiffies - p->tcf_tm.lastuse);\r\nt.expires = jiffies_to_clock_t(p->tcf_tm.expires);\r\nif (nla_put(skb, TCA_NAT_TM, sizeof(t), &t))\r\ngoto nla_put_failure;\r\nreturn skb->len;\r\nnla_put_failure:\r\nnlmsg_trim(skb, b);\r\nreturn -1;\r\n}\r\nstatic int __init nat_init_module(void)\r\n{\r\nreturn tcf_register_action(&act_nat_ops, NAT_TAB_MASK);\r\n}\r\nstatic void __exit nat_cleanup_module(void)\r\n{\r\ntcf_unregister_action(&act_nat_ops);\r\n}
