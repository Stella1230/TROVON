static inline void ssip_set_cmd(struct hsi_msg *msg, u32 cmd)\r\n{\r\nu32 *data;\r\ndata = sg_virt(msg->sgt.sgl);\r\n*data = cmd;\r\n}\r\nstatic inline u32 ssip_get_cmd(struct hsi_msg *msg)\r\n{\r\nu32 *data;\r\ndata = sg_virt(msg->sgt.sgl);\r\nreturn *data;\r\n}\r\nstatic void ssip_skb_to_msg(struct sk_buff *skb, struct hsi_msg *msg)\r\n{\r\nskb_frag_t *frag;\r\nstruct scatterlist *sg;\r\nint i;\r\nBUG_ON(msg->sgt.nents != (unsigned int)(skb_shinfo(skb)->nr_frags + 1));\r\nsg = msg->sgt.sgl;\r\nsg_set_buf(sg, skb->data, skb_headlen(skb));\r\nfor (i = 0; i < skb_shinfo(skb)->nr_frags; i++) {\r\nsg = sg_next(sg);\r\nBUG_ON(!sg);\r\nfrag = &skb_shinfo(skb)->frags[i];\r\nsg_set_page(sg, frag->page.p, frag->size, frag->page_offset);\r\n}\r\n}\r\nstatic void ssip_free_data(struct hsi_msg *msg)\r\n{\r\nstruct sk_buff *skb;\r\nskb = msg->context;\r\npr_debug("free data: msg %p context %p skb %p\n", msg, msg->context,\r\nskb);\r\nmsg->destructor = NULL;\r\ndev_kfree_skb(skb);\r\nhsi_free_msg(msg);\r\n}\r\nstatic struct hsi_msg *ssip_alloc_data(struct ssi_protocol *ssi,\r\nstruct sk_buff *skb, gfp_t flags)\r\n{\r\nstruct hsi_msg *msg;\r\nmsg = hsi_alloc_msg(skb_shinfo(skb)->nr_frags + 1, flags);\r\nif (!msg)\r\nreturn NULL;\r\nssip_skb_to_msg(skb, msg);\r\nmsg->destructor = ssip_free_data;\r\nmsg->channel = ssi->channel_id_data;\r\nmsg->context = skb;\r\nreturn msg;\r\n}\r\nstatic inline void ssip_release_cmd(struct hsi_msg *msg)\r\n{\r\nstruct ssi_protocol *ssi = hsi_client_drvdata(msg->cl);\r\ndev_dbg(&msg->cl->device, "Release cmd 0x%08x\n", ssip_get_cmd(msg));\r\nspin_lock_bh(&ssi->lock);\r\nlist_add_tail(&msg->link, &ssi->cmdqueue);\r\nspin_unlock_bh(&ssi->lock);\r\n}\r\nstatic struct hsi_msg *ssip_claim_cmd(struct ssi_protocol *ssi)\r\n{\r\nstruct hsi_msg *msg;\r\nBUG_ON(list_empty(&ssi->cmdqueue));\r\nspin_lock_bh(&ssi->lock);\r\nmsg = list_first_entry(&ssi->cmdqueue, struct hsi_msg, link);\r\nlist_del(&msg->link);\r\nspin_unlock_bh(&ssi->lock);\r\nmsg->destructor = ssip_release_cmd;\r\nreturn msg;\r\n}\r\nstatic void ssip_free_cmds(struct ssi_protocol *ssi)\r\n{\r\nstruct hsi_msg *msg, *tmp;\r\nlist_for_each_entry_safe(msg, tmp, &ssi->cmdqueue, link) {\r\nlist_del(&msg->link);\r\nmsg->destructor = NULL;\r\nkfree(sg_virt(msg->sgt.sgl));\r\nhsi_free_msg(msg);\r\n}\r\n}\r\nstatic int ssip_alloc_cmds(struct ssi_protocol *ssi)\r\n{\r\nstruct hsi_msg *msg;\r\nu32 *buf;\r\nunsigned int i;\r\nfor (i = 0; i < SSIP_MAX_CMDS; i++) {\r\nmsg = hsi_alloc_msg(1, GFP_KERNEL);\r\nif (!msg)\r\ngoto out;\r\nbuf = kmalloc(sizeof(*buf), GFP_KERNEL);\r\nif (!buf) {\r\nhsi_free_msg(msg);\r\ngoto out;\r\n}\r\nsg_init_one(msg->sgt.sgl, buf, sizeof(*buf));\r\nmsg->channel = ssi->channel_id_cmd;\r\nlist_add_tail(&msg->link, &ssi->cmdqueue);\r\n}\r\nreturn 0;\r\nout:\r\nssip_free_cmds(ssi);\r\nreturn -ENOMEM;\r\n}\r\nstatic void ssip_set_rxstate(struct ssi_protocol *ssi, unsigned int state)\r\n{\r\nssi->recv_state = state;\r\nswitch (state) {\r\ncase RECV_IDLE:\r\ndel_timer(&ssi->rx_wd);\r\nif (ssi->send_state == SEND_IDLE)\r\ndel_timer(&ssi->keep_alive);\r\nbreak;\r\ncase RECV_READY:\r\nif (atomic_read(&ssi->tx_usecnt))\r\nbreak;\r\ncase RECEIVING:\r\nmod_timer(&ssi->keep_alive, jiffies +\r\nmsecs_to_jiffies(SSIP_KATOUT));\r\nmod_timer(&ssi->rx_wd, jiffies + msecs_to_jiffies(SSIP_WDTOUT));\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nstatic void ssip_set_txstate(struct ssi_protocol *ssi, unsigned int state)\r\n{\r\nssi->send_state = state;\r\nswitch (state) {\r\ncase SEND_IDLE:\r\ncase SEND_READY:\r\ndel_timer(&ssi->tx_wd);\r\nif (ssi->recv_state == RECV_IDLE)\r\ndel_timer(&ssi->keep_alive);\r\nbreak;\r\ncase WAIT4READY:\r\ncase SENDING:\r\ncase SENDING_SWBREAK:\r\nmod_timer(&ssi->keep_alive,\r\njiffies + msecs_to_jiffies(SSIP_KATOUT));\r\nmod_timer(&ssi->tx_wd, jiffies + msecs_to_jiffies(SSIP_WDTOUT));\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nstruct hsi_client *ssip_slave_get_master(struct hsi_client *slave)\r\n{\r\nstruct hsi_client *master = ERR_PTR(-ENODEV);\r\nstruct ssi_protocol *ssi;\r\nlist_for_each_entry(ssi, &ssip_list, link)\r\nif (slave->device.parent == ssi->cl->device.parent) {\r\nmaster = ssi->cl;\r\nbreak;\r\n}\r\nreturn master;\r\n}\r\nint ssip_slave_start_tx(struct hsi_client *master)\r\n{\r\nstruct ssi_protocol *ssi = hsi_client_drvdata(master);\r\ndev_dbg(&master->device, "start TX %d\n", atomic_read(&ssi->tx_usecnt));\r\nspin_lock_bh(&ssi->lock);\r\nif (ssi->send_state == SEND_IDLE) {\r\nssip_set_txstate(ssi, WAIT4READY);\r\nhsi_start_tx(master);\r\n}\r\nspin_unlock_bh(&ssi->lock);\r\natomic_inc(&ssi->tx_usecnt);\r\nreturn 0;\r\n}\r\nint ssip_slave_stop_tx(struct hsi_client *master)\r\n{\r\nstruct ssi_protocol *ssi = hsi_client_drvdata(master);\r\nWARN_ON_ONCE(atomic_read(&ssi->tx_usecnt) == 0);\r\nif (atomic_dec_and_test(&ssi->tx_usecnt)) {\r\nspin_lock_bh(&ssi->lock);\r\nif ((ssi->send_state == SEND_READY) ||\r\n(ssi->send_state == WAIT4READY)) {\r\nssip_set_txstate(ssi, SEND_IDLE);\r\nhsi_stop_tx(master);\r\n}\r\nspin_unlock_bh(&ssi->lock);\r\n}\r\ndev_dbg(&master->device, "stop TX %d\n", atomic_read(&ssi->tx_usecnt));\r\nreturn 0;\r\n}\r\nint ssip_slave_running(struct hsi_client *master)\r\n{\r\nstruct ssi_protocol *ssi = hsi_client_drvdata(master);\r\nreturn netif_running(ssi->netdev);\r\n}\r\nstatic void ssip_reset(struct hsi_client *cl)\r\n{\r\nstruct ssi_protocol *ssi = hsi_client_drvdata(cl);\r\nstruct list_head *head, *tmp;\r\nstruct hsi_msg *msg;\r\nif (netif_running(ssi->netdev))\r\nnetif_carrier_off(ssi->netdev);\r\nhsi_flush(cl);\r\nspin_lock_bh(&ssi->lock);\r\nif (ssi->send_state != SEND_IDLE)\r\nhsi_stop_tx(cl);\r\nif (ssi->waketest)\r\nssi_waketest(cl, 0);\r\ndel_timer(&ssi->rx_wd);\r\ndel_timer(&ssi->tx_wd);\r\ndel_timer(&ssi->keep_alive);\r\nssi->main_state = 0;\r\nssi->send_state = 0;\r\nssi->recv_state = 0;\r\nssi->waketest = 0;\r\nssi->rxid = 0;\r\nssi->txid = 0;\r\nlist_for_each_safe(head, tmp, &ssi->txqueue) {\r\nmsg = list_entry(head, struct hsi_msg, link);\r\ndev_dbg(&cl->device, "Pending TX data\n");\r\nlist_del(head);\r\nssip_free_data(msg);\r\n}\r\nssi->txqueue_len = 0;\r\nspin_unlock_bh(&ssi->lock);\r\n}\r\nstatic void ssip_dump_state(struct hsi_client *cl)\r\n{\r\nstruct ssi_protocol *ssi = hsi_client_drvdata(cl);\r\nstruct hsi_msg *msg;\r\nspin_lock_bh(&ssi->lock);\r\ndev_err(&cl->device, "Main state: %d\n", ssi->main_state);\r\ndev_err(&cl->device, "Recv state: %d\n", ssi->recv_state);\r\ndev_err(&cl->device, "Send state: %d\n", ssi->send_state);\r\ndev_err(&cl->device, "CMT %s\n", (ssi->main_state == ACTIVE) ?\r\n"Online" : "Offline");\r\ndev_err(&cl->device, "Wake test %d\n", ssi->waketest);\r\ndev_err(&cl->device, "Data RX id: %d\n", ssi->rxid);\r\ndev_err(&cl->device, "Data TX id: %d\n", ssi->txid);\r\nlist_for_each_entry(msg, &ssi->txqueue, link)\r\ndev_err(&cl->device, "pending TX data (%p)\n", msg);\r\nspin_unlock_bh(&ssi->lock);\r\n}\r\nstatic void ssip_error(struct hsi_client *cl)\r\n{\r\nstruct ssi_protocol *ssi = hsi_client_drvdata(cl);\r\nstruct hsi_msg *msg;\r\nssip_dump_state(cl);\r\nssip_reset(cl);\r\nmsg = ssip_claim_cmd(ssi);\r\nmsg->complete = ssip_rxcmd_complete;\r\nhsi_async_read(cl, msg);\r\n}\r\nstatic void ssip_keep_alive(unsigned long data)\r\n{\r\nstruct hsi_client *cl = (struct hsi_client *)data;\r\nstruct ssi_protocol *ssi = hsi_client_drvdata(cl);\r\ndev_dbg(&cl->device, "Keep alive kick in: m(%d) r(%d) s(%d)\n",\r\nssi->main_state, ssi->recv_state, ssi->send_state);\r\nspin_lock(&ssi->lock);\r\nif (ssi->recv_state == RECV_IDLE)\r\nswitch (ssi->send_state) {\r\ncase SEND_READY:\r\nif (atomic_read(&ssi->tx_usecnt) == 0)\r\nbreak;\r\ncase SEND_IDLE:\r\nspin_unlock(&ssi->lock);\r\nreturn;\r\n}\r\nmod_timer(&ssi->keep_alive, jiffies + msecs_to_jiffies(SSIP_KATOUT));\r\nspin_unlock(&ssi->lock);\r\n}\r\nstatic void ssip_wd(unsigned long data)\r\n{\r\nstruct hsi_client *cl = (struct hsi_client *)data;\r\ndev_err(&cl->device, "Watchdog trigerred\n");\r\nssip_error(cl);\r\n}\r\nstatic void ssip_send_bootinfo_req_cmd(struct hsi_client *cl)\r\n{\r\nstruct ssi_protocol *ssi = hsi_client_drvdata(cl);\r\nstruct hsi_msg *msg;\r\ndev_dbg(&cl->device, "Issuing BOOT INFO REQ command\n");\r\nmsg = ssip_claim_cmd(ssi);\r\nssip_set_cmd(msg, SSIP_BOOTINFO_REQ_CMD(SSIP_LOCAL_VERID));\r\nmsg->complete = ssip_release_cmd;\r\nhsi_async_write(cl, msg);\r\ndev_dbg(&cl->device, "Issuing RX command\n");\r\nmsg = ssip_claim_cmd(ssi);\r\nmsg->complete = ssip_rxcmd_complete;\r\nhsi_async_read(cl, msg);\r\n}\r\nstatic void ssip_start_rx(struct hsi_client *cl)\r\n{\r\nstruct ssi_protocol *ssi = hsi_client_drvdata(cl);\r\nstruct hsi_msg *msg;\r\ndev_dbg(&cl->device, "RX start M(%d) R(%d)\n", ssi->main_state,\r\nssi->recv_state);\r\nspin_lock(&ssi->lock);\r\nif ((ssi->main_state != ACTIVE) || (ssi->recv_state == RECV_READY)) {\r\nif (ssi->main_state == INIT) {\r\nssi->main_state = HANDSHAKE;\r\nspin_unlock(&ssi->lock);\r\nssip_send_bootinfo_req_cmd(cl);\r\n} else {\r\nspin_unlock(&ssi->lock);\r\n}\r\nreturn;\r\n}\r\nssip_set_rxstate(ssi, RECV_READY);\r\nspin_unlock(&ssi->lock);\r\nmsg = ssip_claim_cmd(ssi);\r\nssip_set_cmd(msg, SSIP_READY_CMD);\r\nmsg->complete = ssip_release_cmd;\r\ndev_dbg(&cl->device, "Send READY\n");\r\nhsi_async_write(cl, msg);\r\n}\r\nstatic void ssip_stop_rx(struct hsi_client *cl)\r\n{\r\nstruct ssi_protocol *ssi = hsi_client_drvdata(cl);\r\ndev_dbg(&cl->device, "RX stop M(%d)\n", ssi->main_state);\r\nspin_lock(&ssi->lock);\r\nif (likely(ssi->main_state == ACTIVE))\r\nssip_set_rxstate(ssi, RECV_IDLE);\r\nspin_unlock(&ssi->lock);\r\n}\r\nstatic void ssip_free_strans(struct hsi_msg *msg)\r\n{\r\nssip_free_data(msg->context);\r\nssip_release_cmd(msg);\r\n}\r\nstatic void ssip_strans_complete(struct hsi_msg *msg)\r\n{\r\nstruct hsi_client *cl = msg->cl;\r\nstruct ssi_protocol *ssi = hsi_client_drvdata(cl);\r\nstruct hsi_msg *data;\r\ndata = msg->context;\r\nssip_release_cmd(msg);\r\nspin_lock(&ssi->lock);\r\nssip_set_txstate(ssi, SENDING);\r\nspin_unlock(&ssi->lock);\r\nhsi_async_write(cl, data);\r\n}\r\nstatic int ssip_xmit(struct hsi_client *cl)\r\n{\r\nstruct ssi_protocol *ssi = hsi_client_drvdata(cl);\r\nstruct hsi_msg *msg, *dmsg;\r\nstruct sk_buff *skb;\r\nspin_lock_bh(&ssi->lock);\r\nif (list_empty(&ssi->txqueue)) {\r\nspin_unlock_bh(&ssi->lock);\r\nreturn 0;\r\n}\r\ndmsg = list_first_entry(&ssi->txqueue, struct hsi_msg, link);\r\nlist_del(&dmsg->link);\r\nssi->txqueue_len--;\r\nspin_unlock_bh(&ssi->lock);\r\nmsg = ssip_claim_cmd(ssi);\r\nskb = dmsg->context;\r\nmsg->context = dmsg;\r\nmsg->complete = ssip_strans_complete;\r\nmsg->destructor = ssip_free_strans;\r\nspin_lock_bh(&ssi->lock);\r\nssip_set_cmd(msg, SSIP_START_TRANS_CMD(SSIP_BYTES_TO_FRAMES(skb->len),\r\nssi->txid));\r\nssi->txid++;\r\nssip_set_txstate(ssi, SENDING);\r\nspin_unlock_bh(&ssi->lock);\r\ndev_dbg(&cl->device, "Send STRANS (%d frames)\n",\r\nSSIP_BYTES_TO_FRAMES(skb->len));\r\nreturn hsi_async_write(cl, msg);\r\n}\r\nstatic void ssip_pn_rx(struct sk_buff *skb)\r\n{\r\nstruct net_device *dev = skb->dev;\r\nif (unlikely(!netif_running(dev))) {\r\ndev_dbg(&dev->dev, "Drop RX packet\n");\r\ndev->stats.rx_dropped++;\r\ndev_kfree_skb(skb);\r\nreturn;\r\n}\r\nif (unlikely(!pskb_may_pull(skb, SSIP_MIN_PN_HDR))) {\r\ndev_dbg(&dev->dev, "Error drop RX packet\n");\r\ndev->stats.rx_errors++;\r\ndev->stats.rx_length_errors++;\r\ndev_kfree_skb(skb);\r\nreturn;\r\n}\r\ndev->stats.rx_packets++;\r\ndev->stats.rx_bytes += skb->len;\r\n((u16 *)skb->data)[2] = ntohs(((u16 *)skb->data)[2]);\r\ndev_dbg(&dev->dev, "RX length fixed (%04x -> %u)\n",\r\n((u16 *)skb->data)[2], ntohs(((u16 *)skb->data)[2]));\r\nskb->protocol = htons(ETH_P_PHONET);\r\nskb_reset_mac_header(skb);\r\n__skb_pull(skb, 1);\r\nnetif_rx(skb);\r\n}\r\nstatic void ssip_rx_data_complete(struct hsi_msg *msg)\r\n{\r\nstruct hsi_client *cl = msg->cl;\r\nstruct ssi_protocol *ssi = hsi_client_drvdata(cl);\r\nstruct sk_buff *skb;\r\nif (msg->status == HSI_STATUS_ERROR) {\r\ndev_err(&cl->device, "RX data error\n");\r\nssip_free_data(msg);\r\nssip_error(cl);\r\nreturn;\r\n}\r\ndel_timer(&ssi->rx_wd);\r\nskb = msg->context;\r\nssip_pn_rx(skb);\r\nhsi_free_msg(msg);\r\n}\r\nstatic void ssip_rx_bootinforeq(struct hsi_client *cl, u32 cmd)\r\n{\r\nstruct ssi_protocol *ssi = hsi_client_drvdata(cl);\r\nstruct hsi_msg *msg;\r\nif (cmd == SSIP_CMT_LOADER_SYNC)\r\nreturn;\r\nswitch (ssi->main_state) {\r\ncase ACTIVE:\r\ndev_err(&cl->device, "Boot info req on active state\n");\r\nssip_error(cl);\r\ncase INIT:\r\nspin_lock(&ssi->lock);\r\nssi->main_state = HANDSHAKE;\r\nif (!ssi->waketest) {\r\nssi->waketest = 1;\r\nssi_waketest(cl, 1);\r\n}\r\nmod_timer(&ssi->tx_wd, jiffies + msecs_to_jiffies(SSIP_WDTOUT));\r\nspin_unlock(&ssi->lock);\r\ndev_dbg(&cl->device, "Send BOOTINFO_RESP\n");\r\nif (SSIP_DATA_VERSION(cmd) != SSIP_LOCAL_VERID)\r\ndev_warn(&cl->device, "boot info req verid mismatch\n");\r\nmsg = ssip_claim_cmd(ssi);\r\nssip_set_cmd(msg, SSIP_BOOTINFO_RESP_CMD(SSIP_LOCAL_VERID));\r\nmsg->complete = ssip_release_cmd;\r\nhsi_async_write(cl, msg);\r\nbreak;\r\ncase HANDSHAKE:\r\nbreak;\r\ndefault:\r\ndev_dbg(&cl->device, "Wrong state M(%d)\n", ssi->main_state);\r\nbreak;\r\n}\r\n}\r\nstatic void ssip_rx_bootinforesp(struct hsi_client *cl, u32 cmd)\r\n{\r\nstruct ssi_protocol *ssi = hsi_client_drvdata(cl);\r\nif (SSIP_DATA_VERSION(cmd) != SSIP_LOCAL_VERID)\r\ndev_warn(&cl->device, "boot info resp verid mismatch\n");\r\nspin_lock(&ssi->lock);\r\nif (ssi->main_state != ACTIVE)\r\nmod_timer(&ssi->tx_wd, jiffies + msecs_to_jiffies(SSIP_WDTOUT));\r\nelse\r\ndev_dbg(&cl->device, "boot info resp ignored M(%d)\n",\r\nssi->main_state);\r\nspin_unlock(&ssi->lock);\r\n}\r\nstatic void ssip_rx_waketest(struct hsi_client *cl, u32 cmd)\r\n{\r\nstruct ssi_protocol *ssi = hsi_client_drvdata(cl);\r\nunsigned int wkres = SSIP_PAYLOAD(cmd);\r\nspin_lock(&ssi->lock);\r\nif (ssi->main_state != HANDSHAKE) {\r\ndev_dbg(&cl->device, "wake lines test ignored M(%d)\n",\r\nssi->main_state);\r\nspin_unlock(&ssi->lock);\r\nreturn;\r\n}\r\nif (ssi->waketest) {\r\nssi->waketest = 0;\r\nssi_waketest(cl, 0);\r\n}\r\nssi->main_state = ACTIVE;\r\ndel_timer(&ssi->tx_wd);\r\nspin_unlock(&ssi->lock);\r\ndev_notice(&cl->device, "WAKELINES TEST %s\n",\r\nwkres & SSIP_WAKETEST_FAILED ? "FAILED" : "OK");\r\nif (wkres & SSIP_WAKETEST_FAILED) {\r\nssip_error(cl);\r\nreturn;\r\n}\r\ndev_dbg(&cl->device, "CMT is ONLINE\n");\r\nnetif_wake_queue(ssi->netdev);\r\nnetif_carrier_on(ssi->netdev);\r\n}\r\nstatic void ssip_rx_ready(struct hsi_client *cl)\r\n{\r\nstruct ssi_protocol *ssi = hsi_client_drvdata(cl);\r\nspin_lock(&ssi->lock);\r\nif (unlikely(ssi->main_state != ACTIVE)) {\r\ndev_dbg(&cl->device, "READY on wrong state: S(%d) M(%d)\n",\r\nssi->send_state, ssi->main_state);\r\nspin_unlock(&ssi->lock);\r\nreturn;\r\n}\r\nif (ssi->send_state != WAIT4READY) {\r\ndev_dbg(&cl->device, "Ignore spurious READY command\n");\r\nspin_unlock(&ssi->lock);\r\nreturn;\r\n}\r\nssip_set_txstate(ssi, SEND_READY);\r\nspin_unlock(&ssi->lock);\r\nssip_xmit(cl);\r\n}\r\nstatic void ssip_rx_strans(struct hsi_client *cl, u32 cmd)\r\n{\r\nstruct ssi_protocol *ssi = hsi_client_drvdata(cl);\r\nstruct sk_buff *skb;\r\nstruct hsi_msg *msg;\r\nint len = SSIP_PDU_LENGTH(cmd);\r\ndev_dbg(&cl->device, "RX strans: %d frames\n", len);\r\nspin_lock(&ssi->lock);\r\nif (unlikely(ssi->main_state != ACTIVE)) {\r\ndev_err(&cl->device, "START TRANS wrong state: S(%d) M(%d)\n",\r\nssi->send_state, ssi->main_state);\r\nspin_unlock(&ssi->lock);\r\nreturn;\r\n}\r\nssip_set_rxstate(ssi, RECEIVING);\r\nif (unlikely(SSIP_MSG_ID(cmd) != ssi->rxid)) {\r\ndev_err(&cl->device, "START TRANS id %d expected %d\n",\r\nSSIP_MSG_ID(cmd), ssi->rxid);\r\nspin_unlock(&ssi->lock);\r\ngoto out1;\r\n}\r\nssi->rxid++;\r\nspin_unlock(&ssi->lock);\r\nskb = netdev_alloc_skb(ssi->netdev, len * 4);\r\nif (unlikely(!skb)) {\r\ndev_err(&cl->device, "No memory for rx skb\n");\r\ngoto out1;\r\n}\r\nskb->dev = ssi->netdev;\r\nskb_put(skb, len * 4);\r\nmsg = ssip_alloc_data(ssi, skb, GFP_ATOMIC);\r\nif (unlikely(!msg)) {\r\ndev_err(&cl->device, "No memory for RX data msg\n");\r\ngoto out2;\r\n}\r\nmsg->complete = ssip_rx_data_complete;\r\nhsi_async_read(cl, msg);\r\nreturn;\r\nout2:\r\ndev_kfree_skb(skb);\r\nout1:\r\nssip_error(cl);\r\n}\r\nstatic void ssip_rxcmd_complete(struct hsi_msg *msg)\r\n{\r\nstruct hsi_client *cl = msg->cl;\r\nu32 cmd = ssip_get_cmd(msg);\r\nunsigned int cmdid = SSIP_COMMAND(cmd);\r\nif (msg->status == HSI_STATUS_ERROR) {\r\ndev_err(&cl->device, "RX error detected\n");\r\nssip_release_cmd(msg);\r\nssip_error(cl);\r\nreturn;\r\n}\r\nhsi_async_read(cl, msg);\r\ndev_dbg(&cl->device, "RX cmd: 0x%08x\n", cmd);\r\nswitch (cmdid) {\r\ncase SSIP_SW_BREAK:\r\nbreak;\r\ncase SSIP_BOOTINFO_REQ:\r\nssip_rx_bootinforeq(cl, cmd);\r\nbreak;\r\ncase SSIP_BOOTINFO_RESP:\r\nssip_rx_bootinforesp(cl, cmd);\r\nbreak;\r\ncase SSIP_WAKETEST_RESULT:\r\nssip_rx_waketest(cl, cmd);\r\nbreak;\r\ncase SSIP_START_TRANS:\r\nssip_rx_strans(cl, cmd);\r\nbreak;\r\ncase SSIP_READY:\r\nssip_rx_ready(cl);\r\nbreak;\r\ndefault:\r\ndev_warn(&cl->device, "command 0x%08x not supported\n", cmd);\r\nbreak;\r\n}\r\n}\r\nstatic void ssip_swbreak_complete(struct hsi_msg *msg)\r\n{\r\nstruct hsi_client *cl = msg->cl;\r\nstruct ssi_protocol *ssi = hsi_client_drvdata(cl);\r\nssip_release_cmd(msg);\r\nspin_lock(&ssi->lock);\r\nif (list_empty(&ssi->txqueue)) {\r\nif (atomic_read(&ssi->tx_usecnt)) {\r\nssip_set_txstate(ssi, SEND_READY);\r\n} else {\r\nssip_set_txstate(ssi, SEND_IDLE);\r\nhsi_stop_tx(cl);\r\n}\r\nspin_unlock(&ssi->lock);\r\n} else {\r\nspin_unlock(&ssi->lock);\r\nssip_xmit(cl);\r\n}\r\nnetif_wake_queue(ssi->netdev);\r\n}\r\nstatic void ssip_tx_data_complete(struct hsi_msg *msg)\r\n{\r\nstruct hsi_client *cl = msg->cl;\r\nstruct ssi_protocol *ssi = hsi_client_drvdata(cl);\r\nstruct hsi_msg *cmsg;\r\nif (msg->status == HSI_STATUS_ERROR) {\r\ndev_err(&cl->device, "TX data error\n");\r\nssip_error(cl);\r\ngoto out;\r\n}\r\nspin_lock(&ssi->lock);\r\nif (list_empty(&ssi->txqueue)) {\r\nssip_set_txstate(ssi, SENDING_SWBREAK);\r\nspin_unlock(&ssi->lock);\r\ncmsg = ssip_claim_cmd(ssi);\r\nssip_set_cmd(cmsg, SSIP_SWBREAK_CMD);\r\ncmsg->complete = ssip_swbreak_complete;\r\ndev_dbg(&cl->device, "Send SWBREAK\n");\r\nhsi_async_write(cl, cmsg);\r\n} else {\r\nspin_unlock(&ssi->lock);\r\nssip_xmit(cl);\r\n}\r\nout:\r\nssip_free_data(msg);\r\n}\r\nstatic void ssip_port_event(struct hsi_client *cl, unsigned long event)\r\n{\r\nswitch (event) {\r\ncase HSI_EVENT_START_RX:\r\nssip_start_rx(cl);\r\nbreak;\r\ncase HSI_EVENT_STOP_RX:\r\nssip_stop_rx(cl);\r\nbreak;\r\ndefault:\r\nreturn;\r\n}\r\n}\r\nstatic int ssip_pn_open(struct net_device *dev)\r\n{\r\nstruct hsi_client *cl = to_hsi_client(dev->dev.parent);\r\nstruct ssi_protocol *ssi = hsi_client_drvdata(cl);\r\nint err;\r\nerr = hsi_claim_port(cl, 1);\r\nif (err < 0) {\r\ndev_err(&cl->device, "SSI port already claimed\n");\r\nreturn err;\r\n}\r\nerr = hsi_register_port_event(cl, ssip_port_event);\r\nif (err < 0) {\r\ndev_err(&cl->device, "Register HSI port event failed (%d)\n",\r\nerr);\r\nreturn err;\r\n}\r\ndev_dbg(&cl->device, "Configuring SSI port\n");\r\nhsi_setup(cl);\r\nspin_lock_bh(&ssi->lock);\r\nif (!ssi->waketest) {\r\nssi->waketest = 1;\r\nssi_waketest(cl, 1);\r\n}\r\nssi->main_state = INIT;\r\nspin_unlock_bh(&ssi->lock);\r\nreturn 0;\r\n}\r\nstatic int ssip_pn_stop(struct net_device *dev)\r\n{\r\nstruct hsi_client *cl = to_hsi_client(dev->dev.parent);\r\nssip_reset(cl);\r\nhsi_unregister_port_event(cl);\r\nhsi_release_port(cl);\r\nreturn 0;\r\n}\r\nstatic int ssip_pn_set_mtu(struct net_device *dev, int new_mtu)\r\n{\r\nif (new_mtu > SSIP_MAX_MTU || new_mtu < PHONET_MIN_MTU)\r\nreturn -EINVAL;\r\ndev->mtu = new_mtu;\r\nreturn 0;\r\n}\r\nstatic int ssip_pn_xmit(struct sk_buff *skb, struct net_device *dev)\r\n{\r\nstruct hsi_client *cl = to_hsi_client(dev->dev.parent);\r\nstruct ssi_protocol *ssi = hsi_client_drvdata(cl);\r\nstruct hsi_msg *msg;\r\nif ((skb->protocol != htons(ETH_P_PHONET)) ||\r\n(skb->len < SSIP_MIN_PN_HDR))\r\ngoto drop;\r\nif ((skb->len & 3) && skb_pad(skb, 4 - (skb->len & 3)))\r\ngoto drop;\r\nif (skb_cow_head(skb, 0))\r\ngoto drop;\r\n((u16 *)skb->data)[2] = htons(((u16 *)skb->data)[2]);\r\nmsg = ssip_alloc_data(ssi, skb, GFP_ATOMIC);\r\nif (!msg) {\r\ndev_dbg(&cl->device, "Dropping tx data: No memory\n");\r\ngoto drop;\r\n}\r\nmsg->complete = ssip_tx_data_complete;\r\nspin_lock_bh(&ssi->lock);\r\nif (unlikely(ssi->main_state != ACTIVE)) {\r\nspin_unlock_bh(&ssi->lock);\r\ndev_dbg(&cl->device, "Dropping tx data: CMT is OFFLINE\n");\r\ngoto drop2;\r\n}\r\nlist_add_tail(&msg->link, &ssi->txqueue);\r\nssi->txqueue_len++;\r\nif (dev->tx_queue_len < ssi->txqueue_len) {\r\ndev_info(&cl->device, "TX queue full %d\n", ssi->txqueue_len);\r\nnetif_stop_queue(dev);\r\n}\r\nif (ssi->send_state == SEND_IDLE) {\r\nssip_set_txstate(ssi, WAIT4READY);\r\nspin_unlock_bh(&ssi->lock);\r\ndev_dbg(&cl->device, "Start TX qlen %d\n", ssi->txqueue_len);\r\nhsi_start_tx(cl);\r\n} else if (ssi->send_state == SEND_READY) {\r\ndev_dbg(&cl->device, "Start TX on SEND READY qlen %d\n",\r\nssi->txqueue_len);\r\nspin_unlock_bh(&ssi->lock);\r\nssip_xmit(cl);\r\n} else {\r\nspin_unlock_bh(&ssi->lock);\r\n}\r\ndev->stats.tx_packets++;\r\ndev->stats.tx_bytes += skb->len;\r\nreturn 0;\r\ndrop2:\r\nhsi_free_msg(msg);\r\ndrop:\r\ndev->stats.tx_dropped++;\r\ndev_kfree_skb(skb);\r\nreturn 0;\r\n}\r\nvoid ssip_reset_event(struct hsi_client *master)\r\n{\r\nstruct ssi_protocol *ssi = hsi_client_drvdata(master);\r\ndev_err(&ssi->cl->device, "CMT reset detected!\n");\r\nssip_error(ssi->cl);\r\n}\r\nstatic void ssip_pn_setup(struct net_device *dev)\r\n{\r\ndev->features = 0;\r\ndev->netdev_ops = &ssip_pn_ops;\r\ndev->type = ARPHRD_PHONET;\r\ndev->flags = IFF_POINTOPOINT | IFF_NOARP;\r\ndev->mtu = SSIP_DEFAULT_MTU;\r\ndev->hard_header_len = 1;\r\ndev->dev_addr[0] = PN_MEDIA_SOS;\r\ndev->addr_len = 1;\r\ndev->tx_queue_len = SSIP_TXQUEUE_LEN;\r\ndev->destructor = free_netdev;\r\ndev->header_ops = &phonet_header_ops;\r\n}\r\nstatic int ssi_protocol_probe(struct device *dev)\r\n{\r\nstatic const char ifname[] = "phonet%d";\r\nstruct hsi_client *cl = to_hsi_client(dev);\r\nstruct ssi_protocol *ssi;\r\nint err;\r\nssi = kzalloc(sizeof(*ssi), GFP_KERNEL);\r\nif (!ssi) {\r\ndev_err(dev, "No memory for ssi protocol\n");\r\nreturn -ENOMEM;\r\n}\r\nspin_lock_init(&ssi->lock);\r\ninit_timer_deferrable(&ssi->rx_wd);\r\ninit_timer_deferrable(&ssi->tx_wd);\r\ninit_timer(&ssi->keep_alive);\r\nssi->rx_wd.data = (unsigned long)cl;\r\nssi->rx_wd.function = ssip_wd;\r\nssi->tx_wd.data = (unsigned long)cl;\r\nssi->tx_wd.function = ssip_wd;\r\nssi->keep_alive.data = (unsigned long)cl;\r\nssi->keep_alive.function = ssip_keep_alive;\r\nINIT_LIST_HEAD(&ssi->txqueue);\r\nINIT_LIST_HEAD(&ssi->cmdqueue);\r\natomic_set(&ssi->tx_usecnt, 0);\r\nhsi_client_set_drvdata(cl, ssi);\r\nssi->cl = cl;\r\nssi->channel_id_cmd = hsi_get_channel_id_by_name(cl, "mcsaab-control");\r\nif (ssi->channel_id_cmd < 0) {\r\nerr = ssi->channel_id_cmd;\r\ndev_err(dev, "Could not get cmd channel (%d)\n", err);\r\ngoto out;\r\n}\r\nssi->channel_id_data = hsi_get_channel_id_by_name(cl, "mcsaab-data");\r\nif (ssi->channel_id_data < 0) {\r\nerr = ssi->channel_id_data;\r\ndev_err(dev, "Could not get data channel (%d)\n", err);\r\ngoto out;\r\n}\r\nerr = ssip_alloc_cmds(ssi);\r\nif (err < 0) {\r\ndev_err(dev, "No memory for commands\n");\r\ngoto out;\r\n}\r\nssi->netdev = alloc_netdev(0, ifname, NET_NAME_UNKNOWN, ssip_pn_setup);\r\nif (!ssi->netdev) {\r\ndev_err(dev, "No memory for netdev\n");\r\nerr = -ENOMEM;\r\ngoto out1;\r\n}\r\nSET_NETDEV_DEV(ssi->netdev, dev);\r\nnetif_carrier_off(ssi->netdev);\r\nerr = register_netdev(ssi->netdev);\r\nif (err < 0) {\r\ndev_err(dev, "Register netdev failed (%d)\n", err);\r\ngoto out2;\r\n}\r\nlist_add(&ssi->link, &ssip_list);\r\ndev_dbg(dev, "channel configuration: cmd=%d, data=%d\n",\r\nssi->channel_id_cmd, ssi->channel_id_data);\r\nreturn 0;\r\nout2:\r\nfree_netdev(ssi->netdev);\r\nout1:\r\nssip_free_cmds(ssi);\r\nout:\r\nkfree(ssi);\r\nreturn err;\r\n}\r\nstatic int ssi_protocol_remove(struct device *dev)\r\n{\r\nstruct hsi_client *cl = to_hsi_client(dev);\r\nstruct ssi_protocol *ssi = hsi_client_drvdata(cl);\r\nlist_del(&ssi->link);\r\nunregister_netdev(ssi->netdev);\r\nssip_free_cmds(ssi);\r\nhsi_client_set_drvdata(cl, NULL);\r\nkfree(ssi);\r\nreturn 0;\r\n}\r\nstatic int __init ssip_init(void)\r\n{\r\npr_info("SSI protocol aka McSAAB added\n");\r\nreturn hsi_register_client_driver(&ssip_driver);\r\n}\r\nstatic void __exit ssip_exit(void)\r\n{\r\nhsi_unregister_client_driver(&ssip_driver);\r\npr_info("SSI protocol driver removed\n");\r\n}
