static ssize_t show_sensor(struct device *dev, struct device_attribute *devattr,\r\nchar *buf)\r\n{\r\nstruct sensor_data *sdata = container_of(devattr, struct sensor_data,\r\ndev_attr);\r\nssize_t ret;\r\nu32 x;\r\nret = opal_get_sensor_data(sdata->id, &x);\r\nif (ret)\r\nreturn ret;\r\nif (sdata->type == TEMP)\r\nx *= 1000;\r\nelse if (sdata->type == POWER_INPUT)\r\nx *= 1000000;\r\nreturn sprintf(buf, "%u\n", x);\r\n}\r\nstatic ssize_t show_label(struct device *dev, struct device_attribute *devattr,\r\nchar *buf)\r\n{\r\nstruct sensor_data *sdata = container_of(devattr, struct sensor_data,\r\ndev_attr);\r\nreturn sprintf(buf, "%s\n", sdata->label);\r\n}\r\nstatic int __init get_logical_cpu(int hwcpu)\r\n{\r\nint cpu;\r\nfor_each_possible_cpu(cpu)\r\nif (get_hard_smp_processor_id(cpu) == hwcpu)\r\nreturn cpu;\r\nreturn -ENOENT;\r\n}\r\nstatic void __init make_sensor_label(struct device_node *np,\r\nstruct sensor_data *sdata,\r\nconst char *label)\r\n{\r\nu32 id;\r\nsize_t n;\r\nn = snprintf(sdata->label, sizeof(sdata->label), "%s", label);\r\nif (!of_property_read_u32(np, "ibm,pir", &id)) {\r\nint cpuid = get_logical_cpu(id);\r\nif (cpuid >= 0)\r\nn += snprintf(sdata->label + n,\r\nsizeof(sdata->label) - n, " %d-%d",\r\ncpuid, cpuid + threads_per_core - 1);\r\nelse\r\nn += snprintf(sdata->label + n,\r\nsizeof(sdata->label) - n, " phy%d", id);\r\n}\r\nif (!of_property_read_u32(np, "ibm,chip-id", &id))\r\nn += snprintf(sdata->label + n, sizeof(sdata->label) - n,\r\n" %d", id & 0xffff);\r\n}\r\nstatic int get_sensor_index_attr(const char *name, u32 *index, char *attr)\r\n{\r\nchar *hash_pos = strchr(name, '#');\r\nchar buf[8] = { 0 };\r\nchar *dash_pos;\r\nu32 copy_len;\r\nint err;\r\nif (!hash_pos)\r\nreturn -EINVAL;\r\ndash_pos = strchr(hash_pos, '-');\r\nif (!dash_pos)\r\nreturn -EINVAL;\r\ncopy_len = dash_pos - hash_pos - 1;\r\nif (copy_len >= sizeof(buf))\r\nreturn -EINVAL;\r\nstrncpy(buf, hash_pos + 1, copy_len);\r\nerr = kstrtou32(buf, 10, index);\r\nif (err)\r\nreturn err;\r\nstrncpy(attr, dash_pos + 1, MAX_ATTR_LEN);\r\nreturn 0;\r\n}\r\nstatic const char *convert_opal_attr_name(enum sensors type,\r\nconst char *opal_attr)\r\n{\r\nconst char *attr_name = NULL;\r\nif (!strcmp(opal_attr, DT_FAULT_ATTR_SUFFIX)) {\r\nattr_name = "fault";\r\n} else if (!strcmp(opal_attr, DT_DATA_ATTR_SUFFIX)) {\r\nattr_name = "input";\r\n} else if (!strcmp(opal_attr, DT_THRESHOLD_ATTR_SUFFIX)) {\r\nif (type == TEMP)\r\nattr_name = "max";\r\nelse if (type == FAN)\r\nattr_name = "min";\r\n}\r\nreturn attr_name;\r\n}\r\nstatic const char *parse_opal_node_name(const char *node_name,\r\nenum sensors type, u32 *index)\r\n{\r\nchar attr_suffix[MAX_ATTR_LEN];\r\nconst char *attr_name;\r\nint err;\r\nerr = get_sensor_index_attr(node_name, index, attr_suffix);\r\nif (err)\r\nreturn ERR_PTR(err);\r\nattr_name = convert_opal_attr_name(type, attr_suffix);\r\nif (!attr_name)\r\nreturn ERR_PTR(-ENOENT);\r\nreturn attr_name;\r\n}\r\nstatic int get_sensor_type(struct device_node *np)\r\n{\r\nenum sensors type;\r\nconst char *str;\r\nfor (type = 0; type < MAX_SENSOR_TYPE; type++) {\r\nif (of_device_is_compatible(np, sensor_groups[type].compatible))\r\nreturn type;\r\n}\r\nif (!of_device_is_compatible(np, "ibm,opal-sensor"))\r\nreturn MAX_SENSOR_TYPE;\r\nif (of_property_read_string(np, "sensor-type", &str))\r\nreturn MAX_SENSOR_TYPE;\r\nfor (type = 0; type < MAX_SENSOR_TYPE; type++)\r\nif (!strcmp(str, sensor_groups[type].name))\r\nreturn type;\r\nreturn MAX_SENSOR_TYPE;\r\n}\r\nstatic u32 get_sensor_hwmon_index(struct sensor_data *sdata,\r\nstruct sensor_data *sdata_table, int count)\r\n{\r\nint i;\r\nif (sdata->opal_index != INVALID_INDEX) {\r\nfor (i = 0; i < count; i++)\r\nif (sdata_table[i].opal_index == sdata->opal_index &&\r\nsdata_table[i].type == sdata->type)\r\nreturn sdata_table[i].hwmon_index;\r\n}\r\nreturn ++sensor_groups[sdata->type].hwmon_index;\r\n}\r\nstatic int populate_attr_groups(struct platform_device *pdev)\r\n{\r\nstruct platform_data *pdata = platform_get_drvdata(pdev);\r\nconst struct attribute_group **pgroups = pdata->attr_groups;\r\nstruct device_node *opal, *np;\r\nenum sensors type;\r\nopal = of_find_node_by_path("/ibm,opal/sensors");\r\nfor_each_child_of_node(opal, np) {\r\nconst char *label;\r\nif (np->name == NULL)\r\ncontinue;\r\ntype = get_sensor_type(np);\r\nif (type == MAX_SENSOR_TYPE)\r\ncontinue;\r\nsensor_groups[type].attr_count++;\r\nif (!of_property_read_string(np, "label", &label))\r\nsensor_groups[type].attr_count++;\r\n}\r\nof_node_put(opal);\r\nfor (type = 0; type < MAX_SENSOR_TYPE; type++) {\r\nsensor_groups[type].group.attrs = devm_kzalloc(&pdev->dev,\r\nsizeof(struct attribute *) *\r\n(sensor_groups[type].attr_count + 1),\r\nGFP_KERNEL);\r\nif (!sensor_groups[type].group.attrs)\r\nreturn -ENOMEM;\r\npgroups[type] = &sensor_groups[type].group;\r\npdata->sensors_count += sensor_groups[type].attr_count;\r\nsensor_groups[type].attr_count = 0;\r\n}\r\nreturn 0;\r\n}\r\nstatic void create_hwmon_attr(struct sensor_data *sdata, const char *attr_name,\r\nssize_t (*show)(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf))\r\n{\r\nsnprintf(sdata->name, MAX_ATTR_LEN, "%s%d_%s",\r\nsensor_groups[sdata->type].name, sdata->hwmon_index,\r\nattr_name);\r\nsysfs_attr_init(&sdata->dev_attr.attr);\r\nsdata->dev_attr.attr.name = sdata->name;\r\nsdata->dev_attr.attr.mode = S_IRUGO;\r\nsdata->dev_attr.show = show;\r\n}\r\nstatic int create_device_attrs(struct platform_device *pdev)\r\n{\r\nstruct platform_data *pdata = platform_get_drvdata(pdev);\r\nconst struct attribute_group **pgroups = pdata->attr_groups;\r\nstruct device_node *opal, *np;\r\nstruct sensor_data *sdata;\r\nu32 sensor_id;\r\nenum sensors type;\r\nu32 count = 0;\r\nint err = 0;\r\nopal = of_find_node_by_path("/ibm,opal/sensors");\r\nsdata = devm_kzalloc(&pdev->dev, pdata->sensors_count * sizeof(*sdata),\r\nGFP_KERNEL);\r\nif (!sdata) {\r\nerr = -ENOMEM;\r\ngoto exit_put_node;\r\n}\r\nfor_each_child_of_node(opal, np) {\r\nconst char *attr_name;\r\nu32 opal_index;\r\nconst char *label;\r\nif (np->name == NULL)\r\ncontinue;\r\ntype = get_sensor_type(np);\r\nif (type == MAX_SENSOR_TYPE)\r\ncontinue;\r\nif (of_property_read_u32(np, "sensor-id", &sensor_id) &&\r\nof_property_read_u32(np, "sensor-data", &sensor_id)) {\r\ndev_info(&pdev->dev,\r\n"'sensor-id' missing in the node '%s'\n",\r\nnp->name);\r\ncontinue;\r\n}\r\nsdata[count].id = sensor_id;\r\nsdata[count].type = type;\r\nattr_name = parse_opal_node_name(np->name, type, &opal_index);\r\nif (IS_ERR(attr_name)) {\r\nattr_name = "input";\r\nopal_index = INVALID_INDEX;\r\n}\r\nsdata[count].opal_index = opal_index;\r\nsdata[count].hwmon_index =\r\nget_sensor_hwmon_index(&sdata[count], sdata, count);\r\ncreate_hwmon_attr(&sdata[count], attr_name, show_sensor);\r\npgroups[type]->attrs[sensor_groups[type].attr_count++] =\r\n&sdata[count++].dev_attr.attr;\r\nif (!of_property_read_string(np, "label", &label)) {\r\nsdata[count].type = type;\r\nsdata[count].opal_index = sdata[count - 1].opal_index;\r\nsdata[count].hwmon_index = sdata[count - 1].hwmon_index;\r\nmake_sensor_label(np, &sdata[count], label);\r\ncreate_hwmon_attr(&sdata[count], "label", show_label);\r\npgroups[type]->attrs[sensor_groups[type].attr_count++] =\r\n&sdata[count++].dev_attr.attr;\r\n}\r\n}\r\nexit_put_node:\r\nof_node_put(opal);\r\nreturn err;\r\n}\r\nstatic int ibmpowernv_probe(struct platform_device *pdev)\r\n{\r\nstruct platform_data *pdata;\r\nstruct device *hwmon_dev;\r\nint err;\r\npdata = devm_kzalloc(&pdev->dev, sizeof(*pdata), GFP_KERNEL);\r\nif (!pdata)\r\nreturn -ENOMEM;\r\nplatform_set_drvdata(pdev, pdata);\r\npdata->sensors_count = 0;\r\nerr = populate_attr_groups(pdev);\r\nif (err)\r\nreturn err;\r\nerr = create_device_attrs(pdev);\r\nif (err)\r\nreturn err;\r\nhwmon_dev = devm_hwmon_device_register_with_groups(&pdev->dev, DRVNAME,\r\npdata,\r\npdata->attr_groups);\r\nreturn PTR_ERR_OR_ZERO(hwmon_dev);\r\n}
