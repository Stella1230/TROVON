static __be32 *\r\n_osd_xdr_decode_objid(__be32 *p, struct pnfs_osd_objid *objid)\r\n{\r\np = xdr_decode_opaque_fixed(p, objid->oid_device_id.data,\r\nsizeof(objid->oid_device_id.data));\r\np = xdr_decode_hyper(p, &objid->oid_partition_id);\r\np = xdr_decode_hyper(p, &objid->oid_object_id);\r\nreturn p;\r\n}\r\nstatic int\r\n_osd_xdr_decode_opaque_cred(struct pnfs_osd_opaque_cred *opaque_cred,\r\nstruct xdr_stream *xdr)\r\n{\r\n__be32 *p = xdr_inline_decode(xdr, 1);\r\nif (!p)\r\nreturn -EINVAL;\r\nopaque_cred->cred_len = be32_to_cpu(*p++);\r\np = xdr_inline_decode(xdr, opaque_cred->cred_len);\r\nif (!p)\r\nreturn -EINVAL;\r\nopaque_cred->cred = p;\r\nreturn 0;\r\n}\r\nstatic int\r\n_osd_xdr_decode_object_cred(struct pnfs_osd_object_cred *comp,\r\nstruct xdr_stream *xdr)\r\n{\r\n__be32 *p = xdr_inline_decode(xdr, 32 + 4 + 4);\r\nint ret;\r\nif (!p)\r\nreturn -EIO;\r\np = _osd_xdr_decode_objid(p, &comp->oc_object_id);\r\ncomp->oc_osd_version = be32_to_cpup(p++);\r\ncomp->oc_cap_key_sec = be32_to_cpup(p);\r\nret = _osd_xdr_decode_opaque_cred(&comp->oc_cap_key, xdr);\r\nif (unlikely(ret))\r\nreturn ret;\r\nret = _osd_xdr_decode_opaque_cred(&comp->oc_cap, xdr);\r\nreturn ret;\r\n}\r\nstatic inline int\r\n_osd_data_map_xdr_sz(void)\r\n{\r\nreturn 4 + 8 + 4 + 4 + 4 + 4;\r\n}\r\nstatic __be32 *\r\n_osd_xdr_decode_data_map(__be32 *p, struct pnfs_osd_data_map *data_map)\r\n{\r\ndata_map->odm_num_comps = be32_to_cpup(p++);\r\np = xdr_decode_hyper(p, &data_map->odm_stripe_unit);\r\ndata_map->odm_group_width = be32_to_cpup(p++);\r\ndata_map->odm_group_depth = be32_to_cpup(p++);\r\ndata_map->odm_mirror_cnt = be32_to_cpup(p++);\r\ndata_map->odm_raid_algorithm = be32_to_cpup(p++);\r\ndprintk("%s: odm_num_comps=%u odm_stripe_unit=%llu odm_group_width=%u "\r\n"odm_group_depth=%u odm_mirror_cnt=%u odm_raid_algorithm=%u\n",\r\n__func__,\r\ndata_map->odm_num_comps,\r\n(unsigned long long)data_map->odm_stripe_unit,\r\ndata_map->odm_group_width,\r\ndata_map->odm_group_depth,\r\ndata_map->odm_mirror_cnt,\r\ndata_map->odm_raid_algorithm);\r\nreturn p;\r\n}\r\nint pnfs_osd_xdr_decode_layout_map(struct pnfs_osd_layout *layout,\r\nstruct pnfs_osd_xdr_decode_layout_iter *iter, struct xdr_stream *xdr)\r\n{\r\n__be32 *p;\r\nmemset(iter, 0, sizeof(*iter));\r\np = xdr_inline_decode(xdr, _osd_data_map_xdr_sz() + 4 + 4);\r\nif (unlikely(!p))\r\nreturn -EINVAL;\r\np = _osd_xdr_decode_data_map(p, &layout->olo_map);\r\nlayout->olo_comps_index = be32_to_cpup(p++);\r\nlayout->olo_num_comps = be32_to_cpup(p++);\r\ndprintk("%s: olo_comps_index=%d olo_num_comps=%d\n", __func__,\r\nlayout->olo_comps_index, layout->olo_num_comps);\r\niter->total_comps = layout->olo_num_comps;\r\nreturn 0;\r\n}\r\nbool pnfs_osd_xdr_decode_layout_comp(struct pnfs_osd_object_cred *comp,\r\nstruct pnfs_osd_xdr_decode_layout_iter *iter, struct xdr_stream *xdr,\r\nint *err)\r\n{\r\nBUG_ON(iter->decoded_comps > iter->total_comps);\r\nif (iter->decoded_comps == iter->total_comps)\r\nreturn false;\r\n*err = _osd_xdr_decode_object_cred(comp, xdr);\r\nif (unlikely(*err)) {\r\ndprintk("%s: _osd_xdr_decode_object_cred=>%d decoded_comps=%d "\r\n"total_comps=%d\n", __func__, *err,\r\niter->decoded_comps, iter->total_comps);\r\nreturn false;\r\n}\r\ndprintk("%s: dev(%llx:%llx) par=0x%llx obj=0x%llx "\r\n"key_len=%u cap_len=%u\n",\r\n__func__,\r\n_DEVID_LO(&comp->oc_object_id.oid_device_id),\r\n_DEVID_HI(&comp->oc_object_id.oid_device_id),\r\ncomp->oc_object_id.oid_partition_id,\r\ncomp->oc_object_id.oid_object_id,\r\ncomp->oc_cap_key.cred_len, comp->oc_cap.cred_len);\r\niter->decoded_comps++;\r\nreturn true;\r\n}\r\nstatic __be32 *\r\n__read_u8_opaque(__be32 *p, struct nfs4_string *str)\r\n{\r\nstr->len = be32_to_cpup(p++);\r\nstr->data = (char *)p;\r\np += XDR_QUADLEN(str->len);\r\nreturn p;\r\n}\r\nstatic __be32 *\r\n__read_targetid(__be32 *p, struct pnfs_osd_targetid* targetid)\r\n{\r\nu32 oti_type;\r\noti_type = be32_to_cpup(p++);\r\ntargetid->oti_type = oti_type;\r\nswitch (oti_type) {\r\ncase OBJ_TARGET_SCSI_NAME:\r\ncase OBJ_TARGET_SCSI_DEVICE_ID:\r\np = __read_u8_opaque(p, &targetid->oti_scsi_device_id);\r\n}\r\nreturn p;\r\n}\r\nstatic __be32 *\r\n__read_net_addr(__be32 *p, struct pnfs_osd_net_addr* netaddr)\r\n{\r\np = __read_u8_opaque(p, &netaddr->r_netid);\r\np = __read_u8_opaque(p, &netaddr->r_addr);\r\nreturn p;\r\n}\r\nstatic __be32 *\r\n__read_targetaddr(__be32 *p, struct pnfs_osd_targetaddr *targetaddr)\r\n{\r\nu32 ota_available;\r\nota_available = be32_to_cpup(p++);\r\ntargetaddr->ota_available = ota_available;\r\nif (ota_available)\r\np = __read_net_addr(p, &targetaddr->ota_netaddr);\r\nreturn p;\r\n}\r\nstatic __be32 *\r\n__read_opaque_cred(__be32 *p,\r\nstruct pnfs_osd_opaque_cred *opaque_cred)\r\n{\r\nopaque_cred->cred_len = be32_to_cpu(*p++);\r\nopaque_cred->cred = p;\r\nreturn p + XDR_QUADLEN(opaque_cred->cred_len);\r\n}\r\nstatic __be32 *\r\n__read_object_cred(__be32 *p, struct pnfs_osd_object_cred *comp)\r\n{\r\np = _osd_xdr_decode_objid(p, &comp->oc_object_id);\r\ncomp->oc_osd_version = be32_to_cpup(p++);\r\ncomp->oc_cap_key_sec = be32_to_cpup(p++);\r\np = __read_opaque_cred(p, &comp->oc_cap_key);\r\np = __read_opaque_cred(p, &comp->oc_cap);\r\nreturn p;\r\n}\r\nvoid pnfs_osd_xdr_decode_deviceaddr(\r\nstruct pnfs_osd_deviceaddr *deviceaddr, __be32 *p)\r\n{\r\np = __read_targetid(p, &deviceaddr->oda_targetid);\r\np = __read_targetaddr(p, &deviceaddr->oda_targetaddr);\r\np = xdr_decode_opaque_fixed(p, deviceaddr->oda_lun,\r\nsizeof(deviceaddr->oda_lun));\r\np = __read_u8_opaque(p, &deviceaddr->oda_systemid);\r\np = __read_object_cred(p, &deviceaddr->oda_root_obj_cred);\r\np = __read_u8_opaque(p, &deviceaddr->oda_osdname);\r\ndeviceaddr->oda_osdname.data[deviceaddr->oda_osdname.len] = 0;\r\n}\r\nint\r\npnfs_osd_xdr_encode_layoutupdate(struct xdr_stream *xdr,\r\nstruct pnfs_osd_layoutupdate *lou)\r\n{\r\n__be32 *p = xdr_reserve_space(xdr, 4 + 8 + 4);\r\nif (!p)\r\nreturn -E2BIG;\r\n*p++ = cpu_to_be32(lou->dsu_valid);\r\nif (lou->dsu_valid)\r\np = xdr_encode_hyper(p, lou->dsu_delta);\r\n*p++ = cpu_to_be32(lou->olu_ioerr_flag);\r\nreturn 0;\r\n}\r\nstatic inline __be32 *\r\npnfs_osd_xdr_encode_objid(__be32 *p, struct pnfs_osd_objid *object_id)\r\n{\r\np = xdr_encode_opaque_fixed(p, &object_id->oid_device_id.data,\r\nsizeof(object_id->oid_device_id.data));\r\np = xdr_encode_hyper(p, object_id->oid_partition_id);\r\np = xdr_encode_hyper(p, object_id->oid_object_id);\r\nreturn p;\r\n}\r\nvoid pnfs_osd_xdr_encode_ioerr(__be32 *p, struct pnfs_osd_ioerr *ioerr)\r\n{\r\np = pnfs_osd_xdr_encode_objid(p, &ioerr->oer_component);\r\np = xdr_encode_hyper(p, ioerr->oer_comp_offset);\r\np = xdr_encode_hyper(p, ioerr->oer_comp_length);\r\n*p++ = cpu_to_be32(ioerr->oer_iswrite);\r\n*p = cpu_to_be32(ioerr->oer_errno);\r\n}\r\n__be32 *pnfs_osd_xdr_ioerr_reserve_space(struct xdr_stream *xdr)\r\n{\r\n__be32 *p;\r\np = xdr_reserve_space(xdr, 32 + 24);\r\nif (unlikely(!p))\r\ndprintk("%s: out of xdr space\n", __func__);\r\nreturn p;\r\n}
