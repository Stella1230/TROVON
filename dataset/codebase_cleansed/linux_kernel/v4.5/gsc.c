int gsc_alloc_irq(struct gsc_irq *i)\r\n{\r\nint irq = txn_alloc_irq(GSC_EIM_WIDTH);\r\nif (irq < 0) {\r\nprintk("cannot get irq\n");\r\nreturn irq;\r\n}\r\ni->txn_addr = txn_alloc_addr(irq);\r\ni->txn_data = txn_alloc_data(irq);\r\ni->irq = irq;\r\nreturn irq;\r\n}\r\nint gsc_claim_irq(struct gsc_irq *i, int irq)\r\n{\r\nint c = irq;\r\nirq += CPU_IRQ_BASE;\r\nirq = txn_claim_irq(irq);\r\nif (irq < 0) {\r\nprintk("cannot claim irq %d\n", c);\r\nreturn irq;\r\n}\r\ni->txn_addr = txn_alloc_addr(irq);\r\ni->txn_data = txn_alloc_data(irq);\r\ni->irq = irq;\r\nreturn irq;\r\n}\r\nirqreturn_t gsc_asic_intr(int gsc_asic_irq, void *dev)\r\n{\r\nunsigned long irr;\r\nstruct gsc_asic *gsc_asic = dev;\r\nirr = gsc_readl(gsc_asic->hpa + OFFSET_IRR);\r\nif (irr == 0)\r\nreturn IRQ_NONE;\r\nDEBPRINTK("%s intr, mask=0x%x\n", gsc_asic->name, irr);\r\ndo {\r\nint local_irq = __ffs(irr);\r\nunsigned int irq = gsc_asic->global_irq[local_irq];\r\ngeneric_handle_irq(irq);\r\nirr &= ~(1 << local_irq);\r\n} while (irr);\r\nreturn IRQ_HANDLED;\r\n}\r\nint gsc_find_local_irq(unsigned int irq, int *global_irqs, int limit)\r\n{\r\nint local_irq;\r\nfor (local_irq = 0; local_irq < limit; local_irq++) {\r\nif (global_irqs[local_irq] == irq)\r\nreturn local_irq;\r\n}\r\nreturn NO_IRQ;\r\n}\r\nstatic void gsc_asic_mask_irq(struct irq_data *d)\r\n{\r\nstruct gsc_asic *irq_dev = irq_data_get_irq_chip_data(d);\r\nint local_irq = gsc_find_local_irq(d->irq, irq_dev->global_irq, 32);\r\nu32 imr;\r\nDEBPRINTK(KERN_DEBUG "%s(%d) %s: IMR 0x%x\n", __func__, d->irq,\r\nirq_dev->name, imr);\r\nimr = gsc_readl(irq_dev->hpa + OFFSET_IMR);\r\nimr &= ~(1 << local_irq);\r\ngsc_writel(imr, irq_dev->hpa + OFFSET_IMR);\r\n}\r\nstatic void gsc_asic_unmask_irq(struct irq_data *d)\r\n{\r\nstruct gsc_asic *irq_dev = irq_data_get_irq_chip_data(d);\r\nint local_irq = gsc_find_local_irq(d->irq, irq_dev->global_irq, 32);\r\nu32 imr;\r\nDEBPRINTK(KERN_DEBUG "%s(%d) %s: IMR 0x%x\n", __func__, d->irq,\r\nirq_dev->name, imr);\r\nimr = gsc_readl(irq_dev->hpa + OFFSET_IMR);\r\nimr |= 1 << local_irq;\r\ngsc_writel(imr, irq_dev->hpa + OFFSET_IMR);\r\n}\r\nint gsc_assign_irq(struct irq_chip *type, void *data)\r\n{\r\nstatic int irq = GSC_IRQ_BASE;\r\nif (irq > GSC_IRQ_MAX)\r\nreturn NO_IRQ;\r\nirq_set_chip_and_handler(irq, type, handle_simple_irq);\r\nirq_set_chip_data(irq, data);\r\nreturn irq++;\r\n}\r\nvoid gsc_asic_assign_irq(struct gsc_asic *asic, int local_irq, int *irqp)\r\n{\r\nint irq = asic->global_irq[local_irq];\r\nif (irq <= 0) {\r\nirq = gsc_assign_irq(&gsc_asic_interrupt_type, asic);\r\nif (irq == NO_IRQ)\r\nreturn;\r\nasic->global_irq[local_irq] = irq;\r\n}\r\n*irqp = irq;\r\n}\r\nstatic int gsc_fixup_irqs_callback(struct device *dev, void *data)\r\n{\r\nstruct parisc_device *padev = to_parisc_device(dev);\r\nstruct gsc_fixup_struct *gf = data;\r\nif (padev->id.hw_type == HPHW_FAULTY)\r\ngsc_fixup_irqs(padev, gf->ctrl, gf->choose_irq);\r\ngf->choose_irq(padev, gf->ctrl);\r\nreturn 0;\r\n}\r\nvoid gsc_fixup_irqs(struct parisc_device *parent, void *ctrl,\r\nvoid (*choose_irq)(struct parisc_device *, void *))\r\n{\r\nstruct gsc_fixup_struct data = {\r\n.choose_irq = choose_irq,\r\n.ctrl = ctrl,\r\n};\r\ndevice_for_each_child(&parent->dev, &data, gsc_fixup_irqs_callback);\r\n}\r\nint gsc_common_setup(struct parisc_device *parent, struct gsc_asic *gsc_asic)\r\n{\r\nstruct resource *res;\r\nint i;\r\ngsc_asic->gsc = parent;\r\nfor (i = 0; i < 32; i++) {\r\ngsc_asic->global_irq[i] = NO_IRQ;\r\n}\r\nres = request_mem_region(gsc_asic->hpa, 0x100000, gsc_asic->name);\r\nif (res) {\r\nres->flags = IORESOURCE_MEM;\r\n}\r\n#if 0\r\nprintk(KERN_WARNING "%s IRQ %d EIM 0x%x", gsc_asic->name,\r\nparent->irq, gsc_asic->eim);\r\nif (gsc_readl(gsc_asic->hpa + OFFSET_IMR))\r\nprintk(" IMR is non-zero! (0x%x)",\r\ngsc_readl(gsc_asic->hpa + OFFSET_IMR));\r\nprintk("\n");\r\n#endif\r\nreturn 0;\r\n}\r\nvoid __init gsc_init(void)\r\n{\r\n#ifdef CONFIG_GSC_LASI\r\nregister_parisc_driver(&lasi_driver);\r\nregister_parisc_driver(&asp_driver);\r\n#endif\r\n#ifdef CONFIG_GSC_WAX\r\nregister_parisc_driver(&wax_driver);\r\n#endif\r\n}
