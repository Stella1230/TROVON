int\r\ntsi108_direct_write_config(struct pci_bus *bus, unsigned int devfunc,\r\nint offset, int len, u32 val)\r\n{\r\nvolatile unsigned char *cfg_addr;\r\nstruct pci_controller *hose = pci_bus_to_host(bus);\r\nif (ppc_md.pci_exclude_device)\r\nif (ppc_md.pci_exclude_device(hose, bus->number, devfunc))\r\nreturn PCIBIOS_DEVICE_NOT_FOUND;\r\ncfg_addr = (unsigned char *)(tsi_mk_config_addr(bus->number,\r\ndevfunc, offset) |\r\n(offset & 0x03));\r\n#ifdef DEBUG\r\nprintk("PCI CFG write : ");\r\nprintk("%d:0x%x:0x%x ", bus->number, devfunc, offset);\r\nprintk("%d ADDR=0x%08x ", len, (uint) cfg_addr);\r\nprintk("data = 0x%08x\n", val);\r\n#endif\r\nswitch (len) {\r\ncase 1:\r\nout_8((u8 *) cfg_addr, val);\r\nbreak;\r\ncase 2:\r\nout_le16((u16 *) cfg_addr, val);\r\nbreak;\r\ndefault:\r\nout_le32((u32 *) cfg_addr, val);\r\nbreak;\r\n}\r\nreturn PCIBIOS_SUCCESSFUL;\r\n}\r\nvoid tsi108_clear_pci_error(u32 pci_cfg_base)\r\n{\r\nu32 err_stat, err_addr, pci_stat;\r\nerr_stat = tsi108_read_reg(TSI108_PB_OFFSET + TSI108_PB_ERRCS);\r\nerr_addr = tsi108_read_reg(TSI108_PB_OFFSET + TSI108_PB_AERR);\r\nif (err_stat & TSI108_PB_ERRCS_ES) {\r\ntsi108_write_reg(TSI108_PB_OFFSET + TSI108_PB_ERRCS,\r\nTSI108_PB_ERRCS_ES);\r\ntsi108_write_reg(TSI108_PB_OFFSET + TSI108_PB_ISR,\r\nTSI108_PB_ISR_PBS_RD_ERR);\r\nif ((err_addr & 0xFF000000) == pci_cfg_base) {\r\npci_stat =\r\ntsi108_read_reg(TSI108_PCI_OFFSET + TSI108_PCI_CSR);\r\ntsi108_write_reg(TSI108_PCI_OFFSET + TSI108_PCI_CSR,\r\npci_stat);\r\n}\r\n}\r\nreturn;\r\n}\r\nint\r\ntsi108_direct_read_config(struct pci_bus *bus, unsigned int devfn, int offset,\r\nint len, u32 * val)\r\n{\r\nvolatile unsigned char *cfg_addr;\r\nstruct pci_controller *hose = pci_bus_to_host(bus);\r\nu32 temp;\r\nif (ppc_md.pci_exclude_device)\r\nif (ppc_md.pci_exclude_device(hose, bus->number, devfn))\r\nreturn PCIBIOS_DEVICE_NOT_FOUND;\r\ncfg_addr = (unsigned char *)(tsi_mk_config_addr(bus->number,\r\ndevfn,\r\noffset) | (offset &\r\n0x03));\r\nswitch (len) {\r\ncase 1:\r\n__tsi108_read_pci_config(temp, cfg_addr, "lbzx");\r\nbreak;\r\ncase 2:\r\n__tsi108_read_pci_config(temp, cfg_addr, "lhbrx");\r\nbreak;\r\ndefault:\r\n__tsi108_read_pci_config(temp, cfg_addr, "lwbrx");\r\nbreak;\r\n}\r\n*val = temp;\r\n#ifdef DEBUG\r\nif ((0xFFFFFFFF != temp) && (0xFFFF != temp) && (0xFF != temp)) {\r\nprintk("PCI CFG read : ");\r\nprintk("%d:0x%x:0x%x ", bus->number, devfn, offset);\r\nprintk("%d ADDR=0x%08x ", len, (uint) cfg_addr);\r\nprintk("data = 0x%x\n", *val);\r\n}\r\n#endif\r\nreturn PCIBIOS_SUCCESSFUL;\r\n}\r\nvoid tsi108_clear_pci_cfg_error(void)\r\n{\r\ntsi108_clear_pci_error(tsi108_pci_cfg_phys);\r\n}\r\nint __init tsi108_setup_pci(struct device_node *dev, u32 cfg_phys, int primary)\r\n{\r\nint len;\r\nstruct pci_controller *hose;\r\nstruct resource rsrc;\r\nconst int *bus_range;\r\nint has_address = 0;\r\ntsi108_pci_cfg_base = (u32)ioremap(cfg_phys, TSI108_PCI_CFG_SIZE);\r\ntsi108_pci_cfg_phys = cfg_phys;\r\nDBG("TSI_PCI: %s tsi108_pci_cfg_base=0x%x\n", __func__,\r\ntsi108_pci_cfg_base);\r\nhas_address = (of_address_to_resource(dev, 0, &rsrc) == 0);\r\nbus_range = of_get_property(dev, "bus-range", &len);\r\nif (bus_range == NULL || len < 2 * sizeof(int)) {\r\nprintk(KERN_WARNING "Can't get bus-range for %s, assume"\r\n" bus 0\n", dev->full_name);\r\n}\r\nhose = pcibios_alloc_controller(dev);\r\nif (!hose) {\r\nprintk("PCI Host bridge init failed\n");\r\nreturn -ENOMEM;\r\n}\r\nhose->first_busno = bus_range ? bus_range[0] : 0;\r\nhose->last_busno = bus_range ? bus_range[1] : 0xff;\r\n(hose)->ops = &tsi108_direct_pci_ops;\r\nprintk(KERN_INFO "Found tsi108 PCI host bridge at 0x%08x. "\r\n"Firmware bus number: %d->%d\n",\r\nrsrc.start, hose->first_busno, hose->last_busno);\r\npci_process_bridge_OF_ranges(hose, dev, primary);\r\nreturn 0;\r\n}\r\nstatic void tsi108_pci_int_mask(u_int irq)\r\n{\r\nu_int irp_cfg;\r\nint int_line = (irq - IRQ_PCI_INTAD_BASE);\r\nirp_cfg = tsi108_read_reg(TSI108_PCI_OFFSET + TSI108_PCI_IRP_CFG_CTL);\r\nmb();\r\nirp_cfg |= (1 << int_line);\r\nirp_cfg &= ~(3 << (8 + (int_line * 2)));\r\ntsi108_write_reg(TSI108_PCI_OFFSET + TSI108_PCI_IRP_CFG_CTL, irp_cfg);\r\nmb();\r\nirp_cfg = tsi108_read_reg(TSI108_PCI_OFFSET + TSI108_PCI_IRP_CFG_CTL);\r\n}\r\nstatic void tsi108_pci_int_unmask(u_int irq)\r\n{\r\nu_int irp_cfg;\r\nint int_line = (irq - IRQ_PCI_INTAD_BASE);\r\nirp_cfg = tsi108_read_reg(TSI108_PCI_OFFSET + TSI108_PCI_IRP_CFG_CTL);\r\nmb();\r\nirp_cfg &= ~(1 << int_line);\r\nirp_cfg |= (3 << (8 + (int_line * 2)));\r\ntsi108_write_reg(TSI108_PCI_OFFSET + TSI108_PCI_IRP_CFG_CTL, irp_cfg);\r\nmb();\r\n}\r\nstatic void init_pci_source(void)\r\n{\r\ntsi108_write_reg(TSI108_PCI_OFFSET + TSI108_PCI_IRP_CFG_CTL,\r\n0x0000ff00);\r\ntsi108_write_reg(TSI108_PCI_OFFSET + TSI108_PCI_IRP_ENABLE,\r\nTSI108_PCI_IRP_ENABLE_P_INT);\r\nmb();\r\n}\r\nstatic inline unsigned int get_pci_source(void)\r\n{\r\nu_int temp = 0;\r\nint irq = -1;\r\nint i;\r\nu_int pci_irp_stat;\r\nstatic int mask = 0;\r\npci_irp_stat = tsi108_read_reg(TSI108_PCI_OFFSET + TSI108_PCI_IRP_STAT);\r\nmb();\r\nif (pci_irp_stat & TSI108_PCI_IRP_STAT_P_INT) {\r\ntemp =\r\ntsi108_read_reg(TSI108_PCI_OFFSET +\r\nTSI108_PCI_IRP_INTAD) & 0xf;\r\nmb();\r\nfor (i = 0; i < 4; i++, mask++) {\r\nif (temp & (1 << mask % 4)) {\r\nirq = IRQ_PCI_INTA + mask % 4;\r\nmask++;\r\nbreak;\r\n}\r\n}\r\ntemp = tsi108_read_reg(TSI108_PCI_OFFSET + TSI108_PCI_IRP_ENABLE);\r\ntsi108_write_reg(TSI108_PCI_OFFSET + TSI108_PCI_IRP_ENABLE,\r\ntemp & ~TSI108_PCI_IRP_ENABLE_P_INT);\r\nmb();\r\n(void)tsi108_read_reg(TSI108_PCI_OFFSET + TSI108_PCI_IRP_ENABLE);\r\nmb();\r\n}\r\n#ifdef DEBUG\r\nelse {\r\nprintk("TSI108_PIC: error in TSI108_PCI_IRP_STAT\n");\r\npci_irp_stat =\r\ntsi108_read_reg(TSI108_PCI_OFFSET + TSI108_PCI_IRP_STAT);\r\ntemp =\r\ntsi108_read_reg(TSI108_PCI_OFFSET + TSI108_PCI_IRP_INTAD);\r\nmb();\r\nprintk(">> stat=0x%08x intad=0x%08x ", pci_irp_stat, temp);\r\ntemp =\r\ntsi108_read_reg(TSI108_PCI_OFFSET + TSI108_PCI_IRP_CFG_CTL);\r\nmb();\r\nprintk("cfg_ctl=0x%08x ", temp);\r\ntemp =\r\ntsi108_read_reg(TSI108_PCI_OFFSET + TSI108_PCI_IRP_ENABLE);\r\nmb();\r\nprintk("irp_enable=0x%08x\n", temp);\r\n}\r\n#endif\r\nreturn irq;\r\n}\r\nstatic void tsi108_pci_irq_unmask(struct irq_data *d)\r\n{\r\ntsi108_pci_int_unmask(d->irq);\r\ntsi108_write_reg(TSI108_PCI_OFFSET + TSI108_PCI_IRP_ENABLE,\r\ntsi108_read_reg(TSI108_PCI_OFFSET +\r\nTSI108_PCI_IRP_ENABLE) |\r\nTSI108_PCI_IRP_ENABLE_P_INT);\r\nmb();\r\n}\r\nstatic void tsi108_pci_irq_mask(struct irq_data *d)\r\n{\r\ntsi108_pci_int_mask(d->irq);\r\n}\r\nstatic void tsi108_pci_irq_ack(struct irq_data *d)\r\n{\r\ntsi108_pci_int_mask(d->irq);\r\n}\r\nstatic int pci_irq_host_xlate(struct irq_domain *h, struct device_node *ct,\r\nconst u32 *intspec, unsigned int intsize,\r\nirq_hw_number_t *out_hwirq, unsigned int *out_flags)\r\n{\r\n*out_hwirq = intspec[0];\r\n*out_flags = IRQ_TYPE_LEVEL_HIGH;\r\nreturn 0;\r\n}\r\nstatic int pci_irq_host_map(struct irq_domain *h, unsigned int virq,\r\nirq_hw_number_t hw)\r\n{ unsigned int irq;\r\nDBG("%s(%d, 0x%lx)\n", __func__, virq, hw);\r\nif ((virq >= 1) && (virq <= 4)){\r\nirq = virq + IRQ_PCI_INTAD_BASE - 1;\r\nirq_set_status_flags(irq, IRQ_LEVEL);\r\nirq_set_chip(irq, &tsi108_pci_irq);\r\n}\r\nreturn 0;\r\n}\r\nvoid __init tsi108_pci_int_init(struct device_node *node)\r\n{\r\nDBG("Tsi108_pci_int_init: initializing PCI interrupts\n");\r\npci_irq_host = irq_domain_add_legacy_isa(node, &pci_irq_domain_ops, NULL);\r\nif (pci_irq_host == NULL) {\r\nprintk(KERN_ERR "pci_irq_host: failed to allocate irq domain!\n");\r\nreturn;\r\n}\r\ninit_pci_source();\r\n}\r\nvoid tsi108_irq_cascade(struct irq_desc *desc)\r\n{\r\nstruct irq_chip *chip = irq_desc_get_chip(desc);\r\nunsigned int cascade_irq = get_pci_source();\r\nif (cascade_irq != NO_IRQ)\r\ngeneric_handle_irq(cascade_irq);\r\nchip->irq_eoi(&desc->irq_data);\r\n}
