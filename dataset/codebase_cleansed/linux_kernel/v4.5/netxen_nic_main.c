void\r\nnetxen_nic_update_cmd_producer(struct netxen_adapter *adapter,\r\nstruct nx_host_tx_ring *tx_ring)\r\n{\r\nNXWRIO(adapter, tx_ring->crb_cmd_producer, tx_ring->producer);\r\n}\r\nstatic inline void\r\nnetxen_nic_update_cmd_consumer(struct netxen_adapter *adapter,\r\nstruct nx_host_tx_ring *tx_ring)\r\n{\r\nNXWRIO(adapter, tx_ring->crb_cmd_consumer, tx_ring->sw_consumer);\r\n}\r\nstatic inline void netxen_nic_disable_int(struct nx_host_sds_ring *sds_ring)\r\n{\r\nstruct netxen_adapter *adapter = sds_ring->adapter;\r\nNXWRIO(adapter, sds_ring->crb_intr_mask, 0);\r\n}\r\nstatic inline void netxen_nic_enable_int(struct nx_host_sds_ring *sds_ring)\r\n{\r\nstruct netxen_adapter *adapter = sds_ring->adapter;\r\nNXWRIO(adapter, sds_ring->crb_intr_mask, 0x1);\r\nif (!NETXEN_IS_MSI_FAMILY(adapter))\r\nNXWRIO(adapter, adapter->tgt_mask_reg, 0xfbff);\r\n}\r\nstatic int\r\nnetxen_alloc_sds_rings(struct netxen_recv_context *recv_ctx, int count)\r\n{\r\nint size = sizeof(struct nx_host_sds_ring) * count;\r\nrecv_ctx->sds_rings = kzalloc(size, GFP_KERNEL);\r\nreturn recv_ctx->sds_rings == NULL;\r\n}\r\nstatic void\r\nnetxen_free_sds_rings(struct netxen_recv_context *recv_ctx)\r\n{\r\nkfree(recv_ctx->sds_rings);\r\nrecv_ctx->sds_rings = NULL;\r\n}\r\nstatic int\r\nnetxen_napi_add(struct netxen_adapter *adapter, struct net_device *netdev)\r\n{\r\nint ring;\r\nstruct nx_host_sds_ring *sds_ring;\r\nstruct netxen_recv_context *recv_ctx = &adapter->recv_ctx;\r\nif (netxen_alloc_sds_rings(recv_ctx, adapter->max_sds_rings))\r\nreturn -ENOMEM;\r\nfor (ring = 0; ring < adapter->max_sds_rings; ring++) {\r\nsds_ring = &recv_ctx->sds_rings[ring];\r\nnetif_napi_add(netdev, &sds_ring->napi,\r\nnetxen_nic_poll, NAPI_POLL_WEIGHT);\r\n}\r\nreturn 0;\r\n}\r\nstatic void\r\nnetxen_napi_del(struct netxen_adapter *adapter)\r\n{\r\nint ring;\r\nstruct nx_host_sds_ring *sds_ring;\r\nstruct netxen_recv_context *recv_ctx = &adapter->recv_ctx;\r\nfor (ring = 0; ring < adapter->max_sds_rings; ring++) {\r\nsds_ring = &recv_ctx->sds_rings[ring];\r\nnetif_napi_del(&sds_ring->napi);\r\n}\r\nnetxen_free_sds_rings(&adapter->recv_ctx);\r\n}\r\nstatic void\r\nnetxen_napi_enable(struct netxen_adapter *adapter)\r\n{\r\nint ring;\r\nstruct nx_host_sds_ring *sds_ring;\r\nstruct netxen_recv_context *recv_ctx = &adapter->recv_ctx;\r\nfor (ring = 0; ring < adapter->max_sds_rings; ring++) {\r\nsds_ring = &recv_ctx->sds_rings[ring];\r\nnapi_enable(&sds_ring->napi);\r\nnetxen_nic_enable_int(sds_ring);\r\n}\r\n}\r\nstatic void\r\nnetxen_napi_disable(struct netxen_adapter *adapter)\r\n{\r\nint ring;\r\nstruct nx_host_sds_ring *sds_ring;\r\nstruct netxen_recv_context *recv_ctx = &adapter->recv_ctx;\r\nfor (ring = 0; ring < adapter->max_sds_rings; ring++) {\r\nsds_ring = &recv_ctx->sds_rings[ring];\r\nnetxen_nic_disable_int(sds_ring);\r\nnapi_synchronize(&sds_ring->napi);\r\nnapi_disable(&sds_ring->napi);\r\n}\r\n}\r\nstatic int nx_set_dma_mask(struct netxen_adapter *adapter)\r\n{\r\nstruct pci_dev *pdev = adapter->pdev;\r\nuint64_t mask, cmask;\r\nadapter->pci_using_dac = 0;\r\nmask = DMA_BIT_MASK(32);\r\ncmask = DMA_BIT_MASK(32);\r\nif (NX_IS_REVISION_P2(adapter->ahw.revision_id)) {\r\n#ifndef CONFIG_IA64\r\nmask = DMA_BIT_MASK(35);\r\n#endif\r\n} else {\r\nmask = DMA_BIT_MASK(39);\r\ncmask = mask;\r\n}\r\nif (pci_set_dma_mask(pdev, mask) == 0 &&\r\npci_set_consistent_dma_mask(pdev, cmask) == 0) {\r\nadapter->pci_using_dac = 1;\r\nreturn 0;\r\n}\r\nreturn -EIO;\r\n}\r\nstatic int\r\nnx_update_dma_mask(struct netxen_adapter *adapter)\r\n{\r\nint change, shift, err;\r\nuint64_t mask, old_mask, old_cmask;\r\nstruct pci_dev *pdev = adapter->pdev;\r\nchange = 0;\r\nshift = NXRD32(adapter, CRB_DMA_SHIFT);\r\nif (shift > 32)\r\nreturn 0;\r\nif (NX_IS_REVISION_P3(adapter->ahw.revision_id) && (shift > 9))\r\nchange = 1;\r\nelse if ((adapter->ahw.revision_id == NX_P2_C1) && (shift <= 4))\r\nchange = 1;\r\nif (change) {\r\nold_mask = pdev->dma_mask;\r\nold_cmask = pdev->dev.coherent_dma_mask;\r\nmask = DMA_BIT_MASK(32+shift);\r\nerr = pci_set_dma_mask(pdev, mask);\r\nif (err)\r\ngoto err_out;\r\nif (NX_IS_REVISION_P3(adapter->ahw.revision_id)) {\r\nerr = pci_set_consistent_dma_mask(pdev, mask);\r\nif (err)\r\ngoto err_out;\r\n}\r\ndev_info(&pdev->dev, "using %d-bit dma mask\n", 32+shift);\r\n}\r\nreturn 0;\r\nerr_out:\r\npci_set_dma_mask(pdev, old_mask);\r\npci_set_consistent_dma_mask(pdev, old_cmask);\r\nreturn err;\r\n}\r\nstatic int\r\nnetxen_check_hw_init(struct netxen_adapter *adapter, int first_boot)\r\n{\r\nu32 val, timeout;\r\nif (first_boot == 0x55555555) {\r\nNXWR32(adapter, NETXEN_CAM_RAM(0x1fc), NETXEN_BDINFO_MAGIC);\r\nif (!NX_IS_REVISION_P2(adapter->ahw.revision_id))\r\nreturn 0;\r\nfirst_boot = NXRD32(adapter, NETXEN_PCIE_REG(0x4));\r\nif (!(first_boot & 0x4)) {\r\nfirst_boot |= 0x4;\r\nNXWR32(adapter, NETXEN_PCIE_REG(0x4), first_boot);\r\nNXRD32(adapter, NETXEN_PCIE_REG(0x4));\r\n}\r\nfirst_boot = NXRD32(adapter, NETXEN_ROMUSB_GLB_SW_RESET);\r\nif (first_boot != 0x80000f) {\r\nNXWR32(adapter, NETXEN_CAM_RAM(0x1fc), 0);\r\nreturn -EIO;\r\n}\r\nval = NXRD32(adapter, NETXEN_ROMUSB_GLB_PEGTUNE_DONE);\r\nNXWR32(adapter, NETXEN_ROMUSB_GLB_PEGTUNE_DONE, val | 0x1);\r\ntimeout = 0;\r\ndo {\r\nmsleep(1);\r\nval = NXRD32(adapter, NETXEN_CAM_RAM(0x1fc));\r\nif (++timeout > 5000)\r\nreturn -EIO;\r\n} while (val == NETXEN_BDINFO_MAGIC);\r\n}\r\nreturn 0;\r\n}\r\nstatic void netxen_set_port_mode(struct netxen_adapter *adapter)\r\n{\r\nu32 val, data;\r\nval = adapter->ahw.board_type;\r\nif ((val == NETXEN_BRDTYPE_P3_HMEZ) ||\r\n(val == NETXEN_BRDTYPE_P3_XG_LOM)) {\r\nif (port_mode == NETXEN_PORT_MODE_802_3_AP) {\r\ndata = NETXEN_PORT_MODE_802_3_AP;\r\nNXWR32(adapter, NETXEN_PORT_MODE_ADDR, data);\r\n} else if (port_mode == NETXEN_PORT_MODE_XG) {\r\ndata = NETXEN_PORT_MODE_XG;\r\nNXWR32(adapter, NETXEN_PORT_MODE_ADDR, data);\r\n} else if (port_mode == NETXEN_PORT_MODE_AUTO_NEG_1G) {\r\ndata = NETXEN_PORT_MODE_AUTO_NEG_1G;\r\nNXWR32(adapter, NETXEN_PORT_MODE_ADDR, data);\r\n} else if (port_mode == NETXEN_PORT_MODE_AUTO_NEG_XG) {\r\ndata = NETXEN_PORT_MODE_AUTO_NEG_XG;\r\nNXWR32(adapter, NETXEN_PORT_MODE_ADDR, data);\r\n} else {\r\ndata = NETXEN_PORT_MODE_AUTO_NEG;\r\nNXWR32(adapter, NETXEN_PORT_MODE_ADDR, data);\r\n}\r\nif ((wol_port_mode != NETXEN_PORT_MODE_802_3_AP) &&\r\n(wol_port_mode != NETXEN_PORT_MODE_XG) &&\r\n(wol_port_mode != NETXEN_PORT_MODE_AUTO_NEG_1G) &&\r\n(wol_port_mode != NETXEN_PORT_MODE_AUTO_NEG_XG)) {\r\nwol_port_mode = NETXEN_PORT_MODE_AUTO_NEG;\r\n}\r\nNXWR32(adapter, NETXEN_WOL_PORT_MODE, wol_port_mode);\r\n}\r\n}\r\nstatic void netxen_pcie_strap_init(struct netxen_adapter *adapter)\r\n{\r\nu32 pdevfuncsave;\r\nu32 c8c9value = 0;\r\nu32 chicken = 0;\r\nu32 control = 0;\r\nint i, pos;\r\nstruct pci_dev *pdev;\r\npdev = adapter->pdev;\r\nchicken = NXRD32(adapter, NETXEN_PCIE_REG(PCIE_CHICKEN3));\r\nchicken &= 0xFCFFFFFF;\r\npos = pci_find_capability(pdev, PCI_CAP_ID_GEN);\r\nif (pos == 0xC0) {\r\npci_read_config_dword(pdev, pos + 0x10, &control);\r\nif ((control & 0x000F0000) != 0x00020000) {\r\nchicken |= 0x01000000;\r\n}\r\ndev_info(&adapter->pdev->dev, "Gen2 strapping detected\n");\r\nc8c9value = 0xF1000;\r\n} else {\r\nchicken |= 0x01000000;\r\ndev_info(&adapter->pdev->dev, "Gen1 strapping detected\n");\r\nif (adapter->ahw.revision_id == NX_P3_B0)\r\nc8c9value = 0xF1020;\r\nelse\r\nc8c9value = 0;\r\n}\r\nNXWR32(adapter, NETXEN_PCIE_REG(PCIE_CHICKEN3), chicken);\r\nif (!c8c9value)\r\nreturn;\r\npdevfuncsave = pdev->devfn;\r\nif (pdevfuncsave & 0x07)\r\nreturn;\r\nfor (i = 0; i < 8; i++) {\r\npci_read_config_dword(pdev, pos + 8, &control);\r\npci_read_config_dword(pdev, pos + 8, &control);\r\npci_write_config_dword(pdev, pos + 8, c8c9value);\r\npdev->devfn++;\r\n}\r\npdev->devfn = pdevfuncsave;\r\n}\r\nstatic void netxen_set_msix_bit(struct pci_dev *pdev, int enable)\r\n{\r\nu32 control;\r\nif (pdev->msix_cap) {\r\npci_read_config_dword(pdev, pdev->msix_cap, &control);\r\nif (enable)\r\ncontrol |= PCI_MSIX_FLAGS_ENABLE;\r\nelse\r\ncontrol = 0;\r\npci_write_config_dword(pdev, pdev->msix_cap, control);\r\n}\r\n}\r\nstatic void netxen_init_msix_entries(struct netxen_adapter *adapter, int count)\r\n{\r\nint i;\r\nfor (i = 0; i < count; i++)\r\nadapter->msix_entries[i].entry = i;\r\n}\r\nstatic int\r\nnetxen_read_mac_addr(struct netxen_adapter *adapter)\r\n{\r\nint i;\r\nunsigned char *p;\r\nu64 mac_addr;\r\nstruct net_device *netdev = adapter->netdev;\r\nstruct pci_dev *pdev = adapter->pdev;\r\nif (NX_IS_REVISION_P3(adapter->ahw.revision_id)) {\r\nif (netxen_p3_get_mac_addr(adapter, &mac_addr) != 0)\r\nreturn -EIO;\r\n} else {\r\nif (netxen_get_flash_mac_addr(adapter, &mac_addr) != 0)\r\nreturn -EIO;\r\n}\r\np = (unsigned char *)&mac_addr;\r\nfor (i = 0; i < 6; i++)\r\nnetdev->dev_addr[i] = *(p + 5 - i);\r\nmemcpy(adapter->mac_addr, netdev->dev_addr, netdev->addr_len);\r\nif (!is_valid_ether_addr(netdev->dev_addr))\r\ndev_warn(&pdev->dev, "Bad MAC address %pM.\n", netdev->dev_addr);\r\nreturn 0;\r\n}\r\nstatic int netxen_nic_set_mac(struct net_device *netdev, void *p)\r\n{\r\nstruct netxen_adapter *adapter = netdev_priv(netdev);\r\nstruct sockaddr *addr = p;\r\nif (!is_valid_ether_addr(addr->sa_data))\r\nreturn -EADDRNOTAVAIL;\r\nif (netif_running(netdev)) {\r\nnetif_device_detach(netdev);\r\nnetxen_napi_disable(adapter);\r\n}\r\nmemcpy(adapter->mac_addr, addr->sa_data, netdev->addr_len);\r\nmemcpy(netdev->dev_addr, addr->sa_data, netdev->addr_len);\r\nadapter->macaddr_set(adapter, addr->sa_data);\r\nif (netif_running(netdev)) {\r\nnetif_device_attach(netdev);\r\nnetxen_napi_enable(adapter);\r\n}\r\nreturn 0;\r\n}\r\nstatic void netxen_set_multicast_list(struct net_device *dev)\r\n{\r\nstruct netxen_adapter *adapter = netdev_priv(dev);\r\nadapter->set_multi(dev);\r\n}\r\nstatic netdev_features_t netxen_fix_features(struct net_device *dev,\r\nnetdev_features_t features)\r\n{\r\nif (!(features & NETIF_F_RXCSUM)) {\r\nnetdev_info(dev, "disabling LRO as RXCSUM is off\n");\r\nfeatures &= ~NETIF_F_LRO;\r\n}\r\nreturn features;\r\n}\r\nstatic int netxen_set_features(struct net_device *dev,\r\nnetdev_features_t features)\r\n{\r\nstruct netxen_adapter *adapter = netdev_priv(dev);\r\nint hw_lro;\r\nif (!((dev->features ^ features) & NETIF_F_LRO))\r\nreturn 0;\r\nhw_lro = (features & NETIF_F_LRO) ? NETXEN_NIC_LRO_ENABLED\r\n: NETXEN_NIC_LRO_DISABLED;\r\nif (netxen_config_hw_lro(adapter, hw_lro))\r\nreturn -EIO;\r\nif (!(features & NETIF_F_LRO) && netxen_send_lro_cleanup(adapter))\r\nreturn -EIO;\r\nreturn 0;\r\n}\r\nstatic inline bool netxen_function_zero(struct pci_dev *pdev)\r\n{\r\nreturn (PCI_FUNC(pdev->devfn) == 0) ? true : false;\r\n}\r\nstatic inline void netxen_set_interrupt_mode(struct netxen_adapter *adapter,\r\nu32 mode)\r\n{\r\nNXWR32(adapter, NETXEN_INTR_MODE_REG, mode);\r\n}\r\nstatic inline u32 netxen_get_interrupt_mode(struct netxen_adapter *adapter)\r\n{\r\nreturn NXRD32(adapter, NETXEN_INTR_MODE_REG);\r\n}\r\nstatic void\r\nnetxen_initialize_interrupt_registers(struct netxen_adapter *adapter)\r\n{\r\nstruct netxen_legacy_intr_set *legacy_intrp;\r\nu32 tgt_status_reg, int_state_reg;\r\nif (adapter->ahw.revision_id >= NX_P3_B0)\r\nlegacy_intrp = &legacy_intr[adapter->ahw.pci_func];\r\nelse\r\nlegacy_intrp = &legacy_intr[0];\r\ntgt_status_reg = legacy_intrp->tgt_status_reg;\r\nint_state_reg = ISR_INT_STATE_REG;\r\nadapter->int_vec_bit = legacy_intrp->int_vec_bit;\r\nadapter->tgt_status_reg = netxen_get_ioaddr(adapter, tgt_status_reg);\r\nadapter->tgt_mask_reg = netxen_get_ioaddr(adapter,\r\nlegacy_intrp->tgt_mask_reg);\r\nadapter->pci_int_reg = netxen_get_ioaddr(adapter,\r\nlegacy_intrp->pci_int_reg);\r\nadapter->isr_int_vec = netxen_get_ioaddr(adapter, ISR_INT_VECTOR);\r\nif (adapter->ahw.revision_id >= NX_P3_B1)\r\nadapter->crb_int_state_reg = netxen_get_ioaddr(adapter,\r\nint_state_reg);\r\nelse\r\nadapter->crb_int_state_reg = netxen_get_ioaddr(adapter,\r\nCRB_INT_VECTOR);\r\n}\r\nstatic int netxen_setup_msi_interrupts(struct netxen_adapter *adapter,\r\nint num_msix)\r\n{\r\nstruct pci_dev *pdev = adapter->pdev;\r\nu32 value;\r\nint err;\r\nif (adapter->msix_supported) {\r\nnetxen_init_msix_entries(adapter, num_msix);\r\nerr = pci_enable_msix_range(pdev, adapter->msix_entries,\r\nnum_msix, num_msix);\r\nif (err > 0) {\r\nadapter->flags |= NETXEN_NIC_MSIX_ENABLED;\r\nnetxen_set_msix_bit(pdev, 1);\r\nif (adapter->rss_supported)\r\nadapter->max_sds_rings = num_msix;\r\ndev_info(&pdev->dev, "using msi-x interrupts\n");\r\nreturn 0;\r\n}\r\n}\r\nif (use_msi && !pci_enable_msi(pdev)) {\r\nvalue = msi_tgt_status[adapter->ahw.pci_func];\r\nadapter->flags |= NETXEN_NIC_MSI_ENABLED;\r\nadapter->tgt_status_reg = netxen_get_ioaddr(adapter, value);\r\nadapter->msix_entries[0].vector = pdev->irq;\r\ndev_info(&pdev->dev, "using msi interrupts\n");\r\nreturn 0;\r\n}\r\ndev_err(&pdev->dev, "Failed to acquire MSI-X/MSI interrupt vector\n");\r\nreturn -EIO;\r\n}\r\nstatic int netxen_setup_intr(struct netxen_adapter *adapter)\r\n{\r\nstruct pci_dev *pdev = adapter->pdev;\r\nint num_msix;\r\nif (adapter->rss_supported)\r\nnum_msix = (num_online_cpus() >= MSIX_ENTRIES_PER_ADAPTER) ?\r\nMSIX_ENTRIES_PER_ADAPTER : 2;\r\nelse\r\nnum_msix = 1;\r\nadapter->max_sds_rings = 1;\r\nadapter->flags &= ~(NETXEN_NIC_MSI_ENABLED | NETXEN_NIC_MSIX_ENABLED);\r\nnetxen_initialize_interrupt_registers(adapter);\r\nnetxen_set_msix_bit(pdev, 0);\r\nif (netxen_function_zero(pdev)) {\r\nif (!netxen_setup_msi_interrupts(adapter, num_msix))\r\nnetxen_set_interrupt_mode(adapter, NETXEN_MSI_MODE);\r\nelse\r\nnetxen_set_interrupt_mode(adapter, NETXEN_INTX_MODE);\r\n} else {\r\nif (netxen_get_interrupt_mode(adapter) == NETXEN_MSI_MODE &&\r\nnetxen_setup_msi_interrupts(adapter, num_msix)) {\r\ndev_err(&pdev->dev, "Co-existence of MSI-X/MSI and INTx interrupts is not supported\n");\r\nreturn -EIO;\r\n}\r\n}\r\nif (!NETXEN_IS_MSI_FAMILY(adapter)) {\r\nadapter->msix_entries[0].vector = pdev->irq;\r\ndev_info(&pdev->dev, "using legacy interrupts\n");\r\n}\r\nreturn 0;\r\n}\r\nstatic void\r\nnetxen_teardown_intr(struct netxen_adapter *adapter)\r\n{\r\nif (adapter->flags & NETXEN_NIC_MSIX_ENABLED)\r\npci_disable_msix(adapter->pdev);\r\nif (adapter->flags & NETXEN_NIC_MSI_ENABLED)\r\npci_disable_msi(adapter->pdev);\r\n}\r\nstatic void\r\nnetxen_cleanup_pci_map(struct netxen_adapter *adapter)\r\n{\r\nif (adapter->ahw.db_base != NULL)\r\niounmap(adapter->ahw.db_base);\r\nif (adapter->ahw.pci_base0 != NULL)\r\niounmap(adapter->ahw.pci_base0);\r\nif (adapter->ahw.pci_base1 != NULL)\r\niounmap(adapter->ahw.pci_base1);\r\nif (adapter->ahw.pci_base2 != NULL)\r\niounmap(adapter->ahw.pci_base2);\r\n}\r\nstatic int\r\nnetxen_setup_pci_map(struct netxen_adapter *adapter)\r\n{\r\nvoid __iomem *db_ptr = NULL;\r\nresource_size_t mem_base, db_base;\r\nunsigned long mem_len, db_len = 0;\r\nstruct pci_dev *pdev = adapter->pdev;\r\nint pci_func = adapter->ahw.pci_func;\r\nstruct netxen_hardware_context *ahw = &adapter->ahw;\r\nint err = 0;\r\nadapter->ahw.crb_win = -1;\r\nadapter->ahw.ocm_win = -1;\r\nmem_base = pci_resource_start(pdev, 0);\r\nmem_len = pci_resource_len(pdev, 0);\r\nif (mem_len == NETXEN_PCI_128MB_SIZE) {\r\nahw->pci_base0 = ioremap(mem_base, FIRST_PAGE_GROUP_SIZE);\r\nahw->pci_base1 = ioremap(mem_base + SECOND_PAGE_GROUP_START,\r\nSECOND_PAGE_GROUP_SIZE);\r\nahw->pci_base2 = ioremap(mem_base + THIRD_PAGE_GROUP_START,\r\nTHIRD_PAGE_GROUP_SIZE);\r\nif (ahw->pci_base0 == NULL || ahw->pci_base1 == NULL ||\r\nahw->pci_base2 == NULL) {\r\ndev_err(&pdev->dev, "failed to map PCI bar 0\n");\r\nerr = -EIO;\r\ngoto err_out;\r\n}\r\nahw->pci_len0 = FIRST_PAGE_GROUP_SIZE;\r\n} else if (mem_len == NETXEN_PCI_32MB_SIZE) {\r\nahw->pci_base1 = ioremap(mem_base, SECOND_PAGE_GROUP_SIZE);\r\nahw->pci_base2 = ioremap(mem_base + THIRD_PAGE_GROUP_START -\r\nSECOND_PAGE_GROUP_START, THIRD_PAGE_GROUP_SIZE);\r\nif (ahw->pci_base1 == NULL || ahw->pci_base2 == NULL) {\r\ndev_err(&pdev->dev, "failed to map PCI bar 0\n");\r\nerr = -EIO;\r\ngoto err_out;\r\n}\r\n} else if (mem_len == NETXEN_PCI_2MB_SIZE) {\r\nahw->pci_base0 = pci_ioremap_bar(pdev, 0);\r\nif (ahw->pci_base0 == NULL) {\r\ndev_err(&pdev->dev, "failed to map PCI bar 0\n");\r\nreturn -EIO;\r\n}\r\nahw->pci_len0 = mem_len;\r\n} else {\r\nreturn -EIO;\r\n}\r\nnetxen_setup_hwops(adapter);\r\ndev_info(&pdev->dev, "%dMB memory map\n", (int)(mem_len>>20));\r\nif (NX_IS_REVISION_P3P(adapter->ahw.revision_id)) {\r\nadapter->ahw.ocm_win_crb = netxen_get_ioaddr(adapter,\r\nNETXEN_PCIX_PS_REG(PCIX_OCM_WINDOW_REG(pci_func)));\r\n} else if (NX_IS_REVISION_P3(adapter->ahw.revision_id)) {\r\nadapter->ahw.ocm_win_crb = netxen_get_ioaddr(adapter,\r\nNETXEN_PCIX_PS_REG(PCIE_MN_WINDOW_REG(pci_func)));\r\n}\r\nif (NX_IS_REVISION_P3(adapter->ahw.revision_id))\r\ngoto skip_doorbell;\r\ndb_base = pci_resource_start(pdev, 4);\r\ndb_len = pci_resource_len(pdev, 4);\r\nif (db_len == 0) {\r\nprintk(KERN_ERR "%s: doorbell is disabled\n",\r\nnetxen_nic_driver_name);\r\nerr = -EIO;\r\ngoto err_out;\r\n}\r\ndb_ptr = ioremap(db_base, NETXEN_DB_MAPSIZE_BYTES);\r\nif (!db_ptr) {\r\nprintk(KERN_ERR "%s: Failed to allocate doorbell map.",\r\nnetxen_nic_driver_name);\r\nerr = -EIO;\r\ngoto err_out;\r\n}\r\nskip_doorbell:\r\nadapter->ahw.db_base = db_ptr;\r\nadapter->ahw.db_len = db_len;\r\nreturn 0;\r\nerr_out:\r\nnetxen_cleanup_pci_map(adapter);\r\nreturn err;\r\n}\r\nstatic void\r\nnetxen_check_options(struct netxen_adapter *adapter)\r\n{\r\nu32 fw_major, fw_minor, fw_build, prev_fw_version;\r\nchar brd_name[NETXEN_MAX_SHORT_NAME];\r\nchar serial_num[32];\r\nint i, offset, val, err;\r\n__le32 *ptr32;\r\nstruct pci_dev *pdev = adapter->pdev;\r\nadapter->driver_mismatch = 0;\r\nptr32 = (__le32 *)&serial_num;\r\noffset = NX_FW_SERIAL_NUM_OFFSET;\r\nfor (i = 0; i < 8; i++) {\r\nif (netxen_rom_fast_read(adapter, offset, &val) == -1) {\r\ndev_err(&pdev->dev, "error reading board info\n");\r\nadapter->driver_mismatch = 1;\r\nreturn;\r\n}\r\nptr32[i] = cpu_to_le32(val);\r\noffset += sizeof(u32);\r\n}\r\nfw_major = NXRD32(adapter, NETXEN_FW_VERSION_MAJOR);\r\nfw_minor = NXRD32(adapter, NETXEN_FW_VERSION_MINOR);\r\nfw_build = NXRD32(adapter, NETXEN_FW_VERSION_SUB);\r\nprev_fw_version = adapter->fw_version;\r\nadapter->fw_version = NETXEN_VERSION_CODE(fw_major, fw_minor, fw_build);\r\nif (NX_IS_REVISION_P3(adapter->ahw.revision_id)) {\r\nif (adapter->mdump.md_template == NULL ||\r\nadapter->fw_version > prev_fw_version) {\r\nkfree(adapter->mdump.md_template);\r\nadapter->mdump.md_template = NULL;\r\nerr = netxen_setup_minidump(adapter);\r\nif (err)\r\ndev_err(&adapter->pdev->dev,\r\n"Failed to setup minidump rcode = %d\n", err);\r\n}\r\n}\r\nif (adapter->portnum == 0) {\r\nif (netxen_nic_get_brd_name_by_type(adapter->ahw.board_type,\r\nbrd_name))\r\nstrcpy(serial_num, "Unknown");\r\npr_info("%s: %s Board S/N %s Chip rev 0x%x\n",\r\nmodule_name(THIS_MODULE),\r\nbrd_name, serial_num, adapter->ahw.revision_id);\r\n}\r\nif (adapter->fw_version < NETXEN_VERSION_CODE(3, 4, 216)) {\r\nadapter->driver_mismatch = 1;\r\ndev_warn(&pdev->dev, "firmware version %d.%d.%d unsupported\n",\r\nfw_major, fw_minor, fw_build);\r\nreturn;\r\n}\r\nif (NX_IS_REVISION_P3(adapter->ahw.revision_id)) {\r\ni = NXRD32(adapter, NETXEN_SRE_MISC);\r\nadapter->ahw.cut_through = (i & 0x8000) ? 1 : 0;\r\n}\r\ndev_info(&pdev->dev, "Driver v%s, firmware v%d.%d.%d [%s]\n",\r\nNETXEN_NIC_LINUX_VERSIONID, fw_major, fw_minor, fw_build,\r\nadapter->ahw.cut_through ? "cut-through" : "legacy");\r\nif (adapter->fw_version >= NETXEN_VERSION_CODE(4, 0, 222))\r\nadapter->capabilities = NXRD32(adapter, CRB_FW_CAPABILITIES_1);\r\nif (adapter->ahw.port_type == NETXEN_NIC_XGBE) {\r\nadapter->num_rxd = DEFAULT_RCV_DESCRIPTORS_10G;\r\nadapter->num_jumbo_rxd = MAX_JUMBO_RCV_DESCRIPTORS_10G;\r\n} else if (adapter->ahw.port_type == NETXEN_NIC_GBE) {\r\nadapter->num_rxd = DEFAULT_RCV_DESCRIPTORS_1G;\r\nadapter->num_jumbo_rxd = MAX_JUMBO_RCV_DESCRIPTORS_1G;\r\n}\r\nadapter->msix_supported = 0;\r\nif (NX_IS_REVISION_P3(adapter->ahw.revision_id)) {\r\nadapter->msix_supported = !!use_msi_x;\r\nadapter->rss_supported = !!use_msi_x;\r\n} else {\r\nu32 flashed_ver = 0;\r\nnetxen_rom_fast_read(adapter,\r\nNX_FW_VERSION_OFFSET, (int *)&flashed_ver);\r\nflashed_ver = NETXEN_DECODE_VERSION(flashed_ver);\r\nif (flashed_ver >= NETXEN_VERSION_CODE(3, 4, 336)) {\r\nswitch (adapter->ahw.board_type) {\r\ncase NETXEN_BRDTYPE_P2_SB31_10G:\r\ncase NETXEN_BRDTYPE_P2_SB31_10G_CX4:\r\nadapter->msix_supported = !!use_msi_x;\r\nadapter->rss_supported = !!use_msi_x;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\n}\r\nadapter->num_txd = MAX_CMD_DESCRIPTORS;\r\nif (NX_IS_REVISION_P2(adapter->ahw.revision_id)) {\r\nadapter->num_lro_rxd = MAX_LRO_RCV_DESCRIPTORS;\r\nadapter->max_rds_rings = 3;\r\n} else {\r\nadapter->num_lro_rxd = 0;\r\nadapter->max_rds_rings = 2;\r\n}\r\n}\r\nstatic int\r\nnetxen_start_firmware(struct netxen_adapter *adapter)\r\n{\r\nint val, err, first_boot;\r\nstruct pci_dev *pdev = adapter->pdev;\r\nerr = nx_set_dma_mask(adapter);\r\nif (err)\r\nreturn err;\r\nerr = netxen_can_start_firmware(adapter);\r\nif (err < 0)\r\nreturn err;\r\nif (!err)\r\ngoto wait_init;\r\nfirst_boot = NXRD32(adapter, NETXEN_CAM_RAM(0x1fc));\r\nerr = netxen_check_hw_init(adapter, first_boot);\r\nif (err) {\r\ndev_err(&pdev->dev, "error in init HW init sequence\n");\r\nreturn err;\r\n}\r\nnetxen_request_firmware(adapter);\r\nerr = netxen_need_fw_reset(adapter);\r\nif (err < 0)\r\ngoto err_out;\r\nif (err == 0)\r\ngoto pcie_strap_init;\r\nif (first_boot != 0x55555555) {\r\nNXWR32(adapter, CRB_CMDPEG_STATE, 0);\r\nnetxen_pinit_from_rom(adapter);\r\nmsleep(1);\r\n}\r\nNXWR32(adapter, CRB_DMA_SHIFT, 0x55555555);\r\nNXWR32(adapter, NETXEN_PEG_HALT_STATUS1, 0);\r\nNXWR32(adapter, NETXEN_PEG_HALT_STATUS2, 0);\r\nif (NX_IS_REVISION_P3(adapter->ahw.revision_id))\r\nnetxen_set_port_mode(adapter);\r\nerr = netxen_load_firmware(adapter);\r\nif (err)\r\ngoto err_out;\r\nnetxen_release_firmware(adapter);\r\nif (NX_IS_REVISION_P2(adapter->ahw.revision_id)) {\r\nval = 0x7654;\r\nif (adapter->ahw.port_type == NETXEN_NIC_XGBE)\r\nval |= 0x0f000000;\r\nNXWR32(adapter, NETXEN_MAC_ADDR_CNTL_REG, val);\r\n}\r\nerr = netxen_init_dummy_dma(adapter);\r\nif (err)\r\ngoto err_out;\r\nval = (_NETXEN_NIC_LINUX_MAJOR << 16)\r\n| ((_NETXEN_NIC_LINUX_MINOR << 8))\r\n| (_NETXEN_NIC_LINUX_SUBVERSION);\r\nNXWR32(adapter, CRB_DRIVER_VERSION, val);\r\npcie_strap_init:\r\nif (NX_IS_REVISION_P3(adapter->ahw.revision_id))\r\nnetxen_pcie_strap_init(adapter);\r\nwait_init:\r\nerr = netxen_phantom_init(adapter, NETXEN_NIC_PEG_TUNE);\r\nif (err) {\r\nnetxen_free_dummy_dma(adapter);\r\ngoto err_out;\r\n}\r\nNXWR32(adapter, NX_CRB_DEV_STATE, NX_DEV_READY);\r\nnx_update_dma_mask(adapter);\r\nnetxen_check_options(adapter);\r\nadapter->need_fw_reset = 0;\r\nerr_out:\r\nnetxen_release_firmware(adapter);\r\nreturn err;\r\n}\r\nstatic int\r\nnetxen_nic_request_irq(struct netxen_adapter *adapter)\r\n{\r\nirq_handler_t handler;\r\nstruct nx_host_sds_ring *sds_ring;\r\nint err, ring;\r\nunsigned long flags = 0;\r\nstruct net_device *netdev = adapter->netdev;\r\nstruct netxen_recv_context *recv_ctx = &adapter->recv_ctx;\r\nif (adapter->flags & NETXEN_NIC_MSIX_ENABLED)\r\nhandler = netxen_msix_intr;\r\nelse if (adapter->flags & NETXEN_NIC_MSI_ENABLED)\r\nhandler = netxen_msi_intr;\r\nelse {\r\nflags |= IRQF_SHARED;\r\nhandler = netxen_intr;\r\n}\r\nadapter->irq = netdev->irq;\r\nfor (ring = 0; ring < adapter->max_sds_rings; ring++) {\r\nsds_ring = &recv_ctx->sds_rings[ring];\r\nsprintf(sds_ring->name, "%s[%d]", netdev->name, ring);\r\nerr = request_irq(sds_ring->irq, handler,\r\nflags, sds_ring->name, sds_ring);\r\nif (err)\r\nreturn err;\r\n}\r\nreturn 0;\r\n}\r\nstatic void\r\nnetxen_nic_free_irq(struct netxen_adapter *adapter)\r\n{\r\nint ring;\r\nstruct nx_host_sds_ring *sds_ring;\r\nstruct netxen_recv_context *recv_ctx = &adapter->recv_ctx;\r\nfor (ring = 0; ring < adapter->max_sds_rings; ring++) {\r\nsds_ring = &recv_ctx->sds_rings[ring];\r\nfree_irq(sds_ring->irq, sds_ring);\r\n}\r\n}\r\nstatic void\r\nnetxen_nic_init_coalesce_defaults(struct netxen_adapter *adapter)\r\n{\r\nadapter->coal.flags = NETXEN_NIC_INTR_DEFAULT;\r\nadapter->coal.normal.data.rx_time_us =\r\nNETXEN_DEFAULT_INTR_COALESCE_RX_TIME_US;\r\nadapter->coal.normal.data.rx_packets =\r\nNETXEN_DEFAULT_INTR_COALESCE_RX_PACKETS;\r\nadapter->coal.normal.data.tx_time_us =\r\nNETXEN_DEFAULT_INTR_COALESCE_TX_TIME_US;\r\nadapter->coal.normal.data.tx_packets =\r\nNETXEN_DEFAULT_INTR_COALESCE_TX_PACKETS;\r\n}\r\nstatic int\r\n__netxen_nic_up(struct netxen_adapter *adapter, struct net_device *netdev)\r\n{\r\nint err;\r\nif (adapter->is_up != NETXEN_ADAPTER_UP_MAGIC)\r\nreturn -EIO;\r\nerr = adapter->init_port(adapter, adapter->physical_port);\r\nif (err) {\r\nprintk(KERN_ERR "%s: Failed to initialize port %d\n",\r\nnetxen_nic_driver_name, adapter->portnum);\r\nreturn err;\r\n}\r\nif (NX_IS_REVISION_P2(adapter->ahw.revision_id))\r\nadapter->macaddr_set(adapter, adapter->mac_addr);\r\nadapter->set_multi(netdev);\r\nadapter->set_mtu(adapter, netdev->mtu);\r\nadapter->ahw.linkup = 0;\r\nif (adapter->max_sds_rings > 1)\r\nnetxen_config_rss(adapter, 1);\r\nif (NX_IS_REVISION_P3(adapter->ahw.revision_id))\r\nnetxen_config_intr_coalesce(adapter);\r\nif (netdev->features & NETIF_F_LRO)\r\nnetxen_config_hw_lro(adapter, NETXEN_NIC_LRO_ENABLED);\r\nnetxen_napi_enable(adapter);\r\nif (adapter->capabilities & NX_FW_CAPABILITY_LINK_NOTIFICATION)\r\nnetxen_linkevent_request(adapter, 1);\r\nelse\r\nnetxen_nic_set_link_parameters(adapter);\r\nset_bit(__NX_DEV_UP, &adapter->state);\r\nreturn 0;\r\n}\r\nstatic inline int\r\nnetxen_nic_up(struct netxen_adapter *adapter, struct net_device *netdev)\r\n{\r\nint err = 0;\r\nrtnl_lock();\r\nif (netif_running(netdev))\r\nerr = __netxen_nic_up(adapter, netdev);\r\nrtnl_unlock();\r\nreturn err;\r\n}\r\nstatic void\r\n__netxen_nic_down(struct netxen_adapter *adapter, struct net_device *netdev)\r\n{\r\nif (adapter->is_up != NETXEN_ADAPTER_UP_MAGIC)\r\nreturn;\r\nif (!test_and_clear_bit(__NX_DEV_UP, &adapter->state))\r\nreturn;\r\nsmp_mb();\r\nnetif_carrier_off(netdev);\r\nnetif_tx_disable(netdev);\r\nif (adapter->capabilities & NX_FW_CAPABILITY_LINK_NOTIFICATION)\r\nnetxen_linkevent_request(adapter, 0);\r\nif (adapter->stop_port)\r\nadapter->stop_port(adapter);\r\nif (NX_IS_REVISION_P3(adapter->ahw.revision_id))\r\nnetxen_p3_free_mac_list(adapter);\r\nadapter->set_promisc(adapter, NETXEN_NIU_NON_PROMISC_MODE);\r\nnetxen_napi_disable(adapter);\r\nnetxen_release_tx_buffers(adapter);\r\n}\r\nstatic inline void\r\nnetxen_nic_down(struct netxen_adapter *adapter, struct net_device *netdev)\r\n{\r\nrtnl_lock();\r\nif (netif_running(netdev))\r\n__netxen_nic_down(adapter, netdev);\r\nrtnl_unlock();\r\n}\r\nstatic int\r\nnetxen_nic_attach(struct netxen_adapter *adapter)\r\n{\r\nstruct net_device *netdev = adapter->netdev;\r\nstruct pci_dev *pdev = adapter->pdev;\r\nint err, ring;\r\nstruct nx_host_rds_ring *rds_ring;\r\nstruct nx_host_tx_ring *tx_ring;\r\nu32 capab2;\r\nif (adapter->is_up == NETXEN_ADAPTER_UP_MAGIC)\r\nreturn 0;\r\nerr = netxen_init_firmware(adapter);\r\nif (err)\r\nreturn err;\r\nadapter->flags &= ~NETXEN_FW_MSS_CAP;\r\nif (adapter->capabilities & NX_FW_CAPABILITY_MORE_CAPS) {\r\ncapab2 = NXRD32(adapter, CRB_FW_CAPABILITIES_2);\r\nif (capab2 & NX_FW_CAPABILITY_2_LRO_MAX_TCP_SEG)\r\nadapter->flags |= NETXEN_FW_MSS_CAP;\r\n}\r\nerr = netxen_napi_add(adapter, netdev);\r\nif (err)\r\nreturn err;\r\nerr = netxen_alloc_sw_resources(adapter);\r\nif (err) {\r\nprintk(KERN_ERR "%s: Error in setting sw resources\n",\r\nnetdev->name);\r\nreturn err;\r\n}\r\nerr = netxen_alloc_hw_resources(adapter);\r\nif (err) {\r\nprintk(KERN_ERR "%s: Error in setting hw resources\n",\r\nnetdev->name);\r\ngoto err_out_free_sw;\r\n}\r\nif (NX_IS_REVISION_P2(adapter->ahw.revision_id)) {\r\ntx_ring = adapter->tx_ring;\r\ntx_ring->crb_cmd_producer = netxen_get_ioaddr(adapter,\r\ncrb_cmd_producer[adapter->portnum]);\r\ntx_ring->crb_cmd_consumer = netxen_get_ioaddr(adapter,\r\ncrb_cmd_consumer[adapter->portnum]);\r\ntx_ring->producer = 0;\r\ntx_ring->sw_consumer = 0;\r\nnetxen_nic_update_cmd_producer(adapter, tx_ring);\r\nnetxen_nic_update_cmd_consumer(adapter, tx_ring);\r\n}\r\nfor (ring = 0; ring < adapter->max_rds_rings; ring++) {\r\nrds_ring = &adapter->recv_ctx.rds_rings[ring];\r\nnetxen_post_rx_buffers(adapter, ring, rds_ring);\r\n}\r\nerr = netxen_nic_request_irq(adapter);\r\nif (err) {\r\ndev_err(&pdev->dev, "%s: failed to setup interrupt\n",\r\nnetdev->name);\r\ngoto err_out_free_rxbuf;\r\n}\r\nif (NX_IS_REVISION_P3(adapter->ahw.revision_id))\r\nnetxen_nic_init_coalesce_defaults(adapter);\r\nnetxen_create_sysfs_entries(adapter);\r\nadapter->is_up = NETXEN_ADAPTER_UP_MAGIC;\r\nreturn 0;\r\nerr_out_free_rxbuf:\r\nnetxen_release_rx_buffers(adapter);\r\nnetxen_free_hw_resources(adapter);\r\nerr_out_free_sw:\r\nnetxen_free_sw_resources(adapter);\r\nreturn err;\r\n}\r\nstatic void\r\nnetxen_nic_detach(struct netxen_adapter *adapter)\r\n{\r\nif (adapter->is_up != NETXEN_ADAPTER_UP_MAGIC)\r\nreturn;\r\nnetxen_remove_sysfs_entries(adapter);\r\nnetxen_free_hw_resources(adapter);\r\nnetxen_release_rx_buffers(adapter);\r\nnetxen_nic_free_irq(adapter);\r\nnetxen_napi_del(adapter);\r\nnetxen_free_sw_resources(adapter);\r\nadapter->is_up = 0;\r\n}\r\nint\r\nnetxen_nic_reset_context(struct netxen_adapter *adapter)\r\n{\r\nint err = 0;\r\nstruct net_device *netdev = adapter->netdev;\r\nif (test_and_set_bit(__NX_RESETTING, &adapter->state))\r\nreturn -EBUSY;\r\nif (adapter->is_up == NETXEN_ADAPTER_UP_MAGIC) {\r\nnetif_device_detach(netdev);\r\nif (netif_running(netdev))\r\n__netxen_nic_down(adapter, netdev);\r\nnetxen_nic_detach(adapter);\r\nif (netif_running(netdev)) {\r\nerr = netxen_nic_attach(adapter);\r\nif (!err)\r\nerr = __netxen_nic_up(adapter, netdev);\r\nif (err)\r\ngoto done;\r\n}\r\nnetif_device_attach(netdev);\r\n}\r\ndone:\r\nclear_bit(__NX_RESETTING, &adapter->state);\r\nreturn err;\r\n}\r\nstatic int\r\nnetxen_setup_netdev(struct netxen_adapter *adapter,\r\nstruct net_device *netdev)\r\n{\r\nint err = 0;\r\nstruct pci_dev *pdev = adapter->pdev;\r\nadapter->mc_enabled = 0;\r\nif (NX_IS_REVISION_P3(adapter->ahw.revision_id))\r\nadapter->max_mc_count = 38;\r\nelse\r\nadapter->max_mc_count = 16;\r\nnetdev->netdev_ops = &netxen_netdev_ops;\r\nnetdev->watchdog_timeo = 5*HZ;\r\nnetxen_nic_change_mtu(netdev, netdev->mtu);\r\nnetdev->ethtool_ops = &netxen_nic_ethtool_ops;\r\nnetdev->hw_features = NETIF_F_SG | NETIF_F_IP_CSUM | NETIF_F_TSO |\r\nNETIF_F_RXCSUM;\r\nif (NX_IS_REVISION_P3(adapter->ahw.revision_id))\r\nnetdev->hw_features |= NETIF_F_IPV6_CSUM | NETIF_F_TSO6;\r\nnetdev->vlan_features |= netdev->hw_features;\r\nif (adapter->pci_using_dac) {\r\nnetdev->features |= NETIF_F_HIGHDMA;\r\nnetdev->vlan_features |= NETIF_F_HIGHDMA;\r\n}\r\nif (adapter->capabilities & NX_FW_CAPABILITY_FVLANTX)\r\nnetdev->hw_features |= NETIF_F_HW_VLAN_CTAG_TX;\r\nif (adapter->capabilities & NX_FW_CAPABILITY_HW_LRO)\r\nnetdev->hw_features |= NETIF_F_LRO;\r\nnetdev->features |= netdev->hw_features;\r\nnetdev->irq = adapter->msix_entries[0].vector;\r\nINIT_WORK(&adapter->tx_timeout_task, netxen_tx_timeout_task);\r\nif (netxen_read_mac_addr(adapter))\r\ndev_warn(&pdev->dev, "failed to read mac addr\n");\r\nnetif_carrier_off(netdev);\r\nerr = register_netdev(netdev);\r\nif (err) {\r\ndev_err(&pdev->dev, "failed to register net device\n");\r\nreturn err;\r\n}\r\nreturn 0;\r\n}\r\nstatic void netxen_read_ula_info(struct netxen_adapter *adapter)\r\n{\r\nu32 temp;\r\nif (adapter->portnum != 0)\r\nreturn;\r\ntemp = NXRD32(adapter, NETXEN_ULA_KEY);\r\nswitch (temp) {\r\ncase NETXEN_ULA_ADAPTER_KEY:\r\ndev_info(&adapter->pdev->dev, "ULA adapter");\r\nbreak;\r\ncase NETXEN_NON_ULA_ADAPTER_KEY:\r\ndev_info(&adapter->pdev->dev, "non ULA adapter");\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nreturn;\r\n}\r\nstatic void netxen_mask_aer_correctable(struct netxen_adapter *adapter)\r\n{\r\nstruct pci_dev *pdev = adapter->pdev;\r\nstruct pci_dev *root = pdev->bus->self;\r\nu32 aer_pos;\r\nif (!root)\r\nreturn;\r\nif (adapter->ahw.board_type != NETXEN_BRDTYPE_P3_4_GB_MM &&\r\nadapter->ahw.board_type != NETXEN_BRDTYPE_P3_10G_TP)\r\nreturn;\r\nif (pci_pcie_type(root) != PCI_EXP_TYPE_ROOT_PORT)\r\nreturn;\r\naer_pos = pci_find_ext_capability(root, PCI_EXT_CAP_ID_ERR);\r\nif (!aer_pos)\r\nreturn;\r\npci_write_config_dword(root, aer_pos + PCI_ERR_COR_MASK, 0xffff);\r\n}\r\nstatic int\r\nnetxen_nic_probe(struct pci_dev *pdev, const struct pci_device_id *ent)\r\n{\r\nstruct net_device *netdev = NULL;\r\nstruct netxen_adapter *adapter = NULL;\r\nint i = 0, err;\r\nint pci_func_id = PCI_FUNC(pdev->devfn);\r\nuint8_t revision_id;\r\nu32 val;\r\nif (pdev->revision >= NX_P3_A0 && pdev->revision <= NX_P3_B1) {\r\npr_warn("%s: chip revisions between 0x%x-0x%x will not be enabled\n",\r\nmodule_name(THIS_MODULE), NX_P3_A0, NX_P3_B1);\r\nreturn -ENODEV;\r\n}\r\nif ((err = pci_enable_device(pdev)))\r\nreturn err;\r\nif (!(pci_resource_flags(pdev, 0) & IORESOURCE_MEM)) {\r\nerr = -ENODEV;\r\ngoto err_out_disable_pdev;\r\n}\r\nif ((err = pci_request_regions(pdev, netxen_nic_driver_name)))\r\ngoto err_out_disable_pdev;\r\nif (NX_IS_REVISION_P3(pdev->revision))\r\npci_enable_pcie_error_reporting(pdev);\r\npci_set_master(pdev);\r\nnetdev = alloc_etherdev(sizeof(struct netxen_adapter));\r\nif(!netdev) {\r\nerr = -ENOMEM;\r\ngoto err_out_free_res;\r\n}\r\nSET_NETDEV_DEV(netdev, &pdev->dev);\r\nadapter = netdev_priv(netdev);\r\nadapter->netdev = netdev;\r\nadapter->pdev = pdev;\r\nadapter->ahw.pci_func = pci_func_id;\r\nrevision_id = pdev->revision;\r\nadapter->ahw.revision_id = revision_id;\r\nrwlock_init(&adapter->ahw.crb_lock);\r\nspin_lock_init(&adapter->ahw.mem_lock);\r\nspin_lock_init(&adapter->tx_clean_lock);\r\nINIT_LIST_HEAD(&adapter->mac_list);\r\nINIT_LIST_HEAD(&adapter->ip_list);\r\nerr = netxen_setup_pci_map(adapter);\r\nif (err)\r\ngoto err_out_free_netdev;\r\nadapter->portnum = pci_func_id;\r\nerr = netxen_nic_get_board_info(adapter);\r\nif (err) {\r\ndev_err(&pdev->dev, "Error getting board config info.\n");\r\ngoto err_out_iounmap;\r\n}\r\n#ifdef CONFIG_PCIEAER\r\nnetxen_mask_aer_correctable(adapter);\r\n#endif\r\nswitch (adapter->ahw.board_type) {\r\ncase NETXEN_BRDTYPE_P2_SB31_10G_IMEZ:\r\ncase NETXEN_BRDTYPE_P2_SB31_10G_HMEZ:\r\nif (pci_func_id >= 2)\r\nadapter->portnum = pci_func_id - 2;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nerr = netxen_check_flash_fw_compatibility(adapter);\r\nif (err)\r\ngoto err_out_iounmap;\r\nif (adapter->portnum == 0) {\r\nval = NXRD32(adapter, NX_CRB_DEV_REF_COUNT);\r\nif (val != 0xffffffff && val != 0) {\r\nNXWR32(adapter, NX_CRB_DEV_REF_COUNT, 0);\r\nadapter->need_fw_reset = 1;\r\n}\r\n}\r\nerr = netxen_start_firmware(adapter);\r\nif (err)\r\ngoto err_out_decr_ref;\r\nadapter->physical_port = adapter->portnum;\r\nif (NX_IS_REVISION_P2(adapter->ahw.revision_id)) {\r\ni = NXRD32(adapter, CRB_V2P(adapter->portnum));\r\nif (i != 0x55555555)\r\nadapter->physical_port = i;\r\n}\r\nnetxen_nic_clear_stats(adapter);\r\nerr = netxen_setup_intr(adapter);\r\nif (err) {\r\ndev_err(&adapter->pdev->dev,\r\n"Failed to setup interrupts, error = %d\n", err);\r\ngoto err_out_disable_msi;\r\n}\r\nnetxen_read_ula_info(adapter);\r\nerr = netxen_setup_netdev(adapter, netdev);\r\nif (err)\r\ngoto err_out_disable_msi;\r\npci_set_drvdata(pdev, adapter);\r\nnetxen_schedule_work(adapter, netxen_fw_poll_work, FW_POLL_DELAY);\r\nswitch (adapter->ahw.port_type) {\r\ncase NETXEN_NIC_GBE:\r\ndev_info(&adapter->pdev->dev, "%s: GbE port initialized\n",\r\nadapter->netdev->name);\r\nbreak;\r\ncase NETXEN_NIC_XGBE:\r\ndev_info(&adapter->pdev->dev, "%s: XGbE port initialized\n",\r\nadapter->netdev->name);\r\nbreak;\r\n}\r\nnetxen_create_diag_entries(adapter);\r\nreturn 0;\r\nerr_out_disable_msi:\r\nnetxen_teardown_intr(adapter);\r\nnetxen_free_dummy_dma(adapter);\r\nerr_out_decr_ref:\r\nnx_decr_dev_ref_cnt(adapter);\r\nerr_out_iounmap:\r\nnetxen_cleanup_pci_map(adapter);\r\nerr_out_free_netdev:\r\nfree_netdev(netdev);\r\nerr_out_free_res:\r\npci_release_regions(pdev);\r\nerr_out_disable_pdev:\r\npci_disable_device(pdev);\r\nreturn err;\r\n}\r\nstatic\r\nvoid netxen_cleanup_minidump(struct netxen_adapter *adapter)\r\n{\r\nkfree(adapter->mdump.md_template);\r\nadapter->mdump.md_template = NULL;\r\nif (adapter->mdump.md_capture_buff) {\r\nvfree(adapter->mdump.md_capture_buff);\r\nadapter->mdump.md_capture_buff = NULL;\r\n}\r\n}\r\nstatic void netxen_nic_remove(struct pci_dev *pdev)\r\n{\r\nstruct netxen_adapter *adapter;\r\nstruct net_device *netdev;\r\nadapter = pci_get_drvdata(pdev);\r\nif (adapter == NULL)\r\nreturn;\r\nnetdev = adapter->netdev;\r\nnetxen_cancel_fw_work(adapter);\r\nunregister_netdev(netdev);\r\ncancel_work_sync(&adapter->tx_timeout_task);\r\nnetxen_free_ip_list(adapter, false);\r\nnetxen_nic_detach(adapter);\r\nnx_decr_dev_ref_cnt(adapter);\r\nif (adapter->portnum == 0)\r\nnetxen_free_dummy_dma(adapter);\r\nclear_bit(__NX_RESETTING, &adapter->state);\r\nnetxen_teardown_intr(adapter);\r\nnetxen_set_interrupt_mode(adapter, 0);\r\nnetxen_remove_diag_entries(adapter);\r\nnetxen_cleanup_pci_map(adapter);\r\nnetxen_release_firmware(adapter);\r\nif (NX_IS_REVISION_P3(pdev->revision)) {\r\nnetxen_cleanup_minidump(adapter);\r\npci_disable_pcie_error_reporting(pdev);\r\n}\r\npci_release_regions(pdev);\r\npci_disable_device(pdev);\r\nfree_netdev(netdev);\r\n}\r\nstatic void netxen_nic_detach_func(struct netxen_adapter *adapter)\r\n{\r\nstruct net_device *netdev = adapter->netdev;\r\nnetif_device_detach(netdev);\r\nnetxen_cancel_fw_work(adapter);\r\nif (netif_running(netdev))\r\nnetxen_nic_down(adapter, netdev);\r\ncancel_work_sync(&adapter->tx_timeout_task);\r\nnetxen_nic_detach(adapter);\r\nif (adapter->portnum == 0)\r\nnetxen_free_dummy_dma(adapter);\r\nnx_decr_dev_ref_cnt(adapter);\r\nclear_bit(__NX_RESETTING, &adapter->state);\r\n}\r\nstatic int netxen_nic_attach_func(struct pci_dev *pdev)\r\n{\r\nstruct netxen_adapter *adapter = pci_get_drvdata(pdev);\r\nstruct net_device *netdev = adapter->netdev;\r\nint err;\r\nerr = pci_enable_device(pdev);\r\nif (err)\r\nreturn err;\r\npci_set_power_state(pdev, PCI_D0);\r\npci_set_master(pdev);\r\npci_restore_state(pdev);\r\nadapter->ahw.crb_win = -1;\r\nadapter->ahw.ocm_win = -1;\r\nerr = netxen_start_firmware(adapter);\r\nif (err) {\r\ndev_err(&pdev->dev, "failed to start firmware\n");\r\nreturn err;\r\n}\r\nif (netif_running(netdev)) {\r\nerr = netxen_nic_attach(adapter);\r\nif (err)\r\ngoto err_out;\r\nerr = netxen_nic_up(adapter, netdev);\r\nif (err)\r\ngoto err_out_detach;\r\nnetxen_restore_indev_addr(netdev, NETDEV_UP);\r\n}\r\nnetif_device_attach(netdev);\r\nnetxen_schedule_work(adapter, netxen_fw_poll_work, FW_POLL_DELAY);\r\nreturn 0;\r\nerr_out_detach:\r\nnetxen_nic_detach(adapter);\r\nerr_out:\r\nnx_decr_dev_ref_cnt(adapter);\r\nreturn err;\r\n}\r\nstatic pci_ers_result_t netxen_io_error_detected(struct pci_dev *pdev,\r\npci_channel_state_t state)\r\n{\r\nstruct netxen_adapter *adapter = pci_get_drvdata(pdev);\r\nif (state == pci_channel_io_perm_failure)\r\nreturn PCI_ERS_RESULT_DISCONNECT;\r\nif (nx_dev_request_aer(adapter))\r\nreturn PCI_ERS_RESULT_RECOVERED;\r\nnetxen_nic_detach_func(adapter);\r\npci_disable_device(pdev);\r\nreturn PCI_ERS_RESULT_NEED_RESET;\r\n}\r\nstatic pci_ers_result_t netxen_io_slot_reset(struct pci_dev *pdev)\r\n{\r\nint err = 0;\r\nerr = netxen_nic_attach_func(pdev);\r\nreturn err ? PCI_ERS_RESULT_DISCONNECT : PCI_ERS_RESULT_RECOVERED;\r\n}\r\nstatic void netxen_io_resume(struct pci_dev *pdev)\r\n{\r\npci_cleanup_aer_uncorrect_error_status(pdev);\r\n}\r\nstatic void netxen_nic_shutdown(struct pci_dev *pdev)\r\n{\r\nstruct netxen_adapter *adapter = pci_get_drvdata(pdev);\r\nnetxen_nic_detach_func(adapter);\r\nif (pci_save_state(pdev))\r\nreturn;\r\nif (netxen_nic_wol_supported(adapter)) {\r\npci_enable_wake(pdev, PCI_D3cold, 1);\r\npci_enable_wake(pdev, PCI_D3hot, 1);\r\n}\r\npci_disable_device(pdev);\r\n}\r\nstatic int\r\nnetxen_nic_suspend(struct pci_dev *pdev, pm_message_t state)\r\n{\r\nstruct netxen_adapter *adapter = pci_get_drvdata(pdev);\r\nint retval;\r\nnetxen_nic_detach_func(adapter);\r\nretval = pci_save_state(pdev);\r\nif (retval)\r\nreturn retval;\r\nif (netxen_nic_wol_supported(adapter)) {\r\npci_enable_wake(pdev, PCI_D3cold, 1);\r\npci_enable_wake(pdev, PCI_D3hot, 1);\r\n}\r\npci_disable_device(pdev);\r\npci_set_power_state(pdev, pci_choose_state(pdev, state));\r\nreturn 0;\r\n}\r\nstatic int\r\nnetxen_nic_resume(struct pci_dev *pdev)\r\n{\r\nreturn netxen_nic_attach_func(pdev);\r\n}\r\nstatic int netxen_nic_open(struct net_device *netdev)\r\n{\r\nstruct netxen_adapter *adapter = netdev_priv(netdev);\r\nint err = 0;\r\nif (adapter->driver_mismatch)\r\nreturn -EIO;\r\nerr = netxen_nic_attach(adapter);\r\nif (err)\r\nreturn err;\r\nerr = __netxen_nic_up(adapter, netdev);\r\nif (err)\r\ngoto err_out;\r\nnetif_start_queue(netdev);\r\nreturn 0;\r\nerr_out:\r\nnetxen_nic_detach(adapter);\r\nreturn err;\r\n}\r\nstatic int netxen_nic_close(struct net_device *netdev)\r\n{\r\nstruct netxen_adapter *adapter = netdev_priv(netdev);\r\n__netxen_nic_down(adapter, netdev);\r\nreturn 0;\r\n}\r\nstatic void\r\nnetxen_tso_check(struct net_device *netdev,\r\nstruct nx_host_tx_ring *tx_ring,\r\nstruct cmd_desc_type0 *first_desc,\r\nstruct sk_buff *skb)\r\n{\r\nu8 opcode = TX_ETHER_PKT;\r\n__be16 protocol = skb->protocol;\r\nu16 flags = 0, vid = 0;\r\nu32 producer;\r\nint copied, offset, copy_len, hdr_len = 0, tso = 0, vlan_oob = 0;\r\nstruct cmd_desc_type0 *hwdesc;\r\nstruct vlan_ethhdr *vh;\r\nif (protocol == cpu_to_be16(ETH_P_8021Q)) {\r\nvh = (struct vlan_ethhdr *)skb->data;\r\nprotocol = vh->h_vlan_encapsulated_proto;\r\nflags = FLAGS_VLAN_TAGGED;\r\n} else if (skb_vlan_tag_present(skb)) {\r\nflags = FLAGS_VLAN_OOB;\r\nvid = skb_vlan_tag_get(skb);\r\nnetxen_set_tx_vlan_tci(first_desc, vid);\r\nvlan_oob = 1;\r\n}\r\nif ((netdev->features & (NETIF_F_TSO | NETIF_F_TSO6)) &&\r\nskb_shinfo(skb)->gso_size > 0) {\r\nhdr_len = skb_transport_offset(skb) + tcp_hdrlen(skb);\r\nfirst_desc->mss = cpu_to_le16(skb_shinfo(skb)->gso_size);\r\nfirst_desc->total_hdr_length = hdr_len;\r\nif (vlan_oob) {\r\nfirst_desc->total_hdr_length += VLAN_HLEN;\r\nfirst_desc->tcp_hdr_offset = VLAN_HLEN;\r\nfirst_desc->ip_hdr_offset = VLAN_HLEN;\r\nflags |= FLAGS_VLAN_TAGGED;\r\n}\r\nopcode = (protocol == cpu_to_be16(ETH_P_IPV6)) ?\r\nTX_TCP_LSO6 : TX_TCP_LSO;\r\ntso = 1;\r\n} else if (skb->ip_summed == CHECKSUM_PARTIAL) {\r\nu8 l4proto;\r\nif (protocol == cpu_to_be16(ETH_P_IP)) {\r\nl4proto = ip_hdr(skb)->protocol;\r\nif (l4proto == IPPROTO_TCP)\r\nopcode = TX_TCP_PKT;\r\nelse if(l4proto == IPPROTO_UDP)\r\nopcode = TX_UDP_PKT;\r\n} else if (protocol == cpu_to_be16(ETH_P_IPV6)) {\r\nl4proto = ipv6_hdr(skb)->nexthdr;\r\nif (l4proto == IPPROTO_TCP)\r\nopcode = TX_TCPV6_PKT;\r\nelse if(l4proto == IPPROTO_UDP)\r\nopcode = TX_UDPV6_PKT;\r\n}\r\n}\r\nfirst_desc->tcp_hdr_offset += skb_transport_offset(skb);\r\nfirst_desc->ip_hdr_offset += skb_network_offset(skb);\r\nnetxen_set_tx_flags_opcode(first_desc, flags, opcode);\r\nif (!tso)\r\nreturn;\r\nproducer = tx_ring->producer;\r\ncopied = 0;\r\noffset = 2;\r\nif (vlan_oob) {\r\nhwdesc = &tx_ring->desc_head[producer];\r\ntx_ring->cmd_buf_arr[producer].skb = NULL;\r\ncopy_len = min((int)sizeof(struct cmd_desc_type0) - offset,\r\nhdr_len + VLAN_HLEN);\r\nvh = (struct vlan_ethhdr *)((char *)hwdesc + 2);\r\nskb_copy_from_linear_data(skb, vh, 12);\r\nvh->h_vlan_proto = htons(ETH_P_8021Q);\r\nvh->h_vlan_TCI = htons(vid);\r\nskb_copy_from_linear_data_offset(skb, 12,\r\n(char *)vh + 16, copy_len - 16);\r\ncopied = copy_len - VLAN_HLEN;\r\noffset = 0;\r\nproducer = get_next_index(producer, tx_ring->num_desc);\r\n}\r\nwhile (copied < hdr_len) {\r\ncopy_len = min((int)sizeof(struct cmd_desc_type0) - offset,\r\n(hdr_len - copied));\r\nhwdesc = &tx_ring->desc_head[producer];\r\ntx_ring->cmd_buf_arr[producer].skb = NULL;\r\nskb_copy_from_linear_data_offset(skb, copied,\r\n(char *)hwdesc + offset, copy_len);\r\ncopied += copy_len;\r\noffset = 0;\r\nproducer = get_next_index(producer, tx_ring->num_desc);\r\n}\r\ntx_ring->producer = producer;\r\nbarrier();\r\n}\r\nstatic int\r\nnetxen_map_tx_skb(struct pci_dev *pdev,\r\nstruct sk_buff *skb, struct netxen_cmd_buffer *pbuf)\r\n{\r\nstruct netxen_skb_frag *nf;\r\nstruct skb_frag_struct *frag;\r\nint i, nr_frags;\r\ndma_addr_t map;\r\nnr_frags = skb_shinfo(skb)->nr_frags;\r\nnf = &pbuf->frag_array[0];\r\nmap = pci_map_single(pdev, skb->data,\r\nskb_headlen(skb), PCI_DMA_TODEVICE);\r\nif (pci_dma_mapping_error(pdev, map))\r\ngoto out_err;\r\nnf->dma = map;\r\nnf->length = skb_headlen(skb);\r\nfor (i = 0; i < nr_frags; i++) {\r\nfrag = &skb_shinfo(skb)->frags[i];\r\nnf = &pbuf->frag_array[i+1];\r\nmap = skb_frag_dma_map(&pdev->dev, frag, 0, skb_frag_size(frag),\r\nDMA_TO_DEVICE);\r\nif (dma_mapping_error(&pdev->dev, map))\r\ngoto unwind;\r\nnf->dma = map;\r\nnf->length = skb_frag_size(frag);\r\n}\r\nreturn 0;\r\nunwind:\r\nwhile (--i >= 0) {\r\nnf = &pbuf->frag_array[i+1];\r\npci_unmap_page(pdev, nf->dma, nf->length, PCI_DMA_TODEVICE);\r\nnf->dma = 0ULL;\r\n}\r\nnf = &pbuf->frag_array[0];\r\npci_unmap_single(pdev, nf->dma, skb_headlen(skb), PCI_DMA_TODEVICE);\r\nnf->dma = 0ULL;\r\nout_err:\r\nreturn -ENOMEM;\r\n}\r\nstatic inline void\r\nnetxen_clear_cmddesc(u64 *desc)\r\n{\r\ndesc[0] = 0ULL;\r\ndesc[2] = 0ULL;\r\n}\r\nstatic netdev_tx_t\r\nnetxen_nic_xmit_frame(struct sk_buff *skb, struct net_device *netdev)\r\n{\r\nstruct netxen_adapter *adapter = netdev_priv(netdev);\r\nstruct nx_host_tx_ring *tx_ring = adapter->tx_ring;\r\nstruct netxen_cmd_buffer *pbuf;\r\nstruct netxen_skb_frag *buffrag;\r\nstruct cmd_desc_type0 *hwdesc, *first_desc;\r\nstruct pci_dev *pdev;\r\nint i, k;\r\nint delta = 0;\r\nstruct skb_frag_struct *frag;\r\nu32 producer;\r\nint frag_count, no_of_desc;\r\nu32 num_txd = tx_ring->num_desc;\r\nfrag_count = skb_shinfo(skb)->nr_frags + 1;\r\nif (!skb_is_gso(skb) && frag_count > NETXEN_MAX_FRAGS_PER_TX) {\r\nfor (i = 0; i < (frag_count - NETXEN_MAX_FRAGS_PER_TX); i++) {\r\nfrag = &skb_shinfo(skb)->frags[i];\r\ndelta += skb_frag_size(frag);\r\n}\r\nif (!__pskb_pull_tail(skb, delta))\r\ngoto drop_packet;\r\nfrag_count = 1 + skb_shinfo(skb)->nr_frags;\r\n}\r\nno_of_desc = (frag_count + 3) >> 2;\r\nif (unlikely(netxen_tx_avail(tx_ring) <= TX_STOP_THRESH)) {\r\nnetif_stop_queue(netdev);\r\nsmp_mb();\r\nif (netxen_tx_avail(tx_ring) > TX_STOP_THRESH)\r\nnetif_start_queue(netdev);\r\nelse\r\nreturn NETDEV_TX_BUSY;\r\n}\r\nproducer = tx_ring->producer;\r\npbuf = &tx_ring->cmd_buf_arr[producer];\r\npdev = adapter->pdev;\r\nif (netxen_map_tx_skb(pdev, skb, pbuf))\r\ngoto drop_packet;\r\npbuf->skb = skb;\r\npbuf->frag_count = frag_count;\r\nfirst_desc = hwdesc = &tx_ring->desc_head[producer];\r\nnetxen_clear_cmddesc((u64 *)hwdesc);\r\nnetxen_set_tx_frags_len(first_desc, frag_count, skb->len);\r\nnetxen_set_tx_port(first_desc, adapter->portnum);\r\nfor (i = 0; i < frag_count; i++) {\r\nk = i % 4;\r\nif ((k == 0) && (i > 0)) {\r\nproducer = get_next_index(producer, num_txd);\r\nhwdesc = &tx_ring->desc_head[producer];\r\nnetxen_clear_cmddesc((u64 *)hwdesc);\r\ntx_ring->cmd_buf_arr[producer].skb = NULL;\r\n}\r\nbuffrag = &pbuf->frag_array[i];\r\nhwdesc->buffer_length[k] = cpu_to_le16(buffrag->length);\r\nswitch (k) {\r\ncase 0:\r\nhwdesc->addr_buffer1 = cpu_to_le64(buffrag->dma);\r\nbreak;\r\ncase 1:\r\nhwdesc->addr_buffer2 = cpu_to_le64(buffrag->dma);\r\nbreak;\r\ncase 2:\r\nhwdesc->addr_buffer3 = cpu_to_le64(buffrag->dma);\r\nbreak;\r\ncase 3:\r\nhwdesc->addr_buffer4 = cpu_to_le64(buffrag->dma);\r\nbreak;\r\n}\r\n}\r\ntx_ring->producer = get_next_index(producer, num_txd);\r\nnetxen_tso_check(netdev, tx_ring, first_desc, skb);\r\nadapter->stats.txbytes += skb->len;\r\nadapter->stats.xmitcalled++;\r\nnetxen_nic_update_cmd_producer(adapter, tx_ring);\r\nreturn NETDEV_TX_OK;\r\ndrop_packet:\r\nadapter->stats.txdropped++;\r\ndev_kfree_skb_any(skb);\r\nreturn NETDEV_TX_OK;\r\n}\r\nstatic int netxen_nic_check_temp(struct netxen_adapter *adapter)\r\n{\r\nstruct net_device *netdev = adapter->netdev;\r\nuint32_t temp, temp_state, temp_val;\r\nint rv = 0;\r\ntemp = NXRD32(adapter, CRB_TEMP_STATE);\r\ntemp_state = nx_get_temp_state(temp);\r\ntemp_val = nx_get_temp_val(temp);\r\nif (temp_state == NX_TEMP_PANIC) {\r\nprintk(KERN_ALERT\r\n"%s: Device temperature %d degrees C exceeds"\r\n" maximum allowed. Hardware has been shut down.\n",\r\nnetdev->name, temp_val);\r\nrv = 1;\r\n} else if (temp_state == NX_TEMP_WARN) {\r\nif (adapter->temp == NX_TEMP_NORMAL) {\r\nprintk(KERN_ALERT\r\n"%s: Device temperature %d degrees C "\r\n"exceeds operating range."\r\n" Immediate action needed.\n",\r\nnetdev->name, temp_val);\r\n}\r\n} else {\r\nif (adapter->temp == NX_TEMP_WARN) {\r\nprintk(KERN_INFO\r\n"%s: Device temperature is now %d degrees C"\r\n" in normal range.\n", netdev->name,\r\ntemp_val);\r\n}\r\n}\r\nadapter->temp = temp_state;\r\nreturn rv;\r\n}\r\nvoid netxen_advert_link_change(struct netxen_adapter *adapter, int linkup)\r\n{\r\nstruct net_device *netdev = adapter->netdev;\r\nif (adapter->ahw.linkup && !linkup) {\r\nprintk(KERN_INFO "%s: %s NIC Link is down\n",\r\nnetxen_nic_driver_name, netdev->name);\r\nadapter->ahw.linkup = 0;\r\nif (netif_running(netdev)) {\r\nnetif_carrier_off(netdev);\r\nnetif_stop_queue(netdev);\r\n}\r\nadapter->link_changed = !adapter->has_link_events;\r\n} else if (!adapter->ahw.linkup && linkup) {\r\nprintk(KERN_INFO "%s: %s NIC Link is up\n",\r\nnetxen_nic_driver_name, netdev->name);\r\nadapter->ahw.linkup = 1;\r\nif (netif_running(netdev)) {\r\nnetif_carrier_on(netdev);\r\nnetif_wake_queue(netdev);\r\n}\r\nadapter->link_changed = !adapter->has_link_events;\r\n}\r\n}\r\nstatic void netxen_nic_handle_phy_intr(struct netxen_adapter *adapter)\r\n{\r\nu32 val, port, linkup;\r\nport = adapter->physical_port;\r\nif (NX_IS_REVISION_P3(adapter->ahw.revision_id)) {\r\nval = NXRD32(adapter, CRB_XG_STATE_P3);\r\nval = XG_LINK_STATE_P3(adapter->ahw.pci_func, val);\r\nlinkup = (val == XG_LINK_UP_P3);\r\n} else {\r\nval = NXRD32(adapter, CRB_XG_STATE);\r\nval = (val >> port*8) & 0xff;\r\nlinkup = (val == XG_LINK_UP);\r\n}\r\nnetxen_advert_link_change(adapter, linkup);\r\n}\r\nstatic void netxen_tx_timeout(struct net_device *netdev)\r\n{\r\nstruct netxen_adapter *adapter = netdev_priv(netdev);\r\nif (test_bit(__NX_RESETTING, &adapter->state))\r\nreturn;\r\ndev_err(&netdev->dev, "transmit timeout, resetting.\n");\r\nschedule_work(&adapter->tx_timeout_task);\r\n}\r\nstatic void netxen_tx_timeout_task(struct work_struct *work)\r\n{\r\nstruct netxen_adapter *adapter =\r\ncontainer_of(work, struct netxen_adapter, tx_timeout_task);\r\nif (!netif_running(adapter->netdev))\r\nreturn;\r\nif (test_and_set_bit(__NX_RESETTING, &adapter->state))\r\nreturn;\r\nif (++adapter->tx_timeo_cnt >= NX_MAX_TX_TIMEOUTS)\r\ngoto request_reset;\r\nrtnl_lock();\r\nif (NX_IS_REVISION_P2(adapter->ahw.revision_id)) {\r\nnetxen_napi_disable(adapter);\r\nnetxen_napi_enable(adapter);\r\nnetif_wake_queue(adapter->netdev);\r\nclear_bit(__NX_RESETTING, &adapter->state);\r\n} else {\r\nclear_bit(__NX_RESETTING, &adapter->state);\r\nif (netxen_nic_reset_context(adapter)) {\r\nrtnl_unlock();\r\ngoto request_reset;\r\n}\r\n}\r\nadapter->netdev->trans_start = jiffies;\r\nrtnl_unlock();\r\nreturn;\r\nrequest_reset:\r\nadapter->need_fw_reset = 1;\r\nclear_bit(__NX_RESETTING, &adapter->state);\r\n}\r\nstatic struct rtnl_link_stats64 *netxen_nic_get_stats(struct net_device *netdev,\r\nstruct rtnl_link_stats64 *stats)\r\n{\r\nstruct netxen_adapter *adapter = netdev_priv(netdev);\r\nstats->rx_packets = adapter->stats.rx_pkts + adapter->stats.lro_pkts;\r\nstats->tx_packets = adapter->stats.xmitfinished;\r\nstats->rx_bytes = adapter->stats.rxbytes;\r\nstats->tx_bytes = adapter->stats.txbytes;\r\nstats->rx_dropped = adapter->stats.rxdropped;\r\nstats->tx_dropped = adapter->stats.txdropped;\r\nreturn stats;\r\n}\r\nstatic irqreturn_t netxen_intr(int irq, void *data)\r\n{\r\nstruct nx_host_sds_ring *sds_ring = data;\r\nstruct netxen_adapter *adapter = sds_ring->adapter;\r\nu32 status = 0;\r\nstatus = readl(adapter->isr_int_vec);\r\nif (!(status & adapter->int_vec_bit))\r\nreturn IRQ_NONE;\r\nif (NX_IS_REVISION_P3(adapter->ahw.revision_id)) {\r\nstatus = readl(adapter->crb_int_state_reg);\r\nif (!ISR_LEGACY_INT_TRIGGERED(status))\r\nreturn IRQ_NONE;\r\n} else {\r\nunsigned long our_int = 0;\r\nour_int = readl(adapter->crb_int_state_reg);\r\nif (!test_and_clear_bit((7 + adapter->portnum), &our_int))\r\nreturn IRQ_NONE;\r\nwritel((our_int & 0xffffffff), adapter->crb_int_state_reg);\r\nnetxen_nic_disable_int(sds_ring);\r\n}\r\nwritel(0xffffffff, adapter->tgt_status_reg);\r\nreadl(adapter->isr_int_vec);\r\nreadl(adapter->isr_int_vec);\r\nnapi_schedule(&sds_ring->napi);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic irqreturn_t netxen_msi_intr(int irq, void *data)\r\n{\r\nstruct nx_host_sds_ring *sds_ring = data;\r\nstruct netxen_adapter *adapter = sds_ring->adapter;\r\nwritel(0xffffffff, adapter->tgt_status_reg);\r\nnapi_schedule(&sds_ring->napi);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic irqreturn_t netxen_msix_intr(int irq, void *data)\r\n{\r\nstruct nx_host_sds_ring *sds_ring = data;\r\nnapi_schedule(&sds_ring->napi);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int netxen_nic_poll(struct napi_struct *napi, int budget)\r\n{\r\nstruct nx_host_sds_ring *sds_ring =\r\ncontainer_of(napi, struct nx_host_sds_ring, napi);\r\nstruct netxen_adapter *adapter = sds_ring->adapter;\r\nint tx_complete;\r\nint work_done;\r\ntx_complete = netxen_process_cmd_ring(adapter);\r\nwork_done = netxen_process_rcv_ring(sds_ring, budget);\r\nif (!tx_complete)\r\nwork_done = budget;\r\nif (work_done < budget) {\r\nnapi_complete(&sds_ring->napi);\r\nif (test_bit(__NX_DEV_UP, &adapter->state))\r\nnetxen_nic_enable_int(sds_ring);\r\n}\r\nreturn work_done;\r\n}\r\nstatic void netxen_nic_poll_controller(struct net_device *netdev)\r\n{\r\nint ring;\r\nstruct nx_host_sds_ring *sds_ring;\r\nstruct netxen_adapter *adapter = netdev_priv(netdev);\r\nstruct netxen_recv_context *recv_ctx = &adapter->recv_ctx;\r\ndisable_irq(adapter->irq);\r\nfor (ring = 0; ring < adapter->max_sds_rings; ring++) {\r\nsds_ring = &recv_ctx->sds_rings[ring];\r\nnetxen_intr(adapter->irq, sds_ring);\r\n}\r\nenable_irq(adapter->irq);\r\n}\r\nstatic int\r\nnx_incr_dev_ref_cnt(struct netxen_adapter *adapter)\r\n{\r\nint count;\r\nif (netxen_api_lock(adapter))\r\nreturn -EIO;\r\ncount = NXRD32(adapter, NX_CRB_DEV_REF_COUNT);\r\nNXWR32(adapter, NX_CRB_DEV_REF_COUNT, ++count);\r\nnetxen_api_unlock(adapter);\r\nreturn count;\r\n}\r\nstatic int\r\nnx_decr_dev_ref_cnt(struct netxen_adapter *adapter)\r\n{\r\nint count, state;\r\nif (netxen_api_lock(adapter))\r\nreturn -EIO;\r\ncount = NXRD32(adapter, NX_CRB_DEV_REF_COUNT);\r\nWARN_ON(count == 0);\r\nNXWR32(adapter, NX_CRB_DEV_REF_COUNT, --count);\r\nstate = NXRD32(adapter, NX_CRB_DEV_STATE);\r\nif (count == 0 && state != NX_DEV_FAILED)\r\nNXWR32(adapter, NX_CRB_DEV_STATE, NX_DEV_COLD);\r\nnetxen_api_unlock(adapter);\r\nreturn count;\r\n}\r\nstatic int\r\nnx_dev_request_aer(struct netxen_adapter *adapter)\r\n{\r\nu32 state;\r\nint ret = -EINVAL;\r\nif (netxen_api_lock(adapter))\r\nreturn ret;\r\nstate = NXRD32(adapter, NX_CRB_DEV_STATE);\r\nif (state == NX_DEV_NEED_AER)\r\nret = 0;\r\nelse if (state == NX_DEV_READY) {\r\nNXWR32(adapter, NX_CRB_DEV_STATE, NX_DEV_NEED_AER);\r\nret = 0;\r\n}\r\nnetxen_api_unlock(adapter);\r\nreturn ret;\r\n}\r\nint\r\nnx_dev_request_reset(struct netxen_adapter *adapter)\r\n{\r\nu32 state;\r\nint ret = -EINVAL;\r\nif (netxen_api_lock(adapter))\r\nreturn ret;\r\nstate = NXRD32(adapter, NX_CRB_DEV_STATE);\r\nif (state == NX_DEV_NEED_RESET || state == NX_DEV_FAILED)\r\nret = 0;\r\nelse if (state != NX_DEV_INITALIZING && state != NX_DEV_NEED_AER) {\r\nNXWR32(adapter, NX_CRB_DEV_STATE, NX_DEV_NEED_RESET);\r\nadapter->flags |= NETXEN_FW_RESET_OWNER;\r\nret = 0;\r\n}\r\nnetxen_api_unlock(adapter);\r\nreturn ret;\r\n}\r\nstatic int\r\nnetxen_can_start_firmware(struct netxen_adapter *adapter)\r\n{\r\nint count;\r\nint can_start = 0;\r\nif (netxen_api_lock(adapter)) {\r\nnx_incr_dev_ref_cnt(adapter);\r\nreturn -1;\r\n}\r\ncount = NXRD32(adapter, NX_CRB_DEV_REF_COUNT);\r\nif ((count < 0) || (count >= NX_MAX_PCI_FUNC))\r\ncount = 0;\r\nif (count == 0) {\r\ncan_start = 1;\r\nNXWR32(adapter, NX_CRB_DEV_STATE, NX_DEV_INITALIZING);\r\n}\r\nNXWR32(adapter, NX_CRB_DEV_REF_COUNT, ++count);\r\nnetxen_api_unlock(adapter);\r\nreturn can_start;\r\n}\r\nstatic void\r\nnetxen_schedule_work(struct netxen_adapter *adapter,\r\nwork_func_t func, int delay)\r\n{\r\nINIT_DELAYED_WORK(&adapter->fw_work, func);\r\nschedule_delayed_work(&adapter->fw_work, delay);\r\n}\r\nstatic void\r\nnetxen_cancel_fw_work(struct netxen_adapter *adapter)\r\n{\r\nwhile (test_and_set_bit(__NX_RESETTING, &adapter->state))\r\nmsleep(10);\r\ncancel_delayed_work_sync(&adapter->fw_work);\r\n}\r\nstatic void\r\nnetxen_attach_work(struct work_struct *work)\r\n{\r\nstruct netxen_adapter *adapter = container_of(work,\r\nstruct netxen_adapter, fw_work.work);\r\nstruct net_device *netdev = adapter->netdev;\r\nint err = 0;\r\nif (netif_running(netdev)) {\r\nerr = netxen_nic_attach(adapter);\r\nif (err)\r\ngoto done;\r\nerr = netxen_nic_up(adapter, netdev);\r\nif (err) {\r\nnetxen_nic_detach(adapter);\r\ngoto done;\r\n}\r\nnetxen_restore_indev_addr(netdev, NETDEV_UP);\r\n}\r\nnetif_device_attach(netdev);\r\ndone:\r\nadapter->fw_fail_cnt = 0;\r\nclear_bit(__NX_RESETTING, &adapter->state);\r\nnetxen_schedule_work(adapter, netxen_fw_poll_work, FW_POLL_DELAY);\r\n}\r\nstatic void\r\nnetxen_fwinit_work(struct work_struct *work)\r\n{\r\nstruct netxen_adapter *adapter = container_of(work,\r\nstruct netxen_adapter, fw_work.work);\r\nint dev_state;\r\nint count;\r\ndev_state = NXRD32(adapter, NX_CRB_DEV_STATE);\r\nif (adapter->flags & NETXEN_FW_RESET_OWNER) {\r\ncount = NXRD32(adapter, NX_CRB_DEV_REF_COUNT);\r\nWARN_ON(count == 0);\r\nif (count == 1) {\r\nif (adapter->mdump.md_enabled) {\r\nrtnl_lock();\r\nnetxen_dump_fw(adapter);\r\nrtnl_unlock();\r\n}\r\nadapter->flags &= ~NETXEN_FW_RESET_OWNER;\r\nif (netxen_api_lock(adapter)) {\r\nclear_bit(__NX_RESETTING, &adapter->state);\r\nNXWR32(adapter, NX_CRB_DEV_STATE,\r\nNX_DEV_FAILED);\r\nreturn;\r\n}\r\ncount = NXRD32(adapter, NX_CRB_DEV_REF_COUNT);\r\nNXWR32(adapter, NX_CRB_DEV_REF_COUNT, --count);\r\nNXWR32(adapter, NX_CRB_DEV_STATE, NX_DEV_COLD);\r\ndev_state = NX_DEV_COLD;\r\nnetxen_api_unlock(adapter);\r\n}\r\n}\r\nswitch (dev_state) {\r\ncase NX_DEV_COLD:\r\ncase NX_DEV_READY:\r\nif (!netxen_start_firmware(adapter)) {\r\nnetxen_schedule_work(adapter, netxen_attach_work, 0);\r\nreturn;\r\n}\r\nbreak;\r\ncase NX_DEV_NEED_RESET:\r\ncase NX_DEV_INITALIZING:\r\nnetxen_schedule_work(adapter,\r\nnetxen_fwinit_work, 2 * FW_POLL_DELAY);\r\nreturn;\r\ncase NX_DEV_FAILED:\r\ndefault:\r\nnx_incr_dev_ref_cnt(adapter);\r\nbreak;\r\n}\r\nif (netxen_api_lock(adapter)) {\r\nclear_bit(__NX_RESETTING, &adapter->state);\r\nreturn;\r\n}\r\nNXWR32(adapter, NX_CRB_DEV_STATE, NX_DEV_FAILED);\r\nnetxen_api_unlock(adapter);\r\ndev_err(&adapter->pdev->dev, "%s: Device initialization Failed\n",\r\nadapter->netdev->name);\r\nclear_bit(__NX_RESETTING, &adapter->state);\r\n}\r\nstatic void\r\nnetxen_detach_work(struct work_struct *work)\r\n{\r\nstruct netxen_adapter *adapter = container_of(work,\r\nstruct netxen_adapter, fw_work.work);\r\nstruct net_device *netdev = adapter->netdev;\r\nint ref_cnt = 0, delay;\r\nu32 status;\r\nnetif_device_detach(netdev);\r\nnetxen_nic_down(adapter, netdev);\r\nrtnl_lock();\r\nnetxen_nic_detach(adapter);\r\nrtnl_unlock();\r\nstatus = NXRD32(adapter, NETXEN_PEG_HALT_STATUS1);\r\nif (status & NX_RCODE_FATAL_ERROR)\r\ngoto err_ret;\r\nif (adapter->temp == NX_TEMP_PANIC)\r\ngoto err_ret;\r\nif (!(adapter->flags & NETXEN_FW_RESET_OWNER))\r\nref_cnt = nx_decr_dev_ref_cnt(adapter);\r\nif (ref_cnt == -EIO)\r\ngoto err_ret;\r\ndelay = (ref_cnt == 0) ? 0 : (2 * FW_POLL_DELAY);\r\nadapter->fw_wait_cnt = 0;\r\nnetxen_schedule_work(adapter, netxen_fwinit_work, delay);\r\nreturn;\r\nerr_ret:\r\nclear_bit(__NX_RESETTING, &adapter->state);\r\n}\r\nstatic int\r\nnetxen_check_health(struct netxen_adapter *adapter)\r\n{\r\nu32 state, heartbit;\r\nu32 peg_status;\r\nstruct net_device *netdev = adapter->netdev;\r\nstate = NXRD32(adapter, NX_CRB_DEV_STATE);\r\nif (state == NX_DEV_NEED_AER)\r\nreturn 0;\r\nif (netxen_nic_check_temp(adapter))\r\ngoto detach;\r\nif (adapter->need_fw_reset) {\r\nif (nx_dev_request_reset(adapter))\r\nreturn 0;\r\ngoto detach;\r\n}\r\nif (state == NX_DEV_NEED_RESET || state == NX_DEV_FAILED) {\r\nadapter->need_fw_reset = 1;\r\nif (NX_IS_REVISION_P2(adapter->ahw.revision_id))\r\ngoto detach;\r\n}\r\nif (NX_IS_REVISION_P2(adapter->ahw.revision_id))\r\nreturn 0;\r\nheartbit = NXRD32(adapter, NETXEN_PEG_ALIVE_COUNTER);\r\nif (heartbit != adapter->heartbit) {\r\nadapter->heartbit = heartbit;\r\nadapter->fw_fail_cnt = 0;\r\nif (adapter->need_fw_reset)\r\ngoto detach;\r\nreturn 0;\r\n}\r\nif (++adapter->fw_fail_cnt < FW_FAIL_THRESH)\r\nreturn 0;\r\nif (nx_dev_request_reset(adapter))\r\nreturn 0;\r\nclear_bit(__NX_FW_ATTACHED, &adapter->state);\r\ndev_err(&netdev->dev, "firmware hang detected\n");\r\npeg_status = NXRD32(adapter, NETXEN_PEG_HALT_STATUS1);\r\ndev_err(&adapter->pdev->dev, "Dumping hw/fw registers\n"\r\n"PEG_HALT_STATUS1: 0x%x, PEG_HALT_STATUS2: 0x%x,\n"\r\n"PEG_NET_0_PC: 0x%x, PEG_NET_1_PC: 0x%x,\n"\r\n"PEG_NET_2_PC: 0x%x, PEG_NET_3_PC: 0x%x,\n"\r\n"PEG_NET_4_PC: 0x%x\n",\r\npeg_status,\r\nNXRD32(adapter, NETXEN_PEG_HALT_STATUS2),\r\nNXRD32(adapter, NETXEN_CRB_PEG_NET_0 + 0x3c),\r\nNXRD32(adapter, NETXEN_CRB_PEG_NET_1 + 0x3c),\r\nNXRD32(adapter, NETXEN_CRB_PEG_NET_2 + 0x3c),\r\nNXRD32(adapter, NETXEN_CRB_PEG_NET_3 + 0x3c),\r\nNXRD32(adapter, NETXEN_CRB_PEG_NET_4 + 0x3c));\r\nif (NX_FWERROR_PEGSTAT1(peg_status) == 0x67)\r\ndev_err(&adapter->pdev->dev,\r\n"Firmware aborted with error code 0x00006700. "\r\n"Device is being reset.\n");\r\ndetach:\r\nif ((auto_fw_reset == AUTO_FW_RESET_ENABLED) &&\r\n!test_and_set_bit(__NX_RESETTING, &adapter->state))\r\nnetxen_schedule_work(adapter, netxen_detach_work, 0);\r\nreturn 1;\r\n}\r\nstatic void\r\nnetxen_fw_poll_work(struct work_struct *work)\r\n{\r\nstruct netxen_adapter *adapter = container_of(work,\r\nstruct netxen_adapter, fw_work.work);\r\nif (test_bit(__NX_RESETTING, &adapter->state))\r\ngoto reschedule;\r\nif (test_bit(__NX_DEV_UP, &adapter->state) &&\r\n!(adapter->capabilities & NX_FW_CAPABILITY_LINK_NOTIFICATION)) {\r\nif (!adapter->has_link_events) {\r\nnetxen_nic_handle_phy_intr(adapter);\r\nif (adapter->link_changed)\r\nnetxen_nic_set_link_parameters(adapter);\r\n}\r\n}\r\nif (netxen_check_health(adapter))\r\nreturn;\r\nreschedule:\r\nnetxen_schedule_work(adapter, netxen_fw_poll_work, FW_POLL_DELAY);\r\n}\r\nstatic ssize_t\r\nnetxen_store_bridged_mode(struct device *dev,\r\nstruct device_attribute *attr, const char *buf, size_t len)\r\n{\r\nstruct net_device *net = to_net_dev(dev);\r\nstruct netxen_adapter *adapter = netdev_priv(net);\r\nunsigned long new;\r\nint ret = -EINVAL;\r\nif (!(adapter->capabilities & NX_FW_CAPABILITY_BDG))\r\ngoto err_out;\r\nif (adapter->is_up != NETXEN_ADAPTER_UP_MAGIC)\r\ngoto err_out;\r\nif (kstrtoul(buf, 2, &new))\r\ngoto err_out;\r\nif (!netxen_config_bridged_mode(adapter, !!new))\r\nret = len;\r\nerr_out:\r\nreturn ret;\r\n}\r\nstatic ssize_t\r\nnetxen_show_bridged_mode(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct net_device *net = to_net_dev(dev);\r\nstruct netxen_adapter *adapter;\r\nint bridged_mode = 0;\r\nadapter = netdev_priv(net);\r\nif (adapter->capabilities & NX_FW_CAPABILITY_BDG)\r\nbridged_mode = !!(adapter->flags & NETXEN_NIC_BRIDGE_ENABLED);\r\nreturn sprintf(buf, "%d\n", bridged_mode);\r\n}\r\nstatic ssize_t\r\nnetxen_store_diag_mode(struct device *dev,\r\nstruct device_attribute *attr, const char *buf, size_t len)\r\n{\r\nstruct netxen_adapter *adapter = dev_get_drvdata(dev);\r\nunsigned long new;\r\nif (kstrtoul(buf, 2, &new))\r\nreturn -EINVAL;\r\nif (!!new != !!(adapter->flags & NETXEN_NIC_DIAG_ENABLED))\r\nadapter->flags ^= NETXEN_NIC_DIAG_ENABLED;\r\nreturn len;\r\n}\r\nstatic ssize_t\r\nnetxen_show_diag_mode(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct netxen_adapter *adapter = dev_get_drvdata(dev);\r\nreturn sprintf(buf, "%d\n",\r\n!!(adapter->flags & NETXEN_NIC_DIAG_ENABLED));\r\n}\r\nstatic int\r\nnetxen_sysfs_validate_crb(struct netxen_adapter *adapter,\r\nloff_t offset, size_t size)\r\n{\r\nsize_t crb_size = 4;\r\nif (!(adapter->flags & NETXEN_NIC_DIAG_ENABLED))\r\nreturn -EIO;\r\nif (offset < NETXEN_PCI_CRBSPACE) {\r\nif (NX_IS_REVISION_P2(adapter->ahw.revision_id))\r\nreturn -EINVAL;\r\nif (ADDR_IN_RANGE(offset, NETXEN_PCI_CAMQM,\r\nNETXEN_PCI_CAMQM_2M_END))\r\ncrb_size = 8;\r\nelse\r\nreturn -EINVAL;\r\n}\r\nif ((size != crb_size) || (offset & (crb_size-1)))\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\nstatic ssize_t\r\nnetxen_sysfs_read_crb(struct file *filp, struct kobject *kobj,\r\nstruct bin_attribute *attr,\r\nchar *buf, loff_t offset, size_t size)\r\n{\r\nstruct device *dev = container_of(kobj, struct device, kobj);\r\nstruct netxen_adapter *adapter = dev_get_drvdata(dev);\r\nu32 data;\r\nu64 qmdata;\r\nint ret;\r\nret = netxen_sysfs_validate_crb(adapter, offset, size);\r\nif (ret != 0)\r\nreturn ret;\r\nif (NX_IS_REVISION_P3(adapter->ahw.revision_id) &&\r\nADDR_IN_RANGE(offset, NETXEN_PCI_CAMQM,\r\nNETXEN_PCI_CAMQM_2M_END)) {\r\nnetxen_pci_camqm_read_2M(adapter, offset, &qmdata);\r\nmemcpy(buf, &qmdata, size);\r\n} else {\r\ndata = NXRD32(adapter, offset);\r\nmemcpy(buf, &data, size);\r\n}\r\nreturn size;\r\n}\r\nstatic ssize_t\r\nnetxen_sysfs_write_crb(struct file *filp, struct kobject *kobj,\r\nstruct bin_attribute *attr,\r\nchar *buf, loff_t offset, size_t size)\r\n{\r\nstruct device *dev = container_of(kobj, struct device, kobj);\r\nstruct netxen_adapter *adapter = dev_get_drvdata(dev);\r\nu32 data;\r\nu64 qmdata;\r\nint ret;\r\nret = netxen_sysfs_validate_crb(adapter, offset, size);\r\nif (ret != 0)\r\nreturn ret;\r\nif (NX_IS_REVISION_P3(adapter->ahw.revision_id) &&\r\nADDR_IN_RANGE(offset, NETXEN_PCI_CAMQM,\r\nNETXEN_PCI_CAMQM_2M_END)) {\r\nmemcpy(&qmdata, buf, size);\r\nnetxen_pci_camqm_write_2M(adapter, offset, qmdata);\r\n} else {\r\nmemcpy(&data, buf, size);\r\nNXWR32(adapter, offset, data);\r\n}\r\nreturn size;\r\n}\r\nstatic int\r\nnetxen_sysfs_validate_mem(struct netxen_adapter *adapter,\r\nloff_t offset, size_t size)\r\n{\r\nif (!(adapter->flags & NETXEN_NIC_DIAG_ENABLED))\r\nreturn -EIO;\r\nif ((size != 8) || (offset & 0x7))\r\nreturn -EIO;\r\nreturn 0;\r\n}\r\nstatic ssize_t\r\nnetxen_sysfs_read_mem(struct file *filp, struct kobject *kobj,\r\nstruct bin_attribute *attr,\r\nchar *buf, loff_t offset, size_t size)\r\n{\r\nstruct device *dev = container_of(kobj, struct device, kobj);\r\nstruct netxen_adapter *adapter = dev_get_drvdata(dev);\r\nu64 data;\r\nint ret;\r\nret = netxen_sysfs_validate_mem(adapter, offset, size);\r\nif (ret != 0)\r\nreturn ret;\r\nif (adapter->pci_mem_read(adapter, offset, &data))\r\nreturn -EIO;\r\nmemcpy(buf, &data, size);\r\nreturn size;\r\n}\r\nstatic ssize_t netxen_sysfs_write_mem(struct file *filp, struct kobject *kobj,\r\nstruct bin_attribute *attr, char *buf,\r\nloff_t offset, size_t size)\r\n{\r\nstruct device *dev = container_of(kobj, struct device, kobj);\r\nstruct netxen_adapter *adapter = dev_get_drvdata(dev);\r\nu64 data;\r\nint ret;\r\nret = netxen_sysfs_validate_mem(adapter, offset, size);\r\nif (ret != 0)\r\nreturn ret;\r\nmemcpy(&data, buf, size);\r\nif (adapter->pci_mem_write(adapter, offset, data))\r\nreturn -EIO;\r\nreturn size;\r\n}\r\nstatic ssize_t\r\nnetxen_sysfs_read_dimm(struct file *filp, struct kobject *kobj,\r\nstruct bin_attribute *attr,\r\nchar *buf, loff_t offset, size_t size)\r\n{\r\nstruct device *dev = container_of(kobj, struct device, kobj);\r\nstruct netxen_adapter *adapter = dev_get_drvdata(dev);\r\nstruct net_device *netdev = adapter->netdev;\r\nstruct netxen_dimm_cfg dimm;\r\nu8 dw, rows, cols, banks, ranks;\r\nu32 val;\r\nif (size < attr->size) {\r\nnetdev_err(netdev, "Invalid size\n");\r\nreturn -EINVAL;\r\n}\r\nmemset(&dimm, 0, sizeof(struct netxen_dimm_cfg));\r\nval = NXRD32(adapter, NETXEN_DIMM_CAPABILITY);\r\nif (val & NETXEN_DIMM_VALID_FLAG) {\r\nnetdev_err(netdev, "Invalid DIMM flag\n");\r\ndimm.presence = 0xff;\r\ngoto out;\r\n}\r\nrows = NETXEN_DIMM_NUMROWS(val);\r\ncols = NETXEN_DIMM_NUMCOLS(val);\r\nranks = NETXEN_DIMM_NUMRANKS(val);\r\nbanks = NETXEN_DIMM_NUMBANKS(val);\r\ndw = NETXEN_DIMM_DATAWIDTH(val);\r\ndimm.presence = (val & NETXEN_DIMM_PRESENT);\r\nif (!dimm.presence) {\r\nnetdev_err(netdev, "DIMM not present\n");\r\ngoto out;\r\n}\r\ndimm.dimm_type = NETXEN_DIMM_TYPE(val);\r\nswitch (dimm.dimm_type) {\r\ncase NETXEN_DIMM_TYPE_RDIMM:\r\ncase NETXEN_DIMM_TYPE_UDIMM:\r\ncase NETXEN_DIMM_TYPE_SO_DIMM:\r\ncase NETXEN_DIMM_TYPE_Micro_DIMM:\r\ncase NETXEN_DIMM_TYPE_Mini_RDIMM:\r\ncase NETXEN_DIMM_TYPE_Mini_UDIMM:\r\nbreak;\r\ndefault:\r\nnetdev_err(netdev, "Invalid DIMM type %x\n", dimm.dimm_type);\r\ngoto out;\r\n}\r\nif (val & NETXEN_DIMM_MEMTYPE_DDR2_SDRAM)\r\ndimm.mem_type = NETXEN_DIMM_MEM_DDR2_SDRAM;\r\nelse\r\ndimm.mem_type = NETXEN_DIMM_MEMTYPE(val);\r\nif (val & NETXEN_DIMM_SIZE) {\r\ndimm.size = NETXEN_DIMM_STD_MEM_SIZE;\r\ngoto out;\r\n}\r\nif (!rows) {\r\nnetdev_err(netdev, "Invalid no of rows %x\n", rows);\r\ngoto out;\r\n}\r\nif (!cols) {\r\nnetdev_err(netdev, "Invalid no of columns %x\n", cols);\r\ngoto out;\r\n}\r\nif (!banks) {\r\nnetdev_err(netdev, "Invalid no of banks %x\n", banks);\r\ngoto out;\r\n}\r\nranks += 1;\r\nswitch (dw) {\r\ncase 0x0:\r\ndw = 32;\r\nbreak;\r\ncase 0x1:\r\ndw = 33;\r\nbreak;\r\ncase 0x2:\r\ndw = 36;\r\nbreak;\r\ncase 0x3:\r\ndw = 64;\r\nbreak;\r\ncase 0x4:\r\ndw = 72;\r\nbreak;\r\ncase 0x5:\r\ndw = 80;\r\nbreak;\r\ncase 0x6:\r\ndw = 128;\r\nbreak;\r\ncase 0x7:\r\ndw = 144;\r\nbreak;\r\ndefault:\r\nnetdev_err(netdev, "Invalid data-width %x\n", dw);\r\ngoto out;\r\n}\r\ndimm.size = ((1 << rows) * (1 << cols) * dw * banks * ranks) / 8;\r\ndimm.size = (dimm.size) / 0x100000;\r\nout:\r\nmemcpy(buf, &dimm, sizeof(struct netxen_dimm_cfg));\r\nreturn sizeof(struct netxen_dimm_cfg);\r\n}\r\nstatic void\r\nnetxen_create_sysfs_entries(struct netxen_adapter *adapter)\r\n{\r\nstruct device *dev = &adapter->pdev->dev;\r\nif (adapter->capabilities & NX_FW_CAPABILITY_BDG) {\r\nif (device_create_file(dev, &dev_attr_bridged_mode)) {\r\ndev_warn(dev,\r\n"failed to create bridged_mode sysfs entry\n");\r\n}\r\n}\r\n}\r\nstatic void\r\nnetxen_remove_sysfs_entries(struct netxen_adapter *adapter)\r\n{\r\nstruct device *dev = &adapter->pdev->dev;\r\nif (adapter->capabilities & NX_FW_CAPABILITY_BDG)\r\ndevice_remove_file(dev, &dev_attr_bridged_mode);\r\n}\r\nstatic void\r\nnetxen_create_diag_entries(struct netxen_adapter *adapter)\r\n{\r\nstruct pci_dev *pdev = adapter->pdev;\r\nstruct device *dev;\r\ndev = &pdev->dev;\r\nif (device_create_file(dev, &dev_attr_diag_mode))\r\ndev_info(dev, "failed to create diag_mode sysfs entry\n");\r\nif (device_create_bin_file(dev, &bin_attr_crb))\r\ndev_info(dev, "failed to create crb sysfs entry\n");\r\nif (device_create_bin_file(dev, &bin_attr_mem))\r\ndev_info(dev, "failed to create mem sysfs entry\n");\r\nif (device_create_bin_file(dev, &bin_attr_dimm))\r\ndev_info(dev, "failed to create dimm sysfs entry\n");\r\n}\r\nstatic void\r\nnetxen_remove_diag_entries(struct netxen_adapter *adapter)\r\n{\r\nstruct pci_dev *pdev = adapter->pdev;\r\nstruct device *dev = &pdev->dev;\r\ndevice_remove_file(dev, &dev_attr_diag_mode);\r\ndevice_remove_bin_file(dev, &bin_attr_crb);\r\ndevice_remove_bin_file(dev, &bin_attr_mem);\r\ndevice_remove_bin_file(dev, &bin_attr_dimm);\r\n}\r\nstatic int\r\nnetxen_destip_supported(struct netxen_adapter *adapter)\r\n{\r\nif (NX_IS_REVISION_P2(adapter->ahw.revision_id))\r\nreturn 0;\r\nif (adapter->ahw.cut_through)\r\nreturn 0;\r\nreturn 1;\r\n}\r\nstatic void\r\nnetxen_free_ip_list(struct netxen_adapter *adapter, bool master)\r\n{\r\nstruct nx_ip_list *cur, *tmp_cur;\r\nlist_for_each_entry_safe(cur, tmp_cur, &adapter->ip_list, list) {\r\nif (master) {\r\nif (cur->master) {\r\nnetxen_config_ipaddr(adapter, cur->ip_addr,\r\nNX_IP_DOWN);\r\nlist_del(&cur->list);\r\nkfree(cur);\r\n}\r\n} else {\r\nnetxen_config_ipaddr(adapter, cur->ip_addr, NX_IP_DOWN);\r\nlist_del(&cur->list);\r\nkfree(cur);\r\n}\r\n}\r\n}\r\nstatic bool\r\nnetxen_list_config_ip(struct netxen_adapter *adapter,\r\nstruct in_ifaddr *ifa, unsigned long event)\r\n{\r\nstruct net_device *dev;\r\nstruct nx_ip_list *cur, *tmp_cur;\r\nstruct list_head *head;\r\nbool ret = false;\r\ndev = ifa->ifa_dev ? ifa->ifa_dev->dev : NULL;\r\nif (dev == NULL)\r\ngoto out;\r\nswitch (event) {\r\ncase NX_IP_UP:\r\nlist_for_each(head, &adapter->ip_list) {\r\ncur = list_entry(head, struct nx_ip_list, list);\r\nif (cur->ip_addr == ifa->ifa_address)\r\ngoto out;\r\n}\r\ncur = kzalloc(sizeof(struct nx_ip_list), GFP_ATOMIC);\r\nif (cur == NULL)\r\ngoto out;\r\nif (dev->priv_flags & IFF_802_1Q_VLAN)\r\ndev = vlan_dev_real_dev(dev);\r\ncur->master = !!netif_is_bond_master(dev);\r\ncur->ip_addr = ifa->ifa_address;\r\nlist_add_tail(&cur->list, &adapter->ip_list);\r\nnetxen_config_ipaddr(adapter, ifa->ifa_address, NX_IP_UP);\r\nret = true;\r\nbreak;\r\ncase NX_IP_DOWN:\r\nlist_for_each_entry_safe(cur, tmp_cur,\r\n&adapter->ip_list, list) {\r\nif (cur->ip_addr == ifa->ifa_address) {\r\nlist_del(&cur->list);\r\nkfree(cur);\r\nnetxen_config_ipaddr(adapter, ifa->ifa_address,\r\nNX_IP_DOWN);\r\nret = true;\r\nbreak;\r\n}\r\n}\r\n}\r\nout:\r\nreturn ret;\r\n}\r\nstatic void\r\nnetxen_config_indev_addr(struct netxen_adapter *adapter,\r\nstruct net_device *dev, unsigned long event)\r\n{\r\nstruct in_device *indev;\r\nif (!netxen_destip_supported(adapter))\r\nreturn;\r\nindev = in_dev_get(dev);\r\nif (!indev)\r\nreturn;\r\nfor_ifa(indev) {\r\nswitch (event) {\r\ncase NETDEV_UP:\r\nnetxen_list_config_ip(adapter, ifa, NX_IP_UP);\r\nbreak;\r\ncase NETDEV_DOWN:\r\nnetxen_list_config_ip(adapter, ifa, NX_IP_DOWN);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n} endfor_ifa(indev);\r\nin_dev_put(indev);\r\n}\r\nstatic void\r\nnetxen_restore_indev_addr(struct net_device *netdev, unsigned long event)\r\n{\r\nstruct netxen_adapter *adapter = netdev_priv(netdev);\r\nstruct nx_ip_list *pos, *tmp_pos;\r\nunsigned long ip_event;\r\nip_event = (event == NETDEV_UP) ? NX_IP_UP : NX_IP_DOWN;\r\nnetxen_config_indev_addr(adapter, netdev, event);\r\nlist_for_each_entry_safe(pos, tmp_pos, &adapter->ip_list, list) {\r\nnetxen_config_ipaddr(adapter, pos->ip_addr, ip_event);\r\n}\r\n}\r\nstatic inline bool\r\nnetxen_config_checkdev(struct net_device *dev)\r\n{\r\nstruct netxen_adapter *adapter;\r\nif (!is_netxen_netdev(dev))\r\nreturn false;\r\nadapter = netdev_priv(dev);\r\nif (!adapter)\r\nreturn false;\r\nif (!netxen_destip_supported(adapter))\r\nreturn false;\r\nif (adapter->is_up != NETXEN_ADAPTER_UP_MAGIC)\r\nreturn false;\r\nreturn true;\r\n}\r\nstatic void netxen_config_master(struct net_device *dev, unsigned long event)\r\n{\r\nstruct net_device *master, *slave;\r\nstruct netxen_adapter *adapter = netdev_priv(dev);\r\nrcu_read_lock();\r\nmaster = netdev_master_upper_dev_get_rcu(dev);\r\nif (master && netif_is_bond_master(master) &&\r\n!netif_is_bond_slave(dev)) {\r\nnetxen_config_indev_addr(adapter, master, event);\r\nfor_each_netdev_rcu(&init_net, slave)\r\nif (slave->priv_flags & IFF_802_1Q_VLAN &&\r\nvlan_dev_real_dev(slave) == master)\r\nnetxen_config_indev_addr(adapter, slave, event);\r\n}\r\nrcu_read_unlock();\r\nif (!master && dev->priv_flags & IFF_BONDING)\r\nnetxen_free_ip_list(adapter, true);\r\n}\r\nstatic int netxen_netdev_event(struct notifier_block *this,\r\nunsigned long event, void *ptr)\r\n{\r\nstruct netxen_adapter *adapter;\r\nstruct net_device *dev = netdev_notifier_info_to_dev(ptr);\r\nstruct net_device *orig_dev = dev;\r\nstruct net_device *slave;\r\nrecheck:\r\nif (dev == NULL)\r\ngoto done;\r\nif (dev->priv_flags & IFF_802_1Q_VLAN) {\r\ndev = vlan_dev_real_dev(dev);\r\ngoto recheck;\r\n}\r\nif (event == NETDEV_UP || event == NETDEV_DOWN) {\r\nif (netif_is_bond_master(dev)) {\r\nrcu_read_lock();\r\nfor_each_netdev_in_bond_rcu(dev, slave) {\r\nif (!netxen_config_checkdev(slave))\r\ncontinue;\r\nadapter = netdev_priv(slave);\r\nnetxen_config_indev_addr(adapter,\r\norig_dev, event);\r\n}\r\nrcu_read_unlock();\r\n} else {\r\nif (!netxen_config_checkdev(dev))\r\ngoto done;\r\nadapter = netdev_priv(dev);\r\nif (orig_dev == dev)\r\nnetxen_config_master(dev, event);\r\nnetxen_config_indev_addr(adapter, orig_dev, event);\r\n}\r\n}\r\ndone:\r\nreturn NOTIFY_DONE;\r\n}\r\nstatic int\r\nnetxen_inetaddr_event(struct notifier_block *this,\r\nunsigned long event, void *ptr)\r\n{\r\nstruct netxen_adapter *adapter;\r\nstruct net_device *dev, *slave;\r\nstruct in_ifaddr *ifa = (struct in_ifaddr *)ptr;\r\nunsigned long ip_event;\r\ndev = ifa->ifa_dev ? ifa->ifa_dev->dev : NULL;\r\nip_event = (event == NETDEV_UP) ? NX_IP_UP : NX_IP_DOWN;\r\nrecheck:\r\nif (dev == NULL)\r\ngoto done;\r\nif (dev->priv_flags & IFF_802_1Q_VLAN) {\r\ndev = vlan_dev_real_dev(dev);\r\ngoto recheck;\r\n}\r\nif (event == NETDEV_UP || event == NETDEV_DOWN) {\r\nif (netif_is_bond_master(dev)) {\r\nrcu_read_lock();\r\nfor_each_netdev_in_bond_rcu(dev, slave) {\r\nif (!netxen_config_checkdev(slave))\r\ncontinue;\r\nadapter = netdev_priv(slave);\r\nnetxen_list_config_ip(adapter, ifa, ip_event);\r\n}\r\nrcu_read_unlock();\r\n} else {\r\nif (!netxen_config_checkdev(dev))\r\ngoto done;\r\nadapter = netdev_priv(dev);\r\nnetxen_list_config_ip(adapter, ifa, ip_event);\r\n}\r\n}\r\ndone:\r\nreturn NOTIFY_DONE;\r\n}\r\nstatic void\r\nnetxen_restore_indev_addr(struct net_device *dev, unsigned long event)\r\n{ }\r\nstatic void\r\nnetxen_free_ip_list(struct netxen_adapter *adapter, bool master)\r\n{ }\r\nstatic int __init netxen_init_module(void)\r\n{\r\nprintk(KERN_INFO "%s\n", netxen_nic_driver_string);\r\n#ifdef CONFIG_INET\r\nregister_netdevice_notifier(&netxen_netdev_cb);\r\nregister_inetaddr_notifier(&netxen_inetaddr_cb);\r\n#endif\r\nreturn pci_register_driver(&netxen_driver);\r\n}\r\nstatic void __exit netxen_exit_module(void)\r\n{\r\npci_unregister_driver(&netxen_driver);\r\n#ifdef CONFIG_INET\r\nunregister_inetaddr_notifier(&netxen_inetaddr_cb);\r\nunregister_netdevice_notifier(&netxen_netdev_cb);\r\n#endif\r\n}
