static inline bool is_percpu_irq(irq_hw_number_t irq)\r\n{\r\nif (irq <= ARMADA_370_XP_MAX_PER_CPU_IRQS)\r\nreturn true;\r\nreturn false;\r\n}\r\nstatic void armada_370_xp_irq_mask(struct irq_data *d)\r\n{\r\nirq_hw_number_t hwirq = irqd_to_hwirq(d);\r\nif (!is_percpu_irq(hwirq))\r\nwritel(hwirq, main_int_base +\r\nARMADA_370_XP_INT_CLEAR_ENABLE_OFFS);\r\nelse\r\nwritel(hwirq, per_cpu_int_base +\r\nARMADA_370_XP_INT_SET_MASK_OFFS);\r\n}\r\nstatic void armada_370_xp_irq_unmask(struct irq_data *d)\r\n{\r\nirq_hw_number_t hwirq = irqd_to_hwirq(d);\r\nif (!is_percpu_irq(hwirq))\r\nwritel(hwirq, main_int_base +\r\nARMADA_370_XP_INT_SET_ENABLE_OFFS);\r\nelse\r\nwritel(hwirq, per_cpu_int_base +\r\nARMADA_370_XP_INT_CLEAR_MASK_OFFS);\r\n}\r\nstatic int armada_370_xp_alloc_msi(void)\r\n{\r\nint hwirq;\r\nmutex_lock(&msi_used_lock);\r\nhwirq = find_first_zero_bit(&msi_used, PCI_MSI_DOORBELL_NR);\r\nif (hwirq >= PCI_MSI_DOORBELL_NR)\r\nhwirq = -ENOSPC;\r\nelse\r\nset_bit(hwirq, msi_used);\r\nmutex_unlock(&msi_used_lock);\r\nreturn hwirq;\r\n}\r\nstatic void armada_370_xp_free_msi(int hwirq)\r\n{\r\nmutex_lock(&msi_used_lock);\r\nif (!test_bit(hwirq, msi_used))\r\npr_err("trying to free unused MSI#%d\n", hwirq);\r\nelse\r\nclear_bit(hwirq, msi_used);\r\nmutex_unlock(&msi_used_lock);\r\n}\r\nstatic int armada_370_xp_setup_msi_irq(struct msi_controller *chip,\r\nstruct pci_dev *pdev,\r\nstruct msi_desc *desc)\r\n{\r\nstruct msi_msg msg;\r\nint virq, hwirq;\r\nif (desc->msi_attrib.is_msix)\r\nreturn -EINVAL;\r\nhwirq = armada_370_xp_alloc_msi();\r\nif (hwirq < 0)\r\nreturn hwirq;\r\nvirq = irq_create_mapping(armada_370_xp_msi_domain, hwirq);\r\nif (!virq) {\r\narmada_370_xp_free_msi(hwirq);\r\nreturn -EINVAL;\r\n}\r\nirq_set_msi_desc(virq, desc);\r\nmsg.address_lo = msi_doorbell_addr;\r\nmsg.address_hi = 0;\r\nmsg.data = 0xf00 | (hwirq + 16);\r\npci_write_msi_msg(virq, &msg);\r\nreturn 0;\r\n}\r\nstatic void armada_370_xp_teardown_msi_irq(struct msi_controller *chip,\r\nunsigned int irq)\r\n{\r\nstruct irq_data *d = irq_get_irq_data(irq);\r\nunsigned long hwirq = d->hwirq;\r\nirq_dispose_mapping(irq);\r\narmada_370_xp_free_msi(hwirq);\r\n}\r\nstatic int armada_370_xp_msi_map(struct irq_domain *domain, unsigned int virq,\r\nirq_hw_number_t hw)\r\n{\r\nirq_set_chip_and_handler(virq, &armada_370_xp_msi_irq_chip,\r\nhandle_simple_irq);\r\nreturn 0;\r\n}\r\nstatic int armada_370_xp_msi_init(struct device_node *node,\r\nphys_addr_t main_int_phys_base)\r\n{\r\nstruct msi_controller *msi_chip;\r\nu32 reg;\r\nint ret;\r\nmsi_doorbell_addr = main_int_phys_base +\r\nARMADA_370_XP_SW_TRIG_INT_OFFS;\r\nmsi_chip = kzalloc(sizeof(*msi_chip), GFP_KERNEL);\r\nif (!msi_chip)\r\nreturn -ENOMEM;\r\nmsi_chip->setup_irq = armada_370_xp_setup_msi_irq;\r\nmsi_chip->teardown_irq = armada_370_xp_teardown_msi_irq;\r\nmsi_chip->of_node = node;\r\narmada_370_xp_msi_domain =\r\nirq_domain_add_linear(NULL, PCI_MSI_DOORBELL_NR,\r\n&armada_370_xp_msi_irq_ops,\r\nNULL);\r\nif (!armada_370_xp_msi_domain) {\r\nkfree(msi_chip);\r\nreturn -ENOMEM;\r\n}\r\nret = of_pci_msi_chip_add(msi_chip);\r\nif (ret < 0) {\r\nirq_domain_remove(armada_370_xp_msi_domain);\r\nkfree(msi_chip);\r\nreturn ret;\r\n}\r\nreg = readl(per_cpu_int_base + ARMADA_370_XP_IN_DRBEL_MSK_OFFS)\r\n| PCI_MSI_DOORBELL_MASK;\r\nwritel(reg, per_cpu_int_base +\r\nARMADA_370_XP_IN_DRBEL_MSK_OFFS);\r\nwritel(1, per_cpu_int_base + ARMADA_370_XP_INT_CLEAR_MASK_OFFS);\r\nreturn 0;\r\n}\r\nstatic inline int armada_370_xp_msi_init(struct device_node *node,\r\nphys_addr_t main_int_phys_base)\r\n{\r\nreturn 0;\r\n}\r\nstatic int armada_xp_set_affinity(struct irq_data *d,\r\nconst struct cpumask *mask_val, bool force)\r\n{\r\nirq_hw_number_t hwirq = irqd_to_hwirq(d);\r\nunsigned long reg, mask;\r\nint cpu;\r\ncpu = cpumask_any_and(mask_val, cpu_online_mask);\r\nmask = 1UL << cpu_logical_map(cpu);\r\nraw_spin_lock(&irq_controller_lock);\r\nreg = readl(main_int_base + ARMADA_370_XP_INT_SOURCE_CTL(hwirq));\r\nreg = (reg & (~ARMADA_370_XP_INT_SOURCE_CPU_MASK)) | mask;\r\nwritel(reg, main_int_base + ARMADA_370_XP_INT_SOURCE_CTL(hwirq));\r\nraw_spin_unlock(&irq_controller_lock);\r\nreturn IRQ_SET_MASK_OK;\r\n}\r\nstatic int armada_370_xp_mpic_irq_map(struct irq_domain *h,\r\nunsigned int virq, irq_hw_number_t hw)\r\n{\r\narmada_370_xp_irq_mask(irq_get_irq_data(virq));\r\nif (!is_percpu_irq(hw))\r\nwritel(hw, per_cpu_int_base +\r\nARMADA_370_XP_INT_CLEAR_MASK_OFFS);\r\nelse\r\nwritel(hw, main_int_base + ARMADA_370_XP_INT_SET_ENABLE_OFFS);\r\nirq_set_status_flags(virq, IRQ_LEVEL);\r\nif (is_percpu_irq(hw)) {\r\nirq_set_percpu_devid(virq);\r\nirq_set_chip_and_handler(virq, &armada_370_xp_irq_chip,\r\nhandle_percpu_devid_irq);\r\n} else {\r\nirq_set_chip_and_handler(virq, &armada_370_xp_irq_chip,\r\nhandle_level_irq);\r\n}\r\nirq_set_probe(virq);\r\nirq_clear_status_flags(virq, IRQ_NOAUTOEN);\r\nreturn 0;\r\n}\r\nstatic void armada_xp_mpic_smp_cpu_init(void)\r\n{\r\nu32 control;\r\nint nr_irqs, i;\r\ncontrol = readl(main_int_base + ARMADA_370_XP_INT_CONTROL);\r\nnr_irqs = (control >> 2) & 0x3ff;\r\nfor (i = 0; i < nr_irqs; i++)\r\nwritel(i, per_cpu_int_base + ARMADA_370_XP_INT_SET_MASK_OFFS);\r\nwritel(0, per_cpu_int_base + ARMADA_370_XP_IN_DRBEL_CAUSE_OFFS);\r\nwritel(IPI_DOORBELL_MASK, per_cpu_int_base +\r\nARMADA_370_XP_IN_DRBEL_MSK_OFFS);\r\nwritel(0, per_cpu_int_base + ARMADA_370_XP_INT_CLEAR_MASK_OFFS);\r\n}\r\nstatic void armada_xp_mpic_perf_init(void)\r\n{\r\nunsigned long cpuid = cpu_logical_map(smp_processor_id());\r\nwritel(ARMADA_370_XP_INT_CAUSE_PERF(cpuid),\r\nper_cpu_int_base + ARMADA_370_XP_INT_FABRIC_MASK_OFFS);\r\n}\r\nstatic void armada_mpic_send_doorbell(const struct cpumask *mask,\r\nunsigned int irq)\r\n{\r\nint cpu;\r\nunsigned long map = 0;\r\nfor_each_cpu(cpu, mask)\r\nmap |= 1 << cpu_logical_map(cpu);\r\ndsb();\r\nwritel((map << 8) | irq, main_int_base +\r\nARMADA_370_XP_SW_TRIG_INT_OFFS);\r\n}\r\nstatic int armada_xp_mpic_secondary_init(struct notifier_block *nfb,\r\nunsigned long action, void *hcpu)\r\n{\r\nif (action == CPU_STARTING || action == CPU_STARTING_FROZEN) {\r\narmada_xp_mpic_perf_init();\r\narmada_xp_mpic_smp_cpu_init();\r\n}\r\nreturn NOTIFY_OK;\r\n}\r\nstatic int mpic_cascaded_secondary_init(struct notifier_block *nfb,\r\nunsigned long action, void *hcpu)\r\n{\r\nif (action == CPU_STARTING || action == CPU_STARTING_FROZEN) {\r\narmada_xp_mpic_perf_init();\r\nenable_percpu_irq(parent_irq, IRQ_TYPE_NONE);\r\n}\r\nreturn NOTIFY_OK;\r\n}\r\nstatic void armada_370_xp_handle_msi_irq(struct pt_regs *regs, bool is_chained)\r\n{\r\nu32 msimask, msinr;\r\nmsimask = readl_relaxed(per_cpu_int_base +\r\nARMADA_370_XP_IN_DRBEL_CAUSE_OFFS)\r\n& PCI_MSI_DOORBELL_MASK;\r\nwritel(~msimask, per_cpu_int_base +\r\nARMADA_370_XP_IN_DRBEL_CAUSE_OFFS);\r\nfor (msinr = PCI_MSI_DOORBELL_START;\r\nmsinr < PCI_MSI_DOORBELL_END; msinr++) {\r\nint irq;\r\nif (!(msimask & BIT(msinr)))\r\ncontinue;\r\nif (is_chained) {\r\nirq = irq_find_mapping(armada_370_xp_msi_domain,\r\nmsinr - 16);\r\ngeneric_handle_irq(irq);\r\n} else {\r\nirq = msinr - 16;\r\nhandle_domain_irq(armada_370_xp_msi_domain,\r\nirq, regs);\r\n}\r\n}\r\n}\r\nstatic void armada_370_xp_handle_msi_irq(struct pt_regs *r, bool b) {}\r\nstatic void armada_370_xp_mpic_handle_cascade_irq(struct irq_desc *desc)\r\n{\r\nstruct irq_chip *chip = irq_desc_get_chip(desc);\r\nunsigned long irqmap, irqn, irqsrc, cpuid;\r\nunsigned int cascade_irq;\r\nchained_irq_enter(chip, desc);\r\nirqmap = readl_relaxed(per_cpu_int_base + ARMADA_375_PPI_CAUSE);\r\ncpuid = cpu_logical_map(smp_processor_id());\r\nfor_each_set_bit(irqn, &irqmap, BITS_PER_LONG) {\r\nirqsrc = readl_relaxed(main_int_base +\r\nARMADA_370_XP_INT_SOURCE_CTL(irqn));\r\nif (!(irqsrc & ARMADA_370_XP_INT_IRQ_FIQ_MASK(cpuid)))\r\ncontinue;\r\nif (irqn == 1) {\r\narmada_370_xp_handle_msi_irq(NULL, true);\r\ncontinue;\r\n}\r\ncascade_irq = irq_find_mapping(armada_370_xp_mpic_domain, irqn);\r\ngeneric_handle_irq(cascade_irq);\r\n}\r\nchained_irq_exit(chip, desc);\r\n}\r\nstatic void __exception_irq_entry\r\narmada_370_xp_handle_irq(struct pt_regs *regs)\r\n{\r\nu32 irqstat, irqnr;\r\ndo {\r\nirqstat = readl_relaxed(per_cpu_int_base +\r\nARMADA_370_XP_CPU_INTACK_OFFS);\r\nirqnr = irqstat & 0x3FF;\r\nif (irqnr > 1022)\r\nbreak;\r\nif (irqnr > 1) {\r\nhandle_domain_irq(armada_370_xp_mpic_domain,\r\nirqnr, regs);\r\ncontinue;\r\n}\r\nif (irqnr == 1)\r\narmada_370_xp_handle_msi_irq(regs, false);\r\n#ifdef CONFIG_SMP\r\nif (irqnr == 0) {\r\nu32 ipimask, ipinr;\r\nipimask = readl_relaxed(per_cpu_int_base +\r\nARMADA_370_XP_IN_DRBEL_CAUSE_OFFS)\r\n& IPI_DOORBELL_MASK;\r\nwritel(~ipimask, per_cpu_int_base +\r\nARMADA_370_XP_IN_DRBEL_CAUSE_OFFS);\r\nfor (ipinr = IPI_DOORBELL_START;\r\nipinr < IPI_DOORBELL_END; ipinr++) {\r\nif (ipimask & (0x1 << ipinr))\r\nhandle_IPI(ipinr, regs);\r\n}\r\ncontinue;\r\n}\r\n#endif\r\n} while (1);\r\n}\r\nstatic int armada_370_xp_mpic_suspend(void)\r\n{\r\ndoorbell_mask_reg = readl(per_cpu_int_base +\r\nARMADA_370_XP_IN_DRBEL_MSK_OFFS);\r\nreturn 0;\r\n}\r\nstatic void armada_370_xp_mpic_resume(void)\r\n{\r\nint nirqs;\r\nirq_hw_number_t irq;\r\nnirqs = (readl(main_int_base + ARMADA_370_XP_INT_CONTROL) >> 2) & 0x3ff;\r\nfor (irq = 0; irq < nirqs; irq++) {\r\nstruct irq_data *data;\r\nint virq;\r\nvirq = irq_linear_revmap(armada_370_xp_mpic_domain, irq);\r\nif (virq == 0)\r\ncontinue;\r\nif (!is_percpu_irq(irq))\r\nwritel(irq, per_cpu_int_base +\r\nARMADA_370_XP_INT_CLEAR_MASK_OFFS);\r\nelse\r\nwritel(irq, main_int_base +\r\nARMADA_370_XP_INT_SET_ENABLE_OFFS);\r\ndata = irq_get_irq_data(virq);\r\nif (!irqd_irq_disabled(data))\r\narmada_370_xp_irq_unmask(data);\r\n}\r\nwritel(doorbell_mask_reg,\r\nper_cpu_int_base + ARMADA_370_XP_IN_DRBEL_MSK_OFFS);\r\nif (doorbell_mask_reg & IPI_DOORBELL_MASK)\r\nwritel(0, per_cpu_int_base + ARMADA_370_XP_INT_CLEAR_MASK_OFFS);\r\nif (doorbell_mask_reg & PCI_MSI_DOORBELL_MASK)\r\nwritel(1, per_cpu_int_base + ARMADA_370_XP_INT_CLEAR_MASK_OFFS);\r\n}\r\nstatic int __init armada_370_xp_mpic_of_init(struct device_node *node,\r\nstruct device_node *parent)\r\n{\r\nstruct resource main_int_res, per_cpu_int_res;\r\nint nr_irqs, i;\r\nu32 control;\r\nBUG_ON(of_address_to_resource(node, 0, &main_int_res));\r\nBUG_ON(of_address_to_resource(node, 1, &per_cpu_int_res));\r\nBUG_ON(!request_mem_region(main_int_res.start,\r\nresource_size(&main_int_res),\r\nnode->full_name));\r\nBUG_ON(!request_mem_region(per_cpu_int_res.start,\r\nresource_size(&per_cpu_int_res),\r\nnode->full_name));\r\nmain_int_base = ioremap(main_int_res.start,\r\nresource_size(&main_int_res));\r\nBUG_ON(!main_int_base);\r\nper_cpu_int_base = ioremap(per_cpu_int_res.start,\r\nresource_size(&per_cpu_int_res));\r\nBUG_ON(!per_cpu_int_base);\r\ncontrol = readl(main_int_base + ARMADA_370_XP_INT_CONTROL);\r\nnr_irqs = (control >> 2) & 0x3ff;\r\nfor (i = 0; i < nr_irqs; i++)\r\nwritel(i, main_int_base + ARMADA_370_XP_INT_CLEAR_ENABLE_OFFS);\r\narmada_370_xp_mpic_domain =\r\nirq_domain_add_linear(node, nr_irqs,\r\n&armada_370_xp_mpic_irq_ops, NULL);\r\nBUG_ON(!armada_370_xp_mpic_domain);\r\narmada_xp_mpic_perf_init();\r\narmada_xp_mpic_smp_cpu_init();\r\narmada_370_xp_msi_init(node, main_int_res.start);\r\nparent_irq = irq_of_parse_and_map(node, 0);\r\nif (parent_irq <= 0) {\r\nirq_set_default_host(armada_370_xp_mpic_domain);\r\nset_handle_irq(armada_370_xp_handle_irq);\r\n#ifdef CONFIG_SMP\r\nset_smp_cross_call(armada_mpic_send_doorbell);\r\nregister_cpu_notifier(&armada_370_xp_mpic_cpu_notifier);\r\n#endif\r\n} else {\r\n#ifdef CONFIG_SMP\r\nregister_cpu_notifier(&mpic_cascaded_cpu_notifier);\r\n#endif\r\nirq_set_chained_handler(parent_irq,\r\narmada_370_xp_mpic_handle_cascade_irq);\r\n}\r\nregister_syscore_ops(&armada_370_xp_mpic_syscore_ops);\r\nreturn 0;\r\n}
