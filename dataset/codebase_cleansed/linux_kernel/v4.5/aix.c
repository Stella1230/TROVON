static u64 last_lba(struct block_device *bdev)\r\n{\r\nif (!bdev || !bdev->bd_inode)\r\nreturn 0;\r\nreturn (bdev->bd_inode->i_size >> 9) - 1ULL;\r\n}\r\nstatic size_t read_lba(struct parsed_partitions *state, u64 lba, u8 *buffer,\r\nsize_t count)\r\n{\r\nsize_t totalreadcount = 0;\r\nif (!buffer || lba + count / 512 > last_lba(state->bdev))\r\nreturn 0;\r\nwhile (count) {\r\nint copied = 512;\r\nSector sect;\r\nunsigned char *data = read_part_sector(state, lba++, &sect);\r\nif (!data)\r\nbreak;\r\nif (copied > count)\r\ncopied = count;\r\nmemcpy(buffer, data, copied);\r\nput_dev_sector(sect);\r\nbuffer += copied;\r\ntotalreadcount += copied;\r\ncount -= copied;\r\n}\r\nreturn totalreadcount;\r\n}\r\nstatic struct pvd *alloc_pvd(struct parsed_partitions *state, u32 lba)\r\n{\r\nsize_t count = sizeof(struct pvd);\r\nstruct pvd *p;\r\np = kmalloc(count, GFP_KERNEL);\r\nif (!p)\r\nreturn NULL;\r\nif (read_lba(state, lba, (u8 *) p, count) < count) {\r\nkfree(p);\r\nreturn NULL;\r\n}\r\nreturn p;\r\n}\r\nstatic struct lvname *alloc_lvn(struct parsed_partitions *state, u32 lba)\r\n{\r\nsize_t count = sizeof(struct lvname) * LVM_MAXLVS;\r\nstruct lvname *p;\r\np = kmalloc(count, GFP_KERNEL);\r\nif (!p)\r\nreturn NULL;\r\nif (read_lba(state, lba, (u8 *) p, count) < count) {\r\nkfree(p);\r\nreturn NULL;\r\n}\r\nreturn p;\r\n}\r\nint aix_partition(struct parsed_partitions *state)\r\n{\r\nint ret = 0;\r\nSector sect;\r\nunsigned char *d;\r\nu32 pp_bytes_size;\r\nu32 pp_blocks_size = 0;\r\nu32 vgda_sector = 0;\r\nu32 vgda_len = 0;\r\nint numlvs = 0;\r\nstruct pvd *pvd;\r\nstruct lv_info {\r\nunsigned short pps_per_lv;\r\nunsigned short pps_found;\r\nunsigned char lv_is_contiguous;\r\n} *lvip;\r\nstruct lvname *n = NULL;\r\nd = read_part_sector(state, 7, &sect);\r\nif (d) {\r\nstruct lvm_rec *p = (struct lvm_rec *)d;\r\nu16 lvm_version = be16_to_cpu(p->version);\r\nchar tmp[64];\r\nif (lvm_version == 1) {\r\nint pp_size_log2 = be16_to_cpu(p->pp_size);\r\npp_bytes_size = 1 << pp_size_log2;\r\npp_blocks_size = pp_bytes_size / 512;\r\nsnprintf(tmp, sizeof(tmp),\r\n" AIX LVM header version %u found\n",\r\nlvm_version);\r\nvgda_len = be32_to_cpu(p->vgda_len);\r\nvgda_sector = be32_to_cpu(p->vgda_psn[0]);\r\n} else {\r\nsnprintf(tmp, sizeof(tmp),\r\n" unsupported AIX LVM version %d found\n",\r\nlvm_version);\r\n}\r\nstrlcat(state->pp_buf, tmp, PAGE_SIZE);\r\nput_dev_sector(sect);\r\n}\r\nif (vgda_sector && (d = read_part_sector(state, vgda_sector, &sect))) {\r\nstruct vgda *p = (struct vgda *)d;\r\nnumlvs = be16_to_cpu(p->numlvs);\r\nput_dev_sector(sect);\r\n}\r\nlvip = kcalloc(state->limit, sizeof(struct lv_info), GFP_KERNEL);\r\nif (!lvip)\r\nreturn 0;\r\nif (numlvs && (d = read_part_sector(state, vgda_sector + 1, &sect))) {\r\nstruct lvd *p = (struct lvd *)d;\r\nint i;\r\nn = alloc_lvn(state, vgda_sector + vgda_len - 33);\r\nif (n) {\r\nint foundlvs = 0;\r\nfor (i = 0; foundlvs < numlvs && i < state->limit; i += 1) {\r\nlvip[i].pps_per_lv = be16_to_cpu(p[i].num_lps);\r\nif (lvip[i].pps_per_lv)\r\nfoundlvs += 1;\r\n}\r\n}\r\nput_dev_sector(sect);\r\n}\r\npvd = alloc_pvd(state, vgda_sector + 17);\r\nif (pvd) {\r\nint numpps = be16_to_cpu(pvd->pp_count);\r\nint psn_part1 = be32_to_cpu(pvd->psn_part1);\r\nint i;\r\nint cur_lv_ix = -1;\r\nint next_lp_ix = 1;\r\nint lp_ix;\r\nfor (i = 0; i < numpps; i += 1) {\r\nstruct ppe *p = pvd->ppe + i;\r\nunsigned int lv_ix;\r\nlp_ix = be16_to_cpu(p->lp_ix);\r\nif (!lp_ix) {\r\nnext_lp_ix = 1;\r\ncontinue;\r\n}\r\nlv_ix = be16_to_cpu(p->lv_ix) - 1;\r\nif (lv_ix >= state->limit) {\r\ncur_lv_ix = -1;\r\ncontinue;\r\n}\r\nlvip[lv_ix].pps_found += 1;\r\nif (lp_ix == 1) {\r\ncur_lv_ix = lv_ix;\r\nnext_lp_ix = 1;\r\n} else if (lv_ix != cur_lv_ix || lp_ix != next_lp_ix) {\r\nnext_lp_ix = 1;\r\ncontinue;\r\n}\r\nif (lp_ix == lvip[lv_ix].pps_per_lv) {\r\nchar tmp[70];\r\nput_partition(state, lv_ix + 1,\r\n(i + 1 - lp_ix) * pp_blocks_size + psn_part1,\r\nlvip[lv_ix].pps_per_lv * pp_blocks_size);\r\nsnprintf(tmp, sizeof(tmp), " <%s>\n",\r\nn[lv_ix].name);\r\nstrlcat(state->pp_buf, tmp, PAGE_SIZE);\r\nlvip[lv_ix].lv_is_contiguous = 1;\r\nret = 1;\r\nnext_lp_ix = 1;\r\n} else\r\nnext_lp_ix += 1;\r\n}\r\nfor (i = 0; i < state->limit; i += 1)\r\nif (lvip[i].pps_found && !lvip[i].lv_is_contiguous)\r\npr_warn("partition %s (%u pp's found) is "\r\n"not contiguous\n",\r\nn[i].name, lvip[i].pps_found);\r\nkfree(pvd);\r\n}\r\nkfree(n);\r\nkfree(lvip);\r\nreturn ret;\r\n}
