static inline int ssm2602_get_coeff(int mclk, int rate)\r\n{\r\nint i;\r\nfor (i = 0; i < ARRAY_SIZE(ssm2602_coeff_table); i++) {\r\nif (ssm2602_coeff_table[i].rate == rate &&\r\nssm2602_coeff_table[i].mclk == mclk)\r\nreturn ssm2602_coeff_table[i].srate;\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int ssm2602_hw_params(struct snd_pcm_substream *substream,\r\nstruct snd_pcm_hw_params *params,\r\nstruct snd_soc_dai *dai)\r\n{\r\nstruct snd_soc_codec *codec = dai->codec;\r\nstruct ssm2602_priv *ssm2602 = snd_soc_codec_get_drvdata(codec);\r\nint srate = ssm2602_get_coeff(ssm2602->sysclk, params_rate(params));\r\nunsigned int iface;\r\nif (srate < 0)\r\nreturn srate;\r\nregmap_write(ssm2602->regmap, SSM2602_SRATE, srate);\r\nswitch (params_width(params)) {\r\ncase 16:\r\niface = 0x0;\r\nbreak;\r\ncase 20:\r\niface = 0x4;\r\nbreak;\r\ncase 24:\r\niface = 0x8;\r\nbreak;\r\ncase 32:\r\niface = 0xc;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nregmap_update_bits(ssm2602->regmap, SSM2602_IFACE,\r\nIFACE_AUDIO_DATA_LEN, iface);\r\nreturn 0;\r\n}\r\nstatic int ssm2602_startup(struct snd_pcm_substream *substream,\r\nstruct snd_soc_dai *dai)\r\n{\r\nstruct snd_soc_codec *codec = dai->codec;\r\nstruct ssm2602_priv *ssm2602 = snd_soc_codec_get_drvdata(codec);\r\nif (ssm2602->sysclk_constraints) {\r\nsnd_pcm_hw_constraint_list(substream->runtime, 0,\r\nSNDRV_PCM_HW_PARAM_RATE,\r\nssm2602->sysclk_constraints);\r\n}\r\nreturn 0;\r\n}\r\nstatic int ssm2602_mute(struct snd_soc_dai *dai, int mute)\r\n{\r\nstruct ssm2602_priv *ssm2602 = snd_soc_codec_get_drvdata(dai->codec);\r\nif (mute)\r\nregmap_update_bits(ssm2602->regmap, SSM2602_APDIGI,\r\nAPDIGI_ENABLE_DAC_MUTE,\r\nAPDIGI_ENABLE_DAC_MUTE);\r\nelse\r\nregmap_update_bits(ssm2602->regmap, SSM2602_APDIGI,\r\nAPDIGI_ENABLE_DAC_MUTE, 0);\r\nreturn 0;\r\n}\r\nstatic int ssm2602_set_dai_sysclk(struct snd_soc_dai *codec_dai,\r\nint clk_id, unsigned int freq, int dir)\r\n{\r\nstruct snd_soc_codec *codec = codec_dai->codec;\r\nstruct ssm2602_priv *ssm2602 = snd_soc_codec_get_drvdata(codec);\r\nif (dir == SND_SOC_CLOCK_IN) {\r\nif (clk_id != SSM2602_SYSCLK)\r\nreturn -EINVAL;\r\nswitch (freq) {\r\ncase 12288000:\r\ncase 18432000:\r\nssm2602->sysclk_constraints = &ssm2602_constraints_12288000;\r\nbreak;\r\ncase 11289600:\r\ncase 16934400:\r\nssm2602->sysclk_constraints = &ssm2602_constraints_11289600;\r\nbreak;\r\ncase 12000000:\r\nssm2602->sysclk_constraints = NULL;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nssm2602->sysclk = freq;\r\n} else {\r\nunsigned int mask;\r\nswitch (clk_id) {\r\ncase SSM2602_CLK_CLKOUT:\r\nmask = PWR_CLK_OUT_PDN;\r\nbreak;\r\ncase SSM2602_CLK_XTO:\r\nmask = PWR_OSC_PDN;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nif (freq == 0)\r\nssm2602->clk_out_pwr |= mask;\r\nelse\r\nssm2602->clk_out_pwr &= ~mask;\r\nregmap_update_bits(ssm2602->regmap, SSM2602_PWR,\r\nPWR_CLK_OUT_PDN | PWR_OSC_PDN, ssm2602->clk_out_pwr);\r\n}\r\nreturn 0;\r\n}\r\nstatic int ssm2602_set_dai_fmt(struct snd_soc_dai *codec_dai,\r\nunsigned int fmt)\r\n{\r\nstruct ssm2602_priv *ssm2602 = snd_soc_codec_get_drvdata(codec_dai->codec);\r\nunsigned int iface = 0;\r\nswitch (fmt & SND_SOC_DAIFMT_MASTER_MASK) {\r\ncase SND_SOC_DAIFMT_CBM_CFM:\r\niface |= 0x0040;\r\nbreak;\r\ncase SND_SOC_DAIFMT_CBS_CFS:\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nswitch (fmt & SND_SOC_DAIFMT_FORMAT_MASK) {\r\ncase SND_SOC_DAIFMT_I2S:\r\niface |= 0x0002;\r\nbreak;\r\ncase SND_SOC_DAIFMT_RIGHT_J:\r\nbreak;\r\ncase SND_SOC_DAIFMT_LEFT_J:\r\niface |= 0x0001;\r\nbreak;\r\ncase SND_SOC_DAIFMT_DSP_A:\r\niface |= 0x0013;\r\nbreak;\r\ncase SND_SOC_DAIFMT_DSP_B:\r\niface |= 0x0003;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nswitch (fmt & SND_SOC_DAIFMT_INV_MASK) {\r\ncase SND_SOC_DAIFMT_NB_NF:\r\nbreak;\r\ncase SND_SOC_DAIFMT_IB_IF:\r\niface |= 0x0090;\r\nbreak;\r\ncase SND_SOC_DAIFMT_IB_NF:\r\niface |= 0x0080;\r\nbreak;\r\ncase SND_SOC_DAIFMT_NB_IF:\r\niface |= 0x0010;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nregmap_write(ssm2602->regmap, SSM2602_IFACE, iface);\r\nreturn 0;\r\n}\r\nstatic int ssm2602_set_bias_level(struct snd_soc_codec *codec,\r\nenum snd_soc_bias_level level)\r\n{\r\nstruct ssm2602_priv *ssm2602 = snd_soc_codec_get_drvdata(codec);\r\nswitch (level) {\r\ncase SND_SOC_BIAS_ON:\r\nregmap_update_bits(ssm2602->regmap, SSM2602_PWR,\r\nPWR_POWER_OFF | PWR_CLK_OUT_PDN | PWR_OSC_PDN,\r\nssm2602->clk_out_pwr);\r\nbreak;\r\ncase SND_SOC_BIAS_PREPARE:\r\nbreak;\r\ncase SND_SOC_BIAS_STANDBY:\r\nregmap_update_bits(ssm2602->regmap, SSM2602_PWR,\r\nPWR_POWER_OFF | PWR_CLK_OUT_PDN | PWR_OSC_PDN,\r\nPWR_CLK_OUT_PDN | PWR_OSC_PDN);\r\nbreak;\r\ncase SND_SOC_BIAS_OFF:\r\nregmap_update_bits(ssm2602->regmap, SSM2602_PWR,\r\nPWR_POWER_OFF, PWR_POWER_OFF);\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic int ssm2602_resume(struct snd_soc_codec *codec)\r\n{\r\nstruct ssm2602_priv *ssm2602 = snd_soc_codec_get_drvdata(codec);\r\nregcache_sync(ssm2602->regmap);\r\nreturn 0;\r\n}\r\nstatic int ssm2602_codec_probe(struct snd_soc_codec *codec)\r\n{\r\nstruct snd_soc_dapm_context *dapm = snd_soc_codec_get_dapm(codec);\r\nstruct ssm2602_priv *ssm2602 = snd_soc_codec_get_drvdata(codec);\r\nint ret;\r\nregmap_update_bits(ssm2602->regmap, SSM2602_LOUT1V,\r\nLOUT1V_LRHP_BOTH, LOUT1V_LRHP_BOTH);\r\nregmap_update_bits(ssm2602->regmap, SSM2602_ROUT1V,\r\nROUT1V_RLHP_BOTH, ROUT1V_RLHP_BOTH);\r\nret = snd_soc_add_codec_controls(codec, ssm2602_snd_controls,\r\nARRAY_SIZE(ssm2602_snd_controls));\r\nif (ret)\r\nreturn ret;\r\nret = snd_soc_dapm_new_controls(dapm, ssm2602_dapm_widgets,\r\nARRAY_SIZE(ssm2602_dapm_widgets));\r\nif (ret)\r\nreturn ret;\r\nreturn snd_soc_dapm_add_routes(dapm, ssm2602_routes,\r\nARRAY_SIZE(ssm2602_routes));\r\n}\r\nstatic int ssm2604_codec_probe(struct snd_soc_codec *codec)\r\n{\r\nstruct snd_soc_dapm_context *dapm = snd_soc_codec_get_dapm(codec);\r\nint ret;\r\nret = snd_soc_dapm_new_controls(dapm, ssm2604_dapm_widgets,\r\nARRAY_SIZE(ssm2604_dapm_widgets));\r\nif (ret)\r\nreturn ret;\r\nreturn snd_soc_dapm_add_routes(dapm, ssm2604_routes,\r\nARRAY_SIZE(ssm2604_routes));\r\n}\r\nstatic int ssm260x_codec_probe(struct snd_soc_codec *codec)\r\n{\r\nstruct ssm2602_priv *ssm2602 = snd_soc_codec_get_drvdata(codec);\r\nint ret;\r\nret = regmap_write(ssm2602->regmap, SSM2602_RESET, 0);\r\nif (ret < 0) {\r\ndev_err(codec->dev, "Failed to issue reset: %d\n", ret);\r\nreturn ret;\r\n}\r\nregmap_update_bits(ssm2602->regmap, SSM2602_LINVOL,\r\nLINVOL_LRIN_BOTH, LINVOL_LRIN_BOTH);\r\nregmap_update_bits(ssm2602->regmap, SSM2602_RINVOL,\r\nRINVOL_RLIN_BOTH, RINVOL_RLIN_BOTH);\r\nregmap_write(ssm2602->regmap, SSM2602_APANA, APANA_SELECT_DAC |\r\nAPANA_ENABLE_MIC_BOOST);\r\nswitch (ssm2602->type) {\r\ncase SSM2602:\r\nret = ssm2602_codec_probe(codec);\r\nbreak;\r\ncase SSM2604:\r\nret = ssm2604_codec_probe(codec);\r\nbreak;\r\n}\r\nreturn ret;\r\n}\r\nstatic bool ssm2602_register_volatile(struct device *dev, unsigned int reg)\r\n{\r\nreturn reg == SSM2602_RESET;\r\n}\r\nint ssm2602_probe(struct device *dev, enum ssm2602_type type,\r\nstruct regmap *regmap)\r\n{\r\nstruct ssm2602_priv *ssm2602;\r\nif (IS_ERR(regmap))\r\nreturn PTR_ERR(regmap);\r\nssm2602 = devm_kzalloc(dev, sizeof(*ssm2602), GFP_KERNEL);\r\nif (ssm2602 == NULL)\r\nreturn -ENOMEM;\r\ndev_set_drvdata(dev, ssm2602);\r\nssm2602->type = type;\r\nssm2602->regmap = regmap;\r\nreturn snd_soc_register_codec(dev, &soc_codec_dev_ssm2602,\r\n&ssm2602_dai, 1);\r\n}
