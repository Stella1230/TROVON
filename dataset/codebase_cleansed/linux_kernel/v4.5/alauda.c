static struct alauda_card_info *alauda_card_find_id(unsigned char id)\r\n{\r\nint i;\r\nfor (i = 0; alauda_card_ids[i].id != 0; i++)\r\nif (alauda_card_ids[i].id == id)\r\nreturn &(alauda_card_ids[i]);\r\nreturn NULL;\r\n}\r\nstatic void nand_init_ecc(void)\r\n{\r\nint i, j, a;\r\nparity[0] = 0;\r\nfor (i = 1; i < 256; i++)\r\nparity[i] = (parity[i&(i-1)] ^ 1);\r\nfor (i = 0; i < 256; i++) {\r\na = 0;\r\nfor (j = 0; j < 8; j++) {\r\nif (i & (1<<j)) {\r\nif ((j & 1) == 0)\r\na ^= 0x04;\r\nif ((j & 2) == 0)\r\na ^= 0x10;\r\nif ((j & 4) == 0)\r\na ^= 0x40;\r\n}\r\n}\r\necc2[i] = ~(a ^ (a<<1) ^ (parity[i] ? 0xa8 : 0));\r\n}\r\n}\r\nstatic void nand_compute_ecc(unsigned char *data, unsigned char *ecc)\r\n{\r\nint i, j, a;\r\nunsigned char par = 0, bit, bits[8] = {0};\r\nfor (i = 0; i < 256; i++) {\r\npar ^= data[i];\r\nbit = parity[data[i]];\r\nfor (j = 0; j < 8; j++)\r\nif ((i & (1<<j)) == 0)\r\nbits[j] ^= bit;\r\n}\r\na = (bits[3] << 6) + (bits[2] << 4) + (bits[1] << 2) + bits[0];\r\necc[0] = ~(a ^ (a<<1) ^ (parity[par] ? 0xaa : 0));\r\na = (bits[7] << 6) + (bits[6] << 4) + (bits[5] << 2) + bits[4];\r\necc[1] = ~(a ^ (a<<1) ^ (parity[par] ? 0xaa : 0));\r\necc[2] = ecc2[par];\r\n}\r\nstatic int nand_compare_ecc(unsigned char *data, unsigned char *ecc)\r\n{\r\nreturn (data[0] == ecc[0] && data[1] == ecc[1] && data[2] == ecc[2]);\r\n}\r\nstatic void nand_store_ecc(unsigned char *data, unsigned char *ecc)\r\n{\r\nmemcpy(data, ecc, 3);\r\n}\r\nstatic void alauda_free_maps (struct alauda_media_info *media_info)\r\n{\r\nunsigned int shift = media_info->zoneshift\r\n+ media_info->blockshift + media_info->pageshift;\r\nunsigned int num_zones = media_info->capacity >> shift;\r\nunsigned int i;\r\nif (media_info->lba_to_pba != NULL)\r\nfor (i = 0; i < num_zones; i++) {\r\nkfree(media_info->lba_to_pba[i]);\r\nmedia_info->lba_to_pba[i] = NULL;\r\n}\r\nif (media_info->pba_to_lba != NULL)\r\nfor (i = 0; i < num_zones; i++) {\r\nkfree(media_info->pba_to_lba[i]);\r\nmedia_info->pba_to_lba[i] = NULL;\r\n}\r\n}\r\nstatic int alauda_get_media_status(struct us_data *us, unsigned char *data)\r\n{\r\nint rc;\r\nunsigned char command;\r\nif (MEDIA_PORT(us) == ALAUDA_PORT_XD)\r\ncommand = ALAUDA_GET_XD_MEDIA_STATUS;\r\nelse\r\ncommand = ALAUDA_GET_SM_MEDIA_STATUS;\r\nrc = usb_stor_ctrl_transfer(us, us->recv_ctrl_pipe,\r\ncommand, 0xc0, 0, 1, data, 2);\r\nusb_stor_dbg(us, "Media status %02X %02X\n", data[0], data[1]);\r\nreturn rc;\r\n}\r\nstatic int alauda_ack_media(struct us_data *us)\r\n{\r\nunsigned char command;\r\nif (MEDIA_PORT(us) == ALAUDA_PORT_XD)\r\ncommand = ALAUDA_ACK_XD_MEDIA_CHANGE;\r\nelse\r\ncommand = ALAUDA_ACK_SM_MEDIA_CHANGE;\r\nreturn usb_stor_ctrl_transfer(us, us->send_ctrl_pipe,\r\ncommand, 0x40, 0, 1, NULL, 0);\r\n}\r\nstatic int alauda_get_media_signature(struct us_data *us, unsigned char *data)\r\n{\r\nunsigned char command;\r\nif (MEDIA_PORT(us) == ALAUDA_PORT_XD)\r\ncommand = ALAUDA_GET_XD_MEDIA_SIG;\r\nelse\r\ncommand = ALAUDA_GET_SM_MEDIA_SIG;\r\nreturn usb_stor_ctrl_transfer(us, us->recv_ctrl_pipe,\r\ncommand, 0xc0, 0, 0, data, 4);\r\n}\r\nstatic int alauda_reset_media(struct us_data *us)\r\n{\r\nunsigned char *command = us->iobuf;\r\nmemset(command, 0, 9);\r\ncommand[0] = ALAUDA_BULK_CMD;\r\ncommand[1] = ALAUDA_BULK_RESET_MEDIA;\r\ncommand[8] = MEDIA_PORT(us);\r\nreturn usb_stor_bulk_transfer_buf(us, us->send_bulk_pipe,\r\ncommand, 9, NULL);\r\n}\r\nstatic int alauda_init_media(struct us_data *us)\r\n{\r\nunsigned char *data = us->iobuf;\r\nint ready = 0;\r\nstruct alauda_card_info *media_info;\r\nunsigned int num_zones;\r\nwhile (ready == 0) {\r\nmsleep(20);\r\nif (alauda_get_media_status(us, data) != USB_STOR_XFER_GOOD)\r\nreturn USB_STOR_TRANSPORT_ERROR;\r\nif (data[0] & 0x10)\r\nready = 1;\r\n}\r\nusb_stor_dbg(us, "We are ready for action!\n");\r\nif (alauda_ack_media(us) != USB_STOR_XFER_GOOD)\r\nreturn USB_STOR_TRANSPORT_ERROR;\r\nmsleep(10);\r\nif (alauda_get_media_status(us, data) != USB_STOR_XFER_GOOD)\r\nreturn USB_STOR_TRANSPORT_ERROR;\r\nif (data[0] != 0x14) {\r\nusb_stor_dbg(us, "Media not ready after ack\n");\r\nreturn USB_STOR_TRANSPORT_ERROR;\r\n}\r\nif (alauda_get_media_signature(us, data) != USB_STOR_XFER_GOOD)\r\nreturn USB_STOR_TRANSPORT_ERROR;\r\nusb_stor_dbg(us, "Media signature: %4ph\n", data);\r\nmedia_info = alauda_card_find_id(data[1]);\r\nif (media_info == NULL) {\r\npr_warn("alauda_init_media: Unrecognised media signature: %4ph\n",\r\ndata);\r\nreturn USB_STOR_TRANSPORT_ERROR;\r\n}\r\nMEDIA_INFO(us).capacity = 1 << media_info->chipshift;\r\nusb_stor_dbg(us, "Found media with capacity: %ldMB\n",\r\nMEDIA_INFO(us).capacity >> 20);\r\nMEDIA_INFO(us).pageshift = media_info->pageshift;\r\nMEDIA_INFO(us).blockshift = media_info->blockshift;\r\nMEDIA_INFO(us).zoneshift = media_info->zoneshift;\r\nMEDIA_INFO(us).pagesize = 1 << media_info->pageshift;\r\nMEDIA_INFO(us).blocksize = 1 << media_info->blockshift;\r\nMEDIA_INFO(us).zonesize = 1 << media_info->zoneshift;\r\nMEDIA_INFO(us).uzonesize = ((1 << media_info->zoneshift) / 128) * 125;\r\nMEDIA_INFO(us).blockmask = MEDIA_INFO(us).blocksize - 1;\r\nnum_zones = MEDIA_INFO(us).capacity >> (MEDIA_INFO(us).zoneshift\r\n+ MEDIA_INFO(us).blockshift + MEDIA_INFO(us).pageshift);\r\nMEDIA_INFO(us).pba_to_lba = kcalloc(num_zones, sizeof(u16*), GFP_NOIO);\r\nMEDIA_INFO(us).lba_to_pba = kcalloc(num_zones, sizeof(u16*), GFP_NOIO);\r\nif (alauda_reset_media(us) != USB_STOR_XFER_GOOD)\r\nreturn USB_STOR_TRANSPORT_ERROR;\r\nreturn USB_STOR_TRANSPORT_GOOD;\r\n}\r\nstatic int alauda_check_media(struct us_data *us)\r\n{\r\nstruct alauda_info *info = (struct alauda_info *) us->extra;\r\nunsigned char status[2];\r\nint rc;\r\nrc = alauda_get_media_status(us, status);\r\nif ((status[0] & 0x80) || ((status[0] & 0x1F) == 0x10)\r\n|| ((status[1] & 0x01) == 0)) {\r\nusb_stor_dbg(us, "No media, or door open\n");\r\nalauda_free_maps(&MEDIA_INFO(us));\r\ninfo->sense_key = 0x02;\r\ninfo->sense_asc = 0x3A;\r\ninfo->sense_ascq = 0x00;\r\nreturn USB_STOR_TRANSPORT_FAILED;\r\n}\r\nif (status[0] & 0x08) {\r\nusb_stor_dbg(us, "Media change detected\n");\r\nalauda_free_maps(&MEDIA_INFO(us));\r\nalauda_init_media(us);\r\ninfo->sense_key = UNIT_ATTENTION;\r\ninfo->sense_asc = 0x28;\r\ninfo->sense_ascq = 0x00;\r\nreturn USB_STOR_TRANSPORT_FAILED;\r\n}\r\nreturn USB_STOR_TRANSPORT_GOOD;\r\n}\r\nstatic int alauda_check_status2(struct us_data *us)\r\n{\r\nint rc;\r\nunsigned char command[] = {\r\nALAUDA_BULK_CMD, ALAUDA_BULK_GET_STATUS2,\r\n0, 0, 0, 0, 3, 0, MEDIA_PORT(us)\r\n};\r\nunsigned char data[3];\r\nrc = usb_stor_bulk_transfer_buf(us, us->send_bulk_pipe,\r\ncommand, 9, NULL);\r\nif (rc != USB_STOR_XFER_GOOD)\r\nreturn rc;\r\nrc = usb_stor_bulk_transfer_buf(us, us->recv_bulk_pipe,\r\ndata, 3, NULL);\r\nif (rc != USB_STOR_XFER_GOOD)\r\nreturn rc;\r\nusb_stor_dbg(us, "%3ph\n", data);\r\nif (data[0] & ALAUDA_STATUS_ERROR)\r\nreturn USB_STOR_XFER_ERROR;\r\nreturn USB_STOR_XFER_GOOD;\r\n}\r\nstatic int alauda_get_redu_data(struct us_data *us, u16 pba, unsigned char *data)\r\n{\r\nint rc;\r\nunsigned char command[] = {\r\nALAUDA_BULK_CMD, ALAUDA_BULK_GET_REDU_DATA,\r\nPBA_HI(pba), PBA_ZONE(pba), 0, PBA_LO(pba), 0, 0, MEDIA_PORT(us)\r\n};\r\nrc = usb_stor_bulk_transfer_buf(us, us->send_bulk_pipe,\r\ncommand, 9, NULL);\r\nif (rc != USB_STOR_XFER_GOOD)\r\nreturn rc;\r\nreturn usb_stor_bulk_transfer_buf(us, us->recv_bulk_pipe,\r\ndata, 16, NULL);\r\n}\r\nstatic u16 alauda_find_unused_pba(struct alauda_media_info *info,\r\nunsigned int zone)\r\n{\r\nu16 *pba_to_lba = info->pba_to_lba[zone];\r\nunsigned int i;\r\nfor (i = 0; i < info->zonesize; i++)\r\nif (pba_to_lba[i] == UNDEF)\r\nreturn (zone << info->zoneshift) + i;\r\nreturn 0;\r\n}\r\nstatic int alauda_read_map(struct us_data *us, unsigned int zone)\r\n{\r\nunsigned char *data = us->iobuf;\r\nint result;\r\nint i, j;\r\nunsigned int zonesize = MEDIA_INFO(us).zonesize;\r\nunsigned int uzonesize = MEDIA_INFO(us).uzonesize;\r\nunsigned int lba_offset, lba_real, blocknum;\r\nunsigned int zone_base_lba = zone * uzonesize;\r\nunsigned int zone_base_pba = zone * zonesize;\r\nu16 *lba_to_pba = kcalloc(zonesize, sizeof(u16), GFP_NOIO);\r\nu16 *pba_to_lba = kcalloc(zonesize, sizeof(u16), GFP_NOIO);\r\nif (lba_to_pba == NULL || pba_to_lba == NULL) {\r\nresult = USB_STOR_TRANSPORT_ERROR;\r\ngoto error;\r\n}\r\nusb_stor_dbg(us, "Mapping blocks for zone %d\n", zone);\r\nfor (i = 0; i < zonesize; i++)\r\nlba_to_pba[i] = pba_to_lba[i] = UNDEF;\r\nfor (i = 0; i < zonesize; i++) {\r\nblocknum = zone_base_pba + i;\r\nresult = alauda_get_redu_data(us, blocknum, data);\r\nif (result != USB_STOR_XFER_GOOD) {\r\nresult = USB_STOR_TRANSPORT_ERROR;\r\ngoto error;\r\n}\r\nfor (j = 0; j < 16; j++)\r\nif (data[j] != 0)\r\ngoto nonz;\r\npba_to_lba[i] = UNUSABLE;\r\nusb_stor_dbg(us, "PBA %d has no logical mapping\n", blocknum);\r\ncontinue;\r\nnonz:\r\nfor (j = 0; j < 16; j++)\r\nif (data[j] != 0xff)\r\ngoto nonff;\r\ncontinue;\r\nnonff:\r\nif (j < 6) {\r\nusb_stor_dbg(us, "PBA %d has no logical mapping: reserved area = %02X%02X%02X%02X data status %02X block status %02X\n",\r\nblocknum,\r\ndata[0], data[1], data[2], data[3],\r\ndata[4], data[5]);\r\npba_to_lba[i] = UNUSABLE;\r\ncontinue;\r\n}\r\nif ((data[6] >> 4) != 0x01) {\r\nusb_stor_dbg(us, "PBA %d has invalid address field %02X%02X/%02X%02X\n",\r\nblocknum, data[6], data[7],\r\ndata[11], data[12]);\r\npba_to_lba[i] = UNUSABLE;\r\ncontinue;\r\n}\r\nif (parity[data[6] ^ data[7]]) {\r\nprintk(KERN_WARNING\r\n"alauda_read_map: Bad parity in LBA for block %d"\r\n" (%02X %02X)\n", i, data[6], data[7]);\r\npba_to_lba[i] = UNUSABLE;\r\ncontinue;\r\n}\r\nlba_offset = short_pack(data[7], data[6]);\r\nlba_offset = (lba_offset & 0x07FF) >> 1;\r\nlba_real = lba_offset + zone_base_lba;\r\nif (lba_offset >= uzonesize) {\r\nprintk(KERN_WARNING\r\n"alauda_read_map: Bad low LBA %d for block %d\n",\r\nlba_real, blocknum);\r\ncontinue;\r\n}\r\nif (lba_to_pba[lba_offset] != UNDEF) {\r\nprintk(KERN_WARNING\r\n"alauda_read_map: "\r\n"LBA %d seen for PBA %d and %d\n",\r\nlba_real, lba_to_pba[lba_offset], blocknum);\r\ncontinue;\r\n}\r\npba_to_lba[i] = lba_real;\r\nlba_to_pba[lba_offset] = blocknum;\r\ncontinue;\r\n}\r\nMEDIA_INFO(us).lba_to_pba[zone] = lba_to_pba;\r\nMEDIA_INFO(us).pba_to_lba[zone] = pba_to_lba;\r\nresult = 0;\r\ngoto out;\r\nerror:\r\nkfree(lba_to_pba);\r\nkfree(pba_to_lba);\r\nout:\r\nreturn result;\r\n}\r\nstatic void alauda_ensure_map_for_zone(struct us_data *us, unsigned int zone)\r\n{\r\nif (MEDIA_INFO(us).lba_to_pba[zone] == NULL\r\n|| MEDIA_INFO(us).pba_to_lba[zone] == NULL)\r\nalauda_read_map(us, zone);\r\n}\r\nstatic int alauda_erase_block(struct us_data *us, u16 pba)\r\n{\r\nint rc;\r\nunsigned char command[] = {\r\nALAUDA_BULK_CMD, ALAUDA_BULK_ERASE_BLOCK, PBA_HI(pba),\r\nPBA_ZONE(pba), 0, PBA_LO(pba), 0x02, 0, MEDIA_PORT(us)\r\n};\r\nunsigned char buf[2];\r\nusb_stor_dbg(us, "Erasing PBA %d\n", pba);\r\nrc = usb_stor_bulk_transfer_buf(us, us->send_bulk_pipe,\r\ncommand, 9, NULL);\r\nif (rc != USB_STOR_XFER_GOOD)\r\nreturn rc;\r\nrc = usb_stor_bulk_transfer_buf(us, us->recv_bulk_pipe,\r\nbuf, 2, NULL);\r\nif (rc != USB_STOR_XFER_GOOD)\r\nreturn rc;\r\nusb_stor_dbg(us, "Erase result: %02X %02X\n", buf[0], buf[1]);\r\nreturn rc;\r\n}\r\nstatic int alauda_read_block_raw(struct us_data *us, u16 pba,\r\nunsigned int page, unsigned int pages, unsigned char *data)\r\n{\r\nint rc;\r\nunsigned char command[] = {\r\nALAUDA_BULK_CMD, ALAUDA_BULK_READ_BLOCK, PBA_HI(pba),\r\nPBA_ZONE(pba), 0, PBA_LO(pba) + page, pages, 0, MEDIA_PORT(us)\r\n};\r\nusb_stor_dbg(us, "pba %d page %d count %d\n", pba, page, pages);\r\nrc = usb_stor_bulk_transfer_buf(us, us->send_bulk_pipe,\r\ncommand, 9, NULL);\r\nif (rc != USB_STOR_XFER_GOOD)\r\nreturn rc;\r\nreturn usb_stor_bulk_transfer_buf(us, us->recv_bulk_pipe,\r\ndata, (MEDIA_INFO(us).pagesize + 64) * pages, NULL);\r\n}\r\nstatic int alauda_read_block(struct us_data *us, u16 pba,\r\nunsigned int page, unsigned int pages, unsigned char *data)\r\n{\r\nint i, rc;\r\nunsigned int pagesize = MEDIA_INFO(us).pagesize;\r\nrc = alauda_read_block_raw(us, pba, page, pages, data);\r\nif (rc != USB_STOR_XFER_GOOD)\r\nreturn rc;\r\nfor (i = 0; i < pages; i++) {\r\nint dest_offset = i * pagesize;\r\nint src_offset = i * (pagesize + 64);\r\nmemmove(data + dest_offset, data + src_offset, pagesize);\r\n}\r\nreturn rc;\r\n}\r\nstatic int alauda_write_block(struct us_data *us, u16 pba, unsigned char *data)\r\n{\r\nint rc;\r\nstruct alauda_info *info = (struct alauda_info *) us->extra;\r\nunsigned char command[] = {\r\nALAUDA_BULK_CMD, ALAUDA_BULK_WRITE_BLOCK, PBA_HI(pba),\r\nPBA_ZONE(pba), 0, PBA_LO(pba), 32, 0, MEDIA_PORT(us)\r\n};\r\nusb_stor_dbg(us, "pba %d\n", pba);\r\nrc = usb_stor_bulk_transfer_buf(us, us->send_bulk_pipe,\r\ncommand, 9, NULL);\r\nif (rc != USB_STOR_XFER_GOOD)\r\nreturn rc;\r\nrc = usb_stor_bulk_transfer_buf(us, info->wr_ep, data,\r\n(MEDIA_INFO(us).pagesize + 64) * MEDIA_INFO(us).blocksize,\r\nNULL);\r\nif (rc != USB_STOR_XFER_GOOD)\r\nreturn rc;\r\nreturn alauda_check_status2(us);\r\n}\r\nstatic int alauda_write_lba(struct us_data *us, u16 lba,\r\nunsigned int page, unsigned int pages,\r\nunsigned char *ptr, unsigned char *blockbuffer)\r\n{\r\nu16 pba, lbap, new_pba;\r\nunsigned char *bptr, *cptr, *xptr;\r\nunsigned char ecc[3];\r\nint i, result;\r\nunsigned int uzonesize = MEDIA_INFO(us).uzonesize;\r\nunsigned int zonesize = MEDIA_INFO(us).zonesize;\r\nunsigned int pagesize = MEDIA_INFO(us).pagesize;\r\nunsigned int blocksize = MEDIA_INFO(us).blocksize;\r\nunsigned int lba_offset = lba % uzonesize;\r\nunsigned int new_pba_offset;\r\nunsigned int zone = lba / uzonesize;\r\nalauda_ensure_map_for_zone(us, zone);\r\npba = MEDIA_INFO(us).lba_to_pba[zone][lba_offset];\r\nif (pba == 1) {\r\nprintk(KERN_WARNING\r\n"alauda_write_lba: avoid writing to pba 1\n");\r\nreturn USB_STOR_TRANSPORT_GOOD;\r\n}\r\nnew_pba = alauda_find_unused_pba(&MEDIA_INFO(us), zone);\r\nif (!new_pba) {\r\nprintk(KERN_WARNING\r\n"alauda_write_lba: Out of unused blocks\n");\r\nreturn USB_STOR_TRANSPORT_ERROR;\r\n}\r\nif (pba != UNDEF) {\r\nresult = alauda_read_block_raw(us, pba, 0,\r\nblocksize, blockbuffer);\r\nif (result != USB_STOR_XFER_GOOD)\r\nreturn result;\r\n} else {\r\nmemset(blockbuffer, 0, blocksize * (pagesize + 64));\r\n}\r\nlbap = (lba_offset << 1) | 0x1000;\r\nif (parity[MSB_of(lbap) ^ LSB_of(lbap)])\r\nlbap ^= 1;\r\nfor (i = 0; i < blocksize; i++) {\r\nbptr = blockbuffer + (i * (pagesize + 64));\r\ncptr = bptr + pagesize;\r\nnand_compute_ecc(bptr, ecc);\r\nif (!nand_compare_ecc(cptr+13, ecc)) {\r\nusb_stor_dbg(us, "Warning: bad ecc in page %d- of pba %d\n",\r\ni, pba);\r\nnand_store_ecc(cptr+13, ecc);\r\n}\r\nnand_compute_ecc(bptr + (pagesize / 2), ecc);\r\nif (!nand_compare_ecc(cptr+8, ecc)) {\r\nusb_stor_dbg(us, "Warning: bad ecc in page %d+ of pba %d\n",\r\ni, pba);\r\nnand_store_ecc(cptr+8, ecc);\r\n}\r\ncptr[6] = cptr[11] = MSB_of(lbap);\r\ncptr[7] = cptr[12] = LSB_of(lbap);\r\n}\r\nxptr = ptr;\r\nfor (i = page; i < page+pages; i++) {\r\nbptr = blockbuffer + (i * (pagesize + 64));\r\ncptr = bptr + pagesize;\r\nmemcpy(bptr, xptr, pagesize);\r\nxptr += pagesize;\r\nnand_compute_ecc(bptr, ecc);\r\nnand_store_ecc(cptr+13, ecc);\r\nnand_compute_ecc(bptr + (pagesize / 2), ecc);\r\nnand_store_ecc(cptr+8, ecc);\r\n}\r\nresult = alauda_write_block(us, new_pba, blockbuffer);\r\nif (result != USB_STOR_XFER_GOOD)\r\nreturn result;\r\nnew_pba_offset = new_pba - (zone * zonesize);\r\nMEDIA_INFO(us).pba_to_lba[zone][new_pba_offset] = lba;\r\nMEDIA_INFO(us).lba_to_pba[zone][lba_offset] = new_pba;\r\nusb_stor_dbg(us, "Remapped LBA %d to PBA %d\n", lba, new_pba);\r\nif (pba != UNDEF) {\r\nunsigned int pba_offset = pba - (zone * zonesize);\r\nresult = alauda_erase_block(us, pba);\r\nif (result != USB_STOR_XFER_GOOD)\r\nreturn result;\r\nMEDIA_INFO(us).pba_to_lba[zone][pba_offset] = UNDEF;\r\n}\r\nreturn USB_STOR_TRANSPORT_GOOD;\r\n}\r\nstatic int alauda_read_data(struct us_data *us, unsigned long address,\r\nunsigned int sectors)\r\n{\r\nunsigned char *buffer;\r\nu16 lba, max_lba;\r\nunsigned int page, len, offset;\r\nunsigned int blockshift = MEDIA_INFO(us).blockshift;\r\nunsigned int pageshift = MEDIA_INFO(us).pageshift;\r\nunsigned int blocksize = MEDIA_INFO(us).blocksize;\r\nunsigned int pagesize = MEDIA_INFO(us).pagesize;\r\nunsigned int uzonesize = MEDIA_INFO(us).uzonesize;\r\nstruct scatterlist *sg;\r\nint result;\r\nlen = min(sectors, blocksize) * (pagesize + 64);\r\nbuffer = kmalloc(len, GFP_NOIO);\r\nif (buffer == NULL) {\r\nprintk(KERN_WARNING "alauda_read_data: Out of memory\n");\r\nreturn USB_STOR_TRANSPORT_ERROR;\r\n}\r\nlba = address >> blockshift;\r\npage = (address & MEDIA_INFO(us).blockmask);\r\nmax_lba = MEDIA_INFO(us).capacity >> (blockshift + pageshift);\r\nresult = USB_STOR_TRANSPORT_GOOD;\r\noffset = 0;\r\nsg = NULL;\r\nwhile (sectors > 0) {\r\nunsigned int zone = lba / uzonesize;\r\nunsigned int lba_offset = lba - (zone * uzonesize);\r\nunsigned int pages;\r\nu16 pba;\r\nalauda_ensure_map_for_zone(us, zone);\r\nif (lba >= max_lba) {\r\nusb_stor_dbg(us, "Error: Requested lba %u exceeds maximum %u\n",\r\nlba, max_lba);\r\nresult = USB_STOR_TRANSPORT_ERROR;\r\nbreak;\r\n}\r\npages = min(sectors, blocksize - page);\r\nlen = pages << pageshift;\r\npba = MEDIA_INFO(us).lba_to_pba[zone][lba_offset];\r\nif (pba == UNDEF) {\r\nusb_stor_dbg(us, "Read %d zero pages (LBA %d) page %d\n",\r\npages, lba, page);\r\nmemset(buffer, 0, len);\r\n} else {\r\nusb_stor_dbg(us, "Read %d pages, from PBA %d (LBA %d) page %d\n",\r\npages, pba, lba, page);\r\nresult = alauda_read_block(us, pba, page, pages, buffer);\r\nif (result != USB_STOR_TRANSPORT_GOOD)\r\nbreak;\r\n}\r\nusb_stor_access_xfer_buf(buffer, len, us->srb,\r\n&sg, &offset, TO_XFER_BUF);\r\npage = 0;\r\nlba++;\r\nsectors -= pages;\r\n}\r\nkfree(buffer);\r\nreturn result;\r\n}\r\nstatic int alauda_write_data(struct us_data *us, unsigned long address,\r\nunsigned int sectors)\r\n{\r\nunsigned char *buffer, *blockbuffer;\r\nunsigned int page, len, offset;\r\nunsigned int blockshift = MEDIA_INFO(us).blockshift;\r\nunsigned int pageshift = MEDIA_INFO(us).pageshift;\r\nunsigned int blocksize = MEDIA_INFO(us).blocksize;\r\nunsigned int pagesize = MEDIA_INFO(us).pagesize;\r\nstruct scatterlist *sg;\r\nu16 lba, max_lba;\r\nint result;\r\nlen = min(sectors, blocksize) * pagesize;\r\nbuffer = kmalloc(len, GFP_NOIO);\r\nif (buffer == NULL) {\r\nprintk(KERN_WARNING "alauda_write_data: Out of memory\n");\r\nreturn USB_STOR_TRANSPORT_ERROR;\r\n}\r\nblockbuffer = kmalloc((pagesize + 64) * blocksize, GFP_NOIO);\r\nif (blockbuffer == NULL) {\r\nprintk(KERN_WARNING "alauda_write_data: Out of memory\n");\r\nkfree(buffer);\r\nreturn USB_STOR_TRANSPORT_ERROR;\r\n}\r\nlba = address >> blockshift;\r\npage = (address & MEDIA_INFO(us).blockmask);\r\nmax_lba = MEDIA_INFO(us).capacity >> (pageshift + blockshift);\r\nresult = USB_STOR_TRANSPORT_GOOD;\r\noffset = 0;\r\nsg = NULL;\r\nwhile (sectors > 0) {\r\nunsigned int pages = min(sectors, blocksize - page);\r\nlen = pages << pageshift;\r\nif (lba >= max_lba) {\r\nusb_stor_dbg(us, "Requested lba %u exceeds maximum %u\n",\r\nlba, max_lba);\r\nresult = USB_STOR_TRANSPORT_ERROR;\r\nbreak;\r\n}\r\nusb_stor_access_xfer_buf(buffer, len, us->srb,\r\n&sg, &offset, FROM_XFER_BUF);\r\nresult = alauda_write_lba(us, lba, page, pages, buffer,\r\nblockbuffer);\r\nif (result != USB_STOR_TRANSPORT_GOOD)\r\nbreak;\r\npage = 0;\r\nlba++;\r\nsectors -= pages;\r\n}\r\nkfree(buffer);\r\nkfree(blockbuffer);\r\nreturn result;\r\n}\r\nstatic void alauda_info_destructor(void *extra)\r\n{\r\nstruct alauda_info *info = (struct alauda_info *) extra;\r\nint port;\r\nif (!info)\r\nreturn;\r\nfor (port = 0; port < 2; port++) {\r\nstruct alauda_media_info *media_info = &info->port[port];\r\nalauda_free_maps(media_info);\r\nkfree(media_info->lba_to_pba);\r\nkfree(media_info->pba_to_lba);\r\n}\r\n}\r\nstatic int init_alauda(struct us_data *us)\r\n{\r\nstruct alauda_info *info;\r\nstruct usb_host_interface *altsetting = us->pusb_intf->cur_altsetting;\r\nnand_init_ecc();\r\nus->extra = kzalloc(sizeof(struct alauda_info), GFP_NOIO);\r\nif (!us->extra)\r\nreturn USB_STOR_TRANSPORT_ERROR;\r\ninfo = (struct alauda_info *) us->extra;\r\nus->extra_destructor = alauda_info_destructor;\r\ninfo->wr_ep = usb_sndbulkpipe(us->pusb_dev,\r\naltsetting->endpoint[0].desc.bEndpointAddress\r\n& USB_ENDPOINT_NUMBER_MASK);\r\nreturn USB_STOR_TRANSPORT_GOOD;\r\n}\r\nstatic int alauda_transport(struct scsi_cmnd *srb, struct us_data *us)\r\n{\r\nint rc;\r\nstruct alauda_info *info = (struct alauda_info *) us->extra;\r\nunsigned char *ptr = us->iobuf;\r\nstatic unsigned char inquiry_response[36] = {\r\n0x00, 0x80, 0x00, 0x01, 0x1F, 0x00, 0x00, 0x00\r\n};\r\nif (srb->cmnd[0] == INQUIRY) {\r\nusb_stor_dbg(us, "INQUIRY - Returning bogus response\n");\r\nmemcpy(ptr, inquiry_response, sizeof(inquiry_response));\r\nfill_inquiry_response(us, ptr, 36);\r\nreturn USB_STOR_TRANSPORT_GOOD;\r\n}\r\nif (srb->cmnd[0] == TEST_UNIT_READY) {\r\nusb_stor_dbg(us, "TEST_UNIT_READY\n");\r\nreturn alauda_check_media(us);\r\n}\r\nif (srb->cmnd[0] == READ_CAPACITY) {\r\nunsigned int num_zones;\r\nunsigned long capacity;\r\nrc = alauda_check_media(us);\r\nif (rc != USB_STOR_TRANSPORT_GOOD)\r\nreturn rc;\r\nnum_zones = MEDIA_INFO(us).capacity >> (MEDIA_INFO(us).zoneshift\r\n+ MEDIA_INFO(us).blockshift + MEDIA_INFO(us).pageshift);\r\ncapacity = num_zones * MEDIA_INFO(us).uzonesize\r\n* MEDIA_INFO(us).blocksize;\r\n((__be32 *) ptr)[0] = cpu_to_be32(capacity - 1);\r\n((__be32 *) ptr)[1] = cpu_to_be32(512);\r\nusb_stor_set_xfer_buf(ptr, 8, srb);\r\nreturn USB_STOR_TRANSPORT_GOOD;\r\n}\r\nif (srb->cmnd[0] == READ_10) {\r\nunsigned int page, pages;\r\nrc = alauda_check_media(us);\r\nif (rc != USB_STOR_TRANSPORT_GOOD)\r\nreturn rc;\r\npage = short_pack(srb->cmnd[3], srb->cmnd[2]);\r\npage <<= 16;\r\npage |= short_pack(srb->cmnd[5], srb->cmnd[4]);\r\npages = short_pack(srb->cmnd[8], srb->cmnd[7]);\r\nusb_stor_dbg(us, "READ_10: page %d pagect %d\n", page, pages);\r\nreturn alauda_read_data(us, page, pages);\r\n}\r\nif (srb->cmnd[0] == WRITE_10) {\r\nunsigned int page, pages;\r\nrc = alauda_check_media(us);\r\nif (rc != USB_STOR_TRANSPORT_GOOD)\r\nreturn rc;\r\npage = short_pack(srb->cmnd[3], srb->cmnd[2]);\r\npage <<= 16;\r\npage |= short_pack(srb->cmnd[5], srb->cmnd[4]);\r\npages = short_pack(srb->cmnd[8], srb->cmnd[7]);\r\nusb_stor_dbg(us, "WRITE_10: page %d pagect %d\n", page, pages);\r\nreturn alauda_write_data(us, page, pages);\r\n}\r\nif (srb->cmnd[0] == REQUEST_SENSE) {\r\nusb_stor_dbg(us, "REQUEST_SENSE\n");\r\nmemset(ptr, 0, 18);\r\nptr[0] = 0xF0;\r\nptr[2] = info->sense_key;\r\nptr[7] = 11;\r\nptr[12] = info->sense_asc;\r\nptr[13] = info->sense_ascq;\r\nusb_stor_set_xfer_buf(ptr, 18, srb);\r\nreturn USB_STOR_TRANSPORT_GOOD;\r\n}\r\nif (srb->cmnd[0] == ALLOW_MEDIUM_REMOVAL) {\r\nreturn USB_STOR_TRANSPORT_GOOD;\r\n}\r\nusb_stor_dbg(us, "Gah! Unknown command: %d (0x%x)\n",\r\nsrb->cmnd[0], srb->cmnd[0]);\r\ninfo->sense_key = 0x05;\r\ninfo->sense_asc = 0x20;\r\ninfo->sense_ascq = 0x00;\r\nreturn USB_STOR_TRANSPORT_FAILED;\r\n}\r\nstatic int alauda_probe(struct usb_interface *intf,\r\nconst struct usb_device_id *id)\r\n{\r\nstruct us_data *us;\r\nint result;\r\nresult = usb_stor_probe1(&us, intf, id,\r\n(id - alauda_usb_ids) + alauda_unusual_dev_list,\r\n&alauda_host_template);\r\nif (result)\r\nreturn result;\r\nus->transport_name = "Alauda Control/Bulk";\r\nus->transport = alauda_transport;\r\nus->transport_reset = usb_stor_Bulk_reset;\r\nus->max_lun = 1;\r\nresult = usb_stor_probe2(us);\r\nreturn result;\r\n}
