static int rk_spdif_runtime_suspend(struct device *dev)\r\n{\r\nstruct rk_spdif_dev *spdif = dev_get_drvdata(dev);\r\nclk_disable_unprepare(spdif->mclk);\r\nclk_disable_unprepare(spdif->hclk);\r\nreturn 0;\r\n}\r\nstatic int rk_spdif_runtime_resume(struct device *dev)\r\n{\r\nstruct rk_spdif_dev *spdif = dev_get_drvdata(dev);\r\nint ret;\r\nret = clk_prepare_enable(spdif->mclk);\r\nif (ret) {\r\ndev_err(spdif->dev, "mclk clock enable failed %d\n", ret);\r\nreturn ret;\r\n}\r\nret = clk_prepare_enable(spdif->hclk);\r\nif (ret) {\r\ndev_err(spdif->dev, "hclk clock enable failed %d\n", ret);\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic int rk_spdif_hw_params(struct snd_pcm_substream *substream,\r\nstruct snd_pcm_hw_params *params,\r\nstruct snd_soc_dai *dai)\r\n{\r\nstruct rk_spdif_dev *spdif = snd_soc_dai_get_drvdata(dai);\r\nunsigned int val = SPDIF_CFGR_HALFWORD_ENABLE;\r\nint srate, mclk;\r\nint ret;\r\nsrate = params_rate(params);\r\nswitch (srate) {\r\ncase 32000:\r\ncase 48000:\r\ncase 96000:\r\nmclk = 96000 * 128;\r\nbreak;\r\ncase 44100:\r\nmclk = 44100 * 256;\r\nbreak;\r\ncase 192000:\r\nmclk = 192000 * 128;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nswitch (params_format(params)) {\r\ncase SNDRV_PCM_FORMAT_S16_LE:\r\nval |= SPDIF_CFGR_VDW_16;\r\nbreak;\r\ncase SNDRV_PCM_FORMAT_S20_3LE:\r\nval |= SPDIF_CFGR_VDW_20;\r\nbreak;\r\ncase SNDRV_PCM_FORMAT_S24_LE:\r\nval |= SPDIF_CFGR_VDW_24;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nret = clk_set_rate(spdif->mclk, mclk);\r\nif (ret != 0) {\r\ndev_err(spdif->dev, "Failed to set module clock rate: %d\n",\r\nret);\r\nreturn ret;\r\n}\r\nval |= SPDIF_CFGR_CLK_DIV(mclk/(srate * 256));\r\nret = regmap_update_bits(spdif->regmap, SPDIF_CFGR,\r\nSPDIF_CFGR_CLK_DIV_MASK | SPDIF_CFGR_HALFWORD_ENABLE |\r\nSDPIF_CFGR_VDW_MASK,\r\nval);\r\nreturn ret;\r\n}\r\nstatic int rk_spdif_trigger(struct snd_pcm_substream *substream,\r\nint cmd, struct snd_soc_dai *dai)\r\n{\r\nstruct rk_spdif_dev *spdif = snd_soc_dai_get_drvdata(dai);\r\nint ret;\r\nswitch (cmd) {\r\ncase SNDRV_PCM_TRIGGER_START:\r\ncase SNDRV_PCM_TRIGGER_RESUME:\r\ncase SNDRV_PCM_TRIGGER_PAUSE_RELEASE:\r\nret = regmap_update_bits(spdif->regmap, SPDIF_DMACR,\r\nSPDIF_DMACR_TDE_ENABLE |\r\nSPDIF_DMACR_TDL_MASK,\r\nSPDIF_DMACR_TDE_ENABLE |\r\nSPDIF_DMACR_TDL(16));\r\nif (ret != 0)\r\nreturn ret;\r\nret = regmap_update_bits(spdif->regmap, SPDIF_XFER,\r\nSPDIF_XFER_TXS_START,\r\nSPDIF_XFER_TXS_START);\r\nbreak;\r\ncase SNDRV_PCM_TRIGGER_SUSPEND:\r\ncase SNDRV_PCM_TRIGGER_STOP:\r\ncase SNDRV_PCM_TRIGGER_PAUSE_PUSH:\r\nret = regmap_update_bits(spdif->regmap, SPDIF_DMACR,\r\nSPDIF_DMACR_TDE_ENABLE,\r\nSPDIF_DMACR_TDE_DISABLE);\r\nif (ret != 0)\r\nreturn ret;\r\nret = regmap_update_bits(spdif->regmap, SPDIF_XFER,\r\nSPDIF_XFER_TXS_START,\r\nSPDIF_XFER_TXS_STOP);\r\nbreak;\r\ndefault:\r\nret = -EINVAL;\r\nbreak;\r\n}\r\nreturn ret;\r\n}\r\nstatic int rk_spdif_dai_probe(struct snd_soc_dai *dai)\r\n{\r\nstruct rk_spdif_dev *spdif = snd_soc_dai_get_drvdata(dai);\r\ndai->playback_dma_data = &spdif->playback_dma_data;\r\nreturn 0;\r\n}\r\nstatic bool rk_spdif_wr_reg(struct device *dev, unsigned int reg)\r\n{\r\nswitch (reg) {\r\ncase SPDIF_CFGR:\r\ncase SPDIF_DMACR:\r\ncase SPDIF_INTCR:\r\ncase SPDIF_XFER:\r\ncase SPDIF_SMPDR:\r\nreturn true;\r\ndefault:\r\nreturn false;\r\n}\r\n}\r\nstatic bool rk_spdif_rd_reg(struct device *dev, unsigned int reg)\r\n{\r\nswitch (reg) {\r\ncase SPDIF_CFGR:\r\ncase SPDIF_SDBLR:\r\ncase SPDIF_INTCR:\r\ncase SPDIF_INTSR:\r\ncase SPDIF_XFER:\r\nreturn true;\r\ndefault:\r\nreturn false;\r\n}\r\n}\r\nstatic bool rk_spdif_volatile_reg(struct device *dev, unsigned int reg)\r\n{\r\nswitch (reg) {\r\ncase SPDIF_INTSR:\r\ncase SPDIF_SDBLR:\r\nreturn true;\r\ndefault:\r\nreturn false;\r\n}\r\n}\r\nstatic int rk_spdif_probe(struct platform_device *pdev)\r\n{\r\nstruct device_node *np = pdev->dev.of_node;\r\nstruct rk_spdif_dev *spdif;\r\nconst struct of_device_id *match;\r\nstruct resource *res;\r\nvoid __iomem *regs;\r\nint ret;\r\nmatch = of_match_node(rk_spdif_match, np);\r\nif (match->data == (void *)RK_SPDIF_RK3288) {\r\nstruct regmap *grf;\r\ngrf = syscon_regmap_lookup_by_phandle(np, "rockchip,grf");\r\nif (IS_ERR(grf)) {\r\ndev_err(&pdev->dev,\r\n"rockchip_spdif missing 'rockchip,grf' \n");\r\nreturn PTR_ERR(grf);\r\n}\r\nregmap_write(grf, RK3288_GRF_SOC_CON2, BIT(1) << 16);\r\n}\r\nspdif = devm_kzalloc(&pdev->dev, sizeof(*spdif), GFP_KERNEL);\r\nif (!spdif)\r\nreturn -ENOMEM;\r\nspdif->hclk = devm_clk_get(&pdev->dev, "hclk");\r\nif (IS_ERR(spdif->hclk)) {\r\ndev_err(&pdev->dev, "Can't retrieve rk_spdif bus clock\n");\r\nreturn PTR_ERR(spdif->hclk);\r\n}\r\nret = clk_prepare_enable(spdif->hclk);\r\nif (ret) {\r\ndev_err(spdif->dev, "hclock enable failed %d\n", ret);\r\nreturn ret;\r\n}\r\nspdif->mclk = devm_clk_get(&pdev->dev, "mclk");\r\nif (IS_ERR(spdif->mclk)) {\r\ndev_err(&pdev->dev, "Can't retrieve rk_spdif master clock\n");\r\nreturn PTR_ERR(spdif->mclk);\r\n}\r\nret = clk_prepare_enable(spdif->mclk);\r\nif (ret) {\r\ndev_err(spdif->dev, "clock enable failed %d\n", ret);\r\nreturn ret;\r\n}\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nregs = devm_ioremap_resource(&pdev->dev, res);\r\nif (IS_ERR(regs))\r\nreturn PTR_ERR(regs);\r\nspdif->regmap = devm_regmap_init_mmio_clk(&pdev->dev, "hclk", regs,\r\n&rk_spdif_regmap_config);\r\nif (IS_ERR(spdif->regmap)) {\r\ndev_err(&pdev->dev,\r\n"Failed to initialise managed register map\n");\r\nreturn PTR_ERR(spdif->regmap);\r\n}\r\nspdif->playback_dma_data.addr = res->start + SPDIF_SMPDR;\r\nspdif->playback_dma_data.addr_width = DMA_SLAVE_BUSWIDTH_4_BYTES;\r\nspdif->playback_dma_data.maxburst = 4;\r\nspdif->dev = &pdev->dev;\r\ndev_set_drvdata(&pdev->dev, spdif);\r\npm_runtime_set_active(&pdev->dev);\r\npm_runtime_enable(&pdev->dev);\r\npm_request_idle(&pdev->dev);\r\nret = devm_snd_soc_register_component(&pdev->dev,\r\n&rk_spdif_component,\r\n&rk_spdif_dai, 1);\r\nif (ret) {\r\ndev_err(&pdev->dev, "Could not register DAI\n");\r\ngoto err_pm_runtime;\r\n}\r\nret = devm_snd_dmaengine_pcm_register(&pdev->dev, NULL, 0);\r\nif (ret) {\r\ndev_err(&pdev->dev, "Could not register PCM\n");\r\ngoto err_pm_runtime;\r\n}\r\nreturn 0;\r\nerr_pm_runtime:\r\npm_runtime_disable(&pdev->dev);\r\nreturn ret;\r\n}\r\nstatic int rk_spdif_remove(struct platform_device *pdev)\r\n{\r\nstruct rk_spdif_dev *spdif = dev_get_drvdata(&pdev->dev);\r\npm_runtime_disable(&pdev->dev);\r\nif (!pm_runtime_status_suspended(&pdev->dev))\r\nrk_spdif_runtime_suspend(&pdev->dev);\r\nclk_disable_unprepare(spdif->mclk);\r\nclk_disable_unprepare(spdif->hclk);\r\nreturn 0;\r\n}
