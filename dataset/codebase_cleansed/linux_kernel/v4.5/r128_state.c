static void r128_emit_clip_rects(drm_r128_private_t *dev_priv,\r\nstruct drm_clip_rect *boxes, int count)\r\n{\r\nu32 aux_sc_cntl = 0x00000000;\r\nRING_LOCALS;\r\nDRM_DEBUG("\n");\r\nBEGIN_RING((count < 3 ? count : 3) * 5 + 2);\r\nif (count >= 1) {\r\nOUT_RING(CCE_PACKET0(R128_AUX1_SC_LEFT, 3));\r\nOUT_RING(boxes[0].x1);\r\nOUT_RING(boxes[0].x2 - 1);\r\nOUT_RING(boxes[0].y1);\r\nOUT_RING(boxes[0].y2 - 1);\r\naux_sc_cntl |= (R128_AUX1_SC_EN | R128_AUX1_SC_MODE_OR);\r\n}\r\nif (count >= 2) {\r\nOUT_RING(CCE_PACKET0(R128_AUX2_SC_LEFT, 3));\r\nOUT_RING(boxes[1].x1);\r\nOUT_RING(boxes[1].x2 - 1);\r\nOUT_RING(boxes[1].y1);\r\nOUT_RING(boxes[1].y2 - 1);\r\naux_sc_cntl |= (R128_AUX2_SC_EN | R128_AUX2_SC_MODE_OR);\r\n}\r\nif (count >= 3) {\r\nOUT_RING(CCE_PACKET0(R128_AUX3_SC_LEFT, 3));\r\nOUT_RING(boxes[2].x1);\r\nOUT_RING(boxes[2].x2 - 1);\r\nOUT_RING(boxes[2].y1);\r\nOUT_RING(boxes[2].y2 - 1);\r\naux_sc_cntl |= (R128_AUX3_SC_EN | R128_AUX3_SC_MODE_OR);\r\n}\r\nOUT_RING(CCE_PACKET0(R128_AUX_SC_CNTL, 0));\r\nOUT_RING(aux_sc_cntl);\r\nADVANCE_RING();\r\n}\r\nstatic __inline__ void r128_emit_core(drm_r128_private_t *dev_priv)\r\n{\r\ndrm_r128_sarea_t *sarea_priv = dev_priv->sarea_priv;\r\ndrm_r128_context_regs_t *ctx = &sarea_priv->context_state;\r\nRING_LOCALS;\r\nDRM_DEBUG("\n");\r\nBEGIN_RING(2);\r\nOUT_RING(CCE_PACKET0(R128_SCALE_3D_CNTL, 0));\r\nOUT_RING(ctx->scale_3d_cntl);\r\nADVANCE_RING();\r\n}\r\nstatic __inline__ void r128_emit_context(drm_r128_private_t *dev_priv)\r\n{\r\ndrm_r128_sarea_t *sarea_priv = dev_priv->sarea_priv;\r\ndrm_r128_context_regs_t *ctx = &sarea_priv->context_state;\r\nRING_LOCALS;\r\nDRM_DEBUG("\n");\r\nBEGIN_RING(13);\r\nOUT_RING(CCE_PACKET0(R128_DST_PITCH_OFFSET_C, 11));\r\nOUT_RING(ctx->dst_pitch_offset_c);\r\nOUT_RING(ctx->dp_gui_master_cntl_c);\r\nOUT_RING(ctx->sc_top_left_c);\r\nOUT_RING(ctx->sc_bottom_right_c);\r\nOUT_RING(ctx->z_offset_c);\r\nOUT_RING(ctx->z_pitch_c);\r\nOUT_RING(ctx->z_sten_cntl_c);\r\nOUT_RING(ctx->tex_cntl_c);\r\nOUT_RING(ctx->misc_3d_state_cntl_reg);\r\nOUT_RING(ctx->texture_clr_cmp_clr_c);\r\nOUT_RING(ctx->texture_clr_cmp_msk_c);\r\nOUT_RING(ctx->fog_color_c);\r\nADVANCE_RING();\r\n}\r\nstatic __inline__ void r128_emit_setup(drm_r128_private_t *dev_priv)\r\n{\r\ndrm_r128_sarea_t *sarea_priv = dev_priv->sarea_priv;\r\ndrm_r128_context_regs_t *ctx = &sarea_priv->context_state;\r\nRING_LOCALS;\r\nDRM_DEBUG("\n");\r\nBEGIN_RING(3);\r\nOUT_RING(CCE_PACKET1(R128_SETUP_CNTL, R128_PM4_VC_FPU_SETUP));\r\nOUT_RING(ctx->setup_cntl);\r\nOUT_RING(ctx->pm4_vc_fpu_setup);\r\nADVANCE_RING();\r\n}\r\nstatic __inline__ void r128_emit_masks(drm_r128_private_t *dev_priv)\r\n{\r\ndrm_r128_sarea_t *sarea_priv = dev_priv->sarea_priv;\r\ndrm_r128_context_regs_t *ctx = &sarea_priv->context_state;\r\nRING_LOCALS;\r\nDRM_DEBUG("\n");\r\nBEGIN_RING(5);\r\nOUT_RING(CCE_PACKET0(R128_DP_WRITE_MASK, 0));\r\nOUT_RING(ctx->dp_write_mask);\r\nOUT_RING(CCE_PACKET0(R128_STEN_REF_MASK_C, 1));\r\nOUT_RING(ctx->sten_ref_mask_c);\r\nOUT_RING(ctx->plane_3d_mask_c);\r\nADVANCE_RING();\r\n}\r\nstatic __inline__ void r128_emit_window(drm_r128_private_t *dev_priv)\r\n{\r\ndrm_r128_sarea_t *sarea_priv = dev_priv->sarea_priv;\r\ndrm_r128_context_regs_t *ctx = &sarea_priv->context_state;\r\nRING_LOCALS;\r\nDRM_DEBUG("\n");\r\nBEGIN_RING(2);\r\nOUT_RING(CCE_PACKET0(R128_WINDOW_XY_OFFSET, 0));\r\nOUT_RING(ctx->window_xy_offset);\r\nADVANCE_RING();\r\n}\r\nstatic __inline__ void r128_emit_tex0(drm_r128_private_t *dev_priv)\r\n{\r\ndrm_r128_sarea_t *sarea_priv = dev_priv->sarea_priv;\r\ndrm_r128_context_regs_t *ctx = &sarea_priv->context_state;\r\ndrm_r128_texture_regs_t *tex = &sarea_priv->tex_state[0];\r\nint i;\r\nRING_LOCALS;\r\nDRM_DEBUG("\n");\r\nBEGIN_RING(7 + R128_MAX_TEXTURE_LEVELS);\r\nOUT_RING(CCE_PACKET0(R128_PRIM_TEX_CNTL_C,\r\n2 + R128_MAX_TEXTURE_LEVELS));\r\nOUT_RING(tex->tex_cntl);\r\nOUT_RING(tex->tex_combine_cntl);\r\nOUT_RING(ctx->tex_size_pitch_c);\r\nfor (i = 0; i < R128_MAX_TEXTURE_LEVELS; i++)\r\nOUT_RING(tex->tex_offset[i]);\r\nOUT_RING(CCE_PACKET0(R128_CONSTANT_COLOR_C, 1));\r\nOUT_RING(ctx->constant_color_c);\r\nOUT_RING(tex->tex_border_color);\r\nADVANCE_RING();\r\n}\r\nstatic __inline__ void r128_emit_tex1(drm_r128_private_t *dev_priv)\r\n{\r\ndrm_r128_sarea_t *sarea_priv = dev_priv->sarea_priv;\r\ndrm_r128_texture_regs_t *tex = &sarea_priv->tex_state[1];\r\nint i;\r\nRING_LOCALS;\r\nDRM_DEBUG("\n");\r\nBEGIN_RING(5 + R128_MAX_TEXTURE_LEVELS);\r\nOUT_RING(CCE_PACKET0(R128_SEC_TEX_CNTL_C, 1 + R128_MAX_TEXTURE_LEVELS));\r\nOUT_RING(tex->tex_cntl);\r\nOUT_RING(tex->tex_combine_cntl);\r\nfor (i = 0; i < R128_MAX_TEXTURE_LEVELS; i++)\r\nOUT_RING(tex->tex_offset[i]);\r\nOUT_RING(CCE_PACKET0(R128_SEC_TEXTURE_BORDER_COLOR_C, 0));\r\nOUT_RING(tex->tex_border_color);\r\nADVANCE_RING();\r\n}\r\nstatic void r128_emit_state(drm_r128_private_t *dev_priv)\r\n{\r\ndrm_r128_sarea_t *sarea_priv = dev_priv->sarea_priv;\r\nunsigned int dirty = sarea_priv->dirty;\r\nDRM_DEBUG("dirty=0x%08x\n", dirty);\r\nif (dirty & R128_UPLOAD_CORE) {\r\nr128_emit_core(dev_priv);\r\nsarea_priv->dirty &= ~R128_UPLOAD_CORE;\r\n}\r\nif (dirty & R128_UPLOAD_CONTEXT) {\r\nr128_emit_context(dev_priv);\r\nsarea_priv->dirty &= ~R128_UPLOAD_CONTEXT;\r\n}\r\nif (dirty & R128_UPLOAD_SETUP) {\r\nr128_emit_setup(dev_priv);\r\nsarea_priv->dirty &= ~R128_UPLOAD_SETUP;\r\n}\r\nif (dirty & R128_UPLOAD_MASKS) {\r\nr128_emit_masks(dev_priv);\r\nsarea_priv->dirty &= ~R128_UPLOAD_MASKS;\r\n}\r\nif (dirty & R128_UPLOAD_WINDOW) {\r\nr128_emit_window(dev_priv);\r\nsarea_priv->dirty &= ~R128_UPLOAD_WINDOW;\r\n}\r\nif (dirty & R128_UPLOAD_TEX0) {\r\nr128_emit_tex0(dev_priv);\r\nsarea_priv->dirty &= ~R128_UPLOAD_TEX0;\r\n}\r\nif (dirty & R128_UPLOAD_TEX1) {\r\nr128_emit_tex1(dev_priv);\r\nsarea_priv->dirty &= ~R128_UPLOAD_TEX1;\r\n}\r\nsarea_priv->context_state.tex_cntl_c &= ~R128_TEX_CACHE_FLUSH;\r\nsarea_priv->dirty &= ~R128_REQUIRE_QUIESCENCE;\r\n}\r\nstatic void r128_clear_box(drm_r128_private_t *dev_priv,\r\nint x, int y, int w, int h, int r, int g, int b)\r\n{\r\nu32 pitch, offset;\r\nu32 fb_bpp, color;\r\nRING_LOCALS;\r\nswitch (dev_priv->fb_bpp) {\r\ncase 16:\r\nfb_bpp = R128_GMC_DST_16BPP;\r\ncolor = (((r & 0xf8) << 8) |\r\n((g & 0xfc) << 3) | ((b & 0xf8) >> 3));\r\nbreak;\r\ncase 24:\r\nfb_bpp = R128_GMC_DST_24BPP;\r\ncolor = ((r << 16) | (g << 8) | b);\r\nbreak;\r\ncase 32:\r\nfb_bpp = R128_GMC_DST_32BPP;\r\ncolor = (((0xff) << 24) | (r << 16) | (g << 8) | b);\r\nbreak;\r\ndefault:\r\nreturn;\r\n}\r\noffset = dev_priv->back_offset;\r\npitch = dev_priv->back_pitch >> 3;\r\nBEGIN_RING(6);\r\nOUT_RING(CCE_PACKET3(R128_CNTL_PAINT_MULTI, 4));\r\nOUT_RING(R128_GMC_DST_PITCH_OFFSET_CNTL |\r\nR128_GMC_BRUSH_SOLID_COLOR |\r\nfb_bpp |\r\nR128_GMC_SRC_DATATYPE_COLOR |\r\nR128_ROP3_P |\r\nR128_GMC_CLR_CMP_CNTL_DIS | R128_GMC_AUX_CLIP_DIS);\r\nOUT_RING((pitch << 21) | (offset >> 5));\r\nOUT_RING(color);\r\nOUT_RING((x << 16) | y);\r\nOUT_RING((w << 16) | h);\r\nADVANCE_RING();\r\n}\r\nstatic void r128_cce_performance_boxes(drm_r128_private_t *dev_priv)\r\n{\r\nif (atomic_read(&dev_priv->idle_count) == 0)\r\nr128_clear_box(dev_priv, 64, 4, 8, 8, 0, 255, 0);\r\nelse\r\natomic_set(&dev_priv->idle_count, 0);\r\n}\r\nstatic void r128_print_dirty(const char *msg, unsigned int flags)\r\n{\r\nDRM_INFO("%s: (0x%x) %s%s%s%s%s%s%s%s%s\n",\r\nmsg,\r\nflags,\r\n(flags & R128_UPLOAD_CORE) ? "core, " : "",\r\n(flags & R128_UPLOAD_CONTEXT) ? "context, " : "",\r\n(flags & R128_UPLOAD_SETUP) ? "setup, " : "",\r\n(flags & R128_UPLOAD_TEX0) ? "tex0, " : "",\r\n(flags & R128_UPLOAD_TEX1) ? "tex1, " : "",\r\n(flags & R128_UPLOAD_MASKS) ? "masks, " : "",\r\n(flags & R128_UPLOAD_WINDOW) ? "window, " : "",\r\n(flags & R128_UPLOAD_CLIPRECTS) ? "cliprects, " : "",\r\n(flags & R128_REQUIRE_QUIESCENCE) ? "quiescence, " : "");\r\n}\r\nstatic void r128_cce_dispatch_clear(struct drm_device *dev,\r\ndrm_r128_clear_t *clear)\r\n{\r\ndrm_r128_private_t *dev_priv = dev->dev_private;\r\ndrm_r128_sarea_t *sarea_priv = dev_priv->sarea_priv;\r\nint nbox = sarea_priv->nbox;\r\nstruct drm_clip_rect *pbox = sarea_priv->boxes;\r\nunsigned int flags = clear->flags;\r\nint i;\r\nRING_LOCALS;\r\nDRM_DEBUG("\n");\r\nif (dev_priv->page_flipping && dev_priv->current_page == 1) {\r\nunsigned int tmp = flags;\r\nflags &= ~(R128_FRONT | R128_BACK);\r\nif (tmp & R128_FRONT)\r\nflags |= R128_BACK;\r\nif (tmp & R128_BACK)\r\nflags |= R128_FRONT;\r\n}\r\nfor (i = 0; i < nbox; i++) {\r\nint x = pbox[i].x1;\r\nint y = pbox[i].y1;\r\nint w = pbox[i].x2 - x;\r\nint h = pbox[i].y2 - y;\r\nDRM_DEBUG("dispatch clear %d,%d-%d,%d flags 0x%x\n",\r\npbox[i].x1, pbox[i].y1, pbox[i].x2,\r\npbox[i].y2, flags);\r\nif (flags & (R128_FRONT | R128_BACK)) {\r\nBEGIN_RING(2);\r\nOUT_RING(CCE_PACKET0(R128_DP_WRITE_MASK, 0));\r\nOUT_RING(clear->color_mask);\r\nADVANCE_RING();\r\n}\r\nif (flags & R128_FRONT) {\r\nBEGIN_RING(6);\r\nOUT_RING(CCE_PACKET3(R128_CNTL_PAINT_MULTI, 4));\r\nOUT_RING(R128_GMC_DST_PITCH_OFFSET_CNTL |\r\nR128_GMC_BRUSH_SOLID_COLOR |\r\n(dev_priv->color_fmt << 8) |\r\nR128_GMC_SRC_DATATYPE_COLOR |\r\nR128_ROP3_P |\r\nR128_GMC_CLR_CMP_CNTL_DIS |\r\nR128_GMC_AUX_CLIP_DIS);\r\nOUT_RING(dev_priv->front_pitch_offset_c);\r\nOUT_RING(clear->clear_color);\r\nOUT_RING((x << 16) | y);\r\nOUT_RING((w << 16) | h);\r\nADVANCE_RING();\r\n}\r\nif (flags & R128_BACK) {\r\nBEGIN_RING(6);\r\nOUT_RING(CCE_PACKET3(R128_CNTL_PAINT_MULTI, 4));\r\nOUT_RING(R128_GMC_DST_PITCH_OFFSET_CNTL |\r\nR128_GMC_BRUSH_SOLID_COLOR |\r\n(dev_priv->color_fmt << 8) |\r\nR128_GMC_SRC_DATATYPE_COLOR |\r\nR128_ROP3_P |\r\nR128_GMC_CLR_CMP_CNTL_DIS |\r\nR128_GMC_AUX_CLIP_DIS);\r\nOUT_RING(dev_priv->back_pitch_offset_c);\r\nOUT_RING(clear->clear_color);\r\nOUT_RING((x << 16) | y);\r\nOUT_RING((w << 16) | h);\r\nADVANCE_RING();\r\n}\r\nif (flags & R128_DEPTH) {\r\nBEGIN_RING(6);\r\nOUT_RING(CCE_PACKET3(R128_CNTL_PAINT_MULTI, 4));\r\nOUT_RING(R128_GMC_DST_PITCH_OFFSET_CNTL |\r\nR128_GMC_BRUSH_SOLID_COLOR |\r\n(dev_priv->depth_fmt << 8) |\r\nR128_GMC_SRC_DATATYPE_COLOR |\r\nR128_ROP3_P |\r\nR128_GMC_CLR_CMP_CNTL_DIS |\r\nR128_GMC_AUX_CLIP_DIS | R128_GMC_WR_MSK_DIS);\r\nOUT_RING(dev_priv->depth_pitch_offset_c);\r\nOUT_RING(clear->clear_depth);\r\nOUT_RING((x << 16) | y);\r\nOUT_RING((w << 16) | h);\r\nADVANCE_RING();\r\n}\r\n}\r\n}\r\nstatic void r128_cce_dispatch_swap(struct drm_device *dev)\r\n{\r\ndrm_r128_private_t *dev_priv = dev->dev_private;\r\ndrm_r128_sarea_t *sarea_priv = dev_priv->sarea_priv;\r\nint nbox = sarea_priv->nbox;\r\nstruct drm_clip_rect *pbox = sarea_priv->boxes;\r\nint i;\r\nRING_LOCALS;\r\nDRM_DEBUG("\n");\r\n#if R128_PERFORMANCE_BOXES\r\nr128_cce_performance_boxes(dev_priv);\r\n#endif\r\nfor (i = 0; i < nbox; i++) {\r\nint x = pbox[i].x1;\r\nint y = pbox[i].y1;\r\nint w = pbox[i].x2 - x;\r\nint h = pbox[i].y2 - y;\r\nBEGIN_RING(7);\r\nOUT_RING(CCE_PACKET3(R128_CNTL_BITBLT_MULTI, 5));\r\nOUT_RING(R128_GMC_SRC_PITCH_OFFSET_CNTL |\r\nR128_GMC_DST_PITCH_OFFSET_CNTL |\r\nR128_GMC_BRUSH_NONE |\r\n(dev_priv->color_fmt << 8) |\r\nR128_GMC_SRC_DATATYPE_COLOR |\r\nR128_ROP3_S |\r\nR128_DP_SRC_SOURCE_MEMORY |\r\nR128_GMC_CLR_CMP_CNTL_DIS |\r\nR128_GMC_AUX_CLIP_DIS | R128_GMC_WR_MSK_DIS);\r\nif (dev_priv->current_page == 0) {\r\nOUT_RING(dev_priv->back_pitch_offset_c);\r\nOUT_RING(dev_priv->front_pitch_offset_c);\r\n} else {\r\nOUT_RING(dev_priv->front_pitch_offset_c);\r\nOUT_RING(dev_priv->back_pitch_offset_c);\r\n}\r\nOUT_RING((x << 16) | y);\r\nOUT_RING((x << 16) | y);\r\nOUT_RING((w << 16) | h);\r\nADVANCE_RING();\r\n}\r\ndev_priv->sarea_priv->last_frame++;\r\nBEGIN_RING(2);\r\nOUT_RING(CCE_PACKET0(R128_LAST_FRAME_REG, 0));\r\nOUT_RING(dev_priv->sarea_priv->last_frame);\r\nADVANCE_RING();\r\n}\r\nstatic void r128_cce_dispatch_flip(struct drm_device *dev)\r\n{\r\ndrm_r128_private_t *dev_priv = dev->dev_private;\r\nRING_LOCALS;\r\nDRM_DEBUG("page=%d pfCurrentPage=%d\n",\r\ndev_priv->current_page, dev_priv->sarea_priv->pfCurrentPage);\r\n#if R128_PERFORMANCE_BOXES\r\nr128_cce_performance_boxes(dev_priv);\r\n#endif\r\nBEGIN_RING(4);\r\nR128_WAIT_UNTIL_PAGE_FLIPPED();\r\nOUT_RING(CCE_PACKET0(R128_CRTC_OFFSET, 0));\r\nif (dev_priv->current_page == 0)\r\nOUT_RING(dev_priv->back_offset);\r\nelse\r\nOUT_RING(dev_priv->front_offset);\r\nADVANCE_RING();\r\ndev_priv->sarea_priv->last_frame++;\r\ndev_priv->sarea_priv->pfCurrentPage = dev_priv->current_page =\r\n1 - dev_priv->current_page;\r\nBEGIN_RING(2);\r\nOUT_RING(CCE_PACKET0(R128_LAST_FRAME_REG, 0));\r\nOUT_RING(dev_priv->sarea_priv->last_frame);\r\nADVANCE_RING();\r\n}\r\nstatic void r128_cce_dispatch_vertex(struct drm_device *dev, struct drm_buf *buf)\r\n{\r\ndrm_r128_private_t *dev_priv = dev->dev_private;\r\ndrm_r128_buf_priv_t *buf_priv = buf->dev_private;\r\ndrm_r128_sarea_t *sarea_priv = dev_priv->sarea_priv;\r\nint format = sarea_priv->vc_format;\r\nint offset = buf->bus_address;\r\nint size = buf->used;\r\nint prim = buf_priv->prim;\r\nint i = 0;\r\nRING_LOCALS;\r\nDRM_DEBUG("buf=%d nbox=%d\n", buf->idx, sarea_priv->nbox);\r\nif (0)\r\nr128_print_dirty("dispatch_vertex", sarea_priv->dirty);\r\nif (buf->used) {\r\nbuf_priv->dispatched = 1;\r\nif (sarea_priv->dirty & ~R128_UPLOAD_CLIPRECTS)\r\nr128_emit_state(dev_priv);\r\ndo {\r\nif (i < sarea_priv->nbox) {\r\nr128_emit_clip_rects(dev_priv,\r\n&sarea_priv->boxes[i],\r\nsarea_priv->nbox - i);\r\n}\r\nBEGIN_RING(5);\r\nOUT_RING(CCE_PACKET3(R128_3D_RNDR_GEN_INDX_PRIM, 3));\r\nOUT_RING(offset);\r\nOUT_RING(size);\r\nOUT_RING(format);\r\nOUT_RING(prim | R128_CCE_VC_CNTL_PRIM_WALK_LIST |\r\n(size << R128_CCE_VC_CNTL_NUM_SHIFT));\r\nADVANCE_RING();\r\ni += 3;\r\n} while (i < sarea_priv->nbox);\r\n}\r\nif (buf_priv->discard) {\r\nbuf_priv->age = dev_priv->sarea_priv->last_dispatch;\r\nBEGIN_RING(2);\r\nOUT_RING(CCE_PACKET0(R128_LAST_DISPATCH_REG, 0));\r\nOUT_RING(buf_priv->age);\r\nADVANCE_RING();\r\nbuf->pending = 1;\r\nbuf->used = 0;\r\nbuf_priv->dispatched = 0;\r\n}\r\ndev_priv->sarea_priv->last_dispatch++;\r\nsarea_priv->dirty &= ~R128_UPLOAD_CLIPRECTS;\r\nsarea_priv->nbox = 0;\r\n}\r\nstatic void r128_cce_dispatch_indirect(struct drm_device *dev,\r\nstruct drm_buf *buf, int start, int end)\r\n{\r\ndrm_r128_private_t *dev_priv = dev->dev_private;\r\ndrm_r128_buf_priv_t *buf_priv = buf->dev_private;\r\nRING_LOCALS;\r\nDRM_DEBUG("indirect: buf=%d s=0x%x e=0x%x\n", buf->idx, start, end);\r\nif (start != end) {\r\nint offset = buf->bus_address + start;\r\nint dwords = (end - start + 3) / sizeof(u32);\r\nif (dwords & 1) {\r\nu32 *data = (u32 *)\r\n((char *)dev->agp_buffer_map->handle\r\n+ buf->offset + start);\r\ndata[dwords++] = cpu_to_le32(R128_CCE_PACKET2);\r\n}\r\nbuf_priv->dispatched = 1;\r\nBEGIN_RING(3);\r\nOUT_RING(CCE_PACKET0(R128_PM4_IW_INDOFF, 1));\r\nOUT_RING(offset);\r\nOUT_RING(dwords);\r\nADVANCE_RING();\r\n}\r\nif (buf_priv->discard) {\r\nbuf_priv->age = dev_priv->sarea_priv->last_dispatch;\r\nBEGIN_RING(2);\r\nOUT_RING(CCE_PACKET0(R128_LAST_DISPATCH_REG, 0));\r\nOUT_RING(buf_priv->age);\r\nADVANCE_RING();\r\nbuf->pending = 1;\r\nbuf->used = 0;\r\nbuf_priv->dispatched = 0;\r\n}\r\ndev_priv->sarea_priv->last_dispatch++;\r\n}\r\nstatic void r128_cce_dispatch_indices(struct drm_device *dev,\r\nstruct drm_buf *buf,\r\nint start, int end, int count)\r\n{\r\ndrm_r128_private_t *dev_priv = dev->dev_private;\r\ndrm_r128_buf_priv_t *buf_priv = buf->dev_private;\r\ndrm_r128_sarea_t *sarea_priv = dev_priv->sarea_priv;\r\nint format = sarea_priv->vc_format;\r\nint offset = dev->agp_buffer_map->offset - dev_priv->cce_buffers_offset;\r\nint prim = buf_priv->prim;\r\nu32 *data;\r\nint dwords;\r\nint i = 0;\r\nRING_LOCALS;\r\nDRM_DEBUG("indices: s=%d e=%d c=%d\n", start, end, count);\r\nif (0)\r\nr128_print_dirty("dispatch_indices", sarea_priv->dirty);\r\nif (start != end) {\r\nbuf_priv->dispatched = 1;\r\nif (sarea_priv->dirty & ~R128_UPLOAD_CLIPRECTS)\r\nr128_emit_state(dev_priv);\r\ndwords = (end - start + 3) / sizeof(u32);\r\ndata = (u32 *) ((char *)dev->agp_buffer_map->handle\r\n+ buf->offset + start);\r\ndata[0] = cpu_to_le32(CCE_PACKET3(R128_3D_RNDR_GEN_INDX_PRIM,\r\ndwords - 2));\r\ndata[1] = cpu_to_le32(offset);\r\ndata[2] = cpu_to_le32(R128_MAX_VB_VERTS);\r\ndata[3] = cpu_to_le32(format);\r\ndata[4] = cpu_to_le32((prim | R128_CCE_VC_CNTL_PRIM_WALK_IND |\r\n(count << 16)));\r\nif (count & 0x1) {\r\n#ifdef __LITTLE_ENDIAN\r\ndata[dwords - 1] &= 0x0000ffff;\r\n#else\r\ndata[dwords - 1] &= 0xffff0000;\r\n#endif\r\n}\r\ndo {\r\nif (i < sarea_priv->nbox) {\r\nr128_emit_clip_rects(dev_priv,\r\n&sarea_priv->boxes[i],\r\nsarea_priv->nbox - i);\r\n}\r\nr128_cce_dispatch_indirect(dev, buf, start, end);\r\ni += 3;\r\n} while (i < sarea_priv->nbox);\r\n}\r\nif (buf_priv->discard) {\r\nbuf_priv->age = dev_priv->sarea_priv->last_dispatch;\r\nBEGIN_RING(2);\r\nOUT_RING(CCE_PACKET0(R128_LAST_DISPATCH_REG, 0));\r\nOUT_RING(buf_priv->age);\r\nADVANCE_RING();\r\nbuf->pending = 1;\r\nbuf_priv->dispatched = 0;\r\n}\r\ndev_priv->sarea_priv->last_dispatch++;\r\nsarea_priv->dirty &= ~R128_UPLOAD_CLIPRECTS;\r\nsarea_priv->nbox = 0;\r\n}\r\nstatic int r128_cce_dispatch_blit(struct drm_device *dev,\r\nstruct drm_file *file_priv,\r\ndrm_r128_blit_t *blit)\r\n{\r\ndrm_r128_private_t *dev_priv = dev->dev_private;\r\nstruct drm_device_dma *dma = dev->dma;\r\nstruct drm_buf *buf;\r\ndrm_r128_buf_priv_t *buf_priv;\r\nu32 *data;\r\nint dword_shift, dwords;\r\nRING_LOCALS;\r\nDRM_DEBUG("\n");\r\nswitch (blit->format) {\r\ncase R128_DATATYPE_ARGB8888:\r\ndword_shift = 0;\r\nbreak;\r\ncase R128_DATATYPE_ARGB1555:\r\ncase R128_DATATYPE_RGB565:\r\ncase R128_DATATYPE_ARGB4444:\r\ncase R128_DATATYPE_YVYU422:\r\ncase R128_DATATYPE_VYUY422:\r\ndword_shift = 1;\r\nbreak;\r\ncase R128_DATATYPE_CI8:\r\ncase R128_DATATYPE_RGB8:\r\ndword_shift = 2;\r\nbreak;\r\ndefault:\r\nDRM_ERROR("invalid blit format %d\n", blit->format);\r\nreturn -EINVAL;\r\n}\r\nBEGIN_RING(2);\r\nOUT_RING(CCE_PACKET0(R128_PC_GUI_CTLSTAT, 0));\r\nOUT_RING(R128_PC_RI_GUI | R128_PC_FLUSH_GUI);\r\nADVANCE_RING();\r\nbuf = dma->buflist[blit->idx];\r\nbuf_priv = buf->dev_private;\r\nif (buf->file_priv != file_priv) {\r\nDRM_ERROR("process %d using buffer owned by %p\n",\r\nDRM_CURRENTPID, buf->file_priv);\r\nreturn -EINVAL;\r\n}\r\nif (buf->pending) {\r\nDRM_ERROR("sending pending buffer %d\n", blit->idx);\r\nreturn -EINVAL;\r\n}\r\nbuf_priv->discard = 1;\r\ndwords = (blit->width * blit->height) >> dword_shift;\r\ndata = (u32 *) ((char *)dev->agp_buffer_map->handle + buf->offset);\r\ndata[0] = cpu_to_le32(CCE_PACKET3(R128_CNTL_HOSTDATA_BLT, dwords + 6));\r\ndata[1] = cpu_to_le32((R128_GMC_DST_PITCH_OFFSET_CNTL |\r\nR128_GMC_BRUSH_NONE |\r\n(blit->format << 8) |\r\nR128_GMC_SRC_DATATYPE_COLOR |\r\nR128_ROP3_S |\r\nR128_DP_SRC_SOURCE_HOST_DATA |\r\nR128_GMC_CLR_CMP_CNTL_DIS |\r\nR128_GMC_AUX_CLIP_DIS | R128_GMC_WR_MSK_DIS));\r\ndata[2] = cpu_to_le32((blit->pitch << 21) | (blit->offset >> 5));\r\ndata[3] = cpu_to_le32(0xffffffff);\r\ndata[4] = cpu_to_le32(0xffffffff);\r\ndata[5] = cpu_to_le32((blit->y << 16) | blit->x);\r\ndata[6] = cpu_to_le32((blit->height << 16) | blit->width);\r\ndata[7] = cpu_to_le32(dwords);\r\nbuf->used = (dwords + 8) * sizeof(u32);\r\nr128_cce_dispatch_indirect(dev, buf, 0, buf->used);\r\nBEGIN_RING(2);\r\nOUT_RING(CCE_PACKET0(R128_PC_GUI_CTLSTAT, 0));\r\nOUT_RING(R128_PC_FLUSH_GUI);\r\nADVANCE_RING();\r\nreturn 0;\r\n}\r\nstatic int r128_cce_dispatch_write_span(struct drm_device *dev,\r\ndrm_r128_depth_t *depth)\r\n{\r\ndrm_r128_private_t *dev_priv = dev->dev_private;\r\nint count, x, y;\r\nu32 *buffer;\r\nu8 *mask;\r\nint i, buffer_size, mask_size;\r\nRING_LOCALS;\r\nDRM_DEBUG("\n");\r\ncount = depth->n;\r\nif (count > 4096 || count <= 0)\r\nreturn -EMSGSIZE;\r\nif (copy_from_user(&x, depth->x, sizeof(x)))\r\nreturn -EFAULT;\r\nif (copy_from_user(&y, depth->y, sizeof(y)))\r\nreturn -EFAULT;\r\nbuffer_size = depth->n * sizeof(u32);\r\nbuffer = memdup_user(depth->buffer, buffer_size);\r\nif (IS_ERR(buffer))\r\nreturn PTR_ERR(buffer);\r\nmask_size = depth->n;\r\nif (depth->mask) {\r\nmask = memdup_user(depth->mask, mask_size);\r\nif (IS_ERR(mask)) {\r\nkfree(buffer);\r\nreturn PTR_ERR(mask);\r\n}\r\nfor (i = 0; i < count; i++, x++) {\r\nif (mask[i]) {\r\nBEGIN_RING(6);\r\nOUT_RING(CCE_PACKET3(R128_CNTL_PAINT_MULTI, 4));\r\nOUT_RING(R128_GMC_DST_PITCH_OFFSET_CNTL |\r\nR128_GMC_BRUSH_SOLID_COLOR |\r\n(dev_priv->depth_fmt << 8) |\r\nR128_GMC_SRC_DATATYPE_COLOR |\r\nR128_ROP3_P |\r\nR128_GMC_CLR_CMP_CNTL_DIS |\r\nR128_GMC_WR_MSK_DIS);\r\nOUT_RING(dev_priv->depth_pitch_offset_c);\r\nOUT_RING(buffer[i]);\r\nOUT_RING((x << 16) | y);\r\nOUT_RING((1 << 16) | 1);\r\nADVANCE_RING();\r\n}\r\n}\r\nkfree(mask);\r\n} else {\r\nfor (i = 0; i < count; i++, x++) {\r\nBEGIN_RING(6);\r\nOUT_RING(CCE_PACKET3(R128_CNTL_PAINT_MULTI, 4));\r\nOUT_RING(R128_GMC_DST_PITCH_OFFSET_CNTL |\r\nR128_GMC_BRUSH_SOLID_COLOR |\r\n(dev_priv->depth_fmt << 8) |\r\nR128_GMC_SRC_DATATYPE_COLOR |\r\nR128_ROP3_P |\r\nR128_GMC_CLR_CMP_CNTL_DIS |\r\nR128_GMC_WR_MSK_DIS);\r\nOUT_RING(dev_priv->depth_pitch_offset_c);\r\nOUT_RING(buffer[i]);\r\nOUT_RING((x << 16) | y);\r\nOUT_RING((1 << 16) | 1);\r\nADVANCE_RING();\r\n}\r\n}\r\nkfree(buffer);\r\nreturn 0;\r\n}\r\nstatic int r128_cce_dispatch_write_pixels(struct drm_device *dev,\r\ndrm_r128_depth_t *depth)\r\n{\r\ndrm_r128_private_t *dev_priv = dev->dev_private;\r\nint count, *x, *y;\r\nu32 *buffer;\r\nu8 *mask;\r\nint i, xbuf_size, ybuf_size, buffer_size, mask_size;\r\nRING_LOCALS;\r\nDRM_DEBUG("\n");\r\ncount = depth->n;\r\nif (count > 4096 || count <= 0)\r\nreturn -EMSGSIZE;\r\nxbuf_size = count * sizeof(*x);\r\nybuf_size = count * sizeof(*y);\r\nx = kmalloc(xbuf_size, GFP_KERNEL);\r\nif (x == NULL)\r\nreturn -ENOMEM;\r\ny = kmalloc(ybuf_size, GFP_KERNEL);\r\nif (y == NULL) {\r\nkfree(x);\r\nreturn -ENOMEM;\r\n}\r\nif (copy_from_user(x, depth->x, xbuf_size)) {\r\nkfree(x);\r\nkfree(y);\r\nreturn -EFAULT;\r\n}\r\nif (copy_from_user(y, depth->y, xbuf_size)) {\r\nkfree(x);\r\nkfree(y);\r\nreturn -EFAULT;\r\n}\r\nbuffer_size = depth->n * sizeof(u32);\r\nbuffer = memdup_user(depth->buffer, buffer_size);\r\nif (IS_ERR(buffer)) {\r\nkfree(x);\r\nkfree(y);\r\nreturn PTR_ERR(buffer);\r\n}\r\nif (depth->mask) {\r\nmask_size = depth->n;\r\nmask = memdup_user(depth->mask, mask_size);\r\nif (IS_ERR(mask)) {\r\nkfree(x);\r\nkfree(y);\r\nkfree(buffer);\r\nreturn PTR_ERR(mask);\r\n}\r\nfor (i = 0; i < count; i++) {\r\nif (mask[i]) {\r\nBEGIN_RING(6);\r\nOUT_RING(CCE_PACKET3(R128_CNTL_PAINT_MULTI, 4));\r\nOUT_RING(R128_GMC_DST_PITCH_OFFSET_CNTL |\r\nR128_GMC_BRUSH_SOLID_COLOR |\r\n(dev_priv->depth_fmt << 8) |\r\nR128_GMC_SRC_DATATYPE_COLOR |\r\nR128_ROP3_P |\r\nR128_GMC_CLR_CMP_CNTL_DIS |\r\nR128_GMC_WR_MSK_DIS);\r\nOUT_RING(dev_priv->depth_pitch_offset_c);\r\nOUT_RING(buffer[i]);\r\nOUT_RING((x[i] << 16) | y[i]);\r\nOUT_RING((1 << 16) | 1);\r\nADVANCE_RING();\r\n}\r\n}\r\nkfree(mask);\r\n} else {\r\nfor (i = 0; i < count; i++) {\r\nBEGIN_RING(6);\r\nOUT_RING(CCE_PACKET3(R128_CNTL_PAINT_MULTI, 4));\r\nOUT_RING(R128_GMC_DST_PITCH_OFFSET_CNTL |\r\nR128_GMC_BRUSH_SOLID_COLOR |\r\n(dev_priv->depth_fmt << 8) |\r\nR128_GMC_SRC_DATATYPE_COLOR |\r\nR128_ROP3_P |\r\nR128_GMC_CLR_CMP_CNTL_DIS |\r\nR128_GMC_WR_MSK_DIS);\r\nOUT_RING(dev_priv->depth_pitch_offset_c);\r\nOUT_RING(buffer[i]);\r\nOUT_RING((x[i] << 16) | y[i]);\r\nOUT_RING((1 << 16) | 1);\r\nADVANCE_RING();\r\n}\r\n}\r\nkfree(x);\r\nkfree(y);\r\nkfree(buffer);\r\nreturn 0;\r\n}\r\nstatic int r128_cce_dispatch_read_span(struct drm_device *dev,\r\ndrm_r128_depth_t *depth)\r\n{\r\ndrm_r128_private_t *dev_priv = dev->dev_private;\r\nint count, x, y;\r\nRING_LOCALS;\r\nDRM_DEBUG("\n");\r\ncount = depth->n;\r\nif (count > 4096 || count <= 0)\r\nreturn -EMSGSIZE;\r\nif (copy_from_user(&x, depth->x, sizeof(x)))\r\nreturn -EFAULT;\r\nif (copy_from_user(&y, depth->y, sizeof(y)))\r\nreturn -EFAULT;\r\nBEGIN_RING(7);\r\nOUT_RING(CCE_PACKET3(R128_CNTL_BITBLT_MULTI, 5));\r\nOUT_RING(R128_GMC_SRC_PITCH_OFFSET_CNTL |\r\nR128_GMC_DST_PITCH_OFFSET_CNTL |\r\nR128_GMC_BRUSH_NONE |\r\n(dev_priv->depth_fmt << 8) |\r\nR128_GMC_SRC_DATATYPE_COLOR |\r\nR128_ROP3_S |\r\nR128_DP_SRC_SOURCE_MEMORY |\r\nR128_GMC_CLR_CMP_CNTL_DIS | R128_GMC_WR_MSK_DIS);\r\nOUT_RING(dev_priv->depth_pitch_offset_c);\r\nOUT_RING(dev_priv->span_pitch_offset_c);\r\nOUT_RING((x << 16) | y);\r\nOUT_RING((0 << 16) | 0);\r\nOUT_RING((count << 16) | 1);\r\nADVANCE_RING();\r\nreturn 0;\r\n}\r\nstatic int r128_cce_dispatch_read_pixels(struct drm_device *dev,\r\ndrm_r128_depth_t *depth)\r\n{\r\ndrm_r128_private_t *dev_priv = dev->dev_private;\r\nint count, *x, *y;\r\nint i, xbuf_size, ybuf_size;\r\nRING_LOCALS;\r\nDRM_DEBUG("\n");\r\ncount = depth->n;\r\nif (count > 4096 || count <= 0)\r\nreturn -EMSGSIZE;\r\nif (count > dev_priv->depth_pitch)\r\ncount = dev_priv->depth_pitch;\r\nxbuf_size = count * sizeof(*x);\r\nybuf_size = count * sizeof(*y);\r\nx = kmalloc(xbuf_size, GFP_KERNEL);\r\nif (x == NULL)\r\nreturn -ENOMEM;\r\ny = kmalloc(ybuf_size, GFP_KERNEL);\r\nif (y == NULL) {\r\nkfree(x);\r\nreturn -ENOMEM;\r\n}\r\nif (copy_from_user(x, depth->x, xbuf_size)) {\r\nkfree(x);\r\nkfree(y);\r\nreturn -EFAULT;\r\n}\r\nif (copy_from_user(y, depth->y, ybuf_size)) {\r\nkfree(x);\r\nkfree(y);\r\nreturn -EFAULT;\r\n}\r\nfor (i = 0; i < count; i++) {\r\nBEGIN_RING(7);\r\nOUT_RING(CCE_PACKET3(R128_CNTL_BITBLT_MULTI, 5));\r\nOUT_RING(R128_GMC_SRC_PITCH_OFFSET_CNTL |\r\nR128_GMC_DST_PITCH_OFFSET_CNTL |\r\nR128_GMC_BRUSH_NONE |\r\n(dev_priv->depth_fmt << 8) |\r\nR128_GMC_SRC_DATATYPE_COLOR |\r\nR128_ROP3_S |\r\nR128_DP_SRC_SOURCE_MEMORY |\r\nR128_GMC_CLR_CMP_CNTL_DIS | R128_GMC_WR_MSK_DIS);\r\nOUT_RING(dev_priv->depth_pitch_offset_c);\r\nOUT_RING(dev_priv->span_pitch_offset_c);\r\nOUT_RING((x[i] << 16) | y[i]);\r\nOUT_RING((i << 16) | 0);\r\nOUT_RING((1 << 16) | 1);\r\nADVANCE_RING();\r\n}\r\nkfree(x);\r\nkfree(y);\r\nreturn 0;\r\n}\r\nstatic void r128_cce_dispatch_stipple(struct drm_device *dev, u32 *stipple)\r\n{\r\ndrm_r128_private_t *dev_priv = dev->dev_private;\r\nint i;\r\nRING_LOCALS;\r\nDRM_DEBUG("\n");\r\nBEGIN_RING(33);\r\nOUT_RING(CCE_PACKET0(R128_BRUSH_DATA0, 31));\r\nfor (i = 0; i < 32; i++)\r\nOUT_RING(stipple[i]);\r\nADVANCE_RING();\r\n}\r\nstatic int r128_cce_clear(struct drm_device *dev, void *data, struct drm_file *file_priv)\r\n{\r\ndrm_r128_private_t *dev_priv = dev->dev_private;\r\ndrm_r128_sarea_t *sarea_priv;\r\ndrm_r128_clear_t *clear = data;\r\nDRM_DEBUG("\n");\r\nLOCK_TEST_WITH_RETURN(dev, file_priv);\r\nDEV_INIT_TEST_WITH_RETURN(dev_priv);\r\nRING_SPACE_TEST_WITH_RETURN(dev_priv);\r\nsarea_priv = dev_priv->sarea_priv;\r\nif (sarea_priv->nbox > R128_NR_SAREA_CLIPRECTS)\r\nsarea_priv->nbox = R128_NR_SAREA_CLIPRECTS;\r\nr128_cce_dispatch_clear(dev, clear);\r\nCOMMIT_RING();\r\ndev_priv->sarea_priv->dirty |= R128_UPLOAD_CONTEXT | R128_UPLOAD_MASKS;\r\nreturn 0;\r\n}\r\nstatic int r128_do_init_pageflip(struct drm_device *dev)\r\n{\r\ndrm_r128_private_t *dev_priv = dev->dev_private;\r\nDRM_DEBUG("\n");\r\ndev_priv->crtc_offset = R128_READ(R128_CRTC_OFFSET);\r\ndev_priv->crtc_offset_cntl = R128_READ(R128_CRTC_OFFSET_CNTL);\r\nR128_WRITE(R128_CRTC_OFFSET, dev_priv->front_offset);\r\nR128_WRITE(R128_CRTC_OFFSET_CNTL,\r\ndev_priv->crtc_offset_cntl | R128_CRTC_OFFSET_FLIP_CNTL);\r\ndev_priv->page_flipping = 1;\r\ndev_priv->current_page = 0;\r\ndev_priv->sarea_priv->pfCurrentPage = dev_priv->current_page;\r\nreturn 0;\r\n}\r\nstatic int r128_do_cleanup_pageflip(struct drm_device *dev)\r\n{\r\ndrm_r128_private_t *dev_priv = dev->dev_private;\r\nDRM_DEBUG("\n");\r\nR128_WRITE(R128_CRTC_OFFSET, dev_priv->crtc_offset);\r\nR128_WRITE(R128_CRTC_OFFSET_CNTL, dev_priv->crtc_offset_cntl);\r\nif (dev_priv->current_page != 0) {\r\nr128_cce_dispatch_flip(dev);\r\nCOMMIT_RING();\r\n}\r\ndev_priv->page_flipping = 0;\r\nreturn 0;\r\n}\r\nstatic int r128_cce_flip(struct drm_device *dev, void *data, struct drm_file *file_priv)\r\n{\r\ndrm_r128_private_t *dev_priv = dev->dev_private;\r\nDRM_DEBUG("\n");\r\nLOCK_TEST_WITH_RETURN(dev, file_priv);\r\nDEV_INIT_TEST_WITH_RETURN(dev_priv);\r\nRING_SPACE_TEST_WITH_RETURN(dev_priv);\r\nif (!dev_priv->page_flipping)\r\nr128_do_init_pageflip(dev);\r\nr128_cce_dispatch_flip(dev);\r\nCOMMIT_RING();\r\nreturn 0;\r\n}\r\nstatic int r128_cce_swap(struct drm_device *dev, void *data, struct drm_file *file_priv)\r\n{\r\ndrm_r128_private_t *dev_priv = dev->dev_private;\r\ndrm_r128_sarea_t *sarea_priv = dev_priv->sarea_priv;\r\nDRM_DEBUG("\n");\r\nLOCK_TEST_WITH_RETURN(dev, file_priv);\r\nDEV_INIT_TEST_WITH_RETURN(dev_priv);\r\nRING_SPACE_TEST_WITH_RETURN(dev_priv);\r\nif (sarea_priv->nbox > R128_NR_SAREA_CLIPRECTS)\r\nsarea_priv->nbox = R128_NR_SAREA_CLIPRECTS;\r\nr128_cce_dispatch_swap(dev);\r\ndev_priv->sarea_priv->dirty |= (R128_UPLOAD_CONTEXT |\r\nR128_UPLOAD_MASKS);\r\nCOMMIT_RING();\r\nreturn 0;\r\n}\r\nstatic int r128_cce_vertex(struct drm_device *dev, void *data, struct drm_file *file_priv)\r\n{\r\ndrm_r128_private_t *dev_priv = dev->dev_private;\r\nstruct drm_device_dma *dma = dev->dma;\r\nstruct drm_buf *buf;\r\ndrm_r128_buf_priv_t *buf_priv;\r\ndrm_r128_vertex_t *vertex = data;\r\nLOCK_TEST_WITH_RETURN(dev, file_priv);\r\nDEV_INIT_TEST_WITH_RETURN(dev_priv);\r\nDRM_DEBUG("pid=%d index=%d count=%d discard=%d\n",\r\nDRM_CURRENTPID, vertex->idx, vertex->count, vertex->discard);\r\nif (vertex->idx < 0 || vertex->idx >= dma->buf_count) {\r\nDRM_ERROR("buffer index %d (of %d max)\n",\r\nvertex->idx, dma->buf_count - 1);\r\nreturn -EINVAL;\r\n}\r\nif (vertex->prim < 0 ||\r\nvertex->prim > R128_CCE_VC_CNTL_PRIM_TYPE_TRI_TYPE2) {\r\nDRM_ERROR("buffer prim %d\n", vertex->prim);\r\nreturn -EINVAL;\r\n}\r\nRING_SPACE_TEST_WITH_RETURN(dev_priv);\r\nVB_AGE_TEST_WITH_RETURN(dev_priv);\r\nbuf = dma->buflist[vertex->idx];\r\nbuf_priv = buf->dev_private;\r\nif (buf->file_priv != file_priv) {\r\nDRM_ERROR("process %d using buffer owned by %p\n",\r\nDRM_CURRENTPID, buf->file_priv);\r\nreturn -EINVAL;\r\n}\r\nif (buf->pending) {\r\nDRM_ERROR("sending pending buffer %d\n", vertex->idx);\r\nreturn -EINVAL;\r\n}\r\nbuf->used = vertex->count;\r\nbuf_priv->prim = vertex->prim;\r\nbuf_priv->discard = vertex->discard;\r\nr128_cce_dispatch_vertex(dev, buf);\r\nCOMMIT_RING();\r\nreturn 0;\r\n}\r\nstatic int r128_cce_indices(struct drm_device *dev, void *data, struct drm_file *file_priv)\r\n{\r\ndrm_r128_private_t *dev_priv = dev->dev_private;\r\nstruct drm_device_dma *dma = dev->dma;\r\nstruct drm_buf *buf;\r\ndrm_r128_buf_priv_t *buf_priv;\r\ndrm_r128_indices_t *elts = data;\r\nint count;\r\nLOCK_TEST_WITH_RETURN(dev, file_priv);\r\nDEV_INIT_TEST_WITH_RETURN(dev_priv);\r\nDRM_DEBUG("pid=%d buf=%d s=%d e=%d d=%d\n", DRM_CURRENTPID,\r\nelts->idx, elts->start, elts->end, elts->discard);\r\nif (elts->idx < 0 || elts->idx >= dma->buf_count) {\r\nDRM_ERROR("buffer index %d (of %d max)\n",\r\nelts->idx, dma->buf_count - 1);\r\nreturn -EINVAL;\r\n}\r\nif (elts->prim < 0 ||\r\nelts->prim > R128_CCE_VC_CNTL_PRIM_TYPE_TRI_TYPE2) {\r\nDRM_ERROR("buffer prim %d\n", elts->prim);\r\nreturn -EINVAL;\r\n}\r\nRING_SPACE_TEST_WITH_RETURN(dev_priv);\r\nVB_AGE_TEST_WITH_RETURN(dev_priv);\r\nbuf = dma->buflist[elts->idx];\r\nbuf_priv = buf->dev_private;\r\nif (buf->file_priv != file_priv) {\r\nDRM_ERROR("process %d using buffer owned by %p\n",\r\nDRM_CURRENTPID, buf->file_priv);\r\nreturn -EINVAL;\r\n}\r\nif (buf->pending) {\r\nDRM_ERROR("sending pending buffer %d\n", elts->idx);\r\nreturn -EINVAL;\r\n}\r\ncount = (elts->end - elts->start) / sizeof(u16);\r\nelts->start -= R128_INDEX_PRIM_OFFSET;\r\nif (elts->start & 0x7) {\r\nDRM_ERROR("misaligned buffer 0x%x\n", elts->start);\r\nreturn -EINVAL;\r\n}\r\nif (elts->start < buf->used) {\r\nDRM_ERROR("no header 0x%x - 0x%x\n", elts->start, buf->used);\r\nreturn -EINVAL;\r\n}\r\nbuf->used = elts->end;\r\nbuf_priv->prim = elts->prim;\r\nbuf_priv->discard = elts->discard;\r\nr128_cce_dispatch_indices(dev, buf, elts->start, elts->end, count);\r\nCOMMIT_RING();\r\nreturn 0;\r\n}\r\nstatic int r128_cce_blit(struct drm_device *dev, void *data, struct drm_file *file_priv)\r\n{\r\nstruct drm_device_dma *dma = dev->dma;\r\ndrm_r128_private_t *dev_priv = dev->dev_private;\r\ndrm_r128_blit_t *blit = data;\r\nint ret;\r\nLOCK_TEST_WITH_RETURN(dev, file_priv);\r\nDEV_INIT_TEST_WITH_RETURN(dev_priv);\r\nDRM_DEBUG("pid=%d index=%d\n", DRM_CURRENTPID, blit->idx);\r\nif (blit->idx < 0 || blit->idx >= dma->buf_count) {\r\nDRM_ERROR("buffer index %d (of %d max)\n",\r\nblit->idx, dma->buf_count - 1);\r\nreturn -EINVAL;\r\n}\r\nRING_SPACE_TEST_WITH_RETURN(dev_priv);\r\nVB_AGE_TEST_WITH_RETURN(dev_priv);\r\nret = r128_cce_dispatch_blit(dev, file_priv, blit);\r\nCOMMIT_RING();\r\nreturn ret;\r\n}\r\nstatic int r128_cce_depth(struct drm_device *dev, void *data, struct drm_file *file_priv)\r\n{\r\ndrm_r128_private_t *dev_priv = dev->dev_private;\r\ndrm_r128_depth_t *depth = data;\r\nint ret;\r\nLOCK_TEST_WITH_RETURN(dev, file_priv);\r\nDEV_INIT_TEST_WITH_RETURN(dev_priv);\r\nRING_SPACE_TEST_WITH_RETURN(dev_priv);\r\nret = -EINVAL;\r\nswitch (depth->func) {\r\ncase R128_WRITE_SPAN:\r\nret = r128_cce_dispatch_write_span(dev, depth);\r\nbreak;\r\ncase R128_WRITE_PIXELS:\r\nret = r128_cce_dispatch_write_pixels(dev, depth);\r\nbreak;\r\ncase R128_READ_SPAN:\r\nret = r128_cce_dispatch_read_span(dev, depth);\r\nbreak;\r\ncase R128_READ_PIXELS:\r\nret = r128_cce_dispatch_read_pixels(dev, depth);\r\nbreak;\r\n}\r\nCOMMIT_RING();\r\nreturn ret;\r\n}\r\nstatic int r128_cce_stipple(struct drm_device *dev, void *data, struct drm_file *file_priv)\r\n{\r\ndrm_r128_private_t *dev_priv = dev->dev_private;\r\ndrm_r128_stipple_t *stipple = data;\r\nu32 mask[32];\r\nLOCK_TEST_WITH_RETURN(dev, file_priv);\r\nDEV_INIT_TEST_WITH_RETURN(dev_priv);\r\nif (copy_from_user(&mask, stipple->mask, 32 * sizeof(u32)))\r\nreturn -EFAULT;\r\nRING_SPACE_TEST_WITH_RETURN(dev_priv);\r\nr128_cce_dispatch_stipple(dev, mask);\r\nCOMMIT_RING();\r\nreturn 0;\r\n}\r\nstatic int r128_cce_indirect(struct drm_device *dev, void *data, struct drm_file *file_priv)\r\n{\r\ndrm_r128_private_t *dev_priv = dev->dev_private;\r\nstruct drm_device_dma *dma = dev->dma;\r\nstruct drm_buf *buf;\r\ndrm_r128_buf_priv_t *buf_priv;\r\ndrm_r128_indirect_t *indirect = data;\r\n#if 0\r\nRING_LOCALS;\r\n#endif\r\nLOCK_TEST_WITH_RETURN(dev, file_priv);\r\nDEV_INIT_TEST_WITH_RETURN(dev_priv);\r\nDRM_DEBUG("idx=%d s=%d e=%d d=%d\n",\r\nindirect->idx, indirect->start, indirect->end,\r\nindirect->discard);\r\nif (indirect->idx < 0 || indirect->idx >= dma->buf_count) {\r\nDRM_ERROR("buffer index %d (of %d max)\n",\r\nindirect->idx, dma->buf_count - 1);\r\nreturn -EINVAL;\r\n}\r\nbuf = dma->buflist[indirect->idx];\r\nbuf_priv = buf->dev_private;\r\nif (buf->file_priv != file_priv) {\r\nDRM_ERROR("process %d using buffer owned by %p\n",\r\nDRM_CURRENTPID, buf->file_priv);\r\nreturn -EINVAL;\r\n}\r\nif (buf->pending) {\r\nDRM_ERROR("sending pending buffer %d\n", indirect->idx);\r\nreturn -EINVAL;\r\n}\r\nif (indirect->start < buf->used) {\r\nDRM_ERROR("reusing indirect: start=0x%x actual=0x%x\n",\r\nindirect->start, buf->used);\r\nreturn -EINVAL;\r\n}\r\nRING_SPACE_TEST_WITH_RETURN(dev_priv);\r\nVB_AGE_TEST_WITH_RETURN(dev_priv);\r\nbuf->used = indirect->end;\r\nbuf_priv->discard = indirect->discard;\r\n#if 0\r\nBEGIN_RING(2);\r\nRADEON_WAIT_UNTIL_3D_IDLE();\r\nADVANCE_RING();\r\n#endif\r\nr128_cce_dispatch_indirect(dev, buf, indirect->start, indirect->end);\r\nCOMMIT_RING();\r\nreturn 0;\r\n}\r\nstatic int r128_getparam(struct drm_device *dev, void *data, struct drm_file *file_priv)\r\n{\r\ndrm_r128_private_t *dev_priv = dev->dev_private;\r\ndrm_r128_getparam_t *param = data;\r\nint value;\r\nDEV_INIT_TEST_WITH_RETURN(dev_priv);\r\nDRM_DEBUG("pid=%d\n", DRM_CURRENTPID);\r\nswitch (param->param) {\r\ncase R128_PARAM_IRQ_NR:\r\nvalue = dev->pdev->irq;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nif (copy_to_user(param->value, &value, sizeof(int))) {\r\nDRM_ERROR("copy_to_user\n");\r\nreturn -EFAULT;\r\n}\r\nreturn 0;\r\n}\r\nvoid r128_driver_preclose(struct drm_device *dev, struct drm_file *file_priv)\r\n{\r\nif (dev->dev_private) {\r\ndrm_r128_private_t *dev_priv = dev->dev_private;\r\nif (dev_priv->page_flipping)\r\nr128_do_cleanup_pageflip(dev);\r\n}\r\n}\r\nvoid r128_driver_lastclose(struct drm_device *dev)\r\n{\r\nr128_do_cleanup_cce(dev);\r\n}
