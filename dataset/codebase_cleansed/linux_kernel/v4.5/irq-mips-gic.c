static inline u32 gic_read32(unsigned int reg)\r\n{\r\nreturn __raw_readl(gic_base + reg);\r\n}\r\nstatic inline u64 gic_read64(unsigned int reg)\r\n{\r\nreturn __raw_readq(gic_base + reg);\r\n}\r\nstatic inline unsigned long gic_read(unsigned int reg)\r\n{\r\nif (!mips_cm_is64)\r\nreturn gic_read32(reg);\r\nelse\r\nreturn gic_read64(reg);\r\n}\r\nstatic inline void gic_write32(unsigned int reg, u32 val)\r\n{\r\nreturn __raw_writel(val, gic_base + reg);\r\n}\r\nstatic inline void gic_write64(unsigned int reg, u64 val)\r\n{\r\nreturn __raw_writeq(val, gic_base + reg);\r\n}\r\nstatic inline void gic_write(unsigned int reg, unsigned long val)\r\n{\r\nif (!mips_cm_is64)\r\nreturn gic_write32(reg, (u32)val);\r\nelse\r\nreturn gic_write64(reg, (u64)val);\r\n}\r\nstatic inline void gic_update_bits(unsigned int reg, unsigned long mask,\r\nunsigned long val)\r\n{\r\nunsigned long regval;\r\nregval = gic_read(reg);\r\nregval &= ~mask;\r\nregval |= val;\r\ngic_write(reg, regval);\r\n}\r\nstatic inline void gic_reset_mask(unsigned int intr)\r\n{\r\ngic_write(GIC_REG(SHARED, GIC_SH_RMASK) + GIC_INTR_OFS(intr),\r\n1ul << GIC_INTR_BIT(intr));\r\n}\r\nstatic inline void gic_set_mask(unsigned int intr)\r\n{\r\ngic_write(GIC_REG(SHARED, GIC_SH_SMASK) + GIC_INTR_OFS(intr),\r\n1ul << GIC_INTR_BIT(intr));\r\n}\r\nstatic inline void gic_set_polarity(unsigned int intr, unsigned int pol)\r\n{\r\ngic_update_bits(GIC_REG(SHARED, GIC_SH_SET_POLARITY) +\r\nGIC_INTR_OFS(intr), 1ul << GIC_INTR_BIT(intr),\r\n(unsigned long)pol << GIC_INTR_BIT(intr));\r\n}\r\nstatic inline void gic_set_trigger(unsigned int intr, unsigned int trig)\r\n{\r\ngic_update_bits(GIC_REG(SHARED, GIC_SH_SET_TRIGGER) +\r\nGIC_INTR_OFS(intr), 1ul << GIC_INTR_BIT(intr),\r\n(unsigned long)trig << GIC_INTR_BIT(intr));\r\n}\r\nstatic inline void gic_set_dual_edge(unsigned int intr, unsigned int dual)\r\n{\r\ngic_update_bits(GIC_REG(SHARED, GIC_SH_SET_DUAL) + GIC_INTR_OFS(intr),\r\n1ul << GIC_INTR_BIT(intr),\r\n(unsigned long)dual << GIC_INTR_BIT(intr));\r\n}\r\nstatic inline void gic_map_to_pin(unsigned int intr, unsigned int pin)\r\n{\r\ngic_write32(GIC_REG(SHARED, GIC_SH_INTR_MAP_TO_PIN_BASE) +\r\nGIC_SH_MAP_TO_PIN(intr), GIC_MAP_TO_PIN_MSK | pin);\r\n}\r\nstatic inline void gic_map_to_vpe(unsigned int intr, unsigned int vpe)\r\n{\r\ngic_write(GIC_REG(SHARED, GIC_SH_INTR_MAP_TO_VPE_BASE) +\r\nGIC_SH_MAP_TO_VPE_REG_OFF(intr, vpe),\r\nGIC_SH_MAP_TO_VPE_REG_BIT(vpe));\r\n}\r\ncycle_t gic_read_count(void)\r\n{\r\nunsigned int hi, hi2, lo;\r\nif (mips_cm_is64)\r\nreturn (cycle_t)gic_read(GIC_REG(SHARED, GIC_SH_COUNTER));\r\ndo {\r\nhi = gic_read32(GIC_REG(SHARED, GIC_SH_COUNTER_63_32));\r\nlo = gic_read32(GIC_REG(SHARED, GIC_SH_COUNTER_31_00));\r\nhi2 = gic_read32(GIC_REG(SHARED, GIC_SH_COUNTER_63_32));\r\n} while (hi2 != hi);\r\nreturn (((cycle_t) hi) << 32) + lo;\r\n}\r\nunsigned int gic_get_count_width(void)\r\n{\r\nunsigned int bits, config;\r\nconfig = gic_read(GIC_REG(SHARED, GIC_SH_CONFIG));\r\nbits = 32 + 4 * ((config & GIC_SH_CONFIG_COUNTBITS_MSK) >>\r\nGIC_SH_CONFIG_COUNTBITS_SHF);\r\nreturn bits;\r\n}\r\nvoid gic_write_compare(cycle_t cnt)\r\n{\r\nif (mips_cm_is64) {\r\ngic_write(GIC_REG(VPE_LOCAL, GIC_VPE_COMPARE), cnt);\r\n} else {\r\ngic_write32(GIC_REG(VPE_LOCAL, GIC_VPE_COMPARE_HI),\r\n(int)(cnt >> 32));\r\ngic_write32(GIC_REG(VPE_LOCAL, GIC_VPE_COMPARE_LO),\r\n(int)(cnt & 0xffffffff));\r\n}\r\n}\r\nvoid gic_write_cpu_compare(cycle_t cnt, int cpu)\r\n{\r\nunsigned long flags;\r\nlocal_irq_save(flags);\r\ngic_write(GIC_REG(VPE_LOCAL, GIC_VPE_OTHER_ADDR), cpu);\r\nif (mips_cm_is64) {\r\ngic_write(GIC_REG(VPE_OTHER, GIC_VPE_COMPARE), cnt);\r\n} else {\r\ngic_write32(GIC_REG(VPE_OTHER, GIC_VPE_COMPARE_HI),\r\n(int)(cnt >> 32));\r\ngic_write32(GIC_REG(VPE_OTHER, GIC_VPE_COMPARE_LO),\r\n(int)(cnt & 0xffffffff));\r\n}\r\nlocal_irq_restore(flags);\r\n}\r\ncycle_t gic_read_compare(void)\r\n{\r\nunsigned int hi, lo;\r\nif (mips_cm_is64)\r\nreturn (cycle_t)gic_read(GIC_REG(VPE_LOCAL, GIC_VPE_COMPARE));\r\nhi = gic_read32(GIC_REG(VPE_LOCAL, GIC_VPE_COMPARE_HI));\r\nlo = gic_read32(GIC_REG(VPE_LOCAL, GIC_VPE_COMPARE_LO));\r\nreturn (((cycle_t) hi) << 32) + lo;\r\n}\r\nvoid gic_start_count(void)\r\n{\r\nu32 gicconfig;\r\ngicconfig = gic_read(GIC_REG(SHARED, GIC_SH_CONFIG));\r\ngicconfig &= ~(1 << GIC_SH_CONFIG_COUNTSTOP_SHF);\r\ngic_write(GIC_REG(SHARED, GIC_SH_CONFIG), gicconfig);\r\n}\r\nvoid gic_stop_count(void)\r\n{\r\nu32 gicconfig;\r\ngicconfig = gic_read(GIC_REG(SHARED, GIC_SH_CONFIG));\r\ngicconfig |= 1 << GIC_SH_CONFIG_COUNTSTOP_SHF;\r\ngic_write(GIC_REG(SHARED, GIC_SH_CONFIG), gicconfig);\r\n}\r\nstatic bool gic_local_irq_is_routable(int intr)\r\n{\r\nu32 vpe_ctl;\r\nif (cpu_has_veic)\r\nreturn true;\r\nvpe_ctl = gic_read32(GIC_REG(VPE_LOCAL, GIC_VPE_CTL));\r\nswitch (intr) {\r\ncase GIC_LOCAL_INT_TIMER:\r\nreturn vpe_ctl & GIC_VPE_CTL_TIMER_RTBL_MSK;\r\ncase GIC_LOCAL_INT_PERFCTR:\r\nreturn vpe_ctl & GIC_VPE_CTL_PERFCNT_RTBL_MSK;\r\ncase GIC_LOCAL_INT_FDC:\r\nreturn vpe_ctl & GIC_VPE_CTL_FDC_RTBL_MSK;\r\ncase GIC_LOCAL_INT_SWINT0:\r\ncase GIC_LOCAL_INT_SWINT1:\r\nreturn vpe_ctl & GIC_VPE_CTL_SWINT_RTBL_MSK;\r\ndefault:\r\nreturn true;\r\n}\r\n}\r\nstatic void gic_bind_eic_interrupt(int irq, int set)\r\n{\r\nirq -= GIC_PIN_TO_VEC_OFFSET;\r\ngic_write(GIC_REG(VPE_LOCAL, GIC_VPE_EIC_SHADOW_SET_BASE) +\r\nGIC_VPE_EIC_SS(irq), set);\r\n}\r\nvoid gic_send_ipi(unsigned int intr)\r\n{\r\ngic_write(GIC_REG(SHARED, GIC_SH_WEDGE), GIC_SH_WEDGE_SET(intr));\r\n}\r\nint gic_get_c0_compare_int(void)\r\n{\r\nif (!gic_local_irq_is_routable(GIC_LOCAL_INT_TIMER))\r\nreturn MIPS_CPU_IRQ_BASE + cp0_compare_irq;\r\nreturn irq_create_mapping(gic_irq_domain,\r\nGIC_LOCAL_TO_HWIRQ(GIC_LOCAL_INT_TIMER));\r\n}\r\nint gic_get_c0_perfcount_int(void)\r\n{\r\nif (!gic_local_irq_is_routable(GIC_LOCAL_INT_PERFCTR)) {\r\nif (cp0_perfcount_irq < 0)\r\nreturn -1;\r\nreturn MIPS_CPU_IRQ_BASE + cp0_perfcount_irq;\r\n}\r\nreturn irq_create_mapping(gic_irq_domain,\r\nGIC_LOCAL_TO_HWIRQ(GIC_LOCAL_INT_PERFCTR));\r\n}\r\nint gic_get_c0_fdc_int(void)\r\n{\r\nif (!gic_local_irq_is_routable(GIC_LOCAL_INT_FDC)) {\r\nif (cp0_fdc_irq < 0)\r\nreturn -1;\r\nreturn MIPS_CPU_IRQ_BASE + cp0_fdc_irq;\r\n}\r\nreturn irq_create_mapping(gic_irq_domain,\r\nGIC_LOCAL_TO_HWIRQ(GIC_LOCAL_INT_FDC));\r\n}\r\nint gic_get_usm_range(struct resource *gic_usm_res)\r\n{\r\nif (!gic_present)\r\nreturn -1;\r\ngic_usm_res->start = __gic_base_addr + USM_VISIBLE_SECTION_OFS;\r\ngic_usm_res->end = gic_usm_res->start + (USM_VISIBLE_SECTION_SIZE - 1);\r\nreturn 0;\r\n}\r\nstatic void gic_handle_shared_int(bool chained)\r\n{\r\nunsigned int i, intr, virq, gic_reg_step = mips_cm_is64 ? 8 : 4;\r\nunsigned long *pcpu_mask;\r\nunsigned long pending_reg, intrmask_reg;\r\nDECLARE_BITMAP(pending, GIC_MAX_INTRS);\r\nDECLARE_BITMAP(intrmask, GIC_MAX_INTRS);\r\npcpu_mask = pcpu_masks[smp_processor_id()].pcpu_mask;\r\npending_reg = GIC_REG(SHARED, GIC_SH_PEND);\r\nintrmask_reg = GIC_REG(SHARED, GIC_SH_MASK);\r\nfor (i = 0; i < BITS_TO_LONGS(gic_shared_intrs); i++) {\r\npending[i] = gic_read(pending_reg);\r\nintrmask[i] = gic_read(intrmask_reg);\r\npending_reg += gic_reg_step;\r\nintrmask_reg += gic_reg_step;\r\nif (!config_enabled(CONFIG_64BIT) || mips_cm_is64)\r\ncontinue;\r\npending[i] |= (u64)gic_read(pending_reg) << 32;\r\nintrmask[i] |= (u64)gic_read(intrmask_reg) << 32;\r\npending_reg += gic_reg_step;\r\nintrmask_reg += gic_reg_step;\r\n}\r\nbitmap_and(pending, pending, intrmask, gic_shared_intrs);\r\nbitmap_and(pending, pending, pcpu_mask, gic_shared_intrs);\r\nintr = find_first_bit(pending, gic_shared_intrs);\r\nwhile (intr != gic_shared_intrs) {\r\nvirq = irq_linear_revmap(gic_irq_domain,\r\nGIC_SHARED_TO_HWIRQ(intr));\r\nif (chained)\r\ngeneric_handle_irq(virq);\r\nelse\r\ndo_IRQ(virq);\r\nbitmap_clear(pending, intr, 1);\r\nintr = find_first_bit(pending, gic_shared_intrs);\r\n}\r\n}\r\nstatic void gic_mask_irq(struct irq_data *d)\r\n{\r\ngic_reset_mask(GIC_HWIRQ_TO_SHARED(d->hwirq));\r\n}\r\nstatic void gic_unmask_irq(struct irq_data *d)\r\n{\r\ngic_set_mask(GIC_HWIRQ_TO_SHARED(d->hwirq));\r\n}\r\nstatic void gic_ack_irq(struct irq_data *d)\r\n{\r\nunsigned int irq = GIC_HWIRQ_TO_SHARED(d->hwirq);\r\ngic_write(GIC_REG(SHARED, GIC_SH_WEDGE), GIC_SH_WEDGE_CLR(irq));\r\n}\r\nstatic int gic_set_type(struct irq_data *d, unsigned int type)\r\n{\r\nunsigned int irq = GIC_HWIRQ_TO_SHARED(d->hwirq);\r\nunsigned long flags;\r\nbool is_edge;\r\nspin_lock_irqsave(&gic_lock, flags);\r\nswitch (type & IRQ_TYPE_SENSE_MASK) {\r\ncase IRQ_TYPE_EDGE_FALLING:\r\ngic_set_polarity(irq, GIC_POL_NEG);\r\ngic_set_trigger(irq, GIC_TRIG_EDGE);\r\ngic_set_dual_edge(irq, GIC_TRIG_DUAL_DISABLE);\r\nis_edge = true;\r\nbreak;\r\ncase IRQ_TYPE_EDGE_RISING:\r\ngic_set_polarity(irq, GIC_POL_POS);\r\ngic_set_trigger(irq, GIC_TRIG_EDGE);\r\ngic_set_dual_edge(irq, GIC_TRIG_DUAL_DISABLE);\r\nis_edge = true;\r\nbreak;\r\ncase IRQ_TYPE_EDGE_BOTH:\r\ngic_set_trigger(irq, GIC_TRIG_EDGE);\r\ngic_set_dual_edge(irq, GIC_TRIG_DUAL_ENABLE);\r\nis_edge = true;\r\nbreak;\r\ncase IRQ_TYPE_LEVEL_LOW:\r\ngic_set_polarity(irq, GIC_POL_NEG);\r\ngic_set_trigger(irq, GIC_TRIG_LEVEL);\r\ngic_set_dual_edge(irq, GIC_TRIG_DUAL_DISABLE);\r\nis_edge = false;\r\nbreak;\r\ncase IRQ_TYPE_LEVEL_HIGH:\r\ndefault:\r\ngic_set_polarity(irq, GIC_POL_POS);\r\ngic_set_trigger(irq, GIC_TRIG_LEVEL);\r\ngic_set_dual_edge(irq, GIC_TRIG_DUAL_DISABLE);\r\nis_edge = false;\r\nbreak;\r\n}\r\nif (is_edge)\r\nirq_set_chip_handler_name_locked(d, &gic_edge_irq_controller,\r\nhandle_edge_irq, NULL);\r\nelse\r\nirq_set_chip_handler_name_locked(d, &gic_level_irq_controller,\r\nhandle_level_irq, NULL);\r\nspin_unlock_irqrestore(&gic_lock, flags);\r\nreturn 0;\r\n}\r\nstatic int gic_set_affinity(struct irq_data *d, const struct cpumask *cpumask,\r\nbool force)\r\n{\r\nunsigned int irq = GIC_HWIRQ_TO_SHARED(d->hwirq);\r\ncpumask_t tmp = CPU_MASK_NONE;\r\nunsigned long flags;\r\nint i;\r\ncpumask_and(&tmp, cpumask, cpu_online_mask);\r\nif (cpumask_empty(&tmp))\r\nreturn -EINVAL;\r\nspin_lock_irqsave(&gic_lock, flags);\r\ngic_map_to_vpe(irq, mips_cm_vp_id(cpumask_first(&tmp)));\r\nfor (i = 0; i < NR_CPUS; i++)\r\nclear_bit(irq, pcpu_masks[i].pcpu_mask);\r\nset_bit(irq, pcpu_masks[cpumask_first(&tmp)].pcpu_mask);\r\ncpumask_copy(irq_data_get_affinity_mask(d), cpumask);\r\nspin_unlock_irqrestore(&gic_lock, flags);\r\nreturn IRQ_SET_MASK_OK_NOCOPY;\r\n}\r\nstatic void gic_handle_local_int(bool chained)\r\n{\r\nunsigned long pending, masked;\r\nunsigned int intr, virq;\r\npending = gic_read32(GIC_REG(VPE_LOCAL, GIC_VPE_PEND));\r\nmasked = gic_read32(GIC_REG(VPE_LOCAL, GIC_VPE_MASK));\r\nbitmap_and(&pending, &pending, &masked, GIC_NUM_LOCAL_INTRS);\r\nintr = find_first_bit(&pending, GIC_NUM_LOCAL_INTRS);\r\nwhile (intr != GIC_NUM_LOCAL_INTRS) {\r\nvirq = irq_linear_revmap(gic_irq_domain,\r\nGIC_LOCAL_TO_HWIRQ(intr));\r\nif (chained)\r\ngeneric_handle_irq(virq);\r\nelse\r\ndo_IRQ(virq);\r\nbitmap_clear(&pending, intr, 1);\r\nintr = find_first_bit(&pending, GIC_NUM_LOCAL_INTRS);\r\n}\r\n}\r\nstatic void gic_mask_local_irq(struct irq_data *d)\r\n{\r\nint intr = GIC_HWIRQ_TO_LOCAL(d->hwirq);\r\ngic_write32(GIC_REG(VPE_LOCAL, GIC_VPE_RMASK), 1 << intr);\r\n}\r\nstatic void gic_unmask_local_irq(struct irq_data *d)\r\n{\r\nint intr = GIC_HWIRQ_TO_LOCAL(d->hwirq);\r\ngic_write32(GIC_REG(VPE_LOCAL, GIC_VPE_SMASK), 1 << intr);\r\n}\r\nstatic void gic_mask_local_irq_all_vpes(struct irq_data *d)\r\n{\r\nint intr = GIC_HWIRQ_TO_LOCAL(d->hwirq);\r\nint i;\r\nunsigned long flags;\r\nspin_lock_irqsave(&gic_lock, flags);\r\nfor (i = 0; i < gic_vpes; i++) {\r\ngic_write(GIC_REG(VPE_LOCAL, GIC_VPE_OTHER_ADDR), i);\r\ngic_write32(GIC_REG(VPE_OTHER, GIC_VPE_RMASK), 1 << intr);\r\n}\r\nspin_unlock_irqrestore(&gic_lock, flags);\r\n}\r\nstatic void gic_unmask_local_irq_all_vpes(struct irq_data *d)\r\n{\r\nint intr = GIC_HWIRQ_TO_LOCAL(d->hwirq);\r\nint i;\r\nunsigned long flags;\r\nspin_lock_irqsave(&gic_lock, flags);\r\nfor (i = 0; i < gic_vpes; i++) {\r\ngic_write(GIC_REG(VPE_LOCAL, GIC_VPE_OTHER_ADDR), i);\r\ngic_write32(GIC_REG(VPE_OTHER, GIC_VPE_SMASK), 1 << intr);\r\n}\r\nspin_unlock_irqrestore(&gic_lock, flags);\r\n}\r\nstatic void __gic_irq_dispatch(void)\r\n{\r\ngic_handle_local_int(false);\r\ngic_handle_shared_int(false);\r\n}\r\nstatic void gic_irq_dispatch(struct irq_desc *desc)\r\n{\r\ngic_handle_local_int(true);\r\ngic_handle_shared_int(true);\r\n}\r\nunsigned int plat_ipi_resched_int_xlate(unsigned int cpu)\r\n{\r\nreturn gic_resched_int_base + cpu;\r\n}\r\nunsigned int plat_ipi_call_int_xlate(unsigned int cpu)\r\n{\r\nreturn gic_call_int_base + cpu;\r\n}\r\nstatic irqreturn_t ipi_resched_interrupt(int irq, void *dev_id)\r\n{\r\nscheduler_ipi();\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic irqreturn_t ipi_call_interrupt(int irq, void *dev_id)\r\n{\r\ngeneric_smp_call_function_interrupt();\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic __init void gic_ipi_init_one(unsigned int intr, int cpu,\r\nstruct irqaction *action)\r\n{\r\nint virq = irq_create_mapping(gic_irq_domain,\r\nGIC_SHARED_TO_HWIRQ(intr));\r\nint i;\r\ngic_map_to_vpe(intr, mips_cm_vp_id(cpu));\r\nfor (i = 0; i < NR_CPUS; i++)\r\nclear_bit(intr, pcpu_masks[i].pcpu_mask);\r\nset_bit(intr, pcpu_masks[cpu].pcpu_mask);\r\nirq_set_irq_type(virq, IRQ_TYPE_EDGE_RISING);\r\nirq_set_handler(virq, handle_percpu_irq);\r\nsetup_irq(virq, action);\r\n}\r\nstatic __init void gic_ipi_init(void)\r\n{\r\nint i;\r\ngic_resched_int_base = gic_shared_intrs - nr_cpu_ids;\r\ngic_call_int_base = gic_resched_int_base - nr_cpu_ids;\r\nfor (i = 0; i < nr_cpu_ids; i++) {\r\ngic_ipi_init_one(gic_call_int_base + i, i, &irq_call);\r\ngic_ipi_init_one(gic_resched_int_base + i, i, &irq_resched);\r\n}\r\n}\r\nstatic inline void gic_ipi_init(void)\r\n{\r\n}\r\nstatic void __init gic_basic_init(void)\r\n{\r\nunsigned int i;\r\nboard_bind_eic_interrupt = &gic_bind_eic_interrupt;\r\nfor (i = 0; i < gic_shared_intrs; i++) {\r\ngic_set_polarity(i, GIC_POL_POS);\r\ngic_set_trigger(i, GIC_TRIG_LEVEL);\r\ngic_reset_mask(i);\r\n}\r\nfor (i = 0; i < gic_vpes; i++) {\r\nunsigned int j;\r\ngic_write(GIC_REG(VPE_LOCAL, GIC_VPE_OTHER_ADDR), i);\r\nfor (j = 0; j < GIC_NUM_LOCAL_INTRS; j++) {\r\nif (!gic_local_irq_is_routable(j))\r\ncontinue;\r\ngic_write32(GIC_REG(VPE_OTHER, GIC_VPE_RMASK), 1 << j);\r\n}\r\n}\r\n}\r\nstatic int gic_local_irq_domain_map(struct irq_domain *d, unsigned int virq,\r\nirq_hw_number_t hw)\r\n{\r\nint intr = GIC_HWIRQ_TO_LOCAL(hw);\r\nint ret = 0;\r\nint i;\r\nunsigned long flags;\r\nif (!gic_local_irq_is_routable(intr))\r\nreturn -EPERM;\r\nswitch (intr) {\r\ncase GIC_LOCAL_INT_TIMER:\r\ncase GIC_LOCAL_INT_PERFCTR:\r\ncase GIC_LOCAL_INT_FDC:\r\nirq_set_chip_and_handler(virq,\r\n&gic_all_vpes_local_irq_controller,\r\nhandle_percpu_irq);\r\nbreak;\r\ndefault:\r\nirq_set_chip_and_handler(virq,\r\n&gic_local_irq_controller,\r\nhandle_percpu_devid_irq);\r\nirq_set_percpu_devid(virq);\r\nbreak;\r\n}\r\nspin_lock_irqsave(&gic_lock, flags);\r\nfor (i = 0; i < gic_vpes; i++) {\r\nu32 val = GIC_MAP_TO_PIN_MSK | gic_cpu_pin;\r\ngic_write(GIC_REG(VPE_LOCAL, GIC_VPE_OTHER_ADDR), i);\r\nswitch (intr) {\r\ncase GIC_LOCAL_INT_WD:\r\ngic_write32(GIC_REG(VPE_OTHER, GIC_VPE_WD_MAP), val);\r\nbreak;\r\ncase GIC_LOCAL_INT_COMPARE:\r\ngic_write32(GIC_REG(VPE_OTHER, GIC_VPE_COMPARE_MAP),\r\nval);\r\nbreak;\r\ncase GIC_LOCAL_INT_TIMER:\r\nval = GIC_MAP_TO_PIN_MSK | timer_cpu_pin;\r\ngic_write32(GIC_REG(VPE_OTHER, GIC_VPE_TIMER_MAP),\r\nval);\r\nbreak;\r\ncase GIC_LOCAL_INT_PERFCTR:\r\ngic_write32(GIC_REG(VPE_OTHER, GIC_VPE_PERFCTR_MAP),\r\nval);\r\nbreak;\r\ncase GIC_LOCAL_INT_SWINT0:\r\ngic_write32(GIC_REG(VPE_OTHER, GIC_VPE_SWINT0_MAP),\r\nval);\r\nbreak;\r\ncase GIC_LOCAL_INT_SWINT1:\r\ngic_write32(GIC_REG(VPE_OTHER, GIC_VPE_SWINT1_MAP),\r\nval);\r\nbreak;\r\ncase GIC_LOCAL_INT_FDC:\r\ngic_write32(GIC_REG(VPE_OTHER, GIC_VPE_FDC_MAP), val);\r\nbreak;\r\ndefault:\r\npr_err("Invalid local IRQ %d\n", intr);\r\nret = -EINVAL;\r\nbreak;\r\n}\r\n}\r\nspin_unlock_irqrestore(&gic_lock, flags);\r\nreturn ret;\r\n}\r\nstatic int gic_shared_irq_domain_map(struct irq_domain *d, unsigned int virq,\r\nirq_hw_number_t hw)\r\n{\r\nint intr = GIC_HWIRQ_TO_SHARED(hw);\r\nunsigned long flags;\r\nirq_set_chip_and_handler(virq, &gic_level_irq_controller,\r\nhandle_level_irq);\r\nspin_lock_irqsave(&gic_lock, flags);\r\ngic_map_to_pin(intr, gic_cpu_pin);\r\ngic_map_to_vpe(intr, 0);\r\nset_bit(intr, pcpu_masks[0].pcpu_mask);\r\nspin_unlock_irqrestore(&gic_lock, flags);\r\nreturn 0;\r\n}\r\nstatic int gic_irq_domain_map(struct irq_domain *d, unsigned int virq,\r\nirq_hw_number_t hw)\r\n{\r\nif (GIC_HWIRQ_TO_LOCAL(hw) < GIC_NUM_LOCAL_INTRS)\r\nreturn gic_local_irq_domain_map(d, virq, hw);\r\nreturn gic_shared_irq_domain_map(d, virq, hw);\r\n}\r\nstatic int gic_irq_domain_xlate(struct irq_domain *d, struct device_node *ctrlr,\r\nconst u32 *intspec, unsigned int intsize,\r\nirq_hw_number_t *out_hwirq,\r\nunsigned int *out_type)\r\n{\r\nif (intsize != 3)\r\nreturn -EINVAL;\r\nif (intspec[0] == GIC_SHARED)\r\n*out_hwirq = GIC_SHARED_TO_HWIRQ(intspec[1]);\r\nelse if (intspec[0] == GIC_LOCAL)\r\n*out_hwirq = GIC_LOCAL_TO_HWIRQ(intspec[1]);\r\nelse\r\nreturn -EINVAL;\r\n*out_type = intspec[2] & IRQ_TYPE_SENSE_MASK;\r\nreturn 0;\r\n}\r\nstatic void __init __gic_init(unsigned long gic_base_addr,\r\nunsigned long gic_addrspace_size,\r\nunsigned int cpu_vec, unsigned int irqbase,\r\nstruct device_node *node)\r\n{\r\nunsigned int gicconfig;\r\n__gic_base_addr = gic_base_addr;\r\ngic_base = ioremap_nocache(gic_base_addr, gic_addrspace_size);\r\ngicconfig = gic_read(GIC_REG(SHARED, GIC_SH_CONFIG));\r\ngic_shared_intrs = (gicconfig & GIC_SH_CONFIG_NUMINTRS_MSK) >>\r\nGIC_SH_CONFIG_NUMINTRS_SHF;\r\ngic_shared_intrs = ((gic_shared_intrs + 1) * 8);\r\ngic_vpes = (gicconfig & GIC_SH_CONFIG_NUMVPES_MSK) >>\r\nGIC_SH_CONFIG_NUMVPES_SHF;\r\ngic_vpes = gic_vpes + 1;\r\nif (cpu_has_veic) {\r\ngic_cpu_pin = 0;\r\ntimer_cpu_pin = gic_cpu_pin;\r\nset_vi_handler(gic_cpu_pin + GIC_PIN_TO_VEC_OFFSET,\r\n__gic_irq_dispatch);\r\n} else {\r\ngic_cpu_pin = cpu_vec - GIC_CPU_PIN_OFFSET;\r\nirq_set_chained_handler(MIPS_CPU_IRQ_BASE + cpu_vec,\r\ngic_irq_dispatch);\r\nif (IS_ENABLED(CONFIG_MIPS_CMP) &&\r\ngic_local_irq_is_routable(GIC_LOCAL_INT_TIMER)) {\r\ntimer_cpu_pin = gic_read32(GIC_REG(VPE_LOCAL,\r\nGIC_VPE_TIMER_MAP)) &\r\nGIC_MAP_MSK;\r\nirq_set_chained_handler(MIPS_CPU_IRQ_BASE +\r\nGIC_CPU_PIN_OFFSET +\r\ntimer_cpu_pin,\r\ngic_irq_dispatch);\r\n} else {\r\ntimer_cpu_pin = gic_cpu_pin;\r\n}\r\n}\r\ngic_irq_domain = irq_domain_add_simple(node, GIC_NUM_LOCAL_INTRS +\r\ngic_shared_intrs, irqbase,\r\n&gic_irq_domain_ops, NULL);\r\nif (!gic_irq_domain)\r\npanic("Failed to add GIC IRQ domain");\r\ngic_basic_init();\r\ngic_ipi_init();\r\n}\r\nvoid __init gic_init(unsigned long gic_base_addr,\r\nunsigned long gic_addrspace_size,\r\nunsigned int cpu_vec, unsigned int irqbase)\r\n{\r\n__gic_init(gic_base_addr, gic_addrspace_size, cpu_vec, irqbase, NULL);\r\n}\r\nstatic int __init gic_of_init(struct device_node *node,\r\nstruct device_node *parent)\r\n{\r\nstruct resource res;\r\nunsigned int cpu_vec, i = 0, reserved = 0;\r\nphys_addr_t gic_base;\r\nsize_t gic_len;\r\nwhile (!of_property_read_u32_index(node, "mti,reserved-cpu-vectors",\r\ni++, &cpu_vec))\r\nreserved |= BIT(cpu_vec);\r\nfor (cpu_vec = 2; cpu_vec < 8; cpu_vec++) {\r\nif (!(reserved & BIT(cpu_vec)))\r\nbreak;\r\n}\r\nif (cpu_vec == 8) {\r\npr_err("No CPU vectors available for GIC\n");\r\nreturn -ENODEV;\r\n}\r\nif (of_address_to_resource(node, 0, &res)) {\r\nif (mips_cm_present()) {\r\ngic_base = read_gcr_gic_base() &\r\n~CM_GCR_GIC_BASE_GICEN_MSK;\r\ngic_len = 0x20000;\r\n} else {\r\npr_err("Failed to get GIC memory range\n");\r\nreturn -ENODEV;\r\n}\r\n} else {\r\ngic_base = res.start;\r\ngic_len = resource_size(&res);\r\n}\r\nif (mips_cm_present())\r\nwrite_gcr_gic_base(gic_base | CM_GCR_GIC_BASE_GICEN_MSK);\r\ngic_present = true;\r\n__gic_init(gic_base, gic_len, cpu_vec, 0, node);\r\nreturn 0;\r\n}
