static irqreturn_t bcm_iproc_i2c_isr(int irq, void *data)\r\n{\r\nstruct bcm_iproc_i2c_dev *iproc_i2c = data;\r\nu32 status = readl(iproc_i2c->base + IS_OFFSET);\r\nstatus &= ISR_MASK;\r\nif (!status)\r\nreturn IRQ_NONE;\r\nwritel(status, iproc_i2c->base + IS_OFFSET);\r\niproc_i2c->xfer_is_done = 1;\r\ncomplete_all(&iproc_i2c->done);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int bcm_iproc_i2c_check_status(struct bcm_iproc_i2c_dev *iproc_i2c,\r\nstruct i2c_msg *msg)\r\n{\r\nu32 val;\r\nval = readl(iproc_i2c->base + M_CMD_OFFSET);\r\nval = (val >> M_CMD_STATUS_SHIFT) & M_CMD_STATUS_MASK;\r\nswitch (val) {\r\ncase M_CMD_STATUS_SUCCESS:\r\nreturn 0;\r\ncase M_CMD_STATUS_LOST_ARB:\r\ndev_dbg(iproc_i2c->device, "lost bus arbitration\n");\r\nreturn -EAGAIN;\r\ncase M_CMD_STATUS_NACK_ADDR:\r\ndev_dbg(iproc_i2c->device, "NAK addr:0x%02x\n", msg->addr);\r\nreturn -ENXIO;\r\ncase M_CMD_STATUS_NACK_DATA:\r\ndev_dbg(iproc_i2c->device, "NAK data\n");\r\nreturn -ENXIO;\r\ncase M_CMD_STATUS_TIMEOUT:\r\ndev_dbg(iproc_i2c->device, "bus timeout\n");\r\nreturn -ETIMEDOUT;\r\ndefault:\r\ndev_dbg(iproc_i2c->device, "unknown error code=%d\n", val);\r\nreturn -EIO;\r\n}\r\n}\r\nstatic int bcm_iproc_i2c_xfer_single_msg(struct bcm_iproc_i2c_dev *iproc_i2c,\r\nstruct i2c_msg *msg)\r\n{\r\nint ret, i;\r\nu8 addr;\r\nu32 val;\r\nunsigned long time_left = msecs_to_jiffies(I2C_TIMEOUT_MESC);\r\nif (!!(readl(iproc_i2c->base + M_CMD_OFFSET) &\r\nBIT(M_CMD_START_BUSY_SHIFT))) {\r\ndev_warn(iproc_i2c->device, "bus is busy\n");\r\nreturn -EBUSY;\r\n}\r\naddr = msg->addr << 1 | (msg->flags & I2C_M_RD ? 1 : 0);\r\nwritel(addr, iproc_i2c->base + M_TX_OFFSET);\r\nif (!(msg->flags & I2C_M_RD)) {\r\nfor (i = 0; i < msg->len; i++) {\r\nval = msg->buf[i];\r\nif (i == msg->len - 1)\r\nval |= 1 << M_TX_WR_STATUS_SHIFT;\r\nwritel(val, iproc_i2c->base + M_TX_OFFSET);\r\n}\r\n}\r\nreinit_completion(&iproc_i2c->done);\r\niproc_i2c->xfer_is_done = 0;\r\nwritel(1 << IE_M_START_BUSY_SHIFT, iproc_i2c->base + IE_OFFSET);\r\nval = 1 << M_CMD_START_BUSY_SHIFT;\r\nif (msg->flags & I2C_M_RD) {\r\nval |= (M_CMD_PROTOCOL_BLK_RD << M_CMD_PROTOCOL_SHIFT) |\r\n(msg->len << M_CMD_RD_CNT_SHIFT);\r\n} else {\r\nval |= (M_CMD_PROTOCOL_BLK_WR << M_CMD_PROTOCOL_SHIFT);\r\n}\r\nwritel(val, iproc_i2c->base + M_CMD_OFFSET);\r\ntime_left = wait_for_completion_timeout(&iproc_i2c->done, time_left);\r\nwritel(0, iproc_i2c->base + IE_OFFSET);\r\nreadl(iproc_i2c->base + IE_OFFSET);\r\nsynchronize_irq(iproc_i2c->irq);\r\nif (!time_left && !iproc_i2c->xfer_is_done) {\r\ndev_err(iproc_i2c->device, "transaction timed out\n");\r\nval = (1 << M_FIFO_RX_FLUSH_SHIFT) |\r\n(1 << M_FIFO_TX_FLUSH_SHIFT);\r\nwritel(val, iproc_i2c->base + M_FIFO_CTRL_OFFSET);\r\nreturn -ETIMEDOUT;\r\n}\r\nret = bcm_iproc_i2c_check_status(iproc_i2c, msg);\r\nif (ret) {\r\nval = (1 << M_FIFO_RX_FLUSH_SHIFT) |\r\n(1 << M_FIFO_TX_FLUSH_SHIFT);\r\nwritel(val, iproc_i2c->base + M_FIFO_CTRL_OFFSET);\r\nreturn ret;\r\n}\r\nif (msg->flags & I2C_M_RD) {\r\nfor (i = 0; i < msg->len; i++) {\r\nmsg->buf[i] = (readl(iproc_i2c->base + M_RX_OFFSET) >>\r\nM_RX_DATA_SHIFT) & M_RX_DATA_MASK;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int bcm_iproc_i2c_xfer(struct i2c_adapter *adapter,\r\nstruct i2c_msg msgs[], int num)\r\n{\r\nstruct bcm_iproc_i2c_dev *iproc_i2c = i2c_get_adapdata(adapter);\r\nint ret, i;\r\nfor (i = 0; i < num; i++) {\r\nret = bcm_iproc_i2c_xfer_single_msg(iproc_i2c, &msgs[i]);\r\nif (ret) {\r\ndev_dbg(iproc_i2c->device, "xfer failed\n");\r\nreturn ret;\r\n}\r\n}\r\nreturn num;\r\n}\r\nstatic uint32_t bcm_iproc_i2c_functionality(struct i2c_adapter *adap)\r\n{\r\nreturn I2C_FUNC_I2C | I2C_FUNC_SMBUS_EMUL;\r\n}\r\nstatic int bcm_iproc_i2c_cfg_speed(struct bcm_iproc_i2c_dev *iproc_i2c)\r\n{\r\nunsigned int bus_speed;\r\nu32 val;\r\nint ret = of_property_read_u32(iproc_i2c->device->of_node,\r\n"clock-frequency", &bus_speed);\r\nif (ret < 0) {\r\ndev_info(iproc_i2c->device,\r\n"unable to interpret clock-frequency DT property\n");\r\nbus_speed = 100000;\r\n}\r\nif (bus_speed < 100000) {\r\ndev_err(iproc_i2c->device, "%d Hz bus speed not supported\n",\r\nbus_speed);\r\ndev_err(iproc_i2c->device,\r\n"valid speeds are 100khz and 400khz\n");\r\nreturn -EINVAL;\r\n} else if (bus_speed < 400000) {\r\nbus_speed = 100000;\r\n} else {\r\nbus_speed = 400000;\r\n}\r\niproc_i2c->bus_speed = bus_speed;\r\nval = readl(iproc_i2c->base + TIM_CFG_OFFSET);\r\nval &= ~(1 << TIM_CFG_MODE_400_SHIFT);\r\nval |= (bus_speed == 400000) << TIM_CFG_MODE_400_SHIFT;\r\nwritel(val, iproc_i2c->base + TIM_CFG_OFFSET);\r\ndev_info(iproc_i2c->device, "bus set to %u Hz\n", bus_speed);\r\nreturn 0;\r\n}\r\nstatic int bcm_iproc_i2c_init(struct bcm_iproc_i2c_dev *iproc_i2c)\r\n{\r\nu32 val;\r\nval = readl(iproc_i2c->base + CFG_OFFSET);\r\nval |= 1 << CFG_RESET_SHIFT;\r\nval &= ~(1 << CFG_EN_SHIFT);\r\nwritel(val, iproc_i2c->base + CFG_OFFSET);\r\nudelay(100);\r\nval &= ~(1 << CFG_RESET_SHIFT);\r\nwritel(val, iproc_i2c->base + CFG_OFFSET);\r\nval = (1 << M_FIFO_RX_FLUSH_SHIFT) | (1 << M_FIFO_TX_FLUSH_SHIFT);\r\nwritel(val, iproc_i2c->base + M_FIFO_CTRL_OFFSET);\r\nwritel(0, iproc_i2c->base + IE_OFFSET);\r\nwritel(0xffffffff, iproc_i2c->base + IS_OFFSET);\r\nreturn 0;\r\n}\r\nstatic void bcm_iproc_i2c_enable_disable(struct bcm_iproc_i2c_dev *iproc_i2c,\r\nbool enable)\r\n{\r\nu32 val;\r\nval = readl(iproc_i2c->base + CFG_OFFSET);\r\nif (enable)\r\nval |= BIT(CFG_EN_SHIFT);\r\nelse\r\nval &= ~BIT(CFG_EN_SHIFT);\r\nwritel(val, iproc_i2c->base + CFG_OFFSET);\r\n}\r\nstatic int bcm_iproc_i2c_probe(struct platform_device *pdev)\r\n{\r\nint irq, ret = 0;\r\nstruct bcm_iproc_i2c_dev *iproc_i2c;\r\nstruct i2c_adapter *adap;\r\nstruct resource *res;\r\niproc_i2c = devm_kzalloc(&pdev->dev, sizeof(*iproc_i2c),\r\nGFP_KERNEL);\r\nif (!iproc_i2c)\r\nreturn -ENOMEM;\r\nplatform_set_drvdata(pdev, iproc_i2c);\r\niproc_i2c->device = &pdev->dev;\r\ninit_completion(&iproc_i2c->done);\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\niproc_i2c->base = devm_ioremap_resource(iproc_i2c->device, res);\r\nif (IS_ERR(iproc_i2c->base))\r\nreturn PTR_ERR(iproc_i2c->base);\r\nret = bcm_iproc_i2c_init(iproc_i2c);\r\nif (ret)\r\nreturn ret;\r\nret = bcm_iproc_i2c_cfg_speed(iproc_i2c);\r\nif (ret)\r\nreturn ret;\r\nirq = platform_get_irq(pdev, 0);\r\nif (irq <= 0) {\r\ndev_err(iproc_i2c->device, "no irq resource\n");\r\nreturn irq;\r\n}\r\niproc_i2c->irq = irq;\r\nret = devm_request_irq(iproc_i2c->device, irq, bcm_iproc_i2c_isr, 0,\r\npdev->name, iproc_i2c);\r\nif (ret < 0) {\r\ndev_err(iproc_i2c->device, "unable to request irq %i\n", irq);\r\nreturn ret;\r\n}\r\nbcm_iproc_i2c_enable_disable(iproc_i2c, true);\r\nadap = &iproc_i2c->adapter;\r\ni2c_set_adapdata(adap, iproc_i2c);\r\nstrlcpy(adap->name, "Broadcom iProc I2C adapter", sizeof(adap->name));\r\nadap->algo = &bcm_iproc_algo;\r\nadap->quirks = &bcm_iproc_i2c_quirks;\r\nadap->dev.parent = &pdev->dev;\r\nadap->dev.of_node = pdev->dev.of_node;\r\nret = i2c_add_adapter(adap);\r\nif (ret) {\r\ndev_err(iproc_i2c->device, "failed to add adapter\n");\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic int bcm_iproc_i2c_remove(struct platform_device *pdev)\r\n{\r\nstruct bcm_iproc_i2c_dev *iproc_i2c = platform_get_drvdata(pdev);\r\nwritel(0, iproc_i2c->base + IE_OFFSET);\r\nreadl(iproc_i2c->base + IE_OFFSET);\r\nsynchronize_irq(iproc_i2c->irq);\r\ni2c_del_adapter(&iproc_i2c->adapter);\r\nbcm_iproc_i2c_enable_disable(iproc_i2c, false);\r\nreturn 0;\r\n}\r\nstatic int bcm_iproc_i2c_suspend(struct device *dev)\r\n{\r\nstruct platform_device *pdev = to_platform_device(dev);\r\nstruct bcm_iproc_i2c_dev *iproc_i2c = platform_get_drvdata(pdev);\r\nwritel(0, iproc_i2c->base + IE_OFFSET);\r\nreadl(iproc_i2c->base + IE_OFFSET);\r\nsynchronize_irq(iproc_i2c->irq);\r\nbcm_iproc_i2c_enable_disable(iproc_i2c, false);\r\nreturn 0;\r\n}\r\nstatic int bcm_iproc_i2c_resume(struct device *dev)\r\n{\r\nstruct platform_device *pdev = to_platform_device(dev);\r\nstruct bcm_iproc_i2c_dev *iproc_i2c = platform_get_drvdata(pdev);\r\nint ret;\r\nu32 val;\r\nret = bcm_iproc_i2c_init(iproc_i2c);\r\nif (ret)\r\nreturn ret;\r\nval = readl(iproc_i2c->base + TIM_CFG_OFFSET);\r\nval &= ~(1 << TIM_CFG_MODE_400_SHIFT);\r\nval |= (iproc_i2c->bus_speed == 400000) << TIM_CFG_MODE_400_SHIFT;\r\nwritel(val, iproc_i2c->base + TIM_CFG_OFFSET);\r\nbcm_iproc_i2c_enable_disable(iproc_i2c, true);\r\nreturn 0;\r\n}
