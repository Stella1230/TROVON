static void tmc_wait_for_ready(struct tmc_drvdata *drvdata)\r\n{\r\nif (coresight_timeout(drvdata->base,\r\nTMC_STS, TMC_STS_TRIGGERED_BIT, 1)) {\r\ndev_err(drvdata->dev,\r\n"timeout observed when probing at offset %#x\n",\r\nTMC_STS);\r\n}\r\n}\r\nstatic void tmc_flush_and_stop(struct tmc_drvdata *drvdata)\r\n{\r\nu32 ffcr;\r\nffcr = readl_relaxed(drvdata->base + TMC_FFCR);\r\nffcr |= TMC_FFCR_STOP_ON_FLUSH;\r\nwritel_relaxed(ffcr, drvdata->base + TMC_FFCR);\r\nffcr |= TMC_FFCR_FLUSHMAN;\r\nwritel_relaxed(ffcr, drvdata->base + TMC_FFCR);\r\nif (coresight_timeout(drvdata->base,\r\nTMC_FFCR, TMC_FFCR_FLUSHMAN_BIT, 0)) {\r\ndev_err(drvdata->dev,\r\n"timeout observed when probing at offset %#x\n",\r\nTMC_FFCR);\r\n}\r\ntmc_wait_for_ready(drvdata);\r\n}\r\nstatic void tmc_enable_hw(struct tmc_drvdata *drvdata)\r\n{\r\nwritel_relaxed(TMC_CTL_CAPT_EN, drvdata->base + TMC_CTL);\r\n}\r\nstatic void tmc_disable_hw(struct tmc_drvdata *drvdata)\r\n{\r\nwritel_relaxed(0x0, drvdata->base + TMC_CTL);\r\n}\r\nstatic void tmc_etb_enable_hw(struct tmc_drvdata *drvdata)\r\n{\r\nmemset(drvdata->buf, 0, drvdata->size);\r\nCS_UNLOCK(drvdata->base);\r\nwritel_relaxed(TMC_MODE_CIRCULAR_BUFFER, drvdata->base + TMC_MODE);\r\nwritel_relaxed(TMC_FFCR_EN_FMT | TMC_FFCR_EN_TI |\r\nTMC_FFCR_FON_FLIN | TMC_FFCR_FON_TRIG_EVT |\r\nTMC_FFCR_TRIGON_TRIGIN,\r\ndrvdata->base + TMC_FFCR);\r\nwritel_relaxed(drvdata->trigger_cntr, drvdata->base + TMC_TRG);\r\ntmc_enable_hw(drvdata);\r\nCS_LOCK(drvdata->base);\r\n}\r\nstatic void tmc_etr_enable_hw(struct tmc_drvdata *drvdata)\r\n{\r\nu32 axictl;\r\nmemset(drvdata->vaddr, 0, drvdata->size);\r\nCS_UNLOCK(drvdata->base);\r\nwritel_relaxed(drvdata->size / 4, drvdata->base + TMC_RSZ);\r\nwritel_relaxed(TMC_MODE_CIRCULAR_BUFFER, drvdata->base + TMC_MODE);\r\naxictl = readl_relaxed(drvdata->base + TMC_AXICTL);\r\naxictl |= TMC_AXICTL_WR_BURST_LEN;\r\nwritel_relaxed(axictl, drvdata->base + TMC_AXICTL);\r\naxictl &= ~TMC_AXICTL_SCT_GAT_MODE;\r\nwritel_relaxed(axictl, drvdata->base + TMC_AXICTL);\r\naxictl = (axictl &\r\n~(TMC_AXICTL_PROT_CTL_B0 | TMC_AXICTL_PROT_CTL_B1)) |\r\nTMC_AXICTL_PROT_CTL_B1;\r\nwritel_relaxed(axictl, drvdata->base + TMC_AXICTL);\r\nwritel_relaxed(drvdata->paddr, drvdata->base + TMC_DBALO);\r\nwritel_relaxed(0x0, drvdata->base + TMC_DBAHI);\r\nwritel_relaxed(TMC_FFCR_EN_FMT | TMC_FFCR_EN_TI |\r\nTMC_FFCR_FON_FLIN | TMC_FFCR_FON_TRIG_EVT |\r\nTMC_FFCR_TRIGON_TRIGIN,\r\ndrvdata->base + TMC_FFCR);\r\nwritel_relaxed(drvdata->trigger_cntr, drvdata->base + TMC_TRG);\r\ntmc_enable_hw(drvdata);\r\nCS_LOCK(drvdata->base);\r\n}\r\nstatic void tmc_etf_enable_hw(struct tmc_drvdata *drvdata)\r\n{\r\nCS_UNLOCK(drvdata->base);\r\nwritel_relaxed(TMC_MODE_HARDWARE_FIFO, drvdata->base + TMC_MODE);\r\nwritel_relaxed(TMC_FFCR_EN_FMT | TMC_FFCR_EN_TI,\r\ndrvdata->base + TMC_FFCR);\r\nwritel_relaxed(0x0, drvdata->base + TMC_BUFWM);\r\ntmc_enable_hw(drvdata);\r\nCS_LOCK(drvdata->base);\r\n}\r\nstatic int tmc_enable(struct tmc_drvdata *drvdata, enum tmc_mode mode)\r\n{\r\nunsigned long flags;\r\npm_runtime_get_sync(drvdata->dev);\r\nspin_lock_irqsave(&drvdata->spinlock, flags);\r\nif (drvdata->reading) {\r\nspin_unlock_irqrestore(&drvdata->spinlock, flags);\r\npm_runtime_put(drvdata->dev);\r\nreturn -EBUSY;\r\n}\r\nif (drvdata->config_type == TMC_CONFIG_TYPE_ETB) {\r\ntmc_etb_enable_hw(drvdata);\r\n} else if (drvdata->config_type == TMC_CONFIG_TYPE_ETR) {\r\ntmc_etr_enable_hw(drvdata);\r\n} else {\r\nif (mode == TMC_MODE_CIRCULAR_BUFFER)\r\ntmc_etb_enable_hw(drvdata);\r\nelse\r\ntmc_etf_enable_hw(drvdata);\r\n}\r\ndrvdata->enable = true;\r\nspin_unlock_irqrestore(&drvdata->spinlock, flags);\r\ndev_info(drvdata->dev, "TMC enabled\n");\r\nreturn 0;\r\n}\r\nstatic int tmc_enable_sink(struct coresight_device *csdev)\r\n{\r\nstruct tmc_drvdata *drvdata = dev_get_drvdata(csdev->dev.parent);\r\nreturn tmc_enable(drvdata, TMC_MODE_CIRCULAR_BUFFER);\r\n}\r\nstatic int tmc_enable_link(struct coresight_device *csdev, int inport,\r\nint outport)\r\n{\r\nstruct tmc_drvdata *drvdata = dev_get_drvdata(csdev->dev.parent);\r\nreturn tmc_enable(drvdata, TMC_MODE_HARDWARE_FIFO);\r\n}\r\nstatic void tmc_etb_dump_hw(struct tmc_drvdata *drvdata)\r\n{\r\nenum tmc_mem_intf_width memwidth;\r\nu8 memwords;\r\nchar *bufp;\r\nu32 read_data;\r\nint i;\r\nmemwidth = BMVAL(readl_relaxed(drvdata->base + CORESIGHT_DEVID), 8, 10);\r\nif (memwidth == TMC_MEM_INTF_WIDTH_32BITS)\r\nmemwords = 1;\r\nelse if (memwidth == TMC_MEM_INTF_WIDTH_64BITS)\r\nmemwords = 2;\r\nelse if (memwidth == TMC_MEM_INTF_WIDTH_128BITS)\r\nmemwords = 4;\r\nelse\r\nmemwords = 8;\r\nbufp = drvdata->buf;\r\nwhile (1) {\r\nfor (i = 0; i < memwords; i++) {\r\nread_data = readl_relaxed(drvdata->base + TMC_RRD);\r\nif (read_data == 0xFFFFFFFF)\r\nreturn;\r\nmemcpy(bufp, &read_data, 4);\r\nbufp += 4;\r\n}\r\n}\r\n}\r\nstatic void tmc_etb_disable_hw(struct tmc_drvdata *drvdata)\r\n{\r\nCS_UNLOCK(drvdata->base);\r\ntmc_flush_and_stop(drvdata);\r\ntmc_etb_dump_hw(drvdata);\r\ntmc_disable_hw(drvdata);\r\nCS_LOCK(drvdata->base);\r\n}\r\nstatic void tmc_etr_dump_hw(struct tmc_drvdata *drvdata)\r\n{\r\nu32 rwp, val;\r\nrwp = readl_relaxed(drvdata->base + TMC_RWP);\r\nval = readl_relaxed(drvdata->base + TMC_STS);\r\nif (val & BIT(0))\r\ndrvdata->buf = drvdata->vaddr + rwp - drvdata->paddr;\r\nelse\r\ndrvdata->buf = drvdata->vaddr;\r\n}\r\nstatic void tmc_etr_disable_hw(struct tmc_drvdata *drvdata)\r\n{\r\nCS_UNLOCK(drvdata->base);\r\ntmc_flush_and_stop(drvdata);\r\ntmc_etr_dump_hw(drvdata);\r\ntmc_disable_hw(drvdata);\r\nCS_LOCK(drvdata->base);\r\n}\r\nstatic void tmc_etf_disable_hw(struct tmc_drvdata *drvdata)\r\n{\r\nCS_UNLOCK(drvdata->base);\r\ntmc_flush_and_stop(drvdata);\r\ntmc_disable_hw(drvdata);\r\nCS_LOCK(drvdata->base);\r\n}\r\nstatic void tmc_disable(struct tmc_drvdata *drvdata, enum tmc_mode mode)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&drvdata->spinlock, flags);\r\nif (drvdata->reading)\r\ngoto out;\r\nif (drvdata->config_type == TMC_CONFIG_TYPE_ETB) {\r\ntmc_etb_disable_hw(drvdata);\r\n} else if (drvdata->config_type == TMC_CONFIG_TYPE_ETR) {\r\ntmc_etr_disable_hw(drvdata);\r\n} else {\r\nif (mode == TMC_MODE_CIRCULAR_BUFFER)\r\ntmc_etb_disable_hw(drvdata);\r\nelse\r\ntmc_etf_disable_hw(drvdata);\r\n}\r\nout:\r\ndrvdata->enable = false;\r\nspin_unlock_irqrestore(&drvdata->spinlock, flags);\r\npm_runtime_put(drvdata->dev);\r\ndev_info(drvdata->dev, "TMC disabled\n");\r\n}\r\nstatic void tmc_disable_sink(struct coresight_device *csdev)\r\n{\r\nstruct tmc_drvdata *drvdata = dev_get_drvdata(csdev->dev.parent);\r\ntmc_disable(drvdata, TMC_MODE_CIRCULAR_BUFFER);\r\n}\r\nstatic void tmc_disable_link(struct coresight_device *csdev, int inport,\r\nint outport)\r\n{\r\nstruct tmc_drvdata *drvdata = dev_get_drvdata(csdev->dev.parent);\r\ntmc_disable(drvdata, TMC_MODE_HARDWARE_FIFO);\r\n}\r\nstatic int tmc_read_prepare(struct tmc_drvdata *drvdata)\r\n{\r\nint ret;\r\nunsigned long flags;\r\nenum tmc_mode mode;\r\nspin_lock_irqsave(&drvdata->spinlock, flags);\r\nif (!drvdata->enable)\r\ngoto out;\r\nif (drvdata->config_type == TMC_CONFIG_TYPE_ETB) {\r\ntmc_etb_disable_hw(drvdata);\r\n} else if (drvdata->config_type == TMC_CONFIG_TYPE_ETR) {\r\ntmc_etr_disable_hw(drvdata);\r\n} else {\r\nmode = readl_relaxed(drvdata->base + TMC_MODE);\r\nif (mode == TMC_MODE_CIRCULAR_BUFFER) {\r\ntmc_etb_disable_hw(drvdata);\r\n} else {\r\nret = -ENODEV;\r\ngoto err;\r\n}\r\n}\r\nout:\r\ndrvdata->reading = true;\r\nspin_unlock_irqrestore(&drvdata->spinlock, flags);\r\ndev_info(drvdata->dev, "TMC read start\n");\r\nreturn 0;\r\nerr:\r\nspin_unlock_irqrestore(&drvdata->spinlock, flags);\r\nreturn ret;\r\n}\r\nstatic void tmc_read_unprepare(struct tmc_drvdata *drvdata)\r\n{\r\nunsigned long flags;\r\nenum tmc_mode mode;\r\nspin_lock_irqsave(&drvdata->spinlock, flags);\r\nif (!drvdata->enable)\r\ngoto out;\r\nif (drvdata->config_type == TMC_CONFIG_TYPE_ETB) {\r\ntmc_etb_enable_hw(drvdata);\r\n} else if (drvdata->config_type == TMC_CONFIG_TYPE_ETR) {\r\ntmc_etr_enable_hw(drvdata);\r\n} else {\r\nmode = readl_relaxed(drvdata->base + TMC_MODE);\r\nif (mode == TMC_MODE_CIRCULAR_BUFFER)\r\ntmc_etb_enable_hw(drvdata);\r\n}\r\nout:\r\ndrvdata->reading = false;\r\nspin_unlock_irqrestore(&drvdata->spinlock, flags);\r\ndev_info(drvdata->dev, "TMC read end\n");\r\n}\r\nstatic int tmc_open(struct inode *inode, struct file *file)\r\n{\r\nstruct tmc_drvdata *drvdata = container_of(file->private_data,\r\nstruct tmc_drvdata, miscdev);\r\nint ret = 0;\r\nif (drvdata->read_count++)\r\ngoto out;\r\nret = tmc_read_prepare(drvdata);\r\nif (ret)\r\nreturn ret;\r\nout:\r\nnonseekable_open(inode, file);\r\ndev_dbg(drvdata->dev, "%s: successfully opened\n", __func__);\r\nreturn 0;\r\n}\r\nstatic ssize_t tmc_read(struct file *file, char __user *data, size_t len,\r\nloff_t *ppos)\r\n{\r\nstruct tmc_drvdata *drvdata = container_of(file->private_data,\r\nstruct tmc_drvdata, miscdev);\r\nchar *bufp = drvdata->buf + *ppos;\r\nif (*ppos + len > drvdata->size)\r\nlen = drvdata->size - *ppos;\r\nif (drvdata->config_type == TMC_CONFIG_TYPE_ETR) {\r\nif (bufp == (char *)(drvdata->vaddr + drvdata->size))\r\nbufp = drvdata->vaddr;\r\nelse if (bufp > (char *)(drvdata->vaddr + drvdata->size))\r\nbufp -= drvdata->size;\r\nif ((bufp + len) > (char *)(drvdata->vaddr + drvdata->size))\r\nlen = (char *)(drvdata->vaddr + drvdata->size) - bufp;\r\n}\r\nif (copy_to_user(data, bufp, len)) {\r\ndev_dbg(drvdata->dev, "%s: copy_to_user failed\n", __func__);\r\nreturn -EFAULT;\r\n}\r\n*ppos += len;\r\ndev_dbg(drvdata->dev, "%s: %zu bytes copied, %d bytes left\n",\r\n__func__, len, (int)(drvdata->size - *ppos));\r\nreturn len;\r\n}\r\nstatic int tmc_release(struct inode *inode, struct file *file)\r\n{\r\nstruct tmc_drvdata *drvdata = container_of(file->private_data,\r\nstruct tmc_drvdata, miscdev);\r\nif (--drvdata->read_count) {\r\nif (drvdata->read_count < 0) {\r\ndev_err(drvdata->dev, "mismatched close\n");\r\ndrvdata->read_count = 0;\r\n}\r\ngoto out;\r\n}\r\ntmc_read_unprepare(drvdata);\r\nout:\r\ndev_dbg(drvdata->dev, "%s: released\n", __func__);\r\nreturn 0;\r\n}\r\nstatic ssize_t status_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nunsigned long flags;\r\nu32 tmc_rsz, tmc_sts, tmc_rrp, tmc_rwp, tmc_trg;\r\nu32 tmc_ctl, tmc_ffsr, tmc_ffcr, tmc_mode, tmc_pscr;\r\nu32 devid;\r\nstruct tmc_drvdata *drvdata = dev_get_drvdata(dev->parent);\r\npm_runtime_get_sync(drvdata->dev);\r\nspin_lock_irqsave(&drvdata->spinlock, flags);\r\nCS_UNLOCK(drvdata->base);\r\ntmc_rsz = readl_relaxed(drvdata->base + TMC_RSZ);\r\ntmc_sts = readl_relaxed(drvdata->base + TMC_STS);\r\ntmc_rrp = readl_relaxed(drvdata->base + TMC_RRP);\r\ntmc_rwp = readl_relaxed(drvdata->base + TMC_RWP);\r\ntmc_trg = readl_relaxed(drvdata->base + TMC_TRG);\r\ntmc_ctl = readl_relaxed(drvdata->base + TMC_CTL);\r\ntmc_ffsr = readl_relaxed(drvdata->base + TMC_FFSR);\r\ntmc_ffcr = readl_relaxed(drvdata->base + TMC_FFCR);\r\ntmc_mode = readl_relaxed(drvdata->base + TMC_MODE);\r\ntmc_pscr = readl_relaxed(drvdata->base + TMC_PSCR);\r\ndevid = readl_relaxed(drvdata->base + CORESIGHT_DEVID);\r\nCS_LOCK(drvdata->base);\r\nspin_unlock_irqrestore(&drvdata->spinlock, flags);\r\npm_runtime_put(drvdata->dev);\r\nreturn sprintf(buf,\r\n"Depth:\t\t0x%x\n"\r\n"Status:\t\t0x%x\n"\r\n"RAM read ptr:\t0x%x\n"\r\n"RAM wrt ptr:\t0x%x\n"\r\n"Trigger cnt:\t0x%x\n"\r\n"Control:\t0x%x\n"\r\n"Flush status:\t0x%x\n"\r\n"Flush ctrl:\t0x%x\n"\r\n"Mode:\t\t0x%x\n"\r\n"PSRC:\t\t0x%x\n"\r\n"DEVID:\t\t0x%x\n",\r\ntmc_rsz, tmc_sts, tmc_rrp, tmc_rwp, tmc_trg,\r\ntmc_ctl, tmc_ffsr, tmc_ffcr, tmc_mode, tmc_pscr, devid);\r\nreturn -EINVAL;\r\n}\r\nstatic ssize_t trigger_cntr_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct tmc_drvdata *drvdata = dev_get_drvdata(dev->parent);\r\nunsigned long val = drvdata->trigger_cntr;\r\nreturn sprintf(buf, "%#lx\n", val);\r\n}\r\nstatic ssize_t trigger_cntr_store(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t size)\r\n{\r\nint ret;\r\nunsigned long val;\r\nstruct tmc_drvdata *drvdata = dev_get_drvdata(dev->parent);\r\nret = kstrtoul(buf, 16, &val);\r\nif (ret)\r\nreturn ret;\r\ndrvdata->trigger_cntr = val;\r\nreturn size;\r\n}\r\nstatic int tmc_probe(struct amba_device *adev, const struct amba_id *id)\r\n{\r\nint ret = 0;\r\nu32 devid;\r\nvoid __iomem *base;\r\nstruct device *dev = &adev->dev;\r\nstruct coresight_platform_data *pdata = NULL;\r\nstruct tmc_drvdata *drvdata;\r\nstruct resource *res = &adev->res;\r\nstruct coresight_desc *desc;\r\nstruct device_node *np = adev->dev.of_node;\r\nif (np) {\r\npdata = of_get_coresight_platform_data(dev, np);\r\nif (IS_ERR(pdata))\r\nreturn PTR_ERR(pdata);\r\nadev->dev.platform_data = pdata;\r\n}\r\ndrvdata = devm_kzalloc(dev, sizeof(*drvdata), GFP_KERNEL);\r\nif (!drvdata)\r\nreturn -ENOMEM;\r\ndrvdata->dev = &adev->dev;\r\ndev_set_drvdata(dev, drvdata);\r\nbase = devm_ioremap_resource(dev, res);\r\nif (IS_ERR(base))\r\nreturn PTR_ERR(base);\r\ndrvdata->base = base;\r\nspin_lock_init(&drvdata->spinlock);\r\ndevid = readl_relaxed(drvdata->base + CORESIGHT_DEVID);\r\ndrvdata->config_type = BMVAL(devid, 6, 7);\r\nif (drvdata->config_type == TMC_CONFIG_TYPE_ETR) {\r\nif (np)\r\nret = of_property_read_u32(np,\r\n"arm,buffer-size",\r\n&drvdata->size);\r\nif (ret)\r\ndrvdata->size = SZ_1M;\r\n} else {\r\ndrvdata->size = readl_relaxed(drvdata->base + TMC_RSZ) * 4;\r\n}\r\npm_runtime_put(&adev->dev);\r\nif (drvdata->config_type == TMC_CONFIG_TYPE_ETR) {\r\ndrvdata->vaddr = dma_alloc_coherent(dev, drvdata->size,\r\n&drvdata->paddr, GFP_KERNEL);\r\nif (!drvdata->vaddr)\r\nreturn -ENOMEM;\r\nmemset(drvdata->vaddr, 0, drvdata->size);\r\ndrvdata->buf = drvdata->vaddr;\r\n} else {\r\ndrvdata->buf = devm_kzalloc(dev, drvdata->size, GFP_KERNEL);\r\nif (!drvdata->buf)\r\nreturn -ENOMEM;\r\n}\r\ndesc = devm_kzalloc(dev, sizeof(*desc), GFP_KERNEL);\r\nif (!desc) {\r\nret = -ENOMEM;\r\ngoto err_devm_kzalloc;\r\n}\r\ndesc->pdata = pdata;\r\ndesc->dev = dev;\r\ndesc->subtype.sink_subtype = CORESIGHT_DEV_SUBTYPE_SINK_BUFFER;\r\nif (drvdata->config_type == TMC_CONFIG_TYPE_ETB) {\r\ndesc->type = CORESIGHT_DEV_TYPE_SINK;\r\ndesc->ops = &tmc_etb_cs_ops;\r\ndesc->groups = coresight_etb_groups;\r\n} else if (drvdata->config_type == TMC_CONFIG_TYPE_ETR) {\r\ndesc->type = CORESIGHT_DEV_TYPE_SINK;\r\ndesc->ops = &tmc_etr_cs_ops;\r\ndesc->groups = coresight_etr_groups;\r\n} else {\r\ndesc->type = CORESIGHT_DEV_TYPE_LINKSINK;\r\ndesc->subtype.link_subtype = CORESIGHT_DEV_SUBTYPE_LINK_FIFO;\r\ndesc->ops = &tmc_etf_cs_ops;\r\ndesc->groups = coresight_etf_groups;\r\n}\r\ndrvdata->csdev = coresight_register(desc);\r\nif (IS_ERR(drvdata->csdev)) {\r\nret = PTR_ERR(drvdata->csdev);\r\ngoto err_devm_kzalloc;\r\n}\r\ndrvdata->miscdev.name = pdata->name;\r\ndrvdata->miscdev.minor = MISC_DYNAMIC_MINOR;\r\ndrvdata->miscdev.fops = &tmc_fops;\r\nret = misc_register(&drvdata->miscdev);\r\nif (ret)\r\ngoto err_misc_register;\r\ndev_info(dev, "TMC initialized\n");\r\nreturn 0;\r\nerr_misc_register:\r\ncoresight_unregister(drvdata->csdev);\r\nerr_devm_kzalloc:\r\nif (drvdata->config_type == TMC_CONFIG_TYPE_ETR)\r\ndma_free_coherent(dev, drvdata->size,\r\n&drvdata->paddr, GFP_KERNEL);\r\nreturn ret;\r\n}\r\nstatic int tmc_remove(struct amba_device *adev)\r\n{\r\nstruct tmc_drvdata *drvdata = amba_get_drvdata(adev);\r\nmisc_deregister(&drvdata->miscdev);\r\ncoresight_unregister(drvdata->csdev);\r\nif (drvdata->config_type == TMC_CONFIG_TYPE_ETR)\r\ndma_free_coherent(drvdata->dev, drvdata->size,\r\n&drvdata->paddr, GFP_KERNEL);\r\nreturn 0;\r\n}
