void __nd_detach_ndns(struct device *dev, struct nd_namespace_common **_ndns)\r\n{\r\nstruct nd_namespace_common *ndns = *_ndns;\r\ndev_WARN_ONCE(dev, !mutex_is_locked(&ndns->dev.mutex)\r\n|| ndns->claim != dev,\r\n"%s: invalid claim\n", __func__);\r\nndns->claim = NULL;\r\n*_ndns = NULL;\r\nput_device(&ndns->dev);\r\n}\r\nvoid nd_detach_ndns(struct device *dev,\r\nstruct nd_namespace_common **_ndns)\r\n{\r\nstruct nd_namespace_common *ndns = *_ndns;\r\nif (!ndns)\r\nreturn;\r\nget_device(&ndns->dev);\r\ndevice_lock(&ndns->dev);\r\n__nd_detach_ndns(dev, _ndns);\r\ndevice_unlock(&ndns->dev);\r\nput_device(&ndns->dev);\r\n}\r\nbool __nd_attach_ndns(struct device *dev, struct nd_namespace_common *attach,\r\nstruct nd_namespace_common **_ndns)\r\n{\r\nif (attach->claim)\r\nreturn false;\r\ndev_WARN_ONCE(dev, !mutex_is_locked(&attach->dev.mutex)\r\n|| *_ndns,\r\n"%s: invalid claim\n", __func__);\r\nattach->claim = dev;\r\n*_ndns = attach;\r\nget_device(&attach->dev);\r\nreturn true;\r\n}\r\nbool nd_attach_ndns(struct device *dev, struct nd_namespace_common *attach,\r\nstruct nd_namespace_common **_ndns)\r\n{\r\nbool claimed;\r\ndevice_lock(&attach->dev);\r\nclaimed = __nd_attach_ndns(dev, attach, _ndns);\r\ndevice_unlock(&attach->dev);\r\nreturn claimed;\r\n}\r\nstatic int namespace_match(struct device *dev, void *data)\r\n{\r\nchar *name = data;\r\nreturn strcmp(name, dev_name(dev)) == 0;\r\n}\r\nstatic bool is_idle(struct device *dev, struct nd_namespace_common *ndns)\r\n{\r\nstruct nd_region *nd_region = to_nd_region(dev->parent);\r\nstruct device *seed = NULL;\r\nif (is_nd_btt(dev))\r\nseed = nd_region->btt_seed;\r\nelse if (is_nd_pfn(dev))\r\nseed = nd_region->pfn_seed;\r\nif (seed == dev || ndns || dev->driver)\r\nreturn false;\r\nreturn true;\r\n}\r\nstatic void nd_detach_and_reset(struct device *dev,\r\nstruct nd_namespace_common **_ndns)\r\n{\r\nnd_detach_ndns(dev, _ndns);\r\nif (is_idle(dev, *_ndns)) {\r\nnd_device_unregister(dev, ND_ASYNC);\r\n} else if (is_nd_btt(dev)) {\r\nstruct nd_btt *nd_btt = to_nd_btt(dev);\r\nnd_btt->lbasize = 0;\r\nkfree(nd_btt->uuid);\r\nnd_btt->uuid = NULL;\r\n} else if (is_nd_pfn(dev)) {\r\nstruct nd_pfn *nd_pfn = to_nd_pfn(dev);\r\nkfree(nd_pfn->uuid);\r\nnd_pfn->uuid = NULL;\r\nnd_pfn->mode = PFN_MODE_NONE;\r\n}\r\n}\r\nssize_t nd_namespace_store(struct device *dev,\r\nstruct nd_namespace_common **_ndns, const char *buf,\r\nsize_t len)\r\n{\r\nstruct nd_namespace_common *ndns;\r\nstruct device *found;\r\nchar *name;\r\nif (dev->driver) {\r\ndev_dbg(dev, "%s: -EBUSY\n", __func__);\r\nreturn -EBUSY;\r\n}\r\nname = kstrndup(buf, len, GFP_KERNEL);\r\nif (!name)\r\nreturn -ENOMEM;\r\nstrim(name);\r\nif (strncmp(name, "namespace", 9) == 0 || strcmp(name, "") == 0)\r\n;\r\nelse {\r\nlen = -EINVAL;\r\ngoto out;\r\n}\r\nndns = *_ndns;\r\nif (strcmp(name, "") == 0) {\r\nnd_detach_and_reset(dev, _ndns);\r\ngoto out;\r\n} else if (ndns) {\r\ndev_dbg(dev, "namespace already set to: %s\n",\r\ndev_name(&ndns->dev));\r\nlen = -EBUSY;\r\ngoto out;\r\n}\r\nfound = device_find_child(dev->parent, name, namespace_match);\r\nif (!found) {\r\ndev_dbg(dev, "'%s' not found under %s\n", name,\r\ndev_name(dev->parent));\r\nlen = -ENODEV;\r\ngoto out;\r\n}\r\nndns = to_ndns(found);\r\nif (__nvdimm_namespace_capacity(ndns) < SZ_16M) {\r\ndev_dbg(dev, "%s too small to host\n", name);\r\nlen = -ENXIO;\r\ngoto out_attach;\r\n}\r\nWARN_ON_ONCE(!is_nvdimm_bus_locked(dev));\r\nif (!nd_attach_ndns(dev, ndns, _ndns)) {\r\ndev_dbg(dev, "%s already claimed\n",\r\ndev_name(&ndns->dev));\r\nlen = -EBUSY;\r\n}\r\nout_attach:\r\nput_device(&ndns->dev);\r\nout:\r\nkfree(name);\r\nreturn len;\r\n}\r\nu64 nd_sb_checksum(struct nd_gen_sb *nd_gen_sb)\r\n{\r\nu64 sum;\r\n__le64 sum_save;\r\nBUILD_BUG_ON(sizeof(struct btt_sb) != SZ_4K);\r\nBUILD_BUG_ON(sizeof(struct nd_pfn_sb) != SZ_4K);\r\nBUILD_BUG_ON(sizeof(struct nd_gen_sb) != SZ_4K);\r\nsum_save = nd_gen_sb->checksum;\r\nnd_gen_sb->checksum = 0;\r\nsum = nd_fletcher64(nd_gen_sb, sizeof(*nd_gen_sb), 1);\r\nnd_gen_sb->checksum = sum_save;\r\nreturn sum;\r\n}
