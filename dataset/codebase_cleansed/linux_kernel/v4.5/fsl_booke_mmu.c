unsigned long tlbcam_sz(int idx)\r\n{\r\nreturn tlbcam_addrs[idx].limit - tlbcam_addrs[idx].start + 1;\r\n}\r\nphys_addr_t v_mapped_by_tlbcam(unsigned long va)\r\n{\r\nint b;\r\nfor (b = 0; b < tlbcam_index; ++b)\r\nif (va >= tlbcam_addrs[b].start && va < tlbcam_addrs[b].limit)\r\nreturn tlbcam_addrs[b].phys + (va - tlbcam_addrs[b].start);\r\nreturn 0;\r\n}\r\nunsigned long p_mapped_by_tlbcam(phys_addr_t pa)\r\n{\r\nint b;\r\nfor (b = 0; b < tlbcam_index; ++b)\r\nif (pa >= tlbcam_addrs[b].phys\r\n&& pa < (tlbcam_addrs[b].limit-tlbcam_addrs[b].start)\r\n+tlbcam_addrs[b].phys)\r\nreturn tlbcam_addrs[b].start+(pa-tlbcam_addrs[b].phys);\r\nreturn 0;\r\n}\r\nstatic void settlbcam(int index, unsigned long virt, phys_addr_t phys,\r\nunsigned long size, unsigned long flags, unsigned int pid)\r\n{\r\nunsigned int tsize;\r\ntsize = __ilog2(size) - 10;\r\n#if defined(CONFIG_SMP) || defined(CONFIG_PPC_E500MC)\r\nif ((flags & _PAGE_NO_CACHE) == 0)\r\nflags |= _PAGE_COHERENT;\r\n#endif\r\nTLBCAM[index].MAS0 = MAS0_TLBSEL(1) | MAS0_ESEL(index) | MAS0_NV(index+1);\r\nTLBCAM[index].MAS1 = MAS1_VALID | MAS1_IPROT | MAS1_TSIZE(tsize) | MAS1_TID(pid);\r\nTLBCAM[index].MAS2 = virt & PAGE_MASK;\r\nTLBCAM[index].MAS2 |= (flags & _PAGE_WRITETHRU) ? MAS2_W : 0;\r\nTLBCAM[index].MAS2 |= (flags & _PAGE_NO_CACHE) ? MAS2_I : 0;\r\nTLBCAM[index].MAS2 |= (flags & _PAGE_COHERENT) ? MAS2_M : 0;\r\nTLBCAM[index].MAS2 |= (flags & _PAGE_GUARDED) ? MAS2_G : 0;\r\nTLBCAM[index].MAS2 |= (flags & _PAGE_ENDIAN) ? MAS2_E : 0;\r\nTLBCAM[index].MAS3 = (phys & MAS3_RPN) | MAS3_SX | MAS3_SR;\r\nTLBCAM[index].MAS3 |= ((flags & _PAGE_RW) ? MAS3_SW : 0);\r\nif (mmu_has_feature(MMU_FTR_BIG_PHYS))\r\nTLBCAM[index].MAS7 = (u64)phys >> 32;\r\nif (pte_user(flags)) {\r\nTLBCAM[index].MAS3 |= MAS3_UX | MAS3_UR;\r\nTLBCAM[index].MAS3 |= ((flags & _PAGE_RW) ? MAS3_UW : 0);\r\n}\r\ntlbcam_addrs[index].start = virt;\r\ntlbcam_addrs[index].limit = virt + size - 1;\r\ntlbcam_addrs[index].phys = phys;\r\n}\r\nunsigned long calc_cam_sz(unsigned long ram, unsigned long virt,\r\nphys_addr_t phys)\r\n{\r\nunsigned int camsize = __ilog2(ram);\r\nunsigned int align = __ffs(virt | phys);\r\nunsigned long max_cam;\r\nif ((mfspr(SPRN_MMUCFG) & MMUCFG_MAVN) == MMUCFG_MAVN_V1) {\r\nmax_cam = ((mfspr(SPRN_TLB1CFG) >> 16) & 0xf) * 2 + 10;\r\ncamsize &= ~1U;\r\nalign &= ~1U;\r\n} else {\r\nmax_cam = __ilog2(mfspr(SPRN_TLB1PS)) + 10;\r\n}\r\nif (camsize > align)\r\ncamsize = align;\r\nif (camsize > max_cam)\r\ncamsize = max_cam;\r\nreturn 1UL << camsize;\r\n}\r\nstatic unsigned long map_mem_in_cams_addr(phys_addr_t phys, unsigned long virt,\r\nunsigned long ram, int max_cam_idx,\r\nbool dryrun)\r\n{\r\nint i;\r\nunsigned long amount_mapped = 0;\r\nfor (i = 0; ram && i < max_cam_idx; i++) {\r\nunsigned long cam_sz;\r\ncam_sz = calc_cam_sz(ram, virt, phys);\r\nif (!dryrun)\r\nsettlbcam(i, virt, phys, cam_sz,\r\npgprot_val(PAGE_KERNEL_X), 0);\r\nram -= cam_sz;\r\namount_mapped += cam_sz;\r\nvirt += cam_sz;\r\nphys += cam_sz;\r\n}\r\nif (dryrun)\r\nreturn amount_mapped;\r\nloadcam_multi(0, i, max_cam_idx);\r\ntlbcam_index = i;\r\n#ifdef CONFIG_PPC64\r\nget_paca()->tcd.esel_next = i;\r\nget_paca()->tcd.esel_max = mfspr(SPRN_TLB1CFG) & TLBnCFG_N_ENTRY;\r\nget_paca()->tcd.esel_first = i;\r\n#endif\r\nreturn amount_mapped;\r\n}\r\nunsigned long map_mem_in_cams(unsigned long ram, int max_cam_idx, bool dryrun)\r\n{\r\nunsigned long virt = PAGE_OFFSET;\r\nphys_addr_t phys = memstart_addr;\r\nreturn map_mem_in_cams_addr(phys, virt, ram, max_cam_idx, dryrun);\r\n}\r\nunsigned long __init mmu_mapin_ram(unsigned long top)\r\n{\r\nreturn tlbcam_addrs[tlbcam_index - 1].limit - PAGE_OFFSET + 1;\r\n}\r\nvoid __init MMU_init_hw(void)\r\n{\r\nflush_instruction_cache();\r\n}\r\nvoid __init adjust_total_lowmem(void)\r\n{\r\nunsigned long ram;\r\nint i;\r\nram = min((phys_addr_t)__max_low_memory, (phys_addr_t)total_lowmem);\r\ni = switch_to_as1();\r\n__max_low_memory = map_mem_in_cams(ram, CONFIG_LOWMEM_CAM_NUM, false);\r\nrestore_to_as0(i, 0, 0, 1);\r\npr_info("Memory CAM mapping: ");\r\nfor (i = 0; i < tlbcam_index - 1; i++)\r\npr_cont("%lu/", tlbcam_sz(i) >> 20);\r\npr_cont("%lu Mb, residual: %dMb\n", tlbcam_sz(tlbcam_index - 1) >> 20,\r\n(unsigned int)((total_lowmem - __max_low_memory) >> 20));\r\nmemblock_set_current_limit(memstart_addr + __max_low_memory);\r\n}\r\nvoid setup_initial_memory_limit(phys_addr_t first_memblock_base,\r\nphys_addr_t first_memblock_size)\r\n{\r\nphys_addr_t limit = first_memblock_base + first_memblock_size;\r\nmemblock_set_current_limit(min_t(u64, limit, 0x04000000));\r\n}\r\nnotrace void __init relocate_init(u64 dt_ptr, phys_addr_t start)\r\n{\r\nunsigned long base = KERNELBASE;\r\nkernstart_addr = start;\r\nif (is_second_reloc) {\r\nvirt_phys_offset = PAGE_OFFSET - memstart_addr;\r\nreturn;\r\n}\r\nstart &= ~0x3ffffff;\r\nbase &= ~0x3ffffff;\r\nvirt_phys_offset = base - start;\r\nearly_get_first_memblock_info(__va(dt_ptr), NULL);\r\nif (start != memstart_addr) {\r\nint n;\r\nlong offset = start - memstart_addr;\r\nis_second_reloc = 1;\r\nn = switch_to_as1();\r\nif (memstart_addr > start)\r\nmap_mem_in_cams(0x4000000, CONFIG_LOWMEM_CAM_NUM,\r\nfalse);\r\nelse\r\nmap_mem_in_cams_addr(start, PAGE_OFFSET + offset,\r\n0x4000000, CONFIG_LOWMEM_CAM_NUM,\r\nfalse);\r\nrestore_to_as0(n, offset, __va(dt_ptr), 1);\r\npanic("Relocation error");\r\n}\r\n}
