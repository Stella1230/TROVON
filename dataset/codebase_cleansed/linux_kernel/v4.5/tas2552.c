static int tas2552_post_event(struct snd_soc_dapm_widget *w,\r\nstruct snd_kcontrol *kcontrol, int event)\r\n{\r\nstruct snd_soc_codec *codec = snd_soc_dapm_to_codec(w->dapm);\r\nswitch (event) {\r\ncase SND_SOC_DAPM_POST_PMU:\r\nsnd_soc_write(codec, TAS2552_RESERVED_0D, 0xc0);\r\nsnd_soc_update_bits(codec, TAS2552_LIMIT_RATE_HYS, (1 << 5),\r\n(1 << 5));\r\nsnd_soc_update_bits(codec, TAS2552_CFG_2, 1, 0);\r\nsnd_soc_update_bits(codec, TAS2552_CFG_1, TAS2552_SWS, 0);\r\nbreak;\r\ncase SND_SOC_DAPM_POST_PMD:\r\nsnd_soc_update_bits(codec, TAS2552_CFG_1, TAS2552_SWS,\r\nTAS2552_SWS);\r\nsnd_soc_update_bits(codec, TAS2552_CFG_2, 1, 1);\r\nsnd_soc_update_bits(codec, TAS2552_LIMIT_RATE_HYS, (1 << 5), 0);\r\nsnd_soc_write(codec, TAS2552_RESERVED_0D, 0xbe);\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic void tas2552_sw_shutdown(struct tas2552_data *tas2552, int sw_shutdown)\r\n{\r\nu8 cfg1_reg = 0;\r\nif (!tas2552->codec)\r\nreturn;\r\nif (sw_shutdown)\r\ncfg1_reg = TAS2552_SWS;\r\nsnd_soc_update_bits(tas2552->codec, TAS2552_CFG_1, TAS2552_SWS,\r\ncfg1_reg);\r\n}\r\nstatic int tas2552_setup_pll(struct snd_soc_codec *codec,\r\nstruct snd_pcm_hw_params *params)\r\n{\r\nstruct tas2552_data *tas2552 = dev_get_drvdata(codec->dev);\r\nbool bypass_pll = false;\r\nunsigned int pll_clk = params_rate(params) * 512;\r\nunsigned int pll_clkin = tas2552->pll_clkin;\r\nu8 pll_enable;\r\nif (!pll_clkin) {\r\nif (tas2552->pll_clk_id != TAS2552_PLL_CLKIN_BCLK)\r\nreturn -EINVAL;\r\npll_clkin = snd_soc_params_to_bclk(params);\r\npll_clkin += tas2552->tdm_delay;\r\n}\r\npll_enable = snd_soc_read(codec, TAS2552_CFG_2) & TAS2552_PLL_ENABLE;\r\nsnd_soc_update_bits(codec, TAS2552_CFG_2, TAS2552_PLL_ENABLE, 0);\r\nif (pll_clkin == pll_clk)\r\nbypass_pll = true;\r\nif (bypass_pll) {\r\nsnd_soc_update_bits(codec, TAS2552_PLL_CTRL_2,\r\nTAS2552_PLL_BYPASS, TAS2552_PLL_BYPASS);\r\n} else {\r\nunsigned int d;\r\nu8 j;\r\nu8 pll_sel = (tas2552->pll_clk_id << 3) & TAS2552_PLL_SRC_MASK;\r\nu8 p = snd_soc_read(codec, TAS2552_PLL_CTRL_1);\r\np = (p >> 7);\r\nrecalc:\r\nj = (pll_clk * 2 * (1 << p)) / pll_clkin;\r\nd = (pll_clk * 2 * (1 << p)) % pll_clkin;\r\nd /= (pll_clkin / 10000);\r\nif (d && (pll_clkin < 512000 || pll_clkin > 9200000)) {\r\nif (tas2552->pll_clk_id == TAS2552_PLL_CLKIN_BCLK) {\r\npll_clkin = 1800000;\r\npll_sel = (TAS2552_PLL_CLKIN_1_8_FIXED << 3) &\r\nTAS2552_PLL_SRC_MASK;\r\n} else {\r\npll_clkin = snd_soc_params_to_bclk(params);\r\npll_clkin += tas2552->tdm_delay;\r\npll_sel = (TAS2552_PLL_CLKIN_BCLK << 3) &\r\nTAS2552_PLL_SRC_MASK;\r\n}\r\ngoto recalc;\r\n}\r\nsnd_soc_update_bits(codec, TAS2552_CFG_1, TAS2552_PLL_SRC_MASK,\r\npll_sel);\r\nsnd_soc_update_bits(codec, TAS2552_PLL_CTRL_1,\r\nTAS2552_PLL_J_MASK, j);\r\nsnd_soc_write(codec, TAS2552_PLL_CTRL_2,\r\nTAS2552_PLL_D_UPPER(d));\r\nsnd_soc_write(codec, TAS2552_PLL_CTRL_3,\r\nTAS2552_PLL_D_LOWER(d));\r\n}\r\nsnd_soc_update_bits(codec, TAS2552_CFG_2, TAS2552_PLL_ENABLE,\r\npll_enable);\r\nreturn 0;\r\n}\r\nstatic int tas2552_hw_params(struct snd_pcm_substream *substream,\r\nstruct snd_pcm_hw_params *params,\r\nstruct snd_soc_dai *dai)\r\n{\r\nstruct snd_soc_codec *codec = dai->codec;\r\nstruct tas2552_data *tas2552 = dev_get_drvdata(codec->dev);\r\nint cpf;\r\nu8 ser_ctrl1_reg, wclk_rate;\r\nswitch (params_width(params)) {\r\ncase 16:\r\nser_ctrl1_reg = TAS2552_WORDLENGTH_16BIT;\r\ncpf = 32 + tas2552->tdm_delay;\r\nbreak;\r\ncase 20:\r\nser_ctrl1_reg = TAS2552_WORDLENGTH_20BIT;\r\ncpf = 64 + tas2552->tdm_delay;\r\nbreak;\r\ncase 24:\r\nser_ctrl1_reg = TAS2552_WORDLENGTH_24BIT;\r\ncpf = 64 + tas2552->tdm_delay;\r\nbreak;\r\ncase 32:\r\nser_ctrl1_reg = TAS2552_WORDLENGTH_32BIT;\r\ncpf = 64 + tas2552->tdm_delay;\r\nbreak;\r\ndefault:\r\ndev_err(codec->dev, "Not supported sample size: %d\n",\r\nparams_width(params));\r\nreturn -EINVAL;\r\n}\r\nif (cpf <= 32)\r\nser_ctrl1_reg |= TAS2552_CLKSPERFRAME_32;\r\nelse if (cpf <= 64)\r\nser_ctrl1_reg |= TAS2552_CLKSPERFRAME_64;\r\nelse if (cpf <= 128)\r\nser_ctrl1_reg |= TAS2552_CLKSPERFRAME_128;\r\nelse\r\nser_ctrl1_reg |= TAS2552_CLKSPERFRAME_256;\r\nsnd_soc_update_bits(codec, TAS2552_SER_CTRL_1,\r\nTAS2552_WORDLENGTH_MASK | TAS2552_CLKSPERFRAME_MASK,\r\nser_ctrl1_reg);\r\nswitch (params_rate(params)) {\r\ncase 8000:\r\nwclk_rate = TAS2552_WCLK_FREQ_8KHZ;\r\nbreak;\r\ncase 11025:\r\ncase 12000:\r\nwclk_rate = TAS2552_WCLK_FREQ_11_12KHZ;\r\nbreak;\r\ncase 16000:\r\nwclk_rate = TAS2552_WCLK_FREQ_16KHZ;\r\nbreak;\r\ncase 22050:\r\ncase 24000:\r\nwclk_rate = TAS2552_WCLK_FREQ_22_24KHZ;\r\nbreak;\r\ncase 32000:\r\nwclk_rate = TAS2552_WCLK_FREQ_32KHZ;\r\nbreak;\r\ncase 44100:\r\ncase 48000:\r\nwclk_rate = TAS2552_WCLK_FREQ_44_48KHZ;\r\nbreak;\r\ncase 88200:\r\ncase 96000:\r\nwclk_rate = TAS2552_WCLK_FREQ_88_96KHZ;\r\nbreak;\r\ncase 176400:\r\ncase 192000:\r\nwclk_rate = TAS2552_WCLK_FREQ_176_192KHZ;\r\nbreak;\r\ndefault:\r\ndev_err(codec->dev, "Not supported sample rate: %d\n",\r\nparams_rate(params));\r\nreturn -EINVAL;\r\n}\r\nsnd_soc_update_bits(codec, TAS2552_CFG_3, TAS2552_WCLK_FREQ_MASK,\r\nwclk_rate);\r\nreturn tas2552_setup_pll(codec, params);\r\n}\r\nstatic int tas2552_prepare(struct snd_pcm_substream *substream,\r\nstruct snd_soc_dai *dai)\r\n{\r\nstruct snd_soc_codec *codec = dai->codec;\r\nstruct tas2552_data *tas2552 = snd_soc_codec_get_drvdata(codec);\r\nint delay = 0;\r\nif (tas2552->dai_fmt == SND_SOC_DAIFMT_DSP_A)\r\ndelay += (tas2552->tdm_delay + 1);\r\nelse if (tas2552->dai_fmt == SND_SOC_DAIFMT_DSP_B)\r\ndelay += tas2552->tdm_delay;\r\nsnd_soc_write(codec, TAS2552_SER_CTRL_2, delay);\r\nreturn 0;\r\n}\r\nstatic int tas2552_set_dai_fmt(struct snd_soc_dai *dai, unsigned int fmt)\r\n{\r\nstruct snd_soc_codec *codec = dai->codec;\r\nstruct tas2552_data *tas2552 = dev_get_drvdata(codec->dev);\r\nu8 serial_format;\r\nswitch (fmt & SND_SOC_DAIFMT_MASTER_MASK) {\r\ncase SND_SOC_DAIFMT_CBS_CFS:\r\nserial_format = 0x00;\r\nbreak;\r\ncase SND_SOC_DAIFMT_CBS_CFM:\r\nserial_format = TAS2552_WCLKDIR;\r\nbreak;\r\ncase SND_SOC_DAIFMT_CBM_CFS:\r\nserial_format = TAS2552_BCLKDIR;\r\nbreak;\r\ncase SND_SOC_DAIFMT_CBM_CFM:\r\nserial_format = (TAS2552_BCLKDIR | TAS2552_WCLKDIR);\r\nbreak;\r\ndefault:\r\ndev_vdbg(codec->dev, "DAI Format master is not found\n");\r\nreturn -EINVAL;\r\n}\r\nswitch (fmt & (SND_SOC_DAIFMT_FORMAT_MASK |\r\nSND_SOC_DAIFMT_INV_MASK)) {\r\ncase (SND_SOC_DAIFMT_I2S | SND_SOC_DAIFMT_NB_NF):\r\nbreak;\r\ncase (SND_SOC_DAIFMT_DSP_A | SND_SOC_DAIFMT_IB_NF):\r\ncase (SND_SOC_DAIFMT_DSP_B | SND_SOC_DAIFMT_IB_NF):\r\nserial_format |= TAS2552_DATAFORMAT_DSP;\r\nbreak;\r\ncase (SND_SOC_DAIFMT_RIGHT_J | SND_SOC_DAIFMT_NB_NF):\r\nserial_format |= TAS2552_DATAFORMAT_RIGHT_J;\r\nbreak;\r\ncase (SND_SOC_DAIFMT_LEFT_J | SND_SOC_DAIFMT_NB_NF):\r\nserial_format |= TAS2552_DATAFORMAT_LEFT_J;\r\nbreak;\r\ndefault:\r\ndev_vdbg(codec->dev, "DAI Format is not found\n");\r\nreturn -EINVAL;\r\n}\r\ntas2552->dai_fmt = fmt & SND_SOC_DAIFMT_FORMAT_MASK;\r\nsnd_soc_update_bits(codec, TAS2552_SER_CTRL_1, TAS2552_DAI_FMT_MASK,\r\nserial_format);\r\nreturn 0;\r\n}\r\nstatic int tas2552_set_dai_sysclk(struct snd_soc_dai *dai, int clk_id,\r\nunsigned int freq, int dir)\r\n{\r\nstruct snd_soc_codec *codec = dai->codec;\r\nstruct tas2552_data *tas2552 = dev_get_drvdata(codec->dev);\r\nu8 reg, mask, val;\r\nswitch (clk_id) {\r\ncase TAS2552_PLL_CLKIN_MCLK:\r\ncase TAS2552_PLL_CLKIN_IVCLKIN:\r\nif (freq < 512000 || freq > 24576000) {\r\ndev_warn(codec->dev, "Out of range PLL_CLKIN: %u\n",\r\nfreq);\r\nclk_id = TAS2552_PLL_CLKIN_BCLK;\r\nfreq = 0;\r\n}\r\ncase TAS2552_PLL_CLKIN_BCLK:\r\ncase TAS2552_PLL_CLKIN_1_8_FIXED:\r\nmask = TAS2552_PLL_SRC_MASK;\r\nval = (clk_id << 3) & mask;\r\nreg = TAS2552_CFG_1;\r\ntas2552->pll_clk_id = clk_id;\r\ntas2552->pll_clkin = freq;\r\nbreak;\r\ncase TAS2552_PDM_CLK_PLL:\r\ncase TAS2552_PDM_CLK_IVCLKIN:\r\ncase TAS2552_PDM_CLK_BCLK:\r\ncase TAS2552_PDM_CLK_MCLK:\r\nmask = TAS2552_PDM_CLK_SEL_MASK;\r\nval = (clk_id >> 1) & mask;\r\nreg = TAS2552_PDM_CFG;\r\ntas2552->pdm_clk_id = clk_id;\r\ntas2552->pdm_clk = freq;\r\nbreak;\r\ndefault:\r\ndev_err(codec->dev, "Invalid clk id: %d\n", clk_id);\r\nreturn -EINVAL;\r\n}\r\nsnd_soc_update_bits(codec, reg, mask, val);\r\nreturn 0;\r\n}\r\nstatic int tas2552_set_dai_tdm_slot(struct snd_soc_dai *dai,\r\nunsigned int tx_mask, unsigned int rx_mask,\r\nint slots, int slot_width)\r\n{\r\nstruct snd_soc_codec *codec = dai->codec;\r\nstruct tas2552_data *tas2552 = snd_soc_codec_get_drvdata(codec);\r\nunsigned int lsb;\r\nif (unlikely(!tx_mask)) {\r\ndev_err(codec->dev, "tx masks need to be non 0\n");\r\nreturn -EINVAL;\r\n}\r\nlsb = __ffs(tx_mask);\r\nif ((lsb + 1) != __fls(tx_mask)) {\r\ndev_err(codec->dev, "Invalid mask, slots must be adjacent\n");\r\nreturn -EINVAL;\r\n}\r\ntas2552->tdm_delay = lsb * slot_width;\r\nsnd_soc_update_bits(codec, TAS2552_DOUT,\r\nTAS2552_SDOUT_TRISTATE, TAS2552_SDOUT_TRISTATE);\r\nreturn 0;\r\n}\r\nstatic int tas2552_mute(struct snd_soc_dai *dai, int mute)\r\n{\r\nu8 cfg1_reg = 0;\r\nstruct snd_soc_codec *codec = dai->codec;\r\nif (mute)\r\ncfg1_reg |= TAS2552_MUTE;\r\nsnd_soc_update_bits(codec, TAS2552_CFG_1, TAS2552_MUTE, cfg1_reg);\r\nreturn 0;\r\n}\r\nstatic int tas2552_runtime_suspend(struct device *dev)\r\n{\r\nstruct tas2552_data *tas2552 = dev_get_drvdata(dev);\r\ntas2552_sw_shutdown(tas2552, 1);\r\nregcache_cache_only(tas2552->regmap, true);\r\nregcache_mark_dirty(tas2552->regmap);\r\ngpiod_set_value(tas2552->enable_gpio, 0);\r\nreturn 0;\r\n}\r\nstatic int tas2552_runtime_resume(struct device *dev)\r\n{\r\nstruct tas2552_data *tas2552 = dev_get_drvdata(dev);\r\ngpiod_set_value(tas2552->enable_gpio, 1);\r\ntas2552_sw_shutdown(tas2552, 0);\r\nregcache_cache_only(tas2552->regmap, false);\r\nregcache_sync(tas2552->regmap);\r\nreturn 0;\r\n}\r\nstatic int tas2552_codec_probe(struct snd_soc_codec *codec)\r\n{\r\nstruct tas2552_data *tas2552 = snd_soc_codec_get_drvdata(codec);\r\nint ret;\r\ntas2552->codec = codec;\r\nret = regulator_bulk_enable(ARRAY_SIZE(tas2552->supplies),\r\ntas2552->supplies);\r\nif (ret != 0) {\r\ndev_err(codec->dev, "Failed to enable supplies: %d\n",\r\nret);\r\nreturn ret;\r\n}\r\ngpiod_set_value(tas2552->enable_gpio, 1);\r\nret = pm_runtime_get_sync(codec->dev);\r\nif (ret < 0) {\r\ndev_err(codec->dev, "Enabling device failed: %d\n",\r\nret);\r\ngoto probe_fail;\r\n}\r\nsnd_soc_update_bits(codec, TAS2552_CFG_1, TAS2552_MUTE, TAS2552_MUTE);\r\nsnd_soc_write(codec, TAS2552_CFG_3, TAS2552_I2S_OUT_SEL |\r\nTAS2552_DIN_SRC_SEL_AVG_L_R);\r\nsnd_soc_write(codec, TAS2552_OUTPUT_DATA,\r\nTAS2552_PDM_DATA_SEL_V_I |\r\nTAS2552_R_DATA_OUT(TAS2552_DATA_OUT_V_DATA));\r\nsnd_soc_write(codec, TAS2552_BOOST_APT_CTRL, TAS2552_APT_DELAY_200 |\r\nTAS2552_APT_THRESH_20_17);\r\nsnd_soc_write(codec, TAS2552_CFG_2, TAS2552_BOOST_EN | TAS2552_APT_EN |\r\nTAS2552_LIM_EN);\r\nreturn 0;\r\nprobe_fail:\r\ngpiod_set_value(tas2552->enable_gpio, 0);\r\nregulator_bulk_disable(ARRAY_SIZE(tas2552->supplies),\r\ntas2552->supplies);\r\nreturn -EIO;\r\n}\r\nstatic int tas2552_codec_remove(struct snd_soc_codec *codec)\r\n{\r\nstruct tas2552_data *tas2552 = snd_soc_codec_get_drvdata(codec);\r\npm_runtime_put(codec->dev);\r\ngpiod_set_value(tas2552->enable_gpio, 0);\r\nreturn 0;\r\n}\r\nstatic int tas2552_suspend(struct snd_soc_codec *codec)\r\n{\r\nstruct tas2552_data *tas2552 = snd_soc_codec_get_drvdata(codec);\r\nint ret;\r\nret = regulator_bulk_disable(ARRAY_SIZE(tas2552->supplies),\r\ntas2552->supplies);\r\nif (ret != 0)\r\ndev_err(codec->dev, "Failed to disable supplies: %d\n",\r\nret);\r\nreturn 0;\r\n}\r\nstatic int tas2552_resume(struct snd_soc_codec *codec)\r\n{\r\nstruct tas2552_data *tas2552 = snd_soc_codec_get_drvdata(codec);\r\nint ret;\r\nret = regulator_bulk_enable(ARRAY_SIZE(tas2552->supplies),\r\ntas2552->supplies);\r\nif (ret != 0) {\r\ndev_err(codec->dev, "Failed to enable supplies: %d\n",\r\nret);\r\n}\r\nreturn 0;\r\n}\r\nstatic int tas2552_probe(struct i2c_client *client,\r\nconst struct i2c_device_id *id)\r\n{\r\nstruct device *dev;\r\nstruct tas2552_data *data;\r\nint ret;\r\nint i;\r\ndev = &client->dev;\r\ndata = devm_kzalloc(&client->dev, sizeof(*data), GFP_KERNEL);\r\nif (data == NULL)\r\nreturn -ENOMEM;\r\ndata->enable_gpio = devm_gpiod_get_optional(dev, "enable",\r\nGPIOD_OUT_LOW);\r\nif (IS_ERR(data->enable_gpio))\r\nreturn PTR_ERR(data->enable_gpio);\r\ndata->tas2552_client = client;\r\ndata->regmap = devm_regmap_init_i2c(client, &tas2552_regmap_config);\r\nif (IS_ERR(data->regmap)) {\r\nret = PTR_ERR(data->regmap);\r\ndev_err(&client->dev, "Failed to allocate register map: %d\n",\r\nret);\r\nreturn ret;\r\n}\r\nfor (i = 0; i < ARRAY_SIZE(data->supplies); i++)\r\ndata->supplies[i].supply = tas2552_supply_names[i];\r\nret = devm_regulator_bulk_get(dev, ARRAY_SIZE(data->supplies),\r\ndata->supplies);\r\nif (ret != 0) {\r\ndev_err(dev, "Failed to request supplies: %d\n", ret);\r\nreturn ret;\r\n}\r\npm_runtime_set_active(&client->dev);\r\npm_runtime_set_autosuspend_delay(&client->dev, 1000);\r\npm_runtime_use_autosuspend(&client->dev);\r\npm_runtime_enable(&client->dev);\r\npm_runtime_mark_last_busy(&client->dev);\r\npm_runtime_put_sync_autosuspend(&client->dev);\r\ndev_set_drvdata(&client->dev, data);\r\nret = snd_soc_register_codec(&client->dev,\r\n&soc_codec_dev_tas2552,\r\ntas2552_dai, ARRAY_SIZE(tas2552_dai));\r\nif (ret < 0)\r\ndev_err(&client->dev, "Failed to register codec: %d\n", ret);\r\nreturn ret;\r\n}\r\nstatic int tas2552_i2c_remove(struct i2c_client *client)\r\n{\r\nsnd_soc_unregister_codec(&client->dev);\r\npm_runtime_disable(&client->dev);\r\nreturn 0;\r\n}
