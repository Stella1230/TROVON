static bool cs35l32_readable_register(struct device *dev, unsigned int reg)\r\n{\r\nswitch (reg) {\r\ncase CS35L32_DEVID_AB ... CS35L32_AUDIO_LED_MNGR:\r\ncase CS35L32_ADSP_CTL ... CS35L32_FLASH_INHIBIT:\r\nreturn true;\r\ndefault:\r\nreturn false;\r\n}\r\n}\r\nstatic bool cs35l32_volatile_register(struct device *dev, unsigned int reg)\r\n{\r\nswitch (reg) {\r\ncase CS35L32_DEVID_AB ... CS35L32_REV_ID:\r\ncase CS35L32_INT_STATUS_1 ... CS35L32_LED_STATUS:\r\nreturn true;\r\ndefault:\r\nreturn false;\r\n}\r\n}\r\nstatic bool cs35l32_precious_register(struct device *dev, unsigned int reg)\r\n{\r\nswitch (reg) {\r\ncase CS35L32_INT_STATUS_1 ... CS35L32_LED_STATUS:\r\nreturn true;\r\ndefault:\r\nreturn false;\r\n}\r\n}\r\nstatic int cs35l32_set_dai_fmt(struct snd_soc_dai *codec_dai, unsigned int fmt)\r\n{\r\nstruct snd_soc_codec *codec = codec_dai->codec;\r\nswitch (fmt & SND_SOC_DAIFMT_MASTER_MASK) {\r\ncase SND_SOC_DAIFMT_CBM_CFM:\r\nsnd_soc_update_bits(codec, CS35L32_ADSP_CTL,\r\nCS35L32_ADSP_MASTER_MASK,\r\nCS35L32_ADSP_MASTER_MASK);\r\nbreak;\r\ncase SND_SOC_DAIFMT_CBS_CFS:\r\nsnd_soc_update_bits(codec, CS35L32_ADSP_CTL,\r\nCS35L32_ADSP_MASTER_MASK, 0);\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int cs35l32_set_tristate(struct snd_soc_dai *dai, int tristate)\r\n{\r\nstruct snd_soc_codec *codec = dai->codec;\r\nreturn snd_soc_update_bits(codec, CS35L32_PWRCTL2,\r\nCS35L32_SDOUT_3ST, tristate << 3);\r\n}\r\nstatic int cs35l32_codec_set_sysclk(struct snd_soc_codec *codec,\r\nint clk_id, int source, unsigned int freq, int dir)\r\n{\r\nunsigned int val;\r\nswitch (freq) {\r\ncase 6000000:\r\nval = CS35L32_MCLK_RATIO;\r\nbreak;\r\ncase 12000000:\r\nval = CS35L32_MCLK_DIV2_MASK | CS35L32_MCLK_RATIO;\r\nbreak;\r\ncase 6144000:\r\nval = 0;\r\nbreak;\r\ncase 12288000:\r\nval = CS35L32_MCLK_DIV2_MASK;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn snd_soc_update_bits(codec, CS35L32_CLK_CTL,\r\nCS35L32_MCLK_DIV2_MASK | CS35L32_MCLK_RATIO_MASK, val);\r\n}\r\nstatic int cs35l32_handle_of_data(struct i2c_client *i2c_client,\r\nstruct cs35l32_platform_data *pdata)\r\n{\r\nstruct device_node *np = i2c_client->dev.of_node;\r\nunsigned int val;\r\nif (of_property_read_u32(np, "cirrus,sdout-share", &val) >= 0)\r\npdata->sdout_share = val;\r\nof_property_read_u32(np, "cirrus,boost-manager", &val);\r\nswitch (val) {\r\ncase CS35L32_BOOST_MGR_AUTO:\r\ncase CS35L32_BOOST_MGR_AUTO_AUDIO:\r\ncase CS35L32_BOOST_MGR_BYPASS:\r\ncase CS35L32_BOOST_MGR_FIXED:\r\npdata->boost_mng = val;\r\nbreak;\r\ndefault:\r\ndev_err(&i2c_client->dev,\r\n"Wrong cirrus,boost-manager DT value %d\n", val);\r\npdata->boost_mng = CS35L32_BOOST_MGR_BYPASS;\r\n}\r\nof_property_read_u32(np, "cirrus,sdout-datacfg", &val);\r\nswitch (val) {\r\ncase CS35L32_DATA_CFG_LR_VP:\r\ncase CS35L32_DATA_CFG_LR_STAT:\r\ncase CS35L32_DATA_CFG_LR:\r\ncase CS35L32_DATA_CFG_LR_VPSTAT:\r\npdata->sdout_datacfg = val;\r\nbreak;\r\ndefault:\r\ndev_err(&i2c_client->dev,\r\n"Wrong cirrus,sdout-datacfg DT value %d\n", val);\r\npdata->sdout_datacfg = CS35L32_DATA_CFG_LR;\r\n}\r\nof_property_read_u32(np, "cirrus,battery-threshold", &val);\r\nswitch (val) {\r\ncase CS35L32_BATT_THRESH_3_1V:\r\ncase CS35L32_BATT_THRESH_3_2V:\r\ncase CS35L32_BATT_THRESH_3_3V:\r\ncase CS35L32_BATT_THRESH_3_4V:\r\npdata->batt_thresh = val;\r\nbreak;\r\ndefault:\r\ndev_err(&i2c_client->dev,\r\n"Wrong cirrus,battery-threshold DT value %d\n", val);\r\npdata->batt_thresh = CS35L32_BATT_THRESH_3_3V;\r\n}\r\nof_property_read_u32(np, "cirrus,battery-recovery", &val);\r\nswitch (val) {\r\ncase CS35L32_BATT_RECOV_3_1V:\r\ncase CS35L32_BATT_RECOV_3_2V:\r\ncase CS35L32_BATT_RECOV_3_3V:\r\ncase CS35L32_BATT_RECOV_3_4V:\r\ncase CS35L32_BATT_RECOV_3_5V:\r\ncase CS35L32_BATT_RECOV_3_6V:\r\npdata->batt_recov = val;\r\nbreak;\r\ndefault:\r\ndev_err(&i2c_client->dev,\r\n"Wrong cirrus,battery-recovery DT value %d\n", val);\r\npdata->batt_recov = CS35L32_BATT_RECOV_3_4V;\r\n}\r\nreturn 0;\r\n}\r\nstatic int cs35l32_i2c_probe(struct i2c_client *i2c_client,\r\nconst struct i2c_device_id *id)\r\n{\r\nstruct cs35l32_private *cs35l32;\r\nstruct cs35l32_platform_data *pdata =\r\ndev_get_platdata(&i2c_client->dev);\r\nint ret, i;\r\nunsigned int devid = 0;\r\nunsigned int reg;\r\ncs35l32 = devm_kzalloc(&i2c_client->dev, sizeof(struct cs35l32_private),\r\nGFP_KERNEL);\r\nif (!cs35l32) {\r\ndev_err(&i2c_client->dev, "could not allocate codec\n");\r\nreturn -ENOMEM;\r\n}\r\ni2c_set_clientdata(i2c_client, cs35l32);\r\ncs35l32->regmap = devm_regmap_init_i2c(i2c_client, &cs35l32_regmap);\r\nif (IS_ERR(cs35l32->regmap)) {\r\nret = PTR_ERR(cs35l32->regmap);\r\ndev_err(&i2c_client->dev, "regmap_init() failed: %d\n", ret);\r\nreturn ret;\r\n}\r\nif (pdata) {\r\ncs35l32->pdata = *pdata;\r\n} else {\r\npdata = devm_kzalloc(&i2c_client->dev,\r\nsizeof(struct cs35l32_platform_data),\r\nGFP_KERNEL);\r\nif (!pdata) {\r\ndev_err(&i2c_client->dev, "could not allocate pdata\n");\r\nreturn -ENOMEM;\r\n}\r\nif (i2c_client->dev.of_node) {\r\nret = cs35l32_handle_of_data(i2c_client,\r\n&cs35l32->pdata);\r\nif (ret != 0)\r\nreturn ret;\r\n}\r\n}\r\nfor (i = 0; i < ARRAY_SIZE(cs35l32->supplies); i++)\r\ncs35l32->supplies[i].supply = cs35l32_supply_names[i];\r\nret = devm_regulator_bulk_get(&i2c_client->dev,\r\nARRAY_SIZE(cs35l32->supplies),\r\ncs35l32->supplies);\r\nif (ret != 0) {\r\ndev_err(&i2c_client->dev,\r\n"Failed to request supplies: %d\n", ret);\r\nreturn ret;\r\n}\r\nret = regulator_bulk_enable(ARRAY_SIZE(cs35l32->supplies),\r\ncs35l32->supplies);\r\nif (ret != 0) {\r\ndev_err(&i2c_client->dev,\r\n"Failed to enable supplies: %d\n", ret);\r\nreturn ret;\r\n}\r\ncs35l32->reset_gpio = devm_gpiod_get_optional(&i2c_client->dev,\r\n"reset", GPIOD_OUT_LOW);\r\nif (IS_ERR(cs35l32->reset_gpio))\r\nreturn PTR_ERR(cs35l32->reset_gpio);\r\ngpiod_set_value_cansleep(cs35l32->reset_gpio, 1);\r\nret = regmap_read(cs35l32->regmap, CS35L32_DEVID_AB, &reg);\r\ndevid = (reg & 0xFF) << 12;\r\nret = regmap_read(cs35l32->regmap, CS35L32_DEVID_CD, &reg);\r\ndevid |= (reg & 0xFF) << 4;\r\nret = regmap_read(cs35l32->regmap, CS35L32_DEVID_E, &reg);\r\ndevid |= (reg & 0xF0) >> 4;\r\nif (devid != CS35L32_CHIP_ID) {\r\nret = -ENODEV;\r\ndev_err(&i2c_client->dev,\r\n"CS35L32 Device ID (%X). Expected %X\n",\r\ndevid, CS35L32_CHIP_ID);\r\nreturn ret;\r\n}\r\nret = regmap_read(cs35l32->regmap, CS35L32_REV_ID, &reg);\r\nif (ret < 0) {\r\ndev_err(&i2c_client->dev, "Get Revision ID failed\n");\r\nreturn ret;\r\n}\r\nret = regmap_register_patch(cs35l32->regmap, cs35l32_monitor_patch,\r\nARRAY_SIZE(cs35l32_monitor_patch));\r\nif (ret < 0) {\r\ndev_err(&i2c_client->dev, "Failed to apply errata patch\n");\r\nreturn ret;\r\n}\r\ndev_info(&i2c_client->dev,\r\n"Cirrus Logic CS35L32, Revision: %02X\n", reg & 0xFF);\r\nif (cs35l32->pdata.boost_mng)\r\nregmap_update_bits(cs35l32->regmap, CS35L32_AUDIO_LED_MNGR,\r\nCS35L32_BOOST_MASK,\r\ncs35l32->pdata.boost_mng);\r\nif (cs35l32->pdata.sdout_share)\r\nregmap_update_bits(cs35l32->regmap, CS35L32_ADSP_CTL,\r\nCS35L32_ADSP_SHARE_MASK,\r\ncs35l32->pdata.sdout_share << 3);\r\nif (cs35l32->pdata.sdout_datacfg)\r\nregmap_update_bits(cs35l32->regmap, CS35L32_ADSP_CTL,\r\nCS35L32_ADSP_DATACFG_MASK,\r\ncs35l32->pdata.sdout_datacfg << 4);\r\nif (cs35l32->pdata.batt_recov)\r\nregmap_update_bits(cs35l32->regmap, CS35L32_BATT_THRESHOLD,\r\nCS35L32_BATT_REC_MASK,\r\ncs35l32->pdata.batt_recov << 1);\r\nif (cs35l32->pdata.batt_thresh)\r\nregmap_update_bits(cs35l32->regmap, CS35L32_BATT_THRESHOLD,\r\nCS35L32_BATT_THRESH_MASK,\r\ncs35l32->pdata.batt_thresh << 4);\r\nregmap_update_bits(cs35l32->regmap, CS35L32_PWRCTL1, CS35L32_PDN_AMP,\r\nCS35L32_PDN_AMP);\r\nret = regmap_read(cs35l32->regmap, CS35L32_INT_STATUS_1, &reg);\r\nret = snd_soc_register_codec(&i2c_client->dev,\r\n&soc_codec_dev_cs35l32, cs35l32_dai,\r\nARRAY_SIZE(cs35l32_dai));\r\nif (ret < 0)\r\ngoto err_disable;\r\nreturn 0;\r\nerr_disable:\r\nregulator_bulk_disable(ARRAY_SIZE(cs35l32->supplies),\r\ncs35l32->supplies);\r\nreturn ret;\r\n}\r\nstatic int cs35l32_i2c_remove(struct i2c_client *i2c_client)\r\n{\r\nstruct cs35l32_private *cs35l32 = i2c_get_clientdata(i2c_client);\r\nsnd_soc_unregister_codec(&i2c_client->dev);\r\ngpiod_set_value_cansleep(cs35l32->reset_gpio, 0);\r\nreturn 0;\r\n}\r\nstatic int cs35l32_runtime_suspend(struct device *dev)\r\n{\r\nstruct cs35l32_private *cs35l32 = dev_get_drvdata(dev);\r\nregcache_cache_only(cs35l32->regmap, true);\r\nregcache_mark_dirty(cs35l32->regmap);\r\ngpiod_set_value_cansleep(cs35l32->reset_gpio, 0);\r\nregulator_bulk_disable(ARRAY_SIZE(cs35l32->supplies),\r\ncs35l32->supplies);\r\nreturn 0;\r\n}\r\nstatic int cs35l32_runtime_resume(struct device *dev)\r\n{\r\nstruct cs35l32_private *cs35l32 = dev_get_drvdata(dev);\r\nint ret;\r\nret = regulator_bulk_enable(ARRAY_SIZE(cs35l32->supplies),\r\ncs35l32->supplies);\r\nif (ret != 0) {\r\ndev_err(dev, "Failed to enable supplies: %d\n",\r\nret);\r\nreturn ret;\r\n}\r\ngpiod_set_value_cansleep(cs35l32->reset_gpio, 1);\r\nregcache_cache_only(cs35l32->regmap, false);\r\nregcache_sync(cs35l32->regmap);\r\nreturn 0;\r\n}
