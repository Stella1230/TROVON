static void uart_clps711x_stop_tx(struct uart_port *port)\r\n{\r\nstruct clps711x_port *s = dev_get_drvdata(port->dev);\r\nif (s->tx_enabled) {\r\ndisable_irq(port->irq);\r\ns->tx_enabled = 0;\r\n}\r\n}\r\nstatic void uart_clps711x_start_tx(struct uart_port *port)\r\n{\r\nstruct clps711x_port *s = dev_get_drvdata(port->dev);\r\nif (!s->tx_enabled) {\r\ns->tx_enabled = 1;\r\nenable_irq(port->irq);\r\n}\r\n}\r\nstatic irqreturn_t uart_clps711x_int_rx(int irq, void *dev_id)\r\n{\r\nstruct uart_port *port = dev_id;\r\nstruct clps711x_port *s = dev_get_drvdata(port->dev);\r\nunsigned int status, flg;\r\nu16 ch;\r\nfor (;;) {\r\nu32 sysflg = 0;\r\nregmap_read(s->syscon, SYSFLG_OFFSET, &sysflg);\r\nif (sysflg & SYSFLG_URXFE)\r\nbreak;\r\nch = readw(port->membase + UARTDR_OFFSET);\r\nstatus = ch & (UARTDR_FRMERR | UARTDR_PARERR | UARTDR_OVERR);\r\nch &= 0xff;\r\nport->icount.rx++;\r\nflg = TTY_NORMAL;\r\nif (unlikely(status)) {\r\nif (status & UARTDR_PARERR)\r\nport->icount.parity++;\r\nelse if (status & UARTDR_FRMERR)\r\nport->icount.frame++;\r\nelse if (status & UARTDR_OVERR)\r\nport->icount.overrun++;\r\nstatus &= port->read_status_mask;\r\nif (status & UARTDR_PARERR)\r\nflg = TTY_PARITY;\r\nelse if (status & UARTDR_FRMERR)\r\nflg = TTY_FRAME;\r\nelse if (status & UARTDR_OVERR)\r\nflg = TTY_OVERRUN;\r\n}\r\nif (uart_handle_sysrq_char(port, ch))\r\ncontinue;\r\nif (status & port->ignore_status_mask)\r\ncontinue;\r\nuart_insert_char(port, status, UARTDR_OVERR, ch, flg);\r\n}\r\ntty_flip_buffer_push(&port->state->port);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic irqreturn_t uart_clps711x_int_tx(int irq, void *dev_id)\r\n{\r\nstruct uart_port *port = dev_id;\r\nstruct clps711x_port *s = dev_get_drvdata(port->dev);\r\nstruct circ_buf *xmit = &port->state->xmit;\r\nif (port->x_char) {\r\nwritew(port->x_char, port->membase + UARTDR_OFFSET);\r\nport->icount.tx++;\r\nport->x_char = 0;\r\nreturn IRQ_HANDLED;\r\n}\r\nif (uart_circ_empty(xmit) || uart_tx_stopped(port)) {\r\nif (s->tx_enabled) {\r\ndisable_irq_nosync(port->irq);\r\ns->tx_enabled = 0;\r\n}\r\nreturn IRQ_HANDLED;\r\n}\r\nwhile (!uart_circ_empty(xmit)) {\r\nu32 sysflg = 0;\r\nwritew(xmit->buf[xmit->tail], port->membase + UARTDR_OFFSET);\r\nxmit->tail = (xmit->tail + 1) & (UART_XMIT_SIZE - 1);\r\nport->icount.tx++;\r\nregmap_read(s->syscon, SYSFLG_OFFSET, &sysflg);\r\nif (sysflg & SYSFLG_UTXFF)\r\nbreak;\r\n}\r\nif (uart_circ_chars_pending(xmit) < WAKEUP_CHARS)\r\nuart_write_wakeup(port);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic unsigned int uart_clps711x_tx_empty(struct uart_port *port)\r\n{\r\nstruct clps711x_port *s = dev_get_drvdata(port->dev);\r\nu32 sysflg = 0;\r\nregmap_read(s->syscon, SYSFLG_OFFSET, &sysflg);\r\nreturn (sysflg & SYSFLG_UBUSY) ? 0 : TIOCSER_TEMT;\r\n}\r\nstatic unsigned int uart_clps711x_get_mctrl(struct uart_port *port)\r\n{\r\nunsigned int result = TIOCM_DSR | TIOCM_CTS | TIOCM_CAR;\r\nstruct clps711x_port *s = dev_get_drvdata(port->dev);\r\nreturn mctrl_gpio_get(s->gpios, &result);\r\n}\r\nstatic void uart_clps711x_set_mctrl(struct uart_port *port, unsigned int mctrl)\r\n{\r\nstruct clps711x_port *s = dev_get_drvdata(port->dev);\r\nmctrl_gpio_set(s->gpios, mctrl);\r\n}\r\nstatic void uart_clps711x_break_ctl(struct uart_port *port, int break_state)\r\n{\r\nunsigned int ubrlcr;\r\nubrlcr = readl(port->membase + UBRLCR_OFFSET);\r\nif (break_state)\r\nubrlcr |= UBRLCR_BREAK;\r\nelse\r\nubrlcr &= ~UBRLCR_BREAK;\r\nwritel(ubrlcr, port->membase + UBRLCR_OFFSET);\r\n}\r\nstatic void uart_clps711x_set_ldisc(struct uart_port *port,\r\nstruct ktermios *termios)\r\n{\r\nif (!port->line) {\r\nstruct clps711x_port *s = dev_get_drvdata(port->dev);\r\nregmap_update_bits(s->syscon, SYSCON_OFFSET, SYSCON1_SIREN,\r\n(termios->c_line == N_IRDA) ? SYSCON1_SIREN : 0);\r\n}\r\n}\r\nstatic int uart_clps711x_startup(struct uart_port *port)\r\n{\r\nstruct clps711x_port *s = dev_get_drvdata(port->dev);\r\nwritel(readl(port->membase + UBRLCR_OFFSET) & ~UBRLCR_BREAK,\r\nport->membase + UBRLCR_OFFSET);\r\nreturn regmap_update_bits(s->syscon, SYSCON_OFFSET,\r\nSYSCON_UARTEN, SYSCON_UARTEN);\r\n}\r\nstatic void uart_clps711x_shutdown(struct uart_port *port)\r\n{\r\nstruct clps711x_port *s = dev_get_drvdata(port->dev);\r\nregmap_update_bits(s->syscon, SYSCON_OFFSET, SYSCON_UARTEN, 0);\r\n}\r\nstatic void uart_clps711x_set_termios(struct uart_port *port,\r\nstruct ktermios *termios,\r\nstruct ktermios *old)\r\n{\r\nu32 ubrlcr;\r\nunsigned int baud, quot;\r\ntermios->c_cflag &= ~CMSPAR;\r\ntermios->c_iflag &= ~(BRKINT | IGNBRK);\r\nbaud = uart_get_baud_rate(port, termios, old, port->uartclk / 4096,\r\nport->uartclk / 16);\r\nquot = uart_get_divisor(port, baud);\r\nswitch (termios->c_cflag & CSIZE) {\r\ncase CS5:\r\nubrlcr = UBRLCR_WRDLEN5;\r\nbreak;\r\ncase CS6:\r\nubrlcr = UBRLCR_WRDLEN6;\r\nbreak;\r\ncase CS7:\r\nubrlcr = UBRLCR_WRDLEN7;\r\nbreak;\r\ncase CS8:\r\ndefault:\r\nubrlcr = UBRLCR_WRDLEN8;\r\nbreak;\r\n}\r\nif (termios->c_cflag & CSTOPB)\r\nubrlcr |= UBRLCR_XSTOP;\r\nif (termios->c_cflag & PARENB) {\r\nubrlcr |= UBRLCR_PRTEN;\r\nif (!(termios->c_cflag & PARODD))\r\nubrlcr |= UBRLCR_EVENPRT;\r\n}\r\nubrlcr |= UBRLCR_FIFOEN;\r\nport->read_status_mask = UARTDR_OVERR;\r\nif (termios->c_iflag & INPCK)\r\nport->read_status_mask |= UARTDR_PARERR | UARTDR_FRMERR;\r\nport->ignore_status_mask = 0;\r\nif (!(termios->c_cflag & CREAD))\r\nport->ignore_status_mask |= UARTDR_OVERR | UARTDR_PARERR |\r\nUARTDR_FRMERR;\r\nuart_update_timeout(port, termios->c_cflag, baud);\r\nwritel(ubrlcr | (quot - 1), port->membase + UBRLCR_OFFSET);\r\n}\r\nstatic const char *uart_clps711x_type(struct uart_port *port)\r\n{\r\nreturn (port->type == PORT_CLPS711X) ? "CLPS711X" : NULL;\r\n}\r\nstatic void uart_clps711x_config_port(struct uart_port *port, int flags)\r\n{\r\nif (flags & UART_CONFIG_TYPE)\r\nport->type = PORT_CLPS711X;\r\n}\r\nstatic void uart_clps711x_nop_void(struct uart_port *port)\r\n{\r\n}\r\nstatic int uart_clps711x_nop_int(struct uart_port *port)\r\n{\r\nreturn 0;\r\n}\r\nstatic void uart_clps711x_console_putchar(struct uart_port *port, int ch)\r\n{\r\nstruct clps711x_port *s = dev_get_drvdata(port->dev);\r\nu32 sysflg = 0;\r\ndo {\r\nregmap_read(s->syscon, SYSFLG_OFFSET, &sysflg);\r\n} while (sysflg & SYSFLG_UTXFF);\r\nwritew(ch, port->membase + UARTDR_OFFSET);\r\n}\r\nstatic void uart_clps711x_console_write(struct console *co, const char *c,\r\nunsigned n)\r\n{\r\nstruct uart_port *port = clps711x_uart.state[co->index].uart_port;\r\nstruct clps711x_port *s = dev_get_drvdata(port->dev);\r\nu32 sysflg = 0;\r\nuart_console_write(port, c, n, uart_clps711x_console_putchar);\r\ndo {\r\nregmap_read(s->syscon, SYSFLG_OFFSET, &sysflg);\r\n} while (sysflg & SYSFLG_UBUSY);\r\n}\r\nstatic int uart_clps711x_console_setup(struct console *co, char *options)\r\n{\r\nint baud = 38400, bits = 8, parity = 'n', flow = 'n';\r\nint ret, index = co->index;\r\nstruct clps711x_port *s;\r\nstruct uart_port *port;\r\nunsigned int quot;\r\nu32 ubrlcr;\r\nif (index < 0 || index >= UART_CLPS711X_NR)\r\nreturn -EINVAL;\r\nport = clps711x_uart.state[index].uart_port;\r\nif (!port)\r\nreturn -ENODEV;\r\ns = dev_get_drvdata(port->dev);\r\nif (!options) {\r\nu32 syscon = 0;\r\nregmap_read(s->syscon, SYSCON_OFFSET, &syscon);\r\nif (syscon & SYSCON_UARTEN) {\r\nubrlcr = readl(port->membase + UBRLCR_OFFSET);\r\nif (ubrlcr & UBRLCR_PRTEN) {\r\nif (ubrlcr & UBRLCR_EVENPRT)\r\nparity = 'e';\r\nelse\r\nparity = 'o';\r\n}\r\nif ((ubrlcr & UBRLCR_WRDLEN_MASK) == UBRLCR_WRDLEN7)\r\nbits = 7;\r\nquot = ubrlcr & UBRLCR_BAUD_MASK;\r\nbaud = port->uartclk / (16 * (quot + 1));\r\n}\r\n} else\r\nuart_parse_options(options, &baud, &parity, &bits, &flow);\r\nret = uart_set_options(port, co, baud, parity, bits, flow);\r\nif (ret)\r\nreturn ret;\r\nreturn regmap_update_bits(s->syscon, SYSCON_OFFSET,\r\nSYSCON_UARTEN, SYSCON_UARTEN);\r\n}\r\nstatic int uart_clps711x_probe(struct platform_device *pdev)\r\n{\r\nstruct device_node *np = pdev->dev.of_node;\r\nint ret, index = np ? of_alias_get_id(np, "serial") : pdev->id;\r\nstruct clps711x_port *s;\r\nstruct resource *res;\r\nstruct clk *uart_clk;\r\nif (index < 0 || index >= UART_CLPS711X_NR)\r\nreturn -EINVAL;\r\ns = devm_kzalloc(&pdev->dev, sizeof(*s), GFP_KERNEL);\r\nif (!s)\r\nreturn -ENOMEM;\r\nuart_clk = devm_clk_get(&pdev->dev, NULL);\r\nif (IS_ERR(uart_clk))\r\nreturn PTR_ERR(uart_clk);\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\ns->port.membase = devm_ioremap_resource(&pdev->dev, res);\r\nif (IS_ERR(s->port.membase))\r\nreturn PTR_ERR(s->port.membase);\r\ns->port.irq = platform_get_irq(pdev, 0);\r\nif (IS_ERR_VALUE(s->port.irq))\r\nreturn s->port.irq;\r\ns->rx_irq = platform_get_irq(pdev, 1);\r\nif (IS_ERR_VALUE(s->rx_irq))\r\nreturn s->rx_irq;\r\nif (!np) {\r\nchar syscon_name[9];\r\nsprintf(syscon_name, "syscon.%i", index + 1);\r\ns->syscon = syscon_regmap_lookup_by_pdevname(syscon_name);\r\nif (IS_ERR(s->syscon))\r\nreturn PTR_ERR(s->syscon);\r\n} else {\r\ns->syscon = syscon_regmap_lookup_by_phandle(np, "syscon");\r\nif (IS_ERR(s->syscon))\r\nreturn PTR_ERR(s->syscon);\r\n}\r\ns->port.line = index;\r\ns->port.dev = &pdev->dev;\r\ns->port.iotype = UPIO_MEM32;\r\ns->port.mapbase = res->start;\r\ns->port.type = PORT_CLPS711X;\r\ns->port.fifosize = 16;\r\ns->port.flags = UPF_SKIP_TEST | UPF_FIXED_TYPE;\r\ns->port.uartclk = clk_get_rate(uart_clk);\r\ns->port.ops = &uart_clps711x_ops;\r\nplatform_set_drvdata(pdev, s);\r\ns->gpios = mctrl_gpio_init_noauto(&pdev->dev, 0);\r\nif (IS_ERR(s->gpios))\r\nreturn PTR_ERR(s->gpios);\r\nret = uart_add_one_port(&clps711x_uart, &s->port);\r\nif (ret)\r\nreturn ret;\r\nif (!uart_console(&s->port))\r\nregmap_update_bits(s->syscon, SYSCON_OFFSET, SYSCON_UARTEN, 0);\r\ns->tx_enabled = 1;\r\nret = devm_request_irq(&pdev->dev, s->port.irq, uart_clps711x_int_tx, 0,\r\ndev_name(&pdev->dev), &s->port);\r\nif (ret) {\r\nuart_remove_one_port(&clps711x_uart, &s->port);\r\nreturn ret;\r\n}\r\nret = devm_request_irq(&pdev->dev, s->rx_irq, uart_clps711x_int_rx, 0,\r\ndev_name(&pdev->dev), &s->port);\r\nif (ret)\r\nuart_remove_one_port(&clps711x_uart, &s->port);\r\nreturn ret;\r\n}\r\nstatic int uart_clps711x_remove(struct platform_device *pdev)\r\n{\r\nstruct clps711x_port *s = platform_get_drvdata(pdev);\r\nreturn uart_remove_one_port(&clps711x_uart, &s->port);\r\n}\r\nstatic int __init uart_clps711x_init(void)\r\n{\r\nint ret;\r\n#ifdef CONFIG_SERIAL_CLPS711X_CONSOLE\r\nclps711x_uart.cons = &clps711x_console;\r\nclps711x_console.data = &clps711x_uart;\r\n#endif\r\nret = uart_register_driver(&clps711x_uart);\r\nif (ret)\r\nreturn ret;\r\nreturn platform_driver_register(&clps711x_uart_platform);\r\n}\r\nstatic void __exit uart_clps711x_exit(void)\r\n{\r\nplatform_driver_unregister(&clps711x_uart_platform);\r\nuart_unregister_driver(&clps711x_uart);\r\n}
