static int start_atomic(struct msm_drm_private *priv, uint32_t crtc_mask)\r\n{\r\nint ret;\r\nspin_lock(&priv->pending_crtcs_event.lock);\r\nret = wait_event_interruptible_locked(priv->pending_crtcs_event,\r\n!(priv->pending_crtcs & crtc_mask));\r\nif (ret == 0) {\r\nDBG("start: %08x", crtc_mask);\r\npriv->pending_crtcs |= crtc_mask;\r\n}\r\nspin_unlock(&priv->pending_crtcs_event.lock);\r\nreturn ret;\r\n}\r\nstatic void end_atomic(struct msm_drm_private *priv, uint32_t crtc_mask)\r\n{\r\nspin_lock(&priv->pending_crtcs_event.lock);\r\nDBG("end: %08x", crtc_mask);\r\npriv->pending_crtcs &= ~crtc_mask;\r\nwake_up_all_locked(&priv->pending_crtcs_event);\r\nspin_unlock(&priv->pending_crtcs_event.lock);\r\n}\r\nstatic struct msm_commit *commit_init(struct drm_atomic_state *state)\r\n{\r\nstruct msm_commit *c = kzalloc(sizeof(*c), GFP_KERNEL);\r\nif (!c)\r\nreturn NULL;\r\nc->dev = state->dev;\r\nc->state = state;\r\nINIT_FENCE_CB(&c->fence_cb, fence_cb);\r\nreturn c;\r\n}\r\nstatic void commit_destroy(struct msm_commit *c)\r\n{\r\nend_atomic(c->dev->dev_private, c->crtc_mask);\r\nkfree(c);\r\n}\r\nstatic void msm_atomic_wait_for_commit_done(struct drm_device *dev,\r\nstruct drm_atomic_state *old_state)\r\n{\r\nstruct drm_crtc *crtc;\r\nstruct msm_drm_private *priv = old_state->dev->dev_private;\r\nstruct msm_kms *kms = priv->kms;\r\nint ncrtcs = old_state->dev->mode_config.num_crtc;\r\nint i;\r\nfor (i = 0; i < ncrtcs; i++) {\r\ncrtc = old_state->crtcs[i];\r\nif (!crtc)\r\ncontinue;\r\nif (!crtc->state->enable)\r\ncontinue;\r\nif (old_state->legacy_cursor_update)\r\ncontinue;\r\nkms->funcs->wait_for_crtc_commit_done(kms, crtc);\r\n}\r\n}\r\nstatic void complete_commit(struct msm_commit *c)\r\n{\r\nstruct drm_atomic_state *state = c->state;\r\nstruct drm_device *dev = state->dev;\r\nstruct msm_drm_private *priv = dev->dev_private;\r\nstruct msm_kms *kms = priv->kms;\r\nkms->funcs->prepare_commit(kms, state);\r\ndrm_atomic_helper_commit_modeset_disables(dev, state);\r\ndrm_atomic_helper_commit_planes(dev, state, false);\r\ndrm_atomic_helper_commit_modeset_enables(dev, state);\r\nmsm_atomic_wait_for_commit_done(dev, state);\r\ndrm_atomic_helper_cleanup_planes(dev, state);\r\nkms->funcs->complete_commit(kms, state);\r\ndrm_atomic_state_free(state);\r\ncommit_destroy(c);\r\n}\r\nstatic void fence_cb(struct msm_fence_cb *cb)\r\n{\r\nstruct msm_commit *c =\r\ncontainer_of(cb, struct msm_commit, fence_cb);\r\ncomplete_commit(c);\r\n}\r\nstatic void add_fb(struct msm_commit *c, struct drm_framebuffer *fb)\r\n{\r\nstruct drm_gem_object *obj = msm_framebuffer_bo(fb, 0);\r\nc->fence = max(c->fence, msm_gem_fence(to_msm_bo(obj), MSM_PREP_READ));\r\n}\r\nint msm_atomic_check(struct drm_device *dev,\r\nstruct drm_atomic_state *state)\r\n{\r\nint ret;\r\nret = drm_atomic_helper_check_planes(dev, state);\r\nif (ret)\r\nreturn ret;\r\nret = drm_atomic_helper_check_modeset(dev, state);\r\nif (ret)\r\nreturn ret;\r\nreturn ret;\r\n}\r\nint msm_atomic_commit(struct drm_device *dev,\r\nstruct drm_atomic_state *state, bool async)\r\n{\r\nint nplanes = dev->mode_config.num_total_plane;\r\nint ncrtcs = dev->mode_config.num_crtc;\r\nktime_t timeout;\r\nstruct msm_commit *c;\r\nint i, ret;\r\nret = drm_atomic_helper_prepare_planes(dev, state);\r\nif (ret)\r\nreturn ret;\r\nc = commit_init(state);\r\nif (!c) {\r\nret = -ENOMEM;\r\ngoto error;\r\n}\r\nfor (i = 0; i < ncrtcs; i++) {\r\nstruct drm_crtc *crtc = state->crtcs[i];\r\nif (!crtc)\r\ncontinue;\r\nc->crtc_mask |= (1 << drm_crtc_index(crtc));\r\n}\r\nfor (i = 0; i < nplanes; i++) {\r\nstruct drm_plane *plane = state->planes[i];\r\nstruct drm_plane_state *new_state = state->plane_states[i];\r\nif (!plane)\r\ncontinue;\r\nif ((plane->state->fb != new_state->fb) && new_state->fb)\r\nadd_fb(c, new_state->fb);\r\n}\r\nret = start_atomic(dev->dev_private, c->crtc_mask);\r\nif (ret) {\r\nkfree(c);\r\ngoto error;\r\n}\r\ndrm_atomic_helper_swap_state(dev, state);\r\nif (async) {\r\nmsm_queue_fence_cb(dev, &c->fence_cb, c->fence);\r\nreturn 0;\r\n}\r\ntimeout = ktime_add_ms(ktime_get(), 1000);\r\nmsm_wait_fence(dev, c->fence, &timeout, false);\r\ncomplete_commit(c);\r\nreturn 0;\r\nerror:\r\ndrm_atomic_helper_cleanup_planes(dev, state);\r\nreturn ret;\r\n}
