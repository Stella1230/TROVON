static int __must_check fsl_mc_resource_pool_add_device(struct fsl_mc_bus\r\n*mc_bus,\r\nenum fsl_mc_pool_type\r\npool_type,\r\nstruct fsl_mc_device\r\n*mc_dev)\r\n{\r\nstruct fsl_mc_resource_pool *res_pool;\r\nstruct fsl_mc_resource *resource;\r\nstruct fsl_mc_device *mc_bus_dev = &mc_bus->mc_dev;\r\nint error = -EINVAL;\r\nbool mutex_locked = false;\r\nif (WARN_ON(pool_type < 0 || pool_type >= FSL_MC_NUM_POOL_TYPES))\r\ngoto out;\r\nif (WARN_ON(!FSL_MC_IS_ALLOCATABLE(mc_dev->obj_desc.type)))\r\ngoto out;\r\nif (WARN_ON(mc_dev->resource))\r\ngoto out;\r\nres_pool = &mc_bus->resource_pools[pool_type];\r\nif (WARN_ON(res_pool->type != pool_type))\r\ngoto out;\r\nif (WARN_ON(res_pool->mc_bus != mc_bus))\r\ngoto out;\r\nmutex_lock(&res_pool->mutex);\r\nmutex_locked = true;\r\nif (WARN_ON(res_pool->max_count < 0))\r\ngoto out;\r\nif (WARN_ON(res_pool->free_count < 0 ||\r\nres_pool->free_count > res_pool->max_count))\r\ngoto out;\r\nresource = devm_kzalloc(&mc_bus_dev->dev, sizeof(*resource),\r\nGFP_KERNEL);\r\nif (!resource) {\r\nerror = -ENOMEM;\r\ndev_err(&mc_bus_dev->dev,\r\n"Failed to allocate memory for fsl_mc_resource\n");\r\ngoto out;\r\n}\r\nresource->type = pool_type;\r\nresource->id = mc_dev->obj_desc.id;\r\nresource->data = mc_dev;\r\nresource->parent_pool = res_pool;\r\nINIT_LIST_HEAD(&resource->node);\r\nlist_add_tail(&resource->node, &res_pool->free_list);\r\nmc_dev->resource = resource;\r\nres_pool->free_count++;\r\nres_pool->max_count++;\r\nerror = 0;\r\nout:\r\nif (mutex_locked)\r\nmutex_unlock(&res_pool->mutex);\r\nreturn error;\r\n}\r\nstatic int __must_check fsl_mc_resource_pool_remove_device(struct fsl_mc_device\r\n*mc_dev)\r\n{\r\nstruct fsl_mc_device *mc_bus_dev;\r\nstruct fsl_mc_bus *mc_bus;\r\nstruct fsl_mc_resource_pool *res_pool;\r\nstruct fsl_mc_resource *resource;\r\nint error = -EINVAL;\r\nbool mutex_locked = false;\r\nif (WARN_ON(!FSL_MC_IS_ALLOCATABLE(mc_dev->obj_desc.type)))\r\ngoto out;\r\nresource = mc_dev->resource;\r\nif (WARN_ON(!resource || resource->data != mc_dev))\r\ngoto out;\r\nmc_bus_dev = to_fsl_mc_device(mc_dev->dev.parent);\r\nmc_bus = to_fsl_mc_bus(mc_bus_dev);\r\nres_pool = resource->parent_pool;\r\nif (WARN_ON(res_pool != &mc_bus->resource_pools[resource->type]))\r\ngoto out;\r\nmutex_lock(&res_pool->mutex);\r\nmutex_locked = true;\r\nif (WARN_ON(res_pool->max_count <= 0))\r\ngoto out;\r\nif (WARN_ON(res_pool->free_count <= 0 ||\r\nres_pool->free_count > res_pool->max_count))\r\ngoto out;\r\nif (list_empty(&resource->node)) {\r\nerror = -EBUSY;\r\ndev_err(&mc_bus_dev->dev,\r\n"Device %s cannot be removed from resource pool\n",\r\ndev_name(&mc_dev->dev));\r\ngoto out;\r\n}\r\nlist_del(&resource->node);\r\nINIT_LIST_HEAD(&resource->node);\r\nres_pool->free_count--;\r\nres_pool->max_count--;\r\ndevm_kfree(&mc_bus_dev->dev, resource);\r\nmc_dev->resource = NULL;\r\nerror = 0;\r\nout:\r\nif (mutex_locked)\r\nmutex_unlock(&res_pool->mutex);\r\nreturn error;\r\n}\r\nstatic int __must_check object_type_to_pool_type(const char *object_type,\r\nenum fsl_mc_pool_type\r\n*pool_type)\r\n{\r\nunsigned int i;\r\nfor (i = 0; i < ARRAY_SIZE(fsl_mc_pool_type_strings); i++) {\r\nif (strcmp(object_type, fsl_mc_pool_type_strings[i]) == 0) {\r\n*pool_type = i;\r\nreturn 0;\r\n}\r\n}\r\nreturn -EINVAL;\r\n}\r\nint __must_check fsl_mc_resource_allocate(struct fsl_mc_bus *mc_bus,\r\nenum fsl_mc_pool_type pool_type,\r\nstruct fsl_mc_resource **new_resource)\r\n{\r\nstruct fsl_mc_resource_pool *res_pool;\r\nstruct fsl_mc_resource *resource;\r\nstruct fsl_mc_device *mc_bus_dev = &mc_bus->mc_dev;\r\nint error = -EINVAL;\r\nbool mutex_locked = false;\r\nBUILD_BUG_ON(ARRAY_SIZE(fsl_mc_pool_type_strings) !=\r\nFSL_MC_NUM_POOL_TYPES);\r\n*new_resource = NULL;\r\nif (WARN_ON(pool_type < 0 || pool_type >= FSL_MC_NUM_POOL_TYPES))\r\ngoto error;\r\nres_pool = &mc_bus->resource_pools[pool_type];\r\nif (WARN_ON(res_pool->mc_bus != mc_bus))\r\ngoto error;\r\nmutex_lock(&res_pool->mutex);\r\nmutex_locked = true;\r\nresource = list_first_entry_or_null(&res_pool->free_list,\r\nstruct fsl_mc_resource, node);\r\nif (!resource) {\r\nWARN_ON(res_pool->free_count != 0);\r\nerror = -ENXIO;\r\ndev_err(&mc_bus_dev->dev,\r\n"No more resources of type %s left\n",\r\nfsl_mc_pool_type_strings[pool_type]);\r\ngoto error;\r\n}\r\nif (WARN_ON(resource->type != pool_type))\r\ngoto error;\r\nif (WARN_ON(resource->parent_pool != res_pool))\r\ngoto error;\r\nif (WARN_ON(res_pool->free_count <= 0 ||\r\nres_pool->free_count > res_pool->max_count))\r\ngoto error;\r\nlist_del(&resource->node);\r\nINIT_LIST_HEAD(&resource->node);\r\nres_pool->free_count--;\r\nmutex_unlock(&res_pool->mutex);\r\n*new_resource = resource;\r\nreturn 0;\r\nerror:\r\nif (mutex_locked)\r\nmutex_unlock(&res_pool->mutex);\r\nreturn error;\r\n}\r\nvoid fsl_mc_resource_free(struct fsl_mc_resource *resource)\r\n{\r\nstruct fsl_mc_resource_pool *res_pool;\r\nbool mutex_locked = false;\r\nres_pool = resource->parent_pool;\r\nif (WARN_ON(resource->type != res_pool->type))\r\ngoto out;\r\nmutex_lock(&res_pool->mutex);\r\nmutex_locked = true;\r\nif (WARN_ON(res_pool->free_count < 0 ||\r\nres_pool->free_count >= res_pool->max_count))\r\ngoto out;\r\nif (WARN_ON(!list_empty(&resource->node)))\r\ngoto out;\r\nlist_add_tail(&resource->node, &res_pool->free_list);\r\nres_pool->free_count++;\r\nout:\r\nif (mutex_locked)\r\nmutex_unlock(&res_pool->mutex);\r\n}\r\nint __must_check fsl_mc_portal_allocate(struct fsl_mc_device *mc_dev,\r\nu16 mc_io_flags,\r\nstruct fsl_mc_io **new_mc_io)\r\n{\r\nstruct fsl_mc_device *mc_bus_dev;\r\nstruct fsl_mc_bus *mc_bus;\r\nphys_addr_t mc_portal_phys_addr;\r\nsize_t mc_portal_size;\r\nstruct fsl_mc_device *dpmcp_dev;\r\nint error = -EINVAL;\r\nstruct fsl_mc_resource *resource = NULL;\r\nstruct fsl_mc_io *mc_io = NULL;\r\nif (mc_dev->flags & FSL_MC_IS_DPRC) {\r\nmc_bus_dev = mc_dev;\r\n} else {\r\nif (WARN_ON(mc_dev->dev.parent->bus != &fsl_mc_bus_type))\r\nreturn error;\r\nmc_bus_dev = to_fsl_mc_device(mc_dev->dev.parent);\r\n}\r\nmc_bus = to_fsl_mc_bus(mc_bus_dev);\r\n*new_mc_io = NULL;\r\nerror = fsl_mc_resource_allocate(mc_bus, FSL_MC_POOL_DPMCP, &resource);\r\nif (error < 0)\r\nreturn error;\r\ndpmcp_dev = resource->data;\r\nif (WARN_ON(!dpmcp_dev))\r\ngoto error_cleanup_resource;\r\nif (WARN_ON(dpmcp_dev->obj_desc.region_count == 0))\r\ngoto error_cleanup_resource;\r\nmc_portal_phys_addr = dpmcp_dev->regions[0].start;\r\nmc_portal_size = dpmcp_dev->regions[0].end -\r\ndpmcp_dev->regions[0].start + 1;\r\nif (WARN_ON(mc_portal_size != mc_bus_dev->mc_io->portal_size))\r\ngoto error_cleanup_resource;\r\nerror = fsl_create_mc_io(&mc_bus_dev->dev,\r\nmc_portal_phys_addr,\r\nmc_portal_size, dpmcp_dev,\r\nmc_io_flags, &mc_io);\r\nif (error < 0)\r\ngoto error_cleanup_resource;\r\n*new_mc_io = mc_io;\r\nreturn 0;\r\nerror_cleanup_resource:\r\nfsl_mc_resource_free(resource);\r\nreturn error;\r\n}\r\nvoid fsl_mc_portal_free(struct fsl_mc_io *mc_io)\r\n{\r\nstruct fsl_mc_device *dpmcp_dev;\r\nstruct fsl_mc_resource *resource;\r\ndpmcp_dev = mc_io->dpmcp_dev;\r\nif (WARN_ON(!dpmcp_dev))\r\nreturn;\r\nresource = dpmcp_dev->resource;\r\nif (WARN_ON(!resource || resource->type != FSL_MC_POOL_DPMCP))\r\nreturn;\r\nif (WARN_ON(resource->data != dpmcp_dev))\r\nreturn;\r\nfsl_destroy_mc_io(mc_io);\r\nfsl_mc_resource_free(resource);\r\n}\r\nint fsl_mc_portal_reset(struct fsl_mc_io *mc_io)\r\n{\r\nint error;\r\nstruct fsl_mc_device *dpmcp_dev = mc_io->dpmcp_dev;\r\nif (WARN_ON(!dpmcp_dev))\r\nreturn -EINVAL;\r\nerror = dpmcp_reset(mc_io, 0, dpmcp_dev->mc_handle);\r\nif (error < 0) {\r\ndev_err(&dpmcp_dev->dev, "dpmcp_reset() failed: %d\n", error);\r\nreturn error;\r\n}\r\nreturn 0;\r\n}\r\nint __must_check fsl_mc_object_allocate(struct fsl_mc_device *mc_dev,\r\nenum fsl_mc_pool_type pool_type,\r\nstruct fsl_mc_device **new_mc_adev)\r\n{\r\nstruct fsl_mc_device *mc_bus_dev;\r\nstruct fsl_mc_bus *mc_bus;\r\nstruct fsl_mc_device *mc_adev;\r\nint error = -EINVAL;\r\nstruct fsl_mc_resource *resource = NULL;\r\n*new_mc_adev = NULL;\r\nif (WARN_ON(mc_dev->flags & FSL_MC_IS_DPRC))\r\ngoto error;\r\nif (WARN_ON(mc_dev->dev.parent->bus != &fsl_mc_bus_type))\r\ngoto error;\r\nif (WARN_ON(pool_type == FSL_MC_POOL_DPMCP))\r\ngoto error;\r\nmc_bus_dev = to_fsl_mc_device(mc_dev->dev.parent);\r\nmc_bus = to_fsl_mc_bus(mc_bus_dev);\r\nerror = fsl_mc_resource_allocate(mc_bus, pool_type, &resource);\r\nif (error < 0)\r\ngoto error;\r\nmc_adev = resource->data;\r\nif (WARN_ON(!mc_adev))\r\ngoto error;\r\n*new_mc_adev = mc_adev;\r\nreturn 0;\r\nerror:\r\nif (resource)\r\nfsl_mc_resource_free(resource);\r\nreturn error;\r\n}\r\nvoid fsl_mc_object_free(struct fsl_mc_device *mc_adev)\r\n{\r\nstruct fsl_mc_resource *resource;\r\nresource = mc_adev->resource;\r\nif (WARN_ON(resource->type == FSL_MC_POOL_DPMCP))\r\nreturn;\r\nif (WARN_ON(resource->data != mc_adev))\r\nreturn;\r\nfsl_mc_resource_free(resource);\r\n}\r\nstatic int fsl_mc_allocator_probe(struct fsl_mc_device *mc_dev)\r\n{\r\nenum fsl_mc_pool_type pool_type;\r\nstruct fsl_mc_device *mc_bus_dev;\r\nstruct fsl_mc_bus *mc_bus;\r\nint error;\r\nif (WARN_ON(!FSL_MC_IS_ALLOCATABLE(mc_dev->obj_desc.type)))\r\nreturn -EINVAL;\r\nmc_bus_dev = to_fsl_mc_device(mc_dev->dev.parent);\r\nif (WARN_ON(mc_bus_dev->dev.bus != &fsl_mc_bus_type))\r\nreturn -EINVAL;\r\nmc_bus = to_fsl_mc_bus(mc_bus_dev);\r\nerror = object_type_to_pool_type(mc_dev->obj_desc.type, &pool_type);\r\nif (error < 0)\r\nreturn error;\r\nerror = fsl_mc_resource_pool_add_device(mc_bus, pool_type, mc_dev);\r\nif (error < 0)\r\nreturn error;\r\ndev_dbg(&mc_dev->dev,\r\n"Allocatable MC object device bound to fsl_mc_allocator driver");\r\nreturn 0;\r\n}\r\nstatic int fsl_mc_allocator_remove(struct fsl_mc_device *mc_dev)\r\n{\r\nint error;\r\nif (WARN_ON(!FSL_MC_IS_ALLOCATABLE(mc_dev->obj_desc.type)))\r\nreturn -EINVAL;\r\nif (mc_dev->resource) {\r\nerror = fsl_mc_resource_pool_remove_device(mc_dev);\r\nif (error < 0)\r\nreturn error;\r\n}\r\ndev_dbg(&mc_dev->dev,\r\n"Allocatable MC object device unbound from fsl_mc_allocator driver");\r\nreturn 0;\r\n}\r\nint __init fsl_mc_allocator_driver_init(void)\r\n{\r\nreturn fsl_mc_driver_register(&fsl_mc_allocator_driver);\r\n}\r\nvoid __exit fsl_mc_allocator_driver_exit(void)\r\n{\r\nfsl_mc_driver_unregister(&fsl_mc_allocator_driver);\r\n}
