static inline struct palmas_clock_info *to_palmas_clks_info(struct clk_hw *hw)\r\n{\r\nreturn container_of(hw, struct palmas_clock_info, hw);\r\n}\r\nstatic unsigned long palmas_clks_recalc_rate(struct clk_hw *hw,\r\nunsigned long parent_rate)\r\n{\r\nreturn 32768;\r\n}\r\nstatic int palmas_clks_prepare(struct clk_hw *hw)\r\n{\r\nstruct palmas_clock_info *cinfo = to_palmas_clks_info(hw);\r\nint ret;\r\nret = palmas_update_bits(cinfo->palmas, PALMAS_RESOURCE_BASE,\r\ncinfo->clk_desc->control_reg,\r\ncinfo->clk_desc->enable_mask,\r\ncinfo->clk_desc->enable_mask);\r\nif (ret < 0)\r\ndev_err(cinfo->dev, "Reg 0x%02x update failed, %d\n",\r\ncinfo->clk_desc->control_reg, ret);\r\nelse if (cinfo->clk_desc->delay)\r\nudelay(cinfo->clk_desc->delay);\r\nreturn ret;\r\n}\r\nstatic void palmas_clks_unprepare(struct clk_hw *hw)\r\n{\r\nstruct palmas_clock_info *cinfo = to_palmas_clks_info(hw);\r\nint ret;\r\nif (cinfo->ext_control_pin)\r\nreturn;\r\nret = palmas_update_bits(cinfo->palmas, PALMAS_RESOURCE_BASE,\r\ncinfo->clk_desc->control_reg,\r\ncinfo->clk_desc->enable_mask, 0);\r\nif (ret < 0)\r\ndev_err(cinfo->dev, "Reg 0x%02x update failed, %d\n",\r\ncinfo->clk_desc->control_reg, ret);\r\n}\r\nstatic int palmas_clks_is_prepared(struct clk_hw *hw)\r\n{\r\nstruct palmas_clock_info *cinfo = to_palmas_clks_info(hw);\r\nint ret;\r\nu32 val;\r\nif (cinfo->ext_control_pin)\r\nreturn 1;\r\nret = palmas_read(cinfo->palmas, PALMAS_RESOURCE_BASE,\r\ncinfo->clk_desc->control_reg, &val);\r\nif (ret < 0) {\r\ndev_err(cinfo->dev, "Reg 0x%02x read failed, %d\n",\r\ncinfo->clk_desc->control_reg, ret);\r\nreturn ret;\r\n}\r\nreturn !!(val & cinfo->clk_desc->enable_mask);\r\n}\r\nstatic void palmas_clks_get_clk_data(struct platform_device *pdev,\r\nstruct palmas_clock_info *cinfo)\r\n{\r\nstruct device_node *node = pdev->dev.of_node;\r\nunsigned int prop;\r\nint ret;\r\nret = of_property_read_u32(node, "ti,external-sleep-control",\r\n&prop);\r\nif (ret)\r\nreturn;\r\nswitch (prop) {\r\ncase PALMAS_CLOCK_DT_EXT_CONTROL_ENABLE1:\r\nprop = PALMAS_EXT_CONTROL_ENABLE1;\r\nbreak;\r\ncase PALMAS_CLOCK_DT_EXT_CONTROL_ENABLE2:\r\nprop = PALMAS_EXT_CONTROL_ENABLE2;\r\nbreak;\r\ncase PALMAS_CLOCK_DT_EXT_CONTROL_NSLEEP:\r\nprop = PALMAS_EXT_CONTROL_NSLEEP;\r\nbreak;\r\ndefault:\r\ndev_warn(&pdev->dev, "%s: Invalid ext control option: %u\n",\r\nnode->name, prop);\r\nprop = 0;\r\nbreak;\r\n}\r\ncinfo->ext_control_pin = prop;\r\n}\r\nstatic int palmas_clks_init_configure(struct palmas_clock_info *cinfo)\r\n{\r\nint ret;\r\nret = palmas_update_bits(cinfo->palmas, PALMAS_RESOURCE_BASE,\r\ncinfo->clk_desc->control_reg,\r\ncinfo->clk_desc->sleep_mask, 0);\r\nif (ret < 0) {\r\ndev_err(cinfo->dev, "Reg 0x%02x update failed, %d\n",\r\ncinfo->clk_desc->control_reg, ret);\r\nreturn ret;\r\n}\r\nif (cinfo->ext_control_pin) {\r\nret = clk_prepare(cinfo->clk);\r\nif (ret < 0) {\r\ndev_err(cinfo->dev, "Clock prep failed, %d\n", ret);\r\nreturn ret;\r\n}\r\nret = palmas_ext_control_req_config(cinfo->palmas,\r\ncinfo->clk_desc->sleep_reqstr_id,\r\ncinfo->ext_control_pin, true);\r\nif (ret < 0) {\r\ndev_err(cinfo->dev, "Ext config for %s failed, %d\n",\r\ncinfo->clk_desc->clk_name, ret);\r\nreturn ret;\r\n}\r\n}\r\nreturn ret;\r\n}\r\nstatic int palmas_clks_probe(struct platform_device *pdev)\r\n{\r\nstruct palmas *palmas = dev_get_drvdata(pdev->dev.parent);\r\nstruct device_node *node = pdev->dev.of_node;\r\nstruct palmas_clks_of_match_data *match_data;\r\nconst struct of_device_id *match;\r\nstruct palmas_clock_info *cinfo;\r\nstruct clk *clk;\r\nint ret;\r\nmatch = of_match_device(palmas_clks_of_match, &pdev->dev);\r\nmatch_data = (struct palmas_clks_of_match_data *)match->data;\r\ncinfo = devm_kzalloc(&pdev->dev, sizeof(*cinfo), GFP_KERNEL);\r\nif (!cinfo)\r\nreturn -ENOMEM;\r\npalmas_clks_get_clk_data(pdev, cinfo);\r\nplatform_set_drvdata(pdev, cinfo);\r\ncinfo->dev = &pdev->dev;\r\ncinfo->palmas = palmas;\r\ncinfo->clk_desc = &match_data->desc;\r\ncinfo->hw.init = &match_data->init;\r\nclk = devm_clk_register(&pdev->dev, &cinfo->hw);\r\nif (IS_ERR(clk)) {\r\nret = PTR_ERR(clk);\r\ndev_err(&pdev->dev, "Fail to register clock %s, %d\n",\r\nmatch_data->desc.clk_name, ret);\r\nreturn ret;\r\n}\r\ncinfo->clk = clk;\r\nret = palmas_clks_init_configure(cinfo);\r\nif (ret < 0) {\r\ndev_err(&pdev->dev, "Clock config failed, %d\n", ret);\r\nreturn ret;\r\n}\r\nret = of_clk_add_provider(node, of_clk_src_simple_get, cinfo->clk);\r\nif (ret < 0)\r\ndev_err(&pdev->dev, "Fail to add clock driver, %d\n", ret);\r\nreturn ret;\r\n}\r\nstatic int palmas_clks_remove(struct platform_device *pdev)\r\n{\r\nof_clk_del_provider(pdev->dev.of_node);\r\nreturn 0;\r\n}
