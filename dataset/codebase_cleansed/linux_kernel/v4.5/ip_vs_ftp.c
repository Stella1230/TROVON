static int\r\nip_vs_ftp_init_conn(struct ip_vs_app *app, struct ip_vs_conn *cp)\r\n{\r\ncp->flags |= IP_VS_CONN_F_NFCT;\r\nreturn 0;\r\n}\r\nstatic int\r\nip_vs_ftp_done_conn(struct ip_vs_app *app, struct ip_vs_conn *cp)\r\n{\r\nreturn 0;\r\n}\r\nstatic int ip_vs_ftp_get_addrport(char *data, char *data_limit,\r\nconst char *pattern, size_t plen,\r\nchar skip, char term,\r\n__be32 *addr, __be16 *port,\r\nchar **start, char **end)\r\n{\r\nchar *s, c;\r\nunsigned char p[6];\r\nint i = 0;\r\nif (data_limit - data < plen) {\r\nif (strncasecmp(data, pattern, data_limit - data) == 0)\r\nreturn -1;\r\nelse\r\nreturn 0;\r\n}\r\nif (strncasecmp(data, pattern, plen) != 0) {\r\nreturn 0;\r\n}\r\ns = data + plen;\r\nif (skip) {\r\nint found = 0;\r\nfor (;; s++) {\r\nif (s == data_limit)\r\nreturn -1;\r\nif (!found) {\r\nif (*s == skip)\r\nfound = 1;\r\n} else if (*s != skip) {\r\nbreak;\r\n}\r\n}\r\n}\r\nfor (data = s; ; data++) {\r\nif (data == data_limit)\r\nreturn -1;\r\nif (*data == term)\r\nbreak;\r\n}\r\n*end = data;\r\nmemset(p, 0, sizeof(p));\r\nfor (data = s; ; data++) {\r\nc = *data;\r\nif (c == term)\r\nbreak;\r\nif (c >= '0' && c <= '9') {\r\np[i] = p[i]*10 + c - '0';\r\n} else if (c == ',' && i < 5) {\r\ni++;\r\n} else {\r\nreturn -1;\r\n}\r\n}\r\nif (i != 5)\r\nreturn -1;\r\n*start = s;\r\n*addr = get_unaligned((__be32 *) p);\r\n*port = get_unaligned((__be16 *) (p + 4));\r\nreturn 1;\r\n}\r\nstatic int ip_vs_ftp_out(struct ip_vs_app *app, struct ip_vs_conn *cp,\r\nstruct sk_buff *skb, int *diff)\r\n{\r\nstruct iphdr *iph;\r\nstruct tcphdr *th;\r\nchar *data, *data_limit;\r\nchar *start, *end;\r\nunion nf_inet_addr from;\r\n__be16 port;\r\nstruct ip_vs_conn *n_cp;\r\nchar buf[24];\r\nunsigned int buf_len;\r\nint ret = 0;\r\nenum ip_conntrack_info ctinfo;\r\nstruct nf_conn *ct;\r\n*diff = 0;\r\n#ifdef CONFIG_IP_VS_IPV6\r\nif (cp->af == AF_INET6)\r\nreturn 1;\r\n#endif\r\nif (cp->state != IP_VS_TCP_S_ESTABLISHED)\r\nreturn 1;\r\nif (!skb_make_writable(skb, skb->len))\r\nreturn 0;\r\nif (cp->app_data == &ip_vs_ftp_pasv) {\r\niph = ip_hdr(skb);\r\nth = (struct tcphdr *)&(((char *)iph)[iph->ihl*4]);\r\ndata = (char *)th + (th->doff << 2);\r\ndata_limit = skb_tail_pointer(skb);\r\nif (ip_vs_ftp_get_addrport(data, data_limit,\r\nSERVER_STRING,\r\nsizeof(SERVER_STRING)-1,\r\n'(', ')',\r\n&from.ip, &port,\r\n&start, &end) != 1)\r\nreturn 1;\r\nIP_VS_DBG(7, "PASV response (%pI4:%d) -> %pI4:%d detected\n",\r\n&from.ip, ntohs(port), &cp->caddr.ip, 0);\r\n{\r\nstruct ip_vs_conn_param p;\r\nip_vs_conn_fill_param(cp->ipvs, AF_INET,\r\niph->protocol, &from, port,\r\n&cp->caddr, 0, &p);\r\nn_cp = ip_vs_conn_out_get(&p);\r\n}\r\nif (!n_cp) {\r\nstruct ip_vs_conn_param p;\r\nip_vs_conn_fill_param(cp->ipvs,\r\nAF_INET, IPPROTO_TCP, &cp->caddr,\r\n0, &cp->vaddr, port, &p);\r\nn_cp = ip_vs_conn_new(&p, AF_INET, &from, port,\r\nIP_VS_CONN_F_NO_CPORT |\r\nIP_VS_CONN_F_NFCT,\r\ncp->dest, skb->mark);\r\nif (!n_cp)\r\nreturn 0;\r\nip_vs_control_add(n_cp, cp);\r\n}\r\nfrom.ip = n_cp->vaddr.ip;\r\nport = n_cp->vport;\r\nsnprintf(buf, sizeof(buf), "%u,%u,%u,%u,%u,%u",\r\n((unsigned char *)&from.ip)[0],\r\n((unsigned char *)&from.ip)[1],\r\n((unsigned char *)&from.ip)[2],\r\n((unsigned char *)&from.ip)[3],\r\nntohs(port) >> 8,\r\nntohs(port) & 0xFF);\r\nbuf_len = strlen(buf);\r\nct = nf_ct_get(skb, &ctinfo);\r\nif (ct && !nf_ct_is_untracked(ct) && nfct_nat(ct)) {\r\nrcu_read_lock();\r\nret = nf_nat_mangle_tcp_packet(skb, ct, ctinfo,\r\niph->ihl * 4,\r\nstart-data, end-start,\r\nbuf, buf_len);\r\nrcu_read_unlock();\r\nif (ret) {\r\nip_vs_nfct_expect_related(skb, ct, n_cp,\r\nIPPROTO_TCP, 0, 0);\r\nif (skb->ip_summed == CHECKSUM_COMPLETE)\r\nskb->ip_summed = CHECKSUM_UNNECESSARY;\r\nret = 1;\r\n}\r\n}\r\ncp->app_data = NULL;\r\nip_vs_tcp_conn_listen(n_cp);\r\nip_vs_conn_put(n_cp);\r\nreturn ret;\r\n}\r\nreturn 1;\r\n}\r\nstatic int ip_vs_ftp_in(struct ip_vs_app *app, struct ip_vs_conn *cp,\r\nstruct sk_buff *skb, int *diff)\r\n{\r\nstruct iphdr *iph;\r\nstruct tcphdr *th;\r\nchar *data, *data_start, *data_limit;\r\nchar *start, *end;\r\nunion nf_inet_addr to;\r\n__be16 port;\r\nstruct ip_vs_conn *n_cp;\r\n*diff = 0;\r\n#ifdef CONFIG_IP_VS_IPV6\r\nif (cp->af == AF_INET6)\r\nreturn 1;\r\n#endif\r\nif (cp->state != IP_VS_TCP_S_ESTABLISHED)\r\nreturn 1;\r\nif (!skb_make_writable(skb, skb->len))\r\nreturn 0;\r\niph = ip_hdr(skb);\r\nth = (struct tcphdr *)&(((char *)iph)[iph->ihl*4]);\r\ndata = data_start = (char *)th + (th->doff << 2);\r\ndata_limit = skb_tail_pointer(skb);\r\nwhile (data <= data_limit - 6) {\r\nif (strncasecmp(data, "PASV\r\n", 6) == 0) {\r\nIP_VS_DBG(7, "got PASV at %td of %td\n",\r\ndata - data_start,\r\ndata_limit - data_start);\r\ncp->app_data = &ip_vs_ftp_pasv;\r\nreturn 1;\r\n}\r\ndata++;\r\n}\r\nif (ip_vs_ftp_get_addrport(data_start, data_limit,\r\nCLIENT_STRING, sizeof(CLIENT_STRING)-1,\r\n' ', '\r', &to.ip, &port,\r\n&start, &end) != 1)\r\nreturn 1;\r\nIP_VS_DBG(7, "PORT %pI4:%d detected\n", &to.ip, ntohs(port));\r\ncp->app_data = NULL;\r\nIP_VS_DBG(7, "protocol %s %pI4:%d %pI4:%d\n",\r\nip_vs_proto_name(iph->protocol),\r\n&to.ip, ntohs(port), &cp->vaddr.ip, 0);\r\n{\r\nstruct ip_vs_conn_param p;\r\nip_vs_conn_fill_param(cp->ipvs, AF_INET,\r\niph->protocol, &to, port, &cp->vaddr,\r\nhtons(ntohs(cp->vport)-1), &p);\r\nn_cp = ip_vs_conn_in_get(&p);\r\nif (!n_cp) {\r\nn_cp = ip_vs_conn_new(&p, AF_INET, &cp->daddr,\r\nhtons(ntohs(cp->dport)-1),\r\nIP_VS_CONN_F_NFCT, cp->dest,\r\nskb->mark);\r\nif (!n_cp)\r\nreturn 0;\r\nip_vs_control_add(n_cp, cp);\r\n}\r\n}\r\nip_vs_tcp_conn_listen(n_cp);\r\nip_vs_conn_put(n_cp);\r\nreturn 1;\r\n}\r\nstatic int __net_init __ip_vs_ftp_init(struct net *net)\r\n{\r\nint i, ret;\r\nstruct ip_vs_app *app;\r\nstruct netns_ipvs *ipvs = net_ipvs(net);\r\nif (!ipvs)\r\nreturn -ENOENT;\r\napp = register_ip_vs_app(ipvs, &ip_vs_ftp);\r\nif (IS_ERR(app))\r\nreturn PTR_ERR(app);\r\nfor (i = 0; i < ports_count; i++) {\r\nif (!ports[i])\r\ncontinue;\r\nret = register_ip_vs_app_inc(ipvs, app, app->protocol, ports[i]);\r\nif (ret)\r\ngoto err_unreg;\r\npr_info("%s: loaded support on port[%d] = %d\n",\r\napp->name, i, ports[i]);\r\n}\r\nreturn 0;\r\nerr_unreg:\r\nunregister_ip_vs_app(ipvs, &ip_vs_ftp);\r\nreturn ret;\r\n}\r\nstatic void __ip_vs_ftp_exit(struct net *net)\r\n{\r\nstruct netns_ipvs *ipvs = net_ipvs(net);\r\nif (!ipvs)\r\nreturn;\r\nunregister_ip_vs_app(ipvs, &ip_vs_ftp);\r\n}\r\nstatic int __init ip_vs_ftp_init(void)\r\n{\r\nint rv;\r\nrv = register_pernet_subsys(&ip_vs_ftp_ops);\r\nreturn rv;\r\n}\r\nstatic void __exit ip_vs_ftp_exit(void)\r\n{\r\nunregister_pernet_subsys(&ip_vs_ftp_ops);\r\n}
