static int\r\nnvkm_xtensa_oclass_get(struct nvkm_oclass *oclass, int index)\r\n{\r\nstruct nvkm_xtensa *xtensa = nvkm_xtensa(oclass->engine);\r\nint c = 0;\r\nwhile (xtensa->func->sclass[c].oclass) {\r\nif (c++ == index) {\r\noclass->base = xtensa->func->sclass[index];\r\nreturn index;\r\n}\r\n}\r\nreturn c;\r\n}\r\nstatic int\r\nnvkm_xtensa_cclass_bind(struct nvkm_object *object, struct nvkm_gpuobj *parent,\r\nint align, struct nvkm_gpuobj **pgpuobj)\r\n{\r\nreturn nvkm_gpuobj_new(object->engine->subdev.device, 0x10000, align,\r\ntrue, parent, pgpuobj);\r\n}\r\nstatic void\r\nnvkm_xtensa_intr(struct nvkm_engine *engine)\r\n{\r\nstruct nvkm_xtensa *xtensa = nvkm_xtensa(engine);\r\nstruct nvkm_subdev *subdev = &xtensa->engine.subdev;\r\nstruct nvkm_device *device = subdev->device;\r\nconst u32 base = xtensa->addr;\r\nu32 unk104 = nvkm_rd32(device, base + 0xd04);\r\nu32 intr = nvkm_rd32(device, base + 0xc20);\r\nu32 chan = nvkm_rd32(device, base + 0xc28);\r\nu32 unk10c = nvkm_rd32(device, base + 0xd0c);\r\nif (intr & 0x10)\r\nnvkm_warn(subdev, "Watchdog interrupt, engine hung.\n");\r\nnvkm_wr32(device, base + 0xc20, intr);\r\nintr = nvkm_rd32(device, base + 0xc20);\r\nif (unk104 == 0x10001 && unk10c == 0x200 && chan && !intr) {\r\nnvkm_debug(subdev, "Enabling FIFO_CTRL\n");\r\nnvkm_mask(device, xtensa->addr + 0xd94, 0, xtensa->func->fifo_val);\r\n}\r\n}\r\nstatic int\r\nnvkm_xtensa_fini(struct nvkm_engine *engine, bool suspend)\r\n{\r\nstruct nvkm_xtensa *xtensa = nvkm_xtensa(engine);\r\nstruct nvkm_device *device = xtensa->engine.subdev.device;\r\nconst u32 base = xtensa->addr;\r\nnvkm_wr32(device, base + 0xd84, 0);\r\nnvkm_wr32(device, base + 0xd94, 0);\r\nif (!suspend)\r\nnvkm_memory_del(&xtensa->gpu_fw);\r\nreturn 0;\r\n}\r\nstatic int\r\nnvkm_xtensa_init(struct nvkm_engine *engine)\r\n{\r\nstruct nvkm_xtensa *xtensa = nvkm_xtensa(engine);\r\nstruct nvkm_subdev *subdev = &xtensa->engine.subdev;\r\nstruct nvkm_device *device = subdev->device;\r\nconst u32 base = xtensa->addr;\r\nconst struct firmware *fw;\r\nchar name[32];\r\nint i, ret;\r\nu64 addr, size;\r\nu32 tmp;\r\nif (!xtensa->gpu_fw) {\r\nsnprintf(name, sizeof(name), "nouveau/nv84_xuc%03x",\r\nxtensa->addr >> 12);\r\nret = request_firmware(&fw, name, device->dev);\r\nif (ret) {\r\nnvkm_warn(subdev, "unable to load firmware %s\n", name);\r\nreturn ret;\r\n}\r\nif (fw->size > 0x40000) {\r\nnvkm_warn(subdev, "firmware %s too large\n", name);\r\nrelease_firmware(fw);\r\nreturn -EINVAL;\r\n}\r\nret = nvkm_memory_new(device, NVKM_MEM_TARGET_INST,\r\n0x40000, 0x1000, false,\r\n&xtensa->gpu_fw);\r\nif (ret) {\r\nrelease_firmware(fw);\r\nreturn ret;\r\n}\r\nnvkm_kmap(xtensa->gpu_fw);\r\nfor (i = 0; i < fw->size / 4; i++)\r\nnvkm_wo32(xtensa->gpu_fw, i * 4, *((u32 *)fw->data + i));\r\nnvkm_done(xtensa->gpu_fw);\r\nrelease_firmware(fw);\r\n}\r\naddr = nvkm_memory_addr(xtensa->gpu_fw);\r\nsize = nvkm_memory_size(xtensa->gpu_fw);\r\nnvkm_wr32(device, base + 0xd10, 0x1fffffff);\r\nnvkm_wr32(device, base + 0xd08, 0x0fffffff);\r\nnvkm_wr32(device, base + 0xd28, xtensa->func->unkd28);\r\nnvkm_wr32(device, base + 0xc20, 0x3f);\r\nnvkm_wr32(device, base + 0xd84, 0x3f);\r\nnvkm_wr32(device, base + 0xcc0, addr >> 8);\r\nnvkm_wr32(device, base + 0xcc4, 0x1c);\r\nnvkm_wr32(device, base + 0xcc8, size >> 8);\r\ntmp = nvkm_rd32(device, 0x0);\r\nnvkm_wr32(device, base + 0xde0, tmp);\r\nnvkm_wr32(device, base + 0xce8, 0xf);\r\nnvkm_wr32(device, base + 0xc20, 0x3f);\r\nnvkm_wr32(device, base + 0xd84, 0x3f);\r\nreturn 0;\r\n}\r\nstatic void *\r\nnvkm_xtensa_dtor(struct nvkm_engine *engine)\r\n{\r\nreturn nvkm_xtensa(engine);\r\n}\r\nint\r\nnvkm_xtensa_new_(const struct nvkm_xtensa_func *func,\r\nstruct nvkm_device *device, int index, bool enable,\r\nu32 addr, struct nvkm_engine **pengine)\r\n{\r\nstruct nvkm_xtensa *xtensa;\r\nif (!(xtensa = kzalloc(sizeof(*xtensa), GFP_KERNEL)))\r\nreturn -ENOMEM;\r\nxtensa->func = func;\r\nxtensa->addr = addr;\r\n*pengine = &xtensa->engine;\r\nreturn nvkm_engine_ctor(&nvkm_xtensa, device, index, func->pmc_enable,\r\nenable, &xtensa->engine);\r\n}
