static int\r\nnvkm_falcon_oclass_get(struct nvkm_oclass *oclass, int index)\r\n{\r\nstruct nvkm_falcon *falcon = nvkm_falcon(oclass->engine);\r\nint c = 0;\r\nwhile (falcon->func->sclass[c].oclass) {\r\nif (c++ == index) {\r\noclass->base = falcon->func->sclass[index];\r\nreturn index;\r\n}\r\n}\r\nreturn c;\r\n}\r\nstatic int\r\nnvkm_falcon_cclass_bind(struct nvkm_object *object, struct nvkm_gpuobj *parent,\r\nint align, struct nvkm_gpuobj **pgpuobj)\r\n{\r\nreturn nvkm_gpuobj_new(object->engine->subdev.device, 256,\r\nalign, true, parent, pgpuobj);\r\n}\r\nstatic void\r\nnvkm_falcon_intr(struct nvkm_engine *engine)\r\n{\r\nstruct nvkm_falcon *falcon = nvkm_falcon(engine);\r\nstruct nvkm_subdev *subdev = &falcon->engine.subdev;\r\nstruct nvkm_device *device = subdev->device;\r\nconst u32 base = falcon->addr;\r\nu32 dest = nvkm_rd32(device, base + 0x01c);\r\nu32 intr = nvkm_rd32(device, base + 0x008) & dest & ~(dest >> 16);\r\nu32 inst = nvkm_rd32(device, base + 0x050) & 0x3fffffff;\r\nstruct nvkm_fifo_chan *chan;\r\nunsigned long flags;\r\nchan = nvkm_fifo_chan_inst(device->fifo, (u64)inst << 12, &flags);\r\nif (intr & 0x00000040) {\r\nif (falcon->func->intr) {\r\nfalcon->func->intr(falcon, chan);\r\nnvkm_wr32(device, base + 0x004, 0x00000040);\r\nintr &= ~0x00000040;\r\n}\r\n}\r\nif (intr & 0x00000010) {\r\nnvkm_debug(subdev, "ucode halted\n");\r\nnvkm_wr32(device, base + 0x004, 0x00000010);\r\nintr &= ~0x00000010;\r\n}\r\nif (intr) {\r\nnvkm_error(subdev, "intr %08x\n", intr);\r\nnvkm_wr32(device, base + 0x004, intr);\r\n}\r\nnvkm_fifo_chan_put(device->fifo, flags, &chan);\r\n}\r\nstatic int\r\nnvkm_falcon_fini(struct nvkm_engine *engine, bool suspend)\r\n{\r\nstruct nvkm_falcon *falcon = nvkm_falcon(engine);\r\nstruct nvkm_device *device = falcon->engine.subdev.device;\r\nconst u32 base = falcon->addr;\r\nif (!suspend) {\r\nnvkm_memory_del(&falcon->core);\r\nif (falcon->external) {\r\nvfree(falcon->data.data);\r\nvfree(falcon->code.data);\r\nfalcon->code.data = NULL;\r\n}\r\n}\r\nnvkm_mask(device, base + 0x048, 0x00000003, 0x00000000);\r\nnvkm_wr32(device, base + 0x014, 0xffffffff);\r\nreturn 0;\r\n}\r\nstatic void *\r\nvmemdup(const void *src, size_t len)\r\n{\r\nvoid *p = vmalloc(len);\r\nif (p)\r\nmemcpy(p, src, len);\r\nreturn p;\r\n}\r\nstatic int\r\nnvkm_falcon_oneinit(struct nvkm_engine *engine)\r\n{\r\nstruct nvkm_falcon *falcon = nvkm_falcon(engine);\r\nstruct nvkm_subdev *subdev = &falcon->engine.subdev;\r\nstruct nvkm_device *device = subdev->device;\r\nconst u32 base = falcon->addr;\r\nu32 caps;\r\nif (device->chipset < 0xa3 ||\r\ndevice->chipset == 0xaa || device->chipset == 0xac) {\r\nfalcon->version = 0;\r\nfalcon->secret = (falcon->addr == 0x087000) ? 1 : 0;\r\n} else {\r\ncaps = nvkm_rd32(device, base + 0x12c);\r\nfalcon->version = (caps & 0x0000000f);\r\nfalcon->secret = (caps & 0x00000030) >> 4;\r\n}\r\ncaps = nvkm_rd32(device, base + 0x108);\r\nfalcon->code.limit = (caps & 0x000001ff) << 8;\r\nfalcon->data.limit = (caps & 0x0003fe00) >> 1;\r\nnvkm_debug(subdev, "falcon version: %d\n", falcon->version);\r\nnvkm_debug(subdev, "secret level: %d\n", falcon->secret);\r\nnvkm_debug(subdev, "code limit: %d\n", falcon->code.limit);\r\nnvkm_debug(subdev, "data limit: %d\n", falcon->data.limit);\r\nreturn 0;\r\n}\r\nstatic int\r\nnvkm_falcon_init(struct nvkm_engine *engine)\r\n{\r\nstruct nvkm_falcon *falcon = nvkm_falcon(engine);\r\nstruct nvkm_subdev *subdev = &falcon->engine.subdev;\r\nstruct nvkm_device *device = subdev->device;\r\nconst struct firmware *fw;\r\nchar name[32] = "internal";\r\nconst u32 base = falcon->addr;\r\nint ret, i;\r\nif (falcon->secret && falcon->version < 4) {\r\nif (!falcon->version) {\r\nnvkm_msec(device, 2000,\r\nif (nvkm_rd32(device, base + 0x008) & 0x00000010)\r\nbreak;\r\n);\r\n} else {\r\nnvkm_msec(device, 2000,\r\nif (!(nvkm_rd32(device, base + 0x180) & 0x80000000))\r\nbreak;\r\n);\r\n}\r\nnvkm_wr32(device, base + 0x004, 0x00000010);\r\n}\r\nnvkm_wr32(device, base + 0x014, 0xffffffff);\r\nif (!falcon->code.data) {\r\nsnprintf(name, sizeof(name), "nouveau/nv%02x_fuc%03x",\r\ndevice->chipset, falcon->addr >> 12);\r\nret = request_firmware(&fw, name, device->dev);\r\nif (ret == 0) {\r\nfalcon->code.data = vmemdup(fw->data, fw->size);\r\nfalcon->code.size = fw->size;\r\nfalcon->data.data = NULL;\r\nfalcon->data.size = 0;\r\nrelease_firmware(fw);\r\n}\r\nfalcon->external = true;\r\n}\r\nif (!falcon->code.data) {\r\nsnprintf(name, sizeof(name), "nouveau/nv%02x_fuc%03xd",\r\ndevice->chipset, falcon->addr >> 12);\r\nret = request_firmware(&fw, name, device->dev);\r\nif (ret) {\r\nnvkm_error(subdev, "unable to load firmware data\n");\r\nreturn -ENODEV;\r\n}\r\nfalcon->data.data = vmemdup(fw->data, fw->size);\r\nfalcon->data.size = fw->size;\r\nrelease_firmware(fw);\r\nif (!falcon->data.data)\r\nreturn -ENOMEM;\r\nsnprintf(name, sizeof(name), "nouveau/nv%02x_fuc%03xc",\r\ndevice->chipset, falcon->addr >> 12);\r\nret = request_firmware(&fw, name, device->dev);\r\nif (ret) {\r\nnvkm_error(subdev, "unable to load firmware code\n");\r\nreturn -ENODEV;\r\n}\r\nfalcon->code.data = vmemdup(fw->data, fw->size);\r\nfalcon->code.size = fw->size;\r\nrelease_firmware(fw);\r\nif (!falcon->code.data)\r\nreturn -ENOMEM;\r\n}\r\nnvkm_debug(subdev, "firmware: %s (%s)\n", name, falcon->data.data ?\r\n"static code/data segments" : "self-bootstrapping");\r\nif (!falcon->data.data && !falcon->core) {\r\nret = nvkm_memory_new(device, NVKM_MEM_TARGET_INST,\r\nfalcon->code.size, 256, false,\r\n&falcon->core);\r\nif (ret) {\r\nnvkm_error(subdev, "core allocation failed, %d\n", ret);\r\nreturn ret;\r\n}\r\nnvkm_kmap(falcon->core);\r\nfor (i = 0; i < falcon->code.size; i += 4)\r\nnvkm_wo32(falcon->core, i, falcon->code.data[i / 4]);\r\nnvkm_done(falcon->core);\r\n}\r\nif (falcon->core) {\r\nu64 addr = nvkm_memory_addr(falcon->core);\r\nif (device->card_type < NV_C0)\r\nnvkm_wr32(device, base + 0x618, 0x04000000);\r\nelse\r\nnvkm_wr32(device, base + 0x618, 0x00000114);\r\nnvkm_wr32(device, base + 0x11c, 0);\r\nnvkm_wr32(device, base + 0x110, addr >> 8);\r\nnvkm_wr32(device, base + 0x114, 0);\r\nnvkm_wr32(device, base + 0x118, 0x00006610);\r\n} else {\r\nif (falcon->code.size > falcon->code.limit ||\r\nfalcon->data.size > falcon->data.limit) {\r\nnvkm_error(subdev, "ucode exceeds falcon limit(s)\n");\r\nreturn -EINVAL;\r\n}\r\nif (falcon->version < 3) {\r\nnvkm_wr32(device, base + 0xff8, 0x00100000);\r\nfor (i = 0; i < falcon->code.size / 4; i++)\r\nnvkm_wr32(device, base + 0xff4, falcon->code.data[i]);\r\n} else {\r\nnvkm_wr32(device, base + 0x180, 0x01000000);\r\nfor (i = 0; i < falcon->code.size / 4; i++) {\r\nif ((i & 0x3f) == 0)\r\nnvkm_wr32(device, base + 0x188, i >> 6);\r\nnvkm_wr32(device, base + 0x184, falcon->code.data[i]);\r\n}\r\n}\r\n}\r\nif (falcon->version < 3) {\r\nnvkm_wr32(device, base + 0xff8, 0x00000000);\r\nfor (i = 0; !falcon->core && i < falcon->data.size / 4; i++)\r\nnvkm_wr32(device, base + 0xff4, falcon->data.data[i]);\r\nfor (; i < falcon->data.limit; i += 4)\r\nnvkm_wr32(device, base + 0xff4, 0x00000000);\r\n} else {\r\nnvkm_wr32(device, base + 0x1c0, 0x01000000);\r\nfor (i = 0; !falcon->core && i < falcon->data.size / 4; i++)\r\nnvkm_wr32(device, base + 0x1c4, falcon->data.data[i]);\r\nfor (; i < falcon->data.limit / 4; i++)\r\nnvkm_wr32(device, base + 0x1c4, 0x00000000);\r\n}\r\nnvkm_wr32(device, base + 0x10c, 0x00000001);\r\nnvkm_wr32(device, base + 0x104, 0x00000000);\r\nnvkm_wr32(device, base + 0x100, 0x00000002);\r\nnvkm_wr32(device, base + 0x048, 0x00000003);\r\nif (falcon->func->init)\r\nfalcon->func->init(falcon);\r\nreturn 0;\r\n}\r\nstatic void *\r\nnvkm_falcon_dtor(struct nvkm_engine *engine)\r\n{\r\nreturn nvkm_falcon(engine);\r\n}\r\nint\r\nnvkm_falcon_new_(const struct nvkm_falcon_func *func,\r\nstruct nvkm_device *device, int index, bool enable,\r\nu32 addr, struct nvkm_engine **pengine)\r\n{\r\nstruct nvkm_falcon *falcon;\r\nif (!(falcon = kzalloc(sizeof(*falcon), GFP_KERNEL)))\r\nreturn -ENOMEM;\r\nfalcon->func = func;\r\nfalcon->addr = addr;\r\nfalcon->code.data = func->code.data;\r\nfalcon->code.size = func->code.size;\r\nfalcon->data.data = func->data.data;\r\nfalcon->data.size = func->data.size;\r\n*pengine = &falcon->engine;\r\nreturn nvkm_engine_ctor(&nvkm_falcon, device, index, func->pmc_enable,\r\nenable, &falcon->engine);\r\n}
