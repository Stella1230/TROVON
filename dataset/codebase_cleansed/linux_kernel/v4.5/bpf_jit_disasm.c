static void get_exec_path(char *tpath, size_t size)\r\n{\r\nchar *path;\r\nssize_t len;\r\nsnprintf(tpath, size, "/proc/%d/exe", (int) getpid());\r\ntpath[size - 1] = 0;\r\npath = strdup(tpath);\r\nassert(path);\r\nlen = readlink(path, tpath, size);\r\ntpath[len] = 0;\r\nfree(path);\r\n}\r\nstatic void get_asm_insns(uint8_t *image, size_t len, int opcodes)\r\n{\r\nint count, i, pc = 0;\r\nchar tpath[256];\r\nstruct disassemble_info info;\r\ndisassembler_ftype disassemble;\r\nbfd *bfdf;\r\nmemset(tpath, 0, sizeof(tpath));\r\nget_exec_path(tpath, sizeof(tpath));\r\nbfdf = bfd_openr(tpath, NULL);\r\nassert(bfdf);\r\nassert(bfd_check_format(bfdf, bfd_object));\r\ninit_disassemble_info(&info, stdout, (fprintf_ftype) fprintf);\r\ninfo.arch = bfd_get_arch(bfdf);\r\ninfo.mach = bfd_get_mach(bfdf);\r\ninfo.buffer = image;\r\ninfo.buffer_length = len;\r\ndisassemble_init_for_target(&info);\r\ndisassemble = disassembler(bfdf);\r\nassert(disassemble);\r\ndo {\r\nprintf("%4x:\t", pc);\r\ncount = disassemble(pc, &info);\r\nif (opcodes) {\r\nprintf("\n\t");\r\nfor (i = 0; i < count; ++i)\r\nprintf("%02x ", (uint8_t) image[pc + i]);\r\n}\r\nprintf("\n");\r\npc += count;\r\n} while(count > 0 && pc < len);\r\nbfd_close(bfdf);\r\n}\r\nstatic char *get_klog_buff(unsigned int *klen)\r\n{\r\nint ret, len;\r\nchar *buff;\r\nlen = klogctl(CMD_ACTION_SIZE_BUFFER, NULL, 0);\r\nbuff = malloc(len);\r\nif (!buff)\r\nreturn NULL;\r\nret = klogctl(CMD_ACTION_READ_ALL, buff, len);\r\nif (ret < 0) {\r\nfree(buff);\r\nreturn NULL;\r\n}\r\n*klen = ret;\r\nreturn buff;\r\n}\r\nstatic char *get_flog_buff(const char *file, unsigned int *klen)\r\n{\r\nint fd, ret, len;\r\nstruct stat fi;\r\nchar *buff;\r\nfd = open(file, O_RDONLY);\r\nif (fd < 0)\r\nreturn NULL;\r\nret = fstat(fd, &fi);\r\nif (ret < 0 || !S_ISREG(fi.st_mode))\r\ngoto out;\r\nlen = fi.st_size + 1;\r\nbuff = malloc(len);\r\nif (!buff)\r\ngoto out;\r\nmemset(buff, 0, len);\r\nret = read(fd, buff, len - 1);\r\nif (ret <= 0)\r\ngoto out_free;\r\nclose(fd);\r\n*klen = ret;\r\nreturn buff;\r\nout_free:\r\nfree(buff);\r\nout:\r\nclose(fd);\r\nreturn NULL;\r\n}\r\nstatic char *get_log_buff(const char *file, unsigned int *klen)\r\n{\r\nreturn file ? get_flog_buff(file, klen) : get_klog_buff(klen);\r\n}\r\nstatic void put_log_buff(char *buff)\r\n{\r\nfree(buff);\r\n}\r\nstatic unsigned int get_last_jit_image(char *haystack, size_t hlen,\r\nuint8_t *image, size_t ilen)\r\n{\r\nchar *ptr, *pptr, *tmp;\r\noff_t off = 0;\r\nint ret, flen, proglen, pass, ulen = 0;\r\nregmatch_t pmatch[1];\r\nunsigned long base;\r\nregex_t regex;\r\nif (hlen == 0)\r\nreturn 0;\r\nret = regcomp(&regex, "flen=[[:alnum:]]+ proglen=[[:digit:]]+ "\r\n"pass=[[:digit:]]+ image=[[:xdigit:]]+", REG_EXTENDED);\r\nassert(ret == 0);\r\nptr = haystack;\r\nmemset(pmatch, 0, sizeof(pmatch));\r\nwhile (1) {\r\nret = regexec(&regex, ptr, 1, pmatch, 0);\r\nif (ret == 0) {\r\nptr += pmatch[0].rm_eo;\r\noff += pmatch[0].rm_eo;\r\nassert(off < hlen);\r\n} else\r\nbreak;\r\n}\r\nptr = haystack + off - (pmatch[0].rm_eo - pmatch[0].rm_so);\r\nret = sscanf(ptr, "flen=%d proglen=%d pass=%d image=%lx",\r\n&flen, &proglen, &pass, &base);\r\nif (ret != 4) {\r\nregfree(&regex);\r\nreturn 0;\r\n}\r\ntmp = ptr = haystack + off;\r\nwhile ((ptr = strtok(tmp, "\n")) != NULL && ulen < ilen) {\r\ntmp = NULL;\r\nif (!strstr(ptr, "JIT code"))\r\ncontinue;\r\npptr = ptr;\r\nwhile ((ptr = strstr(pptr, ":")))\r\npptr = ptr + 1;\r\nptr = pptr;\r\ndo {\r\nimage[ulen++] = (uint8_t) strtoul(pptr, &pptr, 16);\r\nif (ptr == pptr || ulen >= ilen) {\r\nulen--;\r\nbreak;\r\n}\r\nptr = pptr;\r\n} while (1);\r\n}\r\nassert(ulen == proglen);\r\nprintf("%d bytes emitted from JIT compiler (pass:%d, flen:%d)\n",\r\nproglen, pass, flen);\r\nprintf("%lx + <x>:\n", base);\r\nregfree(&regex);\r\nreturn ulen;\r\n}\r\nstatic void usage(void)\r\n{\r\nprintf("Usage: bpf_jit_disasm [...]\n");\r\nprintf(" -o Also display related opcodes (default: off).\n");\r\nprintf(" -f <file> Read last image dump from file or stdin (default: klog).\n");\r\nprintf(" -h Display this help.\n");\r\n}\r\nint main(int argc, char **argv)\r\n{\r\nunsigned int len, klen, opt, opcodes = 0;\r\nstatic uint8_t image[32768];\r\nchar *kbuff, *file = NULL;\r\nwhile ((opt = getopt(argc, argv, "of:")) != -1) {\r\nswitch (opt) {\r\ncase 'o':\r\nopcodes = 1;\r\nbreak;\r\ncase 'f':\r\nfile = optarg;\r\nbreak;\r\ndefault:\r\nusage();\r\nreturn -1;\r\n}\r\n}\r\nbfd_init();\r\nmemset(image, 0, sizeof(image));\r\nkbuff = get_log_buff(file, &klen);\r\nif (!kbuff) {\r\nfprintf(stderr, "Could not retrieve log buffer!\n");\r\nreturn -1;\r\n}\r\nlen = get_last_jit_image(kbuff, klen, image, sizeof(image));\r\nif (len > 0)\r\nget_asm_insns(image, len, opcodes);\r\nelse\r\nfprintf(stderr, "No JIT image found!\n");\r\nput_log_buff(kbuff);\r\nreturn 0;\r\n}
