static u_int\r\nahc_calc_syncsrate(u_int period_factor)\r\n{\r\nint i;\r\nfor (i = 0; i < ARRAY_SIZE(scsi_syncrates); i++) {\r\nif (period_factor == scsi_syncrates[i].period_factor) {\r\nreturn (100000000 / scsi_syncrates[i].period);\r\n}\r\n}\r\nreturn (10000000 / (period_factor * 4 * 10));\r\n}\r\nstatic void\r\nahc_format_transinfo(struct seq_file *m, struct ahc_transinfo *tinfo)\r\n{\r\nu_int speed;\r\nu_int freq;\r\nu_int mb;\r\nspeed = 3300;\r\nfreq = 0;\r\nif (tinfo->offset != 0) {\r\nfreq = ahc_calc_syncsrate(tinfo->period);\r\nspeed = freq;\r\n}\r\nspeed *= (0x01 << tinfo->width);\r\nmb = speed / 1000;\r\nif (mb > 0)\r\nseq_printf(m, "%d.%03dMB/s transfers", mb, speed % 1000);\r\nelse\r\nseq_printf(m, "%dKB/s transfers", speed);\r\nif (freq != 0) {\r\nseq_printf(m, " (%d.%03dMHz%s, offset %d",\r\nfreq / 1000, freq % 1000,\r\n(tinfo->ppr_options & MSG_EXT_PPR_DT_REQ) != 0\r\n? " DT" : "", tinfo->offset);\r\n}\r\nif (tinfo->width > 0) {\r\nif (freq != 0) {\r\nseq_puts(m, ", ");\r\n} else {\r\nseq_puts(m, " (");\r\n}\r\nseq_printf(m, "%dbit)", 8 * (0x01 << tinfo->width));\r\n} else if (freq != 0) {\r\nseq_putc(m, ')');\r\n}\r\nseq_putc(m, '\n');\r\n}\r\nstatic void\r\nahc_dump_target_state(struct ahc_softc *ahc, struct seq_file *m,\r\nu_int our_id, char channel, u_int target_id,\r\nu_int target_offset)\r\n{\r\nstruct scsi_target *starget;\r\nstruct ahc_initiator_tinfo *tinfo;\r\nstruct ahc_tmode_tstate *tstate;\r\nint lun;\r\ntinfo = ahc_fetch_transinfo(ahc, channel, our_id,\r\ntarget_id, &tstate);\r\nif ((ahc->features & AHC_TWIN) != 0)\r\nseq_printf(m, "Channel %c ", channel);\r\nseq_printf(m, "Target %d Negotiation Settings\n", target_id);\r\nseq_puts(m, "\tUser: ");\r\nahc_format_transinfo(m, &tinfo->user);\r\nstarget = ahc->platform_data->starget[target_offset];\r\nif (!starget)\r\nreturn;\r\nseq_puts(m, "\tGoal: ");\r\nahc_format_transinfo(m, &tinfo->goal);\r\nseq_puts(m, "\tCurr: ");\r\nahc_format_transinfo(m, &tinfo->curr);\r\nfor (lun = 0; lun < AHC_NUM_LUNS; lun++) {\r\nstruct scsi_device *sdev;\r\nsdev = scsi_device_lookup_by_target(starget, lun);\r\nif (sdev == NULL)\r\ncontinue;\r\nahc_dump_device_state(m, sdev);\r\n}\r\n}\r\nstatic void\r\nahc_dump_device_state(struct seq_file *m, struct scsi_device *sdev)\r\n{\r\nstruct ahc_linux_device *dev = scsi_transport_device_data(sdev);\r\nseq_printf(m, "\tChannel %c Target %d Lun %d Settings\n",\r\nsdev->sdev_target->channel + 'A',\r\nsdev->sdev_target->id, (u8)sdev->lun);\r\nseq_printf(m, "\t\tCommands Queued %ld\n", dev->commands_issued);\r\nseq_printf(m, "\t\tCommands Active %d\n", dev->active);\r\nseq_printf(m, "\t\tCommand Openings %d\n", dev->openings);\r\nseq_printf(m, "\t\tMax Tagged Openings %d\n", dev->maxtags);\r\nseq_printf(m, "\t\tDevice Queue Frozen Count %d\n", dev->qfrozen);\r\n}\r\nint\r\nahc_proc_write_seeprom(struct Scsi_Host *shost, char *buffer, int length)\r\n{\r\nstruct ahc_softc *ahc = *(struct ahc_softc **)shost->hostdata;\r\nstruct seeprom_descriptor sd;\r\nint have_seeprom;\r\nu_long s;\r\nint paused;\r\nint written;\r\nwritten = -EINVAL;\r\nahc_lock(ahc, &s);\r\npaused = ahc_is_paused(ahc);\r\nif (!paused)\r\nahc_pause(ahc);\r\nif (length != sizeof(struct seeprom_config)) {\r\nprintk("ahc_proc_write_seeprom: incorrect buffer size\n");\r\ngoto done;\r\n}\r\nhave_seeprom = ahc_verify_cksum((struct seeprom_config*)buffer);\r\nif (have_seeprom == 0) {\r\nprintk("ahc_proc_write_seeprom: cksum verification failed\n");\r\ngoto done;\r\n}\r\nsd.sd_ahc = ahc;\r\n#if AHC_PCI_CONFIG > 0\r\nif ((ahc->chip & AHC_PCI) != 0) {\r\nsd.sd_control_offset = SEECTL;\r\nsd.sd_status_offset = SEECTL;\r\nsd.sd_dataout_offset = SEECTL;\r\nif (ahc->flags & AHC_LARGE_SEEPROM)\r\nsd.sd_chip = C56_66;\r\nelse\r\nsd.sd_chip = C46;\r\nsd.sd_MS = SEEMS;\r\nsd.sd_RDY = SEERDY;\r\nsd.sd_CS = SEECS;\r\nsd.sd_CK = SEECK;\r\nsd.sd_DO = SEEDO;\r\nsd.sd_DI = SEEDI;\r\nhave_seeprom = ahc_acquire_seeprom(ahc, &sd);\r\n} else\r\n#endif\r\nif ((ahc->chip & AHC_VL) != 0) {\r\nsd.sd_control_offset = SEECTL_2840;\r\nsd.sd_status_offset = STATUS_2840;\r\nsd.sd_dataout_offset = STATUS_2840;\r\nsd.sd_chip = C46;\r\nsd.sd_MS = 0;\r\nsd.sd_RDY = EEPROM_TF;\r\nsd.sd_CS = CS_2840;\r\nsd.sd_CK = CK_2840;\r\nsd.sd_DO = DO_2840;\r\nsd.sd_DI = DI_2840;\r\nhave_seeprom = TRUE;\r\n} else {\r\nprintk("ahc_proc_write_seeprom: unsupported adapter type\n");\r\ngoto done;\r\n}\r\nif (!have_seeprom) {\r\nprintk("ahc_proc_write_seeprom: No Serial EEPROM\n");\r\ngoto done;\r\n} else {\r\nu_int start_addr;\r\nif (ahc->seep_config == NULL) {\r\nahc->seep_config = kmalloc(sizeof(*ahc->seep_config), GFP_ATOMIC);\r\nif (ahc->seep_config == NULL) {\r\nprintk("aic7xxx: Unable to allocate serial "\r\n"eeprom buffer. Write failing\n");\r\ngoto done;\r\n}\r\n}\r\nprintk("aic7xxx: Writing Serial EEPROM\n");\r\nstart_addr = 32 * (ahc->channel - 'A');\r\nahc_write_seeprom(&sd, (u_int16_t *)buffer, start_addr,\r\nsizeof(struct seeprom_config)/2);\r\nahc_read_seeprom(&sd, (uint16_t *)ahc->seep_config,\r\nstart_addr, sizeof(struct seeprom_config)/2);\r\n#if AHC_PCI_CONFIG > 0\r\nif ((ahc->chip & AHC_VL) == 0)\r\nahc_release_seeprom(&sd);\r\n#endif\r\nwritten = length;\r\n}\r\ndone:\r\nif (!paused)\r\nahc_unpause(ahc);\r\nahc_unlock(ahc, &s);\r\nreturn (written);\r\n}\r\nint\r\nahc_linux_show_info(struct seq_file *m, struct Scsi_Host *shost)\r\n{\r\nstruct ahc_softc *ahc = *(struct ahc_softc **)shost->hostdata;\r\nchar ahc_info[256];\r\nu_int max_targ;\r\nu_int i;\r\nseq_printf(m, "Adaptec AIC7xxx driver version: %s\n",\r\nAIC7XXX_DRIVER_VERSION);\r\nseq_printf(m, "%s\n", ahc->description);\r\nahc_controller_info(ahc, ahc_info);\r\nseq_printf(m, "%s\n", ahc_info);\r\nseq_printf(m, "Allocated SCBs: %d, SG List Length: %d\n\n",\r\nahc->scb_data->numscbs, AHC_NSEG);\r\nif (ahc->seep_config == NULL)\r\nseq_puts(m, "No Serial EEPROM\n");\r\nelse {\r\nseq_puts(m, "Serial EEPROM:\n");\r\nfor (i = 0; i < sizeof(*ahc->seep_config)/2; i++) {\r\nif (((i % 8) == 0) && (i != 0)) {\r\nseq_putc(m, '\n');\r\n}\r\nseq_printf(m, "0x%.4x ",\r\n((uint16_t*)ahc->seep_config)[i]);\r\n}\r\nseq_putc(m, '\n');\r\n}\r\nseq_putc(m, '\n');\r\nmax_targ = 16;\r\nif ((ahc->features & (AHC_WIDE|AHC_TWIN)) == 0)\r\nmax_targ = 8;\r\nfor (i = 0; i < max_targ; i++) {\r\nu_int our_id;\r\nu_int target_id;\r\nchar channel;\r\nchannel = 'A';\r\nour_id = ahc->our_id;\r\ntarget_id = i;\r\nif (i > 7 && (ahc->features & AHC_TWIN) != 0) {\r\nchannel = 'B';\r\nour_id = ahc->our_id_b;\r\ntarget_id = i % 8;\r\n}\r\nahc_dump_target_state(ahc, m, our_id,\r\nchannel, target_id, i);\r\n}\r\nreturn 0;\r\n}
