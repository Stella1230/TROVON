static u32 qed_cxt_cdu_iids(struct qed_cxt_mngr *p_mngr)\r\n{\r\nu32 type, pf_cids = 0;\r\nfor (type = 0; type < MAX_CONN_TYPES; type++)\r\npf_cids += p_mngr->conn_cfg[type].cid_count;\r\nreturn pf_cids;\r\n}\r\nstatic void qed_cxt_qm_iids(struct qed_hwfn *p_hwfn,\r\nstruct qed_qm_iids *iids)\r\n{\r\nstruct qed_cxt_mngr *p_mngr = p_hwfn->p_cxt_mngr;\r\nint type;\r\nfor (type = 0; type < MAX_CONN_TYPES; type++)\r\niids->cids += p_mngr->conn_cfg[type].cid_count;\r\nDP_VERBOSE(p_hwfn, QED_MSG_ILT, "iids: CIDS %08x\n", iids->cids);\r\n}\r\nstatic void qed_cxt_set_proto_cid_count(struct qed_hwfn *p_hwfn,\r\nenum protocol_type type,\r\nu32 cid_count)\r\n{\r\nstruct qed_cxt_mngr *p_mgr = p_hwfn->p_cxt_mngr;\r\nstruct qed_conn_type_cfg *p_conn = &p_mgr->conn_cfg[type];\r\np_conn->cid_count = roundup(cid_count, DQ_RANGE_ALIGN);\r\n}\r\nstatic void qed_ilt_cli_blk_fill(struct qed_ilt_client_cfg *p_cli,\r\nstruct qed_ilt_cli_blk *p_blk,\r\nu32 start_line, u32 total_size,\r\nu32 elem_size)\r\n{\r\nu32 ilt_size = ILT_PAGE_IN_BYTES(p_cli->p_size.val);\r\nif (p_blk->total_size)\r\nreturn;\r\np_blk->total_size = total_size;\r\np_blk->real_size_in_page = 0;\r\nif (elem_size)\r\np_blk->real_size_in_page = (ilt_size / elem_size) * elem_size;\r\np_blk->start_line = start_line;\r\n}\r\nstatic void qed_ilt_cli_adv_line(struct qed_hwfn *p_hwfn,\r\nstruct qed_ilt_client_cfg *p_cli,\r\nstruct qed_ilt_cli_blk *p_blk,\r\nu32 *p_line, enum ilt_clients client_id)\r\n{\r\nif (!p_blk->total_size)\r\nreturn;\r\nif (!p_cli->active)\r\np_cli->first.val = *p_line;\r\np_cli->active = true;\r\n*p_line += DIV_ROUND_UP(p_blk->total_size,\r\np_blk->real_size_in_page);\r\np_cli->last.val = *p_line - 1;\r\nDP_VERBOSE(p_hwfn, QED_MSG_ILT,\r\n"ILT[Client %d] - Lines: [%08x - %08x]. Block - Size %08x [Real %08x] Start line %d\n",\r\nclient_id, p_cli->first.val,\r\np_cli->last.val, p_blk->total_size,\r\np_blk->real_size_in_page, p_blk->start_line);\r\n}\r\nint qed_cxt_cfg_ilt_compute(struct qed_hwfn *p_hwfn)\r\n{\r\nstruct qed_cxt_mngr *p_mngr = p_hwfn->p_cxt_mngr;\r\nstruct qed_ilt_client_cfg *p_cli;\r\nstruct qed_ilt_cli_blk *p_blk;\r\nu32 curr_line, total, pf_cids;\r\nstruct qed_qm_iids qm_iids;\r\nmemset(&qm_iids, 0, sizeof(qm_iids));\r\np_mngr->pf_start_line = RESC_START(p_hwfn, QED_ILT);\r\nDP_VERBOSE(p_hwfn, QED_MSG_ILT,\r\n"hwfn [%d] - Set context manager starting line to be 0x%08x\n",\r\np_hwfn->my_id, p_hwfn->p_cxt_mngr->pf_start_line);\r\np_cli = &p_mngr->clients[ILT_CLI_CDUC];\r\ncurr_line = p_mngr->pf_start_line;\r\np_cli->pf_total_lines = 0;\r\npf_cids = qed_cxt_cdu_iids(p_mngr);\r\np_blk = &p_cli->pf_blks[CDUC_BLK];\r\ntotal = pf_cids * CONN_CXT_SIZE(p_hwfn);\r\nqed_ilt_cli_blk_fill(p_cli, p_blk, curr_line,\r\ntotal, CONN_CXT_SIZE(p_hwfn));\r\nqed_ilt_cli_adv_line(p_hwfn, p_cli, p_blk, &curr_line, ILT_CLI_CDUC);\r\np_cli->pf_total_lines = curr_line - p_blk->start_line;\r\np_cli = &p_mngr->clients[ILT_CLI_QM];\r\np_blk = &p_cli->pf_blks[0];\r\nqed_cxt_qm_iids(p_hwfn, &qm_iids);\r\ntotal = qed_qm_pf_mem_size(p_hwfn->rel_pf_id, qm_iids.cids, 0, 0,\r\np_hwfn->qm_info.num_pqs, 0);\r\nDP_VERBOSE(p_hwfn, QED_MSG_ILT,\r\n"QM ILT Info, (cids=%d, num_pqs=%d, memory_size=%d)\n",\r\nqm_iids.cids, p_hwfn->qm_info.num_pqs, total);\r\nqed_ilt_cli_blk_fill(p_cli, p_blk,\r\ncurr_line, total * 0x1000,\r\nQM_PQ_ELEMENT_SIZE);\r\nqed_ilt_cli_adv_line(p_hwfn, p_cli, p_blk, &curr_line, ILT_CLI_QM);\r\np_cli->pf_total_lines = curr_line - p_blk->start_line;\r\nif (curr_line - p_hwfn->p_cxt_mngr->pf_start_line >\r\nRESC_NUM(p_hwfn, QED_ILT)) {\r\nDP_ERR(p_hwfn, "too many ilt lines...#lines=%d\n",\r\ncurr_line - p_hwfn->p_cxt_mngr->pf_start_line);\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic u32 qed_cxt_ilt_shadow_size(struct qed_ilt_client_cfg *ilt_clients)\r\n{\r\nu32 size = 0;\r\nu32 i;\r\nfor_each_ilt_valid_client(i, ilt_clients) {\r\nif (!ilt_clients[i].active)\r\ncontinue;\r\nsize += (ilt_clients[i].last.val -\r\nilt_clients[i].first.val + 1);\r\n}\r\nreturn size;\r\n}\r\nstatic void qed_ilt_shadow_free(struct qed_hwfn *p_hwfn)\r\n{\r\nstruct qed_ilt_client_cfg *p_cli = p_hwfn->p_cxt_mngr->clients;\r\nstruct qed_cxt_mngr *p_mngr = p_hwfn->p_cxt_mngr;\r\nu32 ilt_size, i;\r\nilt_size = qed_cxt_ilt_shadow_size(p_cli);\r\nfor (i = 0; p_mngr->ilt_shadow && i < ilt_size; i++) {\r\nstruct qed_dma_mem *p_dma = &p_mngr->ilt_shadow[i];\r\nif (p_dma->p_virt)\r\ndma_free_coherent(&p_hwfn->cdev->pdev->dev,\r\np_dma->size, p_dma->p_virt,\r\np_dma->p_phys);\r\np_dma->p_virt = NULL;\r\n}\r\nkfree(p_mngr->ilt_shadow);\r\n}\r\nstatic int qed_ilt_blk_alloc(struct qed_hwfn *p_hwfn,\r\nstruct qed_ilt_cli_blk *p_blk,\r\nenum ilt_clients ilt_client,\r\nu32 start_line_offset)\r\n{\r\nstruct qed_dma_mem *ilt_shadow = p_hwfn->p_cxt_mngr->ilt_shadow;\r\nu32 lines, line, sz_left;\r\nif (!p_blk->total_size)\r\nreturn 0;\r\nsz_left = p_blk->total_size;\r\nlines = DIV_ROUND_UP(sz_left, p_blk->real_size_in_page);\r\nline = p_blk->start_line + start_line_offset -\r\np_hwfn->p_cxt_mngr->pf_start_line;\r\nfor (; lines; lines--) {\r\ndma_addr_t p_phys;\r\nvoid *p_virt;\r\nu32 size;\r\nsize = min_t(u32, sz_left,\r\np_blk->real_size_in_page);\r\np_virt = dma_alloc_coherent(&p_hwfn->cdev->pdev->dev,\r\nsize,\r\n&p_phys,\r\nGFP_KERNEL);\r\nif (!p_virt)\r\nreturn -ENOMEM;\r\nmemset(p_virt, 0, size);\r\nilt_shadow[line].p_phys = p_phys;\r\nilt_shadow[line].p_virt = p_virt;\r\nilt_shadow[line].size = size;\r\nDP_VERBOSE(p_hwfn, QED_MSG_ILT,\r\n"ILT shadow: Line [%d] Physical 0x%llx Virtual %p Size %d\n",\r\nline, (u64)p_phys, p_virt, size);\r\nsz_left -= size;\r\nline++;\r\n}\r\nreturn 0;\r\n}\r\nstatic int qed_ilt_shadow_alloc(struct qed_hwfn *p_hwfn)\r\n{\r\nstruct qed_cxt_mngr *p_mngr = p_hwfn->p_cxt_mngr;\r\nstruct qed_ilt_client_cfg *clients = p_mngr->clients;\r\nstruct qed_ilt_cli_blk *p_blk;\r\nu32 size, i, j;\r\nint rc;\r\nsize = qed_cxt_ilt_shadow_size(clients);\r\np_mngr->ilt_shadow = kcalloc(size, sizeof(struct qed_dma_mem),\r\nGFP_KERNEL);\r\nif (!p_mngr->ilt_shadow) {\r\nDP_NOTICE(p_hwfn, "Failed to allocate ilt shadow table\n");\r\nrc = -ENOMEM;\r\ngoto ilt_shadow_fail;\r\n}\r\nDP_VERBOSE(p_hwfn, QED_MSG_ILT,\r\n"Allocated 0x%x bytes for ilt shadow\n",\r\n(u32)(size * sizeof(struct qed_dma_mem)));\r\nfor_each_ilt_valid_client(i, clients) {\r\nif (!clients[i].active)\r\ncontinue;\r\nfor (j = 0; j < ILT_CLI_PF_BLOCKS; j++) {\r\np_blk = &clients[i].pf_blks[j];\r\nrc = qed_ilt_blk_alloc(p_hwfn, p_blk, i, 0);\r\nif (rc != 0)\r\ngoto ilt_shadow_fail;\r\n}\r\n}\r\nreturn 0;\r\nilt_shadow_fail:\r\nqed_ilt_shadow_free(p_hwfn);\r\nreturn rc;\r\n}\r\nstatic void qed_cid_map_free(struct qed_hwfn *p_hwfn)\r\n{\r\nstruct qed_cxt_mngr *p_mngr = p_hwfn->p_cxt_mngr;\r\nu32 type;\r\nfor (type = 0; type < MAX_CONN_TYPES; type++) {\r\nkfree(p_mngr->acquired[type].cid_map);\r\np_mngr->acquired[type].max_count = 0;\r\np_mngr->acquired[type].start_cid = 0;\r\n}\r\n}\r\nstatic int qed_cid_map_alloc(struct qed_hwfn *p_hwfn)\r\n{\r\nstruct qed_cxt_mngr *p_mngr = p_hwfn->p_cxt_mngr;\r\nu32 start_cid = 0;\r\nu32 type;\r\nfor (type = 0; type < MAX_CONN_TYPES; type++) {\r\nu32 cid_cnt = p_hwfn->p_cxt_mngr->conn_cfg[type].cid_count;\r\nu32 size;\r\nif (cid_cnt == 0)\r\ncontinue;\r\nsize = DIV_ROUND_UP(cid_cnt,\r\nsizeof(unsigned long) * BITS_PER_BYTE) *\r\nsizeof(unsigned long);\r\np_mngr->acquired[type].cid_map = kzalloc(size, GFP_KERNEL);\r\nif (!p_mngr->acquired[type].cid_map)\r\ngoto cid_map_fail;\r\np_mngr->acquired[type].max_count = cid_cnt;\r\np_mngr->acquired[type].start_cid = start_cid;\r\np_hwfn->p_cxt_mngr->conn_cfg[type].cid_start = start_cid;\r\nDP_VERBOSE(p_hwfn, QED_MSG_CXT,\r\n"Type %08x start: %08x count %08x\n",\r\ntype, p_mngr->acquired[type].start_cid,\r\np_mngr->acquired[type].max_count);\r\nstart_cid += cid_cnt;\r\n}\r\nreturn 0;\r\ncid_map_fail:\r\nqed_cid_map_free(p_hwfn);\r\nreturn -ENOMEM;\r\n}\r\nint qed_cxt_mngr_alloc(struct qed_hwfn *p_hwfn)\r\n{\r\nstruct qed_cxt_mngr *p_mngr;\r\nu32 i;\r\np_mngr = kzalloc(sizeof(*p_mngr), GFP_ATOMIC);\r\nif (!p_mngr) {\r\nDP_NOTICE(p_hwfn, "Failed to allocate `struct qed_cxt_mngr'\n");\r\nreturn -ENOMEM;\r\n}\r\np_mngr->clients[ILT_CLI_CDUC].first.reg = ILT_CFG_REG(CDUC, FIRST_ILT);\r\np_mngr->clients[ILT_CLI_CDUC].last.reg = ILT_CFG_REG(CDUC, LAST_ILT);\r\np_mngr->clients[ILT_CLI_CDUC].p_size.reg = ILT_CFG_REG(CDUC, P_SIZE);\r\np_mngr->clients[ILT_CLI_QM].first.reg = ILT_CFG_REG(QM, FIRST_ILT);\r\np_mngr->clients[ILT_CLI_QM].last.reg = ILT_CFG_REG(QM, LAST_ILT);\r\np_mngr->clients[ILT_CLI_QM].p_size.reg = ILT_CFG_REG(QM, P_SIZE);\r\nfor (i = 0; i < ILT_CLI_MAX; i++)\r\np_mngr->clients[i].p_size.val = ILT_DEFAULT_HW_P_SIZE;\r\np_hwfn->p_cxt_mngr = p_mngr;\r\nreturn 0;\r\n}\r\nint qed_cxt_tables_alloc(struct qed_hwfn *p_hwfn)\r\n{\r\nint rc;\r\nrc = qed_ilt_shadow_alloc(p_hwfn);\r\nif (rc) {\r\nDP_NOTICE(p_hwfn, "Failed to allocate ilt memory\n");\r\ngoto tables_alloc_fail;\r\n}\r\nrc = qed_cid_map_alloc(p_hwfn);\r\nif (rc) {\r\nDP_NOTICE(p_hwfn, "Failed to allocate cid maps\n");\r\ngoto tables_alloc_fail;\r\n}\r\nreturn 0;\r\ntables_alloc_fail:\r\nqed_cxt_mngr_free(p_hwfn);\r\nreturn rc;\r\n}\r\nvoid qed_cxt_mngr_free(struct qed_hwfn *p_hwfn)\r\n{\r\nif (!p_hwfn->p_cxt_mngr)\r\nreturn;\r\nqed_cid_map_free(p_hwfn);\r\nqed_ilt_shadow_free(p_hwfn);\r\nkfree(p_hwfn->p_cxt_mngr);\r\np_hwfn->p_cxt_mngr = NULL;\r\n}\r\nvoid qed_cxt_mngr_setup(struct qed_hwfn *p_hwfn)\r\n{\r\nstruct qed_cxt_mngr *p_mngr = p_hwfn->p_cxt_mngr;\r\nint type;\r\nfor (type = 0; type < MAX_CONN_TYPES; type++) {\r\nu32 cid_cnt = p_hwfn->p_cxt_mngr->conn_cfg[type].cid_count;\r\nif (cid_cnt == 0)\r\ncontinue;\r\nmemset(p_mngr->acquired[type].cid_map, 0,\r\nDIV_ROUND_UP(cid_cnt,\r\nsizeof(unsigned long) * BITS_PER_BYTE) *\r\nsizeof(unsigned long));\r\n}\r\n}\r\nstatic void qed_cdu_init_common(struct qed_hwfn *p_hwfn)\r\n{\r\nu32 page_sz, elems_per_page, block_waste, cxt_size, cdu_params = 0;\r\npage_sz = p_hwfn->p_cxt_mngr->clients[ILT_CLI_CDUC].p_size.val;\r\ncxt_size = CONN_CXT_SIZE(p_hwfn);\r\nelems_per_page = ILT_PAGE_IN_BYTES(page_sz) / cxt_size;\r\nblock_waste = ILT_PAGE_IN_BYTES(page_sz) - elems_per_page * cxt_size;\r\nSET_FIELD(cdu_params, CDUC_CXT_SIZE, cxt_size);\r\nSET_FIELD(cdu_params, CDUC_BLOCK_WASTE, block_waste);\r\nSET_FIELD(cdu_params, CDUC_NCIB, elems_per_page);\r\nSTORE_RT_REG(p_hwfn, CDU_REG_CID_ADDR_PARAMS_RT_OFFSET, cdu_params);\r\n}\r\nvoid qed_qm_init_pf(struct qed_hwfn *p_hwfn)\r\n{\r\nstruct qed_qm_pf_rt_init_params params;\r\nstruct qed_qm_info *qm_info = &p_hwfn->qm_info;\r\nstruct qed_qm_iids iids;\r\nmemset(&iids, 0, sizeof(iids));\r\nqed_cxt_qm_iids(p_hwfn, &iids);\r\nmemset(&params, 0, sizeof(params));\r\nparams.port_id = p_hwfn->port_id;\r\nparams.pf_id = p_hwfn->rel_pf_id;\r\nparams.max_phys_tcs_per_port = qm_info->max_phys_tcs_per_port;\r\nparams.is_first_pf = p_hwfn->first_on_engine;\r\nparams.num_pf_cids = iids.cids;\r\nparams.start_pq = qm_info->start_pq;\r\nparams.num_pf_pqs = qm_info->num_pqs;\r\nparams.start_vport = qm_info->num_vports;\r\nparams.pf_wfq = qm_info->pf_wfq;\r\nparams.pf_rl = qm_info->pf_rl;\r\nparams.pq_params = qm_info->qm_pq_params;\r\nparams.vport_params = qm_info->qm_vport_params;\r\nqed_qm_pf_rt_init(p_hwfn, p_hwfn->p_main_ptt, &params);\r\n}\r\nstatic int qed_cm_init_pf(struct qed_hwfn *p_hwfn)\r\n{\r\nunion qed_qm_pq_params pq_params;\r\nu16 pq;\r\nmemset(&pq_params, 0, sizeof(pq_params));\r\npq_params.core.tc = LB_TC;\r\npq = qed_get_qm_pq(p_hwfn, PROTOCOLID_CORE, &pq_params);\r\nSTORE_RT_REG(p_hwfn, XCM_REG_CON_PHY_Q3_RT_OFFSET, pq);\r\nreturn 0;\r\n}\r\nstatic void qed_dq_init_pf(struct qed_hwfn *p_hwfn)\r\n{\r\nstruct qed_cxt_mngr *p_mngr = p_hwfn->p_cxt_mngr;\r\nu32 dq_pf_max_cid = 0;\r\ndq_pf_max_cid += (p_mngr->conn_cfg[0].cid_count >> DQ_RANGE_SHIFT);\r\nSTORE_RT_REG(p_hwfn, DORQ_REG_PF_MAX_ICID_0_RT_OFFSET, dq_pf_max_cid);\r\ndq_pf_max_cid += (p_mngr->conn_cfg[1].cid_count >> DQ_RANGE_SHIFT);\r\nSTORE_RT_REG(p_hwfn, DORQ_REG_PF_MAX_ICID_1_RT_OFFSET, dq_pf_max_cid);\r\ndq_pf_max_cid += (p_mngr->conn_cfg[2].cid_count >> DQ_RANGE_SHIFT);\r\nSTORE_RT_REG(p_hwfn, DORQ_REG_PF_MAX_ICID_2_RT_OFFSET, dq_pf_max_cid);\r\ndq_pf_max_cid += (p_mngr->conn_cfg[3].cid_count >> DQ_RANGE_SHIFT);\r\nSTORE_RT_REG(p_hwfn, DORQ_REG_PF_MAX_ICID_3_RT_OFFSET, dq_pf_max_cid);\r\ndq_pf_max_cid += (p_mngr->conn_cfg[4].cid_count >> DQ_RANGE_SHIFT);\r\nSTORE_RT_REG(p_hwfn, DORQ_REG_PF_MAX_ICID_4_RT_OFFSET, dq_pf_max_cid);\r\ndq_pf_max_cid += (p_mngr->conn_cfg[5].cid_count >> DQ_RANGE_SHIFT);\r\nSTORE_RT_REG(p_hwfn, DORQ_REG_PF_MAX_ICID_5_RT_OFFSET, dq_pf_max_cid);\r\n}\r\nstatic void qed_ilt_bounds_init(struct qed_hwfn *p_hwfn)\r\n{\r\nstruct qed_ilt_client_cfg *ilt_clients;\r\nint i;\r\nilt_clients = p_hwfn->p_cxt_mngr->clients;\r\nfor_each_ilt_valid_client(i, ilt_clients) {\r\nif (!ilt_clients[i].active)\r\ncontinue;\r\nSTORE_RT_REG(p_hwfn,\r\nilt_clients[i].first.reg,\r\nilt_clients[i].first.val);\r\nSTORE_RT_REG(p_hwfn,\r\nilt_clients[i].last.reg,\r\nilt_clients[i].last.val);\r\nSTORE_RT_REG(p_hwfn,\r\nilt_clients[i].p_size.reg,\r\nilt_clients[i].p_size.val);\r\n}\r\n}\r\nstatic void qed_ilt_init_pf(struct qed_hwfn *p_hwfn)\r\n{\r\nstruct qed_ilt_client_cfg *clients;\r\nstruct qed_cxt_mngr *p_mngr;\r\nstruct qed_dma_mem *p_shdw;\r\nu32 line, rt_offst, i;\r\nqed_ilt_bounds_init(p_hwfn);\r\np_mngr = p_hwfn->p_cxt_mngr;\r\np_shdw = p_mngr->ilt_shadow;\r\nclients = p_hwfn->p_cxt_mngr->clients;\r\nfor_each_ilt_valid_client(i, clients) {\r\nif (!clients[i].active)\r\ncontinue;\r\nline = clients[i].first.val - p_mngr->pf_start_line;\r\nrt_offst = PSWRQ2_REG_ILT_MEMORY_RT_OFFSET +\r\nclients[i].first.val * ILT_ENTRY_IN_REGS;\r\nfor (; line <= clients[i].last.val - p_mngr->pf_start_line;\r\nline++, rt_offst += ILT_ENTRY_IN_REGS) {\r\nu64 ilt_hw_entry = 0;\r\nif (p_shdw[line].p_virt) {\r\nSET_FIELD(ilt_hw_entry, ILT_ENTRY_VALID, 1ULL);\r\nSET_FIELD(ilt_hw_entry, ILT_ENTRY_PHY_ADDR,\r\n(p_shdw[line].p_phys >> 12));\r\nDP_VERBOSE(p_hwfn, QED_MSG_ILT,\r\n"Setting RT[0x%08x] from ILT[0x%08x] [Client is %d] to Physical addr: 0x%llx\n",\r\nrt_offst, line, i,\r\n(u64)(p_shdw[line].p_phys >> 12));\r\n}\r\nSTORE_RT_REG_AGG(p_hwfn, rt_offst, ilt_hw_entry);\r\n}\r\n}\r\n}\r\nvoid qed_cxt_hw_init_common(struct qed_hwfn *p_hwfn)\r\n{\r\nqed_cdu_init_common(p_hwfn);\r\n}\r\nvoid qed_cxt_hw_init_pf(struct qed_hwfn *p_hwfn)\r\n{\r\nqed_qm_init_pf(p_hwfn);\r\nqed_cm_init_pf(p_hwfn);\r\nqed_dq_init_pf(p_hwfn);\r\nqed_ilt_init_pf(p_hwfn);\r\n}\r\nint qed_cxt_acquire_cid(struct qed_hwfn *p_hwfn,\r\nenum protocol_type type,\r\nu32 *p_cid)\r\n{\r\nstruct qed_cxt_mngr *p_mngr = p_hwfn->p_cxt_mngr;\r\nu32 rel_cid;\r\nif (type >= MAX_CONN_TYPES || !p_mngr->acquired[type].cid_map) {\r\nDP_NOTICE(p_hwfn, "Invalid protocol type %d", type);\r\nreturn -EINVAL;\r\n}\r\nrel_cid = find_first_zero_bit(p_mngr->acquired[type].cid_map,\r\np_mngr->acquired[type].max_count);\r\nif (rel_cid >= p_mngr->acquired[type].max_count) {\r\nDP_NOTICE(p_hwfn, "no CID available for protocol %d\n",\r\ntype);\r\nreturn -EINVAL;\r\n}\r\n__set_bit(rel_cid, p_mngr->acquired[type].cid_map);\r\n*p_cid = rel_cid + p_mngr->acquired[type].start_cid;\r\nreturn 0;\r\n}\r\nstatic bool qed_cxt_test_cid_acquired(struct qed_hwfn *p_hwfn,\r\nu32 cid,\r\nenum protocol_type *p_type)\r\n{\r\nstruct qed_cxt_mngr *p_mngr = p_hwfn->p_cxt_mngr;\r\nstruct qed_cid_acquired_map *p_map;\r\nenum protocol_type p;\r\nu32 rel_cid;\r\nfor (p = 0; p < MAX_CONN_TYPES; p++) {\r\np_map = &p_mngr->acquired[p];\r\nif (!p_map->cid_map)\r\ncontinue;\r\nif (cid >= p_map->start_cid &&\r\ncid < p_map->start_cid + p_map->max_count)\r\nbreak;\r\n}\r\n*p_type = p;\r\nif (p == MAX_CONN_TYPES) {\r\nDP_NOTICE(p_hwfn, "Invalid CID %d", cid);\r\nreturn false;\r\n}\r\nrel_cid = cid - p_map->start_cid;\r\nif (!test_bit(rel_cid, p_map->cid_map)) {\r\nDP_NOTICE(p_hwfn, "CID %d not acquired", cid);\r\nreturn false;\r\n}\r\nreturn true;\r\n}\r\nvoid qed_cxt_release_cid(struct qed_hwfn *p_hwfn,\r\nu32 cid)\r\n{\r\nstruct qed_cxt_mngr *p_mngr = p_hwfn->p_cxt_mngr;\r\nenum protocol_type type;\r\nbool b_acquired;\r\nu32 rel_cid;\r\nb_acquired = qed_cxt_test_cid_acquired(p_hwfn, cid, &type);\r\nif (!b_acquired)\r\nreturn;\r\nrel_cid = cid - p_mngr->acquired[type].start_cid;\r\n__clear_bit(rel_cid, p_mngr->acquired[type].cid_map);\r\n}\r\nint qed_cxt_get_cid_info(struct qed_hwfn *p_hwfn,\r\nstruct qed_cxt_info *p_info)\r\n{\r\nstruct qed_cxt_mngr *p_mngr = p_hwfn->p_cxt_mngr;\r\nu32 conn_cxt_size, hw_p_size, cxts_per_p, line;\r\nenum protocol_type type;\r\nbool b_acquired;\r\nb_acquired = qed_cxt_test_cid_acquired(p_hwfn, p_info->iid, &type);\r\nif (!b_acquired)\r\nreturn -EINVAL;\r\np_info->type = type;\r\nhw_p_size = p_hwfn->p_cxt_mngr->clients[ILT_CLI_CDUC].p_size.val;\r\nconn_cxt_size = CONN_CXT_SIZE(p_hwfn);\r\ncxts_per_p = ILT_PAGE_IN_BYTES(hw_p_size) / conn_cxt_size;\r\nline = p_info->iid / cxts_per_p;\r\nif (!p_mngr->ilt_shadow[line].p_virt)\r\nreturn -EINVAL;\r\np_info->p_cxt = p_mngr->ilt_shadow[line].p_virt +\r\np_info->iid % cxts_per_p * conn_cxt_size;\r\nDP_VERBOSE(p_hwfn, (QED_MSG_ILT | QED_MSG_CXT),\r\n"Accessing ILT shadow[%d]: CXT pointer is at %p (for iid %d)\n",\r\np_info->iid / cxts_per_p, p_info->p_cxt, p_info->iid);\r\nreturn 0;\r\n}\r\nint qed_cxt_set_pf_params(struct qed_hwfn *p_hwfn)\r\n{\r\nstruct qed_eth_pf_params *p_params = &p_hwfn->pf_params.eth_pf_params;\r\nu32 core_cids = 1;\r\nqed_cxt_set_proto_cid_count(p_hwfn, PROTOCOLID_CORE, core_cids);\r\nqed_cxt_set_proto_cid_count(p_hwfn, PROTOCOLID_ETH,\r\np_params->num_cons);\r\nreturn 0;\r\n}
