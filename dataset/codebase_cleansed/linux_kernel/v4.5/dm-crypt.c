static struct crypto_ablkcipher *any_tfm(struct crypt_config *cc)\r\n{\r\nreturn cc->tfms[0];\r\n}\r\nstatic int crypt_iv_plain_gen(struct crypt_config *cc, u8 *iv,\r\nstruct dm_crypt_request *dmreq)\r\n{\r\nmemset(iv, 0, cc->iv_size);\r\n*(__le32 *)iv = cpu_to_le32(dmreq->iv_sector & 0xffffffff);\r\nreturn 0;\r\n}\r\nstatic int crypt_iv_plain64_gen(struct crypt_config *cc, u8 *iv,\r\nstruct dm_crypt_request *dmreq)\r\n{\r\nmemset(iv, 0, cc->iv_size);\r\n*(__le64 *)iv = cpu_to_le64(dmreq->iv_sector);\r\nreturn 0;\r\n}\r\nstatic int crypt_iv_essiv_init(struct crypt_config *cc)\r\n{\r\nstruct iv_essiv_private *essiv = &cc->iv_gen_private.essiv;\r\nstruct hash_desc desc;\r\nstruct scatterlist sg;\r\nstruct crypto_cipher *essiv_tfm;\r\nint err;\r\nsg_init_one(&sg, cc->key, cc->key_size);\r\ndesc.tfm = essiv->hash_tfm;\r\ndesc.flags = CRYPTO_TFM_REQ_MAY_SLEEP;\r\nerr = crypto_hash_digest(&desc, &sg, cc->key_size, essiv->salt);\r\nif (err)\r\nreturn err;\r\nessiv_tfm = cc->iv_private;\r\nerr = crypto_cipher_setkey(essiv_tfm, essiv->salt,\r\ncrypto_hash_digestsize(essiv->hash_tfm));\r\nif (err)\r\nreturn err;\r\nreturn 0;\r\n}\r\nstatic int crypt_iv_essiv_wipe(struct crypt_config *cc)\r\n{\r\nstruct iv_essiv_private *essiv = &cc->iv_gen_private.essiv;\r\nunsigned salt_size = crypto_hash_digestsize(essiv->hash_tfm);\r\nstruct crypto_cipher *essiv_tfm;\r\nint r, err = 0;\r\nmemset(essiv->salt, 0, salt_size);\r\nessiv_tfm = cc->iv_private;\r\nr = crypto_cipher_setkey(essiv_tfm, essiv->salt, salt_size);\r\nif (r)\r\nerr = r;\r\nreturn err;\r\n}\r\nstatic struct crypto_cipher *setup_essiv_cpu(struct crypt_config *cc,\r\nstruct dm_target *ti,\r\nu8 *salt, unsigned saltsize)\r\n{\r\nstruct crypto_cipher *essiv_tfm;\r\nint err;\r\nessiv_tfm = crypto_alloc_cipher(cc->cipher, 0, CRYPTO_ALG_ASYNC);\r\nif (IS_ERR(essiv_tfm)) {\r\nti->error = "Error allocating crypto tfm for ESSIV";\r\nreturn essiv_tfm;\r\n}\r\nif (crypto_cipher_blocksize(essiv_tfm) !=\r\ncrypto_ablkcipher_ivsize(any_tfm(cc))) {\r\nti->error = "Block size of ESSIV cipher does "\r\n"not match IV size of block cipher";\r\ncrypto_free_cipher(essiv_tfm);\r\nreturn ERR_PTR(-EINVAL);\r\n}\r\nerr = crypto_cipher_setkey(essiv_tfm, salt, saltsize);\r\nif (err) {\r\nti->error = "Failed to set key for ESSIV cipher";\r\ncrypto_free_cipher(essiv_tfm);\r\nreturn ERR_PTR(err);\r\n}\r\nreturn essiv_tfm;\r\n}\r\nstatic void crypt_iv_essiv_dtr(struct crypt_config *cc)\r\n{\r\nstruct crypto_cipher *essiv_tfm;\r\nstruct iv_essiv_private *essiv = &cc->iv_gen_private.essiv;\r\ncrypto_free_hash(essiv->hash_tfm);\r\nessiv->hash_tfm = NULL;\r\nkzfree(essiv->salt);\r\nessiv->salt = NULL;\r\nessiv_tfm = cc->iv_private;\r\nif (essiv_tfm)\r\ncrypto_free_cipher(essiv_tfm);\r\ncc->iv_private = NULL;\r\n}\r\nstatic int crypt_iv_essiv_ctr(struct crypt_config *cc, struct dm_target *ti,\r\nconst char *opts)\r\n{\r\nstruct crypto_cipher *essiv_tfm = NULL;\r\nstruct crypto_hash *hash_tfm = NULL;\r\nu8 *salt = NULL;\r\nint err;\r\nif (!opts) {\r\nti->error = "Digest algorithm missing for ESSIV mode";\r\nreturn -EINVAL;\r\n}\r\nhash_tfm = crypto_alloc_hash(opts, 0, CRYPTO_ALG_ASYNC);\r\nif (IS_ERR(hash_tfm)) {\r\nti->error = "Error initializing ESSIV hash";\r\nerr = PTR_ERR(hash_tfm);\r\ngoto bad;\r\n}\r\nsalt = kzalloc(crypto_hash_digestsize(hash_tfm), GFP_KERNEL);\r\nif (!salt) {\r\nti->error = "Error kmallocing salt storage in ESSIV";\r\nerr = -ENOMEM;\r\ngoto bad;\r\n}\r\ncc->iv_gen_private.essiv.salt = salt;\r\ncc->iv_gen_private.essiv.hash_tfm = hash_tfm;\r\nessiv_tfm = setup_essiv_cpu(cc, ti, salt,\r\ncrypto_hash_digestsize(hash_tfm));\r\nif (IS_ERR(essiv_tfm)) {\r\ncrypt_iv_essiv_dtr(cc);\r\nreturn PTR_ERR(essiv_tfm);\r\n}\r\ncc->iv_private = essiv_tfm;\r\nreturn 0;\r\nbad:\r\nif (hash_tfm && !IS_ERR(hash_tfm))\r\ncrypto_free_hash(hash_tfm);\r\nkfree(salt);\r\nreturn err;\r\n}\r\nstatic int crypt_iv_essiv_gen(struct crypt_config *cc, u8 *iv,\r\nstruct dm_crypt_request *dmreq)\r\n{\r\nstruct crypto_cipher *essiv_tfm = cc->iv_private;\r\nmemset(iv, 0, cc->iv_size);\r\n*(__le64 *)iv = cpu_to_le64(dmreq->iv_sector);\r\ncrypto_cipher_encrypt_one(essiv_tfm, iv, iv);\r\nreturn 0;\r\n}\r\nstatic int crypt_iv_benbi_ctr(struct crypt_config *cc, struct dm_target *ti,\r\nconst char *opts)\r\n{\r\nunsigned bs = crypto_ablkcipher_blocksize(any_tfm(cc));\r\nint log = ilog2(bs);\r\nif (1 << log != bs) {\r\nti->error = "cypher blocksize is not a power of 2";\r\nreturn -EINVAL;\r\n}\r\nif (log > 9) {\r\nti->error = "cypher blocksize is > 512";\r\nreturn -EINVAL;\r\n}\r\ncc->iv_gen_private.benbi.shift = 9 - log;\r\nreturn 0;\r\n}\r\nstatic void crypt_iv_benbi_dtr(struct crypt_config *cc)\r\n{\r\n}\r\nstatic int crypt_iv_benbi_gen(struct crypt_config *cc, u8 *iv,\r\nstruct dm_crypt_request *dmreq)\r\n{\r\n__be64 val;\r\nmemset(iv, 0, cc->iv_size - sizeof(u64));\r\nval = cpu_to_be64(((u64)dmreq->iv_sector << cc->iv_gen_private.benbi.shift) + 1);\r\nput_unaligned(val, (__be64 *)(iv + cc->iv_size - sizeof(u64)));\r\nreturn 0;\r\n}\r\nstatic int crypt_iv_null_gen(struct crypt_config *cc, u8 *iv,\r\nstruct dm_crypt_request *dmreq)\r\n{\r\nmemset(iv, 0, cc->iv_size);\r\nreturn 0;\r\n}\r\nstatic void crypt_iv_lmk_dtr(struct crypt_config *cc)\r\n{\r\nstruct iv_lmk_private *lmk = &cc->iv_gen_private.lmk;\r\nif (lmk->hash_tfm && !IS_ERR(lmk->hash_tfm))\r\ncrypto_free_shash(lmk->hash_tfm);\r\nlmk->hash_tfm = NULL;\r\nkzfree(lmk->seed);\r\nlmk->seed = NULL;\r\n}\r\nstatic int crypt_iv_lmk_ctr(struct crypt_config *cc, struct dm_target *ti,\r\nconst char *opts)\r\n{\r\nstruct iv_lmk_private *lmk = &cc->iv_gen_private.lmk;\r\nlmk->hash_tfm = crypto_alloc_shash("md5", 0, 0);\r\nif (IS_ERR(lmk->hash_tfm)) {\r\nti->error = "Error initializing LMK hash";\r\nreturn PTR_ERR(lmk->hash_tfm);\r\n}\r\nif (cc->key_parts == cc->tfms_count) {\r\nlmk->seed = NULL;\r\nreturn 0;\r\n}\r\nlmk->seed = kzalloc(LMK_SEED_SIZE, GFP_KERNEL);\r\nif (!lmk->seed) {\r\ncrypt_iv_lmk_dtr(cc);\r\nti->error = "Error kmallocing seed storage in LMK";\r\nreturn -ENOMEM;\r\n}\r\nreturn 0;\r\n}\r\nstatic int crypt_iv_lmk_init(struct crypt_config *cc)\r\n{\r\nstruct iv_lmk_private *lmk = &cc->iv_gen_private.lmk;\r\nint subkey_size = cc->key_size / cc->key_parts;\r\nif (lmk->seed)\r\nmemcpy(lmk->seed, cc->key + (cc->tfms_count * subkey_size),\r\ncrypto_shash_digestsize(lmk->hash_tfm));\r\nreturn 0;\r\n}\r\nstatic int crypt_iv_lmk_wipe(struct crypt_config *cc)\r\n{\r\nstruct iv_lmk_private *lmk = &cc->iv_gen_private.lmk;\r\nif (lmk->seed)\r\nmemset(lmk->seed, 0, LMK_SEED_SIZE);\r\nreturn 0;\r\n}\r\nstatic int crypt_iv_lmk_one(struct crypt_config *cc, u8 *iv,\r\nstruct dm_crypt_request *dmreq,\r\nu8 *data)\r\n{\r\nstruct iv_lmk_private *lmk = &cc->iv_gen_private.lmk;\r\nSHASH_DESC_ON_STACK(desc, lmk->hash_tfm);\r\nstruct md5_state md5state;\r\n__le32 buf[4];\r\nint i, r;\r\ndesc->tfm = lmk->hash_tfm;\r\ndesc->flags = CRYPTO_TFM_REQ_MAY_SLEEP;\r\nr = crypto_shash_init(desc);\r\nif (r)\r\nreturn r;\r\nif (lmk->seed) {\r\nr = crypto_shash_update(desc, lmk->seed, LMK_SEED_SIZE);\r\nif (r)\r\nreturn r;\r\n}\r\nr = crypto_shash_update(desc, data + 16, 16 * 31);\r\nif (r)\r\nreturn r;\r\nbuf[0] = cpu_to_le32(dmreq->iv_sector & 0xFFFFFFFF);\r\nbuf[1] = cpu_to_le32((((u64)dmreq->iv_sector >> 32) & 0x00FFFFFF) | 0x80000000);\r\nbuf[2] = cpu_to_le32(4024);\r\nbuf[3] = 0;\r\nr = crypto_shash_update(desc, (u8 *)buf, sizeof(buf));\r\nif (r)\r\nreturn r;\r\nr = crypto_shash_export(desc, &md5state);\r\nif (r)\r\nreturn r;\r\nfor (i = 0; i < MD5_HASH_WORDS; i++)\r\n__cpu_to_le32s(&md5state.hash[i]);\r\nmemcpy(iv, &md5state.hash, cc->iv_size);\r\nreturn 0;\r\n}\r\nstatic int crypt_iv_lmk_gen(struct crypt_config *cc, u8 *iv,\r\nstruct dm_crypt_request *dmreq)\r\n{\r\nu8 *src;\r\nint r = 0;\r\nif (bio_data_dir(dmreq->ctx->bio_in) == WRITE) {\r\nsrc = kmap_atomic(sg_page(&dmreq->sg_in));\r\nr = crypt_iv_lmk_one(cc, iv, dmreq, src + dmreq->sg_in.offset);\r\nkunmap_atomic(src);\r\n} else\r\nmemset(iv, 0, cc->iv_size);\r\nreturn r;\r\n}\r\nstatic int crypt_iv_lmk_post(struct crypt_config *cc, u8 *iv,\r\nstruct dm_crypt_request *dmreq)\r\n{\r\nu8 *dst;\r\nint r;\r\nif (bio_data_dir(dmreq->ctx->bio_in) == WRITE)\r\nreturn 0;\r\ndst = kmap_atomic(sg_page(&dmreq->sg_out));\r\nr = crypt_iv_lmk_one(cc, iv, dmreq, dst + dmreq->sg_out.offset);\r\nif (!r)\r\ncrypto_xor(dst + dmreq->sg_out.offset, iv, cc->iv_size);\r\nkunmap_atomic(dst);\r\nreturn r;\r\n}\r\nstatic void crypt_iv_tcw_dtr(struct crypt_config *cc)\r\n{\r\nstruct iv_tcw_private *tcw = &cc->iv_gen_private.tcw;\r\nkzfree(tcw->iv_seed);\r\ntcw->iv_seed = NULL;\r\nkzfree(tcw->whitening);\r\ntcw->whitening = NULL;\r\nif (tcw->crc32_tfm && !IS_ERR(tcw->crc32_tfm))\r\ncrypto_free_shash(tcw->crc32_tfm);\r\ntcw->crc32_tfm = NULL;\r\n}\r\nstatic int crypt_iv_tcw_ctr(struct crypt_config *cc, struct dm_target *ti,\r\nconst char *opts)\r\n{\r\nstruct iv_tcw_private *tcw = &cc->iv_gen_private.tcw;\r\nif (cc->key_size <= (cc->iv_size + TCW_WHITENING_SIZE)) {\r\nti->error = "Wrong key size for TCW";\r\nreturn -EINVAL;\r\n}\r\ntcw->crc32_tfm = crypto_alloc_shash("crc32", 0, 0);\r\nif (IS_ERR(tcw->crc32_tfm)) {\r\nti->error = "Error initializing CRC32 in TCW";\r\nreturn PTR_ERR(tcw->crc32_tfm);\r\n}\r\ntcw->iv_seed = kzalloc(cc->iv_size, GFP_KERNEL);\r\ntcw->whitening = kzalloc(TCW_WHITENING_SIZE, GFP_KERNEL);\r\nif (!tcw->iv_seed || !tcw->whitening) {\r\ncrypt_iv_tcw_dtr(cc);\r\nti->error = "Error allocating seed storage in TCW";\r\nreturn -ENOMEM;\r\n}\r\nreturn 0;\r\n}\r\nstatic int crypt_iv_tcw_init(struct crypt_config *cc)\r\n{\r\nstruct iv_tcw_private *tcw = &cc->iv_gen_private.tcw;\r\nint key_offset = cc->key_size - cc->iv_size - TCW_WHITENING_SIZE;\r\nmemcpy(tcw->iv_seed, &cc->key[key_offset], cc->iv_size);\r\nmemcpy(tcw->whitening, &cc->key[key_offset + cc->iv_size],\r\nTCW_WHITENING_SIZE);\r\nreturn 0;\r\n}\r\nstatic int crypt_iv_tcw_wipe(struct crypt_config *cc)\r\n{\r\nstruct iv_tcw_private *tcw = &cc->iv_gen_private.tcw;\r\nmemset(tcw->iv_seed, 0, cc->iv_size);\r\nmemset(tcw->whitening, 0, TCW_WHITENING_SIZE);\r\nreturn 0;\r\n}\r\nstatic int crypt_iv_tcw_whitening(struct crypt_config *cc,\r\nstruct dm_crypt_request *dmreq,\r\nu8 *data)\r\n{\r\nstruct iv_tcw_private *tcw = &cc->iv_gen_private.tcw;\r\nu64 sector = cpu_to_le64((u64)dmreq->iv_sector);\r\nu8 buf[TCW_WHITENING_SIZE];\r\nSHASH_DESC_ON_STACK(desc, tcw->crc32_tfm);\r\nint i, r;\r\nmemcpy(buf, tcw->whitening, TCW_WHITENING_SIZE);\r\ncrypto_xor(buf, (u8 *)&sector, 8);\r\ncrypto_xor(&buf[8], (u8 *)&sector, 8);\r\ndesc->tfm = tcw->crc32_tfm;\r\ndesc->flags = CRYPTO_TFM_REQ_MAY_SLEEP;\r\nfor (i = 0; i < 4; i++) {\r\nr = crypto_shash_init(desc);\r\nif (r)\r\ngoto out;\r\nr = crypto_shash_update(desc, &buf[i * 4], 4);\r\nif (r)\r\ngoto out;\r\nr = crypto_shash_final(desc, &buf[i * 4]);\r\nif (r)\r\ngoto out;\r\n}\r\ncrypto_xor(&buf[0], &buf[12], 4);\r\ncrypto_xor(&buf[4], &buf[8], 4);\r\nfor (i = 0; i < ((1 << SECTOR_SHIFT) / 8); i++)\r\ncrypto_xor(data + i * 8, buf, 8);\r\nout:\r\nmemzero_explicit(buf, sizeof(buf));\r\nreturn r;\r\n}\r\nstatic int crypt_iv_tcw_gen(struct crypt_config *cc, u8 *iv,\r\nstruct dm_crypt_request *dmreq)\r\n{\r\nstruct iv_tcw_private *tcw = &cc->iv_gen_private.tcw;\r\nu64 sector = cpu_to_le64((u64)dmreq->iv_sector);\r\nu8 *src;\r\nint r = 0;\r\nif (bio_data_dir(dmreq->ctx->bio_in) != WRITE) {\r\nsrc = kmap_atomic(sg_page(&dmreq->sg_in));\r\nr = crypt_iv_tcw_whitening(cc, dmreq, src + dmreq->sg_in.offset);\r\nkunmap_atomic(src);\r\n}\r\nmemcpy(iv, tcw->iv_seed, cc->iv_size);\r\ncrypto_xor(iv, (u8 *)&sector, 8);\r\nif (cc->iv_size > 8)\r\ncrypto_xor(&iv[8], (u8 *)&sector, cc->iv_size - 8);\r\nreturn r;\r\n}\r\nstatic int crypt_iv_tcw_post(struct crypt_config *cc, u8 *iv,\r\nstruct dm_crypt_request *dmreq)\r\n{\r\nu8 *dst;\r\nint r;\r\nif (bio_data_dir(dmreq->ctx->bio_in) != WRITE)\r\nreturn 0;\r\ndst = kmap_atomic(sg_page(&dmreq->sg_out));\r\nr = crypt_iv_tcw_whitening(cc, dmreq, dst + dmreq->sg_out.offset);\r\nkunmap_atomic(dst);\r\nreturn r;\r\n}\r\nstatic void crypt_convert_init(struct crypt_config *cc,\r\nstruct convert_context *ctx,\r\nstruct bio *bio_out, struct bio *bio_in,\r\nsector_t sector)\r\n{\r\nctx->bio_in = bio_in;\r\nctx->bio_out = bio_out;\r\nif (bio_in)\r\nctx->iter_in = bio_in->bi_iter;\r\nif (bio_out)\r\nctx->iter_out = bio_out->bi_iter;\r\nctx->cc_sector = sector + cc->iv_offset;\r\ninit_completion(&ctx->restart);\r\n}\r\nstatic struct dm_crypt_request *dmreq_of_req(struct crypt_config *cc,\r\nstruct ablkcipher_request *req)\r\n{\r\nreturn (struct dm_crypt_request *)((char *)req + cc->dmreq_start);\r\n}\r\nstatic struct ablkcipher_request *req_of_dmreq(struct crypt_config *cc,\r\nstruct dm_crypt_request *dmreq)\r\n{\r\nreturn (struct ablkcipher_request *)((char *)dmreq - cc->dmreq_start);\r\n}\r\nstatic u8 *iv_of_dmreq(struct crypt_config *cc,\r\nstruct dm_crypt_request *dmreq)\r\n{\r\nreturn (u8 *)ALIGN((unsigned long)(dmreq + 1),\r\ncrypto_ablkcipher_alignmask(any_tfm(cc)) + 1);\r\n}\r\nstatic int crypt_convert_block(struct crypt_config *cc,\r\nstruct convert_context *ctx,\r\nstruct ablkcipher_request *req)\r\n{\r\nstruct bio_vec bv_in = bio_iter_iovec(ctx->bio_in, ctx->iter_in);\r\nstruct bio_vec bv_out = bio_iter_iovec(ctx->bio_out, ctx->iter_out);\r\nstruct dm_crypt_request *dmreq;\r\nu8 *iv;\r\nint r;\r\ndmreq = dmreq_of_req(cc, req);\r\niv = iv_of_dmreq(cc, dmreq);\r\ndmreq->iv_sector = ctx->cc_sector;\r\ndmreq->ctx = ctx;\r\nsg_init_table(&dmreq->sg_in, 1);\r\nsg_set_page(&dmreq->sg_in, bv_in.bv_page, 1 << SECTOR_SHIFT,\r\nbv_in.bv_offset);\r\nsg_init_table(&dmreq->sg_out, 1);\r\nsg_set_page(&dmreq->sg_out, bv_out.bv_page, 1 << SECTOR_SHIFT,\r\nbv_out.bv_offset);\r\nbio_advance_iter(ctx->bio_in, &ctx->iter_in, 1 << SECTOR_SHIFT);\r\nbio_advance_iter(ctx->bio_out, &ctx->iter_out, 1 << SECTOR_SHIFT);\r\nif (cc->iv_gen_ops) {\r\nr = cc->iv_gen_ops->generator(cc, iv, dmreq);\r\nif (r < 0)\r\nreturn r;\r\n}\r\nablkcipher_request_set_crypt(req, &dmreq->sg_in, &dmreq->sg_out,\r\n1 << SECTOR_SHIFT, iv);\r\nif (bio_data_dir(ctx->bio_in) == WRITE)\r\nr = crypto_ablkcipher_encrypt(req);\r\nelse\r\nr = crypto_ablkcipher_decrypt(req);\r\nif (!r && cc->iv_gen_ops && cc->iv_gen_ops->post)\r\nr = cc->iv_gen_ops->post(cc, iv, dmreq);\r\nreturn r;\r\n}\r\nstatic void crypt_alloc_req(struct crypt_config *cc,\r\nstruct convert_context *ctx)\r\n{\r\nunsigned key_index = ctx->cc_sector & (cc->tfms_count - 1);\r\nif (!ctx->req)\r\nctx->req = mempool_alloc(cc->req_pool, GFP_NOIO);\r\nablkcipher_request_set_tfm(ctx->req, cc->tfms[key_index]);\r\nablkcipher_request_set_callback(ctx->req,\r\nCRYPTO_TFM_REQ_MAY_BACKLOG | CRYPTO_TFM_REQ_MAY_SLEEP,\r\nkcryptd_async_done, dmreq_of_req(cc, ctx->req));\r\n}\r\nstatic void crypt_free_req(struct crypt_config *cc,\r\nstruct ablkcipher_request *req, struct bio *base_bio)\r\n{\r\nstruct dm_crypt_io *io = dm_per_bio_data(base_bio, cc->per_bio_data_size);\r\nif ((struct ablkcipher_request *)(io + 1) != req)\r\nmempool_free(req, cc->req_pool);\r\n}\r\nstatic int crypt_convert(struct crypt_config *cc,\r\nstruct convert_context *ctx)\r\n{\r\nint r;\r\natomic_set(&ctx->cc_pending, 1);\r\nwhile (ctx->iter_in.bi_size && ctx->iter_out.bi_size) {\r\ncrypt_alloc_req(cc, ctx);\r\natomic_inc(&ctx->cc_pending);\r\nr = crypt_convert_block(cc, ctx, ctx->req);\r\nswitch (r) {\r\ncase -EBUSY:\r\nwait_for_completion(&ctx->restart);\r\nreinit_completion(&ctx->restart);\r\ncase -EINPROGRESS:\r\nctx->req = NULL;\r\nctx->cc_sector++;\r\ncontinue;\r\ncase 0:\r\natomic_dec(&ctx->cc_pending);\r\nctx->cc_sector++;\r\ncond_resched();\r\ncontinue;\r\ndefault:\r\natomic_dec(&ctx->cc_pending);\r\nreturn r;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic struct bio *crypt_alloc_buffer(struct dm_crypt_io *io, unsigned size)\r\n{\r\nstruct crypt_config *cc = io->cc;\r\nstruct bio *clone;\r\nunsigned int nr_iovecs = (size + PAGE_SIZE - 1) >> PAGE_SHIFT;\r\ngfp_t gfp_mask = GFP_NOWAIT | __GFP_HIGHMEM;\r\nunsigned i, len, remaining_size;\r\nstruct page *page;\r\nstruct bio_vec *bvec;\r\nretry:\r\nif (unlikely(gfp_mask & __GFP_DIRECT_RECLAIM))\r\nmutex_lock(&cc->bio_alloc_lock);\r\nclone = bio_alloc_bioset(GFP_NOIO, nr_iovecs, cc->bs);\r\nif (!clone)\r\ngoto return_clone;\r\nclone_init(io, clone);\r\nremaining_size = size;\r\nfor (i = 0; i < nr_iovecs; i++) {\r\npage = mempool_alloc(cc->page_pool, gfp_mask);\r\nif (!page) {\r\ncrypt_free_buffer_pages(cc, clone);\r\nbio_put(clone);\r\ngfp_mask |= __GFP_DIRECT_RECLAIM;\r\ngoto retry;\r\n}\r\nlen = (remaining_size > PAGE_SIZE) ? PAGE_SIZE : remaining_size;\r\nbvec = &clone->bi_io_vec[clone->bi_vcnt++];\r\nbvec->bv_page = page;\r\nbvec->bv_len = len;\r\nbvec->bv_offset = 0;\r\nclone->bi_iter.bi_size += len;\r\nremaining_size -= len;\r\n}\r\nreturn_clone:\r\nif (unlikely(gfp_mask & __GFP_DIRECT_RECLAIM))\r\nmutex_unlock(&cc->bio_alloc_lock);\r\nreturn clone;\r\n}\r\nstatic void crypt_free_buffer_pages(struct crypt_config *cc, struct bio *clone)\r\n{\r\nunsigned int i;\r\nstruct bio_vec *bv;\r\nbio_for_each_segment_all(bv, clone, i) {\r\nBUG_ON(!bv->bv_page);\r\nmempool_free(bv->bv_page, cc->page_pool);\r\nbv->bv_page = NULL;\r\n}\r\n}\r\nstatic void crypt_io_init(struct dm_crypt_io *io, struct crypt_config *cc,\r\nstruct bio *bio, sector_t sector)\r\n{\r\nio->cc = cc;\r\nio->base_bio = bio;\r\nio->sector = sector;\r\nio->error = 0;\r\nio->ctx.req = NULL;\r\natomic_set(&io->io_pending, 0);\r\n}\r\nstatic void crypt_inc_pending(struct dm_crypt_io *io)\r\n{\r\natomic_inc(&io->io_pending);\r\n}\r\nstatic void crypt_dec_pending(struct dm_crypt_io *io)\r\n{\r\nstruct crypt_config *cc = io->cc;\r\nstruct bio *base_bio = io->base_bio;\r\nint error = io->error;\r\nif (!atomic_dec_and_test(&io->io_pending))\r\nreturn;\r\nif (io->ctx.req)\r\ncrypt_free_req(cc, io->ctx.req, base_bio);\r\nbase_bio->bi_error = error;\r\nbio_endio(base_bio);\r\n}\r\nstatic void crypt_endio(struct bio *clone)\r\n{\r\nstruct dm_crypt_io *io = clone->bi_private;\r\nstruct crypt_config *cc = io->cc;\r\nunsigned rw = bio_data_dir(clone);\r\nint error;\r\nif (rw == WRITE)\r\ncrypt_free_buffer_pages(cc, clone);\r\nerror = clone->bi_error;\r\nbio_put(clone);\r\nif (rw == READ && !error) {\r\nkcryptd_queue_crypt(io);\r\nreturn;\r\n}\r\nif (unlikely(error))\r\nio->error = error;\r\ncrypt_dec_pending(io);\r\n}\r\nstatic void clone_init(struct dm_crypt_io *io, struct bio *clone)\r\n{\r\nstruct crypt_config *cc = io->cc;\r\nclone->bi_private = io;\r\nclone->bi_end_io = crypt_endio;\r\nclone->bi_bdev = cc->dev->bdev;\r\nclone->bi_rw = io->base_bio->bi_rw;\r\n}\r\nstatic int kcryptd_io_read(struct dm_crypt_io *io, gfp_t gfp)\r\n{\r\nstruct crypt_config *cc = io->cc;\r\nstruct bio *clone;\r\nclone = bio_clone_fast(io->base_bio, gfp, cc->bs);\r\nif (!clone)\r\nreturn 1;\r\ncrypt_inc_pending(io);\r\nclone_init(io, clone);\r\nclone->bi_iter.bi_sector = cc->start + io->sector;\r\ngeneric_make_request(clone);\r\nreturn 0;\r\n}\r\nstatic void kcryptd_io_read_work(struct work_struct *work)\r\n{\r\nstruct dm_crypt_io *io = container_of(work, struct dm_crypt_io, work);\r\ncrypt_inc_pending(io);\r\nif (kcryptd_io_read(io, GFP_NOIO))\r\nio->error = -ENOMEM;\r\ncrypt_dec_pending(io);\r\n}\r\nstatic void kcryptd_queue_read(struct dm_crypt_io *io)\r\n{\r\nstruct crypt_config *cc = io->cc;\r\nINIT_WORK(&io->work, kcryptd_io_read_work);\r\nqueue_work(cc->io_queue, &io->work);\r\n}\r\nstatic void kcryptd_io_write(struct dm_crypt_io *io)\r\n{\r\nstruct bio *clone = io->ctx.bio_out;\r\ngeneric_make_request(clone);\r\n}\r\nstatic int dmcrypt_write(void *data)\r\n{\r\nstruct crypt_config *cc = data;\r\nstruct dm_crypt_io *io;\r\nwhile (1) {\r\nstruct rb_root write_tree;\r\nstruct blk_plug plug;\r\nDECLARE_WAITQUEUE(wait, current);\r\nspin_lock_irq(&cc->write_thread_wait.lock);\r\ncontinue_locked:\r\nif (!RB_EMPTY_ROOT(&cc->write_tree))\r\ngoto pop_from_list;\r\nif (unlikely(test_bit(DM_CRYPT_EXIT_THREAD, &cc->flags))) {\r\nspin_unlock_irq(&cc->write_thread_wait.lock);\r\nbreak;\r\n}\r\n__set_current_state(TASK_INTERRUPTIBLE);\r\n__add_wait_queue(&cc->write_thread_wait, &wait);\r\nspin_unlock_irq(&cc->write_thread_wait.lock);\r\nschedule();\r\nspin_lock_irq(&cc->write_thread_wait.lock);\r\n__remove_wait_queue(&cc->write_thread_wait, &wait);\r\ngoto continue_locked;\r\npop_from_list:\r\nwrite_tree = cc->write_tree;\r\ncc->write_tree = RB_ROOT;\r\nspin_unlock_irq(&cc->write_thread_wait.lock);\r\nBUG_ON(rb_parent(write_tree.rb_node));\r\nblk_start_plug(&plug);\r\ndo {\r\nio = crypt_io_from_node(rb_first(&write_tree));\r\nrb_erase(&io->rb_node, &write_tree);\r\nkcryptd_io_write(io);\r\n} while (!RB_EMPTY_ROOT(&write_tree));\r\nblk_finish_plug(&plug);\r\n}\r\nreturn 0;\r\n}\r\nstatic void kcryptd_crypt_write_io_submit(struct dm_crypt_io *io, int async)\r\n{\r\nstruct bio *clone = io->ctx.bio_out;\r\nstruct crypt_config *cc = io->cc;\r\nunsigned long flags;\r\nsector_t sector;\r\nstruct rb_node **rbp, *parent;\r\nif (unlikely(io->error < 0)) {\r\ncrypt_free_buffer_pages(cc, clone);\r\nbio_put(clone);\r\ncrypt_dec_pending(io);\r\nreturn;\r\n}\r\nBUG_ON(io->ctx.iter_out.bi_size);\r\nclone->bi_iter.bi_sector = cc->start + io->sector;\r\nif (likely(!async) && test_bit(DM_CRYPT_NO_OFFLOAD, &cc->flags)) {\r\ngeneric_make_request(clone);\r\nreturn;\r\n}\r\nspin_lock_irqsave(&cc->write_thread_wait.lock, flags);\r\nrbp = &cc->write_tree.rb_node;\r\nparent = NULL;\r\nsector = io->sector;\r\nwhile (*rbp) {\r\nparent = *rbp;\r\nif (sector < crypt_io_from_node(parent)->sector)\r\nrbp = &(*rbp)->rb_left;\r\nelse\r\nrbp = &(*rbp)->rb_right;\r\n}\r\nrb_link_node(&io->rb_node, parent, rbp);\r\nrb_insert_color(&io->rb_node, &cc->write_tree);\r\nwake_up_locked(&cc->write_thread_wait);\r\nspin_unlock_irqrestore(&cc->write_thread_wait.lock, flags);\r\n}\r\nstatic void kcryptd_crypt_write_convert(struct dm_crypt_io *io)\r\n{\r\nstruct crypt_config *cc = io->cc;\r\nstruct bio *clone;\r\nint crypt_finished;\r\nsector_t sector = io->sector;\r\nint r;\r\ncrypt_inc_pending(io);\r\ncrypt_convert_init(cc, &io->ctx, NULL, io->base_bio, sector);\r\nclone = crypt_alloc_buffer(io, io->base_bio->bi_iter.bi_size);\r\nif (unlikely(!clone)) {\r\nio->error = -EIO;\r\ngoto dec;\r\n}\r\nio->ctx.bio_out = clone;\r\nio->ctx.iter_out = clone->bi_iter;\r\nsector += bio_sectors(clone);\r\ncrypt_inc_pending(io);\r\nr = crypt_convert(cc, &io->ctx);\r\nif (r)\r\nio->error = -EIO;\r\ncrypt_finished = atomic_dec_and_test(&io->ctx.cc_pending);\r\nif (crypt_finished) {\r\nkcryptd_crypt_write_io_submit(io, 0);\r\nio->sector = sector;\r\n}\r\ndec:\r\ncrypt_dec_pending(io);\r\n}\r\nstatic void kcryptd_crypt_read_done(struct dm_crypt_io *io)\r\n{\r\ncrypt_dec_pending(io);\r\n}\r\nstatic void kcryptd_crypt_read_convert(struct dm_crypt_io *io)\r\n{\r\nstruct crypt_config *cc = io->cc;\r\nint r = 0;\r\ncrypt_inc_pending(io);\r\ncrypt_convert_init(cc, &io->ctx, io->base_bio, io->base_bio,\r\nio->sector);\r\nr = crypt_convert(cc, &io->ctx);\r\nif (r < 0)\r\nio->error = -EIO;\r\nif (atomic_dec_and_test(&io->ctx.cc_pending))\r\nkcryptd_crypt_read_done(io);\r\ncrypt_dec_pending(io);\r\n}\r\nstatic void kcryptd_async_done(struct crypto_async_request *async_req,\r\nint error)\r\n{\r\nstruct dm_crypt_request *dmreq = async_req->data;\r\nstruct convert_context *ctx = dmreq->ctx;\r\nstruct dm_crypt_io *io = container_of(ctx, struct dm_crypt_io, ctx);\r\nstruct crypt_config *cc = io->cc;\r\nif (error == -EINPROGRESS) {\r\ncomplete(&ctx->restart);\r\nreturn;\r\n}\r\nif (!error && cc->iv_gen_ops && cc->iv_gen_ops->post)\r\nerror = cc->iv_gen_ops->post(cc, iv_of_dmreq(cc, dmreq), dmreq);\r\nif (error < 0)\r\nio->error = -EIO;\r\ncrypt_free_req(cc, req_of_dmreq(cc, dmreq), io->base_bio);\r\nif (!atomic_dec_and_test(&ctx->cc_pending))\r\nreturn;\r\nif (bio_data_dir(io->base_bio) == READ)\r\nkcryptd_crypt_read_done(io);\r\nelse\r\nkcryptd_crypt_write_io_submit(io, 1);\r\n}\r\nstatic void kcryptd_crypt(struct work_struct *work)\r\n{\r\nstruct dm_crypt_io *io = container_of(work, struct dm_crypt_io, work);\r\nif (bio_data_dir(io->base_bio) == READ)\r\nkcryptd_crypt_read_convert(io);\r\nelse\r\nkcryptd_crypt_write_convert(io);\r\n}\r\nstatic void kcryptd_queue_crypt(struct dm_crypt_io *io)\r\n{\r\nstruct crypt_config *cc = io->cc;\r\nINIT_WORK(&io->work, kcryptd_crypt);\r\nqueue_work(cc->crypt_queue, &io->work);\r\n}\r\nstatic int crypt_decode_key(u8 *key, char *hex, unsigned int size)\r\n{\r\nchar buffer[3];\r\nunsigned int i;\r\nbuffer[2] = '\0';\r\nfor (i = 0; i < size; i++) {\r\nbuffer[0] = *hex++;\r\nbuffer[1] = *hex++;\r\nif (kstrtou8(buffer, 16, &key[i]))\r\nreturn -EINVAL;\r\n}\r\nif (*hex != '\0')\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\nstatic void crypt_free_tfms(struct crypt_config *cc)\r\n{\r\nunsigned i;\r\nif (!cc->tfms)\r\nreturn;\r\nfor (i = 0; i < cc->tfms_count; i++)\r\nif (cc->tfms[i] && !IS_ERR(cc->tfms[i])) {\r\ncrypto_free_ablkcipher(cc->tfms[i]);\r\ncc->tfms[i] = NULL;\r\n}\r\nkfree(cc->tfms);\r\ncc->tfms = NULL;\r\n}\r\nstatic int crypt_alloc_tfms(struct crypt_config *cc, char *ciphermode)\r\n{\r\nunsigned i;\r\nint err;\r\ncc->tfms = kmalloc(cc->tfms_count * sizeof(struct crypto_ablkcipher *),\r\nGFP_KERNEL);\r\nif (!cc->tfms)\r\nreturn -ENOMEM;\r\nfor (i = 0; i < cc->tfms_count; i++) {\r\ncc->tfms[i] = crypto_alloc_ablkcipher(ciphermode, 0, 0);\r\nif (IS_ERR(cc->tfms[i])) {\r\nerr = PTR_ERR(cc->tfms[i]);\r\ncrypt_free_tfms(cc);\r\nreturn err;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int crypt_setkey_allcpus(struct crypt_config *cc)\r\n{\r\nunsigned subkey_size;\r\nint err = 0, i, r;\r\nsubkey_size = (cc->key_size - cc->key_extra_size) >> ilog2(cc->tfms_count);\r\nfor (i = 0; i < cc->tfms_count; i++) {\r\nr = crypto_ablkcipher_setkey(cc->tfms[i],\r\ncc->key + (i * subkey_size),\r\nsubkey_size);\r\nif (r)\r\nerr = r;\r\n}\r\nreturn err;\r\n}\r\nstatic int crypt_set_key(struct crypt_config *cc, char *key)\r\n{\r\nint r = -EINVAL;\r\nint key_string_len = strlen(key);\r\nif (cc->key_size != (key_string_len >> 1))\r\ngoto out;\r\nif (!cc->key_size && strcmp(key, "-"))\r\ngoto out;\r\nif (cc->key_size && crypt_decode_key(cc->key, key, cc->key_size) < 0)\r\ngoto out;\r\nset_bit(DM_CRYPT_KEY_VALID, &cc->flags);\r\nr = crypt_setkey_allcpus(cc);\r\nout:\r\nmemset(key, '0', key_string_len);\r\nreturn r;\r\n}\r\nstatic int crypt_wipe_key(struct crypt_config *cc)\r\n{\r\nclear_bit(DM_CRYPT_KEY_VALID, &cc->flags);\r\nmemset(&cc->key, 0, cc->key_size * sizeof(u8));\r\nreturn crypt_setkey_allcpus(cc);\r\n}\r\nstatic void crypt_dtr(struct dm_target *ti)\r\n{\r\nstruct crypt_config *cc = ti->private;\r\nti->private = NULL;\r\nif (!cc)\r\nreturn;\r\nif (cc->write_thread) {\r\nspin_lock_irq(&cc->write_thread_wait.lock);\r\nset_bit(DM_CRYPT_EXIT_THREAD, &cc->flags);\r\nwake_up_locked(&cc->write_thread_wait);\r\nspin_unlock_irq(&cc->write_thread_wait.lock);\r\nkthread_stop(cc->write_thread);\r\n}\r\nif (cc->io_queue)\r\ndestroy_workqueue(cc->io_queue);\r\nif (cc->crypt_queue)\r\ndestroy_workqueue(cc->crypt_queue);\r\ncrypt_free_tfms(cc);\r\nif (cc->bs)\r\nbioset_free(cc->bs);\r\nmempool_destroy(cc->page_pool);\r\nmempool_destroy(cc->req_pool);\r\nif (cc->iv_gen_ops && cc->iv_gen_ops->dtr)\r\ncc->iv_gen_ops->dtr(cc);\r\nif (cc->dev)\r\ndm_put_device(ti, cc->dev);\r\nkzfree(cc->cipher);\r\nkzfree(cc->cipher_string);\r\nkzfree(cc);\r\n}\r\nstatic int crypt_ctr_cipher(struct dm_target *ti,\r\nchar *cipher_in, char *key)\r\n{\r\nstruct crypt_config *cc = ti->private;\r\nchar *tmp, *cipher, *chainmode, *ivmode, *ivopts, *keycount;\r\nchar *cipher_api = NULL;\r\nint ret = -EINVAL;\r\nchar dummy;\r\nif (strchr(cipher_in, '(')) {\r\nti->error = "Bad cipher specification";\r\nreturn -EINVAL;\r\n}\r\ncc->cipher_string = kstrdup(cipher_in, GFP_KERNEL);\r\nif (!cc->cipher_string)\r\ngoto bad_mem;\r\ntmp = cipher_in;\r\nkeycount = strsep(&tmp, "-");\r\ncipher = strsep(&keycount, ":");\r\nif (!keycount)\r\ncc->tfms_count = 1;\r\nelse if (sscanf(keycount, "%u%c", &cc->tfms_count, &dummy) != 1 ||\r\n!is_power_of_2(cc->tfms_count)) {\r\nti->error = "Bad cipher key count specification";\r\nreturn -EINVAL;\r\n}\r\ncc->key_parts = cc->tfms_count;\r\ncc->key_extra_size = 0;\r\ncc->cipher = kstrdup(cipher, GFP_KERNEL);\r\nif (!cc->cipher)\r\ngoto bad_mem;\r\nchainmode = strsep(&tmp, "-");\r\nivopts = strsep(&tmp, "-");\r\nivmode = strsep(&ivopts, ":");\r\nif (tmp)\r\nDMWARN("Ignoring unexpected additional cipher options");\r\nif (!chainmode || (!strcmp(chainmode, "plain") && !ivmode)) {\r\nchainmode = "cbc";\r\nivmode = "plain";\r\n}\r\nif (strcmp(chainmode, "ecb") && !ivmode) {\r\nti->error = "IV mechanism required";\r\nreturn -EINVAL;\r\n}\r\ncipher_api = kmalloc(CRYPTO_MAX_ALG_NAME, GFP_KERNEL);\r\nif (!cipher_api)\r\ngoto bad_mem;\r\nret = snprintf(cipher_api, CRYPTO_MAX_ALG_NAME,\r\n"%s(%s)", chainmode, cipher);\r\nif (ret < 0) {\r\nkfree(cipher_api);\r\ngoto bad_mem;\r\n}\r\nret = crypt_alloc_tfms(cc, cipher_api);\r\nif (ret < 0) {\r\nti->error = "Error allocating crypto tfm";\r\ngoto bad;\r\n}\r\ncc->iv_size = crypto_ablkcipher_ivsize(any_tfm(cc));\r\nif (cc->iv_size)\r\ncc->iv_size = max(cc->iv_size,\r\n(unsigned int)(sizeof(u64) / sizeof(u8)));\r\nelse if (ivmode) {\r\nDMWARN("Selected cipher does not support IVs");\r\nivmode = NULL;\r\n}\r\nif (ivmode == NULL)\r\ncc->iv_gen_ops = NULL;\r\nelse if (strcmp(ivmode, "plain") == 0)\r\ncc->iv_gen_ops = &crypt_iv_plain_ops;\r\nelse if (strcmp(ivmode, "plain64") == 0)\r\ncc->iv_gen_ops = &crypt_iv_plain64_ops;\r\nelse if (strcmp(ivmode, "essiv") == 0)\r\ncc->iv_gen_ops = &crypt_iv_essiv_ops;\r\nelse if (strcmp(ivmode, "benbi") == 0)\r\ncc->iv_gen_ops = &crypt_iv_benbi_ops;\r\nelse if (strcmp(ivmode, "null") == 0)\r\ncc->iv_gen_ops = &crypt_iv_null_ops;\r\nelse if (strcmp(ivmode, "lmk") == 0) {\r\ncc->iv_gen_ops = &crypt_iv_lmk_ops;\r\nif (cc->key_size % cc->key_parts) {\r\ncc->key_parts++;\r\ncc->key_extra_size = cc->key_size / cc->key_parts;\r\n}\r\n} else if (strcmp(ivmode, "tcw") == 0) {\r\ncc->iv_gen_ops = &crypt_iv_tcw_ops;\r\ncc->key_parts += 2;\r\ncc->key_extra_size = cc->iv_size + TCW_WHITENING_SIZE;\r\n} else {\r\nret = -EINVAL;\r\nti->error = "Invalid IV mode";\r\ngoto bad;\r\n}\r\nret = crypt_set_key(cc, key);\r\nif (ret < 0) {\r\nti->error = "Error decoding and setting key";\r\ngoto bad;\r\n}\r\nif (cc->iv_gen_ops && cc->iv_gen_ops->ctr) {\r\nret = cc->iv_gen_ops->ctr(cc, ti, ivopts);\r\nif (ret < 0) {\r\nti->error = "Error creating IV";\r\ngoto bad;\r\n}\r\n}\r\nif (cc->iv_gen_ops && cc->iv_gen_ops->init) {\r\nret = cc->iv_gen_ops->init(cc);\r\nif (ret < 0) {\r\nti->error = "Error initialising IV";\r\ngoto bad;\r\n}\r\n}\r\nret = 0;\r\nbad:\r\nkfree(cipher_api);\r\nreturn ret;\r\nbad_mem:\r\nti->error = "Cannot allocate cipher strings";\r\nreturn -ENOMEM;\r\n}\r\nstatic int crypt_ctr(struct dm_target *ti, unsigned int argc, char **argv)\r\n{\r\nstruct crypt_config *cc;\r\nunsigned int key_size, opt_params;\r\nunsigned long long tmpll;\r\nint ret;\r\nsize_t iv_size_padding;\r\nstruct dm_arg_set as;\r\nconst char *opt_string;\r\nchar dummy;\r\nstatic struct dm_arg _args[] = {\r\n{0, 3, "Invalid number of feature args"},\r\n};\r\nif (argc < 5) {\r\nti->error = "Not enough arguments";\r\nreturn -EINVAL;\r\n}\r\nkey_size = strlen(argv[1]) >> 1;\r\ncc = kzalloc(sizeof(*cc) + key_size * sizeof(u8), GFP_KERNEL);\r\nif (!cc) {\r\nti->error = "Cannot allocate encryption context";\r\nreturn -ENOMEM;\r\n}\r\ncc->key_size = key_size;\r\nti->private = cc;\r\nret = crypt_ctr_cipher(ti, argv[0], argv[1]);\r\nif (ret < 0)\r\ngoto bad;\r\ncc->dmreq_start = sizeof(struct ablkcipher_request);\r\ncc->dmreq_start += crypto_ablkcipher_reqsize(any_tfm(cc));\r\ncc->dmreq_start = ALIGN(cc->dmreq_start, __alignof__(struct dm_crypt_request));\r\nif (crypto_ablkcipher_alignmask(any_tfm(cc)) < CRYPTO_MINALIGN) {\r\niv_size_padding = -(cc->dmreq_start + sizeof(struct dm_crypt_request))\r\n& crypto_ablkcipher_alignmask(any_tfm(cc));\r\n} else {\r\niv_size_padding = crypto_ablkcipher_alignmask(any_tfm(cc));\r\n}\r\nret = -ENOMEM;\r\ncc->req_pool = mempool_create_kmalloc_pool(MIN_IOS, cc->dmreq_start +\r\nsizeof(struct dm_crypt_request) + iv_size_padding + cc->iv_size);\r\nif (!cc->req_pool) {\r\nti->error = "Cannot allocate crypt request mempool";\r\ngoto bad;\r\n}\r\ncc->per_bio_data_size = ti->per_bio_data_size =\r\nALIGN(sizeof(struct dm_crypt_io) + cc->dmreq_start +\r\nsizeof(struct dm_crypt_request) + iv_size_padding + cc->iv_size,\r\nARCH_KMALLOC_MINALIGN);\r\ncc->page_pool = mempool_create_page_pool(BIO_MAX_PAGES, 0);\r\nif (!cc->page_pool) {\r\nti->error = "Cannot allocate page mempool";\r\ngoto bad;\r\n}\r\ncc->bs = bioset_create(MIN_IOS, 0);\r\nif (!cc->bs) {\r\nti->error = "Cannot allocate crypt bioset";\r\ngoto bad;\r\n}\r\nmutex_init(&cc->bio_alloc_lock);\r\nret = -EINVAL;\r\nif (sscanf(argv[2], "%llu%c", &tmpll, &dummy) != 1) {\r\nti->error = "Invalid iv_offset sector";\r\ngoto bad;\r\n}\r\ncc->iv_offset = tmpll;\r\nret = dm_get_device(ti, argv[3], dm_table_get_mode(ti->table), &cc->dev);\r\nif (ret) {\r\nti->error = "Device lookup failed";\r\ngoto bad;\r\n}\r\nret = -EINVAL;\r\nif (sscanf(argv[4], "%llu%c", &tmpll, &dummy) != 1) {\r\nti->error = "Invalid device sector";\r\ngoto bad;\r\n}\r\ncc->start = tmpll;\r\nargv += 5;\r\nargc -= 5;\r\nif (argc) {\r\nas.argc = argc;\r\nas.argv = argv;\r\nret = dm_read_arg_group(_args, &as, &opt_params, &ti->error);\r\nif (ret)\r\ngoto bad;\r\nret = -EINVAL;\r\nwhile (opt_params--) {\r\nopt_string = dm_shift_arg(&as);\r\nif (!opt_string) {\r\nti->error = "Not enough feature arguments";\r\ngoto bad;\r\n}\r\nif (!strcasecmp(opt_string, "allow_discards"))\r\nti->num_discard_bios = 1;\r\nelse if (!strcasecmp(opt_string, "same_cpu_crypt"))\r\nset_bit(DM_CRYPT_SAME_CPU, &cc->flags);\r\nelse if (!strcasecmp(opt_string, "submit_from_crypt_cpus"))\r\nset_bit(DM_CRYPT_NO_OFFLOAD, &cc->flags);\r\nelse {\r\nti->error = "Invalid feature arguments";\r\ngoto bad;\r\n}\r\n}\r\n}\r\nret = -ENOMEM;\r\ncc->io_queue = alloc_workqueue("kcryptd_io", WQ_MEM_RECLAIM, 1);\r\nif (!cc->io_queue) {\r\nti->error = "Couldn't create kcryptd io queue";\r\ngoto bad;\r\n}\r\nif (test_bit(DM_CRYPT_SAME_CPU, &cc->flags))\r\ncc->crypt_queue = alloc_workqueue("kcryptd", WQ_CPU_INTENSIVE | WQ_MEM_RECLAIM, 1);\r\nelse\r\ncc->crypt_queue = alloc_workqueue("kcryptd", WQ_CPU_INTENSIVE | WQ_MEM_RECLAIM | WQ_UNBOUND,\r\nnum_online_cpus());\r\nif (!cc->crypt_queue) {\r\nti->error = "Couldn't create kcryptd queue";\r\ngoto bad;\r\n}\r\ninit_waitqueue_head(&cc->write_thread_wait);\r\ncc->write_tree = RB_ROOT;\r\ncc->write_thread = kthread_create(dmcrypt_write, cc, "dmcrypt_write");\r\nif (IS_ERR(cc->write_thread)) {\r\nret = PTR_ERR(cc->write_thread);\r\ncc->write_thread = NULL;\r\nti->error = "Couldn't spawn write thread";\r\ngoto bad;\r\n}\r\nwake_up_process(cc->write_thread);\r\nti->num_flush_bios = 1;\r\nti->discard_zeroes_data_unsupported = true;\r\nreturn 0;\r\nbad:\r\ncrypt_dtr(ti);\r\nreturn ret;\r\n}\r\nstatic int crypt_map(struct dm_target *ti, struct bio *bio)\r\n{\r\nstruct dm_crypt_io *io;\r\nstruct crypt_config *cc = ti->private;\r\nif (unlikely(bio->bi_rw & (REQ_FLUSH | REQ_DISCARD))) {\r\nbio->bi_bdev = cc->dev->bdev;\r\nif (bio_sectors(bio))\r\nbio->bi_iter.bi_sector = cc->start +\r\ndm_target_offset(ti, bio->bi_iter.bi_sector);\r\nreturn DM_MAPIO_REMAPPED;\r\n}\r\nio = dm_per_bio_data(bio, cc->per_bio_data_size);\r\ncrypt_io_init(io, cc, bio, dm_target_offset(ti, bio->bi_iter.bi_sector));\r\nio->ctx.req = (struct ablkcipher_request *)(io + 1);\r\nif (bio_data_dir(io->base_bio) == READ) {\r\nif (kcryptd_io_read(io, GFP_NOWAIT))\r\nkcryptd_queue_read(io);\r\n} else\r\nkcryptd_queue_crypt(io);\r\nreturn DM_MAPIO_SUBMITTED;\r\n}\r\nstatic void crypt_status(struct dm_target *ti, status_type_t type,\r\nunsigned status_flags, char *result, unsigned maxlen)\r\n{\r\nstruct crypt_config *cc = ti->private;\r\nunsigned i, sz = 0;\r\nint num_feature_args = 0;\r\nswitch (type) {\r\ncase STATUSTYPE_INFO:\r\nresult[0] = '\0';\r\nbreak;\r\ncase STATUSTYPE_TABLE:\r\nDMEMIT("%s ", cc->cipher_string);\r\nif (cc->key_size > 0)\r\nfor (i = 0; i < cc->key_size; i++)\r\nDMEMIT("%02x", cc->key[i]);\r\nelse\r\nDMEMIT("-");\r\nDMEMIT(" %llu %s %llu", (unsigned long long)cc->iv_offset,\r\ncc->dev->name, (unsigned long long)cc->start);\r\nnum_feature_args += !!ti->num_discard_bios;\r\nnum_feature_args += test_bit(DM_CRYPT_SAME_CPU, &cc->flags);\r\nnum_feature_args += test_bit(DM_CRYPT_NO_OFFLOAD, &cc->flags);\r\nif (num_feature_args) {\r\nDMEMIT(" %d", num_feature_args);\r\nif (ti->num_discard_bios)\r\nDMEMIT(" allow_discards");\r\nif (test_bit(DM_CRYPT_SAME_CPU, &cc->flags))\r\nDMEMIT(" same_cpu_crypt");\r\nif (test_bit(DM_CRYPT_NO_OFFLOAD, &cc->flags))\r\nDMEMIT(" submit_from_crypt_cpus");\r\n}\r\nbreak;\r\n}\r\n}\r\nstatic void crypt_postsuspend(struct dm_target *ti)\r\n{\r\nstruct crypt_config *cc = ti->private;\r\nset_bit(DM_CRYPT_SUSPENDED, &cc->flags);\r\n}\r\nstatic int crypt_preresume(struct dm_target *ti)\r\n{\r\nstruct crypt_config *cc = ti->private;\r\nif (!test_bit(DM_CRYPT_KEY_VALID, &cc->flags)) {\r\nDMERR("aborting resume - crypt key is not set.");\r\nreturn -EAGAIN;\r\n}\r\nreturn 0;\r\n}\r\nstatic void crypt_resume(struct dm_target *ti)\r\n{\r\nstruct crypt_config *cc = ti->private;\r\nclear_bit(DM_CRYPT_SUSPENDED, &cc->flags);\r\n}\r\nstatic int crypt_message(struct dm_target *ti, unsigned argc, char **argv)\r\n{\r\nstruct crypt_config *cc = ti->private;\r\nint ret = -EINVAL;\r\nif (argc < 2)\r\ngoto error;\r\nif (!strcasecmp(argv[0], "key")) {\r\nif (!test_bit(DM_CRYPT_SUSPENDED, &cc->flags)) {\r\nDMWARN("not suspended during key manipulation.");\r\nreturn -EINVAL;\r\n}\r\nif (argc == 3 && !strcasecmp(argv[1], "set")) {\r\nret = crypt_set_key(cc, argv[2]);\r\nif (ret)\r\nreturn ret;\r\nif (cc->iv_gen_ops && cc->iv_gen_ops->init)\r\nret = cc->iv_gen_ops->init(cc);\r\nreturn ret;\r\n}\r\nif (argc == 2 && !strcasecmp(argv[1], "wipe")) {\r\nif (cc->iv_gen_ops && cc->iv_gen_ops->wipe) {\r\nret = cc->iv_gen_ops->wipe(cc);\r\nif (ret)\r\nreturn ret;\r\n}\r\nreturn crypt_wipe_key(cc);\r\n}\r\n}\r\nerror:\r\nDMWARN("unrecognised message received.");\r\nreturn -EINVAL;\r\n}\r\nstatic int crypt_iterate_devices(struct dm_target *ti,\r\niterate_devices_callout_fn fn, void *data)\r\n{\r\nstruct crypt_config *cc = ti->private;\r\nreturn fn(ti, cc->dev, cc->start, ti->len, data);\r\n}\r\nstatic void crypt_io_hints(struct dm_target *ti, struct queue_limits *limits)\r\n{\r\nlimits->max_segment_size = PAGE_SIZE;\r\n}\r\nstatic int __init dm_crypt_init(void)\r\n{\r\nint r;\r\nr = dm_register_target(&crypt_target);\r\nif (r < 0)\r\nDMERR("register failed %d", r);\r\nreturn r;\r\n}\r\nstatic void __exit dm_crypt_exit(void)\r\n{\r\ndm_unregister_target(&crypt_target);\r\n}
