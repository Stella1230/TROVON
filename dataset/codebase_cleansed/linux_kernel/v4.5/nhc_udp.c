static int udp_uncompress(struct sk_buff *skb, size_t needed)\r\n{\r\nu8 tmp = 0, val = 0;\r\nstruct udphdr uh;\r\nbool fail;\r\nint err;\r\nfail = lowpan_fetch_skb(skb, &tmp, sizeof(tmp));\r\npr_debug("UDP header uncompression\n");\r\nswitch (tmp & LOWPAN_NHC_UDP_CS_P_11) {\r\ncase LOWPAN_NHC_UDP_CS_P_00:\r\nfail |= lowpan_fetch_skb(skb, &uh.source, sizeof(uh.source));\r\nfail |= lowpan_fetch_skb(skb, &uh.dest, sizeof(uh.dest));\r\nbreak;\r\ncase LOWPAN_NHC_UDP_CS_P_01:\r\nfail |= lowpan_fetch_skb(skb, &uh.source, sizeof(uh.source));\r\nfail |= lowpan_fetch_skb(skb, &val, sizeof(val));\r\nuh.dest = htons(val + LOWPAN_NHC_UDP_8BIT_PORT);\r\nbreak;\r\ncase LOWPAN_NHC_UDP_CS_P_10:\r\nfail |= lowpan_fetch_skb(skb, &val, sizeof(val));\r\nuh.source = htons(val + LOWPAN_NHC_UDP_8BIT_PORT);\r\nfail |= lowpan_fetch_skb(skb, &uh.dest, sizeof(uh.dest));\r\nbreak;\r\ncase LOWPAN_NHC_UDP_CS_P_11:\r\nfail |= lowpan_fetch_skb(skb, &val, sizeof(val));\r\nuh.source = htons(LOWPAN_NHC_UDP_4BIT_PORT + (val >> 4));\r\nuh.dest = htons(LOWPAN_NHC_UDP_4BIT_PORT + (val & 0x0f));\r\nbreak;\r\ndefault:\r\nBUG();\r\n}\r\npr_debug("uncompressed UDP ports: src = %d, dst = %d\n",\r\nntohs(uh.source), ntohs(uh.dest));\r\nif (tmp & LOWPAN_NHC_UDP_CS_C) {\r\npr_debug_ratelimited("checksum elided currently not supported\n");\r\nfail = true;\r\n} else {\r\nfail |= lowpan_fetch_skb(skb, &uh.check, sizeof(uh.check));\r\n}\r\nif (fail)\r\nreturn -EINVAL;\r\nswitch (lowpan_priv(skb->dev)->lltype) {\r\ncase LOWPAN_LLTYPE_IEEE802154:\r\nif (lowpan_802154_cb(skb)->d_size)\r\nuh.len = htons(lowpan_802154_cb(skb)->d_size -\r\nsizeof(struct ipv6hdr));\r\nelse\r\nuh.len = htons(skb->len + sizeof(struct udphdr));\r\nbreak;\r\ndefault:\r\nuh.len = htons(skb->len + sizeof(struct udphdr));\r\nbreak;\r\n}\r\npr_debug("uncompressed UDP length: src = %d", ntohs(uh.len));\r\nerr = skb_cow(skb, needed);\r\nif (unlikely(err))\r\nreturn err;\r\nskb_push(skb, sizeof(struct udphdr));\r\nskb_copy_to_linear_data(skb, &uh, sizeof(struct udphdr));\r\nreturn 0;\r\n}\r\nstatic int udp_compress(struct sk_buff *skb, u8 **hc_ptr)\r\n{\r\nconst struct udphdr *uh = udp_hdr(skb);\r\nu8 tmp;\r\nif (((ntohs(uh->source) & LOWPAN_NHC_UDP_4BIT_MASK) ==\r\nLOWPAN_NHC_UDP_4BIT_PORT) &&\r\n((ntohs(uh->dest) & LOWPAN_NHC_UDP_4BIT_MASK) ==\r\nLOWPAN_NHC_UDP_4BIT_PORT)) {\r\npr_debug("UDP header: both ports compression to 4 bits\n");\r\ntmp = LOWPAN_NHC_UDP_CS_P_11;\r\nlowpan_push_hc_data(hc_ptr, &tmp, sizeof(tmp));\r\ntmp = ntohs(uh->dest) - LOWPAN_NHC_UDP_4BIT_PORT +\r\n((ntohs(uh->source) - LOWPAN_NHC_UDP_4BIT_PORT) << 4);\r\nlowpan_push_hc_data(hc_ptr, &tmp, sizeof(tmp));\r\n} else if ((ntohs(uh->dest) & LOWPAN_NHC_UDP_8BIT_MASK) ==\r\nLOWPAN_NHC_UDP_8BIT_PORT) {\r\npr_debug("UDP header: remove 8 bits of dest\n");\r\ntmp = LOWPAN_NHC_UDP_CS_P_01;\r\nlowpan_push_hc_data(hc_ptr, &tmp, sizeof(tmp));\r\nlowpan_push_hc_data(hc_ptr, &uh->source, sizeof(uh->source));\r\ntmp = ntohs(uh->dest) - LOWPAN_NHC_UDP_8BIT_PORT;\r\nlowpan_push_hc_data(hc_ptr, &tmp, sizeof(tmp));\r\n} else if ((ntohs(uh->source) & LOWPAN_NHC_UDP_8BIT_MASK) ==\r\nLOWPAN_NHC_UDP_8BIT_PORT) {\r\npr_debug("UDP header: remove 8 bits of source\n");\r\ntmp = LOWPAN_NHC_UDP_CS_P_10;\r\nlowpan_push_hc_data(hc_ptr, &tmp, sizeof(tmp));\r\ntmp = ntohs(uh->source) - LOWPAN_NHC_UDP_8BIT_PORT;\r\nlowpan_push_hc_data(hc_ptr, &tmp, sizeof(tmp));\r\nlowpan_push_hc_data(hc_ptr, &uh->dest, sizeof(uh->dest));\r\n} else {\r\npr_debug("UDP header: can't compress\n");\r\ntmp = LOWPAN_NHC_UDP_CS_P_00;\r\nlowpan_push_hc_data(hc_ptr, &tmp, sizeof(tmp));\r\nlowpan_push_hc_data(hc_ptr, &uh->source, sizeof(uh->source));\r\nlowpan_push_hc_data(hc_ptr, &uh->dest, sizeof(uh->dest));\r\n}\r\nlowpan_push_hc_data(hc_ptr, &uh->check, sizeof(uh->check));\r\nreturn 0;\r\n}\r\nstatic void udp_nhid_setup(struct lowpan_nhc *nhc)\r\n{\r\nnhc->id[0] = LOWPAN_NHC_UDP_ID;\r\nnhc->idmask[0] = LOWPAN_NHC_UDP_MASK;\r\n}
