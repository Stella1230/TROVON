static void quirk_limit_mrrs(struct pci_dev *dev)\r\n{\r\nstruct pci_bus *bus = dev->bus;\r\nstruct pci_dev *bridge = bus->self;\r\nstatic const struct pci_device_id rc_pci_devids[] = {\r\n{ PCI_DEVICE(PCI_VENDOR_ID_TI, PCIE_RC_K2HK),\r\n.class = PCI_CLASS_BRIDGE_PCI << 8, .class_mask = ~0, },\r\n{ PCI_DEVICE(PCI_VENDOR_ID_TI, PCIE_RC_K2E),\r\n.class = PCI_CLASS_BRIDGE_PCI << 8, .class_mask = ~0, },\r\n{ PCI_DEVICE(PCI_VENDOR_ID_TI, PCIE_RC_K2L),\r\n.class = PCI_CLASS_BRIDGE_PCI << 8, .class_mask = ~0, },\r\n{ 0, },\r\n};\r\nif (pci_is_root_bus(bus))\r\nreturn;\r\nwhile (!pci_is_root_bus(bus)) {\r\nbridge = bus->self;\r\nbus = bus->parent;\r\n}\r\nif (bridge) {\r\nif (pci_match_id(rc_pci_devids, bridge)) {\r\nif (pcie_get_readrq(dev) > 256) {\r\ndev_info(&dev->dev, "limiting MRRS to 256\n");\r\npcie_set_readrq(dev, 256);\r\n}\r\n}\r\n}\r\n}\r\nstatic int ks_pcie_establish_link(struct keystone_pcie *ks_pcie)\r\n{\r\nstruct pcie_port *pp = &ks_pcie->pp;\r\nunsigned int retries;\r\ndw_pcie_setup_rc(pp);\r\nif (dw_pcie_link_up(pp)) {\r\ndev_err(pp->dev, "Link already up\n");\r\nreturn 0;\r\n}\r\nks_dw_pcie_initiate_link_train(ks_pcie);\r\nfor (retries = 0; retries < 200; retries++) {\r\nif (dw_pcie_link_up(pp))\r\nreturn 0;\r\nusleep_range(100, 1000);\r\nks_dw_pcie_initiate_link_train(ks_pcie);\r\n}\r\ndev_err(pp->dev, "phy link never came up\n");\r\nreturn -EINVAL;\r\n}\r\nstatic void ks_pcie_msi_irq_handler(struct irq_desc *desc)\r\n{\r\nunsigned int irq = irq_desc_get_irq(desc);\r\nstruct keystone_pcie *ks_pcie = irq_desc_get_handler_data(desc);\r\nu32 offset = irq - ks_pcie->msi_host_irqs[0];\r\nstruct pcie_port *pp = &ks_pcie->pp;\r\nstruct irq_chip *chip = irq_desc_get_chip(desc);\r\ndev_dbg(pp->dev, "%s, irq %d\n", __func__, irq);\r\nchained_irq_enter(chip, desc);\r\nks_dw_pcie_handle_msi_irq(ks_pcie, offset);\r\nchained_irq_exit(chip, desc);\r\n}\r\nstatic void ks_pcie_legacy_irq_handler(struct irq_desc *desc)\r\n{\r\nunsigned int irq = irq_desc_get_irq(desc);\r\nstruct keystone_pcie *ks_pcie = irq_desc_get_handler_data(desc);\r\nstruct pcie_port *pp = &ks_pcie->pp;\r\nu32 irq_offset = irq - ks_pcie->legacy_host_irqs[0];\r\nstruct irq_chip *chip = irq_desc_get_chip(desc);\r\ndev_dbg(pp->dev, ": Handling legacy irq %d\n", irq);\r\nchained_irq_enter(chip, desc);\r\nks_dw_pcie_handle_legacy_irq(ks_pcie, irq_offset);\r\nchained_irq_exit(chip, desc);\r\n}\r\nstatic int ks_pcie_get_irq_controller_info(struct keystone_pcie *ks_pcie,\r\nchar *controller, int *num_irqs)\r\n{\r\nint temp, max_host_irqs, legacy = 1, *host_irqs, ret = -EINVAL;\r\nstruct device *dev = ks_pcie->pp.dev;\r\nstruct device_node *np_pcie = dev->of_node, **np_temp;\r\nif (!strcmp(controller, "msi-interrupt-controller"))\r\nlegacy = 0;\r\nif (legacy) {\r\nnp_temp = &ks_pcie->legacy_intc_np;\r\nmax_host_irqs = MAX_LEGACY_HOST_IRQS;\r\nhost_irqs = &ks_pcie->legacy_host_irqs[0];\r\n} else {\r\nnp_temp = &ks_pcie->msi_intc_np;\r\nmax_host_irqs = MAX_MSI_HOST_IRQS;\r\nhost_irqs = &ks_pcie->msi_host_irqs[0];\r\n}\r\n*np_temp = of_find_node_by_name(np_pcie, controller);\r\nif (!(*np_temp)) {\r\ndev_err(dev, "Node for %s is absent\n", controller);\r\ngoto out;\r\n}\r\ntemp = of_irq_count(*np_temp);\r\nif (!temp)\r\ngoto out;\r\nif (temp > max_host_irqs)\r\ndev_warn(dev, "Too many %s interrupts defined %u\n",\r\n(legacy ? "legacy" : "MSI"), temp);\r\nfor (temp = 0; temp < max_host_irqs; temp++) {\r\nhost_irqs[temp] = irq_of_parse_and_map(*np_temp, temp);\r\nif (!host_irqs[temp])\r\nbreak;\r\n}\r\nif (temp) {\r\n*num_irqs = temp;\r\nret = 0;\r\n}\r\nout:\r\nreturn ret;\r\n}\r\nstatic void ks_pcie_setup_interrupts(struct keystone_pcie *ks_pcie)\r\n{\r\nint i;\r\nfor (i = 0; i < ks_pcie->num_legacy_host_irqs; i++) {\r\nirq_set_chained_handler_and_data(ks_pcie->legacy_host_irqs[i],\r\nks_pcie_legacy_irq_handler,\r\nks_pcie);\r\n}\r\nks_dw_pcie_enable_legacy_irqs(ks_pcie);\r\nif (IS_ENABLED(CONFIG_PCI_MSI)) {\r\nfor (i = 0; i < ks_pcie->num_msi_host_irqs; i++) {\r\nirq_set_chained_handler_and_data(ks_pcie->msi_host_irqs[i],\r\nks_pcie_msi_irq_handler,\r\nks_pcie);\r\n}\r\n}\r\n}\r\nstatic int keystone_pcie_fault(unsigned long addr, unsigned int fsr,\r\nstruct pt_regs *regs)\r\n{\r\nunsigned long instr = *(unsigned long *) instruction_pointer(regs);\r\nif ((instr & 0x0e100090) == 0x00100090) {\r\nint reg = (instr >> 12) & 15;\r\nregs->uregs[reg] = -1;\r\nregs->ARM_pc += 4;\r\n}\r\nreturn 0;\r\n}\r\nstatic void __init ks_pcie_host_init(struct pcie_port *pp)\r\n{\r\nstruct keystone_pcie *ks_pcie = to_keystone_pcie(pp);\r\nu32 val;\r\nks_pcie_establish_link(ks_pcie);\r\nks_dw_pcie_setup_rc_app_regs(ks_pcie);\r\nks_pcie_setup_interrupts(ks_pcie);\r\nwritew(PCI_IO_RANGE_TYPE_32 | (PCI_IO_RANGE_TYPE_32 << 8),\r\npp->dbi_base + PCI_IO_BASE);\r\nwritew(ks_pcie->device_id, pp->dbi_base + PCI_DEVICE_ID);\r\nval = readl(pp->dbi_base + PCIE_CAP_BASE + PCI_EXP_DEVCTL);\r\nval &= ~PCI_EXP_DEVCTL_READRQ;\r\nval |= BIT(12);\r\nwritel(val, pp->dbi_base + PCIE_CAP_BASE + PCI_EXP_DEVCTL);\r\nhook_fault_code(17, keystone_pcie_fault, SIGBUS, 0,\r\n"Asynchronous external abort");\r\n}\r\nstatic int __init ks_add_pcie_port(struct keystone_pcie *ks_pcie,\r\nstruct platform_device *pdev)\r\n{\r\nstruct pcie_port *pp = &ks_pcie->pp;\r\nint ret;\r\nret = ks_pcie_get_irq_controller_info(ks_pcie,\r\n"legacy-interrupt-controller",\r\n&ks_pcie->num_legacy_host_irqs);\r\nif (ret)\r\nreturn ret;\r\nif (IS_ENABLED(CONFIG_PCI_MSI)) {\r\nret = ks_pcie_get_irq_controller_info(ks_pcie,\r\n"msi-interrupt-controller",\r\n&ks_pcie->num_msi_host_irqs);\r\nif (ret)\r\nreturn ret;\r\n}\r\npp->root_bus_nr = -1;\r\npp->ops = &keystone_pcie_host_ops;\r\nret = ks_dw_pcie_host_init(ks_pcie, ks_pcie->msi_intc_np);\r\nif (ret) {\r\ndev_err(&pdev->dev, "failed to initialize host\n");\r\nreturn ret;\r\n}\r\nreturn ret;\r\n}\r\nstatic int __exit ks_pcie_remove(struct platform_device *pdev)\r\n{\r\nstruct keystone_pcie *ks_pcie = platform_get_drvdata(pdev);\r\nclk_disable_unprepare(ks_pcie->clk);\r\nreturn 0;\r\n}\r\nstatic int __init ks_pcie_probe(struct platform_device *pdev)\r\n{\r\nstruct device *dev = &pdev->dev;\r\nstruct keystone_pcie *ks_pcie;\r\nstruct pcie_port *pp;\r\nstruct resource *res;\r\nvoid __iomem *reg_p;\r\nstruct phy *phy;\r\nint ret = 0;\r\nks_pcie = devm_kzalloc(&pdev->dev, sizeof(*ks_pcie),\r\nGFP_KERNEL);\r\nif (!ks_pcie)\r\nreturn -ENOMEM;\r\npp = &ks_pcie->pp;\r\nphy = devm_phy_get(dev, "pcie-phy");\r\nif (!IS_ERR_OR_NULL(phy)) {\r\nret = phy_init(phy);\r\nif (ret < 0)\r\nreturn ret;\r\n}\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 2);\r\nreg_p = devm_ioremap_resource(dev, res);\r\nif (IS_ERR(reg_p))\r\nreturn PTR_ERR(reg_p);\r\nks_pcie->device_id = readl(reg_p) >> 16;\r\ndevm_iounmap(dev, reg_p);\r\ndevm_release_mem_region(dev, res->start, resource_size(res));\r\npp->dev = dev;\r\nplatform_set_drvdata(pdev, ks_pcie);\r\nks_pcie->clk = devm_clk_get(dev, "pcie");\r\nif (IS_ERR(ks_pcie->clk)) {\r\ndev_err(dev, "Failed to get pcie rc clock\n");\r\nreturn PTR_ERR(ks_pcie->clk);\r\n}\r\nret = clk_prepare_enable(ks_pcie->clk);\r\nif (ret)\r\nreturn ret;\r\nret = ks_add_pcie_port(ks_pcie, pdev);\r\nif (ret < 0)\r\ngoto fail_clk;\r\nreturn 0;\r\nfail_clk:\r\nclk_disable_unprepare(ks_pcie->clk);\r\nreturn ret;\r\n}
