static void bcm_sf2_sw_get_strings(struct dsa_switch *ds,\r\nint port, uint8_t *data)\r\n{\r\nunsigned int i;\r\nfor (i = 0; i < BCM_SF2_STATS_SIZE; i++)\r\nmemcpy(data + i * ETH_GSTRING_LEN,\r\nbcm_sf2_mib[i].string, ETH_GSTRING_LEN);\r\n}\r\nstatic void bcm_sf2_sw_get_ethtool_stats(struct dsa_switch *ds,\r\nint port, uint64_t *data)\r\n{\r\nstruct bcm_sf2_priv *priv = ds_to_priv(ds);\r\nconst struct bcm_sf2_hw_stats *s;\r\nunsigned int i;\r\nu64 val = 0;\r\nu32 offset;\r\nmutex_lock(&priv->stats_mutex);\r\nfor (i = 0; i < BCM_SF2_STATS_SIZE; i++) {\r\ns = &bcm_sf2_mib[i];\r\noffset = s->reg + CORE_P_MIB_OFFSET(port);\r\nif (s->sizeof_stat == 8)\r\nval = core_readq(priv, offset);\r\nelse\r\nval = core_readl(priv, offset);\r\ndata[i] = (u64)val;\r\n}\r\nmutex_unlock(&priv->stats_mutex);\r\n}\r\nstatic int bcm_sf2_sw_get_sset_count(struct dsa_switch *ds)\r\n{\r\nreturn BCM_SF2_STATS_SIZE;\r\n}\r\nstatic char *bcm_sf2_sw_probe(struct device *host_dev, int sw_addr)\r\n{\r\nreturn "Broadcom Starfighter 2";\r\n}\r\nstatic void bcm_sf2_imp_vlan_setup(struct dsa_switch *ds, int cpu_port)\r\n{\r\nstruct bcm_sf2_priv *priv = ds_to_priv(ds);\r\nunsigned int i;\r\nu32 reg;\r\nfor (i = 0; i < priv->hw_params.num_ports; i++) {\r\nif (!((1 << i) & ds->phys_port_mask))\r\ncontinue;\r\nreg = core_readl(priv, CORE_PORT_VLAN_CTL_PORT(i));\r\nreg |= (1 << cpu_port);\r\ncore_writel(priv, reg, CORE_PORT_VLAN_CTL_PORT(i));\r\n}\r\n}\r\nstatic void bcm_sf2_imp_setup(struct dsa_switch *ds, int port)\r\n{\r\nstruct bcm_sf2_priv *priv = ds_to_priv(ds);\r\nu32 reg, val;\r\nreg = core_readl(priv, CORE_MEM_PSM_VDD_CTRL);\r\nreg &= ~P_TXQ_PSM_VDD(port);\r\ncore_writel(priv, reg, CORE_MEM_PSM_VDD_CTRL);\r\nreg = core_readl(priv, CORE_IMP_CTL);\r\nreg |= (RX_BCST_EN | RX_MCST_EN | RX_UCST_EN);\r\nreg &= ~(RX_DIS | TX_DIS);\r\ncore_writel(priv, reg, CORE_IMP_CTL);\r\ncore_writel(priv, SW_FWDG_EN, CORE_SWMODE);\r\nreg = core_readl(priv, CORE_SWITCH_CTRL);\r\nreg |= MII_DUMB_FWDG_EN;\r\ncore_writel(priv, reg, CORE_SWITCH_CTRL);\r\nswitch (port) {\r\ncase 8:\r\nval = BRCM_HDR_EN_P8;\r\nbreak;\r\ncase 7:\r\nval = BRCM_HDR_EN_P7;\r\nbreak;\r\ncase 5:\r\nval = BRCM_HDR_EN_P5;\r\nbreak;\r\ndefault:\r\nval = 0;\r\nbreak;\r\n}\r\nreg = core_readl(priv, CORE_BRCM_HDR_CTRL);\r\nreg |= val;\r\ncore_writel(priv, reg, CORE_BRCM_HDR_CTRL);\r\nreg = core_readl(priv, CORE_BRCM_HDR_RX_DIS);\r\nreg &= ~(1 << port);\r\ncore_writel(priv, reg, CORE_BRCM_HDR_RX_DIS);\r\nreg = core_readl(priv, CORE_BRCM_HDR_TX_DIS);\r\nreg &= ~(1 << port);\r\ncore_writel(priv, reg, CORE_BRCM_HDR_TX_DIS);\r\nreg = core_readl(priv, CORE_STS_OVERRIDE_IMP);\r\nreg |= (MII_SW_OR | LINK_STS);\r\ncore_writel(priv, reg, CORE_STS_OVERRIDE_IMP);\r\n}\r\nstatic void bcm_sf2_eee_enable_set(struct dsa_switch *ds, int port, bool enable)\r\n{\r\nstruct bcm_sf2_priv *priv = ds_to_priv(ds);\r\nu32 reg;\r\nreg = core_readl(priv, CORE_EEE_EN_CTRL);\r\nif (enable)\r\nreg |= 1 << port;\r\nelse\r\nreg &= ~(1 << port);\r\ncore_writel(priv, reg, CORE_EEE_EN_CTRL);\r\n}\r\nstatic void bcm_sf2_gphy_enable_set(struct dsa_switch *ds, bool enable)\r\n{\r\nstruct bcm_sf2_priv *priv = ds_to_priv(ds);\r\nu32 reg;\r\nreg = reg_readl(priv, REG_SPHY_CNTRL);\r\nif (enable) {\r\nreg |= PHY_RESET;\r\nreg &= ~(EXT_PWR_DOWN | IDDQ_BIAS | CK25_DIS);\r\nreg_writel(priv, reg, REG_SPHY_CNTRL);\r\nudelay(21);\r\nreg = reg_readl(priv, REG_SPHY_CNTRL);\r\nreg &= ~PHY_RESET;\r\n} else {\r\nreg |= EXT_PWR_DOWN | IDDQ_BIAS | PHY_RESET;\r\nreg_writel(priv, reg, REG_SPHY_CNTRL);\r\nmdelay(1);\r\nreg |= CK25_DIS;\r\n}\r\nreg_writel(priv, reg, REG_SPHY_CNTRL);\r\nif (!enable) {\r\nreg = reg_readl(priv, REG_LED_CNTRL(0));\r\nreg |= SPDLNK_SRC_SEL;\r\nreg_writel(priv, reg, REG_LED_CNTRL(0));\r\n}\r\n}\r\nstatic inline void bcm_sf2_port_intr_enable(struct bcm_sf2_priv *priv,\r\nint port)\r\n{\r\nunsigned int off;\r\nswitch (port) {\r\ncase 7:\r\noff = P7_IRQ_OFF;\r\nbreak;\r\ncase 0:\r\nintrl2_0_mask_clear(priv, P_IRQ_MASK(P0_IRQ_OFF));\r\nreturn;\r\ndefault:\r\noff = P_IRQ_OFF(port);\r\nbreak;\r\n}\r\nintrl2_1_mask_clear(priv, P_IRQ_MASK(off));\r\n}\r\nstatic inline void bcm_sf2_port_intr_disable(struct bcm_sf2_priv *priv,\r\nint port)\r\n{\r\nunsigned int off;\r\nswitch (port) {\r\ncase 7:\r\noff = P7_IRQ_OFF;\r\nbreak;\r\ncase 0:\r\nintrl2_0_mask_set(priv, P_IRQ_MASK(P0_IRQ_OFF));\r\nintrl2_0_writel(priv, P_IRQ_MASK(P0_IRQ_OFF), INTRL2_CPU_CLEAR);\r\nreturn;\r\ndefault:\r\noff = P_IRQ_OFF(port);\r\nbreak;\r\n}\r\nintrl2_1_mask_set(priv, P_IRQ_MASK(off));\r\nintrl2_1_writel(priv, P_IRQ_MASK(off), INTRL2_CPU_CLEAR);\r\n}\r\nstatic int bcm_sf2_port_setup(struct dsa_switch *ds, int port,\r\nstruct phy_device *phy)\r\n{\r\nstruct bcm_sf2_priv *priv = ds_to_priv(ds);\r\ns8 cpu_port = ds->dst[ds->index].cpu_port;\r\nu32 reg;\r\nreg = core_readl(priv, CORE_MEM_PSM_VDD_CTRL);\r\nreg &= ~P_TXQ_PSM_VDD(port);\r\ncore_writel(priv, reg, CORE_MEM_PSM_VDD_CTRL);\r\ncore_writel(priv, 0, CORE_G_PCTL_PORT(port));\r\nif (priv->int_phy_mask & 1 << port && priv->hw_params.num_gphy == 1) {\r\nbcm_sf2_gphy_enable_set(ds, true);\r\nif (phy) {\r\nphy->state = PHY_READY;\r\nphy_init_hw(phy);\r\n}\r\n}\r\nif (port == priv->moca_port)\r\nbcm_sf2_port_intr_enable(priv, port);\r\nreg = core_readl(priv, CORE_PORT_VLAN_CTL_PORT(port));\r\nreg &= ~PORT_VLAN_CTRL_MASK;\r\nreg |= (1 << port);\r\nreg |= priv->port_sts[port].vlan_ctl_mask;\r\ncore_writel(priv, reg, CORE_PORT_VLAN_CTL_PORT(port));\r\nbcm_sf2_imp_vlan_setup(ds, cpu_port);\r\nif (priv->port_sts[port].eee.eee_enabled)\r\nbcm_sf2_eee_enable_set(ds, port, true);\r\nreturn 0;\r\n}\r\nstatic void bcm_sf2_port_disable(struct dsa_switch *ds, int port,\r\nstruct phy_device *phy)\r\n{\r\nstruct bcm_sf2_priv *priv = ds_to_priv(ds);\r\nu32 off, reg;\r\nif (priv->wol_ports_mask & (1 << port))\r\nreturn;\r\nif (port == priv->moca_port)\r\nbcm_sf2_port_intr_disable(priv, port);\r\nif (priv->int_phy_mask & 1 << port && priv->hw_params.num_gphy == 1)\r\nbcm_sf2_gphy_enable_set(ds, false);\r\nif (dsa_is_cpu_port(ds, port))\r\noff = CORE_IMP_CTL;\r\nelse\r\noff = CORE_G_PCTL_PORT(port);\r\nreg = core_readl(priv, off);\r\nreg |= RX_DIS | TX_DIS;\r\ncore_writel(priv, reg, off);\r\nreg = core_readl(priv, CORE_MEM_PSM_VDD_CTRL);\r\nreg |= P_TXQ_PSM_VDD(port);\r\ncore_writel(priv, reg, CORE_MEM_PSM_VDD_CTRL);\r\n}\r\nstatic int bcm_sf2_eee_init(struct dsa_switch *ds, int port,\r\nstruct phy_device *phy)\r\n{\r\nstruct bcm_sf2_priv *priv = ds_to_priv(ds);\r\nstruct ethtool_eee *p = &priv->port_sts[port].eee;\r\nint ret;\r\np->supported = (SUPPORTED_1000baseT_Full | SUPPORTED_100baseT_Full);\r\nret = phy_init_eee(phy, 0);\r\nif (ret)\r\nreturn 0;\r\nbcm_sf2_eee_enable_set(ds, port, true);\r\nreturn 1;\r\n}\r\nstatic int bcm_sf2_sw_get_eee(struct dsa_switch *ds, int port,\r\nstruct ethtool_eee *e)\r\n{\r\nstruct bcm_sf2_priv *priv = ds_to_priv(ds);\r\nstruct ethtool_eee *p = &priv->port_sts[port].eee;\r\nu32 reg;\r\nreg = core_readl(priv, CORE_EEE_LPI_INDICATE);\r\ne->eee_enabled = p->eee_enabled;\r\ne->eee_active = !!(reg & (1 << port));\r\nreturn 0;\r\n}\r\nstatic int bcm_sf2_sw_set_eee(struct dsa_switch *ds, int port,\r\nstruct phy_device *phydev,\r\nstruct ethtool_eee *e)\r\n{\r\nstruct bcm_sf2_priv *priv = ds_to_priv(ds);\r\nstruct ethtool_eee *p = &priv->port_sts[port].eee;\r\np->eee_enabled = e->eee_enabled;\r\nif (!p->eee_enabled) {\r\nbcm_sf2_eee_enable_set(ds, port, false);\r\n} else {\r\np->eee_enabled = bcm_sf2_eee_init(ds, port, phydev);\r\nif (!p->eee_enabled)\r\nreturn -EOPNOTSUPP;\r\n}\r\nreturn 0;\r\n}\r\nstatic int bcm_sf2_sw_fast_age_port(struct dsa_switch *ds, int port)\r\n{\r\nstruct bcm_sf2_priv *priv = ds_to_priv(ds);\r\nunsigned int timeout = 1000;\r\nu32 reg;\r\ncore_writel(priv, port, CORE_FAST_AGE_PORT);\r\nreg = core_readl(priv, CORE_FAST_AGE_CTRL);\r\nreg |= EN_AGE_PORT | EN_AGE_DYNAMIC | FAST_AGE_STR_DONE;\r\ncore_writel(priv, reg, CORE_FAST_AGE_CTRL);\r\ndo {\r\nreg = core_readl(priv, CORE_FAST_AGE_CTRL);\r\nif (!(reg & FAST_AGE_STR_DONE))\r\nbreak;\r\ncpu_relax();\r\n} while (timeout--);\r\nif (!timeout)\r\nreturn -ETIMEDOUT;\r\ncore_writel(priv, 0, CORE_FAST_AGE_CTRL);\r\nreturn 0;\r\n}\r\nstatic int bcm_sf2_sw_br_join(struct dsa_switch *ds, int port,\r\nu32 br_port_mask)\r\n{\r\nstruct bcm_sf2_priv *priv = ds_to_priv(ds);\r\nunsigned int i;\r\nu32 reg, p_ctl;\r\np_ctl = core_readl(priv, CORE_PORT_VLAN_CTL_PORT(port));\r\nfor (i = 0; i < priv->hw_params.num_ports; i++) {\r\nif (!((1 << i) & br_port_mask))\r\ncontinue;\r\nreg = core_readl(priv, CORE_PORT_VLAN_CTL_PORT(i));\r\nreg |= 1 << port;\r\ncore_writel(priv, reg, CORE_PORT_VLAN_CTL_PORT(i));\r\npriv->port_sts[i].vlan_ctl_mask = reg;\r\np_ctl |= 1 << i;\r\n}\r\ncore_writel(priv, p_ctl, CORE_PORT_VLAN_CTL_PORT(port));\r\npriv->port_sts[port].vlan_ctl_mask = p_ctl;\r\nreturn 0;\r\n}\r\nstatic int bcm_sf2_sw_br_leave(struct dsa_switch *ds, int port,\r\nu32 br_port_mask)\r\n{\r\nstruct bcm_sf2_priv *priv = ds_to_priv(ds);\r\nunsigned int i;\r\nu32 reg, p_ctl;\r\np_ctl = core_readl(priv, CORE_PORT_VLAN_CTL_PORT(port));\r\nfor (i = 0; i < priv->hw_params.num_ports; i++) {\r\nif (!((1 << i) & br_port_mask))\r\ncontinue;\r\nreg = core_readl(priv, CORE_PORT_VLAN_CTL_PORT(i));\r\nreg &= ~(1 << port);\r\ncore_writel(priv, reg, CORE_PORT_VLAN_CTL_PORT(i));\r\npriv->port_sts[port].vlan_ctl_mask = reg;\r\nif (port != i)\r\np_ctl &= ~(1 << i);\r\n}\r\ncore_writel(priv, p_ctl, CORE_PORT_VLAN_CTL_PORT(port));\r\npriv->port_sts[port].vlan_ctl_mask = p_ctl;\r\nreturn 0;\r\n}\r\nstatic int bcm_sf2_sw_br_set_stp_state(struct dsa_switch *ds, int port,\r\nu8 state)\r\n{\r\nstruct bcm_sf2_priv *priv = ds_to_priv(ds);\r\nu8 hw_state, cur_hw_state;\r\nint ret = 0;\r\nu32 reg;\r\nreg = core_readl(priv, CORE_G_PCTL_PORT(port));\r\ncur_hw_state = reg & (G_MISTP_STATE_MASK << G_MISTP_STATE_SHIFT);\r\nswitch (state) {\r\ncase BR_STATE_DISABLED:\r\nhw_state = G_MISTP_DIS_STATE;\r\nbreak;\r\ncase BR_STATE_LISTENING:\r\nhw_state = G_MISTP_LISTEN_STATE;\r\nbreak;\r\ncase BR_STATE_LEARNING:\r\nhw_state = G_MISTP_LEARN_STATE;\r\nbreak;\r\ncase BR_STATE_FORWARDING:\r\nhw_state = G_MISTP_FWD_STATE;\r\nbreak;\r\ncase BR_STATE_BLOCKING:\r\nhw_state = G_MISTP_BLOCK_STATE;\r\nbreak;\r\ndefault:\r\npr_err("%s: invalid STP state: %d\n", __func__, state);\r\nreturn -EINVAL;\r\n}\r\nif (cur_hw_state != hw_state) {\r\nif (cur_hw_state >= G_MISTP_LEARN_STATE &&\r\nhw_state <= G_MISTP_LISTEN_STATE) {\r\nret = bcm_sf2_sw_fast_age_port(ds, port);\r\nif (ret) {\r\npr_err("%s: fast-ageing failed\n", __func__);\r\nreturn ret;\r\n}\r\n}\r\n}\r\nreg = core_readl(priv, CORE_G_PCTL_PORT(port));\r\nreg &= ~(G_MISTP_STATE_MASK << G_MISTP_STATE_SHIFT);\r\nreg |= hw_state;\r\ncore_writel(priv, reg, CORE_G_PCTL_PORT(port));\r\nreturn 0;\r\n}\r\nstatic int bcm_sf2_arl_op_wait(struct bcm_sf2_priv *priv)\r\n{\r\nunsigned int timeout = 10;\r\nu32 reg;\r\ndo {\r\nreg = core_readl(priv, CORE_ARLA_RWCTL);\r\nif (!(reg & ARL_STRTDN))\r\nreturn 0;\r\nusleep_range(1000, 2000);\r\n} while (timeout--);\r\nreturn -ETIMEDOUT;\r\n}\r\nstatic int bcm_sf2_arl_rw_op(struct bcm_sf2_priv *priv, unsigned int op)\r\n{\r\nu32 cmd;\r\nif (op > ARL_RW)\r\nreturn -EINVAL;\r\ncmd = core_readl(priv, CORE_ARLA_RWCTL);\r\ncmd &= ~IVL_SVL_SELECT;\r\ncmd |= ARL_STRTDN;\r\nif (op)\r\ncmd |= ARL_RW;\r\nelse\r\ncmd &= ~ARL_RW;\r\ncore_writel(priv, cmd, CORE_ARLA_RWCTL);\r\nreturn bcm_sf2_arl_op_wait(priv);\r\n}\r\nstatic int bcm_sf2_arl_read(struct bcm_sf2_priv *priv, u64 mac,\r\nu16 vid, struct bcm_sf2_arl_entry *ent, u8 *idx,\r\nbool is_valid)\r\n{\r\nunsigned int i;\r\nint ret;\r\nret = bcm_sf2_arl_op_wait(priv);\r\nif (ret)\r\nreturn ret;\r\nfor (i = 0; i < 4; i++) {\r\nu64 mac_vid;\r\nu32 fwd_entry;\r\nmac_vid = core_readq(priv, CORE_ARLA_MACVID_ENTRY(i));\r\nfwd_entry = core_readl(priv, CORE_ARLA_FWD_ENTRY(i));\r\nbcm_sf2_arl_to_entry(ent, mac_vid, fwd_entry);\r\nif (ent->is_valid && is_valid) {\r\n*idx = i;\r\nreturn 0;\r\n}\r\nif (!is_valid && (mac_vid & mac))\r\nreturn 0;\r\n}\r\nreturn -ENOENT;\r\n}\r\nstatic int bcm_sf2_arl_op(struct bcm_sf2_priv *priv, int op, int port,\r\nconst unsigned char *addr, u16 vid, bool is_valid)\r\n{\r\nstruct bcm_sf2_arl_entry ent;\r\nu32 fwd_entry;\r\nu64 mac, mac_vid = 0;\r\nu8 idx = 0;\r\nint ret;\r\nmac = bcm_sf2_mac_to_u64(addr);\r\ncore_writeq(priv, mac, CORE_ARLA_MAC);\r\ncore_writel(priv, vid, CORE_ARLA_VID);\r\nret = bcm_sf2_arl_rw_op(priv, 1);\r\nif (ret)\r\nreturn ret;\r\nret = bcm_sf2_arl_read(priv, mac, vid, &ent, &idx, is_valid);\r\nif (op)\r\nreturn ret;\r\nif (ret) {\r\nfwd_entry = 0;\r\nidx = 0;\r\n}\r\nmemset(&ent, 0, sizeof(ent));\r\nent.port = port;\r\nent.is_valid = is_valid;\r\nent.vid = vid;\r\nent.is_static = true;\r\nmemcpy(ent.mac, addr, ETH_ALEN);\r\nbcm_sf2_arl_from_entry(&mac_vid, &fwd_entry, &ent);\r\ncore_writeq(priv, mac_vid, CORE_ARLA_MACVID_ENTRY(idx));\r\ncore_writel(priv, fwd_entry, CORE_ARLA_FWD_ENTRY(idx));\r\nret = bcm_sf2_arl_rw_op(priv, 0);\r\nif (ret)\r\nreturn ret;\r\nreturn bcm_sf2_arl_read(priv, mac, vid, &ent, &idx, is_valid);\r\n}\r\nstatic int bcm_sf2_sw_fdb_prepare(struct dsa_switch *ds, int port,\r\nconst struct switchdev_obj_port_fdb *fdb,\r\nstruct switchdev_trans *trans)\r\n{\r\nreturn 0;\r\n}\r\nstatic int bcm_sf2_sw_fdb_add(struct dsa_switch *ds, int port,\r\nconst struct switchdev_obj_port_fdb *fdb,\r\nstruct switchdev_trans *trans)\r\n{\r\nstruct bcm_sf2_priv *priv = ds_to_priv(ds);\r\nreturn bcm_sf2_arl_op(priv, 0, port, fdb->addr, fdb->vid, true);\r\n}\r\nstatic int bcm_sf2_sw_fdb_del(struct dsa_switch *ds, int port,\r\nconst struct switchdev_obj_port_fdb *fdb)\r\n{\r\nstruct bcm_sf2_priv *priv = ds_to_priv(ds);\r\nreturn bcm_sf2_arl_op(priv, 0, port, fdb->addr, fdb->vid, false);\r\n}\r\nstatic int bcm_sf2_arl_search_wait(struct bcm_sf2_priv *priv)\r\n{\r\nunsigned timeout = 1000;\r\nu32 reg;\r\ndo {\r\nreg = core_readl(priv, CORE_ARLA_SRCH_CTL);\r\nif (!(reg & ARLA_SRCH_STDN))\r\nreturn 0;\r\nif (reg & ARLA_SRCH_VLID)\r\nreturn 0;\r\nusleep_range(1000, 2000);\r\n} while (timeout--);\r\nreturn -ETIMEDOUT;\r\n}\r\nstatic void bcm_sf2_arl_search_rd(struct bcm_sf2_priv *priv, u8 idx,\r\nstruct bcm_sf2_arl_entry *ent)\r\n{\r\nu64 mac_vid;\r\nu32 fwd_entry;\r\nmac_vid = core_readq(priv, CORE_ARLA_SRCH_RSLT_MACVID(idx));\r\nfwd_entry = core_readl(priv, CORE_ARLA_SRCH_RSLT(idx));\r\nbcm_sf2_arl_to_entry(ent, mac_vid, fwd_entry);\r\n}\r\nstatic int bcm_sf2_sw_fdb_copy(struct net_device *dev, int port,\r\nconst struct bcm_sf2_arl_entry *ent,\r\nstruct switchdev_obj_port_fdb *fdb,\r\nint (*cb)(struct switchdev_obj *obj))\r\n{\r\nif (!ent->is_valid)\r\nreturn 0;\r\nif (port != ent->port)\r\nreturn 0;\r\nether_addr_copy(fdb->addr, ent->mac);\r\nfdb->vid = ent->vid;\r\nfdb->ndm_state = ent->is_static ? NUD_NOARP : NUD_REACHABLE;\r\nreturn cb(&fdb->obj);\r\n}\r\nstatic int bcm_sf2_sw_fdb_dump(struct dsa_switch *ds, int port,\r\nstruct switchdev_obj_port_fdb *fdb,\r\nint (*cb)(struct switchdev_obj *obj))\r\n{\r\nstruct bcm_sf2_priv *priv = ds_to_priv(ds);\r\nstruct net_device *dev = ds->ports[port];\r\nstruct bcm_sf2_arl_entry results[2];\r\nunsigned int count = 0;\r\nint ret;\r\ncore_writel(priv, ARLA_SRCH_STDN, CORE_ARLA_SRCH_CTL);\r\ndo {\r\nret = bcm_sf2_arl_search_wait(priv);\r\nif (ret)\r\nreturn ret;\r\nbcm_sf2_arl_search_rd(priv, 0, &results[0]);\r\nret = bcm_sf2_sw_fdb_copy(dev, port, &results[0], fdb, cb);\r\nif (ret)\r\nreturn ret;\r\nbcm_sf2_arl_search_rd(priv, 1, &results[1]);\r\nret = bcm_sf2_sw_fdb_copy(dev, port, &results[1], fdb, cb);\r\nif (ret)\r\nreturn ret;\r\nif (!results[0].is_valid && !results[1].is_valid)\r\nbreak;\r\n} while (count++ < CORE_ARLA_NUM_ENTRIES);\r\nreturn 0;\r\n}\r\nstatic irqreturn_t bcm_sf2_switch_0_isr(int irq, void *dev_id)\r\n{\r\nstruct bcm_sf2_priv *priv = dev_id;\r\npriv->irq0_stat = intrl2_0_readl(priv, INTRL2_CPU_STATUS) &\r\n~priv->irq0_mask;\r\nintrl2_0_writel(priv, priv->irq0_stat, INTRL2_CPU_CLEAR);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic irqreturn_t bcm_sf2_switch_1_isr(int irq, void *dev_id)\r\n{\r\nstruct bcm_sf2_priv *priv = dev_id;\r\npriv->irq1_stat = intrl2_1_readl(priv, INTRL2_CPU_STATUS) &\r\n~priv->irq1_mask;\r\nintrl2_1_writel(priv, priv->irq1_stat, INTRL2_CPU_CLEAR);\r\nif (priv->irq1_stat & P_LINK_UP_IRQ(P7_IRQ_OFF))\r\npriv->port_sts[7].link = 1;\r\nif (priv->irq1_stat & P_LINK_DOWN_IRQ(P7_IRQ_OFF))\r\npriv->port_sts[7].link = 0;\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int bcm_sf2_sw_rst(struct bcm_sf2_priv *priv)\r\n{\r\nunsigned int timeout = 1000;\r\nu32 reg;\r\nreg = core_readl(priv, CORE_WATCHDOG_CTRL);\r\nreg |= SOFTWARE_RESET | EN_CHIP_RST | EN_SW_RESET;\r\ncore_writel(priv, reg, CORE_WATCHDOG_CTRL);\r\ndo {\r\nreg = core_readl(priv, CORE_WATCHDOG_CTRL);\r\nif (!(reg & SOFTWARE_RESET))\r\nbreak;\r\nusleep_range(1000, 2000);\r\n} while (timeout-- > 0);\r\nif (timeout == 0)\r\nreturn -ETIMEDOUT;\r\nreturn 0;\r\n}\r\nstatic void bcm_sf2_intr_disable(struct bcm_sf2_priv *priv)\r\n{\r\nintrl2_0_writel(priv, 0xffffffff, INTRL2_CPU_MASK_SET);\r\nintrl2_0_writel(priv, 0xffffffff, INTRL2_CPU_CLEAR);\r\nintrl2_0_writel(priv, 0, INTRL2_CPU_MASK_CLEAR);\r\nintrl2_1_writel(priv, 0xffffffff, INTRL2_CPU_MASK_SET);\r\nintrl2_1_writel(priv, 0xffffffff, INTRL2_CPU_CLEAR);\r\nintrl2_1_writel(priv, 0, INTRL2_CPU_MASK_CLEAR);\r\n}\r\nstatic void bcm_sf2_identify_ports(struct bcm_sf2_priv *priv,\r\nstruct device_node *dn)\r\n{\r\nstruct device_node *port;\r\nconst char *phy_mode_str;\r\nint mode;\r\nunsigned int port_num;\r\nint ret;\r\npriv->moca_port = -1;\r\nfor_each_available_child_of_node(dn, port) {\r\nif (of_property_read_u32(port, "reg", &port_num))\r\ncontinue;\r\nmode = of_get_phy_mode(port);\r\nif (mode < 0) {\r\nret = of_property_read_string(port, "phy-mode",\r\n&phy_mode_str);\r\nif (ret < 0)\r\ncontinue;\r\nif (!strcasecmp(phy_mode_str, "internal"))\r\npriv->int_phy_mask |= 1 << port_num;\r\n}\r\nif (mode == PHY_INTERFACE_MODE_MOCA)\r\npriv->moca_port = port_num;\r\n}\r\n}\r\nstatic int bcm_sf2_sw_setup(struct dsa_switch *ds)\r\n{\r\nconst char *reg_names[BCM_SF2_REGS_NUM] = BCM_SF2_REGS_NAME;\r\nstruct bcm_sf2_priv *priv = ds_to_priv(ds);\r\nstruct device_node *dn;\r\nvoid __iomem **base;\r\nunsigned int port;\r\nunsigned int i;\r\nu32 reg, rev;\r\nint ret;\r\nspin_lock_init(&priv->indir_lock);\r\nmutex_init(&priv->stats_mutex);\r\ndn = ds->pd->of_node->parent;\r\nbcm_sf2_identify_ports(priv, ds->pd->of_node);\r\npriv->irq0 = irq_of_parse_and_map(dn, 0);\r\npriv->irq1 = irq_of_parse_and_map(dn, 1);\r\nbase = &priv->core;\r\nfor (i = 0; i < BCM_SF2_REGS_NUM; i++) {\r\n*base = of_iomap(dn, i);\r\nif (*base == NULL) {\r\npr_err("unable to find register: %s\n", reg_names[i]);\r\nret = -ENOMEM;\r\ngoto out_unmap;\r\n}\r\nbase++;\r\n}\r\nret = bcm_sf2_sw_rst(priv);\r\nif (ret) {\r\npr_err("unable to software reset switch: %d\n", ret);\r\ngoto out_unmap;\r\n}\r\nbcm_sf2_intr_disable(priv);\r\nret = request_irq(priv->irq0, bcm_sf2_switch_0_isr, 0,\r\n"switch_0", priv);\r\nif (ret < 0) {\r\npr_err("failed to request switch_0 IRQ\n");\r\ngoto out_unmap;\r\n}\r\nret = request_irq(priv->irq1, bcm_sf2_switch_1_isr, 0,\r\n"switch_1", priv);\r\nif (ret < 0) {\r\npr_err("failed to request switch_1 IRQ\n");\r\ngoto out_free_irq0;\r\n}\r\nreg = core_readl(priv, CORE_GMNCFGCFG);\r\nreg |= RST_MIB_CNT;\r\ncore_writel(priv, reg, CORE_GMNCFGCFG);\r\nreg &= ~RST_MIB_CNT;\r\ncore_writel(priv, reg, CORE_GMNCFGCFG);\r\npriv->hw_params.num_ports = core_readl(priv, CORE_IMP0_PRT_ID) + 1;\r\nif (priv->hw_params.num_ports > DSA_MAX_PORTS)\r\npriv->hw_params.num_ports = DSA_MAX_PORTS;\r\nif (of_property_read_u32(dn, "brcm,num-gphy",\r\n&priv->hw_params.num_gphy))\r\npriv->hw_params.num_gphy = 1;\r\nfor (port = 0; port < priv->hw_params.num_ports; port++) {\r\nif ((1 << port) & ds->phys_port_mask)\r\nbcm_sf2_port_setup(ds, port, NULL);\r\nelse if (dsa_is_cpu_port(ds, port))\r\nbcm_sf2_imp_setup(ds, port);\r\nelse\r\nbcm_sf2_port_disable(ds, port, NULL);\r\n}\r\nif (of_machine_is_compatible("brcm,bcm7445d0"))\r\nds->phys_mii_mask |= ((1 << BRCM_PSEUDO_PHY_ADDR) | (1 << 0));\r\nelse\r\nds->phys_mii_mask = 0;\r\nrev = reg_readl(priv, REG_SWITCH_REVISION);\r\npriv->hw_params.top_rev = (rev >> SWITCH_TOP_REV_SHIFT) &\r\nSWITCH_TOP_REV_MASK;\r\npriv->hw_params.core_rev = (rev & SF2_REV_MASK);\r\nrev = reg_readl(priv, REG_PHY_REVISION);\r\npriv->hw_params.gphy_rev = rev & PHY_REVISION_MASK;\r\npr_info("Starfighter 2 top: %x.%02x, core: %x.%02x base: 0x%p, IRQs: %d, %d\n",\r\npriv->hw_params.top_rev >> 8, priv->hw_params.top_rev & 0xff,\r\npriv->hw_params.core_rev >> 8, priv->hw_params.core_rev & 0xff,\r\npriv->core, priv->irq0, priv->irq1);\r\nreturn 0;\r\nout_free_irq0:\r\nfree_irq(priv->irq0, priv);\r\nout_unmap:\r\nbase = &priv->core;\r\nfor (i = 0; i < BCM_SF2_REGS_NUM; i++) {\r\nif (*base)\r\niounmap(*base);\r\nbase++;\r\n}\r\nreturn ret;\r\n}\r\nstatic int bcm_sf2_sw_set_addr(struct dsa_switch *ds, u8 *addr)\r\n{\r\nreturn 0;\r\n}\r\nstatic u32 bcm_sf2_sw_get_phy_flags(struct dsa_switch *ds, int port)\r\n{\r\nstruct bcm_sf2_priv *priv = ds_to_priv(ds);\r\nreturn priv->hw_params.gphy_rev;\r\n}\r\nstatic int bcm_sf2_sw_indir_rw(struct dsa_switch *ds, int op, int addr,\r\nint regnum, u16 val)\r\n{\r\nstruct bcm_sf2_priv *priv = ds_to_priv(ds);\r\nint ret = 0;\r\nu32 reg;\r\nreg = reg_readl(priv, REG_SWITCH_CNTRL);\r\nreg |= MDIO_MASTER_SEL;\r\nreg_writel(priv, reg, REG_SWITCH_CNTRL);\r\nreg = 0x70;\r\nreg <<= 2;\r\ncore_writel(priv, addr, reg);\r\nreg = 0x80 << 8 | regnum << 1;\r\nreg <<= 2;\r\nif (op)\r\nret = core_readl(priv, reg);\r\nelse\r\ncore_writel(priv, val, reg);\r\nreg = reg_readl(priv, REG_SWITCH_CNTRL);\r\nreg &= ~MDIO_MASTER_SEL;\r\nreg_writel(priv, reg, REG_SWITCH_CNTRL);\r\nreturn ret & 0xffff;\r\n}\r\nstatic int bcm_sf2_sw_phy_read(struct dsa_switch *ds, int addr, int regnum)\r\n{\r\nswitch (addr) {\r\ncase 0:\r\ncase BRCM_PSEUDO_PHY_ADDR:\r\nreturn bcm_sf2_sw_indir_rw(ds, 1, addr, regnum, 0);\r\ndefault:\r\nreturn 0xffff;\r\n}\r\n}\r\nstatic int bcm_sf2_sw_phy_write(struct dsa_switch *ds, int addr, int regnum,\r\nu16 val)\r\n{\r\nswitch (addr) {\r\ncase 0:\r\ncase BRCM_PSEUDO_PHY_ADDR:\r\nbcm_sf2_sw_indir_rw(ds, 0, addr, regnum, val);\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic void bcm_sf2_sw_adjust_link(struct dsa_switch *ds, int port,\r\nstruct phy_device *phydev)\r\n{\r\nstruct bcm_sf2_priv *priv = ds_to_priv(ds);\r\nu32 id_mode_dis = 0, port_mode;\r\nconst char *str = NULL;\r\nu32 reg;\r\nswitch (phydev->interface) {\r\ncase PHY_INTERFACE_MODE_RGMII:\r\nstr = "RGMII (no delay)";\r\nid_mode_dis = 1;\r\ncase PHY_INTERFACE_MODE_RGMII_TXID:\r\nif (!str)\r\nstr = "RGMII (TX delay)";\r\nport_mode = EXT_GPHY;\r\nbreak;\r\ncase PHY_INTERFACE_MODE_MII:\r\nstr = "MII";\r\nport_mode = EXT_EPHY;\r\nbreak;\r\ncase PHY_INTERFACE_MODE_REVMII:\r\nstr = "Reverse MII";\r\nport_mode = EXT_REVMII;\r\nbreak;\r\ndefault:\r\ngoto force_link;\r\n}\r\nif (!phydev->link) {\r\nreg = reg_readl(priv, REG_RGMII_CNTRL_P(port));\r\nreg &= ~RGMII_MODE_EN;\r\nreg_writel(priv, reg, REG_RGMII_CNTRL_P(port));\r\ngoto force_link;\r\n}\r\nreg = reg_readl(priv, REG_RGMII_CNTRL_P(port));\r\nreg &= ~ID_MODE_DIS;\r\nreg &= ~(PORT_MODE_MASK << PORT_MODE_SHIFT);\r\nreg &= ~(RX_PAUSE_EN | TX_PAUSE_EN);\r\nreg |= port_mode | RGMII_MODE_EN;\r\nif (id_mode_dis)\r\nreg |= ID_MODE_DIS;\r\nif (phydev->pause) {\r\nif (phydev->asym_pause)\r\nreg |= TX_PAUSE_EN;\r\nreg |= RX_PAUSE_EN;\r\n}\r\nreg_writel(priv, reg, REG_RGMII_CNTRL_P(port));\r\npr_info("Port %d configured for %s\n", port, str);\r\nforce_link:\r\nreg = SW_OVERRIDE;\r\nswitch (phydev->speed) {\r\ncase SPEED_1000:\r\nreg |= SPDSTS_1000 << SPEED_SHIFT;\r\nbreak;\r\ncase SPEED_100:\r\nreg |= SPDSTS_100 << SPEED_SHIFT;\r\nbreak;\r\n}\r\nif (phydev->link)\r\nreg |= LINK_STS;\r\nif (phydev->duplex == DUPLEX_FULL)\r\nreg |= DUPLX_MODE;\r\ncore_writel(priv, reg, CORE_STS_OVERRIDE_GMIIP_PORT(port));\r\n}\r\nstatic void bcm_sf2_sw_fixed_link_update(struct dsa_switch *ds, int port,\r\nstruct fixed_phy_status *status)\r\n{\r\nstruct bcm_sf2_priv *priv = ds_to_priv(ds);\r\nu32 duplex, pause;\r\nu32 reg;\r\nduplex = core_readl(priv, CORE_DUPSTS);\r\npause = core_readl(priv, CORE_PAUSESTS);\r\nstatus->link = 0;\r\nif (port == priv->moca_port) {\r\nstatus->link = priv->port_sts[port].link;\r\nif (!status->link)\r\nnetif_carrier_off(ds->ports[port]);\r\nstatus->duplex = 1;\r\n} else {\r\nstatus->link = 1;\r\nstatus->duplex = !!(duplex & (1 << port));\r\n}\r\nreg = core_readl(priv, CORE_STS_OVERRIDE_GMIIP_PORT(port));\r\nreg |= SW_OVERRIDE;\r\nif (status->link)\r\nreg |= LINK_STS;\r\nelse\r\nreg &= ~LINK_STS;\r\ncore_writel(priv, reg, CORE_STS_OVERRIDE_GMIIP_PORT(port));\r\nif ((pause & (1 << port)) &&\r\n(pause & (1 << (port + PAUSESTS_TX_PAUSE_SHIFT)))) {\r\nstatus->asym_pause = 1;\r\nstatus->pause = 1;\r\n}\r\nif (pause & (1 << port))\r\nstatus->pause = 1;\r\n}\r\nstatic int bcm_sf2_sw_suspend(struct dsa_switch *ds)\r\n{\r\nstruct bcm_sf2_priv *priv = ds_to_priv(ds);\r\nunsigned int port;\r\nbcm_sf2_intr_disable(priv);\r\nfor (port = 0; port < DSA_MAX_PORTS; port++) {\r\nif ((1 << port) & ds->phys_port_mask ||\r\ndsa_is_cpu_port(ds, port))\r\nbcm_sf2_port_disable(ds, port, NULL);\r\n}\r\nreturn 0;\r\n}\r\nstatic int bcm_sf2_sw_resume(struct dsa_switch *ds)\r\n{\r\nstruct bcm_sf2_priv *priv = ds_to_priv(ds);\r\nunsigned int port;\r\nint ret;\r\nret = bcm_sf2_sw_rst(priv);\r\nif (ret) {\r\npr_err("%s: failed to software reset switch\n", __func__);\r\nreturn ret;\r\n}\r\nif (priv->hw_params.num_gphy == 1)\r\nbcm_sf2_gphy_enable_set(ds, true);\r\nfor (port = 0; port < DSA_MAX_PORTS; port++) {\r\nif ((1 << port) & ds->phys_port_mask)\r\nbcm_sf2_port_setup(ds, port, NULL);\r\nelse if (dsa_is_cpu_port(ds, port))\r\nbcm_sf2_imp_setup(ds, port);\r\n}\r\nreturn 0;\r\n}\r\nstatic void bcm_sf2_sw_get_wol(struct dsa_switch *ds, int port,\r\nstruct ethtool_wolinfo *wol)\r\n{\r\nstruct net_device *p = ds->dst[ds->index].master_netdev;\r\nstruct bcm_sf2_priv *priv = ds_to_priv(ds);\r\nstruct ethtool_wolinfo pwol;\r\np->ethtool_ops->get_wol(p, &pwol);\r\nwol->supported = pwol.supported;\r\nmemset(&wol->sopass, 0, sizeof(wol->sopass));\r\nif (pwol.wolopts & WAKE_MAGICSECURE)\r\nmemcpy(&wol->sopass, pwol.sopass, sizeof(wol->sopass));\r\nif (priv->wol_ports_mask & (1 << port))\r\nwol->wolopts = pwol.wolopts;\r\nelse\r\nwol->wolopts = 0;\r\n}\r\nstatic int bcm_sf2_sw_set_wol(struct dsa_switch *ds, int port,\r\nstruct ethtool_wolinfo *wol)\r\n{\r\nstruct net_device *p = ds->dst[ds->index].master_netdev;\r\nstruct bcm_sf2_priv *priv = ds_to_priv(ds);\r\ns8 cpu_port = ds->dst[ds->index].cpu_port;\r\nstruct ethtool_wolinfo pwol;\r\np->ethtool_ops->get_wol(p, &pwol);\r\nif (wol->wolopts & ~pwol.supported)\r\nreturn -EINVAL;\r\nif (wol->wolopts)\r\npriv->wol_ports_mask |= (1 << port);\r\nelse\r\npriv->wol_ports_mask &= ~(1 << port);\r\nif (priv->wol_ports_mask && priv->wol_ports_mask != (1 << cpu_port))\r\npriv->wol_ports_mask |= (1 << cpu_port);\r\nelse\r\npriv->wol_ports_mask &= ~(1 << cpu_port);\r\nreturn p->ethtool_ops->set_wol(p, wol);\r\n}\r\nstatic int __init bcm_sf2_init(void)\r\n{\r\nregister_switch_driver(&bcm_sf2_switch_driver);\r\nreturn 0;\r\n}\r\nstatic void __exit bcm_sf2_exit(void)\r\n{\r\nunregister_switch_driver(&bcm_sf2_switch_driver);\r\n}
