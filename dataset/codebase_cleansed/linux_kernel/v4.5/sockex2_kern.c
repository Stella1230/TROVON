static inline int proto_ports_offset(__u64 proto)\r\n{\r\nswitch (proto) {\r\ncase IPPROTO_TCP:\r\ncase IPPROTO_UDP:\r\ncase IPPROTO_DCCP:\r\ncase IPPROTO_ESP:\r\ncase IPPROTO_SCTP:\r\ncase IPPROTO_UDPLITE:\r\nreturn 0;\r\ncase IPPROTO_AH:\r\nreturn 4;\r\ndefault:\r\nreturn 0;\r\n}\r\n}\r\nstatic inline int ip_is_fragment(struct __sk_buff *ctx, __u64 nhoff)\r\n{\r\nreturn load_half(ctx, nhoff + offsetof(struct iphdr, frag_off))\r\n& (IP_MF | IP_OFFSET);\r\n}\r\nstatic inline __u32 ipv6_addr_hash(struct __sk_buff *ctx, __u64 off)\r\n{\r\n__u64 w0 = load_word(ctx, off);\r\n__u64 w1 = load_word(ctx, off + 4);\r\n__u64 w2 = load_word(ctx, off + 8);\r\n__u64 w3 = load_word(ctx, off + 12);\r\nreturn (__u32)(w0 ^ w1 ^ w2 ^ w3);\r\n}\r\nstatic inline __u64 parse_ip(struct __sk_buff *skb, __u64 nhoff, __u64 *ip_proto,\r\nstruct flow_keys *flow)\r\n{\r\n__u64 verlen;\r\nif (unlikely(ip_is_fragment(skb, nhoff)))\r\n*ip_proto = 0;\r\nelse\r\n*ip_proto = load_byte(skb, nhoff + offsetof(struct iphdr, protocol));\r\nif (*ip_proto != IPPROTO_GRE) {\r\nflow->src = load_word(skb, nhoff + offsetof(struct iphdr, saddr));\r\nflow->dst = load_word(skb, nhoff + offsetof(struct iphdr, daddr));\r\n}\r\nverlen = load_byte(skb, nhoff + 0);\r\nif (likely(verlen == 0x45))\r\nnhoff += 20;\r\nelse\r\nnhoff += (verlen & 0xF) << 2;\r\nreturn nhoff;\r\n}\r\nstatic inline __u64 parse_ipv6(struct __sk_buff *skb, __u64 nhoff, __u64 *ip_proto,\r\nstruct flow_keys *flow)\r\n{\r\n*ip_proto = load_byte(skb,\r\nnhoff + offsetof(struct ipv6hdr, nexthdr));\r\nflow->src = ipv6_addr_hash(skb,\r\nnhoff + offsetof(struct ipv6hdr, saddr));\r\nflow->dst = ipv6_addr_hash(skb,\r\nnhoff + offsetof(struct ipv6hdr, daddr));\r\nnhoff += sizeof(struct ipv6hdr);\r\nreturn nhoff;\r\n}\r\nstatic inline bool flow_dissector(struct __sk_buff *skb, struct flow_keys *flow)\r\n{\r\n__u64 nhoff = ETH_HLEN;\r\n__u64 ip_proto;\r\n__u64 proto = load_half(skb, 12);\r\nint poff;\r\nif (proto == ETH_P_8021AD) {\r\nproto = load_half(skb, nhoff + offsetof(struct vlan_hdr,\r\nh_vlan_encapsulated_proto));\r\nnhoff += sizeof(struct vlan_hdr);\r\n}\r\nif (proto == ETH_P_8021Q) {\r\nproto = load_half(skb, nhoff + offsetof(struct vlan_hdr,\r\nh_vlan_encapsulated_proto));\r\nnhoff += sizeof(struct vlan_hdr);\r\n}\r\nif (likely(proto == ETH_P_IP))\r\nnhoff = parse_ip(skb, nhoff, &ip_proto, flow);\r\nelse if (proto == ETH_P_IPV6)\r\nnhoff = parse_ipv6(skb, nhoff, &ip_proto, flow);\r\nelse\r\nreturn false;\r\nswitch (ip_proto) {\r\ncase IPPROTO_GRE: {\r\nstruct gre_hdr {\r\n__be16 flags;\r\n__be16 proto;\r\n};\r\n__u64 gre_flags = load_half(skb,\r\nnhoff + offsetof(struct gre_hdr, flags));\r\n__u64 gre_proto = load_half(skb,\r\nnhoff + offsetof(struct gre_hdr, proto));\r\nif (gre_flags & (GRE_VERSION|GRE_ROUTING))\r\nbreak;\r\nproto = gre_proto;\r\nnhoff += 4;\r\nif (gre_flags & GRE_CSUM)\r\nnhoff += 4;\r\nif (gre_flags & GRE_KEY)\r\nnhoff += 4;\r\nif (gre_flags & GRE_SEQ)\r\nnhoff += 4;\r\nif (proto == ETH_P_8021Q) {\r\nproto = load_half(skb,\r\nnhoff + offsetof(struct vlan_hdr,\r\nh_vlan_encapsulated_proto));\r\nnhoff += sizeof(struct vlan_hdr);\r\n}\r\nif (proto == ETH_P_IP)\r\nnhoff = parse_ip(skb, nhoff, &ip_proto, flow);\r\nelse if (proto == ETH_P_IPV6)\r\nnhoff = parse_ipv6(skb, nhoff, &ip_proto, flow);\r\nelse\r\nreturn false;\r\nbreak;\r\n}\r\ncase IPPROTO_IPIP:\r\nnhoff = parse_ip(skb, nhoff, &ip_proto, flow);\r\nbreak;\r\ncase IPPROTO_IPV6:\r\nnhoff = parse_ipv6(skb, nhoff, &ip_proto, flow);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nflow->ip_proto = ip_proto;\r\npoff = proto_ports_offset(ip_proto);\r\nif (poff >= 0) {\r\nnhoff += poff;\r\nflow->ports = load_word(skb, nhoff);\r\n}\r\nflow->thoff = (__u16) nhoff;\r\nreturn true;\r\n}\r\nint bpf_prog2(struct __sk_buff *skb)\r\n{\r\nstruct flow_keys flow;\r\nstruct pair *value;\r\nu32 key;\r\nif (!flow_dissector(skb, &flow))\r\nreturn 0;\r\nkey = flow.dst;\r\nvalue = bpf_map_lookup_elem(&hash_map, &key);\r\nif (value) {\r\n__sync_fetch_and_add(&value->packets, 1);\r\n__sync_fetch_and_add(&value->bytes, skb->len);\r\n} else {\r\nstruct pair val = {1, skb->len};\r\nbpf_map_update_elem(&hash_map, &key, &val, BPF_ANY);\r\n}\r\nreturn 0;\r\n}
