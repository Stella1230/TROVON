static int dw210x_op_rw(struct usb_device *dev, u8 request, u16 value,\r\nu16 index, u8 * data, u16 len, int flags)\r\n{\r\nint ret;\r\nu8 *u8buf;\r\nunsigned int pipe = (flags == DW210X_READ_MSG) ?\r\nusb_rcvctrlpipe(dev, 0) : usb_sndctrlpipe(dev, 0);\r\nu8 request_type = (flags == DW210X_READ_MSG) ? USB_DIR_IN : USB_DIR_OUT;\r\nu8buf = kmalloc(len, GFP_KERNEL);\r\nif (!u8buf)\r\nreturn -ENOMEM;\r\nif (flags == DW210X_WRITE_MSG)\r\nmemcpy(u8buf, data, len);\r\nret = usb_control_msg(dev, pipe, request, request_type | USB_TYPE_VENDOR,\r\nvalue, index , u8buf, len, 2000);\r\nif (flags == DW210X_READ_MSG)\r\nmemcpy(data, u8buf, len);\r\nkfree(u8buf);\r\nreturn ret;\r\n}\r\nstatic int dw2102_i2c_transfer(struct i2c_adapter *adap, struct i2c_msg msg[],\r\nint num)\r\n{\r\nstruct dvb_usb_device *d = i2c_get_adapdata(adap);\r\nint i = 0;\r\nu8 buf6[] = {0x2c, 0x05, 0xc0, 0, 0, 0, 0};\r\nu16 value;\r\nif (!d)\r\nreturn -ENODEV;\r\nif (mutex_lock_interruptible(&d->i2c_mutex) < 0)\r\nreturn -EAGAIN;\r\nswitch (num) {\r\ncase 2:\r\nvalue = msg[0].buf[0];\r\nfor (i = 0; i < msg[1].len; i++) {\r\ndw210x_op_rw(d->udev, 0xb5, value + i, 0,\r\nbuf6, 2, DW210X_READ_MSG);\r\nmsg[1].buf[i] = buf6[0];\r\n}\r\nbreak;\r\ncase 1:\r\nswitch (msg[0].addr) {\r\ncase 0x68:\r\nbuf6[0] = 0x2a;\r\nbuf6[1] = msg[0].buf[0];\r\nbuf6[2] = msg[0].buf[1];\r\ndw210x_op_rw(d->udev, 0xb2, 0, 0,\r\nbuf6, 3, DW210X_WRITE_MSG);\r\nbreak;\r\ncase 0x60:\r\nif (msg[0].flags == 0) {\r\nbuf6[0] = 0x2c;\r\nbuf6[1] = 5;\r\nbuf6[2] = 0xc0;\r\nbuf6[3] = msg[0].buf[0];\r\nbuf6[4] = msg[0].buf[1];\r\nbuf6[5] = msg[0].buf[2];\r\nbuf6[6] = msg[0].buf[3];\r\ndw210x_op_rw(d->udev, 0xb2, 0, 0,\r\nbuf6, 7, DW210X_WRITE_MSG);\r\n} else {\r\ndw210x_op_rw(d->udev, 0xb5, 0, 0,\r\nbuf6, 1, DW210X_READ_MSG);\r\nmsg[0].buf[0] = buf6[0];\r\n}\r\nbreak;\r\ncase (DW2102_RC_QUERY):\r\ndw210x_op_rw(d->udev, 0xb8, 0, 0,\r\nbuf6, 2, DW210X_READ_MSG);\r\nmsg[0].buf[0] = buf6[0];\r\nmsg[0].buf[1] = buf6[1];\r\nbreak;\r\ncase (DW2102_VOLTAGE_CTRL):\r\nbuf6[0] = 0x30;\r\nbuf6[1] = msg[0].buf[0];\r\ndw210x_op_rw(d->udev, 0xb2, 0, 0,\r\nbuf6, 2, DW210X_WRITE_MSG);\r\nbreak;\r\n}\r\nbreak;\r\n}\r\nmutex_unlock(&d->i2c_mutex);\r\nreturn num;\r\n}\r\nstatic int dw2102_serit_i2c_transfer(struct i2c_adapter *adap,\r\nstruct i2c_msg msg[], int num)\r\n{\r\nstruct dvb_usb_device *d = i2c_get_adapdata(adap);\r\nu8 buf6[] = {0, 0, 0, 0, 0, 0, 0};\r\nif (!d)\r\nreturn -ENODEV;\r\nif (mutex_lock_interruptible(&d->i2c_mutex) < 0)\r\nreturn -EAGAIN;\r\nswitch (num) {\r\ncase 2:\r\nbuf6[0] = msg[0].addr << 1;\r\nbuf6[1] = msg[0].len;\r\nbuf6[2] = msg[0].buf[0];\r\ndw210x_op_rw(d->udev, 0xc2, 0, 0,\r\nbuf6, msg[0].len + 2, DW210X_WRITE_MSG);\r\ndw210x_op_rw(d->udev, 0xc3, 0xd0, 0,\r\nbuf6, msg[1].len + 2, DW210X_READ_MSG);\r\nmemcpy(msg[1].buf, buf6 + 2, msg[1].len);\r\nbreak;\r\ncase 1:\r\nswitch (msg[0].addr) {\r\ncase 0x68:\r\nbuf6[0] = msg[0].addr << 1;\r\nbuf6[1] = msg[0].len;\r\nmemcpy(buf6 + 2, msg[0].buf, msg[0].len);\r\ndw210x_op_rw(d->udev, 0xc2, 0, 0, buf6,\r\nmsg[0].len + 2, DW210X_WRITE_MSG);\r\nbreak;\r\ncase(DW2102_RC_QUERY):\r\ndw210x_op_rw(d->udev, 0xb8, 0, 0,\r\nbuf6, 2, DW210X_READ_MSG);\r\nmsg[0].buf[0] = buf6[0];\r\nmsg[0].buf[1] = buf6[1];\r\nbreak;\r\ncase(DW2102_VOLTAGE_CTRL):\r\nbuf6[0] = 0x30;\r\nbuf6[1] = msg[0].buf[0];\r\ndw210x_op_rw(d->udev, 0xb2, 0, 0,\r\nbuf6, 2, DW210X_WRITE_MSG);\r\nbreak;\r\n}\r\nbreak;\r\n}\r\nmutex_unlock(&d->i2c_mutex);\r\nreturn num;\r\n}\r\nstatic int dw2102_earda_i2c_transfer(struct i2c_adapter *adap, struct i2c_msg msg[], int num)\r\n{\r\nstruct dvb_usb_device *d = i2c_get_adapdata(adap);\r\nint ret;\r\nif (!d)\r\nreturn -ENODEV;\r\nif (mutex_lock_interruptible(&d->i2c_mutex) < 0)\r\nreturn -EAGAIN;\r\nswitch (num) {\r\ncase 2: {\r\nu8 ibuf[MAX_XFER_SIZE], obuf[3];\r\nif (2 + msg[1].len > sizeof(ibuf)) {\r\nwarn("i2c rd: len=%d is too big!\n",\r\nmsg[1].len);\r\nret = -EOPNOTSUPP;\r\ngoto unlock;\r\n}\r\nobuf[0] = msg[0].addr << 1;\r\nobuf[1] = msg[0].len;\r\nobuf[2] = msg[0].buf[0];\r\ndw210x_op_rw(d->udev, 0xc2, 0, 0,\r\nobuf, msg[0].len + 2, DW210X_WRITE_MSG);\r\ndw210x_op_rw(d->udev, 0xc3, 0xd1 , 0,\r\nibuf, msg[1].len + 2, DW210X_READ_MSG);\r\nmemcpy(msg[1].buf, ibuf + 2, msg[1].len);\r\nbreak;\r\n}\r\ncase 1:\r\nswitch (msg[0].addr) {\r\ncase 0x68: {\r\nu8 obuf[MAX_XFER_SIZE];\r\nif (2 + msg[0].len > sizeof(obuf)) {\r\nwarn("i2c wr: len=%d is too big!\n",\r\nmsg[1].len);\r\nret = -EOPNOTSUPP;\r\ngoto unlock;\r\n}\r\nobuf[0] = msg[0].addr << 1;\r\nobuf[1] = msg[0].len;\r\nmemcpy(obuf + 2, msg[0].buf, msg[0].len);\r\ndw210x_op_rw(d->udev, 0xc2, 0, 0,\r\nobuf, msg[0].len + 2, DW210X_WRITE_MSG);\r\nbreak;\r\n}\r\ncase 0x61: {\r\nu8 obuf[MAX_XFER_SIZE];\r\nif (2 + msg[0].len > sizeof(obuf)) {\r\nwarn("i2c wr: len=%d is too big!\n",\r\nmsg[1].len);\r\nret = -EOPNOTSUPP;\r\ngoto unlock;\r\n}\r\nobuf[0] = msg[0].addr << 1;\r\nobuf[1] = msg[0].len;\r\nmemcpy(obuf + 2, msg[0].buf, msg[0].len);\r\ndw210x_op_rw(d->udev, 0xc2, 0, 0,\r\nobuf, msg[0].len + 2, DW210X_WRITE_MSG);\r\nbreak;\r\n}\r\ncase(DW2102_RC_QUERY): {\r\nu8 ibuf[2];\r\ndw210x_op_rw(d->udev, 0xb8, 0, 0,\r\nibuf, 2, DW210X_READ_MSG);\r\nmemcpy(msg[0].buf, ibuf , 2);\r\nbreak;\r\n}\r\ncase(DW2102_VOLTAGE_CTRL): {\r\nu8 obuf[2];\r\nobuf[0] = 0x30;\r\nobuf[1] = msg[0].buf[0];\r\ndw210x_op_rw(d->udev, 0xb2, 0, 0,\r\nobuf, 2, DW210X_WRITE_MSG);\r\nbreak;\r\n}\r\n}\r\nbreak;\r\n}\r\nret = num;\r\nunlock:\r\nmutex_unlock(&d->i2c_mutex);\r\nreturn ret;\r\n}\r\nstatic int dw2104_i2c_transfer(struct i2c_adapter *adap, struct i2c_msg msg[], int num)\r\n{\r\nstruct dvb_usb_device *d = i2c_get_adapdata(adap);\r\nint len, i, j, ret;\r\nif (!d)\r\nreturn -ENODEV;\r\nif (mutex_lock_interruptible(&d->i2c_mutex) < 0)\r\nreturn -EAGAIN;\r\nfor (j = 0; j < num; j++) {\r\nswitch (msg[j].addr) {\r\ncase(DW2102_RC_QUERY): {\r\nu8 ibuf[2];\r\ndw210x_op_rw(d->udev, 0xb8, 0, 0,\r\nibuf, 2, DW210X_READ_MSG);\r\nmemcpy(msg[j].buf, ibuf , 2);\r\nbreak;\r\n}\r\ncase(DW2102_VOLTAGE_CTRL): {\r\nu8 obuf[2];\r\nobuf[0] = 0x30;\r\nobuf[1] = msg[j].buf[0];\r\ndw210x_op_rw(d->udev, 0xb2, 0, 0,\r\nobuf, 2, DW210X_WRITE_MSG);\r\nbreak;\r\n}\r\ndefault: {\r\nif (msg[j].flags == I2C_M_RD) {\r\nu8 ibuf[MAX_XFER_SIZE];\r\nif (2 + msg[j].len > sizeof(ibuf)) {\r\nwarn("i2c rd: len=%d is too big!\n",\r\nmsg[j].len);\r\nret = -EOPNOTSUPP;\r\ngoto unlock;\r\n}\r\ndw210x_op_rw(d->udev, 0xc3,\r\n(msg[j].addr << 1) + 1, 0,\r\nibuf, msg[j].len + 2,\r\nDW210X_READ_MSG);\r\nmemcpy(msg[j].buf, ibuf + 2, msg[j].len);\r\nmdelay(10);\r\n} else if (((msg[j].buf[0] == 0xb0) &&\r\n(msg[j].addr == 0x68)) ||\r\n((msg[j].buf[0] == 0xf7) &&\r\n(msg[j].addr == 0x55))) {\r\nu8 obuf[19];\r\nobuf[0] = msg[j].addr << 1;\r\nobuf[1] = (msg[j].len > 15 ? 17 : msg[j].len);\r\nobuf[2] = msg[j].buf[0];\r\nlen = msg[j].len - 1;\r\ni = 1;\r\ndo {\r\nmemcpy(obuf + 3, msg[j].buf + i,\r\n(len > 16 ? 16 : len));\r\ndw210x_op_rw(d->udev, 0xc2, 0, 0,\r\nobuf, (len > 16 ? 16 : len) + 3,\r\nDW210X_WRITE_MSG);\r\ni += 16;\r\nlen -= 16;\r\n} while (len > 0);\r\n} else {\r\nu8 obuf[MAX_XFER_SIZE];\r\nif (2 + msg[j].len > sizeof(obuf)) {\r\nwarn("i2c wr: len=%d is too big!\n",\r\nmsg[j].len);\r\nret = -EOPNOTSUPP;\r\ngoto unlock;\r\n}\r\nobuf[0] = msg[j].addr << 1;\r\nobuf[1] = msg[j].len;\r\nmemcpy(obuf + 2, msg[j].buf, msg[j].len);\r\ndw210x_op_rw(d->udev, 0xc2, 0, 0,\r\nobuf, msg[j].len + 2,\r\nDW210X_WRITE_MSG);\r\n}\r\nbreak;\r\n}\r\n}\r\n}\r\nret = num;\r\nunlock:\r\nmutex_unlock(&d->i2c_mutex);\r\nreturn ret;\r\n}\r\nstatic int dw3101_i2c_transfer(struct i2c_adapter *adap, struct i2c_msg msg[],\r\nint num)\r\n{\r\nstruct dvb_usb_device *d = i2c_get_adapdata(adap);\r\nint ret;\r\nint i;\r\nif (!d)\r\nreturn -ENODEV;\r\nif (mutex_lock_interruptible(&d->i2c_mutex) < 0)\r\nreturn -EAGAIN;\r\nswitch (num) {\r\ncase 2: {\r\nu8 ibuf[MAX_XFER_SIZE], obuf[3];\r\nif (2 + msg[1].len > sizeof(ibuf)) {\r\nwarn("i2c rd: len=%d is too big!\n",\r\nmsg[1].len);\r\nret = -EOPNOTSUPP;\r\ngoto unlock;\r\n}\r\nobuf[0] = msg[0].addr << 1;\r\nobuf[1] = msg[0].len;\r\nobuf[2] = msg[0].buf[0];\r\ndw210x_op_rw(d->udev, 0xc2, 0, 0,\r\nobuf, msg[0].len + 2, DW210X_WRITE_MSG);\r\ndw210x_op_rw(d->udev, 0xc3, 0x19 , 0,\r\nibuf, msg[1].len + 2, DW210X_READ_MSG);\r\nmemcpy(msg[1].buf, ibuf + 2, msg[1].len);\r\nbreak;\r\n}\r\ncase 1:\r\nswitch (msg[0].addr) {\r\ncase 0x60:\r\ncase 0x0c: {\r\nu8 obuf[MAX_XFER_SIZE];\r\nif (2 + msg[0].len > sizeof(obuf)) {\r\nwarn("i2c wr: len=%d is too big!\n",\r\nmsg[0].len);\r\nret = -EOPNOTSUPP;\r\ngoto unlock;\r\n}\r\nobuf[0] = msg[0].addr << 1;\r\nobuf[1] = msg[0].len;\r\nmemcpy(obuf + 2, msg[0].buf, msg[0].len);\r\ndw210x_op_rw(d->udev, 0xc2, 0, 0,\r\nobuf, msg[0].len + 2, DW210X_WRITE_MSG);\r\nbreak;\r\n}\r\ncase(DW2102_RC_QUERY): {\r\nu8 ibuf[2];\r\ndw210x_op_rw(d->udev, 0xb8, 0, 0,\r\nibuf, 2, DW210X_READ_MSG);\r\nmemcpy(msg[0].buf, ibuf , 2);\r\nbreak;\r\n}\r\n}\r\nbreak;\r\n}\r\nfor (i = 0; i < num; i++) {\r\ndeb_xfer("%02x:%02x: %s ", i, msg[i].addr,\r\nmsg[i].flags == 0 ? ">>>" : "<<<");\r\ndebug_dump(msg[i].buf, msg[i].len, deb_xfer);\r\n}\r\nret = num;\r\nunlock:\r\nmutex_unlock(&d->i2c_mutex);\r\nreturn ret;\r\n}\r\nstatic int s6x0_i2c_transfer(struct i2c_adapter *adap, struct i2c_msg msg[],\r\nint num)\r\n{\r\nstruct dvb_usb_device *d = i2c_get_adapdata(adap);\r\nstruct usb_device *udev;\r\nint len, i, j, ret;\r\nif (!d)\r\nreturn -ENODEV;\r\nudev = d->udev;\r\nif (mutex_lock_interruptible(&d->i2c_mutex) < 0)\r\nreturn -EAGAIN;\r\nfor (j = 0; j < num; j++) {\r\nswitch (msg[j].addr) {\r\ncase (DW2102_RC_QUERY): {\r\nu8 ibuf[5];\r\ndw210x_op_rw(d->udev, 0xb8, 0, 0,\r\nibuf, 5, DW210X_READ_MSG);\r\nmemcpy(msg[j].buf, ibuf + 3, 2);\r\nbreak;\r\n}\r\ncase (DW2102_VOLTAGE_CTRL): {\r\nu8 obuf[2];\r\nobuf[0] = 1;\r\nobuf[1] = msg[j].buf[1];\r\ndw210x_op_rw(d->udev, 0x8a, 0, 0,\r\nobuf, 2, DW210X_WRITE_MSG);\r\nobuf[0] = 3;\r\nobuf[1] = msg[j].buf[0];\r\ndw210x_op_rw(d->udev, 0x8a, 0, 0,\r\nobuf, 2, DW210X_WRITE_MSG);\r\nbreak;\r\n}\r\ncase (DW2102_LED_CTRL): {\r\nu8 obuf[2];\r\nobuf[0] = 5;\r\nobuf[1] = msg[j].buf[0];\r\ndw210x_op_rw(d->udev, 0x8a, 0, 0,\r\nobuf, 2, DW210X_WRITE_MSG);\r\nbreak;\r\n}\r\ndefault: {\r\nif (msg[j].flags == I2C_M_RD) {\r\nu8 ibuf[MAX_XFER_SIZE];\r\nif (msg[j].len > sizeof(ibuf)) {\r\nwarn("i2c rd: len=%d is too big!\n",\r\nmsg[j].len);\r\nret = -EOPNOTSUPP;\r\ngoto unlock;\r\n}\r\ndw210x_op_rw(d->udev, 0x91, 0, 0,\r\nibuf, msg[j].len,\r\nDW210X_READ_MSG);\r\nmemcpy(msg[j].buf, ibuf, msg[j].len);\r\nbreak;\r\n} else if ((msg[j].buf[0] == 0xb0) &&\r\n(msg[j].addr == 0x68)) {\r\nu8 obuf[19];\r\nobuf[0] = (msg[j].len > 16 ?\r\n18 : msg[j].len + 1);\r\nobuf[1] = msg[j].addr << 1;\r\nobuf[2] = msg[j].buf[0];\r\nlen = msg[j].len - 1;\r\ni = 1;\r\ndo {\r\nmemcpy(obuf + 3, msg[j].buf + i,\r\n(len > 16 ? 16 : len));\r\ndw210x_op_rw(d->udev, 0x80, 0, 0,\r\nobuf, (len > 16 ? 16 : len) + 3,\r\nDW210X_WRITE_MSG);\r\ni += 16;\r\nlen -= 16;\r\n} while (len > 0);\r\n} else if (j < (num - 1)) {\r\nu8 obuf[MAX_XFER_SIZE];\r\nif (2 + msg[j].len > sizeof(obuf)) {\r\nwarn("i2c wr: len=%d is too big!\n",\r\nmsg[j].len);\r\nret = -EOPNOTSUPP;\r\ngoto unlock;\r\n}\r\nobuf[0] = msg[j + 1].len;\r\nobuf[1] = (msg[j].addr << 1);\r\nmemcpy(obuf + 2, msg[j].buf, msg[j].len);\r\ndw210x_op_rw(d->udev,\r\nle16_to_cpu(udev->descriptor.idProduct) ==\r\n0x7500 ? 0x92 : 0x90, 0, 0,\r\nobuf, msg[j].len + 2,\r\nDW210X_WRITE_MSG);\r\nbreak;\r\n} else {\r\nu8 obuf[MAX_XFER_SIZE];\r\nif (2 + msg[j].len > sizeof(obuf)) {\r\nwarn("i2c wr: len=%d is too big!\n",\r\nmsg[j].len);\r\nret = -EOPNOTSUPP;\r\ngoto unlock;\r\n}\r\nobuf[0] = msg[j].len + 1;\r\nobuf[1] = (msg[j].addr << 1);\r\nmemcpy(obuf + 2, msg[j].buf, msg[j].len);\r\ndw210x_op_rw(d->udev, 0x80, 0, 0,\r\nobuf, msg[j].len + 2,\r\nDW210X_WRITE_MSG);\r\nbreak;\r\n}\r\nbreak;\r\n}\r\n}\r\n}\r\nret = num;\r\nunlock:\r\nmutex_unlock(&d->i2c_mutex);\r\nreturn ret;\r\n}\r\nstatic int su3000_i2c_transfer(struct i2c_adapter *adap, struct i2c_msg msg[],\r\nint num)\r\n{\r\nstruct dvb_usb_device *d = i2c_get_adapdata(adap);\r\nu8 obuf[0x40], ibuf[0x40];\r\nif (!d)\r\nreturn -ENODEV;\r\nif (mutex_lock_interruptible(&d->i2c_mutex) < 0)\r\nreturn -EAGAIN;\r\nswitch (num) {\r\ncase 1:\r\nswitch (msg[0].addr) {\r\ncase SU3000_STREAM_CTRL:\r\nobuf[0] = msg[0].buf[0] + 0x36;\r\nobuf[1] = 3;\r\nobuf[2] = 0;\r\nif (dvb_usb_generic_rw(d, obuf, 3, ibuf, 0, 0) < 0)\r\nerr("i2c transfer failed.");\r\nbreak;\r\ncase DW2102_RC_QUERY:\r\nobuf[0] = 0x10;\r\nif (dvb_usb_generic_rw(d, obuf, 1, ibuf, 2, 0) < 0)\r\nerr("i2c transfer failed.");\r\nmsg[0].buf[1] = ibuf[0];\r\nmsg[0].buf[0] = ibuf[1];\r\nbreak;\r\ndefault:\r\nobuf[0] = 0x08;\r\nobuf[1] = msg[0].addr;\r\nobuf[2] = msg[0].len;\r\nmemcpy(&obuf[3], msg[0].buf, msg[0].len);\r\nif (dvb_usb_generic_rw(d, obuf, msg[0].len + 3,\r\nibuf, 1, 0) < 0)\r\nerr("i2c transfer failed.");\r\n}\r\nbreak;\r\ncase 2:\r\nobuf[0] = 0x09;\r\nobuf[1] = msg[0].len;\r\nobuf[2] = msg[1].len;\r\nobuf[3] = msg[0].addr;\r\nmemcpy(&obuf[4], msg[0].buf, msg[0].len);\r\nif (dvb_usb_generic_rw(d, obuf, msg[0].len + 4,\r\nibuf, msg[1].len + 1, 0) < 0)\r\nerr("i2c transfer failed.");\r\nmemcpy(msg[1].buf, &ibuf[1], msg[1].len);\r\nbreak;\r\ndefault:\r\nwarn("more than 2 i2c messages at a time is not handled yet.");\r\nbreak;\r\n}\r\nmutex_unlock(&d->i2c_mutex);\r\nreturn num;\r\n}\r\nstatic u32 dw210x_i2c_func(struct i2c_adapter *adapter)\r\n{\r\nreturn I2C_FUNC_I2C;\r\n}\r\nstatic int dw210x_read_mac_address(struct dvb_usb_device *d, u8 mac[6])\r\n{\r\nint i;\r\nu8 ibuf[] = {0, 0};\r\nu8 eeprom[256], eepromline[16];\r\nfor (i = 0; i < 256; i++) {\r\nif (dw210x_op_rw(d->udev, 0xb6, 0xa0 , i, ibuf, 2, DW210X_READ_MSG) < 0) {\r\nerr("read eeprom failed.");\r\nreturn -1;\r\n} else {\r\neepromline[i%16] = ibuf[0];\r\neeprom[i] = ibuf[0];\r\n}\r\nif ((i % 16) == 15) {\r\ndeb_xfer("%02x: ", i - 15);\r\ndebug_dump(eepromline, 16, deb_xfer);\r\n}\r\n}\r\nmemcpy(mac, eeprom + 8, 6);\r\nreturn 0;\r\n}\r\nstatic int s6x0_read_mac_address(struct dvb_usb_device *d, u8 mac[6])\r\n{\r\nint i, ret;\r\nu8 ibuf[] = { 0 }, obuf[] = { 0 };\r\nu8 eeprom[256], eepromline[16];\r\nstruct i2c_msg msg[] = {\r\n{\r\n.addr = 0xa0 >> 1,\r\n.flags = 0,\r\n.buf = obuf,\r\n.len = 1,\r\n}, {\r\n.addr = 0xa0 >> 1,\r\n.flags = I2C_M_RD,\r\n.buf = ibuf,\r\n.len = 1,\r\n}\r\n};\r\nfor (i = 0; i < 256; i++) {\r\nobuf[0] = i;\r\nret = s6x0_i2c_transfer(&d->i2c_adap, msg, 2);\r\nif (ret != 2) {\r\nerr("read eeprom failed.");\r\nreturn -1;\r\n} else {\r\neepromline[i % 16] = ibuf[0];\r\neeprom[i] = ibuf[0];\r\n}\r\nif ((i % 16) == 15) {\r\ndeb_xfer("%02x: ", i - 15);\r\ndebug_dump(eepromline, 16, deb_xfer);\r\n}\r\n}\r\nmemcpy(mac, eeprom + 16, 6);\r\nreturn 0;\r\n}\r\nstatic int su3000_streaming_ctrl(struct dvb_usb_adapter *adap, int onoff)\r\n{\r\nstatic u8 command_start[] = {0x00};\r\nstatic u8 command_stop[] = {0x01};\r\nstruct i2c_msg msg = {\r\n.addr = SU3000_STREAM_CTRL,\r\n.flags = 0,\r\n.buf = onoff ? command_start : command_stop,\r\n.len = 1\r\n};\r\ni2c_transfer(&adap->dev->i2c_adap, &msg, 1);\r\nreturn 0;\r\n}\r\nstatic int su3000_power_ctrl(struct dvb_usb_device *d, int i)\r\n{\r\nstruct dw2102_state *state = (struct dw2102_state *)d->priv;\r\nu8 obuf[] = {0xde, 0};\r\ninfo("%s: %d, initialized %d\n", __func__, i, state->initialized);\r\nif (i && !state->initialized) {\r\nstate->initialized = 1;\r\ndvb_usb_generic_rw(d, obuf, 2, NULL, 0, 0);\r\n}\r\nreturn 0;\r\n}\r\nstatic int su3000_read_mac_address(struct dvb_usb_device *d, u8 mac[6])\r\n{\r\nint i;\r\nu8 obuf[] = { 0x1f, 0xf0 };\r\nu8 ibuf[] = { 0 };\r\nstruct i2c_msg msg[] = {\r\n{\r\n.addr = 0x51,\r\n.flags = 0,\r\n.buf = obuf,\r\n.len = 2,\r\n}, {\r\n.addr = 0x51,\r\n.flags = I2C_M_RD,\r\n.buf = ibuf,\r\n.len = 1,\r\n}\r\n};\r\nfor (i = 0; i < 6; i++) {\r\nobuf[1] = 0xf0 + i;\r\nif (i2c_transfer(&d->i2c_adap, msg, 2) != 2)\r\nbreak;\r\nelse\r\nmac[i] = ibuf[0];\r\n}\r\nreturn 0;\r\n}\r\nstatic int su3000_identify_state(struct usb_device *udev,\r\nstruct dvb_usb_device_properties *props,\r\nstruct dvb_usb_device_description **desc,\r\nint *cold)\r\n{\r\ninfo("%s\n", __func__);\r\n*cold = 0;\r\nreturn 0;\r\n}\r\nstatic int dw210x_set_voltage(struct dvb_frontend *fe,\r\nenum fe_sec_voltage voltage)\r\n{\r\nstatic u8 command_13v[] = {0x00, 0x01};\r\nstatic u8 command_18v[] = {0x01, 0x01};\r\nstatic u8 command_off[] = {0x00, 0x00};\r\nstruct i2c_msg msg = {\r\n.addr = DW2102_VOLTAGE_CTRL,\r\n.flags = 0,\r\n.buf = command_off,\r\n.len = 2,\r\n};\r\nstruct dvb_usb_adapter *udev_adap =\r\n(struct dvb_usb_adapter *)(fe->dvb->priv);\r\nif (voltage == SEC_VOLTAGE_18)\r\nmsg.buf = command_18v;\r\nelse if (voltage == SEC_VOLTAGE_13)\r\nmsg.buf = command_13v;\r\ni2c_transfer(&udev_adap->dev->i2c_adap, &msg, 1);\r\nreturn 0;\r\n}\r\nstatic int s660_set_voltage(struct dvb_frontend *fe,\r\nenum fe_sec_voltage voltage)\r\n{\r\nstruct dvb_usb_adapter *d =\r\n(struct dvb_usb_adapter *)(fe->dvb->priv);\r\nstruct dw2102_state *st = (struct dw2102_state *)d->dev->priv;\r\ndw210x_set_voltage(fe, voltage);\r\nif (st->old_set_voltage)\r\nst->old_set_voltage(fe, voltage);\r\nreturn 0;\r\n}\r\nstatic void dw210x_led_ctrl(struct dvb_frontend *fe, int offon)\r\n{\r\nstatic u8 led_off[] = { 0 };\r\nstatic u8 led_on[] = { 1 };\r\nstruct i2c_msg msg = {\r\n.addr = DW2102_LED_CTRL,\r\n.flags = 0,\r\n.buf = led_off,\r\n.len = 1\r\n};\r\nstruct dvb_usb_adapter *udev_adap =\r\n(struct dvb_usb_adapter *)(fe->dvb->priv);\r\nif (offon)\r\nmsg.buf = led_on;\r\ni2c_transfer(&udev_adap->dev->i2c_adap, &msg, 1);\r\n}\r\nstatic int tt_s2_4600_read_status(struct dvb_frontend *fe,\r\nenum fe_status *status)\r\n{\r\nstruct dvb_usb_adapter *d =\r\n(struct dvb_usb_adapter *)(fe->dvb->priv);\r\nstruct dw2102_state *st = (struct dw2102_state *)d->dev->priv;\r\nint ret;\r\nret = st->fe_read_status(fe, status);\r\nif ((*status & FE_HAS_LOCK) && (!st->last_lock))\r\nsu3000_streaming_ctrl(d, 1);\r\nst->last_lock = (*status & FE_HAS_LOCK) ? 1 : 0;\r\nreturn ret;\r\n}\r\nstatic int dw2104_frontend_attach(struct dvb_usb_adapter *d)\r\n{\r\nstruct dvb_tuner_ops *tuner_ops = NULL;\r\nif (demod_probe & 4) {\r\nd->fe_adap[0].fe = dvb_attach(stv0900_attach, &dw2104a_stv0900_config,\r\n&d->dev->i2c_adap, 0);\r\nif (d->fe_adap[0].fe != NULL) {\r\nif (dvb_attach(stb6100_attach, d->fe_adap[0].fe,\r\n&dw2104a_stb6100_config,\r\n&d->dev->i2c_adap)) {\r\ntuner_ops = &d->fe_adap[0].fe->ops.tuner_ops;\r\ntuner_ops->set_frequency = stb6100_set_freq;\r\ntuner_ops->get_frequency = stb6100_get_freq;\r\ntuner_ops->set_bandwidth = stb6100_set_bandw;\r\ntuner_ops->get_bandwidth = stb6100_get_bandw;\r\nd->fe_adap[0].fe->ops.set_voltage = dw210x_set_voltage;\r\ninfo("Attached STV0900+STB6100!\n");\r\nreturn 0;\r\n}\r\n}\r\n}\r\nif (demod_probe & 2) {\r\nd->fe_adap[0].fe = dvb_attach(stv0900_attach, &dw2104_stv0900_config,\r\n&d->dev->i2c_adap, 0);\r\nif (d->fe_adap[0].fe != NULL) {\r\nif (dvb_attach(stv6110_attach, d->fe_adap[0].fe,\r\n&dw2104_stv6110_config,\r\n&d->dev->i2c_adap)) {\r\nd->fe_adap[0].fe->ops.set_voltage = dw210x_set_voltage;\r\ninfo("Attached STV0900+STV6110A!\n");\r\nreturn 0;\r\n}\r\n}\r\n}\r\nif (demod_probe & 1) {\r\nd->fe_adap[0].fe = dvb_attach(cx24116_attach, &dw2104_config,\r\n&d->dev->i2c_adap);\r\nif (d->fe_adap[0].fe != NULL) {\r\nd->fe_adap[0].fe->ops.set_voltage = dw210x_set_voltage;\r\ninfo("Attached cx24116!\n");\r\nreturn 0;\r\n}\r\n}\r\nd->fe_adap[0].fe = dvb_attach(ds3000_attach, &dw2104_ds3000_config,\r\n&d->dev->i2c_adap);\r\nif (d->fe_adap[0].fe != NULL) {\r\ndvb_attach(ts2020_attach, d->fe_adap[0].fe,\r\n&dw2104_ts2020_config, &d->dev->i2c_adap);\r\nd->fe_adap[0].fe->ops.set_voltage = dw210x_set_voltage;\r\ninfo("Attached DS3000!\n");\r\nreturn 0;\r\n}\r\nreturn -EIO;\r\n}\r\nstatic int dw2102_frontend_attach(struct dvb_usb_adapter *d)\r\n{\r\nif (dw2102_properties.i2c_algo == &dw2102_serit_i2c_algo) {\r\nd->fe_adap[0].fe = dvb_attach(si21xx_attach, &serit_sp1511lhb_config,\r\n&d->dev->i2c_adap);\r\nif (d->fe_adap[0].fe != NULL) {\r\nd->fe_adap[0].fe->ops.set_voltage = dw210x_set_voltage;\r\ninfo("Attached si21xx!\n");\r\nreturn 0;\r\n}\r\n}\r\nif (dw2102_properties.i2c_algo == &dw2102_earda_i2c_algo) {\r\nd->fe_adap[0].fe = dvb_attach(stv0288_attach, &earda_config,\r\n&d->dev->i2c_adap);\r\nif (d->fe_adap[0].fe != NULL) {\r\nif (dvb_attach(stb6000_attach, d->fe_adap[0].fe, 0x61,\r\n&d->dev->i2c_adap)) {\r\nd->fe_adap[0].fe->ops.set_voltage = dw210x_set_voltage;\r\ninfo("Attached stv0288!\n");\r\nreturn 0;\r\n}\r\n}\r\n}\r\nif (dw2102_properties.i2c_algo == &dw2102_i2c_algo) {\r\nd->fe_adap[0].fe = dvb_attach(stv0299_attach, &sharp_z0194a_config,\r\n&d->dev->i2c_adap);\r\nif (d->fe_adap[0].fe != NULL) {\r\nd->fe_adap[0].fe->ops.set_voltage = dw210x_set_voltage;\r\ninfo("Attached stv0299!\n");\r\nreturn 0;\r\n}\r\n}\r\nreturn -EIO;\r\n}\r\nstatic int dw3101_frontend_attach(struct dvb_usb_adapter *d)\r\n{\r\nd->fe_adap[0].fe = dvb_attach(tda10023_attach, &dw3101_tda10023_config,\r\n&d->dev->i2c_adap, 0x48);\r\nif (d->fe_adap[0].fe != NULL) {\r\ninfo("Attached tda10023!\n");\r\nreturn 0;\r\n}\r\nreturn -EIO;\r\n}\r\nstatic int zl100313_frontend_attach(struct dvb_usb_adapter *d)\r\n{\r\nd->fe_adap[0].fe = dvb_attach(mt312_attach, &zl313_config,\r\n&d->dev->i2c_adap);\r\nif (d->fe_adap[0].fe != NULL) {\r\nif (dvb_attach(zl10039_attach, d->fe_adap[0].fe, 0x60,\r\n&d->dev->i2c_adap)) {\r\nd->fe_adap[0].fe->ops.set_voltage = dw210x_set_voltage;\r\ninfo("Attached zl100313+zl10039!\n");\r\nreturn 0;\r\n}\r\n}\r\nreturn -EIO;\r\n}\r\nstatic int stv0288_frontend_attach(struct dvb_usb_adapter *d)\r\n{\r\nu8 obuf[] = {7, 1};\r\nd->fe_adap[0].fe = dvb_attach(stv0288_attach, &earda_config,\r\n&d->dev->i2c_adap);\r\nif (d->fe_adap[0].fe == NULL)\r\nreturn -EIO;\r\nif (NULL == dvb_attach(stb6000_attach, d->fe_adap[0].fe, 0x61, &d->dev->i2c_adap))\r\nreturn -EIO;\r\nd->fe_adap[0].fe->ops.set_voltage = dw210x_set_voltage;\r\ndw210x_op_rw(d->dev->udev, 0x8a, 0, 0, obuf, 2, DW210X_WRITE_MSG);\r\ninfo("Attached stv0288+stb6000!\n");\r\nreturn 0;\r\n}\r\nstatic int ds3000_frontend_attach(struct dvb_usb_adapter *d)\r\n{\r\nstruct dw2102_state *st = d->dev->priv;\r\nu8 obuf[] = {7, 1};\r\nd->fe_adap[0].fe = dvb_attach(ds3000_attach, &s660_ds3000_config,\r\n&d->dev->i2c_adap);\r\nif (d->fe_adap[0].fe == NULL)\r\nreturn -EIO;\r\ndvb_attach(ts2020_attach, d->fe_adap[0].fe, &s660_ts2020_config,\r\n&d->dev->i2c_adap);\r\nst->old_set_voltage = d->fe_adap[0].fe->ops.set_voltage;\r\nd->fe_adap[0].fe->ops.set_voltage = s660_set_voltage;\r\ndw210x_op_rw(d->dev->udev, 0x8a, 0, 0, obuf, 2, DW210X_WRITE_MSG);\r\ninfo("Attached ds3000+ts2020!\n");\r\nreturn 0;\r\n}\r\nstatic int prof_7500_frontend_attach(struct dvb_usb_adapter *d)\r\n{\r\nu8 obuf[] = {7, 1};\r\nd->fe_adap[0].fe = dvb_attach(stv0900_attach, &prof_7500_stv0900_config,\r\n&d->dev->i2c_adap, 0);\r\nif (d->fe_adap[0].fe == NULL)\r\nreturn -EIO;\r\nd->fe_adap[0].fe->ops.set_voltage = dw210x_set_voltage;\r\ndw210x_op_rw(d->dev->udev, 0x8a, 0, 0, obuf, 2, DW210X_WRITE_MSG);\r\ninfo("Attached STV0900+STB6100A!\n");\r\nreturn 0;\r\n}\r\nstatic int su3000_frontend_attach(struct dvb_usb_adapter *d)\r\n{\r\nu8 obuf[3] = { 0xe, 0x80, 0 };\r\nu8 ibuf[] = { 0 };\r\nif (dvb_usb_generic_rw(d->dev, obuf, 3, ibuf, 1, 0) < 0)\r\nerr("command 0x0e transfer failed.");\r\nobuf[0] = 0xe;\r\nobuf[1] = 0x02;\r\nobuf[2] = 1;\r\nif (dvb_usb_generic_rw(d->dev, obuf, 3, ibuf, 1, 0) < 0)\r\nerr("command 0x0e transfer failed.");\r\nmsleep(300);\r\nobuf[0] = 0xe;\r\nobuf[1] = 0x83;\r\nobuf[2] = 0;\r\nif (dvb_usb_generic_rw(d->dev, obuf, 3, ibuf, 1, 0) < 0)\r\nerr("command 0x0e transfer failed.");\r\nobuf[0] = 0xe;\r\nobuf[1] = 0x83;\r\nobuf[2] = 1;\r\nif (dvb_usb_generic_rw(d->dev, obuf, 3, ibuf, 1, 0) < 0)\r\nerr("command 0x0e transfer failed.");\r\nobuf[0] = 0x51;\r\nif (dvb_usb_generic_rw(d->dev, obuf, 1, ibuf, 1, 0) < 0)\r\nerr("command 0x51 transfer failed.");\r\nd->fe_adap[0].fe = dvb_attach(ds3000_attach, &su3000_ds3000_config,\r\n&d->dev->i2c_adap);\r\nif (d->fe_adap[0].fe == NULL)\r\nreturn -EIO;\r\nif (dvb_attach(ts2020_attach, d->fe_adap[0].fe,\r\n&dw2104_ts2020_config,\r\n&d->dev->i2c_adap)) {\r\ninfo("Attached DS3000/TS2020!\n");\r\nreturn 0;\r\n}\r\ninfo("Failed to attach DS3000/TS2020!\n");\r\nreturn -EIO;\r\n}\r\nstatic int t220_frontend_attach(struct dvb_usb_adapter *d)\r\n{\r\nu8 obuf[3] = { 0xe, 0x87, 0 };\r\nu8 ibuf[] = { 0 };\r\nif (dvb_usb_generic_rw(d->dev, obuf, 3, ibuf, 1, 0) < 0)\r\nerr("command 0x0e transfer failed.");\r\nobuf[0] = 0xe;\r\nobuf[1] = 0x86;\r\nobuf[2] = 1;\r\nif (dvb_usb_generic_rw(d->dev, obuf, 3, ibuf, 1, 0) < 0)\r\nerr("command 0x0e transfer failed.");\r\nobuf[0] = 0xe;\r\nobuf[1] = 0x80;\r\nobuf[2] = 0;\r\nif (dvb_usb_generic_rw(d->dev, obuf, 3, ibuf, 1, 0) < 0)\r\nerr("command 0x0e transfer failed.");\r\nmsleep(50);\r\nobuf[0] = 0xe;\r\nobuf[1] = 0x80;\r\nobuf[2] = 1;\r\nif (dvb_usb_generic_rw(d->dev, obuf, 3, ibuf, 1, 0) < 0)\r\nerr("command 0x0e transfer failed.");\r\nobuf[0] = 0x51;\r\nif (dvb_usb_generic_rw(d->dev, obuf, 1, ibuf, 1, 0) < 0)\r\nerr("command 0x51 transfer failed.");\r\nd->fe_adap[0].fe = dvb_attach(cxd2820r_attach, &cxd2820r_config,\r\n&d->dev->i2c_adap, NULL);\r\nif (d->fe_adap[0].fe != NULL) {\r\nif (dvb_attach(tda18271_attach, d->fe_adap[0].fe, 0x60,\r\n&d->dev->i2c_adap, &tda18271_config)) {\r\ninfo("Attached TDA18271HD/CXD2820R!\n");\r\nreturn 0;\r\n}\r\n}\r\ninfo("Failed to attach TDA18271HD/CXD2820R!\n");\r\nreturn -EIO;\r\n}\r\nstatic int m88rs2000_frontend_attach(struct dvb_usb_adapter *d)\r\n{\r\nu8 obuf[] = { 0x51 };\r\nu8 ibuf[] = { 0 };\r\nif (dvb_usb_generic_rw(d->dev, obuf, 1, ibuf, 1, 0) < 0)\r\nerr("command 0x51 transfer failed.");\r\nd->fe_adap[0].fe = dvb_attach(m88rs2000_attach, &s421_m88rs2000_config,\r\n&d->dev->i2c_adap);\r\nif (d->fe_adap[0].fe == NULL)\r\nreturn -EIO;\r\nif (dvb_attach(ts2020_attach, d->fe_adap[0].fe,\r\n&dw2104_ts2020_config,\r\n&d->dev->i2c_adap)) {\r\ninfo("Attached RS2000/TS2020!\n");\r\nreturn 0;\r\n}\r\ninfo("Failed to attach RS2000/TS2020!\n");\r\nreturn -EIO;\r\n}\r\nstatic int tt_s2_4600_frontend_attach(struct dvb_usb_adapter *adap)\r\n{\r\nstruct dvb_usb_device *d = adap->dev;\r\nstruct dw2102_state *state = d->priv;\r\nu8 obuf[3] = { 0xe, 0x80, 0 };\r\nu8 ibuf[] = { 0 };\r\nstruct i2c_adapter *i2c_adapter;\r\nstruct i2c_client *client;\r\nstruct i2c_board_info info;\r\nstruct ts2020_config ts2020_config = {};\r\nif (dvb_usb_generic_rw(d, obuf, 3, ibuf, 1, 0) < 0)\r\nerr("command 0x0e transfer failed.");\r\nobuf[0] = 0xe;\r\nobuf[1] = 0x02;\r\nobuf[2] = 1;\r\nif (dvb_usb_generic_rw(d, obuf, 3, ibuf, 1, 0) < 0)\r\nerr("command 0x0e transfer failed.");\r\nmsleep(300);\r\nobuf[0] = 0xe;\r\nobuf[1] = 0x83;\r\nobuf[2] = 0;\r\nif (dvb_usb_generic_rw(d, obuf, 3, ibuf, 1, 0) < 0)\r\nerr("command 0x0e transfer failed.");\r\nobuf[0] = 0xe;\r\nobuf[1] = 0x83;\r\nobuf[2] = 1;\r\nif (dvb_usb_generic_rw(d, obuf, 3, ibuf, 1, 0) < 0)\r\nerr("command 0x0e transfer failed.");\r\nobuf[0] = 0x51;\r\nif (dvb_usb_generic_rw(d, obuf, 1, ibuf, 1, 0) < 0)\r\nerr("command 0x51 transfer failed.");\r\nmemset(&info, 0, sizeof(struct i2c_board_info));\r\nadap->fe_adap[0].fe = dvb_attach(m88ds3103_attach,\r\n&tt_s2_4600_m88ds3103_config,\r\n&d->i2c_adap,\r\n&i2c_adapter);\r\nif (adap->fe_adap[0].fe == NULL)\r\nreturn -ENODEV;\r\nts2020_config.fe = adap->fe_adap[0].fe;\r\nstrlcpy(info.type, "ts2022", I2C_NAME_SIZE);\r\ninfo.addr = 0x60;\r\ninfo.platform_data = &ts2020_config;\r\nrequest_module("ts2020");\r\nclient = i2c_new_device(i2c_adapter, &info);\r\nif (client == NULL || client->dev.driver == NULL) {\r\ndvb_frontend_detach(adap->fe_adap[0].fe);\r\nreturn -ENODEV;\r\n}\r\nif (!try_module_get(client->dev.driver->owner)) {\r\ni2c_unregister_device(client);\r\ndvb_frontend_detach(adap->fe_adap[0].fe);\r\nreturn -ENODEV;\r\n}\r\nadap->fe_adap[0].fe->ops.read_signal_strength =\r\nadap->fe_adap[0].fe->ops.tuner_ops.get_rf_strength;\r\nstate->i2c_client_tuner = client;\r\nstate->fe_read_status = adap->fe_adap[0].fe->ops.read_status;\r\nadap->fe_adap[0].fe->ops.read_status = tt_s2_4600_read_status;\r\nstate->last_lock = 0;\r\nreturn 0;\r\n}\r\nstatic int dw2102_tuner_attach(struct dvb_usb_adapter *adap)\r\n{\r\ndvb_attach(dvb_pll_attach, adap->fe_adap[0].fe, 0x60,\r\n&adap->dev->i2c_adap, DVB_PLL_OPERA1);\r\nreturn 0;\r\n}\r\nstatic int dw3101_tuner_attach(struct dvb_usb_adapter *adap)\r\n{\r\ndvb_attach(dvb_pll_attach, adap->fe_adap[0].fe, 0x60,\r\n&adap->dev->i2c_adap, DVB_PLL_TUA6034);\r\nreturn 0;\r\n}\r\nstatic int dw2102_rc_query(struct dvb_usb_device *d)\r\n{\r\nu8 key[2];\r\nstruct i2c_msg msg = {\r\n.addr = DW2102_RC_QUERY,\r\n.flags = I2C_M_RD,\r\n.buf = key,\r\n.len = 2\r\n};\r\nif (d->props.i2c_algo->master_xfer(&d->i2c_adap, &msg, 1) == 1) {\r\nif (msg.buf[0] != 0xff) {\r\ndeb_rc("%s: rc code: %x, %x\n",\r\n__func__, key[0], key[1]);\r\nrc_keydown(d->rc_dev, RC_TYPE_UNKNOWN, key[0], 0);\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int prof_rc_query(struct dvb_usb_device *d)\r\n{\r\nu8 key[2];\r\nstruct i2c_msg msg = {\r\n.addr = DW2102_RC_QUERY,\r\n.flags = I2C_M_RD,\r\n.buf = key,\r\n.len = 2\r\n};\r\nif (d->props.i2c_algo->master_xfer(&d->i2c_adap, &msg, 1) == 1) {\r\nif (msg.buf[0] != 0xff) {\r\ndeb_rc("%s: rc code: %x, %x\n",\r\n__func__, key[0], key[1]);\r\nrc_keydown(d->rc_dev, RC_TYPE_UNKNOWN, key[0]^0xff, 0);\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int su3000_rc_query(struct dvb_usb_device *d)\r\n{\r\nu8 key[2];\r\nstruct i2c_msg msg = {\r\n.addr = DW2102_RC_QUERY,\r\n.flags = I2C_M_RD,\r\n.buf = key,\r\n.len = 2\r\n};\r\nif (d->props.i2c_algo->master_xfer(&d->i2c_adap, &msg, 1) == 1) {\r\nif (msg.buf[0] != 0xff) {\r\ndeb_rc("%s: rc code: %x, %x\n",\r\n__func__, key[0], key[1]);\r\nrc_keydown(d->rc_dev, RC_TYPE_RC5,\r\nRC_SCANCODE_RC5(key[1], key[0]), 0);\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int dw2102_load_firmware(struct usb_device *dev,\r\nconst struct firmware *frmwr)\r\n{\r\nu8 *b, *p;\r\nint ret = 0, i;\r\nu8 reset;\r\nu8 reset16[] = {0, 0, 0, 0, 0, 0, 0};\r\nconst struct firmware *fw;\r\nswitch (le16_to_cpu(dev->descriptor.idProduct)) {\r\ncase 0x2101:\r\nret = request_firmware(&fw, DW2101_FIRMWARE, &dev->dev);\r\nif (ret != 0) {\r\nerr(err_str, DW2101_FIRMWARE);\r\nreturn ret;\r\n}\r\nbreak;\r\ndefault:\r\nfw = frmwr;\r\nbreak;\r\n}\r\ninfo("start downloading DW210X firmware");\r\np = kmalloc(fw->size, GFP_KERNEL);\r\nreset = 1;\r\ndw210x_op_rw(dev, 0xa0, 0x7f92, 0, &reset, 1, DW210X_WRITE_MSG);\r\ndw210x_op_rw(dev, 0xa0, 0xe600, 0, &reset, 1, DW210X_WRITE_MSG);\r\nif (p != NULL) {\r\nmemcpy(p, fw->data, fw->size);\r\nfor (i = 0; i < fw->size; i += 0x40) {\r\nb = (u8 *) p + i;\r\nif (dw210x_op_rw(dev, 0xa0, i, 0, b , 0x40,\r\nDW210X_WRITE_MSG) != 0x40) {\r\nerr("error while transferring firmware");\r\nret = -EINVAL;\r\nbreak;\r\n}\r\n}\r\nreset = 0;\r\nif (ret || dw210x_op_rw(dev, 0xa0, 0x7f92, 0, &reset, 1,\r\nDW210X_WRITE_MSG) != 1) {\r\nerr("could not restart the USB controller CPU.");\r\nret = -EINVAL;\r\n}\r\nif (ret || dw210x_op_rw(dev, 0xa0, 0xe600, 0, &reset, 1,\r\nDW210X_WRITE_MSG) != 1) {\r\nerr("could not restart the USB controller CPU.");\r\nret = -EINVAL;\r\n}\r\nswitch (le16_to_cpu(dev->descriptor.idProduct)) {\r\ncase USB_PID_TEVII_S650:\r\ndw2104_properties.rc.core.rc_codes = RC_MAP_TEVII_NEC;\r\ncase USB_PID_DW2104:\r\nreset = 1;\r\ndw210x_op_rw(dev, 0xc4, 0x0000, 0, &reset, 1,\r\nDW210X_WRITE_MSG);\r\ncase USB_PID_DW3101:\r\nreset = 0;\r\ndw210x_op_rw(dev, 0xbf, 0x0040, 0, &reset, 0,\r\nDW210X_WRITE_MSG);\r\nbreak;\r\ncase USB_PID_CINERGY_S:\r\ncase USB_PID_DW2102:\r\ndw210x_op_rw(dev, 0xbf, 0x0040, 0, &reset, 0,\r\nDW210X_WRITE_MSG);\r\ndw210x_op_rw(dev, 0xb9, 0x0000, 0, &reset16[0], 2,\r\nDW210X_READ_MSG);\r\ndw210x_op_rw(dev, 0xb5, 0, 0, &reset16[0], 2,\r\nDW210X_READ_MSG);\r\nif ((reset16[0] == 0xa1) || (reset16[0] == 0x80)) {\r\ndw2102_properties.i2c_algo = &dw2102_i2c_algo;\r\ndw2102_properties.adapter->fe[0].tuner_attach = &dw2102_tuner_attach;\r\nbreak;\r\n} else {\r\nreset16[0] = 0xd0;\r\nreset16[1] = 1;\r\nreset16[2] = 0;\r\ndw210x_op_rw(dev, 0xc2, 0, 0, &reset16[0], 3,\r\nDW210X_WRITE_MSG);\r\ndw210x_op_rw(dev, 0xc3, 0xd1, 0, &reset16[0], 3,\r\nDW210X_READ_MSG);\r\nif (reset16[2] == 0x11) {\r\ndw2102_properties.i2c_algo = &dw2102_earda_i2c_algo;\r\nbreak;\r\n}\r\n}\r\ncase 0x2101:\r\ndw210x_op_rw(dev, 0xbc, 0x0030, 0, &reset16[0], 2,\r\nDW210X_READ_MSG);\r\ndw210x_op_rw(dev, 0xba, 0x0000, 0, &reset16[0], 7,\r\nDW210X_READ_MSG);\r\ndw210x_op_rw(dev, 0xba, 0x0000, 0, &reset16[0], 7,\r\nDW210X_READ_MSG);\r\ndw210x_op_rw(dev, 0xb9, 0x0000, 0, &reset16[0], 2,\r\nDW210X_READ_MSG);\r\nbreak;\r\n}\r\nmsleep(100);\r\nkfree(p);\r\n}\r\nreturn ret;\r\n}\r\nstatic int dw2102_probe(struct usb_interface *intf,\r\nconst struct usb_device_id *id)\r\n{\r\np1100 = kmemdup(&s6x0_properties,\r\nsizeof(struct dvb_usb_device_properties), GFP_KERNEL);\r\nif (!p1100)\r\nreturn -ENOMEM;\r\np1100->firmware = P1100_FIRMWARE;\r\np1100->devices[0] = d1100;\r\np1100->rc.core.rc_query = prof_rc_query;\r\np1100->rc.core.rc_codes = RC_MAP_TBS_NEC;\r\np1100->adapter->fe[0].frontend_attach = stv0288_frontend_attach;\r\ns660 = kmemdup(&s6x0_properties,\r\nsizeof(struct dvb_usb_device_properties), GFP_KERNEL);\r\nif (!s660) {\r\nkfree(p1100);\r\nreturn -ENOMEM;\r\n}\r\ns660->firmware = S660_FIRMWARE;\r\ns660->num_device_descs = 3;\r\ns660->devices[0] = d660;\r\ns660->devices[1] = d480_1;\r\ns660->devices[2] = d480_2;\r\ns660->adapter->fe[0].frontend_attach = ds3000_frontend_attach;\r\np7500 = kmemdup(&s6x0_properties,\r\nsizeof(struct dvb_usb_device_properties), GFP_KERNEL);\r\nif (!p7500) {\r\nkfree(p1100);\r\nkfree(s660);\r\nreturn -ENOMEM;\r\n}\r\np7500->firmware = P7500_FIRMWARE;\r\np7500->devices[0] = d7500;\r\np7500->rc.core.rc_query = prof_rc_query;\r\np7500->rc.core.rc_codes = RC_MAP_TBS_NEC;\r\np7500->adapter->fe[0].frontend_attach = prof_7500_frontend_attach;\r\ns421 = kmemdup(&su3000_properties,\r\nsizeof(struct dvb_usb_device_properties), GFP_KERNEL);\r\nif (!s421) {\r\nkfree(p1100);\r\nkfree(s660);\r\nkfree(p7500);\r\nreturn -ENOMEM;\r\n}\r\ns421->num_device_descs = 2;\r\ns421->devices[0] = d421;\r\ns421->devices[1] = d632;\r\ns421->adapter->fe[0].frontend_attach = m88rs2000_frontend_attach;\r\nif (0 == dvb_usb_device_init(intf, &dw2102_properties,\r\nTHIS_MODULE, NULL, adapter_nr) ||\r\n0 == dvb_usb_device_init(intf, &dw2104_properties,\r\nTHIS_MODULE, NULL, adapter_nr) ||\r\n0 == dvb_usb_device_init(intf, &dw3101_properties,\r\nTHIS_MODULE, NULL, adapter_nr) ||\r\n0 == dvb_usb_device_init(intf, &s6x0_properties,\r\nTHIS_MODULE, NULL, adapter_nr) ||\r\n0 == dvb_usb_device_init(intf, p1100,\r\nTHIS_MODULE, NULL, adapter_nr) ||\r\n0 == dvb_usb_device_init(intf, s660,\r\nTHIS_MODULE, NULL, adapter_nr) ||\r\n0 == dvb_usb_device_init(intf, p7500,\r\nTHIS_MODULE, NULL, adapter_nr) ||\r\n0 == dvb_usb_device_init(intf, s421,\r\nTHIS_MODULE, NULL, adapter_nr) ||\r\n0 == dvb_usb_device_init(intf, &su3000_properties,\r\nTHIS_MODULE, NULL, adapter_nr) ||\r\n0 == dvb_usb_device_init(intf, &t220_properties,\r\nTHIS_MODULE, NULL, adapter_nr) ||\r\n0 == dvb_usb_device_init(intf, &tt_s2_4600_properties,\r\nTHIS_MODULE, NULL, adapter_nr))\r\nreturn 0;\r\nreturn -ENODEV;\r\n}\r\nstatic void dw2102_disconnect(struct usb_interface *intf)\r\n{\r\nstruct dvb_usb_device *d = usb_get_intfdata(intf);\r\nstruct dw2102_state *st = (struct dw2102_state *)d->priv;\r\nstruct i2c_client *client;\r\nclient = st->i2c_client_tuner;\r\nif (client) {\r\nmodule_put(client->dev.driver->owner);\r\ni2c_unregister_device(client);\r\n}\r\ndvb_usb_device_exit(intf);\r\n}
