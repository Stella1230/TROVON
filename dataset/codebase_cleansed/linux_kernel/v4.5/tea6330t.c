int snd_tea6330t_detect(struct snd_i2c_bus *bus, int equalizer)\r\n{\r\nint res;\r\nsnd_i2c_lock(bus);\r\nres = snd_i2c_probeaddr(bus, TEA6330T_ADDR);\r\nsnd_i2c_unlock(bus);\r\nreturn res;\r\n}\r\nstatic int snd_tea6330t_info_master_volume(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_info *uinfo)\r\n{\r\nuinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;\r\nuinfo->count = 2;\r\nuinfo->value.integer.min = 0;\r\nuinfo->value.integer.max = 43;\r\nreturn 0;\r\n}\r\nstatic int snd_tea6330t_get_master_volume(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct tea6330t *tea = snd_kcontrol_chip(kcontrol);\r\nsnd_i2c_lock(tea->bus);\r\nucontrol->value.integer.value[0] = tea->mleft - 0x14;\r\nucontrol->value.integer.value[1] = tea->mright - 0x14;\r\nsnd_i2c_unlock(tea->bus);\r\nreturn 0;\r\n}\r\nstatic int snd_tea6330t_put_master_volume(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct tea6330t *tea = snd_kcontrol_chip(kcontrol);\r\nint change, count, err;\r\nunsigned char bytes[3];\r\nunsigned char val1, val2;\r\nval1 = (ucontrol->value.integer.value[0] % 44) + 0x14;\r\nval2 = (ucontrol->value.integer.value[1] % 44) + 0x14;\r\nsnd_i2c_lock(tea->bus);\r\nchange = val1 != tea->mleft || val2 != tea->mright;\r\ntea->mleft = val1;\r\ntea->mright = val2;\r\ncount = 0;\r\nif (tea->regs[TEA6330T_SADDR_VOLUME_LEFT] != 0) {\r\nbytes[count++] = TEA6330T_SADDR_VOLUME_LEFT;\r\nbytes[count++] = tea->regs[TEA6330T_SADDR_VOLUME_LEFT] = tea->mleft;\r\n}\r\nif (tea->regs[TEA6330T_SADDR_VOLUME_RIGHT] != 0) {\r\nif (count == 0)\r\nbytes[count++] = TEA6330T_SADDR_VOLUME_RIGHT;\r\nbytes[count++] = tea->regs[TEA6330T_SADDR_VOLUME_RIGHT] = tea->mright;\r\n}\r\nif (count > 0) {\r\nif ((err = snd_i2c_sendbytes(tea->device, bytes, count)) < 0)\r\nchange = err;\r\n}\r\nsnd_i2c_unlock(tea->bus);\r\nreturn change;\r\n}\r\nstatic int snd_tea6330t_get_master_switch(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct tea6330t *tea = snd_kcontrol_chip(kcontrol);\r\nsnd_i2c_lock(tea->bus);\r\nucontrol->value.integer.value[0] = tea->regs[TEA6330T_SADDR_VOLUME_LEFT] == 0 ? 0 : 1;\r\nucontrol->value.integer.value[1] = tea->regs[TEA6330T_SADDR_VOLUME_RIGHT] == 0 ? 0 : 1;\r\nsnd_i2c_unlock(tea->bus);\r\nreturn 0;\r\n}\r\nstatic int snd_tea6330t_put_master_switch(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct tea6330t *tea = snd_kcontrol_chip(kcontrol);\r\nint change, err;\r\nunsigned char bytes[3];\r\nunsigned char oval1, oval2, val1, val2;\r\nval1 = ucontrol->value.integer.value[0] & 1;\r\nval2 = ucontrol->value.integer.value[1] & 1;\r\nsnd_i2c_lock(tea->bus);\r\noval1 = tea->regs[TEA6330T_SADDR_VOLUME_LEFT] == 0 ? 0 : 1;\r\noval2 = tea->regs[TEA6330T_SADDR_VOLUME_RIGHT] == 0 ? 0 : 1;\r\nchange = val1 != oval1 || val2 != oval2;\r\ntea->regs[TEA6330T_SADDR_VOLUME_LEFT] = val1 ? tea->mleft : 0;\r\ntea->regs[TEA6330T_SADDR_VOLUME_RIGHT] = val2 ? tea->mright : 0;\r\nbytes[0] = TEA6330T_SADDR_VOLUME_LEFT;\r\nbytes[1] = tea->regs[TEA6330T_SADDR_VOLUME_LEFT];\r\nbytes[2] = tea->regs[TEA6330T_SADDR_VOLUME_RIGHT];\r\nif ((err = snd_i2c_sendbytes(tea->device, bytes, 3)) < 0)\r\nchange = err;\r\nsnd_i2c_unlock(tea->bus);\r\nreturn change;\r\n}\r\nstatic int snd_tea6330t_info_bass(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_info *uinfo)\r\n{\r\nstruct tea6330t *tea = snd_kcontrol_chip(kcontrol);\r\nuinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;\r\nuinfo->count = 1;\r\nuinfo->value.integer.min = 0;\r\nuinfo->value.integer.max = tea->max_bass;\r\nreturn 0;\r\n}\r\nstatic int snd_tea6330t_get_bass(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct tea6330t *tea = snd_kcontrol_chip(kcontrol);\r\nucontrol->value.integer.value[0] = tea->bass;\r\nreturn 0;\r\n}\r\nstatic int snd_tea6330t_put_bass(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct tea6330t *tea = snd_kcontrol_chip(kcontrol);\r\nint change, err;\r\nunsigned char bytes[2];\r\nunsigned char val1;\r\nval1 = ucontrol->value.integer.value[0] % (tea->max_bass + 1);\r\nsnd_i2c_lock(tea->bus);\r\ntea->bass = val1;\r\nval1 += tea->equalizer ? 7 : 3;\r\nchange = tea->regs[TEA6330T_SADDR_BASS] != val1;\r\nbytes[0] = TEA6330T_SADDR_BASS;\r\nbytes[1] = tea->regs[TEA6330T_SADDR_BASS] = val1;\r\nif ((err = snd_i2c_sendbytes(tea->device, bytes, 2)) < 0)\r\nchange = err;\r\nsnd_i2c_unlock(tea->bus);\r\nreturn change;\r\n}\r\nstatic int snd_tea6330t_info_treble(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_info *uinfo)\r\n{\r\nstruct tea6330t *tea = snd_kcontrol_chip(kcontrol);\r\nuinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;\r\nuinfo->count = 1;\r\nuinfo->value.integer.min = 0;\r\nuinfo->value.integer.max = tea->max_treble;\r\nreturn 0;\r\n}\r\nstatic int snd_tea6330t_get_treble(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct tea6330t *tea = snd_kcontrol_chip(kcontrol);\r\nucontrol->value.integer.value[0] = tea->treble;\r\nreturn 0;\r\n}\r\nstatic int snd_tea6330t_put_treble(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct tea6330t *tea = snd_kcontrol_chip(kcontrol);\r\nint change, err;\r\nunsigned char bytes[2];\r\nunsigned char val1;\r\nval1 = ucontrol->value.integer.value[0] % (tea->max_treble + 1);\r\nsnd_i2c_lock(tea->bus);\r\ntea->treble = val1;\r\nval1 += 3;\r\nchange = tea->regs[TEA6330T_SADDR_TREBLE] != val1;\r\nbytes[0] = TEA6330T_SADDR_TREBLE;\r\nbytes[1] = tea->regs[TEA6330T_SADDR_TREBLE] = val1;\r\nif ((err = snd_i2c_sendbytes(tea->device, bytes, 2)) < 0)\r\nchange = err;\r\nsnd_i2c_unlock(tea->bus);\r\nreturn change;\r\n}\r\nstatic void snd_tea6330_free(struct snd_i2c_device *device)\r\n{\r\nkfree(device->private_data);\r\n}\r\nint snd_tea6330t_update_mixer(struct snd_card *card,\r\nstruct snd_i2c_bus *bus,\r\nint equalizer, int fader)\r\n{\r\nstruct snd_i2c_device *device;\r\nstruct tea6330t *tea;\r\nstruct snd_kcontrol_new *knew;\r\nunsigned int idx;\r\nint err = -ENOMEM;\r\nu8 default_treble, default_bass;\r\nunsigned char bytes[7];\r\ntea = kzalloc(sizeof(*tea), GFP_KERNEL);\r\nif (tea == NULL)\r\nreturn -ENOMEM;\r\nif ((err = snd_i2c_device_create(bus, "TEA6330T", TEA6330T_ADDR, &device)) < 0) {\r\nkfree(tea);\r\nreturn err;\r\n}\r\ntea->device = device;\r\ntea->bus = bus;\r\ntea->equalizer = equalizer;\r\ntea->fader = fader;\r\ndevice->private_data = tea;\r\ndevice->private_free = snd_tea6330_free;\r\nsnd_i2c_lock(bus);\r\ntea->regs[TEA6330T_SADDR_FADER] = 0x3f;\r\ntea->regs[TEA6330T_SADDR_AUDIO_SWITCH] = equalizer ? 0 : TEA6330T_EQN;\r\nif (!tea->equalizer) {\r\ntea->max_bass = 9;\r\ntea->max_treble = 8;\r\ndefault_bass = 3 + 4;\r\ntea->bass = 4;\r\ndefault_treble = 3 + 4;\r\ntea->treble = 4;\r\n} else {\r\ntea->max_bass = 5;\r\ntea->max_treble = 0;\r\ndefault_bass = 7 + 4;\r\ntea->bass = 4;\r\ndefault_treble = 3;\r\ntea->treble = 0;\r\n}\r\ntea->mleft = tea->mright = 0x14;\r\ntea->regs[TEA6330T_SADDR_BASS] = default_bass;\r\ntea->regs[TEA6330T_SADDR_TREBLE] = default_treble;\r\nbytes[0] = TEA6330T_SADDR_VOLUME_LEFT;\r\nfor (idx = 0; idx < 6; idx++)\r\nbytes[idx+1] = tea->regs[idx];\r\nif ((err = snd_i2c_sendbytes(device, bytes, 7)) < 0)\r\ngoto __error;\r\nstrcat(card->mixername, ",TEA6330T");\r\nif ((err = snd_component_add(card, "TEA6330T")) < 0)\r\ngoto __error;\r\nfor (idx = 0; idx < ARRAY_SIZE(snd_tea6330t_controls); idx++) {\r\nknew = &snd_tea6330t_controls[idx];\r\nif (tea->treble == 0 && !strcmp(knew->name, "Tone Control - Treble"))\r\ncontinue;\r\nif ((err = snd_ctl_add(card, snd_ctl_new1(knew, tea))) < 0)\r\ngoto __error;\r\n}\r\nsnd_i2c_unlock(bus);\r\nreturn 0;\r\n__error:\r\nsnd_i2c_unlock(bus);\r\nsnd_i2c_device_free(device);\r\nreturn err;\r\n}\r\nstatic int __init alsa_tea6330t_init(void)\r\n{\r\nreturn 0;\r\n}\r\nstatic void __exit alsa_tea6330t_exit(void)\r\n{\r\n}
