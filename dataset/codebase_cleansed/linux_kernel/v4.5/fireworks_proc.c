static inline const char*\r\nget_phys_name(struct snd_efw_phys_grp *grp, bool input)\r\n{\r\nconst char *const ch_type[] = {\r\n"Analog", "S/PDIF", "ADAT", "S/PDIF or ADAT", "Mirroring",\r\n"Headphones", "I2S", "Guitar", "Pirzo Guitar", "Guitar String",\r\n};\r\nif (grp->type < ARRAY_SIZE(ch_type))\r\nreturn ch_type[grp->type];\r\nelse if (input)\r\nreturn "Input";\r\nelse\r\nreturn "Output";\r\n}\r\nstatic void\r\nproc_read_hwinfo(struct snd_info_entry *entry, struct snd_info_buffer *buffer)\r\n{\r\nstruct snd_efw *efw = entry->private_data;\r\nunsigned short i;\r\nstruct snd_efw_hwinfo *hwinfo;\r\nhwinfo = kmalloc(sizeof(struct snd_efw_hwinfo), GFP_KERNEL);\r\nif (hwinfo == NULL)\r\nreturn;\r\nif (snd_efw_command_get_hwinfo(efw, hwinfo) < 0)\r\ngoto end;\r\nsnd_iprintf(buffer, "guid_hi: 0x%X\n", hwinfo->guid_hi);\r\nsnd_iprintf(buffer, "guid_lo: 0x%X\n", hwinfo->guid_lo);\r\nsnd_iprintf(buffer, "type: 0x%X\n", hwinfo->type);\r\nsnd_iprintf(buffer, "version: 0x%X\n", hwinfo->version);\r\nsnd_iprintf(buffer, "vendor_name: %s\n", hwinfo->vendor_name);\r\nsnd_iprintf(buffer, "model_name: %s\n", hwinfo->model_name);\r\nsnd_iprintf(buffer, "dsp_version: 0x%X\n", hwinfo->dsp_version);\r\nsnd_iprintf(buffer, "arm_version: 0x%X\n", hwinfo->arm_version);\r\nsnd_iprintf(buffer, "fpga_version: 0x%X\n", hwinfo->fpga_version);\r\nsnd_iprintf(buffer, "flags: 0x%X\n", hwinfo->flags);\r\nsnd_iprintf(buffer, "max_sample_rate: 0x%X\n", hwinfo->max_sample_rate);\r\nsnd_iprintf(buffer, "min_sample_rate: 0x%X\n", hwinfo->min_sample_rate);\r\nsnd_iprintf(buffer, "supported_clock: 0x%X\n",\r\nhwinfo->supported_clocks);\r\nsnd_iprintf(buffer, "phys out: 0x%X\n", hwinfo->phys_out);\r\nsnd_iprintf(buffer, "phys in: 0x%X\n", hwinfo->phys_in);\r\nsnd_iprintf(buffer, "phys in grps: 0x%X\n",\r\nhwinfo->phys_in_grp_count);\r\nfor (i = 0; i < hwinfo->phys_in_grp_count; i++) {\r\nsnd_iprintf(buffer,\r\n"phys in grp[%d]: type 0x%X, count 0x%X\n",\r\ni, hwinfo->phys_out_grps[i].type,\r\nhwinfo->phys_out_grps[i].count);\r\n}\r\nsnd_iprintf(buffer, "phys out grps: 0x%X\n",\r\nhwinfo->phys_out_grp_count);\r\nfor (i = 0; i < hwinfo->phys_out_grp_count; i++) {\r\nsnd_iprintf(buffer,\r\n"phys out grps[%d]: type 0x%X, count 0x%X\n",\r\ni, hwinfo->phys_out_grps[i].type,\r\nhwinfo->phys_out_grps[i].count);\r\n}\r\nsnd_iprintf(buffer, "amdtp rx pcm channels 1x: 0x%X\n",\r\nhwinfo->amdtp_rx_pcm_channels);\r\nsnd_iprintf(buffer, "amdtp tx pcm channels 1x: 0x%X\n",\r\nhwinfo->amdtp_tx_pcm_channels);\r\nsnd_iprintf(buffer, "amdtp rx pcm channels 2x: 0x%X\n",\r\nhwinfo->amdtp_rx_pcm_channels_2x);\r\nsnd_iprintf(buffer, "amdtp tx pcm channels 2x: 0x%X\n",\r\nhwinfo->amdtp_tx_pcm_channels_2x);\r\nsnd_iprintf(buffer, "amdtp rx pcm channels 4x: 0x%X\n",\r\nhwinfo->amdtp_rx_pcm_channels_4x);\r\nsnd_iprintf(buffer, "amdtp tx pcm channels 4x: 0x%X\n",\r\nhwinfo->amdtp_tx_pcm_channels_4x);\r\nsnd_iprintf(buffer, "midi out ports: 0x%X\n", hwinfo->midi_out_ports);\r\nsnd_iprintf(buffer, "midi in ports: 0x%X\n", hwinfo->midi_in_ports);\r\nsnd_iprintf(buffer, "mixer playback channels: 0x%X\n",\r\nhwinfo->mixer_playback_channels);\r\nsnd_iprintf(buffer, "mixer capture channels: 0x%X\n",\r\nhwinfo->mixer_capture_channels);\r\nend:\r\nkfree(hwinfo);\r\n}\r\nstatic void\r\nproc_read_clock(struct snd_info_entry *entry, struct snd_info_buffer *buffer)\r\n{\r\nstruct snd_efw *efw = entry->private_data;\r\nenum snd_efw_clock_source clock_source;\r\nunsigned int sampling_rate;\r\nif (snd_efw_command_get_clock_source(efw, &clock_source) < 0)\r\nreturn;\r\nif (snd_efw_command_get_sampling_rate(efw, &sampling_rate) < 0)\r\nreturn;\r\nsnd_iprintf(buffer, "Clock Source: %d\n", clock_source);\r\nsnd_iprintf(buffer, "Sampling Rate: %d\n", sampling_rate);\r\n}\r\nstatic void\r\nproc_read_phys_meters(struct snd_info_entry *entry,\r\nstruct snd_info_buffer *buffer)\r\n{\r\nstruct snd_efw *efw = entry->private_data;\r\nstruct snd_efw_phys_meters *meters;\r\nunsigned int g, c, m, max, size;\r\nconst char *name;\r\nu32 *linear;\r\nint err;\r\nsize = sizeof(struct snd_efw_phys_meters) +\r\n(efw->phys_in + efw->phys_out) * sizeof(u32);\r\nmeters = kzalloc(size, GFP_KERNEL);\r\nif (meters == NULL)\r\nreturn;\r\nerr = snd_efw_command_get_phys_meters(efw, meters, size);\r\nif (err < 0)\r\ngoto end;\r\nsnd_iprintf(buffer, "Physical Meters:\n");\r\nm = 0;\r\nmax = min(efw->phys_out, meters->out_meters);\r\nlinear = meters->values;\r\nsnd_iprintf(buffer, " %d Outputs:\n", max);\r\nfor (g = 0; g < efw->phys_out_grp_count; g++) {\r\nname = get_phys_name(&efw->phys_out_grps[g], false);\r\nfor (c = 0; c < efw->phys_out_grps[g].count; c++) {\r\nif (m < max)\r\nsnd_iprintf(buffer, "\t%s [%d]: %d\n",\r\nname, c, linear[m++]);\r\n}\r\n}\r\nm = 0;\r\nmax = min(efw->phys_in, meters->in_meters);\r\nlinear = meters->values + meters->out_meters;\r\nsnd_iprintf(buffer, " %d Inputs:\n", max);\r\nfor (g = 0; g < efw->phys_in_grp_count; g++) {\r\nname = get_phys_name(&efw->phys_in_grps[g], true);\r\nfor (c = 0; c < efw->phys_in_grps[g].count; c++)\r\nif (m < max)\r\nsnd_iprintf(buffer, "\t%s [%d]: %d\n",\r\nname, c, linear[m++]);\r\n}\r\nend:\r\nkfree(meters);\r\n}\r\nstatic void\r\nproc_read_queues_state(struct snd_info_entry *entry,\r\nstruct snd_info_buffer *buffer)\r\n{\r\nstruct snd_efw *efw = entry->private_data;\r\nunsigned int consumed;\r\nif (efw->pull_ptr > efw->push_ptr)\r\nconsumed = snd_efw_resp_buf_size -\r\n(unsigned int)(efw->pull_ptr - efw->push_ptr);\r\nelse\r\nconsumed = (unsigned int)(efw->push_ptr - efw->pull_ptr);\r\nsnd_iprintf(buffer, "%d %d/%d\n",\r\nefw->resp_queues, consumed, snd_efw_resp_buf_size);\r\n}\r\nstatic void\r\nadd_node(struct snd_efw *efw, struct snd_info_entry *root, const char *name,\r\nvoid (*op)(struct snd_info_entry *e, struct snd_info_buffer *b))\r\n{\r\nstruct snd_info_entry *entry;\r\nentry = snd_info_create_card_entry(efw->card, name, root);\r\nif (entry == NULL)\r\nreturn;\r\nsnd_info_set_text_ops(entry, efw, op);\r\nif (snd_info_register(entry) < 0)\r\nsnd_info_free_entry(entry);\r\n}\r\nvoid snd_efw_proc_init(struct snd_efw *efw)\r\n{\r\nstruct snd_info_entry *root;\r\nroot = snd_info_create_card_entry(efw->card, "firewire",\r\nefw->card->proc_root);\r\nif (root == NULL)\r\nreturn;\r\nroot->mode = S_IFDIR | S_IRUGO | S_IXUGO;\r\nif (snd_info_register(root) < 0) {\r\nsnd_info_free_entry(root);\r\nreturn;\r\n}\r\nadd_node(efw, root, "clock", proc_read_clock);\r\nadd_node(efw, root, "firmware", proc_read_hwinfo);\r\nadd_node(efw, root, "meters", proc_read_phys_meters);\r\nadd_node(efw, root, "queues", proc_read_queues_state);\r\n}
