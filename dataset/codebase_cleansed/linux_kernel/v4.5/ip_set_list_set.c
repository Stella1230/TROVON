static int\r\nlist_set_ktest(struct ip_set *set, const struct sk_buff *skb,\r\nconst struct xt_action_param *par,\r\nstruct ip_set_adt_opt *opt, const struct ip_set_ext *ext)\r\n{\r\nstruct list_set *map = set->data;\r\nstruct set_elem *e;\r\nu32 cmdflags = opt->cmdflags;\r\nint ret;\r\nopt->cmdflags &= ~IPSET_FLAG_MATCH_COUNTERS;\r\nif (opt->cmdflags & IPSET_FLAG_SKIP_SUBCOUNTER_UPDATE)\r\nopt->cmdflags &= ~IPSET_FLAG_SKIP_COUNTER_UPDATE;\r\nlist_for_each_entry_rcu(e, &map->members, list) {\r\nif (SET_WITH_TIMEOUT(set) &&\r\nip_set_timeout_expired(ext_timeout(e, set)))\r\ncontinue;\r\nret = ip_set_test(e->id, skb, par, opt);\r\nif (ret > 0) {\r\nif (SET_WITH_COUNTER(set))\r\nip_set_update_counter(ext_counter(e, set),\r\next, &opt->ext,\r\ncmdflags);\r\nif (SET_WITH_SKBINFO(set))\r\nip_set_get_skbinfo(ext_skbinfo(e, set),\r\next, &opt->ext,\r\ncmdflags);\r\nreturn ret;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int\r\nlist_set_kadd(struct ip_set *set, const struct sk_buff *skb,\r\nconst struct xt_action_param *par,\r\nstruct ip_set_adt_opt *opt, const struct ip_set_ext *ext)\r\n{\r\nstruct list_set *map = set->data;\r\nstruct set_elem *e;\r\nint ret;\r\nlist_for_each_entry(e, &map->members, list) {\r\nif (SET_WITH_TIMEOUT(set) &&\r\nip_set_timeout_expired(ext_timeout(e, set)))\r\ncontinue;\r\nret = ip_set_add(e->id, skb, par, opt);\r\nif (ret == 0)\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic int\r\nlist_set_kdel(struct ip_set *set, const struct sk_buff *skb,\r\nconst struct xt_action_param *par,\r\nstruct ip_set_adt_opt *opt, const struct ip_set_ext *ext)\r\n{\r\nstruct list_set *map = set->data;\r\nstruct set_elem *e;\r\nint ret;\r\nlist_for_each_entry(e, &map->members, list) {\r\nif (SET_WITH_TIMEOUT(set) &&\r\nip_set_timeout_expired(ext_timeout(e, set)))\r\ncontinue;\r\nret = ip_set_del(e->id, skb, par, opt);\r\nif (ret == 0)\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic int\r\nlist_set_kadt(struct ip_set *set, const struct sk_buff *skb,\r\nconst struct xt_action_param *par,\r\nenum ipset_adt adt, struct ip_set_adt_opt *opt)\r\n{\r\nstruct ip_set_ext ext = IP_SET_INIT_KEXT(skb, opt, set);\r\nint ret = -EINVAL;\r\nrcu_read_lock();\r\nswitch (adt) {\r\ncase IPSET_TEST:\r\nret = list_set_ktest(set, skb, par, opt, &ext);\r\nbreak;\r\ncase IPSET_ADD:\r\nret = list_set_kadd(set, skb, par, opt, &ext);\r\nbreak;\r\ncase IPSET_DEL:\r\nret = list_set_kdel(set, skb, par, opt, &ext);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nrcu_read_unlock();\r\nreturn ret;\r\n}\r\nstatic void\r\n__list_set_del(struct ip_set *set, struct set_elem *e)\r\n{\r\nstruct list_set *map = set->data;\r\nip_set_put_byindex(map->net, e->id);\r\nip_set_ext_destroy(set, e);\r\nkfree_rcu(e, rcu);\r\n}\r\nstatic inline void\r\nlist_set_del(struct ip_set *set, struct set_elem *e)\r\n{\r\nlist_del_rcu(&e->list);\r\n__list_set_del(set, e);\r\n}\r\nstatic inline void\r\nlist_set_replace(struct ip_set *set, struct set_elem *e, struct set_elem *old)\r\n{\r\nlist_replace_rcu(&old->list, &e->list);\r\n__list_set_del(set, old);\r\n}\r\nstatic void\r\nset_cleanup_entries(struct ip_set *set)\r\n{\r\nstruct list_set *map = set->data;\r\nstruct set_elem *e, *n;\r\nlist_for_each_entry_safe(e, n, &map->members, list)\r\nif (ip_set_timeout_expired(ext_timeout(e, set)))\r\nlist_set_del(set, e);\r\n}\r\nstatic int\r\nlist_set_utest(struct ip_set *set, void *value, const struct ip_set_ext *ext,\r\nstruct ip_set_ext *mext, u32 flags)\r\n{\r\nstruct list_set *map = set->data;\r\nstruct set_adt_elem *d = value;\r\nstruct set_elem *e, *next, *prev = NULL;\r\nint ret;\r\nlist_for_each_entry(e, &map->members, list) {\r\nif (SET_WITH_TIMEOUT(set) &&\r\nip_set_timeout_expired(ext_timeout(e, set)))\r\ncontinue;\r\nelse if (e->id != d->id) {\r\nprev = e;\r\ncontinue;\r\n}\r\nif (d->before == 0) {\r\nret = 1;\r\n} else if (d->before > 0) {\r\nnext = list_next_entry(e, list);\r\nret = !list_is_last(&e->list, &map->members) &&\r\nnext->id == d->refid;\r\n} else {\r\nret = prev && prev->id == d->refid;\r\n}\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic void\r\nlist_set_init_extensions(struct ip_set *set, const struct ip_set_ext *ext,\r\nstruct set_elem *e)\r\n{\r\nif (SET_WITH_COUNTER(set))\r\nip_set_init_counter(ext_counter(e, set), ext);\r\nif (SET_WITH_COMMENT(set))\r\nip_set_init_comment(ext_comment(e, set), ext);\r\nif (SET_WITH_SKBINFO(set))\r\nip_set_init_skbinfo(ext_skbinfo(e, set), ext);\r\nif (SET_WITH_TIMEOUT(set))\r\nip_set_timeout_set(ext_timeout(e, set), ext->timeout);\r\n}\r\nstatic int\r\nlist_set_uadd(struct ip_set *set, void *value, const struct ip_set_ext *ext,\r\nstruct ip_set_ext *mext, u32 flags)\r\n{\r\nstruct list_set *map = set->data;\r\nstruct set_adt_elem *d = value;\r\nstruct set_elem *e, *n, *prev, *next;\r\nbool flag_exist = flags & IPSET_FLAG_EXIST;\r\nif (SET_WITH_TIMEOUT(set))\r\nset_cleanup_entries(set);\r\nn = prev = next = NULL;\r\nlist_for_each_entry(e, &map->members, list) {\r\nif (SET_WITH_TIMEOUT(set) &&\r\nip_set_timeout_expired(ext_timeout(e, set)))\r\ncontinue;\r\nelse if (d->id == e->id)\r\nn = e;\r\nelse if (d->before == 0 || e->id != d->refid)\r\ncontinue;\r\nelse if (d->before > 0)\r\nnext = e;\r\nelse\r\nprev = e;\r\n}\r\nif (n) {\r\nif ((d->before > 0 && !next) ||\r\n(d->before < 0 && !prev))\r\nreturn -IPSET_ERR_REF_EXIST;\r\nif (!flag_exist)\r\nreturn -IPSET_ERR_EXIST;\r\nip_set_ext_destroy(set, n);\r\nlist_set_init_extensions(set, ext, n);\r\nip_set_put_byindex(map->net, d->id);\r\nreturn 0;\r\n}\r\nif (d->before == 0) {\r\nn = list_empty(&map->members) ? NULL :\r\nlist_last_entry(&map->members, struct set_elem, list);\r\n} else if (d->before > 0) {\r\nif (!list_is_last(&next->list, &map->members))\r\nn = list_next_entry(next, list);\r\n} else {\r\nif (prev->list.prev != &map->members)\r\nn = list_prev_entry(prev, list);\r\n}\r\nif (n &&\r\n!(SET_WITH_TIMEOUT(set) &&\r\nip_set_timeout_expired(ext_timeout(n, set))))\r\nn = NULL;\r\ne = kzalloc(set->dsize, GFP_ATOMIC);\r\nif (!e)\r\nreturn -ENOMEM;\r\ne->id = d->id;\r\nINIT_LIST_HEAD(&e->list);\r\nlist_set_init_extensions(set, ext, e);\r\nif (n)\r\nlist_set_replace(set, e, n);\r\nelse if (next)\r\nlist_add_tail_rcu(&e->list, &next->list);\r\nelse if (prev)\r\nlist_add_rcu(&e->list, &prev->list);\r\nelse\r\nlist_add_tail_rcu(&e->list, &map->members);\r\nreturn 0;\r\n}\r\nstatic int\r\nlist_set_udel(struct ip_set *set, void *value, const struct ip_set_ext *ext,\r\nstruct ip_set_ext *mext, u32 flags)\r\n{\r\nstruct list_set *map = set->data;\r\nstruct set_adt_elem *d = value;\r\nstruct set_elem *e, *next, *prev = NULL;\r\nlist_for_each_entry(e, &map->members, list) {\r\nif (SET_WITH_TIMEOUT(set) &&\r\nip_set_timeout_expired(ext_timeout(e, set)))\r\ncontinue;\r\nelse if (e->id != d->id) {\r\nprev = e;\r\ncontinue;\r\n}\r\nif (d->before > 0) {\r\nnext = list_next_entry(e, list);\r\nif (list_is_last(&e->list, &map->members) ||\r\nnext->id != d->refid)\r\nreturn -IPSET_ERR_REF_EXIST;\r\n} else if (d->before < 0) {\r\nif (!prev || prev->id != d->refid)\r\nreturn -IPSET_ERR_REF_EXIST;\r\n}\r\nlist_set_del(set, e);\r\nreturn 0;\r\n}\r\nreturn d->before != 0 ? -IPSET_ERR_REF_EXIST : -IPSET_ERR_EXIST;\r\n}\r\nstatic int\r\nlist_set_uadt(struct ip_set *set, struct nlattr *tb[],\r\nenum ipset_adt adt, u32 *lineno, u32 flags, bool retried)\r\n{\r\nstruct list_set *map = set->data;\r\nipset_adtfn adtfn = set->variant->adt[adt];\r\nstruct set_adt_elem e = { .refid = IPSET_INVALID_ID };\r\nstruct ip_set_ext ext = IP_SET_INIT_UEXT(set);\r\nstruct ip_set *s;\r\nint ret = 0;\r\nif (tb[IPSET_ATTR_LINENO])\r\n*lineno = nla_get_u32(tb[IPSET_ATTR_LINENO]);\r\nif (unlikely(!tb[IPSET_ATTR_NAME] ||\r\n!ip_set_optattr_netorder(tb, IPSET_ATTR_CADT_FLAGS)))\r\nreturn -IPSET_ERR_PROTOCOL;\r\nret = ip_set_get_extensions(set, tb, &ext);\r\nif (ret)\r\nreturn ret;\r\ne.id = ip_set_get_byname(map->net, nla_data(tb[IPSET_ATTR_NAME]), &s);\r\nif (e.id == IPSET_INVALID_ID)\r\nreturn -IPSET_ERR_NAME;\r\nif (s->type->features & IPSET_TYPE_NAME) {\r\nret = -IPSET_ERR_LOOP;\r\ngoto finish;\r\n}\r\nif (tb[IPSET_ATTR_CADT_FLAGS]) {\r\nu32 f = ip_set_get_h32(tb[IPSET_ATTR_CADT_FLAGS]);\r\ne.before = f & IPSET_FLAG_BEFORE;\r\n}\r\nif (e.before && !tb[IPSET_ATTR_NAMEREF]) {\r\nret = -IPSET_ERR_BEFORE;\r\ngoto finish;\r\n}\r\nif (tb[IPSET_ATTR_NAMEREF]) {\r\ne.refid = ip_set_get_byname(map->net,\r\nnla_data(tb[IPSET_ATTR_NAMEREF]),\r\n&s);\r\nif (e.refid == IPSET_INVALID_ID) {\r\nret = -IPSET_ERR_NAMEREF;\r\ngoto finish;\r\n}\r\nif (!e.before)\r\ne.before = -1;\r\n}\r\nif (adt != IPSET_TEST && SET_WITH_TIMEOUT(set))\r\nset_cleanup_entries(set);\r\nret = adtfn(set, &e, &ext, &ext, flags);\r\nfinish:\r\nif (e.refid != IPSET_INVALID_ID)\r\nip_set_put_byindex(map->net, e.refid);\r\nif (adt != IPSET_ADD || ret)\r\nip_set_put_byindex(map->net, e.id);\r\nreturn ip_set_eexist(ret, flags) ? 0 : ret;\r\n}\r\nstatic void\r\nlist_set_flush(struct ip_set *set)\r\n{\r\nstruct list_set *map = set->data;\r\nstruct set_elem *e, *n;\r\nlist_for_each_entry_safe(e, n, &map->members, list)\r\nlist_set_del(set, e);\r\n}\r\nstatic void\r\nlist_set_destroy(struct ip_set *set)\r\n{\r\nstruct list_set *map = set->data;\r\nstruct set_elem *e, *n;\r\nif (SET_WITH_TIMEOUT(set))\r\ndel_timer_sync(&map->gc);\r\nlist_for_each_entry_safe(e, n, &map->members, list) {\r\nlist_del(&e->list);\r\nip_set_put_byindex(map->net, e->id);\r\nip_set_ext_destroy(set, e);\r\nkfree(e);\r\n}\r\nkfree(map);\r\nset->data = NULL;\r\n}\r\nstatic int\r\nlist_set_head(struct ip_set *set, struct sk_buff *skb)\r\n{\r\nconst struct list_set *map = set->data;\r\nstruct nlattr *nested;\r\nstruct set_elem *e;\r\nu32 n = 0;\r\nlist_for_each_entry(e, &map->members, list)\r\nn++;\r\nnested = ipset_nest_start(skb, IPSET_ATTR_DATA);\r\nif (!nested)\r\ngoto nla_put_failure;\r\nif (nla_put_net32(skb, IPSET_ATTR_SIZE, htonl(map->size)) ||\r\nnla_put_net32(skb, IPSET_ATTR_REFERENCES, htonl(set->ref - 1)) ||\r\nnla_put_net32(skb, IPSET_ATTR_MEMSIZE,\r\nhtonl(sizeof(*map) + n * set->dsize)))\r\ngoto nla_put_failure;\r\nif (unlikely(ip_set_put_flags(skb, set)))\r\ngoto nla_put_failure;\r\nipset_nest_end(skb, nested);\r\nreturn 0;\r\nnla_put_failure:\r\nreturn -EMSGSIZE;\r\n}\r\nstatic int\r\nlist_set_list(const struct ip_set *set,\r\nstruct sk_buff *skb, struct netlink_callback *cb)\r\n{\r\nconst struct list_set *map = set->data;\r\nstruct nlattr *atd, *nested;\r\nu32 i = 0, first = cb->args[IPSET_CB_ARG0];\r\nstruct set_elem *e;\r\nint ret = 0;\r\natd = ipset_nest_start(skb, IPSET_ATTR_ADT);\r\nif (!atd)\r\nreturn -EMSGSIZE;\r\nlist_for_each_entry(e, &map->members, list) {\r\nif (i == first)\r\nbreak;\r\ni++;\r\n}\r\nrcu_read_lock();\r\nlist_for_each_entry_from(e, &map->members, list) {\r\ni++;\r\nif (SET_WITH_TIMEOUT(set) &&\r\nip_set_timeout_expired(ext_timeout(e, set)))\r\ncontinue;\r\nnested = ipset_nest_start(skb, IPSET_ATTR_DATA);\r\nif (!nested) {\r\nif (i == first) {\r\nnla_nest_cancel(skb, atd);\r\nret = -EMSGSIZE;\r\ngoto out;\r\n}\r\ngoto nla_put_failure;\r\n}\r\nif (nla_put_string(skb, IPSET_ATTR_NAME,\r\nip_set_name_byindex(map->net, e->id)))\r\ngoto nla_put_failure;\r\nif (ip_set_put_extensions(skb, set, e, true))\r\ngoto nla_put_failure;\r\nipset_nest_end(skb, nested);\r\n}\r\nipset_nest_end(skb, atd);\r\ncb->args[IPSET_CB_ARG0] = 0;\r\ngoto out;\r\nnla_put_failure:\r\nnla_nest_cancel(skb, nested);\r\nif (unlikely(i == first)) {\r\ncb->args[IPSET_CB_ARG0] = 0;\r\nret = -EMSGSIZE;\r\n}\r\ncb->args[IPSET_CB_ARG0] = i - 1;\r\nipset_nest_end(skb, atd);\r\nout:\r\nrcu_read_unlock();\r\nreturn ret;\r\n}\r\nstatic bool\r\nlist_set_same_set(const struct ip_set *a, const struct ip_set *b)\r\n{\r\nconst struct list_set *x = a->data;\r\nconst struct list_set *y = b->data;\r\nreturn x->size == y->size &&\r\na->timeout == b->timeout &&\r\na->extensions == b->extensions;\r\n}\r\nstatic void\r\nlist_set_gc(unsigned long ul_set)\r\n{\r\nstruct ip_set *set = (struct ip_set *)ul_set;\r\nstruct list_set *map = set->data;\r\nspin_lock_bh(&set->lock);\r\nset_cleanup_entries(set);\r\nspin_unlock_bh(&set->lock);\r\nmap->gc.expires = jiffies + IPSET_GC_PERIOD(set->timeout) * HZ;\r\nadd_timer(&map->gc);\r\n}\r\nstatic void\r\nlist_set_gc_init(struct ip_set *set, void (*gc)(unsigned long ul_set))\r\n{\r\nstruct list_set *map = set->data;\r\ninit_timer(&map->gc);\r\nmap->gc.data = (unsigned long)set;\r\nmap->gc.function = gc;\r\nmap->gc.expires = jiffies + IPSET_GC_PERIOD(set->timeout) * HZ;\r\nadd_timer(&map->gc);\r\n}\r\nstatic bool\r\ninit_list_set(struct net *net, struct ip_set *set, u32 size)\r\n{\r\nstruct list_set *map;\r\nmap = kzalloc(sizeof(*map), GFP_KERNEL);\r\nif (!map)\r\nreturn false;\r\nmap->size = size;\r\nmap->net = net;\r\nINIT_LIST_HEAD(&map->members);\r\nset->data = map;\r\nreturn true;\r\n}\r\nstatic int\r\nlist_set_create(struct net *net, struct ip_set *set, struct nlattr *tb[],\r\nu32 flags)\r\n{\r\nu32 size = IP_SET_LIST_DEFAULT_SIZE;\r\nif (unlikely(!ip_set_optattr_netorder(tb, IPSET_ATTR_SIZE) ||\r\n!ip_set_optattr_netorder(tb, IPSET_ATTR_TIMEOUT) ||\r\n!ip_set_optattr_netorder(tb, IPSET_ATTR_CADT_FLAGS)))\r\nreturn -IPSET_ERR_PROTOCOL;\r\nif (tb[IPSET_ATTR_SIZE])\r\nsize = ip_set_get_h32(tb[IPSET_ATTR_SIZE]);\r\nif (size < IP_SET_LIST_MIN_SIZE)\r\nsize = IP_SET_LIST_MIN_SIZE;\r\nset->variant = &set_variant;\r\nset->dsize = ip_set_elem_len(set, tb, sizeof(struct set_elem),\r\n__alignof__(struct set_elem));\r\nif (!init_list_set(net, set, size))\r\nreturn -ENOMEM;\r\nif (tb[IPSET_ATTR_TIMEOUT]) {\r\nset->timeout = ip_set_timeout_uget(tb[IPSET_ATTR_TIMEOUT]);\r\nlist_set_gc_init(set, list_set_gc);\r\n}\r\nreturn 0;\r\n}\r\nstatic int __init\r\nlist_set_init(void)\r\n{\r\nreturn ip_set_type_register(&list_set_type);\r\n}\r\nstatic void __exit\r\nlist_set_fini(void)\r\n{\r\nrcu_barrier();\r\nip_set_type_unregister(&list_set_type);\r\n}
