static u8 rtl8xxxu_read8(struct rtl8xxxu_priv *priv, u16 addr)\r\n{\r\nstruct usb_device *udev = priv->udev;\r\nint len;\r\nu8 data;\r\nmutex_lock(&priv->usb_buf_mutex);\r\nlen = usb_control_msg(udev, usb_rcvctrlpipe(udev, 0),\r\nREALTEK_USB_CMD_REQ, REALTEK_USB_READ,\r\naddr, 0, &priv->usb_buf.val8, sizeof(u8),\r\nRTW_USB_CONTROL_MSG_TIMEOUT);\r\ndata = priv->usb_buf.val8;\r\nmutex_unlock(&priv->usb_buf_mutex);\r\nif (rtl8xxxu_debug & RTL8XXXU_DEBUG_REG_READ)\r\ndev_info(&udev->dev, "%s(%04x) = 0x%02x, len %i\n",\r\n__func__, addr, data, len);\r\nreturn data;\r\n}\r\nstatic u16 rtl8xxxu_read16(struct rtl8xxxu_priv *priv, u16 addr)\r\n{\r\nstruct usb_device *udev = priv->udev;\r\nint len;\r\nu16 data;\r\nmutex_lock(&priv->usb_buf_mutex);\r\nlen = usb_control_msg(udev, usb_rcvctrlpipe(udev, 0),\r\nREALTEK_USB_CMD_REQ, REALTEK_USB_READ,\r\naddr, 0, &priv->usb_buf.val16, sizeof(u16),\r\nRTW_USB_CONTROL_MSG_TIMEOUT);\r\ndata = le16_to_cpu(priv->usb_buf.val16);\r\nmutex_unlock(&priv->usb_buf_mutex);\r\nif (rtl8xxxu_debug & RTL8XXXU_DEBUG_REG_READ)\r\ndev_info(&udev->dev, "%s(%04x) = 0x%04x, len %i\n",\r\n__func__, addr, data, len);\r\nreturn data;\r\n}\r\nstatic u32 rtl8xxxu_read32(struct rtl8xxxu_priv *priv, u16 addr)\r\n{\r\nstruct usb_device *udev = priv->udev;\r\nint len;\r\nu32 data;\r\nmutex_lock(&priv->usb_buf_mutex);\r\nlen = usb_control_msg(udev, usb_rcvctrlpipe(udev, 0),\r\nREALTEK_USB_CMD_REQ, REALTEK_USB_READ,\r\naddr, 0, &priv->usb_buf.val32, sizeof(u32),\r\nRTW_USB_CONTROL_MSG_TIMEOUT);\r\ndata = le32_to_cpu(priv->usb_buf.val32);\r\nmutex_unlock(&priv->usb_buf_mutex);\r\nif (rtl8xxxu_debug & RTL8XXXU_DEBUG_REG_READ)\r\ndev_info(&udev->dev, "%s(%04x) = 0x%08x, len %i\n",\r\n__func__, addr, data, len);\r\nreturn data;\r\n}\r\nstatic int rtl8xxxu_write8(struct rtl8xxxu_priv *priv, u16 addr, u8 val)\r\n{\r\nstruct usb_device *udev = priv->udev;\r\nint ret;\r\nmutex_lock(&priv->usb_buf_mutex);\r\npriv->usb_buf.val8 = val;\r\nret = usb_control_msg(udev, usb_sndctrlpipe(udev, 0),\r\nREALTEK_USB_CMD_REQ, REALTEK_USB_WRITE,\r\naddr, 0, &priv->usb_buf.val8, sizeof(u8),\r\nRTW_USB_CONTROL_MSG_TIMEOUT);\r\nmutex_unlock(&priv->usb_buf_mutex);\r\nif (rtl8xxxu_debug & RTL8XXXU_DEBUG_REG_WRITE)\r\ndev_info(&udev->dev, "%s(%04x) = 0x%02x\n",\r\n__func__, addr, val);\r\nreturn ret;\r\n}\r\nstatic int rtl8xxxu_write16(struct rtl8xxxu_priv *priv, u16 addr, u16 val)\r\n{\r\nstruct usb_device *udev = priv->udev;\r\nint ret;\r\nmutex_lock(&priv->usb_buf_mutex);\r\npriv->usb_buf.val16 = cpu_to_le16(val);\r\nret = usb_control_msg(udev, usb_sndctrlpipe(udev, 0),\r\nREALTEK_USB_CMD_REQ, REALTEK_USB_WRITE,\r\naddr, 0, &priv->usb_buf.val16, sizeof(u16),\r\nRTW_USB_CONTROL_MSG_TIMEOUT);\r\nmutex_unlock(&priv->usb_buf_mutex);\r\nif (rtl8xxxu_debug & RTL8XXXU_DEBUG_REG_WRITE)\r\ndev_info(&udev->dev, "%s(%04x) = 0x%04x\n",\r\n__func__, addr, val);\r\nreturn ret;\r\n}\r\nstatic int rtl8xxxu_write32(struct rtl8xxxu_priv *priv, u16 addr, u32 val)\r\n{\r\nstruct usb_device *udev = priv->udev;\r\nint ret;\r\nmutex_lock(&priv->usb_buf_mutex);\r\npriv->usb_buf.val32 = cpu_to_le32(val);\r\nret = usb_control_msg(udev, usb_sndctrlpipe(udev, 0),\r\nREALTEK_USB_CMD_REQ, REALTEK_USB_WRITE,\r\naddr, 0, &priv->usb_buf.val32, sizeof(u32),\r\nRTW_USB_CONTROL_MSG_TIMEOUT);\r\nmutex_unlock(&priv->usb_buf_mutex);\r\nif (rtl8xxxu_debug & RTL8XXXU_DEBUG_REG_WRITE)\r\ndev_info(&udev->dev, "%s(%04x) = 0x%08x\n",\r\n__func__, addr, val);\r\nreturn ret;\r\n}\r\nstatic int\r\nrtl8xxxu_writeN(struct rtl8xxxu_priv *priv, u16 addr, u8 *buf, u16 len)\r\n{\r\nstruct usb_device *udev = priv->udev;\r\nint blocksize = priv->fops->writeN_block_size;\r\nint ret, i, count, remainder;\r\ncount = len / blocksize;\r\nremainder = len % blocksize;\r\nfor (i = 0; i < count; i++) {\r\nret = usb_control_msg(udev, usb_sndctrlpipe(udev, 0),\r\nREALTEK_USB_CMD_REQ, REALTEK_USB_WRITE,\r\naddr, 0, buf, blocksize,\r\nRTW_USB_CONTROL_MSG_TIMEOUT);\r\nif (ret != blocksize)\r\ngoto write_error;\r\naddr += blocksize;\r\nbuf += blocksize;\r\n}\r\nif (remainder) {\r\nret = usb_control_msg(udev, usb_sndctrlpipe(udev, 0),\r\nREALTEK_USB_CMD_REQ, REALTEK_USB_WRITE,\r\naddr, 0, buf, remainder,\r\nRTW_USB_CONTROL_MSG_TIMEOUT);\r\nif (ret != remainder)\r\ngoto write_error;\r\n}\r\nreturn len;\r\nwrite_error:\r\ndev_info(&udev->dev,\r\n"%s: Failed to write block at addr: %04x size: %04x\n",\r\n__func__, addr, blocksize);\r\nreturn -EAGAIN;\r\n}\r\nstatic u32 rtl8xxxu_read_rfreg(struct rtl8xxxu_priv *priv,\r\nenum rtl8xxxu_rfpath path, u8 reg)\r\n{\r\nu32 hssia, val32, retval;\r\nhssia = rtl8xxxu_read32(priv, REG_FPGA0_XA_HSSI_PARM2);\r\nif (path != RF_A)\r\nval32 = rtl8xxxu_read32(priv, rtl8xxxu_rfregs[path].hssiparm2);\r\nelse\r\nval32 = hssia;\r\nval32 &= ~FPGA0_HSSI_PARM2_ADDR_MASK;\r\nval32 |= (reg << FPGA0_HSSI_PARM2_ADDR_SHIFT);\r\nval32 |= FPGA0_HSSI_PARM2_EDGE_READ;\r\nhssia &= ~FPGA0_HSSI_PARM2_EDGE_READ;\r\nrtl8xxxu_write32(priv, REG_FPGA0_XA_HSSI_PARM2, hssia);\r\nudelay(10);\r\nrtl8xxxu_write32(priv, rtl8xxxu_rfregs[path].hssiparm2, val32);\r\nudelay(100);\r\nhssia |= FPGA0_HSSI_PARM2_EDGE_READ;\r\nrtl8xxxu_write32(priv, REG_FPGA0_XA_HSSI_PARM2, hssia);\r\nudelay(10);\r\nval32 = rtl8xxxu_read32(priv, rtl8xxxu_rfregs[path].hssiparm1);\r\nif (val32 & FPGA0_HSSI_PARM1_PI)\r\nretval = rtl8xxxu_read32(priv, rtl8xxxu_rfregs[path].hspiread);\r\nelse\r\nretval = rtl8xxxu_read32(priv, rtl8xxxu_rfregs[path].lssiread);\r\nretval &= 0xfffff;\r\nif (rtl8xxxu_debug & RTL8XXXU_DEBUG_RFREG_READ)\r\ndev_info(&priv->udev->dev, "%s(%02x) = 0x%06x\n",\r\n__func__, reg, retval);\r\nreturn retval;\r\n}\r\nstatic int rtl8xxxu_write_rfreg(struct rtl8xxxu_priv *priv,\r\nenum rtl8xxxu_rfpath path, u8 reg, u32 data)\r\n{\r\nint ret, retval;\r\nu32 dataaddr;\r\nif (rtl8xxxu_debug & RTL8XXXU_DEBUG_RFREG_WRITE)\r\ndev_info(&priv->udev->dev, "%s(%02x) = 0x%06x\n",\r\n__func__, reg, data);\r\ndata &= FPGA0_LSSI_PARM_DATA_MASK;\r\ndataaddr = (reg << FPGA0_LSSI_PARM_ADDR_SHIFT) | data;\r\nret = rtl8xxxu_write32(priv, rtl8xxxu_rfregs[path].lssiparm, dataaddr);\r\nif (ret != sizeof(dataaddr))\r\nretval = -EIO;\r\nelse\r\nretval = 0;\r\nudelay(1);\r\nreturn retval;\r\n}\r\nstatic int rtl8723a_h2c_cmd(struct rtl8xxxu_priv *priv, struct h2c_cmd *h2c)\r\n{\r\nstruct device *dev = &priv->udev->dev;\r\nint mbox_nr, retry, retval = 0;\r\nint mbox_reg, mbox_ext_reg;\r\nu8 val8;\r\nmutex_lock(&priv->h2c_mutex);\r\nmbox_nr = priv->next_mbox;\r\nmbox_reg = REG_HMBOX_0 + (mbox_nr * 4);\r\nmbox_ext_reg = REG_HMBOX_EXT_0 + (mbox_nr * 2);\r\nretry = 100;\r\ndo {\r\nval8 = rtl8xxxu_read8(priv, REG_HMTFR);\r\nif (!(val8 & BIT(mbox_nr)))\r\nbreak;\r\n} while (retry--);\r\nif (!retry) {\r\ndev_dbg(dev, "%s: Mailbox busy\n", __func__);\r\nretval = -EBUSY;\r\ngoto error;\r\n}\r\nif (h2c->cmd.cmd & H2C_EXT) {\r\nrtl8xxxu_write16(priv, mbox_ext_reg,\r\nle16_to_cpu(h2c->raw.ext));\r\nif (rtl8xxxu_debug & RTL8XXXU_DEBUG_H2C)\r\ndev_info(dev, "H2C_EXT %04x\n",\r\nle16_to_cpu(h2c->raw.ext));\r\n}\r\nrtl8xxxu_write32(priv, mbox_reg, le32_to_cpu(h2c->raw.data));\r\nif (rtl8xxxu_debug & RTL8XXXU_DEBUG_H2C)\r\ndev_info(dev, "H2C %08x\n", le32_to_cpu(h2c->raw.data));\r\npriv->next_mbox = (mbox_nr + 1) % H2C_MAX_MBOX;\r\nerror:\r\nmutex_unlock(&priv->h2c_mutex);\r\nreturn retval;\r\n}\r\nstatic void rtl8723a_enable_rf(struct rtl8xxxu_priv *priv)\r\n{\r\nu8 val8;\r\nu32 val32;\r\nval8 = rtl8xxxu_read8(priv, REG_SPS0_CTRL);\r\nval8 |= BIT(0) | BIT(3);\r\nrtl8xxxu_write8(priv, REG_SPS0_CTRL, val8);\r\nval32 = rtl8xxxu_read32(priv, REG_FPGA0_XAB_RF_PARM);\r\nval32 &= ~(BIT(4) | BIT(5));\r\nval32 |= BIT(3);\r\nif (priv->rf_paths == 2) {\r\nval32 &= ~(BIT(20) | BIT(21));\r\nval32 |= BIT(19);\r\n}\r\nrtl8xxxu_write32(priv, REG_FPGA0_XAB_RF_PARM, val32);\r\nval32 = rtl8xxxu_read32(priv, REG_OFDM0_TRX_PATH_ENABLE);\r\nval32 &= ~OFDM_RF_PATH_TX_MASK;\r\nif (priv->tx_paths == 2)\r\nval32 |= OFDM_RF_PATH_TX_A | OFDM_RF_PATH_TX_B;\r\nelse if (priv->rtlchip == 0x8192c || priv->rtlchip == 0x8191c)\r\nval32 |= OFDM_RF_PATH_TX_B;\r\nelse\r\nval32 |= OFDM_RF_PATH_TX_A;\r\nrtl8xxxu_write32(priv, REG_OFDM0_TRX_PATH_ENABLE, val32);\r\nval32 = rtl8xxxu_read32(priv, REG_FPGA0_RF_MODE);\r\nval32 &= ~FPGA_RF_MODE_JAPAN;\r\nrtl8xxxu_write32(priv, REG_FPGA0_RF_MODE, val32);\r\nif (priv->rf_paths == 2)\r\nrtl8xxxu_write32(priv, REG_RX_WAIT_CCA, 0x63db25a0);\r\nelse\r\nrtl8xxxu_write32(priv, REG_RX_WAIT_CCA, 0x631b25a0);\r\nrtl8xxxu_write_rfreg(priv, RF_A, RF6052_REG_AC, 0x32d95);\r\nif (priv->rf_paths == 2)\r\nrtl8xxxu_write_rfreg(priv, RF_B, RF6052_REG_AC, 0x32d95);\r\nrtl8xxxu_write8(priv, REG_TXPAUSE, 0x00);\r\n}\r\nstatic void rtl8723a_disable_rf(struct rtl8xxxu_priv *priv)\r\n{\r\nu8 sps0;\r\nu32 val32;\r\nrtl8xxxu_write8(priv, REG_TXPAUSE, 0xff);\r\nsps0 = rtl8xxxu_read8(priv, REG_SPS0_CTRL);\r\nval32 = rtl8xxxu_read32(priv, REG_FPGA0_XAB_RF_PARM);\r\nval32 &= ~(BIT(3) | BIT(4) | BIT(5));\r\nif (priv->rf_paths == 2)\r\nval32 &= ~(BIT(19) | BIT(20) | BIT(21));\r\nrtl8xxxu_write32(priv, REG_FPGA0_XAB_RF_PARM, val32);\r\nval32 = rtl8xxxu_read32(priv, REG_OFDM0_TRX_PATH_ENABLE);\r\nval32 &= ~OFDM_RF_PATH_TX_MASK;\r\nrtl8xxxu_write32(priv, REG_OFDM0_TRX_PATH_ENABLE, val32);\r\nval32 = rtl8xxxu_read32(priv, REG_FPGA0_RF_MODE);\r\nval32 |= FPGA_RF_MODE_JAPAN;\r\nrtl8xxxu_write32(priv, REG_FPGA0_RF_MODE, val32);\r\nif (priv->rf_paths == 2)\r\nrtl8xxxu_write32(priv, REG_RX_WAIT_CCA, 0x00db25a0);\r\nelse\r\nrtl8xxxu_write32(priv, REG_RX_WAIT_CCA, 0x001b25a0);\r\nrtl8xxxu_write_rfreg(priv, RF_A, RF6052_REG_AC, 0);\r\nif (priv->rf_paths == 2)\r\nrtl8xxxu_write_rfreg(priv, RF_B, RF6052_REG_AC, 0);\r\nsps0 &= ~(BIT(0) | BIT(3));\r\nrtl8xxxu_write8(priv, REG_SPS0_CTRL, sps0);\r\n}\r\nstatic void rtl8723a_stop_tx_beacon(struct rtl8xxxu_priv *priv)\r\n{\r\nu8 val8;\r\nval8 = rtl8xxxu_read8(priv, REG_FWHW_TXQ_CTRL + 2);\r\nval8 &= ~BIT(6);\r\nrtl8xxxu_write8(priv, REG_FWHW_TXQ_CTRL + 2, val8);\r\nrtl8xxxu_write8(priv, REG_TBTT_PROHIBIT + 1, 0x64);\r\nval8 = rtl8xxxu_read8(priv, REG_TBTT_PROHIBIT + 2);\r\nval8 &= ~BIT(0);\r\nrtl8xxxu_write8(priv, REG_TBTT_PROHIBIT + 2, val8);\r\n}\r\nstatic int rtl8723a_channel_to_group(int channel)\r\n{\r\nint group;\r\nif (channel < 4)\r\ngroup = 0;\r\nelse if (channel < 10)\r\ngroup = 1;\r\nelse\r\ngroup = 2;\r\nreturn group;\r\n}\r\nstatic void rtl8723au_config_channel(struct ieee80211_hw *hw)\r\n{\r\nstruct rtl8xxxu_priv *priv = hw->priv;\r\nu32 val32, rsr;\r\nu8 val8, opmode;\r\nbool ht = true;\r\nint sec_ch_above, channel;\r\nint i;\r\nopmode = rtl8xxxu_read8(priv, REG_BW_OPMODE);\r\nrsr = rtl8xxxu_read32(priv, REG_RESPONSE_RATE_SET);\r\nchannel = hw->conf.chandef.chan->hw_value;\r\nswitch (hw->conf.chandef.width) {\r\ncase NL80211_CHAN_WIDTH_20_NOHT:\r\nht = false;\r\ncase NL80211_CHAN_WIDTH_20:\r\nopmode |= BW_OPMODE_20MHZ;\r\nrtl8xxxu_write8(priv, REG_BW_OPMODE, opmode);\r\nval32 = rtl8xxxu_read32(priv, REG_FPGA0_RF_MODE);\r\nval32 &= ~FPGA_RF_MODE;\r\nrtl8xxxu_write32(priv, REG_FPGA0_RF_MODE, val32);\r\nval32 = rtl8xxxu_read32(priv, REG_FPGA1_RF_MODE);\r\nval32 &= ~FPGA_RF_MODE;\r\nrtl8xxxu_write32(priv, REG_FPGA1_RF_MODE, val32);\r\nval32 = rtl8xxxu_read32(priv, REG_FPGA0_ANALOG2);\r\nval32 |= FPGA0_ANALOG2_20MHZ;\r\nrtl8xxxu_write32(priv, REG_FPGA0_ANALOG2, val32);\r\nbreak;\r\ncase NL80211_CHAN_WIDTH_40:\r\nif (hw->conf.chandef.center_freq1 >\r\nhw->conf.chandef.chan->center_freq) {\r\nsec_ch_above = 1;\r\nchannel += 2;\r\n} else {\r\nsec_ch_above = 0;\r\nchannel -= 2;\r\n}\r\nopmode &= ~BW_OPMODE_20MHZ;\r\nrtl8xxxu_write8(priv, REG_BW_OPMODE, opmode);\r\nrsr &= ~RSR_RSC_BANDWIDTH_40M;\r\nif (sec_ch_above)\r\nrsr |= RSR_RSC_UPPER_SUB_CHANNEL;\r\nelse\r\nrsr |= RSR_RSC_LOWER_SUB_CHANNEL;\r\nrtl8xxxu_write32(priv, REG_RESPONSE_RATE_SET, rsr);\r\nval32 = rtl8xxxu_read32(priv, REG_FPGA0_RF_MODE);\r\nval32 |= FPGA_RF_MODE;\r\nrtl8xxxu_write32(priv, REG_FPGA0_RF_MODE, val32);\r\nval32 = rtl8xxxu_read32(priv, REG_FPGA1_RF_MODE);\r\nval32 |= FPGA_RF_MODE;\r\nrtl8xxxu_write32(priv, REG_FPGA1_RF_MODE, val32);\r\nval32 = rtl8xxxu_read32(priv, REG_CCK0_SYSTEM);\r\nval32 &= ~CCK0_SIDEBAND;\r\nif (!sec_ch_above)\r\nval32 |= CCK0_SIDEBAND;\r\nrtl8xxxu_write32(priv, REG_CCK0_SYSTEM, val32);\r\nval32 = rtl8xxxu_read32(priv, REG_OFDM1_LSTF);\r\nval32 &= ~OFDM_LSTF_PRIME_CH_MASK;\r\nif (sec_ch_above)\r\nval32 |= OFDM_LSTF_PRIME_CH_LOW;\r\nelse\r\nval32 |= OFDM_LSTF_PRIME_CH_HIGH;\r\nrtl8xxxu_write32(priv, REG_OFDM1_LSTF, val32);\r\nval32 = rtl8xxxu_read32(priv, REG_FPGA0_ANALOG2);\r\nval32 &= ~FPGA0_ANALOG2_20MHZ;\r\nrtl8xxxu_write32(priv, REG_FPGA0_ANALOG2, val32);\r\nval32 = rtl8xxxu_read32(priv, REG_FPGA0_POWER_SAVE);\r\nval32 &= ~(FPGA0_PS_LOWER_CHANNEL | FPGA0_PS_UPPER_CHANNEL);\r\nif (sec_ch_above)\r\nval32 |= FPGA0_PS_UPPER_CHANNEL;\r\nelse\r\nval32 |= FPGA0_PS_LOWER_CHANNEL;\r\nrtl8xxxu_write32(priv, REG_FPGA0_POWER_SAVE, val32);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nfor (i = RF_A; i < priv->rf_paths; i++) {\r\nval32 = rtl8xxxu_read_rfreg(priv, i, RF6052_REG_MODE_AG);\r\nval32 &= ~MODE_AG_CHANNEL_MASK;\r\nval32 |= channel;\r\nrtl8xxxu_write_rfreg(priv, i, RF6052_REG_MODE_AG, val32);\r\n}\r\nif (ht)\r\nval8 = 0x0e;\r\nelse\r\nval8 = 0x0a;\r\nrtl8xxxu_write8(priv, REG_SIFS_CCK + 1, val8);\r\nrtl8xxxu_write8(priv, REG_SIFS_OFDM + 1, val8);\r\nrtl8xxxu_write16(priv, REG_R2T_SIFS, 0x0808);\r\nrtl8xxxu_write16(priv, REG_T2T_SIFS, 0x0a0a);\r\nfor (i = RF_A; i < priv->rf_paths; i++) {\r\nval32 = rtl8xxxu_read_rfreg(priv, i, RF6052_REG_MODE_AG);\r\nif (hw->conf.chandef.width == NL80211_CHAN_WIDTH_40)\r\nval32 &= ~MODE_AG_CHANNEL_20MHZ;\r\nelse\r\nval32 |= MODE_AG_CHANNEL_20MHZ;\r\nrtl8xxxu_write_rfreg(priv, i, RF6052_REG_MODE_AG, val32);\r\n}\r\n}\r\nstatic void\r\nrtl8723a_set_tx_power(struct rtl8xxxu_priv *priv, int channel, bool ht40)\r\n{\r\nu8 cck[RTL8723A_MAX_RF_PATHS], ofdm[RTL8723A_MAX_RF_PATHS];\r\nu8 ofdmbase[RTL8723A_MAX_RF_PATHS], mcsbase[RTL8723A_MAX_RF_PATHS];\r\nu32 val32, ofdm_a, ofdm_b, mcs_a, mcs_b;\r\nu8 val8;\r\nint group, i;\r\ngroup = rtl8723a_channel_to_group(channel);\r\ncck[0] = priv->cck_tx_power_index_A[group];\r\ncck[1] = priv->cck_tx_power_index_B[group];\r\nofdm[0] = priv->ht40_1s_tx_power_index_A[group];\r\nofdm[1] = priv->ht40_1s_tx_power_index_B[group];\r\nofdmbase[0] = ofdm[0] + priv->ofdm_tx_power_index_diff[group].a;\r\nofdmbase[1] = ofdm[1] + priv->ofdm_tx_power_index_diff[group].b;\r\nmcsbase[0] = ofdm[0];\r\nmcsbase[1] = ofdm[1];\r\nif (!ht40) {\r\nmcsbase[0] += priv->ht20_tx_power_index_diff[group].a;\r\nmcsbase[1] += priv->ht20_tx_power_index_diff[group].b;\r\n}\r\nif (priv->tx_paths > 1) {\r\nif (ofdm[0] > priv->ht40_2s_tx_power_index_diff[group].a)\r\nofdm[0] -= priv->ht40_2s_tx_power_index_diff[group].a;\r\nif (ofdm[1] > priv->ht40_2s_tx_power_index_diff[group].b)\r\nofdm[1] -= priv->ht40_2s_tx_power_index_diff[group].b;\r\n}\r\nif (rtl8xxxu_debug & RTL8XXXU_DEBUG_CHANNEL)\r\ndev_info(&priv->udev->dev,\r\n"%s: Setting TX power CCK A: %02x, "\r\n"CCK B: %02x, OFDM A: %02x, OFDM B: %02x\n",\r\n__func__, cck[0], cck[1], ofdm[0], ofdm[1]);\r\nfor (i = 0; i < RTL8723A_MAX_RF_PATHS; i++) {\r\nif (cck[i] > RF6052_MAX_TX_PWR)\r\ncck[i] = RF6052_MAX_TX_PWR;\r\nif (ofdm[i] > RF6052_MAX_TX_PWR)\r\nofdm[i] = RF6052_MAX_TX_PWR;\r\n}\r\nval32 = rtl8xxxu_read32(priv, REG_TX_AGC_A_CCK1_MCS32);\r\nval32 &= 0xffff00ff;\r\nval32 |= (cck[0] << 8);\r\nrtl8xxxu_write32(priv, REG_TX_AGC_A_CCK1_MCS32, val32);\r\nval32 = rtl8xxxu_read32(priv, REG_TX_AGC_B_CCK11_A_CCK2_11);\r\nval32 &= 0xff;\r\nval32 |= ((cck[0] << 8) | (cck[0] << 16) | (cck[0] << 24));\r\nrtl8xxxu_write32(priv, REG_TX_AGC_B_CCK11_A_CCK2_11, val32);\r\nval32 = rtl8xxxu_read32(priv, REG_TX_AGC_B_CCK11_A_CCK2_11);\r\nval32 &= 0xffffff00;\r\nval32 |= cck[1];\r\nrtl8xxxu_write32(priv, REG_TX_AGC_B_CCK11_A_CCK2_11, val32);\r\nval32 = rtl8xxxu_read32(priv, REG_TX_AGC_B_CCK1_55_MCS32);\r\nval32 &= 0xff;\r\nval32 |= ((cck[1] << 8) | (cck[1] << 16) | (cck[1] << 24));\r\nrtl8xxxu_write32(priv, REG_TX_AGC_B_CCK1_55_MCS32, val32);\r\nofdm_a = ofdmbase[0] | ofdmbase[0] << 8 |\r\nofdmbase[0] << 16 | ofdmbase[0] << 24;\r\nofdm_b = ofdmbase[1] | ofdmbase[1] << 8 |\r\nofdmbase[1] << 16 | ofdmbase[1] << 24;\r\nrtl8xxxu_write32(priv, REG_TX_AGC_A_RATE18_06, ofdm_a);\r\nrtl8xxxu_write32(priv, REG_TX_AGC_B_RATE18_06, ofdm_b);\r\nrtl8xxxu_write32(priv, REG_TX_AGC_A_RATE54_24, ofdm_a);\r\nrtl8xxxu_write32(priv, REG_TX_AGC_B_RATE54_24, ofdm_b);\r\nmcs_a = mcsbase[0] | mcsbase[0] << 8 |\r\nmcsbase[0] << 16 | mcsbase[0] << 24;\r\nmcs_b = mcsbase[1] | mcsbase[1] << 8 |\r\nmcsbase[1] << 16 | mcsbase[1] << 24;\r\nrtl8xxxu_write32(priv, REG_TX_AGC_A_MCS03_MCS00, mcs_a);\r\nrtl8xxxu_write32(priv, REG_TX_AGC_B_MCS03_MCS00, mcs_b);\r\nrtl8xxxu_write32(priv, REG_TX_AGC_A_MCS07_MCS04, mcs_a);\r\nrtl8xxxu_write32(priv, REG_TX_AGC_B_MCS07_MCS04, mcs_b);\r\nrtl8xxxu_write32(priv, REG_TX_AGC_A_MCS11_MCS08, mcs_a);\r\nrtl8xxxu_write32(priv, REG_TX_AGC_B_MCS11_MCS08, mcs_b);\r\nrtl8xxxu_write32(priv, REG_TX_AGC_A_MCS15_MCS12, mcs_a);\r\nfor (i = 0; i < 3; i++) {\r\nif (i != 2)\r\nval8 = (mcsbase[0] > 8) ? (mcsbase[0] - 8) : 0;\r\nelse\r\nval8 = (mcsbase[0] > 6) ? (mcsbase[0] - 6) : 0;\r\nrtl8xxxu_write8(priv, REG_OFDM0_XC_TX_IQ_IMBALANCE + i, val8);\r\n}\r\nrtl8xxxu_write32(priv, REG_TX_AGC_B_MCS15_MCS12, mcs_b);\r\nfor (i = 0; i < 3; i++) {\r\nif (i != 2)\r\nval8 = (mcsbase[1] > 8) ? (mcsbase[1] - 8) : 0;\r\nelse\r\nval8 = (mcsbase[1] > 6) ? (mcsbase[1] - 6) : 0;\r\nrtl8xxxu_write8(priv, REG_OFDM0_XD_TX_IQ_IMBALANCE + i, val8);\r\n}\r\n}\r\nstatic void rtl8xxxu_set_linktype(struct rtl8xxxu_priv *priv,\r\nenum nl80211_iftype linktype)\r\n{\r\nu16 val8;\r\nval8 = rtl8xxxu_read16(priv, REG_MSR);\r\nval8 &= ~MSR_LINKTYPE_MASK;\r\nswitch (linktype) {\r\ncase NL80211_IFTYPE_UNSPECIFIED:\r\nval8 |= MSR_LINKTYPE_NONE;\r\nbreak;\r\ncase NL80211_IFTYPE_ADHOC:\r\nval8 |= MSR_LINKTYPE_ADHOC;\r\nbreak;\r\ncase NL80211_IFTYPE_STATION:\r\nval8 |= MSR_LINKTYPE_STATION;\r\nbreak;\r\ncase NL80211_IFTYPE_AP:\r\nval8 |= MSR_LINKTYPE_AP;\r\nbreak;\r\ndefault:\r\ngoto out;\r\n}\r\nrtl8xxxu_write8(priv, REG_MSR, val8);\r\nout:\r\nreturn;\r\n}\r\nstatic void\r\nrtl8xxxu_set_retry(struct rtl8xxxu_priv *priv, u16 short_retry, u16 long_retry)\r\n{\r\nu16 val16;\r\nval16 = ((short_retry << RETRY_LIMIT_SHORT_SHIFT) &\r\nRETRY_LIMIT_SHORT_MASK) |\r\n((long_retry << RETRY_LIMIT_LONG_SHIFT) &\r\nRETRY_LIMIT_LONG_MASK);\r\nrtl8xxxu_write16(priv, REG_RETRY_LIMIT, val16);\r\n}\r\nstatic void\r\nrtl8xxxu_set_spec_sifs(struct rtl8xxxu_priv *priv, u16 cck, u16 ofdm)\r\n{\r\nu16 val16;\r\nval16 = ((cck << SPEC_SIFS_CCK_SHIFT) & SPEC_SIFS_CCK_MASK) |\r\n((ofdm << SPEC_SIFS_OFDM_SHIFT) & SPEC_SIFS_OFDM_MASK);\r\nrtl8xxxu_write16(priv, REG_SPEC_SIFS, val16);\r\n}\r\nstatic void rtl8xxxu_print_chipinfo(struct rtl8xxxu_priv *priv)\r\n{\r\nstruct device *dev = &priv->udev->dev;\r\nchar *cut;\r\nswitch (priv->chip_cut) {\r\ncase 0:\r\ncut = "A";\r\nbreak;\r\ncase 1:\r\ncut = "B";\r\nbreak;\r\ndefault:\r\ncut = "unknown";\r\n}\r\ndev_info(dev,\r\n"RTL%s rev %s (%s) %iT%iR, TX queues %i, WiFi=%i, BT=%i, GPS=%i, HI PA=%i\n",\r\npriv->chip_name, cut, priv->vendor_umc ? "UMC" : "TSMC",\r\npriv->tx_paths, priv->rx_paths, priv->ep_tx_count,\r\npriv->has_wifi, priv->has_bluetooth, priv->has_gps,\r\npriv->hi_pa);\r\ndev_info(dev, "RTL%s MAC: %pM\n", priv->chip_name, priv->mac_addr);\r\n}\r\nstatic int rtl8xxxu_identify_chip(struct rtl8xxxu_priv *priv)\r\n{\r\nstruct device *dev = &priv->udev->dev;\r\nu32 val32, bonding;\r\nu16 val16;\r\nval32 = rtl8xxxu_read32(priv, REG_SYS_CFG);\r\npriv->chip_cut = (val32 & SYS_CFG_CHIP_VERSION_MASK) >>\r\nSYS_CFG_CHIP_VERSION_SHIFT;\r\nif (val32 & SYS_CFG_TRP_VAUX_EN) {\r\ndev_info(dev, "Unsupported test chip\n");\r\nreturn -ENOTSUPP;\r\n}\r\nif (val32 & SYS_CFG_BT_FUNC) {\r\nsprintf(priv->chip_name, "8723AU");\r\npriv->rf_paths = 1;\r\npriv->rx_paths = 1;\r\npriv->tx_paths = 1;\r\npriv->rtlchip = 0x8723a;\r\nval32 = rtl8xxxu_read32(priv, REG_MULTI_FUNC_CTRL);\r\nif (val32 & MULTI_WIFI_FUNC_EN)\r\npriv->has_wifi = 1;\r\nif (val32 & MULTI_BT_FUNC_EN)\r\npriv->has_bluetooth = 1;\r\nif (val32 & MULTI_GPS_FUNC_EN)\r\npriv->has_gps = 1;\r\n} else if (val32 & SYS_CFG_TYPE_ID) {\r\nbonding = rtl8xxxu_read32(priv, REG_HPON_FSM);\r\nbonding &= HPON_FSM_BONDING_MASK;\r\nif (bonding == HPON_FSM_BONDING_1T2R) {\r\nsprintf(priv->chip_name, "8191CU");\r\npriv->rf_paths = 2;\r\npriv->rx_paths = 2;\r\npriv->tx_paths = 1;\r\npriv->rtlchip = 0x8191c;\r\n} else {\r\nsprintf(priv->chip_name, "8192CU");\r\npriv->rf_paths = 2;\r\npriv->rx_paths = 2;\r\npriv->tx_paths = 2;\r\npriv->rtlchip = 0x8192c;\r\n}\r\npriv->has_wifi = 1;\r\n} else {\r\nsprintf(priv->chip_name, "8188CU");\r\npriv->rf_paths = 1;\r\npriv->rx_paths = 1;\r\npriv->tx_paths = 1;\r\npriv->rtlchip = 0x8188c;\r\npriv->has_wifi = 1;\r\n}\r\nif (val32 & SYS_CFG_VENDOR_ID)\r\npriv->vendor_umc = 1;\r\nval32 = rtl8xxxu_read32(priv, REG_GPIO_OUTSTS);\r\npriv->rom_rev = (val32 & GPIO_RF_RL_ID) >> 28;\r\nval16 = rtl8xxxu_read16(priv, REG_NORMAL_SIE_EP_TX);\r\nif (val16 & NORMAL_SIE_EP_TX_HIGH_MASK) {\r\npriv->ep_tx_high_queue = 1;\r\npriv->ep_tx_count++;\r\n}\r\nif (val16 & NORMAL_SIE_EP_TX_NORMAL_MASK) {\r\npriv->ep_tx_normal_queue = 1;\r\npriv->ep_tx_count++;\r\n}\r\nif (val16 & NORMAL_SIE_EP_TX_LOW_MASK) {\r\npriv->ep_tx_low_queue = 1;\r\npriv->ep_tx_count++;\r\n}\r\nif (!priv->ep_tx_count) {\r\nswitch (priv->nr_out_eps) {\r\ncase 3:\r\npriv->ep_tx_low_queue = 1;\r\npriv->ep_tx_count++;\r\ncase 2:\r\npriv->ep_tx_normal_queue = 1;\r\npriv->ep_tx_count++;\r\ncase 1:\r\npriv->ep_tx_high_queue = 1;\r\npriv->ep_tx_count++;\r\nbreak;\r\ndefault:\r\ndev_info(dev, "Unsupported USB TX end-points\n");\r\nreturn -ENOTSUPP;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int rtl8723au_parse_efuse(struct rtl8xxxu_priv *priv)\r\n{\r\nif (priv->efuse_wifi.efuse8723.rtl_id != cpu_to_le16(0x8129))\r\nreturn -EINVAL;\r\nether_addr_copy(priv->mac_addr, priv->efuse_wifi.efuse8723.mac_addr);\r\nmemcpy(priv->cck_tx_power_index_A,\r\npriv->efuse_wifi.efuse8723.cck_tx_power_index_A,\r\nsizeof(priv->cck_tx_power_index_A));\r\nmemcpy(priv->cck_tx_power_index_B,\r\npriv->efuse_wifi.efuse8723.cck_tx_power_index_B,\r\nsizeof(priv->cck_tx_power_index_B));\r\nmemcpy(priv->ht40_1s_tx_power_index_A,\r\npriv->efuse_wifi.efuse8723.ht40_1s_tx_power_index_A,\r\nsizeof(priv->ht40_1s_tx_power_index_A));\r\nmemcpy(priv->ht40_1s_tx_power_index_B,\r\npriv->efuse_wifi.efuse8723.ht40_1s_tx_power_index_B,\r\nsizeof(priv->ht40_1s_tx_power_index_B));\r\nmemcpy(priv->ht20_tx_power_index_diff,\r\npriv->efuse_wifi.efuse8723.ht20_tx_power_index_diff,\r\nsizeof(priv->ht20_tx_power_index_diff));\r\nmemcpy(priv->ofdm_tx_power_index_diff,\r\npriv->efuse_wifi.efuse8723.ofdm_tx_power_index_diff,\r\nsizeof(priv->ofdm_tx_power_index_diff));\r\nmemcpy(priv->ht40_max_power_offset,\r\npriv->efuse_wifi.efuse8723.ht40_max_power_offset,\r\nsizeof(priv->ht40_max_power_offset));\r\nmemcpy(priv->ht20_max_power_offset,\r\npriv->efuse_wifi.efuse8723.ht20_max_power_offset,\r\nsizeof(priv->ht20_max_power_offset));\r\ndev_info(&priv->udev->dev, "Vendor: %.7s\n",\r\npriv->efuse_wifi.efuse8723.vendor_name);\r\ndev_info(&priv->udev->dev, "Product: %.41s\n",\r\npriv->efuse_wifi.efuse8723.device_name);\r\nreturn 0;\r\n}\r\nstatic int rtl8192cu_parse_efuse(struct rtl8xxxu_priv *priv)\r\n{\r\nint i;\r\nif (priv->efuse_wifi.efuse8192.rtl_id != cpu_to_le16(0x8129))\r\nreturn -EINVAL;\r\nether_addr_copy(priv->mac_addr, priv->efuse_wifi.efuse8192.mac_addr);\r\nmemcpy(priv->cck_tx_power_index_A,\r\npriv->efuse_wifi.efuse8192.cck_tx_power_index_A,\r\nsizeof(priv->cck_tx_power_index_A));\r\nmemcpy(priv->cck_tx_power_index_B,\r\npriv->efuse_wifi.efuse8192.cck_tx_power_index_B,\r\nsizeof(priv->cck_tx_power_index_B));\r\nmemcpy(priv->ht40_1s_tx_power_index_A,\r\npriv->efuse_wifi.efuse8192.ht40_1s_tx_power_index_A,\r\nsizeof(priv->ht40_1s_tx_power_index_A));\r\nmemcpy(priv->ht40_1s_tx_power_index_B,\r\npriv->efuse_wifi.efuse8192.ht40_1s_tx_power_index_B,\r\nsizeof(priv->ht40_1s_tx_power_index_B));\r\nmemcpy(priv->ht40_2s_tx_power_index_diff,\r\npriv->efuse_wifi.efuse8192.ht40_2s_tx_power_index_diff,\r\nsizeof(priv->ht40_2s_tx_power_index_diff));\r\nmemcpy(priv->ht20_tx_power_index_diff,\r\npriv->efuse_wifi.efuse8192.ht20_tx_power_index_diff,\r\nsizeof(priv->ht20_tx_power_index_diff));\r\nmemcpy(priv->ofdm_tx_power_index_diff,\r\npriv->efuse_wifi.efuse8192.ofdm_tx_power_index_diff,\r\nsizeof(priv->ofdm_tx_power_index_diff));\r\nmemcpy(priv->ht40_max_power_offset,\r\npriv->efuse_wifi.efuse8192.ht40_max_power_offset,\r\nsizeof(priv->ht40_max_power_offset));\r\nmemcpy(priv->ht20_max_power_offset,\r\npriv->efuse_wifi.efuse8192.ht20_max_power_offset,\r\nsizeof(priv->ht20_max_power_offset));\r\ndev_info(&priv->udev->dev, "Vendor: %.7s\n",\r\npriv->efuse_wifi.efuse8192.vendor_name);\r\ndev_info(&priv->udev->dev, "Product: %.20s\n",\r\npriv->efuse_wifi.efuse8192.device_name);\r\nif (priv->efuse_wifi.efuse8192.rf_regulatory & 0x20) {\r\nsprintf(priv->chip_name, "8188RU");\r\npriv->hi_pa = 1;\r\n}\r\nif (rtl8xxxu_debug & RTL8XXXU_DEBUG_EFUSE) {\r\nunsigned char *raw = priv->efuse_wifi.raw;\r\ndev_info(&priv->udev->dev,\r\n"%s: dumping efuse (0x%02zx bytes):\n",\r\n__func__, sizeof(struct rtl8192cu_efuse));\r\nfor (i = 0; i < sizeof(struct rtl8192cu_efuse); i += 8) {\r\ndev_info(&priv->udev->dev, "%02x: "\r\n"%02x %02x %02x %02x %02x %02x %02x %02x\n", i,\r\nraw[i], raw[i + 1], raw[i + 2],\r\nraw[i + 3], raw[i + 4], raw[i + 5],\r\nraw[i + 6], raw[i + 7]);\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int\r\nrtl8xxxu_read_efuse8(struct rtl8xxxu_priv *priv, u16 offset, u8 *data)\r\n{\r\nint i;\r\nu8 val8;\r\nu32 val32;\r\nrtl8xxxu_write8(priv, REG_EFUSE_CTRL + 1, offset & 0xff);\r\nval8 = rtl8xxxu_read8(priv, REG_EFUSE_CTRL + 2);\r\nval8 &= 0xfc;\r\nval8 |= (offset >> 8) & 0x03;\r\nrtl8xxxu_write8(priv, REG_EFUSE_CTRL + 2, val8);\r\nval8 = rtl8xxxu_read8(priv, REG_EFUSE_CTRL + 3);\r\nrtl8xxxu_write8(priv, REG_EFUSE_CTRL + 3, val8 & 0x7f);\r\nval32 = rtl8xxxu_read32(priv, REG_EFUSE_CTRL);\r\nfor (i = 0; i < RTL8XXXU_MAX_REG_POLL; i++) {\r\nval32 = rtl8xxxu_read32(priv, REG_EFUSE_CTRL);\r\nif (val32 & BIT(31))\r\nbreak;\r\n}\r\nif (i == RTL8XXXU_MAX_REG_POLL)\r\nreturn -EIO;\r\nudelay(50);\r\nval32 = rtl8xxxu_read32(priv, REG_EFUSE_CTRL);\r\n*data = val32 & 0xff;\r\nreturn 0;\r\n}\r\nstatic int rtl8xxxu_read_efuse(struct rtl8xxxu_priv *priv)\r\n{\r\nstruct device *dev = &priv->udev->dev;\r\nint i, ret = 0;\r\nu8 val8, word_mask, header, extheader;\r\nu16 val16, efuse_addr, offset;\r\nu32 val32;\r\nval16 = rtl8xxxu_read16(priv, REG_9346CR);\r\nif (val16 & EEPROM_ENABLE)\r\npriv->has_eeprom = 1;\r\nif (val16 & EEPROM_BOOT)\r\npriv->boot_eeprom = 1;\r\nval32 = rtl8xxxu_read32(priv, REG_EFUSE_TEST);\r\nval32 = (val32 & ~EFUSE_SELECT_MASK) | EFUSE_WIFI_SELECT;\r\nrtl8xxxu_write32(priv, REG_EFUSE_TEST, val32);\r\ndev_dbg(dev, "Booting from %s\n",\r\npriv->boot_eeprom ? "EEPROM" : "EFUSE");\r\nrtl8xxxu_write8(priv, REG_EFUSE_ACCESS, EFUSE_ACCESS_ENABLE);\r\nval16 = rtl8xxxu_read16(priv, REG_SYS_ISO_CTRL);\r\nif (!(val16 & SYS_ISO_PWC_EV12V)) {\r\nval16 |= SYS_ISO_PWC_EV12V;\r\nrtl8xxxu_write16(priv, REG_SYS_ISO_CTRL, val16);\r\n}\r\nval16 = rtl8xxxu_read16(priv, REG_SYS_FUNC);\r\nif (!(val16 & SYS_FUNC_ELDR)) {\r\nval16 |= SYS_FUNC_ELDR;\r\nrtl8xxxu_write16(priv, REG_SYS_FUNC, val16);\r\n}\r\nval16 = rtl8xxxu_read16(priv, REG_SYS_CLKR);\r\nif (!(val16 & SYS_CLK_LOADER_ENABLE) || !(val16 & SYS_CLK_ANA8M)) {\r\nval16 |= (SYS_CLK_LOADER_ENABLE | SYS_CLK_ANA8M);\r\nrtl8xxxu_write16(priv, REG_SYS_CLKR, val16);\r\n}\r\nmemset(priv->efuse_wifi.raw, 0xff, EFUSE_MAP_LEN_8723A);\r\nefuse_addr = 0;\r\nwhile (efuse_addr < EFUSE_REAL_CONTENT_LEN_8723A) {\r\nret = rtl8xxxu_read_efuse8(priv, efuse_addr++, &header);\r\nif (ret || header == 0xff)\r\ngoto exit;\r\nif ((header & 0x1f) == 0x0f) {\r\noffset = (header & 0xe0) >> 5;\r\nret = rtl8xxxu_read_efuse8(priv, efuse_addr++,\r\n&extheader);\r\nif (ret)\r\ngoto exit;\r\nif ((extheader & 0x0f) == 0x0f)\r\ncontinue;\r\noffset |= ((extheader & 0xf0) >> 1);\r\nword_mask = extheader & 0x0f;\r\n} else {\r\noffset = (header >> 4) & 0x0f;\r\nword_mask = header & 0x0f;\r\n}\r\nif (offset < EFUSE_MAX_SECTION_8723A) {\r\nu16 map_addr;\r\nmap_addr = offset * 8;\r\nif (map_addr >= EFUSE_MAP_LEN_8723A) {\r\ndev_warn(dev, "%s: Illegal map_addr (%04x), "\r\n"efuse corrupt!\n",\r\n__func__, map_addr);\r\nret = -EINVAL;\r\ngoto exit;\r\n}\r\nfor (i = 0; i < EFUSE_MAX_WORD_UNIT; i++) {\r\nif (!(word_mask & BIT(i))) {\r\nret = rtl8xxxu_read_efuse8(priv,\r\nefuse_addr++,\r\n&val8);\r\nif (ret)\r\ngoto exit;\r\npriv->efuse_wifi.raw[map_addr++] = val8;\r\nret = rtl8xxxu_read_efuse8(priv,\r\nefuse_addr++,\r\n&val8);\r\nif (ret)\r\ngoto exit;\r\npriv->efuse_wifi.raw[map_addr++] = val8;\r\n} else\r\nmap_addr += 2;\r\n}\r\n} else {\r\ndev_warn(dev,\r\n"%s: Illegal offset (%04x), efuse corrupt!\n",\r\n__func__, offset);\r\nret = -EINVAL;\r\ngoto exit;\r\n}\r\n}\r\nexit:\r\nrtl8xxxu_write8(priv, REG_EFUSE_ACCESS, EFUSE_ACCESS_DISABLE);\r\nreturn ret;\r\n}\r\nstatic int rtl8xxxu_start_firmware(struct rtl8xxxu_priv *priv)\r\n{\r\nstruct device *dev = &priv->udev->dev;\r\nint ret = 0, i;\r\nu32 val32;\r\nfor (i = 0; i < RTL8XXXU_FIRMWARE_POLL_MAX; i++) {\r\nval32 = rtl8xxxu_read32(priv, REG_MCU_FW_DL);\r\nif (val32 & MCU_FW_DL_CSUM_REPORT)\r\nbreak;\r\n}\r\nif (i == RTL8XXXU_FIRMWARE_POLL_MAX) {\r\ndev_warn(dev, "Firmware checksum poll timed out\n");\r\nret = -EAGAIN;\r\ngoto exit;\r\n}\r\nval32 = rtl8xxxu_read32(priv, REG_MCU_FW_DL);\r\nval32 |= MCU_FW_DL_READY;\r\nval32 &= ~MCU_WINT_INIT_READY;\r\nrtl8xxxu_write32(priv, REG_MCU_FW_DL, val32);\r\nfor (i = 0; i < RTL8XXXU_FIRMWARE_POLL_MAX; i++) {\r\nval32 = rtl8xxxu_read32(priv, REG_MCU_FW_DL);\r\nif (val32 & MCU_WINT_INIT_READY)\r\nbreak;\r\nudelay(100);\r\n}\r\nif (i == RTL8XXXU_FIRMWARE_POLL_MAX) {\r\ndev_warn(dev, "Firmware failed to start\n");\r\nret = -EAGAIN;\r\ngoto exit;\r\n}\r\nexit:\r\nreturn ret;\r\n}\r\nstatic int rtl8xxxu_download_firmware(struct rtl8xxxu_priv *priv)\r\n{\r\nint pages, remainder, i, ret;\r\nu8 val8;\r\nu16 val16;\r\nu32 val32;\r\nu8 *fwptr;\r\nval8 = rtl8xxxu_read8(priv, REG_SYS_FUNC + 1);\r\nval8 |= 4;\r\nrtl8xxxu_write8(priv, REG_SYS_FUNC + 1, val8);\r\nval16 = rtl8xxxu_read16(priv, REG_SYS_FUNC);\r\nrtl8xxxu_write16(priv, REG_SYS_FUNC, val16 | SYS_FUNC_CPU_ENABLE);\r\nval8 = rtl8xxxu_read8(priv, REG_MCU_FW_DL);\r\nrtl8xxxu_write8(priv, REG_MCU_FW_DL, val8 | MCU_FW_DL_ENABLE);\r\nval32 = rtl8xxxu_read32(priv, REG_MCU_FW_DL);\r\nrtl8xxxu_write32(priv, REG_MCU_FW_DL, val32 & ~BIT(19));\r\nval8 = rtl8xxxu_read8(priv, REG_MCU_FW_DL);\r\nrtl8xxxu_write8(priv, REG_MCU_FW_DL, val8 | MCU_FW_DL_CSUM_REPORT);\r\npages = priv->fw_size / RTL_FW_PAGE_SIZE;\r\nremainder = priv->fw_size % RTL_FW_PAGE_SIZE;\r\nfwptr = priv->fw_data->data;\r\nfor (i = 0; i < pages; i++) {\r\nval8 = rtl8xxxu_read8(priv, REG_MCU_FW_DL + 2) & 0xF8;\r\nrtl8xxxu_write8(priv, REG_MCU_FW_DL + 2, val8 | i);\r\nret = rtl8xxxu_writeN(priv, REG_FW_START_ADDRESS,\r\nfwptr, RTL_FW_PAGE_SIZE);\r\nif (ret != RTL_FW_PAGE_SIZE) {\r\nret = -EAGAIN;\r\ngoto fw_abort;\r\n}\r\nfwptr += RTL_FW_PAGE_SIZE;\r\n}\r\nif (remainder) {\r\nval8 = rtl8xxxu_read8(priv, REG_MCU_FW_DL + 2) & 0xF8;\r\nrtl8xxxu_write8(priv, REG_MCU_FW_DL + 2, val8 | i);\r\nret = rtl8xxxu_writeN(priv, REG_FW_START_ADDRESS,\r\nfwptr, remainder);\r\nif (ret != remainder) {\r\nret = -EAGAIN;\r\ngoto fw_abort;\r\n}\r\n}\r\nret = 0;\r\nfw_abort:\r\nval16 = rtl8xxxu_read16(priv, REG_MCU_FW_DL);\r\nrtl8xxxu_write16(priv, REG_MCU_FW_DL,\r\nval16 & (~MCU_FW_DL_ENABLE & 0xff));\r\nreturn ret;\r\n}\r\nstatic int rtl8xxxu_load_firmware(struct rtl8xxxu_priv *priv, char *fw_name)\r\n{\r\nstruct device *dev = &priv->udev->dev;\r\nconst struct firmware *fw;\r\nint ret = 0;\r\nu16 signature;\r\ndev_info(dev, "%s: Loading firmware %s\n", DRIVER_NAME, fw_name);\r\nif (request_firmware(&fw, fw_name, &priv->udev->dev)) {\r\ndev_warn(dev, "request_firmware(%s) failed\n", fw_name);\r\nret = -EAGAIN;\r\ngoto exit;\r\n}\r\nif (!fw) {\r\ndev_warn(dev, "Firmware data not available\n");\r\nret = -EINVAL;\r\ngoto exit;\r\n}\r\npriv->fw_data = kmemdup(fw->data, fw->size, GFP_KERNEL);\r\npriv->fw_size = fw->size - sizeof(struct rtl8xxxu_firmware_header);\r\nsignature = le16_to_cpu(priv->fw_data->signature);\r\nswitch (signature & 0xfff0) {\r\ncase 0x92c0:\r\ncase 0x88c0:\r\ncase 0x2300:\r\nbreak;\r\ndefault:\r\nret = -EINVAL;\r\ndev_warn(dev, "%s: Invalid firmware signature: 0x%04x\n",\r\n__func__, signature);\r\n}\r\ndev_info(dev, "Firmware revision %i.%i (signature 0x%04x)\n",\r\nle16_to_cpu(priv->fw_data->major_version),\r\npriv->fw_data->minor_version, signature);\r\nexit:\r\nrelease_firmware(fw);\r\nreturn ret;\r\n}\r\nstatic int rtl8723au_load_firmware(struct rtl8xxxu_priv *priv)\r\n{\r\nchar *fw_name;\r\nint ret;\r\nswitch (priv->chip_cut) {\r\ncase 0:\r\nfw_name = "rtlwifi/rtl8723aufw_A.bin";\r\nbreak;\r\ncase 1:\r\nif (priv->enable_bluetooth)\r\nfw_name = "rtlwifi/rtl8723aufw_B.bin";\r\nelse\r\nfw_name = "rtlwifi/rtl8723aufw_B_NoBT.bin";\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nret = rtl8xxxu_load_firmware(priv, fw_name);\r\nreturn ret;\r\n}\r\nstatic int rtl8192cu_load_firmware(struct rtl8xxxu_priv *priv)\r\n{\r\nchar *fw_name;\r\nint ret;\r\nif (!priv->vendor_umc)\r\nfw_name = "rtlwifi/rtl8192cufw_TMSC.bin";\r\nelse if (priv->chip_cut || priv->rtlchip == 0x8192c)\r\nfw_name = "rtlwifi/rtl8192cufw_B.bin";\r\nelse\r\nfw_name = "rtlwifi/rtl8192cufw_A.bin";\r\nret = rtl8xxxu_load_firmware(priv, fw_name);\r\nreturn ret;\r\n}\r\nstatic void rtl8xxxu_firmware_self_reset(struct rtl8xxxu_priv *priv)\r\n{\r\nu16 val16;\r\nint i = 100;\r\nrtl8xxxu_write8(priv, REG_HMTFR + 3, 0x20);\r\nfor (i = 100; i > 0; i--) {\r\nval16 = rtl8xxxu_read16(priv, REG_SYS_FUNC);\r\nif (!(val16 & SYS_FUNC_CPU_ENABLE)) {\r\ndev_dbg(&priv->udev->dev,\r\n"%s: Firmware self reset success!\n", __func__);\r\nbreak;\r\n}\r\nudelay(50);\r\n}\r\nif (!i) {\r\nval16 = rtl8xxxu_read16(priv, REG_SYS_FUNC);\r\nval16 &= ~SYS_FUNC_CPU_ENABLE;\r\nrtl8xxxu_write16(priv, REG_SYS_FUNC, val16);\r\n}\r\n}\r\nstatic int\r\nrtl8xxxu_init_mac(struct rtl8xxxu_priv *priv, struct rtl8xxxu_reg8val *array)\r\n{\r\nint i, ret;\r\nu16 reg;\r\nu8 val;\r\nfor (i = 0; ; i++) {\r\nreg = array[i].reg;\r\nval = array[i].val;\r\nif (reg == 0xffff && val == 0xff)\r\nbreak;\r\nret = rtl8xxxu_write8(priv, reg, val);\r\nif (ret != 1) {\r\ndev_warn(&priv->udev->dev,\r\n"Failed to initialize MAC\n");\r\nreturn -EAGAIN;\r\n}\r\n}\r\nrtl8xxxu_write8(priv, REG_MAX_AGGR_NUM, 0x0a);\r\nreturn 0;\r\n}\r\nstatic int rtl8xxxu_init_phy_regs(struct rtl8xxxu_priv *priv,\r\nstruct rtl8xxxu_reg32val *array)\r\n{\r\nint i, ret;\r\nu16 reg;\r\nu32 val;\r\nfor (i = 0; ; i++) {\r\nreg = array[i].reg;\r\nval = array[i].val;\r\nif (reg == 0xffff && val == 0xffffffff)\r\nbreak;\r\nret = rtl8xxxu_write32(priv, reg, val);\r\nif (ret != sizeof(val)) {\r\ndev_warn(&priv->udev->dev,\r\n"Failed to initialize PHY\n");\r\nreturn -EAGAIN;\r\n}\r\nudelay(1);\r\n}\r\nreturn 0;\r\n}\r\nstatic int rtl8xxxu_init_phy_bb(struct rtl8xxxu_priv *priv)\r\n{\r\nu8 val8, ldoa15, ldov12d, lpldo, ldohci12;\r\nu32 val32;\r\nval8 = rtl8xxxu_read8(priv, REG_AFE_PLL_CTRL);\r\nudelay(2);\r\nval8 |= AFE_PLL_320_ENABLE;\r\nrtl8xxxu_write8(priv, REG_AFE_PLL_CTRL, val8);\r\nudelay(2);\r\nrtl8xxxu_write8(priv, REG_AFE_PLL_CTRL + 1, 0xff);\r\nudelay(2);\r\nval8 = rtl8xxxu_read8(priv, REG_SYS_FUNC);\r\nval8 |= SYS_FUNC_BB_GLB_RSTN | SYS_FUNC_BBRSTB;\r\nrtl8xxxu_write8(priv, REG_SYS_FUNC, val8);\r\nval32 = rtl8xxxu_read32(priv, REG_AFE_XTAL_CTRL);\r\nval32 &= ~AFE_XTAL_RF_GATE;\r\nif (priv->has_bluetooth)\r\nval32 &= ~AFE_XTAL_BT_GATE;\r\nrtl8xxxu_write32(priv, REG_AFE_XTAL_CTRL, val32);\r\nval8 = RF_ENABLE | RF_RSTB | RF_SDMRSTB;\r\nrtl8xxxu_write8(priv, REG_RF_CTRL, val8);\r\nif (priv->hi_pa)\r\nrtl8xxxu_init_phy_regs(priv, rtl8188ru_phy_1t_highpa_table);\r\nelse if (priv->tx_paths == 2)\r\nrtl8xxxu_init_phy_regs(priv, rtl8192cu_phy_2t_init_table);\r\nelse\r\nrtl8xxxu_init_phy_regs(priv, rtl8723a_phy_1t_init_table);\r\nif (priv->rtlchip == 0x8188c && priv->hi_pa &&\r\npriv->vendor_umc && priv->chip_cut == 1)\r\nrtl8xxxu_write8(priv, REG_OFDM0_AGC_PARM1 + 2, 0x50);\r\nif (priv->tx_paths == 1 && priv->rx_paths == 2) {\r\nval32 = rtl8xxxu_read32(priv, REG_FPGA0_TX_INFO);\r\nval32 &= ~(BIT(0) | BIT(1));\r\nval32 |= BIT(1);\r\nrtl8xxxu_write32(priv, REG_FPGA0_TX_INFO, val32);\r\nval32 = rtl8xxxu_read32(priv, REG_FPGA1_TX_INFO);\r\nval32 &= ~0x300033;\r\nval32 |= 0x200022;\r\nrtl8xxxu_write32(priv, REG_FPGA1_TX_INFO, val32);\r\nval32 = rtl8xxxu_read32(priv, REG_CCK0_AFE_SETTING);\r\nval32 &= 0xff000000;\r\nval32 |= 0x45000000;\r\nrtl8xxxu_write32(priv, REG_CCK0_AFE_SETTING, val32);\r\nval32 = rtl8xxxu_read32(priv, REG_OFDM0_TRX_PATH_ENABLE);\r\nval32 &= ~(OFDM_RF_PATH_RX_MASK | OFDM_RF_PATH_TX_MASK);\r\nval32 |= (OFDM_RF_PATH_RX_A | OFDM_RF_PATH_RX_B |\r\nOFDM_RF_PATH_TX_B);\r\nrtl8xxxu_write32(priv, REG_OFDM0_TRX_PATH_ENABLE, val32);\r\nval32 = rtl8xxxu_read32(priv, REG_OFDM0_AGC_PARM1);\r\nval32 &= ~(BIT(4) | BIT(5));\r\nval32 |= BIT(4);\r\nrtl8xxxu_write32(priv, REG_OFDM0_AGC_PARM1, val32);\r\nval32 = rtl8xxxu_read32(priv, REG_TX_CCK_RFON);\r\nval32 &= ~(BIT(27) | BIT(26));\r\nval32 |= BIT(27);\r\nrtl8xxxu_write32(priv, REG_TX_CCK_RFON, val32);\r\nval32 = rtl8xxxu_read32(priv, REG_TX_CCK_BBON);\r\nval32 &= ~(BIT(27) | BIT(26));\r\nval32 |= BIT(27);\r\nrtl8xxxu_write32(priv, REG_TX_CCK_BBON, val32);\r\nval32 = rtl8xxxu_read32(priv, REG_TX_OFDM_RFON);\r\nval32 &= ~(BIT(27) | BIT(26));\r\nval32 |= BIT(27);\r\nrtl8xxxu_write32(priv, REG_TX_OFDM_RFON, val32);\r\nval32 = rtl8xxxu_read32(priv, REG_TX_OFDM_BBON);\r\nval32 &= ~(BIT(27) | BIT(26));\r\nval32 |= BIT(27);\r\nrtl8xxxu_write32(priv, REG_TX_OFDM_BBON, val32);\r\nval32 = rtl8xxxu_read32(priv, REG_TX_TO_TX);\r\nval32 &= ~(BIT(27) | BIT(26));\r\nval32 |= BIT(27);\r\nrtl8xxxu_write32(priv, REG_TX_TO_TX, val32);\r\n}\r\nif (priv->hi_pa)\r\nrtl8xxxu_init_phy_regs(priv, rtl8xxx_agc_highpa_table);\r\nelse\r\nrtl8xxxu_init_phy_regs(priv, rtl8xxx_agc_standard_table);\r\nif (priv->rtlchip == 0x8723a &&\r\npriv->efuse_wifi.efuse8723.version >= 0x01) {\r\nval32 = rtl8xxxu_read32(priv, REG_MAC_PHY_CTRL);\r\nval8 = priv->efuse_wifi.efuse8723.xtal_k & 0x3f;\r\nval32 &= 0xff000fff;\r\nval32 |= ((val8 | (val8 << 6)) << 12);\r\nrtl8xxxu_write32(priv, REG_MAC_PHY_CTRL, val32);\r\n}\r\nldoa15 = LDOA15_ENABLE | LDOA15_OBUF;\r\nldov12d = LDOV12D_ENABLE | BIT(2) | (2 << LDOV12D_VADJ_SHIFT);\r\nldohci12 = 0x57;\r\nlpldo = 1;\r\nval32 = (lpldo << 24) | (ldohci12 << 16) | (ldov12d << 8) | ldoa15;\r\nrtl8xxxu_write32(priv, REG_LDOA15_CTRL, val32);\r\nreturn 0;\r\n}\r\nstatic int rtl8xxxu_init_rf_regs(struct rtl8xxxu_priv *priv,\r\nstruct rtl8xxxu_rfregval *array,\r\nenum rtl8xxxu_rfpath path)\r\n{\r\nint i, ret;\r\nu8 reg;\r\nu32 val;\r\nfor (i = 0; ; i++) {\r\nreg = array[i].reg;\r\nval = array[i].val;\r\nif (reg == 0xff && val == 0xffffffff)\r\nbreak;\r\nswitch (reg) {\r\ncase 0xfe:\r\nmsleep(50);\r\ncontinue;\r\ncase 0xfd:\r\nmdelay(5);\r\ncontinue;\r\ncase 0xfc:\r\nmdelay(1);\r\ncontinue;\r\ncase 0xfb:\r\nudelay(50);\r\ncontinue;\r\ncase 0xfa:\r\nudelay(5);\r\ncontinue;\r\ncase 0xf9:\r\nudelay(1);\r\ncontinue;\r\n}\r\nreg &= 0x3f;\r\nret = rtl8xxxu_write_rfreg(priv, path, reg, val);\r\nif (ret) {\r\ndev_warn(&priv->udev->dev,\r\n"Failed to initialize RF\n");\r\nreturn -EAGAIN;\r\n}\r\nudelay(1);\r\n}\r\nreturn 0;\r\n}\r\nstatic int rtl8xxxu_init_phy_rf(struct rtl8xxxu_priv *priv,\r\nstruct rtl8xxxu_rfregval *table,\r\nenum rtl8xxxu_rfpath path)\r\n{\r\nu32 val32;\r\nu16 val16, rfsi_rfenv;\r\nu16 reg_sw_ctrl, reg_int_oe, reg_hssi_parm2;\r\nswitch (path) {\r\ncase RF_A:\r\nreg_sw_ctrl = REG_FPGA0_XA_RF_SW_CTRL;\r\nreg_int_oe = REG_FPGA0_XA_RF_INT_OE;\r\nreg_hssi_parm2 = REG_FPGA0_XA_HSSI_PARM2;\r\nbreak;\r\ncase RF_B:\r\nreg_sw_ctrl = REG_FPGA0_XB_RF_SW_CTRL;\r\nreg_int_oe = REG_FPGA0_XB_RF_INT_OE;\r\nreg_hssi_parm2 = REG_FPGA0_XB_HSSI_PARM2;\r\nbreak;\r\ndefault:\r\ndev_err(&priv->udev->dev, "%s:Unsupported RF path %c\n",\r\n__func__, path + 'A');\r\nreturn -EINVAL;\r\n}\r\nrfsi_rfenv = rtl8xxxu_read16(priv, reg_sw_ctrl);\r\nrfsi_rfenv &= FPGA0_RF_RFENV;\r\nval32 = rtl8xxxu_read32(priv, reg_int_oe);\r\nval32 |= BIT(20);\r\nrtl8xxxu_write32(priv, reg_int_oe, val32);\r\nudelay(1);\r\nval32 = rtl8xxxu_read32(priv, reg_int_oe);\r\nval32 |= BIT(4);\r\nrtl8xxxu_write32(priv, reg_int_oe, val32);\r\nudelay(1);\r\nval32 = rtl8xxxu_read32(priv, reg_hssi_parm2);\r\nval32 &= ~FPGA0_HSSI_3WIRE_ADDR_LEN;\r\nrtl8xxxu_write32(priv, reg_hssi_parm2, val32);\r\nudelay(1);\r\nval32 = rtl8xxxu_read32(priv, reg_hssi_parm2);\r\nval32 &= ~FPGA0_HSSI_3WIRE_DATA_LEN;\r\nrtl8xxxu_write32(priv, reg_hssi_parm2, val32);\r\nudelay(1);\r\nrtl8xxxu_init_rf_regs(priv, table, path);\r\nval16 = rtl8xxxu_read16(priv, reg_sw_ctrl);\r\nval16 &= ~FPGA0_RF_RFENV;\r\nval16 |= rfsi_rfenv;\r\nrtl8xxxu_write16(priv, reg_sw_ctrl, val16);\r\nreturn 0;\r\n}\r\nstatic int rtl8xxxu_llt_write(struct rtl8xxxu_priv *priv, u8 address, u8 data)\r\n{\r\nint ret = -EBUSY;\r\nint count = 0;\r\nu32 value;\r\nvalue = LLT_OP_WRITE | address << 8 | data;\r\nrtl8xxxu_write32(priv, REG_LLT_INIT, value);\r\ndo {\r\nvalue = rtl8xxxu_read32(priv, REG_LLT_INIT);\r\nif ((value & LLT_OP_MASK) == LLT_OP_INACTIVE) {\r\nret = 0;\r\nbreak;\r\n}\r\n} while (count++ < 20);\r\nreturn ret;\r\n}\r\nstatic int rtl8xxxu_init_llt_table(struct rtl8xxxu_priv *priv, u8 last_tx_page)\r\n{\r\nint ret;\r\nint i;\r\nfor (i = 0; i < last_tx_page; i++) {\r\nret = rtl8xxxu_llt_write(priv, i, i + 1);\r\nif (ret)\r\ngoto exit;\r\n}\r\nret = rtl8xxxu_llt_write(priv, last_tx_page, 0xff);\r\nif (ret)\r\ngoto exit;\r\nfor (i = last_tx_page + 1; i < 0xff; i++) {\r\nret = rtl8xxxu_llt_write(priv, i, (i + 1));\r\nif (ret)\r\ngoto exit;\r\n}\r\nret = rtl8xxxu_llt_write(priv, 0xff, last_tx_page + 1);\r\nif (ret)\r\ngoto exit;\r\nexit:\r\nreturn ret;\r\n}\r\nstatic int rtl8xxxu_init_queue_priority(struct rtl8xxxu_priv *priv)\r\n{\r\nu16 val16, hi, lo;\r\nu16 hiq, mgq, bkq, beq, viq, voq;\r\nint hip, mgp, bkp, bep, vip, vop;\r\nint ret = 0;\r\nswitch (priv->ep_tx_count) {\r\ncase 1:\r\nif (priv->ep_tx_high_queue) {\r\nhi = TRXDMA_QUEUE_HIGH;\r\n} else if (priv->ep_tx_low_queue) {\r\nhi = TRXDMA_QUEUE_LOW;\r\n} else if (priv->ep_tx_normal_queue) {\r\nhi = TRXDMA_QUEUE_NORMAL;\r\n} else {\r\nhi = 0;\r\nret = -EINVAL;\r\n}\r\nhiq = hi;\r\nmgq = hi;\r\nbkq = hi;\r\nbeq = hi;\r\nviq = hi;\r\nvoq = hi;\r\nhip = 0;\r\nmgp = 0;\r\nbkp = 0;\r\nbep = 0;\r\nvip = 0;\r\nvop = 0;\r\nbreak;\r\ncase 2:\r\nif (priv->ep_tx_high_queue && priv->ep_tx_low_queue) {\r\nhi = TRXDMA_QUEUE_HIGH;\r\nlo = TRXDMA_QUEUE_LOW;\r\n} else if (priv->ep_tx_normal_queue && priv->ep_tx_low_queue) {\r\nhi = TRXDMA_QUEUE_NORMAL;\r\nlo = TRXDMA_QUEUE_LOW;\r\n} else if (priv->ep_tx_high_queue && priv->ep_tx_normal_queue) {\r\nhi = TRXDMA_QUEUE_HIGH;\r\nlo = TRXDMA_QUEUE_NORMAL;\r\n} else {\r\nret = -EINVAL;\r\nhi = 0;\r\nlo = 0;\r\n}\r\nhiq = hi;\r\nmgq = hi;\r\nbkq = lo;\r\nbeq = lo;\r\nviq = hi;\r\nvoq = hi;\r\nhip = 0;\r\nmgp = 0;\r\nbkp = 1;\r\nbep = 1;\r\nvip = 0;\r\nvop = 0;\r\nbreak;\r\ncase 3:\r\nbeq = TRXDMA_QUEUE_LOW;\r\nbkq = TRXDMA_QUEUE_LOW;\r\nviq = TRXDMA_QUEUE_NORMAL;\r\nvoq = TRXDMA_QUEUE_HIGH;\r\nmgq = TRXDMA_QUEUE_HIGH;\r\nhiq = TRXDMA_QUEUE_HIGH;\r\nhip = hiq ^ 3;\r\nmgp = mgq ^ 3;\r\nbkp = bkq ^ 3;\r\nbep = beq ^ 3;\r\nvip = viq ^ 3;\r\nvop = viq ^ 3;\r\nbreak;\r\ndefault:\r\nret = -EINVAL;\r\n}\r\nif (!ret) {\r\nval16 = rtl8xxxu_read16(priv, REG_TRXDMA_CTRL);\r\nval16 &= 0x7;\r\nval16 |= (voq << TRXDMA_CTRL_VOQ_SHIFT) |\r\n(viq << TRXDMA_CTRL_VIQ_SHIFT) |\r\n(beq << TRXDMA_CTRL_BEQ_SHIFT) |\r\n(bkq << TRXDMA_CTRL_BKQ_SHIFT) |\r\n(mgq << TRXDMA_CTRL_MGQ_SHIFT) |\r\n(hiq << TRXDMA_CTRL_HIQ_SHIFT);\r\nrtl8xxxu_write16(priv, REG_TRXDMA_CTRL, val16);\r\npriv->pipe_out[TXDESC_QUEUE_VO] =\r\nusb_sndbulkpipe(priv->udev, priv->out_ep[vop]);\r\npriv->pipe_out[TXDESC_QUEUE_VI] =\r\nusb_sndbulkpipe(priv->udev, priv->out_ep[vip]);\r\npriv->pipe_out[TXDESC_QUEUE_BE] =\r\nusb_sndbulkpipe(priv->udev, priv->out_ep[bep]);\r\npriv->pipe_out[TXDESC_QUEUE_BK] =\r\nusb_sndbulkpipe(priv->udev, priv->out_ep[bkp]);\r\npriv->pipe_out[TXDESC_QUEUE_BEACON] =\r\nusb_sndbulkpipe(priv->udev, priv->out_ep[0]);\r\npriv->pipe_out[TXDESC_QUEUE_MGNT] =\r\nusb_sndbulkpipe(priv->udev, priv->out_ep[mgp]);\r\npriv->pipe_out[TXDESC_QUEUE_HIGH] =\r\nusb_sndbulkpipe(priv->udev, priv->out_ep[hip]);\r\npriv->pipe_out[TXDESC_QUEUE_CMD] =\r\nusb_sndbulkpipe(priv->udev, priv->out_ep[0]);\r\n}\r\nreturn ret;\r\n}\r\nstatic void rtl8xxxu_fill_iqk_matrix_a(struct rtl8xxxu_priv *priv,\r\nbool iqk_ok, int result[][8],\r\nint candidate, bool tx_only)\r\n{\r\nu32 oldval, x, tx0_a, reg;\r\nint y, tx0_c;\r\nu32 val32;\r\nif (!iqk_ok)\r\nreturn;\r\nval32 = rtl8xxxu_read32(priv, REG_OFDM0_XA_TX_IQ_IMBALANCE);\r\noldval = val32 >> 22;\r\nx = result[candidate][0];\r\nif ((x & 0x00000200) != 0)\r\nx = x | 0xfffffc00;\r\ntx0_a = (x * oldval) >> 8;\r\nval32 = rtl8xxxu_read32(priv, REG_OFDM0_XA_TX_IQ_IMBALANCE);\r\nval32 &= ~0x3ff;\r\nval32 |= tx0_a;\r\nrtl8xxxu_write32(priv, REG_OFDM0_XA_TX_IQ_IMBALANCE, val32);\r\nval32 = rtl8xxxu_read32(priv, REG_OFDM0_ENERGY_CCA_THRES);\r\nval32 &= ~BIT(31);\r\nif ((x * oldval >> 7) & 0x1)\r\nval32 |= BIT(31);\r\nrtl8xxxu_write32(priv, REG_OFDM0_ENERGY_CCA_THRES, val32);\r\ny = result[candidate][1];\r\nif ((y & 0x00000200) != 0)\r\ny = y | 0xfffffc00;\r\ntx0_c = (y * oldval) >> 8;\r\nval32 = rtl8xxxu_read32(priv, REG_OFDM0_XC_TX_AFE);\r\nval32 &= ~0xf0000000;\r\nval32 |= (((tx0_c & 0x3c0) >> 6) << 28);\r\nrtl8xxxu_write32(priv, REG_OFDM0_XC_TX_AFE, val32);\r\nval32 = rtl8xxxu_read32(priv, REG_OFDM0_XA_TX_IQ_IMBALANCE);\r\nval32 &= ~0x003f0000;\r\nval32 |= ((tx0_c & 0x3f) << 16);\r\nrtl8xxxu_write32(priv, REG_OFDM0_XA_TX_IQ_IMBALANCE, val32);\r\nval32 = rtl8xxxu_read32(priv, REG_OFDM0_ENERGY_CCA_THRES);\r\nval32 &= ~BIT(29);\r\nif ((y * oldval >> 7) & 0x1)\r\nval32 |= BIT(29);\r\nrtl8xxxu_write32(priv, REG_OFDM0_ENERGY_CCA_THRES, val32);\r\nif (tx_only) {\r\ndev_dbg(&priv->udev->dev, "%s: only TX\n", __func__);\r\nreturn;\r\n}\r\nreg = result[candidate][2];\r\nval32 = rtl8xxxu_read32(priv, REG_OFDM0_XA_RX_IQ_IMBALANCE);\r\nval32 &= ~0x3ff;\r\nval32 |= (reg & 0x3ff);\r\nrtl8xxxu_write32(priv, REG_OFDM0_XA_RX_IQ_IMBALANCE, val32);\r\nreg = result[candidate][3] & 0x3F;\r\nval32 = rtl8xxxu_read32(priv, REG_OFDM0_XA_RX_IQ_IMBALANCE);\r\nval32 &= ~0xfc00;\r\nval32 |= ((reg << 10) & 0xfc00);\r\nrtl8xxxu_write32(priv, REG_OFDM0_XA_RX_IQ_IMBALANCE, val32);\r\nreg = (result[candidate][3] >> 6) & 0xF;\r\nval32 = rtl8xxxu_read32(priv, REG_OFDM0_RX_IQ_EXT_ANTA);\r\nval32 &= ~0xf0000000;\r\nval32 |= (reg << 28);\r\nrtl8xxxu_write32(priv, REG_OFDM0_RX_IQ_EXT_ANTA, val32);\r\n}\r\nstatic void rtl8xxxu_fill_iqk_matrix_b(struct rtl8xxxu_priv *priv,\r\nbool iqk_ok, int result[][8],\r\nint candidate, bool tx_only)\r\n{\r\nu32 oldval, x, tx1_a, reg;\r\nint y, tx1_c;\r\nu32 val32;\r\nif (!iqk_ok)\r\nreturn;\r\nval32 = rtl8xxxu_read32(priv, REG_OFDM0_XB_TX_IQ_IMBALANCE);\r\noldval = val32 >> 22;\r\nx = result[candidate][4];\r\nif ((x & 0x00000200) != 0)\r\nx = x | 0xfffffc00;\r\ntx1_a = (x * oldval) >> 8;\r\nval32 = rtl8xxxu_read32(priv, REG_OFDM0_XB_TX_IQ_IMBALANCE);\r\nval32 &= ~0x3ff;\r\nval32 |= tx1_a;\r\nrtl8xxxu_write32(priv, REG_OFDM0_XB_TX_IQ_IMBALANCE, val32);\r\nval32 = rtl8xxxu_read32(priv, REG_OFDM0_ENERGY_CCA_THRES);\r\nval32 &= ~BIT(27);\r\nif ((x * oldval >> 7) & 0x1)\r\nval32 |= BIT(27);\r\nrtl8xxxu_write32(priv, REG_OFDM0_ENERGY_CCA_THRES, val32);\r\ny = result[candidate][5];\r\nif ((y & 0x00000200) != 0)\r\ny = y | 0xfffffc00;\r\ntx1_c = (y * oldval) >> 8;\r\nval32 = rtl8xxxu_read32(priv, REG_OFDM0_XD_TX_AFE);\r\nval32 &= ~0xf0000000;\r\nval32 |= (((tx1_c & 0x3c0) >> 6) << 28);\r\nrtl8xxxu_write32(priv, REG_OFDM0_XD_TX_AFE, val32);\r\nval32 = rtl8xxxu_read32(priv, REG_OFDM0_XB_TX_IQ_IMBALANCE);\r\nval32 &= ~0x003f0000;\r\nval32 |= ((tx1_c & 0x3f) << 16);\r\nrtl8xxxu_write32(priv, REG_OFDM0_XB_TX_IQ_IMBALANCE, val32);\r\nval32 = rtl8xxxu_read32(priv, REG_OFDM0_ENERGY_CCA_THRES);\r\nval32 &= ~BIT(25);\r\nif ((y * oldval >> 7) & 0x1)\r\nval32 |= BIT(25);\r\nrtl8xxxu_write32(priv, REG_OFDM0_ENERGY_CCA_THRES, val32);\r\nif (tx_only) {\r\ndev_dbg(&priv->udev->dev, "%s: only TX\n", __func__);\r\nreturn;\r\n}\r\nreg = result[candidate][6];\r\nval32 = rtl8xxxu_read32(priv, REG_OFDM0_XB_RX_IQ_IMBALANCE);\r\nval32 &= ~0x3ff;\r\nval32 |= (reg & 0x3ff);\r\nrtl8xxxu_write32(priv, REG_OFDM0_XB_RX_IQ_IMBALANCE, val32);\r\nreg = result[candidate][7] & 0x3f;\r\nval32 = rtl8xxxu_read32(priv, REG_OFDM0_XB_RX_IQ_IMBALANCE);\r\nval32 &= ~0xfc00;\r\nval32 |= ((reg << 10) & 0xfc00);\r\nrtl8xxxu_write32(priv, REG_OFDM0_XB_RX_IQ_IMBALANCE, val32);\r\nreg = (result[candidate][7] >> 6) & 0xf;\r\nval32 = rtl8xxxu_read32(priv, REG_OFDM0_AGCR_SSI_TABLE);\r\nval32 &= ~0x0000f000;\r\nval32 |= (reg << 12);\r\nrtl8xxxu_write32(priv, REG_OFDM0_AGCR_SSI_TABLE, val32);\r\n}\r\nstatic bool rtl8xxxu_simularity_compare(struct rtl8xxxu_priv *priv,\r\nint result[][8], int c1, int c2)\r\n{\r\nu32 i, j, diff, simubitmap, bound = 0;\r\nint candidate[2] = {-1, -1};\r\nbool retval = true;\r\nif (priv->tx_paths > 1)\r\nbound = 8;\r\nelse\r\nbound = 4;\r\nsimubitmap = 0;\r\nfor (i = 0; i < bound; i++) {\r\ndiff = (result[c1][i] > result[c2][i]) ?\r\n(result[c1][i] - result[c2][i]) :\r\n(result[c2][i] - result[c1][i]);\r\nif (diff > MAX_TOLERANCE) {\r\nif ((i == 2 || i == 6) && !simubitmap) {\r\nif (result[c1][i] + result[c1][i + 1] == 0)\r\ncandidate[(i / 4)] = c2;\r\nelse if (result[c2][i] + result[c2][i + 1] == 0)\r\ncandidate[(i / 4)] = c1;\r\nelse\r\nsimubitmap = simubitmap | (1 << i);\r\n} else {\r\nsimubitmap = simubitmap | (1 << i);\r\n}\r\n}\r\n}\r\nif (simubitmap == 0) {\r\nfor (i = 0; i < (bound / 4); i++) {\r\nif (candidate[i] >= 0) {\r\nfor (j = i * 4; j < (i + 1) * 4 - 2; j++)\r\nresult[3][j] = result[candidate[i]][j];\r\nretval = false;\r\n}\r\n}\r\nreturn retval;\r\n} else if (!(simubitmap & 0x0f)) {\r\nfor (i = 0; i < 4; i++)\r\nresult[3][i] = result[c1][i];\r\n} else if (!(simubitmap & 0xf0) && priv->tx_paths > 1) {\r\nfor (i = 4; i < 8; i++)\r\nresult[3][i] = result[c1][i];\r\n}\r\nreturn false;\r\n}\r\nstatic void\r\nrtl8xxxu_save_mac_regs(struct rtl8xxxu_priv *priv, const u32 *reg, u32 *backup)\r\n{\r\nint i;\r\nfor (i = 0; i < (RTL8XXXU_MAC_REGS - 1); i++)\r\nbackup[i] = rtl8xxxu_read8(priv, reg[i]);\r\nbackup[i] = rtl8xxxu_read32(priv, reg[i]);\r\n}\r\nstatic void rtl8xxxu_restore_mac_regs(struct rtl8xxxu_priv *priv,\r\nconst u32 *reg, u32 *backup)\r\n{\r\nint i;\r\nfor (i = 0; i < (RTL8XXXU_MAC_REGS - 1); i++)\r\nrtl8xxxu_write8(priv, reg[i], backup[i]);\r\nrtl8xxxu_write32(priv, reg[i], backup[i]);\r\n}\r\nstatic void rtl8xxxu_save_regs(struct rtl8xxxu_priv *priv, const u32 *regs,\r\nu32 *backup, int count)\r\n{\r\nint i;\r\nfor (i = 0; i < count; i++)\r\nbackup[i] = rtl8xxxu_read32(priv, regs[i]);\r\n}\r\nstatic void rtl8xxxu_restore_regs(struct rtl8xxxu_priv *priv, const u32 *regs,\r\nu32 *backup, int count)\r\n{\r\nint i;\r\nfor (i = 0; i < count; i++)\r\nrtl8xxxu_write32(priv, regs[i], backup[i]);\r\n}\r\nstatic void rtl8xxxu_path_adda_on(struct rtl8xxxu_priv *priv, const u32 *regs,\r\nbool path_a_on)\r\n{\r\nu32 path_on;\r\nint i;\r\npath_on = path_a_on ? 0x04db25a4 : 0x0b1b25a4;\r\nif (priv->tx_paths == 1) {\r\npath_on = 0x0bdb25a0;\r\nrtl8xxxu_write32(priv, regs[0], 0x0b1b25a0);\r\n} else {\r\nrtl8xxxu_write32(priv, regs[0], path_on);\r\n}\r\nfor (i = 1 ; i < RTL8XXXU_ADDA_REGS ; i++)\r\nrtl8xxxu_write32(priv, regs[i], path_on);\r\n}\r\nstatic void rtl8xxxu_mac_calibration(struct rtl8xxxu_priv *priv,\r\nconst u32 *regs, u32 *backup)\r\n{\r\nint i = 0;\r\nrtl8xxxu_write8(priv, regs[i], 0x3f);\r\nfor (i = 1 ; i < (RTL8XXXU_MAC_REGS - 1); i++)\r\nrtl8xxxu_write8(priv, regs[i], (u8)(backup[i] & ~BIT(3)));\r\nrtl8xxxu_write8(priv, regs[i], (u8)(backup[i] & ~BIT(5)));\r\n}\r\nstatic int rtl8xxxu_iqk_path_a(struct rtl8xxxu_priv *priv)\r\n{\r\nu32 reg_eac, reg_e94, reg_e9c, reg_ea4, val32;\r\nint result = 0;\r\nrtl8xxxu_write32(priv, REG_TX_IQK_TONE_A, 0x10008c1f);\r\nrtl8xxxu_write32(priv, REG_RX_IQK_TONE_A, 0x10008c1f);\r\nrtl8xxxu_write32(priv, REG_TX_IQK_PI_A, 0x82140102);\r\nval32 = (priv->rf_paths > 1) ? 0x28160202 :\r\n0x28160502;\r\nrtl8xxxu_write32(priv, REG_RX_IQK_PI_A, val32);\r\nif (priv->rf_paths > 1) {\r\nrtl8xxxu_write32(priv, REG_TX_IQK_TONE_B, 0x10008c22);\r\nrtl8xxxu_write32(priv, REG_RX_IQK_TONE_B, 0x10008c22);\r\nrtl8xxxu_write32(priv, REG_TX_IQK_PI_B, 0x82140102);\r\nrtl8xxxu_write32(priv, REG_RX_IQK_PI_B, 0x28160202);\r\n}\r\nrtl8xxxu_write32(priv, REG_IQK_AGC_RSP, 0x001028d1);\r\nrtl8xxxu_write32(priv, REG_IQK_AGC_PTS, 0xf9000000);\r\nrtl8xxxu_write32(priv, REG_IQK_AGC_PTS, 0xf8000000);\r\nmdelay(1);\r\nreg_eac = rtl8xxxu_read32(priv, REG_RX_POWER_AFTER_IQK_A_2);\r\nreg_e94 = rtl8xxxu_read32(priv, REG_TX_POWER_BEFORE_IQK_A);\r\nreg_e9c = rtl8xxxu_read32(priv, REG_TX_POWER_AFTER_IQK_A);\r\nreg_ea4 = rtl8xxxu_read32(priv, REG_RX_POWER_BEFORE_IQK_A_2);\r\nif (!(reg_eac & BIT(28)) &&\r\n((reg_e94 & 0x03ff0000) != 0x01420000) &&\r\n((reg_e9c & 0x03ff0000) != 0x00420000))\r\nresult |= 0x01;\r\nelse\r\ngoto out;\r\nif (!(reg_eac & BIT(27)) &&\r\n((reg_ea4 & 0x03ff0000) != 0x01320000) &&\r\n((reg_eac & 0x03ff0000) != 0x00360000))\r\nresult |= 0x02;\r\nelse\r\ndev_warn(&priv->udev->dev, "%s: Path A RX IQK failed!\n",\r\n__func__);\r\nout:\r\nreturn result;\r\n}\r\nstatic int rtl8xxxu_iqk_path_b(struct rtl8xxxu_priv *priv)\r\n{\r\nu32 reg_eac, reg_eb4, reg_ebc, reg_ec4, reg_ecc;\r\nint result = 0;\r\nrtl8xxxu_write32(priv, REG_IQK_AGC_CONT, 0x00000002);\r\nrtl8xxxu_write32(priv, REG_IQK_AGC_CONT, 0x00000000);\r\nmdelay(1);\r\nreg_eac = rtl8xxxu_read32(priv, REG_RX_POWER_AFTER_IQK_A_2);\r\nreg_eb4 = rtl8xxxu_read32(priv, REG_TX_POWER_BEFORE_IQK_B);\r\nreg_ebc = rtl8xxxu_read32(priv, REG_TX_POWER_AFTER_IQK_B);\r\nreg_ec4 = rtl8xxxu_read32(priv, REG_RX_POWER_BEFORE_IQK_B_2);\r\nreg_ecc = rtl8xxxu_read32(priv, REG_RX_POWER_AFTER_IQK_B_2);\r\nif (!(reg_eac & BIT(31)) &&\r\n((reg_eb4 & 0x03ff0000) != 0x01420000) &&\r\n((reg_ebc & 0x03ff0000) != 0x00420000))\r\nresult |= 0x01;\r\nelse\r\ngoto out;\r\nif (!(reg_eac & BIT(30)) &&\r\n(((reg_ec4 & 0x03ff0000) >> 16) != 0x132) &&\r\n(((reg_ecc & 0x03ff0000) >> 16) != 0x36))\r\nresult |= 0x02;\r\nelse\r\ndev_warn(&priv->udev->dev, "%s: Path B RX IQK failed!\n",\r\n__func__);\r\nout:\r\nreturn result;\r\n}\r\nstatic void rtl8xxxu_phy_iqcalibrate(struct rtl8xxxu_priv *priv,\r\nint result[][8], int t)\r\n{\r\nstruct device *dev = &priv->udev->dev;\r\nu32 i, val32;\r\nint path_a_ok, path_b_ok;\r\nint retry = 2;\r\nconst u32 adda_regs[RTL8XXXU_ADDA_REGS] = {\r\nREG_FPGA0_XCD_SWITCH_CTRL, REG_BLUETOOTH,\r\nREG_RX_WAIT_CCA, REG_TX_CCK_RFON,\r\nREG_TX_CCK_BBON, REG_TX_OFDM_RFON,\r\nREG_TX_OFDM_BBON, REG_TX_TO_RX,\r\nREG_TX_TO_TX, REG_RX_CCK,\r\nREG_RX_OFDM, REG_RX_WAIT_RIFS,\r\nREG_RX_TO_RX, REG_STANDBY,\r\nREG_SLEEP, REG_PMPD_ANAEN\r\n};\r\nconst u32 iqk_mac_regs[RTL8XXXU_MAC_REGS] = {\r\nREG_TXPAUSE, REG_BEACON_CTRL,\r\nREG_BEACON_CTRL_1, REG_GPIO_MUXCFG\r\n};\r\nconst u32 iqk_bb_regs[RTL8XXXU_BB_REGS] = {\r\nREG_OFDM0_TRX_PATH_ENABLE, REG_OFDM0_TR_MUX_PAR,\r\nREG_FPGA0_XCD_RF_SW_CTRL, REG_CONFIG_ANT_A, REG_CONFIG_ANT_B,\r\nREG_FPGA0_XAB_RF_SW_CTRL, REG_FPGA0_XA_RF_INT_OE,\r\nREG_FPGA0_XB_RF_INT_OE, REG_FPGA0_RF_MODE\r\n};\r\nif (t == 0) {\r\nrtl8xxxu_save_regs(priv, adda_regs, priv->adda_backup,\r\nRTL8XXXU_ADDA_REGS);\r\nrtl8xxxu_save_mac_regs(priv, iqk_mac_regs, priv->mac_backup);\r\nrtl8xxxu_save_regs(priv, iqk_bb_regs,\r\npriv->bb_backup, RTL8XXXU_BB_REGS);\r\n}\r\nrtl8xxxu_path_adda_on(priv, adda_regs, true);\r\nif (t == 0) {\r\nval32 = rtl8xxxu_read32(priv, REG_FPGA0_XA_HSSI_PARM1);\r\nif (val32 & FPGA0_HSSI_PARM1_PI)\r\npriv->pi_enabled = 1;\r\n}\r\nif (!priv->pi_enabled) {\r\nrtl8xxxu_write32(priv, REG_FPGA0_XA_HSSI_PARM1, 0x01000100);\r\nrtl8xxxu_write32(priv, REG_FPGA0_XB_HSSI_PARM1, 0x01000100);\r\n}\r\nval32 = rtl8xxxu_read32(priv, REG_FPGA0_RF_MODE);\r\nval32 &= ~FPGA_RF_MODE_CCK;\r\nrtl8xxxu_write32(priv, REG_FPGA0_RF_MODE, val32);\r\nrtl8xxxu_write32(priv, REG_OFDM0_TRX_PATH_ENABLE, 0x03a05600);\r\nrtl8xxxu_write32(priv, REG_OFDM0_TR_MUX_PAR, 0x000800e4);\r\nrtl8xxxu_write32(priv, REG_FPGA0_XCD_RF_SW_CTRL, 0x22204000);\r\nval32 = rtl8xxxu_read32(priv, REG_FPGA0_XAB_RF_SW_CTRL);\r\nval32 |= (FPGA0_RF_PAPE | (FPGA0_RF_PAPE << FPGA0_RF_BD_CTRL_SHIFT));\r\nrtl8xxxu_write32(priv, REG_FPGA0_XAB_RF_SW_CTRL, val32);\r\nval32 = rtl8xxxu_read32(priv, REG_FPGA0_XA_RF_INT_OE);\r\nval32 &= ~BIT(10);\r\nrtl8xxxu_write32(priv, REG_FPGA0_XA_RF_INT_OE, val32);\r\nval32 = rtl8xxxu_read32(priv, REG_FPGA0_XB_RF_INT_OE);\r\nval32 &= ~BIT(10);\r\nrtl8xxxu_write32(priv, REG_FPGA0_XB_RF_INT_OE, val32);\r\nif (priv->tx_paths > 1) {\r\nrtl8xxxu_write32(priv, REG_FPGA0_XA_LSSI_PARM, 0x00010000);\r\nrtl8xxxu_write32(priv, REG_FPGA0_XB_LSSI_PARM, 0x00010000);\r\n}\r\nrtl8xxxu_mac_calibration(priv, iqk_mac_regs, priv->mac_backup);\r\nrtl8xxxu_write32(priv, REG_CONFIG_ANT_A, 0x00080000);\r\nif (priv->tx_paths > 1)\r\nrtl8xxxu_write32(priv, REG_CONFIG_ANT_B, 0x00080000);\r\nrtl8xxxu_write32(priv, REG_FPGA0_IQK, 0x80800000);\r\nrtl8xxxu_write32(priv, REG_TX_IQK, 0x01007c00);\r\nrtl8xxxu_write32(priv, REG_RX_IQK, 0x01004800);\r\nfor (i = 0; i < retry; i++) {\r\npath_a_ok = rtl8xxxu_iqk_path_a(priv);\r\nif (path_a_ok == 0x03) {\r\nval32 = rtl8xxxu_read32(priv,\r\nREG_TX_POWER_BEFORE_IQK_A);\r\nresult[t][0] = (val32 >> 16) & 0x3ff;\r\nval32 = rtl8xxxu_read32(priv,\r\nREG_TX_POWER_AFTER_IQK_A);\r\nresult[t][1] = (val32 >> 16) & 0x3ff;\r\nval32 = rtl8xxxu_read32(priv,\r\nREG_RX_POWER_BEFORE_IQK_A_2);\r\nresult[t][2] = (val32 >> 16) & 0x3ff;\r\nval32 = rtl8xxxu_read32(priv,\r\nREG_RX_POWER_AFTER_IQK_A_2);\r\nresult[t][3] = (val32 >> 16) & 0x3ff;\r\nbreak;\r\n} else if (i == (retry - 1) && path_a_ok == 0x01) {\r\ndev_dbg(dev, "%s: Path A IQK Only Tx Success!!\n",\r\n__func__);\r\nval32 = rtl8xxxu_read32(priv,\r\nREG_TX_POWER_BEFORE_IQK_A);\r\nresult[t][0] = (val32 >> 16) & 0x3ff;\r\nval32 = rtl8xxxu_read32(priv,\r\nREG_TX_POWER_AFTER_IQK_A);\r\nresult[t][1] = (val32 >> 16) & 0x3ff;\r\n}\r\n}\r\nif (!path_a_ok)\r\ndev_dbg(dev, "%s: Path A IQK failed!\n", __func__);\r\nif (priv->tx_paths > 1) {\r\nrtl8xxxu_write32(priv, REG_FPGA0_IQK, 0x0);\r\nrtl8xxxu_write32(priv, REG_FPGA0_XA_LSSI_PARM, 0x00010000);\r\nrtl8xxxu_write32(priv, REG_FPGA0_IQK, 0x80800000);\r\nrtl8xxxu_path_adda_on(priv, adda_regs, false);\r\nfor (i = 0; i < retry; i++) {\r\npath_b_ok = rtl8xxxu_iqk_path_b(priv);\r\nif (path_b_ok == 0x03) {\r\nval32 = rtl8xxxu_read32(priv, REG_TX_POWER_BEFORE_IQK_B);\r\nresult[t][4] = (val32 >> 16) & 0x3ff;\r\nval32 = rtl8xxxu_read32(priv, REG_TX_POWER_AFTER_IQK_B);\r\nresult[t][5] = (val32 >> 16) & 0x3ff;\r\nval32 = rtl8xxxu_read32(priv, REG_RX_POWER_BEFORE_IQK_B_2);\r\nresult[t][6] = (val32 >> 16) & 0x3ff;\r\nval32 = rtl8xxxu_read32(priv, REG_RX_POWER_AFTER_IQK_B_2);\r\nresult[t][7] = (val32 >> 16) & 0x3ff;\r\nbreak;\r\n} else if (i == (retry - 1) && path_b_ok == 0x01) {\r\nval32 = rtl8xxxu_read32(priv, REG_TX_POWER_BEFORE_IQK_B);\r\nresult[t][4] = (val32 >> 16) & 0x3ff;\r\nval32 = rtl8xxxu_read32(priv, REG_TX_POWER_AFTER_IQK_B);\r\nresult[t][5] = (val32 >> 16) & 0x3ff;\r\n}\r\n}\r\nif (!path_b_ok)\r\ndev_dbg(dev, "%s: Path B IQK failed!\n", __func__);\r\n}\r\nrtl8xxxu_write32(priv, REG_FPGA0_IQK, 0);\r\nif (t) {\r\nif (!priv->pi_enabled) {\r\nval32 = 0x01000000;\r\nrtl8xxxu_write32(priv, REG_FPGA0_XA_HSSI_PARM1, val32);\r\nrtl8xxxu_write32(priv, REG_FPGA0_XB_HSSI_PARM1, val32);\r\n}\r\nrtl8xxxu_restore_regs(priv, adda_regs, priv->adda_backup,\r\nRTL8XXXU_ADDA_REGS);\r\nrtl8xxxu_restore_mac_regs(priv, iqk_mac_regs, priv->mac_backup);\r\nrtl8xxxu_restore_regs(priv, iqk_bb_regs,\r\npriv->bb_backup, RTL8XXXU_BB_REGS);\r\nrtl8xxxu_write32(priv, REG_FPGA0_XA_LSSI_PARM, 0x00032ed3);\r\nif (priv->tx_paths > 1) {\r\nrtl8xxxu_write32(priv, REG_FPGA0_XB_LSSI_PARM,\r\n0x00032ed3);\r\n}\r\nrtl8xxxu_write32(priv, REG_TX_IQK_TONE_A, 0x01008c00);\r\nrtl8xxxu_write32(priv, REG_RX_IQK_TONE_A, 0x01008c00);\r\n}\r\n}\r\nstatic void rtl8723a_phy_iq_calibrate(struct rtl8xxxu_priv *priv)\r\n{\r\nstruct device *dev = &priv->udev->dev;\r\nint result[4][8];\r\nint i, candidate;\r\nbool path_a_ok, path_b_ok;\r\nu32 reg_e94, reg_e9c, reg_ea4, reg_eac;\r\nu32 reg_eb4, reg_ebc, reg_ec4, reg_ecc;\r\ns32 reg_tmp = 0;\r\nbool simu;\r\nmemset(result, 0, sizeof(result));\r\ncandidate = -1;\r\npath_a_ok = false;\r\npath_b_ok = false;\r\nrtl8xxxu_read32(priv, REG_FPGA0_RF_MODE);\r\nfor (i = 0; i < 3; i++) {\r\nrtl8xxxu_phy_iqcalibrate(priv, result, i);\r\nif (i == 1) {\r\nsimu = rtl8xxxu_simularity_compare(priv, result, 0, 1);\r\nif (simu) {\r\ncandidate = 0;\r\nbreak;\r\n}\r\n}\r\nif (i == 2) {\r\nsimu = rtl8xxxu_simularity_compare(priv, result, 0, 2);\r\nif (simu) {\r\ncandidate = 0;\r\nbreak;\r\n}\r\nsimu = rtl8xxxu_simularity_compare(priv, result, 1, 2);\r\nif (simu) {\r\ncandidate = 1;\r\n} else {\r\nfor (i = 0; i < 8; i++)\r\nreg_tmp += result[3][i];\r\nif (reg_tmp)\r\ncandidate = 3;\r\nelse\r\ncandidate = -1;\r\n}\r\n}\r\n}\r\nfor (i = 0; i < 4; i++) {\r\nreg_e94 = result[i][0];\r\nreg_e9c = result[i][1];\r\nreg_ea4 = result[i][2];\r\nreg_eac = result[i][3];\r\nreg_eb4 = result[i][4];\r\nreg_ebc = result[i][5];\r\nreg_ec4 = result[i][6];\r\nreg_ecc = result[i][7];\r\n}\r\nif (candidate >= 0) {\r\nreg_e94 = result[candidate][0];\r\npriv->rege94 = reg_e94;\r\nreg_e9c = result[candidate][1];\r\npriv->rege9c = reg_e9c;\r\nreg_ea4 = result[candidate][2];\r\nreg_eac = result[candidate][3];\r\nreg_eb4 = result[candidate][4];\r\npriv->regeb4 = reg_eb4;\r\nreg_ebc = result[candidate][5];\r\npriv->regebc = reg_ebc;\r\nreg_ec4 = result[candidate][6];\r\nreg_ecc = result[candidate][7];\r\ndev_dbg(dev, "%s: candidate is %x\n", __func__, candidate);\r\ndev_dbg(dev,\r\n"%s: e94 =%x e9c=%x ea4=%x eac=%x eb4=%x ebc=%x ec4=%x "\r\n"ecc=%x\n ", __func__, reg_e94, reg_e9c,\r\nreg_ea4, reg_eac, reg_eb4, reg_ebc, reg_ec4, reg_ecc);\r\npath_a_ok = true;\r\npath_b_ok = true;\r\n} else {\r\nreg_e94 = reg_eb4 = priv->rege94 = priv->regeb4 = 0x100;\r\nreg_e9c = reg_ebc = priv->rege9c = priv->regebc = 0x0;\r\n}\r\nif (reg_e94 && candidate >= 0)\r\nrtl8xxxu_fill_iqk_matrix_a(priv, path_a_ok, result,\r\ncandidate, (reg_ea4 == 0));\r\nif (priv->tx_paths > 1 && reg_eb4)\r\nrtl8xxxu_fill_iqk_matrix_b(priv, path_b_ok, result,\r\ncandidate, (reg_ec4 == 0));\r\nrtl8xxxu_save_regs(priv, rtl8723au_iqk_phy_iq_bb_reg,\r\npriv->bb_recovery_backup, RTL8XXXU_BB_REGS);\r\n}\r\nstatic void rtl8723a_phy_lc_calibrate(struct rtl8xxxu_priv *priv)\r\n{\r\nu32 val32;\r\nu32 rf_amode, rf_bmode = 0, lstf;\r\nlstf = rtl8xxxu_read32(priv, REG_OFDM1_LSTF);\r\nif (lstf & OFDM_LSTF_MASK) {\r\nval32 = lstf & ~OFDM_LSTF_MASK;\r\nrtl8xxxu_write32(priv, REG_OFDM1_LSTF, val32);\r\nrf_amode = rtl8xxxu_read_rfreg(priv, RF_A, RF6052_REG_AC);\r\nrtl8xxxu_write_rfreg(priv, RF_A, RF6052_REG_AC,\r\n(rf_amode & 0x8ffff) | 0x10000);\r\nif (priv->tx_paths > 1) {\r\nrf_bmode = rtl8xxxu_read_rfreg(priv, RF_B,\r\nRF6052_REG_AC);\r\nrtl8xxxu_write_rfreg(priv, RF_B, RF6052_REG_AC,\r\n(rf_bmode & 0x8ffff) | 0x10000);\r\n}\r\n} else {\r\nrtl8xxxu_write8(priv, REG_TXPAUSE, 0xff);\r\n}\r\nval32 = rtl8xxxu_read_rfreg(priv, RF_A, RF6052_REG_MODE_AG);\r\nval32 |= 0x08000;\r\nrtl8xxxu_write_rfreg(priv, RF_A, RF6052_REG_MODE_AG, val32);\r\nmsleep(100);\r\nif (lstf & OFDM_LSTF_MASK) {\r\nrtl8xxxu_write32(priv, REG_OFDM1_LSTF, lstf);\r\nrtl8xxxu_write_rfreg(priv, RF_A, RF6052_REG_AC, rf_amode);\r\nif (priv->tx_paths > 1)\r\nrtl8xxxu_write_rfreg(priv, RF_B, RF6052_REG_AC,\r\nrf_bmode);\r\n} else\r\nrtl8xxxu_write8(priv, REG_TXPAUSE, 0x00);\r\n}\r\nstatic int rtl8xxxu_set_mac(struct rtl8xxxu_priv *priv)\r\n{\r\nint i;\r\nu16 reg;\r\nreg = REG_MACID;\r\nfor (i = 0; i < ETH_ALEN; i++)\r\nrtl8xxxu_write8(priv, reg + i, priv->mac_addr[i]);\r\nreturn 0;\r\n}\r\nstatic int rtl8xxxu_set_bssid(struct rtl8xxxu_priv *priv, const u8 *bssid)\r\n{\r\nint i;\r\nu16 reg;\r\ndev_dbg(&priv->udev->dev, "%s: (%pM)\n", __func__, bssid);\r\nreg = REG_BSSID;\r\nfor (i = 0; i < ETH_ALEN; i++)\r\nrtl8xxxu_write8(priv, reg + i, bssid[i]);\r\nreturn 0;\r\n}\r\nstatic void\r\nrtl8xxxu_set_ampdu_factor(struct rtl8xxxu_priv *priv, u8 ampdu_factor)\r\n{\r\nu8 vals[4] = { 0x41, 0xa8, 0x72, 0xb9 };\r\nu8 max_agg = 0xf;\r\nint i;\r\nampdu_factor = 1 << (ampdu_factor + 2);\r\nif (ampdu_factor > max_agg)\r\nampdu_factor = max_agg;\r\nfor (i = 0; i < 4; i++) {\r\nif ((vals[i] & 0xf0) > (ampdu_factor << 4))\r\nvals[i] = (vals[i] & 0x0f) | (ampdu_factor << 4);\r\nif ((vals[i] & 0x0f) > ampdu_factor)\r\nvals[i] = (vals[i] & 0xf0) | ampdu_factor;\r\nrtl8xxxu_write8(priv, REG_AGGLEN_LMT + i, vals[i]);\r\n}\r\n}\r\nstatic void rtl8xxxu_set_ampdu_min_space(struct rtl8xxxu_priv *priv, u8 density)\r\n{\r\nu8 val8;\r\nval8 = rtl8xxxu_read8(priv, REG_AMPDU_MIN_SPACE);\r\nval8 &= 0xf8;\r\nval8 |= density;\r\nrtl8xxxu_write8(priv, REG_AMPDU_MIN_SPACE, val8);\r\n}\r\nstatic int rtl8xxxu_active_to_emu(struct rtl8xxxu_priv *priv)\r\n{\r\nu8 val8;\r\nint count, ret;\r\nrtl8xxxu_write8(priv, REG_RF_CTRL, 0);\r\nval8 = rtl8xxxu_read8(priv, REG_LEDCFG2);\r\nval8 &= ~LEDCFG2_DPDT_SELECT;\r\nrtl8xxxu_write8(priv, REG_LEDCFG2, val8);\r\nval8 = rtl8xxxu_read8(priv, REG_APS_FSMCO + 1);\r\nval8 |= BIT(1);\r\nrtl8xxxu_write8(priv, REG_APS_FSMCO + 1, val8);\r\nfor (count = RTL8XXXU_MAX_REG_POLL; count; count--) {\r\nval8 = rtl8xxxu_read8(priv, REG_APS_FSMCO + 1);\r\nif ((val8 & BIT(1)) == 0)\r\nbreak;\r\nudelay(10);\r\n}\r\nif (!count) {\r\ndev_warn(&priv->udev->dev, "%s: Disabling MAC timed out\n",\r\n__func__);\r\nret = -EBUSY;\r\ngoto exit;\r\n}\r\nval8 = rtl8xxxu_read8(priv, REG_SYS_ISO_CTRL);\r\nval8 |= SYS_ISO_ANALOG_IPS;\r\nrtl8xxxu_write8(priv, REG_SYS_ISO_CTRL, val8);\r\nval8 = rtl8xxxu_read8(priv, REG_LDOA15_CTRL);\r\nval8 &= ~LDOA15_ENABLE;\r\nrtl8xxxu_write8(priv, REG_LDOA15_CTRL, val8);\r\nexit:\r\nreturn ret;\r\n}\r\nstatic int rtl8xxxu_active_to_lps(struct rtl8xxxu_priv *priv)\r\n{\r\nu8 val8;\r\nu8 val32;\r\nint count, ret;\r\nrtl8xxxu_write8(priv, REG_TXPAUSE, 0xff);\r\nfor (count = RTL8XXXU_MAX_REG_POLL; count; count--) {\r\nval32 = rtl8xxxu_read32(priv, 0x5f8);\r\nif (!val32)\r\nbreak;\r\nudelay(10);\r\n}\r\nif (!count) {\r\ndev_warn(&priv->udev->dev,\r\n"%s: RX poll timed out (0x05f8)\n", __func__);\r\nret = -EBUSY;\r\ngoto exit;\r\n}\r\nval8 = rtl8xxxu_read8(priv, REG_SYS_FUNC);\r\nval8 &= ~SYS_FUNC_BBRSTB;\r\nrtl8xxxu_write8(priv, REG_SYS_FUNC, val8);\r\nudelay(2);\r\nval8 = rtl8xxxu_read8(priv, REG_SYS_FUNC);\r\nval8 &= ~SYS_FUNC_BB_GLB_RSTN;\r\nrtl8xxxu_write8(priv, REG_SYS_FUNC, val8);\r\nval8 = rtl8xxxu_read8(priv, REG_CR);\r\nval8 = CR_HCI_TXDMA_ENABLE | CR_HCI_RXDMA_ENABLE;\r\nrtl8xxxu_write8(priv, REG_CR, val8);\r\nval8 = rtl8xxxu_read8(priv, REG_CR + 1);\r\nval8 &= ~BIT(1);\r\nrtl8xxxu_write8(priv, REG_CR + 1, val8);\r\nval8 = rtl8xxxu_read8(priv, REG_DUAL_TSF_RST);\r\nval8 |= DUAL_TSF_TX_OK;\r\nrtl8xxxu_write8(priv, REG_DUAL_TSF_RST, val8);\r\nexit:\r\nreturn ret;\r\n}\r\nstatic void rtl8xxxu_disabled_to_emu(struct rtl8xxxu_priv *priv)\r\n{\r\nu8 val8;\r\nval8 = rtl8xxxu_read8(priv, REG_APS_FSMCO + 1);\r\nval8 &= ~(BIT(3) | BIT(7));\r\nrtl8xxxu_write8(priv, REG_APS_FSMCO + 1, val8);\r\nval8 = rtl8xxxu_read8(priv, REG_GPIO_INTM + 2);\r\nval8 &= ~BIT(0);\r\nrtl8xxxu_write8(priv, REG_GPIO_INTM + 2, val8);\r\nval8 = rtl8xxxu_read8(priv, REG_APS_FSMCO + 1);\r\nval8 &= ~(BIT(3) | BIT(4));\r\nrtl8xxxu_write8(priv, REG_APS_FSMCO + 1, val8);\r\n}\r\nstatic int rtl8xxxu_emu_to_active(struct rtl8xxxu_priv *priv)\r\n{\r\nu8 val8;\r\nu32 val32;\r\nint count, ret = 0;\r\nval8 = rtl8xxxu_read8(priv, REG_LDOA15_CTRL);\r\nval8 |= LDOA15_ENABLE;\r\nrtl8xxxu_write8(priv, REG_LDOA15_CTRL, val8);\r\nval8 = rtl8xxxu_read8(priv, 0x0067);\r\nval8 &= ~BIT(4);\r\nrtl8xxxu_write8(priv, 0x0067, val8);\r\nmdelay(1);\r\nval8 = rtl8xxxu_read8(priv, REG_SYS_ISO_CTRL);\r\nval8 &= ~SYS_ISO_ANALOG_IPS;\r\nrtl8xxxu_write8(priv, REG_SYS_ISO_CTRL, val8);\r\nval8 = rtl8xxxu_read8(priv, REG_APS_FSMCO + 1);\r\nval8 &= ~BIT(2);\r\nrtl8xxxu_write8(priv, REG_APS_FSMCO + 1, val8);\r\nfor (count = RTL8XXXU_MAX_REG_POLL; count; count--) {\r\nval32 = rtl8xxxu_read32(priv, REG_APS_FSMCO);\r\nif (val32 & BIT(17))\r\nbreak;\r\nudelay(10);\r\n}\r\nif (!count) {\r\nret = -EBUSY;\r\ngoto exit;\r\n}\r\nval8 = rtl8xxxu_read8(priv, REG_APS_FSMCO + 2);\r\nval8 |= BIT(0);\r\nrtl8xxxu_write8(priv, REG_APS_FSMCO + 2, val8);\r\nval8 = rtl8xxxu_read8(priv, REG_APS_FSMCO + 1);\r\nval8 &= ~BIT(7);\r\nrtl8xxxu_write8(priv, REG_APS_FSMCO + 1, val8);\r\nval8 = rtl8xxxu_read8(priv, REG_APS_FSMCO + 1);\r\nval8 &= ~(BIT(3) | BIT(4));\r\nrtl8xxxu_write8(priv, REG_APS_FSMCO + 1, val8);\r\nval32 = rtl8xxxu_read32(priv, REG_APS_FSMCO);\r\nval32 |= APS_FSMCO_MAC_ENABLE;\r\nrtl8xxxu_write32(priv, REG_APS_FSMCO, val32);\r\nfor (count = RTL8XXXU_MAX_REG_POLL; count; count--) {\r\nval32 = rtl8xxxu_read32(priv, REG_APS_FSMCO);\r\nif ((val32 & APS_FSMCO_MAC_ENABLE) == 0) {\r\nret = 0;\r\nbreak;\r\n}\r\nudelay(10);\r\n}\r\nif (!count) {\r\nret = -EBUSY;\r\ngoto exit;\r\n}\r\nval8 = rtl8xxxu_read8(priv, REG_LEDCFG2);\r\nval8 |= LEDCFG2_DPDT_SELECT;\r\nval8 &= ~LEDCFG2_DPDT_SELECT;\r\nrtl8xxxu_write8(priv, REG_LEDCFG2, val8);\r\nexit:\r\nreturn ret;\r\n}\r\nstatic int rtl8xxxu_emu_to_disabled(struct rtl8xxxu_priv *priv)\r\n{\r\nu8 val8;\r\nrtl8xxxu_write8(priv, REG_APS_FSMCO + 3, 0x20);\r\nval8 = rtl8xxxu_read8(priv, REG_APS_FSMCO + 1);\r\nval8 &= ~BIT(4);\r\nval8 |= BIT(3);\r\nrtl8xxxu_write8(priv, REG_APS_FSMCO + 1, val8);\r\nval8 = rtl8xxxu_read8(priv, REG_APS_FSMCO + 1);\r\nval8 |= BIT(7);\r\nrtl8xxxu_write8(priv, REG_APS_FSMCO + 1, val8);\r\nval8 = rtl8xxxu_read8(priv, REG_GPIO_INTM + 2);\r\nval8 |= BIT(0);\r\nrtl8xxxu_write8(priv, REG_GPIO_INTM + 2, val8);\r\nreturn 0;\r\n}\r\nstatic int rtl8723au_power_on(struct rtl8xxxu_priv *priv)\r\n{\r\nu8 val8;\r\nu16 val16;\r\nu32 val32;\r\nint ret;\r\nrtl8xxxu_write8(priv, REG_RSV_CTRL, 0x0);\r\nrtl8xxxu_disabled_to_emu(priv);\r\nret = rtl8xxxu_emu_to_active(priv);\r\nif (ret)\r\ngoto exit;\r\nval8 = rtl8xxxu_read8(priv, REG_APS_FSMCO + 2);\r\nval8 |= BIT(3);\r\nrtl8xxxu_write8(priv, REG_APS_FSMCO + 2, val8);\r\nval16 = rtl8xxxu_read16(priv, REG_CR);\r\nval16 |= (CR_HCI_TXDMA_ENABLE | CR_HCI_RXDMA_ENABLE |\r\nCR_TXDMA_ENABLE | CR_RXDMA_ENABLE |\r\nCR_PROTOCOL_ENABLE | CR_SCHEDULE_ENABLE |\r\nCR_MAC_TX_ENABLE | CR_MAC_RX_ENABLE |\r\nCR_SECURITY_ENABLE | CR_CALTIMER_ENABLE);\r\nrtl8xxxu_write16(priv, REG_CR, val16);\r\nval32 = rtl8xxxu_read32(priv, REG_EFUSE_CTRL);\r\nval32 &= ~(BIT(28) | BIT(29) | BIT(30));\r\nval32 |= (0x06 << 28);\r\nrtl8xxxu_write32(priv, REG_EFUSE_CTRL, val32);\r\nexit:\r\nreturn ret;\r\n}\r\nstatic int rtl8192cu_power_on(struct rtl8xxxu_priv *priv)\r\n{\r\nu8 val8;\r\nu16 val16;\r\nu32 val32;\r\nint i;\r\nfor (i = 100; i; i--) {\r\nval8 = rtl8xxxu_read8(priv, REG_APS_FSMCO);\r\nif (val8 & APS_FSMCO_PFM_ALDN)\r\nbreak;\r\n}\r\nif (!i) {\r\npr_info("%s: Poll failed\n", __func__);\r\nreturn -ENODEV;\r\n}\r\nrtl8xxxu_write8(priv, REG_RSV_CTRL, 0x0);\r\nrtl8xxxu_write8(priv, REG_SPS0_CTRL, 0x2b);\r\nudelay(100);\r\nval8 = rtl8xxxu_read8(priv, REG_LDOV12D_CTRL);\r\nif (!(val8 & LDOV12D_ENABLE)) {\r\npr_info("%s: Enabling LDOV12D (%02x)\n", __func__, val8);\r\nval8 |= LDOV12D_ENABLE;\r\nrtl8xxxu_write8(priv, REG_LDOV12D_CTRL, val8);\r\nudelay(100);\r\nval8 = rtl8xxxu_read8(priv, REG_SYS_ISO_CTRL);\r\nval8 &= ~SYS_ISO_MD2PP;\r\nrtl8xxxu_write8(priv, REG_SYS_ISO_CTRL, val8);\r\n}\r\nval16 = rtl8xxxu_read16(priv, REG_APS_FSMCO);\r\nval16 |= APS_FSMCO_MAC_ENABLE;\r\nrtl8xxxu_write16(priv, REG_APS_FSMCO, val16);\r\nfor (i = 1000; i; i--) {\r\nval16 = rtl8xxxu_read16(priv, REG_APS_FSMCO);\r\nif (!(val16 & APS_FSMCO_MAC_ENABLE))\r\nbreak;\r\n}\r\nif (!i) {\r\npr_info("%s: FSMCO_MAC_ENABLE poll failed\n", __func__);\r\nreturn -EBUSY;\r\n}\r\nval16 = APS_FSMCO_HW_SUSPEND | APS_FSMCO_ENABLE_POWERDOWN |\r\nAPS_FSMCO_PFM_ALDN;\r\nrtl8xxxu_write16(priv, REG_APS_FSMCO, val16);\r\nval16 = rtl8xxxu_read16(priv, REG_SYS_ISO_CTRL);\r\nval16 &= ~SYS_ISO_DIOR;\r\nrtl8xxxu_write16(priv, REG_SYS_ISO_CTRL, val16);\r\nval8 = rtl8xxxu_read8(priv, REG_APSD_CTRL);\r\nval8 &= ~APSD_CTRL_OFF;\r\nrtl8xxxu_write8(priv, REG_APSD_CTRL, val8);\r\nfor (i = 200; i; i--) {\r\nval8 = rtl8xxxu_read8(priv, REG_APSD_CTRL);\r\nif (!(val8 & APSD_CTRL_OFF_STATUS))\r\nbreak;\r\n}\r\nif (!i) {\r\npr_info("%s: APSD_CTRL poll failed\n", __func__);\r\nreturn -EBUSY;\r\n}\r\nval16 = rtl8xxxu_read16(priv, REG_CR);\r\nval16 |= CR_HCI_TXDMA_ENABLE | CR_HCI_RXDMA_ENABLE |\r\nCR_TXDMA_ENABLE | CR_RXDMA_ENABLE | CR_PROTOCOL_ENABLE |\r\nCR_SCHEDULE_ENABLE | CR_MAC_TX_ENABLE | CR_MAC_RX_ENABLE;\r\nrtl8xxxu_write16(priv, REG_CR, val16);\r\nif (priv->rtlchip == 0x8188c && priv->hi_pa) {\r\nval32 = rtl8xxxu_read32(priv, REG_FPGA0_XCD_RF_PARM);\r\nval32 &= ~BIT(1);\r\nrtl8xxxu_write32(priv, REG_FPGA0_XCD_RF_PARM, val32);\r\n}\r\nreturn 0;\r\n}\r\nstatic void rtl8xxxu_power_off(struct rtl8xxxu_priv *priv)\r\n{\r\nu8 val8;\r\nu16 val16;\r\nu32 val32;\r\nif (priv->rtlchip == 0x8188c && priv->hi_pa) {\r\nval32 = rtl8xxxu_read32(priv, REG_FPGA0_XCD_RF_PARM);\r\nval32 |= BIT(1);\r\nrtl8xxxu_write32(priv, REG_FPGA0_XCD_RF_PARM, val32);\r\n}\r\nrtl8xxxu_active_to_lps(priv);\r\nrtl8xxxu_write8(priv, REG_RF_CTRL, 0x00);\r\nif (rtl8xxxu_read8(priv, REG_MCU_FW_DL) & MCU_FW_RAM_SEL)\r\nrtl8xxxu_firmware_self_reset(priv);\r\nval16 = rtl8xxxu_read16(priv, REG_SYS_FUNC);\r\nval16 &= ~SYS_FUNC_CPU_ENABLE;\r\nrtl8xxxu_write16(priv, REG_SYS_FUNC, val16);\r\nrtl8xxxu_write8(priv, REG_MCU_FW_DL, 0x00);\r\nrtl8xxxu_active_to_emu(priv);\r\nrtl8xxxu_emu_to_disabled(priv);\r\nval8 = rtl8xxxu_read8(priv, REG_RSV_CTRL + 1);\r\nval8 &= ~BIT(0);\r\nrtl8xxxu_write8(priv, REG_RSV_CTRL + 1, val8);\r\nval8 = rtl8xxxu_read8(priv, REG_RSV_CTRL + 1);\r\nval8 |= BIT(0);\r\nrtl8xxxu_write8(priv, REG_RSV_CTRL + 1, val8);\r\nrtl8xxxu_write8(priv, REG_RSV_CTRL, 0x0e);\r\n}\r\nstatic void rtl8xxxu_init_bt(struct rtl8xxxu_priv *priv)\r\n{\r\nif (!priv->has_bluetooth)\r\nreturn;\r\n}\r\nstatic int rtl8xxxu_init_device(struct ieee80211_hw *hw)\r\n{\r\nstruct rtl8xxxu_priv *priv = hw->priv;\r\nstruct device *dev = &priv->udev->dev;\r\nstruct rtl8xxxu_rfregval *rftable;\r\nbool macpower;\r\nint ret;\r\nu8 val8;\r\nu16 val16;\r\nu32 val32;\r\nval8 = rtl8xxxu_read8(priv, REG_CR);\r\nif (val8 == 0xea)\r\nmacpower = false;\r\nelse\r\nmacpower = true;\r\nret = priv->fops->power_on(priv);\r\nif (ret < 0) {\r\ndev_warn(dev, "%s: Failed power on\n", __func__);\r\ngoto exit;\r\n}\r\ndev_dbg(dev, "%s: macpower %i\n", __func__, macpower);\r\nif (!macpower) {\r\nret = rtl8xxxu_init_llt_table(priv, TX_TOTAL_PAGE_NUM);\r\nif (ret) {\r\ndev_warn(dev, "%s: LLT table init failed\n", __func__);\r\ngoto exit;\r\n}\r\n}\r\nret = rtl8xxxu_download_firmware(priv);\r\ndev_dbg(dev, "%s: download_fiwmare %i\n", __func__, ret);\r\nif (ret)\r\ngoto exit;\r\nret = rtl8xxxu_start_firmware(priv);\r\ndev_dbg(dev, "%s: start_fiwmare %i\n", __func__, ret);\r\nif (ret)\r\ngoto exit;\r\nret = rtl8xxxu_init_mac(priv, rtl8723a_mac_init_table);\r\ndev_dbg(dev, "%s: init_mac %i\n", __func__, ret);\r\nif (ret)\r\ngoto exit;\r\nret = rtl8xxxu_init_phy_bb(priv);\r\ndev_dbg(dev, "%s: init_phy_bb %i\n", __func__, ret);\r\nif (ret)\r\ngoto exit;\r\nswitch(priv->rtlchip) {\r\ncase 0x8723a:\r\nrftable = rtl8723au_radioa_1t_init_table;\r\nret = rtl8xxxu_init_phy_rf(priv, rftable, RF_A);\r\nbreak;\r\ncase 0x8188c:\r\nif (priv->hi_pa)\r\nrftable = rtl8188ru_radioa_1t_highpa_table;\r\nelse\r\nrftable = rtl8192cu_radioa_1t_init_table;\r\nret = rtl8xxxu_init_phy_rf(priv, rftable, RF_A);\r\nbreak;\r\ncase 0x8191c:\r\nrftable = rtl8192cu_radioa_1t_init_table;\r\nret = rtl8xxxu_init_phy_rf(priv, rftable, RF_A);\r\nbreak;\r\ncase 0x8192c:\r\nrftable = rtl8192cu_radioa_2t_init_table;\r\nret = rtl8xxxu_init_phy_rf(priv, rftable, RF_A);\r\nif (ret)\r\nbreak;\r\nrftable = rtl8192cu_radiob_2t_init_table;\r\nret = rtl8xxxu_init_phy_rf(priv, rftable, RF_B);\r\nbreak;\r\ndefault:\r\nret = -EINVAL;\r\n}\r\nif (ret)\r\ngoto exit;\r\nrtl8xxxu_write32(priv, REG_AFE_XTAL_CTRL, 0x0381808d);\r\nrtl8xxxu_write32(priv, REG_AFE_PLL_CTRL, 0xf0ffff83);\r\nrtl8xxxu_write32(priv, REG_AFE_PLL_CTRL, 0xf0ffff82);\r\nrtl8xxxu_write32(priv, REG_AFE_PLL_CTRL, 0xf0ffff83);\r\nrtl8xxxu_write32(priv, REG_FPGA0_TX_INFO, 0x00000003);\r\nval32 = FPGA0_RF_TRSW | FPGA0_RF_TRSWB | FPGA0_RF_ANTSW |\r\nFPGA0_RF_ANTSWB | FPGA0_RF_PAPE |\r\n((FPGA0_RF_ANTSW | FPGA0_RF_ANTSWB | FPGA0_RF_PAPE) <<\r\nFPGA0_RF_BD_CTRL_SHIFT);\r\nrtl8xxxu_write32(priv, REG_FPGA0_XAB_RF_SW_CTRL, val32);\r\nrtl8xxxu_write32(priv, REG_FPGA0_XA_RF_INT_OE, 0x66F60210);\r\npriv->rf_mode_ag[0] = rtl8xxxu_read_rfreg(priv, RF_A,\r\nRF6052_REG_MODE_AG);\r\ndev_dbg(dev, "%s: macpower %i\n", __func__, macpower);\r\nif (!macpower) {\r\nif (priv->ep_tx_normal_queue)\r\nval8 = TX_PAGE_NUM_NORM_PQ;\r\nelse\r\nval8 = 0;\r\nrtl8xxxu_write8(priv, REG_RQPN_NPQ, val8);\r\nval32 = (TX_PAGE_NUM_PUBQ << RQPN_NORM_PQ_SHIFT) | RQPN_LOAD;\r\nif (priv->ep_tx_high_queue)\r\nval32 |= (TX_PAGE_NUM_HI_PQ << RQPN_HI_PQ_SHIFT);\r\nif (priv->ep_tx_low_queue)\r\nval32 |= (TX_PAGE_NUM_LO_PQ << RQPN_LO_PQ_SHIFT);\r\nrtl8xxxu_write32(priv, REG_RQPN, val32);\r\nval8 = TX_TOTAL_PAGE_NUM + 1;\r\nrtl8xxxu_write8(priv, REG_TXPKTBUF_BCNQ_BDNY, val8);\r\nrtl8xxxu_write8(priv, REG_TXPKTBUF_MGQ_BDNY, val8);\r\nrtl8xxxu_write8(priv, REG_TXPKTBUF_WMAC_LBK_BF_HD, val8);\r\nrtl8xxxu_write8(priv, REG_TRXFF_BNDY, val8);\r\nrtl8xxxu_write8(priv, REG_TDECTRL + 1, val8);\r\n}\r\nret = rtl8xxxu_init_queue_priority(priv);\r\ndev_dbg(dev, "%s: init_queue_priority %i\n", __func__, ret);\r\nif (ret)\r\ngoto exit;\r\nrtl8xxxu_write16(priv, REG_TRXFF_BNDY + 2, 0x27ff);\r\nval8 = (PBP_PAGE_SIZE_128 << PBP_PAGE_SIZE_RX_SHIFT) |\r\n(PBP_PAGE_SIZE_128 << PBP_PAGE_SIZE_TX_SHIFT);\r\nrtl8xxxu_write8(priv, REG_PBP, val8);\r\nrtl8xxxu_write8(priv, REG_RX_DRVINFO_SZ, 4);\r\nrtl8xxxu_write32(priv, REG_HISR, 0xffffffff);\r\nrtl8xxxu_write32(priv, REG_HIMR, 0xffffffff);\r\nrtl8xxxu_set_mac(priv);\r\nrtl8xxxu_set_linktype(priv, NL80211_IFTYPE_STATION);\r\nval32 = RCR_ACCEPT_PHYS_MATCH | RCR_ACCEPT_MCAST | RCR_ACCEPT_BCAST |\r\nRCR_ACCEPT_MGMT_FRAME | RCR_HTC_LOC_CTRL |\r\nRCR_APPEND_PHYSTAT | RCR_APPEND_ICV | RCR_APPEND_MIC;\r\nrtl8xxxu_write32(priv, REG_RCR, val32);\r\nrtl8xxxu_write32(priv, REG_MAR, 0xffffffff);\r\nrtl8xxxu_write32(priv, REG_MAR + 4, 0xffffffff);\r\nval32 = rtl8xxxu_read32(priv, REG_RESPONSE_RATE_SET);\r\nval32 &= ~RESPONSE_RATE_BITMAP_ALL;\r\nval32 |= RESPONSE_RATE_RRSR_CCK_ONLY_1M;\r\nrtl8xxxu_write32(priv, REG_RESPONSE_RATE_SET, val32);\r\nrtl8xxxu_set_spec_sifs(priv, 0x10, 0x10);\r\nrtl8xxxu_set_retry(priv, 0x30, 0x30);\r\nrtl8xxxu_set_spec_sifs(priv, 0x0a, 0x10);\r\nrtl8xxxu_write16(priv, REG_MAC_SPEC_SIFS, 0x100a);\r\nrtl8xxxu_write16(priv, REG_SIFS_CCK, 0x100a);\r\nrtl8xxxu_write16(priv, REG_SIFS_OFDM, 0x100a);\r\nrtl8xxxu_write32(priv, REG_EDCA_BE_PARAM, 0x005ea42b);\r\nrtl8xxxu_write32(priv, REG_EDCA_BK_PARAM, 0x0000a44f);\r\nrtl8xxxu_write32(priv, REG_EDCA_VI_PARAM, 0x005ea324);\r\nrtl8xxxu_write32(priv, REG_EDCA_VO_PARAM, 0x002fa226);\r\nrtl8xxxu_write32(priv, REG_DARFRC, 0x00000000);\r\nrtl8xxxu_write32(priv, REG_DARFRC + 4, 0x10080404);\r\nrtl8xxxu_write32(priv, REG_RARFRC, 0x04030201);\r\nrtl8xxxu_write32(priv, REG_RARFRC + 4, 0x08070605);\r\nval8 = rtl8xxxu_read8(priv, REG_FWHW_TXQ_CTRL);\r\nval8 |= FWHW_TXQ_CTRL_AMPDU_RETRY;\r\nrtl8xxxu_write8(priv, REG_FWHW_TXQ_CTRL, val8);\r\nrtl8xxxu_write8(priv, REG_ACKTO, 0x40);\r\nval16 = BEACON_DISABLE_TSF_UPDATE | (BEACON_DISABLE_TSF_UPDATE << 8);\r\nrtl8xxxu_write16(priv, REG_BEACON_CTRL, val16);\r\nrtl8xxxu_write16(priv, REG_TBTT_PROHIBIT, 0x6404);\r\nrtl8xxxu_write8(priv, REG_DRIVER_EARLY_INT, DRIVER_EARLY_INT_TIME);\r\nrtl8xxxu_write8(priv, REG_BEACON_DMA_TIME, BEACON_DMA_ATIME_INT_TIME);\r\nrtl8xxxu_write16(priv, REG_BEACON_TCFG, 0x660F);\r\nval32 = rtl8xxxu_read32(priv, REG_FPGA0_RF_MODE);\r\nval32 |= (FPGA_RF_MODE_CCK | FPGA_RF_MODE_OFDM);\r\nrtl8xxxu_write32(priv, REG_FPGA0_RF_MODE, val32);\r\nrtl8xxxu_write32(priv, REG_CAM_CMD, CAM_CMD_POLLING | BIT(30));\r\nrtl8723a_set_tx_power(priv, 1, false);\r\nval8 = rtl8xxxu_read8(priv, REG_LEDCFG2);\r\nval8 |= LEDCFG2_DPDT_SELECT;\r\nrtl8xxxu_write8(priv, REG_LEDCFG2, val8);\r\nrtl8xxxu_write8(priv, REG_HWSEQ_CTRL, 0xff);\r\nrtl8xxxu_write32(priv, REG_BAR_MODE_CTRL, 0x0201ffff);\r\nrtl8xxxu_write16(priv, REG_FAST_EDCA_CTRL, 0);\r\nif (priv->iqk_initialized) {\r\nrtl8xxxu_restore_regs(priv, rtl8723au_iqk_phy_iq_bb_reg,\r\npriv->bb_recovery_backup,\r\nRTL8XXXU_BB_REGS);\r\n} else {\r\nrtl8723a_phy_iq_calibrate(priv);\r\npriv->iqk_initialized = true;\r\n}\r\nrtl8xxxu_write_rfreg(priv, RF_A, RF6052_REG_T_METER, 0x60);\r\nrtl8723a_phy_lc_calibrate(priv);\r\nrtl8xxxu_write8(priv, 0xfe40, 0xe0);\r\nrtl8xxxu_write8(priv, 0xfe41, 0x8d);\r\nrtl8xxxu_write8(priv, 0xfe42, 0x80);\r\nrtl8xxxu_write32(priv, REG_TXDMA_OFFSET_CHK, 0xfd0320);\r\nrtl8xxxu_write8(priv, 0xfe40, 0xe6);\r\nrtl8xxxu_write8(priv, 0xfe41, 0x94);\r\nrtl8xxxu_write8(priv, 0xfe42, 0x80);\r\nrtl8xxxu_write8(priv, 0xfe40, 0xe0);\r\nrtl8xxxu_write8(priv, 0xfe41, 0x19);\r\nrtl8xxxu_write8(priv, 0xfe42, 0x80);\r\nrtl8xxxu_write8(priv, 0xfe40, 0xe5);\r\nrtl8xxxu_write8(priv, 0xfe41, 0x91);\r\nrtl8xxxu_write8(priv, 0xfe42, 0x80);\r\nrtl8xxxu_write8(priv, 0xfe40, 0xe2);\r\nrtl8xxxu_write8(priv, 0xfe41, 0x81);\r\nrtl8xxxu_write8(priv, 0xfe42, 0x80);\r\nrtl8xxxu_init_bt(priv);\r\nval32 = rtl8xxxu_read32(priv, REG_FPGA0_XA_HSSI_PARM2);\r\nif (val32 & FPGA0_HSSI_PARM2_CCK_HIGH_PWR)\r\npriv->path_a_hi_power = 1;\r\nval32 = rtl8xxxu_read32(priv, REG_OFDM0_TRX_PATH_ENABLE);\r\npriv->path_a_rf_paths = val32 & OFDM_RF_PATH_RX_MASK;\r\nval32 = rtl8xxxu_read32(priv, REG_OFDM0_XA_AGC_CORE1);\r\npriv->path_a_ig_value = val32 & OFDM0_X_AGC_CORE1_IGI_MASK;\r\nval8 = ((30000 + NAV_UPPER_UNIT - 1) / NAV_UPPER_UNIT);\r\nrtl8xxxu_write8(priv, REG_NAV_UPPER, val8);\r\nval32 = rtl8xxxu_read32(priv, REG_FPGA0_RF_MODE);\r\nif ((val32 & 0xff000000) != 0x83000000) {\r\nval32 |= FPGA_RF_MODE_CCK;\r\nrtl8xxxu_write32(priv, REG_FPGA0_RF_MODE, val32);\r\n}\r\nval32 = rtl8xxxu_read32(priv, REG_FWHW_TXQ_CTRL);\r\nval32 |= FWHW_TXQ_CTRL_XMIT_MGMT_ACK;\r\nrtl8xxxu_write32(priv, REG_FWHW_TXQ_CTRL, val32);\r\nexit:\r\nreturn ret;\r\n}\r\nstatic void rtl8xxxu_disable_device(struct ieee80211_hw *hw)\r\n{\r\nstruct rtl8xxxu_priv *priv = hw->priv;\r\nrtl8xxxu_power_off(priv);\r\n}\r\nstatic void rtl8xxxu_cam_write(struct rtl8xxxu_priv *priv,\r\nstruct ieee80211_key_conf *key, const u8 *mac)\r\n{\r\nu32 cmd, val32, addr, ctrl;\r\nint j, i, tmp_debug;\r\ntmp_debug = rtl8xxxu_debug;\r\nif (rtl8xxxu_debug & RTL8XXXU_DEBUG_KEY)\r\nrtl8xxxu_debug |= RTL8XXXU_DEBUG_REG_WRITE;\r\naddr = key->keyidx << CAM_CMD_KEY_SHIFT;\r\nctrl = (key->cipher & 0x0f) << 2 | key->keyidx | CAM_WRITE_VALID;\r\nfor (j = 5; j >= 0; j--) {\r\nswitch (j) {\r\ncase 0:\r\nval32 = ctrl | (mac[0] << 16) | (mac[1] << 24);\r\nbreak;\r\ncase 1:\r\nval32 = mac[2] | (mac[3] << 8) |\r\n(mac[4] << 16) | (mac[5] << 24);\r\nbreak;\r\ndefault:\r\ni = (j - 2) << 2;\r\nval32 = key->key[i] | (key->key[i + 1] << 8) |\r\nkey->key[i + 2] << 16 | key->key[i + 3] << 24;\r\nbreak;\r\n}\r\nrtl8xxxu_write32(priv, REG_CAM_WRITE, val32);\r\ncmd = CAM_CMD_POLLING | CAM_CMD_WRITE | (addr + j);\r\nrtl8xxxu_write32(priv, REG_CAM_CMD, cmd);\r\nudelay(100);\r\n}\r\nrtl8xxxu_debug = tmp_debug;\r\n}\r\nstatic void rtl8xxxu_sw_scan_start(struct ieee80211_hw *hw,\r\nstruct ieee80211_vif *vif, const u8* mac)\r\n{\r\nstruct rtl8xxxu_priv *priv = hw->priv;\r\nu8 val8;\r\nval8 = rtl8xxxu_read8(priv, REG_BEACON_CTRL);\r\nval8 |= BEACON_DISABLE_TSF_UPDATE;\r\nrtl8xxxu_write8(priv, REG_BEACON_CTRL, val8);\r\n}\r\nstatic void rtl8xxxu_sw_scan_complete(struct ieee80211_hw *hw,\r\nstruct ieee80211_vif *vif)\r\n{\r\nstruct rtl8xxxu_priv *priv = hw->priv;\r\nu8 val8;\r\nval8 = rtl8xxxu_read8(priv, REG_BEACON_CTRL);\r\nval8 &= ~BEACON_DISABLE_TSF_UPDATE;\r\nrtl8xxxu_write8(priv, REG_BEACON_CTRL, val8);\r\n}\r\nstatic void rtl8xxxu_update_rate_mask(struct rtl8xxxu_priv *priv,\r\nu32 ramask, int sgi)\r\n{\r\nstruct h2c_cmd h2c;\r\nh2c.ramask.cmd = H2C_SET_RATE_MASK;\r\nh2c.ramask.mask_lo = cpu_to_le16(ramask & 0xffff);\r\nh2c.ramask.mask_hi = cpu_to_le16(ramask >> 16);\r\nh2c.ramask.arg = 0x80;\r\nif (sgi)\r\nh2c.ramask.arg |= 0x20;\r\ndev_dbg(&priv->udev->dev, "%s: rate mask %08x, arg %02x\n", __func__,\r\nramask, h2c.ramask.arg);\r\nrtl8723a_h2c_cmd(priv, &h2c);\r\n}\r\nstatic void rtl8xxxu_set_basic_rates(struct rtl8xxxu_priv *priv, u32 rate_cfg)\r\n{\r\nu32 val32;\r\nu8 rate_idx = 0;\r\nrate_cfg &= RESPONSE_RATE_BITMAP_ALL;\r\nval32 = rtl8xxxu_read32(priv, REG_RESPONSE_RATE_SET);\r\nval32 &= ~RESPONSE_RATE_BITMAP_ALL;\r\nval32 |= rate_cfg;\r\nrtl8xxxu_write32(priv, REG_RESPONSE_RATE_SET, val32);\r\ndev_dbg(&priv->udev->dev, "%s: rates %08x\n", __func__, rate_cfg);\r\nwhile (rate_cfg) {\r\nrate_cfg = (rate_cfg >> 1);\r\nrate_idx++;\r\n}\r\nrtl8xxxu_write8(priv, REG_INIRTS_RATE_SEL, rate_idx);\r\n}\r\nstatic void\r\nrtl8xxxu_bss_info_changed(struct ieee80211_hw *hw, struct ieee80211_vif *vif,\r\nstruct ieee80211_bss_conf *bss_conf, u32 changed)\r\n{\r\nstruct rtl8xxxu_priv *priv = hw->priv;\r\nstruct device *dev = &priv->udev->dev;\r\nstruct ieee80211_sta *sta;\r\nu32 val32;\r\nu8 val8;\r\nif (changed & BSS_CHANGED_ASSOC) {\r\nstruct h2c_cmd h2c;\r\ndev_dbg(dev, "Changed ASSOC: %i!\n", bss_conf->assoc);\r\nmemset(&h2c, 0, sizeof(struct h2c_cmd));\r\nrtl8xxxu_set_linktype(priv, vif->type);\r\nif (bss_conf->assoc) {\r\nu32 ramask;\r\nint sgi = 0;\r\nrcu_read_lock();\r\nsta = ieee80211_find_sta(vif, bss_conf->bssid);\r\nif (!sta) {\r\ndev_info(dev, "%s: ASSOC no sta found\n",\r\n__func__);\r\nrcu_read_unlock();\r\ngoto error;\r\n}\r\nif (sta->ht_cap.ht_supported)\r\ndev_info(dev, "%s: HT supported\n", __func__);\r\nif (sta->vht_cap.vht_supported)\r\ndev_info(dev, "%s: VHT supported\n", __func__);\r\nramask = (sta->supp_rates[0] & 0xfff) |\r\nsta->ht_cap.mcs.rx_mask[0] << 12 |\r\nsta->ht_cap.mcs.rx_mask[1] << 20;\r\nif (sta->ht_cap.cap &\r\n(IEEE80211_HT_CAP_SGI_40 | IEEE80211_HT_CAP_SGI_20))\r\nsgi = 1;\r\nrcu_read_unlock();\r\nrtl8xxxu_update_rate_mask(priv, ramask, sgi);\r\nval32 = rtl8xxxu_read32(priv, REG_RCR);\r\nval32 |= RCR_CHECK_BSSID_MATCH | RCR_CHECK_BSSID_BEACON;\r\nrtl8xxxu_write32(priv, REG_RCR, val32);\r\nrtl8xxxu_write16(priv, REG_RXFLTMAP2, 0xffff);\r\nrtl8xxxu_write8(priv, REG_BCN_MAX_ERR, 0xff);\r\nrtl8723a_stop_tx_beacon(priv);\r\nrtl8xxxu_write16(priv, REG_BCN_PSR_RPT,\r\n0xc000 | bss_conf->aid);\r\nh2c.joinbss.data = H2C_JOIN_BSS_CONNECT;\r\n} else {\r\nval32 = rtl8xxxu_read32(priv, REG_RCR);\r\nval32 &= ~(RCR_CHECK_BSSID_MATCH |\r\nRCR_CHECK_BSSID_BEACON);\r\nrtl8xxxu_write32(priv, REG_RCR, val32);\r\nval8 = rtl8xxxu_read8(priv, REG_BEACON_CTRL);\r\nval8 |= BEACON_DISABLE_TSF_UPDATE;\r\nrtl8xxxu_write8(priv, REG_BEACON_CTRL, val8);\r\nrtl8xxxu_write16(priv, REG_RXFLTMAP2, 0x0000);\r\nh2c.joinbss.data = H2C_JOIN_BSS_DISCONNECT;\r\n}\r\nh2c.joinbss.cmd = H2C_JOIN_BSS_REPORT;\r\nrtl8723a_h2c_cmd(priv, &h2c);\r\n}\r\nif (changed & BSS_CHANGED_ERP_PREAMBLE) {\r\ndev_dbg(dev, "Changed ERP_PREAMBLE: Use short preamble %i\n",\r\nbss_conf->use_short_preamble);\r\nval32 = rtl8xxxu_read32(priv, REG_RESPONSE_RATE_SET);\r\nif (bss_conf->use_short_preamble)\r\nval32 |= RSR_ACK_SHORT_PREAMBLE;\r\nelse\r\nval32 &= ~RSR_ACK_SHORT_PREAMBLE;\r\nrtl8xxxu_write32(priv, REG_RESPONSE_RATE_SET, val32);\r\n}\r\nif (changed & BSS_CHANGED_ERP_SLOT) {\r\ndev_dbg(dev, "Changed ERP_SLOT: short_slot_time %i\n",\r\nbss_conf->use_short_slot);\r\nif (bss_conf->use_short_slot)\r\nval8 = 9;\r\nelse\r\nval8 = 20;\r\nrtl8xxxu_write8(priv, REG_SLOT, val8);\r\n}\r\nif (changed & BSS_CHANGED_BSSID) {\r\ndev_dbg(dev, "Changed BSSID!\n");\r\nrtl8xxxu_set_bssid(priv, bss_conf->bssid);\r\n}\r\nif (changed & BSS_CHANGED_BASIC_RATES) {\r\ndev_dbg(dev, "Changed BASIC_RATES!\n");\r\nrtl8xxxu_set_basic_rates(priv, bss_conf->basic_rates);\r\n}\r\nerror:\r\nreturn;\r\n}\r\nstatic u32 rtl8xxxu_80211_to_rtl_queue(u32 queue)\r\n{\r\nu32 rtlqueue;\r\nswitch (queue) {\r\ncase IEEE80211_AC_VO:\r\nrtlqueue = TXDESC_QUEUE_VO;\r\nbreak;\r\ncase IEEE80211_AC_VI:\r\nrtlqueue = TXDESC_QUEUE_VI;\r\nbreak;\r\ncase IEEE80211_AC_BE:\r\nrtlqueue = TXDESC_QUEUE_BE;\r\nbreak;\r\ncase IEEE80211_AC_BK:\r\nrtlqueue = TXDESC_QUEUE_BK;\r\nbreak;\r\ndefault:\r\nrtlqueue = TXDESC_QUEUE_BE;\r\n}\r\nreturn rtlqueue;\r\n}\r\nstatic u32 rtl8xxxu_queue_select(struct ieee80211_hw *hw, struct sk_buff *skb)\r\n{\r\nstruct ieee80211_hdr *hdr = (struct ieee80211_hdr *)skb->data;\r\nu32 queue;\r\nif (ieee80211_is_mgmt(hdr->frame_control))\r\nqueue = TXDESC_QUEUE_MGNT;\r\nelse\r\nqueue = rtl8xxxu_80211_to_rtl_queue(skb_get_queue_mapping(skb));\r\nreturn queue;\r\n}\r\nstatic void rtl8xxxu_calc_tx_desc_csum(struct rtl8xxxu_tx_desc *tx_desc)\r\n{\r\n__le16 *ptr = (__le16 *)tx_desc;\r\nu16 csum = 0;\r\nint i;\r\ntx_desc->csum = cpu_to_le16(0);\r\nfor (i = 0; i < (sizeof(struct rtl8xxxu_tx_desc) / sizeof(u16)); i++)\r\ncsum = csum ^ le16_to_cpu(ptr[i]);\r\ntx_desc->csum |= cpu_to_le16(csum);\r\n}\r\nstatic void rtl8xxxu_free_tx_resources(struct rtl8xxxu_priv *priv)\r\n{\r\nstruct rtl8xxxu_tx_urb *tx_urb, *tmp;\r\nunsigned long flags;\r\nspin_lock_irqsave(&priv->tx_urb_lock, flags);\r\nlist_for_each_entry_safe(tx_urb, tmp, &priv->tx_urb_free_list, list) {\r\nlist_del(&tx_urb->list);\r\npriv->tx_urb_free_count--;\r\nusb_free_urb(&tx_urb->urb);\r\n}\r\nspin_unlock_irqrestore(&priv->tx_urb_lock, flags);\r\n}\r\nstatic struct rtl8xxxu_tx_urb *\r\nrtl8xxxu_alloc_tx_urb(struct rtl8xxxu_priv *priv)\r\n{\r\nstruct rtl8xxxu_tx_urb *tx_urb;\r\nunsigned long flags;\r\nspin_lock_irqsave(&priv->tx_urb_lock, flags);\r\ntx_urb = list_first_entry_or_null(&priv->tx_urb_free_list,\r\nstruct rtl8xxxu_tx_urb, list);\r\nif (tx_urb) {\r\nlist_del(&tx_urb->list);\r\npriv->tx_urb_free_count--;\r\nif (priv->tx_urb_free_count < RTL8XXXU_TX_URB_LOW_WATER &&\r\n!priv->tx_stopped) {\r\npriv->tx_stopped = true;\r\nieee80211_stop_queues(priv->hw);\r\n}\r\n}\r\nspin_unlock_irqrestore(&priv->tx_urb_lock, flags);\r\nreturn tx_urb;\r\n}\r\nstatic void rtl8xxxu_free_tx_urb(struct rtl8xxxu_priv *priv,\r\nstruct rtl8xxxu_tx_urb *tx_urb)\r\n{\r\nunsigned long flags;\r\nINIT_LIST_HEAD(&tx_urb->list);\r\nspin_lock_irqsave(&priv->tx_urb_lock, flags);\r\nlist_add(&tx_urb->list, &priv->tx_urb_free_list);\r\npriv->tx_urb_free_count++;\r\nif (priv->tx_urb_free_count > RTL8XXXU_TX_URB_HIGH_WATER &&\r\npriv->tx_stopped) {\r\npriv->tx_stopped = false;\r\nieee80211_wake_queues(priv->hw);\r\n}\r\nspin_unlock_irqrestore(&priv->tx_urb_lock, flags);\r\n}\r\nstatic void rtl8xxxu_tx_complete(struct urb *urb)\r\n{\r\nstruct sk_buff *skb = (struct sk_buff *)urb->context;\r\nstruct ieee80211_tx_info *tx_info;\r\nstruct ieee80211_hw *hw;\r\nstruct rtl8xxxu_tx_urb *tx_urb =\r\ncontainer_of(urb, struct rtl8xxxu_tx_urb, urb);\r\ntx_info = IEEE80211_SKB_CB(skb);\r\nhw = tx_info->rate_driver_data[0];\r\nskb_pull(skb, sizeof(struct rtl8xxxu_tx_desc));\r\nieee80211_tx_info_clear_status(tx_info);\r\ntx_info->status.rates[0].idx = -1;\r\ntx_info->status.rates[0].count = 0;\r\nif (!urb->status)\r\ntx_info->flags |= IEEE80211_TX_STAT_ACK;\r\nieee80211_tx_status_irqsafe(hw, skb);\r\nrtl8xxxu_free_tx_urb(hw->priv, tx_urb);\r\n}\r\nstatic void rtl8xxxu_dump_action(struct device *dev,\r\nstruct ieee80211_hdr *hdr)\r\n{\r\nstruct ieee80211_mgmt *mgmt = (struct ieee80211_mgmt *)hdr;\r\nu16 cap, timeout;\r\nif (!(rtl8xxxu_debug & RTL8XXXU_DEBUG_ACTION))\r\nreturn;\r\nswitch (mgmt->u.action.u.addba_resp.action_code) {\r\ncase WLAN_ACTION_ADDBA_RESP:\r\ncap = le16_to_cpu(mgmt->u.action.u.addba_resp.capab);\r\ntimeout = le16_to_cpu(mgmt->u.action.u.addba_resp.timeout);\r\ndev_info(dev, "WLAN_ACTION_ADDBA_RESP: "\r\n"timeout %i, tid %02x, buf_size %02x, policy %02x, "\r\n"status %02x\n",\r\ntimeout,\r\n(cap & IEEE80211_ADDBA_PARAM_TID_MASK) >> 2,\r\n(cap & IEEE80211_ADDBA_PARAM_BUF_SIZE_MASK) >> 6,\r\n(cap >> 1) & 0x1,\r\nle16_to_cpu(mgmt->u.action.u.addba_resp.status));\r\nbreak;\r\ncase WLAN_ACTION_ADDBA_REQ:\r\ncap = le16_to_cpu(mgmt->u.action.u.addba_req.capab);\r\ntimeout = le16_to_cpu(mgmt->u.action.u.addba_req.timeout);\r\ndev_info(dev, "WLAN_ACTION_ADDBA_REQ: "\r\n"timeout %i, tid %02x, buf_size %02x, policy %02x\n",\r\ntimeout,\r\n(cap & IEEE80211_ADDBA_PARAM_TID_MASK) >> 2,\r\n(cap & IEEE80211_ADDBA_PARAM_BUF_SIZE_MASK) >> 6,\r\n(cap >> 1) & 0x1);\r\nbreak;\r\ndefault:\r\ndev_info(dev, "action frame %02x\n",\r\nmgmt->u.action.u.addba_resp.action_code);\r\nbreak;\r\n}\r\n}\r\nstatic void rtl8xxxu_tx(struct ieee80211_hw *hw,\r\nstruct ieee80211_tx_control *control,\r\nstruct sk_buff *skb)\r\n{\r\nstruct ieee80211_hdr *hdr = (struct ieee80211_hdr *)skb->data;\r\nstruct ieee80211_tx_info *tx_info = IEEE80211_SKB_CB(skb);\r\nstruct ieee80211_rate *tx_rate = ieee80211_get_tx_rate(hw, tx_info);\r\nstruct rtl8xxxu_priv *priv = hw->priv;\r\nstruct rtl8xxxu_tx_desc *tx_desc;\r\nstruct rtl8xxxu_tx_urb *tx_urb;\r\nstruct ieee80211_sta *sta = NULL;\r\nstruct ieee80211_vif *vif = tx_info->control.vif;\r\nstruct device *dev = &priv->udev->dev;\r\nu32 queue, rate;\r\nu16 pktlen = skb->len;\r\nu16 seq_number;\r\nu16 rate_flag = tx_info->control.rates[0].flags;\r\nint ret;\r\nif (skb_headroom(skb) < sizeof(struct rtl8xxxu_tx_desc)) {\r\ndev_warn(dev,\r\n"%s: Not enough headroom (%i) for tx descriptor\n",\r\n__func__, skb_headroom(skb));\r\ngoto error;\r\n}\r\nif (unlikely(skb->len > (65535 - sizeof(struct rtl8xxxu_tx_desc)))) {\r\ndev_warn(dev, "%s: Trying to send over-sized skb (%i)\n",\r\n__func__, skb->len);\r\ngoto error;\r\n}\r\ntx_urb = rtl8xxxu_alloc_tx_urb(priv);\r\nif (!tx_urb) {\r\ndev_warn(dev, "%s: Unable to allocate tx urb\n", __func__);\r\ngoto error;\r\n}\r\nif (rtl8xxxu_debug & RTL8XXXU_DEBUG_TX)\r\ndev_info(dev, "%s: TX rate: %d (%d), pkt size %d\n",\r\n__func__, tx_rate->bitrate, tx_rate->hw_value, pktlen);\r\nif (ieee80211_is_action(hdr->frame_control))\r\nrtl8xxxu_dump_action(dev, hdr);\r\ntx_info->rate_driver_data[0] = hw;\r\nif (control && control->sta)\r\nsta = control->sta;\r\ntx_desc = (struct rtl8xxxu_tx_desc *)\r\nskb_push(skb, sizeof(struct rtl8xxxu_tx_desc));\r\nmemset(tx_desc, 0, sizeof(struct rtl8xxxu_tx_desc));\r\ntx_desc->pkt_size = cpu_to_le16(pktlen);\r\ntx_desc->pkt_offset = sizeof(struct rtl8xxxu_tx_desc);\r\ntx_desc->txdw0 =\r\nTXDESC_OWN | TXDESC_FIRST_SEGMENT | TXDESC_LAST_SEGMENT;\r\nif (is_multicast_ether_addr(ieee80211_get_DA(hdr)) ||\r\nis_broadcast_ether_addr(ieee80211_get_DA(hdr)))\r\ntx_desc->txdw0 |= TXDESC_BROADMULTICAST;\r\nqueue = rtl8xxxu_queue_select(hw, skb);\r\ntx_desc->txdw1 = cpu_to_le32(queue << TXDESC_QUEUE_SHIFT);\r\nif (tx_info->control.hw_key) {\r\nswitch (tx_info->control.hw_key->cipher) {\r\ncase WLAN_CIPHER_SUITE_WEP40:\r\ncase WLAN_CIPHER_SUITE_WEP104:\r\ncase WLAN_CIPHER_SUITE_TKIP:\r\ntx_desc->txdw1 |= cpu_to_le32(TXDESC_SEC_RC4);\r\nbreak;\r\ncase WLAN_CIPHER_SUITE_CCMP:\r\ntx_desc->txdw1 |= cpu_to_le32(TXDESC_SEC_AES);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nseq_number = IEEE80211_SEQ_TO_SN(le16_to_cpu(hdr->seq_ctrl));\r\ntx_desc->txdw3 = cpu_to_le32((u32)seq_number << TXDESC_SEQ_SHIFT);\r\nif (rate_flag & IEEE80211_TX_RC_MCS)\r\nrate = tx_info->control.rates[0].idx + DESC_RATE_MCS0;\r\nelse\r\nrate = tx_rate->hw_value;\r\ntx_desc->txdw5 = cpu_to_le32(rate);\r\nif (ieee80211_is_data(hdr->frame_control))\r\ntx_desc->txdw5 |= cpu_to_le32(0x0001ff00);\r\nif (ieee80211_is_data_qos(hdr->frame_control) && sta) {\r\nif (sta->ht_cap.ht_supported) {\r\nu32 ampdu, val32;\r\nampdu = (u32)sta->ht_cap.ampdu_density;\r\nval32 = ampdu << TXDESC_AMPDU_DENSITY_SHIFT;\r\ntx_desc->txdw2 |= cpu_to_le32(val32);\r\ntx_desc->txdw1 |= cpu_to_le32(TXDESC_AGG_ENABLE);\r\n} else\r\ntx_desc->txdw1 |= cpu_to_le32(TXDESC_BK);\r\n} else\r\ntx_desc->txdw1 |= cpu_to_le32(TXDESC_BK);\r\nif (ieee80211_is_data_qos(hdr->frame_control))\r\ntx_desc->txdw4 |= cpu_to_le32(TXDESC_QOS);\r\nif (rate_flag & IEEE80211_TX_RC_USE_SHORT_PREAMBLE ||\r\n(sta && vif && vif->bss_conf.use_short_preamble))\r\ntx_desc->txdw4 |= cpu_to_le32(TXDESC_SHORT_PREAMBLE);\r\nif (rate_flag & IEEE80211_TX_RC_SHORT_GI ||\r\n(ieee80211_is_data_qos(hdr->frame_control) &&\r\nsta && sta->ht_cap.cap &\r\n(IEEE80211_HT_CAP_SGI_40 | IEEE80211_HT_CAP_SGI_20))) {\r\ntx_desc->txdw5 |= cpu_to_le32(TXDESC_SHORT_GI);\r\n}\r\nif (ieee80211_is_mgmt(hdr->frame_control)) {\r\ntx_desc->txdw5 = cpu_to_le32(tx_rate->hw_value);\r\ntx_desc->txdw4 |= cpu_to_le32(TXDESC_USE_DRIVER_RATE);\r\ntx_desc->txdw5 |= cpu_to_le32(6 << TXDESC_RETRY_LIMIT_SHIFT);\r\ntx_desc->txdw5 |= cpu_to_le32(TXDESC_RETRY_LIMIT_ENABLE);\r\n}\r\nif (rate_flag & IEEE80211_TX_RC_USE_RTS_CTS) {\r\ntx_desc->txdw4 |= cpu_to_le32(DESC_RATE_24M);\r\ntx_desc->txdw4 |= cpu_to_le32(TXDESC_RTS_CTS_ENABLE);\r\ntx_desc->txdw4 |= cpu_to_le32(TXDESC_HW_RTS_ENABLE);\r\n}\r\nrtl8xxxu_calc_tx_desc_csum(tx_desc);\r\nusb_fill_bulk_urb(&tx_urb->urb, priv->udev, priv->pipe_out[queue],\r\nskb->data, skb->len, rtl8xxxu_tx_complete, skb);\r\nusb_anchor_urb(&tx_urb->urb, &priv->tx_anchor);\r\nret = usb_submit_urb(&tx_urb->urb, GFP_ATOMIC);\r\nif (ret) {\r\nusb_unanchor_urb(&tx_urb->urb);\r\nrtl8xxxu_free_tx_urb(priv, tx_urb);\r\ngoto error;\r\n}\r\nreturn;\r\nerror:\r\ndev_kfree_skb(skb);\r\n}\r\nstatic void rtl8xxxu_rx_parse_phystats(struct rtl8xxxu_priv *priv,\r\nstruct ieee80211_rx_status *rx_status,\r\nstruct rtl8xxxu_rx_desc *rx_desc,\r\nstruct rtl8723au_phy_stats *phy_stats)\r\n{\r\nif (phy_stats->sgi_en)\r\nrx_status->flag |= RX_FLAG_SHORT_GI;\r\nif (rx_desc->rxmcs < DESC_RATE_6M) {\r\nu8 cck_agc_rpt = phy_stats->cck_agc_rpt_ofdm_cfosho_a;\r\nswitch (cck_agc_rpt & 0xc0) {\r\ncase 0xc0:\r\nrx_status->signal = -46 - (cck_agc_rpt & 0x3e);\r\nbreak;\r\ncase 0x80:\r\nrx_status->signal = -26 - (cck_agc_rpt & 0x3e);\r\nbreak;\r\ncase 0x40:\r\nrx_status->signal = -12 - (cck_agc_rpt & 0x3e);\r\nbreak;\r\ncase 0x00:\r\nrx_status->signal = 16 - (cck_agc_rpt & 0x3e);\r\nbreak;\r\n}\r\n} else {\r\nrx_status->signal =\r\n(phy_stats->cck_sig_qual_ofdm_pwdb_all >> 1) - 110;\r\n}\r\n}\r\nstatic void rtl8xxxu_free_rx_resources(struct rtl8xxxu_priv *priv)\r\n{\r\nstruct rtl8xxxu_rx_urb *rx_urb, *tmp;\r\nunsigned long flags;\r\nspin_lock_irqsave(&priv->rx_urb_lock, flags);\r\nlist_for_each_entry_safe(rx_urb, tmp,\r\n&priv->rx_urb_pending_list, list) {\r\nlist_del(&rx_urb->list);\r\npriv->rx_urb_pending_count--;\r\nusb_free_urb(&rx_urb->urb);\r\n}\r\nspin_unlock_irqrestore(&priv->rx_urb_lock, flags);\r\n}\r\nstatic void rtl8xxxu_queue_rx_urb(struct rtl8xxxu_priv *priv,\r\nstruct rtl8xxxu_rx_urb *rx_urb)\r\n{\r\nstruct sk_buff *skb;\r\nunsigned long flags;\r\nint pending = 0;\r\nspin_lock_irqsave(&priv->rx_urb_lock, flags);\r\nif (!priv->shutdown) {\r\nlist_add_tail(&rx_urb->list, &priv->rx_urb_pending_list);\r\npriv->rx_urb_pending_count++;\r\npending = priv->rx_urb_pending_count;\r\n} else {\r\nskb = (struct sk_buff *)rx_urb->urb.context;\r\ndev_kfree_skb(skb);\r\nusb_free_urb(&rx_urb->urb);\r\n}\r\nspin_unlock_irqrestore(&priv->rx_urb_lock, flags);\r\nif (pending > RTL8XXXU_RX_URB_PENDING_WATER)\r\nschedule_work(&priv->rx_urb_wq);\r\n}\r\nstatic void rtl8xxxu_rx_urb_work(struct work_struct *work)\r\n{\r\nstruct rtl8xxxu_priv *priv;\r\nstruct rtl8xxxu_rx_urb *rx_urb, *tmp;\r\nstruct list_head local;\r\nstruct sk_buff *skb;\r\nunsigned long flags;\r\nint ret;\r\npriv = container_of(work, struct rtl8xxxu_priv, rx_urb_wq);\r\nINIT_LIST_HEAD(&local);\r\nspin_lock_irqsave(&priv->rx_urb_lock, flags);\r\nlist_splice_init(&priv->rx_urb_pending_list, &local);\r\npriv->rx_urb_pending_count = 0;\r\nspin_unlock_irqrestore(&priv->rx_urb_lock, flags);\r\nlist_for_each_entry_safe(rx_urb, tmp, &local, list) {\r\nlist_del_init(&rx_urb->list);\r\nret = rtl8xxxu_submit_rx_urb(priv, rx_urb);\r\nswitch (ret) {\r\ncase 0:\r\nbreak;\r\ncase -ENOMEM:\r\ncase -EAGAIN:\r\nrtl8xxxu_queue_rx_urb(priv, rx_urb);\r\nbreak;\r\ndefault:\r\npr_info("failed to requeue urb %i\n", ret);\r\nskb = (struct sk_buff *)rx_urb->urb.context;\r\ndev_kfree_skb(skb);\r\nusb_free_urb(&rx_urb->urb);\r\n}\r\n}\r\n}\r\nstatic void rtl8xxxu_rx_complete(struct urb *urb)\r\n{\r\nstruct rtl8xxxu_rx_urb *rx_urb =\r\ncontainer_of(urb, struct rtl8xxxu_rx_urb, urb);\r\nstruct ieee80211_hw *hw = rx_urb->hw;\r\nstruct rtl8xxxu_priv *priv = hw->priv;\r\nstruct sk_buff *skb = (struct sk_buff *)urb->context;\r\nstruct rtl8xxxu_rx_desc *rx_desc = (struct rtl8xxxu_rx_desc *)skb->data;\r\nstruct rtl8723au_phy_stats *phy_stats;\r\nstruct ieee80211_rx_status *rx_status = IEEE80211_SKB_RXCB(skb);\r\nstruct ieee80211_mgmt *mgmt;\r\nstruct device *dev = &priv->udev->dev;\r\n__le32 *_rx_desc_le = (__le32 *)skb->data;\r\nu32 *_rx_desc = (u32 *)skb->data;\r\nint cnt, len, drvinfo_sz, desc_shift, i;\r\nfor (i = 0; i < (sizeof(struct rtl8xxxu_rx_desc) / sizeof(u32)); i++)\r\n_rx_desc[i] = le32_to_cpu(_rx_desc_le[i]);\r\ncnt = rx_desc->frag;\r\nlen = rx_desc->pktlen;\r\ndrvinfo_sz = rx_desc->drvinfo_sz * 8;\r\ndesc_shift = rx_desc->shift;\r\nskb_put(skb, urb->actual_length);\r\nif (urb->status == 0) {\r\nskb_pull(skb, sizeof(struct rtl8xxxu_rx_desc));\r\nphy_stats = (struct rtl8723au_phy_stats *)skb->data;\r\nskb_pull(skb, drvinfo_sz + desc_shift);\r\nmgmt = (struct ieee80211_mgmt *)skb->data;\r\nmemset(rx_status, 0, sizeof(struct ieee80211_rx_status));\r\nif (rx_desc->phy_stats)\r\nrtl8xxxu_rx_parse_phystats(priv, rx_status,\r\nrx_desc, phy_stats);\r\nrx_status->freq = hw->conf.chandef.chan->center_freq;\r\nrx_status->band = hw->conf.chandef.chan->band;\r\nrx_status->mactime = le32_to_cpu(rx_desc->tsfl);\r\nrx_status->flag |= RX_FLAG_MACTIME_START;\r\nif (!rx_desc->swdec)\r\nrx_status->flag |= RX_FLAG_DECRYPTED;\r\nif (rx_desc->crc32)\r\nrx_status->flag |= RX_FLAG_FAILED_FCS_CRC;\r\nif (rx_desc->bw)\r\nrx_status->flag |= RX_FLAG_40MHZ;\r\nif (rx_desc->rxht) {\r\nrx_status->flag |= RX_FLAG_HT;\r\nrx_status->rate_idx = rx_desc->rxmcs - DESC_RATE_MCS0;\r\n} else {\r\nrx_status->rate_idx = rx_desc->rxmcs;\r\n}\r\nieee80211_rx_irqsafe(hw, skb);\r\nskb = NULL;\r\nrx_urb->urb.context = NULL;\r\nrtl8xxxu_queue_rx_urb(priv, rx_urb);\r\n} else {\r\ndev_dbg(dev, "%s: status %i\n", __func__, urb->status);\r\ngoto cleanup;\r\n}\r\nreturn;\r\ncleanup:\r\nusb_free_urb(urb);\r\ndev_kfree_skb(skb);\r\nreturn;\r\n}\r\nstatic int rtl8xxxu_submit_rx_urb(struct rtl8xxxu_priv *priv,\r\nstruct rtl8xxxu_rx_urb *rx_urb)\r\n{\r\nstruct sk_buff *skb;\r\nint skb_size;\r\nint ret;\r\nskb_size = sizeof(struct rtl8xxxu_rx_desc) + RTL_RX_BUFFER_SIZE;\r\nskb = __netdev_alloc_skb(NULL, skb_size, GFP_KERNEL);\r\nif (!skb)\r\nreturn -ENOMEM;\r\nmemset(skb->data, 0, sizeof(struct rtl8xxxu_rx_desc));\r\nusb_fill_bulk_urb(&rx_urb->urb, priv->udev, priv->pipe_in, skb->data,\r\nskb_size, rtl8xxxu_rx_complete, skb);\r\nusb_anchor_urb(&rx_urb->urb, &priv->rx_anchor);\r\nret = usb_submit_urb(&rx_urb->urb, GFP_ATOMIC);\r\nif (ret)\r\nusb_unanchor_urb(&rx_urb->urb);\r\nreturn ret;\r\n}\r\nstatic void rtl8xxxu_int_complete(struct urb *urb)\r\n{\r\nstruct rtl8xxxu_priv *priv = (struct rtl8xxxu_priv *)urb->context;\r\nstruct device *dev = &priv->udev->dev;\r\nint ret;\r\ndev_dbg(dev, "%s: status %i\n", __func__, urb->status);\r\nif (urb->status == 0) {\r\nusb_anchor_urb(urb, &priv->int_anchor);\r\nret = usb_submit_urb(urb, GFP_ATOMIC);\r\nif (ret)\r\nusb_unanchor_urb(urb);\r\n} else {\r\ndev_info(dev, "%s: Error %i\n", __func__, urb->status);\r\n}\r\n}\r\nstatic int rtl8xxxu_submit_int_urb(struct ieee80211_hw *hw)\r\n{\r\nstruct rtl8xxxu_priv *priv = hw->priv;\r\nstruct urb *urb;\r\nu32 val32;\r\nint ret;\r\nurb = usb_alloc_urb(0, GFP_KERNEL);\r\nif (!urb)\r\nreturn -ENOMEM;\r\nusb_fill_int_urb(urb, priv->udev, priv->pipe_interrupt,\r\npriv->int_buf, USB_INTR_CONTENT_LENGTH,\r\nrtl8xxxu_int_complete, priv, 1);\r\nusb_anchor_urb(urb, &priv->int_anchor);\r\nret = usb_submit_urb(urb, GFP_KERNEL);\r\nif (ret) {\r\nusb_unanchor_urb(urb);\r\ngoto error;\r\n}\r\nval32 = rtl8xxxu_read32(priv, REG_USB_HIMR);\r\nval32 |= USB_HIMR_CPWM;\r\nrtl8xxxu_write32(priv, REG_USB_HIMR, val32);\r\nerror:\r\nreturn ret;\r\n}\r\nstatic int rtl8xxxu_add_interface(struct ieee80211_hw *hw,\r\nstruct ieee80211_vif *vif)\r\n{\r\nstruct rtl8xxxu_priv *priv = hw->priv;\r\nint ret;\r\nu8 val8;\r\nswitch (vif->type) {\r\ncase NL80211_IFTYPE_STATION:\r\nrtl8723a_stop_tx_beacon(priv);\r\nval8 = rtl8xxxu_read8(priv, REG_BEACON_CTRL);\r\nval8 |= BEACON_ATIM | BEACON_FUNCTION_ENABLE |\r\nBEACON_DISABLE_TSF_UPDATE;\r\nrtl8xxxu_write8(priv, REG_BEACON_CTRL, val8);\r\nret = 0;\r\nbreak;\r\ndefault:\r\nret = -EOPNOTSUPP;\r\n}\r\nrtl8xxxu_set_linktype(priv, vif->type);\r\nreturn ret;\r\n}\r\nstatic void rtl8xxxu_remove_interface(struct ieee80211_hw *hw,\r\nstruct ieee80211_vif *vif)\r\n{\r\nstruct rtl8xxxu_priv *priv = hw->priv;\r\ndev_dbg(&priv->udev->dev, "%s\n", __func__);\r\n}\r\nstatic int rtl8xxxu_config(struct ieee80211_hw *hw, u32 changed)\r\n{\r\nstruct rtl8xxxu_priv *priv = hw->priv;\r\nstruct device *dev = &priv->udev->dev;\r\nu16 val16;\r\nint ret = 0, channel;\r\nbool ht40;\r\nif (rtl8xxxu_debug & RTL8XXXU_DEBUG_CHANNEL)\r\ndev_info(dev,\r\n"%s: channel: %i (changed %08x chandef.width %02x)\n",\r\n__func__, hw->conf.chandef.chan->hw_value,\r\nchanged, hw->conf.chandef.width);\r\nif (changed & IEEE80211_CONF_CHANGE_RETRY_LIMITS) {\r\nval16 = ((hw->conf.long_frame_max_tx_count <<\r\nRETRY_LIMIT_LONG_SHIFT) & RETRY_LIMIT_LONG_MASK) |\r\n((hw->conf.short_frame_max_tx_count <<\r\nRETRY_LIMIT_SHORT_SHIFT) & RETRY_LIMIT_SHORT_MASK);\r\nrtl8xxxu_write16(priv, REG_RETRY_LIMIT, val16);\r\n}\r\nif (changed & IEEE80211_CONF_CHANGE_CHANNEL) {\r\nswitch (hw->conf.chandef.width) {\r\ncase NL80211_CHAN_WIDTH_20_NOHT:\r\ncase NL80211_CHAN_WIDTH_20:\r\nht40 = false;\r\nbreak;\r\ncase NL80211_CHAN_WIDTH_40:\r\nht40 = true;\r\nbreak;\r\ndefault:\r\nret = -ENOTSUPP;\r\ngoto exit;\r\n}\r\nchannel = hw->conf.chandef.chan->hw_value;\r\nrtl8723a_set_tx_power(priv, channel, ht40);\r\nrtl8723au_config_channel(hw);\r\n}\r\nexit:\r\nreturn ret;\r\n}\r\nstatic int rtl8xxxu_conf_tx(struct ieee80211_hw *hw,\r\nstruct ieee80211_vif *vif, u16 queue,\r\nconst struct ieee80211_tx_queue_params *param)\r\n{\r\nstruct rtl8xxxu_priv *priv = hw->priv;\r\nstruct device *dev = &priv->udev->dev;\r\nu32 val32;\r\nu8 aifs, acm_ctrl, acm_bit;\r\naifs = param->aifs;\r\nval32 = aifs |\r\nfls(param->cw_min) << EDCA_PARAM_ECW_MIN_SHIFT |\r\nfls(param->cw_max) << EDCA_PARAM_ECW_MAX_SHIFT |\r\n(u32)param->txop << EDCA_PARAM_TXOP_SHIFT;\r\nacm_ctrl = rtl8xxxu_read8(priv, REG_ACM_HW_CTRL);\r\ndev_dbg(dev,\r\n"%s: IEEE80211 queue %02x val %08x, acm %i, acm_ctrl %02x\n",\r\n__func__, queue, val32, param->acm, acm_ctrl);\r\nswitch (queue) {\r\ncase IEEE80211_AC_VO:\r\nacm_bit = ACM_HW_CTRL_VO;\r\nrtl8xxxu_write32(priv, REG_EDCA_VO_PARAM, val32);\r\nbreak;\r\ncase IEEE80211_AC_VI:\r\nacm_bit = ACM_HW_CTRL_VI;\r\nrtl8xxxu_write32(priv, REG_EDCA_VI_PARAM, val32);\r\nbreak;\r\ncase IEEE80211_AC_BE:\r\nacm_bit = ACM_HW_CTRL_BE;\r\nrtl8xxxu_write32(priv, REG_EDCA_BE_PARAM, val32);\r\nbreak;\r\ncase IEEE80211_AC_BK:\r\nacm_bit = ACM_HW_CTRL_BK;\r\nrtl8xxxu_write32(priv, REG_EDCA_BK_PARAM, val32);\r\nbreak;\r\ndefault:\r\nacm_bit = 0;\r\nbreak;\r\n}\r\nif (param->acm)\r\nacm_ctrl |= acm_bit;\r\nelse\r\nacm_ctrl &= ~acm_bit;\r\nrtl8xxxu_write8(priv, REG_ACM_HW_CTRL, acm_ctrl);\r\nreturn 0;\r\n}\r\nstatic void rtl8xxxu_configure_filter(struct ieee80211_hw *hw,\r\nunsigned int changed_flags,\r\nunsigned int *total_flags, u64 multicast)\r\n{\r\nstruct rtl8xxxu_priv *priv = hw->priv;\r\ndev_dbg(&priv->udev->dev, "%s: changed_flags %08x, total_flags %08x\n",\r\n__func__, changed_flags, *total_flags);\r\n*total_flags &= (FIF_ALLMULTI | FIF_CONTROL | FIF_BCN_PRBRESP_PROMISC);\r\n}\r\nstatic int rtl8xxxu_set_rts_threshold(struct ieee80211_hw *hw, u32 rts)\r\n{\r\nif (rts > 2347)\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\nstatic int rtl8xxxu_set_key(struct ieee80211_hw *hw, enum set_key_cmd cmd,\r\nstruct ieee80211_vif *vif,\r\nstruct ieee80211_sta *sta,\r\nstruct ieee80211_key_conf *key)\r\n{\r\nstruct rtl8xxxu_priv *priv = hw->priv;\r\nstruct device *dev = &priv->udev->dev;\r\nu8 mac_addr[ETH_ALEN];\r\nu8 val8;\r\nu16 val16;\r\nu32 val32;\r\nint retval = -EOPNOTSUPP;\r\ndev_dbg(dev, "%s: cmd %02x, cipher %08x, index %i\n",\r\n__func__, cmd, key->cipher, key->keyidx);\r\nif (vif->type != NL80211_IFTYPE_STATION)\r\nreturn -EOPNOTSUPP;\r\nif (key->keyidx > 3)\r\nreturn -EOPNOTSUPP;\r\nswitch (key->cipher) {\r\ncase WLAN_CIPHER_SUITE_WEP40:\r\ncase WLAN_CIPHER_SUITE_WEP104:\r\nbreak;\r\ncase WLAN_CIPHER_SUITE_CCMP:\r\nkey->flags |= IEEE80211_KEY_FLAG_SW_MGMT_TX;\r\nbreak;\r\ncase WLAN_CIPHER_SUITE_TKIP:\r\nkey->flags |= IEEE80211_KEY_FLAG_GENERATE_MMIC;\r\ndefault:\r\nreturn -EOPNOTSUPP;\r\n}\r\nif (key->flags & IEEE80211_KEY_FLAG_PAIRWISE) {\r\ndev_dbg(dev, "%s: pairwise key\n", __func__);\r\nether_addr_copy(mac_addr, sta->addr);\r\n} else {\r\ndev_dbg(dev, "%s: group key\n", __func__);\r\neth_broadcast_addr(mac_addr);\r\n}\r\nval16 = rtl8xxxu_read16(priv, REG_CR);\r\nval16 |= CR_SECURITY_ENABLE;\r\nrtl8xxxu_write16(priv, REG_CR, val16);\r\nval8 = SEC_CFG_TX_SEC_ENABLE | SEC_CFG_TXBC_USE_DEFKEY |\r\nSEC_CFG_RX_SEC_ENABLE | SEC_CFG_RXBC_USE_DEFKEY;\r\nval8 |= SEC_CFG_TX_USE_DEFKEY | SEC_CFG_RX_USE_DEFKEY;\r\nrtl8xxxu_write8(priv, REG_SECURITY_CFG, val8);\r\nswitch (cmd) {\r\ncase SET_KEY:\r\nkey->hw_key_idx = key->keyidx;\r\nkey->flags |= IEEE80211_KEY_FLAG_GENERATE_IV;\r\nrtl8xxxu_cam_write(priv, key, mac_addr);\r\nretval = 0;\r\nbreak;\r\ncase DISABLE_KEY:\r\nrtl8xxxu_write32(priv, REG_CAM_WRITE, 0x00000000);\r\nval32 = CAM_CMD_POLLING | CAM_CMD_WRITE |\r\nkey->keyidx << CAM_CMD_KEY_SHIFT;\r\nrtl8xxxu_write32(priv, REG_CAM_CMD, val32);\r\nretval = 0;\r\nbreak;\r\ndefault:\r\ndev_warn(dev, "%s: Unsupported command %02x\n", __func__, cmd);\r\n}\r\nreturn retval;\r\n}\r\nstatic int\r\nrtl8xxxu_ampdu_action(struct ieee80211_hw *hw, struct ieee80211_vif *vif,\r\nenum ieee80211_ampdu_mlme_action action,\r\nstruct ieee80211_sta *sta, u16 tid, u16 *ssn, u8 buf_size,\r\nbool amsdu)\r\n{\r\nstruct rtl8xxxu_priv *priv = hw->priv;\r\nstruct device *dev = &priv->udev->dev;\r\nu8 ampdu_factor, ampdu_density;\r\nswitch (action) {\r\ncase IEEE80211_AMPDU_TX_START:\r\ndev_info(dev, "%s: IEEE80211_AMPDU_TX_START\n", __func__);\r\nampdu_factor = sta->ht_cap.ampdu_factor;\r\nampdu_density = sta->ht_cap.ampdu_density;\r\nrtl8xxxu_set_ampdu_factor(priv, ampdu_factor);\r\nrtl8xxxu_set_ampdu_min_space(priv, ampdu_density);\r\ndev_dbg(dev,\r\n"Changed HT: ampdu_factor %02x, ampdu_density %02x\n",\r\nampdu_factor, ampdu_density);\r\nbreak;\r\ncase IEEE80211_AMPDU_TX_STOP_FLUSH:\r\ndev_info(dev, "%s: IEEE80211_AMPDU_TX_STOP_FLUSH\n", __func__);\r\nrtl8xxxu_set_ampdu_factor(priv, 0);\r\nrtl8xxxu_set_ampdu_min_space(priv, 0);\r\nbreak;\r\ncase IEEE80211_AMPDU_TX_STOP_FLUSH_CONT:\r\ndev_info(dev, "%s: IEEE80211_AMPDU_TX_STOP_FLUSH_CONT\n",\r\n__func__);\r\nrtl8xxxu_set_ampdu_factor(priv, 0);\r\nrtl8xxxu_set_ampdu_min_space(priv, 0);\r\nbreak;\r\ncase IEEE80211_AMPDU_RX_START:\r\ndev_info(dev, "%s: IEEE80211_AMPDU_RX_START\n", __func__);\r\nbreak;\r\ncase IEEE80211_AMPDU_RX_STOP:\r\ndev_info(dev, "%s: IEEE80211_AMPDU_RX_STOP\n", __func__);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic int rtl8xxxu_start(struct ieee80211_hw *hw)\r\n{\r\nstruct rtl8xxxu_priv *priv = hw->priv;\r\nstruct rtl8xxxu_rx_urb *rx_urb;\r\nstruct rtl8xxxu_tx_urb *tx_urb;\r\nunsigned long flags;\r\nint ret, i;\r\nret = 0;\r\ninit_usb_anchor(&priv->rx_anchor);\r\ninit_usb_anchor(&priv->tx_anchor);\r\ninit_usb_anchor(&priv->int_anchor);\r\nrtl8723a_enable_rf(priv);\r\nret = rtl8xxxu_submit_int_urb(hw);\r\nif (ret)\r\ngoto exit;\r\nfor (i = 0; i < RTL8XXXU_TX_URBS; i++) {\r\ntx_urb = kmalloc(sizeof(struct rtl8xxxu_tx_urb), GFP_KERNEL);\r\nif (!tx_urb) {\r\nif (!i)\r\nret = -ENOMEM;\r\ngoto error_out;\r\n}\r\nusb_init_urb(&tx_urb->urb);\r\nINIT_LIST_HEAD(&tx_urb->list);\r\ntx_urb->hw = hw;\r\nlist_add(&tx_urb->list, &priv->tx_urb_free_list);\r\npriv->tx_urb_free_count++;\r\n}\r\npriv->tx_stopped = false;\r\nspin_lock_irqsave(&priv->rx_urb_lock, flags);\r\npriv->shutdown = false;\r\nspin_unlock_irqrestore(&priv->rx_urb_lock, flags);\r\nfor (i = 0; i < RTL8XXXU_RX_URBS; i++) {\r\nrx_urb = kmalloc(sizeof(struct rtl8xxxu_rx_urb), GFP_KERNEL);\r\nif (!rx_urb) {\r\nif (!i)\r\nret = -ENOMEM;\r\ngoto error_out;\r\n}\r\nusb_init_urb(&rx_urb->urb);\r\nINIT_LIST_HEAD(&rx_urb->list);\r\nrx_urb->hw = hw;\r\nret = rtl8xxxu_submit_rx_urb(priv, rx_urb);\r\n}\r\nexit:\r\nrtl8xxxu_write16(priv, REG_RXFLTMAP2, 0x0000);\r\nrtl8xxxu_write16(priv, REG_RXFLTMAP0, 0xffff);\r\nrtl8xxxu_write32(priv, REG_OFDM0_XA_AGC_CORE1, 0x6954341e);\r\nreturn ret;\r\nerror_out:\r\nrtl8xxxu_free_tx_resources(priv);\r\nrtl8xxxu_write16(priv, REG_RXFLTMAP2, 0x0000);\r\nrtl8xxxu_write16(priv, REG_RXFLTMAP0, 0x0000);\r\nreturn ret;\r\n}\r\nstatic void rtl8xxxu_stop(struct ieee80211_hw *hw)\r\n{\r\nstruct rtl8xxxu_priv *priv = hw->priv;\r\nunsigned long flags;\r\nrtl8xxxu_write8(priv, REG_TXPAUSE, 0xff);\r\nrtl8xxxu_write16(priv, REG_RXFLTMAP0, 0x0000);\r\nrtl8xxxu_write16(priv, REG_RXFLTMAP2, 0x0000);\r\nspin_lock_irqsave(&priv->rx_urb_lock, flags);\r\npriv->shutdown = true;\r\nspin_unlock_irqrestore(&priv->rx_urb_lock, flags);\r\nusb_kill_anchored_urbs(&priv->rx_anchor);\r\nusb_kill_anchored_urbs(&priv->tx_anchor);\r\nusb_kill_anchored_urbs(&priv->int_anchor);\r\nrtl8723a_disable_rf(priv);\r\nrtl8xxxu_write32(priv, REG_USB_HIMR, 0);\r\nrtl8xxxu_free_rx_resources(priv);\r\nrtl8xxxu_free_tx_resources(priv);\r\n}\r\nstatic int rtl8xxxu_parse_usb(struct rtl8xxxu_priv *priv,\r\nstruct usb_interface *interface)\r\n{\r\nstruct usb_interface_descriptor *interface_desc;\r\nstruct usb_host_interface *host_interface;\r\nstruct usb_endpoint_descriptor *endpoint;\r\nstruct device *dev = &priv->udev->dev;\r\nint i, j = 0, endpoints;\r\nu8 dir, xtype, num;\r\nint ret = 0;\r\nhost_interface = &interface->altsetting[0];\r\ninterface_desc = &host_interface->desc;\r\nendpoints = interface_desc->bNumEndpoints;\r\nfor (i = 0; i < endpoints; i++) {\r\nendpoint = &host_interface->endpoint[i].desc;\r\ndir = endpoint->bEndpointAddress & USB_ENDPOINT_DIR_MASK;\r\nnum = usb_endpoint_num(endpoint);\r\nxtype = usb_endpoint_type(endpoint);\r\nif (rtl8xxxu_debug & RTL8XXXU_DEBUG_USB)\r\ndev_dbg(dev,\r\n"%s: endpoint: dir %02x, # %02x, type %02x\n",\r\n__func__, dir, num, xtype);\r\nif (usb_endpoint_dir_in(endpoint) &&\r\nusb_endpoint_xfer_bulk(endpoint)) {\r\nif (rtl8xxxu_debug & RTL8XXXU_DEBUG_USB)\r\ndev_dbg(dev, "%s: in endpoint num %i\n",\r\n__func__, num);\r\nif (priv->pipe_in) {\r\ndev_warn(dev,\r\n"%s: Too many IN pipes\n", __func__);\r\nret = -EINVAL;\r\ngoto exit;\r\n}\r\npriv->pipe_in = usb_rcvbulkpipe(priv->udev, num);\r\n}\r\nif (usb_endpoint_dir_in(endpoint) &&\r\nusb_endpoint_xfer_int(endpoint)) {\r\nif (rtl8xxxu_debug & RTL8XXXU_DEBUG_USB)\r\ndev_dbg(dev, "%s: interrupt endpoint num %i\n",\r\n__func__, num);\r\nif (priv->pipe_interrupt) {\r\ndev_warn(dev, "%s: Too many INTERRUPT pipes\n",\r\n__func__);\r\nret = -EINVAL;\r\ngoto exit;\r\n}\r\npriv->pipe_interrupt = usb_rcvintpipe(priv->udev, num);\r\n}\r\nif (usb_endpoint_dir_out(endpoint) &&\r\nusb_endpoint_xfer_bulk(endpoint)) {\r\nif (rtl8xxxu_debug & RTL8XXXU_DEBUG_USB)\r\ndev_dbg(dev, "%s: out endpoint num %i\n",\r\n__func__, num);\r\nif (j >= RTL8XXXU_OUT_ENDPOINTS) {\r\ndev_warn(dev,\r\n"%s: Too many OUT pipes\n", __func__);\r\nret = -EINVAL;\r\ngoto exit;\r\n}\r\npriv->out_ep[j++] = num;\r\n}\r\n}\r\nexit:\r\npriv->nr_out_eps = j;\r\nreturn ret;\r\n}\r\nstatic int rtl8xxxu_probe(struct usb_interface *interface,\r\nconst struct usb_device_id *id)\r\n{\r\nstruct rtl8xxxu_priv *priv;\r\nstruct ieee80211_hw *hw;\r\nstruct usb_device *udev;\r\nstruct ieee80211_supported_band *sband;\r\nint ret = 0;\r\nint untested = 1;\r\nudev = usb_get_dev(interface_to_usbdev(interface));\r\nswitch (id->idVendor) {\r\ncase USB_VENDOR_ID_REALTEK:\r\nswitch(id->idProduct) {\r\ncase 0x1724:\r\ncase 0x8176:\r\ncase 0x8178:\r\ncase 0x817f:\r\nuntested = 0;\r\nbreak;\r\n}\r\nbreak;\r\ncase 0x7392:\r\nif (id->idProduct == 0x7811)\r\nuntested = 0;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nif (untested) {\r\nrtl8xxxu_debug = RTL8XXXU_DEBUG_EFUSE;\r\ndev_info(&udev->dev,\r\n"This Realtek USB WiFi dongle (0x%04x:0x%04x) is untested!\n",\r\nid->idVendor, id->idProduct);\r\ndev_info(&udev->dev,\r\n"Please report results to Jes.Sorensen@gmail.com\n");\r\n}\r\nhw = ieee80211_alloc_hw(sizeof(struct rtl8xxxu_priv), &rtl8xxxu_ops);\r\nif (!hw) {\r\nret = -ENOMEM;\r\ngoto exit;\r\n}\r\npriv = hw->priv;\r\npriv->hw = hw;\r\npriv->udev = udev;\r\npriv->fops = (struct rtl8xxxu_fileops *)id->driver_info;\r\nmutex_init(&priv->usb_buf_mutex);\r\nmutex_init(&priv->h2c_mutex);\r\nINIT_LIST_HEAD(&priv->tx_urb_free_list);\r\nspin_lock_init(&priv->tx_urb_lock);\r\nINIT_LIST_HEAD(&priv->rx_urb_pending_list);\r\nspin_lock_init(&priv->rx_urb_lock);\r\nINIT_WORK(&priv->rx_urb_wq, rtl8xxxu_rx_urb_work);\r\nusb_set_intfdata(interface, hw);\r\nret = rtl8xxxu_parse_usb(priv, interface);\r\nif (ret)\r\ngoto exit;\r\nret = rtl8xxxu_identify_chip(priv);\r\nif (ret) {\r\ndev_err(&udev->dev, "Fatal - failed to identify chip\n");\r\ngoto exit;\r\n}\r\nret = rtl8xxxu_read_efuse(priv);\r\nif (ret) {\r\ndev_err(&udev->dev, "Fatal - failed to read EFuse\n");\r\ngoto exit;\r\n}\r\nret = priv->fops->parse_efuse(priv);\r\nif (ret) {\r\ndev_err(&udev->dev, "Fatal - failed to parse EFuse\n");\r\ngoto exit;\r\n}\r\nrtl8xxxu_print_chipinfo(priv);\r\nret = priv->fops->load_firmware(priv);\r\nif (ret) {\r\ndev_err(&udev->dev, "Fatal - failed to load firmware\n");\r\ngoto exit;\r\n}\r\nret = rtl8xxxu_init_device(hw);\r\nhw->wiphy->max_scan_ssids = 1;\r\nhw->wiphy->max_scan_ie_len = IEEE80211_MAX_DATA_LEN;\r\nhw->wiphy->interface_modes = BIT(NL80211_IFTYPE_STATION);\r\nhw->queues = 4;\r\nsband = &rtl8xxxu_supported_band;\r\nsband->ht_cap.ht_supported = true;\r\nsband->ht_cap.ampdu_factor = IEEE80211_HT_MAX_AMPDU_64K;\r\nsband->ht_cap.ampdu_density = IEEE80211_HT_MPDU_DENSITY_16;\r\nsband->ht_cap.cap = IEEE80211_HT_CAP_SGI_20 | IEEE80211_HT_CAP_SGI_40;\r\nmemset(&sband->ht_cap.mcs, 0, sizeof(sband->ht_cap.mcs));\r\nsband->ht_cap.mcs.rx_mask[0] = 0xff;\r\nsband->ht_cap.mcs.rx_mask[4] = 0x01;\r\nif (priv->rf_paths > 1) {\r\nsband->ht_cap.mcs.rx_mask[1] = 0xff;\r\nsband->ht_cap.cap |= IEEE80211_HT_CAP_SGI_40;\r\n}\r\nsband->ht_cap.mcs.tx_params = IEEE80211_HT_MCS_TX_DEFINED;\r\nif (rtl8xxxu_ht40_2g) {\r\ndev_info(&udev->dev, "Enabling HT_20_40 on the 2.4GHz band\n");\r\nsband->ht_cap.cap |= IEEE80211_HT_CAP_SUP_WIDTH_20_40;\r\n}\r\nhw->wiphy->bands[IEEE80211_BAND_2GHZ] = sband;\r\nhw->wiphy->rts_threshold = 2347;\r\nSET_IEEE80211_DEV(priv->hw, &interface->dev);\r\nSET_IEEE80211_PERM_ADDR(hw, priv->mac_addr);\r\nhw->extra_tx_headroom = sizeof(struct rtl8xxxu_tx_desc);\r\nieee80211_hw_set(hw, SIGNAL_DBM);\r\nieee80211_hw_set(hw, HAS_RATE_CONTROL);\r\nieee80211_hw_set(hw, AMPDU_AGGREGATION);\r\nret = ieee80211_register_hw(priv->hw);\r\nif (ret) {\r\ndev_err(&udev->dev, "%s: Failed to register: %i\n",\r\n__func__, ret);\r\ngoto exit;\r\n}\r\nexit:\r\nif (ret < 0)\r\nusb_put_dev(udev);\r\nreturn ret;\r\n}\r\nstatic void rtl8xxxu_disconnect(struct usb_interface *interface)\r\n{\r\nstruct rtl8xxxu_priv *priv;\r\nstruct ieee80211_hw *hw;\r\nhw = usb_get_intfdata(interface);\r\npriv = hw->priv;\r\nrtl8xxxu_disable_device(hw);\r\nusb_set_intfdata(interface, NULL);\r\ndev_info(&priv->udev->dev, "disconnecting\n");\r\nieee80211_unregister_hw(hw);\r\nkfree(priv->fw_data);\r\nmutex_destroy(&priv->usb_buf_mutex);\r\nmutex_destroy(&priv->h2c_mutex);\r\nusb_put_dev(priv->udev);\r\nieee80211_free_hw(hw);\r\n}\r\nstatic int __init rtl8xxxu_module_init(void)\r\n{\r\nint res;\r\nres = usb_register(&rtl8xxxu_driver);\r\nif (res < 0)\r\npr_err(DRIVER_NAME ": usb_register() failed (%i)\n", res);\r\nreturn res;\r\n}\r\nstatic void __exit rtl8xxxu_module_exit(void)\r\n{\r\nusb_deregister(&rtl8xxxu_driver);\r\n}
