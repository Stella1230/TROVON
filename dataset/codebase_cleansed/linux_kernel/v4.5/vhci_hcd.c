static void dump_port_status_diff(u32 prev_status, u32 new_status)\r\n{\r\nint i = 0;\r\nu32 bit = 1;\r\npr_debug("status prev -> new: %08x -> %08x\n", prev_status, new_status);\r\nwhile (bit) {\r\nu32 prev = prev_status & bit;\r\nu32 new = new_status & bit;\r\nchar change;\r\nif (!prev && new)\r\nchange = '+';\r\nelse if (prev && !new)\r\nchange = '-';\r\nelse\r\nchange = ' ';\r\nif (prev || new)\r\npr_debug(" %c%s\n", change, bit_desc[i]);\r\nbit <<= 1;\r\ni++;\r\n}\r\npr_debug("\n");\r\n}\r\nvoid rh_port_connect(int rhport, enum usb_device_speed speed)\r\n{\r\nusbip_dbg_vhci_rh("rh_port_connect %d\n", rhport);\r\nspin_lock(&the_controller->lock);\r\nthe_controller->port_status[rhport] |= USB_PORT_STAT_CONNECTION\r\n| (1 << USB_PORT_FEAT_C_CONNECTION);\r\nswitch (speed) {\r\ncase USB_SPEED_HIGH:\r\nthe_controller->port_status[rhport] |= USB_PORT_STAT_HIGH_SPEED;\r\nbreak;\r\ncase USB_SPEED_LOW:\r\nthe_controller->port_status[rhport] |= USB_PORT_STAT_LOW_SPEED;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nspin_unlock(&the_controller->lock);\r\nusb_hcd_poll_rh_status(vhci_to_hcd(the_controller));\r\n}\r\nstatic void rh_port_disconnect(int rhport)\r\n{\r\nusbip_dbg_vhci_rh("rh_port_disconnect %d\n", rhport);\r\nspin_lock(&the_controller->lock);\r\nthe_controller->port_status[rhport] &= ~USB_PORT_STAT_CONNECTION;\r\nthe_controller->port_status[rhport] |=\r\n(1 << USB_PORT_FEAT_C_CONNECTION);\r\nspin_unlock(&the_controller->lock);\r\nusb_hcd_poll_rh_status(vhci_to_hcd(the_controller));\r\n}\r\nstatic int vhci_hub_status(struct usb_hcd *hcd, char *buf)\r\n{\r\nstruct vhci_hcd *vhci;\r\nint retval;\r\nint rhport;\r\nint changed = 0;\r\nretval = DIV_ROUND_UP(VHCI_NPORTS + 1, 8);\r\nmemset(buf, 0, retval);\r\nvhci = hcd_to_vhci(hcd);\r\nspin_lock(&vhci->lock);\r\nif (!HCD_HW_ACCESSIBLE(hcd)) {\r\nusbip_dbg_vhci_rh("hw accessible flag not on?\n");\r\ngoto done;\r\n}\r\nfor (rhport = 0; rhport < VHCI_NPORTS; rhport++) {\r\nif ((vhci->port_status[rhport] & PORT_C_MASK)) {\r\nusbip_dbg_vhci_rh("port %d status changed\n", rhport);\r\nbuf[(rhport + 1) / 8] |= 1 << (rhport + 1) % 8;\r\nchanged = 1;\r\n}\r\n}\r\nif ((hcd->state == HC_STATE_SUSPENDED) && (changed == 1))\r\nusb_hcd_resume_root_hub(hcd);\r\ndone:\r\nspin_unlock(&vhci->lock);\r\nreturn changed ? retval : 0;\r\n}\r\nstatic inline void hub_descriptor(struct usb_hub_descriptor *desc)\r\n{\r\nmemset(desc, 0, sizeof(*desc));\r\ndesc->bDescriptorType = USB_DT_HUB;\r\ndesc->bDescLength = 9;\r\ndesc->wHubCharacteristics = cpu_to_le16(\r\nHUB_CHAR_INDV_PORT_LPSM | HUB_CHAR_COMMON_OCPM);\r\ndesc->bNbrPorts = VHCI_NPORTS;\r\ndesc->u.hs.DeviceRemovable[0] = 0xff;\r\ndesc->u.hs.DeviceRemovable[1] = 0xff;\r\n}\r\nstatic int vhci_hub_control(struct usb_hcd *hcd, u16 typeReq, u16 wValue,\r\nu16 wIndex, char *buf, u16 wLength)\r\n{\r\nstruct vhci_hcd *dum;\r\nint retval = 0;\r\nint rhport;\r\nu32 prev_port_status[VHCI_NPORTS];\r\nif (!HCD_HW_ACCESSIBLE(hcd))\r\nreturn -ETIMEDOUT;\r\nusbip_dbg_vhci_rh("typeReq %x wValue %x wIndex %x\n", typeReq, wValue,\r\nwIndex);\r\nif (wIndex > VHCI_NPORTS)\r\npr_err("invalid port number %d\n", wIndex);\r\nrhport = ((__u8)(wIndex & 0x00ff)) - 1;\r\ndum = hcd_to_vhci(hcd);\r\nspin_lock(&dum->lock);\r\nif (usbip_dbg_flag_vhci_rh) {\r\nmemcpy(prev_port_status, dum->port_status,\r\nsizeof(prev_port_status));\r\n}\r\nswitch (typeReq) {\r\ncase ClearHubFeature:\r\nusbip_dbg_vhci_rh(" ClearHubFeature\n");\r\nbreak;\r\ncase ClearPortFeature:\r\nswitch (wValue) {\r\ncase USB_PORT_FEAT_SUSPEND:\r\nif (dum->port_status[rhport] & USB_PORT_STAT_SUSPEND) {\r\ndum->resuming = 1;\r\ndum->re_timeout =\r\njiffies + msecs_to_jiffies(20);\r\n}\r\nbreak;\r\ncase USB_PORT_FEAT_POWER:\r\nusbip_dbg_vhci_rh(\r\n" ClearPortFeature: USB_PORT_FEAT_POWER\n");\r\ndum->port_status[rhport] = 0;\r\ndum->resuming = 0;\r\nbreak;\r\ncase USB_PORT_FEAT_C_RESET:\r\nusbip_dbg_vhci_rh(\r\n" ClearPortFeature: USB_PORT_FEAT_C_RESET\n");\r\nswitch (dum->vdev[rhport].speed) {\r\ncase USB_SPEED_HIGH:\r\ndum->port_status[rhport] |=\r\nUSB_PORT_STAT_HIGH_SPEED;\r\nbreak;\r\ncase USB_SPEED_LOW:\r\ndum->port_status[rhport] |=\r\nUSB_PORT_STAT_LOW_SPEED;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\ndefault:\r\nusbip_dbg_vhci_rh(" ClearPortFeature: default %x\n",\r\nwValue);\r\ndum->port_status[rhport] &= ~(1 << wValue);\r\nbreak;\r\n}\r\nbreak;\r\ncase GetHubDescriptor:\r\nusbip_dbg_vhci_rh(" GetHubDescriptor\n");\r\nhub_descriptor((struct usb_hub_descriptor *) buf);\r\nbreak;\r\ncase GetHubStatus:\r\nusbip_dbg_vhci_rh(" GetHubStatus\n");\r\n*(__le32 *) buf = cpu_to_le32(0);\r\nbreak;\r\ncase GetPortStatus:\r\nusbip_dbg_vhci_rh(" GetPortStatus port %x\n", wIndex);\r\nif (wIndex > VHCI_NPORTS || wIndex < 1) {\r\npr_err("invalid port number %d\n", wIndex);\r\nretval = -EPIPE;\r\n}\r\nif (dum->resuming && time_after(jiffies, dum->re_timeout)) {\r\ndum->port_status[rhport] |=\r\n(1 << USB_PORT_FEAT_C_SUSPEND);\r\ndum->port_status[rhport] &=\r\n~(1 << USB_PORT_FEAT_SUSPEND);\r\ndum->resuming = 0;\r\ndum->re_timeout = 0;\r\n}\r\nif ((dum->port_status[rhport] & (1 << USB_PORT_FEAT_RESET)) !=\r\n0 && time_after(jiffies, dum->re_timeout)) {\r\ndum->port_status[rhport] |=\r\n(1 << USB_PORT_FEAT_C_RESET);\r\ndum->port_status[rhport] &=\r\n~(1 << USB_PORT_FEAT_RESET);\r\ndum->re_timeout = 0;\r\nif (dum->vdev[rhport].ud.status ==\r\nVDEV_ST_NOTASSIGNED) {\r\nusbip_dbg_vhci_rh(\r\n" enable rhport %d (status %u)\n",\r\nrhport,\r\ndum->vdev[rhport].ud.status);\r\ndum->port_status[rhport] |=\r\nUSB_PORT_STAT_ENABLE;\r\n}\r\n}\r\n((__le16 *) buf)[0] = cpu_to_le16(dum->port_status[rhport]);\r\n((__le16 *) buf)[1] =\r\ncpu_to_le16(dum->port_status[rhport] >> 16);\r\nusbip_dbg_vhci_rh(" GetPortStatus bye %x %x\n", ((u16 *)buf)[0],\r\n((u16 *)buf)[1]);\r\nbreak;\r\ncase SetHubFeature:\r\nusbip_dbg_vhci_rh(" SetHubFeature\n");\r\nretval = -EPIPE;\r\nbreak;\r\ncase SetPortFeature:\r\nswitch (wValue) {\r\ncase USB_PORT_FEAT_SUSPEND:\r\nusbip_dbg_vhci_rh(\r\n" SetPortFeature: USB_PORT_FEAT_SUSPEND\n");\r\nbreak;\r\ncase USB_PORT_FEAT_RESET:\r\nusbip_dbg_vhci_rh(\r\n" SetPortFeature: USB_PORT_FEAT_RESET\n");\r\nif (dum->port_status[rhport] & USB_PORT_STAT_ENABLE) {\r\ndum->port_status[rhport] &=\r\n~(USB_PORT_STAT_ENABLE |\r\nUSB_PORT_STAT_LOW_SPEED |\r\nUSB_PORT_STAT_HIGH_SPEED);\r\n}\r\ndum->re_timeout = jiffies + msecs_to_jiffies(50);\r\ndefault:\r\nusbip_dbg_vhci_rh(" SetPortFeature: default %d\n",\r\nwValue);\r\ndum->port_status[rhport] |= (1 << wValue);\r\nbreak;\r\n}\r\nbreak;\r\ndefault:\r\npr_err("default: no such request\n");\r\nretval = -EPIPE;\r\n}\r\nif (usbip_dbg_flag_vhci_rh) {\r\npr_debug("port %d\n", rhport);\r\nif (rhport >= 0) {\r\ndump_port_status_diff(prev_port_status[rhport],\r\ndum->port_status[rhport]);\r\n}\r\n}\r\nusbip_dbg_vhci_rh(" bye\n");\r\nspin_unlock(&dum->lock);\r\nreturn retval;\r\n}\r\nstatic struct vhci_device *get_vdev(struct usb_device *udev)\r\n{\r\nint i;\r\nif (!udev)\r\nreturn NULL;\r\nfor (i = 0; i < VHCI_NPORTS; i++)\r\nif (the_controller->vdev[i].udev == udev)\r\nreturn port_to_vdev(i);\r\nreturn NULL;\r\n}\r\nstatic void vhci_tx_urb(struct urb *urb)\r\n{\r\nstruct vhci_device *vdev = get_vdev(urb->dev);\r\nstruct vhci_priv *priv;\r\nif (!vdev) {\r\npr_err("could not get virtual device");\r\nreturn;\r\n}\r\npriv = kzalloc(sizeof(struct vhci_priv), GFP_ATOMIC);\r\nif (!priv) {\r\nusbip_event_add(&vdev->ud, VDEV_EVENT_ERROR_MALLOC);\r\nreturn;\r\n}\r\nspin_lock(&vdev->priv_lock);\r\npriv->seqnum = atomic_inc_return(&the_controller->seqnum);\r\nif (priv->seqnum == 0xffff)\r\ndev_info(&urb->dev->dev, "seqnum max\n");\r\npriv->vdev = vdev;\r\npriv->urb = urb;\r\nurb->hcpriv = (void *) priv;\r\nlist_add_tail(&priv->list, &vdev->priv_tx);\r\nwake_up(&vdev->waitq_tx);\r\nspin_unlock(&vdev->priv_lock);\r\n}\r\nstatic int vhci_urb_enqueue(struct usb_hcd *hcd, struct urb *urb,\r\ngfp_t mem_flags)\r\n{\r\nstruct device *dev = &urb->dev->dev;\r\nint ret = 0;\r\nstruct vhci_device *vdev;\r\nusbip_dbg_vhci_hc("enter, usb_hcd %p urb %p mem_flags %d\n",\r\nhcd, urb, mem_flags);\r\nBUG_ON(!urb->transfer_buffer && urb->transfer_buffer_length);\r\nspin_lock(&the_controller->lock);\r\nif (urb->status != -EINPROGRESS) {\r\ndev_err(dev, "URB already unlinked!, status %d\n", urb->status);\r\nspin_unlock(&the_controller->lock);\r\nreturn urb->status;\r\n}\r\nvdev = port_to_vdev(urb->dev->portnum-1);\r\nspin_lock(&vdev->ud.lock);\r\nif (vdev->ud.status == VDEV_ST_NULL ||\r\nvdev->ud.status == VDEV_ST_ERROR) {\r\ndev_err(dev, "enqueue for inactive port %d\n", vdev->rhport);\r\nspin_unlock(&vdev->ud.lock);\r\nspin_unlock(&the_controller->lock);\r\nreturn -ENODEV;\r\n}\r\nspin_unlock(&vdev->ud.lock);\r\nret = usb_hcd_link_urb_to_ep(hcd, urb);\r\nif (ret)\r\ngoto no_need_unlink;\r\nif (usb_pipedevice(urb->pipe) == 0) {\r\n__u8 type = usb_pipetype(urb->pipe);\r\nstruct usb_ctrlrequest *ctrlreq =\r\n(struct usb_ctrlrequest *) urb->setup_packet;\r\nif (type != PIPE_CONTROL || !ctrlreq) {\r\ndev_err(dev, "invalid request to devnum 0\n");\r\nret = -EINVAL;\r\ngoto no_need_xmit;\r\n}\r\nswitch (ctrlreq->bRequest) {\r\ncase USB_REQ_SET_ADDRESS:\r\ndev_info(dev, "SetAddress Request (%d) to port %d\n",\r\nctrlreq->wValue, vdev->rhport);\r\nusb_put_dev(vdev->udev);\r\nvdev->udev = usb_get_dev(urb->dev);\r\nspin_lock(&vdev->ud.lock);\r\nvdev->ud.status = VDEV_ST_USED;\r\nspin_unlock(&vdev->ud.lock);\r\nif (urb->status == -EINPROGRESS) {\r\nurb->status = 0;\r\n}\r\ngoto no_need_xmit;\r\ncase USB_REQ_GET_DESCRIPTOR:\r\nif (ctrlreq->wValue == cpu_to_le16(USB_DT_DEVICE << 8))\r\nusbip_dbg_vhci_hc(\r\n"Not yet?:Get_Descriptor to device 0 (get max pipe size)\n");\r\nusb_put_dev(vdev->udev);\r\nvdev->udev = usb_get_dev(urb->dev);\r\ngoto out;\r\ndefault:\r\ndev_err(dev,\r\n"invalid request to devnum 0 bRequest %u, wValue %u\n",\r\nctrlreq->bRequest,\r\nctrlreq->wValue);\r\nret = -EINVAL;\r\ngoto no_need_xmit;\r\n}\r\n}\r\nout:\r\nvhci_tx_urb(urb);\r\nspin_unlock(&the_controller->lock);\r\nreturn 0;\r\nno_need_xmit:\r\nusb_hcd_unlink_urb_from_ep(hcd, urb);\r\nno_need_unlink:\r\nspin_unlock(&the_controller->lock);\r\nif (!ret)\r\nusb_hcd_giveback_urb(vhci_to_hcd(the_controller),\r\nurb, urb->status);\r\nreturn ret;\r\n}\r\nstatic int vhci_urb_dequeue(struct usb_hcd *hcd, struct urb *urb, int status)\r\n{\r\nstruct vhci_priv *priv;\r\nstruct vhci_device *vdev;\r\npr_info("dequeue a urb %p\n", urb);\r\nspin_lock(&the_controller->lock);\r\npriv = urb->hcpriv;\r\nif (!priv) {\r\nspin_unlock(&the_controller->lock);\r\nreturn -EIDRM;\r\n}\r\n{\r\nint ret = 0;\r\nret = usb_hcd_check_unlink_urb(hcd, urb, status);\r\nif (ret) {\r\nspin_unlock(&the_controller->lock);\r\nreturn ret;\r\n}\r\n}\r\nvdev = priv->vdev;\r\nif (!vdev->ud.tcp_socket) {\r\nspin_lock(&vdev->priv_lock);\r\npr_info("device %p seems to be disconnected\n", vdev);\r\nlist_del(&priv->list);\r\nkfree(priv);\r\nurb->hcpriv = NULL;\r\nspin_unlock(&vdev->priv_lock);\r\npr_info("gives back urb %p\n", urb);\r\nusb_hcd_unlink_urb_from_ep(hcd, urb);\r\nspin_unlock(&the_controller->lock);\r\nusb_hcd_giveback_urb(vhci_to_hcd(the_controller), urb,\r\nurb->status);\r\nspin_lock(&the_controller->lock);\r\n} else {\r\nstruct vhci_unlink *unlink;\r\nspin_lock(&vdev->priv_lock);\r\nunlink = kzalloc(sizeof(struct vhci_unlink), GFP_ATOMIC);\r\nif (!unlink) {\r\nspin_unlock(&vdev->priv_lock);\r\nspin_unlock(&the_controller->lock);\r\nusbip_event_add(&vdev->ud, VDEV_EVENT_ERROR_MALLOC);\r\nreturn -ENOMEM;\r\n}\r\nunlink->seqnum = atomic_inc_return(&the_controller->seqnum);\r\nif (unlink->seqnum == 0xffff)\r\npr_info("seqnum max\n");\r\nunlink->unlink_seqnum = priv->seqnum;\r\npr_info("device %p seems to be still connected\n", vdev);\r\nlist_add_tail(&unlink->list, &vdev->unlink_tx);\r\nwake_up(&vdev->waitq_tx);\r\nspin_unlock(&vdev->priv_lock);\r\n}\r\nspin_unlock(&the_controller->lock);\r\nusbip_dbg_vhci_hc("leave\n");\r\nreturn 0;\r\n}\r\nstatic void vhci_device_unlink_cleanup(struct vhci_device *vdev)\r\n{\r\nstruct vhci_unlink *unlink, *tmp;\r\nspin_lock(&the_controller->lock);\r\nspin_lock(&vdev->priv_lock);\r\nlist_for_each_entry_safe(unlink, tmp, &vdev->unlink_tx, list) {\r\npr_info("unlink cleanup tx %lu\n", unlink->unlink_seqnum);\r\nlist_del(&unlink->list);\r\nkfree(unlink);\r\n}\r\nwhile (!list_empty(&vdev->unlink_rx)) {\r\nstruct urb *urb;\r\nunlink = list_first_entry(&vdev->unlink_rx, struct vhci_unlink,\r\nlist);\r\npr_info("unlink cleanup rx %lu\n", unlink->unlink_seqnum);\r\nurb = pickup_urb_and_free_priv(vdev, unlink->unlink_seqnum);\r\nif (!urb) {\r\npr_info("the urb (seqnum %lu) was already given back\n",\r\nunlink->unlink_seqnum);\r\nlist_del(&unlink->list);\r\nkfree(unlink);\r\ncontinue;\r\n}\r\nurb->status = -ENODEV;\r\nusb_hcd_unlink_urb_from_ep(vhci_to_hcd(the_controller), urb);\r\nlist_del(&unlink->list);\r\nspin_unlock(&vdev->priv_lock);\r\nspin_unlock(&the_controller->lock);\r\nusb_hcd_giveback_urb(vhci_to_hcd(the_controller), urb,\r\nurb->status);\r\nspin_lock(&the_controller->lock);\r\nspin_lock(&vdev->priv_lock);\r\nkfree(unlink);\r\n}\r\nspin_unlock(&vdev->priv_lock);\r\nspin_unlock(&the_controller->lock);\r\n}\r\nstatic void vhci_shutdown_connection(struct usbip_device *ud)\r\n{\r\nstruct vhci_device *vdev = container_of(ud, struct vhci_device, ud);\r\nif (ud->tcp_socket) {\r\npr_debug("shutdown tcp_socket %p\n", ud->tcp_socket);\r\nkernel_sock_shutdown(ud->tcp_socket, SHUT_RDWR);\r\n}\r\nif (vdev->ud.tcp_rx) {\r\nkthread_stop_put(vdev->ud.tcp_rx);\r\nvdev->ud.tcp_rx = NULL;\r\n}\r\nif (vdev->ud.tcp_tx) {\r\nkthread_stop_put(vdev->ud.tcp_tx);\r\nvdev->ud.tcp_tx = NULL;\r\n}\r\npr_info("stop threads\n");\r\nif (vdev->ud.tcp_socket) {\r\nsockfd_put(vdev->ud.tcp_socket);\r\nvdev->ud.tcp_socket = NULL;\r\n}\r\npr_info("release socket\n");\r\nvhci_device_unlink_cleanup(vdev);\r\nrh_port_disconnect(vdev->rhport);\r\npr_info("disconnect device\n");\r\n}\r\nstatic void vhci_device_reset(struct usbip_device *ud)\r\n{\r\nstruct vhci_device *vdev = container_of(ud, struct vhci_device, ud);\r\nspin_lock(&ud->lock);\r\nvdev->speed = 0;\r\nvdev->devid = 0;\r\nusb_put_dev(vdev->udev);\r\nvdev->udev = NULL;\r\nif (ud->tcp_socket) {\r\nsockfd_put(ud->tcp_socket);\r\nud->tcp_socket = NULL;\r\n}\r\nud->status = VDEV_ST_NULL;\r\nspin_unlock(&ud->lock);\r\n}\r\nstatic void vhci_device_unusable(struct usbip_device *ud)\r\n{\r\nspin_lock(&ud->lock);\r\nud->status = VDEV_ST_ERROR;\r\nspin_unlock(&ud->lock);\r\n}\r\nstatic void vhci_device_init(struct vhci_device *vdev)\r\n{\r\nmemset(vdev, 0, sizeof(*vdev));\r\nvdev->ud.side = USBIP_VHCI;\r\nvdev->ud.status = VDEV_ST_NULL;\r\nspin_lock_init(&vdev->ud.lock);\r\nINIT_LIST_HEAD(&vdev->priv_rx);\r\nINIT_LIST_HEAD(&vdev->priv_tx);\r\nINIT_LIST_HEAD(&vdev->unlink_tx);\r\nINIT_LIST_HEAD(&vdev->unlink_rx);\r\nspin_lock_init(&vdev->priv_lock);\r\ninit_waitqueue_head(&vdev->waitq_tx);\r\nvdev->ud.eh_ops.shutdown = vhci_shutdown_connection;\r\nvdev->ud.eh_ops.reset = vhci_device_reset;\r\nvdev->ud.eh_ops.unusable = vhci_device_unusable;\r\nusbip_start_eh(&vdev->ud);\r\n}\r\nstatic int vhci_start(struct usb_hcd *hcd)\r\n{\r\nstruct vhci_hcd *vhci = hcd_to_vhci(hcd);\r\nint rhport;\r\nint err = 0;\r\nusbip_dbg_vhci_hc("enter vhci_start\n");\r\nfor (rhport = 0; rhport < VHCI_NPORTS; rhport++) {\r\nstruct vhci_device *vdev = &vhci->vdev[rhport];\r\nvhci_device_init(vdev);\r\nvdev->rhport = rhport;\r\n}\r\natomic_set(&vhci->seqnum, 0);\r\nspin_lock_init(&vhci->lock);\r\nhcd->power_budget = 0;\r\nhcd->uses_new_polling = 1;\r\nerr = sysfs_create_group(&vhci_dev(vhci)->kobj, &dev_attr_group);\r\nif (err) {\r\npr_err("create sysfs files\n");\r\nreturn err;\r\n}\r\nreturn 0;\r\n}\r\nstatic void vhci_stop(struct usb_hcd *hcd)\r\n{\r\nstruct vhci_hcd *vhci = hcd_to_vhci(hcd);\r\nint rhport = 0;\r\nusbip_dbg_vhci_hc("stop VHCI controller\n");\r\nsysfs_remove_group(&vhci_dev(vhci)->kobj, &dev_attr_group);\r\nfor (rhport = 0; rhport < VHCI_NPORTS; rhport++) {\r\nstruct vhci_device *vdev = &vhci->vdev[rhport];\r\nusbip_event_add(&vdev->ud, VDEV_EVENT_REMOVED);\r\nusbip_stop_eh(&vdev->ud);\r\n}\r\n}\r\nstatic int vhci_get_frame_number(struct usb_hcd *hcd)\r\n{\r\npr_err("Not yet implemented\n");\r\nreturn 0;\r\n}\r\nstatic int vhci_bus_suspend(struct usb_hcd *hcd)\r\n{\r\nstruct vhci_hcd *vhci = hcd_to_vhci(hcd);\r\ndev_dbg(&hcd->self.root_hub->dev, "%s\n", __func__);\r\nspin_lock(&vhci->lock);\r\nhcd->state = HC_STATE_SUSPENDED;\r\nspin_unlock(&vhci->lock);\r\nreturn 0;\r\n}\r\nstatic int vhci_bus_resume(struct usb_hcd *hcd)\r\n{\r\nstruct vhci_hcd *vhci = hcd_to_vhci(hcd);\r\nint rc = 0;\r\ndev_dbg(&hcd->self.root_hub->dev, "%s\n", __func__);\r\nspin_lock(&vhci->lock);\r\nif (!HCD_HW_ACCESSIBLE(hcd))\r\nrc = -ESHUTDOWN;\r\nelse\r\nhcd->state = HC_STATE_RUNNING;\r\nspin_unlock(&vhci->lock);\r\nreturn rc;\r\n}\r\nstatic int vhci_hcd_probe(struct platform_device *pdev)\r\n{\r\nstruct usb_hcd *hcd;\r\nint ret;\r\nusbip_dbg_vhci_hc("name %s id %d\n", pdev->name, pdev->id);\r\nhcd = usb_create_hcd(&vhci_hc_driver, &pdev->dev, dev_name(&pdev->dev));\r\nif (!hcd) {\r\npr_err("create hcd failed\n");\r\nreturn -ENOMEM;\r\n}\r\nhcd->has_tt = 1;\r\nthe_controller = hcd_to_vhci(hcd);\r\nret = usb_add_hcd(hcd, 0, 0);\r\nif (ret != 0) {\r\npr_err("usb_add_hcd failed %d\n", ret);\r\nusb_put_hcd(hcd);\r\nthe_controller = NULL;\r\nreturn ret;\r\n}\r\nusbip_dbg_vhci_hc("bye\n");\r\nreturn 0;\r\n}\r\nstatic int vhci_hcd_remove(struct platform_device *pdev)\r\n{\r\nstruct usb_hcd *hcd;\r\nhcd = platform_get_drvdata(pdev);\r\nif (!hcd)\r\nreturn 0;\r\nusb_remove_hcd(hcd);\r\nusb_put_hcd(hcd);\r\nthe_controller = NULL;\r\nreturn 0;\r\n}\r\nstatic int vhci_hcd_suspend(struct platform_device *pdev, pm_message_t state)\r\n{\r\nstruct usb_hcd *hcd;\r\nint rhport = 0;\r\nint connected = 0;\r\nint ret = 0;\r\nhcd = platform_get_drvdata(pdev);\r\nspin_lock(&the_controller->lock);\r\nfor (rhport = 0; rhport < VHCI_NPORTS; rhport++)\r\nif (the_controller->port_status[rhport] &\r\nUSB_PORT_STAT_CONNECTION)\r\nconnected += 1;\r\nspin_unlock(&the_controller->lock);\r\nif (connected > 0) {\r\ndev_info(&pdev->dev,\r\n"We have %d active connection%s. Do not suspend.\n",\r\nconnected, (connected == 1 ? "" : "s"));\r\nret = -EBUSY;\r\n} else {\r\ndev_info(&pdev->dev, "suspend vhci_hcd");\r\nclear_bit(HCD_FLAG_HW_ACCESSIBLE, &hcd->flags);\r\n}\r\nreturn ret;\r\n}\r\nstatic int vhci_hcd_resume(struct platform_device *pdev)\r\n{\r\nstruct usb_hcd *hcd;\r\ndev_dbg(&pdev->dev, "%s\n", __func__);\r\nhcd = platform_get_drvdata(pdev);\r\nset_bit(HCD_FLAG_HW_ACCESSIBLE, &hcd->flags);\r\nusb_hcd_poll_rh_status(hcd);\r\nreturn 0;\r\n}\r\nstatic void the_pdev_release(struct device *dev)\r\n{\r\n}\r\nstatic int __init vhci_hcd_init(void)\r\n{\r\nint ret;\r\nif (usb_disabled())\r\nreturn -ENODEV;\r\nret = platform_driver_register(&vhci_driver);\r\nif (ret)\r\ngoto err_driver_register;\r\nret = platform_device_register(&the_pdev);\r\nif (ret)\r\ngoto err_platform_device_register;\r\npr_info(DRIVER_DESC " v" USBIP_VERSION "\n");\r\nreturn ret;\r\nerr_platform_device_register:\r\nplatform_driver_unregister(&vhci_driver);\r\nerr_driver_register:\r\nreturn ret;\r\n}\r\nstatic void __exit vhci_hcd_exit(void)\r\n{\r\nplatform_device_unregister(&the_pdev);\r\nplatform_driver_unregister(&vhci_driver);\r\n}
