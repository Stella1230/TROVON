static int tegra20_reset_sleeping_cpu_1(void)\r\n{\r\nint ret = 0;\r\ntegra_pen_lock();\r\nif (readb(tegra20_cpu1_resettable_status) == CPU_RESETTABLE)\r\ntegra20_cpu_shutdown(1);\r\nelse\r\nret = -EINVAL;\r\ntegra_pen_unlock();\r\nreturn ret;\r\n}\r\nstatic void tegra20_wake_cpu1_from_reset(void)\r\n{\r\ntegra_pen_lock();\r\ntegra20_cpu_clear_resettable();\r\ntegra_enable_cpu_clock(1);\r\ntegra_cpu_out_of_reset(1);\r\nflowctrl_write_cpu_halt(1, 0);\r\ntegra_pen_unlock();\r\n}\r\nstatic int tegra20_reset_cpu_1(void)\r\n{\r\nif (!cpu_online(1) || !tegra20_reset_sleeping_cpu_1())\r\nreturn 0;\r\ntegra20_wake_cpu1_from_reset();\r\nreturn -EBUSY;\r\n}\r\nstatic inline void tegra20_wake_cpu1_from_reset(void)\r\n{\r\n}\r\nstatic inline int tegra20_reset_cpu_1(void)\r\n{\r\nreturn 0;\r\n}\r\nstatic bool tegra20_cpu_cluster_power_down(struct cpuidle_device *dev,\r\nstruct cpuidle_driver *drv,\r\nint index)\r\n{\r\nwhile (tegra20_cpu_is_resettable_soon())\r\ncpu_relax();\r\nif (tegra20_reset_cpu_1() || !tegra_cpu_rail_off_ready())\r\nreturn false;\r\ntick_broadcast_enter();\r\ntegra_idle_lp2_last();\r\ntick_broadcast_exit();\r\nif (cpu_online(1))\r\ntegra20_wake_cpu1_from_reset();\r\nreturn true;\r\n}\r\nstatic bool tegra20_idle_enter_lp2_cpu_1(struct cpuidle_device *dev,\r\nstruct cpuidle_driver *drv,\r\nint index)\r\n{\r\ntick_broadcast_enter();\r\ncpu_suspend(0, tegra20_sleep_cpu_secondary_finish);\r\ntegra20_cpu_clear_resettable();\r\ntick_broadcast_exit();\r\nreturn true;\r\n}\r\nstatic inline bool tegra20_idle_enter_lp2_cpu_1(struct cpuidle_device *dev,\r\nstruct cpuidle_driver *drv,\r\nint index)\r\n{\r\nreturn true;\r\n}\r\nstatic int tegra20_idle_lp2_coupled(struct cpuidle_device *dev,\r\nstruct cpuidle_driver *drv,\r\nint index)\r\n{\r\nbool entered_lp2 = false;\r\nif (tegra_pending_sgi())\r\nACCESS_ONCE(abort_flag) = true;\r\ncpuidle_coupled_parallel_barrier(dev, &abort_barrier);\r\nif (abort_flag) {\r\ncpuidle_coupled_parallel_barrier(dev, &abort_barrier);\r\nabort_flag = false;\r\nreturn -EINTR;\r\n}\r\nlocal_fiq_disable();\r\ntegra_set_cpu_in_lp2();\r\ncpu_pm_enter();\r\nif (dev->cpu == 0)\r\nentered_lp2 = tegra20_cpu_cluster_power_down(dev, drv, index);\r\nelse\r\nentered_lp2 = tegra20_idle_enter_lp2_cpu_1(dev, drv, index);\r\ncpu_pm_exit();\r\ntegra_clear_cpu_in_lp2();\r\nlocal_fiq_enable();\r\nsmp_rmb();\r\nreturn entered_lp2 ? index : 0;\r\n}\r\nvoid tegra20_cpuidle_pcie_irqs_in_use(void)\r\n{\r\npr_info_once(\r\n"Disabling cpuidle LP2 state, since PCIe IRQs are in use\n");\r\ntegra_idle_driver.states[1].disabled = true;\r\n}\r\nint __init tegra20_cpuidle_init(void)\r\n{\r\nreturn cpuidle_register(&tegra_idle_driver, cpu_possible_mask);\r\n}
