static void yurex_control_callback(struct urb *urb)\r\n{\r\nstruct usb_yurex *dev = urb->context;\r\nint status = urb->status;\r\nif (status) {\r\ndev_err(&urb->dev->dev, "%s - control failed: %d\n",\r\n__func__, status);\r\nwake_up_interruptible(&dev->waitq);\r\nreturn;\r\n}\r\n}\r\nstatic void yurex_delete(struct kref *kref)\r\n{\r\nstruct usb_yurex *dev = to_yurex_dev(kref);\r\ndev_dbg(&dev->interface->dev, "%s\n", __func__);\r\nusb_put_dev(dev->udev);\r\nif (dev->cntl_urb) {\r\nusb_kill_urb(dev->cntl_urb);\r\nkfree(dev->cntl_req);\r\nif (dev->cntl_buffer)\r\nusb_free_coherent(dev->udev, YUREX_BUF_SIZE,\r\ndev->cntl_buffer, dev->cntl_urb->transfer_dma);\r\nusb_free_urb(dev->cntl_urb);\r\n}\r\nif (dev->urb) {\r\nusb_kill_urb(dev->urb);\r\nif (dev->int_buffer)\r\nusb_free_coherent(dev->udev, YUREX_BUF_SIZE,\r\ndev->int_buffer, dev->urb->transfer_dma);\r\nusb_free_urb(dev->urb);\r\n}\r\nkfree(dev);\r\n}\r\nstatic void yurex_interrupt(struct urb *urb)\r\n{\r\nstruct usb_yurex *dev = urb->context;\r\nunsigned char *buf = dev->int_buffer;\r\nint status = urb->status;\r\nunsigned long flags;\r\nint retval, i;\r\nswitch (status) {\r\ncase 0:\r\nbreak;\r\ncase -EOVERFLOW:\r\ndev_err(&dev->interface->dev,\r\n"%s - overflow with length %d, actual length is %d\n",\r\n__func__, YUREX_BUF_SIZE, dev->urb->actual_length);\r\ncase -ECONNRESET:\r\ncase -ENOENT:\r\ncase -ESHUTDOWN:\r\ncase -EILSEQ:\r\nreturn;\r\ndefault:\r\ndev_err(&dev->interface->dev,\r\n"%s - unknown status received: %d\n", __func__, status);\r\ngoto exit;\r\n}\r\nswitch (buf[0]) {\r\ncase CMD_COUNT:\r\ncase CMD_READ:\r\nif (buf[6] == CMD_EOF) {\r\nspin_lock_irqsave(&dev->lock, flags);\r\ndev->bbu = 0;\r\nfor (i = 1; i < 6; i++) {\r\ndev->bbu += buf[i];\r\nif (i != 5)\r\ndev->bbu <<= 8;\r\n}\r\ndev_dbg(&dev->interface->dev, "%s count: %lld\n",\r\n__func__, dev->bbu);\r\nspin_unlock_irqrestore(&dev->lock, flags);\r\nkill_fasync(&dev->async_queue, SIGIO, POLL_IN);\r\n}\r\nelse\r\ndev_dbg(&dev->interface->dev,\r\n"data format error - no EOF\n");\r\nbreak;\r\ncase CMD_ACK:\r\ndev_dbg(&dev->interface->dev, "%s ack: %c\n",\r\n__func__, buf[1]);\r\nwake_up_interruptible(&dev->waitq);\r\nbreak;\r\n}\r\nexit:\r\nretval = usb_submit_urb(dev->urb, GFP_ATOMIC);\r\nif (retval) {\r\ndev_err(&dev->interface->dev, "%s - usb_submit_urb failed: %d\n",\r\n__func__, retval);\r\n}\r\n}\r\nstatic int yurex_probe(struct usb_interface *interface, const struct usb_device_id *id)\r\n{\r\nstruct usb_yurex *dev;\r\nstruct usb_host_interface *iface_desc;\r\nstruct usb_endpoint_descriptor *endpoint;\r\nint retval = -ENOMEM;\r\nint i;\r\nDEFINE_WAIT(wait);\r\ndev = kzalloc(sizeof(*dev), GFP_KERNEL);\r\nif (!dev) {\r\ndev_err(&interface->dev, "Out of memory\n");\r\ngoto error;\r\n}\r\nkref_init(&dev->kref);\r\nmutex_init(&dev->io_mutex);\r\nspin_lock_init(&dev->lock);\r\ninit_waitqueue_head(&dev->waitq);\r\ndev->udev = usb_get_dev(interface_to_usbdev(interface));\r\ndev->interface = interface;\r\niface_desc = interface->cur_altsetting;\r\nfor (i = 0; i < iface_desc->desc.bNumEndpoints; i++) {\r\nendpoint = &iface_desc->endpoint[i].desc;\r\nif (usb_endpoint_is_int_in(endpoint)) {\r\ndev->int_in_endpointAddr = endpoint->bEndpointAddress;\r\nbreak;\r\n}\r\n}\r\nif (!dev->int_in_endpointAddr) {\r\nretval = -ENODEV;\r\ndev_err(&interface->dev, "Could not find endpoints\n");\r\ngoto error;\r\n}\r\ndev->cntl_urb = usb_alloc_urb(0, GFP_KERNEL);\r\nif (!dev->cntl_urb) {\r\ndev_err(&interface->dev, "Could not allocate control URB\n");\r\ngoto error;\r\n}\r\ndev->cntl_req = kmalloc(YUREX_BUF_SIZE, GFP_KERNEL);\r\nif (!dev->cntl_req) {\r\ndev_err(&interface->dev, "Could not allocate cntl_req\n");\r\ngoto error;\r\n}\r\ndev->cntl_buffer = usb_alloc_coherent(dev->udev, YUREX_BUF_SIZE,\r\nGFP_KERNEL,\r\n&dev->cntl_urb->transfer_dma);\r\nif (!dev->cntl_buffer) {\r\ndev_err(&interface->dev, "Could not allocate cntl_buffer\n");\r\ngoto error;\r\n}\r\ndev->cntl_req->bRequestType = USB_DIR_OUT | USB_TYPE_CLASS |\r\nUSB_RECIP_INTERFACE;\r\ndev->cntl_req->bRequest = HID_REQ_SET_REPORT;\r\ndev->cntl_req->wValue = cpu_to_le16((HID_OUTPUT_REPORT + 1) << 8);\r\ndev->cntl_req->wIndex = cpu_to_le16(iface_desc->desc.bInterfaceNumber);\r\ndev->cntl_req->wLength = cpu_to_le16(YUREX_BUF_SIZE);\r\nusb_fill_control_urb(dev->cntl_urb, dev->udev,\r\nusb_sndctrlpipe(dev->udev, 0),\r\n(void *)dev->cntl_req, dev->cntl_buffer,\r\nYUREX_BUF_SIZE, yurex_control_callback, dev);\r\ndev->cntl_urb->transfer_flags |= URB_NO_TRANSFER_DMA_MAP;\r\ndev->urb = usb_alloc_urb(0, GFP_KERNEL);\r\nif (!dev->urb) {\r\ndev_err(&interface->dev, "Could not allocate URB\n");\r\ngoto error;\r\n}\r\ndev->int_buffer = usb_alloc_coherent(dev->udev, YUREX_BUF_SIZE,\r\nGFP_KERNEL, &dev->urb->transfer_dma);\r\nif (!dev->int_buffer) {\r\ndev_err(&interface->dev, "Could not allocate int_buffer\n");\r\ngoto error;\r\n}\r\nusb_fill_int_urb(dev->urb, dev->udev,\r\nusb_rcvintpipe(dev->udev, dev->int_in_endpointAddr),\r\ndev->int_buffer, YUREX_BUF_SIZE, yurex_interrupt,\r\ndev, 1);\r\ndev->urb->transfer_flags |= URB_NO_TRANSFER_DMA_MAP;\r\nif (usb_submit_urb(dev->urb, GFP_KERNEL)) {\r\nretval = -EIO;\r\ndev_err(&interface->dev, "Could not submitting URB\n");\r\ngoto error;\r\n}\r\nusb_set_intfdata(interface, dev);\r\ndev->bbu = -1;\r\nretval = usb_register_dev(interface, &yurex_class);\r\nif (retval) {\r\ndev_err(&interface->dev,\r\n"Not able to get a minor for this device.\n");\r\nusb_set_intfdata(interface, NULL);\r\ngoto error;\r\n}\r\ndev_info(&interface->dev,\r\n"USB YUREX device now attached to Yurex #%d\n",\r\ninterface->minor);\r\nreturn 0;\r\nerror:\r\nif (dev)\r\nkref_put(&dev->kref, yurex_delete);\r\nreturn retval;\r\n}\r\nstatic void yurex_disconnect(struct usb_interface *interface)\r\n{\r\nstruct usb_yurex *dev;\r\nint minor = interface->minor;\r\ndev = usb_get_intfdata(interface);\r\nusb_set_intfdata(interface, NULL);\r\nusb_deregister_dev(interface, &yurex_class);\r\nmutex_lock(&dev->io_mutex);\r\ndev->interface = NULL;\r\nmutex_unlock(&dev->io_mutex);\r\nkill_fasync(&dev->async_queue, SIGIO, POLL_IN);\r\nwake_up_interruptible(&dev->waitq);\r\nkref_put(&dev->kref, yurex_delete);\r\ndev_info(&interface->dev, "USB YUREX #%d now disconnected\n", minor);\r\n}\r\nstatic int yurex_fasync(int fd, struct file *file, int on)\r\n{\r\nstruct usb_yurex *dev;\r\ndev = file->private_data;\r\nreturn fasync_helper(fd, file, on, &dev->async_queue);\r\n}\r\nstatic int yurex_open(struct inode *inode, struct file *file)\r\n{\r\nstruct usb_yurex *dev;\r\nstruct usb_interface *interface;\r\nint subminor;\r\nint retval = 0;\r\nsubminor = iminor(inode);\r\ninterface = usb_find_interface(&yurex_driver, subminor);\r\nif (!interface) {\r\nprintk(KERN_ERR "%s - error, can't find device for minor %d",\r\n__func__, subminor);\r\nretval = -ENODEV;\r\ngoto exit;\r\n}\r\ndev = usb_get_intfdata(interface);\r\nif (!dev) {\r\nretval = -ENODEV;\r\ngoto exit;\r\n}\r\nkref_get(&dev->kref);\r\nmutex_lock(&dev->io_mutex);\r\nfile->private_data = dev;\r\nmutex_unlock(&dev->io_mutex);\r\nexit:\r\nreturn retval;\r\n}\r\nstatic int yurex_release(struct inode *inode, struct file *file)\r\n{\r\nstruct usb_yurex *dev;\r\ndev = file->private_data;\r\nif (dev == NULL)\r\nreturn -ENODEV;\r\nkref_put(&dev->kref, yurex_delete);\r\nreturn 0;\r\n}\r\nstatic ssize_t yurex_read(struct file *file, char __user *buffer, size_t count,\r\nloff_t *ppos)\r\n{\r\nstruct usb_yurex *dev;\r\nint retval = 0;\r\nint bytes_read = 0;\r\nchar in_buffer[20];\r\nunsigned long flags;\r\ndev = file->private_data;\r\nmutex_lock(&dev->io_mutex);\r\nif (!dev->interface) {\r\nretval = -ENODEV;\r\ngoto exit;\r\n}\r\nspin_lock_irqsave(&dev->lock, flags);\r\nbytes_read = snprintf(in_buffer, 20, "%lld\n", dev->bbu);\r\nspin_unlock_irqrestore(&dev->lock, flags);\r\nif (*ppos < bytes_read) {\r\nif (copy_to_user(buffer, in_buffer + *ppos, bytes_read - *ppos))\r\nretval = -EFAULT;\r\nelse {\r\nretval = bytes_read - *ppos;\r\n*ppos += bytes_read;\r\n}\r\n}\r\nexit:\r\nmutex_unlock(&dev->io_mutex);\r\nreturn retval;\r\n}\r\nstatic ssize_t yurex_write(struct file *file, const char __user *user_buffer,\r\nsize_t count, loff_t *ppos)\r\n{\r\nstruct usb_yurex *dev;\r\nint i, set = 0, retval = 0;\r\nchar buffer[16];\r\nchar *data = buffer;\r\nunsigned long long c, c2 = 0;\r\nsigned long timeout = 0;\r\nDEFINE_WAIT(wait);\r\ncount = min(sizeof(buffer), count);\r\ndev = file->private_data;\r\nif (count == 0)\r\ngoto error;\r\nmutex_lock(&dev->io_mutex);\r\nif (!dev->interface) {\r\nmutex_unlock(&dev->io_mutex);\r\nretval = -ENODEV;\r\ngoto error;\r\n}\r\nif (copy_from_user(buffer, user_buffer, count)) {\r\nmutex_unlock(&dev->io_mutex);\r\nretval = -EFAULT;\r\ngoto error;\r\n}\r\nmemset(dev->cntl_buffer, CMD_PADDING, YUREX_BUF_SIZE);\r\nswitch (buffer[0]) {\r\ncase CMD_ANIMATE:\r\ncase CMD_LED:\r\ndev->cntl_buffer[0] = buffer[0];\r\ndev->cntl_buffer[1] = buffer[1];\r\ndev->cntl_buffer[2] = CMD_EOF;\r\nbreak;\r\ncase CMD_READ:\r\ncase CMD_VERSION:\r\ndev->cntl_buffer[0] = buffer[0];\r\ndev->cntl_buffer[1] = 0x00;\r\ndev->cntl_buffer[2] = CMD_EOF;\r\nbreak;\r\ncase CMD_SET:\r\ndata++;\r\ncase '0' ... '9':\r\nset = 1;\r\nc = c2 = simple_strtoull(data, NULL, 0);\r\ndev->cntl_buffer[0] = CMD_SET;\r\nfor (i = 1; i < 6; i++) {\r\ndev->cntl_buffer[i] = (c>>32) & 0xff;\r\nc <<= 8;\r\n}\r\nbuffer[6] = CMD_EOF;\r\nbreak;\r\ndefault:\r\nmutex_unlock(&dev->io_mutex);\r\nreturn -EINVAL;\r\n}\r\nprepare_to_wait(&dev->waitq, &wait, TASK_INTERRUPTIBLE);\r\ndev_dbg(&dev->interface->dev, "%s - submit %c\n", __func__,\r\ndev->cntl_buffer[0]);\r\nretval = usb_submit_urb(dev->cntl_urb, GFP_KERNEL);\r\nif (retval >= 0)\r\ntimeout = schedule_timeout(YUREX_WRITE_TIMEOUT);\r\nfinish_wait(&dev->waitq, &wait);\r\nmutex_unlock(&dev->io_mutex);\r\nif (retval < 0) {\r\ndev_err(&dev->interface->dev,\r\n"%s - failed to send bulk msg, error %d\n",\r\n__func__, retval);\r\ngoto error;\r\n}\r\nif (set && timeout)\r\ndev->bbu = c2;\r\nreturn timeout ? count : -EIO;\r\nerror:\r\nreturn retval;\r\n}
