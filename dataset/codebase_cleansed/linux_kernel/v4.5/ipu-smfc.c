int ipu_smfc_set_burstsize(struct ipu_smfc *smfc, int burstsize)\r\n{\r\nstruct ipu_smfc_priv *priv = smfc->priv;\r\nunsigned long flags;\r\nu32 val, shift;\r\nspin_lock_irqsave(&priv->lock, flags);\r\nshift = smfc->chno * 4;\r\nval = readl(priv->base + SMFC_BS);\r\nval &= ~(0xf << shift);\r\nval |= burstsize << shift;\r\nwritel(val, priv->base + SMFC_BS);\r\nspin_unlock_irqrestore(&priv->lock, flags);\r\nreturn 0;\r\n}\r\nint ipu_smfc_map_channel(struct ipu_smfc *smfc, int csi_id, int mipi_id)\r\n{\r\nstruct ipu_smfc_priv *priv = smfc->priv;\r\nunsigned long flags;\r\nu32 val, shift;\r\nspin_lock_irqsave(&priv->lock, flags);\r\nshift = smfc->chno * 3;\r\nval = readl(priv->base + SMFC_MAP);\r\nval &= ~(0x7 << shift);\r\nval |= ((csi_id << 2) | mipi_id) << shift;\r\nwritel(val, priv->base + SMFC_MAP);\r\nspin_unlock_irqrestore(&priv->lock, flags);\r\nreturn 0;\r\n}\r\nint ipu_smfc_set_watermark(struct ipu_smfc *smfc, u32 set_level, u32 clr_level)\r\n{\r\nstruct ipu_smfc_priv *priv = smfc->priv;\r\nunsigned long flags;\r\nu32 val, shift;\r\nspin_lock_irqsave(&priv->lock, flags);\r\nshift = smfc->chno * 6 + (smfc->chno > 1 ? 4 : 0);\r\nval = readl(priv->base + SMFC_WMC);\r\nval &= ~(0x3f << shift);\r\nval |= ((clr_level << 3) | set_level) << shift;\r\nwritel(val, priv->base + SMFC_WMC);\r\nspin_unlock_irqrestore(&priv->lock, flags);\r\nreturn 0;\r\n}\r\nint ipu_smfc_enable(struct ipu_smfc *smfc)\r\n{\r\nstruct ipu_smfc_priv *priv = smfc->priv;\r\nunsigned long flags;\r\nspin_lock_irqsave(&priv->lock, flags);\r\nif (!priv->use_count)\r\nipu_module_enable(priv->ipu, IPU_CONF_SMFC_EN);\r\npriv->use_count++;\r\nspin_unlock_irqrestore(&priv->lock, flags);\r\nreturn 0;\r\n}\r\nint ipu_smfc_disable(struct ipu_smfc *smfc)\r\n{\r\nstruct ipu_smfc_priv *priv = smfc->priv;\r\nunsigned long flags;\r\nspin_lock_irqsave(&priv->lock, flags);\r\npriv->use_count--;\r\nif (!priv->use_count)\r\nipu_module_disable(priv->ipu, IPU_CONF_SMFC_EN);\r\nif (priv->use_count < 0)\r\npriv->use_count = 0;\r\nspin_unlock_irqrestore(&priv->lock, flags);\r\nreturn 0;\r\n}\r\nstruct ipu_smfc *ipu_smfc_get(struct ipu_soc *ipu, unsigned int chno)\r\n{\r\nstruct ipu_smfc_priv *priv = ipu->smfc_priv;\r\nstruct ipu_smfc *smfc, *ret;\r\nunsigned long flags;\r\nif (chno >= 4)\r\nreturn ERR_PTR(-EINVAL);\r\nsmfc = &priv->channel[chno];\r\nret = smfc;\r\nspin_lock_irqsave(&priv->lock, flags);\r\nif (smfc->inuse) {\r\nret = ERR_PTR(-EBUSY);\r\ngoto unlock;\r\n}\r\nsmfc->inuse = true;\r\nunlock:\r\nspin_unlock_irqrestore(&priv->lock, flags);\r\nreturn ret;\r\n}\r\nvoid ipu_smfc_put(struct ipu_smfc *smfc)\r\n{\r\nstruct ipu_smfc_priv *priv = smfc->priv;\r\nunsigned long flags;\r\nspin_lock_irqsave(&priv->lock, flags);\r\nsmfc->inuse = false;\r\nspin_unlock_irqrestore(&priv->lock, flags);\r\n}\r\nint ipu_smfc_init(struct ipu_soc *ipu, struct device *dev,\r\nunsigned long base)\r\n{\r\nstruct ipu_smfc_priv *priv;\r\nint i;\r\npriv = devm_kzalloc(dev, sizeof(*priv), GFP_KERNEL);\r\nif (!priv)\r\nreturn -ENOMEM;\r\nipu->smfc_priv = priv;\r\nspin_lock_init(&priv->lock);\r\npriv->ipu = ipu;\r\npriv->base = devm_ioremap(dev, base, PAGE_SIZE);\r\nif (!priv->base)\r\nreturn -ENOMEM;\r\nfor (i = 0; i < 4; i++) {\r\npriv->channel[i].priv = priv;\r\npriv->channel[i].chno = i;\r\n}\r\npr_debug("%s: ioremap 0x%08lx -> %p\n", __func__, base, priv->base);\r\nreturn 0;\r\n}\r\nvoid ipu_smfc_exit(struct ipu_soc *ipu)\r\n{\r\n}
