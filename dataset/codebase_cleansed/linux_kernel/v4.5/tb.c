static void tb_scan_switch(struct tb_switch *sw)\r\n{\r\nint i;\r\nfor (i = 1; i <= sw->config.max_port_number; i++)\r\ntb_scan_port(&sw->ports[i]);\r\n}\r\nstatic void tb_scan_port(struct tb_port *port)\r\n{\r\nstruct tb_switch *sw;\r\nif (tb_is_upstream_port(port))\r\nreturn;\r\nif (port->config.type != TB_TYPE_PORT)\r\nreturn;\r\nif (port->dual_link_port && port->link_nr)\r\nreturn;\r\nif (tb_wait_for_port(port, false) <= 0)\r\nreturn;\r\nif (port->remote) {\r\ntb_port_WARN(port, "port already has a remote!\n");\r\nreturn;\r\n}\r\nsw = tb_switch_alloc(port->sw->tb, tb_downstream_route(port));\r\nif (!sw)\r\nreturn;\r\nport->remote = tb_upstream_port(sw);\r\ntb_upstream_port(sw)->remote = port;\r\ntb_scan_switch(sw);\r\n}\r\nstatic void tb_free_invalid_tunnels(struct tb *tb)\r\n{\r\nstruct tb_pci_tunnel *tunnel;\r\nstruct tb_pci_tunnel *n;\r\nlist_for_each_entry_safe(tunnel, n, &tb->tunnel_list, list)\r\n{\r\nif (tb_pci_is_invalid(tunnel)) {\r\ntb_pci_deactivate(tunnel);\r\ntb_pci_free(tunnel);\r\n}\r\n}\r\n}\r\nstatic void tb_free_unplugged_children(struct tb_switch *sw)\r\n{\r\nint i;\r\nfor (i = 1; i <= sw->config.max_port_number; i++) {\r\nstruct tb_port *port = &sw->ports[i];\r\nif (tb_is_upstream_port(port))\r\ncontinue;\r\nif (!port->remote)\r\ncontinue;\r\nif (port->remote->sw->is_unplugged) {\r\ntb_switch_free(port->remote->sw);\r\nport->remote = NULL;\r\n} else {\r\ntb_free_unplugged_children(port->remote->sw);\r\n}\r\n}\r\n}\r\nstatic struct tb_port *tb_find_pci_up_port(struct tb_switch *sw)\r\n{\r\nint i;\r\nfor (i = 1; i <= sw->config.max_port_number; i++)\r\nif (sw->ports[i].config.type == TB_TYPE_PCIE_UP)\r\nreturn &sw->ports[i];\r\nreturn NULL;\r\n}\r\nstatic struct tb_port *tb_find_unused_down_port(struct tb_switch *sw)\r\n{\r\nint i;\r\nint cap;\r\nint res;\r\nint data;\r\nfor (i = 1; i <= sw->config.max_port_number; i++) {\r\nif (tb_is_upstream_port(&sw->ports[i]))\r\ncontinue;\r\nif (sw->ports[i].config.type != TB_TYPE_PCIE_DOWN)\r\ncontinue;\r\ncap = tb_find_cap(&sw->ports[i], TB_CFG_PORT, TB_CAP_PCIE);\r\nif (cap <= 0)\r\ncontinue;\r\nres = tb_port_read(&sw->ports[i], &data, TB_CFG_PORT, cap, 1);\r\nif (res < 0)\r\ncontinue;\r\nif (data & 0x80000000)\r\ncontinue;\r\nreturn &sw->ports[i];\r\n}\r\nreturn NULL;\r\n}\r\nstatic void tb_activate_pcie_devices(struct tb *tb)\r\n{\r\nint i;\r\nint cap;\r\nu32 data;\r\nstruct tb_switch *sw;\r\nstruct tb_port *up_port;\r\nstruct tb_port *down_port;\r\nstruct tb_pci_tunnel *tunnel;\r\nfor (i = 1; i <= tb->root_switch->config.max_port_number; i++) {\r\nif (tb_is_upstream_port(&tb->root_switch->ports[i]))\r\ncontinue;\r\nif (tb->root_switch->ports[i].config.type != TB_TYPE_PORT)\r\ncontinue;\r\nif (!tb->root_switch->ports[i].remote)\r\ncontinue;\r\nsw = tb->root_switch->ports[i].remote->sw;\r\nup_port = tb_find_pci_up_port(sw);\r\nif (!up_port) {\r\ntb_sw_info(sw, "no PCIe devices found, aborting\n");\r\ncontinue;\r\n}\r\ncap = tb_find_cap(up_port, TB_CFG_PORT, TB_CAP_PCIE);\r\nif (cap <= 0)\r\ncontinue;\r\nif (tb_port_read(up_port, &data, TB_CFG_PORT, cap, 1))\r\ncontinue;\r\nif (data & 0x80000000) {\r\ntb_port_info(up_port,\r\n"PCIe port already activated, aborting\n");\r\ncontinue;\r\n}\r\ndown_port = tb_find_unused_down_port(tb->root_switch);\r\nif (!down_port) {\r\ntb_port_info(up_port,\r\n"All PCIe down ports are occupied, aborting\n");\r\ncontinue;\r\n}\r\ntunnel = tb_pci_alloc(tb, up_port, down_port);\r\nif (!tunnel) {\r\ntb_port_info(up_port,\r\n"PCIe tunnel allocation failed, aborting\n");\r\ncontinue;\r\n}\r\nif (tb_pci_activate(tunnel)) {\r\ntb_port_info(up_port,\r\n"PCIe tunnel activation failed, aborting\n");\r\ntb_pci_free(tunnel);\r\n}\r\n}\r\n}\r\nstatic void tb_handle_hotplug(struct work_struct *work)\r\n{\r\nstruct tb_hotplug_event *ev = container_of(work, typeof(*ev), work);\r\nstruct tb *tb = ev->tb;\r\nstruct tb_switch *sw;\r\nstruct tb_port *port;\r\nmutex_lock(&tb->lock);\r\nif (!tb->hotplug_active)\r\ngoto out;\r\nsw = get_switch_at_route(tb->root_switch, ev->route);\r\nif (!sw) {\r\ntb_warn(tb,\r\n"hotplug event from non existent switch %llx:%x (unplug: %d)\n",\r\nev->route, ev->port, ev->unplug);\r\ngoto out;\r\n}\r\nif (ev->port > sw->config.max_port_number) {\r\ntb_warn(tb,\r\n"hotplug event from non existent port %llx:%x (unplug: %d)\n",\r\nev->route, ev->port, ev->unplug);\r\ngoto out;\r\n}\r\nport = &sw->ports[ev->port];\r\nif (tb_is_upstream_port(port)) {\r\ntb_warn(tb,\r\n"hotplug event for upstream port %llx:%x (unplug: %d)\n",\r\nev->route, ev->port, ev->unplug);\r\ngoto out;\r\n}\r\nif (ev->unplug) {\r\nif (port->remote) {\r\ntb_port_info(port, "unplugged\n");\r\ntb_sw_set_unpplugged(port->remote->sw);\r\ntb_free_invalid_tunnels(tb);\r\ntb_switch_free(port->remote->sw);\r\nport->remote = NULL;\r\n} else {\r\ntb_port_info(port,\r\n"got unplug event for disconnected port, ignoring\n");\r\n}\r\n} else if (port->remote) {\r\ntb_port_info(port,\r\n"got plug event for connected port, ignoring\n");\r\n} else {\r\ntb_port_info(port, "hotplug: scanning\n");\r\ntb_scan_port(port);\r\nif (!port->remote) {\r\ntb_port_info(port, "hotplug: no switch found\n");\r\n} else if (port->remote->sw->config.depth > 1) {\r\ntb_sw_warn(port->remote->sw,\r\n"hotplug: chaining not supported\n");\r\n} else {\r\ntb_sw_info(port->remote->sw,\r\n"hotplug: activating pcie devices\n");\r\ntb_activate_pcie_devices(tb);\r\n}\r\n}\r\nout:\r\nmutex_unlock(&tb->lock);\r\nkfree(ev);\r\n}\r\nstatic void tb_schedule_hotplug_handler(void *data, u64 route, u8 port,\r\nbool unplug)\r\n{\r\nstruct tb *tb = data;\r\nstruct tb_hotplug_event *ev = kmalloc(sizeof(*ev), GFP_KERNEL);\r\nif (!ev)\r\nreturn;\r\nINIT_WORK(&ev->work, tb_handle_hotplug);\r\nev->tb = tb;\r\nev->route = route;\r\nev->port = port;\r\nev->unplug = unplug;\r\nqueue_work(tb->wq, &ev->work);\r\n}\r\nvoid thunderbolt_shutdown_and_free(struct tb *tb)\r\n{\r\nstruct tb_pci_tunnel *tunnel;\r\nstruct tb_pci_tunnel *n;\r\nmutex_lock(&tb->lock);\r\nlist_for_each_entry_safe(tunnel, n, &tb->tunnel_list, list) {\r\ntb_pci_deactivate(tunnel);\r\ntb_pci_free(tunnel);\r\n}\r\nif (tb->root_switch)\r\ntb_switch_free(tb->root_switch);\r\ntb->root_switch = NULL;\r\nif (tb->ctl) {\r\ntb_ctl_stop(tb->ctl);\r\ntb_ctl_free(tb->ctl);\r\n}\r\ntb->ctl = NULL;\r\ntb->hotplug_active = false;\r\nmutex_unlock(&tb->lock);\r\nif (tb->wq) {\r\nflush_workqueue(tb->wq);\r\ndestroy_workqueue(tb->wq);\r\ntb->wq = NULL;\r\n}\r\nmutex_destroy(&tb->lock);\r\nkfree(tb);\r\n}\r\nstruct tb *thunderbolt_alloc_and_start(struct tb_nhi *nhi)\r\n{\r\nstruct tb *tb;\r\nBUILD_BUG_ON(sizeof(struct tb_regs_switch_header) != 5 * 4);\r\nBUILD_BUG_ON(sizeof(struct tb_regs_port_header) != 8 * 4);\r\nBUILD_BUG_ON(sizeof(struct tb_regs_hop) != 2 * 4);\r\ntb = kzalloc(sizeof(*tb), GFP_KERNEL);\r\nif (!tb)\r\nreturn NULL;\r\ntb->nhi = nhi;\r\nmutex_init(&tb->lock);\r\nmutex_lock(&tb->lock);\r\nINIT_LIST_HEAD(&tb->tunnel_list);\r\ntb->wq = alloc_ordered_workqueue("thunderbolt", 0);\r\nif (!tb->wq)\r\ngoto err_locked;\r\ntb->ctl = tb_ctl_alloc(tb->nhi, tb_schedule_hotplug_handler, tb);\r\nif (!tb->ctl)\r\ngoto err_locked;\r\ntb_ctl_start(tb->ctl);\r\ntb->root_switch = tb_switch_alloc(tb, 0);\r\nif (!tb->root_switch)\r\ngoto err_locked;\r\ntb_scan_switch(tb->root_switch);\r\ntb_activate_pcie_devices(tb);\r\ntb->hotplug_active = true;\r\nmutex_unlock(&tb->lock);\r\nreturn tb;\r\nerr_locked:\r\nmutex_unlock(&tb->lock);\r\nthunderbolt_shutdown_and_free(tb);\r\nreturn NULL;\r\n}\r\nvoid thunderbolt_suspend(struct tb *tb)\r\n{\r\ntb_info(tb, "suspending...\n");\r\nmutex_lock(&tb->lock);\r\ntb_switch_suspend(tb->root_switch);\r\ntb_ctl_stop(tb->ctl);\r\ntb->hotplug_active = false;\r\nmutex_unlock(&tb->lock);\r\ntb_info(tb, "suspend finished\n");\r\n}\r\nvoid thunderbolt_resume(struct tb *tb)\r\n{\r\nstruct tb_pci_tunnel *tunnel, *n;\r\ntb_info(tb, "resuming...\n");\r\nmutex_lock(&tb->lock);\r\ntb_ctl_start(tb->ctl);\r\ntb_switch_reset(tb, 0);\r\ntb_switch_resume(tb->root_switch);\r\ntb_free_invalid_tunnels(tb);\r\ntb_free_unplugged_children(tb->root_switch);\r\nlist_for_each_entry_safe(tunnel, n, &tb->tunnel_list, list)\r\ntb_pci_restart(tunnel);\r\nif (!list_empty(&tb->tunnel_list)) {\r\ntb_info(tb, "tunnels restarted, sleeping for 100ms\n");\r\nmsleep(100);\r\n}\r\ntb->hotplug_active = true;\r\nmutex_unlock(&tb->lock);\r\ntb_info(tb, "resume finished\n");\r\n}
