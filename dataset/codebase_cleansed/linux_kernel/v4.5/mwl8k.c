static const char *mwl8k_cmd_name(__le16 cmd, char *buf, int bufsize)\r\n{\r\nu16 command = le16_to_cpu(cmd);\r\n#define MWL8K_CMDNAME(x) case MWL8K_CMD_##x: do {\\r\nsnprintf(buf, bufsize, "%s", #x);\\r\nreturn buf;\\r\n} while (0)\r\nswitch (command & ~0x8000) {\r\nMWL8K_CMDNAME(CODE_DNLD);\r\nMWL8K_CMDNAME(GET_HW_SPEC);\r\nMWL8K_CMDNAME(SET_HW_SPEC);\r\nMWL8K_CMDNAME(MAC_MULTICAST_ADR);\r\nMWL8K_CMDNAME(GET_STAT);\r\nMWL8K_CMDNAME(RADIO_CONTROL);\r\nMWL8K_CMDNAME(RF_TX_POWER);\r\nMWL8K_CMDNAME(TX_POWER);\r\nMWL8K_CMDNAME(RF_ANTENNA);\r\nMWL8K_CMDNAME(SET_BEACON);\r\nMWL8K_CMDNAME(SET_PRE_SCAN);\r\nMWL8K_CMDNAME(SET_POST_SCAN);\r\nMWL8K_CMDNAME(SET_RF_CHANNEL);\r\nMWL8K_CMDNAME(SET_AID);\r\nMWL8K_CMDNAME(SET_RATE);\r\nMWL8K_CMDNAME(SET_FINALIZE_JOIN);\r\nMWL8K_CMDNAME(RTS_THRESHOLD);\r\nMWL8K_CMDNAME(SET_SLOT);\r\nMWL8K_CMDNAME(SET_EDCA_PARAMS);\r\nMWL8K_CMDNAME(SET_WMM_MODE);\r\nMWL8K_CMDNAME(MIMO_CONFIG);\r\nMWL8K_CMDNAME(USE_FIXED_RATE);\r\nMWL8K_CMDNAME(ENABLE_SNIFFER);\r\nMWL8K_CMDNAME(SET_MAC_ADDR);\r\nMWL8K_CMDNAME(SET_RATEADAPT_MODE);\r\nMWL8K_CMDNAME(BSS_START);\r\nMWL8K_CMDNAME(SET_NEW_STN);\r\nMWL8K_CMDNAME(UPDATE_ENCRYPTION);\r\nMWL8K_CMDNAME(UPDATE_STADB);\r\nMWL8K_CMDNAME(BASTREAM);\r\nMWL8K_CMDNAME(GET_WATCHDOG_BITMAP);\r\ndefault:\r\nsnprintf(buf, bufsize, "0x%x", cmd);\r\n}\r\n#undef MWL8K_CMDNAME\r\nreturn buf;\r\n}\r\nstatic void mwl8k_hw_reset(struct mwl8k_priv *priv)\r\n{\r\niowrite32(MWL8K_H2A_INT_RESET,\r\npriv->regs + MWL8K_HIU_H2A_INTERRUPT_EVENTS);\r\niowrite32(MWL8K_H2A_INT_RESET,\r\npriv->regs + MWL8K_HIU_H2A_INTERRUPT_EVENTS);\r\nmsleep(20);\r\n}\r\nstatic void mwl8k_release_fw(const struct firmware **fw)\r\n{\r\nif (*fw == NULL)\r\nreturn;\r\nrelease_firmware(*fw);\r\n*fw = NULL;\r\n}\r\nstatic void mwl8k_release_firmware(struct mwl8k_priv *priv)\r\n{\r\nmwl8k_release_fw(&priv->fw_ucode);\r\nmwl8k_release_fw(&priv->fw_helper);\r\n}\r\nstatic int mwl8k_request_fw(struct mwl8k_priv *priv,\r\nconst char *fname, const struct firmware **fw,\r\nbool nowait)\r\n{\r\nif (*fw != NULL)\r\nmwl8k_release_fw(fw);\r\nif (nowait)\r\nreturn request_firmware_nowait(THIS_MODULE, 1, fname,\r\n&priv->pdev->dev, GFP_KERNEL,\r\npriv, mwl8k_fw_state_machine);\r\nelse\r\nreturn request_firmware(fw, fname, &priv->pdev->dev);\r\n}\r\nstatic int mwl8k_request_firmware(struct mwl8k_priv *priv, char *fw_image,\r\nbool nowait)\r\n{\r\nstruct mwl8k_device_info *di = priv->device_info;\r\nint rc;\r\nif (di->helper_image != NULL) {\r\nif (nowait)\r\nrc = mwl8k_request_fw(priv, di->helper_image,\r\n&priv->fw_helper, true);\r\nelse\r\nrc = mwl8k_request_fw(priv, di->helper_image,\r\n&priv->fw_helper, false);\r\nif (rc)\r\nprintk(KERN_ERR "%s: Error requesting helper fw %s\n",\r\npci_name(priv->pdev), di->helper_image);\r\nif (rc || nowait)\r\nreturn rc;\r\n}\r\nif (nowait) {\r\npriv->fw_state = FW_STATE_LOADING_PREF;\r\nrc = mwl8k_request_fw(priv, fw_image,\r\n&priv->fw_ucode,\r\ntrue);\r\n} else\r\nrc = mwl8k_request_fw(priv, fw_image,\r\n&priv->fw_ucode, false);\r\nif (rc) {\r\nprintk(KERN_ERR "%s: Error requesting firmware file %s\n",\r\npci_name(priv->pdev), fw_image);\r\nmwl8k_release_fw(&priv->fw_helper);\r\nreturn rc;\r\n}\r\nreturn 0;\r\n}\r\nstatic int\r\nmwl8k_send_fw_load_cmd(struct mwl8k_priv *priv, void *data, int length)\r\n{\r\nvoid __iomem *regs = priv->regs;\r\ndma_addr_t dma_addr;\r\nint loops;\r\ndma_addr = pci_map_single(priv->pdev, data, length, PCI_DMA_TODEVICE);\r\nif (pci_dma_mapping_error(priv->pdev, dma_addr))\r\nreturn -ENOMEM;\r\niowrite32(dma_addr, regs + MWL8K_HIU_GEN_PTR);\r\niowrite32(0, regs + MWL8K_HIU_INT_CODE);\r\niowrite32(MWL8K_H2A_INT_DOORBELL,\r\nregs + MWL8K_HIU_H2A_INTERRUPT_EVENTS);\r\niowrite32(MWL8K_H2A_INT_DUMMY,\r\nregs + MWL8K_HIU_H2A_INTERRUPT_EVENTS);\r\nloops = 1000;\r\ndo {\r\nu32 int_code;\r\nif (priv->is_8764) {\r\nint_code = ioread32(regs +\r\nMWL8K_HIU_H2A_INTERRUPT_STATUS);\r\nif (int_code == 0)\r\nbreak;\r\n} else {\r\nint_code = ioread32(regs + MWL8K_HIU_INT_CODE);\r\nif (int_code == MWL8K_INT_CODE_CMD_FINISHED) {\r\niowrite32(0, regs + MWL8K_HIU_INT_CODE);\r\nbreak;\r\n}\r\n}\r\ncond_resched();\r\nudelay(1);\r\n} while (--loops);\r\npci_unmap_single(priv->pdev, dma_addr, length, PCI_DMA_TODEVICE);\r\nreturn loops ? 0 : -ETIMEDOUT;\r\n}\r\nstatic int mwl8k_load_fw_image(struct mwl8k_priv *priv,\r\nconst u8 *data, size_t length)\r\n{\r\nstruct mwl8k_cmd_pkt *cmd;\r\nint done;\r\nint rc = 0;\r\ncmd = kmalloc(sizeof(*cmd) + 256, GFP_KERNEL);\r\nif (cmd == NULL)\r\nreturn -ENOMEM;\r\ncmd->code = cpu_to_le16(MWL8K_CMD_CODE_DNLD);\r\ncmd->seq_num = 0;\r\ncmd->macid = 0;\r\ncmd->result = 0;\r\ndone = 0;\r\nwhile (length) {\r\nint block_size = length > 256 ? 256 : length;\r\nmemcpy(cmd->payload, data + done, block_size);\r\ncmd->length = cpu_to_le16(block_size);\r\nrc = mwl8k_send_fw_load_cmd(priv, cmd,\r\nsizeof(*cmd) + block_size);\r\nif (rc)\r\nbreak;\r\ndone += block_size;\r\nlength -= block_size;\r\n}\r\nif (!rc) {\r\ncmd->length = 0;\r\nrc = mwl8k_send_fw_load_cmd(priv, cmd, sizeof(*cmd));\r\n}\r\nkfree(cmd);\r\nreturn rc;\r\n}\r\nstatic int mwl8k_feed_fw_image(struct mwl8k_priv *priv,\r\nconst u8 *data, size_t length)\r\n{\r\nunsigned char *buffer;\r\nint may_continue, rc = 0;\r\nu32 done, prev_block_size;\r\nbuffer = kmalloc(1024, GFP_KERNEL);\r\nif (buffer == NULL)\r\nreturn -ENOMEM;\r\ndone = 0;\r\nprev_block_size = 0;\r\nmay_continue = 1000;\r\nwhile (may_continue > 0) {\r\nu32 block_size;\r\nblock_size = ioread32(priv->regs + MWL8K_HIU_SCRATCH);\r\nif (block_size & 1) {\r\nblock_size &= ~1;\r\nmay_continue--;\r\n} else {\r\ndone += prev_block_size;\r\nlength -= prev_block_size;\r\n}\r\nif (block_size > 1024 || block_size > length) {\r\nrc = -EOVERFLOW;\r\nbreak;\r\n}\r\nif (length == 0) {\r\nrc = 0;\r\nbreak;\r\n}\r\nif (block_size == 0) {\r\nrc = -EPROTO;\r\nmay_continue--;\r\nudelay(1);\r\ncontinue;\r\n}\r\nprev_block_size = block_size;\r\nmemcpy(buffer, data + done, block_size);\r\nrc = mwl8k_send_fw_load_cmd(priv, buffer, block_size);\r\nif (rc)\r\nbreak;\r\n}\r\nif (!rc && length != 0)\r\nrc = -EREMOTEIO;\r\nkfree(buffer);\r\nreturn rc;\r\n}\r\nstatic int mwl8k_load_firmware(struct ieee80211_hw *hw)\r\n{\r\nstruct mwl8k_priv *priv = hw->priv;\r\nconst struct firmware *fw = priv->fw_ucode;\r\nint rc;\r\nint loops;\r\nif (!memcmp(fw->data, "\x01\x00\x00\x00", 4) && !priv->is_8764) {\r\nconst struct firmware *helper = priv->fw_helper;\r\nif (helper == NULL) {\r\nprintk(KERN_ERR "%s: helper image needed but none "\r\n"given\n", pci_name(priv->pdev));\r\nreturn -EINVAL;\r\n}\r\nrc = mwl8k_load_fw_image(priv, helper->data, helper->size);\r\nif (rc) {\r\nprintk(KERN_ERR "%s: unable to load firmware "\r\n"helper image\n", pci_name(priv->pdev));\r\nreturn rc;\r\n}\r\nmsleep(20);\r\nrc = mwl8k_feed_fw_image(priv, fw->data, fw->size);\r\n} else {\r\nif (priv->is_8764)\r\nrc = mwl8k_feed_fw_image(priv, fw->data, fw->size);\r\nelse\r\nrc = mwl8k_load_fw_image(priv, fw->data, fw->size);\r\n}\r\nif (rc) {\r\nprintk(KERN_ERR "%s: unable to load firmware image\n",\r\npci_name(priv->pdev));\r\nreturn rc;\r\n}\r\niowrite32(MWL8K_MODE_STA, priv->regs + MWL8K_HIU_GEN_PTR);\r\nloops = 500000;\r\ndo {\r\nu32 ready_code;\r\nready_code = ioread32(priv->regs + MWL8K_HIU_INT_CODE);\r\nif (ready_code == MWL8K_FWAP_READY) {\r\npriv->ap_fw = true;\r\nbreak;\r\n} else if (ready_code == MWL8K_FWSTA_READY) {\r\npriv->ap_fw = false;\r\nbreak;\r\n}\r\ncond_resched();\r\nudelay(1);\r\n} while (--loops);\r\nreturn loops ? 0 : -ETIMEDOUT;\r\n}\r\nstatic inline void mwl8k_remove_dma_header(struct sk_buff *skb, __le16 qos)\r\n{\r\nstruct mwl8k_dma_data *tr;\r\nint hdrlen;\r\ntr = (struct mwl8k_dma_data *)skb->data;\r\nhdrlen = ieee80211_hdrlen(tr->wh.frame_control);\r\nif (hdrlen != sizeof(tr->wh)) {\r\nif (ieee80211_is_data_qos(tr->wh.frame_control)) {\r\nmemmove(tr->data - hdrlen, &tr->wh, hdrlen - 2);\r\n*((__le16 *)(tr->data - 2)) = qos;\r\n} else {\r\nmemmove(tr->data - hdrlen, &tr->wh, hdrlen);\r\n}\r\n}\r\nif (hdrlen != sizeof(*tr))\r\nskb_pull(skb, sizeof(*tr) - hdrlen);\r\n}\r\nstatic void\r\nmwl8k_add_dma_header(struct mwl8k_priv *priv, struct sk_buff *skb,\r\nint head_pad, int tail_pad)\r\n{\r\nstruct ieee80211_hdr *wh;\r\nint hdrlen;\r\nint reqd_hdrlen;\r\nstruct mwl8k_dma_data *tr;\r\nwh = (struct ieee80211_hdr *)skb->data;\r\nhdrlen = ieee80211_hdrlen(wh->frame_control);\r\nif (priv->ap_fw && (hdrlen < (sizeof(struct ieee80211_cts)\r\n+ REDUCED_TX_HEADROOM))) {\r\nif (pskb_expand_head(skb, REDUCED_TX_HEADROOM, 0, GFP_ATOMIC)) {\r\nwiphy_err(priv->hw->wiphy,\r\n"Failed to reallocate TX buffer\n");\r\nreturn;\r\n}\r\nskb->truesize += REDUCED_TX_HEADROOM;\r\n}\r\nreqd_hdrlen = sizeof(*tr) + head_pad;\r\nif (hdrlen != reqd_hdrlen)\r\nskb_push(skb, reqd_hdrlen - hdrlen);\r\nif (ieee80211_is_data_qos(wh->frame_control))\r\nhdrlen -= IEEE80211_QOS_CTL_LEN;\r\ntr = (struct mwl8k_dma_data *)skb->data;\r\nif (wh != &tr->wh)\r\nmemmove(&tr->wh, wh, hdrlen);\r\nif (hdrlen != sizeof(tr->wh))\r\nmemset(((void *)&tr->wh) + hdrlen, 0, sizeof(tr->wh) - hdrlen);\r\ntr->fwlen = cpu_to_le16(skb->len - sizeof(*tr) + tail_pad);\r\n}\r\nstatic void mwl8k_encapsulate_tx_frame(struct mwl8k_priv *priv,\r\nstruct sk_buff *skb)\r\n{\r\nstruct ieee80211_hdr *wh;\r\nstruct ieee80211_tx_info *tx_info;\r\nstruct ieee80211_key_conf *key_conf;\r\nint data_pad;\r\nint head_pad = 0;\r\nwh = (struct ieee80211_hdr *)skb->data;\r\ntx_info = IEEE80211_SKB_CB(skb);\r\nkey_conf = NULL;\r\nif (ieee80211_is_data(wh->frame_control))\r\nkey_conf = tx_info->control.hw_key;\r\ndata_pad = 0;\r\nif (key_conf != NULL) {\r\nhead_pad = key_conf->iv_len;\r\nswitch (key_conf->cipher) {\r\ncase WLAN_CIPHER_SUITE_WEP40:\r\ncase WLAN_CIPHER_SUITE_WEP104:\r\ndata_pad = 4;\r\nbreak;\r\ncase WLAN_CIPHER_SUITE_TKIP:\r\ndata_pad = 12;\r\nbreak;\r\ncase WLAN_CIPHER_SUITE_CCMP:\r\ndata_pad = 8;\r\nbreak;\r\n}\r\n}\r\nmwl8k_add_dma_header(priv, skb, head_pad, data_pad);\r\n}\r\nstatic void mwl8k_rxd_ap_init(void *_rxd, dma_addr_t next_dma_addr)\r\n{\r\nstruct mwl8k_rxd_ap *rxd = _rxd;\r\nrxd->next_rxd_phys_addr = cpu_to_le32(next_dma_addr);\r\nrxd->rx_ctrl = MWL8K_AP_RX_CTRL_OWNED_BY_HOST;\r\n}\r\nstatic void mwl8k_rxd_ap_refill(void *_rxd, dma_addr_t addr, int len)\r\n{\r\nstruct mwl8k_rxd_ap *rxd = _rxd;\r\nrxd->pkt_len = cpu_to_le16(len);\r\nrxd->pkt_phys_addr = cpu_to_le32(addr);\r\nwmb();\r\nrxd->rx_ctrl = 0;\r\n}\r\nstatic int\r\nmwl8k_rxd_ap_process(void *_rxd, struct ieee80211_rx_status *status,\r\n__le16 *qos, s8 *noise)\r\n{\r\nstruct mwl8k_rxd_ap *rxd = _rxd;\r\nif (!(rxd->rx_ctrl & MWL8K_AP_RX_CTRL_OWNED_BY_HOST))\r\nreturn -1;\r\nrmb();\r\nmemset(status, 0, sizeof(*status));\r\nstatus->signal = -rxd->rssi;\r\n*noise = -rxd->noise_floor;\r\nif (rxd->rate & MWL8K_AP_RATE_INFO_MCS_FORMAT) {\r\nstatus->flag |= RX_FLAG_HT;\r\nif (rxd->rate & MWL8K_AP_RATE_INFO_40MHZ)\r\nstatus->flag |= RX_FLAG_40MHZ;\r\nstatus->rate_idx = MWL8K_AP_RATE_INFO_RATEID(rxd->rate);\r\n} else {\r\nint i;\r\nfor (i = 0; i < ARRAY_SIZE(mwl8k_rates_24); i++) {\r\nif (mwl8k_rates_24[i].hw_value == rxd->rate) {\r\nstatus->rate_idx = i;\r\nbreak;\r\n}\r\n}\r\n}\r\nif (rxd->channel > 14) {\r\nstatus->band = IEEE80211_BAND_5GHZ;\r\nif (!(status->flag & RX_FLAG_HT))\r\nstatus->rate_idx -= 5;\r\n} else {\r\nstatus->band = IEEE80211_BAND_2GHZ;\r\n}\r\nstatus->freq = ieee80211_channel_to_frequency(rxd->channel,\r\nstatus->band);\r\n*qos = rxd->qos_control;\r\nif ((rxd->rx_status != MWL8K_AP_RXSTAT_GENERAL_DECRYPT_ERR) &&\r\n(rxd->rx_status & MWL8K_AP_RXSTAT_DECRYPT_ERR_MASK) &&\r\n(rxd->rx_status & MWL8K_AP_RXSTAT_TKIP_DECRYPT_MIC_ERR))\r\nstatus->flag |= RX_FLAG_MMIC_ERROR;\r\nreturn le16_to_cpu(rxd->pkt_len);\r\n}\r\nstatic void mwl8k_rxd_sta_init(void *_rxd, dma_addr_t next_dma_addr)\r\n{\r\nstruct mwl8k_rxd_sta *rxd = _rxd;\r\nrxd->next_rxd_phys_addr = cpu_to_le32(next_dma_addr);\r\nrxd->rx_ctrl = MWL8K_STA_RX_CTRL_OWNED_BY_HOST;\r\n}\r\nstatic void mwl8k_rxd_sta_refill(void *_rxd, dma_addr_t addr, int len)\r\n{\r\nstruct mwl8k_rxd_sta *rxd = _rxd;\r\nrxd->pkt_len = cpu_to_le16(len);\r\nrxd->pkt_phys_addr = cpu_to_le32(addr);\r\nwmb();\r\nrxd->rx_ctrl = 0;\r\n}\r\nstatic int\r\nmwl8k_rxd_sta_process(void *_rxd, struct ieee80211_rx_status *status,\r\n__le16 *qos, s8 *noise)\r\n{\r\nstruct mwl8k_rxd_sta *rxd = _rxd;\r\nu16 rate_info;\r\nif (!(rxd->rx_ctrl & MWL8K_STA_RX_CTRL_OWNED_BY_HOST))\r\nreturn -1;\r\nrmb();\r\nrate_info = le16_to_cpu(rxd->rate_info);\r\nmemset(status, 0, sizeof(*status));\r\nstatus->signal = -rxd->rssi;\r\n*noise = -rxd->noise_level;\r\nstatus->antenna = MWL8K_STA_RATE_INFO_ANTSELECT(rate_info);\r\nstatus->rate_idx = MWL8K_STA_RATE_INFO_RATEID(rate_info);\r\nif (rate_info & MWL8K_STA_RATE_INFO_SHORTPRE)\r\nstatus->flag |= RX_FLAG_SHORTPRE;\r\nif (rate_info & MWL8K_STA_RATE_INFO_40MHZ)\r\nstatus->flag |= RX_FLAG_40MHZ;\r\nif (rate_info & MWL8K_STA_RATE_INFO_SHORTGI)\r\nstatus->flag |= RX_FLAG_SHORT_GI;\r\nif (rate_info & MWL8K_STA_RATE_INFO_MCS_FORMAT)\r\nstatus->flag |= RX_FLAG_HT;\r\nif (rxd->channel > 14) {\r\nstatus->band = IEEE80211_BAND_5GHZ;\r\nif (!(status->flag & RX_FLAG_HT))\r\nstatus->rate_idx -= 5;\r\n} else {\r\nstatus->band = IEEE80211_BAND_2GHZ;\r\n}\r\nstatus->freq = ieee80211_channel_to_frequency(rxd->channel,\r\nstatus->band);\r\n*qos = rxd->qos_control;\r\nif ((rxd->rx_ctrl & MWL8K_STA_RX_CTRL_DECRYPT_ERROR) &&\r\n(rxd->rx_ctrl & MWL8K_STA_RX_CTRL_DEC_ERR_TYPE))\r\nstatus->flag |= RX_FLAG_MMIC_ERROR;\r\nreturn le16_to_cpu(rxd->pkt_len);\r\n}\r\nstatic int mwl8k_rxq_init(struct ieee80211_hw *hw, int index)\r\n{\r\nstruct mwl8k_priv *priv = hw->priv;\r\nstruct mwl8k_rx_queue *rxq = priv->rxq + index;\r\nint size;\r\nint i;\r\nrxq->rxd_count = 0;\r\nrxq->head = 0;\r\nrxq->tail = 0;\r\nsize = MWL8K_RX_DESCS * priv->rxd_ops->rxd_size;\r\nrxq->rxd = pci_zalloc_consistent(priv->pdev, size, &rxq->rxd_dma);\r\nif (rxq->rxd == NULL) {\r\nwiphy_err(hw->wiphy, "failed to alloc RX descriptors\n");\r\nreturn -ENOMEM;\r\n}\r\nrxq->buf = kcalloc(MWL8K_RX_DESCS, sizeof(*rxq->buf), GFP_KERNEL);\r\nif (rxq->buf == NULL) {\r\npci_free_consistent(priv->pdev, size, rxq->rxd, rxq->rxd_dma);\r\nreturn -ENOMEM;\r\n}\r\nfor (i = 0; i < MWL8K_RX_DESCS; i++) {\r\nint desc_size;\r\nvoid *rxd;\r\nint nexti;\r\ndma_addr_t next_dma_addr;\r\ndesc_size = priv->rxd_ops->rxd_size;\r\nrxd = rxq->rxd + (i * priv->rxd_ops->rxd_size);\r\nnexti = i + 1;\r\nif (nexti == MWL8K_RX_DESCS)\r\nnexti = 0;\r\nnext_dma_addr = rxq->rxd_dma + (nexti * desc_size);\r\npriv->rxd_ops->rxd_init(rxd, next_dma_addr);\r\n}\r\nreturn 0;\r\n}\r\nstatic int rxq_refill(struct ieee80211_hw *hw, int index, int limit)\r\n{\r\nstruct mwl8k_priv *priv = hw->priv;\r\nstruct mwl8k_rx_queue *rxq = priv->rxq + index;\r\nint refilled;\r\nrefilled = 0;\r\nwhile (rxq->rxd_count < MWL8K_RX_DESCS && limit--) {\r\nstruct sk_buff *skb;\r\ndma_addr_t addr;\r\nint rx;\r\nvoid *rxd;\r\nskb = dev_alloc_skb(MWL8K_RX_MAXSZ);\r\nif (skb == NULL)\r\nbreak;\r\naddr = pci_map_single(priv->pdev, skb->data,\r\nMWL8K_RX_MAXSZ, DMA_FROM_DEVICE);\r\nrxq->rxd_count++;\r\nrx = rxq->tail++;\r\nif (rxq->tail == MWL8K_RX_DESCS)\r\nrxq->tail = 0;\r\nrxq->buf[rx].skb = skb;\r\ndma_unmap_addr_set(&rxq->buf[rx], dma, addr);\r\nrxd = rxq->rxd + (rx * priv->rxd_ops->rxd_size);\r\npriv->rxd_ops->rxd_refill(rxd, addr, MWL8K_RX_MAXSZ);\r\nrefilled++;\r\n}\r\nreturn refilled;\r\n}\r\nstatic void mwl8k_rxq_deinit(struct ieee80211_hw *hw, int index)\r\n{\r\nstruct mwl8k_priv *priv = hw->priv;\r\nstruct mwl8k_rx_queue *rxq = priv->rxq + index;\r\nint i;\r\nif (rxq->rxd == NULL)\r\nreturn;\r\nfor (i = 0; i < MWL8K_RX_DESCS; i++) {\r\nif (rxq->buf[i].skb != NULL) {\r\npci_unmap_single(priv->pdev,\r\ndma_unmap_addr(&rxq->buf[i], dma),\r\nMWL8K_RX_MAXSZ, PCI_DMA_FROMDEVICE);\r\ndma_unmap_addr_set(&rxq->buf[i], dma, 0);\r\nkfree_skb(rxq->buf[i].skb);\r\nrxq->buf[i].skb = NULL;\r\n}\r\n}\r\nkfree(rxq->buf);\r\nrxq->buf = NULL;\r\npci_free_consistent(priv->pdev,\r\nMWL8K_RX_DESCS * priv->rxd_ops->rxd_size,\r\nrxq->rxd, rxq->rxd_dma);\r\nrxq->rxd = NULL;\r\n}\r\nstatic inline int\r\nmwl8k_capture_bssid(struct mwl8k_priv *priv, struct ieee80211_hdr *wh)\r\n{\r\nreturn priv->capture_beacon &&\r\nieee80211_is_beacon(wh->frame_control) &&\r\nether_addr_equal_64bits(wh->addr3, priv->capture_bssid);\r\n}\r\nstatic inline void mwl8k_save_beacon(struct ieee80211_hw *hw,\r\nstruct sk_buff *skb)\r\n{\r\nstruct mwl8k_priv *priv = hw->priv;\r\npriv->capture_beacon = false;\r\neth_zero_addr(priv->capture_bssid);\r\npriv->beacon_skb = skb_copy(skb, GFP_ATOMIC);\r\nif (priv->beacon_skb != NULL)\r\nieee80211_queue_work(hw, &priv->finalize_join_worker);\r\n}\r\nstatic inline struct mwl8k_vif *mwl8k_find_vif_bss(struct list_head *vif_list,\r\nu8 *bssid)\r\n{\r\nstruct mwl8k_vif *mwl8k_vif;\r\nlist_for_each_entry(mwl8k_vif,\r\nvif_list, list) {\r\nif (memcmp(bssid, mwl8k_vif->bssid,\r\nETH_ALEN) == 0)\r\nreturn mwl8k_vif;\r\n}\r\nreturn NULL;\r\n}\r\nstatic int rxq_process(struct ieee80211_hw *hw, int index, int limit)\r\n{\r\nstruct mwl8k_priv *priv = hw->priv;\r\nstruct mwl8k_vif *mwl8k_vif = NULL;\r\nstruct mwl8k_rx_queue *rxq = priv->rxq + index;\r\nint processed;\r\nprocessed = 0;\r\nwhile (rxq->rxd_count && limit--) {\r\nstruct sk_buff *skb;\r\nvoid *rxd;\r\nint pkt_len;\r\nstruct ieee80211_rx_status status;\r\nstruct ieee80211_hdr *wh;\r\n__le16 qos;\r\nskb = rxq->buf[rxq->head].skb;\r\nif (skb == NULL)\r\nbreak;\r\nrxd = rxq->rxd + (rxq->head * priv->rxd_ops->rxd_size);\r\npkt_len = priv->rxd_ops->rxd_process(rxd, &status, &qos,\r\n&priv->noise);\r\nif (pkt_len < 0)\r\nbreak;\r\nrxq->buf[rxq->head].skb = NULL;\r\npci_unmap_single(priv->pdev,\r\ndma_unmap_addr(&rxq->buf[rxq->head], dma),\r\nMWL8K_RX_MAXSZ, PCI_DMA_FROMDEVICE);\r\ndma_unmap_addr_set(&rxq->buf[rxq->head], dma, 0);\r\nrxq->head++;\r\nif (rxq->head == MWL8K_RX_DESCS)\r\nrxq->head = 0;\r\nrxq->rxd_count--;\r\nwh = &((struct mwl8k_dma_data *)skb->data)->wh;\r\nif (mwl8k_capture_bssid(priv, (void *)skb->data))\r\nmwl8k_save_beacon(hw, skb);\r\nif (ieee80211_has_protected(wh->frame_control)) {\r\nmwl8k_vif = mwl8k_find_vif_bss(&priv->vif_list,\r\nwh->addr1);\r\nif (mwl8k_vif != NULL &&\r\nmwl8k_vif->is_hw_crypto_enabled) {\r\nif (status.flag & RX_FLAG_MMIC_ERROR) {\r\nstruct mwl8k_dma_data *tr;\r\ntr = (struct mwl8k_dma_data *)skb->data;\r\nmemset((void *)&(tr->data), 0, 4);\r\npkt_len += 4;\r\n}\r\nif (!ieee80211_is_auth(wh->frame_control))\r\nstatus.flag |= RX_FLAG_IV_STRIPPED |\r\nRX_FLAG_DECRYPTED |\r\nRX_FLAG_MMIC_STRIPPED;\r\n}\r\n}\r\nskb_put(skb, pkt_len);\r\nmwl8k_remove_dma_header(skb, qos);\r\nmemcpy(IEEE80211_SKB_RXCB(skb), &status, sizeof(status));\r\nieee80211_rx_irqsafe(hw, skb);\r\nprocessed++;\r\n}\r\nreturn processed;\r\n}\r\nstatic int mwl8k_txq_init(struct ieee80211_hw *hw, int index)\r\n{\r\nstruct mwl8k_priv *priv = hw->priv;\r\nstruct mwl8k_tx_queue *txq = priv->txq + index;\r\nint size;\r\nint i;\r\ntxq->len = 0;\r\ntxq->head = 0;\r\ntxq->tail = 0;\r\nsize = MWL8K_TX_DESCS * sizeof(struct mwl8k_tx_desc);\r\ntxq->txd = pci_zalloc_consistent(priv->pdev, size, &txq->txd_dma);\r\nif (txq->txd == NULL) {\r\nwiphy_err(hw->wiphy, "failed to alloc TX descriptors\n");\r\nreturn -ENOMEM;\r\n}\r\ntxq->skb = kcalloc(MWL8K_TX_DESCS, sizeof(*txq->skb), GFP_KERNEL);\r\nif (txq->skb == NULL) {\r\npci_free_consistent(priv->pdev, size, txq->txd, txq->txd_dma);\r\nreturn -ENOMEM;\r\n}\r\nfor (i = 0; i < MWL8K_TX_DESCS; i++) {\r\nstruct mwl8k_tx_desc *tx_desc;\r\nint nexti;\r\ntx_desc = txq->txd + i;\r\nnexti = (i + 1) % MWL8K_TX_DESCS;\r\ntx_desc->status = 0;\r\ntx_desc->next_txd_phys_addr =\r\ncpu_to_le32(txq->txd_dma + nexti * sizeof(*tx_desc));\r\n}\r\nreturn 0;\r\n}\r\nstatic inline void mwl8k_tx_start(struct mwl8k_priv *priv)\r\n{\r\niowrite32(MWL8K_H2A_INT_PPA_READY,\r\npriv->regs + MWL8K_HIU_H2A_INTERRUPT_EVENTS);\r\niowrite32(MWL8K_H2A_INT_DUMMY,\r\npriv->regs + MWL8K_HIU_H2A_INTERRUPT_EVENTS);\r\nioread32(priv->regs + MWL8K_HIU_INT_CODE);\r\n}\r\nstatic void mwl8k_dump_tx_rings(struct ieee80211_hw *hw)\r\n{\r\nstruct mwl8k_priv *priv = hw->priv;\r\nint i;\r\nfor (i = 0; i < mwl8k_tx_queues(priv); i++) {\r\nstruct mwl8k_tx_queue *txq = priv->txq + i;\r\nint fw_owned = 0;\r\nint drv_owned = 0;\r\nint unused = 0;\r\nint desc;\r\nfor (desc = 0; desc < MWL8K_TX_DESCS; desc++) {\r\nstruct mwl8k_tx_desc *tx_desc = txq->txd + desc;\r\nu32 status;\r\nstatus = le32_to_cpu(tx_desc->status);\r\nif (status & MWL8K_TXD_STATUS_FW_OWNED)\r\nfw_owned++;\r\nelse\r\ndrv_owned++;\r\nif (tx_desc->pkt_len == 0)\r\nunused++;\r\n}\r\nwiphy_err(hw->wiphy,\r\n"txq[%d] len=%d head=%d tail=%d "\r\n"fw_owned=%d drv_owned=%d unused=%d\n",\r\ni,\r\ntxq->len, txq->head, txq->tail,\r\nfw_owned, drv_owned, unused);\r\n}\r\n}\r\nstatic int mwl8k_tx_wait_empty(struct ieee80211_hw *hw)\r\n{\r\nstruct mwl8k_priv *priv = hw->priv;\r\nDECLARE_COMPLETION_ONSTACK(tx_wait);\r\nint retry;\r\nint rc;\r\nmight_sleep();\r\nif (priv->hw_restart_in_progress) {\r\nif (priv->hw_restart_owner == current)\r\nreturn 0;\r\nelse\r\nreturn -EBUSY;\r\n}\r\nif (atomic_read(&priv->watchdog_event_pending))\r\nreturn 0;\r\nif (!priv->pending_tx_pkts)\r\nreturn 0;\r\nretry = 1;\r\nrc = 0;\r\nspin_lock_bh(&priv->tx_lock);\r\npriv->tx_wait = &tx_wait;\r\nwhile (!rc) {\r\nint oldcount;\r\nunsigned long timeout;\r\noldcount = priv->pending_tx_pkts;\r\nspin_unlock_bh(&priv->tx_lock);\r\ntimeout = wait_for_completion_timeout(&tx_wait,\r\nmsecs_to_jiffies(MWL8K_TX_WAIT_TIMEOUT_MS));\r\nif (atomic_read(&priv->watchdog_event_pending)) {\r\nspin_lock_bh(&priv->tx_lock);\r\npriv->tx_wait = NULL;\r\nspin_unlock_bh(&priv->tx_lock);\r\nreturn 0;\r\n}\r\nspin_lock_bh(&priv->tx_lock);\r\nif (timeout || !priv->pending_tx_pkts) {\r\nWARN_ON(priv->pending_tx_pkts);\r\nif (retry)\r\nwiphy_notice(hw->wiphy, "tx rings drained\n");\r\nbreak;\r\n}\r\nif (retry) {\r\nmwl8k_tx_start(priv);\r\nretry = 0;\r\ncontinue;\r\n}\r\nif (priv->pending_tx_pkts < oldcount) {\r\nwiphy_notice(hw->wiphy,\r\n"waiting for tx rings to drain (%d -> %d pkts)\n",\r\noldcount, priv->pending_tx_pkts);\r\nretry = 1;\r\ncontinue;\r\n}\r\npriv->tx_wait = NULL;\r\nwiphy_err(hw->wiphy, "tx rings stuck for %d ms\n",\r\nMWL8K_TX_WAIT_TIMEOUT_MS);\r\nmwl8k_dump_tx_rings(hw);\r\npriv->hw_restart_in_progress = true;\r\nieee80211_queue_work(hw, &priv->fw_reload);\r\nrc = -ETIMEDOUT;\r\n}\r\npriv->tx_wait = NULL;\r\nspin_unlock_bh(&priv->tx_lock);\r\nreturn rc;\r\n}\r\nstatic int mwl8k_tid_queue_mapping(u8 tid)\r\n{\r\nBUG_ON(tid > 7);\r\nswitch (tid) {\r\ncase 0:\r\ncase 3:\r\nreturn IEEE80211_AC_BE;\r\ncase 1:\r\ncase 2:\r\nreturn IEEE80211_AC_BK;\r\ncase 4:\r\ncase 5:\r\nreturn IEEE80211_AC_VI;\r\ncase 6:\r\ncase 7:\r\nreturn IEEE80211_AC_VO;\r\ndefault:\r\nreturn -1;\r\n}\r\n}\r\nstatic int\r\nmwl8k_txq_reclaim(struct ieee80211_hw *hw, int index, int limit, int force)\r\n{\r\nstruct mwl8k_priv *priv = hw->priv;\r\nstruct mwl8k_tx_queue *txq = priv->txq + index;\r\nint processed;\r\nprocessed = 0;\r\nwhile (txq->len > 0 && limit--) {\r\nint tx;\r\nstruct mwl8k_tx_desc *tx_desc;\r\nunsigned long addr;\r\nint size;\r\nstruct sk_buff *skb;\r\nstruct ieee80211_tx_info *info;\r\nu32 status;\r\nstruct ieee80211_sta *sta;\r\nstruct mwl8k_sta *sta_info = NULL;\r\nu16 rate_info;\r\nstruct ieee80211_hdr *wh;\r\ntx = txq->head;\r\ntx_desc = txq->txd + tx;\r\nstatus = le32_to_cpu(tx_desc->status);\r\nif (status & MWL8K_TXD_STATUS_FW_OWNED) {\r\nif (!force)\r\nbreak;\r\ntx_desc->status &=\r\n~cpu_to_le32(MWL8K_TXD_STATUS_FW_OWNED);\r\n}\r\ntxq->head = (tx + 1) % MWL8K_TX_DESCS;\r\nBUG_ON(txq->len == 0);\r\ntxq->len--;\r\npriv->pending_tx_pkts--;\r\naddr = le32_to_cpu(tx_desc->pkt_phys_addr);\r\nsize = le16_to_cpu(tx_desc->pkt_len);\r\nskb = txq->skb[tx];\r\ntxq->skb[tx] = NULL;\r\nBUG_ON(skb == NULL);\r\npci_unmap_single(priv->pdev, addr, size, PCI_DMA_TODEVICE);\r\nmwl8k_remove_dma_header(skb, tx_desc->qos_control);\r\nwh = (struct ieee80211_hdr *) skb->data;\r\ntx_desc->pkt_phys_addr = 0;\r\ntx_desc->pkt_len = 0;\r\ninfo = IEEE80211_SKB_CB(skb);\r\nif (ieee80211_is_data(wh->frame_control)) {\r\nrcu_read_lock();\r\nsta = ieee80211_find_sta_by_ifaddr(hw, wh->addr1,\r\nwh->addr2);\r\nif (sta) {\r\nsta_info = MWL8K_STA(sta);\r\nBUG_ON(sta_info == NULL);\r\nrate_info = le16_to_cpu(tx_desc->rate_info);\r\nif (RI_RATE_ID_MCS(rate_info) < 1 ||\r\nRI_FORMAT(rate_info) == 0) {\r\nsta_info->is_ampdu_allowed = false;\r\n} else {\r\nsta_info->is_ampdu_allowed = true;\r\n}\r\n}\r\nrcu_read_unlock();\r\n}\r\nieee80211_tx_info_clear_status(info);\r\ninfo->status.rates[0].idx = -1;\r\ninfo->status.rates[0].count = 1;\r\nif (MWL8K_TXD_SUCCESS(status))\r\ninfo->flags |= IEEE80211_TX_STAT_ACK;\r\nieee80211_tx_status_irqsafe(hw, skb);\r\nprocessed++;\r\n}\r\nreturn processed;\r\n}\r\nstatic void mwl8k_txq_deinit(struct ieee80211_hw *hw, int index)\r\n{\r\nstruct mwl8k_priv *priv = hw->priv;\r\nstruct mwl8k_tx_queue *txq = priv->txq + index;\r\nif (txq->txd == NULL)\r\nreturn;\r\nmwl8k_txq_reclaim(hw, index, INT_MAX, 1);\r\nkfree(txq->skb);\r\ntxq->skb = NULL;\r\npci_free_consistent(priv->pdev,\r\nMWL8K_TX_DESCS * sizeof(struct mwl8k_tx_desc),\r\ntxq->txd, txq->txd_dma);\r\ntxq->txd = NULL;\r\n}\r\nstatic struct mwl8k_ampdu_stream *\r\nmwl8k_add_stream(struct ieee80211_hw *hw, struct ieee80211_sta *sta, u8 tid)\r\n{\r\nstruct mwl8k_ampdu_stream *stream;\r\nstruct mwl8k_priv *priv = hw->priv;\r\nint i;\r\nfor (i = 0; i < MWL8K_NUM_AMPDU_STREAMS; i++) {\r\nstream = &priv->ampdu[i];\r\nif (stream->state == AMPDU_NO_STREAM) {\r\nstream->sta = sta;\r\nstream->state = AMPDU_STREAM_NEW;\r\nstream->tid = tid;\r\nstream->idx = i;\r\nwiphy_debug(hw->wiphy, "Added a new stream for %pM %d",\r\nsta->addr, tid);\r\nreturn stream;\r\n}\r\n}\r\nreturn NULL;\r\n}\r\nstatic int\r\nmwl8k_start_stream(struct ieee80211_hw *hw, struct mwl8k_ampdu_stream *stream)\r\n{\r\nint ret;\r\nif (stream->state != AMPDU_STREAM_NEW)\r\nreturn 0;\r\nret = ieee80211_start_tx_ba_session(stream->sta, stream->tid, 0);\r\nif (ret)\r\nwiphy_debug(hw->wiphy, "Failed to start stream for %pM %d: "\r\n"%d\n", stream->sta->addr, stream->tid, ret);\r\nelse\r\nwiphy_debug(hw->wiphy, "Started stream for %pM %d\n",\r\nstream->sta->addr, stream->tid);\r\nreturn ret;\r\n}\r\nstatic void\r\nmwl8k_remove_stream(struct ieee80211_hw *hw, struct mwl8k_ampdu_stream *stream)\r\n{\r\nwiphy_debug(hw->wiphy, "Remove stream for %pM %d\n", stream->sta->addr,\r\nstream->tid);\r\nmemset(stream, 0, sizeof(*stream));\r\n}\r\nstatic struct mwl8k_ampdu_stream *\r\nmwl8k_lookup_stream(struct ieee80211_hw *hw, u8 *addr, u8 tid)\r\n{\r\nstruct mwl8k_priv *priv = hw->priv;\r\nint i;\r\nfor (i = 0; i < MWL8K_NUM_AMPDU_STREAMS; i++) {\r\nstruct mwl8k_ampdu_stream *stream;\r\nstream = &priv->ampdu[i];\r\nif (stream->state == AMPDU_NO_STREAM)\r\ncontinue;\r\nif (!memcmp(stream->sta->addr, addr, ETH_ALEN) &&\r\nstream->tid == tid)\r\nreturn stream;\r\n}\r\nreturn NULL;\r\n}\r\nstatic inline bool mwl8k_ampdu_allowed(struct ieee80211_sta *sta, u8 tid)\r\n{\r\nstruct mwl8k_sta *sta_info = MWL8K_STA(sta);\r\nstruct tx_traffic_info *tx_stats;\r\nBUG_ON(tid >= MWL8K_MAX_TID);\r\ntx_stats = &sta_info->tx_stats[tid];\r\nreturn sta_info->is_ampdu_allowed &&\r\ntx_stats->pkts > MWL8K_AMPDU_PACKET_THRESHOLD;\r\n}\r\nstatic inline void mwl8k_tx_count_packet(struct ieee80211_sta *sta, u8 tid)\r\n{\r\nstruct mwl8k_sta *sta_info = MWL8K_STA(sta);\r\nstruct tx_traffic_info *tx_stats;\r\nBUG_ON(tid >= MWL8K_MAX_TID);\r\ntx_stats = &sta_info->tx_stats[tid];\r\nif (tx_stats->start_time == 0)\r\ntx_stats->start_time = jiffies;\r\nif (jiffies - tx_stats->start_time > HZ) {\r\ntx_stats->pkts = 0;\r\ntx_stats->start_time = 0;\r\n} else\r\ntx_stats->pkts++;\r\n}\r\nstatic void\r\nmwl8k_txq_xmit(struct ieee80211_hw *hw,\r\nint index,\r\nstruct ieee80211_sta *sta,\r\nstruct sk_buff *skb)\r\n{\r\nstruct mwl8k_priv *priv = hw->priv;\r\nstruct ieee80211_tx_info *tx_info;\r\nstruct mwl8k_vif *mwl8k_vif;\r\nstruct ieee80211_hdr *wh;\r\nstruct mwl8k_tx_queue *txq;\r\nstruct mwl8k_tx_desc *tx;\r\ndma_addr_t dma;\r\nu32 txstatus;\r\nu8 txdatarate;\r\nu16 qos;\r\nint txpriority;\r\nu8 tid = 0;\r\nstruct mwl8k_ampdu_stream *stream = NULL;\r\nbool start_ba_session = false;\r\nbool mgmtframe = false;\r\nstruct ieee80211_mgmt *mgmt = (struct ieee80211_mgmt *)skb->data;\r\nbool eapol_frame = false;\r\nwh = (struct ieee80211_hdr *)skb->data;\r\nif (ieee80211_is_data_qos(wh->frame_control))\r\nqos = le16_to_cpu(*((__le16 *)ieee80211_get_qos_ctl(wh)));\r\nelse\r\nqos = 0;\r\nif (skb->protocol == cpu_to_be16(ETH_P_PAE))\r\neapol_frame = true;\r\nif (ieee80211_is_mgmt(wh->frame_control))\r\nmgmtframe = true;\r\nif (priv->ap_fw)\r\nmwl8k_encapsulate_tx_frame(priv, skb);\r\nelse\r\nmwl8k_add_dma_header(priv, skb, 0, 0);\r\nwh = &((struct mwl8k_dma_data *)skb->data)->wh;\r\ntx_info = IEEE80211_SKB_CB(skb);\r\nmwl8k_vif = MWL8K_VIF(tx_info->control.vif);\r\nif (tx_info->flags & IEEE80211_TX_CTL_ASSIGN_SEQ) {\r\nwh->seq_ctrl &= cpu_to_le16(IEEE80211_SCTL_FRAG);\r\nwh->seq_ctrl |= cpu_to_le16(mwl8k_vif->seqno);\r\nmwl8k_vif->seqno += 0x10;\r\n}\r\ntxstatus = 0;\r\ntxdatarate = 0;\r\nif (ieee80211_is_mgmt(wh->frame_control) ||\r\nieee80211_is_ctl(wh->frame_control)) {\r\ntxdatarate = 0;\r\nqos |= MWL8K_QOS_QLEN_UNSPEC | MWL8K_QOS_EOSP;\r\n} else if (ieee80211_is_data(wh->frame_control)) {\r\ntxdatarate = 1;\r\nif (is_multicast_ether_addr(wh->addr1))\r\ntxstatus |= MWL8K_TXD_STATUS_MULTICAST_TX;\r\nqos &= ~MWL8K_QOS_ACK_POLICY_MASK;\r\nif (tx_info->flags & IEEE80211_TX_CTL_AMPDU)\r\nqos |= MWL8K_QOS_ACK_POLICY_BLOCKACK;\r\nelse\r\nqos |= MWL8K_QOS_ACK_POLICY_NORMAL;\r\n}\r\nif (unlikely(ieee80211_is_action(wh->frame_control) &&\r\nmgmt->u.action.category == WLAN_CATEGORY_BACK &&\r\nmgmt->u.action.u.addba_req.action_code == WLAN_ACTION_ADDBA_REQ &&\r\npriv->ap_fw)) {\r\nu16 capab = le16_to_cpu(mgmt->u.action.u.addba_req.capab);\r\ntid = (capab & IEEE80211_ADDBA_PARAM_TID_MASK) >> 2;\r\nindex = mwl8k_tid_queue_mapping(tid);\r\n}\r\ntxpriority = index;\r\nif (priv->ap_fw && sta && sta->ht_cap.ht_supported && !eapol_frame &&\r\nieee80211_is_data_qos(wh->frame_control)) {\r\ntid = qos & 0xf;\r\nmwl8k_tx_count_packet(sta, tid);\r\nspin_lock(&priv->stream_lock);\r\nstream = mwl8k_lookup_stream(hw, sta->addr, tid);\r\nif (stream != NULL) {\r\nif (stream->state == AMPDU_STREAM_ACTIVE) {\r\nWARN_ON(!(qos & MWL8K_QOS_ACK_POLICY_BLOCKACK));\r\ntxpriority = (BA_QUEUE + stream->idx) %\r\nTOTAL_HW_TX_QUEUES;\r\nif (stream->idx <= 1)\r\nindex = stream->idx +\r\nMWL8K_TX_WMM_QUEUES;\r\n} else if (stream->state == AMPDU_STREAM_NEW) {\r\n} else {\r\nwiphy_warn(hw->wiphy,\r\n"Cannot send packet while ADDBA "\r\n"dialog is underway.\n");\r\nspin_unlock(&priv->stream_lock);\r\ndev_kfree_skb(skb);\r\nreturn;\r\n}\r\n} else {\r\nif (mwl8k_ampdu_allowed(sta, tid)) {\r\nstream = mwl8k_add_stream(hw, sta, tid);\r\nif (stream != NULL)\r\nstart_ba_session = true;\r\n}\r\n}\r\nspin_unlock(&priv->stream_lock);\r\n} else {\r\nqos &= ~MWL8K_QOS_ACK_POLICY_MASK;\r\nqos |= MWL8K_QOS_ACK_POLICY_NORMAL;\r\n}\r\ndma = pci_map_single(priv->pdev, skb->data,\r\nskb->len, PCI_DMA_TODEVICE);\r\nif (pci_dma_mapping_error(priv->pdev, dma)) {\r\nwiphy_debug(hw->wiphy,\r\n"failed to dma map skb, dropping TX frame.\n");\r\nif (start_ba_session) {\r\nspin_lock(&priv->stream_lock);\r\nmwl8k_remove_stream(hw, stream);\r\nspin_unlock(&priv->stream_lock);\r\n}\r\ndev_kfree_skb(skb);\r\nreturn;\r\n}\r\nspin_lock_bh(&priv->tx_lock);\r\ntxq = priv->txq + index;\r\nif (txq->len >= MWL8K_TX_DESCS - 2) {\r\nif (!mgmtframe || txq->len == MWL8K_TX_DESCS) {\r\nif (start_ba_session) {\r\nspin_lock(&priv->stream_lock);\r\nmwl8k_remove_stream(hw, stream);\r\nspin_unlock(&priv->stream_lock);\r\n}\r\nmwl8k_tx_start(priv);\r\nspin_unlock_bh(&priv->tx_lock);\r\npci_unmap_single(priv->pdev, dma, skb->len,\r\nPCI_DMA_TODEVICE);\r\ndev_kfree_skb(skb);\r\nreturn;\r\n}\r\n}\r\nBUG_ON(txq->skb[txq->tail] != NULL);\r\ntxq->skb[txq->tail] = skb;\r\ntx = txq->txd + txq->tail;\r\ntx->data_rate = txdatarate;\r\ntx->tx_priority = txpriority;\r\ntx->qos_control = cpu_to_le16(qos);\r\ntx->pkt_phys_addr = cpu_to_le32(dma);\r\ntx->pkt_len = cpu_to_le16(skb->len);\r\ntx->rate_info = 0;\r\nif (!priv->ap_fw && sta != NULL)\r\ntx->peer_id = MWL8K_STA(sta)->peer_id;\r\nelse\r\ntx->peer_id = 0;\r\nif (priv->ap_fw && ieee80211_is_data(wh->frame_control) && !eapol_frame)\r\ntx->timestamp = cpu_to_le32(ioread32(priv->regs +\r\nMWL8K_HW_TIMER_REGISTER));\r\nelse\r\ntx->timestamp = 0;\r\nwmb();\r\ntx->status = cpu_to_le32(MWL8K_TXD_STATUS_FW_OWNED | txstatus);\r\ntxq->len++;\r\npriv->pending_tx_pkts++;\r\ntxq->tail++;\r\nif (txq->tail == MWL8K_TX_DESCS)\r\ntxq->tail = 0;\r\nmwl8k_tx_start(priv);\r\nspin_unlock_bh(&priv->tx_lock);\r\nif (start_ba_session) {\r\nspin_lock(&priv->stream_lock);\r\nif (mwl8k_start_stream(hw, stream))\r\nmwl8k_remove_stream(hw, stream);\r\nspin_unlock(&priv->stream_lock);\r\n}\r\n}\r\nstatic int mwl8k_fw_lock(struct ieee80211_hw *hw)\r\n{\r\nstruct mwl8k_priv *priv = hw->priv;\r\nif (priv->fw_mutex_owner != current) {\r\nint rc;\r\nmutex_lock(&priv->fw_mutex);\r\nieee80211_stop_queues(hw);\r\nrc = mwl8k_tx_wait_empty(hw);\r\nif (rc) {\r\nif (!priv->hw_restart_in_progress)\r\nieee80211_wake_queues(hw);\r\nmutex_unlock(&priv->fw_mutex);\r\nreturn rc;\r\n}\r\npriv->fw_mutex_owner = current;\r\n}\r\npriv->fw_mutex_depth++;\r\nreturn 0;\r\n}\r\nstatic void mwl8k_fw_unlock(struct ieee80211_hw *hw)\r\n{\r\nstruct mwl8k_priv *priv = hw->priv;\r\nif (!--priv->fw_mutex_depth) {\r\nif (!priv->hw_restart_in_progress)\r\nieee80211_wake_queues(hw);\r\npriv->fw_mutex_owner = NULL;\r\nmutex_unlock(&priv->fw_mutex);\r\n}\r\n}\r\nstatic int mwl8k_post_cmd(struct ieee80211_hw *hw, struct mwl8k_cmd_pkt *cmd)\r\n{\r\nDECLARE_COMPLETION_ONSTACK(cmd_wait);\r\nstruct mwl8k_priv *priv = hw->priv;\r\nvoid __iomem *regs = priv->regs;\r\ndma_addr_t dma_addr;\r\nunsigned int dma_size;\r\nint rc;\r\nunsigned long timeout = 0;\r\nu8 buf[32];\r\nu32 bitmap = 0;\r\nwiphy_dbg(hw->wiphy, "Posting %s [%d]\n",\r\nmwl8k_cmd_name(cmd->code, buf, sizeof(buf)), cmd->macid);\r\nrc = mwl8k_fw_lock(hw);\r\nif (rc)\r\nreturn rc;\r\nif (priv->ap_fw && priv->running_bsses) {\r\nswitch (le16_to_cpu(cmd->code)) {\r\ncase MWL8K_CMD_SET_RF_CHANNEL:\r\ncase MWL8K_CMD_RADIO_CONTROL:\r\ncase MWL8K_CMD_RF_TX_POWER:\r\ncase MWL8K_CMD_TX_POWER:\r\ncase MWL8K_CMD_RF_ANTENNA:\r\ncase MWL8K_CMD_RTS_THRESHOLD:\r\ncase MWL8K_CMD_MIMO_CONFIG:\r\nbitmap = priv->running_bsses;\r\nmwl8k_enable_bsses(hw, false, bitmap);\r\nbreak;\r\n}\r\n}\r\ncmd->result = (__force __le16) 0xffff;\r\ndma_size = le16_to_cpu(cmd->length);\r\ndma_addr = pci_map_single(priv->pdev, cmd, dma_size,\r\nPCI_DMA_BIDIRECTIONAL);\r\nif (pci_dma_mapping_error(priv->pdev, dma_addr))\r\nreturn -ENOMEM;\r\npriv->hostcmd_wait = &cmd_wait;\r\niowrite32(dma_addr, regs + MWL8K_HIU_GEN_PTR);\r\niowrite32(MWL8K_H2A_INT_DOORBELL,\r\nregs + MWL8K_HIU_H2A_INTERRUPT_EVENTS);\r\niowrite32(MWL8K_H2A_INT_DUMMY,\r\nregs + MWL8K_HIU_H2A_INTERRUPT_EVENTS);\r\ntimeout = wait_for_completion_timeout(&cmd_wait,\r\nmsecs_to_jiffies(MWL8K_CMD_TIMEOUT_MS));\r\npriv->hostcmd_wait = NULL;\r\npci_unmap_single(priv->pdev, dma_addr, dma_size,\r\nPCI_DMA_BIDIRECTIONAL);\r\nif (!timeout) {\r\nwiphy_err(hw->wiphy, "Command %s timeout after %u ms\n",\r\nmwl8k_cmd_name(cmd->code, buf, sizeof(buf)),\r\nMWL8K_CMD_TIMEOUT_MS);\r\nrc = -ETIMEDOUT;\r\n} else {\r\nint ms;\r\nms = MWL8K_CMD_TIMEOUT_MS - jiffies_to_msecs(timeout);\r\nrc = cmd->result ? -EINVAL : 0;\r\nif (rc)\r\nwiphy_err(hw->wiphy, "Command %s error 0x%x\n",\r\nmwl8k_cmd_name(cmd->code, buf, sizeof(buf)),\r\nle16_to_cpu(cmd->result));\r\nelse if (ms > 2000)\r\nwiphy_notice(hw->wiphy, "Command %s took %d ms\n",\r\nmwl8k_cmd_name(cmd->code,\r\nbuf, sizeof(buf)),\r\nms);\r\n}\r\nif (bitmap)\r\nmwl8k_enable_bsses(hw, true, bitmap);\r\nmwl8k_fw_unlock(hw);\r\nreturn rc;\r\n}\r\nstatic int mwl8k_post_pervif_cmd(struct ieee80211_hw *hw,\r\nstruct ieee80211_vif *vif,\r\nstruct mwl8k_cmd_pkt *cmd)\r\n{\r\nif (vif != NULL)\r\ncmd->macid = MWL8K_VIF(vif)->macid;\r\nreturn mwl8k_post_cmd(hw, cmd);\r\n}\r\nstatic void mwl8k_setup_2ghz_band(struct ieee80211_hw *hw)\r\n{\r\nstruct mwl8k_priv *priv = hw->priv;\r\nBUILD_BUG_ON(sizeof(priv->channels_24) != sizeof(mwl8k_channels_24));\r\nmemcpy(priv->channels_24, mwl8k_channels_24, sizeof(mwl8k_channels_24));\r\nBUILD_BUG_ON(sizeof(priv->rates_24) != sizeof(mwl8k_rates_24));\r\nmemcpy(priv->rates_24, mwl8k_rates_24, sizeof(mwl8k_rates_24));\r\npriv->band_24.band = IEEE80211_BAND_2GHZ;\r\npriv->band_24.channels = priv->channels_24;\r\npriv->band_24.n_channels = ARRAY_SIZE(mwl8k_channels_24);\r\npriv->band_24.bitrates = priv->rates_24;\r\npriv->band_24.n_bitrates = ARRAY_SIZE(mwl8k_rates_24);\r\nhw->wiphy->bands[IEEE80211_BAND_2GHZ] = &priv->band_24;\r\n}\r\nstatic void mwl8k_setup_5ghz_band(struct ieee80211_hw *hw)\r\n{\r\nstruct mwl8k_priv *priv = hw->priv;\r\nBUILD_BUG_ON(sizeof(priv->channels_50) != sizeof(mwl8k_channels_50));\r\nmemcpy(priv->channels_50, mwl8k_channels_50, sizeof(mwl8k_channels_50));\r\nBUILD_BUG_ON(sizeof(priv->rates_50) != sizeof(mwl8k_rates_50));\r\nmemcpy(priv->rates_50, mwl8k_rates_50, sizeof(mwl8k_rates_50));\r\npriv->band_50.band = IEEE80211_BAND_5GHZ;\r\npriv->band_50.channels = priv->channels_50;\r\npriv->band_50.n_channels = ARRAY_SIZE(mwl8k_channels_50);\r\npriv->band_50.bitrates = priv->rates_50;\r\npriv->band_50.n_bitrates = ARRAY_SIZE(mwl8k_rates_50);\r\nhw->wiphy->bands[IEEE80211_BAND_5GHZ] = &priv->band_50;\r\n}\r\nstatic void\r\nmwl8k_set_ht_caps(struct ieee80211_hw *hw,\r\nstruct ieee80211_supported_band *band, u32 cap)\r\n{\r\nint rx_streams;\r\nint tx_streams;\r\nband->ht_cap.ht_supported = 1;\r\nif (cap & MWL8K_CAP_MAX_AMSDU)\r\nband->ht_cap.cap |= IEEE80211_HT_CAP_MAX_AMSDU;\r\nif (cap & MWL8K_CAP_GREENFIELD)\r\nband->ht_cap.cap |= IEEE80211_HT_CAP_GRN_FLD;\r\nif (cap & MWL8K_CAP_AMPDU) {\r\nieee80211_hw_set(hw, AMPDU_AGGREGATION);\r\nband->ht_cap.ampdu_factor = IEEE80211_HT_MAX_AMPDU_64K;\r\nband->ht_cap.ampdu_density = IEEE80211_HT_MPDU_DENSITY_NONE;\r\n}\r\nif (cap & MWL8K_CAP_RX_STBC)\r\nband->ht_cap.cap |= IEEE80211_HT_CAP_RX_STBC;\r\nif (cap & MWL8K_CAP_TX_STBC)\r\nband->ht_cap.cap |= IEEE80211_HT_CAP_TX_STBC;\r\nif (cap & MWL8K_CAP_SHORTGI_40MHZ)\r\nband->ht_cap.cap |= IEEE80211_HT_CAP_SGI_40;\r\nif (cap & MWL8K_CAP_SHORTGI_20MHZ)\r\nband->ht_cap.cap |= IEEE80211_HT_CAP_SGI_20;\r\nif (cap & MWL8K_CAP_DELAY_BA)\r\nband->ht_cap.cap |= IEEE80211_HT_CAP_DELAY_BA;\r\nif (cap & MWL8K_CAP_40MHZ)\r\nband->ht_cap.cap |= IEEE80211_HT_CAP_SUP_WIDTH_20_40;\r\nrx_streams = hweight32(cap & MWL8K_CAP_RX_ANTENNA_MASK);\r\ntx_streams = hweight32(cap & MWL8K_CAP_TX_ANTENNA_MASK);\r\nband->ht_cap.mcs.rx_mask[0] = 0xff;\r\nif (rx_streams >= 2)\r\nband->ht_cap.mcs.rx_mask[1] = 0xff;\r\nif (rx_streams >= 3)\r\nband->ht_cap.mcs.rx_mask[2] = 0xff;\r\nband->ht_cap.mcs.rx_mask[4] = 0x01;\r\nband->ht_cap.mcs.tx_params = IEEE80211_HT_MCS_TX_DEFINED;\r\nif (rx_streams != tx_streams) {\r\nband->ht_cap.mcs.tx_params |= IEEE80211_HT_MCS_TX_RX_DIFF;\r\nband->ht_cap.mcs.tx_params |= (tx_streams - 1) <<\r\nIEEE80211_HT_MCS_TX_MAX_STREAMS_SHIFT;\r\n}\r\n}\r\nstatic void\r\nmwl8k_set_caps(struct ieee80211_hw *hw, u32 caps)\r\n{\r\nstruct mwl8k_priv *priv = hw->priv;\r\nif (priv->caps)\r\nreturn;\r\nif ((caps & MWL8K_CAP_2GHZ4) || !(caps & MWL8K_CAP_BAND_MASK)) {\r\nmwl8k_setup_2ghz_band(hw);\r\nif (caps & MWL8K_CAP_MIMO)\r\nmwl8k_set_ht_caps(hw, &priv->band_24, caps);\r\n}\r\nif (caps & MWL8K_CAP_5GHZ) {\r\nmwl8k_setup_5ghz_band(hw);\r\nif (caps & MWL8K_CAP_MIMO)\r\nmwl8k_set_ht_caps(hw, &priv->band_50, caps);\r\n}\r\npriv->caps = caps;\r\n}\r\nstatic int mwl8k_cmd_get_hw_spec_sta(struct ieee80211_hw *hw)\r\n{\r\nstruct mwl8k_priv *priv = hw->priv;\r\nstruct mwl8k_cmd_get_hw_spec_sta *cmd;\r\nint rc;\r\nint i;\r\ncmd = kzalloc(sizeof(*cmd), GFP_KERNEL);\r\nif (cmd == NULL)\r\nreturn -ENOMEM;\r\ncmd->header.code = cpu_to_le16(MWL8K_CMD_GET_HW_SPEC);\r\ncmd->header.length = cpu_to_le16(sizeof(*cmd));\r\nmemset(cmd->perm_addr, 0xff, sizeof(cmd->perm_addr));\r\ncmd->ps_cookie = cpu_to_le32(priv->cookie_dma);\r\ncmd->rx_queue_ptr = cpu_to_le32(priv->rxq[0].rxd_dma);\r\ncmd->num_tx_queues = cpu_to_le32(mwl8k_tx_queues(priv));\r\nfor (i = 0; i < mwl8k_tx_queues(priv); i++)\r\ncmd->tx_queue_ptrs[i] = cpu_to_le32(priv->txq[i].txd_dma);\r\ncmd->num_tx_desc_per_queue = cpu_to_le32(MWL8K_TX_DESCS);\r\ncmd->total_rxd = cpu_to_le32(MWL8K_RX_DESCS);\r\nrc = mwl8k_post_cmd(hw, &cmd->header);\r\nif (!rc) {\r\nSET_IEEE80211_PERM_ADDR(hw, cmd->perm_addr);\r\npriv->num_mcaddrs = le16_to_cpu(cmd->num_mcaddrs);\r\npriv->fw_rev = le32_to_cpu(cmd->fw_rev);\r\npriv->hw_rev = cmd->hw_rev;\r\nmwl8k_set_caps(hw, le32_to_cpu(cmd->caps));\r\npriv->ap_macids_supported = 0x00000000;\r\npriv->sta_macids_supported = 0x00000001;\r\n}\r\nkfree(cmd);\r\nreturn rc;\r\n}\r\nstatic int mwl8k_cmd_get_hw_spec_ap(struct ieee80211_hw *hw)\r\n{\r\nstruct mwl8k_priv *priv = hw->priv;\r\nstruct mwl8k_cmd_get_hw_spec_ap *cmd;\r\nint rc, i;\r\nu32 api_version;\r\ncmd = kzalloc(sizeof(*cmd), GFP_KERNEL);\r\nif (cmd == NULL)\r\nreturn -ENOMEM;\r\ncmd->header.code = cpu_to_le16(MWL8K_CMD_GET_HW_SPEC);\r\ncmd->header.length = cpu_to_le16(sizeof(*cmd));\r\nmemset(cmd->perm_addr, 0xff, sizeof(cmd->perm_addr));\r\ncmd->ps_cookie = cpu_to_le32(priv->cookie_dma);\r\nrc = mwl8k_post_cmd(hw, &cmd->header);\r\nif (!rc) {\r\nint off;\r\napi_version = le32_to_cpu(cmd->fw_api_version);\r\nif (priv->device_info->fw_api_ap != api_version) {\r\nprintk(KERN_ERR "%s: Unsupported fw API version for %s."\r\n" Expected %d got %d.\n", MWL8K_NAME,\r\npriv->device_info->part_name,\r\npriv->device_info->fw_api_ap,\r\napi_version);\r\nrc = -EINVAL;\r\ngoto done;\r\n}\r\nSET_IEEE80211_PERM_ADDR(hw, cmd->perm_addr);\r\npriv->num_mcaddrs = le16_to_cpu(cmd->num_mcaddrs);\r\npriv->fw_rev = le32_to_cpu(cmd->fw_rev);\r\npriv->hw_rev = cmd->hw_rev;\r\nmwl8k_set_caps(hw, le32_to_cpu(cmd->caps));\r\npriv->ap_macids_supported = 0x000000ff;\r\npriv->sta_macids_supported = 0x00000100;\r\npriv->num_ampdu_queues = le32_to_cpu(cmd->num_of_ampdu_queues);\r\nif (priv->num_ampdu_queues > MWL8K_MAX_AMPDU_QUEUES) {\r\nwiphy_warn(hw->wiphy, "fw reported %d ampdu queues"\r\n" but we only support %d.\n",\r\npriv->num_ampdu_queues,\r\nMWL8K_MAX_AMPDU_QUEUES);\r\npriv->num_ampdu_queues = MWL8K_MAX_AMPDU_QUEUES;\r\n}\r\noff = le32_to_cpu(cmd->rxwrptr) & 0xffff;\r\niowrite32(priv->rxq[0].rxd_dma, priv->sram + off);\r\noff = le32_to_cpu(cmd->rxrdptr) & 0xffff;\r\niowrite32(priv->rxq[0].rxd_dma, priv->sram + off);\r\npriv->txq_offset[0] = le32_to_cpu(cmd->wcbbase0) & 0xffff;\r\npriv->txq_offset[1] = le32_to_cpu(cmd->wcbbase1) & 0xffff;\r\npriv->txq_offset[2] = le32_to_cpu(cmd->wcbbase2) & 0xffff;\r\npriv->txq_offset[3] = le32_to_cpu(cmd->wcbbase3) & 0xffff;\r\nfor (i = 0; i < priv->num_ampdu_queues; i++)\r\npriv->txq_offset[i + MWL8K_TX_WMM_QUEUES] =\r\nle32_to_cpu(cmd->wcbbase_ampdu[i]) & 0xffff;\r\n}\r\ndone:\r\nkfree(cmd);\r\nreturn rc;\r\n}\r\nstatic int mwl8k_cmd_set_hw_spec(struct ieee80211_hw *hw)\r\n{\r\nstruct mwl8k_priv *priv = hw->priv;\r\nstruct mwl8k_cmd_set_hw_spec *cmd;\r\nint rc;\r\nint i;\r\ncmd = kzalloc(sizeof(*cmd), GFP_KERNEL);\r\nif (cmd == NULL)\r\nreturn -ENOMEM;\r\ncmd->header.code = cpu_to_le16(MWL8K_CMD_SET_HW_SPEC);\r\ncmd->header.length = cpu_to_le16(sizeof(*cmd));\r\ncmd->ps_cookie = cpu_to_le32(priv->cookie_dma);\r\ncmd->rx_queue_ptr = cpu_to_le32(priv->rxq[0].rxd_dma);\r\ncmd->num_tx_queues = cpu_to_le32(mwl8k_tx_queues(priv));\r\nfor (i = 0; i < mwl8k_tx_queues(priv); i++) {\r\nint j = mwl8k_tx_queues(priv) - 1 - i;\r\ncmd->tx_queue_ptrs[i] = cpu_to_le32(priv->txq[j].txd_dma);\r\n}\r\ncmd->flags = cpu_to_le32(MWL8K_SET_HW_SPEC_FLAG_HOST_DECR_MGMT |\r\nMWL8K_SET_HW_SPEC_FLAG_HOSTFORM_PROBERESP |\r\nMWL8K_SET_HW_SPEC_FLAG_HOSTFORM_BEACON |\r\nMWL8K_SET_HW_SPEC_FLAG_ENABLE_LIFE_TIME_EXPIRY |\r\nMWL8K_SET_HW_SPEC_FLAG_GENERATE_CCMP_HDR);\r\ncmd->num_tx_desc_per_queue = cpu_to_le32(MWL8K_TX_DESCS);\r\ncmd->total_rxd = cpu_to_le32(MWL8K_RX_DESCS);\r\nrc = mwl8k_post_cmd(hw, &cmd->header);\r\nkfree(cmd);\r\nreturn rc;\r\n}\r\nstatic struct mwl8k_cmd_pkt *\r\n__mwl8k_cmd_mac_multicast_adr(struct ieee80211_hw *hw, int allmulti,\r\nstruct netdev_hw_addr_list *mc_list)\r\n{\r\nstruct mwl8k_priv *priv = hw->priv;\r\nstruct mwl8k_cmd_mac_multicast_adr *cmd;\r\nint size;\r\nint mc_count = 0;\r\nif (mc_list)\r\nmc_count = netdev_hw_addr_list_count(mc_list);\r\nif (allmulti || mc_count > priv->num_mcaddrs) {\r\nallmulti = 1;\r\nmc_count = 0;\r\n}\r\nsize = sizeof(*cmd) + mc_count * ETH_ALEN;\r\ncmd = kzalloc(size, GFP_ATOMIC);\r\nif (cmd == NULL)\r\nreturn NULL;\r\ncmd->header.code = cpu_to_le16(MWL8K_CMD_MAC_MULTICAST_ADR);\r\ncmd->header.length = cpu_to_le16(size);\r\ncmd->action = cpu_to_le16(MWL8K_ENABLE_RX_DIRECTED |\r\nMWL8K_ENABLE_RX_BROADCAST);\r\nif (allmulti) {\r\ncmd->action |= cpu_to_le16(MWL8K_ENABLE_RX_ALL_MULTICAST);\r\n} else if (mc_count) {\r\nstruct netdev_hw_addr *ha;\r\nint i = 0;\r\ncmd->action |= cpu_to_le16(MWL8K_ENABLE_RX_MULTICAST);\r\ncmd->numaddr = cpu_to_le16(mc_count);\r\nnetdev_hw_addr_list_for_each(ha, mc_list) {\r\nmemcpy(cmd->addr[i], ha->addr, ETH_ALEN);\r\n}\r\n}\r\nreturn &cmd->header;\r\n}\r\nstatic int mwl8k_cmd_get_stat(struct ieee80211_hw *hw,\r\nstruct ieee80211_low_level_stats *stats)\r\n{\r\nstruct mwl8k_cmd_get_stat *cmd;\r\nint rc;\r\ncmd = kzalloc(sizeof(*cmd), GFP_KERNEL);\r\nif (cmd == NULL)\r\nreturn -ENOMEM;\r\ncmd->header.code = cpu_to_le16(MWL8K_CMD_GET_STAT);\r\ncmd->header.length = cpu_to_le16(sizeof(*cmd));\r\nrc = mwl8k_post_cmd(hw, &cmd->header);\r\nif (!rc) {\r\nstats->dot11ACKFailureCount =\r\nle32_to_cpu(cmd->stats[MWL8K_STAT_ACK_FAILURE]);\r\nstats->dot11RTSFailureCount =\r\nle32_to_cpu(cmd->stats[MWL8K_STAT_RTS_FAILURE]);\r\nstats->dot11FCSErrorCount =\r\nle32_to_cpu(cmd->stats[MWL8K_STAT_FCS_ERROR]);\r\nstats->dot11RTSSuccessCount =\r\nle32_to_cpu(cmd->stats[MWL8K_STAT_RTS_SUCCESS]);\r\n}\r\nkfree(cmd);\r\nreturn rc;\r\n}\r\nstatic int\r\nmwl8k_cmd_radio_control(struct ieee80211_hw *hw, bool enable, bool force)\r\n{\r\nstruct mwl8k_priv *priv = hw->priv;\r\nstruct mwl8k_cmd_radio_control *cmd;\r\nint rc;\r\nif (enable == priv->radio_on && !force)\r\nreturn 0;\r\ncmd = kzalloc(sizeof(*cmd), GFP_KERNEL);\r\nif (cmd == NULL)\r\nreturn -ENOMEM;\r\ncmd->header.code = cpu_to_le16(MWL8K_CMD_RADIO_CONTROL);\r\ncmd->header.length = cpu_to_le16(sizeof(*cmd));\r\ncmd->action = cpu_to_le16(MWL8K_CMD_SET);\r\ncmd->control = cpu_to_le16(priv->radio_short_preamble ? 3 : 1);\r\ncmd->radio_on = cpu_to_le16(enable ? 0x0001 : 0x0000);\r\nrc = mwl8k_post_cmd(hw, &cmd->header);\r\nkfree(cmd);\r\nif (!rc)\r\npriv->radio_on = enable;\r\nreturn rc;\r\n}\r\nstatic int mwl8k_cmd_radio_disable(struct ieee80211_hw *hw)\r\n{\r\nreturn mwl8k_cmd_radio_control(hw, 0, 0);\r\n}\r\nstatic int mwl8k_cmd_radio_enable(struct ieee80211_hw *hw)\r\n{\r\nreturn mwl8k_cmd_radio_control(hw, 1, 0);\r\n}\r\nstatic int\r\nmwl8k_set_radio_preamble(struct ieee80211_hw *hw, bool short_preamble)\r\n{\r\nstruct mwl8k_priv *priv = hw->priv;\r\npriv->radio_short_preamble = short_preamble;\r\nreturn mwl8k_cmd_radio_control(hw, 1, 1);\r\n}\r\nstatic int mwl8k_cmd_rf_tx_power(struct ieee80211_hw *hw, int dBm)\r\n{\r\nstruct mwl8k_cmd_rf_tx_power *cmd;\r\nint rc;\r\ncmd = kzalloc(sizeof(*cmd), GFP_KERNEL);\r\nif (cmd == NULL)\r\nreturn -ENOMEM;\r\ncmd->header.code = cpu_to_le16(MWL8K_CMD_RF_TX_POWER);\r\ncmd->header.length = cpu_to_le16(sizeof(*cmd));\r\ncmd->action = cpu_to_le16(MWL8K_CMD_SET);\r\ncmd->support_level = cpu_to_le16(dBm);\r\nrc = mwl8k_post_cmd(hw, &cmd->header);\r\nkfree(cmd);\r\nreturn rc;\r\n}\r\nstatic int mwl8k_cmd_tx_power(struct ieee80211_hw *hw,\r\nstruct ieee80211_conf *conf,\r\nunsigned short pwr)\r\n{\r\nstruct ieee80211_channel *channel = conf->chandef.chan;\r\nenum nl80211_channel_type channel_type =\r\ncfg80211_get_chandef_type(&conf->chandef);\r\nstruct mwl8k_cmd_tx_power *cmd;\r\nint rc;\r\nint i;\r\ncmd = kzalloc(sizeof(*cmd), GFP_KERNEL);\r\nif (cmd == NULL)\r\nreturn -ENOMEM;\r\ncmd->header.code = cpu_to_le16(MWL8K_CMD_TX_POWER);\r\ncmd->header.length = cpu_to_le16(sizeof(*cmd));\r\ncmd->action = cpu_to_le16(MWL8K_CMD_SET_LIST);\r\nif (channel->band == IEEE80211_BAND_2GHZ)\r\ncmd->band = cpu_to_le16(0x1);\r\nelse if (channel->band == IEEE80211_BAND_5GHZ)\r\ncmd->band = cpu_to_le16(0x4);\r\ncmd->channel = cpu_to_le16(channel->hw_value);\r\nif (channel_type == NL80211_CHAN_NO_HT ||\r\nchannel_type == NL80211_CHAN_HT20) {\r\ncmd->bw = cpu_to_le16(0x2);\r\n} else {\r\ncmd->bw = cpu_to_le16(0x4);\r\nif (channel_type == NL80211_CHAN_HT40MINUS)\r\ncmd->sub_ch = cpu_to_le16(0x3);\r\nelse if (channel_type == NL80211_CHAN_HT40PLUS)\r\ncmd->sub_ch = cpu_to_le16(0x1);\r\n}\r\nfor (i = 0; i < MWL8K_TX_POWER_LEVEL_TOTAL; i++)\r\ncmd->power_level_list[i] = cpu_to_le16(pwr);\r\nrc = mwl8k_post_cmd(hw, &cmd->header);\r\nkfree(cmd);\r\nreturn rc;\r\n}\r\nstatic int\r\nmwl8k_cmd_rf_antenna(struct ieee80211_hw *hw, int antenna, int mask)\r\n{\r\nstruct mwl8k_cmd_rf_antenna *cmd;\r\nint rc;\r\ncmd = kzalloc(sizeof(*cmd), GFP_KERNEL);\r\nif (cmd == NULL)\r\nreturn -ENOMEM;\r\ncmd->header.code = cpu_to_le16(MWL8K_CMD_RF_ANTENNA);\r\ncmd->header.length = cpu_to_le16(sizeof(*cmd));\r\ncmd->antenna = cpu_to_le16(antenna);\r\ncmd->mode = cpu_to_le16(mask);\r\nrc = mwl8k_post_cmd(hw, &cmd->header);\r\nkfree(cmd);\r\nreturn rc;\r\n}\r\nstatic int mwl8k_cmd_set_beacon(struct ieee80211_hw *hw,\r\nstruct ieee80211_vif *vif, u8 *beacon, int len)\r\n{\r\nstruct mwl8k_cmd_set_beacon *cmd;\r\nint rc;\r\ncmd = kzalloc(sizeof(*cmd) + len, GFP_KERNEL);\r\nif (cmd == NULL)\r\nreturn -ENOMEM;\r\ncmd->header.code = cpu_to_le16(MWL8K_CMD_SET_BEACON);\r\ncmd->header.length = cpu_to_le16(sizeof(*cmd) + len);\r\ncmd->beacon_len = cpu_to_le16(len);\r\nmemcpy(cmd->beacon, beacon, len);\r\nrc = mwl8k_post_pervif_cmd(hw, vif, &cmd->header);\r\nkfree(cmd);\r\nreturn rc;\r\n}\r\nstatic int mwl8k_cmd_set_pre_scan(struct ieee80211_hw *hw)\r\n{\r\nstruct mwl8k_cmd_set_pre_scan *cmd;\r\nint rc;\r\ncmd = kzalloc(sizeof(*cmd), GFP_KERNEL);\r\nif (cmd == NULL)\r\nreturn -ENOMEM;\r\ncmd->header.code = cpu_to_le16(MWL8K_CMD_SET_PRE_SCAN);\r\ncmd->header.length = cpu_to_le16(sizeof(*cmd));\r\nrc = mwl8k_post_cmd(hw, &cmd->header);\r\nkfree(cmd);\r\nreturn rc;\r\n}\r\nstatic int\r\nmwl8k_cmd_bbp_reg_access(struct ieee80211_hw *hw,\r\nu16 action,\r\nu16 offset,\r\nu8 *value)\r\n{\r\nstruct mwl8k_cmd_bbp_reg_access *cmd;\r\nint rc;\r\ncmd = kzalloc(sizeof(*cmd), GFP_KERNEL);\r\nif (cmd == NULL)\r\nreturn -ENOMEM;\r\ncmd->header.code = cpu_to_le16(MWL8K_CMD_BBP_REG_ACCESS);\r\ncmd->header.length = cpu_to_le16(sizeof(*cmd));\r\ncmd->action = cpu_to_le16(action);\r\ncmd->offset = cpu_to_le16(offset);\r\nrc = mwl8k_post_cmd(hw, &cmd->header);\r\nif (!rc)\r\n*value = cmd->value;\r\nelse\r\n*value = 0;\r\nkfree(cmd);\r\nreturn rc;\r\n}\r\nstatic int\r\nmwl8k_cmd_set_post_scan(struct ieee80211_hw *hw, const __u8 *mac)\r\n{\r\nstruct mwl8k_cmd_set_post_scan *cmd;\r\nint rc;\r\ncmd = kzalloc(sizeof(*cmd), GFP_KERNEL);\r\nif (cmd == NULL)\r\nreturn -ENOMEM;\r\ncmd->header.code = cpu_to_le16(MWL8K_CMD_SET_POST_SCAN);\r\ncmd->header.length = cpu_to_le16(sizeof(*cmd));\r\ncmd->isibss = 0;\r\nmemcpy(cmd->bssid, mac, ETH_ALEN);\r\nrc = mwl8k_post_cmd(hw, &cmd->header);\r\nkfree(cmd);\r\nreturn rc;\r\n}\r\nstatic int freq_to_idx(struct mwl8k_priv *priv, int freq)\r\n{\r\nstruct ieee80211_supported_band *sband;\r\nint band, ch, idx = 0;\r\nfor (band = IEEE80211_BAND_2GHZ; band < IEEE80211_NUM_BANDS; band++) {\r\nsband = priv->hw->wiphy->bands[band];\r\nif (!sband)\r\ncontinue;\r\nfor (ch = 0; ch < sband->n_channels; ch++, idx++)\r\nif (sband->channels[ch].center_freq == freq)\r\ngoto exit;\r\n}\r\nexit:\r\nreturn idx;\r\n}\r\nstatic void mwl8k_update_survey(struct mwl8k_priv *priv,\r\nstruct ieee80211_channel *channel)\r\n{\r\nu32 cca_cnt, rx_rdy;\r\ns8 nf = 0, idx;\r\nstruct survey_info *survey;\r\nidx = freq_to_idx(priv, priv->acs_chan->center_freq);\r\nif (idx >= MWL8K_NUM_CHANS) {\r\nwiphy_err(priv->hw->wiphy, "Failed to update survey\n");\r\nreturn;\r\n}\r\nsurvey = &priv->survey[idx];\r\ncca_cnt = ioread32(priv->regs + NOK_CCA_CNT_REG);\r\ncca_cnt /= 1000;\r\nsurvey->time_busy = (u64) cca_cnt;\r\nrx_rdy = ioread32(priv->regs + BBU_RXRDY_CNT_REG);\r\nrx_rdy /= 1000;\r\nsurvey->time_rx = (u64) rx_rdy;\r\npriv->channel_time = jiffies - priv->channel_time;\r\nsurvey->time = jiffies_to_msecs(priv->channel_time);\r\nsurvey->channel = channel;\r\nmwl8k_cmd_bbp_reg_access(priv->hw, 0, BBU_AVG_NOISE_VAL, &nf);\r\nsurvey->noise = nf * -1;\r\nsurvey->filled = SURVEY_INFO_NOISE_DBM |\r\nSURVEY_INFO_TIME |\r\nSURVEY_INFO_TIME_BUSY |\r\nSURVEY_INFO_TIME_RX;\r\n}\r\nstatic int mwl8k_cmd_set_rf_channel(struct ieee80211_hw *hw,\r\nstruct ieee80211_conf *conf)\r\n{\r\nstruct ieee80211_channel *channel = conf->chandef.chan;\r\nenum nl80211_channel_type channel_type =\r\ncfg80211_get_chandef_type(&conf->chandef);\r\nstruct mwl8k_cmd_set_rf_channel *cmd;\r\nstruct mwl8k_priv *priv = hw->priv;\r\nint rc;\r\ncmd = kzalloc(sizeof(*cmd), GFP_KERNEL);\r\nif (cmd == NULL)\r\nreturn -ENOMEM;\r\ncmd->header.code = cpu_to_le16(MWL8K_CMD_SET_RF_CHANNEL);\r\ncmd->header.length = cpu_to_le16(sizeof(*cmd));\r\ncmd->action = cpu_to_le16(MWL8K_CMD_SET);\r\ncmd->current_channel = channel->hw_value;\r\nif (channel->band == IEEE80211_BAND_2GHZ)\r\ncmd->channel_flags |= cpu_to_le32(0x00000001);\r\nelse if (channel->band == IEEE80211_BAND_5GHZ)\r\ncmd->channel_flags |= cpu_to_le32(0x00000004);\r\nif (!priv->sw_scan_start) {\r\nif (channel_type == NL80211_CHAN_NO_HT ||\r\nchannel_type == NL80211_CHAN_HT20)\r\ncmd->channel_flags |= cpu_to_le32(0x00000080);\r\nelse if (channel_type == NL80211_CHAN_HT40MINUS)\r\ncmd->channel_flags |= cpu_to_le32(0x000001900);\r\nelse if (channel_type == NL80211_CHAN_HT40PLUS)\r\ncmd->channel_flags |= cpu_to_le32(0x000000900);\r\n} else {\r\ncmd->channel_flags |= cpu_to_le32(0x00000080);\r\n}\r\nif (priv->sw_scan_start) {\r\nif (priv->channel_time != 0)\r\nmwl8k_update_survey(priv, priv->acs_chan);\r\npriv->channel_time = jiffies;\r\npriv->acs_chan = channel;\r\n}\r\nrc = mwl8k_post_cmd(hw, &cmd->header);\r\nkfree(cmd);\r\nreturn rc;\r\n}\r\nstatic void legacy_rate_mask_to_array(u8 *rates, u32 mask)\r\n{\r\nint i;\r\nint j;\r\nmask &= 0x1fef;\r\nfor (i = 0, j = 0; i < 13; i++) {\r\nif (mask & (1 << i))\r\nrates[j++] = mwl8k_rates_24[i].hw_value;\r\n}\r\n}\r\nstatic int\r\nmwl8k_cmd_set_aid(struct ieee80211_hw *hw,\r\nstruct ieee80211_vif *vif, u32 legacy_rate_mask)\r\n{\r\nstruct mwl8k_cmd_update_set_aid *cmd;\r\nu16 prot_mode;\r\nint rc;\r\ncmd = kzalloc(sizeof(*cmd), GFP_KERNEL);\r\nif (cmd == NULL)\r\nreturn -ENOMEM;\r\ncmd->header.code = cpu_to_le16(MWL8K_CMD_SET_AID);\r\ncmd->header.length = cpu_to_le16(sizeof(*cmd));\r\ncmd->aid = cpu_to_le16(vif->bss_conf.aid);\r\nmemcpy(cmd->bssid, vif->bss_conf.bssid, ETH_ALEN);\r\nif (vif->bss_conf.use_cts_prot) {\r\nprot_mode = MWL8K_FRAME_PROT_11G;\r\n} else {\r\nswitch (vif->bss_conf.ht_operation_mode &\r\nIEEE80211_HT_OP_MODE_PROTECTION) {\r\ncase IEEE80211_HT_OP_MODE_PROTECTION_20MHZ:\r\nprot_mode = MWL8K_FRAME_PROT_11N_HT_40MHZ_ONLY;\r\nbreak;\r\ncase IEEE80211_HT_OP_MODE_PROTECTION_NONHT_MIXED:\r\nprot_mode = MWL8K_FRAME_PROT_11N_HT_ALL;\r\nbreak;\r\ndefault:\r\nprot_mode = MWL8K_FRAME_PROT_DISABLED;\r\nbreak;\r\n}\r\n}\r\ncmd->protection_mode = cpu_to_le16(prot_mode);\r\nlegacy_rate_mask_to_array(cmd->supp_rates, legacy_rate_mask);\r\nrc = mwl8k_post_cmd(hw, &cmd->header);\r\nkfree(cmd);\r\nreturn rc;\r\n}\r\nstatic int\r\nmwl8k_cmd_set_rate(struct ieee80211_hw *hw, struct ieee80211_vif *vif,\r\nu32 legacy_rate_mask, u8 *mcs_rates)\r\n{\r\nstruct mwl8k_cmd_set_rate *cmd;\r\nint rc;\r\ncmd = kzalloc(sizeof(*cmd), GFP_KERNEL);\r\nif (cmd == NULL)\r\nreturn -ENOMEM;\r\ncmd->header.code = cpu_to_le16(MWL8K_CMD_SET_RATE);\r\ncmd->header.length = cpu_to_le16(sizeof(*cmd));\r\nlegacy_rate_mask_to_array(cmd->legacy_rates, legacy_rate_mask);\r\nmemcpy(cmd->mcs_set, mcs_rates, 16);\r\nrc = mwl8k_post_cmd(hw, &cmd->header);\r\nkfree(cmd);\r\nreturn rc;\r\n}\r\nstatic int mwl8k_cmd_finalize_join(struct ieee80211_hw *hw, void *frame,\r\nint framelen, int dtim)\r\n{\r\nstruct mwl8k_cmd_finalize_join *cmd;\r\nstruct ieee80211_mgmt *payload = frame;\r\nint payload_len;\r\nint rc;\r\ncmd = kzalloc(sizeof(*cmd), GFP_KERNEL);\r\nif (cmd == NULL)\r\nreturn -ENOMEM;\r\ncmd->header.code = cpu_to_le16(MWL8K_CMD_SET_FINALIZE_JOIN);\r\ncmd->header.length = cpu_to_le16(sizeof(*cmd));\r\ncmd->sleep_interval = cpu_to_le32(dtim ? dtim : 1);\r\npayload_len = framelen - ieee80211_hdrlen(payload->frame_control);\r\nif (payload_len < 0)\r\npayload_len = 0;\r\nelse if (payload_len > MWL8K_FJ_BEACON_MAXLEN)\r\npayload_len = MWL8K_FJ_BEACON_MAXLEN;\r\nmemcpy(cmd->beacon_data, &payload->u.beacon, payload_len);\r\nrc = mwl8k_post_cmd(hw, &cmd->header);\r\nkfree(cmd);\r\nreturn rc;\r\n}\r\nstatic int\r\nmwl8k_cmd_set_rts_threshold(struct ieee80211_hw *hw, int rts_thresh)\r\n{\r\nstruct mwl8k_cmd_set_rts_threshold *cmd;\r\nint rc;\r\ncmd = kzalloc(sizeof(*cmd), GFP_KERNEL);\r\nif (cmd == NULL)\r\nreturn -ENOMEM;\r\ncmd->header.code = cpu_to_le16(MWL8K_CMD_RTS_THRESHOLD);\r\ncmd->header.length = cpu_to_le16(sizeof(*cmd));\r\ncmd->action = cpu_to_le16(MWL8K_CMD_SET);\r\ncmd->threshold = cpu_to_le16(rts_thresh);\r\nrc = mwl8k_post_cmd(hw, &cmd->header);\r\nkfree(cmd);\r\nreturn rc;\r\n}\r\nstatic int mwl8k_cmd_set_slot(struct ieee80211_hw *hw, bool short_slot_time)\r\n{\r\nstruct mwl8k_cmd_set_slot *cmd;\r\nint rc;\r\ncmd = kzalloc(sizeof(*cmd), GFP_KERNEL);\r\nif (cmd == NULL)\r\nreturn -ENOMEM;\r\ncmd->header.code = cpu_to_le16(MWL8K_CMD_SET_SLOT);\r\ncmd->header.length = cpu_to_le16(sizeof(*cmd));\r\ncmd->action = cpu_to_le16(MWL8K_CMD_SET);\r\ncmd->short_slot = short_slot_time;\r\nrc = mwl8k_post_cmd(hw, &cmd->header);\r\nkfree(cmd);\r\nreturn rc;\r\n}\r\nstatic int\r\nmwl8k_cmd_set_edca_params(struct ieee80211_hw *hw, __u8 qnum,\r\n__u16 cw_min, __u16 cw_max,\r\n__u8 aifs, __u16 txop)\r\n{\r\nstruct mwl8k_priv *priv = hw->priv;\r\nstruct mwl8k_cmd_set_edca_params *cmd;\r\nint rc;\r\ncmd = kzalloc(sizeof(*cmd), GFP_KERNEL);\r\nif (cmd == NULL)\r\nreturn -ENOMEM;\r\ncmd->header.code = cpu_to_le16(MWL8K_CMD_SET_EDCA_PARAMS);\r\ncmd->header.length = cpu_to_le16(sizeof(*cmd));\r\ncmd->action = cpu_to_le16(MWL8K_SET_EDCA_ALL);\r\ncmd->txop = cpu_to_le16(txop);\r\nif (priv->ap_fw) {\r\ncmd->ap.log_cw_max = cpu_to_le32(ilog2(cw_max + 1));\r\ncmd->ap.log_cw_min = cpu_to_le32(ilog2(cw_min + 1));\r\ncmd->ap.aifs = aifs;\r\ncmd->ap.txq = qnum;\r\n} else {\r\ncmd->sta.log_cw_max = (u8)ilog2(cw_max + 1);\r\ncmd->sta.log_cw_min = (u8)ilog2(cw_min + 1);\r\ncmd->sta.aifs = aifs;\r\ncmd->sta.txq = qnum;\r\n}\r\nrc = mwl8k_post_cmd(hw, &cmd->header);\r\nkfree(cmd);\r\nreturn rc;\r\n}\r\nstatic int mwl8k_cmd_set_wmm_mode(struct ieee80211_hw *hw, bool enable)\r\n{\r\nstruct mwl8k_priv *priv = hw->priv;\r\nstruct mwl8k_cmd_set_wmm_mode *cmd;\r\nint rc;\r\ncmd = kzalloc(sizeof(*cmd), GFP_KERNEL);\r\nif (cmd == NULL)\r\nreturn -ENOMEM;\r\ncmd->header.code = cpu_to_le16(MWL8K_CMD_SET_WMM_MODE);\r\ncmd->header.length = cpu_to_le16(sizeof(*cmd));\r\ncmd->action = cpu_to_le16(!!enable);\r\nrc = mwl8k_post_cmd(hw, &cmd->header);\r\nkfree(cmd);\r\nif (!rc)\r\npriv->wmm_enabled = enable;\r\nreturn rc;\r\n}\r\nstatic int mwl8k_cmd_mimo_config(struct ieee80211_hw *hw, __u8 rx, __u8 tx)\r\n{\r\nstruct mwl8k_cmd_mimo_config *cmd;\r\nint rc;\r\ncmd = kzalloc(sizeof(*cmd), GFP_KERNEL);\r\nif (cmd == NULL)\r\nreturn -ENOMEM;\r\ncmd->header.code = cpu_to_le16(MWL8K_CMD_MIMO_CONFIG);\r\ncmd->header.length = cpu_to_le16(sizeof(*cmd));\r\ncmd->action = cpu_to_le32((u32)MWL8K_CMD_SET);\r\ncmd->rx_antenna_map = rx;\r\ncmd->tx_antenna_map = tx;\r\nrc = mwl8k_post_cmd(hw, &cmd->header);\r\nkfree(cmd);\r\nreturn rc;\r\n}\r\nstatic int mwl8k_cmd_use_fixed_rate_sta(struct ieee80211_hw *hw)\r\n{\r\nstruct mwl8k_cmd_use_fixed_rate_sta *cmd;\r\nint rc;\r\ncmd = kzalloc(sizeof(*cmd), GFP_KERNEL);\r\nif (cmd == NULL)\r\nreturn -ENOMEM;\r\ncmd->header.code = cpu_to_le16(MWL8K_CMD_USE_FIXED_RATE);\r\ncmd->header.length = cpu_to_le16(sizeof(*cmd));\r\ncmd->action = cpu_to_le32(MWL8K_USE_AUTO_RATE);\r\ncmd->rate_type = cpu_to_le32(MWL8K_UCAST_RATE);\r\nrc = mwl8k_post_cmd(hw, &cmd->header);\r\nkfree(cmd);\r\nreturn rc;\r\n}\r\nstatic int\r\nmwl8k_cmd_use_fixed_rate_ap(struct ieee80211_hw *hw, int mcast, int mgmt)\r\n{\r\nstruct mwl8k_cmd_use_fixed_rate_ap *cmd;\r\nint rc;\r\ncmd = kzalloc(sizeof(*cmd), GFP_KERNEL);\r\nif (cmd == NULL)\r\nreturn -ENOMEM;\r\ncmd->header.code = cpu_to_le16(MWL8K_CMD_USE_FIXED_RATE);\r\ncmd->header.length = cpu_to_le16(sizeof(*cmd));\r\ncmd->action = cpu_to_le32(MWL8K_USE_AUTO_RATE);\r\ncmd->multicast_rate = mcast;\r\ncmd->management_rate = mgmt;\r\nrc = mwl8k_post_cmd(hw, &cmd->header);\r\nkfree(cmd);\r\nreturn rc;\r\n}\r\nstatic int mwl8k_cmd_enable_sniffer(struct ieee80211_hw *hw, bool enable)\r\n{\r\nstruct mwl8k_cmd_enable_sniffer *cmd;\r\nint rc;\r\ncmd = kzalloc(sizeof(*cmd), GFP_KERNEL);\r\nif (cmd == NULL)\r\nreturn -ENOMEM;\r\ncmd->header.code = cpu_to_le16(MWL8K_CMD_ENABLE_SNIFFER);\r\ncmd->header.length = cpu_to_le16(sizeof(*cmd));\r\ncmd->action = cpu_to_le32(!!enable);\r\nrc = mwl8k_post_cmd(hw, &cmd->header);\r\nkfree(cmd);\r\nreturn rc;\r\n}\r\nstatic int mwl8k_cmd_update_mac_addr(struct ieee80211_hw *hw,\r\nstruct ieee80211_vif *vif, u8 *mac, bool set)\r\n{\r\nstruct mwl8k_priv *priv = hw->priv;\r\nstruct mwl8k_vif *mwl8k_vif = MWL8K_VIF(vif);\r\nstruct mwl8k_cmd_update_mac_addr *cmd;\r\nint mac_type;\r\nint rc;\r\nmac_type = MWL8K_MAC_TYPE_PRIMARY_AP;\r\nif (vif != NULL && vif->type == NL80211_IFTYPE_STATION) {\r\nif (mwl8k_vif->macid + 1 == ffs(priv->sta_macids_supported))\r\nif (priv->ap_fw)\r\nmac_type = MWL8K_MAC_TYPE_SECONDARY_CLIENT;\r\nelse\r\nmac_type = MWL8K_MAC_TYPE_PRIMARY_CLIENT;\r\nelse\r\nmac_type = MWL8K_MAC_TYPE_SECONDARY_CLIENT;\r\n} else if (vif != NULL && vif->type == NL80211_IFTYPE_AP) {\r\nif (mwl8k_vif->macid + 1 == ffs(priv->ap_macids_supported))\r\nmac_type = MWL8K_MAC_TYPE_PRIMARY_AP;\r\nelse\r\nmac_type = MWL8K_MAC_TYPE_SECONDARY_AP;\r\n}\r\ncmd = kzalloc(sizeof(*cmd), GFP_KERNEL);\r\nif (cmd == NULL)\r\nreturn -ENOMEM;\r\nif (set)\r\ncmd->header.code = cpu_to_le16(MWL8K_CMD_SET_MAC_ADDR);\r\nelse\r\ncmd->header.code = cpu_to_le16(MWL8K_CMD_DEL_MAC_ADDR);\r\ncmd->header.length = cpu_to_le16(sizeof(*cmd));\r\nif (priv->ap_fw) {\r\ncmd->mbss.mac_type = cpu_to_le16(mac_type);\r\nmemcpy(cmd->mbss.mac_addr, mac, ETH_ALEN);\r\n} else {\r\nmemcpy(cmd->mac_addr, mac, ETH_ALEN);\r\n}\r\nrc = mwl8k_post_pervif_cmd(hw, vif, &cmd->header);\r\nkfree(cmd);\r\nreturn rc;\r\n}\r\nstatic inline int mwl8k_cmd_set_mac_addr(struct ieee80211_hw *hw,\r\nstruct ieee80211_vif *vif, u8 *mac)\r\n{\r\nreturn mwl8k_cmd_update_mac_addr(hw, vif, mac, true);\r\n}\r\nstatic inline int mwl8k_cmd_del_mac_addr(struct ieee80211_hw *hw,\r\nstruct ieee80211_vif *vif, u8 *mac)\r\n{\r\nreturn mwl8k_cmd_update_mac_addr(hw, vif, mac, false);\r\n}\r\nstatic int mwl8k_cmd_set_rateadapt_mode(struct ieee80211_hw *hw, __u16 mode)\r\n{\r\nstruct mwl8k_cmd_set_rate_adapt_mode *cmd;\r\nint rc;\r\ncmd = kzalloc(sizeof(*cmd), GFP_KERNEL);\r\nif (cmd == NULL)\r\nreturn -ENOMEM;\r\ncmd->header.code = cpu_to_le16(MWL8K_CMD_SET_RATEADAPT_MODE);\r\ncmd->header.length = cpu_to_le16(sizeof(*cmd));\r\ncmd->action = cpu_to_le16(MWL8K_CMD_SET);\r\ncmd->mode = cpu_to_le16(mode);\r\nrc = mwl8k_post_cmd(hw, &cmd->header);\r\nkfree(cmd);\r\nreturn rc;\r\n}\r\nstatic int mwl8k_cmd_get_watchdog_bitmap(struct ieee80211_hw *hw, u8 *bitmap)\r\n{\r\nstruct mwl8k_cmd_get_watchdog_bitmap *cmd;\r\nint rc;\r\ncmd = kzalloc(sizeof(*cmd), GFP_KERNEL);\r\nif (cmd == NULL)\r\nreturn -ENOMEM;\r\ncmd->header.code = cpu_to_le16(MWL8K_CMD_GET_WATCHDOG_BITMAP);\r\ncmd->header.length = cpu_to_le16(sizeof(*cmd));\r\nrc = mwl8k_post_cmd(hw, &cmd->header);\r\nif (!rc)\r\n*bitmap = cmd->bitmap;\r\nkfree(cmd);\r\nreturn rc;\r\n}\r\nstatic void mwl8k_watchdog_ba_events(struct work_struct *work)\r\n{\r\nint rc;\r\nu8 bitmap = 0, stream_index;\r\nstruct mwl8k_ampdu_stream *streams;\r\nstruct mwl8k_priv *priv =\r\ncontainer_of(work, struct mwl8k_priv, watchdog_ba_handle);\r\nstruct ieee80211_hw *hw = priv->hw;\r\nint i;\r\nu32 status = 0;\r\nmwl8k_fw_lock(hw);\r\nrc = mwl8k_cmd_get_watchdog_bitmap(priv->hw, &bitmap);\r\nif (rc)\r\ngoto done;\r\nspin_lock(&priv->stream_lock);\r\nfor (i = 0; i < TOTAL_HW_TX_QUEUES; i++) {\r\nif (bitmap & (1 << i)) {\r\nstream_index = (i + MWL8K_WMM_QUEUE_NUMBER) %\r\nTOTAL_HW_TX_QUEUES;\r\nstreams = &priv->ampdu[stream_index];\r\nif (streams->state == AMPDU_STREAM_ACTIVE) {\r\nieee80211_stop_tx_ba_session(streams->sta,\r\nstreams->tid);\r\nspin_unlock(&priv->stream_lock);\r\nmwl8k_destroy_ba(hw, stream_index);\r\nspin_lock(&priv->stream_lock);\r\n}\r\n}\r\n}\r\nspin_unlock(&priv->stream_lock);\r\ndone:\r\natomic_dec(&priv->watchdog_event_pending);\r\nstatus = ioread32(priv->regs + MWL8K_HIU_A2H_INTERRUPT_STATUS_MASK);\r\niowrite32((status | MWL8K_A2H_INT_BA_WATCHDOG),\r\npriv->regs + MWL8K_HIU_A2H_INTERRUPT_STATUS_MASK);\r\nmwl8k_fw_unlock(hw);\r\nreturn;\r\n}\r\nstatic int mwl8k_cmd_bss_start(struct ieee80211_hw *hw,\r\nstruct ieee80211_vif *vif, int enable)\r\n{\r\nstruct mwl8k_cmd_bss_start *cmd;\r\nstruct mwl8k_vif *mwl8k_vif = MWL8K_VIF(vif);\r\nstruct mwl8k_priv *priv = hw->priv;\r\nint rc;\r\nif (enable && (priv->running_bsses & (1 << mwl8k_vif->macid)))\r\nreturn 0;\r\nif (!enable && !(priv->running_bsses & (1 << mwl8k_vif->macid)))\r\nreturn 0;\r\ncmd = kzalloc(sizeof(*cmd), GFP_KERNEL);\r\nif (cmd == NULL)\r\nreturn -ENOMEM;\r\ncmd->header.code = cpu_to_le16(MWL8K_CMD_BSS_START);\r\ncmd->header.length = cpu_to_le16(sizeof(*cmd));\r\ncmd->enable = cpu_to_le32(enable);\r\nrc = mwl8k_post_pervif_cmd(hw, vif, &cmd->header);\r\nkfree(cmd);\r\nif (!rc) {\r\nif (enable)\r\npriv->running_bsses |= (1 << mwl8k_vif->macid);\r\nelse\r\npriv->running_bsses &= ~(1 << mwl8k_vif->macid);\r\n}\r\nreturn rc;\r\n}\r\nstatic void mwl8k_enable_bsses(struct ieee80211_hw *hw, bool enable, u32 bitmap)\r\n{\r\nstruct mwl8k_priv *priv = hw->priv;\r\nstruct mwl8k_vif *mwl8k_vif, *tmp_vif;\r\nstruct ieee80211_vif *vif;\r\nlist_for_each_entry_safe(mwl8k_vif, tmp_vif, &priv->vif_list, list) {\r\nvif = mwl8k_vif->vif;\r\nif (!(bitmap & (1 << mwl8k_vif->macid)))\r\ncontinue;\r\nif (vif->type == NL80211_IFTYPE_AP)\r\nmwl8k_cmd_bss_start(hw, vif, enable);\r\n}\r\n}\r\nstatic int\r\nmwl8k_check_ba(struct ieee80211_hw *hw, struct mwl8k_ampdu_stream *stream,\r\nstruct ieee80211_vif *vif)\r\n{\r\nstruct mwl8k_cmd_bastream *cmd;\r\nint rc;\r\ncmd = kzalloc(sizeof(*cmd), GFP_KERNEL);\r\nif (cmd == NULL)\r\nreturn -ENOMEM;\r\ncmd->header.code = cpu_to_le16(MWL8K_CMD_BASTREAM);\r\ncmd->header.length = cpu_to_le16(sizeof(*cmd));\r\ncmd->action = cpu_to_le32(MWL8K_BA_CHECK);\r\ncmd->create_params.queue_id = stream->idx;\r\nmemcpy(&cmd->create_params.peer_mac_addr[0], stream->sta->addr,\r\nETH_ALEN);\r\ncmd->create_params.tid = stream->tid;\r\ncmd->create_params.flags =\r\ncpu_to_le32(BASTREAM_FLAG_IMMEDIATE_TYPE) |\r\ncpu_to_le32(BASTREAM_FLAG_DIRECTION_UPSTREAM);\r\nrc = mwl8k_post_pervif_cmd(hw, vif, &cmd->header);\r\nkfree(cmd);\r\nreturn rc;\r\n}\r\nstatic int\r\nmwl8k_create_ba(struct ieee80211_hw *hw, struct mwl8k_ampdu_stream *stream,\r\nu8 buf_size, struct ieee80211_vif *vif)\r\n{\r\nstruct mwl8k_cmd_bastream *cmd;\r\nint rc;\r\ncmd = kzalloc(sizeof(*cmd), GFP_KERNEL);\r\nif (cmd == NULL)\r\nreturn -ENOMEM;\r\ncmd->header.code = cpu_to_le16(MWL8K_CMD_BASTREAM);\r\ncmd->header.length = cpu_to_le16(sizeof(*cmd));\r\ncmd->action = cpu_to_le32(MWL8K_BA_CREATE);\r\ncmd->create_params.bar_thrs = cpu_to_le32((u32)buf_size);\r\ncmd->create_params.window_size = cpu_to_le32((u32)buf_size);\r\ncmd->create_params.queue_id = stream->idx;\r\nmemcpy(cmd->create_params.peer_mac_addr, stream->sta->addr, ETH_ALEN);\r\ncmd->create_params.tid = stream->tid;\r\ncmd->create_params.curr_seq_no = cpu_to_le16(0);\r\ncmd->create_params.reset_seq_no_flag = 1;\r\ncmd->create_params.param_info =\r\n(stream->sta->ht_cap.ampdu_factor &\r\nIEEE80211_HT_AMPDU_PARM_FACTOR) |\r\n((stream->sta->ht_cap.ampdu_density << 2) &\r\nIEEE80211_HT_AMPDU_PARM_DENSITY);\r\ncmd->create_params.flags =\r\ncpu_to_le32(BASTREAM_FLAG_IMMEDIATE_TYPE |\r\nBASTREAM_FLAG_DIRECTION_UPSTREAM);\r\nrc = mwl8k_post_pervif_cmd(hw, vif, &cmd->header);\r\nwiphy_debug(hw->wiphy, "Created a BA stream for %pM : tid %d\n",\r\nstream->sta->addr, stream->tid);\r\nkfree(cmd);\r\nreturn rc;\r\n}\r\nstatic void mwl8k_destroy_ba(struct ieee80211_hw *hw,\r\nu8 idx)\r\n{\r\nstruct mwl8k_cmd_bastream *cmd;\r\ncmd = kzalloc(sizeof(*cmd), GFP_KERNEL);\r\nif (cmd == NULL)\r\nreturn;\r\ncmd->header.code = cpu_to_le16(MWL8K_CMD_BASTREAM);\r\ncmd->header.length = cpu_to_le16(sizeof(*cmd));\r\ncmd->action = cpu_to_le32(MWL8K_BA_DESTROY);\r\ncmd->destroy_params.ba_context = cpu_to_le32(idx);\r\nmwl8k_post_cmd(hw, &cmd->header);\r\nwiphy_debug(hw->wiphy, "Deleted BA stream index %d\n", idx);\r\nkfree(cmd);\r\n}\r\nstatic int mwl8k_cmd_set_new_stn_add(struct ieee80211_hw *hw,\r\nstruct ieee80211_vif *vif,\r\nstruct ieee80211_sta *sta)\r\n{\r\nstruct mwl8k_cmd_set_new_stn *cmd;\r\nu32 rates;\r\nint rc;\r\ncmd = kzalloc(sizeof(*cmd), GFP_KERNEL);\r\nif (cmd == NULL)\r\nreturn -ENOMEM;\r\ncmd->header.code = cpu_to_le16(MWL8K_CMD_SET_NEW_STN);\r\ncmd->header.length = cpu_to_le16(sizeof(*cmd));\r\ncmd->aid = cpu_to_le16(sta->aid);\r\nmemcpy(cmd->mac_addr, sta->addr, ETH_ALEN);\r\ncmd->stn_id = cpu_to_le16(sta->aid);\r\ncmd->action = cpu_to_le16(MWL8K_STA_ACTION_ADD);\r\nif (hw->conf.chandef.chan->band == IEEE80211_BAND_2GHZ)\r\nrates = sta->supp_rates[IEEE80211_BAND_2GHZ];\r\nelse\r\nrates = sta->supp_rates[IEEE80211_BAND_5GHZ] << 5;\r\ncmd->legacy_rates = cpu_to_le32(rates);\r\nif (sta->ht_cap.ht_supported) {\r\ncmd->ht_rates[0] = sta->ht_cap.mcs.rx_mask[0];\r\ncmd->ht_rates[1] = sta->ht_cap.mcs.rx_mask[1];\r\ncmd->ht_rates[2] = sta->ht_cap.mcs.rx_mask[2];\r\ncmd->ht_rates[3] = sta->ht_cap.mcs.rx_mask[3];\r\ncmd->ht_capabilities_info = cpu_to_le16(sta->ht_cap.cap);\r\ncmd->mac_ht_param_info = (sta->ht_cap.ampdu_factor & 3) |\r\n((sta->ht_cap.ampdu_density & 7) << 2);\r\ncmd->is_qos_sta = 1;\r\n}\r\nrc = mwl8k_post_pervif_cmd(hw, vif, &cmd->header);\r\nkfree(cmd);\r\nreturn rc;\r\n}\r\nstatic int mwl8k_cmd_set_new_stn_add_self(struct ieee80211_hw *hw,\r\nstruct ieee80211_vif *vif)\r\n{\r\nstruct mwl8k_cmd_set_new_stn *cmd;\r\nint rc;\r\ncmd = kzalloc(sizeof(*cmd), GFP_KERNEL);\r\nif (cmd == NULL)\r\nreturn -ENOMEM;\r\ncmd->header.code = cpu_to_le16(MWL8K_CMD_SET_NEW_STN);\r\ncmd->header.length = cpu_to_le16(sizeof(*cmd));\r\nmemcpy(cmd->mac_addr, vif->addr, ETH_ALEN);\r\nrc = mwl8k_post_pervif_cmd(hw, vif, &cmd->header);\r\nkfree(cmd);\r\nreturn rc;\r\n}\r\nstatic int mwl8k_cmd_set_new_stn_del(struct ieee80211_hw *hw,\r\nstruct ieee80211_vif *vif, u8 *addr)\r\n{\r\nstruct mwl8k_cmd_set_new_stn *cmd;\r\nstruct mwl8k_priv *priv = hw->priv;\r\nint rc, i;\r\nu8 idx;\r\nspin_lock(&priv->stream_lock);\r\nfor (i = 0; i < MWL8K_NUM_AMPDU_STREAMS; i++) {\r\nstruct mwl8k_ampdu_stream *s;\r\ns = &priv->ampdu[i];\r\nif (s->state != AMPDU_NO_STREAM) {\r\nif (memcmp(s->sta->addr, addr, ETH_ALEN) == 0) {\r\nif (s->state == AMPDU_STREAM_ACTIVE) {\r\nidx = s->idx;\r\nspin_unlock(&priv->stream_lock);\r\nmwl8k_destroy_ba(hw, idx);\r\nspin_lock(&priv->stream_lock);\r\n} else if (s->state == AMPDU_STREAM_NEW) {\r\nmwl8k_remove_stream(hw, s);\r\n}\r\n}\r\n}\r\n}\r\nspin_unlock(&priv->stream_lock);\r\ncmd = kzalloc(sizeof(*cmd), GFP_KERNEL);\r\nif (cmd == NULL)\r\nreturn -ENOMEM;\r\ncmd->header.code = cpu_to_le16(MWL8K_CMD_SET_NEW_STN);\r\ncmd->header.length = cpu_to_le16(sizeof(*cmd));\r\nmemcpy(cmd->mac_addr, addr, ETH_ALEN);\r\ncmd->action = cpu_to_le16(MWL8K_STA_ACTION_REMOVE);\r\nrc = mwl8k_post_pervif_cmd(hw, vif, &cmd->header);\r\nkfree(cmd);\r\nreturn rc;\r\n}\r\nstatic int mwl8k_cmd_update_encryption_enable(struct ieee80211_hw *hw,\r\nstruct ieee80211_vif *vif,\r\nu8 *addr,\r\nu8 encr_type)\r\n{\r\nstruct mwl8k_cmd_update_encryption *cmd;\r\nint rc;\r\ncmd = kzalloc(sizeof(*cmd), GFP_KERNEL);\r\nif (cmd == NULL)\r\nreturn -ENOMEM;\r\ncmd->header.code = cpu_to_le16(MWL8K_CMD_UPDATE_ENCRYPTION);\r\ncmd->header.length = cpu_to_le16(sizeof(*cmd));\r\ncmd->action = cpu_to_le32(MWL8K_ENCR_ENABLE);\r\nmemcpy(cmd->mac_addr, addr, ETH_ALEN);\r\ncmd->encr_type = encr_type;\r\nrc = mwl8k_post_pervif_cmd(hw, vif, &cmd->header);\r\nkfree(cmd);\r\nreturn rc;\r\n}\r\nstatic int mwl8k_encryption_set_cmd_info(struct mwl8k_cmd_set_key *cmd,\r\nu8 *addr,\r\nstruct ieee80211_key_conf *key)\r\n{\r\ncmd->header.code = cpu_to_le16(MWL8K_CMD_UPDATE_ENCRYPTION);\r\ncmd->header.length = cpu_to_le16(sizeof(*cmd));\r\ncmd->length = cpu_to_le16(sizeof(*cmd) -\r\noffsetof(struct mwl8k_cmd_set_key, length));\r\ncmd->key_id = cpu_to_le32(key->keyidx);\r\ncmd->key_len = cpu_to_le16(key->keylen);\r\nmemcpy(cmd->mac_addr, addr, ETH_ALEN);\r\nswitch (key->cipher) {\r\ncase WLAN_CIPHER_SUITE_WEP40:\r\ncase WLAN_CIPHER_SUITE_WEP104:\r\ncmd->key_type_id = cpu_to_le16(MWL8K_ALG_WEP);\r\nif (key->keyidx == 0)\r\ncmd->key_info = cpu_to_le32(MWL8K_KEY_FLAG_WEP_TXKEY);\r\nbreak;\r\ncase WLAN_CIPHER_SUITE_TKIP:\r\ncmd->key_type_id = cpu_to_le16(MWL8K_ALG_TKIP);\r\ncmd->key_info = (key->flags & IEEE80211_KEY_FLAG_PAIRWISE)\r\n? cpu_to_le32(MWL8K_KEY_FLAG_PAIRWISE)\r\n: cpu_to_le32(MWL8K_KEY_FLAG_TXGROUPKEY);\r\ncmd->key_info |= cpu_to_le32(MWL8K_KEY_FLAG_MICKEY_VALID\r\n| MWL8K_KEY_FLAG_TSC_VALID);\r\nbreak;\r\ncase WLAN_CIPHER_SUITE_CCMP:\r\ncmd->key_type_id = cpu_to_le16(MWL8K_ALG_CCMP);\r\ncmd->key_info = (key->flags & IEEE80211_KEY_FLAG_PAIRWISE)\r\n? cpu_to_le32(MWL8K_KEY_FLAG_PAIRWISE)\r\n: cpu_to_le32(MWL8K_KEY_FLAG_TXGROUPKEY);\r\nbreak;\r\ndefault:\r\nreturn -ENOTSUPP;\r\n}\r\nreturn 0;\r\n}\r\nstatic int mwl8k_cmd_encryption_set_key(struct ieee80211_hw *hw,\r\nstruct ieee80211_vif *vif,\r\nu8 *addr,\r\nstruct ieee80211_key_conf *key)\r\n{\r\nstruct mwl8k_cmd_set_key *cmd;\r\nint rc;\r\nint keymlen;\r\nu32 action;\r\nu8 idx;\r\nstruct mwl8k_vif *mwl8k_vif = MWL8K_VIF(vif);\r\ncmd = kzalloc(sizeof(*cmd), GFP_KERNEL);\r\nif (cmd == NULL)\r\nreturn -ENOMEM;\r\nrc = mwl8k_encryption_set_cmd_info(cmd, addr, key);\r\nif (rc < 0)\r\ngoto done;\r\nidx = key->keyidx;\r\nif (key->flags & IEEE80211_KEY_FLAG_PAIRWISE)\r\naction = MWL8K_ENCR_SET_KEY;\r\nelse\r\naction = MWL8K_ENCR_SET_GROUP_KEY;\r\nswitch (key->cipher) {\r\ncase WLAN_CIPHER_SUITE_WEP40:\r\ncase WLAN_CIPHER_SUITE_WEP104:\r\nif (!mwl8k_vif->wep_key_conf[idx].enabled) {\r\nmemcpy(mwl8k_vif->wep_key_conf[idx].key, key,\r\nsizeof(*key) + key->keylen);\r\nmwl8k_vif->wep_key_conf[idx].enabled = 1;\r\n}\r\nkeymlen = key->keylen;\r\naction = MWL8K_ENCR_SET_KEY;\r\nbreak;\r\ncase WLAN_CIPHER_SUITE_TKIP:\r\nkeymlen = MAX_ENCR_KEY_LENGTH + 2 * MIC_KEY_LENGTH;\r\nbreak;\r\ncase WLAN_CIPHER_SUITE_CCMP:\r\nkeymlen = key->keylen;\r\nbreak;\r\ndefault:\r\nrc = -ENOTSUPP;\r\ngoto done;\r\n}\r\nmemcpy(cmd->key_material, key->key, keymlen);\r\ncmd->action = cpu_to_le32(action);\r\nrc = mwl8k_post_pervif_cmd(hw, vif, &cmd->header);\r\ndone:\r\nkfree(cmd);\r\nreturn rc;\r\n}\r\nstatic int mwl8k_cmd_encryption_remove_key(struct ieee80211_hw *hw,\r\nstruct ieee80211_vif *vif,\r\nu8 *addr,\r\nstruct ieee80211_key_conf *key)\r\n{\r\nstruct mwl8k_cmd_set_key *cmd;\r\nint rc;\r\nstruct mwl8k_vif *mwl8k_vif = MWL8K_VIF(vif);\r\ncmd = kzalloc(sizeof(*cmd), GFP_KERNEL);\r\nif (cmd == NULL)\r\nreturn -ENOMEM;\r\nrc = mwl8k_encryption_set_cmd_info(cmd, addr, key);\r\nif (rc < 0)\r\ngoto done;\r\nif (key->cipher == WLAN_CIPHER_SUITE_WEP40 ||\r\nkey->cipher == WLAN_CIPHER_SUITE_WEP104)\r\nmwl8k_vif->wep_key_conf[key->keyidx].enabled = 0;\r\ncmd->action = cpu_to_le32(MWL8K_ENCR_REMOVE_KEY);\r\nrc = mwl8k_post_pervif_cmd(hw, vif, &cmd->header);\r\ndone:\r\nkfree(cmd);\r\nreturn rc;\r\n}\r\nstatic int mwl8k_set_key(struct ieee80211_hw *hw,\r\nenum set_key_cmd cmd_param,\r\nstruct ieee80211_vif *vif,\r\nstruct ieee80211_sta *sta,\r\nstruct ieee80211_key_conf *key)\r\n{\r\nint rc = 0;\r\nu8 encr_type;\r\nu8 *addr;\r\nstruct mwl8k_vif *mwl8k_vif = MWL8K_VIF(vif);\r\nstruct mwl8k_priv *priv = hw->priv;\r\nif (vif->type == NL80211_IFTYPE_STATION && !priv->ap_fw)\r\nreturn -EOPNOTSUPP;\r\nif (sta == NULL)\r\naddr = vif->addr;\r\nelse\r\naddr = sta->addr;\r\nif (cmd_param == SET_KEY) {\r\nrc = mwl8k_cmd_encryption_set_key(hw, vif, addr, key);\r\nif (rc)\r\ngoto out;\r\nif ((key->cipher == WLAN_CIPHER_SUITE_WEP40)\r\n|| (key->cipher == WLAN_CIPHER_SUITE_WEP104))\r\nencr_type = MWL8K_UPDATE_ENCRYPTION_TYPE_WEP;\r\nelse\r\nencr_type = MWL8K_UPDATE_ENCRYPTION_TYPE_MIXED;\r\nrc = mwl8k_cmd_update_encryption_enable(hw, vif, addr,\r\nencr_type);\r\nif (rc)\r\ngoto out;\r\nmwl8k_vif->is_hw_crypto_enabled = true;\r\n} else {\r\nrc = mwl8k_cmd_encryption_remove_key(hw, vif, addr, key);\r\nif (rc)\r\ngoto out;\r\n}\r\nout:\r\nreturn rc;\r\n}\r\nstatic int mwl8k_cmd_update_stadb_add(struct ieee80211_hw *hw,\r\nstruct ieee80211_vif *vif,\r\nstruct ieee80211_sta *sta)\r\n{\r\nstruct mwl8k_cmd_update_stadb *cmd;\r\nstruct peer_capability_info *p;\r\nu32 rates;\r\nint rc;\r\ncmd = kzalloc(sizeof(*cmd), GFP_KERNEL);\r\nif (cmd == NULL)\r\nreturn -ENOMEM;\r\ncmd->header.code = cpu_to_le16(MWL8K_CMD_UPDATE_STADB);\r\ncmd->header.length = cpu_to_le16(sizeof(*cmd));\r\ncmd->action = cpu_to_le32(MWL8K_STA_DB_MODIFY_ENTRY);\r\nmemcpy(cmd->peer_addr, sta->addr, ETH_ALEN);\r\np = &cmd->peer_info;\r\np->peer_type = MWL8K_PEER_TYPE_ACCESSPOINT;\r\np->basic_caps = cpu_to_le16(vif->bss_conf.assoc_capability);\r\np->ht_support = sta->ht_cap.ht_supported;\r\np->ht_caps = cpu_to_le16(sta->ht_cap.cap);\r\np->extended_ht_caps = (sta->ht_cap.ampdu_factor & 3) |\r\n((sta->ht_cap.ampdu_density & 7) << 2);\r\nif (hw->conf.chandef.chan->band == IEEE80211_BAND_2GHZ)\r\nrates = sta->supp_rates[IEEE80211_BAND_2GHZ];\r\nelse\r\nrates = sta->supp_rates[IEEE80211_BAND_5GHZ] << 5;\r\nlegacy_rate_mask_to_array(p->legacy_rates, rates);\r\nmemcpy(p->ht_rates, sta->ht_cap.mcs.rx_mask, 16);\r\np->interop = 1;\r\np->amsdu_enabled = 0;\r\nrc = mwl8k_post_cmd(hw, &cmd->header);\r\nif (!rc)\r\nrc = p->station_id;\r\nkfree(cmd);\r\nreturn rc;\r\n}\r\nstatic int mwl8k_cmd_update_stadb_del(struct ieee80211_hw *hw,\r\nstruct ieee80211_vif *vif, u8 *addr)\r\n{\r\nstruct mwl8k_cmd_update_stadb *cmd;\r\nint rc;\r\ncmd = kzalloc(sizeof(*cmd), GFP_KERNEL);\r\nif (cmd == NULL)\r\nreturn -ENOMEM;\r\ncmd->header.code = cpu_to_le16(MWL8K_CMD_UPDATE_STADB);\r\ncmd->header.length = cpu_to_le16(sizeof(*cmd));\r\ncmd->action = cpu_to_le32(MWL8K_STA_DB_DEL_ENTRY);\r\nmemcpy(cmd->peer_addr, addr, ETH_ALEN);\r\nrc = mwl8k_post_cmd(hw, &cmd->header);\r\nkfree(cmd);\r\nreturn rc;\r\n}\r\nstatic irqreturn_t mwl8k_interrupt(int irq, void *dev_id)\r\n{\r\nstruct ieee80211_hw *hw = dev_id;\r\nstruct mwl8k_priv *priv = hw->priv;\r\nu32 status;\r\nstatus = ioread32(priv->regs + MWL8K_HIU_A2H_INTERRUPT_STATUS);\r\nif (!status)\r\nreturn IRQ_NONE;\r\nif (status & MWL8K_A2H_INT_TX_DONE) {\r\nstatus &= ~MWL8K_A2H_INT_TX_DONE;\r\ntasklet_schedule(&priv->poll_tx_task);\r\n}\r\nif (status & MWL8K_A2H_INT_RX_READY) {\r\nstatus &= ~MWL8K_A2H_INT_RX_READY;\r\ntasklet_schedule(&priv->poll_rx_task);\r\n}\r\nif (status & MWL8K_A2H_INT_BA_WATCHDOG) {\r\niowrite32(~MWL8K_A2H_INT_BA_WATCHDOG,\r\npriv->regs + MWL8K_HIU_A2H_INTERRUPT_STATUS_MASK);\r\natomic_inc(&priv->watchdog_event_pending);\r\nstatus &= ~MWL8K_A2H_INT_BA_WATCHDOG;\r\nieee80211_queue_work(hw, &priv->watchdog_ba_handle);\r\n}\r\nif (status)\r\niowrite32(~status, priv->regs + MWL8K_HIU_A2H_INTERRUPT_STATUS);\r\nif (status & MWL8K_A2H_INT_OPC_DONE) {\r\nif (priv->hostcmd_wait != NULL)\r\ncomplete(priv->hostcmd_wait);\r\n}\r\nif (status & MWL8K_A2H_INT_QUEUE_EMPTY) {\r\nif (!mutex_is_locked(&priv->fw_mutex) &&\r\npriv->radio_on && priv->pending_tx_pkts)\r\nmwl8k_tx_start(priv);\r\n}\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void mwl8k_tx_poll(unsigned long data)\r\n{\r\nstruct ieee80211_hw *hw = (struct ieee80211_hw *)data;\r\nstruct mwl8k_priv *priv = hw->priv;\r\nint limit;\r\nint i;\r\nlimit = 32;\r\nspin_lock_bh(&priv->tx_lock);\r\nfor (i = 0; i < mwl8k_tx_queues(priv); i++)\r\nlimit -= mwl8k_txq_reclaim(hw, i, limit, 0);\r\nif (!priv->pending_tx_pkts && priv->tx_wait != NULL) {\r\ncomplete(priv->tx_wait);\r\npriv->tx_wait = NULL;\r\n}\r\nspin_unlock_bh(&priv->tx_lock);\r\nif (limit) {\r\nwritel(~MWL8K_A2H_INT_TX_DONE,\r\npriv->regs + MWL8K_HIU_A2H_INTERRUPT_STATUS);\r\n} else {\r\ntasklet_schedule(&priv->poll_tx_task);\r\n}\r\n}\r\nstatic void mwl8k_rx_poll(unsigned long data)\r\n{\r\nstruct ieee80211_hw *hw = (struct ieee80211_hw *)data;\r\nstruct mwl8k_priv *priv = hw->priv;\r\nint limit;\r\nlimit = 32;\r\nlimit -= rxq_process(hw, 0, limit);\r\nlimit -= rxq_refill(hw, 0, limit);\r\nif (limit) {\r\nwritel(~MWL8K_A2H_INT_RX_READY,\r\npriv->regs + MWL8K_HIU_A2H_INTERRUPT_STATUS);\r\n} else {\r\ntasklet_schedule(&priv->poll_rx_task);\r\n}\r\n}\r\nstatic void mwl8k_tx(struct ieee80211_hw *hw,\r\nstruct ieee80211_tx_control *control,\r\nstruct sk_buff *skb)\r\n{\r\nstruct mwl8k_priv *priv = hw->priv;\r\nint index = skb_get_queue_mapping(skb);\r\nif (!priv->radio_on) {\r\nwiphy_debug(hw->wiphy,\r\n"dropped TX frame since radio disabled\n");\r\ndev_kfree_skb(skb);\r\nreturn;\r\n}\r\nmwl8k_txq_xmit(hw, index, control->sta, skb);\r\n}\r\nstatic int mwl8k_start(struct ieee80211_hw *hw)\r\n{\r\nstruct mwl8k_priv *priv = hw->priv;\r\nint rc;\r\nrc = request_irq(priv->pdev->irq, mwl8k_interrupt,\r\nIRQF_SHARED, MWL8K_NAME, hw);\r\nif (rc) {\r\npriv->irq = -1;\r\nwiphy_err(hw->wiphy, "failed to register IRQ handler\n");\r\nreturn -EIO;\r\n}\r\npriv->irq = priv->pdev->irq;\r\ntasklet_enable(&priv->poll_tx_task);\r\ntasklet_enable(&priv->poll_rx_task);\r\niowrite32(MWL8K_A2H_EVENTS, priv->regs + MWL8K_HIU_A2H_INTERRUPT_MASK);\r\niowrite32(MWL8K_A2H_EVENTS,\r\npriv->regs + MWL8K_HIU_A2H_INTERRUPT_STATUS_MASK);\r\nrc = mwl8k_fw_lock(hw);\r\nif (!rc) {\r\nrc = mwl8k_cmd_radio_enable(hw);\r\nif (!priv->ap_fw) {\r\nif (!rc)\r\nrc = mwl8k_cmd_enable_sniffer(hw, 0);\r\nif (!rc)\r\nrc = mwl8k_cmd_set_pre_scan(hw);\r\nif (!rc)\r\nrc = mwl8k_cmd_set_post_scan(hw,\r\n"\x00\x00\x00\x00\x00\x00");\r\n}\r\nif (!rc)\r\nrc = mwl8k_cmd_set_rateadapt_mode(hw, 0);\r\nif (!rc)\r\nrc = mwl8k_cmd_set_wmm_mode(hw, 0);\r\nmwl8k_fw_unlock(hw);\r\n}\r\nif (rc) {\r\niowrite32(0, priv->regs + MWL8K_HIU_A2H_INTERRUPT_MASK);\r\nfree_irq(priv->pdev->irq, hw);\r\npriv->irq = -1;\r\ntasklet_disable(&priv->poll_tx_task);\r\ntasklet_disable(&priv->poll_rx_task);\r\n} else {\r\nieee80211_wake_queues(hw);\r\n}\r\nreturn rc;\r\n}\r\nstatic void mwl8k_stop(struct ieee80211_hw *hw)\r\n{\r\nstruct mwl8k_priv *priv = hw->priv;\r\nint i;\r\nif (!priv->hw_restart_in_progress)\r\nmwl8k_cmd_radio_disable(hw);\r\nieee80211_stop_queues(hw);\r\niowrite32(0, priv->regs + MWL8K_HIU_A2H_INTERRUPT_MASK);\r\nif (priv->irq != -1) {\r\nfree_irq(priv->pdev->irq, hw);\r\npriv->irq = -1;\r\n}\r\ncancel_work_sync(&priv->finalize_join_worker);\r\ncancel_work_sync(&priv->watchdog_ba_handle);\r\nif (priv->beacon_skb != NULL)\r\ndev_kfree_skb(priv->beacon_skb);\r\ntasklet_disable(&priv->poll_tx_task);\r\ntasklet_disable(&priv->poll_rx_task);\r\nfor (i = 0; i < mwl8k_tx_queues(priv); i++)\r\nmwl8k_txq_reclaim(hw, i, INT_MAX, 1);\r\n}\r\nstatic int mwl8k_add_interface(struct ieee80211_hw *hw,\r\nstruct ieee80211_vif *vif)\r\n{\r\nstruct mwl8k_priv *priv = hw->priv;\r\nstruct mwl8k_vif *mwl8k_vif;\r\nu32 macids_supported;\r\nint macid, rc;\r\nstruct mwl8k_device_info *di;\r\nif (priv->sniffer_enabled) {\r\nwiphy_info(hw->wiphy,\r\n"unable to create STA interface because sniffer mode is enabled\n");\r\nreturn -EINVAL;\r\n}\r\ndi = priv->device_info;\r\nswitch (vif->type) {\r\ncase NL80211_IFTYPE_AP:\r\nif (!priv->ap_fw && di->fw_image_ap) {\r\nif (!list_empty(&priv->vif_list))\r\nreturn -EBUSY;\r\nrc = mwl8k_reload_firmware(hw, di->fw_image_ap);\r\nif (rc)\r\nreturn rc;\r\n}\r\nmacids_supported = priv->ap_macids_supported;\r\nbreak;\r\ncase NL80211_IFTYPE_STATION:\r\nif (priv->ap_fw && di->fw_image_sta) {\r\nif (!list_empty(&priv->vif_list)) {\r\nwiphy_warn(hw->wiphy, "AP interface is running.\n"\r\n"Adding STA interface for WDS");\r\n} else {\r\nrc = mwl8k_reload_firmware(hw,\r\ndi->fw_image_sta);\r\nif (rc)\r\nreturn rc;\r\n}\r\n}\r\nmacids_supported = priv->sta_macids_supported;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nmacid = ffs(macids_supported & ~priv->macids_used);\r\nif (!macid--)\r\nreturn -EBUSY;\r\nmwl8k_vif = MWL8K_VIF(vif);\r\nmemset(mwl8k_vif, 0, sizeof(*mwl8k_vif));\r\nmwl8k_vif->vif = vif;\r\nmwl8k_vif->macid = macid;\r\nmwl8k_vif->seqno = 0;\r\nmemcpy(mwl8k_vif->bssid, vif->addr, ETH_ALEN);\r\nmwl8k_vif->is_hw_crypto_enabled = false;\r\nmwl8k_cmd_set_mac_addr(hw, vif, vif->addr);\r\nif (vif->type == NL80211_IFTYPE_AP)\r\nmwl8k_cmd_set_new_stn_add_self(hw, vif);\r\npriv->macids_used |= 1 << mwl8k_vif->macid;\r\nlist_add_tail(&mwl8k_vif->list, &priv->vif_list);\r\nreturn 0;\r\n}\r\nstatic void mwl8k_remove_vif(struct mwl8k_priv *priv, struct mwl8k_vif *vif)\r\n{\r\nif (!priv->macids_used)\r\nreturn;\r\npriv->macids_used &= ~(1 << vif->macid);\r\nlist_del(&vif->list);\r\n}\r\nstatic void mwl8k_remove_interface(struct ieee80211_hw *hw,\r\nstruct ieee80211_vif *vif)\r\n{\r\nstruct mwl8k_priv *priv = hw->priv;\r\nstruct mwl8k_vif *mwl8k_vif = MWL8K_VIF(vif);\r\nif (vif->type == NL80211_IFTYPE_AP)\r\nmwl8k_cmd_set_new_stn_del(hw, vif, vif->addr);\r\nmwl8k_cmd_del_mac_addr(hw, vif, vif->addr);\r\nmwl8k_remove_vif(priv, mwl8k_vif);\r\n}\r\nstatic void mwl8k_hw_restart_work(struct work_struct *work)\r\n{\r\nstruct mwl8k_priv *priv =\r\ncontainer_of(work, struct mwl8k_priv, fw_reload);\r\nstruct ieee80211_hw *hw = priv->hw;\r\nstruct mwl8k_device_info *di;\r\nint rc;\r\nif (priv->hostcmd_wait != NULL) {\r\ncomplete(priv->hostcmd_wait);\r\npriv->hostcmd_wait = NULL;\r\n}\r\npriv->hw_restart_owner = current;\r\ndi = priv->device_info;\r\nmwl8k_fw_lock(hw);\r\nif (priv->ap_fw)\r\nrc = mwl8k_reload_firmware(hw, di->fw_image_ap);\r\nelse\r\nrc = mwl8k_reload_firmware(hw, di->fw_image_sta);\r\nif (rc)\r\ngoto fail;\r\npriv->hw_restart_owner = NULL;\r\npriv->hw_restart_in_progress = false;\r\nmwl8k_fw_unlock(hw);\r\nieee80211_restart_hw(hw);\r\nwiphy_err(hw->wiphy, "Firmware restarted successfully\n");\r\nreturn;\r\nfail:\r\nmwl8k_fw_unlock(hw);\r\nwiphy_err(hw->wiphy, "Firmware restart failed\n");\r\n}\r\nstatic int mwl8k_config(struct ieee80211_hw *hw, u32 changed)\r\n{\r\nstruct ieee80211_conf *conf = &hw->conf;\r\nstruct mwl8k_priv *priv = hw->priv;\r\nint rc;\r\nrc = mwl8k_fw_lock(hw);\r\nif (rc)\r\nreturn rc;\r\nif (conf->flags & IEEE80211_CONF_IDLE)\r\nrc = mwl8k_cmd_radio_disable(hw);\r\nelse\r\nrc = mwl8k_cmd_radio_enable(hw);\r\nif (rc)\r\ngoto out;\r\nif (changed & IEEE80211_CONF_CHANGE_CHANNEL) {\r\nrc = mwl8k_cmd_set_rf_channel(hw, conf);\r\nif (rc)\r\ngoto out;\r\n}\r\nif (conf->power_level > 18)\r\nconf->power_level = 18;\r\nif (priv->ap_fw) {\r\nif (conf->flags & IEEE80211_CONF_CHANGE_POWER) {\r\nrc = mwl8k_cmd_tx_power(hw, conf, conf->power_level);\r\nif (rc)\r\ngoto out;\r\n}\r\n} else {\r\nrc = mwl8k_cmd_rf_tx_power(hw, conf->power_level);\r\nif (rc)\r\ngoto out;\r\nrc = mwl8k_cmd_mimo_config(hw, 0x7, 0x7);\r\n}\r\nout:\r\nmwl8k_fw_unlock(hw);\r\nreturn rc;\r\n}\r\nstatic void\r\nmwl8k_bss_info_changed_sta(struct ieee80211_hw *hw, struct ieee80211_vif *vif,\r\nstruct ieee80211_bss_conf *info, u32 changed)\r\n{\r\nstruct mwl8k_priv *priv = hw->priv;\r\nu32 ap_legacy_rates = 0;\r\nu8 ap_mcs_rates[16];\r\nint rc;\r\nif (mwl8k_fw_lock(hw))\r\nreturn;\r\nif ((changed & BSS_CHANGED_ASSOC) && !vif->bss_conf.assoc)\r\npriv->capture_beacon = false;\r\nif (vif->bss_conf.assoc) {\r\nstruct ieee80211_sta *ap;\r\nrcu_read_lock();\r\nap = ieee80211_find_sta(vif, vif->bss_conf.bssid);\r\nif (ap == NULL) {\r\nrcu_read_unlock();\r\ngoto out;\r\n}\r\nif (hw->conf.chandef.chan->band == IEEE80211_BAND_2GHZ) {\r\nap_legacy_rates = ap->supp_rates[IEEE80211_BAND_2GHZ];\r\n} else {\r\nap_legacy_rates =\r\nap->supp_rates[IEEE80211_BAND_5GHZ] << 5;\r\n}\r\nmemcpy(ap_mcs_rates, ap->ht_cap.mcs.rx_mask, 16);\r\nrcu_read_unlock();\r\nif (changed & BSS_CHANGED_ASSOC) {\r\nif (!priv->ap_fw) {\r\nrc = mwl8k_cmd_set_rate(hw, vif,\r\nap_legacy_rates,\r\nap_mcs_rates);\r\nif (rc)\r\ngoto out;\r\nrc = mwl8k_cmd_use_fixed_rate_sta(hw);\r\nif (rc)\r\ngoto out;\r\n} else {\r\nint idx;\r\nint rate;\r\nidx = ffs(vif->bss_conf.basic_rates);\r\nif (idx)\r\nidx--;\r\nif (hw->conf.chandef.chan->band ==\r\nIEEE80211_BAND_2GHZ)\r\nrate = mwl8k_rates_24[idx].hw_value;\r\nelse\r\nrate = mwl8k_rates_50[idx].hw_value;\r\nmwl8k_cmd_use_fixed_rate_ap(hw, rate, rate);\r\n}\r\n}\r\n}\r\nif (changed & BSS_CHANGED_ERP_PREAMBLE) {\r\nrc = mwl8k_set_radio_preamble(hw,\r\nvif->bss_conf.use_short_preamble);\r\nif (rc)\r\ngoto out;\r\n}\r\nif ((changed & BSS_CHANGED_ERP_SLOT) && !priv->ap_fw) {\r\nrc = mwl8k_cmd_set_slot(hw, vif->bss_conf.use_short_slot);\r\nif (rc)\r\ngoto out;\r\n}\r\nif (vif->bss_conf.assoc && !priv->ap_fw &&\r\n(changed & (BSS_CHANGED_ASSOC | BSS_CHANGED_ERP_CTS_PROT |\r\nBSS_CHANGED_HT))) {\r\nrc = mwl8k_cmd_set_aid(hw, vif, ap_legacy_rates);\r\nif (rc)\r\ngoto out;\r\n}\r\nif (vif->bss_conf.assoc &&\r\n(changed & (BSS_CHANGED_ASSOC | BSS_CHANGED_BEACON_INT))) {\r\nmemcpy(priv->capture_bssid, vif->bss_conf.bssid, ETH_ALEN);\r\npriv->capture_beacon = true;\r\n}\r\nout:\r\nmwl8k_fw_unlock(hw);\r\n}\r\nstatic void\r\nmwl8k_bss_info_changed_ap(struct ieee80211_hw *hw, struct ieee80211_vif *vif,\r\nstruct ieee80211_bss_conf *info, u32 changed)\r\n{\r\nint rc;\r\nif (mwl8k_fw_lock(hw))\r\nreturn;\r\nif (changed & BSS_CHANGED_ERP_PREAMBLE) {\r\nrc = mwl8k_set_radio_preamble(hw,\r\nvif->bss_conf.use_short_preamble);\r\nif (rc)\r\ngoto out;\r\n}\r\nif (changed & BSS_CHANGED_BASIC_RATES) {\r\nint idx;\r\nint rate;\r\nidx = ffs(vif->bss_conf.basic_rates);\r\nif (idx)\r\nidx--;\r\nif (hw->conf.chandef.chan->band == IEEE80211_BAND_2GHZ)\r\nrate = mwl8k_rates_24[idx].hw_value;\r\nelse\r\nrate = mwl8k_rates_50[idx].hw_value;\r\nmwl8k_cmd_use_fixed_rate_ap(hw, rate, rate);\r\n}\r\nif (changed & (BSS_CHANGED_BEACON_INT | BSS_CHANGED_BEACON)) {\r\nstruct sk_buff *skb;\r\nskb = ieee80211_beacon_get(hw, vif);\r\nif (skb != NULL) {\r\nmwl8k_cmd_set_beacon(hw, vif, skb->data, skb->len);\r\nkfree_skb(skb);\r\n}\r\n}\r\nif (changed & BSS_CHANGED_BEACON_ENABLED)\r\nmwl8k_cmd_bss_start(hw, vif, info->enable_beacon);\r\nout:\r\nmwl8k_fw_unlock(hw);\r\n}\r\nstatic void\r\nmwl8k_bss_info_changed(struct ieee80211_hw *hw, struct ieee80211_vif *vif,\r\nstruct ieee80211_bss_conf *info, u32 changed)\r\n{\r\nif (vif->type == NL80211_IFTYPE_STATION)\r\nmwl8k_bss_info_changed_sta(hw, vif, info, changed);\r\nif (vif->type == NL80211_IFTYPE_AP)\r\nmwl8k_bss_info_changed_ap(hw, vif, info, changed);\r\n}\r\nstatic u64 mwl8k_prepare_multicast(struct ieee80211_hw *hw,\r\nstruct netdev_hw_addr_list *mc_list)\r\n{\r\nstruct mwl8k_cmd_pkt *cmd;\r\ncmd = __mwl8k_cmd_mac_multicast_adr(hw, 0, mc_list);\r\nreturn (unsigned long)cmd;\r\n}\r\nstatic int\r\nmwl8k_configure_filter_sniffer(struct ieee80211_hw *hw,\r\nunsigned int changed_flags,\r\nunsigned int *total_flags)\r\n{\r\nstruct mwl8k_priv *priv = hw->priv;\r\nif (!list_empty(&priv->vif_list)) {\r\nif (net_ratelimit())\r\nwiphy_info(hw->wiphy,\r\n"not enabling sniffer mode because STA interface is active\n");\r\nreturn 0;\r\n}\r\nif (!priv->sniffer_enabled) {\r\nif (mwl8k_cmd_enable_sniffer(hw, 1))\r\nreturn 0;\r\npriv->sniffer_enabled = true;\r\n}\r\n*total_flags &= FIF_ALLMULTI |\r\nFIF_BCN_PRBRESP_PROMISC | FIF_CONTROL |\r\nFIF_OTHER_BSS;\r\nreturn 1;\r\n}\r\nstatic struct mwl8k_vif *mwl8k_first_vif(struct mwl8k_priv *priv)\r\n{\r\nif (!list_empty(&priv->vif_list))\r\nreturn list_entry(priv->vif_list.next, struct mwl8k_vif, list);\r\nreturn NULL;\r\n}\r\nstatic void mwl8k_configure_filter(struct ieee80211_hw *hw,\r\nunsigned int changed_flags,\r\nunsigned int *total_flags,\r\nu64 multicast)\r\n{\r\nstruct mwl8k_priv *priv = hw->priv;\r\nstruct mwl8k_cmd_pkt *cmd = (void *)(unsigned long)multicast;\r\nif (priv->ap_fw) {\r\n*total_flags &= FIF_ALLMULTI | FIF_BCN_PRBRESP_PROMISC;\r\nkfree(cmd);\r\nreturn;\r\n}\r\nif (*total_flags & (FIF_CONTROL | FIF_OTHER_BSS) &&\r\nmwl8k_configure_filter_sniffer(hw, changed_flags, total_flags)) {\r\nkfree(cmd);\r\nreturn;\r\n}\r\n*total_flags &= FIF_ALLMULTI | FIF_BCN_PRBRESP_PROMISC;\r\nif (mwl8k_fw_lock(hw)) {\r\nkfree(cmd);\r\nreturn;\r\n}\r\nif (priv->sniffer_enabled) {\r\nmwl8k_cmd_enable_sniffer(hw, 0);\r\npriv->sniffer_enabled = false;\r\n}\r\nif (changed_flags & FIF_BCN_PRBRESP_PROMISC) {\r\nif (*total_flags & FIF_BCN_PRBRESP_PROMISC) {\r\nmwl8k_cmd_set_pre_scan(hw);\r\n} else {\r\nstruct mwl8k_vif *mwl8k_vif;\r\nconst u8 *bssid;\r\nmwl8k_vif = mwl8k_first_vif(priv);\r\nif (mwl8k_vif != NULL)\r\nbssid = mwl8k_vif->vif->bss_conf.bssid;\r\nelse\r\nbssid = "\x01\x00\x00\x00\x00\x00";\r\nmwl8k_cmd_set_post_scan(hw, bssid);\r\n}\r\n}\r\nif (*total_flags & FIF_ALLMULTI) {\r\nkfree(cmd);\r\ncmd = __mwl8k_cmd_mac_multicast_adr(hw, 1, NULL);\r\n}\r\nif (cmd != NULL) {\r\nmwl8k_post_cmd(hw, cmd);\r\nkfree(cmd);\r\n}\r\nmwl8k_fw_unlock(hw);\r\n}\r\nstatic int mwl8k_set_rts_threshold(struct ieee80211_hw *hw, u32 value)\r\n{\r\nreturn mwl8k_cmd_set_rts_threshold(hw, value);\r\n}\r\nstatic int mwl8k_sta_remove(struct ieee80211_hw *hw,\r\nstruct ieee80211_vif *vif,\r\nstruct ieee80211_sta *sta)\r\n{\r\nstruct mwl8k_priv *priv = hw->priv;\r\nif (priv->ap_fw)\r\nreturn mwl8k_cmd_set_new_stn_del(hw, vif, sta->addr);\r\nelse\r\nreturn mwl8k_cmd_update_stadb_del(hw, vif, sta->addr);\r\n}\r\nstatic int mwl8k_sta_add(struct ieee80211_hw *hw,\r\nstruct ieee80211_vif *vif,\r\nstruct ieee80211_sta *sta)\r\n{\r\nstruct mwl8k_priv *priv = hw->priv;\r\nint ret;\r\nint i;\r\nstruct mwl8k_vif *mwl8k_vif = MWL8K_VIF(vif);\r\nstruct ieee80211_key_conf *key;\r\nif (!priv->ap_fw) {\r\nret = mwl8k_cmd_update_stadb_add(hw, vif, sta);\r\nif (ret >= 0) {\r\nMWL8K_STA(sta)->peer_id = ret;\r\nif (sta->ht_cap.ht_supported)\r\nMWL8K_STA(sta)->is_ampdu_allowed = true;\r\nret = 0;\r\n}\r\n} else {\r\nret = mwl8k_cmd_set_new_stn_add(hw, vif, sta);\r\n}\r\nfor (i = 0; i < NUM_WEP_KEYS; i++) {\r\nkey = IEEE80211_KEY_CONF(mwl8k_vif->wep_key_conf[i].key);\r\nif (mwl8k_vif->wep_key_conf[i].enabled)\r\nmwl8k_set_key(hw, SET_KEY, vif, sta, key);\r\n}\r\nreturn ret;\r\n}\r\nstatic int mwl8k_conf_tx(struct ieee80211_hw *hw,\r\nstruct ieee80211_vif *vif, u16 queue,\r\nconst struct ieee80211_tx_queue_params *params)\r\n{\r\nstruct mwl8k_priv *priv = hw->priv;\r\nint rc;\r\nrc = mwl8k_fw_lock(hw);\r\nif (!rc) {\r\nBUG_ON(queue > MWL8K_TX_WMM_QUEUES - 1);\r\nmemcpy(&priv->wmm_params[queue], params, sizeof(*params));\r\nif (!priv->wmm_enabled)\r\nrc = mwl8k_cmd_set_wmm_mode(hw, 1);\r\nif (!rc) {\r\nint q = MWL8K_TX_WMM_QUEUES - 1 - queue;\r\nrc = mwl8k_cmd_set_edca_params(hw, q,\r\nparams->cw_min,\r\nparams->cw_max,\r\nparams->aifs,\r\nparams->txop);\r\n}\r\nmwl8k_fw_unlock(hw);\r\n}\r\nreturn rc;\r\n}\r\nstatic int mwl8k_get_stats(struct ieee80211_hw *hw,\r\nstruct ieee80211_low_level_stats *stats)\r\n{\r\nreturn mwl8k_cmd_get_stat(hw, stats);\r\n}\r\nstatic int mwl8k_get_survey(struct ieee80211_hw *hw, int idx,\r\nstruct survey_info *survey)\r\n{\r\nstruct mwl8k_priv *priv = hw->priv;\r\nstruct ieee80211_conf *conf = &hw->conf;\r\nstruct ieee80211_supported_band *sband;\r\nif (priv->ap_fw) {\r\nsband = hw->wiphy->bands[IEEE80211_BAND_2GHZ];\r\nif (sband && idx >= sband->n_channels) {\r\nidx -= sband->n_channels;\r\nsband = NULL;\r\n}\r\nif (!sband)\r\nsband = hw->wiphy->bands[IEEE80211_BAND_5GHZ];\r\nif (!sband || idx >= sband->n_channels)\r\nreturn -ENOENT;\r\nmemcpy(survey, &priv->survey[idx], sizeof(*survey));\r\nsurvey->channel = &sband->channels[idx];\r\nreturn 0;\r\n}\r\nif (idx != 0)\r\nreturn -ENOENT;\r\nsurvey->channel = conf->chandef.chan;\r\nsurvey->filled = SURVEY_INFO_NOISE_DBM;\r\nsurvey->noise = priv->noise;\r\nreturn 0;\r\n}\r\nstatic int\r\nmwl8k_ampdu_action(struct ieee80211_hw *hw, struct ieee80211_vif *vif,\r\nenum ieee80211_ampdu_mlme_action action,\r\nstruct ieee80211_sta *sta, u16 tid, u16 *ssn,\r\nu8 buf_size, bool amsdu)\r\n{\r\nint i, rc = 0;\r\nstruct mwl8k_priv *priv = hw->priv;\r\nstruct mwl8k_ampdu_stream *stream;\r\nu8 *addr = sta->addr, idx;\r\nstruct mwl8k_sta *sta_info = MWL8K_STA(sta);\r\nif (!ieee80211_hw_check(hw, AMPDU_AGGREGATION))\r\nreturn -ENOTSUPP;\r\nspin_lock(&priv->stream_lock);\r\nstream = mwl8k_lookup_stream(hw, addr, tid);\r\nswitch (action) {\r\ncase IEEE80211_AMPDU_RX_START:\r\ncase IEEE80211_AMPDU_RX_STOP:\r\nbreak;\r\ncase IEEE80211_AMPDU_TX_START:\r\n*ssn = 0;\r\nif (stream == NULL) {\r\nwiphy_warn(hw->wiphy, "Unexpected call to %s. "\r\n"Proceeding anyway.\n", __func__);\r\nstream = mwl8k_add_stream(hw, sta, tid);\r\n}\r\nif (stream == NULL) {\r\nwiphy_debug(hw->wiphy, "no free AMPDU streams\n");\r\nrc = -EBUSY;\r\nbreak;\r\n}\r\nstream->state = AMPDU_STREAM_IN_PROGRESS;\r\nspin_unlock(&priv->stream_lock);\r\nfor (i = 0; i < MAX_AMPDU_ATTEMPTS; i++) {\r\nif (!sta_info->is_ampdu_allowed) {\r\nspin_lock(&priv->stream_lock);\r\nmwl8k_remove_stream(hw, stream);\r\nspin_unlock(&priv->stream_lock);\r\nreturn -EBUSY;\r\n}\r\nrc = mwl8k_check_ba(hw, stream, vif);\r\nif (!rc || rc == -EBUSY)\r\nbreak;\r\nmsleep(1000);\r\n}\r\nspin_lock(&priv->stream_lock);\r\nif (rc) {\r\nwiphy_err(hw->wiphy, "Stream for tid %d busy after %d"\r\n" attempts\n", tid, MAX_AMPDU_ATTEMPTS);\r\nmwl8k_remove_stream(hw, stream);\r\nrc = -EBUSY;\r\nbreak;\r\n}\r\nieee80211_start_tx_ba_cb_irqsafe(vif, addr, tid);\r\nbreak;\r\ncase IEEE80211_AMPDU_TX_STOP_CONT:\r\ncase IEEE80211_AMPDU_TX_STOP_FLUSH:\r\ncase IEEE80211_AMPDU_TX_STOP_FLUSH_CONT:\r\nif (stream) {\r\nif (stream->state == AMPDU_STREAM_ACTIVE) {\r\nidx = stream->idx;\r\nspin_unlock(&priv->stream_lock);\r\nmwl8k_destroy_ba(hw, idx);\r\nspin_lock(&priv->stream_lock);\r\n}\r\nmwl8k_remove_stream(hw, stream);\r\n}\r\nieee80211_stop_tx_ba_cb_irqsafe(vif, addr, tid);\r\nbreak;\r\ncase IEEE80211_AMPDU_TX_OPERATIONAL:\r\nBUG_ON(stream == NULL);\r\nBUG_ON(stream->state != AMPDU_STREAM_IN_PROGRESS);\r\nspin_unlock(&priv->stream_lock);\r\nrc = mwl8k_create_ba(hw, stream, buf_size, vif);\r\nspin_lock(&priv->stream_lock);\r\nif (!rc)\r\nstream->state = AMPDU_STREAM_ACTIVE;\r\nelse {\r\nidx = stream->idx;\r\nspin_unlock(&priv->stream_lock);\r\nmwl8k_destroy_ba(hw, idx);\r\nspin_lock(&priv->stream_lock);\r\nwiphy_debug(hw->wiphy,\r\n"Failed adding stream for sta %pM tid %d\n",\r\naddr, tid);\r\nmwl8k_remove_stream(hw, stream);\r\n}\r\nbreak;\r\ndefault:\r\nrc = -ENOTSUPP;\r\n}\r\nspin_unlock(&priv->stream_lock);\r\nreturn rc;\r\n}\r\nstatic void mwl8k_sw_scan_start(struct ieee80211_hw *hw,\r\nstruct ieee80211_vif *vif,\r\nconst u8 *mac_addr)\r\n{\r\nstruct mwl8k_priv *priv = hw->priv;\r\nu8 tmp;\r\nif (!priv->ap_fw)\r\nreturn;\r\npriv->channel_time = 0;\r\nioread32(priv->regs + BBU_RXRDY_CNT_REG);\r\nioread32(priv->regs + NOK_CCA_CNT_REG);\r\nmwl8k_cmd_bbp_reg_access(priv->hw, 0, BBU_AVG_NOISE_VAL, &tmp);\r\npriv->sw_scan_start = true;\r\n}\r\nstatic void mwl8k_sw_scan_complete(struct ieee80211_hw *hw,\r\nstruct ieee80211_vif *vif)\r\n{\r\nstruct mwl8k_priv *priv = hw->priv;\r\nu8 tmp;\r\nif (!priv->ap_fw)\r\nreturn;\r\npriv->sw_scan_start = false;\r\npriv->channel_time = 0;\r\nioread32(priv->regs + BBU_RXRDY_CNT_REG);\r\nioread32(priv->regs + NOK_CCA_CNT_REG);\r\nmwl8k_cmd_bbp_reg_access(priv->hw, 0, BBU_AVG_NOISE_VAL, &tmp);\r\n}\r\nstatic void mwl8k_finalize_join_worker(struct work_struct *work)\r\n{\r\nstruct mwl8k_priv *priv =\r\ncontainer_of(work, struct mwl8k_priv, finalize_join_worker);\r\nstruct sk_buff *skb = priv->beacon_skb;\r\nstruct ieee80211_mgmt *mgmt = (void *)skb->data;\r\nint len = skb->len - offsetof(struct ieee80211_mgmt, u.beacon.variable);\r\nconst u8 *tim = cfg80211_find_ie(WLAN_EID_TIM,\r\nmgmt->u.beacon.variable, len);\r\nint dtim_period = 1;\r\nif (tim && tim[1] >= 2)\r\ndtim_period = tim[3];\r\nmwl8k_cmd_finalize_join(priv->hw, skb->data, skb->len, dtim_period);\r\ndev_kfree_skb(skb);\r\npriv->beacon_skb = NULL;\r\n}\r\nstatic int mwl8k_request_alt_fw(struct mwl8k_priv *priv)\r\n{\r\nint rc;\r\nprintk(KERN_ERR "%s: Error requesting preferred fw %s.\n"\r\n"Trying alternative firmware %s\n", pci_name(priv->pdev),\r\npriv->fw_pref, priv->fw_alt);\r\nrc = mwl8k_request_fw(priv, priv->fw_alt, &priv->fw_ucode, true);\r\nif (rc) {\r\nprintk(KERN_ERR "%s: Error requesting alt fw %s\n",\r\npci_name(priv->pdev), priv->fw_alt);\r\nreturn rc;\r\n}\r\nreturn 0;\r\n}\r\nstatic void mwl8k_fw_state_machine(const struct firmware *fw, void *context)\r\n{\r\nstruct mwl8k_priv *priv = context;\r\nstruct mwl8k_device_info *di = priv->device_info;\r\nint rc;\r\nswitch (priv->fw_state) {\r\ncase FW_STATE_INIT:\r\nif (!fw) {\r\nprintk(KERN_ERR "%s: Error requesting helper fw %s\n",\r\npci_name(priv->pdev), di->helper_image);\r\ngoto fail;\r\n}\r\npriv->fw_helper = fw;\r\nrc = mwl8k_request_fw(priv, priv->fw_pref, &priv->fw_ucode,\r\ntrue);\r\nif (rc && priv->fw_alt) {\r\nrc = mwl8k_request_alt_fw(priv);\r\nif (rc)\r\ngoto fail;\r\npriv->fw_state = FW_STATE_LOADING_ALT;\r\n} else if (rc)\r\ngoto fail;\r\nelse\r\npriv->fw_state = FW_STATE_LOADING_PREF;\r\nbreak;\r\ncase FW_STATE_LOADING_PREF:\r\nif (!fw) {\r\nif (priv->fw_alt) {\r\nrc = mwl8k_request_alt_fw(priv);\r\nif (rc)\r\ngoto fail;\r\npriv->fw_state = FW_STATE_LOADING_ALT;\r\n} else\r\ngoto fail;\r\n} else {\r\npriv->fw_ucode = fw;\r\nrc = mwl8k_firmware_load_success(priv);\r\nif (rc)\r\ngoto fail;\r\nelse\r\ncomplete(&priv->firmware_loading_complete);\r\n}\r\nbreak;\r\ncase FW_STATE_LOADING_ALT:\r\nif (!fw) {\r\nprintk(KERN_ERR "%s: Error requesting alt fw %s\n",\r\npci_name(priv->pdev), di->helper_image);\r\ngoto fail;\r\n}\r\npriv->fw_ucode = fw;\r\nrc = mwl8k_firmware_load_success(priv);\r\nif (rc)\r\ngoto fail;\r\nelse\r\ncomplete(&priv->firmware_loading_complete);\r\nbreak;\r\ndefault:\r\nprintk(KERN_ERR "%s: Unexpected firmware loading state: %d\n",\r\nMWL8K_NAME, priv->fw_state);\r\nBUG_ON(1);\r\n}\r\nreturn;\r\nfail:\r\npriv->fw_state = FW_STATE_ERROR;\r\ncomplete(&priv->firmware_loading_complete);\r\ndevice_release_driver(&priv->pdev->dev);\r\nmwl8k_release_firmware(priv);\r\n}\r\nstatic int mwl8k_init_firmware(struct ieee80211_hw *hw, char *fw_image,\r\nbool nowait)\r\n{\r\nstruct mwl8k_priv *priv = hw->priv;\r\nint rc;\r\nint count = MAX_RESTART_ATTEMPTS;\r\nretry:\r\nmwl8k_hw_reset(priv);\r\nrc = mwl8k_request_firmware(priv, fw_image, nowait);\r\nif (rc) {\r\nwiphy_err(hw->wiphy, "Firmware files not found\n");\r\nreturn rc;\r\n}\r\nif (nowait)\r\nreturn rc;\r\nrc = mwl8k_load_firmware(hw);\r\nif (rc)\r\nwiphy_err(hw->wiphy, "Cannot start firmware\n");\r\nmwl8k_release_firmware(priv);\r\nif (rc && count) {\r\ncount--;\r\nwiphy_err(hw->wiphy, "Trying to reload the firmware again\n");\r\nmsleep(20);\r\ngoto retry;\r\n}\r\nreturn rc;\r\n}\r\nstatic int mwl8k_init_txqs(struct ieee80211_hw *hw)\r\n{\r\nstruct mwl8k_priv *priv = hw->priv;\r\nint rc = 0;\r\nint i;\r\nfor (i = 0; i < mwl8k_tx_queues(priv); i++) {\r\nrc = mwl8k_txq_init(hw, i);\r\nif (rc)\r\nbreak;\r\nif (priv->ap_fw)\r\niowrite32(priv->txq[i].txd_dma,\r\npriv->sram + priv->txq_offset[i]);\r\n}\r\nreturn rc;\r\n}\r\nstatic int mwl8k_probe_hw(struct ieee80211_hw *hw)\r\n{\r\nstruct mwl8k_priv *priv = hw->priv;\r\nint rc = 0;\r\nint i;\r\nif (priv->ap_fw) {\r\npriv->rxd_ops = priv->device_info->ap_rxd_ops;\r\nif (priv->rxd_ops == NULL) {\r\nwiphy_err(hw->wiphy,\r\n"Driver does not have AP firmware image support for this hardware\n");\r\nrc = -ENOENT;\r\ngoto err_stop_firmware;\r\n}\r\n} else {\r\npriv->rxd_ops = &rxd_sta_ops;\r\n}\r\npriv->sniffer_enabled = false;\r\npriv->wmm_enabled = false;\r\npriv->pending_tx_pkts = 0;\r\natomic_set(&priv->watchdog_event_pending, 0);\r\nrc = mwl8k_rxq_init(hw, 0);\r\nif (rc)\r\ngoto err_stop_firmware;\r\nrxq_refill(hw, 0, INT_MAX);\r\npriv->num_ampdu_queues = 0;\r\nif (!priv->ap_fw) {\r\nrc = mwl8k_init_txqs(hw);\r\nif (rc)\r\ngoto err_free_queues;\r\n}\r\niowrite32(0, priv->regs + MWL8K_HIU_A2H_INTERRUPT_STATUS);\r\niowrite32(0, priv->regs + MWL8K_HIU_A2H_INTERRUPT_MASK);\r\niowrite32(MWL8K_A2H_INT_TX_DONE|MWL8K_A2H_INT_RX_READY|\r\nMWL8K_A2H_INT_BA_WATCHDOG,\r\npriv->regs + MWL8K_HIU_A2H_INTERRUPT_CLEAR_SEL);\r\niowrite32(MWL8K_A2H_INT_OPC_DONE,\r\npriv->regs + MWL8K_HIU_A2H_INTERRUPT_STATUS_MASK);\r\nrc = request_irq(priv->pdev->irq, mwl8k_interrupt,\r\nIRQF_SHARED, MWL8K_NAME, hw);\r\nif (rc) {\r\nwiphy_err(hw->wiphy, "failed to register IRQ handler\n");\r\ngoto err_free_queues;\r\n}\r\nif (!priv->hw_restart_in_progress)\r\nmemset(priv->ampdu, 0, sizeof(priv->ampdu));\r\niowrite32(MWL8K_A2H_EVENTS, priv->regs + MWL8K_HIU_A2H_INTERRUPT_MASK);\r\nif (priv->ap_fw) {\r\nrc = mwl8k_cmd_get_hw_spec_ap(hw);\r\nif (!rc)\r\nrc = mwl8k_init_txqs(hw);\r\nif (!rc)\r\nrc = mwl8k_cmd_set_hw_spec(hw);\r\n} else {\r\nrc = mwl8k_cmd_get_hw_spec_sta(hw);\r\n}\r\nif (rc) {\r\nwiphy_err(hw->wiphy, "Cannot initialise firmware\n");\r\ngoto err_free_irq;\r\n}\r\nrc = mwl8k_cmd_radio_disable(hw);\r\nif (rc) {\r\nwiphy_err(hw->wiphy, "Cannot disable\n");\r\ngoto err_free_irq;\r\n}\r\nrc = mwl8k_cmd_set_mac_addr(hw, NULL, "\x00\x00\x00\x00\x00\x00");\r\nif (rc) {\r\nwiphy_err(hw->wiphy, "Cannot clear MAC address\n");\r\ngoto err_free_irq;\r\n}\r\nrc = mwl8k_cmd_rf_antenna(hw, MWL8K_RF_ANTENNA_RX, 0x3);\r\nif (rc)\r\nwiphy_warn(hw->wiphy, "failed to set # of RX antennas");\r\nrc = mwl8k_cmd_rf_antenna(hw, MWL8K_RF_ANTENNA_TX, 0x7);\r\nif (rc)\r\nwiphy_warn(hw->wiphy, "failed to set # of TX antennas");\r\niowrite32(0, priv->regs + MWL8K_HIU_A2H_INTERRUPT_MASK);\r\nfree_irq(priv->pdev->irq, hw);\r\nwiphy_info(hw->wiphy, "%s v%d, %pm, %s firmware %u.%u.%u.%u\n",\r\npriv->device_info->part_name,\r\npriv->hw_rev, hw->wiphy->perm_addr,\r\npriv->ap_fw ? "AP" : "STA",\r\n(priv->fw_rev >> 24) & 0xff, (priv->fw_rev >> 16) & 0xff,\r\n(priv->fw_rev >> 8) & 0xff, priv->fw_rev & 0xff);\r\nreturn 0;\r\nerr_free_irq:\r\niowrite32(0, priv->regs + MWL8K_HIU_A2H_INTERRUPT_MASK);\r\nfree_irq(priv->pdev->irq, hw);\r\nerr_free_queues:\r\nfor (i = 0; i < mwl8k_tx_queues(priv); i++)\r\nmwl8k_txq_deinit(hw, i);\r\nmwl8k_rxq_deinit(hw, 0);\r\nerr_stop_firmware:\r\nmwl8k_hw_reset(priv);\r\nreturn rc;\r\n}\r\nstatic int mwl8k_reload_firmware(struct ieee80211_hw *hw, char *fw_image)\r\n{\r\nint i, rc = 0;\r\nstruct mwl8k_priv *priv = hw->priv;\r\nstruct mwl8k_vif *vif, *tmp_vif;\r\nmwl8k_stop(hw);\r\nmwl8k_rxq_deinit(hw, 0);\r\nif (priv->hw_restart_in_progress)\r\nlist_for_each_entry_safe(vif, tmp_vif, &priv->vif_list, list)\r\nmwl8k_remove_vif(priv, vif);\r\nfor (i = 0; i < mwl8k_tx_queues(priv); i++)\r\nmwl8k_txq_deinit(hw, i);\r\nrc = mwl8k_init_firmware(hw, fw_image, false);\r\nif (rc)\r\ngoto fail;\r\nrc = mwl8k_probe_hw(hw);\r\nif (rc)\r\ngoto fail;\r\nif (priv->hw_restart_in_progress)\r\nreturn rc;\r\nrc = mwl8k_start(hw);\r\nif (rc)\r\ngoto fail;\r\nrc = mwl8k_config(hw, ~0);\r\nif (rc)\r\ngoto fail;\r\nfor (i = 0; i < MWL8K_TX_WMM_QUEUES; i++) {\r\nrc = mwl8k_conf_tx(hw, NULL, i, &priv->wmm_params[i]);\r\nif (rc)\r\ngoto fail;\r\n}\r\nreturn rc;\r\nfail:\r\nprintk(KERN_WARNING "mwl8k: Failed to reload firmware image.\n");\r\nreturn rc;\r\n}\r\nstatic int mwl8k_firmware_load_success(struct mwl8k_priv *priv)\r\n{\r\nstruct ieee80211_hw *hw = priv->hw;\r\nint i, rc;\r\nrc = mwl8k_load_firmware(hw);\r\nmwl8k_release_firmware(priv);\r\nif (rc) {\r\nwiphy_err(hw->wiphy, "Cannot start firmware\n");\r\nreturn rc;\r\n}\r\nhw->extra_tx_headroom =\r\nsizeof(struct mwl8k_dma_data) - sizeof(struct ieee80211_cts);\r\nhw->extra_tx_headroom -= priv->ap_fw ? REDUCED_TX_HEADROOM : 0;\r\nhw->queues = MWL8K_TX_WMM_QUEUES;\r\nieee80211_hw_set(hw, SIGNAL_DBM);\r\nieee80211_hw_set(hw, HAS_RATE_CONTROL);\r\nif (priv->ap_fw)\r\nieee80211_hw_set(hw, AP_LINK_PS);\r\nhw->vif_data_size = sizeof(struct mwl8k_vif);\r\nhw->sta_data_size = sizeof(struct mwl8k_sta);\r\npriv->macids_used = 0;\r\nINIT_LIST_HEAD(&priv->vif_list);\r\npriv->radio_on = false;\r\npriv->radio_short_preamble = false;\r\nINIT_WORK(&priv->finalize_join_worker, mwl8k_finalize_join_worker);\r\nINIT_WORK(&priv->watchdog_ba_handle, mwl8k_watchdog_ba_events);\r\nINIT_WORK(&priv->fw_reload, mwl8k_hw_restart_work);\r\ntasklet_init(&priv->poll_tx_task, mwl8k_tx_poll, (unsigned long)hw);\r\ntasklet_disable(&priv->poll_tx_task);\r\ntasklet_init(&priv->poll_rx_task, mwl8k_rx_poll, (unsigned long)hw);\r\ntasklet_disable(&priv->poll_rx_task);\r\npriv->cookie = pci_alloc_consistent(priv->pdev, 4, &priv->cookie_dma);\r\nif (priv->cookie == NULL)\r\nreturn -ENOMEM;\r\nmutex_init(&priv->fw_mutex);\r\npriv->fw_mutex_owner = NULL;\r\npriv->fw_mutex_depth = 0;\r\npriv->hostcmd_wait = NULL;\r\nspin_lock_init(&priv->tx_lock);\r\nspin_lock_init(&priv->stream_lock);\r\npriv->tx_wait = NULL;\r\nrc = mwl8k_probe_hw(hw);\r\nif (rc)\r\ngoto err_free_cookie;\r\nhw->wiphy->interface_modes = 0;\r\nif (priv->ap_macids_supported || priv->device_info->fw_image_ap) {\r\nhw->wiphy->interface_modes |= BIT(NL80211_IFTYPE_AP);\r\nhw->wiphy->interface_modes |= BIT(NL80211_IFTYPE_STATION);\r\nhw->wiphy->iface_combinations = &ap_if_comb;\r\nhw->wiphy->n_iface_combinations = 1;\r\n}\r\nif (priv->sta_macids_supported || priv->device_info->fw_image_sta)\r\nhw->wiphy->interface_modes |= BIT(NL80211_IFTYPE_STATION);\r\nrc = ieee80211_register_hw(hw);\r\nif (rc) {\r\nwiphy_err(hw->wiphy, "Cannot register device\n");\r\ngoto err_unprobe_hw;\r\n}\r\nreturn 0;\r\nerr_unprobe_hw:\r\nfor (i = 0; i < mwl8k_tx_queues(priv); i++)\r\nmwl8k_txq_deinit(hw, i);\r\nmwl8k_rxq_deinit(hw, 0);\r\nerr_free_cookie:\r\nif (priv->cookie != NULL)\r\npci_free_consistent(priv->pdev, 4,\r\npriv->cookie, priv->cookie_dma);\r\nreturn rc;\r\n}\r\nstatic int mwl8k_probe(struct pci_dev *pdev,\r\nconst struct pci_device_id *id)\r\n{\r\nstatic int printed_version;\r\nstruct ieee80211_hw *hw;\r\nstruct mwl8k_priv *priv;\r\nstruct mwl8k_device_info *di;\r\nint rc;\r\nif (!printed_version) {\r\nprintk(KERN_INFO "%s version %s\n", MWL8K_DESC, MWL8K_VERSION);\r\nprinted_version = 1;\r\n}\r\nrc = pci_enable_device(pdev);\r\nif (rc) {\r\nprintk(KERN_ERR "%s: Cannot enable new PCI device\n",\r\nMWL8K_NAME);\r\nreturn rc;\r\n}\r\nrc = pci_request_regions(pdev, MWL8K_NAME);\r\nif (rc) {\r\nprintk(KERN_ERR "%s: Cannot obtain PCI resources\n",\r\nMWL8K_NAME);\r\ngoto err_disable_device;\r\n}\r\npci_set_master(pdev);\r\nhw = ieee80211_alloc_hw(sizeof(*priv), &mwl8k_ops);\r\nif (hw == NULL) {\r\nprintk(KERN_ERR "%s: ieee80211 alloc failed\n", MWL8K_NAME);\r\nrc = -ENOMEM;\r\ngoto err_free_reg;\r\n}\r\nSET_IEEE80211_DEV(hw, &pdev->dev);\r\npci_set_drvdata(pdev, hw);\r\npriv = hw->priv;\r\npriv->hw = hw;\r\npriv->pdev = pdev;\r\npriv->device_info = &mwl8k_info_tbl[id->driver_data];\r\nif (id->driver_data == MWL8764)\r\npriv->is_8764 = true;\r\npriv->sram = pci_iomap(pdev, 0, 0x10000);\r\nif (priv->sram == NULL) {\r\nwiphy_err(hw->wiphy, "Cannot map device SRAM\n");\r\nrc = -EIO;\r\ngoto err_iounmap;\r\n}\r\npriv->regs = pci_iomap(pdev, 1, 0x10000);\r\nif (priv->regs == NULL) {\r\npriv->regs = pci_iomap(pdev, 2, 0x10000);\r\nif (priv->regs == NULL) {\r\nwiphy_err(hw->wiphy, "Cannot map device registers\n");\r\nrc = -EIO;\r\ngoto err_iounmap;\r\n}\r\n}\r\ninit_completion(&priv->firmware_loading_complete);\r\ndi = priv->device_info;\r\nif (ap_mode_default && di->fw_image_ap) {\r\npriv->fw_pref = di->fw_image_ap;\r\npriv->fw_alt = di->fw_image_sta;\r\n} else if (!ap_mode_default && di->fw_image_sta) {\r\npriv->fw_pref = di->fw_image_sta;\r\npriv->fw_alt = di->fw_image_ap;\r\n} else if (ap_mode_default && !di->fw_image_ap && di->fw_image_sta) {\r\nprintk(KERN_WARNING "AP fw is unavailable. Using STA fw.");\r\npriv->fw_pref = di->fw_image_sta;\r\n} else if (!ap_mode_default && !di->fw_image_sta && di->fw_image_ap) {\r\nprintk(KERN_WARNING "STA fw is unavailable. Using AP fw.");\r\npriv->fw_pref = di->fw_image_ap;\r\n}\r\nrc = mwl8k_init_firmware(hw, priv->fw_pref, true);\r\nif (rc)\r\ngoto err_stop_firmware;\r\npriv->hw_restart_in_progress = false;\r\npriv->running_bsses = 0;\r\nreturn rc;\r\nerr_stop_firmware:\r\nmwl8k_hw_reset(priv);\r\nerr_iounmap:\r\nif (priv->regs != NULL)\r\npci_iounmap(pdev, priv->regs);\r\nif (priv->sram != NULL)\r\npci_iounmap(pdev, priv->sram);\r\nieee80211_free_hw(hw);\r\nerr_free_reg:\r\npci_release_regions(pdev);\r\nerr_disable_device:\r\npci_disable_device(pdev);\r\nreturn rc;\r\n}\r\nstatic void mwl8k_remove(struct pci_dev *pdev)\r\n{\r\nstruct ieee80211_hw *hw = pci_get_drvdata(pdev);\r\nstruct mwl8k_priv *priv;\r\nint i;\r\nif (hw == NULL)\r\nreturn;\r\npriv = hw->priv;\r\nwait_for_completion(&priv->firmware_loading_complete);\r\nif (priv->fw_state == FW_STATE_ERROR) {\r\nmwl8k_hw_reset(priv);\r\ngoto unmap;\r\n}\r\nieee80211_stop_queues(hw);\r\nieee80211_unregister_hw(hw);\r\ntasklet_kill(&priv->poll_tx_task);\r\ntasklet_kill(&priv->poll_rx_task);\r\nmwl8k_hw_reset(priv);\r\nfor (i = 0; i < mwl8k_tx_queues(priv); i++)\r\nmwl8k_txq_reclaim(hw, i, INT_MAX, 1);\r\nfor (i = 0; i < mwl8k_tx_queues(priv); i++)\r\nmwl8k_txq_deinit(hw, i);\r\nmwl8k_rxq_deinit(hw, 0);\r\npci_free_consistent(priv->pdev, 4, priv->cookie, priv->cookie_dma);\r\nunmap:\r\npci_iounmap(pdev, priv->regs);\r\npci_iounmap(pdev, priv->sram);\r\nieee80211_free_hw(hw);\r\npci_release_regions(pdev);\r\npci_disable_device(pdev);\r\n}
