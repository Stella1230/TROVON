static void mtouch_process_format_tablet(struct mtouch *mtouch)\r\n{\r\nstruct input_dev *dev = mtouch->dev;\r\nif (MTOUCH_FORMAT_TABLET_LENGTH == ++mtouch->idx) {\r\ninput_report_abs(dev, ABS_X, MTOUCH_GET_XC(mtouch->data));\r\ninput_report_abs(dev, ABS_Y, MTOUCH_MAX_YC - MTOUCH_GET_YC(mtouch->data));\r\ninput_report_key(dev, BTN_TOUCH, MTOUCH_GET_TOUCHED(mtouch->data));\r\ninput_sync(dev);\r\nmtouch->idx = 0;\r\n}\r\n}\r\nstatic void mtouch_process_response(struct mtouch *mtouch)\r\n{\r\nif (MTOUCH_RESPONSE_END_BYTE == mtouch->data[mtouch->idx++]) {\r\nmtouch->idx = 0;\r\n} else if (MTOUCH_MAX_LENGTH == mtouch->idx) {\r\nprintk(KERN_ERR "mtouch.c: too many response bytes\n");\r\nmtouch->idx = 0;\r\n}\r\n}\r\nstatic irqreturn_t mtouch_interrupt(struct serio *serio,\r\nunsigned char data, unsigned int flags)\r\n{\r\nstruct mtouch* mtouch = serio_get_drvdata(serio);\r\nmtouch->data[mtouch->idx] = data;\r\nif (MTOUCH_FORMAT_TABLET_STATUS_BIT & mtouch->data[0])\r\nmtouch_process_format_tablet(mtouch);\r\nelse if (MTOUCH_RESPONSE_BEGIN_BYTE == mtouch->data[0])\r\nmtouch_process_response(mtouch);\r\nelse\r\nprintk(KERN_DEBUG "mtouch.c: unknown/unsynchronized data from device, byte %x\n",mtouch->data[0]);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void mtouch_disconnect(struct serio *serio)\r\n{\r\nstruct mtouch* mtouch = serio_get_drvdata(serio);\r\ninput_get_device(mtouch->dev);\r\ninput_unregister_device(mtouch->dev);\r\nserio_close(serio);\r\nserio_set_drvdata(serio, NULL);\r\ninput_put_device(mtouch->dev);\r\nkfree(mtouch);\r\n}\r\nstatic int mtouch_connect(struct serio *serio, struct serio_driver *drv)\r\n{\r\nstruct mtouch *mtouch;\r\nstruct input_dev *input_dev;\r\nint err;\r\nmtouch = kzalloc(sizeof(struct mtouch), GFP_KERNEL);\r\ninput_dev = input_allocate_device();\r\nif (!mtouch || !input_dev) {\r\nerr = -ENOMEM;\r\ngoto fail1;\r\n}\r\nmtouch->serio = serio;\r\nmtouch->dev = input_dev;\r\nsnprintf(mtouch->phys, sizeof(mtouch->phys), "%s/input0", serio->phys);\r\ninput_dev->name = "MicroTouch Serial TouchScreen";\r\ninput_dev->phys = mtouch->phys;\r\ninput_dev->id.bustype = BUS_RS232;\r\ninput_dev->id.vendor = SERIO_MICROTOUCH;\r\ninput_dev->id.product = 0;\r\ninput_dev->id.version = 0x0100;\r\ninput_dev->dev.parent = &serio->dev;\r\ninput_dev->evbit[0] = BIT_MASK(EV_KEY) | BIT_MASK(EV_ABS);\r\ninput_dev->keybit[BIT_WORD(BTN_TOUCH)] = BIT_MASK(BTN_TOUCH);\r\ninput_set_abs_params(mtouch->dev, ABS_X, MTOUCH_MIN_XC, MTOUCH_MAX_XC, 0, 0);\r\ninput_set_abs_params(mtouch->dev, ABS_Y, MTOUCH_MIN_YC, MTOUCH_MAX_YC, 0, 0);\r\nserio_set_drvdata(serio, mtouch);\r\nerr = serio_open(serio, drv);\r\nif (err)\r\ngoto fail2;\r\nerr = input_register_device(mtouch->dev);\r\nif (err)\r\ngoto fail3;\r\nreturn 0;\r\nfail3: serio_close(serio);\r\nfail2: serio_set_drvdata(serio, NULL);\r\nfail1: input_free_device(input_dev);\r\nkfree(mtouch);\r\nreturn err;\r\n}
