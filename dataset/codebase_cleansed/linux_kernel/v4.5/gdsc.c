static int gdsc_is_enabled(struct gdsc *sc)\r\n{\r\nu32 val;\r\nint ret;\r\nret = regmap_read(sc->regmap, sc->gdscr, &val);\r\nif (ret)\r\nreturn ret;\r\nreturn !!(val & PWR_ON_MASK);\r\n}\r\nstatic int gdsc_toggle_logic(struct gdsc *sc, bool en)\r\n{\r\nint ret;\r\nu32 val = en ? 0 : SW_COLLAPSE_MASK;\r\nu32 check = en ? PWR_ON_MASK : 0;\r\nunsigned long timeout;\r\nret = regmap_update_bits(sc->regmap, sc->gdscr, SW_COLLAPSE_MASK, val);\r\nif (ret)\r\nreturn ret;\r\ntimeout = jiffies + usecs_to_jiffies(TIMEOUT_US);\r\ndo {\r\nret = regmap_read(sc->regmap, sc->gdscr, &val);\r\nif (ret)\r\nreturn ret;\r\nif ((val & PWR_ON_MASK) == check)\r\nreturn 0;\r\n} while (time_before(jiffies, timeout));\r\nret = regmap_read(sc->regmap, sc->gdscr, &val);\r\nif (ret)\r\nreturn ret;\r\nif ((val & PWR_ON_MASK) == check)\r\nreturn 0;\r\nreturn -ETIMEDOUT;\r\n}\r\nstatic inline int gdsc_deassert_reset(struct gdsc *sc)\r\n{\r\nint i;\r\nfor (i = 0; i < sc->reset_count; i++)\r\nsc->rcdev->ops->deassert(sc->rcdev, sc->resets[i]);\r\nreturn 0;\r\n}\r\nstatic inline int gdsc_assert_reset(struct gdsc *sc)\r\n{\r\nint i;\r\nfor (i = 0; i < sc->reset_count; i++)\r\nsc->rcdev->ops->assert(sc->rcdev, sc->resets[i]);\r\nreturn 0;\r\n}\r\nstatic inline void gdsc_force_mem_on(struct gdsc *sc)\r\n{\r\nint i;\r\nu32 mask = RETAIN_MEM | RETAIN_PERIPH;\r\nfor (i = 0; i < sc->cxc_count; i++)\r\nregmap_update_bits(sc->regmap, sc->cxcs[i], mask, mask);\r\n}\r\nstatic inline void gdsc_clear_mem_on(struct gdsc *sc)\r\n{\r\nint i;\r\nu32 mask = RETAIN_MEM | RETAIN_PERIPH;\r\nfor (i = 0; i < sc->cxc_count; i++)\r\nregmap_update_bits(sc->regmap, sc->cxcs[i], mask, 0);\r\n}\r\nstatic int gdsc_enable(struct generic_pm_domain *domain)\r\n{\r\nstruct gdsc *sc = domain_to_gdsc(domain);\r\nint ret;\r\nif (sc->pwrsts == PWRSTS_ON)\r\nreturn gdsc_deassert_reset(sc);\r\nret = gdsc_toggle_logic(sc, true);\r\nif (ret)\r\nreturn ret;\r\nif (sc->pwrsts & PWRSTS_OFF)\r\ngdsc_force_mem_on(sc);\r\nudelay(1);\r\nreturn 0;\r\n}\r\nstatic int gdsc_disable(struct generic_pm_domain *domain)\r\n{\r\nstruct gdsc *sc = domain_to_gdsc(domain);\r\nif (sc->pwrsts == PWRSTS_ON)\r\nreturn gdsc_assert_reset(sc);\r\nif (sc->pwrsts & PWRSTS_OFF)\r\ngdsc_clear_mem_on(sc);\r\nreturn gdsc_toggle_logic(sc, false);\r\n}\r\nstatic int gdsc_init(struct gdsc *sc)\r\n{\r\nu32 mask, val;\r\nint on, ret;\r\nmask = HW_CONTROL_MASK | SW_OVERRIDE_MASK |\r\nEN_REST_WAIT_MASK | EN_FEW_WAIT_MASK | CLK_DIS_WAIT_MASK;\r\nval = EN_REST_WAIT_VAL | EN_FEW_WAIT_VAL | CLK_DIS_WAIT_VAL;\r\nret = regmap_update_bits(sc->regmap, sc->gdscr, mask, val);\r\nif (ret)\r\nreturn ret;\r\nif (sc->pwrsts == PWRSTS_ON) {\r\nret = gdsc_toggle_logic(sc, true);\r\nif (ret)\r\nreturn ret;\r\n}\r\non = gdsc_is_enabled(sc);\r\nif (on < 0)\r\nreturn on;\r\nif (on || (sc->pwrsts & PWRSTS_RET))\r\ngdsc_force_mem_on(sc);\r\nelse\r\ngdsc_clear_mem_on(sc);\r\nsc->pd.power_off = gdsc_disable;\r\nsc->pd.power_on = gdsc_enable;\r\npm_genpd_init(&sc->pd, NULL, !on);\r\nreturn 0;\r\n}\r\nint gdsc_register(struct device *dev, struct gdsc **scs, size_t num,\r\nstruct reset_controller_dev *rcdev, struct regmap *regmap)\r\n{\r\nint i, ret;\r\nstruct genpd_onecell_data *data;\r\ndata = devm_kzalloc(dev, sizeof(*data), GFP_KERNEL);\r\nif (!data)\r\nreturn -ENOMEM;\r\ndata->domains = devm_kcalloc(dev, num, sizeof(*data->domains),\r\nGFP_KERNEL);\r\nif (!data->domains)\r\nreturn -ENOMEM;\r\ndata->num_domains = num;\r\nfor (i = 0; i < num; i++) {\r\nif (!scs[i])\r\ncontinue;\r\nscs[i]->regmap = regmap;\r\nscs[i]->rcdev = rcdev;\r\nret = gdsc_init(scs[i]);\r\nif (ret)\r\nreturn ret;\r\ndata->domains[i] = &scs[i]->pd;\r\n}\r\nreturn of_genpd_add_provider_onecell(dev->of_node, data);\r\n}\r\nvoid gdsc_unregister(struct device *dev)\r\n{\r\nof_genpd_del_provider(dev->of_node);\r\n}
