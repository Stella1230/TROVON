static void rhine_wait_bit(struct rhine_private *rp, u8 reg, u8 mask, bool low)\r\n{\r\nvoid __iomem *ioaddr = rp->base;\r\nint i;\r\nfor (i = 0; i < 1024; i++) {\r\nbool has_mask_bits = !!(ioread8(ioaddr + reg) & mask);\r\nif (low ^ has_mask_bits)\r\nbreak;\r\nudelay(10);\r\n}\r\nif (i > 64) {\r\nnetif_dbg(rp, hw, rp->dev, "%s bit wait (%02x/%02x) cycle "\r\n"count: %04d\n", low ? "low" : "high", reg, mask, i);\r\n}\r\n}\r\nstatic void rhine_wait_bit_high(struct rhine_private *rp, u8 reg, u8 mask)\r\n{\r\nrhine_wait_bit(rp, reg, mask, false);\r\n}\r\nstatic void rhine_wait_bit_low(struct rhine_private *rp, u8 reg, u8 mask)\r\n{\r\nrhine_wait_bit(rp, reg, mask, true);\r\n}\r\nstatic u32 rhine_get_events(struct rhine_private *rp)\r\n{\r\nvoid __iomem *ioaddr = rp->base;\r\nu32 intr_status;\r\nintr_status = ioread16(ioaddr + IntrStatus);\r\nif (rp->quirks & rqStatusWBRace)\r\nintr_status |= ioread8(ioaddr + IntrStatus2) << 16;\r\nreturn intr_status;\r\n}\r\nstatic void rhine_ack_events(struct rhine_private *rp, u32 mask)\r\n{\r\nvoid __iomem *ioaddr = rp->base;\r\nif (rp->quirks & rqStatusWBRace)\r\niowrite8(mask >> 16, ioaddr + IntrStatus2);\r\niowrite16(mask, ioaddr + IntrStatus);\r\nmmiowb();\r\n}\r\nstatic void rhine_power_init(struct net_device *dev)\r\n{\r\nstruct rhine_private *rp = netdev_priv(dev);\r\nvoid __iomem *ioaddr = rp->base;\r\nu16 wolstat;\r\nif (rp->quirks & rqWOL) {\r\niowrite8(ioread8(ioaddr + StickyHW) & 0xFC, ioaddr + StickyHW);\r\niowrite8(0x80, ioaddr + WOLcgClr);\r\niowrite8(0xFF, ioaddr + WOLcrClr);\r\nif (rp->quirks & rq6patterns)\r\niowrite8(0x03, ioaddr + WOLcrClr1);\r\nwolstat = ioread8(ioaddr + PwrcsrSet);\r\nif (rp->quirks & rq6patterns)\r\nwolstat |= (ioread8(ioaddr + PwrcsrSet1) & 0x03) << 8;\r\niowrite8(0xFF, ioaddr + PwrcsrClr);\r\nif (rp->quirks & rq6patterns)\r\niowrite8(0x03, ioaddr + PwrcsrClr1);\r\nif (wolstat) {\r\nchar *reason;\r\nswitch (wolstat) {\r\ncase WOLmagic:\r\nreason = "Magic packet";\r\nbreak;\r\ncase WOLlnkon:\r\nreason = "Link went up";\r\nbreak;\r\ncase WOLlnkoff:\r\nreason = "Link went down";\r\nbreak;\r\ncase WOLucast:\r\nreason = "Unicast packet";\r\nbreak;\r\ncase WOLbmcast:\r\nreason = "Multicast/broadcast packet";\r\nbreak;\r\ndefault:\r\nreason = "Unknown";\r\n}\r\nnetdev_info(dev, "Woke system up. Reason: %s\n",\r\nreason);\r\n}\r\n}\r\n}\r\nstatic void rhine_chip_reset(struct net_device *dev)\r\n{\r\nstruct rhine_private *rp = netdev_priv(dev);\r\nvoid __iomem *ioaddr = rp->base;\r\nu8 cmd1;\r\niowrite8(Cmd1Reset, ioaddr + ChipCmd1);\r\nIOSYNC;\r\nif (ioread8(ioaddr + ChipCmd1) & Cmd1Reset) {\r\nnetdev_info(dev, "Reset not complete yet. Trying harder.\n");\r\nif (rp->quirks & rqForceReset)\r\niowrite8(0x40, ioaddr + MiscCmd);\r\nrhine_wait_bit_low(rp, ChipCmd1, Cmd1Reset);\r\n}\r\ncmd1 = ioread8(ioaddr + ChipCmd1);\r\nnetif_info(rp, hw, dev, "Reset %s\n", (cmd1 & Cmd1Reset) ?\r\n"failed" : "succeeded");\r\n}\r\nstatic void enable_mmio(long pioaddr, u32 quirks)\r\n{\r\nint n;\r\nif (quirks & rqNeedEnMMIO) {\r\nif (quirks & rqRhineI) {\r\nn = inb(pioaddr + ConfigA) | 0x20;\r\noutb(n, pioaddr + ConfigA);\r\n} else {\r\nn = inb(pioaddr + ConfigD) | 0x80;\r\noutb(n, pioaddr + ConfigD);\r\n}\r\n}\r\n}\r\nstatic inline int verify_mmio(struct device *hwdev,\r\nlong pioaddr,\r\nvoid __iomem *ioaddr,\r\nu32 quirks)\r\n{\r\nif (quirks & rqNeedEnMMIO) {\r\nint i = 0;\r\nwhile (mmio_verify_registers[i]) {\r\nint reg = mmio_verify_registers[i++];\r\nunsigned char a = inb(pioaddr+reg);\r\nunsigned char b = readb(ioaddr+reg);\r\nif (a != b) {\r\ndev_err(hwdev,\r\n"MMIO do not match PIO [%02x] (%02x != %02x)\n",\r\nreg, a, b);\r\nreturn -EIO;\r\n}\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic void rhine_reload_eeprom(long pioaddr, struct net_device *dev)\r\n{\r\nstruct rhine_private *rp = netdev_priv(dev);\r\nvoid __iomem *ioaddr = rp->base;\r\nint i;\r\noutb(0x20, pioaddr + MACRegEEcsr);\r\nfor (i = 0; i < 1024; i++) {\r\nif (!(inb(pioaddr + MACRegEEcsr) & 0x20))\r\nbreak;\r\n}\r\nif (i > 512)\r\npr_info("%4d cycles used @ %s:%d\n", i, __func__, __LINE__);\r\nenable_mmio(pioaddr, rp->quirks);\r\nif (rp->quirks & rqWOL)\r\niowrite8(ioread8(ioaddr + ConfigA) & 0xFC, ioaddr + ConfigA);\r\n}\r\nstatic void rhine_poll(struct net_device *dev)\r\n{\r\nstruct rhine_private *rp = netdev_priv(dev);\r\nconst int irq = rp->irq;\r\ndisable_irq(irq);\r\nrhine_interrupt(irq, dev);\r\nenable_irq(irq);\r\n}\r\nstatic void rhine_kick_tx_threshold(struct rhine_private *rp)\r\n{\r\nif (rp->tx_thresh < 0xe0) {\r\nvoid __iomem *ioaddr = rp->base;\r\nrp->tx_thresh += 0x20;\r\nBYTE_REG_BITS_SET(rp->tx_thresh, 0x80, ioaddr + TxConfig);\r\n}\r\n}\r\nstatic void rhine_tx_err(struct rhine_private *rp, u32 status)\r\n{\r\nstruct net_device *dev = rp->dev;\r\nif (status & IntrTxAborted) {\r\nnetif_info(rp, tx_err, dev,\r\n"Abort %08x, frame dropped\n", status);\r\n}\r\nif (status & IntrTxUnderrun) {\r\nrhine_kick_tx_threshold(rp);\r\nnetif_info(rp, tx_err ,dev, "Transmitter underrun, "\r\n"Tx threshold now %02x\n", rp->tx_thresh);\r\n}\r\nif (status & IntrTxDescRace)\r\nnetif_info(rp, tx_err, dev, "Tx descriptor write-back race\n");\r\nif ((status & IntrTxError) &&\r\n(status & (IntrTxAborted | IntrTxUnderrun | IntrTxDescRace)) == 0) {\r\nrhine_kick_tx_threshold(rp);\r\nnetif_info(rp, tx_err, dev, "Unspecified error. "\r\n"Tx threshold now %02x\n", rp->tx_thresh);\r\n}\r\nrhine_restart_tx(dev);\r\n}\r\nstatic void rhine_update_rx_crc_and_missed_errord(struct rhine_private *rp)\r\n{\r\nvoid __iomem *ioaddr = rp->base;\r\nstruct net_device_stats *stats = &rp->dev->stats;\r\nstats->rx_crc_errors += ioread16(ioaddr + RxCRCErrs);\r\nstats->rx_missed_errors += ioread16(ioaddr + RxMissed);\r\niowrite32(0, ioaddr + RxMissed);\r\nioread16(ioaddr + RxCRCErrs);\r\nioread16(ioaddr + RxMissed);\r\n}\r\nstatic int rhine_napipoll(struct napi_struct *napi, int budget)\r\n{\r\nstruct rhine_private *rp = container_of(napi, struct rhine_private, napi);\r\nstruct net_device *dev = rp->dev;\r\nvoid __iomem *ioaddr = rp->base;\r\nu16 enable_mask = RHINE_EVENT & 0xffff;\r\nint work_done = 0;\r\nu32 status;\r\nstatus = rhine_get_events(rp);\r\nrhine_ack_events(rp, status & ~RHINE_EVENT_SLOW);\r\nif (status & RHINE_EVENT_NAPI_RX)\r\nwork_done += rhine_rx(dev, budget);\r\nif (status & RHINE_EVENT_NAPI_TX) {\r\nif (status & RHINE_EVENT_NAPI_TX_ERR) {\r\nrhine_wait_bit_low(rp, ChipCmd, CmdTxOn);\r\nif (ioread8(ioaddr + ChipCmd) & CmdTxOn)\r\nnetif_warn(rp, tx_err, dev, "Tx still on\n");\r\n}\r\nrhine_tx(dev);\r\nif (status & RHINE_EVENT_NAPI_TX_ERR)\r\nrhine_tx_err(rp, status);\r\n}\r\nif (status & IntrStatsMax) {\r\nspin_lock(&rp->lock);\r\nrhine_update_rx_crc_and_missed_errord(rp);\r\nspin_unlock(&rp->lock);\r\n}\r\nif (status & RHINE_EVENT_SLOW) {\r\nenable_mask &= ~RHINE_EVENT_SLOW;\r\nschedule_work(&rp->slow_event_task);\r\n}\r\nif (work_done < budget) {\r\nnapi_complete(napi);\r\niowrite16(enable_mask, ioaddr + IntrEnable);\r\nmmiowb();\r\n}\r\nreturn work_done;\r\n}\r\nstatic void rhine_hw_init(struct net_device *dev, long pioaddr)\r\n{\r\nstruct rhine_private *rp = netdev_priv(dev);\r\nrhine_chip_reset(dev);\r\nif (rp->quirks & rqRhineI)\r\nmsleep(5);\r\nif (dev_is_pci(dev->dev.parent))\r\nrhine_reload_eeprom(pioaddr, dev);\r\n}\r\nstatic int rhine_init_one_common(struct device *hwdev, u32 quirks,\r\nlong pioaddr, void __iomem *ioaddr, int irq)\r\n{\r\nstruct net_device *dev;\r\nstruct rhine_private *rp;\r\nint i, rc, phy_id;\r\nconst char *name;\r\nrc = dma_set_mask(hwdev, DMA_BIT_MASK(32));\r\nif (rc) {\r\ndev_err(hwdev, "32-bit DMA addresses not supported by the card!?\n");\r\ngoto err_out;\r\n}\r\ndev = alloc_etherdev(sizeof(struct rhine_private));\r\nif (!dev) {\r\nrc = -ENOMEM;\r\ngoto err_out;\r\n}\r\nSET_NETDEV_DEV(dev, hwdev);\r\nrp = netdev_priv(dev);\r\nrp->dev = dev;\r\nrp->quirks = quirks;\r\nrp->pioaddr = pioaddr;\r\nrp->base = ioaddr;\r\nrp->irq = irq;\r\nrp->msg_enable = netif_msg_init(debug, RHINE_MSG_DEFAULT);\r\nphy_id = rp->quirks & rqIntPHY ? 1 : 0;\r\nu64_stats_init(&rp->tx_stats.syncp);\r\nu64_stats_init(&rp->rx_stats.syncp);\r\nrhine_power_init(dev);\r\nrhine_hw_init(dev, pioaddr);\r\nfor (i = 0; i < 6; i++)\r\ndev->dev_addr[i] = ioread8(ioaddr + StationAddr + i);\r\nif (!is_valid_ether_addr(dev->dev_addr)) {\r\nnetdev_err(dev, "Invalid MAC address: %pM\n", dev->dev_addr);\r\neth_hw_addr_random(dev);\r\nnetdev_info(dev, "Using random MAC address: %pM\n",\r\ndev->dev_addr);\r\n}\r\nif (!phy_id)\r\nphy_id = ioread8(ioaddr + 0x6C);\r\nspin_lock_init(&rp->lock);\r\nmutex_init(&rp->task_lock);\r\nINIT_WORK(&rp->reset_task, rhine_reset_task);\r\nINIT_WORK(&rp->slow_event_task, rhine_slow_event_task);\r\nrp->mii_if.dev = dev;\r\nrp->mii_if.mdio_read = mdio_read;\r\nrp->mii_if.mdio_write = mdio_write;\r\nrp->mii_if.phy_id_mask = 0x1f;\r\nrp->mii_if.reg_num_mask = 0x1f;\r\ndev->netdev_ops = &rhine_netdev_ops;\r\ndev->ethtool_ops = &netdev_ethtool_ops;\r\ndev->watchdog_timeo = TX_TIMEOUT;\r\nnetif_napi_add(dev, &rp->napi, rhine_napipoll, 64);\r\nif (rp->quirks & rqRhineI)\r\ndev->features |= NETIF_F_SG|NETIF_F_HW_CSUM;\r\nif (rp->quirks & rqMgmt)\r\ndev->features |= NETIF_F_HW_VLAN_CTAG_TX |\r\nNETIF_F_HW_VLAN_CTAG_RX |\r\nNETIF_F_HW_VLAN_CTAG_FILTER;\r\nrc = register_netdev(dev);\r\nif (rc)\r\ngoto err_out_free_netdev;\r\nif (rp->quirks & rqRhineI)\r\nname = "Rhine";\r\nelse if (rp->quirks & rqStatusWBRace)\r\nname = "Rhine II";\r\nelse if (rp->quirks & rqMgmt)\r\nname = "Rhine III (Management Adapter)";\r\nelse\r\nname = "Rhine III";\r\nnetdev_info(dev, "VIA %s at 0x%lx, %pM, IRQ %d\n",\r\nname, (long)ioaddr, dev->dev_addr, rp->irq);\r\ndev_set_drvdata(hwdev, dev);\r\n{\r\nu16 mii_cmd;\r\nint mii_status = mdio_read(dev, phy_id, 1);\r\nmii_cmd = mdio_read(dev, phy_id, MII_BMCR) & ~BMCR_ISOLATE;\r\nmdio_write(dev, phy_id, MII_BMCR, mii_cmd);\r\nif (mii_status != 0xffff && mii_status != 0x0000) {\r\nrp->mii_if.advertising = mdio_read(dev, phy_id, 4);\r\nnetdev_info(dev,\r\n"MII PHY found at address %d, status 0x%04x advertising %04x Link %04x\n",\r\nphy_id,\r\nmii_status, rp->mii_if.advertising,\r\nmdio_read(dev, phy_id, 5));\r\nif (mii_status & BMSR_LSTATUS)\r\nnetif_carrier_on(dev);\r\nelse\r\nnetif_carrier_off(dev);\r\n}\r\n}\r\nrp->mii_if.phy_id = phy_id;\r\nif (avoid_D3)\r\nnetif_info(rp, probe, dev, "No D3 power state at shutdown\n");\r\nreturn 0;\r\nerr_out_free_netdev:\r\nfree_netdev(dev);\r\nerr_out:\r\nreturn rc;\r\n}\r\nstatic int rhine_init_one_pci(struct pci_dev *pdev,\r\nconst struct pci_device_id *ent)\r\n{\r\nstruct device *hwdev = &pdev->dev;\r\nint rc;\r\nlong pioaddr, memaddr;\r\nvoid __iomem *ioaddr;\r\nint io_size = pdev->revision < VTunknown0 ? 128 : 256;\r\n#ifdef CONFIG_VIA_RHINE_MMIO\r\nu32 quirks = rqNeedEnMMIO;\r\n#else\r\nu32 quirks = 0;\r\n#endif\r\n#ifndef MODULE\r\npr_info_once("%s\n", version);\r\n#endif\r\nrc = pci_enable_device(pdev);\r\nif (rc)\r\ngoto err_out;\r\nif (pdev->revision < VTunknown0) {\r\nquirks |= rqRhineI;\r\n} else if (pdev->revision >= VT6102) {\r\nquirks |= rqWOL | rqForceReset;\r\nif (pdev->revision < VT6105) {\r\nquirks |= rqStatusWBRace;\r\n} else {\r\nquirks |= rqIntPHY;\r\nif (pdev->revision >= VT6105_B0)\r\nquirks |= rq6patterns;\r\nif (pdev->revision >= VT6105M)\r\nquirks |= rqMgmt;\r\n}\r\n}\r\nif ((pci_resource_len(pdev, 0) < io_size) ||\r\n(pci_resource_len(pdev, 1) < io_size)) {\r\nrc = -EIO;\r\ndev_err(hwdev, "Insufficient PCI resources, aborting\n");\r\ngoto err_out_pci_disable;\r\n}\r\npioaddr = pci_resource_start(pdev, 0);\r\nmemaddr = pci_resource_start(pdev, 1);\r\npci_set_master(pdev);\r\nrc = pci_request_regions(pdev, DRV_NAME);\r\nif (rc)\r\ngoto err_out_pci_disable;\r\nioaddr = pci_iomap(pdev, (quirks & rqNeedEnMMIO ? 1 : 0), io_size);\r\nif (!ioaddr) {\r\nrc = -EIO;\r\ndev_err(hwdev,\r\n"ioremap failed for device %s, region 0x%X @ 0x%lX\n",\r\ndev_name(hwdev), io_size, memaddr);\r\ngoto err_out_free_res;\r\n}\r\nenable_mmio(pioaddr, quirks);\r\nrc = verify_mmio(hwdev, pioaddr, ioaddr, quirks);\r\nif (rc)\r\ngoto err_out_unmap;\r\nrc = rhine_init_one_common(&pdev->dev, quirks,\r\npioaddr, ioaddr, pdev->irq);\r\nif (!rc)\r\nreturn 0;\r\nerr_out_unmap:\r\npci_iounmap(pdev, ioaddr);\r\nerr_out_free_res:\r\npci_release_regions(pdev);\r\nerr_out_pci_disable:\r\npci_disable_device(pdev);\r\nerr_out:\r\nreturn rc;\r\n}\r\nstatic int rhine_init_one_platform(struct platform_device *pdev)\r\n{\r\nconst struct of_device_id *match;\r\nconst u32 *quirks;\r\nint irq;\r\nstruct resource *res;\r\nvoid __iomem *ioaddr;\r\nmatch = of_match_device(rhine_of_tbl, &pdev->dev);\r\nif (!match)\r\nreturn -EINVAL;\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nioaddr = devm_ioremap_resource(&pdev->dev, res);\r\nif (IS_ERR(ioaddr))\r\nreturn PTR_ERR(ioaddr);\r\nirq = irq_of_parse_and_map(pdev->dev.of_node, 0);\r\nif (!irq)\r\nreturn -EINVAL;\r\nquirks = match->data;\r\nif (!quirks)\r\nreturn -EINVAL;\r\nreturn rhine_init_one_common(&pdev->dev, *quirks,\r\n(long)ioaddr, ioaddr, irq);\r\n}\r\nstatic int alloc_ring(struct net_device* dev)\r\n{\r\nstruct rhine_private *rp = netdev_priv(dev);\r\nstruct device *hwdev = dev->dev.parent;\r\nvoid *ring;\r\ndma_addr_t ring_dma;\r\nring = dma_alloc_coherent(hwdev,\r\nRX_RING_SIZE * sizeof(struct rx_desc) +\r\nTX_RING_SIZE * sizeof(struct tx_desc),\r\n&ring_dma,\r\nGFP_ATOMIC);\r\nif (!ring) {\r\nnetdev_err(dev, "Could not allocate DMA memory\n");\r\nreturn -ENOMEM;\r\n}\r\nif (rp->quirks & rqRhineI) {\r\nrp->tx_bufs = dma_alloc_coherent(hwdev,\r\nPKT_BUF_SZ * TX_RING_SIZE,\r\n&rp->tx_bufs_dma,\r\nGFP_ATOMIC);\r\nif (rp->tx_bufs == NULL) {\r\ndma_free_coherent(hwdev,\r\nRX_RING_SIZE * sizeof(struct rx_desc) +\r\nTX_RING_SIZE * sizeof(struct tx_desc),\r\nring, ring_dma);\r\nreturn -ENOMEM;\r\n}\r\n}\r\nrp->rx_ring = ring;\r\nrp->tx_ring = ring + RX_RING_SIZE * sizeof(struct rx_desc);\r\nrp->rx_ring_dma = ring_dma;\r\nrp->tx_ring_dma = ring_dma + RX_RING_SIZE * sizeof(struct rx_desc);\r\nreturn 0;\r\n}\r\nstatic void free_ring(struct net_device* dev)\r\n{\r\nstruct rhine_private *rp = netdev_priv(dev);\r\nstruct device *hwdev = dev->dev.parent;\r\ndma_free_coherent(hwdev,\r\nRX_RING_SIZE * sizeof(struct rx_desc) +\r\nTX_RING_SIZE * sizeof(struct tx_desc),\r\nrp->rx_ring, rp->rx_ring_dma);\r\nrp->tx_ring = NULL;\r\nif (rp->tx_bufs)\r\ndma_free_coherent(hwdev, PKT_BUF_SZ * TX_RING_SIZE,\r\nrp->tx_bufs, rp->tx_bufs_dma);\r\nrp->tx_bufs = NULL;\r\n}\r\nstatic inline int rhine_skb_dma_init(struct net_device *dev,\r\nstruct rhine_skb_dma *sd)\r\n{\r\nstruct rhine_private *rp = netdev_priv(dev);\r\nstruct device *hwdev = dev->dev.parent;\r\nconst int size = rp->rx_buf_sz;\r\nsd->skb = netdev_alloc_skb(dev, size);\r\nif (!sd->skb)\r\nreturn -ENOMEM;\r\nsd->dma = dma_map_single(hwdev, sd->skb->data, size, DMA_FROM_DEVICE);\r\nif (unlikely(dma_mapping_error(hwdev, sd->dma))) {\r\nnetif_err(rp, drv, dev, "Rx DMA mapping failure\n");\r\ndev_kfree_skb_any(sd->skb);\r\nreturn -EIO;\r\n}\r\nreturn 0;\r\n}\r\nstatic void rhine_reset_rbufs(struct rhine_private *rp)\r\n{\r\nint i;\r\nrp->cur_rx = 0;\r\nfor (i = 0; i < RX_RING_SIZE; i++)\r\nrp->rx_ring[i].rx_status = cpu_to_le32(DescOwn);\r\n}\r\nstatic inline void rhine_skb_dma_nic_store(struct rhine_private *rp,\r\nstruct rhine_skb_dma *sd, int entry)\r\n{\r\nrp->rx_skbuff_dma[entry] = sd->dma;\r\nrp->rx_skbuff[entry] = sd->skb;\r\nrp->rx_ring[entry].addr = cpu_to_le32(sd->dma);\r\ndma_wmb();\r\n}\r\nstatic int alloc_rbufs(struct net_device *dev)\r\n{\r\nstruct rhine_private *rp = netdev_priv(dev);\r\ndma_addr_t next;\r\nint rc, i;\r\nrp->rx_buf_sz = (dev->mtu <= 1500 ? PKT_BUF_SZ : dev->mtu + 32);\r\nnext = rp->rx_ring_dma;\r\nfor (i = 0; i < RX_RING_SIZE; i++) {\r\nrp->rx_ring[i].rx_status = 0;\r\nrp->rx_ring[i].desc_length = cpu_to_le32(rp->rx_buf_sz);\r\nnext += sizeof(struct rx_desc);\r\nrp->rx_ring[i].next_desc = cpu_to_le32(next);\r\nrp->rx_skbuff[i] = NULL;\r\n}\r\nrp->rx_ring[i-1].next_desc = cpu_to_le32(rp->rx_ring_dma);\r\nfor (i = 0; i < RX_RING_SIZE; i++) {\r\nstruct rhine_skb_dma sd;\r\nrc = rhine_skb_dma_init(dev, &sd);\r\nif (rc < 0) {\r\nfree_rbufs(dev);\r\ngoto out;\r\n}\r\nrhine_skb_dma_nic_store(rp, &sd, i);\r\n}\r\nrhine_reset_rbufs(rp);\r\nout:\r\nreturn rc;\r\n}\r\nstatic void free_rbufs(struct net_device* dev)\r\n{\r\nstruct rhine_private *rp = netdev_priv(dev);\r\nstruct device *hwdev = dev->dev.parent;\r\nint i;\r\nfor (i = 0; i < RX_RING_SIZE; i++) {\r\nrp->rx_ring[i].rx_status = 0;\r\nrp->rx_ring[i].addr = cpu_to_le32(0xBADF00D0);\r\nif (rp->rx_skbuff[i]) {\r\ndma_unmap_single(hwdev,\r\nrp->rx_skbuff_dma[i],\r\nrp->rx_buf_sz, DMA_FROM_DEVICE);\r\ndev_kfree_skb(rp->rx_skbuff[i]);\r\n}\r\nrp->rx_skbuff[i] = NULL;\r\n}\r\n}\r\nstatic void alloc_tbufs(struct net_device* dev)\r\n{\r\nstruct rhine_private *rp = netdev_priv(dev);\r\ndma_addr_t next;\r\nint i;\r\nrp->dirty_tx = rp->cur_tx = 0;\r\nnext = rp->tx_ring_dma;\r\nfor (i = 0; i < TX_RING_SIZE; i++) {\r\nrp->tx_skbuff[i] = NULL;\r\nrp->tx_ring[i].tx_status = 0;\r\nrp->tx_ring[i].desc_length = cpu_to_le32(TXDESC);\r\nnext += sizeof(struct tx_desc);\r\nrp->tx_ring[i].next_desc = cpu_to_le32(next);\r\nif (rp->quirks & rqRhineI)\r\nrp->tx_buf[i] = &rp->tx_bufs[i * PKT_BUF_SZ];\r\n}\r\nrp->tx_ring[i-1].next_desc = cpu_to_le32(rp->tx_ring_dma);\r\nnetdev_reset_queue(dev);\r\n}\r\nstatic void free_tbufs(struct net_device* dev)\r\n{\r\nstruct rhine_private *rp = netdev_priv(dev);\r\nstruct device *hwdev = dev->dev.parent;\r\nint i;\r\nfor (i = 0; i < TX_RING_SIZE; i++) {\r\nrp->tx_ring[i].tx_status = 0;\r\nrp->tx_ring[i].desc_length = cpu_to_le32(TXDESC);\r\nrp->tx_ring[i].addr = cpu_to_le32(0xBADF00D0);\r\nif (rp->tx_skbuff[i]) {\r\nif (rp->tx_skbuff_dma[i]) {\r\ndma_unmap_single(hwdev,\r\nrp->tx_skbuff_dma[i],\r\nrp->tx_skbuff[i]->len,\r\nDMA_TO_DEVICE);\r\n}\r\ndev_kfree_skb(rp->tx_skbuff[i]);\r\n}\r\nrp->tx_skbuff[i] = NULL;\r\nrp->tx_buf[i] = NULL;\r\n}\r\n}\r\nstatic void rhine_check_media(struct net_device *dev, unsigned int init_media)\r\n{\r\nstruct rhine_private *rp = netdev_priv(dev);\r\nvoid __iomem *ioaddr = rp->base;\r\nif (!rp->mii_if.force_media)\r\nmii_check_media(&rp->mii_if, netif_msg_link(rp), init_media);\r\nif (rp->mii_if.full_duplex)\r\niowrite8(ioread8(ioaddr + ChipCmd1) | Cmd1FDuplex,\r\nioaddr + ChipCmd1);\r\nelse\r\niowrite8(ioread8(ioaddr + ChipCmd1) & ~Cmd1FDuplex,\r\nioaddr + ChipCmd1);\r\nnetif_info(rp, link, dev, "force_media %d, carrier %d\n",\r\nrp->mii_if.force_media, netif_carrier_ok(dev));\r\n}\r\nstatic void rhine_set_carrier(struct mii_if_info *mii)\r\n{\r\nstruct net_device *dev = mii->dev;\r\nstruct rhine_private *rp = netdev_priv(dev);\r\nif (mii->force_media) {\r\nif (!netif_carrier_ok(dev))\r\nnetif_carrier_on(dev);\r\n}\r\nrhine_check_media(dev, 0);\r\nnetif_info(rp, link, dev, "force_media %d, carrier %d\n",\r\nmii->force_media, netif_carrier_ok(dev));\r\n}\r\nstatic void rhine_set_cam(void __iomem *ioaddr, int idx, u8 *addr)\r\n{\r\nint i;\r\niowrite8(CAMC_CAMEN, ioaddr + CamCon);\r\nwmb();\r\nidx &= (MCAM_SIZE - 1);\r\niowrite8((u8) idx, ioaddr + CamAddr);\r\nfor (i = 0; i < 6; i++, addr++)\r\niowrite8(*addr, ioaddr + MulticastFilter0 + i);\r\nudelay(10);\r\nwmb();\r\niowrite8(CAMC_CAMWR | CAMC_CAMEN, ioaddr + CamCon);\r\nudelay(10);\r\niowrite8(0, ioaddr + CamCon);\r\n}\r\nstatic void rhine_set_vlan_cam(void __iomem *ioaddr, int idx, u8 *addr)\r\n{\r\niowrite8(CAMC_CAMEN | CAMC_VCAMSL, ioaddr + CamCon);\r\nwmb();\r\nidx &= (VCAM_SIZE - 1);\r\niowrite8((u8) idx, ioaddr + CamAddr);\r\niowrite16(*((u16 *) addr), ioaddr + MulticastFilter0 + 6);\r\nudelay(10);\r\nwmb();\r\niowrite8(CAMC_CAMWR | CAMC_CAMEN, ioaddr + CamCon);\r\nudelay(10);\r\niowrite8(0, ioaddr + CamCon);\r\n}\r\nstatic void rhine_set_cam_mask(void __iomem *ioaddr, u32 mask)\r\n{\r\niowrite8(CAMC_CAMEN, ioaddr + CamCon);\r\nwmb();\r\niowrite32(mask, ioaddr + CamMask);\r\niowrite8(0, ioaddr + CamCon);\r\n}\r\nstatic void rhine_set_vlan_cam_mask(void __iomem *ioaddr, u32 mask)\r\n{\r\niowrite8(CAMC_CAMEN | CAMC_VCAMSL, ioaddr + CamCon);\r\nwmb();\r\niowrite32(mask, ioaddr + CamMask);\r\niowrite8(0, ioaddr + CamCon);\r\n}\r\nstatic void rhine_init_cam_filter(struct net_device *dev)\r\n{\r\nstruct rhine_private *rp = netdev_priv(dev);\r\nvoid __iomem *ioaddr = rp->base;\r\nrhine_set_vlan_cam_mask(ioaddr, 0);\r\nrhine_set_cam_mask(ioaddr, 0);\r\nBYTE_REG_BITS_ON(TCR_PQEN, ioaddr + TxConfig);\r\nBYTE_REG_BITS_OFF(BCR1_VIDFR, ioaddr + PCIBusConfig1);\r\n}\r\nstatic void rhine_update_vcam(struct net_device *dev)\r\n{\r\nstruct rhine_private *rp = netdev_priv(dev);\r\nvoid __iomem *ioaddr = rp->base;\r\nu16 vid;\r\nu32 vCAMmask = 0;\r\nunsigned int i = 0;\r\nfor_each_set_bit(vid, rp->active_vlans, VLAN_N_VID) {\r\nrhine_set_vlan_cam(ioaddr, i, (u8 *)&vid);\r\nvCAMmask |= 1 << i;\r\nif (++i >= VCAM_SIZE)\r\nbreak;\r\n}\r\nrhine_set_vlan_cam_mask(ioaddr, vCAMmask);\r\n}\r\nstatic int rhine_vlan_rx_add_vid(struct net_device *dev, __be16 proto, u16 vid)\r\n{\r\nstruct rhine_private *rp = netdev_priv(dev);\r\nspin_lock_bh(&rp->lock);\r\nset_bit(vid, rp->active_vlans);\r\nrhine_update_vcam(dev);\r\nspin_unlock_bh(&rp->lock);\r\nreturn 0;\r\n}\r\nstatic int rhine_vlan_rx_kill_vid(struct net_device *dev, __be16 proto, u16 vid)\r\n{\r\nstruct rhine_private *rp = netdev_priv(dev);\r\nspin_lock_bh(&rp->lock);\r\nclear_bit(vid, rp->active_vlans);\r\nrhine_update_vcam(dev);\r\nspin_unlock_bh(&rp->lock);\r\nreturn 0;\r\n}\r\nstatic void init_registers(struct net_device *dev)\r\n{\r\nstruct rhine_private *rp = netdev_priv(dev);\r\nvoid __iomem *ioaddr = rp->base;\r\nint i;\r\nfor (i = 0; i < 6; i++)\r\niowrite8(dev->dev_addr[i], ioaddr + StationAddr + i);\r\niowrite16(0x0006, ioaddr + PCIBusConfig);\r\niowrite8(0x20, ioaddr + TxConfig);\r\nrp->tx_thresh = 0x20;\r\nrp->rx_thresh = 0x60;\r\niowrite32(rp->rx_ring_dma, ioaddr + RxRingPtr);\r\niowrite32(rp->tx_ring_dma, ioaddr + TxRingPtr);\r\nrhine_set_rx_mode(dev);\r\nif (rp->quirks & rqMgmt)\r\nrhine_init_cam_filter(dev);\r\nnapi_enable(&rp->napi);\r\niowrite16(RHINE_EVENT & 0xffff, ioaddr + IntrEnable);\r\niowrite16(CmdStart | CmdTxOn | CmdRxOn | (Cmd1NoTxPoll << 8),\r\nioaddr + ChipCmd);\r\nrhine_check_media(dev, 1);\r\n}\r\nstatic void rhine_enable_linkmon(struct rhine_private *rp)\r\n{\r\nvoid __iomem *ioaddr = rp->base;\r\niowrite8(0, ioaddr + MIICmd);\r\niowrite8(MII_BMSR, ioaddr + MIIRegAddr);\r\niowrite8(0x80, ioaddr + MIICmd);\r\nrhine_wait_bit_high(rp, MIIRegAddr, 0x20);\r\niowrite8(MII_BMSR | 0x40, ioaddr + MIIRegAddr);\r\n}\r\nstatic void rhine_disable_linkmon(struct rhine_private *rp)\r\n{\r\nvoid __iomem *ioaddr = rp->base;\r\niowrite8(0, ioaddr + MIICmd);\r\nif (rp->quirks & rqRhineI) {\r\niowrite8(0x01, ioaddr + MIIRegAddr);\r\nmdelay(1);\r\niowrite8(0x80, ioaddr + MIICmd);\r\nrhine_wait_bit_high(rp, MIIRegAddr, 0x20);\r\niowrite8(0, ioaddr + MIICmd);\r\n}\r\nelse\r\nrhine_wait_bit_high(rp, MIIRegAddr, 0x80);\r\n}\r\nstatic int mdio_read(struct net_device *dev, int phy_id, int regnum)\r\n{\r\nstruct rhine_private *rp = netdev_priv(dev);\r\nvoid __iomem *ioaddr = rp->base;\r\nint result;\r\nrhine_disable_linkmon(rp);\r\niowrite8(phy_id, ioaddr + MIIPhyAddr);\r\niowrite8(regnum, ioaddr + MIIRegAddr);\r\niowrite8(0x40, ioaddr + MIICmd);\r\nrhine_wait_bit_low(rp, MIICmd, 0x40);\r\nresult = ioread16(ioaddr + MIIData);\r\nrhine_enable_linkmon(rp);\r\nreturn result;\r\n}\r\nstatic void mdio_write(struct net_device *dev, int phy_id, int regnum, int value)\r\n{\r\nstruct rhine_private *rp = netdev_priv(dev);\r\nvoid __iomem *ioaddr = rp->base;\r\nrhine_disable_linkmon(rp);\r\niowrite8(phy_id, ioaddr + MIIPhyAddr);\r\niowrite8(regnum, ioaddr + MIIRegAddr);\r\niowrite16(value, ioaddr + MIIData);\r\niowrite8(0x20, ioaddr + MIICmd);\r\nrhine_wait_bit_low(rp, MIICmd, 0x20);\r\nrhine_enable_linkmon(rp);\r\n}\r\nstatic void rhine_task_disable(struct rhine_private *rp)\r\n{\r\nmutex_lock(&rp->task_lock);\r\nrp->task_enable = false;\r\nmutex_unlock(&rp->task_lock);\r\ncancel_work_sync(&rp->slow_event_task);\r\ncancel_work_sync(&rp->reset_task);\r\n}\r\nstatic void rhine_task_enable(struct rhine_private *rp)\r\n{\r\nmutex_lock(&rp->task_lock);\r\nrp->task_enable = true;\r\nmutex_unlock(&rp->task_lock);\r\n}\r\nstatic int rhine_open(struct net_device *dev)\r\n{\r\nstruct rhine_private *rp = netdev_priv(dev);\r\nvoid __iomem *ioaddr = rp->base;\r\nint rc;\r\nrc = request_irq(rp->irq, rhine_interrupt, IRQF_SHARED, dev->name, dev);\r\nif (rc)\r\ngoto out;\r\nnetif_dbg(rp, ifup, dev, "%s() irq %d\n", __func__, rp->irq);\r\nrc = alloc_ring(dev);\r\nif (rc < 0)\r\ngoto out_free_irq;\r\nrc = alloc_rbufs(dev);\r\nif (rc < 0)\r\ngoto out_free_ring;\r\nalloc_tbufs(dev);\r\nrhine_chip_reset(dev);\r\nrhine_task_enable(rp);\r\ninit_registers(dev);\r\nnetif_dbg(rp, ifup, dev, "%s() Done - status %04x MII status: %04x\n",\r\n__func__, ioread16(ioaddr + ChipCmd),\r\nmdio_read(dev, rp->mii_if.phy_id, MII_BMSR));\r\nnetif_start_queue(dev);\r\nout:\r\nreturn rc;\r\nout_free_ring:\r\nfree_ring(dev);\r\nout_free_irq:\r\nfree_irq(rp->irq, dev);\r\ngoto out;\r\n}\r\nstatic void rhine_reset_task(struct work_struct *work)\r\n{\r\nstruct rhine_private *rp = container_of(work, struct rhine_private,\r\nreset_task);\r\nstruct net_device *dev = rp->dev;\r\nmutex_lock(&rp->task_lock);\r\nif (!rp->task_enable)\r\ngoto out_unlock;\r\nnapi_disable(&rp->napi);\r\nnetif_tx_disable(dev);\r\nspin_lock_bh(&rp->lock);\r\nfree_tbufs(dev);\r\nalloc_tbufs(dev);\r\nrhine_reset_rbufs(rp);\r\nrhine_chip_reset(dev);\r\ninit_registers(dev);\r\nspin_unlock_bh(&rp->lock);\r\ndev->trans_start = jiffies;\r\ndev->stats.tx_errors++;\r\nnetif_wake_queue(dev);\r\nout_unlock:\r\nmutex_unlock(&rp->task_lock);\r\n}\r\nstatic void rhine_tx_timeout(struct net_device *dev)\r\n{\r\nstruct rhine_private *rp = netdev_priv(dev);\r\nvoid __iomem *ioaddr = rp->base;\r\nnetdev_warn(dev, "Transmit timed out, status %04x, PHY status %04x, resetting...\n",\r\nioread16(ioaddr + IntrStatus),\r\nmdio_read(dev, rp->mii_if.phy_id, MII_BMSR));\r\nschedule_work(&rp->reset_task);\r\n}\r\nstatic inline bool rhine_tx_queue_full(struct rhine_private *rp)\r\n{\r\nreturn (rp->cur_tx - rp->dirty_tx) >= TX_QUEUE_LEN;\r\n}\r\nstatic netdev_tx_t rhine_start_tx(struct sk_buff *skb,\r\nstruct net_device *dev)\r\n{\r\nstruct rhine_private *rp = netdev_priv(dev);\r\nstruct device *hwdev = dev->dev.parent;\r\nvoid __iomem *ioaddr = rp->base;\r\nunsigned entry;\r\nentry = rp->cur_tx % TX_RING_SIZE;\r\nif (skb_padto(skb, ETH_ZLEN))\r\nreturn NETDEV_TX_OK;\r\nrp->tx_skbuff[entry] = skb;\r\nif ((rp->quirks & rqRhineI) &&\r\n(((unsigned long)skb->data & 3) || skb_shinfo(skb)->nr_frags != 0 || skb->ip_summed == CHECKSUM_PARTIAL)) {\r\nif (skb->len > PKT_BUF_SZ) {\r\ndev_kfree_skb_any(skb);\r\nrp->tx_skbuff[entry] = NULL;\r\ndev->stats.tx_dropped++;\r\nreturn NETDEV_TX_OK;\r\n}\r\nskb_copy_and_csum_dev(skb, rp->tx_buf[entry]);\r\nif (skb->len < ETH_ZLEN)\r\nmemset(rp->tx_buf[entry] + skb->len, 0,\r\nETH_ZLEN - skb->len);\r\nrp->tx_skbuff_dma[entry] = 0;\r\nrp->tx_ring[entry].addr = cpu_to_le32(rp->tx_bufs_dma +\r\n(rp->tx_buf[entry] -\r\nrp->tx_bufs));\r\n} else {\r\nrp->tx_skbuff_dma[entry] =\r\ndma_map_single(hwdev, skb->data, skb->len,\r\nDMA_TO_DEVICE);\r\nif (dma_mapping_error(hwdev, rp->tx_skbuff_dma[entry])) {\r\ndev_kfree_skb_any(skb);\r\nrp->tx_skbuff_dma[entry] = 0;\r\ndev->stats.tx_dropped++;\r\nreturn NETDEV_TX_OK;\r\n}\r\nrp->tx_ring[entry].addr = cpu_to_le32(rp->tx_skbuff_dma[entry]);\r\n}\r\nrp->tx_ring[entry].desc_length =\r\ncpu_to_le32(TXDESC | (skb->len >= ETH_ZLEN ? skb->len : ETH_ZLEN));\r\nif (unlikely(skb_vlan_tag_present(skb))) {\r\nu16 vid_pcp = skb_vlan_tag_get(skb);\r\nvid_pcp = (vid_pcp & VLAN_VID_MASK) |\r\n((vid_pcp & VLAN_PRIO_MASK) >> 1);\r\nrp->tx_ring[entry].tx_status = cpu_to_le32((vid_pcp) << 16);\r\nrp->tx_ring[entry].desc_length |= cpu_to_le32(0x020000);\r\n}\r\nelse\r\nrp->tx_ring[entry].tx_status = 0;\r\nnetdev_sent_queue(dev, skb->len);\r\ndma_wmb();\r\nrp->tx_ring[entry].tx_status |= cpu_to_le32(DescOwn);\r\nwmb();\r\nrp->cur_tx++;\r\nsmp_wmb();\r\nif (skb_vlan_tag_present(skb))\r\nBYTE_REG_BITS_ON(1 << 7, ioaddr + TQWake);\r\niowrite8(ioread8(ioaddr + ChipCmd1) | Cmd1TxDemand,\r\nioaddr + ChipCmd1);\r\nIOSYNC;\r\nif (rhine_tx_queue_full(rp)) {\r\nnetif_stop_queue(dev);\r\nsmp_rmb();\r\nif (!rhine_tx_queue_full(rp))\r\nnetif_wake_queue(dev);\r\n}\r\nnetif_dbg(rp, tx_queued, dev, "Transmit frame #%d queued in slot %d\n",\r\nrp->cur_tx - 1, entry);\r\nreturn NETDEV_TX_OK;\r\n}\r\nstatic void rhine_irq_disable(struct rhine_private *rp)\r\n{\r\niowrite16(0x0000, rp->base + IntrEnable);\r\nmmiowb();\r\n}\r\nstatic irqreturn_t rhine_interrupt(int irq, void *dev_instance)\r\n{\r\nstruct net_device *dev = dev_instance;\r\nstruct rhine_private *rp = netdev_priv(dev);\r\nu32 status;\r\nint handled = 0;\r\nstatus = rhine_get_events(rp);\r\nnetif_dbg(rp, intr, dev, "Interrupt, status %08x\n", status);\r\nif (status & RHINE_EVENT) {\r\nhandled = 1;\r\nrhine_irq_disable(rp);\r\nnapi_schedule(&rp->napi);\r\n}\r\nif (status & ~(IntrLinkChange | IntrStatsMax | RHINE_EVENT_NAPI)) {\r\nnetif_err(rp, intr, dev, "Something Wicked happened! %08x\n",\r\nstatus);\r\n}\r\nreturn IRQ_RETVAL(handled);\r\n}\r\nstatic void rhine_tx(struct net_device *dev)\r\n{\r\nstruct rhine_private *rp = netdev_priv(dev);\r\nstruct device *hwdev = dev->dev.parent;\r\nunsigned int pkts_compl = 0, bytes_compl = 0;\r\nunsigned int dirty_tx = rp->dirty_tx;\r\nunsigned int cur_tx;\r\nstruct sk_buff *skb;\r\nsmp_rmb();\r\ncur_tx = rp->cur_tx;\r\nwhile (dirty_tx != cur_tx) {\r\nunsigned int entry = dirty_tx % TX_RING_SIZE;\r\nu32 txstatus = le32_to_cpu(rp->tx_ring[entry].tx_status);\r\nnetif_dbg(rp, tx_done, dev, "Tx scavenge %d status %08x\n",\r\nentry, txstatus);\r\nif (txstatus & DescOwn)\r\nbreak;\r\nskb = rp->tx_skbuff[entry];\r\nif (txstatus & 0x8000) {\r\nnetif_dbg(rp, tx_done, dev,\r\n"Transmit error, Tx status %08x\n", txstatus);\r\ndev->stats.tx_errors++;\r\nif (txstatus & 0x0400)\r\ndev->stats.tx_carrier_errors++;\r\nif (txstatus & 0x0200)\r\ndev->stats.tx_window_errors++;\r\nif (txstatus & 0x0100)\r\ndev->stats.tx_aborted_errors++;\r\nif (txstatus & 0x0080)\r\ndev->stats.tx_heartbeat_errors++;\r\nif (((rp->quirks & rqRhineI) && txstatus & 0x0002) ||\r\n(txstatus & 0x0800) || (txstatus & 0x1000)) {\r\ndev->stats.tx_fifo_errors++;\r\nrp->tx_ring[entry].tx_status = cpu_to_le32(DescOwn);\r\nbreak;\r\n}\r\n} else {\r\nif (rp->quirks & rqRhineI)\r\ndev->stats.collisions += (txstatus >> 3) & 0x0F;\r\nelse\r\ndev->stats.collisions += txstatus & 0x0F;\r\nnetif_dbg(rp, tx_done, dev, "collisions: %1.1x:%1.1x\n",\r\n(txstatus >> 3) & 0xF, txstatus & 0xF);\r\nu64_stats_update_begin(&rp->tx_stats.syncp);\r\nrp->tx_stats.bytes += skb->len;\r\nrp->tx_stats.packets++;\r\nu64_stats_update_end(&rp->tx_stats.syncp);\r\n}\r\nif (rp->tx_skbuff_dma[entry]) {\r\ndma_unmap_single(hwdev,\r\nrp->tx_skbuff_dma[entry],\r\nskb->len,\r\nDMA_TO_DEVICE);\r\n}\r\nbytes_compl += skb->len;\r\npkts_compl++;\r\ndev_consume_skb_any(skb);\r\nrp->tx_skbuff[entry] = NULL;\r\ndirty_tx++;\r\n}\r\nrp->dirty_tx = dirty_tx;\r\nsmp_wmb();\r\nnetdev_completed_queue(dev, pkts_compl, bytes_compl);\r\nif (!rhine_tx_queue_full(rp) && netif_queue_stopped(dev)) {\r\nnetif_wake_queue(dev);\r\nsmp_rmb();\r\nif (rhine_tx_queue_full(rp))\r\nnetif_stop_queue(dev);\r\n}\r\n}\r\nstatic inline u16 rhine_get_vlan_tci(struct sk_buff *skb, int data_size)\r\n{\r\nu8 *trailer = (u8 *)skb->data + ((data_size + 3) & ~3) + 2;\r\nreturn be16_to_cpup((__be16 *)trailer);\r\n}\r\nstatic inline void rhine_rx_vlan_tag(struct sk_buff *skb, struct rx_desc *desc,\r\nint data_size)\r\n{\r\ndma_rmb();\r\nif (unlikely(desc->desc_length & cpu_to_le32(DescTag))) {\r\nu16 vlan_tci;\r\nvlan_tci = rhine_get_vlan_tci(skb, data_size);\r\n__vlan_hwaccel_put_tag(skb, htons(ETH_P_8021Q), vlan_tci);\r\n}\r\n}\r\nstatic int rhine_rx(struct net_device *dev, int limit)\r\n{\r\nstruct rhine_private *rp = netdev_priv(dev);\r\nstruct device *hwdev = dev->dev.parent;\r\nint entry = rp->cur_rx % RX_RING_SIZE;\r\nint count;\r\nnetif_dbg(rp, rx_status, dev, "%s(), entry %d status %08x\n", __func__,\r\nentry, le32_to_cpu(rp->rx_ring[entry].rx_status));\r\nfor (count = 0; count < limit; ++count) {\r\nstruct rx_desc *desc = rp->rx_ring + entry;\r\nu32 desc_status = le32_to_cpu(desc->rx_status);\r\nint data_size = desc_status >> 16;\r\nif (desc_status & DescOwn)\r\nbreak;\r\nnetif_dbg(rp, rx_status, dev, "%s() status %08x\n", __func__,\r\ndesc_status);\r\nif ((desc_status & (RxWholePkt | RxErr)) != RxWholePkt) {\r\nif ((desc_status & RxWholePkt) != RxWholePkt) {\r\nnetdev_warn(dev,\r\n"Oversized Ethernet frame spanned multiple buffers, "\r\n"entry %#x length %d status %08x!\n",\r\nentry, data_size,\r\ndesc_status);\r\ndev->stats.rx_length_errors++;\r\n} else if (desc_status & RxErr) {\r\nnetif_dbg(rp, rx_err, dev,\r\n"%s() Rx error %08x\n", __func__,\r\ndesc_status);\r\ndev->stats.rx_errors++;\r\nif (desc_status & 0x0030)\r\ndev->stats.rx_length_errors++;\r\nif (desc_status & 0x0048)\r\ndev->stats.rx_fifo_errors++;\r\nif (desc_status & 0x0004)\r\ndev->stats.rx_frame_errors++;\r\nif (desc_status & 0x0002) {\r\nspin_lock(&rp->lock);\r\ndev->stats.rx_crc_errors++;\r\nspin_unlock(&rp->lock);\r\n}\r\n}\r\n} else {\r\nint pkt_len = data_size - 4;\r\nstruct sk_buff *skb;\r\nif (pkt_len < rx_copybreak) {\r\nskb = netdev_alloc_skb_ip_align(dev, pkt_len);\r\nif (unlikely(!skb))\r\ngoto drop;\r\ndma_sync_single_for_cpu(hwdev,\r\nrp->rx_skbuff_dma[entry],\r\nrp->rx_buf_sz,\r\nDMA_FROM_DEVICE);\r\nskb_copy_to_linear_data(skb,\r\nrp->rx_skbuff[entry]->data,\r\npkt_len);\r\ndma_sync_single_for_device(hwdev,\r\nrp->rx_skbuff_dma[entry],\r\nrp->rx_buf_sz,\r\nDMA_FROM_DEVICE);\r\n} else {\r\nstruct rhine_skb_dma sd;\r\nif (unlikely(rhine_skb_dma_init(dev, &sd) < 0))\r\ngoto drop;\r\nskb = rp->rx_skbuff[entry];\r\ndma_unmap_single(hwdev,\r\nrp->rx_skbuff_dma[entry],\r\nrp->rx_buf_sz,\r\nDMA_FROM_DEVICE);\r\nrhine_skb_dma_nic_store(rp, &sd, entry);\r\n}\r\nskb_put(skb, pkt_len);\r\nrhine_rx_vlan_tag(skb, desc, data_size);\r\nskb->protocol = eth_type_trans(skb, dev);\r\nnetif_receive_skb(skb);\r\nu64_stats_update_begin(&rp->rx_stats.syncp);\r\nrp->rx_stats.bytes += pkt_len;\r\nrp->rx_stats.packets++;\r\nu64_stats_update_end(&rp->rx_stats.syncp);\r\n}\r\ngive_descriptor_to_nic:\r\ndesc->rx_status = cpu_to_le32(DescOwn);\r\nentry = (++rp->cur_rx) % RX_RING_SIZE;\r\n}\r\nreturn count;\r\ndrop:\r\ndev->stats.rx_dropped++;\r\ngoto give_descriptor_to_nic;\r\n}\r\nstatic void rhine_restart_tx(struct net_device *dev) {\r\nstruct rhine_private *rp = netdev_priv(dev);\r\nvoid __iomem *ioaddr = rp->base;\r\nint entry = rp->dirty_tx % TX_RING_SIZE;\r\nu32 intr_status;\r\nintr_status = rhine_get_events(rp);\r\nif ((intr_status & IntrTxErrSummary) == 0) {\r\niowrite32(rp->tx_ring_dma + entry * sizeof(struct tx_desc),\r\nioaddr + TxRingPtr);\r\niowrite8(ioread8(ioaddr + ChipCmd) | CmdTxOn,\r\nioaddr + ChipCmd);\r\nif (rp->tx_ring[entry].desc_length & cpu_to_le32(0x020000))\r\nBYTE_REG_BITS_ON(1 << 7, ioaddr + TQWake);\r\niowrite8(ioread8(ioaddr + ChipCmd1) | Cmd1TxDemand,\r\nioaddr + ChipCmd1);\r\nIOSYNC;\r\n}\r\nelse {\r\nnetif_warn(rp, tx_err, dev, "another error occurred %08x\n",\r\nintr_status);\r\n}\r\n}\r\nstatic void rhine_slow_event_task(struct work_struct *work)\r\n{\r\nstruct rhine_private *rp =\r\ncontainer_of(work, struct rhine_private, slow_event_task);\r\nstruct net_device *dev = rp->dev;\r\nu32 intr_status;\r\nmutex_lock(&rp->task_lock);\r\nif (!rp->task_enable)\r\ngoto out_unlock;\r\nintr_status = rhine_get_events(rp);\r\nrhine_ack_events(rp, intr_status & RHINE_EVENT_SLOW);\r\nif (intr_status & IntrLinkChange)\r\nrhine_check_media(dev, 0);\r\nif (intr_status & IntrPCIErr)\r\nnetif_warn(rp, hw, dev, "PCI error\n");\r\niowrite16(RHINE_EVENT & 0xffff, rp->base + IntrEnable);\r\nout_unlock:\r\nmutex_unlock(&rp->task_lock);\r\n}\r\nstatic struct rtnl_link_stats64 *\r\nrhine_get_stats64(struct net_device *dev, struct rtnl_link_stats64 *stats)\r\n{\r\nstruct rhine_private *rp = netdev_priv(dev);\r\nunsigned int start;\r\nspin_lock_bh(&rp->lock);\r\nrhine_update_rx_crc_and_missed_errord(rp);\r\nspin_unlock_bh(&rp->lock);\r\nnetdev_stats_to_stats64(stats, &dev->stats);\r\ndo {\r\nstart = u64_stats_fetch_begin_irq(&rp->rx_stats.syncp);\r\nstats->rx_packets = rp->rx_stats.packets;\r\nstats->rx_bytes = rp->rx_stats.bytes;\r\n} while (u64_stats_fetch_retry_irq(&rp->rx_stats.syncp, start));\r\ndo {\r\nstart = u64_stats_fetch_begin_irq(&rp->tx_stats.syncp);\r\nstats->tx_packets = rp->tx_stats.packets;\r\nstats->tx_bytes = rp->tx_stats.bytes;\r\n} while (u64_stats_fetch_retry_irq(&rp->tx_stats.syncp, start));\r\nreturn stats;\r\n}\r\nstatic void rhine_set_rx_mode(struct net_device *dev)\r\n{\r\nstruct rhine_private *rp = netdev_priv(dev);\r\nvoid __iomem *ioaddr = rp->base;\r\nu32 mc_filter[2];\r\nu8 rx_mode = 0x0C;\r\nstruct netdev_hw_addr *ha;\r\nif (dev->flags & IFF_PROMISC) {\r\nrx_mode = 0x1C;\r\niowrite32(0xffffffff, ioaddr + MulticastFilter0);\r\niowrite32(0xffffffff, ioaddr + MulticastFilter1);\r\n} else if ((netdev_mc_count(dev) > multicast_filter_limit) ||\r\n(dev->flags & IFF_ALLMULTI)) {\r\niowrite32(0xffffffff, ioaddr + MulticastFilter0);\r\niowrite32(0xffffffff, ioaddr + MulticastFilter1);\r\n} else if (rp->quirks & rqMgmt) {\r\nint i = 0;\r\nu32 mCAMmask = 0;\r\nnetdev_for_each_mc_addr(ha, dev) {\r\nif (i == MCAM_SIZE)\r\nbreak;\r\nrhine_set_cam(ioaddr, i, ha->addr);\r\nmCAMmask |= 1 << i;\r\ni++;\r\n}\r\nrhine_set_cam_mask(ioaddr, mCAMmask);\r\n} else {\r\nmemset(mc_filter, 0, sizeof(mc_filter));\r\nnetdev_for_each_mc_addr(ha, dev) {\r\nint bit_nr = ether_crc(ETH_ALEN, ha->addr) >> 26;\r\nmc_filter[bit_nr >> 5] |= 1 << (bit_nr & 31);\r\n}\r\niowrite32(mc_filter[0], ioaddr + MulticastFilter0);\r\niowrite32(mc_filter[1], ioaddr + MulticastFilter1);\r\n}\r\nif (rp->quirks & rqMgmt) {\r\nif (dev->flags & IFF_PROMISC)\r\nBYTE_REG_BITS_OFF(BCR1_VIDFR, ioaddr + PCIBusConfig1);\r\nelse\r\nBYTE_REG_BITS_ON(BCR1_VIDFR, ioaddr + PCIBusConfig1);\r\n}\r\nBYTE_REG_BITS_ON(rx_mode, ioaddr + RxConfig);\r\n}\r\nstatic void netdev_get_drvinfo(struct net_device *dev, struct ethtool_drvinfo *info)\r\n{\r\nstruct device *hwdev = dev->dev.parent;\r\nstrlcpy(info->driver, DRV_NAME, sizeof(info->driver));\r\nstrlcpy(info->version, DRV_VERSION, sizeof(info->version));\r\nstrlcpy(info->bus_info, dev_name(hwdev), sizeof(info->bus_info));\r\n}\r\nstatic int netdev_get_settings(struct net_device *dev, struct ethtool_cmd *cmd)\r\n{\r\nstruct rhine_private *rp = netdev_priv(dev);\r\nint rc;\r\nmutex_lock(&rp->task_lock);\r\nrc = mii_ethtool_gset(&rp->mii_if, cmd);\r\nmutex_unlock(&rp->task_lock);\r\nreturn rc;\r\n}\r\nstatic int netdev_set_settings(struct net_device *dev, struct ethtool_cmd *cmd)\r\n{\r\nstruct rhine_private *rp = netdev_priv(dev);\r\nint rc;\r\nmutex_lock(&rp->task_lock);\r\nrc = mii_ethtool_sset(&rp->mii_if, cmd);\r\nrhine_set_carrier(&rp->mii_if);\r\nmutex_unlock(&rp->task_lock);\r\nreturn rc;\r\n}\r\nstatic int netdev_nway_reset(struct net_device *dev)\r\n{\r\nstruct rhine_private *rp = netdev_priv(dev);\r\nreturn mii_nway_restart(&rp->mii_if);\r\n}\r\nstatic u32 netdev_get_link(struct net_device *dev)\r\n{\r\nstruct rhine_private *rp = netdev_priv(dev);\r\nreturn mii_link_ok(&rp->mii_if);\r\n}\r\nstatic u32 netdev_get_msglevel(struct net_device *dev)\r\n{\r\nstruct rhine_private *rp = netdev_priv(dev);\r\nreturn rp->msg_enable;\r\n}\r\nstatic void netdev_set_msglevel(struct net_device *dev, u32 value)\r\n{\r\nstruct rhine_private *rp = netdev_priv(dev);\r\nrp->msg_enable = value;\r\n}\r\nstatic void rhine_get_wol(struct net_device *dev, struct ethtool_wolinfo *wol)\r\n{\r\nstruct rhine_private *rp = netdev_priv(dev);\r\nif (!(rp->quirks & rqWOL))\r\nreturn;\r\nspin_lock_irq(&rp->lock);\r\nwol->supported = WAKE_PHY | WAKE_MAGIC |\r\nWAKE_UCAST | WAKE_MCAST | WAKE_BCAST;\r\nwol->wolopts = rp->wolopts;\r\nspin_unlock_irq(&rp->lock);\r\n}\r\nstatic int rhine_set_wol(struct net_device *dev, struct ethtool_wolinfo *wol)\r\n{\r\nstruct rhine_private *rp = netdev_priv(dev);\r\nu32 support = WAKE_PHY | WAKE_MAGIC |\r\nWAKE_UCAST | WAKE_MCAST | WAKE_BCAST;\r\nif (!(rp->quirks & rqWOL))\r\nreturn -EINVAL;\r\nif (wol->wolopts & ~support)\r\nreturn -EINVAL;\r\nspin_lock_irq(&rp->lock);\r\nrp->wolopts = wol->wolopts;\r\nspin_unlock_irq(&rp->lock);\r\nreturn 0;\r\n}\r\nstatic int netdev_ioctl(struct net_device *dev, struct ifreq *rq, int cmd)\r\n{\r\nstruct rhine_private *rp = netdev_priv(dev);\r\nint rc;\r\nif (!netif_running(dev))\r\nreturn -EINVAL;\r\nmutex_lock(&rp->task_lock);\r\nrc = generic_mii_ioctl(&rp->mii_if, if_mii(rq), cmd, NULL);\r\nrhine_set_carrier(&rp->mii_if);\r\nmutex_unlock(&rp->task_lock);\r\nreturn rc;\r\n}\r\nstatic int rhine_close(struct net_device *dev)\r\n{\r\nstruct rhine_private *rp = netdev_priv(dev);\r\nvoid __iomem *ioaddr = rp->base;\r\nrhine_task_disable(rp);\r\nnapi_disable(&rp->napi);\r\nnetif_stop_queue(dev);\r\nnetif_dbg(rp, ifdown, dev, "Shutting down ethercard, status was %04x\n",\r\nioread16(ioaddr + ChipCmd));\r\niowrite8(rp->tx_thresh | 0x02, ioaddr + TxConfig);\r\nrhine_irq_disable(rp);\r\niowrite16(CmdStop, ioaddr + ChipCmd);\r\nfree_irq(rp->irq, dev);\r\nfree_rbufs(dev);\r\nfree_tbufs(dev);\r\nfree_ring(dev);\r\nreturn 0;\r\n}\r\nstatic void rhine_remove_one_pci(struct pci_dev *pdev)\r\n{\r\nstruct net_device *dev = pci_get_drvdata(pdev);\r\nstruct rhine_private *rp = netdev_priv(dev);\r\nunregister_netdev(dev);\r\npci_iounmap(pdev, rp->base);\r\npci_release_regions(pdev);\r\nfree_netdev(dev);\r\npci_disable_device(pdev);\r\n}\r\nstatic int rhine_remove_one_platform(struct platform_device *pdev)\r\n{\r\nstruct net_device *dev = platform_get_drvdata(pdev);\r\nstruct rhine_private *rp = netdev_priv(dev);\r\nunregister_netdev(dev);\r\niounmap(rp->base);\r\nfree_netdev(dev);\r\nreturn 0;\r\n}\r\nstatic void rhine_shutdown_pci(struct pci_dev *pdev)\r\n{\r\nstruct net_device *dev = pci_get_drvdata(pdev);\r\nstruct rhine_private *rp = netdev_priv(dev);\r\nvoid __iomem *ioaddr = rp->base;\r\nif (!(rp->quirks & rqWOL))\r\nreturn;\r\nrhine_power_init(dev);\r\nif (rp->quirks & rq6patterns)\r\niowrite8(0x04, ioaddr + WOLcgClr);\r\nspin_lock(&rp->lock);\r\nif (rp->wolopts & WAKE_MAGIC) {\r\niowrite8(WOLmagic, ioaddr + WOLcrSet);\r\niowrite8(ioread8(ioaddr + ConfigA) | 0x03, ioaddr + ConfigA);\r\n}\r\nif (rp->wolopts & (WAKE_BCAST|WAKE_MCAST))\r\niowrite8(WOLbmcast, ioaddr + WOLcgSet);\r\nif (rp->wolopts & WAKE_PHY)\r\niowrite8(WOLlnkon | WOLlnkoff, ioaddr + WOLcrSet);\r\nif (rp->wolopts & WAKE_UCAST)\r\niowrite8(WOLucast, ioaddr + WOLcrSet);\r\nif (rp->wolopts) {\r\niowrite8(0x01, ioaddr + PwcfgSet);\r\niowrite8(ioread8(ioaddr + StickyHW) | 0x04, ioaddr + StickyHW);\r\n}\r\nspin_unlock(&rp->lock);\r\nif (system_state == SYSTEM_POWER_OFF && !avoid_D3) {\r\niowrite8(ioread8(ioaddr + StickyHW) | 0x03, ioaddr + StickyHW);\r\npci_wake_from_d3(pdev, true);\r\npci_set_power_state(pdev, PCI_D3hot);\r\n}\r\n}\r\nstatic int rhine_suspend(struct device *device)\r\n{\r\nstruct net_device *dev = dev_get_drvdata(device);\r\nstruct rhine_private *rp = netdev_priv(dev);\r\nif (!netif_running(dev))\r\nreturn 0;\r\nrhine_task_disable(rp);\r\nrhine_irq_disable(rp);\r\nnapi_disable(&rp->napi);\r\nnetif_device_detach(dev);\r\nif (dev_is_pci(device))\r\nrhine_shutdown_pci(to_pci_dev(device));\r\nreturn 0;\r\n}\r\nstatic int rhine_resume(struct device *device)\r\n{\r\nstruct net_device *dev = dev_get_drvdata(device);\r\nstruct rhine_private *rp = netdev_priv(dev);\r\nif (!netif_running(dev))\r\nreturn 0;\r\nenable_mmio(rp->pioaddr, rp->quirks);\r\nrhine_power_init(dev);\r\nfree_tbufs(dev);\r\nalloc_tbufs(dev);\r\nrhine_reset_rbufs(rp);\r\nrhine_task_enable(rp);\r\nspin_lock_bh(&rp->lock);\r\ninit_registers(dev);\r\nspin_unlock_bh(&rp->lock);\r\nnetif_device_attach(dev);\r\nreturn 0;\r\n}\r\nstatic int __init rhine_init(void)\r\n{\r\nint ret_pci, ret_platform;\r\n#ifdef MODULE\r\npr_info("%s\n", version);\r\n#endif\r\nif (dmi_check_system(rhine_dmi_table)) {\r\navoid_D3 = true;\r\npr_warn("Broken BIOS detected, avoid_D3 enabled\n");\r\n}\r\nelse if (avoid_D3)\r\npr_info("avoid_D3 set\n");\r\nret_pci = pci_register_driver(&rhine_driver_pci);\r\nret_platform = platform_driver_register(&rhine_driver_platform);\r\nif ((ret_pci < 0) && (ret_platform < 0))\r\nreturn ret_pci;\r\nreturn 0;\r\n}\r\nstatic void __exit rhine_cleanup(void)\r\n{\r\nplatform_driver_unregister(&rhine_driver_platform);\r\npci_unregister_driver(&rhine_driver_pci);\r\n}
