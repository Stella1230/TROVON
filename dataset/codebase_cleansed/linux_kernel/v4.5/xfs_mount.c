void\r\nxfs_uuid_table_free(void)\r\n{\r\nif (xfs_uuid_table_size == 0)\r\nreturn;\r\nkmem_free(xfs_uuid_table);\r\nxfs_uuid_table = NULL;\r\nxfs_uuid_table_size = 0;\r\n}\r\nSTATIC int\r\nxfs_uuid_mount(\r\nstruct xfs_mount *mp)\r\n{\r\nuuid_t *uuid = &mp->m_sb.sb_uuid;\r\nint hole, i;\r\nif (mp->m_flags & XFS_MOUNT_NOUUID)\r\nreturn 0;\r\nif (uuid_is_nil(uuid)) {\r\nxfs_warn(mp, "Filesystem has nil UUID - can't mount");\r\nreturn -EINVAL;\r\n}\r\nmutex_lock(&xfs_uuid_table_mutex);\r\nfor (i = 0, hole = -1; i < xfs_uuid_table_size; i++) {\r\nif (uuid_is_nil(&xfs_uuid_table[i])) {\r\nhole = i;\r\ncontinue;\r\n}\r\nif (uuid_equal(uuid, &xfs_uuid_table[i]))\r\ngoto out_duplicate;\r\n}\r\nif (hole < 0) {\r\nxfs_uuid_table = kmem_realloc(xfs_uuid_table,\r\n(xfs_uuid_table_size + 1) * sizeof(*xfs_uuid_table),\r\nxfs_uuid_table_size * sizeof(*xfs_uuid_table),\r\nKM_SLEEP);\r\nhole = xfs_uuid_table_size++;\r\n}\r\nxfs_uuid_table[hole] = *uuid;\r\nmutex_unlock(&xfs_uuid_table_mutex);\r\nreturn 0;\r\nout_duplicate:\r\nmutex_unlock(&xfs_uuid_table_mutex);\r\nxfs_warn(mp, "Filesystem has duplicate UUID %pU - can't mount", uuid);\r\nreturn -EINVAL;\r\n}\r\nSTATIC void\r\nxfs_uuid_unmount(\r\nstruct xfs_mount *mp)\r\n{\r\nuuid_t *uuid = &mp->m_sb.sb_uuid;\r\nint i;\r\nif (mp->m_flags & XFS_MOUNT_NOUUID)\r\nreturn;\r\nmutex_lock(&xfs_uuid_table_mutex);\r\nfor (i = 0; i < xfs_uuid_table_size; i++) {\r\nif (uuid_is_nil(&xfs_uuid_table[i]))\r\ncontinue;\r\nif (!uuid_equal(uuid, &xfs_uuid_table[i]))\r\ncontinue;\r\nmemset(&xfs_uuid_table[i], 0, sizeof(uuid_t));\r\nbreak;\r\n}\r\nASSERT(i < xfs_uuid_table_size);\r\nmutex_unlock(&xfs_uuid_table_mutex);\r\n}\r\nSTATIC void\r\n__xfs_free_perag(\r\nstruct rcu_head *head)\r\n{\r\nstruct xfs_perag *pag = container_of(head, struct xfs_perag, rcu_head);\r\nASSERT(atomic_read(&pag->pag_ref) == 0);\r\nkmem_free(pag);\r\n}\r\nSTATIC void\r\nxfs_free_perag(\r\nxfs_mount_t *mp)\r\n{\r\nxfs_agnumber_t agno;\r\nstruct xfs_perag *pag;\r\nfor (agno = 0; agno < mp->m_sb.sb_agcount; agno++) {\r\nspin_lock(&mp->m_perag_lock);\r\npag = radix_tree_delete(&mp->m_perag_tree, agno);\r\nspin_unlock(&mp->m_perag_lock);\r\nASSERT(pag);\r\nASSERT(atomic_read(&pag->pag_ref) == 0);\r\ncall_rcu(&pag->rcu_head, __xfs_free_perag);\r\n}\r\n}\r\nint\r\nxfs_sb_validate_fsb_count(\r\nxfs_sb_t *sbp,\r\n__uint64_t nblocks)\r\n{\r\nASSERT(PAGE_SHIFT >= sbp->sb_blocklog);\r\nASSERT(sbp->sb_blocklog >= BBSHIFT);\r\nif (nblocks >> (PAGE_CACHE_SHIFT - sbp->sb_blocklog) > ULONG_MAX)\r\nreturn -EFBIG;\r\nreturn 0;\r\n}\r\nint\r\nxfs_initialize_perag(\r\nxfs_mount_t *mp,\r\nxfs_agnumber_t agcount,\r\nxfs_agnumber_t *maxagi)\r\n{\r\nxfs_agnumber_t index;\r\nxfs_agnumber_t first_initialised = 0;\r\nxfs_perag_t *pag;\r\nxfs_agino_t agino;\r\nxfs_ino_t ino;\r\nxfs_sb_t *sbp = &mp->m_sb;\r\nint error = -ENOMEM;\r\nfor (index = 0; index < agcount; index++) {\r\npag = xfs_perag_get(mp, index);\r\nif (pag) {\r\nxfs_perag_put(pag);\r\ncontinue;\r\n}\r\nif (!first_initialised)\r\nfirst_initialised = index;\r\npag = kmem_zalloc(sizeof(*pag), KM_MAYFAIL);\r\nif (!pag)\r\ngoto out_unwind;\r\npag->pag_agno = index;\r\npag->pag_mount = mp;\r\nspin_lock_init(&pag->pag_ici_lock);\r\nmutex_init(&pag->pag_ici_reclaim_lock);\r\nINIT_RADIX_TREE(&pag->pag_ici_root, GFP_ATOMIC);\r\nspin_lock_init(&pag->pag_buf_lock);\r\npag->pag_buf_tree = RB_ROOT;\r\nif (radix_tree_preload(GFP_NOFS))\r\ngoto out_unwind;\r\nspin_lock(&mp->m_perag_lock);\r\nif (radix_tree_insert(&mp->m_perag_tree, index, pag)) {\r\nBUG();\r\nspin_unlock(&mp->m_perag_lock);\r\nradix_tree_preload_end();\r\nerror = -EEXIST;\r\ngoto out_unwind;\r\n}\r\nspin_unlock(&mp->m_perag_lock);\r\nradix_tree_preload_end();\r\n}\r\nagino = XFS_OFFBNO_TO_AGINO(mp, sbp->sb_agblocks - 1, 0);\r\nino = XFS_AGINO_TO_INO(mp, agcount - 1, agino);\r\nif ((mp->m_flags & XFS_MOUNT_SMALL_INUMS) && ino > XFS_MAXINUMBER_32)\r\nmp->m_flags |= XFS_MOUNT_32BITINODES;\r\nelse\r\nmp->m_flags &= ~XFS_MOUNT_32BITINODES;\r\nif (mp->m_flags & XFS_MOUNT_32BITINODES)\r\nindex = xfs_set_inode32(mp, agcount);\r\nelse\r\nindex = xfs_set_inode64(mp, agcount);\r\nif (maxagi)\r\n*maxagi = index;\r\nreturn 0;\r\nout_unwind:\r\nkmem_free(pag);\r\nfor (; index > first_initialised; index--) {\r\npag = radix_tree_delete(&mp->m_perag_tree, index);\r\nkmem_free(pag);\r\n}\r\nreturn error;\r\n}\r\nint\r\nxfs_readsb(\r\nstruct xfs_mount *mp,\r\nint flags)\r\n{\r\nunsigned int sector_size;\r\nstruct xfs_buf *bp;\r\nstruct xfs_sb *sbp = &mp->m_sb;\r\nint error;\r\nint loud = !(flags & XFS_MFSI_QUIET);\r\nconst struct xfs_buf_ops *buf_ops;\r\nASSERT(mp->m_sb_bp == NULL);\r\nASSERT(mp->m_ddev_targp != NULL);\r\nsector_size = xfs_getsize_buftarg(mp->m_ddev_targp);\r\nbuf_ops = NULL;\r\nreread:\r\nerror = xfs_buf_read_uncached(mp->m_ddev_targp, XFS_SB_DADDR,\r\nBTOBB(sector_size), 0, &bp, buf_ops);\r\nif (error) {\r\nif (loud)\r\nxfs_warn(mp, "SB validate failed with error %d.", error);\r\nif (error == -EFSBADCRC)\r\nerror = -EFSCORRUPTED;\r\nreturn error;\r\n}\r\nxfs_sb_from_disk(sbp, XFS_BUF_TO_SBP(bp));\r\nif (sbp->sb_magicnum != XFS_SB_MAGIC) {\r\nif (loud)\r\nxfs_warn(mp, "Invalid superblock magic number");\r\nerror = -EINVAL;\r\ngoto release_buf;\r\n}\r\nif (sector_size > sbp->sb_sectsize) {\r\nif (loud)\r\nxfs_warn(mp, "device supports %u byte sectors (not %u)",\r\nsector_size, sbp->sb_sectsize);\r\nerror = -ENOSYS;\r\ngoto release_buf;\r\n}\r\nif (buf_ops == NULL) {\r\nxfs_buf_relse(bp);\r\nsector_size = sbp->sb_sectsize;\r\nbuf_ops = loud ? &xfs_sb_buf_ops : &xfs_sb_quiet_buf_ops;\r\ngoto reread;\r\n}\r\nxfs_reinit_percpu_counters(mp);\r\nbp->b_ops = &xfs_sb_buf_ops;\r\nmp->m_sb_bp = bp;\r\nxfs_buf_unlock(bp);\r\nreturn 0;\r\nrelease_buf:\r\nxfs_buf_relse(bp);\r\nreturn error;\r\n}\r\nSTATIC int\r\nxfs_update_alignment(xfs_mount_t *mp)\r\n{\r\nxfs_sb_t *sbp = &(mp->m_sb);\r\nif (mp->m_dalign) {\r\nif ((BBTOB(mp->m_dalign) & mp->m_blockmask) ||\r\n(BBTOB(mp->m_swidth) & mp->m_blockmask)) {\r\nxfs_warn(mp,\r\n"alignment check failed: sunit/swidth vs. blocksize(%d)",\r\nsbp->sb_blocksize);\r\nreturn -EINVAL;\r\n} else {\r\nmp->m_dalign = XFS_BB_TO_FSBT(mp, mp->m_dalign);\r\nif (mp->m_dalign && (sbp->sb_agblocks % mp->m_dalign)) {\r\nxfs_warn(mp,\r\n"alignment check failed: sunit/swidth vs. agsize(%d)",\r\nsbp->sb_agblocks);\r\nreturn -EINVAL;\r\n} else if (mp->m_dalign) {\r\nmp->m_swidth = XFS_BB_TO_FSBT(mp, mp->m_swidth);\r\n} else {\r\nxfs_warn(mp,\r\n"alignment check failed: sunit(%d) less than bsize(%d)",\r\nmp->m_dalign, sbp->sb_blocksize);\r\nreturn -EINVAL;\r\n}\r\n}\r\nif (xfs_sb_version_hasdalign(sbp)) {\r\nif (sbp->sb_unit != mp->m_dalign) {\r\nsbp->sb_unit = mp->m_dalign;\r\nmp->m_update_sb = true;\r\n}\r\nif (sbp->sb_width != mp->m_swidth) {\r\nsbp->sb_width = mp->m_swidth;\r\nmp->m_update_sb = true;\r\n}\r\n} else {\r\nxfs_warn(mp,\r\n"cannot change alignment: superblock does not support data alignment");\r\nreturn -EINVAL;\r\n}\r\n} else if ((mp->m_flags & XFS_MOUNT_NOALIGN) != XFS_MOUNT_NOALIGN &&\r\nxfs_sb_version_hasdalign(&mp->m_sb)) {\r\nmp->m_dalign = sbp->sb_unit;\r\nmp->m_swidth = sbp->sb_width;\r\n}\r\nreturn 0;\r\n}\r\nSTATIC void\r\nxfs_set_maxicount(xfs_mount_t *mp)\r\n{\r\nxfs_sb_t *sbp = &(mp->m_sb);\r\n__uint64_t icount;\r\nif (sbp->sb_imax_pct) {\r\nicount = sbp->sb_dblocks * sbp->sb_imax_pct;\r\ndo_div(icount, 100);\r\ndo_div(icount, mp->m_ialloc_blks);\r\nmp->m_maxicount = (icount * mp->m_ialloc_blks) <<\r\nsbp->sb_inopblog;\r\n} else {\r\nmp->m_maxicount = 0;\r\n}\r\n}\r\nSTATIC void\r\nxfs_set_rw_sizes(xfs_mount_t *mp)\r\n{\r\nxfs_sb_t *sbp = &(mp->m_sb);\r\nint readio_log, writeio_log;\r\nif (!(mp->m_flags & XFS_MOUNT_DFLT_IOSIZE)) {\r\nif (mp->m_flags & XFS_MOUNT_WSYNC) {\r\nreadio_log = XFS_WSYNC_READIO_LOG;\r\nwriteio_log = XFS_WSYNC_WRITEIO_LOG;\r\n} else {\r\nreadio_log = XFS_READIO_LOG_LARGE;\r\nwriteio_log = XFS_WRITEIO_LOG_LARGE;\r\n}\r\n} else {\r\nreadio_log = mp->m_readio_log;\r\nwriteio_log = mp->m_writeio_log;\r\n}\r\nif (sbp->sb_blocklog > readio_log) {\r\nmp->m_readio_log = sbp->sb_blocklog;\r\n} else {\r\nmp->m_readio_log = readio_log;\r\n}\r\nmp->m_readio_blocks = 1 << (mp->m_readio_log - sbp->sb_blocklog);\r\nif (sbp->sb_blocklog > writeio_log) {\r\nmp->m_writeio_log = sbp->sb_blocklog;\r\n} else {\r\nmp->m_writeio_log = writeio_log;\r\n}\r\nmp->m_writeio_blocks = 1 << (mp->m_writeio_log - sbp->sb_blocklog);\r\n}\r\nvoid\r\nxfs_set_low_space_thresholds(\r\nstruct xfs_mount *mp)\r\n{\r\nint i;\r\nfor (i = 0; i < XFS_LOWSP_MAX; i++) {\r\n__uint64_t space = mp->m_sb.sb_dblocks;\r\ndo_div(space, 100);\r\nmp->m_low_space[i] = space * (i + 1);\r\n}\r\n}\r\nSTATIC void\r\nxfs_set_inoalignment(xfs_mount_t *mp)\r\n{\r\nif (xfs_sb_version_hasalign(&mp->m_sb) &&\r\nmp->m_sb.sb_inoalignmt >=\r\nXFS_B_TO_FSBT(mp, mp->m_inode_cluster_size))\r\nmp->m_inoalign_mask = mp->m_sb.sb_inoalignmt - 1;\r\nelse\r\nmp->m_inoalign_mask = 0;\r\nif (mp->m_dalign && mp->m_inoalign_mask &&\r\n!(mp->m_dalign & mp->m_inoalign_mask))\r\nmp->m_sinoalign = mp->m_dalign;\r\nelse\r\nmp->m_sinoalign = 0;\r\n}\r\nSTATIC int\r\nxfs_check_sizes(\r\nstruct xfs_mount *mp)\r\n{\r\nstruct xfs_buf *bp;\r\nxfs_daddr_t d;\r\nint error;\r\nd = (xfs_daddr_t)XFS_FSB_TO_BB(mp, mp->m_sb.sb_dblocks);\r\nif (XFS_BB_TO_FSB(mp, d) != mp->m_sb.sb_dblocks) {\r\nxfs_warn(mp, "filesystem size mismatch detected");\r\nreturn -EFBIG;\r\n}\r\nerror = xfs_buf_read_uncached(mp->m_ddev_targp,\r\nd - XFS_FSS_TO_BB(mp, 1),\r\nXFS_FSS_TO_BB(mp, 1), 0, &bp, NULL);\r\nif (error) {\r\nxfs_warn(mp, "last sector read failed");\r\nreturn error;\r\n}\r\nxfs_buf_relse(bp);\r\nif (mp->m_logdev_targp == mp->m_ddev_targp)\r\nreturn 0;\r\nd = (xfs_daddr_t)XFS_FSB_TO_BB(mp, mp->m_sb.sb_logblocks);\r\nif (XFS_BB_TO_FSB(mp, d) != mp->m_sb.sb_logblocks) {\r\nxfs_warn(mp, "log size mismatch detected");\r\nreturn -EFBIG;\r\n}\r\nerror = xfs_buf_read_uncached(mp->m_logdev_targp,\r\nd - XFS_FSB_TO_BB(mp, 1),\r\nXFS_FSB_TO_BB(mp, 1), 0, &bp, NULL);\r\nif (error) {\r\nxfs_warn(mp, "log device read failed");\r\nreturn error;\r\n}\r\nxfs_buf_relse(bp);\r\nreturn 0;\r\n}\r\nint\r\nxfs_mount_reset_sbqflags(\r\nstruct xfs_mount *mp)\r\n{\r\nmp->m_qflags = 0;\r\nif (mp->m_sb.sb_qflags == 0)\r\nreturn 0;\r\nspin_lock(&mp->m_sb_lock);\r\nmp->m_sb.sb_qflags = 0;\r\nspin_unlock(&mp->m_sb_lock);\r\nif (!xfs_fs_writable(mp, SB_FREEZE_WRITE))\r\nreturn 0;\r\nreturn xfs_sync_sb(mp, false);\r\n}\r\n__uint64_t\r\nxfs_default_resblks(xfs_mount_t *mp)\r\n{\r\n__uint64_t resblks;\r\nresblks = mp->m_sb.sb_dblocks;\r\ndo_div(resblks, 20);\r\nresblks = min_t(__uint64_t, resblks, 8192);\r\nreturn resblks;\r\n}\r\nint\r\nxfs_mountfs(\r\nstruct xfs_mount *mp)\r\n{\r\nstruct xfs_sb *sbp = &(mp->m_sb);\r\nstruct xfs_inode *rip;\r\n__uint64_t resblks;\r\nuint quotamount = 0;\r\nuint quotaflags = 0;\r\nint error = 0;\r\nxfs_sb_mount_common(mp, sbp);\r\nif (xfs_sb_has_mismatched_features2(sbp)) {\r\nxfs_warn(mp, "correcting sb_features alignment problem");\r\nsbp->sb_features2 |= sbp->sb_bad_features2;\r\nmp->m_update_sb = true;\r\nif (xfs_sb_version_hasattr2(&mp->m_sb) &&\r\n!(mp->m_flags & XFS_MOUNT_NOATTR2))\r\nmp->m_flags |= XFS_MOUNT_ATTR2;\r\n}\r\nif (xfs_sb_version_hasattr2(&mp->m_sb) &&\r\n(mp->m_flags & XFS_MOUNT_NOATTR2)) {\r\nxfs_sb_version_removeattr2(&mp->m_sb);\r\nmp->m_update_sb = true;\r\nif (!sbp->sb_features2)\r\nmp->m_update_sb = true;\r\n}\r\nif (!(mp->m_sb.sb_versionnum & XFS_SB_VERSION_NLINKBIT)) {\r\nmp->m_sb.sb_versionnum |= XFS_SB_VERSION_NLINKBIT;\r\nmp->m_update_sb = true;\r\n}\r\nerror = xfs_update_alignment(mp);\r\nif (error)\r\ngoto out;\r\nxfs_alloc_compute_maxlevels(mp);\r\nxfs_bmap_compute_maxlevels(mp, XFS_DATA_FORK);\r\nxfs_bmap_compute_maxlevels(mp, XFS_ATTR_FORK);\r\nxfs_ialloc_compute_maxlevels(mp);\r\nxfs_set_maxicount(mp);\r\nerror = xfs_sysfs_init(&mp->m_kobj, &xfs_mp_ktype, NULL, mp->m_fsname);\r\nif (error)\r\ngoto out;\r\nerror = xfs_sysfs_init(&mp->m_stats.xs_kobj, &xfs_stats_ktype,\r\n&mp->m_kobj, "stats");\r\nif (error)\r\ngoto out_remove_sysfs;\r\nerror = xfs_uuid_mount(mp);\r\nif (error)\r\ngoto out_del_stats;\r\nxfs_set_rw_sizes(mp);\r\nxfs_set_low_space_thresholds(mp);\r\nmp->m_inode_cluster_size = XFS_INODE_BIG_CLUSTER_SIZE;\r\nif (xfs_sb_version_hascrc(&mp->m_sb)) {\r\nint new_size = mp->m_inode_cluster_size;\r\nnew_size *= mp->m_sb.sb_inodesize / XFS_DINODE_MIN_SIZE;\r\nif (mp->m_sb.sb_inoalignmt >= XFS_B_TO_FSBT(mp, new_size))\r\nmp->m_inode_cluster_size = new_size;\r\n}\r\nif (xfs_sb_version_hassparseinodes(&mp->m_sb) &&\r\nmp->m_sb.sb_spino_align !=\r\nXFS_B_TO_FSBT(mp, mp->m_inode_cluster_size)) {\r\nxfs_warn(mp,\r\n"Sparse inode block alignment (%u) must match cluster size (%llu).",\r\nmp->m_sb.sb_spino_align,\r\nXFS_B_TO_FSBT(mp, mp->m_inode_cluster_size));\r\nerror = -EINVAL;\r\ngoto out_remove_uuid;\r\n}\r\nxfs_set_inoalignment(mp);\r\nerror = xfs_check_sizes(mp);\r\nif (error)\r\ngoto out_remove_uuid;\r\nerror = xfs_rtmount_init(mp);\r\nif (error) {\r\nxfs_warn(mp, "RT mount failed");\r\ngoto out_remove_uuid;\r\n}\r\nuuid_getnodeuniq(&sbp->sb_uuid, mp->m_fixedfsid);\r\nmp->m_dmevmask = 0;\r\nerror = xfs_da_mount(mp);\r\nif (error) {\r\nxfs_warn(mp, "Failed dir/attr init: %d", error);\r\ngoto out_remove_uuid;\r\n}\r\nxfs_trans_init(mp);\r\nspin_lock_init(&mp->m_perag_lock);\r\nINIT_RADIX_TREE(&mp->m_perag_tree, GFP_ATOMIC);\r\nerror = xfs_initialize_perag(mp, sbp->sb_agcount, &mp->m_maxagi);\r\nif (error) {\r\nxfs_warn(mp, "Failed per-ag init: %d", error);\r\ngoto out_free_dir;\r\n}\r\nif (!sbp->sb_logblocks) {\r\nxfs_warn(mp, "no log defined");\r\nXFS_ERROR_REPORT("xfs_mountfs", XFS_ERRLEVEL_LOW, mp);\r\nerror = -EFSCORRUPTED;\r\ngoto out_free_perag;\r\n}\r\nerror = xfs_log_mount(mp, mp->m_logdev_targp,\r\nXFS_FSB_TO_DADDR(mp, sbp->sb_logstart),\r\nXFS_FSB_TO_BB(mp, sbp->sb_logblocks));\r\nif (error) {\r\nxfs_warn(mp, "log mount failed");\r\ngoto out_fail_wait;\r\n}\r\nif (xfs_sb_version_haslazysbcount(&mp->m_sb) &&\r\n!XFS_LAST_UNMOUNT_WAS_CLEAN(mp) &&\r\n!mp->m_sb.sb_inprogress) {\r\nerror = xfs_initialize_perag_data(mp, sbp->sb_agcount);\r\nif (error)\r\ngoto out_log_dealloc;\r\n}\r\nerror = xfs_iget(mp, NULL, sbp->sb_rootino, 0, XFS_ILOCK_EXCL, &rip);\r\nif (error) {\r\nxfs_warn(mp, "failed to read root inode");\r\ngoto out_log_dealloc;\r\n}\r\nASSERT(rip != NULL);\r\nif (unlikely(!S_ISDIR(rip->i_d.di_mode))) {\r\nxfs_warn(mp, "corrupted root inode %llu: not a directory",\r\n(unsigned long long)rip->i_ino);\r\nxfs_iunlock(rip, XFS_ILOCK_EXCL);\r\nXFS_ERROR_REPORT("xfs_mountfs_int(2)", XFS_ERRLEVEL_LOW,\r\nmp);\r\nerror = -EFSCORRUPTED;\r\ngoto out_rele_rip;\r\n}\r\nmp->m_rootip = rip;\r\nxfs_iunlock(rip, XFS_ILOCK_EXCL);\r\nerror = xfs_rtmount_inodes(mp);\r\nif (error) {\r\nxfs_warn(mp, "failed to read RT inodes");\r\ngoto out_rele_rip;\r\n}\r\nif (mp->m_update_sb && !(mp->m_flags & XFS_MOUNT_RDONLY)) {\r\nerror = xfs_sync_sb(mp, false);\r\nif (error) {\r\nxfs_warn(mp, "failed to write sb changes");\r\ngoto out_rtunmount;\r\n}\r\n}\r\nif (XFS_IS_QUOTA_RUNNING(mp)) {\r\nerror = xfs_qm_newmount(mp, &quotamount, &quotaflags);\r\nif (error)\r\ngoto out_rtunmount;\r\n} else {\r\nASSERT(!XFS_IS_QUOTA_ON(mp));\r\nif (mp->m_sb.sb_qflags & XFS_ALL_QUOTA_ACCT) {\r\nxfs_notice(mp, "resetting quota flags");\r\nerror = xfs_mount_reset_sbqflags(mp);\r\nif (error)\r\ngoto out_rtunmount;\r\n}\r\n}\r\nerror = xfs_log_mount_finish(mp);\r\nif (error) {\r\nxfs_warn(mp, "log mount finish failed");\r\ngoto out_rtunmount;\r\n}\r\nif (quotamount) {\r\nASSERT(mp->m_qflags == 0);\r\nmp->m_qflags = quotaflags;\r\nxfs_qm_mount_quotas(mp);\r\n}\r\nif (!(mp->m_flags & XFS_MOUNT_RDONLY)) {\r\nresblks = xfs_default_resblks(mp);\r\nerror = xfs_reserve_blocks(mp, &resblks, NULL);\r\nif (error)\r\nxfs_warn(mp,\r\n"Unable to allocate reserve blocks. Continuing without reserve pool.");\r\n}\r\nreturn 0;\r\nout_rtunmount:\r\nxfs_rtunmount_inodes(mp);\r\nout_rele_rip:\r\nIRELE(rip);\r\ncancel_delayed_work_sync(&mp->m_reclaim_work);\r\nxfs_reclaim_inodes(mp, SYNC_WAIT);\r\nout_log_dealloc:\r\nxfs_log_mount_cancel(mp);\r\nout_fail_wait:\r\nif (mp->m_logdev_targp && mp->m_logdev_targp != mp->m_ddev_targp)\r\nxfs_wait_buftarg(mp->m_logdev_targp);\r\nxfs_wait_buftarg(mp->m_ddev_targp);\r\nout_free_perag:\r\nxfs_free_perag(mp);\r\nout_free_dir:\r\nxfs_da_unmount(mp);\r\nout_remove_uuid:\r\nxfs_uuid_unmount(mp);\r\nout_del_stats:\r\nxfs_sysfs_del(&mp->m_stats.xs_kobj);\r\nout_remove_sysfs:\r\nxfs_sysfs_del(&mp->m_kobj);\r\nout:\r\nreturn error;\r\n}\r\nvoid\r\nxfs_unmountfs(\r\nstruct xfs_mount *mp)\r\n{\r\n__uint64_t resblks;\r\nint error;\r\ncancel_delayed_work_sync(&mp->m_eofblocks_work);\r\nxfs_qm_unmount_quotas(mp);\r\nxfs_rtunmount_inodes(mp);\r\nIRELE(mp->m_rootip);\r\nxfs_log_force(mp, XFS_LOG_SYNC);\r\nxfs_ail_push_all_sync(mp->m_ail);\r\ncancel_delayed_work_sync(&mp->m_reclaim_work);\r\nxfs_reclaim_inodes(mp, SYNC_WAIT);\r\nxfs_qm_unmount(mp);\r\nresblks = 0;\r\nerror = xfs_reserve_blocks(mp, &resblks, NULL);\r\nif (error)\r\nxfs_warn(mp, "Unable to free reserved block pool. "\r\n"Freespace may not be correct on next mount.");\r\nerror = xfs_log_sbcount(mp);\r\nif (error)\r\nxfs_warn(mp, "Unable to update superblock counters. "\r\n"Freespace may not be correct on next mount.");\r\nxfs_log_unmount(mp);\r\nxfs_da_unmount(mp);\r\nxfs_uuid_unmount(mp);\r\n#if defined(DEBUG)\r\nxfs_errortag_clearall(mp, 0);\r\n#endif\r\nxfs_free_perag(mp);\r\nxfs_sysfs_del(&mp->m_stats.xs_kobj);\r\nxfs_sysfs_del(&mp->m_kobj);\r\n}\r\nbool\r\nxfs_fs_writable(\r\nstruct xfs_mount *mp,\r\nint level)\r\n{\r\nASSERT(level > SB_UNFROZEN);\r\nif ((mp->m_super->s_writers.frozen >= level) ||\r\nXFS_FORCED_SHUTDOWN(mp) || (mp->m_flags & XFS_MOUNT_RDONLY))\r\nreturn false;\r\nreturn true;\r\n}\r\nint\r\nxfs_log_sbcount(xfs_mount_t *mp)\r\n{\r\nif (!xfs_fs_writable(mp, SB_FREEZE_COMPLETE))\r\nreturn 0;\r\nif (!xfs_sb_version_haslazysbcount(&mp->m_sb))\r\nreturn 0;\r\nreturn xfs_sync_sb(mp, true);\r\n}\r\nint\r\nxfs_mod_icount(\r\nstruct xfs_mount *mp,\r\nint64_t delta)\r\n{\r\n__percpu_counter_add(&mp->m_icount, delta, XFS_ICOUNT_BATCH);\r\nif (__percpu_counter_compare(&mp->m_icount, 0, XFS_ICOUNT_BATCH) < 0) {\r\nASSERT(0);\r\npercpu_counter_add(&mp->m_icount, -delta);\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nint\r\nxfs_mod_ifree(\r\nstruct xfs_mount *mp,\r\nint64_t delta)\r\n{\r\npercpu_counter_add(&mp->m_ifree, delta);\r\nif (percpu_counter_compare(&mp->m_ifree, 0) < 0) {\r\nASSERT(0);\r\npercpu_counter_add(&mp->m_ifree, -delta);\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nint\r\nxfs_mod_fdblocks(\r\nstruct xfs_mount *mp,\r\nint64_t delta,\r\nbool rsvd)\r\n{\r\nint64_t lcounter;\r\nlong long res_used;\r\ns32 batch;\r\nif (delta > 0) {\r\nif (likely(mp->m_resblks == mp->m_resblks_avail)) {\r\npercpu_counter_add(&mp->m_fdblocks, delta);\r\nreturn 0;\r\n}\r\nspin_lock(&mp->m_sb_lock);\r\nres_used = (long long)(mp->m_resblks - mp->m_resblks_avail);\r\nif (res_used > delta) {\r\nmp->m_resblks_avail += delta;\r\n} else {\r\ndelta -= res_used;\r\nmp->m_resblks_avail = mp->m_resblks;\r\npercpu_counter_add(&mp->m_fdblocks, delta);\r\n}\r\nspin_unlock(&mp->m_sb_lock);\r\nreturn 0;\r\n}\r\nif (__percpu_counter_compare(&mp->m_fdblocks, 2 * XFS_FDBLOCKS_BATCH,\r\nXFS_FDBLOCKS_BATCH) < 0)\r\nbatch = 1;\r\nelse\r\nbatch = XFS_FDBLOCKS_BATCH;\r\n__percpu_counter_add(&mp->m_fdblocks, delta, batch);\r\nif (__percpu_counter_compare(&mp->m_fdblocks, XFS_ALLOC_SET_ASIDE(mp),\r\nXFS_FDBLOCKS_BATCH) >= 0) {\r\nreturn 0;\r\n}\r\nspin_lock(&mp->m_sb_lock);\r\npercpu_counter_add(&mp->m_fdblocks, -delta);\r\nif (!rsvd)\r\ngoto fdblocks_enospc;\r\nlcounter = (long long)mp->m_resblks_avail + delta;\r\nif (lcounter >= 0) {\r\nmp->m_resblks_avail = lcounter;\r\nspin_unlock(&mp->m_sb_lock);\r\nreturn 0;\r\n}\r\nprintk_once(KERN_WARNING\r\n"Filesystem \"%s\": reserve blocks depleted! "\r\n"Consider increasing reserve pool size.",\r\nmp->m_fsname);\r\nfdblocks_enospc:\r\nspin_unlock(&mp->m_sb_lock);\r\nreturn -ENOSPC;\r\n}\r\nint\r\nxfs_mod_frextents(\r\nstruct xfs_mount *mp,\r\nint64_t delta)\r\n{\r\nint64_t lcounter;\r\nint ret = 0;\r\nspin_lock(&mp->m_sb_lock);\r\nlcounter = mp->m_sb.sb_frextents + delta;\r\nif (lcounter < 0)\r\nret = -ENOSPC;\r\nelse\r\nmp->m_sb.sb_frextents = lcounter;\r\nspin_unlock(&mp->m_sb_lock);\r\nreturn ret;\r\n}\r\nstruct xfs_buf *\r\nxfs_getsb(\r\nstruct xfs_mount *mp,\r\nint flags)\r\n{\r\nstruct xfs_buf *bp = mp->m_sb_bp;\r\nif (!xfs_buf_trylock(bp)) {\r\nif (flags & XBF_TRYLOCK)\r\nreturn NULL;\r\nxfs_buf_lock(bp);\r\n}\r\nxfs_buf_hold(bp);\r\nASSERT(XFS_BUF_ISDONE(bp));\r\nreturn bp;\r\n}\r\nvoid\r\nxfs_freesb(\r\nstruct xfs_mount *mp)\r\n{\r\nstruct xfs_buf *bp = mp->m_sb_bp;\r\nxfs_buf_lock(bp);\r\nmp->m_sb_bp = NULL;\r\nxfs_buf_relse(bp);\r\n}\r\nint\r\nxfs_dev_is_read_only(\r\nstruct xfs_mount *mp,\r\nchar *message)\r\n{\r\nif (xfs_readonly_buftarg(mp->m_ddev_targp) ||\r\nxfs_readonly_buftarg(mp->m_logdev_targp) ||\r\n(mp->m_rtdev_targp && xfs_readonly_buftarg(mp->m_rtdev_targp))) {\r\nxfs_notice(mp, "%s required on read-only device.", message);\r\nxfs_notice(mp, "write access unavailable, cannot proceed.");\r\nreturn -EROFS;\r\n}\r\nreturn 0;\r\n}
