static int pl172_timing_prop(struct amba_device *adev,\r\nconst struct device_node *np, const char *name,\r\nu32 reg_offset, u32 max, int start)\r\n{\r\nstruct pl172_data *pl172 = amba_get_drvdata(adev);\r\nint cycles;\r\nu32 val;\r\nif (!of_property_read_u32(np, name, &val)) {\r\ncycles = DIV_ROUND_UP(val * pl172->rate, NSEC_PER_MSEC) - start;\r\nif (cycles < 0) {\r\ncycles = 0;\r\n} else if (cycles > max) {\r\ndev_err(&adev->dev, "%s timing too tight\n", name);\r\nreturn -EINVAL;\r\n}\r\nwritel(cycles, pl172->base + reg_offset);\r\n}\r\ndev_dbg(&adev->dev, "%s: %u cycle(s)\n", name, start +\r\nreadl(pl172->base + reg_offset));\r\nreturn 0;\r\n}\r\nstatic int pl172_setup_static(struct amba_device *adev,\r\nstruct device_node *np, u32 cs)\r\n{\r\nstruct pl172_data *pl172 = amba_get_drvdata(adev);\r\nu32 cfg;\r\nint ret;\r\nif (!of_property_read_u32(np, "mpmc,memory-width", &cfg)) {\r\nif (cfg == 8) {\r\ncfg = MPMC_STATIC_CFG_MW_8BIT;\r\n} else if (cfg == 16) {\r\ncfg = MPMC_STATIC_CFG_MW_16BIT;\r\n} else if (cfg == 32) {\r\ncfg = MPMC_STATIC_CFG_MW_32BIT;\r\n} else {\r\ndev_err(&adev->dev, "invalid memory width cs%u\n", cs);\r\nreturn -EINVAL;\r\n}\r\n} else {\r\ndev_err(&adev->dev, "memory-width property required\n");\r\nreturn -EINVAL;\r\n}\r\nif (of_property_read_bool(np, "mpmc,async-page-mode"))\r\ncfg |= MPMC_STATIC_CFG_PM;\r\nif (of_property_read_bool(np, "mpmc,cs-active-high"))\r\ncfg |= MPMC_STATIC_CFG_PC;\r\nif (of_property_read_bool(np, "mpmc,byte-lane-low"))\r\ncfg |= MPMC_STATIC_CFG_PB;\r\nif (of_property_read_bool(np, "mpmc,extended-wait"))\r\ncfg |= MPMC_STATIC_CFG_EW;\r\nif (amba_part(adev) == 0x172 &&\r\nof_property_read_bool(np, "mpmc,buffer-enable"))\r\ncfg |= MPMC_STATIC_CFG_B;\r\nif (of_property_read_bool(np, "mpmc,write-protect"))\r\ncfg |= MPMC_STATIC_CFG_P;\r\nwritel(cfg, pl172->base + MPMC_STATIC_CFG(cs));\r\ndev_dbg(&adev->dev, "mpmc static config cs%u: 0x%08x\n", cs, cfg);\r\nret = pl172_timing_prop(adev, np, "mpmc,write-enable-delay",\r\nMPMC_STATIC_WAIT_WEN(cs),\r\nMPMC_STATIC_WAIT_WEN_MAX, 1);\r\nif (ret)\r\ngoto fail;\r\nret = pl172_timing_prop(adev, np, "mpmc,output-enable-delay",\r\nMPMC_STATIC_WAIT_OEN(cs),\r\nMPMC_STATIC_WAIT_OEN_MAX, 0);\r\nif (ret)\r\ngoto fail;\r\nret = pl172_timing_prop(adev, np, "mpmc,read-access-delay",\r\nMPMC_STATIC_WAIT_RD(cs),\r\nMPMC_STATIC_WAIT_RD_MAX, 1);\r\nif (ret)\r\ngoto fail;\r\nret = pl172_timing_prop(adev, np, "mpmc,page-mode-read-delay",\r\nMPMC_STATIC_WAIT_PAGE(cs),\r\nMPMC_STATIC_WAIT_PAGE_MAX, 1);\r\nif (ret)\r\ngoto fail;\r\nret = pl172_timing_prop(adev, np, "mpmc,write-access-delay",\r\nMPMC_STATIC_WAIT_WR(cs),\r\nMPMC_STATIC_WAIT_WR_MAX, 2);\r\nif (ret)\r\ngoto fail;\r\nret = pl172_timing_prop(adev, np, "mpmc,turn-round-delay",\r\nMPMC_STATIC_WAIT_TURN(cs),\r\nMPMC_STATIC_WAIT_TURN_MAX, 1);\r\nif (ret)\r\ngoto fail;\r\nreturn 0;\r\nfail:\r\ndev_err(&adev->dev, "failed to configure cs%u\n", cs);\r\nreturn ret;\r\n}\r\nstatic int pl172_parse_cs_config(struct amba_device *adev,\r\nstruct device_node *np)\r\n{\r\nu32 cs;\r\nif (!of_property_read_u32(np, "mpmc,cs", &cs)) {\r\nif (cs >= PL172_MAX_CS) {\r\ndev_err(&adev->dev, "cs%u invalid\n", cs);\r\nreturn -EINVAL;\r\n}\r\nreturn pl172_setup_static(adev, np, cs);\r\n}\r\ndev_err(&adev->dev, "cs property required\n");\r\nreturn -EINVAL;\r\n}\r\nstatic int pl172_probe(struct amba_device *adev, const struct amba_id *id)\r\n{\r\nstruct device_node *child_np, *np = adev->dev.of_node;\r\nstruct device *dev = &adev->dev;\r\nstatic const char *rev = "?";\r\nstruct pl172_data *pl172;\r\nint ret;\r\nif (amba_part(adev) == 0x172) {\r\nif (amba_rev(adev) < ARRAY_SIZE(pl172_revisions))\r\nrev = pl172_revisions[amba_rev(adev)];\r\n} else if (amba_part(adev) == 0x175) {\r\nif (amba_rev(adev) < ARRAY_SIZE(pl175_revisions))\r\nrev = pl175_revisions[amba_rev(adev)];\r\n} else if (amba_part(adev) == 0x176) {\r\nif (amba_rev(adev) < ARRAY_SIZE(pl176_revisions))\r\nrev = pl176_revisions[amba_rev(adev)];\r\n}\r\ndev_info(dev, "ARM PL%x revision %s\n", amba_part(adev), rev);\r\npl172 = devm_kzalloc(dev, sizeof(*pl172), GFP_KERNEL);\r\nif (!pl172)\r\nreturn -ENOMEM;\r\npl172->clk = devm_clk_get(dev, "mpmcclk");\r\nif (IS_ERR(pl172->clk)) {\r\ndev_err(dev, "no mpmcclk provided clock\n");\r\nreturn PTR_ERR(pl172->clk);\r\n}\r\nret = clk_prepare_enable(pl172->clk);\r\nif (ret) {\r\ndev_err(dev, "unable to mpmcclk enable clock\n");\r\nreturn ret;\r\n}\r\npl172->rate = clk_get_rate(pl172->clk) / MSEC_PER_SEC;\r\nif (!pl172->rate) {\r\ndev_err(dev, "unable to get mpmcclk clock rate\n");\r\nret = -EINVAL;\r\ngoto err_clk_enable;\r\n}\r\nret = amba_request_regions(adev, NULL);\r\nif (ret) {\r\ndev_err(dev, "unable to request AMBA regions\n");\r\ngoto err_clk_enable;\r\n}\r\npl172->base = devm_ioremap(dev, adev->res.start,\r\nresource_size(&adev->res));\r\nif (!pl172->base) {\r\ndev_err(dev, "ioremap failed\n");\r\nret = -ENOMEM;\r\ngoto err_no_ioremap;\r\n}\r\namba_set_drvdata(adev, pl172);\r\nfor_each_available_child_of_node(np, child_np) {\r\nret = pl172_parse_cs_config(adev, child_np);\r\nif (ret)\r\ncontinue;\r\nof_platform_populate(child_np, NULL, NULL, dev);\r\n}\r\nreturn 0;\r\nerr_no_ioremap:\r\namba_release_regions(adev);\r\nerr_clk_enable:\r\nclk_disable_unprepare(pl172->clk);\r\nreturn ret;\r\n}\r\nstatic int pl172_remove(struct amba_device *adev)\r\n{\r\nstruct pl172_data *pl172 = amba_get_drvdata(adev);\r\nclk_disable_unprepare(pl172->clk);\r\namba_release_regions(adev);\r\nreturn 0;\r\n}
