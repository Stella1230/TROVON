static int pb0100_s_ctrl(struct v4l2_ctrl *ctrl)\r\n{\r\nstruct gspca_dev *gspca_dev =\r\ncontainer_of(ctrl->handler, struct gspca_dev, ctrl_handler);\r\nstruct sd *sd = (struct sd *)gspca_dev;\r\nstruct pb0100_ctrls *ctrls = sd->sensor_priv;\r\nint err = -EINVAL;\r\nswitch (ctrl->id) {\r\ncase V4L2_CID_AUTOGAIN:\r\nerr = pb0100_set_autogain(gspca_dev, ctrl->val);\r\nif (err)\r\nbreak;\r\nif (ctrl->val)\r\nbreak;\r\nerr = pb0100_set_gain(gspca_dev, ctrls->gain->val);\r\nif (err)\r\nbreak;\r\nerr = pb0100_set_exposure(gspca_dev, ctrls->exposure->val);\r\nbreak;\r\ncase V4L2_CTRL_CLASS_USER + 0x1001:\r\nerr = pb0100_set_autogain_target(gspca_dev, ctrl->val);\r\nbreak;\r\n}\r\nreturn err;\r\n}\r\nstatic int pb0100_init_controls(struct sd *sd)\r\n{\r\nstruct v4l2_ctrl_handler *hdl = &sd->gspca_dev.ctrl_handler;\r\nstruct pb0100_ctrls *ctrls;\r\nstatic const struct v4l2_ctrl_config autogain_target = {\r\n.ops = &pb0100_ctrl_ops,\r\n.id = V4L2_CTRL_CLASS_USER + 0x1000,\r\n.type = V4L2_CTRL_TYPE_INTEGER,\r\n.name = "Automatic Gain Target",\r\n.max = 255,\r\n.step = 1,\r\n.def = 128,\r\n};\r\nstatic const struct v4l2_ctrl_config natural_light = {\r\n.ops = &pb0100_ctrl_ops,\r\n.id = V4L2_CTRL_CLASS_USER + 0x1001,\r\n.type = V4L2_CTRL_TYPE_BOOLEAN,\r\n.name = "Natural Light Source",\r\n.max = 1,\r\n.step = 1,\r\n.def = 1,\r\n};\r\nctrls = kzalloc(sizeof(*ctrls), GFP_KERNEL);\r\nif (!ctrls)\r\nreturn -ENOMEM;\r\nv4l2_ctrl_handler_init(hdl, 6);\r\nctrls->autogain = v4l2_ctrl_new_std(hdl, &pb0100_ctrl_ops,\r\nV4L2_CID_AUTOGAIN, 0, 1, 1, 1);\r\nctrls->exposure = v4l2_ctrl_new_std(hdl, &pb0100_ctrl_ops,\r\nV4L2_CID_EXPOSURE, 0, 511, 1, 12);\r\nctrls->gain = v4l2_ctrl_new_std(hdl, &pb0100_ctrl_ops,\r\nV4L2_CID_GAIN, 0, 255, 1, 128);\r\nctrls->red = v4l2_ctrl_new_std(hdl, &pb0100_ctrl_ops,\r\nV4L2_CID_RED_BALANCE, -255, 255, 1, 0);\r\nctrls->blue = v4l2_ctrl_new_std(hdl, &pb0100_ctrl_ops,\r\nV4L2_CID_BLUE_BALANCE, -255, 255, 1, 0);\r\nctrls->natural = v4l2_ctrl_new_custom(hdl, &natural_light, NULL);\r\nctrls->target = v4l2_ctrl_new_custom(hdl, &autogain_target, NULL);\r\nif (hdl->error) {\r\nkfree(ctrls);\r\nreturn hdl->error;\r\n}\r\nsd->sensor_priv = ctrls;\r\nv4l2_ctrl_auto_cluster(5, &ctrls->autogain, 0, false);\r\nreturn 0;\r\n}\r\nstatic int pb0100_probe(struct sd *sd)\r\n{\r\nu16 sensor;\r\nint err;\r\nerr = stv06xx_read_sensor(sd, PB_IDENT, &sensor);\r\nif (err < 0)\r\nreturn -ENODEV;\r\nif ((sensor >> 8) != 0x64)\r\nreturn -ENODEV;\r\npr_info("Photobit pb0100 sensor detected\n");\r\nsd->gspca_dev.cam.cam_mode = pb0100_mode;\r\nsd->gspca_dev.cam.nmodes = ARRAY_SIZE(pb0100_mode);\r\nreturn 0;\r\n}\r\nstatic int pb0100_start(struct sd *sd)\r\n{\r\nint err, packet_size, max_packet_size;\r\nstruct usb_host_interface *alt;\r\nstruct usb_interface *intf;\r\nstruct gspca_dev *gspca_dev = (struct gspca_dev *)sd;\r\nstruct cam *cam = &sd->gspca_dev.cam;\r\nu32 mode = cam->cam_mode[sd->gspca_dev.curr_mode].priv;\r\nintf = usb_ifnum_to_if(sd->gspca_dev.dev, sd->gspca_dev.iface);\r\nalt = usb_altnum_to_altsetting(intf, sd->gspca_dev.alt);\r\nif (!alt)\r\nreturn -ENODEV;\r\npacket_size = le16_to_cpu(alt->endpoint[0].desc.wMaxPacketSize);\r\nmax_packet_size = sd->sensor->max_packet_size[sd->gspca_dev.curr_mode];\r\nif (packet_size < max_packet_size)\r\nstv06xx_write_sensor(sd, PB_ROWSPEED, BIT(4)|BIT(3)|BIT(1));\r\nelse\r\nstv06xx_write_sensor(sd, PB_ROWSPEED, BIT(5)|BIT(3)|BIT(1));\r\nif (mode & PB0100_CROP_TO_VGA) {\r\nstv06xx_write_sensor(sd, PB_RSTART, 30);\r\nstv06xx_write_sensor(sd, PB_CSTART, 20);\r\nstv06xx_write_sensor(sd, PB_RWSIZE, 240 - 1);\r\nstv06xx_write_sensor(sd, PB_CWSIZE, 320 - 1);\r\n} else {\r\nstv06xx_write_sensor(sd, PB_RSTART, 8);\r\nstv06xx_write_sensor(sd, PB_CSTART, 4);\r\nstv06xx_write_sensor(sd, PB_RWSIZE, 288 - 1);\r\nstv06xx_write_sensor(sd, PB_CWSIZE, 352 - 1);\r\n}\r\nif (mode & PB0100_SUBSAMPLE) {\r\nstv06xx_write_bridge(sd, STV_Y_CTRL, 0x02);\r\nstv06xx_write_bridge(sd, STV_X_CTRL, 0x06);\r\nstv06xx_write_bridge(sd, STV_SCAN_RATE, 0x10);\r\n} else {\r\nstv06xx_write_bridge(sd, STV_Y_CTRL, 0x01);\r\nstv06xx_write_bridge(sd, STV_X_CTRL, 0x0a);\r\nstv06xx_write_bridge(sd, STV_SCAN_RATE, 0x20);\r\n}\r\nerr = stv06xx_write_sensor(sd, PB_CONTROL, BIT(5)|BIT(3)|BIT(1));\r\nPDEBUG(D_STREAM, "Started stream, status: %d", err);\r\nreturn (err < 0) ? err : 0;\r\n}\r\nstatic int pb0100_stop(struct sd *sd)\r\n{\r\nstruct gspca_dev *gspca_dev = (struct gspca_dev *)sd;\r\nint err;\r\nerr = stv06xx_write_sensor(sd, PB_ABORTFRAME, 1);\r\nif (err < 0)\r\ngoto out;\r\nerr = stv06xx_write_sensor(sd, PB_CONTROL, BIT(5)|BIT(3));\r\nPDEBUG(D_STREAM, "Halting stream");\r\nout:\r\nreturn (err < 0) ? err : 0;\r\n}\r\nstatic int pb0100_init(struct sd *sd)\r\n{\r\nstv06xx_write_bridge(sd, STV_REG00, 1);\r\nstv06xx_write_bridge(sd, STV_SCAN_RATE, 0);\r\nstv06xx_write_sensor(sd, PB_RESET, 1);\r\nstv06xx_write_sensor(sd, PB_RESET, 0);\r\nstv06xx_write_sensor(sd, PB_CONTROL, BIT(5)|BIT(3));\r\nstv06xx_write_sensor(sd, PB_PREADCTRL, BIT(12)|BIT(10)|BIT(6));\r\nstv06xx_write_sensor(sd, PB_ADCGLOBALGAIN, 12);\r\nstv06xx_write_sensor(sd, PB_R28, 12);\r\nstv06xx_write_sensor(sd, PB_ADCMAXGAIN, 180);\r\nstv06xx_write_sensor(sd, PB_ADCMINGAIN, 12);\r\nstv06xx_write_sensor(sd, PB_R54, 3);\r\nstv06xx_write_sensor(sd, PB_R55, 0);\r\nstv06xx_write_sensor(sd, PB_UPDATEINT, 1);\r\nstv06xx_write_sensor(sd, PB_R15, 800);\r\nstv06xx_write_sensor(sd, PB_R17, 10);\r\nstv06xx_write_sensor(sd, PB_EXPGAIN, 0);\r\nstv06xx_write_sensor(sd, PB_VOFFSET, 0);\r\nstv06xx_write_sensor(sd, PB_ADCGAINH, 11);\r\nstv06xx_write_sensor(sd, PB_ADCGAINL, 0);\r\nstv06xx_write_bridge(sd, STV_REG00, 0x11);\r\nstv06xx_write_bridge(sd, STV_REG03, 0x45);\r\nstv06xx_write_bridge(sd, STV_REG04, 0x07);\r\nstv06xx_write_sensor(sd, PB_ROWSPEED, BIT(4)|BIT(3)|BIT(1));\r\nstv06xx_write_sensor(sd, PB_CFILLIN, 14);\r\nstv06xx_write_sensor(sd, PB_VBL, 0);\r\nstv06xx_write_sensor(sd, PB_FINTTIME, 0);\r\nstv06xx_write_sensor(sd, PB_RINTTIME, 123);\r\nstv06xx_write_bridge(sd, STV_REG01, 0xc2);\r\nstv06xx_write_bridge(sd, STV_REG02, 0xb0);\r\nreturn 0;\r\n}\r\nstatic int pb0100_dump(struct sd *sd)\r\n{\r\nreturn 0;\r\n}\r\nstatic int pb0100_set_gain(struct gspca_dev *gspca_dev, __s32 val)\r\n{\r\nint err;\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\nstruct pb0100_ctrls *ctrls = sd->sensor_priv;\r\nerr = stv06xx_write_sensor(sd, PB_G1GAIN, val);\r\nif (!err)\r\nerr = stv06xx_write_sensor(sd, PB_G2GAIN, val);\r\nPDEBUG(D_CONF, "Set green gain to %d, status: %d", val, err);\r\nif (!err)\r\nerr = pb0100_set_red_balance(gspca_dev, ctrls->red->val);\r\nif (!err)\r\nerr = pb0100_set_blue_balance(gspca_dev, ctrls->blue->val);\r\nreturn err;\r\n}\r\nstatic int pb0100_set_red_balance(struct gspca_dev *gspca_dev, __s32 val)\r\n{\r\nint err;\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\nstruct pb0100_ctrls *ctrls = sd->sensor_priv;\r\nval += ctrls->gain->val;\r\nif (val < 0)\r\nval = 0;\r\nelse if (val > 255)\r\nval = 255;\r\nerr = stv06xx_write_sensor(sd, PB_RGAIN, val);\r\nPDEBUG(D_CONF, "Set red gain to %d, status: %d", val, err);\r\nreturn err;\r\n}\r\nstatic int pb0100_set_blue_balance(struct gspca_dev *gspca_dev, __s32 val)\r\n{\r\nint err;\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\nstruct pb0100_ctrls *ctrls = sd->sensor_priv;\r\nval += ctrls->gain->val;\r\nif (val < 0)\r\nval = 0;\r\nelse if (val > 255)\r\nval = 255;\r\nerr = stv06xx_write_sensor(sd, PB_BGAIN, val);\r\nPDEBUG(D_CONF, "Set blue gain to %d, status: %d", val, err);\r\nreturn err;\r\n}\r\nstatic int pb0100_set_exposure(struct gspca_dev *gspca_dev, __s32 val)\r\n{\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\nint err;\r\nerr = stv06xx_write_sensor(sd, PB_RINTTIME, val);\r\nPDEBUG(D_CONF, "Set exposure to %d, status: %d", val, err);\r\nreturn err;\r\n}\r\nstatic int pb0100_set_autogain(struct gspca_dev *gspca_dev, __s32 val)\r\n{\r\nint err;\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\nstruct pb0100_ctrls *ctrls = sd->sensor_priv;\r\nif (val) {\r\nif (ctrls->natural->val)\r\nval = BIT(6)|BIT(4)|BIT(0);\r\nelse\r\nval = BIT(4)|BIT(0);\r\n} else\r\nval = 0;\r\nerr = stv06xx_write_sensor(sd, PB_EXPGAIN, val);\r\nPDEBUG(D_CONF, "Set autogain to %d (natural: %d), status: %d",\r\nval, ctrls->natural->val, err);\r\nreturn err;\r\n}\r\nstatic int pb0100_set_autogain_target(struct gspca_dev *gspca_dev, __s32 val)\r\n{\r\nint err, totalpixels, brightpixels, darkpixels;\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\ntotalpixels = gspca_dev->pixfmt.width * gspca_dev->pixfmt.height;\r\ntotalpixels = totalpixels/(8*8) + totalpixels/(64*64);\r\nbrightpixels = (totalpixels * val) >> 8;\r\ndarkpixels = totalpixels - brightpixels;\r\nerr = stv06xx_write_sensor(sd, PB_R21, brightpixels);\r\nif (!err)\r\nerr = stv06xx_write_sensor(sd, PB_R22, darkpixels);\r\nPDEBUG(D_CONF, "Set autogain target to %d, status: %d", val, err);\r\nreturn err;\r\n}
