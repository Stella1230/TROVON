static int\r\nextract_icmp4_fields(const struct sk_buff *skb,\r\nu8 *protocol,\r\n__be32 *raddr,\r\n__be32 *laddr,\r\n__be16 *rport,\r\n__be16 *lport)\r\n{\r\nunsigned int outside_hdrlen = ip_hdrlen(skb);\r\nstruct iphdr *inside_iph, _inside_iph;\r\nstruct icmphdr *icmph, _icmph;\r\n__be16 *ports, _ports[2];\r\nicmph = skb_header_pointer(skb, outside_hdrlen,\r\nsizeof(_icmph), &_icmph);\r\nif (icmph == NULL)\r\nreturn 1;\r\nswitch (icmph->type) {\r\ncase ICMP_DEST_UNREACH:\r\ncase ICMP_SOURCE_QUENCH:\r\ncase ICMP_REDIRECT:\r\ncase ICMP_TIME_EXCEEDED:\r\ncase ICMP_PARAMETERPROB:\r\nbreak;\r\ndefault:\r\nreturn 1;\r\n}\r\ninside_iph = skb_header_pointer(skb, outside_hdrlen +\r\nsizeof(struct icmphdr),\r\nsizeof(_inside_iph), &_inside_iph);\r\nif (inside_iph == NULL)\r\nreturn 1;\r\nif (inside_iph->protocol != IPPROTO_TCP &&\r\ninside_iph->protocol != IPPROTO_UDP)\r\nreturn 1;\r\nports = skb_header_pointer(skb, outside_hdrlen +\r\nsizeof(struct icmphdr) +\r\n(inside_iph->ihl << 2),\r\nsizeof(_ports), &_ports);\r\nif (ports == NULL)\r\nreturn 1;\r\n*protocol = inside_iph->protocol;\r\n*laddr = inside_iph->saddr;\r\n*lport = ports[0];\r\n*raddr = inside_iph->daddr;\r\n*rport = ports[1];\r\nreturn 0;\r\n}\r\nstatic struct sock *\r\nxt_socket_get_sock_v4(struct net *net, const u8 protocol,\r\nconst __be32 saddr, const __be32 daddr,\r\nconst __be16 sport, const __be16 dport,\r\nconst struct net_device *in)\r\n{\r\nswitch (protocol) {\r\ncase IPPROTO_TCP:\r\nreturn __inet_lookup(net, &tcp_hashinfo,\r\nsaddr, sport, daddr, dport,\r\nin->ifindex);\r\ncase IPPROTO_UDP:\r\nreturn udp4_lib_lookup(net, saddr, sport, daddr, dport,\r\nin->ifindex);\r\n}\r\nreturn NULL;\r\n}\r\nstatic bool xt_socket_sk_is_transparent(struct sock *sk)\r\n{\r\nswitch (sk->sk_state) {\r\ncase TCP_TIME_WAIT:\r\nreturn inet_twsk(sk)->tw_transparent;\r\ncase TCP_NEW_SYN_RECV:\r\nreturn inet_rsk(inet_reqsk(sk))->no_srccheck;\r\ndefault:\r\nreturn inet_sk(sk)->transparent;\r\n}\r\n}\r\nstatic struct sock *xt_socket_lookup_slow_v4(struct net *net,\r\nconst struct sk_buff *skb,\r\nconst struct net_device *indev)\r\n{\r\nconst struct iphdr *iph = ip_hdr(skb);\r\n__be32 uninitialized_var(daddr), uninitialized_var(saddr);\r\n__be16 uninitialized_var(dport), uninitialized_var(sport);\r\nu8 uninitialized_var(protocol);\r\n#ifdef XT_SOCKET_HAVE_CONNTRACK\r\nstruct nf_conn const *ct;\r\nenum ip_conntrack_info ctinfo;\r\n#endif\r\nif (iph->protocol == IPPROTO_UDP || iph->protocol == IPPROTO_TCP) {\r\nstruct udphdr _hdr, *hp;\r\nhp = skb_header_pointer(skb, ip_hdrlen(skb),\r\nsizeof(_hdr), &_hdr);\r\nif (hp == NULL)\r\nreturn NULL;\r\nprotocol = iph->protocol;\r\nsaddr = iph->saddr;\r\nsport = hp->source;\r\ndaddr = iph->daddr;\r\ndport = hp->dest;\r\n} else if (iph->protocol == IPPROTO_ICMP) {\r\nif (extract_icmp4_fields(skb, &protocol, &saddr, &daddr,\r\n&sport, &dport))\r\nreturn NULL;\r\n} else {\r\nreturn NULL;\r\n}\r\n#ifdef XT_SOCKET_HAVE_CONNTRACK\r\nct = nf_ct_get(skb, &ctinfo);\r\nif (ct && !nf_ct_is_untracked(ct) &&\r\n((iph->protocol != IPPROTO_ICMP &&\r\nctinfo == IP_CT_ESTABLISHED_REPLY) ||\r\n(iph->protocol == IPPROTO_ICMP &&\r\nctinfo == IP_CT_RELATED_REPLY)) &&\r\n(ct->status & IPS_SRC_NAT_DONE)) {\r\ndaddr = ct->tuplehash[IP_CT_DIR_ORIGINAL].tuple.src.u3.ip;\r\ndport = (iph->protocol == IPPROTO_TCP) ?\r\nct->tuplehash[IP_CT_DIR_ORIGINAL].tuple.src.u.tcp.port :\r\nct->tuplehash[IP_CT_DIR_ORIGINAL].tuple.src.u.udp.port;\r\n}\r\n#endif\r\nreturn xt_socket_get_sock_v4(net, protocol, saddr, daddr,\r\nsport, dport, indev);\r\n}\r\nstatic bool\r\nsocket_match(const struct sk_buff *skb, struct xt_action_param *par,\r\nconst struct xt_socket_mtinfo1 *info)\r\n{\r\nstruct sk_buff *pskb = (struct sk_buff *)skb;\r\nstruct sock *sk = skb->sk;\r\nif (!sk)\r\nsk = xt_socket_lookup_slow_v4(par->net, skb, par->in);\r\nif (sk) {\r\nbool wildcard;\r\nbool transparent = true;\r\nwildcard = (!(info->flags & XT_SOCKET_NOWILDCARD) &&\r\nsk_fullsock(sk) &&\r\ninet_sk(sk)->inet_rcv_saddr == 0);\r\nif (info->flags & XT_SOCKET_TRANSPARENT)\r\ntransparent = xt_socket_sk_is_transparent(sk);\r\nif (info->flags & XT_SOCKET_RESTORESKMARK && !wildcard &&\r\ntransparent)\r\npskb->mark = sk->sk_mark;\r\nif (sk != skb->sk)\r\nsock_gen_put(sk);\r\nif (wildcard || !transparent)\r\nsk = NULL;\r\n}\r\nreturn sk != NULL;\r\n}\r\nstatic bool\r\nsocket_mt4_v0(const struct sk_buff *skb, struct xt_action_param *par)\r\n{\r\nstatic struct xt_socket_mtinfo1 xt_info_v0 = {\r\n.flags = 0,\r\n};\r\nreturn socket_match(skb, par, &xt_info_v0);\r\n}\r\nstatic bool\r\nsocket_mt4_v1_v2_v3(const struct sk_buff *skb, struct xt_action_param *par)\r\n{\r\nreturn socket_match(skb, par, par->matchinfo);\r\n}\r\nstatic int\r\nextract_icmp6_fields(const struct sk_buff *skb,\r\nunsigned int outside_hdrlen,\r\nint *protocol,\r\nconst struct in6_addr **raddr,\r\nconst struct in6_addr **laddr,\r\n__be16 *rport,\r\n__be16 *lport,\r\nstruct ipv6hdr *ipv6_var)\r\n{\r\nconst struct ipv6hdr *inside_iph;\r\nstruct icmp6hdr *icmph, _icmph;\r\n__be16 *ports, _ports[2];\r\nu8 inside_nexthdr;\r\n__be16 inside_fragoff;\r\nint inside_hdrlen;\r\nicmph = skb_header_pointer(skb, outside_hdrlen,\r\nsizeof(_icmph), &_icmph);\r\nif (icmph == NULL)\r\nreturn 1;\r\nif (icmph->icmp6_type & ICMPV6_INFOMSG_MASK)\r\nreturn 1;\r\ninside_iph = skb_header_pointer(skb, outside_hdrlen + sizeof(_icmph),\r\nsizeof(*ipv6_var), ipv6_var);\r\nif (inside_iph == NULL)\r\nreturn 1;\r\ninside_nexthdr = inside_iph->nexthdr;\r\ninside_hdrlen = ipv6_skip_exthdr(skb, outside_hdrlen + sizeof(_icmph) +\r\nsizeof(*ipv6_var),\r\n&inside_nexthdr, &inside_fragoff);\r\nif (inside_hdrlen < 0)\r\nreturn 1;\r\nif (inside_nexthdr != IPPROTO_TCP &&\r\ninside_nexthdr != IPPROTO_UDP)\r\nreturn 1;\r\nports = skb_header_pointer(skb, inside_hdrlen,\r\nsizeof(_ports), &_ports);\r\nif (ports == NULL)\r\nreturn 1;\r\n*protocol = inside_nexthdr;\r\n*laddr = &inside_iph->saddr;\r\n*lport = ports[0];\r\n*raddr = &inside_iph->daddr;\r\n*rport = ports[1];\r\nreturn 0;\r\n}\r\nstatic struct sock *\r\nxt_socket_get_sock_v6(struct net *net, const u8 protocol,\r\nconst struct in6_addr *saddr, const struct in6_addr *daddr,\r\nconst __be16 sport, const __be16 dport,\r\nconst struct net_device *in)\r\n{\r\nswitch (protocol) {\r\ncase IPPROTO_TCP:\r\nreturn inet6_lookup(net, &tcp_hashinfo,\r\nsaddr, sport, daddr, dport,\r\nin->ifindex);\r\ncase IPPROTO_UDP:\r\nreturn udp6_lib_lookup(net, saddr, sport, daddr, dport,\r\nin->ifindex);\r\n}\r\nreturn NULL;\r\n}\r\nstatic struct sock *xt_socket_lookup_slow_v6(struct net *net,\r\nconst struct sk_buff *skb,\r\nconst struct net_device *indev)\r\n{\r\n__be16 uninitialized_var(dport), uninitialized_var(sport);\r\nconst struct in6_addr *daddr = NULL, *saddr = NULL;\r\nstruct ipv6hdr *iph = ipv6_hdr(skb);\r\nint thoff = 0, tproto;\r\ntproto = ipv6_find_hdr(skb, &thoff, -1, NULL, NULL);\r\nif (tproto < 0) {\r\npr_debug("unable to find transport header in IPv6 packet, dropping\n");\r\nreturn NULL;\r\n}\r\nif (tproto == IPPROTO_UDP || tproto == IPPROTO_TCP) {\r\nstruct udphdr _hdr, *hp;\r\nhp = skb_header_pointer(skb, thoff, sizeof(_hdr), &_hdr);\r\nif (hp == NULL)\r\nreturn NULL;\r\nsaddr = &iph->saddr;\r\nsport = hp->source;\r\ndaddr = &iph->daddr;\r\ndport = hp->dest;\r\n} else if (tproto == IPPROTO_ICMPV6) {\r\nstruct ipv6hdr ipv6_var;\r\nif (extract_icmp6_fields(skb, thoff, &tproto, &saddr, &daddr,\r\n&sport, &dport, &ipv6_var))\r\nreturn NULL;\r\n} else {\r\nreturn NULL;\r\n}\r\nreturn xt_socket_get_sock_v6(net, tproto, saddr, daddr,\r\nsport, dport, indev);\r\n}\r\nstatic bool\r\nsocket_mt6_v1_v2_v3(const struct sk_buff *skb, struct xt_action_param *par)\r\n{\r\nconst struct xt_socket_mtinfo1 *info = (struct xt_socket_mtinfo1 *) par->matchinfo;\r\nstruct sk_buff *pskb = (struct sk_buff *)skb;\r\nstruct sock *sk = skb->sk;\r\nif (!sk)\r\nsk = xt_socket_lookup_slow_v6(par->net, skb, par->in);\r\nif (sk) {\r\nbool wildcard;\r\nbool transparent = true;\r\nwildcard = (!(info->flags & XT_SOCKET_NOWILDCARD) &&\r\nsk_fullsock(sk) &&\r\nipv6_addr_any(&sk->sk_v6_rcv_saddr));\r\nif (info->flags & XT_SOCKET_TRANSPARENT)\r\ntransparent = xt_socket_sk_is_transparent(sk);\r\nif (info->flags & XT_SOCKET_RESTORESKMARK && !wildcard &&\r\ntransparent)\r\npskb->mark = sk->sk_mark;\r\nif (sk != skb->sk)\r\nsock_gen_put(sk);\r\nif (wildcard || !transparent)\r\nsk = NULL;\r\n}\r\nreturn sk != NULL;\r\n}\r\nstatic int socket_mt_v1_check(const struct xt_mtchk_param *par)\r\n{\r\nconst struct xt_socket_mtinfo1 *info = (struct xt_socket_mtinfo1 *) par->matchinfo;\r\nif (info->flags & ~XT_SOCKET_FLAGS_V1) {\r\npr_info("unknown flags 0x%x\n", info->flags & ~XT_SOCKET_FLAGS_V1);\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int socket_mt_v2_check(const struct xt_mtchk_param *par)\r\n{\r\nconst struct xt_socket_mtinfo2 *info = (struct xt_socket_mtinfo2 *) par->matchinfo;\r\nif (info->flags & ~XT_SOCKET_FLAGS_V2) {\r\npr_info("unknown flags 0x%x\n", info->flags & ~XT_SOCKET_FLAGS_V2);\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int socket_mt_v3_check(const struct xt_mtchk_param *par)\r\n{\r\nconst struct xt_socket_mtinfo3 *info =\r\n(struct xt_socket_mtinfo3 *)par->matchinfo;\r\nif (info->flags & ~XT_SOCKET_FLAGS_V3) {\r\npr_info("unknown flags 0x%x\n",\r\ninfo->flags & ~XT_SOCKET_FLAGS_V3);\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int __init socket_mt_init(void)\r\n{\r\nnf_defrag_ipv4_enable();\r\n#ifdef XT_SOCKET_HAVE_IPV6\r\nnf_defrag_ipv6_enable();\r\n#endif\r\nreturn xt_register_matches(socket_mt_reg, ARRAY_SIZE(socket_mt_reg));\r\n}\r\nstatic void __exit socket_mt_exit(void)\r\n{\r\nxt_unregister_matches(socket_mt_reg, ARRAY_SIZE(socket_mt_reg));\r\n}
