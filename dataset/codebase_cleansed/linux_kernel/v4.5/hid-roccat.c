static ssize_t roccat_read(struct file *file, char __user *buffer,\r\nsize_t count, loff_t *ppos)\r\n{\r\nstruct roccat_reader *reader = file->private_data;\r\nstruct roccat_device *device = reader->device;\r\nstruct roccat_report *report;\r\nssize_t retval = 0, len;\r\nDECLARE_WAITQUEUE(wait, current);\r\nmutex_lock(&device->cbuf_lock);\r\nif (reader->cbuf_start == device->cbuf_end) {\r\nadd_wait_queue(&device->wait, &wait);\r\nset_current_state(TASK_INTERRUPTIBLE);\r\nwhile (reader->cbuf_start == device->cbuf_end) {\r\nif (file->f_flags & O_NONBLOCK) {\r\nretval = -EAGAIN;\r\nbreak;\r\n}\r\nif (signal_pending(current)) {\r\nretval = -ERESTARTSYS;\r\nbreak;\r\n}\r\nif (!device->exist) {\r\nretval = -EIO;\r\nbreak;\r\n}\r\nmutex_unlock(&device->cbuf_lock);\r\nschedule();\r\nmutex_lock(&device->cbuf_lock);\r\nset_current_state(TASK_INTERRUPTIBLE);\r\n}\r\nset_current_state(TASK_RUNNING);\r\nremove_wait_queue(&device->wait, &wait);\r\n}\r\nif (retval)\r\ngoto exit_unlock;\r\nreport = &device->cbuf[reader->cbuf_start];\r\nlen = device->report_size > count ? count : device->report_size;\r\nif (copy_to_user(buffer, report->value, len)) {\r\nretval = -EFAULT;\r\ngoto exit_unlock;\r\n}\r\nretval += len;\r\nreader->cbuf_start = (reader->cbuf_start + 1) % ROCCAT_CBUF_SIZE;\r\nexit_unlock:\r\nmutex_unlock(&device->cbuf_lock);\r\nreturn retval;\r\n}\r\nstatic unsigned int roccat_poll(struct file *file, poll_table *wait)\r\n{\r\nstruct roccat_reader *reader = file->private_data;\r\npoll_wait(file, &reader->device->wait, wait);\r\nif (reader->cbuf_start != reader->device->cbuf_end)\r\nreturn POLLIN | POLLRDNORM;\r\nif (!reader->device->exist)\r\nreturn POLLERR | POLLHUP;\r\nreturn 0;\r\n}\r\nstatic int roccat_open(struct inode *inode, struct file *file)\r\n{\r\nunsigned int minor = iminor(inode);\r\nstruct roccat_reader *reader;\r\nstruct roccat_device *device;\r\nint error = 0;\r\nreader = kzalloc(sizeof(struct roccat_reader), GFP_KERNEL);\r\nif (!reader)\r\nreturn -ENOMEM;\r\nmutex_lock(&devices_lock);\r\ndevice = devices[minor];\r\nif (!device) {\r\npr_emerg("roccat device with minor %d doesn't exist\n", minor);\r\nerror = -ENODEV;\r\ngoto exit_err_devices;\r\n}\r\nmutex_lock(&device->readers_lock);\r\nif (!device->open++) {\r\nerror = hid_hw_power(device->hid, PM_HINT_FULLON);\r\nif (error < 0) {\r\n--device->open;\r\ngoto exit_err_readers;\r\n}\r\nerror = hid_hw_open(device->hid);\r\nif (error < 0) {\r\nhid_hw_power(device->hid, PM_HINT_NORMAL);\r\n--device->open;\r\ngoto exit_err_readers;\r\n}\r\n}\r\nreader->device = device;\r\nreader->cbuf_start = device->cbuf_end;\r\nlist_add_tail(&reader->node, &device->readers);\r\nfile->private_data = reader;\r\nexit_err_readers:\r\nmutex_unlock(&device->readers_lock);\r\nexit_err_devices:\r\nmutex_unlock(&devices_lock);\r\nif (error)\r\nkfree(reader);\r\nreturn error;\r\n}\r\nstatic int roccat_release(struct inode *inode, struct file *file)\r\n{\r\nunsigned int minor = iminor(inode);\r\nstruct roccat_reader *reader = file->private_data;\r\nstruct roccat_device *device;\r\nmutex_lock(&devices_lock);\r\ndevice = devices[minor];\r\nif (!device) {\r\nmutex_unlock(&devices_lock);\r\npr_emerg("roccat device with minor %d doesn't exist\n", minor);\r\nreturn -ENODEV;\r\n}\r\nmutex_lock(&device->readers_lock);\r\nlist_del(&reader->node);\r\nmutex_unlock(&device->readers_lock);\r\nkfree(reader);\r\nif (!--device->open) {\r\nif (device->exist) {\r\nhid_hw_power(device->hid, PM_HINT_NORMAL);\r\nhid_hw_close(device->hid);\r\n} else {\r\nkfree(device);\r\n}\r\n}\r\nmutex_unlock(&devices_lock);\r\nreturn 0;\r\n}\r\nint roccat_report_event(int minor, u8 const *data)\r\n{\r\nstruct roccat_device *device;\r\nstruct roccat_reader *reader;\r\nstruct roccat_report *report;\r\nuint8_t *new_value;\r\ndevice = devices[minor];\r\nnew_value = kmemdup(data, device->report_size, GFP_ATOMIC);\r\nif (!new_value)\r\nreturn -ENOMEM;\r\nreport = &device->cbuf[device->cbuf_end];\r\nkfree(report->value);\r\nreport->value = new_value;\r\ndevice->cbuf_end = (device->cbuf_end + 1) % ROCCAT_CBUF_SIZE;\r\nlist_for_each_entry(reader, &device->readers, node) {\r\nif (reader->cbuf_start == device->cbuf_end)\r\nreader->cbuf_start = (reader->cbuf_start + 1) % ROCCAT_CBUF_SIZE;\r\n}\r\nwake_up_interruptible(&device->wait);\r\nreturn 0;\r\n}\r\nint roccat_connect(struct class *klass, struct hid_device *hid, int report_size)\r\n{\r\nunsigned int minor;\r\nstruct roccat_device *device;\r\nint temp;\r\ndevice = kzalloc(sizeof(struct roccat_device), GFP_KERNEL);\r\nif (!device)\r\nreturn -ENOMEM;\r\nmutex_lock(&devices_lock);\r\nfor (minor = 0; minor < ROCCAT_MAX_DEVICES; ++minor) {\r\nif (devices[minor])\r\ncontinue;\r\nbreak;\r\n}\r\nif (minor < ROCCAT_MAX_DEVICES) {\r\ndevices[minor] = device;\r\n} else {\r\nmutex_unlock(&devices_lock);\r\nkfree(device);\r\nreturn -EINVAL;\r\n}\r\ndevice->dev = device_create(klass, &hid->dev,\r\nMKDEV(roccat_major, minor), NULL,\r\n"%s%s%d", "roccat", hid->driver->name, minor);\r\nif (IS_ERR(device->dev)) {\r\ndevices[minor] = NULL;\r\nmutex_unlock(&devices_lock);\r\ntemp = PTR_ERR(device->dev);\r\nkfree(device);\r\nreturn temp;\r\n}\r\nmutex_unlock(&devices_lock);\r\ninit_waitqueue_head(&device->wait);\r\nINIT_LIST_HEAD(&device->readers);\r\nmutex_init(&device->readers_lock);\r\nmutex_init(&device->cbuf_lock);\r\ndevice->minor = minor;\r\ndevice->hid = hid;\r\ndevice->exist = 1;\r\ndevice->cbuf_end = 0;\r\ndevice->report_size = report_size;\r\nreturn minor;\r\n}\r\nvoid roccat_disconnect(int minor)\r\n{\r\nstruct roccat_device *device;\r\nmutex_lock(&devices_lock);\r\ndevice = devices[minor];\r\nmutex_unlock(&devices_lock);\r\ndevice->exist = 0;\r\ndevice_destroy(device->dev->class, MKDEV(roccat_major, minor));\r\nmutex_lock(&devices_lock);\r\ndevices[minor] = NULL;\r\nmutex_unlock(&devices_lock);\r\nif (device->open) {\r\nhid_hw_close(device->hid);\r\nwake_up_interruptible(&device->wait);\r\n} else {\r\nkfree(device);\r\n}\r\n}\r\nstatic long roccat_ioctl(struct file *file, unsigned int cmd, unsigned long arg)\r\n{\r\nstruct inode *inode = file_inode(file);\r\nstruct roccat_device *device;\r\nunsigned int minor = iminor(inode);\r\nlong retval = 0;\r\nmutex_lock(&devices_lock);\r\ndevice = devices[minor];\r\nif (!device) {\r\nretval = -ENODEV;\r\ngoto out;\r\n}\r\nswitch (cmd) {\r\ncase ROCCATIOCGREPSIZE:\r\nif (put_user(device->report_size, (int __user *)arg))\r\nretval = -EFAULT;\r\nbreak;\r\ndefault:\r\nretval = -ENOTTY;\r\n}\r\nout:\r\nmutex_unlock(&devices_lock);\r\nreturn retval;\r\n}\r\nstatic int __init roccat_init(void)\r\n{\r\nint retval;\r\ndev_t dev_id;\r\nretval = alloc_chrdev_region(&dev_id, ROCCAT_FIRST_MINOR,\r\nROCCAT_MAX_DEVICES, "roccat");\r\nroccat_major = MAJOR(dev_id);\r\nif (retval < 0) {\r\npr_warn("can't get major number\n");\r\ngoto error;\r\n}\r\ncdev_init(&roccat_cdev, &roccat_ops);\r\nretval = cdev_add(&roccat_cdev, dev_id, ROCCAT_MAX_DEVICES);\r\nif (retval < 0) {\r\npr_warn("cannot add cdev\n");\r\ngoto cleanup_alloc_chrdev_region;\r\n}\r\nreturn 0;\r\ncleanup_alloc_chrdev_region:\r\nunregister_chrdev_region(dev_id, ROCCAT_MAX_DEVICES);\r\nerror:\r\nreturn retval;\r\n}\r\nstatic void __exit roccat_exit(void)\r\n{\r\ndev_t dev_id = MKDEV(roccat_major, 0);\r\ncdev_del(&roccat_cdev);\r\nunregister_chrdev_region(dev_id, ROCCAT_MAX_DEVICES);\r\n}
