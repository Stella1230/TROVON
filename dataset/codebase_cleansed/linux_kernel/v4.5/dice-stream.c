int snd_dice_stream_get_rate_mode(struct snd_dice *dice, unsigned int rate,\r\nunsigned int *mode)\r\n{\r\nint i;\r\nfor (i = 0; i < ARRAY_SIZE(snd_dice_rates); i++) {\r\nif (!(dice->clock_caps & BIT(i)))\r\ncontinue;\r\nif (snd_dice_rates[i] != rate)\r\ncontinue;\r\n*mode = (i - 1) / 2;\r\nreturn 0;\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic void release_resources(struct snd_dice *dice,\r\nstruct fw_iso_resources *resources)\r\n{\r\n__be32 channel;\r\nchannel = cpu_to_be32((u32)-1);\r\nif (resources == &dice->tx_resources)\r\nsnd_dice_transaction_write_tx(dice, TX_ISOCHRONOUS,\r\n&channel, sizeof(channel));\r\nelse\r\nsnd_dice_transaction_write_rx(dice, RX_ISOCHRONOUS,\r\n&channel, sizeof(channel));\r\nfw_iso_resources_free(resources);\r\n}\r\nstatic int keep_resources(struct snd_dice *dice,\r\nstruct fw_iso_resources *resources,\r\nunsigned int max_payload_bytes)\r\n{\r\n__be32 channel;\r\nint err;\r\nerr = fw_iso_resources_allocate(resources, max_payload_bytes,\r\nfw_parent_device(dice->unit)->max_speed);\r\nif (err < 0)\r\ngoto end;\r\nchannel = cpu_to_be32(resources->channel);\r\nif (resources == &dice->tx_resources)\r\nerr = snd_dice_transaction_write_tx(dice, TX_ISOCHRONOUS,\r\n&channel, sizeof(channel));\r\nelse\r\nerr = snd_dice_transaction_write_rx(dice, RX_ISOCHRONOUS,\r\n&channel, sizeof(channel));\r\nif (err < 0)\r\nrelease_resources(dice, resources);\r\nend:\r\nreturn err;\r\n}\r\nstatic void stop_stream(struct snd_dice *dice, struct amdtp_stream *stream)\r\n{\r\namdtp_stream_pcm_abort(stream);\r\namdtp_stream_stop(stream);\r\nif (stream == &dice->tx_stream)\r\nrelease_resources(dice, &dice->tx_resources);\r\nelse\r\nrelease_resources(dice, &dice->rx_resources);\r\n}\r\nstatic int start_stream(struct snd_dice *dice, struct amdtp_stream *stream,\r\nunsigned int rate)\r\n{\r\nstruct fw_iso_resources *resources;\r\nunsigned int i, mode, pcm_chs, midi_ports;\r\nbool double_pcm_frames;\r\nint err;\r\nerr = snd_dice_stream_get_rate_mode(dice, rate, &mode);\r\nif (err < 0)\r\ngoto end;\r\nif (stream == &dice->tx_stream) {\r\nresources = &dice->tx_resources;\r\npcm_chs = dice->tx_channels[mode];\r\nmidi_ports = dice->tx_midi_ports[mode];\r\n} else {\r\nresources = &dice->rx_resources;\r\npcm_chs = dice->rx_channels[mode];\r\nmidi_ports = dice->rx_midi_ports[mode];\r\n}\r\ndouble_pcm_frames = mode > 1;\r\nif (double_pcm_frames) {\r\nrate /= 2;\r\npcm_chs *= 2;\r\n}\r\nerr = amdtp_am824_set_parameters(stream, rate, pcm_chs, midi_ports,\r\ndouble_pcm_frames);\r\nif (err < 0)\r\ngoto end;\r\nif (double_pcm_frames) {\r\npcm_chs /= 2;\r\nfor (i = 0; i < pcm_chs; i++) {\r\namdtp_am824_set_pcm_position(stream, i, i * 2);\r\namdtp_am824_set_pcm_position(stream, i + pcm_chs,\r\ni * 2 + 1);\r\n}\r\n}\r\nerr = keep_resources(dice, resources,\r\namdtp_stream_get_max_payload(stream));\r\nif (err < 0) {\r\ndev_err(&dice->unit->device,\r\n"fail to keep isochronous resources\n");\r\ngoto end;\r\n}\r\nerr = amdtp_stream_start(stream, resources->channel,\r\nfw_parent_device(dice->unit)->max_speed);\r\nif (err < 0)\r\nrelease_resources(dice, resources);\r\nend:\r\nreturn err;\r\n}\r\nstatic int get_sync_mode(struct snd_dice *dice, enum cip_flags *sync_mode)\r\n{\r\nu32 source;\r\nint err;\r\nerr = snd_dice_transaction_get_clock_source(dice, &source);\r\nif (err < 0)\r\ngoto end;\r\nswitch (source) {\r\ncase CLOCK_SOURCE_ARX4:\r\ncase CLOCK_SOURCE_ARX3:\r\ncase CLOCK_SOURCE_ARX2:\r\nerr = -ENOSYS;\r\nbreak;\r\ncase CLOCK_SOURCE_ARX1:\r\n*sync_mode = 0;\r\nbreak;\r\ndefault:\r\n*sync_mode = CIP_SYNC_TO_DEVICE;\r\nbreak;\r\n}\r\nend:\r\nreturn err;\r\n}\r\nint snd_dice_stream_start_duplex(struct snd_dice *dice, unsigned int rate)\r\n{\r\nstruct amdtp_stream *master, *slave;\r\nunsigned int curr_rate;\r\nenum cip_flags sync_mode;\r\nint err = 0;\r\nif (dice->substreams_counter == 0)\r\ngoto end;\r\nerr = get_sync_mode(dice, &sync_mode);\r\nif (err < 0)\r\ngoto end;\r\nif (sync_mode == CIP_SYNC_TO_DEVICE) {\r\nmaster = &dice->tx_stream;\r\nslave = &dice->rx_stream;\r\n} else {\r\nmaster = &dice->rx_stream;\r\nslave = &dice->tx_stream;\r\n}\r\nif (amdtp_streaming_error(master) || amdtp_streaming_error(slave))\r\nstop_stream(dice, master);\r\nerr = snd_dice_transaction_get_rate(dice, &curr_rate);\r\nif (err < 0) {\r\ndev_err(&dice->unit->device,\r\n"fail to get sampling rate\n");\r\ngoto end;\r\n}\r\nif (rate == 0)\r\nrate = curr_rate;\r\nif (rate != curr_rate)\r\nstop_stream(dice, master);\r\nif (!amdtp_stream_running(master)) {\r\nstop_stream(dice, slave);\r\nsnd_dice_transaction_clear_enable(dice);\r\namdtp_stream_set_sync(sync_mode, master, slave);\r\nerr = snd_dice_transaction_set_rate(dice, rate);\r\nif (err < 0) {\r\ndev_err(&dice->unit->device,\r\n"fail to set sampling rate\n");\r\ngoto end;\r\n}\r\nerr = start_stream(dice, master, rate);\r\nif (err < 0) {\r\ndev_err(&dice->unit->device,\r\n"fail to start AMDTP master stream\n");\r\ngoto end;\r\n}\r\nerr = start_stream(dice, slave, rate);\r\nif (err < 0) {\r\ndev_err(&dice->unit->device,\r\n"fail to start AMDTP slave stream\n");\r\nstop_stream(dice, master);\r\ngoto end;\r\n}\r\nerr = snd_dice_transaction_set_enable(dice);\r\nif (err < 0) {\r\ndev_err(&dice->unit->device,\r\n"fail to enable interface\n");\r\nstop_stream(dice, master);\r\nstop_stream(dice, slave);\r\ngoto end;\r\n}\r\nif (!amdtp_stream_wait_callback(master, CALLBACK_TIMEOUT) ||\r\n!amdtp_stream_wait_callback(slave, CALLBACK_TIMEOUT)) {\r\nsnd_dice_transaction_clear_enable(dice);\r\nstop_stream(dice, master);\r\nstop_stream(dice, slave);\r\nerr = -ETIMEDOUT;\r\n}\r\n}\r\nend:\r\nreturn err;\r\n}\r\nvoid snd_dice_stream_stop_duplex(struct snd_dice *dice)\r\n{\r\nif (dice->substreams_counter > 0)\r\nreturn;\r\nsnd_dice_transaction_clear_enable(dice);\r\nstop_stream(dice, &dice->tx_stream);\r\nstop_stream(dice, &dice->rx_stream);\r\n}\r\nstatic int init_stream(struct snd_dice *dice, struct amdtp_stream *stream)\r\n{\r\nint err;\r\nstruct fw_iso_resources *resources;\r\nenum amdtp_stream_direction dir;\r\nif (stream == &dice->tx_stream) {\r\nresources = &dice->tx_resources;\r\ndir = AMDTP_IN_STREAM;\r\n} else {\r\nresources = &dice->rx_resources;\r\ndir = AMDTP_OUT_STREAM;\r\n}\r\nerr = fw_iso_resources_init(resources, dice->unit);\r\nif (err < 0)\r\ngoto end;\r\nresources->channels_mask = 0x00000000ffffffffuLL;\r\nerr = amdtp_am824_init(stream, dice->unit, dir, CIP_BLOCKING);\r\nif (err < 0) {\r\namdtp_stream_destroy(stream);\r\nfw_iso_resources_destroy(resources);\r\n}\r\nend:\r\nreturn err;\r\n}\r\nstatic void destroy_stream(struct snd_dice *dice, struct amdtp_stream *stream)\r\n{\r\nstruct fw_iso_resources *resources;\r\nif (stream == &dice->tx_stream)\r\nresources = &dice->tx_resources;\r\nelse\r\nresources = &dice->rx_resources;\r\namdtp_stream_destroy(stream);\r\nfw_iso_resources_destroy(resources);\r\n}\r\nint snd_dice_stream_init_duplex(struct snd_dice *dice)\r\n{\r\nint err;\r\ndice->substreams_counter = 0;\r\nerr = init_stream(dice, &dice->tx_stream);\r\nif (err < 0)\r\ngoto end;\r\nerr = init_stream(dice, &dice->rx_stream);\r\nif (err < 0)\r\ndestroy_stream(dice, &dice->tx_stream);\r\nend:\r\nreturn err;\r\n}\r\nvoid snd_dice_stream_destroy_duplex(struct snd_dice *dice)\r\n{\r\nsnd_dice_transaction_clear_enable(dice);\r\ndestroy_stream(dice, &dice->tx_stream);\r\ndestroy_stream(dice, &dice->rx_stream);\r\ndice->substreams_counter = 0;\r\n}\r\nvoid snd_dice_stream_update_duplex(struct snd_dice *dice)\r\n{\r\ndice->global_enabled = false;\r\nstop_stream(dice, &dice->rx_stream);\r\nstop_stream(dice, &dice->tx_stream);\r\nfw_iso_resources_update(&dice->rx_resources);\r\nfw_iso_resources_update(&dice->tx_resources);\r\n}\r\nstatic void dice_lock_changed(struct snd_dice *dice)\r\n{\r\ndice->dev_lock_changed = true;\r\nwake_up(&dice->hwdep_wait);\r\n}\r\nint snd_dice_stream_lock_try(struct snd_dice *dice)\r\n{\r\nint err;\r\nspin_lock_irq(&dice->lock);\r\nif (dice->dev_lock_count < 0) {\r\nerr = -EBUSY;\r\ngoto out;\r\n}\r\nif (dice->dev_lock_count++ == 0)\r\ndice_lock_changed(dice);\r\nerr = 0;\r\nout:\r\nspin_unlock_irq(&dice->lock);\r\nreturn err;\r\n}\r\nvoid snd_dice_stream_lock_release(struct snd_dice *dice)\r\n{\r\nspin_lock_irq(&dice->lock);\r\nif (WARN_ON(dice->dev_lock_count <= 0))\r\ngoto out;\r\nif (--dice->dev_lock_count == 0)\r\ndice_lock_changed(dice);\r\nout:\r\nspin_unlock_irq(&dice->lock);\r\n}
