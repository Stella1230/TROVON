void ecryptfs_to_hex(char *dst, char *src, size_t src_size)\r\n{\r\nint x;\r\nfor (x = 0; x < src_size; x++)\r\nsprintf(&dst[x * 2], "%.2x", (unsigned char)src[x]);\r\n}\r\nvoid ecryptfs_from_hex(char *dst, char *src, int dst_size)\r\n{\r\nint x;\r\nchar tmp[3] = { 0, };\r\nfor (x = 0; x < dst_size; x++) {\r\ntmp[0] = src[x * 2];\r\ntmp[1] = src[x * 2 + 1];\r\ndst[x] = (unsigned char)simple_strtol(tmp, NULL, 16);\r\n}\r\n}\r\nstatic int ecryptfs_calculate_md5(char *dst,\r\nstruct ecryptfs_crypt_stat *crypt_stat,\r\nchar *src, int len)\r\n{\r\nstruct scatterlist sg;\r\nstruct hash_desc desc = {\r\n.tfm = crypt_stat->hash_tfm,\r\n.flags = CRYPTO_TFM_REQ_MAY_SLEEP\r\n};\r\nint rc = 0;\r\nmutex_lock(&crypt_stat->cs_hash_tfm_mutex);\r\nsg_init_one(&sg, (u8 *)src, len);\r\nif (!desc.tfm) {\r\ndesc.tfm = crypto_alloc_hash(ECRYPTFS_DEFAULT_HASH, 0,\r\nCRYPTO_ALG_ASYNC);\r\nif (IS_ERR(desc.tfm)) {\r\nrc = PTR_ERR(desc.tfm);\r\necryptfs_printk(KERN_ERR, "Error attempting to "\r\n"allocate crypto context; rc = [%d]\n",\r\nrc);\r\ngoto out;\r\n}\r\ncrypt_stat->hash_tfm = desc.tfm;\r\n}\r\nrc = crypto_hash_init(&desc);\r\nif (rc) {\r\nprintk(KERN_ERR\r\n"%s: Error initializing crypto hash; rc = [%d]\n",\r\n__func__, rc);\r\ngoto out;\r\n}\r\nrc = crypto_hash_update(&desc, &sg, len);\r\nif (rc) {\r\nprintk(KERN_ERR\r\n"%s: Error updating crypto hash; rc = [%d]\n",\r\n__func__, rc);\r\ngoto out;\r\n}\r\nrc = crypto_hash_final(&desc, dst);\r\nif (rc) {\r\nprintk(KERN_ERR\r\n"%s: Error finalizing crypto hash; rc = [%d]\n",\r\n__func__, rc);\r\ngoto out;\r\n}\r\nout:\r\nmutex_unlock(&crypt_stat->cs_hash_tfm_mutex);\r\nreturn rc;\r\n}\r\nstatic int ecryptfs_crypto_api_algify_cipher_name(char **algified_name,\r\nchar *cipher_name,\r\nchar *chaining_modifier)\r\n{\r\nint cipher_name_len = strlen(cipher_name);\r\nint chaining_modifier_len = strlen(chaining_modifier);\r\nint algified_name_len;\r\nint rc;\r\nalgified_name_len = (chaining_modifier_len + cipher_name_len + 3);\r\n(*algified_name) = kmalloc(algified_name_len, GFP_KERNEL);\r\nif (!(*algified_name)) {\r\nrc = -ENOMEM;\r\ngoto out;\r\n}\r\nsnprintf((*algified_name), algified_name_len, "%s(%s)",\r\nchaining_modifier, cipher_name);\r\nrc = 0;\r\nout:\r\nreturn rc;\r\n}\r\nint ecryptfs_derive_iv(char *iv, struct ecryptfs_crypt_stat *crypt_stat,\r\nloff_t offset)\r\n{\r\nint rc = 0;\r\nchar dst[MD5_DIGEST_SIZE];\r\nchar src[ECRYPTFS_MAX_IV_BYTES + 16];\r\nif (unlikely(ecryptfs_verbosity > 0)) {\r\necryptfs_printk(KERN_DEBUG, "root iv:\n");\r\necryptfs_dump_hex(crypt_stat->root_iv, crypt_stat->iv_bytes);\r\n}\r\nmemcpy(src, crypt_stat->root_iv, crypt_stat->iv_bytes);\r\nmemset((src + crypt_stat->iv_bytes), 0, 16);\r\nsnprintf((src + crypt_stat->iv_bytes), 16, "%lld", offset);\r\nif (unlikely(ecryptfs_verbosity > 0)) {\r\necryptfs_printk(KERN_DEBUG, "source:\n");\r\necryptfs_dump_hex(src, (crypt_stat->iv_bytes + 16));\r\n}\r\nrc = ecryptfs_calculate_md5(dst, crypt_stat, src,\r\n(crypt_stat->iv_bytes + 16));\r\nif (rc) {\r\necryptfs_printk(KERN_WARNING, "Error attempting to compute "\r\n"MD5 while generating IV for a page\n");\r\ngoto out;\r\n}\r\nmemcpy(iv, dst, crypt_stat->iv_bytes);\r\nif (unlikely(ecryptfs_verbosity > 0)) {\r\necryptfs_printk(KERN_DEBUG, "derived iv:\n");\r\necryptfs_dump_hex(iv, crypt_stat->iv_bytes);\r\n}\r\nout:\r\nreturn rc;\r\n}\r\nvoid\r\necryptfs_init_crypt_stat(struct ecryptfs_crypt_stat *crypt_stat)\r\n{\r\nmemset((void *)crypt_stat, 0, sizeof(struct ecryptfs_crypt_stat));\r\nINIT_LIST_HEAD(&crypt_stat->keysig_list);\r\nmutex_init(&crypt_stat->keysig_list_mutex);\r\nmutex_init(&crypt_stat->cs_mutex);\r\nmutex_init(&crypt_stat->cs_tfm_mutex);\r\nmutex_init(&crypt_stat->cs_hash_tfm_mutex);\r\ncrypt_stat->flags |= ECRYPTFS_STRUCT_INITIALIZED;\r\n}\r\nvoid ecryptfs_destroy_crypt_stat(struct ecryptfs_crypt_stat *crypt_stat)\r\n{\r\nstruct ecryptfs_key_sig *key_sig, *key_sig_tmp;\r\nif (crypt_stat->tfm)\r\ncrypto_free_ablkcipher(crypt_stat->tfm);\r\nif (crypt_stat->hash_tfm)\r\ncrypto_free_hash(crypt_stat->hash_tfm);\r\nlist_for_each_entry_safe(key_sig, key_sig_tmp,\r\n&crypt_stat->keysig_list, crypt_stat_list) {\r\nlist_del(&key_sig->crypt_stat_list);\r\nkmem_cache_free(ecryptfs_key_sig_cache, key_sig);\r\n}\r\nmemset(crypt_stat, 0, sizeof(struct ecryptfs_crypt_stat));\r\n}\r\nvoid ecryptfs_destroy_mount_crypt_stat(\r\nstruct ecryptfs_mount_crypt_stat *mount_crypt_stat)\r\n{\r\nstruct ecryptfs_global_auth_tok *auth_tok, *auth_tok_tmp;\r\nif (!(mount_crypt_stat->flags & ECRYPTFS_MOUNT_CRYPT_STAT_INITIALIZED))\r\nreturn;\r\nmutex_lock(&mount_crypt_stat->global_auth_tok_list_mutex);\r\nlist_for_each_entry_safe(auth_tok, auth_tok_tmp,\r\n&mount_crypt_stat->global_auth_tok_list,\r\nmount_crypt_stat_list) {\r\nlist_del(&auth_tok->mount_crypt_stat_list);\r\nif (!(auth_tok->flags & ECRYPTFS_AUTH_TOK_INVALID))\r\nkey_put(auth_tok->global_auth_tok_key);\r\nkmem_cache_free(ecryptfs_global_auth_tok_cache, auth_tok);\r\n}\r\nmutex_unlock(&mount_crypt_stat->global_auth_tok_list_mutex);\r\nmemset(mount_crypt_stat, 0, sizeof(struct ecryptfs_mount_crypt_stat));\r\n}\r\nint virt_to_scatterlist(const void *addr, int size, struct scatterlist *sg,\r\nint sg_size)\r\n{\r\nint i = 0;\r\nstruct page *pg;\r\nint offset;\r\nint remainder_of_page;\r\nsg_init_table(sg, sg_size);\r\nwhile (size > 0 && i < sg_size) {\r\npg = virt_to_page(addr);\r\noffset = offset_in_page(addr);\r\nsg_set_page(&sg[i], pg, 0, offset);\r\nremainder_of_page = PAGE_CACHE_SIZE - offset;\r\nif (size >= remainder_of_page) {\r\nsg[i].length = remainder_of_page;\r\naddr += remainder_of_page;\r\nsize -= remainder_of_page;\r\n} else {\r\nsg[i].length = size;\r\naddr += size;\r\nsize = 0;\r\n}\r\ni++;\r\n}\r\nif (size > 0)\r\nreturn -ENOMEM;\r\nreturn i;\r\n}\r\nstatic void extent_crypt_complete(struct crypto_async_request *req, int rc)\r\n{\r\nstruct extent_crypt_result *ecr = req->data;\r\nif (rc == -EINPROGRESS)\r\nreturn;\r\necr->rc = rc;\r\ncomplete(&ecr->completion);\r\n}\r\nstatic int crypt_scatterlist(struct ecryptfs_crypt_stat *crypt_stat,\r\nstruct scatterlist *dst_sg,\r\nstruct scatterlist *src_sg, int size,\r\nunsigned char *iv, int op)\r\n{\r\nstruct ablkcipher_request *req = NULL;\r\nstruct extent_crypt_result ecr;\r\nint rc = 0;\r\nBUG_ON(!crypt_stat || !crypt_stat->tfm\r\n|| !(crypt_stat->flags & ECRYPTFS_STRUCT_INITIALIZED));\r\nif (unlikely(ecryptfs_verbosity > 0)) {\r\necryptfs_printk(KERN_DEBUG, "Key size [%zd]; key:\n",\r\ncrypt_stat->key_size);\r\necryptfs_dump_hex(crypt_stat->key,\r\ncrypt_stat->key_size);\r\n}\r\ninit_completion(&ecr.completion);\r\nmutex_lock(&crypt_stat->cs_tfm_mutex);\r\nreq = ablkcipher_request_alloc(crypt_stat->tfm, GFP_NOFS);\r\nif (!req) {\r\nmutex_unlock(&crypt_stat->cs_tfm_mutex);\r\nrc = -ENOMEM;\r\ngoto out;\r\n}\r\nablkcipher_request_set_callback(req,\r\nCRYPTO_TFM_REQ_MAY_BACKLOG | CRYPTO_TFM_REQ_MAY_SLEEP,\r\nextent_crypt_complete, &ecr);\r\nif (!(crypt_stat->flags & ECRYPTFS_KEY_SET)) {\r\nrc = crypto_ablkcipher_setkey(crypt_stat->tfm, crypt_stat->key,\r\ncrypt_stat->key_size);\r\nif (rc) {\r\necryptfs_printk(KERN_ERR,\r\n"Error setting key; rc = [%d]\n",\r\nrc);\r\nmutex_unlock(&crypt_stat->cs_tfm_mutex);\r\nrc = -EINVAL;\r\ngoto out;\r\n}\r\ncrypt_stat->flags |= ECRYPTFS_KEY_SET;\r\n}\r\nmutex_unlock(&crypt_stat->cs_tfm_mutex);\r\nablkcipher_request_set_crypt(req, src_sg, dst_sg, size, iv);\r\nrc = op == ENCRYPT ? crypto_ablkcipher_encrypt(req) :\r\ncrypto_ablkcipher_decrypt(req);\r\nif (rc == -EINPROGRESS || rc == -EBUSY) {\r\nstruct extent_crypt_result *ecr = req->base.data;\r\nwait_for_completion(&ecr->completion);\r\nrc = ecr->rc;\r\nreinit_completion(&ecr->completion);\r\n}\r\nout:\r\nablkcipher_request_free(req);\r\nreturn rc;\r\n}\r\nstatic loff_t lower_offset_for_page(struct ecryptfs_crypt_stat *crypt_stat,\r\nstruct page *page)\r\n{\r\nreturn ecryptfs_lower_header_size(crypt_stat) +\r\n((loff_t)page->index << PAGE_CACHE_SHIFT);\r\n}\r\nstatic int crypt_extent(struct ecryptfs_crypt_stat *crypt_stat,\r\nstruct page *dst_page,\r\nstruct page *src_page,\r\nunsigned long extent_offset, int op)\r\n{\r\npgoff_t page_index = op == ENCRYPT ? src_page->index : dst_page->index;\r\nloff_t extent_base;\r\nchar extent_iv[ECRYPTFS_MAX_IV_BYTES];\r\nstruct scatterlist src_sg, dst_sg;\r\nsize_t extent_size = crypt_stat->extent_size;\r\nint rc;\r\nextent_base = (((loff_t)page_index) * (PAGE_CACHE_SIZE / extent_size));\r\nrc = ecryptfs_derive_iv(extent_iv, crypt_stat,\r\n(extent_base + extent_offset));\r\nif (rc) {\r\necryptfs_printk(KERN_ERR, "Error attempting to derive IV for "\r\n"extent [0x%.16llx]; rc = [%d]\n",\r\n(unsigned long long)(extent_base + extent_offset), rc);\r\ngoto out;\r\n}\r\nsg_init_table(&src_sg, 1);\r\nsg_init_table(&dst_sg, 1);\r\nsg_set_page(&src_sg, src_page, extent_size,\r\nextent_offset * extent_size);\r\nsg_set_page(&dst_sg, dst_page, extent_size,\r\nextent_offset * extent_size);\r\nrc = crypt_scatterlist(crypt_stat, &dst_sg, &src_sg, extent_size,\r\nextent_iv, op);\r\nif (rc < 0) {\r\nprintk(KERN_ERR "%s: Error attempting to crypt page with "\r\n"page_index = [%ld], extent_offset = [%ld]; "\r\n"rc = [%d]\n", __func__, page_index, extent_offset, rc);\r\ngoto out;\r\n}\r\nrc = 0;\r\nout:\r\nreturn rc;\r\n}\r\nint ecryptfs_encrypt_page(struct page *page)\r\n{\r\nstruct inode *ecryptfs_inode;\r\nstruct ecryptfs_crypt_stat *crypt_stat;\r\nchar *enc_extent_virt;\r\nstruct page *enc_extent_page = NULL;\r\nloff_t extent_offset;\r\nloff_t lower_offset;\r\nint rc = 0;\r\necryptfs_inode = page->mapping->host;\r\ncrypt_stat =\r\n&(ecryptfs_inode_to_private(ecryptfs_inode)->crypt_stat);\r\nBUG_ON(!(crypt_stat->flags & ECRYPTFS_ENCRYPTED));\r\nenc_extent_page = alloc_page(GFP_USER);\r\nif (!enc_extent_page) {\r\nrc = -ENOMEM;\r\necryptfs_printk(KERN_ERR, "Error allocating memory for "\r\n"encrypted extent\n");\r\ngoto out;\r\n}\r\nfor (extent_offset = 0;\r\nextent_offset < (PAGE_CACHE_SIZE / crypt_stat->extent_size);\r\nextent_offset++) {\r\nrc = crypt_extent(crypt_stat, enc_extent_page, page,\r\nextent_offset, ENCRYPT);\r\nif (rc) {\r\nprintk(KERN_ERR "%s: Error encrypting extent; "\r\n"rc = [%d]\n", __func__, rc);\r\ngoto out;\r\n}\r\n}\r\nlower_offset = lower_offset_for_page(crypt_stat, page);\r\nenc_extent_virt = kmap(enc_extent_page);\r\nrc = ecryptfs_write_lower(ecryptfs_inode, enc_extent_virt, lower_offset,\r\nPAGE_CACHE_SIZE);\r\nkunmap(enc_extent_page);\r\nif (rc < 0) {\r\necryptfs_printk(KERN_ERR,\r\n"Error attempting to write lower page; rc = [%d]\n",\r\nrc);\r\ngoto out;\r\n}\r\nrc = 0;\r\nout:\r\nif (enc_extent_page) {\r\n__free_page(enc_extent_page);\r\n}\r\nreturn rc;\r\n}\r\nint ecryptfs_decrypt_page(struct page *page)\r\n{\r\nstruct inode *ecryptfs_inode;\r\nstruct ecryptfs_crypt_stat *crypt_stat;\r\nchar *page_virt;\r\nunsigned long extent_offset;\r\nloff_t lower_offset;\r\nint rc = 0;\r\necryptfs_inode = page->mapping->host;\r\ncrypt_stat =\r\n&(ecryptfs_inode_to_private(ecryptfs_inode)->crypt_stat);\r\nBUG_ON(!(crypt_stat->flags & ECRYPTFS_ENCRYPTED));\r\nlower_offset = lower_offset_for_page(crypt_stat, page);\r\npage_virt = kmap(page);\r\nrc = ecryptfs_read_lower(page_virt, lower_offset, PAGE_CACHE_SIZE,\r\necryptfs_inode);\r\nkunmap(page);\r\nif (rc < 0) {\r\necryptfs_printk(KERN_ERR,\r\n"Error attempting to read lower page; rc = [%d]\n",\r\nrc);\r\ngoto out;\r\n}\r\nfor (extent_offset = 0;\r\nextent_offset < (PAGE_CACHE_SIZE / crypt_stat->extent_size);\r\nextent_offset++) {\r\nrc = crypt_extent(crypt_stat, page, page,\r\nextent_offset, DECRYPT);\r\nif (rc) {\r\nprintk(KERN_ERR "%s: Error encrypting extent; "\r\n"rc = [%d]\n", __func__, rc);\r\ngoto out;\r\n}\r\n}\r\nout:\r\nreturn rc;\r\n}\r\nint ecryptfs_init_crypt_ctx(struct ecryptfs_crypt_stat *crypt_stat)\r\n{\r\nchar *full_alg_name;\r\nint rc = -EINVAL;\r\necryptfs_printk(KERN_DEBUG,\r\n"Initializing cipher [%s]; strlen = [%d]; "\r\n"key_size_bits = [%zd]\n",\r\ncrypt_stat->cipher, (int)strlen(crypt_stat->cipher),\r\ncrypt_stat->key_size << 3);\r\nmutex_lock(&crypt_stat->cs_tfm_mutex);\r\nif (crypt_stat->tfm) {\r\nrc = 0;\r\ngoto out_unlock;\r\n}\r\nrc = ecryptfs_crypto_api_algify_cipher_name(&full_alg_name,\r\ncrypt_stat->cipher, "cbc");\r\nif (rc)\r\ngoto out_unlock;\r\ncrypt_stat->tfm = crypto_alloc_ablkcipher(full_alg_name, 0, 0);\r\nif (IS_ERR(crypt_stat->tfm)) {\r\nrc = PTR_ERR(crypt_stat->tfm);\r\ncrypt_stat->tfm = NULL;\r\necryptfs_printk(KERN_ERR, "cryptfs: init_crypt_ctx(): "\r\n"Error initializing cipher [%s]\n",\r\nfull_alg_name);\r\ngoto out_free;\r\n}\r\ncrypto_ablkcipher_set_flags(crypt_stat->tfm, CRYPTO_TFM_REQ_WEAK_KEY);\r\nrc = 0;\r\nout_free:\r\nkfree(full_alg_name);\r\nout_unlock:\r\nmutex_unlock(&crypt_stat->cs_tfm_mutex);\r\nreturn rc;\r\n}\r\nstatic void set_extent_mask_and_shift(struct ecryptfs_crypt_stat *crypt_stat)\r\n{\r\nint extent_size_tmp;\r\ncrypt_stat->extent_mask = 0xFFFFFFFF;\r\ncrypt_stat->extent_shift = 0;\r\nif (crypt_stat->extent_size == 0)\r\nreturn;\r\nextent_size_tmp = crypt_stat->extent_size;\r\nwhile ((extent_size_tmp & 0x01) == 0) {\r\nextent_size_tmp >>= 1;\r\ncrypt_stat->extent_mask <<= 1;\r\ncrypt_stat->extent_shift++;\r\n}\r\n}\r\nvoid ecryptfs_set_default_sizes(struct ecryptfs_crypt_stat *crypt_stat)\r\n{\r\ncrypt_stat->extent_size = ECRYPTFS_DEFAULT_EXTENT_SIZE;\r\nset_extent_mask_and_shift(crypt_stat);\r\ncrypt_stat->iv_bytes = ECRYPTFS_DEFAULT_IV_BYTES;\r\nif (crypt_stat->flags & ECRYPTFS_METADATA_IN_XATTR)\r\ncrypt_stat->metadata_size = ECRYPTFS_MINIMUM_HEADER_EXTENT_SIZE;\r\nelse {\r\nif (PAGE_CACHE_SIZE <= ECRYPTFS_MINIMUM_HEADER_EXTENT_SIZE)\r\ncrypt_stat->metadata_size =\r\nECRYPTFS_MINIMUM_HEADER_EXTENT_SIZE;\r\nelse\r\ncrypt_stat->metadata_size = PAGE_CACHE_SIZE;\r\n}\r\n}\r\nint ecryptfs_compute_root_iv(struct ecryptfs_crypt_stat *crypt_stat)\r\n{\r\nint rc = 0;\r\nchar dst[MD5_DIGEST_SIZE];\r\nBUG_ON(crypt_stat->iv_bytes > MD5_DIGEST_SIZE);\r\nBUG_ON(crypt_stat->iv_bytes <= 0);\r\nif (!(crypt_stat->flags & ECRYPTFS_KEY_VALID)) {\r\nrc = -EINVAL;\r\necryptfs_printk(KERN_WARNING, "Session key not valid; "\r\n"cannot generate root IV\n");\r\ngoto out;\r\n}\r\nrc = ecryptfs_calculate_md5(dst, crypt_stat, crypt_stat->key,\r\ncrypt_stat->key_size);\r\nif (rc) {\r\necryptfs_printk(KERN_WARNING, "Error attempting to compute "\r\n"MD5 while generating root IV\n");\r\ngoto out;\r\n}\r\nmemcpy(crypt_stat->root_iv, dst, crypt_stat->iv_bytes);\r\nout:\r\nif (rc) {\r\nmemset(crypt_stat->root_iv, 0, crypt_stat->iv_bytes);\r\ncrypt_stat->flags |= ECRYPTFS_SECURITY_WARNING;\r\n}\r\nreturn rc;\r\n}\r\nstatic void ecryptfs_generate_new_key(struct ecryptfs_crypt_stat *crypt_stat)\r\n{\r\nget_random_bytes(crypt_stat->key, crypt_stat->key_size);\r\ncrypt_stat->flags |= ECRYPTFS_KEY_VALID;\r\necryptfs_compute_root_iv(crypt_stat);\r\nif (unlikely(ecryptfs_verbosity > 0)) {\r\necryptfs_printk(KERN_DEBUG, "Generated new session key:\n");\r\necryptfs_dump_hex(crypt_stat->key,\r\ncrypt_stat->key_size);\r\n}\r\n}\r\nstatic void ecryptfs_copy_mount_wide_flags_to_inode_flags(\r\nstruct ecryptfs_crypt_stat *crypt_stat,\r\nstruct ecryptfs_mount_crypt_stat *mount_crypt_stat)\r\n{\r\nif (mount_crypt_stat->flags & ECRYPTFS_XATTR_METADATA_ENABLED)\r\ncrypt_stat->flags |= ECRYPTFS_METADATA_IN_XATTR;\r\nif (mount_crypt_stat->flags & ECRYPTFS_ENCRYPTED_VIEW_ENABLED)\r\ncrypt_stat->flags |= ECRYPTFS_VIEW_AS_ENCRYPTED;\r\nif (mount_crypt_stat->flags & ECRYPTFS_GLOBAL_ENCRYPT_FILENAMES) {\r\ncrypt_stat->flags |= ECRYPTFS_ENCRYPT_FILENAMES;\r\nif (mount_crypt_stat->flags\r\n& ECRYPTFS_GLOBAL_ENCFN_USE_MOUNT_FNEK)\r\ncrypt_stat->flags |= ECRYPTFS_ENCFN_USE_MOUNT_FNEK;\r\nelse if (mount_crypt_stat->flags\r\n& ECRYPTFS_GLOBAL_ENCFN_USE_FEK)\r\ncrypt_stat->flags |= ECRYPTFS_ENCFN_USE_FEK;\r\n}\r\n}\r\nstatic int ecryptfs_copy_mount_wide_sigs_to_inode_sigs(\r\nstruct ecryptfs_crypt_stat *crypt_stat,\r\nstruct ecryptfs_mount_crypt_stat *mount_crypt_stat)\r\n{\r\nstruct ecryptfs_global_auth_tok *global_auth_tok;\r\nint rc = 0;\r\nmutex_lock(&crypt_stat->keysig_list_mutex);\r\nmutex_lock(&mount_crypt_stat->global_auth_tok_list_mutex);\r\nlist_for_each_entry(global_auth_tok,\r\n&mount_crypt_stat->global_auth_tok_list,\r\nmount_crypt_stat_list) {\r\nif (global_auth_tok->flags & ECRYPTFS_AUTH_TOK_FNEK)\r\ncontinue;\r\nrc = ecryptfs_add_keysig(crypt_stat, global_auth_tok->sig);\r\nif (rc) {\r\nprintk(KERN_ERR "Error adding keysig; rc = [%d]\n", rc);\r\ngoto out;\r\n}\r\n}\r\nout:\r\nmutex_unlock(&mount_crypt_stat->global_auth_tok_list_mutex);\r\nmutex_unlock(&crypt_stat->keysig_list_mutex);\r\nreturn rc;\r\n}\r\nstatic void ecryptfs_set_default_crypt_stat_vals(\r\nstruct ecryptfs_crypt_stat *crypt_stat,\r\nstruct ecryptfs_mount_crypt_stat *mount_crypt_stat)\r\n{\r\necryptfs_copy_mount_wide_flags_to_inode_flags(crypt_stat,\r\nmount_crypt_stat);\r\necryptfs_set_default_sizes(crypt_stat);\r\nstrcpy(crypt_stat->cipher, ECRYPTFS_DEFAULT_CIPHER);\r\ncrypt_stat->key_size = ECRYPTFS_DEFAULT_KEY_BYTES;\r\ncrypt_stat->flags &= ~(ECRYPTFS_KEY_VALID);\r\ncrypt_stat->file_version = ECRYPTFS_FILE_VERSION;\r\ncrypt_stat->mount_crypt_stat = mount_crypt_stat;\r\n}\r\nint ecryptfs_new_file_context(struct inode *ecryptfs_inode)\r\n{\r\nstruct ecryptfs_crypt_stat *crypt_stat =\r\n&ecryptfs_inode_to_private(ecryptfs_inode)->crypt_stat;\r\nstruct ecryptfs_mount_crypt_stat *mount_crypt_stat =\r\n&ecryptfs_superblock_to_private(\r\necryptfs_inode->i_sb)->mount_crypt_stat;\r\nint cipher_name_len;\r\nint rc = 0;\r\necryptfs_set_default_crypt_stat_vals(crypt_stat, mount_crypt_stat);\r\ncrypt_stat->flags |= (ECRYPTFS_ENCRYPTED | ECRYPTFS_KEY_VALID);\r\necryptfs_copy_mount_wide_flags_to_inode_flags(crypt_stat,\r\nmount_crypt_stat);\r\nrc = ecryptfs_copy_mount_wide_sigs_to_inode_sigs(crypt_stat,\r\nmount_crypt_stat);\r\nif (rc) {\r\nprintk(KERN_ERR "Error attempting to copy mount-wide key sigs "\r\n"to the inode key sigs; rc = [%d]\n", rc);\r\ngoto out;\r\n}\r\ncipher_name_len =\r\nstrlen(mount_crypt_stat->global_default_cipher_name);\r\nmemcpy(crypt_stat->cipher,\r\nmount_crypt_stat->global_default_cipher_name,\r\ncipher_name_len);\r\ncrypt_stat->cipher[cipher_name_len] = '\0';\r\ncrypt_stat->key_size =\r\nmount_crypt_stat->global_default_cipher_key_size;\r\necryptfs_generate_new_key(crypt_stat);\r\nrc = ecryptfs_init_crypt_ctx(crypt_stat);\r\nif (rc)\r\necryptfs_printk(KERN_ERR, "Error initializing cryptographic "\r\n"context for cipher [%s]: rc = [%d]\n",\r\ncrypt_stat->cipher, rc);\r\nout:\r\nreturn rc;\r\n}\r\nstatic int ecryptfs_validate_marker(char *data)\r\n{\r\nu32 m_1, m_2;\r\nm_1 = get_unaligned_be32(data);\r\nm_2 = get_unaligned_be32(data + 4);\r\nif ((m_1 ^ MAGIC_ECRYPTFS_MARKER) == m_2)\r\nreturn 0;\r\necryptfs_printk(KERN_DEBUG, "m_1 = [0x%.8x]; m_2 = [0x%.8x]; "\r\n"MAGIC_ECRYPTFS_MARKER = [0x%.8x]\n", m_1, m_2,\r\nMAGIC_ECRYPTFS_MARKER);\r\necryptfs_printk(KERN_DEBUG, "(m_1 ^ MAGIC_ECRYPTFS_MARKER) = "\r\n"[0x%.8x]\n", (m_1 ^ MAGIC_ECRYPTFS_MARKER));\r\nreturn -EINVAL;\r\n}\r\nstatic int ecryptfs_process_flags(struct ecryptfs_crypt_stat *crypt_stat,\r\nchar *page_virt, int *bytes_read)\r\n{\r\nint rc = 0;\r\nint i;\r\nu32 flags;\r\nflags = get_unaligned_be32(page_virt);\r\nfor (i = 0; i < ((sizeof(ecryptfs_flag_map)\r\n/ sizeof(struct ecryptfs_flag_map_elem))); i++)\r\nif (flags & ecryptfs_flag_map[i].file_flag) {\r\ncrypt_stat->flags |= ecryptfs_flag_map[i].local_flag;\r\n} else\r\ncrypt_stat->flags &= ~(ecryptfs_flag_map[i].local_flag);\r\ncrypt_stat->file_version = ((flags >> 24) & 0xFF);\r\n(*bytes_read) = 4;\r\nreturn rc;\r\n}\r\nstatic void write_ecryptfs_marker(char *page_virt, size_t *written)\r\n{\r\nu32 m_1, m_2;\r\nget_random_bytes(&m_1, (MAGIC_ECRYPTFS_MARKER_SIZE_BYTES / 2));\r\nm_2 = (m_1 ^ MAGIC_ECRYPTFS_MARKER);\r\nput_unaligned_be32(m_1, page_virt);\r\npage_virt += (MAGIC_ECRYPTFS_MARKER_SIZE_BYTES / 2);\r\nput_unaligned_be32(m_2, page_virt);\r\n(*written) = MAGIC_ECRYPTFS_MARKER_SIZE_BYTES;\r\n}\r\nvoid ecryptfs_write_crypt_stat_flags(char *page_virt,\r\nstruct ecryptfs_crypt_stat *crypt_stat,\r\nsize_t *written)\r\n{\r\nu32 flags = 0;\r\nint i;\r\nfor (i = 0; i < ((sizeof(ecryptfs_flag_map)\r\n/ sizeof(struct ecryptfs_flag_map_elem))); i++)\r\nif (crypt_stat->flags & ecryptfs_flag_map[i].local_flag)\r\nflags |= ecryptfs_flag_map[i].file_flag;\r\nflags |= ((((u8)crypt_stat->file_version) << 24) & 0xFF000000);\r\nput_unaligned_be32(flags, page_virt);\r\n(*written) = 4;\r\n}\r\nu8 ecryptfs_code_for_cipher_string(char *cipher_name, size_t key_bytes)\r\n{\r\nint i;\r\nu8 code = 0;\r\nstruct ecryptfs_cipher_code_str_map_elem *map =\r\necryptfs_cipher_code_str_map;\r\nif (strcmp(cipher_name, "aes") == 0) {\r\nswitch (key_bytes) {\r\ncase 16:\r\ncode = RFC2440_CIPHER_AES_128;\r\nbreak;\r\ncase 24:\r\ncode = RFC2440_CIPHER_AES_192;\r\nbreak;\r\ncase 32:\r\ncode = RFC2440_CIPHER_AES_256;\r\n}\r\n} else {\r\nfor (i = 0; i < ARRAY_SIZE(ecryptfs_cipher_code_str_map); i++)\r\nif (strcmp(cipher_name, map[i].cipher_str) == 0) {\r\ncode = map[i].cipher_code;\r\nbreak;\r\n}\r\n}\r\nreturn code;\r\n}\r\nint ecryptfs_cipher_code_to_string(char *str, u8 cipher_code)\r\n{\r\nint rc = 0;\r\nint i;\r\nstr[0] = '\0';\r\nfor (i = 0; i < ARRAY_SIZE(ecryptfs_cipher_code_str_map); i++)\r\nif (cipher_code == ecryptfs_cipher_code_str_map[i].cipher_code)\r\nstrcpy(str, ecryptfs_cipher_code_str_map[i].cipher_str);\r\nif (str[0] == '\0') {\r\necryptfs_printk(KERN_WARNING, "Cipher code not recognized: "\r\n"[%d]\n", cipher_code);\r\nrc = -EINVAL;\r\n}\r\nreturn rc;\r\n}\r\nint ecryptfs_read_and_validate_header_region(struct inode *inode)\r\n{\r\nu8 file_size[ECRYPTFS_SIZE_AND_MARKER_BYTES];\r\nu8 *marker = file_size + ECRYPTFS_FILE_SIZE_BYTES;\r\nint rc;\r\nrc = ecryptfs_read_lower(file_size, 0, ECRYPTFS_SIZE_AND_MARKER_BYTES,\r\ninode);\r\nif (rc < ECRYPTFS_SIZE_AND_MARKER_BYTES)\r\nreturn rc >= 0 ? -EINVAL : rc;\r\nrc = ecryptfs_validate_marker(marker);\r\nif (!rc)\r\necryptfs_i_size_init(file_size, inode);\r\nreturn rc;\r\n}\r\nvoid\r\necryptfs_write_header_metadata(char *virt,\r\nstruct ecryptfs_crypt_stat *crypt_stat,\r\nsize_t *written)\r\n{\r\nu32 header_extent_size;\r\nu16 num_header_extents_at_front;\r\nheader_extent_size = (u32)crypt_stat->extent_size;\r\nnum_header_extents_at_front =\r\n(u16)(crypt_stat->metadata_size / crypt_stat->extent_size);\r\nput_unaligned_be32(header_extent_size, virt);\r\nvirt += 4;\r\nput_unaligned_be16(num_header_extents_at_front, virt);\r\n(*written) = 6;\r\n}\r\nstatic int ecryptfs_write_headers_virt(char *page_virt, size_t max,\r\nsize_t *size,\r\nstruct ecryptfs_crypt_stat *crypt_stat,\r\nstruct dentry *ecryptfs_dentry)\r\n{\r\nint rc;\r\nsize_t written;\r\nsize_t offset;\r\noffset = ECRYPTFS_FILE_SIZE_BYTES;\r\nwrite_ecryptfs_marker((page_virt + offset), &written);\r\noffset += written;\r\necryptfs_write_crypt_stat_flags((page_virt + offset), crypt_stat,\r\n&written);\r\noffset += written;\r\necryptfs_write_header_metadata((page_virt + offset), crypt_stat,\r\n&written);\r\noffset += written;\r\nrc = ecryptfs_generate_key_packet_set((page_virt + offset), crypt_stat,\r\necryptfs_dentry, &written,\r\nmax - offset);\r\nif (rc)\r\necryptfs_printk(KERN_WARNING, "Error generating key packet "\r\n"set; rc = [%d]\n", rc);\r\nif (size) {\r\noffset += written;\r\n*size = offset;\r\n}\r\nreturn rc;\r\n}\r\nstatic int\r\necryptfs_write_metadata_to_contents(struct inode *ecryptfs_inode,\r\nchar *virt, size_t virt_len)\r\n{\r\nint rc;\r\nrc = ecryptfs_write_lower(ecryptfs_inode, virt,\r\n0, virt_len);\r\nif (rc < 0)\r\nprintk(KERN_ERR "%s: Error attempting to write header "\r\n"information to lower file; rc = [%d]\n", __func__, rc);\r\nelse\r\nrc = 0;\r\nreturn rc;\r\n}\r\nstatic int\r\necryptfs_write_metadata_to_xattr(struct dentry *ecryptfs_dentry,\r\nchar *page_virt, size_t size)\r\n{\r\nint rc;\r\nrc = ecryptfs_setxattr(ecryptfs_dentry, ECRYPTFS_XATTR_NAME, page_virt,\r\nsize, 0);\r\nreturn rc;\r\n}\r\nstatic unsigned long ecryptfs_get_zeroed_pages(gfp_t gfp_mask,\r\nunsigned int order)\r\n{\r\nstruct page *page;\r\npage = alloc_pages(gfp_mask | __GFP_ZERO, order);\r\nif (page)\r\nreturn (unsigned long) page_address(page);\r\nreturn 0;\r\n}\r\nint ecryptfs_write_metadata(struct dentry *ecryptfs_dentry,\r\nstruct inode *ecryptfs_inode)\r\n{\r\nstruct ecryptfs_crypt_stat *crypt_stat =\r\n&ecryptfs_inode_to_private(ecryptfs_inode)->crypt_stat;\r\nunsigned int order;\r\nchar *virt;\r\nsize_t virt_len;\r\nsize_t size = 0;\r\nint rc = 0;\r\nif (likely(crypt_stat->flags & ECRYPTFS_ENCRYPTED)) {\r\nif (!(crypt_stat->flags & ECRYPTFS_KEY_VALID)) {\r\nprintk(KERN_ERR "Key is invalid; bailing out\n");\r\nrc = -EINVAL;\r\ngoto out;\r\n}\r\n} else {\r\nprintk(KERN_WARNING "%s: Encrypted flag not set\n",\r\n__func__);\r\nrc = -EINVAL;\r\ngoto out;\r\n}\r\nvirt_len = crypt_stat->metadata_size;\r\norder = get_order(virt_len);\r\nvirt = (char *)ecryptfs_get_zeroed_pages(GFP_KERNEL, order);\r\nif (!virt) {\r\nprintk(KERN_ERR "%s: Out of memory\n", __func__);\r\nrc = -ENOMEM;\r\ngoto out;\r\n}\r\nrc = ecryptfs_write_headers_virt(virt, virt_len, &size, crypt_stat,\r\necryptfs_dentry);\r\nif (unlikely(rc)) {\r\nprintk(KERN_ERR "%s: Error whilst writing headers; rc = [%d]\n",\r\n__func__, rc);\r\ngoto out_free;\r\n}\r\nif (crypt_stat->flags & ECRYPTFS_METADATA_IN_XATTR)\r\nrc = ecryptfs_write_metadata_to_xattr(ecryptfs_dentry, virt,\r\nsize);\r\nelse\r\nrc = ecryptfs_write_metadata_to_contents(ecryptfs_inode, virt,\r\nvirt_len);\r\nif (rc) {\r\nprintk(KERN_ERR "%s: Error writing metadata out to lower file; "\r\n"rc = [%d]\n", __func__, rc);\r\ngoto out_free;\r\n}\r\nout_free:\r\nfree_pages((unsigned long)virt, order);\r\nout:\r\nreturn rc;\r\n}\r\nstatic int parse_header_metadata(struct ecryptfs_crypt_stat *crypt_stat,\r\nchar *virt, int *bytes_read,\r\nint validate_header_size)\r\n{\r\nint rc = 0;\r\nu32 header_extent_size;\r\nu16 num_header_extents_at_front;\r\nheader_extent_size = get_unaligned_be32(virt);\r\nvirt += sizeof(__be32);\r\nnum_header_extents_at_front = get_unaligned_be16(virt);\r\ncrypt_stat->metadata_size = (((size_t)num_header_extents_at_front\r\n* (size_t)header_extent_size));\r\n(*bytes_read) = (sizeof(__be32) + sizeof(__be16));\r\nif ((validate_header_size == ECRYPTFS_VALIDATE_HEADER_SIZE)\r\n&& (crypt_stat->metadata_size\r\n< ECRYPTFS_MINIMUM_HEADER_EXTENT_SIZE)) {\r\nrc = -EINVAL;\r\nprintk(KERN_WARNING "Invalid header size: [%zd]\n",\r\ncrypt_stat->metadata_size);\r\n}\r\nreturn rc;\r\n}\r\nstatic void set_default_header_data(struct ecryptfs_crypt_stat *crypt_stat)\r\n{\r\ncrypt_stat->metadata_size = ECRYPTFS_MINIMUM_HEADER_EXTENT_SIZE;\r\n}\r\nvoid ecryptfs_i_size_init(const char *page_virt, struct inode *inode)\r\n{\r\nstruct ecryptfs_mount_crypt_stat *mount_crypt_stat;\r\nstruct ecryptfs_crypt_stat *crypt_stat;\r\nu64 file_size;\r\ncrypt_stat = &ecryptfs_inode_to_private(inode)->crypt_stat;\r\nmount_crypt_stat =\r\n&ecryptfs_superblock_to_private(inode->i_sb)->mount_crypt_stat;\r\nif (mount_crypt_stat->flags & ECRYPTFS_ENCRYPTED_VIEW_ENABLED) {\r\nfile_size = i_size_read(ecryptfs_inode_to_lower(inode));\r\nif (crypt_stat->flags & ECRYPTFS_METADATA_IN_XATTR)\r\nfile_size += crypt_stat->metadata_size;\r\n} else\r\nfile_size = get_unaligned_be64(page_virt);\r\ni_size_write(inode, (loff_t)file_size);\r\ncrypt_stat->flags |= ECRYPTFS_I_SIZE_INITIALIZED;\r\n}\r\nstatic int ecryptfs_read_headers_virt(char *page_virt,\r\nstruct ecryptfs_crypt_stat *crypt_stat,\r\nstruct dentry *ecryptfs_dentry,\r\nint validate_header_size)\r\n{\r\nint rc = 0;\r\nint offset;\r\nint bytes_read;\r\necryptfs_set_default_sizes(crypt_stat);\r\ncrypt_stat->mount_crypt_stat = &ecryptfs_superblock_to_private(\r\necryptfs_dentry->d_sb)->mount_crypt_stat;\r\noffset = ECRYPTFS_FILE_SIZE_BYTES;\r\nrc = ecryptfs_validate_marker(page_virt + offset);\r\nif (rc)\r\ngoto out;\r\nif (!(crypt_stat->flags & ECRYPTFS_I_SIZE_INITIALIZED))\r\necryptfs_i_size_init(page_virt, d_inode(ecryptfs_dentry));\r\noffset += MAGIC_ECRYPTFS_MARKER_SIZE_BYTES;\r\nrc = ecryptfs_process_flags(crypt_stat, (page_virt + offset),\r\n&bytes_read);\r\nif (rc) {\r\necryptfs_printk(KERN_WARNING, "Error processing flags\n");\r\ngoto out;\r\n}\r\nif (crypt_stat->file_version > ECRYPTFS_SUPPORTED_FILE_VERSION) {\r\necryptfs_printk(KERN_WARNING, "File version is [%d]; only "\r\n"file version [%d] is supported by this "\r\n"version of eCryptfs\n",\r\ncrypt_stat->file_version,\r\nECRYPTFS_SUPPORTED_FILE_VERSION);\r\nrc = -EINVAL;\r\ngoto out;\r\n}\r\noffset += bytes_read;\r\nif (crypt_stat->file_version >= 1) {\r\nrc = parse_header_metadata(crypt_stat, (page_virt + offset),\r\n&bytes_read, validate_header_size);\r\nif (rc) {\r\necryptfs_printk(KERN_WARNING, "Error reading header "\r\n"metadata; rc = [%d]\n", rc);\r\n}\r\noffset += bytes_read;\r\n} else\r\nset_default_header_data(crypt_stat);\r\nrc = ecryptfs_parse_packet_set(crypt_stat, (page_virt + offset),\r\necryptfs_dentry);\r\nout:\r\nreturn rc;\r\n}\r\nint ecryptfs_read_xattr_region(char *page_virt, struct inode *ecryptfs_inode)\r\n{\r\nstruct dentry *lower_dentry =\r\necryptfs_inode_to_private(ecryptfs_inode)->lower_file->f_path.dentry;\r\nssize_t size;\r\nint rc = 0;\r\nsize = ecryptfs_getxattr_lower(lower_dentry, ECRYPTFS_XATTR_NAME,\r\npage_virt, ECRYPTFS_DEFAULT_EXTENT_SIZE);\r\nif (size < 0) {\r\nif (unlikely(ecryptfs_verbosity > 0))\r\nprintk(KERN_INFO "Error attempting to read the [%s] "\r\n"xattr from the lower file; return value = "\r\n"[%zd]\n", ECRYPTFS_XATTR_NAME, size);\r\nrc = -EINVAL;\r\ngoto out;\r\n}\r\nout:\r\nreturn rc;\r\n}\r\nint ecryptfs_read_and_validate_xattr_region(struct dentry *dentry,\r\nstruct inode *inode)\r\n{\r\nu8 file_size[ECRYPTFS_SIZE_AND_MARKER_BYTES];\r\nu8 *marker = file_size + ECRYPTFS_FILE_SIZE_BYTES;\r\nint rc;\r\nrc = ecryptfs_getxattr_lower(ecryptfs_dentry_to_lower(dentry),\r\nECRYPTFS_XATTR_NAME, file_size,\r\nECRYPTFS_SIZE_AND_MARKER_BYTES);\r\nif (rc < ECRYPTFS_SIZE_AND_MARKER_BYTES)\r\nreturn rc >= 0 ? -EINVAL : rc;\r\nrc = ecryptfs_validate_marker(marker);\r\nif (!rc)\r\necryptfs_i_size_init(file_size, inode);\r\nreturn rc;\r\n}\r\nint ecryptfs_read_metadata(struct dentry *ecryptfs_dentry)\r\n{\r\nint rc;\r\nchar *page_virt;\r\nstruct inode *ecryptfs_inode = d_inode(ecryptfs_dentry);\r\nstruct ecryptfs_crypt_stat *crypt_stat =\r\n&ecryptfs_inode_to_private(ecryptfs_inode)->crypt_stat;\r\nstruct ecryptfs_mount_crypt_stat *mount_crypt_stat =\r\n&ecryptfs_superblock_to_private(\r\necryptfs_dentry->d_sb)->mount_crypt_stat;\r\necryptfs_copy_mount_wide_flags_to_inode_flags(crypt_stat,\r\nmount_crypt_stat);\r\npage_virt = kmem_cache_alloc(ecryptfs_header_cache, GFP_USER);\r\nif (!page_virt) {\r\nrc = -ENOMEM;\r\nprintk(KERN_ERR "%s: Unable to allocate page_virt\n",\r\n__func__);\r\ngoto out;\r\n}\r\nrc = ecryptfs_read_lower(page_virt, 0, crypt_stat->extent_size,\r\necryptfs_inode);\r\nif (rc >= 0)\r\nrc = ecryptfs_read_headers_virt(page_virt, crypt_stat,\r\necryptfs_dentry,\r\nECRYPTFS_VALIDATE_HEADER_SIZE);\r\nif (rc) {\r\nmemset(page_virt, 0, PAGE_CACHE_SIZE);\r\nrc = ecryptfs_read_xattr_region(page_virt, ecryptfs_inode);\r\nif (rc) {\r\nprintk(KERN_DEBUG "Valid eCryptfs headers not found in "\r\n"file header region or xattr region, inode %lu\n",\r\necryptfs_inode->i_ino);\r\nrc = -EINVAL;\r\ngoto out;\r\n}\r\nrc = ecryptfs_read_headers_virt(page_virt, crypt_stat,\r\necryptfs_dentry,\r\nECRYPTFS_DONT_VALIDATE_HEADER_SIZE);\r\nif (rc) {\r\nprintk(KERN_DEBUG "Valid eCryptfs headers not found in "\r\n"file xattr region either, inode %lu\n",\r\necryptfs_inode->i_ino);\r\nrc = -EINVAL;\r\n}\r\nif (crypt_stat->mount_crypt_stat->flags\r\n& ECRYPTFS_XATTR_METADATA_ENABLED) {\r\ncrypt_stat->flags |= ECRYPTFS_METADATA_IN_XATTR;\r\n} else {\r\nprintk(KERN_WARNING "Attempt to access file with "\r\n"crypto metadata only in the extended attribute "\r\n"region, but eCryptfs was mounted without "\r\n"xattr support enabled. eCryptfs will not treat "\r\n"this like an encrypted file, inode %lu\n",\r\necryptfs_inode->i_ino);\r\nrc = -EINVAL;\r\n}\r\n}\r\nout:\r\nif (page_virt) {\r\nmemset(page_virt, 0, PAGE_CACHE_SIZE);\r\nkmem_cache_free(ecryptfs_header_cache, page_virt);\r\n}\r\nreturn rc;\r\n}\r\nstatic int\r\necryptfs_encrypt_filename(struct ecryptfs_filename *filename,\r\nstruct ecryptfs_crypt_stat *crypt_stat,\r\nstruct ecryptfs_mount_crypt_stat *mount_crypt_stat)\r\n{\r\nint rc = 0;\r\nfilename->encrypted_filename = NULL;\r\nfilename->encrypted_filename_size = 0;\r\nif ((crypt_stat && (crypt_stat->flags & ECRYPTFS_ENCFN_USE_MOUNT_FNEK))\r\n|| (mount_crypt_stat && (mount_crypt_stat->flags\r\n& ECRYPTFS_GLOBAL_ENCFN_USE_MOUNT_FNEK))) {\r\nsize_t packet_size;\r\nsize_t remaining_bytes;\r\nrc = ecryptfs_write_tag_70_packet(\r\nNULL, NULL,\r\n&filename->encrypted_filename_size,\r\nmount_crypt_stat, NULL,\r\nfilename->filename_size);\r\nif (rc) {\r\nprintk(KERN_ERR "%s: Error attempting to get packet "\r\n"size for tag 72; rc = [%d]\n", __func__,\r\nrc);\r\nfilename->encrypted_filename_size = 0;\r\ngoto out;\r\n}\r\nfilename->encrypted_filename =\r\nkmalloc(filename->encrypted_filename_size, GFP_KERNEL);\r\nif (!filename->encrypted_filename) {\r\nprintk(KERN_ERR "%s: Out of memory whilst attempting "\r\n"to kmalloc [%zd] bytes\n", __func__,\r\nfilename->encrypted_filename_size);\r\nrc = -ENOMEM;\r\ngoto out;\r\n}\r\nremaining_bytes = filename->encrypted_filename_size;\r\nrc = ecryptfs_write_tag_70_packet(filename->encrypted_filename,\r\n&remaining_bytes,\r\n&packet_size,\r\nmount_crypt_stat,\r\nfilename->filename,\r\nfilename->filename_size);\r\nif (rc) {\r\nprintk(KERN_ERR "%s: Error attempting to generate "\r\n"tag 70 packet; rc = [%d]\n", __func__,\r\nrc);\r\nkfree(filename->encrypted_filename);\r\nfilename->encrypted_filename = NULL;\r\nfilename->encrypted_filename_size = 0;\r\ngoto out;\r\n}\r\nfilename->encrypted_filename_size = packet_size;\r\n} else {\r\nprintk(KERN_ERR "%s: No support for requested filename "\r\n"encryption method in this release\n", __func__);\r\nrc = -EOPNOTSUPP;\r\ngoto out;\r\n}\r\nout:\r\nreturn rc;\r\n}\r\nstatic int ecryptfs_copy_filename(char **copied_name, size_t *copied_name_size,\r\nconst char *name, size_t name_size)\r\n{\r\nint rc = 0;\r\n(*copied_name) = kmalloc((name_size + 1), GFP_KERNEL);\r\nif (!(*copied_name)) {\r\nrc = -ENOMEM;\r\ngoto out;\r\n}\r\nmemcpy((void *)(*copied_name), (void *)name, name_size);\r\n(*copied_name)[(name_size)] = '\0';\r\n(*copied_name_size) = name_size;\r\nout:\r\nreturn rc;\r\n}\r\nstatic int\r\necryptfs_process_key_cipher(struct crypto_blkcipher **key_tfm,\r\nchar *cipher_name, size_t *key_size)\r\n{\r\nchar dummy_key[ECRYPTFS_MAX_KEY_BYTES];\r\nchar *full_alg_name = NULL;\r\nint rc;\r\n*key_tfm = NULL;\r\nif (*key_size > ECRYPTFS_MAX_KEY_BYTES) {\r\nrc = -EINVAL;\r\nprintk(KERN_ERR "Requested key size is [%zd] bytes; maximum "\r\n"allowable is [%d]\n", *key_size, ECRYPTFS_MAX_KEY_BYTES);\r\ngoto out;\r\n}\r\nrc = ecryptfs_crypto_api_algify_cipher_name(&full_alg_name, cipher_name,\r\n"ecb");\r\nif (rc)\r\ngoto out;\r\n*key_tfm = crypto_alloc_blkcipher(full_alg_name, 0, CRYPTO_ALG_ASYNC);\r\nif (IS_ERR(*key_tfm)) {\r\nrc = PTR_ERR(*key_tfm);\r\nprintk(KERN_ERR "Unable to allocate crypto cipher with name "\r\n"[%s]; rc = [%d]\n", full_alg_name, rc);\r\ngoto out;\r\n}\r\ncrypto_blkcipher_set_flags(*key_tfm, CRYPTO_TFM_REQ_WEAK_KEY);\r\nif (*key_size == 0) {\r\nstruct blkcipher_alg *alg = crypto_blkcipher_alg(*key_tfm);\r\n*key_size = alg->max_keysize;\r\n}\r\nget_random_bytes(dummy_key, *key_size);\r\nrc = crypto_blkcipher_setkey(*key_tfm, dummy_key, *key_size);\r\nif (rc) {\r\nprintk(KERN_ERR "Error attempting to set key of size [%zd] for "\r\n"cipher [%s]; rc = [%d]\n", *key_size, full_alg_name,\r\nrc);\r\nrc = -EINVAL;\r\ngoto out;\r\n}\r\nout:\r\nkfree(full_alg_name);\r\nreturn rc;\r\n}\r\nint __init ecryptfs_init_crypto(void)\r\n{\r\nmutex_init(&key_tfm_list_mutex);\r\nINIT_LIST_HEAD(&key_tfm_list);\r\nreturn 0;\r\n}\r\nint ecryptfs_destroy_crypto(void)\r\n{\r\nstruct ecryptfs_key_tfm *key_tfm, *key_tfm_tmp;\r\nmutex_lock(&key_tfm_list_mutex);\r\nlist_for_each_entry_safe(key_tfm, key_tfm_tmp, &key_tfm_list,\r\nkey_tfm_list) {\r\nlist_del(&key_tfm->key_tfm_list);\r\nif (key_tfm->key_tfm)\r\ncrypto_free_blkcipher(key_tfm->key_tfm);\r\nkmem_cache_free(ecryptfs_key_tfm_cache, key_tfm);\r\n}\r\nmutex_unlock(&key_tfm_list_mutex);\r\nreturn 0;\r\n}\r\nint\r\necryptfs_add_new_key_tfm(struct ecryptfs_key_tfm **key_tfm, char *cipher_name,\r\nsize_t key_size)\r\n{\r\nstruct ecryptfs_key_tfm *tmp_tfm;\r\nint rc = 0;\r\nBUG_ON(!mutex_is_locked(&key_tfm_list_mutex));\r\ntmp_tfm = kmem_cache_alloc(ecryptfs_key_tfm_cache, GFP_KERNEL);\r\nif (key_tfm != NULL)\r\n(*key_tfm) = tmp_tfm;\r\nif (!tmp_tfm) {\r\nrc = -ENOMEM;\r\nprintk(KERN_ERR "Error attempting to allocate from "\r\n"ecryptfs_key_tfm_cache\n");\r\ngoto out;\r\n}\r\nmutex_init(&tmp_tfm->key_tfm_mutex);\r\nstrncpy(tmp_tfm->cipher_name, cipher_name,\r\nECRYPTFS_MAX_CIPHER_NAME_SIZE);\r\ntmp_tfm->cipher_name[ECRYPTFS_MAX_CIPHER_NAME_SIZE] = '\0';\r\ntmp_tfm->key_size = key_size;\r\nrc = ecryptfs_process_key_cipher(&tmp_tfm->key_tfm,\r\ntmp_tfm->cipher_name,\r\n&tmp_tfm->key_size);\r\nif (rc) {\r\nprintk(KERN_ERR "Error attempting to initialize key TFM "\r\n"cipher with name = [%s]; rc = [%d]\n",\r\ntmp_tfm->cipher_name, rc);\r\nkmem_cache_free(ecryptfs_key_tfm_cache, tmp_tfm);\r\nif (key_tfm != NULL)\r\n(*key_tfm) = NULL;\r\ngoto out;\r\n}\r\nlist_add(&tmp_tfm->key_tfm_list, &key_tfm_list);\r\nout:\r\nreturn rc;\r\n}\r\nint ecryptfs_tfm_exists(char *cipher_name, struct ecryptfs_key_tfm **key_tfm)\r\n{\r\nstruct ecryptfs_key_tfm *tmp_key_tfm;\r\nBUG_ON(!mutex_is_locked(&key_tfm_list_mutex));\r\nlist_for_each_entry(tmp_key_tfm, &key_tfm_list, key_tfm_list) {\r\nif (strcmp(tmp_key_tfm->cipher_name, cipher_name) == 0) {\r\nif (key_tfm)\r\n(*key_tfm) = tmp_key_tfm;\r\nreturn 1;\r\n}\r\n}\r\nif (key_tfm)\r\n(*key_tfm) = NULL;\r\nreturn 0;\r\n}\r\nint ecryptfs_get_tfm_and_mutex_for_cipher_name(struct crypto_blkcipher **tfm,\r\nstruct mutex **tfm_mutex,\r\nchar *cipher_name)\r\n{\r\nstruct ecryptfs_key_tfm *key_tfm;\r\nint rc = 0;\r\n(*tfm) = NULL;\r\n(*tfm_mutex) = NULL;\r\nmutex_lock(&key_tfm_list_mutex);\r\nif (!ecryptfs_tfm_exists(cipher_name, &key_tfm)) {\r\nrc = ecryptfs_add_new_key_tfm(&key_tfm, cipher_name, 0);\r\nif (rc) {\r\nprintk(KERN_ERR "Error adding new key_tfm to list; "\r\n"rc = [%d]\n", rc);\r\ngoto out;\r\n}\r\n}\r\n(*tfm) = key_tfm->key_tfm;\r\n(*tfm_mutex) = &key_tfm->key_tfm_mutex;\r\nout:\r\nmutex_unlock(&key_tfm_list_mutex);\r\nreturn rc;\r\n}\r\nstatic void ecryptfs_encode_for_filename(unsigned char *dst, size_t *dst_size,\r\nunsigned char *src, size_t src_size)\r\n{\r\nsize_t num_blocks;\r\nsize_t block_num = 0;\r\nsize_t dst_offset = 0;\r\nunsigned char last_block[3];\r\nif (src_size == 0) {\r\n(*dst_size) = 0;\r\ngoto out;\r\n}\r\nnum_blocks = (src_size / 3);\r\nif ((src_size % 3) == 0) {\r\nmemcpy(last_block, (&src[src_size - 3]), 3);\r\n} else {\r\nnum_blocks++;\r\nlast_block[2] = 0x00;\r\nswitch (src_size % 3) {\r\ncase 1:\r\nlast_block[0] = src[src_size - 1];\r\nlast_block[1] = 0x00;\r\nbreak;\r\ncase 2:\r\nlast_block[0] = src[src_size - 2];\r\nlast_block[1] = src[src_size - 1];\r\n}\r\n}\r\n(*dst_size) = (num_blocks * 4);\r\nif (!dst)\r\ngoto out;\r\nwhile (block_num < num_blocks) {\r\nunsigned char *src_block;\r\nunsigned char dst_block[4];\r\nif (block_num == (num_blocks - 1))\r\nsrc_block = last_block;\r\nelse\r\nsrc_block = &src[block_num * 3];\r\ndst_block[0] = ((src_block[0] >> 2) & 0x3F);\r\ndst_block[1] = (((src_block[0] << 4) & 0x30)\r\n| ((src_block[1] >> 4) & 0x0F));\r\ndst_block[2] = (((src_block[1] << 2) & 0x3C)\r\n| ((src_block[2] >> 6) & 0x03));\r\ndst_block[3] = (src_block[2] & 0x3F);\r\ndst[dst_offset++] = portable_filename_chars[dst_block[0]];\r\ndst[dst_offset++] = portable_filename_chars[dst_block[1]];\r\ndst[dst_offset++] = portable_filename_chars[dst_block[2]];\r\ndst[dst_offset++] = portable_filename_chars[dst_block[3]];\r\nblock_num++;\r\n}\r\nout:\r\nreturn;\r\n}\r\nstatic size_t ecryptfs_max_decoded_size(size_t encoded_size)\r\n{\r\nreturn ((encoded_size + 1) * 3) / 4;\r\n}\r\nstatic void\r\necryptfs_decode_from_filename(unsigned char *dst, size_t *dst_size,\r\nconst unsigned char *src, size_t src_size)\r\n{\r\nu8 current_bit_offset = 0;\r\nsize_t src_byte_offset = 0;\r\nsize_t dst_byte_offset = 0;\r\nif (dst == NULL) {\r\n(*dst_size) = ecryptfs_max_decoded_size(src_size);\r\ngoto out;\r\n}\r\nwhile (src_byte_offset < src_size) {\r\nunsigned char src_byte =\r\nfilename_rev_map[(int)src[src_byte_offset]];\r\nswitch (current_bit_offset) {\r\ncase 0:\r\ndst[dst_byte_offset] = (src_byte << 2);\r\ncurrent_bit_offset = 6;\r\nbreak;\r\ncase 6:\r\ndst[dst_byte_offset++] |= (src_byte >> 4);\r\ndst[dst_byte_offset] = ((src_byte & 0xF)\r\n<< 4);\r\ncurrent_bit_offset = 4;\r\nbreak;\r\ncase 4:\r\ndst[dst_byte_offset++] |= (src_byte >> 2);\r\ndst[dst_byte_offset] = (src_byte << 6);\r\ncurrent_bit_offset = 2;\r\nbreak;\r\ncase 2:\r\ndst[dst_byte_offset++] |= (src_byte);\r\ncurrent_bit_offset = 0;\r\nbreak;\r\n}\r\nsrc_byte_offset++;\r\n}\r\n(*dst_size) = dst_byte_offset;\r\nout:\r\nreturn;\r\n}\r\nint ecryptfs_encrypt_and_encode_filename(\r\nchar **encoded_name,\r\nsize_t *encoded_name_size,\r\nstruct ecryptfs_crypt_stat *crypt_stat,\r\nstruct ecryptfs_mount_crypt_stat *mount_crypt_stat,\r\nconst char *name, size_t name_size)\r\n{\r\nsize_t encoded_name_no_prefix_size;\r\nint rc = 0;\r\n(*encoded_name) = NULL;\r\n(*encoded_name_size) = 0;\r\nif ((crypt_stat && (crypt_stat->flags & ECRYPTFS_ENCRYPT_FILENAMES))\r\n|| (mount_crypt_stat && (mount_crypt_stat->flags\r\n& ECRYPTFS_GLOBAL_ENCRYPT_FILENAMES))) {\r\nstruct ecryptfs_filename *filename;\r\nfilename = kzalloc(sizeof(*filename), GFP_KERNEL);\r\nif (!filename) {\r\nprintk(KERN_ERR "%s: Out of memory whilst attempting "\r\n"to kzalloc [%zd] bytes\n", __func__,\r\nsizeof(*filename));\r\nrc = -ENOMEM;\r\ngoto out;\r\n}\r\nfilename->filename = (char *)name;\r\nfilename->filename_size = name_size;\r\nrc = ecryptfs_encrypt_filename(filename, crypt_stat,\r\nmount_crypt_stat);\r\nif (rc) {\r\nprintk(KERN_ERR "%s: Error attempting to encrypt "\r\n"filename; rc = [%d]\n", __func__, rc);\r\nkfree(filename);\r\ngoto out;\r\n}\r\necryptfs_encode_for_filename(\r\nNULL, &encoded_name_no_prefix_size,\r\nfilename->encrypted_filename,\r\nfilename->encrypted_filename_size);\r\nif ((crypt_stat && (crypt_stat->flags\r\n& ECRYPTFS_ENCFN_USE_MOUNT_FNEK))\r\n|| (mount_crypt_stat\r\n&& (mount_crypt_stat->flags\r\n& ECRYPTFS_GLOBAL_ENCFN_USE_MOUNT_FNEK)))\r\n(*encoded_name_size) =\r\n(ECRYPTFS_FNEK_ENCRYPTED_FILENAME_PREFIX_SIZE\r\n+ encoded_name_no_prefix_size);\r\nelse\r\n(*encoded_name_size) =\r\n(ECRYPTFS_FEK_ENCRYPTED_FILENAME_PREFIX_SIZE\r\n+ encoded_name_no_prefix_size);\r\n(*encoded_name) = kmalloc((*encoded_name_size) + 1, GFP_KERNEL);\r\nif (!(*encoded_name)) {\r\nprintk(KERN_ERR "%s: Out of memory whilst attempting "\r\n"to kzalloc [%zd] bytes\n", __func__,\r\n(*encoded_name_size));\r\nrc = -ENOMEM;\r\nkfree(filename->encrypted_filename);\r\nkfree(filename);\r\ngoto out;\r\n}\r\nif ((crypt_stat && (crypt_stat->flags\r\n& ECRYPTFS_ENCFN_USE_MOUNT_FNEK))\r\n|| (mount_crypt_stat\r\n&& (mount_crypt_stat->flags\r\n& ECRYPTFS_GLOBAL_ENCFN_USE_MOUNT_FNEK))) {\r\nmemcpy((*encoded_name),\r\nECRYPTFS_FNEK_ENCRYPTED_FILENAME_PREFIX,\r\nECRYPTFS_FNEK_ENCRYPTED_FILENAME_PREFIX_SIZE);\r\necryptfs_encode_for_filename(\r\n((*encoded_name)\r\n+ ECRYPTFS_FNEK_ENCRYPTED_FILENAME_PREFIX_SIZE),\r\n&encoded_name_no_prefix_size,\r\nfilename->encrypted_filename,\r\nfilename->encrypted_filename_size);\r\n(*encoded_name_size) =\r\n(ECRYPTFS_FNEK_ENCRYPTED_FILENAME_PREFIX_SIZE\r\n+ encoded_name_no_prefix_size);\r\n(*encoded_name)[(*encoded_name_size)] = '\0';\r\n} else {\r\nrc = -EOPNOTSUPP;\r\n}\r\nif (rc) {\r\nprintk(KERN_ERR "%s: Error attempting to encode "\r\n"encrypted filename; rc = [%d]\n", __func__,\r\nrc);\r\nkfree((*encoded_name));\r\n(*encoded_name) = NULL;\r\n(*encoded_name_size) = 0;\r\n}\r\nkfree(filename->encrypted_filename);\r\nkfree(filename);\r\n} else {\r\nrc = ecryptfs_copy_filename(encoded_name,\r\nencoded_name_size,\r\nname, name_size);\r\n}\r\nout:\r\nreturn rc;\r\n}\r\nint ecryptfs_decode_and_decrypt_filename(char **plaintext_name,\r\nsize_t *plaintext_name_size,\r\nstruct super_block *sb,\r\nconst char *name, size_t name_size)\r\n{\r\nstruct ecryptfs_mount_crypt_stat *mount_crypt_stat =\r\n&ecryptfs_superblock_to_private(sb)->mount_crypt_stat;\r\nchar *decoded_name;\r\nsize_t decoded_name_size;\r\nsize_t packet_size;\r\nint rc = 0;\r\nif ((mount_crypt_stat->flags & ECRYPTFS_GLOBAL_ENCRYPT_FILENAMES)\r\n&& !(mount_crypt_stat->flags & ECRYPTFS_ENCRYPTED_VIEW_ENABLED)\r\n&& (name_size > ECRYPTFS_FNEK_ENCRYPTED_FILENAME_PREFIX_SIZE)\r\n&& (strncmp(name, ECRYPTFS_FNEK_ENCRYPTED_FILENAME_PREFIX,\r\nECRYPTFS_FNEK_ENCRYPTED_FILENAME_PREFIX_SIZE) == 0)) {\r\nconst char *orig_name = name;\r\nsize_t orig_name_size = name_size;\r\nname += ECRYPTFS_FNEK_ENCRYPTED_FILENAME_PREFIX_SIZE;\r\nname_size -= ECRYPTFS_FNEK_ENCRYPTED_FILENAME_PREFIX_SIZE;\r\necryptfs_decode_from_filename(NULL, &decoded_name_size,\r\nname, name_size);\r\ndecoded_name = kmalloc(decoded_name_size, GFP_KERNEL);\r\nif (!decoded_name) {\r\nprintk(KERN_ERR "%s: Out of memory whilst attempting "\r\n"to kmalloc [%zd] bytes\n", __func__,\r\ndecoded_name_size);\r\nrc = -ENOMEM;\r\ngoto out;\r\n}\r\necryptfs_decode_from_filename(decoded_name, &decoded_name_size,\r\nname, name_size);\r\nrc = ecryptfs_parse_tag_70_packet(plaintext_name,\r\nplaintext_name_size,\r\n&packet_size,\r\nmount_crypt_stat,\r\ndecoded_name,\r\ndecoded_name_size);\r\nif (rc) {\r\nprintk(KERN_INFO "%s: Could not parse tag 70 packet "\r\n"from filename; copying through filename "\r\n"as-is\n", __func__);\r\nrc = ecryptfs_copy_filename(plaintext_name,\r\nplaintext_name_size,\r\norig_name, orig_name_size);\r\ngoto out_free;\r\n}\r\n} else {\r\nrc = ecryptfs_copy_filename(plaintext_name,\r\nplaintext_name_size,\r\nname, name_size);\r\ngoto out;\r\n}\r\nout_free:\r\nkfree(decoded_name);\r\nout:\r\nreturn rc;\r\n}\r\nint ecryptfs_set_f_namelen(long *namelen, long lower_namelen,\r\nstruct ecryptfs_mount_crypt_stat *mount_crypt_stat)\r\n{\r\nstruct blkcipher_desc desc;\r\nstruct mutex *tfm_mutex;\r\nsize_t cipher_blocksize;\r\nint rc;\r\nif (!(mount_crypt_stat->flags & ECRYPTFS_GLOBAL_ENCRYPT_FILENAMES)) {\r\n(*namelen) = lower_namelen;\r\nreturn 0;\r\n}\r\nrc = ecryptfs_get_tfm_and_mutex_for_cipher_name(&desc.tfm, &tfm_mutex,\r\nmount_crypt_stat->global_default_fn_cipher_name);\r\nif (unlikely(rc)) {\r\n(*namelen) = 0;\r\nreturn rc;\r\n}\r\nmutex_lock(tfm_mutex);\r\ncipher_blocksize = crypto_blkcipher_blocksize(desc.tfm);\r\nmutex_unlock(tfm_mutex);\r\nif (lower_namelen == NAME_MAX\r\n&& (cipher_blocksize == 8 || cipher_blocksize == 16)) {\r\n(*namelen) = ENC_NAME_MAX_BLOCKLEN_8_OR_16;\r\nreturn 0;\r\n}\r\n(*namelen) = lower_namelen;\r\n(*namelen) -= ECRYPTFS_FNEK_ENCRYPTED_FILENAME_PREFIX_SIZE;\r\n(*namelen) = ecryptfs_max_decoded_size(*namelen) - 3;\r\n(*namelen) -= ECRYPTFS_TAG_70_MAX_METADATA_SIZE;\r\n(*namelen) -= ECRYPTFS_FILENAME_MIN_RANDOM_PREPEND_BYTES;\r\n(*namelen) -= cipher_blocksize - 1;\r\nif ((*namelen) < 0)\r\n(*namelen) = 0;\r\nreturn 0;\r\n}
