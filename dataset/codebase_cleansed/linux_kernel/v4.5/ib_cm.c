static void rds_ib_set_protocol(struct rds_connection *conn, unsigned int version)\r\n{\r\nconn->c_version = version;\r\n}\r\nstatic void rds_ib_set_flow_control(struct rds_connection *conn, u32 credits)\r\n{\r\nstruct rds_ib_connection *ic = conn->c_transport_data;\r\nif (rds_ib_sysctl_flow_control && credits != 0) {\r\nic->i_flowctl = 1;\r\nrds_ib_send_add_credits(conn, credits);\r\n} else {\r\nic->i_flowctl = 0;\r\n}\r\n}\r\nstatic void\r\nrds_ib_tune_rnr(struct rds_ib_connection *ic, struct ib_qp_attr *attr)\r\n{\r\nint ret;\r\nattr->min_rnr_timer = IB_RNR_TIMER_000_32;\r\nret = ib_modify_qp(ic->i_cm_id->qp, attr, IB_QP_MIN_RNR_TIMER);\r\nif (ret)\r\nprintk(KERN_NOTICE "ib_modify_qp(IB_QP_MIN_RNR_TIMER): err=%d\n", -ret);\r\n}\r\nvoid rds_ib_cm_connect_complete(struct rds_connection *conn, struct rdma_cm_event *event)\r\n{\r\nconst struct rds_ib_connect_private *dp = NULL;\r\nstruct rds_ib_connection *ic = conn->c_transport_data;\r\nstruct ib_qp_attr qp_attr;\r\nint err;\r\nif (event->param.conn.private_data_len >= sizeof(*dp)) {\r\ndp = event->param.conn.private_data;\r\nif (dp->dp_protocol_major) {\r\nrds_ib_set_protocol(conn,\r\nRDS_PROTOCOL(dp->dp_protocol_major,\r\ndp->dp_protocol_minor));\r\nrds_ib_set_flow_control(conn, be32_to_cpu(dp->dp_credit));\r\n}\r\n}\r\nif (conn->c_version < RDS_PROTOCOL(3,1)) {\r\nprintk(KERN_NOTICE "RDS/IB: Connection to %pI4 version %u.%u failed,"\r\n" no longer supported\n",\r\n&conn->c_faddr,\r\nRDS_PROTOCOL_MAJOR(conn->c_version),\r\nRDS_PROTOCOL_MINOR(conn->c_version));\r\nrds_conn_destroy(conn);\r\nreturn;\r\n} else {\r\nprintk(KERN_NOTICE "RDS/IB: connected to %pI4 version %u.%u%s\n",\r\n&conn->c_faddr,\r\nRDS_PROTOCOL_MAJOR(conn->c_version),\r\nRDS_PROTOCOL_MINOR(conn->c_version),\r\nic->i_flowctl ? ", flow control" : "");\r\n}\r\nrds_ib_send_init_ring(ic);\r\nrds_ib_recv_init_ring(ic);\r\nrds_ib_recv_refill(conn, 1, GFP_KERNEL);\r\nrds_ib_tune_rnr(ic, &qp_attr);\r\nqp_attr.qp_state = IB_QPS_RTS;\r\nerr = ib_modify_qp(ic->i_cm_id->qp, &qp_attr, IB_QP_STATE);\r\nif (err)\r\nprintk(KERN_NOTICE "ib_modify_qp(IB_QP_STATE, RTS): err=%d\n", err);\r\nerr = rds_ib_update_ipaddr(ic->rds_ibdev, conn->c_laddr);\r\nif (err)\r\nprintk(KERN_ERR "rds_ib_update_ipaddr failed (%d)\n",\r\nerr);\r\nif (dp) {\r\n__be64 dp_ack_seq = get_unaligned(&dp->dp_ack_seq);\r\nif (dp_ack_seq)\r\nrds_send_drop_acked(conn, be64_to_cpu(dp_ack_seq),\r\nNULL);\r\n}\r\nrds_connect_complete(conn);\r\n}\r\nstatic void rds_ib_cm_fill_conn_param(struct rds_connection *conn,\r\nstruct rdma_conn_param *conn_param,\r\nstruct rds_ib_connect_private *dp,\r\nu32 protocol_version,\r\nu32 max_responder_resources,\r\nu32 max_initiator_depth)\r\n{\r\nstruct rds_ib_connection *ic = conn->c_transport_data;\r\nstruct rds_ib_device *rds_ibdev = ic->rds_ibdev;\r\nmemset(conn_param, 0, sizeof(struct rdma_conn_param));\r\nconn_param->responder_resources =\r\nmin_t(u32, rds_ibdev->max_responder_resources, max_responder_resources);\r\nconn_param->initiator_depth =\r\nmin_t(u32, rds_ibdev->max_initiator_depth, max_initiator_depth);\r\nconn_param->retry_count = min_t(unsigned int, rds_ib_retry_count, 7);\r\nconn_param->rnr_retry_count = 7;\r\nif (dp) {\r\nmemset(dp, 0, sizeof(*dp));\r\ndp->dp_saddr = conn->c_laddr;\r\ndp->dp_daddr = conn->c_faddr;\r\ndp->dp_protocol_major = RDS_PROTOCOL_MAJOR(protocol_version);\r\ndp->dp_protocol_minor = RDS_PROTOCOL_MINOR(protocol_version);\r\ndp->dp_protocol_minor_mask = cpu_to_be16(RDS_IB_SUPPORTED_PROTOCOLS);\r\ndp->dp_ack_seq = rds_ib_piggyb_ack(ic);\r\nif (ic->i_flowctl) {\r\nunsigned int credits;\r\ncredits = IB_GET_POST_CREDITS(atomic_read(&ic->i_credits));\r\ndp->dp_credit = cpu_to_be32(credits);\r\natomic_sub(IB_SET_POST_CREDITS(credits), &ic->i_credits);\r\n}\r\nconn_param->private_data = dp;\r\nconn_param->private_data_len = sizeof(*dp);\r\n}\r\n}\r\nstatic void rds_ib_cq_event_handler(struct ib_event *event, void *data)\r\n{\r\nrdsdebug("event %u (%s) data %p\n",\r\nevent->event, ib_event_msg(event->event), data);\r\n}\r\nstatic void rds_ib_cq_comp_handler_recv(struct ib_cq *cq, void *context)\r\n{\r\nstruct rds_connection *conn = context;\r\nstruct rds_ib_connection *ic = conn->c_transport_data;\r\nrdsdebug("conn %p cq %p\n", conn, cq);\r\nrds_ib_stats_inc(s_ib_evt_handler_call);\r\ntasklet_schedule(&ic->i_recv_tasklet);\r\n}\r\nstatic void poll_cq(struct rds_ib_connection *ic, struct ib_cq *cq,\r\nstruct ib_wc *wcs,\r\nstruct rds_ib_ack_state *ack_state)\r\n{\r\nint nr;\r\nint i;\r\nstruct ib_wc *wc;\r\nwhile ((nr = ib_poll_cq(cq, RDS_IB_WC_MAX, wcs)) > 0) {\r\nfor (i = 0; i < nr; i++) {\r\nwc = wcs + i;\r\nrdsdebug("wc wr_id 0x%llx status %u byte_len %u imm_data %u\n",\r\n(unsigned long long)wc->wr_id, wc->status,\r\nwc->byte_len, be32_to_cpu(wc->ex.imm_data));\r\nif (wc->wr_id & RDS_IB_SEND_OP)\r\nrds_ib_send_cqe_handler(ic, wc);\r\nelse\r\nrds_ib_recv_cqe_handler(ic, wc, ack_state);\r\n}\r\n}\r\n}\r\nstatic void rds_ib_tasklet_fn_send(unsigned long data)\r\n{\r\nstruct rds_ib_connection *ic = (struct rds_ib_connection *)data;\r\nstruct rds_connection *conn = ic->conn;\r\nstruct rds_ib_ack_state state;\r\nrds_ib_stats_inc(s_ib_tasklet_call);\r\nmemset(&state, 0, sizeof(state));\r\npoll_cq(ic, ic->i_send_cq, ic->i_send_wc, &state);\r\nib_req_notify_cq(ic->i_send_cq, IB_CQ_NEXT_COMP);\r\npoll_cq(ic, ic->i_send_cq, ic->i_send_wc, &state);\r\nif (rds_conn_up(conn) &&\r\n(!test_bit(RDS_LL_SEND_FULL, &conn->c_flags) ||\r\ntest_bit(0, &conn->c_map_queued)))\r\nrds_send_xmit(ic->conn);\r\n}\r\nstatic void rds_ib_tasklet_fn_recv(unsigned long data)\r\n{\r\nstruct rds_ib_connection *ic = (struct rds_ib_connection *)data;\r\nstruct rds_connection *conn = ic->conn;\r\nstruct rds_ib_device *rds_ibdev = ic->rds_ibdev;\r\nstruct rds_ib_ack_state state;\r\nif (!rds_ibdev)\r\nrds_conn_drop(conn);\r\nrds_ib_stats_inc(s_ib_tasklet_call);\r\nmemset(&state, 0, sizeof(state));\r\npoll_cq(ic, ic->i_recv_cq, ic->i_recv_wc, &state);\r\nib_req_notify_cq(ic->i_recv_cq, IB_CQ_SOLICITED);\r\npoll_cq(ic, ic->i_recv_cq, ic->i_recv_wc, &state);\r\nif (state.ack_next_valid)\r\nrds_ib_set_ack(ic, state.ack_next, state.ack_required);\r\nif (state.ack_recv_valid && state.ack_recv > ic->i_ack_recv) {\r\nrds_send_drop_acked(conn, state.ack_recv, NULL);\r\nic->i_ack_recv = state.ack_recv;\r\n}\r\nif (rds_conn_up(conn))\r\nrds_ib_attempt_ack(ic);\r\n}\r\nstatic void rds_ib_qp_event_handler(struct ib_event *event, void *data)\r\n{\r\nstruct rds_connection *conn = data;\r\nstruct rds_ib_connection *ic = conn->c_transport_data;\r\nrdsdebug("conn %p ic %p event %u (%s)\n", conn, ic, event->event,\r\nib_event_msg(event->event));\r\nswitch (event->event) {\r\ncase IB_EVENT_COMM_EST:\r\nrdma_notify(ic->i_cm_id, IB_EVENT_COMM_EST);\r\nbreak;\r\ndefault:\r\nrdsdebug("Fatal QP Event %u (%s) "\r\n"- connection %pI4->%pI4, reconnecting\n",\r\nevent->event, ib_event_msg(event->event),\r\n&conn->c_laddr, &conn->c_faddr);\r\nrds_conn_drop(conn);\r\nbreak;\r\n}\r\n}\r\nstatic void rds_ib_cq_comp_handler_send(struct ib_cq *cq, void *context)\r\n{\r\nstruct rds_connection *conn = context;\r\nstruct rds_ib_connection *ic = conn->c_transport_data;\r\nrdsdebug("conn %p cq %p\n", conn, cq);\r\nrds_ib_stats_inc(s_ib_evt_handler_call);\r\ntasklet_schedule(&ic->i_send_tasklet);\r\n}\r\nstatic int rds_ib_setup_qp(struct rds_connection *conn)\r\n{\r\nstruct rds_ib_connection *ic = conn->c_transport_data;\r\nstruct ib_device *dev = ic->i_cm_id->device;\r\nstruct ib_qp_init_attr attr;\r\nstruct ib_cq_init_attr cq_attr = {};\r\nstruct rds_ib_device *rds_ibdev;\r\nint ret;\r\nrds_ibdev = rds_ib_get_client_data(dev);\r\nif (!rds_ibdev)\r\nreturn -EOPNOTSUPP;\r\nrds_ib_add_conn(rds_ibdev, conn);\r\nif (rds_ibdev->max_wrs < ic->i_send_ring.w_nr + 1)\r\nrds_ib_ring_resize(&ic->i_send_ring, rds_ibdev->max_wrs - 1);\r\nif (rds_ibdev->max_wrs < ic->i_recv_ring.w_nr + 1)\r\nrds_ib_ring_resize(&ic->i_recv_ring, rds_ibdev->max_wrs - 1);\r\nic->i_pd = rds_ibdev->pd;\r\ncq_attr.cqe = ic->i_send_ring.w_nr + 1;\r\nic->i_send_cq = ib_create_cq(dev, rds_ib_cq_comp_handler_send,\r\nrds_ib_cq_event_handler, conn,\r\n&cq_attr);\r\nif (IS_ERR(ic->i_send_cq)) {\r\nret = PTR_ERR(ic->i_send_cq);\r\nic->i_send_cq = NULL;\r\nrdsdebug("ib_create_cq send failed: %d\n", ret);\r\ngoto out;\r\n}\r\ncq_attr.cqe = ic->i_recv_ring.w_nr;\r\nic->i_recv_cq = ib_create_cq(dev, rds_ib_cq_comp_handler_recv,\r\nrds_ib_cq_event_handler, conn,\r\n&cq_attr);\r\nif (IS_ERR(ic->i_recv_cq)) {\r\nret = PTR_ERR(ic->i_recv_cq);\r\nic->i_recv_cq = NULL;\r\nrdsdebug("ib_create_cq recv failed: %d\n", ret);\r\ngoto out;\r\n}\r\nret = ib_req_notify_cq(ic->i_send_cq, IB_CQ_NEXT_COMP);\r\nif (ret) {\r\nrdsdebug("ib_req_notify_cq send failed: %d\n", ret);\r\ngoto out;\r\n}\r\nret = ib_req_notify_cq(ic->i_recv_cq, IB_CQ_SOLICITED);\r\nif (ret) {\r\nrdsdebug("ib_req_notify_cq recv failed: %d\n", ret);\r\ngoto out;\r\n}\r\nmemset(&attr, 0, sizeof(attr));\r\nattr.event_handler = rds_ib_qp_event_handler;\r\nattr.qp_context = conn;\r\nattr.cap.max_send_wr = ic->i_send_ring.w_nr + 1;\r\nattr.cap.max_recv_wr = ic->i_recv_ring.w_nr + 1;\r\nattr.cap.max_send_sge = rds_ibdev->max_sge;\r\nattr.cap.max_recv_sge = RDS_IB_RECV_SGE;\r\nattr.sq_sig_type = IB_SIGNAL_REQ_WR;\r\nattr.qp_type = IB_QPT_RC;\r\nattr.send_cq = ic->i_send_cq;\r\nattr.recv_cq = ic->i_recv_cq;\r\nret = rdma_create_qp(ic->i_cm_id, ic->i_pd, &attr);\r\nif (ret) {\r\nrdsdebug("rdma_create_qp failed: %d\n", ret);\r\ngoto out;\r\n}\r\nic->i_send_hdrs = ib_dma_alloc_coherent(dev,\r\nic->i_send_ring.w_nr *\r\nsizeof(struct rds_header),\r\n&ic->i_send_hdrs_dma, GFP_KERNEL);\r\nif (!ic->i_send_hdrs) {\r\nret = -ENOMEM;\r\nrdsdebug("ib_dma_alloc_coherent send failed\n");\r\ngoto out;\r\n}\r\nic->i_recv_hdrs = ib_dma_alloc_coherent(dev,\r\nic->i_recv_ring.w_nr *\r\nsizeof(struct rds_header),\r\n&ic->i_recv_hdrs_dma, GFP_KERNEL);\r\nif (!ic->i_recv_hdrs) {\r\nret = -ENOMEM;\r\nrdsdebug("ib_dma_alloc_coherent recv failed\n");\r\ngoto out;\r\n}\r\nic->i_ack = ib_dma_alloc_coherent(dev, sizeof(struct rds_header),\r\n&ic->i_ack_dma, GFP_KERNEL);\r\nif (!ic->i_ack) {\r\nret = -ENOMEM;\r\nrdsdebug("ib_dma_alloc_coherent ack failed\n");\r\ngoto out;\r\n}\r\nic->i_sends = vzalloc_node(ic->i_send_ring.w_nr * sizeof(struct rds_ib_send_work),\r\nibdev_to_node(dev));\r\nif (!ic->i_sends) {\r\nret = -ENOMEM;\r\nrdsdebug("send allocation failed\n");\r\ngoto out;\r\n}\r\nic->i_recvs = vzalloc_node(ic->i_recv_ring.w_nr * sizeof(struct rds_ib_recv_work),\r\nibdev_to_node(dev));\r\nif (!ic->i_recvs) {\r\nret = -ENOMEM;\r\nrdsdebug("recv allocation failed\n");\r\ngoto out;\r\n}\r\nrds_ib_recv_init_ack(ic);\r\nrdsdebug("conn %p pd %p cq %p %p\n", conn, ic->i_pd,\r\nic->i_send_cq, ic->i_recv_cq);\r\nout:\r\nrds_ib_dev_put(rds_ibdev);\r\nreturn ret;\r\n}\r\nstatic u32 rds_ib_protocol_compatible(struct rdma_cm_event *event)\r\n{\r\nconst struct rds_ib_connect_private *dp = event->param.conn.private_data;\r\nu16 common;\r\nu32 version = 0;\r\nif (!event->param.conn.private_data_len) {\r\nprintk(KERN_NOTICE "RDS incoming connection has no private data, "\r\n"rejecting\n");\r\nreturn 0;\r\n}\r\nif (event->param.conn.private_data_len < sizeof (*dp) ||\r\ndp->dp_protocol_major == 0)\r\nreturn RDS_PROTOCOL_3_0;\r\ncommon = be16_to_cpu(dp->dp_protocol_minor_mask) & RDS_IB_SUPPORTED_PROTOCOLS;\r\nif (dp->dp_protocol_major == 3 && common) {\r\nversion = RDS_PROTOCOL_3_0;\r\nwhile ((common >>= 1) != 0)\r\nversion++;\r\n} else\r\nprintk_ratelimited(KERN_NOTICE "RDS: Connection from %pI4 using incompatible protocol version %u.%u\n",\r\n&dp->dp_saddr,\r\ndp->dp_protocol_major,\r\ndp->dp_protocol_minor);\r\nreturn version;\r\n}\r\nint rds_ib_cm_handle_connect(struct rdma_cm_id *cm_id,\r\nstruct rdma_cm_event *event)\r\n{\r\n__be64 lguid = cm_id->route.path_rec->sgid.global.interface_id;\r\n__be64 fguid = cm_id->route.path_rec->dgid.global.interface_id;\r\nconst struct rds_ib_connect_private *dp = event->param.conn.private_data;\r\nstruct rds_ib_connect_private dp_rep;\r\nstruct rds_connection *conn = NULL;\r\nstruct rds_ib_connection *ic = NULL;\r\nstruct rdma_conn_param conn_param;\r\nu32 version;\r\nint err = 1, destroy = 1;\r\nversion = rds_ib_protocol_compatible(event);\r\nif (!version)\r\ngoto out;\r\nrdsdebug("saddr %pI4 daddr %pI4 RDSv%u.%u lguid 0x%llx fguid "\r\n"0x%llx\n", &dp->dp_saddr, &dp->dp_daddr,\r\nRDS_PROTOCOL_MAJOR(version), RDS_PROTOCOL_MINOR(version),\r\n(unsigned long long)be64_to_cpu(lguid),\r\n(unsigned long long)be64_to_cpu(fguid));\r\nconn = rds_conn_create(&init_net, dp->dp_daddr, dp->dp_saddr,\r\n&rds_ib_transport, GFP_KERNEL);\r\nif (IS_ERR(conn)) {\r\nrdsdebug("rds_conn_create failed (%ld)\n", PTR_ERR(conn));\r\nconn = NULL;\r\ngoto out;\r\n}\r\nmutex_lock(&conn->c_cm_lock);\r\nif (!rds_conn_transition(conn, RDS_CONN_DOWN, RDS_CONN_CONNECTING)) {\r\nif (rds_conn_state(conn) == RDS_CONN_UP) {\r\nrdsdebug("incoming connect while connecting\n");\r\nrds_conn_drop(conn);\r\nrds_ib_stats_inc(s_ib_listen_closed_stale);\r\n} else\r\nif (rds_conn_state(conn) == RDS_CONN_CONNECTING) {\r\nrds_ib_stats_inc(s_ib_connect_raced);\r\n}\r\ngoto out;\r\n}\r\nic = conn->c_transport_data;\r\nrds_ib_set_protocol(conn, version);\r\nrds_ib_set_flow_control(conn, be32_to_cpu(dp->dp_credit));\r\nif (dp->dp_ack_seq)\r\nrds_send_drop_acked(conn, be64_to_cpu(dp->dp_ack_seq), NULL);\r\nBUG_ON(cm_id->context);\r\nBUG_ON(ic->i_cm_id);\r\nic->i_cm_id = cm_id;\r\ncm_id->context = conn;\r\ndestroy = 0;\r\nerr = rds_ib_setup_qp(conn);\r\nif (err) {\r\nrds_ib_conn_error(conn, "rds_ib_setup_qp failed (%d)\n", err);\r\ngoto out;\r\n}\r\nrds_ib_cm_fill_conn_param(conn, &conn_param, &dp_rep, version,\r\nevent->param.conn.responder_resources,\r\nevent->param.conn.initiator_depth);\r\nerr = rdma_accept(cm_id, &conn_param);\r\nif (err)\r\nrds_ib_conn_error(conn, "rdma_accept failed (%d)\n", err);\r\nout:\r\nif (conn)\r\nmutex_unlock(&conn->c_cm_lock);\r\nif (err)\r\nrdma_reject(cm_id, NULL, 0);\r\nreturn destroy;\r\n}\r\nint rds_ib_cm_initiate_connect(struct rdma_cm_id *cm_id)\r\n{\r\nstruct rds_connection *conn = cm_id->context;\r\nstruct rds_ib_connection *ic = conn->c_transport_data;\r\nstruct rdma_conn_param conn_param;\r\nstruct rds_ib_connect_private dp;\r\nint ret;\r\nrds_ib_set_protocol(conn, RDS_PROTOCOL_3_0);\r\nic->i_flowctl = rds_ib_sysctl_flow_control;\r\nret = rds_ib_setup_qp(conn);\r\nif (ret) {\r\nrds_ib_conn_error(conn, "rds_ib_setup_qp failed (%d)\n", ret);\r\ngoto out;\r\n}\r\nrds_ib_cm_fill_conn_param(conn, &conn_param, &dp, RDS_PROTOCOL_VERSION,\r\nUINT_MAX, UINT_MAX);\r\nret = rdma_connect(cm_id, &conn_param);\r\nif (ret)\r\nrds_ib_conn_error(conn, "rdma_connect failed (%d)\n", ret);\r\nout:\r\nif (ret) {\r\nif (ic->i_cm_id == cm_id)\r\nret = 0;\r\n}\r\nreturn ret;\r\n}\r\nint rds_ib_conn_connect(struct rds_connection *conn)\r\n{\r\nstruct rds_ib_connection *ic = conn->c_transport_data;\r\nstruct sockaddr_in src, dest;\r\nint ret;\r\nic->i_cm_id = rdma_create_id(&init_net, rds_rdma_cm_event_handler, conn,\r\nRDMA_PS_TCP, IB_QPT_RC);\r\nif (IS_ERR(ic->i_cm_id)) {\r\nret = PTR_ERR(ic->i_cm_id);\r\nic->i_cm_id = NULL;\r\nrdsdebug("rdma_create_id() failed: %d\n", ret);\r\ngoto out;\r\n}\r\nrdsdebug("created cm id %p for conn %p\n", ic->i_cm_id, conn);\r\nsrc.sin_family = AF_INET;\r\nsrc.sin_addr.s_addr = (__force u32)conn->c_laddr;\r\nsrc.sin_port = (__force u16)htons(0);\r\ndest.sin_family = AF_INET;\r\ndest.sin_addr.s_addr = (__force u32)conn->c_faddr;\r\ndest.sin_port = (__force u16)htons(RDS_PORT);\r\nret = rdma_resolve_addr(ic->i_cm_id, (struct sockaddr *)&src,\r\n(struct sockaddr *)&dest,\r\nRDS_RDMA_RESOLVE_TIMEOUT_MS);\r\nif (ret) {\r\nrdsdebug("addr resolve failed for cm id %p: %d\n", ic->i_cm_id,\r\nret);\r\nrdma_destroy_id(ic->i_cm_id);\r\nic->i_cm_id = NULL;\r\n}\r\nout:\r\nreturn ret;\r\n}\r\nvoid rds_ib_conn_shutdown(struct rds_connection *conn)\r\n{\r\nstruct rds_ib_connection *ic = conn->c_transport_data;\r\nint err = 0;\r\nrdsdebug("cm %p pd %p cq %p %p qp %p\n", ic->i_cm_id,\r\nic->i_pd, ic->i_send_cq, ic->i_recv_cq,\r\nic->i_cm_id ? ic->i_cm_id->qp : NULL);\r\nif (ic->i_cm_id) {\r\nstruct ib_device *dev = ic->i_cm_id->device;\r\nrdsdebug("disconnecting cm %p\n", ic->i_cm_id);\r\nerr = rdma_disconnect(ic->i_cm_id);\r\nif (err) {\r\nrdsdebug("failed to disconnect, cm: %p err %d\n",\r\nic->i_cm_id, err);\r\n}\r\nwait_event(rds_ib_ring_empty_wait,\r\nrds_ib_ring_empty(&ic->i_recv_ring) &&\r\n(atomic_read(&ic->i_signaled_sends) == 0));\r\ntasklet_kill(&ic->i_send_tasklet);\r\ntasklet_kill(&ic->i_recv_tasklet);\r\nif (ic->i_cm_id->qp)\r\nrdma_destroy_qp(ic->i_cm_id);\r\nif (ic->i_send_cq)\r\nib_destroy_cq(ic->i_send_cq);\r\nif (ic->i_recv_cq)\r\nib_destroy_cq(ic->i_recv_cq);\r\nif (ic->i_send_hdrs)\r\nib_dma_free_coherent(dev,\r\nic->i_send_ring.w_nr *\r\nsizeof(struct rds_header),\r\nic->i_send_hdrs,\r\nic->i_send_hdrs_dma);\r\nif (ic->i_recv_hdrs)\r\nib_dma_free_coherent(dev,\r\nic->i_recv_ring.w_nr *\r\nsizeof(struct rds_header),\r\nic->i_recv_hdrs,\r\nic->i_recv_hdrs_dma);\r\nif (ic->i_ack)\r\nib_dma_free_coherent(dev, sizeof(struct rds_header),\r\nic->i_ack, ic->i_ack_dma);\r\nif (ic->i_sends)\r\nrds_ib_send_clear_ring(ic);\r\nif (ic->i_recvs)\r\nrds_ib_recv_clear_ring(ic);\r\nrdma_destroy_id(ic->i_cm_id);\r\nif (ic->rds_ibdev)\r\nrds_ib_remove_conn(ic->rds_ibdev, conn);\r\nic->i_cm_id = NULL;\r\nic->i_pd = NULL;\r\nic->i_send_cq = NULL;\r\nic->i_recv_cq = NULL;\r\nic->i_send_hdrs = NULL;\r\nic->i_recv_hdrs = NULL;\r\nic->i_ack = NULL;\r\n}\r\nBUG_ON(ic->rds_ibdev);\r\nif (ic->i_data_op) {\r\nstruct rds_message *rm;\r\nrm = container_of(ic->i_data_op, struct rds_message, data);\r\nrds_message_put(rm);\r\nic->i_data_op = NULL;\r\n}\r\nclear_bit(IB_ACK_IN_FLIGHT, &ic->i_ack_flags);\r\n#ifdef KERNEL_HAS_ATOMIC64\r\natomic64_set(&ic->i_ack_next, 0);\r\n#else\r\nic->i_ack_next = 0;\r\n#endif\r\nic->i_ack_recv = 0;\r\nic->i_flowctl = 0;\r\natomic_set(&ic->i_credits, 0);\r\nrds_ib_ring_init(&ic->i_send_ring, rds_ib_sysctl_max_send_wr);\r\nrds_ib_ring_init(&ic->i_recv_ring, rds_ib_sysctl_max_recv_wr);\r\nif (ic->i_ibinc) {\r\nrds_inc_put(&ic->i_ibinc->ii_inc);\r\nic->i_ibinc = NULL;\r\n}\r\nvfree(ic->i_sends);\r\nic->i_sends = NULL;\r\nvfree(ic->i_recvs);\r\nic->i_recvs = NULL;\r\n}\r\nint rds_ib_conn_alloc(struct rds_connection *conn, gfp_t gfp)\r\n{\r\nstruct rds_ib_connection *ic;\r\nunsigned long flags;\r\nint ret;\r\nic = kzalloc(sizeof(struct rds_ib_connection), gfp);\r\nif (!ic)\r\nreturn -ENOMEM;\r\nret = rds_ib_recv_alloc_caches(ic);\r\nif (ret) {\r\nkfree(ic);\r\nreturn ret;\r\n}\r\nINIT_LIST_HEAD(&ic->ib_node);\r\ntasklet_init(&ic->i_send_tasklet, rds_ib_tasklet_fn_send,\r\n(unsigned long)ic);\r\ntasklet_init(&ic->i_recv_tasklet, rds_ib_tasklet_fn_recv,\r\n(unsigned long)ic);\r\nmutex_init(&ic->i_recv_mutex);\r\n#ifndef KERNEL_HAS_ATOMIC64\r\nspin_lock_init(&ic->i_ack_lock);\r\n#endif\r\natomic_set(&ic->i_signaled_sends, 0);\r\nrds_ib_ring_init(&ic->i_send_ring, rds_ib_sysctl_max_send_wr);\r\nrds_ib_ring_init(&ic->i_recv_ring, rds_ib_sysctl_max_recv_wr);\r\nic->conn = conn;\r\nconn->c_transport_data = ic;\r\nspin_lock_irqsave(&ib_nodev_conns_lock, flags);\r\nlist_add_tail(&ic->ib_node, &ib_nodev_conns);\r\nspin_unlock_irqrestore(&ib_nodev_conns_lock, flags);\r\nrdsdebug("conn %p conn ic %p\n", conn, conn->c_transport_data);\r\nreturn 0;\r\n}\r\nvoid rds_ib_conn_free(void *arg)\r\n{\r\nstruct rds_ib_connection *ic = arg;\r\nspinlock_t *lock_ptr;\r\nrdsdebug("ic %p\n", ic);\r\nlock_ptr = ic->rds_ibdev ? &ic->rds_ibdev->spinlock : &ib_nodev_conns_lock;\r\nspin_lock_irq(lock_ptr);\r\nlist_del(&ic->ib_node);\r\nspin_unlock_irq(lock_ptr);\r\nrds_ib_recv_free_caches(ic);\r\nkfree(ic);\r\n}\r\nvoid\r\n__rds_ib_conn_error(struct rds_connection *conn, const char *fmt, ...)\r\n{\r\nva_list ap;\r\nrds_conn_drop(conn);\r\nva_start(ap, fmt);\r\nvprintk(fmt, ap);\r\nva_end(ap);\r\n}
