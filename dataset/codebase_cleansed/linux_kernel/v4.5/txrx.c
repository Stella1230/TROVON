static inline int get_rssi0(struct wcn36xx_rx_bd *bd)\r\n{\r\nreturn 100 - ((bd->phy_stat0 >> 24) & 0xff);\r\n}\r\nint wcn36xx_rx_skb(struct wcn36xx *wcn, struct sk_buff *skb)\r\n{\r\nstruct ieee80211_rx_status status;\r\nstruct ieee80211_hdr *hdr;\r\nstruct wcn36xx_rx_bd *bd;\r\nu16 fc, sn;\r\nmemset(&status, 0, sizeof(status));\r\nbd = (struct wcn36xx_rx_bd *)skb->data;\r\nbuff_to_be((u32 *)bd, sizeof(*bd)/sizeof(u32));\r\nwcn36xx_dbg_dump(WCN36XX_DBG_RX_DUMP,\r\n"BD <<< ", (char *)bd,\r\nsizeof(struct wcn36xx_rx_bd));\r\nskb_put(skb, bd->pdu.mpdu_header_off + bd->pdu.mpdu_len);\r\nskb_pull(skb, bd->pdu.mpdu_header_off);\r\nstatus.mactime = 10;\r\nstatus.freq = WCN36XX_CENTER_FREQ(wcn);\r\nstatus.band = WCN36XX_BAND(wcn);\r\nstatus.signal = -get_rssi0(bd);\r\nstatus.antenna = 1;\r\nstatus.rate_idx = 1;\r\nstatus.flag = 0;\r\nstatus.rx_flags = 0;\r\nstatus.flag |= RX_FLAG_IV_STRIPPED |\r\nRX_FLAG_MMIC_STRIPPED |\r\nRX_FLAG_DECRYPTED;\r\nwcn36xx_dbg(WCN36XX_DBG_RX, "status.flags=%x\n", status.flag);\r\nmemcpy(IEEE80211_SKB_RXCB(skb), &status, sizeof(status));\r\nhdr = (struct ieee80211_hdr *) skb->data;\r\nfc = __le16_to_cpu(hdr->frame_control);\r\nsn = IEEE80211_SEQ_TO_SN(__le16_to_cpu(hdr->seq_ctrl));\r\nif (ieee80211_is_beacon(hdr->frame_control)) {\r\nwcn36xx_dbg(WCN36XX_DBG_BEACON, "beacon skb %p len %d fc %04x sn %d\n",\r\nskb, skb->len, fc, sn);\r\nwcn36xx_dbg_dump(WCN36XX_DBG_BEACON_DUMP, "SKB <<< ",\r\n(char *)skb->data, skb->len);\r\n} else {\r\nwcn36xx_dbg(WCN36XX_DBG_RX, "rx skb %p len %d fc %04x sn %d\n",\r\nskb, skb->len, fc, sn);\r\nwcn36xx_dbg_dump(WCN36XX_DBG_RX_DUMP, "SKB <<< ",\r\n(char *)skb->data, skb->len);\r\n}\r\nieee80211_rx_irqsafe(wcn->hw, skb);\r\nreturn 0;\r\n}\r\nstatic void wcn36xx_set_tx_pdu(struct wcn36xx_tx_bd *bd,\r\nu32 mpdu_header_len,\r\nu32 len,\r\nu16 tid)\r\n{\r\nbd->pdu.mpdu_header_len = mpdu_header_len;\r\nbd->pdu.mpdu_header_off = sizeof(*bd);\r\nbd->pdu.mpdu_data_off = bd->pdu.mpdu_header_len +\r\nbd->pdu.mpdu_header_off;\r\nbd->pdu.mpdu_len = len;\r\nbd->pdu.tid = tid;\r\nbd->pdu.bd_ssn = WCN36XX_TXBD_SSN_FILL_DPU_QOS;\r\n}\r\nstatic inline struct wcn36xx_vif *get_vif_by_addr(struct wcn36xx *wcn,\r\nu8 *addr)\r\n{\r\nstruct wcn36xx_vif *vif_priv = NULL;\r\nstruct ieee80211_vif *vif = NULL;\r\nlist_for_each_entry(vif_priv, &wcn->vif_list, list) {\r\nvif = container_of((void *)vif_priv,\r\nstruct ieee80211_vif,\r\ndrv_priv);\r\nif (memcmp(vif->addr, addr, ETH_ALEN) == 0)\r\nreturn vif_priv;\r\n}\r\nwcn36xx_warn("vif %pM not found\n", addr);\r\nreturn NULL;\r\n}\r\nstatic void wcn36xx_tx_start_ampdu(struct wcn36xx *wcn,\r\nstruct wcn36xx_sta *sta_priv,\r\nstruct sk_buff *skb)\r\n{\r\nstruct ieee80211_hdr *hdr = (struct ieee80211_hdr *)skb->data;\r\nstruct ieee80211_sta *sta;\r\nu8 *qc, tid;\r\nif (!conf_is_ht(&wcn->hw->conf))\r\nreturn;\r\nsta = wcn36xx_priv_to_sta(sta_priv);\r\nif (WARN_ON(!ieee80211_is_data_qos(hdr->frame_control)))\r\nreturn;\r\nif (skb_get_queue_mapping(skb) == IEEE80211_AC_VO)\r\nreturn;\r\nqc = ieee80211_get_qos_ctl(hdr);\r\ntid = qc[0] & IEEE80211_QOS_CTL_TID_MASK;\r\nspin_lock(&sta_priv->ampdu_lock);\r\nif (sta_priv->ampdu_state[tid] != WCN36XX_AMPDU_NONE)\r\ngoto out_unlock;\r\nif (sta_priv->non_agg_frame_ct++ >= WCN36XX_AMPDU_START_THRESH) {\r\nsta_priv->ampdu_state[tid] = WCN36XX_AMPDU_START;\r\nsta_priv->non_agg_frame_ct = 0;\r\nieee80211_start_tx_ba_session(sta, tid, 0);\r\n}\r\nout_unlock:\r\nspin_unlock(&sta_priv->ampdu_lock);\r\n}\r\nstatic void wcn36xx_set_tx_data(struct wcn36xx_tx_bd *bd,\r\nstruct wcn36xx *wcn,\r\nstruct wcn36xx_vif **vif_priv,\r\nstruct wcn36xx_sta *sta_priv,\r\nstruct sk_buff *skb,\r\nbool bcast)\r\n{\r\nstruct ieee80211_hdr *hdr = (struct ieee80211_hdr *)skb->data;\r\nstruct ieee80211_vif *vif = NULL;\r\nstruct wcn36xx_vif *__vif_priv = NULL;\r\nbool is_data_qos;\r\nbd->bd_rate = WCN36XX_BD_RATE_DATA;\r\nif (sta_priv) {\r\n__vif_priv = sta_priv->vif;\r\nvif = container_of((void *)__vif_priv,\r\nstruct ieee80211_vif,\r\ndrv_priv);\r\nbd->dpu_sign = sta_priv->ucast_dpu_sign;\r\nif (vif->type == NL80211_IFTYPE_STATION) {\r\nbd->sta_index = sta_priv->bss_sta_index;\r\nbd->dpu_desc_idx = sta_priv->bss_dpu_desc_index;\r\n} else if (vif->type == NL80211_IFTYPE_AP ||\r\nvif->type == NL80211_IFTYPE_ADHOC ||\r\nvif->type == NL80211_IFTYPE_MESH_POINT) {\r\nbd->sta_index = sta_priv->sta_index;\r\nbd->dpu_desc_idx = sta_priv->dpu_desc_index;\r\n}\r\n} else {\r\n__vif_priv = get_vif_by_addr(wcn, hdr->addr2);\r\nbd->sta_index = __vif_priv->self_sta_index;\r\nbd->dpu_desc_idx = __vif_priv->self_dpu_desc_index;\r\nbd->dpu_sign = __vif_priv->self_ucast_dpu_sign;\r\n}\r\nif (ieee80211_is_nullfunc(hdr->frame_control) ||\r\n(sta_priv && !sta_priv->is_data_encrypted))\r\nbd->dpu_ne = 1;\r\nif (bcast) {\r\nbd->ub = 1;\r\nbd->ack_policy = 1;\r\n}\r\n*vif_priv = __vif_priv;\r\nis_data_qos = ieee80211_is_data_qos(hdr->frame_control);\r\nwcn36xx_set_tx_pdu(bd,\r\nis_data_qos ?\r\nsizeof(struct ieee80211_qos_hdr) :\r\nsizeof(struct ieee80211_hdr_3addr),\r\nskb->len, sta_priv ? sta_priv->tid : 0);\r\nif (sta_priv && is_data_qos)\r\nwcn36xx_tx_start_ampdu(wcn, sta_priv, skb);\r\n}\r\nstatic void wcn36xx_set_tx_mgmt(struct wcn36xx_tx_bd *bd,\r\nstruct wcn36xx *wcn,\r\nstruct wcn36xx_vif **vif_priv,\r\nstruct sk_buff *skb,\r\nbool bcast)\r\n{\r\nstruct ieee80211_hdr *hdr = (struct ieee80211_hdr *)skb->data;\r\nstruct wcn36xx_vif *__vif_priv =\r\nget_vif_by_addr(wcn, hdr->addr2);\r\nbd->sta_index = __vif_priv->self_sta_index;\r\nbd->dpu_desc_idx = __vif_priv->self_dpu_desc_index;\r\nbd->dpu_ne = 1;\r\nif (ieee80211_is_mgmt(hdr->frame_control))\r\nbd->bd_rate = (WCN36XX_BAND(wcn) == IEEE80211_BAND_5GHZ) ?\r\nWCN36XX_BD_RATE_CTRL :\r\nWCN36XX_BD_RATE_MGMT;\r\nelse if (ieee80211_is_ctl(hdr->frame_control))\r\nbd->bd_rate = WCN36XX_BD_RATE_CTRL;\r\nelse\r\nwcn36xx_warn("frame control type unknown\n");\r\nif (__vif_priv->is_joining &&\r\nieee80211_is_probe_req(hdr->frame_control))\r\nbcast = false;\r\nif (bcast) {\r\nbd->ub = 1;\r\nbd->ack_policy = 1;\r\nbd->queue_id = WCN36XX_TX_B_WQ_ID;\r\n} else\r\nbd->queue_id = WCN36XX_TX_U_WQ_ID;\r\n*vif_priv = __vif_priv;\r\nwcn36xx_set_tx_pdu(bd,\r\nieee80211_is_data_qos(hdr->frame_control) ?\r\nsizeof(struct ieee80211_qos_hdr) :\r\nsizeof(struct ieee80211_hdr_3addr),\r\nskb->len, WCN36XX_TID);\r\n}\r\nint wcn36xx_start_tx(struct wcn36xx *wcn,\r\nstruct wcn36xx_sta *sta_priv,\r\nstruct sk_buff *skb)\r\n{\r\nstruct ieee80211_hdr *hdr = (struct ieee80211_hdr *)skb->data;\r\nstruct wcn36xx_vif *vif_priv = NULL;\r\nstruct ieee80211_tx_info *info = IEEE80211_SKB_CB(skb);\r\nunsigned long flags;\r\nbool is_low = ieee80211_is_data(hdr->frame_control);\r\nbool bcast = is_broadcast_ether_addr(hdr->addr1) ||\r\nis_multicast_ether_addr(hdr->addr1);\r\nstruct wcn36xx_tx_bd *bd = wcn36xx_dxe_get_next_bd(wcn, is_low);\r\nif (!bd) {\r\nwcn36xx_err("bd address may not be NULL for BD DXE\n");\r\nreturn -EINVAL;\r\n}\r\nmemset(bd, 0, sizeof(*bd));\r\nwcn36xx_dbg(WCN36XX_DBG_TX,\r\n"tx skb %p len %d fc %04x sn %d %s %s\n",\r\nskb, skb->len, __le16_to_cpu(hdr->frame_control),\r\nIEEE80211_SEQ_TO_SN(__le16_to_cpu(hdr->seq_ctrl)),\r\nis_low ? "low" : "high", bcast ? "bcast" : "ucast");\r\nwcn36xx_dbg_dump(WCN36XX_DBG_TX_DUMP, "", skb->data, skb->len);\r\nbd->dpu_rf = WCN36XX_BMU_WQ_TX;\r\nbd->tx_comp = !!(info->flags & IEEE80211_TX_CTL_REQ_TX_STATUS);\r\nif (bd->tx_comp) {\r\nwcn36xx_dbg(WCN36XX_DBG_DXE, "TX_ACK status requested\n");\r\nspin_lock_irqsave(&wcn->dxe_lock, flags);\r\nif (wcn->tx_ack_skb) {\r\nspin_unlock_irqrestore(&wcn->dxe_lock, flags);\r\nwcn36xx_warn("tx_ack_skb already set\n");\r\nreturn -EINVAL;\r\n}\r\nwcn->tx_ack_skb = skb;\r\nspin_unlock_irqrestore(&wcn->dxe_lock, flags);\r\nieee80211_stop_queues(wcn->hw);\r\n}\r\nif (is_low)\r\nwcn36xx_set_tx_data(bd, wcn, &vif_priv, sta_priv, skb, bcast);\r\nelse\r\nwcn36xx_set_tx_mgmt(bd, wcn, &vif_priv, skb, bcast);\r\nbuff_to_be((u32 *)bd, sizeof(*bd)/sizeof(u32));\r\nbd->tx_bd_sign = 0xbdbdbdbd;\r\nreturn wcn36xx_dxe_tx_frame(wcn, vif_priv, skb, is_low);\r\n}
