static void ttm_tt_alloc_page_directory(struct ttm_tt *ttm)\r\n{\r\nttm->pages = drm_calloc_large(ttm->num_pages, sizeof(void*));\r\n}\r\nstatic void ttm_dma_tt_alloc_page_directory(struct ttm_dma_tt *ttm)\r\n{\r\nttm->ttm.pages = drm_calloc_large(ttm->ttm.num_pages,\r\nsizeof(*ttm->ttm.pages) +\r\nsizeof(*ttm->dma_address) +\r\nsizeof(*ttm->cpu_address));\r\nttm->cpu_address = (void *) (ttm->ttm.pages + ttm->ttm.num_pages);\r\nttm->dma_address = (void *) (ttm->cpu_address + ttm->ttm.num_pages);\r\n}\r\nstatic inline int ttm_tt_set_page_caching(struct page *p,\r\nenum ttm_caching_state c_old,\r\nenum ttm_caching_state c_new)\r\n{\r\nint ret = 0;\r\nif (PageHighMem(p))\r\nreturn 0;\r\nif (c_old != tt_cached) {\r\nret = set_pages_wb(p, 1);\r\nif (ret)\r\nreturn ret;\r\n}\r\nif (c_new == tt_wc)\r\nret = set_memory_wc((unsigned long) page_address(p), 1);\r\nelse if (c_new == tt_uncached)\r\nret = set_pages_uc(p, 1);\r\nreturn ret;\r\n}\r\nstatic inline int ttm_tt_set_page_caching(struct page *p,\r\nenum ttm_caching_state c_old,\r\nenum ttm_caching_state c_new)\r\n{\r\nreturn 0;\r\n}\r\nstatic int ttm_tt_set_caching(struct ttm_tt *ttm,\r\nenum ttm_caching_state c_state)\r\n{\r\nint i, j;\r\nstruct page *cur_page;\r\nint ret;\r\nif (ttm->caching_state == c_state)\r\nreturn 0;\r\nif (ttm->state == tt_unpopulated) {\r\nttm->caching_state = c_state;\r\nreturn 0;\r\n}\r\nif (ttm->caching_state == tt_cached)\r\ndrm_clflush_pages(ttm->pages, ttm->num_pages);\r\nfor (i = 0; i < ttm->num_pages; ++i) {\r\ncur_page = ttm->pages[i];\r\nif (likely(cur_page != NULL)) {\r\nret = ttm_tt_set_page_caching(cur_page,\r\nttm->caching_state,\r\nc_state);\r\nif (unlikely(ret != 0))\r\ngoto out_err;\r\n}\r\n}\r\nttm->caching_state = c_state;\r\nreturn 0;\r\nout_err:\r\nfor (j = 0; j < i; ++j) {\r\ncur_page = ttm->pages[j];\r\nif (likely(cur_page != NULL)) {\r\n(void)ttm_tt_set_page_caching(cur_page, c_state,\r\nttm->caching_state);\r\n}\r\n}\r\nreturn ret;\r\n}\r\nint ttm_tt_set_placement_caching(struct ttm_tt *ttm, uint32_t placement)\r\n{\r\nenum ttm_caching_state state;\r\nif (placement & TTM_PL_FLAG_WC)\r\nstate = tt_wc;\r\nelse if (placement & TTM_PL_FLAG_UNCACHED)\r\nstate = tt_uncached;\r\nelse\r\nstate = tt_cached;\r\nreturn ttm_tt_set_caching(ttm, state);\r\n}\r\nvoid ttm_tt_destroy(struct ttm_tt *ttm)\r\n{\r\nif (unlikely(ttm == NULL))\r\nreturn;\r\nif (ttm->state == tt_bound) {\r\nttm_tt_unbind(ttm);\r\n}\r\nif (ttm->state == tt_unbound)\r\nttm_tt_unpopulate(ttm);\r\nif (!(ttm->page_flags & TTM_PAGE_FLAG_PERSISTENT_SWAP) &&\r\nttm->swap_storage)\r\nfput(ttm->swap_storage);\r\nttm->swap_storage = NULL;\r\nttm->func->destroy(ttm);\r\n}\r\nint ttm_tt_init(struct ttm_tt *ttm, struct ttm_bo_device *bdev,\r\nunsigned long size, uint32_t page_flags,\r\nstruct page *dummy_read_page)\r\n{\r\nttm->bdev = bdev;\r\nttm->glob = bdev->glob;\r\nttm->num_pages = (size + PAGE_SIZE - 1) >> PAGE_SHIFT;\r\nttm->caching_state = tt_cached;\r\nttm->page_flags = page_flags;\r\nttm->dummy_read_page = dummy_read_page;\r\nttm->state = tt_unpopulated;\r\nttm->swap_storage = NULL;\r\nttm_tt_alloc_page_directory(ttm);\r\nif (!ttm->pages) {\r\nttm_tt_destroy(ttm);\r\npr_err("Failed allocating page table\n");\r\nreturn -ENOMEM;\r\n}\r\nreturn 0;\r\n}\r\nvoid ttm_tt_fini(struct ttm_tt *ttm)\r\n{\r\ndrm_free_large(ttm->pages);\r\nttm->pages = NULL;\r\n}\r\nint ttm_dma_tt_init(struct ttm_dma_tt *ttm_dma, struct ttm_bo_device *bdev,\r\nunsigned long size, uint32_t page_flags,\r\nstruct page *dummy_read_page)\r\n{\r\nstruct ttm_tt *ttm = &ttm_dma->ttm;\r\nttm->bdev = bdev;\r\nttm->glob = bdev->glob;\r\nttm->num_pages = (size + PAGE_SIZE - 1) >> PAGE_SHIFT;\r\nttm->caching_state = tt_cached;\r\nttm->page_flags = page_flags;\r\nttm->dummy_read_page = dummy_read_page;\r\nttm->state = tt_unpopulated;\r\nttm->swap_storage = NULL;\r\nINIT_LIST_HEAD(&ttm_dma->pages_list);\r\nttm_dma_tt_alloc_page_directory(ttm_dma);\r\nif (!ttm->pages) {\r\nttm_tt_destroy(ttm);\r\npr_err("Failed allocating page table\n");\r\nreturn -ENOMEM;\r\n}\r\nreturn 0;\r\n}\r\nvoid ttm_dma_tt_fini(struct ttm_dma_tt *ttm_dma)\r\n{\r\nstruct ttm_tt *ttm = &ttm_dma->ttm;\r\ndrm_free_large(ttm->pages);\r\nttm->pages = NULL;\r\nttm_dma->cpu_address = NULL;\r\nttm_dma->dma_address = NULL;\r\n}\r\nvoid ttm_tt_unbind(struct ttm_tt *ttm)\r\n{\r\nint ret;\r\nif (ttm->state == tt_bound) {\r\nret = ttm->func->unbind(ttm);\r\nBUG_ON(ret);\r\nttm->state = tt_unbound;\r\n}\r\n}\r\nint ttm_tt_bind(struct ttm_tt *ttm, struct ttm_mem_reg *bo_mem)\r\n{\r\nint ret = 0;\r\nif (!ttm)\r\nreturn -EINVAL;\r\nif (ttm->state == tt_bound)\r\nreturn 0;\r\nret = ttm->bdev->driver->ttm_tt_populate(ttm);\r\nif (ret)\r\nreturn ret;\r\nret = ttm->func->bind(ttm, bo_mem);\r\nif (unlikely(ret != 0))\r\nreturn ret;\r\nttm->state = tt_bound;\r\nreturn 0;\r\n}\r\nint ttm_tt_swapin(struct ttm_tt *ttm)\r\n{\r\nstruct address_space *swap_space;\r\nstruct file *swap_storage;\r\nstruct page *from_page;\r\nstruct page *to_page;\r\nint i;\r\nint ret = -ENOMEM;\r\nswap_storage = ttm->swap_storage;\r\nBUG_ON(swap_storage == NULL);\r\nswap_space = file_inode(swap_storage)->i_mapping;\r\nfor (i = 0; i < ttm->num_pages; ++i) {\r\nfrom_page = shmem_read_mapping_page(swap_space, i);\r\nif (IS_ERR(from_page)) {\r\nret = PTR_ERR(from_page);\r\ngoto out_err;\r\n}\r\nto_page = ttm->pages[i];\r\nif (unlikely(to_page == NULL))\r\ngoto out_err;\r\ncopy_highpage(to_page, from_page);\r\npage_cache_release(from_page);\r\n}\r\nif (!(ttm->page_flags & TTM_PAGE_FLAG_PERSISTENT_SWAP))\r\nfput(swap_storage);\r\nttm->swap_storage = NULL;\r\nttm->page_flags &= ~TTM_PAGE_FLAG_SWAPPED;\r\nreturn 0;\r\nout_err:\r\nreturn ret;\r\n}\r\nint ttm_tt_swapout(struct ttm_tt *ttm, struct file *persistent_swap_storage)\r\n{\r\nstruct address_space *swap_space;\r\nstruct file *swap_storage;\r\nstruct page *from_page;\r\nstruct page *to_page;\r\nint i;\r\nint ret = -ENOMEM;\r\nBUG_ON(ttm->state != tt_unbound && ttm->state != tt_unpopulated);\r\nBUG_ON(ttm->caching_state != tt_cached);\r\nif (!persistent_swap_storage) {\r\nswap_storage = shmem_file_setup("ttm swap",\r\nttm->num_pages << PAGE_SHIFT,\r\n0);\r\nif (IS_ERR(swap_storage)) {\r\npr_err("Failed allocating swap storage\n");\r\nreturn PTR_ERR(swap_storage);\r\n}\r\n} else\r\nswap_storage = persistent_swap_storage;\r\nswap_space = file_inode(swap_storage)->i_mapping;\r\nfor (i = 0; i < ttm->num_pages; ++i) {\r\nfrom_page = ttm->pages[i];\r\nif (unlikely(from_page == NULL))\r\ncontinue;\r\nto_page = shmem_read_mapping_page(swap_space, i);\r\nif (IS_ERR(to_page)) {\r\nret = PTR_ERR(to_page);\r\ngoto out_err;\r\n}\r\ncopy_highpage(to_page, from_page);\r\nset_page_dirty(to_page);\r\nmark_page_accessed(to_page);\r\npage_cache_release(to_page);\r\n}\r\nttm_tt_unpopulate(ttm);\r\nttm->swap_storage = swap_storage;\r\nttm->page_flags |= TTM_PAGE_FLAG_SWAPPED;\r\nif (persistent_swap_storage)\r\nttm->page_flags |= TTM_PAGE_FLAG_PERSISTENT_SWAP;\r\nreturn 0;\r\nout_err:\r\nif (!persistent_swap_storage)\r\nfput(swap_storage);\r\nreturn ret;\r\n}\r\nstatic void ttm_tt_clear_mapping(struct ttm_tt *ttm)\r\n{\r\npgoff_t i;\r\nstruct page **page = ttm->pages;\r\nif (ttm->page_flags & TTM_PAGE_FLAG_SG)\r\nreturn;\r\nfor (i = 0; i < ttm->num_pages; ++i) {\r\n(*page)->mapping = NULL;\r\n(*page++)->index = 0;\r\n}\r\n}\r\nvoid ttm_tt_unpopulate(struct ttm_tt *ttm)\r\n{\r\nif (ttm->state == tt_unpopulated)\r\nreturn;\r\nttm_tt_clear_mapping(ttm);\r\nttm->bdev->driver->ttm_tt_unpopulate(ttm);\r\n}
