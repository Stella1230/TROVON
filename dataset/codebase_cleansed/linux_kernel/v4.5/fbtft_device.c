static int write_gpio16_wr_slow(struct fbtft_par *par, void *buf, size_t len)\r\n{\r\nu16 data;\r\nint i;\r\n#ifndef DO_NOT_OPTIMIZE_FBTFT_WRITE_GPIO\r\nstatic u16 prev_data;\r\n#endif\r\nfbtft_par_dbg_hex(DEBUG_WRITE, par, par->info->device, u8, buf, len,\r\n"%s(len=%d): ", __func__, len);\r\nwhile (len) {\r\ndata = *(u16 *) buf;\r\ngpio_set_value(par->gpio.wr, 0);\r\n#ifndef DO_NOT_OPTIMIZE_FBTFT_WRITE_GPIO\r\nif (data == prev_data) {\r\ngpio_set_value(par->gpio.wr, 0);\r\n} else {\r\nfor (i = 0; i < 16; i++) {\r\nif ((data & 1) != (prev_data & 1))\r\ngpio_set_value(par->gpio.db[i],\r\ndata & 1);\r\ndata >>= 1;\r\nprev_data >>= 1;\r\n}\r\n}\r\n#else\r\nfor (i = 0; i < 16; i++) {\r\ngpio_set_value(par->gpio.db[i], data & 1);\r\ndata >>= 1;\r\n}\r\n#endif\r\ngpio_set_value(par->gpio.wr, 1);\r\n#ifndef DO_NOT_OPTIMIZE_FBTFT_WRITE_GPIO\r\nprev_data = *(u16 *) buf;\r\n#endif\r\nbuf += 2;\r\nlen -= 2;\r\n}\r\nreturn 0;\r\n}\r\nstatic void adafruit18_green_tab_set_addr_win(struct fbtft_par *par,\r\nint xs, int ys, int xe, int ye)\r\n{\r\nwrite_reg(par, 0x2A, 0, xs + 2, 0, xe + 2);\r\nwrite_reg(par, 0x2B, 0, ys + 1, 0, ye + 1);\r\nwrite_reg(par, 0x2C);\r\n}\r\nstatic void fbtft_device_pdev_release(struct device *dev)\r\n{\r\n}\r\nstatic int spi_device_found(struct device *dev, void *data)\r\n{\r\nstruct spi_device *spi = container_of(dev, struct spi_device, dev);\r\ndev_info(dev, "%s %s %dkHz %d bits mode=0x%02X\n", spi->modalias,\r\ndev_name(dev), spi->max_speed_hz / 1000, spi->bits_per_word,\r\nspi->mode);\r\nreturn 0;\r\n}\r\nstatic void pr_spi_devices(void)\r\n{\r\npr_debug("SPI devices registered:\n");\r\nbus_for_each_dev(&spi_bus_type, NULL, NULL, spi_device_found);\r\n}\r\nstatic int p_device_found(struct device *dev, void *data)\r\n{\r\nstruct platform_device\r\n*pdev = container_of(dev, struct platform_device, dev);\r\nif (strstr(pdev->name, "fb"))\r\ndev_info(dev, "%s id=%d pdata? %s\n", pdev->name, pdev->id,\r\npdev->dev.platform_data ? "yes" : "no");\r\nreturn 0;\r\n}\r\nstatic void pr_p_devices(void)\r\n{\r\npr_debug("'fb' Platform devices registered:\n");\r\nbus_for_each_dev(&platform_bus_type, NULL, NULL, p_device_found);\r\n}\r\nstatic void fbtft_device_spi_delete(struct spi_master *master, unsigned cs)\r\n{\r\nstruct device *dev;\r\nchar str[32];\r\nsnprintf(str, sizeof(str), "%s.%u", dev_name(&master->dev), cs);\r\ndev = bus_find_device_by_name(&spi_bus_type, NULL, str);\r\nif (dev) {\r\nif (verbose)\r\ndev_info(dev, "Deleting %s\n", str);\r\ndevice_del(dev);\r\n}\r\n}\r\nstatic int fbtft_device_spi_device_register(struct spi_board_info *spi)\r\n{\r\nstruct spi_master *master;\r\nmaster = spi_busnum_to_master(spi->bus_num);\r\nif (!master) {\r\npr_err("spi_busnum_to_master(%d) returned NULL\n",\r\nspi->bus_num);\r\nreturn -EINVAL;\r\n}\r\nfbtft_device_spi_delete(master, spi->chip_select);\r\nspi_device = spi_new_device(master, spi);\r\nput_device(&master->dev);\r\nif (!spi_device) {\r\ndev_err(&master->dev, "spi_new_device() returned NULL\n");\r\nreturn -EPERM;\r\n}\r\nreturn 0;\r\n}\r\nstatic int fbtft_device_spi_device_register(struct spi_board_info *spi)\r\n{\r\nreturn spi_register_board_info(spi, 1);\r\n}\r\nstatic int __init fbtft_device_init(void)\r\n{\r\nstruct spi_board_info *spi = NULL;\r\nstruct fbtft_platform_data *pdata;\r\nconst struct fbtft_gpio *gpio = NULL;\r\nchar *p_gpio, *p_name, *p_num;\r\nbool found = false;\r\nint i = 0;\r\nlong val;\r\nint ret = 0;\r\nif (name == NULL) {\r\n#ifdef MODULE\r\npr_err("missing module parameter: 'name'\n");\r\nreturn -EINVAL;\r\n#else\r\nreturn 0;\r\n#endif\r\n}\r\nif (init_num > FBTFT_MAX_INIT_SEQUENCE) {\r\npr_err("init parameter: exceeded max array size: %d\n",\r\nFBTFT_MAX_INIT_SEQUENCE);\r\nreturn -EINVAL;\r\n}\r\nwhile ((p_gpio = strsep(&gpios, ","))) {\r\nif (strchr(p_gpio, ':') == NULL) {\r\npr_err("error: missing ':' in gpios parameter: %s\n",\r\np_gpio);\r\nreturn -EINVAL;\r\n}\r\np_num = p_gpio;\r\np_name = strsep(&p_num, ":");\r\nif (p_name == NULL || p_num == NULL) {\r\npr_err("something bad happened parsing gpios parameter: %s\n",\r\np_gpio);\r\nreturn -EINVAL;\r\n}\r\nret = kstrtol(p_num, 10, &val);\r\nif (ret) {\r\npr_err("could not parse number in gpios parameter: %s:%s\n",\r\np_name, p_num);\r\nreturn -EINVAL;\r\n}\r\nstrncpy(fbtft_device_param_gpios[i].name, p_name,\r\nFBTFT_GPIO_NAME_SIZE - 1);\r\nfbtft_device_param_gpios[i++].gpio = (int) val;\r\nif (i == MAX_GPIOS) {\r\npr_err("gpios parameter: exceeded max array size: %d\n",\r\nMAX_GPIOS);\r\nreturn -EINVAL;\r\n}\r\n}\r\nif (fbtft_device_param_gpios[0].name[0])\r\ngpio = fbtft_device_param_gpios;\r\nif (verbose > 2)\r\npr_spi_devices();\r\nif (verbose > 2)\r\npr_p_devices();\r\npr_debug("name='%s', busnum=%d, cs=%d\n", name, busnum, cs);\r\nif (rotate > 0 && rotate < 4) {\r\nrotate = (4 - rotate) * 90;\r\npr_warn("argument 'rotate' should be an angle. Values 1-3 is deprecated. Setting it to %d.\n",\r\nrotate);\r\n}\r\nif (rotate != 0 && rotate != 90 && rotate != 180 && rotate != 270) {\r\npr_warn("argument 'rotate' illegal value: %d. Setting it to 0.\n",\r\nrotate);\r\nrotate = 0;\r\n}\r\nif (strncmp(name, "list", FBTFT_GPIO_NAME_SIZE) == 0) {\r\npr_info("Supported displays:\n");\r\nfor (i = 0; i < ARRAY_SIZE(displays); i++)\r\npr_info("%s\n", displays[i].name);\r\nreturn -ECANCELED;\r\n}\r\nif (custom) {\r\ni = ARRAY_SIZE(displays) - 1;\r\ndisplays[i].name = name;\r\nif (speed == 0) {\r\ndisplays[i].pdev->name = name;\r\ndisplays[i].spi = NULL;\r\n} else {\r\nstrncpy(displays[i].spi->modalias, name, SPI_NAME_SIZE);\r\ndisplays[i].pdev = NULL;\r\n}\r\n}\r\nfor (i = 0; i < ARRAY_SIZE(displays); i++) {\r\nif (strncmp(name, displays[i].name, 32) == 0) {\r\nif (displays[i].spi) {\r\nspi = displays[i].spi;\r\nspi->chip_select = cs;\r\nspi->bus_num = busnum;\r\nif (speed)\r\nspi->max_speed_hz = speed;\r\nif (mode != -1)\r\nspi->mode = mode;\r\npdata = (void *)spi->platform_data;\r\n} else if (displays[i].pdev) {\r\np_device = displays[i].pdev;\r\npdata = p_device->dev.platform_data;\r\n} else {\r\npr_err("broken displays array\n");\r\nreturn -EINVAL;\r\n}\r\npdata->rotate = rotate;\r\nif (bgr == 0)\r\npdata->bgr = false;\r\nelse if (bgr == 1)\r\npdata->bgr = true;\r\nif (startbyte)\r\npdata->startbyte = startbyte;\r\nif (gamma)\r\npdata->gamma = gamma;\r\npdata->display.debug = debug;\r\nif (fps)\r\npdata->fps = fps;\r\nif (txbuflen)\r\npdata->txbuflen = txbuflen;\r\nif (init_num)\r\npdata->display.init_sequence = init;\r\nif (gpio)\r\npdata->gpios = gpio;\r\nif (custom) {\r\npdata->display.width = width;\r\npdata->display.height = height;\r\npdata->display.buswidth = buswidth;\r\npdata->display.backlight = 1;\r\n}\r\nif (displays[i].spi) {\r\nret = fbtft_device_spi_device_register(spi);\r\nif (ret) {\r\npr_err("failed to register SPI device\n");\r\nreturn ret;\r\n}\r\n} else {\r\nret = platform_device_register(p_device);\r\nif (ret < 0) {\r\npr_err("platform_device_register() returned %d\n",\r\nret);\r\nreturn ret;\r\n}\r\n}\r\nfound = true;\r\nbreak;\r\n}\r\n}\r\nif (!found) {\r\npr_err("display not supported: '%s'\n", name);\r\nreturn -EINVAL;\r\n}\r\nif (verbose && pdata && pdata->gpios) {\r\ngpio = pdata->gpios;\r\npr_info("GPIOS used by '%s':\n", name);\r\nfound = false;\r\nwhile (verbose && gpio->name[0]) {\r\npr_info("'%s' = GPIO%d\n", gpio->name, gpio->gpio);\r\ngpio++;\r\nfound = true;\r\n}\r\nif (!found)\r\npr_info("(none)\n");\r\n}\r\nif (spi_device && (verbose > 1))\r\npr_spi_devices();\r\nif (p_device && (verbose > 1))\r\npr_p_devices();\r\nreturn 0;\r\n}\r\nstatic void __exit fbtft_device_exit(void)\r\n{\r\nif (spi_device) {\r\ndevice_del(&spi_device->dev);\r\nkfree(spi_device);\r\n}\r\nif (p_device)\r\nplatform_device_unregister(p_device);\r\n}
