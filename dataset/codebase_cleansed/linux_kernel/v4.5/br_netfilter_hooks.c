static inline __be16 vlan_proto(const struct sk_buff *skb)\r\n{\r\nif (skb_vlan_tag_present(skb))\r\nreturn skb->protocol;\r\nelse if (skb->protocol == htons(ETH_P_8021Q))\r\nreturn vlan_eth_hdr(skb)->h_vlan_encapsulated_proto;\r\nelse\r\nreturn 0;\r\n}\r\nstatic inline __be16 pppoe_proto(const struct sk_buff *skb)\r\n{\r\nreturn *((__be16 *)(skb_mac_header(skb) + ETH_HLEN +\r\nsizeof(struct pppoe_hdr)));\r\n}\r\nstatic void nf_bridge_info_free(struct sk_buff *skb)\r\n{\r\nif (skb->nf_bridge) {\r\nnf_bridge_put(skb->nf_bridge);\r\nskb->nf_bridge = NULL;\r\n}\r\n}\r\nstatic inline struct net_device *bridge_parent(const struct net_device *dev)\r\n{\r\nstruct net_bridge_port *port;\r\nport = br_port_get_rcu(dev);\r\nreturn port ? port->br->dev : NULL;\r\n}\r\nstatic inline struct nf_bridge_info *nf_bridge_unshare(struct sk_buff *skb)\r\n{\r\nstruct nf_bridge_info *nf_bridge = skb->nf_bridge;\r\nif (atomic_read(&nf_bridge->use) > 1) {\r\nstruct nf_bridge_info *tmp = nf_bridge_alloc(skb);\r\nif (tmp) {\r\nmemcpy(tmp, nf_bridge, sizeof(struct nf_bridge_info));\r\natomic_set(&tmp->use, 1);\r\n}\r\nnf_bridge_put(nf_bridge);\r\nnf_bridge = tmp;\r\n}\r\nreturn nf_bridge;\r\n}\r\nunsigned int nf_bridge_encap_header_len(const struct sk_buff *skb)\r\n{\r\nswitch (skb->protocol) {\r\ncase __cpu_to_be16(ETH_P_8021Q):\r\nreturn VLAN_HLEN;\r\ncase __cpu_to_be16(ETH_P_PPP_SES):\r\nreturn PPPOE_SES_HLEN;\r\ndefault:\r\nreturn 0;\r\n}\r\n}\r\nstatic inline void nf_bridge_pull_encap_header(struct sk_buff *skb)\r\n{\r\nunsigned int len = nf_bridge_encap_header_len(skb);\r\nskb_pull(skb, len);\r\nskb->network_header += len;\r\n}\r\nstatic inline void nf_bridge_pull_encap_header_rcsum(struct sk_buff *skb)\r\n{\r\nunsigned int len = nf_bridge_encap_header_len(skb);\r\nskb_pull_rcsum(skb, len);\r\nskb->network_header += len;\r\n}\r\nstatic int br_validate_ipv4(struct net *net, struct sk_buff *skb)\r\n{\r\nconst struct iphdr *iph;\r\nu32 len;\r\nif (!pskb_may_pull(skb, sizeof(struct iphdr)))\r\ngoto inhdr_error;\r\niph = ip_hdr(skb);\r\nif (iph->ihl < 5 || iph->version != 4)\r\ngoto inhdr_error;\r\nif (!pskb_may_pull(skb, iph->ihl*4))\r\ngoto inhdr_error;\r\niph = ip_hdr(skb);\r\nif (unlikely(ip_fast_csum((u8 *)iph, iph->ihl)))\r\ngoto inhdr_error;\r\nlen = ntohs(iph->tot_len);\r\nif (skb->len < len) {\r\nIP_INC_STATS_BH(net, IPSTATS_MIB_INTRUNCATEDPKTS);\r\ngoto drop;\r\n} else if (len < (iph->ihl*4))\r\ngoto inhdr_error;\r\nif (pskb_trim_rcsum(skb, len)) {\r\nIP_INC_STATS_BH(net, IPSTATS_MIB_INDISCARDS);\r\ngoto drop;\r\n}\r\nmemset(IPCB(skb), 0, sizeof(struct inet_skb_parm));\r\nreturn 0;\r\ninhdr_error:\r\nIP_INC_STATS_BH(net, IPSTATS_MIB_INHDRERRORS);\r\ndrop:\r\nreturn -1;\r\n}\r\nvoid nf_bridge_update_protocol(struct sk_buff *skb)\r\n{\r\nswitch (skb->nf_bridge->orig_proto) {\r\ncase BRNF_PROTO_8021Q:\r\nskb->protocol = htons(ETH_P_8021Q);\r\nbreak;\r\ncase BRNF_PROTO_PPPOE:\r\nskb->protocol = htons(ETH_P_PPP_SES);\r\nbreak;\r\ncase BRNF_PROTO_UNCHANGED:\r\nbreak;\r\n}\r\n}\r\nint br_nf_pre_routing_finish_bridge(struct net *net, struct sock *sk, struct sk_buff *skb)\r\n{\r\nstruct neighbour *neigh;\r\nstruct dst_entry *dst;\r\nskb->dev = bridge_parent(skb->dev);\r\nif (!skb->dev)\r\ngoto free_skb;\r\ndst = skb_dst(skb);\r\nneigh = dst_neigh_lookup_skb(dst, skb);\r\nif (neigh) {\r\nstruct nf_bridge_info *nf_bridge = nf_bridge_info_get(skb);\r\nint ret;\r\nif (neigh->hh.hh_len) {\r\nneigh_hh_bridge(&neigh->hh, skb);\r\nskb->dev = nf_bridge->physindev;\r\nret = br_handle_frame_finish(net, sk, skb);\r\n} else {\r\nskb_copy_from_linear_data_offset(skb,\r\n-(ETH_HLEN-ETH_ALEN),\r\nnf_bridge->neigh_header,\r\nETH_HLEN-ETH_ALEN);\r\nnf_bridge->bridged_dnat = 1;\r\nret = neigh->output(neigh, skb);\r\n}\r\nneigh_release(neigh);\r\nreturn ret;\r\n}\r\nfree_skb:\r\nkfree_skb(skb);\r\nreturn 0;\r\n}\r\nstatic inline bool\r\nbr_nf_ipv4_daddr_was_changed(const struct sk_buff *skb,\r\nconst struct nf_bridge_info *nf_bridge)\r\n{\r\nreturn ip_hdr(skb)->daddr != nf_bridge->ipv4_daddr;\r\n}\r\nstatic int br_nf_pre_routing_finish(struct net *net, struct sock *sk, struct sk_buff *skb)\r\n{\r\nstruct net_device *dev = skb->dev;\r\nstruct iphdr *iph = ip_hdr(skb);\r\nstruct nf_bridge_info *nf_bridge = nf_bridge_info_get(skb);\r\nstruct rtable *rt;\r\nint err;\r\nnf_bridge->frag_max_size = IPCB(skb)->frag_max_size;\r\nif (nf_bridge->pkt_otherhost) {\r\nskb->pkt_type = PACKET_OTHERHOST;\r\nnf_bridge->pkt_otherhost = false;\r\n}\r\nnf_bridge->in_prerouting = 0;\r\nif (br_nf_ipv4_daddr_was_changed(skb, nf_bridge)) {\r\nif ((err = ip_route_input(skb, iph->daddr, iph->saddr, iph->tos, dev))) {\r\nstruct in_device *in_dev = __in_dev_get_rcu(dev);\r\nif (err != -EHOSTUNREACH || !in_dev || IN_DEV_FORWARD(in_dev))\r\ngoto free_skb;\r\nrt = ip_route_output(net, iph->daddr, 0,\r\nRT_TOS(iph->tos), 0);\r\nif (!IS_ERR(rt)) {\r\nif (rt->dst.dev == dev) {\r\nskb_dst_set(skb, &rt->dst);\r\ngoto bridged_dnat;\r\n}\r\nip_rt_put(rt);\r\n}\r\nfree_skb:\r\nkfree_skb(skb);\r\nreturn 0;\r\n} else {\r\nif (skb_dst(skb)->dev == dev) {\r\nbridged_dnat:\r\nskb->dev = nf_bridge->physindev;\r\nnf_bridge_update_protocol(skb);\r\nnf_bridge_push_encap_header(skb);\r\nNF_HOOK_THRESH(NFPROTO_BRIDGE,\r\nNF_BR_PRE_ROUTING,\r\nnet, sk, skb, skb->dev, NULL,\r\nbr_nf_pre_routing_finish_bridge,\r\n1);\r\nreturn 0;\r\n}\r\nether_addr_copy(eth_hdr(skb)->h_dest, dev->dev_addr);\r\nskb->pkt_type = PACKET_HOST;\r\n}\r\n} else {\r\nrt = bridge_parent_rtable(nf_bridge->physindev);\r\nif (!rt) {\r\nkfree_skb(skb);\r\nreturn 0;\r\n}\r\nskb_dst_set_noref(skb, &rt->dst);\r\n}\r\nskb->dev = nf_bridge->physindev;\r\nnf_bridge_update_protocol(skb);\r\nnf_bridge_push_encap_header(skb);\r\nNF_HOOK_THRESH(NFPROTO_BRIDGE, NF_BR_PRE_ROUTING, net, sk, skb,\r\nskb->dev, NULL,\r\nbr_handle_frame_finish, 1);\r\nreturn 0;\r\n}\r\nstatic struct net_device *brnf_get_logical_dev(struct sk_buff *skb, const struct net_device *dev)\r\n{\r\nstruct net_device *vlan, *br;\r\nbr = bridge_parent(dev);\r\nif (brnf_pass_vlan_indev == 0 || !skb_vlan_tag_present(skb))\r\nreturn br;\r\nvlan = __vlan_find_dev_deep_rcu(br, skb->vlan_proto,\r\nskb_vlan_tag_get(skb) & VLAN_VID_MASK);\r\nreturn vlan ? vlan : br;\r\n}\r\nstruct net_device *setup_pre_routing(struct sk_buff *skb)\r\n{\r\nstruct nf_bridge_info *nf_bridge = nf_bridge_info_get(skb);\r\nif (skb->pkt_type == PACKET_OTHERHOST) {\r\nskb->pkt_type = PACKET_HOST;\r\nnf_bridge->pkt_otherhost = true;\r\n}\r\nnf_bridge->in_prerouting = 1;\r\nnf_bridge->physindev = skb->dev;\r\nskb->dev = brnf_get_logical_dev(skb, skb->dev);\r\nif (skb->protocol == htons(ETH_P_8021Q))\r\nnf_bridge->orig_proto = BRNF_PROTO_8021Q;\r\nelse if (skb->protocol == htons(ETH_P_PPP_SES))\r\nnf_bridge->orig_proto = BRNF_PROTO_PPPOE;\r\nskb_orphan(skb);\r\nreturn skb->dev;\r\n}\r\nstatic unsigned int br_nf_pre_routing(void *priv,\r\nstruct sk_buff *skb,\r\nconst struct nf_hook_state *state)\r\n{\r\nstruct nf_bridge_info *nf_bridge;\r\nstruct net_bridge_port *p;\r\nstruct net_bridge *br;\r\n__u32 len = nf_bridge_encap_header_len(skb);\r\nif (unlikely(!pskb_may_pull(skb, len)))\r\nreturn NF_DROP;\r\np = br_port_get_rcu(state->in);\r\nif (p == NULL)\r\nreturn NF_DROP;\r\nbr = p->br;\r\nif (IS_IPV6(skb) || IS_VLAN_IPV6(skb) || IS_PPPOE_IPV6(skb)) {\r\nif (!brnf_call_ip6tables && !br->nf_call_ip6tables)\r\nreturn NF_ACCEPT;\r\nnf_bridge_pull_encap_header_rcsum(skb);\r\nreturn br_nf_pre_routing_ipv6(priv, skb, state);\r\n}\r\nif (!brnf_call_iptables && !br->nf_call_iptables)\r\nreturn NF_ACCEPT;\r\nif (!IS_IP(skb) && !IS_VLAN_IP(skb) && !IS_PPPOE_IP(skb))\r\nreturn NF_ACCEPT;\r\nnf_bridge_pull_encap_header_rcsum(skb);\r\nif (br_validate_ipv4(state->net, skb))\r\nreturn NF_DROP;\r\nnf_bridge_put(skb->nf_bridge);\r\nif (!nf_bridge_alloc(skb))\r\nreturn NF_DROP;\r\nif (!setup_pre_routing(skb))\r\nreturn NF_DROP;\r\nnf_bridge = nf_bridge_info_get(skb);\r\nnf_bridge->ipv4_daddr = ip_hdr(skb)->daddr;\r\nskb->protocol = htons(ETH_P_IP);\r\nNF_HOOK(NFPROTO_IPV4, NF_INET_PRE_ROUTING, state->net, state->sk, skb,\r\nskb->dev, NULL,\r\nbr_nf_pre_routing_finish);\r\nreturn NF_STOLEN;\r\n}\r\nstatic unsigned int br_nf_local_in(void *priv,\r\nstruct sk_buff *skb,\r\nconst struct nf_hook_state *state)\r\n{\r\nbr_drop_fake_rtable(skb);\r\nreturn NF_ACCEPT;\r\n}\r\nstatic int br_nf_forward_finish(struct net *net, struct sock *sk, struct sk_buff *skb)\r\n{\r\nstruct nf_bridge_info *nf_bridge = nf_bridge_info_get(skb);\r\nstruct net_device *in;\r\nif (!IS_ARP(skb) && !IS_VLAN_ARP(skb)) {\r\nif (skb->protocol == htons(ETH_P_IP))\r\nnf_bridge->frag_max_size = IPCB(skb)->frag_max_size;\r\nif (skb->protocol == htons(ETH_P_IPV6))\r\nnf_bridge->frag_max_size = IP6CB(skb)->frag_max_size;\r\nin = nf_bridge->physindev;\r\nif (nf_bridge->pkt_otherhost) {\r\nskb->pkt_type = PACKET_OTHERHOST;\r\nnf_bridge->pkt_otherhost = false;\r\n}\r\nnf_bridge_update_protocol(skb);\r\n} else {\r\nin = *((struct net_device **)(skb->cb));\r\n}\r\nnf_bridge_push_encap_header(skb);\r\nNF_HOOK_THRESH(NFPROTO_BRIDGE, NF_BR_FORWARD, net, sk, skb,\r\nin, skb->dev, br_forward_finish, 1);\r\nreturn 0;\r\n}\r\nstatic unsigned int br_nf_forward_ip(void *priv,\r\nstruct sk_buff *skb,\r\nconst struct nf_hook_state *state)\r\n{\r\nstruct nf_bridge_info *nf_bridge;\r\nstruct net_device *parent;\r\nu_int8_t pf;\r\nif (!skb->nf_bridge)\r\nreturn NF_ACCEPT;\r\nif (!nf_bridge_unshare(skb))\r\nreturn NF_DROP;\r\nnf_bridge = nf_bridge_info_get(skb);\r\nif (!nf_bridge)\r\nreturn NF_DROP;\r\nparent = bridge_parent(state->out);\r\nif (!parent)\r\nreturn NF_DROP;\r\nif (IS_IP(skb) || IS_VLAN_IP(skb) || IS_PPPOE_IP(skb))\r\npf = NFPROTO_IPV4;\r\nelse if (IS_IPV6(skb) || IS_VLAN_IPV6(skb) || IS_PPPOE_IPV6(skb))\r\npf = NFPROTO_IPV6;\r\nelse\r\nreturn NF_ACCEPT;\r\nnf_bridge_pull_encap_header(skb);\r\nif (skb->pkt_type == PACKET_OTHERHOST) {\r\nskb->pkt_type = PACKET_HOST;\r\nnf_bridge->pkt_otherhost = true;\r\n}\r\nif (pf == NFPROTO_IPV4) {\r\nif (br_validate_ipv4(state->net, skb))\r\nreturn NF_DROP;\r\nIPCB(skb)->frag_max_size = nf_bridge->frag_max_size;\r\n}\r\nif (pf == NFPROTO_IPV6) {\r\nif (br_validate_ipv6(state->net, skb))\r\nreturn NF_DROP;\r\nIP6CB(skb)->frag_max_size = nf_bridge->frag_max_size;\r\n}\r\nnf_bridge->physoutdev = skb->dev;\r\nif (pf == NFPROTO_IPV4)\r\nskb->protocol = htons(ETH_P_IP);\r\nelse\r\nskb->protocol = htons(ETH_P_IPV6);\r\nNF_HOOK(pf, NF_INET_FORWARD, state->net, NULL, skb,\r\nbrnf_get_logical_dev(skb, state->in),\r\nparent, br_nf_forward_finish);\r\nreturn NF_STOLEN;\r\n}\r\nstatic unsigned int br_nf_forward_arp(void *priv,\r\nstruct sk_buff *skb,\r\nconst struct nf_hook_state *state)\r\n{\r\nstruct net_bridge_port *p;\r\nstruct net_bridge *br;\r\nstruct net_device **d = (struct net_device **)(skb->cb);\r\np = br_port_get_rcu(state->out);\r\nif (p == NULL)\r\nreturn NF_ACCEPT;\r\nbr = p->br;\r\nif (!brnf_call_arptables && !br->nf_call_arptables)\r\nreturn NF_ACCEPT;\r\nif (!IS_ARP(skb)) {\r\nif (!IS_VLAN_ARP(skb))\r\nreturn NF_ACCEPT;\r\nnf_bridge_pull_encap_header(skb);\r\n}\r\nif (arp_hdr(skb)->ar_pln != 4) {\r\nif (IS_VLAN_ARP(skb))\r\nnf_bridge_push_encap_header(skb);\r\nreturn NF_ACCEPT;\r\n}\r\n*d = state->in;\r\nNF_HOOK(NFPROTO_ARP, NF_ARP_FORWARD, state->net, state->sk, skb,\r\nstate->in, state->out, br_nf_forward_finish);\r\nreturn NF_STOLEN;\r\n}\r\nstatic int br_nf_push_frag_xmit(struct net *net, struct sock *sk, struct sk_buff *skb)\r\n{\r\nstruct brnf_frag_data *data;\r\nint err;\r\ndata = this_cpu_ptr(&brnf_frag_data_storage);\r\nerr = skb_cow_head(skb, data->size);\r\nif (err) {\r\nkfree_skb(skb);\r\nreturn 0;\r\n}\r\nif (data->vlan_tci) {\r\nskb->vlan_tci = data->vlan_tci;\r\nskb->vlan_proto = data->vlan_proto;\r\n}\r\nskb_copy_to_linear_data_offset(skb, -data->size, data->mac, data->size);\r\n__skb_push(skb, data->encap_size);\r\nnf_bridge_info_free(skb);\r\nreturn br_dev_queue_push_xmit(net, sk, skb);\r\n}\r\nstatic int\r\nbr_nf_ip_fragment(struct net *net, struct sock *sk, struct sk_buff *skb,\r\nint (*output)(struct net *, struct sock *, struct sk_buff *))\r\n{\r\nunsigned int mtu = ip_skb_dst_mtu(skb);\r\nstruct iphdr *iph = ip_hdr(skb);\r\nif (unlikely(((iph->frag_off & htons(IP_DF)) && !skb->ignore_df) ||\r\n(IPCB(skb)->frag_max_size &&\r\nIPCB(skb)->frag_max_size > mtu))) {\r\nIP_INC_STATS(net, IPSTATS_MIB_FRAGFAILS);\r\nkfree_skb(skb);\r\nreturn -EMSGSIZE;\r\n}\r\nreturn ip_do_fragment(net, sk, skb, output);\r\n}\r\nstatic unsigned int nf_bridge_mtu_reduction(const struct sk_buff *skb)\r\n{\r\nif (skb->nf_bridge->orig_proto == BRNF_PROTO_PPPOE)\r\nreturn PPPOE_SES_HLEN;\r\nreturn 0;\r\n}\r\nstatic int br_nf_dev_queue_xmit(struct net *net, struct sock *sk, struct sk_buff *skb)\r\n{\r\nstruct nf_bridge_info *nf_bridge;\r\nunsigned int mtu_reserved;\r\nmtu_reserved = nf_bridge_mtu_reduction(skb);\r\nif (skb_is_gso(skb) || skb->len + mtu_reserved <= skb->dev->mtu) {\r\nnf_bridge_info_free(skb);\r\nreturn br_dev_queue_push_xmit(net, sk, skb);\r\n}\r\nnf_bridge = nf_bridge_info_get(skb);\r\nif (IS_ENABLED(CONFIG_NF_DEFRAG_IPV4) &&\r\nskb->protocol == htons(ETH_P_IP)) {\r\nstruct brnf_frag_data *data;\r\nif (br_validate_ipv4(net, skb))\r\ngoto drop;\r\nIPCB(skb)->frag_max_size = nf_bridge->frag_max_size;\r\nnf_bridge_update_protocol(skb);\r\ndata = this_cpu_ptr(&brnf_frag_data_storage);\r\ndata->vlan_tci = skb->vlan_tci;\r\ndata->vlan_proto = skb->vlan_proto;\r\ndata->encap_size = nf_bridge_encap_header_len(skb);\r\ndata->size = ETH_HLEN + data->encap_size;\r\nskb_copy_from_linear_data_offset(skb, -data->size, data->mac,\r\ndata->size);\r\nreturn br_nf_ip_fragment(net, sk, skb, br_nf_push_frag_xmit);\r\n}\r\nif (IS_ENABLED(CONFIG_NF_DEFRAG_IPV6) &&\r\nskb->protocol == htons(ETH_P_IPV6)) {\r\nconst struct nf_ipv6_ops *v6ops = nf_get_ipv6_ops();\r\nstruct brnf_frag_data *data;\r\nif (br_validate_ipv6(net, skb))\r\ngoto drop;\r\nIP6CB(skb)->frag_max_size = nf_bridge->frag_max_size;\r\nnf_bridge_update_protocol(skb);\r\ndata = this_cpu_ptr(&brnf_frag_data_storage);\r\ndata->encap_size = nf_bridge_encap_header_len(skb);\r\ndata->size = ETH_HLEN + data->encap_size;\r\nskb_copy_from_linear_data_offset(skb, -data->size, data->mac,\r\ndata->size);\r\nif (v6ops)\r\nreturn v6ops->fragment(net, sk, skb, br_nf_push_frag_xmit);\r\nkfree_skb(skb);\r\nreturn -EMSGSIZE;\r\n}\r\nnf_bridge_info_free(skb);\r\nreturn br_dev_queue_push_xmit(net, sk, skb);\r\ndrop:\r\nkfree_skb(skb);\r\nreturn 0;\r\n}\r\nstatic unsigned int br_nf_post_routing(void *priv,\r\nstruct sk_buff *skb,\r\nconst struct nf_hook_state *state)\r\n{\r\nstruct nf_bridge_info *nf_bridge = nf_bridge_info_get(skb);\r\nstruct net_device *realoutdev = bridge_parent(skb->dev);\r\nu_int8_t pf;\r\nif (!nf_bridge || !nf_bridge->physoutdev)\r\nreturn NF_ACCEPT;\r\nif (!realoutdev)\r\nreturn NF_DROP;\r\nif (IS_IP(skb) || IS_VLAN_IP(skb) || IS_PPPOE_IP(skb))\r\npf = NFPROTO_IPV4;\r\nelse if (IS_IPV6(skb) || IS_VLAN_IPV6(skb) || IS_PPPOE_IPV6(skb))\r\npf = NFPROTO_IPV6;\r\nelse\r\nreturn NF_ACCEPT;\r\nif (skb->pkt_type == PACKET_OTHERHOST) {\r\nskb->pkt_type = PACKET_HOST;\r\nnf_bridge->pkt_otherhost = true;\r\n}\r\nnf_bridge_pull_encap_header(skb);\r\nif (pf == NFPROTO_IPV4)\r\nskb->protocol = htons(ETH_P_IP);\r\nelse\r\nskb->protocol = htons(ETH_P_IPV6);\r\nNF_HOOK(pf, NF_INET_POST_ROUTING, state->net, state->sk, skb,\r\nNULL, realoutdev,\r\nbr_nf_dev_queue_xmit);\r\nreturn NF_STOLEN;\r\n}\r\nstatic unsigned int ip_sabotage_in(void *priv,\r\nstruct sk_buff *skb,\r\nconst struct nf_hook_state *state)\r\n{\r\nif (skb->nf_bridge && !skb->nf_bridge->in_prerouting)\r\nreturn NF_STOP;\r\nreturn NF_ACCEPT;\r\n}\r\nstatic void br_nf_pre_routing_finish_bridge_slow(struct sk_buff *skb)\r\n{\r\nstruct nf_bridge_info *nf_bridge = nf_bridge_info_get(skb);\r\nskb_pull(skb, ETH_HLEN);\r\nnf_bridge->bridged_dnat = 0;\r\nBUILD_BUG_ON(sizeof(nf_bridge->neigh_header) != (ETH_HLEN - ETH_ALEN));\r\nskb_copy_to_linear_data_offset(skb, -(ETH_HLEN - ETH_ALEN),\r\nnf_bridge->neigh_header,\r\nETH_HLEN - ETH_ALEN);\r\nskb->dev = nf_bridge->physindev;\r\nnf_bridge->physoutdev = NULL;\r\nbr_handle_frame_finish(dev_net(skb->dev), NULL, skb);\r\n}\r\nstatic int br_nf_dev_xmit(struct sk_buff *skb)\r\n{\r\nif (skb->nf_bridge && skb->nf_bridge->bridged_dnat) {\r\nbr_nf_pre_routing_finish_bridge_slow(skb);\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}\r\nvoid br_netfilter_enable(void)\r\n{\r\n}\r\nstatic\r\nint brnf_sysctl_call_tables(struct ctl_table *ctl, int write,\r\nvoid __user *buffer, size_t *lenp, loff_t *ppos)\r\n{\r\nint ret;\r\nret = proc_dointvec(ctl, write, buffer, lenp, ppos);\r\nif (write && *(int *)(ctl->data))\r\n*(int *)(ctl->data) = 1;\r\nreturn ret;\r\n}\r\nstatic int __init br_netfilter_init(void)\r\n{\r\nint ret;\r\nret = nf_register_hooks(br_nf_ops, ARRAY_SIZE(br_nf_ops));\r\nif (ret < 0)\r\nreturn ret;\r\n#ifdef CONFIG_SYSCTL\r\nbrnf_sysctl_header = register_net_sysctl(&init_net, "net/bridge", brnf_table);\r\nif (brnf_sysctl_header == NULL) {\r\nprintk(KERN_WARNING\r\n"br_netfilter: can't register to sysctl.\n");\r\nnf_unregister_hooks(br_nf_ops, ARRAY_SIZE(br_nf_ops));\r\nreturn -ENOMEM;\r\n}\r\n#endif\r\nRCU_INIT_POINTER(nf_br_ops, &br_ops);\r\nprintk(KERN_NOTICE "Bridge firewalling registered\n");\r\nreturn 0;\r\n}\r\nstatic void __exit br_netfilter_fini(void)\r\n{\r\nRCU_INIT_POINTER(nf_br_ops, NULL);\r\nnf_unregister_hooks(br_nf_ops, ARRAY_SIZE(br_nf_ops));\r\n#ifdef CONFIG_SYSCTL\r\nunregister_net_sysctl_table(brnf_sysctl_header);\r\n#endif\r\n}
