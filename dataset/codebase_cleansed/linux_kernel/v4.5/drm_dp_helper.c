static u8 dp_link_status(const u8 link_status[DP_LINK_STATUS_SIZE], int r)\r\n{\r\nreturn link_status[r - DP_LANE0_1_STATUS];\r\n}\r\nstatic u8 dp_get_lane_status(const u8 link_status[DP_LINK_STATUS_SIZE],\r\nint lane)\r\n{\r\nint i = DP_LANE0_1_STATUS + (lane >> 1);\r\nint s = (lane & 1) * 4;\r\nu8 l = dp_link_status(link_status, i);\r\nreturn (l >> s) & 0xf;\r\n}\r\nbool drm_dp_channel_eq_ok(const u8 link_status[DP_LINK_STATUS_SIZE],\r\nint lane_count)\r\n{\r\nu8 lane_align;\r\nu8 lane_status;\r\nint lane;\r\nlane_align = dp_link_status(link_status,\r\nDP_LANE_ALIGN_STATUS_UPDATED);\r\nif ((lane_align & DP_INTERLANE_ALIGN_DONE) == 0)\r\nreturn false;\r\nfor (lane = 0; lane < lane_count; lane++) {\r\nlane_status = dp_get_lane_status(link_status, lane);\r\nif ((lane_status & DP_CHANNEL_EQ_BITS) != DP_CHANNEL_EQ_BITS)\r\nreturn false;\r\n}\r\nreturn true;\r\n}\r\nbool drm_dp_clock_recovery_ok(const u8 link_status[DP_LINK_STATUS_SIZE],\r\nint lane_count)\r\n{\r\nint lane;\r\nu8 lane_status;\r\nfor (lane = 0; lane < lane_count; lane++) {\r\nlane_status = dp_get_lane_status(link_status, lane);\r\nif ((lane_status & DP_LANE_CR_DONE) == 0)\r\nreturn false;\r\n}\r\nreturn true;\r\n}\r\nu8 drm_dp_get_adjust_request_voltage(const u8 link_status[DP_LINK_STATUS_SIZE],\r\nint lane)\r\n{\r\nint i = DP_ADJUST_REQUEST_LANE0_1 + (lane >> 1);\r\nint s = ((lane & 1) ?\r\nDP_ADJUST_VOLTAGE_SWING_LANE1_SHIFT :\r\nDP_ADJUST_VOLTAGE_SWING_LANE0_SHIFT);\r\nu8 l = dp_link_status(link_status, i);\r\nreturn ((l >> s) & 0x3) << DP_TRAIN_VOLTAGE_SWING_SHIFT;\r\n}\r\nu8 drm_dp_get_adjust_request_pre_emphasis(const u8 link_status[DP_LINK_STATUS_SIZE],\r\nint lane)\r\n{\r\nint i = DP_ADJUST_REQUEST_LANE0_1 + (lane >> 1);\r\nint s = ((lane & 1) ?\r\nDP_ADJUST_PRE_EMPHASIS_LANE1_SHIFT :\r\nDP_ADJUST_PRE_EMPHASIS_LANE0_SHIFT);\r\nu8 l = dp_link_status(link_status, i);\r\nreturn ((l >> s) & 0x3) << DP_TRAIN_PRE_EMPHASIS_SHIFT;\r\n}\r\nvoid drm_dp_link_train_clock_recovery_delay(const u8 dpcd[DP_RECEIVER_CAP_SIZE]) {\r\nif (dpcd[DP_TRAINING_AUX_RD_INTERVAL] == 0)\r\nudelay(100);\r\nelse\r\nmdelay(dpcd[DP_TRAINING_AUX_RD_INTERVAL] * 4);\r\n}\r\nvoid drm_dp_link_train_channel_eq_delay(const u8 dpcd[DP_RECEIVER_CAP_SIZE]) {\r\nif (dpcd[DP_TRAINING_AUX_RD_INTERVAL] == 0)\r\nudelay(400);\r\nelse\r\nmdelay(dpcd[DP_TRAINING_AUX_RD_INTERVAL] * 4);\r\n}\r\nu8 drm_dp_link_rate_to_bw_code(int link_rate)\r\n{\r\nswitch (link_rate) {\r\ncase 162000:\r\ndefault:\r\nreturn DP_LINK_BW_1_62;\r\ncase 270000:\r\nreturn DP_LINK_BW_2_7;\r\ncase 540000:\r\nreturn DP_LINK_BW_5_4;\r\n}\r\n}\r\nint drm_dp_bw_code_to_link_rate(u8 link_bw)\r\n{\r\nswitch (link_bw) {\r\ncase DP_LINK_BW_1_62:\r\ndefault:\r\nreturn 162000;\r\ncase DP_LINK_BW_2_7:\r\nreturn 270000;\r\ncase DP_LINK_BW_5_4:\r\nreturn 540000;\r\n}\r\n}\r\nstatic int drm_dp_dpcd_access(struct drm_dp_aux *aux, u8 request,\r\nunsigned int offset, void *buffer, size_t size)\r\n{\r\nstruct drm_dp_aux_msg msg;\r\nunsigned int retry;\r\nint err;\r\nmemset(&msg, 0, sizeof(msg));\r\nmsg.address = offset;\r\nmsg.request = request;\r\nmsg.buffer = buffer;\r\nmsg.size = size;\r\nfor (retry = 0; retry < 32; retry++) {\r\nmutex_lock(&aux->hw_mutex);\r\nerr = aux->transfer(aux, &msg);\r\nmutex_unlock(&aux->hw_mutex);\r\nif (err < 0) {\r\nif (err == -EBUSY)\r\ncontinue;\r\nreturn err;\r\n}\r\nswitch (msg.reply & DP_AUX_NATIVE_REPLY_MASK) {\r\ncase DP_AUX_NATIVE_REPLY_ACK:\r\nif (err < size)\r\nreturn -EPROTO;\r\nreturn err;\r\ncase DP_AUX_NATIVE_REPLY_NACK:\r\nreturn -EIO;\r\ncase DP_AUX_NATIVE_REPLY_DEFER:\r\nusleep_range(AUX_RETRY_INTERVAL, AUX_RETRY_INTERVAL + 100);\r\nbreak;\r\n}\r\n}\r\nDRM_DEBUG_KMS("too many retries, giving up\n");\r\nreturn -EIO;\r\n}\r\nssize_t drm_dp_dpcd_read(struct drm_dp_aux *aux, unsigned int offset,\r\nvoid *buffer, size_t size)\r\n{\r\nreturn drm_dp_dpcd_access(aux, DP_AUX_NATIVE_READ, offset, buffer,\r\nsize);\r\n}\r\nssize_t drm_dp_dpcd_write(struct drm_dp_aux *aux, unsigned int offset,\r\nvoid *buffer, size_t size)\r\n{\r\nreturn drm_dp_dpcd_access(aux, DP_AUX_NATIVE_WRITE, offset, buffer,\r\nsize);\r\n}\r\nint drm_dp_dpcd_read_link_status(struct drm_dp_aux *aux,\r\nu8 status[DP_LINK_STATUS_SIZE])\r\n{\r\nreturn drm_dp_dpcd_read(aux, DP_LANE0_1_STATUS, status,\r\nDP_LINK_STATUS_SIZE);\r\n}\r\nint drm_dp_link_probe(struct drm_dp_aux *aux, struct drm_dp_link *link)\r\n{\r\nu8 values[3];\r\nint err;\r\nmemset(link, 0, sizeof(*link));\r\nerr = drm_dp_dpcd_read(aux, DP_DPCD_REV, values, sizeof(values));\r\nif (err < 0)\r\nreturn err;\r\nlink->revision = values[0];\r\nlink->rate = drm_dp_bw_code_to_link_rate(values[1]);\r\nlink->num_lanes = values[2] & DP_MAX_LANE_COUNT_MASK;\r\nif (values[2] & DP_ENHANCED_FRAME_CAP)\r\nlink->capabilities |= DP_LINK_CAP_ENHANCED_FRAMING;\r\nreturn 0;\r\n}\r\nint drm_dp_link_power_up(struct drm_dp_aux *aux, struct drm_dp_link *link)\r\n{\r\nu8 value;\r\nint err;\r\nif (link->revision < 0x11)\r\nreturn 0;\r\nerr = drm_dp_dpcd_readb(aux, DP_SET_POWER, &value);\r\nif (err < 0)\r\nreturn err;\r\nvalue &= ~DP_SET_POWER_MASK;\r\nvalue |= DP_SET_POWER_D0;\r\nerr = drm_dp_dpcd_writeb(aux, DP_SET_POWER, value);\r\nif (err < 0)\r\nreturn err;\r\nusleep_range(1000, 2000);\r\nreturn 0;\r\n}\r\nint drm_dp_link_power_down(struct drm_dp_aux *aux, struct drm_dp_link *link)\r\n{\r\nu8 value;\r\nint err;\r\nif (link->revision < 0x11)\r\nreturn 0;\r\nerr = drm_dp_dpcd_readb(aux, DP_SET_POWER, &value);\r\nif (err < 0)\r\nreturn err;\r\nvalue &= ~DP_SET_POWER_MASK;\r\nvalue |= DP_SET_POWER_D3;\r\nerr = drm_dp_dpcd_writeb(aux, DP_SET_POWER, value);\r\nif (err < 0)\r\nreturn err;\r\nreturn 0;\r\n}\r\nint drm_dp_link_configure(struct drm_dp_aux *aux, struct drm_dp_link *link)\r\n{\r\nu8 values[2];\r\nint err;\r\nvalues[0] = drm_dp_link_rate_to_bw_code(link->rate);\r\nvalues[1] = link->num_lanes;\r\nif (link->capabilities & DP_LINK_CAP_ENHANCED_FRAMING)\r\nvalues[1] |= DP_LANE_COUNT_ENHANCED_FRAME_EN;\r\nerr = drm_dp_dpcd_write(aux, DP_LINK_BW_SET, values, sizeof(values));\r\nif (err < 0)\r\nreturn err;\r\nreturn 0;\r\n}\r\nstatic u32 drm_dp_i2c_functionality(struct i2c_adapter *adapter)\r\n{\r\nreturn I2C_FUNC_I2C | I2C_FUNC_SMBUS_EMUL |\r\nI2C_FUNC_SMBUS_READ_BLOCK_DATA |\r\nI2C_FUNC_SMBUS_BLOCK_PROC_CALL |\r\nI2C_FUNC_10BIT_ADDR;\r\n}\r\nstatic void drm_dp_i2c_msg_write_status_update(struct drm_dp_aux_msg *msg)\r\n{\r\nif ((msg->request & ~DP_AUX_I2C_MOT) == DP_AUX_I2C_WRITE) {\r\nmsg->request &= DP_AUX_I2C_MOT;\r\nmsg->request |= DP_AUX_I2C_WRITE_STATUS_UPDATE;\r\n}\r\n}\r\nstatic int drm_dp_aux_req_duration(const struct drm_dp_aux_msg *msg)\r\n{\r\nint len = AUX_PRECHARGE_LEN + AUX_SYNC_LEN + AUX_STOP_LEN +\r\nAUX_CMD_LEN + AUX_ADDRESS_LEN + AUX_LENGTH_LEN;\r\nif ((msg->request & DP_AUX_I2C_READ) == 0)\r\nlen += msg->size * 8;\r\nreturn len;\r\n}\r\nstatic int drm_dp_aux_reply_duration(const struct drm_dp_aux_msg *msg)\r\n{\r\nint len = AUX_PRECHARGE_LEN + AUX_SYNC_LEN + AUX_STOP_LEN +\r\nAUX_CMD_LEN + AUX_REPLY_PAD_LEN;\r\nif (msg->request & DP_AUX_I2C_READ)\r\nlen += msg->size * 8;\r\nreturn len;\r\n}\r\nstatic int drm_dp_i2c_msg_duration(const struct drm_dp_aux_msg *msg,\r\nint i2c_speed_khz)\r\n{\r\nreturn DIV_ROUND_UP((I2C_START_LEN + I2C_ADDR_LEN +\r\nmsg->size * I2C_DATA_LEN +\r\nI2C_STOP_LEN) * 1000, i2c_speed_khz);\r\n}\r\nstatic int drm_dp_i2c_retry_count(const struct drm_dp_aux_msg *msg,\r\nint i2c_speed_khz)\r\n{\r\nint aux_time_us = drm_dp_aux_req_duration(msg) +\r\ndrm_dp_aux_reply_duration(msg);\r\nint i2c_time_us = drm_dp_i2c_msg_duration(msg, i2c_speed_khz);\r\nreturn DIV_ROUND_UP(i2c_time_us, aux_time_us + AUX_RETRY_INTERVAL);\r\n}\r\nstatic int drm_dp_i2c_do_msg(struct drm_dp_aux *aux, struct drm_dp_aux_msg *msg)\r\n{\r\nunsigned int retry, defer_i2c;\r\nint ret;\r\nint max_retries = max(7, drm_dp_i2c_retry_count(msg, dp_aux_i2c_speed_khz));\r\nfor (retry = 0, defer_i2c = 0; retry < (max_retries + defer_i2c); retry++) {\r\nmutex_lock(&aux->hw_mutex);\r\nret = aux->transfer(aux, msg);\r\nmutex_unlock(&aux->hw_mutex);\r\nif (ret < 0) {\r\nif (ret == -EBUSY)\r\ncontinue;\r\nDRM_DEBUG_KMS("transaction failed: %d\n", ret);\r\nreturn ret;\r\n}\r\nswitch (msg->reply & DP_AUX_NATIVE_REPLY_MASK) {\r\ncase DP_AUX_NATIVE_REPLY_ACK:\r\nbreak;\r\ncase DP_AUX_NATIVE_REPLY_NACK:\r\nDRM_DEBUG_KMS("native nack (result=%d, size=%zu)\n", ret, msg->size);\r\nreturn -EREMOTEIO;\r\ncase DP_AUX_NATIVE_REPLY_DEFER:\r\nDRM_DEBUG_KMS("native defer\n");\r\nusleep_range(AUX_RETRY_INTERVAL, AUX_RETRY_INTERVAL + 100);\r\ncontinue;\r\ndefault:\r\nDRM_ERROR("invalid native reply %#04x\n", msg->reply);\r\nreturn -EREMOTEIO;\r\n}\r\nswitch (msg->reply & DP_AUX_I2C_REPLY_MASK) {\r\ncase DP_AUX_I2C_REPLY_ACK:\r\nif (ret != msg->size)\r\ndrm_dp_i2c_msg_write_status_update(msg);\r\nreturn ret;\r\ncase DP_AUX_I2C_REPLY_NACK:\r\nDRM_DEBUG_KMS("I2C nack (result=%d, size=%zu\n", ret, msg->size);\r\naux->i2c_nack_count++;\r\nreturn -EREMOTEIO;\r\ncase DP_AUX_I2C_REPLY_DEFER:\r\nDRM_DEBUG_KMS("I2C defer\n");\r\naux->i2c_defer_count++;\r\nif (defer_i2c < 7)\r\ndefer_i2c++;\r\nusleep_range(AUX_RETRY_INTERVAL, AUX_RETRY_INTERVAL + 100);\r\ndrm_dp_i2c_msg_write_status_update(msg);\r\ncontinue;\r\ndefault:\r\nDRM_ERROR("invalid I2C reply %#04x\n", msg->reply);\r\nreturn -EREMOTEIO;\r\n}\r\n}\r\nDRM_DEBUG_KMS("too many retries, giving up\n");\r\nreturn -EREMOTEIO;\r\n}\r\nstatic void drm_dp_i2c_msg_set_request(struct drm_dp_aux_msg *msg,\r\nconst struct i2c_msg *i2c_msg)\r\n{\r\nmsg->request = (i2c_msg->flags & I2C_M_RD) ?\r\nDP_AUX_I2C_READ : DP_AUX_I2C_WRITE;\r\nmsg->request |= DP_AUX_I2C_MOT;\r\n}\r\nstatic int drm_dp_i2c_drain_msg(struct drm_dp_aux *aux, struct drm_dp_aux_msg *orig_msg)\r\n{\r\nint err, ret = orig_msg->size;\r\nstruct drm_dp_aux_msg msg = *orig_msg;\r\nwhile (msg.size > 0) {\r\nerr = drm_dp_i2c_do_msg(aux, &msg);\r\nif (err <= 0)\r\nreturn err == 0 ? -EPROTO : err;\r\nif (err < msg.size && err < ret) {\r\nDRM_DEBUG_KMS("Partial I2C reply: requested %zu bytes got %d bytes\n",\r\nmsg.size, err);\r\nret = err;\r\n}\r\nmsg.size -= err;\r\nmsg.buffer += err;\r\n}\r\nreturn ret;\r\n}\r\nstatic int drm_dp_i2c_xfer(struct i2c_adapter *adapter, struct i2c_msg *msgs,\r\nint num)\r\n{\r\nstruct drm_dp_aux *aux = adapter->algo_data;\r\nunsigned int i, j;\r\nunsigned transfer_size;\r\nstruct drm_dp_aux_msg msg;\r\nint err = 0;\r\ndp_aux_i2c_transfer_size = clamp(dp_aux_i2c_transfer_size, 1, DP_AUX_MAX_PAYLOAD_BYTES);\r\nmemset(&msg, 0, sizeof(msg));\r\nfor (i = 0; i < num; i++) {\r\nmsg.address = msgs[i].addr;\r\ndrm_dp_i2c_msg_set_request(&msg, &msgs[i]);\r\nmsg.buffer = NULL;\r\nmsg.size = 0;\r\nerr = drm_dp_i2c_do_msg(aux, &msg);\r\ndrm_dp_i2c_msg_set_request(&msg, &msgs[i]);\r\nif (err < 0)\r\nbreak;\r\ntransfer_size = dp_aux_i2c_transfer_size;\r\nfor (j = 0; j < msgs[i].len; j += msg.size) {\r\nmsg.buffer = msgs[i].buf + j;\r\nmsg.size = min(transfer_size, msgs[i].len - j);\r\nerr = drm_dp_i2c_drain_msg(aux, &msg);\r\ndrm_dp_i2c_msg_set_request(&msg, &msgs[i]);\r\nif (err < 0)\r\nbreak;\r\ntransfer_size = err;\r\n}\r\nif (err < 0)\r\nbreak;\r\n}\r\nif (err >= 0)\r\nerr = num;\r\nmsg.request &= ~DP_AUX_I2C_MOT;\r\nmsg.buffer = NULL;\r\nmsg.size = 0;\r\n(void)drm_dp_i2c_do_msg(aux, &msg);\r\nreturn err;\r\n}\r\nint drm_dp_aux_register(struct drm_dp_aux *aux)\r\n{\r\nmutex_init(&aux->hw_mutex);\r\naux->ddc.algo = &drm_dp_i2c_algo;\r\naux->ddc.algo_data = aux;\r\naux->ddc.retries = 3;\r\naux->ddc.class = I2C_CLASS_DDC;\r\naux->ddc.owner = THIS_MODULE;\r\naux->ddc.dev.parent = aux->dev;\r\naux->ddc.dev.of_node = aux->dev->of_node;\r\nstrlcpy(aux->ddc.name, aux->name ? aux->name : dev_name(aux->dev),\r\nsizeof(aux->ddc.name));\r\nreturn i2c_add_adapter(&aux->ddc);\r\n}\r\nvoid drm_dp_aux_unregister(struct drm_dp_aux *aux)\r\n{\r\ni2c_del_adapter(&aux->ddc);\r\n}
