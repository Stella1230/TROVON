static inline u16 qed_attn_update_idx(struct qed_hwfn *p_hwfn,\r\nstruct qed_sb_attn_info *p_sb_desc)\r\n{\r\nu16 rc = 0;\r\nu16 index;\r\nmmiowb();\r\nindex = le16_to_cpu(p_sb_desc->sb_attn->sb_index);\r\nif (p_sb_desc->index != index) {\r\np_sb_desc->index = index;\r\nrc = QED_SB_ATT_IDX;\r\n}\r\nmmiowb();\r\nreturn rc;\r\n}\r\nstatic int qed_int_assertion(struct qed_hwfn *p_hwfn,\r\nu16 asserted_bits)\r\n{\r\nstruct qed_sb_attn_info *sb_attn_sw = p_hwfn->p_sb_attn;\r\nu32 igu_mask;\r\nigu_mask = qed_rd(p_hwfn, p_hwfn->p_dpc_ptt,\r\nIGU_REG_ATTENTION_ENABLE);\r\nDP_VERBOSE(p_hwfn, NETIF_MSG_INTR, "IGU mask: 0x%08x --> 0x%08x\n",\r\nigu_mask, igu_mask & ~(asserted_bits & ATTN_BITS_MASKABLE));\r\nigu_mask &= ~(asserted_bits & ATTN_BITS_MASKABLE);\r\nqed_wr(p_hwfn, p_hwfn->p_dpc_ptt, IGU_REG_ATTENTION_ENABLE, igu_mask);\r\nDP_VERBOSE(p_hwfn, NETIF_MSG_INTR,\r\n"inner known ATTN state: 0x%04x --> 0x%04x\n",\r\nsb_attn_sw->known_attn,\r\nsb_attn_sw->known_attn | asserted_bits);\r\nsb_attn_sw->known_attn |= asserted_bits;\r\nif (asserted_bits & 0x100) {\r\nqed_mcp_handle_events(p_hwfn, p_hwfn->p_dpc_ptt);\r\nqed_wr(p_hwfn, p_hwfn->p_dpc_ptt,\r\nsb_attn_sw->mfw_attn_addr, 0);\r\n}\r\nDIRECT_REG_WR((u8 __iomem *)p_hwfn->regview +\r\nGTT_BAR0_MAP_REG_IGU_CMD +\r\n((IGU_CMD_ATTN_BIT_SET_UPPER -\r\nIGU_CMD_INT_ACK_BASE) << 3),\r\n(u32)asserted_bits);\r\nDP_VERBOSE(p_hwfn, NETIF_MSG_INTR, "set cmd IGU: 0x%04x\n",\r\nasserted_bits);\r\nreturn 0;\r\n}\r\nstatic int qed_int_deassertion(struct qed_hwfn *p_hwfn,\r\nu16 deasserted_bits)\r\n{\r\nstruct qed_sb_attn_info *sb_attn_sw = p_hwfn->p_sb_attn;\r\nu32 aeu_mask;\r\nif (deasserted_bits != 0x100)\r\nDP_ERR(p_hwfn, "Unexpected - non-link deassertion\n");\r\nDIRECT_REG_WR((u8 __iomem *)p_hwfn->regview +\r\nGTT_BAR0_MAP_REG_IGU_CMD +\r\n((IGU_CMD_ATTN_BIT_CLR_UPPER -\r\nIGU_CMD_INT_ACK_BASE) << 3),\r\n~((u32)deasserted_bits));\r\naeu_mask = qed_rd(p_hwfn, p_hwfn->p_dpc_ptt,\r\nIGU_REG_ATTENTION_ENABLE);\r\naeu_mask |= (deasserted_bits & ATTN_BITS_MASKABLE);\r\nqed_wr(p_hwfn, p_hwfn->p_dpc_ptt, IGU_REG_ATTENTION_ENABLE, aeu_mask);\r\nsb_attn_sw->known_attn &= ~deasserted_bits;\r\nreturn 0;\r\n}\r\nstatic int qed_int_attentions(struct qed_hwfn *p_hwfn)\r\n{\r\nstruct qed_sb_attn_info *p_sb_attn_sw = p_hwfn->p_sb_attn;\r\nstruct atten_status_block *p_sb_attn = p_sb_attn_sw->sb_attn;\r\nu32 attn_bits = 0, attn_acks = 0;\r\nu16 asserted_bits, deasserted_bits;\r\n__le16 index;\r\nint rc = 0;\r\ndo {\r\nindex = p_sb_attn->sb_index;\r\nattn_bits = le32_to_cpu(p_sb_attn->atten_bits);\r\nattn_acks = le32_to_cpu(p_sb_attn->atten_ack);\r\n} while (index != p_sb_attn->sb_index);\r\np_sb_attn->sb_index = index;\r\nasserted_bits = (attn_bits & ~attn_acks & ATTN_STATE_BITS) &\r\n~p_sb_attn_sw->known_attn;\r\ndeasserted_bits = (~attn_bits & attn_acks & ATTN_STATE_BITS) &\r\np_sb_attn_sw->known_attn;\r\nif ((asserted_bits & ~0x100) || (deasserted_bits & ~0x100)) {\r\nDP_INFO(p_hwfn,\r\n"Attention: Index: 0x%04x, Bits: 0x%08x, Acks: 0x%08x, asserted: 0x%04x, De-asserted 0x%04x [Prev. known: 0x%04x]\n",\r\nindex, attn_bits, attn_acks, asserted_bits,\r\ndeasserted_bits, p_sb_attn_sw->known_attn);\r\n} else if (asserted_bits == 0x100) {\r\nDP_INFO(p_hwfn,\r\n"MFW indication via attention\n");\r\n} else {\r\nDP_VERBOSE(p_hwfn, NETIF_MSG_INTR,\r\n"MFW indication [deassertion]\n");\r\n}\r\nif (asserted_bits) {\r\nrc = qed_int_assertion(p_hwfn, asserted_bits);\r\nif (rc)\r\nreturn rc;\r\n}\r\nif (deasserted_bits) {\r\nrc = qed_int_deassertion(p_hwfn, deasserted_bits);\r\nif (rc)\r\nreturn rc;\r\n}\r\nreturn rc;\r\n}\r\nstatic void qed_sb_ack_attn(struct qed_hwfn *p_hwfn,\r\nvoid __iomem *igu_addr,\r\nu32 ack_cons)\r\n{\r\nstruct igu_prod_cons_update igu_ack = { 0 };\r\nigu_ack.sb_id_and_flags =\r\n((ack_cons << IGU_PROD_CONS_UPDATE_SB_INDEX_SHIFT) |\r\n(1 << IGU_PROD_CONS_UPDATE_UPDATE_FLAG_SHIFT) |\r\n(IGU_INT_NOP << IGU_PROD_CONS_UPDATE_ENABLE_INT_SHIFT) |\r\n(IGU_SEG_ACCESS_ATTN <<\r\nIGU_PROD_CONS_UPDATE_SEGMENT_ACCESS_SHIFT));\r\nDIRECT_REG_WR(igu_addr, igu_ack.sb_id_and_flags);\r\nmmiowb();\r\nbarrier();\r\n}\r\nvoid qed_int_sp_dpc(unsigned long hwfn_cookie)\r\n{\r\nstruct qed_hwfn *p_hwfn = (struct qed_hwfn *)hwfn_cookie;\r\nstruct qed_pi_info *pi_info = NULL;\r\nstruct qed_sb_attn_info *sb_attn;\r\nstruct qed_sb_info *sb_info;\r\nint arr_size;\r\nu16 rc = 0;\r\nif (!p_hwfn->p_sp_sb) {\r\nDP_ERR(p_hwfn->cdev, "DPC called - no p_sp_sb\n");\r\nreturn;\r\n}\r\nsb_info = &p_hwfn->p_sp_sb->sb_info;\r\narr_size = ARRAY_SIZE(p_hwfn->p_sp_sb->pi_info_arr);\r\nif (!sb_info) {\r\nDP_ERR(p_hwfn->cdev,\r\n"Status block is NULL - cannot ack interrupts\n");\r\nreturn;\r\n}\r\nif (!p_hwfn->p_sb_attn) {\r\nDP_ERR(p_hwfn->cdev, "DPC called - no p_sb_attn");\r\nreturn;\r\n}\r\nsb_attn = p_hwfn->p_sb_attn;\r\nDP_VERBOSE(p_hwfn, NETIF_MSG_INTR, "DPC Called! (hwfn %p %d)\n",\r\np_hwfn, p_hwfn->my_id);\r\nqed_sb_ack(sb_info, IGU_INT_DISABLE, 0);\r\nif (!sb_info->sb_virt) {\r\nDP_ERR(\r\np_hwfn->cdev,\r\n"Interrupt Status block is NULL - cannot check for new interrupts!\n");\r\n} else {\r\nu32 tmp_index = sb_info->sb_ack;\r\nrc = qed_sb_update_sb_idx(sb_info);\r\nDP_VERBOSE(p_hwfn->cdev, NETIF_MSG_INTR,\r\n"Interrupt indices: 0x%08x --> 0x%08x\n",\r\ntmp_index, sb_info->sb_ack);\r\n}\r\nif (!sb_attn || !sb_attn->sb_attn) {\r\nDP_ERR(\r\np_hwfn->cdev,\r\n"Attentions Status block is NULL - cannot check for new attentions!\n");\r\n} else {\r\nu16 tmp_index = sb_attn->index;\r\nrc |= qed_attn_update_idx(p_hwfn, sb_attn);\r\nDP_VERBOSE(p_hwfn->cdev, NETIF_MSG_INTR,\r\n"Attention indices: 0x%08x --> 0x%08x\n",\r\ntmp_index, sb_attn->index);\r\n}\r\nif (!(rc & QED_SB_EVENT_MASK)) {\r\nqed_sb_ack(sb_info, IGU_INT_ENABLE, 1);\r\nreturn;\r\n}\r\nif (!p_hwfn->p_dpc_ptt) {\r\nDP_NOTICE(p_hwfn->cdev, "Failed to allocate PTT\n");\r\nqed_sb_ack(sb_info, IGU_INT_ENABLE, 1);\r\nreturn;\r\n}\r\nif (rc & QED_SB_ATT_IDX)\r\nqed_int_attentions(p_hwfn);\r\nif (rc & QED_SB_IDX) {\r\nint pi;\r\nfor (pi = 0; pi < arr_size; pi++) {\r\npi_info = &p_hwfn->p_sp_sb->pi_info_arr[pi];\r\nif (pi_info->comp_cb)\r\npi_info->comp_cb(p_hwfn, pi_info->cookie);\r\n}\r\n}\r\nif (sb_attn && (rc & QED_SB_ATT_IDX))\r\nqed_sb_ack_attn(p_hwfn, sb_info->igu_addr, sb_attn->index);\r\nqed_sb_ack(sb_info, IGU_INT_ENABLE, 1);\r\n}\r\nstatic void qed_int_sb_attn_free(struct qed_hwfn *p_hwfn)\r\n{\r\nstruct qed_dev *cdev = p_hwfn->cdev;\r\nstruct qed_sb_attn_info *p_sb = p_hwfn->p_sb_attn;\r\nif (p_sb) {\r\nif (p_sb->sb_attn)\r\ndma_free_coherent(&cdev->pdev->dev,\r\nSB_ATTN_ALIGNED_SIZE(p_hwfn),\r\np_sb->sb_attn,\r\np_sb->sb_phys);\r\nkfree(p_sb);\r\n}\r\n}\r\nstatic void qed_int_sb_attn_setup(struct qed_hwfn *p_hwfn,\r\nstruct qed_ptt *p_ptt)\r\n{\r\nstruct qed_sb_attn_info *sb_info = p_hwfn->p_sb_attn;\r\nmemset(sb_info->sb_attn, 0, sizeof(*sb_info->sb_attn));\r\nsb_info->index = 0;\r\nsb_info->known_attn = 0;\r\nqed_wr(p_hwfn, p_ptt, IGU_REG_ATTN_MSG_ADDR_L,\r\nlower_32_bits(p_hwfn->p_sb_attn->sb_phys));\r\nqed_wr(p_hwfn, p_ptt, IGU_REG_ATTN_MSG_ADDR_H,\r\nupper_32_bits(p_hwfn->p_sb_attn->sb_phys));\r\n}\r\nstatic void qed_int_sb_attn_init(struct qed_hwfn *p_hwfn,\r\nstruct qed_ptt *p_ptt,\r\nvoid *sb_virt_addr,\r\ndma_addr_t sb_phy_addr)\r\n{\r\nstruct qed_sb_attn_info *sb_info = p_hwfn->p_sb_attn;\r\nsb_info->sb_attn = sb_virt_addr;\r\nsb_info->sb_phys = sb_phy_addr;\r\nsb_info->mfw_attn_addr = (p_hwfn->rel_pf_id << 3) +\r\nMISC_REG_AEU_GENERAL_ATTN_0;\r\nqed_int_sb_attn_setup(p_hwfn, p_ptt);\r\n}\r\nstatic int qed_int_sb_attn_alloc(struct qed_hwfn *p_hwfn,\r\nstruct qed_ptt *p_ptt)\r\n{\r\nstruct qed_dev *cdev = p_hwfn->cdev;\r\nstruct qed_sb_attn_info *p_sb;\r\nvoid *p_virt;\r\ndma_addr_t p_phys = 0;\r\np_sb = kmalloc(sizeof(*p_sb), GFP_ATOMIC);\r\nif (!p_sb) {\r\nDP_NOTICE(cdev, "Failed to allocate `struct qed_sb_attn_info'\n");\r\nreturn -ENOMEM;\r\n}\r\np_virt = dma_alloc_coherent(&cdev->pdev->dev,\r\nSB_ATTN_ALIGNED_SIZE(p_hwfn),\r\n&p_phys, GFP_KERNEL);\r\nif (!p_virt) {\r\nDP_NOTICE(cdev, "Failed to allocate status block (attentions)\n");\r\nkfree(p_sb);\r\nreturn -ENOMEM;\r\n}\r\np_hwfn->p_sb_attn = p_sb;\r\nqed_int_sb_attn_init(p_hwfn, p_ptt, p_virt, p_phys);\r\nreturn 0;\r\n}\r\nvoid qed_init_cau_sb_entry(struct qed_hwfn *p_hwfn,\r\nstruct cau_sb_entry *p_sb_entry,\r\nu8 pf_id,\r\nu16 vf_number,\r\nu8 vf_valid)\r\n{\r\nu32 cau_state;\r\nmemset(p_sb_entry, 0, sizeof(*p_sb_entry));\r\nSET_FIELD(p_sb_entry->params, CAU_SB_ENTRY_PF_NUMBER, pf_id);\r\nSET_FIELD(p_sb_entry->params, CAU_SB_ENTRY_VF_NUMBER, vf_number);\r\nSET_FIELD(p_sb_entry->params, CAU_SB_ENTRY_VF_VALID, vf_valid);\r\nSET_FIELD(p_sb_entry->params, CAU_SB_ENTRY_SB_TIMESET0, 0x7F);\r\nSET_FIELD(p_sb_entry->params, CAU_SB_ENTRY_SB_TIMESET1, 0x7F);\r\nSET_FIELD(p_sb_entry->params, CAU_SB_ENTRY_TIMER_RES0,\r\nQED_CAU_DEF_RX_TIMER_RES);\r\nSET_FIELD(p_sb_entry->params, CAU_SB_ENTRY_TIMER_RES1,\r\nQED_CAU_DEF_TX_TIMER_RES);\r\ncau_state = CAU_HC_DISABLE_STATE;\r\nif (p_hwfn->cdev->int_coalescing_mode == QED_COAL_MODE_ENABLE) {\r\ncau_state = CAU_HC_ENABLE_STATE;\r\nif (!p_hwfn->cdev->rx_coalesce_usecs)\r\np_hwfn->cdev->rx_coalesce_usecs =\r\nQED_CAU_DEF_RX_USECS;\r\nif (!p_hwfn->cdev->tx_coalesce_usecs)\r\np_hwfn->cdev->tx_coalesce_usecs =\r\nQED_CAU_DEF_TX_USECS;\r\n}\r\nSET_FIELD(p_sb_entry->data, CAU_SB_ENTRY_STATE0, cau_state);\r\nSET_FIELD(p_sb_entry->data, CAU_SB_ENTRY_STATE1, cau_state);\r\n}\r\nvoid qed_int_cau_conf_sb(struct qed_hwfn *p_hwfn,\r\nstruct qed_ptt *p_ptt,\r\ndma_addr_t sb_phys,\r\nu16 igu_sb_id,\r\nu16 vf_number,\r\nu8 vf_valid)\r\n{\r\nstruct cau_sb_entry sb_entry;\r\nu32 val;\r\nqed_init_cau_sb_entry(p_hwfn, &sb_entry, p_hwfn->rel_pf_id,\r\nvf_number, vf_valid);\r\nif (p_hwfn->hw_init_done) {\r\nval = CAU_REG_SB_ADDR_MEMORY + igu_sb_id * sizeof(u64);\r\nqed_wr(p_hwfn, p_ptt, val, lower_32_bits(sb_phys));\r\nqed_wr(p_hwfn, p_ptt, val + sizeof(u32),\r\nupper_32_bits(sb_phys));\r\nval = CAU_REG_SB_VAR_MEMORY + igu_sb_id * sizeof(u64);\r\nqed_wr(p_hwfn, p_ptt, val, sb_entry.data);\r\nqed_wr(p_hwfn, p_ptt, val + sizeof(u32), sb_entry.params);\r\n} else {\r\nSTORE_RT_REG_AGG(p_hwfn,\r\nCAU_REG_SB_ADDR_MEMORY_RT_OFFSET +\r\nigu_sb_id * 2,\r\nsb_phys);\r\nSTORE_RT_REG_AGG(p_hwfn,\r\nCAU_REG_SB_VAR_MEMORY_RT_OFFSET +\r\nigu_sb_id * 2,\r\nsb_entry);\r\n}\r\nif (p_hwfn->cdev->int_coalescing_mode == QED_COAL_MODE_ENABLE) {\r\nu8 timeset = p_hwfn->cdev->rx_coalesce_usecs >>\r\n(QED_CAU_DEF_RX_TIMER_RES + 1);\r\nu8 num_tc = 1, i;\r\nqed_int_cau_conf_pi(p_hwfn, p_ptt, igu_sb_id, RX_PI,\r\nQED_COAL_RX_STATE_MACHINE,\r\ntimeset);\r\ntimeset = p_hwfn->cdev->tx_coalesce_usecs >>\r\n(QED_CAU_DEF_TX_TIMER_RES + 1);\r\nfor (i = 0; i < num_tc; i++) {\r\nqed_int_cau_conf_pi(p_hwfn, p_ptt,\r\nigu_sb_id, TX_PI(i),\r\nQED_COAL_TX_STATE_MACHINE,\r\ntimeset);\r\n}\r\n}\r\n}\r\nvoid qed_int_cau_conf_pi(struct qed_hwfn *p_hwfn,\r\nstruct qed_ptt *p_ptt,\r\nu16 igu_sb_id,\r\nu32 pi_index,\r\nenum qed_coalescing_fsm coalescing_fsm,\r\nu8 timeset)\r\n{\r\nstruct cau_pi_entry pi_entry;\r\nu32 sb_offset;\r\nu32 pi_offset;\r\nsb_offset = igu_sb_id * PIS_PER_SB;\r\nmemset(&pi_entry, 0, sizeof(struct cau_pi_entry));\r\nSET_FIELD(pi_entry.prod, CAU_PI_ENTRY_PI_TIMESET, timeset);\r\nif (coalescing_fsm == QED_COAL_RX_STATE_MACHINE)\r\nSET_FIELD(pi_entry.prod, CAU_PI_ENTRY_FSM_SEL, 0);\r\nelse\r\nSET_FIELD(pi_entry.prod, CAU_PI_ENTRY_FSM_SEL, 1);\r\npi_offset = sb_offset + pi_index;\r\nif (p_hwfn->hw_init_done) {\r\nqed_wr(p_hwfn, p_ptt,\r\nCAU_REG_PI_MEMORY + pi_offset * sizeof(u32),\r\n*((u32 *)&(pi_entry)));\r\n} else {\r\nSTORE_RT_REG(p_hwfn,\r\nCAU_REG_PI_MEMORY_RT_OFFSET + pi_offset,\r\n*((u32 *)&(pi_entry)));\r\n}\r\n}\r\nvoid qed_int_sb_setup(struct qed_hwfn *p_hwfn,\r\nstruct qed_ptt *p_ptt,\r\nstruct qed_sb_info *sb_info)\r\n{\r\nsb_info->sb_ack = 0;\r\nmemset(sb_info->sb_virt, 0, sizeof(*sb_info->sb_virt));\r\nqed_int_cau_conf_sb(p_hwfn, p_ptt, sb_info->sb_phys,\r\nsb_info->igu_sb_id, 0, 0);\r\n}\r\nstatic u16 qed_get_igu_sb_id(struct qed_hwfn *p_hwfn,\r\nu16 sb_id)\r\n{\r\nu16 igu_sb_id;\r\nif (sb_id == QED_SP_SB_ID)\r\nigu_sb_id = p_hwfn->hw_info.p_igu_info->igu_dsb_id;\r\nelse\r\nigu_sb_id = sb_id + p_hwfn->hw_info.p_igu_info->igu_base_sb;\r\nDP_VERBOSE(p_hwfn, NETIF_MSG_INTR, "SB [%s] index is 0x%04x\n",\r\n(sb_id == QED_SP_SB_ID) ? "DSB" : "non-DSB", igu_sb_id);\r\nreturn igu_sb_id;\r\n}\r\nint qed_int_sb_init(struct qed_hwfn *p_hwfn,\r\nstruct qed_ptt *p_ptt,\r\nstruct qed_sb_info *sb_info,\r\nvoid *sb_virt_addr,\r\ndma_addr_t sb_phy_addr,\r\nu16 sb_id)\r\n{\r\nsb_info->sb_virt = sb_virt_addr;\r\nsb_info->sb_phys = sb_phy_addr;\r\nsb_info->igu_sb_id = qed_get_igu_sb_id(p_hwfn, sb_id);\r\nif (sb_id != QED_SP_SB_ID) {\r\np_hwfn->sbs_info[sb_id] = sb_info;\r\np_hwfn->num_sbs++;\r\n}\r\nsb_info->cdev = p_hwfn->cdev;\r\nsb_info->igu_addr = (u8 __iomem *)p_hwfn->regview +\r\nGTT_BAR0_MAP_REG_IGU_CMD +\r\n(sb_info->igu_sb_id << 3);\r\nsb_info->flags |= QED_SB_INFO_INIT;\r\nqed_int_sb_setup(p_hwfn, p_ptt, sb_info);\r\nreturn 0;\r\n}\r\nint qed_int_sb_release(struct qed_hwfn *p_hwfn,\r\nstruct qed_sb_info *sb_info,\r\nu16 sb_id)\r\n{\r\nif (sb_id == QED_SP_SB_ID) {\r\nDP_ERR(p_hwfn, "Do Not free sp sb using this function");\r\nreturn -EINVAL;\r\n}\r\nsb_info->sb_ack = 0;\r\nmemset(sb_info->sb_virt, 0, sizeof(*sb_info->sb_virt));\r\np_hwfn->sbs_info[sb_id] = NULL;\r\np_hwfn->num_sbs--;\r\nreturn 0;\r\n}\r\nstatic void qed_int_sp_sb_free(struct qed_hwfn *p_hwfn)\r\n{\r\nstruct qed_sb_sp_info *p_sb = p_hwfn->p_sp_sb;\r\nif (p_sb) {\r\nif (p_sb->sb_info.sb_virt)\r\ndma_free_coherent(&p_hwfn->cdev->pdev->dev,\r\nSB_ALIGNED_SIZE(p_hwfn),\r\np_sb->sb_info.sb_virt,\r\np_sb->sb_info.sb_phys);\r\nkfree(p_sb);\r\n}\r\n}\r\nstatic int qed_int_sp_sb_alloc(struct qed_hwfn *p_hwfn,\r\nstruct qed_ptt *p_ptt)\r\n{\r\nstruct qed_sb_sp_info *p_sb;\r\ndma_addr_t p_phys = 0;\r\nvoid *p_virt;\r\np_sb = kmalloc(sizeof(*p_sb), GFP_ATOMIC);\r\nif (!p_sb) {\r\nDP_NOTICE(p_hwfn, "Failed to allocate `struct qed_sb_info'\n");\r\nreturn -ENOMEM;\r\n}\r\np_virt = dma_alloc_coherent(&p_hwfn->cdev->pdev->dev,\r\nSB_ALIGNED_SIZE(p_hwfn),\r\n&p_phys, GFP_KERNEL);\r\nif (!p_virt) {\r\nDP_NOTICE(p_hwfn, "Failed to allocate status block\n");\r\nkfree(p_sb);\r\nreturn -ENOMEM;\r\n}\r\np_hwfn->p_sp_sb = p_sb;\r\nqed_int_sb_init(p_hwfn, p_ptt, &p_sb->sb_info, p_virt,\r\np_phys, QED_SP_SB_ID);\r\nmemset(p_sb->pi_info_arr, 0, sizeof(p_sb->pi_info_arr));\r\nreturn 0;\r\n}\r\nstatic void qed_int_sp_sb_setup(struct qed_hwfn *p_hwfn,\r\nstruct qed_ptt *p_ptt)\r\n{\r\nif (!p_hwfn)\r\nreturn;\r\nif (p_hwfn->p_sp_sb)\r\nqed_int_sb_setup(p_hwfn, p_ptt, &p_hwfn->p_sp_sb->sb_info);\r\nelse\r\nDP_NOTICE(p_hwfn->cdev,\r\n"Failed to setup Slow path status block - NULL pointer\n");\r\nif (p_hwfn->p_sb_attn)\r\nqed_int_sb_attn_setup(p_hwfn, p_ptt);\r\nelse\r\nDP_NOTICE(p_hwfn->cdev,\r\n"Failed to setup attentions status block - NULL pointer\n");\r\n}\r\nint qed_int_register_cb(struct qed_hwfn *p_hwfn,\r\nqed_int_comp_cb_t comp_cb,\r\nvoid *cookie,\r\nu8 *sb_idx,\r\n__le16 **p_fw_cons)\r\n{\r\nstruct qed_sb_sp_info *p_sp_sb = p_hwfn->p_sp_sb;\r\nint qed_status = -ENOMEM;\r\nu8 pi;\r\nfor (pi = 0; pi < ARRAY_SIZE(p_sp_sb->pi_info_arr); pi++) {\r\nif (!p_sp_sb->pi_info_arr[pi].comp_cb) {\r\np_sp_sb->pi_info_arr[pi].comp_cb = comp_cb;\r\np_sp_sb->pi_info_arr[pi].cookie = cookie;\r\n*sb_idx = pi;\r\n*p_fw_cons = &p_sp_sb->sb_info.sb_virt->pi_array[pi];\r\nqed_status = 0;\r\nbreak;\r\n}\r\n}\r\nreturn qed_status;\r\n}\r\nint qed_int_unregister_cb(struct qed_hwfn *p_hwfn, u8 pi)\r\n{\r\nstruct qed_sb_sp_info *p_sp_sb = p_hwfn->p_sp_sb;\r\nint qed_status = -ENOMEM;\r\nif (p_sp_sb->pi_info_arr[pi].comp_cb) {\r\np_sp_sb->pi_info_arr[pi].comp_cb = NULL;\r\np_sp_sb->pi_info_arr[pi].cookie = NULL;\r\nqed_status = 0;\r\n}\r\nreturn qed_status;\r\n}\r\nu16 qed_int_get_sp_sb_id(struct qed_hwfn *p_hwfn)\r\n{\r\nreturn p_hwfn->p_sp_sb->sb_info.igu_sb_id;\r\n}\r\nvoid qed_int_igu_enable_int(struct qed_hwfn *p_hwfn,\r\nstruct qed_ptt *p_ptt,\r\nenum qed_int_mode int_mode)\r\n{\r\nu32 igu_pf_conf = IGU_PF_CONF_FUNC_EN | IGU_PF_CONF_ATTN_BIT_EN;\r\np_hwfn->cdev->int_mode = int_mode;\r\nswitch (p_hwfn->cdev->int_mode) {\r\ncase QED_INT_MODE_INTA:\r\nigu_pf_conf |= IGU_PF_CONF_INT_LINE_EN;\r\nigu_pf_conf |= IGU_PF_CONF_SINGLE_ISR_EN;\r\nbreak;\r\ncase QED_INT_MODE_MSI:\r\nigu_pf_conf |= IGU_PF_CONF_MSI_MSIX_EN;\r\nigu_pf_conf |= IGU_PF_CONF_SINGLE_ISR_EN;\r\nbreak;\r\ncase QED_INT_MODE_MSIX:\r\nigu_pf_conf |= IGU_PF_CONF_MSI_MSIX_EN;\r\nbreak;\r\ncase QED_INT_MODE_POLL:\r\nbreak;\r\n}\r\nqed_wr(p_hwfn, p_ptt, IGU_REG_PF_CONFIGURATION, igu_pf_conf);\r\n}\r\nint qed_int_igu_enable(struct qed_hwfn *p_hwfn, struct qed_ptt *p_ptt,\r\nenum qed_int_mode int_mode)\r\n{\r\nint rc, i;\r\nfor (i = 0; i < 9; i++)\r\nqed_wr(p_hwfn, p_ptt,\r\nMISC_REG_AEU_ENABLE1_IGU_OUT_0 + (i << 2), 0);\r\nqed_wr(p_hwfn, p_ptt, IGU_REG_LEADING_EDGE_LATCH, 0xfff);\r\nqed_wr(p_hwfn, p_ptt, IGU_REG_TRAILING_EDGE_LATCH, 0xfff);\r\nmmiowb();\r\nqed_wr(p_hwfn, p_ptt, MISC_REG_AEU_MASK_ATTN_IGU, 0xff);\r\nif ((int_mode != QED_INT_MODE_INTA) || IS_LEAD_HWFN(p_hwfn)) {\r\nrc = qed_slowpath_irq_req(p_hwfn);\r\nif (rc != 0) {\r\nDP_NOTICE(p_hwfn, "Slowpath IRQ request failed\n");\r\nreturn -EINVAL;\r\n}\r\np_hwfn->b_int_requested = true;\r\n}\r\nqed_int_igu_enable_int(p_hwfn, p_ptt, int_mode);\r\np_hwfn->b_int_enabled = 1;\r\nreturn rc;\r\n}\r\nvoid qed_int_igu_disable_int(struct qed_hwfn *p_hwfn,\r\nstruct qed_ptt *p_ptt)\r\n{\r\np_hwfn->b_int_enabled = 0;\r\nqed_wr(p_hwfn, p_ptt, IGU_REG_PF_CONFIGURATION, 0);\r\n}\r\nvoid qed_int_igu_cleanup_sb(struct qed_hwfn *p_hwfn,\r\nstruct qed_ptt *p_ptt,\r\nu32 sb_id,\r\nbool cleanup_set,\r\nu16 opaque_fid\r\n)\r\n{\r\nu32 pxp_addr = IGU_CMD_INT_ACK_BASE + sb_id;\r\nu32 sleep_cnt = IGU_CLEANUP_SLEEP_LENGTH;\r\nu32 data = 0;\r\nu32 cmd_ctrl = 0;\r\nu32 val = 0;\r\nu32 sb_bit = 0;\r\nu32 sb_bit_addr = 0;\r\nSET_FIELD(data, IGU_CLEANUP_CLEANUP_SET, cleanup_set ? 1 : 0);\r\nSET_FIELD(data, IGU_CLEANUP_CLEANUP_TYPE, 0);\r\nSET_FIELD(data, IGU_CLEANUP_COMMAND_TYPE, IGU_COMMAND_TYPE_SET);\r\nSET_FIELD(cmd_ctrl, IGU_CTRL_REG_PXP_ADDR, pxp_addr);\r\nSET_FIELD(cmd_ctrl, IGU_CTRL_REG_FID, opaque_fid);\r\nSET_FIELD(cmd_ctrl, IGU_CTRL_REG_TYPE, IGU_CTRL_CMD_TYPE_WR);\r\nqed_wr(p_hwfn, p_ptt, IGU_REG_COMMAND_REG_32LSB_DATA, data);\r\nbarrier();\r\nqed_wr(p_hwfn, p_ptt, IGU_REG_COMMAND_REG_CTRL, cmd_ctrl);\r\nmmiowb();\r\nsb_bit = 1 << (sb_id % 32);\r\nsb_bit_addr = sb_id / 32 * sizeof(u32);\r\nsb_bit_addr += IGU_REG_CLEANUP_STATUS_0;\r\ndo {\r\nval = qed_rd(p_hwfn, p_ptt, sb_bit_addr);\r\nif ((val & sb_bit) == (cleanup_set ? sb_bit : 0))\r\nbreak;\r\nusleep_range(5000, 10000);\r\n} while (--sleep_cnt);\r\nif (!sleep_cnt)\r\nDP_NOTICE(p_hwfn,\r\n"Timeout waiting for clear status 0x%08x [for sb %d]\n",\r\nval, sb_id);\r\n}\r\nvoid qed_int_igu_init_pure_rt_single(struct qed_hwfn *p_hwfn,\r\nstruct qed_ptt *p_ptt,\r\nu32 sb_id,\r\nu16 opaque,\r\nbool b_set)\r\n{\r\nint pi;\r\nif (b_set)\r\nqed_int_igu_cleanup_sb(p_hwfn, p_ptt, sb_id, 1, opaque);\r\nqed_int_igu_cleanup_sb(p_hwfn, p_ptt, sb_id, 0, opaque);\r\nfor (pi = 0; pi < 12; pi++)\r\nqed_wr(p_hwfn, p_ptt,\r\nCAU_REG_PI_MEMORY + (sb_id * 12 + pi) * 4, 0);\r\n}\r\nvoid qed_int_igu_init_pure_rt(struct qed_hwfn *p_hwfn,\r\nstruct qed_ptt *p_ptt,\r\nbool b_set,\r\nbool b_slowpath)\r\n{\r\nu32 igu_base_sb = p_hwfn->hw_info.p_igu_info->igu_base_sb;\r\nu32 igu_sb_cnt = p_hwfn->hw_info.p_igu_info->igu_sb_cnt;\r\nu32 sb_id = 0;\r\nu32 val = 0;\r\nval = qed_rd(p_hwfn, p_ptt, IGU_REG_BLOCK_CONFIGURATION);\r\nval |= IGU_REG_BLOCK_CONFIGURATION_VF_CLEANUP_EN;\r\nval &= ~IGU_REG_BLOCK_CONFIGURATION_PXP_TPH_INTERFACE_EN;\r\nqed_wr(p_hwfn, p_ptt, IGU_REG_BLOCK_CONFIGURATION, val);\r\nDP_VERBOSE(p_hwfn, NETIF_MSG_INTR,\r\n"IGU cleaning SBs [%d,...,%d]\n",\r\nigu_base_sb, igu_base_sb + igu_sb_cnt - 1);\r\nfor (sb_id = igu_base_sb; sb_id < igu_base_sb + igu_sb_cnt; sb_id++)\r\nqed_int_igu_init_pure_rt_single(p_hwfn, p_ptt, sb_id,\r\np_hwfn->hw_info.opaque_fid,\r\nb_set);\r\nif (b_slowpath) {\r\nsb_id = p_hwfn->hw_info.p_igu_info->igu_dsb_id;\r\nDP_VERBOSE(p_hwfn, NETIF_MSG_INTR,\r\n"IGU cleaning slowpath SB [%d]\n", sb_id);\r\nqed_int_igu_init_pure_rt_single(p_hwfn, p_ptt, sb_id,\r\np_hwfn->hw_info.opaque_fid,\r\nb_set);\r\n}\r\n}\r\nint qed_int_igu_read_cam(struct qed_hwfn *p_hwfn,\r\nstruct qed_ptt *p_ptt)\r\n{\r\nstruct qed_igu_info *p_igu_info;\r\nstruct qed_igu_block *blk;\r\nu32 val;\r\nu16 sb_id;\r\nu16 prev_sb_id = 0xFF;\r\np_hwfn->hw_info.p_igu_info = kzalloc(sizeof(*p_igu_info), GFP_ATOMIC);\r\nif (!p_hwfn->hw_info.p_igu_info)\r\nreturn -ENOMEM;\r\np_igu_info = p_hwfn->hw_info.p_igu_info;\r\np_igu_info->igu_base_sb = 0xffff;\r\np_igu_info->igu_sb_cnt = 0;\r\np_igu_info->igu_dsb_id = 0xffff;\r\np_igu_info->igu_base_sb_iov = 0xffff;\r\nfor (sb_id = 0; sb_id < QED_MAPPING_MEMORY_SIZE(p_hwfn->cdev);\r\nsb_id++) {\r\nblk = &p_igu_info->igu_map.igu_blocks[sb_id];\r\nval = qed_rd(p_hwfn, p_ptt,\r\nIGU_REG_MAPPING_MEMORY + sizeof(u32) * sb_id);\r\nif (!GET_FIELD(val, IGU_MAPPING_LINE_VALID) &&\r\nGET_FIELD(val, IGU_MAPPING_LINE_PF_VALID))\r\nbreak;\r\nblk->status = QED_IGU_STATUS_VALID;\r\nblk->function_id = GET_FIELD(val,\r\nIGU_MAPPING_LINE_FUNCTION_NUMBER);\r\nblk->is_pf = GET_FIELD(val, IGU_MAPPING_LINE_PF_VALID);\r\nblk->vector_number = GET_FIELD(val,\r\nIGU_MAPPING_LINE_VECTOR_NUMBER);\r\nDP_VERBOSE(p_hwfn, NETIF_MSG_INTR,\r\n"IGU_BLOCK[sb_id]:%x:func_id = %d is_pf = %d vector_num = 0x%x\n",\r\nval, blk->function_id, blk->is_pf,\r\nblk->vector_number);\r\nif (blk->is_pf) {\r\nif (blk->function_id == p_hwfn->rel_pf_id) {\r\nblk->status |= QED_IGU_STATUS_PF;\r\nif (blk->vector_number == 0) {\r\nif (p_igu_info->igu_dsb_id == 0xffff)\r\np_igu_info->igu_dsb_id = sb_id;\r\n} else {\r\nif (p_igu_info->igu_base_sb ==\r\n0xffff) {\r\np_igu_info->igu_base_sb = sb_id;\r\n} else if (prev_sb_id != sb_id - 1) {\r\nDP_NOTICE(p_hwfn->cdev,\r\n"consecutive igu vectors for HWFN %x broken",\r\np_hwfn->rel_pf_id);\r\nbreak;\r\n}\r\nprev_sb_id = sb_id;\r\n(p_igu_info->igu_sb_cnt)++;\r\n}\r\n}\r\n}\r\n}\r\nDP_VERBOSE(p_hwfn, NETIF_MSG_INTR,\r\n"IGU igu_base_sb=0x%x igu_sb_cnt=%d igu_dsb_id=0x%x\n",\r\np_igu_info->igu_base_sb,\r\np_igu_info->igu_sb_cnt,\r\np_igu_info->igu_dsb_id);\r\nif (p_igu_info->igu_base_sb == 0xffff ||\r\np_igu_info->igu_dsb_id == 0xffff ||\r\np_igu_info->igu_sb_cnt == 0) {\r\nDP_NOTICE(p_hwfn,\r\n"IGU CAM returned invalid values igu_base_sb=0x%x igu_sb_cnt=%d igu_dsb_id=0x%x\n",\r\np_igu_info->igu_base_sb,\r\np_igu_info->igu_sb_cnt,\r\np_igu_info->igu_dsb_id);\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nvoid qed_int_igu_init_rt(struct qed_hwfn *p_hwfn)\r\n{\r\nu32 igu_pf_conf = 0;\r\nigu_pf_conf |= IGU_PF_CONF_FUNC_EN;\r\nSTORE_RT_REG(p_hwfn, IGU_REG_PF_CONFIGURATION_RT_OFFSET, igu_pf_conf);\r\n}\r\nu64 qed_int_igu_read_sisr_reg(struct qed_hwfn *p_hwfn)\r\n{\r\nu64 intr_status = 0;\r\nu32 intr_status_lo = 0;\r\nu32 intr_status_hi = 0;\r\nu32 lsb_igu_cmd_addr = IGU_REG_SISR_MDPC_WMASK_LSB_UPPER -\r\nIGU_CMD_INT_ACK_BASE;\r\nu32 msb_igu_cmd_addr = IGU_REG_SISR_MDPC_WMASK_MSB_UPPER -\r\nIGU_CMD_INT_ACK_BASE;\r\nintr_status_lo = REG_RD(p_hwfn,\r\nGTT_BAR0_MAP_REG_IGU_CMD +\r\nlsb_igu_cmd_addr * 8);\r\nintr_status_hi = REG_RD(p_hwfn,\r\nGTT_BAR0_MAP_REG_IGU_CMD +\r\nmsb_igu_cmd_addr * 8);\r\nintr_status = ((u64)intr_status_hi << 32) + (u64)intr_status_lo;\r\nreturn intr_status;\r\n}\r\nstatic void qed_int_sp_dpc_setup(struct qed_hwfn *p_hwfn)\r\n{\r\ntasklet_init(p_hwfn->sp_dpc,\r\nqed_int_sp_dpc, (unsigned long)p_hwfn);\r\np_hwfn->b_sp_dpc_enabled = true;\r\n}\r\nstatic int qed_int_sp_dpc_alloc(struct qed_hwfn *p_hwfn)\r\n{\r\np_hwfn->sp_dpc = kmalloc(sizeof(*p_hwfn->sp_dpc), GFP_ATOMIC);\r\nif (!p_hwfn->sp_dpc)\r\nreturn -ENOMEM;\r\nreturn 0;\r\n}\r\nstatic void qed_int_sp_dpc_free(struct qed_hwfn *p_hwfn)\r\n{\r\nkfree(p_hwfn->sp_dpc);\r\n}\r\nint qed_int_alloc(struct qed_hwfn *p_hwfn,\r\nstruct qed_ptt *p_ptt)\r\n{\r\nint rc = 0;\r\nrc = qed_int_sp_dpc_alloc(p_hwfn);\r\nif (rc) {\r\nDP_ERR(p_hwfn->cdev, "Failed to allocate sp dpc mem\n");\r\nreturn rc;\r\n}\r\nrc = qed_int_sp_sb_alloc(p_hwfn, p_ptt);\r\nif (rc) {\r\nDP_ERR(p_hwfn->cdev, "Failed to allocate sp sb mem\n");\r\nreturn rc;\r\n}\r\nrc = qed_int_sb_attn_alloc(p_hwfn, p_ptt);\r\nif (rc) {\r\nDP_ERR(p_hwfn->cdev, "Failed to allocate sb attn mem\n");\r\nreturn rc;\r\n}\r\nreturn rc;\r\n}\r\nvoid qed_int_free(struct qed_hwfn *p_hwfn)\r\n{\r\nqed_int_sp_sb_free(p_hwfn);\r\nqed_int_sb_attn_free(p_hwfn);\r\nqed_int_sp_dpc_free(p_hwfn);\r\n}\r\nvoid qed_int_setup(struct qed_hwfn *p_hwfn,\r\nstruct qed_ptt *p_ptt)\r\n{\r\nqed_int_sp_sb_setup(p_hwfn, p_ptt);\r\nqed_int_sp_dpc_setup(p_hwfn);\r\n}\r\nint qed_int_get_num_sbs(struct qed_hwfn *p_hwfn,\r\nint *p_iov_blks)\r\n{\r\nstruct qed_igu_info *info = p_hwfn->hw_info.p_igu_info;\r\nif (!info)\r\nreturn 0;\r\nif (p_iov_blks)\r\n*p_iov_blks = info->free_blks;\r\nreturn info->igu_sb_cnt;\r\n}\r\nvoid qed_int_disable_post_isr_release(struct qed_dev *cdev)\r\n{\r\nint i;\r\nfor_each_hwfn(cdev, i)\r\ncdev->hwfns[i].b_int_requested = false;\r\n}
