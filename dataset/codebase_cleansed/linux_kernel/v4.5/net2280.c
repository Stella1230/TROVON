static char *type_string(u8 bmAttributes)\r\n{\r\nswitch ((bmAttributes) & USB_ENDPOINT_XFERTYPE_MASK) {\r\ncase USB_ENDPOINT_XFER_BULK: return "bulk";\r\ncase USB_ENDPOINT_XFER_ISOC: return "iso";\r\ncase USB_ENDPOINT_XFER_INT: return "intr";\r\n}\r\nreturn "control";\r\n}\r\nstatic inline void enable_pciirqenb(struct net2280_ep *ep)\r\n{\r\nu32 tmp = readl(&ep->dev->regs->pciirqenb0);\r\nif (ep->dev->quirks & PLX_LEGACY)\r\ntmp |= BIT(ep->num);\r\nelse\r\ntmp |= BIT(ep_bit[ep->num]);\r\nwritel(tmp, &ep->dev->regs->pciirqenb0);\r\nreturn;\r\n}\r\nstatic int\r\nnet2280_enable(struct usb_ep *_ep, const struct usb_endpoint_descriptor *desc)\r\n{\r\nstruct net2280 *dev;\r\nstruct net2280_ep *ep;\r\nu32 max;\r\nu32 tmp = 0;\r\nu32 type;\r\nunsigned long flags;\r\nstatic const u32 ep_key[9] = { 1, 0, 1, 0, 1, 1, 0, 1, 0 };\r\nint ret = 0;\r\nep = container_of(_ep, struct net2280_ep, ep);\r\nif (!_ep || !desc || ep->desc || _ep->name == ep0name ||\r\ndesc->bDescriptorType != USB_DT_ENDPOINT) {\r\npr_err("%s: failed at line=%d\n", __func__, __LINE__);\r\nreturn -EINVAL;\r\n}\r\ndev = ep->dev;\r\nif (!dev->driver || dev->gadget.speed == USB_SPEED_UNKNOWN) {\r\nret = -ESHUTDOWN;\r\ngoto print_err;\r\n}\r\nif ((desc->bEndpointAddress & 0x0f) == EP_DONTUSE) {\r\nret = -EDOM;\r\ngoto print_err;\r\n}\r\nif (dev->quirks & PLX_SUPERSPEED) {\r\nif ((desc->bEndpointAddress & 0x0f) >= 0x0c) {\r\nret = -EDOM;\r\ngoto print_err;\r\n}\r\nep->is_in = !!usb_endpoint_dir_in(desc);\r\nif (dev->enhanced_mode && ep->is_in && ep_key[ep->num]) {\r\nret = -EINVAL;\r\ngoto print_err;\r\n}\r\n}\r\nmax = usb_endpoint_maxp(desc) & 0x1fff;\r\nif (ep->num > 4 && max > 64 && (dev->quirks & PLX_LEGACY)) {\r\nret = -ERANGE;\r\ngoto print_err;\r\n}\r\nspin_lock_irqsave(&dev->lock, flags);\r\n_ep->maxpacket = max & 0x7ff;\r\nep->desc = desc;\r\nep->stopped = 0;\r\nep->wedged = 0;\r\nep->out_overflow = 0;\r\nset_max_speed(ep, max);\r\nwritel(BIT(FIFO_FLUSH), &ep->regs->ep_stat);\r\nif ((dev->quirks & PLX_SUPERSPEED) && dev->enhanced_mode) {\r\ntmp = readl(&ep->cfg->ep_cfg);\r\nif ((tmp & 0xf) != usb_endpoint_num(desc)) {\r\nret = -EINVAL;\r\nspin_unlock_irqrestore(&dev->lock, flags);\r\ngoto print_err;\r\n}\r\nif (ep->is_in)\r\ntmp &= ~USB3380_EP_CFG_MASK_IN;\r\nelse\r\ntmp &= ~USB3380_EP_CFG_MASK_OUT;\r\n}\r\ntype = (desc->bmAttributes & USB_ENDPOINT_XFERTYPE_MASK);\r\nif (type == USB_ENDPOINT_XFER_INT) {\r\nif (dev->chiprev == 0100 &&\r\ndev->gadget.speed == USB_SPEED_HIGH &&\r\n!(desc->bEndpointAddress & USB_DIR_IN))\r\nwritel(BIT(CLEAR_NAK_OUT_PACKETS_MODE),\r\n&ep->regs->ep_rsp);\r\n} else if (type == USB_ENDPOINT_XFER_BULK) {\r\nif ((dev->gadget.speed == USB_SPEED_SUPER && max != 1024) ||\r\n(dev->gadget.speed == USB_SPEED_HIGH && max != 512) ||\r\n(dev->gadget.speed == USB_SPEED_FULL && max > 64)) {\r\nspin_unlock_irqrestore(&dev->lock, flags);\r\nret = -ERANGE;\r\ngoto print_err;\r\n}\r\n}\r\nep->is_iso = (type == USB_ENDPOINT_XFER_ISOC);\r\nif (dev->quirks & PLX_LEGACY) {\r\ntmp |= type << ENDPOINT_TYPE;\r\ntmp |= desc->bEndpointAddress;\r\ntmp |= (4 << ENDPOINT_BYTE_COUNT);\r\ntmp |= BIT(ENDPOINT_ENABLE);\r\nep->is_in = (tmp & USB_DIR_IN) != 0;\r\n} else {\r\nif (dev->enhanced_mode && ep->is_in) {\r\ntmp |= type << IN_ENDPOINT_TYPE;\r\ntmp |= BIT(IN_ENDPOINT_ENABLE);\r\n} else {\r\ntmp |= type << OUT_ENDPOINT_TYPE;\r\ntmp |= BIT(OUT_ENDPOINT_ENABLE);\r\ntmp |= (ep->is_in << ENDPOINT_DIRECTION);\r\n}\r\ntmp |= (4 << ENDPOINT_BYTE_COUNT);\r\nif (!dev->enhanced_mode)\r\ntmp |= usb_endpoint_num(desc);\r\ntmp |= (ep->ep.maxburst << MAX_BURST_SIZE);\r\n}\r\nwmb();\r\nif (!ep->is_in)\r\nwritel(BIT(SET_NAK_OUT_PACKETS), &ep->regs->ep_rsp);\r\nelse if (!(dev->quirks & PLX_2280)) {\r\nwritel(BIT(CLEAR_NAK_OUT_PACKETS) |\r\nBIT(CLEAR_NAK_OUT_PACKETS_MODE), &ep->regs->ep_rsp);\r\n}\r\nif (dev->quirks & PLX_SUPERSPEED)\r\nep_clear_seqnum(ep);\r\nwritel(tmp, &ep->cfg->ep_cfg);\r\nif (!ep->dma) {\r\nenable_pciirqenb(ep);\r\ntmp = BIT(DATA_PACKET_RECEIVED_INTERRUPT_ENABLE) |\r\nBIT(DATA_PACKET_TRANSMITTED_INTERRUPT_ENABLE);\r\nif (dev->quirks & PLX_2280)\r\ntmp |= readl(&ep->regs->ep_irqenb);\r\nwritel(tmp, &ep->regs->ep_irqenb);\r\n} else {\r\ntmp = BIT((8 + ep->num));\r\ntmp |= readl(&dev->regs->pciirqenb1);\r\nwritel(tmp, &dev->regs->pciirqenb1);\r\nif ((desc->bEndpointAddress & USB_DIR_IN) == 0) {\r\ntmp = BIT(SHORT_PACKET_TRANSFERRED_INTERRUPT_ENABLE);\r\nwritel(tmp, &ep->regs->ep_irqenb);\r\nenable_pciirqenb(ep);\r\n}\r\n}\r\ntmp = desc->bEndpointAddress;\r\nep_dbg(dev, "enabled %s (ep%d%s-%s) %s max %04x\n",\r\n_ep->name, tmp & 0x0f, DIR_STRING(tmp),\r\ntype_string(desc->bmAttributes),\r\nep->dma ? "dma" : "pio", max);\r\nspin_unlock_irqrestore(&dev->lock, flags);\r\nreturn ret;\r\nprint_err:\r\ndev_err(&ep->dev->pdev->dev, "%s: error=%d\n", __func__, ret);\r\nreturn ret;\r\n}\r\nstatic int handshake(u32 __iomem *ptr, u32 mask, u32 done, int usec)\r\n{\r\nu32 result;\r\ndo {\r\nresult = readl(ptr);\r\nif (result == ~(u32)0)\r\nreturn -ENODEV;\r\nresult &= mask;\r\nif (result == done)\r\nreturn 0;\r\nudelay(1);\r\nusec--;\r\n} while (usec > 0);\r\nreturn -ETIMEDOUT;\r\n}\r\nstatic void ep_reset_228x(struct net2280_regs __iomem *regs,\r\nstruct net2280_ep *ep)\r\n{\r\nu32 tmp;\r\nep->desc = NULL;\r\nINIT_LIST_HEAD(&ep->queue);\r\nusb_ep_set_maxpacket_limit(&ep->ep, ~0);\r\nep->ep.ops = &net2280_ep_ops;\r\nif (ep->dma) {\r\nwritel(0, &ep->dma->dmactl);\r\nwritel(BIT(DMA_SCATTER_GATHER_DONE_INTERRUPT) |\r\nBIT(DMA_TRANSACTION_DONE_INTERRUPT) |\r\nBIT(DMA_ABORT),\r\n&ep->dma->dmastat);\r\ntmp = readl(&regs->pciirqenb0);\r\ntmp &= ~BIT(ep->num);\r\nwritel(tmp, &regs->pciirqenb0);\r\n} else {\r\ntmp = readl(&regs->pciirqenb1);\r\ntmp &= ~BIT((8 + ep->num));\r\nwritel(tmp, &regs->pciirqenb1);\r\n}\r\nwritel(0, &ep->regs->ep_irqenb);\r\nif (!ep->is_in || (ep->dev->quirks & PLX_2280)) {\r\ntmp = BIT(SET_NAK_OUT_PACKETS_MODE) |\r\nBIT(SET_NAK_OUT_PACKETS) |\r\nBIT(CLEAR_EP_HIDE_STATUS_PHASE) |\r\nBIT(CLEAR_INTERRUPT_MODE);\r\n} else {\r\ntmp = BIT(CLEAR_NAK_OUT_PACKETS_MODE) |\r\nBIT(CLEAR_NAK_OUT_PACKETS) |\r\nBIT(CLEAR_EP_HIDE_STATUS_PHASE) |\r\nBIT(CLEAR_INTERRUPT_MODE);\r\n}\r\nif (ep->num != 0) {\r\ntmp |= BIT(CLEAR_ENDPOINT_TOGGLE) |\r\nBIT(CLEAR_ENDPOINT_HALT);\r\n}\r\nwritel(tmp, &ep->regs->ep_rsp);\r\nif (ep->dev->quirks & PLX_2280)\r\ntmp = BIT(FIFO_OVERFLOW) |\r\nBIT(FIFO_UNDERFLOW);\r\nelse\r\ntmp = 0;\r\nwritel(tmp | BIT(TIMEOUT) |\r\nBIT(USB_STALL_SENT) |\r\nBIT(USB_IN_NAK_SENT) |\r\nBIT(USB_IN_ACK_RCVD) |\r\nBIT(USB_OUT_PING_NAK_SENT) |\r\nBIT(USB_OUT_ACK_SENT) |\r\nBIT(FIFO_FLUSH) |\r\nBIT(SHORT_PACKET_OUT_DONE_INTERRUPT) |\r\nBIT(SHORT_PACKET_TRANSFERRED_INTERRUPT) |\r\nBIT(DATA_PACKET_RECEIVED_INTERRUPT) |\r\nBIT(DATA_PACKET_TRANSMITTED_INTERRUPT) |\r\nBIT(DATA_OUT_PING_TOKEN_INTERRUPT) |\r\nBIT(DATA_IN_TOKEN_INTERRUPT),\r\n&ep->regs->ep_stat);\r\n}\r\nstatic void ep_reset_338x(struct net2280_regs __iomem *regs,\r\nstruct net2280_ep *ep)\r\n{\r\nu32 tmp, dmastat;\r\nep->desc = NULL;\r\nINIT_LIST_HEAD(&ep->queue);\r\nusb_ep_set_maxpacket_limit(&ep->ep, ~0);\r\nep->ep.ops = &net2280_ep_ops;\r\nif (ep->dma) {\r\nwritel(0, &ep->dma->dmactl);\r\nwritel(BIT(DMA_ABORT_DONE_INTERRUPT) |\r\nBIT(DMA_PAUSE_DONE_INTERRUPT) |\r\nBIT(DMA_SCATTER_GATHER_DONE_INTERRUPT) |\r\nBIT(DMA_TRANSACTION_DONE_INTERRUPT),\r\n&ep->dma->dmastat);\r\ndmastat = readl(&ep->dma->dmastat);\r\nif (dmastat == 0x5002) {\r\nep_warn(ep->dev, "The dmastat return = %x!!\n",\r\ndmastat);\r\nwritel(0x5a, &ep->dma->dmastat);\r\n}\r\ntmp = readl(&regs->pciirqenb0);\r\ntmp &= ~BIT(ep_bit[ep->num]);\r\nwritel(tmp, &regs->pciirqenb0);\r\n} else {\r\nif (ep->num < 5) {\r\ntmp = readl(&regs->pciirqenb1);\r\ntmp &= ~BIT((8 + ep->num));\r\nwritel(tmp, &regs->pciirqenb1);\r\n}\r\n}\r\nwritel(0, &ep->regs->ep_irqenb);\r\nwritel(BIT(SHORT_PACKET_OUT_DONE_INTERRUPT) |\r\nBIT(SHORT_PACKET_TRANSFERRED_INTERRUPT) |\r\nBIT(FIFO_OVERFLOW) |\r\nBIT(DATA_PACKET_RECEIVED_INTERRUPT) |\r\nBIT(DATA_PACKET_TRANSMITTED_INTERRUPT) |\r\nBIT(DATA_OUT_PING_TOKEN_INTERRUPT) |\r\nBIT(DATA_IN_TOKEN_INTERRUPT), &ep->regs->ep_stat);\r\ntmp = readl(&ep->cfg->ep_cfg);\r\nif (ep->is_in)\r\ntmp &= ~USB3380_EP_CFG_MASK_IN;\r\nelse\r\ntmp &= ~USB3380_EP_CFG_MASK_OUT;\r\nwritel(tmp, &ep->cfg->ep_cfg);\r\n}\r\nstatic int net2280_disable(struct usb_ep *_ep)\r\n{\r\nstruct net2280_ep *ep;\r\nunsigned long flags;\r\nep = container_of(_ep, struct net2280_ep, ep);\r\nif (!_ep || !ep->desc || _ep->name == ep0name) {\r\npr_err("%s: Invalid ep=%p or ep->desc\n", __func__, _ep);\r\nreturn -EINVAL;\r\n}\r\nspin_lock_irqsave(&ep->dev->lock, flags);\r\nnuke(ep);\r\nif (ep->dev->quirks & PLX_SUPERSPEED)\r\nep_reset_338x(ep->dev->regs, ep);\r\nelse\r\nep_reset_228x(ep->dev->regs, ep);\r\nep_vdbg(ep->dev, "disabled %s %s\n",\r\nep->dma ? "dma" : "pio", _ep->name);\r\n(void)readl(&ep->cfg->ep_cfg);\r\nif (!ep->dma && ep->num >= 1 && ep->num <= 4)\r\nep->dma = &ep->dev->dma[ep->num - 1];\r\nspin_unlock_irqrestore(&ep->dev->lock, flags);\r\nreturn 0;\r\n}\r\nstatic struct usb_request\r\n*net2280_alloc_request(struct usb_ep *_ep, gfp_t gfp_flags)\r\n{\r\nstruct net2280_ep *ep;\r\nstruct net2280_request *req;\r\nif (!_ep) {\r\npr_err("%s: Invalid ep\n", __func__);\r\nreturn NULL;\r\n}\r\nep = container_of(_ep, struct net2280_ep, ep);\r\nreq = kzalloc(sizeof(*req), gfp_flags);\r\nif (!req)\r\nreturn NULL;\r\nINIT_LIST_HEAD(&req->queue);\r\nif (ep->dma) {\r\nstruct net2280_dma *td;\r\ntd = pci_pool_alloc(ep->dev->requests, gfp_flags,\r\n&req->td_dma);\r\nif (!td) {\r\nkfree(req);\r\nreturn NULL;\r\n}\r\ntd->dmacount = 0;\r\ntd->dmadesc = td->dmaaddr;\r\nreq->td = td;\r\n}\r\nreturn &req->req;\r\n}\r\nstatic void net2280_free_request(struct usb_ep *_ep, struct usb_request *_req)\r\n{\r\nstruct net2280_ep *ep;\r\nstruct net2280_request *req;\r\nep = container_of(_ep, struct net2280_ep, ep);\r\nif (!_ep || !_req) {\r\ndev_err(&ep->dev->pdev->dev, "%s: Inavlid ep=%p or req=%p\n",\r\n__func__, _ep, _req);\r\nreturn;\r\n}\r\nreq = container_of(_req, struct net2280_request, req);\r\nWARN_ON(!list_empty(&req->queue));\r\nif (req->td)\r\npci_pool_free(ep->dev->requests, req->td, req->td_dma);\r\nkfree(req);\r\n}\r\nstatic void write_fifo(struct net2280_ep *ep, struct usb_request *req)\r\n{\r\nstruct net2280_ep_regs __iomem *regs = ep->regs;\r\nu8 *buf;\r\nu32 tmp;\r\nunsigned count, total;\r\nif (req) {\r\nbuf = req->buf + req->actual;\r\nprefetch(buf);\r\ntotal = req->length - req->actual;\r\n} else {\r\ntotal = 0;\r\nbuf = NULL;\r\n}\r\ncount = ep->ep.maxpacket;\r\nif (count > total)\r\ncount = total;\r\nep_vdbg(ep->dev, "write %s fifo (IN) %d bytes%s req %p\n",\r\nep->ep.name, count,\r\n(count != ep->ep.maxpacket) ? " (short)" : "",\r\nreq);\r\nwhile (count >= 4) {\r\ntmp = get_unaligned((u32 *)buf);\r\ncpu_to_le32s(&tmp);\r\nwritel(tmp, &regs->ep_data);\r\nbuf += 4;\r\ncount -= 4;\r\n}\r\nif (count || total < ep->ep.maxpacket) {\r\ntmp = count ? get_unaligned((u32 *)buf) : count;\r\ncpu_to_le32s(&tmp);\r\nset_fifo_bytecount(ep, count & 0x03);\r\nwritel(tmp, &regs->ep_data);\r\n}\r\n}\r\nstatic void out_flush(struct net2280_ep *ep)\r\n{\r\nu32 __iomem *statp;\r\nu32 tmp;\r\nstatp = &ep->regs->ep_stat;\r\ntmp = readl(statp);\r\nif (tmp & BIT(NAK_OUT_PACKETS)) {\r\nep_dbg(ep->dev, "%s %s %08x !NAK\n",\r\nep->ep.name, __func__, tmp);\r\nwritel(BIT(SET_NAK_OUT_PACKETS), &ep->regs->ep_rsp);\r\n}\r\nwritel(BIT(DATA_OUT_PING_TOKEN_INTERRUPT) |\r\nBIT(DATA_PACKET_RECEIVED_INTERRUPT),\r\nstatp);\r\nwritel(BIT(FIFO_FLUSH), statp);\r\nmb();\r\ntmp = readl(statp);\r\nif (tmp & BIT(DATA_OUT_PING_TOKEN_INTERRUPT) &&\r\nep->dev->gadget.speed == USB_SPEED_FULL) {\r\nunsigned usec;\r\nusec = 50;\r\nhandshake(statp, BIT(USB_OUT_PING_NAK_SENT),\r\nBIT(USB_OUT_PING_NAK_SENT), usec);\r\n}\r\n}\r\nstatic int read_fifo(struct net2280_ep *ep, struct net2280_request *req)\r\n{\r\nstruct net2280_ep_regs __iomem *regs = ep->regs;\r\nu8 *buf = req->req.buf + req->req.actual;\r\nunsigned count, tmp, is_short;\r\nunsigned cleanup = 0, prevent = 0;\r\nif (ep->dev->chiprev == 0x0100 &&\r\nep->dev->gadget.speed == USB_SPEED_FULL) {\r\nudelay(1);\r\ntmp = readl(&ep->regs->ep_stat);\r\nif ((tmp & BIT(NAK_OUT_PACKETS)))\r\ncleanup = 1;\r\nelse if ((tmp & BIT(FIFO_FULL))) {\r\nstart_out_naking(ep);\r\nprevent = 1;\r\n}\r\n}\r\nprefetchw(buf);\r\ncount = readl(&regs->ep_avail);\r\nif (unlikely(count == 0)) {\r\nudelay(1);\r\ntmp = readl(&ep->regs->ep_stat);\r\ncount = readl(&regs->ep_avail);\r\nif (count == 0 && (tmp & BIT(NAK_OUT_PACKETS)) == 0)\r\nreturn 0;\r\n}\r\ntmp = req->req.length - req->req.actual;\r\nif (count > tmp) {\r\nif ((tmp % ep->ep.maxpacket) != 0) {\r\nep_err(ep->dev,\r\n"%s out fifo %d bytes, expected %d\n",\r\nep->ep.name, count, tmp);\r\nreq->req.status = -EOVERFLOW;\r\ncleanup = 1;\r\n}\r\ncount = tmp;\r\n}\r\nreq->req.actual += count;\r\nis_short = (count == 0) || ((count % ep->ep.maxpacket) != 0);\r\nep_vdbg(ep->dev, "read %s fifo (OUT) %d bytes%s%s%s req %p %d/%d\n",\r\nep->ep.name, count, is_short ? " (short)" : "",\r\ncleanup ? " flush" : "", prevent ? " nak" : "",\r\nreq, req->req.actual, req->req.length);\r\nwhile (count >= 4) {\r\ntmp = readl(&regs->ep_data);\r\ncpu_to_le32s(&tmp);\r\nput_unaligned(tmp, (u32 *)buf);\r\nbuf += 4;\r\ncount -= 4;\r\n}\r\nif (count) {\r\ntmp = readl(&regs->ep_data);\r\ndo {\r\n*buf++ = (u8) tmp;\r\ntmp >>= 8;\r\n} while (--count);\r\n}\r\nif (cleanup)\r\nout_flush(ep);\r\nif (prevent) {\r\nwritel(BIT(CLEAR_NAK_OUT_PACKETS), &ep->regs->ep_rsp);\r\n(void) readl(&ep->regs->ep_rsp);\r\n}\r\nreturn is_short || ((req->req.actual == req->req.length) &&\r\n!req->req.zero);\r\n}\r\nstatic void fill_dma_desc(struct net2280_ep *ep,\r\nstruct net2280_request *req, int valid)\r\n{\r\nstruct net2280_dma *td = req->td;\r\nu32 dmacount = req->req.length;\r\nif (ep->is_in)\r\ndmacount |= BIT(DMA_DIRECTION);\r\nif ((!ep->is_in && (dmacount % ep->ep.maxpacket) != 0) ||\r\n!(ep->dev->quirks & PLX_2280))\r\ndmacount |= BIT(END_OF_CHAIN);\r\nreq->valid = valid;\r\nif (valid)\r\ndmacount |= BIT(VALID_BIT);\r\ndmacount |= BIT(DMA_DONE_INTERRUPT_ENABLE);\r\ntd->dmaaddr = cpu_to_le32 (req->req.dma);\r\nwmb();\r\ntd->dmacount = cpu_to_le32(dmacount);\r\n}\r\nstatic inline void spin_stop_dma(struct net2280_dma_regs __iomem *dma)\r\n{\r\nhandshake(&dma->dmactl, BIT(DMA_ENABLE), 0, 50);\r\n}\r\nstatic inline void stop_dma(struct net2280_dma_regs __iomem *dma)\r\n{\r\nwritel(readl(&dma->dmactl) & ~BIT(DMA_ENABLE), &dma->dmactl);\r\nspin_stop_dma(dma);\r\n}\r\nstatic void start_queue(struct net2280_ep *ep, u32 dmactl, u32 td_dma)\r\n{\r\nstruct net2280_dma_regs __iomem *dma = ep->dma;\r\nunsigned int tmp = BIT(VALID_BIT) | (ep->is_in << DMA_DIRECTION);\r\nif (!(ep->dev->quirks & PLX_2280))\r\ntmp |= BIT(END_OF_CHAIN);\r\nwritel(tmp, &dma->dmacount);\r\nwritel(readl(&dma->dmastat), &dma->dmastat);\r\nwritel(td_dma, &dma->dmadesc);\r\nif (ep->dev->quirks & PLX_SUPERSPEED)\r\ndmactl |= BIT(DMA_REQUEST_OUTSTANDING);\r\nwritel(dmactl, &dma->dmactl);\r\n(void) readl(&ep->dev->pci->pcimstctl);\r\nwritel(BIT(DMA_START), &dma->dmastat);\r\nif (!ep->is_in)\r\nstop_out_naking(ep);\r\n}\r\nstatic void start_dma(struct net2280_ep *ep, struct net2280_request *req)\r\n{\r\nu32 tmp;\r\nstruct net2280_dma_regs __iomem *dma = ep->dma;\r\nWARN_ON(readl(&dma->dmactl) & BIT(DMA_ENABLE));\r\nwritel(0, &ep->dma->dmactl);\r\nif (!ep->is_in && (readl(&ep->regs->ep_stat) &\r\nBIT(NAK_OUT_PACKETS))) {\r\nwritel(BIT(SHORT_PACKET_TRANSFERRED_INTERRUPT),\r\n&ep->regs->ep_stat);\r\ntmp = readl(&ep->regs->ep_avail);\r\nif (tmp) {\r\nwritel(readl(&dma->dmastat), &dma->dmastat);\r\nwritel(req->req.dma, &dma->dmaaddr);\r\ntmp = min(tmp, req->req.length);\r\nreq->td->dmacount = cpu_to_le32(req->req.length - tmp);\r\nwritel(BIT(DMA_DONE_INTERRUPT_ENABLE) | tmp,\r\n&dma->dmacount);\r\nreq->td->dmadesc = 0;\r\nreq->valid = 1;\r\nwritel(BIT(DMA_ENABLE), &dma->dmactl);\r\nwritel(BIT(DMA_START), &dma->dmastat);\r\nreturn;\r\n}\r\n}\r\ntmp = dmactl_default;\r\nif (ep->is_in) {\r\nif (likely((req->req.length % ep->ep.maxpacket) ||\r\nreq->req.zero)){\r\ntmp |= BIT(DMA_FIFO_VALIDATE);\r\nep->in_fifo_validate = 1;\r\n} else\r\nep->in_fifo_validate = 0;\r\n}\r\nreq->td->dmadesc = cpu_to_le32 (ep->td_dma);\r\nfill_dma_desc(ep, req, 1);\r\nreq->td->dmacount |= cpu_to_le32(BIT(END_OF_CHAIN));\r\nstart_queue(ep, tmp, req->td_dma);\r\n}\r\nstatic inline void\r\nqueue_dma(struct net2280_ep *ep, struct net2280_request *req, int valid)\r\n{\r\nstruct net2280_dma *end;\r\ndma_addr_t tmp;\r\nend = ep->dummy;\r\nep->dummy = req->td;\r\nreq->td = end;\r\ntmp = ep->td_dma;\r\nep->td_dma = req->td_dma;\r\nreq->td_dma = tmp;\r\nend->dmadesc = cpu_to_le32 (ep->td_dma);\r\nfill_dma_desc(ep, req, valid);\r\n}\r\nstatic void\r\ndone(struct net2280_ep *ep, struct net2280_request *req, int status)\r\n{\r\nstruct net2280 *dev;\r\nunsigned stopped = ep->stopped;\r\nlist_del_init(&req->queue);\r\nif (req->req.status == -EINPROGRESS)\r\nreq->req.status = status;\r\nelse\r\nstatus = req->req.status;\r\ndev = ep->dev;\r\nif (ep->dma)\r\nusb_gadget_unmap_request(&dev->gadget, &req->req, ep->is_in);\r\nif (status && status != -ESHUTDOWN)\r\nep_vdbg(dev, "complete %s req %p stat %d len %u/%u\n",\r\nep->ep.name, &req->req, status,\r\nreq->req.actual, req->req.length);\r\nep->stopped = 1;\r\nspin_unlock(&dev->lock);\r\nusb_gadget_giveback_request(&ep->ep, &req->req);\r\nspin_lock(&dev->lock);\r\nep->stopped = stopped;\r\n}\r\nstatic int\r\nnet2280_queue(struct usb_ep *_ep, struct usb_request *_req, gfp_t gfp_flags)\r\n{\r\nstruct net2280_request *req;\r\nstruct net2280_ep *ep;\r\nstruct net2280 *dev;\r\nunsigned long flags;\r\nint ret = 0;\r\nep = container_of(_ep, struct net2280_ep, ep);\r\nif (!_ep || (!ep->desc && ep->num != 0)) {\r\npr_err("%s: Invalid ep=%p or ep->desc\n", __func__, _ep);\r\nreturn -EINVAL;\r\n}\r\nreq = container_of(_req, struct net2280_request, req);\r\nif (!_req || !_req->complete || !_req->buf ||\r\n!list_empty(&req->queue)) {\r\nret = -EINVAL;\r\ngoto print_err;\r\n}\r\nif (_req->length > (~0 & DMA_BYTE_COUNT_MASK)) {\r\nret = -EDOM;\r\ngoto print_err;\r\n}\r\ndev = ep->dev;\r\nif (!dev->driver || dev->gadget.speed == USB_SPEED_UNKNOWN) {\r\nret = -ESHUTDOWN;\r\ngoto print_err;\r\n}\r\nif (ep->dma && _req->length == 0) {\r\nret = -EOPNOTSUPP;\r\ngoto print_err;\r\n}\r\nif (ep->dma) {\r\nret = usb_gadget_map_request(&dev->gadget, _req,\r\nep->is_in);\r\nif (ret)\r\ngoto print_err;\r\n}\r\nep_vdbg(dev, "%s queue req %p, len %d buf %p\n",\r\n_ep->name, _req, _req->length, _req->buf);\r\nspin_lock_irqsave(&dev->lock, flags);\r\n_req->status = -EINPROGRESS;\r\n_req->actual = 0;\r\nif (list_empty(&ep->queue) && !ep->stopped &&\r\n!((dev->quirks & PLX_SUPERSPEED) && ep->dma &&\r\n(readl(&ep->regs->ep_rsp) & BIT(CLEAR_ENDPOINT_HALT)))) {\r\nif (ep->dma)\r\nstart_dma(ep, req);\r\nelse {\r\nif (ep->num == 0 && _req->length == 0) {\r\nallow_status(ep);\r\ndone(ep, req, 0);\r\nep_vdbg(dev, "%s status ack\n", ep->ep.name);\r\ngoto done;\r\n}\r\nif (ep->is_in)\r\nwrite_fifo(ep, _req);\r\nelse if (list_empty(&ep->queue)) {\r\nu32 s;\r\ns = readl(&ep->regs->ep_stat);\r\nif ((s & BIT(FIFO_EMPTY)) == 0) {\r\nif (read_fifo(ep, req) &&\r\nep->num == 0) {\r\ndone(ep, req, 0);\r\nallow_status(ep);\r\nreq = NULL;\r\n} else if (read_fifo(ep, req) &&\r\nep->num != 0) {\r\ndone(ep, req, 0);\r\nreq = NULL;\r\n} else\r\ns = readl(&ep->regs->ep_stat);\r\n}\r\nif (req && (s & BIT(NAK_OUT_PACKETS)))\r\nwritel(BIT(CLEAR_NAK_OUT_PACKETS),\r\n&ep->regs->ep_rsp);\r\n}\r\n}\r\n} else if (ep->dma) {\r\nint valid = 1;\r\nif (ep->is_in) {\r\nint expect;\r\nexpect = likely(req->req.zero ||\r\n(req->req.length % ep->ep.maxpacket));\r\nif (expect != ep->in_fifo_validate)\r\nvalid = 0;\r\n}\r\nqueue_dma(ep, req, valid);\r\n}\r\nep->responded = 1;\r\nif (req)\r\nlist_add_tail(&req->queue, &ep->queue);\r\ndone:\r\nspin_unlock_irqrestore(&dev->lock, flags);\r\nreturn ret;\r\nprint_err:\r\ndev_err(&ep->dev->pdev->dev, "%s: error=%d\n", __func__, ret);\r\nreturn ret;\r\n}\r\nstatic inline void\r\ndma_done(struct net2280_ep *ep, struct net2280_request *req, u32 dmacount,\r\nint status)\r\n{\r\nreq->req.actual = req->req.length - (DMA_BYTE_COUNT_MASK & dmacount);\r\ndone(ep, req, status);\r\n}\r\nstatic void scan_dma_completions(struct net2280_ep *ep)\r\n{\r\nwhile (!list_empty(&ep->queue)) {\r\nstruct net2280_request *req;\r\nu32 tmp;\r\nreq = list_entry(ep->queue.next,\r\nstruct net2280_request, queue);\r\nif (!req->valid)\r\nbreak;\r\nrmb();\r\ntmp = le32_to_cpup(&req->td->dmacount);\r\nif ((tmp & BIT(VALID_BIT)) != 0)\r\nbreak;\r\nif (unlikely(req->td->dmadesc == 0)) {\r\ntmp = readl(&ep->dma->dmacount);\r\nif (tmp & DMA_BYTE_COUNT_MASK)\r\nbreak;\r\ndma_done(ep, req, tmp, 0);\r\nbreak;\r\n} else if (!ep->is_in &&\r\n(req->req.length % ep->ep.maxpacket) &&\r\n!(ep->dev->quirks & PLX_SUPERSPEED)) {\r\ntmp = readl(&ep->regs->ep_stat);\r\nif ((tmp & BIT(NAK_OUT_PACKETS)) == 0) {\r\nep_warn(ep->dev, "%s lost packet sync!\n",\r\nep->ep.name);\r\nreq->req.status = -EOVERFLOW;\r\n} else {\r\ntmp = readl(&ep->regs->ep_avail);\r\nif (tmp) {\r\nep->out_overflow = 1;\r\nep_dbg(ep->dev,\r\n"%s dma, discard %d len %d\n",\r\nep->ep.name, tmp,\r\nreq->req.length);\r\nreq->req.status = -EOVERFLOW;\r\n}\r\n}\r\n}\r\ndma_done(ep, req, tmp, 0);\r\n}\r\n}\r\nstatic void restart_dma(struct net2280_ep *ep)\r\n{\r\nstruct net2280_request *req;\r\nif (ep->stopped)\r\nreturn;\r\nreq = list_entry(ep->queue.next, struct net2280_request, queue);\r\nstart_dma(ep, req);\r\n}\r\nstatic void abort_dma(struct net2280_ep *ep)\r\n{\r\nif (likely(!list_empty(&ep->queue))) {\r\nwritel(BIT(DMA_ABORT), &ep->dma->dmastat);\r\nspin_stop_dma(ep->dma);\r\n} else\r\nstop_dma(ep->dma);\r\nscan_dma_completions(ep);\r\n}\r\nstatic void nuke(struct net2280_ep *ep)\r\n{\r\nstruct net2280_request *req;\r\nep->stopped = 1;\r\nif (ep->dma)\r\nabort_dma(ep);\r\nwhile (!list_empty(&ep->queue)) {\r\nreq = list_entry(ep->queue.next,\r\nstruct net2280_request,\r\nqueue);\r\ndone(ep, req, -ESHUTDOWN);\r\n}\r\n}\r\nstatic int net2280_dequeue(struct usb_ep *_ep, struct usb_request *_req)\r\n{\r\nstruct net2280_ep *ep;\r\nstruct net2280_request *req;\r\nunsigned long flags;\r\nu32 dmactl;\r\nint stopped;\r\nep = container_of(_ep, struct net2280_ep, ep);\r\nif (!_ep || (!ep->desc && ep->num != 0) || !_req) {\r\npr_err("%s: Invalid ep=%p or ep->desc or req=%p\n",\r\n__func__, _ep, _req);\r\nreturn -EINVAL;\r\n}\r\nspin_lock_irqsave(&ep->dev->lock, flags);\r\nstopped = ep->stopped;\r\ndmactl = 0;\r\nep->stopped = 1;\r\nif (ep->dma) {\r\ndmactl = readl(&ep->dma->dmactl);\r\nstop_dma(ep->dma);\r\nscan_dma_completions(ep);\r\n}\r\nlist_for_each_entry(req, &ep->queue, queue) {\r\nif (&req->req == _req)\r\nbreak;\r\n}\r\nif (&req->req != _req) {\r\nspin_unlock_irqrestore(&ep->dev->lock, flags);\r\ndev_err(&ep->dev->pdev->dev, "%s: Request mismatch\n",\r\n__func__);\r\nreturn -EINVAL;\r\n}\r\nif (ep->queue.next == &req->queue) {\r\nif (ep->dma) {\r\nep_dbg(ep->dev, "unlink (%s) dma\n", _ep->name);\r\n_req->status = -ECONNRESET;\r\nabort_dma(ep);\r\nif (likely(ep->queue.next == &req->queue)) {\r\nreq->td->dmacount = 0;\r\ndma_done(ep, req,\r\nreadl(&ep->dma->dmacount),\r\n-ECONNRESET);\r\n}\r\n} else {\r\nep_dbg(ep->dev, "unlink (%s) pio\n", _ep->name);\r\ndone(ep, req, -ECONNRESET);\r\n}\r\nreq = NULL;\r\n}\r\nif (req)\r\ndone(ep, req, -ECONNRESET);\r\nep->stopped = stopped;\r\nif (ep->dma) {\r\nif (list_empty(&ep->queue))\r\nstop_dma(ep->dma);\r\nelse if (!ep->stopped) {\r\nif (req)\r\nwritel(dmactl, &ep->dma->dmactl);\r\nelse\r\nstart_dma(ep, list_entry(ep->queue.next,\r\nstruct net2280_request, queue));\r\n}\r\n}\r\nspin_unlock_irqrestore(&ep->dev->lock, flags);\r\nreturn 0;\r\n}\r\nstatic int\r\nnet2280_set_halt_and_wedge(struct usb_ep *_ep, int value, int wedged)\r\n{\r\nstruct net2280_ep *ep;\r\nunsigned long flags;\r\nint retval = 0;\r\nep = container_of(_ep, struct net2280_ep, ep);\r\nif (!_ep || (!ep->desc && ep->num != 0)) {\r\npr_err("%s: Invalid ep=%p or ep->desc\n", __func__, _ep);\r\nreturn -EINVAL;\r\n}\r\nif (!ep->dev->driver || ep->dev->gadget.speed == USB_SPEED_UNKNOWN) {\r\nretval = -ESHUTDOWN;\r\ngoto print_err;\r\n}\r\nif (ep->desc && (ep->desc->bmAttributes & 0x03)\r\n== USB_ENDPOINT_XFER_ISOC) {\r\nretval = -EINVAL;\r\ngoto print_err;\r\n}\r\nspin_lock_irqsave(&ep->dev->lock, flags);\r\nif (!list_empty(&ep->queue)) {\r\nretval = -EAGAIN;\r\ngoto print_unlock;\r\n} else if (ep->is_in && value && net2280_fifo_status(_ep) != 0) {\r\nretval = -EAGAIN;\r\ngoto print_unlock;\r\n} else {\r\nep_vdbg(ep->dev, "%s %s %s\n", _ep->name,\r\nvalue ? "set" : "clear",\r\nwedged ? "wedge" : "halt");\r\nif (value) {\r\nif (ep->num == 0)\r\nep->dev->protocol_stall = 1;\r\nelse\r\nset_halt(ep);\r\nif (wedged)\r\nep->wedged = 1;\r\n} else {\r\nclear_halt(ep);\r\nif (ep->dev->quirks & PLX_SUPERSPEED &&\r\n!list_empty(&ep->queue) && ep->td_dma)\r\nrestart_dma(ep);\r\nep->wedged = 0;\r\n}\r\n(void) readl(&ep->regs->ep_rsp);\r\n}\r\nspin_unlock_irqrestore(&ep->dev->lock, flags);\r\nreturn retval;\r\nprint_unlock:\r\nspin_unlock_irqrestore(&ep->dev->lock, flags);\r\nprint_err:\r\ndev_err(&ep->dev->pdev->dev, "%s: error=%d\n", __func__, retval);\r\nreturn retval;\r\n}\r\nstatic int net2280_set_halt(struct usb_ep *_ep, int value)\r\n{\r\nreturn net2280_set_halt_and_wedge(_ep, value, 0);\r\n}\r\nstatic int net2280_set_wedge(struct usb_ep *_ep)\r\n{\r\nif (!_ep || _ep->name == ep0name) {\r\npr_err("%s: Invalid ep=%p or ep0\n", __func__, _ep);\r\nreturn -EINVAL;\r\n}\r\nreturn net2280_set_halt_and_wedge(_ep, 1, 1);\r\n}\r\nstatic int net2280_fifo_status(struct usb_ep *_ep)\r\n{\r\nstruct net2280_ep *ep;\r\nu32 avail;\r\nep = container_of(_ep, struct net2280_ep, ep);\r\nif (!_ep || (!ep->desc && ep->num != 0)) {\r\npr_err("%s: Invalid ep=%p or ep->desc\n", __func__, _ep);\r\nreturn -ENODEV;\r\n}\r\nif (!ep->dev->driver || ep->dev->gadget.speed == USB_SPEED_UNKNOWN) {\r\ndev_err(&ep->dev->pdev->dev,\r\n"%s: Invalid driver=%p or speed=%d\n",\r\n__func__, ep->dev->driver, ep->dev->gadget.speed);\r\nreturn -ESHUTDOWN;\r\n}\r\navail = readl(&ep->regs->ep_avail) & (BIT(12) - 1);\r\nif (avail > ep->fifo_size) {\r\ndev_err(&ep->dev->pdev->dev, "%s: Fifo overflow\n", __func__);\r\nreturn -EOVERFLOW;\r\n}\r\nif (ep->is_in)\r\navail = ep->fifo_size - avail;\r\nreturn avail;\r\n}\r\nstatic void net2280_fifo_flush(struct usb_ep *_ep)\r\n{\r\nstruct net2280_ep *ep;\r\nep = container_of(_ep, struct net2280_ep, ep);\r\nif (!_ep || (!ep->desc && ep->num != 0)) {\r\npr_err("%s: Invalid ep=%p or ep->desc\n", __func__, _ep);\r\nreturn;\r\n}\r\nif (!ep->dev->driver || ep->dev->gadget.speed == USB_SPEED_UNKNOWN) {\r\ndev_err(&ep->dev->pdev->dev,\r\n"%s: Invalid driver=%p or speed=%d\n",\r\n__func__, ep->dev->driver, ep->dev->gadget.speed);\r\nreturn;\r\n}\r\nwritel(BIT(FIFO_FLUSH), &ep->regs->ep_stat);\r\n(void) readl(&ep->regs->ep_rsp);\r\n}\r\nstatic int net2280_get_frame(struct usb_gadget *_gadget)\r\n{\r\nstruct net2280 *dev;\r\nunsigned long flags;\r\nu16 retval;\r\nif (!_gadget)\r\nreturn -ENODEV;\r\ndev = container_of(_gadget, struct net2280, gadget);\r\nspin_lock_irqsave(&dev->lock, flags);\r\nretval = get_idx_reg(dev->regs, REG_FRAME) & 0x03ff;\r\nspin_unlock_irqrestore(&dev->lock, flags);\r\nreturn retval;\r\n}\r\nstatic int net2280_wakeup(struct usb_gadget *_gadget)\r\n{\r\nstruct net2280 *dev;\r\nu32 tmp;\r\nunsigned long flags;\r\nif (!_gadget)\r\nreturn 0;\r\ndev = container_of(_gadget, struct net2280, gadget);\r\nspin_lock_irqsave(&dev->lock, flags);\r\ntmp = readl(&dev->usb->usbctl);\r\nif (tmp & BIT(DEVICE_REMOTE_WAKEUP_ENABLE))\r\nwritel(BIT(GENERATE_RESUME), &dev->usb->usbstat);\r\nspin_unlock_irqrestore(&dev->lock, flags);\r\nreturn 0;\r\n}\r\nstatic int net2280_set_selfpowered(struct usb_gadget *_gadget, int value)\r\n{\r\nstruct net2280 *dev;\r\nu32 tmp;\r\nunsigned long flags;\r\nif (!_gadget)\r\nreturn 0;\r\ndev = container_of(_gadget, struct net2280, gadget);\r\nspin_lock_irqsave(&dev->lock, flags);\r\ntmp = readl(&dev->usb->usbctl);\r\nif (value) {\r\ntmp |= BIT(SELF_POWERED_STATUS);\r\n_gadget->is_selfpowered = 1;\r\n} else {\r\ntmp &= ~BIT(SELF_POWERED_STATUS);\r\n_gadget->is_selfpowered = 0;\r\n}\r\nwritel(tmp, &dev->usb->usbctl);\r\nspin_unlock_irqrestore(&dev->lock, flags);\r\nreturn 0;\r\n}\r\nstatic int net2280_pullup(struct usb_gadget *_gadget, int is_on)\r\n{\r\nstruct net2280 *dev;\r\nu32 tmp;\r\nunsigned long flags;\r\nif (!_gadget)\r\nreturn -ENODEV;\r\ndev = container_of(_gadget, struct net2280, gadget);\r\nspin_lock_irqsave(&dev->lock, flags);\r\ntmp = readl(&dev->usb->usbctl);\r\ndev->softconnect = (is_on != 0);\r\nif (is_on) {\r\nep0_start(dev);\r\nwritel(tmp | BIT(USB_DETECT_ENABLE), &dev->usb->usbctl);\r\n} else {\r\nwritel(tmp & ~BIT(USB_DETECT_ENABLE), &dev->usb->usbctl);\r\nstop_activity(dev, dev->driver);\r\n}\r\nspin_unlock_irqrestore(&dev->lock, flags);\r\nreturn 0;\r\n}\r\nstatic struct usb_ep *net2280_match_ep(struct usb_gadget *_gadget,\r\nstruct usb_endpoint_descriptor *desc,\r\nstruct usb_ss_ep_comp_descriptor *ep_comp)\r\n{\r\nchar name[8];\r\nstruct usb_ep *ep;\r\nif (usb_endpoint_type(desc) == USB_ENDPOINT_XFER_INT) {\r\nep = gadget_find_ep_by_name(_gadget, "ep-e");\r\nif (ep && usb_gadget_ep_match_desc(_gadget, ep, desc, ep_comp))\r\nreturn ep;\r\nep = gadget_find_ep_by_name(_gadget, "ep-f");\r\nif (ep && usb_gadget_ep_match_desc(_gadget, ep, desc, ep_comp))\r\nreturn ep;\r\n}\r\nsnprintf(name, sizeof(name), "ep%d%s", usb_endpoint_num(desc),\r\nusb_endpoint_dir_in(desc) ? "in" : "out");\r\nep = gadget_find_ep_by_name(_gadget, name);\r\nif (ep && usb_gadget_ep_match_desc(_gadget, ep, desc, ep_comp))\r\nreturn ep;\r\nreturn NULL;\r\n}\r\nstatic ssize_t function_show(struct device *_dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct net2280 *dev = dev_get_drvdata(_dev);\r\nif (!dev->driver || !dev->driver->function ||\r\nstrlen(dev->driver->function) > PAGE_SIZE)\r\nreturn 0;\r\nreturn scnprintf(buf, PAGE_SIZE, "%s\n", dev->driver->function);\r\n}\r\nstatic ssize_t registers_show(struct device *_dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct net2280 *dev;\r\nchar *next;\r\nunsigned size, t;\r\nunsigned long flags;\r\nint i;\r\nu32 t1, t2;\r\nconst char *s;\r\ndev = dev_get_drvdata(_dev);\r\nnext = buf;\r\nsize = PAGE_SIZE;\r\nspin_lock_irqsave(&dev->lock, flags);\r\nif (dev->driver)\r\ns = dev->driver->driver.name;\r\nelse\r\ns = "(none)";\r\nt = scnprintf(next, size, "%s version " DRIVER_VERSION\r\n", chiprev %04x\n\n"\r\n"devinit %03x fifoctl %08x gadget '%s'\n"\r\n"pci irqenb0 %02x irqenb1 %08x "\r\n"irqstat0 %04x irqstat1 %08x\n",\r\ndriver_name, dev->chiprev,\r\nreadl(&dev->regs->devinit),\r\nreadl(&dev->regs->fifoctl),\r\ns,\r\nreadl(&dev->regs->pciirqenb0),\r\nreadl(&dev->regs->pciirqenb1),\r\nreadl(&dev->regs->irqstat0),\r\nreadl(&dev->regs->irqstat1));\r\nsize -= t;\r\nnext += t;\r\nt1 = readl(&dev->usb->usbctl);\r\nt2 = readl(&dev->usb->usbstat);\r\nif (t1 & BIT(VBUS_PIN)) {\r\nif (t2 & BIT(HIGH_SPEED))\r\ns = "high speed";\r\nelse if (dev->gadget.speed == USB_SPEED_UNKNOWN)\r\ns = "powered";\r\nelse\r\ns = "full speed";\r\n} else\r\ns = "not attached";\r\nt = scnprintf(next, size,\r\n"stdrsp %08x usbctl %08x usbstat %08x "\r\n"addr 0x%02x (%s)\n",\r\nreadl(&dev->usb->stdrsp), t1, t2,\r\nreadl(&dev->usb->ouraddr), s);\r\nsize -= t;\r\nnext += t;\r\nfor (i = 0; i < dev->n_ep; i++) {\r\nstruct net2280_ep *ep;\r\nep = &dev->ep[i];\r\nif (i && !ep->desc)\r\ncontinue;\r\nt1 = readl(&ep->cfg->ep_cfg);\r\nt2 = readl(&ep->regs->ep_rsp) & 0xff;\r\nt = scnprintf(next, size,\r\n"\n%s\tcfg %05x rsp (%02x) %s%s%s%s%s%s%s%s"\r\n"irqenb %02x\n",\r\nep->ep.name, t1, t2,\r\n(t2 & BIT(CLEAR_NAK_OUT_PACKETS))\r\n? "NAK " : "",\r\n(t2 & BIT(CLEAR_EP_HIDE_STATUS_PHASE))\r\n? "hide " : "",\r\n(t2 & BIT(CLEAR_EP_FORCE_CRC_ERROR))\r\n? "CRC " : "",\r\n(t2 & BIT(CLEAR_INTERRUPT_MODE))\r\n? "interrupt " : "",\r\n(t2 & BIT(CLEAR_CONTROL_STATUS_PHASE_HANDSHAKE))\r\n? "status " : "",\r\n(t2 & BIT(CLEAR_NAK_OUT_PACKETS_MODE))\r\n? "NAKmode " : "",\r\n(t2 & BIT(CLEAR_ENDPOINT_TOGGLE))\r\n? "DATA1 " : "DATA0 ",\r\n(t2 & BIT(CLEAR_ENDPOINT_HALT))\r\n? "HALT " : "",\r\nreadl(&ep->regs->ep_irqenb));\r\nsize -= t;\r\nnext += t;\r\nt = scnprintf(next, size,\r\n"\tstat %08x avail %04x "\r\n"(ep%d%s-%s)%s\n",\r\nreadl(&ep->regs->ep_stat),\r\nreadl(&ep->regs->ep_avail),\r\nt1 & 0x0f, DIR_STRING(t1),\r\ntype_string(t1 >> 8),\r\nep->stopped ? "*" : "");\r\nsize -= t;\r\nnext += t;\r\nif (!ep->dma)\r\ncontinue;\r\nt = scnprintf(next, size,\r\n" dma\tctl %08x stat %08x count %08x\n"\r\n"\taddr %08x desc %08x\n",\r\nreadl(&ep->dma->dmactl),\r\nreadl(&ep->dma->dmastat),\r\nreadl(&ep->dma->dmacount),\r\nreadl(&ep->dma->dmaaddr),\r\nreadl(&ep->dma->dmadesc));\r\nsize -= t;\r\nnext += t;\r\n}\r\nt = scnprintf(next, size, "\nirqs: ");\r\nsize -= t;\r\nnext += t;\r\nfor (i = 0; i < dev->n_ep; i++) {\r\nstruct net2280_ep *ep;\r\nep = &dev->ep[i];\r\nif (i && !ep->irqs)\r\ncontinue;\r\nt = scnprintf(next, size, " %s/%lu", ep->ep.name, ep->irqs);\r\nsize -= t;\r\nnext += t;\r\n}\r\nt = scnprintf(next, size, "\n");\r\nsize -= t;\r\nnext += t;\r\nspin_unlock_irqrestore(&dev->lock, flags);\r\nreturn PAGE_SIZE - size;\r\n}\r\nstatic ssize_t queues_show(struct device *_dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct net2280 *dev;\r\nchar *next;\r\nunsigned size;\r\nunsigned long flags;\r\nint i;\r\ndev = dev_get_drvdata(_dev);\r\nnext = buf;\r\nsize = PAGE_SIZE;\r\nspin_lock_irqsave(&dev->lock, flags);\r\nfor (i = 0; i < dev->n_ep; i++) {\r\nstruct net2280_ep *ep = &dev->ep[i];\r\nstruct net2280_request *req;\r\nint t;\r\nif (i != 0) {\r\nconst struct usb_endpoint_descriptor *d;\r\nd = ep->desc;\r\nif (!d)\r\ncontinue;\r\nt = d->bEndpointAddress;\r\nt = scnprintf(next, size,\r\n"\n%s (ep%d%s-%s) max %04x %s fifo %d\n",\r\nep->ep.name, t & USB_ENDPOINT_NUMBER_MASK,\r\n(t & USB_DIR_IN) ? "in" : "out",\r\ntype_string(d->bmAttributes),\r\nusb_endpoint_maxp(d) & 0x1fff,\r\nep->dma ? "dma" : "pio", ep->fifo_size\r\n);\r\n} else\r\nt = scnprintf(next, size, "ep0 max 64 pio %s\n",\r\nep->is_in ? "in" : "out");\r\nif (t <= 0 || t > size)\r\ngoto done;\r\nsize -= t;\r\nnext += t;\r\nif (list_empty(&ep->queue)) {\r\nt = scnprintf(next, size, "\t(nothing queued)\n");\r\nif (t <= 0 || t > size)\r\ngoto done;\r\nsize -= t;\r\nnext += t;\r\ncontinue;\r\n}\r\nlist_for_each_entry(req, &ep->queue, queue) {\r\nif (ep->dma && req->td_dma == readl(&ep->dma->dmadesc))\r\nt = scnprintf(next, size,\r\n"\treq %p len %d/%d "\r\n"buf %p (dmacount %08x)\n",\r\n&req->req, req->req.actual,\r\nreq->req.length, req->req.buf,\r\nreadl(&ep->dma->dmacount));\r\nelse\r\nt = scnprintf(next, size,\r\n"\treq %p len %d/%d buf %p\n",\r\n&req->req, req->req.actual,\r\nreq->req.length, req->req.buf);\r\nif (t <= 0 || t > size)\r\ngoto done;\r\nsize -= t;\r\nnext += t;\r\nif (ep->dma) {\r\nstruct net2280_dma *td;\r\ntd = req->td;\r\nt = scnprintf(next, size, "\t td %08x "\r\n" count %08x buf %08x desc %08x\n",\r\n(u32) req->td_dma,\r\nle32_to_cpu(td->dmacount),\r\nle32_to_cpu(td->dmaaddr),\r\nle32_to_cpu(td->dmadesc));\r\nif (t <= 0 || t > size)\r\ngoto done;\r\nsize -= t;\r\nnext += t;\r\n}\r\n}\r\n}\r\ndone:\r\nspin_unlock_irqrestore(&dev->lock, flags);\r\nreturn PAGE_SIZE - size;\r\n}\r\nstatic void set_fifo_mode(struct net2280 *dev, int mode)\r\n{\r\nwritel((0xffff << PCI_BASE2_RANGE) | mode, &dev->regs->fifoctl);\r\nINIT_LIST_HEAD(&dev->gadget.ep_list);\r\nlist_add_tail(&dev->ep[1].ep.ep_list, &dev->gadget.ep_list);\r\nlist_add_tail(&dev->ep[2].ep.ep_list, &dev->gadget.ep_list);\r\nswitch (mode) {\r\ncase 0:\r\nlist_add_tail(&dev->ep[3].ep.ep_list, &dev->gadget.ep_list);\r\nlist_add_tail(&dev->ep[4].ep.ep_list, &dev->gadget.ep_list);\r\ndev->ep[1].fifo_size = dev->ep[2].fifo_size = 1024;\r\nbreak;\r\ncase 1:\r\ndev->ep[1].fifo_size = dev->ep[2].fifo_size = 2048;\r\nbreak;\r\ncase 2:\r\nlist_add_tail(&dev->ep[3].ep.ep_list, &dev->gadget.ep_list);\r\ndev->ep[1].fifo_size = 2048;\r\ndev->ep[2].fifo_size = 1024;\r\nbreak;\r\n}\r\nlist_add_tail(&dev->ep[5].ep.ep_list, &dev->gadget.ep_list);\r\nlist_add_tail(&dev->ep[6].ep.ep_list, &dev->gadget.ep_list);\r\n}\r\nstatic void defect7374_disable_data_eps(struct net2280 *dev)\r\n{\r\nstruct net2280_ep *ep;\r\nint i;\r\nunsigned char ep_sel;\r\nu32 tmp_reg;\r\nfor (i = 1; i < 5; i++) {\r\nep = &dev->ep[i];\r\nwritel(i, &ep->cfg->ep_cfg);\r\n}\r\nfor (i = 0; i < 6; i++)\r\nwritel(0, &dev->dep[i].dep_cfg);\r\nfor (ep_sel = 0; ep_sel <= 21; ep_sel++) {\r\ntmp_reg = readl(&dev->plregs->pl_ep_ctrl);\r\nwritel(((tmp_reg & ~0x1f) | ep_sel), &dev->plregs->pl_ep_ctrl);\r\nif (ep_sel < 2 || (ep_sel > 9 && ep_sel < 14) ||\r\nep_sel == 18 || ep_sel == 20)\r\ncontinue;\r\ntmp_reg = readl(&dev->plregs->pl_ep_cfg_4);\r\ntmp_reg &= ~BIT(NON_CTRL_IN_TOLERATE_BAD_DIR);\r\nwritel(tmp_reg, &dev->plregs->pl_ep_cfg_4);\r\ntmp_reg = readl(&dev->plregs->pl_ep_ctrl);\r\ntmp_reg |= BIT(EP_INITIALIZED);\r\nwritel(tmp_reg, &dev->plregs->pl_ep_ctrl);\r\n}\r\n}\r\nstatic void defect7374_enable_data_eps_zero(struct net2280 *dev)\r\n{\r\nu32 tmp = 0, tmp_reg;\r\nu32 scratch;\r\nint i;\r\nunsigned char ep_sel;\r\nscratch = get_idx_reg(dev->regs, SCRATCH);\r\nWARN_ON((scratch & (0xf << DEFECT7374_FSM_FIELD))\r\n== DEFECT7374_FSM_SS_CONTROL_READ);\r\nscratch &= ~(0xf << DEFECT7374_FSM_FIELD);\r\nep_warn(dev, "Operate Defect 7374 workaround soft this time");\r\nep_warn(dev, "It will operate on cold-reboot and SS connect");\r\ntmp = ((0 << ENDPOINT_NUMBER) | BIT(ENDPOINT_DIRECTION) |\r\n(2 << OUT_ENDPOINT_TYPE) | (2 << IN_ENDPOINT_TYPE) |\r\n((dev->enhanced_mode) ?\r\nBIT(OUT_ENDPOINT_ENABLE) | BIT(IN_ENDPOINT_ENABLE) :\r\nBIT(ENDPOINT_ENABLE)));\r\nfor (i = 1; i < 5; i++)\r\nwritel(tmp, &dev->ep[i].cfg->ep_cfg);\r\ntmp = ((0 << ENDPOINT_NUMBER) | BIT(ENDPOINT_ENABLE));\r\nwritel(tmp, &dev->dep[1].dep_cfg);\r\nwritel(tmp, &dev->dep[3].dep_cfg);\r\nwritel(tmp, &dev->dep[4].dep_cfg);\r\nwritel(tmp, &dev->dep[5].dep_cfg);\r\nfor (ep_sel = 0; ep_sel <= 21; ep_sel++) {\r\ntmp_reg = readl(&dev->plregs->pl_ep_ctrl);\r\nwritel(((tmp_reg & ~0x1f) | ep_sel),\r\n&dev->plregs->pl_ep_ctrl);\r\nif (ep_sel == 1) {\r\ntmp =\r\n(readl(&dev->plregs->pl_ep_ctrl) |\r\nBIT(CLEAR_ACK_ERROR_CODE) | 0);\r\nwritel(tmp, &dev->plregs->pl_ep_ctrl);\r\ncontinue;\r\n}\r\nif (ep_sel == 0 || (ep_sel > 9 && ep_sel < 14) ||\r\nep_sel == 18 || ep_sel == 20)\r\ncontinue;\r\ntmp = (readl(&dev->plregs->pl_ep_cfg_4) |\r\nBIT(NON_CTRL_IN_TOLERATE_BAD_DIR) | 0);\r\nwritel(tmp, &dev->plregs->pl_ep_cfg_4);\r\ntmp = readl(&dev->plregs->pl_ep_ctrl) &\r\n~BIT(EP_INITIALIZED);\r\nwritel(tmp, &dev->plregs->pl_ep_ctrl);\r\n}\r\nscratch |= DEFECT7374_FSM_WAITING_FOR_CONTROL_READ;\r\nset_idx_reg(dev->regs, SCRATCH, scratch);\r\n}\r\nstatic void usb_reset_228x(struct net2280 *dev)\r\n{\r\nu32 tmp;\r\ndev->gadget.speed = USB_SPEED_UNKNOWN;\r\n(void) readl(&dev->usb->usbctl);\r\nnet2280_led_init(dev);\r\nwritel(0, &dev->usb->stdrsp);\r\nwritel(0, &dev->regs->pciirqenb0);\r\nwritel(0, &dev->regs->pciirqenb1);\r\nfor (tmp = 0; tmp < 4; tmp++) {\r\nstruct net2280_ep *ep = &dev->ep[tmp + 1];\r\nif (ep->dma)\r\nabort_dma(ep);\r\n}\r\nwritel(~0, &dev->regs->irqstat0),\r\nwritel(~(u32)BIT(SUSPEND_REQUEST_INTERRUPT), &dev->regs->irqstat1),\r\ntmp = readl(&dev->regs->devinit) |\r\nBIT(PCI_ENABLE) |\r\nBIT(FIFO_SOFT_RESET) |\r\nBIT(USB_SOFT_RESET) |\r\nBIT(M8051_RESET);\r\nwritel(tmp, &dev->regs->devinit);\r\nset_fifo_mode(dev, (fifo_mode <= 2) ? fifo_mode : 0);\r\n}\r\nstatic void usb_reset_338x(struct net2280 *dev)\r\n{\r\nu32 tmp;\r\ndev->gadget.speed = USB_SPEED_UNKNOWN;\r\n(void)readl(&dev->usb->usbctl);\r\nnet2280_led_init(dev);\r\nif (dev->bug7734_patched) {\r\nwritel(0, &dev->usb->stdrsp);\r\nwritel(0, &dev->regs->pciirqenb0);\r\nwritel(0, &dev->regs->pciirqenb1);\r\n}\r\nfor (tmp = 0; tmp < 4; tmp++) {\r\nstruct net2280_ep *ep = &dev->ep[tmp + 1];\r\nstruct net2280_dma_regs __iomem *dma;\r\nif (ep->dma) {\r\nabort_dma(ep);\r\n} else {\r\ndma = &dev->dma[tmp];\r\nwritel(BIT(DMA_ABORT), &dma->dmastat);\r\nwritel(0, &dma->dmactl);\r\n}\r\n}\r\nwritel(~0, &dev->regs->irqstat0), writel(~0, &dev->regs->irqstat1);\r\nif (dev->bug7734_patched) {\r\ntmp = readl(&dev->regs->devinit) |\r\nBIT(PCI_ENABLE) |\r\nBIT(FIFO_SOFT_RESET) |\r\nBIT(USB_SOFT_RESET) |\r\nBIT(M8051_RESET);\r\nwritel(tmp, &dev->regs->devinit);\r\n}\r\nINIT_LIST_HEAD(&dev->gadget.ep_list);\r\nfor (tmp = 1; tmp < dev->n_ep; tmp++)\r\nlist_add_tail(&dev->ep[tmp].ep.ep_list, &dev->gadget.ep_list);\r\n}\r\nstatic void usb_reset(struct net2280 *dev)\r\n{\r\nif (dev->quirks & PLX_LEGACY)\r\nreturn usb_reset_228x(dev);\r\nreturn usb_reset_338x(dev);\r\n}\r\nstatic void usb_reinit_228x(struct net2280 *dev)\r\n{\r\nu32 tmp;\r\nfor (tmp = 0; tmp < 7; tmp++) {\r\nstruct net2280_ep *ep = &dev->ep[tmp];\r\nep->ep.name = ep_info_dft[tmp].name;\r\nep->ep.caps = ep_info_dft[tmp].caps;\r\nep->dev = dev;\r\nep->num = tmp;\r\nif (tmp > 0 && tmp <= 4) {\r\nep->fifo_size = 1024;\r\nep->dma = &dev->dma[tmp - 1];\r\n} else\r\nep->fifo_size = 64;\r\nep->regs = &dev->epregs[tmp];\r\nep->cfg = &dev->epregs[tmp];\r\nep_reset_228x(dev->regs, ep);\r\n}\r\nusb_ep_set_maxpacket_limit(&dev->ep[0].ep, 64);\r\nusb_ep_set_maxpacket_limit(&dev->ep[5].ep, 64);\r\nusb_ep_set_maxpacket_limit(&dev->ep[6].ep, 64);\r\ndev->gadget.ep0 = &dev->ep[0].ep;\r\ndev->ep[0].stopped = 0;\r\nINIT_LIST_HEAD(&dev->gadget.ep0->ep_list);\r\nfor (tmp = 0; tmp < 5; tmp++)\r\nwritel(EP_DONTUSE, &dev->dep[tmp].dep_cfg);\r\n}\r\nstatic void usb_reinit_338x(struct net2280 *dev)\r\n{\r\nint i;\r\nu32 tmp, val;\r\nstatic const u32 ne[9] = { 0, 1, 2, 3, 4, 1, 2, 3, 4 };\r\nstatic const u32 ep_reg_addr[9] = { 0x00, 0xC0, 0x00, 0xC0, 0x00,\r\n0x00, 0xC0, 0x00, 0xC0 };\r\nfor (i = 0; i < dev->n_ep; i++) {\r\nstruct net2280_ep *ep = &dev->ep[i];\r\nep->ep.name = dev->enhanced_mode ? ep_info_adv[i].name :\r\nep_info_dft[i].name;\r\nep->ep.caps = dev->enhanced_mode ? ep_info_adv[i].caps :\r\nep_info_dft[i].caps;\r\nep->dev = dev;\r\nep->num = i;\r\nif (i > 0 && i <= 4)\r\nep->dma = &dev->dma[i - 1];\r\nif (dev->enhanced_mode) {\r\nep->cfg = &dev->epregs[ne[i]];\r\nif (i > 0 && i < 5)\r\nwritel(ne[i], &ep->cfg->ep_cfg);\r\nep->regs = (struct net2280_ep_regs __iomem *)\r\n(((void __iomem *)&dev->epregs[ne[i]]) +\r\nep_reg_addr[i]);\r\n} else {\r\nep->cfg = &dev->epregs[i];\r\nep->regs = &dev->epregs[i];\r\n}\r\nep->fifo_size = (i != 0) ? 2048 : 512;\r\nep_reset_338x(dev->regs, ep);\r\n}\r\nusb_ep_set_maxpacket_limit(&dev->ep[0].ep, 512);\r\ndev->gadget.ep0 = &dev->ep[0].ep;\r\ndev->ep[0].stopped = 0;\r\nif (dev->bug7734_patched) {\r\ntmp = readl(&dev->usb_ext->usbctl2) &\r\n~(BIT(U1_ENABLE) | BIT(U2_ENABLE) | BIT(LTM_ENABLE));\r\nwritel(tmp, &dev->usb_ext->usbctl2);\r\n}\r\nval = readl(&dev->ll_lfps_regs->ll_lfps_5);\r\nval &= ~(0xf << TIMER_LFPS_6US);\r\nval |= 0x5 << TIMER_LFPS_6US;\r\nwritel(val, &dev->ll_lfps_regs->ll_lfps_5);\r\nval = readl(&dev->ll_lfps_regs->ll_lfps_6);\r\nval &= ~(0xffff << TIMER_LFPS_80US);\r\nval |= 0x0100 << TIMER_LFPS_80US;\r\nwritel(val, &dev->ll_lfps_regs->ll_lfps_6);\r\nval = readl(&dev->ll_tsn_regs->ll_tsn_counters_2);\r\nval &= ~(0x1f << HOT_TX_NORESET_TS2);\r\nval |= 0x10 << HOT_TX_NORESET_TS2;\r\nwritel(val, &dev->ll_tsn_regs->ll_tsn_counters_2);\r\nval = readl(&dev->ll_tsn_regs->ll_tsn_counters_3);\r\nval &= ~(0x1f << HOT_RX_RESET_TS2);\r\nval |= 0x3 << HOT_RX_RESET_TS2;\r\nwritel(val, &dev->ll_tsn_regs->ll_tsn_counters_3);\r\nval = readl(&dev->ll_chicken_reg->ll_tsn_chicken_bit);\r\nval |= BIT(RECOVERY_IDLE_TO_RECOVER_FMW);\r\nwritel(val, &dev->ll_chicken_reg->ll_tsn_chicken_bit);\r\nINIT_LIST_HEAD(&dev->gadget.ep0->ep_list);\r\nwritel(0x0D, &dev->dep[0].dep_cfg);\r\nwritel(0x0D, &dev->dep[1].dep_cfg);\r\nwritel(0x0E, &dev->dep[2].dep_cfg);\r\nwritel(0x0E, &dev->dep[3].dep_cfg);\r\nwritel(0x0F, &dev->dep[4].dep_cfg);\r\nwritel(0x0C, &dev->dep[5].dep_cfg);\r\n}\r\nstatic void usb_reinit(struct net2280 *dev)\r\n{\r\nif (dev->quirks & PLX_LEGACY)\r\nreturn usb_reinit_228x(dev);\r\nreturn usb_reinit_338x(dev);\r\n}\r\nstatic void ep0_start_228x(struct net2280 *dev)\r\n{\r\nwritel(BIT(CLEAR_EP_HIDE_STATUS_PHASE) |\r\nBIT(CLEAR_NAK_OUT_PACKETS) |\r\nBIT(CLEAR_CONTROL_STATUS_PHASE_HANDSHAKE),\r\n&dev->epregs[0].ep_rsp);\r\nwritel(BIT(SET_TEST_MODE) |\r\nBIT(SET_ADDRESS) |\r\nBIT(DEVICE_SET_CLEAR_DEVICE_REMOTE_WAKEUP) |\r\nBIT(GET_DEVICE_STATUS) |\r\nBIT(GET_INTERFACE_STATUS),\r\n&dev->usb->stdrsp);\r\nwritel(BIT(USB_ROOT_PORT_WAKEUP_ENABLE) |\r\nBIT(SELF_POWERED_USB_DEVICE) |\r\nBIT(REMOTE_WAKEUP_SUPPORT) |\r\n(dev->softconnect << USB_DETECT_ENABLE) |\r\nBIT(SELF_POWERED_STATUS),\r\n&dev->usb->usbctl);\r\nwritel(BIT(SETUP_PACKET_INTERRUPT_ENABLE) |\r\nBIT(ENDPOINT_0_INTERRUPT_ENABLE),\r\n&dev->regs->pciirqenb0);\r\nwritel(BIT(PCI_INTERRUPT_ENABLE) |\r\nBIT(PCI_MASTER_ABORT_RECEIVED_INTERRUPT_ENABLE) |\r\nBIT(PCI_TARGET_ABORT_RECEIVED_INTERRUPT_ENABLE) |\r\nBIT(PCI_RETRY_ABORT_INTERRUPT_ENABLE) |\r\nBIT(VBUS_INTERRUPT_ENABLE) |\r\nBIT(ROOT_PORT_RESET_INTERRUPT_ENABLE) |\r\nBIT(SUSPEND_REQUEST_CHANGE_INTERRUPT_ENABLE),\r\n&dev->regs->pciirqenb1);\r\n(void) readl(&dev->usb->usbctl);\r\n}\r\nstatic void ep0_start_338x(struct net2280 *dev)\r\n{\r\nif (dev->bug7734_patched)\r\nwritel(BIT(CLEAR_NAK_OUT_PACKETS_MODE) |\r\nBIT(SET_EP_HIDE_STATUS_PHASE),\r\n&dev->epregs[0].ep_rsp);\r\nwritel(BIT(SET_ISOCHRONOUS_DELAY) |\r\nBIT(SET_SEL) |\r\nBIT(SET_TEST_MODE) |\r\nBIT(SET_ADDRESS) |\r\nBIT(GET_INTERFACE_STATUS) |\r\nBIT(GET_DEVICE_STATUS),\r\n&dev->usb->stdrsp);\r\ndev->wakeup_enable = 1;\r\nwritel(BIT(USB_ROOT_PORT_WAKEUP_ENABLE) |\r\n(dev->softconnect << USB_DETECT_ENABLE) |\r\nBIT(DEVICE_REMOTE_WAKEUP_ENABLE),\r\n&dev->usb->usbctl);\r\nwritel(BIT(SETUP_PACKET_INTERRUPT_ENABLE) |\r\nBIT(ENDPOINT_0_INTERRUPT_ENABLE),\r\n&dev->regs->pciirqenb0);\r\nwritel(BIT(PCI_INTERRUPT_ENABLE) |\r\nBIT(ROOT_PORT_RESET_INTERRUPT_ENABLE) |\r\nBIT(SUSPEND_REQUEST_CHANGE_INTERRUPT_ENABLE) |\r\nBIT(VBUS_INTERRUPT_ENABLE),\r\n&dev->regs->pciirqenb1);\r\n(void)readl(&dev->usb->usbctl);\r\n}\r\nstatic void ep0_start(struct net2280 *dev)\r\n{\r\nif (dev->quirks & PLX_LEGACY)\r\nreturn ep0_start_228x(dev);\r\nreturn ep0_start_338x(dev);\r\n}\r\nstatic int net2280_start(struct usb_gadget *_gadget,\r\nstruct usb_gadget_driver *driver)\r\n{\r\nstruct net2280 *dev;\r\nint retval;\r\nunsigned i;\r\nif (!driver || driver->max_speed < USB_SPEED_HIGH ||\r\n!driver->setup)\r\nreturn -EINVAL;\r\ndev = container_of(_gadget, struct net2280, gadget);\r\nfor (i = 0; i < dev->n_ep; i++)\r\ndev->ep[i].irqs = 0;\r\ndriver->driver.bus = NULL;\r\ndev->driver = driver;\r\nretval = device_create_file(&dev->pdev->dev, &dev_attr_function);\r\nif (retval)\r\ngoto err_unbind;\r\nretval = device_create_file(&dev->pdev->dev, &dev_attr_queues);\r\nif (retval)\r\ngoto err_func;\r\nnet2280_led_active(dev, 1);\r\nif ((dev->quirks & PLX_SUPERSPEED) && !dev->bug7734_patched)\r\ndefect7374_enable_data_eps_zero(dev);\r\nep0_start(dev);\r\nreturn 0;\r\nerr_func:\r\ndevice_remove_file(&dev->pdev->dev, &dev_attr_function);\r\nerr_unbind:\r\ndev->driver = NULL;\r\nreturn retval;\r\n}\r\nstatic void stop_activity(struct net2280 *dev, struct usb_gadget_driver *driver)\r\n{\r\nint i;\r\nif (dev->gadget.speed == USB_SPEED_UNKNOWN)\r\ndriver = NULL;\r\nusb_reset(dev);\r\nfor (i = 0; i < dev->n_ep; i++)\r\nnuke(&dev->ep[i]);\r\nif (driver) {\r\nspin_unlock(&dev->lock);\r\ndriver->disconnect(&dev->gadget);\r\nspin_lock(&dev->lock);\r\n}\r\nusb_reinit(dev);\r\n}\r\nstatic int net2280_stop(struct usb_gadget *_gadget)\r\n{\r\nstruct net2280 *dev;\r\nunsigned long flags;\r\ndev = container_of(_gadget, struct net2280, gadget);\r\nspin_lock_irqsave(&dev->lock, flags);\r\nstop_activity(dev, NULL);\r\nspin_unlock_irqrestore(&dev->lock, flags);\r\nnet2280_led_active(dev, 0);\r\ndevice_remove_file(&dev->pdev->dev, &dev_attr_function);\r\ndevice_remove_file(&dev->pdev->dev, &dev_attr_queues);\r\ndev->driver = NULL;\r\nreturn 0;\r\n}\r\nstatic void handle_ep_small(struct net2280_ep *ep)\r\n{\r\nstruct net2280_request *req;\r\nu32 t;\r\nint mode = 1;\r\nif (!list_empty(&ep->queue))\r\nreq = list_entry(ep->queue.next,\r\nstruct net2280_request, queue);\r\nelse\r\nreq = NULL;\r\nt = readl(&ep->regs->ep_stat);\r\nep->irqs++;\r\nep_vdbg(ep->dev, "%s ack ep_stat %08x, req %p\n",\r\nep->ep.name, t, req ? &req->req : NULL);\r\nif (!ep->is_in || (ep->dev->quirks & PLX_2280))\r\nwritel(t & ~BIT(NAK_OUT_PACKETS), &ep->regs->ep_stat);\r\nelse\r\nwritel(t, &ep->regs->ep_stat);\r\nif (unlikely(ep->num == 0)) {\r\nif (ep->is_in) {\r\nif (t & BIT(DATA_OUT_PING_TOKEN_INTERRUPT)) {\r\nif (ep->dev->protocol_stall) {\r\nep->stopped = 1;\r\nset_halt(ep);\r\n}\r\nif (!req)\r\nallow_status(ep);\r\nmode = 2;\r\n} else if (t & BIT(DATA_IN_TOKEN_INTERRUPT)) {\r\nif (ep->dev->protocol_stall) {\r\nep->stopped = 1;\r\nset_halt(ep);\r\nmode = 2;\r\n} else if (ep->responded &&\r\n!req && !ep->stopped)\r\nwrite_fifo(ep, NULL);\r\n}\r\n} else {\r\nif (t & BIT(DATA_IN_TOKEN_INTERRUPT)) {\r\nif (ep->dev->protocol_stall) {\r\nep->stopped = 1;\r\nset_halt(ep);\r\n}\r\nmode = 2;\r\n} else if (((t & BIT(DATA_OUT_PING_TOKEN_INTERRUPT)) &&\r\nreq &&\r\nreq->req.actual == req->req.length) ||\r\n(ep->responded && !req)) {\r\nep->dev->protocol_stall = 1;\r\nset_halt(ep);\r\nep->stopped = 1;\r\nif (req)\r\ndone(ep, req, -EOVERFLOW);\r\nreq = NULL;\r\n}\r\n}\r\n}\r\nif (unlikely(!req))\r\nreturn;\r\nif (likely(ep->dma)) {\r\nif (t & BIT(SHORT_PACKET_TRANSFERRED_INTERRUPT)) {\r\nu32 count;\r\nint stopped = ep->stopped;\r\nep->stopped = 1;\r\nfor (count = 0; ; t = readl(&ep->regs->ep_stat)) {\r\nscan_dma_completions(ep);\r\nif (unlikely(list_empty(&ep->queue) ||\r\nep->out_overflow)) {\r\nreq = NULL;\r\nbreak;\r\n}\r\nreq = list_entry(ep->queue.next,\r\nstruct net2280_request, queue);\r\nif (likely(t & BIT(FIFO_EMPTY))) {\r\ncount = readl(&ep->dma->dmacount);\r\ncount &= DMA_BYTE_COUNT_MASK;\r\nif (readl(&ep->dma->dmadesc)\r\n!= req->td_dma)\r\nreq = NULL;\r\nbreak;\r\n}\r\nudelay(1);\r\n}\r\nwritel(BIT(DMA_ABORT), &ep->dma->dmastat);\r\nspin_stop_dma(ep->dma);\r\nif (likely(req)) {\r\nreq->td->dmacount = 0;\r\nt = readl(&ep->regs->ep_avail);\r\ndma_done(ep, req, count,\r\n(ep->out_overflow || t)\r\n? -EOVERFLOW : 0);\r\n}\r\nif (unlikely(ep->out_overflow ||\r\n(ep->dev->chiprev == 0x0100 &&\r\nep->dev->gadget.speed\r\n== USB_SPEED_FULL))) {\r\nout_flush(ep);\r\nep->out_overflow = 0;\r\n}\r\nep->stopped = stopped;\r\nif (!list_empty(&ep->queue))\r\nrestart_dma(ep);\r\n} else\r\nep_dbg(ep->dev, "%s dma ep_stat %08x ??\n",\r\nep->ep.name, t);\r\nreturn;\r\n} else if (t & BIT(DATA_PACKET_RECEIVED_INTERRUPT)) {\r\nif (read_fifo(ep, req) && ep->num != 0)\r\nmode = 2;\r\n} else if (t & BIT(DATA_PACKET_TRANSMITTED_INTERRUPT)) {\r\nunsigned len;\r\nlen = req->req.length - req->req.actual;\r\nif (len > ep->ep.maxpacket)\r\nlen = ep->ep.maxpacket;\r\nreq->req.actual += len;\r\nif ((req->req.actual == req->req.length) &&\r\n(!req->req.zero || len != ep->ep.maxpacket) && ep->num)\r\nmode = 2;\r\n} else if (mode == 1)\r\nreturn;\r\nif (mode == 2) {\r\ndone(ep, req, 0);\r\nif (ep->num == 0) {\r\nif (!ep->stopped)\r\nallow_status(ep);\r\nreq = NULL;\r\n} else {\r\nif (!list_empty(&ep->queue) && !ep->stopped)\r\nreq = list_entry(ep->queue.next,\r\nstruct net2280_request, queue);\r\nelse\r\nreq = NULL;\r\nif (req && !ep->is_in)\r\nstop_out_naking(ep);\r\n}\r\n}\r\nif (req && !ep->stopped) {\r\nif (t & BIT(DATA_PACKET_TRANSMITTED_INTERRUPT))\r\nwrite_fifo(ep, &req->req);\r\n}\r\n}\r\nstatic struct net2280_ep *get_ep_by_addr(struct net2280 *dev, u16 wIndex)\r\n{\r\nstruct net2280_ep *ep;\r\nif ((wIndex & USB_ENDPOINT_NUMBER_MASK) == 0)\r\nreturn &dev->ep[0];\r\nlist_for_each_entry(ep, &dev->gadget.ep_list, ep.ep_list) {\r\nu8 bEndpointAddress;\r\nif (!ep->desc)\r\ncontinue;\r\nbEndpointAddress = ep->desc->bEndpointAddress;\r\nif ((wIndex ^ bEndpointAddress) & USB_DIR_IN)\r\ncontinue;\r\nif ((wIndex & 0x0f) == (bEndpointAddress & 0x0f))\r\nreturn ep;\r\n}\r\nreturn NULL;\r\n}\r\nstatic void defect7374_workaround(struct net2280 *dev, struct usb_ctrlrequest r)\r\n{\r\nu32 scratch, fsmvalue;\r\nu32 ack_wait_timeout, state;\r\nscratch = get_idx_reg(dev->regs, SCRATCH);\r\nfsmvalue = scratch & (0xf << DEFECT7374_FSM_FIELD);\r\nscratch &= ~(0xf << DEFECT7374_FSM_FIELD);\r\nif (!((fsmvalue == DEFECT7374_FSM_WAITING_FOR_CONTROL_READ) &&\r\n(r.bRequestType & USB_DIR_IN)))\r\nreturn;\r\nif (!(readl(&dev->usb->usbstat) & BIT(SUPER_SPEED_MODE))) {\r\nscratch |= DEFECT7374_FSM_NON_SS_CONTROL_READ;\r\ndev->bug7734_patched = 1;\r\ngoto restore_data_eps;\r\n}\r\nfor (ack_wait_timeout = 0;\r\nack_wait_timeout < DEFECT_7374_NUMBEROF_MAX_WAIT_LOOPS;\r\nack_wait_timeout++) {\r\nstate = readl(&dev->plregs->pl_ep_status_1)\r\n& (0xff << STATE);\r\nif ((state >= (ACK_GOOD_NORMAL << STATE)) &&\r\n(state <= (ACK_GOOD_MORE_ACKS_TO_COME << STATE))) {\r\nscratch |= DEFECT7374_FSM_SS_CONTROL_READ;\r\ndev->bug7734_patched = 1;\r\nbreak;\r\n}\r\nudelay(DEFECT_7374_PROCESSOR_WAIT_TIME);\r\ncontinue;\r\n}\r\nif (ack_wait_timeout >= DEFECT_7374_NUMBEROF_MAX_WAIT_LOOPS) {\r\nep_err(dev, "FAIL: Defect 7374 workaround waited but failed "\r\n"to detect SS host's data phase ACK.");\r\nep_err(dev, "PL_EP_STATUS_1(23:16):.Expected from 0x11 to 0x16"\r\n"got 0x%2.2x.\n", state >> STATE);\r\n} else {\r\nep_warn(dev, "INFO: Defect 7374 workaround waited about\n"\r\n"%duSec for Control Read Data Phase ACK\n",\r\nDEFECT_7374_PROCESSOR_WAIT_TIME * ack_wait_timeout);\r\n}\r\nrestore_data_eps:\r\ndefect7374_disable_data_eps(dev);\r\nset_idx_reg(dev->regs, SCRATCH, scratch);\r\nreturn;\r\n}\r\nstatic void ep_clear_seqnum(struct net2280_ep *ep)\r\n{\r\nstruct net2280 *dev = ep->dev;\r\nu32 val;\r\nstatic const u32 ep_pl[9] = { 0, 3, 4, 7, 8, 2, 5, 6, 9 };\r\nval = readl(&dev->plregs->pl_ep_ctrl) & ~0x1f;\r\nval |= ep_pl[ep->num];\r\nwritel(val, &dev->plregs->pl_ep_ctrl);\r\nval |= BIT(SEQUENCE_NUMBER_RESET);\r\nwritel(val, &dev->plregs->pl_ep_ctrl);\r\nreturn;\r\n}\r\nstatic void handle_stat0_irqs_superspeed(struct net2280 *dev,\r\nstruct net2280_ep *ep, struct usb_ctrlrequest r)\r\n{\r\nint tmp = 0;\r\n#define w_value le16_to_cpu(r.wValue)\r\n#define w_index le16_to_cpu(r.wIndex)\r\n#define w_length le16_to_cpu(r.wLength)\r\nswitch (r.bRequest) {\r\nstruct net2280_ep *e;\r\nu16 status;\r\ncase USB_REQ_SET_CONFIGURATION:\r\ndev->addressed_state = !w_value;\r\ngoto usb3_delegate;\r\ncase USB_REQ_GET_STATUS:\r\nswitch (r.bRequestType) {\r\ncase (USB_DIR_IN | USB_TYPE_STANDARD | USB_RECIP_DEVICE):\r\nstatus = dev->wakeup_enable ? 0x02 : 0x00;\r\nif (dev->gadget.is_selfpowered)\r\nstatus |= BIT(0);\r\nstatus |= (dev->u1_enable << 2 | dev->u2_enable << 3 |\r\ndev->ltm_enable << 4);\r\nwritel(0, &dev->epregs[0].ep_irqenb);\r\nset_fifo_bytecount(ep, sizeof(status));\r\nwritel((__force u32) status, &dev->epregs[0].ep_data);\r\nallow_status_338x(ep);\r\nbreak;\r\ncase (USB_DIR_IN | USB_TYPE_STANDARD | USB_RECIP_ENDPOINT):\r\ne = get_ep_by_addr(dev, w_index);\r\nif (!e)\r\ngoto do_stall3;\r\nstatus = readl(&e->regs->ep_rsp) &\r\nBIT(CLEAR_ENDPOINT_HALT);\r\nwritel(0, &dev->epregs[0].ep_irqenb);\r\nset_fifo_bytecount(ep, sizeof(status));\r\nwritel((__force u32) status, &dev->epregs[0].ep_data);\r\nallow_status_338x(ep);\r\nbreak;\r\ndefault:\r\ngoto usb3_delegate;\r\n}\r\nbreak;\r\ncase USB_REQ_CLEAR_FEATURE:\r\nswitch (r.bRequestType) {\r\ncase (USB_DIR_OUT | USB_TYPE_STANDARD | USB_RECIP_DEVICE):\r\nif (!dev->addressed_state) {\r\nswitch (w_value) {\r\ncase USB_DEVICE_U1_ENABLE:\r\ndev->u1_enable = 0;\r\nwritel(readl(&dev->usb_ext->usbctl2) &\r\n~BIT(U1_ENABLE),\r\n&dev->usb_ext->usbctl2);\r\nallow_status_338x(ep);\r\ngoto next_endpoints3;\r\ncase USB_DEVICE_U2_ENABLE:\r\ndev->u2_enable = 0;\r\nwritel(readl(&dev->usb_ext->usbctl2) &\r\n~BIT(U2_ENABLE),\r\n&dev->usb_ext->usbctl2);\r\nallow_status_338x(ep);\r\ngoto next_endpoints3;\r\ncase USB_DEVICE_LTM_ENABLE:\r\ndev->ltm_enable = 0;\r\nwritel(readl(&dev->usb_ext->usbctl2) &\r\n~BIT(LTM_ENABLE),\r\n&dev->usb_ext->usbctl2);\r\nallow_status_338x(ep);\r\ngoto next_endpoints3;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nif (w_value == USB_DEVICE_REMOTE_WAKEUP) {\r\ndev->wakeup_enable = 0;\r\nwritel(readl(&dev->usb->usbctl) &\r\n~BIT(DEVICE_REMOTE_WAKEUP_ENABLE),\r\n&dev->usb->usbctl);\r\nallow_status_338x(ep);\r\nbreak;\r\n}\r\ngoto usb3_delegate;\r\ncase (USB_DIR_OUT | USB_TYPE_STANDARD | USB_RECIP_ENDPOINT):\r\ne = get_ep_by_addr(dev, w_index);\r\nif (!e)\r\ngoto do_stall3;\r\nif (w_value != USB_ENDPOINT_HALT)\r\ngoto do_stall3;\r\nep_vdbg(dev, "%s clear halt\n", e->ep.name);\r\nep_clear_seqnum(e);\r\nclear_halt(e);\r\nif (!list_empty(&e->queue) && e->td_dma)\r\nrestart_dma(e);\r\nallow_status(ep);\r\nep->stopped = 1;\r\nbreak;\r\ndefault:\r\ngoto usb3_delegate;\r\n}\r\nbreak;\r\ncase USB_REQ_SET_FEATURE:\r\nswitch (r.bRequestType) {\r\ncase (USB_DIR_OUT | USB_TYPE_STANDARD | USB_RECIP_DEVICE):\r\nif (!dev->addressed_state) {\r\nswitch (w_value) {\r\ncase USB_DEVICE_U1_ENABLE:\r\ndev->u1_enable = 1;\r\nwritel(readl(&dev->usb_ext->usbctl2) |\r\nBIT(U1_ENABLE),\r\n&dev->usb_ext->usbctl2);\r\nallow_status_338x(ep);\r\ngoto next_endpoints3;\r\ncase USB_DEVICE_U2_ENABLE:\r\ndev->u2_enable = 1;\r\nwritel(readl(&dev->usb_ext->usbctl2) |\r\nBIT(U2_ENABLE),\r\n&dev->usb_ext->usbctl2);\r\nallow_status_338x(ep);\r\ngoto next_endpoints3;\r\ncase USB_DEVICE_LTM_ENABLE:\r\ndev->ltm_enable = 1;\r\nwritel(readl(&dev->usb_ext->usbctl2) |\r\nBIT(LTM_ENABLE),\r\n&dev->usb_ext->usbctl2);\r\nallow_status_338x(ep);\r\ngoto next_endpoints3;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nif (w_value == USB_DEVICE_REMOTE_WAKEUP) {\r\ndev->wakeup_enable = 1;\r\nwritel(readl(&dev->usb->usbctl) |\r\nBIT(DEVICE_REMOTE_WAKEUP_ENABLE),\r\n&dev->usb->usbctl);\r\nallow_status_338x(ep);\r\nbreak;\r\n}\r\ngoto usb3_delegate;\r\ncase (USB_DIR_OUT | USB_TYPE_STANDARD | USB_RECIP_ENDPOINT):\r\ne = get_ep_by_addr(dev, w_index);\r\nif (!e || (w_value != USB_ENDPOINT_HALT))\r\ngoto do_stall3;\r\nep->stopped = 1;\r\nif (ep->num == 0)\r\nep->dev->protocol_stall = 1;\r\nelse {\r\nif (ep->dma)\r\nabort_dma(ep);\r\nset_halt(ep);\r\n}\r\nallow_status_338x(ep);\r\nbreak;\r\ndefault:\r\ngoto usb3_delegate;\r\n}\r\nbreak;\r\ndefault:\r\nusb3_delegate:\r\nep_vdbg(dev, "setup %02x.%02x v%04x i%04x l%04x ep_cfg %08x\n",\r\nr.bRequestType, r.bRequest,\r\nw_value, w_index, w_length,\r\nreadl(&ep->cfg->ep_cfg));\r\nep->responded = 0;\r\nspin_unlock(&dev->lock);\r\ntmp = dev->driver->setup(&dev->gadget, &r);\r\nspin_lock(&dev->lock);\r\n}\r\ndo_stall3:\r\nif (tmp < 0) {\r\nep_vdbg(dev, "req %02x.%02x protocol STALL; stat %d\n",\r\nr.bRequestType, r.bRequest, tmp);\r\ndev->protocol_stall = 1;\r\nset_halt(ep);\r\n}\r\nnext_endpoints3:\r\n#undef w_value\r\n#undef w_index\r\n#undef w_length\r\nreturn;\r\n}\r\nstatic void usb338x_handle_ep_intr(struct net2280 *dev, u32 stat0)\r\n{\r\nu32 index;\r\nu32 bit;\r\nfor (index = 0; index < ARRAY_SIZE(ep_bit); index++) {\r\nbit = BIT(ep_bit[index]);\r\nif (!stat0)\r\nbreak;\r\nif (!(stat0 & bit))\r\ncontinue;\r\nstat0 &= ~bit;\r\nhandle_ep_small(&dev->ep[index]);\r\n}\r\n}\r\nstatic void handle_stat0_irqs(struct net2280 *dev, u32 stat)\r\n{\r\nstruct net2280_ep *ep;\r\nu32 num, scratch;\r\nstat &= ~BIT(INTA_ASSERTED);\r\nif (!stat)\r\nreturn;\r\nif (unlikely(stat & BIT(SETUP_PACKET_INTERRUPT))) {\r\nunion {\r\nu32 raw[2];\r\nstruct usb_ctrlrequest r;\r\n} u;\r\nint tmp;\r\nstruct net2280_request *req;\r\nif (dev->gadget.speed == USB_SPEED_UNKNOWN) {\r\nu32 val = readl(&dev->usb->usbstat);\r\nif (val & BIT(SUPER_SPEED)) {\r\ndev->gadget.speed = USB_SPEED_SUPER;\r\nusb_ep_set_maxpacket_limit(&dev->ep[0].ep,\r\nEP0_SS_MAX_PACKET_SIZE);\r\n} else if (val & BIT(HIGH_SPEED)) {\r\ndev->gadget.speed = USB_SPEED_HIGH;\r\nusb_ep_set_maxpacket_limit(&dev->ep[0].ep,\r\nEP0_HS_MAX_PACKET_SIZE);\r\n} else {\r\ndev->gadget.speed = USB_SPEED_FULL;\r\nusb_ep_set_maxpacket_limit(&dev->ep[0].ep,\r\nEP0_HS_MAX_PACKET_SIZE);\r\n}\r\nnet2280_led_speed(dev, dev->gadget.speed);\r\nep_dbg(dev, "%s\n",\r\nusb_speed_string(dev->gadget.speed));\r\n}\r\nep = &dev->ep[0];\r\nep->irqs++;\r\nstat &= ~BIT(ENDPOINT_0_INTERRUPT);\r\nwhile (!list_empty(&ep->queue)) {\r\nreq = list_entry(ep->queue.next,\r\nstruct net2280_request, queue);\r\ndone(ep, req, (req->req.actual == req->req.length)\r\n? 0 : -EPROTO);\r\n}\r\nep->stopped = 0;\r\ndev->protocol_stall = 0;\r\nif (!(dev->quirks & PLX_SUPERSPEED)) {\r\nif (ep->dev->quirks & PLX_2280)\r\ntmp = BIT(FIFO_OVERFLOW) |\r\nBIT(FIFO_UNDERFLOW);\r\nelse\r\ntmp = 0;\r\nwritel(tmp | BIT(TIMEOUT) |\r\nBIT(USB_STALL_SENT) |\r\nBIT(USB_IN_NAK_SENT) |\r\nBIT(USB_IN_ACK_RCVD) |\r\nBIT(USB_OUT_PING_NAK_SENT) |\r\nBIT(USB_OUT_ACK_SENT) |\r\nBIT(SHORT_PACKET_OUT_DONE_INTERRUPT) |\r\nBIT(SHORT_PACKET_TRANSFERRED_INTERRUPT) |\r\nBIT(DATA_PACKET_RECEIVED_INTERRUPT) |\r\nBIT(DATA_PACKET_TRANSMITTED_INTERRUPT) |\r\nBIT(DATA_OUT_PING_TOKEN_INTERRUPT) |\r\nBIT(DATA_IN_TOKEN_INTERRUPT),\r\n&ep->regs->ep_stat);\r\n}\r\nu.raw[0] = readl(&dev->usb->setup0123);\r\nu.raw[1] = readl(&dev->usb->setup4567);\r\ncpu_to_le32s(&u.raw[0]);\r\ncpu_to_le32s(&u.raw[1]);\r\nif ((dev->quirks & PLX_SUPERSPEED) && !dev->bug7734_patched)\r\ndefect7374_workaround(dev, u.r);\r\ntmp = 0;\r\n#define w_value le16_to_cpu(u.r.wValue)\r\n#define w_index le16_to_cpu(u.r.wIndex)\r\n#define w_length le16_to_cpu(u.r.wLength)\r\nwritel(BIT(SETUP_PACKET_INTERRUPT), &dev->regs->irqstat0);\r\nstat ^= BIT(SETUP_PACKET_INTERRUPT);\r\nep->is_in = (u.r.bRequestType & USB_DIR_IN) != 0;\r\nif (ep->is_in) {\r\nscratch = BIT(DATA_PACKET_TRANSMITTED_INTERRUPT) |\r\nBIT(DATA_OUT_PING_TOKEN_INTERRUPT) |\r\nBIT(DATA_IN_TOKEN_INTERRUPT);\r\nstop_out_naking(ep);\r\n} else\r\nscratch = BIT(DATA_PACKET_RECEIVED_INTERRUPT) |\r\nBIT(DATA_OUT_PING_TOKEN_INTERRUPT) |\r\nBIT(DATA_IN_TOKEN_INTERRUPT);\r\nwritel(scratch, &dev->epregs[0].ep_irqenb);\r\nep->responded = 1;\r\nif (dev->gadget.speed == USB_SPEED_SUPER) {\r\nhandle_stat0_irqs_superspeed(dev, ep, u.r);\r\ngoto next_endpoints;\r\n}\r\nswitch (u.r.bRequest) {\r\ncase USB_REQ_GET_STATUS: {\r\nstruct net2280_ep *e;\r\n__le32 status;\r\nif (u.r.bRequestType != (USB_DIR_IN|USB_RECIP_ENDPOINT))\r\ngoto delegate;\r\ne = get_ep_by_addr(dev, w_index);\r\nif (!e || w_length > 2)\r\ngoto do_stall;\r\nif (readl(&e->regs->ep_rsp) & BIT(SET_ENDPOINT_HALT))\r\nstatus = cpu_to_le32(1);\r\nelse\r\nstatus = cpu_to_le32(0);\r\nwritel(0, &dev->epregs[0].ep_irqenb);\r\nset_fifo_bytecount(ep, w_length);\r\nwritel((__force u32)status, &dev->epregs[0].ep_data);\r\nallow_status(ep);\r\nep_vdbg(dev, "%s stat %02x\n", ep->ep.name, status);\r\ngoto next_endpoints;\r\n}\r\nbreak;\r\ncase USB_REQ_CLEAR_FEATURE: {\r\nstruct net2280_ep *e;\r\nif (u.r.bRequestType != USB_RECIP_ENDPOINT)\r\ngoto delegate;\r\nif (w_value != USB_ENDPOINT_HALT || w_length != 0)\r\ngoto do_stall;\r\ne = get_ep_by_addr(dev, w_index);\r\nif (!e)\r\ngoto do_stall;\r\nif (e->wedged) {\r\nep_vdbg(dev, "%s wedged, halt not cleared\n",\r\nep->ep.name);\r\n} else {\r\nep_vdbg(dev, "%s clear halt\n", e->ep.name);\r\nclear_halt(e);\r\nif ((ep->dev->quirks & PLX_SUPERSPEED) &&\r\n!list_empty(&e->queue) && e->td_dma)\r\nrestart_dma(e);\r\n}\r\nallow_status(ep);\r\ngoto next_endpoints;\r\n}\r\nbreak;\r\ncase USB_REQ_SET_FEATURE: {\r\nstruct net2280_ep *e;\r\nif (u.r.bRequestType != USB_RECIP_ENDPOINT)\r\ngoto delegate;\r\nif (w_value != USB_ENDPOINT_HALT || w_length != 0)\r\ngoto do_stall;\r\ne = get_ep_by_addr(dev, w_index);\r\nif (!e)\r\ngoto do_stall;\r\nif (e->ep.name == ep0name)\r\ngoto do_stall;\r\nset_halt(e);\r\nif ((dev->quirks & PLX_SUPERSPEED) && e->dma)\r\nabort_dma(e);\r\nallow_status(ep);\r\nep_vdbg(dev, "%s set halt\n", ep->ep.name);\r\ngoto next_endpoints;\r\n}\r\nbreak;\r\ndefault:\r\ndelegate:\r\nep_vdbg(dev, "setup %02x.%02x v%04x i%04x l%04x "\r\n"ep_cfg %08x\n",\r\nu.r.bRequestType, u.r.bRequest,\r\nw_value, w_index, w_length,\r\nreadl(&ep->cfg->ep_cfg));\r\nep->responded = 0;\r\nspin_unlock(&dev->lock);\r\ntmp = dev->driver->setup(&dev->gadget, &u.r);\r\nspin_lock(&dev->lock);\r\n}\r\nif (tmp < 0) {\r\ndo_stall:\r\nep_vdbg(dev, "req %02x.%02x protocol STALL; stat %d\n",\r\nu.r.bRequestType, u.r.bRequest, tmp);\r\ndev->protocol_stall = 1;\r\n}\r\n}\r\n#undef w_value\r\n#undef w_index\r\n#undef w_length\r\nnext_endpoints:\r\nif ((dev->quirks & PLX_SUPERSPEED) && dev->enhanced_mode) {\r\nu32 mask = (BIT(ENDPOINT_0_INTERRUPT) |\r\nUSB3380_IRQSTAT0_EP_INTR_MASK_IN |\r\nUSB3380_IRQSTAT0_EP_INTR_MASK_OUT);\r\nif (stat & mask) {\r\nusb338x_handle_ep_intr(dev, stat & mask);\r\nstat &= ~mask;\r\n}\r\n} else {\r\nscratch = stat & 0x7f;\r\nstat &= ~0x7f;\r\nfor (num = 0; scratch; num++) {\r\nu32 t;\r\nt = BIT(num);\r\nif ((scratch & t) == 0)\r\ncontinue;\r\nscratch ^= t;\r\nep = &dev->ep[num];\r\nhandle_ep_small(ep);\r\n}\r\n}\r\nif (stat)\r\nep_dbg(dev, "unhandled irqstat0 %08x\n", stat);\r\n}\r\nstatic void handle_stat1_irqs(struct net2280 *dev, u32 stat)\r\n__releases(dev->lock)\r\n__acquires(dev->lock)\r\n{\r\nstruct net2280_ep *ep;\r\nu32 tmp, num, mask, scratch;\r\ntmp = BIT(VBUS_INTERRUPT) | BIT(ROOT_PORT_RESET_INTERRUPT);\r\nmask = BIT(SUPER_SPEED) | BIT(HIGH_SPEED) | BIT(FULL_SPEED);\r\nif (stat & tmp) {\r\nbool reset = false;\r\nbool disconnect = false;\r\nwritel(tmp, &dev->regs->irqstat1);\r\nif (dev->gadget.speed != USB_SPEED_UNKNOWN) {\r\nif ((stat & BIT(VBUS_INTERRUPT)) &&\r\n(readl(&dev->usb->usbctl) &\r\nBIT(VBUS_PIN)) == 0) {\r\ndisconnect = true;\r\nep_dbg(dev, "disconnect %s\n",\r\ndev->driver->driver.name);\r\n} else if ((stat & BIT(ROOT_PORT_RESET_INTERRUPT)) &&\r\n(readl(&dev->usb->usbstat) & mask)\r\n== 0) {\r\nreset = true;\r\nep_dbg(dev, "reset %s\n",\r\ndev->driver->driver.name);\r\n}\r\nif (disconnect || reset) {\r\nstop_activity(dev, dev->driver);\r\nep0_start(dev);\r\nspin_unlock(&dev->lock);\r\nif (reset)\r\nusb_gadget_udc_reset\r\n(&dev->gadget, dev->driver);\r\nelse\r\n(dev->driver->disconnect)\r\n(&dev->gadget);\r\nspin_lock(&dev->lock);\r\nreturn;\r\n}\r\n}\r\nstat &= ~tmp;\r\nif (!stat)\r\nreturn;\r\n}\r\ntmp = BIT(SUSPEND_REQUEST_CHANGE_INTERRUPT);\r\nif (stat & tmp) {\r\nwritel(tmp, &dev->regs->irqstat1);\r\nif (stat & BIT(SUSPEND_REQUEST_INTERRUPT)) {\r\nif (dev->driver->suspend)\r\ndev->driver->suspend(&dev->gadget);\r\nif (!enable_suspend)\r\nstat &= ~BIT(SUSPEND_REQUEST_INTERRUPT);\r\n} else {\r\nif (dev->driver->resume)\r\ndev->driver->resume(&dev->gadget);\r\n}\r\nstat &= ~tmp;\r\n}\r\nif (stat)\r\nwritel(stat, &dev->regs->irqstat1);\r\nif (dev->quirks & PLX_2280)\r\nstat &= ~(BIT(CONTROL_STATUS_INTERRUPT) |\r\nBIT(SUSPEND_REQUEST_INTERRUPT) |\r\nBIT(RESUME_INTERRUPT) |\r\nBIT(SOF_INTERRUPT));\r\nelse\r\nstat &= ~(BIT(CONTROL_STATUS_INTERRUPT) |\r\nBIT(RESUME_INTERRUPT) |\r\nBIT(SOF_DOWN_INTERRUPT) |\r\nBIT(SOF_INTERRUPT));\r\nif (!stat)\r\nreturn;\r\nscratch = stat & DMA_INTERRUPTS;\r\nstat &= ~DMA_INTERRUPTS;\r\nscratch >>= 9;\r\nfor (num = 0; scratch; num++) {\r\nstruct net2280_dma_regs __iomem *dma;\r\ntmp = BIT(num);\r\nif ((tmp & scratch) == 0)\r\ncontinue;\r\nscratch ^= tmp;\r\nep = &dev->ep[num + 1];\r\ndma = ep->dma;\r\nif (!dma)\r\ncontinue;\r\ntmp = readl(&dma->dmastat);\r\nwritel(tmp, &dma->dmastat);\r\nif (dev->quirks & PLX_SUPERSPEED) {\r\nu32 r_dmacount = readl(&dma->dmacount);\r\nif (!ep->is_in && (r_dmacount & 0x00FFFFFF) &&\r\n(tmp & BIT(DMA_TRANSACTION_DONE_INTERRUPT)))\r\ncontinue;\r\n}\r\nif (!(tmp & BIT(DMA_TRANSACTION_DONE_INTERRUPT))) {\r\nep_dbg(ep->dev, "%s no xact done? %08x\n",\r\nep->ep.name, tmp);\r\ncontinue;\r\n}\r\nstop_dma(ep->dma);\r\nscan_dma_completions(ep);\r\nif (!list_empty(&ep->queue)) {\r\ntmp = readl(&dma->dmactl);\r\nrestart_dma(ep);\r\n}\r\nep->irqs++;\r\n}\r\nif (stat & PCI_ERROR_INTERRUPTS) {\r\nep_err(dev, "pci dma error; stat %08x\n", stat);\r\nstat &= ~PCI_ERROR_INTERRUPTS;\r\nstop_activity(dev, dev->driver);\r\nep0_start(dev);\r\nstat = 0;\r\n}\r\nif (stat)\r\nep_dbg(dev, "unhandled irqstat1 %08x\n", stat);\r\n}\r\nstatic irqreturn_t net2280_irq(int irq, void *_dev)\r\n{\r\nstruct net2280 *dev = _dev;\r\nif ((dev->quirks & PLX_LEGACY) &&\r\n(!(readl(&dev->regs->irqstat0) & BIT(INTA_ASSERTED))))\r\nreturn IRQ_NONE;\r\nspin_lock(&dev->lock);\r\nhandle_stat1_irqs(dev, readl(&dev->regs->irqstat1));\r\nhandle_stat0_irqs(dev, readl(&dev->regs->irqstat0));\r\nif (dev->quirks & PLX_SUPERSPEED) {\r\nu32 pciirqenb1 = readl(&dev->regs->pciirqenb1);\r\nwritel(pciirqenb1 & 0x7FFFFFFF, &dev->regs->pciirqenb1);\r\nwritel(pciirqenb1, &dev->regs->pciirqenb1);\r\n}\r\nspin_unlock(&dev->lock);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void gadget_release(struct device *_dev)\r\n{\r\nstruct net2280 *dev = dev_get_drvdata(_dev);\r\nkfree(dev);\r\n}\r\nstatic void net2280_remove(struct pci_dev *pdev)\r\n{\r\nstruct net2280 *dev = pci_get_drvdata(pdev);\r\nusb_del_gadget_udc(&dev->gadget);\r\nBUG_ON(dev->driver);\r\nnet2280_led_shutdown(dev);\r\nif (dev->requests) {\r\nint i;\r\nfor (i = 1; i < 5; i++) {\r\nif (!dev->ep[i].dummy)\r\ncontinue;\r\npci_pool_free(dev->requests, dev->ep[i].dummy,\r\ndev->ep[i].td_dma);\r\n}\r\npci_pool_destroy(dev->requests);\r\n}\r\nif (dev->got_irq)\r\nfree_irq(pdev->irq, dev);\r\nif (dev->quirks & PLX_SUPERSPEED)\r\npci_disable_msi(pdev);\r\nif (dev->regs)\r\niounmap(dev->regs);\r\nif (dev->region)\r\nrelease_mem_region(pci_resource_start(pdev, 0),\r\npci_resource_len(pdev, 0));\r\nif (dev->enabled)\r\npci_disable_device(pdev);\r\ndevice_remove_file(&pdev->dev, &dev_attr_registers);\r\nep_info(dev, "unbind\n");\r\n}\r\nstatic int net2280_probe(struct pci_dev *pdev, const struct pci_device_id *id)\r\n{\r\nstruct net2280 *dev;\r\nunsigned long resource, len;\r\nvoid __iomem *base = NULL;\r\nint retval, i;\r\ndev = kzalloc(sizeof(*dev), GFP_KERNEL);\r\nif (dev == NULL) {\r\nretval = -ENOMEM;\r\ngoto done;\r\n}\r\npci_set_drvdata(pdev, dev);\r\nspin_lock_init(&dev->lock);\r\ndev->quirks = id->driver_data;\r\ndev->pdev = pdev;\r\ndev->gadget.ops = &net2280_ops;\r\ndev->gadget.max_speed = (dev->quirks & PLX_SUPERSPEED) ?\r\nUSB_SPEED_SUPER : USB_SPEED_HIGH;\r\ndev->gadget.name = driver_name;\r\nif (pci_enable_device(pdev) < 0) {\r\nretval = -ENODEV;\r\ngoto done;\r\n}\r\ndev->enabled = 1;\r\nresource = pci_resource_start(pdev, 0);\r\nlen = pci_resource_len(pdev, 0);\r\nif (!request_mem_region(resource, len, driver_name)) {\r\nep_dbg(dev, "controller already in use\n");\r\nretval = -EBUSY;\r\ngoto done;\r\n}\r\ndev->region = 1;\r\nbase = ioremap_nocache(resource, len);\r\nif (base == NULL) {\r\nep_dbg(dev, "can't map memory\n");\r\nretval = -EFAULT;\r\ngoto done;\r\n}\r\ndev->regs = (struct net2280_regs __iomem *) base;\r\ndev->usb = (struct net2280_usb_regs __iomem *) (base + 0x0080);\r\ndev->pci = (struct net2280_pci_regs __iomem *) (base + 0x0100);\r\ndev->dma = (struct net2280_dma_regs __iomem *) (base + 0x0180);\r\ndev->dep = (struct net2280_dep_regs __iomem *) (base + 0x0200);\r\ndev->epregs = (struct net2280_ep_regs __iomem *) (base + 0x0300);\r\nif (dev->quirks & PLX_SUPERSPEED) {\r\nu32 fsmvalue;\r\nu32 usbstat;\r\ndev->usb_ext = (struct usb338x_usb_ext_regs __iomem *)\r\n(base + 0x00b4);\r\ndev->llregs = (struct usb338x_ll_regs __iomem *)\r\n(base + 0x0700);\r\ndev->ll_lfps_regs = (struct usb338x_ll_lfps_regs __iomem *)\r\n(base + 0x0748);\r\ndev->ll_tsn_regs = (struct usb338x_ll_tsn_regs __iomem *)\r\n(base + 0x077c);\r\ndev->ll_chicken_reg = (struct usb338x_ll_chi_regs __iomem *)\r\n(base + 0x079c);\r\ndev->plregs = (struct usb338x_pl_regs __iomem *)\r\n(base + 0x0800);\r\nusbstat = readl(&dev->usb->usbstat);\r\ndev->enhanced_mode = !!(usbstat & BIT(11));\r\ndev->n_ep = (dev->enhanced_mode) ? 9 : 5;\r\nfsmvalue = get_idx_reg(dev->regs, SCRATCH) &\r\n(0xf << DEFECT7374_FSM_FIELD);\r\nif (fsmvalue == DEFECT7374_FSM_SS_CONTROL_READ) {\r\ndev->bug7734_patched = 1;\r\nwritel(0, &dev->usb->usbctl);\r\n} else\r\ndev->bug7734_patched = 0;\r\n} else {\r\ndev->enhanced_mode = 0;\r\ndev->n_ep = 7;\r\nwritel(0, &dev->usb->usbctl);\r\n}\r\nusb_reset(dev);\r\nusb_reinit(dev);\r\nif (!pdev->irq) {\r\nep_err(dev, "No IRQ. Check PCI setup!\n");\r\nretval = -ENODEV;\r\ngoto done;\r\n}\r\nif (dev->quirks & PLX_SUPERSPEED)\r\nif (pci_enable_msi(pdev))\r\nep_err(dev, "Failed to enable MSI mode\n");\r\nif (request_irq(pdev->irq, net2280_irq, IRQF_SHARED,\r\ndriver_name, dev)) {\r\nep_err(dev, "request interrupt %d failed\n", pdev->irq);\r\nretval = -EBUSY;\r\ngoto done;\r\n}\r\ndev->got_irq = 1;\r\ndev->requests = pci_pool_create("requests", pdev,\r\nsizeof(struct net2280_dma),\r\n0 ,\r\n0 );\r\nif (!dev->requests) {\r\nep_dbg(dev, "can't get request pool\n");\r\nretval = -ENOMEM;\r\ngoto done;\r\n}\r\nfor (i = 1; i < 5; i++) {\r\nstruct net2280_dma *td;\r\ntd = pci_pool_alloc(dev->requests, GFP_KERNEL,\r\n&dev->ep[i].td_dma);\r\nif (!td) {\r\nep_dbg(dev, "can't get dummy %d\n", i);\r\nretval = -ENOMEM;\r\ngoto done;\r\n}\r\ntd->dmacount = 0;\r\ntd->dmadesc = td->dmaaddr;\r\ndev->ep[i].dummy = td;\r\n}\r\nif (dev->quirks & PLX_LEGACY)\r\nwritel(BIT(DMA_MEMORY_WRITE_AND_INVALIDATE_ENABLE) |\r\nBIT(DMA_READ_MULTIPLE_ENABLE) |\r\nBIT(DMA_READ_LINE_ENABLE),\r\n&dev->pci->pcimstctl);\r\npci_set_master(pdev);\r\npci_try_set_mwi(pdev);\r\ndev->chiprev = get_idx_reg(dev->regs, REG_CHIPREV) & 0xffff;\r\nep_info(dev, "%s\n", driver_desc);\r\nep_info(dev, "irq %d, pci mem %p, chip rev %04x\n",\r\npdev->irq, base, dev->chiprev);\r\nep_info(dev, "version: " DRIVER_VERSION "; %s\n",\r\ndev->enhanced_mode ? "enhanced mode" : "legacy mode");\r\nretval = device_create_file(&pdev->dev, &dev_attr_registers);\r\nif (retval)\r\ngoto done;\r\nretval = usb_add_gadget_udc_release(&pdev->dev, &dev->gadget,\r\ngadget_release);\r\nif (retval)\r\ngoto done;\r\nreturn 0;\r\ndone:\r\nif (dev)\r\nnet2280_remove(pdev);\r\nreturn retval;\r\n}\r\nstatic void net2280_shutdown(struct pci_dev *pdev)\r\n{\r\nstruct net2280 *dev = pci_get_drvdata(pdev);\r\nwritel(0, &dev->regs->pciirqenb0);\r\nwritel(0, &dev->regs->pciirqenb1);\r\nwritel(0, &dev->usb->usbctl);\r\n}
