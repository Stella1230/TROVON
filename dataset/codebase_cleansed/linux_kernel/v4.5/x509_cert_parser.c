void x509_free_certificate(struct x509_certificate *cert)\r\n{\r\nif (cert) {\r\npublic_key_destroy(cert->pub);\r\nkfree(cert->issuer);\r\nkfree(cert->subject);\r\nkfree(cert->id);\r\nkfree(cert->skid);\r\nkfree(cert->akid_id);\r\nkfree(cert->akid_skid);\r\nkfree(cert->sig.digest);\r\nmpi_free(cert->sig.rsa.s);\r\nkfree(cert);\r\n}\r\n}\r\nstruct x509_certificate *x509_cert_parse(const void *data, size_t datalen)\r\n{\r\nstruct x509_certificate *cert;\r\nstruct x509_parse_context *ctx;\r\nstruct asymmetric_key_id *kid;\r\nlong ret;\r\nret = -ENOMEM;\r\ncert = kzalloc(sizeof(struct x509_certificate), GFP_KERNEL);\r\nif (!cert)\r\ngoto error_no_cert;\r\ncert->pub = kzalloc(sizeof(struct public_key), GFP_KERNEL);\r\nif (!cert->pub)\r\ngoto error_no_ctx;\r\nctx = kzalloc(sizeof(struct x509_parse_context), GFP_KERNEL);\r\nif (!ctx)\r\ngoto error_no_ctx;\r\nctx->cert = cert;\r\nctx->data = (unsigned long)data;\r\nret = asn1_ber_decoder(&x509_decoder, ctx, data, datalen);\r\nif (ret < 0)\r\ngoto error_decode;\r\nif (ctx->raw_akid) {\r\npr_devel("AKID: %u %*phN\n",\r\nctx->raw_akid_size, ctx->raw_akid_size, ctx->raw_akid);\r\nret = asn1_ber_decoder(&x509_akid_decoder, ctx,\r\nctx->raw_akid, ctx->raw_akid_size);\r\nif (ret < 0) {\r\npr_warn("Couldn't decode AuthKeyIdentifier\n");\r\ngoto error_decode;\r\n}\r\n}\r\nret = asn1_ber_decoder(&x509_rsakey_decoder, ctx,\r\nctx->key, ctx->key_size);\r\nif (ret < 0)\r\ngoto error_decode;\r\nkid = asymmetric_key_generate_id(cert->raw_serial,\r\ncert->raw_serial_size,\r\ncert->raw_issuer,\r\ncert->raw_issuer_size);\r\nif (IS_ERR(kid)) {\r\nret = PTR_ERR(kid);\r\ngoto error_decode;\r\n}\r\ncert->id = kid;\r\nkfree(ctx);\r\nreturn cert;\r\nerror_decode:\r\nkfree(ctx);\r\nerror_no_ctx:\r\nx509_free_certificate(cert);\r\nerror_no_cert:\r\nreturn ERR_PTR(ret);\r\n}\r\nint x509_note_OID(void *context, size_t hdrlen,\r\nunsigned char tag,\r\nconst void *value, size_t vlen)\r\n{\r\nstruct x509_parse_context *ctx = context;\r\nctx->last_oid = look_up_OID(value, vlen);\r\nif (ctx->last_oid == OID__NR) {\r\nchar buffer[50];\r\nsprint_oid(value, vlen, buffer, sizeof(buffer));\r\npr_debug("Unknown OID: [%lu] %s\n",\r\n(unsigned long)value - ctx->data, buffer);\r\n}\r\nreturn 0;\r\n}\r\nint x509_note_tbs_certificate(void *context, size_t hdrlen,\r\nunsigned char tag,\r\nconst void *value, size_t vlen)\r\n{\r\nstruct x509_parse_context *ctx = context;\r\npr_debug("x509_note_tbs_certificate(,%zu,%02x,%ld,%zu)!\n",\r\nhdrlen, tag, (unsigned long)value - ctx->data, vlen);\r\nctx->cert->tbs = value - hdrlen;\r\nctx->cert->tbs_size = vlen + hdrlen;\r\nreturn 0;\r\n}\r\nint x509_note_pkey_algo(void *context, size_t hdrlen,\r\nunsigned char tag,\r\nconst void *value, size_t vlen)\r\n{\r\nstruct x509_parse_context *ctx = context;\r\npr_debug("PubKey Algo: %u\n", ctx->last_oid);\r\nswitch (ctx->last_oid) {\r\ncase OID_md2WithRSAEncryption:\r\ncase OID_md3WithRSAEncryption:\r\ndefault:\r\nreturn -ENOPKG;\r\ncase OID_md4WithRSAEncryption:\r\nctx->cert->sig.pkey_hash_algo = HASH_ALGO_MD5;\r\nctx->cert->sig.pkey_algo = PKEY_ALGO_RSA;\r\nbreak;\r\ncase OID_sha1WithRSAEncryption:\r\nctx->cert->sig.pkey_hash_algo = HASH_ALGO_SHA1;\r\nctx->cert->sig.pkey_algo = PKEY_ALGO_RSA;\r\nbreak;\r\ncase OID_sha256WithRSAEncryption:\r\nctx->cert->sig.pkey_hash_algo = HASH_ALGO_SHA256;\r\nctx->cert->sig.pkey_algo = PKEY_ALGO_RSA;\r\nbreak;\r\ncase OID_sha384WithRSAEncryption:\r\nctx->cert->sig.pkey_hash_algo = HASH_ALGO_SHA384;\r\nctx->cert->sig.pkey_algo = PKEY_ALGO_RSA;\r\nbreak;\r\ncase OID_sha512WithRSAEncryption:\r\nctx->cert->sig.pkey_hash_algo = HASH_ALGO_SHA512;\r\nctx->cert->sig.pkey_algo = PKEY_ALGO_RSA;\r\nbreak;\r\ncase OID_sha224WithRSAEncryption:\r\nctx->cert->sig.pkey_hash_algo = HASH_ALGO_SHA224;\r\nctx->cert->sig.pkey_algo = PKEY_ALGO_RSA;\r\nbreak;\r\n}\r\nctx->algo_oid = ctx->last_oid;\r\nreturn 0;\r\n}\r\nint x509_note_signature(void *context, size_t hdrlen,\r\nunsigned char tag,\r\nconst void *value, size_t vlen)\r\n{\r\nstruct x509_parse_context *ctx = context;\r\npr_debug("Signature type: %u size %zu\n", ctx->last_oid, vlen);\r\nif (ctx->last_oid != ctx->algo_oid) {\r\npr_warn("Got cert with pkey (%u) and sig (%u) algorithm OIDs\n",\r\nctx->algo_oid, ctx->last_oid);\r\nreturn -EINVAL;\r\n}\r\nctx->cert->raw_sig = value;\r\nctx->cert->raw_sig_size = vlen;\r\nreturn 0;\r\n}\r\nint x509_note_serial(void *context, size_t hdrlen,\r\nunsigned char tag,\r\nconst void *value, size_t vlen)\r\n{\r\nstruct x509_parse_context *ctx = context;\r\nctx->cert->raw_serial = value;\r\nctx->cert->raw_serial_size = vlen;\r\nreturn 0;\r\n}\r\nint x509_extract_name_segment(void *context, size_t hdrlen,\r\nunsigned char tag,\r\nconst void *value, size_t vlen)\r\n{\r\nstruct x509_parse_context *ctx = context;\r\nswitch (ctx->last_oid) {\r\ncase OID_commonName:\r\nctx->cn_size = vlen;\r\nctx->cn_offset = (unsigned long)value - ctx->data;\r\nbreak;\r\ncase OID_organizationName:\r\nctx->o_size = vlen;\r\nctx->o_offset = (unsigned long)value - ctx->data;\r\nbreak;\r\ncase OID_email_address:\r\nctx->email_size = vlen;\r\nctx->email_offset = (unsigned long)value - ctx->data;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic int x509_fabricate_name(struct x509_parse_context *ctx, size_t hdrlen,\r\nunsigned char tag,\r\nchar **_name, size_t vlen)\r\n{\r\nconst void *name, *data = (const void *)ctx->data;\r\nsize_t namesize;\r\nchar *buffer;\r\nif (*_name)\r\nreturn -EINVAL;\r\nif (!ctx->cn_size && !ctx->o_size && !ctx->email_size) {\r\nbuffer = kmalloc(1, GFP_KERNEL);\r\nif (!buffer)\r\nreturn -ENOMEM;\r\nbuffer[0] = 0;\r\ngoto done;\r\n}\r\nif (ctx->cn_size && ctx->o_size) {\r\nnamesize = ctx->cn_size;\r\nname = data + ctx->cn_offset;\r\nif (ctx->cn_size >= ctx->o_size &&\r\nmemcmp(data + ctx->cn_offset, data + ctx->o_offset,\r\nctx->o_size) == 0)\r\ngoto single_component;\r\nif (ctx->cn_size >= 7 &&\r\nctx->o_size >= 7 &&\r\nmemcmp(data + ctx->cn_offset, data + ctx->o_offset, 7) == 0)\r\ngoto single_component;\r\nbuffer = kmalloc(ctx->o_size + 2 + ctx->cn_size + 1,\r\nGFP_KERNEL);\r\nif (!buffer)\r\nreturn -ENOMEM;\r\nmemcpy(buffer,\r\ndata + ctx->o_offset, ctx->o_size);\r\nbuffer[ctx->o_size + 0] = ':';\r\nbuffer[ctx->o_size + 1] = ' ';\r\nmemcpy(buffer + ctx->o_size + 2,\r\ndata + ctx->cn_offset, ctx->cn_size);\r\nbuffer[ctx->o_size + 2 + ctx->cn_size] = 0;\r\ngoto done;\r\n} else if (ctx->cn_size) {\r\nnamesize = ctx->cn_size;\r\nname = data + ctx->cn_offset;\r\n} else if (ctx->o_size) {\r\nnamesize = ctx->o_size;\r\nname = data + ctx->o_offset;\r\n} else {\r\nnamesize = ctx->email_size;\r\nname = data + ctx->email_offset;\r\n}\r\nsingle_component:\r\nbuffer = kmalloc(namesize + 1, GFP_KERNEL);\r\nif (!buffer)\r\nreturn -ENOMEM;\r\nmemcpy(buffer, name, namesize);\r\nbuffer[namesize] = 0;\r\ndone:\r\n*_name = buffer;\r\nctx->cn_size = 0;\r\nctx->o_size = 0;\r\nctx->email_size = 0;\r\nreturn 0;\r\n}\r\nint x509_note_issuer(void *context, size_t hdrlen,\r\nunsigned char tag,\r\nconst void *value, size_t vlen)\r\n{\r\nstruct x509_parse_context *ctx = context;\r\nctx->cert->raw_issuer = value;\r\nctx->cert->raw_issuer_size = vlen;\r\nreturn x509_fabricate_name(ctx, hdrlen, tag, &ctx->cert->issuer, vlen);\r\n}\r\nint x509_note_subject(void *context, size_t hdrlen,\r\nunsigned char tag,\r\nconst void *value, size_t vlen)\r\n{\r\nstruct x509_parse_context *ctx = context;\r\nctx->cert->raw_subject = value;\r\nctx->cert->raw_subject_size = vlen;\r\nreturn x509_fabricate_name(ctx, hdrlen, tag, &ctx->cert->subject, vlen);\r\n}\r\nint x509_extract_key_data(void *context, size_t hdrlen,\r\nunsigned char tag,\r\nconst void *value, size_t vlen)\r\n{\r\nstruct x509_parse_context *ctx = context;\r\nif (ctx->last_oid != OID_rsaEncryption)\r\nreturn -ENOPKG;\r\nctx->cert->pub->pkey_algo = PKEY_ALGO_RSA;\r\nctx->key = value + 1;\r\nctx->key_size = vlen - 1;\r\nreturn 0;\r\n}\r\nint rsa_extract_mpi(void *context, size_t hdrlen,\r\nunsigned char tag,\r\nconst void *value, size_t vlen)\r\n{\r\nstruct x509_parse_context *ctx = context;\r\nMPI mpi;\r\nif (ctx->nr_mpi >= ARRAY_SIZE(ctx->cert->pub->mpi)) {\r\npr_err("Too many public key MPIs in certificate\n");\r\nreturn -EBADMSG;\r\n}\r\nmpi = mpi_read_raw_data(value, vlen);\r\nif (!mpi)\r\nreturn -ENOMEM;\r\nctx->cert->pub->mpi[ctx->nr_mpi++] = mpi;\r\nreturn 0;\r\n}\r\nint x509_process_extension(void *context, size_t hdrlen,\r\nunsigned char tag,\r\nconst void *value, size_t vlen)\r\n{\r\nstruct x509_parse_context *ctx = context;\r\nstruct asymmetric_key_id *kid;\r\nconst unsigned char *v = value;\r\npr_debug("Extension: %u\n", ctx->last_oid);\r\nif (ctx->last_oid == OID_subjectKeyIdentifier) {\r\nif (ctx->cert->skid || vlen < 3)\r\nreturn -EBADMSG;\r\nif (v[0] != ASN1_OTS || v[1] != vlen - 2)\r\nreturn -EBADMSG;\r\nv += 2;\r\nvlen -= 2;\r\nctx->cert->raw_skid_size = vlen;\r\nctx->cert->raw_skid = v;\r\nkid = asymmetric_key_generate_id(v, vlen, "", 0);\r\nif (IS_ERR(kid))\r\nreturn PTR_ERR(kid);\r\nctx->cert->skid = kid;\r\npr_debug("subjkeyid %*phN\n", kid->len, kid->data);\r\nreturn 0;\r\n}\r\nif (ctx->last_oid == OID_authorityKeyIdentifier) {\r\nctx->raw_akid = v;\r\nctx->raw_akid_size = vlen;\r\nreturn 0;\r\n}\r\nreturn 0;\r\n}\r\nint x509_decode_time(time64_t *_t, size_t hdrlen,\r\nunsigned char tag,\r\nconst unsigned char *value, size_t vlen)\r\n{\r\nstatic const unsigned char month_lengths[] = { 31, 29, 31, 30, 31, 30,\r\n31, 31, 30, 31, 30, 31 };\r\nconst unsigned char *p = value;\r\nunsigned year, mon, day, hour, min, sec, mon_len;\r\n#define dec2bin(X) ({ unsigned char x = (X) - '0'; if (x > 9) goto invalid_time; x; })\r\n#define DD2bin(P) ({ unsigned x = dec2bin(P[0]) * 10 + dec2bin(P[1]); P += 2; x; })\r\nif (tag == ASN1_UNITIM) {\r\nif (vlen != 13)\r\ngoto unsupported_time;\r\nyear = DD2bin(p);\r\nif (year >= 50)\r\nyear += 1900;\r\nelse\r\nyear += 2000;\r\n} else if (tag == ASN1_GENTIM) {\r\nif (vlen != 15)\r\ngoto unsupported_time;\r\nyear = DD2bin(p) * 100 + DD2bin(p);\r\nif (year >= 1950 && year <= 2049)\r\ngoto invalid_time;\r\n} else {\r\ngoto unsupported_time;\r\n}\r\nmon = DD2bin(p);\r\nday = DD2bin(p);\r\nhour = DD2bin(p);\r\nmin = DD2bin(p);\r\nsec = DD2bin(p);\r\nif (*p != 'Z')\r\ngoto unsupported_time;\r\nif (year < 1970 ||\r\nmon < 1 || mon > 12)\r\ngoto invalid_time;\r\nmon_len = month_lengths[mon - 1];\r\nif (mon == 2) {\r\nif (year % 4 == 0) {\r\nmon_len = 29;\r\nif (year % 100 == 0) {\r\nyear /= 100;\r\nif (year % 4 != 0)\r\nmon_len = 28;\r\n}\r\n}\r\n}\r\nif (day < 1 || day > mon_len ||\r\nhour > 23 ||\r\nmin > 59 ||\r\nsec > 59)\r\ngoto invalid_time;\r\n*_t = mktime64(year, mon, day, hour, min, sec);\r\nreturn 0;\r\nunsupported_time:\r\npr_debug("Got unsupported time [tag %02x]: '%*phN'\n",\r\ntag, (int)vlen, value);\r\nreturn -EBADMSG;\r\ninvalid_time:\r\npr_debug("Got invalid time [tag %02x]: '%*phN'\n",\r\ntag, (int)vlen, value);\r\nreturn -EBADMSG;\r\n}\r\nint x509_note_not_before(void *context, size_t hdrlen,\r\nunsigned char tag,\r\nconst void *value, size_t vlen)\r\n{\r\nstruct x509_parse_context *ctx = context;\r\nreturn x509_decode_time(&ctx->cert->valid_from, hdrlen, tag, value, vlen);\r\n}\r\nint x509_note_not_after(void *context, size_t hdrlen,\r\nunsigned char tag,\r\nconst void *value, size_t vlen)\r\n{\r\nstruct x509_parse_context *ctx = context;\r\nreturn x509_decode_time(&ctx->cert->valid_to, hdrlen, tag, value, vlen);\r\n}\r\nint x509_akid_note_kid(void *context, size_t hdrlen,\r\nunsigned char tag,\r\nconst void *value, size_t vlen)\r\n{\r\nstruct x509_parse_context *ctx = context;\r\nstruct asymmetric_key_id *kid;\r\npr_debug("AKID: keyid: %*phN\n", (int)vlen, value);\r\nif (ctx->cert->akid_skid)\r\nreturn 0;\r\nkid = asymmetric_key_generate_id(value, vlen, "", 0);\r\nif (IS_ERR(kid))\r\nreturn PTR_ERR(kid);\r\npr_debug("authkeyid %*phN\n", kid->len, kid->data);\r\nctx->cert->akid_skid = kid;\r\nreturn 0;\r\n}\r\nint x509_akid_note_name(void *context, size_t hdrlen,\r\nunsigned char tag,\r\nconst void *value, size_t vlen)\r\n{\r\nstruct x509_parse_context *ctx = context;\r\npr_debug("AKID: name: %*phN\n", (int)vlen, value);\r\nctx->akid_raw_issuer = value;\r\nctx->akid_raw_issuer_size = vlen;\r\nreturn 0;\r\n}\r\nint x509_akid_note_serial(void *context, size_t hdrlen,\r\nunsigned char tag,\r\nconst void *value, size_t vlen)\r\n{\r\nstruct x509_parse_context *ctx = context;\r\nstruct asymmetric_key_id *kid;\r\npr_debug("AKID: serial: %*phN\n", (int)vlen, value);\r\nif (!ctx->akid_raw_issuer || ctx->cert->akid_id)\r\nreturn 0;\r\nkid = asymmetric_key_generate_id(value,\r\nvlen,\r\nctx->akid_raw_issuer,\r\nctx->akid_raw_issuer_size);\r\nif (IS_ERR(kid))\r\nreturn PTR_ERR(kid);\r\npr_debug("authkeyid %*phN\n", kid->len, kid->data);\r\nctx->cert->akid_id = kid;\r\nreturn 0;\r\n}
