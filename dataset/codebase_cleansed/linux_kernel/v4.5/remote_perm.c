static inline struct ll_remote_perm *alloc_ll_remote_perm(void)\r\n{\r\nstruct ll_remote_perm *lrp;\r\nlrp = kmem_cache_alloc(ll_remote_perm_cachep, GFP_KERNEL | __GFP_ZERO);\r\nif (lrp)\r\nINIT_HLIST_NODE(&lrp->lrp_list);\r\nreturn lrp;\r\n}\r\nstatic inline void free_ll_remote_perm(struct ll_remote_perm *lrp)\r\n{\r\nif (!lrp)\r\nreturn;\r\nif (!hlist_unhashed(&lrp->lrp_list))\r\nhlist_del(&lrp->lrp_list);\r\nkmem_cache_free(ll_remote_perm_cachep, lrp);\r\n}\r\nstatic struct hlist_head *alloc_rmtperm_hash(void)\r\n{\r\nstruct hlist_head *hash;\r\nint i;\r\nhash = kmem_cache_alloc(ll_rmtperm_hash_cachep, GFP_NOFS | __GFP_ZERO);\r\nif (!hash)\r\nreturn NULL;\r\nfor (i = 0; i < REMOTE_PERM_HASHSIZE; i++)\r\nINIT_HLIST_HEAD(hash + i);\r\nreturn hash;\r\n}\r\nvoid free_rmtperm_hash(struct hlist_head *hash)\r\n{\r\nint i;\r\nstruct ll_remote_perm *lrp;\r\nstruct hlist_node *next;\r\nif (!hash)\r\nreturn;\r\nfor (i = 0; i < REMOTE_PERM_HASHSIZE; i++)\r\nhlist_for_each_entry_safe(lrp, next, hash + i, lrp_list)\r\nfree_ll_remote_perm(lrp);\r\nkmem_cache_free(ll_rmtperm_hash_cachep, hash);\r\n}\r\nstatic inline int remote_perm_hashfunc(uid_t uid)\r\n{\r\nreturn uid & (REMOTE_PERM_HASHSIZE - 1);\r\n}\r\nstatic int do_check_remote_perm(struct ll_inode_info *lli, int mask)\r\n{\r\nstruct hlist_head *head;\r\nstruct ll_remote_perm *lrp;\r\nint found = 0, rc;\r\nif (!lli->lli_remote_perms)\r\nreturn -ENOENT;\r\nhead = lli->lli_remote_perms +\r\nremote_perm_hashfunc(from_kuid(&init_user_ns, current_uid()));\r\nspin_lock(&lli->lli_lock);\r\nhlist_for_each_entry(lrp, head, lrp_list) {\r\nif (lrp->lrp_uid != from_kuid(&init_user_ns, current_uid()))\r\ncontinue;\r\nif (lrp->lrp_gid != from_kgid(&init_user_ns, current_gid()))\r\ncontinue;\r\nif (lrp->lrp_fsuid != from_kuid(&init_user_ns, current_fsuid()))\r\ncontinue;\r\nif (lrp->lrp_fsgid != from_kgid(&init_user_ns, current_fsgid()))\r\ncontinue;\r\nfound = 1;\r\nbreak;\r\n}\r\nif (!found) {\r\nrc = -ENOENT;\r\ngoto out;\r\n}\r\nCDEBUG(D_SEC, "found remote perm: %u/%u/%u/%u - %#x\n",\r\nlrp->lrp_uid, lrp->lrp_gid, lrp->lrp_fsuid, lrp->lrp_fsgid,\r\nlrp->lrp_access_perm);\r\nrc = ((lrp->lrp_access_perm & mask) == mask) ? 0 : -EACCES;\r\nout:\r\nspin_unlock(&lli->lli_lock);\r\nreturn rc;\r\n}\r\nint ll_update_remote_perm(struct inode *inode, struct mdt_remote_perm *perm)\r\n{\r\nstruct ll_inode_info *lli = ll_i2info(inode);\r\nstruct ll_remote_perm *lrp = NULL, *tmp = NULL;\r\nstruct hlist_head *head, *perm_hash = NULL;\r\nLASSERT(ll_i2sbi(inode)->ll_flags & LL_SBI_RMT_CLIENT);\r\n#if 0\r\nif (perm->rp_uid != current->uid ||\r\nperm->rp_gid != current->gid ||\r\nperm->rp_fsuid != current->fsuid ||\r\nperm->rp_fsgid != current->fsgid) {\r\nCDEBUG(D_SEC,\r\n"remote perm user %u/%u/%u/%u != current %u/%u/%u/%u\n",\r\nperm->rp_uid, perm->rp_gid, perm->rp_fsuid,\r\nperm->rp_fsgid, current->uid, current->gid,\r\ncurrent->fsuid, current->fsgid);\r\nreturn -EAGAIN;\r\n}\r\n#endif\r\nif (!lli->lli_remote_perms) {\r\nperm_hash = alloc_rmtperm_hash();\r\nif (!perm_hash) {\r\nCERROR("alloc lli_remote_perms failed!\n");\r\nreturn -ENOMEM;\r\n}\r\n}\r\nspin_lock(&lli->lli_lock);\r\nif (!lli->lli_remote_perms)\r\nlli->lli_remote_perms = perm_hash;\r\nelse\r\nfree_rmtperm_hash(perm_hash);\r\nhead = lli->lli_remote_perms + remote_perm_hashfunc(perm->rp_uid);\r\nagain:\r\nhlist_for_each_entry(tmp, head, lrp_list) {\r\nif (tmp->lrp_uid != perm->rp_uid)\r\ncontinue;\r\nif (tmp->lrp_gid != perm->rp_gid)\r\ncontinue;\r\nif (tmp->lrp_fsuid != perm->rp_fsuid)\r\ncontinue;\r\nif (tmp->lrp_fsgid != perm->rp_fsgid)\r\ncontinue;\r\nfree_ll_remote_perm(lrp);\r\nlrp = tmp;\r\nbreak;\r\n}\r\nif (!lrp) {\r\nspin_unlock(&lli->lli_lock);\r\nlrp = alloc_ll_remote_perm();\r\nif (!lrp) {\r\nCERROR("alloc memory for ll_remote_perm failed!\n");\r\nreturn -ENOMEM;\r\n}\r\nspin_lock(&lli->lli_lock);\r\ngoto again;\r\n}\r\nlrp->lrp_access_perm = perm->rp_access_perm;\r\nif (lrp != tmp) {\r\nlrp->lrp_uid = perm->rp_uid;\r\nlrp->lrp_gid = perm->rp_gid;\r\nlrp->lrp_fsuid = perm->rp_fsuid;\r\nlrp->lrp_fsgid = perm->rp_fsgid;\r\nhlist_add_head(&lrp->lrp_list, head);\r\n}\r\nlli->lli_rmtperm_time = cfs_time_current();\r\nspin_unlock(&lli->lli_lock);\r\nCDEBUG(D_SEC, "new remote perm@%p: %u/%u/%u/%u - %#x\n",\r\nlrp, lrp->lrp_uid, lrp->lrp_gid, lrp->lrp_fsuid, lrp->lrp_fsgid,\r\nlrp->lrp_access_perm);\r\nreturn 0;\r\n}\r\nint lustre_check_remote_perm(struct inode *inode, int mask)\r\n{\r\nstruct ll_inode_info *lli = ll_i2info(inode);\r\nstruct ll_sb_info *sbi = ll_i2sbi(inode);\r\nstruct ptlrpc_request *req = NULL;\r\nstruct mdt_remote_perm *perm;\r\nunsigned long save;\r\nint i = 0, rc;\r\ndo {\r\nsave = lli->lli_rmtperm_time;\r\nrc = do_check_remote_perm(lli, mask);\r\nif (!rc || (rc != -ENOENT && i))\r\nbreak;\r\nmight_sleep();\r\nmutex_lock(&lli->lli_rmtperm_mutex);\r\nif (save != lli->lli_rmtperm_time) {\r\nrc = do_check_remote_perm(lli, mask);\r\nif (!rc || (rc != -ENOENT && i)) {\r\nmutex_unlock(&lli->lli_rmtperm_mutex);\r\nbreak;\r\n}\r\n}\r\nif (i++ > 5) {\r\nCERROR("check remote perm falls in dead loop!\n");\r\nLBUG();\r\n}\r\nrc = md_get_remote_perm(sbi->ll_md_exp, ll_inode2fid(inode),\r\nll_i2suppgid(inode), &req);\r\nif (rc) {\r\nmutex_unlock(&lli->lli_rmtperm_mutex);\r\nbreak;\r\n}\r\nperm = req_capsule_server_swab_get(&req->rq_pill, &RMF_ACL,\r\nlustre_swab_mdt_remote_perm);\r\nif (unlikely(!perm)) {\r\nmutex_unlock(&lli->lli_rmtperm_mutex);\r\nrc = -EPROTO;\r\nbreak;\r\n}\r\nrc = ll_update_remote_perm(inode, perm);\r\nmutex_unlock(&lli->lli_rmtperm_mutex);\r\nif (rc == -ENOMEM)\r\nbreak;\r\nptlrpc_req_finished(req);\r\nreq = NULL;\r\n} while (1);\r\nptlrpc_req_finished(req);\r\nreturn rc;\r\n}
