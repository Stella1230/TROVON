static long\r\nrestore_sigcontext(struct sigcontext __user *sc, struct pt_regs *regs)\r\n{\r\nunsigned long usp;\r\nstruct switch_stack *sw = (struct switch_stack *)regs - 1;\r\nlong i, err = __get_user(regs->pc, &sc->sc_pc);\r\ncurrent->restart_block.fn = do_no_restart_syscall;\r\nsw->r26 = (unsigned long) ret_from_sys_call;\r\nerr |= __get_user(regs->r0, sc->sc_regs+0);\r\nerr |= __get_user(regs->r1, sc->sc_regs+1);\r\nerr |= __get_user(regs->r2, sc->sc_regs+2);\r\nerr |= __get_user(regs->r3, sc->sc_regs+3);\r\nerr |= __get_user(regs->r4, sc->sc_regs+4);\r\nerr |= __get_user(regs->r5, sc->sc_regs+5);\r\nerr |= __get_user(regs->r6, sc->sc_regs+6);\r\nerr |= __get_user(regs->r7, sc->sc_regs+7);\r\nerr |= __get_user(regs->r8, sc->sc_regs+8);\r\nerr |= __get_user(sw->r9, sc->sc_regs+9);\r\nerr |= __get_user(sw->r10, sc->sc_regs+10);\r\nerr |= __get_user(sw->r11, sc->sc_regs+11);\r\nerr |= __get_user(sw->r12, sc->sc_regs+12);\r\nerr |= __get_user(sw->r13, sc->sc_regs+13);\r\nerr |= __get_user(sw->r14, sc->sc_regs+14);\r\nerr |= __get_user(sw->r15, sc->sc_regs+15);\r\nerr |= __get_user(regs->r16, sc->sc_regs+16);\r\nerr |= __get_user(regs->r17, sc->sc_regs+17);\r\nerr |= __get_user(regs->r18, sc->sc_regs+18);\r\nerr |= __get_user(regs->r19, sc->sc_regs+19);\r\nerr |= __get_user(regs->r20, sc->sc_regs+20);\r\nerr |= __get_user(regs->r21, sc->sc_regs+21);\r\nerr |= __get_user(regs->r22, sc->sc_regs+22);\r\nerr |= __get_user(regs->r23, sc->sc_regs+23);\r\nerr |= __get_user(regs->r24, sc->sc_regs+24);\r\nerr |= __get_user(regs->r25, sc->sc_regs+25);\r\nerr |= __get_user(regs->r26, sc->sc_regs+26);\r\nerr |= __get_user(regs->r27, sc->sc_regs+27);\r\nerr |= __get_user(regs->r28, sc->sc_regs+28);\r\nerr |= __get_user(regs->gp, sc->sc_regs+29);\r\nerr |= __get_user(usp, sc->sc_regs+30);\r\nwrusp(usp);\r\nfor (i = 0; i < 31; i++)\r\nerr |= __get_user(sw->fp[i], sc->sc_fpregs+i);\r\nerr |= __get_user(sw->fp[31], &sc->sc_fpcr);\r\nreturn err;\r\n}\r\nasmlinkage void\r\ndo_sigreturn(struct sigcontext __user *sc)\r\n{\r\nstruct pt_regs *regs = current_pt_regs();\r\nsigset_t set;\r\nif (!access_ok(VERIFY_READ, sc, sizeof(*sc)))\r\ngoto give_sigsegv;\r\nif (__get_user(set.sig[0], &sc->sc_mask))\r\ngoto give_sigsegv;\r\nset_current_blocked(&set);\r\nif (restore_sigcontext(sc, regs))\r\ngoto give_sigsegv;\r\nif (ptrace_cancel_bpt (current)) {\r\nsiginfo_t info;\r\ninfo.si_signo = SIGTRAP;\r\ninfo.si_errno = 0;\r\ninfo.si_code = TRAP_BRKPT;\r\ninfo.si_addr = (void __user *) regs->pc;\r\ninfo.si_trapno = 0;\r\nsend_sig_info(SIGTRAP, &info, current);\r\n}\r\nreturn;\r\ngive_sigsegv:\r\nforce_sig(SIGSEGV, current);\r\n}\r\nasmlinkage void\r\ndo_rt_sigreturn(struct rt_sigframe __user *frame)\r\n{\r\nstruct pt_regs *regs = current_pt_regs();\r\nsigset_t set;\r\nif (!access_ok(VERIFY_READ, &frame->uc, sizeof(frame->uc)))\r\ngoto give_sigsegv;\r\nif (__copy_from_user(&set, &frame->uc.uc_sigmask, sizeof(set)))\r\ngoto give_sigsegv;\r\nset_current_blocked(&set);\r\nif (restore_sigcontext(&frame->uc.uc_mcontext, regs))\r\ngoto give_sigsegv;\r\nif (ptrace_cancel_bpt (current)) {\r\nsiginfo_t info;\r\ninfo.si_signo = SIGTRAP;\r\ninfo.si_errno = 0;\r\ninfo.si_code = TRAP_BRKPT;\r\ninfo.si_addr = (void __user *) regs->pc;\r\ninfo.si_trapno = 0;\r\nsend_sig_info(SIGTRAP, &info, current);\r\n}\r\nreturn;\r\ngive_sigsegv:\r\nforce_sig(SIGSEGV, current);\r\n}\r\nstatic inline void __user *\r\nget_sigframe(struct ksignal *ksig, unsigned long sp, size_t frame_size)\r\n{\r\nreturn (void __user *)((sigsp(sp, ksig) - frame_size) & -32ul);\r\n}\r\nstatic long\r\nsetup_sigcontext(struct sigcontext __user *sc, struct pt_regs *regs,\r\nunsigned long mask, unsigned long sp)\r\n{\r\nstruct switch_stack *sw = (struct switch_stack *)regs - 1;\r\nlong i, err = 0;\r\nerr |= __put_user(on_sig_stack((unsigned long)sc), &sc->sc_onstack);\r\nerr |= __put_user(mask, &sc->sc_mask);\r\nerr |= __put_user(regs->pc, &sc->sc_pc);\r\nerr |= __put_user(8, &sc->sc_ps);\r\nerr |= __put_user(regs->r0 , sc->sc_regs+0);\r\nerr |= __put_user(regs->r1 , sc->sc_regs+1);\r\nerr |= __put_user(regs->r2 , sc->sc_regs+2);\r\nerr |= __put_user(regs->r3 , sc->sc_regs+3);\r\nerr |= __put_user(regs->r4 , sc->sc_regs+4);\r\nerr |= __put_user(regs->r5 , sc->sc_regs+5);\r\nerr |= __put_user(regs->r6 , sc->sc_regs+6);\r\nerr |= __put_user(regs->r7 , sc->sc_regs+7);\r\nerr |= __put_user(regs->r8 , sc->sc_regs+8);\r\nerr |= __put_user(sw->r9 , sc->sc_regs+9);\r\nerr |= __put_user(sw->r10 , sc->sc_regs+10);\r\nerr |= __put_user(sw->r11 , sc->sc_regs+11);\r\nerr |= __put_user(sw->r12 , sc->sc_regs+12);\r\nerr |= __put_user(sw->r13 , sc->sc_regs+13);\r\nerr |= __put_user(sw->r14 , sc->sc_regs+14);\r\nerr |= __put_user(sw->r15 , sc->sc_regs+15);\r\nerr |= __put_user(regs->r16, sc->sc_regs+16);\r\nerr |= __put_user(regs->r17, sc->sc_regs+17);\r\nerr |= __put_user(regs->r18, sc->sc_regs+18);\r\nerr |= __put_user(regs->r19, sc->sc_regs+19);\r\nerr |= __put_user(regs->r20, sc->sc_regs+20);\r\nerr |= __put_user(regs->r21, sc->sc_regs+21);\r\nerr |= __put_user(regs->r22, sc->sc_regs+22);\r\nerr |= __put_user(regs->r23, sc->sc_regs+23);\r\nerr |= __put_user(regs->r24, sc->sc_regs+24);\r\nerr |= __put_user(regs->r25, sc->sc_regs+25);\r\nerr |= __put_user(regs->r26, sc->sc_regs+26);\r\nerr |= __put_user(regs->r27, sc->sc_regs+27);\r\nerr |= __put_user(regs->r28, sc->sc_regs+28);\r\nerr |= __put_user(regs->gp , sc->sc_regs+29);\r\nerr |= __put_user(sp, sc->sc_regs+30);\r\nerr |= __put_user(0, sc->sc_regs+31);\r\nfor (i = 0; i < 31; i++)\r\nerr |= __put_user(sw->fp[i], sc->sc_fpregs+i);\r\nerr |= __put_user(0, sc->sc_fpregs+31);\r\nerr |= __put_user(sw->fp[31], &sc->sc_fpcr);\r\nerr |= __put_user(regs->trap_a0, &sc->sc_traparg_a0);\r\nerr |= __put_user(regs->trap_a1, &sc->sc_traparg_a1);\r\nerr |= __put_user(regs->trap_a2, &sc->sc_traparg_a2);\r\nreturn err;\r\n}\r\nstatic int\r\nsetup_frame(struct ksignal *ksig, sigset_t *set, struct pt_regs *regs)\r\n{\r\nunsigned long oldsp, r26, err = 0;\r\nstruct sigframe __user *frame;\r\noldsp = rdusp();\r\nframe = get_sigframe(ksig, oldsp, sizeof(*frame));\r\nif (!access_ok(VERIFY_WRITE, frame, sizeof(*frame)))\r\nreturn -EFAULT;\r\nerr |= setup_sigcontext(&frame->sc, regs, set->sig[0], oldsp);\r\nif (err)\r\nreturn -EFAULT;\r\nr26 = (unsigned long) ksig->ka.ka_restorer;\r\nif (!r26) {\r\nerr |= __put_user(INSN_MOV_R30_R16, frame->retcode+0);\r\nerr |= __put_user(INSN_LDI_R0+__NR_sigreturn, frame->retcode+1);\r\nerr |= __put_user(INSN_CALLSYS, frame->retcode+2);\r\nimb();\r\nr26 = (unsigned long) frame->retcode;\r\n}\r\nif (err)\r\nreturn err;\r\nregs->r26 = r26;\r\nregs->r27 = regs->pc = (unsigned long) ksig->ka.sa.sa_handler;\r\nregs->r16 = ksig->sig;\r\nregs->r17 = 0;\r\nregs->r18 = (unsigned long) &frame->sc;\r\nwrusp((unsigned long) frame);\r\n#if DEBUG_SIG\r\nprintk("SIG deliver (%s:%d): sp=%p pc=%p ra=%p\n",\r\ncurrent->comm, current->pid, frame, regs->pc, regs->r26);\r\n#endif\r\nreturn 0;\r\n}\r\nstatic int\r\nsetup_rt_frame(struct ksignal *ksig, sigset_t *set, struct pt_regs *regs)\r\n{\r\nunsigned long oldsp, r26, err = 0;\r\nstruct rt_sigframe __user *frame;\r\noldsp = rdusp();\r\nframe = get_sigframe(ksig, oldsp, sizeof(*frame));\r\nif (!access_ok(VERIFY_WRITE, frame, sizeof(*frame)))\r\nreturn -EFAULT;\r\nerr |= copy_siginfo_to_user(&frame->info, &ksig->info);\r\nerr |= __put_user(0, &frame->uc.uc_flags);\r\nerr |= __put_user(0, &frame->uc.uc_link);\r\nerr |= __put_user(set->sig[0], &frame->uc.uc_osf_sigmask);\r\nerr |= __save_altstack(&frame->uc.uc_stack, oldsp);\r\nerr |= setup_sigcontext(&frame->uc.uc_mcontext, regs,\r\nset->sig[0], oldsp);\r\nerr |= __copy_to_user(&frame->uc.uc_sigmask, set, sizeof(*set));\r\nif (err)\r\nreturn -EFAULT;\r\nr26 = (unsigned long) ksig->ka.ka_restorer;\r\nif (!r26) {\r\nerr |= __put_user(INSN_MOV_R30_R16, frame->retcode+0);\r\nerr |= __put_user(INSN_LDI_R0+__NR_rt_sigreturn,\r\nframe->retcode+1);\r\nerr |= __put_user(INSN_CALLSYS, frame->retcode+2);\r\nimb();\r\nr26 = (unsigned long) frame->retcode;\r\n}\r\nif (err)\r\nreturn -EFAULT;\r\nregs->r26 = r26;\r\nregs->r27 = regs->pc = (unsigned long) ksig->ka.sa.sa_handler;\r\nregs->r16 = ksig->sig;\r\nregs->r17 = (unsigned long) &frame->info;\r\nregs->r18 = (unsigned long) &frame->uc;\r\nwrusp((unsigned long) frame);\r\n#if DEBUG_SIG\r\nprintk("SIG deliver (%s:%d): sp=%p pc=%p ra=%p\n",\r\ncurrent->comm, current->pid, frame, regs->pc, regs->r26);\r\n#endif\r\nreturn 0;\r\n}\r\nstatic inline void\r\nhandle_signal(struct ksignal *ksig, struct pt_regs *regs)\r\n{\r\nsigset_t *oldset = sigmask_to_save();\r\nint ret;\r\nif (ksig->ka.sa.sa_flags & SA_SIGINFO)\r\nret = setup_rt_frame(ksig, oldset, regs);\r\nelse\r\nret = setup_frame(ksig, oldset, regs);\r\nsignal_setup_done(ret, ksig, 0);\r\n}\r\nstatic inline void\r\nsyscall_restart(unsigned long r0, unsigned long r19,\r\nstruct pt_regs *regs, struct k_sigaction *ka)\r\n{\r\nswitch (regs->r0) {\r\ncase ERESTARTSYS:\r\nif (!(ka->sa.sa_flags & SA_RESTART)) {\r\ncase ERESTARTNOHAND:\r\nregs->r0 = EINTR;\r\nbreak;\r\n}\r\ncase ERESTARTNOINTR:\r\nregs->r0 = r0;\r\nregs->r19 = r19;\r\nregs->pc -= 4;\r\nbreak;\r\ncase ERESTART_RESTARTBLOCK:\r\nregs->r0 = EINTR;\r\nbreak;\r\n}\r\n}\r\nstatic void\r\ndo_signal(struct pt_regs *regs, unsigned long r0, unsigned long r19)\r\n{\r\nunsigned long single_stepping = ptrace_cancel_bpt(current);\r\nstruct ksignal ksig;\r\nif (get_signal(&ksig)) {\r\nsingle_stepping |= ptrace_cancel_bpt(current);\r\nif (r0)\r\nsyscall_restart(r0, r19, regs, &ksig.ka);\r\nhandle_signal(&ksig, regs);\r\n} else {\r\nsingle_stepping |= ptrace_cancel_bpt(current);\r\nif (r0) {\r\nswitch (regs->r0) {\r\ncase ERESTARTNOHAND:\r\ncase ERESTARTSYS:\r\ncase ERESTARTNOINTR:\r\nregs->r0 = r0;\r\nregs->r19 = r19;\r\nregs->pc -= 4;\r\nbreak;\r\ncase ERESTART_RESTARTBLOCK:\r\nregs->r0 = __NR_restart_syscall;\r\nregs->pc -= 4;\r\nbreak;\r\n}\r\n}\r\nrestore_saved_sigmask();\r\n}\r\nif (single_stepping)\r\nptrace_set_bpt(current);\r\n}\r\nvoid\r\ndo_work_pending(struct pt_regs *regs, unsigned long thread_flags,\r\nunsigned long r0, unsigned long r19)\r\n{\r\ndo {\r\nif (thread_flags & _TIF_NEED_RESCHED) {\r\nschedule();\r\n} else {\r\nlocal_irq_enable();\r\nif (thread_flags & _TIF_SIGPENDING) {\r\ndo_signal(regs, r0, r19);\r\nr0 = 0;\r\n} else {\r\nclear_thread_flag(TIF_NOTIFY_RESUME);\r\ntracehook_notify_resume(regs);\r\n}\r\n}\r\nlocal_irq_disable();\r\nthread_flags = current_thread_info()->flags;\r\n} while (thread_flags & _TIF_WORK_MASK);\r\n}
