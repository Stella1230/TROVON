int dvo_awg_generate_code(struct sti_dvo *dvo, u8 *ram_size, u32 *ram_code)\r\n{\r\nstruct drm_display_mode *mode = &dvo->mode;\r\nstruct dvo_config *config = dvo->config;\r\nstruct awg_code_generation_params fw_gen_params;\r\nstruct awg_timing timing;\r\nfw_gen_params.ram_code = ram_code;\r\nfw_gen_params.instruction_offset = 0;\r\ntiming.total_lines = mode->vtotal;\r\ntiming.active_lines = mode->vdisplay;\r\ntiming.blanking_lines = mode->vsync_start - mode->vdisplay;\r\ntiming.trailing_lines = mode->vtotal - mode->vsync_start;\r\ntiming.total_pixels = mode->htotal;\r\ntiming.active_pixels = mode->hdisplay;\r\ntiming.blanking_pixels = mode->hsync_start - mode->hdisplay;\r\ntiming.trailing_pixels = mode->htotal - mode->hsync_start;\r\ntiming.blanking_level = BLANKING_LEVEL;\r\nif (config->awg_fwgen_fct(&fw_gen_params, &timing)) {\r\nDRM_ERROR("AWG firmware not properly generated\n");\r\nreturn -EINVAL;\r\n}\r\n*ram_size = fw_gen_params.instruction_offset;\r\nreturn 0;\r\n}\r\nstatic void dvo_awg_configure(struct sti_dvo *dvo, u32 *awg_ram_code, int nb)\r\n{\r\nint i;\r\nDRM_DEBUG_DRIVER("\n");\r\nfor (i = 0; i < nb; i++)\r\nwritel(awg_ram_code[i],\r\ndvo->regs + DVO_DIGSYNC_INSTR_I + i * 4);\r\nfor (i = nb; i < AWG_MAX_INST; i++)\r\nwritel(0, dvo->regs + DVO_DIGSYNC_INSTR_I + i * 4);\r\nwritel(DVO_AWG_CTRL_EN, dvo->regs + DVO_AWG_DIGSYNC_CTRL);\r\n}\r\nstatic void sti_dvo_disable(struct drm_bridge *bridge)\r\n{\r\nstruct sti_dvo *dvo = bridge->driver_private;\r\nif (!dvo->enabled)\r\nreturn;\r\nDRM_DEBUG_DRIVER("\n");\r\nif (dvo->config->awg_fwgen_fct)\r\nwritel(0x00000000, dvo->regs + DVO_AWG_DIGSYNC_CTRL);\r\nwritel(0x00000000, dvo->regs + DVO_DOF_CFG);\r\nif (dvo->panel)\r\ndvo->panel->funcs->disable(dvo->panel);\r\nclk_disable_unprepare(dvo->clk_pix);\r\nclk_disable_unprepare(dvo->clk);\r\ndvo->enabled = false;\r\n}\r\nstatic void sti_dvo_pre_enable(struct drm_bridge *bridge)\r\n{\r\nstruct sti_dvo *dvo = bridge->driver_private;\r\nstruct dvo_config *config = dvo->config;\r\nu32 val;\r\nDRM_DEBUG_DRIVER("\n");\r\nif (dvo->enabled)\r\nreturn;\r\nwritel(0x00000000, dvo->regs + DVO_DOF_CFG);\r\nwritel(0x00000000, dvo->regs + DVO_AWG_DIGSYNC_CTRL);\r\nif (config->awg_fwgen_fct) {\r\nu8 nb_instr;\r\nu32 awg_ram_code[AWG_MAX_INST];\r\nif (!dvo_awg_generate_code(dvo, &nb_instr, awg_ram_code))\r\ndvo_awg_configure(dvo, awg_ram_code, nb_instr);\r\nelse\r\nreturn;\r\n}\r\nif (clk_prepare_enable(dvo->clk_pix))\r\nDRM_ERROR("Failed to prepare/enable dvo_pix clk\n");\r\nif (clk_prepare_enable(dvo->clk))\r\nDRM_ERROR("Failed to prepare/enable dvo clk\n");\r\nif (dvo->panel)\r\ndvo->panel->funcs->enable(dvo->panel);\r\nwritel(config->lowbyte, dvo->regs + DVO_LUT_PROG_LOW);\r\nwritel(config->midbyte, dvo->regs + DVO_LUT_PROG_MID);\r\nwritel(config->highbyte, dvo->regs + DVO_LUT_PROG_HIGH);\r\nval = (config->flags | DVO_DOF_EN);\r\nwritel(val, dvo->regs + DVO_DOF_CFG);\r\ndvo->enabled = true;\r\n}\r\nstatic void sti_dvo_set_mode(struct drm_bridge *bridge,\r\nstruct drm_display_mode *mode,\r\nstruct drm_display_mode *adjusted_mode)\r\n{\r\nstruct sti_dvo *dvo = bridge->driver_private;\r\nstruct sti_mixer *mixer = to_sti_mixer(dvo->encoder->crtc);\r\nint rate = mode->clock * 1000;\r\nstruct clk *clkp;\r\nint ret;\r\nDRM_DEBUG_DRIVER("\n");\r\nmemcpy(&dvo->mode, mode, sizeof(struct drm_display_mode));\r\nif (mixer->id == STI_MIXER_MAIN)\r\nclkp = dvo->clk_main_parent;\r\nelse\r\nclkp = dvo->clk_aux_parent;\r\nif (clkp) {\r\nclk_set_parent(dvo->clk_pix, clkp);\r\nclk_set_parent(dvo->clk, clkp);\r\n}\r\nret = clk_set_rate(dvo->clk_pix, rate);\r\nif (ret < 0) {\r\nDRM_ERROR("Cannot set rate (%dHz) for dvo_pix clk\n", rate);\r\nreturn;\r\n}\r\nret = clk_set_rate(dvo->clk, rate);\r\nif (ret < 0) {\r\nDRM_ERROR("Cannot set rate (%dHz) for dvo clk\n", rate);\r\nreturn;\r\n}\r\ndvo->config = &rgb_24bit_de_cfg;\r\n}\r\nstatic void sti_dvo_bridge_nope(struct drm_bridge *bridge)\r\n{\r\n}\r\nstatic int sti_dvo_connector_get_modes(struct drm_connector *connector)\r\n{\r\nstruct sti_dvo_connector *dvo_connector\r\n= to_sti_dvo_connector(connector);\r\nstruct sti_dvo *dvo = dvo_connector->dvo;\r\nif (dvo->panel)\r\nreturn dvo->panel->funcs->get_modes(dvo->panel);\r\nreturn 0;\r\n}\r\nstatic int sti_dvo_connector_mode_valid(struct drm_connector *connector,\r\nstruct drm_display_mode *mode)\r\n{\r\nint target = mode->clock * 1000;\r\nint target_min = target - CLK_TOLERANCE_HZ;\r\nint target_max = target + CLK_TOLERANCE_HZ;\r\nint result;\r\nstruct sti_dvo_connector *dvo_connector\r\n= to_sti_dvo_connector(connector);\r\nstruct sti_dvo *dvo = dvo_connector->dvo;\r\nresult = clk_round_rate(dvo->clk_pix, target);\r\nDRM_DEBUG_DRIVER("target rate = %d => available rate = %d\n",\r\ntarget, result);\r\nif ((result < target_min) || (result > target_max)) {\r\nDRM_DEBUG_DRIVER("dvo pixclk=%d not supported\n", target);\r\nreturn MODE_BAD;\r\n}\r\nreturn MODE_OK;\r\n}\r\nstruct drm_encoder *sti_dvo_best_encoder(struct drm_connector *connector)\r\n{\r\nstruct sti_dvo_connector *dvo_connector\r\n= to_sti_dvo_connector(connector);\r\nreturn dvo_connector->encoder;\r\n}\r\nstatic enum drm_connector_status\r\nsti_dvo_connector_detect(struct drm_connector *connector, bool force)\r\n{\r\nstruct sti_dvo_connector *dvo_connector\r\n= to_sti_dvo_connector(connector);\r\nstruct sti_dvo *dvo = dvo_connector->dvo;\r\nDRM_DEBUG_DRIVER("\n");\r\nif (!dvo->panel)\r\ndvo->panel = of_drm_find_panel(dvo->panel_node);\r\nif (dvo->panel)\r\nif (!drm_panel_attach(dvo->panel, connector))\r\nreturn connector_status_connected;\r\nreturn connector_status_disconnected;\r\n}\r\nstatic void sti_dvo_connector_destroy(struct drm_connector *connector)\r\n{\r\nstruct sti_dvo_connector *dvo_connector\r\n= to_sti_dvo_connector(connector);\r\ndrm_connector_unregister(connector);\r\ndrm_connector_cleanup(connector);\r\nkfree(dvo_connector);\r\n}\r\nstatic struct drm_encoder *sti_dvo_find_encoder(struct drm_device *dev)\r\n{\r\nstruct drm_encoder *encoder;\r\nlist_for_each_entry(encoder, &dev->mode_config.encoder_list, head) {\r\nif (encoder->encoder_type == DRM_MODE_ENCODER_LVDS)\r\nreturn encoder;\r\n}\r\nreturn NULL;\r\n}\r\nstatic int sti_dvo_bind(struct device *dev, struct device *master, void *data)\r\n{\r\nstruct sti_dvo *dvo = dev_get_drvdata(dev);\r\nstruct drm_device *drm_dev = data;\r\nstruct drm_encoder *encoder;\r\nstruct sti_dvo_connector *connector;\r\nstruct drm_connector *drm_connector;\r\nstruct drm_bridge *bridge;\r\nint err;\r\ndvo->drm_dev = drm_dev;\r\nencoder = sti_dvo_find_encoder(drm_dev);\r\nif (!encoder)\r\nreturn -ENOMEM;\r\nconnector = devm_kzalloc(dev, sizeof(*connector), GFP_KERNEL);\r\nif (!connector)\r\nreturn -ENOMEM;\r\nconnector->dvo = dvo;\r\nbridge = devm_kzalloc(dev, sizeof(*bridge), GFP_KERNEL);\r\nif (!bridge)\r\nreturn -ENOMEM;\r\nbridge->driver_private = dvo;\r\nbridge->funcs = &sti_dvo_bridge_funcs;\r\nbridge->of_node = dvo->dev.of_node;\r\nerr = drm_bridge_add(bridge);\r\nif (err) {\r\nDRM_ERROR("Failed to add bridge\n");\r\nreturn err;\r\n}\r\nerr = drm_bridge_attach(drm_dev, bridge);\r\nif (err) {\r\nDRM_ERROR("Failed to attach bridge\n");\r\nreturn err;\r\n}\r\ndvo->bridge = bridge;\r\nencoder->bridge = bridge;\r\nconnector->encoder = encoder;\r\ndvo->encoder = encoder;\r\ndrm_connector = (struct drm_connector *)connector;\r\ndrm_connector->polled = DRM_CONNECTOR_POLL_HPD;\r\ndrm_connector_init(drm_dev, drm_connector,\r\n&sti_dvo_connector_funcs, DRM_MODE_CONNECTOR_LVDS);\r\ndrm_connector_helper_add(drm_connector,\r\n&sti_dvo_connector_helper_funcs);\r\nerr = drm_connector_register(drm_connector);\r\nif (err)\r\ngoto err_connector;\r\nerr = drm_mode_connector_attach_encoder(drm_connector, encoder);\r\nif (err) {\r\nDRM_ERROR("Failed to attach a connector to a encoder\n");\r\ngoto err_sysfs;\r\n}\r\nreturn 0;\r\nerr_sysfs:\r\ndrm_connector_unregister(drm_connector);\r\nerr_connector:\r\ndrm_bridge_remove(bridge);\r\ndrm_connector_cleanup(drm_connector);\r\nreturn -EINVAL;\r\n}\r\nstatic void sti_dvo_unbind(struct device *dev,\r\nstruct device *master, void *data)\r\n{\r\nstruct sti_dvo *dvo = dev_get_drvdata(dev);\r\ndrm_bridge_remove(dvo->bridge);\r\n}\r\nstatic int sti_dvo_probe(struct platform_device *pdev)\r\n{\r\nstruct device *dev = &pdev->dev;\r\nstruct sti_dvo *dvo;\r\nstruct resource *res;\r\nstruct device_node *np = dev->of_node;\r\nDRM_INFO("%s\n", __func__);\r\ndvo = devm_kzalloc(dev, sizeof(*dvo), GFP_KERNEL);\r\nif (!dvo) {\r\nDRM_ERROR("Failed to allocate memory for DVO\n");\r\nreturn -ENOMEM;\r\n}\r\ndvo->dev = pdev->dev;\r\nres = platform_get_resource_byname(pdev, IORESOURCE_MEM, "dvo-reg");\r\nif (!res) {\r\nDRM_ERROR("Invalid dvo resource\n");\r\nreturn -ENOMEM;\r\n}\r\ndvo->regs = devm_ioremap_nocache(dev, res->start,\r\nresource_size(res));\r\nif (!dvo->regs)\r\nreturn -ENOMEM;\r\ndvo->clk_pix = devm_clk_get(dev, "dvo_pix");\r\nif (IS_ERR(dvo->clk_pix)) {\r\nDRM_ERROR("Cannot get dvo_pix clock\n");\r\nreturn PTR_ERR(dvo->clk_pix);\r\n}\r\ndvo->clk = devm_clk_get(dev, "dvo");\r\nif (IS_ERR(dvo->clk)) {\r\nDRM_ERROR("Cannot get dvo clock\n");\r\nreturn PTR_ERR(dvo->clk);\r\n}\r\ndvo->clk_main_parent = devm_clk_get(dev, "main_parent");\r\nif (IS_ERR(dvo->clk_main_parent)) {\r\nDRM_DEBUG_DRIVER("Cannot get main_parent clock\n");\r\ndvo->clk_main_parent = NULL;\r\n}\r\ndvo->clk_aux_parent = devm_clk_get(dev, "aux_parent");\r\nif (IS_ERR(dvo->clk_aux_parent)) {\r\nDRM_DEBUG_DRIVER("Cannot get aux_parent clock\n");\r\ndvo->clk_aux_parent = NULL;\r\n}\r\ndvo->panel_node = of_parse_phandle(np, "sti,panel", 0);\r\nif (!dvo->panel_node)\r\nDRM_ERROR("No panel associated to the dvo output\n");\r\nplatform_set_drvdata(pdev, dvo);\r\nreturn component_add(&pdev->dev, &sti_dvo_ops);\r\n}\r\nstatic int sti_dvo_remove(struct platform_device *pdev)\r\n{\r\ncomponent_del(&pdev->dev, &sti_dvo_ops);\r\nreturn 0;\r\n}
