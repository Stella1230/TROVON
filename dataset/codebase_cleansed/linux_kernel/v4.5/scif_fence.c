void scif_recv_mark(struct scif_dev *scifdev, struct scifmsg *msg)\r\n{\r\nstruct scif_endpt *ep = (struct scif_endpt *)msg->payload[0];\r\nint mark, err;\r\nerr = _scif_fence_mark(ep, &mark);\r\nif (err)\r\nmsg->uop = SCIF_MARK_NACK;\r\nelse\r\nmsg->uop = SCIF_MARK_ACK;\r\nmsg->payload[0] = ep->remote_ep;\r\nmsg->payload[2] = mark;\r\nscif_nodeqp_send(ep->remote_dev, msg);\r\n}\r\nvoid scif_recv_mark_resp(struct scif_dev *scifdev, struct scifmsg *msg)\r\n{\r\nstruct scif_endpt *ep = (struct scif_endpt *)msg->payload[0];\r\nstruct scif_fence_info *fence_req =\r\n(struct scif_fence_info *)msg->payload[1];\r\nmutex_lock(&ep->rma_info.rma_lock);\r\nif (msg->uop == SCIF_MARK_ACK) {\r\nfence_req->state = OP_COMPLETED;\r\nfence_req->dma_mark = (int)msg->payload[2];\r\n} else {\r\nfence_req->state = OP_FAILED;\r\n}\r\nmutex_unlock(&ep->rma_info.rma_lock);\r\ncomplete(&fence_req->comp);\r\n}\r\nvoid scif_recv_wait(struct scif_dev *scifdev, struct scifmsg *msg)\r\n{\r\nstruct scif_endpt *ep = (struct scif_endpt *)msg->payload[0];\r\nstruct scif_remote_fence_info *fence;\r\nfence = kmalloc(sizeof(*fence), GFP_KERNEL);\r\nif (!fence) {\r\nmsg->payload[0] = ep->remote_ep;\r\nmsg->uop = SCIF_WAIT_NACK;\r\nscif_nodeqp_send(ep->remote_dev, msg);\r\nreturn;\r\n}\r\nmemcpy(&fence->msg, msg, sizeof(struct scifmsg));\r\nINIT_LIST_HEAD(&fence->list);\r\nmutex_lock(&scif_info.fencelock);\r\natomic_inc(&ep->rma_info.fence_refcount);\r\nlist_add_tail(&fence->list, &scif_info.fence);\r\nmutex_unlock(&scif_info.fencelock);\r\nschedule_work(&scif_info.misc_work);\r\n}\r\nvoid scif_recv_wait_resp(struct scif_dev *scifdev, struct scifmsg *msg)\r\n{\r\nstruct scif_endpt *ep = (struct scif_endpt *)msg->payload[0];\r\nstruct scif_fence_info *fence_req =\r\n(struct scif_fence_info *)msg->payload[1];\r\nmutex_lock(&ep->rma_info.rma_lock);\r\nif (msg->uop == SCIF_WAIT_ACK)\r\nfence_req->state = OP_COMPLETED;\r\nelse\r\nfence_req->state = OP_FAILED;\r\nmutex_unlock(&ep->rma_info.rma_lock);\r\ncomplete(&fence_req->comp);\r\n}\r\nvoid scif_recv_sig_local(struct scif_dev *scifdev, struct scifmsg *msg)\r\n{\r\nstruct scif_endpt *ep = (struct scif_endpt *)msg->payload[0];\r\nint err;\r\nerr = scif_prog_signal(ep, msg->payload[1], msg->payload[2],\r\nSCIF_WINDOW_SELF);\r\nif (err)\r\nmsg->uop = SCIF_SIG_NACK;\r\nelse\r\nmsg->uop = SCIF_SIG_ACK;\r\nmsg->payload[0] = ep->remote_ep;\r\nscif_nodeqp_send(ep->remote_dev, msg);\r\n}\r\nvoid scif_recv_sig_remote(struct scif_dev *scifdev, struct scifmsg *msg)\r\n{\r\nstruct scif_endpt *ep = (struct scif_endpt *)msg->payload[0];\r\nint err;\r\nerr = scif_prog_signal(ep, msg->payload[1], msg->payload[2],\r\nSCIF_WINDOW_PEER);\r\nif (err)\r\nmsg->uop = SCIF_SIG_NACK;\r\nelse\r\nmsg->uop = SCIF_SIG_ACK;\r\nmsg->payload[0] = ep->remote_ep;\r\nscif_nodeqp_send(ep->remote_dev, msg);\r\n}\r\nvoid scif_recv_sig_resp(struct scif_dev *scifdev, struct scifmsg *msg)\r\n{\r\nstruct scif_endpt *ep = (struct scif_endpt *)msg->payload[0];\r\nstruct scif_fence_info *fence_req =\r\n(struct scif_fence_info *)msg->payload[3];\r\nmutex_lock(&ep->rma_info.rma_lock);\r\nif (msg->uop == SCIF_SIG_ACK)\r\nfence_req->state = OP_COMPLETED;\r\nelse\r\nfence_req->state = OP_FAILED;\r\nmutex_unlock(&ep->rma_info.rma_lock);\r\ncomplete(&fence_req->comp);\r\n}\r\nstatic inline void *scif_get_local_va(off_t off, struct scif_window *window)\r\n{\r\nstruct page **pages = window->pinned_pages->pages;\r\nint page_nr = (off - window->offset) >> PAGE_SHIFT;\r\noff_t page_off = off & ~PAGE_MASK;\r\nreturn page_address(pages[page_nr]) + page_off;\r\n}\r\nstatic void scif_prog_signal_cb(void *arg)\r\n{\r\nstruct scif_status *status = arg;\r\ndma_pool_free(status->ep->remote_dev->signal_pool, status,\r\nstatus->src_dma_addr);\r\n}\r\nstatic int _scif_prog_signal(scif_epd_t epd, dma_addr_t dst, u64 val)\r\n{\r\nstruct scif_endpt *ep = (struct scif_endpt *)epd;\r\nstruct dma_chan *chan = ep->rma_info.dma_chan;\r\nstruct dma_device *ddev = chan->device;\r\nbool x100 = !is_dma_copy_aligned(chan->device, 1, 1, 1);\r\nstruct dma_async_tx_descriptor *tx;\r\nstruct scif_status *status = NULL;\r\ndma_addr_t src;\r\ndma_cookie_t cookie;\r\nint err;\r\ntx = ddev->device_prep_dma_memcpy(chan, 0, 0, 0, DMA_PREP_FENCE);\r\nif (!tx) {\r\nerr = -ENOMEM;\r\ndev_err(&ep->remote_dev->sdev->dev, "%s %d err %d\n",\r\n__func__, __LINE__, err);\r\ngoto alloc_fail;\r\n}\r\ncookie = tx->tx_submit(tx);\r\nif (dma_submit_error(cookie)) {\r\nerr = (int)cookie;\r\ndev_err(&ep->remote_dev->sdev->dev, "%s %d err %d\n",\r\n__func__, __LINE__, err);\r\ngoto alloc_fail;\r\n}\r\ndma_async_issue_pending(chan);\r\nif (x100) {\r\ntx = ddev->device_prep_dma_imm_data(chan, dst, val, 0);\r\n} else {\r\nstatus = dma_pool_alloc(ep->remote_dev->signal_pool, GFP_KERNEL,\r\n&src);\r\nif (!status) {\r\nerr = -ENOMEM;\r\ndev_err(&ep->remote_dev->sdev->dev, "%s %d err %d\n",\r\n__func__, __LINE__, err);\r\ngoto alloc_fail;\r\n}\r\nstatus->val = val;\r\nstatus->src_dma_addr = src;\r\nstatus->ep = ep;\r\nsrc += offsetof(struct scif_status, val);\r\ntx = ddev->device_prep_dma_memcpy(chan, dst, src, sizeof(val),\r\nDMA_PREP_INTERRUPT);\r\n}\r\nif (!tx) {\r\nerr = -ENOMEM;\r\ndev_err(&ep->remote_dev->sdev->dev, "%s %d err %d\n",\r\n__func__, __LINE__, err);\r\ngoto dma_fail;\r\n}\r\nif (!x100) {\r\ntx->callback = scif_prog_signal_cb;\r\ntx->callback_param = status;\r\n}\r\ncookie = tx->tx_submit(tx);\r\nif (dma_submit_error(cookie)) {\r\nerr = -EIO;\r\ndev_err(&ep->remote_dev->sdev->dev, "%s %d err %d\n",\r\n__func__, __LINE__, err);\r\ngoto dma_fail;\r\n}\r\ndma_async_issue_pending(chan);\r\nreturn 0;\r\ndma_fail:\r\nif (!x100)\r\ndma_pool_free(ep->remote_dev->signal_pool, status,\r\nstatus->src_dma_addr);\r\nalloc_fail:\r\nreturn err;\r\n}\r\nint scif_prog_signal(scif_epd_t epd, off_t offset, u64 val,\r\nenum scif_window_type type)\r\n{\r\nstruct scif_endpt *ep = (struct scif_endpt *)epd;\r\nstruct scif_window *window = NULL;\r\nstruct scif_rma_req req;\r\ndma_addr_t dst_dma_addr;\r\nint err;\r\nmutex_lock(&ep->rma_info.rma_lock);\r\nreq.out_window = &window;\r\nreq.offset = offset;\r\nreq.nr_bytes = sizeof(u64);\r\nreq.prot = SCIF_PROT_WRITE;\r\nreq.type = SCIF_WINDOW_SINGLE;\r\nif (type == SCIF_WINDOW_SELF)\r\nreq.head = &ep->rma_info.reg_list;\r\nelse\r\nreq.head = &ep->rma_info.remote_reg_list;\r\nerr = scif_query_window(&req);\r\nif (err) {\r\ndev_err(scif_info.mdev.this_device,\r\n"%s %d err %d\n", __func__, __LINE__, err);\r\ngoto unlock_ret;\r\n}\r\nif (scif_is_mgmt_node() && scifdev_self(ep->remote_dev)) {\r\nu64 *dst_virt;\r\nif (type == SCIF_WINDOW_SELF)\r\ndst_virt = scif_get_local_va(offset, window);\r\nelse\r\ndst_virt =\r\nscif_get_local_va(offset, (struct scif_window *)\r\nwindow->peer_window);\r\n*dst_virt = val;\r\n} else {\r\ndst_dma_addr = __scif_off_to_dma_addr(window, offset);\r\nerr = _scif_prog_signal(epd, dst_dma_addr, val);\r\n}\r\nunlock_ret:\r\nmutex_unlock(&ep->rma_info.rma_lock);\r\nreturn err;\r\n}\r\nstatic int _scif_fence_wait(scif_epd_t epd, int mark)\r\n{\r\nstruct scif_endpt *ep = (struct scif_endpt *)epd;\r\ndma_cookie_t cookie = mark & ~SCIF_REMOTE_FENCE;\r\nint err;\r\nerr = wait_event_interruptible_timeout(ep->rma_info.markwq,\r\ndma_async_is_tx_complete(\r\nep->rma_info.dma_chan,\r\ncookie, NULL, NULL) ==\r\nDMA_COMPLETE,\r\nSCIF_NODE_ALIVE_TIMEOUT);\r\nif (!err)\r\nerr = -ETIMEDOUT;\r\nelse if (err > 0)\r\nerr = 0;\r\nreturn err;\r\n}\r\nvoid scif_rma_handle_remote_fences(void)\r\n{\r\nstruct list_head *item, *tmp;\r\nstruct scif_remote_fence_info *fence;\r\nstruct scif_endpt *ep;\r\nint mark, err;\r\nmight_sleep();\r\nmutex_lock(&scif_info.fencelock);\r\nlist_for_each_safe(item, tmp, &scif_info.fence) {\r\nfence = list_entry(item, struct scif_remote_fence_info,\r\nlist);\r\nlist_del(&fence->list);\r\nep = (struct scif_endpt *)fence->msg.payload[0];\r\nmark = fence->msg.payload[2];\r\nerr = _scif_fence_wait(ep, mark);\r\nif (err)\r\nfence->msg.uop = SCIF_WAIT_NACK;\r\nelse\r\nfence->msg.uop = SCIF_WAIT_ACK;\r\nfence->msg.payload[0] = ep->remote_ep;\r\nscif_nodeqp_send(ep->remote_dev, &fence->msg);\r\nkfree(fence);\r\nif (!atomic_sub_return(1, &ep->rma_info.fence_refcount))\r\nschedule_work(&scif_info.misc_work);\r\n}\r\nmutex_unlock(&scif_info.fencelock);\r\n}\r\nstatic int _scif_send_fence(scif_epd_t epd, int uop, int mark, int *out_mark)\r\n{\r\nint err;\r\nstruct scifmsg msg;\r\nstruct scif_fence_info *fence_req;\r\nstruct scif_endpt *ep = (struct scif_endpt *)epd;\r\nfence_req = kmalloc(sizeof(*fence_req), GFP_KERNEL);\r\nif (!fence_req) {\r\nerr = -ENOMEM;\r\ngoto error;\r\n}\r\nfence_req->state = OP_IN_PROGRESS;\r\ninit_completion(&fence_req->comp);\r\nmsg.src = ep->port;\r\nmsg.uop = uop;\r\nmsg.payload[0] = ep->remote_ep;\r\nmsg.payload[1] = (u64)fence_req;\r\nif (uop == SCIF_WAIT)\r\nmsg.payload[2] = mark;\r\nspin_lock(&ep->lock);\r\nif (ep->state == SCIFEP_CONNECTED)\r\nerr = scif_nodeqp_send(ep->remote_dev, &msg);\r\nelse\r\nerr = -ENOTCONN;\r\nspin_unlock(&ep->lock);\r\nif (err)\r\ngoto error_free;\r\nretry:\r\nerr = wait_for_completion_timeout(&fence_req->comp,\r\nSCIF_NODE_ALIVE_TIMEOUT);\r\nif (!err && scifdev_alive(ep))\r\ngoto retry;\r\nif (!err)\r\nerr = -ENODEV;\r\nif (err > 0)\r\nerr = 0;\r\nmutex_lock(&ep->rma_info.rma_lock);\r\nif (err < 0) {\r\nif (fence_req->state == OP_IN_PROGRESS)\r\nfence_req->state = OP_FAILED;\r\n}\r\nif (fence_req->state == OP_FAILED && !err)\r\nerr = -ENOMEM;\r\nif (uop == SCIF_MARK && fence_req->state == OP_COMPLETED)\r\n*out_mark = SCIF_REMOTE_FENCE | fence_req->dma_mark;\r\nmutex_unlock(&ep->rma_info.rma_lock);\r\nerror_free:\r\nkfree(fence_req);\r\nerror:\r\nreturn err;\r\n}\r\nstatic int scif_send_fence_mark(scif_epd_t epd, int *out_mark)\r\n{\r\nreturn _scif_send_fence(epd, SCIF_MARK, 0, out_mark);\r\n}\r\nstatic int scif_send_fence_wait(scif_epd_t epd, int mark)\r\n{\r\nreturn _scif_send_fence(epd, SCIF_WAIT, mark, NULL);\r\n}\r\nstatic int _scif_send_fence_signal_wait(struct scif_endpt *ep,\r\nstruct scif_fence_info *fence_req)\r\n{\r\nint err;\r\nretry:\r\nerr = wait_for_completion_timeout(&fence_req->comp,\r\nSCIF_NODE_ALIVE_TIMEOUT);\r\nif (!err && scifdev_alive(ep))\r\ngoto retry;\r\nif (!err)\r\nerr = -ENODEV;\r\nif (err > 0)\r\nerr = 0;\r\nif (err < 0) {\r\nmutex_lock(&ep->rma_info.rma_lock);\r\nif (fence_req->state == OP_IN_PROGRESS)\r\nfence_req->state = OP_FAILED;\r\nmutex_unlock(&ep->rma_info.rma_lock);\r\n}\r\nif (fence_req->state == OP_FAILED && !err)\r\nerr = -ENXIO;\r\nreturn err;\r\n}\r\nstatic int scif_send_fence_signal(scif_epd_t epd, off_t roff, u64 rval,\r\noff_t loff, u64 lval, int flags)\r\n{\r\nint err = 0;\r\nstruct scifmsg msg;\r\nstruct scif_fence_info *fence_req;\r\nstruct scif_endpt *ep = (struct scif_endpt *)epd;\r\nfence_req = kmalloc(sizeof(*fence_req), GFP_KERNEL);\r\nif (!fence_req) {\r\nerr = -ENOMEM;\r\ngoto error;\r\n}\r\nfence_req->state = OP_IN_PROGRESS;\r\ninit_completion(&fence_req->comp);\r\nmsg.src = ep->port;\r\nif (flags & SCIF_SIGNAL_LOCAL) {\r\nmsg.uop = SCIF_SIG_LOCAL;\r\nmsg.payload[0] = ep->remote_ep;\r\nmsg.payload[1] = roff;\r\nmsg.payload[2] = rval;\r\nmsg.payload[3] = (u64)fence_req;\r\nspin_lock(&ep->lock);\r\nif (ep->state == SCIFEP_CONNECTED)\r\nerr = scif_nodeqp_send(ep->remote_dev, &msg);\r\nelse\r\nerr = -ENOTCONN;\r\nspin_unlock(&ep->lock);\r\nif (err)\r\ngoto error_free;\r\nerr = _scif_send_fence_signal_wait(ep, fence_req);\r\nif (err)\r\ngoto error_free;\r\n}\r\nfence_req->state = OP_IN_PROGRESS;\r\nif (flags & SCIF_SIGNAL_REMOTE) {\r\nmsg.uop = SCIF_SIG_REMOTE;\r\nmsg.payload[0] = ep->remote_ep;\r\nmsg.payload[1] = loff;\r\nmsg.payload[2] = lval;\r\nmsg.payload[3] = (u64)fence_req;\r\nspin_lock(&ep->lock);\r\nif (ep->state == SCIFEP_CONNECTED)\r\nerr = scif_nodeqp_send(ep->remote_dev, &msg);\r\nelse\r\nerr = -ENOTCONN;\r\nspin_unlock(&ep->lock);\r\nif (err)\r\ngoto error_free;\r\nerr = _scif_send_fence_signal_wait(ep, fence_req);\r\n}\r\nerror_free:\r\nkfree(fence_req);\r\nerror:\r\nreturn err;\r\n}\r\nstatic void scif_fence_mark_cb(void *arg)\r\n{\r\nstruct scif_endpt *ep = (struct scif_endpt *)arg;\r\nwake_up_interruptible(&ep->rma_info.markwq);\r\natomic_dec(&ep->rma_info.fence_refcount);\r\n}\r\nint _scif_fence_mark(scif_epd_t epd, int *mark)\r\n{\r\nstruct scif_endpt *ep = (struct scif_endpt *)epd;\r\nstruct dma_chan *chan = ep->rma_info.dma_chan;\r\nstruct dma_device *ddev = chan->device;\r\nstruct dma_async_tx_descriptor *tx;\r\ndma_cookie_t cookie;\r\nint err;\r\ntx = ddev->device_prep_dma_memcpy(chan, 0, 0, 0, DMA_PREP_FENCE);\r\nif (!tx) {\r\nerr = -ENOMEM;\r\ndev_err(&ep->remote_dev->sdev->dev, "%s %d err %d\n",\r\n__func__, __LINE__, err);\r\nreturn err;\r\n}\r\ncookie = tx->tx_submit(tx);\r\nif (dma_submit_error(cookie)) {\r\nerr = (int)cookie;\r\ndev_err(&ep->remote_dev->sdev->dev, "%s %d err %d\n",\r\n__func__, __LINE__, err);\r\nreturn err;\r\n}\r\ndma_async_issue_pending(chan);\r\ntx = ddev->device_prep_dma_interrupt(chan, DMA_PREP_INTERRUPT);\r\nif (!tx) {\r\nerr = -ENOMEM;\r\ndev_err(&ep->remote_dev->sdev->dev, "%s %d err %d\n",\r\n__func__, __LINE__, err);\r\nreturn err;\r\n}\r\ntx->callback = scif_fence_mark_cb;\r\ntx->callback_param = ep;\r\n*mark = cookie = tx->tx_submit(tx);\r\nif (dma_submit_error(cookie)) {\r\nerr = (int)cookie;\r\ndev_err(&ep->remote_dev->sdev->dev, "%s %d err %d\n",\r\n__func__, __LINE__, err);\r\nreturn err;\r\n}\r\natomic_inc(&ep->rma_info.fence_refcount);\r\ndma_async_issue_pending(chan);\r\nreturn 0;\r\n}\r\nint scif_fence_mark(scif_epd_t epd, int flags, int *mark)\r\n{\r\nstruct scif_endpt *ep = (struct scif_endpt *)epd;\r\nint err = 0;\r\ndev_dbg(scif_info.mdev.this_device,\r\n"SCIFAPI fence_mark: ep %p flags 0x%x mark 0x%x\n",\r\nep, flags, *mark);\r\nerr = scif_verify_epd(ep);\r\nif (err)\r\nreturn err;\r\nif (flags & ~(SCIF_FENCE_INIT_SELF | SCIF_FENCE_INIT_PEER))\r\nreturn -EINVAL;\r\nif (!(flags & (SCIF_FENCE_INIT_SELF | SCIF_FENCE_INIT_PEER)))\r\nreturn -EINVAL;\r\nif ((flags & SCIF_FENCE_INIT_SELF) && (flags & SCIF_FENCE_INIT_PEER))\r\nreturn -EINVAL;\r\nif (scifdev_self(ep->remote_dev) && scif_is_mgmt_node()) {\r\n*mark = SCIF_LOOPB_MAGIC_MARK;\r\nreturn 0;\r\n}\r\nif (flags & SCIF_FENCE_INIT_SELF)\r\nerr = _scif_fence_mark(epd, mark);\r\nelse\r\nerr = scif_send_fence_mark(ep, mark);\r\nif (err)\r\ndev_err(scif_info.mdev.this_device,\r\n"%s %d err %d\n", __func__, __LINE__, err);\r\ndev_dbg(scif_info.mdev.this_device,\r\n"SCIFAPI fence_mark: ep %p flags 0x%x mark 0x%x err %d\n",\r\nep, flags, *mark, err);\r\nreturn err;\r\n}\r\nint scif_fence_wait(scif_epd_t epd, int mark)\r\n{\r\nstruct scif_endpt *ep = (struct scif_endpt *)epd;\r\nint err = 0;\r\ndev_dbg(scif_info.mdev.this_device,\r\n"SCIFAPI fence_wait: ep %p mark 0x%x\n",\r\nep, mark);\r\nerr = scif_verify_epd(ep);\r\nif (err)\r\nreturn err;\r\nif (scifdev_self(ep->remote_dev) && scif_is_mgmt_node()) {\r\nif (mark == SCIF_LOOPB_MAGIC_MARK)\r\nreturn 0;\r\nelse\r\nreturn -EINVAL;\r\n}\r\nif (mark & SCIF_REMOTE_FENCE)\r\nerr = scif_send_fence_wait(epd, mark);\r\nelse\r\nerr = _scif_fence_wait(epd, mark);\r\nif (err < 0)\r\ndev_err(scif_info.mdev.this_device,\r\n"%s %d err %d\n", __func__, __LINE__, err);\r\nreturn err;\r\n}\r\nint scif_fence_signal(scif_epd_t epd, off_t loff, u64 lval,\r\noff_t roff, u64 rval, int flags)\r\n{\r\nstruct scif_endpt *ep = (struct scif_endpt *)epd;\r\nint err = 0;\r\ndev_dbg(scif_info.mdev.this_device,\r\n"SCIFAPI fence_signal: ep %p loff 0x%lx lval 0x%llx roff 0x%lx rval 0x%llx flags 0x%x\n",\r\nep, loff, lval, roff, rval, flags);\r\nerr = scif_verify_epd(ep);\r\nif (err)\r\nreturn err;\r\nif (flags & ~(SCIF_FENCE_INIT_SELF | SCIF_FENCE_INIT_PEER |\r\nSCIF_SIGNAL_LOCAL | SCIF_SIGNAL_REMOTE))\r\nreturn -EINVAL;\r\nif (!(flags & (SCIF_FENCE_INIT_SELF | SCIF_FENCE_INIT_PEER)))\r\nreturn -EINVAL;\r\nif ((flags & SCIF_FENCE_INIT_SELF) && (flags & SCIF_FENCE_INIT_PEER))\r\nreturn -EINVAL;\r\nif (!(flags & (SCIF_SIGNAL_LOCAL | SCIF_SIGNAL_REMOTE)))\r\nreturn -EINVAL;\r\nif ((flags & SCIF_SIGNAL_LOCAL) && (loff & (sizeof(u32) - 1)))\r\nreturn -EINVAL;\r\nif ((flags & SCIF_SIGNAL_REMOTE) && (roff & (sizeof(u32) - 1)))\r\nreturn -EINVAL;\r\nif (flags & SCIF_FENCE_INIT_PEER) {\r\nerr = scif_send_fence_signal(epd, roff, rval, loff,\r\nlval, flags);\r\n} else {\r\nif (flags & SCIF_SIGNAL_LOCAL) {\r\nerr = scif_prog_signal(epd, loff, lval,\r\nSCIF_WINDOW_SELF);\r\nif (err)\r\ngoto error_ret;\r\n}\r\nif (flags & SCIF_SIGNAL_REMOTE)\r\nerr = scif_prog_signal(epd, roff,\r\nrval, SCIF_WINDOW_PEER);\r\n}\r\nerror_ret:\r\nif (err)\r\ndev_err(scif_info.mdev.this_device,\r\n"%s %d err %d\n", __func__, __LINE__, err);\r\nreturn err;\r\n}
