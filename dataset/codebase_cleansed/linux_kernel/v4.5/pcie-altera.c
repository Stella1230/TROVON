static void altera_pcie_retrain(struct pci_dev *dev)\r\n{\r\nu16 linkcap, linkstat;\r\npcie_capability_read_word(dev, PCI_EXP_LNKCAP, &linkcap);\r\nif ((linkcap & PCI_EXP_LNKCAP_SLS) <= PCI_EXP_LNKCAP_SLS_2_5GB)\r\nreturn;\r\npcie_capability_read_word(dev, PCI_EXP_LNKSTA, &linkstat);\r\nif ((linkstat & PCI_EXP_LNKSTA_CLS) == PCI_EXP_LNKSTA_CLS_2_5GB)\r\npcie_capability_set_word(dev, PCI_EXP_LNKCTL,\r\nPCI_EXP_LNKCTL_RL);\r\n}\r\nstatic bool altera_pcie_hide_rc_bar(struct pci_bus *bus, unsigned int devfn,\r\nint offset)\r\n{\r\nif (pci_is_root_bus(bus) && (devfn == 0) &&\r\n(offset == PCI_BASE_ADDRESS_0))\r\nreturn true;\r\nreturn false;\r\n}\r\nstatic inline void cra_writel(struct altera_pcie *pcie, const u32 value,\r\nconst u32 reg)\r\n{\r\nwritel_relaxed(value, pcie->cra_base + reg);\r\n}\r\nstatic inline u32 cra_readl(struct altera_pcie *pcie, const u32 reg)\r\n{\r\nreturn readl_relaxed(pcie->cra_base + reg);\r\n}\r\nstatic void tlp_write_tx(struct altera_pcie *pcie,\r\nstruct tlp_rp_regpair_t *tlp_rp_regdata)\r\n{\r\ncra_writel(pcie, tlp_rp_regdata->reg0, RP_TX_REG0);\r\ncra_writel(pcie, tlp_rp_regdata->reg1, RP_TX_REG1);\r\ncra_writel(pcie, tlp_rp_regdata->ctrl, RP_TX_CNTRL);\r\n}\r\nstatic bool altera_pcie_link_is_up(struct altera_pcie *pcie)\r\n{\r\nreturn !!(cra_readl(pcie, RP_LTSSM) & LTSSM_L0);\r\n}\r\nstatic bool altera_pcie_valid_config(struct altera_pcie *pcie,\r\nstruct pci_bus *bus, int dev)\r\n{\r\nif (bus->number != pcie->root_bus_nr) {\r\nif (!altera_pcie_link_is_up(pcie))\r\nreturn false;\r\n}\r\nif (bus->number == pcie->root_bus_nr && dev > 0)\r\nreturn false;\r\nif (bus->primary == pcie->root_bus_nr && dev > 0)\r\nreturn false;\r\nreturn true;\r\n}\r\nstatic int tlp_read_packet(struct altera_pcie *pcie, u32 *value)\r\n{\r\nint i;\r\nbool sop = 0;\r\nu32 ctrl;\r\nu32 reg0, reg1;\r\nu32 comp_status = 1;\r\nfor (i = 0; i < TLP_LOOP; i++) {\r\nctrl = cra_readl(pcie, RP_RXCPL_STATUS);\r\nif ((ctrl & RP_RXCPL_SOP) || (ctrl & RP_RXCPL_EOP) || sop) {\r\nreg0 = cra_readl(pcie, RP_RXCPL_REG0);\r\nreg1 = cra_readl(pcie, RP_RXCPL_REG1);\r\nif (ctrl & RP_RXCPL_SOP) {\r\nsop = true;\r\ncomp_status = TLP_COMP_STATUS(reg1);\r\n}\r\nif (ctrl & RP_RXCPL_EOP) {\r\nif (comp_status)\r\nreturn PCIBIOS_DEVICE_NOT_FOUND;\r\nif (value)\r\n*value = reg0;\r\nreturn PCIBIOS_SUCCESSFUL;\r\n}\r\n}\r\nudelay(5);\r\n}\r\nreturn PCIBIOS_DEVICE_NOT_FOUND;\r\n}\r\nstatic void tlp_write_packet(struct altera_pcie *pcie, u32 *headers,\r\nu32 data, bool align)\r\n{\r\nstruct tlp_rp_regpair_t tlp_rp_regdata;\r\ntlp_rp_regdata.reg0 = headers[0];\r\ntlp_rp_regdata.reg1 = headers[1];\r\ntlp_rp_regdata.ctrl = RP_TX_SOP;\r\ntlp_write_tx(pcie, &tlp_rp_regdata);\r\nif (align) {\r\ntlp_rp_regdata.reg0 = headers[2];\r\ntlp_rp_regdata.reg1 = 0;\r\ntlp_rp_regdata.ctrl = 0;\r\ntlp_write_tx(pcie, &tlp_rp_regdata);\r\ntlp_rp_regdata.reg0 = data;\r\ntlp_rp_regdata.reg1 = 0;\r\n} else {\r\ntlp_rp_regdata.reg0 = headers[2];\r\ntlp_rp_regdata.reg1 = data;\r\n}\r\ntlp_rp_regdata.ctrl = RP_TX_EOP;\r\ntlp_write_tx(pcie, &tlp_rp_regdata);\r\n}\r\nstatic int tlp_cfg_dword_read(struct altera_pcie *pcie, u8 bus, u32 devfn,\r\nint where, u8 byte_en, u32 *value)\r\n{\r\nu32 headers[TLP_HDR_SIZE];\r\nif (bus == pcie->root_bus_nr)\r\nheaders[0] = TLP_CFG_DW0(TLP_FMTTYPE_CFGRD0);\r\nelse\r\nheaders[0] = TLP_CFG_DW0(TLP_FMTTYPE_CFGRD1);\r\nheaders[1] = TLP_CFG_DW1(TLP_REQ_ID(pcie->root_bus_nr, RP_DEVFN),\r\nTLP_READ_TAG, byte_en);\r\nheaders[2] = TLP_CFG_DW2(bus, devfn, where);\r\ntlp_write_packet(pcie, headers, 0, false);\r\nreturn tlp_read_packet(pcie, value);\r\n}\r\nstatic int tlp_cfg_dword_write(struct altera_pcie *pcie, u8 bus, u32 devfn,\r\nint where, u8 byte_en, u32 value)\r\n{\r\nu32 headers[TLP_HDR_SIZE];\r\nint ret;\r\nif (bus == pcie->root_bus_nr)\r\nheaders[0] = TLP_CFG_DW0(TLP_FMTTYPE_CFGWR0);\r\nelse\r\nheaders[0] = TLP_CFG_DW0(TLP_FMTTYPE_CFGWR1);\r\nheaders[1] = TLP_CFG_DW1(TLP_REQ_ID(pcie->root_bus_nr, RP_DEVFN),\r\nTLP_WRITE_TAG, byte_en);\r\nheaders[2] = TLP_CFG_DW2(bus, devfn, where);\r\nif ((where & 0x7) == 0)\r\ntlp_write_packet(pcie, headers, value, true);\r\nelse\r\ntlp_write_packet(pcie, headers, value, false);\r\nret = tlp_read_packet(pcie, NULL);\r\nif (ret != PCIBIOS_SUCCESSFUL)\r\nreturn ret;\r\nif ((bus == pcie->root_bus_nr) && (where == PCI_PRIMARY_BUS))\r\npcie->root_bus_nr = (u8)(value);\r\nreturn PCIBIOS_SUCCESSFUL;\r\n}\r\nstatic int altera_pcie_cfg_read(struct pci_bus *bus, unsigned int devfn,\r\nint where, int size, u32 *value)\r\n{\r\nstruct altera_pcie *pcie = bus->sysdata;\r\nint ret;\r\nu32 data;\r\nu8 byte_en;\r\nif (altera_pcie_hide_rc_bar(bus, devfn, where))\r\nreturn PCIBIOS_BAD_REGISTER_NUMBER;\r\nif (!altera_pcie_valid_config(pcie, bus, PCI_SLOT(devfn))) {\r\n*value = 0xffffffff;\r\nreturn PCIBIOS_DEVICE_NOT_FOUND;\r\n}\r\nswitch (size) {\r\ncase 1:\r\nbyte_en = 1 << (where & 3);\r\nbreak;\r\ncase 2:\r\nbyte_en = 3 << (where & 3);\r\nbreak;\r\ndefault:\r\nbyte_en = 0xf;\r\nbreak;\r\n}\r\nret = tlp_cfg_dword_read(pcie, bus->number, devfn,\r\n(where & ~DWORD_MASK), byte_en, &data);\r\nif (ret != PCIBIOS_SUCCESSFUL)\r\nreturn ret;\r\nswitch (size) {\r\ncase 1:\r\n*value = (data >> (8 * (where & 0x3))) & 0xff;\r\nbreak;\r\ncase 2:\r\n*value = (data >> (8 * (where & 0x2))) & 0xffff;\r\nbreak;\r\ndefault:\r\n*value = data;\r\nbreak;\r\n}\r\nreturn PCIBIOS_SUCCESSFUL;\r\n}\r\nstatic int altera_pcie_cfg_write(struct pci_bus *bus, unsigned int devfn,\r\nint where, int size, u32 value)\r\n{\r\nstruct altera_pcie *pcie = bus->sysdata;\r\nu32 data32;\r\nu32 shift = 8 * (where & 3);\r\nu8 byte_en;\r\nif (altera_pcie_hide_rc_bar(bus, devfn, where))\r\nreturn PCIBIOS_BAD_REGISTER_NUMBER;\r\nif (!altera_pcie_valid_config(pcie, bus, PCI_SLOT(devfn)))\r\nreturn PCIBIOS_DEVICE_NOT_FOUND;\r\nswitch (size) {\r\ncase 1:\r\ndata32 = (value & 0xff) << shift;\r\nbyte_en = 1 << (where & 3);\r\nbreak;\r\ncase 2:\r\ndata32 = (value & 0xffff) << shift;\r\nbyte_en = 3 << (where & 3);\r\nbreak;\r\ndefault:\r\ndata32 = value;\r\nbyte_en = 0xf;\r\nbreak;\r\n}\r\nreturn tlp_cfg_dword_write(pcie, bus->number, devfn,\r\n(where & ~DWORD_MASK), byte_en, data32);\r\n}\r\nstatic int altera_pcie_intx_map(struct irq_domain *domain, unsigned int irq,\r\nirq_hw_number_t hwirq)\r\n{\r\nirq_set_chip_and_handler(irq, &dummy_irq_chip, handle_simple_irq);\r\nirq_set_chip_data(irq, domain->host_data);\r\nreturn 0;\r\n}\r\nstatic void altera_pcie_isr(struct irq_desc *desc)\r\n{\r\nstruct irq_chip *chip = irq_desc_get_chip(desc);\r\nstruct altera_pcie *pcie;\r\nunsigned long status;\r\nu32 bit;\r\nu32 virq;\r\nchained_irq_enter(chip, desc);\r\npcie = irq_desc_get_handler_data(desc);\r\nwhile ((status = cra_readl(pcie, P2A_INT_STATUS)\r\n& P2A_INT_STS_ALL) != 0) {\r\nfor_each_set_bit(bit, &status, INTX_NUM) {\r\ncra_writel(pcie, 1 << bit, P2A_INT_STATUS);\r\nvirq = irq_find_mapping(pcie->irq_domain, bit + 1);\r\nif (virq)\r\ngeneric_handle_irq(virq);\r\nelse\r\ndev_err(&pcie->pdev->dev,\r\n"unexpected IRQ, INT%d\n", bit);\r\n}\r\n}\r\nchained_irq_exit(chip, desc);\r\n}\r\nstatic void altera_pcie_release_of_pci_ranges(struct altera_pcie *pcie)\r\n{\r\npci_free_resource_list(&pcie->resources);\r\n}\r\nstatic int altera_pcie_parse_request_of_pci_ranges(struct altera_pcie *pcie)\r\n{\r\nint err, res_valid = 0;\r\nstruct device *dev = &pcie->pdev->dev;\r\nstruct device_node *np = dev->of_node;\r\nstruct resource_entry *win;\r\nerr = of_pci_get_host_bridge_resources(np, 0, 0xff, &pcie->resources,\r\nNULL);\r\nif (err)\r\nreturn err;\r\nresource_list_for_each_entry(win, &pcie->resources) {\r\nstruct resource *parent, *res = win->res;\r\nswitch (resource_type(res)) {\r\ncase IORESOURCE_MEM:\r\nparent = &iomem_resource;\r\nres_valid |= !(res->flags & IORESOURCE_PREFETCH);\r\nbreak;\r\ndefault:\r\ncontinue;\r\n}\r\nerr = devm_request_resource(dev, parent, res);\r\nif (err)\r\ngoto out_release_res;\r\n}\r\nif (!res_valid) {\r\ndev_err(dev, "non-prefetchable memory resource required\n");\r\nerr = -EINVAL;\r\ngoto out_release_res;\r\n}\r\nreturn 0;\r\nout_release_res:\r\naltera_pcie_release_of_pci_ranges(pcie);\r\nreturn err;\r\n}\r\nstatic int altera_pcie_init_irq_domain(struct altera_pcie *pcie)\r\n{\r\nstruct device *dev = &pcie->pdev->dev;\r\nstruct device_node *node = dev->of_node;\r\npcie->irq_domain = irq_domain_add_linear(node, INTX_NUM + 1,\r\n&intx_domain_ops, pcie);\r\nif (!pcie->irq_domain) {\r\ndev_err(dev, "Failed to get a INTx IRQ domain\n");\r\nreturn -ENOMEM;\r\n}\r\nreturn 0;\r\n}\r\nstatic int altera_pcie_parse_dt(struct altera_pcie *pcie)\r\n{\r\nstruct resource *cra;\r\nstruct platform_device *pdev = pcie->pdev;\r\ncra = platform_get_resource_byname(pdev, IORESOURCE_MEM, "Cra");\r\nif (!cra) {\r\ndev_err(&pdev->dev, "no Cra memory resource defined\n");\r\nreturn -ENODEV;\r\n}\r\npcie->cra_base = devm_ioremap_resource(&pdev->dev, cra);\r\nif (IS_ERR(pcie->cra_base)) {\r\ndev_err(&pdev->dev, "failed to map cra memory\n");\r\nreturn PTR_ERR(pcie->cra_base);\r\n}\r\npcie->irq = platform_get_irq(pdev, 0);\r\nif (pcie->irq <= 0) {\r\ndev_err(&pdev->dev, "failed to get IRQ: %d\n", pcie->irq);\r\nreturn -EINVAL;\r\n}\r\nirq_set_chained_handler_and_data(pcie->irq, altera_pcie_isr, pcie);\r\nreturn 0;\r\n}\r\nstatic int altera_pcie_probe(struct platform_device *pdev)\r\n{\r\nstruct altera_pcie *pcie;\r\nstruct pci_bus *bus;\r\nstruct pci_bus *child;\r\nint ret;\r\npcie = devm_kzalloc(&pdev->dev, sizeof(*pcie), GFP_KERNEL);\r\nif (!pcie)\r\nreturn -ENOMEM;\r\npcie->pdev = pdev;\r\nret = altera_pcie_parse_dt(pcie);\r\nif (ret) {\r\ndev_err(&pdev->dev, "Parsing DT failed\n");\r\nreturn ret;\r\n}\r\nINIT_LIST_HEAD(&pcie->resources);\r\nret = altera_pcie_parse_request_of_pci_ranges(pcie);\r\nif (ret) {\r\ndev_err(&pdev->dev, "Failed add resources\n");\r\nreturn ret;\r\n}\r\nret = altera_pcie_init_irq_domain(pcie);\r\nif (ret) {\r\ndev_err(&pdev->dev, "Failed creating IRQ Domain\n");\r\nreturn ret;\r\n}\r\ncra_writel(pcie, P2A_INT_STS_ALL, P2A_INT_STATUS);\r\ncra_writel(pcie, P2A_INT_ENA_ALL, P2A_INT_ENABLE);\r\nbus = pci_scan_root_bus(&pdev->dev, pcie->root_bus_nr, &altera_pcie_ops,\r\npcie, &pcie->resources);\r\nif (!bus)\r\nreturn -ENOMEM;\r\npci_fixup_irqs(pci_common_swizzle, of_irq_parse_and_map_pci);\r\npci_assign_unassigned_bus_resources(bus);\r\nlist_for_each_entry(child, &bus->children, node)\r\npcie_bus_configure_settings(child);\r\npci_bus_add_devices(bus);\r\nplatform_set_drvdata(pdev, pcie);\r\nreturn ret;\r\n}\r\nstatic int altera_pcie_init(void)\r\n{\r\nreturn platform_driver_register(&altera_pcie_driver);\r\n}
