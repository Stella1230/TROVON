static void authenc_request_complete(struct aead_request *req, int err)\r\n{\r\nif (err != -EINPROGRESS)\r\naead_request_complete(req, err);\r\n}\r\nint crypto_authenc_extractkeys(struct crypto_authenc_keys *keys, const u8 *key,\r\nunsigned int keylen)\r\n{\r\nstruct rtattr *rta = (struct rtattr *)key;\r\nstruct crypto_authenc_key_param *param;\r\nif (!RTA_OK(rta, keylen))\r\nreturn -EINVAL;\r\nif (rta->rta_type != CRYPTO_AUTHENC_KEYA_PARAM)\r\nreturn -EINVAL;\r\nif (RTA_PAYLOAD(rta) < sizeof(*param))\r\nreturn -EINVAL;\r\nparam = RTA_DATA(rta);\r\nkeys->enckeylen = be32_to_cpu(param->enckeylen);\r\nkey += RTA_ALIGN(rta->rta_len);\r\nkeylen -= RTA_ALIGN(rta->rta_len);\r\nif (keylen < keys->enckeylen)\r\nreturn -EINVAL;\r\nkeys->authkeylen = keylen - keys->enckeylen;\r\nkeys->authkey = key;\r\nkeys->enckey = key + keys->authkeylen;\r\nreturn 0;\r\n}\r\nstatic int crypto_authenc_setkey(struct crypto_aead *authenc, const u8 *key,\r\nunsigned int keylen)\r\n{\r\nstruct crypto_authenc_ctx *ctx = crypto_aead_ctx(authenc);\r\nstruct crypto_ahash *auth = ctx->auth;\r\nstruct crypto_ablkcipher *enc = ctx->enc;\r\nstruct crypto_authenc_keys keys;\r\nint err = -EINVAL;\r\nif (crypto_authenc_extractkeys(&keys, key, keylen) != 0)\r\ngoto badkey;\r\ncrypto_ahash_clear_flags(auth, CRYPTO_TFM_REQ_MASK);\r\ncrypto_ahash_set_flags(auth, crypto_aead_get_flags(authenc) &\r\nCRYPTO_TFM_REQ_MASK);\r\nerr = crypto_ahash_setkey(auth, keys.authkey, keys.authkeylen);\r\ncrypto_aead_set_flags(authenc, crypto_ahash_get_flags(auth) &\r\nCRYPTO_TFM_RES_MASK);\r\nif (err)\r\ngoto out;\r\ncrypto_ablkcipher_clear_flags(enc, CRYPTO_TFM_REQ_MASK);\r\ncrypto_ablkcipher_set_flags(enc, crypto_aead_get_flags(authenc) &\r\nCRYPTO_TFM_REQ_MASK);\r\nerr = crypto_ablkcipher_setkey(enc, keys.enckey, keys.enckeylen);\r\ncrypto_aead_set_flags(authenc, crypto_ablkcipher_get_flags(enc) &\r\nCRYPTO_TFM_RES_MASK);\r\nout:\r\nreturn err;\r\nbadkey:\r\ncrypto_aead_set_flags(authenc, CRYPTO_TFM_RES_BAD_KEY_LEN);\r\ngoto out;\r\n}\r\nstatic void authenc_geniv_ahash_done(struct crypto_async_request *areq, int err)\r\n{\r\nstruct aead_request *req = areq->data;\r\nstruct crypto_aead *authenc = crypto_aead_reqtfm(req);\r\nstruct aead_instance *inst = aead_alg_instance(authenc);\r\nstruct authenc_instance_ctx *ictx = aead_instance_ctx(inst);\r\nstruct authenc_request_ctx *areq_ctx = aead_request_ctx(req);\r\nstruct ahash_request *ahreq = (void *)(areq_ctx->tail + ictx->reqoff);\r\nif (err)\r\ngoto out;\r\nscatterwalk_map_and_copy(ahreq->result, req->dst,\r\nreq->assoclen + req->cryptlen,\r\ncrypto_aead_authsize(authenc), 1);\r\nout:\r\naead_request_complete(req, err);\r\n}\r\nstatic int crypto_authenc_genicv(struct aead_request *req, unsigned int flags)\r\n{\r\nstruct crypto_aead *authenc = crypto_aead_reqtfm(req);\r\nstruct aead_instance *inst = aead_alg_instance(authenc);\r\nstruct crypto_authenc_ctx *ctx = crypto_aead_ctx(authenc);\r\nstruct authenc_instance_ctx *ictx = aead_instance_ctx(inst);\r\nstruct crypto_ahash *auth = ctx->auth;\r\nstruct authenc_request_ctx *areq_ctx = aead_request_ctx(req);\r\nstruct ahash_request *ahreq = (void *)(areq_ctx->tail + ictx->reqoff);\r\nu8 *hash = areq_ctx->tail;\r\nint err;\r\nhash = (u8 *)ALIGN((unsigned long)hash + crypto_ahash_alignmask(auth),\r\ncrypto_ahash_alignmask(auth) + 1);\r\nahash_request_set_tfm(ahreq, auth);\r\nahash_request_set_crypt(ahreq, req->dst, hash,\r\nreq->assoclen + req->cryptlen);\r\nahash_request_set_callback(ahreq, flags,\r\nauthenc_geniv_ahash_done, req);\r\nerr = crypto_ahash_digest(ahreq);\r\nif (err)\r\nreturn err;\r\nscatterwalk_map_and_copy(hash, req->dst, req->assoclen + req->cryptlen,\r\ncrypto_aead_authsize(authenc), 1);\r\nreturn 0;\r\n}\r\nstatic void crypto_authenc_encrypt_done(struct crypto_async_request *req,\r\nint err)\r\n{\r\nstruct aead_request *areq = req->data;\r\nif (err)\r\ngoto out;\r\nerr = crypto_authenc_genicv(areq, 0);\r\nout:\r\nauthenc_request_complete(areq, err);\r\n}\r\nstatic int crypto_authenc_copy_assoc(struct aead_request *req)\r\n{\r\nstruct crypto_aead *authenc = crypto_aead_reqtfm(req);\r\nstruct crypto_authenc_ctx *ctx = crypto_aead_ctx(authenc);\r\nstruct blkcipher_desc desc = {\r\n.tfm = ctx->null,\r\n};\r\nreturn crypto_blkcipher_encrypt(&desc, req->dst, req->src,\r\nreq->assoclen);\r\n}\r\nstatic int crypto_authenc_encrypt(struct aead_request *req)\r\n{\r\nstruct crypto_aead *authenc = crypto_aead_reqtfm(req);\r\nstruct aead_instance *inst = aead_alg_instance(authenc);\r\nstruct crypto_authenc_ctx *ctx = crypto_aead_ctx(authenc);\r\nstruct authenc_instance_ctx *ictx = aead_instance_ctx(inst);\r\nstruct authenc_request_ctx *areq_ctx = aead_request_ctx(req);\r\nstruct crypto_ablkcipher *enc = ctx->enc;\r\nunsigned int cryptlen = req->cryptlen;\r\nstruct ablkcipher_request *abreq = (void *)(areq_ctx->tail +\r\nictx->reqoff);\r\nstruct scatterlist *src, *dst;\r\nint err;\r\nsg_init_table(areq_ctx->src, 2);\r\nsrc = scatterwalk_ffwd(areq_ctx->src, req->src, req->assoclen);\r\ndst = src;\r\nif (req->src != req->dst) {\r\nerr = crypto_authenc_copy_assoc(req);\r\nif (err)\r\nreturn err;\r\nsg_init_table(areq_ctx->dst, 2);\r\ndst = scatterwalk_ffwd(areq_ctx->dst, req->dst, req->assoclen);\r\n}\r\nablkcipher_request_set_tfm(abreq, enc);\r\nablkcipher_request_set_callback(abreq, aead_request_flags(req),\r\ncrypto_authenc_encrypt_done, req);\r\nablkcipher_request_set_crypt(abreq, src, dst, cryptlen, req->iv);\r\nerr = crypto_ablkcipher_encrypt(abreq);\r\nif (err)\r\nreturn err;\r\nreturn crypto_authenc_genicv(req, aead_request_flags(req));\r\n}\r\nstatic int crypto_authenc_decrypt_tail(struct aead_request *req,\r\nunsigned int flags)\r\n{\r\nstruct crypto_aead *authenc = crypto_aead_reqtfm(req);\r\nstruct aead_instance *inst = aead_alg_instance(authenc);\r\nstruct crypto_authenc_ctx *ctx = crypto_aead_ctx(authenc);\r\nstruct authenc_instance_ctx *ictx = aead_instance_ctx(inst);\r\nstruct authenc_request_ctx *areq_ctx = aead_request_ctx(req);\r\nstruct ahash_request *ahreq = (void *)(areq_ctx->tail + ictx->reqoff);\r\nstruct ablkcipher_request *abreq = (void *)(areq_ctx->tail +\r\nictx->reqoff);\r\nunsigned int authsize = crypto_aead_authsize(authenc);\r\nu8 *ihash = ahreq->result + authsize;\r\nstruct scatterlist *src, *dst;\r\nscatterwalk_map_and_copy(ihash, req->src, ahreq->nbytes, authsize, 0);\r\nif (crypto_memneq(ihash, ahreq->result, authsize))\r\nreturn -EBADMSG;\r\nsg_init_table(areq_ctx->src, 2);\r\nsrc = scatterwalk_ffwd(areq_ctx->src, req->src, req->assoclen);\r\ndst = src;\r\nif (req->src != req->dst) {\r\nsg_init_table(areq_ctx->dst, 2);\r\ndst = scatterwalk_ffwd(areq_ctx->dst, req->dst, req->assoclen);\r\n}\r\nablkcipher_request_set_tfm(abreq, ctx->enc);\r\nablkcipher_request_set_callback(abreq, aead_request_flags(req),\r\nreq->base.complete, req->base.data);\r\nablkcipher_request_set_crypt(abreq, src, dst,\r\nreq->cryptlen - authsize, req->iv);\r\nreturn crypto_ablkcipher_decrypt(abreq);\r\n}\r\nstatic void authenc_verify_ahash_done(struct crypto_async_request *areq,\r\nint err)\r\n{\r\nstruct aead_request *req = areq->data;\r\nif (err)\r\ngoto out;\r\nerr = crypto_authenc_decrypt_tail(req, 0);\r\nout:\r\nauthenc_request_complete(req, err);\r\n}\r\nstatic int crypto_authenc_decrypt(struct aead_request *req)\r\n{\r\nstruct crypto_aead *authenc = crypto_aead_reqtfm(req);\r\nunsigned int authsize = crypto_aead_authsize(authenc);\r\nstruct aead_instance *inst = aead_alg_instance(authenc);\r\nstruct crypto_authenc_ctx *ctx = crypto_aead_ctx(authenc);\r\nstruct authenc_instance_ctx *ictx = aead_instance_ctx(inst);\r\nstruct crypto_ahash *auth = ctx->auth;\r\nstruct authenc_request_ctx *areq_ctx = aead_request_ctx(req);\r\nstruct ahash_request *ahreq = (void *)(areq_ctx->tail + ictx->reqoff);\r\nu8 *hash = areq_ctx->tail;\r\nint err;\r\nhash = (u8 *)ALIGN((unsigned long)hash + crypto_ahash_alignmask(auth),\r\ncrypto_ahash_alignmask(auth) + 1);\r\nahash_request_set_tfm(ahreq, auth);\r\nahash_request_set_crypt(ahreq, req->src, hash,\r\nreq->assoclen + req->cryptlen - authsize);\r\nahash_request_set_callback(ahreq, aead_request_flags(req),\r\nauthenc_verify_ahash_done, req);\r\nerr = crypto_ahash_digest(ahreq);\r\nif (err)\r\nreturn err;\r\nreturn crypto_authenc_decrypt_tail(req, aead_request_flags(req));\r\n}\r\nstatic int crypto_authenc_init_tfm(struct crypto_aead *tfm)\r\n{\r\nstruct aead_instance *inst = aead_alg_instance(tfm);\r\nstruct authenc_instance_ctx *ictx = aead_instance_ctx(inst);\r\nstruct crypto_authenc_ctx *ctx = crypto_aead_ctx(tfm);\r\nstruct crypto_ahash *auth;\r\nstruct crypto_ablkcipher *enc;\r\nstruct crypto_blkcipher *null;\r\nint err;\r\nauth = crypto_spawn_ahash(&ictx->auth);\r\nif (IS_ERR(auth))\r\nreturn PTR_ERR(auth);\r\nenc = crypto_spawn_skcipher(&ictx->enc);\r\nerr = PTR_ERR(enc);\r\nif (IS_ERR(enc))\r\ngoto err_free_ahash;\r\nnull = crypto_get_default_null_skcipher();\r\nerr = PTR_ERR(null);\r\nif (IS_ERR(null))\r\ngoto err_free_skcipher;\r\nctx->auth = auth;\r\nctx->enc = enc;\r\nctx->null = null;\r\ncrypto_aead_set_reqsize(\r\ntfm,\r\nsizeof(struct authenc_request_ctx) +\r\nictx->reqoff +\r\nmax_t(unsigned int,\r\ncrypto_ahash_reqsize(auth) +\r\nsizeof(struct ahash_request),\r\nsizeof(struct ablkcipher_request) +\r\ncrypto_ablkcipher_reqsize(enc)));\r\nreturn 0;\r\nerr_free_skcipher:\r\ncrypto_free_ablkcipher(enc);\r\nerr_free_ahash:\r\ncrypto_free_ahash(auth);\r\nreturn err;\r\n}\r\nstatic void crypto_authenc_exit_tfm(struct crypto_aead *tfm)\r\n{\r\nstruct crypto_authenc_ctx *ctx = crypto_aead_ctx(tfm);\r\ncrypto_free_ahash(ctx->auth);\r\ncrypto_free_ablkcipher(ctx->enc);\r\ncrypto_put_default_null_skcipher();\r\n}\r\nstatic void crypto_authenc_free(struct aead_instance *inst)\r\n{\r\nstruct authenc_instance_ctx *ctx = aead_instance_ctx(inst);\r\ncrypto_drop_skcipher(&ctx->enc);\r\ncrypto_drop_ahash(&ctx->auth);\r\nkfree(inst);\r\n}\r\nstatic int crypto_authenc_create(struct crypto_template *tmpl,\r\nstruct rtattr **tb)\r\n{\r\nstruct crypto_attr_type *algt;\r\nstruct aead_instance *inst;\r\nstruct hash_alg_common *auth;\r\nstruct crypto_alg *auth_base;\r\nstruct crypto_alg *enc;\r\nstruct authenc_instance_ctx *ctx;\r\nconst char *enc_name;\r\nint err;\r\nalgt = crypto_get_attr_type(tb);\r\nif (IS_ERR(algt))\r\nreturn PTR_ERR(algt);\r\nif ((algt->type ^ CRYPTO_ALG_TYPE_AEAD) & algt->mask)\r\nreturn -EINVAL;\r\nauth = ahash_attr_alg(tb[1], CRYPTO_ALG_TYPE_HASH,\r\nCRYPTO_ALG_TYPE_AHASH_MASK);\r\nif (IS_ERR(auth))\r\nreturn PTR_ERR(auth);\r\nauth_base = &auth->base;\r\nenc_name = crypto_attr_alg_name(tb[2]);\r\nerr = PTR_ERR(enc_name);\r\nif (IS_ERR(enc_name))\r\ngoto out_put_auth;\r\ninst = kzalloc(sizeof(*inst) + sizeof(*ctx), GFP_KERNEL);\r\nerr = -ENOMEM;\r\nif (!inst)\r\ngoto out_put_auth;\r\nctx = aead_instance_ctx(inst);\r\nerr = crypto_init_ahash_spawn(&ctx->auth, auth,\r\naead_crypto_instance(inst));\r\nif (err)\r\ngoto err_free_inst;\r\ncrypto_set_skcipher_spawn(&ctx->enc, aead_crypto_instance(inst));\r\nerr = crypto_grab_skcipher(&ctx->enc, enc_name, 0,\r\ncrypto_requires_sync(algt->type,\r\nalgt->mask));\r\nif (err)\r\ngoto err_drop_auth;\r\nenc = crypto_skcipher_spawn_alg(&ctx->enc);\r\nctx->reqoff = ALIGN(2 * auth->digestsize + auth_base->cra_alignmask,\r\nauth_base->cra_alignmask + 1);\r\nerr = -ENAMETOOLONG;\r\nif (snprintf(inst->alg.base.cra_name, CRYPTO_MAX_ALG_NAME,\r\n"authenc(%s,%s)", auth_base->cra_name, enc->cra_name) >=\r\nCRYPTO_MAX_ALG_NAME)\r\ngoto err_drop_enc;\r\nif (snprintf(inst->alg.base.cra_driver_name, CRYPTO_MAX_ALG_NAME,\r\n"authenc(%s,%s)", auth_base->cra_driver_name,\r\nenc->cra_driver_name) >= CRYPTO_MAX_ALG_NAME)\r\ngoto err_drop_enc;\r\ninst->alg.base.cra_flags = enc->cra_flags & CRYPTO_ALG_ASYNC;\r\ninst->alg.base.cra_priority = enc->cra_priority * 10 +\r\nauth_base->cra_priority;\r\ninst->alg.base.cra_blocksize = enc->cra_blocksize;\r\ninst->alg.base.cra_alignmask = auth_base->cra_alignmask |\r\nenc->cra_alignmask;\r\ninst->alg.base.cra_ctxsize = sizeof(struct crypto_authenc_ctx);\r\ninst->alg.ivsize = enc->cra_ablkcipher.ivsize;\r\ninst->alg.maxauthsize = auth->digestsize;\r\ninst->alg.init = crypto_authenc_init_tfm;\r\ninst->alg.exit = crypto_authenc_exit_tfm;\r\ninst->alg.setkey = crypto_authenc_setkey;\r\ninst->alg.encrypt = crypto_authenc_encrypt;\r\ninst->alg.decrypt = crypto_authenc_decrypt;\r\ninst->free = crypto_authenc_free;\r\nerr = aead_register_instance(tmpl, inst);\r\nif (err)\r\ngoto err_drop_enc;\r\nout:\r\ncrypto_mod_put(auth_base);\r\nreturn err;\r\nerr_drop_enc:\r\ncrypto_drop_skcipher(&ctx->enc);\r\nerr_drop_auth:\r\ncrypto_drop_ahash(&ctx->auth);\r\nerr_free_inst:\r\nkfree(inst);\r\nout_put_auth:\r\ngoto out;\r\n}\r\nstatic int __init crypto_authenc_module_init(void)\r\n{\r\nreturn crypto_register_template(&crypto_authenc_tmpl);\r\n}\r\nstatic void __exit crypto_authenc_module_exit(void)\r\n{\r\ncrypto_unregister_template(&crypto_authenc_tmpl);\r\n}
