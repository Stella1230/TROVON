static inline int ap_using_interrupts(void)\r\n{\r\nreturn ap_airq_flag;\r\n}\r\nstatic inline int ap_instructions_available(void)\r\n{\r\nregister unsigned long reg0 asm ("0") = AP_MKQID(0,0);\r\nregister unsigned long reg1 asm ("1") = -ENODEV;\r\nregister unsigned long reg2 asm ("2") = 0UL;\r\nasm volatile(\r\n" .long 0xb2af0000\n"\r\n"0: la %1,0\n"\r\n"1:\n"\r\nEX_TABLE(0b, 1b)\r\n: "+d" (reg0), "+d" (reg1), "+d" (reg2) : : "cc" );\r\nreturn reg1;\r\n}\r\nstatic int ap_interrupts_available(void)\r\n{\r\nreturn test_facility(65);\r\n}\r\nstatic int ap_configuration_available(void)\r\n{\r\nreturn test_facility(12);\r\n}\r\nstatic inline struct ap_queue_status\r\nap_test_queue(ap_qid_t qid, unsigned long *info)\r\n{\r\nregister unsigned long reg0 asm ("0") = qid;\r\nregister struct ap_queue_status reg1 asm ("1");\r\nregister unsigned long reg2 asm ("2") = 0UL;\r\nif (test_facility(15))\r\nreg0 |= 1UL << 23;\r\nasm volatile(".long 0xb2af0000"\r\n: "+d" (reg0), "=d" (reg1), "+d" (reg2) : : "cc");\r\nif (info)\r\n*info = reg2;\r\nreturn reg1;\r\n}\r\nstatic inline struct ap_queue_status ap_reset_queue(ap_qid_t qid)\r\n{\r\nregister unsigned long reg0 asm ("0") = qid | 0x01000000UL;\r\nregister struct ap_queue_status reg1 asm ("1");\r\nregister unsigned long reg2 asm ("2") = 0UL;\r\nasm volatile(\r\n".long 0xb2af0000"\r\n: "+d" (reg0), "=d" (reg1), "+d" (reg2) : : "cc");\r\nreturn reg1;\r\n}\r\nstatic inline struct ap_queue_status\r\nap_queue_interruption_control(ap_qid_t qid, void *ind)\r\n{\r\nregister unsigned long reg0 asm ("0") = qid | 0x03000000UL;\r\nregister unsigned long reg1_in asm ("1") = 0x0000800000000000UL | AP_ISC;\r\nregister struct ap_queue_status reg1_out asm ("1");\r\nregister void *reg2 asm ("2") = ind;\r\nasm volatile(\r\n".long 0xb2af0000"\r\n: "+d" (reg0), "+d" (reg1_in), "=d" (reg1_out), "+d" (reg2)\r\n:\r\n: "cc" );\r\nreturn reg1_out;\r\n}\r\nstatic inline int ap_query_configuration(void)\r\n{\r\nregister unsigned long reg0 asm ("0") = 0x04000000UL;\r\nregister unsigned long reg1 asm ("1") = -EINVAL;\r\nregister void *reg2 asm ("2") = (void *) ap_configuration;\r\nif (!ap_configuration)\r\nreturn -EOPNOTSUPP;\r\nasm volatile(\r\n".long 0xb2af0000\n"\r\n"0: la %1,0\n"\r\n"1:\n"\r\nEX_TABLE(0b, 1b)\r\n: "+d" (reg0), "+d" (reg1), "+d" (reg2)\r\n:\r\n: "cc");\r\nreturn reg1;\r\n}\r\nstatic void ap_init_configuration(void)\r\n{\r\nif (!ap_configuration_available())\r\nreturn;\r\nap_configuration = kzalloc(sizeof(*ap_configuration), GFP_KERNEL);\r\nif (!ap_configuration)\r\nreturn;\r\nif (ap_query_configuration() != 0) {\r\nkfree(ap_configuration);\r\nap_configuration = NULL;\r\nreturn;\r\n}\r\n}\r\nstatic inline int ap_test_config(unsigned int *field, unsigned int nr)\r\n{\r\nreturn ap_test_bit((field + (nr >> 5)), (nr & 0x1f));\r\n}\r\nstatic inline int ap_test_config_card_id(unsigned int id)\r\n{\r\nif (!ap_configuration)\r\nreturn 1;\r\nreturn ap_test_config(ap_configuration->apm, id);\r\n}\r\nstatic inline int ap_test_config_domain(unsigned int domain)\r\n{\r\nif (!ap_configuration)\r\nreturn domain < 16;\r\nreturn ap_test_config(ap_configuration->aqm, domain);\r\n}\r\nstatic int ap_queue_enable_interruption(struct ap_device *ap_dev, void *ind)\r\n{\r\nstruct ap_queue_status status;\r\nstatus = ap_queue_interruption_control(ap_dev->qid, ind);\r\nswitch (status.response_code) {\r\ncase AP_RESPONSE_NORMAL:\r\ncase AP_RESPONSE_OTHERWISE_CHANGED:\r\nreturn 0;\r\ncase AP_RESPONSE_Q_NOT_AVAIL:\r\ncase AP_RESPONSE_DECONFIGURED:\r\ncase AP_RESPONSE_CHECKSTOPPED:\r\ncase AP_RESPONSE_INVALID_ADDRESS:\r\npr_err("Registering adapter interrupts for AP %d failed\n",\r\nAP_QID_DEVICE(ap_dev->qid));\r\nreturn -EOPNOTSUPP;\r\ncase AP_RESPONSE_RESET_IN_PROGRESS:\r\ncase AP_RESPONSE_BUSY:\r\ndefault:\r\nreturn -EBUSY;\r\n}\r\n}\r\nstatic inline struct ap_queue_status\r\n__ap_send(ap_qid_t qid, unsigned long long psmid, void *msg, size_t length,\r\nunsigned int special)\r\n{\r\ntypedef struct { char _[length]; } msgblock;\r\nregister unsigned long reg0 asm ("0") = qid | 0x40000000UL;\r\nregister struct ap_queue_status reg1 asm ("1");\r\nregister unsigned long reg2 asm ("2") = (unsigned long) msg;\r\nregister unsigned long reg3 asm ("3") = (unsigned long) length;\r\nregister unsigned long reg4 asm ("4") = (unsigned int) (psmid >> 32);\r\nregister unsigned long reg5 asm ("5") = psmid & 0xffffffff;\r\nif (special == 1)\r\nreg0 |= 0x400000UL;\r\nasm volatile (\r\n"0: .long 0xb2ad0042\n"\r\n" brc 2,0b"\r\n: "+d" (reg0), "=d" (reg1), "+d" (reg2), "+d" (reg3)\r\n: "d" (reg4), "d" (reg5), "m" (*(msgblock *) msg)\r\n: "cc" );\r\nreturn reg1;\r\n}\r\nint ap_send(ap_qid_t qid, unsigned long long psmid, void *msg, size_t length)\r\n{\r\nstruct ap_queue_status status;\r\nstatus = __ap_send(qid, psmid, msg, length, 0);\r\nswitch (status.response_code) {\r\ncase AP_RESPONSE_NORMAL:\r\nreturn 0;\r\ncase AP_RESPONSE_Q_FULL:\r\ncase AP_RESPONSE_RESET_IN_PROGRESS:\r\nreturn -EBUSY;\r\ncase AP_RESPONSE_REQ_FAC_NOT_INST:\r\nreturn -EINVAL;\r\ndefault:\r\nreturn -ENODEV;\r\n}\r\n}\r\nstatic inline struct ap_queue_status\r\n__ap_recv(ap_qid_t qid, unsigned long long *psmid, void *msg, size_t length)\r\n{\r\ntypedef struct { char _[length]; } msgblock;\r\nregister unsigned long reg0 asm("0") = qid | 0x80000000UL;\r\nregister struct ap_queue_status reg1 asm ("1");\r\nregister unsigned long reg2 asm("2") = 0UL;\r\nregister unsigned long reg4 asm("4") = (unsigned long) msg;\r\nregister unsigned long reg5 asm("5") = (unsigned long) length;\r\nregister unsigned long reg6 asm("6") = 0UL;\r\nregister unsigned long reg7 asm("7") = 0UL;\r\nasm volatile(\r\n"0: .long 0xb2ae0064\n"\r\n" brc 6,0b\n"\r\n: "+d" (reg0), "=d" (reg1), "+d" (reg2),\r\n"+d" (reg4), "+d" (reg5), "+d" (reg6), "+d" (reg7),\r\n"=m" (*(msgblock *) msg) : : "cc" );\r\n*psmid = (((unsigned long long) reg6) << 32) + reg7;\r\nreturn reg1;\r\n}\r\nint ap_recv(ap_qid_t qid, unsigned long long *psmid, void *msg, size_t length)\r\n{\r\nstruct ap_queue_status status;\r\nstatus = __ap_recv(qid, psmid, msg, length);\r\nswitch (status.response_code) {\r\ncase AP_RESPONSE_NORMAL:\r\nreturn 0;\r\ncase AP_RESPONSE_NO_PENDING_REPLY:\r\nif (status.queue_empty)\r\nreturn -ENOENT;\r\nreturn -EBUSY;\r\ncase AP_RESPONSE_RESET_IN_PROGRESS:\r\nreturn -EBUSY;\r\ndefault:\r\nreturn -ENODEV;\r\n}\r\n}\r\nstatic int ap_query_queue(ap_qid_t qid, int *queue_depth, int *device_type,\r\nunsigned int *facilities)\r\n{\r\nstruct ap_queue_status status;\r\nunsigned long info;\r\nint nd;\r\nif (!ap_test_config_card_id(AP_QID_DEVICE(qid)))\r\nreturn -ENODEV;\r\nstatus = ap_test_queue(qid, &info);\r\nswitch (status.response_code) {\r\ncase AP_RESPONSE_NORMAL:\r\n*queue_depth = (int)(info & 0xff);\r\n*device_type = (int)((info >> 24) & 0xff);\r\n*facilities = (unsigned int)(info >> 32);\r\nnd = (info >> 16) & 0xff;\r\nif ((info & (1UL << 57)) && nd > 0)\r\nap_max_domain_id = nd;\r\nreturn 0;\r\ncase AP_RESPONSE_Q_NOT_AVAIL:\r\ncase AP_RESPONSE_DECONFIGURED:\r\ncase AP_RESPONSE_CHECKSTOPPED:\r\ncase AP_RESPONSE_INVALID_ADDRESS:\r\nreturn -ENODEV;\r\ncase AP_RESPONSE_RESET_IN_PROGRESS:\r\ncase AP_RESPONSE_OTHERWISE_CHANGED:\r\ncase AP_RESPONSE_BUSY:\r\nreturn -EBUSY;\r\ndefault:\r\nBUG();\r\n}\r\n}\r\nstatic void ap_sm_wait(enum ap_wait wait)\r\n{\r\nktime_t hr_time;\r\nswitch (wait) {\r\ncase AP_WAIT_AGAIN:\r\ncase AP_WAIT_INTERRUPT:\r\nif (ap_using_interrupts())\r\nbreak;\r\nif (ap_poll_kthread) {\r\nwake_up(&ap_poll_wait);\r\nbreak;\r\n}\r\ncase AP_WAIT_TIMEOUT:\r\nspin_lock_bh(&ap_poll_timer_lock);\r\nif (!hrtimer_is_queued(&ap_poll_timer)) {\r\nhr_time = ktime_set(0, poll_timeout);\r\nhrtimer_forward_now(&ap_poll_timer, hr_time);\r\nhrtimer_restart(&ap_poll_timer);\r\n}\r\nspin_unlock_bh(&ap_poll_timer_lock);\r\nbreak;\r\ncase AP_WAIT_NONE:\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nstatic enum ap_wait ap_sm_nop(struct ap_device *ap_dev)\r\n{\r\nreturn AP_WAIT_NONE;\r\n}\r\nstatic struct ap_queue_status ap_sm_recv(struct ap_device *ap_dev)\r\n{\r\nstruct ap_queue_status status;\r\nstruct ap_message *ap_msg;\r\nstatus = __ap_recv(ap_dev->qid, &ap_dev->reply->psmid,\r\nap_dev->reply->message, ap_dev->reply->length);\r\nswitch (status.response_code) {\r\ncase AP_RESPONSE_NORMAL:\r\natomic_dec(&ap_poll_requests);\r\nap_dev->queue_count--;\r\nif (ap_dev->queue_count > 0)\r\nmod_timer(&ap_dev->timeout,\r\njiffies + ap_dev->drv->request_timeout);\r\nlist_for_each_entry(ap_msg, &ap_dev->pendingq, list) {\r\nif (ap_msg->psmid != ap_dev->reply->psmid)\r\ncontinue;\r\nlist_del_init(&ap_msg->list);\r\nap_dev->pendingq_count--;\r\nap_msg->receive(ap_dev, ap_msg, ap_dev->reply);\r\nbreak;\r\n}\r\ncase AP_RESPONSE_NO_PENDING_REPLY:\r\nif (!status.queue_empty || ap_dev->queue_count <= 0)\r\nbreak;\r\natomic_sub(ap_dev->queue_count, &ap_poll_requests);\r\nap_dev->queue_count = 0;\r\nlist_splice_init(&ap_dev->pendingq, &ap_dev->requestq);\r\nap_dev->requestq_count += ap_dev->pendingq_count;\r\nap_dev->pendingq_count = 0;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nreturn status;\r\n}\r\nstatic enum ap_wait ap_sm_read(struct ap_device *ap_dev)\r\n{\r\nstruct ap_queue_status status;\r\nstatus = ap_sm_recv(ap_dev);\r\nswitch (status.response_code) {\r\ncase AP_RESPONSE_NORMAL:\r\nif (ap_dev->queue_count > 0) {\r\nap_dev->state = AP_STATE_WORKING;\r\nreturn AP_WAIT_AGAIN;\r\n}\r\nap_dev->state = AP_STATE_IDLE;\r\nreturn AP_WAIT_NONE;\r\ncase AP_RESPONSE_NO_PENDING_REPLY:\r\nif (ap_dev->queue_count > 0)\r\nreturn AP_WAIT_INTERRUPT;\r\nap_dev->state = AP_STATE_IDLE;\r\nreturn AP_WAIT_NONE;\r\ndefault:\r\nap_dev->state = AP_STATE_BORKED;\r\nreturn AP_WAIT_NONE;\r\n}\r\n}\r\nstatic enum ap_wait ap_sm_write(struct ap_device *ap_dev)\r\n{\r\nstruct ap_queue_status status;\r\nstruct ap_message *ap_msg;\r\nif (ap_dev->requestq_count <= 0)\r\nreturn AP_WAIT_NONE;\r\nap_msg = list_entry(ap_dev->requestq.next, struct ap_message, list);\r\nstatus = __ap_send(ap_dev->qid, ap_msg->psmid,\r\nap_msg->message, ap_msg->length, ap_msg->special);\r\nswitch (status.response_code) {\r\ncase AP_RESPONSE_NORMAL:\r\natomic_inc(&ap_poll_requests);\r\nap_dev->queue_count++;\r\nif (ap_dev->queue_count == 1)\r\nmod_timer(&ap_dev->timeout,\r\njiffies + ap_dev->drv->request_timeout);\r\nlist_move_tail(&ap_msg->list, &ap_dev->pendingq);\r\nap_dev->requestq_count--;\r\nap_dev->pendingq_count++;\r\nif (ap_dev->queue_count < ap_dev->queue_depth) {\r\nap_dev->state = AP_STATE_WORKING;\r\nreturn AP_WAIT_AGAIN;\r\n}\r\ncase AP_RESPONSE_Q_FULL:\r\nap_dev->state = AP_STATE_QUEUE_FULL;\r\nreturn AP_WAIT_INTERRUPT;\r\ncase AP_RESPONSE_RESET_IN_PROGRESS:\r\nap_dev->state = AP_STATE_RESET_WAIT;\r\nreturn AP_WAIT_TIMEOUT;\r\ncase AP_RESPONSE_MESSAGE_TOO_BIG:\r\ncase AP_RESPONSE_REQ_FAC_NOT_INST:\r\nlist_del_init(&ap_msg->list);\r\nap_dev->requestq_count--;\r\nap_msg->rc = -EINVAL;\r\nap_msg->receive(ap_dev, ap_msg, NULL);\r\nreturn AP_WAIT_AGAIN;\r\ndefault:\r\nap_dev->state = AP_STATE_BORKED;\r\nreturn AP_WAIT_NONE;\r\n}\r\n}\r\nstatic enum ap_wait ap_sm_read_write(struct ap_device *ap_dev)\r\n{\r\nreturn min(ap_sm_read(ap_dev), ap_sm_write(ap_dev));\r\n}\r\nstatic enum ap_wait ap_sm_reset(struct ap_device *ap_dev)\r\n{\r\nstruct ap_queue_status status;\r\nstatus = ap_reset_queue(ap_dev->qid);\r\nswitch (status.response_code) {\r\ncase AP_RESPONSE_NORMAL:\r\ncase AP_RESPONSE_RESET_IN_PROGRESS:\r\nap_dev->state = AP_STATE_RESET_WAIT;\r\nap_dev->interrupt = AP_INTR_DISABLED;\r\nreturn AP_WAIT_TIMEOUT;\r\ncase AP_RESPONSE_BUSY:\r\nreturn AP_WAIT_TIMEOUT;\r\ncase AP_RESPONSE_Q_NOT_AVAIL:\r\ncase AP_RESPONSE_DECONFIGURED:\r\ncase AP_RESPONSE_CHECKSTOPPED:\r\ndefault:\r\nap_dev->state = AP_STATE_BORKED;\r\nreturn AP_WAIT_NONE;\r\n}\r\n}\r\nstatic enum ap_wait ap_sm_reset_wait(struct ap_device *ap_dev)\r\n{\r\nstruct ap_queue_status status;\r\nunsigned long info;\r\nif (ap_dev->queue_count > 0)\r\nstatus = ap_sm_recv(ap_dev);\r\nelse\r\nstatus = ap_test_queue(ap_dev->qid, &info);\r\nswitch (status.response_code) {\r\ncase AP_RESPONSE_NORMAL:\r\nif (ap_using_interrupts() &&\r\nap_queue_enable_interruption(ap_dev,\r\nap_airq.lsi_ptr) == 0)\r\nap_dev->state = AP_STATE_SETIRQ_WAIT;\r\nelse\r\nap_dev->state = (ap_dev->queue_count > 0) ?\r\nAP_STATE_WORKING : AP_STATE_IDLE;\r\nreturn AP_WAIT_AGAIN;\r\ncase AP_RESPONSE_BUSY:\r\ncase AP_RESPONSE_RESET_IN_PROGRESS:\r\nreturn AP_WAIT_TIMEOUT;\r\ncase AP_RESPONSE_Q_NOT_AVAIL:\r\ncase AP_RESPONSE_DECONFIGURED:\r\ncase AP_RESPONSE_CHECKSTOPPED:\r\ndefault:\r\nap_dev->state = AP_STATE_BORKED;\r\nreturn AP_WAIT_NONE;\r\n}\r\n}\r\nstatic enum ap_wait ap_sm_setirq_wait(struct ap_device *ap_dev)\r\n{\r\nstruct ap_queue_status status;\r\nunsigned long info;\r\nif (ap_dev->queue_count > 0)\r\nstatus = ap_sm_recv(ap_dev);\r\nelse\r\nstatus = ap_test_queue(ap_dev->qid, &info);\r\nif (status.int_enabled == 1) {\r\nap_dev->interrupt = AP_INTR_ENABLED;\r\nap_dev->state = (ap_dev->queue_count > 0) ?\r\nAP_STATE_WORKING : AP_STATE_IDLE;\r\n}\r\nswitch (status.response_code) {\r\ncase AP_RESPONSE_NORMAL:\r\nif (ap_dev->queue_count > 0)\r\nreturn AP_WAIT_AGAIN;\r\ncase AP_RESPONSE_NO_PENDING_REPLY:\r\nreturn AP_WAIT_TIMEOUT;\r\ndefault:\r\nap_dev->state = AP_STATE_BORKED;\r\nreturn AP_WAIT_NONE;\r\n}\r\n}\r\nstatic inline enum ap_wait ap_sm_event(struct ap_device *ap_dev,\r\nenum ap_event event)\r\n{\r\nreturn ap_jumptable[ap_dev->state][event](ap_dev);\r\n}\r\nstatic inline enum ap_wait ap_sm_event_loop(struct ap_device *ap_dev,\r\nenum ap_event event)\r\n{\r\nenum ap_wait wait;\r\nwhile ((wait = ap_sm_event(ap_dev, event)) == AP_WAIT_AGAIN)\r\n;\r\nreturn wait;\r\n}\r\nstatic void ap_request_timeout(unsigned long data)\r\n{\r\nstruct ap_device *ap_dev = (struct ap_device *) data;\r\nif (ap_suspend_flag)\r\nreturn;\r\nspin_lock_bh(&ap_dev->lock);\r\nap_sm_wait(ap_sm_event(ap_dev, AP_EVENT_TIMEOUT));\r\nspin_unlock_bh(&ap_dev->lock);\r\n}\r\nstatic enum hrtimer_restart ap_poll_timeout(struct hrtimer *unused)\r\n{\r\nif (!ap_suspend_flag)\r\ntasklet_schedule(&ap_tasklet);\r\nreturn HRTIMER_NORESTART;\r\n}\r\nstatic void ap_interrupt_handler(struct airq_struct *airq)\r\n{\r\ninc_irq_stat(IRQIO_APB);\r\nif (!ap_suspend_flag)\r\ntasklet_schedule(&ap_tasklet);\r\n}\r\nstatic void ap_tasklet_fn(unsigned long dummy)\r\n{\r\nstruct ap_device *ap_dev;\r\nenum ap_wait wait = AP_WAIT_NONE;\r\nif (ap_using_interrupts())\r\nxchg(ap_airq.lsi_ptr, 0);\r\nspin_lock(&ap_device_list_lock);\r\nlist_for_each_entry(ap_dev, &ap_device_list, list) {\r\nspin_lock_bh(&ap_dev->lock);\r\nwait = min(wait, ap_sm_event_loop(ap_dev, AP_EVENT_POLL));\r\nspin_unlock_bh(&ap_dev->lock);\r\n}\r\nspin_unlock(&ap_device_list_lock);\r\nap_sm_wait(wait);\r\n}\r\nstatic int ap_poll_thread(void *data)\r\n{\r\nDECLARE_WAITQUEUE(wait, current);\r\nset_user_nice(current, MAX_NICE);\r\nset_freezable();\r\nwhile (!kthread_should_stop()) {\r\nadd_wait_queue(&ap_poll_wait, &wait);\r\nset_current_state(TASK_INTERRUPTIBLE);\r\nif (ap_suspend_flag ||\r\natomic_read(&ap_poll_requests) <= 0) {\r\nschedule();\r\ntry_to_freeze();\r\n}\r\nset_current_state(TASK_RUNNING);\r\nremove_wait_queue(&ap_poll_wait, &wait);\r\nif (need_resched()) {\r\nschedule();\r\ntry_to_freeze();\r\ncontinue;\r\n}\r\nap_tasklet_fn(0);\r\n} while (!kthread_should_stop());\r\nreturn 0;\r\n}\r\nstatic int ap_poll_thread_start(void)\r\n{\r\nint rc;\r\nif (ap_using_interrupts() || ap_poll_kthread)\r\nreturn 0;\r\nmutex_lock(&ap_poll_thread_mutex);\r\nap_poll_kthread = kthread_run(ap_poll_thread, NULL, "appoll");\r\nrc = PTR_RET(ap_poll_kthread);\r\nif (rc)\r\nap_poll_kthread = NULL;\r\nmutex_unlock(&ap_poll_thread_mutex);\r\nreturn rc;\r\n}\r\nstatic void ap_poll_thread_stop(void)\r\n{\r\nif (!ap_poll_kthread)\r\nreturn;\r\nmutex_lock(&ap_poll_thread_mutex);\r\nkthread_stop(ap_poll_kthread);\r\nap_poll_kthread = NULL;\r\nmutex_unlock(&ap_poll_thread_mutex);\r\n}\r\nvoid ap_queue_message(struct ap_device *ap_dev, struct ap_message *ap_msg)\r\n{\r\nBUG_ON(!ap_msg->receive);\r\nspin_lock_bh(&ap_dev->lock);\r\nlist_add_tail(&ap_msg->list, &ap_dev->requestq);\r\nap_dev->requestq_count++;\r\nap_dev->total_request_count++;\r\nap_sm_wait(ap_sm_event_loop(ap_dev, AP_EVENT_POLL));\r\nspin_unlock_bh(&ap_dev->lock);\r\n}\r\nvoid ap_cancel_message(struct ap_device *ap_dev, struct ap_message *ap_msg)\r\n{\r\nstruct ap_message *tmp;\r\nspin_lock_bh(&ap_dev->lock);\r\nif (!list_empty(&ap_msg->list)) {\r\nlist_for_each_entry(tmp, &ap_dev->pendingq, list)\r\nif (tmp->psmid == ap_msg->psmid) {\r\nap_dev->pendingq_count--;\r\ngoto found;\r\n}\r\nap_dev->requestq_count--;\r\nfound:\r\nlist_del_init(&ap_msg->list);\r\n}\r\nspin_unlock_bh(&ap_dev->lock);\r\n}\r\nstatic ssize_t ap_hwtype_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct ap_device *ap_dev = to_ap_dev(dev);\r\nreturn snprintf(buf, PAGE_SIZE, "%d\n", ap_dev->device_type);\r\n}\r\nstatic ssize_t ap_raw_hwtype_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct ap_device *ap_dev = to_ap_dev(dev);\r\nreturn snprintf(buf, PAGE_SIZE, "%d\n", ap_dev->raw_hwtype);\r\n}\r\nstatic ssize_t ap_depth_show(struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct ap_device *ap_dev = to_ap_dev(dev);\r\nreturn snprintf(buf, PAGE_SIZE, "%d\n", ap_dev->queue_depth);\r\n}\r\nstatic ssize_t ap_request_count_show(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct ap_device *ap_dev = to_ap_dev(dev);\r\nint rc;\r\nspin_lock_bh(&ap_dev->lock);\r\nrc = snprintf(buf, PAGE_SIZE, "%d\n", ap_dev->total_request_count);\r\nspin_unlock_bh(&ap_dev->lock);\r\nreturn rc;\r\n}\r\nstatic ssize_t ap_requestq_count_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct ap_device *ap_dev = to_ap_dev(dev);\r\nint rc;\r\nspin_lock_bh(&ap_dev->lock);\r\nrc = snprintf(buf, PAGE_SIZE, "%d\n", ap_dev->requestq_count);\r\nspin_unlock_bh(&ap_dev->lock);\r\nreturn rc;\r\n}\r\nstatic ssize_t ap_pendingq_count_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct ap_device *ap_dev = to_ap_dev(dev);\r\nint rc;\r\nspin_lock_bh(&ap_dev->lock);\r\nrc = snprintf(buf, PAGE_SIZE, "%d\n", ap_dev->pendingq_count);\r\nspin_unlock_bh(&ap_dev->lock);\r\nreturn rc;\r\n}\r\nstatic ssize_t ap_reset_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct ap_device *ap_dev = to_ap_dev(dev);\r\nint rc = 0;\r\nspin_lock_bh(&ap_dev->lock);\r\nswitch (ap_dev->state) {\r\ncase AP_STATE_RESET_START:\r\ncase AP_STATE_RESET_WAIT:\r\nrc = snprintf(buf, PAGE_SIZE, "Reset in progress.\n");\r\nbreak;\r\ncase AP_STATE_WORKING:\r\ncase AP_STATE_QUEUE_FULL:\r\nrc = snprintf(buf, PAGE_SIZE, "Reset Timer armed.\n");\r\nbreak;\r\ndefault:\r\nrc = snprintf(buf, PAGE_SIZE, "No Reset Timer set.\n");\r\n}\r\nspin_unlock_bh(&ap_dev->lock);\r\nreturn rc;\r\n}\r\nstatic ssize_t ap_interrupt_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct ap_device *ap_dev = to_ap_dev(dev);\r\nint rc = 0;\r\nspin_lock_bh(&ap_dev->lock);\r\nif (ap_dev->state == AP_STATE_SETIRQ_WAIT)\r\nrc = snprintf(buf, PAGE_SIZE, "Enable Interrupt pending.\n");\r\nelse if (ap_dev->interrupt == AP_INTR_ENABLED)\r\nrc = snprintf(buf, PAGE_SIZE, "Interrupts enabled.\n");\r\nelse\r\nrc = snprintf(buf, PAGE_SIZE, "Interrupts disabled.\n");\r\nspin_unlock_bh(&ap_dev->lock);\r\nreturn rc;\r\n}\r\nstatic ssize_t ap_modalias_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nreturn sprintf(buf, "ap:t%02X\n", to_ap_dev(dev)->device_type);\r\n}\r\nstatic ssize_t ap_functions_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct ap_device *ap_dev = to_ap_dev(dev);\r\nreturn snprintf(buf, PAGE_SIZE, "0x%08X\n", ap_dev->functions);\r\n}\r\nstatic int ap_bus_match(struct device *dev, struct device_driver *drv)\r\n{\r\nstruct ap_device *ap_dev = to_ap_dev(dev);\r\nstruct ap_driver *ap_drv = to_ap_drv(drv);\r\nstruct ap_device_id *id;\r\nfor (id = ap_drv->ids; id->match_flags; id++) {\r\nif ((id->match_flags & AP_DEVICE_ID_MATCH_DEVICE_TYPE) &&\r\n(id->dev_type != ap_dev->device_type))\r\ncontinue;\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}\r\nstatic int ap_uevent (struct device *dev, struct kobj_uevent_env *env)\r\n{\r\nstruct ap_device *ap_dev = to_ap_dev(dev);\r\nint retval = 0;\r\nif (!ap_dev)\r\nreturn -ENODEV;\r\nretval = add_uevent_var(env, "DEV_TYPE=%04X", ap_dev->device_type);\r\nif (retval)\r\nreturn retval;\r\nretval = add_uevent_var(env, "MODALIAS=ap:t%02X", ap_dev->device_type);\r\nreturn retval;\r\n}\r\nstatic int ap_dev_suspend(struct device *dev, pm_message_t state)\r\n{\r\nstruct ap_device *ap_dev = to_ap_dev(dev);\r\nspin_lock_bh(&ap_dev->lock);\r\nap_dev->state = AP_STATE_SUSPEND_WAIT;\r\nwhile (ap_sm_event(ap_dev, AP_EVENT_POLL) != AP_WAIT_NONE)\r\n;\r\nap_dev->state = AP_STATE_BORKED;\r\nspin_unlock_bh(&ap_dev->lock);\r\nreturn 0;\r\n}\r\nstatic int ap_dev_resume(struct device *dev)\r\n{\r\nreturn 0;\r\n}\r\nstatic void ap_bus_suspend(void)\r\n{\r\nap_suspend_flag = 1;\r\nflush_work(&ap_scan_work);\r\ntasklet_disable(&ap_tasklet);\r\n}\r\nstatic int __ap_devices_unregister(struct device *dev, void *dummy)\r\n{\r\ndevice_unregister(dev);\r\nreturn 0;\r\n}\r\nstatic void ap_bus_resume(void)\r\n{\r\nint rc;\r\nbus_for_each_dev(&ap_bus_type, NULL, NULL, __ap_devices_unregister);\r\nif (ap_interrupts_available() && !ap_using_interrupts()) {\r\nrc = register_adapter_interrupt(&ap_airq);\r\nap_airq_flag = (rc == 0);\r\n}\r\nif (!ap_interrupts_available() && ap_using_interrupts()) {\r\nunregister_adapter_interrupt(&ap_airq);\r\nap_airq_flag = 0;\r\n}\r\nif (!user_set_domain)\r\nap_domain_index = -1;\r\nap_suspend_flag = 0;\r\nif (ap_airq_flag)\r\nxchg(ap_airq.lsi_ptr, 0);\r\ntasklet_enable(&ap_tasklet);\r\nqueue_work(system_long_wq, &ap_scan_work);\r\n}\r\nstatic int ap_power_event(struct notifier_block *this, unsigned long event,\r\nvoid *ptr)\r\n{\r\nswitch (event) {\r\ncase PM_HIBERNATION_PREPARE:\r\ncase PM_SUSPEND_PREPARE:\r\nap_bus_suspend();\r\nbreak;\r\ncase PM_POST_HIBERNATION:\r\ncase PM_POST_SUSPEND:\r\nap_bus_resume();\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nreturn NOTIFY_DONE;\r\n}\r\nstatic int ap_device_probe(struct device *dev)\r\n{\r\nstruct ap_device *ap_dev = to_ap_dev(dev);\r\nstruct ap_driver *ap_drv = to_ap_drv(dev->driver);\r\nint rc;\r\nap_dev->drv = ap_drv;\r\nrc = ap_drv->probe ? ap_drv->probe(ap_dev) : -ENODEV;\r\nif (rc)\r\nap_dev->drv = NULL;\r\nreturn rc;\r\n}\r\nstatic void __ap_flush_queue(struct ap_device *ap_dev)\r\n{\r\nstruct ap_message *ap_msg, *next;\r\nlist_for_each_entry_safe(ap_msg, next, &ap_dev->pendingq, list) {\r\nlist_del_init(&ap_msg->list);\r\nap_dev->pendingq_count--;\r\nap_msg->rc = -EAGAIN;\r\nap_msg->receive(ap_dev, ap_msg, NULL);\r\n}\r\nlist_for_each_entry_safe(ap_msg, next, &ap_dev->requestq, list) {\r\nlist_del_init(&ap_msg->list);\r\nap_dev->requestq_count--;\r\nap_msg->rc = -EAGAIN;\r\nap_msg->receive(ap_dev, ap_msg, NULL);\r\n}\r\n}\r\nvoid ap_flush_queue(struct ap_device *ap_dev)\r\n{\r\nspin_lock_bh(&ap_dev->lock);\r\n__ap_flush_queue(ap_dev);\r\nspin_unlock_bh(&ap_dev->lock);\r\n}\r\nstatic int ap_device_remove(struct device *dev)\r\n{\r\nstruct ap_device *ap_dev = to_ap_dev(dev);\r\nstruct ap_driver *ap_drv = ap_dev->drv;\r\nap_flush_queue(ap_dev);\r\ndel_timer_sync(&ap_dev->timeout);\r\nspin_lock_bh(&ap_device_list_lock);\r\nlist_del_init(&ap_dev->list);\r\nspin_unlock_bh(&ap_device_list_lock);\r\nif (ap_drv->remove)\r\nap_drv->remove(ap_dev);\r\nspin_lock_bh(&ap_dev->lock);\r\natomic_sub(ap_dev->queue_count, &ap_poll_requests);\r\nspin_unlock_bh(&ap_dev->lock);\r\nreturn 0;\r\n}\r\nstatic void ap_device_release(struct device *dev)\r\n{\r\nkfree(to_ap_dev(dev));\r\n}\r\nint ap_driver_register(struct ap_driver *ap_drv, struct module *owner,\r\nchar *name)\r\n{\r\nstruct device_driver *drv = &ap_drv->driver;\r\nif (!initialised)\r\nreturn -ENODEV;\r\ndrv->bus = &ap_bus_type;\r\ndrv->probe = ap_device_probe;\r\ndrv->remove = ap_device_remove;\r\ndrv->owner = owner;\r\ndrv->name = name;\r\nreturn driver_register(drv);\r\n}\r\nvoid ap_driver_unregister(struct ap_driver *ap_drv)\r\n{\r\ndriver_unregister(&ap_drv->driver);\r\n}\r\nvoid ap_bus_force_rescan(void)\r\n{\r\nif (ap_suspend_flag)\r\nreturn;\r\ndel_timer(&ap_config_timer);\r\nqueue_work(system_long_wq, &ap_scan_work);\r\nflush_work(&ap_scan_work);\r\n}\r\nstatic ssize_t ap_domain_show(struct bus_type *bus, char *buf)\r\n{\r\nreturn snprintf(buf, PAGE_SIZE, "%d\n", ap_domain_index);\r\n}\r\nstatic ssize_t ap_control_domain_mask_show(struct bus_type *bus, char *buf)\r\n{\r\nif (!ap_configuration)\r\nreturn snprintf(buf, PAGE_SIZE, "not supported\n");\r\nif (!test_facility(76))\r\nreturn snprintf(buf, PAGE_SIZE, "%08x%08x\n",\r\nap_configuration->adm[0],\r\nap_configuration->adm[1]);\r\nreturn snprintf(buf, PAGE_SIZE,\r\n"0x%08x%08x%08x%08x%08x%08x%08x%08x\n",\r\nap_configuration->adm[0], ap_configuration->adm[1],\r\nap_configuration->adm[2], ap_configuration->adm[3],\r\nap_configuration->adm[4], ap_configuration->adm[5],\r\nap_configuration->adm[6], ap_configuration->adm[7]);\r\n}\r\nstatic ssize_t ap_config_time_show(struct bus_type *bus, char *buf)\r\n{\r\nreturn snprintf(buf, PAGE_SIZE, "%d\n", ap_config_time);\r\n}\r\nstatic ssize_t ap_interrupts_show(struct bus_type *bus, char *buf)\r\n{\r\nreturn snprintf(buf, PAGE_SIZE, "%d\n",\r\nap_using_interrupts() ? 1 : 0);\r\n}\r\nstatic ssize_t ap_config_time_store(struct bus_type *bus,\r\nconst char *buf, size_t count)\r\n{\r\nint time;\r\nif (sscanf(buf, "%d\n", &time) != 1 || time < 5 || time > 120)\r\nreturn -EINVAL;\r\nap_config_time = time;\r\nmod_timer(&ap_config_timer, jiffies + ap_config_time * HZ);\r\nreturn count;\r\n}\r\nstatic ssize_t ap_poll_thread_show(struct bus_type *bus, char *buf)\r\n{\r\nreturn snprintf(buf, PAGE_SIZE, "%d\n", ap_poll_kthread ? 1 : 0);\r\n}\r\nstatic ssize_t ap_poll_thread_store(struct bus_type *bus,\r\nconst char *buf, size_t count)\r\n{\r\nint flag, rc;\r\nif (sscanf(buf, "%d\n", &flag) != 1)\r\nreturn -EINVAL;\r\nif (flag) {\r\nrc = ap_poll_thread_start();\r\nif (rc)\r\ncount = rc;\r\n} else\r\nap_poll_thread_stop();\r\nreturn count;\r\n}\r\nstatic ssize_t poll_timeout_show(struct bus_type *bus, char *buf)\r\n{\r\nreturn snprintf(buf, PAGE_SIZE, "%llu\n", poll_timeout);\r\n}\r\nstatic ssize_t poll_timeout_store(struct bus_type *bus, const char *buf,\r\nsize_t count)\r\n{\r\nunsigned long long time;\r\nktime_t hr_time;\r\nif (sscanf(buf, "%llu\n", &time) != 1 || time < 1 ||\r\ntime > 120000000000ULL)\r\nreturn -EINVAL;\r\npoll_timeout = time;\r\nhr_time = ktime_set(0, poll_timeout);\r\nspin_lock_bh(&ap_poll_timer_lock);\r\nhrtimer_cancel(&ap_poll_timer);\r\nhrtimer_set_expires(&ap_poll_timer, hr_time);\r\nhrtimer_start_expires(&ap_poll_timer, HRTIMER_MODE_ABS);\r\nspin_unlock_bh(&ap_poll_timer_lock);\r\nreturn count;\r\n}\r\nstatic ssize_t ap_max_domain_id_show(struct bus_type *bus, char *buf)\r\n{\r\nint max_domain_id;\r\nif (ap_configuration)\r\nmax_domain_id = ap_max_domain_id ? : -1;\r\nelse\r\nmax_domain_id = 15;\r\nreturn snprintf(buf, PAGE_SIZE, "%d\n", max_domain_id);\r\n}\r\nstatic int ap_select_domain(void)\r\n{\r\nint count, max_count, best_domain;\r\nstruct ap_queue_status status;\r\nint i, j;\r\nif (ap_domain_index >= 0)\r\nreturn 0;\r\nbest_domain = -1;\r\nmax_count = 0;\r\nfor (i = 0; i < AP_DOMAINS; i++) {\r\nif (!ap_test_config_domain(i))\r\ncontinue;\r\ncount = 0;\r\nfor (j = 0; j < AP_DEVICES; j++) {\r\nif (!ap_test_config_card_id(j))\r\ncontinue;\r\nstatus = ap_test_queue(AP_MKQID(j, i), NULL);\r\nif (status.response_code != AP_RESPONSE_NORMAL)\r\ncontinue;\r\ncount++;\r\n}\r\nif (count > max_count) {\r\nmax_count = count;\r\nbest_domain = i;\r\n}\r\n}\r\nif (best_domain >= 0){\r\nap_domain_index = best_domain;\r\nreturn 0;\r\n}\r\nreturn -ENODEV;\r\n}\r\nstatic int __ap_scan_bus(struct device *dev, void *data)\r\n{\r\nreturn to_ap_dev(dev)->qid == (ap_qid_t)(unsigned long) data;\r\n}\r\nstatic void ap_scan_bus(struct work_struct *unused)\r\n{\r\nstruct ap_device *ap_dev;\r\nstruct device *dev;\r\nap_qid_t qid;\r\nint queue_depth = 0, device_type = 0;\r\nunsigned int device_functions = 0;\r\nint rc, i, borked;\r\nap_query_configuration();\r\nif (ap_select_domain() != 0)\r\ngoto out;\r\nfor (i = 0; i < AP_DEVICES; i++) {\r\nqid = AP_MKQID(i, ap_domain_index);\r\ndev = bus_find_device(&ap_bus_type, NULL,\r\n(void *)(unsigned long)qid,\r\n__ap_scan_bus);\r\nrc = ap_query_queue(qid, &queue_depth, &device_type,\r\n&device_functions);\r\nif (dev) {\r\nap_dev = to_ap_dev(dev);\r\nspin_lock_bh(&ap_dev->lock);\r\nif (rc == -ENODEV)\r\nap_dev->state = AP_STATE_BORKED;\r\nborked = ap_dev->state == AP_STATE_BORKED;\r\nspin_unlock_bh(&ap_dev->lock);\r\nif (borked)\r\ndevice_unregister(dev);\r\nput_device(dev);\r\nif (!borked)\r\ncontinue;\r\n}\r\nif (rc)\r\ncontinue;\r\nap_dev = kzalloc(sizeof(*ap_dev), GFP_KERNEL);\r\nif (!ap_dev)\r\nbreak;\r\nap_dev->qid = qid;\r\nap_dev->state = AP_STATE_RESET_START;\r\nap_dev->interrupt = AP_INTR_DISABLED;\r\nap_dev->queue_depth = queue_depth;\r\nap_dev->raw_hwtype = device_type;\r\nap_dev->device_type = device_type;\r\nap_dev->functions = device_functions;\r\nspin_lock_init(&ap_dev->lock);\r\nINIT_LIST_HEAD(&ap_dev->pendingq);\r\nINIT_LIST_HEAD(&ap_dev->requestq);\r\nINIT_LIST_HEAD(&ap_dev->list);\r\nsetup_timer(&ap_dev->timeout, ap_request_timeout,\r\n(unsigned long) ap_dev);\r\nap_dev->device.bus = &ap_bus_type;\r\nap_dev->device.parent = ap_root_device;\r\nrc = dev_set_name(&ap_dev->device, "card%02x",\r\nAP_QID_DEVICE(ap_dev->qid));\r\nif (rc) {\r\nkfree(ap_dev);\r\ncontinue;\r\n}\r\nspin_lock_bh(&ap_device_list_lock);\r\nlist_add(&ap_dev->list, &ap_device_list);\r\nspin_unlock_bh(&ap_device_list_lock);\r\nspin_lock_bh(&ap_dev->lock);\r\nap_sm_wait(ap_sm_event(ap_dev, AP_EVENT_POLL));\r\nspin_unlock_bh(&ap_dev->lock);\r\nap_dev->device.release = ap_device_release;\r\nrc = device_register(&ap_dev->device);\r\nif (rc) {\r\nspin_lock_bh(&ap_dev->lock);\r\nlist_del_init(&ap_dev->list);\r\nspin_unlock_bh(&ap_dev->lock);\r\nput_device(&ap_dev->device);\r\ncontinue;\r\n}\r\nrc = sysfs_create_group(&ap_dev->device.kobj,\r\n&ap_dev_attr_group);\r\nif (rc) {\r\ndevice_unregister(&ap_dev->device);\r\ncontinue;\r\n}\r\n}\r\nout:\r\nmod_timer(&ap_config_timer, jiffies + ap_config_time * HZ);\r\n}\r\nstatic void ap_config_timeout(unsigned long ptr)\r\n{\r\nif (ap_suspend_flag)\r\nreturn;\r\nqueue_work(system_long_wq, &ap_scan_work);\r\n}\r\nstatic void ap_reset_domain(void)\r\n{\r\nint i;\r\nif (ap_domain_index == -1 || !ap_test_config_domain(ap_domain_index))\r\nreturn;\r\nfor (i = 0; i < AP_DEVICES; i++)\r\nap_reset_queue(AP_MKQID(i, ap_domain_index));\r\n}\r\nstatic void ap_reset_all(void)\r\n{\r\nint i, j;\r\nfor (i = 0; i < AP_DOMAINS; i++) {\r\nif (!ap_test_config_domain(i))\r\ncontinue;\r\nfor (j = 0; j < AP_DEVICES; j++) {\r\nif (!ap_test_config_card_id(j))\r\ncontinue;\r\nap_reset_queue(AP_MKQID(j, i));\r\n}\r\n}\r\n}\r\nint __init ap_module_init(void)\r\n{\r\nint max_domain_id;\r\nint rc, i;\r\nif (ap_instructions_available() != 0) {\r\npr_warn("The hardware system does not support AP instructions\n");\r\nreturn -ENODEV;\r\n}\r\nap_init_configuration();\r\nif (ap_configuration)\r\nmax_domain_id = ap_max_domain_id ? : (AP_DOMAINS - 1);\r\nelse\r\nmax_domain_id = 15;\r\nif (ap_domain_index < -1 || ap_domain_index > max_domain_id) {\r\npr_warn("%d is not a valid cryptographic domain\n",\r\nap_domain_index);\r\nreturn -EINVAL;\r\n}\r\nif (ap_domain_index >= 0)\r\nuser_set_domain = 1;\r\nif (ap_interrupts_available()) {\r\nrc = register_adapter_interrupt(&ap_airq);\r\nap_airq_flag = (rc == 0);\r\n}\r\nregister_reset_call(&ap_reset_call);\r\nrc = bus_register(&ap_bus_type);\r\nif (rc)\r\ngoto out;\r\nfor (i = 0; ap_bus_attrs[i]; i++) {\r\nrc = bus_create_file(&ap_bus_type, ap_bus_attrs[i]);\r\nif (rc)\r\ngoto out_bus;\r\n}\r\nap_root_device = root_device_register("ap");\r\nrc = PTR_RET(ap_root_device);\r\nif (rc)\r\ngoto out_bus;\r\nsetup_timer(&ap_config_timer, ap_config_timeout, 0);\r\nif (MACHINE_IS_VM)\r\npoll_timeout = 1500000;\r\nspin_lock_init(&ap_poll_timer_lock);\r\nhrtimer_init(&ap_poll_timer, CLOCK_MONOTONIC, HRTIMER_MODE_ABS);\r\nap_poll_timer.function = ap_poll_timeout;\r\nif (ap_thread_flag) {\r\nrc = ap_poll_thread_start();\r\nif (rc)\r\ngoto out_work;\r\n}\r\nrc = register_pm_notifier(&ap_power_notifier);\r\nif (rc)\r\ngoto out_pm;\r\nqueue_work(system_long_wq, &ap_scan_work);\r\ninitialised = true;\r\nreturn 0;\r\nout_pm:\r\nap_poll_thread_stop();\r\nout_work:\r\nhrtimer_cancel(&ap_poll_timer);\r\nroot_device_unregister(ap_root_device);\r\nout_bus:\r\nwhile (i--)\r\nbus_remove_file(&ap_bus_type, ap_bus_attrs[i]);\r\nbus_unregister(&ap_bus_type);\r\nout:\r\nunregister_reset_call(&ap_reset_call);\r\nif (ap_using_interrupts())\r\nunregister_adapter_interrupt(&ap_airq);\r\nkfree(ap_configuration);\r\nreturn rc;\r\n}\r\nvoid ap_module_exit(void)\r\n{\r\nint i;\r\ninitialised = false;\r\nap_reset_domain();\r\nap_poll_thread_stop();\r\ndel_timer_sync(&ap_config_timer);\r\nhrtimer_cancel(&ap_poll_timer);\r\ntasklet_kill(&ap_tasklet);\r\nbus_for_each_dev(&ap_bus_type, NULL, NULL, __ap_devices_unregister);\r\nfor (i = 0; ap_bus_attrs[i]; i++)\r\nbus_remove_file(&ap_bus_type, ap_bus_attrs[i]);\r\nunregister_pm_notifier(&ap_power_notifier);\r\nroot_device_unregister(ap_root_device);\r\nbus_unregister(&ap_bus_type);\r\nkfree(ap_configuration);\r\nunregister_reset_call(&ap_reset_call);\r\nif (ap_using_interrupts())\r\nunregister_adapter_interrupt(&ap_airq);\r\n}
