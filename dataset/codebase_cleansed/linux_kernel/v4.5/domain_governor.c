static int dev_update_qos_constraint(struct device *dev, void *data)\r\n{\r\ns64 *constraint_ns_p = data;\r\ns32 constraint_ns = -1;\r\nif (dev->power.subsys_data && dev->power.subsys_data->domain_data)\r\nconstraint_ns = dev_gpd_data(dev)->td.effective_constraint_ns;\r\nif (constraint_ns < 0) {\r\nconstraint_ns = dev_pm_qos_read_value(dev);\r\nconstraint_ns *= NSEC_PER_USEC;\r\n}\r\nif (constraint_ns == 0)\r\nreturn 0;\r\nif (constraint_ns < *constraint_ns_p || *constraint_ns_p == 0)\r\n*constraint_ns_p = constraint_ns;\r\nreturn 0;\r\n}\r\nstatic bool default_stop_ok(struct device *dev)\r\n{\r\nstruct gpd_timing_data *td = &dev_gpd_data(dev)->td;\r\nunsigned long flags;\r\ns64 constraint_ns;\r\ndev_dbg(dev, "%s()\n", __func__);\r\nspin_lock_irqsave(&dev->power.lock, flags);\r\nif (!td->constraint_changed) {\r\nbool ret = td->cached_stop_ok;\r\nspin_unlock_irqrestore(&dev->power.lock, flags);\r\nreturn ret;\r\n}\r\ntd->constraint_changed = false;\r\ntd->cached_stop_ok = false;\r\ntd->effective_constraint_ns = -1;\r\nconstraint_ns = __dev_pm_qos_read_value(dev);\r\nspin_unlock_irqrestore(&dev->power.lock, flags);\r\nif (constraint_ns < 0)\r\nreturn false;\r\nconstraint_ns *= NSEC_PER_USEC;\r\nif (!dev->power.ignore_children)\r\ndevice_for_each_child(dev, &constraint_ns,\r\ndev_update_qos_constraint);\r\nif (constraint_ns > 0) {\r\nconstraint_ns -= td->suspend_latency_ns +\r\ntd->resume_latency_ns;\r\nif (constraint_ns == 0)\r\nreturn false;\r\n}\r\ntd->effective_constraint_ns = constraint_ns;\r\ntd->cached_stop_ok = constraint_ns >= 0;\r\nreturn td->cached_stop_ok;\r\n}\r\nstatic bool default_power_down_ok(struct dev_pm_domain *pd)\r\n{\r\nstruct generic_pm_domain *genpd = pd_to_genpd(pd);\r\nstruct gpd_link *link;\r\nstruct pm_domain_data *pdd;\r\ns64 min_off_time_ns;\r\ns64 off_on_time_ns;\r\nif (genpd->max_off_time_changed) {\r\nstruct gpd_link *link;\r\nlist_for_each_entry(link, &genpd->slave_links, slave_node)\r\nlink->master->max_off_time_changed = true;\r\ngenpd->max_off_time_changed = false;\r\ngenpd->cached_power_down_ok = false;\r\ngenpd->max_off_time_ns = -1;\r\n} else {\r\nreturn genpd->cached_power_down_ok;\r\n}\r\noff_on_time_ns = genpd->power_off_latency_ns +\r\ngenpd->power_on_latency_ns;\r\nmin_off_time_ns = -1;\r\nlist_for_each_entry(link, &genpd->master_links, master_node) {\r\nstruct generic_pm_domain *sd = link->slave;\r\ns64 sd_max_off_ns = sd->max_off_time_ns;\r\nif (sd_max_off_ns < 0)\r\ncontinue;\r\nif (sd_max_off_ns <= off_on_time_ns)\r\nreturn false;\r\nif (min_off_time_ns > sd_max_off_ns || min_off_time_ns < 0)\r\nmin_off_time_ns = sd_max_off_ns;\r\n}\r\nlist_for_each_entry(pdd, &genpd->dev_list, list_node) {\r\nstruct gpd_timing_data *td;\r\ns64 constraint_ns;\r\ntd = &to_gpd_data(pdd)->td;\r\nconstraint_ns = td->effective_constraint_ns;\r\nif (constraint_ns < 0) {\r\nconstraint_ns = dev_pm_qos_read_value(pdd->dev);\r\nconstraint_ns *= NSEC_PER_USEC;\r\n}\r\nif (constraint_ns == 0)\r\ncontinue;\r\nif (constraint_ns <= off_on_time_ns)\r\nreturn false;\r\nif (min_off_time_ns > constraint_ns || min_off_time_ns < 0)\r\nmin_off_time_ns = constraint_ns;\r\n}\r\ngenpd->cached_power_down_ok = true;\r\nif (min_off_time_ns < 0)\r\nreturn true;\r\ngenpd->max_off_time_ns = min_off_time_ns - genpd->power_on_latency_ns;\r\nreturn true;\r\n}\r\nstatic bool always_on_power_down_ok(struct dev_pm_domain *domain)\r\n{\r\nreturn false;\r\n}
