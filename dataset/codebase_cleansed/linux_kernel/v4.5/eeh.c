static int __init eeh_setup(char *str)\r\n{\r\nif (!strcmp(str, "off"))\r\neeh_add_flag(EEH_FORCE_DISABLED);\r\nelse if (!strcmp(str, "early_log"))\r\neeh_add_flag(EEH_EARLY_DUMP_LOG);\r\nreturn 1;\r\n}\r\nstatic size_t eeh_dump_dev_log(struct eeh_dev *edev, char *buf, size_t len)\r\n{\r\nstruct pci_dn *pdn = eeh_dev_to_pdn(edev);\r\nu32 cfg;\r\nint cap, i;\r\nint n = 0, l = 0;\r\nchar buffer[128];\r\nn += scnprintf(buf+n, len-n, "%04x:%02x:%02x:%01x\n",\r\nedev->phb->global_number, pdn->busno,\r\nPCI_SLOT(pdn->devfn), PCI_FUNC(pdn->devfn));\r\npr_warn("EEH: of node=%04x:%02x:%02x:%01x\n",\r\nedev->phb->global_number, pdn->busno,\r\nPCI_SLOT(pdn->devfn), PCI_FUNC(pdn->devfn));\r\neeh_ops->read_config(pdn, PCI_VENDOR_ID, 4, &cfg);\r\nn += scnprintf(buf+n, len-n, "dev/vend:%08x\n", cfg);\r\npr_warn("EEH: PCI device/vendor: %08x\n", cfg);\r\neeh_ops->read_config(pdn, PCI_COMMAND, 4, &cfg);\r\nn += scnprintf(buf+n, len-n, "cmd/stat:%x\n", cfg);\r\npr_warn("EEH: PCI cmd/status register: %08x\n", cfg);\r\nif (edev->mode & EEH_DEV_BRIDGE) {\r\neeh_ops->read_config(pdn, PCI_SEC_STATUS, 2, &cfg);\r\nn += scnprintf(buf+n, len-n, "sec stat:%x\n", cfg);\r\npr_warn("EEH: Bridge secondary status: %04x\n", cfg);\r\neeh_ops->read_config(pdn, PCI_BRIDGE_CONTROL, 2, &cfg);\r\nn += scnprintf(buf+n, len-n, "brdg ctl:%x\n", cfg);\r\npr_warn("EEH: Bridge control: %04x\n", cfg);\r\n}\r\ncap = edev->pcix_cap;\r\nif (cap) {\r\neeh_ops->read_config(pdn, cap, 4, &cfg);\r\nn += scnprintf(buf+n, len-n, "pcix-cmd:%x\n", cfg);\r\npr_warn("EEH: PCI-X cmd: %08x\n", cfg);\r\neeh_ops->read_config(pdn, cap+4, 4, &cfg);\r\nn += scnprintf(buf+n, len-n, "pcix-stat:%x\n", cfg);\r\npr_warn("EEH: PCI-X status: %08x\n", cfg);\r\n}\r\ncap = edev->pcie_cap;\r\nif (cap) {\r\nn += scnprintf(buf+n, len-n, "pci-e cap10:\n");\r\npr_warn("EEH: PCI-E capabilities and status follow:\n");\r\nfor (i=0; i<=8; i++) {\r\neeh_ops->read_config(pdn, cap+4*i, 4, &cfg);\r\nn += scnprintf(buf+n, len-n, "%02x:%x\n", 4*i, cfg);\r\nif ((i % 4) == 0) {\r\nif (i != 0)\r\npr_warn("%s\n", buffer);\r\nl = scnprintf(buffer, sizeof(buffer),\r\n"EEH: PCI-E %02x: %08x ",\r\n4*i, cfg);\r\n} else {\r\nl += scnprintf(buffer+l, sizeof(buffer)-l,\r\n"%08x ", cfg);\r\n}\r\n}\r\npr_warn("%s\n", buffer);\r\n}\r\ncap = edev->aer_cap;\r\nif (cap) {\r\nn += scnprintf(buf+n, len-n, "pci-e AER:\n");\r\npr_warn("EEH: PCI-E AER capability register set follows:\n");\r\nfor (i=0; i<=13; i++) {\r\neeh_ops->read_config(pdn, cap+4*i, 4, &cfg);\r\nn += scnprintf(buf+n, len-n, "%02x:%x\n", 4*i, cfg);\r\nif ((i % 4) == 0) {\r\nif (i != 0)\r\npr_warn("%s\n", buffer);\r\nl = scnprintf(buffer, sizeof(buffer),\r\n"EEH: PCI-E AER %02x: %08x ",\r\n4*i, cfg);\r\n} else {\r\nl += scnprintf(buffer+l, sizeof(buffer)-l,\r\n"%08x ", cfg);\r\n}\r\n}\r\npr_warn("%s\n", buffer);\r\n}\r\nreturn n;\r\n}\r\nstatic void *eeh_dump_pe_log(void *data, void *flag)\r\n{\r\nstruct eeh_pe *pe = data;\r\nstruct eeh_dev *edev, *tmp;\r\nsize_t *plen = flag;\r\nif (pe->state & EEH_PE_CFG_BLOCKED)\r\nreturn NULL;\r\neeh_pe_for_each_dev(pe, edev, tmp)\r\n*plen += eeh_dump_dev_log(edev, pci_regs_buf + *plen,\r\nEEH_PCI_REGS_LOG_LEN - *plen);\r\nreturn NULL;\r\n}\r\nvoid eeh_slot_error_detail(struct eeh_pe *pe, int severity)\r\n{\r\nsize_t loglen = 0;\r\nif (!(pe->type & EEH_PE_PHB)) {\r\nif (eeh_has_flag(EEH_ENABLE_IO_FOR_LOG))\r\neeh_pci_enable(pe, EEH_OPT_THAW_MMIO);\r\neeh_ops->configure_bridge(pe);\r\nif (!(pe->state & EEH_PE_CFG_BLOCKED)) {\r\neeh_pe_restore_bars(pe);\r\npci_regs_buf[0] = 0;\r\neeh_pe_traverse(pe, eeh_dump_pe_log, &loglen);\r\n}\r\n}\r\neeh_ops->get_log(pe, severity, pci_regs_buf, loglen);\r\n}\r\nstatic inline unsigned long eeh_token_to_phys(unsigned long token)\r\n{\r\npte_t *ptep;\r\nunsigned long pa;\r\nint hugepage_shift;\r\nptep = __find_linux_pte_or_hugepte(init_mm.pgd, token,\r\nNULL, &hugepage_shift);\r\nif (!ptep)\r\nreturn token;\r\nWARN_ON(hugepage_shift);\r\npa = pte_pfn(*ptep) << PAGE_SHIFT;\r\nreturn pa | (token & (PAGE_SIZE-1));\r\n}\r\nstatic int eeh_phb_check_failure(struct eeh_pe *pe)\r\n{\r\nstruct eeh_pe *phb_pe;\r\nunsigned long flags;\r\nint ret;\r\nif (!eeh_has_flag(EEH_PROBE_MODE_DEV))\r\nreturn -EPERM;\r\nphb_pe = eeh_phb_pe_get(pe->phb);\r\nif (!phb_pe) {\r\npr_warn("%s Can't find PE for PHB#%d\n",\r\n__func__, pe->phb->global_number);\r\nreturn -EEXIST;\r\n}\r\neeh_serialize_lock(&flags);\r\nif (phb_pe->state & EEH_PE_ISOLATED) {\r\nret = 0;\r\ngoto out;\r\n}\r\nret = eeh_ops->get_state(phb_pe, NULL);\r\nif ((ret < 0) ||\r\n(ret == EEH_STATE_NOT_SUPPORT) ||\r\n(ret & (EEH_STATE_MMIO_ACTIVE | EEH_STATE_DMA_ACTIVE)) ==\r\n(EEH_STATE_MMIO_ACTIVE | EEH_STATE_DMA_ACTIVE)) {\r\nret = 0;\r\ngoto out;\r\n}\r\neeh_pe_state_mark(phb_pe, EEH_PE_ISOLATED);\r\neeh_serialize_unlock(flags);\r\npr_err("EEH: PHB#%x failure detected, location: %s\n",\r\nphb_pe->phb->global_number, eeh_pe_loc_get(phb_pe));\r\ndump_stack();\r\neeh_send_failure_event(phb_pe);\r\nreturn 1;\r\nout:\r\neeh_serialize_unlock(flags);\r\nreturn ret;\r\n}\r\nint eeh_dev_check_failure(struct eeh_dev *edev)\r\n{\r\nint ret;\r\nint active_flags = (EEH_STATE_MMIO_ACTIVE | EEH_STATE_DMA_ACTIVE);\r\nunsigned long flags;\r\nstruct pci_dn *pdn;\r\nstruct pci_dev *dev;\r\nstruct eeh_pe *pe, *parent_pe, *phb_pe;\r\nint rc = 0;\r\nconst char *location = NULL;\r\neeh_stats.total_mmio_ffs++;\r\nif (!eeh_enabled())\r\nreturn 0;\r\nif (!edev) {\r\neeh_stats.no_dn++;\r\nreturn 0;\r\n}\r\ndev = eeh_dev_to_pci_dev(edev);\r\npe = eeh_dev_to_pe(edev);\r\nif (!pe) {\r\neeh_stats.ignored_check++;\r\npr_debug("EEH: Ignored check for %s\n",\r\neeh_pci_name(dev));\r\nreturn 0;\r\n}\r\nif (!pe->addr && !pe->config_addr) {\r\neeh_stats.no_cfg_addr++;\r\nreturn 0;\r\n}\r\nret = eeh_phb_check_failure(pe);\r\nif (ret > 0)\r\nreturn ret;\r\nif (eeh_pe_passed(pe))\r\nreturn 0;\r\neeh_serialize_lock(&flags);\r\nrc = 1;\r\nif (pe->state & EEH_PE_ISOLATED) {\r\npe->check_count++;\r\nif (pe->check_count % EEH_MAX_FAILS == 0) {\r\npdn = eeh_dev_to_pdn(edev);\r\nif (pdn->node)\r\nlocation = of_get_property(pdn->node, "ibm,loc-code", NULL);\r\nprintk(KERN_ERR "EEH: %d reads ignored for recovering device at "\r\n"location=%s driver=%s pci addr=%s\n",\r\npe->check_count,\r\nlocation ? location : "unknown",\r\neeh_driver_name(dev), eeh_pci_name(dev));\r\nprintk(KERN_ERR "EEH: Might be infinite loop in %s driver\n",\r\neeh_driver_name(dev));\r\ndump_stack();\r\n}\r\ngoto dn_unlock;\r\n}\r\nret = eeh_ops->get_state(pe, NULL);\r\nif ((ret < 0) ||\r\n(ret == EEH_STATE_NOT_SUPPORT) ||\r\n((ret & active_flags) == active_flags)) {\r\neeh_stats.false_positives++;\r\npe->false_positives++;\r\nrc = 0;\r\ngoto dn_unlock;\r\n}\r\nparent_pe = pe->parent;\r\nwhile (parent_pe) {\r\nif (parent_pe->type & EEH_PE_PHB)\r\nbreak;\r\nret = eeh_ops->get_state(parent_pe, NULL);\r\nif (ret > 0 &&\r\n(ret & active_flags) != active_flags)\r\npe = parent_pe;\r\nparent_pe = parent_pe->parent;\r\n}\r\neeh_stats.slot_resets++;\r\neeh_pe_state_mark(pe, EEH_PE_ISOLATED);\r\neeh_serialize_unlock(flags);\r\nphb_pe = eeh_phb_pe_get(pe->phb);\r\npr_err("EEH: Frozen PHB#%x-PE#%x detected\n",\r\npe->phb->global_number, pe->addr);\r\npr_err("EEH: PE location: %s, PHB location: %s\n",\r\neeh_pe_loc_get(pe), eeh_pe_loc_get(phb_pe));\r\ndump_stack();\r\neeh_send_failure_event(pe);\r\nreturn 1;\r\ndn_unlock:\r\neeh_serialize_unlock(flags);\r\nreturn rc;\r\n}\r\nint eeh_check_failure(const volatile void __iomem *token)\r\n{\r\nunsigned long addr;\r\nstruct eeh_dev *edev;\r\naddr = eeh_token_to_phys((unsigned long __force) token);\r\nedev = eeh_addr_cache_get_dev(addr);\r\nif (!edev) {\r\neeh_stats.no_device++;\r\nreturn 0;\r\n}\r\nreturn eeh_dev_check_failure(edev);\r\n}\r\nint eeh_pci_enable(struct eeh_pe *pe, int function)\r\n{\r\nint active_flag, rc;\r\nswitch (function) {\r\ncase EEH_OPT_THAW_MMIO:\r\nactive_flag = EEH_STATE_MMIO_ACTIVE | EEH_STATE_MMIO_ENABLED;\r\nbreak;\r\ncase EEH_OPT_THAW_DMA:\r\nactive_flag = EEH_STATE_DMA_ACTIVE;\r\nbreak;\r\ncase EEH_OPT_DISABLE:\r\ncase EEH_OPT_ENABLE:\r\ncase EEH_OPT_FREEZE_PE:\r\nactive_flag = 0;\r\nbreak;\r\ndefault:\r\npr_warn("%s: Invalid function %d\n",\r\n__func__, function);\r\nreturn -EINVAL;\r\n}\r\nif (active_flag) {\r\nrc = eeh_ops->get_state(pe, NULL);\r\nif (rc < 0)\r\nreturn rc;\r\nif (rc == EEH_STATE_NOT_SUPPORT)\r\nreturn 0;\r\nif (rc & active_flag)\r\nreturn 0;\r\n}\r\nrc = eeh_ops->set_option(pe, function);\r\nif (rc)\r\npr_warn("%s: Unexpected state change %d on "\r\n"PHB#%d-PE#%x, err=%d\n",\r\n__func__, function, pe->phb->global_number,\r\npe->addr, rc);\r\nif (active_flag) {\r\nrc = eeh_ops->wait_state(pe, PCI_BUS_RESET_WAIT_MSEC);\r\nif (rc <= 0)\r\nreturn rc;\r\nif (rc & active_flag)\r\nreturn 0;\r\nreturn -EIO;\r\n}\r\nreturn rc;\r\n}\r\nstatic void *eeh_disable_and_save_dev_state(void *data, void *userdata)\r\n{\r\nstruct eeh_dev *edev = data;\r\nstruct pci_dev *pdev = eeh_dev_to_pci_dev(edev);\r\nstruct pci_dev *dev = userdata;\r\nif (!pdev || pdev == dev)\r\nreturn NULL;\r\npci_set_power_state(pdev, PCI_D0);\r\npci_save_state(pdev);\r\npci_write_config_word(pdev, PCI_COMMAND, PCI_COMMAND_INTX_DISABLE);\r\nreturn NULL;\r\n}\r\nstatic void *eeh_restore_dev_state(void *data, void *userdata)\r\n{\r\nstruct eeh_dev *edev = data;\r\nstruct pci_dn *pdn = eeh_dev_to_pdn(edev);\r\nstruct pci_dev *pdev = eeh_dev_to_pci_dev(edev);\r\nstruct pci_dev *dev = userdata;\r\nif (!pdev)\r\nreturn NULL;\r\nif (pdn && eeh_ops->restore_config)\r\neeh_ops->restore_config(pdn);\r\nif (pdev != dev)\r\npci_restore_state(pdev);\r\nreturn NULL;\r\n}\r\nint pcibios_set_pcie_reset_state(struct pci_dev *dev, enum pcie_reset_state state)\r\n{\r\nstruct eeh_dev *edev = pci_dev_to_eeh_dev(dev);\r\nstruct eeh_pe *pe = eeh_dev_to_pe(edev);\r\nif (!pe) {\r\npr_err("%s: No PE found on PCI device %s\n",\r\n__func__, pci_name(dev));\r\nreturn -EINVAL;\r\n}\r\nswitch (state) {\r\ncase pcie_deassert_reset:\r\neeh_ops->reset(pe, EEH_RESET_DEACTIVATE);\r\neeh_unfreeze_pe(pe, false);\r\neeh_pe_state_clear(pe, EEH_PE_CFG_BLOCKED);\r\neeh_pe_dev_traverse(pe, eeh_restore_dev_state, dev);\r\neeh_pe_state_clear(pe, EEH_PE_ISOLATED);\r\nbreak;\r\ncase pcie_hot_reset:\r\neeh_pe_state_mark_with_cfg(pe, EEH_PE_ISOLATED);\r\neeh_ops->set_option(pe, EEH_OPT_FREEZE_PE);\r\neeh_pe_dev_traverse(pe, eeh_disable_and_save_dev_state, dev);\r\neeh_pe_state_mark(pe, EEH_PE_CFG_BLOCKED);\r\neeh_ops->reset(pe, EEH_RESET_HOT);\r\nbreak;\r\ncase pcie_warm_reset:\r\neeh_pe_state_mark_with_cfg(pe, EEH_PE_ISOLATED);\r\neeh_ops->set_option(pe, EEH_OPT_FREEZE_PE);\r\neeh_pe_dev_traverse(pe, eeh_disable_and_save_dev_state, dev);\r\neeh_pe_state_mark(pe, EEH_PE_CFG_BLOCKED);\r\neeh_ops->reset(pe, EEH_RESET_FUNDAMENTAL);\r\nbreak;\r\ndefault:\r\neeh_pe_state_clear(pe, EEH_PE_ISOLATED | EEH_PE_CFG_BLOCKED);\r\nreturn -EINVAL;\r\n};\r\nreturn 0;\r\n}\r\nstatic void *eeh_set_dev_freset(void *data, void *flag)\r\n{\r\nstruct pci_dev *dev;\r\nunsigned int *freset = (unsigned int *)flag;\r\nstruct eeh_dev *edev = (struct eeh_dev *)data;\r\ndev = eeh_dev_to_pci_dev(edev);\r\nif (dev)\r\n*freset |= dev->needs_freset;\r\nreturn NULL;\r\n}\r\nstatic void eeh_reset_pe_once(struct eeh_pe *pe)\r\n{\r\nunsigned int freset = 0;\r\neeh_pe_dev_traverse(pe, eeh_set_dev_freset, &freset);\r\nif (freset)\r\neeh_ops->reset(pe, EEH_RESET_FUNDAMENTAL);\r\nelse\r\neeh_ops->reset(pe, EEH_RESET_HOT);\r\neeh_ops->reset(pe, EEH_RESET_DEACTIVATE);\r\n}\r\nint eeh_reset_pe(struct eeh_pe *pe)\r\n{\r\nint flags = (EEH_STATE_MMIO_ACTIVE | EEH_STATE_DMA_ACTIVE);\r\nint i, state, ret;\r\neeh_pe_state_mark(pe, EEH_PE_RESET | EEH_PE_CFG_BLOCKED);\r\nfor (i = 0; i < 3; i++) {\r\neeh_reset_pe_once(pe);\r\nstate = eeh_ops->wait_state(pe, PCI_BUS_RESET_WAIT_MSEC);\r\nif ((state & flags) == flags) {\r\nret = 0;\r\ngoto out;\r\n}\r\nif (state < 0) {\r\npr_warn("%s: Unrecoverable slot failure on PHB#%d-PE#%x",\r\n__func__, pe->phb->global_number, pe->addr);\r\nret = -ENOTRECOVERABLE;\r\ngoto out;\r\n}\r\nret = -EIO;\r\npr_warn("%s: Failure %d resetting PHB#%x-PE#%x\n (%d)\n",\r\n__func__, state, pe->phb->global_number, pe->addr, (i + 1));\r\n}\r\nout:\r\neeh_pe_state_clear(pe, EEH_PE_RESET | EEH_PE_CFG_BLOCKED);\r\nreturn ret;\r\n}\r\nvoid eeh_save_bars(struct eeh_dev *edev)\r\n{\r\nstruct pci_dn *pdn;\r\nint i;\r\npdn = eeh_dev_to_pdn(edev);\r\nif (!pdn)\r\nreturn;\r\nfor (i = 0; i < 16; i++)\r\neeh_ops->read_config(pdn, i * 4, 4, &edev->config_space[i]);\r\nif (edev->mode & EEH_DEV_BRIDGE)\r\nedev->config_space[1] |= PCI_COMMAND_MASTER;\r\n}\r\nint __init eeh_ops_register(struct eeh_ops *ops)\r\n{\r\nif (!ops->name) {\r\npr_warn("%s: Invalid EEH ops name for %p\n",\r\n__func__, ops);\r\nreturn -EINVAL;\r\n}\r\nif (eeh_ops && eeh_ops != ops) {\r\npr_warn("%s: EEH ops of platform %s already existing (%s)\n",\r\n__func__, eeh_ops->name, ops->name);\r\nreturn -EEXIST;\r\n}\r\neeh_ops = ops;\r\nreturn 0;\r\n}\r\nint __exit eeh_ops_unregister(const char *name)\r\n{\r\nif (!name || !strlen(name)) {\r\npr_warn("%s: Invalid EEH ops name\n",\r\n__func__);\r\nreturn -EINVAL;\r\n}\r\nif (eeh_ops && !strcmp(eeh_ops->name, name)) {\r\neeh_ops = NULL;\r\nreturn 0;\r\n}\r\nreturn -EEXIST;\r\n}\r\nstatic int eeh_reboot_notifier(struct notifier_block *nb,\r\nunsigned long action, void *unused)\r\n{\r\neeh_clear_flag(EEH_ENABLED);\r\nreturn NOTIFY_DONE;\r\n}\r\nint eeh_init(void)\r\n{\r\nstruct pci_controller *hose, *tmp;\r\nstruct pci_dn *pdn;\r\nstatic int cnt = 0;\r\nint ret = 0;\r\nif (machine_is(powernv) && cnt++ <= 0)\r\nreturn ret;\r\nret = register_reboot_notifier(&eeh_reboot_nb);\r\nif (ret) {\r\npr_warn("%s: Failed to register notifier (%d)\n",\r\n__func__, ret);\r\nreturn ret;\r\n}\r\nif (!eeh_ops) {\r\npr_warn("%s: Platform EEH operation not found\n",\r\n__func__);\r\nreturn -EEXIST;\r\n} else if ((ret = eeh_ops->init()))\r\nreturn ret;\r\nret = eeh_event_init();\r\nif (ret)\r\nreturn ret;\r\nlist_for_each_entry_safe(hose, tmp, &hose_list, list_node) {\r\npdn = hose->pci_data;\r\ntraverse_pci_dn(pdn, eeh_ops->probe, NULL);\r\n}\r\nif (eeh_ops->post_init) {\r\nret = eeh_ops->post_init();\r\nif (ret)\r\nreturn ret;\r\n}\r\nif (eeh_enabled())\r\npr_info("EEH: PCI Enhanced I/O Error Handling Enabled\n");\r\nelse\r\npr_warn("EEH: No capable adapters found\n");\r\nreturn ret;\r\n}\r\nvoid eeh_add_device_early(struct pci_dn *pdn)\r\n{\r\nstruct pci_controller *phb;\r\nstruct eeh_dev *edev = pdn_to_eeh_dev(pdn);\r\nif (!edev || !eeh_enabled())\r\nreturn;\r\nif (!eeh_has_flag(EEH_PROBE_MODE_DEVTREE))\r\nreturn;\r\nphb = edev->phb;\r\nif (NULL == phb ||\r\n(eeh_has_flag(EEH_PROBE_MODE_DEVTREE) && 0 == phb->buid))\r\nreturn;\r\neeh_ops->probe(pdn, NULL);\r\n}\r\nvoid eeh_add_device_tree_early(struct pci_dn *pdn)\r\n{\r\nstruct pci_dn *n;\r\nif (!pdn)\r\nreturn;\r\nlist_for_each_entry(n, &pdn->child_list, list)\r\neeh_add_device_tree_early(n);\r\neeh_add_device_early(pdn);\r\n}\r\nvoid eeh_add_device_late(struct pci_dev *dev)\r\n{\r\nstruct pci_dn *pdn;\r\nstruct eeh_dev *edev;\r\nif (!dev || !eeh_enabled())\r\nreturn;\r\npr_debug("EEH: Adding device %s\n", pci_name(dev));\r\npdn = pci_get_pdn_by_devfn(dev->bus, dev->devfn);\r\nedev = pdn_to_eeh_dev(pdn);\r\nif (edev->pdev == dev) {\r\npr_debug("EEH: Already referenced !\n");\r\nreturn;\r\n}\r\nif (edev->pdev) {\r\neeh_rmv_from_parent_pe(edev);\r\neeh_addr_cache_rmv_dev(edev->pdev);\r\neeh_sysfs_remove_device(edev->pdev);\r\nedev->mode &= ~EEH_DEV_SYSFS;\r\nedev->mode |= EEH_DEV_NO_HANDLER;\r\nedev->pdev = NULL;\r\ndev->dev.archdata.edev = NULL;\r\n}\r\nif (eeh_has_flag(EEH_PROBE_MODE_DEV))\r\neeh_ops->probe(pdn, NULL);\r\nedev->pdev = dev;\r\ndev->dev.archdata.edev = edev;\r\neeh_addr_cache_insert_dev(dev);\r\n}\r\nvoid eeh_add_device_tree_late(struct pci_bus *bus)\r\n{\r\nstruct pci_dev *dev;\r\nlist_for_each_entry(dev, &bus->devices, bus_list) {\r\neeh_add_device_late(dev);\r\nif (dev->hdr_type == PCI_HEADER_TYPE_BRIDGE) {\r\nstruct pci_bus *subbus = dev->subordinate;\r\nif (subbus)\r\neeh_add_device_tree_late(subbus);\r\n}\r\n}\r\n}\r\nvoid eeh_add_sysfs_files(struct pci_bus *bus)\r\n{\r\nstruct pci_dev *dev;\r\nlist_for_each_entry(dev, &bus->devices, bus_list) {\r\neeh_sysfs_add_device(dev);\r\nif (dev->hdr_type == PCI_HEADER_TYPE_BRIDGE) {\r\nstruct pci_bus *subbus = dev->subordinate;\r\nif (subbus)\r\neeh_add_sysfs_files(subbus);\r\n}\r\n}\r\n}\r\nvoid eeh_remove_device(struct pci_dev *dev)\r\n{\r\nstruct eeh_dev *edev;\r\nif (!dev || !eeh_enabled())\r\nreturn;\r\nedev = pci_dev_to_eeh_dev(dev);\r\npr_debug("EEH: Removing device %s\n", pci_name(dev));\r\nif (!edev || !edev->pdev || !edev->pe) {\r\npr_debug("EEH: Not referenced !\n");\r\nreturn;\r\n}\r\nedev->pdev = NULL;\r\ndev->dev.archdata.edev = NULL;\r\nif (!(edev->pe->state & EEH_PE_KEEP))\r\neeh_rmv_from_parent_pe(edev);\r\nelse\r\nedev->mode |= EEH_DEV_DISCONNECTED;\r\nedev->mode |= EEH_DEV_NO_HANDLER;\r\neeh_addr_cache_rmv_dev(dev);\r\neeh_sysfs_remove_device(dev);\r\nedev->mode &= ~EEH_DEV_SYSFS;\r\n}\r\nint eeh_unfreeze_pe(struct eeh_pe *pe, bool sw_state)\r\n{\r\nint ret;\r\nret = eeh_pci_enable(pe, EEH_OPT_THAW_MMIO);\r\nif (ret) {\r\npr_warn("%s: Failure %d enabling IO on PHB#%x-PE#%x\n",\r\n__func__, ret, pe->phb->global_number, pe->addr);\r\nreturn ret;\r\n}\r\nret = eeh_pci_enable(pe, EEH_OPT_THAW_DMA);\r\nif (ret) {\r\npr_warn("%s: Failure %d enabling DMA on PHB#%x-PE#%x\n",\r\n__func__, ret, pe->phb->global_number, pe->addr);\r\nreturn ret;\r\n}\r\nif (sw_state && (pe->state & EEH_PE_ISOLATED))\r\neeh_pe_state_clear(pe, EEH_PE_ISOLATED);\r\nreturn ret;\r\n}\r\nstatic int eeh_pe_change_owner(struct eeh_pe *pe)\r\n{\r\nstruct eeh_dev *edev, *tmp;\r\nstruct pci_dev *pdev;\r\nstruct pci_device_id *id;\r\nint flags, ret;\r\nflags = (EEH_STATE_MMIO_ACTIVE | EEH_STATE_DMA_ACTIVE);\r\nret = eeh_ops->get_state(pe, NULL);\r\nif (ret < 0 || ret == EEH_STATE_NOT_SUPPORT)\r\nreturn 0;\r\nif ((ret & flags) == flags)\r\nreturn 0;\r\neeh_pe_for_each_dev(pe, edev, tmp) {\r\npdev = eeh_dev_to_pci_dev(edev);\r\nif (!pdev)\r\ncontinue;\r\nfor (id = &eeh_reset_ids[0]; id->vendor != 0; id++) {\r\nif (id->vendor != PCI_ANY_ID &&\r\nid->vendor != pdev->vendor)\r\ncontinue;\r\nif (id->device != PCI_ANY_ID &&\r\nid->device != pdev->device)\r\ncontinue;\r\nif (id->subvendor != PCI_ANY_ID &&\r\nid->subvendor != pdev->subsystem_vendor)\r\ncontinue;\r\nif (id->subdevice != PCI_ANY_ID &&\r\nid->subdevice != pdev->subsystem_device)\r\ncontinue;\r\ngoto reset;\r\n}\r\n}\r\nreturn eeh_unfreeze_pe(pe, true);\r\nreset:\r\nreturn eeh_pe_reset_and_recover(pe);\r\n}\r\nint eeh_dev_open(struct pci_dev *pdev)\r\n{\r\nstruct eeh_dev *edev;\r\nint ret = -ENODEV;\r\nmutex_lock(&eeh_dev_mutex);\r\nif (!pdev)\r\ngoto out;\r\nedev = pci_dev_to_eeh_dev(pdev);\r\nif (!edev || !edev->pe)\r\ngoto out;\r\nret = eeh_pe_change_owner(edev->pe);\r\nif (ret)\r\ngoto out;\r\natomic_inc(&edev->pe->pass_dev_cnt);\r\nmutex_unlock(&eeh_dev_mutex);\r\nreturn 0;\r\nout:\r\nmutex_unlock(&eeh_dev_mutex);\r\nreturn ret;\r\n}\r\nvoid eeh_dev_release(struct pci_dev *pdev)\r\n{\r\nstruct eeh_dev *edev;\r\nmutex_lock(&eeh_dev_mutex);\r\nif (!pdev)\r\ngoto out;\r\nedev = pci_dev_to_eeh_dev(pdev);\r\nif (!edev || !edev->pe || !eeh_pe_passed(edev->pe))\r\ngoto out;\r\nWARN_ON(atomic_dec_if_positive(&edev->pe->pass_dev_cnt) < 0);\r\neeh_pe_change_owner(edev->pe);\r\nout:\r\nmutex_unlock(&eeh_dev_mutex);\r\n}\r\nstatic int dev_has_iommu_table(struct device *dev, void *data)\r\n{\r\nstruct pci_dev *pdev = to_pci_dev(dev);\r\nstruct pci_dev **ppdev = data;\r\nif (!dev)\r\nreturn 0;\r\nif (dev->iommu_group) {\r\n*ppdev = pdev;\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}\r\nstruct eeh_pe *eeh_iommu_group_to_pe(struct iommu_group *group)\r\n{\r\nstruct pci_dev *pdev = NULL;\r\nstruct eeh_dev *edev;\r\nint ret;\r\nif (!group)\r\nreturn NULL;\r\nret = iommu_group_for_each_dev(group, &pdev, dev_has_iommu_table);\r\nif (!ret || !pdev)\r\nreturn NULL;\r\nedev = pci_dev_to_eeh_dev(pdev);\r\nif (!edev || !edev->pe)\r\nreturn NULL;\r\nreturn edev->pe;\r\n}\r\nint eeh_pe_set_option(struct eeh_pe *pe, int option)\r\n{\r\nint ret = 0;\r\nif (!pe)\r\nreturn -ENODEV;\r\nswitch (option) {\r\ncase EEH_OPT_ENABLE:\r\nif (eeh_enabled()) {\r\nret = eeh_pe_change_owner(pe);\r\nbreak;\r\n}\r\nret = -EIO;\r\nbreak;\r\ncase EEH_OPT_DISABLE:\r\nbreak;\r\ncase EEH_OPT_THAW_MMIO:\r\ncase EEH_OPT_THAW_DMA:\r\nif (!eeh_ops || !eeh_ops->set_option) {\r\nret = -ENOENT;\r\nbreak;\r\n}\r\nret = eeh_pci_enable(pe, option);\r\nbreak;\r\ndefault:\r\npr_debug("%s: Option %d out of range (%d, %d)\n",\r\n__func__, option, EEH_OPT_DISABLE, EEH_OPT_THAW_DMA);\r\nret = -EINVAL;\r\n}\r\nreturn ret;\r\n}\r\nint eeh_pe_get_state(struct eeh_pe *pe)\r\n{\r\nint result, ret = 0;\r\nbool rst_active, dma_en, mmio_en;\r\nif (!pe)\r\nreturn -ENODEV;\r\nif (!eeh_ops || !eeh_ops->get_state)\r\nreturn -ENOENT;\r\nresult = eeh_ops->get_state(pe, NULL);\r\nrst_active = !!(result & EEH_STATE_RESET_ACTIVE);\r\ndma_en = !!(result & EEH_STATE_DMA_ENABLED);\r\nmmio_en = !!(result & EEH_STATE_MMIO_ENABLED);\r\nif (rst_active)\r\nret = EEH_PE_STATE_RESET;\r\nelse if (dma_en && mmio_en)\r\nret = EEH_PE_STATE_NORMAL;\r\nelse if (!dma_en && !mmio_en)\r\nret = EEH_PE_STATE_STOPPED_IO_DMA;\r\nelse if (!dma_en && mmio_en)\r\nret = EEH_PE_STATE_STOPPED_DMA;\r\nelse\r\nret = EEH_PE_STATE_UNAVAIL;\r\nreturn ret;\r\n}\r\nstatic int eeh_pe_reenable_devices(struct eeh_pe *pe)\r\n{\r\nstruct eeh_dev *edev, *tmp;\r\nstruct pci_dev *pdev;\r\nint ret = 0;\r\neeh_pe_restore_bars(pe);\r\neeh_pe_for_each_dev(pe, edev, tmp) {\r\npdev = eeh_dev_to_pci_dev(edev);\r\nif (!pdev)\r\ncontinue;\r\nret = pci_reenable_device(pdev);\r\nif (ret) {\r\npr_warn("%s: Failure %d reenabling %s\n",\r\n__func__, ret, pci_name(pdev));\r\nreturn ret;\r\n}\r\n}\r\nreturn eeh_unfreeze_pe(pe, true);\r\n}\r\nint eeh_pe_reset(struct eeh_pe *pe, int option)\r\n{\r\nint ret = 0;\r\nif (!pe)\r\nreturn -ENODEV;\r\nif (!eeh_ops || !eeh_ops->set_option || !eeh_ops->reset)\r\nreturn -ENOENT;\r\nswitch (option) {\r\ncase EEH_RESET_DEACTIVATE:\r\nret = eeh_ops->reset(pe, option);\r\neeh_pe_state_clear(pe, EEH_PE_CFG_BLOCKED);\r\nif (ret)\r\nbreak;\r\nret = eeh_pe_reenable_devices(pe);\r\nbreak;\r\ncase EEH_RESET_HOT:\r\ncase EEH_RESET_FUNDAMENTAL:\r\neeh_ops->set_option(pe, EEH_OPT_FREEZE_PE);\r\neeh_pe_state_mark(pe, EEH_PE_CFG_BLOCKED);\r\nret = eeh_ops->reset(pe, option);\r\nbreak;\r\ndefault:\r\npr_debug("%s: Unsupported option %d\n",\r\n__func__, option);\r\nret = -EINVAL;\r\n}\r\nreturn ret;\r\n}\r\nint eeh_pe_configure(struct eeh_pe *pe)\r\n{\r\nint ret = 0;\r\nif (!pe)\r\nreturn -ENODEV;\r\nreturn ret;\r\n}\r\nint eeh_pe_inject_err(struct eeh_pe *pe, int type, int func,\r\nunsigned long addr, unsigned long mask)\r\n{\r\nif (!pe)\r\nreturn -ENODEV;\r\nif (!eeh_ops || !eeh_ops->err_inject)\r\nreturn -ENOENT;\r\nif (type != EEH_ERR_TYPE_32 && type != EEH_ERR_TYPE_64)\r\nreturn -EINVAL;\r\nif (func < EEH_ERR_FUNC_MIN || func > EEH_ERR_FUNC_MAX)\r\nreturn -EINVAL;\r\nreturn eeh_ops->err_inject(pe, type, func, addr, mask);\r\n}\r\nstatic int proc_eeh_show(struct seq_file *m, void *v)\r\n{\r\nif (!eeh_enabled()) {\r\nseq_printf(m, "EEH Subsystem is globally disabled\n");\r\nseq_printf(m, "eeh_total_mmio_ffs=%llu\n", eeh_stats.total_mmio_ffs);\r\n} else {\r\nseq_printf(m, "EEH Subsystem is enabled\n");\r\nseq_printf(m,\r\n"no device=%llu\n"\r\n"no device node=%llu\n"\r\n"no config address=%llu\n"\r\n"check not wanted=%llu\n"\r\n"eeh_total_mmio_ffs=%llu\n"\r\n"eeh_false_positives=%llu\n"\r\n"eeh_slot_resets=%llu\n",\r\neeh_stats.no_device,\r\neeh_stats.no_dn,\r\neeh_stats.no_cfg_addr,\r\neeh_stats.ignored_check,\r\neeh_stats.total_mmio_ffs,\r\neeh_stats.false_positives,\r\neeh_stats.slot_resets);\r\n}\r\nreturn 0;\r\n}\r\nstatic int proc_eeh_open(struct inode *inode, struct file *file)\r\n{\r\nreturn single_open(file, proc_eeh_show, NULL);\r\n}\r\nstatic int eeh_enable_dbgfs_set(void *data, u64 val)\r\n{\r\nif (val)\r\neeh_clear_flag(EEH_FORCE_DISABLED);\r\nelse\r\neeh_add_flag(EEH_FORCE_DISABLED);\r\nif (eeh_ops->post_init)\r\neeh_ops->post_init();\r\nreturn 0;\r\n}\r\nstatic int eeh_enable_dbgfs_get(void *data, u64 *val)\r\n{\r\nif (eeh_enabled())\r\n*val = 0x1ul;\r\nelse\r\n*val = 0x0ul;\r\nreturn 0;\r\n}\r\nstatic int eeh_freeze_dbgfs_set(void *data, u64 val)\r\n{\r\neeh_max_freezes = val;\r\nreturn 0;\r\n}\r\nstatic int eeh_freeze_dbgfs_get(void *data, u64 *val)\r\n{\r\n*val = eeh_max_freezes;\r\nreturn 0;\r\n}\r\nstatic int __init eeh_init_proc(void)\r\n{\r\nif (machine_is(pseries) || machine_is(powernv)) {\r\nproc_create("powerpc/eeh", 0, NULL, &proc_eeh_operations);\r\n#ifdef CONFIG_DEBUG_FS\r\ndebugfs_create_file("eeh_enable", 0600,\r\npowerpc_debugfs_root, NULL,\r\n&eeh_enable_dbgfs_ops);\r\ndebugfs_create_file("eeh_max_freezes", 0600,\r\npowerpc_debugfs_root, NULL,\r\n&eeh_freeze_dbgfs_ops);\r\n#endif\r\n}\r\nreturn 0;\r\n}
