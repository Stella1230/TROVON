static void number_of_connections(struct mei_cl_device *cldev)\r\n{\r\ndev_dbg(&cldev->dev, "running hook %s on %pUl\n",\r\n__func__, mei_me_cl_uuid(cldev->me_cl));\r\nif (cldev->me_cl->props.max_number_of_connections > 1)\r\ncldev->do_match = 0;\r\n}\r\nstatic void blacklist(struct mei_cl_device *cldev)\r\n{\r\ndev_dbg(&cldev->dev, "running hook %s on %pUl\n",\r\n__func__, mei_me_cl_uuid(cldev->me_cl));\r\ncldev->do_match = 0;\r\n}\r\nstatic int mei_nfc_if_version(struct mei_cl *cl,\r\nstruct mei_nfc_if_version *ver)\r\n{\r\nstruct mei_device *bus;\r\nstruct mei_nfc_cmd cmd = {\r\n.command = MEI_NFC_CMD_MAINTENANCE,\r\n.data_size = 1,\r\n.sub_command = MEI_NFC_SUBCMD_IF_VERSION,\r\n};\r\nstruct mei_nfc_reply *reply = NULL;\r\nsize_t if_version_length;\r\nint bytes_recv, ret;\r\nbus = cl->dev;\r\nWARN_ON(mutex_is_locked(&bus->device_lock));\r\nret = __mei_cl_send(cl, (u8 *)&cmd, sizeof(struct mei_nfc_cmd), 1);\r\nif (ret < 0) {\r\ndev_err(bus->dev, "Could not send IF version cmd\n");\r\nreturn ret;\r\n}\r\nif_version_length = sizeof(struct mei_nfc_reply) +\r\nsizeof(struct mei_nfc_if_version);\r\nreply = kzalloc(if_version_length, GFP_KERNEL);\r\nif (!reply)\r\nreturn -ENOMEM;\r\nret = 0;\r\nbytes_recv = __mei_cl_recv(cl, (u8 *)reply, if_version_length);\r\nif (bytes_recv < 0 || bytes_recv < sizeof(struct mei_nfc_reply)) {\r\ndev_err(bus->dev, "Could not read IF version\n");\r\nret = -EIO;\r\ngoto err;\r\n}\r\nmemcpy(ver, reply->data, sizeof(struct mei_nfc_if_version));\r\ndev_info(bus->dev, "NFC MEI VERSION: IVN 0x%x Vendor ID 0x%x Type 0x%x\n",\r\nver->fw_ivn, ver->vendor_id, ver->radio_type);\r\nerr:\r\nkfree(reply);\r\nreturn ret;\r\n}\r\nstatic const char *mei_nfc_radio_name(struct mei_nfc_if_version *ver)\r\n{\r\nif (ver->vendor_id == MEI_NFC_VENDOR_INSIDE) {\r\nif (ver->radio_type == MEI_NFC_VENDOR_INSIDE_UREAD)\r\nreturn "microread";\r\n}\r\nif (ver->vendor_id == MEI_NFC_VENDOR_NXP) {\r\nif (ver->radio_type == MEI_NFC_VENDOR_NXP_PN544)\r\nreturn "pn544";\r\n}\r\nreturn NULL;\r\n}\r\nstatic void mei_nfc(struct mei_cl_device *cldev)\r\n{\r\nstruct mei_device *bus;\r\nstruct mei_cl *cl;\r\nstruct mei_me_client *me_cl = NULL;\r\nstruct mei_nfc_if_version ver;\r\nconst char *radio_name = NULL;\r\nint ret;\r\nbus = cldev->bus;\r\ndev_dbg(bus->dev, "running hook %s: %pUl match=%d\n",\r\n__func__, mei_me_cl_uuid(cldev->me_cl), cldev->do_match);\r\nmutex_lock(&bus->device_lock);\r\ncl = mei_cl_alloc_linked(bus, MEI_HOST_CLIENT_ID_ANY);\r\nif (IS_ERR(cl)) {\r\nret = PTR_ERR(cl);\r\ncl = NULL;\r\ndev_err(bus->dev, "nfc hook alloc failed %d\n", ret);\r\ngoto out;\r\n}\r\nme_cl = mei_me_cl_by_uuid(bus, &mei_nfc_info_guid);\r\nif (!me_cl) {\r\nret = -ENOTTY;\r\ndev_err(bus->dev, "Cannot find nfc info %d\n", ret);\r\ngoto out;\r\n}\r\nret = mei_cl_connect(cl, me_cl, NULL);\r\nif (ret < 0) {\r\ndev_err(&cldev->dev, "Can't connect to the NFC INFO ME ret = %d\n",\r\nret);\r\ngoto out;\r\n}\r\nmutex_unlock(&bus->device_lock);\r\nret = mei_nfc_if_version(cl, &ver);\r\nif (ret)\r\ngoto disconnect;\r\nradio_name = mei_nfc_radio_name(&ver);\r\nif (!radio_name) {\r\nret = -ENOENT;\r\ndev_err(&cldev->dev, "Can't get the NFC interface version ret = %d\n",\r\nret);\r\ngoto disconnect;\r\n}\r\ndev_dbg(bus->dev, "nfc radio %s\n", radio_name);\r\nstrlcpy(cldev->name, radio_name, sizeof(cldev->name));\r\ndisconnect:\r\nmutex_lock(&bus->device_lock);\r\nif (mei_cl_disconnect(cl) < 0)\r\ndev_err(bus->dev, "Can't disconnect the NFC INFO ME\n");\r\nmei_cl_flush_queues(cl, NULL);\r\nout:\r\nmei_cl_unlink(cl);\r\nmutex_unlock(&bus->device_lock);\r\nmei_me_cl_put(me_cl);\r\nkfree(cl);\r\nif (ret)\r\ncldev->do_match = 0;\r\ndev_dbg(bus->dev, "end of fixup match = %d\n", cldev->do_match);\r\n}\r\nvoid mei_cl_bus_dev_fixup(struct mei_cl_device *cldev)\r\n{\r\nstruct mei_fixup *f;\r\nconst uuid_le *uuid = mei_me_cl_uuid(cldev->me_cl);\r\nint i;\r\nfor (i = 0; i < ARRAY_SIZE(mei_fixups); i++) {\r\nf = &mei_fixups[i];\r\nif (uuid_le_cmp(f->uuid, MEI_UUID_ANY) == 0 ||\r\nuuid_le_cmp(f->uuid, *uuid) == 0)\r\nf->hook(cldev);\r\n}\r\n}
