static int __fsl_mc_device_remove_if_not_in_mc(struct device *dev, void *data)\r\n{\r\nint i;\r\nstruct dprc_child_objs *objs;\r\nstruct fsl_mc_device *mc_dev;\r\nWARN_ON(!dev);\r\nWARN_ON(!data);\r\nmc_dev = to_fsl_mc_device(dev);\r\nobjs = data;\r\nfor (i = 0; i < objs->child_count; i++) {\r\nstruct dprc_obj_desc *obj_desc = &objs->child_array[i];\r\nif (strlen(obj_desc->type) != 0 &&\r\nFSL_MC_DEVICE_MATCH(mc_dev, obj_desc))\r\nbreak;\r\n}\r\nif (i == objs->child_count)\r\nfsl_mc_device_remove(mc_dev);\r\nreturn 0;\r\n}\r\nstatic int __fsl_mc_device_remove(struct device *dev, void *data)\r\n{\r\nWARN_ON(!dev);\r\nWARN_ON(data);\r\nfsl_mc_device_remove(to_fsl_mc_device(dev));\r\nreturn 0;\r\n}\r\nstatic void dprc_remove_devices(struct fsl_mc_device *mc_bus_dev,\r\nstruct dprc_obj_desc *obj_desc_array,\r\nint num_child_objects_in_mc)\r\n{\r\nif (num_child_objects_in_mc != 0) {\r\nstruct dprc_child_objs objs;\r\nobjs.child_count = num_child_objects_in_mc;\r\nobjs.child_array = obj_desc_array;\r\ndevice_for_each_child(&mc_bus_dev->dev, &objs,\r\n__fsl_mc_device_remove_if_not_in_mc);\r\n} else {\r\ndevice_for_each_child(&mc_bus_dev->dev, NULL,\r\n__fsl_mc_device_remove);\r\n}\r\n}\r\nstatic int __fsl_mc_device_match(struct device *dev, void *data)\r\n{\r\nstruct dprc_obj_desc *obj_desc = data;\r\nstruct fsl_mc_device *mc_dev = to_fsl_mc_device(dev);\r\nreturn FSL_MC_DEVICE_MATCH(mc_dev, obj_desc);\r\n}\r\nstatic struct fsl_mc_device *fsl_mc_device_lookup(struct dprc_obj_desc\r\n*obj_desc,\r\nstruct fsl_mc_device\r\n*mc_bus_dev)\r\n{\r\nstruct device *dev;\r\ndev = device_find_child(&mc_bus_dev->dev, obj_desc,\r\n__fsl_mc_device_match);\r\nreturn dev ? to_fsl_mc_device(dev) : NULL;\r\n}\r\nstatic void check_plugged_state_change(struct fsl_mc_device *mc_dev,\r\nstruct dprc_obj_desc *obj_desc)\r\n{\r\nint error;\r\nu32 plugged_flag_at_mc =\r\n(obj_desc->state & DPRC_OBJ_STATE_PLUGGED);\r\nif (plugged_flag_at_mc !=\r\n(mc_dev->obj_desc.state & DPRC_OBJ_STATE_PLUGGED)) {\r\nif (plugged_flag_at_mc) {\r\nmc_dev->obj_desc.state |= DPRC_OBJ_STATE_PLUGGED;\r\nerror = device_attach(&mc_dev->dev);\r\nif (error < 0) {\r\ndev_err(&mc_dev->dev,\r\n"device_attach() failed: %d\n",\r\nerror);\r\n}\r\n} else {\r\nmc_dev->obj_desc.state &= ~DPRC_OBJ_STATE_PLUGGED;\r\ndevice_release_driver(&mc_dev->dev);\r\n}\r\n}\r\n}\r\nstatic void dprc_add_new_devices(struct fsl_mc_device *mc_bus_dev,\r\nstruct dprc_obj_desc *obj_desc_array,\r\nint num_child_objects_in_mc)\r\n{\r\nint error;\r\nint i;\r\nfor (i = 0; i < num_child_objects_in_mc; i++) {\r\nstruct fsl_mc_device *child_dev;\r\nstruct dprc_obj_desc *obj_desc = &obj_desc_array[i];\r\nif (strlen(obj_desc->type) == 0)\r\ncontinue;\r\nchild_dev = fsl_mc_device_lookup(obj_desc, mc_bus_dev);\r\nif (child_dev) {\r\ncheck_plugged_state_change(child_dev, obj_desc);\r\ncontinue;\r\n}\r\nerror = fsl_mc_device_add(obj_desc, NULL, &mc_bus_dev->dev,\r\n&child_dev);\r\nif (error < 0)\r\ncontinue;\r\n}\r\n}\r\nstatic void dprc_init_all_resource_pools(struct fsl_mc_device *mc_bus_dev)\r\n{\r\nint pool_type;\r\nstruct fsl_mc_bus *mc_bus = to_fsl_mc_bus(mc_bus_dev);\r\nfor (pool_type = 0; pool_type < FSL_MC_NUM_POOL_TYPES; pool_type++) {\r\nstruct fsl_mc_resource_pool *res_pool =\r\n&mc_bus->resource_pools[pool_type];\r\nres_pool->type = pool_type;\r\nres_pool->max_count = 0;\r\nres_pool->free_count = 0;\r\nres_pool->mc_bus = mc_bus;\r\nINIT_LIST_HEAD(&res_pool->free_list);\r\nmutex_init(&res_pool->mutex);\r\n}\r\n}\r\nstatic void dprc_cleanup_resource_pool(struct fsl_mc_device *mc_bus_dev,\r\nenum fsl_mc_pool_type pool_type)\r\n{\r\nstruct fsl_mc_resource *resource;\r\nstruct fsl_mc_resource *next;\r\nstruct fsl_mc_bus *mc_bus = to_fsl_mc_bus(mc_bus_dev);\r\nstruct fsl_mc_resource_pool *res_pool =\r\n&mc_bus->resource_pools[pool_type];\r\nint free_count = 0;\r\nWARN_ON(res_pool->type != pool_type);\r\nWARN_ON(res_pool->free_count != res_pool->max_count);\r\nlist_for_each_entry_safe(resource, next, &res_pool->free_list, node) {\r\nfree_count++;\r\nWARN_ON(resource->type != res_pool->type);\r\nWARN_ON(resource->parent_pool != res_pool);\r\ndevm_kfree(&mc_bus_dev->dev, resource);\r\n}\r\nWARN_ON(free_count != res_pool->free_count);\r\n}\r\nstatic void dprc_cleanup_all_resource_pools(struct fsl_mc_device *mc_bus_dev)\r\n{\r\nint pool_type;\r\nfor (pool_type = 0; pool_type < FSL_MC_NUM_POOL_TYPES; pool_type++)\r\ndprc_cleanup_resource_pool(mc_bus_dev, pool_type);\r\n}\r\nint dprc_scan_objects(struct fsl_mc_device *mc_bus_dev)\r\n{\r\nint num_child_objects;\r\nint dprc_get_obj_failures;\r\nint error;\r\nstruct dprc_obj_desc *child_obj_desc_array = NULL;\r\nerror = dprc_get_obj_count(mc_bus_dev->mc_io,\r\n0,\r\nmc_bus_dev->mc_handle,\r\n&num_child_objects);\r\nif (error < 0) {\r\ndev_err(&mc_bus_dev->dev, "dprc_get_obj_count() failed: %d\n",\r\nerror);\r\nreturn error;\r\n}\r\nif (num_child_objects != 0) {\r\nint i;\r\nchild_obj_desc_array =\r\ndevm_kmalloc_array(&mc_bus_dev->dev, num_child_objects,\r\nsizeof(*child_obj_desc_array),\r\nGFP_KERNEL);\r\nif (!child_obj_desc_array)\r\nreturn -ENOMEM;\r\ndprc_get_obj_failures = 0;\r\nfor (i = 0; i < num_child_objects; i++) {\r\nstruct dprc_obj_desc *obj_desc =\r\n&child_obj_desc_array[i];\r\nerror = dprc_get_obj(mc_bus_dev->mc_io,\r\n0,\r\nmc_bus_dev->mc_handle,\r\ni, obj_desc);\r\nif (error < 0) {\r\ndev_err(&mc_bus_dev->dev,\r\n"dprc_get_obj(i=%d) failed: %d\n",\r\ni, error);\r\nobj_desc->type[0] = '\0';\r\nobj_desc->id = error;\r\ndprc_get_obj_failures++;\r\ncontinue;\r\n}\r\ndev_dbg(&mc_bus_dev->dev,\r\n"Discovered object: type %s, id %d\n",\r\nobj_desc->type, obj_desc->id);\r\n}\r\nif (dprc_get_obj_failures != 0) {\r\ndev_err(&mc_bus_dev->dev,\r\n"%d out of %d devices could not be retrieved\n",\r\ndprc_get_obj_failures, num_child_objects);\r\n}\r\n}\r\ndprc_remove_devices(mc_bus_dev, child_obj_desc_array,\r\nnum_child_objects);\r\ndprc_add_new_devices(mc_bus_dev, child_obj_desc_array,\r\nnum_child_objects);\r\nif (child_obj_desc_array)\r\ndevm_kfree(&mc_bus_dev->dev, child_obj_desc_array);\r\nreturn 0;\r\n}\r\nint dprc_scan_container(struct fsl_mc_device *mc_bus_dev)\r\n{\r\nint error;\r\nstruct fsl_mc_bus *mc_bus = to_fsl_mc_bus(mc_bus_dev);\r\ndprc_init_all_resource_pools(mc_bus_dev);\r\nmutex_lock(&mc_bus->scan_mutex);\r\nerror = dprc_scan_objects(mc_bus_dev);\r\nmutex_unlock(&mc_bus->scan_mutex);\r\nif (error < 0)\r\ngoto error;\r\nreturn 0;\r\nerror:\r\ndprc_cleanup_all_resource_pools(mc_bus_dev);\r\nreturn error;\r\n}\r\nstatic int dprc_probe(struct fsl_mc_device *mc_dev)\r\n{\r\nint error;\r\nsize_t region_size;\r\nstruct fsl_mc_bus *mc_bus = to_fsl_mc_bus(mc_dev);\r\nif (WARN_ON(strcmp(mc_dev->obj_desc.type, "dprc") != 0))\r\nreturn -EINVAL;\r\nif (!mc_dev->mc_io) {\r\nif (WARN_ON(mc_dev->obj_desc.region_count == 0))\r\nreturn -EINVAL;\r\nregion_size = mc_dev->regions[0].end -\r\nmc_dev->regions[0].start + 1;\r\nerror = fsl_create_mc_io(&mc_dev->dev,\r\nmc_dev->regions[0].start,\r\nregion_size,\r\nNULL, 0, &mc_dev->mc_io);\r\nif (error < 0)\r\nreturn error;\r\n}\r\nerror = dprc_open(mc_dev->mc_io, 0, mc_dev->obj_desc.id,\r\n&mc_dev->mc_handle);\r\nif (error < 0) {\r\ndev_err(&mc_dev->dev, "dprc_open() failed: %d\n", error);\r\ngoto error_cleanup_mc_io;\r\n}\r\nmutex_init(&mc_bus->scan_mutex);\r\nerror = dprc_scan_container(mc_dev);\r\nif (error < 0)\r\ngoto error_cleanup_open;\r\ndev_info(&mc_dev->dev, "DPRC device bound to driver");\r\nreturn 0;\r\nerror_cleanup_open:\r\n(void)dprc_close(mc_dev->mc_io, 0, mc_dev->mc_handle);\r\nerror_cleanup_mc_io:\r\nfsl_destroy_mc_io(mc_dev->mc_io);\r\nreturn error;\r\n}\r\nstatic int dprc_remove(struct fsl_mc_device *mc_dev)\r\n{\r\nint error;\r\nif (WARN_ON(strcmp(mc_dev->obj_desc.type, "dprc") != 0))\r\nreturn -EINVAL;\r\nif (WARN_ON(!mc_dev->mc_io))\r\nreturn -EINVAL;\r\ndevice_for_each_child(&mc_dev->dev, NULL, __fsl_mc_device_remove);\r\ndprc_cleanup_all_resource_pools(mc_dev);\r\nerror = dprc_close(mc_dev->mc_io, 0, mc_dev->mc_handle);\r\nif (error < 0)\r\ndev_err(&mc_dev->dev, "dprc_close() failed: %d\n", error);\r\ndev_info(&mc_dev->dev, "DPRC device unbound from driver");\r\nreturn 0;\r\n}\r\nint __init dprc_driver_init(void)\r\n{\r\nreturn fsl_mc_driver_register(&dprc_driver);\r\n}\r\nvoid dprc_driver_exit(void)\r\n{\r\nfsl_mc_driver_unregister(&dprc_driver);\r\n}
