static void fatal(const char *x, ...)\r\n{\r\nva_list ap;\r\nva_start(ap, x);\r\nvfprintf(stderr, x, ap);\r\nva_end(ap);\r\nexit(EXIT_FAILURE);\r\n}\r\nstatic void usage(void)\r\n{\r\nprintf("slabinfo 4/15/2011. (c) 2007 sgi/(c) 2011 Linux Foundation.\n\n"\r\n"slabinfo [-ahnpvtsz] [-d debugopts] [slab-regexp]\n"\r\n"-a|--aliases Show aliases\n"\r\n"-A|--activity Most active slabs first\n"\r\n"-d<options>|--debug=<options> Set/Clear Debug options\n"\r\n"-D|--display-active Switch line format to activity\n"\r\n"-e|--empty Show empty slabs\n"\r\n"-f|--first-alias Show first alias\n"\r\n"-h|--help Show usage information\n"\r\n"-i|--inverted Inverted list\n"\r\n"-l|--slabs Show slabs\n"\r\n"-n|--numa Show NUMA information\n"\r\n"-o|--ops Show kmem_cache_ops\n"\r\n"-s|--shrink Shrink slabs\n"\r\n"-r|--report Detailed report on single slabs\n"\r\n"-S|--Size Sort by size\n"\r\n"-t|--tracking Show alloc/free information\n"\r\n"-T|--Totals Show summary information\n"\r\n"-v|--validate Validate slabs\n"\r\n"-z|--zero Include empty slabs\n"\r\n"-1|--1ref Single reference\n"\r\n"-N|--lines=K Show the first K slabs\n"\r\n"-L|--Loss Sort by loss\n"\r\n"-X|--Xtotals Show extended summary information\n"\r\n"-B|--Bytes Show size in bytes\n"\r\n"\nValid debug options (FZPUT may be combined)\n"\r\n"a / A Switch on all debug options (=FZUP)\n"\r\n"- Switch off all debug options\n"\r\n"f / F Sanity Checks (SLAB_DEBUG_FREE)\n"\r\n"z / Z Redzoning\n"\r\n"p / P Poisoning\n"\r\n"u / U Tracking\n"\r\n"t / T Tracing\n"\r\n);\r\n}\r\nstatic unsigned long read_obj(const char *name)\r\n{\r\nFILE *f = fopen(name, "r");\r\nif (!f)\r\nbuffer[0] = 0;\r\nelse {\r\nif (!fgets(buffer, sizeof(buffer), f))\r\nbuffer[0] = 0;\r\nfclose(f);\r\nif (buffer[strlen(buffer)] == '\n')\r\nbuffer[strlen(buffer)] = 0;\r\n}\r\nreturn strlen(buffer);\r\n}\r\nstatic unsigned long get_obj(const char *name)\r\n{\r\nif (!read_obj(name))\r\nreturn 0;\r\nreturn atol(buffer);\r\n}\r\nstatic unsigned long get_obj_and_str(const char *name, char **x)\r\n{\r\nunsigned long result = 0;\r\nchar *p;\r\n*x = NULL;\r\nif (!read_obj(name)) {\r\nx = NULL;\r\nreturn 0;\r\n}\r\nresult = strtoul(buffer, &p, 10);\r\nwhile (*p == ' ')\r\np++;\r\nif (*p)\r\n*x = strdup(p);\r\nreturn result;\r\n}\r\nstatic void set_obj(struct slabinfo *s, const char *name, int n)\r\n{\r\nchar x[100];\r\nFILE *f;\r\nsnprintf(x, 100, "%s/%s", s->name, name);\r\nf = fopen(x, "w");\r\nif (!f)\r\nfatal("Cannot write to %s\n", x);\r\nfprintf(f, "%d\n", n);\r\nfclose(f);\r\n}\r\nstatic unsigned long read_slab_obj(struct slabinfo *s, const char *name)\r\n{\r\nchar x[100];\r\nFILE *f;\r\nsize_t l;\r\nsnprintf(x, 100, "%s/%s", s->name, name);\r\nf = fopen(x, "r");\r\nif (!f) {\r\nbuffer[0] = 0;\r\nl = 0;\r\n} else {\r\nl = fread(buffer, 1, sizeof(buffer), f);\r\nbuffer[l] = 0;\r\nfclose(f);\r\n}\r\nreturn l;\r\n}\r\nstatic int store_size(char *buffer, unsigned long value)\r\n{\r\nunsigned long divisor = 1;\r\nchar trailer = 0;\r\nint n;\r\nif (!show_bytes) {\r\nif (value > 1000000000UL) {\r\ndivisor = 100000000UL;\r\ntrailer = 'G';\r\n} else if (value > 1000000UL) {\r\ndivisor = 100000UL;\r\ntrailer = 'M';\r\n} else if (value > 1000UL) {\r\ndivisor = 100;\r\ntrailer = 'K';\r\n}\r\n}\r\nvalue /= divisor;\r\nn = sprintf(buffer, "%ld",value);\r\nif (trailer) {\r\nbuffer[n] = trailer;\r\nn++;\r\nbuffer[n] = 0;\r\n}\r\nif (divisor != 1) {\r\nmemmove(buffer + n - 2, buffer + n - 3, 4);\r\nbuffer[n-2] = '.';\r\nn++;\r\n}\r\nreturn n;\r\n}\r\nstatic void decode_numa_list(int *numa, char *t)\r\n{\r\nint node;\r\nint nr;\r\nmemset(numa, 0, MAX_NODES * sizeof(int));\r\nif (!t)\r\nreturn;\r\nwhile (*t == 'N') {\r\nt++;\r\nnode = strtoul(t, &t, 10);\r\nif (*t == '=') {\r\nt++;\r\nnr = strtoul(t, &t, 10);\r\nnuma[node] = nr;\r\nif (node > highest_node)\r\nhighest_node = node;\r\n}\r\nwhile (*t == ' ')\r\nt++;\r\n}\r\n}\r\nstatic void slab_validate(struct slabinfo *s)\r\n{\r\nif (strcmp(s->name, "*") == 0)\r\nreturn;\r\nset_obj(s, "validate", 1);\r\n}\r\nstatic void slab_shrink(struct slabinfo *s)\r\n{\r\nif (strcmp(s->name, "*") == 0)\r\nreturn;\r\nset_obj(s, "shrink", 1);\r\n}\r\nstatic void first_line(void)\r\n{\r\nif (show_activity)\r\nprintf("Name Objects Alloc Free"\r\n" %%Fast Fallb O CmpX UL\n");\r\nelse\r\nprintf("Name Objects Objsize %s "\r\n"Slabs/Part/Cpu O/S O %%Fr %%Ef Flg\n",\r\nsort_loss ? " Loss" : "Space");\r\n}\r\nstatic struct aliasinfo *find_one_alias(struct slabinfo *find)\r\n{\r\nstruct aliasinfo *a;\r\nstruct aliasinfo *best = NULL;\r\nfor(a = aliasinfo;a < aliasinfo + aliases; a++) {\r\nif (a->slab == find &&\r\n(!best || strlen(best->name) < strlen(a->name))) {\r\nbest = a;\r\nif (strncmp(a->name,"kmall", 5) == 0)\r\nreturn best;\r\n}\r\n}\r\nreturn best;\r\n}\r\nstatic unsigned long slab_size(struct slabinfo *s)\r\n{\r\nreturn s->slabs * (page_size << s->order);\r\n}\r\nstatic unsigned long slab_activity(struct slabinfo *s)\r\n{\r\nreturn s->alloc_fastpath + s->free_fastpath +\r\ns->alloc_slowpath + s->free_slowpath;\r\n}\r\nstatic unsigned long slab_waste(struct slabinfo *s)\r\n{\r\nreturn slab_size(s) - s->objects * s->object_size;\r\n}\r\nstatic void slab_numa(struct slabinfo *s, int mode)\r\n{\r\nint node;\r\nif (strcmp(s->name, "*") == 0)\r\nreturn;\r\nif (!highest_node) {\r\nprintf("\n%s: No NUMA information available.\n", s->name);\r\nreturn;\r\n}\r\nif (skip_zero && !s->slabs)\r\nreturn;\r\nif (!line) {\r\nprintf("\n%-21s:", mode ? "NUMA nodes" : "Slab");\r\nfor(node = 0; node <= highest_node; node++)\r\nprintf(" %4d", node);\r\nprintf("\n----------------------");\r\nfor(node = 0; node <= highest_node; node++)\r\nprintf("-----");\r\nprintf("\n");\r\n}\r\nprintf("%-21s ", mode ? "All slabs" : s->name);\r\nfor(node = 0; node <= highest_node; node++) {\r\nchar b[20];\r\nstore_size(b, s->numa[node]);\r\nprintf(" %4s", b);\r\n}\r\nprintf("\n");\r\nif (mode) {\r\nprintf("%-21s ", "Partial slabs");\r\nfor(node = 0; node <= highest_node; node++) {\r\nchar b[20];\r\nstore_size(b, s->numa_partial[node]);\r\nprintf(" %4s", b);\r\n}\r\nprintf("\n");\r\n}\r\nline++;\r\n}\r\nstatic void show_tracking(struct slabinfo *s)\r\n{\r\nprintf("\n%s: Kernel object allocation\n", s->name);\r\nprintf("-----------------------------------------------------------------------\n");\r\nif (read_slab_obj(s, "alloc_calls"))\r\nprintf("%s", buffer);\r\nelse\r\nprintf("No Data\n");\r\nprintf("\n%s: Kernel object freeing\n", s->name);\r\nprintf("------------------------------------------------------------------------\n");\r\nif (read_slab_obj(s, "free_calls"))\r\nprintf("%s", buffer);\r\nelse\r\nprintf("No Data\n");\r\n}\r\nstatic void ops(struct slabinfo *s)\r\n{\r\nif (strcmp(s->name, "*") == 0)\r\nreturn;\r\nif (read_slab_obj(s, "ops")) {\r\nprintf("\n%s: kmem_cache operations\n", s->name);\r\nprintf("--------------------------------------------\n");\r\nprintf("%s", buffer);\r\n} else\r\nprintf("\n%s has no kmem_cache operations\n", s->name);\r\n}\r\nstatic const char *onoff(int x)\r\n{\r\nif (x)\r\nreturn "On ";\r\nreturn "Off";\r\n}\r\nstatic void slab_stats(struct slabinfo *s)\r\n{\r\nunsigned long total_alloc;\r\nunsigned long total_free;\r\nunsigned long total;\r\nif (!s->alloc_slab)\r\nreturn;\r\ntotal_alloc = s->alloc_fastpath + s->alloc_slowpath;\r\ntotal_free = s->free_fastpath + s->free_slowpath;\r\nif (!total_alloc)\r\nreturn;\r\nprintf("\n");\r\nprintf("Slab Perf Counter Alloc Free %%Al %%Fr\n");\r\nprintf("--------------------------------------------------\n");\r\nprintf("Fastpath %8lu %8lu %3lu %3lu\n",\r\ns->alloc_fastpath, s->free_fastpath,\r\ns->alloc_fastpath * 100 / total_alloc,\r\ntotal_free ? s->free_fastpath * 100 / total_free : 0);\r\nprintf("Slowpath %8lu %8lu %3lu %3lu\n",\r\ntotal_alloc - s->alloc_fastpath, s->free_slowpath,\r\n(total_alloc - s->alloc_fastpath) * 100 / total_alloc,\r\ntotal_free ? s->free_slowpath * 100 / total_free : 0);\r\nprintf("Page Alloc %8lu %8lu %3lu %3lu\n",\r\ns->alloc_slab, s->free_slab,\r\ns->alloc_slab * 100 / total_alloc,\r\ntotal_free ? s->free_slab * 100 / total_free : 0);\r\nprintf("Add partial %8lu %8lu %3lu %3lu\n",\r\ns->deactivate_to_head + s->deactivate_to_tail,\r\ns->free_add_partial,\r\n(s->deactivate_to_head + s->deactivate_to_tail) * 100 / total_alloc,\r\ntotal_free ? s->free_add_partial * 100 / total_free : 0);\r\nprintf("Remove partial %8lu %8lu %3lu %3lu\n",\r\ns->alloc_from_partial, s->free_remove_partial,\r\ns->alloc_from_partial * 100 / total_alloc,\r\ntotal_free ? s->free_remove_partial * 100 / total_free : 0);\r\nprintf("Cpu partial list %8lu %8lu %3lu %3lu\n",\r\ns->cpu_partial_alloc, s->cpu_partial_free,\r\ns->cpu_partial_alloc * 100 / total_alloc,\r\ntotal_free ? s->cpu_partial_free * 100 / total_free : 0);\r\nprintf("RemoteObj/SlabFrozen %8lu %8lu %3lu %3lu\n",\r\ns->deactivate_remote_frees, s->free_frozen,\r\ns->deactivate_remote_frees * 100 / total_alloc,\r\ntotal_free ? s->free_frozen * 100 / total_free : 0);\r\nprintf("Total %8lu %8lu\n\n", total_alloc, total_free);\r\nif (s->cpuslab_flush)\r\nprintf("Flushes %8lu\n", s->cpuslab_flush);\r\ntotal = s->deactivate_full + s->deactivate_empty +\r\ns->deactivate_to_head + s->deactivate_to_tail + s->deactivate_bypass;\r\nif (total) {\r\nprintf("\nSlab Deactivation Ocurrences %%\n");\r\nprintf("-------------------------------------------------\n");\r\nprintf("Slab full %7lu %3lu%%\n",\r\ns->deactivate_full, (s->deactivate_full * 100) / total);\r\nprintf("Slab empty %7lu %3lu%%\n",\r\ns->deactivate_empty, (s->deactivate_empty * 100) / total);\r\nprintf("Moved to head of partial list %7lu %3lu%%\n",\r\ns->deactivate_to_head, (s->deactivate_to_head * 100) / total);\r\nprintf("Moved to tail of partial list %7lu %3lu%%\n",\r\ns->deactivate_to_tail, (s->deactivate_to_tail * 100) / total);\r\nprintf("Deactivation bypass %7lu %3lu%%\n",\r\ns->deactivate_bypass, (s->deactivate_bypass * 100) / total);\r\nprintf("Refilled from foreign frees %7lu %3lu%%\n",\r\ns->alloc_refill, (s->alloc_refill * 100) / total);\r\nprintf("Node mismatch %7lu %3lu%%\n",\r\ns->alloc_node_mismatch, (s->alloc_node_mismatch * 100) / total);\r\n}\r\nif (s->cmpxchg_double_fail || s->cmpxchg_double_cpu_fail)\r\nprintf("\nCmpxchg_double Looping\n------------------------\n");\r\nprintf("Locked Cmpxchg Double redos %lu\nUnlocked Cmpxchg Double redos %lu\n",\r\ns->cmpxchg_double_fail, s->cmpxchg_double_cpu_fail);\r\n}\r\nstatic void report(struct slabinfo *s)\r\n{\r\nif (strcmp(s->name, "*") == 0)\r\nreturn;\r\nprintf("\nSlabcache: %-15s Aliases: %2d Order : %2d Objects: %lu\n",\r\ns->name, s->aliases, s->order, s->objects);\r\nif (s->hwcache_align)\r\nprintf("** Hardware cacheline aligned\n");\r\nif (s->cache_dma)\r\nprintf("** Memory is allocated in a special DMA zone\n");\r\nif (s->destroy_by_rcu)\r\nprintf("** Slabs are destroyed via RCU\n");\r\nif (s->reclaim_account)\r\nprintf("** Reclaim accounting active\n");\r\nprintf("\nSizes (bytes) Slabs Debug Memory\n");\r\nprintf("------------------------------------------------------------------------\n");\r\nprintf("Object : %7d Total : %7ld Sanity Checks : %s Total: %7ld\n",\r\ns->object_size, s->slabs, onoff(s->sanity_checks),\r\ns->slabs * (page_size << s->order));\r\nprintf("SlabObj: %7d Full : %7ld Redzoning : %s Used : %7ld\n",\r\ns->slab_size, s->slabs - s->partial - s->cpu_slabs,\r\nonoff(s->red_zone), s->objects * s->object_size);\r\nprintf("SlabSiz: %7d Partial: %7ld Poisoning : %s Loss : %7ld\n",\r\npage_size << s->order, s->partial, onoff(s->poison),\r\ns->slabs * (page_size << s->order) - s->objects * s->object_size);\r\nprintf("Loss : %7d CpuSlab: %7d Tracking : %s Lalig: %7ld\n",\r\ns->slab_size - s->object_size, s->cpu_slabs, onoff(s->store_user),\r\n(s->slab_size - s->object_size) * s->objects);\r\nprintf("Align : %7d Objects: %7d Tracing : %s Lpadd: %7ld\n",\r\ns->align, s->objs_per_slab, onoff(s->trace),\r\n((page_size << s->order) - s->objs_per_slab * s->slab_size) *\r\ns->slabs);\r\nops(s);\r\nshow_tracking(s);\r\nslab_numa(s, 1);\r\nslab_stats(s);\r\n}\r\nstatic void slabcache(struct slabinfo *s)\r\n{\r\nchar size_str[20];\r\nchar dist_str[40];\r\nchar flags[20];\r\nchar *p = flags;\r\nif (strcmp(s->name, "*") == 0)\r\nreturn;\r\nif (actual_slabs == 1) {\r\nreport(s);\r\nreturn;\r\n}\r\nif (skip_zero && !show_empty && !s->slabs)\r\nreturn;\r\nif (show_empty && s->slabs)\r\nreturn;\r\nif (sort_loss == 0)\r\nstore_size(size_str, slab_size(s));\r\nelse\r\nstore_size(size_str, slab_waste(s));\r\nsnprintf(dist_str, 40, "%lu/%lu/%d", s->slabs - s->cpu_slabs,\r\ns->partial, s->cpu_slabs);\r\nif (!line++)\r\nfirst_line();\r\nif (s->aliases)\r\n*p++ = '*';\r\nif (s->cache_dma)\r\n*p++ = 'd';\r\nif (s->hwcache_align)\r\n*p++ = 'A';\r\nif (s->poison)\r\n*p++ = 'P';\r\nif (s->reclaim_account)\r\n*p++ = 'a';\r\nif (s->red_zone)\r\n*p++ = 'Z';\r\nif (s->sanity_checks)\r\n*p++ = 'F';\r\nif (s->store_user)\r\n*p++ = 'U';\r\nif (s->trace)\r\n*p++ = 'T';\r\n*p = 0;\r\nif (show_activity) {\r\nunsigned long total_alloc;\r\nunsigned long total_free;\r\ntotal_alloc = s->alloc_fastpath + s->alloc_slowpath;\r\ntotal_free = s->free_fastpath + s->free_slowpath;\r\nprintf("%-21s %8ld %10ld %10ld %3ld %3ld %5ld %1d %4ld %4ld\n",\r\ns->name, s->objects,\r\ntotal_alloc, total_free,\r\ntotal_alloc ? (s->alloc_fastpath * 100 / total_alloc) : 0,\r\ntotal_free ? (s->free_fastpath * 100 / total_free) : 0,\r\ns->order_fallback, s->order, s->cmpxchg_double_fail,\r\ns->cmpxchg_double_cpu_fail);\r\n} else {\r\nprintf("%-21s %8ld %7d %15s %14s %4d %1d %3ld %3ld %s\n",\r\ns->name, s->objects, s->object_size, size_str, dist_str,\r\ns->objs_per_slab, s->order,\r\ns->slabs ? (s->partial * 100) / s->slabs : 100,\r\ns->slabs ? (s->objects * s->object_size * 100) /\r\n(s->slabs * (page_size << s->order)) : 100,\r\nflags);\r\n}\r\n}\r\nstatic int debug_opt_scan(char *opt)\r\n{\r\nif (!opt || !opt[0] || strcmp(opt, "-") == 0)\r\nreturn 1;\r\nif (strcasecmp(opt, "a") == 0) {\r\nsanity = 1;\r\npoison = 1;\r\nredzone = 1;\r\ntracking = 1;\r\nreturn 1;\r\n}\r\nfor ( ; *opt; opt++)\r\nswitch (*opt) {\r\ncase 'F' : case 'f':\r\nif (sanity)\r\nreturn 0;\r\nsanity = 1;\r\nbreak;\r\ncase 'P' : case 'p':\r\nif (poison)\r\nreturn 0;\r\npoison = 1;\r\nbreak;\r\ncase 'Z' : case 'z':\r\nif (redzone)\r\nreturn 0;\r\nredzone = 1;\r\nbreak;\r\ncase 'U' : case 'u':\r\nif (tracking)\r\nreturn 0;\r\ntracking = 1;\r\nbreak;\r\ncase 'T' : case 't':\r\nif (tracing)\r\nreturn 0;\r\ntracing = 1;\r\nbreak;\r\ndefault:\r\nreturn 0;\r\n}\r\nreturn 1;\r\n}\r\nstatic int slab_empty(struct slabinfo *s)\r\n{\r\nif (s->objects > 0)\r\nreturn 0;\r\nif (s->slabs != 0)\r\nset_obj(s, "shrink", 1);\r\nreturn 1;\r\n}\r\nstatic void slab_debug(struct slabinfo *s)\r\n{\r\nif (strcmp(s->name, "*") == 0)\r\nreturn;\r\nif (sanity && !s->sanity_checks) {\r\nset_obj(s, "sanity", 1);\r\n}\r\nif (!sanity && s->sanity_checks) {\r\nif (slab_empty(s))\r\nset_obj(s, "sanity", 0);\r\nelse\r\nfprintf(stderr, "%s not empty cannot disable sanity checks\n", s->name);\r\n}\r\nif (redzone && !s->red_zone) {\r\nif (slab_empty(s))\r\nset_obj(s, "red_zone", 1);\r\nelse\r\nfprintf(stderr, "%s not empty cannot enable redzoning\n", s->name);\r\n}\r\nif (!redzone && s->red_zone) {\r\nif (slab_empty(s))\r\nset_obj(s, "red_zone", 0);\r\nelse\r\nfprintf(stderr, "%s not empty cannot disable redzoning\n", s->name);\r\n}\r\nif (poison && !s->poison) {\r\nif (slab_empty(s))\r\nset_obj(s, "poison", 1);\r\nelse\r\nfprintf(stderr, "%s not empty cannot enable poisoning\n", s->name);\r\n}\r\nif (!poison && s->poison) {\r\nif (slab_empty(s))\r\nset_obj(s, "poison", 0);\r\nelse\r\nfprintf(stderr, "%s not empty cannot disable poisoning\n", s->name);\r\n}\r\nif (tracking && !s->store_user) {\r\nif (slab_empty(s))\r\nset_obj(s, "store_user", 1);\r\nelse\r\nfprintf(stderr, "%s not empty cannot enable tracking\n", s->name);\r\n}\r\nif (!tracking && s->store_user) {\r\nif (slab_empty(s))\r\nset_obj(s, "store_user", 0);\r\nelse\r\nfprintf(stderr, "%s not empty cannot disable tracking\n", s->name);\r\n}\r\nif (tracing && !s->trace) {\r\nif (slabs == 1)\r\nset_obj(s, "trace", 1);\r\nelse\r\nfprintf(stderr, "%s can only enable trace for one slab at a time\n", s->name);\r\n}\r\nif (!tracing && s->trace)\r\nset_obj(s, "trace", 1);\r\n}\r\nstatic void totals(void)\r\n{\r\nstruct slabinfo *s;\r\nint used_slabs = 0;\r\nchar b1[20], b2[20], b3[20], b4[20];\r\nunsigned long long max = 1ULL << 63;\r\nunsigned long long min_objsize = max, max_objsize = 0, avg_objsize;\r\nunsigned long long min_partial = max, max_partial = 0,\r\navg_partial, total_partial = 0;\r\nunsigned long long min_slabs = max, max_slabs = 0,\r\navg_slabs, total_slabs = 0;\r\nunsigned long long min_size = max, max_size = 0,\r\navg_size, total_size = 0;\r\nunsigned long long min_used = max, max_used = 0,\r\navg_used, total_used = 0;\r\nunsigned long long min_waste = max, max_waste = 0,\r\navg_waste, total_waste = 0;\r\nunsigned long long min_objects = max, max_objects = 0,\r\navg_objects, total_objects = 0;\r\nunsigned long long min_objwaste = max,\r\nmax_objwaste = 0, avg_objwaste,\r\ntotal_objwaste = 0;\r\nunsigned long long min_memobj = max,\r\nmax_memobj = 0, avg_memobj,\r\ntotal_objsize = 0;\r\nunsigned long min_ppart = 100, max_ppart = 0,\r\navg_ppart, total_ppart = 0;\r\nunsigned long min_partobj = max, max_partobj = 0,\r\navg_partobj, total_partobj = 0;\r\nunsigned long min_ppartobj = 100, max_ppartobj = 0,\r\navg_ppartobj, total_ppartobj = 0;\r\nfor (s = slabinfo; s < slabinfo + slabs; s++) {\r\nunsigned long long size;\r\nunsigned long used;\r\nunsigned long long wasted;\r\nunsigned long long objwaste;\r\nunsigned long percentage_partial_slabs;\r\nunsigned long percentage_partial_objs;\r\nif (!s->slabs || !s->objects)\r\ncontinue;\r\nused_slabs++;\r\nsize = slab_size(s);\r\nused = s->objects * s->object_size;\r\nwasted = size - used;\r\nobjwaste = s->slab_size - s->object_size;\r\npercentage_partial_slabs = s->partial * 100 / s->slabs;\r\nif (percentage_partial_slabs > 100)\r\npercentage_partial_slabs = 100;\r\npercentage_partial_objs = s->objects_partial * 100\r\n/ s->objects;\r\nif (percentage_partial_objs > 100)\r\npercentage_partial_objs = 100;\r\nif (s->object_size < min_objsize)\r\nmin_objsize = s->object_size;\r\nif (s->partial < min_partial)\r\nmin_partial = s->partial;\r\nif (s->slabs < min_slabs)\r\nmin_slabs = s->slabs;\r\nif (size < min_size)\r\nmin_size = size;\r\nif (wasted < min_waste)\r\nmin_waste = wasted;\r\nif (objwaste < min_objwaste)\r\nmin_objwaste = objwaste;\r\nif (s->objects < min_objects)\r\nmin_objects = s->objects;\r\nif (used < min_used)\r\nmin_used = used;\r\nif (s->objects_partial < min_partobj)\r\nmin_partobj = s->objects_partial;\r\nif (percentage_partial_slabs < min_ppart)\r\nmin_ppart = percentage_partial_slabs;\r\nif (percentage_partial_objs < min_ppartobj)\r\nmin_ppartobj = percentage_partial_objs;\r\nif (s->slab_size < min_memobj)\r\nmin_memobj = s->slab_size;\r\nif (s->object_size > max_objsize)\r\nmax_objsize = s->object_size;\r\nif (s->partial > max_partial)\r\nmax_partial = s->partial;\r\nif (s->slabs > max_slabs)\r\nmax_slabs = s->slabs;\r\nif (size > max_size)\r\nmax_size = size;\r\nif (wasted > max_waste)\r\nmax_waste = wasted;\r\nif (objwaste > max_objwaste)\r\nmax_objwaste = objwaste;\r\nif (s->objects > max_objects)\r\nmax_objects = s->objects;\r\nif (used > max_used)\r\nmax_used = used;\r\nif (s->objects_partial > max_partobj)\r\nmax_partobj = s->objects_partial;\r\nif (percentage_partial_slabs > max_ppart)\r\nmax_ppart = percentage_partial_slabs;\r\nif (percentage_partial_objs > max_ppartobj)\r\nmax_ppartobj = percentage_partial_objs;\r\nif (s->slab_size > max_memobj)\r\nmax_memobj = s->slab_size;\r\ntotal_partial += s->partial;\r\ntotal_slabs += s->slabs;\r\ntotal_size += size;\r\ntotal_waste += wasted;\r\ntotal_objects += s->objects;\r\ntotal_used += used;\r\ntotal_partobj += s->objects_partial;\r\ntotal_ppart += percentage_partial_slabs;\r\ntotal_ppartobj += percentage_partial_objs;\r\ntotal_objwaste += s->objects * objwaste;\r\ntotal_objsize += s->objects * s->slab_size;\r\n}\r\nif (!total_objects) {\r\nprintf("No objects\n");\r\nreturn;\r\n}\r\nif (!used_slabs) {\r\nprintf("No slabs\n");\r\nreturn;\r\n}\r\navg_partial = total_partial / used_slabs;\r\navg_slabs = total_slabs / used_slabs;\r\navg_size = total_size / used_slabs;\r\navg_waste = total_waste / used_slabs;\r\navg_objects = total_objects / used_slabs;\r\navg_used = total_used / used_slabs;\r\navg_partobj = total_partobj / used_slabs;\r\navg_ppart = total_ppart / used_slabs;\r\navg_ppartobj = total_ppartobj / used_slabs;\r\navg_objsize = total_used / total_objects;\r\navg_objwaste = total_objwaste / total_objects;\r\navg_partobj = total_partobj * 100 / total_objects;\r\navg_memobj = total_objsize / total_objects;\r\nprintf("Slabcache Totals\n");\r\nprintf("----------------\n");\r\nprintf("Slabcaches : %15d Aliases : %11d->%-3d Active: %3d\n",\r\nslabs, aliases, alias_targets, used_slabs);\r\nstore_size(b1, total_size);store_size(b2, total_waste);\r\nstore_size(b3, total_waste * 100 / total_used);\r\nprintf("Memory used: %15s # Loss : %15s MRatio:%6s%%\n", b1, b2, b3);\r\nstore_size(b1, total_objects);store_size(b2, total_partobj);\r\nstore_size(b3, total_partobj * 100 / total_objects);\r\nprintf("# Objects : %15s # PartObj: %15s ORatio:%6s%%\n", b1, b2, b3);\r\nprintf("\n");\r\nprintf("Per Cache Average "\r\n"Min Max Total\n");\r\nprintf("---------------------------------------"\r\n"-------------------------------------\n");\r\nstore_size(b1, avg_objects);store_size(b2, min_objects);\r\nstore_size(b3, max_objects);store_size(b4, total_objects);\r\nprintf("#Objects %15s %15s %15s %15s\n",\r\nb1, b2, b3, b4);\r\nstore_size(b1, avg_slabs);store_size(b2, min_slabs);\r\nstore_size(b3, max_slabs);store_size(b4, total_slabs);\r\nprintf("#Slabs %15s %15s %15s %15s\n",\r\nb1, b2, b3, b4);\r\nstore_size(b1, avg_partial);store_size(b2, min_partial);\r\nstore_size(b3, max_partial);store_size(b4, total_partial);\r\nprintf("#PartSlab %15s %15s %15s %15s\n",\r\nb1, b2, b3, b4);\r\nstore_size(b1, avg_ppart);store_size(b2, min_ppart);\r\nstore_size(b3, max_ppart);\r\nstore_size(b4, total_partial * 100 / total_slabs);\r\nprintf("%%PartSlab%15s%% %15s%% %15s%% %15s%%\n",\r\nb1, b2, b3, b4);\r\nstore_size(b1, avg_partobj);store_size(b2, min_partobj);\r\nstore_size(b3, max_partobj);\r\nstore_size(b4, total_partobj);\r\nprintf("PartObjs %15s %15s %15s %15s\n",\r\nb1, b2, b3, b4);\r\nstore_size(b1, avg_ppartobj);store_size(b2, min_ppartobj);\r\nstore_size(b3, max_ppartobj);\r\nstore_size(b4, total_partobj * 100 / total_objects);\r\nprintf("%% PartObj%15s%% %15s%% %15s%% %15s%%\n",\r\nb1, b2, b3, b4);\r\nstore_size(b1, avg_size);store_size(b2, min_size);\r\nstore_size(b3, max_size);store_size(b4, total_size);\r\nprintf("Memory %15s %15s %15s %15s\n",\r\nb1, b2, b3, b4);\r\nstore_size(b1, avg_used);store_size(b2, min_used);\r\nstore_size(b3, max_used);store_size(b4, total_used);\r\nprintf("Used %15s %15s %15s %15s\n",\r\nb1, b2, b3, b4);\r\nstore_size(b1, avg_waste);store_size(b2, min_waste);\r\nstore_size(b3, max_waste);store_size(b4, total_waste);\r\nprintf("Loss %15s %15s %15s %15s\n",\r\nb1, b2, b3, b4);\r\nprintf("\n");\r\nprintf("Per Object Average "\r\n"Min Max\n");\r\nprintf("---------------------------------------"\r\n"--------------------\n");\r\nstore_size(b1, avg_memobj);store_size(b2, min_memobj);\r\nstore_size(b3, max_memobj);\r\nprintf("Memory %15s %15s %15s\n",\r\nb1, b2, b3);\r\nstore_size(b1, avg_objsize);store_size(b2, min_objsize);\r\nstore_size(b3, max_objsize);\r\nprintf("User %15s %15s %15s\n",\r\nb1, b2, b3);\r\nstore_size(b1, avg_objwaste);store_size(b2, min_objwaste);\r\nstore_size(b3, max_objwaste);\r\nprintf("Loss %15s %15s %15s\n",\r\nb1, b2, b3);\r\n}\r\nstatic void sort_slabs(void)\r\n{\r\nstruct slabinfo *s1,*s2;\r\nfor (s1 = slabinfo; s1 < slabinfo + slabs; s1++) {\r\nfor (s2 = s1 + 1; s2 < slabinfo + slabs; s2++) {\r\nint result;\r\nif (sort_size)\r\nresult = slab_size(s1) < slab_size(s2);\r\nelse if (sort_active)\r\nresult = slab_activity(s1) < slab_activity(s2);\r\nelse if (sort_loss)\r\nresult = slab_waste(s1) < slab_waste(s2);\r\nelse\r\nresult = strcasecmp(s1->name, s2->name);\r\nif (show_inverted)\r\nresult = -result;\r\nif (result > 0) {\r\nstruct slabinfo t;\r\nmemcpy(&t, s1, sizeof(struct slabinfo));\r\nmemcpy(s1, s2, sizeof(struct slabinfo));\r\nmemcpy(s2, &t, sizeof(struct slabinfo));\r\n}\r\n}\r\n}\r\n}\r\nstatic void sort_aliases(void)\r\n{\r\nstruct aliasinfo *a1,*a2;\r\nfor (a1 = aliasinfo; a1 < aliasinfo + aliases; a1++) {\r\nfor (a2 = a1 + 1; a2 < aliasinfo + aliases; a2++) {\r\nchar *n1, *n2;\r\nn1 = a1->name;\r\nn2 = a2->name;\r\nif (show_alias && !show_inverted) {\r\nn1 = a1->ref;\r\nn2 = a2->ref;\r\n}\r\nif (strcasecmp(n1, n2) > 0) {\r\nstruct aliasinfo t;\r\nmemcpy(&t, a1, sizeof(struct aliasinfo));\r\nmemcpy(a1, a2, sizeof(struct aliasinfo));\r\nmemcpy(a2, &t, sizeof(struct aliasinfo));\r\n}\r\n}\r\n}\r\n}\r\nstatic void link_slabs(void)\r\n{\r\nstruct aliasinfo *a;\r\nstruct slabinfo *s;\r\nfor (a = aliasinfo; a < aliasinfo + aliases; a++) {\r\nfor (s = slabinfo; s < slabinfo + slabs; s++)\r\nif (strcmp(a->ref, s->name) == 0) {\r\na->slab = s;\r\ns->refs++;\r\nbreak;\r\n}\r\nif (s == slabinfo + slabs)\r\nfatal("Unresolved alias %s\n", a->ref);\r\n}\r\n}\r\nstatic void alias(void)\r\n{\r\nstruct aliasinfo *a;\r\nchar *active = NULL;\r\nsort_aliases();\r\nlink_slabs();\r\nfor(a = aliasinfo; a < aliasinfo + aliases; a++) {\r\nif (!show_single_ref && a->slab->refs == 1)\r\ncontinue;\r\nif (!show_inverted) {\r\nif (active) {\r\nif (strcmp(a->slab->name, active) == 0) {\r\nprintf(" %s", a->name);\r\ncontinue;\r\n}\r\n}\r\nprintf("\n%-12s <- %s", a->slab->name, a->name);\r\nactive = a->slab->name;\r\n}\r\nelse\r\nprintf("%-15s -> %s\n", a->name, a->slab->name);\r\n}\r\nif (active)\r\nprintf("\n");\r\n}\r\nstatic void rename_slabs(void)\r\n{\r\nstruct slabinfo *s;\r\nstruct aliasinfo *a;\r\nfor (s = slabinfo; s < slabinfo + slabs; s++) {\r\nif (*s->name != ':')\r\ncontinue;\r\nif (s->refs > 1 && !show_first_alias)\r\ncontinue;\r\na = find_one_alias(s);\r\nif (a)\r\ns->name = a->name;\r\nelse {\r\ns->name = "*";\r\nactual_slabs--;\r\n}\r\n}\r\n}\r\nstatic int slab_mismatch(char *slab)\r\n{\r\nreturn regexec(&pattern, slab, 0, NULL, 0);\r\n}\r\nstatic void read_slab_dir(void)\r\n{\r\nDIR *dir;\r\nstruct dirent *de;\r\nstruct slabinfo *slab = slabinfo;\r\nstruct aliasinfo *alias = aliasinfo;\r\nchar *p;\r\nchar *t;\r\nint count;\r\nif (chdir("/sys/kernel/slab") && chdir("/sys/slab"))\r\nfatal("SYSFS support for SLUB not active\n");\r\ndir = opendir(".");\r\nwhile ((de = readdir(dir))) {\r\nif (de->d_name[0] == '.' ||\r\n(de->d_name[0] != ':' && slab_mismatch(de->d_name)))\r\ncontinue;\r\nswitch (de->d_type) {\r\ncase DT_LNK:\r\nalias->name = strdup(de->d_name);\r\ncount = readlink(de->d_name, buffer, sizeof(buffer)-1);\r\nif (count < 0)\r\nfatal("Cannot read symlink %s\n", de->d_name);\r\nbuffer[count] = 0;\r\np = buffer + count;\r\nwhile (p > buffer && p[-1] != '/')\r\np--;\r\nalias->ref = strdup(p);\r\nalias++;\r\nbreak;\r\ncase DT_DIR:\r\nif (chdir(de->d_name))\r\nfatal("Unable to access slab %s\n", slab->name);\r\nslab->name = strdup(de->d_name);\r\nslab->alias = 0;\r\nslab->refs = 0;\r\nslab->aliases = get_obj("aliases");\r\nslab->align = get_obj("align");\r\nslab->cache_dma = get_obj("cache_dma");\r\nslab->cpu_slabs = get_obj("cpu_slabs");\r\nslab->destroy_by_rcu = get_obj("destroy_by_rcu");\r\nslab->hwcache_align = get_obj("hwcache_align");\r\nslab->object_size = get_obj("object_size");\r\nslab->objects = get_obj("objects");\r\nslab->objects_partial = get_obj("objects_partial");\r\nslab->objects_total = get_obj("objects_total");\r\nslab->objs_per_slab = get_obj("objs_per_slab");\r\nslab->order = get_obj("order");\r\nslab->partial = get_obj("partial");\r\nslab->partial = get_obj_and_str("partial", &t);\r\ndecode_numa_list(slab->numa_partial, t);\r\nfree(t);\r\nslab->poison = get_obj("poison");\r\nslab->reclaim_account = get_obj("reclaim_account");\r\nslab->red_zone = get_obj("red_zone");\r\nslab->sanity_checks = get_obj("sanity_checks");\r\nslab->slab_size = get_obj("slab_size");\r\nslab->slabs = get_obj_and_str("slabs", &t);\r\ndecode_numa_list(slab->numa, t);\r\nfree(t);\r\nslab->store_user = get_obj("store_user");\r\nslab->trace = get_obj("trace");\r\nslab->alloc_fastpath = get_obj("alloc_fastpath");\r\nslab->alloc_slowpath = get_obj("alloc_slowpath");\r\nslab->free_fastpath = get_obj("free_fastpath");\r\nslab->free_slowpath = get_obj("free_slowpath");\r\nslab->free_frozen= get_obj("free_frozen");\r\nslab->free_add_partial = get_obj("free_add_partial");\r\nslab->free_remove_partial = get_obj("free_remove_partial");\r\nslab->alloc_from_partial = get_obj("alloc_from_partial");\r\nslab->alloc_slab = get_obj("alloc_slab");\r\nslab->alloc_refill = get_obj("alloc_refill");\r\nslab->free_slab = get_obj("free_slab");\r\nslab->cpuslab_flush = get_obj("cpuslab_flush");\r\nslab->deactivate_full = get_obj("deactivate_full");\r\nslab->deactivate_empty = get_obj("deactivate_empty");\r\nslab->deactivate_to_head = get_obj("deactivate_to_head");\r\nslab->deactivate_to_tail = get_obj("deactivate_to_tail");\r\nslab->deactivate_remote_frees = get_obj("deactivate_remote_frees");\r\nslab->order_fallback = get_obj("order_fallback");\r\nslab->cmpxchg_double_cpu_fail = get_obj("cmpxchg_double_cpu_fail");\r\nslab->cmpxchg_double_fail = get_obj("cmpxchg_double_fail");\r\nslab->cpu_partial_alloc = get_obj("cpu_partial_alloc");\r\nslab->cpu_partial_free = get_obj("cpu_partial_free");\r\nslab->alloc_node_mismatch = get_obj("alloc_node_mismatch");\r\nslab->deactivate_bypass = get_obj("deactivate_bypass");\r\nchdir("..");\r\nif (slab->name[0] == ':')\r\nalias_targets++;\r\nslab++;\r\nbreak;\r\ndefault :\r\nfatal("Unknown file type %lx\n", de->d_type);\r\n}\r\n}\r\nclosedir(dir);\r\nslabs = slab - slabinfo;\r\nactual_slabs = slabs;\r\naliases = alias - aliasinfo;\r\nif (slabs > MAX_SLABS)\r\nfatal("Too many slabs\n");\r\nif (aliases > MAX_ALIASES)\r\nfatal("Too many aliases\n");\r\n}\r\nstatic void output_slabs(void)\r\n{\r\nstruct slabinfo *slab;\r\nint lines = output_lines;\r\nfor (slab = slabinfo; (slab < slabinfo + slabs) &&\r\nlines != 0; slab++) {\r\nif (slab->alias)\r\ncontinue;\r\nif (lines != -1)\r\nlines--;\r\nif (show_numa)\r\nslab_numa(slab, 0);\r\nelse if (show_track)\r\nshow_tracking(slab);\r\nelse if (validate)\r\nslab_validate(slab);\r\nelse if (shrink)\r\nslab_shrink(slab);\r\nelse if (set_debug)\r\nslab_debug(slab);\r\nelse if (show_ops)\r\nops(slab);\r\nelse if (show_slab)\r\nslabcache(slab);\r\nelse if (show_report)\r\nreport(slab);\r\n}\r\n}\r\nstatic void xtotals(void)\r\n{\r\ntotals();\r\nlink_slabs();\r\nrename_slabs();\r\nprintf("\nSlabs sorted by size\n");\r\nprintf("--------------------\n");\r\nsort_loss = 0;\r\nsort_size = 1;\r\nsort_slabs();\r\noutput_slabs();\r\nprintf("\nSlabs sorted by loss\n");\r\nprintf("--------------------\n");\r\nline = 0;\r\nsort_loss = 1;\r\nsort_size = 0;\r\nsort_slabs();\r\noutput_slabs();\r\nprintf("\n");\r\n}\r\nint main(int argc, char *argv[])\r\n{\r\nint c;\r\nint err;\r\nchar *pattern_source;\r\npage_size = getpagesize();\r\nwhile ((c = getopt_long(argc, argv, "aAd::Defhil1noprstvzTSN:LXB",\r\nopts, NULL)) != -1)\r\nswitch (c) {\r\ncase '1':\r\nshow_single_ref = 1;\r\nbreak;\r\ncase 'a':\r\nshow_alias = 1;\r\nbreak;\r\ncase 'A':\r\nsort_active = 1;\r\nbreak;\r\ncase 'd':\r\nset_debug = 1;\r\nif (!debug_opt_scan(optarg))\r\nfatal("Invalid debug option '%s'\n", optarg);\r\nbreak;\r\ncase 'D':\r\nshow_activity = 1;\r\nbreak;\r\ncase 'e':\r\nshow_empty = 1;\r\nbreak;\r\ncase 'f':\r\nshow_first_alias = 1;\r\nbreak;\r\ncase 'h':\r\nusage();\r\nreturn 0;\r\ncase 'i':\r\nshow_inverted = 1;\r\nbreak;\r\ncase 'n':\r\nshow_numa = 1;\r\nbreak;\r\ncase 'o':\r\nshow_ops = 1;\r\nbreak;\r\ncase 'r':\r\nshow_report = 1;\r\nbreak;\r\ncase 's':\r\nshrink = 1;\r\nbreak;\r\ncase 'l':\r\nshow_slab = 1;\r\nbreak;\r\ncase 't':\r\nshow_track = 1;\r\nbreak;\r\ncase 'v':\r\nvalidate = 1;\r\nbreak;\r\ncase 'z':\r\nskip_zero = 0;\r\nbreak;\r\ncase 'T':\r\nshow_totals = 1;\r\nbreak;\r\ncase 'S':\r\nsort_size = 1;\r\nbreak;\r\ncase 'N':\r\nif (optarg) {\r\noutput_lines = atoi(optarg);\r\nif (output_lines < 1)\r\noutput_lines = 1;\r\n}\r\nbreak;\r\ncase 'L':\r\nsort_loss = 1;\r\nbreak;\r\ncase 'X':\r\nif (output_lines == -1)\r\noutput_lines = 1;\r\nextended_totals = 1;\r\nshow_bytes = 1;\r\nbreak;\r\ncase 'B':\r\nshow_bytes = 1;\r\nbreak;\r\ndefault:\r\nfatal("%s: Invalid option '%c'\n", argv[0], optopt);\r\n}\r\nif (!show_slab && !show_alias && !show_track && !show_report\r\n&& !validate && !shrink && !set_debug && !show_ops)\r\nshow_slab = 1;\r\nif (argc > optind)\r\npattern_source = argv[optind];\r\nelse\r\npattern_source = ".*";\r\nerr = regcomp(&pattern, pattern_source, REG_ICASE|REG_NOSUB);\r\nif (err)\r\nfatal("%s: Invalid pattern '%s' code %d\n",\r\nargv[0], pattern_source, err);\r\nread_slab_dir();\r\nif (show_alias) {\r\nalias();\r\n} else if (extended_totals) {\r\nxtotals();\r\n} else if (show_totals) {\r\ntotals();\r\n} else {\r\nlink_slabs();\r\nrename_slabs();\r\nsort_slabs();\r\noutput_slabs();\r\n}\r\nreturn 0;\r\n}
