static void decode_irq_flags(struct pnp_dev *dev, int flags, u8 *triggering,\r\nu8 *polarity, u8 *shareable)\r\n{\r\nswitch (flags & (IORESOURCE_IRQ_LOWLEVEL | IORESOURCE_IRQ_HIGHLEVEL |\r\nIORESOURCE_IRQ_LOWEDGE | IORESOURCE_IRQ_HIGHEDGE)) {\r\ncase IORESOURCE_IRQ_LOWLEVEL:\r\n*triggering = ACPI_LEVEL_SENSITIVE;\r\n*polarity = ACPI_ACTIVE_LOW;\r\nbreak;\r\ncase IORESOURCE_IRQ_HIGHLEVEL:\r\n*triggering = ACPI_LEVEL_SENSITIVE;\r\n*polarity = ACPI_ACTIVE_HIGH;\r\nbreak;\r\ncase IORESOURCE_IRQ_LOWEDGE:\r\n*triggering = ACPI_EDGE_SENSITIVE;\r\n*polarity = ACPI_ACTIVE_LOW;\r\nbreak;\r\ncase IORESOURCE_IRQ_HIGHEDGE:\r\n*triggering = ACPI_EDGE_SENSITIVE;\r\n*polarity = ACPI_ACTIVE_HIGH;\r\nbreak;\r\ndefault:\r\ndev_err(&dev->dev, "can't encode invalid IRQ mode %#x\n",\r\nflags);\r\n*triggering = ACPI_EDGE_SENSITIVE;\r\n*polarity = ACPI_ACTIVE_HIGH;\r\nbreak;\r\n}\r\nif (flags & IORESOURCE_IRQ_SHAREABLE)\r\n*shareable = ACPI_SHARED;\r\nelse\r\n*shareable = ACPI_EXCLUSIVE;\r\n}\r\nstatic int dma_flags(struct pnp_dev *dev, int type, int bus_master,\r\nint transfer)\r\n{\r\nint flags = 0;\r\nif (bus_master)\r\nflags |= IORESOURCE_DMA_MASTER;\r\nswitch (type) {\r\ncase ACPI_COMPATIBILITY:\r\nflags |= IORESOURCE_DMA_COMPATIBLE;\r\nbreak;\r\ncase ACPI_TYPE_A:\r\nflags |= IORESOURCE_DMA_TYPEA;\r\nbreak;\r\ncase ACPI_TYPE_B:\r\nflags |= IORESOURCE_DMA_TYPEB;\r\nbreak;\r\ncase ACPI_TYPE_F:\r\nflags |= IORESOURCE_DMA_TYPEF;\r\nbreak;\r\ndefault:\r\nflags |= IORESOURCE_DMA_COMPATIBLE;\r\ndev_err(&dev->dev, "invalid DMA type %d\n", type);\r\n}\r\nswitch (transfer) {\r\ncase ACPI_TRANSFER_8:\r\nflags |= IORESOURCE_DMA_8BIT;\r\nbreak;\r\ncase ACPI_TRANSFER_8_16:\r\nflags |= IORESOURCE_DMA_8AND16BIT;\r\nbreak;\r\ncase ACPI_TRANSFER_16:\r\nflags |= IORESOURCE_DMA_16BIT;\r\nbreak;\r\ndefault:\r\nflags |= IORESOURCE_DMA_8AND16BIT;\r\ndev_err(&dev->dev, "invalid DMA transfer type %d\n", transfer);\r\n}\r\nreturn flags;\r\n}\r\nstatic void pnpacpi_add_irqresource(struct pnp_dev *dev, struct resource *r)\r\n{\r\nif (!(r->flags & IORESOURCE_DISABLED))\r\npcibios_penalize_isa_irq(r->start, 1);\r\npnp_add_resource(dev, r);\r\n}\r\nstatic int vendor_resource_matches(struct pnp_dev *dev,\r\nstruct acpi_resource_vendor_typed *vendor,\r\nstruct acpi_vendor_uuid *match,\r\nint expected_len)\r\n{\r\nint uuid_len = sizeof(vendor->uuid);\r\nu8 uuid_subtype = vendor->uuid_subtype;\r\nu8 *uuid = vendor->uuid;\r\nint actual_len;\r\nactual_len = vendor->byte_length - uuid_len - 1;\r\nif (uuid_subtype == match->subtype &&\r\nuuid_len == sizeof(match->data) &&\r\nmemcmp(uuid, match->data, uuid_len) == 0) {\r\nif (expected_len && expected_len != actual_len) {\r\ndev_err(&dev->dev, "wrong vendor descriptor size; "\r\n"expected %d, found %d bytes\n",\r\nexpected_len, actual_len);\r\nreturn 0;\r\n}\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}\r\nstatic void pnpacpi_parse_allocated_vendor(struct pnp_dev *dev,\r\nstruct acpi_resource_vendor_typed *vendor)\r\n{\r\nif (vendor_resource_matches(dev, vendor, &hp_ccsr_uuid, 16)) {\r\nu64 start, length;\r\nmemcpy(&start, vendor->byte_data, sizeof(start));\r\nmemcpy(&length, vendor->byte_data + 8, sizeof(length));\r\npnp_add_mem_resource(dev, start, start + length - 1, 0);\r\n}\r\n}\r\nstatic acpi_status pnpacpi_allocated_resource(struct acpi_resource *res,\r\nvoid *data)\r\n{\r\nstruct pnp_dev *dev = data;\r\nstruct acpi_resource_dma *dma;\r\nstruct acpi_resource_vendor_typed *vendor_typed;\r\nstruct resource_win win = {{0}, 0};\r\nstruct resource *r = &win.res;\r\nint i, flags;\r\nif (acpi_dev_resource_address_space(res, &win)\r\n|| acpi_dev_resource_ext_address_space(res, &win)) {\r\npnp_add_resource(dev, &win.res);\r\nreturn AE_OK;\r\n}\r\nr->flags = 0;\r\nif (acpi_dev_resource_interrupt(res, 0, r)) {\r\npnpacpi_add_irqresource(dev, r);\r\nfor (i = 1; acpi_dev_resource_interrupt(res, i, r); i++)\r\npnpacpi_add_irqresource(dev, r);\r\nif (i > 1) {\r\nif (pnp_can_write(dev)) {\r\ndev_warn(&dev->dev, "multiple interrupts in "\r\n"_CRS descriptor; configuration can't "\r\n"be changed\n");\r\ndev->capabilities &= ~PNP_WRITE;\r\n}\r\n}\r\nreturn AE_OK;\r\n} else if (r->flags & IORESOURCE_DISABLED) {\r\npnp_add_irq_resource(dev, 0, IORESOURCE_DISABLED);\r\nreturn AE_OK;\r\n}\r\nswitch (res->type) {\r\ncase ACPI_RESOURCE_TYPE_MEMORY24:\r\ncase ACPI_RESOURCE_TYPE_MEMORY32:\r\ncase ACPI_RESOURCE_TYPE_FIXED_MEMORY32:\r\nif (acpi_dev_resource_memory(res, r))\r\npnp_add_resource(dev, r);\r\nbreak;\r\ncase ACPI_RESOURCE_TYPE_IO:\r\ncase ACPI_RESOURCE_TYPE_FIXED_IO:\r\nif (acpi_dev_resource_io(res, r))\r\npnp_add_resource(dev, r);\r\nbreak;\r\ncase ACPI_RESOURCE_TYPE_DMA:\r\ndma = &res->data.dma;\r\nif (dma->channel_count > 0 && dma->channels[0] != (u8) -1)\r\nflags = dma_flags(dev, dma->type, dma->bus_master,\r\ndma->transfer);\r\nelse\r\nflags = IORESOURCE_DISABLED;\r\npnp_add_dma_resource(dev, dma->channels[0], flags);\r\nbreak;\r\ncase ACPI_RESOURCE_TYPE_START_DEPENDENT:\r\ncase ACPI_RESOURCE_TYPE_END_DEPENDENT:\r\nbreak;\r\ncase ACPI_RESOURCE_TYPE_VENDOR:\r\nvendor_typed = &res->data.vendor_typed;\r\npnpacpi_parse_allocated_vendor(dev, vendor_typed);\r\nbreak;\r\ncase ACPI_RESOURCE_TYPE_END_TAG:\r\nbreak;\r\ncase ACPI_RESOURCE_TYPE_GENERIC_REGISTER:\r\nbreak;\r\ndefault:\r\ndev_warn(&dev->dev, "unknown resource type %d in _CRS\n",\r\nres->type);\r\nreturn AE_ERROR;\r\n}\r\nreturn AE_OK;\r\n}\r\nint pnpacpi_parse_allocated_resource(struct pnp_dev *dev)\r\n{\r\nstruct acpi_device *acpi_dev = dev->data;\r\nacpi_handle handle = acpi_dev->handle;\r\nacpi_status status;\r\npnp_dbg(&dev->dev, "parse allocated resources\n");\r\npnp_init_resources(dev);\r\nstatus = acpi_walk_resources(handle, METHOD_NAME__CRS,\r\npnpacpi_allocated_resource, dev);\r\nif (ACPI_FAILURE(status)) {\r\nif (status != AE_NOT_FOUND)\r\ndev_err(&dev->dev, "can't evaluate _CRS: %d", status);\r\nreturn -EPERM;\r\n}\r\nreturn 0;\r\n}\r\nstatic __init void pnpacpi_parse_dma_option(struct pnp_dev *dev,\r\nunsigned int option_flags,\r\nstruct acpi_resource_dma *p)\r\n{\r\nint i;\r\nunsigned char map = 0, flags;\r\nfor (i = 0; i < p->channel_count; i++)\r\nmap |= 1 << p->channels[i];\r\nflags = dma_flags(dev, p->type, p->bus_master, p->transfer);\r\npnp_register_dma_resource(dev, option_flags, map, flags);\r\n}\r\nstatic __init void pnpacpi_parse_irq_option(struct pnp_dev *dev,\r\nunsigned int option_flags,\r\nstruct acpi_resource_irq *p)\r\n{\r\nint i;\r\npnp_irq_mask_t map;\r\nunsigned char flags;\r\nbitmap_zero(map.bits, PNP_IRQ_NR);\r\nfor (i = 0; i < p->interrupt_count; i++)\r\nif (p->interrupts[i])\r\n__set_bit(p->interrupts[i], map.bits);\r\nflags = acpi_dev_irq_flags(p->triggering, p->polarity, p->sharable);\r\npnp_register_irq_resource(dev, option_flags, &map, flags);\r\n}\r\nstatic __init void pnpacpi_parse_ext_irq_option(struct pnp_dev *dev,\r\nunsigned int option_flags,\r\nstruct acpi_resource_extended_irq *p)\r\n{\r\nint i;\r\npnp_irq_mask_t map;\r\nunsigned char flags;\r\nbitmap_zero(map.bits, PNP_IRQ_NR);\r\nfor (i = 0; i < p->interrupt_count; i++) {\r\nif (p->interrupts[i]) {\r\nif (p->interrupts[i] < PNP_IRQ_NR)\r\n__set_bit(p->interrupts[i], map.bits);\r\nelse\r\ndev_err(&dev->dev, "ignoring IRQ %d option "\r\n"(too large for %d entry bitmap)\n",\r\np->interrupts[i], PNP_IRQ_NR);\r\n}\r\n}\r\nflags = acpi_dev_irq_flags(p->triggering, p->polarity, p->sharable);\r\npnp_register_irq_resource(dev, option_flags, &map, flags);\r\n}\r\nstatic __init void pnpacpi_parse_port_option(struct pnp_dev *dev,\r\nunsigned int option_flags,\r\nstruct acpi_resource_io *io)\r\n{\r\nunsigned char flags = 0;\r\nif (io->io_decode == ACPI_DECODE_16)\r\nflags = IORESOURCE_IO_16BIT_ADDR;\r\npnp_register_port_resource(dev, option_flags, io->minimum, io->maximum,\r\nio->alignment, io->address_length, flags);\r\n}\r\nstatic __init void pnpacpi_parse_fixed_port_option(struct pnp_dev *dev,\r\nunsigned int option_flags,\r\nstruct acpi_resource_fixed_io *io)\r\n{\r\npnp_register_port_resource(dev, option_flags, io->address, io->address,\r\n0, io->address_length, IORESOURCE_IO_FIXED);\r\n}\r\nstatic __init void pnpacpi_parse_mem24_option(struct pnp_dev *dev,\r\nunsigned int option_flags,\r\nstruct acpi_resource_memory24 *p)\r\n{\r\nunsigned char flags = 0;\r\nif (p->write_protect == ACPI_READ_WRITE_MEMORY)\r\nflags = IORESOURCE_MEM_WRITEABLE;\r\npnp_register_mem_resource(dev, option_flags, p->minimum, p->maximum,\r\np->alignment, p->address_length, flags);\r\n}\r\nstatic __init void pnpacpi_parse_mem32_option(struct pnp_dev *dev,\r\nunsigned int option_flags,\r\nstruct acpi_resource_memory32 *p)\r\n{\r\nunsigned char flags = 0;\r\nif (p->write_protect == ACPI_READ_WRITE_MEMORY)\r\nflags = IORESOURCE_MEM_WRITEABLE;\r\npnp_register_mem_resource(dev, option_flags, p->minimum, p->maximum,\r\np->alignment, p->address_length, flags);\r\n}\r\nstatic __init void pnpacpi_parse_fixed_mem32_option(struct pnp_dev *dev,\r\nunsigned int option_flags,\r\nstruct acpi_resource_fixed_memory32 *p)\r\n{\r\nunsigned char flags = 0;\r\nif (p->write_protect == ACPI_READ_WRITE_MEMORY)\r\nflags = IORESOURCE_MEM_WRITEABLE;\r\npnp_register_mem_resource(dev, option_flags, p->address, p->address,\r\n0, p->address_length, flags);\r\n}\r\nstatic __init void pnpacpi_parse_address_option(struct pnp_dev *dev,\r\nunsigned int option_flags,\r\nstruct acpi_resource *r)\r\n{\r\nstruct acpi_resource_address64 addr, *p = &addr;\r\nacpi_status status;\r\nunsigned char flags = 0;\r\nstatus = acpi_resource_to_address64(r, p);\r\nif (ACPI_FAILURE(status)) {\r\ndev_warn(&dev->dev, "can't convert resource type %d\n",\r\nr->type);\r\nreturn;\r\n}\r\nif (p->resource_type == ACPI_MEMORY_RANGE) {\r\nif (p->info.mem.write_protect == ACPI_READ_WRITE_MEMORY)\r\nflags = IORESOURCE_MEM_WRITEABLE;\r\npnp_register_mem_resource(dev, option_flags, p->address.minimum,\r\np->address.minimum, 0, p->address.address_length,\r\nflags);\r\n} else if (p->resource_type == ACPI_IO_RANGE)\r\npnp_register_port_resource(dev, option_flags, p->address.minimum,\r\np->address.minimum, 0, p->address.address_length,\r\nIORESOURCE_IO_FIXED);\r\n}\r\nstatic __init void pnpacpi_parse_ext_address_option(struct pnp_dev *dev,\r\nunsigned int option_flags,\r\nstruct acpi_resource *r)\r\n{\r\nstruct acpi_resource_extended_address64 *p = &r->data.ext_address64;\r\nunsigned char flags = 0;\r\nif (p->resource_type == ACPI_MEMORY_RANGE) {\r\nif (p->info.mem.write_protect == ACPI_READ_WRITE_MEMORY)\r\nflags = IORESOURCE_MEM_WRITEABLE;\r\npnp_register_mem_resource(dev, option_flags, p->address.minimum,\r\np->address.minimum, 0, p->address.address_length,\r\nflags);\r\n} else if (p->resource_type == ACPI_IO_RANGE)\r\npnp_register_port_resource(dev, option_flags, p->address.minimum,\r\np->address.minimum, 0, p->address.address_length,\r\nIORESOURCE_IO_FIXED);\r\n}\r\nstatic __init acpi_status pnpacpi_option_resource(struct acpi_resource *res,\r\nvoid *data)\r\n{\r\nint priority;\r\nstruct acpipnp_parse_option_s *parse_data = data;\r\nstruct pnp_dev *dev = parse_data->dev;\r\nunsigned int option_flags = parse_data->option_flags;\r\nswitch (res->type) {\r\ncase ACPI_RESOURCE_TYPE_IRQ:\r\npnpacpi_parse_irq_option(dev, option_flags, &res->data.irq);\r\nbreak;\r\ncase ACPI_RESOURCE_TYPE_DMA:\r\npnpacpi_parse_dma_option(dev, option_flags, &res->data.dma);\r\nbreak;\r\ncase ACPI_RESOURCE_TYPE_START_DEPENDENT:\r\nswitch (res->data.start_dpf.compatibility_priority) {\r\ncase ACPI_GOOD_CONFIGURATION:\r\npriority = PNP_RES_PRIORITY_PREFERRED;\r\nbreak;\r\ncase ACPI_ACCEPTABLE_CONFIGURATION:\r\npriority = PNP_RES_PRIORITY_ACCEPTABLE;\r\nbreak;\r\ncase ACPI_SUB_OPTIMAL_CONFIGURATION:\r\npriority = PNP_RES_PRIORITY_FUNCTIONAL;\r\nbreak;\r\ndefault:\r\npriority = PNP_RES_PRIORITY_INVALID;\r\nbreak;\r\n}\r\nparse_data->option_flags = pnp_new_dependent_set(dev, priority);\r\nbreak;\r\ncase ACPI_RESOURCE_TYPE_END_DEPENDENT:\r\nparse_data->option_flags = 0;\r\nbreak;\r\ncase ACPI_RESOURCE_TYPE_IO:\r\npnpacpi_parse_port_option(dev, option_flags, &res->data.io);\r\nbreak;\r\ncase ACPI_RESOURCE_TYPE_FIXED_IO:\r\npnpacpi_parse_fixed_port_option(dev, option_flags,\r\n&res->data.fixed_io);\r\nbreak;\r\ncase ACPI_RESOURCE_TYPE_VENDOR:\r\ncase ACPI_RESOURCE_TYPE_END_TAG:\r\nbreak;\r\ncase ACPI_RESOURCE_TYPE_MEMORY24:\r\npnpacpi_parse_mem24_option(dev, option_flags,\r\n&res->data.memory24);\r\nbreak;\r\ncase ACPI_RESOURCE_TYPE_MEMORY32:\r\npnpacpi_parse_mem32_option(dev, option_flags,\r\n&res->data.memory32);\r\nbreak;\r\ncase ACPI_RESOURCE_TYPE_FIXED_MEMORY32:\r\npnpacpi_parse_fixed_mem32_option(dev, option_flags,\r\n&res->data.fixed_memory32);\r\nbreak;\r\ncase ACPI_RESOURCE_TYPE_ADDRESS16:\r\ncase ACPI_RESOURCE_TYPE_ADDRESS32:\r\ncase ACPI_RESOURCE_TYPE_ADDRESS64:\r\npnpacpi_parse_address_option(dev, option_flags, res);\r\nbreak;\r\ncase ACPI_RESOURCE_TYPE_EXTENDED_ADDRESS64:\r\npnpacpi_parse_ext_address_option(dev, option_flags, res);\r\nbreak;\r\ncase ACPI_RESOURCE_TYPE_EXTENDED_IRQ:\r\npnpacpi_parse_ext_irq_option(dev, option_flags,\r\n&res->data.extended_irq);\r\nbreak;\r\ncase ACPI_RESOURCE_TYPE_GENERIC_REGISTER:\r\nbreak;\r\ndefault:\r\ndev_warn(&dev->dev, "unknown resource type %d in _PRS\n",\r\nres->type);\r\nreturn AE_ERROR;\r\n}\r\nreturn AE_OK;\r\n}\r\nint __init pnpacpi_parse_resource_option_data(struct pnp_dev *dev)\r\n{\r\nstruct acpi_device *acpi_dev = dev->data;\r\nacpi_handle handle = acpi_dev->handle;\r\nacpi_status status;\r\nstruct acpipnp_parse_option_s parse_data;\r\npnp_dbg(&dev->dev, "parse resource options\n");\r\nparse_data.dev = dev;\r\nparse_data.option_flags = 0;\r\nstatus = acpi_walk_resources(handle, METHOD_NAME__PRS,\r\npnpacpi_option_resource, &parse_data);\r\nif (ACPI_FAILURE(status)) {\r\nif (status != AE_NOT_FOUND)\r\ndev_err(&dev->dev, "can't evaluate _PRS: %d", status);\r\nreturn -EPERM;\r\n}\r\nreturn 0;\r\n}\r\nstatic int pnpacpi_supported_resource(struct acpi_resource *res)\r\n{\r\nswitch (res->type) {\r\ncase ACPI_RESOURCE_TYPE_IRQ:\r\ncase ACPI_RESOURCE_TYPE_DMA:\r\ncase ACPI_RESOURCE_TYPE_IO:\r\ncase ACPI_RESOURCE_TYPE_FIXED_IO:\r\ncase ACPI_RESOURCE_TYPE_MEMORY24:\r\ncase ACPI_RESOURCE_TYPE_MEMORY32:\r\ncase ACPI_RESOURCE_TYPE_FIXED_MEMORY32:\r\ncase ACPI_RESOURCE_TYPE_ADDRESS16:\r\ncase ACPI_RESOURCE_TYPE_ADDRESS32:\r\ncase ACPI_RESOURCE_TYPE_ADDRESS64:\r\ncase ACPI_RESOURCE_TYPE_EXTENDED_ADDRESS64:\r\ncase ACPI_RESOURCE_TYPE_EXTENDED_IRQ:\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}\r\nstatic acpi_status pnpacpi_count_resources(struct acpi_resource *res,\r\nvoid *data)\r\n{\r\nint *res_cnt = data;\r\nif (pnpacpi_supported_resource(res))\r\n(*res_cnt)++;\r\nreturn AE_OK;\r\n}\r\nstatic acpi_status pnpacpi_type_resources(struct acpi_resource *res, void *data)\r\n{\r\nstruct acpi_resource **resource = data;\r\nif (pnpacpi_supported_resource(res)) {\r\n(*resource)->type = res->type;\r\n(*resource)->length = sizeof(struct acpi_resource);\r\nif (res->type == ACPI_RESOURCE_TYPE_IRQ)\r\n(*resource)->data.irq.descriptor_length =\r\nres->data.irq.descriptor_length;\r\n(*resource)++;\r\n}\r\nreturn AE_OK;\r\n}\r\nint pnpacpi_build_resource_template(struct pnp_dev *dev,\r\nstruct acpi_buffer *buffer)\r\n{\r\nstruct acpi_device *acpi_dev = dev->data;\r\nacpi_handle handle = acpi_dev->handle;\r\nstruct acpi_resource *resource;\r\nint res_cnt = 0;\r\nacpi_status status;\r\nstatus = acpi_walk_resources(handle, METHOD_NAME__CRS,\r\npnpacpi_count_resources, &res_cnt);\r\nif (ACPI_FAILURE(status)) {\r\ndev_err(&dev->dev, "can't evaluate _CRS: %d\n", status);\r\nreturn -EINVAL;\r\n}\r\nif (!res_cnt)\r\nreturn -EINVAL;\r\nbuffer->length = sizeof(struct acpi_resource) * (res_cnt + 1) + 1;\r\nbuffer->pointer = kzalloc(buffer->length - 1, GFP_KERNEL);\r\nif (!buffer->pointer)\r\nreturn -ENOMEM;\r\nresource = (struct acpi_resource *)buffer->pointer;\r\nstatus = acpi_walk_resources(handle, METHOD_NAME__CRS,\r\npnpacpi_type_resources, &resource);\r\nif (ACPI_FAILURE(status)) {\r\nkfree(buffer->pointer);\r\ndev_err(&dev->dev, "can't evaluate _CRS: %d\n", status);\r\nreturn -EINVAL;\r\n}\r\nresource->type = ACPI_RESOURCE_TYPE_END_TAG;\r\nresource->length = sizeof(struct acpi_resource);\r\nreturn 0;\r\n}\r\nstatic void pnpacpi_encode_irq(struct pnp_dev *dev,\r\nstruct acpi_resource *resource,\r\nstruct resource *p)\r\n{\r\nstruct acpi_resource_irq *irq = &resource->data.irq;\r\nu8 triggering, polarity, shareable;\r\nif (!pnp_resource_enabled(p)) {\r\nirq->interrupt_count = 0;\r\npnp_dbg(&dev->dev, " encode irq (%s)\n",\r\np ? "disabled" : "missing");\r\nreturn;\r\n}\r\ndecode_irq_flags(dev, p->flags, &triggering, &polarity, &shareable);\r\nirq->triggering = triggering;\r\nirq->polarity = polarity;\r\nirq->sharable = shareable;\r\nirq->interrupt_count = 1;\r\nirq->interrupts[0] = p->start;\r\npnp_dbg(&dev->dev, " encode irq %d %s %s %s (%d-byte descriptor)\n",\r\n(int) p->start,\r\ntriggering == ACPI_LEVEL_SENSITIVE ? "level" : "edge",\r\npolarity == ACPI_ACTIVE_LOW ? "low" : "high",\r\nirq->sharable == ACPI_SHARED ? "shared" : "exclusive",\r\nirq->descriptor_length);\r\n}\r\nstatic void pnpacpi_encode_ext_irq(struct pnp_dev *dev,\r\nstruct acpi_resource *resource,\r\nstruct resource *p)\r\n{\r\nstruct acpi_resource_extended_irq *extended_irq = &resource->data.extended_irq;\r\nu8 triggering, polarity, shareable;\r\nif (!pnp_resource_enabled(p)) {\r\nextended_irq->interrupt_count = 0;\r\npnp_dbg(&dev->dev, " encode extended irq (%s)\n",\r\np ? "disabled" : "missing");\r\nreturn;\r\n}\r\ndecode_irq_flags(dev, p->flags, &triggering, &polarity, &shareable);\r\nextended_irq->producer_consumer = ACPI_CONSUMER;\r\nextended_irq->triggering = triggering;\r\nextended_irq->polarity = polarity;\r\nextended_irq->sharable = shareable;\r\nextended_irq->interrupt_count = 1;\r\nextended_irq->interrupts[0] = p->start;\r\npnp_dbg(&dev->dev, " encode irq %d %s %s %s\n", (int) p->start,\r\ntriggering == ACPI_LEVEL_SENSITIVE ? "level" : "edge",\r\npolarity == ACPI_ACTIVE_LOW ? "low" : "high",\r\nextended_irq->sharable == ACPI_SHARED ? "shared" : "exclusive");\r\n}\r\nstatic void pnpacpi_encode_dma(struct pnp_dev *dev,\r\nstruct acpi_resource *resource,\r\nstruct resource *p)\r\n{\r\nstruct acpi_resource_dma *dma = &resource->data.dma;\r\nif (!pnp_resource_enabled(p)) {\r\ndma->channel_count = 0;\r\npnp_dbg(&dev->dev, " encode dma (%s)\n",\r\np ? "disabled" : "missing");\r\nreturn;\r\n}\r\nswitch (p->flags & IORESOURCE_DMA_SPEED_MASK) {\r\ncase IORESOURCE_DMA_TYPEA:\r\ndma->type = ACPI_TYPE_A;\r\nbreak;\r\ncase IORESOURCE_DMA_TYPEB:\r\ndma->type = ACPI_TYPE_B;\r\nbreak;\r\ncase IORESOURCE_DMA_TYPEF:\r\ndma->type = ACPI_TYPE_F;\r\nbreak;\r\ndefault:\r\ndma->type = ACPI_COMPATIBILITY;\r\n}\r\nswitch (p->flags & IORESOURCE_DMA_TYPE_MASK) {\r\ncase IORESOURCE_DMA_8BIT:\r\ndma->transfer = ACPI_TRANSFER_8;\r\nbreak;\r\ncase IORESOURCE_DMA_8AND16BIT:\r\ndma->transfer = ACPI_TRANSFER_8_16;\r\nbreak;\r\ndefault:\r\ndma->transfer = ACPI_TRANSFER_16;\r\n}\r\ndma->bus_master = !!(p->flags & IORESOURCE_DMA_MASTER);\r\ndma->channel_count = 1;\r\ndma->channels[0] = p->start;\r\npnp_dbg(&dev->dev, " encode dma %d "\r\n"type %#x transfer %#x master %d\n",\r\n(int) p->start, dma->type, dma->transfer, dma->bus_master);\r\n}\r\nstatic void pnpacpi_encode_io(struct pnp_dev *dev,\r\nstruct acpi_resource *resource,\r\nstruct resource *p)\r\n{\r\nstruct acpi_resource_io *io = &resource->data.io;\r\nif (pnp_resource_enabled(p)) {\r\nio->io_decode = (p->flags & IORESOURCE_IO_16BIT_ADDR) ?\r\nACPI_DECODE_16 : ACPI_DECODE_10;\r\nio->minimum = p->start;\r\nio->maximum = p->end;\r\nio->alignment = 0;\r\nio->address_length = resource_size(p);\r\n} else {\r\nio->minimum = 0;\r\nio->address_length = 0;\r\n}\r\npnp_dbg(&dev->dev, " encode io %#x-%#x decode %#x\n", io->minimum,\r\nio->minimum + io->address_length - 1, io->io_decode);\r\n}\r\nstatic void pnpacpi_encode_fixed_io(struct pnp_dev *dev,\r\nstruct acpi_resource *resource,\r\nstruct resource *p)\r\n{\r\nstruct acpi_resource_fixed_io *fixed_io = &resource->data.fixed_io;\r\nif (pnp_resource_enabled(p)) {\r\nfixed_io->address = p->start;\r\nfixed_io->address_length = resource_size(p);\r\n} else {\r\nfixed_io->address = 0;\r\nfixed_io->address_length = 0;\r\n}\r\npnp_dbg(&dev->dev, " encode fixed_io %#x-%#x\n", fixed_io->address,\r\nfixed_io->address + fixed_io->address_length - 1);\r\n}\r\nstatic void pnpacpi_encode_mem24(struct pnp_dev *dev,\r\nstruct acpi_resource *resource,\r\nstruct resource *p)\r\n{\r\nstruct acpi_resource_memory24 *memory24 = &resource->data.memory24;\r\nif (pnp_resource_enabled(p)) {\r\nmemory24->write_protect = p->flags & IORESOURCE_MEM_WRITEABLE ?\r\nACPI_READ_WRITE_MEMORY : ACPI_READ_ONLY_MEMORY;\r\nmemory24->minimum = p->start;\r\nmemory24->maximum = p->end;\r\nmemory24->alignment = 0;\r\nmemory24->address_length = resource_size(p);\r\n} else {\r\nmemory24->minimum = 0;\r\nmemory24->address_length = 0;\r\n}\r\npnp_dbg(&dev->dev, " encode mem24 %#x-%#x write_protect %#x\n",\r\nmemory24->minimum,\r\nmemory24->minimum + memory24->address_length - 1,\r\nmemory24->write_protect);\r\n}\r\nstatic void pnpacpi_encode_mem32(struct pnp_dev *dev,\r\nstruct acpi_resource *resource,\r\nstruct resource *p)\r\n{\r\nstruct acpi_resource_memory32 *memory32 = &resource->data.memory32;\r\nif (pnp_resource_enabled(p)) {\r\nmemory32->write_protect = p->flags & IORESOURCE_MEM_WRITEABLE ?\r\nACPI_READ_WRITE_MEMORY : ACPI_READ_ONLY_MEMORY;\r\nmemory32->minimum = p->start;\r\nmemory32->maximum = p->end;\r\nmemory32->alignment = 0;\r\nmemory32->address_length = resource_size(p);\r\n} else {\r\nmemory32->minimum = 0;\r\nmemory32->alignment = 0;\r\n}\r\npnp_dbg(&dev->dev, " encode mem32 %#x-%#x write_protect %#x\n",\r\nmemory32->minimum,\r\nmemory32->minimum + memory32->address_length - 1,\r\nmemory32->write_protect);\r\n}\r\nstatic void pnpacpi_encode_fixed_mem32(struct pnp_dev *dev,\r\nstruct acpi_resource *resource,\r\nstruct resource *p)\r\n{\r\nstruct acpi_resource_fixed_memory32 *fixed_memory32 = &resource->data.fixed_memory32;\r\nif (pnp_resource_enabled(p)) {\r\nfixed_memory32->write_protect =\r\np->flags & IORESOURCE_MEM_WRITEABLE ?\r\nACPI_READ_WRITE_MEMORY : ACPI_READ_ONLY_MEMORY;\r\nfixed_memory32->address = p->start;\r\nfixed_memory32->address_length = resource_size(p);\r\n} else {\r\nfixed_memory32->address = 0;\r\nfixed_memory32->address_length = 0;\r\n}\r\npnp_dbg(&dev->dev, " encode fixed_mem32 %#x-%#x write_protect %#x\n",\r\nfixed_memory32->address,\r\nfixed_memory32->address + fixed_memory32->address_length - 1,\r\nfixed_memory32->write_protect);\r\n}\r\nint pnpacpi_encode_resources(struct pnp_dev *dev, struct acpi_buffer *buffer)\r\n{\r\nint i = 0;\r\nint res_cnt = (buffer->length - 1) / sizeof(struct acpi_resource) - 1;\r\nstruct acpi_resource *resource = buffer->pointer;\r\nunsigned int port = 0, irq = 0, dma = 0, mem = 0;\r\npnp_dbg(&dev->dev, "encode %d resources\n", res_cnt);\r\nwhile (i < res_cnt) {\r\nswitch (resource->type) {\r\ncase ACPI_RESOURCE_TYPE_IRQ:\r\npnpacpi_encode_irq(dev, resource,\r\npnp_get_resource(dev, IORESOURCE_IRQ, irq));\r\nirq++;\r\nbreak;\r\ncase ACPI_RESOURCE_TYPE_DMA:\r\npnpacpi_encode_dma(dev, resource,\r\npnp_get_resource(dev, IORESOURCE_DMA, dma));\r\ndma++;\r\nbreak;\r\ncase ACPI_RESOURCE_TYPE_IO:\r\npnpacpi_encode_io(dev, resource,\r\npnp_get_resource(dev, IORESOURCE_IO, port));\r\nport++;\r\nbreak;\r\ncase ACPI_RESOURCE_TYPE_FIXED_IO:\r\npnpacpi_encode_fixed_io(dev, resource,\r\npnp_get_resource(dev, IORESOURCE_IO, port));\r\nport++;\r\nbreak;\r\ncase ACPI_RESOURCE_TYPE_MEMORY24:\r\npnpacpi_encode_mem24(dev, resource,\r\npnp_get_resource(dev, IORESOURCE_MEM, mem));\r\nmem++;\r\nbreak;\r\ncase ACPI_RESOURCE_TYPE_MEMORY32:\r\npnpacpi_encode_mem32(dev, resource,\r\npnp_get_resource(dev, IORESOURCE_MEM, mem));\r\nmem++;\r\nbreak;\r\ncase ACPI_RESOURCE_TYPE_FIXED_MEMORY32:\r\npnpacpi_encode_fixed_mem32(dev, resource,\r\npnp_get_resource(dev, IORESOURCE_MEM, mem));\r\nmem++;\r\nbreak;\r\ncase ACPI_RESOURCE_TYPE_EXTENDED_IRQ:\r\npnpacpi_encode_ext_irq(dev, resource,\r\npnp_get_resource(dev, IORESOURCE_IRQ, irq));\r\nirq++;\r\nbreak;\r\ncase ACPI_RESOURCE_TYPE_START_DEPENDENT:\r\ncase ACPI_RESOURCE_TYPE_END_DEPENDENT:\r\ncase ACPI_RESOURCE_TYPE_VENDOR:\r\ncase ACPI_RESOURCE_TYPE_END_TAG:\r\ncase ACPI_RESOURCE_TYPE_ADDRESS16:\r\ncase ACPI_RESOURCE_TYPE_ADDRESS32:\r\ncase ACPI_RESOURCE_TYPE_ADDRESS64:\r\ncase ACPI_RESOURCE_TYPE_EXTENDED_ADDRESS64:\r\ncase ACPI_RESOURCE_TYPE_GENERIC_REGISTER:\r\ndefault:\r\ndev_warn(&dev->dev, "can't encode unknown resource "\r\n"type %d\n", resource->type);\r\nreturn -EINVAL;\r\n}\r\nresource++;\r\ni++;\r\n}\r\nreturn 0;\r\n}
