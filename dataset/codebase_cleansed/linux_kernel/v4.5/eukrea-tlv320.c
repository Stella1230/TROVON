static int eukrea_tlv320_hw_params(struct snd_pcm_substream *substream,\r\nstruct snd_pcm_hw_params *params)\r\n{\r\nstruct snd_soc_pcm_runtime *rtd = substream->private_data;\r\nstruct snd_soc_dai *codec_dai = rtd->codec_dai;\r\nstruct snd_soc_dai *cpu_dai = rtd->cpu_dai;\r\nint ret;\r\nret = snd_soc_dai_set_sysclk(codec_dai, 0,\r\nCODEC_CLOCK, SND_SOC_CLOCK_OUT);\r\nif (ret) {\r\ndev_err(cpu_dai->dev,\r\n"Failed to set the codec sysclk.\n");\r\nreturn ret;\r\n}\r\nsnd_soc_dai_set_tdm_slot(cpu_dai, 0x3, 0x3, 2, 0);\r\nret = snd_soc_dai_set_sysclk(cpu_dai, IMX_SSP_SYS_CLK, 0,\r\nSND_SOC_CLOCK_IN);\r\nif (ret && ret != -EINVAL) {\r\ndev_err(cpu_dai->dev,\r\n"Can't set the IMX_SSP_SYS_CLK CPU system clock.\n");\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic int eukrea_tlv320_probe(struct platform_device *pdev)\r\n{\r\nint ret;\r\nint int_port = 0, ext_port;\r\nstruct device_node *np = pdev->dev.of_node;\r\nstruct device_node *ssi_np = NULL, *codec_np = NULL;\r\neukrea_tlv320.dev = &pdev->dev;\r\nif (np) {\r\nret = snd_soc_of_parse_card_name(&eukrea_tlv320,\r\n"eukrea,model");\r\nif (ret) {\r\ndev_err(&pdev->dev,\r\n"eukrea,model node missing or invalid.\n");\r\ngoto err;\r\n}\r\nssi_np = of_parse_phandle(pdev->dev.of_node,\r\n"ssi-controller", 0);\r\nif (!ssi_np) {\r\ndev_err(&pdev->dev,\r\n"ssi-controller missing or invalid.\n");\r\nret = -ENODEV;\r\ngoto err;\r\n}\r\ncodec_np = of_parse_phandle(ssi_np, "codec-handle", 0);\r\nif (codec_np)\r\neukrea_tlv320_dai.codec_of_node = codec_np;\r\nelse\r\ndev_err(&pdev->dev, "codec-handle node missing or invalid.\n");\r\nret = of_property_read_u32(np, "fsl,mux-int-port", &int_port);\r\nif (ret) {\r\ndev_err(&pdev->dev,\r\n"fsl,mux-int-port node missing or invalid.\n");\r\nreturn ret;\r\n}\r\nret = of_property_read_u32(np, "fsl,mux-ext-port", &ext_port);\r\nif (ret) {\r\ndev_err(&pdev->dev,\r\n"fsl,mux-ext-port node missing or invalid.\n");\r\nreturn ret;\r\n}\r\nint_port--;\r\next_port--;\r\neukrea_tlv320_dai.cpu_of_node = ssi_np;\r\neukrea_tlv320_dai.platform_of_node = ssi_np;\r\n} else {\r\neukrea_tlv320_dai.cpu_dai_name = "imx-ssi.0";\r\neukrea_tlv320_dai.platform_name = "imx-ssi.0";\r\neukrea_tlv320_dai.codec_name = "tlv320aic23-codec.0-001a";\r\neukrea_tlv320.name = "cpuimx-audio";\r\n}\r\nif (machine_is_eukrea_cpuimx27() ||\r\nof_find_compatible_node(NULL, NULL, "fsl,imx21-audmux")) {\r\nimx_audmux_v1_configure_port(MX27_AUDMUX_HPCR1_SSI0,\r\nIMX_AUDMUX_V1_PCR_SYN |\r\nIMX_AUDMUX_V1_PCR_TFSDIR |\r\nIMX_AUDMUX_V1_PCR_TCLKDIR |\r\nIMX_AUDMUX_V1_PCR_RFSDIR |\r\nIMX_AUDMUX_V1_PCR_RCLKDIR |\r\nIMX_AUDMUX_V1_PCR_TFCSEL(MX27_AUDMUX_HPCR3_SSI_PINS_4) |\r\nIMX_AUDMUX_V1_PCR_RFCSEL(MX27_AUDMUX_HPCR3_SSI_PINS_4) |\r\nIMX_AUDMUX_V1_PCR_RXDSEL(MX27_AUDMUX_HPCR3_SSI_PINS_4)\r\n);\r\nimx_audmux_v1_configure_port(MX27_AUDMUX_HPCR3_SSI_PINS_4,\r\nIMX_AUDMUX_V1_PCR_SYN |\r\nIMX_AUDMUX_V1_PCR_RXDSEL(MX27_AUDMUX_HPCR1_SSI0)\r\n);\r\n} else if (machine_is_eukrea_cpuimx25sd() ||\r\nmachine_is_eukrea_cpuimx35sd() ||\r\nmachine_is_eukrea_cpuimx51sd() ||\r\nof_find_compatible_node(NULL, NULL, "fsl,imx31-audmux")) {\r\nif (!np)\r\next_port = machine_is_eukrea_cpuimx25sd() ?\r\n4 : 3;\r\nimx_audmux_v2_configure_port(int_port,\r\nIMX_AUDMUX_V2_PTCR_SYN |\r\nIMX_AUDMUX_V2_PTCR_TFSDIR |\r\nIMX_AUDMUX_V2_PTCR_TFSEL(ext_port) |\r\nIMX_AUDMUX_V2_PTCR_TCLKDIR |\r\nIMX_AUDMUX_V2_PTCR_TCSEL(ext_port),\r\nIMX_AUDMUX_V2_PDCR_RXDSEL(ext_port)\r\n);\r\nimx_audmux_v2_configure_port(ext_port,\r\nIMX_AUDMUX_V2_PTCR_SYN,\r\nIMX_AUDMUX_V2_PDCR_RXDSEL(int_port)\r\n);\r\n} else {\r\nif (np) {\r\ndev_err(&pdev->dev,\r\n"Missing or invalid audmux DT node.\n");\r\nreturn -ENODEV;\r\n} else {\r\nreturn 0;\r\n}\r\n}\r\nret = snd_soc_register_card(&eukrea_tlv320);\r\nerr:\r\nif (ret)\r\ndev_err(&pdev->dev, "snd_soc_register_card failed (%d)\n", ret);\r\nof_node_put(ssi_np);\r\nreturn ret;\r\n}\r\nstatic int eukrea_tlv320_remove(struct platform_device *pdev)\r\n{\r\nsnd_soc_unregister_card(&eukrea_tlv320);\r\nreturn 0;\r\n}
