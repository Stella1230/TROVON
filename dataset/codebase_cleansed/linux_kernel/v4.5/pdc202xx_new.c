static u8 max_dma_rate(struct pci_dev *pdev)\r\n{\r\nu8 mode;\r\nswitch(pdev->device) {\r\ncase PCI_DEVICE_ID_PROMISE_20277:\r\ncase PCI_DEVICE_ID_PROMISE_20276:\r\ncase PCI_DEVICE_ID_PROMISE_20275:\r\ncase PCI_DEVICE_ID_PROMISE_20271:\r\ncase PCI_DEVICE_ID_PROMISE_20269:\r\nmode = 4;\r\nbreak;\r\ncase PCI_DEVICE_ID_PROMISE_20270:\r\ncase PCI_DEVICE_ID_PROMISE_20268:\r\nmode = 3;\r\nbreak;\r\ndefault:\r\nreturn 0;\r\n}\r\nreturn mode;\r\n}\r\nstatic u8 get_indexed_reg(ide_hwif_t *hwif, u8 index)\r\n{\r\nu8 value;\r\noutb(index, hwif->dma_base + 1);\r\nvalue = inb(hwif->dma_base + 3);\r\nDBG("index[%02X] value[%02X]\n", index, value);\r\nreturn value;\r\n}\r\nstatic void set_indexed_reg(ide_hwif_t *hwif, u8 index, u8 value)\r\n{\r\noutb(index, hwif->dma_base + 1);\r\noutb(value, hwif->dma_base + 3);\r\nDBG("index[%02X] value[%02X]\n", index, value);\r\n}\r\nstatic void pdcnew_set_dma_mode(ide_hwif_t *hwif, ide_drive_t *drive)\r\n{\r\nstruct pci_dev *dev = to_pci_dev(hwif->dev);\r\nu8 adj = (drive->dn & 1) ? 0x08 : 0x00;\r\nconst u8 speed = drive->dma_mode;\r\nif (max_dma_rate(dev) == 4) {\r\nu8 mode = speed & 0x07;\r\nif (speed >= XFER_UDMA_0) {\r\nset_indexed_reg(hwif, 0x10 + adj,\r\nudma_timings[mode].reg10);\r\nset_indexed_reg(hwif, 0x11 + adj,\r\nudma_timings[mode].reg11);\r\nset_indexed_reg(hwif, 0x12 + adj,\r\nudma_timings[mode].reg12);\r\n} else {\r\nset_indexed_reg(hwif, 0x0e + adj,\r\nmwdma_timings[mode].reg0e);\r\nset_indexed_reg(hwif, 0x0f + adj,\r\nmwdma_timings[mode].reg0f);\r\n}\r\n} else if (speed == XFER_UDMA_2) {\r\nu8 tmp = get_indexed_reg(hwif, 0x10 + adj);\r\nset_indexed_reg(hwif, 0x10 + adj, tmp & 0x7f);\r\n}\r\n}\r\nstatic void pdcnew_set_pio_mode(ide_hwif_t *hwif, ide_drive_t *drive)\r\n{\r\nstruct pci_dev *dev = to_pci_dev(hwif->dev);\r\nu8 adj = (drive->dn & 1) ? 0x08 : 0x00;\r\nconst u8 pio = drive->pio_mode - XFER_PIO_0;\r\nif (max_dma_rate(dev) == 4) {\r\nset_indexed_reg(hwif, 0x0c + adj, pio_timings[pio].reg0c);\r\nset_indexed_reg(hwif, 0x0d + adj, pio_timings[pio].reg0d);\r\nset_indexed_reg(hwif, 0x13 + adj, pio_timings[pio].reg13);\r\n}\r\n}\r\nstatic u8 pdcnew_cable_detect(ide_hwif_t *hwif)\r\n{\r\nif (get_indexed_reg(hwif, 0x0b) & 0x04)\r\nreturn ATA_CBL_PATA40;\r\nelse\r\nreturn ATA_CBL_PATA80;\r\n}\r\nstatic void pdcnew_reset(ide_drive_t *drive)\r\n{\r\nprintk(KERN_WARNING "pdc202xx_new: %s channel reset.\n",\r\ndrive->hwif->channel ? "Secondary" : "Primary");\r\n}\r\nstatic long read_counter(u32 dma_base)\r\n{\r\nu32 pri_dma_base = dma_base, sec_dma_base = dma_base + 0x08;\r\nu8 cnt0, cnt1, cnt2, cnt3;\r\nlong count = 0, last;\r\nint retry = 3;\r\ndo {\r\nlast = count;\r\noutb(0x20, pri_dma_base + 0x01);\r\ncnt0 = inb(pri_dma_base + 0x03);\r\noutb(0x21, pri_dma_base + 0x01);\r\ncnt1 = inb(pri_dma_base + 0x03);\r\noutb(0x20, sec_dma_base + 0x01);\r\ncnt2 = inb(sec_dma_base + 0x03);\r\noutb(0x21, sec_dma_base + 0x01);\r\ncnt3 = inb(sec_dma_base + 0x03);\r\ncount = (cnt3 << 23) | (cnt2 << 15) | (cnt1 << 8) | cnt0;\r\n} while (retry-- && (((last ^ count) & 0x3fff8000) || last < count));\r\nDBG("cnt0[%02X] cnt1[%02X] cnt2[%02X] cnt3[%02X]\n",\r\ncnt0, cnt1, cnt2, cnt3);\r\nreturn count;\r\n}\r\nstatic long detect_pll_input_clock(unsigned long dma_base)\r\n{\r\nktime_t start_time, end_time;\r\nlong start_count, end_count;\r\nlong pll_input, usec_elapsed;\r\nu8 scr1;\r\nstart_count = read_counter(dma_base);\r\nstart_time = ktime_get();\r\noutb(0x01, dma_base + 0x01);\r\nscr1 = inb(dma_base + 0x03);\r\nDBG("scr1[%02X]\n", scr1);\r\noutb(scr1 | 0x40, dma_base + 0x03);\r\nmdelay(10);\r\nend_count = read_counter(dma_base);\r\nend_time = ktime_get();\r\noutb(0x01, dma_base + 0x01);\r\nscr1 = inb(dma_base + 0x03);\r\nDBG("scr1[%02X]\n", scr1);\r\noutb(scr1 & ~0x40, dma_base + 0x03);\r\nusec_elapsed = ktime_us_delta(end_time, start_time);\r\npll_input = ((start_count - end_count) & 0x3fffffff) / 10 *\r\n(10000000 / usec_elapsed);\r\nDBG("start[%ld] end[%ld]\n", start_count, end_count);\r\nreturn pll_input;\r\n}\r\nstatic void apple_kiwi_init(struct pci_dev *pdev)\r\n{\r\nstruct device_node *np = pci_device_to_OF_node(pdev);\r\nu8 conf;\r\nif (np == NULL || !of_device_is_compatible(np, "kiwi-root"))\r\nreturn;\r\nif (pdev->revision >= 0x03) {\r\npci_read_config_byte (pdev, 0x40, &conf);\r\npci_write_config_byte(pdev, 0x40, (conf | 0x01));\r\n}\r\n}\r\nstatic int init_chipset_pdcnew(struct pci_dev *dev)\r\n{\r\nconst char *name = DRV_NAME;\r\nunsigned long dma_base = pci_resource_start(dev, 4);\r\nunsigned long sec_dma_base = dma_base + 0x08;\r\nlong pll_input, pll_output, ratio;\r\nint f, r;\r\nu8 pll_ctl0, pll_ctl1;\r\nif (dma_base == 0)\r\nreturn -EFAULT;\r\n#ifdef CONFIG_PPC_PMAC\r\napple_kiwi_init(dev);\r\n#endif\r\nswitch(max_dma_rate(dev)) {\r\ncase 4:\r\npll_output = 133333333;\r\nbreak;\r\ncase 3:\r\ndefault:\r\npll_output = 100000000;\r\nbreak;\r\n}\r\npll_input = detect_pll_input_clock(dma_base);\r\nprintk(KERN_INFO "%s %s: PLL input clock is %ld kHz\n",\r\nname, pci_name(dev), pll_input / 1000);\r\nif (unlikely(pll_input < 5000000L || pll_input > 70000000L)) {\r\nprintk(KERN_ERR "%s %s: Bad PLL input clock %ld Hz, giving up!"\r\n"\n", name, pci_name(dev), pll_input);\r\ngoto out;\r\n}\r\n#ifdef DEBUG\r\nDBG("pll_output is %ld Hz\n", pll_output);\r\noutb(0x02, sec_dma_base + 0x01);\r\npll_ctl0 = inb(sec_dma_base + 0x03);\r\noutb(0x03, sec_dma_base + 0x01);\r\npll_ctl1 = inb(sec_dma_base + 0x03);\r\nDBG("pll_ctl[%02X][%02X]\n", pll_ctl0, pll_ctl1);\r\n#endif\r\nratio = pll_output / (pll_input / 1000);\r\nif (ratio < 8600L) {\r\nr = 0x0d;\r\n} else if (ratio < 12900L) {\r\nr = 0x08;\r\n} else if (ratio < 16100L) {\r\nr = 0x06;\r\n} else if (ratio < 64000L) {\r\nr = 0x00;\r\n} else {\r\nprintk(KERN_ERR "%s %s: Bad ratio %ld, giving up!\n",\r\nname, pci_name(dev), ratio);\r\ngoto out;\r\n}\r\nf = (ratio * (r + 2)) / 1000 - 2;\r\nDBG("F[%d] R[%d] ratio*1000[%ld]\n", f, r, ratio);\r\nif (unlikely(f < 0 || f > 127)) {\r\nprintk(KERN_ERR "%s %s: F[%d] invalid!\n",\r\nname, pci_name(dev), f);\r\ngoto out;\r\n}\r\npll_ctl0 = (u8) f;\r\npll_ctl1 = (u8) r;\r\nDBG("Writing pll_ctl[%02X][%02X]\n", pll_ctl0, pll_ctl1);\r\noutb(0x02, sec_dma_base + 0x01);\r\noutb(pll_ctl0, sec_dma_base + 0x03);\r\noutb(0x03, sec_dma_base + 0x01);\r\noutb(pll_ctl1, sec_dma_base + 0x03);\r\nmdelay(30);\r\n#ifdef DEBUG\r\noutb(0x02, sec_dma_base + 0x01);\r\npll_ctl0 = inb(sec_dma_base + 0x03);\r\noutb(0x03, sec_dma_base + 0x01);\r\npll_ctl1 = inb(sec_dma_base + 0x03);\r\nDBG("pll_ctl[%02X][%02X]\n", pll_ctl0, pll_ctl1);\r\n#endif\r\nout:\r\nreturn 0;\r\n}\r\nstatic struct pci_dev *pdc20270_get_dev2(struct pci_dev *dev)\r\n{\r\nstruct pci_dev *dev2;\r\ndev2 = pci_get_slot(dev->bus, PCI_DEVFN(PCI_SLOT(dev->devfn) + 1,\r\nPCI_FUNC(dev->devfn)));\r\nif (dev2 &&\r\ndev2->vendor == dev->vendor &&\r\ndev2->device == dev->device) {\r\nif (dev2->irq != dev->irq) {\r\ndev2->irq = dev->irq;\r\nprintk(KERN_INFO DRV_NAME " %s: PCI config space "\r\n"interrupt fixed\n", pci_name(dev));\r\n}\r\nreturn dev2;\r\n}\r\nreturn NULL;\r\n}\r\nstatic int pdc202new_init_one(struct pci_dev *dev, const struct pci_device_id *id)\r\n{\r\nconst struct ide_port_info *d = &pdcnew_chipsets[id->driver_data];\r\nstruct pci_dev *bridge = dev->bus->self;\r\nif (dev->device == PCI_DEVICE_ID_PROMISE_20270 && bridge &&\r\nbridge->vendor == PCI_VENDOR_ID_DEC &&\r\nbridge->device == PCI_DEVICE_ID_DEC_21150) {\r\nstruct pci_dev *dev2;\r\nif (PCI_SLOT(dev->devfn) & 2)\r\nreturn -ENODEV;\r\ndev2 = pdc20270_get_dev2(dev);\r\nif (dev2) {\r\nint ret = ide_pci_init_two(dev, dev2, d, NULL);\r\nif (ret < 0)\r\npci_dev_put(dev2);\r\nreturn ret;\r\n}\r\n}\r\nif (dev->device == PCI_DEVICE_ID_PROMISE_20276 && bridge &&\r\nbridge->vendor == PCI_VENDOR_ID_INTEL &&\r\n(bridge->device == PCI_DEVICE_ID_INTEL_I960 ||\r\nbridge->device == PCI_DEVICE_ID_INTEL_I960RM)) {\r\nprintk(KERN_INFO DRV_NAME " %s: attached to I2O RAID controller,"\r\n" skipping\n", pci_name(dev));\r\nreturn -ENODEV;\r\n}\r\nreturn ide_pci_init_one(dev, d, NULL);\r\n}\r\nstatic void pdc202new_remove(struct pci_dev *dev)\r\n{\r\nstruct ide_host *host = pci_get_drvdata(dev);\r\nstruct pci_dev *dev2 = host->dev[1] ? to_pci_dev(host->dev[1]) : NULL;\r\nide_pci_remove(dev);\r\npci_dev_put(dev2);\r\n}\r\nstatic int __init pdc202new_ide_init(void)\r\n{\r\nreturn ide_pci_register_driver(&pdc202new_pci_driver);\r\n}\r\nstatic void __exit pdc202new_ide_exit(void)\r\n{\r\npci_unregister_driver(&pdc202new_pci_driver);\r\n}
