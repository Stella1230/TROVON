int arp_mc_map(__be32 addr, u8 *haddr, struct net_device *dev, int dir)\r\n{\r\nswitch (dev->type) {\r\ncase ARPHRD_ETHER:\r\ncase ARPHRD_FDDI:\r\ncase ARPHRD_IEEE802:\r\nip_eth_mc_map(addr, haddr);\r\nreturn 0;\r\ncase ARPHRD_INFINIBAND:\r\nip_ib_mc_map(addr, dev->broadcast, haddr);\r\nreturn 0;\r\ncase ARPHRD_IPGRE:\r\nip_ipgre_mc_map(addr, dev->broadcast, haddr);\r\nreturn 0;\r\ndefault:\r\nif (dir) {\r\nmemcpy(haddr, dev->broadcast, dev->addr_len);\r\nreturn 0;\r\n}\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic u32 arp_hash(const void *pkey,\r\nconst struct net_device *dev,\r\n__u32 *hash_rnd)\r\n{\r\nreturn arp_hashfn(pkey, dev, hash_rnd);\r\n}\r\nstatic bool arp_key_eq(const struct neighbour *neigh, const void *pkey)\r\n{\r\nreturn neigh_key_eq32(neigh, pkey);\r\n}\r\nstatic int arp_constructor(struct neighbour *neigh)\r\n{\r\n__be32 addr = *(__be32 *)neigh->primary_key;\r\nstruct net_device *dev = neigh->dev;\r\nstruct in_device *in_dev;\r\nstruct neigh_parms *parms;\r\nrcu_read_lock();\r\nin_dev = __in_dev_get_rcu(dev);\r\nif (!in_dev) {\r\nrcu_read_unlock();\r\nreturn -EINVAL;\r\n}\r\nneigh->type = inet_addr_type_dev_table(dev_net(dev), dev, addr);\r\nparms = in_dev->arp_parms;\r\n__neigh_parms_put(neigh->parms);\r\nneigh->parms = neigh_parms_clone(parms);\r\nrcu_read_unlock();\r\nif (!dev->header_ops) {\r\nneigh->nud_state = NUD_NOARP;\r\nneigh->ops = &arp_direct_ops;\r\nneigh->output = neigh_direct_output;\r\n} else {\r\nif (neigh->type == RTN_MULTICAST) {\r\nneigh->nud_state = NUD_NOARP;\r\narp_mc_map(addr, neigh->ha, dev, 1);\r\n} else if (dev->flags & (IFF_NOARP | IFF_LOOPBACK)) {\r\nneigh->nud_state = NUD_NOARP;\r\nmemcpy(neigh->ha, dev->dev_addr, dev->addr_len);\r\n} else if (neigh->type == RTN_BROADCAST ||\r\n(dev->flags & IFF_POINTOPOINT)) {\r\nneigh->nud_state = NUD_NOARP;\r\nmemcpy(neigh->ha, dev->broadcast, dev->addr_len);\r\n}\r\nif (dev->header_ops->cache)\r\nneigh->ops = &arp_hh_ops;\r\nelse\r\nneigh->ops = &arp_generic_ops;\r\nif (neigh->nud_state & NUD_VALID)\r\nneigh->output = neigh->ops->connected_output;\r\nelse\r\nneigh->output = neigh->ops->output;\r\n}\r\nreturn 0;\r\n}\r\nstatic void arp_error_report(struct neighbour *neigh, struct sk_buff *skb)\r\n{\r\ndst_link_failure(skb);\r\nkfree_skb(skb);\r\n}\r\nstatic void arp_send_dst(int type, int ptype, __be32 dest_ip,\r\nstruct net_device *dev, __be32 src_ip,\r\nconst unsigned char *dest_hw,\r\nconst unsigned char *src_hw,\r\nconst unsigned char *target_hw,\r\nstruct dst_entry *dst)\r\n{\r\nstruct sk_buff *skb;\r\nif (dev->flags & IFF_NOARP)\r\nreturn;\r\nskb = arp_create(type, ptype, dest_ip, dev, src_ip,\r\ndest_hw, src_hw, target_hw);\r\nif (!skb)\r\nreturn;\r\nskb_dst_set(skb, dst_clone(dst));\r\narp_xmit(skb);\r\n}\r\nvoid arp_send(int type, int ptype, __be32 dest_ip,\r\nstruct net_device *dev, __be32 src_ip,\r\nconst unsigned char *dest_hw, const unsigned char *src_hw,\r\nconst unsigned char *target_hw)\r\n{\r\narp_send_dst(type, ptype, dest_ip, dev, src_ip, dest_hw, src_hw,\r\ntarget_hw, NULL);\r\n}\r\nstatic void arp_solicit(struct neighbour *neigh, struct sk_buff *skb)\r\n{\r\n__be32 saddr = 0;\r\nu8 dst_ha[MAX_ADDR_LEN], *dst_hw = NULL;\r\nstruct net_device *dev = neigh->dev;\r\n__be32 target = *(__be32 *)neigh->primary_key;\r\nint probes = atomic_read(&neigh->probes);\r\nstruct in_device *in_dev;\r\nstruct dst_entry *dst = NULL;\r\nrcu_read_lock();\r\nin_dev = __in_dev_get_rcu(dev);\r\nif (!in_dev) {\r\nrcu_read_unlock();\r\nreturn;\r\n}\r\nswitch (IN_DEV_ARP_ANNOUNCE(in_dev)) {\r\ndefault:\r\ncase 0:\r\nif (skb && inet_addr_type_dev_table(dev_net(dev), dev,\r\nip_hdr(skb)->saddr) == RTN_LOCAL)\r\nsaddr = ip_hdr(skb)->saddr;\r\nbreak;\r\ncase 1:\r\nif (!skb)\r\nbreak;\r\nsaddr = ip_hdr(skb)->saddr;\r\nif (inet_addr_type_dev_table(dev_net(dev), dev,\r\nsaddr) == RTN_LOCAL) {\r\nif (inet_addr_onlink(in_dev, target, saddr))\r\nbreak;\r\n}\r\nsaddr = 0;\r\nbreak;\r\ncase 2:\r\nbreak;\r\n}\r\nrcu_read_unlock();\r\nif (!saddr)\r\nsaddr = inet_select_addr(dev, target, RT_SCOPE_LINK);\r\nprobes -= NEIGH_VAR(neigh->parms, UCAST_PROBES);\r\nif (probes < 0) {\r\nif (!(neigh->nud_state & NUD_VALID))\r\npr_debug("trying to ucast probe in NUD_INVALID\n");\r\nneigh_ha_snapshot(dst_ha, neigh, dev);\r\ndst_hw = dst_ha;\r\n} else {\r\nprobes -= NEIGH_VAR(neigh->parms, APP_PROBES);\r\nif (probes < 0) {\r\nneigh_app_ns(neigh);\r\nreturn;\r\n}\r\n}\r\nif (skb && !(dev->priv_flags & IFF_XMIT_DST_RELEASE))\r\ndst = skb_dst(skb);\r\narp_send_dst(ARPOP_REQUEST, ETH_P_ARP, target, dev, saddr,\r\ndst_hw, dev->dev_addr, NULL, dst);\r\n}\r\nstatic int arp_ignore(struct in_device *in_dev, __be32 sip, __be32 tip)\r\n{\r\nstruct net *net = dev_net(in_dev->dev);\r\nint scope;\r\nswitch (IN_DEV_ARP_IGNORE(in_dev)) {\r\ncase 0:\r\nreturn 0;\r\ncase 1:\r\nsip = 0;\r\nscope = RT_SCOPE_HOST;\r\nbreak;\r\ncase 2:\r\nscope = RT_SCOPE_HOST;\r\nbreak;\r\ncase 3:\r\nsip = 0;\r\nscope = RT_SCOPE_LINK;\r\nin_dev = NULL;\r\nbreak;\r\ncase 4:\r\ncase 5:\r\ncase 6:\r\ncase 7:\r\nreturn 0;\r\ncase 8:\r\nreturn 1;\r\ndefault:\r\nreturn 0;\r\n}\r\nreturn !inet_confirm_addr(net, in_dev, sip, tip, scope);\r\n}\r\nstatic int arp_filter(__be32 sip, __be32 tip, struct net_device *dev)\r\n{\r\nstruct rtable *rt;\r\nint flag = 0;\r\nstruct net *net = dev_net(dev);\r\nrt = ip_route_output(net, sip, tip, 0, 0);\r\nif (IS_ERR(rt))\r\nreturn 1;\r\nif (rt->dst.dev != dev) {\r\nNET_INC_STATS_BH(net, LINUX_MIB_ARPFILTER);\r\nflag = 1;\r\n}\r\nip_rt_put(rt);\r\nreturn flag;\r\n}\r\nstatic inline int arp_fwd_proxy(struct in_device *in_dev,\r\nstruct net_device *dev, struct rtable *rt)\r\n{\r\nstruct in_device *out_dev;\r\nint imi, omi = -1;\r\nif (rt->dst.dev == dev)\r\nreturn 0;\r\nif (!IN_DEV_PROXY_ARP(in_dev))\r\nreturn 0;\r\nimi = IN_DEV_MEDIUM_ID(in_dev);\r\nif (imi == 0)\r\nreturn 1;\r\nif (imi == -1)\r\nreturn 0;\r\nout_dev = __in_dev_get_rcu(rt->dst.dev);\r\nif (out_dev)\r\nomi = IN_DEV_MEDIUM_ID(out_dev);\r\nreturn omi != imi && omi != -1;\r\n}\r\nstatic inline int arp_fwd_pvlan(struct in_device *in_dev,\r\nstruct net_device *dev, struct rtable *rt,\r\n__be32 sip, __be32 tip)\r\n{\r\nif (rt->dst.dev != dev)\r\nreturn 0;\r\nif (sip == tip)\r\nreturn 0;\r\nif (IN_DEV_PROXY_ARP_PVLAN(in_dev))\r\nreturn 1;\r\nelse\r\nreturn 0;\r\n}\r\nstruct sk_buff *arp_create(int type, int ptype, __be32 dest_ip,\r\nstruct net_device *dev, __be32 src_ip,\r\nconst unsigned char *dest_hw,\r\nconst unsigned char *src_hw,\r\nconst unsigned char *target_hw)\r\n{\r\nstruct sk_buff *skb;\r\nstruct arphdr *arp;\r\nunsigned char *arp_ptr;\r\nint hlen = LL_RESERVED_SPACE(dev);\r\nint tlen = dev->needed_tailroom;\r\nskb = alloc_skb(arp_hdr_len(dev) + hlen + tlen, GFP_ATOMIC);\r\nif (!skb)\r\nreturn NULL;\r\nskb_reserve(skb, hlen);\r\nskb_reset_network_header(skb);\r\narp = (struct arphdr *) skb_put(skb, arp_hdr_len(dev));\r\nskb->dev = dev;\r\nskb->protocol = htons(ETH_P_ARP);\r\nif (!src_hw)\r\nsrc_hw = dev->dev_addr;\r\nif (!dest_hw)\r\ndest_hw = dev->broadcast;\r\nif (dev_hard_header(skb, dev, ptype, dest_hw, src_hw, skb->len) < 0)\r\ngoto out;\r\nswitch (dev->type) {\r\ndefault:\r\narp->ar_hrd = htons(dev->type);\r\narp->ar_pro = htons(ETH_P_IP);\r\nbreak;\r\n#if IS_ENABLED(CONFIG_AX25)\r\ncase ARPHRD_AX25:\r\narp->ar_hrd = htons(ARPHRD_AX25);\r\narp->ar_pro = htons(AX25_P_IP);\r\nbreak;\r\n#if IS_ENABLED(CONFIG_NETROM)\r\ncase ARPHRD_NETROM:\r\narp->ar_hrd = htons(ARPHRD_NETROM);\r\narp->ar_pro = htons(AX25_P_IP);\r\nbreak;\r\n#endif\r\n#endif\r\n#if IS_ENABLED(CONFIG_FDDI)\r\ncase ARPHRD_FDDI:\r\narp->ar_hrd = htons(ARPHRD_ETHER);\r\narp->ar_pro = htons(ETH_P_IP);\r\nbreak;\r\n#endif\r\n}\r\narp->ar_hln = dev->addr_len;\r\narp->ar_pln = 4;\r\narp->ar_op = htons(type);\r\narp_ptr = (unsigned char *)(arp + 1);\r\nmemcpy(arp_ptr, src_hw, dev->addr_len);\r\narp_ptr += dev->addr_len;\r\nmemcpy(arp_ptr, &src_ip, 4);\r\narp_ptr += 4;\r\nswitch (dev->type) {\r\n#if IS_ENABLED(CONFIG_FIREWIRE_NET)\r\ncase ARPHRD_IEEE1394:\r\nbreak;\r\n#endif\r\ndefault:\r\nif (target_hw)\r\nmemcpy(arp_ptr, target_hw, dev->addr_len);\r\nelse\r\nmemset(arp_ptr, 0, dev->addr_len);\r\narp_ptr += dev->addr_len;\r\n}\r\nmemcpy(arp_ptr, &dest_ip, 4);\r\nreturn skb;\r\nout:\r\nkfree_skb(skb);\r\nreturn NULL;\r\n}\r\nstatic int arp_xmit_finish(struct net *net, struct sock *sk, struct sk_buff *skb)\r\n{\r\nreturn dev_queue_xmit(skb);\r\n}\r\nvoid arp_xmit(struct sk_buff *skb)\r\n{\r\nNF_HOOK(NFPROTO_ARP, NF_ARP_OUT,\r\ndev_net(skb->dev), NULL, skb, NULL, skb->dev,\r\narp_xmit_finish);\r\n}\r\nstatic int arp_process(struct net *net, struct sock *sk, struct sk_buff *skb)\r\n{\r\nstruct net_device *dev = skb->dev;\r\nstruct in_device *in_dev = __in_dev_get_rcu(dev);\r\nstruct arphdr *arp;\r\nunsigned char *arp_ptr;\r\nstruct rtable *rt;\r\nunsigned char *sha;\r\n__be32 sip, tip;\r\nu16 dev_type = dev->type;\r\nint addr_type;\r\nstruct neighbour *n;\r\nstruct dst_entry *reply_dst = NULL;\r\nbool is_garp = false;\r\nif (!in_dev)\r\ngoto out;\r\narp = arp_hdr(skb);\r\nswitch (dev_type) {\r\ndefault:\r\nif (arp->ar_pro != htons(ETH_P_IP) ||\r\nhtons(dev_type) != arp->ar_hrd)\r\ngoto out;\r\nbreak;\r\ncase ARPHRD_ETHER:\r\ncase ARPHRD_FDDI:\r\ncase ARPHRD_IEEE802:\r\nif ((arp->ar_hrd != htons(ARPHRD_ETHER) &&\r\narp->ar_hrd != htons(ARPHRD_IEEE802)) ||\r\narp->ar_pro != htons(ETH_P_IP))\r\ngoto out;\r\nbreak;\r\ncase ARPHRD_AX25:\r\nif (arp->ar_pro != htons(AX25_P_IP) ||\r\narp->ar_hrd != htons(ARPHRD_AX25))\r\ngoto out;\r\nbreak;\r\ncase ARPHRD_NETROM:\r\nif (arp->ar_pro != htons(AX25_P_IP) ||\r\narp->ar_hrd != htons(ARPHRD_NETROM))\r\ngoto out;\r\nbreak;\r\n}\r\nif (arp->ar_op != htons(ARPOP_REPLY) &&\r\narp->ar_op != htons(ARPOP_REQUEST))\r\ngoto out;\r\narp_ptr = (unsigned char *)(arp + 1);\r\nsha = arp_ptr;\r\narp_ptr += dev->addr_len;\r\nmemcpy(&sip, arp_ptr, 4);\r\narp_ptr += 4;\r\nswitch (dev_type) {\r\n#if IS_ENABLED(CONFIG_FIREWIRE_NET)\r\ncase ARPHRD_IEEE1394:\r\nbreak;\r\n#endif\r\ndefault:\r\narp_ptr += dev->addr_len;\r\n}\r\nmemcpy(&tip, arp_ptr, 4);\r\nif (ipv4_is_multicast(tip) ||\r\n(!IN_DEV_ROUTE_LOCALNET(in_dev) && ipv4_is_loopback(tip)))\r\ngoto out;\r\nif (dev_type == ARPHRD_DLCI)\r\nsha = dev->broadcast;\r\nif (arp->ar_op == htons(ARPOP_REQUEST) && skb_metadata_dst(skb))\r\nreply_dst = (struct dst_entry *)\r\niptunnel_metadata_reply(skb_metadata_dst(skb),\r\nGFP_ATOMIC);\r\nif (sip == 0) {\r\nif (arp->ar_op == htons(ARPOP_REQUEST) &&\r\ninet_addr_type_dev_table(net, dev, tip) == RTN_LOCAL &&\r\n!arp_ignore(in_dev, sip, tip))\r\narp_send_dst(ARPOP_REPLY, ETH_P_ARP, sip, dev, tip,\r\nsha, dev->dev_addr, sha, reply_dst);\r\ngoto out;\r\n}\r\nif (arp->ar_op == htons(ARPOP_REQUEST) &&\r\nip_route_input_noref(skb, tip, sip, 0, dev) == 0) {\r\nrt = skb_rtable(skb);\r\naddr_type = rt->rt_type;\r\nif (addr_type == RTN_LOCAL) {\r\nint dont_send;\r\ndont_send = arp_ignore(in_dev, sip, tip);\r\nif (!dont_send && IN_DEV_ARPFILTER(in_dev))\r\ndont_send = arp_filter(sip, tip, dev);\r\nif (!dont_send) {\r\nn = neigh_event_ns(&arp_tbl, sha, &sip, dev);\r\nif (n) {\r\narp_send_dst(ARPOP_REPLY, ETH_P_ARP,\r\nsip, dev, tip, sha,\r\ndev->dev_addr, sha,\r\nreply_dst);\r\nneigh_release(n);\r\n}\r\n}\r\ngoto out;\r\n} else if (IN_DEV_FORWARD(in_dev)) {\r\nif (addr_type == RTN_UNICAST &&\r\n(arp_fwd_proxy(in_dev, dev, rt) ||\r\narp_fwd_pvlan(in_dev, dev, rt, sip, tip) ||\r\n(rt->dst.dev != dev &&\r\npneigh_lookup(&arp_tbl, net, &tip, dev, 0)))) {\r\nn = neigh_event_ns(&arp_tbl, sha, &sip, dev);\r\nif (n)\r\nneigh_release(n);\r\nif (NEIGH_CB(skb)->flags & LOCALLY_ENQUEUED ||\r\nskb->pkt_type == PACKET_HOST ||\r\nNEIGH_VAR(in_dev->arp_parms, PROXY_DELAY) == 0) {\r\narp_send_dst(ARPOP_REPLY, ETH_P_ARP,\r\nsip, dev, tip, sha,\r\ndev->dev_addr, sha,\r\nreply_dst);\r\n} else {\r\npneigh_enqueue(&arp_tbl,\r\nin_dev->arp_parms, skb);\r\ngoto out_free_dst;\r\n}\r\ngoto out;\r\n}\r\n}\r\n}\r\nn = __neigh_lookup(&arp_tbl, &sip, dev, 0);\r\nif (IN_DEV_ARP_ACCEPT(in_dev)) {\r\nunsigned int addr_type = inet_addr_type_dev_table(net, dev, sip);\r\nis_garp = arp->ar_op == htons(ARPOP_REQUEST) && tip == sip &&\r\naddr_type == RTN_UNICAST;\r\nif (!n &&\r\n((arp->ar_op == htons(ARPOP_REPLY) &&\r\naddr_type == RTN_UNICAST) || is_garp))\r\nn = __neigh_lookup(&arp_tbl, &sip, dev, 1);\r\n}\r\nif (n) {\r\nint state = NUD_REACHABLE;\r\nint override;\r\noverride = time_after(jiffies,\r\nn->updated +\r\nNEIGH_VAR(n->parms, LOCKTIME)) ||\r\nis_garp;\r\nif (arp->ar_op != htons(ARPOP_REPLY) ||\r\nskb->pkt_type != PACKET_HOST)\r\nstate = NUD_STALE;\r\nneigh_update(n, sha, state,\r\noverride ? NEIGH_UPDATE_F_OVERRIDE : 0);\r\nneigh_release(n);\r\n}\r\nout:\r\nconsume_skb(skb);\r\nout_free_dst:\r\ndst_release(reply_dst);\r\nreturn 0;\r\n}\r\nstatic void parp_redo(struct sk_buff *skb)\r\n{\r\narp_process(dev_net(skb->dev), NULL, skb);\r\n}\r\nstatic int arp_rcv(struct sk_buff *skb, struct net_device *dev,\r\nstruct packet_type *pt, struct net_device *orig_dev)\r\n{\r\nconst struct arphdr *arp;\r\nif (dev->flags & IFF_NOARP ||\r\nskb->pkt_type == PACKET_OTHERHOST ||\r\nskb->pkt_type == PACKET_LOOPBACK)\r\ngoto consumeskb;\r\nskb = skb_share_check(skb, GFP_ATOMIC);\r\nif (!skb)\r\ngoto out_of_mem;\r\nif (!pskb_may_pull(skb, arp_hdr_len(dev)))\r\ngoto freeskb;\r\narp = arp_hdr(skb);\r\nif (arp->ar_hln != dev->addr_len || arp->ar_pln != 4)\r\ngoto freeskb;\r\nmemset(NEIGH_CB(skb), 0, sizeof(struct neighbour_cb));\r\nreturn NF_HOOK(NFPROTO_ARP, NF_ARP_IN,\r\ndev_net(dev), NULL, skb, dev, NULL,\r\narp_process);\r\nconsumeskb:\r\nconsume_skb(skb);\r\nreturn 0;\r\nfreeskb:\r\nkfree_skb(skb);\r\nout_of_mem:\r\nreturn 0;\r\n}\r\nstatic int arp_req_set_proxy(struct net *net, struct net_device *dev, int on)\r\n{\r\nif (!dev) {\r\nIPV4_DEVCONF_ALL(net, PROXY_ARP) = on;\r\nreturn 0;\r\n}\r\nif (__in_dev_get_rtnl(dev)) {\r\nIN_DEV_CONF_SET(__in_dev_get_rtnl(dev), PROXY_ARP, on);\r\nreturn 0;\r\n}\r\nreturn -ENXIO;\r\n}\r\nstatic int arp_req_set_public(struct net *net, struct arpreq *r,\r\nstruct net_device *dev)\r\n{\r\n__be32 ip = ((struct sockaddr_in *)&r->arp_pa)->sin_addr.s_addr;\r\n__be32 mask = ((struct sockaddr_in *)&r->arp_netmask)->sin_addr.s_addr;\r\nif (mask && mask != htonl(0xFFFFFFFF))\r\nreturn -EINVAL;\r\nif (!dev && (r->arp_flags & ATF_COM)) {\r\ndev = dev_getbyhwaddr_rcu(net, r->arp_ha.sa_family,\r\nr->arp_ha.sa_data);\r\nif (!dev)\r\nreturn -ENODEV;\r\n}\r\nif (mask) {\r\nif (!pneigh_lookup(&arp_tbl, net, &ip, dev, 1))\r\nreturn -ENOBUFS;\r\nreturn 0;\r\n}\r\nreturn arp_req_set_proxy(net, dev, 1);\r\n}\r\nstatic int arp_req_set(struct net *net, struct arpreq *r,\r\nstruct net_device *dev)\r\n{\r\n__be32 ip;\r\nstruct neighbour *neigh;\r\nint err;\r\nif (r->arp_flags & ATF_PUBL)\r\nreturn arp_req_set_public(net, r, dev);\r\nip = ((struct sockaddr_in *)&r->arp_pa)->sin_addr.s_addr;\r\nif (r->arp_flags & ATF_PERM)\r\nr->arp_flags |= ATF_COM;\r\nif (!dev) {\r\nstruct rtable *rt = ip_route_output(net, ip, 0, RTO_ONLINK, 0);\r\nif (IS_ERR(rt))\r\nreturn PTR_ERR(rt);\r\ndev = rt->dst.dev;\r\nip_rt_put(rt);\r\nif (!dev)\r\nreturn -EINVAL;\r\n}\r\nswitch (dev->type) {\r\n#if IS_ENABLED(CONFIG_FDDI)\r\ncase ARPHRD_FDDI:\r\nif (r->arp_ha.sa_family != ARPHRD_FDDI &&\r\nr->arp_ha.sa_family != ARPHRD_ETHER &&\r\nr->arp_ha.sa_family != ARPHRD_IEEE802)\r\nreturn -EINVAL;\r\nbreak;\r\n#endif\r\ndefault:\r\nif (r->arp_ha.sa_family != dev->type)\r\nreturn -EINVAL;\r\nbreak;\r\n}\r\nneigh = __neigh_lookup_errno(&arp_tbl, &ip, dev);\r\nerr = PTR_ERR(neigh);\r\nif (!IS_ERR(neigh)) {\r\nunsigned int state = NUD_STALE;\r\nif (r->arp_flags & ATF_PERM)\r\nstate = NUD_PERMANENT;\r\nerr = neigh_update(neigh, (r->arp_flags & ATF_COM) ?\r\nr->arp_ha.sa_data : NULL, state,\r\nNEIGH_UPDATE_F_OVERRIDE |\r\nNEIGH_UPDATE_F_ADMIN);\r\nneigh_release(neigh);\r\n}\r\nreturn err;\r\n}\r\nstatic unsigned int arp_state_to_flags(struct neighbour *neigh)\r\n{\r\nif (neigh->nud_state&NUD_PERMANENT)\r\nreturn ATF_PERM | ATF_COM;\r\nelse if (neigh->nud_state&NUD_VALID)\r\nreturn ATF_COM;\r\nelse\r\nreturn 0;\r\n}\r\nstatic int arp_req_get(struct arpreq *r, struct net_device *dev)\r\n{\r\n__be32 ip = ((struct sockaddr_in *) &r->arp_pa)->sin_addr.s_addr;\r\nstruct neighbour *neigh;\r\nint err = -ENXIO;\r\nneigh = neigh_lookup(&arp_tbl, &ip, dev);\r\nif (neigh) {\r\nif (!(neigh->nud_state & NUD_NOARP)) {\r\nread_lock_bh(&neigh->lock);\r\nmemcpy(r->arp_ha.sa_data, neigh->ha, dev->addr_len);\r\nr->arp_flags = arp_state_to_flags(neigh);\r\nread_unlock_bh(&neigh->lock);\r\nr->arp_ha.sa_family = dev->type;\r\nstrlcpy(r->arp_dev, dev->name, sizeof(r->arp_dev));\r\nerr = 0;\r\n}\r\nneigh_release(neigh);\r\n}\r\nreturn err;\r\n}\r\nstatic int arp_invalidate(struct net_device *dev, __be32 ip)\r\n{\r\nstruct neighbour *neigh = neigh_lookup(&arp_tbl, &ip, dev);\r\nint err = -ENXIO;\r\nif (neigh) {\r\nif (neigh->nud_state & ~NUD_NOARP)\r\nerr = neigh_update(neigh, NULL, NUD_FAILED,\r\nNEIGH_UPDATE_F_OVERRIDE|\r\nNEIGH_UPDATE_F_ADMIN);\r\nneigh_release(neigh);\r\n}\r\nreturn err;\r\n}\r\nstatic int arp_req_delete_public(struct net *net, struct arpreq *r,\r\nstruct net_device *dev)\r\n{\r\n__be32 ip = ((struct sockaddr_in *) &r->arp_pa)->sin_addr.s_addr;\r\n__be32 mask = ((struct sockaddr_in *)&r->arp_netmask)->sin_addr.s_addr;\r\nif (mask == htonl(0xFFFFFFFF))\r\nreturn pneigh_delete(&arp_tbl, net, &ip, dev);\r\nif (mask)\r\nreturn -EINVAL;\r\nreturn arp_req_set_proxy(net, dev, 0);\r\n}\r\nstatic int arp_req_delete(struct net *net, struct arpreq *r,\r\nstruct net_device *dev)\r\n{\r\n__be32 ip;\r\nif (r->arp_flags & ATF_PUBL)\r\nreturn arp_req_delete_public(net, r, dev);\r\nip = ((struct sockaddr_in *)&r->arp_pa)->sin_addr.s_addr;\r\nif (!dev) {\r\nstruct rtable *rt = ip_route_output(net, ip, 0, RTO_ONLINK, 0);\r\nif (IS_ERR(rt))\r\nreturn PTR_ERR(rt);\r\ndev = rt->dst.dev;\r\nip_rt_put(rt);\r\nif (!dev)\r\nreturn -EINVAL;\r\n}\r\nreturn arp_invalidate(dev, ip);\r\n}\r\nint arp_ioctl(struct net *net, unsigned int cmd, void __user *arg)\r\n{\r\nint err;\r\nstruct arpreq r;\r\nstruct net_device *dev = NULL;\r\nswitch (cmd) {\r\ncase SIOCDARP:\r\ncase SIOCSARP:\r\nif (!ns_capable(net->user_ns, CAP_NET_ADMIN))\r\nreturn -EPERM;\r\ncase SIOCGARP:\r\nerr = copy_from_user(&r, arg, sizeof(struct arpreq));\r\nif (err)\r\nreturn -EFAULT;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nif (r.arp_pa.sa_family != AF_INET)\r\nreturn -EPFNOSUPPORT;\r\nif (!(r.arp_flags & ATF_PUBL) &&\r\n(r.arp_flags & (ATF_NETMASK | ATF_DONTPUB)))\r\nreturn -EINVAL;\r\nif (!(r.arp_flags & ATF_NETMASK))\r\n((struct sockaddr_in *)&r.arp_netmask)->sin_addr.s_addr =\r\nhtonl(0xFFFFFFFFUL);\r\nrtnl_lock();\r\nif (r.arp_dev[0]) {\r\nerr = -ENODEV;\r\ndev = __dev_get_by_name(net, r.arp_dev);\r\nif (!dev)\r\ngoto out;\r\nif (!r.arp_ha.sa_family)\r\nr.arp_ha.sa_family = dev->type;\r\nerr = -EINVAL;\r\nif ((r.arp_flags & ATF_COM) && r.arp_ha.sa_family != dev->type)\r\ngoto out;\r\n} else if (cmd == SIOCGARP) {\r\nerr = -ENODEV;\r\ngoto out;\r\n}\r\nswitch (cmd) {\r\ncase SIOCDARP:\r\nerr = arp_req_delete(net, &r, dev);\r\nbreak;\r\ncase SIOCSARP:\r\nerr = arp_req_set(net, &r, dev);\r\nbreak;\r\ncase SIOCGARP:\r\nerr = arp_req_get(&r, dev);\r\nbreak;\r\n}\r\nout:\r\nrtnl_unlock();\r\nif (cmd == SIOCGARP && !err && copy_to_user(arg, &r, sizeof(r)))\r\nerr = -EFAULT;\r\nreturn err;\r\n}\r\nstatic int arp_netdev_event(struct notifier_block *this, unsigned long event,\r\nvoid *ptr)\r\n{\r\nstruct net_device *dev = netdev_notifier_info_to_dev(ptr);\r\nstruct netdev_notifier_change_info *change_info;\r\nswitch (event) {\r\ncase NETDEV_CHANGEADDR:\r\nneigh_changeaddr(&arp_tbl, dev);\r\nrt_cache_flush(dev_net(dev));\r\nbreak;\r\ncase NETDEV_CHANGE:\r\nchange_info = ptr;\r\nif (change_info->flags_changed & IFF_NOARP)\r\nneigh_changeaddr(&arp_tbl, dev);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nreturn NOTIFY_DONE;\r\n}\r\nvoid arp_ifdown(struct net_device *dev)\r\n{\r\nneigh_ifdown(&arp_tbl, dev);\r\n}\r\nvoid __init arp_init(void)\r\n{\r\nneigh_table_init(NEIGH_ARP_TABLE, &arp_tbl);\r\ndev_add_pack(&arp_packet_type);\r\narp_proc_init();\r\n#ifdef CONFIG_SYSCTL\r\nneigh_sysctl_register(NULL, &arp_tbl.parms, NULL);\r\n#endif\r\nregister_netdevice_notifier(&arp_netdev_notifier);\r\n}\r\nstatic char *ax2asc2(ax25_address *a, char *buf)\r\n{\r\nchar c, *s;\r\nint n;\r\nfor (n = 0, s = buf; n < 6; n++) {\r\nc = (a->ax25_call[n] >> 1) & 0x7F;\r\nif (c != ' ')\r\n*s++ = c;\r\n}\r\n*s++ = '-';\r\nn = (a->ax25_call[6] >> 1) & 0x0F;\r\nif (n > 9) {\r\n*s++ = '1';\r\nn -= 10;\r\n}\r\n*s++ = n + '0';\r\n*s++ = '\0';\r\nif (*buf == '\0' || *buf == '-')\r\nreturn "*";\r\nreturn buf;\r\n}\r\nstatic void arp_format_neigh_entry(struct seq_file *seq,\r\nstruct neighbour *n)\r\n{\r\nchar hbuffer[HBUFFERLEN];\r\nint k, j;\r\nchar tbuf[16];\r\nstruct net_device *dev = n->dev;\r\nint hatype = dev->type;\r\nread_lock(&n->lock);\r\n#if IS_ENABLED(CONFIG_AX25)\r\nif (hatype == ARPHRD_AX25 || hatype == ARPHRD_NETROM)\r\nax2asc2((ax25_address *)n->ha, hbuffer);\r\nelse {\r\n#endif\r\nfor (k = 0, j = 0; k < HBUFFERLEN - 3 && j < dev->addr_len; j++) {\r\nhbuffer[k++] = hex_asc_hi(n->ha[j]);\r\nhbuffer[k++] = hex_asc_lo(n->ha[j]);\r\nhbuffer[k++] = ':';\r\n}\r\nif (k != 0)\r\n--k;\r\nhbuffer[k] = 0;\r\n#if IS_ENABLED(CONFIG_AX25)\r\n}\r\n#endif\r\nsprintf(tbuf, "%pI4", n->primary_key);\r\nseq_printf(seq, "%-16s 0x%-10x0x%-10x%s * %s\n",\r\ntbuf, hatype, arp_state_to_flags(n), hbuffer, dev->name);\r\nread_unlock(&n->lock);\r\n}\r\nstatic void arp_format_pneigh_entry(struct seq_file *seq,\r\nstruct pneigh_entry *n)\r\n{\r\nstruct net_device *dev = n->dev;\r\nint hatype = dev ? dev->type : 0;\r\nchar tbuf[16];\r\nsprintf(tbuf, "%pI4", n->key);\r\nseq_printf(seq, "%-16s 0x%-10x0x%-10x%s * %s\n",\r\ntbuf, hatype, ATF_PUBL | ATF_PERM, "00:00:00:00:00:00",\r\ndev ? dev->name : "*");\r\n}\r\nstatic int arp_seq_show(struct seq_file *seq, void *v)\r\n{\r\nif (v == SEQ_START_TOKEN) {\r\nseq_puts(seq, "IP address HW type Flags "\r\n"HW address Mask Device\n");\r\n} else {\r\nstruct neigh_seq_state *state = seq->private;\r\nif (state->flags & NEIGH_SEQ_IS_PNEIGH)\r\narp_format_pneigh_entry(seq, v);\r\nelse\r\narp_format_neigh_entry(seq, v);\r\n}\r\nreturn 0;\r\n}\r\nstatic void *arp_seq_start(struct seq_file *seq, loff_t *pos)\r\n{\r\nreturn neigh_seq_start(seq, pos, &arp_tbl, NEIGH_SEQ_SKIP_NOARP);\r\n}\r\nstatic int arp_seq_open(struct inode *inode, struct file *file)\r\n{\r\nreturn seq_open_net(inode, file, &arp_seq_ops,\r\nsizeof(struct neigh_seq_state));\r\n}\r\nstatic int __net_init arp_net_init(struct net *net)\r\n{\r\nif (!proc_create("arp", S_IRUGO, net->proc_net, &arp_seq_fops))\r\nreturn -ENOMEM;\r\nreturn 0;\r\n}\r\nstatic void __net_exit arp_net_exit(struct net *net)\r\n{\r\nremove_proc_entry("arp", net->proc_net);\r\n}\r\nstatic int __init arp_proc_init(void)\r\n{\r\nreturn register_pernet_subsys(&arp_net_ops);\r\n}\r\nstatic int __init arp_proc_init(void)\r\n{\r\nreturn 0;\r\n}
