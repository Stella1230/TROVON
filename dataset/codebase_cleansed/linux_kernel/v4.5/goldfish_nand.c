static u32 goldfish_nand_cmd_with_params(struct mtd_info *mtd,\r\nenum nand_cmd cmd, u64 addr, u32 len,\r\nvoid *ptr, u32 *rv)\r\n{\r\nu32 cmdp;\r\nstruct goldfish_nand *nand = mtd->priv;\r\nstruct cmd_params *cps = nand->cmd_params;\r\nunsigned char __iomem *base = nand->base;\r\nif (!cps)\r\nreturn -1;\r\nswitch (cmd) {\r\ncase NAND_CMD_ERASE:\r\ncmdp = NAND_CMD_ERASE_WITH_PARAMS;\r\nbreak;\r\ncase NAND_CMD_READ:\r\ncmdp = NAND_CMD_READ_WITH_PARAMS;\r\nbreak;\r\ncase NAND_CMD_WRITE:\r\ncmdp = NAND_CMD_WRITE_WITH_PARAMS;\r\nbreak;\r\ndefault:\r\nreturn -1;\r\n}\r\ncps->dev = mtd - nand->mtd;\r\ncps->addr_high = (u32)(addr >> 32);\r\ncps->addr_low = (u32)addr;\r\ncps->transfer_size = len;\r\ncps->data = (unsigned long)ptr;\r\nwritel(cmdp, base + NAND_COMMAND);\r\n*rv = cps->result;\r\nreturn 0;\r\n}\r\nstatic u32 goldfish_nand_cmd(struct mtd_info *mtd, enum nand_cmd cmd,\r\nu64 addr, u32 len, void *ptr)\r\n{\r\nstruct goldfish_nand *nand = mtd->priv;\r\nu32 rv;\r\nunsigned char __iomem *base = nand->base;\r\nmutex_lock(&nand->lock);\r\nif (goldfish_nand_cmd_with_params(mtd, cmd, addr, len, ptr, &rv)) {\r\nwritel(mtd - nand->mtd, base + NAND_DEV);\r\nwritel((u32)(addr >> 32), base + NAND_ADDR_HIGH);\r\nwritel((u32)addr, base + NAND_ADDR_LOW);\r\nwritel(len, base + NAND_TRANSFER_SIZE);\r\ngf_write_ptr(ptr, base + NAND_DATA, base + NAND_DATA_HIGH);\r\nwritel(cmd, base + NAND_COMMAND);\r\nrv = readl(base + NAND_RESULT);\r\n}\r\nmutex_unlock(&nand->lock);\r\nreturn rv;\r\n}\r\nstatic int goldfish_nand_erase(struct mtd_info *mtd, struct erase_info *instr)\r\n{\r\nloff_t ofs = instr->addr;\r\nu32 len = instr->len;\r\nu32 rem;\r\nif (ofs + len > mtd->size)\r\ngoto invalid_arg;\r\nrem = do_div(ofs, mtd->writesize);\r\nif (rem)\r\ngoto invalid_arg;\r\nofs *= (mtd->writesize + mtd->oobsize);\r\nif (len % mtd->writesize)\r\ngoto invalid_arg;\r\nlen = len / mtd->writesize * (mtd->writesize + mtd->oobsize);\r\nif (goldfish_nand_cmd(mtd, NAND_CMD_ERASE, ofs, len, NULL) != len) {\r\npr_err("goldfish_nand_erase: erase failed, start %llx, len %x, dev_size %llx, erase_size %x\n",\r\nofs, len, mtd->size, mtd->erasesize);\r\nreturn -EIO;\r\n}\r\ninstr->state = MTD_ERASE_DONE;\r\nmtd_erase_callback(instr);\r\nreturn 0;\r\ninvalid_arg:\r\npr_err("goldfish_nand_erase: invalid erase, start %llx, len %x, dev_size %llx, erase_size %x\n",\r\nofs, len, mtd->size, mtd->erasesize);\r\nreturn -EINVAL;\r\n}\r\nstatic int goldfish_nand_read_oob(struct mtd_info *mtd, loff_t ofs,\r\nstruct mtd_oob_ops *ops)\r\n{\r\nu32 rem;\r\nif (ofs + ops->len > mtd->size)\r\ngoto invalid_arg;\r\nif (ops->datbuf && ops->len && ops->len != mtd->writesize)\r\ngoto invalid_arg;\r\nif (ops->ooblen + ops->ooboffs > mtd->oobsize)\r\ngoto invalid_arg;\r\nrem = do_div(ofs, mtd->writesize);\r\nif (rem)\r\ngoto invalid_arg;\r\nofs *= (mtd->writesize + mtd->oobsize);\r\nif (ops->datbuf)\r\nops->retlen = goldfish_nand_cmd(mtd, NAND_CMD_READ, ofs,\r\nops->len, ops->datbuf);\r\nofs += mtd->writesize + ops->ooboffs;\r\nif (ops->oobbuf)\r\nops->oobretlen = goldfish_nand_cmd(mtd, NAND_CMD_READ, ofs,\r\nops->ooblen, ops->oobbuf);\r\nreturn 0;\r\ninvalid_arg:\r\npr_err("goldfish_nand_read_oob: invalid read, start %llx, len %zx, ooblen %zx, dev_size %llx, write_size %x\n",\r\nofs, ops->len, ops->ooblen, mtd->size, mtd->writesize);\r\nreturn -EINVAL;\r\n}\r\nstatic int goldfish_nand_write_oob(struct mtd_info *mtd, loff_t ofs,\r\nstruct mtd_oob_ops *ops)\r\n{\r\nu32 rem;\r\nif (ofs + ops->len > mtd->size)\r\ngoto invalid_arg;\r\nif (ops->len && ops->len != mtd->writesize)\r\ngoto invalid_arg;\r\nif (ops->ooblen + ops->ooboffs > mtd->oobsize)\r\ngoto invalid_arg;\r\nrem = do_div(ofs, mtd->writesize);\r\nif (rem)\r\ngoto invalid_arg;\r\nofs *= (mtd->writesize + mtd->oobsize);\r\nif (ops->datbuf)\r\nops->retlen = goldfish_nand_cmd(mtd, NAND_CMD_WRITE, ofs,\r\nops->len, ops->datbuf);\r\nofs += mtd->writesize + ops->ooboffs;\r\nif (ops->oobbuf)\r\nops->oobretlen = goldfish_nand_cmd(mtd, NAND_CMD_WRITE, ofs,\r\nops->ooblen, ops->oobbuf);\r\nreturn 0;\r\ninvalid_arg:\r\npr_err("goldfish_nand_write_oob: invalid write, start %llx, len %zx, ooblen %zx, dev_size %llx, write_size %x\n",\r\nofs, ops->len, ops->ooblen, mtd->size, mtd->writesize);\r\nreturn -EINVAL;\r\n}\r\nstatic int goldfish_nand_read(struct mtd_info *mtd, loff_t from, size_t len,\r\nsize_t *retlen, u_char *buf)\r\n{\r\nu32 rem;\r\nif (from + len > mtd->size)\r\ngoto invalid_arg;\r\nrem = do_div(from, mtd->writesize);\r\nif (rem)\r\ngoto invalid_arg;\r\nfrom *= (mtd->writesize + mtd->oobsize);\r\n*retlen = goldfish_nand_cmd(mtd, NAND_CMD_READ, from, len, buf);\r\nreturn 0;\r\ninvalid_arg:\r\npr_err("goldfish_nand_read: invalid read, start %llx, len %zx, dev_size %llx, write_size %x\n",\r\nfrom, len, mtd->size, mtd->writesize);\r\nreturn -EINVAL;\r\n}\r\nstatic int goldfish_nand_write(struct mtd_info *mtd, loff_t to, size_t len,\r\nsize_t *retlen, const u_char *buf)\r\n{\r\nu32 rem;\r\nif (to + len > mtd->size)\r\ngoto invalid_arg;\r\nrem = do_div(to, mtd->writesize);\r\nif (rem)\r\ngoto invalid_arg;\r\nto *= (mtd->writesize + mtd->oobsize);\r\n*retlen = goldfish_nand_cmd(mtd, NAND_CMD_WRITE, to, len, (void *)buf);\r\nreturn 0;\r\ninvalid_arg:\r\npr_err("goldfish_nand_write: invalid write, start %llx, len %zx, dev_size %llx, write_size %x\n",\r\nto, len, mtd->size, mtd->writesize);\r\nreturn -EINVAL;\r\n}\r\nstatic int goldfish_nand_block_isbad(struct mtd_info *mtd, loff_t ofs)\r\n{\r\nu32 rem;\r\nif (ofs >= mtd->size)\r\ngoto invalid_arg;\r\nrem = do_div(ofs, mtd->erasesize);\r\nif (rem)\r\ngoto invalid_arg;\r\nofs *= mtd->erasesize / mtd->writesize;\r\nofs *= (mtd->writesize + mtd->oobsize);\r\nreturn goldfish_nand_cmd(mtd, NAND_CMD_BLOCK_BAD_GET, ofs, 0, NULL);\r\ninvalid_arg:\r\npr_err("goldfish_nand_block_isbad: invalid arg, ofs %llx, dev_size %llx, write_size %x\n",\r\nofs, mtd->size, mtd->writesize);\r\nreturn -EINVAL;\r\n}\r\nstatic int goldfish_nand_block_markbad(struct mtd_info *mtd, loff_t ofs)\r\n{\r\nu32 rem;\r\nif (ofs >= mtd->size)\r\ngoto invalid_arg;\r\nrem = do_div(ofs, mtd->erasesize);\r\nif (rem)\r\ngoto invalid_arg;\r\nofs *= mtd->erasesize / mtd->writesize;\r\nofs *= (mtd->writesize + mtd->oobsize);\r\nif (goldfish_nand_cmd(mtd, NAND_CMD_BLOCK_BAD_SET, ofs, 0, NULL) != 1)\r\nreturn -EIO;\r\nreturn 0;\r\ninvalid_arg:\r\npr_err("goldfish_nand_block_markbad: invalid arg, ofs %llx, dev_size %llx, write_size %x\n",\r\nofs, mtd->size, mtd->writesize);\r\nreturn -EINVAL;\r\n}\r\nstatic int nand_setup_cmd_params(struct platform_device *pdev,\r\nstruct goldfish_nand *nand)\r\n{\r\nu64 paddr;\r\nunsigned char __iomem *base = nand->base;\r\nnand->cmd_params = devm_kzalloc(&pdev->dev,\r\nsizeof(struct cmd_params), GFP_KERNEL);\r\nif (!nand->cmd_params)\r\nreturn -1;\r\npaddr = __pa(nand->cmd_params);\r\nwritel((u32)(paddr >> 32), base + NAND_CMD_PARAMS_ADDR_HIGH);\r\nwritel((u32)paddr, base + NAND_CMD_PARAMS_ADDR_LOW);\r\nreturn 0;\r\n}\r\nstatic int goldfish_nand_init_device(struct platform_device *pdev,\r\nstruct goldfish_nand *nand, int id)\r\n{\r\nu32 name_len;\r\nu32 result;\r\nu32 flags;\r\nunsigned char __iomem *base = nand->base;\r\nstruct mtd_info *mtd = &nand->mtd[id];\r\nchar *name;\r\nmutex_lock(&nand->lock);\r\nwritel(id, base + NAND_DEV);\r\nflags = readl(base + NAND_DEV_FLAGS);\r\nname_len = readl(base + NAND_DEV_NAME_LEN);\r\nmtd->writesize = readl(base + NAND_DEV_PAGE_SIZE);\r\nmtd->size = readl(base + NAND_DEV_SIZE_LOW);\r\nmtd->size |= (u64)readl(base + NAND_DEV_SIZE_HIGH) << 32;\r\nmtd->oobsize = readl(base + NAND_DEV_EXTRA_SIZE);\r\nmtd->oobavail = mtd->oobsize;\r\nmtd->erasesize = readl(base + NAND_DEV_ERASE_SIZE) /\r\n(mtd->writesize + mtd->oobsize) * mtd->writesize;\r\ndo_div(mtd->size, mtd->writesize + mtd->oobsize);\r\nmtd->size *= mtd->writesize;\r\ndev_dbg(&pdev->dev,\r\n"goldfish nand dev%d: size %llx, page %d, extra %d, erase %d\n",\r\nid, mtd->size, mtd->writesize,\r\nmtd->oobsize, mtd->erasesize);\r\nmutex_unlock(&nand->lock);\r\nmtd->priv = nand;\r\nname = devm_kzalloc(&pdev->dev, name_len + 1, GFP_KERNEL);\r\nif (!name)\r\nreturn -ENOMEM;\r\nmtd->name = name;\r\nresult = goldfish_nand_cmd(mtd, NAND_CMD_GET_DEV_NAME, 0, name_len,\r\nname);\r\nif (result != name_len) {\r\ndev_err(&pdev->dev,\r\n"goldfish_nand_init_device failed to get dev name %d != %d\n",\r\nresult, name_len);\r\nreturn -ENODEV;\r\n}\r\n((char *)mtd->name)[name_len] = '\0';\r\nmtd->type = MTD_NANDFLASH;\r\nmtd->flags = MTD_CAP_NANDFLASH;\r\nif (flags & NAND_DEV_FLAG_READ_ONLY)\r\nmtd->flags &= ~MTD_WRITEABLE;\r\nif (flags & NAND_DEV_FLAG_CMD_PARAMS_CAP)\r\nnand_setup_cmd_params(pdev, nand);\r\nmtd->owner = THIS_MODULE;\r\nmtd->_erase = goldfish_nand_erase;\r\nmtd->_read = goldfish_nand_read;\r\nmtd->_write = goldfish_nand_write;\r\nmtd->_read_oob = goldfish_nand_read_oob;\r\nmtd->_write_oob = goldfish_nand_write_oob;\r\nmtd->_block_isbad = goldfish_nand_block_isbad;\r\nmtd->_block_markbad = goldfish_nand_block_markbad;\r\nif (mtd_device_register(mtd, NULL, 0))\r\nreturn -EIO;\r\nreturn 0;\r\n}\r\nstatic int goldfish_nand_probe(struct platform_device *pdev)\r\n{\r\nu32 num_dev;\r\nint i;\r\nint err;\r\nu32 num_dev_working;\r\nu32 version;\r\nstruct resource *r;\r\nstruct goldfish_nand *nand;\r\nunsigned char __iomem *base;\r\nr = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nif (!r)\r\nreturn -ENODEV;\r\nbase = devm_ioremap(&pdev->dev, r->start, PAGE_SIZE);\r\nif (!base)\r\nreturn -ENOMEM;\r\nversion = readl(base + NAND_VERSION);\r\nif (version != NAND_VERSION_CURRENT) {\r\ndev_err(&pdev->dev,\r\n"goldfish_nand_init: version mismatch, got %d, expected %d\n",\r\nversion, NAND_VERSION_CURRENT);\r\nreturn -ENODEV;\r\n}\r\nnum_dev = readl(base + NAND_NUM_DEV);\r\nif (num_dev == 0)\r\nreturn -ENODEV;\r\nnand = devm_kzalloc(&pdev->dev, sizeof(*nand) +\r\nsizeof(struct mtd_info) * num_dev, GFP_KERNEL);\r\nif (!nand)\r\nreturn -ENOMEM;\r\nmutex_init(&nand->lock);\r\nnand->base = base;\r\nnand->mtd_count = num_dev;\r\nplatform_set_drvdata(pdev, nand);\r\nnum_dev_working = 0;\r\nfor (i = 0; i < num_dev; i++) {\r\nerr = goldfish_nand_init_device(pdev, nand, i);\r\nif (err == 0)\r\nnum_dev_working++;\r\n}\r\nif (num_dev_working == 0)\r\nreturn -ENODEV;\r\nreturn 0;\r\n}\r\nstatic int goldfish_nand_remove(struct platform_device *pdev)\r\n{\r\nstruct goldfish_nand *nand = platform_get_drvdata(pdev);\r\nint i;\r\nfor (i = 0; i < nand->mtd_count; i++) {\r\nif (nand->mtd[i].name)\r\nmtd_device_unregister(&nand->mtd[i]);\r\n}\r\nreturn 0;\r\n}
