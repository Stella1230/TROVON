static ksock_tx_t *\r\nksocknal_queue_tx_msg_v1(ksock_conn_t *conn, ksock_tx_t *tx_msg)\r\n{\r\nlist_add_tail(&tx_msg->tx_list, &conn->ksnc_tx_queue);\r\nreturn NULL;\r\n}\r\nvoid\r\nksocknal_next_tx_carrier(ksock_conn_t *conn)\r\n{\r\nksock_tx_t *tx = conn->ksnc_tx_carrier;\r\nLASSERT(!list_empty(&conn->ksnc_tx_queue));\r\nLASSERT(tx != NULL);\r\nif (tx->tx_list.next == &conn->ksnc_tx_queue) {\r\nconn->ksnc_tx_carrier = NULL;\r\n} else {\r\nconn->ksnc_tx_carrier = list_entry(tx->tx_list.next,\r\nksock_tx_t, tx_list);\r\nLASSERT(conn->ksnc_tx_carrier->tx_msg.ksm_type == tx->tx_msg.ksm_type);\r\n}\r\n}\r\nstatic int\r\nksocknal_queue_tx_zcack_v2(ksock_conn_t *conn,\r\nksock_tx_t *tx_ack, __u64 cookie)\r\n{\r\nksock_tx_t *tx = conn->ksnc_tx_carrier;\r\nLASSERT(tx_ack == NULL ||\r\ntx_ack->tx_msg.ksm_type == KSOCK_MSG_NOOP);\r\nif (tx == NULL) {\r\nif (tx_ack != NULL) {\r\nlist_add_tail(&tx_ack->tx_list,\r\n&conn->ksnc_tx_queue);\r\nconn->ksnc_tx_carrier = tx_ack;\r\n}\r\nreturn 0;\r\n}\r\nif (tx->tx_msg.ksm_type == KSOCK_MSG_NOOP) {\r\nif (tx_ack != NULL)\r\nlist_add_tail(&tx_ack->tx_list,\r\n&conn->ksnc_tx_queue);\r\nreturn 0;\r\n}\r\nLASSERT(tx->tx_msg.ksm_type == KSOCK_MSG_LNET);\r\nLASSERT(tx->tx_msg.ksm_zc_cookies[1] == 0);\r\nif (tx_ack != NULL)\r\ncookie = tx_ack->tx_msg.ksm_zc_cookies[1];\r\ntx->tx_msg.ksm_zc_cookies[1] = cookie;\r\nksocknal_next_tx_carrier(conn);\r\nreturn 1;\r\n}\r\nstatic ksock_tx_t *\r\nksocknal_queue_tx_msg_v2(ksock_conn_t *conn, ksock_tx_t *tx_msg)\r\n{\r\nksock_tx_t *tx = conn->ksnc_tx_carrier;\r\nif (tx == NULL) {\r\nlist_add_tail(&tx_msg->tx_list, &conn->ksnc_tx_queue);\r\nconn->ksnc_tx_carrier = tx_msg;\r\nreturn NULL;\r\n}\r\nif (tx->tx_msg.ksm_type == KSOCK_MSG_LNET) {\r\nlist_add_tail(&tx_msg->tx_list, &conn->ksnc_tx_queue);\r\nreturn NULL;\r\n}\r\nLASSERT(tx->tx_msg.ksm_type == KSOCK_MSG_NOOP);\r\ntx_msg->tx_msg.ksm_zc_cookies[1] = tx->tx_msg.ksm_zc_cookies[1];\r\nksocknal_next_tx_carrier(conn);\r\nlist_add(&tx_msg->tx_list, &tx->tx_list);\r\nlist_del(&tx->tx_list);\r\nreturn tx;\r\n}\r\nstatic int\r\nksocknal_queue_tx_zcack_v3(ksock_conn_t *conn,\r\nksock_tx_t *tx_ack, __u64 cookie)\r\n{\r\nksock_tx_t *tx;\r\nif (conn->ksnc_type != SOCKLND_CONN_ACK)\r\nreturn ksocknal_queue_tx_zcack_v2(conn, tx_ack, cookie);\r\nLASSERT(tx_ack == NULL ||\r\ntx_ack->tx_msg.ksm_type == KSOCK_MSG_NOOP);\r\ntx = conn->ksnc_tx_carrier;\r\nif (tx == NULL) {\r\nif (tx_ack != NULL) {\r\nlist_add_tail(&tx_ack->tx_list,\r\n&conn->ksnc_tx_queue);\r\nconn->ksnc_tx_carrier = tx_ack;\r\n}\r\nreturn 0;\r\n}\r\nif (tx_ack != NULL)\r\ncookie = tx_ack->tx_msg.ksm_zc_cookies[1];\r\nif (cookie == SOCKNAL_KEEPALIVE_PING)\r\nreturn 1;\r\nif (tx->tx_msg.ksm_zc_cookies[1] == SOCKNAL_KEEPALIVE_PING) {\r\nLASSERT(tx->tx_msg.ksm_zc_cookies[0] == 0);\r\ntx->tx_msg.ksm_zc_cookies[1] = cookie;\r\nreturn 1;\r\n}\r\nif (cookie == tx->tx_msg.ksm_zc_cookies[0] ||\r\ncookie == tx->tx_msg.ksm_zc_cookies[1]) {\r\nCWARN("%s: duplicated ZC cookie: %llu\n",\r\nlibcfs_id2str(conn->ksnc_peer->ksnp_id), cookie);\r\nreturn 1;\r\n}\r\nif (tx->tx_msg.ksm_zc_cookies[0] == 0) {\r\nif (tx->tx_msg.ksm_zc_cookies[1] > cookie) {\r\ntx->tx_msg.ksm_zc_cookies[0] = tx->tx_msg.ksm_zc_cookies[1];\r\ntx->tx_msg.ksm_zc_cookies[1] = cookie;\r\n} else {\r\ntx->tx_msg.ksm_zc_cookies[0] = cookie;\r\n}\r\nif (tx->tx_msg.ksm_zc_cookies[0] - tx->tx_msg.ksm_zc_cookies[1] > 2) {\r\nksocknal_next_tx_carrier(conn);\r\n}\r\nreturn 1;\r\n}\r\nif (tx->tx_msg.ksm_zc_cookies[0] > tx->tx_msg.ksm_zc_cookies[1]) {\r\n__u64 tmp = 0;\r\nLASSERT(tx->tx_msg.ksm_zc_cookies[0] -\r\ntx->tx_msg.ksm_zc_cookies[1] <= 2);\r\nif (tx->tx_msg.ksm_zc_cookies[0] -\r\ntx->tx_msg.ksm_zc_cookies[1] == 2) {\r\nif (cookie == tx->tx_msg.ksm_zc_cookies[1] + 1)\r\ntmp = cookie;\r\n} else if (cookie == tx->tx_msg.ksm_zc_cookies[1] - 1) {\r\ntmp = tx->tx_msg.ksm_zc_cookies[1];\r\n} else if (cookie == tx->tx_msg.ksm_zc_cookies[0] + 1) {\r\ntmp = tx->tx_msg.ksm_zc_cookies[0];\r\n}\r\nif (tmp != 0) {\r\ntx->tx_msg.ksm_zc_cookies[0] = tmp - 1;\r\ntx->tx_msg.ksm_zc_cookies[1] = tmp + 1;\r\nreturn 1;\r\n}\r\n} else {\r\nif (cookie >= tx->tx_msg.ksm_zc_cookies[0] &&\r\ncookie <= tx->tx_msg.ksm_zc_cookies[1]) {\r\nCWARN("%s: duplicated ZC cookie: %llu\n",\r\nlibcfs_id2str(conn->ksnc_peer->ksnp_id), cookie);\r\nreturn 1;\r\n}\r\nif (cookie == tx->tx_msg.ksm_zc_cookies[1] + 1) {\r\ntx->tx_msg.ksm_zc_cookies[1] = cookie;\r\nreturn 1;\r\n}\r\nif (cookie == tx->tx_msg.ksm_zc_cookies[0] - 1) {\r\ntx->tx_msg.ksm_zc_cookies[0] = cookie;\r\nreturn 1;\r\n}\r\n}\r\nif (tx_ack != NULL) {\r\nlist_add_tail(&tx_ack->tx_list, &conn->ksnc_tx_queue);\r\nksocknal_next_tx_carrier(conn);\r\n}\r\nreturn 0;\r\n}\r\nstatic int\r\nksocknal_match_tx(ksock_conn_t *conn, ksock_tx_t *tx, int nonblk)\r\n{\r\nint nob;\r\n#if SOCKNAL_VERSION_DEBUG\r\nif (!*ksocknal_tunables.ksnd_typed_conns)\r\nreturn SOCKNAL_MATCH_YES;\r\n#endif\r\nif (tx == NULL || tx->tx_lnetmsg == NULL) {\r\nnob = offsetof(ksock_msg_t, ksm_u);\r\n} else {\r\nnob = tx->tx_lnetmsg->msg_len +\r\n((conn->ksnc_proto == &ksocknal_protocol_v1x) ?\r\nsizeof(lnet_hdr_t) : sizeof(ksock_msg_t));\r\n}\r\nswitch (conn->ksnc_type) {\r\ndefault:\r\nCERROR("ksnc_type bad: %u\n", conn->ksnc_type);\r\nLBUG();\r\ncase SOCKLND_CONN_ANY:\r\nreturn SOCKNAL_MATCH_YES;\r\ncase SOCKLND_CONN_BULK_IN:\r\nreturn SOCKNAL_MATCH_MAY;\r\ncase SOCKLND_CONN_BULK_OUT:\r\nif (nob < *ksocknal_tunables.ksnd_min_bulk)\r\nreturn SOCKNAL_MATCH_MAY;\r\nelse\r\nreturn SOCKNAL_MATCH_YES;\r\ncase SOCKLND_CONN_CONTROL:\r\nif (nob >= *ksocknal_tunables.ksnd_min_bulk)\r\nreturn SOCKNAL_MATCH_MAY;\r\nelse\r\nreturn SOCKNAL_MATCH_YES;\r\n}\r\n}\r\nstatic int\r\nksocknal_match_tx_v3(ksock_conn_t *conn, ksock_tx_t *tx, int nonblk)\r\n{\r\nint nob;\r\nif (tx == NULL || tx->tx_lnetmsg == NULL)\r\nnob = offsetof(ksock_msg_t, ksm_u);\r\nelse\r\nnob = tx->tx_lnetmsg->msg_len + sizeof(ksock_msg_t);\r\nswitch (conn->ksnc_type) {\r\ndefault:\r\nCERROR("ksnc_type bad: %u\n", conn->ksnc_type);\r\nLBUG();\r\ncase SOCKLND_CONN_ANY:\r\nreturn SOCKNAL_MATCH_NO;\r\ncase SOCKLND_CONN_ACK:\r\nif (nonblk)\r\nreturn SOCKNAL_MATCH_YES;\r\nelse if (tx == NULL || tx->tx_lnetmsg == NULL)\r\nreturn SOCKNAL_MATCH_MAY;\r\nelse\r\nreturn SOCKNAL_MATCH_NO;\r\ncase SOCKLND_CONN_BULK_OUT:\r\nif (nonblk)\r\nreturn SOCKNAL_MATCH_NO;\r\nelse if (nob < *ksocknal_tunables.ksnd_min_bulk)\r\nreturn SOCKNAL_MATCH_MAY;\r\nelse\r\nreturn SOCKNAL_MATCH_YES;\r\ncase SOCKLND_CONN_CONTROL:\r\nif (nonblk)\r\nreturn SOCKNAL_MATCH_NO;\r\nelse if (nob >= *ksocknal_tunables.ksnd_min_bulk)\r\nreturn SOCKNAL_MATCH_MAY;\r\nelse\r\nreturn SOCKNAL_MATCH_YES;\r\n}\r\n}\r\nstatic int\r\nksocknal_handle_zcreq(ksock_conn_t *c, __u64 cookie, int remote)\r\n{\r\nksock_peer_t *peer = c->ksnc_peer;\r\nksock_conn_t *conn;\r\nksock_tx_t *tx;\r\nint rc;\r\nread_lock(&ksocknal_data.ksnd_global_lock);\r\nconn = ksocknal_find_conn_locked(peer, NULL, !!remote);\r\nif (conn != NULL) {\r\nksock_sched_t *sched = conn->ksnc_scheduler;\r\nLASSERT(conn->ksnc_proto->pro_queue_tx_zcack != NULL);\r\nspin_lock_bh(&sched->kss_lock);\r\nrc = conn->ksnc_proto->pro_queue_tx_zcack(conn, NULL, cookie);\r\nspin_unlock_bh(&sched->kss_lock);\r\nif (rc) {\r\nread_unlock(&ksocknal_data.ksnd_global_lock);\r\nreturn 0;\r\n}\r\n}\r\nread_unlock(&ksocknal_data.ksnd_global_lock);\r\ntx = ksocknal_alloc_tx_noop(cookie, !!remote);\r\nif (tx == NULL)\r\nreturn -ENOMEM;\r\nrc = ksocknal_launch_packet(peer->ksnp_ni, tx, peer->ksnp_id);\r\nif (rc == 0)\r\nreturn 0;\r\nksocknal_free_tx(tx);\r\nreturn rc;\r\n}\r\nstatic int\r\nksocknal_handle_zcack(ksock_conn_t *conn, __u64 cookie1, __u64 cookie2)\r\n{\r\nksock_peer_t *peer = conn->ksnc_peer;\r\nksock_tx_t *tx;\r\nksock_tx_t *tmp;\r\nLIST_HEAD(zlist);\r\nint count;\r\nif (cookie1 == 0)\r\ncookie1 = cookie2;\r\ncount = (cookie1 > cookie2) ? 2 : (cookie2 - cookie1 + 1);\r\nif (cookie2 == SOCKNAL_KEEPALIVE_PING &&\r\nconn->ksnc_proto == &ksocknal_protocol_v3x) {\r\nreturn count == 1 ? 0 : -EPROTO;\r\n}\r\nspin_lock(&peer->ksnp_lock);\r\nlist_for_each_entry_safe(tx, tmp,\r\n&peer->ksnp_zc_req_list, tx_zc_list) {\r\n__u64 c = tx->tx_msg.ksm_zc_cookies[0];\r\nif (c == cookie1 || c == cookie2 || (cookie1 < c && c < cookie2)) {\r\ntx->tx_msg.ksm_zc_cookies[0] = 0;\r\nlist_del(&tx->tx_zc_list);\r\nlist_add(&tx->tx_zc_list, &zlist);\r\nif (--count == 0)\r\nbreak;\r\n}\r\n}\r\nspin_unlock(&peer->ksnp_lock);\r\nwhile (!list_empty(&zlist)) {\r\ntx = list_entry(zlist.next, ksock_tx_t, tx_zc_list);\r\nlist_del(&tx->tx_zc_list);\r\nksocknal_tx_decref(tx);\r\n}\r\nreturn count == 0 ? 0 : -EPROTO;\r\n}\r\nstatic int\r\nksocknal_send_hello_v1(ksock_conn_t *conn, ksock_hello_msg_t *hello)\r\n{\r\nstruct socket *sock = conn->ksnc_sock;\r\nlnet_hdr_t *hdr;\r\nlnet_magicversion_t *hmv;\r\nint rc;\r\nint i;\r\nCLASSERT(sizeof(lnet_magicversion_t) == offsetof(lnet_hdr_t, src_nid));\r\nLIBCFS_ALLOC(hdr, sizeof(*hdr));\r\nif (hdr == NULL) {\r\nCERROR("Can't allocate lnet_hdr_t\n");\r\nreturn -ENOMEM;\r\n}\r\nhmv = (lnet_magicversion_t *)&hdr->dest_nid;\r\nhmv->magic = cpu_to_le32 (LNET_PROTO_TCP_MAGIC);\r\nhmv->version_major = cpu_to_le16 (KSOCK_PROTO_V1_MAJOR);\r\nhmv->version_minor = cpu_to_le16 (KSOCK_PROTO_V1_MINOR);\r\nif (the_lnet.ln_testprotocompat != 0) {\r\nLNET_LOCK();\r\nif ((the_lnet.ln_testprotocompat & 1) != 0) {\r\nhmv->version_major++;\r\nthe_lnet.ln_testprotocompat &= ~1;\r\n}\r\nif ((the_lnet.ln_testprotocompat & 2) != 0) {\r\nhmv->magic = LNET_PROTO_MAGIC;\r\nthe_lnet.ln_testprotocompat &= ~2;\r\n}\r\nLNET_UNLOCK();\r\n}\r\nhdr->src_nid = cpu_to_le64 (hello->kshm_src_nid);\r\nhdr->src_pid = cpu_to_le32 (hello->kshm_src_pid);\r\nhdr->type = cpu_to_le32 (LNET_MSG_HELLO);\r\nhdr->payload_length = cpu_to_le32 (hello->kshm_nips * sizeof(__u32));\r\nhdr->msg.hello.type = cpu_to_le32 (hello->kshm_ctype);\r\nhdr->msg.hello.incarnation = cpu_to_le64 (hello->kshm_src_incarnation);\r\nrc = lnet_sock_write(sock, hdr, sizeof(*hdr), lnet_acceptor_timeout());\r\nif (rc != 0) {\r\nCNETERR("Error %d sending HELLO hdr to %pI4h/%d\n",\r\nrc, &conn->ksnc_ipaddr, conn->ksnc_port);\r\ngoto out;\r\n}\r\nif (hello->kshm_nips == 0)\r\ngoto out;\r\nfor (i = 0; i < (int) hello->kshm_nips; i++) {\r\nhello->kshm_ips[i] = __cpu_to_le32 (hello->kshm_ips[i]);\r\n}\r\nrc = lnet_sock_write(sock, hello->kshm_ips,\r\nhello->kshm_nips * sizeof(__u32),\r\nlnet_acceptor_timeout());\r\nif (rc != 0) {\r\nCNETERR("Error %d sending HELLO payload (%d) to %pI4h/%d\n",\r\nrc, hello->kshm_nips,\r\n&conn->ksnc_ipaddr, conn->ksnc_port);\r\n}\r\nout:\r\nLIBCFS_FREE(hdr, sizeof(*hdr));\r\nreturn rc;\r\n}\r\nstatic int\r\nksocknal_send_hello_v2(ksock_conn_t *conn, ksock_hello_msg_t *hello)\r\n{\r\nstruct socket *sock = conn->ksnc_sock;\r\nint rc;\r\nhello->kshm_magic = LNET_PROTO_MAGIC;\r\nhello->kshm_version = conn->ksnc_proto->pro_version;\r\nif (the_lnet.ln_testprotocompat != 0) {\r\nLNET_LOCK();\r\nif ((the_lnet.ln_testprotocompat & 1) != 0) {\r\nhello->kshm_version++;\r\nthe_lnet.ln_testprotocompat &= ~1;\r\n}\r\nLNET_UNLOCK();\r\n}\r\nrc = lnet_sock_write(sock, hello, offsetof(ksock_hello_msg_t, kshm_ips),\r\nlnet_acceptor_timeout());\r\nif (rc != 0) {\r\nCNETERR("Error %d sending HELLO hdr to %pI4h/%d\n",\r\nrc, &conn->ksnc_ipaddr, conn->ksnc_port);\r\nreturn rc;\r\n}\r\nif (hello->kshm_nips == 0)\r\nreturn 0;\r\nrc = lnet_sock_write(sock, hello->kshm_ips,\r\nhello->kshm_nips * sizeof(__u32),\r\nlnet_acceptor_timeout());\r\nif (rc != 0) {\r\nCNETERR("Error %d sending HELLO payload (%d) to %pI4h/%d\n",\r\nrc, hello->kshm_nips,\r\n&conn->ksnc_ipaddr, conn->ksnc_port);\r\n}\r\nreturn rc;\r\n}\r\nstatic int\r\nksocknal_recv_hello_v1(ksock_conn_t *conn, ksock_hello_msg_t *hello,\r\nint timeout)\r\n{\r\nstruct socket *sock = conn->ksnc_sock;\r\nlnet_hdr_t *hdr;\r\nint rc;\r\nint i;\r\nLIBCFS_ALLOC(hdr, sizeof(*hdr));\r\nif (hdr == NULL) {\r\nCERROR("Can't allocate lnet_hdr_t\n");\r\nreturn -ENOMEM;\r\n}\r\nrc = lnet_sock_read(sock, &hdr->src_nid,\r\nsizeof(*hdr) - offsetof(lnet_hdr_t, src_nid),\r\ntimeout);\r\nif (rc != 0) {\r\nCERROR("Error %d reading rest of HELLO hdr from %pI4h\n",\r\nrc, &conn->ksnc_ipaddr);\r\nLASSERT(rc < 0 && rc != -EALREADY);\r\ngoto out;\r\n}\r\nif (hdr->type != cpu_to_le32 (LNET_MSG_HELLO)) {\r\nCERROR("Expecting a HELLO hdr, but got type %d from %pI4h\n",\r\nle32_to_cpu(hdr->type),\r\n&conn->ksnc_ipaddr);\r\nrc = -EPROTO;\r\ngoto out;\r\n}\r\nhello->kshm_src_nid = le64_to_cpu(hdr->src_nid);\r\nhello->kshm_src_pid = le32_to_cpu(hdr->src_pid);\r\nhello->kshm_src_incarnation = le64_to_cpu(hdr->msg.hello.incarnation);\r\nhello->kshm_ctype = le32_to_cpu(hdr->msg.hello.type);\r\nhello->kshm_nips = le32_to_cpu(hdr->payload_length) /\r\nsizeof(__u32);\r\nif (hello->kshm_nips > LNET_MAX_INTERFACES) {\r\nCERROR("Bad nips %d from ip %pI4h\n",\r\nhello->kshm_nips, &conn->ksnc_ipaddr);\r\nrc = -EPROTO;\r\ngoto out;\r\n}\r\nif (hello->kshm_nips == 0)\r\ngoto out;\r\nrc = lnet_sock_read(sock, hello->kshm_ips,\r\nhello->kshm_nips * sizeof(__u32), timeout);\r\nif (rc != 0) {\r\nCERROR("Error %d reading IPs from ip %pI4h\n",\r\nrc, &conn->ksnc_ipaddr);\r\nLASSERT(rc < 0 && rc != -EALREADY);\r\ngoto out;\r\n}\r\nfor (i = 0; i < (int) hello->kshm_nips; i++) {\r\nhello->kshm_ips[i] = __le32_to_cpu(hello->kshm_ips[i]);\r\nif (hello->kshm_ips[i] == 0) {\r\nCERROR("Zero IP[%d] from ip %pI4h\n",\r\ni, &conn->ksnc_ipaddr);\r\nrc = -EPROTO;\r\nbreak;\r\n}\r\n}\r\nout:\r\nLIBCFS_FREE(hdr, sizeof(*hdr));\r\nreturn rc;\r\n}\r\nstatic int\r\nksocknal_recv_hello_v2(ksock_conn_t *conn, ksock_hello_msg_t *hello, int timeout)\r\n{\r\nstruct socket *sock = conn->ksnc_sock;\r\nint rc;\r\nint i;\r\nif (hello->kshm_magic == LNET_PROTO_MAGIC)\r\nconn->ksnc_flip = 0;\r\nelse\r\nconn->ksnc_flip = 1;\r\nrc = lnet_sock_read(sock, &hello->kshm_src_nid,\r\noffsetof(ksock_hello_msg_t, kshm_ips) -\r\noffsetof(ksock_hello_msg_t, kshm_src_nid),\r\ntimeout);\r\nif (rc != 0) {\r\nCERROR("Error %d reading HELLO from %pI4h\n",\r\nrc, &conn->ksnc_ipaddr);\r\nLASSERT(rc < 0 && rc != -EALREADY);\r\nreturn rc;\r\n}\r\nif (conn->ksnc_flip) {\r\n__swab32s(&hello->kshm_src_pid);\r\n__swab64s(&hello->kshm_src_nid);\r\n__swab32s(&hello->kshm_dst_pid);\r\n__swab64s(&hello->kshm_dst_nid);\r\n__swab64s(&hello->kshm_src_incarnation);\r\n__swab64s(&hello->kshm_dst_incarnation);\r\n__swab32s(&hello->kshm_ctype);\r\n__swab32s(&hello->kshm_nips);\r\n}\r\nif (hello->kshm_nips > LNET_MAX_INTERFACES) {\r\nCERROR("Bad nips %d from ip %pI4h\n",\r\nhello->kshm_nips, &conn->ksnc_ipaddr);\r\nreturn -EPROTO;\r\n}\r\nif (hello->kshm_nips == 0)\r\nreturn 0;\r\nrc = lnet_sock_read(sock, hello->kshm_ips,\r\nhello->kshm_nips * sizeof(__u32), timeout);\r\nif (rc != 0) {\r\nCERROR("Error %d reading IPs from ip %pI4h\n",\r\nrc, &conn->ksnc_ipaddr);\r\nLASSERT(rc < 0 && rc != -EALREADY);\r\nreturn rc;\r\n}\r\nfor (i = 0; i < (int) hello->kshm_nips; i++) {\r\nif (conn->ksnc_flip)\r\n__swab32s(&hello->kshm_ips[i]);\r\nif (hello->kshm_ips[i] == 0) {\r\nCERROR("Zero IP[%d] from ip %pI4h\n",\r\ni, &conn->ksnc_ipaddr);\r\nreturn -EPROTO;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic void\r\nksocknal_pack_msg_v1(ksock_tx_t *tx)\r\n{\r\nLASSERT(tx->tx_msg.ksm_type != KSOCK_MSG_NOOP);\r\nLASSERT(tx->tx_lnetmsg != NULL);\r\ntx->tx_iov[0].iov_base = &tx->tx_lnetmsg->msg_hdr;\r\ntx->tx_iov[0].iov_len = sizeof(lnet_hdr_t);\r\ntx->tx_resid = tx->tx_nob = tx->tx_lnetmsg->msg_len + sizeof(lnet_hdr_t);\r\n}\r\nstatic void\r\nksocknal_pack_msg_v2(ksock_tx_t *tx)\r\n{\r\ntx->tx_iov[0].iov_base = &tx->tx_msg;\r\nif (tx->tx_lnetmsg != NULL) {\r\nLASSERT(tx->tx_msg.ksm_type != KSOCK_MSG_NOOP);\r\ntx->tx_msg.ksm_u.lnetmsg.ksnm_hdr = tx->tx_lnetmsg->msg_hdr;\r\ntx->tx_iov[0].iov_len = sizeof(ksock_msg_t);\r\ntx->tx_resid = tx->tx_nob = sizeof(ksock_msg_t) + tx->tx_lnetmsg->msg_len;\r\n} else {\r\nLASSERT(tx->tx_msg.ksm_type == KSOCK_MSG_NOOP);\r\ntx->tx_iov[0].iov_len = offsetof(ksock_msg_t, ksm_u.lnetmsg.ksnm_hdr);\r\ntx->tx_resid = tx->tx_nob = offsetof(ksock_msg_t, ksm_u.lnetmsg.ksnm_hdr);\r\n}\r\n}\r\nstatic void\r\nksocknal_unpack_msg_v1(ksock_msg_t *msg)\r\n{\r\nmsg->ksm_csum = 0;\r\nmsg->ksm_type = KSOCK_MSG_LNET;\r\nmsg->ksm_zc_cookies[0] = msg->ksm_zc_cookies[1] = 0;\r\n}\r\nstatic void\r\nksocknal_unpack_msg_v2(ksock_msg_t *msg)\r\n{\r\nreturn;\r\n}
