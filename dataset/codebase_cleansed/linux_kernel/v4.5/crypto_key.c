static void derive_crypt_complete(struct crypto_async_request *req, int rc)\r\n{\r\nstruct f2fs_completion_result *ecr = req->data;\r\nif (rc == -EINPROGRESS)\r\nreturn;\r\necr->res = rc;\r\ncomplete(&ecr->completion);\r\n}\r\nstatic int f2fs_derive_key_aes(char deriving_key[F2FS_AES_128_ECB_KEY_SIZE],\r\nchar source_key[F2FS_AES_256_XTS_KEY_SIZE],\r\nchar derived_key[F2FS_AES_256_XTS_KEY_SIZE])\r\n{\r\nint res = 0;\r\nstruct ablkcipher_request *req = NULL;\r\nDECLARE_F2FS_COMPLETION_RESULT(ecr);\r\nstruct scatterlist src_sg, dst_sg;\r\nstruct crypto_ablkcipher *tfm = crypto_alloc_ablkcipher("ecb(aes)", 0,\r\n0);\r\nif (IS_ERR(tfm)) {\r\nres = PTR_ERR(tfm);\r\ntfm = NULL;\r\ngoto out;\r\n}\r\ncrypto_ablkcipher_set_flags(tfm, CRYPTO_TFM_REQ_WEAK_KEY);\r\nreq = ablkcipher_request_alloc(tfm, GFP_NOFS);\r\nif (!req) {\r\nres = -ENOMEM;\r\ngoto out;\r\n}\r\nablkcipher_request_set_callback(req,\r\nCRYPTO_TFM_REQ_MAY_BACKLOG | CRYPTO_TFM_REQ_MAY_SLEEP,\r\nderive_crypt_complete, &ecr);\r\nres = crypto_ablkcipher_setkey(tfm, deriving_key,\r\nF2FS_AES_128_ECB_KEY_SIZE);\r\nif (res < 0)\r\ngoto out;\r\nsg_init_one(&src_sg, source_key, F2FS_AES_256_XTS_KEY_SIZE);\r\nsg_init_one(&dst_sg, derived_key, F2FS_AES_256_XTS_KEY_SIZE);\r\nablkcipher_request_set_crypt(req, &src_sg, &dst_sg,\r\nF2FS_AES_256_XTS_KEY_SIZE, NULL);\r\nres = crypto_ablkcipher_encrypt(req);\r\nif (res == -EINPROGRESS || res == -EBUSY) {\r\nBUG_ON(req->base.data != &ecr);\r\nwait_for_completion(&ecr.completion);\r\nres = ecr.res;\r\n}\r\nout:\r\nif (req)\r\nablkcipher_request_free(req);\r\nif (tfm)\r\ncrypto_free_ablkcipher(tfm);\r\nreturn res;\r\n}\r\nstatic void f2fs_free_crypt_info(struct f2fs_crypt_info *ci)\r\n{\r\nif (!ci)\r\nreturn;\r\nkey_put(ci->ci_keyring_key);\r\ncrypto_free_ablkcipher(ci->ci_ctfm);\r\nkmem_cache_free(f2fs_crypt_info_cachep, ci);\r\n}\r\nvoid f2fs_free_encryption_info(struct inode *inode, struct f2fs_crypt_info *ci)\r\n{\r\nstruct f2fs_inode_info *fi = F2FS_I(inode);\r\nstruct f2fs_crypt_info *prev;\r\nif (ci == NULL)\r\nci = ACCESS_ONCE(fi->i_crypt_info);\r\nif (ci == NULL)\r\nreturn;\r\nprev = cmpxchg(&fi->i_crypt_info, ci, NULL);\r\nif (prev != ci)\r\nreturn;\r\nf2fs_free_crypt_info(ci);\r\n}\r\nint _f2fs_get_encryption_info(struct inode *inode)\r\n{\r\nstruct f2fs_inode_info *fi = F2FS_I(inode);\r\nstruct f2fs_crypt_info *crypt_info;\r\nchar full_key_descriptor[F2FS_KEY_DESC_PREFIX_SIZE +\r\n(F2FS_KEY_DESCRIPTOR_SIZE * 2) + 1];\r\nstruct key *keyring_key = NULL;\r\nstruct f2fs_encryption_key *master_key;\r\nstruct f2fs_encryption_context ctx;\r\nconst struct user_key_payload *ukp;\r\nstruct crypto_ablkcipher *ctfm;\r\nconst char *cipher_str;\r\nchar raw_key[F2FS_MAX_KEY_SIZE];\r\nchar mode;\r\nint res;\r\nres = f2fs_crypto_initialize();\r\nif (res)\r\nreturn res;\r\nretry:\r\ncrypt_info = ACCESS_ONCE(fi->i_crypt_info);\r\nif (crypt_info) {\r\nif (!crypt_info->ci_keyring_key ||\r\nkey_validate(crypt_info->ci_keyring_key) == 0)\r\nreturn 0;\r\nf2fs_free_encryption_info(inode, crypt_info);\r\ngoto retry;\r\n}\r\nres = f2fs_getxattr(inode, F2FS_XATTR_INDEX_ENCRYPTION,\r\nF2FS_XATTR_NAME_ENCRYPTION_CONTEXT,\r\n&ctx, sizeof(ctx), NULL);\r\nif (res < 0)\r\nreturn res;\r\nelse if (res != sizeof(ctx))\r\nreturn -EINVAL;\r\nres = 0;\r\ncrypt_info = kmem_cache_alloc(f2fs_crypt_info_cachep, GFP_NOFS);\r\nif (!crypt_info)\r\nreturn -ENOMEM;\r\ncrypt_info->ci_flags = ctx.flags;\r\ncrypt_info->ci_data_mode = ctx.contents_encryption_mode;\r\ncrypt_info->ci_filename_mode = ctx.filenames_encryption_mode;\r\ncrypt_info->ci_ctfm = NULL;\r\ncrypt_info->ci_keyring_key = NULL;\r\nmemcpy(crypt_info->ci_master_key, ctx.master_key_descriptor,\r\nsizeof(crypt_info->ci_master_key));\r\nif (S_ISREG(inode->i_mode))\r\nmode = crypt_info->ci_data_mode;\r\nelse if (S_ISDIR(inode->i_mode) || S_ISLNK(inode->i_mode))\r\nmode = crypt_info->ci_filename_mode;\r\nelse\r\nBUG();\r\nswitch (mode) {\r\ncase F2FS_ENCRYPTION_MODE_AES_256_XTS:\r\ncipher_str = "xts(aes)";\r\nbreak;\r\ncase F2FS_ENCRYPTION_MODE_AES_256_CTS:\r\ncipher_str = "cts(cbc(aes))";\r\nbreak;\r\ndefault:\r\nprintk_once(KERN_WARNING\r\n"f2fs: unsupported key mode %d (ino %u)\n",\r\nmode, (unsigned) inode->i_ino);\r\nres = -ENOKEY;\r\ngoto out;\r\n}\r\nmemcpy(full_key_descriptor, F2FS_KEY_DESC_PREFIX,\r\nF2FS_KEY_DESC_PREFIX_SIZE);\r\nsprintf(full_key_descriptor + F2FS_KEY_DESC_PREFIX_SIZE,\r\n"%*phN", F2FS_KEY_DESCRIPTOR_SIZE,\r\nctx.master_key_descriptor);\r\nfull_key_descriptor[F2FS_KEY_DESC_PREFIX_SIZE +\r\n(2 * F2FS_KEY_DESCRIPTOR_SIZE)] = '\0';\r\nkeyring_key = request_key(&key_type_logon, full_key_descriptor, NULL);\r\nif (IS_ERR(keyring_key)) {\r\nres = PTR_ERR(keyring_key);\r\nkeyring_key = NULL;\r\ngoto out;\r\n}\r\ncrypt_info->ci_keyring_key = keyring_key;\r\nBUG_ON(keyring_key->type != &key_type_logon);\r\nukp = user_key_payload(keyring_key);\r\nif (ukp->datalen != sizeof(struct f2fs_encryption_key)) {\r\nres = -EINVAL;\r\ngoto out;\r\n}\r\nmaster_key = (struct f2fs_encryption_key *)ukp->data;\r\nBUILD_BUG_ON(F2FS_AES_128_ECB_KEY_SIZE !=\r\nF2FS_KEY_DERIVATION_NONCE_SIZE);\r\nBUG_ON(master_key->size != F2FS_AES_256_XTS_KEY_SIZE);\r\nres = f2fs_derive_key_aes(ctx.nonce, master_key->raw,\r\nraw_key);\r\nif (res)\r\ngoto out;\r\nctfm = crypto_alloc_ablkcipher(cipher_str, 0, 0);\r\nif (!ctfm || IS_ERR(ctfm)) {\r\nres = ctfm ? PTR_ERR(ctfm) : -ENOMEM;\r\nprintk(KERN_DEBUG\r\n"%s: error %d (inode %u) allocating crypto tfm\n",\r\n__func__, res, (unsigned) inode->i_ino);\r\ngoto out;\r\n}\r\ncrypt_info->ci_ctfm = ctfm;\r\ncrypto_ablkcipher_clear_flags(ctfm, ~0);\r\ncrypto_tfm_set_flags(crypto_ablkcipher_tfm(ctfm),\r\nCRYPTO_TFM_REQ_WEAK_KEY);\r\nres = crypto_ablkcipher_setkey(ctfm, raw_key,\r\nf2fs_encryption_key_size(mode));\r\nif (res)\r\ngoto out;\r\nmemzero_explicit(raw_key, sizeof(raw_key));\r\nif (cmpxchg(&fi->i_crypt_info, NULL, crypt_info) != NULL) {\r\nf2fs_free_crypt_info(crypt_info);\r\ngoto retry;\r\n}\r\nreturn 0;\r\nout:\r\nif (res == -ENOKEY && !S_ISREG(inode->i_mode))\r\nres = 0;\r\nf2fs_free_crypt_info(crypt_info);\r\nmemzero_explicit(raw_key, sizeof(raw_key));\r\nreturn res;\r\n}\r\nint f2fs_has_encryption_key(struct inode *inode)\r\n{\r\nstruct f2fs_inode_info *fi = F2FS_I(inode);\r\nreturn (fi->i_crypt_info != NULL);\r\n}
