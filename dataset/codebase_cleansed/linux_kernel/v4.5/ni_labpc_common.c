static unsigned int labpc_inb(struct comedi_device *dev, unsigned long reg)\r\n{\r\nreturn inb(dev->iobase + reg);\r\n}\r\nstatic void labpc_outb(struct comedi_device *dev,\r\nunsigned int byte, unsigned long reg)\r\n{\r\noutb(byte, dev->iobase + reg);\r\n}\r\nstatic unsigned int labpc_readb(struct comedi_device *dev, unsigned long reg)\r\n{\r\nreturn readb(dev->mmio + reg);\r\n}\r\nstatic void labpc_writeb(struct comedi_device *dev,\r\nunsigned int byte, unsigned long reg)\r\n{\r\nwriteb(byte, dev->mmio + reg);\r\n}\r\nstatic int labpc_cancel(struct comedi_device *dev, struct comedi_subdevice *s)\r\n{\r\nstruct labpc_private *devpriv = dev->private;\r\nunsigned long flags;\r\nspin_lock_irqsave(&dev->spinlock, flags);\r\ndevpriv->cmd2 &= ~(CMD2_SWTRIG | CMD2_HWTRIG | CMD2_PRETRIG);\r\ndevpriv->write_byte(dev, devpriv->cmd2, CMD2_REG);\r\nspin_unlock_irqrestore(&dev->spinlock, flags);\r\ndevpriv->cmd3 = 0;\r\ndevpriv->write_byte(dev, devpriv->cmd3, CMD3_REG);\r\nreturn 0;\r\n}\r\nstatic void labpc_ai_set_chan_and_gain(struct comedi_device *dev,\r\nenum scan_mode mode,\r\nunsigned int chan,\r\nunsigned int range,\r\nunsigned int aref)\r\n{\r\nconst struct labpc_boardinfo *board = dev->board_ptr;\r\nstruct labpc_private *devpriv = dev->private;\r\nif (board->is_labpc1200) {\r\nrange += (range > 0) + (range > 7);\r\n}\r\nif ((mode == MODE_SINGLE_CHAN || mode == MODE_SINGLE_CHAN_INTERVAL) &&\r\naref == AREF_DIFF)\r\nchan *= 2;\r\ndevpriv->cmd1 = CMD1_MA(chan);\r\ndevpriv->cmd1 |= CMD1_GAIN(range);\r\ndevpriv->write_byte(dev, devpriv->cmd1, CMD1_REG);\r\n}\r\nstatic void labpc_setup_cmd6_reg(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nenum scan_mode mode,\r\nenum transfer_type xfer,\r\nunsigned int range,\r\nunsigned int aref,\r\nbool ena_intr)\r\n{\r\nconst struct labpc_boardinfo *board = dev->board_ptr;\r\nstruct labpc_private *devpriv = dev->private;\r\nif (!board->is_labpc1200)\r\nreturn;\r\nif (aref != AREF_GROUND)\r\ndevpriv->cmd6 |= CMD6_NRSE;\r\nelse\r\ndevpriv->cmd6 &= ~CMD6_NRSE;\r\nif (comedi_range_is_unipolar(s, range))\r\ndevpriv->cmd6 |= CMD6_ADCUNI;\r\nelse\r\ndevpriv->cmd6 &= ~CMD6_ADCUNI;\r\nif (xfer == fifo_half_full_transfer)\r\ndevpriv->cmd6 |= CMD6_HFINTEN;\r\nelse\r\ndevpriv->cmd6 &= ~CMD6_HFINTEN;\r\nif (ena_intr)\r\ndevpriv->cmd6 |= CMD6_DQINTEN;\r\nelse\r\ndevpriv->cmd6 &= ~CMD6_DQINTEN;\r\nif (mode == MODE_MULT_CHAN_UP)\r\ndevpriv->cmd6 |= CMD6_SCANUP;\r\nelse\r\ndevpriv->cmd6 &= ~CMD6_SCANUP;\r\ndevpriv->write_byte(dev, devpriv->cmd6, CMD6_REG);\r\n}\r\nstatic unsigned int labpc_read_adc_fifo(struct comedi_device *dev)\r\n{\r\nstruct labpc_private *devpriv = dev->private;\r\nunsigned int lsb = devpriv->read_byte(dev, ADC_FIFO_REG);\r\nunsigned int msb = devpriv->read_byte(dev, ADC_FIFO_REG);\r\nreturn (msb << 8) | lsb;\r\n}\r\nstatic void labpc_clear_adc_fifo(struct comedi_device *dev)\r\n{\r\nstruct labpc_private *devpriv = dev->private;\r\ndevpriv->write_byte(dev, 0x1, ADC_FIFO_CLEAR_REG);\r\nlabpc_read_adc_fifo(dev);\r\n}\r\nstatic int labpc_ai_eoc(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_insn *insn,\r\nunsigned long context)\r\n{\r\nstruct labpc_private *devpriv = dev->private;\r\ndevpriv->stat1 = devpriv->read_byte(dev, STAT1_REG);\r\nif (devpriv->stat1 & STAT1_DAVAIL)\r\nreturn 0;\r\nreturn -EBUSY;\r\n}\r\nstatic int labpc_ai_insn_read(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_insn *insn,\r\nunsigned int *data)\r\n{\r\nstruct labpc_private *devpriv = dev->private;\r\nunsigned int chan = CR_CHAN(insn->chanspec);\r\nunsigned int range = CR_RANGE(insn->chanspec);\r\nunsigned int aref = CR_AREF(insn->chanspec);\r\nint ret;\r\nint i;\r\nlabpc_cancel(dev, s);\r\nlabpc_ai_set_chan_and_gain(dev, MODE_SINGLE_CHAN, chan, range, aref);\r\nlabpc_setup_cmd6_reg(dev, s, MODE_SINGLE_CHAN, fifo_not_empty_transfer,\r\nrange, aref, false);\r\ndevpriv->cmd4 = 0;\r\ndevpriv->cmd4 |= CMD4_ECLKRCV;\r\nif (aref == AREF_DIFF)\r\ndevpriv->cmd4 |= CMD4_SEDIFF;\r\ndevpriv->write_byte(dev, devpriv->cmd4, CMD4_REG);\r\ncomedi_8254_set_mode(devpriv->counter, 0, I8254_MODE2 | I8254_BINARY);\r\nlabpc_clear_adc_fifo(dev);\r\nfor (i = 0; i < insn->n; i++) {\r\ndevpriv->write_byte(dev, 0x1, ADC_START_CONVERT_REG);\r\nret = comedi_timeout(dev, s, insn, labpc_ai_eoc, 0);\r\nif (ret)\r\nreturn ret;\r\ndata[i] = labpc_read_adc_fifo(dev);\r\n}\r\nreturn insn->n;\r\n}\r\nstatic bool labpc_use_continuous_mode(const struct comedi_cmd *cmd,\r\nenum scan_mode mode)\r\n{\r\nif (mode == MODE_SINGLE_CHAN || cmd->scan_begin_src == TRIG_FOLLOW)\r\nreturn true;\r\nreturn false;\r\n}\r\nstatic unsigned int labpc_ai_convert_period(const struct comedi_cmd *cmd,\r\nenum scan_mode mode)\r\n{\r\nif (cmd->convert_src != TRIG_TIMER)\r\nreturn 0;\r\nif (mode == MODE_SINGLE_CHAN && cmd->scan_begin_src == TRIG_TIMER)\r\nreturn cmd->scan_begin_arg;\r\nreturn cmd->convert_arg;\r\n}\r\nstatic void labpc_set_ai_convert_period(struct comedi_cmd *cmd,\r\nenum scan_mode mode, unsigned int ns)\r\n{\r\nif (cmd->convert_src != TRIG_TIMER)\r\nreturn;\r\nif (mode == MODE_SINGLE_CHAN &&\r\ncmd->scan_begin_src == TRIG_TIMER) {\r\ncmd->scan_begin_arg = ns;\r\nif (cmd->convert_arg > cmd->scan_begin_arg)\r\ncmd->convert_arg = cmd->scan_begin_arg;\r\n} else {\r\ncmd->convert_arg = ns;\r\n}\r\n}\r\nstatic unsigned int labpc_ai_scan_period(const struct comedi_cmd *cmd,\r\nenum scan_mode mode)\r\n{\r\nif (cmd->scan_begin_src != TRIG_TIMER)\r\nreturn 0;\r\nif (mode == MODE_SINGLE_CHAN && cmd->convert_src == TRIG_TIMER)\r\nreturn 0;\r\nreturn cmd->scan_begin_arg;\r\n}\r\nstatic void labpc_set_ai_scan_period(struct comedi_cmd *cmd,\r\nenum scan_mode mode, unsigned int ns)\r\n{\r\nif (cmd->scan_begin_src != TRIG_TIMER)\r\nreturn;\r\nif (mode == MODE_SINGLE_CHAN && cmd->convert_src == TRIG_TIMER)\r\nreturn;\r\ncmd->scan_begin_arg = ns;\r\n}\r\nstatic void labpc_adc_timing(struct comedi_device *dev, struct comedi_cmd *cmd,\r\nenum scan_mode mode)\r\n{\r\nstruct comedi_8254 *pacer = dev->pacer;\r\nunsigned int convert_period = labpc_ai_convert_period(cmd, mode);\r\nunsigned int scan_period = labpc_ai_scan_period(cmd, mode);\r\nunsigned int base_period;\r\nif (convert_period && scan_period) {\r\npacer->next_div1 = (scan_period - 1) /\r\n(pacer->osc_base * I8254_MAX_COUNT) + 1;\r\ncomedi_check_trigger_arg_min(&pacer->next_div1, 2);\r\ncomedi_check_trigger_arg_max(&pacer->next_div1,\r\nI8254_MAX_COUNT);\r\nbase_period = pacer->osc_base * pacer->next_div1;\r\nswitch (cmd->flags & CMDF_ROUND_MASK) {\r\ndefault:\r\ncase CMDF_ROUND_NEAREST:\r\npacer->next_div = DIV_ROUND_CLOSEST(convert_period,\r\nbase_period);\r\npacer->next_div2 = DIV_ROUND_CLOSEST(scan_period,\r\nbase_period);\r\nbreak;\r\ncase CMDF_ROUND_UP:\r\npacer->next_div = DIV_ROUND_UP(convert_period,\r\nbase_period);\r\npacer->next_div2 = DIV_ROUND_UP(scan_period,\r\nbase_period);\r\nbreak;\r\ncase CMDF_ROUND_DOWN:\r\npacer->next_div = convert_period / base_period;\r\npacer->next_div2 = scan_period / base_period;\r\nbreak;\r\n}\r\ncomedi_check_trigger_arg_min(&pacer->next_div, 2);\r\ncomedi_check_trigger_arg_max(&pacer->next_div, I8254_MAX_COUNT);\r\ncomedi_check_trigger_arg_min(&pacer->next_div2, 2);\r\ncomedi_check_trigger_arg_max(&pacer->next_div2,\r\nI8254_MAX_COUNT);\r\nlabpc_set_ai_convert_period(cmd, mode,\r\nbase_period * pacer->next_div);\r\nlabpc_set_ai_scan_period(cmd, mode,\r\nbase_period * pacer->next_div2);\r\n} else if (scan_period) {\r\ncomedi_8254_cascade_ns_to_timer(pacer, &scan_period,\r\ncmd->flags);\r\nlabpc_set_ai_scan_period(cmd, mode, scan_period);\r\n} else if (convert_period) {\r\ncomedi_8254_cascade_ns_to_timer(pacer, &convert_period,\r\ncmd->flags);\r\npacer->next_div = pacer->next_div2;\r\nlabpc_set_ai_convert_period(cmd, mode, convert_period);\r\n}\r\n}\r\nstatic enum scan_mode labpc_ai_scan_mode(const struct comedi_cmd *cmd)\r\n{\r\nunsigned int chan0;\r\nunsigned int chan1;\r\nif (cmd->chanlist_len == 1)\r\nreturn MODE_SINGLE_CHAN;\r\nif (!cmd->chanlist)\r\nreturn MODE_MULT_CHAN_UP;\r\nchan0 = CR_CHAN(cmd->chanlist[0]);\r\nchan1 = CR_CHAN(cmd->chanlist[1]);\r\nif (chan0 < chan1)\r\nreturn MODE_MULT_CHAN_UP;\r\nif (chan0 > chan1)\r\nreturn MODE_MULT_CHAN_DOWN;\r\nreturn MODE_SINGLE_CHAN_INTERVAL;\r\n}\r\nstatic int labpc_ai_check_chanlist(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_cmd *cmd)\r\n{\r\nenum scan_mode mode = labpc_ai_scan_mode(cmd);\r\nunsigned int chan0 = CR_CHAN(cmd->chanlist[0]);\r\nunsigned int range0 = CR_RANGE(cmd->chanlist[0]);\r\nunsigned int aref0 = CR_AREF(cmd->chanlist[0]);\r\nint i;\r\nfor (i = 0; i < cmd->chanlist_len; i++) {\r\nunsigned int chan = CR_CHAN(cmd->chanlist[i]);\r\nunsigned int range = CR_RANGE(cmd->chanlist[i]);\r\nunsigned int aref = CR_AREF(cmd->chanlist[i]);\r\nswitch (mode) {\r\ncase MODE_SINGLE_CHAN:\r\nbreak;\r\ncase MODE_SINGLE_CHAN_INTERVAL:\r\nif (chan != chan0) {\r\ndev_dbg(dev->class_dev,\r\n"channel scanning order specified in chanlist is not supported by hardware\n");\r\nreturn -EINVAL;\r\n}\r\nbreak;\r\ncase MODE_MULT_CHAN_UP:\r\nif (chan != i) {\r\ndev_dbg(dev->class_dev,\r\n"channel scanning order specified in chanlist is not supported by hardware\n");\r\nreturn -EINVAL;\r\n}\r\nbreak;\r\ncase MODE_MULT_CHAN_DOWN:\r\nif (chan != (cmd->chanlist_len - i - 1)) {\r\ndev_dbg(dev->class_dev,\r\n"channel scanning order specified in chanlist is not supported by hardware\n");\r\nreturn -EINVAL;\r\n}\r\nbreak;\r\n}\r\nif (range != range0) {\r\ndev_dbg(dev->class_dev,\r\n"entries in chanlist must all have the same range\n");\r\nreturn -EINVAL;\r\n}\r\nif (aref != aref0) {\r\ndev_dbg(dev->class_dev,\r\n"entries in chanlist must all have the same reference\n");\r\nreturn -EINVAL;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int labpc_ai_cmdtest(struct comedi_device *dev,\r\nstruct comedi_subdevice *s, struct comedi_cmd *cmd)\r\n{\r\nconst struct labpc_boardinfo *board = dev->board_ptr;\r\nint err = 0;\r\nint tmp, tmp2;\r\nunsigned int stop_mask;\r\nenum scan_mode mode;\r\nerr |= comedi_check_trigger_src(&cmd->start_src, TRIG_NOW | TRIG_EXT);\r\nerr |= comedi_check_trigger_src(&cmd->scan_begin_src,\r\nTRIG_TIMER | TRIG_FOLLOW | TRIG_EXT);\r\nerr |= comedi_check_trigger_src(&cmd->convert_src,\r\nTRIG_TIMER | TRIG_EXT);\r\nerr |= comedi_check_trigger_src(&cmd->scan_end_src, TRIG_COUNT);\r\nstop_mask = TRIG_COUNT | TRIG_NONE;\r\nif (board->is_labpc1200)\r\nstop_mask |= TRIG_EXT;\r\nerr |= comedi_check_trigger_src(&cmd->stop_src, stop_mask);\r\nif (err)\r\nreturn 1;\r\nerr |= comedi_check_trigger_is_unique(cmd->start_src);\r\nerr |= comedi_check_trigger_is_unique(cmd->scan_begin_src);\r\nerr |= comedi_check_trigger_is_unique(cmd->convert_src);\r\nerr |= comedi_check_trigger_is_unique(cmd->stop_src);\r\nif (cmd->start_src == TRIG_EXT && cmd->stop_src == TRIG_EXT)\r\nerr++;\r\nif (err)\r\nreturn 2;\r\nswitch (cmd->start_src) {\r\ncase TRIG_NOW:\r\nerr |= comedi_check_trigger_arg_is(&cmd->start_arg, 0);\r\nbreak;\r\ncase TRIG_EXT:\r\nbreak;\r\n}\r\nif (!cmd->chanlist_len)\r\nerr |= -EINVAL;\r\nerr |= comedi_check_trigger_arg_is(&cmd->scan_end_arg,\r\ncmd->chanlist_len);\r\nif (cmd->convert_src == TRIG_TIMER) {\r\nerr |= comedi_check_trigger_arg_min(&cmd->convert_arg,\r\nboard->ai_speed);\r\n}\r\nif (cmd->scan_begin_src == TRIG_TIMER) {\r\nif (cmd->convert_src == TRIG_TIMER) {\r\nerr |= comedi_check_trigger_arg_min(&cmd->\r\nscan_begin_arg,\r\ncmd->convert_arg *\r\ncmd->chanlist_len);\r\n}\r\nerr |= comedi_check_trigger_arg_min(&cmd->scan_begin_arg,\r\nboard->ai_speed *\r\ncmd->chanlist_len);\r\n}\r\nswitch (cmd->stop_src) {\r\ncase TRIG_COUNT:\r\nerr |= comedi_check_trigger_arg_min(&cmd->stop_arg, 1);\r\nbreak;\r\ncase TRIG_NONE:\r\nerr |= comedi_check_trigger_arg_is(&cmd->stop_arg, 0);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nif (err)\r\nreturn 3;\r\ntmp = cmd->convert_arg;\r\ntmp2 = cmd->scan_begin_arg;\r\nmode = labpc_ai_scan_mode(cmd);\r\nlabpc_adc_timing(dev, cmd, mode);\r\nif (tmp != cmd->convert_arg || tmp2 != cmd->scan_begin_arg)\r\nerr++;\r\nif (err)\r\nreturn 4;\r\nif (cmd->chanlist && cmd->chanlist_len > 0)\r\nerr |= labpc_ai_check_chanlist(dev, s, cmd);\r\nif (err)\r\nreturn 5;\r\nreturn 0;\r\n}\r\nstatic int labpc_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)\r\n{\r\nconst struct labpc_boardinfo *board = dev->board_ptr;\r\nstruct labpc_private *devpriv = dev->private;\r\nstruct comedi_async *async = s->async;\r\nstruct comedi_cmd *cmd = &async->cmd;\r\nenum scan_mode mode = labpc_ai_scan_mode(cmd);\r\nunsigned int chanspec = (mode == MODE_MULT_CHAN_UP) ?\r\ncmd->chanlist[cmd->chanlist_len - 1] :\r\ncmd->chanlist[0];\r\nunsigned int chan = CR_CHAN(chanspec);\r\nunsigned int range = CR_RANGE(chanspec);\r\nunsigned int aref = CR_AREF(chanspec);\r\nenum transfer_type xfer;\r\nunsigned long flags;\r\nlabpc_cancel(dev, s);\r\nif (cmd->stop_src == TRIG_COUNT)\r\ndevpriv->count = cmd->stop_arg * cmd->chanlist_len;\r\nif (cmd->stop_src == TRIG_EXT) {\r\ncomedi_8254_load(devpriv->counter, 1,\r\n3, I8254_MODE0 | I8254_BINARY);\r\n} else {\r\ncomedi_8254_set_mode(devpriv->counter, 1,\r\nI8254_MODE0 | I8254_BINARY);\r\n}\r\nif (devpriv->dma &&\r\n(cmd->flags & (CMDF_WAKE_EOS | CMDF_PRIORITY)) == 0)\r\nxfer = isa_dma_transfer;\r\nelse if (\r\nboard->is_labpc1200 &&\r\n(cmd->flags & CMDF_WAKE_EOS) == 0 &&\r\n(cmd->stop_src != TRIG_COUNT || devpriv->count > 256))\r\nxfer = fifo_half_full_transfer;\r\nelse\r\nxfer = fifo_not_empty_transfer;\r\ndevpriv->current_transfer = xfer;\r\nlabpc_ai_set_chan_and_gain(dev, mode, chan, range, aref);\r\nlabpc_setup_cmd6_reg(dev, s, mode, xfer, range, aref,\r\n(cmd->stop_src == TRIG_EXT));\r\nif (mode == MODE_MULT_CHAN_UP || mode == MODE_MULT_CHAN_DOWN) {\r\ndevpriv->cmd1 |= CMD1_SCANEN;\r\nudelay(1);\r\ndevpriv->write_byte(dev, devpriv->cmd1, CMD1_REG);\r\n}\r\ndevpriv->write_byte(dev, cmd->chanlist_len, INTERVAL_COUNT_REG);\r\ndevpriv->write_byte(dev, 0x1, INTERVAL_STROBE_REG);\r\nif (cmd->convert_src == TRIG_TIMER ||\r\ncmd->scan_begin_src == TRIG_TIMER) {\r\nstruct comedi_8254 *pacer = dev->pacer;\r\nstruct comedi_8254 *counter = devpriv->counter;\r\ncomedi_8254_update_divisors(pacer);\r\ncomedi_8254_load(pacer, 0, pacer->divisor1,\r\nI8254_MODE3 | I8254_BINARY);\r\ncomedi_8254_set_mode(counter, 0, I8254_MODE2 | I8254_BINARY);\r\nif (labpc_ai_convert_period(cmd, mode))\r\ncomedi_8254_write(counter, 0, pacer->divisor);\r\nif (labpc_ai_scan_period(cmd, mode))\r\ncomedi_8254_load(pacer, 1, pacer->divisor2,\r\nI8254_MODE2 | I8254_BINARY);\r\n}\r\nlabpc_clear_adc_fifo(dev);\r\nif (xfer == isa_dma_transfer)\r\nlabpc_setup_dma(dev, s);\r\ndevpriv->cmd3 |= CMD3_ERRINTEN;\r\nif (xfer == fifo_not_empty_transfer)\r\ndevpriv->cmd3 |= CMD3_FIFOINTEN;\r\ndevpriv->write_byte(dev, devpriv->cmd3, CMD3_REG);\r\ndevpriv->cmd4 = 0;\r\nif (cmd->convert_src != TRIG_EXT)\r\ndevpriv->cmd4 |= CMD4_ECLKRCV;\r\nif (!labpc_use_continuous_mode(cmd, mode)) {\r\ndevpriv->cmd4 |= CMD4_INTSCAN;\r\nif (cmd->scan_begin_src == TRIG_EXT)\r\ndevpriv->cmd4 |= CMD4_EOIRCV;\r\n}\r\nif (aref == AREF_DIFF)\r\ndevpriv->cmd4 |= CMD4_SEDIFF;\r\ndevpriv->write_byte(dev, devpriv->cmd4, CMD4_REG);\r\nspin_lock_irqsave(&dev->spinlock, flags);\r\ndevpriv->cmd2 |= CMD2_TBSEL;\r\ndevpriv->cmd2 &= ~(CMD2_SWTRIG | CMD2_HWTRIG | CMD2_PRETRIG);\r\nif (cmd->start_src == TRIG_EXT)\r\ndevpriv->cmd2 |= CMD2_HWTRIG;\r\nelse\r\ndevpriv->cmd2 |= CMD2_SWTRIG;\r\nif (cmd->stop_src == TRIG_EXT)\r\ndevpriv->cmd2 |= (CMD2_HWTRIG | CMD2_PRETRIG);\r\ndevpriv->write_byte(dev, devpriv->cmd2, CMD2_REG);\r\nspin_unlock_irqrestore(&dev->spinlock, flags);\r\nreturn 0;\r\n}\r\nstatic int labpc_drain_fifo(struct comedi_device *dev)\r\n{\r\nstruct labpc_private *devpriv = dev->private;\r\nstruct comedi_async *async = dev->read_subdev->async;\r\nstruct comedi_cmd *cmd = &async->cmd;\r\nunsigned short data;\r\nconst int timeout = 10000;\r\nunsigned int i;\r\ndevpriv->stat1 = devpriv->read_byte(dev, STAT1_REG);\r\nfor (i = 0; (devpriv->stat1 & STAT1_DAVAIL) && i < timeout;\r\ni++) {\r\nif (cmd->stop_src == TRIG_COUNT) {\r\nif (devpriv->count == 0)\r\nbreak;\r\ndevpriv->count--;\r\n}\r\ndata = labpc_read_adc_fifo(dev);\r\ncomedi_buf_write_samples(dev->read_subdev, &data, 1);\r\ndevpriv->stat1 = devpriv->read_byte(dev, STAT1_REG);\r\n}\r\nif (i == timeout) {\r\ndev_err(dev->class_dev, "ai timeout, fifo never empties\n");\r\nasync->events |= COMEDI_CB_ERROR;\r\nreturn -1;\r\n}\r\nreturn 0;\r\n}\r\nstatic void labpc_drain_dregs(struct comedi_device *dev)\r\n{\r\nstruct labpc_private *devpriv = dev->private;\r\nif (devpriv->current_transfer == isa_dma_transfer)\r\nlabpc_drain_dma(dev);\r\nlabpc_drain_fifo(dev);\r\n}\r\nstatic irqreturn_t labpc_interrupt(int irq, void *d)\r\n{\r\nstruct comedi_device *dev = d;\r\nconst struct labpc_boardinfo *board = dev->board_ptr;\r\nstruct labpc_private *devpriv = dev->private;\r\nstruct comedi_subdevice *s = dev->read_subdev;\r\nstruct comedi_async *async;\r\nstruct comedi_cmd *cmd;\r\nif (!dev->attached) {\r\ndev_err(dev->class_dev, "premature interrupt\n");\r\nreturn IRQ_HANDLED;\r\n}\r\nasync = s->async;\r\ncmd = &async->cmd;\r\ndevpriv->stat1 = devpriv->read_byte(dev, STAT1_REG);\r\nif (board->is_labpc1200)\r\ndevpriv->stat2 = devpriv->read_byte(dev, STAT2_REG);\r\nif ((devpriv->stat1 & (STAT1_GATA0 | STAT1_CNTINT | STAT1_OVERFLOW |\r\nSTAT1_OVERRUN | STAT1_DAVAIL)) == 0 &&\r\n(devpriv->stat2 & STAT2_OUTA1) == 0 &&\r\n(devpriv->stat2 & STAT2_FIFONHF)) {\r\nreturn IRQ_NONE;\r\n}\r\nif (devpriv->stat1 & STAT1_OVERRUN) {\r\ndevpriv->write_byte(dev, 0x1, ADC_FIFO_CLEAR_REG);\r\nasync->events |= COMEDI_CB_ERROR;\r\ncomedi_handle_events(dev, s);\r\ndev_err(dev->class_dev, "overrun\n");\r\nreturn IRQ_HANDLED;\r\n}\r\nif (devpriv->current_transfer == isa_dma_transfer)\r\nlabpc_handle_dma_status(dev);\r\nelse\r\nlabpc_drain_fifo(dev);\r\nif (devpriv->stat1 & STAT1_CNTINT) {\r\ndev_err(dev->class_dev, "handled timer interrupt?\n");\r\ndevpriv->write_byte(dev, 0x1, TIMER_CLEAR_REG);\r\n}\r\nif (devpriv->stat1 & STAT1_OVERFLOW) {\r\ndevpriv->write_byte(dev, 0x1, ADC_FIFO_CLEAR_REG);\r\nasync->events |= COMEDI_CB_ERROR;\r\ncomedi_handle_events(dev, s);\r\ndev_err(dev->class_dev, "overflow\n");\r\nreturn IRQ_HANDLED;\r\n}\r\nif (cmd->stop_src == TRIG_EXT) {\r\nif (devpriv->stat2 & STAT2_OUTA1) {\r\nlabpc_drain_dregs(dev);\r\nasync->events |= COMEDI_CB_EOA;\r\n}\r\n}\r\nif (cmd->stop_src == TRIG_COUNT) {\r\nif (devpriv->count == 0)\r\nasync->events |= COMEDI_CB_EOA;\r\n}\r\ncomedi_handle_events(dev, s);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void labpc_ao_write(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nunsigned int chan, unsigned int val)\r\n{\r\nstruct labpc_private *devpriv = dev->private;\r\ndevpriv->write_byte(dev, val & 0xff, DAC_LSB_REG(chan));\r\ndevpriv->write_byte(dev, (val >> 8) & 0xff, DAC_MSB_REG(chan));\r\ns->readback[chan] = val;\r\n}\r\nstatic int labpc_ao_insn_write(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_insn *insn,\r\nunsigned int *data)\r\n{\r\nconst struct labpc_boardinfo *board = dev->board_ptr;\r\nstruct labpc_private *devpriv = dev->private;\r\nint channel, range;\r\nunsigned long flags;\r\nchannel = CR_CHAN(insn->chanspec);\r\nspin_lock_irqsave(&dev->spinlock, flags);\r\ndevpriv->cmd2 &= ~CMD2_LDAC(channel);\r\ndevpriv->write_byte(dev, devpriv->cmd2, CMD2_REG);\r\nspin_unlock_irqrestore(&dev->spinlock, flags);\r\nif (board->is_labpc1200) {\r\nrange = CR_RANGE(insn->chanspec);\r\nif (comedi_range_is_unipolar(s, range))\r\ndevpriv->cmd6 |= CMD6_DACUNI(channel);\r\nelse\r\ndevpriv->cmd6 &= ~CMD6_DACUNI(channel);\r\ndevpriv->write_byte(dev, devpriv->cmd6, CMD6_REG);\r\n}\r\nlabpc_ao_write(dev, s, channel, data[0]);\r\nreturn 1;\r\n}\r\nstatic void labpc_serial_out(struct comedi_device *dev, unsigned int value,\r\nunsigned int value_width)\r\n{\r\nstruct labpc_private *devpriv = dev->private;\r\nint i;\r\nfor (i = 1; i <= value_width; i++) {\r\ndevpriv->cmd5 &= ~CMD5_SCLK;\r\nif (value & (1 << (value_width - i)))\r\ndevpriv->cmd5 |= CMD5_SDATA;\r\nelse\r\ndevpriv->cmd5 &= ~CMD5_SDATA;\r\nudelay(1);\r\ndevpriv->write_byte(dev, devpriv->cmd5, CMD5_REG);\r\ndevpriv->cmd5 |= CMD5_SCLK;\r\nudelay(1);\r\ndevpriv->write_byte(dev, devpriv->cmd5, CMD5_REG);\r\n}\r\n}\r\nstatic unsigned int labpc_serial_in(struct comedi_device *dev)\r\n{\r\nstruct labpc_private *devpriv = dev->private;\r\nunsigned int value = 0;\r\nint i;\r\nconst int value_width = 8;\r\nfor (i = 1; i <= value_width; i++) {\r\ndevpriv->cmd5 |= CMD5_SCLK;\r\nudelay(1);\r\ndevpriv->write_byte(dev, devpriv->cmd5, CMD5_REG);\r\ndevpriv->cmd5 &= ~CMD5_SCLK;\r\nudelay(1);\r\ndevpriv->write_byte(dev, devpriv->cmd5, CMD5_REG);\r\nudelay(1);\r\ndevpriv->stat2 = devpriv->read_byte(dev, STAT2_REG);\r\nif (devpriv->stat2 & STAT2_PROMOUT)\r\nvalue |= 1 << (value_width - i);\r\n}\r\nreturn value;\r\n}\r\nstatic unsigned int labpc_eeprom_read(struct comedi_device *dev,\r\nunsigned int address)\r\n{\r\nstruct labpc_private *devpriv = dev->private;\r\nunsigned int value;\r\nconst int read_instruction = 0x3;\r\nconst int write_length = 8;\r\ndevpriv->cmd5 &= ~CMD5_EEPROMCS;\r\nudelay(1);\r\ndevpriv->write_byte(dev, devpriv->cmd5, CMD5_REG);\r\ndevpriv->cmd5 |= (CMD5_EEPROMCS | CMD5_WRTPRT);\r\nudelay(1);\r\ndevpriv->write_byte(dev, devpriv->cmd5, CMD5_REG);\r\nlabpc_serial_out(dev, read_instruction, write_length);\r\nlabpc_serial_out(dev, address, write_length);\r\nvalue = labpc_serial_in(dev);\r\ndevpriv->cmd5 &= ~(CMD5_EEPROMCS | CMD5_WRTPRT);\r\nudelay(1);\r\ndevpriv->write_byte(dev, devpriv->cmd5, CMD5_REG);\r\nreturn value;\r\n}\r\nstatic unsigned int labpc_eeprom_read_status(struct comedi_device *dev)\r\n{\r\nstruct labpc_private *devpriv = dev->private;\r\nunsigned int value;\r\nconst int read_status_instruction = 0x5;\r\nconst int write_length = 8;\r\ndevpriv->cmd5 &= ~CMD5_EEPROMCS;\r\nudelay(1);\r\ndevpriv->write_byte(dev, devpriv->cmd5, CMD5_REG);\r\ndevpriv->cmd5 |= (CMD5_EEPROMCS | CMD5_WRTPRT);\r\nudelay(1);\r\ndevpriv->write_byte(dev, devpriv->cmd5, CMD5_REG);\r\nlabpc_serial_out(dev, read_status_instruction, write_length);\r\nvalue = labpc_serial_in(dev);\r\ndevpriv->cmd5 &= ~(CMD5_EEPROMCS | CMD5_WRTPRT);\r\nudelay(1);\r\ndevpriv->write_byte(dev, devpriv->cmd5, CMD5_REG);\r\nreturn value;\r\n}\r\nstatic void labpc_eeprom_write(struct comedi_device *dev,\r\nunsigned int address, unsigned int value)\r\n{\r\nstruct labpc_private *devpriv = dev->private;\r\nconst int write_enable_instruction = 0x6;\r\nconst int write_instruction = 0x2;\r\nconst int write_length = 8;\r\ndevpriv->cmd5 &= ~CMD5_EEPROMCS;\r\nudelay(1);\r\ndevpriv->write_byte(dev, devpriv->cmd5, CMD5_REG);\r\ndevpriv->cmd5 |= (CMD5_EEPROMCS | CMD5_WRTPRT);\r\nudelay(1);\r\ndevpriv->write_byte(dev, devpriv->cmd5, CMD5_REG);\r\nlabpc_serial_out(dev, write_enable_instruction, write_length);\r\ndevpriv->cmd5 &= ~CMD5_EEPROMCS;\r\nudelay(1);\r\ndevpriv->write_byte(dev, devpriv->cmd5, CMD5_REG);\r\ndevpriv->cmd5 |= CMD5_EEPROMCS;\r\nudelay(1);\r\ndevpriv->write_byte(dev, devpriv->cmd5, CMD5_REG);\r\nlabpc_serial_out(dev, write_instruction, write_length);\r\nlabpc_serial_out(dev, address, write_length);\r\nlabpc_serial_out(dev, value, write_length);\r\ndevpriv->cmd5 &= ~CMD5_EEPROMCS;\r\nudelay(1);\r\ndevpriv->write_byte(dev, devpriv->cmd5, CMD5_REG);\r\ndevpriv->cmd5 &= ~(CMD5_EEPROMCS | CMD5_WRTPRT);\r\nudelay(1);\r\ndevpriv->write_byte(dev, devpriv->cmd5, CMD5_REG);\r\n}\r\nstatic void write_caldac(struct comedi_device *dev, unsigned int channel,\r\nunsigned int value)\r\n{\r\nstruct labpc_private *devpriv = dev->private;\r\ndevpriv->cmd5 &= ~(CMD5_CALDACLD | CMD5_EEPROMCS | CMD5_WRTPRT);\r\nudelay(1);\r\ndevpriv->write_byte(dev, devpriv->cmd5, CMD5_REG);\r\nlabpc_serial_out(dev, channel, 4);\r\nlabpc_serial_out(dev, value, 8);\r\ndevpriv->cmd5 |= CMD5_CALDACLD;\r\nudelay(1);\r\ndevpriv->write_byte(dev, devpriv->cmd5, CMD5_REG);\r\ndevpriv->cmd5 &= ~CMD5_CALDACLD;\r\nudelay(1);\r\ndevpriv->write_byte(dev, devpriv->cmd5, CMD5_REG);\r\n}\r\nstatic int labpc_calib_insn_write(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_insn *insn,\r\nunsigned int *data)\r\n{\r\nunsigned int chan = CR_CHAN(insn->chanspec);\r\nif (insn->n > 0) {\r\nunsigned int val = data[insn->n - 1];\r\nif (s->readback[chan] != val) {\r\nwrite_caldac(dev, chan, val);\r\ns->readback[chan] = val;\r\n}\r\n}\r\nreturn insn->n;\r\n}\r\nstatic int labpc_eeprom_ready(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_insn *insn,\r\nunsigned long context)\r\n{\r\nunsigned int status;\r\nstatus = labpc_eeprom_read_status(dev);\r\nif ((status & 0x1) == 0)\r\nreturn 0;\r\nreturn -EBUSY;\r\n}\r\nstatic int labpc_eeprom_insn_write(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_insn *insn,\r\nunsigned int *data)\r\n{\r\nunsigned int chan = CR_CHAN(insn->chanspec);\r\nint ret;\r\nif (chan < 16 || chan > 127)\r\nreturn -EINVAL;\r\nif (insn->n > 0) {\r\nunsigned int val = data[insn->n - 1];\r\nret = comedi_timeout(dev, s, insn, labpc_eeprom_ready, 0);\r\nif (ret)\r\nreturn ret;\r\nlabpc_eeprom_write(dev, chan, val);\r\ns->readback[chan] = val;\r\n}\r\nreturn insn->n;\r\n}\r\nint labpc_common_attach(struct comedi_device *dev,\r\nunsigned int irq, unsigned long isr_flags)\r\n{\r\nconst struct labpc_boardinfo *board = dev->board_ptr;\r\nstruct labpc_private *devpriv;\r\nstruct comedi_subdevice *s;\r\nint ret;\r\nint i;\r\ndevpriv = comedi_alloc_devpriv(dev, sizeof(*devpriv));\r\nif (!devpriv)\r\nreturn -ENOMEM;\r\nif (dev->mmio) {\r\ndevpriv->read_byte = labpc_readb;\r\ndevpriv->write_byte = labpc_writeb;\r\n} else {\r\ndevpriv->read_byte = labpc_inb;\r\ndevpriv->write_byte = labpc_outb;\r\n}\r\ndevpriv->write_byte(dev, devpriv->cmd1, CMD1_REG);\r\ndevpriv->write_byte(dev, devpriv->cmd2, CMD2_REG);\r\ndevpriv->write_byte(dev, devpriv->cmd3, CMD3_REG);\r\ndevpriv->write_byte(dev, devpriv->cmd4, CMD4_REG);\r\nif (board->is_labpc1200) {\r\ndevpriv->write_byte(dev, devpriv->cmd5, CMD5_REG);\r\ndevpriv->write_byte(dev, devpriv->cmd6, CMD6_REG);\r\n}\r\nif (irq) {\r\nret = request_irq(irq, labpc_interrupt, isr_flags,\r\ndev->board_name, dev);\r\nif (ret == 0)\r\ndev->irq = irq;\r\n}\r\nif (dev->mmio) {\r\ndev->pacer = comedi_8254_mm_init(dev->mmio + COUNTER_B_BASE_REG,\r\nI8254_OSC_BASE_2MHZ,\r\nI8254_IO8, 0);\r\ndevpriv->counter = comedi_8254_mm_init(dev->mmio +\r\nCOUNTER_A_BASE_REG,\r\nI8254_OSC_BASE_2MHZ,\r\nI8254_IO8, 0);\r\n} else {\r\ndev->pacer = comedi_8254_init(dev->iobase + COUNTER_B_BASE_REG,\r\nI8254_OSC_BASE_2MHZ,\r\nI8254_IO8, 0);\r\ndevpriv->counter = comedi_8254_init(dev->iobase +\r\nCOUNTER_A_BASE_REG,\r\nI8254_OSC_BASE_2MHZ,\r\nI8254_IO8, 0);\r\n}\r\nif (!dev->pacer || !devpriv->counter)\r\nreturn -ENOMEM;\r\nret = comedi_alloc_subdevices(dev, 5);\r\nif (ret)\r\nreturn ret;\r\ns = &dev->subdevices[0];\r\ns->type = COMEDI_SUBD_AI;\r\ns->subdev_flags = SDF_READABLE | SDF_GROUND | SDF_COMMON | SDF_DIFF;\r\ns->n_chan = 8;\r\ns->len_chanlist = 8;\r\ns->maxdata = 0x0fff;\r\ns->range_table = board->is_labpc1200 ?\r\n&range_labpc_1200_ai : &range_labpc_plus_ai;\r\ns->insn_read = labpc_ai_insn_read;\r\nif (dev->irq) {\r\ndev->read_subdev = s;\r\ns->subdev_flags |= SDF_CMD_READ;\r\ns->do_cmd = labpc_ai_cmd;\r\ns->do_cmdtest = labpc_ai_cmdtest;\r\ns->cancel = labpc_cancel;\r\n}\r\ns = &dev->subdevices[1];\r\nif (board->has_ao) {\r\ns->type = COMEDI_SUBD_AO;\r\ns->subdev_flags = SDF_READABLE | SDF_WRITABLE | SDF_GROUND;\r\ns->n_chan = NUM_AO_CHAN;\r\ns->maxdata = 0x0fff;\r\ns->range_table = &range_labpc_ao;\r\ns->insn_write = labpc_ao_insn_write;\r\nret = comedi_alloc_subdev_readback(s);\r\nif (ret)\r\nreturn ret;\r\nfor (i = 0; i < s->n_chan; i++)\r\nlabpc_ao_write(dev, s, i, s->maxdata / 2);\r\n} else {\r\ns->type = COMEDI_SUBD_UNUSED;\r\n}\r\ns = &dev->subdevices[2];\r\nif (dev->mmio)\r\nret = subdev_8255_mm_init(dev, s, NULL, DIO_BASE_REG);\r\nelse\r\nret = subdev_8255_init(dev, s, NULL, DIO_BASE_REG);\r\nif (ret)\r\nreturn ret;\r\ns = &dev->subdevices[3];\r\nif (board->is_labpc1200) {\r\ns->type = COMEDI_SUBD_CALIB;\r\ns->subdev_flags = SDF_READABLE | SDF_WRITABLE | SDF_INTERNAL;\r\ns->n_chan = 16;\r\ns->maxdata = 0xff;\r\ns->insn_write = labpc_calib_insn_write;\r\nret = comedi_alloc_subdev_readback(s);\r\nif (ret)\r\nreturn ret;\r\nfor (i = 0; i < s->n_chan; i++) {\r\nwrite_caldac(dev, i, s->maxdata / 2);\r\ns->readback[i] = s->maxdata / 2;\r\n}\r\n} else {\r\ns->type = COMEDI_SUBD_UNUSED;\r\n}\r\ns = &dev->subdevices[4];\r\nif (board->is_labpc1200) {\r\ns->type = COMEDI_SUBD_MEMORY;\r\ns->subdev_flags = SDF_READABLE | SDF_WRITABLE | SDF_INTERNAL;\r\ns->n_chan = EEPROM_SIZE;\r\ns->maxdata = 0xff;\r\ns->insn_write = labpc_eeprom_insn_write;\r\nret = comedi_alloc_subdev_readback(s);\r\nif (ret)\r\nreturn ret;\r\nfor (i = 0; i < s->n_chan; i++)\r\ns->readback[i] = labpc_eeprom_read(dev, i);\r\n} else {\r\ns->type = COMEDI_SUBD_UNUSED;\r\n}\r\nreturn 0;\r\n}\r\nvoid labpc_common_detach(struct comedi_device *dev)\r\n{\r\nstruct labpc_private *devpriv = dev->private;\r\nif (devpriv)\r\nkfree(devpriv->counter);\r\n}\r\nstatic int __init labpc_common_init(void)\r\n{\r\nreturn 0;\r\n}\r\nstatic void __exit labpc_common_exit(void)\r\n{\r\n}
