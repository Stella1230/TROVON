static void build_key_data(void)\r\n{\r\nu_char *kp, counters[MAXFUNCS], ch, ch1;\r\nu_short *p_key = key_data, key;\r\nint i, offset = 1;\r\nnstates = (int)(state_tbl[-1]);\r\nmemset(counters, 0, sizeof(counters));\r\nmemset(key_offsets, 0, sizeof(key_offsets));\r\nkp = state_tbl + nstates + 1;\r\nwhile (*kp++) {\r\nfor (i = 0; i < nstates; i++, kp++) {\r\nif (!*kp)\r\ncontinue;\r\nif ((state_tbl[i]&16) != 0 && *kp == SPK_KEY)\r\ncontinue;\r\ncounters[*kp]++;\r\n}\r\n}\r\nfor (i = 0; i < MAXFUNCS; i++) {\r\nif (counters[i] == 0)\r\ncontinue;\r\nkey_offsets[i] = offset;\r\noffset += (counters[i]+1);\r\nif (offset >= MAXKEYS)\r\nbreak;\r\n}\r\nkp = state_tbl + nstates + 1;\r\nwhile ((ch = *kp++)) {\r\nfor (i = 0; i < nstates; i++) {\r\nch1 = *kp++;\r\nif (!ch1)\r\ncontinue;\r\nif ((state_tbl[i]&16) != 0 && ch1 == SPK_KEY)\r\ncontinue;\r\nkey = (state_tbl[i] << 8) + ch;\r\ncounters[ch1]--;\r\noffset = key_offsets[ch1];\r\nif (!offset)\r\ncontinue;\r\np_key = key_data + offset + counters[ch1];\r\n*p_key = key;\r\n}\r\n}\r\n}\r\nstatic void say_key(int key)\r\n{\r\nint i, state = key >> 8;\r\nkey &= 0xff;\r\nfor (i = 0; i < 6; i++) {\r\nif (state & masks[i])\r\nsynth_printf(" %s", spk_msg_get(MSG_STATES_START + i));\r\n}\r\nif ((key > 0) && (key <= num_key_names))\r\nsynth_printf(" %s\n",\r\nspk_msg_get(MSG_KEYNAMES_START + (key - 1)));\r\n}\r\nstatic int help_init(void)\r\n{\r\nchar start = SPACE;\r\nint i;\r\nint num_funcs = MSG_FUNCNAMES_END - MSG_FUNCNAMES_START + 1;\r\nstate_tbl = spk_our_keys[0]+SHIFT_TBL_SIZE+2;\r\nfor (i = 0; i < num_funcs; i++) {\r\nchar *cur_funcname = spk_msg_get(MSG_FUNCNAMES_START + i);\r\nif (start == *cur_funcname)\r\ncontinue;\r\nstart = *cur_funcname;\r\nletter_offsets[(start&31)-1] = i;\r\n}\r\nreturn 0;\r\n}\r\nint spk_handle_help(struct vc_data *vc, u_char type, u_char ch, u_short key)\r\n{\r\nint i, n;\r\nchar *name;\r\nu_char func, *kp;\r\nu_short *p_keys, val;\r\nif (letter_offsets[0] == -1)\r\nhelp_init();\r\nif (type == KT_LATIN) {\r\nif (ch == SPACE) {\r\nspk_special_handler = NULL;\r\nsynth_printf("%s\n", spk_msg_get(MSG_LEAVING_HELP));\r\nreturn 1;\r\n}\r\nch |= 32;\r\nif (ch < 'a' || ch > 'z')\r\nreturn -1;\r\nif (letter_offsets[ch-'a'] == -1) {\r\nsynth_printf(spk_msg_get(MSG_NO_COMMAND), ch);\r\nsynth_printf("\n");\r\nreturn 1;\r\n}\r\ncur_item = letter_offsets[ch-'a'];\r\n} else if (type == KT_CUR) {\r\nif (ch == 0\r\n&& (MSG_FUNCNAMES_START + cur_item + 1) <=\r\nMSG_FUNCNAMES_END)\r\ncur_item++;\r\nelse if (ch == 3 && cur_item > 0)\r\ncur_item--;\r\nelse\r\nreturn -1;\r\n} else if (type == KT_SPKUP\r\n&& ch == SPEAKUP_HELP\r\n&& !spk_special_handler) {\r\nspk_special_handler = spk_handle_help;\r\nsynth_printf("%s\n", spk_msg_get(MSG_HELP_INFO));\r\nbuild_key_data();\r\nreturn 1;\r\n} else {\r\nname = NULL;\r\nif ((type != KT_SPKUP) && (key > 0) && (key <= num_key_names)) {\r\nsynth_printf("%s\n",\r\nspk_msg_get(MSG_KEYNAMES_START + key-1));\r\nreturn 1;\r\n}\r\nfor (i = 0; funcvals[i] != 0 && !name; i++) {\r\nif (ch == funcvals[i])\r\nname = spk_msg_get(MSG_FUNCNAMES_START + i);\r\n}\r\nif (!name)\r\nreturn -1;\r\nkp = spk_our_keys[key]+1;\r\nfor (i = 0; i < nstates; i++) {\r\nif (ch == kp[i])\r\nbreak;\r\n}\r\nkey += (state_tbl[i] << 8);\r\nsay_key(key);\r\nsynth_printf(spk_msg_get(MSG_KEYDESC), name);\r\nsynth_printf("\n");\r\nreturn 1;\r\n}\r\nname = spk_msg_get(MSG_FUNCNAMES_START + cur_item);\r\nfunc = funcvals[cur_item];\r\nsynth_printf("%s", name);\r\nif (key_offsets[func] == 0) {\r\nsynth_printf(" %s\n", spk_msg_get(MSG_IS_UNASSIGNED));\r\nreturn 1;\r\n}\r\np_keys = key_data + key_offsets[func];\r\nfor (n = 0; p_keys[n]; n++) {\r\nval = p_keys[n];\r\nif (n > 0)\r\nsynth_printf("%s ", spk_msg_get(MSG_DISJUNCTION));\r\nsay_key(val);\r\n}\r\nreturn 1;\r\n}
