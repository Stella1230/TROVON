void qlcnic_83xx_register_map(struct qlcnic_hardware_context *ahw)\r\n{\r\nahw->hw_ops = &qlcnic_83xx_hw_ops;\r\nahw->reg_tbl = (u32 *)qlcnic_83xx_reg_tbl;\r\nahw->ext_reg_tbl = (u32 *)qlcnic_83xx_ext_reg_tbl;\r\n}\r\nint qlcnic_83xx_get_fw_version(struct qlcnic_adapter *adapter)\r\n{\r\nu32 fw_major, fw_minor, fw_build;\r\nstruct pci_dev *pdev = adapter->pdev;\r\nfw_major = QLC_SHARED_REG_RD32(adapter, QLCNIC_FW_VERSION_MAJOR);\r\nfw_minor = QLC_SHARED_REG_RD32(adapter, QLCNIC_FW_VERSION_MINOR);\r\nfw_build = QLC_SHARED_REG_RD32(adapter, QLCNIC_FW_VERSION_SUB);\r\nadapter->fw_version = QLCNIC_VERSION_CODE(fw_major, fw_minor, fw_build);\r\ndev_info(&pdev->dev, "Driver v%s, firmware version %d.%d.%d\n",\r\nQLCNIC_LINUX_VERSIONID, fw_major, fw_minor, fw_build);\r\nreturn adapter->fw_version;\r\n}\r\nstatic int __qlcnic_set_win_base(struct qlcnic_adapter *adapter, u32 addr)\r\n{\r\nvoid __iomem *base;\r\nu32 val;\r\nbase = adapter->ahw->pci_base0 +\r\nQLC_83XX_CRB_WIN_FUNC(adapter->ahw->pci_func);\r\nwritel(addr, base);\r\nval = readl(base);\r\nif (val != addr)\r\nreturn -EIO;\r\nreturn 0;\r\n}\r\nint qlcnic_83xx_rd_reg_indirect(struct qlcnic_adapter *adapter, ulong addr,\r\nint *err)\r\n{\r\nstruct qlcnic_hardware_context *ahw = adapter->ahw;\r\n*err = __qlcnic_set_win_base(adapter, (u32) addr);\r\nif (!*err) {\r\nreturn QLCRDX(ahw, QLCNIC_WILDCARD);\r\n} else {\r\ndev_err(&adapter->pdev->dev,\r\n"%s failed, addr = 0x%lx\n", __func__, addr);\r\nreturn -EIO;\r\n}\r\n}\r\nint qlcnic_83xx_wrt_reg_indirect(struct qlcnic_adapter *adapter, ulong addr,\r\nu32 data)\r\n{\r\nint err;\r\nstruct qlcnic_hardware_context *ahw = adapter->ahw;\r\nerr = __qlcnic_set_win_base(adapter, (u32) addr);\r\nif (!err) {\r\nQLCWRX(ahw, QLCNIC_WILDCARD, data);\r\nreturn 0;\r\n} else {\r\ndev_err(&adapter->pdev->dev,\r\n"%s failed, addr = 0x%x data = 0x%x\n",\r\n__func__, (int)addr, data);\r\nreturn err;\r\n}\r\n}\r\nstatic void qlcnic_83xx_enable_legacy(struct qlcnic_adapter *adapter)\r\n{\r\nstruct qlcnic_hardware_context *ahw = adapter->ahw;\r\nadapter->tgt_status_reg = ahw->pci_base0 + QLC_83XX_INTX_PTR;\r\nadapter->tgt_mask_reg = ahw->pci_base0 + QLC_83XX_INTX_MASK;\r\nadapter->isr_int_vec = ahw->pci_base0 + QLC_83XX_INTX_TRGR;\r\nadapter->msix_entries[0].vector = adapter->pdev->irq;\r\ndev_info(&adapter->pdev->dev, "using legacy interrupt\n");\r\n}\r\nstatic int qlcnic_83xx_calculate_msix_vector(struct qlcnic_adapter *adapter)\r\n{\r\nint num_msix;\r\nnum_msix = adapter->drv_sds_rings;\r\nnum_msix += 1;\r\nif (!(adapter->flags & QLCNIC_TX_INTR_SHARED))\r\nnum_msix += adapter->drv_tx_rings;\r\nreturn num_msix;\r\n}\r\nint qlcnic_83xx_setup_intr(struct qlcnic_adapter *adapter)\r\n{\r\nstruct qlcnic_hardware_context *ahw = adapter->ahw;\r\nint err, i, num_msix;\r\nif (adapter->flags & QLCNIC_TSS_RSS) {\r\nerr = qlcnic_setup_tss_rss_intr(adapter);\r\nif (err < 0)\r\nreturn err;\r\nnum_msix = ahw->num_msix;\r\n} else {\r\nnum_msix = qlcnic_83xx_calculate_msix_vector(adapter);\r\nerr = qlcnic_enable_msix(adapter, num_msix);\r\nif (err == -ENOMEM)\r\nreturn err;\r\nif (adapter->flags & QLCNIC_MSIX_ENABLED) {\r\nnum_msix = ahw->num_msix;\r\n} else {\r\nif (qlcnic_sriov_vf_check(adapter))\r\nreturn -EINVAL;\r\nnum_msix = 1;\r\nadapter->drv_sds_rings = QLCNIC_SINGLE_RING;\r\nadapter->drv_tx_rings = QLCNIC_SINGLE_RING;\r\n}\r\n}\r\nahw->intr_tbl = vzalloc(num_msix *\r\nsizeof(struct qlcnic_intrpt_config));\r\nif (!ahw->intr_tbl)\r\nreturn -ENOMEM;\r\nif (!(adapter->flags & QLCNIC_MSIX_ENABLED)) {\r\nif (adapter->ahw->pci_func >= QLC_MAX_LEGACY_FUNC_SUPP) {\r\ndev_err(&adapter->pdev->dev, "PCI function number 8 and higher are not supported with legacy interrupt, func 0x%x\n",\r\nahw->pci_func);\r\nreturn -EOPNOTSUPP;\r\n}\r\nqlcnic_83xx_enable_legacy(adapter);\r\n}\r\nfor (i = 0; i < num_msix; i++) {\r\nif (adapter->flags & QLCNIC_MSIX_ENABLED)\r\nahw->intr_tbl[i].type = QLCNIC_INTRPT_MSIX;\r\nelse\r\nahw->intr_tbl[i].type = QLCNIC_INTRPT_INTX;\r\nahw->intr_tbl[i].id = i;\r\nahw->intr_tbl[i].src = 0;\r\n}\r\nreturn 0;\r\n}\r\nstatic inline void qlcnic_83xx_clear_legacy_intr_mask(struct qlcnic_adapter *adapter)\r\n{\r\nwritel(0, adapter->tgt_mask_reg);\r\n}\r\nstatic inline void qlcnic_83xx_set_legacy_intr_mask(struct qlcnic_adapter *adapter)\r\n{\r\nif (adapter->tgt_mask_reg)\r\nwritel(1, adapter->tgt_mask_reg);\r\n}\r\nstatic inline void qlcnic_83xx_enable_legacy_msix_mbx_intr(struct qlcnic_adapter\r\n*adapter)\r\n{\r\nu32 mask;\r\nmask = QLCRDX(adapter->ahw, QLCNIC_DEF_INT_MASK);\r\nwritel(0, adapter->ahw->pci_base0 + mask);\r\n}\r\nvoid qlcnic_83xx_disable_mbx_intr(struct qlcnic_adapter *adapter)\r\n{\r\nu32 mask;\r\nmask = QLCRDX(adapter->ahw, QLCNIC_DEF_INT_MASK);\r\nwritel(1, adapter->ahw->pci_base0 + mask);\r\nQLCWRX(adapter->ahw, QLCNIC_MBX_INTR_ENBL, 0);\r\n}\r\nstatic inline void qlcnic_83xx_get_mbx_data(struct qlcnic_adapter *adapter,\r\nstruct qlcnic_cmd_args *cmd)\r\n{\r\nint i;\r\nif (cmd->op_type == QLC_83XX_MBX_POST_BC_OP)\r\nreturn;\r\nfor (i = 0; i < cmd->rsp.num; i++)\r\ncmd->rsp.arg[i] = readl(QLCNIC_MBX_FW(adapter->ahw, i));\r\n}\r\nirqreturn_t qlcnic_83xx_clear_legacy_intr(struct qlcnic_adapter *adapter)\r\n{\r\nu32 intr_val;\r\nstruct qlcnic_hardware_context *ahw = adapter->ahw;\r\nint retries = 0;\r\nintr_val = readl(adapter->tgt_status_reg);\r\nif (!QLC_83XX_VALID_INTX_BIT31(intr_val))\r\nreturn IRQ_NONE;\r\nif (QLC_83XX_INTX_FUNC(intr_val) != adapter->ahw->pci_func) {\r\nadapter->stats.spurious_intr++;\r\nreturn IRQ_NONE;\r\n}\r\nwmb();\r\nwritel(0, adapter->isr_int_vec);\r\nintr_val = readl(adapter->isr_int_vec);\r\ndo {\r\nintr_val = readl(adapter->tgt_status_reg);\r\nif (QLC_83XX_INTX_FUNC(intr_val) != ahw->pci_func)\r\nbreak;\r\nretries++;\r\n} while (QLC_83XX_VALID_INTX_BIT30(intr_val) &&\r\n(retries < QLC_83XX_LEGACY_INTX_MAX_RETRY));\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic inline void qlcnic_83xx_notify_mbx_response(struct qlcnic_mailbox *mbx)\r\n{\r\natomic_set(&mbx->rsp_status, QLC_83XX_MBX_RESPONSE_ARRIVED);\r\ncomplete(&mbx->completion);\r\n}\r\nstatic void qlcnic_83xx_poll_process_aen(struct qlcnic_adapter *adapter)\r\n{\r\nu32 resp, event, rsp_status = QLC_83XX_MBX_RESPONSE_ARRIVED;\r\nstruct qlcnic_mailbox *mbx = adapter->ahw->mailbox;\r\nunsigned long flags;\r\nspin_lock_irqsave(&mbx->aen_lock, flags);\r\nresp = QLCRDX(adapter->ahw, QLCNIC_FW_MBX_CTRL);\r\nif (!(resp & QLCNIC_SET_OWNER))\r\ngoto out;\r\nevent = readl(QLCNIC_MBX_FW(adapter->ahw, 0));\r\nif (event & QLCNIC_MBX_ASYNC_EVENT) {\r\n__qlcnic_83xx_process_aen(adapter);\r\n} else {\r\nif (atomic_read(&mbx->rsp_status) != rsp_status)\r\nqlcnic_83xx_notify_mbx_response(mbx);\r\n}\r\nout:\r\nqlcnic_83xx_enable_legacy_msix_mbx_intr(adapter);\r\nspin_unlock_irqrestore(&mbx->aen_lock, flags);\r\n}\r\nirqreturn_t qlcnic_83xx_intr(int irq, void *data)\r\n{\r\nstruct qlcnic_adapter *adapter = data;\r\nstruct qlcnic_host_sds_ring *sds_ring;\r\nstruct qlcnic_hardware_context *ahw = adapter->ahw;\r\nif (qlcnic_83xx_clear_legacy_intr(adapter) == IRQ_NONE)\r\nreturn IRQ_NONE;\r\nqlcnic_83xx_poll_process_aen(adapter);\r\nif (ahw->diag_test) {\r\nif (ahw->diag_test == QLCNIC_INTERRUPT_TEST)\r\nahw->diag_cnt++;\r\nqlcnic_83xx_enable_legacy_msix_mbx_intr(adapter);\r\nreturn IRQ_HANDLED;\r\n}\r\nif (!test_bit(__QLCNIC_DEV_UP, &adapter->state)) {\r\nqlcnic_83xx_enable_legacy_msix_mbx_intr(adapter);\r\n} else {\r\nsds_ring = &adapter->recv_ctx->sds_rings[0];\r\nnapi_schedule(&sds_ring->napi);\r\n}\r\nreturn IRQ_HANDLED;\r\n}\r\nirqreturn_t qlcnic_83xx_tmp_intr(int irq, void *data)\r\n{\r\nstruct qlcnic_host_sds_ring *sds_ring = data;\r\nstruct qlcnic_adapter *adapter = sds_ring->adapter;\r\nif (adapter->flags & QLCNIC_MSIX_ENABLED)\r\ngoto done;\r\nif (adapter->nic_ops->clear_legacy_intr(adapter) == IRQ_NONE)\r\nreturn IRQ_NONE;\r\ndone:\r\nadapter->ahw->diag_cnt++;\r\nqlcnic_enable_sds_intr(adapter, sds_ring);\r\nreturn IRQ_HANDLED;\r\n}\r\nvoid qlcnic_83xx_free_mbx_intr(struct qlcnic_adapter *adapter)\r\n{\r\nu32 num_msix;\r\nif (!(adapter->flags & QLCNIC_MSIX_ENABLED))\r\nqlcnic_83xx_set_legacy_intr_mask(adapter);\r\nqlcnic_83xx_disable_mbx_intr(adapter);\r\nif (adapter->flags & QLCNIC_MSIX_ENABLED)\r\nnum_msix = adapter->ahw->num_msix - 1;\r\nelse\r\nnum_msix = 0;\r\nmsleep(20);\r\nif (adapter->msix_entries) {\r\nsynchronize_irq(adapter->msix_entries[num_msix].vector);\r\nfree_irq(adapter->msix_entries[num_msix].vector, adapter);\r\n}\r\n}\r\nint qlcnic_83xx_setup_mbx_intr(struct qlcnic_adapter *adapter)\r\n{\r\nirq_handler_t handler;\r\nu32 val;\r\nint err = 0;\r\nunsigned long flags = 0;\r\nif (!(adapter->flags & QLCNIC_MSI_ENABLED) &&\r\n!(adapter->flags & QLCNIC_MSIX_ENABLED))\r\nflags |= IRQF_SHARED;\r\nif (adapter->flags & QLCNIC_MSIX_ENABLED) {\r\nhandler = qlcnic_83xx_handle_aen;\r\nval = adapter->msix_entries[adapter->ahw->num_msix - 1].vector;\r\nerr = request_irq(val, handler, flags, "qlcnic-MB", adapter);\r\nif (err) {\r\ndev_err(&adapter->pdev->dev,\r\n"failed to register MBX interrupt\n");\r\nreturn err;\r\n}\r\n} else {\r\nhandler = qlcnic_83xx_intr;\r\nval = adapter->msix_entries[0].vector;\r\nerr = request_irq(val, handler, flags, "qlcnic", adapter);\r\nif (err) {\r\ndev_err(&adapter->pdev->dev,\r\n"failed to register INTx interrupt\n");\r\nreturn err;\r\n}\r\nqlcnic_83xx_clear_legacy_intr_mask(adapter);\r\n}\r\nqlcnic_83xx_enable_mbx_interrupt(adapter);\r\nreturn err;\r\n}\r\nvoid qlcnic_83xx_get_func_no(struct qlcnic_adapter *adapter)\r\n{\r\nu32 val = QLCRDX(adapter->ahw, QLCNIC_INFORMANT);\r\nadapter->ahw->pci_func = (val >> 24) & 0xff;\r\n}\r\nint qlcnic_83xx_cam_lock(struct qlcnic_adapter *adapter)\r\n{\r\nvoid __iomem *addr;\r\nu32 val, limit = 0;\r\nstruct qlcnic_hardware_context *ahw = adapter->ahw;\r\naddr = ahw->pci_base0 + QLC_83XX_SEM_LOCK_FUNC(ahw->pci_func);\r\ndo {\r\nval = readl(addr);\r\nif (val) {\r\nQLC_SHARED_REG_WR32(adapter, QLCNIC_FLASH_LOCK_OWNER,\r\nahw->pci_func);\r\nreturn 0;\r\n}\r\nusleep_range(1000, 2000);\r\n} while (++limit <= QLCNIC_PCIE_SEM_TIMEOUT);\r\nreturn -EIO;\r\n}\r\nvoid qlcnic_83xx_cam_unlock(struct qlcnic_adapter *adapter)\r\n{\r\nvoid __iomem *addr;\r\nu32 val;\r\nstruct qlcnic_hardware_context *ahw = adapter->ahw;\r\naddr = ahw->pci_base0 + QLC_83XX_SEM_UNLOCK_FUNC(ahw->pci_func);\r\nval = readl(addr);\r\n}\r\nvoid qlcnic_83xx_read_crb(struct qlcnic_adapter *adapter, char *buf,\r\nloff_t offset, size_t size)\r\n{\r\nint ret = 0;\r\nu32 data;\r\nif (qlcnic_api_lock(adapter)) {\r\ndev_err(&adapter->pdev->dev,\r\n"%s: failed to acquire lock. addr offset 0x%x\n",\r\n__func__, (u32)offset);\r\nreturn;\r\n}\r\ndata = QLCRD32(adapter, (u32) offset, &ret);\r\nqlcnic_api_unlock(adapter);\r\nif (ret == -EIO) {\r\ndev_err(&adapter->pdev->dev,\r\n"%s: failed. addr offset 0x%x\n",\r\n__func__, (u32)offset);\r\nreturn;\r\n}\r\nmemcpy(buf, &data, size);\r\n}\r\nvoid qlcnic_83xx_write_crb(struct qlcnic_adapter *adapter, char *buf,\r\nloff_t offset, size_t size)\r\n{\r\nu32 data;\r\nmemcpy(&data, buf, size);\r\nqlcnic_83xx_wrt_reg_indirect(adapter, (u32) offset, data);\r\n}\r\nint qlcnic_83xx_get_port_info(struct qlcnic_adapter *adapter)\r\n{\r\nstruct qlcnic_hardware_context *ahw = adapter->ahw;\r\nint status;\r\nstatus = qlcnic_83xx_get_port_config(adapter);\r\nif (status) {\r\ndev_err(&adapter->pdev->dev,\r\n"Get Port Info failed\n");\r\n} else {\r\nif (ahw->port_config & QLC_83XX_10G_CAPABLE) {\r\nahw->port_type = QLCNIC_XGBE;\r\n} else if (ahw->port_config & QLC_83XX_10_CAPABLE ||\r\nahw->port_config & QLC_83XX_100_CAPABLE ||\r\nahw->port_config & QLC_83XX_1G_CAPABLE) {\r\nahw->port_type = QLCNIC_GBE;\r\n} else {\r\nahw->port_type = QLCNIC_XGBE;\r\n}\r\nif (QLC_83XX_AUTONEG(ahw->port_config))\r\nahw->link_autoneg = AUTONEG_ENABLE;\r\n}\r\nreturn status;\r\n}\r\nstatic void qlcnic_83xx_set_mac_filter_count(struct qlcnic_adapter *adapter)\r\n{\r\nstruct qlcnic_hardware_context *ahw = adapter->ahw;\r\nu16 act_pci_fn = ahw->total_nic_func;\r\nu16 count;\r\nahw->max_mc_count = QLC_83XX_MAX_MC_COUNT;\r\nif (act_pci_fn <= 2)\r\ncount = (QLC_83XX_MAX_UC_COUNT - QLC_83XX_MAX_MC_COUNT) /\r\nact_pci_fn;\r\nelse\r\ncount = (QLC_83XX_LB_MAX_FILTERS - QLC_83XX_MAX_MC_COUNT) /\r\nact_pci_fn;\r\nahw->max_uc_count = count;\r\n}\r\nvoid qlcnic_83xx_enable_mbx_interrupt(struct qlcnic_adapter *adapter)\r\n{\r\nu32 val;\r\nif (adapter->flags & QLCNIC_MSIX_ENABLED)\r\nval = BIT_2 | ((adapter->ahw->num_msix - 1) << 8);\r\nelse\r\nval = BIT_2;\r\nQLCWRX(adapter->ahw, QLCNIC_MBX_INTR_ENBL, val);\r\nqlcnic_83xx_enable_legacy_msix_mbx_intr(adapter);\r\n}\r\nvoid qlcnic_83xx_check_vf(struct qlcnic_adapter *adapter,\r\nconst struct pci_device_id *ent)\r\n{\r\nu32 op_mode, priv_level;\r\nstruct qlcnic_hardware_context *ahw = adapter->ahw;\r\nahw->fw_hal_version = 2;\r\nqlcnic_get_func_no(adapter);\r\nif (qlcnic_sriov_vf_check(adapter)) {\r\nqlcnic_sriov_vf_set_ops(adapter);\r\nreturn;\r\n}\r\nop_mode = QLCRDX(adapter->ahw, QLC_83XX_DRV_OP_MODE);\r\nif (op_mode == QLC_83XX_DEFAULT_OPMODE)\r\npriv_level = QLCNIC_MGMT_FUNC;\r\nelse\r\npriv_level = QLC_83XX_GET_FUNC_PRIVILEGE(op_mode,\r\nahw->pci_func);\r\nif (priv_level == QLCNIC_NON_PRIV_FUNC) {\r\nahw->op_mode = QLCNIC_NON_PRIV_FUNC;\r\ndev_info(&adapter->pdev->dev,\r\n"HAL Version: %d Non Privileged function\n",\r\nahw->fw_hal_version);\r\nadapter->nic_ops = &qlcnic_vf_ops;\r\n} else {\r\nif (pci_find_ext_capability(adapter->pdev,\r\nPCI_EXT_CAP_ID_SRIOV))\r\nset_bit(__QLCNIC_SRIOV_CAPABLE, &adapter->state);\r\nadapter->nic_ops = &qlcnic_83xx_ops;\r\n}\r\n}\r\nvoid qlcnic_dump_mbx(struct qlcnic_adapter *adapter,\r\nstruct qlcnic_cmd_args *cmd)\r\n{\r\nint i;\r\nif (cmd->op_type == QLC_83XX_MBX_POST_BC_OP)\r\nreturn;\r\ndev_info(&adapter->pdev->dev,\r\n"Host MBX regs(%d)\n", cmd->req.num);\r\nfor (i = 0; i < cmd->req.num; i++) {\r\nif (i && !(i % 8))\r\npr_info("\n");\r\npr_info("%08x ", cmd->req.arg[i]);\r\n}\r\npr_info("\n");\r\ndev_info(&adapter->pdev->dev,\r\n"FW MBX regs(%d)\n", cmd->rsp.num);\r\nfor (i = 0; i < cmd->rsp.num; i++) {\r\nif (i && !(i % 8))\r\npr_info("\n");\r\npr_info("%08x ", cmd->rsp.arg[i]);\r\n}\r\npr_info("\n");\r\n}\r\nstatic void qlcnic_83xx_poll_for_mbx_completion(struct qlcnic_adapter *adapter,\r\nstruct qlcnic_cmd_args *cmd)\r\n{\r\nstruct qlcnic_hardware_context *ahw = adapter->ahw;\r\nint opcode = LSW(cmd->req.arg[0]);\r\nunsigned long max_loops;\r\nmax_loops = cmd->total_cmds * QLC_83XX_MBX_CMD_LOOP;\r\nfor (; max_loops; max_loops--) {\r\nif (atomic_read(&cmd->rsp_status) ==\r\nQLC_83XX_MBX_RESPONSE_ARRIVED)\r\nreturn;\r\nudelay(1);\r\n}\r\ndev_err(&adapter->pdev->dev,\r\n"%s: Mailbox command timed out, cmd_op=0x%x, cmd_type=0x%x, pci_func=0x%x, op_mode=0x%x\n",\r\n__func__, opcode, cmd->type, ahw->pci_func, ahw->op_mode);\r\nflush_workqueue(ahw->mailbox->work_q);\r\nreturn;\r\n}\r\nint qlcnic_83xx_issue_cmd(struct qlcnic_adapter *adapter,\r\nstruct qlcnic_cmd_args *cmd)\r\n{\r\nstruct qlcnic_mailbox *mbx = adapter->ahw->mailbox;\r\nstruct qlcnic_hardware_context *ahw = adapter->ahw;\r\nint cmd_type, err, opcode;\r\nunsigned long timeout;\r\nif (!mbx)\r\nreturn -EIO;\r\nopcode = LSW(cmd->req.arg[0]);\r\ncmd_type = cmd->type;\r\nerr = mbx->ops->enqueue_cmd(adapter, cmd, &timeout);\r\nif (err) {\r\ndev_err(&adapter->pdev->dev,\r\n"%s: Mailbox not available, cmd_op=0x%x, cmd_context=0x%x, pci_func=0x%x, op_mode=0x%x\n",\r\n__func__, opcode, cmd->type, ahw->pci_func,\r\nahw->op_mode);\r\nreturn err;\r\n}\r\nswitch (cmd_type) {\r\ncase QLC_83XX_MBX_CMD_WAIT:\r\nif (!wait_for_completion_timeout(&cmd->completion, timeout)) {\r\ndev_err(&adapter->pdev->dev,\r\n"%s: Mailbox command timed out, cmd_op=0x%x, cmd_type=0x%x, pci_func=0x%x, op_mode=0x%x\n",\r\n__func__, opcode, cmd_type, ahw->pci_func,\r\nahw->op_mode);\r\nflush_workqueue(mbx->work_q);\r\n}\r\nbreak;\r\ncase QLC_83XX_MBX_CMD_NO_WAIT:\r\nreturn 0;\r\ncase QLC_83XX_MBX_CMD_BUSY_WAIT:\r\nqlcnic_83xx_poll_for_mbx_completion(adapter, cmd);\r\nbreak;\r\ndefault:\r\ndev_err(&adapter->pdev->dev,\r\n"%s: Invalid mailbox command, cmd_op=0x%x, cmd_type=0x%x, pci_func=0x%x, op_mode=0x%x\n",\r\n__func__, opcode, cmd_type, ahw->pci_func,\r\nahw->op_mode);\r\nqlcnic_83xx_detach_mailbox_work(adapter);\r\n}\r\nreturn cmd->rsp_opcode;\r\n}\r\nint qlcnic_83xx_alloc_mbx_args(struct qlcnic_cmd_args *mbx,\r\nstruct qlcnic_adapter *adapter, u32 type)\r\n{\r\nint i, size;\r\nu32 temp;\r\nconst struct qlcnic_mailbox_metadata *mbx_tbl;\r\nmemset(mbx, 0, sizeof(struct qlcnic_cmd_args));\r\nmbx_tbl = qlcnic_83xx_mbx_tbl;\r\nsize = ARRAY_SIZE(qlcnic_83xx_mbx_tbl);\r\nfor (i = 0; i < size; i++) {\r\nif (type == mbx_tbl[i].cmd) {\r\nmbx->op_type = QLC_83XX_FW_MBX_CMD;\r\nmbx->req.num = mbx_tbl[i].in_args;\r\nmbx->rsp.num = mbx_tbl[i].out_args;\r\nmbx->req.arg = kcalloc(mbx->req.num, sizeof(u32),\r\nGFP_ATOMIC);\r\nif (!mbx->req.arg)\r\nreturn -ENOMEM;\r\nmbx->rsp.arg = kcalloc(mbx->rsp.num, sizeof(u32),\r\nGFP_ATOMIC);\r\nif (!mbx->rsp.arg) {\r\nkfree(mbx->req.arg);\r\nmbx->req.arg = NULL;\r\nreturn -ENOMEM;\r\n}\r\ntemp = adapter->ahw->fw_hal_version << 29;\r\nmbx->req.arg[0] = (type | (mbx->req.num << 16) | temp);\r\nmbx->cmd_op = type;\r\nreturn 0;\r\n}\r\n}\r\ndev_err(&adapter->pdev->dev, "%s: Invalid mailbox command opcode 0x%x\n",\r\n__func__, type);\r\nreturn -EINVAL;\r\n}\r\nvoid qlcnic_83xx_idc_aen_work(struct work_struct *work)\r\n{\r\nstruct qlcnic_adapter *adapter;\r\nstruct qlcnic_cmd_args cmd;\r\nint i, err = 0;\r\nadapter = container_of(work, struct qlcnic_adapter, idc_aen_work.work);\r\nerr = qlcnic_alloc_mbx_args(&cmd, adapter, QLCNIC_CMD_IDC_ACK);\r\nif (err)\r\nreturn;\r\nfor (i = 1; i < QLC_83XX_MBX_AEN_CNT; i++)\r\ncmd.req.arg[i] = adapter->ahw->mbox_aen[i];\r\nerr = qlcnic_issue_cmd(adapter, &cmd);\r\nif (err)\r\ndev_info(&adapter->pdev->dev,\r\n"%s: Mailbox IDC ACK failed.\n", __func__);\r\nqlcnic_free_mbx_args(&cmd);\r\n}\r\nstatic void qlcnic_83xx_handle_idc_comp_aen(struct qlcnic_adapter *adapter,\r\nu32 data[])\r\n{\r\ndev_dbg(&adapter->pdev->dev, "Completion AEN:0x%x.\n",\r\nQLCNIC_MBX_RSP(data[0]));\r\nclear_bit(QLC_83XX_IDC_COMP_AEN, &adapter->ahw->idc.status);\r\nreturn;\r\n}\r\nstatic void __qlcnic_83xx_process_aen(struct qlcnic_adapter *adapter)\r\n{\r\nstruct qlcnic_hardware_context *ahw = adapter->ahw;\r\nu32 event[QLC_83XX_MBX_AEN_CNT];\r\nint i;\r\nfor (i = 0; i < QLC_83XX_MBX_AEN_CNT; i++)\r\nevent[i] = readl(QLCNIC_MBX_FW(ahw, i));\r\nswitch (QLCNIC_MBX_RSP(event[0])) {\r\ncase QLCNIC_MBX_LINK_EVENT:\r\nqlcnic_83xx_handle_link_aen(adapter, event);\r\nbreak;\r\ncase QLCNIC_MBX_COMP_EVENT:\r\nqlcnic_83xx_handle_idc_comp_aen(adapter, event);\r\nbreak;\r\ncase QLCNIC_MBX_REQUEST_EVENT:\r\nfor (i = 0; i < QLC_83XX_MBX_AEN_CNT; i++)\r\nadapter->ahw->mbox_aen[i] = QLCNIC_MBX_RSP(event[i]);\r\nqueue_delayed_work(adapter->qlcnic_wq,\r\n&adapter->idc_aen_work, 0);\r\nbreak;\r\ncase QLCNIC_MBX_TIME_EXTEND_EVENT:\r\nahw->extend_lb_time = event[1] >> 8 & 0xf;\r\nbreak;\r\ncase QLCNIC_MBX_BC_EVENT:\r\nqlcnic_sriov_handle_bc_event(adapter, event[1]);\r\nbreak;\r\ncase QLCNIC_MBX_SFP_INSERT_EVENT:\r\ndev_info(&adapter->pdev->dev, "SFP+ Insert AEN:0x%x.\n",\r\nQLCNIC_MBX_RSP(event[0]));\r\nbreak;\r\ncase QLCNIC_MBX_SFP_REMOVE_EVENT:\r\ndev_info(&adapter->pdev->dev, "SFP Removed AEN:0x%x.\n",\r\nQLCNIC_MBX_RSP(event[0]));\r\nbreak;\r\ncase QLCNIC_MBX_DCBX_CONFIG_CHANGE_EVENT:\r\nqlcnic_dcb_aen_handler(adapter->dcb, (void *)&event[1]);\r\nbreak;\r\ndefault:\r\ndev_dbg(&adapter->pdev->dev, "Unsupported AEN:0x%x.\n",\r\nQLCNIC_MBX_RSP(event[0]));\r\nbreak;\r\n}\r\nQLCWRX(ahw, QLCNIC_FW_MBX_CTRL, QLCNIC_CLR_OWNER);\r\n}\r\nstatic void qlcnic_83xx_process_aen(struct qlcnic_adapter *adapter)\r\n{\r\nu32 resp, event, rsp_status = QLC_83XX_MBX_RESPONSE_ARRIVED;\r\nstruct qlcnic_hardware_context *ahw = adapter->ahw;\r\nstruct qlcnic_mailbox *mbx = ahw->mailbox;\r\nunsigned long flags;\r\nspin_lock_irqsave(&mbx->aen_lock, flags);\r\nresp = QLCRDX(ahw, QLCNIC_FW_MBX_CTRL);\r\nif (resp & QLCNIC_SET_OWNER) {\r\nevent = readl(QLCNIC_MBX_FW(ahw, 0));\r\nif (event & QLCNIC_MBX_ASYNC_EVENT) {\r\n__qlcnic_83xx_process_aen(adapter);\r\n} else {\r\nif (atomic_read(&mbx->rsp_status) != rsp_status)\r\nqlcnic_83xx_notify_mbx_response(mbx);\r\n}\r\n}\r\nspin_unlock_irqrestore(&mbx->aen_lock, flags);\r\n}\r\nstatic void qlcnic_83xx_mbx_poll_work(struct work_struct *work)\r\n{\r\nstruct qlcnic_adapter *adapter;\r\nadapter = container_of(work, struct qlcnic_adapter, mbx_poll_work.work);\r\nif (!test_bit(__QLCNIC_MBX_POLL_ENABLE, &adapter->state))\r\nreturn;\r\nqlcnic_83xx_process_aen(adapter);\r\nqueue_delayed_work(adapter->qlcnic_wq, &adapter->mbx_poll_work,\r\n(HZ / 10));\r\n}\r\nvoid qlcnic_83xx_enable_mbx_poll(struct qlcnic_adapter *adapter)\r\n{\r\nif (test_and_set_bit(__QLCNIC_MBX_POLL_ENABLE, &adapter->state))\r\nreturn;\r\nINIT_DELAYED_WORK(&adapter->mbx_poll_work, qlcnic_83xx_mbx_poll_work);\r\nqueue_delayed_work(adapter->qlcnic_wq, &adapter->mbx_poll_work, 0);\r\n}\r\nvoid qlcnic_83xx_disable_mbx_poll(struct qlcnic_adapter *adapter)\r\n{\r\nif (!test_and_clear_bit(__QLCNIC_MBX_POLL_ENABLE, &adapter->state))\r\nreturn;\r\ncancel_delayed_work_sync(&adapter->mbx_poll_work);\r\n}\r\nstatic int qlcnic_83xx_add_rings(struct qlcnic_adapter *adapter)\r\n{\r\nint index, i, err, sds_mbx_size;\r\nu32 *buf, intrpt_id, intr_mask;\r\nu16 context_id;\r\nu8 num_sds;\r\nstruct qlcnic_cmd_args cmd;\r\nstruct qlcnic_host_sds_ring *sds;\r\nstruct qlcnic_sds_mbx sds_mbx;\r\nstruct qlcnic_add_rings_mbx_out *mbx_out;\r\nstruct qlcnic_recv_context *recv_ctx = adapter->recv_ctx;\r\nstruct qlcnic_hardware_context *ahw = adapter->ahw;\r\nsds_mbx_size = sizeof(struct qlcnic_sds_mbx);\r\ncontext_id = recv_ctx->context_id;\r\nnum_sds = adapter->drv_sds_rings - QLCNIC_MAX_SDS_RINGS;\r\nahw->hw_ops->alloc_mbx_args(&cmd, adapter,\r\nQLCNIC_CMD_ADD_RCV_RINGS);\r\ncmd.req.arg[1] = 0 | (num_sds << 8) | (context_id << 16);\r\nindex = 2;\r\nfor (i = 8; i < adapter->drv_sds_rings; i++) {\r\nmemset(&sds_mbx, 0, sds_mbx_size);\r\nsds = &recv_ctx->sds_rings[i];\r\nsds->consumer = 0;\r\nmemset(sds->desc_head, 0, STATUS_DESC_RINGSIZE(sds));\r\nsds_mbx.phy_addr_low = LSD(sds->phys_addr);\r\nsds_mbx.phy_addr_high = MSD(sds->phys_addr);\r\nsds_mbx.sds_ring_size = sds->num_desc;\r\nif (adapter->flags & QLCNIC_MSIX_ENABLED)\r\nintrpt_id = ahw->intr_tbl[i].id;\r\nelse\r\nintrpt_id = QLCRDX(ahw, QLCNIC_DEF_INT_ID);\r\nif (adapter->ahw->diag_test != QLCNIC_LOOPBACK_TEST)\r\nsds_mbx.intrpt_id = intrpt_id;\r\nelse\r\nsds_mbx.intrpt_id = 0xffff;\r\nsds_mbx.intrpt_val = 0;\r\nbuf = &cmd.req.arg[index];\r\nmemcpy(buf, &sds_mbx, sds_mbx_size);\r\nindex += sds_mbx_size / sizeof(u32);\r\n}\r\nerr = ahw->hw_ops->mbx_cmd(adapter, &cmd);\r\nif (err) {\r\ndev_err(&adapter->pdev->dev,\r\n"Failed to add rings %d\n", err);\r\ngoto out;\r\n}\r\nmbx_out = (struct qlcnic_add_rings_mbx_out *)&cmd.rsp.arg[1];\r\nindex = 0;\r\nfor (i = 8; i < adapter->drv_sds_rings; i++) {\r\nsds = &recv_ctx->sds_rings[i];\r\nsds->crb_sts_consumer = ahw->pci_base0 +\r\nmbx_out->host_csmr[index];\r\nif (adapter->flags & QLCNIC_MSIX_ENABLED)\r\nintr_mask = ahw->intr_tbl[i].src;\r\nelse\r\nintr_mask = QLCRDX(ahw, QLCNIC_DEF_INT_MASK);\r\nsds->crb_intr_mask = ahw->pci_base0 + intr_mask;\r\nindex++;\r\n}\r\nout:\r\nqlcnic_free_mbx_args(&cmd);\r\nreturn err;\r\n}\r\nvoid qlcnic_83xx_del_rx_ctx(struct qlcnic_adapter *adapter)\r\n{\r\nint err;\r\nu32 temp = 0;\r\nstruct qlcnic_cmd_args cmd;\r\nstruct qlcnic_recv_context *recv_ctx = adapter->recv_ctx;\r\nif (qlcnic_alloc_mbx_args(&cmd, adapter, QLCNIC_CMD_DESTROY_RX_CTX))\r\nreturn;\r\nif (qlcnic_sriov_pf_check(adapter) || qlcnic_sriov_vf_check(adapter))\r\ncmd.req.arg[0] |= (0x3 << 29);\r\nif (qlcnic_sriov_pf_check(adapter))\r\nqlcnic_pf_set_interface_id_del_rx_ctx(adapter, &temp);\r\ncmd.req.arg[1] = recv_ctx->context_id | temp;\r\nerr = qlcnic_issue_cmd(adapter, &cmd);\r\nif (err)\r\ndev_err(&adapter->pdev->dev,\r\n"Failed to destroy rx ctx in firmware\n");\r\nrecv_ctx->state = QLCNIC_HOST_CTX_STATE_FREED;\r\nqlcnic_free_mbx_args(&cmd);\r\n}\r\nint qlcnic_83xx_create_rx_ctx(struct qlcnic_adapter *adapter)\r\n{\r\nint i, err, index, sds_mbx_size, rds_mbx_size;\r\nu8 num_sds, num_rds;\r\nu32 *buf, intrpt_id, intr_mask, cap = 0;\r\nstruct qlcnic_host_sds_ring *sds;\r\nstruct qlcnic_host_rds_ring *rds;\r\nstruct qlcnic_sds_mbx sds_mbx;\r\nstruct qlcnic_rds_mbx rds_mbx;\r\nstruct qlcnic_cmd_args cmd;\r\nstruct qlcnic_rcv_mbx_out *mbx_out;\r\nstruct qlcnic_recv_context *recv_ctx = adapter->recv_ctx;\r\nstruct qlcnic_hardware_context *ahw = adapter->ahw;\r\nnum_rds = adapter->max_rds_rings;\r\nif (adapter->drv_sds_rings <= QLCNIC_MAX_SDS_RINGS)\r\nnum_sds = adapter->drv_sds_rings;\r\nelse\r\nnum_sds = QLCNIC_MAX_SDS_RINGS;\r\nsds_mbx_size = sizeof(struct qlcnic_sds_mbx);\r\nrds_mbx_size = sizeof(struct qlcnic_rds_mbx);\r\ncap = QLCNIC_CAP0_LEGACY_CONTEXT;\r\nif (adapter->flags & QLCNIC_FW_LRO_MSS_CAP)\r\ncap |= QLC_83XX_FW_CAP_LRO_MSS;\r\nerr = qlcnic_alloc_mbx_args(&cmd, adapter,\r\nQLCNIC_CMD_CREATE_RX_CTX);\r\nif (err)\r\nreturn err;\r\nif (qlcnic_sriov_pf_check(adapter) || qlcnic_sriov_vf_check(adapter))\r\ncmd.req.arg[0] |= (0x3 << 29);\r\ncmd.req.arg[1] = cap;\r\ncmd.req.arg[5] = 1 | (num_rds << 5) | (num_sds << 8) |\r\n(QLC_83XX_HOST_RDS_MODE_UNIQUE << 16);\r\nif (qlcnic_sriov_pf_check(adapter))\r\nqlcnic_pf_set_interface_id_create_rx_ctx(adapter,\r\n&cmd.req.arg[6]);\r\nindex = QLC_83XX_HOST_SDS_MBX_IDX;\r\nfor (i = 0; i < num_sds; i++) {\r\nmemset(&sds_mbx, 0, sds_mbx_size);\r\nsds = &recv_ctx->sds_rings[i];\r\nsds->consumer = 0;\r\nmemset(sds->desc_head, 0, STATUS_DESC_RINGSIZE(sds));\r\nsds_mbx.phy_addr_low = LSD(sds->phys_addr);\r\nsds_mbx.phy_addr_high = MSD(sds->phys_addr);\r\nsds_mbx.sds_ring_size = sds->num_desc;\r\nif (adapter->flags & QLCNIC_MSIX_ENABLED)\r\nintrpt_id = ahw->intr_tbl[i].id;\r\nelse\r\nintrpt_id = QLCRDX(ahw, QLCNIC_DEF_INT_ID);\r\nif (adapter->ahw->diag_test != QLCNIC_LOOPBACK_TEST)\r\nsds_mbx.intrpt_id = intrpt_id;\r\nelse\r\nsds_mbx.intrpt_id = 0xffff;\r\nsds_mbx.intrpt_val = 0;\r\nbuf = &cmd.req.arg[index];\r\nmemcpy(buf, &sds_mbx, sds_mbx_size);\r\nindex += sds_mbx_size / sizeof(u32);\r\n}\r\nindex = QLCNIC_HOST_RDS_MBX_IDX;\r\nrds = &recv_ctx->rds_rings[0];\r\nrds->producer = 0;\r\nmemset(&rds_mbx, 0, rds_mbx_size);\r\nrds_mbx.phy_addr_reg_low = LSD(rds->phys_addr);\r\nrds_mbx.phy_addr_reg_high = MSD(rds->phys_addr);\r\nrds_mbx.reg_ring_sz = rds->dma_size;\r\nrds_mbx.reg_ring_len = rds->num_desc;\r\nrds = &recv_ctx->rds_rings[1];\r\nrds->producer = 0;\r\nrds_mbx.phy_addr_jmb_low = LSD(rds->phys_addr);\r\nrds_mbx.phy_addr_jmb_high = MSD(rds->phys_addr);\r\nrds_mbx.jmb_ring_sz = rds->dma_size;\r\nrds_mbx.jmb_ring_len = rds->num_desc;\r\nbuf = &cmd.req.arg[index];\r\nmemcpy(buf, &rds_mbx, rds_mbx_size);\r\nerr = ahw->hw_ops->mbx_cmd(adapter, &cmd);\r\nif (err) {\r\ndev_err(&adapter->pdev->dev,\r\n"Failed to create Rx ctx in firmware%d\n", err);\r\ngoto out;\r\n}\r\nmbx_out = (struct qlcnic_rcv_mbx_out *)&cmd.rsp.arg[1];\r\nrecv_ctx->context_id = mbx_out->ctx_id;\r\nrecv_ctx->state = mbx_out->state;\r\nrecv_ctx->virt_port = mbx_out->vport_id;\r\ndev_info(&adapter->pdev->dev, "Rx Context[%d] Created, state:0x%x\n",\r\nrecv_ctx->context_id, recv_ctx->state);\r\nrds = &recv_ctx->rds_rings[0];\r\nrds->crb_rcv_producer = ahw->pci_base0 +\r\nmbx_out->host_prod[0].reg_buf;\r\nrds = &recv_ctx->rds_rings[1];\r\nrds->crb_rcv_producer = ahw->pci_base0 +\r\nmbx_out->host_prod[0].jmb_buf;\r\nfor (i = 0; i < num_sds; i++) {\r\nsds = &recv_ctx->sds_rings[i];\r\nsds->crb_sts_consumer = ahw->pci_base0 +\r\nmbx_out->host_csmr[i];\r\nif (adapter->flags & QLCNIC_MSIX_ENABLED)\r\nintr_mask = ahw->intr_tbl[i].src;\r\nelse\r\nintr_mask = QLCRDX(ahw, QLCNIC_DEF_INT_MASK);\r\nsds->crb_intr_mask = ahw->pci_base0 + intr_mask;\r\n}\r\nif (adapter->drv_sds_rings > QLCNIC_MAX_SDS_RINGS)\r\nerr = qlcnic_83xx_add_rings(adapter);\r\nout:\r\nqlcnic_free_mbx_args(&cmd);\r\nreturn err;\r\n}\r\nvoid qlcnic_83xx_del_tx_ctx(struct qlcnic_adapter *adapter,\r\nstruct qlcnic_host_tx_ring *tx_ring)\r\n{\r\nstruct qlcnic_cmd_args cmd;\r\nu32 temp = 0;\r\nif (qlcnic_alloc_mbx_args(&cmd, adapter, QLCNIC_CMD_DESTROY_TX_CTX))\r\nreturn;\r\nif (qlcnic_sriov_pf_check(adapter) || qlcnic_sriov_vf_check(adapter))\r\ncmd.req.arg[0] |= (0x3 << 29);\r\nif (qlcnic_sriov_pf_check(adapter))\r\nqlcnic_pf_set_interface_id_del_tx_ctx(adapter, &temp);\r\ncmd.req.arg[1] = tx_ring->ctx_id | temp;\r\nif (qlcnic_issue_cmd(adapter, &cmd))\r\ndev_err(&adapter->pdev->dev,\r\n"Failed to destroy tx ctx in firmware\n");\r\nqlcnic_free_mbx_args(&cmd);\r\n}\r\nint qlcnic_83xx_create_tx_ctx(struct qlcnic_adapter *adapter,\r\nstruct qlcnic_host_tx_ring *tx, int ring)\r\n{\r\nint err;\r\nu16 msix_id;\r\nu32 *buf, intr_mask, temp = 0;\r\nstruct qlcnic_cmd_args cmd;\r\nstruct qlcnic_tx_mbx mbx;\r\nstruct qlcnic_tx_mbx_out *mbx_out;\r\nstruct qlcnic_hardware_context *ahw = adapter->ahw;\r\nu32 msix_vector;\r\ntx->producer = 0;\r\ntx->sw_consumer = 0;\r\n*(tx->hw_consumer) = 0;\r\nmemset(&mbx, 0, sizeof(struct qlcnic_tx_mbx));\r\nmbx.phys_addr_low = LSD(tx->phys_addr);\r\nmbx.phys_addr_high = MSD(tx->phys_addr);\r\nmbx.cnsmr_index_low = LSD(tx->hw_cons_phys_addr);\r\nmbx.cnsmr_index_high = MSD(tx->hw_cons_phys_addr);\r\nmbx.size = tx->num_desc;\r\nif (adapter->flags & QLCNIC_MSIX_ENABLED) {\r\nif (!(adapter->flags & QLCNIC_TX_INTR_SHARED))\r\nmsix_vector = adapter->drv_sds_rings + ring;\r\nelse\r\nmsix_vector = adapter->drv_sds_rings - 1;\r\nmsix_id = ahw->intr_tbl[msix_vector].id;\r\n} else {\r\nmsix_id = QLCRDX(ahw, QLCNIC_DEF_INT_ID);\r\n}\r\nif (adapter->ahw->diag_test != QLCNIC_LOOPBACK_TEST)\r\nmbx.intr_id = msix_id;\r\nelse\r\nmbx.intr_id = 0xffff;\r\nmbx.src = 0;\r\nerr = qlcnic_alloc_mbx_args(&cmd, adapter, QLCNIC_CMD_CREATE_TX_CTX);\r\nif (err)\r\nreturn err;\r\nif (qlcnic_sriov_pf_check(adapter) || qlcnic_sriov_vf_check(adapter))\r\ncmd.req.arg[0] |= (0x3 << 29);\r\nif (qlcnic_sriov_pf_check(adapter))\r\nqlcnic_pf_set_interface_id_create_tx_ctx(adapter, &temp);\r\ncmd.req.arg[1] = QLCNIC_CAP0_LEGACY_CONTEXT;\r\ncmd.req.arg[5] = QLCNIC_SINGLE_RING | temp;\r\nbuf = &cmd.req.arg[6];\r\nmemcpy(buf, &mbx, sizeof(struct qlcnic_tx_mbx));\r\nerr = qlcnic_issue_cmd(adapter, &cmd);\r\nif (err) {\r\nnetdev_err(adapter->netdev,\r\n"Failed to create Tx ctx in firmware 0x%x\n", err);\r\ngoto out;\r\n}\r\nmbx_out = (struct qlcnic_tx_mbx_out *)&cmd.rsp.arg[2];\r\ntx->crb_cmd_producer = ahw->pci_base0 + mbx_out->host_prod;\r\ntx->ctx_id = mbx_out->ctx_id;\r\nif ((adapter->flags & QLCNIC_MSIX_ENABLED) &&\r\n!(adapter->flags & QLCNIC_TX_INTR_SHARED)) {\r\nintr_mask = ahw->intr_tbl[adapter->drv_sds_rings + ring].src;\r\ntx->crb_intr_mask = ahw->pci_base0 + intr_mask;\r\n}\r\nnetdev_info(adapter->netdev,\r\n"Tx Context[0x%x] Created, state:0x%x\n",\r\ntx->ctx_id, mbx_out->state);\r\nout:\r\nqlcnic_free_mbx_args(&cmd);\r\nreturn err;\r\n}\r\nstatic int qlcnic_83xx_diag_alloc_res(struct net_device *netdev, int test,\r\nu8 num_sds_ring)\r\n{\r\nstruct qlcnic_adapter *adapter = netdev_priv(netdev);\r\nstruct qlcnic_host_sds_ring *sds_ring;\r\nstruct qlcnic_host_rds_ring *rds_ring;\r\nu16 adapter_state = adapter->is_up;\r\nu8 ring;\r\nint ret;\r\nnetif_device_detach(netdev);\r\nif (netif_running(netdev))\r\n__qlcnic_down(adapter, netdev);\r\nqlcnic_detach(adapter);\r\nadapter->drv_sds_rings = QLCNIC_SINGLE_RING;\r\nadapter->ahw->diag_test = test;\r\nadapter->ahw->linkup = 0;\r\nret = qlcnic_attach(adapter);\r\nif (ret) {\r\nnetif_device_attach(netdev);\r\nreturn ret;\r\n}\r\nret = qlcnic_fw_create_ctx(adapter);\r\nif (ret) {\r\nqlcnic_detach(adapter);\r\nif (adapter_state == QLCNIC_ADAPTER_UP_MAGIC) {\r\nadapter->drv_sds_rings = num_sds_ring;\r\nqlcnic_attach(adapter);\r\n}\r\nnetif_device_attach(netdev);\r\nreturn ret;\r\n}\r\nfor (ring = 0; ring < adapter->max_rds_rings; ring++) {\r\nrds_ring = &adapter->recv_ctx->rds_rings[ring];\r\nqlcnic_post_rx_buffers(adapter, rds_ring, ring);\r\n}\r\nif (adapter->ahw->diag_test == QLCNIC_INTERRUPT_TEST) {\r\nfor (ring = 0; ring < adapter->drv_sds_rings; ring++) {\r\nsds_ring = &adapter->recv_ctx->sds_rings[ring];\r\nqlcnic_enable_sds_intr(adapter, sds_ring);\r\n}\r\n}\r\nif (adapter->ahw->diag_test == QLCNIC_LOOPBACK_TEST) {\r\nadapter->ahw->loopback_state = 0;\r\nadapter->ahw->hw_ops->setup_link_event(adapter, 1);\r\n}\r\nset_bit(__QLCNIC_DEV_UP, &adapter->state);\r\nreturn 0;\r\n}\r\nstatic void qlcnic_83xx_diag_free_res(struct net_device *netdev,\r\nu8 drv_sds_rings)\r\n{\r\nstruct qlcnic_adapter *adapter = netdev_priv(netdev);\r\nstruct qlcnic_host_sds_ring *sds_ring;\r\nint ring;\r\nclear_bit(__QLCNIC_DEV_UP, &adapter->state);\r\nif (adapter->ahw->diag_test == QLCNIC_INTERRUPT_TEST) {\r\nfor (ring = 0; ring < adapter->drv_sds_rings; ring++) {\r\nsds_ring = &adapter->recv_ctx->sds_rings[ring];\r\nif (adapter->flags & QLCNIC_MSIX_ENABLED)\r\nqlcnic_disable_sds_intr(adapter, sds_ring);\r\n}\r\n}\r\nqlcnic_fw_destroy_ctx(adapter);\r\nqlcnic_detach(adapter);\r\nadapter->ahw->diag_test = 0;\r\nadapter->drv_sds_rings = drv_sds_rings;\r\nif (qlcnic_attach(adapter))\r\ngoto out;\r\nif (netif_running(netdev))\r\n__qlcnic_up(adapter, netdev);\r\nout:\r\nnetif_device_attach(netdev);\r\n}\r\nstatic void qlcnic_83xx_get_beacon_state(struct qlcnic_adapter *adapter)\r\n{\r\nstruct qlcnic_hardware_context *ahw = adapter->ahw;\r\nstruct qlcnic_cmd_args cmd;\r\nu8 beacon_state;\r\nint err = 0;\r\nerr = qlcnic_alloc_mbx_args(&cmd, adapter, QLCNIC_CMD_GET_LED_CONFIG);\r\nif (!err) {\r\nerr = qlcnic_issue_cmd(adapter, &cmd);\r\nif (!err) {\r\nbeacon_state = cmd.rsp.arg[4];\r\nif (beacon_state == QLCNIC_BEACON_DISABLE)\r\nahw->beacon_state = QLC_83XX_BEACON_OFF;\r\nelse if (beacon_state == QLC_83XX_ENABLE_BEACON)\r\nahw->beacon_state = QLC_83XX_BEACON_ON;\r\n}\r\n} else {\r\nnetdev_err(adapter->netdev, "Get beacon state failed, err=%d\n",\r\nerr);\r\n}\r\nqlcnic_free_mbx_args(&cmd);\r\nreturn;\r\n}\r\nint qlcnic_83xx_config_led(struct qlcnic_adapter *adapter, u32 state,\r\nu32 beacon)\r\n{\r\nstruct qlcnic_cmd_args cmd;\r\nu32 mbx_in;\r\nint i, status = 0;\r\nif (state) {\r\nstatus = qlcnic_alloc_mbx_args(&cmd, adapter,\r\nQLCNIC_CMD_GET_LED_CONFIG);\r\nif (status)\r\nreturn status;\r\nstatus = qlcnic_issue_cmd(adapter, &cmd);\r\nif (status) {\r\ndev_err(&adapter->pdev->dev,\r\n"Get led config failed.\n");\r\ngoto mbx_err;\r\n} else {\r\nfor (i = 0; i < 4; i++)\r\nadapter->ahw->mbox_reg[i] = cmd.rsp.arg[i+1];\r\n}\r\nqlcnic_free_mbx_args(&cmd);\r\nmbx_in = (LSW(QLC_83XX_LED_CONFIG) << 16) |\r\nLSW(QLC_83XX_LED_CONFIG);\r\nstatus = qlcnic_alloc_mbx_args(&cmd, adapter,\r\nQLCNIC_CMD_SET_LED_CONFIG);\r\nif (status)\r\nreturn status;\r\ncmd.req.arg[1] = mbx_in;\r\ncmd.req.arg[2] = mbx_in;\r\ncmd.req.arg[3] = mbx_in;\r\nif (beacon)\r\ncmd.req.arg[4] = QLC_83XX_ENABLE_BEACON;\r\nstatus = qlcnic_issue_cmd(adapter, &cmd);\r\nif (status) {\r\ndev_err(&adapter->pdev->dev,\r\n"Set led config failed.\n");\r\n}\r\nmbx_err:\r\nqlcnic_free_mbx_args(&cmd);\r\nreturn status;\r\n} else {\r\nstatus = qlcnic_alloc_mbx_args(&cmd, adapter,\r\nQLCNIC_CMD_SET_LED_CONFIG);\r\nif (status)\r\nreturn status;\r\ncmd.req.arg[1] = adapter->ahw->mbox_reg[0];\r\ncmd.req.arg[2] = adapter->ahw->mbox_reg[1];\r\ncmd.req.arg[3] = adapter->ahw->mbox_reg[2];\r\nif (beacon)\r\ncmd.req.arg[4] = adapter->ahw->mbox_reg[3];\r\nstatus = qlcnic_issue_cmd(adapter, &cmd);\r\nif (status)\r\ndev_err(&adapter->pdev->dev,\r\n"Restoring led config failed.\n");\r\nqlcnic_free_mbx_args(&cmd);\r\nreturn status;\r\n}\r\n}\r\nint qlcnic_83xx_set_led(struct net_device *netdev,\r\nenum ethtool_phys_id_state state)\r\n{\r\nstruct qlcnic_adapter *adapter = netdev_priv(netdev);\r\nint err = -EIO, active = 1;\r\nif (adapter->ahw->op_mode == QLCNIC_NON_PRIV_FUNC) {\r\nnetdev_warn(netdev,\r\n"LED test is not supported in non-privileged mode\n");\r\nreturn -EOPNOTSUPP;\r\n}\r\nswitch (state) {\r\ncase ETHTOOL_ID_ACTIVE:\r\nif (test_and_set_bit(__QLCNIC_LED_ENABLE, &adapter->state))\r\nreturn -EBUSY;\r\nif (test_bit(__QLCNIC_RESETTING, &adapter->state))\r\nbreak;\r\nerr = qlcnic_83xx_config_led(adapter, active, 0);\r\nif (err)\r\nnetdev_err(netdev, "Failed to set LED blink state\n");\r\nbreak;\r\ncase ETHTOOL_ID_INACTIVE:\r\nactive = 0;\r\nif (test_bit(__QLCNIC_RESETTING, &adapter->state))\r\nbreak;\r\nerr = qlcnic_83xx_config_led(adapter, active, 0);\r\nif (err)\r\nnetdev_err(netdev, "Failed to reset LED blink state\n");\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nif (!active || err)\r\nclear_bit(__QLCNIC_LED_ENABLE, &adapter->state);\r\nreturn err;\r\n}\r\nvoid qlcnic_83xx_initialize_nic(struct qlcnic_adapter *adapter, int enable)\r\n{\r\nstruct qlcnic_cmd_args cmd;\r\nint status;\r\nif (qlcnic_sriov_vf_check(adapter))\r\nreturn;\r\nif (enable)\r\nstatus = qlcnic_alloc_mbx_args(&cmd, adapter,\r\nQLCNIC_CMD_INIT_NIC_FUNC);\r\nelse\r\nstatus = qlcnic_alloc_mbx_args(&cmd, adapter,\r\nQLCNIC_CMD_STOP_NIC_FUNC);\r\nif (status)\r\nreturn;\r\ncmd.req.arg[1] = QLC_REGISTER_LB_IDC | QLC_INIT_FW_RESOURCES;\r\nif (adapter->dcb)\r\ncmd.req.arg[1] |= QLC_REGISTER_DCB_AEN;\r\nstatus = qlcnic_issue_cmd(adapter, &cmd);\r\nif (status)\r\ndev_err(&adapter->pdev->dev,\r\n"Failed to %s in NIC IDC function event.\n",\r\n(enable ? "register" : "unregister"));\r\nqlcnic_free_mbx_args(&cmd);\r\n}\r\nstatic int qlcnic_83xx_set_port_config(struct qlcnic_adapter *adapter)\r\n{\r\nstruct qlcnic_cmd_args cmd;\r\nint err;\r\nerr = qlcnic_alloc_mbx_args(&cmd, adapter, QLCNIC_CMD_SET_PORT_CONFIG);\r\nif (err)\r\nreturn err;\r\ncmd.req.arg[1] = adapter->ahw->port_config;\r\nerr = qlcnic_issue_cmd(adapter, &cmd);\r\nif (err)\r\ndev_info(&adapter->pdev->dev, "Set Port Config failed.\n");\r\nqlcnic_free_mbx_args(&cmd);\r\nreturn err;\r\n}\r\nstatic int qlcnic_83xx_get_port_config(struct qlcnic_adapter *adapter)\r\n{\r\nstruct qlcnic_cmd_args cmd;\r\nint err;\r\nerr = qlcnic_alloc_mbx_args(&cmd, adapter, QLCNIC_CMD_GET_PORT_CONFIG);\r\nif (err)\r\nreturn err;\r\nerr = qlcnic_issue_cmd(adapter, &cmd);\r\nif (err)\r\ndev_info(&adapter->pdev->dev, "Get Port config failed\n");\r\nelse\r\nadapter->ahw->port_config = cmd.rsp.arg[1];\r\nqlcnic_free_mbx_args(&cmd);\r\nreturn err;\r\n}\r\nint qlcnic_83xx_setup_link_event(struct qlcnic_adapter *adapter, int enable)\r\n{\r\nint err;\r\nu32 temp;\r\nstruct qlcnic_cmd_args cmd;\r\nerr = qlcnic_alloc_mbx_args(&cmd, adapter, QLCNIC_CMD_GET_LINK_EVENT);\r\nif (err)\r\nreturn err;\r\ntemp = adapter->recv_ctx->context_id << 16;\r\ncmd.req.arg[1] = (enable ? 1 : 0) | BIT_8 | temp;\r\nerr = qlcnic_issue_cmd(adapter, &cmd);\r\nif (err)\r\ndev_info(&adapter->pdev->dev,\r\n"Setup linkevent mailbox failed\n");\r\nqlcnic_free_mbx_args(&cmd);\r\nreturn err;\r\n}\r\nstatic void qlcnic_83xx_set_interface_id_promisc(struct qlcnic_adapter *adapter,\r\nu32 *interface_id)\r\n{\r\nif (qlcnic_sriov_pf_check(adapter)) {\r\nqlcnic_alloc_lb_filters_mem(adapter);\r\nqlcnic_pf_set_interface_id_promisc(adapter, interface_id);\r\nadapter->rx_mac_learn = true;\r\n} else {\r\nif (!qlcnic_sriov_vf_check(adapter))\r\n*interface_id = adapter->recv_ctx->context_id << 16;\r\n}\r\n}\r\nint qlcnic_83xx_nic_set_promisc(struct qlcnic_adapter *adapter, u32 mode)\r\n{\r\nstruct qlcnic_cmd_args *cmd = NULL;\r\nu32 temp = 0;\r\nint err;\r\nif (adapter->recv_ctx->state == QLCNIC_HOST_CTX_STATE_FREED)\r\nreturn -EIO;\r\ncmd = kzalloc(sizeof(*cmd), GFP_ATOMIC);\r\nif (!cmd)\r\nreturn -ENOMEM;\r\nerr = qlcnic_alloc_mbx_args(cmd, adapter,\r\nQLCNIC_CMD_CONFIGURE_MAC_RX_MODE);\r\nif (err)\r\ngoto out;\r\ncmd->type = QLC_83XX_MBX_CMD_NO_WAIT;\r\nqlcnic_83xx_set_interface_id_promisc(adapter, &temp);\r\nif (qlcnic_84xx_check(adapter) && qlcnic_sriov_pf_check(adapter))\r\nmode = VPORT_MISS_MODE_ACCEPT_ALL;\r\ncmd->req.arg[1] = mode | temp;\r\nerr = qlcnic_issue_cmd(adapter, cmd);\r\nif (!err)\r\nreturn err;\r\nqlcnic_free_mbx_args(cmd);\r\nout:\r\nkfree(cmd);\r\nreturn err;\r\n}\r\nint qlcnic_83xx_loopback_test(struct net_device *netdev, u8 mode)\r\n{\r\nstruct qlcnic_adapter *adapter = netdev_priv(netdev);\r\nstruct qlcnic_hardware_context *ahw = adapter->ahw;\r\nu8 drv_sds_rings = adapter->drv_sds_rings;\r\nu8 drv_tx_rings = adapter->drv_tx_rings;\r\nint ret = 0, loop = 0;\r\nif (ahw->op_mode == QLCNIC_NON_PRIV_FUNC) {\r\nnetdev_warn(netdev,\r\n"Loopback test not supported in non privileged mode\n");\r\nreturn -ENOTSUPP;\r\n}\r\nif (test_bit(__QLCNIC_RESETTING, &adapter->state)) {\r\nnetdev_info(netdev, "Device is resetting\n");\r\nreturn -EBUSY;\r\n}\r\nif (qlcnic_get_diag_lock(adapter)) {\r\nnetdev_info(netdev, "Device is in diagnostics mode\n");\r\nreturn -EBUSY;\r\n}\r\nnetdev_info(netdev, "%s loopback test in progress\n",\r\nmode == QLCNIC_ILB_MODE ? "internal" : "external");\r\nret = qlcnic_83xx_diag_alloc_res(netdev, QLCNIC_LOOPBACK_TEST,\r\ndrv_sds_rings);\r\nif (ret)\r\ngoto fail_diag_alloc;\r\nret = qlcnic_83xx_set_lb_mode(adapter, mode);\r\nif (ret)\r\ngoto free_diag_res;\r\ndo {\r\nmsleep(QLC_83XX_LB_MSLEEP_COUNT);\r\nif (test_bit(__QLCNIC_RESETTING, &adapter->state)) {\r\nnetdev_info(netdev,\r\n"Device is resetting, free LB test resources\n");\r\nret = -EBUSY;\r\ngoto free_diag_res;\r\n}\r\nif (loop++ > QLC_83XX_LB_WAIT_COUNT) {\r\nnetdev_info(netdev,\r\n"Firmware didn't sent link up event to loopback request\n");\r\nret = -ETIMEDOUT;\r\nqlcnic_83xx_clear_lb_mode(adapter, mode);\r\ngoto free_diag_res;\r\n}\r\n} while ((adapter->ahw->linkup && ahw->has_link_events) != 1);\r\nret = qlcnic_do_lb_test(adapter, mode);\r\nqlcnic_83xx_clear_lb_mode(adapter, mode);\r\nfree_diag_res:\r\nqlcnic_83xx_diag_free_res(netdev, drv_sds_rings);\r\nfail_diag_alloc:\r\nadapter->drv_sds_rings = drv_sds_rings;\r\nadapter->drv_tx_rings = drv_tx_rings;\r\nqlcnic_release_diag_lock(adapter);\r\nreturn ret;\r\n}\r\nstatic void qlcnic_extend_lb_idc_cmpltn_wait(struct qlcnic_adapter *adapter,\r\nu32 *max_wait_count)\r\n{\r\nstruct qlcnic_hardware_context *ahw = adapter->ahw;\r\nint temp;\r\nnetdev_info(adapter->netdev, "Received loopback IDC time extend event for 0x%x seconds\n",\r\nahw->extend_lb_time);\r\ntemp = ahw->extend_lb_time * 1000;\r\n*max_wait_count += temp / QLC_83XX_LB_MSLEEP_COUNT;\r\nahw->extend_lb_time = 0;\r\n}\r\nstatic int qlcnic_83xx_set_lb_mode(struct qlcnic_adapter *adapter, u8 mode)\r\n{\r\nstruct qlcnic_hardware_context *ahw = adapter->ahw;\r\nstruct net_device *netdev = adapter->netdev;\r\nu32 config, max_wait_count;\r\nint status = 0, loop = 0;\r\nahw->extend_lb_time = 0;\r\nmax_wait_count = QLC_83XX_LB_WAIT_COUNT;\r\nstatus = qlcnic_83xx_get_port_config(adapter);\r\nif (status)\r\nreturn status;\r\nconfig = ahw->port_config;\r\nif ((config & QLC_83XX_CFG_LOOPBACK_HSS) ||\r\n(config & QLC_83XX_CFG_LOOPBACK_EXT)) {\r\nnetdev_err(netdev,\r\n"Port already in Loopback mode.\n");\r\nreturn -EINPROGRESS;\r\n}\r\nset_bit(QLC_83XX_IDC_COMP_AEN, &ahw->idc.status);\r\nif (mode == QLCNIC_ILB_MODE)\r\nahw->port_config |= QLC_83XX_CFG_LOOPBACK_HSS;\r\nif (mode == QLCNIC_ELB_MODE)\r\nahw->port_config |= QLC_83XX_CFG_LOOPBACK_EXT;\r\nstatus = qlcnic_83xx_set_port_config(adapter);\r\nif (status) {\r\nnetdev_err(netdev,\r\n"Failed to Set Loopback Mode = 0x%x.\n",\r\nahw->port_config);\r\nahw->port_config = config;\r\nclear_bit(QLC_83XX_IDC_COMP_AEN, &ahw->idc.status);\r\nreturn status;\r\n}\r\ndo {\r\nmsleep(QLC_83XX_LB_MSLEEP_COUNT);\r\nif (test_bit(__QLCNIC_RESETTING, &adapter->state)) {\r\nnetdev_info(netdev,\r\n"Device is resetting, free LB test resources\n");\r\nclear_bit(QLC_83XX_IDC_COMP_AEN, &ahw->idc.status);\r\nreturn -EBUSY;\r\n}\r\nif (ahw->extend_lb_time)\r\nqlcnic_extend_lb_idc_cmpltn_wait(adapter,\r\n&max_wait_count);\r\nif (loop++ > max_wait_count) {\r\nnetdev_err(netdev, "%s: Did not receive loopback IDC completion AEN\n",\r\n__func__);\r\nclear_bit(QLC_83XX_IDC_COMP_AEN, &ahw->idc.status);\r\nqlcnic_83xx_clear_lb_mode(adapter, mode);\r\nreturn -ETIMEDOUT;\r\n}\r\n} while (test_bit(QLC_83XX_IDC_COMP_AEN, &ahw->idc.status));\r\nqlcnic_sre_macaddr_change(adapter, adapter->mac_addr, 0,\r\nQLCNIC_MAC_ADD);\r\nreturn status;\r\n}\r\nstatic int qlcnic_83xx_clear_lb_mode(struct qlcnic_adapter *adapter, u8 mode)\r\n{\r\nstruct qlcnic_hardware_context *ahw = adapter->ahw;\r\nu32 config = ahw->port_config, max_wait_count;\r\nstruct net_device *netdev = adapter->netdev;\r\nint status = 0, loop = 0;\r\nahw->extend_lb_time = 0;\r\nmax_wait_count = QLC_83XX_LB_WAIT_COUNT;\r\nset_bit(QLC_83XX_IDC_COMP_AEN, &ahw->idc.status);\r\nif (mode == QLCNIC_ILB_MODE)\r\nahw->port_config &= ~QLC_83XX_CFG_LOOPBACK_HSS;\r\nif (mode == QLCNIC_ELB_MODE)\r\nahw->port_config &= ~QLC_83XX_CFG_LOOPBACK_EXT;\r\nstatus = qlcnic_83xx_set_port_config(adapter);\r\nif (status) {\r\nnetdev_err(netdev,\r\n"Failed to Clear Loopback Mode = 0x%x.\n",\r\nahw->port_config);\r\nahw->port_config = config;\r\nclear_bit(QLC_83XX_IDC_COMP_AEN, &ahw->idc.status);\r\nreturn status;\r\n}\r\ndo {\r\nmsleep(QLC_83XX_LB_MSLEEP_COUNT);\r\nif (test_bit(__QLCNIC_RESETTING, &adapter->state)) {\r\nnetdev_info(netdev,\r\n"Device is resetting, free LB test resources\n");\r\nclear_bit(QLC_83XX_IDC_COMP_AEN, &ahw->idc.status);\r\nreturn -EBUSY;\r\n}\r\nif (ahw->extend_lb_time)\r\nqlcnic_extend_lb_idc_cmpltn_wait(adapter,\r\n&max_wait_count);\r\nif (loop++ > max_wait_count) {\r\nnetdev_err(netdev, "%s: Did not receive loopback IDC completion AEN\n",\r\n__func__);\r\nclear_bit(QLC_83XX_IDC_COMP_AEN, &ahw->idc.status);\r\nreturn -ETIMEDOUT;\r\n}\r\n} while (test_bit(QLC_83XX_IDC_COMP_AEN, &ahw->idc.status));\r\nqlcnic_sre_macaddr_change(adapter, adapter->mac_addr, 0,\r\nQLCNIC_MAC_DEL);\r\nreturn status;\r\n}\r\nstatic void qlcnic_83xx_set_interface_id_ipaddr(struct qlcnic_adapter *adapter,\r\nu32 *interface_id)\r\n{\r\nif (qlcnic_sriov_pf_check(adapter)) {\r\nqlcnic_pf_set_interface_id_ipaddr(adapter, interface_id);\r\n} else {\r\nif (!qlcnic_sriov_vf_check(adapter))\r\n*interface_id = adapter->recv_ctx->context_id << 16;\r\n}\r\n}\r\nvoid qlcnic_83xx_config_ipaddr(struct qlcnic_adapter *adapter, __be32 ip,\r\nint mode)\r\n{\r\nint err;\r\nu32 temp = 0, temp_ip;\r\nstruct qlcnic_cmd_args cmd;\r\nerr = qlcnic_alloc_mbx_args(&cmd, adapter,\r\nQLCNIC_CMD_CONFIGURE_IP_ADDR);\r\nif (err)\r\nreturn;\r\nqlcnic_83xx_set_interface_id_ipaddr(adapter, &temp);\r\nif (mode == QLCNIC_IP_UP)\r\ncmd.req.arg[1] = 1 | temp;\r\nelse\r\ncmd.req.arg[1] = 2 | temp;\r\ntemp_ip = swab32(ntohl(ip));\r\nmemcpy(&cmd.req.arg[2], &temp_ip, sizeof(u32));\r\nerr = qlcnic_issue_cmd(adapter, &cmd);\r\nif (err != QLCNIC_RCODE_SUCCESS)\r\ndev_err(&adapter->netdev->dev,\r\n"could not notify %s IP 0x%x request\n",\r\n(mode == QLCNIC_IP_UP) ? "Add" : "Remove", ip);\r\nqlcnic_free_mbx_args(&cmd);\r\n}\r\nint qlcnic_83xx_config_hw_lro(struct qlcnic_adapter *adapter, int mode)\r\n{\r\nint err;\r\nu32 temp, arg1;\r\nstruct qlcnic_cmd_args cmd;\r\nint lro_bit_mask;\r\nlro_bit_mask = (mode ? (BIT_0 | BIT_1 | BIT_2 | BIT_3) : 0);\r\nif (adapter->recv_ctx->state == QLCNIC_HOST_CTX_STATE_FREED)\r\nreturn 0;\r\nerr = qlcnic_alloc_mbx_args(&cmd, adapter, QLCNIC_CMD_CONFIGURE_HW_LRO);\r\nif (err)\r\nreturn err;\r\ntemp = adapter->recv_ctx->context_id << 16;\r\narg1 = lro_bit_mask | temp;\r\ncmd.req.arg[1] = arg1;\r\nerr = qlcnic_issue_cmd(adapter, &cmd);\r\nif (err)\r\ndev_info(&adapter->pdev->dev, "LRO config failed\n");\r\nqlcnic_free_mbx_args(&cmd);\r\nreturn err;\r\n}\r\nint qlcnic_83xx_config_rss(struct qlcnic_adapter *adapter, int enable)\r\n{\r\nint err;\r\nu32 word;\r\nstruct qlcnic_cmd_args cmd;\r\nconst u64 key[] = { 0xbeac01fa6a42b73bULL, 0x8030f20c77cb2da3ULL,\r\n0xae7b30b4d0ca2bcbULL, 0x43a38fb04167253dULL,\r\n0x255b0ec26d5a56daULL };\r\nerr = qlcnic_alloc_mbx_args(&cmd, adapter, QLCNIC_CMD_CONFIGURE_RSS);\r\nif (err)\r\nreturn err;\r\nword = ((u32)(RSS_HASHTYPE_IP_TCP & 0x3) << 4) |\r\n((u32)(RSS_HASHTYPE_IP_TCP & 0x3) << 6) |\r\n((u32)(enable & 0x1) << 8) |\r\n((0x7ULL) << 16);\r\ncmd.req.arg[1] = (adapter->recv_ctx->context_id);\r\ncmd.req.arg[2] = word;\r\nmemcpy(&cmd.req.arg[4], key, sizeof(key));\r\nerr = qlcnic_issue_cmd(adapter, &cmd);\r\nif (err)\r\ndev_info(&adapter->pdev->dev, "RSS config failed\n");\r\nqlcnic_free_mbx_args(&cmd);\r\nreturn err;\r\n}\r\nstatic void qlcnic_83xx_set_interface_id_macaddr(struct qlcnic_adapter *adapter,\r\nu32 *interface_id)\r\n{\r\nif (qlcnic_sriov_pf_check(adapter)) {\r\nqlcnic_pf_set_interface_id_macaddr(adapter, interface_id);\r\n} else {\r\nif (!qlcnic_sriov_vf_check(adapter))\r\n*interface_id = adapter->recv_ctx->context_id << 16;\r\n}\r\n}\r\nint qlcnic_83xx_sre_macaddr_change(struct qlcnic_adapter *adapter, u8 *addr,\r\nu16 vlan_id, u8 op)\r\n{\r\nstruct qlcnic_cmd_args *cmd = NULL;\r\nstruct qlcnic_macvlan_mbx mv;\r\nu32 *buf, temp = 0;\r\nint err;\r\nif (adapter->recv_ctx->state == QLCNIC_HOST_CTX_STATE_FREED)\r\nreturn -EIO;\r\ncmd = kzalloc(sizeof(*cmd), GFP_ATOMIC);\r\nif (!cmd)\r\nreturn -ENOMEM;\r\nerr = qlcnic_alloc_mbx_args(cmd, adapter, QLCNIC_CMD_CONFIG_MAC_VLAN);\r\nif (err)\r\ngoto out;\r\ncmd->type = QLC_83XX_MBX_CMD_NO_WAIT;\r\nif (vlan_id)\r\nop = (op == QLCNIC_MAC_ADD || op == QLCNIC_MAC_VLAN_ADD) ?\r\nQLCNIC_MAC_VLAN_ADD : QLCNIC_MAC_VLAN_DEL;\r\ncmd->req.arg[1] = op | (1 << 8);\r\nqlcnic_83xx_set_interface_id_macaddr(adapter, &temp);\r\ncmd->req.arg[1] |= temp;\r\nmv.vlan = vlan_id;\r\nmv.mac_addr0 = addr[0];\r\nmv.mac_addr1 = addr[1];\r\nmv.mac_addr2 = addr[2];\r\nmv.mac_addr3 = addr[3];\r\nmv.mac_addr4 = addr[4];\r\nmv.mac_addr5 = addr[5];\r\nbuf = &cmd->req.arg[2];\r\nmemcpy(buf, &mv, sizeof(struct qlcnic_macvlan_mbx));\r\nerr = qlcnic_issue_cmd(adapter, cmd);\r\nif (!err)\r\nreturn err;\r\nqlcnic_free_mbx_args(cmd);\r\nout:\r\nkfree(cmd);\r\nreturn err;\r\n}\r\nvoid qlcnic_83xx_change_l2_filter(struct qlcnic_adapter *adapter, u64 *addr,\r\nu16 vlan_id)\r\n{\r\nu8 mac[ETH_ALEN];\r\nmemcpy(&mac, addr, ETH_ALEN);\r\nqlcnic_83xx_sre_macaddr_change(adapter, mac, vlan_id, QLCNIC_MAC_ADD);\r\n}\r\nstatic void qlcnic_83xx_configure_mac(struct qlcnic_adapter *adapter, u8 *mac,\r\nu8 type, struct qlcnic_cmd_args *cmd)\r\n{\r\nswitch (type) {\r\ncase QLCNIC_SET_STATION_MAC:\r\ncase QLCNIC_SET_FAC_DEF_MAC:\r\nmemcpy(&cmd->req.arg[2], mac, sizeof(u32));\r\nmemcpy(&cmd->req.arg[3], &mac[4], sizeof(u16));\r\nbreak;\r\n}\r\ncmd->req.arg[1] = type;\r\n}\r\nint qlcnic_83xx_get_mac_address(struct qlcnic_adapter *adapter, u8 *mac,\r\nu8 function)\r\n{\r\nint err, i;\r\nstruct qlcnic_cmd_args cmd;\r\nu32 mac_low, mac_high;\r\nfunction = 0;\r\nerr = qlcnic_alloc_mbx_args(&cmd, adapter, QLCNIC_CMD_MAC_ADDRESS);\r\nif (err)\r\nreturn err;\r\nqlcnic_83xx_configure_mac(adapter, mac, QLCNIC_GET_CURRENT_MAC, &cmd);\r\nerr = qlcnic_issue_cmd(adapter, &cmd);\r\nif (err == QLCNIC_RCODE_SUCCESS) {\r\nmac_low = cmd.rsp.arg[1];\r\nmac_high = cmd.rsp.arg[2];\r\nfor (i = 0; i < 2; i++)\r\nmac[i] = (u8) (mac_high >> ((1 - i) * 8));\r\nfor (i = 2; i < 6; i++)\r\nmac[i] = (u8) (mac_low >> ((5 - i) * 8));\r\n} else {\r\ndev_err(&adapter->pdev->dev, "Failed to get mac address%d\n",\r\nerr);\r\nerr = -EIO;\r\n}\r\nqlcnic_free_mbx_args(&cmd);\r\nreturn err;\r\n}\r\nstatic int qlcnic_83xx_set_rx_intr_coal(struct qlcnic_adapter *adapter)\r\n{\r\nstruct qlcnic_nic_intr_coalesce *coal = &adapter->ahw->coal;\r\nstruct qlcnic_cmd_args cmd;\r\nu16 temp;\r\nint err;\r\nerr = qlcnic_alloc_mbx_args(&cmd, adapter, QLCNIC_CMD_CONFIG_INTR_COAL);\r\nif (err)\r\nreturn err;\r\ntemp = adapter->recv_ctx->context_id;\r\ncmd.req.arg[1] = QLCNIC_INTR_COAL_TYPE_RX | temp << 16;\r\ntemp = coal->rx_time_us;\r\ncmd.req.arg[2] = coal->rx_packets | temp << 16;\r\ncmd.req.arg[3] = coal->flag;\r\nerr = qlcnic_issue_cmd(adapter, &cmd);\r\nif (err != QLCNIC_RCODE_SUCCESS)\r\nnetdev_err(adapter->netdev,\r\n"failed to set interrupt coalescing parameters\n");\r\nqlcnic_free_mbx_args(&cmd);\r\nreturn err;\r\n}\r\nstatic int qlcnic_83xx_set_tx_intr_coal(struct qlcnic_adapter *adapter)\r\n{\r\nstruct qlcnic_nic_intr_coalesce *coal = &adapter->ahw->coal;\r\nstruct qlcnic_cmd_args cmd;\r\nu16 temp;\r\nint err;\r\nerr = qlcnic_alloc_mbx_args(&cmd, adapter, QLCNIC_CMD_CONFIG_INTR_COAL);\r\nif (err)\r\nreturn err;\r\ntemp = adapter->tx_ring->ctx_id;\r\ncmd.req.arg[1] = QLCNIC_INTR_COAL_TYPE_TX | temp << 16;\r\ntemp = coal->tx_time_us;\r\ncmd.req.arg[2] = coal->tx_packets | temp << 16;\r\ncmd.req.arg[3] = coal->flag;\r\nerr = qlcnic_issue_cmd(adapter, &cmd);\r\nif (err != QLCNIC_RCODE_SUCCESS)\r\nnetdev_err(adapter->netdev,\r\n"failed to set interrupt coalescing parameters\n");\r\nqlcnic_free_mbx_args(&cmd);\r\nreturn err;\r\n}\r\nint qlcnic_83xx_set_rx_tx_intr_coal(struct qlcnic_adapter *adapter)\r\n{\r\nint err = 0;\r\nerr = qlcnic_83xx_set_rx_intr_coal(adapter);\r\nif (err)\r\nnetdev_err(adapter->netdev,\r\n"failed to set Rx coalescing parameters\n");\r\nerr = qlcnic_83xx_set_tx_intr_coal(adapter);\r\nif (err)\r\nnetdev_err(adapter->netdev,\r\n"failed to set Tx coalescing parameters\n");\r\nreturn err;\r\n}\r\nint qlcnic_83xx_config_intr_coal(struct qlcnic_adapter *adapter,\r\nstruct ethtool_coalesce *ethcoal)\r\n{\r\nstruct qlcnic_nic_intr_coalesce *coal = &adapter->ahw->coal;\r\nu32 rx_coalesce_usecs, rx_max_frames;\r\nu32 tx_coalesce_usecs, tx_max_frames;\r\nint err;\r\nif (adapter->recv_ctx->state == QLCNIC_HOST_CTX_STATE_FREED)\r\nreturn -EIO;\r\ntx_coalesce_usecs = ethcoal->tx_coalesce_usecs;\r\ntx_max_frames = ethcoal->tx_max_coalesced_frames;\r\nrx_coalesce_usecs = ethcoal->rx_coalesce_usecs;\r\nrx_max_frames = ethcoal->rx_max_coalesced_frames;\r\ncoal->flag = QLCNIC_INTR_DEFAULT;\r\nif ((coal->rx_time_us == rx_coalesce_usecs) &&\r\n(coal->rx_packets == rx_max_frames)) {\r\ncoal->type = QLCNIC_INTR_COAL_TYPE_TX;\r\ncoal->tx_time_us = tx_coalesce_usecs;\r\ncoal->tx_packets = tx_max_frames;\r\n} else if ((coal->tx_time_us == tx_coalesce_usecs) &&\r\n(coal->tx_packets == tx_max_frames)) {\r\ncoal->type = QLCNIC_INTR_COAL_TYPE_RX;\r\ncoal->rx_time_us = rx_coalesce_usecs;\r\ncoal->rx_packets = rx_max_frames;\r\n} else {\r\ncoal->type = QLCNIC_INTR_COAL_TYPE_RX_TX;\r\ncoal->rx_time_us = rx_coalesce_usecs;\r\ncoal->rx_packets = rx_max_frames;\r\ncoal->tx_time_us = tx_coalesce_usecs;\r\ncoal->tx_packets = tx_max_frames;\r\n}\r\nswitch (coal->type) {\r\ncase QLCNIC_INTR_COAL_TYPE_RX:\r\nerr = qlcnic_83xx_set_rx_intr_coal(adapter);\r\nbreak;\r\ncase QLCNIC_INTR_COAL_TYPE_TX:\r\nerr = qlcnic_83xx_set_tx_intr_coal(adapter);\r\nbreak;\r\ncase QLCNIC_INTR_COAL_TYPE_RX_TX:\r\nerr = qlcnic_83xx_set_rx_tx_intr_coal(adapter);\r\nbreak;\r\ndefault:\r\nerr = -EINVAL;\r\nnetdev_err(adapter->netdev,\r\n"Invalid Interrupt coalescing type\n");\r\nbreak;\r\n}\r\nreturn err;\r\n}\r\nstatic void qlcnic_83xx_handle_link_aen(struct qlcnic_adapter *adapter,\r\nu32 data[])\r\n{\r\nstruct qlcnic_hardware_context *ahw = adapter->ahw;\r\nu8 link_status, duplex;\r\nlink_status = LSB(data[3]) & 1;\r\nif (link_status) {\r\nahw->link_speed = MSW(data[2]);\r\nduplex = LSB(MSW(data[3]));\r\nif (duplex)\r\nahw->link_duplex = DUPLEX_FULL;\r\nelse\r\nahw->link_duplex = DUPLEX_HALF;\r\n} else {\r\nahw->link_speed = SPEED_UNKNOWN;\r\nahw->link_duplex = DUPLEX_UNKNOWN;\r\n}\r\nahw->link_autoneg = MSB(MSW(data[3]));\r\nahw->module_type = MSB(LSW(data[3]));\r\nahw->has_link_events = 1;\r\nahw->lb_mode = data[4] & QLCNIC_LB_MODE_MASK;\r\nqlcnic_advert_link_change(adapter, link_status);\r\n}\r\nstatic irqreturn_t qlcnic_83xx_handle_aen(int irq, void *data)\r\n{\r\nstruct qlcnic_adapter *adapter = data;\r\nstruct qlcnic_mailbox *mbx;\r\nu32 mask, resp, event;\r\nunsigned long flags;\r\nmbx = adapter->ahw->mailbox;\r\nspin_lock_irqsave(&mbx->aen_lock, flags);\r\nresp = QLCRDX(adapter->ahw, QLCNIC_FW_MBX_CTRL);\r\nif (!(resp & QLCNIC_SET_OWNER))\r\ngoto out;\r\nevent = readl(QLCNIC_MBX_FW(adapter->ahw, 0));\r\nif (event & QLCNIC_MBX_ASYNC_EVENT)\r\n__qlcnic_83xx_process_aen(adapter);\r\nelse\r\nqlcnic_83xx_notify_mbx_response(mbx);\r\nout:\r\nmask = QLCRDX(adapter->ahw, QLCNIC_DEF_INT_MASK);\r\nwritel(0, adapter->ahw->pci_base0 + mask);\r\nspin_unlock_irqrestore(&mbx->aen_lock, flags);\r\nreturn IRQ_HANDLED;\r\n}\r\nint qlcnic_83xx_set_nic_info(struct qlcnic_adapter *adapter,\r\nstruct qlcnic_info *nic)\r\n{\r\nint i, err = -EIO;\r\nstruct qlcnic_cmd_args cmd;\r\nif (adapter->ahw->op_mode != QLCNIC_MGMT_FUNC) {\r\ndev_err(&adapter->pdev->dev,\r\n"%s: Error, invoked by non management func\n",\r\n__func__);\r\nreturn err;\r\n}\r\nerr = qlcnic_alloc_mbx_args(&cmd, adapter, QLCNIC_CMD_SET_NIC_INFO);\r\nif (err)\r\nreturn err;\r\ncmd.req.arg[1] = (nic->pci_func << 16);\r\ncmd.req.arg[2] = 0x1 << 16;\r\ncmd.req.arg[3] = nic->phys_port | (nic->switch_mode << 16);\r\ncmd.req.arg[4] = nic->capabilities;\r\ncmd.req.arg[5] = (nic->max_mac_filters & 0xFF) | ((nic->max_mtu) << 16);\r\ncmd.req.arg[6] = (nic->max_tx_ques) | ((nic->max_rx_ques) << 16);\r\ncmd.req.arg[7] = (nic->min_tx_bw) | ((nic->max_tx_bw) << 16);\r\nfor (i = 8; i < 32; i++)\r\ncmd.req.arg[i] = 0;\r\nerr = qlcnic_issue_cmd(adapter, &cmd);\r\nif (err != QLCNIC_RCODE_SUCCESS) {\r\ndev_err(&adapter->pdev->dev, "Failed to set nic info%d\n",\r\nerr);\r\nerr = -EIO;\r\n}\r\nqlcnic_free_mbx_args(&cmd);\r\nreturn err;\r\n}\r\nint qlcnic_83xx_get_nic_info(struct qlcnic_adapter *adapter,\r\nstruct qlcnic_info *npar_info, u8 func_id)\r\n{\r\nint err;\r\nu32 temp;\r\nu8 op = 0;\r\nstruct qlcnic_cmd_args cmd;\r\nstruct qlcnic_hardware_context *ahw = adapter->ahw;\r\nerr = qlcnic_alloc_mbx_args(&cmd, adapter, QLCNIC_CMD_GET_NIC_INFO);\r\nif (err)\r\nreturn err;\r\nif (func_id != ahw->pci_func) {\r\ntemp = func_id << 16;\r\ncmd.req.arg[1] = op | BIT_31 | temp;\r\n} else {\r\ncmd.req.arg[1] = ahw->pci_func << 16;\r\n}\r\nerr = qlcnic_issue_cmd(adapter, &cmd);\r\nif (err) {\r\ndev_info(&adapter->pdev->dev,\r\n"Failed to get nic info %d\n", err);\r\ngoto out;\r\n}\r\nnpar_info->op_type = cmd.rsp.arg[1];\r\nnpar_info->pci_func = cmd.rsp.arg[2] & 0xFFFF;\r\nnpar_info->op_mode = (cmd.rsp.arg[2] & 0xFFFF0000) >> 16;\r\nnpar_info->phys_port = cmd.rsp.arg[3] & 0xFFFF;\r\nnpar_info->switch_mode = (cmd.rsp.arg[3] & 0xFFFF0000) >> 16;\r\nnpar_info->capabilities = cmd.rsp.arg[4];\r\nnpar_info->max_mac_filters = cmd.rsp.arg[5] & 0xFF;\r\nnpar_info->max_mtu = (cmd.rsp.arg[5] & 0xFFFF0000) >> 16;\r\nnpar_info->max_tx_ques = cmd.rsp.arg[6] & 0xFFFF;\r\nnpar_info->max_rx_ques = (cmd.rsp.arg[6] & 0xFFFF0000) >> 16;\r\nnpar_info->min_tx_bw = cmd.rsp.arg[7] & 0xFFFF;\r\nnpar_info->max_tx_bw = (cmd.rsp.arg[7] & 0xFFFF0000) >> 16;\r\nif (cmd.rsp.arg[8] & 0x1)\r\nnpar_info->max_bw_reg_offset = (cmd.rsp.arg[8] & 0x7FFE) >> 1;\r\nif (cmd.rsp.arg[8] & 0x10000) {\r\ntemp = (cmd.rsp.arg[8] & 0x7FFE0000) >> 17;\r\nnpar_info->max_linkspeed_reg_offset = temp;\r\n}\r\nmemcpy(ahw->extra_capability, &cmd.rsp.arg[16],\r\nsizeof(ahw->extra_capability));\r\nout:\r\nqlcnic_free_mbx_args(&cmd);\r\nreturn err;\r\n}\r\nint qlcnic_get_pci_func_type(struct qlcnic_adapter *adapter, u16 type,\r\nu16 *nic, u16 *fcoe, u16 *iscsi)\r\n{\r\nstruct device *dev = &adapter->pdev->dev;\r\nint err = 0;\r\nswitch (type) {\r\ncase QLCNIC_TYPE_NIC:\r\n(*nic)++;\r\nbreak;\r\ncase QLCNIC_TYPE_FCOE:\r\n(*fcoe)++;\r\nbreak;\r\ncase QLCNIC_TYPE_ISCSI:\r\n(*iscsi)++;\r\nbreak;\r\ndefault:\r\ndev_err(dev, "%s: Unknown PCI type[%x]\n",\r\n__func__, type);\r\nerr = -EIO;\r\n}\r\nreturn err;\r\n}\r\nint qlcnic_83xx_get_pci_info(struct qlcnic_adapter *adapter,\r\nstruct qlcnic_pci_info *pci_info)\r\n{\r\nstruct qlcnic_hardware_context *ahw = adapter->ahw;\r\nstruct device *dev = &adapter->pdev->dev;\r\nu16 nic = 0, fcoe = 0, iscsi = 0;\r\nstruct qlcnic_cmd_args cmd;\r\nint i, err = 0, j = 0;\r\nu32 temp;\r\nerr = qlcnic_alloc_mbx_args(&cmd, adapter, QLCNIC_CMD_GET_PCI_INFO);\r\nif (err)\r\nreturn err;\r\nerr = qlcnic_issue_cmd(adapter, &cmd);\r\nahw->total_nic_func = 0;\r\nif (err == QLCNIC_RCODE_SUCCESS) {\r\nahw->max_pci_func = cmd.rsp.arg[1] & 0xFF;\r\nfor (i = 2, j = 0; j < ahw->max_vnic_func; j++, pci_info++) {\r\npci_info->id = cmd.rsp.arg[i] & 0xFFFF;\r\npci_info->active = (cmd.rsp.arg[i] & 0xFFFF0000) >> 16;\r\ni++;\r\nif (!pci_info->active) {\r\ni += QLC_SKIP_INACTIVE_PCI_REGS;\r\ncontinue;\r\n}\r\npci_info->type = cmd.rsp.arg[i] & 0xFFFF;\r\nerr = qlcnic_get_pci_func_type(adapter, pci_info->type,\r\n&nic, &fcoe, &iscsi);\r\ntemp = (cmd.rsp.arg[i] & 0xFFFF0000) >> 16;\r\npci_info->default_port = temp;\r\ni++;\r\npci_info->tx_min_bw = cmd.rsp.arg[i] & 0xFFFF;\r\ntemp = (cmd.rsp.arg[i] & 0xFFFF0000) >> 16;\r\npci_info->tx_max_bw = temp;\r\ni = i + 2;\r\nmemcpy(pci_info->mac, &cmd.rsp.arg[i], ETH_ALEN - 2);\r\ni++;\r\nmemcpy(pci_info->mac + sizeof(u32), &cmd.rsp.arg[i], 2);\r\ni = i + 3;\r\n}\r\n} else {\r\ndev_err(dev, "Failed to get PCI Info, error = %d\n", err);\r\nerr = -EIO;\r\n}\r\nahw->total_nic_func = nic;\r\nahw->total_pci_func = nic + fcoe + iscsi;\r\nif (ahw->total_nic_func == 0 || ahw->total_pci_func == 0) {\r\ndev_err(dev, "%s: Invalid function count: total nic func[%x], total pci func[%x]\n",\r\n__func__, ahw->total_nic_func, ahw->total_pci_func);\r\nerr = -EIO;\r\n}\r\nqlcnic_free_mbx_args(&cmd);\r\nreturn err;\r\n}\r\nint qlcnic_83xx_config_intrpt(struct qlcnic_adapter *adapter, bool op_type)\r\n{\r\nint i, index, err;\r\nu8 max_ints;\r\nu32 val, temp, type;\r\nstruct qlcnic_cmd_args cmd;\r\nmax_ints = adapter->ahw->num_msix - 1;\r\nerr = qlcnic_alloc_mbx_args(&cmd, adapter, QLCNIC_CMD_CONFIG_INTRPT);\r\nif (err)\r\nreturn err;\r\ncmd.req.arg[1] = max_ints;\r\nif (qlcnic_sriov_vf_check(adapter))\r\ncmd.req.arg[1] |= (adapter->ahw->pci_func << 8) | BIT_16;\r\nfor (i = 0, index = 2; i < max_ints; i++) {\r\ntype = op_type ? QLCNIC_INTRPT_ADD : QLCNIC_INTRPT_DEL;\r\nval = type | (adapter->ahw->intr_tbl[i].type << 4);\r\nif (adapter->ahw->intr_tbl[i].type == QLCNIC_INTRPT_MSIX)\r\nval |= (adapter->ahw->intr_tbl[i].id << 16);\r\ncmd.req.arg[index++] = val;\r\n}\r\nerr = qlcnic_issue_cmd(adapter, &cmd);\r\nif (err) {\r\ndev_err(&adapter->pdev->dev,\r\n"Failed to configure interrupts 0x%x\n", err);\r\ngoto out;\r\n}\r\nmax_ints = cmd.rsp.arg[1];\r\nfor (i = 0, index = 2; i < max_ints; i++, index += 2) {\r\nval = cmd.rsp.arg[index];\r\nif (LSB(val)) {\r\ndev_info(&adapter->pdev->dev,\r\n"Can't configure interrupt %d\n",\r\nadapter->ahw->intr_tbl[i].id);\r\ncontinue;\r\n}\r\nif (op_type) {\r\nadapter->ahw->intr_tbl[i].id = MSW(val);\r\nadapter->ahw->intr_tbl[i].enabled = 1;\r\ntemp = cmd.rsp.arg[index + 1];\r\nadapter->ahw->intr_tbl[i].src = temp;\r\n} else {\r\nadapter->ahw->intr_tbl[i].id = i;\r\nadapter->ahw->intr_tbl[i].enabled = 0;\r\nadapter->ahw->intr_tbl[i].src = 0;\r\n}\r\n}\r\nout:\r\nqlcnic_free_mbx_args(&cmd);\r\nreturn err;\r\n}\r\nint qlcnic_83xx_lock_flash(struct qlcnic_adapter *adapter)\r\n{\r\nint id, timeout = 0;\r\nu32 status = 0;\r\nwhile (status == 0) {\r\nstatus = QLC_SHARED_REG_RD32(adapter, QLCNIC_FLASH_LOCK);\r\nif (status)\r\nbreak;\r\nif (++timeout >= QLC_83XX_FLASH_LOCK_TIMEOUT) {\r\nid = QLC_SHARED_REG_RD32(adapter,\r\nQLCNIC_FLASH_LOCK_OWNER);\r\ndev_err(&adapter->pdev->dev,\r\n"%s: failed, lock held by %d\n", __func__, id);\r\nreturn -EIO;\r\n}\r\nusleep_range(1000, 2000);\r\n}\r\nQLC_SHARED_REG_WR32(adapter, QLCNIC_FLASH_LOCK_OWNER, adapter->portnum);\r\nreturn 0;\r\n}\r\nvoid qlcnic_83xx_unlock_flash(struct qlcnic_adapter *adapter)\r\n{\r\nQLC_SHARED_REG_RD32(adapter, QLCNIC_FLASH_UNLOCK);\r\nQLC_SHARED_REG_WR32(adapter, QLCNIC_FLASH_LOCK_OWNER, 0xFF);\r\n}\r\nint qlcnic_83xx_lockless_flash_read32(struct qlcnic_adapter *adapter,\r\nu32 flash_addr, u8 *p_data,\r\nint count)\r\n{\r\nu32 word, range, flash_offset, addr = flash_addr, ret;\r\nulong indirect_add, direct_window;\r\nint i, err = 0;\r\nflash_offset = addr & (QLCNIC_FLASH_SECTOR_SIZE - 1);\r\nif (addr & 0x3) {\r\ndev_err(&adapter->pdev->dev, "Illegal addr = 0x%x\n", addr);\r\nreturn -EIO;\r\n}\r\nqlcnic_83xx_wrt_reg_indirect(adapter, QLC_83XX_FLASH_DIRECT_WINDOW,\r\n(addr & 0xFFFF0000));\r\nrange = flash_offset + (count * sizeof(u32));\r\nif (range > (QLCNIC_FLASH_SECTOR_SIZE - 1)) {\r\nfor (i = 0; i < count; i++) {\r\nindirect_add = QLC_83XX_FLASH_DIRECT_DATA(addr);\r\nret = QLCRD32(adapter, indirect_add, &err);\r\nif (err == -EIO)\r\nreturn err;\r\nword = ret;\r\n*(u32 *)p_data = word;\r\np_data = p_data + 4;\r\naddr = addr + 4;\r\nflash_offset = flash_offset + 4;\r\nif (flash_offset > (QLCNIC_FLASH_SECTOR_SIZE - 1)) {\r\ndirect_window = QLC_83XX_FLASH_DIRECT_WINDOW;\r\nqlcnic_83xx_wrt_reg_indirect(adapter,\r\ndirect_window,\r\n(addr));\r\nflash_offset = 0;\r\n}\r\n}\r\n} else {\r\nfor (i = 0; i < count; i++) {\r\nindirect_add = QLC_83XX_FLASH_DIRECT_DATA(addr);\r\nret = QLCRD32(adapter, indirect_add, &err);\r\nif (err == -EIO)\r\nreturn err;\r\nword = ret;\r\n*(u32 *)p_data = word;\r\np_data = p_data + 4;\r\naddr = addr + 4;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int qlcnic_83xx_poll_flash_status_reg(struct qlcnic_adapter *adapter)\r\n{\r\nu32 status;\r\nint retries = QLC_83XX_FLASH_READ_RETRY_COUNT;\r\nint err = 0;\r\ndo {\r\nstatus = QLCRD32(adapter, QLC_83XX_FLASH_STATUS, &err);\r\nif (err == -EIO)\r\nreturn err;\r\nif ((status & QLC_83XX_FLASH_STATUS_READY) ==\r\nQLC_83XX_FLASH_STATUS_READY)\r\nbreak;\r\nusleep_range(1000, 1100);\r\n} while (--retries);\r\nif (!retries)\r\nreturn -EIO;\r\nreturn 0;\r\n}\r\nint qlcnic_83xx_enable_flash_write(struct qlcnic_adapter *adapter)\r\n{\r\nint ret;\r\nu32 cmd;\r\ncmd = adapter->ahw->fdt.write_statusreg_cmd;\r\nqlcnic_83xx_wrt_reg_indirect(adapter, QLC_83XX_FLASH_ADDR,\r\n(QLC_83XX_FLASH_FDT_WRITE_DEF_SIG | cmd));\r\nqlcnic_83xx_wrt_reg_indirect(adapter, QLC_83XX_FLASH_WRDATA,\r\nadapter->ahw->fdt.write_enable_bits);\r\nqlcnic_83xx_wrt_reg_indirect(adapter, QLC_83XX_FLASH_CONTROL,\r\nQLC_83XX_FLASH_SECOND_ERASE_MS_VAL);\r\nret = qlcnic_83xx_poll_flash_status_reg(adapter);\r\nif (ret)\r\nreturn -EIO;\r\nreturn 0;\r\n}\r\nint qlcnic_83xx_disable_flash_write(struct qlcnic_adapter *adapter)\r\n{\r\nint ret;\r\nqlcnic_83xx_wrt_reg_indirect(adapter, QLC_83XX_FLASH_ADDR,\r\n(QLC_83XX_FLASH_FDT_WRITE_DEF_SIG |\r\nadapter->ahw->fdt.write_statusreg_cmd));\r\nqlcnic_83xx_wrt_reg_indirect(adapter, QLC_83XX_FLASH_WRDATA,\r\nadapter->ahw->fdt.write_disable_bits);\r\nqlcnic_83xx_wrt_reg_indirect(adapter, QLC_83XX_FLASH_CONTROL,\r\nQLC_83XX_FLASH_SECOND_ERASE_MS_VAL);\r\nret = qlcnic_83xx_poll_flash_status_reg(adapter);\r\nif (ret)\r\nreturn -EIO;\r\nreturn 0;\r\n}\r\nint qlcnic_83xx_read_flash_mfg_id(struct qlcnic_adapter *adapter)\r\n{\r\nint ret, err = 0;\r\nu32 mfg_id;\r\nif (qlcnic_83xx_lock_flash(adapter))\r\nreturn -EIO;\r\nqlcnic_83xx_wrt_reg_indirect(adapter, QLC_83XX_FLASH_ADDR,\r\nQLC_83XX_FLASH_FDT_READ_MFG_ID_VAL);\r\nqlcnic_83xx_wrt_reg_indirect(adapter, QLC_83XX_FLASH_CONTROL,\r\nQLC_83XX_FLASH_READ_CTRL);\r\nret = qlcnic_83xx_poll_flash_status_reg(adapter);\r\nif (ret) {\r\nqlcnic_83xx_unlock_flash(adapter);\r\nreturn -EIO;\r\n}\r\nmfg_id = QLCRD32(adapter, QLC_83XX_FLASH_RDDATA, &err);\r\nif (err == -EIO) {\r\nqlcnic_83xx_unlock_flash(adapter);\r\nreturn err;\r\n}\r\nadapter->flash_mfg_id = (mfg_id & 0xFF);\r\nqlcnic_83xx_unlock_flash(adapter);\r\nreturn 0;\r\n}\r\nint qlcnic_83xx_read_flash_descriptor_table(struct qlcnic_adapter *adapter)\r\n{\r\nint count, fdt_size, ret = 0;\r\nfdt_size = sizeof(struct qlcnic_fdt);\r\ncount = fdt_size / sizeof(u32);\r\nif (qlcnic_83xx_lock_flash(adapter))\r\nreturn -EIO;\r\nmemset(&adapter->ahw->fdt, 0, fdt_size);\r\nret = qlcnic_83xx_lockless_flash_read32(adapter, QLCNIC_FDT_LOCATION,\r\n(u8 *)&adapter->ahw->fdt,\r\ncount);\r\nqlcnic_swap32_buffer((u32 *)&adapter->ahw->fdt, count);\r\nqlcnic_83xx_unlock_flash(adapter);\r\nreturn ret;\r\n}\r\nint qlcnic_83xx_erase_flash_sector(struct qlcnic_adapter *adapter,\r\nu32 sector_start_addr)\r\n{\r\nu32 reversed_addr, addr1, addr2, cmd;\r\nint ret = -EIO;\r\nif (qlcnic_83xx_lock_flash(adapter) != 0)\r\nreturn -EIO;\r\nif (adapter->ahw->fdt.mfg_id == adapter->flash_mfg_id) {\r\nret = qlcnic_83xx_enable_flash_write(adapter);\r\nif (ret) {\r\nqlcnic_83xx_unlock_flash(adapter);\r\ndev_err(&adapter->pdev->dev,\r\n"%s failed at %d\n",\r\n__func__, __LINE__);\r\nreturn ret;\r\n}\r\n}\r\nret = qlcnic_83xx_poll_flash_status_reg(adapter);\r\nif (ret) {\r\nqlcnic_83xx_unlock_flash(adapter);\r\ndev_err(&adapter->pdev->dev,\r\n"%s: failed at %d\n", __func__, __LINE__);\r\nreturn -EIO;\r\n}\r\naddr1 = (sector_start_addr & 0xFF) << 16;\r\naddr2 = (sector_start_addr & 0xFF0000) >> 16;\r\nreversed_addr = addr1 | addr2 | (sector_start_addr & 0xFF00);\r\nqlcnic_83xx_wrt_reg_indirect(adapter, QLC_83XX_FLASH_WRDATA,\r\nreversed_addr);\r\ncmd = QLC_83XX_FLASH_FDT_ERASE_DEF_SIG | adapter->ahw->fdt.erase_cmd;\r\nif (adapter->ahw->fdt.mfg_id == adapter->flash_mfg_id)\r\nqlcnic_83xx_wrt_reg_indirect(adapter, QLC_83XX_FLASH_ADDR, cmd);\r\nelse\r\nqlcnic_83xx_wrt_reg_indirect(adapter, QLC_83XX_FLASH_ADDR,\r\nQLC_83XX_FLASH_OEM_ERASE_SIG);\r\nqlcnic_83xx_wrt_reg_indirect(adapter, QLC_83XX_FLASH_CONTROL,\r\nQLC_83XX_FLASH_LAST_ERASE_MS_VAL);\r\nret = qlcnic_83xx_poll_flash_status_reg(adapter);\r\nif (ret) {\r\nqlcnic_83xx_unlock_flash(adapter);\r\ndev_err(&adapter->pdev->dev,\r\n"%s: failed at %d\n", __func__, __LINE__);\r\nreturn -EIO;\r\n}\r\nif (adapter->ahw->fdt.mfg_id == adapter->flash_mfg_id) {\r\nret = qlcnic_83xx_disable_flash_write(adapter);\r\nif (ret) {\r\nqlcnic_83xx_unlock_flash(adapter);\r\ndev_err(&adapter->pdev->dev,\r\n"%s: failed at %d\n", __func__, __LINE__);\r\nreturn ret;\r\n}\r\n}\r\nqlcnic_83xx_unlock_flash(adapter);\r\nreturn 0;\r\n}\r\nint qlcnic_83xx_flash_write32(struct qlcnic_adapter *adapter, u32 addr,\r\nu32 *p_data)\r\n{\r\nint ret = -EIO;\r\nu32 addr1 = 0x00800000 | (addr >> 2);\r\nqlcnic_83xx_wrt_reg_indirect(adapter, QLC_83XX_FLASH_ADDR, addr1);\r\nqlcnic_83xx_wrt_reg_indirect(adapter, QLC_83XX_FLASH_WRDATA, *p_data);\r\nqlcnic_83xx_wrt_reg_indirect(adapter, QLC_83XX_FLASH_CONTROL,\r\nQLC_83XX_FLASH_LAST_ERASE_MS_VAL);\r\nret = qlcnic_83xx_poll_flash_status_reg(adapter);\r\nif (ret) {\r\ndev_err(&adapter->pdev->dev,\r\n"%s: failed at %d\n", __func__, __LINE__);\r\nreturn -EIO;\r\n}\r\nreturn 0;\r\n}\r\nint qlcnic_83xx_flash_bulk_write(struct qlcnic_adapter *adapter, u32 addr,\r\nu32 *p_data, int count)\r\n{\r\nu32 temp;\r\nint ret = -EIO, err = 0;\r\nif ((count < QLC_83XX_FLASH_WRITE_MIN) ||\r\n(count > QLC_83XX_FLASH_WRITE_MAX)) {\r\ndev_err(&adapter->pdev->dev,\r\n"%s: Invalid word count\n", __func__);\r\nreturn -EIO;\r\n}\r\ntemp = QLCRD32(adapter, QLC_83XX_FLASH_SPI_CONTROL, &err);\r\nif (err == -EIO)\r\nreturn err;\r\nqlcnic_83xx_wrt_reg_indirect(adapter, QLC_83XX_FLASH_SPI_CONTROL,\r\n(temp | QLC_83XX_FLASH_SPI_CTRL));\r\nqlcnic_83xx_wrt_reg_indirect(adapter, QLC_83XX_FLASH_ADDR,\r\nQLC_83XX_FLASH_ADDR_TEMP_VAL);\r\nqlcnic_83xx_wrt_reg_indirect(adapter, QLC_83XX_FLASH_WRDATA, *p_data++);\r\nqlcnic_83xx_wrt_reg_indirect(adapter, QLC_83XX_FLASH_CONTROL,\r\nQLC_83XX_FLASH_FIRST_MS_PATTERN);\r\nret = qlcnic_83xx_poll_flash_status_reg(adapter);\r\nif (ret) {\r\ndev_err(&adapter->pdev->dev,\r\n"%s: failed at %d\n", __func__, __LINE__);\r\nreturn -EIO;\r\n}\r\ncount--;\r\nqlcnic_83xx_wrt_reg_indirect(adapter, QLC_83XX_FLASH_ADDR,\r\nQLC_83XX_FLASH_ADDR_SECOND_TEMP_VAL);\r\nwhile (count != 1) {\r\nqlcnic_83xx_wrt_reg_indirect(adapter, QLC_83XX_FLASH_WRDATA,\r\n*p_data++);\r\nqlcnic_83xx_wrt_reg_indirect(adapter, QLC_83XX_FLASH_CONTROL,\r\nQLC_83XX_FLASH_SECOND_MS_PATTERN);\r\nret = qlcnic_83xx_poll_flash_status_reg(adapter);\r\nif (ret) {\r\ndev_err(&adapter->pdev->dev,\r\n"%s: failed at %d\n", __func__, __LINE__);\r\nreturn -EIO;\r\n}\r\ncount--;\r\n}\r\nqlcnic_83xx_wrt_reg_indirect(adapter, QLC_83XX_FLASH_ADDR,\r\nQLC_83XX_FLASH_ADDR_TEMP_VAL |\r\n(addr >> 2));\r\nqlcnic_83xx_wrt_reg_indirect(adapter, QLC_83XX_FLASH_WRDATA, *p_data++);\r\nqlcnic_83xx_wrt_reg_indirect(adapter, QLC_83XX_FLASH_CONTROL,\r\nQLC_83XX_FLASH_LAST_MS_PATTERN);\r\nret = qlcnic_83xx_poll_flash_status_reg(adapter);\r\nif (ret) {\r\ndev_err(&adapter->pdev->dev,\r\n"%s: failed at %d\n", __func__, __LINE__);\r\nreturn -EIO;\r\n}\r\nret = QLCRD32(adapter, QLC_83XX_FLASH_SPI_STATUS, &err);\r\nif (err == -EIO)\r\nreturn err;\r\nif ((ret & QLC_83XX_FLASH_SPI_CTRL) == QLC_83XX_FLASH_SPI_CTRL) {\r\ndev_err(&adapter->pdev->dev, "%s: failed at %d\n",\r\n__func__, __LINE__);\r\ntemp = QLCRD32(adapter, QLC_83XX_FLASH_SPI_CONTROL, &err);\r\nif (err == -EIO)\r\nreturn err;\r\nqlcnic_83xx_wrt_reg_indirect(adapter,\r\nQLC_83XX_FLASH_SPI_CONTROL,\r\n(temp | QLC_83XX_FLASH_SPI_CTRL));\r\n}\r\nreturn 0;\r\n}\r\nstatic void qlcnic_83xx_recover_driver_lock(struct qlcnic_adapter *adapter)\r\n{\r\nu32 val, id;\r\nval = QLCRDX(adapter->ahw, QLC_83XX_RECOVER_DRV_LOCK);\r\nif ((val & QLC_83XX_DRV_LOCK_RECOVERY_STATUS_MASK) == 0) {\r\nval = val & ~0x3F;\r\nval = val | ((adapter->portnum << 2) |\r\nQLC_83XX_NEED_DRV_LOCK_RECOVERY);\r\nQLCWRX(adapter->ahw, QLC_83XX_RECOVER_DRV_LOCK, val);\r\ndev_info(&adapter->pdev->dev,\r\n"%s: lock recovery initiated\n", __func__);\r\nmsleep(QLC_83XX_DRV_LOCK_RECOVERY_DELAY);\r\nval = QLCRDX(adapter->ahw, QLC_83XX_RECOVER_DRV_LOCK);\r\nid = ((val >> 2) & 0xF);\r\nif (id == adapter->portnum) {\r\nval = val & ~QLC_83XX_DRV_LOCK_RECOVERY_STATUS_MASK;\r\nval = val | QLC_83XX_DRV_LOCK_RECOVERY_IN_PROGRESS;\r\nQLCWRX(adapter->ahw, QLC_83XX_RECOVER_DRV_LOCK, val);\r\nQLCRDX(adapter->ahw, QLC_83XX_DRV_UNLOCK);\r\nval = val & ~0x3F;\r\nQLCWRX(adapter->ahw, QLC_83XX_RECOVER_DRV_LOCK, val);\r\ndev_info(&adapter->pdev->dev,\r\n"%s: lock recovery completed\n", __func__);\r\n} else {\r\ndev_info(&adapter->pdev->dev,\r\n"%s: func %d to resume lock recovery process\n",\r\n__func__, id);\r\n}\r\n} else {\r\ndev_info(&adapter->pdev->dev,\r\n"%s: lock recovery initiated by other functions\n",\r\n__func__);\r\n}\r\n}\r\nint qlcnic_83xx_lock_driver(struct qlcnic_adapter *adapter)\r\n{\r\nu32 lock_alive_counter, val, id, i = 0, status = 0, temp = 0;\r\nint max_attempt = 0;\r\nwhile (status == 0) {\r\nstatus = QLCRDX(adapter->ahw, QLC_83XX_DRV_LOCK);\r\nif (status)\r\nbreak;\r\nmsleep(QLC_83XX_DRV_LOCK_WAIT_DELAY);\r\ni++;\r\nif (i == 1)\r\ntemp = QLCRDX(adapter->ahw, QLC_83XX_DRV_LOCK_ID);\r\nif (i == QLC_83XX_DRV_LOCK_WAIT_COUNTER) {\r\nval = QLCRDX(adapter->ahw, QLC_83XX_DRV_LOCK_ID);\r\nif (val == temp) {\r\nid = val & 0xFF;\r\ndev_info(&adapter->pdev->dev,\r\n"%s: lock to be recovered from %d\n",\r\n__func__, id);\r\nqlcnic_83xx_recover_driver_lock(adapter);\r\ni = 0;\r\nmax_attempt++;\r\n} else {\r\ndev_err(&adapter->pdev->dev,\r\n"%s: failed to get lock\n", __func__);\r\nreturn -EIO;\r\n}\r\n}\r\nif (max_attempt == QLC_83XX_MAX_DRV_LOCK_RECOVERY_ATTEMPT) {\r\ndev_err(&adapter->pdev->dev,\r\n"%s: failed to get lock\n", __func__);\r\nreturn -EIO;\r\n}\r\n}\r\nval = QLCRDX(adapter->ahw, QLC_83XX_DRV_LOCK_ID);\r\nlock_alive_counter = val >> 8;\r\nlock_alive_counter++;\r\nval = lock_alive_counter << 8 | adapter->portnum;\r\nQLCWRX(adapter->ahw, QLC_83XX_DRV_LOCK_ID, val);\r\nreturn 0;\r\n}\r\nvoid qlcnic_83xx_unlock_driver(struct qlcnic_adapter *adapter)\r\n{\r\nu32 val, lock_alive_counter, id;\r\nval = QLCRDX(adapter->ahw, QLC_83XX_DRV_LOCK_ID);\r\nid = val & 0xFF;\r\nlock_alive_counter = val >> 8;\r\nif (id != adapter->portnum)\r\ndev_err(&adapter->pdev->dev,\r\n"%s:Warning func %d is unlocking lock owned by %d\n",\r\n__func__, adapter->portnum, id);\r\nval = (lock_alive_counter << 8) | 0xFF;\r\nQLCWRX(adapter->ahw, QLC_83XX_DRV_LOCK_ID, val);\r\nQLCRDX(adapter->ahw, QLC_83XX_DRV_UNLOCK);\r\n}\r\nint qlcnic_ms_mem_write128(struct qlcnic_adapter *adapter, u64 addr,\r\nu32 *data, u32 count)\r\n{\r\nint i, j, ret = 0;\r\nu32 temp;\r\nif (addr & 0xF)\r\nreturn -EIO;\r\nmutex_lock(&adapter->ahw->mem_lock);\r\nqlcnic_ind_wr(adapter, QLCNIC_MS_ADDR_HI, 0);\r\nfor (i = 0; i < count; i++, addr += 16) {\r\nif (!((ADDR_IN_RANGE(addr, QLCNIC_ADDR_QDR_NET,\r\nQLCNIC_ADDR_QDR_NET_MAX)) ||\r\n(ADDR_IN_RANGE(addr, QLCNIC_ADDR_DDR_NET,\r\nQLCNIC_ADDR_DDR_NET_MAX)))) {\r\nmutex_unlock(&adapter->ahw->mem_lock);\r\nreturn -EIO;\r\n}\r\nqlcnic_ind_wr(adapter, QLCNIC_MS_ADDR_LO, addr);\r\nqlcnic_ind_wr(adapter, QLCNIC_MS_WRTDATA_LO, *data++);\r\nqlcnic_ind_wr(adapter, QLCNIC_MS_WRTDATA_HI, *data++);\r\nqlcnic_ind_wr(adapter, QLCNIC_MS_WRTDATA_ULO, *data++);\r\nqlcnic_ind_wr(adapter, QLCNIC_MS_WRTDATA_UHI, *data++);\r\nqlcnic_ind_wr(adapter, QLCNIC_MS_CTRL, QLCNIC_TA_WRITE_ENABLE);\r\nqlcnic_ind_wr(adapter, QLCNIC_MS_CTRL, QLCNIC_TA_WRITE_START);\r\nfor (j = 0; j < MAX_CTL_CHECK; j++) {\r\ntemp = qlcnic_ind_rd(adapter, QLCNIC_MS_CTRL);\r\nif ((temp & TA_CTL_BUSY) == 0)\r\nbreak;\r\n}\r\nif (j >= MAX_CTL_CHECK) {\r\nprintk_ratelimited(KERN_WARNING\r\n"MS memory write failed\n");\r\nmutex_unlock(&adapter->ahw->mem_lock);\r\nreturn -EIO;\r\n}\r\n}\r\nmutex_unlock(&adapter->ahw->mem_lock);\r\nreturn ret;\r\n}\r\nint qlcnic_83xx_flash_read32(struct qlcnic_adapter *adapter, u32 flash_addr,\r\nu8 *p_data, int count)\r\n{\r\nu32 word, addr = flash_addr, ret;\r\nulong indirect_addr;\r\nint i, err = 0;\r\nif (qlcnic_83xx_lock_flash(adapter) != 0)\r\nreturn -EIO;\r\nif (addr & 0x3) {\r\ndev_err(&adapter->pdev->dev, "Illegal addr = 0x%x\n", addr);\r\nqlcnic_83xx_unlock_flash(adapter);\r\nreturn -EIO;\r\n}\r\nfor (i = 0; i < count; i++) {\r\nif (qlcnic_83xx_wrt_reg_indirect(adapter,\r\nQLC_83XX_FLASH_DIRECT_WINDOW,\r\n(addr))) {\r\nqlcnic_83xx_unlock_flash(adapter);\r\nreturn -EIO;\r\n}\r\nindirect_addr = QLC_83XX_FLASH_DIRECT_DATA(addr);\r\nret = QLCRD32(adapter, indirect_addr, &err);\r\nif (err == -EIO)\r\nreturn err;\r\nword = ret;\r\n*(u32 *)p_data = word;\r\np_data = p_data + 4;\r\naddr = addr + 4;\r\n}\r\nqlcnic_83xx_unlock_flash(adapter);\r\nreturn 0;\r\n}\r\nint qlcnic_83xx_test_link(struct qlcnic_adapter *adapter)\r\n{\r\nu8 pci_func;\r\nint err;\r\nu32 config = 0, state;\r\nstruct qlcnic_cmd_args cmd;\r\nstruct qlcnic_hardware_context *ahw = adapter->ahw;\r\nif (qlcnic_sriov_vf_check(adapter))\r\npci_func = adapter->portnum;\r\nelse\r\npci_func = ahw->pci_func;\r\nstate = readl(ahw->pci_base0 + QLC_83XX_LINK_STATE(pci_func));\r\nif (!QLC_83xx_FUNC_VAL(state, pci_func)) {\r\ndev_info(&adapter->pdev->dev, "link state down\n");\r\nreturn config;\r\n}\r\nerr = qlcnic_alloc_mbx_args(&cmd, adapter, QLCNIC_CMD_GET_LINK_STATUS);\r\nif (err)\r\nreturn err;\r\nerr = qlcnic_issue_cmd(adapter, &cmd);\r\nif (err) {\r\ndev_info(&adapter->pdev->dev,\r\n"Get Link Status Command failed: 0x%x\n", err);\r\ngoto out;\r\n} else {\r\nconfig = cmd.rsp.arg[1];\r\nswitch (QLC_83XX_CURRENT_LINK_SPEED(config)) {\r\ncase QLC_83XX_10M_LINK:\r\nahw->link_speed = SPEED_10;\r\nbreak;\r\ncase QLC_83XX_100M_LINK:\r\nahw->link_speed = SPEED_100;\r\nbreak;\r\ncase QLC_83XX_1G_LINK:\r\nahw->link_speed = SPEED_1000;\r\nbreak;\r\ncase QLC_83XX_10G_LINK:\r\nahw->link_speed = SPEED_10000;\r\nbreak;\r\ndefault:\r\nahw->link_speed = 0;\r\nbreak;\r\n}\r\nconfig = cmd.rsp.arg[3];\r\nswitch (QLC_83XX_SFP_MODULE_TYPE(config)) {\r\ncase QLC_83XX_MODULE_FIBRE_10GBASE_LRM:\r\ncase QLC_83XX_MODULE_FIBRE_10GBASE_LR:\r\ncase QLC_83XX_MODULE_FIBRE_10GBASE_SR:\r\nahw->supported_type = PORT_FIBRE;\r\nahw->port_type = QLCNIC_XGBE;\r\nbreak;\r\ncase QLC_83XX_MODULE_FIBRE_1000BASE_SX:\r\ncase QLC_83XX_MODULE_FIBRE_1000BASE_LX:\r\ncase QLC_83XX_MODULE_FIBRE_1000BASE_CX:\r\nahw->supported_type = PORT_FIBRE;\r\nahw->port_type = QLCNIC_GBE;\r\nbreak;\r\ncase QLC_83XX_MODULE_TP_1000BASE_T:\r\nahw->supported_type = PORT_TP;\r\nahw->port_type = QLCNIC_GBE;\r\nbreak;\r\ncase QLC_83XX_MODULE_DA_10GE_PASSIVE_CP:\r\ncase QLC_83XX_MODULE_DA_10GE_ACTIVE_CP:\r\ncase QLC_83XX_MODULE_DA_10GE_LEGACY_CP:\r\ncase QLC_83XX_MODULE_DA_1GE_PASSIVE_CP:\r\nahw->supported_type = PORT_DA;\r\nahw->port_type = QLCNIC_XGBE;\r\nbreak;\r\ndefault:\r\nahw->supported_type = PORT_OTHER;\r\nahw->port_type = QLCNIC_XGBE;\r\n}\r\nif (config & 1)\r\nerr = 1;\r\n}\r\nout:\r\nqlcnic_free_mbx_args(&cmd);\r\nreturn config;\r\n}\r\nint qlcnic_83xx_get_settings(struct qlcnic_adapter *adapter,\r\nstruct ethtool_cmd *ecmd)\r\n{\r\nstruct qlcnic_hardware_context *ahw = adapter->ahw;\r\nu32 config = 0;\r\nint status = 0;\r\nif (!test_bit(__QLCNIC_MAINTENANCE_MODE, &adapter->state)) {\r\nstatus = qlcnic_83xx_get_port_info(adapter);\r\nconfig = qlcnic_83xx_test_link(adapter);\r\nahw->module_type = QLC_83XX_SFP_MODULE_TYPE(config);\r\n}\r\nahw->board_type = QLCNIC_BRDTYPE_83XX_10G;\r\nif (netif_running(adapter->netdev) && ahw->has_link_events) {\r\nethtool_cmd_speed_set(ecmd, ahw->link_speed);\r\necmd->duplex = ahw->link_duplex;\r\necmd->autoneg = ahw->link_autoneg;\r\n} else {\r\nethtool_cmd_speed_set(ecmd, SPEED_UNKNOWN);\r\necmd->duplex = DUPLEX_UNKNOWN;\r\necmd->autoneg = AUTONEG_DISABLE;\r\n}\r\necmd->supported = (SUPPORTED_10baseT_Full |\r\nSUPPORTED_100baseT_Full |\r\nSUPPORTED_1000baseT_Full |\r\nSUPPORTED_10000baseT_Full |\r\nSUPPORTED_Autoneg);\r\nif (ecmd->autoneg == AUTONEG_ENABLE) {\r\nif (ahw->port_config & QLC_83XX_10_CAPABLE)\r\necmd->advertising |= SUPPORTED_10baseT_Full;\r\nif (ahw->port_config & QLC_83XX_100_CAPABLE)\r\necmd->advertising |= SUPPORTED_100baseT_Full;\r\nif (ahw->port_config & QLC_83XX_1G_CAPABLE)\r\necmd->advertising |= SUPPORTED_1000baseT_Full;\r\nif (ahw->port_config & QLC_83XX_10G_CAPABLE)\r\necmd->advertising |= SUPPORTED_10000baseT_Full;\r\nif (ahw->port_config & QLC_83XX_AUTONEG_ENABLE)\r\necmd->advertising |= ADVERTISED_Autoneg;\r\n} else {\r\nswitch (ahw->link_speed) {\r\ncase SPEED_10:\r\necmd->advertising = SUPPORTED_10baseT_Full;\r\nbreak;\r\ncase SPEED_100:\r\necmd->advertising = SUPPORTED_100baseT_Full;\r\nbreak;\r\ncase SPEED_1000:\r\necmd->advertising = SUPPORTED_1000baseT_Full;\r\nbreak;\r\ncase SPEED_10000:\r\necmd->advertising = SUPPORTED_10000baseT_Full;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nswitch (ahw->supported_type) {\r\ncase PORT_FIBRE:\r\necmd->supported |= SUPPORTED_FIBRE;\r\necmd->advertising |= ADVERTISED_FIBRE;\r\necmd->port = PORT_FIBRE;\r\necmd->transceiver = XCVR_EXTERNAL;\r\nbreak;\r\ncase PORT_TP:\r\necmd->supported |= SUPPORTED_TP;\r\necmd->advertising |= ADVERTISED_TP;\r\necmd->port = PORT_TP;\r\necmd->transceiver = XCVR_INTERNAL;\r\nbreak;\r\ncase PORT_DA:\r\necmd->supported |= SUPPORTED_FIBRE;\r\necmd->advertising |= ADVERTISED_FIBRE;\r\necmd->port = PORT_DA;\r\necmd->transceiver = XCVR_EXTERNAL;\r\nbreak;\r\ndefault:\r\necmd->supported |= SUPPORTED_FIBRE;\r\necmd->advertising |= ADVERTISED_FIBRE;\r\necmd->port = PORT_OTHER;\r\necmd->transceiver = XCVR_EXTERNAL;\r\nbreak;\r\n}\r\necmd->phy_address = ahw->physical_port;\r\nreturn status;\r\n}\r\nint qlcnic_83xx_set_settings(struct qlcnic_adapter *adapter,\r\nstruct ethtool_cmd *ecmd)\r\n{\r\nstruct qlcnic_hardware_context *ahw = adapter->ahw;\r\nu32 config = adapter->ahw->port_config;\r\nint status = 0;\r\nif (ecmd->duplex == DUPLEX_HALF) {\r\nnetdev_info(adapter->netdev,\r\n"Half duplex mode not supported\n");\r\nreturn -EINVAL;\r\n}\r\nif (ecmd->autoneg) {\r\nahw->port_config |= QLC_83XX_AUTONEG_ENABLE;\r\nahw->port_config |= (QLC_83XX_100_CAPABLE |\r\nQLC_83XX_1G_CAPABLE |\r\nQLC_83XX_10G_CAPABLE);\r\n} else {\r\nahw->port_config &= ~QLC_83XX_AUTONEG_ENABLE;\r\nswitch (ethtool_cmd_speed(ecmd)) {\r\ncase SPEED_10:\r\nahw->port_config &= ~(QLC_83XX_100_CAPABLE |\r\nQLC_83XX_1G_CAPABLE |\r\nQLC_83XX_10G_CAPABLE);\r\nahw->port_config |= QLC_83XX_10_CAPABLE;\r\nbreak;\r\ncase SPEED_100:\r\nahw->port_config &= ~(QLC_83XX_10_CAPABLE |\r\nQLC_83XX_1G_CAPABLE |\r\nQLC_83XX_10G_CAPABLE);\r\nahw->port_config |= QLC_83XX_100_CAPABLE;\r\nbreak;\r\ncase SPEED_1000:\r\nahw->port_config &= ~(QLC_83XX_10_CAPABLE |\r\nQLC_83XX_100_CAPABLE |\r\nQLC_83XX_10G_CAPABLE);\r\nahw->port_config |= QLC_83XX_1G_CAPABLE;\r\nbreak;\r\ncase SPEED_10000:\r\nahw->port_config &= ~(QLC_83XX_10_CAPABLE |\r\nQLC_83XX_100_CAPABLE |\r\nQLC_83XX_1G_CAPABLE);\r\nahw->port_config |= QLC_83XX_10G_CAPABLE;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\n}\r\nstatus = qlcnic_83xx_set_port_config(adapter);\r\nif (status) {\r\nnetdev_info(adapter->netdev,\r\n"Failed to Set Link Speed and autoneg.\n");\r\nahw->port_config = config;\r\n}\r\nreturn status;\r\n}\r\nstatic inline u64 *qlcnic_83xx_copy_stats(struct qlcnic_cmd_args *cmd,\r\nu64 *data, int index)\r\n{\r\nu32 low, hi;\r\nu64 val;\r\nlow = cmd->rsp.arg[index];\r\nhi = cmd->rsp.arg[index + 1];\r\nval = (((u64) low) | (((u64) hi) << 32));\r\n*data++ = val;\r\nreturn data;\r\n}\r\nstatic u64 *qlcnic_83xx_fill_stats(struct qlcnic_adapter *adapter,\r\nstruct qlcnic_cmd_args *cmd, u64 *data,\r\nint type, int *ret)\r\n{\r\nint err, k, total_regs;\r\n*ret = 0;\r\nerr = qlcnic_issue_cmd(adapter, cmd);\r\nif (err != QLCNIC_RCODE_SUCCESS) {\r\ndev_info(&adapter->pdev->dev,\r\n"Error in get statistics mailbox command\n");\r\n*ret = -EIO;\r\nreturn data;\r\n}\r\ntotal_regs = cmd->rsp.num;\r\nswitch (type) {\r\ncase QLC_83XX_STAT_MAC:\r\nfor (k = 2; k < 28; k += 2)\r\ndata = qlcnic_83xx_copy_stats(cmd, data, k);\r\nfor (k += 6; k < 60; k += 2)\r\ndata = qlcnic_83xx_copy_stats(cmd, data, k);\r\nfor (k += 6; k < 80; k += 2)\r\ndata = qlcnic_83xx_copy_stats(cmd, data, k);\r\nfor (; k < total_regs; k += 2)\r\ndata = qlcnic_83xx_copy_stats(cmd, data, k);\r\nbreak;\r\ncase QLC_83XX_STAT_RX:\r\nfor (k = 2; k < 8; k += 2)\r\ndata = qlcnic_83xx_copy_stats(cmd, data, k);\r\nfor (k += 2; k < 24; k += 2)\r\ndata = qlcnic_83xx_copy_stats(cmd, data, k);\r\nfor (k += 2; k < total_regs; k += 2)\r\ndata = qlcnic_83xx_copy_stats(cmd, data, k);\r\nbreak;\r\ncase QLC_83XX_STAT_TX:\r\nfor (k = 2; k < 10; k += 2)\r\ndata = qlcnic_83xx_copy_stats(cmd, data, k);\r\nfor (k += 2; k < total_regs; k += 2)\r\ndata = qlcnic_83xx_copy_stats(cmd, data, k);\r\nbreak;\r\ndefault:\r\ndev_warn(&adapter->pdev->dev, "Unknown get statistics mode\n");\r\n*ret = -EIO;\r\n}\r\nreturn data;\r\n}\r\nvoid qlcnic_83xx_get_stats(struct qlcnic_adapter *adapter, u64 *data)\r\n{\r\nstruct qlcnic_cmd_args cmd;\r\nstruct net_device *netdev = adapter->netdev;\r\nint ret = 0;\r\nret = qlcnic_alloc_mbx_args(&cmd, adapter, QLCNIC_CMD_GET_STATISTICS);\r\nif (ret)\r\nreturn;\r\ncmd.req.arg[1] = BIT_1 | (adapter->tx_ring->ctx_id << 16);\r\ncmd.rsp.num = QLC_83XX_TX_STAT_REGS;\r\ndata = qlcnic_83xx_fill_stats(adapter, &cmd, data,\r\nQLC_83XX_STAT_TX, &ret);\r\nif (ret) {\r\nnetdev_err(netdev, "Error getting Tx stats\n");\r\ngoto out;\r\n}\r\ncmd.req.arg[1] = BIT_2 | (adapter->portnum << 16);\r\ncmd.rsp.num = QLC_83XX_MAC_STAT_REGS;\r\nmemset(cmd.rsp.arg, 0, sizeof(u32) * cmd.rsp.num);\r\ndata = qlcnic_83xx_fill_stats(adapter, &cmd, data,\r\nQLC_83XX_STAT_MAC, &ret);\r\nif (ret) {\r\nnetdev_err(netdev, "Error getting MAC stats\n");\r\ngoto out;\r\n}\r\ncmd.req.arg[1] = adapter->recv_ctx->context_id << 16;\r\ncmd.rsp.num = QLC_83XX_RX_STAT_REGS;\r\nmemset(cmd.rsp.arg, 0, sizeof(u32) * cmd.rsp.num);\r\ndata = qlcnic_83xx_fill_stats(adapter, &cmd, data,\r\nQLC_83XX_STAT_RX, &ret);\r\nif (ret)\r\nnetdev_err(netdev, "Error getting Rx stats\n");\r\nout:\r\nqlcnic_free_mbx_args(&cmd);\r\n}\r\nint qlcnic_83xx_extend_md_capab(struct qlcnic_adapter *adapter)\r\n{\r\nstruct qlcnic_cmd_args cmd;\r\nint err;\r\nerr = qlcnic_alloc_mbx_args(&cmd, adapter,\r\nQLCNIC_CMD_83XX_EXTEND_ISCSI_DUMP_CAP);\r\nif (err)\r\nreturn err;\r\ncmd.req.arg[1] = (QLCNIC_83XX_ADD_PORT0 | QLCNIC_83XX_ADD_PORT1);\r\ncmd.req.arg[2] = QLCNIC_83XX_EXTENDED_MEM_SIZE;\r\ncmd.req.arg[3] = QLCNIC_83XX_EXTENDED_MEM_SIZE;\r\nerr = qlcnic_issue_cmd(adapter, &cmd);\r\nif (err)\r\ndev_err(&adapter->pdev->dev,\r\n"failed to issue extend iSCSI minidump capability\n");\r\nreturn err;\r\n}\r\nint qlcnic_83xx_reg_test(struct qlcnic_adapter *adapter)\r\n{\r\nu32 major, minor, sub;\r\nmajor = QLC_SHARED_REG_RD32(adapter, QLCNIC_FW_VERSION_MAJOR);\r\nminor = QLC_SHARED_REG_RD32(adapter, QLCNIC_FW_VERSION_MINOR);\r\nsub = QLC_SHARED_REG_RD32(adapter, QLCNIC_FW_VERSION_SUB);\r\nif (adapter->fw_version != QLCNIC_VERSION_CODE(major, minor, sub)) {\r\ndev_info(&adapter->pdev->dev, "%s: Reg test failed\n",\r\n__func__);\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}\r\ninline int qlcnic_83xx_get_regs_len(struct qlcnic_adapter *adapter)\r\n{\r\nreturn (ARRAY_SIZE(qlcnic_83xx_ext_reg_tbl) *\r\nsizeof(*adapter->ahw->ext_reg_tbl)) +\r\n(ARRAY_SIZE(qlcnic_83xx_reg_tbl) *\r\nsizeof(*adapter->ahw->reg_tbl));\r\n}\r\nint qlcnic_83xx_get_registers(struct qlcnic_adapter *adapter, u32 *regs_buff)\r\n{\r\nint i, j = 0;\r\nfor (i = QLCNIC_DEV_INFO_SIZE + 1;\r\nj < ARRAY_SIZE(qlcnic_83xx_reg_tbl); i++, j++)\r\nregs_buff[i] = QLC_SHARED_REG_RD32(adapter, j);\r\nfor (j = 0; j < ARRAY_SIZE(qlcnic_83xx_ext_reg_tbl); j++)\r\nregs_buff[i++] = QLCRDX(adapter->ahw, j);\r\nreturn i;\r\n}\r\nint qlcnic_83xx_interrupt_test(struct net_device *netdev)\r\n{\r\nstruct qlcnic_adapter *adapter = netdev_priv(netdev);\r\nstruct qlcnic_hardware_context *ahw = adapter->ahw;\r\nstruct qlcnic_cmd_args cmd;\r\nu8 val, drv_sds_rings = adapter->drv_sds_rings;\r\nu8 drv_tx_rings = adapter->drv_tx_rings;\r\nu32 data;\r\nu16 intrpt_id, id;\r\nint ret;\r\nif (test_bit(__QLCNIC_RESETTING, &adapter->state)) {\r\nnetdev_info(netdev, "Device is resetting\n");\r\nreturn -EBUSY;\r\n}\r\nif (qlcnic_get_diag_lock(adapter)) {\r\nnetdev_info(netdev, "Device in diagnostics mode\n");\r\nreturn -EBUSY;\r\n}\r\nret = qlcnic_83xx_diag_alloc_res(netdev, QLCNIC_INTERRUPT_TEST,\r\ndrv_sds_rings);\r\nif (ret)\r\ngoto fail_diag_irq;\r\nahw->diag_cnt = 0;\r\nret = qlcnic_alloc_mbx_args(&cmd, adapter, QLCNIC_CMD_INTRPT_TEST);\r\nif (ret)\r\ngoto fail_diag_irq;\r\nif (adapter->flags & QLCNIC_MSIX_ENABLED)\r\nintrpt_id = ahw->intr_tbl[0].id;\r\nelse\r\nintrpt_id = QLCRDX(ahw, QLCNIC_DEF_INT_ID);\r\ncmd.req.arg[1] = 1;\r\ncmd.req.arg[2] = intrpt_id;\r\ncmd.req.arg[3] = BIT_0;\r\nret = qlcnic_issue_cmd(adapter, &cmd);\r\ndata = cmd.rsp.arg[2];\r\nid = LSW(data);\r\nval = LSB(MSW(data));\r\nif (id != intrpt_id)\r\ndev_info(&adapter->pdev->dev,\r\n"Interrupt generated: 0x%x, requested:0x%x\n",\r\nid, intrpt_id);\r\nif (val)\r\ndev_err(&adapter->pdev->dev,\r\n"Interrupt test error: 0x%x\n", val);\r\nif (ret)\r\ngoto done;\r\nmsleep(20);\r\nret = !ahw->diag_cnt;\r\ndone:\r\nqlcnic_free_mbx_args(&cmd);\r\nqlcnic_83xx_diag_free_res(netdev, drv_sds_rings);\r\nfail_diag_irq:\r\nadapter->drv_sds_rings = drv_sds_rings;\r\nadapter->drv_tx_rings = drv_tx_rings;\r\nqlcnic_release_diag_lock(adapter);\r\nreturn ret;\r\n}\r\nvoid qlcnic_83xx_get_pauseparam(struct qlcnic_adapter *adapter,\r\nstruct ethtool_pauseparam *pause)\r\n{\r\nstruct qlcnic_hardware_context *ahw = adapter->ahw;\r\nint status = 0;\r\nu32 config;\r\nstatus = qlcnic_83xx_get_port_config(adapter);\r\nif (status) {\r\ndev_err(&adapter->pdev->dev,\r\n"%s: Get Pause Config failed\n", __func__);\r\nreturn;\r\n}\r\nconfig = ahw->port_config;\r\nif (config & QLC_83XX_CFG_STD_PAUSE) {\r\nswitch (MSW(config)) {\r\ncase QLC_83XX_TX_PAUSE:\r\npause->tx_pause = 1;\r\nbreak;\r\ncase QLC_83XX_RX_PAUSE:\r\npause->rx_pause = 1;\r\nbreak;\r\ncase QLC_83XX_TX_RX_PAUSE:\r\ndefault:\r\npause->tx_pause = 1;\r\npause->rx_pause = 1;\r\n}\r\n}\r\nif (QLC_83XX_AUTONEG(config))\r\npause->autoneg = 1;\r\n}\r\nint qlcnic_83xx_set_pauseparam(struct qlcnic_adapter *adapter,\r\nstruct ethtool_pauseparam *pause)\r\n{\r\nstruct qlcnic_hardware_context *ahw = adapter->ahw;\r\nint status = 0;\r\nu32 config;\r\nstatus = qlcnic_83xx_get_port_config(adapter);\r\nif (status) {\r\ndev_err(&adapter->pdev->dev,\r\n"%s: Get Pause Config failed.\n", __func__);\r\nreturn status;\r\n}\r\nconfig = ahw->port_config;\r\nif (ahw->port_type == QLCNIC_GBE) {\r\nif (pause->autoneg)\r\nahw->port_config |= QLC_83XX_ENABLE_AUTONEG;\r\nif (!pause->autoneg)\r\nahw->port_config &= ~QLC_83XX_ENABLE_AUTONEG;\r\n} else if ((ahw->port_type == QLCNIC_XGBE) && (pause->autoneg)) {\r\nreturn -EOPNOTSUPP;\r\n}\r\nif (!(config & QLC_83XX_CFG_STD_PAUSE))\r\nahw->port_config |= QLC_83XX_CFG_STD_PAUSE;\r\nif (pause->rx_pause && pause->tx_pause) {\r\nahw->port_config |= QLC_83XX_CFG_STD_TX_RX_PAUSE;\r\n} else if (pause->rx_pause && !pause->tx_pause) {\r\nahw->port_config &= ~QLC_83XX_CFG_STD_TX_PAUSE;\r\nahw->port_config |= QLC_83XX_CFG_STD_RX_PAUSE;\r\n} else if (pause->tx_pause && !pause->rx_pause) {\r\nahw->port_config &= ~QLC_83XX_CFG_STD_RX_PAUSE;\r\nahw->port_config |= QLC_83XX_CFG_STD_TX_PAUSE;\r\n} else if (!pause->rx_pause && !pause->tx_pause) {\r\nahw->port_config &= ~(QLC_83XX_CFG_STD_TX_RX_PAUSE |\r\nQLC_83XX_CFG_STD_PAUSE);\r\n}\r\nstatus = qlcnic_83xx_set_port_config(adapter);\r\nif (status) {\r\ndev_err(&adapter->pdev->dev,\r\n"%s: Set Pause Config failed.\n", __func__);\r\nahw->port_config = config;\r\n}\r\nreturn status;\r\n}\r\nstatic int qlcnic_83xx_read_flash_status_reg(struct qlcnic_adapter *adapter)\r\n{\r\nint ret, err = 0;\r\nu32 temp;\r\nqlcnic_83xx_wrt_reg_indirect(adapter, QLC_83XX_FLASH_ADDR,\r\nQLC_83XX_FLASH_OEM_READ_SIG);\r\nqlcnic_83xx_wrt_reg_indirect(adapter, QLC_83XX_FLASH_CONTROL,\r\nQLC_83XX_FLASH_READ_CTRL);\r\nret = qlcnic_83xx_poll_flash_status_reg(adapter);\r\nif (ret)\r\nreturn -EIO;\r\ntemp = QLCRD32(adapter, QLC_83XX_FLASH_RDDATA, &err);\r\nif (err == -EIO)\r\nreturn err;\r\nreturn temp & 0xFF;\r\n}\r\nint qlcnic_83xx_flash_test(struct qlcnic_adapter *adapter)\r\n{\r\nint status;\r\nstatus = qlcnic_83xx_read_flash_status_reg(adapter);\r\nif (status == -EIO) {\r\ndev_info(&adapter->pdev->dev, "%s: EEPROM test failed.\n",\r\n__func__);\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}\r\nstatic int qlcnic_83xx_shutdown(struct pci_dev *pdev)\r\n{\r\nstruct qlcnic_adapter *adapter = pci_get_drvdata(pdev);\r\nstruct net_device *netdev = adapter->netdev;\r\nint retval;\r\nnetif_device_detach(netdev);\r\nqlcnic_cancel_idc_work(adapter);\r\nif (netif_running(netdev))\r\nqlcnic_down(adapter, netdev);\r\nqlcnic_83xx_disable_mbx_intr(adapter);\r\ncancel_delayed_work_sync(&adapter->idc_aen_work);\r\nretval = pci_save_state(pdev);\r\nif (retval)\r\nreturn retval;\r\nreturn 0;\r\n}\r\nstatic int qlcnic_83xx_resume(struct qlcnic_adapter *adapter)\r\n{\r\nstruct qlcnic_hardware_context *ahw = adapter->ahw;\r\nstruct qlc_83xx_idc *idc = &ahw->idc;\r\nint err = 0;\r\nerr = qlcnic_83xx_idc_init(adapter);\r\nif (err)\r\nreturn err;\r\nif (ahw->nic_mode == QLCNIC_VNIC_MODE) {\r\nif (ahw->op_mode == QLCNIC_MGMT_FUNC) {\r\nqlcnic_83xx_set_vnic_opmode(adapter);\r\n} else {\r\nerr = qlcnic_83xx_check_vnic_state(adapter);\r\nif (err)\r\nreturn err;\r\n}\r\n}\r\nerr = qlcnic_83xx_idc_reattach_driver(adapter);\r\nif (err)\r\nreturn err;\r\nqlcnic_schedule_work(adapter, qlcnic_83xx_idc_poll_dev_state,\r\nidc->delay);\r\nreturn err;\r\n}\r\nvoid qlcnic_83xx_reinit_mbx_work(struct qlcnic_mailbox *mbx)\r\n{\r\nreinit_completion(&mbx->completion);\r\nset_bit(QLC_83XX_MBX_READY, &mbx->status);\r\n}\r\nvoid qlcnic_83xx_free_mailbox(struct qlcnic_mailbox *mbx)\r\n{\r\nif (!mbx)\r\nreturn;\r\ndestroy_workqueue(mbx->work_q);\r\nkfree(mbx);\r\n}\r\nstatic inline void\r\nqlcnic_83xx_notify_cmd_completion(struct qlcnic_adapter *adapter,\r\nstruct qlcnic_cmd_args *cmd)\r\n{\r\natomic_set(&cmd->rsp_status, QLC_83XX_MBX_RESPONSE_ARRIVED);\r\nif (cmd->type == QLC_83XX_MBX_CMD_NO_WAIT) {\r\nqlcnic_free_mbx_args(cmd);\r\nkfree(cmd);\r\nreturn;\r\n}\r\ncomplete(&cmd->completion);\r\n}\r\nstatic void qlcnic_83xx_flush_mbx_queue(struct qlcnic_adapter *adapter)\r\n{\r\nstruct qlcnic_mailbox *mbx = adapter->ahw->mailbox;\r\nstruct list_head *head = &mbx->cmd_q;\r\nstruct qlcnic_cmd_args *cmd = NULL;\r\nspin_lock(&mbx->queue_lock);\r\nwhile (!list_empty(head)) {\r\ncmd = list_entry(head->next, struct qlcnic_cmd_args, list);\r\ndev_info(&adapter->pdev->dev, "%s: Mailbox command 0x%x\n",\r\n__func__, cmd->cmd_op);\r\nlist_del(&cmd->list);\r\nmbx->num_cmds--;\r\nqlcnic_83xx_notify_cmd_completion(adapter, cmd);\r\n}\r\nspin_unlock(&mbx->queue_lock);\r\n}\r\nstatic int qlcnic_83xx_check_mbx_status(struct qlcnic_adapter *adapter)\r\n{\r\nstruct qlcnic_hardware_context *ahw = adapter->ahw;\r\nstruct qlcnic_mailbox *mbx = ahw->mailbox;\r\nu32 host_mbx_ctrl;\r\nif (!test_bit(QLC_83XX_MBX_READY, &mbx->status))\r\nreturn -EBUSY;\r\nhost_mbx_ctrl = QLCRDX(ahw, QLCNIC_HOST_MBX_CTRL);\r\nif (host_mbx_ctrl) {\r\nclear_bit(QLC_83XX_MBX_READY, &mbx->status);\r\nahw->idc.collect_dump = 1;\r\nreturn -EIO;\r\n}\r\nreturn 0;\r\n}\r\nstatic inline void qlcnic_83xx_signal_mbx_cmd(struct qlcnic_adapter *adapter,\r\nu8 issue_cmd)\r\n{\r\nif (issue_cmd)\r\nQLCWRX(adapter->ahw, QLCNIC_HOST_MBX_CTRL, QLCNIC_SET_OWNER);\r\nelse\r\nQLCWRX(adapter->ahw, QLCNIC_FW_MBX_CTRL, QLCNIC_CLR_OWNER);\r\n}\r\nstatic void qlcnic_83xx_dequeue_mbx_cmd(struct qlcnic_adapter *adapter,\r\nstruct qlcnic_cmd_args *cmd)\r\n{\r\nstruct qlcnic_mailbox *mbx = adapter->ahw->mailbox;\r\nspin_lock(&mbx->queue_lock);\r\nlist_del(&cmd->list);\r\nmbx->num_cmds--;\r\nspin_unlock(&mbx->queue_lock);\r\nqlcnic_83xx_notify_cmd_completion(adapter, cmd);\r\n}\r\nstatic void qlcnic_83xx_encode_mbx_cmd(struct qlcnic_adapter *adapter,\r\nstruct qlcnic_cmd_args *cmd)\r\n{\r\nu32 mbx_cmd, fw_hal_version, hdr_size, total_size, tmp;\r\nstruct qlcnic_hardware_context *ahw = adapter->ahw;\r\nint i, j;\r\nif (cmd->op_type != QLC_83XX_MBX_POST_BC_OP) {\r\nmbx_cmd = cmd->req.arg[0];\r\nwritel(mbx_cmd, QLCNIC_MBX_HOST(ahw, 0));\r\nfor (i = 1; i < cmd->req.num; i++)\r\nwritel(cmd->req.arg[i], QLCNIC_MBX_HOST(ahw, i));\r\n} else {\r\nfw_hal_version = ahw->fw_hal_version;\r\nhdr_size = sizeof(struct qlcnic_bc_hdr) / sizeof(u32);\r\ntotal_size = cmd->pay_size + hdr_size;\r\ntmp = QLCNIC_CMD_BC_EVENT_SETUP | total_size << 16;\r\nmbx_cmd = tmp | fw_hal_version << 29;\r\nwritel(mbx_cmd, QLCNIC_MBX_HOST(ahw, 0));\r\nmbx_cmd = 0x1 | 1 << 4;\r\nif (qlcnic_sriov_pf_check(adapter))\r\nmbx_cmd |= cmd->func_num << 5;\r\nwritel(mbx_cmd, QLCNIC_MBX_HOST(ahw, 1));\r\nfor (i = 2, j = 0; j < hdr_size; i++, j++)\r\nwritel(*(cmd->hdr++), QLCNIC_MBX_HOST(ahw, i));\r\nfor (j = 0; j < cmd->pay_size; j++, i++)\r\nwritel(*(cmd->pay++), QLCNIC_MBX_HOST(ahw, i));\r\n}\r\n}\r\nvoid qlcnic_83xx_detach_mailbox_work(struct qlcnic_adapter *adapter)\r\n{\r\nstruct qlcnic_mailbox *mbx = adapter->ahw->mailbox;\r\nif (!mbx)\r\nreturn;\r\nclear_bit(QLC_83XX_MBX_READY, &mbx->status);\r\ncomplete(&mbx->completion);\r\ncancel_work_sync(&mbx->work);\r\nflush_workqueue(mbx->work_q);\r\nqlcnic_83xx_flush_mbx_queue(adapter);\r\n}\r\nstatic int qlcnic_83xx_enqueue_mbx_cmd(struct qlcnic_adapter *adapter,\r\nstruct qlcnic_cmd_args *cmd,\r\nunsigned long *timeout)\r\n{\r\nstruct qlcnic_mailbox *mbx = adapter->ahw->mailbox;\r\nif (test_bit(QLC_83XX_MBX_READY, &mbx->status)) {\r\natomic_set(&cmd->rsp_status, QLC_83XX_MBX_RESPONSE_WAIT);\r\ninit_completion(&cmd->completion);\r\ncmd->rsp_opcode = QLC_83XX_MBX_RESPONSE_UNKNOWN;\r\nspin_lock(&mbx->queue_lock);\r\nlist_add_tail(&cmd->list, &mbx->cmd_q);\r\nmbx->num_cmds++;\r\ncmd->total_cmds = mbx->num_cmds;\r\n*timeout = cmd->total_cmds * QLC_83XX_MBX_TIMEOUT;\r\nqueue_work(mbx->work_q, &mbx->work);\r\nspin_unlock(&mbx->queue_lock);\r\nreturn 0;\r\n}\r\nreturn -EBUSY;\r\n}\r\nstatic int qlcnic_83xx_check_mac_rcode(struct qlcnic_adapter *adapter,\r\nstruct qlcnic_cmd_args *cmd)\r\n{\r\nu8 mac_cmd_rcode;\r\nu32 fw_data;\r\nif (cmd->cmd_op == QLCNIC_CMD_CONFIG_MAC_VLAN) {\r\nfw_data = readl(QLCNIC_MBX_FW(adapter->ahw, 2));\r\nmac_cmd_rcode = (u8)fw_data;\r\nif (mac_cmd_rcode == QLC_83XX_NO_NIC_RESOURCE ||\r\nmac_cmd_rcode == QLC_83XX_MAC_PRESENT ||\r\nmac_cmd_rcode == QLC_83XX_MAC_ABSENT) {\r\ncmd->rsp_opcode = QLCNIC_RCODE_SUCCESS;\r\nreturn QLCNIC_RCODE_SUCCESS;\r\n}\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic void qlcnic_83xx_decode_mbx_rsp(struct qlcnic_adapter *adapter,\r\nstruct qlcnic_cmd_args *cmd)\r\n{\r\nstruct qlcnic_hardware_context *ahw = adapter->ahw;\r\nstruct device *dev = &adapter->pdev->dev;\r\nu8 mbx_err_code;\r\nu32 fw_data;\r\nfw_data = readl(QLCNIC_MBX_FW(ahw, 0));\r\nmbx_err_code = QLCNIC_MBX_STATUS(fw_data);\r\nqlcnic_83xx_get_mbx_data(adapter, cmd);\r\nswitch (mbx_err_code) {\r\ncase QLCNIC_MBX_RSP_OK:\r\ncase QLCNIC_MBX_PORT_RSP_OK:\r\ncmd->rsp_opcode = QLCNIC_RCODE_SUCCESS;\r\nbreak;\r\ndefault:\r\nif (!qlcnic_83xx_check_mac_rcode(adapter, cmd))\r\nbreak;\r\ndev_err(dev, "%s: Mailbox command failed, opcode=0x%x, cmd_type=0x%x, func=0x%x, op_mode=0x%x, error=0x%x\n",\r\n__func__, cmd->cmd_op, cmd->type, ahw->pci_func,\r\nahw->op_mode, mbx_err_code);\r\ncmd->rsp_opcode = QLC_83XX_MBX_RESPONSE_FAILED;\r\nqlcnic_dump_mbx(adapter, cmd);\r\n}\r\nreturn;\r\n}\r\nstatic inline void qlcnic_dump_mailbox_registers(struct qlcnic_adapter *adapter)\r\n{\r\nstruct qlcnic_hardware_context *ahw = adapter->ahw;\r\nu32 offset;\r\noffset = QLCRDX(ahw, QLCNIC_DEF_INT_MASK);\r\ndev_info(&adapter->pdev->dev, "Mbx interrupt mask=0x%x, Mbx interrupt enable=0x%x, Host mbx control=0x%x, Fw mbx control=0x%x",\r\nreadl(ahw->pci_base0 + offset),\r\nQLCRDX(ahw, QLCNIC_MBX_INTR_ENBL),\r\nQLCRDX(ahw, QLCNIC_HOST_MBX_CTRL),\r\nQLCRDX(ahw, QLCNIC_FW_MBX_CTRL));\r\n}\r\nstatic void qlcnic_83xx_mailbox_worker(struct work_struct *work)\r\n{\r\nstruct qlcnic_mailbox *mbx = container_of(work, struct qlcnic_mailbox,\r\nwork);\r\nstruct qlcnic_adapter *adapter = mbx->adapter;\r\nconst struct qlcnic_mbx_ops *mbx_ops = mbx->ops;\r\nstruct device *dev = &adapter->pdev->dev;\r\natomic_t *rsp_status = &mbx->rsp_status;\r\nstruct list_head *head = &mbx->cmd_q;\r\nstruct qlcnic_hardware_context *ahw;\r\nstruct qlcnic_cmd_args *cmd = NULL;\r\nahw = adapter->ahw;\r\nwhile (true) {\r\nif (qlcnic_83xx_check_mbx_status(adapter)) {\r\nqlcnic_83xx_flush_mbx_queue(adapter);\r\nreturn;\r\n}\r\natomic_set(rsp_status, QLC_83XX_MBX_RESPONSE_WAIT);\r\nspin_lock(&mbx->queue_lock);\r\nif (list_empty(head)) {\r\nspin_unlock(&mbx->queue_lock);\r\nreturn;\r\n}\r\ncmd = list_entry(head->next, struct qlcnic_cmd_args, list);\r\nspin_unlock(&mbx->queue_lock);\r\nmbx_ops->encode_cmd(adapter, cmd);\r\nmbx_ops->nofity_fw(adapter, QLC_83XX_MBX_REQUEST);\r\nif (wait_for_completion_timeout(&mbx->completion,\r\nQLC_83XX_MBX_TIMEOUT)) {\r\nmbx_ops->decode_resp(adapter, cmd);\r\nmbx_ops->nofity_fw(adapter, QLC_83XX_MBX_COMPLETION);\r\n} else {\r\ndev_err(dev, "%s: Mailbox command timeout, opcode=0x%x, cmd_type=0x%x, func=0x%x, op_mode=0x%x\n",\r\n__func__, cmd->cmd_op, cmd->type, ahw->pci_func,\r\nahw->op_mode);\r\nclear_bit(QLC_83XX_MBX_READY, &mbx->status);\r\nqlcnic_dump_mailbox_registers(adapter);\r\nqlcnic_83xx_get_mbx_data(adapter, cmd);\r\nqlcnic_dump_mbx(adapter, cmd);\r\nqlcnic_83xx_idc_request_reset(adapter,\r\nQLCNIC_FORCE_FW_DUMP_KEY);\r\ncmd->rsp_opcode = QLCNIC_RCODE_TIMEOUT;\r\n}\r\nmbx_ops->dequeue_cmd(adapter, cmd);\r\n}\r\n}\r\nint qlcnic_83xx_init_mailbox_work(struct qlcnic_adapter *adapter)\r\n{\r\nstruct qlcnic_hardware_context *ahw = adapter->ahw;\r\nstruct qlcnic_mailbox *mbx;\r\nahw->mailbox = kzalloc(sizeof(*mbx), GFP_KERNEL);\r\nif (!ahw->mailbox)\r\nreturn -ENOMEM;\r\nmbx = ahw->mailbox;\r\nmbx->ops = &qlcnic_83xx_mbx_ops;\r\nmbx->adapter = adapter;\r\nspin_lock_init(&mbx->queue_lock);\r\nspin_lock_init(&mbx->aen_lock);\r\nINIT_LIST_HEAD(&mbx->cmd_q);\r\ninit_completion(&mbx->completion);\r\nmbx->work_q = create_singlethread_workqueue("qlcnic_mailbox");\r\nif (mbx->work_q == NULL) {\r\nkfree(mbx);\r\nreturn -ENOMEM;\r\n}\r\nINIT_WORK(&mbx->work, qlcnic_83xx_mailbox_worker);\r\nset_bit(QLC_83XX_MBX_READY, &mbx->status);\r\nreturn 0;\r\n}\r\nstatic pci_ers_result_t qlcnic_83xx_io_error_detected(struct pci_dev *pdev,\r\npci_channel_state_t state)\r\n{\r\nstruct qlcnic_adapter *adapter = pci_get_drvdata(pdev);\r\nif (state == pci_channel_io_perm_failure)\r\nreturn PCI_ERS_RESULT_DISCONNECT;\r\nif (state == pci_channel_io_normal)\r\nreturn PCI_ERS_RESULT_RECOVERED;\r\nset_bit(__QLCNIC_AER, &adapter->state);\r\nset_bit(__QLCNIC_RESETTING, &adapter->state);\r\nqlcnic_83xx_aer_stop_poll_work(adapter);\r\npci_save_state(pdev);\r\npci_disable_device(pdev);\r\nreturn PCI_ERS_RESULT_NEED_RESET;\r\n}\r\nstatic pci_ers_result_t qlcnic_83xx_io_slot_reset(struct pci_dev *pdev)\r\n{\r\nstruct qlcnic_adapter *adapter = pci_get_drvdata(pdev);\r\nint err = 0;\r\npdev->error_state = pci_channel_io_normal;\r\nerr = pci_enable_device(pdev);\r\nif (err)\r\ngoto disconnect;\r\npci_set_power_state(pdev, PCI_D0);\r\npci_set_master(pdev);\r\npci_restore_state(pdev);\r\nerr = qlcnic_83xx_aer_reset(adapter);\r\nif (err == 0)\r\nreturn PCI_ERS_RESULT_RECOVERED;\r\ndisconnect:\r\nclear_bit(__QLCNIC_AER, &adapter->state);\r\nclear_bit(__QLCNIC_RESETTING, &adapter->state);\r\nreturn PCI_ERS_RESULT_DISCONNECT;\r\n}\r\nstatic void qlcnic_83xx_io_resume(struct pci_dev *pdev)\r\n{\r\nstruct qlcnic_adapter *adapter = pci_get_drvdata(pdev);\r\npci_cleanup_aer_uncorrect_error_status(pdev);\r\nif (test_and_clear_bit(__QLCNIC_AER, &adapter->state))\r\nqlcnic_83xx_aer_start_poll_work(adapter);\r\n}
