void via_init_futex(drm_via_private_t *dev_priv)\r\n{\r\nunsigned int i;\r\nDRM_DEBUG("\n");\r\nfor (i = 0; i < VIA_NR_XVMC_LOCKS; ++i) {\r\ninit_waitqueue_head(&(dev_priv->decoder_queue[i]));\r\nXVMCLOCKPTR(dev_priv->sarea_priv, i)->lock = 0;\r\n}\r\n}\r\nvoid via_cleanup_futex(drm_via_private_t *dev_priv)\r\n{\r\n}\r\nvoid via_release_futex(drm_via_private_t *dev_priv, int context)\r\n{\r\nunsigned int i;\r\nvolatile int *lock;\r\nif (!dev_priv->sarea_priv)\r\nreturn;\r\nfor (i = 0; i < VIA_NR_XVMC_LOCKS; ++i) {\r\nlock = (volatile int *)XVMCLOCKPTR(dev_priv->sarea_priv, i);\r\nif ((_DRM_LOCKING_CONTEXT(*lock) == context)) {\r\nif (_DRM_LOCK_IS_HELD(*lock)\r\n&& (*lock & _DRM_LOCK_CONT)) {\r\nwake_up(&(dev_priv->decoder_queue[i]));\r\n}\r\n*lock = 0;\r\n}\r\n}\r\n}\r\nint via_decoder_futex(struct drm_device *dev, void *data, struct drm_file *file_priv)\r\n{\r\ndrm_via_futex_t *fx = data;\r\nvolatile int *lock;\r\ndrm_via_private_t *dev_priv = (drm_via_private_t *) dev->dev_private;\r\ndrm_via_sarea_t *sAPriv = dev_priv->sarea_priv;\r\nint ret = 0;\r\nDRM_DEBUG("\n");\r\nif (fx->lock >= VIA_NR_XVMC_LOCKS)\r\nreturn -EFAULT;\r\nlock = (volatile int *)XVMCLOCKPTR(sAPriv, fx->lock);\r\nswitch (fx->func) {\r\ncase VIA_FUTEX_WAIT:\r\nDRM_WAIT_ON(ret, dev_priv->decoder_queue[fx->lock],\r\n(fx->ms / 10) * (HZ / 100), *lock != fx->val);\r\nreturn ret;\r\ncase VIA_FUTEX_WAKE:\r\nwake_up(&(dev_priv->decoder_queue[fx->lock]));\r\nreturn 0;\r\n}\r\nreturn 0;\r\n}
