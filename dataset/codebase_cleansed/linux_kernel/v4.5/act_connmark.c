static int tcf_connmark(struct sk_buff *skb, const struct tc_action *a,\r\nstruct tcf_result *res)\r\n{\r\nconst struct nf_conntrack_tuple_hash *thash;\r\nstruct nf_conntrack_tuple tuple;\r\nenum ip_conntrack_info ctinfo;\r\nstruct tcf_connmark_info *ca = a->priv;\r\nstruct nf_conntrack_zone zone;\r\nstruct nf_conn *c;\r\nint proto;\r\nspin_lock(&ca->tcf_lock);\r\nca->tcf_tm.lastuse = jiffies;\r\nbstats_update(&ca->tcf_bstats, skb);\r\nif (skb->protocol == htons(ETH_P_IP)) {\r\nif (skb->len < sizeof(struct iphdr))\r\ngoto out;\r\nproto = NFPROTO_IPV4;\r\n} else if (skb->protocol == htons(ETH_P_IPV6)) {\r\nif (skb->len < sizeof(struct ipv6hdr))\r\ngoto out;\r\nproto = NFPROTO_IPV6;\r\n} else {\r\ngoto out;\r\n}\r\nc = nf_ct_get(skb, &ctinfo);\r\nif (c) {\r\nskb->mark = c->mark;\r\nca->tcf_qstats.overlimits++;\r\ngoto out;\r\n}\r\nif (!nf_ct_get_tuplepr(skb, skb_network_offset(skb),\r\nproto, ca->net, &tuple))\r\ngoto out;\r\nzone.id = ca->zone;\r\nzone.dir = NF_CT_DEFAULT_ZONE_DIR;\r\nthash = nf_conntrack_find_get(ca->net, &zone, &tuple);\r\nif (!thash)\r\ngoto out;\r\nc = nf_ct_tuplehash_to_ctrack(thash);\r\nca->tcf_qstats.overlimits++;\r\nskb->mark = c->mark;\r\nnf_ct_put(c);\r\nout:\r\nspin_unlock(&ca->tcf_lock);\r\nreturn ca->tcf_action;\r\n}\r\nstatic int tcf_connmark_init(struct net *net, struct nlattr *nla,\r\nstruct nlattr *est, struct tc_action *a,\r\nint ovr, int bind)\r\n{\r\nstruct nlattr *tb[TCA_CONNMARK_MAX + 1];\r\nstruct tcf_connmark_info *ci;\r\nstruct tc_connmark *parm;\r\nint ret = 0;\r\nif (!nla)\r\nreturn -EINVAL;\r\nret = nla_parse_nested(tb, TCA_CONNMARK_MAX, nla, connmark_policy);\r\nif (ret < 0)\r\nreturn ret;\r\nparm = nla_data(tb[TCA_CONNMARK_PARMS]);\r\nif (!tcf_hash_check(parm->index, a, bind)) {\r\nret = tcf_hash_create(parm->index, est, a, sizeof(*ci),\r\nbind, false);\r\nif (ret)\r\nreturn ret;\r\nci = to_connmark(a);\r\nci->tcf_action = parm->action;\r\nci->net = net;\r\nci->zone = parm->zone;\r\ntcf_hash_insert(a);\r\nret = ACT_P_CREATED;\r\n} else {\r\nci = to_connmark(a);\r\nif (bind)\r\nreturn 0;\r\ntcf_hash_release(a, bind);\r\nif (!ovr)\r\nreturn -EEXIST;\r\nci->tcf_action = parm->action;\r\nci->zone = parm->zone;\r\n}\r\nreturn ret;\r\n}\r\nstatic inline int tcf_connmark_dump(struct sk_buff *skb, struct tc_action *a,\r\nint bind, int ref)\r\n{\r\nunsigned char *b = skb_tail_pointer(skb);\r\nstruct tcf_connmark_info *ci = a->priv;\r\nstruct tc_connmark opt = {\r\n.index = ci->tcf_index,\r\n.refcnt = ci->tcf_refcnt - ref,\r\n.bindcnt = ci->tcf_bindcnt - bind,\r\n.action = ci->tcf_action,\r\n.zone = ci->zone,\r\n};\r\nstruct tcf_t t;\r\nif (nla_put(skb, TCA_CONNMARK_PARMS, sizeof(opt), &opt))\r\ngoto nla_put_failure;\r\nt.install = jiffies_to_clock_t(jiffies - ci->tcf_tm.install);\r\nt.lastuse = jiffies_to_clock_t(jiffies - ci->tcf_tm.lastuse);\r\nt.expires = jiffies_to_clock_t(ci->tcf_tm.expires);\r\nif (nla_put(skb, TCA_CONNMARK_TM, sizeof(t), &t))\r\ngoto nla_put_failure;\r\nreturn skb->len;\r\nnla_put_failure:\r\nnlmsg_trim(skb, b);\r\nreturn -1;\r\n}\r\nstatic int __init connmark_init_module(void)\r\n{\r\nreturn tcf_register_action(&act_connmark_ops, CONNMARK_TAB_MASK);\r\n}\r\nstatic void __exit connmark_cleanup_module(void)\r\n{\r\ntcf_unregister_action(&act_connmark_ops);\r\n}
