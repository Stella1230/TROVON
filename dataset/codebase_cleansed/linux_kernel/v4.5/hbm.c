static const char *mei_hbm_status_str(enum mei_hbm_status status)\r\n{\r\n#define MEI_HBM_STATUS(status) case MEI_HBMS_##status: return #status\r\nswitch (status) {\r\nMEI_HBM_STATUS(SUCCESS);\r\nMEI_HBM_STATUS(CLIENT_NOT_FOUND);\r\nMEI_HBM_STATUS(ALREADY_EXISTS);\r\nMEI_HBM_STATUS(REJECTED);\r\nMEI_HBM_STATUS(INVALID_PARAMETER);\r\nMEI_HBM_STATUS(NOT_ALLOWED);\r\nMEI_HBM_STATUS(ALREADY_STARTED);\r\nMEI_HBM_STATUS(NOT_STARTED);\r\ndefault: return "unknown";\r\n}\r\n#undef MEI_HBM_STATUS\r\n}\r\nstatic const char *mei_cl_conn_status_str(enum mei_cl_connect_status status)\r\n{\r\n#define MEI_CL_CS(status) case MEI_CL_CONN_##status: return #status\r\nswitch (status) {\r\nMEI_CL_CS(SUCCESS);\r\nMEI_CL_CS(NOT_FOUND);\r\nMEI_CL_CS(ALREADY_STARTED);\r\nMEI_CL_CS(OUT_OF_RESOURCES);\r\nMEI_CL_CS(MESSAGE_SMALL);\r\nMEI_CL_CS(NOT_ALLOWED);\r\ndefault: return "unknown";\r\n}\r\n#undef MEI_CL_CCS\r\n}\r\nconst char *mei_hbm_state_str(enum mei_hbm_state state)\r\n{\r\n#define MEI_HBM_STATE(state) case MEI_HBM_##state: return #state\r\nswitch (state) {\r\nMEI_HBM_STATE(IDLE);\r\nMEI_HBM_STATE(STARTING);\r\nMEI_HBM_STATE(STARTED);\r\nMEI_HBM_STATE(ENUM_CLIENTS);\r\nMEI_HBM_STATE(CLIENT_PROPERTIES);\r\nMEI_HBM_STATE(STOPPED);\r\ndefault:\r\nreturn "unknown";\r\n}\r\n#undef MEI_HBM_STATE\r\n}\r\nstatic int mei_cl_conn_status_to_errno(enum mei_cl_connect_status status)\r\n{\r\nswitch (status) {\r\ncase MEI_CL_CONN_SUCCESS: return 0;\r\ncase MEI_CL_CONN_NOT_FOUND: return -ENOTTY;\r\ncase MEI_CL_CONN_ALREADY_STARTED: return -EBUSY;\r\ncase MEI_CL_CONN_OUT_OF_RESOURCES: return -EBUSY;\r\ncase MEI_CL_CONN_MESSAGE_SMALL: return -EINVAL;\r\ncase MEI_CL_CONN_NOT_ALLOWED: return -EBUSY;\r\ndefault: return -EINVAL;\r\n}\r\n}\r\nvoid mei_hbm_idle(struct mei_device *dev)\r\n{\r\ndev->init_clients_timer = 0;\r\ndev->hbm_state = MEI_HBM_IDLE;\r\n}\r\nvoid mei_hbm_reset(struct mei_device *dev)\r\n{\r\ndev->me_client_index = 0;\r\nmei_me_cl_rm_all(dev);\r\nmei_hbm_idle(dev);\r\n}\r\nstatic inline void mei_hbm_hdr(struct mei_msg_hdr *hdr, size_t length)\r\n{\r\nhdr->host_addr = 0;\r\nhdr->me_addr = 0;\r\nhdr->length = length;\r\nhdr->msg_complete = 1;\r\nhdr->reserved = 0;\r\n}\r\nstatic inline\r\nvoid mei_hbm_cl_hdr(struct mei_cl *cl, u8 hbm_cmd, void *buf, size_t len)\r\n{\r\nstruct mei_hbm_cl_cmd *cmd = buf;\r\nmemset(cmd, 0, len);\r\ncmd->hbm_cmd = hbm_cmd;\r\ncmd->host_addr = mei_cl_host_addr(cl);\r\ncmd->me_addr = mei_cl_me_id(cl);\r\n}\r\nstatic inline\r\nint mei_hbm_cl_write(struct mei_device *dev,\r\nstruct mei_cl *cl, u8 hbm_cmd, size_t len)\r\n{\r\nstruct mei_msg_hdr *mei_hdr = &dev->wr_msg.hdr;\r\nmei_hbm_hdr(mei_hdr, len);\r\nmei_hbm_cl_hdr(cl, hbm_cmd, dev->wr_msg.data, len);\r\nreturn mei_write_message(dev, mei_hdr, dev->wr_msg.data);\r\n}\r\nstatic inline\r\nbool mei_hbm_cl_addr_equal(struct mei_cl *cl, struct mei_hbm_cl_cmd *cmd)\r\n{\r\nreturn mei_cl_host_addr(cl) == cmd->host_addr &&\r\nmei_cl_me_id(cl) == cmd->me_addr;\r\n}\r\nstatic inline\r\nstruct mei_cl *mei_hbm_cl_find_by_cmd(struct mei_device *dev, void *buf)\r\n{\r\nstruct mei_hbm_cl_cmd *cmd = (struct mei_hbm_cl_cmd *)buf;\r\nstruct mei_cl *cl;\r\nlist_for_each_entry(cl, &dev->file_list, link)\r\nif (mei_hbm_cl_addr_equal(cl, cmd))\r\nreturn cl;\r\nreturn NULL;\r\n}\r\nint mei_hbm_start_wait(struct mei_device *dev)\r\n{\r\nint ret;\r\nif (dev->hbm_state > MEI_HBM_STARTING)\r\nreturn 0;\r\nmutex_unlock(&dev->device_lock);\r\nret = wait_event_timeout(dev->wait_hbm_start,\r\ndev->hbm_state != MEI_HBM_STARTING,\r\nmei_secs_to_jiffies(MEI_HBM_TIMEOUT));\r\nmutex_lock(&dev->device_lock);\r\nif (ret == 0 && (dev->hbm_state <= MEI_HBM_STARTING)) {\r\ndev->hbm_state = MEI_HBM_IDLE;\r\ndev_err(dev->dev, "waiting for mei start failed\n");\r\nreturn -ETIME;\r\n}\r\nreturn 0;\r\n}\r\nint mei_hbm_start_req(struct mei_device *dev)\r\n{\r\nstruct mei_msg_hdr *mei_hdr = &dev->wr_msg.hdr;\r\nstruct hbm_host_version_request *start_req;\r\nconst size_t len = sizeof(struct hbm_host_version_request);\r\nint ret;\r\nmei_hbm_reset(dev);\r\nmei_hbm_hdr(mei_hdr, len);\r\nstart_req = (struct hbm_host_version_request *)dev->wr_msg.data;\r\nmemset(start_req, 0, len);\r\nstart_req->hbm_cmd = HOST_START_REQ_CMD;\r\nstart_req->host_version.major_version = HBM_MAJOR_VERSION;\r\nstart_req->host_version.minor_version = HBM_MINOR_VERSION;\r\ndev->hbm_state = MEI_HBM_IDLE;\r\nret = mei_write_message(dev, mei_hdr, dev->wr_msg.data);\r\nif (ret) {\r\ndev_err(dev->dev, "version message write failed: ret = %d\n",\r\nret);\r\nreturn ret;\r\n}\r\ndev->hbm_state = MEI_HBM_STARTING;\r\ndev->init_clients_timer = MEI_CLIENTS_INIT_TIMEOUT;\r\nreturn 0;\r\n}\r\nstatic int mei_hbm_enum_clients_req(struct mei_device *dev)\r\n{\r\nstruct mei_msg_hdr *mei_hdr = &dev->wr_msg.hdr;\r\nstruct hbm_host_enum_request *enum_req;\r\nconst size_t len = sizeof(struct hbm_host_enum_request);\r\nint ret;\r\nmei_hbm_hdr(mei_hdr, len);\r\nenum_req = (struct hbm_host_enum_request *)dev->wr_msg.data;\r\nmemset(enum_req, 0, len);\r\nenum_req->hbm_cmd = HOST_ENUM_REQ_CMD;\r\nenum_req->allow_add = dev->hbm_f_dc_supported;\r\nret = mei_write_message(dev, mei_hdr, dev->wr_msg.data);\r\nif (ret) {\r\ndev_err(dev->dev, "enumeration request write failed: ret = %d.\n",\r\nret);\r\nreturn ret;\r\n}\r\ndev->hbm_state = MEI_HBM_ENUM_CLIENTS;\r\ndev->init_clients_timer = MEI_CLIENTS_INIT_TIMEOUT;\r\nreturn 0;\r\n}\r\nstatic int mei_hbm_me_cl_add(struct mei_device *dev,\r\nstruct hbm_props_response *res)\r\n{\r\nstruct mei_me_client *me_cl;\r\nconst uuid_le *uuid = &res->client_properties.protocol_name;\r\nmei_me_cl_rm_by_uuid(dev, uuid);\r\nme_cl = kzalloc(sizeof(struct mei_me_client), GFP_KERNEL);\r\nif (!me_cl)\r\nreturn -ENOMEM;\r\nmei_me_cl_init(me_cl);\r\nme_cl->props = res->client_properties;\r\nme_cl->client_id = res->me_addr;\r\nme_cl->mei_flow_ctrl_creds = 0;\r\nmei_me_cl_add(dev, me_cl);\r\nreturn 0;\r\n}\r\nstatic int mei_hbm_add_cl_resp(struct mei_device *dev, u8 addr, u8 status)\r\n{\r\nstruct mei_msg_hdr *mei_hdr = &dev->wr_msg.hdr;\r\nstruct hbm_add_client_response *resp;\r\nconst size_t len = sizeof(struct hbm_add_client_response);\r\nint ret;\r\ndev_dbg(dev->dev, "adding client response\n");\r\nresp = (struct hbm_add_client_response *)dev->wr_msg.data;\r\nmei_hbm_hdr(mei_hdr, len);\r\nmemset(resp, 0, sizeof(struct hbm_add_client_response));\r\nresp->hbm_cmd = MEI_HBM_ADD_CLIENT_RES_CMD;\r\nresp->me_addr = addr;\r\nresp->status = status;\r\nret = mei_write_message(dev, mei_hdr, dev->wr_msg.data);\r\nif (ret)\r\ndev_err(dev->dev, "add client response write failed: ret = %d\n",\r\nret);\r\nreturn ret;\r\n}\r\nstatic int mei_hbm_fw_add_cl_req(struct mei_device *dev,\r\nstruct hbm_add_client_request *req)\r\n{\r\nint ret;\r\nu8 status = MEI_HBMS_SUCCESS;\r\nBUILD_BUG_ON(sizeof(struct hbm_add_client_request) !=\r\nsizeof(struct hbm_props_response));\r\nret = mei_hbm_me_cl_add(dev, (struct hbm_props_response *)req);\r\nif (ret)\r\nstatus = !MEI_HBMS_SUCCESS;\r\nreturn mei_hbm_add_cl_resp(dev, req->me_addr, status);\r\n}\r\nint mei_hbm_cl_notify_req(struct mei_device *dev,\r\nstruct mei_cl *cl, u8 start)\r\n{\r\nstruct mei_msg_hdr *mei_hdr = &dev->wr_msg.hdr;\r\nstruct hbm_notification_request *req;\r\nconst size_t len = sizeof(struct hbm_notification_request);\r\nint ret;\r\nmei_hbm_hdr(mei_hdr, len);\r\nmei_hbm_cl_hdr(cl, MEI_HBM_NOTIFY_REQ_CMD, dev->wr_msg.data, len);\r\nreq = (struct hbm_notification_request *)dev->wr_msg.data;\r\nreq->start = start;\r\nret = mei_write_message(dev, mei_hdr, dev->wr_msg.data);\r\nif (ret)\r\ndev_err(dev->dev, "notify request failed: ret = %d\n", ret);\r\nreturn ret;\r\n}\r\nstatic inline enum mei_cb_file_ops notify_res_to_fop(struct mei_hbm_cl_cmd *cmd)\r\n{\r\nstruct hbm_notification_response *rs =\r\n(struct hbm_notification_response *)cmd;\r\nreturn mei_cl_notify_req2fop(rs->start);\r\n}\r\nstatic void mei_hbm_cl_notify_start_res(struct mei_device *dev,\r\nstruct mei_cl *cl,\r\nstruct mei_hbm_cl_cmd *cmd)\r\n{\r\nstruct hbm_notification_response *rs =\r\n(struct hbm_notification_response *)cmd;\r\ncl_dbg(dev, cl, "hbm: notify start response status=%d\n", rs->status);\r\nif (rs->status == MEI_HBMS_SUCCESS ||\r\nrs->status == MEI_HBMS_ALREADY_STARTED) {\r\ncl->notify_en = true;\r\ncl->status = 0;\r\n} else {\r\ncl->status = -EINVAL;\r\n}\r\n}\r\nstatic void mei_hbm_cl_notify_stop_res(struct mei_device *dev,\r\nstruct mei_cl *cl,\r\nstruct mei_hbm_cl_cmd *cmd)\r\n{\r\nstruct hbm_notification_response *rs =\r\n(struct hbm_notification_response *)cmd;\r\ncl_dbg(dev, cl, "hbm: notify stop response status=%d\n", rs->status);\r\nif (rs->status == MEI_HBMS_SUCCESS ||\r\nrs->status == MEI_HBMS_NOT_STARTED) {\r\ncl->notify_en = false;\r\ncl->status = 0;\r\n} else {\r\ncl->status = -EINVAL;\r\n}\r\n}\r\nstatic void mei_hbm_cl_notify(struct mei_device *dev,\r\nstruct mei_hbm_cl_cmd *cmd)\r\n{\r\nstruct mei_cl *cl;\r\ncl = mei_hbm_cl_find_by_cmd(dev, cmd);\r\nif (cl)\r\nmei_cl_notify(cl);\r\n}\r\nstatic int mei_hbm_prop_req(struct mei_device *dev)\r\n{\r\nstruct mei_msg_hdr *mei_hdr = &dev->wr_msg.hdr;\r\nstruct hbm_props_request *prop_req;\r\nconst size_t len = sizeof(struct hbm_props_request);\r\nunsigned long next_client_index;\r\nint ret;\r\nnext_client_index = find_next_bit(dev->me_clients_map, MEI_CLIENTS_MAX,\r\ndev->me_client_index);\r\nif (next_client_index == MEI_CLIENTS_MAX) {\r\ndev->hbm_state = MEI_HBM_STARTED;\r\nschedule_work(&dev->init_work);\r\nreturn 0;\r\n}\r\nmei_hbm_hdr(mei_hdr, len);\r\nprop_req = (struct hbm_props_request *)dev->wr_msg.data;\r\nmemset(prop_req, 0, sizeof(struct hbm_props_request));\r\nprop_req->hbm_cmd = HOST_CLIENT_PROPERTIES_REQ_CMD;\r\nprop_req->me_addr = next_client_index;\r\nret = mei_write_message(dev, mei_hdr, dev->wr_msg.data);\r\nif (ret) {\r\ndev_err(dev->dev, "properties request write failed: ret = %d\n",\r\nret);\r\nreturn ret;\r\n}\r\ndev->init_clients_timer = MEI_CLIENTS_INIT_TIMEOUT;\r\ndev->me_client_index = next_client_index;\r\nreturn 0;\r\n}\r\nint mei_hbm_pg(struct mei_device *dev, u8 pg_cmd)\r\n{\r\nstruct mei_msg_hdr *mei_hdr = &dev->wr_msg.hdr;\r\nstruct hbm_power_gate *req;\r\nconst size_t len = sizeof(struct hbm_power_gate);\r\nint ret;\r\nif (!dev->hbm_f_pg_supported)\r\nreturn -EOPNOTSUPP;\r\nmei_hbm_hdr(mei_hdr, len);\r\nreq = (struct hbm_power_gate *)dev->wr_msg.data;\r\nmemset(req, 0, len);\r\nreq->hbm_cmd = pg_cmd;\r\nret = mei_write_message(dev, mei_hdr, dev->wr_msg.data);\r\nif (ret)\r\ndev_err(dev->dev, "power gate command write failed.\n");\r\nreturn ret;\r\n}\r\nstatic int mei_hbm_stop_req(struct mei_device *dev)\r\n{\r\nstruct mei_msg_hdr *mei_hdr = &dev->wr_msg.hdr;\r\nstruct hbm_host_stop_request *req =\r\n(struct hbm_host_stop_request *)dev->wr_msg.data;\r\nconst size_t len = sizeof(struct hbm_host_stop_request);\r\nmei_hbm_hdr(mei_hdr, len);\r\nmemset(req, 0, len);\r\nreq->hbm_cmd = HOST_STOP_REQ_CMD;\r\nreq->reason = DRIVER_STOP_REQUEST;\r\nreturn mei_write_message(dev, mei_hdr, dev->wr_msg.data);\r\n}\r\nint mei_hbm_cl_flow_control_req(struct mei_device *dev, struct mei_cl *cl)\r\n{\r\nconst size_t len = sizeof(struct hbm_flow_control);\r\ncl_dbg(dev, cl, "sending flow control\n");\r\nreturn mei_hbm_cl_write(dev, cl, MEI_FLOW_CONTROL_CMD, len);\r\n}\r\nstatic int mei_hbm_add_single_flow_creds(struct mei_device *dev,\r\nstruct hbm_flow_control *flow)\r\n{\r\nstruct mei_me_client *me_cl;\r\nint rets;\r\nme_cl = mei_me_cl_by_id(dev, flow->me_addr);\r\nif (!me_cl) {\r\ndev_err(dev->dev, "no such me client %d\n",\r\nflow->me_addr);\r\nreturn -ENOENT;\r\n}\r\nif (WARN_ON(me_cl->props.single_recv_buf == 0)) {\r\nrets = -EINVAL;\r\ngoto out;\r\n}\r\nme_cl->mei_flow_ctrl_creds++;\r\ndev_dbg(dev->dev, "recv flow ctrl msg ME %d (single) creds = %d.\n",\r\nflow->me_addr, me_cl->mei_flow_ctrl_creds);\r\nrets = 0;\r\nout:\r\nmei_me_cl_put(me_cl);\r\nreturn rets;\r\n}\r\nstatic void mei_hbm_cl_flow_control_res(struct mei_device *dev,\r\nstruct hbm_flow_control *flow_control)\r\n{\r\nstruct mei_cl *cl;\r\nif (!flow_control->host_addr) {\r\nmei_hbm_add_single_flow_creds(dev, flow_control);\r\nreturn;\r\n}\r\ncl = mei_hbm_cl_find_by_cmd(dev, flow_control);\r\nif (cl) {\r\ncl->mei_flow_ctrl_creds++;\r\ncl_dbg(dev, cl, "flow control creds = %d.\n",\r\ncl->mei_flow_ctrl_creds);\r\n}\r\n}\r\nint mei_hbm_cl_disconnect_req(struct mei_device *dev, struct mei_cl *cl)\r\n{\r\nconst size_t len = sizeof(struct hbm_client_connect_request);\r\nreturn mei_hbm_cl_write(dev, cl, CLIENT_DISCONNECT_REQ_CMD, len);\r\n}\r\nint mei_hbm_cl_disconnect_rsp(struct mei_device *dev, struct mei_cl *cl)\r\n{\r\nconst size_t len = sizeof(struct hbm_client_connect_response);\r\nreturn mei_hbm_cl_write(dev, cl, CLIENT_DISCONNECT_RES_CMD, len);\r\n}\r\nstatic void mei_hbm_cl_disconnect_res(struct mei_device *dev, struct mei_cl *cl,\r\nstruct mei_hbm_cl_cmd *cmd)\r\n{\r\nstruct hbm_client_connect_response *rs =\r\n(struct hbm_client_connect_response *)cmd;\r\ncl_dbg(dev, cl, "hbm: disconnect response status=%d\n", rs->status);\r\nif (rs->status == MEI_CL_DISCONN_SUCCESS)\r\ncl->state = MEI_FILE_DISCONNECT_REPLY;\r\ncl->status = 0;\r\n}\r\nint mei_hbm_cl_connect_req(struct mei_device *dev, struct mei_cl *cl)\r\n{\r\nconst size_t len = sizeof(struct hbm_client_connect_request);\r\nreturn mei_hbm_cl_write(dev, cl, CLIENT_CONNECT_REQ_CMD, len);\r\n}\r\nstatic void mei_hbm_cl_connect_res(struct mei_device *dev, struct mei_cl *cl,\r\nstruct mei_hbm_cl_cmd *cmd)\r\n{\r\nstruct hbm_client_connect_response *rs =\r\n(struct hbm_client_connect_response *)cmd;\r\ncl_dbg(dev, cl, "hbm: connect response status=%s\n",\r\nmei_cl_conn_status_str(rs->status));\r\nif (rs->status == MEI_CL_CONN_SUCCESS)\r\ncl->state = MEI_FILE_CONNECTED;\r\nelse {\r\ncl->state = MEI_FILE_DISCONNECT_REPLY;\r\nif (rs->status == MEI_CL_CONN_NOT_FOUND)\r\nmei_me_cl_del(dev, cl->me_cl);\r\n}\r\ncl->status = mei_cl_conn_status_to_errno(rs->status);\r\n}\r\nstatic void mei_hbm_cl_res(struct mei_device *dev,\r\nstruct mei_hbm_cl_cmd *rs,\r\nenum mei_cb_file_ops fop_type)\r\n{\r\nstruct mei_cl *cl;\r\nstruct mei_cl_cb *cb, *next;\r\ncl = NULL;\r\nlist_for_each_entry_safe(cb, next, &dev->ctrl_rd_list.list, list) {\r\ncl = cb->cl;\r\nif (cb->fop_type != fop_type)\r\ncontinue;\r\nif (mei_hbm_cl_addr_equal(cl, rs)) {\r\nlist_del_init(&cb->list);\r\nbreak;\r\n}\r\n}\r\nif (!cl)\r\nreturn;\r\nswitch (fop_type) {\r\ncase MEI_FOP_CONNECT:\r\nmei_hbm_cl_connect_res(dev, cl, rs);\r\nbreak;\r\ncase MEI_FOP_DISCONNECT:\r\nmei_hbm_cl_disconnect_res(dev, cl, rs);\r\nbreak;\r\ncase MEI_FOP_NOTIFY_START:\r\nmei_hbm_cl_notify_start_res(dev, cl, rs);\r\nbreak;\r\ncase MEI_FOP_NOTIFY_STOP:\r\nmei_hbm_cl_notify_stop_res(dev, cl, rs);\r\nbreak;\r\ndefault:\r\nreturn;\r\n}\r\ncl->timer_count = 0;\r\nwake_up(&cl->wait);\r\n}\r\nstatic int mei_hbm_fw_disconnect_req(struct mei_device *dev,\r\nstruct hbm_client_connect_request *disconnect_req)\r\n{\r\nstruct mei_cl *cl;\r\nstruct mei_cl_cb *cb;\r\ncl = mei_hbm_cl_find_by_cmd(dev, disconnect_req);\r\nif (cl) {\r\ncl_dbg(dev, cl, "fw disconnect request received\n");\r\ncl->state = MEI_FILE_DISCONNECTING;\r\ncl->timer_count = 0;\r\ncb = mei_io_cb_init(cl, MEI_FOP_DISCONNECT_RSP, NULL);\r\nif (!cb)\r\nreturn -ENOMEM;\r\ncl_dbg(dev, cl, "add disconnect response as first\n");\r\nlist_add(&cb->list, &dev->ctrl_wr_list.list);\r\n}\r\nreturn 0;\r\n}\r\nstatic int mei_hbm_pg_enter_res(struct mei_device *dev)\r\n{\r\nif (mei_pg_state(dev) != MEI_PG_OFF ||\r\ndev->pg_event != MEI_PG_EVENT_WAIT) {\r\ndev_err(dev->dev, "hbm: pg entry response: state mismatch [%s, %d]\n",\r\nmei_pg_state_str(mei_pg_state(dev)), dev->pg_event);\r\nreturn -EPROTO;\r\n}\r\ndev->pg_event = MEI_PG_EVENT_RECEIVED;\r\nwake_up(&dev->wait_pg);\r\nreturn 0;\r\n}\r\nvoid mei_hbm_pg_resume(struct mei_device *dev)\r\n{\r\npm_request_resume(dev->dev);\r\n}\r\nstatic int mei_hbm_pg_exit_res(struct mei_device *dev)\r\n{\r\nif (mei_pg_state(dev) != MEI_PG_ON ||\r\n(dev->pg_event != MEI_PG_EVENT_WAIT &&\r\ndev->pg_event != MEI_PG_EVENT_IDLE)) {\r\ndev_err(dev->dev, "hbm: pg exit response: state mismatch [%s, %d]\n",\r\nmei_pg_state_str(mei_pg_state(dev)), dev->pg_event);\r\nreturn -EPROTO;\r\n}\r\nswitch (dev->pg_event) {\r\ncase MEI_PG_EVENT_WAIT:\r\ndev->pg_event = MEI_PG_EVENT_RECEIVED;\r\nwake_up(&dev->wait_pg);\r\nbreak;\r\ncase MEI_PG_EVENT_IDLE:\r\ndev->pg_event = MEI_PG_EVENT_RECEIVED;\r\nmei_hbm_pg_resume(dev);\r\nbreak;\r\ndefault:\r\nWARN(1, "hbm: pg exit response: unexpected pg event = %d\n",\r\ndev->pg_event);\r\nreturn -EPROTO;\r\n}\r\nreturn 0;\r\n}\r\nstatic void mei_hbm_config_features(struct mei_device *dev)\r\n{\r\ndev->hbm_f_pg_supported = 0;\r\nif (dev->version.major_version > HBM_MAJOR_VERSION_PGI)\r\ndev->hbm_f_pg_supported = 1;\r\nif (dev->version.major_version == HBM_MAJOR_VERSION_PGI &&\r\ndev->version.minor_version >= HBM_MINOR_VERSION_PGI)\r\ndev->hbm_f_pg_supported = 1;\r\nif (dev->version.major_version >= HBM_MAJOR_VERSION_DC)\r\ndev->hbm_f_dc_supported = 1;\r\nif (dev->version.major_version >= HBM_MAJOR_VERSION_DOT)\r\ndev->hbm_f_dot_supported = 1;\r\nif (dev->version.major_version >= HBM_MAJOR_VERSION_EV)\r\ndev->hbm_f_ev_supported = 1;\r\n}\r\nbool mei_hbm_version_is_supported(struct mei_device *dev)\r\n{\r\nreturn (dev->version.major_version < HBM_MAJOR_VERSION) ||\r\n(dev->version.major_version == HBM_MAJOR_VERSION &&\r\ndev->version.minor_version <= HBM_MINOR_VERSION);\r\n}\r\nint mei_hbm_dispatch(struct mei_device *dev, struct mei_msg_hdr *hdr)\r\n{\r\nstruct mei_bus_message *mei_msg;\r\nstruct hbm_host_version_response *version_res;\r\nstruct hbm_props_response *props_res;\r\nstruct hbm_host_enum_response *enum_res;\r\nstruct hbm_add_client_request *add_cl_req;\r\nint ret;\r\nstruct mei_hbm_cl_cmd *cl_cmd;\r\nstruct hbm_client_connect_request *disconnect_req;\r\nstruct hbm_flow_control *flow_control;\r\nBUG_ON(hdr->length >= sizeof(dev->rd_msg_buf));\r\nmei_read_slots(dev, dev->rd_msg_buf, hdr->length);\r\nmei_msg = (struct mei_bus_message *)dev->rd_msg_buf;\r\ncl_cmd = (struct mei_hbm_cl_cmd *)mei_msg;\r\nif (dev->hbm_state == MEI_HBM_IDLE) {\r\ndev_dbg(dev->dev, "hbm: state is idle ignore spurious messages\n");\r\nreturn 0;\r\n}\r\nswitch (mei_msg->hbm_cmd) {\r\ncase HOST_START_RES_CMD:\r\ndev_dbg(dev->dev, "hbm: start: response message received.\n");\r\ndev->init_clients_timer = 0;\r\nversion_res = (struct hbm_host_version_response *)mei_msg;\r\ndev_dbg(dev->dev, "HBM VERSION: DRIVER=%02d:%02d DEVICE=%02d:%02d\n",\r\nHBM_MAJOR_VERSION, HBM_MINOR_VERSION,\r\nversion_res->me_max_version.major_version,\r\nversion_res->me_max_version.minor_version);\r\nif (version_res->host_version_supported) {\r\ndev->version.major_version = HBM_MAJOR_VERSION;\r\ndev->version.minor_version = HBM_MINOR_VERSION;\r\n} else {\r\ndev->version.major_version =\r\nversion_res->me_max_version.major_version;\r\ndev->version.minor_version =\r\nversion_res->me_max_version.minor_version;\r\n}\r\nif (!mei_hbm_version_is_supported(dev)) {\r\ndev_warn(dev->dev, "hbm: start: version mismatch - stopping the driver.\n");\r\ndev->hbm_state = MEI_HBM_STOPPED;\r\nif (mei_hbm_stop_req(dev)) {\r\ndev_err(dev->dev, "hbm: start: failed to send stop request\n");\r\nreturn -EIO;\r\n}\r\nbreak;\r\n}\r\nmei_hbm_config_features(dev);\r\nif (dev->dev_state != MEI_DEV_INIT_CLIENTS ||\r\ndev->hbm_state != MEI_HBM_STARTING) {\r\ndev_err(dev->dev, "hbm: start: state mismatch, [%d, %d]\n",\r\ndev->dev_state, dev->hbm_state);\r\nreturn -EPROTO;\r\n}\r\nif (mei_hbm_enum_clients_req(dev)) {\r\ndev_err(dev->dev, "hbm: start: failed to send enumeration request\n");\r\nreturn -EIO;\r\n}\r\nwake_up(&dev->wait_hbm_start);\r\nbreak;\r\ncase CLIENT_CONNECT_RES_CMD:\r\ndev_dbg(dev->dev, "hbm: client connect response: message received.\n");\r\nmei_hbm_cl_res(dev, cl_cmd, MEI_FOP_CONNECT);\r\nbreak;\r\ncase CLIENT_DISCONNECT_RES_CMD:\r\ndev_dbg(dev->dev, "hbm: client disconnect response: message received.\n");\r\nmei_hbm_cl_res(dev, cl_cmd, MEI_FOP_DISCONNECT);\r\nbreak;\r\ncase MEI_FLOW_CONTROL_CMD:\r\ndev_dbg(dev->dev, "hbm: client flow control response: message received.\n");\r\nflow_control = (struct hbm_flow_control *) mei_msg;\r\nmei_hbm_cl_flow_control_res(dev, flow_control);\r\nbreak;\r\ncase MEI_PG_ISOLATION_ENTRY_RES_CMD:\r\ndev_dbg(dev->dev, "hbm: power gate isolation entry response received\n");\r\nret = mei_hbm_pg_enter_res(dev);\r\nif (ret)\r\nreturn ret;\r\nbreak;\r\ncase MEI_PG_ISOLATION_EXIT_REQ_CMD:\r\ndev_dbg(dev->dev, "hbm: power gate isolation exit request received\n");\r\nret = mei_hbm_pg_exit_res(dev);\r\nif (ret)\r\nreturn ret;\r\nbreak;\r\ncase HOST_CLIENT_PROPERTIES_RES_CMD:\r\ndev_dbg(dev->dev, "hbm: properties response: message received.\n");\r\ndev->init_clients_timer = 0;\r\nif (dev->dev_state != MEI_DEV_INIT_CLIENTS ||\r\ndev->hbm_state != MEI_HBM_CLIENT_PROPERTIES) {\r\ndev_err(dev->dev, "hbm: properties response: state mismatch, [%d, %d]\n",\r\ndev->dev_state, dev->hbm_state);\r\nreturn -EPROTO;\r\n}\r\nprops_res = (struct hbm_props_response *)mei_msg;\r\nif (props_res->status) {\r\ndev_err(dev->dev, "hbm: properties response: wrong status = %d %s\n",\r\nprops_res->status,\r\nmei_hbm_status_str(props_res->status));\r\nreturn -EPROTO;\r\n}\r\nmei_hbm_me_cl_add(dev, props_res);\r\ndev->me_client_index++;\r\nif (mei_hbm_prop_req(dev))\r\nreturn -EIO;\r\nbreak;\r\ncase HOST_ENUM_RES_CMD:\r\ndev_dbg(dev->dev, "hbm: enumeration response: message received\n");\r\ndev->init_clients_timer = 0;\r\nenum_res = (struct hbm_host_enum_response *) mei_msg;\r\nBUILD_BUG_ON(sizeof(dev->me_clients_map)\r\n< sizeof(enum_res->valid_addresses));\r\nmemcpy(dev->me_clients_map, enum_res->valid_addresses,\r\nsizeof(enum_res->valid_addresses));\r\nif (dev->dev_state != MEI_DEV_INIT_CLIENTS ||\r\ndev->hbm_state != MEI_HBM_ENUM_CLIENTS) {\r\ndev_err(dev->dev, "hbm: enumeration response: state mismatch, [%d, %d]\n",\r\ndev->dev_state, dev->hbm_state);\r\nreturn -EPROTO;\r\n}\r\ndev->hbm_state = MEI_HBM_CLIENT_PROPERTIES;\r\nif (mei_hbm_prop_req(dev))\r\nreturn -EIO;\r\nbreak;\r\ncase HOST_STOP_RES_CMD:\r\ndev_dbg(dev->dev, "hbm: stop response: message received\n");\r\ndev->init_clients_timer = 0;\r\nif (dev->hbm_state != MEI_HBM_STOPPED) {\r\ndev_err(dev->dev, "hbm: stop response: state mismatch, [%d, %d]\n",\r\ndev->dev_state, dev->hbm_state);\r\nreturn -EPROTO;\r\n}\r\ndev->dev_state = MEI_DEV_POWER_DOWN;\r\ndev_info(dev->dev, "hbm: stop response: resetting.\n");\r\nreturn -EPROTO;\r\nbreak;\r\ncase CLIENT_DISCONNECT_REQ_CMD:\r\ndev_dbg(dev->dev, "hbm: disconnect request: message received\n");\r\ndisconnect_req = (struct hbm_client_connect_request *)mei_msg;\r\nmei_hbm_fw_disconnect_req(dev, disconnect_req);\r\nbreak;\r\ncase ME_STOP_REQ_CMD:\r\ndev_dbg(dev->dev, "hbm: stop request: message received\n");\r\ndev->hbm_state = MEI_HBM_STOPPED;\r\nif (mei_hbm_stop_req(dev)) {\r\ndev_err(dev->dev, "hbm: stop request: failed to send stop request\n");\r\nreturn -EIO;\r\n}\r\nbreak;\r\ncase MEI_HBM_ADD_CLIENT_REQ_CMD:\r\ndev_dbg(dev->dev, "hbm: add client request received\n");\r\nif (dev->hbm_state <= MEI_HBM_ENUM_CLIENTS ||\r\ndev->hbm_state >= MEI_HBM_STOPPED) {\r\ndev_err(dev->dev, "hbm: add client: state mismatch, [%d, %d]\n",\r\ndev->dev_state, dev->hbm_state);\r\nreturn -EPROTO;\r\n}\r\nadd_cl_req = (struct hbm_add_client_request *)mei_msg;\r\nret = mei_hbm_fw_add_cl_req(dev, add_cl_req);\r\nif (ret) {\r\ndev_err(dev->dev, "hbm: add client: failed to send response %d\n",\r\nret);\r\nreturn -EIO;\r\n}\r\ndev_dbg(dev->dev, "hbm: add client request processed\n");\r\nbreak;\r\ncase MEI_HBM_NOTIFY_RES_CMD:\r\ndev_dbg(dev->dev, "hbm: notify response received\n");\r\nmei_hbm_cl_res(dev, cl_cmd, notify_res_to_fop(cl_cmd));\r\nbreak;\r\ncase MEI_HBM_NOTIFICATION_CMD:\r\ndev_dbg(dev->dev, "hbm: notification\n");\r\nmei_hbm_cl_notify(dev, cl_cmd);\r\nbreak;\r\ndefault:\r\nBUG();\r\nbreak;\r\n}\r\nreturn 0;\r\n}
