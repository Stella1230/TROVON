static void *virt_map(u64 address)\r\n{\r\nif (address & (1UL << 63))\r\nreturn (void *) (__IA64_UNCACHED_OFFSET | address);\r\nreturn __va(address);\r\n}\r\nstatic void aml_nfw_execute(struct ia64_nfw_context *c)\r\n{\r\nstruct ia64_pdesc virt_entry;\r\nia64_sal_handler entry;\r\nvirt_entry.ip = virt_map(c->ip);\r\nvirt_entry.gp = virt_map(c->gp);\r\nentry = (ia64_sal_handler) &virt_entry;\r\nIA64_FW_CALL(entry, c->ret,\r\nc->arg[0], c->arg[1], c->arg[2], c->arg[3],\r\nc->arg[4], c->arg[5], c->arg[6], c->arg[7]);\r\n}\r\nstatic void aml_nfw_read_arg(u8 *offset, u32 bit_width, u64 *value)\r\n{\r\nswitch (bit_width) {\r\ncase 8:\r\n*value = *(u8 *)offset;\r\nbreak;\r\ncase 16:\r\n*value = *(u16 *)offset;\r\nbreak;\r\ncase 32:\r\n*value = *(u32 *)offset;\r\nbreak;\r\ncase 64:\r\n*value = *(u64 *)offset;\r\nbreak;\r\n}\r\n}\r\nstatic void aml_nfw_write_arg(u8 *offset, u32 bit_width, u64 *value)\r\n{\r\nswitch (bit_width) {\r\ncase 8:\r\n*(u8 *) offset = *value;\r\nbreak;\r\ncase 16:\r\n*(u16 *) offset = *value;\r\nbreak;\r\ncase 32:\r\n*(u32 *) offset = *value;\r\nbreak;\r\ncase 64:\r\n*(u64 *) offset = *value;\r\nbreak;\r\n}\r\n}\r\nstatic acpi_status aml_nfw_handler(u32 function, acpi_physical_address address,\r\nu32 bit_width, u64 *value, void *handler_context,\r\nvoid *region_context)\r\n{\r\nstruct ia64_nfw_context *context = handler_context;\r\nu8 *offset = (u8 *) context + address;\r\nif (bit_width != 8 && bit_width != 16 &&\r\nbit_width != 32 && bit_width != 64)\r\nreturn AE_BAD_PARAMETER;\r\nif (address + (bit_width >> 3) > sizeof(struct ia64_nfw_context))\r\nreturn AE_BAD_PARAMETER;\r\nswitch (function) {\r\ncase ACPI_READ:\r\nif (address == offsetof(struct ia64_nfw_context, ret))\r\naml_nfw_execute(context);\r\naml_nfw_read_arg(offset, bit_width, value);\r\nbreak;\r\ncase ACPI_WRITE:\r\naml_nfw_write_arg(offset, bit_width, value);\r\nbreak;\r\n}\r\nreturn AE_OK;\r\n}\r\nstatic int aml_nfw_add_global_handler(void)\r\n{\r\nacpi_status status;\r\nif (global_handler_registered)\r\nreturn 0;\r\nstatus = acpi_install_address_space_handler(ACPI_ROOT_OBJECT,\r\nAML_NFW_SPACE, aml_nfw_handler, NULL, &global_context);\r\nif (ACPI_FAILURE(status))\r\nreturn -ENODEV;\r\nglobal_handler_registered = 1;\r\nprintk(KERN_INFO "Global 0x%02X opregion handler registered\n",\r\nAML_NFW_SPACE);\r\nreturn 0;\r\n}\r\nstatic int aml_nfw_remove_global_handler(void)\r\n{\r\nacpi_status status;\r\nif (!global_handler_registered)\r\nreturn 0;\r\nstatus = acpi_remove_address_space_handler(ACPI_ROOT_OBJECT,\r\nAML_NFW_SPACE, aml_nfw_handler);\r\nif (ACPI_FAILURE(status))\r\nreturn -ENODEV;\r\nglobal_handler_registered = 0;\r\nprintk(KERN_INFO "Global 0x%02X opregion handler removed\n",\r\nAML_NFW_SPACE);\r\nreturn 0;\r\n}\r\nstatic int aml_nfw_add(struct acpi_device *device)\r\n{\r\nreturn aml_nfw_add_global_handler();\r\n}\r\nstatic int aml_nfw_remove(struct acpi_device *device)\r\n{\r\nreturn aml_nfw_remove_global_handler();\r\n}\r\nstatic int __init aml_nfw_init(void)\r\n{\r\nint result;\r\nif (force_register)\r\naml_nfw_add_global_handler();\r\nresult = acpi_bus_register_driver(&acpi_aml_nfw_driver);\r\nif (result < 0) {\r\naml_nfw_remove_global_handler();\r\nreturn result;\r\n}\r\nreturn 0;\r\n}\r\nstatic void __exit aml_nfw_exit(void)\r\n{\r\nacpi_bus_unregister_driver(&acpi_aml_nfw_driver);\r\naml_nfw_remove_global_handler();\r\n}
