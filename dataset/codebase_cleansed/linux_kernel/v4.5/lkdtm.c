static unsigned int jp_do_irq(unsigned int irq)\r\n{\r\nlkdtm_handler();\r\njprobe_return();\r\nreturn 0;\r\n}\r\nstatic irqreturn_t jp_handle_irq_event(unsigned int irq,\r\nstruct irqaction *action)\r\n{\r\nlkdtm_handler();\r\njprobe_return();\r\nreturn 0;\r\n}\r\nstatic void jp_tasklet_action(struct softirq_action *a)\r\n{\r\nlkdtm_handler();\r\njprobe_return();\r\n}\r\nstatic void jp_ll_rw_block(int rw, int nr, struct buffer_head *bhs[])\r\n{\r\nlkdtm_handler();\r\njprobe_return();\r\n}\r\nstatic unsigned long jp_shrink_inactive_list(unsigned long max_scan,\r\nstruct zone *zone,\r\nstruct scan_control *sc)\r\n{\r\nlkdtm_handler();\r\njprobe_return();\r\nreturn 0;\r\n}\r\nstatic int jp_hrtimer_start(struct hrtimer *timer, ktime_t tim,\r\nconst enum hrtimer_mode mode)\r\n{\r\nlkdtm_handler();\r\njprobe_return();\r\nreturn 0;\r\n}\r\nstatic int jp_scsi_dispatch_cmd(struct scsi_cmnd *cmd)\r\n{\r\nlkdtm_handler();\r\njprobe_return();\r\nreturn 0;\r\n}\r\nstatic int jp_generic_ide_ioctl(ide_drive_t *drive, struct file *file,\r\nstruct block_device *bdev, unsigned int cmd,\r\nunsigned long arg)\r\n{\r\nlkdtm_handler();\r\njprobe_return();\r\nreturn 0;\r\n}\r\nstatic enum ctype parse_cp_type(const char *what, size_t count)\r\n{\r\nint i;\r\nfor (i = 0; i < ARRAY_SIZE(cp_type); i++) {\r\nif (!strcmp(what, cp_type[i]))\r\nreturn i + 1;\r\n}\r\nreturn CT_NONE;\r\n}\r\nstatic const char *cp_type_to_str(enum ctype type)\r\n{\r\nif (type == CT_NONE || type < 0 || type > ARRAY_SIZE(cp_type))\r\nreturn "None";\r\nreturn cp_type[type - 1];\r\n}\r\nstatic const char *cp_name_to_str(enum cname name)\r\n{\r\nif (name == CN_INVALID || name < 0 || name > ARRAY_SIZE(cp_name))\r\nreturn "INVALID";\r\nreturn cp_name[name - 1];\r\n}\r\nstatic int lkdtm_parse_commandline(void)\r\n{\r\nint i;\r\nunsigned long flags;\r\nif (cpoint_count < 1 || recur_count < 1)\r\nreturn -EINVAL;\r\nspin_lock_irqsave(&count_lock, flags);\r\ncount = cpoint_count;\r\nspin_unlock_irqrestore(&count_lock, flags);\r\nif (!cpoint_type && !cpoint_name)\r\nreturn 0;\r\nif (!cpoint_type || !cpoint_name)\r\nreturn -EINVAL;\r\ncptype = parse_cp_type(cpoint_type, strlen(cpoint_type));\r\nif (cptype == CT_NONE)\r\nreturn -EINVAL;\r\nfor (i = 0; i < ARRAY_SIZE(cp_name); i++) {\r\nif (!strcmp(cpoint_name, cp_name[i])) {\r\ncpoint = i + 1;\r\nreturn 0;\r\n}\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int recursive_loop(int remaining)\r\n{\r\nchar buf[REC_STACK_SIZE];\r\nmemset(buf, (remaining & 0xff) | 0x1, REC_STACK_SIZE);\r\nif (!remaining)\r\nreturn 0;\r\nelse\r\nreturn recursive_loop(remaining - 1);\r\n}\r\nstatic void do_nothing(void)\r\n{\r\nreturn;\r\n}\r\nstatic void do_overwritten(void)\r\n{\r\npr_info("do_overwritten wasn't overwritten!\n");\r\nreturn;\r\n}\r\nstatic noinline void corrupt_stack(void)\r\n{\r\nchar data[8];\r\nmemset((void *)data, 0, 64);\r\n}\r\nstatic void execute_location(void *dst)\r\n{\r\nvoid (*func)(void) = dst;\r\npr_info("attempting ok execution at %p\n", do_nothing);\r\ndo_nothing();\r\nmemcpy(dst, do_nothing, EXEC_SIZE);\r\nflush_icache_range((unsigned long)dst, (unsigned long)dst + EXEC_SIZE);\r\npr_info("attempting bad execution at %p\n", func);\r\nfunc();\r\n}\r\nstatic void execute_user_location(void *dst)\r\n{\r\nvoid (*func)(void) = dst;\r\npr_info("attempting ok execution at %p\n", do_nothing);\r\ndo_nothing();\r\nif (copy_to_user((void __user *)dst, do_nothing, EXEC_SIZE))\r\nreturn;\r\nflush_icache_range((unsigned long)dst, (unsigned long)dst + EXEC_SIZE);\r\npr_info("attempting bad execution at %p\n", func);\r\nfunc();\r\n}\r\nstatic void lkdtm_do_action(enum ctype which)\r\n{\r\nswitch (which) {\r\ncase CT_PANIC:\r\npanic("dumptest");\r\nbreak;\r\ncase CT_BUG:\r\nBUG();\r\nbreak;\r\ncase CT_WARNING:\r\nWARN_ON(1);\r\nbreak;\r\ncase CT_EXCEPTION:\r\n*((int *) 0) = 0;\r\nbreak;\r\ncase CT_LOOP:\r\nfor (;;)\r\n;\r\nbreak;\r\ncase CT_OVERFLOW:\r\n(void) recursive_loop(recur_count);\r\nbreak;\r\ncase CT_CORRUPT_STACK:\r\ncorrupt_stack();\r\nbreak;\r\ncase CT_UNALIGNED_LOAD_STORE_WRITE: {\r\nstatic u8 data[5] __attribute__((aligned(4))) = {1, 2,\r\n3, 4, 5};\r\nu32 *p;\r\nu32 val = 0x12345678;\r\np = (u32 *)(data + 1);\r\nif (*p == 0)\r\nval = 0x87654321;\r\n*p = val;\r\nbreak;\r\n}\r\ncase CT_OVERWRITE_ALLOCATION: {\r\nsize_t len = 1020;\r\nu32 *data = kmalloc(len, GFP_KERNEL);\r\ndata[1024 / sizeof(u32)] = 0x12345678;\r\nkfree(data);\r\nbreak;\r\n}\r\ncase CT_WRITE_AFTER_FREE: {\r\nsize_t len = 1024;\r\nu32 *data = kmalloc(len, GFP_KERNEL);\r\nkfree(data);\r\nschedule();\r\nmemset(data, 0x78, len);\r\nbreak;\r\n}\r\ncase CT_SOFTLOCKUP:\r\npreempt_disable();\r\nfor (;;)\r\ncpu_relax();\r\nbreak;\r\ncase CT_HARDLOCKUP:\r\nlocal_irq_disable();\r\nfor (;;)\r\ncpu_relax();\r\nbreak;\r\ncase CT_SPINLOCKUP:\r\nspin_lock(&lock_me_up);\r\n__release(&lock_me_up);\r\nbreak;\r\ncase CT_HUNG_TASK:\r\nset_current_state(TASK_UNINTERRUPTIBLE);\r\nschedule();\r\nbreak;\r\ncase CT_EXEC_DATA:\r\nexecute_location(data_area);\r\nbreak;\r\ncase CT_EXEC_STACK: {\r\nu8 stack_area[EXEC_SIZE];\r\nexecute_location(stack_area);\r\nbreak;\r\n}\r\ncase CT_EXEC_KMALLOC: {\r\nu32 *kmalloc_area = kmalloc(EXEC_SIZE, GFP_KERNEL);\r\nexecute_location(kmalloc_area);\r\nkfree(kmalloc_area);\r\nbreak;\r\n}\r\ncase CT_EXEC_VMALLOC: {\r\nu32 *vmalloc_area = vmalloc(EXEC_SIZE);\r\nexecute_location(vmalloc_area);\r\nvfree(vmalloc_area);\r\nbreak;\r\n}\r\ncase CT_EXEC_USERSPACE: {\r\nunsigned long user_addr;\r\nuser_addr = vm_mmap(NULL, 0, PAGE_SIZE,\r\nPROT_READ | PROT_WRITE | PROT_EXEC,\r\nMAP_ANONYMOUS | MAP_PRIVATE, 0);\r\nif (user_addr >= TASK_SIZE) {\r\npr_warn("Failed to allocate user memory\n");\r\nreturn;\r\n}\r\nexecute_user_location((void *)user_addr);\r\nvm_munmap(user_addr, PAGE_SIZE);\r\nbreak;\r\n}\r\ncase CT_ACCESS_USERSPACE: {\r\nunsigned long user_addr, tmp = 0;\r\nunsigned long *ptr;\r\nuser_addr = vm_mmap(NULL, 0, PAGE_SIZE,\r\nPROT_READ | PROT_WRITE | PROT_EXEC,\r\nMAP_ANONYMOUS | MAP_PRIVATE, 0);\r\nif (user_addr >= TASK_SIZE) {\r\npr_warn("Failed to allocate user memory\n");\r\nreturn;\r\n}\r\nif (copy_to_user((void __user *)user_addr, &tmp, sizeof(tmp))) {\r\npr_warn("copy_to_user failed\n");\r\nvm_munmap(user_addr, PAGE_SIZE);\r\nreturn;\r\n}\r\nptr = (unsigned long *)user_addr;\r\npr_info("attempting bad read at %p\n", ptr);\r\ntmp = *ptr;\r\ntmp += 0xc0dec0de;\r\npr_info("attempting bad write at %p\n", ptr);\r\n*ptr = tmp;\r\nvm_munmap(user_addr, PAGE_SIZE);\r\nbreak;\r\n}\r\ncase CT_WRITE_RO: {\r\nunsigned long *ptr;\r\nptr = (unsigned long *)&rodata;\r\npr_info("attempting bad write at %p\n", ptr);\r\n*ptr ^= 0xabcd1234;\r\nbreak;\r\n}\r\ncase CT_WRITE_KERN: {\r\nsize_t size;\r\nunsigned char *ptr;\r\nsize = (unsigned long)do_overwritten -\r\n(unsigned long)do_nothing;\r\nptr = (unsigned char *)do_overwritten;\r\npr_info("attempting bad %zu byte write at %p\n", size, ptr);\r\nmemcpy(ptr, (unsigned char *)do_nothing, size);\r\nflush_icache_range((unsigned long)ptr,\r\n(unsigned long)(ptr + size));\r\ndo_overwritten();\r\nbreak;\r\n}\r\ncase CT_NONE:\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nstatic void lkdtm_handler(void)\r\n{\r\nunsigned long flags;\r\nbool do_it = false;\r\nspin_lock_irqsave(&count_lock, flags);\r\ncount--;\r\npr_info("Crash point %s of type %s hit, trigger in %d rounds\n",\r\ncp_name_to_str(cpoint), cp_type_to_str(cptype), count);\r\nif (count == 0) {\r\ndo_it = true;\r\ncount = cpoint_count;\r\n}\r\nspin_unlock_irqrestore(&count_lock, flags);\r\nif (do_it)\r\nlkdtm_do_action(cptype);\r\n}\r\nstatic int lkdtm_register_cpoint(enum cname which)\r\n{\r\nint ret;\r\ncpoint = CN_INVALID;\r\nif (lkdtm.entry != NULL)\r\nunregister_jprobe(&lkdtm);\r\nswitch (which) {\r\ncase CN_DIRECT:\r\nlkdtm_do_action(cptype);\r\nreturn 0;\r\ncase CN_INT_HARDWARE_ENTRY:\r\nlkdtm.kp.symbol_name = "do_IRQ";\r\nlkdtm.entry = (kprobe_opcode_t*) jp_do_irq;\r\nbreak;\r\ncase CN_INT_HW_IRQ_EN:\r\nlkdtm.kp.symbol_name = "handle_IRQ_event";\r\nlkdtm.entry = (kprobe_opcode_t*) jp_handle_irq_event;\r\nbreak;\r\ncase CN_INT_TASKLET_ENTRY:\r\nlkdtm.kp.symbol_name = "tasklet_action";\r\nlkdtm.entry = (kprobe_opcode_t*) jp_tasklet_action;\r\nbreak;\r\ncase CN_FS_DEVRW:\r\nlkdtm.kp.symbol_name = "ll_rw_block";\r\nlkdtm.entry = (kprobe_opcode_t*) jp_ll_rw_block;\r\nbreak;\r\ncase CN_MEM_SWAPOUT:\r\nlkdtm.kp.symbol_name = "shrink_inactive_list";\r\nlkdtm.entry = (kprobe_opcode_t*) jp_shrink_inactive_list;\r\nbreak;\r\ncase CN_TIMERADD:\r\nlkdtm.kp.symbol_name = "hrtimer_start";\r\nlkdtm.entry = (kprobe_opcode_t*) jp_hrtimer_start;\r\nbreak;\r\ncase CN_SCSI_DISPATCH_CMD:\r\nlkdtm.kp.symbol_name = "scsi_dispatch_cmd";\r\nlkdtm.entry = (kprobe_opcode_t*) jp_scsi_dispatch_cmd;\r\nbreak;\r\ncase CN_IDE_CORE_CP:\r\n#ifdef CONFIG_IDE\r\nlkdtm.kp.symbol_name = "generic_ide_ioctl";\r\nlkdtm.entry = (kprobe_opcode_t*) jp_generic_ide_ioctl;\r\n#else\r\npr_info("Crash point not available\n");\r\nreturn -EINVAL;\r\n#endif\r\nbreak;\r\ndefault:\r\npr_info("Invalid Crash Point\n");\r\nreturn -EINVAL;\r\n}\r\ncpoint = which;\r\nif ((ret = register_jprobe(&lkdtm)) < 0) {\r\npr_info("Couldn't register jprobe\n");\r\ncpoint = CN_INVALID;\r\n}\r\nreturn ret;\r\n}\r\nstatic ssize_t do_register_entry(enum cname which, struct file *f,\r\nconst char __user *user_buf, size_t count, loff_t *off)\r\n{\r\nchar *buf;\r\nint err;\r\nif (count >= PAGE_SIZE)\r\nreturn -EINVAL;\r\nbuf = (char *)__get_free_page(GFP_KERNEL);\r\nif (!buf)\r\nreturn -ENOMEM;\r\nif (copy_from_user(buf, user_buf, count)) {\r\nfree_page((unsigned long) buf);\r\nreturn -EFAULT;\r\n}\r\nbuf[count] = '\0';\r\nstrim(buf);\r\ncptype = parse_cp_type(buf, count);\r\nfree_page((unsigned long) buf);\r\nif (cptype == CT_NONE)\r\nreturn -EINVAL;\r\nerr = lkdtm_register_cpoint(which);\r\nif (err < 0)\r\nreturn err;\r\n*off += count;\r\nreturn count;\r\n}\r\nstatic ssize_t lkdtm_debugfs_read(struct file *f, char __user *user_buf,\r\nsize_t count, loff_t *off)\r\n{\r\nchar *buf;\r\nint i, n, out;\r\nbuf = (char *)__get_free_page(GFP_KERNEL);\r\nif (buf == NULL)\r\nreturn -ENOMEM;\r\nn = snprintf(buf, PAGE_SIZE, "Available crash types:\n");\r\nfor (i = 0; i < ARRAY_SIZE(cp_type); i++)\r\nn += snprintf(buf + n, PAGE_SIZE - n, "%s\n", cp_type[i]);\r\nbuf[n] = '\0';\r\nout = simple_read_from_buffer(user_buf, count, off,\r\nbuf, n);\r\nfree_page((unsigned long) buf);\r\nreturn out;\r\n}\r\nstatic int lkdtm_debugfs_open(struct inode *inode, struct file *file)\r\n{\r\nreturn 0;\r\n}\r\nstatic ssize_t int_hardware_entry(struct file *f, const char __user *buf,\r\nsize_t count, loff_t *off)\r\n{\r\nreturn do_register_entry(CN_INT_HARDWARE_ENTRY, f, buf, count, off);\r\n}\r\nstatic ssize_t int_hw_irq_en(struct file *f, const char __user *buf,\r\nsize_t count, loff_t *off)\r\n{\r\nreturn do_register_entry(CN_INT_HW_IRQ_EN, f, buf, count, off);\r\n}\r\nstatic ssize_t int_tasklet_entry(struct file *f, const char __user *buf,\r\nsize_t count, loff_t *off)\r\n{\r\nreturn do_register_entry(CN_INT_TASKLET_ENTRY, f, buf, count, off);\r\n}\r\nstatic ssize_t fs_devrw_entry(struct file *f, const char __user *buf,\r\nsize_t count, loff_t *off)\r\n{\r\nreturn do_register_entry(CN_FS_DEVRW, f, buf, count, off);\r\n}\r\nstatic ssize_t mem_swapout_entry(struct file *f, const char __user *buf,\r\nsize_t count, loff_t *off)\r\n{\r\nreturn do_register_entry(CN_MEM_SWAPOUT, f, buf, count, off);\r\n}\r\nstatic ssize_t timeradd_entry(struct file *f, const char __user *buf,\r\nsize_t count, loff_t *off)\r\n{\r\nreturn do_register_entry(CN_TIMERADD, f, buf, count, off);\r\n}\r\nstatic ssize_t scsi_dispatch_cmd_entry(struct file *f,\r\nconst char __user *buf, size_t count, loff_t *off)\r\n{\r\nreturn do_register_entry(CN_SCSI_DISPATCH_CMD, f, buf, count, off);\r\n}\r\nstatic ssize_t ide_core_cp_entry(struct file *f, const char __user *buf,\r\nsize_t count, loff_t *off)\r\n{\r\nreturn do_register_entry(CN_IDE_CORE_CP, f, buf, count, off);\r\n}\r\nstatic ssize_t direct_entry(struct file *f, const char __user *user_buf,\r\nsize_t count, loff_t *off)\r\n{\r\nenum ctype type;\r\nchar *buf;\r\nif (count >= PAGE_SIZE)\r\nreturn -EINVAL;\r\nif (count < 1)\r\nreturn -EINVAL;\r\nbuf = (char *)__get_free_page(GFP_KERNEL);\r\nif (!buf)\r\nreturn -ENOMEM;\r\nif (copy_from_user(buf, user_buf, count)) {\r\nfree_page((unsigned long) buf);\r\nreturn -EFAULT;\r\n}\r\nbuf[count] = '\0';\r\nstrim(buf);\r\ntype = parse_cp_type(buf, count);\r\nfree_page((unsigned long) buf);\r\nif (type == CT_NONE)\r\nreturn -EINVAL;\r\npr_info("Performing direct entry %s\n", cp_type_to_str(type));\r\nlkdtm_do_action(type);\r\n*off += count;\r\nreturn count;\r\n}\r\nstatic int __init lkdtm_module_init(void)\r\n{\r\nint ret = -EINVAL;\r\nint n_debugfs_entries = 1;\r\nint i;\r\nlkdtm_debugfs_root = debugfs_create_dir("provoke-crash", NULL);\r\nif (!lkdtm_debugfs_root) {\r\npr_err("creating root dir failed\n");\r\nreturn -ENODEV;\r\n}\r\n#ifdef CONFIG_KPROBES\r\nn_debugfs_entries = ARRAY_SIZE(crash_entries);\r\n#endif\r\nfor (i = 0; i < n_debugfs_entries; i++) {\r\nconst struct crash_entry *cur = &crash_entries[i];\r\nstruct dentry *de;\r\nde = debugfs_create_file(cur->name, 0644, lkdtm_debugfs_root,\r\nNULL, &cur->fops);\r\nif (de == NULL) {\r\npr_err("could not create %s\n", cur->name);\r\ngoto out_err;\r\n}\r\n}\r\nif (lkdtm_parse_commandline() == -EINVAL) {\r\npr_info("Invalid command\n");\r\ngoto out_err;\r\n}\r\nif (cpoint != CN_INVALID && cptype != CT_NONE) {\r\nret = lkdtm_register_cpoint(cpoint);\r\nif (ret < 0) {\r\npr_info("Invalid crash point %d\n", cpoint);\r\ngoto out_err;\r\n}\r\npr_info("Crash point %s of type %s registered\n",\r\ncpoint_name, cpoint_type);\r\n} else {\r\npr_info("No crash points registered, enable through debugfs\n");\r\n}\r\nreturn 0;\r\nout_err:\r\ndebugfs_remove_recursive(lkdtm_debugfs_root);\r\nreturn ret;\r\n}\r\nstatic void __exit lkdtm_module_exit(void)\r\n{\r\ndebugfs_remove_recursive(lkdtm_debugfs_root);\r\nunregister_jprobe(&lkdtm);\r\npr_info("Crash point unregistered\n");\r\n}
