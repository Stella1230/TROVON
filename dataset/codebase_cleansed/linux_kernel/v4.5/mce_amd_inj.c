static int toggle_hw_mce_inject(unsigned int cpu, bool enable)\r\n{\r\nu32 l, h;\r\nint err;\r\nerr = rdmsr_on_cpu(cpu, MSR_K7_HWCR, &l, &h);\r\nif (err) {\r\npr_err("%s: error reading HWCR\n", __func__);\r\nreturn err;\r\n}\r\nenable ? (l |= BIT(18)) : (l &= ~BIT(18));\r\nerr = wrmsr_on_cpu(cpu, MSR_K7_HWCR, l, h);\r\nif (err)\r\npr_err("%s: error writing HWCR\n", __func__);\r\nreturn err;\r\n}\r\nstatic int __set_inj(const char *buf)\r\n{\r\nint i;\r\nfor (i = 0; i < N_INJ_TYPES; i++) {\r\nif (!strncmp(flags_options[i], buf, strlen(flags_options[i]))) {\r\ninj_type = i;\r\nreturn 0;\r\n}\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic ssize_t flags_read(struct file *filp, char __user *ubuf,\r\nsize_t cnt, loff_t *ppos)\r\n{\r\nchar buf[MAX_FLAG_OPT_SIZE];\r\nint n;\r\nn = sprintf(buf, "%s\n", flags_options[inj_type]);\r\nreturn simple_read_from_buffer(ubuf, cnt, ppos, buf, n);\r\n}\r\nstatic ssize_t flags_write(struct file *filp, const char __user *ubuf,\r\nsize_t cnt, loff_t *ppos)\r\n{\r\nchar buf[MAX_FLAG_OPT_SIZE], *__buf;\r\nint err;\r\nif (cnt > MAX_FLAG_OPT_SIZE)\r\nreturn -EINVAL;\r\nif (copy_from_user(&buf, ubuf, cnt))\r\nreturn -EFAULT;\r\nbuf[cnt - 1] = 0;\r\n__buf = strstrip(buf);\r\nerr = __set_inj(__buf);\r\nif (err) {\r\npr_err("%s: Invalid flags value: %s\n", __func__, __buf);\r\nreturn err;\r\n}\r\n*ppos += cnt;\r\nreturn cnt;\r\n}\r\nstatic int inj_extcpu_set(void *data, u64 val)\r\n{\r\nstruct mce *m = (struct mce *)data;\r\nif (val >= nr_cpu_ids || !cpu_online(val)) {\r\npr_err("%s: Invalid CPU: %llu\n", __func__, val);\r\nreturn -EINVAL;\r\n}\r\nm->extcpu = val;\r\nreturn 0;\r\n}\r\nstatic void trigger_mce(void *info)\r\n{\r\nasm volatile("int $18");\r\n}\r\nstatic void trigger_dfr_int(void *info)\r\n{\r\nasm volatile("int %0" :: "i" (DEFERRED_ERROR_VECTOR));\r\n}\r\nstatic void trigger_thr_int(void *info)\r\n{\r\nasm volatile("int %0" :: "i" (THRESHOLD_APIC_VECTOR));\r\n}\r\nstatic u32 get_nbc_for_node(int node_id)\r\n{\r\nstruct cpuinfo_x86 *c = &boot_cpu_data;\r\nu32 cores_per_node;\r\ncores_per_node = c->x86_max_cores / amd_get_nodes_per_socket();\r\nreturn cores_per_node * node_id;\r\n}\r\nstatic void toggle_nb_mca_mst_cpu(u16 nid)\r\n{\r\nstruct pci_dev *F3 = node_to_amd_nb(nid)->misc;\r\nu32 val;\r\nint err;\r\nif (!F3)\r\nreturn;\r\nerr = pci_read_config_dword(F3, NBCFG, &val);\r\nif (err) {\r\npr_err("%s: Error reading F%dx%03x.\n",\r\n__func__, PCI_FUNC(F3->devfn), NBCFG);\r\nreturn;\r\n}\r\nif (val & BIT(27))\r\nreturn;\r\npr_err("%s: Set D18F3x44[NbMcaToMstCpuEn] which BIOS hasn't done.\n",\r\n__func__);\r\nval |= BIT(27);\r\nerr = pci_write_config_dword(F3, NBCFG, val);\r\nif (err)\r\npr_err("%s: Error writing F%dx%03x.\n",\r\n__func__, PCI_FUNC(F3->devfn), NBCFG);\r\n}\r\nstatic void do_inject(void)\r\n{\r\nu64 mcg_status = 0;\r\nunsigned int cpu = i_mce.extcpu;\r\nu8 b = i_mce.bank;\r\nif (i_mce.misc)\r\ni_mce.status |= MCI_STATUS_MISCV;\r\nif (inj_type == SW_INJ) {\r\nmce_inject_log(&i_mce);\r\nreturn;\r\n}\r\nmcg_status = MCG_STATUS_MCIP | MCG_STATUS_EIPV;\r\nif (!(i_mce.status & MCI_STATUS_PCC))\r\nmcg_status |= MCG_STATUS_RIPV;\r\nif (inj_type == DFR_INT_INJ) {\r\ni_mce.status |= MCI_STATUS_DEFERRED;\r\ni_mce.status |= (i_mce.status & ~MCI_STATUS_UC);\r\n}\r\nif (static_cpu_has(X86_FEATURE_AMD_DCM) && b == 4) {\r\ntoggle_nb_mca_mst_cpu(amd_get_nb_id(cpu));\r\ncpu = get_nbc_for_node(amd_get_nb_id(cpu));\r\n}\r\nget_online_cpus();\r\nif (!cpu_online(cpu))\r\ngoto err;\r\ntoggle_hw_mce_inject(cpu, true);\r\nwrmsr_on_cpu(cpu, MSR_IA32_MCG_STATUS,\r\n(u32)mcg_status, (u32)(mcg_status >> 32));\r\nwrmsr_on_cpu(cpu, MSR_IA32_MCx_STATUS(b),\r\n(u32)i_mce.status, (u32)(i_mce.status >> 32));\r\nwrmsr_on_cpu(cpu, MSR_IA32_MCx_ADDR(b),\r\n(u32)i_mce.addr, (u32)(i_mce.addr >> 32));\r\nwrmsr_on_cpu(cpu, MSR_IA32_MCx_MISC(b),\r\n(u32)i_mce.misc, (u32)(i_mce.misc >> 32));\r\ntoggle_hw_mce_inject(cpu, false);\r\nswitch (inj_type) {\r\ncase DFR_INT_INJ:\r\nsmp_call_function_single(cpu, trigger_dfr_int, NULL, 0);\r\nbreak;\r\ncase THR_INT_INJ:\r\nsmp_call_function_single(cpu, trigger_thr_int, NULL, 0);\r\nbreak;\r\ndefault:\r\nsmp_call_function_single(cpu, trigger_mce, NULL, 0);\r\n}\r\nerr:\r\nput_online_cpus();\r\n}\r\nstatic int inj_bank_set(void *data, u64 val)\r\n{\r\nstruct mce *m = (struct mce *)data;\r\nif (val >= n_banks) {\r\npr_err("Non-existent MCE bank: %llu\n", val);\r\nreturn -EINVAL;\r\n}\r\nm->bank = val;\r\ndo_inject();\r\nreturn 0;\r\n}\r\nstatic ssize_t\r\ninj_readme_read(struct file *filp, char __user *ubuf,\r\nsize_t cnt, loff_t *ppos)\r\n{\r\nreturn simple_read_from_buffer(ubuf, cnt, ppos,\r\nreadme_msg, strlen(readme_msg));\r\n}\r\nstatic int __init init_mce_inject(void)\r\n{\r\nint i;\r\nu64 cap;\r\nrdmsrl(MSR_IA32_MCG_CAP, cap);\r\nn_banks = cap & MCG_BANKCNT_MASK;\r\ndfs_inj = debugfs_create_dir("mce-inject", NULL);\r\nif (!dfs_inj)\r\nreturn -EINVAL;\r\nfor (i = 0; i < ARRAY_SIZE(dfs_fls); i++) {\r\ndfs_fls[i].d = debugfs_create_file(dfs_fls[i].name,\r\ndfs_fls[i].perm,\r\ndfs_inj,\r\n&i_mce,\r\ndfs_fls[i].fops);\r\nif (!dfs_fls[i].d)\r\ngoto err_dfs_add;\r\n}\r\nreturn 0;\r\nerr_dfs_add:\r\nwhile (--i >= 0)\r\ndebugfs_remove(dfs_fls[i].d);\r\ndebugfs_remove(dfs_inj);\r\ndfs_inj = NULL;\r\nreturn -ENOMEM;\r\n}\r\nstatic void __exit exit_mce_inject(void)\r\n{\r\nint i;\r\nfor (i = 0; i < ARRAY_SIZE(dfs_fls); i++)\r\ndebugfs_remove(dfs_fls[i].d);\r\nmemset(&dfs_fls, 0, sizeof(dfs_fls));\r\ndebugfs_remove(dfs_inj);\r\ndfs_inj = NULL;\r\n}
