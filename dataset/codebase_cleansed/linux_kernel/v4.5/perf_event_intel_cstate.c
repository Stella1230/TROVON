bool test_core(int idx)\r\n{\r\nif (boot_cpu_data.x86_vendor != X86_VENDOR_INTEL ||\r\nboot_cpu_data.x86 != 6)\r\nreturn false;\r\nswitch (boot_cpu_data.x86_model) {\r\ncase 30:\r\ncase 26:\r\ncase 46:\r\ncase 37:\r\ncase 44:\r\ncase 47:\r\nif (idx == PERF_CSTATE_CORE_C3_RES ||\r\nidx == PERF_CSTATE_CORE_C6_RES)\r\nreturn true;\r\nbreak;\r\ncase 42:\r\ncase 45:\r\ncase 58:\r\ncase 62:\r\ncase 60:\r\ncase 63:\r\ncase 69:\r\ncase 70:\r\ncase 61:\r\ncase 86:\r\ncase 71:\r\ncase 79:\r\ncase 78:\r\ncase 94:\r\nif (idx == PERF_CSTATE_CORE_C3_RES ||\r\nidx == PERF_CSTATE_CORE_C6_RES ||\r\nidx == PERF_CSTATE_CORE_C7_RES)\r\nreturn true;\r\nbreak;\r\ncase 55:\r\ncase 77:\r\ncase 76:\r\nif (idx == PERF_CSTATE_CORE_C1_RES ||\r\nidx == PERF_CSTATE_CORE_C6_RES)\r\nreturn true;\r\nbreak;\r\n}\r\nreturn false;\r\n}\r\nbool test_pkg(int idx)\r\n{\r\nif (boot_cpu_data.x86_vendor != X86_VENDOR_INTEL ||\r\nboot_cpu_data.x86 != 6)\r\nreturn false;\r\nswitch (boot_cpu_data.x86_model) {\r\ncase 30:\r\ncase 26:\r\ncase 46:\r\ncase 37:\r\ncase 44:\r\ncase 47:\r\nif (idx == PERF_CSTATE_CORE_C3_RES ||\r\nidx == PERF_CSTATE_CORE_C6_RES ||\r\nidx == PERF_CSTATE_CORE_C7_RES)\r\nreturn true;\r\nbreak;\r\ncase 42:\r\ncase 45:\r\ncase 58:\r\ncase 62:\r\ncase 60:\r\ncase 63:\r\ncase 70:\r\ncase 61:\r\ncase 86:\r\ncase 71:\r\ncase 79:\r\ncase 78:\r\ncase 94:\r\nif (idx == PERF_CSTATE_PKG_C2_RES ||\r\nidx == PERF_CSTATE_PKG_C3_RES ||\r\nidx == PERF_CSTATE_PKG_C6_RES ||\r\nidx == PERF_CSTATE_PKG_C7_RES)\r\nreturn true;\r\nbreak;\r\ncase 55:\r\ncase 77:\r\ncase 76:\r\nif (idx == PERF_CSTATE_CORE_C6_RES)\r\nreturn true;\r\nbreak;\r\ncase 69:\r\nif (idx == PERF_CSTATE_PKG_C2_RES ||\r\nidx == PERF_CSTATE_PKG_C3_RES ||\r\nidx == PERF_CSTATE_PKG_C6_RES ||\r\nidx == PERF_CSTATE_PKG_C7_RES ||\r\nidx == PERF_CSTATE_PKG_C8_RES ||\r\nidx == PERF_CSTATE_PKG_C9_RES ||\r\nidx == PERF_CSTATE_PKG_C10_RES)\r\nreturn true;\r\nbreak;\r\n}\r\nreturn false;\r\n}\r\nstatic ssize_t cstate_get_attr_cpumask(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct pmu *pmu = dev_get_drvdata(dev);\r\nif (pmu == &cstate_core_pmu)\r\nreturn cpumap_print_to_pagebuf(true, buf, &cstate_core_cpu_mask);\r\nelse if (pmu == &cstate_pkg_pmu)\r\nreturn cpumap_print_to_pagebuf(true, buf, &cstate_pkg_cpu_mask);\r\nelse\r\nreturn 0;\r\n}\r\nstatic int cstate_pmu_event_init(struct perf_event *event)\r\n{\r\nu64 cfg = event->attr.config;\r\nint ret = 0;\r\nif (event->attr.type != event->pmu->type)\r\nreturn -ENOENT;\r\nif (event->attr.exclude_user ||\r\nevent->attr.exclude_kernel ||\r\nevent->attr.exclude_hv ||\r\nevent->attr.exclude_idle ||\r\nevent->attr.exclude_host ||\r\nevent->attr.exclude_guest ||\r\nevent->attr.sample_period)\r\nreturn -EINVAL;\r\nif (event->pmu == &cstate_core_pmu) {\r\nif (cfg >= PERF_CSTATE_CORE_EVENT_MAX)\r\nreturn -EINVAL;\r\nif (!core_msr[cfg].attr)\r\nreturn -EINVAL;\r\nevent->hw.event_base = core_msr[cfg].msr;\r\n} else if (event->pmu == &cstate_pkg_pmu) {\r\nif (cfg >= PERF_CSTATE_PKG_EVENT_MAX)\r\nreturn -EINVAL;\r\nif (!pkg_msr[cfg].attr)\r\nreturn -EINVAL;\r\nevent->hw.event_base = pkg_msr[cfg].msr;\r\n} else\r\nreturn -ENOENT;\r\nevent->hw.config = cfg;\r\nevent->hw.idx = -1;\r\nreturn ret;\r\n}\r\nstatic inline u64 cstate_pmu_read_counter(struct perf_event *event)\r\n{\r\nu64 val;\r\nrdmsrl(event->hw.event_base, val);\r\nreturn val;\r\n}\r\nstatic void cstate_pmu_event_update(struct perf_event *event)\r\n{\r\nstruct hw_perf_event *hwc = &event->hw;\r\nu64 prev_raw_count, new_raw_count;\r\nagain:\r\nprev_raw_count = local64_read(&hwc->prev_count);\r\nnew_raw_count = cstate_pmu_read_counter(event);\r\nif (local64_cmpxchg(&hwc->prev_count, prev_raw_count,\r\nnew_raw_count) != prev_raw_count)\r\ngoto again;\r\nlocal64_add(new_raw_count - prev_raw_count, &event->count);\r\n}\r\nstatic void cstate_pmu_event_start(struct perf_event *event, int mode)\r\n{\r\nlocal64_set(&event->hw.prev_count, cstate_pmu_read_counter(event));\r\n}\r\nstatic void cstate_pmu_event_stop(struct perf_event *event, int mode)\r\n{\r\ncstate_pmu_event_update(event);\r\n}\r\nstatic void cstate_pmu_event_del(struct perf_event *event, int mode)\r\n{\r\ncstate_pmu_event_stop(event, PERF_EF_UPDATE);\r\n}\r\nstatic int cstate_pmu_event_add(struct perf_event *event, int mode)\r\n{\r\nif (mode & PERF_EF_START)\r\ncstate_pmu_event_start(event, mode);\r\nreturn 0;\r\n}\r\nstatic void cstate_cpu_exit(int cpu)\r\n{\r\nint i, id, target;\r\nif (has_cstate_core) {\r\nid = topology_core_id(cpu);\r\ntarget = -1;\r\nfor_each_online_cpu(i) {\r\nif (i == cpu)\r\ncontinue;\r\nif (id == topology_core_id(i)) {\r\ntarget = i;\r\nbreak;\r\n}\r\n}\r\nif (cpumask_test_and_clear_cpu(cpu, &cstate_core_cpu_mask) && target >= 0)\r\ncpumask_set_cpu(target, &cstate_core_cpu_mask);\r\nWARN_ON(cpumask_empty(&cstate_core_cpu_mask));\r\nif (target >= 0)\r\nperf_pmu_migrate_context(&cstate_core_pmu, cpu, target);\r\n}\r\nif (has_cstate_pkg) {\r\nid = topology_physical_package_id(cpu);\r\ntarget = -1;\r\nfor_each_online_cpu(i) {\r\nif (i == cpu)\r\ncontinue;\r\nif (id == topology_physical_package_id(i)) {\r\ntarget = i;\r\nbreak;\r\n}\r\n}\r\nif (cpumask_test_and_clear_cpu(cpu, &cstate_pkg_cpu_mask) && target >= 0)\r\ncpumask_set_cpu(target, &cstate_pkg_cpu_mask);\r\nWARN_ON(cpumask_empty(&cstate_pkg_cpu_mask));\r\nif (target >= 0)\r\nperf_pmu_migrate_context(&cstate_pkg_pmu, cpu, target);\r\n}\r\n}\r\nstatic void cstate_cpu_init(int cpu)\r\n{\r\nint i, id;\r\nif (has_cstate_core) {\r\nid = topology_core_id(cpu);\r\nfor_each_cpu(i, &cstate_core_cpu_mask) {\r\nif (id == topology_core_id(i))\r\nbreak;\r\n}\r\nif (i >= nr_cpu_ids)\r\ncpumask_set_cpu(cpu, &cstate_core_cpu_mask);\r\n}\r\nif (has_cstate_pkg) {\r\nid = topology_physical_package_id(cpu);\r\nfor_each_cpu(i, &cstate_pkg_cpu_mask) {\r\nif (id == topology_physical_package_id(i))\r\nbreak;\r\n}\r\nif (i >= nr_cpu_ids)\r\ncpumask_set_cpu(cpu, &cstate_pkg_cpu_mask);\r\n}\r\n}\r\nstatic int cstate_cpu_notifier(struct notifier_block *self,\r\nunsigned long action, void *hcpu)\r\n{\r\nunsigned int cpu = (long)hcpu;\r\nswitch (action & ~CPU_TASKS_FROZEN) {\r\ncase CPU_UP_PREPARE:\r\nbreak;\r\ncase CPU_STARTING:\r\ncstate_cpu_init(cpu);\r\nbreak;\r\ncase CPU_UP_CANCELED:\r\ncase CPU_DYING:\r\nbreak;\r\ncase CPU_ONLINE:\r\ncase CPU_DEAD:\r\nbreak;\r\ncase CPU_DOWN_PREPARE:\r\ncstate_cpu_exit(cpu);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nreturn NOTIFY_OK;\r\n}\r\nstatic bool cstate_probe_msr(struct perf_cstate_msr *msr,\r\nstruct attribute **events_attrs,\r\nint max_event_nr)\r\n{\r\nint i, j = 0;\r\nu64 val;\r\nfor (i = 0; i < max_event_nr; i++) {\r\nif (!msr[i].test(i) || rdmsrl_safe(msr[i].msr, &val))\r\nmsr[i].attr = NULL;\r\n}\r\nfor (i = 0; i < max_event_nr; i++) {\r\nif (msr[i].attr)\r\nevents_attrs[j++] = &msr[i].attr->attr.attr;\r\n}\r\nevents_attrs[j] = NULL;\r\nreturn (j > 0) ? true : false;\r\n}\r\nstatic int __init cstate_init(void)\r\n{\r\nswitch (boot_cpu_data.x86_model) {\r\ncase 55:\r\ncase 76:\r\ncase 77:\r\npkg_msr[PERF_CSTATE_PKG_C6_RES].msr = MSR_PKG_C7_RESIDENCY;\r\n}\r\nif (cstate_probe_msr(core_msr, core_events_attrs, PERF_CSTATE_CORE_EVENT_MAX))\r\nhas_cstate_core = true;\r\nif (cstate_probe_msr(pkg_msr, pkg_events_attrs, PERF_CSTATE_PKG_EVENT_MAX))\r\nhas_cstate_pkg = true;\r\nreturn (has_cstate_core || has_cstate_pkg) ? 0 : -ENODEV;\r\n}\r\nstatic void __init cstate_cpumask_init(void)\r\n{\r\nint cpu;\r\ncpu_notifier_register_begin();\r\nfor_each_online_cpu(cpu)\r\ncstate_cpu_init(cpu);\r\n__perf_cpu_notifier(cstate_cpu_notifier);\r\ncpu_notifier_register_done();\r\n}\r\nstatic void __init cstate_pmus_register(void)\r\n{\r\nint err;\r\nif (has_cstate_core) {\r\nerr = perf_pmu_register(&cstate_core_pmu, cstate_core_pmu.name, -1);\r\nif (WARN_ON(err))\r\npr_info("Failed to register PMU %s error %d\n",\r\ncstate_core_pmu.name, err);\r\n}\r\nif (has_cstate_pkg) {\r\nerr = perf_pmu_register(&cstate_pkg_pmu, cstate_pkg_pmu.name, -1);\r\nif (WARN_ON(err))\r\npr_info("Failed to register PMU %s error %d\n",\r\ncstate_pkg_pmu.name, err);\r\n}\r\n}\r\nstatic int __init cstate_pmu_init(void)\r\n{\r\nint err;\r\nif (cpu_has_hypervisor)\r\nreturn -ENODEV;\r\nerr = cstate_init();\r\nif (err)\r\nreturn err;\r\ncstate_cpumask_init();\r\ncstate_pmus_register();\r\nreturn 0;\r\n}
