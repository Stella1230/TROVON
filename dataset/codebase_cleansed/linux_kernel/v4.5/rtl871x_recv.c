void _r8712_init_sta_recv_priv(struct sta_recv_priv *psta_recvpriv)\r\n{\r\nmemset((u8 *)psta_recvpriv, 0, sizeof(struct sta_recv_priv));\r\nspin_lock_init(&psta_recvpriv->lock);\r\n_init_queue(&psta_recvpriv->defrag_q);\r\n}\r\nsint _r8712_init_recv_priv(struct recv_priv *precvpriv,\r\nstruct _adapter *padapter)\r\n{\r\nsint i;\r\nunion recv_frame *precvframe;\r\nmemset((unsigned char *)precvpriv, 0, sizeof(struct recv_priv));\r\nspin_lock_init(&precvpriv->lock);\r\n_init_queue(&precvpriv->free_recv_queue);\r\n_init_queue(&precvpriv->recv_pending_queue);\r\nprecvpriv->adapter = padapter;\r\nprecvpriv->free_recvframe_cnt = NR_RECVFRAME;\r\nprecvpriv->pallocated_frame_buf = kmalloc(NR_RECVFRAME *\r\nsizeof(union recv_frame) + RXFRAME_ALIGN_SZ,\r\nGFP_ATOMIC);\r\nif (precvpriv->pallocated_frame_buf == NULL)\r\nreturn _FAIL;\r\nkmemleak_not_leak(precvpriv->pallocated_frame_buf);\r\nmemset(precvpriv->pallocated_frame_buf, 0, NR_RECVFRAME *\r\nsizeof(union recv_frame) + RXFRAME_ALIGN_SZ);\r\nprecvpriv->precv_frame_buf = precvpriv->pallocated_frame_buf +\r\nRXFRAME_ALIGN_SZ -\r\n((addr_t)(precvpriv->pallocated_frame_buf) &\r\n(RXFRAME_ALIGN_SZ - 1));\r\nprecvframe = (union recv_frame *)precvpriv->precv_frame_buf;\r\nfor (i = 0; i < NR_RECVFRAME; i++) {\r\nINIT_LIST_HEAD(&(precvframe->u.list));\r\nlist_add_tail(&(precvframe->u.list),\r\n&(precvpriv->free_recv_queue.queue));\r\nr8712_os_recv_resource_alloc(padapter, precvframe);\r\nprecvframe->u.hdr.adapter = padapter;\r\nprecvframe++;\r\n}\r\nprecvpriv->rx_pending_cnt = 1;\r\nreturn r8712_init_recv_priv(precvpriv, padapter);\r\n}\r\nvoid _r8712_free_recv_priv(struct recv_priv *precvpriv)\r\n{\r\nkfree(precvpriv->pallocated_frame_buf);\r\nr8712_free_recv_priv(precvpriv);\r\n}\r\nunion recv_frame *r8712_alloc_recvframe(struct __queue *pfree_recv_queue)\r\n{\r\nunsigned long irqL;\r\nunion recv_frame *precvframe;\r\nstruct list_head *plist, *phead;\r\nstruct _adapter *padapter;\r\nstruct recv_priv *precvpriv;\r\nspin_lock_irqsave(&pfree_recv_queue->lock, irqL);\r\nif (list_empty(&pfree_recv_queue->queue)) {\r\nprecvframe = NULL;\r\n} else {\r\nphead = &pfree_recv_queue->queue;\r\nplist = phead->next;\r\nprecvframe = LIST_CONTAINOR(plist, union recv_frame, u);\r\nlist_del_init(&precvframe->u.hdr.list);\r\npadapter = precvframe->u.hdr.adapter;\r\nif (padapter != NULL) {\r\nprecvpriv = &padapter->recvpriv;\r\nif (pfree_recv_queue == &precvpriv->free_recv_queue)\r\nprecvpriv->free_recvframe_cnt--;\r\n}\r\n}\r\nspin_unlock_irqrestore(&pfree_recv_queue->lock, irqL);\r\nreturn precvframe;\r\n}\r\nvoid r8712_free_recvframe_queue(struct __queue *pframequeue,\r\nstruct __queue *pfree_recv_queue)\r\n{\r\nunion recv_frame *precvframe;\r\nstruct list_head *plist, *phead;\r\nspin_lock(&pframequeue->lock);\r\nphead = &pframequeue->queue;\r\nplist = phead->next;\r\nwhile (!end_of_queue_search(phead, plist)) {\r\nprecvframe = LIST_CONTAINOR(plist, union recv_frame, u);\r\nplist = plist->next;\r\nr8712_free_recvframe(precvframe, pfree_recv_queue);\r\n}\r\nspin_unlock(&pframequeue->lock);\r\n}\r\nsint r8712_recvframe_chkmic(struct _adapter *adapter,\r\nunion recv_frame *precvframe)\r\n{\r\nsint i, res = _SUCCESS;\r\nu32 datalen;\r\nu8 miccode[8];\r\nu8 bmic_err = false;\r\nu8 *pframe, *payload, *pframemic;\r\nu8 *mickey, idx, *iv;\r\nstruct sta_info *stainfo;\r\nstruct rx_pkt_attrib *prxattrib = &precvframe->u.hdr.attrib;\r\nstruct security_priv *psecuritypriv = &adapter->securitypriv;\r\nstainfo = r8712_get_stainfo(&adapter->stapriv, &prxattrib->ta[0]);\r\nif (prxattrib->encrypt == _TKIP_) {\r\nif (stainfo != NULL) {\r\nif (IS_MCAST(prxattrib->ra)) {\r\niv = precvframe->u.hdr.rx_data +\r\nprxattrib->hdrlen;\r\nidx = iv[3];\r\nmickey = &psecuritypriv->XGrprxmickey[(((idx >>\r\n6) & 0x3)) - 1].skey[0];\r\nif (!psecuritypriv->binstallGrpkey)\r\nreturn _FAIL;\r\n} else {\r\nmickey = &stainfo->tkiprxmickey.skey[0];\r\n}\r\ndatalen = precvframe->u.hdr.len - prxattrib->hdrlen -\r\nprxattrib->iv_len - prxattrib->icv_len - 8;\r\npframe = precvframe->u.hdr.rx_data;\r\npayload = pframe + prxattrib->hdrlen +\r\nprxattrib->iv_len;\r\nseccalctkipmic(mickey, pframe, payload, datalen,\r\n&miccode[0],\r\n(unsigned char)prxattrib->priority);\r\npframemic = payload + datalen;\r\nbmic_err = false;\r\nfor (i = 0; i < 8; i++) {\r\nif (miccode[i] != *(pframemic + i))\r\nbmic_err = true;\r\n}\r\nif (bmic_err) {\r\nif (prxattrib->bdecrypted)\r\nr8712_handle_tkip_mic_err(adapter,\r\n(u8)IS_MCAST(prxattrib->ra));\r\nres = _FAIL;\r\n} else {\r\nif (!psecuritypriv->bcheck_grpkey &&\r\nIS_MCAST(prxattrib->ra))\r\npsecuritypriv->bcheck_grpkey = true;\r\n}\r\nrecvframe_pull_tail(precvframe, 8);\r\n}\r\n}\r\nreturn res;\r\n}\r\nunion recv_frame *r8712_decryptor(struct _adapter *padapter,\r\nunion recv_frame *precv_frame)\r\n{\r\nstruct rx_pkt_attrib *prxattrib = &precv_frame->u.hdr.attrib;\r\nstruct security_priv *psecuritypriv = &padapter->securitypriv;\r\nunion recv_frame *return_packet = precv_frame;\r\nif ((prxattrib->encrypt > 0) && ((prxattrib->bdecrypted == 0) ||\r\npsecuritypriv->sw_decrypt)) {\r\npsecuritypriv->hw_decrypted = false;\r\nswitch (prxattrib->encrypt) {\r\ncase _WEP40_:\r\ncase _WEP104_:\r\nr8712_wep_decrypt(padapter, (u8 *)precv_frame);\r\nbreak;\r\ncase _TKIP_:\r\nr8712_tkip_decrypt(padapter, (u8 *)precv_frame);\r\nbreak;\r\ncase _AES_:\r\nr8712_aes_decrypt(padapter, (u8 *)precv_frame);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n} else if (prxattrib->bdecrypted == 1) {\r\npsecuritypriv->hw_decrypted = true;\r\n}\r\nreturn return_packet;\r\n}\r\nunion recv_frame *r8712_portctrl(struct _adapter *adapter,\r\nunion recv_frame *precv_frame)\r\n{\r\nu8 *psta_addr, *ptr;\r\nuint auth_alg;\r\nstruct recv_frame_hdr *pfhdr;\r\nstruct sta_info *psta;\r\nstruct sta_priv *pstapriv;\r\nunion recv_frame *prtnframe;\r\nu16 ether_type;\r\npstapriv = &adapter->stapriv;\r\nptr = get_recvframe_data(precv_frame);\r\npfhdr = &precv_frame->u.hdr;\r\npsta_addr = pfhdr->attrib.ta;\r\npsta = r8712_get_stainfo(pstapriv, psta_addr);\r\nauth_alg = adapter->securitypriv.AuthAlgrthm;\r\nif (auth_alg == 2) {\r\nptr = ptr + pfhdr->attrib.hdrlen + LLC_HEADER_SIZE;\r\nmemcpy(&ether_type, ptr, 2);\r\nether_type = ntohs((unsigned short)ether_type);\r\nif ((psta != NULL) && (psta->ieee8021x_blocked)) {\r\nif (ether_type == 0x888e) {\r\nprtnframe = precv_frame;\r\n} else {\r\nr8712_free_recvframe(precv_frame,\r\n&adapter->recvpriv.free_recv_queue);\r\nprtnframe = NULL;\r\n}\r\n} else {\r\nprtnframe = precv_frame;\r\nif (ether_type == 0x888e) {\r\nprtnframe = precv_frame;\r\n}\r\n}\r\n} else {\r\nprtnframe = precv_frame;\r\n}\r\nreturn prtnframe;\r\n}\r\nstatic sint recv_decache(union recv_frame *precv_frame, u8 bretry,\r\nstruct stainfo_rxcache *prxcache)\r\n{\r\nsint tid = precv_frame->u.hdr.attrib.priority;\r\nu16 seq_ctrl = ((precv_frame->u.hdr.attrib.seq_num & 0xffff) << 4) |\r\n(precv_frame->u.hdr.attrib.frag_num & 0xf);\r\nif (tid > 15)\r\nreturn _FAIL;\r\nif (seq_ctrl == prxcache->tid_rxseq[tid])\r\nreturn _FAIL;\r\nprxcache->tid_rxseq[tid] = seq_ctrl;\r\nreturn _SUCCESS;\r\n}\r\nstatic sint sta2sta_data_frame(struct _adapter *adapter,\r\nunion recv_frame *precv_frame,\r\nstruct sta_info **psta)\r\n{\r\nu8 *ptr = precv_frame->u.hdr.rx_data;\r\nsint ret = _SUCCESS;\r\nstruct rx_pkt_attrib *pattrib = &precv_frame->u.hdr.attrib;\r\nstruct sta_priv *pstapriv = &adapter->stapriv;\r\nstruct mlme_priv *pmlmepriv = &adapter->mlmepriv;\r\nu8 *mybssid = get_bssid(pmlmepriv);\r\nu8 *myhwaddr = myid(&adapter->eeprompriv);\r\nu8 *sta_addr = NULL;\r\nsint bmcast = IS_MCAST(pattrib->dst);\r\nif (check_fwstate(pmlmepriv, WIFI_ADHOC_STATE) ||\r\ncheck_fwstate(pmlmepriv, WIFI_ADHOC_MASTER_STATE)) {\r\nif (!memcmp(myhwaddr, pattrib->src, ETH_ALEN))\r\nreturn _FAIL;\r\nif ((memcmp(myhwaddr, pattrib->dst, ETH_ALEN)) && (!bmcast))\r\nreturn _FAIL;\r\nif (is_zero_ether_addr(pattrib->bssid) ||\r\nis_zero_ether_addr(mybssid) ||\r\n(memcmp(pattrib->bssid, mybssid, ETH_ALEN)))\r\nreturn _FAIL;\r\nsta_addr = pattrib->src;\r\n} else if (check_fwstate(pmlmepriv, WIFI_STATION_STATE)) {\r\nif (memcmp(pattrib->bssid, pattrib->src, ETH_ALEN))\r\nreturn _FAIL;\r\nsta_addr = pattrib->bssid;\r\n} else if (check_fwstate(pmlmepriv, WIFI_AP_STATE)) {\r\nif (bmcast) {\r\nif (!IS_MCAST(pattrib->bssid))\r\nreturn _FAIL;\r\n} else {\r\nif (memcmp(pattrib->bssid, pattrib->dst, ETH_ALEN))\r\nreturn _FAIL;\r\nsta_addr = pattrib->src;\r\n}\r\n} else if (check_fwstate(pmlmepriv, WIFI_MP_STATE)) {\r\nmemcpy(pattrib->dst, GetAddr1Ptr(ptr), ETH_ALEN);\r\nmemcpy(pattrib->src, GetAddr2Ptr(ptr), ETH_ALEN);\r\nmemcpy(pattrib->bssid, GetAddr3Ptr(ptr), ETH_ALEN);\r\nmemcpy(pattrib->ra, pattrib->dst, ETH_ALEN);\r\nmemcpy(pattrib->ta, pattrib->src, ETH_ALEN);\r\nsta_addr = mybssid;\r\n} else {\r\nret = _FAIL;\r\n}\r\nif (bmcast)\r\n*psta = r8712_get_bcmc_stainfo(adapter);\r\nelse\r\n*psta = r8712_get_stainfo(pstapriv, sta_addr);\r\nif (*psta == NULL) {\r\nif (check_fwstate(pmlmepriv, WIFI_MP_STATE))\r\nadapter->mppriv.rx_pktloss++;\r\nreturn _FAIL;\r\n}\r\nreturn ret;\r\n}\r\nstatic sint ap2sta_data_frame(struct _adapter *adapter,\r\nunion recv_frame *precv_frame,\r\nstruct sta_info **psta)\r\n{\r\nu8 *ptr = precv_frame->u.hdr.rx_data;\r\nstruct rx_pkt_attrib *pattrib = &precv_frame->u.hdr.attrib;\r\nstruct sta_priv *pstapriv = &adapter->stapriv;\r\nstruct mlme_priv *pmlmepriv = &adapter->mlmepriv;\r\nu8 *mybssid = get_bssid(pmlmepriv);\r\nu8 *myhwaddr = myid(&adapter->eeprompriv);\r\nsint bmcast = IS_MCAST(pattrib->dst);\r\nif (check_fwstate(pmlmepriv, WIFI_STATION_STATE) &&\r\ncheck_fwstate(pmlmepriv, _FW_LINKED)) {\r\nif ((GetFrameSubType(ptr)) == WIFI_DATA_NULL)\r\nreturn _FAIL;\r\nif ((GetFrameSubType(ptr) & WIFI_QOS_DATA_TYPE) ==\r\nWIFI_QOS_DATA_TYPE) {\r\nif (GetFrameSubType(ptr) & (BIT(4) | BIT(5) | BIT(6)))\r\nreturn _FAIL;\r\n}\r\nif (!memcmp(myhwaddr, pattrib->src, ETH_ALEN))\r\nreturn _FAIL;\r\nif ((memcmp(myhwaddr, pattrib->dst, ETH_ALEN)) && (!bmcast))\r\nreturn _FAIL;\r\nif (is_zero_ether_addr(pattrib->bssid) ||\r\nis_zero_ether_addr(mybssid) ||\r\n(memcmp(pattrib->bssid, mybssid, ETH_ALEN)))\r\nreturn _FAIL;\r\nif (bmcast)\r\n*psta = r8712_get_bcmc_stainfo(adapter);\r\nelse\r\n*psta = r8712_get_stainfo(pstapriv, pattrib->bssid);\r\nif (*psta == NULL)\r\nreturn _FAIL;\r\n} else if (check_fwstate(pmlmepriv, WIFI_MP_STATE) &&\r\ncheck_fwstate(pmlmepriv, _FW_LINKED)) {\r\nmemcpy(pattrib->dst, GetAddr1Ptr(ptr), ETH_ALEN);\r\nmemcpy(pattrib->src, GetAddr2Ptr(ptr), ETH_ALEN);\r\nmemcpy(pattrib->bssid, GetAddr3Ptr(ptr), ETH_ALEN);\r\nmemcpy(pattrib->ra, pattrib->dst, ETH_ALEN);\r\nmemcpy(pattrib->ta, pattrib->src, ETH_ALEN);\r\nmemcpy(pattrib->bssid, mybssid, ETH_ALEN);\r\n*psta = r8712_get_stainfo(pstapriv, pattrib->bssid);\r\nif (*psta == NULL)\r\nreturn _FAIL;\r\n} else {\r\nreturn _FAIL;\r\n}\r\nreturn _SUCCESS;\r\n}\r\nstatic sint sta2ap_data_frame(struct _adapter *adapter,\r\nunion recv_frame *precv_frame,\r\nstruct sta_info **psta)\r\n{\r\nstruct rx_pkt_attrib *pattrib = &precv_frame->u.hdr.attrib;\r\nstruct sta_priv *pstapriv = &adapter->stapriv;\r\nstruct mlme_priv *pmlmepriv = &adapter->mlmepriv;\r\nunsigned char *mybssid = get_bssid(pmlmepriv);\r\nif (check_fwstate(pmlmepriv, WIFI_AP_STATE)) {\r\nif (memcmp(pattrib->bssid, mybssid, ETH_ALEN))\r\nreturn _FAIL;\r\n*psta = r8712_get_stainfo(pstapriv, pattrib->src);\r\nif (*psta == NULL)\r\nreturn _FAIL;\r\n}\r\nreturn _SUCCESS;\r\n}\r\nstatic sint validate_recv_ctrl_frame(struct _adapter *adapter,\r\nunion recv_frame *precv_frame)\r\n{\r\nreturn _FAIL;\r\n}\r\nstatic sint validate_recv_mgnt_frame(struct _adapter *adapter,\r\nunion recv_frame *precv_frame)\r\n{\r\nreturn _FAIL;\r\n}\r\nstatic sint validate_recv_data_frame(struct _adapter *adapter,\r\nunion recv_frame *precv_frame)\r\n{\r\nint res;\r\nu8 bretry;\r\nu8 *psa, *pda, *pbssid;\r\nstruct sta_info *psta = NULL;\r\nu8 *ptr = precv_frame->u.hdr.rx_data;\r\nstruct rx_pkt_attrib *pattrib = &precv_frame->u.hdr.attrib;\r\nstruct security_priv *psecuritypriv = &adapter->securitypriv;\r\nbretry = GetRetry(ptr);\r\npda = get_da(ptr);\r\npsa = get_sa(ptr);\r\npbssid = get_hdr_bssid(ptr);\r\nif (pbssid == NULL)\r\nreturn _FAIL;\r\nmemcpy(pattrib->dst, pda, ETH_ALEN);\r\nmemcpy(pattrib->src, psa, ETH_ALEN);\r\nmemcpy(pattrib->bssid, pbssid, ETH_ALEN);\r\nswitch (pattrib->to_fr_ds) {\r\ncase 0:\r\nmemcpy(pattrib->ra, pda, ETH_ALEN);\r\nmemcpy(pattrib->ta, psa, ETH_ALEN);\r\nres = sta2sta_data_frame(adapter, precv_frame, &psta);\r\nbreak;\r\ncase 1:\r\nmemcpy(pattrib->ra, pda, ETH_ALEN);\r\nmemcpy(pattrib->ta, pbssid, ETH_ALEN);\r\nres = ap2sta_data_frame(adapter, precv_frame, &psta);\r\nbreak;\r\ncase 2:\r\nmemcpy(pattrib->ra, pbssid, ETH_ALEN);\r\nmemcpy(pattrib->ta, psa, ETH_ALEN);\r\nres = sta2ap_data_frame(adapter, precv_frame, &psta);\r\nbreak;\r\ncase 3:\r\nmemcpy(pattrib->ra, GetAddr1Ptr(ptr), ETH_ALEN);\r\nmemcpy(pattrib->ta, GetAddr2Ptr(ptr), ETH_ALEN);\r\nreturn _FAIL;\r\ndefault:\r\nreturn _FAIL;\r\n}\r\nif (res == _FAIL)\r\nreturn _FAIL;\r\nif (psta == NULL)\r\nreturn _FAIL;\r\nprecv_frame->u.hdr.psta = psta;\r\npattrib->amsdu = 0;\r\nif (pattrib->qos == 1) {\r\npattrib->priority = GetPriority((ptr + 24));\r\npattrib->ack_policy = GetAckpolicy((ptr + 24));\r\npattrib->amsdu = GetAMsdu((ptr + 24));\r\npattrib->hdrlen = pattrib->to_fr_ds == 3 ? 32 : 26;\r\n} else {\r\npattrib->priority = 0;\r\npattrib->hdrlen = (pattrib->to_fr_ds == 3) ? 30 : 24;\r\n}\r\nif (pattrib->order)\r\npattrib->hdrlen += 4;\r\nprecv_frame->u.hdr.preorder_ctrl =\r\n&psta->recvreorder_ctrl[pattrib->priority];\r\nif (recv_decache(precv_frame, bretry, &psta->sta_recvpriv.rxcache) ==\r\n_FAIL)\r\nreturn _FAIL;\r\nif (pattrib->privacy) {\r\nGET_ENCRY_ALGO(psecuritypriv, psta, pattrib->encrypt,\r\nIS_MCAST(pattrib->ra));\r\nSET_ICE_IV_LEN(pattrib->iv_len, pattrib->icv_len,\r\npattrib->encrypt);\r\n} else {\r\npattrib->encrypt = 0;\r\npattrib->iv_len = pattrib->icv_len = 0;\r\n}\r\nreturn _SUCCESS;\r\n}\r\nsint r8712_validate_recv_frame(struct _adapter *adapter,\r\nunion recv_frame *precv_frame)\r\n{\r\nu8 type;\r\nu8 subtype;\r\nsint retval = _SUCCESS;\r\nstruct rx_pkt_attrib *pattrib = &precv_frame->u.hdr.attrib;\r\nu8 *ptr = precv_frame->u.hdr.rx_data;\r\nu8 ver = (unsigned char)(*ptr) & 0x3;\r\nif (ver != 0)\r\nreturn _FAIL;\r\ntype = GetFrameType(ptr);\r\nsubtype = GetFrameSubType(ptr);\r\npattrib->to_fr_ds = get_tofr_ds(ptr);\r\npattrib->frag_num = GetFragNum(ptr);\r\npattrib->seq_num = GetSequence(ptr);\r\npattrib->pw_save = GetPwrMgt(ptr);\r\npattrib->mfrag = GetMFrag(ptr);\r\npattrib->mdata = GetMData(ptr);\r\npattrib->privacy = GetPrivacy(ptr);\r\npattrib->order = GetOrder(ptr);\r\nswitch (type) {\r\ncase WIFI_MGT_TYPE:\r\nretval = validate_recv_mgnt_frame(adapter, precv_frame);\r\nbreak;\r\ncase WIFI_CTRL_TYPE:\r\nretval = validate_recv_ctrl_frame(adapter, precv_frame);\r\nbreak;\r\ncase WIFI_DATA_TYPE:\r\npattrib->qos = (subtype & BIT(7)) ? 1 : 0;\r\nretval = validate_recv_data_frame(adapter, precv_frame);\r\nbreak;\r\ndefault:\r\nreturn _FAIL;\r\n}\r\nreturn retval;\r\n}\r\nsint r8712_wlanhdr_to_ethhdr(union recv_frame *precvframe)\r\n{\r\nsint rmv_len;\r\nu16 len;\r\nu8 bsnaphdr;\r\nu8 *psnap_type;\r\nstruct ieee80211_snap_hdr *psnap;\r\nstruct _adapter *adapter = precvframe->u.hdr.adapter;\r\nstruct mlme_priv *pmlmepriv = &adapter->mlmepriv;\r\nu8 *ptr = get_recvframe_data(precvframe);\r\nstruct rx_pkt_attrib *pattrib = &precvframe->u.hdr.attrib;\r\nif (pattrib->encrypt)\r\nrecvframe_pull_tail(precvframe, pattrib->icv_len);\r\npsnap = (struct ieee80211_snap_hdr *)(ptr + pattrib->hdrlen +\r\npattrib->iv_len);\r\npsnap_type = ptr + pattrib->hdrlen + pattrib->iv_len + SNAP_SIZE;\r\nif ((!memcmp(psnap, (void *)rfc1042_header, SNAP_SIZE) &&\r\n(memcmp(psnap_type, (void *)SNAP_ETH_TYPE_IPX, 2)) &&\r\n(memcmp(psnap_type, (void *)SNAP_ETH_TYPE_APPLETALK_AARP, 2))) ||\r\n!memcmp(psnap, (void *)bridge_tunnel_header, SNAP_SIZE)) {\r\nbsnaphdr = true;\r\n} else {\r\nbsnaphdr = false;\r\n}\r\nrmv_len = pattrib->hdrlen + pattrib->iv_len +\r\n(bsnaphdr ? SNAP_SIZE : 0);\r\nlen = precvframe->u.hdr.len - rmv_len;\r\nif (check_fwstate(pmlmepriv, WIFI_MP_STATE)) {\r\nptr += rmv_len;\r\n*ptr = 0x87;\r\n*(ptr + 1) = 0x12;\r\nptr = recvframe_pull(precvframe, (rmv_len -\r\nsizeof(struct ethhdr) + 2) - 24);\r\nmemcpy(ptr, get_rxmem(precvframe), 24);\r\nptr += 24;\r\n} else\r\nptr = recvframe_pull(precvframe, (rmv_len -\r\nsizeof(struct ethhdr) + (bsnaphdr ? 2 : 0)));\r\nmemcpy(ptr, pattrib->dst, ETH_ALEN);\r\nmemcpy(ptr + ETH_ALEN, pattrib->src, ETH_ALEN);\r\nif (!bsnaphdr) {\r\nlen = htons(len);\r\nmemcpy(ptr + 12, &len, 2);\r\n}\r\nreturn _SUCCESS;\r\n}\r\ns32 r8712_recv_entry(union recv_frame *precvframe)\r\n{\r\nstruct _adapter *padapter;\r\nstruct recv_priv *precvpriv;\r\ns32 ret = _SUCCESS;\r\npadapter = precvframe->u.hdr.adapter;\r\nprecvpriv = &(padapter->recvpriv);\r\npadapter->ledpriv.LedControlHandler(padapter, LED_CTL_RX);\r\nret = recv_func(padapter, precvframe);\r\nif (ret == _FAIL)\r\ngoto _recv_entry_drop;\r\nprecvpriv->rx_pkts++;\r\nprecvpriv->rx_bytes += (uint)(precvframe->u.hdr.rx_tail -\r\nprecvframe->u.hdr.rx_data);\r\nreturn ret;\r\n_recv_entry_drop:\r\nprecvpriv->rx_drop++;\r\npadapter->mppriv.rx_pktloss = precvpriv->rx_drop;\r\nreturn ret;\r\n}
