static void at91_start_clock(struct ohci_at91_priv *ohci_at91)\r\n{\r\nif (ohci_at91->clocked)\r\nreturn;\r\nclk_set_rate(ohci_at91->fclk, 48000000);\r\nclk_prepare_enable(ohci_at91->hclk);\r\nclk_prepare_enable(ohci_at91->iclk);\r\nclk_prepare_enable(ohci_at91->fclk);\r\nohci_at91->clocked = true;\r\n}\r\nstatic void at91_stop_clock(struct ohci_at91_priv *ohci_at91)\r\n{\r\nif (!ohci_at91->clocked)\r\nreturn;\r\nclk_disable_unprepare(ohci_at91->fclk);\r\nclk_disable_unprepare(ohci_at91->iclk);\r\nclk_disable_unprepare(ohci_at91->hclk);\r\nohci_at91->clocked = false;\r\n}\r\nstatic void at91_start_hc(struct platform_device *pdev)\r\n{\r\nstruct usb_hcd *hcd = platform_get_drvdata(pdev);\r\nstruct ohci_regs __iomem *regs = hcd->regs;\r\nstruct ohci_at91_priv *ohci_at91 = hcd_to_ohci_at91_priv(hcd);\r\ndev_dbg(&pdev->dev, "start\n");\r\nat91_start_clock(ohci_at91);\r\nwritel(0, &regs->control);\r\n}\r\nstatic void at91_stop_hc(struct platform_device *pdev)\r\n{\r\nstruct usb_hcd *hcd = platform_get_drvdata(pdev);\r\nstruct ohci_regs __iomem *regs = hcd->regs;\r\nstruct ohci_at91_priv *ohci_at91 = hcd_to_ohci_at91_priv(hcd);\r\ndev_dbg(&pdev->dev, "stop\n");\r\nwritel(0, &regs->control);\r\nat91_stop_clock(ohci_at91);\r\n}\r\nstatic int usb_hcd_at91_probe(const struct hc_driver *driver,\r\nstruct platform_device *pdev)\r\n{\r\nstruct at91_usbh_data *board;\r\nstruct ohci_hcd *ohci;\r\nint retval;\r\nstruct usb_hcd *hcd;\r\nstruct ohci_at91_priv *ohci_at91;\r\nstruct device *dev = &pdev->dev;\r\nstruct resource *res;\r\nint irq;\r\nirq = platform_get_irq(pdev, 0);\r\nif (irq < 0) {\r\ndev_dbg(dev, "hcd probe: missing irq resource\n");\r\nreturn irq;\r\n}\r\nhcd = usb_create_hcd(driver, dev, "at91");\r\nif (!hcd)\r\nreturn -ENOMEM;\r\nohci_at91 = hcd_to_ohci_at91_priv(hcd);\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nhcd->regs = devm_ioremap_resource(dev, res);\r\nif (IS_ERR(hcd->regs)) {\r\nretval = PTR_ERR(hcd->regs);\r\ngoto err;\r\n}\r\nhcd->rsrc_start = res->start;\r\nhcd->rsrc_len = resource_size(res);\r\nohci_at91->iclk = devm_clk_get(dev, "ohci_clk");\r\nif (IS_ERR(ohci_at91->iclk)) {\r\ndev_err(dev, "failed to get ohci_clk\n");\r\nretval = PTR_ERR(ohci_at91->iclk);\r\ngoto err;\r\n}\r\nohci_at91->fclk = devm_clk_get(dev, "uhpck");\r\nif (IS_ERR(ohci_at91->fclk)) {\r\ndev_err(dev, "failed to get uhpck\n");\r\nretval = PTR_ERR(ohci_at91->fclk);\r\ngoto err;\r\n}\r\nohci_at91->hclk = devm_clk_get(dev, "hclk");\r\nif (IS_ERR(ohci_at91->hclk)) {\r\ndev_err(dev, "failed to get hclk\n");\r\nretval = PTR_ERR(ohci_at91->hclk);\r\ngoto err;\r\n}\r\nboard = hcd->self.controller->platform_data;\r\nohci = hcd_to_ohci(hcd);\r\nohci->num_ports = board->ports;\r\nat91_start_hc(pdev);\r\nretval = usb_add_hcd(hcd, irq, IRQF_SHARED);\r\nif (retval == 0) {\r\ndevice_wakeup_enable(hcd->self.controller);\r\nreturn retval;\r\n}\r\nat91_stop_hc(pdev);\r\nerr:\r\nusb_put_hcd(hcd);\r\nreturn retval;\r\n}\r\nstatic void usb_hcd_at91_remove(struct usb_hcd *hcd,\r\nstruct platform_device *pdev)\r\n{\r\nusb_remove_hcd(hcd);\r\nat91_stop_hc(pdev);\r\nusb_put_hcd(hcd);\r\n}\r\nstatic void ohci_at91_usb_set_power(struct at91_usbh_data *pdata, int port, int enable)\r\n{\r\nif (!valid_port(port))\r\nreturn;\r\nif (!gpio_is_valid(pdata->vbus_pin[port]))\r\nreturn;\r\ngpio_set_value(pdata->vbus_pin[port],\r\npdata->vbus_pin_active_low[port] ^ enable);\r\n}\r\nstatic int ohci_at91_usb_get_power(struct at91_usbh_data *pdata, int port)\r\n{\r\nif (!valid_port(port))\r\nreturn -EINVAL;\r\nif (!gpio_is_valid(pdata->vbus_pin[port]))\r\nreturn -EINVAL;\r\nreturn gpio_get_value(pdata->vbus_pin[port]) ^\r\npdata->vbus_pin_active_low[port];\r\n}\r\nstatic int ohci_at91_hub_status_data(struct usb_hcd *hcd, char *buf)\r\n{\r\nstruct at91_usbh_data *pdata = hcd->self.controller->platform_data;\r\nint length = ohci_hub_status_data(hcd, buf);\r\nint port;\r\nat91_for_each_port(port) {\r\nif (pdata->overcurrent_changed[port]) {\r\nif (!length)\r\nlength = 1;\r\nbuf[0] |= 1 << (port + 1);\r\n}\r\n}\r\nreturn length;\r\n}\r\nstatic int ohci_at91_hub_control(struct usb_hcd *hcd, u16 typeReq, u16 wValue,\r\nu16 wIndex, char *buf, u16 wLength)\r\n{\r\nstruct at91_usbh_data *pdata = dev_get_platdata(hcd->self.controller);\r\nstruct usb_hub_descriptor *desc;\r\nint ret = -EINVAL;\r\nu32 *data = (u32 *)buf;\r\ndev_dbg(hcd->self.controller,\r\n"ohci_at91_hub_control(%p,0x%04x,0x%04x,0x%04x,%p,%04x)\n",\r\nhcd, typeReq, wValue, wIndex, buf, wLength);\r\nwIndex--;\r\nswitch (typeReq) {\r\ncase SetPortFeature:\r\nif (wValue == USB_PORT_FEAT_POWER) {\r\ndev_dbg(hcd->self.controller, "SetPortFeat: POWER\n");\r\nif (valid_port(wIndex)) {\r\nohci_at91_usb_set_power(pdata, wIndex, 1);\r\nret = 0;\r\n}\r\ngoto out;\r\n}\r\nbreak;\r\ncase ClearPortFeature:\r\nswitch (wValue) {\r\ncase USB_PORT_FEAT_C_OVER_CURRENT:\r\ndev_dbg(hcd->self.controller,\r\n"ClearPortFeature: C_OVER_CURRENT\n");\r\nif (valid_port(wIndex)) {\r\npdata->overcurrent_changed[wIndex] = 0;\r\npdata->overcurrent_status[wIndex] = 0;\r\n}\r\ngoto out;\r\ncase USB_PORT_FEAT_OVER_CURRENT:\r\ndev_dbg(hcd->self.controller,\r\n"ClearPortFeature: OVER_CURRENT\n");\r\nif (valid_port(wIndex))\r\npdata->overcurrent_status[wIndex] = 0;\r\ngoto out;\r\ncase USB_PORT_FEAT_POWER:\r\ndev_dbg(hcd->self.controller,\r\n"ClearPortFeature: POWER\n");\r\nif (valid_port(wIndex)) {\r\nohci_at91_usb_set_power(pdata, wIndex, 0);\r\nreturn 0;\r\n}\r\n}\r\nbreak;\r\n}\r\nret = ohci_hub_control(hcd, typeReq, wValue, wIndex + 1, buf, wLength);\r\nif (ret)\r\ngoto out;\r\nswitch (typeReq) {\r\ncase GetHubDescriptor:\r\ndesc = (struct usb_hub_descriptor *)buf;\r\ndev_dbg(hcd->self.controller, "wHubCharacteristics 0x%04x\n",\r\ndesc->wHubCharacteristics);\r\ndesc->wHubCharacteristics &= ~cpu_to_le16(HUB_CHAR_LPSM);\r\ndesc->wHubCharacteristics |=\r\ncpu_to_le16(HUB_CHAR_INDV_PORT_LPSM);\r\nif (pdata->overcurrent_supported) {\r\ndesc->wHubCharacteristics &= ~cpu_to_le16(HUB_CHAR_OCPM);\r\ndesc->wHubCharacteristics |=\r\ncpu_to_le16(HUB_CHAR_INDV_PORT_OCPM);\r\n}\r\ndev_dbg(hcd->self.controller, "wHubCharacteristics after 0x%04x\n",\r\ndesc->wHubCharacteristics);\r\nreturn ret;\r\ncase GetPortStatus:\r\ndev_dbg(hcd->self.controller, "GetPortStatus(%d)\n", wIndex);\r\nif (valid_port(wIndex)) {\r\nif (!ohci_at91_usb_get_power(pdata, wIndex))\r\n*data &= ~cpu_to_le32(RH_PS_PPS);\r\nif (pdata->overcurrent_changed[wIndex])\r\n*data |= cpu_to_le32(RH_PS_OCIC);\r\nif (pdata->overcurrent_status[wIndex])\r\n*data |= cpu_to_le32(RH_PS_POCI);\r\n}\r\n}\r\nout:\r\nreturn ret;\r\n}\r\nstatic irqreturn_t ohci_hcd_at91_overcurrent_irq(int irq, void *data)\r\n{\r\nstruct platform_device *pdev = data;\r\nstruct at91_usbh_data *pdata = dev_get_platdata(&pdev->dev);\r\nint val, gpio, port;\r\nat91_for_each_port(port) {\r\nif (gpio_is_valid(pdata->overcurrent_pin[port]) &&\r\ngpio_to_irq(pdata->overcurrent_pin[port]) == irq) {\r\ngpio = pdata->overcurrent_pin[port];\r\nbreak;\r\n}\r\n}\r\nif (port == AT91_MAX_USBH_PORTS) {\r\ndev_err(& pdev->dev, "overcurrent interrupt from unknown GPIO\n");\r\nreturn IRQ_HANDLED;\r\n}\r\nval = gpio_get_value(gpio);\r\nif (!val) {\r\nohci_at91_usb_set_power(pdata, port, 0);\r\npdata->overcurrent_status[port] = 1;\r\npdata->overcurrent_changed[port] = 1;\r\n}\r\ndev_dbg(& pdev->dev, "overcurrent situation %s\n",\r\nval ? "exited" : "notified");\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int ohci_hcd_at91_drv_probe(struct platform_device *pdev)\r\n{\r\nstruct device_node *np = pdev->dev.of_node;\r\nstruct at91_usbh_data *pdata;\r\nint i;\r\nint gpio;\r\nint ret;\r\nenum of_gpio_flags flags;\r\nu32 ports;\r\nret = dma_coerce_mask_and_coherent(&pdev->dev, DMA_BIT_MASK(32));\r\nif (ret)\r\nreturn ret;\r\npdata = devm_kzalloc(&pdev->dev, sizeof(*pdata), GFP_KERNEL);\r\nif (!pdata)\r\nreturn -ENOMEM;\r\npdev->dev.platform_data = pdata;\r\nif (!of_property_read_u32(np, "num-ports", &ports))\r\npdata->ports = ports;\r\nat91_for_each_port(i) {\r\nif (i >= pdata->ports) {\r\npdata->vbus_pin[i] = -EINVAL;\r\npdata->overcurrent_pin[i] = -EINVAL;\r\ncontinue;\r\n}\r\ngpio = of_get_named_gpio_flags(np, "atmel,vbus-gpio", i,\r\n&flags);\r\npdata->vbus_pin[i] = gpio;\r\nif (!gpio_is_valid(gpio))\r\ncontinue;\r\npdata->vbus_pin_active_low[i] = flags & OF_GPIO_ACTIVE_LOW;\r\nret = gpio_request(gpio, "ohci_vbus");\r\nif (ret) {\r\ndev_err(&pdev->dev,\r\n"can't request vbus gpio %d\n", gpio);\r\ncontinue;\r\n}\r\nret = gpio_direction_output(gpio,\r\n!pdata->vbus_pin_active_low[i]);\r\nif (ret) {\r\ndev_err(&pdev->dev,\r\n"can't put vbus gpio %d as output %d\n",\r\ngpio, !pdata->vbus_pin_active_low[i]);\r\ngpio_free(gpio);\r\ncontinue;\r\n}\r\nohci_at91_usb_set_power(pdata, i, 1);\r\n}\r\nat91_for_each_port(i) {\r\nif (i >= pdata->ports)\r\nbreak;\r\npdata->overcurrent_pin[i] =\r\nof_get_named_gpio_flags(np, "atmel,oc-gpio", i, &flags);\r\nif (!gpio_is_valid(pdata->overcurrent_pin[i]))\r\ncontinue;\r\ngpio = pdata->overcurrent_pin[i];\r\nret = gpio_request(gpio, "ohci_overcurrent");\r\nif (ret) {\r\ndev_err(&pdev->dev,\r\n"can't request overcurrent gpio %d\n",\r\ngpio);\r\ncontinue;\r\n}\r\nret = gpio_direction_input(gpio);\r\nif (ret) {\r\ndev_err(&pdev->dev,\r\n"can't configure overcurrent gpio %d as input\n",\r\ngpio);\r\ngpio_free(gpio);\r\ncontinue;\r\n}\r\nret = request_irq(gpio_to_irq(gpio),\r\nohci_hcd_at91_overcurrent_irq,\r\nIRQF_SHARED, "ohci_overcurrent", pdev);\r\nif (ret) {\r\ngpio_free(gpio);\r\ndev_err(&pdev->dev,\r\n"can't get gpio IRQ for overcurrent\n");\r\n}\r\n}\r\ndevice_init_wakeup(&pdev->dev, 1);\r\nreturn usb_hcd_at91_probe(&ohci_at91_hc_driver, pdev);\r\n}\r\nstatic int ohci_hcd_at91_drv_remove(struct platform_device *pdev)\r\n{\r\nstruct at91_usbh_data *pdata = dev_get_platdata(&pdev->dev);\r\nint i;\r\nif (pdata) {\r\nat91_for_each_port(i) {\r\nif (!gpio_is_valid(pdata->vbus_pin[i]))\r\ncontinue;\r\nohci_at91_usb_set_power(pdata, i, 0);\r\ngpio_free(pdata->vbus_pin[i]);\r\n}\r\nat91_for_each_port(i) {\r\nif (!gpio_is_valid(pdata->overcurrent_pin[i]))\r\ncontinue;\r\nfree_irq(gpio_to_irq(pdata->overcurrent_pin[i]), pdev);\r\ngpio_free(pdata->overcurrent_pin[i]);\r\n}\r\n}\r\ndevice_init_wakeup(&pdev->dev, 0);\r\nusb_hcd_at91_remove(platform_get_drvdata(pdev), pdev);\r\nreturn 0;\r\n}\r\nstatic int\r\nohci_hcd_at91_drv_suspend(struct device *dev)\r\n{\r\nstruct usb_hcd *hcd = dev_get_drvdata(dev);\r\nstruct ohci_hcd *ohci = hcd_to_ohci(hcd);\r\nstruct ohci_at91_priv *ohci_at91 = hcd_to_ohci_at91_priv(hcd);\r\nint ret;\r\nohci_at91->wakeup = device_may_wakeup(dev)\r\n&& !at91_suspend_entering_slow_clock();\r\nif (ohci_at91->wakeup)\r\nenable_irq_wake(hcd->irq);\r\nret = ohci_suspend(hcd, ohci_at91->wakeup);\r\nif (ret) {\r\nif (ohci_at91->wakeup)\r\ndisable_irq_wake(hcd->irq);\r\nreturn ret;\r\n}\r\nif (!ohci_at91->wakeup) {\r\nohci->hc_control = ohci_readl(ohci, &ohci->regs->control);\r\nohci->hc_control &= OHCI_CTRL_RWC;\r\nohci_writel(ohci, ohci->hc_control, &ohci->regs->control);\r\nohci->rh_state = OHCI_RH_HALTED;\r\n(void) ohci_readl (ohci, &ohci->regs->control);\r\nat91_stop_clock(ohci_at91);\r\n}\r\nreturn ret;\r\n}\r\nstatic int ohci_hcd_at91_drv_resume(struct device *dev)\r\n{\r\nstruct usb_hcd *hcd = dev_get_drvdata(dev);\r\nstruct ohci_at91_priv *ohci_at91 = hcd_to_ohci_at91_priv(hcd);\r\nif (ohci_at91->wakeup)\r\ndisable_irq_wake(hcd->irq);\r\nat91_start_clock(ohci_at91);\r\nohci_resume(hcd, false);\r\nreturn 0;\r\n}\r\nstatic int __init ohci_at91_init(void)\r\n{\r\nif (usb_disabled())\r\nreturn -ENODEV;\r\npr_info("%s: " DRIVER_DESC "\n", hcd_name);\r\nohci_init_driver(&ohci_at91_hc_driver, &ohci_at91_drv_overrides);\r\nohci_at91_hc_driver.hub_status_data = ohci_at91_hub_status_data;\r\nohci_at91_hc_driver.hub_control = ohci_at91_hub_control;\r\nreturn platform_driver_register(&ohci_hcd_at91_driver);\r\n}\r\nstatic void __exit ohci_at91_cleanup(void)\r\n{\r\nplatform_driver_unregister(&ohci_hcd_at91_driver);\r\n}
