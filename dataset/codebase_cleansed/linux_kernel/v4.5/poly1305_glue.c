static int poly1305_simd_init(struct shash_desc *desc)\r\n{\r\nstruct poly1305_simd_desc_ctx *sctx = shash_desc_ctx(desc);\r\nsctx->uset = false;\r\n#ifdef CONFIG_AS_AVX2\r\nsctx->wset = false;\r\n#endif\r\nreturn crypto_poly1305_init(desc);\r\n}\r\nstatic void poly1305_simd_mult(u32 *a, const u32 *b)\r\n{\r\nu8 m[POLY1305_BLOCK_SIZE];\r\nmemset(m, 0, sizeof(m));\r\na[4] -= 1 << 24;\r\npoly1305_block_sse2(a, m, b, 1);\r\n}\r\nstatic unsigned int poly1305_simd_blocks(struct poly1305_desc_ctx *dctx,\r\nconst u8 *src, unsigned int srclen)\r\n{\r\nstruct poly1305_simd_desc_ctx *sctx;\r\nunsigned int blocks, datalen;\r\nBUILD_BUG_ON(offsetof(struct poly1305_simd_desc_ctx, base));\r\nsctx = container_of(dctx, struct poly1305_simd_desc_ctx, base);\r\nif (unlikely(!dctx->sset)) {\r\ndatalen = crypto_poly1305_setdesckey(dctx, src, srclen);\r\nsrc += srclen - datalen;\r\nsrclen = datalen;\r\n}\r\n#ifdef CONFIG_AS_AVX2\r\nif (poly1305_use_avx2 && srclen >= POLY1305_BLOCK_SIZE * 4) {\r\nif (unlikely(!sctx->wset)) {\r\nif (!sctx->uset) {\r\nmemcpy(sctx->u, dctx->r, sizeof(sctx->u));\r\npoly1305_simd_mult(sctx->u, dctx->r);\r\nsctx->uset = true;\r\n}\r\nmemcpy(sctx->u + 5, sctx->u, sizeof(sctx->u));\r\npoly1305_simd_mult(sctx->u + 5, dctx->r);\r\nmemcpy(sctx->u + 10, sctx->u + 5, sizeof(sctx->u));\r\npoly1305_simd_mult(sctx->u + 10, dctx->r);\r\nsctx->wset = true;\r\n}\r\nblocks = srclen / (POLY1305_BLOCK_SIZE * 4);\r\npoly1305_4block_avx2(dctx->h, src, dctx->r, blocks, sctx->u);\r\nsrc += POLY1305_BLOCK_SIZE * 4 * blocks;\r\nsrclen -= POLY1305_BLOCK_SIZE * 4 * blocks;\r\n}\r\n#endif\r\nif (likely(srclen >= POLY1305_BLOCK_SIZE * 2)) {\r\nif (unlikely(!sctx->uset)) {\r\nmemcpy(sctx->u, dctx->r, sizeof(sctx->u));\r\npoly1305_simd_mult(sctx->u, dctx->r);\r\nsctx->uset = true;\r\n}\r\nblocks = srclen / (POLY1305_BLOCK_SIZE * 2);\r\npoly1305_2block_sse2(dctx->h, src, dctx->r, blocks, sctx->u);\r\nsrc += POLY1305_BLOCK_SIZE * 2 * blocks;\r\nsrclen -= POLY1305_BLOCK_SIZE * 2 * blocks;\r\n}\r\nif (srclen >= POLY1305_BLOCK_SIZE) {\r\npoly1305_block_sse2(dctx->h, src, dctx->r, 1);\r\nsrclen -= POLY1305_BLOCK_SIZE;\r\n}\r\nreturn srclen;\r\n}\r\nstatic int poly1305_simd_update(struct shash_desc *desc,\r\nconst u8 *src, unsigned int srclen)\r\n{\r\nstruct poly1305_desc_ctx *dctx = shash_desc_ctx(desc);\r\nunsigned int bytes;\r\nif (srclen <= 288 || !may_use_simd())\r\nreturn crypto_poly1305_update(desc, src, srclen);\r\nkernel_fpu_begin();\r\nif (unlikely(dctx->buflen)) {\r\nbytes = min(srclen, POLY1305_BLOCK_SIZE - dctx->buflen);\r\nmemcpy(dctx->buf + dctx->buflen, src, bytes);\r\nsrc += bytes;\r\nsrclen -= bytes;\r\ndctx->buflen += bytes;\r\nif (dctx->buflen == POLY1305_BLOCK_SIZE) {\r\npoly1305_simd_blocks(dctx, dctx->buf,\r\nPOLY1305_BLOCK_SIZE);\r\ndctx->buflen = 0;\r\n}\r\n}\r\nif (likely(srclen >= POLY1305_BLOCK_SIZE)) {\r\nbytes = poly1305_simd_blocks(dctx, src, srclen);\r\nsrc += srclen - bytes;\r\nsrclen = bytes;\r\n}\r\nkernel_fpu_end();\r\nif (unlikely(srclen)) {\r\ndctx->buflen = srclen;\r\nmemcpy(dctx->buf, src, srclen);\r\n}\r\nreturn 0;\r\n}\r\nstatic int __init poly1305_simd_mod_init(void)\r\n{\r\nif (!cpu_has_xmm2)\r\nreturn -ENODEV;\r\n#ifdef CONFIG_AS_AVX2\r\npoly1305_use_avx2 = cpu_has_avx && cpu_has_avx2 &&\r\ncpu_has_xfeatures(XFEATURE_MASK_SSE | XFEATURE_MASK_YMM, NULL);\r\nalg.descsize = sizeof(struct poly1305_simd_desc_ctx);\r\nif (poly1305_use_avx2)\r\nalg.descsize += 10 * sizeof(u32);\r\n#endif\r\nreturn crypto_register_shash(&alg);\r\n}\r\nstatic void __exit poly1305_simd_mod_exit(void)\r\n{\r\ncrypto_unregister_shash(&alg);\r\n}
