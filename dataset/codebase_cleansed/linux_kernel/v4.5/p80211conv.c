int skb_ether_to_p80211(wlandevice_t *wlandev, u32 ethconv,\r\nstruct sk_buff *skb, union p80211_hdr *p80211_hdr,\r\nstruct p80211_metawep *p80211_wep)\r\n{\r\n__le16 fc;\r\nu16 proto;\r\nstruct wlan_ethhdr e_hdr;\r\nstruct wlan_llc *e_llc;\r\nstruct wlan_snap *e_snap;\r\nint foo;\r\nmemcpy(&e_hdr, skb->data, sizeof(e_hdr));\r\nif (skb->len <= 0) {\r\npr_debug("zero-length skb!\n");\r\nreturn 1;\r\n}\r\nif (ethconv == WLAN_ETHCONV_ENCAP) {\r\npr_debug("ENCAP len: %d\n", skb->len);\r\n} else {\r\nproto = ntohs(e_hdr.type);\r\nif (proto <= ETH_DATA_LEN) {\r\npr_debug("802.3 len: %d\n", skb->len);\r\nskb_pull(skb, ETH_HLEN);\r\nskb_trim(skb, proto);\r\n} else {\r\npr_debug("DIXII len: %d\n", skb->len);\r\nskb_pull(skb, ETH_HLEN);\r\ne_snap =\r\n(struct wlan_snap *) skb_push(skb,\r\nsizeof(struct wlan_snap));\r\ne_snap->type = htons(proto);\r\nif (ethconv == WLAN_ETHCONV_8021h\r\n&& p80211_stt_findproto(proto)) {\r\nmemcpy(e_snap->oui, oui_8021h,\r\nWLAN_IEEE_OUI_LEN);\r\n} else {\r\nmemcpy(e_snap->oui, oui_rfc1042,\r\nWLAN_IEEE_OUI_LEN);\r\n}\r\ne_llc =\r\n(struct wlan_llc *) skb_push(skb,\r\nsizeof(struct wlan_llc));\r\ne_llc->dsap = 0xAA;\r\ne_llc->ssap = 0xAA;\r\ne_llc->ctl = 0x03;\r\n}\r\n}\r\nfc = cpu_to_le16(WLAN_SET_FC_FTYPE(WLAN_FTYPE_DATA) |\r\nWLAN_SET_FC_FSTYPE(WLAN_FSTYPE_DATAONLY));\r\nswitch (wlandev->macmode) {\r\ncase WLAN_MACMODE_IBSS_STA:\r\nmemcpy(p80211_hdr->a3.a1, &e_hdr.daddr, ETH_ALEN);\r\nmemcpy(p80211_hdr->a3.a2, wlandev->netdev->dev_addr, ETH_ALEN);\r\nmemcpy(p80211_hdr->a3.a3, wlandev->bssid, ETH_ALEN);\r\nbreak;\r\ncase WLAN_MACMODE_ESS_STA:\r\nfc |= cpu_to_le16(WLAN_SET_FC_TODS(1));\r\nmemcpy(p80211_hdr->a3.a1, wlandev->bssid, ETH_ALEN);\r\nmemcpy(p80211_hdr->a3.a2, wlandev->netdev->dev_addr, ETH_ALEN);\r\nmemcpy(p80211_hdr->a3.a3, &e_hdr.daddr, ETH_ALEN);\r\nbreak;\r\ncase WLAN_MACMODE_ESS_AP:\r\nfc |= cpu_to_le16(WLAN_SET_FC_FROMDS(1));\r\nmemcpy(p80211_hdr->a3.a1, &e_hdr.daddr, ETH_ALEN);\r\nmemcpy(p80211_hdr->a3.a2, wlandev->bssid, ETH_ALEN);\r\nmemcpy(p80211_hdr->a3.a3, &e_hdr.saddr, ETH_ALEN);\r\nbreak;\r\ndefault:\r\nnetdev_err(wlandev->netdev,\r\n"Error: Converting eth to wlan in unknown mode.\n");\r\nreturn 1;\r\n}\r\np80211_wep->data = NULL;\r\nif ((wlandev->hostwep & HOSTWEP_PRIVACYINVOKED)\r\n&& (wlandev->hostwep & HOSTWEP_ENCRYPT)) {\r\np80211_wep->data = kmalloc(skb->len, GFP_ATOMIC);\r\nif (!p80211_wep->data)\r\nreturn -ENOMEM;\r\nfoo = wep_encrypt(wlandev, skb->data, p80211_wep->data,\r\nskb->len,\r\n(wlandev->hostwep & HOSTWEP_DEFAULTKEY_MASK),\r\np80211_wep->iv, p80211_wep->icv);\r\nif (foo) {\r\nnetdev_warn(wlandev->netdev,\r\n"Host en-WEP failed, dropping frame (%d).\n",\r\nfoo);\r\nreturn 2;\r\n}\r\nfc |= cpu_to_le16(WLAN_SET_FC_ISWEP(1));\r\n}\r\np80211_hdr->a3.fc = fc;\r\np80211_hdr->a3.dur = 0;\r\np80211_hdr->a3.seq = 0;\r\nreturn 0;\r\n}\r\nstatic void orinoco_spy_gather(wlandevice_t *wlandev, char *mac,\r\nstruct p80211_rxmeta *rxmeta)\r\n{\r\nint i;\r\nfor (i = 0; i < wlandev->spy_number; i++) {\r\nif (!memcmp(wlandev->spy_address[i], mac, ETH_ALEN)) {\r\nmemcpy(wlandev->spy_address[i], mac, ETH_ALEN);\r\nwlandev->spy_stat[i].level = rxmeta->signal;\r\nwlandev->spy_stat[i].noise = rxmeta->noise;\r\nwlandev->spy_stat[i].qual =\r\n(rxmeta->signal >\r\nrxmeta->noise) ? (rxmeta->signal -\r\nrxmeta->noise) : 0;\r\nwlandev->spy_stat[i].updated = 0x7;\r\n}\r\n}\r\n}\r\nint skb_p80211_to_ether(wlandevice_t *wlandev, u32 ethconv,\r\nstruct sk_buff *skb)\r\n{\r\nnetdevice_t *netdev = wlandev->netdev;\r\nu16 fc;\r\nunsigned int payload_length;\r\nunsigned int payload_offset;\r\nu8 daddr[ETH_ALEN];\r\nu8 saddr[ETH_ALEN];\r\nunion p80211_hdr *w_hdr;\r\nstruct wlan_ethhdr *e_hdr;\r\nstruct wlan_llc *e_llc;\r\nstruct wlan_snap *e_snap;\r\nint foo;\r\npayload_length = skb->len - WLAN_HDR_A3_LEN - WLAN_CRC_LEN;\r\npayload_offset = WLAN_HDR_A3_LEN;\r\nw_hdr = (union p80211_hdr *) skb->data;\r\nfc = le16_to_cpu(w_hdr->a3.fc);\r\nif ((WLAN_GET_FC_TODS(fc) == 0) && (WLAN_GET_FC_FROMDS(fc) == 0)) {\r\nether_addr_copy(daddr, w_hdr->a3.a1);\r\nether_addr_copy(saddr, w_hdr->a3.a2);\r\n} else if ((WLAN_GET_FC_TODS(fc) == 0)\r\n&& (WLAN_GET_FC_FROMDS(fc) == 1)) {\r\nether_addr_copy(daddr, w_hdr->a3.a1);\r\nether_addr_copy(saddr, w_hdr->a3.a3);\r\n} else if ((WLAN_GET_FC_TODS(fc) == 1)\r\n&& (WLAN_GET_FC_FROMDS(fc) == 0)) {\r\nether_addr_copy(daddr, w_hdr->a3.a3);\r\nether_addr_copy(saddr, w_hdr->a3.a2);\r\n} else {\r\npayload_offset = WLAN_HDR_A4_LEN;\r\nif (payload_length < WLAN_HDR_A4_LEN - WLAN_HDR_A3_LEN) {\r\nnetdev_err(netdev, "A4 frame too short!\n");\r\nreturn 1;\r\n}\r\npayload_length -= (WLAN_HDR_A4_LEN - WLAN_HDR_A3_LEN);\r\nether_addr_copy(daddr, w_hdr->a4.a3);\r\nether_addr_copy(saddr, w_hdr->a4.a4);\r\n}\r\nif ((wlandev->hostwep & HOSTWEP_PRIVACYINVOKED) && WLAN_GET_FC_ISWEP(fc)\r\n&& (wlandev->hostwep & HOSTWEP_DECRYPT)) {\r\nif (payload_length <= 8) {\r\nnetdev_err(netdev,\r\n"WEP frame too short (%u).\n", skb->len);\r\nreturn 1;\r\n}\r\nfoo = wep_decrypt(wlandev, skb->data + payload_offset + 4,\r\npayload_length - 8, -1,\r\nskb->data + payload_offset,\r\nskb->data + payload_offset +\r\npayload_length - 4);\r\nif (foo) {\r\npr_debug("Host de-WEP failed, dropping frame (%d).\n",\r\nfoo);\r\nwlandev->rx.decrypt_err++;\r\nreturn 2;\r\n}\r\npayload_length -= 8;\r\nskb_pull(skb, 4);\r\nskb_trim(skb, skb->len - 4);\r\nwlandev->rx.decrypt++;\r\n}\r\ne_hdr = (struct wlan_ethhdr *) (skb->data + payload_offset);\r\ne_llc = (struct wlan_llc *) (skb->data + payload_offset);\r\ne_snap =\r\n(struct wlan_snap *) (skb->data + payload_offset +\r\nsizeof(struct wlan_llc));\r\nif ((payload_length >= sizeof(struct wlan_ethhdr)) &&\r\n(e_llc->dsap != 0xaa || e_llc->ssap != 0xaa) &&\r\n((!ether_addr_equal_unaligned(daddr, e_hdr->daddr)) ||\r\n(!ether_addr_equal_unaligned(saddr, e_hdr->saddr)))) {\r\npr_debug("802.3 ENCAP len: %d\n", payload_length);\r\nif (payload_length > (netdev->mtu + ETH_HLEN)) {\r\nnetdev_err(netdev, "ENCAP frame too large (%d > %d)\n",\r\npayload_length, netdev->mtu + ETH_HLEN);\r\nreturn 1;\r\n}\r\nskb_pull(skb, payload_offset);\r\nskb_trim(skb, skb->len - WLAN_CRC_LEN);\r\n} else if ((payload_length >= sizeof(struct wlan_llc) +\r\nsizeof(struct wlan_snap))\r\n&& (e_llc->dsap == 0xaa)\r\n&& (e_llc->ssap == 0xaa)\r\n&& (e_llc->ctl == 0x03)\r\n&&\r\n(((memcmp(e_snap->oui, oui_rfc1042, WLAN_IEEE_OUI_LEN) == 0)\r\n&& (ethconv == WLAN_ETHCONV_8021h)\r\n&& (p80211_stt_findproto(le16_to_cpu(e_snap->type))))\r\n|| (memcmp(e_snap->oui, oui_rfc1042, WLAN_IEEE_OUI_LEN) !=\r\n0))) {\r\npr_debug("SNAP+RFC1042 len: %d\n", payload_length);\r\nif (payload_length > netdev->mtu) {\r\nnetdev_err(netdev, "SNAP frame too large (%d > %d)\n",\r\npayload_length, netdev->mtu);\r\nreturn 1;\r\n}\r\nskb_pull(skb, payload_offset);\r\ne_hdr = (struct wlan_ethhdr *)skb_push(skb, ETH_HLEN);\r\nether_addr_copy(e_hdr->daddr, daddr);\r\nether_addr_copy(e_hdr->saddr, saddr);\r\ne_hdr->type = htons(payload_length);\r\nskb_trim(skb, skb->len - WLAN_CRC_LEN);\r\n} else if ((payload_length >= sizeof(struct wlan_llc) +\r\nsizeof(struct wlan_snap))\r\n&& (e_llc->dsap == 0xaa)\r\n&& (e_llc->ssap == 0xaa)\r\n&& (e_llc->ctl == 0x03)) {\r\npr_debug("802.1h/RFC1042 len: %d\n", payload_length);\r\nif ((payload_length - sizeof(struct wlan_llc) -\r\nsizeof(struct wlan_snap))\r\n> netdev->mtu) {\r\nnetdev_err(netdev, "DIXII frame too large (%ld > %d)\n",\r\n(long int)(payload_length -\r\nsizeof(struct wlan_llc) -\r\nsizeof(struct wlan_snap)), netdev->mtu);\r\nreturn 1;\r\n}\r\nskb_pull(skb, payload_offset);\r\nskb_pull(skb, sizeof(struct wlan_llc));\r\nskb_pull(skb, sizeof(struct wlan_snap));\r\ne_hdr = (struct wlan_ethhdr *)skb_push(skb, ETH_HLEN);\r\ne_hdr->type = e_snap->type;\r\nether_addr_copy(e_hdr->daddr, daddr);\r\nether_addr_copy(e_hdr->saddr, saddr);\r\nskb_trim(skb, skb->len - WLAN_CRC_LEN);\r\n} else {\r\npr_debug("NON-ENCAP len: %d\n", payload_length);\r\nif (payload_length > netdev->mtu) {\r\nnetdev_err(netdev, "OTHER frame too large (%d > %d)\n",\r\npayload_length, netdev->mtu);\r\nreturn 1;\r\n}\r\nskb_pull(skb, payload_offset);\r\ne_hdr = (struct wlan_ethhdr *)skb_push(skb, ETH_HLEN);\r\nether_addr_copy(e_hdr->daddr, daddr);\r\nether_addr_copy(e_hdr->saddr, saddr);\r\ne_hdr->type = htons(payload_length);\r\nskb_trim(skb, skb->len - WLAN_CRC_LEN);\r\n}\r\nskb->protocol = eth_type_trans(skb, netdev);\r\nif (wlandev->spy_number)\r\norinoco_spy_gather(wlandev, eth_hdr(skb)->h_source,\r\nP80211SKB_RXMETA(skb));\r\np80211skb_rxmeta_detach(skb);\r\nreturn 0;\r\n}\r\nint p80211_stt_findproto(u16 proto)\r\n{\r\nif (proto == ETH_P_AARP)\r\nreturn 1;\r\nreturn 0;\r\n}\r\nvoid p80211skb_rxmeta_detach(struct sk_buff *skb)\r\n{\r\nstruct p80211_rxmeta *rxmeta;\r\nstruct p80211_frmmeta *frmmeta;\r\nif (skb == NULL) {\r\npr_debug("Called w/ null skb.\n");\r\nreturn;\r\n}\r\nfrmmeta = P80211SKB_FRMMETA(skb);\r\nif (frmmeta == NULL) {\r\npr_debug("Called w/ bad frmmeta magic.\n");\r\nreturn;\r\n}\r\nrxmeta = frmmeta->rx;\r\nif (rxmeta == NULL) {\r\npr_debug("Called w/ bad rxmeta ptr.\n");\r\nreturn;\r\n}\r\nkfree(rxmeta);\r\nmemset(skb->cb, 0, sizeof(skb->cb));\r\n}\r\nint p80211skb_rxmeta_attach(struct wlandevice *wlandev, struct sk_buff *skb)\r\n{\r\nint result = 0;\r\nstruct p80211_rxmeta *rxmeta;\r\nstruct p80211_frmmeta *frmmeta;\r\nif (P80211SKB_RXMETA(skb) != NULL) {\r\nnetdev_err(wlandev->netdev,\r\n"%s: RXmeta already attached!\n", wlandev->name);\r\nresult = 0;\r\ngoto exit;\r\n}\r\nrxmeta = kzalloc(sizeof(struct p80211_rxmeta), GFP_ATOMIC);\r\nif (rxmeta == NULL) {\r\nnetdev_err(wlandev->netdev,\r\n"%s: Failed to allocate rxmeta.\n", wlandev->name);\r\nresult = 1;\r\ngoto exit;\r\n}\r\nrxmeta->wlandev = wlandev;\r\nrxmeta->hosttime = jiffies;\r\nmemset(skb->cb, 0, sizeof(struct p80211_frmmeta));\r\nfrmmeta = (struct p80211_frmmeta *) (skb->cb);\r\nfrmmeta->magic = P80211_FRMMETA_MAGIC;\r\nfrmmeta->rx = rxmeta;\r\nexit:\r\nreturn result;\r\n}\r\nvoid p80211skb_free(struct wlandevice *wlandev, struct sk_buff *skb)\r\n{\r\nstruct p80211_frmmeta *meta;\r\nmeta = P80211SKB_FRMMETA(skb);\r\nif (meta && meta->rx)\r\np80211skb_rxmeta_detach(skb);\r\nelse\r\nnetdev_err(wlandev->netdev,\r\n"Freeing an skb (%p) w/ no frmmeta.\n", skb);\r\ndev_kfree_skb(skb);\r\n}
