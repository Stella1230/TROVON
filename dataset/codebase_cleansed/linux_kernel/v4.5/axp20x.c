static void axp20x_power_off(void)\r\n{\r\nif (axp20x_pm_power_off->variant == AXP288_ID)\r\nreturn;\r\nregmap_write(axp20x_pm_power_off->regmap, AXP20X_OFF_CTRL,\r\nAXP20X_OFF);\r\n}\r\nstatic int axp20x_match_device(struct axp20x_dev *axp20x, struct device *dev)\r\n{\r\nconst struct acpi_device_id *acpi_id;\r\nconst struct of_device_id *of_id;\r\nif (dev->of_node) {\r\nof_id = of_match_device(axp20x_of_match, dev);\r\nif (!of_id) {\r\ndev_err(dev, "Unable to match OF ID\n");\r\nreturn -ENODEV;\r\n}\r\naxp20x->variant = (long) of_id->data;\r\n} else {\r\nacpi_id = acpi_match_device(dev->driver->acpi_match_table, dev);\r\nif (!acpi_id || !acpi_id->driver_data) {\r\ndev_err(dev, "Unable to match ACPI ID and data\n");\r\nreturn -ENODEV;\r\n}\r\naxp20x->variant = (long) acpi_id->driver_data;\r\n}\r\nswitch (axp20x->variant) {\r\ncase AXP152_ID:\r\naxp20x->nr_cells = ARRAY_SIZE(axp152_cells);\r\naxp20x->cells = axp152_cells;\r\naxp20x->regmap_cfg = &axp152_regmap_config;\r\naxp20x->regmap_irq_chip = &axp152_regmap_irq_chip;\r\nbreak;\r\ncase AXP202_ID:\r\ncase AXP209_ID:\r\naxp20x->nr_cells = ARRAY_SIZE(axp20x_cells);\r\naxp20x->cells = axp20x_cells;\r\naxp20x->regmap_cfg = &axp20x_regmap_config;\r\naxp20x->regmap_irq_chip = &axp20x_regmap_irq_chip;\r\nbreak;\r\ncase AXP221_ID:\r\naxp20x->nr_cells = ARRAY_SIZE(axp22x_cells);\r\naxp20x->cells = axp22x_cells;\r\naxp20x->regmap_cfg = &axp22x_regmap_config;\r\naxp20x->regmap_irq_chip = &axp22x_regmap_irq_chip;\r\nbreak;\r\ncase AXP288_ID:\r\naxp20x->cells = axp288_cells;\r\naxp20x->nr_cells = ARRAY_SIZE(axp288_cells);\r\naxp20x->regmap_cfg = &axp288_regmap_config;\r\naxp20x->regmap_irq_chip = &axp288_regmap_irq_chip;\r\nbreak;\r\ndefault:\r\ndev_err(dev, "unsupported AXP20X ID %lu\n", axp20x->variant);\r\nreturn -EINVAL;\r\n}\r\ndev_info(dev, "AXP20x variant %s found\n",\r\naxp20x_model_names[axp20x->variant]);\r\nreturn 0;\r\n}\r\nstatic int axp20x_i2c_probe(struct i2c_client *i2c,\r\nconst struct i2c_device_id *id)\r\n{\r\nstruct axp20x_dev *axp20x;\r\nint ret;\r\naxp20x = devm_kzalloc(&i2c->dev, sizeof(*axp20x), GFP_KERNEL);\r\nif (!axp20x)\r\nreturn -ENOMEM;\r\nret = axp20x_match_device(axp20x, &i2c->dev);\r\nif (ret)\r\nreturn ret;\r\naxp20x->i2c_client = i2c;\r\naxp20x->dev = &i2c->dev;\r\ndev_set_drvdata(axp20x->dev, axp20x);\r\naxp20x->regmap = devm_regmap_init_i2c(i2c, axp20x->regmap_cfg);\r\nif (IS_ERR(axp20x->regmap)) {\r\nret = PTR_ERR(axp20x->regmap);\r\ndev_err(&i2c->dev, "regmap init failed: %d\n", ret);\r\nreturn ret;\r\n}\r\nret = regmap_add_irq_chip(axp20x->regmap, i2c->irq,\r\nIRQF_ONESHOT | IRQF_SHARED, -1,\r\naxp20x->regmap_irq_chip,\r\n&axp20x->regmap_irqc);\r\nif (ret) {\r\ndev_err(&i2c->dev, "failed to add irq chip: %d\n", ret);\r\nreturn ret;\r\n}\r\nret = mfd_add_devices(axp20x->dev, -1, axp20x->cells,\r\naxp20x->nr_cells, NULL, 0, NULL);\r\nif (ret) {\r\ndev_err(&i2c->dev, "failed to add MFD devices: %d\n", ret);\r\nregmap_del_irq_chip(i2c->irq, axp20x->regmap_irqc);\r\nreturn ret;\r\n}\r\nif (!pm_power_off) {\r\naxp20x_pm_power_off = axp20x;\r\npm_power_off = axp20x_power_off;\r\n}\r\ndev_info(&i2c->dev, "AXP20X driver loaded\n");\r\nreturn 0;\r\n}\r\nstatic int axp20x_i2c_remove(struct i2c_client *i2c)\r\n{\r\nstruct axp20x_dev *axp20x = i2c_get_clientdata(i2c);\r\nif (axp20x == axp20x_pm_power_off) {\r\naxp20x_pm_power_off = NULL;\r\npm_power_off = NULL;\r\n}\r\nmfd_remove_devices(axp20x->dev);\r\nregmap_del_irq_chip(axp20x->i2c_client->irq, axp20x->regmap_irqc);\r\nreturn 0;\r\n}
