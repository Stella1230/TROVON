static int shadow_and_reallocate_code (struct snd_cs46xx * chip, u32 * data, u32 size,\r\nu32 overlay_begin_address)\r\n{\r\nunsigned int i = 0, j, nreallocated = 0;\r\nu32 hival,loval,address;\r\nu32 mop_operands,mop_type,wide_op;\r\nstruct dsp_spos_instance * ins = chip->dsp_spos_instance;\r\nif (snd_BUG_ON(size %2))\r\nreturn -EINVAL;\r\nwhile (i < size) {\r\nloval = data[i++];\r\nhival = data[i++];\r\nif (ins->code.offset > 0) {\r\nmop_operands = (hival >> 6) & 0x03fff;\r\nmop_type = mop_operands >> 10;\r\nif (mop_type == 0 &&\r\n(mop_operands & WIDE_LADD_INSTR_MASK) == 0 &&\r\n(mop_operands & WIDE_INSTR_MASK) != 0) {\r\nwide_op = loval & 0x7f;\r\nfor (j = 0;j < ARRAY_SIZE(wide_opcodes); ++j) {\r\nif (wide_opcodes[j] == wide_op) {\r\naddress = (hival & 0x00FFF) << 5;\r\naddress |= loval >> 15;\r\ndev_dbg(chip->card->dev,\r\n"handle_wideop[1]: %05x:%05x addr %04x\n",\r\nhival, loval, address);\r\nif ( !(address & 0x8000) ) {\r\naddress += (ins->code.offset / 2) - overlay_begin_address;\r\n} else {\r\ndev_dbg(chip->card->dev,\r\n"handle_wideop[1]: ROM symbol not reallocated\n");\r\n}\r\nhival &= 0xFF000;\r\nloval &= 0x07FFF;\r\nhival |= ( (address >> 5) & 0x00FFF);\r\nloval |= ( (address << 15) & 0xF8000);\r\naddress = (hival & 0x00FFF) << 5;\r\naddress |= loval >> 15;\r\ndev_dbg(chip->card->dev,\r\n"handle_wideop:[2] %05x:%05x addr %04x\n",\r\nhival, loval, address); nreallocated++;\r\n}\r\n}\r\n}\r\n}\r\nins->code.data[ins->code.size++] = loval;\r\nins->code.data[ins->code.size++] = hival;\r\n}\r\ndev_dbg(chip->card->dev,\r\n"dsp_spos: %d instructions reallocated\n", nreallocated);\r\nreturn nreallocated;\r\n}\r\nstatic struct dsp_segment_desc * get_segment_desc (struct dsp_module_desc * module, int seg_type)\r\n{\r\nint i;\r\nfor (i = 0;i < module->nsegments; ++i) {\r\nif (module->segments[i].segment_type == seg_type) {\r\nreturn (module->segments + i);\r\n}\r\n}\r\nreturn NULL;\r\n}\r\nstatic int find_free_symbol_index (struct dsp_spos_instance * ins)\r\n{\r\nint index = ins->symbol_table.nsymbols,i;\r\nfor (i = ins->symbol_table.highest_frag_index; i < ins->symbol_table.nsymbols; ++i) {\r\nif (ins->symbol_table.symbols[i].deleted) {\r\nindex = i;\r\nbreak;\r\n}\r\n}\r\nreturn index;\r\n}\r\nstatic int add_symbols (struct snd_cs46xx * chip, struct dsp_module_desc * module)\r\n{\r\nint i;\r\nstruct dsp_spos_instance * ins = chip->dsp_spos_instance;\r\nif (module->symbol_table.nsymbols > 0) {\r\nif (!strcmp(module->symbol_table.symbols[0].symbol_name, "OVERLAYBEGINADDRESS") &&\r\nmodule->symbol_table.symbols[0].symbol_type == SYMBOL_CONSTANT ) {\r\nmodule->overlay_begin_address = module->symbol_table.symbols[0].address;\r\n}\r\n}\r\nfor (i = 0;i < module->symbol_table.nsymbols; ++i) {\r\nif (ins->symbol_table.nsymbols == (DSP_MAX_SYMBOLS - 1)) {\r\ndev_err(chip->card->dev,\r\n"dsp_spos: symbol table is full\n");\r\nreturn -ENOMEM;\r\n}\r\nif (cs46xx_dsp_lookup_symbol(chip,\r\nmodule->symbol_table.symbols[i].symbol_name,\r\nmodule->symbol_table.symbols[i].symbol_type) == NULL) {\r\nins->symbol_table.symbols[ins->symbol_table.nsymbols] = module->symbol_table.symbols[i];\r\nins->symbol_table.symbols[ins->symbol_table.nsymbols].address += ((ins->code.offset / 2) - module->overlay_begin_address);\r\nins->symbol_table.symbols[ins->symbol_table.nsymbols].module = module;\r\nins->symbol_table.symbols[ins->symbol_table.nsymbols].deleted = 0;\r\nif (ins->symbol_table.nsymbols > ins->symbol_table.highest_frag_index)\r\nins->symbol_table.highest_frag_index = ins->symbol_table.nsymbols;\r\nins->symbol_table.nsymbols++;\r\n} else {\r\n#if 0\r\ndev_dbg(chip->card->dev,\r\n"dsp_spos: symbol <%s> duplicated, probably nothing wrong with that (Cirrus?)\n",\r\nmodule->symbol_table.symbols[i].symbol_name); */\r\n#endif\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic struct dsp_symbol_entry *\r\nadd_symbol (struct snd_cs46xx * chip, char * symbol_name, u32 address, int type)\r\n{\r\nstruct dsp_spos_instance * ins = chip->dsp_spos_instance;\r\nstruct dsp_symbol_entry * symbol = NULL;\r\nint index;\r\nif (ins->symbol_table.nsymbols == (DSP_MAX_SYMBOLS - 1)) {\r\ndev_err(chip->card->dev, "dsp_spos: symbol table is full\n");\r\nreturn NULL;\r\n}\r\nif (cs46xx_dsp_lookup_symbol(chip,\r\nsymbol_name,\r\ntype) != NULL) {\r\ndev_err(chip->card->dev,\r\n"dsp_spos: symbol <%s> duplicated\n", symbol_name);\r\nreturn NULL;\r\n}\r\nindex = find_free_symbol_index (ins);\r\nstrcpy (ins->symbol_table.symbols[index].symbol_name, symbol_name);\r\nins->symbol_table.symbols[index].address = address;\r\nins->symbol_table.symbols[index].symbol_type = type;\r\nins->symbol_table.symbols[index].module = NULL;\r\nins->symbol_table.symbols[index].deleted = 0;\r\nsymbol = (ins->symbol_table.symbols + index);\r\nif (index > ins->symbol_table.highest_frag_index)\r\nins->symbol_table.highest_frag_index = index;\r\nif (index == ins->symbol_table.nsymbols)\r\nins->symbol_table.nsymbols++;\r\nreturn symbol;\r\n}\r\nstruct dsp_spos_instance *cs46xx_dsp_spos_create (struct snd_cs46xx * chip)\r\n{\r\nstruct dsp_spos_instance * ins = kzalloc(sizeof(struct dsp_spos_instance), GFP_KERNEL);\r\nif (ins == NULL)\r\nreturn NULL;\r\nins->symbol_table.symbols = vmalloc(sizeof(struct dsp_symbol_entry) *\r\nDSP_MAX_SYMBOLS);\r\nins->code.data = kmalloc(DSP_CODE_BYTE_SIZE, GFP_KERNEL);\r\nins->modules = kmalloc(sizeof(struct dsp_module_desc) * DSP_MAX_MODULES, GFP_KERNEL);\r\nif (!ins->symbol_table.symbols || !ins->code.data || !ins->modules) {\r\ncs46xx_dsp_spos_destroy(chip);\r\ngoto error;\r\n}\r\nins->symbol_table.nsymbols = 0;\r\nins->symbol_table.highest_frag_index = 0;\r\nins->code.offset = 0;\r\nins->code.size = 0;\r\nins->nscb = 0;\r\nins->ntask = 0;\r\nins->nmodules = 0;\r\nins->spdif_in_sample_rate = 48000;\r\nins->dac_volume_right = 0x8000;\r\nins->dac_volume_left = 0x8000;\r\nins->spdif_input_volume_right = 0x8000;\r\nins->spdif_input_volume_left = 0x8000;\r\nins->spdif_csuv_default =\r\nins->spdif_csuv_stream =\r\n((unsigned int)_wrap_all_bits( (SNDRV_PCM_DEFAULT_CON_SPDIF & 0xff)) << 24) |\r\n((unsigned int)_wrap_all_bits( ((SNDRV_PCM_DEFAULT_CON_SPDIF >> 8) & 0xff)) << 16) |\r\n(unsigned int)_wrap_all_bits( (SNDRV_PCM_DEFAULT_CON_SPDIF >> 24) & 0xff) |\r\n(1 << 13) | (1 << 12);\r\nreturn ins;\r\nerror:\r\nkfree(ins->modules);\r\nkfree(ins->code.data);\r\nvfree(ins->symbol_table.symbols);\r\nkfree(ins);\r\nreturn NULL;\r\n}\r\nvoid cs46xx_dsp_spos_destroy (struct snd_cs46xx * chip)\r\n{\r\nint i;\r\nstruct dsp_spos_instance * ins = chip->dsp_spos_instance;\r\nif (snd_BUG_ON(!ins))\r\nreturn;\r\nmutex_lock(&chip->spos_mutex);\r\nfor (i = 0; i < ins->nscb; ++i) {\r\nif (ins->scbs[i].deleted) continue;\r\ncs46xx_dsp_proc_free_scb_desc ( (ins->scbs + i) );\r\n#ifdef CONFIG_PM_SLEEP\r\nkfree(ins->scbs[i].data);\r\n#endif\r\n}\r\nkfree(ins->code.data);\r\nvfree(ins->symbol_table.symbols);\r\nkfree(ins->modules);\r\nkfree(ins);\r\nmutex_unlock(&chip->spos_mutex);\r\n}\r\nstatic int dsp_load_parameter(struct snd_cs46xx *chip,\r\nstruct dsp_segment_desc *parameter)\r\n{\r\nu32 doffset, dsize;\r\nif (!parameter) {\r\ndev_dbg(chip->card->dev,\r\n"dsp_spos: module got no parameter segment\n");\r\nreturn 0;\r\n}\r\ndoffset = (parameter->offset * 4 + DSP_PARAMETER_BYTE_OFFSET);\r\ndsize = parameter->size * 4;\r\ndev_dbg(chip->card->dev,\r\n"dsp_spos: downloading parameter data to chip (%08x-%08x)\n",\r\ndoffset,doffset + dsize);\r\nif (snd_cs46xx_download (chip, parameter->data, doffset, dsize)) {\r\ndev_err(chip->card->dev,\r\n"dsp_spos: failed to download parameter data to DSP\n");\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int dsp_load_sample(struct snd_cs46xx *chip,\r\nstruct dsp_segment_desc *sample)\r\n{\r\nu32 doffset, dsize;\r\nif (!sample) {\r\ndev_dbg(chip->card->dev,\r\n"dsp_spos: module got no sample segment\n");\r\nreturn 0;\r\n}\r\ndoffset = (sample->offset * 4 + DSP_SAMPLE_BYTE_OFFSET);\r\ndsize = sample->size * 4;\r\ndev_dbg(chip->card->dev,\r\n"dsp_spos: downloading sample data to chip (%08x-%08x)\n",\r\ndoffset,doffset + dsize);\r\nif (snd_cs46xx_download (chip,sample->data,doffset,dsize)) {\r\ndev_err(chip->card->dev,\r\n"dsp_spos: failed to sample data to DSP\n");\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nint cs46xx_dsp_load_module (struct snd_cs46xx * chip, struct dsp_module_desc * module)\r\n{\r\nstruct dsp_spos_instance * ins = chip->dsp_spos_instance;\r\nstruct dsp_segment_desc * code = get_segment_desc (module,SEGTYPE_SP_PROGRAM);\r\nu32 doffset, dsize;\r\nint err;\r\nif (ins->nmodules == DSP_MAX_MODULES - 1) {\r\ndev_err(chip->card->dev,\r\n"dsp_spos: to many modules loaded into DSP\n");\r\nreturn -ENOMEM;\r\n}\r\ndev_dbg(chip->card->dev,\r\n"dsp_spos: loading module %s into DSP\n", module->module_name);\r\nif (ins->nmodules == 0) {\r\ndev_dbg(chip->card->dev, "dsp_spos: clearing parameter area\n");\r\nsnd_cs46xx_clear_BA1(chip, DSP_PARAMETER_BYTE_OFFSET, DSP_PARAMETER_BYTE_SIZE);\r\n}\r\nerr = dsp_load_parameter(chip, get_segment_desc(module,\r\nSEGTYPE_SP_PARAMETER));\r\nif (err < 0)\r\nreturn err;\r\nif (ins->nmodules == 0) {\r\ndev_dbg(chip->card->dev, "dsp_spos: clearing sample area\n");\r\nsnd_cs46xx_clear_BA1(chip, DSP_SAMPLE_BYTE_OFFSET, DSP_SAMPLE_BYTE_SIZE);\r\n}\r\nerr = dsp_load_sample(chip, get_segment_desc(module,\r\nSEGTYPE_SP_SAMPLE));\r\nif (err < 0)\r\nreturn err;\r\nif (ins->nmodules == 0) {\r\ndev_dbg(chip->card->dev, "dsp_spos: clearing code area\n");\r\nsnd_cs46xx_clear_BA1(chip, DSP_CODE_BYTE_OFFSET, DSP_CODE_BYTE_SIZE);\r\n}\r\nif (code == NULL) {\r\ndev_dbg(chip->card->dev,\r\n"dsp_spos: module got no code segment\n");\r\n} else {\r\nif (ins->code.offset + code->size > DSP_CODE_BYTE_SIZE) {\r\ndev_err(chip->card->dev,\r\n"dsp_spos: no space available in DSP\n");\r\nreturn -ENOMEM;\r\n}\r\nmodule->load_address = ins->code.offset;\r\nmodule->overlay_begin_address = 0x000;\r\nif (snd_BUG_ON(!module->symbol_table.symbols))\r\nreturn -ENOMEM;\r\nif (add_symbols(chip,module)) {\r\ndev_err(chip->card->dev,\r\n"dsp_spos: failed to load symbol table\n");\r\nreturn -ENOMEM;\r\n}\r\ndoffset = (code->offset * 4 + ins->code.offset * 4 + DSP_CODE_BYTE_OFFSET);\r\ndsize = code->size * 4;\r\ndev_dbg(chip->card->dev,\r\n"dsp_spos: downloading code to chip (%08x-%08x)\n",\r\ndoffset,doffset + dsize);\r\nmodule->nfixups = shadow_and_reallocate_code(chip,code->data,code->size,module->overlay_begin_address);\r\nif (snd_cs46xx_download (chip,(ins->code.data + ins->code.offset),doffset,dsize)) {\r\ndev_err(chip->card->dev,\r\n"dsp_spos: failed to download code to DSP\n");\r\nreturn -EINVAL;\r\n}\r\nins->code.offset += code->size;\r\n}\r\nins->modules[ins->nmodules] = *module;\r\nins->nmodules++;\r\nreturn 0;\r\n}\r\nstruct dsp_symbol_entry *\r\ncs46xx_dsp_lookup_symbol (struct snd_cs46xx * chip, char * symbol_name, int symbol_type)\r\n{\r\nint i;\r\nstruct dsp_spos_instance * ins = chip->dsp_spos_instance;\r\nfor ( i = 0; i < ins->symbol_table.nsymbols; ++i ) {\r\nif (ins->symbol_table.symbols[i].deleted)\r\ncontinue;\r\nif (!strcmp(ins->symbol_table.symbols[i].symbol_name,symbol_name) &&\r\nins->symbol_table.symbols[i].symbol_type == symbol_type) {\r\nreturn (ins->symbol_table.symbols + i);\r\n}\r\n}\r\n#if 0\r\ndev_err(chip->card->dev, "dsp_spos: symbol <%s> type %02x not found\n",\r\nsymbol_name,symbol_type);\r\n#endif\r\nreturn NULL;\r\n}\r\nstatic struct dsp_symbol_entry *\r\ncs46xx_dsp_lookup_symbol_addr (struct snd_cs46xx * chip, u32 address, int symbol_type)\r\n{\r\nint i;\r\nstruct dsp_spos_instance * ins = chip->dsp_spos_instance;\r\nfor ( i = 0; i < ins->symbol_table.nsymbols; ++i ) {\r\nif (ins->symbol_table.symbols[i].deleted)\r\ncontinue;\r\nif (ins->symbol_table.symbols[i].address == address &&\r\nins->symbol_table.symbols[i].symbol_type == symbol_type) {\r\nreturn (ins->symbol_table.symbols + i);\r\n}\r\n}\r\nreturn NULL;\r\n}\r\nstatic void cs46xx_dsp_proc_symbol_table_read (struct snd_info_entry *entry,\r\nstruct snd_info_buffer *buffer)\r\n{\r\nstruct snd_cs46xx *chip = entry->private_data;\r\nstruct dsp_spos_instance * ins = chip->dsp_spos_instance;\r\nint i;\r\nsnd_iprintf(buffer, "SYMBOLS:\n");\r\nfor ( i = 0; i < ins->symbol_table.nsymbols; ++i ) {\r\nchar *module_str = "system";\r\nif (ins->symbol_table.symbols[i].deleted)\r\ncontinue;\r\nif (ins->symbol_table.symbols[i].module != NULL) {\r\nmodule_str = ins->symbol_table.symbols[i].module->module_name;\r\n}\r\nsnd_iprintf(buffer, "%04X <%02X> %s [%s]\n",\r\nins->symbol_table.symbols[i].address,\r\nins->symbol_table.symbols[i].symbol_type,\r\nins->symbol_table.symbols[i].symbol_name,\r\nmodule_str);\r\n}\r\n}\r\nstatic void cs46xx_dsp_proc_modules_read (struct snd_info_entry *entry,\r\nstruct snd_info_buffer *buffer)\r\n{\r\nstruct snd_cs46xx *chip = entry->private_data;\r\nstruct dsp_spos_instance * ins = chip->dsp_spos_instance;\r\nint i,j;\r\nmutex_lock(&chip->spos_mutex);\r\nsnd_iprintf(buffer, "MODULES:\n");\r\nfor ( i = 0; i < ins->nmodules; ++i ) {\r\nsnd_iprintf(buffer, "\n%s:\n", ins->modules[i].module_name);\r\nsnd_iprintf(buffer, " %d symbols\n", ins->modules[i].symbol_table.nsymbols);\r\nsnd_iprintf(buffer, " %d fixups\n", ins->modules[i].nfixups);\r\nfor (j = 0; j < ins->modules[i].nsegments; ++ j) {\r\nstruct dsp_segment_desc * desc = (ins->modules[i].segments + j);\r\nsnd_iprintf(buffer, " segment %02x offset %08x size %08x\n",\r\ndesc->segment_type,desc->offset, desc->size);\r\n}\r\n}\r\nmutex_unlock(&chip->spos_mutex);\r\n}\r\nstatic void cs46xx_dsp_proc_task_tree_read (struct snd_info_entry *entry,\r\nstruct snd_info_buffer *buffer)\r\n{\r\nstruct snd_cs46xx *chip = entry->private_data;\r\nstruct dsp_spos_instance * ins = chip->dsp_spos_instance;\r\nint i, j, col;\r\nvoid __iomem *dst = chip->region.idx[1].remap_addr + DSP_PARAMETER_BYTE_OFFSET;\r\nmutex_lock(&chip->spos_mutex);\r\nsnd_iprintf(buffer, "TASK TREES:\n");\r\nfor ( i = 0; i < ins->ntask; ++i) {\r\nsnd_iprintf(buffer,"\n%04x %s:\n",ins->tasks[i].address,ins->tasks[i].task_name);\r\nfor (col = 0,j = 0;j < ins->tasks[i].size; j++,col++) {\r\nu32 val;\r\nif (col == 4) {\r\nsnd_iprintf(buffer,"\n");\r\ncol = 0;\r\n}\r\nval = readl(dst + (ins->tasks[i].address + j) * sizeof(u32));\r\nsnd_iprintf(buffer,"%08x ",val);\r\n}\r\n}\r\nsnd_iprintf(buffer,"\n");\r\nmutex_unlock(&chip->spos_mutex);\r\n}\r\nstatic void cs46xx_dsp_proc_scb_read (struct snd_info_entry *entry,\r\nstruct snd_info_buffer *buffer)\r\n{\r\nstruct snd_cs46xx *chip = entry->private_data;\r\nstruct dsp_spos_instance * ins = chip->dsp_spos_instance;\r\nint i;\r\nmutex_lock(&chip->spos_mutex);\r\nsnd_iprintf(buffer, "SCB's:\n");\r\nfor ( i = 0; i < ins->nscb; ++i) {\r\nif (ins->scbs[i].deleted)\r\ncontinue;\r\nsnd_iprintf(buffer,"\n%04x %s:\n\n",ins->scbs[i].address,ins->scbs[i].scb_name);\r\nif (ins->scbs[i].parent_scb_ptr != NULL) {\r\nsnd_iprintf(buffer,"parent [%s:%04x] ",\r\nins->scbs[i].parent_scb_ptr->scb_name,\r\nins->scbs[i].parent_scb_ptr->address);\r\n} else snd_iprintf(buffer,"parent [none] ");\r\nsnd_iprintf(buffer,"sub_list_ptr [%s:%04x]\nnext_scb_ptr [%s:%04x] task_entry [%s:%04x]\n",\r\nins->scbs[i].sub_list_ptr->scb_name,\r\nins->scbs[i].sub_list_ptr->address,\r\nins->scbs[i].next_scb_ptr->scb_name,\r\nins->scbs[i].next_scb_ptr->address,\r\nins->scbs[i].task_entry->symbol_name,\r\nins->scbs[i].task_entry->address);\r\n}\r\nsnd_iprintf(buffer,"\n");\r\nmutex_unlock(&chip->spos_mutex);\r\n}\r\nstatic void cs46xx_dsp_proc_parameter_dump_read (struct snd_info_entry *entry,\r\nstruct snd_info_buffer *buffer)\r\n{\r\nstruct snd_cs46xx *chip = entry->private_data;\r\nunsigned int i, col = 0;\r\nvoid __iomem *dst = chip->region.idx[1].remap_addr + DSP_PARAMETER_BYTE_OFFSET;\r\nstruct dsp_symbol_entry * symbol;\r\nfor (i = 0;i < DSP_PARAMETER_BYTE_SIZE; i += sizeof(u32),col ++) {\r\nif (col == 4) {\r\nsnd_iprintf(buffer,"\n");\r\ncol = 0;\r\n}\r\nif ( (symbol = cs46xx_dsp_lookup_symbol_addr (chip,i / sizeof(u32), SYMBOL_PARAMETER)) != NULL) {\r\ncol = 0;\r\nsnd_iprintf (buffer,"\n%s:\n",symbol->symbol_name);\r\n}\r\nif (col == 0) {\r\nsnd_iprintf(buffer, "%04X ", i / (unsigned int)sizeof(u32));\r\n}\r\nsnd_iprintf(buffer,"%08X ",readl(dst + i));\r\n}\r\n}\r\nstatic void cs46xx_dsp_proc_sample_dump_read (struct snd_info_entry *entry,\r\nstruct snd_info_buffer *buffer)\r\n{\r\nstruct snd_cs46xx *chip = entry->private_data;\r\nint i,col = 0;\r\nvoid __iomem *dst = chip->region.idx[2].remap_addr;\r\nsnd_iprintf(buffer,"PCMREADER:\n");\r\nfor (i = PCM_READER_BUF1;i < PCM_READER_BUF1 + 0x30; i += sizeof(u32),col ++) {\r\nif (col == 4) {\r\nsnd_iprintf(buffer,"\n");\r\ncol = 0;\r\n}\r\nif (col == 0) {\r\nsnd_iprintf(buffer, "%04X ",i);\r\n}\r\nsnd_iprintf(buffer,"%08X ",readl(dst + i));\r\n}\r\nsnd_iprintf(buffer,"\nMIX_SAMPLE_BUF1:\n");\r\ncol = 0;\r\nfor (i = MIX_SAMPLE_BUF1;i < MIX_SAMPLE_BUF1 + 0x40; i += sizeof(u32),col ++) {\r\nif (col == 4) {\r\nsnd_iprintf(buffer,"\n");\r\ncol = 0;\r\n}\r\nif (col == 0) {\r\nsnd_iprintf(buffer, "%04X ",i);\r\n}\r\nsnd_iprintf(buffer,"%08X ",readl(dst + i));\r\n}\r\nsnd_iprintf(buffer,"\nSRC_TASK_SCB1:\n");\r\ncol = 0;\r\nfor (i = 0x2480 ; i < 0x2480 + 0x40 ; i += sizeof(u32),col ++) {\r\nif (col == 4) {\r\nsnd_iprintf(buffer,"\n");\r\ncol = 0;\r\n}\r\nif (col == 0) {\r\nsnd_iprintf(buffer, "%04X ",i);\r\n}\r\nsnd_iprintf(buffer,"%08X ",readl(dst + i));\r\n}\r\nsnd_iprintf(buffer,"\nSPDIFO_BUFFER:\n");\r\ncol = 0;\r\nfor (i = SPDIFO_IP_OUTPUT_BUFFER1;i < SPDIFO_IP_OUTPUT_BUFFER1 + 0x30; i += sizeof(u32),col ++) {\r\nif (col == 4) {\r\nsnd_iprintf(buffer,"\n");\r\ncol = 0;\r\n}\r\nif (col == 0) {\r\nsnd_iprintf(buffer, "%04X ",i);\r\n}\r\nsnd_iprintf(buffer,"%08X ",readl(dst + i));\r\n}\r\nsnd_iprintf(buffer,"\n...\n");\r\ncol = 0;\r\nfor (i = SPDIFO_IP_OUTPUT_BUFFER1+0xD0;i < SPDIFO_IP_OUTPUT_BUFFER1 + 0x110; i += sizeof(u32),col ++) {\r\nif (col == 4) {\r\nsnd_iprintf(buffer,"\n");\r\ncol = 0;\r\n}\r\nif (col == 0) {\r\nsnd_iprintf(buffer, "%04X ",i);\r\n}\r\nsnd_iprintf(buffer,"%08X ",readl(dst + i));\r\n}\r\nsnd_iprintf(buffer,"\nOUTPUT_SNOOP:\n");\r\ncol = 0;\r\nfor (i = OUTPUT_SNOOP_BUFFER;i < OUTPUT_SNOOP_BUFFER + 0x40; i += sizeof(u32),col ++) {\r\nif (col == 4) {\r\nsnd_iprintf(buffer,"\n");\r\ncol = 0;\r\n}\r\nif (col == 0) {\r\nsnd_iprintf(buffer, "%04X ",i);\r\n}\r\nsnd_iprintf(buffer,"%08X ",readl(dst + i));\r\n}\r\nsnd_iprintf(buffer,"\nCODEC_INPUT_BUF1: \n");\r\ncol = 0;\r\nfor (i = CODEC_INPUT_BUF1;i < CODEC_INPUT_BUF1 + 0x40; i += sizeof(u32),col ++) {\r\nif (col == 4) {\r\nsnd_iprintf(buffer,"\n");\r\ncol = 0;\r\n}\r\nif (col == 0) {\r\nsnd_iprintf(buffer, "%04X ",i);\r\n}\r\nsnd_iprintf(buffer,"%08X ",readl(dst + i));\r\n}\r\n#if 0\r\nsnd_iprintf(buffer,"\nWRITE_BACK_BUF1: \n");\r\ncol = 0;\r\nfor (i = WRITE_BACK_BUF1;i < WRITE_BACK_BUF1 + 0x40; i += sizeof(u32),col ++) {\r\nif (col == 4) {\r\nsnd_iprintf(buffer,"\n");\r\ncol = 0;\r\n}\r\nif (col == 0) {\r\nsnd_iprintf(buffer, "%04X ",i);\r\n}\r\nsnd_iprintf(buffer,"%08X ",readl(dst + i));\r\n}\r\n#endif\r\nsnd_iprintf(buffer,"\nSPDIFI_IP_OUTPUT_BUFFER1: \n");\r\ncol = 0;\r\nfor (i = SPDIFI_IP_OUTPUT_BUFFER1;i < SPDIFI_IP_OUTPUT_BUFFER1 + 0x80; i += sizeof(u32),col ++) {\r\nif (col == 4) {\r\nsnd_iprintf(buffer,"\n");\r\ncol = 0;\r\n}\r\nif (col == 0) {\r\nsnd_iprintf(buffer, "%04X ",i);\r\n}\r\nsnd_iprintf(buffer,"%08X ",readl(dst + i));\r\n}\r\nsnd_iprintf(buffer,"\n");\r\n}\r\nint cs46xx_dsp_proc_init (struct snd_card *card, struct snd_cs46xx *chip)\r\n{\r\nstruct snd_info_entry *entry;\r\nstruct dsp_spos_instance * ins = chip->dsp_spos_instance;\r\nint i;\r\nins->snd_card = card;\r\nif ((entry = snd_info_create_card_entry(card, "dsp", card->proc_root)) != NULL) {\r\nentry->content = SNDRV_INFO_CONTENT_TEXT;\r\nentry->mode = S_IFDIR | S_IRUGO | S_IXUGO;\r\nif (snd_info_register(entry) < 0) {\r\nsnd_info_free_entry(entry);\r\nentry = NULL;\r\n}\r\n}\r\nins->proc_dsp_dir = entry;\r\nif (!ins->proc_dsp_dir)\r\nreturn -ENOMEM;\r\nif ((entry = snd_info_create_card_entry(card, "spos_symbols", ins->proc_dsp_dir)) != NULL) {\r\nentry->content = SNDRV_INFO_CONTENT_TEXT;\r\nentry->private_data = chip;\r\nentry->mode = S_IFREG | S_IRUGO | S_IWUSR;\r\nentry->c.text.read = cs46xx_dsp_proc_symbol_table_read;\r\nif (snd_info_register(entry) < 0) {\r\nsnd_info_free_entry(entry);\r\nentry = NULL;\r\n}\r\n}\r\nins->proc_sym_info_entry = entry;\r\nif ((entry = snd_info_create_card_entry(card, "spos_modules", ins->proc_dsp_dir)) != NULL) {\r\nentry->content = SNDRV_INFO_CONTENT_TEXT;\r\nentry->private_data = chip;\r\nentry->mode = S_IFREG | S_IRUGO | S_IWUSR;\r\nentry->c.text.read = cs46xx_dsp_proc_modules_read;\r\nif (snd_info_register(entry) < 0) {\r\nsnd_info_free_entry(entry);\r\nentry = NULL;\r\n}\r\n}\r\nins->proc_modules_info_entry = entry;\r\nif ((entry = snd_info_create_card_entry(card, "parameter", ins->proc_dsp_dir)) != NULL) {\r\nentry->content = SNDRV_INFO_CONTENT_TEXT;\r\nentry->private_data = chip;\r\nentry->mode = S_IFREG | S_IRUGO | S_IWUSR;\r\nentry->c.text.read = cs46xx_dsp_proc_parameter_dump_read;\r\nif (snd_info_register(entry) < 0) {\r\nsnd_info_free_entry(entry);\r\nentry = NULL;\r\n}\r\n}\r\nins->proc_parameter_dump_info_entry = entry;\r\nif ((entry = snd_info_create_card_entry(card, "sample", ins->proc_dsp_dir)) != NULL) {\r\nentry->content = SNDRV_INFO_CONTENT_TEXT;\r\nentry->private_data = chip;\r\nentry->mode = S_IFREG | S_IRUGO | S_IWUSR;\r\nentry->c.text.read = cs46xx_dsp_proc_sample_dump_read;\r\nif (snd_info_register(entry) < 0) {\r\nsnd_info_free_entry(entry);\r\nentry = NULL;\r\n}\r\n}\r\nins->proc_sample_dump_info_entry = entry;\r\nif ((entry = snd_info_create_card_entry(card, "task_tree", ins->proc_dsp_dir)) != NULL) {\r\nentry->content = SNDRV_INFO_CONTENT_TEXT;\r\nentry->private_data = chip;\r\nentry->mode = S_IFREG | S_IRUGO | S_IWUSR;\r\nentry->c.text.read = cs46xx_dsp_proc_task_tree_read;\r\nif (snd_info_register(entry) < 0) {\r\nsnd_info_free_entry(entry);\r\nentry = NULL;\r\n}\r\n}\r\nins->proc_task_info_entry = entry;\r\nif ((entry = snd_info_create_card_entry(card, "scb_info", ins->proc_dsp_dir)) != NULL) {\r\nentry->content = SNDRV_INFO_CONTENT_TEXT;\r\nentry->private_data = chip;\r\nentry->mode = S_IFREG | S_IRUGO | S_IWUSR;\r\nentry->c.text.read = cs46xx_dsp_proc_scb_read;\r\nif (snd_info_register(entry) < 0) {\r\nsnd_info_free_entry(entry);\r\nentry = NULL;\r\n}\r\n}\r\nins->proc_scb_info_entry = entry;\r\nmutex_lock(&chip->spos_mutex);\r\nfor (i = 0; i < ins->nscb; ++i) {\r\nif (ins->scbs[i].deleted) continue;\r\ncs46xx_dsp_proc_register_scb_desc (chip, (ins->scbs + i));\r\n}\r\nmutex_unlock(&chip->spos_mutex);\r\nreturn 0;\r\n}\r\nint cs46xx_dsp_proc_done (struct snd_cs46xx *chip)\r\n{\r\nstruct dsp_spos_instance * ins = chip->dsp_spos_instance;\r\nint i;\r\nsnd_info_free_entry(ins->proc_sym_info_entry);\r\nins->proc_sym_info_entry = NULL;\r\nsnd_info_free_entry(ins->proc_modules_info_entry);\r\nins->proc_modules_info_entry = NULL;\r\nsnd_info_free_entry(ins->proc_parameter_dump_info_entry);\r\nins->proc_parameter_dump_info_entry = NULL;\r\nsnd_info_free_entry(ins->proc_sample_dump_info_entry);\r\nins->proc_sample_dump_info_entry = NULL;\r\nsnd_info_free_entry(ins->proc_scb_info_entry);\r\nins->proc_scb_info_entry = NULL;\r\nsnd_info_free_entry(ins->proc_task_info_entry);\r\nins->proc_task_info_entry = NULL;\r\nmutex_lock(&chip->spos_mutex);\r\nfor (i = 0; i < ins->nscb; ++i) {\r\nif (ins->scbs[i].deleted) continue;\r\ncs46xx_dsp_proc_free_scb_desc ( (ins->scbs + i) );\r\n}\r\nmutex_unlock(&chip->spos_mutex);\r\nsnd_info_free_entry(ins->proc_dsp_dir);\r\nins->proc_dsp_dir = NULL;\r\nreturn 0;\r\n}\r\nstatic void _dsp_create_task_tree (struct snd_cs46xx *chip, u32 * task_data,\r\nu32 dest, int size)\r\n{\r\nvoid __iomem *spdst = chip->region.idx[1].remap_addr +\r\nDSP_PARAMETER_BYTE_OFFSET + dest * sizeof(u32);\r\nint i;\r\nfor (i = 0; i < size; ++i) {\r\ndev_dbg(chip->card->dev, "addr %p, val %08x\n",\r\nspdst, task_data[i]);\r\nwritel(task_data[i],spdst);\r\nspdst += sizeof(u32);\r\n}\r\n}\r\nstatic void _dsp_create_scb (struct snd_cs46xx *chip, u32 * scb_data, u32 dest)\r\n{\r\nvoid __iomem *spdst = chip->region.idx[1].remap_addr +\r\nDSP_PARAMETER_BYTE_OFFSET + dest * sizeof(u32);\r\nint i;\r\nfor (i = 0; i < 0x10; ++i) {\r\ndev_dbg(chip->card->dev, "addr %p, val %08x\n",\r\nspdst, scb_data[i]);\r\nwritel(scb_data[i],spdst);\r\nspdst += sizeof(u32);\r\n}\r\n}\r\nstatic int find_free_scb_index (struct dsp_spos_instance * ins)\r\n{\r\nint index = ins->nscb, i;\r\nfor (i = ins->scb_highest_frag_index; i < ins->nscb; ++i) {\r\nif (ins->scbs[i].deleted) {\r\nindex = i;\r\nbreak;\r\n}\r\n}\r\nreturn index;\r\n}\r\nstatic struct dsp_scb_descriptor * _map_scb (struct snd_cs46xx *chip, char * name, u32 dest)\r\n{\r\nstruct dsp_spos_instance * ins = chip->dsp_spos_instance;\r\nstruct dsp_scb_descriptor * desc = NULL;\r\nint index;\r\nif (ins->nscb == DSP_MAX_SCB_DESC - 1) {\r\ndev_err(chip->card->dev,\r\n"dsp_spos: got no place for other SCB\n");\r\nreturn NULL;\r\n}\r\nindex = find_free_scb_index (ins);\r\nmemset(&ins->scbs[index], 0, sizeof(ins->scbs[index]));\r\nstrcpy(ins->scbs[index].scb_name, name);\r\nins->scbs[index].address = dest;\r\nins->scbs[index].index = index;\r\nins->scbs[index].ref_count = 1;\r\ndesc = (ins->scbs + index);\r\nins->scbs[index].scb_symbol = add_symbol (chip, name, dest, SYMBOL_PARAMETER);\r\nif (index > ins->scb_highest_frag_index)\r\nins->scb_highest_frag_index = index;\r\nif (index == ins->nscb)\r\nins->nscb++;\r\nreturn desc;\r\n}\r\nstatic struct dsp_task_descriptor *\r\n_map_task_tree (struct snd_cs46xx *chip, char * name, u32 dest, u32 size)\r\n{\r\nstruct dsp_spos_instance * ins = chip->dsp_spos_instance;\r\nstruct dsp_task_descriptor * desc = NULL;\r\nif (ins->ntask == DSP_MAX_TASK_DESC - 1) {\r\ndev_err(chip->card->dev,\r\n"dsp_spos: got no place for other TASK\n");\r\nreturn NULL;\r\n}\r\nif (name)\r\nstrcpy(ins->tasks[ins->ntask].task_name, name);\r\nelse\r\nstrcpy(ins->tasks[ins->ntask].task_name, "(NULL)");\r\nins->tasks[ins->ntask].address = dest;\r\nins->tasks[ins->ntask].size = size;\r\nins->tasks[ins->ntask].index = ins->ntask;\r\ndesc = (ins->tasks + ins->ntask);\r\nins->ntask++;\r\nif (name)\r\nadd_symbol (chip,name,dest,SYMBOL_PARAMETER);\r\nreturn desc;\r\n}\r\nstruct dsp_scb_descriptor *\r\ncs46xx_dsp_create_scb (struct snd_cs46xx *chip, char * name, u32 * scb_data, u32 dest)\r\n{\r\nstruct dsp_scb_descriptor * desc;\r\n#ifdef CONFIG_PM_SLEEP\r\nscb_data = kmemdup(scb_data, SCB_BYTES, GFP_KERNEL);\r\nif (!scb_data)\r\nreturn NULL;\r\n#endif\r\ndesc = _map_scb (chip,name,dest);\r\nif (desc) {\r\ndesc->data = scb_data;\r\n_dsp_create_scb(chip,scb_data,dest);\r\n} else {\r\ndev_err(chip->card->dev, "dsp_spos: failed to map SCB\n");\r\n#ifdef CONFIG_PM_SLEEP\r\nkfree(scb_data);\r\n#endif\r\n}\r\nreturn desc;\r\n}\r\nstatic struct dsp_task_descriptor *\r\ncs46xx_dsp_create_task_tree (struct snd_cs46xx *chip, char * name, u32 * task_data,\r\nu32 dest, int size)\r\n{\r\nstruct dsp_task_descriptor * desc;\r\ndesc = _map_task_tree (chip,name,dest,size);\r\nif (desc) {\r\ndesc->data = task_data;\r\n_dsp_create_task_tree(chip,task_data,dest,size);\r\n} else {\r\ndev_err(chip->card->dev, "dsp_spos: failed to map TASK\n");\r\n}\r\nreturn desc;\r\n}\r\nint cs46xx_dsp_scb_and_task_init (struct snd_cs46xx *chip)\r\n{\r\nstruct dsp_spos_instance * ins = chip->dsp_spos_instance;\r\nstruct dsp_symbol_entry * fg_task_tree_header_code;\r\nstruct dsp_symbol_entry * task_tree_header_code;\r\nstruct dsp_symbol_entry * task_tree_thread;\r\nstruct dsp_symbol_entry * null_algorithm;\r\nstruct dsp_symbol_entry * magic_snoop_task;\r\nstruct dsp_scb_descriptor * timing_master_scb;\r\nstruct dsp_scb_descriptor * codec_out_scb;\r\nstruct dsp_scb_descriptor * codec_in_scb;\r\nstruct dsp_scb_descriptor * src_task_scb;\r\nstruct dsp_scb_descriptor * master_mix_scb;\r\nstruct dsp_scb_descriptor * rear_mix_scb;\r\nstruct dsp_scb_descriptor * record_mix_scb;\r\nstruct dsp_scb_descriptor * write_back_scb;\r\nstruct dsp_scb_descriptor * vari_decimate_scb;\r\nstruct dsp_scb_descriptor * rear_codec_out_scb;\r\nstruct dsp_scb_descriptor * clfe_codec_out_scb;\r\nstruct dsp_scb_descriptor * magic_snoop_scb;\r\nint fifo_addr, fifo_span, valid_slots;\r\nstatic struct dsp_spos_control_block sposcb = {\r\nHFG_TREE_SCB,HFG_STACK,\r\nSPOSCB_ADDR,BG_TREE_SCB_ADDR,\r\nDSP_SPOS_DC,0,\r\nDSP_SPOS_DC,DSP_SPOS_DC,\r\n0,0,\r\nDSP_SPOS_UU,0,\r\nFG_TASK_HEADER_ADDR,0,\r\n0,0,\r\nDSP_SPOS_UU,DSP_SPOS_DC,\r\n0,\r\n0,HFG_FIRST_EXECUTE_MODE,\r\nDSP_SPOS_UU,DSP_SPOS_UU,\r\nDSP_SPOS_DC_DC,\r\nDSP_SPOS_DC_DC,\r\nDSP_SPOS_DC_DC,\r\nDSP_SPOS_DC_DC\r\n};\r\ncs46xx_dsp_create_task_tree(chip, "sposCB", (u32 *)&sposcb, SPOSCB_ADDR, 0x10);\r\nnull_algorithm = cs46xx_dsp_lookup_symbol(chip, "NULLALGORITHM", SYMBOL_CODE);\r\nif (null_algorithm == NULL) {\r\ndev_err(chip->card->dev,\r\n"dsp_spos: symbol NULLALGORITHM not found\n");\r\nreturn -EIO;\r\n}\r\nfg_task_tree_header_code = cs46xx_dsp_lookup_symbol(chip, "FGTASKTREEHEADERCODE", SYMBOL_CODE);\r\nif (fg_task_tree_header_code == NULL) {\r\ndev_err(chip->card->dev,\r\n"dsp_spos: symbol FGTASKTREEHEADERCODE not found\n");\r\nreturn -EIO;\r\n}\r\ntask_tree_header_code = cs46xx_dsp_lookup_symbol(chip, "TASKTREEHEADERCODE", SYMBOL_CODE);\r\nif (task_tree_header_code == NULL) {\r\ndev_err(chip->card->dev,\r\n"dsp_spos: symbol TASKTREEHEADERCODE not found\n");\r\nreturn -EIO;\r\n}\r\ntask_tree_thread = cs46xx_dsp_lookup_symbol(chip, "TASKTREETHREAD", SYMBOL_CODE);\r\nif (task_tree_thread == NULL) {\r\ndev_err(chip->card->dev,\r\n"dsp_spos: symbol TASKTREETHREAD not found\n");\r\nreturn -EIO;\r\n}\r\nmagic_snoop_task = cs46xx_dsp_lookup_symbol(chip, "MAGICSNOOPTASK", SYMBOL_CODE);\r\nif (magic_snoop_task == NULL) {\r\ndev_err(chip->card->dev,\r\n"dsp_spos: symbol MAGICSNOOPTASK not found\n");\r\nreturn -EIO;\r\n}\r\n{\r\nstatic struct dsp_generic_scb null_scb = {\r\n{ 0, 0, 0, 0 },\r\n{ 0, 0, 0, 0, 0 },\r\nNULL_SCB_ADDR, NULL_SCB_ADDR,\r\n0, 0, 0, 0, 0,\r\n{\r\n0,0,\r\n0,0,\r\n}\r\n};\r\nnull_scb.entry_point = null_algorithm->address;\r\nins->the_null_scb = cs46xx_dsp_create_scb(chip, "nullSCB", (u32 *)&null_scb, NULL_SCB_ADDR);\r\nins->the_null_scb->task_entry = null_algorithm;\r\nins->the_null_scb->sub_list_ptr = ins->the_null_scb;\r\nins->the_null_scb->next_scb_ptr = ins->the_null_scb;\r\nins->the_null_scb->parent_scb_ptr = NULL;\r\ncs46xx_dsp_proc_register_scb_desc (chip,ins->the_null_scb);\r\n}\r\n{\r\nstatic struct dsp_task_tree_control_block fg_task_tree_hdr = {\r\n{ FG_TASK_HEADER_ADDR | (DSP_SPOS_DC << 0x10),\r\nDSP_SPOS_DC_DC,\r\nDSP_SPOS_DC_DC,\r\n0x0000,DSP_SPOS_DC,\r\nDSP_SPOS_DC, DSP_SPOS_DC,\r\nDSP_SPOS_DC_DC,\r\nDSP_SPOS_DC_DC,\r\nDSP_SPOS_DC_DC,\r\nDSP_SPOS_DC,DSP_SPOS_DC },\r\n{\r\nBG_TREE_SCB_ADDR,TIMINGMASTER_SCB_ADDR,\r\n0,\r\nFG_TASK_HEADER_ADDR + TCBData,\r\n},\r\n{\r\n4,0,\r\n1,0,\r\n2,SPOSCB_ADDR + HFGFlags,\r\n0,0,\r\nFG_TASK_HEADER_ADDR + TCBContextBlk,FG_STACK\r\n},\r\n{\r\nDSP_SPOS_DC,0,\r\nDSP_SPOS_DC,DSP_SPOS_DC,\r\nDSP_SPOS_DC,DSP_SPOS_DC,\r\nDSP_SPOS_DC,DSP_SPOS_DC,\r\nDSP_SPOS_DC,DSP_SPOS_DC,\r\nDSP_SPOS_DCDC,\r\nDSP_SPOS_UU,1,\r\nDSP_SPOS_DCDC,\r\nDSP_SPOS_DCDC,\r\nDSP_SPOS_DCDC,\r\nDSP_SPOS_DCDC,\r\nDSP_SPOS_DCDC,\r\nDSP_SPOS_DCDC,\r\nDSP_SPOS_DCDC,\r\nDSP_SPOS_DCDC,\r\nDSP_SPOS_DCDC,\r\nDSP_SPOS_DCDC,\r\nDSP_SPOS_DCDC,\r\nDSP_SPOS_DCDC,\r\nDSP_SPOS_DCDC,\r\nDSP_SPOS_DCDC,\r\nDSP_SPOS_DCDC,\r\nDSP_SPOS_DCDC,\r\nDSP_SPOS_DCDC,\r\nDSP_SPOS_DCDC,\r\nDSP_SPOS_DCDC,\r\nDSP_SPOS_DCDC,\r\nDSP_SPOS_DCDC,\r\nDSP_SPOS_DCDC,\r\nDSP_SPOS_DCDC,\r\nDSP_SPOS_DCDC,\r\nDSP_SPOS_DCDC,\r\nDSP_SPOS_DCDC,\r\nDSP_SPOS_DCDC,\r\nDSP_SPOS_DCDC\r\n},\r\n{\r\nFG_INTERVAL_TIMER_PERIOD,DSP_SPOS_UU,\r\n0,0\r\n}\r\n};\r\nfg_task_tree_hdr.links.entry_point = fg_task_tree_header_code->address;\r\nfg_task_tree_hdr.context_blk.stack0 = task_tree_thread->address;\r\ncs46xx_dsp_create_task_tree(chip,"FGtaskTreeHdr",(u32 *)&fg_task_tree_hdr,FG_TASK_HEADER_ADDR,0x35);\r\n}\r\n{\r\nstatic struct dsp_task_tree_control_block bg_task_tree_hdr = {\r\n{ DSP_SPOS_DC_DC,\r\nDSP_SPOS_DC_DC,\r\nDSP_SPOS_DC_DC,\r\nDSP_SPOS_DC, DSP_SPOS_DC,\r\nDSP_SPOS_DC, DSP_SPOS_DC,\r\nDSP_SPOS_DC_DC,\r\nDSP_SPOS_DC_DC,\r\nDSP_SPOS_DC_DC,\r\nDSP_SPOS_DC,DSP_SPOS_DC },\r\n{\r\nNULL_SCB_ADDR,NULL_SCB_ADDR,\r\n0,\r\nBG_TREE_SCB_ADDR + TCBData,\r\n},\r\n{\r\n9999,0,\r\n0,1,\r\n0,SPOSCB_ADDR + HFGFlags,\r\n0,0,\r\nBG_TREE_SCB_ADDR + TCBContextBlk,BG_STACK\r\n},\r\n{\r\nDSP_SPOS_DC,0,\r\nDSP_SPOS_DC,DSP_SPOS_DC,\r\nDSP_SPOS_DC,DSP_SPOS_DC,\r\nDSP_SPOS_DC,DSP_SPOS_DC,\r\nDSP_SPOS_DC,DSP_SPOS_DC,\r\nDSP_SPOS_DCDC,\r\nDSP_SPOS_UU,1,\r\nDSP_SPOS_DCDC,\r\nDSP_SPOS_DCDC,\r\nDSP_SPOS_DCDC,\r\nDSP_SPOS_DCDC,\r\nDSP_SPOS_DCDC,\r\nDSP_SPOS_DCDC,\r\nDSP_SPOS_DCDC,\r\nDSP_SPOS_DCDC,\r\nDSP_SPOS_DCDC,\r\nDSP_SPOS_DCDC,\r\nDSP_SPOS_DCDC,\r\nDSP_SPOS_DCDC,\r\nDSP_SPOS_DCDC,\r\nDSP_SPOS_DCDC,\r\nDSP_SPOS_DCDC,\r\nDSP_SPOS_DCDC,\r\nDSP_SPOS_DCDC,\r\nDSP_SPOS_DCDC,\r\nDSP_SPOS_DCDC,\r\nDSP_SPOS_DCDC,\r\nDSP_SPOS_DCDC,\r\nDSP_SPOS_DCDC,\r\nDSP_SPOS_DCDC,\r\nDSP_SPOS_DCDC,\r\nDSP_SPOS_DCDC,\r\nDSP_SPOS_DCDC,\r\nDSP_SPOS_DCDC,\r\nDSP_SPOS_DCDC\r\n},\r\n{\r\nBG_INTERVAL_TIMER_PERIOD,DSP_SPOS_UU,\r\n0,0\r\n}\r\n};\r\nbg_task_tree_hdr.links.entry_point = task_tree_header_code->address;\r\nbg_task_tree_hdr.context_blk.stack0 = task_tree_thread->address;\r\ncs46xx_dsp_create_task_tree(chip,"BGtaskTreeHdr",(u32 *)&bg_task_tree_hdr,BG_TREE_SCB_ADDR,0x35);\r\n}\r\ntiming_master_scb = cs46xx_dsp_create_timing_master_scb(chip);\r\ncodec_out_scb = cs46xx_dsp_create_codec_out_scb(chip,"CodecOutSCB_I",0x0010,0x0000,\r\nMASTERMIX_SCB_ADDR,\r\nCODECOUT_SCB_ADDR,timing_master_scb,\r\nSCB_ON_PARENT_SUBLIST_SCB);\r\nif (!codec_out_scb) goto _fail_end;\r\nmaster_mix_scb = cs46xx_dsp_create_mix_only_scb(chip,"MasterMixSCB",\r\nMIX_SAMPLE_BUF1,MASTERMIX_SCB_ADDR,\r\ncodec_out_scb,\r\nSCB_ON_PARENT_SUBLIST_SCB);\r\nins->master_mix_scb = master_mix_scb;\r\nif (!master_mix_scb) goto _fail_end;\r\ncodec_in_scb = cs46xx_dsp_create_codec_in_scb(chip,"CodecInSCB",0x0010,0x00A0,\r\nCODEC_INPUT_BUF1,\r\nCODECIN_SCB_ADDR,codec_out_scb,\r\nSCB_ON_PARENT_NEXT_SCB);\r\nif (!codec_in_scb) goto _fail_end;\r\nins->codec_in_scb = codec_in_scb;\r\nwrite_back_scb = cs46xx_dsp_create_mix_to_ostream_scb(chip,"WriteBackSCB",\r\nWRITE_BACK_BUF1,WRITE_BACK_SPB,\r\nWRITEBACK_SCB_ADDR,\r\ntiming_master_scb,\r\nSCB_ON_PARENT_NEXT_SCB);\r\nif (!write_back_scb) goto _fail_end;\r\n{\r\nstatic struct dsp_mix2_ostream_spb mix2_ostream_spb = {\r\n0x00020000,\r\n0x0000ffff\r\n};\r\nif (!cs46xx_dsp_create_task_tree(chip, NULL,\r\n(u32 *)&mix2_ostream_spb,\r\nWRITE_BACK_SPB, 2))\r\ngoto _fail_end;\r\n}\r\nvari_decimate_scb = cs46xx_dsp_create_vari_decimate_scb(chip,"VariDecimateSCB",\r\nVARI_DECIMATE_BUF0,\r\nVARI_DECIMATE_BUF1,\r\nVARIDECIMATE_SCB_ADDR,\r\nwrite_back_scb,\r\nSCB_ON_PARENT_SUBLIST_SCB);\r\nif (!vari_decimate_scb) goto _fail_end;\r\nrecord_mix_scb = cs46xx_dsp_create_mix_only_scb(chip,"RecordMixerSCB",\r\nMIX_SAMPLE_BUF2,\r\nRECORD_MIXER_SCB_ADDR,\r\nvari_decimate_scb,\r\nSCB_ON_PARENT_SUBLIST_SCB);\r\nins->record_mixer_scb = record_mix_scb;\r\nif (!record_mix_scb) goto _fail_end;\r\nvalid_slots = snd_cs46xx_peekBA0(chip, BA0_ACOSV);\r\nif (snd_BUG_ON(chip->nr_ac97_codecs != 1 && chip->nr_ac97_codecs != 2))\r\ngoto _fail_end;\r\nif (chip->nr_ac97_codecs == 1) {\r\nfifo_addr = 0x20;\r\nfifo_span = 0x60;\r\nvalid_slots |= ACOSV_SLV5 | ACOSV_SLV11;\r\n} else {\r\nfifo_addr = 0x40;\r\nfifo_span = 0x10;\r\nvalid_slots |= ACOSV_SLV7 | ACOSV_SLV8;\r\n}\r\nrear_codec_out_scb = cs46xx_dsp_create_codec_out_scb(chip,"CodecOutSCB_Rear",fifo_span,fifo_addr,\r\nREAR_MIXER_SCB_ADDR,\r\nREAR_CODECOUT_SCB_ADDR,codec_in_scb,\r\nSCB_ON_PARENT_NEXT_SCB);\r\nif (!rear_codec_out_scb) goto _fail_end;\r\nrear_mix_scb = cs46xx_dsp_create_mix_only_scb(chip,"RearMixerSCB",\r\nMIX_SAMPLE_BUF3,\r\nREAR_MIXER_SCB_ADDR,\r\nrear_codec_out_scb,\r\nSCB_ON_PARENT_SUBLIST_SCB);\r\nins->rear_mix_scb = rear_mix_scb;\r\nif (!rear_mix_scb) goto _fail_end;\r\nif (chip->nr_ac97_codecs == 2) {\r\nclfe_codec_out_scb = cs46xx_dsp_create_codec_out_scb(chip,"CodecOutSCB_CLFE",0x0030,0x0030,\r\nCLFE_MIXER_SCB_ADDR,\r\nCLFE_CODEC_SCB_ADDR,\r\nrear_codec_out_scb,\r\nSCB_ON_PARENT_NEXT_SCB);\r\nif (!clfe_codec_out_scb) goto _fail_end;\r\nins->center_lfe_mix_scb = cs46xx_dsp_create_mix_only_scb(chip,"CLFEMixerSCB",\r\nMIX_SAMPLE_BUF4,\r\nCLFE_MIXER_SCB_ADDR,\r\nclfe_codec_out_scb,\r\nSCB_ON_PARENT_SUBLIST_SCB);\r\nif (!ins->center_lfe_mix_scb) goto _fail_end;\r\nvalid_slots |= ACOSV_SLV6 | ACOSV_SLV9;\r\n} else {\r\nclfe_codec_out_scb = rear_codec_out_scb;\r\nins->center_lfe_mix_scb = rear_mix_scb;\r\n}\r\nsnd_cs46xx_pokeBA0(chip, BA0_ACOSV, valid_slots);\r\nmagic_snoop_scb = cs46xx_dsp_create_magic_snoop_scb (chip,"MagicSnoopSCB_I",OUTPUTSNOOP_SCB_ADDR,\r\nOUTPUT_SNOOP_BUFFER,\r\ncodec_out_scb,\r\nclfe_codec_out_scb,\r\nSCB_ON_PARENT_NEXT_SCB);\r\nif (!magic_snoop_scb) goto _fail_end;\r\nins->ref_snoop_scb = magic_snoop_scb;\r\nif (!cs46xx_dsp_create_spio_write_scb(chip,"SPIOWriteSCB",SPIOWRITE_SCB_ADDR,\r\nmagic_snoop_scb,\r\nSCB_ON_PARENT_NEXT_SCB))\r\ngoto _fail_end;\r\nsrc_task_scb = cs46xx_dsp_create_src_task_scb(chip,"SrcTaskSCB_SPDIFI",\r\nins->spdif_in_sample_rate,\r\nSRC_OUTPUT_BUF1,\r\nSRC_DELAY_BUF1,SRCTASK_SCB_ADDR,\r\nmaster_mix_scb,\r\nSCB_ON_PARENT_SUBLIST_SCB,1);\r\nif (!src_task_scb) goto _fail_end;\r\ncs46xx_src_unlink(chip,src_task_scb);\r\nins->spdif_in_src = src_task_scb;\r\ncs46xx_dsp_async_init(chip,timing_master_scb);\r\nreturn 0;\r\n_fail_end:\r\ndev_err(chip->card->dev, "dsp_spos: failed to setup SCB's in DSP\n");\r\nreturn -EINVAL;\r\n}\r\nstatic int cs46xx_dsp_async_init (struct snd_cs46xx *chip,\r\nstruct dsp_scb_descriptor * fg_entry)\r\n{\r\nstruct dsp_spos_instance * ins = chip->dsp_spos_instance;\r\nstruct dsp_symbol_entry * s16_async_codec_input_task;\r\nstruct dsp_symbol_entry * spdifo_task;\r\nstruct dsp_symbol_entry * spdifi_task;\r\nstruct dsp_scb_descriptor * spdifi_scb_desc, * spdifo_scb_desc, * async_codec_scb_desc;\r\ns16_async_codec_input_task = cs46xx_dsp_lookup_symbol(chip, "S16_ASYNCCODECINPUTTASK", SYMBOL_CODE);\r\nif (s16_async_codec_input_task == NULL) {\r\ndev_err(chip->card->dev,\r\n"dsp_spos: symbol S16_ASYNCCODECINPUTTASK not found\n");\r\nreturn -EIO;\r\n}\r\nspdifo_task = cs46xx_dsp_lookup_symbol(chip, "SPDIFOTASK", SYMBOL_CODE);\r\nif (spdifo_task == NULL) {\r\ndev_err(chip->card->dev,\r\n"dsp_spos: symbol SPDIFOTASK not found\n");\r\nreturn -EIO;\r\n}\r\nspdifi_task = cs46xx_dsp_lookup_symbol(chip, "SPDIFITASK", SYMBOL_CODE);\r\nif (spdifi_task == NULL) {\r\ndev_err(chip->card->dev,\r\n"dsp_spos: symbol SPDIFITASK not found\n");\r\nreturn -EIO;\r\n}\r\n{\r\nstruct dsp_spdifoscb spdifo_scb = {\r\nDSP_SPOS_UUUU,\r\n{\r\n0xb0,\r\n0,\r\n0,\r\n0,\r\n},\r\nRSCONFIG_SAMPLE_16MONO + RSCONFIG_MODULO_256,\r\n( SPDIFO_IP_OUTPUT_BUFFER1 << 0x10 ) | 0xFFFC,\r\n0,0,\r\n0,\r\nFG_TASK_HEADER_ADDR, NULL_SCB_ADDR,\r\nspdifo_task->address,\r\nSPDIFO_SCB_INST + SPDIFOFIFOPointer,\r\n{\r\n0x0040,\r\n0x20ff,\r\n},\r\n0x804c,0,\r\n0x0108,0x0001,\r\nDSP_SPOS_UUUU\r\n};\r\nstruct dsp_spdifiscb spdifi_scb = {\r\nDSP_SPOS_UULO,DSP_SPOS_UUHI,\r\n0,\r\n0,\r\n1,4000,\r\nDSP_SPOS_UUUU,\r\n0,DSP_SPOS_UUHI,\r\nDSP_SPOS_UUUU,\r\nDSP_SPOS_UU,DSP_SPOS_DC,\r\nDSP_SPOS_UUUU,\r\nSPDIFO_SCB_INST, NULL_SCB_ADDR,\r\nspdifi_task->address,\r\nSPDIFI_SCB_INST + SPDIFIFIFOPointer,\r\nRSCONFIG_SAMPLE_16MONO + RSCONFIG_MODULO_128,\r\n(SPDIFI_IP_OUTPUT_BUFFER1 << 0x10) | 0xFFFC,\r\n0x8048,0,\r\n0x01f0,0x0001,\r\nDSP_SPOS_UUUU\r\n};\r\nstruct dsp_async_codec_input_scb async_codec_input_scb = {\r\nDSP_SPOS_UUUU,\r\n0,\r\n0,\r\n1,4000,\r\n0x0118,0x0001,\r\nRSCONFIG_SAMPLE_16MONO + RSCONFIG_MODULO_64,\r\n(ASYNC_IP_OUTPUT_BUFFER1 << 0x10) | 0xFFFC,\r\nDSP_SPOS_UU,0x3,\r\nDSP_SPOS_UUUU,\r\nSPDIFI_SCB_INST,NULL_SCB_ADDR,\r\ns16_async_codec_input_task->address,\r\nHFG_TREE_SCB + AsyncCIOFIFOPointer,\r\nRSCONFIG_SAMPLE_16STEREO + RSCONFIG_MODULO_64,\r\n(ASYNC_IP_OUTPUT_BUFFER1 << 0x10),\r\n#ifdef UseASER1Input\r\n0x8042,0,\r\n0x0100,0x0001,\r\n#endif\r\n#ifdef UseASER2Input\r\n0x8044,0,\r\n0x0110,0x0001,\r\n#endif\r\n0,\r\n};\r\nspdifo_scb_desc = cs46xx_dsp_create_scb(chip,"SPDIFOSCB",(u32 *)&spdifo_scb,SPDIFO_SCB_INST);\r\nif (snd_BUG_ON(!spdifo_scb_desc))\r\nreturn -EIO;\r\nspdifi_scb_desc = cs46xx_dsp_create_scb(chip,"SPDIFISCB",(u32 *)&spdifi_scb,SPDIFI_SCB_INST);\r\nif (snd_BUG_ON(!spdifi_scb_desc))\r\nreturn -EIO;\r\nasync_codec_scb_desc = cs46xx_dsp_create_scb(chip,"AsynCodecInputSCB",(u32 *)&async_codec_input_scb, HFG_TREE_SCB);\r\nif (snd_BUG_ON(!async_codec_scb_desc))\r\nreturn -EIO;\r\nasync_codec_scb_desc->parent_scb_ptr = NULL;\r\nasync_codec_scb_desc->next_scb_ptr = spdifi_scb_desc;\r\nasync_codec_scb_desc->sub_list_ptr = ins->the_null_scb;\r\nasync_codec_scb_desc->task_entry = s16_async_codec_input_task;\r\nspdifi_scb_desc->parent_scb_ptr = async_codec_scb_desc;\r\nspdifi_scb_desc->next_scb_ptr = spdifo_scb_desc;\r\nspdifi_scb_desc->sub_list_ptr = ins->the_null_scb;\r\nspdifi_scb_desc->task_entry = spdifi_task;\r\nspdifo_scb_desc->parent_scb_ptr = spdifi_scb_desc;\r\nspdifo_scb_desc->next_scb_ptr = fg_entry;\r\nspdifo_scb_desc->sub_list_ptr = ins->the_null_scb;\r\nspdifo_scb_desc->task_entry = spdifo_task;\r\nfg_entry->parent_scb_ptr = spdifo_scb_desc;\r\ncs46xx_dsp_proc_register_scb_desc (chip,spdifo_scb_desc);\r\ncs46xx_dsp_proc_register_scb_desc (chip,spdifi_scb_desc);\r\ncs46xx_dsp_proc_register_scb_desc (chip,async_codec_scb_desc);\r\nsnd_cs46xx_pokeBA0(chip, BA0_ASER_MASTER, 0x1 );\r\n}\r\nreturn 0;\r\n}\r\nstatic void cs46xx_dsp_disable_spdif_hw (struct snd_cs46xx *chip)\r\n{\r\nstruct dsp_spos_instance * ins = chip->dsp_spos_instance;\r\nsnd_cs46xx_pokeBA0(chip, BA0_ASER_FADDR, 0);\r\ncs46xx_poke_via_dsp (chip,SP_SPDOUT_CONTROL, 0);\r\ncs46xx_poke_via_dsp (chip,SP_SPDOUT_CSUV, 0x0);\r\ncs46xx_poke_via_dsp (chip,SP_SPDIN_FIFOPTR, 0x0);\r\nins->spdif_status_out &= ~DSP_SPDIF_STATUS_HW_ENABLED;\r\n}\r\nint cs46xx_dsp_enable_spdif_hw (struct snd_cs46xx *chip)\r\n{\r\nstruct dsp_spos_instance * ins = chip->dsp_spos_instance;\r\ncs46xx_dsp_disable_spdif_hw (chip);\r\nudelay(50);\r\nsnd_cs46xx_pokeBA0(chip, BA0_ASER_FADDR, ( 0x8000 | ((SP_SPDOUT_FIFO >> 4) << 4) ));\r\ncs46xx_poke_via_dsp (chip,SP_SPDOUT_CONTROL, 0x80000000);\r\ncs46xx_poke_via_dsp (chip,SP_SPDOUT_CSUV, ins->spdif_csuv_default);\r\nins->spdif_status_out |= DSP_SPDIF_STATUS_HW_ENABLED;\r\nreturn 0;\r\n}\r\nint cs46xx_dsp_enable_spdif_in (struct snd_cs46xx *chip)\r\n{\r\nstruct dsp_spos_instance * ins = chip->dsp_spos_instance;\r\nchip->active_ctrl(chip, 1);\r\nchip->amplifier_ctrl(chip, 1);\r\nif (snd_BUG_ON(ins->asynch_rx_scb))\r\nreturn -EINVAL;\r\nif (snd_BUG_ON(!ins->spdif_in_src))\r\nreturn -EINVAL;\r\nmutex_lock(&chip->spos_mutex);\r\nif ( ! (ins->spdif_status_out & DSP_SPDIF_STATUS_INPUT_CTRL_ENABLED) ) {\r\ncs46xx_poke_via_dsp (chip,SP_ASER_COUNTDOWN, 0x80000005);\r\ncs46xx_poke_via_dsp (chip,SP_SPDIN_CONTROL, 0x800003ff);\r\nins->spdif_status_out |= DSP_SPDIF_STATUS_INPUT_CTRL_ENABLED;\r\n}\r\nins->asynch_rx_scb = cs46xx_dsp_create_asynch_fg_rx_scb(chip,"AsynchFGRxSCB",\r\nASYNCRX_SCB_ADDR,\r\nSPDIFI_SCB_INST,\r\nSPDIFI_IP_OUTPUT_BUFFER1,\r\nins->spdif_in_src,\r\nSCB_ON_PARENT_SUBLIST_SCB);\r\nspin_lock_irq(&chip->reg_lock);\r\ncs46xx_src_link(chip,ins->spdif_in_src);\r\ncs46xx_dsp_scb_set_volume (chip,ins->spdif_in_src,0x7fff,0x7fff);\r\nspin_unlock_irq(&chip->reg_lock);\r\nins->spdif_status_in = 1;\r\nmutex_unlock(&chip->spos_mutex);\r\nreturn 0;\r\n}\r\nint cs46xx_dsp_disable_spdif_in (struct snd_cs46xx *chip)\r\n{\r\nstruct dsp_spos_instance * ins = chip->dsp_spos_instance;\r\nif (snd_BUG_ON(!ins->asynch_rx_scb))\r\nreturn -EINVAL;\r\nif (snd_BUG_ON(!ins->spdif_in_src))\r\nreturn -EINVAL;\r\nmutex_lock(&chip->spos_mutex);\r\ncs46xx_dsp_remove_scb (chip,ins->asynch_rx_scb);\r\nins->asynch_rx_scb = NULL;\r\ncs46xx_src_unlink(chip,ins->spdif_in_src);\r\nins->spdif_status_in = 0;\r\nmutex_unlock(&chip->spos_mutex);\r\nchip->active_ctrl(chip, -1);\r\nchip->amplifier_ctrl(chip, -1);\r\nreturn 0;\r\n}\r\nint cs46xx_dsp_enable_pcm_capture (struct snd_cs46xx *chip)\r\n{\r\nstruct dsp_spos_instance * ins = chip->dsp_spos_instance;\r\nif (snd_BUG_ON(ins->pcm_input))\r\nreturn -EINVAL;\r\nif (snd_BUG_ON(!ins->ref_snoop_scb))\r\nreturn -EINVAL;\r\nmutex_lock(&chip->spos_mutex);\r\nins->pcm_input = cs46xx_add_record_source(chip,ins->ref_snoop_scb,PCMSERIALIN_PCM_SCB_ADDR,\r\n"PCMSerialInput_Wave");\r\nmutex_unlock(&chip->spos_mutex);\r\nreturn 0;\r\n}\r\nint cs46xx_dsp_disable_pcm_capture (struct snd_cs46xx *chip)\r\n{\r\nstruct dsp_spos_instance * ins = chip->dsp_spos_instance;\r\nif (snd_BUG_ON(!ins->pcm_input))\r\nreturn -EINVAL;\r\nmutex_lock(&chip->spos_mutex);\r\ncs46xx_dsp_remove_scb (chip,ins->pcm_input);\r\nins->pcm_input = NULL;\r\nmutex_unlock(&chip->spos_mutex);\r\nreturn 0;\r\n}\r\nint cs46xx_dsp_enable_adc_capture (struct snd_cs46xx *chip)\r\n{\r\nstruct dsp_spos_instance * ins = chip->dsp_spos_instance;\r\nif (snd_BUG_ON(ins->adc_input))\r\nreturn -EINVAL;\r\nif (snd_BUG_ON(!ins->codec_in_scb))\r\nreturn -EINVAL;\r\nmutex_lock(&chip->spos_mutex);\r\nins->adc_input = cs46xx_add_record_source(chip,ins->codec_in_scb,PCMSERIALIN_SCB_ADDR,\r\n"PCMSerialInput_ADC");\r\nmutex_unlock(&chip->spos_mutex);\r\nreturn 0;\r\n}\r\nint cs46xx_dsp_disable_adc_capture (struct snd_cs46xx *chip)\r\n{\r\nstruct dsp_spos_instance * ins = chip->dsp_spos_instance;\r\nif (snd_BUG_ON(!ins->adc_input))\r\nreturn -EINVAL;\r\nmutex_lock(&chip->spos_mutex);\r\ncs46xx_dsp_remove_scb (chip,ins->adc_input);\r\nins->adc_input = NULL;\r\nmutex_unlock(&chip->spos_mutex);\r\nreturn 0;\r\n}\r\nint cs46xx_poke_via_dsp (struct snd_cs46xx *chip, u32 address, u32 data)\r\n{\r\nu32 temp;\r\nint i;\r\nif (address < 0x8000 || address >= 0x9000)\r\nreturn -EINVAL;\r\ntemp = ( address << 16 ) | ( address & 0x0000FFFF);\r\nsnd_cs46xx_poke(chip,( SPIOWRITE_SCB_ADDR << 2), temp);\r\nsnd_cs46xx_poke(chip,((SPIOWRITE_SCB_ADDR + 1) << 2), data);\r\nsnd_cs46xx_poke(chip,((SPIOWRITE_SCB_ADDR + 2) << 2), data);\r\nsnd_cs46xx_poke(chip,((SPIOWRITE_SCB_ADDR + 6) << 2), SPIOWRITE_SCB_ADDR << 0x10);\r\nfor (i=0; i<25; i++) {\r\nudelay(125);\r\ntemp = snd_cs46xx_peek(chip,((SPIOWRITE_SCB_ADDR + 6) << 2));\r\nif (temp == 0x00000000)\r\nbreak;\r\n}\r\nif (i == 25) {\r\ndev_err(chip->card->dev,\r\n"dsp_spos: SPIOWriteTask not responding\n");\r\nreturn -EBUSY;\r\n}\r\nreturn 0;\r\n}\r\nint cs46xx_dsp_set_dac_volume (struct snd_cs46xx * chip, u16 left, u16 right)\r\n{\r\nstruct dsp_spos_instance * ins = chip->dsp_spos_instance;\r\nstruct dsp_scb_descriptor * scb;\r\nmutex_lock(&chip->spos_mutex);\r\nscb = ins->master_mix_scb->sub_list_ptr;\r\nwhile (scb != ins->the_null_scb) {\r\ncs46xx_dsp_scb_set_volume (chip,scb,left,right);\r\nscb = scb->next_scb_ptr;\r\n}\r\nscb = ins->rear_mix_scb->sub_list_ptr;\r\nwhile (scb != ins->the_null_scb) {\r\ncs46xx_dsp_scb_set_volume (chip,scb,left,right);\r\nscb = scb->next_scb_ptr;\r\n}\r\nins->dac_volume_left = left;\r\nins->dac_volume_right = right;\r\nmutex_unlock(&chip->spos_mutex);\r\nreturn 0;\r\n}\r\nint cs46xx_dsp_set_iec958_volume (struct snd_cs46xx * chip, u16 left, u16 right)\r\n{\r\nstruct dsp_spos_instance * ins = chip->dsp_spos_instance;\r\nmutex_lock(&chip->spos_mutex);\r\nif (ins->asynch_rx_scb != NULL)\r\ncs46xx_dsp_scb_set_volume (chip,ins->asynch_rx_scb,\r\nleft,right);\r\nins->spdif_input_volume_left = left;\r\nins->spdif_input_volume_right = right;\r\nmutex_unlock(&chip->spos_mutex);\r\nreturn 0;\r\n}\r\nint cs46xx_dsp_resume(struct snd_cs46xx * chip)\r\n{\r\nstruct dsp_spos_instance * ins = chip->dsp_spos_instance;\r\nint i, err;\r\nsnd_cs46xx_clear_BA1(chip, DSP_PARAMETER_BYTE_OFFSET,\r\nDSP_PARAMETER_BYTE_SIZE);\r\nsnd_cs46xx_clear_BA1(chip, DSP_SAMPLE_BYTE_OFFSET,\r\nDSP_SAMPLE_BYTE_SIZE);\r\nsnd_cs46xx_clear_BA1(chip, DSP_CODE_BYTE_OFFSET, DSP_CODE_BYTE_SIZE);\r\nfor (i = 0; i < ins->nmodules; i++) {\r\nstruct dsp_module_desc *module = &ins->modules[i];\r\nstruct dsp_segment_desc *seg;\r\nu32 doffset, dsize;\r\nseg = get_segment_desc(module, SEGTYPE_SP_PARAMETER);\r\nerr = dsp_load_parameter(chip, seg);\r\nif (err < 0)\r\nreturn err;\r\nseg = get_segment_desc(module, SEGTYPE_SP_SAMPLE);\r\nerr = dsp_load_sample(chip, seg);\r\nif (err < 0)\r\nreturn err;\r\nseg = get_segment_desc(module, SEGTYPE_SP_PROGRAM);\r\nif (!seg)\r\ncontinue;\r\ndoffset = seg->offset * 4 + module->load_address * 4\r\n+ DSP_CODE_BYTE_OFFSET;\r\ndsize = seg->size * 4;\r\nerr = snd_cs46xx_download(chip,\r\nins->code.data + module->load_address,\r\ndoffset, dsize);\r\nif (err < 0)\r\nreturn err;\r\n}\r\nfor (i = 0; i < ins->ntask; i++) {\r\nstruct dsp_task_descriptor *t = &ins->tasks[i];\r\n_dsp_create_task_tree(chip, t->data, t->address, t->size);\r\n}\r\nfor (i = 0; i < ins->nscb; i++) {\r\nstruct dsp_scb_descriptor *s = &ins->scbs[i];\r\nif (s->deleted)\r\ncontinue;\r\n_dsp_create_scb(chip, s->data, s->address);\r\n}\r\nfor (i = 0; i < ins->nscb; i++) {\r\nstruct dsp_scb_descriptor *s = &ins->scbs[i];\r\nif (s->deleted)\r\ncontinue;\r\nif (s->updated)\r\ncs46xx_dsp_spos_update_scb(chip, s);\r\nif (s->volume_set)\r\ncs46xx_dsp_scb_set_volume(chip, s,\r\ns->volume[0], s->volume[1]);\r\n}\r\nif (ins->spdif_status_out & DSP_SPDIF_STATUS_HW_ENABLED) {\r\ncs46xx_dsp_enable_spdif_hw(chip);\r\nsnd_cs46xx_poke(chip, (ins->ref_snoop_scb->address + 2) << 2,\r\n(OUTPUT_SNOOP_BUFFER + 0x10) << 0x10);\r\nif (ins->spdif_status_out & DSP_SPDIF_STATUS_PLAYBACK_OPEN)\r\ncs46xx_poke_via_dsp(chip, SP_SPDOUT_CSUV,\r\nins->spdif_csuv_stream);\r\n}\r\nif (chip->dsp_spos_instance->spdif_status_in) {\r\ncs46xx_poke_via_dsp(chip, SP_ASER_COUNTDOWN, 0x80000005);\r\ncs46xx_poke_via_dsp(chip, SP_SPDIN_CONTROL, 0x800003ff);\r\n}\r\nreturn 0;\r\n}
