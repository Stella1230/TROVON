fnic_trace_data_t *fnic_trace_get_buf(void)\r\n{\r\nunsigned long fnic_buf_head;\r\nunsigned long flags;\r\nspin_lock_irqsave(&fnic_trace_lock, flags);\r\nfnic_buf_head =\r\nfnic_trace_entries.page_offset[fnic_trace_entries.wr_idx];\r\nfnic_trace_entries.wr_idx++;\r\nif (fnic_trace_entries.wr_idx >= fnic_max_trace_entries)\r\nfnic_trace_entries.wr_idx = 0;\r\nif (fnic_trace_entries.wr_idx == fnic_trace_entries.rd_idx) {\r\nfnic_trace_entries.rd_idx++;\r\nif (fnic_trace_entries.rd_idx >= fnic_max_trace_entries)\r\nfnic_trace_entries.rd_idx = 0;\r\n}\r\nspin_unlock_irqrestore(&fnic_trace_lock, flags);\r\nreturn (fnic_trace_data_t *)fnic_buf_head;\r\n}\r\nint fnic_get_trace_data(fnic_dbgfs_t *fnic_dbgfs_prt)\r\n{\r\nint rd_idx;\r\nint wr_idx;\r\nint len = 0;\r\nunsigned long flags;\r\nchar str[KSYM_SYMBOL_LEN];\r\nstruct timespec val;\r\nfnic_trace_data_t *tbp;\r\nspin_lock_irqsave(&fnic_trace_lock, flags);\r\nrd_idx = fnic_trace_entries.rd_idx;\r\nwr_idx = fnic_trace_entries.wr_idx;\r\nif (wr_idx < rd_idx) {\r\nwhile (1) {\r\ntbp = (fnic_trace_data_t *)\r\nfnic_trace_entries.page_offset[rd_idx];\r\nif (!tbp) {\r\nspin_unlock_irqrestore(&fnic_trace_lock, flags);\r\nreturn 0;\r\n}\r\nif (sizeof(unsigned long) < 8) {\r\nsprint_symbol(str, tbp->fnaddr.low);\r\njiffies_to_timespec(tbp->timestamp.low, &val);\r\n} else {\r\nsprint_symbol(str, tbp->fnaddr.val);\r\njiffies_to_timespec(tbp->timestamp.val, &val);\r\n}\r\nlen += snprintf(fnic_dbgfs_prt->buffer + len,\r\n(trace_max_pages * PAGE_SIZE * 3) - len,\r\n"%16lu.%16lu %-50s %8x %8x %16llx %16llx "\r\n"%16llx %16llx %16llx\n", val.tv_sec,\r\nval.tv_nsec, str, tbp->host_no, tbp->tag,\r\ntbp->data[0], tbp->data[1], tbp->data[2],\r\ntbp->data[3], tbp->data[4]);\r\nrd_idx++;\r\nif (rd_idx > (fnic_max_trace_entries-1))\r\nrd_idx = 0;\r\nif (rd_idx == wr_idx)\r\nbreak;\r\n}\r\n} else if (wr_idx > rd_idx) {\r\nwhile (1) {\r\ntbp = (fnic_trace_data_t *)\r\nfnic_trace_entries.page_offset[rd_idx];\r\nif (!tbp) {\r\nspin_unlock_irqrestore(&fnic_trace_lock, flags);\r\nreturn 0;\r\n}\r\nif (sizeof(unsigned long) < 8) {\r\nsprint_symbol(str, tbp->fnaddr.low);\r\njiffies_to_timespec(tbp->timestamp.low, &val);\r\n} else {\r\nsprint_symbol(str, tbp->fnaddr.val);\r\njiffies_to_timespec(tbp->timestamp.val, &val);\r\n}\r\nlen += snprintf(fnic_dbgfs_prt->buffer + len,\r\n(trace_max_pages * PAGE_SIZE * 3) - len,\r\n"%16lu.%16lu %-50s %8x %8x %16llx %16llx "\r\n"%16llx %16llx %16llx\n", val.tv_sec,\r\nval.tv_nsec, str, tbp->host_no, tbp->tag,\r\ntbp->data[0], tbp->data[1], tbp->data[2],\r\ntbp->data[3], tbp->data[4]);\r\nrd_idx++;\r\nif (rd_idx == wr_idx)\r\nbreak;\r\n}\r\n}\r\nspin_unlock_irqrestore(&fnic_trace_lock, flags);\r\nreturn len;\r\n}\r\nint fnic_get_stats_data(struct stats_debug_info *debug,\r\nstruct fnic_stats *stats)\r\n{\r\nint len = 0;\r\nint buf_size = debug->buf_size;\r\nstruct timespec val1, val2;\r\nlen = snprintf(debug->debug_buffer + len, buf_size - len,\r\n"------------------------------------------\n"\r\n"\t\tIO Statistics\n"\r\n"------------------------------------------\n");\r\nlen += snprintf(debug->debug_buffer + len, buf_size - len,\r\n"Number of Active IOs: %lld\nMaximum Active IOs: %lld\n"\r\n"Number of IOs: %lld\nNumber of IO Completions: %lld\n"\r\n"Number of IO Failures: %lld\nNumber of IO NOT Found: %lld\n"\r\n"Number of Memory alloc Failures: %lld\n"\r\n"Number of IOREQ Null: %lld\n"\r\n"Number of SCSI cmd pointer Null: %lld\n",\r\n(u64)atomic64_read(&stats->io_stats.active_ios),\r\n(u64)atomic64_read(&stats->io_stats.max_active_ios),\r\n(u64)atomic64_read(&stats->io_stats.num_ios),\r\n(u64)atomic64_read(&stats->io_stats.io_completions),\r\n(u64)atomic64_read(&stats->io_stats.io_failures),\r\n(u64)atomic64_read(&stats->io_stats.io_not_found),\r\n(u64)atomic64_read(&stats->io_stats.alloc_failures),\r\n(u64)atomic64_read(&stats->io_stats.ioreq_null),\r\n(u64)atomic64_read(&stats->io_stats.sc_null));\r\nlen += snprintf(debug->debug_buffer + len, buf_size - len,\r\n"\n------------------------------------------\n"\r\n"\t\tAbort Statistics\n"\r\n"------------------------------------------\n");\r\nlen += snprintf(debug->debug_buffer + len, buf_size - len,\r\n"Number of Aborts: %lld\n"\r\n"Number of Abort Failures: %lld\n"\r\n"Number of Abort Driver Timeouts: %lld\n"\r\n"Number of Abort FW Timeouts: %lld\n"\r\n"Number of Abort IO NOT Found: %lld\n",\r\n(u64)atomic64_read(&stats->abts_stats.aborts),\r\n(u64)atomic64_read(&stats->abts_stats.abort_failures),\r\n(u64)atomic64_read(&stats->abts_stats.abort_drv_timeouts),\r\n(u64)atomic64_read(&stats->abts_stats.abort_fw_timeouts),\r\n(u64)atomic64_read(&stats->abts_stats.abort_io_not_found));\r\nlen += snprintf(debug->debug_buffer + len, buf_size - len,\r\n"\n------------------------------------------\n"\r\n"\t\tTerminate Statistics\n"\r\n"------------------------------------------\n");\r\nlen += snprintf(debug->debug_buffer + len, buf_size - len,\r\n"Number of Terminates: %lld\n"\r\n"Maximum Terminates: %lld\n"\r\n"Number of Terminate Driver Timeouts: %lld\n"\r\n"Number of Terminate FW Timeouts: %lld\n"\r\n"Number of Terminate IO NOT Found: %lld\n"\r\n"Number of Terminate Failures: %lld\n",\r\n(u64)atomic64_read(&stats->term_stats.terminates),\r\n(u64)atomic64_read(&stats->term_stats.max_terminates),\r\n(u64)atomic64_read(&stats->term_stats.terminate_drv_timeouts),\r\n(u64)atomic64_read(&stats->term_stats.terminate_fw_timeouts),\r\n(u64)atomic64_read(&stats->term_stats.terminate_io_not_found),\r\n(u64)atomic64_read(&stats->term_stats.terminate_failures));\r\nlen += snprintf(debug->debug_buffer + len, buf_size - len,\r\n"\n------------------------------------------\n"\r\n"\t\tReset Statistics\n"\r\n"------------------------------------------\n");\r\nlen += snprintf(debug->debug_buffer + len, buf_size - len,\r\n"Number of Device Resets: %lld\n"\r\n"Number of Device Reset Failures: %lld\n"\r\n"Number of Device Reset Aborts: %lld\n"\r\n"Number of Device Reset Timeouts: %lld\n"\r\n"Number of Device Reset Terminates: %lld\n"\r\n"Number of FW Resets: %lld\n"\r\n"Number of FW Reset Completions: %lld\n"\r\n"Number of FW Reset Failures: %lld\n"\r\n"Number of Fnic Reset: %lld\n"\r\n"Number of Fnic Reset Completions: %lld\n"\r\n"Number of Fnic Reset Failures: %lld\n",\r\n(u64)atomic64_read(&stats->reset_stats.device_resets),\r\n(u64)atomic64_read(&stats->reset_stats.device_reset_failures),\r\n(u64)atomic64_read(&stats->reset_stats.device_reset_aborts),\r\n(u64)atomic64_read(&stats->reset_stats.device_reset_timeouts),\r\n(u64)atomic64_read(\r\n&stats->reset_stats.device_reset_terminates),\r\n(u64)atomic64_read(&stats->reset_stats.fw_resets),\r\n(u64)atomic64_read(&stats->reset_stats.fw_reset_completions),\r\n(u64)atomic64_read(&stats->reset_stats.fw_reset_failures),\r\n(u64)atomic64_read(&stats->reset_stats.fnic_resets),\r\n(u64)atomic64_read(\r\n&stats->reset_stats.fnic_reset_completions),\r\n(u64)atomic64_read(&stats->reset_stats.fnic_reset_failures));\r\nlen += snprintf(debug->debug_buffer + len, buf_size - len,\r\n"\n------------------------------------------\n"\r\n"\t\tFirmware Statistics\n"\r\n"------------------------------------------\n");\r\nlen += snprintf(debug->debug_buffer + len, buf_size - len,\r\n"Number of Active FW Requests %lld\n"\r\n"Maximum FW Requests: %lld\n"\r\n"Number of FW out of resources: %lld\n"\r\n"Number of FW IO errors: %lld\n",\r\n(u64)atomic64_read(&stats->fw_stats.active_fw_reqs),\r\n(u64)atomic64_read(&stats->fw_stats.max_fw_reqs),\r\n(u64)atomic64_read(&stats->fw_stats.fw_out_of_resources),\r\n(u64)atomic64_read(&stats->fw_stats.io_fw_errs));\r\nlen += snprintf(debug->debug_buffer + len, buf_size - len,\r\n"\n------------------------------------------\n"\r\n"\t\tVlan Discovery Statistics\n"\r\n"------------------------------------------\n");\r\nlen += snprintf(debug->debug_buffer + len, buf_size - len,\r\n"Number of Vlan Discovery Requests Sent %lld\n"\r\n"Vlan Response Received with no FCF VLAN ID: %lld\n"\r\n"No solicitations recvd after vlan set, expiry count: %lld\n"\r\n"Flogi rejects count: %lld\n",\r\n(u64)atomic64_read(&stats->vlan_stats.vlan_disc_reqs),\r\n(u64)atomic64_read(&stats->vlan_stats.resp_withno_vlanID),\r\n(u64)atomic64_read(&stats->vlan_stats.sol_expiry_count),\r\n(u64)atomic64_read(&stats->vlan_stats.flogi_rejects));\r\nlen += snprintf(debug->debug_buffer + len, buf_size - len,\r\n"\n------------------------------------------\n"\r\n"\t\tOther Important Statistics\n"\r\n"------------------------------------------\n");\r\njiffies_to_timespec(stats->misc_stats.last_isr_time, &val1);\r\njiffies_to_timespec(stats->misc_stats.last_ack_time, &val2);\r\nlen += snprintf(debug->debug_buffer + len, buf_size - len,\r\n"Last ISR time: %llu (%8lu.%8lu)\n"\r\n"Last ACK time: %llu (%8lu.%8lu)\n"\r\n"Number of ISRs: %lld\n"\r\n"Maximum CQ Entries: %lld\n"\r\n"Number of ACK index out of range: %lld\n"\r\n"Number of data count mismatch: %lld\n"\r\n"Number of FCPIO Timeouts: %lld\n"\r\n"Number of FCPIO Aborted: %lld\n"\r\n"Number of SGL Invalid: %lld\n"\r\n"Number of Copy WQ Alloc Failures for ABTs: %lld\n"\r\n"Number of Copy WQ Alloc Failures for Device Reset: %lld\n"\r\n"Number of Copy WQ Alloc Failures for IOs: %lld\n"\r\n"Number of no icmnd itmf Completions: %lld\n"\r\n"Number of QUEUE Fulls: %lld\n"\r\n"Number of rport not ready: %lld\n"\r\n"Number of receive frame errors: %lld\n",\r\n(u64)stats->misc_stats.last_isr_time,\r\nval1.tv_sec, val1.tv_nsec,\r\n(u64)stats->misc_stats.last_ack_time,\r\nval2.tv_sec, val2.tv_nsec,\r\n(u64)atomic64_read(&stats->misc_stats.isr_count),\r\n(u64)atomic64_read(&stats->misc_stats.max_cq_entries),\r\n(u64)atomic64_read(&stats->misc_stats.ack_index_out_of_range),\r\n(u64)atomic64_read(&stats->misc_stats.data_count_mismatch),\r\n(u64)atomic64_read(&stats->misc_stats.fcpio_timeout),\r\n(u64)atomic64_read(&stats->misc_stats.fcpio_aborted),\r\n(u64)atomic64_read(&stats->misc_stats.sgl_invalid),\r\n(u64)atomic64_read(\r\n&stats->misc_stats.abts_cpwq_alloc_failures),\r\n(u64)atomic64_read(\r\n&stats->misc_stats.devrst_cpwq_alloc_failures),\r\n(u64)atomic64_read(&stats->misc_stats.io_cpwq_alloc_failures),\r\n(u64)atomic64_read(&stats->misc_stats.no_icmnd_itmf_cmpls),\r\n(u64)atomic64_read(&stats->misc_stats.queue_fulls),\r\n(u64)atomic64_read(&stats->misc_stats.rport_not_ready),\r\n(u64)atomic64_read(&stats->misc_stats.frame_errors));\r\nreturn len;\r\n}\r\nint fnic_trace_buf_init(void)\r\n{\r\nunsigned long fnic_buf_head;\r\nint i;\r\nint err = 0;\r\ntrace_max_pages = fnic_trace_max_pages;\r\nfnic_max_trace_entries = (trace_max_pages * PAGE_SIZE)/\r\nFNIC_ENTRY_SIZE_BYTES;\r\nfnic_trace_buf_p = (unsigned long)vmalloc((trace_max_pages * PAGE_SIZE));\r\nif (!fnic_trace_buf_p) {\r\nprintk(KERN_ERR PFX "Failed to allocate memory "\r\n"for fnic_trace_buf_p\n");\r\nerr = -ENOMEM;\r\ngoto err_fnic_trace_buf_init;\r\n}\r\nmemset((void *)fnic_trace_buf_p, 0, (trace_max_pages * PAGE_SIZE));\r\nfnic_trace_entries.page_offset = vmalloc(fnic_max_trace_entries *\r\nsizeof(unsigned long));\r\nif (!fnic_trace_entries.page_offset) {\r\nprintk(KERN_ERR PFX "Failed to allocate memory for"\r\n" page_offset\n");\r\nif (fnic_trace_buf_p) {\r\nvfree((void *)fnic_trace_buf_p);\r\nfnic_trace_buf_p = 0;\r\n}\r\nerr = -ENOMEM;\r\ngoto err_fnic_trace_buf_init;\r\n}\r\nmemset((void *)fnic_trace_entries.page_offset, 0,\r\n(fnic_max_trace_entries * sizeof(unsigned long)));\r\nfnic_trace_entries.wr_idx = fnic_trace_entries.rd_idx = 0;\r\nfnic_buf_head = fnic_trace_buf_p;\r\nfor (i = 0; i < fnic_max_trace_entries; i++) {\r\nfnic_trace_entries.page_offset[i] = fnic_buf_head;\r\nfnic_buf_head += FNIC_ENTRY_SIZE_BYTES;\r\n}\r\nerr = fnic_trace_debugfs_init();\r\nif (err < 0) {\r\npr_err("fnic: Failed to initialize debugfs for tracing\n");\r\ngoto err_fnic_trace_debugfs_init;\r\n}\r\npr_info("fnic: Successfully Initialized Trace Buffer\n");\r\nreturn err;\r\nerr_fnic_trace_debugfs_init:\r\nfnic_trace_free();\r\nerr_fnic_trace_buf_init:\r\nreturn err;\r\n}\r\nvoid fnic_trace_free(void)\r\n{\r\nfnic_tracing_enabled = 0;\r\nfnic_trace_debugfs_terminate();\r\nif (fnic_trace_entries.page_offset) {\r\nvfree((void *)fnic_trace_entries.page_offset);\r\nfnic_trace_entries.page_offset = NULL;\r\n}\r\nif (fnic_trace_buf_p) {\r\nvfree((void *)fnic_trace_buf_p);\r\nfnic_trace_buf_p = 0;\r\n}\r\nprintk(KERN_INFO PFX "Successfully Freed Trace Buffer\n");\r\n}\r\nint fnic_fc_trace_init(void)\r\n{\r\nunsigned long fc_trace_buf_head;\r\nint err = 0;\r\nint i;\r\nfc_trace_max_entries = (fnic_fc_trace_max_pages * PAGE_SIZE)/\r\nFC_TRC_SIZE_BYTES;\r\nfnic_fc_ctlr_trace_buf_p = (unsigned long)vmalloc(\r\nfnic_fc_trace_max_pages * PAGE_SIZE);\r\nif (!fnic_fc_ctlr_trace_buf_p) {\r\npr_err("fnic: Failed to allocate memory for "\r\n"FC Control Trace Buf\n");\r\nerr = -ENOMEM;\r\ngoto err_fnic_fc_ctlr_trace_buf_init;\r\n}\r\nmemset((void *)fnic_fc_ctlr_trace_buf_p, 0,\r\nfnic_fc_trace_max_pages * PAGE_SIZE);\r\nfc_trace_entries.page_offset = vmalloc(fc_trace_max_entries *\r\nsizeof(unsigned long));\r\nif (!fc_trace_entries.page_offset) {\r\npr_err("fnic:Failed to allocate memory for page_offset\n");\r\nif (fnic_fc_ctlr_trace_buf_p) {\r\npr_err("fnic: Freeing FC Control Trace Buf\n");\r\nvfree((void *)fnic_fc_ctlr_trace_buf_p);\r\nfnic_fc_ctlr_trace_buf_p = 0;\r\n}\r\nerr = -ENOMEM;\r\ngoto err_fnic_fc_ctlr_trace_buf_init;\r\n}\r\nmemset((void *)fc_trace_entries.page_offset, 0,\r\n(fc_trace_max_entries * sizeof(unsigned long)));\r\nfc_trace_entries.rd_idx = fc_trace_entries.wr_idx = 0;\r\nfc_trace_buf_head = fnic_fc_ctlr_trace_buf_p;\r\nfor (i = 0; i < fc_trace_max_entries; i++) {\r\nfc_trace_entries.page_offset[i] = fc_trace_buf_head;\r\nfc_trace_buf_head += FC_TRC_SIZE_BYTES;\r\n}\r\nerr = fnic_fc_trace_debugfs_init();\r\nif (err < 0) {\r\npr_err("fnic: Failed to initialize FC_CTLR tracing.\n");\r\ngoto err_fnic_fc_ctlr_trace_debugfs_init;\r\n}\r\npr_info("fnic: Successfully Initialized FC_CTLR Trace Buffer\n");\r\nreturn err;\r\nerr_fnic_fc_ctlr_trace_debugfs_init:\r\nfnic_fc_trace_free();\r\nerr_fnic_fc_ctlr_trace_buf_init:\r\nreturn err;\r\n}\r\nvoid fnic_fc_trace_free(void)\r\n{\r\nfnic_fc_tracing_enabled = 0;\r\nfnic_fc_trace_debugfs_terminate();\r\nif (fc_trace_entries.page_offset) {\r\nvfree((void *)fc_trace_entries.page_offset);\r\nfc_trace_entries.page_offset = NULL;\r\n}\r\nif (fnic_fc_ctlr_trace_buf_p) {\r\nvfree((void *)fnic_fc_ctlr_trace_buf_p);\r\nfnic_fc_ctlr_trace_buf_p = 0;\r\n}\r\npr_info("fnic:Successfully FC_CTLR Freed Trace Buffer\n");\r\n}\r\nint fnic_fc_trace_set_data(u32 host_no, u8 frame_type,\r\nchar *frame, u32 fc_trc_frame_len)\r\n{\r\nunsigned long flags;\r\nstruct fc_trace_hdr *fc_buf;\r\nunsigned long eth_fcoe_hdr_len;\r\nchar *fc_trace;\r\nif (fnic_fc_tracing_enabled == 0)\r\nreturn 0;\r\nspin_lock_irqsave(&fnic_fc_trace_lock, flags);\r\nif (fnic_fc_trace_cleared == 1) {\r\nfc_trace_entries.rd_idx = fc_trace_entries.wr_idx = 0;\r\npr_info("fnic: Resetting the read idx\n");\r\nmemset((void *)fnic_fc_ctlr_trace_buf_p, 0,\r\nfnic_fc_trace_max_pages * PAGE_SIZE);\r\nfnic_fc_trace_cleared = 0;\r\n}\r\nfc_buf = (struct fc_trace_hdr *)\r\nfc_trace_entries.page_offset[fc_trace_entries.wr_idx];\r\nfc_trace_entries.wr_idx++;\r\nif (fc_trace_entries.wr_idx >= fc_trace_max_entries)\r\nfc_trace_entries.wr_idx = 0;\r\nif (fc_trace_entries.wr_idx == fc_trace_entries.rd_idx) {\r\nfc_trace_entries.rd_idx++;\r\nif (fc_trace_entries.rd_idx >= fc_trace_max_entries)\r\nfc_trace_entries.rd_idx = 0;\r\n}\r\nfc_buf->time_stamp = CURRENT_TIME;\r\nfc_buf->host_no = host_no;\r\nfc_buf->frame_type = frame_type;\r\nfc_trace = (char *)FC_TRACE_ADDRESS(fc_buf);\r\nif (frame_type == FNIC_FC_RECV) {\r\neth_fcoe_hdr_len = sizeof(struct ethhdr) +\r\nsizeof(struct fcoe_hdr);\r\nmemset((char *)fc_trace, 0xff, eth_fcoe_hdr_len);\r\nmemcpy((char *)(fc_trace + eth_fcoe_hdr_len), (void *)frame,\r\nmin_t(u8, fc_trc_frame_len,\r\n(u8)(FC_TRC_SIZE_BYTES - FC_TRC_HEADER_SIZE\r\n- eth_fcoe_hdr_len)));\r\n} else {\r\nmemcpy((char *)fc_trace, (void *)frame,\r\nmin_t(u8, fc_trc_frame_len,\r\n(u8)(FC_TRC_SIZE_BYTES - FC_TRC_HEADER_SIZE)));\r\n}\r\nfc_buf->frame_len = fc_trc_frame_len;\r\nspin_unlock_irqrestore(&fnic_fc_trace_lock, flags);\r\nreturn 0;\r\n}\r\nint fnic_fc_trace_get_data(fnic_dbgfs_t *fnic_dbgfs_prt, u8 rdata_flag)\r\n{\r\nint rd_idx, wr_idx;\r\nunsigned long flags;\r\nint len = 0, j;\r\nstruct fc_trace_hdr *tdata;\r\nchar *fc_trace;\r\nspin_lock_irqsave(&fnic_fc_trace_lock, flags);\r\nif (fc_trace_entries.wr_idx == fc_trace_entries.rd_idx) {\r\nspin_unlock_irqrestore(&fnic_fc_trace_lock, flags);\r\npr_info("fnic: Buffer is empty\n");\r\nreturn 0;\r\n}\r\nrd_idx = fc_trace_entries.rd_idx;\r\nwr_idx = fc_trace_entries.wr_idx;\r\nif (rdata_flag == 0) {\r\nlen += snprintf(fnic_dbgfs_prt->buffer + len,\r\n(fnic_fc_trace_max_pages * PAGE_SIZE * 3) - len,\r\n"Time Stamp (UTC)\t\t"\r\n"Host No: F Type: len: FCoE_FRAME:\n");\r\n}\r\nwhile (rd_idx != wr_idx) {\r\ntdata = (struct fc_trace_hdr *)\r\nfc_trace_entries.page_offset[rd_idx];\r\nif (!tdata) {\r\npr_info("fnic: Rd data is NULL\n");\r\nspin_unlock_irqrestore(&fnic_fc_trace_lock, flags);\r\nreturn 0;\r\n}\r\nif (rdata_flag == 0) {\r\ncopy_and_format_trace_data(tdata,\r\nfnic_dbgfs_prt, &len, rdata_flag);\r\n} else {\r\nfc_trace = (char *)tdata;\r\nfor (j = 0; j < FC_TRC_SIZE_BYTES; j++) {\r\nlen += snprintf(fnic_dbgfs_prt->buffer + len,\r\n(fnic_fc_trace_max_pages * PAGE_SIZE * 3)\r\n- len, "%02x", fc_trace[j] & 0xff);\r\n}\r\nlen += snprintf(fnic_dbgfs_prt->buffer + len,\r\n(fnic_fc_trace_max_pages * PAGE_SIZE * 3) - len,\r\n"\n");\r\n}\r\nrd_idx++;\r\nif (rd_idx > (fc_trace_max_entries - 1))\r\nrd_idx = 0;\r\n}\r\nspin_unlock_irqrestore(&fnic_fc_trace_lock, flags);\r\nreturn len;\r\n}\r\nvoid copy_and_format_trace_data(struct fc_trace_hdr *tdata,\r\nfnic_dbgfs_t *fnic_dbgfs_prt, int *orig_len,\r\nu8 rdata_flag)\r\n{\r\nstruct tm tm;\r\nint j, i = 1, len;\r\nchar *fc_trace, *fmt;\r\nint ethhdr_len = sizeof(struct ethhdr) - 1;\r\nint fcoehdr_len = sizeof(struct fcoe_hdr);\r\nint fchdr_len = sizeof(struct fc_frame_header);\r\nint max_size = fnic_fc_trace_max_pages * PAGE_SIZE * 3;\r\ntdata->frame_type = tdata->frame_type & 0x7F;\r\nlen = *orig_len;\r\ntime_to_tm(tdata->time_stamp.tv_sec, 0, &tm);\r\nfmt = "%02d:%02d:%04ld %02d:%02d:%02d.%09lu ns%8x %c%8x\t";\r\nlen += snprintf(fnic_dbgfs_prt->buffer + len,\r\nmax_size - len,\r\nfmt,\r\ntm.tm_mon + 1, tm.tm_mday, tm.tm_year + 1900,\r\ntm.tm_hour, tm.tm_min, tm.tm_sec,\r\ntdata->time_stamp.tv_nsec, tdata->host_no,\r\ntdata->frame_type, tdata->frame_len);\r\nfc_trace = (char *)FC_TRACE_ADDRESS(tdata);\r\nfor (j = 0; j < min_t(u8, tdata->frame_len,\r\n(u8)(FC_TRC_SIZE_BYTES - FC_TRC_HEADER_SIZE)); j++) {\r\nif (tdata->frame_type == FNIC_FC_LE) {\r\nlen += snprintf(fnic_dbgfs_prt->buffer + len,\r\nmax_size - len, "%c", fc_trace[j]);\r\n} else {\r\nlen += snprintf(fnic_dbgfs_prt->buffer + len,\r\nmax_size - len, "%02x", fc_trace[j] & 0xff);\r\nlen += snprintf(fnic_dbgfs_prt->buffer + len,\r\nmax_size - len, " ");\r\nif (j == ethhdr_len ||\r\nj == ethhdr_len + fcoehdr_len ||\r\nj == ethhdr_len + fcoehdr_len + fchdr_len ||\r\n(i > 3 && j%fchdr_len == 0)) {\r\nlen += snprintf(fnic_dbgfs_prt->buffer\r\n+ len, max_size - len,\r\n"\n\t\t\t\t\t\t\t\t");\r\ni++;\r\n}\r\n}\r\n}\r\nlen += snprintf(fnic_dbgfs_prt->buffer + len,\r\nmax_size - len, "\n");\r\n*orig_len = len;\r\n}
