static void emc_ccfifo_writel(struct tegra_emc *emc, u32 value,\r\nunsigned long offset)\r\n{\r\nwritel(value, emc->regs + EMC_CCFIFO_DATA);\r\nwritel(offset, emc->regs + EMC_CCFIFO_ADDR);\r\n}\r\nstatic void emc_seq_update_timing(struct tegra_emc *emc)\r\n{\r\nunsigned int i;\r\nu32 value;\r\nwritel(1, emc->regs + EMC_TIMING_CONTROL);\r\nfor (i = 0; i < EMC_STATUS_UPDATE_TIMEOUT; ++i) {\r\nvalue = readl(emc->regs + EMC_STATUS);\r\nif ((value & EMC_STATUS_TIMING_UPDATE_STALLED) == 0)\r\nreturn;\r\nudelay(1);\r\n}\r\ndev_err(emc->dev, "timing update timed out\n");\r\n}\r\nstatic void emc_seq_disable_auto_cal(struct tegra_emc *emc)\r\n{\r\nunsigned int i;\r\nu32 value;\r\nwritel(0, emc->regs + EMC_AUTO_CAL_INTERVAL);\r\nfor (i = 0; i < EMC_STATUS_UPDATE_TIMEOUT; ++i) {\r\nvalue = readl(emc->regs + EMC_AUTO_CAL_STATUS);\r\nif ((value & EMC_AUTO_CAL_STATUS_ACTIVE) == 0)\r\nreturn;\r\nudelay(1);\r\n}\r\ndev_err(emc->dev, "auto cal disable timed out\n");\r\n}\r\nstatic void emc_seq_wait_clkchange(struct tegra_emc *emc)\r\n{\r\nunsigned int i;\r\nu32 value;\r\nfor (i = 0; i < EMC_STATUS_UPDATE_TIMEOUT; ++i) {\r\nvalue = readl(emc->regs + EMC_INTSTATUS);\r\nif (value & EMC_INTSTATUS_CLKCHANGE_COMPLETE)\r\nreturn;\r\nudelay(1);\r\n}\r\ndev_err(emc->dev, "clock change timed out\n");\r\n}\r\nstatic struct emc_timing *tegra_emc_find_timing(struct tegra_emc *emc,\r\nunsigned long rate)\r\n{\r\nstruct emc_timing *timing = NULL;\r\nunsigned int i;\r\nfor (i = 0; i < emc->num_timings; i++) {\r\nif (emc->timings[i].rate == rate) {\r\ntiming = &emc->timings[i];\r\nbreak;\r\n}\r\n}\r\nif (!timing) {\r\ndev_err(emc->dev, "no timing for rate %lu\n", rate);\r\nreturn NULL;\r\n}\r\nreturn timing;\r\n}\r\nint tegra_emc_prepare_timing_change(struct tegra_emc *emc,\r\nunsigned long rate)\r\n{\r\nstruct emc_timing *timing = tegra_emc_find_timing(emc, rate);\r\nstruct emc_timing *last = &emc->last_timing;\r\nenum emc_dll_change dll_change;\r\nunsigned int pre_wait = 0;\r\nu32 val, val2, mask;\r\nbool update = false;\r\nunsigned int i;\r\nif (!timing)\r\nreturn -ENOENT;\r\nif ((last->emc_mode_1 & 0x1) == (timing->emc_mode_1 & 0x1))\r\ndll_change = DLL_CHANGE_NONE;\r\nelse if (timing->emc_mode_1 & 0x1)\r\ndll_change = DLL_CHANGE_ON;\r\nelse\r\ndll_change = DLL_CHANGE_OFF;\r\nwritel(EMC_INTSTATUS_CLKCHANGE_COMPLETE, emc->regs + EMC_INTSTATUS);\r\nval = readl(emc->regs + EMC_CFG);\r\nif (val & EMC_CFG_PWR_MASK) {\r\nval &= ~EMC_CFG_POWER_FEATURES_MASK;\r\nwritel(val, emc->regs + EMC_CFG);\r\npre_wait = 5;\r\n}\r\nif (emc->dram_type == DRAM_TYPE_DDR3)\r\nmask = EMC_SEL_DPD_CTRL_DDR3_MASK;\r\nelse\r\nmask = EMC_SEL_DPD_CTRL_MASK;\r\nval = readl(emc->regs + EMC_SEL_DPD_CTRL);\r\nif (val & mask) {\r\nval &= ~mask;\r\nwritel(val, emc->regs + EMC_SEL_DPD_CTRL);\r\n}\r\nval = readl(emc->regs + EMC_BGBIAS_CTL0);\r\nval2 = last->emc_bgbias_ctl0;\r\nif (!(timing->emc_bgbias_ctl0 &\r\nEMC_BGBIAS_CTL0_BIAS0_DSC_E_PWRD_IBIAS_RX) &&\r\n(val & EMC_BGBIAS_CTL0_BIAS0_DSC_E_PWRD_IBIAS_RX)) {\r\nval2 &= ~EMC_BGBIAS_CTL0_BIAS0_DSC_E_PWRD_IBIAS_RX;\r\nupdate = true;\r\n}\r\nif ((val & EMC_BGBIAS_CTL0_BIAS0_DSC_E_PWRD) ||\r\n(val & EMC_BGBIAS_CTL0_BIAS0_DSC_E_PWRD_IBIAS_VTTGEN)) {\r\nupdate = true;\r\n}\r\nif (update) {\r\nwritel(val2, emc->regs + EMC_BGBIAS_CTL0);\r\nif (pre_wait < 5)\r\npre_wait = 5;\r\n}\r\nupdate = false;\r\nval = readl(emc->regs + EMC_XM2DQSPADCTRL2);\r\nif (timing->emc_xm2dqspadctrl2 & EMC_XM2DQSPADCTRL2_VREF_ENABLE &&\r\n!(val & EMC_XM2DQSPADCTRL2_VREF_ENABLE)) {\r\nval |= EMC_XM2DQSPADCTRL2_VREF_ENABLE;\r\nupdate = true;\r\n}\r\nif (timing->emc_xm2dqspadctrl2 & EMC_XM2DQSPADCTRL2_RX_FT_REC_ENABLE &&\r\n!(val & EMC_XM2DQSPADCTRL2_RX_FT_REC_ENABLE)) {\r\nval |= EMC_XM2DQSPADCTRL2_RX_FT_REC_ENABLE;\r\nupdate = true;\r\n}\r\nif (update) {\r\nwritel(val, emc->regs + EMC_XM2DQSPADCTRL2);\r\nif (pre_wait < 30)\r\npre_wait = 30;\r\n}\r\nif (pre_wait) {\r\nemc_seq_update_timing(emc);\r\nudelay(pre_wait);\r\n}\r\nif (last->emc_ctt_term_ctrl != timing->emc_ctt_term_ctrl) {\r\nemc_seq_disable_auto_cal(emc);\r\nwritel(timing->emc_ctt_term_ctrl,\r\nemc->regs + EMC_CTT_TERM_CTRL);\r\nemc_seq_update_timing(emc);\r\n}\r\nfor (i = 0; i < ARRAY_SIZE(timing->emc_burst_data); ++i)\r\nwritel(timing->emc_burst_data[i],\r\nemc->regs + emc_burst_regs[i]);\r\nwritel(timing->emc_xm2dqspadctrl2, emc->regs + EMC_XM2DQSPADCTRL2);\r\nwritel(timing->emc_zcal_interval, emc->regs + EMC_ZCAL_INTERVAL);\r\ntegra_mc_write_emem_configuration(emc->mc, timing->rate);\r\nval = timing->emc_cfg & ~EMC_CFG_POWER_FEATURES_MASK;\r\nemc_ccfifo_writel(emc, val, EMC_CFG);\r\nif (timing->emc_auto_cal_config2 != last->emc_auto_cal_config2)\r\nemc_ccfifo_writel(emc, timing->emc_auto_cal_config2,\r\nEMC_AUTO_CAL_CONFIG2);\r\nif (timing->emc_auto_cal_config3 != last->emc_auto_cal_config3)\r\nemc_ccfifo_writel(emc, timing->emc_auto_cal_config3,\r\nEMC_AUTO_CAL_CONFIG3);\r\nif (timing->emc_auto_cal_config != last->emc_auto_cal_config) {\r\nval = timing->emc_auto_cal_config;\r\nval &= EMC_AUTO_CAL_CONFIG_AUTO_CAL_START;\r\nemc_ccfifo_writel(emc, val, EMC_AUTO_CAL_CONFIG);\r\n}\r\nif (emc->dram_type == DRAM_TYPE_DDR3 &&\r\ndll_change == DLL_CHANGE_ON) {\r\nu32 cnt = 512;\r\nif (timing->emc_zcal_interval != 0 &&\r\nlast->emc_zcal_interval == 0)\r\ncnt -= emc->dram_num * 256;\r\nval = (timing->emc_mrs_wait_cnt\r\n& EMC_MRS_WAIT_CNT_SHORT_WAIT_MASK)\r\n>> EMC_MRS_WAIT_CNT_SHORT_WAIT_SHIFT;\r\nif (cnt < val)\r\ncnt = val;\r\nval = timing->emc_mrs_wait_cnt\r\n& ~EMC_MRS_WAIT_CNT_LONG_WAIT_MASK;\r\nval |= (cnt << EMC_MRS_WAIT_CNT_LONG_WAIT_SHIFT)\r\n& EMC_MRS_WAIT_CNT_LONG_WAIT_MASK;\r\nwritel(val, emc->regs + EMC_MRS_WAIT_CNT);\r\n}\r\nval = timing->emc_cfg_2;\r\nval &= ~EMC_CFG_2_DIS_STP_OB_CLK_DURING_NON_WR;\r\nemc_ccfifo_writel(emc, val, EMC_CFG_2);\r\nif (emc->dram_type == DRAM_TYPE_DDR3 && dll_change == DLL_CHANGE_OFF)\r\nemc_ccfifo_writel(emc, timing->emc_mode_1, EMC_EMRS);\r\nemc_ccfifo_writel(emc, EMC_REFCTRL_DEV_SEL(emc->dram_num),\r\nEMC_REFCTRL);\r\nif (emc->dram_type == DRAM_TYPE_DDR3)\r\nemc_ccfifo_writel(emc, EMC_DRAM_DEV_SEL(emc->dram_num) |\r\nEMC_SELF_REF_CMD_ENABLED,\r\nEMC_SELF_REF);\r\nemc_ccfifo_writel(emc, 1, EMC_STALL_THEN_EXE_AFTER_CLKCHANGE);\r\nif (emc->dram_type == DRAM_TYPE_DDR3)\r\nemc_ccfifo_writel(emc, EMC_DRAM_DEV_SEL(emc->dram_num),\r\nEMC_SELF_REF);\r\nemc_ccfifo_writel(emc, EMC_REFCTRL_DEV_SEL(emc->dram_num) |\r\nEMC_REFCTRL_ENABLE,\r\nEMC_REFCTRL);\r\nif (emc->dram_type == DRAM_TYPE_DDR3) {\r\nif (timing->emc_mode_1 != last->emc_mode_1)\r\nemc_ccfifo_writel(emc, timing->emc_mode_1, EMC_EMRS);\r\nif (timing->emc_mode_2 != last->emc_mode_2)\r\nemc_ccfifo_writel(emc, timing->emc_mode_2, EMC_EMRS2);\r\nif ((timing->emc_mode_reset != last->emc_mode_reset) ||\r\ndll_change == DLL_CHANGE_ON) {\r\nval = timing->emc_mode_reset;\r\nif (dll_change == DLL_CHANGE_ON) {\r\nval |= EMC_MODE_SET_DLL_RESET;\r\nval |= EMC_MODE_SET_LONG_CNT;\r\n} else {\r\nval &= ~EMC_MODE_SET_DLL_RESET;\r\n}\r\nemc_ccfifo_writel(emc, val, EMC_MRS);\r\n}\r\n} else {\r\nif (timing->emc_mode_2 != last->emc_mode_2)\r\nemc_ccfifo_writel(emc, timing->emc_mode_2, EMC_MRW2);\r\nif (timing->emc_mode_1 != last->emc_mode_1)\r\nemc_ccfifo_writel(emc, timing->emc_mode_1, EMC_MRW);\r\nif (timing->emc_mode_4 != last->emc_mode_4)\r\nemc_ccfifo_writel(emc, timing->emc_mode_4, EMC_MRW4);\r\n}\r\nif (timing->emc_zcal_interval != 0 && last->emc_zcal_interval == 0) {\r\nemc_ccfifo_writel(emc, EMC_ZQ_CAL_LONG_CMD_DEV0, EMC_ZQ_CAL);\r\nif (emc->dram_num > 1)\r\nemc_ccfifo_writel(emc, EMC_ZQ_CAL_LONG_CMD_DEV1,\r\nEMC_ZQ_CAL);\r\n}\r\nemc_ccfifo_writel(emc, 0, EMC_CCFIFO_STATUS);\r\nif (timing->emc_cfg_2 & EMC_CFG_2_DIS_STP_OB_CLK_DURING_NON_WR)\r\nemc_ccfifo_writel(emc, timing->emc_cfg_2, EMC_CFG_2);\r\nemc_seq_disable_auto_cal(emc);\r\nreadl(emc->regs + EMC_INTSTATUS);\r\nreturn 0;\r\n}\r\nvoid tegra_emc_complete_timing_change(struct tegra_emc *emc,\r\nunsigned long rate)\r\n{\r\nstruct emc_timing *timing = tegra_emc_find_timing(emc, rate);\r\nstruct emc_timing *last = &emc->last_timing;\r\nu32 val;\r\nif (!timing)\r\nreturn;\r\nemc_seq_wait_clkchange(emc);\r\nif (timing->emc_ctt_term_ctrl != last->emc_ctt_term_ctrl)\r\nwritel(timing->emc_auto_cal_interval,\r\nemc->regs + EMC_AUTO_CAL_INTERVAL);\r\nif (timing->emc_cfg & EMC_CFG_PWR_MASK)\r\nwritel(timing->emc_cfg, emc->regs + EMC_CFG);\r\nwritel(timing->emc_zcal_cnt_long, emc->regs + EMC_ZCAL_WAIT_CNT);\r\nif (emc->dram_type == DRAM_TYPE_LPDDR3 &&\r\ntiming->emc_bgbias_ctl0 &\r\nEMC_BGBIAS_CTL0_BIAS0_DSC_E_PWRD_IBIAS_RX) {\r\nval = timing->emc_bgbias_ctl0;\r\nval |= EMC_BGBIAS_CTL0_BIAS0_DSC_E_PWRD_IBIAS_VTTGEN;\r\nval |= EMC_BGBIAS_CTL0_BIAS0_DSC_E_PWRD;\r\nwritel(val, emc->regs + EMC_BGBIAS_CTL0);\r\n} else {\r\nif (emc->dram_type == DRAM_TYPE_DDR3 &&\r\nreadl(emc->regs + EMC_BGBIAS_CTL0) !=\r\ntiming->emc_bgbias_ctl0) {\r\nwritel(timing->emc_bgbias_ctl0,\r\nemc->regs + EMC_BGBIAS_CTL0);\r\n}\r\nwritel(timing->emc_auto_cal_interval,\r\nemc->regs + EMC_AUTO_CAL_INTERVAL);\r\n}\r\nudelay(2);\r\nwritel(timing->emc_sel_dpd_ctrl, emc->regs + EMC_SEL_DPD_CTRL);\r\nemc_seq_update_timing(emc);\r\nemc->last_timing = *timing;\r\n}\r\nstatic void emc_read_current_timing(struct tegra_emc *emc,\r\nstruct emc_timing *timing)\r\n{\r\nunsigned int i;\r\nfor (i = 0; i < ARRAY_SIZE(emc_burst_regs); ++i)\r\ntiming->emc_burst_data[i] =\r\nreadl(emc->regs + emc_burst_regs[i]);\r\ntiming->emc_cfg = readl(emc->regs + EMC_CFG);\r\ntiming->emc_auto_cal_interval = 0;\r\ntiming->emc_zcal_cnt_long = 0;\r\ntiming->emc_mode_1 = 0;\r\ntiming->emc_mode_2 = 0;\r\ntiming->emc_mode_4 = 0;\r\ntiming->emc_mode_reset = 0;\r\n}\r\nstatic int emc_init(struct tegra_emc *emc)\r\n{\r\nemc->dram_type = readl(emc->regs + EMC_FBIO_CFG5);\r\nemc->dram_type &= EMC_FBIO_CFG5_DRAM_TYPE_MASK;\r\nemc->dram_type >>= EMC_FBIO_CFG5_DRAM_TYPE_SHIFT;\r\nemc->dram_num = tegra_mc_get_emem_device_count(emc->mc);\r\nemc_read_current_timing(emc, &emc->last_timing);\r\nreturn 0;\r\n}\r\nstatic int load_one_timing_from_dt(struct tegra_emc *emc,\r\nstruct emc_timing *timing,\r\nstruct device_node *node)\r\n{\r\nu32 value;\r\nint err;\r\nerr = of_property_read_u32(node, "clock-frequency", &value);\r\nif (err) {\r\ndev_err(emc->dev, "timing %s: failed to read rate: %d\n",\r\nnode->name, err);\r\nreturn err;\r\n}\r\ntiming->rate = value;\r\nerr = of_property_read_u32_array(node, "nvidia,emc-configuration",\r\ntiming->emc_burst_data,\r\nARRAY_SIZE(timing->emc_burst_data));\r\nif (err) {\r\ndev_err(emc->dev,\r\n"timing %s: failed to read emc burst data: %d\n",\r\nnode->name, err);\r\nreturn err;\r\n}\r\n#define EMC_READ_PROP(prop, dtprop) { \\r\nerr = of_property_read_u32(node, dtprop, &timing->prop); \\r\nif (err) { \\r\ndev_err(emc->dev, "timing %s: failed to read " #prop ": %d\n", \\r\nnode->name, err); \\r\nreturn err; \\r\n} \\r\n}\r\nEMC_READ_PROP(emc_auto_cal_config, "nvidia,emc-auto-cal-config")\r\nEMC_READ_PROP(emc_auto_cal_config2, "nvidia,emc-auto-cal-config2")\r\nEMC_READ_PROP(emc_auto_cal_config3, "nvidia,emc-auto-cal-config3")\r\nEMC_READ_PROP(emc_auto_cal_interval, "nvidia,emc-auto-cal-interval")\r\nEMC_READ_PROP(emc_bgbias_ctl0, "nvidia,emc-bgbias-ctl0")\r\nEMC_READ_PROP(emc_cfg, "nvidia,emc-cfg")\r\nEMC_READ_PROP(emc_cfg_2, "nvidia,emc-cfg-2")\r\nEMC_READ_PROP(emc_ctt_term_ctrl, "nvidia,emc-ctt-term-ctrl")\r\nEMC_READ_PROP(emc_mode_1, "nvidia,emc-mode-1")\r\nEMC_READ_PROP(emc_mode_2, "nvidia,emc-mode-2")\r\nEMC_READ_PROP(emc_mode_4, "nvidia,emc-mode-4")\r\nEMC_READ_PROP(emc_mode_reset, "nvidia,emc-mode-reset")\r\nEMC_READ_PROP(emc_mrs_wait_cnt, "nvidia,emc-mrs-wait-cnt")\r\nEMC_READ_PROP(emc_sel_dpd_ctrl, "nvidia,emc-sel-dpd-ctrl")\r\nEMC_READ_PROP(emc_xm2dqspadctrl2, "nvidia,emc-xm2dqspadctrl2")\r\nEMC_READ_PROP(emc_zcal_cnt_long, "nvidia,emc-zcal-cnt-long")\r\nEMC_READ_PROP(emc_zcal_interval, "nvidia,emc-zcal-interval")\r\n#undef EMC_READ_PROP\r\nreturn 0;\r\n}\r\nstatic int cmp_timings(const void *_a, const void *_b)\r\n{\r\nconst struct emc_timing *a = _a;\r\nconst struct emc_timing *b = _b;\r\nif (a->rate < b->rate)\r\nreturn -1;\r\nelse if (a->rate == b->rate)\r\nreturn 0;\r\nelse\r\nreturn 1;\r\n}\r\nstatic int tegra_emc_load_timings_from_dt(struct tegra_emc *emc,\r\nstruct device_node *node)\r\n{\r\nint child_count = of_get_child_count(node);\r\nstruct device_node *child;\r\nstruct emc_timing *timing;\r\nunsigned int i = 0;\r\nint err;\r\nemc->timings = devm_kcalloc(emc->dev, child_count, sizeof(*timing),\r\nGFP_KERNEL);\r\nif (!emc->timings)\r\nreturn -ENOMEM;\r\nemc->num_timings = child_count;\r\nfor_each_child_of_node(node, child) {\r\ntiming = &emc->timings[i++];\r\nerr = load_one_timing_from_dt(emc, timing, child);\r\nif (err)\r\nreturn err;\r\n}\r\nsort(emc->timings, emc->num_timings, sizeof(*timing), cmp_timings,\r\nNULL);\r\nreturn 0;\r\n}\r\nstatic struct device_node *\r\ntegra_emc_find_node_by_ram_code(struct device_node *node, u32 ram_code)\r\n{\r\nstruct device_node *np;\r\nint err;\r\nfor_each_child_of_node(node, np) {\r\nu32 value;\r\nerr = of_property_read_u32(np, "nvidia,ram-code", &value);\r\nif (err || (value != ram_code)) {\r\nof_node_put(np);\r\ncontinue;\r\n}\r\nreturn np;\r\n}\r\nreturn NULL;\r\n}\r\nstatic int emc_debug_rate_get(void *data, u64 *rate)\r\n{\r\nstruct clk *c = data;\r\n*rate = clk_get_rate(c);\r\nreturn 0;\r\n}\r\nstatic int emc_debug_rate_set(void *data, u64 rate)\r\n{\r\nstruct clk *c = data;\r\nreturn clk_set_rate(c, rate);\r\n}\r\nstatic int emc_debug_supported_rates_show(struct seq_file *s, void *data)\r\n{\r\nstruct tegra_emc *emc = s->private;\r\nconst char *prefix = "";\r\nunsigned int i;\r\nfor (i = 0; i < emc->num_timings; i++) {\r\nstruct emc_timing *timing = &emc->timings[i];\r\nseq_printf(s, "%s%lu", prefix, timing->rate);\r\nprefix = " ";\r\n}\r\nseq_puts(s, "\n");\r\nreturn 0;\r\n}\r\nstatic int emc_debug_supported_rates_open(struct inode *inode,\r\nstruct file *file)\r\n{\r\nreturn single_open(file, emc_debug_supported_rates_show,\r\ninode->i_private);\r\n}\r\nstatic void emc_debugfs_init(struct device *dev, struct tegra_emc *emc)\r\n{\r\nstruct dentry *root, *file;\r\nstruct clk *clk;\r\nroot = debugfs_create_dir("emc", NULL);\r\nif (!root) {\r\ndev_err(dev, "failed to create debugfs directory\n");\r\nreturn;\r\n}\r\nclk = clk_get_sys("tegra-clk-debug", "emc");\r\nif (IS_ERR(clk)) {\r\ndev_err(dev, "failed to get debug clock: %ld\n", PTR_ERR(clk));\r\nreturn;\r\n}\r\nfile = debugfs_create_file("rate", S_IRUGO | S_IWUSR, root, clk,\r\n&emc_debug_rate_fops);\r\nif (!file)\r\ndev_err(dev, "failed to create debugfs entry\n");\r\nfile = debugfs_create_file("supported_rates", S_IRUGO, root, emc,\r\n&emc_debug_supported_rates_fops);\r\nif (!file)\r\ndev_err(dev, "failed to create debugfs entry\n");\r\n}\r\nstatic int tegra_emc_probe(struct platform_device *pdev)\r\n{\r\nstruct platform_device *mc;\r\nstruct device_node *np;\r\nstruct tegra_emc *emc;\r\nstruct resource *res;\r\nu32 ram_code;\r\nint err;\r\nemc = devm_kzalloc(&pdev->dev, sizeof(*emc), GFP_KERNEL);\r\nif (!emc)\r\nreturn -ENOMEM;\r\nemc->dev = &pdev->dev;\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nemc->regs = devm_ioremap_resource(&pdev->dev, res);\r\nif (IS_ERR(emc->regs))\r\nreturn PTR_ERR(emc->regs);\r\nnp = of_parse_phandle(pdev->dev.of_node, "nvidia,memory-controller", 0);\r\nif (!np) {\r\ndev_err(&pdev->dev, "could not get memory controller\n");\r\nreturn -ENOENT;\r\n}\r\nmc = of_find_device_by_node(np);\r\nif (!mc)\r\nreturn -ENOENT;\r\nof_node_put(np);\r\nemc->mc = platform_get_drvdata(mc);\r\nif (!emc->mc)\r\nreturn -EPROBE_DEFER;\r\nram_code = tegra_read_ram_code();\r\nnp = tegra_emc_find_node_by_ram_code(pdev->dev.of_node, ram_code);\r\nif (!np) {\r\ndev_err(&pdev->dev,\r\n"no memory timings for RAM code %u found in DT\n",\r\nram_code);\r\nreturn -ENOENT;\r\n}\r\nerr = tegra_emc_load_timings_from_dt(emc, np);\r\nof_node_put(np);\r\nif (err)\r\nreturn err;\r\nif (emc->num_timings == 0) {\r\ndev_err(&pdev->dev,\r\n"no memory timings for RAM code %u registered\n",\r\nram_code);\r\nreturn -ENOENT;\r\n}\r\nerr = emc_init(emc);\r\nif (err) {\r\ndev_err(&pdev->dev, "EMC initialization failed: %d\n", err);\r\nreturn err;\r\n}\r\nplatform_set_drvdata(pdev, emc);\r\nif (IS_ENABLED(CONFIG_DEBUG_FS))\r\nemc_debugfs_init(&pdev->dev, emc);\r\nreturn 0;\r\n}\r\nstatic int tegra_emc_init(void)\r\n{\r\nreturn platform_driver_register(&tegra_emc_driver);\r\n}
