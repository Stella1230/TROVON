static inline void mcasp_set_bits(struct davinci_mcasp *mcasp, u32 offset,\r\nu32 val)\r\n{\r\nvoid __iomem *reg = mcasp->base + offset;\r\n__raw_writel(__raw_readl(reg) | val, reg);\r\n}\r\nstatic inline void mcasp_clr_bits(struct davinci_mcasp *mcasp, u32 offset,\r\nu32 val)\r\n{\r\nvoid __iomem *reg = mcasp->base + offset;\r\n__raw_writel((__raw_readl(reg) & ~(val)), reg);\r\n}\r\nstatic inline void mcasp_mod_bits(struct davinci_mcasp *mcasp, u32 offset,\r\nu32 val, u32 mask)\r\n{\r\nvoid __iomem *reg = mcasp->base + offset;\r\n__raw_writel((__raw_readl(reg) & ~mask) | val, reg);\r\n}\r\nstatic inline void mcasp_set_reg(struct davinci_mcasp *mcasp, u32 offset,\r\nu32 val)\r\n{\r\n__raw_writel(val, mcasp->base + offset);\r\n}\r\nstatic inline u32 mcasp_get_reg(struct davinci_mcasp *mcasp, u32 offset)\r\n{\r\nreturn (u32)__raw_readl(mcasp->base + offset);\r\n}\r\nstatic void mcasp_set_ctl_reg(struct davinci_mcasp *mcasp, u32 ctl_reg, u32 val)\r\n{\r\nint i = 0;\r\nmcasp_set_bits(mcasp, ctl_reg, val);\r\nfor (i = 0; i < 1000; i++) {\r\nif ((mcasp_get_reg(mcasp, ctl_reg) & val) == val)\r\nbreak;\r\n}\r\nif (i == 1000 && ((mcasp_get_reg(mcasp, ctl_reg) & val) != val))\r\nprintk(KERN_ERR "GBLCTL write error\n");\r\n}\r\nstatic bool mcasp_is_synchronous(struct davinci_mcasp *mcasp)\r\n{\r\nu32 rxfmctl = mcasp_get_reg(mcasp, DAVINCI_MCASP_RXFMCTL_REG);\r\nu32 aclkxctl = mcasp_get_reg(mcasp, DAVINCI_MCASP_ACLKXCTL_REG);\r\nreturn !(aclkxctl & TX_ASYNC) && rxfmctl & AFSRE;\r\n}\r\nstatic void mcasp_start_rx(struct davinci_mcasp *mcasp)\r\n{\r\nif (mcasp->rxnumevt) {\r\nu32 reg = mcasp->fifo_base + MCASP_RFIFOCTL_OFFSET;\r\nmcasp_clr_bits(mcasp, reg, FIFO_ENABLE);\r\nmcasp_set_bits(mcasp, reg, FIFO_ENABLE);\r\n}\r\nmcasp_set_ctl_reg(mcasp, DAVINCI_MCASP_GBLCTLR_REG, RXHCLKRST);\r\nmcasp_set_ctl_reg(mcasp, DAVINCI_MCASP_GBLCTLR_REG, RXCLKRST);\r\nif (mcasp_is_synchronous(mcasp)) {\r\nmcasp_set_ctl_reg(mcasp, DAVINCI_MCASP_GBLCTLX_REG, TXHCLKRST);\r\nmcasp_set_ctl_reg(mcasp, DAVINCI_MCASP_GBLCTLX_REG, TXCLKRST);\r\n}\r\nmcasp_set_ctl_reg(mcasp, DAVINCI_MCASP_GBLCTLR_REG, RXSERCLR);\r\nmcasp_set_ctl_reg(mcasp, DAVINCI_MCASP_GBLCTLR_REG, RXSMRST);\r\nmcasp_set_ctl_reg(mcasp, DAVINCI_MCASP_GBLCTLR_REG, RXFSRST);\r\nif (mcasp_is_synchronous(mcasp))\r\nmcasp_set_ctl_reg(mcasp, DAVINCI_MCASP_GBLCTLX_REG, TXFSRST);\r\nmcasp_set_bits(mcasp, DAVINCI_MCASP_EVTCTLR_REG,\r\nmcasp->irq_request[SNDRV_PCM_STREAM_CAPTURE]);\r\n}\r\nstatic void mcasp_start_tx(struct davinci_mcasp *mcasp)\r\n{\r\nu32 cnt;\r\nif (mcasp->txnumevt) {\r\nu32 reg = mcasp->fifo_base + MCASP_WFIFOCTL_OFFSET;\r\nmcasp_clr_bits(mcasp, reg, FIFO_ENABLE);\r\nmcasp_set_bits(mcasp, reg, FIFO_ENABLE);\r\n}\r\nmcasp_set_ctl_reg(mcasp, DAVINCI_MCASP_GBLCTLX_REG, TXHCLKRST);\r\nmcasp_set_ctl_reg(mcasp, DAVINCI_MCASP_GBLCTLX_REG, TXCLKRST);\r\nmcasp_set_ctl_reg(mcasp, DAVINCI_MCASP_GBLCTLX_REG, TXSERCLR);\r\ncnt = 0;\r\nwhile ((mcasp_get_reg(mcasp, DAVINCI_MCASP_TXSTAT_REG) & XRDATA) &&\r\n(cnt < 100000))\r\ncnt++;\r\nmcasp_set_ctl_reg(mcasp, DAVINCI_MCASP_GBLCTLX_REG, TXSMRST);\r\nmcasp_set_ctl_reg(mcasp, DAVINCI_MCASP_GBLCTLX_REG, TXFSRST);\r\nmcasp_set_bits(mcasp, DAVINCI_MCASP_EVTCTLX_REG,\r\nmcasp->irq_request[SNDRV_PCM_STREAM_PLAYBACK]);\r\n}\r\nstatic void davinci_mcasp_start(struct davinci_mcasp *mcasp, int stream)\r\n{\r\nmcasp->streams++;\r\nif (stream == SNDRV_PCM_STREAM_PLAYBACK)\r\nmcasp_start_tx(mcasp);\r\nelse\r\nmcasp_start_rx(mcasp);\r\n}\r\nstatic void mcasp_stop_rx(struct davinci_mcasp *mcasp)\r\n{\r\nmcasp_clr_bits(mcasp, DAVINCI_MCASP_EVTCTLR_REG,\r\nmcasp->irq_request[SNDRV_PCM_STREAM_CAPTURE]);\r\nif (mcasp_is_synchronous(mcasp) && !mcasp->streams)\r\nmcasp_set_reg(mcasp, DAVINCI_MCASP_GBLCTLX_REG, 0);\r\nmcasp_set_reg(mcasp, DAVINCI_MCASP_GBLCTLR_REG, 0);\r\nmcasp_set_reg(mcasp, DAVINCI_MCASP_RXSTAT_REG, 0xFFFFFFFF);\r\nif (mcasp->rxnumevt) {\r\nu32 reg = mcasp->fifo_base + MCASP_RFIFOCTL_OFFSET;\r\nmcasp_clr_bits(mcasp, reg, FIFO_ENABLE);\r\n}\r\n}\r\nstatic void mcasp_stop_tx(struct davinci_mcasp *mcasp)\r\n{\r\nu32 val = 0;\r\nmcasp_clr_bits(mcasp, DAVINCI_MCASP_EVTCTLX_REG,\r\nmcasp->irq_request[SNDRV_PCM_STREAM_PLAYBACK]);\r\nif (mcasp_is_synchronous(mcasp) && mcasp->streams)\r\nval = TXHCLKRST | TXCLKRST | TXFSRST;\r\nmcasp_set_reg(mcasp, DAVINCI_MCASP_GBLCTLX_REG, val);\r\nmcasp_set_reg(mcasp, DAVINCI_MCASP_TXSTAT_REG, 0xFFFFFFFF);\r\nif (mcasp->txnumevt) {\r\nu32 reg = mcasp->fifo_base + MCASP_WFIFOCTL_OFFSET;\r\nmcasp_clr_bits(mcasp, reg, FIFO_ENABLE);\r\n}\r\n}\r\nstatic void davinci_mcasp_stop(struct davinci_mcasp *mcasp, int stream)\r\n{\r\nmcasp->streams--;\r\nif (stream == SNDRV_PCM_STREAM_PLAYBACK)\r\nmcasp_stop_tx(mcasp);\r\nelse\r\nmcasp_stop_rx(mcasp);\r\n}\r\nstatic irqreturn_t davinci_mcasp_tx_irq_handler(int irq, void *data)\r\n{\r\nstruct davinci_mcasp *mcasp = (struct davinci_mcasp *)data;\r\nstruct snd_pcm_substream *substream;\r\nu32 irq_mask = mcasp->irq_request[SNDRV_PCM_STREAM_PLAYBACK];\r\nu32 handled_mask = 0;\r\nu32 stat;\r\nstat = mcasp_get_reg(mcasp, DAVINCI_MCASP_TXSTAT_REG);\r\nif (stat & XUNDRN & irq_mask) {\r\ndev_warn(mcasp->dev, "Transmit buffer underflow\n");\r\nhandled_mask |= XUNDRN;\r\nsubstream = mcasp->substreams[SNDRV_PCM_STREAM_PLAYBACK];\r\nif (substream) {\r\nsnd_pcm_stream_lock_irq(substream);\r\nif (snd_pcm_running(substream))\r\nsnd_pcm_stop(substream, SNDRV_PCM_STATE_XRUN);\r\nsnd_pcm_stream_unlock_irq(substream);\r\n}\r\n}\r\nif (!handled_mask)\r\ndev_warn(mcasp->dev, "unhandled tx event. txstat: 0x%08x\n",\r\nstat);\r\nif (stat & XRERR)\r\nhandled_mask |= XRERR;\r\nmcasp_set_reg(mcasp, DAVINCI_MCASP_TXSTAT_REG, handled_mask);\r\nreturn IRQ_RETVAL(handled_mask);\r\n}\r\nstatic irqreturn_t davinci_mcasp_rx_irq_handler(int irq, void *data)\r\n{\r\nstruct davinci_mcasp *mcasp = (struct davinci_mcasp *)data;\r\nstruct snd_pcm_substream *substream;\r\nu32 irq_mask = mcasp->irq_request[SNDRV_PCM_STREAM_CAPTURE];\r\nu32 handled_mask = 0;\r\nu32 stat;\r\nstat = mcasp_get_reg(mcasp, DAVINCI_MCASP_RXSTAT_REG);\r\nif (stat & ROVRN & irq_mask) {\r\ndev_warn(mcasp->dev, "Receive buffer overflow\n");\r\nhandled_mask |= ROVRN;\r\nsubstream = mcasp->substreams[SNDRV_PCM_STREAM_CAPTURE];\r\nif (substream) {\r\nsnd_pcm_stream_lock_irq(substream);\r\nif (snd_pcm_running(substream))\r\nsnd_pcm_stop(substream, SNDRV_PCM_STATE_XRUN);\r\nsnd_pcm_stream_unlock_irq(substream);\r\n}\r\n}\r\nif (!handled_mask)\r\ndev_warn(mcasp->dev, "unhandled rx event. rxstat: 0x%08x\n",\r\nstat);\r\nif (stat & XRERR)\r\nhandled_mask |= XRERR;\r\nmcasp_set_reg(mcasp, DAVINCI_MCASP_RXSTAT_REG, handled_mask);\r\nreturn IRQ_RETVAL(handled_mask);\r\n}\r\nstatic irqreturn_t davinci_mcasp_common_irq_handler(int irq, void *data)\r\n{\r\nstruct davinci_mcasp *mcasp = (struct davinci_mcasp *)data;\r\nirqreturn_t ret = IRQ_NONE;\r\nif (mcasp->substreams[SNDRV_PCM_STREAM_PLAYBACK])\r\nret = davinci_mcasp_tx_irq_handler(irq, data);\r\nif (mcasp->substreams[SNDRV_PCM_STREAM_CAPTURE])\r\nret |= davinci_mcasp_rx_irq_handler(irq, data);\r\nreturn ret;\r\n}\r\nstatic int davinci_mcasp_set_dai_fmt(struct snd_soc_dai *cpu_dai,\r\nunsigned int fmt)\r\n{\r\nstruct davinci_mcasp *mcasp = snd_soc_dai_get_drvdata(cpu_dai);\r\nint ret = 0;\r\nu32 data_delay;\r\nbool fs_pol_rising;\r\nbool inv_fs = false;\r\npm_runtime_get_sync(mcasp->dev);\r\nswitch (fmt & SND_SOC_DAIFMT_FORMAT_MASK) {\r\ncase SND_SOC_DAIFMT_DSP_A:\r\nmcasp_clr_bits(mcasp, DAVINCI_MCASP_TXFMCTL_REG, FSXDUR);\r\nmcasp_clr_bits(mcasp, DAVINCI_MCASP_RXFMCTL_REG, FSRDUR);\r\ndata_delay = 1;\r\nbreak;\r\ncase SND_SOC_DAIFMT_DSP_B:\r\ncase SND_SOC_DAIFMT_AC97:\r\nmcasp_clr_bits(mcasp, DAVINCI_MCASP_TXFMCTL_REG, FSXDUR);\r\nmcasp_clr_bits(mcasp, DAVINCI_MCASP_RXFMCTL_REG, FSRDUR);\r\ndata_delay = 0;\r\nbreak;\r\ncase SND_SOC_DAIFMT_I2S:\r\nmcasp_set_bits(mcasp, DAVINCI_MCASP_TXFMCTL_REG, FSXDUR);\r\nmcasp_set_bits(mcasp, DAVINCI_MCASP_RXFMCTL_REG, FSRDUR);\r\ndata_delay = 1;\r\ninv_fs = true;\r\nbreak;\r\ncase SND_SOC_DAIFMT_LEFT_J:\r\nmcasp_set_bits(mcasp, DAVINCI_MCASP_TXFMCTL_REG, FSXDUR);\r\nmcasp_set_bits(mcasp, DAVINCI_MCASP_RXFMCTL_REG, FSRDUR);\r\ndata_delay = 0;\r\nbreak;\r\ndefault:\r\nret = -EINVAL;\r\ngoto out;\r\n}\r\nmcasp_mod_bits(mcasp, DAVINCI_MCASP_TXFMT_REG, FSXDLY(data_delay),\r\nFSXDLY(3));\r\nmcasp_mod_bits(mcasp, DAVINCI_MCASP_RXFMT_REG, FSRDLY(data_delay),\r\nFSRDLY(3));\r\nswitch (fmt & SND_SOC_DAIFMT_MASTER_MASK) {\r\ncase SND_SOC_DAIFMT_CBS_CFS:\r\nmcasp_set_bits(mcasp, DAVINCI_MCASP_ACLKXCTL_REG, ACLKXE);\r\nmcasp_set_bits(mcasp, DAVINCI_MCASP_TXFMCTL_REG, AFSXE);\r\nmcasp_set_bits(mcasp, DAVINCI_MCASP_ACLKRCTL_REG, ACLKRE);\r\nmcasp_set_bits(mcasp, DAVINCI_MCASP_RXFMCTL_REG, AFSRE);\r\nmcasp_set_bits(mcasp, DAVINCI_MCASP_PDIR_REG, ACLKX | ACLKR);\r\nmcasp_set_bits(mcasp, DAVINCI_MCASP_PDIR_REG, AFSX | AFSR);\r\nmcasp->bclk_master = 1;\r\nbreak;\r\ncase SND_SOC_DAIFMT_CBS_CFM:\r\nmcasp_set_bits(mcasp, DAVINCI_MCASP_ACLKXCTL_REG, ACLKXE);\r\nmcasp_clr_bits(mcasp, DAVINCI_MCASP_TXFMCTL_REG, AFSXE);\r\nmcasp_set_bits(mcasp, DAVINCI_MCASP_ACLKRCTL_REG, ACLKRE);\r\nmcasp_clr_bits(mcasp, DAVINCI_MCASP_RXFMCTL_REG, AFSRE);\r\nmcasp_set_bits(mcasp, DAVINCI_MCASP_PDIR_REG, ACLKX | ACLKR);\r\nmcasp_clr_bits(mcasp, DAVINCI_MCASP_PDIR_REG, AFSX | AFSR);\r\nmcasp->bclk_master = 1;\r\nbreak;\r\ncase SND_SOC_DAIFMT_CBM_CFS:\r\nmcasp_clr_bits(mcasp, DAVINCI_MCASP_ACLKXCTL_REG, ACLKXE);\r\nmcasp_set_bits(mcasp, DAVINCI_MCASP_TXFMCTL_REG, AFSXE);\r\nmcasp_clr_bits(mcasp, DAVINCI_MCASP_ACLKRCTL_REG, ACLKRE);\r\nmcasp_set_bits(mcasp, DAVINCI_MCASP_RXFMCTL_REG, AFSRE);\r\nmcasp_clr_bits(mcasp, DAVINCI_MCASP_PDIR_REG, ACLKX | ACLKR);\r\nmcasp_set_bits(mcasp, DAVINCI_MCASP_PDIR_REG, AFSX | AFSR);\r\nmcasp->bclk_master = 0;\r\nbreak;\r\ncase SND_SOC_DAIFMT_CBM_CFM:\r\nmcasp_clr_bits(mcasp, DAVINCI_MCASP_ACLKXCTL_REG, ACLKXE);\r\nmcasp_clr_bits(mcasp, DAVINCI_MCASP_TXFMCTL_REG, AFSXE);\r\nmcasp_clr_bits(mcasp, DAVINCI_MCASP_ACLKRCTL_REG, ACLKRE);\r\nmcasp_clr_bits(mcasp, DAVINCI_MCASP_RXFMCTL_REG, AFSRE);\r\nmcasp_clr_bits(mcasp, DAVINCI_MCASP_PDIR_REG,\r\nACLKX | AHCLKX | AFSX | ACLKR | AHCLKR | AFSR);\r\nmcasp->bclk_master = 0;\r\nbreak;\r\ndefault:\r\nret = -EINVAL;\r\ngoto out;\r\n}\r\nswitch (fmt & SND_SOC_DAIFMT_INV_MASK) {\r\ncase SND_SOC_DAIFMT_IB_NF:\r\nmcasp_clr_bits(mcasp, DAVINCI_MCASP_ACLKXCTL_REG, ACLKXPOL);\r\nmcasp_clr_bits(mcasp, DAVINCI_MCASP_ACLKRCTL_REG, ACLKRPOL);\r\nfs_pol_rising = true;\r\nbreak;\r\ncase SND_SOC_DAIFMT_NB_IF:\r\nmcasp_set_bits(mcasp, DAVINCI_MCASP_ACLKXCTL_REG, ACLKXPOL);\r\nmcasp_set_bits(mcasp, DAVINCI_MCASP_ACLKRCTL_REG, ACLKRPOL);\r\nfs_pol_rising = false;\r\nbreak;\r\ncase SND_SOC_DAIFMT_IB_IF:\r\nmcasp_clr_bits(mcasp, DAVINCI_MCASP_ACLKXCTL_REG, ACLKXPOL);\r\nmcasp_clr_bits(mcasp, DAVINCI_MCASP_ACLKRCTL_REG, ACLKRPOL);\r\nfs_pol_rising = false;\r\nbreak;\r\ncase SND_SOC_DAIFMT_NB_NF:\r\nmcasp_set_bits(mcasp, DAVINCI_MCASP_ACLKXCTL_REG, ACLKXPOL);\r\nmcasp_set_bits(mcasp, DAVINCI_MCASP_ACLKRCTL_REG, ACLKRPOL);\r\nfs_pol_rising = true;\r\nbreak;\r\ndefault:\r\nret = -EINVAL;\r\ngoto out;\r\n}\r\nif (inv_fs)\r\nfs_pol_rising = !fs_pol_rising;\r\nif (fs_pol_rising) {\r\nmcasp_clr_bits(mcasp, DAVINCI_MCASP_TXFMCTL_REG, FSXPOL);\r\nmcasp_clr_bits(mcasp, DAVINCI_MCASP_RXFMCTL_REG, FSRPOL);\r\n} else {\r\nmcasp_set_bits(mcasp, DAVINCI_MCASP_TXFMCTL_REG, FSXPOL);\r\nmcasp_set_bits(mcasp, DAVINCI_MCASP_RXFMCTL_REG, FSRPOL);\r\n}\r\nout:\r\npm_runtime_put(mcasp->dev);\r\nreturn ret;\r\n}\r\nstatic int __davinci_mcasp_set_clkdiv(struct snd_soc_dai *dai, int div_id,\r\nint div, bool explicit)\r\n{\r\nstruct davinci_mcasp *mcasp = snd_soc_dai_get_drvdata(dai);\r\npm_runtime_get_sync(mcasp->dev);\r\nswitch (div_id) {\r\ncase 0:\r\nmcasp_mod_bits(mcasp, DAVINCI_MCASP_AHCLKXCTL_REG,\r\nAHCLKXDIV(div - 1), AHCLKXDIV_MASK);\r\nmcasp_mod_bits(mcasp, DAVINCI_MCASP_AHCLKRCTL_REG,\r\nAHCLKRDIV(div - 1), AHCLKRDIV_MASK);\r\nbreak;\r\ncase 1:\r\nmcasp_mod_bits(mcasp, DAVINCI_MCASP_ACLKXCTL_REG,\r\nACLKXDIV(div - 1), ACLKXDIV_MASK);\r\nmcasp_mod_bits(mcasp, DAVINCI_MCASP_ACLKRCTL_REG,\r\nACLKRDIV(div - 1), ACLKRDIV_MASK);\r\nif (explicit)\r\nmcasp->bclk_div = div;\r\nbreak;\r\ncase 2:\r\nmcasp->slot_width = div / mcasp->tdm_slots;\r\nif (div % mcasp->tdm_slots)\r\ndev_warn(mcasp->dev,\r\n"%s(): BCLK/LRCLK %d is not divisible by %d tdm slots",\r\n__func__, div, mcasp->tdm_slots);\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\npm_runtime_put(mcasp->dev);\r\nreturn 0;\r\n}\r\nstatic int davinci_mcasp_set_clkdiv(struct snd_soc_dai *dai, int div_id,\r\nint div)\r\n{\r\nreturn __davinci_mcasp_set_clkdiv(dai, div_id, div, 1);\r\n}\r\nstatic int davinci_mcasp_set_sysclk(struct snd_soc_dai *dai, int clk_id,\r\nunsigned int freq, int dir)\r\n{\r\nstruct davinci_mcasp *mcasp = snd_soc_dai_get_drvdata(dai);\r\npm_runtime_get_sync(mcasp->dev);\r\nif (dir == SND_SOC_CLOCK_OUT) {\r\nmcasp_set_bits(mcasp, DAVINCI_MCASP_AHCLKXCTL_REG, AHCLKXE);\r\nmcasp_set_bits(mcasp, DAVINCI_MCASP_AHCLKRCTL_REG, AHCLKRE);\r\nmcasp_set_bits(mcasp, DAVINCI_MCASP_PDIR_REG, AHCLKX);\r\n} else {\r\nmcasp_clr_bits(mcasp, DAVINCI_MCASP_AHCLKXCTL_REG, AHCLKXE);\r\nmcasp_clr_bits(mcasp, DAVINCI_MCASP_AHCLKRCTL_REG, AHCLKRE);\r\nmcasp_clr_bits(mcasp, DAVINCI_MCASP_PDIR_REG, AHCLKX);\r\n}\r\nmcasp->sysclk_freq = freq;\r\npm_runtime_put(mcasp->dev);\r\nreturn 0;\r\n}\r\nstatic int davinci_mcasp_ch_constraint(struct davinci_mcasp *mcasp, int stream,\r\nint serializers)\r\n{\r\nstruct snd_pcm_hw_constraint_list *cl = &mcasp->chconstr[stream];\r\nunsigned int *list = (unsigned int *) cl->list;\r\nint slots = mcasp->tdm_slots;\r\nint i, count = 0;\r\nif (mcasp->tdm_mask[stream])\r\nslots = hweight32(mcasp->tdm_mask[stream]);\r\nfor (i = 2; i <= slots; i++)\r\nlist[count++] = i;\r\nfor (i = 2; i <= serializers; i++)\r\nlist[count++] = i*slots;\r\ncl->count = count;\r\nreturn 0;\r\n}\r\nstatic int davinci_mcasp_set_ch_constraints(struct davinci_mcasp *mcasp)\r\n{\r\nint rx_serializers = 0, tx_serializers = 0, ret, i;\r\nfor (i = 0; i < mcasp->num_serializer; i++)\r\nif (mcasp->serial_dir[i] == TX_MODE)\r\ntx_serializers++;\r\nelse if (mcasp->serial_dir[i] == RX_MODE)\r\nrx_serializers++;\r\nret = davinci_mcasp_ch_constraint(mcasp, SNDRV_PCM_STREAM_PLAYBACK,\r\ntx_serializers);\r\nif (ret)\r\nreturn ret;\r\nret = davinci_mcasp_ch_constraint(mcasp, SNDRV_PCM_STREAM_CAPTURE,\r\nrx_serializers);\r\nreturn ret;\r\n}\r\nstatic int davinci_mcasp_set_tdm_slot(struct snd_soc_dai *dai,\r\nunsigned int tx_mask,\r\nunsigned int rx_mask,\r\nint slots, int slot_width)\r\n{\r\nstruct davinci_mcasp *mcasp = snd_soc_dai_get_drvdata(dai);\r\ndev_dbg(mcasp->dev,\r\n"%s() tx_mask 0x%08x rx_mask 0x%08x slots %d width %d\n",\r\n__func__, tx_mask, rx_mask, slots, slot_width);\r\nif (tx_mask >= (1<<slots) || rx_mask >= (1<<slots)) {\r\ndev_err(mcasp->dev,\r\n"Bad tdm mask tx: 0x%08x rx: 0x%08x slots %d\n",\r\ntx_mask, rx_mask, slots);\r\nreturn -EINVAL;\r\n}\r\nif (slot_width &&\r\n(slot_width < 8 || slot_width > 32 || slot_width % 4 != 0)) {\r\ndev_err(mcasp->dev, "%s: Unsupported slot_width %d\n",\r\n__func__, slot_width);\r\nreturn -EINVAL;\r\n}\r\nmcasp->tdm_slots = slots;\r\nmcasp->tdm_mask[SNDRV_PCM_STREAM_PLAYBACK] = tx_mask;\r\nmcasp->tdm_mask[SNDRV_PCM_STREAM_CAPTURE] = rx_mask;\r\nmcasp->slot_width = slot_width;\r\nreturn davinci_mcasp_set_ch_constraints(mcasp);\r\n}\r\nstatic int davinci_config_channel_size(struct davinci_mcasp *mcasp,\r\nint sample_width)\r\n{\r\nu32 fmt;\r\nu32 tx_rotate = (sample_width / 4) & 0x7;\r\nu32 mask = (1ULL << sample_width) - 1;\r\nu32 slot_width = sample_width;\r\nu32 rx_rotate = 0;\r\nif (mcasp->slot_width) {\r\nslot_width = mcasp->slot_width;\r\nrx_rotate = (slot_width - sample_width) / 4;\r\n}\r\nfmt = (slot_width >> 1) - 1;\r\nif (mcasp->op_mode != DAVINCI_MCASP_DIT_MODE) {\r\nmcasp_mod_bits(mcasp, DAVINCI_MCASP_RXFMT_REG, RXSSZ(fmt),\r\nRXSSZ(0x0F));\r\nmcasp_mod_bits(mcasp, DAVINCI_MCASP_TXFMT_REG, TXSSZ(fmt),\r\nTXSSZ(0x0F));\r\nmcasp_mod_bits(mcasp, DAVINCI_MCASP_TXFMT_REG, TXROT(tx_rotate),\r\nTXROT(7));\r\nmcasp_mod_bits(mcasp, DAVINCI_MCASP_RXFMT_REG, RXROT(rx_rotate),\r\nRXROT(7));\r\nmcasp_set_reg(mcasp, DAVINCI_MCASP_RXMASK_REG, mask);\r\n}\r\nmcasp_set_reg(mcasp, DAVINCI_MCASP_TXMASK_REG, mask);\r\nreturn 0;\r\n}\r\nstatic int mcasp_common_hw_param(struct davinci_mcasp *mcasp, int stream,\r\nint period_words, int channels)\r\n{\r\nstruct snd_dmaengine_dai_dma_data *dma_data = &mcasp->dma_data[stream];\r\nint i;\r\nu8 tx_ser = 0;\r\nu8 rx_ser = 0;\r\nu8 slots = mcasp->tdm_slots;\r\nu8 max_active_serializers = (channels + slots - 1) / slots;\r\nint active_serializers, numevt;\r\nu32 reg;\r\nif (mcasp->version < MCASP_VERSION_3)\r\nmcasp_set_bits(mcasp, DAVINCI_MCASP_PWREMUMGT_REG, MCASP_SOFT);\r\nmcasp_set_reg(mcasp, DAVINCI_MCASP_PFUNC_REG, 0x00000000);\r\nif (stream == SNDRV_PCM_STREAM_PLAYBACK) {\r\nmcasp_set_reg(mcasp, DAVINCI_MCASP_TXSTAT_REG, 0xFFFFFFFF);\r\nmcasp_clr_bits(mcasp, DAVINCI_MCASP_XEVTCTL_REG, TXDATADMADIS);\r\n} else {\r\nmcasp_set_reg(mcasp, DAVINCI_MCASP_RXSTAT_REG, 0xFFFFFFFF);\r\nmcasp_clr_bits(mcasp, DAVINCI_MCASP_REVTCTL_REG, RXDATADMADIS);\r\n}\r\nfor (i = 0; i < mcasp->num_serializer; i++) {\r\nmcasp_set_bits(mcasp, DAVINCI_MCASP_XRSRCTL_REG(i),\r\nmcasp->serial_dir[i]);\r\nif (mcasp->serial_dir[i] == TX_MODE &&\r\ntx_ser < max_active_serializers) {\r\nmcasp_set_bits(mcasp, DAVINCI_MCASP_PDIR_REG, AXR(i));\r\nmcasp_mod_bits(mcasp, DAVINCI_MCASP_XRSRCTL_REG(i),\r\nDISMOD_LOW, DISMOD_MASK);\r\ntx_ser++;\r\n} else if (mcasp->serial_dir[i] == RX_MODE &&\r\nrx_ser < max_active_serializers) {\r\nmcasp_clr_bits(mcasp, DAVINCI_MCASP_PDIR_REG, AXR(i));\r\nrx_ser++;\r\n} else {\r\nmcasp_mod_bits(mcasp, DAVINCI_MCASP_XRSRCTL_REG(i),\r\nSRMOD_INACTIVE, SRMOD_MASK);\r\n}\r\n}\r\nif (stream == SNDRV_PCM_STREAM_PLAYBACK) {\r\nactive_serializers = tx_ser;\r\nnumevt = mcasp->txnumevt;\r\nreg = mcasp->fifo_base + MCASP_WFIFOCTL_OFFSET;\r\n} else {\r\nactive_serializers = rx_ser;\r\nnumevt = mcasp->rxnumevt;\r\nreg = mcasp->fifo_base + MCASP_RFIFOCTL_OFFSET;\r\n}\r\nif (active_serializers < max_active_serializers) {\r\ndev_warn(mcasp->dev, "stream has more channels (%d) than are "\r\n"enabled in mcasp (%d)\n", channels,\r\nactive_serializers * slots);\r\nreturn -EINVAL;\r\n}\r\nif (!numevt) {\r\nif (active_serializers > 1) {\r\ndma_data->maxburst = active_serializers;\r\n} else {\r\ndma_data->maxburst = 0;\r\n}\r\nreturn 0;\r\n}\r\nif (period_words % active_serializers) {\r\ndev_err(mcasp->dev, "Invalid combination of period words and "\r\n"active serializers: %d, %d\n", period_words,\r\nactive_serializers);\r\nreturn -EINVAL;\r\n}\r\nnumevt = (numevt / active_serializers) * active_serializers;\r\nwhile (period_words % numevt && numevt > 0)\r\nnumevt -= active_serializers;\r\nif (numevt <= 0)\r\nnumevt = active_serializers;\r\nmcasp_mod_bits(mcasp, reg, active_serializers, NUMDMA_MASK);\r\nmcasp_mod_bits(mcasp, reg, NUMEVT(numevt), NUMEVT_MASK);\r\nif (numevt == 1)\r\nnumevt = 0;\r\ndma_data->maxburst = numevt;\r\nreturn 0;\r\n}\r\nstatic int mcasp_i2s_hw_param(struct davinci_mcasp *mcasp, int stream,\r\nint channels)\r\n{\r\nint i, active_slots;\r\nint total_slots;\r\nint active_serializers;\r\nu32 mask = 0;\r\nu32 busel = 0;\r\ntotal_slots = mcasp->tdm_slots;\r\nif (mcasp->tdm_mask[stream]) {\r\nactive_slots = hweight32(mcasp->tdm_mask[stream]);\r\nactive_serializers = (channels + active_slots - 1) /\r\nactive_slots;\r\nif (active_serializers == 1) {\r\nactive_slots = channels;\r\nfor (i = 0; i < total_slots; i++) {\r\nif ((1 << i) & mcasp->tdm_mask[stream]) {\r\nmask |= (1 << i);\r\nif (--active_slots <= 0)\r\nbreak;\r\n}\r\n}\r\n}\r\n} else {\r\nactive_serializers = (channels + total_slots - 1) / total_slots;\r\nif (active_serializers == 1)\r\nactive_slots = channels;\r\nelse\r\nactive_slots = total_slots;\r\nfor (i = 0; i < active_slots; i++)\r\nmask |= (1 << i);\r\n}\r\nmcasp_clr_bits(mcasp, DAVINCI_MCASP_ACLKXCTL_REG, TX_ASYNC);\r\nif (!mcasp->dat_port)\r\nbusel = TXSEL;\r\nif (stream == SNDRV_PCM_STREAM_PLAYBACK) {\r\nmcasp_set_reg(mcasp, DAVINCI_MCASP_TXTDM_REG, mask);\r\nmcasp_set_bits(mcasp, DAVINCI_MCASP_TXFMT_REG, busel | TXORD);\r\nmcasp_mod_bits(mcasp, DAVINCI_MCASP_TXFMCTL_REG,\r\nFSXMOD(total_slots), FSXMOD(0x1FF));\r\n} else if (stream == SNDRV_PCM_STREAM_CAPTURE) {\r\nmcasp_set_reg(mcasp, DAVINCI_MCASP_RXTDM_REG, mask);\r\nmcasp_set_bits(mcasp, DAVINCI_MCASP_RXFMT_REG, busel | RXORD);\r\nmcasp_mod_bits(mcasp, DAVINCI_MCASP_RXFMCTL_REG,\r\nFSRMOD(total_slots), FSRMOD(0x1FF));\r\nif (mcasp_is_synchronous(mcasp) && !mcasp->channels)\r\nmcasp_mod_bits(mcasp, DAVINCI_MCASP_TXFMCTL_REG,\r\nFSXMOD(total_slots), FSXMOD(0x1FF));\r\n}\r\nreturn 0;\r\n}\r\nstatic int mcasp_dit_hw_param(struct davinci_mcasp *mcasp,\r\nunsigned int rate)\r\n{\r\nu32 cs_value = 0;\r\nu8 *cs_bytes = (u8*) &cs_value;\r\nmcasp_set_bits(mcasp, DAVINCI_MCASP_TXFMT_REG, TXROT(6) | TXSSZ(15));\r\nmcasp_set_reg(mcasp, DAVINCI_MCASP_TXFMCTL_REG, AFSXE | FSXMOD(0x180));\r\nmcasp_set_reg(mcasp, DAVINCI_MCASP_TXTDM_REG, 0xFFFFFFFF);\r\nmcasp_set_bits(mcasp, DAVINCI_MCASP_ACLKXCTL_REG, ACLKXE | TX_ASYNC);\r\nmcasp_clr_bits(mcasp, DAVINCI_MCASP_XEVTCTL_REG, TXDATADMADIS);\r\nmcasp_set_bits(mcasp, DAVINCI_MCASP_AHCLKXCTL_REG, AHCLKXDIV(3));\r\nmcasp_set_bits(mcasp, DAVINCI_MCASP_TXDITCTL_REG, DITEN);\r\ncs_bytes[0] = IEC958_AES0_CON_NOT_COPYRIGHT;\r\ncs_bytes[1] = IEC958_AES1_CON_PCM_CODER;\r\nswitch (rate) {\r\ncase 22050:\r\ncs_bytes[3] |= IEC958_AES3_CON_FS_22050;\r\nbreak;\r\ncase 24000:\r\ncs_bytes[3] |= IEC958_AES3_CON_FS_24000;\r\nbreak;\r\ncase 32000:\r\ncs_bytes[3] |= IEC958_AES3_CON_FS_32000;\r\nbreak;\r\ncase 44100:\r\ncs_bytes[3] |= IEC958_AES3_CON_FS_44100;\r\nbreak;\r\ncase 48000:\r\ncs_bytes[3] |= IEC958_AES3_CON_FS_48000;\r\nbreak;\r\ncase 88200:\r\ncs_bytes[3] |= IEC958_AES3_CON_FS_88200;\r\nbreak;\r\ncase 96000:\r\ncs_bytes[3] |= IEC958_AES3_CON_FS_96000;\r\nbreak;\r\ncase 176400:\r\ncs_bytes[3] |= IEC958_AES3_CON_FS_176400;\r\nbreak;\r\ncase 192000:\r\ncs_bytes[3] |= IEC958_AES3_CON_FS_192000;\r\nbreak;\r\ndefault:\r\nprintk(KERN_WARNING "unsupported sampling rate: %d\n", rate);\r\nreturn -EINVAL;\r\n}\r\nmcasp_set_reg(mcasp, DAVINCI_MCASP_DITCSRA_REG, cs_value);\r\nmcasp_set_reg(mcasp, DAVINCI_MCASP_DITCSRB_REG, cs_value);\r\nreturn 0;\r\n}\r\nstatic int davinci_mcasp_calc_clk_div(struct davinci_mcasp *mcasp,\r\nunsigned int bclk_freq,\r\nint *error_ppm)\r\n{\r\nint div = mcasp->sysclk_freq / bclk_freq;\r\nint rem = mcasp->sysclk_freq % bclk_freq;\r\nif (rem != 0) {\r\nif (div == 0 ||\r\n((mcasp->sysclk_freq / div) - bclk_freq) >\r\n(bclk_freq - (mcasp->sysclk_freq / (div+1)))) {\r\ndiv++;\r\nrem = rem - bclk_freq;\r\n}\r\n}\r\nif (error_ppm)\r\n*error_ppm =\r\n(div*1000000 + (int)div64_long(1000000LL*rem,\r\n(int)bclk_freq))\r\n/div - 1000000;\r\nreturn div;\r\n}\r\nstatic int davinci_mcasp_hw_params(struct snd_pcm_substream *substream,\r\nstruct snd_pcm_hw_params *params,\r\nstruct snd_soc_dai *cpu_dai)\r\n{\r\nstruct davinci_mcasp *mcasp = snd_soc_dai_get_drvdata(cpu_dai);\r\nint word_length;\r\nint channels = params_channels(params);\r\nint period_size = params_period_size(params);\r\nint ret;\r\nif (mcasp->bclk_master && mcasp->bclk_div == 0 && mcasp->sysclk_freq) {\r\nint slots = mcasp->tdm_slots;\r\nint rate = params_rate(params);\r\nint sbits = params_width(params);\r\nint ppm, div;\r\nif (mcasp->slot_width)\r\nsbits = mcasp->slot_width;\r\ndiv = davinci_mcasp_calc_clk_div(mcasp, rate*sbits*slots,\r\n&ppm);\r\nif (ppm)\r\ndev_info(mcasp->dev, "Sample-rate is off by %d PPM\n",\r\nppm);\r\n__davinci_mcasp_set_clkdiv(cpu_dai, 1, div, 0);\r\n}\r\nret = mcasp_common_hw_param(mcasp, substream->stream,\r\nperiod_size * channels, channels);\r\nif (ret)\r\nreturn ret;\r\nif (mcasp->op_mode == DAVINCI_MCASP_DIT_MODE)\r\nret = mcasp_dit_hw_param(mcasp, params_rate(params));\r\nelse\r\nret = mcasp_i2s_hw_param(mcasp, substream->stream,\r\nchannels);\r\nif (ret)\r\nreturn ret;\r\nswitch (params_format(params)) {\r\ncase SNDRV_PCM_FORMAT_U8:\r\ncase SNDRV_PCM_FORMAT_S8:\r\nword_length = 8;\r\nbreak;\r\ncase SNDRV_PCM_FORMAT_U16_LE:\r\ncase SNDRV_PCM_FORMAT_S16_LE:\r\nword_length = 16;\r\nbreak;\r\ncase SNDRV_PCM_FORMAT_U24_3LE:\r\ncase SNDRV_PCM_FORMAT_S24_3LE:\r\nword_length = 24;\r\nbreak;\r\ncase SNDRV_PCM_FORMAT_U24_LE:\r\ncase SNDRV_PCM_FORMAT_S24_LE:\r\nword_length = 24;\r\nbreak;\r\ncase SNDRV_PCM_FORMAT_U32_LE:\r\ncase SNDRV_PCM_FORMAT_S32_LE:\r\nword_length = 32;\r\nbreak;\r\ndefault:\r\nprintk(KERN_WARNING "davinci-mcasp: unsupported PCM format");\r\nreturn -EINVAL;\r\n}\r\ndavinci_config_channel_size(mcasp, word_length);\r\nif (mcasp->op_mode == DAVINCI_MCASP_IIS_MODE)\r\nmcasp->channels = channels;\r\nreturn 0;\r\n}\r\nstatic int davinci_mcasp_trigger(struct snd_pcm_substream *substream,\r\nint cmd, struct snd_soc_dai *cpu_dai)\r\n{\r\nstruct davinci_mcasp *mcasp = snd_soc_dai_get_drvdata(cpu_dai);\r\nint ret = 0;\r\nswitch (cmd) {\r\ncase SNDRV_PCM_TRIGGER_RESUME:\r\ncase SNDRV_PCM_TRIGGER_START:\r\ncase SNDRV_PCM_TRIGGER_PAUSE_RELEASE:\r\ndavinci_mcasp_start(mcasp, substream->stream);\r\nbreak;\r\ncase SNDRV_PCM_TRIGGER_SUSPEND:\r\ncase SNDRV_PCM_TRIGGER_STOP:\r\ncase SNDRV_PCM_TRIGGER_PAUSE_PUSH:\r\ndavinci_mcasp_stop(mcasp, substream->stream);\r\nbreak;\r\ndefault:\r\nret = -EINVAL;\r\n}\r\nreturn ret;\r\n}\r\nstatic int davinci_mcasp_hw_rule_rate(struct snd_pcm_hw_params *params,\r\nstruct snd_pcm_hw_rule *rule)\r\n{\r\nstruct davinci_mcasp_ruledata *rd = rule->private;\r\nstruct snd_interval *ri =\r\nhw_param_interval(params, SNDRV_PCM_HW_PARAM_RATE);\r\nint sbits = params_width(params);\r\nint slots = rd->mcasp->tdm_slots;\r\nstruct snd_interval range;\r\nint i;\r\nif (rd->mcasp->slot_width)\r\nsbits = rd->mcasp->slot_width;\r\nsnd_interval_any(&range);\r\nrange.empty = 1;\r\nfor (i = 0; i < ARRAY_SIZE(davinci_mcasp_dai_rates); i++) {\r\nif (snd_interval_test(ri, davinci_mcasp_dai_rates[i])) {\r\nuint bclk_freq = sbits*slots*\r\ndavinci_mcasp_dai_rates[i];\r\nint ppm;\r\ndavinci_mcasp_calc_clk_div(rd->mcasp, bclk_freq, &ppm);\r\nif (abs(ppm) < DAVINCI_MAX_RATE_ERROR_PPM) {\r\nif (range.empty) {\r\nrange.min = davinci_mcasp_dai_rates[i];\r\nrange.empty = 0;\r\n}\r\nrange.max = davinci_mcasp_dai_rates[i];\r\n}\r\n}\r\n}\r\ndev_dbg(rd->mcasp->dev,\r\n"Frequencies %d-%d -> %d-%d for %d sbits and %d tdm slots\n",\r\nri->min, ri->max, range.min, range.max, sbits, slots);\r\nreturn snd_interval_refine(hw_param_interval(params, rule->var),\r\n&range);\r\n}\r\nstatic int davinci_mcasp_hw_rule_format(struct snd_pcm_hw_params *params,\r\nstruct snd_pcm_hw_rule *rule)\r\n{\r\nstruct davinci_mcasp_ruledata *rd = rule->private;\r\nstruct snd_mask *fmt = hw_param_mask(params, SNDRV_PCM_HW_PARAM_FORMAT);\r\nstruct snd_mask nfmt;\r\nint rate = params_rate(params);\r\nint slots = rd->mcasp->tdm_slots;\r\nint i, count = 0;\r\nsnd_mask_none(&nfmt);\r\nfor (i = 0; i < SNDRV_PCM_FORMAT_LAST; i++) {\r\nif (snd_mask_test(fmt, i)) {\r\nuint sbits = snd_pcm_format_width(i);\r\nint ppm;\r\nif (rd->mcasp->slot_width)\r\nsbits = rd->mcasp->slot_width;\r\ndavinci_mcasp_calc_clk_div(rd->mcasp, sbits*slots*rate,\r\n&ppm);\r\nif (abs(ppm) < DAVINCI_MAX_RATE_ERROR_PPM) {\r\nsnd_mask_set(&nfmt, i);\r\ncount++;\r\n}\r\n}\r\n}\r\ndev_dbg(rd->mcasp->dev,\r\n"%d possible sample format for %d Hz and %d tdm slots\n",\r\ncount, rate, slots);\r\nreturn snd_mask_refine(fmt, &nfmt);\r\n}\r\nstatic int davinci_mcasp_startup(struct snd_pcm_substream *substream,\r\nstruct snd_soc_dai *cpu_dai)\r\n{\r\nstruct davinci_mcasp *mcasp = snd_soc_dai_get_drvdata(cpu_dai);\r\nstruct davinci_mcasp_ruledata *ruledata =\r\n&mcasp->ruledata[substream->stream];\r\nu32 max_channels = 0;\r\nint i, dir;\r\nint tdm_slots = mcasp->tdm_slots;\r\nif (mcasp->tdm_mask[substream->stream])\r\ntdm_slots = hweight32(mcasp->tdm_mask[substream->stream]);\r\nmcasp->substreams[substream->stream] = substream;\r\nif (mcasp->op_mode == DAVINCI_MCASP_DIT_MODE)\r\nreturn 0;\r\nif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)\r\ndir = TX_MODE;\r\nelse\r\ndir = RX_MODE;\r\nfor (i = 0; i < mcasp->num_serializer; i++) {\r\nif (mcasp->serial_dir[i] == dir)\r\nmax_channels++;\r\n}\r\nruledata->serializers = max_channels;\r\nmax_channels *= tdm_slots;\r\nif (mcasp->channels && mcasp->channels < max_channels)\r\nmax_channels = mcasp->channels;\r\nif (max_channels < tdm_slots)\r\nmax_channels = tdm_slots;\r\nsnd_pcm_hw_constraint_minmax(substream->runtime,\r\nSNDRV_PCM_HW_PARAM_CHANNELS,\r\n2, max_channels);\r\nsnd_pcm_hw_constraint_list(substream->runtime,\r\n0, SNDRV_PCM_HW_PARAM_CHANNELS,\r\n&mcasp->chconstr[substream->stream]);\r\nif (mcasp->slot_width)\r\nsnd_pcm_hw_constraint_minmax(substream->runtime,\r\nSNDRV_PCM_HW_PARAM_SAMPLE_BITS,\r\n8, mcasp->slot_width);\r\nif (mcasp->bclk_master && mcasp->bclk_div == 0 && mcasp->sysclk_freq) {\r\nint ret;\r\nruledata->mcasp = mcasp;\r\nret = snd_pcm_hw_rule_add(substream->runtime, 0,\r\nSNDRV_PCM_HW_PARAM_RATE,\r\ndavinci_mcasp_hw_rule_rate,\r\nruledata,\r\nSNDRV_PCM_HW_PARAM_FORMAT, -1);\r\nif (ret)\r\nreturn ret;\r\nret = snd_pcm_hw_rule_add(substream->runtime, 0,\r\nSNDRV_PCM_HW_PARAM_FORMAT,\r\ndavinci_mcasp_hw_rule_format,\r\nruledata,\r\nSNDRV_PCM_HW_PARAM_RATE, -1);\r\nif (ret)\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic void davinci_mcasp_shutdown(struct snd_pcm_substream *substream,\r\nstruct snd_soc_dai *cpu_dai)\r\n{\r\nstruct davinci_mcasp *mcasp = snd_soc_dai_get_drvdata(cpu_dai);\r\nmcasp->substreams[substream->stream] = NULL;\r\nif (mcasp->op_mode == DAVINCI_MCASP_DIT_MODE)\r\nreturn;\r\nif (!cpu_dai->active)\r\nmcasp->channels = 0;\r\n}\r\nstatic int davinci_mcasp_dai_probe(struct snd_soc_dai *dai)\r\n{\r\nstruct davinci_mcasp *mcasp = snd_soc_dai_get_drvdata(dai);\r\ndai->playback_dma_data = &mcasp->dma_data[SNDRV_PCM_STREAM_PLAYBACK];\r\ndai->capture_dma_data = &mcasp->dma_data[SNDRV_PCM_STREAM_CAPTURE];\r\nreturn 0;\r\n}\r\nstatic int davinci_mcasp_suspend(struct snd_soc_dai *dai)\r\n{\r\nstruct davinci_mcasp *mcasp = snd_soc_dai_get_drvdata(dai);\r\nstruct davinci_mcasp_context *context = &mcasp->context;\r\nu32 reg;\r\nint i;\r\ncontext->pm_state = pm_runtime_active(mcasp->dev);\r\nif (!context->pm_state)\r\npm_runtime_get_sync(mcasp->dev);\r\nfor (i = 0; i < ARRAY_SIZE(context_regs); i++)\r\ncontext->config_regs[i] = mcasp_get_reg(mcasp, context_regs[i]);\r\nif (mcasp->txnumevt) {\r\nreg = mcasp->fifo_base + MCASP_WFIFOCTL_OFFSET;\r\ncontext->afifo_regs[0] = mcasp_get_reg(mcasp, reg);\r\n}\r\nif (mcasp->rxnumevt) {\r\nreg = mcasp->fifo_base + MCASP_RFIFOCTL_OFFSET;\r\ncontext->afifo_regs[1] = mcasp_get_reg(mcasp, reg);\r\n}\r\nfor (i = 0; i < mcasp->num_serializer; i++)\r\ncontext->xrsr_regs[i] = mcasp_get_reg(mcasp,\r\nDAVINCI_MCASP_XRSRCTL_REG(i));\r\npm_runtime_put_sync(mcasp->dev);\r\nreturn 0;\r\n}\r\nstatic int davinci_mcasp_resume(struct snd_soc_dai *dai)\r\n{\r\nstruct davinci_mcasp *mcasp = snd_soc_dai_get_drvdata(dai);\r\nstruct davinci_mcasp_context *context = &mcasp->context;\r\nu32 reg;\r\nint i;\r\npm_runtime_get_sync(mcasp->dev);\r\nfor (i = 0; i < ARRAY_SIZE(context_regs); i++)\r\nmcasp_set_reg(mcasp, context_regs[i], context->config_regs[i]);\r\nif (mcasp->txnumevt) {\r\nreg = mcasp->fifo_base + MCASP_WFIFOCTL_OFFSET;\r\nmcasp_set_reg(mcasp, reg, context->afifo_regs[0]);\r\n}\r\nif (mcasp->rxnumevt) {\r\nreg = mcasp->fifo_base + MCASP_RFIFOCTL_OFFSET;\r\nmcasp_set_reg(mcasp, reg, context->afifo_regs[1]);\r\n}\r\nfor (i = 0; i < mcasp->num_serializer; i++)\r\nmcasp_set_reg(mcasp, DAVINCI_MCASP_XRSRCTL_REG(i),\r\ncontext->xrsr_regs[i]);\r\nif (!context->pm_state)\r\npm_runtime_put_sync(mcasp->dev);\r\nreturn 0;\r\n}\r\nstatic int mcasp_reparent_fck(struct platform_device *pdev)\r\n{\r\nstruct device_node *node = pdev->dev.of_node;\r\nstruct clk *gfclk, *parent_clk;\r\nconst char *parent_name;\r\nint ret;\r\nif (!node)\r\nreturn 0;\r\nparent_name = of_get_property(node, "fck_parent", NULL);\r\nif (!parent_name)\r\nreturn 0;\r\ngfclk = clk_get(&pdev->dev, "fck");\r\nif (IS_ERR(gfclk)) {\r\ndev_err(&pdev->dev, "failed to get fck\n");\r\nreturn PTR_ERR(gfclk);\r\n}\r\nparent_clk = clk_get(NULL, parent_name);\r\nif (IS_ERR(parent_clk)) {\r\ndev_err(&pdev->dev, "failed to get parent clock\n");\r\nret = PTR_ERR(parent_clk);\r\ngoto err1;\r\n}\r\nret = clk_set_parent(gfclk, parent_clk);\r\nif (ret) {\r\ndev_err(&pdev->dev, "failed to reparent fck\n");\r\ngoto err2;\r\n}\r\nerr2:\r\nclk_put(parent_clk);\r\nerr1:\r\nclk_put(gfclk);\r\nreturn ret;\r\n}\r\nstatic struct davinci_mcasp_pdata *davinci_mcasp_set_pdata_from_of(\r\nstruct platform_device *pdev)\r\n{\r\nstruct device_node *np = pdev->dev.of_node;\r\nstruct davinci_mcasp_pdata *pdata = NULL;\r\nconst struct of_device_id *match =\r\nof_match_device(mcasp_dt_ids, &pdev->dev);\r\nstruct of_phandle_args dma_spec;\r\nconst u32 *of_serial_dir32;\r\nu32 val;\r\nint i, ret = 0;\r\nif (pdev->dev.platform_data) {\r\npdata = pdev->dev.platform_data;\r\nreturn pdata;\r\n} else if (match) {\r\npdata = (struct davinci_mcasp_pdata*) match->data;\r\n} else {\r\nret = -EINVAL;\r\ngoto nodata;\r\n}\r\nret = of_property_read_u32(np, "op-mode", &val);\r\nif (ret >= 0)\r\npdata->op_mode = val;\r\nret = of_property_read_u32(np, "tdm-slots", &val);\r\nif (ret >= 0) {\r\nif (val < 2 || val > 32) {\r\ndev_err(&pdev->dev,\r\n"tdm-slots must be in rage [2-32]\n");\r\nret = -EINVAL;\r\ngoto nodata;\r\n}\r\npdata->tdm_slots = val;\r\n}\r\nof_serial_dir32 = of_get_property(np, "serial-dir", &val);\r\nval /= sizeof(u32);\r\nif (of_serial_dir32) {\r\nu8 *of_serial_dir = devm_kzalloc(&pdev->dev,\r\n(sizeof(*of_serial_dir) * val),\r\nGFP_KERNEL);\r\nif (!of_serial_dir) {\r\nret = -ENOMEM;\r\ngoto nodata;\r\n}\r\nfor (i = 0; i < val; i++)\r\nof_serial_dir[i] = be32_to_cpup(&of_serial_dir32[i]);\r\npdata->num_serializer = val;\r\npdata->serial_dir = of_serial_dir;\r\n}\r\nret = of_property_match_string(np, "dma-names", "tx");\r\nif (ret < 0)\r\ngoto nodata;\r\nret = of_parse_phandle_with_args(np, "dmas", "#dma-cells", ret,\r\n&dma_spec);\r\nif (ret < 0)\r\ngoto nodata;\r\npdata->tx_dma_channel = dma_spec.args[0];\r\nif (pdata->op_mode != DAVINCI_MCASP_DIT_MODE) {\r\nret = of_property_match_string(np, "dma-names", "rx");\r\nif (ret < 0)\r\ngoto nodata;\r\nret = of_parse_phandle_with_args(np, "dmas", "#dma-cells", ret,\r\n&dma_spec);\r\nif (ret < 0)\r\ngoto nodata;\r\npdata->rx_dma_channel = dma_spec.args[0];\r\n}\r\nret = of_property_read_u32(np, "tx-num-evt", &val);\r\nif (ret >= 0)\r\npdata->txnumevt = val;\r\nret = of_property_read_u32(np, "rx-num-evt", &val);\r\nif (ret >= 0)\r\npdata->rxnumevt = val;\r\nret = of_property_read_u32(np, "sram-size-playback", &val);\r\nif (ret >= 0)\r\npdata->sram_size_playback = val;\r\nret = of_property_read_u32(np, "sram-size-capture", &val);\r\nif (ret >= 0)\r\npdata->sram_size_capture = val;\r\nreturn pdata;\r\nnodata:\r\nif (ret < 0) {\r\ndev_err(&pdev->dev, "Error populating platform data, err %d\n",\r\nret);\r\npdata = NULL;\r\n}\r\nreturn pdata;\r\n}\r\nstatic int davinci_mcasp_get_dma_type(struct davinci_mcasp *mcasp)\r\n{\r\nstruct dma_chan *chan;\r\nconst char *tmp;\r\nint ret = PCM_EDMA;\r\nif (!mcasp->dev->of_node)\r\nreturn PCM_EDMA;\r\ntmp = mcasp->dma_data[SNDRV_PCM_STREAM_PLAYBACK].filter_data;\r\nchan = dma_request_slave_channel_reason(mcasp->dev, tmp);\r\nif (IS_ERR(chan)) {\r\nif (PTR_ERR(chan) != -EPROBE_DEFER)\r\ndev_err(mcasp->dev,\r\n"Can't verify DMA configuration (%ld)\n",\r\nPTR_ERR(chan));\r\nreturn PTR_ERR(chan);\r\n}\r\nBUG_ON(!chan->device || !chan->device->dev);\r\nif (chan->device->dev->of_node)\r\nret = of_property_read_string(chan->device->dev->of_node,\r\n"compatible", &tmp);\r\nelse\r\ndev_dbg(mcasp->dev, "DMA controller has no of-node\n");\r\ndma_release_channel(chan);\r\nif (ret)\r\nreturn ret;\r\ndev_dbg(mcasp->dev, "DMA controller compatible = \"%s\"\n", tmp);\r\nif (!strncmp(tmp, sdma_prefix, strlen(sdma_prefix)))\r\nreturn PCM_SDMA;\r\nreturn PCM_EDMA;\r\n}\r\nstatic int davinci_mcasp_probe(struct platform_device *pdev)\r\n{\r\nstruct snd_dmaengine_dai_dma_data *dma_data;\r\nstruct resource *mem, *res, *dat;\r\nstruct davinci_mcasp_pdata *pdata;\r\nstruct davinci_mcasp *mcasp;\r\nchar *irq_name;\r\nint *dma;\r\nint irq;\r\nint ret;\r\nif (!pdev->dev.platform_data && !pdev->dev.of_node) {\r\ndev_err(&pdev->dev, "No platform data supplied\n");\r\nreturn -EINVAL;\r\n}\r\nmcasp = devm_kzalloc(&pdev->dev, sizeof(struct davinci_mcasp),\r\nGFP_KERNEL);\r\nif (!mcasp)\r\nreturn -ENOMEM;\r\npdata = davinci_mcasp_set_pdata_from_of(pdev);\r\nif (!pdata) {\r\ndev_err(&pdev->dev, "no platform data\n");\r\nreturn -EINVAL;\r\n}\r\nmem = platform_get_resource_byname(pdev, IORESOURCE_MEM, "mpu");\r\nif (!mem) {\r\ndev_warn(mcasp->dev,\r\n"\"mpu\" mem resource not found, using index 0\n");\r\nmem = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nif (!mem) {\r\ndev_err(&pdev->dev, "no mem resource?\n");\r\nreturn -ENODEV;\r\n}\r\n}\r\nmcasp->base = devm_ioremap_resource(&pdev->dev, mem);\r\nif (IS_ERR(mcasp->base))\r\nreturn PTR_ERR(mcasp->base);\r\npm_runtime_enable(&pdev->dev);\r\nmcasp->op_mode = pdata->op_mode;\r\nif (mcasp->op_mode == DAVINCI_MCASP_IIS_MODE) {\r\nif (pdata->tdm_slots < 2) {\r\ndev_err(&pdev->dev, "invalid tdm slots: %d\n",\r\npdata->tdm_slots);\r\nmcasp->tdm_slots = 2;\r\n} else if (pdata->tdm_slots > 32) {\r\ndev_err(&pdev->dev, "invalid tdm slots: %d\n",\r\npdata->tdm_slots);\r\nmcasp->tdm_slots = 32;\r\n} else {\r\nmcasp->tdm_slots = pdata->tdm_slots;\r\n}\r\n}\r\nmcasp->num_serializer = pdata->num_serializer;\r\n#ifdef CONFIG_PM_SLEEP\r\nmcasp->context.xrsr_regs = devm_kzalloc(&pdev->dev,\r\nsizeof(u32) * mcasp->num_serializer,\r\nGFP_KERNEL);\r\n#endif\r\nmcasp->serial_dir = pdata->serial_dir;\r\nmcasp->version = pdata->version;\r\nmcasp->txnumevt = pdata->txnumevt;\r\nmcasp->rxnumevt = pdata->rxnumevt;\r\nmcasp->dev = &pdev->dev;\r\nirq = platform_get_irq_byname(pdev, "common");\r\nif (irq >= 0) {\r\nirq_name = devm_kasprintf(&pdev->dev, GFP_KERNEL, "%s_common",\r\ndev_name(&pdev->dev));\r\nret = devm_request_threaded_irq(&pdev->dev, irq, NULL,\r\ndavinci_mcasp_common_irq_handler,\r\nIRQF_ONESHOT | IRQF_SHARED,\r\nirq_name, mcasp);\r\nif (ret) {\r\ndev_err(&pdev->dev, "common IRQ request failed\n");\r\ngoto err;\r\n}\r\nmcasp->irq_request[SNDRV_PCM_STREAM_PLAYBACK] = XUNDRN;\r\nmcasp->irq_request[SNDRV_PCM_STREAM_CAPTURE] = ROVRN;\r\n}\r\nirq = platform_get_irq_byname(pdev, "rx");\r\nif (irq >= 0) {\r\nirq_name = devm_kasprintf(&pdev->dev, GFP_KERNEL, "%s_rx",\r\ndev_name(&pdev->dev));\r\nret = devm_request_threaded_irq(&pdev->dev, irq, NULL,\r\ndavinci_mcasp_rx_irq_handler,\r\nIRQF_ONESHOT, irq_name, mcasp);\r\nif (ret) {\r\ndev_err(&pdev->dev, "RX IRQ request failed\n");\r\ngoto err;\r\n}\r\nmcasp->irq_request[SNDRV_PCM_STREAM_CAPTURE] = ROVRN;\r\n}\r\nirq = platform_get_irq_byname(pdev, "tx");\r\nif (irq >= 0) {\r\nirq_name = devm_kasprintf(&pdev->dev, GFP_KERNEL, "%s_tx",\r\ndev_name(&pdev->dev));\r\nret = devm_request_threaded_irq(&pdev->dev, irq, NULL,\r\ndavinci_mcasp_tx_irq_handler,\r\nIRQF_ONESHOT, irq_name, mcasp);\r\nif (ret) {\r\ndev_err(&pdev->dev, "TX IRQ request failed\n");\r\ngoto err;\r\n}\r\nmcasp->irq_request[SNDRV_PCM_STREAM_PLAYBACK] = XUNDRN;\r\n}\r\ndat = platform_get_resource_byname(pdev, IORESOURCE_MEM, "dat");\r\nif (dat)\r\nmcasp->dat_port = true;\r\ndma_data = &mcasp->dma_data[SNDRV_PCM_STREAM_PLAYBACK];\r\nif (dat)\r\ndma_data->addr = dat->start;\r\nelse\r\ndma_data->addr = mem->start + pdata->tx_dma_offset;\r\ndma = &mcasp->dma_request[SNDRV_PCM_STREAM_PLAYBACK];\r\nres = platform_get_resource(pdev, IORESOURCE_DMA, 0);\r\nif (res)\r\n*dma = res->start;\r\nelse\r\n*dma = pdata->tx_dma_channel;\r\nif (pdev->dev.of_node)\r\ndma_data->filter_data = "tx";\r\nelse\r\ndma_data->filter_data = dma;\r\nif (mcasp->op_mode != DAVINCI_MCASP_DIT_MODE) {\r\ndma_data = &mcasp->dma_data[SNDRV_PCM_STREAM_CAPTURE];\r\nif (dat)\r\ndma_data->addr = dat->start;\r\nelse\r\ndma_data->addr = mem->start + pdata->rx_dma_offset;\r\ndma = &mcasp->dma_request[SNDRV_PCM_STREAM_CAPTURE];\r\nres = platform_get_resource(pdev, IORESOURCE_DMA, 1);\r\nif (res)\r\n*dma = res->start;\r\nelse\r\n*dma = pdata->rx_dma_channel;\r\nif (pdev->dev.of_node)\r\ndma_data->filter_data = "rx";\r\nelse\r\ndma_data->filter_data = dma;\r\n}\r\nif (mcasp->version < MCASP_VERSION_3) {\r\nmcasp->fifo_base = DAVINCI_MCASP_V2_AFIFO_BASE;\r\nmcasp->dat_port = true;\r\n} else {\r\nmcasp->fifo_base = DAVINCI_MCASP_V3_AFIFO_BASE;\r\n}\r\nmcasp->chconstr[SNDRV_PCM_STREAM_PLAYBACK].list =\r\ndevm_kzalloc(mcasp->dev, sizeof(unsigned int) *\r\n(32 + mcasp->num_serializer - 2),\r\nGFP_KERNEL);\r\nmcasp->chconstr[SNDRV_PCM_STREAM_CAPTURE].list =\r\ndevm_kzalloc(mcasp->dev, sizeof(unsigned int) *\r\n(32 + mcasp->num_serializer - 2),\r\nGFP_KERNEL);\r\nif (!mcasp->chconstr[SNDRV_PCM_STREAM_PLAYBACK].list ||\r\n!mcasp->chconstr[SNDRV_PCM_STREAM_CAPTURE].list)\r\nreturn -ENOMEM;\r\nret = davinci_mcasp_set_ch_constraints(mcasp);\r\nif (ret)\r\ngoto err;\r\ndev_set_drvdata(&pdev->dev, mcasp);\r\nmcasp_reparent_fck(pdev);\r\nret = devm_snd_soc_register_component(&pdev->dev,\r\n&davinci_mcasp_component,\r\n&davinci_mcasp_dai[pdata->op_mode], 1);\r\nif (ret != 0)\r\ngoto err;\r\nret = davinci_mcasp_get_dma_type(mcasp);\r\nswitch (ret) {\r\ncase PCM_EDMA:\r\n#if IS_BUILTIN(CONFIG_SND_EDMA_SOC) || \\r\n(IS_MODULE(CONFIG_SND_DAVINCI_SOC_MCASP) && \\r\nIS_MODULE(CONFIG_SND_EDMA_SOC))\r\nret = edma_pcm_platform_register(&pdev->dev);\r\n#else\r\ndev_err(&pdev->dev, "Missing SND_EDMA_SOC\n");\r\nret = -EINVAL;\r\ngoto err;\r\n#endif\r\nbreak;\r\ncase PCM_SDMA:\r\n#if IS_BUILTIN(CONFIG_SND_OMAP_SOC) || \\r\n(IS_MODULE(CONFIG_SND_DAVINCI_SOC_MCASP) && \\r\nIS_MODULE(CONFIG_SND_OMAP_SOC))\r\nret = omap_pcm_platform_register(&pdev->dev);\r\n#else\r\ndev_err(&pdev->dev, "Missing SND_SDMA_SOC\n");\r\nret = -EINVAL;\r\ngoto err;\r\n#endif\r\nbreak;\r\ndefault:\r\ndev_err(&pdev->dev, "No DMA controller found (%d)\n", ret);\r\ncase -EPROBE_DEFER:\r\ngoto err;\r\nbreak;\r\n}\r\nif (ret) {\r\ndev_err(&pdev->dev, "register PCM failed: %d\n", ret);\r\ngoto err;\r\n}\r\nreturn 0;\r\nerr:\r\npm_runtime_disable(&pdev->dev);\r\nreturn ret;\r\n}\r\nstatic int davinci_mcasp_remove(struct platform_device *pdev)\r\n{\r\npm_runtime_disable(&pdev->dev);\r\nreturn 0;\r\n}
