static unsigned long dma_find_base(unsigned int chan)\r\n{\r\nunsigned long base = SH_DMAC_BASE0;\r\n#ifdef SH_DMAC_BASE1\r\nif (chan >= 6)\r\nbase = SH_DMAC_BASE1;\r\n#endif\r\nreturn base;\r\n}\r\nstatic unsigned long dma_base_addr(unsigned int chan)\r\n{\r\nunsigned long base = dma_find_base(chan);\r\nif (chan >= 9)\r\nchan -= 6;\r\nif (chan >= 4)\r\nbase += 0x10;\r\nreturn base + (chan * 0x10);\r\n}\r\nstatic inline unsigned int get_dmte_irq(unsigned int chan)\r\n{\r\nreturn chan >= 6 ? DMTE6_IRQ : DMTE0_IRQ;\r\n}\r\nstatic inline unsigned int get_dmte_irq(unsigned int chan)\r\n{\r\nreturn dmte_irq_map[chan];\r\n}\r\nstatic inline unsigned int calc_xmit_shift(struct dma_channel *chan)\r\n{\r\nu32 chcr = __raw_readl(dma_base_addr(chan->chan) + CHCR);\r\nint cnt = ((chcr & CHCR_TS_LOW_MASK) >> CHCR_TS_LOW_SHIFT) |\r\n((chcr & CHCR_TS_HIGH_MASK) >> CHCR_TS_HIGH_SHIFT);\r\nreturn ts_shift[cnt];\r\n}\r\nstatic irqreturn_t dma_tei(int irq, void *dev_id)\r\n{\r\nstruct dma_channel *chan = dev_id;\r\nu32 chcr;\r\nchcr = __raw_readl(dma_base_addr(chan->chan) + CHCR);\r\nif (!(chcr & CHCR_TE))\r\nreturn IRQ_NONE;\r\nchcr &= ~(CHCR_IE | CHCR_DE);\r\n__raw_writel(chcr, (dma_base_addr(chan->chan) + CHCR));\r\nwake_up(&chan->wait_queue);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int sh_dmac_request_dma(struct dma_channel *chan)\r\n{\r\nif (unlikely(!(chan->flags & DMA_TEI_CAPABLE)))\r\nreturn 0;\r\nreturn request_irq(get_dmte_irq(chan->chan), dma_tei, IRQF_SHARED,\r\nchan->dev_id, chan);\r\n}\r\nstatic void sh_dmac_free_dma(struct dma_channel *chan)\r\n{\r\nfree_irq(get_dmte_irq(chan->chan), chan);\r\n}\r\nstatic int\r\nsh_dmac_configure_channel(struct dma_channel *chan, unsigned long chcr)\r\n{\r\nif (!chcr)\r\nchcr = RS_DUAL | CHCR_IE;\r\nif (chcr & CHCR_IE) {\r\nchcr &= ~CHCR_IE;\r\nchan->flags |= DMA_TEI_CAPABLE;\r\n} else {\r\nchan->flags &= ~DMA_TEI_CAPABLE;\r\n}\r\n__raw_writel(chcr, (dma_base_addr(chan->chan) + CHCR));\r\nchan->flags |= DMA_CONFIGURED;\r\nreturn 0;\r\n}\r\nstatic void sh_dmac_enable_dma(struct dma_channel *chan)\r\n{\r\nint irq;\r\nu32 chcr;\r\nchcr = __raw_readl(dma_base_addr(chan->chan) + CHCR);\r\nchcr |= CHCR_DE;\r\nif (chan->flags & DMA_TEI_CAPABLE)\r\nchcr |= CHCR_IE;\r\n__raw_writel(chcr, (dma_base_addr(chan->chan) + CHCR));\r\nif (chan->flags & DMA_TEI_CAPABLE) {\r\nirq = get_dmte_irq(chan->chan);\r\nenable_irq(irq);\r\n}\r\n}\r\nstatic void sh_dmac_disable_dma(struct dma_channel *chan)\r\n{\r\nint irq;\r\nu32 chcr;\r\nif (chan->flags & DMA_TEI_CAPABLE) {\r\nirq = get_dmte_irq(chan->chan);\r\ndisable_irq(irq);\r\n}\r\nchcr = __raw_readl(dma_base_addr(chan->chan) + CHCR);\r\nchcr &= ~(CHCR_DE | CHCR_TE | CHCR_IE);\r\n__raw_writel(chcr, (dma_base_addr(chan->chan) + CHCR));\r\n}\r\nstatic int sh_dmac_xfer_dma(struct dma_channel *chan)\r\n{\r\nif (unlikely(!(chan->flags & DMA_CONFIGURED)))\r\nsh_dmac_configure_channel(chan, 0);\r\nsh_dmac_disable_dma(chan);\r\nif (chan->sar || (mach_is_dreamcast() &&\r\nchan->chan == PVR2_CASCADE_CHAN))\r\n__raw_writel(chan->sar, (dma_base_addr(chan->chan) + SAR));\r\nif (chan->dar || (mach_is_dreamcast() &&\r\nchan->chan == PVR2_CASCADE_CHAN))\r\n__raw_writel(chan->dar, (dma_base_addr(chan->chan) + DAR));\r\n__raw_writel(chan->count >> calc_xmit_shift(chan),\r\n(dma_base_addr(chan->chan) + TCR));\r\nsh_dmac_enable_dma(chan);\r\nreturn 0;\r\n}\r\nstatic int sh_dmac_get_dma_residue(struct dma_channel *chan)\r\n{\r\nif (!(__raw_readl(dma_base_addr(chan->chan) + CHCR) & CHCR_DE))\r\nreturn 0;\r\nreturn __raw_readl(dma_base_addr(chan->chan) + TCR)\r\n<< calc_xmit_shift(chan);\r\n}\r\nstatic inline int dmaor_reset(int no)\r\n{\r\nunsigned long dmaor = dmaor_read_reg(no);\r\ndmaor &= ~(DMAOR_NMIF | DMAOR_AE);\r\ndmaor_write_reg(no, dmaor);\r\ndmaor |= DMAOR_INIT;\r\ndmaor_write_reg(no, dmaor);\r\nif ((dmaor_read_reg(no) & (DMAOR_AE | DMAOR_NMIF))) {\r\nprintk(KERN_ERR "dma-sh: Can't initialize DMAOR.\n");\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic inline unsigned int get_dma_error_irq(int n)\r\n{\r\nreturn get_dmte_irq(n * 6);\r\n}\r\nstatic inline unsigned int get_dma_error_irq(int n)\r\n{\r\nreturn dmae_irq_map[n];\r\n}\r\nstatic irqreturn_t dma_err(int irq, void *dummy)\r\n{\r\nint i;\r\nfor (i = 0; i < NR_DMAOR; i++)\r\ndmaor_reset(i);\r\ndisable_irq(irq);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int dmae_irq_init(void)\r\n{\r\nint n;\r\nfor (n = 0; n < NR_DMAE; n++) {\r\nint i = request_irq(get_dma_error_irq(n), dma_err,\r\nIRQF_SHARED, dmae_name[n], (void *)dmae_name[n]);\r\nif (unlikely(i < 0)) {\r\nprintk(KERN_ERR "%s request_irq fail\n", dmae_name[n]);\r\nreturn i;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic void dmae_irq_free(void)\r\n{\r\nint n;\r\nfor (n = 0; n < NR_DMAE; n++)\r\nfree_irq(get_dma_error_irq(n), NULL);\r\n}\r\nstatic inline int dmae_irq_init(void)\r\n{\r\nreturn 0;\r\n}\r\nstatic void dmae_irq_free(void)\r\n{\r\n}\r\nstatic int __init sh_dmac_init(void)\r\n{\r\nstruct dma_info *info = &sh_dmac_info;\r\nint i, rc;\r\nrc = dmae_irq_init();\r\nif (unlikely(rc != 0))\r\nreturn rc;\r\nfor (i = 0; i < NR_DMAOR; i++) {\r\nrc = dmaor_reset(i);\r\nif (unlikely(rc != 0))\r\nreturn rc;\r\n}\r\nreturn register_dmac(info);\r\n}\r\nstatic void __exit sh_dmac_exit(void)\r\n{\r\ndmae_irq_free();\r\nunregister_dmac(&sh_dmac_info);\r\n}
