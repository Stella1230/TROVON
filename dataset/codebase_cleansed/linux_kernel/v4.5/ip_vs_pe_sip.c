static const char *ip_vs_dbg_callid(char *buf, size_t buf_len,\r\nconst char *callid, size_t callid_len,\r\nint *idx)\r\n{\r\nsize_t max_len = 64;\r\nsize_t len = min3(max_len, callid_len, buf_len - *idx - 1);\r\nmemcpy(buf + *idx, callid, len);\r\nbuf[*idx+len] = '\0';\r\n*idx += len + 1;\r\nreturn buf + *idx - len;\r\n}\r\nstatic int get_callid(const char *dptr, unsigned int dataoff,\r\nunsigned int datalen,\r\nunsigned int *matchoff, unsigned int *matchlen)\r\n{\r\nwhile (1) {\r\nint ret = ct_sip_get_header(NULL, dptr, dataoff, datalen,\r\nSIP_HDR_CALL_ID, matchoff,\r\nmatchlen);\r\nif (ret > 0)\r\nbreak;\r\nif (!ret)\r\nreturn -EINVAL;\r\ndataoff += *matchoff;\r\n}\r\nif (*matchlen > IP_VS_PEDATA_MAXLEN)\r\nreturn -EINVAL;\r\nif (*matchoff + *matchlen == datalen)\r\nreturn -EINVAL;\r\nif (*(dptr + *matchoff + *matchlen) != '\r' &&\r\n*(dptr + *matchoff + *matchlen) != '\n')\r\nreturn -EINVAL;\r\nIP_VS_DBG_BUF(9, "SIP callid %s (%d bytes)\n",\r\nIP_VS_DEBUG_CALLID(dptr + *matchoff, *matchlen),\r\n*matchlen);\r\nreturn 0;\r\n}\r\nstatic int\r\nip_vs_sip_fill_param(struct ip_vs_conn_param *p, struct sk_buff *skb)\r\n{\r\nstruct ip_vs_iphdr iph;\r\nunsigned int dataoff, datalen, matchoff, matchlen;\r\nconst char *dptr;\r\nint retc;\r\nip_vs_fill_iph_skb(p->af, skb, false, &iph);\r\nif (iph.protocol != IPPROTO_UDP)\r\nreturn -EINVAL;\r\ndataoff = iph.len + sizeof(struct udphdr);\r\nif (dataoff >= skb->len)\r\nreturn -EINVAL;\r\nretc = skb_linearize(skb);\r\nif (retc < 0)\r\nreturn retc;\r\ndptr = skb->data + dataoff;\r\ndatalen = skb->len - dataoff;\r\nif (get_callid(dptr, dataoff, datalen, &matchoff, &matchlen))\r\nreturn -EINVAL;\r\np->pe_data = kmemdup(dptr + matchoff, matchlen, GFP_ATOMIC);\r\nif (!p->pe_data)\r\nreturn -ENOMEM;\r\np->pe_data_len = matchlen;\r\nreturn 0;\r\n}\r\nstatic bool ip_vs_sip_ct_match(const struct ip_vs_conn_param *p,\r\nstruct ip_vs_conn *ct)\r\n{\r\nbool ret = false;\r\nif (ct->af == p->af &&\r\nip_vs_addr_equal(p->af, p->caddr, &ct->caddr) &&\r\nip_vs_addr_equal(p->protocol == IPPROTO_IP ? AF_UNSPEC : p->af,\r\np->vaddr, &ct->vaddr) &&\r\nct->vport == p->vport &&\r\nct->flags & IP_VS_CONN_F_TEMPLATE &&\r\nct->protocol == p->protocol &&\r\nct->pe_data && ct->pe_data_len == p->pe_data_len &&\r\n!memcmp(ct->pe_data, p->pe_data, p->pe_data_len))\r\nret = true;\r\nIP_VS_DBG_BUF(9, "SIP template match %s %s->%s:%d %s\n",\r\nip_vs_proto_name(p->protocol),\r\nIP_VS_DEBUG_CALLID(p->pe_data, p->pe_data_len),\r\nIP_VS_DBG_ADDR(p->af, p->vaddr), ntohs(p->vport),\r\nret ? "hit" : "not hit");\r\nreturn ret;\r\n}\r\nstatic u32 ip_vs_sip_hashkey_raw(const struct ip_vs_conn_param *p,\r\nu32 initval, bool inverse)\r\n{\r\nreturn jhash(p->pe_data, p->pe_data_len, initval);\r\n}\r\nstatic int ip_vs_sip_show_pe_data(const struct ip_vs_conn *cp, char *buf)\r\n{\r\nmemcpy(buf, cp->pe_data, cp->pe_data_len);\r\nreturn cp->pe_data_len;\r\n}\r\nstatic int __init ip_vs_sip_init(void)\r\n{\r\nreturn register_ip_vs_pe(&ip_vs_sip_pe);\r\n}\r\nstatic void __exit ip_vs_sip_cleanup(void)\r\n{\r\nunregister_ip_vs_pe(&ip_vs_sip_pe);\r\nsynchronize_rcu();\r\n}
