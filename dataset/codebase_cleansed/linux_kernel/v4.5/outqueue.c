static inline void sctp_outq_head_data(struct sctp_outq *q,\r\nstruct sctp_chunk *ch)\r\n{\r\nlist_add(&ch->list, &q->out_chunk_list);\r\nq->out_qlen += ch->skb->len;\r\n}\r\nstatic inline struct sctp_chunk *sctp_outq_dequeue_data(struct sctp_outq *q)\r\n{\r\nstruct sctp_chunk *ch = NULL;\r\nif (!list_empty(&q->out_chunk_list)) {\r\nstruct list_head *entry = q->out_chunk_list.next;\r\nch = list_entry(entry, struct sctp_chunk, list);\r\nlist_del_init(entry);\r\nq->out_qlen -= ch->skb->len;\r\n}\r\nreturn ch;\r\n}\r\nstatic inline void sctp_outq_tail_data(struct sctp_outq *q,\r\nstruct sctp_chunk *ch)\r\n{\r\nlist_add_tail(&ch->list, &q->out_chunk_list);\r\nq->out_qlen += ch->skb->len;\r\n}\r\nstatic inline int sctp_cacc_skip_3_1_d(struct sctp_transport *primary,\r\nstruct sctp_transport *transport,\r\nint count_of_newacks)\r\n{\r\nif (count_of_newacks >= 2 && transport != primary)\r\nreturn 1;\r\nreturn 0;\r\n}\r\nstatic inline int sctp_cacc_skip_3_1_f(struct sctp_transport *transport,\r\nint count_of_newacks)\r\n{\r\nif (count_of_newacks < 2 &&\r\n(transport && !transport->cacc.cacc_saw_newack))\r\nreturn 1;\r\nreturn 0;\r\n}\r\nstatic inline int sctp_cacc_skip_3_1(struct sctp_transport *primary,\r\nstruct sctp_transport *transport,\r\nint count_of_newacks)\r\n{\r\nif (!primary->cacc.cycling_changeover) {\r\nif (sctp_cacc_skip_3_1_d(primary, transport, count_of_newacks))\r\nreturn 1;\r\nif (sctp_cacc_skip_3_1_f(transport, count_of_newacks))\r\nreturn 1;\r\nreturn 0;\r\n}\r\nreturn 0;\r\n}\r\nstatic inline int sctp_cacc_skip_3_2(struct sctp_transport *primary, __u32 tsn)\r\n{\r\nif (primary->cacc.cycling_changeover &&\r\nTSN_lt(tsn, primary->cacc.next_tsn_at_change))\r\nreturn 1;\r\nreturn 0;\r\n}\r\nstatic inline int sctp_cacc_skip(struct sctp_transport *primary,\r\nstruct sctp_transport *transport,\r\nint count_of_newacks,\r\n__u32 tsn)\r\n{\r\nif (primary->cacc.changeover_active &&\r\n(sctp_cacc_skip_3_1(primary, transport, count_of_newacks) ||\r\nsctp_cacc_skip_3_2(primary, tsn)))\r\nreturn 1;\r\nreturn 0;\r\n}\r\nvoid sctp_outq_init(struct sctp_association *asoc, struct sctp_outq *q)\r\n{\r\nmemset(q, 0, sizeof(struct sctp_outq));\r\nq->asoc = asoc;\r\nINIT_LIST_HEAD(&q->out_chunk_list);\r\nINIT_LIST_HEAD(&q->control_chunk_list);\r\nINIT_LIST_HEAD(&q->retransmit);\r\nINIT_LIST_HEAD(&q->sacked);\r\nINIT_LIST_HEAD(&q->abandoned);\r\n}\r\nstatic void __sctp_outq_teardown(struct sctp_outq *q)\r\n{\r\nstruct sctp_transport *transport;\r\nstruct list_head *lchunk, *temp;\r\nstruct sctp_chunk *chunk, *tmp;\r\nlist_for_each_entry(transport, &q->asoc->peer.transport_addr_list,\r\ntransports) {\r\nwhile ((lchunk = sctp_list_dequeue(&transport->transmitted)) != NULL) {\r\nchunk = list_entry(lchunk, struct sctp_chunk,\r\ntransmitted_list);\r\nsctp_chunk_fail(chunk, q->error);\r\nsctp_chunk_free(chunk);\r\n}\r\n}\r\nlist_for_each_safe(lchunk, temp, &q->sacked) {\r\nlist_del_init(lchunk);\r\nchunk = list_entry(lchunk, struct sctp_chunk,\r\ntransmitted_list);\r\nsctp_chunk_fail(chunk, q->error);\r\nsctp_chunk_free(chunk);\r\n}\r\nlist_for_each_safe(lchunk, temp, &q->retransmit) {\r\nlist_del_init(lchunk);\r\nchunk = list_entry(lchunk, struct sctp_chunk,\r\ntransmitted_list);\r\nsctp_chunk_fail(chunk, q->error);\r\nsctp_chunk_free(chunk);\r\n}\r\nlist_for_each_safe(lchunk, temp, &q->abandoned) {\r\nlist_del_init(lchunk);\r\nchunk = list_entry(lchunk, struct sctp_chunk,\r\ntransmitted_list);\r\nsctp_chunk_fail(chunk, q->error);\r\nsctp_chunk_free(chunk);\r\n}\r\nwhile ((chunk = sctp_outq_dequeue_data(q)) != NULL) {\r\nsctp_chunk_fail(chunk, q->error);\r\nsctp_chunk_free(chunk);\r\n}\r\nlist_for_each_entry_safe(chunk, tmp, &q->control_chunk_list, list) {\r\nlist_del_init(&chunk->list);\r\nsctp_chunk_free(chunk);\r\n}\r\n}\r\nvoid sctp_outq_teardown(struct sctp_outq *q)\r\n{\r\n__sctp_outq_teardown(q);\r\nsctp_outq_init(q->asoc, q);\r\n}\r\nvoid sctp_outq_free(struct sctp_outq *q)\r\n{\r\n__sctp_outq_teardown(q);\r\n}\r\nint sctp_outq_tail(struct sctp_outq *q, struct sctp_chunk *chunk)\r\n{\r\nstruct net *net = sock_net(q->asoc->base.sk);\r\nint error = 0;\r\npr_debug("%s: outq:%p, chunk:%p[%s]\n", __func__, q, chunk,\r\nchunk && chunk->chunk_hdr ?\r\nsctp_cname(SCTP_ST_CHUNK(chunk->chunk_hdr->type)) :\r\n"illegal chunk");\r\nif (sctp_chunk_is_data(chunk)) {\r\nswitch (q->asoc->state) {\r\ncase SCTP_STATE_CLOSED:\r\ncase SCTP_STATE_SHUTDOWN_PENDING:\r\ncase SCTP_STATE_SHUTDOWN_SENT:\r\ncase SCTP_STATE_SHUTDOWN_RECEIVED:\r\ncase SCTP_STATE_SHUTDOWN_ACK_SENT:\r\nerror = -ESHUTDOWN;\r\nbreak;\r\ndefault:\r\npr_debug("%s: outqueueing: outq:%p, chunk:%p[%s])\n",\r\n__func__, q, chunk, chunk && chunk->chunk_hdr ?\r\nsctp_cname(SCTP_ST_CHUNK(chunk->chunk_hdr->type)) :\r\n"illegal chunk");\r\nsctp_chunk_hold(chunk);\r\nsctp_outq_tail_data(q, chunk);\r\nif (chunk->chunk_hdr->flags & SCTP_DATA_UNORDERED)\r\nSCTP_INC_STATS(net, SCTP_MIB_OUTUNORDERCHUNKS);\r\nelse\r\nSCTP_INC_STATS(net, SCTP_MIB_OUTORDERCHUNKS);\r\nbreak;\r\n}\r\n} else {\r\nlist_add_tail(&chunk->list, &q->control_chunk_list);\r\nSCTP_INC_STATS(net, SCTP_MIB_OUTCTRLCHUNKS);\r\n}\r\nif (error < 0)\r\nreturn error;\r\nif (!q->cork)\r\nerror = sctp_outq_flush(q, 0);\r\nreturn error;\r\n}\r\nstatic void sctp_insert_list(struct list_head *head, struct list_head *new)\r\n{\r\nstruct list_head *pos;\r\nstruct sctp_chunk *nchunk, *lchunk;\r\n__u32 ntsn, ltsn;\r\nint done = 0;\r\nnchunk = list_entry(new, struct sctp_chunk, transmitted_list);\r\nntsn = ntohl(nchunk->subh.data_hdr->tsn);\r\nlist_for_each(pos, head) {\r\nlchunk = list_entry(pos, struct sctp_chunk, transmitted_list);\r\nltsn = ntohl(lchunk->subh.data_hdr->tsn);\r\nif (TSN_lt(ntsn, ltsn)) {\r\nlist_add(new, pos->prev);\r\ndone = 1;\r\nbreak;\r\n}\r\n}\r\nif (!done)\r\nlist_add_tail(new, head);\r\n}\r\nvoid sctp_retransmit_mark(struct sctp_outq *q,\r\nstruct sctp_transport *transport,\r\n__u8 reason)\r\n{\r\nstruct list_head *lchunk, *ltemp;\r\nstruct sctp_chunk *chunk;\r\nlist_for_each_safe(lchunk, ltemp, &transport->transmitted) {\r\nchunk = list_entry(lchunk, struct sctp_chunk,\r\ntransmitted_list);\r\nif (sctp_chunk_abandoned(chunk)) {\r\nlist_del_init(lchunk);\r\nsctp_insert_list(&q->abandoned, lchunk);\r\nif (!chunk->tsn_gap_acked) {\r\nif (chunk->transport)\r\nchunk->transport->flight_size -=\r\nsctp_data_size(chunk);\r\nq->outstanding_bytes -= sctp_data_size(chunk);\r\nq->asoc->peer.rwnd += sctp_data_size(chunk);\r\n}\r\ncontinue;\r\n}\r\nif ((reason == SCTP_RTXR_FAST_RTX &&\r\n(chunk->fast_retransmit == SCTP_NEED_FRTX)) ||\r\n(reason != SCTP_RTXR_FAST_RTX && !chunk->tsn_gap_acked)) {\r\nq->asoc->peer.rwnd += sctp_data_size(chunk);\r\nq->outstanding_bytes -= sctp_data_size(chunk);\r\nif (chunk->transport)\r\ntransport->flight_size -= sctp_data_size(chunk);\r\nchunk->tsn_missing_report = 0;\r\nif (chunk->rtt_in_progress) {\r\nchunk->rtt_in_progress = 0;\r\ntransport->rto_pending = 0;\r\n}\r\nchunk->resent = 1;\r\nlist_del_init(lchunk);\r\nsctp_insert_list(&q->retransmit, lchunk);\r\n}\r\n}\r\npr_debug("%s: transport:%p, reason:%d, cwnd:%d, ssthresh:%d, "\r\n"flight_size:%d, pba:%d\n", __func__, transport, reason,\r\ntransport->cwnd, transport->ssthresh, transport->flight_size,\r\ntransport->partial_bytes_acked);\r\n}\r\nvoid sctp_retransmit(struct sctp_outq *q, struct sctp_transport *transport,\r\nsctp_retransmit_reason_t reason)\r\n{\r\nstruct net *net = sock_net(q->asoc->base.sk);\r\nint error = 0;\r\nswitch (reason) {\r\ncase SCTP_RTXR_T3_RTX:\r\nSCTP_INC_STATS(net, SCTP_MIB_T3_RETRANSMITS);\r\nsctp_transport_lower_cwnd(transport, SCTP_LOWER_CWND_T3_RTX);\r\nif (transport == transport->asoc->peer.retran_path)\r\nsctp_assoc_update_retran_path(transport->asoc);\r\ntransport->asoc->rtx_data_chunks +=\r\ntransport->asoc->unack_data;\r\nbreak;\r\ncase SCTP_RTXR_FAST_RTX:\r\nSCTP_INC_STATS(net, SCTP_MIB_FAST_RETRANSMITS);\r\nsctp_transport_lower_cwnd(transport, SCTP_LOWER_CWND_FAST_RTX);\r\nq->fast_rtx = 1;\r\nbreak;\r\ncase SCTP_RTXR_PMTUD:\r\nSCTP_INC_STATS(net, SCTP_MIB_PMTUD_RETRANSMITS);\r\nbreak;\r\ncase SCTP_RTXR_T1_RTX:\r\nSCTP_INC_STATS(net, SCTP_MIB_T1_RETRANSMITS);\r\ntransport->asoc->init_retries++;\r\nbreak;\r\ndefault:\r\nBUG();\r\n}\r\nsctp_retransmit_mark(q, transport, reason);\r\nif (reason == SCTP_RTXR_T3_RTX)\r\nsctp_generate_fwdtsn(q, q->asoc->ctsn_ack_point);\r\nif (reason != SCTP_RTXR_FAST_RTX)\r\nerror = sctp_outq_flush(q, 1);\r\nif (error)\r\nq->asoc->base.sk->sk_err = -error;\r\n}\r\nstatic int sctp_outq_flush_rtx(struct sctp_outq *q, struct sctp_packet *pkt,\r\nint rtx_timeout, int *start_timer)\r\n{\r\nstruct list_head *lqueue;\r\nstruct sctp_transport *transport = pkt->transport;\r\nsctp_xmit_t status;\r\nstruct sctp_chunk *chunk, *chunk1;\r\nint fast_rtx;\r\nint error = 0;\r\nint timer = 0;\r\nint done = 0;\r\nlqueue = &q->retransmit;\r\nfast_rtx = q->fast_rtx;\r\nlist_for_each_entry_safe(chunk, chunk1, lqueue, transmitted_list) {\r\nif (sctp_chunk_abandoned(chunk)) {\r\nlist_del_init(&chunk->transmitted_list);\r\nsctp_insert_list(&q->abandoned,\r\n&chunk->transmitted_list);\r\ncontinue;\r\n}\r\nif (chunk->tsn_gap_acked) {\r\nlist_move_tail(&chunk->transmitted_list,\r\n&transport->transmitted);\r\ncontinue;\r\n}\r\nif (fast_rtx && !chunk->fast_retransmit)\r\ncontinue;\r\nredo:\r\nstatus = sctp_packet_append_chunk(pkt, chunk);\r\nswitch (status) {\r\ncase SCTP_XMIT_PMTU_FULL:\r\nif (!pkt->has_data && !pkt->has_cookie_echo) {\r\nsctp_packet_transmit(pkt);\r\ngoto redo;\r\n}\r\nerror = sctp_packet_transmit(pkt);\r\nif (rtx_timeout || fast_rtx)\r\ndone = 1;\r\nelse\r\ngoto redo;\r\nbreak;\r\ncase SCTP_XMIT_RWND_FULL:\r\nerror = sctp_packet_transmit(pkt);\r\ndone = 1;\r\nbreak;\r\ncase SCTP_XMIT_DELAY:\r\nerror = sctp_packet_transmit(pkt);\r\ndone = 1;\r\nbreak;\r\ndefault:\r\nlist_move_tail(&chunk->transmitted_list,\r\n&transport->transmitted);\r\nif (chunk->fast_retransmit == SCTP_NEED_FRTX)\r\nchunk->fast_retransmit = SCTP_DONT_FRTX;\r\nq->asoc->stats.rtxchunks++;\r\nbreak;\r\n}\r\nif (!error && !timer)\r\ntimer = 1;\r\nif (done)\r\nbreak;\r\n}\r\nif (rtx_timeout || fast_rtx) {\r\nlist_for_each_entry(chunk1, lqueue, transmitted_list) {\r\nif (chunk1->fast_retransmit == SCTP_NEED_FRTX)\r\nchunk1->fast_retransmit = SCTP_DONT_FRTX;\r\n}\r\n}\r\n*start_timer = timer;\r\nif (fast_rtx)\r\nq->fast_rtx = 0;\r\nreturn error;\r\n}\r\nint sctp_outq_uncork(struct sctp_outq *q)\r\n{\r\nif (q->cork)\r\nq->cork = 0;\r\nreturn sctp_outq_flush(q, 0);\r\n}\r\nstatic int sctp_outq_flush(struct sctp_outq *q, int rtx_timeout)\r\n{\r\nstruct sctp_packet *packet;\r\nstruct sctp_packet singleton;\r\nstruct sctp_association *asoc = q->asoc;\r\n__u16 sport = asoc->base.bind_addr.port;\r\n__u16 dport = asoc->peer.port;\r\n__u32 vtag = asoc->peer.i.init_tag;\r\nstruct sctp_transport *transport = NULL;\r\nstruct sctp_transport *new_transport;\r\nstruct sctp_chunk *chunk, *tmp;\r\nsctp_xmit_t status;\r\nint error = 0;\r\nint start_timer = 0;\r\nint one_packet = 0;\r\nstruct list_head transport_list;\r\nstruct list_head *ltransport;\r\nINIT_LIST_HEAD(&transport_list);\r\npacket = NULL;\r\nlist_for_each_entry_safe(chunk, tmp, &q->control_chunk_list, list) {\r\nif (asoc->src_out_of_asoc_ok &&\r\nchunk->chunk_hdr->type != SCTP_CID_ASCONF)\r\ncontinue;\r\nlist_del_init(&chunk->list);\r\nnew_transport = chunk->transport;\r\nif (!new_transport) {\r\nif (transport &&\r\nsctp_cmp_addr_exact(&chunk->dest,\r\n&transport->ipaddr))\r\nnew_transport = transport;\r\nelse\r\nnew_transport = sctp_assoc_lookup_paddr(asoc,\r\n&chunk->dest);\r\nif (!new_transport)\r\nnew_transport = asoc->peer.active_path;\r\n} else if ((new_transport->state == SCTP_INACTIVE) ||\r\n(new_transport->state == SCTP_UNCONFIRMED) ||\r\n(new_transport->state == SCTP_PF)) {\r\nif (chunk->chunk_hdr->type != SCTP_CID_HEARTBEAT &&\r\nchunk->chunk_hdr->type != SCTP_CID_HEARTBEAT_ACK &&\r\nchunk->chunk_hdr->type != SCTP_CID_ASCONF_ACK)\r\nnew_transport = asoc->peer.active_path;\r\n}\r\nif (new_transport != transport) {\r\ntransport = new_transport;\r\nif (list_empty(&transport->send_ready)) {\r\nlist_add_tail(&transport->send_ready,\r\n&transport_list);\r\n}\r\npacket = &transport->packet;\r\nsctp_packet_config(packet, vtag,\r\nasoc->peer.ecn_capable);\r\n}\r\nswitch (chunk->chunk_hdr->type) {\r\ncase SCTP_CID_INIT:\r\ncase SCTP_CID_INIT_ACK:\r\ncase SCTP_CID_SHUTDOWN_COMPLETE:\r\nsctp_packet_init(&singleton, transport, sport, dport);\r\nsctp_packet_config(&singleton, vtag, 0);\r\nsctp_packet_append_chunk(&singleton, chunk);\r\nerror = sctp_packet_transmit(&singleton);\r\nif (error < 0)\r\nreturn error;\r\nbreak;\r\ncase SCTP_CID_ABORT:\r\nif (sctp_test_T_bit(chunk)) {\r\npacket->vtag = asoc->c.my_vtag;\r\n}\r\ncase SCTP_CID_HEARTBEAT_ACK:\r\ncase SCTP_CID_SHUTDOWN_ACK:\r\ncase SCTP_CID_COOKIE_ACK:\r\ncase SCTP_CID_COOKIE_ECHO:\r\ncase SCTP_CID_ERROR:\r\ncase SCTP_CID_ECN_CWR:\r\ncase SCTP_CID_ASCONF_ACK:\r\none_packet = 1;\r\ncase SCTP_CID_SACK:\r\ncase SCTP_CID_HEARTBEAT:\r\ncase SCTP_CID_SHUTDOWN:\r\ncase SCTP_CID_ECN_ECNE:\r\ncase SCTP_CID_ASCONF:\r\ncase SCTP_CID_FWD_TSN:\r\nstatus = sctp_packet_transmit_chunk(packet, chunk,\r\none_packet);\r\nif (status != SCTP_XMIT_OK) {\r\nlist_add(&chunk->list, &q->control_chunk_list);\r\n} else {\r\nasoc->stats.octrlchunks++;\r\nif (chunk->chunk_hdr->type == SCTP_CID_FWD_TSN)\r\nsctp_transport_reset_timers(transport);\r\n}\r\nbreak;\r\ndefault:\r\nBUG();\r\n}\r\n}\r\nif (q->asoc->src_out_of_asoc_ok)\r\ngoto sctp_flush_out;\r\nswitch (asoc->state) {\r\ncase SCTP_STATE_COOKIE_ECHOED:\r\nif (!packet || !packet->has_cookie_echo)\r\nbreak;\r\ncase SCTP_STATE_ESTABLISHED:\r\ncase SCTP_STATE_SHUTDOWN_PENDING:\r\ncase SCTP_STATE_SHUTDOWN_RECEIVED:\r\nif (!list_empty(&q->retransmit)) {\r\nif (asoc->peer.retran_path->state == SCTP_UNCONFIRMED)\r\ngoto sctp_flush_out;\r\nif (transport == asoc->peer.retran_path)\r\ngoto retran;\r\ntransport = asoc->peer.retran_path;\r\nif (list_empty(&transport->send_ready)) {\r\nlist_add_tail(&transport->send_ready,\r\n&transport_list);\r\n}\r\npacket = &transport->packet;\r\nsctp_packet_config(packet, vtag,\r\nasoc->peer.ecn_capable);\r\nretran:\r\nerror = sctp_outq_flush_rtx(q, packet,\r\nrtx_timeout, &start_timer);\r\nif (start_timer)\r\nsctp_transport_reset_timers(transport);\r\nif (packet->has_cookie_echo)\r\ngoto sctp_flush_out;\r\nif (!list_empty(&q->retransmit))\r\ngoto sctp_flush_out;\r\n}\r\nif (transport)\r\nsctp_transport_burst_limited(transport);\r\nwhile ((chunk = sctp_outq_dequeue_data(q)) != NULL) {\r\nif (chunk->sinfo.sinfo_stream >=\r\nasoc->c.sinit_num_ostreams) {\r\nsctp_chunk_fail(chunk, SCTP_ERROR_INV_STRM);\r\nsctp_chunk_free(chunk);\r\ncontinue;\r\n}\r\nif (sctp_chunk_abandoned(chunk)) {\r\nsctp_chunk_fail(chunk, 0);\r\nsctp_chunk_free(chunk);\r\ncontinue;\r\n}\r\nnew_transport = chunk->transport;\r\nif (!new_transport ||\r\n((new_transport->state == SCTP_INACTIVE) ||\r\n(new_transport->state == SCTP_UNCONFIRMED) ||\r\n(new_transport->state == SCTP_PF)))\r\nnew_transport = asoc->peer.active_path;\r\nif (new_transport->state == SCTP_UNCONFIRMED)\r\ncontinue;\r\nif (new_transport != transport) {\r\ntransport = new_transport;\r\nif (list_empty(&transport->send_ready)) {\r\nlist_add_tail(&transport->send_ready,\r\n&transport_list);\r\n}\r\npacket = &transport->packet;\r\nsctp_packet_config(packet, vtag,\r\nasoc->peer.ecn_capable);\r\nsctp_transport_burst_limited(transport);\r\n}\r\npr_debug("%s: outq:%p, chunk:%p[%s], tx-tsn:0x%x skb->head:%p "\r\n"skb->users:%d\n",\r\n__func__, q, chunk, chunk && chunk->chunk_hdr ?\r\nsctp_cname(SCTP_ST_CHUNK(chunk->chunk_hdr->type)) :\r\n"illegal chunk", ntohl(chunk->subh.data_hdr->tsn),\r\nchunk->skb ? chunk->skb->head : NULL, chunk->skb ?\r\natomic_read(&chunk->skb->users) : -1);\r\nstatus = sctp_packet_transmit_chunk(packet, chunk, 0);\r\nswitch (status) {\r\ncase SCTP_XMIT_PMTU_FULL:\r\ncase SCTP_XMIT_RWND_FULL:\r\ncase SCTP_XMIT_DELAY:\r\npr_debug("%s: could not transmit tsn:0x%x, status:%d\n",\r\n__func__, ntohl(chunk->subh.data_hdr->tsn),\r\nstatus);\r\nsctp_outq_head_data(q, chunk);\r\ngoto sctp_flush_out;\r\ncase SCTP_XMIT_OK:\r\nif (asoc->state == SCTP_STATE_SHUTDOWN_PENDING)\r\nchunk->chunk_hdr->flags |= SCTP_DATA_SACK_IMM;\r\nif (chunk->chunk_hdr->flags & SCTP_DATA_UNORDERED)\r\nasoc->stats.ouodchunks++;\r\nelse\r\nasoc->stats.oodchunks++;\r\nbreak;\r\ndefault:\r\nBUG();\r\n}\r\nlist_add_tail(&chunk->transmitted_list,\r\n&transport->transmitted);\r\nsctp_transport_reset_timers(transport);\r\nif (packet->has_cookie_echo)\r\ngoto sctp_flush_out;\r\n}\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nsctp_flush_out:\r\nwhile ((ltransport = sctp_list_dequeue(&transport_list)) != NULL) {\r\nstruct sctp_transport *t = list_entry(ltransport,\r\nstruct sctp_transport,\r\nsend_ready);\r\npacket = &t->packet;\r\nif (!sctp_packet_empty(packet))\r\nerror = sctp_packet_transmit(packet);\r\nsctp_transport_burst_reset(t);\r\n}\r\nreturn error;\r\n}\r\nstatic void sctp_sack_update_unack_data(struct sctp_association *assoc,\r\nstruct sctp_sackhdr *sack)\r\n{\r\nsctp_sack_variable_t *frags;\r\n__u16 unack_data;\r\nint i;\r\nunack_data = assoc->next_tsn - assoc->ctsn_ack_point - 1;\r\nfrags = sack->variable;\r\nfor (i = 0; i < ntohs(sack->num_gap_ack_blocks); i++) {\r\nunack_data -= ((ntohs(frags[i].gab.end) -\r\nntohs(frags[i].gab.start) + 1));\r\n}\r\nassoc->unack_data = unack_data;\r\n}\r\nint sctp_outq_sack(struct sctp_outq *q, struct sctp_chunk *chunk)\r\n{\r\nstruct sctp_association *asoc = q->asoc;\r\nstruct sctp_sackhdr *sack = chunk->subh.sack_hdr;\r\nstruct sctp_transport *transport;\r\nstruct sctp_chunk *tchunk = NULL;\r\nstruct list_head *lchunk, *transport_list, *temp;\r\nsctp_sack_variable_t *frags = sack->variable;\r\n__u32 sack_ctsn, ctsn, tsn;\r\n__u32 highest_tsn, highest_new_tsn;\r\n__u32 sack_a_rwnd;\r\nunsigned int outstanding;\r\nstruct sctp_transport *primary = asoc->peer.primary_path;\r\nint count_of_newacks = 0;\r\nint gap_ack_blocks;\r\nu8 accum_moved = 0;\r\ntransport_list = &asoc->peer.transport_addr_list;\r\nsack_ctsn = ntohl(sack->cum_tsn_ack);\r\ngap_ack_blocks = ntohs(sack->num_gap_ack_blocks);\r\nasoc->stats.gapcnt += gap_ack_blocks;\r\nif (primary->cacc.changeover_active) {\r\nu8 clear_cycling = 0;\r\nif (TSN_lte(primary->cacc.next_tsn_at_change, sack_ctsn)) {\r\nprimary->cacc.changeover_active = 0;\r\nclear_cycling = 1;\r\n}\r\nif (clear_cycling || gap_ack_blocks) {\r\nlist_for_each_entry(transport, transport_list,\r\ntransports) {\r\nif (clear_cycling)\r\ntransport->cacc.cycling_changeover = 0;\r\nif (gap_ack_blocks)\r\ntransport->cacc.cacc_saw_newack = 0;\r\n}\r\n}\r\n}\r\nhighest_tsn = sack_ctsn;\r\nif (gap_ack_blocks)\r\nhighest_tsn += ntohs(frags[gap_ack_blocks - 1].gab.end);\r\nif (TSN_lt(asoc->highest_sacked, highest_tsn))\r\nasoc->highest_sacked = highest_tsn;\r\nhighest_new_tsn = sack_ctsn;\r\nsctp_check_transmitted(q, &q->retransmit, NULL, NULL, sack, &highest_new_tsn);\r\nlist_for_each_entry(transport, transport_list, transports) {\r\nsctp_check_transmitted(q, &transport->transmitted,\r\ntransport, &chunk->source, sack,\r\n&highest_new_tsn);\r\nif (transport->cacc.cacc_saw_newack)\r\ncount_of_newacks++;\r\n}\r\nif (TSN_lt(asoc->ctsn_ack_point, sack_ctsn)) {\r\nasoc->ctsn_ack_point = sack_ctsn;\r\naccum_moved = 1;\r\n}\r\nif (gap_ack_blocks) {\r\nif (asoc->fast_recovery && accum_moved)\r\nhighest_new_tsn = highest_tsn;\r\nlist_for_each_entry(transport, transport_list, transports)\r\nsctp_mark_missing(q, &transport->transmitted, transport,\r\nhighest_new_tsn, count_of_newacks);\r\n}\r\nsctp_sack_update_unack_data(asoc, sack);\r\nctsn = asoc->ctsn_ack_point;\r\nlist_for_each_safe(lchunk, temp, &q->sacked) {\r\ntchunk = list_entry(lchunk, struct sctp_chunk,\r\ntransmitted_list);\r\ntsn = ntohl(tchunk->subh.data_hdr->tsn);\r\nif (TSN_lte(tsn, ctsn)) {\r\nlist_del_init(&tchunk->transmitted_list);\r\nsctp_chunk_free(tchunk);\r\n}\r\n}\r\nsack_a_rwnd = ntohl(sack->a_rwnd);\r\nasoc->peer.zero_window_announced = !sack_a_rwnd;\r\noutstanding = q->outstanding_bytes;\r\nif (outstanding < sack_a_rwnd)\r\nsack_a_rwnd -= outstanding;\r\nelse\r\nsack_a_rwnd = 0;\r\nasoc->peer.rwnd = sack_a_rwnd;\r\nsctp_generate_fwdtsn(q, sack_ctsn);\r\npr_debug("%s: sack cumulative tsn ack:0x%x\n", __func__, sack_ctsn);\r\npr_debug("%s: cumulative tsn ack of assoc:%p is 0x%x, "\r\n"advertised peer ack point:0x%x\n", __func__, asoc, ctsn,\r\nasoc->adv_peer_ack_point);\r\nreturn sctp_outq_is_empty(q);\r\n}\r\nint sctp_outq_is_empty(const struct sctp_outq *q)\r\n{\r\nreturn q->out_qlen == 0 && q->outstanding_bytes == 0 &&\r\nlist_empty(&q->retransmit);\r\n}\r\nstatic void sctp_check_transmitted(struct sctp_outq *q,\r\nstruct list_head *transmitted_queue,\r\nstruct sctp_transport *transport,\r\nunion sctp_addr *saddr,\r\nstruct sctp_sackhdr *sack,\r\n__u32 *highest_new_tsn_in_sack)\r\n{\r\nstruct list_head *lchunk;\r\nstruct sctp_chunk *tchunk;\r\nstruct list_head tlist;\r\n__u32 tsn;\r\n__u32 sack_ctsn;\r\n__u32 rtt;\r\n__u8 restart_timer = 0;\r\nint bytes_acked = 0;\r\nint migrate_bytes = 0;\r\nbool forward_progress = false;\r\nsack_ctsn = ntohl(sack->cum_tsn_ack);\r\nINIT_LIST_HEAD(&tlist);\r\nwhile (NULL != (lchunk = sctp_list_dequeue(transmitted_queue))) {\r\ntchunk = list_entry(lchunk, struct sctp_chunk,\r\ntransmitted_list);\r\nif (sctp_chunk_abandoned(tchunk)) {\r\nsctp_insert_list(&q->abandoned, lchunk);\r\nif (!tchunk->tsn_gap_acked) {\r\nif (tchunk->transport)\r\ntchunk->transport->flight_size -=\r\nsctp_data_size(tchunk);\r\nq->outstanding_bytes -= sctp_data_size(tchunk);\r\n}\r\ncontinue;\r\n}\r\ntsn = ntohl(tchunk->subh.data_hdr->tsn);\r\nif (sctp_acked(sack, tsn)) {\r\nif (transport) {\r\nif (!tchunk->tsn_gap_acked &&\r\n!tchunk->resent &&\r\ntchunk->rtt_in_progress) {\r\ntchunk->rtt_in_progress = 0;\r\nrtt = jiffies - tchunk->sent_at;\r\nsctp_transport_update_rto(transport,\r\nrtt);\r\n}\r\n}\r\nif (!tchunk->tsn_gap_acked) {\r\ntchunk->tsn_gap_acked = 1;\r\nif (TSN_lt(*highest_new_tsn_in_sack, tsn))\r\n*highest_new_tsn_in_sack = tsn;\r\nbytes_acked += sctp_data_size(tchunk);\r\nif (!tchunk->transport)\r\nmigrate_bytes += sctp_data_size(tchunk);\r\nforward_progress = true;\r\n}\r\nif (TSN_lte(tsn, sack_ctsn)) {\r\nrestart_timer = 1;\r\nforward_progress = true;\r\nif (!tchunk->tsn_gap_acked) {\r\nif (transport &&\r\nsack->num_gap_ack_blocks &&\r\nq->asoc->peer.primary_path->cacc.\r\nchangeover_active)\r\ntransport->cacc.cacc_saw_newack\r\n= 1;\r\n}\r\nlist_add_tail(&tchunk->transmitted_list,\r\n&q->sacked);\r\n} else {\r\nlist_add_tail(lchunk, &tlist);\r\n}\r\n} else {\r\nif (tchunk->tsn_gap_acked) {\r\npr_debug("%s: receiver reneged on data TSN:0x%x\n",\r\n__func__, tsn);\r\ntchunk->tsn_gap_acked = 0;\r\nif (tchunk->transport)\r\nbytes_acked -= sctp_data_size(tchunk);\r\nrestart_timer = 1;\r\n}\r\nlist_add_tail(lchunk, &tlist);\r\n}\r\n}\r\nif (transport) {\r\nif (bytes_acked) {\r\nstruct sctp_association *asoc = transport->asoc;\r\nbytes_acked -= migrate_bytes;\r\ntransport->error_count = 0;\r\ntransport->asoc->overall_error_count = 0;\r\nforward_progress = true;\r\nif (asoc->state == SCTP_STATE_SHUTDOWN_PENDING &&\r\ndel_timer(&asoc->timers\r\n[SCTP_EVENT_TIMEOUT_T5_SHUTDOWN_GUARD]))\r\nsctp_association_put(asoc);\r\nif ((transport->state == SCTP_INACTIVE ||\r\ntransport->state == SCTP_UNCONFIRMED) &&\r\nsctp_cmp_addr_exact(&transport->ipaddr, saddr)) {\r\nsctp_assoc_control_transport(\r\ntransport->asoc,\r\ntransport,\r\nSCTP_TRANSPORT_UP,\r\nSCTP_RECEIVED_SACK);\r\n}\r\nsctp_transport_raise_cwnd(transport, sack_ctsn,\r\nbytes_acked);\r\ntransport->flight_size -= bytes_acked;\r\nif (transport->flight_size == 0)\r\ntransport->partial_bytes_acked = 0;\r\nq->outstanding_bytes -= bytes_acked + migrate_bytes;\r\n} else {\r\nif (!q->asoc->peer.rwnd &&\r\n!list_empty(&tlist) &&\r\n(sack_ctsn+2 == q->asoc->next_tsn) &&\r\nq->asoc->state < SCTP_STATE_SHUTDOWN_PENDING) {\r\npr_debug("%s: sack received for zero window "\r\n"probe:%u\n", __func__, sack_ctsn);\r\nq->asoc->overall_error_count = 0;\r\ntransport->error_count = 0;\r\n}\r\n}\r\nif (!transport->flight_size) {\r\nif (del_timer(&transport->T3_rtx_timer))\r\nsctp_transport_put(transport);\r\n} else if (restart_timer) {\r\nif (!mod_timer(&transport->T3_rtx_timer,\r\njiffies + transport->rto))\r\nsctp_transport_hold(transport);\r\n}\r\nif (forward_progress) {\r\nif (transport->dst)\r\ndst_confirm(transport->dst);\r\n}\r\n}\r\nlist_splice(&tlist, transmitted_queue);\r\n}\r\nstatic void sctp_mark_missing(struct sctp_outq *q,\r\nstruct list_head *transmitted_queue,\r\nstruct sctp_transport *transport,\r\n__u32 highest_new_tsn_in_sack,\r\nint count_of_newacks)\r\n{\r\nstruct sctp_chunk *chunk;\r\n__u32 tsn;\r\nchar do_fast_retransmit = 0;\r\nstruct sctp_association *asoc = q->asoc;\r\nstruct sctp_transport *primary = asoc->peer.primary_path;\r\nlist_for_each_entry(chunk, transmitted_queue, transmitted_list) {\r\ntsn = ntohl(chunk->subh.data_hdr->tsn);\r\nif (chunk->fast_retransmit == SCTP_CAN_FRTX &&\r\n!chunk->tsn_gap_acked &&\r\nTSN_lt(tsn, highest_new_tsn_in_sack)) {\r\nif (!transport || !sctp_cacc_skip(primary,\r\nchunk->transport,\r\ncount_of_newacks, tsn)) {\r\nchunk->tsn_missing_report++;\r\npr_debug("%s: tsn:0x%x missing counter:%d\n",\r\n__func__, tsn, chunk->tsn_missing_report);\r\n}\r\n}\r\nif (chunk->tsn_missing_report >= 3) {\r\nchunk->fast_retransmit = SCTP_NEED_FRTX;\r\ndo_fast_retransmit = 1;\r\n}\r\n}\r\nif (transport) {\r\nif (do_fast_retransmit)\r\nsctp_retransmit(q, transport, SCTP_RTXR_FAST_RTX);\r\npr_debug("%s: transport:%p, cwnd:%d, ssthresh:%d, "\r\n"flight_size:%d, pba:%d\n", __func__, transport,\r\ntransport->cwnd, transport->ssthresh,\r\ntransport->flight_size, transport->partial_bytes_acked);\r\n}\r\n}\r\nstatic int sctp_acked(struct sctp_sackhdr *sack, __u32 tsn)\r\n{\r\nint i;\r\nsctp_sack_variable_t *frags;\r\n__u16 gap;\r\n__u32 ctsn = ntohl(sack->cum_tsn_ack);\r\nif (TSN_lte(tsn, ctsn))\r\ngoto pass;\r\nfrags = sack->variable;\r\ngap = tsn - ctsn;\r\nfor (i = 0; i < ntohs(sack->num_gap_ack_blocks); ++i) {\r\nif (TSN_lte(ntohs(frags[i].gab.start), gap) &&\r\nTSN_lte(gap, ntohs(frags[i].gab.end)))\r\ngoto pass;\r\n}\r\nreturn 0;\r\npass:\r\nreturn 1;\r\n}\r\nstatic inline int sctp_get_skip_pos(struct sctp_fwdtsn_skip *skiplist,\r\nint nskips, __be16 stream)\r\n{\r\nint i;\r\nfor (i = 0; i < nskips; i++) {\r\nif (skiplist[i].stream == stream)\r\nreturn i;\r\n}\r\nreturn i;\r\n}\r\nstatic void sctp_generate_fwdtsn(struct sctp_outq *q, __u32 ctsn)\r\n{\r\nstruct sctp_association *asoc = q->asoc;\r\nstruct sctp_chunk *ftsn_chunk = NULL;\r\nstruct sctp_fwdtsn_skip ftsn_skip_arr[10];\r\nint nskips = 0;\r\nint skip_pos = 0;\r\n__u32 tsn;\r\nstruct sctp_chunk *chunk;\r\nstruct list_head *lchunk, *temp;\r\nif (!asoc->peer.prsctp_capable)\r\nreturn;\r\nif (TSN_lt(asoc->adv_peer_ack_point, ctsn))\r\nasoc->adv_peer_ack_point = ctsn;\r\nlist_for_each_safe(lchunk, temp, &q->abandoned) {\r\nchunk = list_entry(lchunk, struct sctp_chunk,\r\ntransmitted_list);\r\ntsn = ntohl(chunk->subh.data_hdr->tsn);\r\nif (TSN_lte(tsn, ctsn)) {\r\nlist_del_init(lchunk);\r\nsctp_chunk_free(chunk);\r\n} else {\r\nif (TSN_lte(tsn, asoc->adv_peer_ack_point+1)) {\r\nasoc->adv_peer_ack_point = tsn;\r\nif (chunk->chunk_hdr->flags &\r\nSCTP_DATA_UNORDERED)\r\ncontinue;\r\nskip_pos = sctp_get_skip_pos(&ftsn_skip_arr[0],\r\nnskips,\r\nchunk->subh.data_hdr->stream);\r\nftsn_skip_arr[skip_pos].stream =\r\nchunk->subh.data_hdr->stream;\r\nftsn_skip_arr[skip_pos].ssn =\r\nchunk->subh.data_hdr->ssn;\r\nif (skip_pos == nskips)\r\nnskips++;\r\nif (nskips == 10)\r\nbreak;\r\n} else\r\nbreak;\r\n}\r\n}\r\nif (asoc->adv_peer_ack_point > ctsn)\r\nftsn_chunk = sctp_make_fwdtsn(asoc, asoc->adv_peer_ack_point,\r\nnskips, &ftsn_skip_arr[0]);\r\nif (ftsn_chunk) {\r\nlist_add_tail(&ftsn_chunk->list, &q->control_chunk_list);\r\nSCTP_INC_STATS(sock_net(asoc->base.sk), SCTP_MIB_OUTCTRLCHUNKS);\r\n}\r\n}
