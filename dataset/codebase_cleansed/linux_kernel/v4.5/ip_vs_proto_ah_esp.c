static void\r\nah_esp_conn_fill_param_proto(struct netns_ipvs *ipvs, int af,\r\nconst struct ip_vs_iphdr *iph,\r\nstruct ip_vs_conn_param *p)\r\n{\r\nif (likely(!ip_vs_iph_inverse(iph)))\r\nip_vs_conn_fill_param(ipvs, af, IPPROTO_UDP,\r\n&iph->saddr, htons(PORT_ISAKMP),\r\n&iph->daddr, htons(PORT_ISAKMP), p);\r\nelse\r\nip_vs_conn_fill_param(ipvs, af, IPPROTO_UDP,\r\n&iph->daddr, htons(PORT_ISAKMP),\r\n&iph->saddr, htons(PORT_ISAKMP), p);\r\n}\r\nstatic struct ip_vs_conn *\r\nah_esp_conn_in_get(struct netns_ipvs *ipvs, int af, const struct sk_buff *skb,\r\nconst struct ip_vs_iphdr *iph)\r\n{\r\nstruct ip_vs_conn *cp;\r\nstruct ip_vs_conn_param p;\r\nah_esp_conn_fill_param_proto(ipvs, af, iph, &p);\r\ncp = ip_vs_conn_in_get(&p);\r\nif (!cp) {\r\nIP_VS_DBG_BUF(12, "Unknown ISAKMP entry for outin packet "\r\n"%s%s %s->%s\n",\r\nip_vs_iph_icmp(iph) ? "ICMP+" : "",\r\nip_vs_proto_get(iph->protocol)->name,\r\nIP_VS_DBG_ADDR(af, &iph->saddr),\r\nIP_VS_DBG_ADDR(af, &iph->daddr));\r\n}\r\nreturn cp;\r\n}\r\nstatic struct ip_vs_conn *\r\nah_esp_conn_out_get(struct netns_ipvs *ipvs, int af, const struct sk_buff *skb,\r\nconst struct ip_vs_iphdr *iph)\r\n{\r\nstruct ip_vs_conn *cp;\r\nstruct ip_vs_conn_param p;\r\nah_esp_conn_fill_param_proto(ipvs, af, iph, &p);\r\ncp = ip_vs_conn_out_get(&p);\r\nif (!cp) {\r\nIP_VS_DBG_BUF(12, "Unknown ISAKMP entry for inout packet "\r\n"%s%s %s->%s\n",\r\nip_vs_iph_icmp(iph) ? "ICMP+" : "",\r\nip_vs_proto_get(iph->protocol)->name,\r\nIP_VS_DBG_ADDR(af, &iph->saddr),\r\nIP_VS_DBG_ADDR(af, &iph->daddr));\r\n}\r\nreturn cp;\r\n}\r\nstatic int\r\nah_esp_conn_schedule(struct netns_ipvs *ipvs, int af, struct sk_buff *skb,\r\nstruct ip_vs_proto_data *pd,\r\nint *verdict, struct ip_vs_conn **cpp,\r\nstruct ip_vs_iphdr *iph)\r\n{\r\n*verdict = NF_ACCEPT;\r\nreturn 0;\r\n}
