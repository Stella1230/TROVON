static const char *rproc_crash_to_string(enum rproc_crash_type type)\r\n{\r\nif (type < ARRAY_SIZE(rproc_crash_names))\r\nreturn rproc_crash_names[type];\r\nreturn "unknown";\r\n}\r\nstatic int rproc_iommu_fault(struct iommu_domain *domain, struct device *dev,\r\nunsigned long iova, int flags, void *token)\r\n{\r\nstruct rproc *rproc = token;\r\ndev_err(dev, "iommu fault: da 0x%lx flags 0x%x\n", iova, flags);\r\nrproc_report_crash(rproc, RPROC_MMUFAULT);\r\nreturn -ENOSYS;\r\n}\r\nstatic int rproc_enable_iommu(struct rproc *rproc)\r\n{\r\nstruct iommu_domain *domain;\r\nstruct device *dev = rproc->dev.parent;\r\nint ret;\r\nif (!rproc->has_iommu) {\r\ndev_dbg(dev, "iommu not present\n");\r\nreturn 0;\r\n}\r\ndomain = iommu_domain_alloc(dev->bus);\r\nif (!domain) {\r\ndev_err(dev, "can't alloc iommu domain\n");\r\nreturn -ENOMEM;\r\n}\r\niommu_set_fault_handler(domain, rproc_iommu_fault, rproc);\r\nret = iommu_attach_device(domain, dev);\r\nif (ret) {\r\ndev_err(dev, "can't attach iommu device: %d\n", ret);\r\ngoto free_domain;\r\n}\r\nrproc->domain = domain;\r\nreturn 0;\r\nfree_domain:\r\niommu_domain_free(domain);\r\nreturn ret;\r\n}\r\nstatic void rproc_disable_iommu(struct rproc *rproc)\r\n{\r\nstruct iommu_domain *domain = rproc->domain;\r\nstruct device *dev = rproc->dev.parent;\r\nif (!domain)\r\nreturn;\r\niommu_detach_device(domain, dev);\r\niommu_domain_free(domain);\r\n}\r\nvoid *rproc_da_to_va(struct rproc *rproc, u64 da, int len)\r\n{\r\nstruct rproc_mem_entry *carveout;\r\nvoid *ptr = NULL;\r\nif (rproc->ops->da_to_va) {\r\nptr = rproc->ops->da_to_va(rproc, da, len);\r\nif (ptr)\r\ngoto out;\r\n}\r\nlist_for_each_entry(carveout, &rproc->carveouts, node) {\r\nint offset = da - carveout->da;\r\nif (offset < 0)\r\ncontinue;\r\nif (offset + len > carveout->len)\r\ncontinue;\r\nptr = carveout->va + offset;\r\nbreak;\r\n}\r\nout:\r\nreturn ptr;\r\n}\r\nint rproc_alloc_vring(struct rproc_vdev *rvdev, int i)\r\n{\r\nstruct rproc *rproc = rvdev->rproc;\r\nstruct device *dev = &rproc->dev;\r\nstruct rproc_vring *rvring = &rvdev->vring[i];\r\nstruct fw_rsc_vdev *rsc;\r\ndma_addr_t dma;\r\nvoid *va;\r\nint ret, size, notifyid;\r\nsize = PAGE_ALIGN(vring_size(rvring->len, rvring->align));\r\nva = dma_alloc_coherent(dev->parent, size, &dma, GFP_KERNEL);\r\nif (!va) {\r\ndev_err(dev->parent, "dma_alloc_coherent failed\n");\r\nreturn -EINVAL;\r\n}\r\nret = idr_alloc(&rproc->notifyids, rvring, 0, 0, GFP_KERNEL);\r\nif (ret < 0) {\r\ndev_err(dev, "idr_alloc failed: %d\n", ret);\r\ndma_free_coherent(dev->parent, size, va, dma);\r\nreturn ret;\r\n}\r\nnotifyid = ret;\r\ndev_dbg(dev, "vring%d: va %p dma %llx size %x idr %d\n", i, va,\r\n(unsigned long long)dma, size, notifyid);\r\nrvring->va = va;\r\nrvring->dma = dma;\r\nrvring->notifyid = notifyid;\r\nrsc = (void *)rproc->table_ptr + rvdev->rsc_offset;\r\nrsc->vring[i].da = dma;\r\nrsc->vring[i].notifyid = notifyid;\r\nreturn 0;\r\n}\r\nstatic int\r\nrproc_parse_vring(struct rproc_vdev *rvdev, struct fw_rsc_vdev *rsc, int i)\r\n{\r\nstruct rproc *rproc = rvdev->rproc;\r\nstruct device *dev = &rproc->dev;\r\nstruct fw_rsc_vdev_vring *vring = &rsc->vring[i];\r\nstruct rproc_vring *rvring = &rvdev->vring[i];\r\ndev_dbg(dev, "vdev rsc: vring%d: da %x, qsz %d, align %d\n",\r\ni, vring->da, vring->num, vring->align);\r\nif (vring->reserved) {\r\ndev_err(dev, "vring rsc has non zero reserved bytes\n");\r\nreturn -EINVAL;\r\n}\r\nif (!vring->num || !vring->align) {\r\ndev_err(dev, "invalid qsz (%d) or alignment (%d)\n",\r\nvring->num, vring->align);\r\nreturn -EINVAL;\r\n}\r\nrvring->len = vring->num;\r\nrvring->align = vring->align;\r\nrvring->rvdev = rvdev;\r\nreturn 0;\r\n}\r\nvoid rproc_free_vring(struct rproc_vring *rvring)\r\n{\r\nint size = PAGE_ALIGN(vring_size(rvring->len, rvring->align));\r\nstruct rproc *rproc = rvring->rvdev->rproc;\r\nint idx = rvring->rvdev->vring - rvring;\r\nstruct fw_rsc_vdev *rsc;\r\ndma_free_coherent(rproc->dev.parent, size, rvring->va, rvring->dma);\r\nidr_remove(&rproc->notifyids, rvring->notifyid);\r\nrsc = (void *)rproc->table_ptr + rvring->rvdev->rsc_offset;\r\nrsc->vring[idx].da = 0;\r\nrsc->vring[idx].notifyid = -1;\r\n}\r\nstatic int rproc_handle_vdev(struct rproc *rproc, struct fw_rsc_vdev *rsc,\r\nint offset, int avail)\r\n{\r\nstruct device *dev = &rproc->dev;\r\nstruct rproc_vdev *rvdev;\r\nint i, ret;\r\nif (sizeof(*rsc) + rsc->num_of_vrings * sizeof(struct fw_rsc_vdev_vring)\r\n+ rsc->config_len > avail) {\r\ndev_err(dev, "vdev rsc is truncated\n");\r\nreturn -EINVAL;\r\n}\r\nif (rsc->reserved[0] || rsc->reserved[1]) {\r\ndev_err(dev, "vdev rsc has non zero reserved bytes\n");\r\nreturn -EINVAL;\r\n}\r\ndev_dbg(dev, "vdev rsc: id %d, dfeatures %x, cfg len %d, %d vrings\n",\r\nrsc->id, rsc->dfeatures, rsc->config_len, rsc->num_of_vrings);\r\nif (rsc->num_of_vrings > ARRAY_SIZE(rvdev->vring)) {\r\ndev_err(dev, "too many vrings: %d\n", rsc->num_of_vrings);\r\nreturn -EINVAL;\r\n}\r\nrvdev = kzalloc(sizeof(struct rproc_vdev), GFP_KERNEL);\r\nif (!rvdev)\r\nreturn -ENOMEM;\r\nrvdev->rproc = rproc;\r\nfor (i = 0; i < rsc->num_of_vrings; i++) {\r\nret = rproc_parse_vring(rvdev, rsc, i);\r\nif (ret)\r\ngoto free_rvdev;\r\n}\r\nrvdev->rsc_offset = offset;\r\nlist_add_tail(&rvdev->node, &rproc->rvdevs);\r\nret = rproc_add_virtio_dev(rvdev, rsc->id);\r\nif (ret)\r\ngoto remove_rvdev;\r\nreturn 0;\r\nremove_rvdev:\r\nlist_del(&rvdev->node);\r\nfree_rvdev:\r\nkfree(rvdev);\r\nreturn ret;\r\n}\r\nstatic int rproc_handle_trace(struct rproc *rproc, struct fw_rsc_trace *rsc,\r\nint offset, int avail)\r\n{\r\nstruct rproc_mem_entry *trace;\r\nstruct device *dev = &rproc->dev;\r\nvoid *ptr;\r\nchar name[15];\r\nif (sizeof(*rsc) > avail) {\r\ndev_err(dev, "trace rsc is truncated\n");\r\nreturn -EINVAL;\r\n}\r\nif (rsc->reserved) {\r\ndev_err(dev, "trace rsc has non zero reserved bytes\n");\r\nreturn -EINVAL;\r\n}\r\nptr = rproc_da_to_va(rproc, rsc->da, rsc->len);\r\nif (!ptr) {\r\ndev_err(dev, "erroneous trace resource entry\n");\r\nreturn -EINVAL;\r\n}\r\ntrace = kzalloc(sizeof(*trace), GFP_KERNEL);\r\nif (!trace)\r\nreturn -ENOMEM;\r\ntrace->len = rsc->len;\r\ntrace->va = ptr;\r\nsnprintf(name, sizeof(name), "trace%d", rproc->num_traces);\r\ntrace->priv = rproc_create_trace_file(name, rproc, trace);\r\nif (!trace->priv) {\r\ntrace->va = NULL;\r\nkfree(trace);\r\nreturn -EINVAL;\r\n}\r\nlist_add_tail(&trace->node, &rproc->traces);\r\nrproc->num_traces++;\r\ndev_dbg(dev, "%s added: va %p, da 0x%x, len 0x%x\n", name, ptr,\r\nrsc->da, rsc->len);\r\nreturn 0;\r\n}\r\nstatic int rproc_handle_devmem(struct rproc *rproc, struct fw_rsc_devmem *rsc,\r\nint offset, int avail)\r\n{\r\nstruct rproc_mem_entry *mapping;\r\nstruct device *dev = &rproc->dev;\r\nint ret;\r\nif (!rproc->domain)\r\nreturn -EINVAL;\r\nif (sizeof(*rsc) > avail) {\r\ndev_err(dev, "devmem rsc is truncated\n");\r\nreturn -EINVAL;\r\n}\r\nif (rsc->reserved) {\r\ndev_err(dev, "devmem rsc has non zero reserved bytes\n");\r\nreturn -EINVAL;\r\n}\r\nmapping = kzalloc(sizeof(*mapping), GFP_KERNEL);\r\nif (!mapping)\r\nreturn -ENOMEM;\r\nret = iommu_map(rproc->domain, rsc->da, rsc->pa, rsc->len, rsc->flags);\r\nif (ret) {\r\ndev_err(dev, "failed to map devmem: %d\n", ret);\r\ngoto out;\r\n}\r\nmapping->da = rsc->da;\r\nmapping->len = rsc->len;\r\nlist_add_tail(&mapping->node, &rproc->mappings);\r\ndev_dbg(dev, "mapped devmem pa 0x%x, da 0x%x, len 0x%x\n",\r\nrsc->pa, rsc->da, rsc->len);\r\nreturn 0;\r\nout:\r\nkfree(mapping);\r\nreturn ret;\r\n}\r\nstatic int rproc_handle_carveout(struct rproc *rproc,\r\nstruct fw_rsc_carveout *rsc,\r\nint offset, int avail)\r\n{\r\nstruct rproc_mem_entry *carveout, *mapping;\r\nstruct device *dev = &rproc->dev;\r\ndma_addr_t dma;\r\nvoid *va;\r\nint ret;\r\nif (sizeof(*rsc) > avail) {\r\ndev_err(dev, "carveout rsc is truncated\n");\r\nreturn -EINVAL;\r\n}\r\nif (rsc->reserved) {\r\ndev_err(dev, "carveout rsc has non zero reserved bytes\n");\r\nreturn -EINVAL;\r\n}\r\ndev_dbg(dev, "carveout rsc: da %x, pa %x, len %x, flags %x\n",\r\nrsc->da, rsc->pa, rsc->len, rsc->flags);\r\ncarveout = kzalloc(sizeof(*carveout), GFP_KERNEL);\r\nif (!carveout)\r\nreturn -ENOMEM;\r\nva = dma_alloc_coherent(dev->parent, rsc->len, &dma, GFP_KERNEL);\r\nif (!va) {\r\ndev_err(dev->parent, "dma_alloc_coherent err: %d\n", rsc->len);\r\nret = -ENOMEM;\r\ngoto free_carv;\r\n}\r\ndev_dbg(dev, "carveout va %p, dma %llx, len 0x%x\n", va,\r\n(unsigned long long)dma, rsc->len);\r\nif (rproc->domain) {\r\nmapping = kzalloc(sizeof(*mapping), GFP_KERNEL);\r\nif (!mapping) {\r\ndev_err(dev, "kzalloc mapping failed\n");\r\nret = -ENOMEM;\r\ngoto dma_free;\r\n}\r\nret = iommu_map(rproc->domain, rsc->da, dma, rsc->len,\r\nrsc->flags);\r\nif (ret) {\r\ndev_err(dev, "iommu_map failed: %d\n", ret);\r\ngoto free_mapping;\r\n}\r\nmapping->da = rsc->da;\r\nmapping->len = rsc->len;\r\nlist_add_tail(&mapping->node, &rproc->mappings);\r\ndev_dbg(dev, "carveout mapped 0x%x to 0x%llx\n",\r\nrsc->da, (unsigned long long)dma);\r\n}\r\nrsc->pa = dma;\r\ncarveout->va = va;\r\ncarveout->len = rsc->len;\r\ncarveout->dma = dma;\r\ncarveout->da = rsc->da;\r\nlist_add_tail(&carveout->node, &rproc->carveouts);\r\nreturn 0;\r\nfree_mapping:\r\nkfree(mapping);\r\ndma_free:\r\ndma_free_coherent(dev->parent, rsc->len, va, dma);\r\nfree_carv:\r\nkfree(carveout);\r\nreturn ret;\r\n}\r\nstatic int rproc_count_vrings(struct rproc *rproc, struct fw_rsc_vdev *rsc,\r\nint offset, int avail)\r\n{\r\nrproc->max_notifyid += rsc->num_of_vrings;\r\nreturn 0;\r\n}\r\nstatic int rproc_handle_resources(struct rproc *rproc, int len,\r\nrproc_handle_resource_t handlers[RSC_LAST])\r\n{\r\nstruct device *dev = &rproc->dev;\r\nrproc_handle_resource_t handler;\r\nint ret = 0, i;\r\nfor (i = 0; i < rproc->table_ptr->num; i++) {\r\nint offset = rproc->table_ptr->offset[i];\r\nstruct fw_rsc_hdr *hdr = (void *)rproc->table_ptr + offset;\r\nint avail = len - offset - sizeof(*hdr);\r\nvoid *rsc = (void *)hdr + sizeof(*hdr);\r\nif (avail < 0) {\r\ndev_err(dev, "rsc table is truncated\n");\r\nreturn -EINVAL;\r\n}\r\ndev_dbg(dev, "rsc: type %d\n", hdr->type);\r\nif (hdr->type >= RSC_LAST) {\r\ndev_warn(dev, "unsupported resource %d\n", hdr->type);\r\ncontinue;\r\n}\r\nhandler = handlers[hdr->type];\r\nif (!handler)\r\ncontinue;\r\nret = handler(rproc, rsc, offset + sizeof(*hdr), avail);\r\nif (ret)\r\nbreak;\r\n}\r\nreturn ret;\r\n}\r\nstatic void rproc_resource_cleanup(struct rproc *rproc)\r\n{\r\nstruct rproc_mem_entry *entry, *tmp;\r\nstruct device *dev = &rproc->dev;\r\nlist_for_each_entry_safe(entry, tmp, &rproc->traces, node) {\r\nrproc_remove_trace_file(entry->priv);\r\nrproc->num_traces--;\r\nlist_del(&entry->node);\r\nkfree(entry);\r\n}\r\nlist_for_each_entry_safe(entry, tmp, &rproc->mappings, node) {\r\nsize_t unmapped;\r\nunmapped = iommu_unmap(rproc->domain, entry->da, entry->len);\r\nif (unmapped != entry->len) {\r\ndev_err(dev, "failed to unmap %u/%zu\n", entry->len,\r\nunmapped);\r\n}\r\nlist_del(&entry->node);\r\nkfree(entry);\r\n}\r\nlist_for_each_entry_safe(entry, tmp, &rproc->carveouts, node) {\r\ndma_free_coherent(dev->parent, entry->len, entry->va,\r\nentry->dma);\r\nlist_del(&entry->node);\r\nkfree(entry);\r\n}\r\n}\r\nstatic int rproc_fw_boot(struct rproc *rproc, const struct firmware *fw)\r\n{\r\nstruct device *dev = &rproc->dev;\r\nconst char *name = rproc->firmware;\r\nstruct resource_table *table, *loaded_table;\r\nint ret, tablesz;\r\nif (!rproc->table_ptr)\r\nreturn -ENOMEM;\r\nret = rproc_fw_sanity_check(rproc, fw);\r\nif (ret)\r\nreturn ret;\r\ndev_info(dev, "Booting fw image %s, size %zd\n", name, fw->size);\r\nret = rproc_enable_iommu(rproc);\r\nif (ret) {\r\ndev_err(dev, "can't enable iommu: %d\n", ret);\r\nreturn ret;\r\n}\r\nrproc->bootaddr = rproc_get_boot_addr(rproc, fw);\r\nret = -EINVAL;\r\ntable = rproc_find_rsc_table(rproc, fw, &tablesz);\r\nif (!table)\r\ngoto clean_up;\r\nif (rproc->table_csum != crc32(0, table, tablesz)) {\r\ndev_err(dev, "resource checksum failed, fw changed?\n");\r\ngoto clean_up;\r\n}\r\nret = rproc_handle_resources(rproc, tablesz, rproc_loading_handlers);\r\nif (ret) {\r\ndev_err(dev, "Failed to process resources: %d\n", ret);\r\ngoto clean_up;\r\n}\r\nret = rproc_load_segments(rproc, fw);\r\nif (ret) {\r\ndev_err(dev, "Failed to load program segments: %d\n", ret);\r\ngoto clean_up;\r\n}\r\nloaded_table = rproc_find_loaded_rsc_table(rproc, fw);\r\nif (!loaded_table) {\r\nret = -EINVAL;\r\ngoto clean_up;\r\n}\r\nmemcpy(loaded_table, rproc->cached_table, tablesz);\r\nret = rproc->ops->start(rproc);\r\nif (ret) {\r\ndev_err(dev, "can't start rproc %s: %d\n", rproc->name, ret);\r\ngoto clean_up;\r\n}\r\nrproc->table_ptr = loaded_table;\r\nrproc->state = RPROC_RUNNING;\r\ndev_info(dev, "remote processor %s is now up\n", rproc->name);\r\nreturn 0;\r\nclean_up:\r\nrproc_resource_cleanup(rproc);\r\nrproc_disable_iommu(rproc);\r\nreturn ret;\r\n}\r\nstatic void rproc_fw_config_virtio(const struct firmware *fw, void *context)\r\n{\r\nstruct rproc *rproc = context;\r\nstruct resource_table *table;\r\nint ret, tablesz;\r\nif (rproc_fw_sanity_check(rproc, fw) < 0)\r\ngoto out;\r\ntable = rproc_find_rsc_table(rproc, fw, &tablesz);\r\nif (!table)\r\ngoto out;\r\nrproc->table_csum = crc32(0, table, tablesz);\r\nrproc->cached_table = kmemdup(table, tablesz, GFP_KERNEL);\r\nif (!rproc->cached_table)\r\ngoto out;\r\nrproc->table_ptr = rproc->cached_table;\r\nrproc->max_notifyid = -1;\r\nret = rproc_handle_resources(rproc, tablesz,\r\nrproc_count_vrings_handler);\r\nif (ret)\r\ngoto out;\r\nret = rproc_handle_resources(rproc, tablesz, rproc_vdev_handler);\r\nout:\r\nrelease_firmware(fw);\r\ncomplete_all(&rproc->firmware_loading_complete);\r\n}\r\nstatic int rproc_add_virtio_devices(struct rproc *rproc)\r\n{\r\nint ret;\r\ninit_completion(&rproc->firmware_loading_complete);\r\nret = request_firmware_nowait(THIS_MODULE, FW_ACTION_HOTPLUG,\r\nrproc->firmware, &rproc->dev, GFP_KERNEL,\r\nrproc, rproc_fw_config_virtio);\r\nif (ret < 0) {\r\ndev_err(&rproc->dev, "request_firmware_nowait err: %d\n", ret);\r\ncomplete_all(&rproc->firmware_loading_complete);\r\n}\r\nreturn ret;\r\n}\r\nint rproc_trigger_recovery(struct rproc *rproc)\r\n{\r\nstruct rproc_vdev *rvdev, *rvtmp;\r\ndev_err(&rproc->dev, "recovering %s\n", rproc->name);\r\ninit_completion(&rproc->crash_comp);\r\nlist_for_each_entry_safe(rvdev, rvtmp, &rproc->rvdevs, node)\r\nrproc_remove_virtio_dev(rvdev);\r\nwait_for_completion(&rproc->crash_comp);\r\nkfree(rproc->cached_table);\r\nreturn rproc_add_virtio_devices(rproc);\r\n}\r\nstatic void rproc_crash_handler_work(struct work_struct *work)\r\n{\r\nstruct rproc *rproc = container_of(work, struct rproc, crash_handler);\r\nstruct device *dev = &rproc->dev;\r\ndev_dbg(dev, "enter %s\n", __func__);\r\nmutex_lock(&rproc->lock);\r\nif (rproc->state == RPROC_CRASHED || rproc->state == RPROC_OFFLINE) {\r\nmutex_unlock(&rproc->lock);\r\nreturn;\r\n}\r\nrproc->state = RPROC_CRASHED;\r\ndev_err(dev, "handling crash #%u in %s\n", ++rproc->crash_cnt,\r\nrproc->name);\r\nmutex_unlock(&rproc->lock);\r\nif (!rproc->recovery_disabled)\r\nrproc_trigger_recovery(rproc);\r\n}\r\nint rproc_boot(struct rproc *rproc)\r\n{\r\nconst struct firmware *firmware_p;\r\nstruct device *dev;\r\nint ret;\r\nif (!rproc) {\r\npr_err("invalid rproc handle\n");\r\nreturn -EINVAL;\r\n}\r\ndev = &rproc->dev;\r\nret = mutex_lock_interruptible(&rproc->lock);\r\nif (ret) {\r\ndev_err(dev, "can't lock rproc %s: %d\n", rproc->name, ret);\r\nreturn ret;\r\n}\r\nif (!rproc->firmware) {\r\ndev_err(dev, "%s: no firmware to load\n", __func__);\r\nret = -EINVAL;\r\ngoto unlock_mutex;\r\n}\r\nif (!try_module_get(dev->parent->driver->owner)) {\r\ndev_err(dev, "%s: can't get owner\n", __func__);\r\nret = -EINVAL;\r\ngoto unlock_mutex;\r\n}\r\nif (atomic_inc_return(&rproc->power) > 1) {\r\nret = 0;\r\ngoto unlock_mutex;\r\n}\r\ndev_info(dev, "powering up %s\n", rproc->name);\r\nret = request_firmware(&firmware_p, rproc->firmware, dev);\r\nif (ret < 0) {\r\ndev_err(dev, "request_firmware failed: %d\n", ret);\r\ngoto downref_rproc;\r\n}\r\nret = rproc_fw_boot(rproc, firmware_p);\r\nrelease_firmware(firmware_p);\r\ndownref_rproc:\r\nif (ret) {\r\nmodule_put(dev->parent->driver->owner);\r\natomic_dec(&rproc->power);\r\n}\r\nunlock_mutex:\r\nmutex_unlock(&rproc->lock);\r\nreturn ret;\r\n}\r\nvoid rproc_shutdown(struct rproc *rproc)\r\n{\r\nstruct device *dev = &rproc->dev;\r\nint ret;\r\nret = mutex_lock_interruptible(&rproc->lock);\r\nif (ret) {\r\ndev_err(dev, "can't lock rproc %s: %d\n", rproc->name, ret);\r\nreturn;\r\n}\r\nif (!atomic_dec_and_test(&rproc->power))\r\ngoto out;\r\nret = rproc->ops->stop(rproc);\r\nif (ret) {\r\natomic_inc(&rproc->power);\r\ndev_err(dev, "can't stop rproc: %d\n", ret);\r\ngoto out;\r\n}\r\nrproc_resource_cleanup(rproc);\r\nrproc_disable_iommu(rproc);\r\nrproc->table_ptr = rproc->cached_table;\r\nif (rproc->state == RPROC_CRASHED)\r\ncomplete_all(&rproc->crash_comp);\r\nrproc->state = RPROC_OFFLINE;\r\ndev_info(dev, "stopped remote processor %s\n", rproc->name);\r\nout:\r\nmutex_unlock(&rproc->lock);\r\nif (!ret)\r\nmodule_put(dev->parent->driver->owner);\r\n}\r\nstruct rproc *rproc_get_by_phandle(phandle phandle)\r\n{\r\nstruct rproc *rproc = NULL, *r;\r\nstruct device_node *np;\r\nnp = of_find_node_by_phandle(phandle);\r\nif (!np)\r\nreturn NULL;\r\nmutex_lock(&rproc_list_mutex);\r\nlist_for_each_entry(r, &rproc_list, node) {\r\nif (r->dev.parent && r->dev.parent->of_node == np) {\r\nrproc = r;\r\nget_device(&rproc->dev);\r\nbreak;\r\n}\r\n}\r\nmutex_unlock(&rproc_list_mutex);\r\nof_node_put(np);\r\nreturn rproc;\r\n}\r\nstruct rproc *rproc_get_by_phandle(phandle phandle)\r\n{\r\nreturn NULL;\r\n}\r\nint rproc_add(struct rproc *rproc)\r\n{\r\nstruct device *dev = &rproc->dev;\r\nint ret;\r\nret = device_add(dev);\r\nif (ret < 0)\r\nreturn ret;\r\nmutex_lock(&rproc_list_mutex);\r\nlist_add(&rproc->node, &rproc_list);\r\nmutex_unlock(&rproc_list_mutex);\r\ndev_info(dev, "%s is available\n", rproc->name);\r\ndev_info(dev, "Note: remoteproc is still under development and considered experimental.\n");\r\ndev_info(dev, "THE BINARY FORMAT IS NOT YET FINALIZED, and backward compatibility isn't yet guaranteed.\n");\r\nrproc_create_debug_dir(rproc);\r\nreturn rproc_add_virtio_devices(rproc);\r\n}\r\nstatic void rproc_type_release(struct device *dev)\r\n{\r\nstruct rproc *rproc = container_of(dev, struct rproc, dev);\r\ndev_info(&rproc->dev, "releasing %s\n", rproc->name);\r\nrproc_delete_debug_dir(rproc);\r\nidr_destroy(&rproc->notifyids);\r\nif (rproc->index >= 0)\r\nida_simple_remove(&rproc_dev_index, rproc->index);\r\nkfree(rproc);\r\n}\r\nstruct rproc *rproc_alloc(struct device *dev, const char *name,\r\nconst struct rproc_ops *ops,\r\nconst char *firmware, int len)\r\n{\r\nstruct rproc *rproc;\r\nchar *p, *template = "rproc-%s-fw";\r\nint name_len = 0;\r\nif (!dev || !name || !ops)\r\nreturn NULL;\r\nif (!firmware)\r\nname_len = strlen(name) + strlen(template) - 2 + 1;\r\nrproc = kzalloc(sizeof(struct rproc) + len + name_len, GFP_KERNEL);\r\nif (!rproc)\r\nreturn NULL;\r\nif (!firmware) {\r\np = (char *)rproc + sizeof(struct rproc) + len;\r\nsnprintf(p, name_len, template, name);\r\n} else {\r\np = (char *)firmware;\r\n}\r\nrproc->firmware = p;\r\nrproc->name = name;\r\nrproc->ops = ops;\r\nrproc->priv = &rproc[1];\r\ndevice_initialize(&rproc->dev);\r\nrproc->dev.parent = dev;\r\nrproc->dev.type = &rproc_type;\r\nrproc->index = ida_simple_get(&rproc_dev_index, 0, 0, GFP_KERNEL);\r\nif (rproc->index < 0) {\r\ndev_err(dev, "ida_simple_get failed: %d\n", rproc->index);\r\nput_device(&rproc->dev);\r\nreturn NULL;\r\n}\r\ndev_set_name(&rproc->dev, "remoteproc%d", rproc->index);\r\natomic_set(&rproc->power, 0);\r\nrproc->fw_ops = &rproc_elf_fw_ops;\r\nmutex_init(&rproc->lock);\r\nidr_init(&rproc->notifyids);\r\nINIT_LIST_HEAD(&rproc->carveouts);\r\nINIT_LIST_HEAD(&rproc->mappings);\r\nINIT_LIST_HEAD(&rproc->traces);\r\nINIT_LIST_HEAD(&rproc->rvdevs);\r\nINIT_WORK(&rproc->crash_handler, rproc_crash_handler_work);\r\ninit_completion(&rproc->crash_comp);\r\nrproc->state = RPROC_OFFLINE;\r\nreturn rproc;\r\n}\r\nvoid rproc_put(struct rproc *rproc)\r\n{\r\nput_device(&rproc->dev);\r\n}\r\nint rproc_del(struct rproc *rproc)\r\n{\r\nstruct rproc_vdev *rvdev, *tmp;\r\nif (!rproc)\r\nreturn -EINVAL;\r\nwait_for_completion(&rproc->firmware_loading_complete);\r\nlist_for_each_entry_safe(rvdev, tmp, &rproc->rvdevs, node)\r\nrproc_remove_virtio_dev(rvdev);\r\nkfree(rproc->cached_table);\r\nmutex_lock(&rproc_list_mutex);\r\nlist_del(&rproc->node);\r\nmutex_unlock(&rproc_list_mutex);\r\ndevice_del(&rproc->dev);\r\nreturn 0;\r\n}\r\nvoid rproc_report_crash(struct rproc *rproc, enum rproc_crash_type type)\r\n{\r\nif (!rproc) {\r\npr_err("NULL rproc pointer\n");\r\nreturn;\r\n}\r\ndev_err(&rproc->dev, "crash detected in %s: type %s\n",\r\nrproc->name, rproc_crash_to_string(type));\r\nschedule_work(&rproc->crash_handler);\r\n}\r\nstatic int __init remoteproc_init(void)\r\n{\r\nrproc_init_debugfs();\r\nreturn 0;\r\n}\r\nstatic void __exit remoteproc_exit(void)\r\n{\r\nida_destroy(&rproc_dev_index);\r\nrproc_exit_debugfs();\r\n}
