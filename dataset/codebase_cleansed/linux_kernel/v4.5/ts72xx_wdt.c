static int timeout_to_regval(int new_timeout)\r\n{\r\nint i;\r\nnew_timeout = clamp_val(new_timeout, 1, 8);\r\nfor (i = 0; i < ARRAY_SIZE(ts72xx_wdt_map); i++) {\r\nif (ts72xx_wdt_map[i].timeout >= new_timeout)\r\nreturn ts72xx_wdt_map[i].regval;\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int regval_to_timeout(int regval)\r\n{\r\nint i;\r\nfor (i = 0; i < ARRAY_SIZE(ts72xx_wdt_map); i++) {\r\nif (ts72xx_wdt_map[i].regval == regval)\r\nreturn ts72xx_wdt_map[i].timeout;\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic inline void ts72xx_wdt_kick(struct ts72xx_wdt *wdt)\r\n{\r\n__raw_writeb(TS72XX_WDT_FEED_VAL, wdt->feed_reg);\r\n}\r\nstatic void ts72xx_wdt_start(struct ts72xx_wdt *wdt)\r\n{\r\nts72xx_wdt_kick(wdt);\r\n__raw_writeb((u8)wdt->regval, wdt->control_reg);\r\n}\r\nstatic void ts72xx_wdt_stop(struct ts72xx_wdt *wdt)\r\n{\r\nts72xx_wdt_kick(wdt);\r\n__raw_writeb(0, wdt->control_reg);\r\n}\r\nstatic int ts72xx_wdt_open(struct inode *inode, struct file *file)\r\n{\r\nstruct ts72xx_wdt *wdt = platform_get_drvdata(ts72xx_wdt_pdev);\r\nint regval;\r\nregval = timeout_to_regval(timeout);\r\nif (regval < 0) {\r\ndev_err(&wdt->pdev->dev,\r\n"failed to convert timeout (%d) to register value\n",\r\ntimeout);\r\nreturn regval;\r\n}\r\nif (mutex_lock_interruptible(&wdt->lock))\r\nreturn -ERESTARTSYS;\r\nif ((wdt->flags & TS72XX_WDT_BUSY_FLAG) != 0) {\r\nmutex_unlock(&wdt->lock);\r\nreturn -EBUSY;\r\n}\r\nwdt->flags = TS72XX_WDT_BUSY_FLAG;\r\nwdt->regval = regval;\r\nfile->private_data = wdt;\r\nts72xx_wdt_start(wdt);\r\nmutex_unlock(&wdt->lock);\r\nreturn nonseekable_open(inode, file);\r\n}\r\nstatic int ts72xx_wdt_release(struct inode *inode, struct file *file)\r\n{\r\nstruct ts72xx_wdt *wdt = file->private_data;\r\nif (mutex_lock_interruptible(&wdt->lock))\r\nreturn -ERESTARTSYS;\r\nif ((wdt->flags & TS72XX_WDT_EXPECT_CLOSE_FLAG) != 0) {\r\nts72xx_wdt_stop(wdt);\r\n} else {\r\ndev_warn(&wdt->pdev->dev,\r\n"TS-72XX WDT device closed unexpectly. "\r\n"Watchdog timer will not stop!\n");\r\nts72xx_wdt_kick(wdt);\r\n}\r\nwdt->flags = 0;\r\nmutex_unlock(&wdt->lock);\r\nreturn 0;\r\n}\r\nstatic ssize_t ts72xx_wdt_write(struct file *file,\r\nconst char __user *data,\r\nsize_t len,\r\nloff_t *ppos)\r\n{\r\nstruct ts72xx_wdt *wdt = file->private_data;\r\nif (!len)\r\nreturn 0;\r\nif (mutex_lock_interruptible(&wdt->lock))\r\nreturn -ERESTARTSYS;\r\nts72xx_wdt_kick(wdt);\r\nif (!nowayout) {\r\nint i;\r\nfor (i = 0; i < len; i++) {\r\nchar c;\r\nwdt->flags &= ~TS72XX_WDT_EXPECT_CLOSE_FLAG;\r\nif (get_user(c, data + i)) {\r\nmutex_unlock(&wdt->lock);\r\nreturn -EFAULT;\r\n}\r\nif (c == 'V') {\r\nwdt->flags |= TS72XX_WDT_EXPECT_CLOSE_FLAG;\r\nbreak;\r\n}\r\n}\r\n}\r\nmutex_unlock(&wdt->lock);\r\nreturn len;\r\n}\r\nstatic long ts72xx_wdt_ioctl(struct file *file, unsigned int cmd,\r\nunsigned long arg)\r\n{\r\nstruct ts72xx_wdt *wdt = file->private_data;\r\nvoid __user *argp = (void __user *)arg;\r\nint __user *p = (int __user *)argp;\r\nint error = 0;\r\nif (mutex_lock_interruptible(&wdt->lock))\r\nreturn -ERESTARTSYS;\r\nswitch (cmd) {\r\ncase WDIOC_GETSUPPORT:\r\nif (copy_to_user(argp, &winfo, sizeof(winfo)))\r\nerror = -EFAULT;\r\nbreak;\r\ncase WDIOC_GETSTATUS:\r\ncase WDIOC_GETBOOTSTATUS:\r\nerror = put_user(0, p);\r\nbreak;\r\ncase WDIOC_KEEPALIVE:\r\nts72xx_wdt_kick(wdt);\r\nbreak;\r\ncase WDIOC_SETOPTIONS: {\r\nint options;\r\nerror = get_user(options, p);\r\nif (error)\r\nbreak;\r\nerror = -EINVAL;\r\nif ((options & WDIOS_DISABLECARD) != 0) {\r\nts72xx_wdt_stop(wdt);\r\nerror = 0;\r\n}\r\nif ((options & WDIOS_ENABLECARD) != 0) {\r\nts72xx_wdt_start(wdt);\r\nerror = 0;\r\n}\r\nbreak;\r\n}\r\ncase WDIOC_SETTIMEOUT: {\r\nint new_timeout;\r\nint regval;\r\nerror = get_user(new_timeout, p);\r\nif (error)\r\nbreak;\r\nregval = timeout_to_regval(new_timeout);\r\nif (regval < 0) {\r\nerror = regval;\r\nbreak;\r\n}\r\nts72xx_wdt_stop(wdt);\r\nwdt->regval = regval;\r\nts72xx_wdt_start(wdt);\r\n}\r\ncase WDIOC_GETTIMEOUT:\r\nerror = put_user(regval_to_timeout(wdt->regval), p);\r\nbreak;\r\ndefault:\r\nerror = -ENOTTY;\r\nbreak;\r\n}\r\nmutex_unlock(&wdt->lock);\r\nreturn error;\r\n}\r\nstatic int ts72xx_wdt_probe(struct platform_device *pdev)\r\n{\r\nstruct ts72xx_wdt *wdt;\r\nstruct resource *r1, *r2;\r\nint error = 0;\r\nwdt = devm_kzalloc(&pdev->dev, sizeof(struct ts72xx_wdt), GFP_KERNEL);\r\nif (!wdt)\r\nreturn -ENOMEM;\r\nr1 = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nwdt->control_reg = devm_ioremap_resource(&pdev->dev, r1);\r\nif (IS_ERR(wdt->control_reg))\r\nreturn PTR_ERR(wdt->control_reg);\r\nr2 = platform_get_resource(pdev, IORESOURCE_MEM, 1);\r\nwdt->feed_reg = devm_ioremap_resource(&pdev->dev, r2);\r\nif (IS_ERR(wdt->feed_reg))\r\nreturn PTR_ERR(wdt->feed_reg);\r\nplatform_set_drvdata(pdev, wdt);\r\nts72xx_wdt_pdev = pdev;\r\nwdt->pdev = pdev;\r\nmutex_init(&wdt->lock);\r\nts72xx_wdt_stop(wdt);\r\nerror = misc_register(&ts72xx_wdt_miscdev);\r\nif (error) {\r\ndev_err(&pdev->dev, "failed to register miscdev\n");\r\nreturn error;\r\n}\r\ndev_info(&pdev->dev, "TS-72xx Watchdog driver\n");\r\nreturn 0;\r\n}\r\nstatic int ts72xx_wdt_remove(struct platform_device *pdev)\r\n{\r\nmisc_deregister(&ts72xx_wdt_miscdev);\r\nreturn 0;\r\n}
