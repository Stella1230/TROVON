static char *dgap_getword(char **in)\r\n{\r\nchar *ret_ptr = *in;\r\nchar *ptr = strpbrk(*in, " \t\n");\r\nif (!ptr)\r\nreturn NULL;\r\n*ptr = '\0';\r\n*in = ptr + 1;\r\nwhile (*in && **in && ((**in == ' ') ||\r\n(**in == '\t') ||\r\n(**in == '\n'))) {\r\n**in = '\0';\r\n*in = *in + 1;\r\n}\r\nreturn ret_ptr;\r\n}\r\nstatic int dgap_gettok(char **in)\r\n{\r\nchar *w;\r\nstruct toklist *t;\r\nif (strstr(dgap_cword, "board")) {\r\nw = dgap_getword(in);\r\nif (!w)\r\nreturn 0;\r\nsnprintf(dgap_cword, MAXCWORD, "%s", w);\r\nfor (t = dgap_brdtype; t->token != 0; t++) {\r\nif (!strcmp(w, t->string))\r\nreturn t->token;\r\n}\r\n} else {\r\nwhile ((w = dgap_getword(in))) {\r\nsnprintf(dgap_cword, MAXCWORD, "%s", w);\r\nfor (t = dgap_tlist; t->token != 0; t++) {\r\nif (!strcmp(w, t->string))\r\nreturn t->token;\r\n}\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int dgap_checknode(struct cnode *p)\r\n{\r\nswitch (p->type) {\r\ncase LNODE:\r\nif (p->u.line.v_speed == 0) {\r\npr_err("line speed not specified");\r\nreturn 1;\r\n}\r\nreturn 0;\r\ncase CNODE:\r\nif (p->u.conc.v_speed == 0) {\r\npr_err("concentrator line speed not specified");\r\nreturn 1;\r\n}\r\nif (p->u.conc.v_nport == 0) {\r\npr_err("number of ports on concentrator not specified");\r\nreturn 1;\r\n}\r\nif (p->u.conc.v_id == 0) {\r\npr_err("concentrator id letter not specified");\r\nreturn 1;\r\n}\r\nreturn 0;\r\ncase MNODE:\r\nif (p->u.module.v_nport == 0) {\r\npr_err("number of ports on EBI module not specified");\r\nreturn 1;\r\n}\r\nif (p->u.module.v_id == 0) {\r\npr_err("EBI module id letter not specified");\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}\r\nreturn 0;\r\n}\r\nstatic uint dgap_config_get_useintr(struct board_t *bd)\r\n{\r\nstruct cnode *p;\r\nif (!bd)\r\nreturn 0;\r\nfor (p = bd->bd_config; p; p = p->next) {\r\nif (p->type == INTRNODE) {\r\nreturn p->u.useintr;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic uint dgap_config_get_altpin(struct board_t *bd)\r\n{\r\nstruct cnode *p;\r\nif (!bd)\r\nreturn 0;\r\nfor (p = bd->bd_config; p; p = p->next) {\r\nif (p->type == ANODE) {\r\nreturn p->u.altpin;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic struct cnode *dgap_find_config(int type, int bus, int slot)\r\n{\r\nstruct cnode *p, *prev, *prev2, *found;\r\np = &dgap_head;\r\nwhile (p->next) {\r\nprev = p;\r\np = p->next;\r\nif (p->type != BNODE)\r\ncontinue;\r\nif (p->u.board.type != type)\r\ncontinue;\r\nif (p->u.board.v_pcibus &&\r\np->u.board.pcibus != bus)\r\ncontinue;\r\nif (p->u.board.v_pcislot &&\r\np->u.board.pcislot != slot)\r\ncontinue;\r\nfound = p;\r\nwhile (p->next) {\r\nprev2 = p;\r\np = p->next;\r\nif (p->type != BNODE)\r\ncontinue;\r\nprev2->next = NULL;\r\nprev->next = p;\r\nreturn found;\r\n}\r\nprev->next = NULL;\r\nreturn found;\r\n}\r\nreturn NULL;\r\n}\r\nstatic uint dgap_config_get_num_prts(struct board_t *bd)\r\n{\r\nint count = 0;\r\nstruct cnode *p;\r\nif (!bd)\r\nreturn 0;\r\nfor (p = bd->bd_config; p; p = p->next) {\r\nswitch (p->type) {\r\ncase BNODE:\r\nif (p->u.board.type > EPCFE)\r\ncount += p->u.board.nport;\r\nbreak;\r\ncase CNODE:\r\ncount += p->u.conc.nport;\r\nbreak;\r\ncase MNODE:\r\ncount += p->u.module.nport;\r\nbreak;\r\n}\r\n}\r\nreturn count;\r\n}\r\nstatic char *dgap_create_config_string(struct board_t *bd, char *string)\r\n{\r\nchar *ptr = string;\r\nstruct cnode *p;\r\nstruct cnode *q;\r\nint speed;\r\nif (!bd) {\r\n*ptr = 0xff;\r\nreturn string;\r\n}\r\nfor (p = bd->bd_config; p; p = p->next) {\r\nswitch (p->type) {\r\ncase LNODE:\r\n*ptr = '\0';\r\nptr++;\r\n*ptr = p->u.line.speed;\r\nptr++;\r\nbreak;\r\ncase CNODE:\r\nspeed = p->u.conc.speed;\r\nq = p->next;\r\nif (q && (q->type == MNODE)) {\r\n*ptr = (p->u.conc.nport + 0x80);\r\nptr++;\r\np = q;\r\nwhile (q->next && (q->next->type) == MNODE) {\r\n*ptr = (q->u.module.nport + 0x80);\r\nptr++;\r\np = q;\r\nq = q->next;\r\n}\r\n*ptr = q->u.module.nport;\r\nptr++;\r\n} else {\r\n*ptr = p->u.conc.nport;\r\nptr++;\r\n}\r\n*ptr = speed;\r\nptr++;\r\nbreak;\r\n}\r\n}\r\n*ptr = 0xff;\r\nreturn string;\r\n}\r\nstatic int dgap_parsefile(char **in)\r\n{\r\nstruct cnode *p, *brd, *line, *conc;\r\nint rc;\r\nchar *s;\r\nint linecnt = 0;\r\np = &dgap_head;\r\nbrd = line = conc = NULL;\r\nwhile (p->next)\r\np = p->next;\r\nwhile ((rc = dgap_gettok(in)) != BEGIN) {\r\nif (rc == 0) {\r\npr_err("unexpected EOF");\r\nreturn -1;\r\n}\r\n}\r\nfor (; ;) {\r\nint board_type = 0;\r\nint conc_type = 0;\r\nint module_type = 0;\r\nrc = dgap_gettok(in);\r\nif (rc == 0) {\r\npr_err("unexpected EOF");\r\nreturn -1;\r\n}\r\nswitch (rc) {\r\ncase BEGIN:\r\npr_err("unexpected config_begin\n");\r\nreturn -1;\r\ncase END:\r\nreturn 0;\r\ncase BOARD:\r\nif (dgap_checknode(p))\r\nreturn -1;\r\np->next = kzalloc(sizeof(struct cnode), GFP_KERNEL);\r\nif (!p->next)\r\nreturn -ENOMEM;\r\np = p->next;\r\np->type = BNODE;\r\np->u.board.status = kstrdup("No", GFP_KERNEL);\r\nline = conc = NULL;\r\nbrd = p;\r\nlinecnt = -1;\r\nboard_type = dgap_gettok(in);\r\nif (board_type == 0) {\r\npr_err("board !!type not specified");\r\nreturn -1;\r\n}\r\np->u.board.type = board_type;\r\nbreak;\r\ncase MEM:\r\nif (p->type != BNODE) {\r\npr_err("memory address only valid for boards");\r\nreturn -1;\r\n}\r\ns = dgap_getword(in);\r\nif (!s) {\r\npr_err("unexpected end of file");\r\nreturn -1;\r\n}\r\nkfree(p->u.board.addrstr);\r\np->u.board.addrstr = kstrdup(s, GFP_KERNEL);\r\nif (kstrtoul(s, 0, &p->u.board.addr)) {\r\npr_err("bad number for memory address");\r\nreturn -1;\r\n}\r\np->u.board.v_addr = 1;\r\nbreak;\r\ncase PCIINFO:\r\nif (p->type != BNODE) {\r\npr_err("memory address only valid for boards");\r\nreturn -1;\r\n}\r\ns = dgap_getword(in);\r\nif (!s) {\r\npr_err("unexpected end of file");\r\nreturn -1;\r\n}\r\nkfree(p->u.board.pcibusstr);\r\np->u.board.pcibusstr = kstrdup(s, GFP_KERNEL);\r\nif (kstrtoul(s, 0, &p->u.board.pcibus)) {\r\npr_err("bad number for pci bus");\r\nreturn -1;\r\n}\r\np->u.board.v_pcibus = 1;\r\ns = dgap_getword(in);\r\nif (!s) {\r\npr_err("unexpected end of file");\r\nreturn -1;\r\n}\r\nkfree(p->u.board.pcislotstr);\r\np->u.board.pcislotstr = kstrdup(s, GFP_KERNEL);\r\nif (kstrtoul(s, 0, &p->u.board.pcislot)) {\r\npr_err("bad number for pci slot");\r\nreturn -1;\r\n}\r\np->u.board.v_pcislot = 1;\r\nbreak;\r\ncase METHOD:\r\nif (p->type != BNODE) {\r\npr_err("install method only valid for boards");\r\nreturn -1;\r\n}\r\ns = dgap_getword(in);\r\nif (!s) {\r\npr_err("unexpected end of file");\r\nreturn -1;\r\n}\r\nkfree(p->u.board.method);\r\np->u.board.method = kstrdup(s, GFP_KERNEL);\r\np->u.board.v_method = 1;\r\nbreak;\r\ncase STATUS:\r\nif (p->type != BNODE) {\r\npr_err("config status only valid for boards");\r\nreturn -1;\r\n}\r\ns = dgap_getword(in);\r\nif (!s) {\r\npr_err("unexpected end of file");\r\nreturn -1;\r\n}\r\nkfree(p->u.board.status);\r\np->u.board.status = kstrdup(s, GFP_KERNEL);\r\nbreak;\r\ncase NPORTS:\r\nif (p->type == BNODE) {\r\ns = dgap_getword(in);\r\nif (!s) {\r\npr_err("unexpected end of file");\r\nreturn -1;\r\n}\r\nif (kstrtol(s, 0, &p->u.board.nport)) {\r\npr_err("bad number for number of ports");\r\nreturn -1;\r\n}\r\np->u.board.v_nport = 1;\r\n} else if (p->type == CNODE) {\r\ns = dgap_getword(in);\r\nif (!s) {\r\npr_err("unexpected end of file");\r\nreturn -1;\r\n}\r\nif (kstrtol(s, 0, &p->u.conc.nport)) {\r\npr_err("bad number for number of ports");\r\nreturn -1;\r\n}\r\np->u.conc.v_nport = 1;\r\n} else if (p->type == MNODE) {\r\ns = dgap_getword(in);\r\nif (!s) {\r\npr_err("unexpected end of file");\r\nreturn -1;\r\n}\r\nif (kstrtol(s, 0, &p->u.module.nport)) {\r\npr_err("bad number for number of ports");\r\nreturn -1;\r\n}\r\np->u.module.v_nport = 1;\r\n} else {\r\npr_err("nports only valid for concentrators or modules");\r\nreturn -1;\r\n}\r\nbreak;\r\ncase ID:\r\ns = dgap_getword(in);\r\nif (!s) {\r\npr_err("unexpected end of file");\r\nreturn -1;\r\n}\r\nkfree(p->u.board.status);\r\np->u.board.status = kstrdup(s, GFP_KERNEL);\r\nif (p->type == CNODE) {\r\nkfree(p->u.conc.id);\r\np->u.conc.id = kstrdup(s, GFP_KERNEL);\r\np->u.conc.v_id = 1;\r\n} else if (p->type == MNODE) {\r\nkfree(p->u.module.id);\r\np->u.module.id = kstrdup(s, GFP_KERNEL);\r\np->u.module.v_id = 1;\r\n} else {\r\npr_err("id only valid for concentrators or modules");\r\nreturn -1;\r\n}\r\nbreak;\r\ncase STARTO:\r\nif (p->type == BNODE) {\r\ns = dgap_getword(in);\r\nif (!s) {\r\npr_err("unexpected end of file");\r\nreturn -1;\r\n}\r\nif (kstrtol(s, 0, &p->u.board.start)) {\r\npr_err("bad number for start of tty count");\r\nreturn -1;\r\n}\r\np->u.board.v_start = 1;\r\n} else if (p->type == CNODE) {\r\ns = dgap_getword(in);\r\nif (!s) {\r\npr_err("unexpected end of file");\r\nreturn -1;\r\n}\r\nif (kstrtol(s, 0, &p->u.conc.start)) {\r\npr_err("bad number for start of tty count");\r\nreturn -1;\r\n}\r\np->u.conc.v_start = 1;\r\n} else if (p->type == MNODE) {\r\ns = dgap_getword(in);\r\nif (!s) {\r\npr_err("unexpected end of file");\r\nreturn -1;\r\n}\r\nif (kstrtol(s, 0, &p->u.module.start)) {\r\npr_err("bad number for start of tty count");\r\nreturn -1;\r\n}\r\np->u.module.v_start = 1;\r\n} else {\r\npr_err("start only valid for concentrators or modules");\r\nreturn -1;\r\n}\r\nbreak;\r\ncase TTYN:\r\nif (dgap_checknode(p))\r\nreturn -1;\r\np->next = kzalloc(sizeof(struct cnode), GFP_KERNEL);\r\nif (!p->next)\r\nreturn -ENOMEM;\r\np = p->next;\r\np->type = TNODE;\r\ns = dgap_getword(in);\r\nif (!s) {\r\npr_err("unexpeced end of file");\r\nreturn -1;\r\n}\r\np->u.ttyname = kstrdup(s, GFP_KERNEL);\r\nif (!p->u.ttyname)\r\nreturn -1;\r\nbreak;\r\ncase CU:\r\nif (dgap_checknode(p))\r\nreturn -1;\r\np->next = kzalloc(sizeof(struct cnode), GFP_KERNEL);\r\nif (!p->next)\r\nreturn -ENOMEM;\r\np = p->next;\r\np->type = CUNODE;\r\ns = dgap_getword(in);\r\nif (!s) {\r\npr_err("unexpeced end of file");\r\nreturn -1;\r\n}\r\np->u.cuname = kstrdup(s, GFP_KERNEL);\r\nif (!p->u.cuname)\r\nreturn -1;\r\nbreak;\r\ncase LINE:\r\nif (dgap_checknode(p))\r\nreturn -1;\r\nif (!brd) {\r\npr_err("must specify board before line info");\r\nreturn -1;\r\n}\r\nswitch (brd->u.board.type) {\r\ncase PPCM:\r\npr_err("line not valid for PC/em");\r\nreturn -1;\r\n}\r\np->next = kzalloc(sizeof(struct cnode), GFP_KERNEL);\r\nif (!p->next)\r\nreturn -ENOMEM;\r\np = p->next;\r\np->type = LNODE;\r\nconc = NULL;\r\nline = p;\r\nlinecnt++;\r\nbreak;\r\ncase CONC:\r\nif (dgap_checknode(p))\r\nreturn -1;\r\nif (!line) {\r\npr_err("must specify line info before concentrator");\r\nreturn -1;\r\n}\r\np->next = kzalloc(sizeof(struct cnode), GFP_KERNEL);\r\nif (!p->next)\r\nreturn -ENOMEM;\r\np = p->next;\r\np->type = CNODE;\r\nconc = p;\r\nif (linecnt)\r\nbrd->u.board.conc2++;\r\nelse\r\nbrd->u.board.conc1++;\r\nconc_type = dgap_gettok(in);\r\nif (conc_type == 0 ||\r\n(conc_type != CX && conc_type != EPC)) {\r\npr_err("failed to set a type of concentratros");\r\nreturn -1;\r\n}\r\np->u.conc.type = conc_type;\r\nbreak;\r\ncase MOD:\r\nif (dgap_checknode(p))\r\nreturn -1;\r\nif (!brd) {\r\npr_err("must specify board info before EBI modules");\r\nreturn -1;\r\n}\r\nswitch (brd->u.board.type) {\r\ncase PPCM:\r\nlinecnt = 0;\r\nbreak;\r\ndefault:\r\nif (!conc) {\r\npr_err("must specify concentrator info before EBI module");\r\nreturn -1;\r\n}\r\n}\r\np->next = kzalloc(sizeof(struct cnode), GFP_KERNEL);\r\nif (!p->next)\r\nreturn -ENOMEM;\r\np = p->next;\r\np->type = MNODE;\r\nif (linecnt)\r\nbrd->u.board.module2++;\r\nelse\r\nbrd->u.board.module1++;\r\nmodule_type = dgap_gettok(in);\r\nif (module_type == 0 ||\r\n(module_type != PORTS && module_type != MODEM)) {\r\npr_err("failed to set a type of module");\r\nreturn -1;\r\n}\r\np->u.module.type = module_type;\r\nbreak;\r\ncase CABLE:\r\nif (p->type == LNODE) {\r\ns = dgap_getword(in);\r\nif (!s) {\r\npr_err("unexpected end of file");\r\nreturn -1;\r\n}\r\nkfree(p->u.line.cable);\r\np->u.line.cable = kstrdup(s, GFP_KERNEL);\r\np->u.line.v_cable = 1;\r\n}\r\nbreak;\r\ncase SPEED:\r\nif (p->type == LNODE) {\r\ns = dgap_getword(in);\r\nif (!s) {\r\npr_err("unexpected end of file");\r\nreturn -1;\r\n}\r\nif (kstrtol(s, 0, &p->u.line.speed)) {\r\npr_err("bad number for line speed");\r\nreturn -1;\r\n}\r\np->u.line.v_speed = 1;\r\n} else if (p->type == CNODE) {\r\ns = dgap_getword(in);\r\nif (!s) {\r\npr_err("unexpected end of file");\r\nreturn -1;\r\n}\r\nif (kstrtol(s, 0, &p->u.conc.speed)) {\r\npr_err("bad number for line speed");\r\nreturn -1;\r\n}\r\np->u.conc.v_speed = 1;\r\n} else {\r\npr_err("speed valid only for lines or concentrators.");\r\nreturn -1;\r\n}\r\nbreak;\r\ncase CONNECT:\r\nif (p->type == CNODE) {\r\ns = dgap_getword(in);\r\nif (!s) {\r\npr_err("unexpected end of file");\r\nreturn -1;\r\n}\r\nkfree(p->u.conc.connect);\r\np->u.conc.connect = kstrdup(s, GFP_KERNEL);\r\np->u.conc.v_connect = 1;\r\n}\r\nbreak;\r\ncase PRINT:\r\nif (dgap_checknode(p))\r\nreturn -1;\r\np->next = kzalloc(sizeof(struct cnode), GFP_KERNEL);\r\nif (!p->next)\r\nreturn -ENOMEM;\r\np = p->next;\r\np->type = PNODE;\r\ns = dgap_getword(in);\r\nif (!s) {\r\npr_err("unexpeced end of file");\r\nreturn -1;\r\n}\r\np->u.printname = kstrdup(s, GFP_KERNEL);\r\nif (!p->u.printname)\r\nreturn -1;\r\nbreak;\r\ncase CMAJOR:\r\nif (dgap_checknode(p))\r\nreturn -1;\r\np->next = kzalloc(sizeof(struct cnode), GFP_KERNEL);\r\nif (!p->next)\r\nreturn -ENOMEM;\r\np = p->next;\r\np->type = JNODE;\r\ns = dgap_getword(in);\r\nif (!s) {\r\npr_err("unexpected end of file");\r\nreturn -1;\r\n}\r\nif (kstrtol(s, 0, &p->u.majornumber)) {\r\npr_err("bad number for major number");\r\nreturn -1;\r\n}\r\nbreak;\r\ncase ALTPIN:\r\nif (dgap_checknode(p))\r\nreturn -1;\r\np->next = kzalloc(sizeof(struct cnode), GFP_KERNEL);\r\nif (!p->next)\r\nreturn -ENOMEM;\r\np = p->next;\r\np->type = ANODE;\r\ns = dgap_getword(in);\r\nif (!s) {\r\npr_err("unexpected end of file");\r\nreturn -1;\r\n}\r\nif (kstrtol(s, 0, &p->u.altpin)) {\r\npr_err("bad number for altpin");\r\nreturn -1;\r\n}\r\nbreak;\r\ncase USEINTR:\r\nif (dgap_checknode(p))\r\nreturn -1;\r\np->next = kzalloc(sizeof(struct cnode), GFP_KERNEL);\r\nif (!p->next)\r\nreturn -ENOMEM;\r\np = p->next;\r\np->type = INTRNODE;\r\ns = dgap_getword(in);\r\nif (!s) {\r\npr_err("unexpected end of file");\r\nreturn -1;\r\n}\r\nif (kstrtol(s, 0, &p->u.useintr)) {\r\npr_err("bad number for useintr");\r\nreturn -1;\r\n}\r\nbreak;\r\ncase TTSIZ:\r\nif (dgap_checknode(p))\r\nreturn -1;\r\np->next = kzalloc(sizeof(struct cnode), GFP_KERNEL);\r\nif (!p->next)\r\nreturn -ENOMEM;\r\np = p->next;\r\np->type = TSNODE;\r\ns = dgap_getword(in);\r\nif (!s) {\r\npr_err("unexpected end of file");\r\nreturn -1;\r\n}\r\nif (kstrtol(s, 0, &p->u.ttysize)) {\r\npr_err("bad number for ttysize");\r\nreturn -1;\r\n}\r\nbreak;\r\ncase CHSIZ:\r\nif (dgap_checknode(p))\r\nreturn -1;\r\np->next = kzalloc(sizeof(struct cnode), GFP_KERNEL);\r\nif (!p->next)\r\nreturn -ENOMEM;\r\np = p->next;\r\np->type = CSNODE;\r\ns = dgap_getword(in);\r\nif (!s) {\r\npr_err("unexpected end of file");\r\nreturn -1;\r\n}\r\nif (kstrtol(s, 0, &p->u.chsize)) {\r\npr_err("bad number for chsize");\r\nreturn -1;\r\n}\r\nbreak;\r\ncase BSSIZ:\r\nif (dgap_checknode(p))\r\nreturn -1;\r\np->next = kzalloc(sizeof(struct cnode), GFP_KERNEL);\r\nif (!p->next)\r\nreturn -ENOMEM;\r\np = p->next;\r\np->type = BSNODE;\r\ns = dgap_getword(in);\r\nif (!s) {\r\npr_err("unexpected end of file");\r\nreturn -1;\r\n}\r\nif (kstrtol(s, 0, &p->u.bssize)) {\r\npr_err("bad number for bssize");\r\nreturn -1;\r\n}\r\nbreak;\r\ncase UNTSIZ:\r\nif (dgap_checknode(p))\r\nreturn -1;\r\np->next = kzalloc(sizeof(struct cnode), GFP_KERNEL);\r\nif (!p->next)\r\nreturn -ENOMEM;\r\np = p->next;\r\np->type = USNODE;\r\ns = dgap_getword(in);\r\nif (!s) {\r\npr_err("unexpected end of file");\r\nreturn -1;\r\n}\r\nif (kstrtol(s, 0, &p->u.unsize)) {\r\npr_err("bad number for schedsize");\r\nreturn -1;\r\n}\r\nbreak;\r\ncase F2SIZ:\r\nif (dgap_checknode(p))\r\nreturn -1;\r\np->next = kzalloc(sizeof(struct cnode), GFP_KERNEL);\r\nif (!p->next)\r\nreturn -ENOMEM;\r\np = p->next;\r\np->type = FSNODE;\r\ns = dgap_getword(in);\r\nif (!s) {\r\npr_err("unexpected end of file");\r\nreturn -1;\r\n}\r\nif (kstrtol(s, 0, &p->u.f2size)) {\r\npr_err("bad number for f2200size");\r\nreturn -1;\r\n}\r\nbreak;\r\ncase VPSIZ:\r\nif (dgap_checknode(p))\r\nreturn -1;\r\np->next = kzalloc(sizeof(struct cnode), GFP_KERNEL);\r\nif (!p->next)\r\nreturn -ENOMEM;\r\np = p->next;\r\np->type = VSNODE;\r\ns = dgap_getword(in);\r\nif (!s) {\r\npr_err("unexpected end of file");\r\nreturn -1;\r\n}\r\nif (kstrtol(s, 0, &p->u.vpixsize)) {\r\npr_err("bad number for vpixsize");\r\nreturn -1;\r\n}\r\nbreak;\r\n}\r\n}\r\n}\r\nstatic void dgap_cleanup_nodes(void)\r\n{\r\nstruct cnode *p;\r\np = &dgap_head;\r\nwhile (p) {\r\nstruct cnode *tmp = p->next;\r\nif (p->type == NULLNODE) {\r\np = tmp;\r\ncontinue;\r\n}\r\nswitch (p->type) {\r\ncase BNODE:\r\nkfree(p->u.board.addrstr);\r\nkfree(p->u.board.pcibusstr);\r\nkfree(p->u.board.pcislotstr);\r\nkfree(p->u.board.method);\r\nbreak;\r\ncase CNODE:\r\nkfree(p->u.conc.id);\r\nkfree(p->u.conc.connect);\r\nbreak;\r\ncase MNODE:\r\nkfree(p->u.module.id);\r\nbreak;\r\ncase TNODE:\r\nkfree(p->u.ttyname);\r\nbreak;\r\ncase CUNODE:\r\nkfree(p->u.cuname);\r\nbreak;\r\ncase LNODE:\r\nkfree(p->u.line.cable);\r\nbreak;\r\ncase PNODE:\r\nkfree(p->u.printname);\r\nbreak;\r\n}\r\nkfree(p->u.board.status);\r\nkfree(p);\r\np = tmp;\r\n}\r\n}\r\nstatic uint dgap_get_custom_baud(struct channel_t *ch)\r\n{\r\nu8 __iomem *vaddr;\r\nulong offset;\r\nif (!ch || ch->magic != DGAP_CHANNEL_MAGIC)\r\nreturn 0;\r\nif (!ch->ch_bd || ch->ch_bd->magic != DGAP_BOARD_MAGIC)\r\nreturn 0;\r\nif (!(ch->ch_bd->bd_flags & BD_FEP5PLUS))\r\nreturn 0;\r\nvaddr = ch->ch_bd->re_map_membase;\r\nif (!vaddr)\r\nreturn 0;\r\noffset = (ioread16(vaddr + ECS_SEG) << 4) + (ch->ch_portnum * 0x28)\r\n+ LINE_SPEED;\r\nreturn readw(vaddr + offset);\r\n}\r\nstatic int dgap_remap(struct board_t *brd)\r\n{\r\nif (!brd || brd->magic != DGAP_BOARD_MAGIC)\r\nreturn -EIO;\r\nif (!request_mem_region(brd->membase, 0x200000, "dgap"))\r\nreturn -ENOMEM;\r\nif (!request_mem_region(brd->membase + PCI_IO_OFFSET, 0x200000, "dgap"))\r\ngoto err_req_mem;\r\nbrd->re_map_membase = ioremap(brd->membase, 0x200000);\r\nif (!brd->re_map_membase)\r\ngoto err_remap_mem;\r\nbrd->re_map_port = ioremap((brd->membase + PCI_IO_OFFSET), 0x200000);\r\nif (!brd->re_map_port)\r\ngoto err_remap_port;\r\nreturn 0;\r\nerr_remap_port:\r\niounmap(brd->re_map_membase);\r\nerr_remap_mem:\r\nrelease_mem_region(brd->membase + PCI_IO_OFFSET, 0x200000);\r\nerr_req_mem:\r\nrelease_mem_region(brd->membase, 0x200000);\r\nreturn -ENOMEM;\r\n}\r\nstatic void dgap_unmap(struct board_t *brd)\r\n{\r\niounmap(brd->re_map_port);\r\niounmap(brd->re_map_membase);\r\nrelease_mem_region(brd->membase + PCI_IO_OFFSET, 0x200000);\r\nrelease_mem_region(brd->membase, 0x200000);\r\n}\r\nstatic void dgap_parity_scan(struct channel_t *ch, unsigned char *cbuf,\r\nunsigned char *fbuf, int *len)\r\n{\r\nint l = *len;\r\nint count = 0;\r\nunsigned char *in, *cout, *fout;\r\nunsigned char c;\r\nin = cbuf;\r\ncout = cbuf;\r\nfout = fbuf;\r\nif (!ch || ch->magic != DGAP_CHANNEL_MAGIC)\r\nreturn;\r\nwhile (l--) {\r\nc = *in++;\r\nswitch (ch->pscan_state) {\r\ndefault:\r\nch->pscan_state = 0;\r\ncase 0:\r\nif (c == (unsigned char)'\377')\r\nch->pscan_state = 1;\r\nelse {\r\n*cout++ = c;\r\n*fout++ = TTY_NORMAL;\r\ncount += 1;\r\n}\r\nbreak;\r\ncase 1:\r\nif (c == (unsigned char)'\377') {\r\n*cout++ = c;\r\n*fout++ = TTY_NORMAL;\r\ncount += 1;\r\nch->pscan_state = 0;\r\n} else {\r\nch->pscan_savechar = c;\r\nch->pscan_state = 2;\r\n}\r\nbreak;\r\ncase 2:\r\n*cout++ = c;\r\nif (ch->pscan_savechar == 0x0) {\r\nif (c == 0x0) {\r\nch->ch_err_break++;\r\n*fout++ = TTY_BREAK;\r\n} else {\r\nch->ch_err_parity++;\r\n*fout++ = TTY_PARITY;\r\n}\r\n}\r\ncount += 1;\r\nch->pscan_state = 0;\r\n}\r\n}\r\n*len = count;\r\n}\r\nstatic void dgap_input(struct channel_t *ch)\r\n{\r\nstruct board_t *bd;\r\nstruct bs_t __iomem *bs;\r\nstruct tty_struct *tp;\r\nstruct tty_ldisc *ld;\r\nuint rmask;\r\nuint head;\r\nuint tail;\r\nint data_len;\r\nulong lock_flags;\r\nulong lock_flags2;\r\nint flip_len;\r\nint len;\r\nint n;\r\nu8 *buf;\r\nu8 tmpchar;\r\nint s;\r\nif (!ch || ch->magic != DGAP_CHANNEL_MAGIC)\r\nreturn;\r\ntp = ch->ch_tun.un_tty;\r\nbs = ch->ch_bs;\r\nif (!bs)\r\nreturn;\r\nbd = ch->ch_bd;\r\nif (!bd || bd->magic != DGAP_BOARD_MAGIC)\r\nreturn;\r\nspin_lock_irqsave(&bd->bd_lock, lock_flags);\r\nspin_lock_irqsave(&ch->ch_lock, lock_flags2);\r\nrmask = ch->ch_rsize - 1;\r\nhead = readw(&bs->rx_head);\r\nhead &= rmask;\r\ntail = readw(&bs->rx_tail);\r\ntail &= rmask;\r\ndata_len = (head - tail) & rmask;\r\nif (data_len == 0) {\r\nwriteb(1, &bs->idata);\r\nspin_unlock_irqrestore(&ch->ch_lock, lock_flags2);\r\nspin_unlock_irqrestore(&bd->bd_lock, lock_flags);\r\nreturn;\r\n}\r\nif ((bd->state != BOARD_READY) || !tp ||\r\n(tp->magic != TTY_MAGIC) ||\r\n!(ch->ch_tun.un_flags & UN_ISOPEN) ||\r\n!(tp->termios.c_cflag & CREAD) ||\r\n(ch->ch_tun.un_flags & UN_CLOSING)) {\r\nwritew(head, &bs->rx_tail);\r\nwriteb(1, &bs->idata);\r\nspin_unlock_irqrestore(&ch->ch_lock, lock_flags2);\r\nspin_unlock_irqrestore(&bd->bd_lock, lock_flags);\r\nreturn;\r\n}\r\nif (ch->ch_flags & CH_RXBLOCK) {\r\nwriteb(1, &bs->idata);\r\nspin_unlock_irqrestore(&ch->ch_lock, lock_flags2);\r\nspin_unlock_irqrestore(&bd->bd_lock, lock_flags);\r\nreturn;\r\n}\r\ntmpchar = readb(&bs->orun);\r\nif (tmpchar) {\r\nch->ch_err_overrun++;\r\nwriteb(0, &bs->orun);\r\n}\r\nflip_len = TTY_FLIPBUF_SIZE;\r\nlen = min(data_len, flip_len);\r\nlen = min(len, (N_TTY_BUF_SIZE - 1));\r\nld = tty_ldisc_ref(tp);\r\n#ifdef TTY_DONT_FLIP\r\nif (test_bit(TTY_DONT_FLIP, &tp->flags))\r\nlen = 0;\r\n#endif\r\nif (!ld) {\r\nlen = 0;\r\n} else {\r\nif (!ld->ops->receive_buf) {\r\nwritew(head, &bs->rx_tail);\r\nlen = 0;\r\n}\r\n}\r\nif (len <= 0) {\r\nwriteb(1, &bs->idata);\r\nspin_unlock_irqrestore(&ch->ch_lock, lock_flags2);\r\nspin_unlock_irqrestore(&bd->bd_lock, lock_flags);\r\nif (ld)\r\ntty_ldisc_deref(ld);\r\nreturn;\r\n}\r\nbuf = ch->ch_bd->flipbuf;\r\nn = len;\r\nwhile (n) {\r\ns = ((head >= tail) ? head : ch->ch_rsize) - tail;\r\ns = min(s, n);\r\nif (s <= 0)\r\nbreak;\r\nmemcpy_fromio(buf, ch->ch_raddr + tail, s);\r\ntail += s;\r\nbuf += s;\r\nn -= s;\r\ntail &= rmask;\r\n}\r\nwritew(tail, &bs->rx_tail);\r\nwriteb(1, &bs->idata);\r\nch->ch_rxcount += len;\r\nif (I_PARMRK(tp) || I_BRKINT(tp) || I_INPCK(tp)) {\r\ndgap_parity_scan(ch, ch->ch_bd->flipbuf,\r\nch->ch_bd->flipflagbuf, &len);\r\nlen = tty_buffer_request_room(tp->port, len);\r\ntty_insert_flip_string_flags(tp->port, ch->ch_bd->flipbuf,\r\nch->ch_bd->flipflagbuf, len);\r\n} else {\r\nlen = tty_buffer_request_room(tp->port, len);\r\ntty_insert_flip_string(tp->port, ch->ch_bd->flipbuf, len);\r\n}\r\nspin_unlock_irqrestore(&ch->ch_lock, lock_flags2);\r\nspin_unlock_irqrestore(&bd->bd_lock, lock_flags);\r\ntty_flip_buffer_push(tp->port);\r\nif (ld)\r\ntty_ldisc_deref(ld);\r\n}\r\nstatic void dgap_write_wakeup(struct board_t *bd, struct channel_t *ch,\r\nstruct un_t *un, u32 mask,\r\nunsigned long *irq_flags1,\r\nunsigned long *irq_flags2)\r\n{\r\nif (!(un->un_flags & mask))\r\nreturn;\r\nun->un_flags &= ~mask;\r\nif (!(un->un_flags & UN_ISOPEN))\r\nreturn;\r\nif ((un->un_tty->flags & (1 << TTY_DO_WRITE_WAKEUP)) &&\r\nun->un_tty->ldisc->ops->write_wakeup) {\r\nspin_unlock_irqrestore(&ch->ch_lock, *irq_flags2);\r\nspin_unlock_irqrestore(&bd->bd_lock, *irq_flags1);\r\n(un->un_tty->ldisc->ops->write_wakeup)(un->un_tty);\r\nspin_lock_irqsave(&bd->bd_lock, *irq_flags1);\r\nspin_lock_irqsave(&ch->ch_lock, *irq_flags2);\r\n}\r\nwake_up_interruptible(&un->un_tty->write_wait);\r\nwake_up_interruptible(&un->un_flags_wait);\r\n}\r\nstatic void dgap_carrier(struct channel_t *ch)\r\n{\r\nstruct board_t *bd;\r\nint virt_carrier = 0;\r\nint phys_carrier = 0;\r\nif (!ch || ch->magic != DGAP_CHANNEL_MAGIC)\r\nreturn;\r\nbd = ch->ch_bd;\r\nif (!bd || bd->magic != DGAP_BOARD_MAGIC)\r\nreturn;\r\nif (ch->ch_digi.digi_flags & DIGI_ALTPIN) {\r\nch->ch_dsr = DM_CD;\r\nch->ch_cd = DM_DSR;\r\n} else {\r\nch->ch_dsr = DM_DSR;\r\nch->ch_cd = DM_CD;\r\n}\r\nif (ch->ch_mistat & D_CD(ch))\r\nphys_carrier = 1;\r\nif (ch->ch_digi.digi_flags & DIGI_FORCEDCD)\r\nvirt_carrier = 1;\r\nif (ch->ch_c_cflag & CLOCAL)\r\nvirt_carrier = 1;\r\nif (((ch->ch_flags & CH_FCAR) == 0) && (virt_carrier == 1)) {\r\nif (waitqueue_active(&(ch->ch_flags_wait)))\r\nwake_up_interruptible(&ch->ch_flags_wait);\r\n}\r\nif (((ch->ch_flags & CH_CD) == 0) && (phys_carrier == 1)) {\r\nif (waitqueue_active(&(ch->ch_flags_wait)))\r\nwake_up_interruptible(&ch->ch_flags_wait);\r\n}\r\nif ((virt_carrier == 0) &&\r\n((ch->ch_flags & CH_CD) != 0) &&\r\n(phys_carrier == 0)) {\r\nif (waitqueue_active(&(ch->ch_flags_wait)))\r\nwake_up_interruptible(&ch->ch_flags_wait);\r\nif (ch->ch_tun.un_open_count > 0)\r\ntty_hangup(ch->ch_tun.un_tty);\r\nif (ch->ch_pun.un_open_count > 0)\r\ntty_hangup(ch->ch_pun.un_tty);\r\n}\r\nif (virt_carrier == 1)\r\nch->ch_flags |= CH_FCAR;\r\nelse\r\nch->ch_flags &= ~CH_FCAR;\r\nif (phys_carrier == 1)\r\nch->ch_flags |= CH_CD;\r\nelse\r\nch->ch_flags &= ~CH_CD;\r\n}\r\nstatic int dgap_event(struct board_t *bd)\r\n{\r\nstruct channel_t *ch;\r\nulong lock_flags;\r\nulong lock_flags2;\r\nstruct bs_t __iomem *bs;\r\nu8 __iomem *event;\r\nu8 __iomem *vaddr;\r\nstruct ev_t __iomem *eaddr;\r\nuint head;\r\nuint tail;\r\nint port;\r\nint reason;\r\nint modem;\r\nif (!bd || bd->magic != DGAP_BOARD_MAGIC)\r\nreturn -EIO;\r\nspin_lock_irqsave(&bd->bd_lock, lock_flags);\r\nvaddr = bd->re_map_membase;\r\nif (!vaddr) {\r\nspin_unlock_irqrestore(&bd->bd_lock, lock_flags);\r\nreturn -EIO;\r\n}\r\neaddr = (struct ev_t __iomem *)(vaddr + EVBUF);\r\nhead = readw(&eaddr->ev_head);\r\ntail = readw(&eaddr->ev_tail);\r\nif (head >= EVMAX - EVSTART || tail >= EVMAX - EVSTART ||\r\n(head | tail) & 03) {\r\nspin_unlock_irqrestore(&bd->bd_lock, lock_flags);\r\nreturn -EIO;\r\n}\r\nwhile (tail != head) {\r\nevent = bd->re_map_membase + tail + EVSTART;\r\nport = ioread8(event);\r\nreason = ioread8(event + 1);\r\nmodem = ioread8(event + 2);\r\nioread8(event + 3);\r\nif (port >= bd->nasync)\r\ngoto next;\r\nif (!(reason & (IFMODEM | IFBREAK | IFTLW | IFTEM | IFDATA)))\r\ngoto next;\r\nch = bd->channels[port];\r\nif (!ch || ch->magic != DGAP_CHANNEL_MAGIC)\r\ngoto next;\r\nspin_lock_irqsave(&ch->ch_lock, lock_flags2);\r\nbs = ch->ch_bs;\r\nif (!bs) {\r\nspin_unlock_irqrestore(&ch->ch_lock, lock_flags2);\r\ngoto next;\r\n}\r\nif (reason & IFDATA) {\r\nspin_unlock_irqrestore(&ch->ch_lock, lock_flags2);\r\nspin_unlock_irqrestore(&bd->bd_lock, lock_flags);\r\ndgap_input(ch);\r\nspin_lock_irqsave(&bd->bd_lock, lock_flags);\r\nspin_lock_irqsave(&ch->ch_lock, lock_flags2);\r\nif (ch->ch_flags & CH_RACTIVE)\r\nch->ch_flags |= CH_RENABLE;\r\nelse\r\nwriteb(1, &bs->idata);\r\nif (ch->ch_flags & CH_RWAIT) {\r\nch->ch_flags &= ~CH_RWAIT;\r\nwake_up_interruptible\r\n(&ch->ch_tun.un_flags_wait);\r\n}\r\n}\r\nif (reason & IFMODEM) {\r\nch->ch_mistat = modem;\r\ndgap_carrier(ch);\r\n}\r\nif (reason & IFBREAK) {\r\nif (ch->ch_tun.un_tty) {\r\nch->ch_err_break++;\r\ntty_buffer_request_room\r\n(ch->ch_tun.un_tty->port, 1);\r\ntty_insert_flip_char(ch->ch_tun.un_tty->port,\r\n0, TTY_BREAK);\r\ntty_flip_buffer_push(ch->ch_tun.un_tty->port);\r\n}\r\n}\r\nif (reason & IFTLW) {\r\ndgap_write_wakeup(bd, ch, &ch->ch_tun, UN_LOW,\r\n&lock_flags, &lock_flags2);\r\ndgap_write_wakeup(bd, ch, &ch->ch_pun, UN_LOW,\r\n&lock_flags, &lock_flags2);\r\nif (ch->ch_flags & CH_WLOW) {\r\nch->ch_flags &= ~CH_WLOW;\r\nwake_up_interruptible(&ch->ch_flags_wait);\r\n}\r\n}\r\nif (reason & IFTEM) {\r\ndgap_write_wakeup(bd, ch, &ch->ch_tun, UN_EMPTY,\r\n&lock_flags, &lock_flags2);\r\ndgap_write_wakeup(bd, ch, &ch->ch_pun, UN_EMPTY,\r\n&lock_flags, &lock_flags2);\r\nif (ch->ch_flags & CH_WEMPTY) {\r\nch->ch_flags &= ~CH_WEMPTY;\r\nwake_up_interruptible(&ch->ch_flags_wait);\r\n}\r\n}\r\nspin_unlock_irqrestore(&ch->ch_lock, lock_flags2);\r\nnext:\r\ntail = (tail + 4) & (EVMAX - EVSTART - 4);\r\n}\r\nwritew(tail, &eaddr->ev_tail);\r\nspin_unlock_irqrestore(&bd->bd_lock, lock_flags);\r\nreturn 0;\r\n}\r\nstatic void dgap_poll_tasklet(unsigned long data)\r\n{\r\nstruct board_t *bd = (struct board_t *)data;\r\nulong lock_flags;\r\nchar __iomem *vaddr;\r\nu16 head, tail;\r\nif (!bd || (bd->magic != DGAP_BOARD_MAGIC))\r\nreturn;\r\nif (bd->inhibit_poller)\r\nreturn;\r\nspin_lock_irqsave(&bd->bd_lock, lock_flags);\r\nvaddr = bd->re_map_membase;\r\nif (bd->state == BOARD_READY) {\r\nstruct ev_t __iomem *eaddr;\r\nif (!bd->re_map_membase) {\r\nspin_unlock_irqrestore(&bd->bd_lock, lock_flags);\r\nreturn;\r\n}\r\nif (!bd->re_map_port) {\r\nspin_unlock_irqrestore(&bd->bd_lock, lock_flags);\r\nreturn;\r\n}\r\nif (!bd->nasync)\r\ngoto out;\r\neaddr = (struct ev_t __iomem *)(vaddr + EVBUF);\r\nhead = readw(&eaddr->ev_head);\r\ntail = readw(&eaddr->ev_tail);\r\nif (head != tail) {\r\nspin_unlock_irqrestore(&bd->bd_lock, lock_flags);\r\ndgap_event(bd);\r\nspin_lock_irqsave(&bd->bd_lock, lock_flags);\r\n}\r\nout:\r\nif (bd->intr_running)\r\nreadb(bd->re_map_port + 2);\r\nspin_unlock_irqrestore(&bd->bd_lock, lock_flags);\r\nreturn;\r\n}\r\nspin_unlock_irqrestore(&bd->bd_lock, lock_flags);\r\n}\r\nstatic struct board_t *dgap_found_board(struct pci_dev *pdev, int id,\r\nint boardnum)\r\n{\r\nstruct board_t *brd;\r\nunsigned int pci_irq;\r\nint i;\r\nint ret;\r\nbrd = kzalloc(sizeof(struct board_t), GFP_KERNEL);\r\nif (!brd)\r\nreturn ERR_PTR(-ENOMEM);\r\nbrd->magic = DGAP_BOARD_MAGIC;\r\nbrd->boardnum = boardnum;\r\nbrd->vendor = dgap_pci_tbl[id].vendor;\r\nbrd->device = dgap_pci_tbl[id].device;\r\nbrd->pdev = pdev;\r\nbrd->pci_bus = pdev->bus->number;\r\nbrd->pci_slot = PCI_SLOT(pdev->devfn);\r\nbrd->name = dgap_ids[id].name;\r\nbrd->maxports = dgap_ids[id].maxports;\r\nbrd->type = dgap_ids[id].config_type;\r\nbrd->dpatype = dgap_ids[id].dpatype;\r\nbrd->dpastatus = BD_NOFEP;\r\ninit_waitqueue_head(&brd->state_wait);\r\nspin_lock_init(&brd->bd_lock);\r\nbrd->inhibit_poller = FALSE;\r\nbrd->wait_for_bios = 0;\r\nbrd->wait_for_fep = 0;\r\nfor (i = 0; i < MAXPORTS; i++)\r\nbrd->channels[i] = NULL;\r\npci_read_config_word(pdev, PCI_SUBSYSTEM_VENDOR_ID, &brd->subvendor);\r\npci_read_config_word(pdev, PCI_SUBSYSTEM_ID, &brd->subdevice);\r\npci_read_config_byte(pdev, PCI_REVISION_ID, &brd->rev);\r\npci_irq = pdev->irq;\r\nbrd->irq = pci_irq;\r\nif (brd->device == PCI_DEV_XRJ_DID || brd->device == PCI_DEV_EPCJ_DID) {\r\nbrd->membase = pci_resource_start(pdev, 2);\r\nbrd->membase_end = pci_resource_end(pdev, 2);\r\n}\r\nelse {\r\nbrd->membase = pci_resource_start(pdev, 0);\r\nbrd->membase_end = pci_resource_end(pdev, 0);\r\n}\r\nif (!brd->membase) {\r\nret = -ENODEV;\r\ngoto free_brd;\r\n}\r\nif (brd->membase & 1)\r\nbrd->membase &= ~3;\r\nelse\r\nbrd->membase &= ~15;\r\nbrd->port = brd->membase + PCI_IO_OFFSET;\r\nbrd->port_end = brd->port + PCI_IO_SIZE_DGAP;\r\nif (brd->device != PCI_DEV_XRJ_DID && brd->device != PCI_DEV_EPCJ_DID) {\r\nunsigned short cmd;\r\npci_write_config_byte(pdev, 0x40, 0);\r\npci_write_config_byte(pdev, 0x46, 0);\r\npci_write_config_byte(pdev, 0x42, 1);\r\npci_read_config_word(pdev, PCI_COMMAND, &cmd);\r\ncmd |= (PCI_COMMAND_IO | PCI_COMMAND_MEMORY);\r\npci_write_config_word(pdev, PCI_COMMAND, cmd);\r\n}\r\ntasklet_init(&brd->helper_tasklet, dgap_poll_tasklet,\r\n(unsigned long)brd);\r\nret = dgap_remap(brd);\r\nif (ret)\r\ngoto free_brd;\r\npr_info("dgap: board %d: %s (rev %d), irq %ld\n",\r\nboardnum, brd->name, brd->rev, brd->irq);\r\nreturn brd;\r\nfree_brd:\r\nkfree(brd);\r\nreturn ERR_PTR(ret);\r\n}\r\nstatic irqreturn_t dgap_intr(int irq, void *voidbrd)\r\n{\r\nstruct board_t *brd = voidbrd;\r\nif (!brd)\r\nreturn IRQ_NONE;\r\nif (brd->magic != DGAP_BOARD_MAGIC)\r\nreturn IRQ_NONE;\r\nbrd->intr_count++;\r\ntasklet_schedule(&brd->helper_tasklet);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void dgap_poll_handler(ulong dummy)\r\n{\r\nunsigned int i;\r\nstruct board_t *brd;\r\nunsigned long lock_flags;\r\nulong new_time;\r\ndgap_poll_counter++;\r\nif (dgap_driver_state != DRIVER_READY)\r\ngoto schedule_poller;\r\nif ((dgap_numboards == 1) || (num_online_cpus() <= 1)) {\r\nfor (i = 0; i < dgap_numboards; i++) {\r\nbrd = dgap_board[i];\r\nif (brd->state == BOARD_FAILED)\r\ncontinue;\r\nif (!brd->intr_running)\r\ndgap_poll_tasklet((unsigned long)brd);\r\n}\r\n} else {\r\nfor (i = 0; i < dgap_numboards; i++) {\r\nbrd = dgap_board[i];\r\nif (!spin_trylock(&brd->bd_lock))\r\ncontinue;\r\nif (brd->state == BOARD_FAILED) {\r\nspin_unlock(&brd->bd_lock);\r\ncontinue;\r\n}\r\nif (!brd->intr_running)\r\ntasklet_schedule(&brd->helper_tasklet);\r\nspin_unlock(&brd->bd_lock);\r\n}\r\n}\r\nschedule_poller:\r\nspin_lock_irqsave(&dgap_poll_lock, lock_flags);\r\ndgap_poll_time += dgap_jiffies_from_ms(dgap_poll_tick);\r\nnew_time = dgap_poll_time - jiffies;\r\nif ((ulong)new_time >= 2 * dgap_poll_tick) {\r\ndgap_poll_time =\r\njiffies + dgap_jiffies_from_ms(dgap_poll_tick);\r\n}\r\ndgap_poll_timer.function = dgap_poll_handler;\r\ndgap_poll_timer.data = 0;\r\ndgap_poll_timer.expires = dgap_poll_time;\r\nspin_unlock_irqrestore(&dgap_poll_lock, lock_flags);\r\nif (!dgap_poll_stop)\r\nadd_timer(&dgap_poll_timer);\r\n}\r\nstatic void dgap_cmdb(struct channel_t *ch, u8 cmd, u8 byte1,\r\nu8 byte2, uint ncmds)\r\n{\r\nchar __iomem *vaddr;\r\nstruct __iomem cm_t *cm_addr;\r\nuint count;\r\nuint n;\r\nu16 head;\r\nu16 tail;\r\nif (!ch || ch->magic != DGAP_CHANNEL_MAGIC)\r\nreturn;\r\nif (ch->ch_bd->state == BOARD_FAILED)\r\nreturn;\r\nvaddr = ch->ch_bd->re_map_membase;\r\nif (!vaddr)\r\nreturn;\r\ncm_addr = (struct cm_t __iomem *)(vaddr + CMDBUF);\r\nhead = readw(&cm_addr->cm_head);\r\nif (head >= (CMDMAX - CMDSTART) || (head & 03)) {\r\nch->ch_bd->state = BOARD_FAILED;\r\nreturn;\r\n}\r\nwriteb(cmd, (vaddr + head + CMDSTART + 0));\r\nwriteb((u8)ch->ch_portnum, (vaddr + head + CMDSTART + 1));\r\nwriteb(byte1, (vaddr + head + CMDSTART + 2));\r\nwriteb(byte2, (vaddr + head + CMDSTART + 3));\r\nhead = (head + 4) & (CMDMAX - CMDSTART - 4);\r\nwritew(head, &cm_addr->cm_head);\r\nfor (count = dgap_count ;;) {\r\nhead = readw(&cm_addr->cm_head);\r\ntail = readw(&cm_addr->cm_tail);\r\nn = (head - tail) & (CMDMAX - CMDSTART - 4);\r\nif (n <= ncmds * sizeof(struct cm_t))\r\nbreak;\r\nif (--count == 0) {\r\nch->ch_bd->state = BOARD_FAILED;\r\nreturn;\r\n}\r\nudelay(10);\r\n}\r\n}\r\nstatic void dgap_cmdw(struct channel_t *ch, u8 cmd, u16 word, uint ncmds)\r\n{\r\nchar __iomem *vaddr;\r\nstruct __iomem cm_t *cm_addr;\r\nuint count;\r\nuint n;\r\nu16 head;\r\nu16 tail;\r\nif (!ch || ch->magic != DGAP_CHANNEL_MAGIC)\r\nreturn;\r\nif (ch->ch_bd->state == BOARD_FAILED)\r\nreturn;\r\nvaddr = ch->ch_bd->re_map_membase;\r\nif (!vaddr)\r\nreturn;\r\ncm_addr = (struct cm_t __iomem *)(vaddr + CMDBUF);\r\nhead = readw(&cm_addr->cm_head);\r\nif (head >= (CMDMAX - CMDSTART) || (head & 03)) {\r\nch->ch_bd->state = BOARD_FAILED;\r\nreturn;\r\n}\r\nwriteb(cmd, (vaddr + head + CMDSTART + 0));\r\nwriteb((u8)ch->ch_portnum, (vaddr + head + CMDSTART + 1));\r\nwritew((u16)word, (vaddr + head + CMDSTART + 2));\r\nhead = (head + 4) & (CMDMAX - CMDSTART - 4);\r\nwritew(head, &cm_addr->cm_head);\r\nfor (count = dgap_count ;;) {\r\nhead = readw(&cm_addr->cm_head);\r\ntail = readw(&cm_addr->cm_tail);\r\nn = (head - tail) & (CMDMAX - CMDSTART - 4);\r\nif (n <= ncmds * sizeof(struct cm_t))\r\nbreak;\r\nif (--count == 0) {\r\nch->ch_bd->state = BOARD_FAILED;\r\nreturn;\r\n}\r\nudelay(10);\r\n}\r\n}\r\nstatic void dgap_cmdw_ext(struct channel_t *ch, u16 cmd, u16 word, uint ncmds)\r\n{\r\nchar __iomem *vaddr;\r\nstruct __iomem cm_t *cm_addr;\r\nuint count;\r\nuint n;\r\nu16 head;\r\nu16 tail;\r\nif (!ch || ch->magic != DGAP_CHANNEL_MAGIC)\r\nreturn;\r\nif (ch->ch_bd->state == BOARD_FAILED)\r\nreturn;\r\nvaddr = ch->ch_bd->re_map_membase;\r\nif (!vaddr)\r\nreturn;\r\ncm_addr = (struct cm_t __iomem *)(vaddr + CMDBUF);\r\nhead = readw(&cm_addr->cm_head);\r\nif (head >= (CMDMAX - CMDSTART) || (head & 03)) {\r\nch->ch_bd->state = BOARD_FAILED;\r\nreturn;\r\n}\r\nwriteb((u8)0xff, (vaddr + head + CMDSTART + 0));\r\nwriteb((u8)ch->ch_portnum, (vaddr + head + CMDSTART + 1));\r\nwritew((u16)cmd, (vaddr + head + CMDSTART + 2));\r\nif (((head + 4) >= ((CMDMAX - CMDSTART)) || (head & 03)))\r\nwritew((u16)word, (vaddr + CMDSTART));\r\nelse\r\nwritew((u16)word, (vaddr + head + CMDSTART + 4));\r\nhead = (head + 8) & (CMDMAX - CMDSTART - 4);\r\nwritew(head, &cm_addr->cm_head);\r\nfor (count = dgap_count ;;) {\r\nhead = readw(&cm_addr->cm_head);\r\ntail = readw(&cm_addr->cm_tail);\r\nn = (head - tail) & (CMDMAX - CMDSTART - 4);\r\nif (n <= ncmds * sizeof(struct cm_t))\r\nbreak;\r\nif (--count == 0) {\r\nch->ch_bd->state = BOARD_FAILED;\r\nreturn;\r\n}\r\nudelay(10);\r\n}\r\n}\r\nstatic void dgap_wmove(struct channel_t *ch, char *buf, uint cnt)\r\n{\r\nint n;\r\nchar __iomem *taddr;\r\nstruct bs_t __iomem *bs;\r\nu16 head;\r\nif (!ch || ch->magic != DGAP_CHANNEL_MAGIC)\r\nreturn;\r\nbs = ch->ch_bs;\r\nhead = readw(&bs->tx_head);\r\nif ((cnt > ch->ch_tsize) ||\r\n(unsigned)(head - ch->ch_tstart) >= ch->ch_tsize)\r\nreturn;\r\nn = ch->ch_tstart + ch->ch_tsize - head;\r\nif (cnt >= n) {\r\ncnt -= n;\r\ntaddr = ch->ch_taddr + head;\r\nmemcpy_toio(taddr, buf, n);\r\nhead = ch->ch_tstart;\r\nbuf += n;\r\n}\r\ntaddr = ch->ch_taddr + head;\r\nn = cnt;\r\nmemcpy_toio(taddr, buf, n);\r\nhead += cnt;\r\nwritew(head, &bs->tx_head);\r\n}\r\nstatic void dgap_firmware_reset_port(struct channel_t *ch)\r\n{\r\ndgap_cmdb(ch, CHRESET, 0, 0, 0);\r\nch->ch_fepiflag = 0;\r\nch->ch_fepcflag = 0;\r\nch->ch_fepoflag = 0;\r\nch->ch_fepstartc = 0;\r\nch->ch_fepstopc = 0;\r\nch->ch_fepastartc = 0;\r\nch->ch_fepastopc = 0;\r\nch->ch_mostat = 0;\r\nch->ch_hflow = 0;\r\n}\r\nstatic int dgap_param(struct channel_t *ch, struct board_t *bd, u32 un_type)\r\n{\r\nu16 head;\r\nu16 cflag;\r\nu16 iflag;\r\nu8 mval;\r\nu8 hflow;\r\nif ((ch->ch_c_cflag & (CBAUD)) == 0) {\r\nhead = readw(&ch->ch_bs->rx_head);\r\nwritew(head, &ch->ch_bs->rx_tail);\r\nhead = readw(&ch->ch_bs->tx_head);\r\nwritew(head, &ch->ch_bs->tx_tail);\r\nch->ch_flags |= (CH_BAUD0);\r\nch->ch_mval &= ~(D_RTS(ch) | D_DTR(ch));\r\nmval = D_DTR(ch) | D_RTS(ch);\r\nch->ch_baud_info = 0;\r\n} else if (ch->ch_custom_speed && (bd->bd_flags & BD_FEP5PLUS)) {\r\ndgap_cmdw_ext(ch, 0xff01, ch->ch_custom_speed, 0);\r\nch->ch_custom_speed = dgap_get_custom_baud(ch);\r\nch->ch_baud_info = ch->ch_custom_speed;\r\nif (ch->ch_flags & CH_BAUD0) {\r\nch->ch_flags &= ~(CH_BAUD0);\r\nch->ch_mval |= (D_RTS(ch) | D_DTR(ch));\r\n}\r\nmval = D_DTR(ch) | D_RTS(ch);\r\n} else {\r\nint iindex = 0;\r\nint jindex = 0;\r\nint baud = 0;\r\nulong bauds[4][16] = {\r\n{\r\n0, 50, 75, 110,\r\n134, 150, 200, 300,\r\n600, 1200, 1800, 2400,\r\n4800, 9600, 19200, 38400 },\r\n{\r\n0, 57600, 115200, 230400,\r\n460800, 150, 200, 921600,\r\n600, 1200, 1800, 2400,\r\n4800, 9600, 19200, 38400 },\r\n{\r\n0, 57600, 76800, 115200,\r\n14400, 57600, 230400, 76800,\r\n115200, 230400, 28800, 460800,\r\n921600, 9600, 19200, 38400 },\r\n{\r\n0, 57600, 115200, 230400,\r\n460800, 150, 200, 921600,\r\n600, 1200, 1800, 2400,\r\n4800, 9600, 19200, 38400 }\r\n};\r\nif (!(ch->ch_tun.un_flags & UN_ISOPEN) &&\r\nun_type == DGAP_PRINT)\r\nbaud = C_BAUD(ch->ch_pun.un_tty) & 0xff;\r\nelse\r\nbaud = C_BAUD(ch->ch_tun.un_tty) & 0xff;\r\nif (ch->ch_c_cflag & CBAUDEX)\r\niindex = 1;\r\nif (ch->ch_digi.digi_flags & DIGI_FAST)\r\niindex += 2;\r\njindex = baud;\r\nif ((iindex >= 0) && (iindex < 4) &&\r\n(jindex >= 0) && (jindex < 16))\r\nbaud = bauds[iindex][jindex];\r\nelse\r\nbaud = 0;\r\nif (baud == 0)\r\nbaud = 9600;\r\nch->ch_baud_info = baud;\r\ncflag = ch->ch_c_cflag & ((CBAUD ^ CBAUDEX) | PARODD | PARENB |\r\nCSTOPB | CSIZE);\r\nif ((ch->ch_digi.digi_flags & DIGI_FAST) ||\r\n(ch->ch_c_cflag & CBAUDEX))\r\ncflag |= HUPCL;\r\nif ((ch->ch_c_cflag & CBAUDEX) &&\r\n!(ch->ch_digi.digi_flags & DIGI_FAST)) {\r\ntcflag_t tcflag = (ch->ch_c_cflag & CBAUD) | CBAUDEX;\r\nint baudpart = 0;\r\nswitch (tcflag) {\r\ncase B57600:\r\nbaudpart = 1;\r\nbreak;\r\n#ifdef B76800\r\ncase B76800:\r\nbaudpart = 2;\r\nbreak;\r\n#endif\r\ncase B115200:\r\nbaudpart = 3;\r\nbreak;\r\ncase B230400:\r\nbaudpart = 9;\r\nbreak;\r\ncase B460800:\r\nbaudpart = 11;\r\nbreak;\r\n#ifdef B921600\r\ncase B921600:\r\nbaudpart = 12;\r\nbreak;\r\n#endif\r\ndefault:\r\nbaudpart = 0;\r\n}\r\nif (baudpart)\r\ncflag = (cflag & ~(CBAUD | CBAUDEX)) | baudpart;\r\n}\r\ncflag &= 0xffff;\r\nif (cflag != ch->ch_fepcflag) {\r\nch->ch_fepcflag = (u16)(cflag & 0xffff);\r\ndgap_cmdw(ch, SCFLAG, (u16)cflag, 0);\r\n}\r\nif (ch->ch_flags & CH_BAUD0) {\r\nch->ch_flags &= ~(CH_BAUD0);\r\nch->ch_mval |= (D_RTS(ch) | D_DTR(ch));\r\n}\r\nmval = D_DTR(ch) | D_RTS(ch);\r\n}\r\niflag = ch->ch_c_iflag & (IGNBRK | BRKINT | IGNPAR | PARMRK |\r\nINPCK | ISTRIP | IXON | IXANY | IXOFF);\r\nif ((ch->ch_startc == _POSIX_VDISABLE) ||\r\n(ch->ch_stopc == _POSIX_VDISABLE)) {\r\niflag &= ~(IXON | IXOFF);\r\nch->ch_c_iflag &= ~(IXON | IXOFF);\r\n}\r\nif (bd->device == PCI_DEV_XR_IBM_DID) {\r\nif (ch->ch_digi.digi_flags & DIGI_422)\r\ndgap_cmdb(ch, SCOMMODE, MODE_422, 0, 0);\r\nelse\r\ndgap_cmdb(ch, SCOMMODE, MODE_232, 0, 0);\r\n}\r\nif (ch->ch_digi.digi_flags & DIGI_ALTPIN)\r\niflag |= IALTPIN;\r\nif (iflag != ch->ch_fepiflag) {\r\nch->ch_fepiflag = iflag;\r\ndgap_cmdw(ch, SIFLAG, (u16)ch->ch_fepiflag, 0);\r\n}\r\nhflow = 0;\r\nif (ch->ch_c_cflag & CRTSCTS)\r\nhflow |= (D_RTS(ch) | D_CTS(ch));\r\nif (ch->ch_digi.digi_flags & RTSPACE)\r\nhflow |= D_RTS(ch);\r\nif (ch->ch_digi.digi_flags & DTRPACE)\r\nhflow |= D_DTR(ch);\r\nif (ch->ch_digi.digi_flags & CTSPACE)\r\nhflow |= D_CTS(ch);\r\nif (ch->ch_digi.digi_flags & DSRPACE)\r\nhflow |= D_DSR(ch);\r\nif (ch->ch_digi.digi_flags & DCDPACE)\r\nhflow |= D_CD(ch);\r\nif (hflow != ch->ch_hflow) {\r\nch->ch_hflow = hflow;\r\ndgap_cmdb(ch, SHFLOW, (u8)hflow, 0xff, 0);\r\n}\r\nif (bd->bd_flags & BD_FEP5PLUS) {\r\nu16 hflow2 = 0;\r\nif (ch->ch_digi.digi_flags & DIGI_RTS_TOGGLE)\r\nhflow2 |= (D_RTS(ch));\r\nif (ch->ch_digi.digi_flags & DIGI_DTR_TOGGLE)\r\nhflow2 |= (D_DTR(ch));\r\ndgap_cmdw_ext(ch, 0xff03, hflow2, 0);\r\n}\r\nmval ^= ch->ch_mforce & (mval ^ ch->ch_mval);\r\nif (ch->ch_mostat ^ mval) {\r\nch->ch_mostat = mval;\r\ndgap_cmdb(ch, SMODEM, (u8)mval, D_RTS(ch) | D_DTR(ch), 0);\r\n}\r\nch->ch_mistat = readb(&ch->ch_bs->m_stat);\r\ndgap_carrier(ch);\r\nif (ch->ch_startc != ch->ch_fepstartc ||\r\nch->ch_stopc != ch->ch_fepstopc) {\r\nch->ch_fepstartc = ch->ch_startc;\r\nch->ch_fepstopc = ch->ch_stopc;\r\ndgap_cmdb(ch, SFLOWC, ch->ch_fepstartc, ch->ch_fepstopc, 0);\r\n}\r\nif (ch->ch_astartc != ch->ch_fepastartc ||\r\nch->ch_astopc != ch->ch_fepastopc) {\r\nch->ch_fepastartc = ch->ch_astartc;\r\nch->ch_fepastopc = ch->ch_astopc;\r\ndgap_cmdb(ch, SAFLOWC, ch->ch_fepastartc, ch->ch_fepastopc, 0);\r\n}\r\nreturn 0;\r\n}\r\nstatic int dgap_block_til_ready(struct tty_struct *tty, struct file *file,\r\nstruct channel_t *ch)\r\n{\r\nint retval = 0;\r\nstruct un_t *un;\r\nulong lock_flags;\r\nuint old_flags;\r\nint sleep_on_un_flags;\r\nif (!tty || tty->magic != TTY_MAGIC || !file || !ch ||\r\nch->magic != DGAP_CHANNEL_MAGIC)\r\nreturn -EIO;\r\nun = tty->driver_data;\r\nif (!un || un->magic != DGAP_UNIT_MAGIC)\r\nreturn -EIO;\r\nspin_lock_irqsave(&ch->ch_lock, lock_flags);\r\nch->ch_wopen++;\r\nwhile (1) {\r\nsleep_on_un_flags = 0;\r\nif (ch->ch_bd->state == BOARD_FAILED) {\r\nretval = -EIO;\r\nbreak;\r\n}\r\nif (tty_hung_up_p(file)) {\r\nretval = -EAGAIN;\r\nbreak;\r\n}\r\nif (!((ch->ch_tun.un_flags | ch->ch_pun.un_flags) &\r\nUN_CLOSING)) {\r\nif (file->f_flags & O_NONBLOCK)\r\nbreak;\r\nif (tty->flags & (1 << TTY_IO_ERROR))\r\nbreak;\r\nif (ch->ch_flags & CH_CD)\r\nbreak;\r\nif (ch->ch_flags & CH_FCAR)\r\nbreak;\r\n} else {\r\nsleep_on_un_flags = 1;\r\n}\r\nif (signal_pending(current)) {\r\nretval = -ERESTARTSYS;\r\nbreak;\r\n}\r\nif (sleep_on_un_flags)\r\nold_flags = ch->ch_tun.un_flags | ch->ch_pun.un_flags;\r\nelse\r\nold_flags = ch->ch_flags;\r\nspin_unlock_irqrestore(&ch->ch_lock, lock_flags);\r\nif (sleep_on_un_flags) {\r\nretval = wait_event_interruptible(un->un_flags_wait,\r\n(old_flags != (ch->ch_tun.un_flags |\r\nch->ch_pun.un_flags)));\r\n} else {\r\nretval = wait_event_interruptible(ch->ch_flags_wait,\r\n(old_flags != ch->ch_flags));\r\n}\r\nspin_lock_irqsave(&ch->ch_lock, lock_flags);\r\n}\r\nch->ch_wopen--;\r\nspin_unlock_irqrestore(&ch->ch_lock, lock_flags);\r\nreturn retval;\r\n}\r\nstatic void dgap_tty_flush_buffer(struct tty_struct *tty)\r\n{\r\nstruct board_t *bd;\r\nstruct channel_t *ch;\r\nstruct un_t *un;\r\nulong lock_flags;\r\nulong lock_flags2;\r\nu16 head;\r\nif (!tty || tty->magic != TTY_MAGIC)\r\nreturn;\r\nun = tty->driver_data;\r\nif (!un || un->magic != DGAP_UNIT_MAGIC)\r\nreturn;\r\nch = un->un_ch;\r\nif (!ch || ch->magic != DGAP_CHANNEL_MAGIC)\r\nreturn;\r\nbd = ch->ch_bd;\r\nif (!bd || bd->magic != DGAP_BOARD_MAGIC)\r\nreturn;\r\nspin_lock_irqsave(&bd->bd_lock, lock_flags);\r\nspin_lock_irqsave(&ch->ch_lock, lock_flags2);\r\nch->ch_flags &= ~CH_STOP;\r\nhead = readw(&ch->ch_bs->tx_head);\r\ndgap_cmdw(ch, FLUSHTX, (u16)head, 0);\r\ndgap_cmdw(ch, RESUMETX, 0, 0);\r\nif (ch->ch_tun.un_flags & (UN_LOW | UN_EMPTY)) {\r\nch->ch_tun.un_flags &= ~(UN_LOW | UN_EMPTY);\r\nwake_up_interruptible(&ch->ch_tun.un_flags_wait);\r\n}\r\nif (ch->ch_pun.un_flags & (UN_LOW | UN_EMPTY)) {\r\nch->ch_pun.un_flags &= ~(UN_LOW | UN_EMPTY);\r\nwake_up_interruptible(&ch->ch_pun.un_flags_wait);\r\n}\r\nspin_unlock_irqrestore(&ch->ch_lock, lock_flags2);\r\nspin_unlock_irqrestore(&bd->bd_lock, lock_flags);\r\nif (waitqueue_active(&tty->write_wait))\r\nwake_up_interruptible(&tty->write_wait);\r\ntty_wakeup(tty);\r\n}\r\nstatic void dgap_tty_hangup(struct tty_struct *tty)\r\n{\r\nstruct board_t *bd;\r\nstruct channel_t *ch;\r\nstruct un_t *un;\r\nif (!tty || tty->magic != TTY_MAGIC)\r\nreturn;\r\nun = tty->driver_data;\r\nif (!un || un->magic != DGAP_UNIT_MAGIC)\r\nreturn;\r\nch = un->un_ch;\r\nif (!ch || ch->magic != DGAP_CHANNEL_MAGIC)\r\nreturn;\r\nbd = ch->ch_bd;\r\nif (!bd || bd->magic != DGAP_BOARD_MAGIC)\r\nreturn;\r\ndgap_tty_flush_buffer(tty);\r\n}\r\nstatic int dgap_tty_chars_in_buffer(struct tty_struct *tty)\r\n{\r\nstruct board_t *bd;\r\nstruct channel_t *ch;\r\nstruct un_t *un;\r\nstruct bs_t __iomem *bs;\r\nu8 tbusy;\r\nuint chars;\r\nu16 thead, ttail, tmask, chead, ctail;\r\nulong lock_flags = 0;\r\nulong lock_flags2 = 0;\r\nif (!tty)\r\nreturn 0;\r\nun = tty->driver_data;\r\nif (!un || un->magic != DGAP_UNIT_MAGIC)\r\nreturn 0;\r\nch = un->un_ch;\r\nif (!ch || ch->magic != DGAP_CHANNEL_MAGIC)\r\nreturn 0;\r\nbd = ch->ch_bd;\r\nif (!bd || bd->magic != DGAP_BOARD_MAGIC)\r\nreturn 0;\r\nbs = ch->ch_bs;\r\nif (!bs)\r\nreturn 0;\r\nspin_lock_irqsave(&bd->bd_lock, lock_flags);\r\nspin_lock_irqsave(&ch->ch_lock, lock_flags2);\r\ntmask = (ch->ch_tsize - 1);\r\nthead = readw(&bs->tx_head) & tmask;\r\nttail = readw(&bs->tx_tail) & tmask;\r\ntbusy = readb(&bs->tbusy);\r\nchead = readw(&ch->ch_cm->cm_head);\r\nctail = readw(&ch->ch_cm->cm_tail);\r\nspin_unlock_irqrestore(&ch->ch_lock, lock_flags2);\r\nspin_unlock_irqrestore(&bd->bd_lock, lock_flags);\r\nif ((ttail == thead) && (tbusy == 0) && (chead == ctail)) {\r\nchars = 0;\r\n} else {\r\nif (thead >= ttail)\r\nchars = thead - ttail;\r\nelse\r\nchars = thead - ttail + ch->ch_tsize;\r\nif (chars == 0) {\r\nif (tbusy != 0) {\r\nspin_lock_irqsave(&ch->ch_lock, lock_flags);\r\nun->un_flags |= UN_EMPTY;\r\nwriteb(1, &bs->iempty);\r\nspin_unlock_irqrestore(&ch->ch_lock,\r\nlock_flags);\r\n}\r\nchars = 1;\r\n}\r\n}\r\nreturn chars;\r\n}\r\nstatic int dgap_wait_for_drain(struct tty_struct *tty)\r\n{\r\nstruct channel_t *ch;\r\nstruct un_t *un;\r\nstruct bs_t __iomem *bs;\r\nint ret = 0;\r\nuint count = 1;\r\nulong lock_flags = 0;\r\nif (!tty || tty->magic != TTY_MAGIC)\r\nreturn -EIO;\r\nun = tty->driver_data;\r\nif (!un || un->magic != DGAP_UNIT_MAGIC)\r\nreturn -EIO;\r\nch = un->un_ch;\r\nif (!ch || ch->magic != DGAP_CHANNEL_MAGIC)\r\nreturn -EIO;\r\nbs = ch->ch_bs;\r\nif (!bs)\r\nreturn -EIO;\r\nwhile (count != 0) {\r\ncount = dgap_tty_chars_in_buffer(tty);\r\nif (count == 0)\r\nbreak;\r\nspin_lock_irqsave(&ch->ch_lock, lock_flags);\r\nun->un_flags |= UN_EMPTY;\r\nwriteb(1, &bs->iempty);\r\nspin_unlock_irqrestore(&ch->ch_lock, lock_flags);\r\nret = wait_event_interruptible(un->un_flags_wait,\r\n((un->un_flags & UN_EMPTY) == 0));\r\nif (ret)\r\nbreak;\r\n}\r\nspin_lock_irqsave(&ch->ch_lock, lock_flags);\r\nun->un_flags &= ~(UN_EMPTY);\r\nspin_unlock_irqrestore(&ch->ch_lock, lock_flags);\r\nreturn ret;\r\n}\r\nstatic int dgap_maxcps_room(struct channel_t *ch, struct un_t *un,\r\nint bytes_available)\r\n{\r\nif (un->un_type != DGAP_PRINT)\r\nreturn bytes_available;\r\nif (ch->ch_digi.digi_maxcps > 0 && ch->ch_digi.digi_bufsize > 0) {\r\nint cps_limit = 0;\r\nunsigned long current_time = jiffies;\r\nunsigned long buffer_time = current_time +\r\n(HZ * ch->ch_digi.digi_bufsize) /\r\nch->ch_digi.digi_maxcps;\r\nif (ch->ch_cpstime < current_time) {\r\nch->ch_cpstime = current_time;\r\ncps_limit = ch->ch_digi.digi_bufsize;\r\n} else if (ch->ch_cpstime < buffer_time) {\r\ncps_limit = ((buffer_time - ch->ch_cpstime) *\r\nch->ch_digi.digi_maxcps) / HZ;\r\n} else {\r\ncps_limit = 0;\r\n}\r\nbytes_available = min(cps_limit, bytes_available);\r\n}\r\nreturn bytes_available;\r\n}\r\nstatic inline void dgap_set_firmware_event(struct un_t *un, unsigned int event)\r\n{\r\nstruct channel_t *ch;\r\nstruct bs_t __iomem *bs;\r\nif (!un || un->magic != DGAP_UNIT_MAGIC)\r\nreturn;\r\nch = un->un_ch;\r\nif (!ch || ch->magic != DGAP_CHANNEL_MAGIC)\r\nreturn;\r\nbs = ch->ch_bs;\r\nif (!bs)\r\nreturn;\r\nif ((event & UN_LOW) != 0) {\r\nif ((un->un_flags & UN_LOW) == 0) {\r\nun->un_flags |= UN_LOW;\r\nwriteb(1, &bs->ilow);\r\n}\r\n}\r\nif ((event & UN_LOW) != 0) {\r\nif ((un->un_flags & UN_EMPTY) == 0) {\r\nun->un_flags |= UN_EMPTY;\r\nwriteb(1, &bs->iempty);\r\n}\r\n}\r\n}\r\nstatic int dgap_tty_write_room(struct tty_struct *tty)\r\n{\r\nstruct channel_t *ch;\r\nstruct un_t *un;\r\nstruct bs_t __iomem *bs;\r\nu16 head, tail, tmask;\r\nint ret;\r\nulong lock_flags = 0;\r\nif (!tty)\r\nreturn 0;\r\nun = tty->driver_data;\r\nif (!un || un->magic != DGAP_UNIT_MAGIC)\r\nreturn 0;\r\nch = un->un_ch;\r\nif (!ch || ch->magic != DGAP_CHANNEL_MAGIC)\r\nreturn 0;\r\nbs = ch->ch_bs;\r\nif (!bs)\r\nreturn 0;\r\nspin_lock_irqsave(&ch->ch_lock, lock_flags);\r\ntmask = ch->ch_tsize - 1;\r\nhead = readw(&bs->tx_head) & tmask;\r\ntail = readw(&bs->tx_tail) & tmask;\r\nret = tail - head - 1;\r\nif (ret < 0)\r\nret += ch->ch_tsize;\r\nret = dgap_maxcps_room(ch, un, ret);\r\nif (un->un_type == DGAP_PRINT) {\r\nif (!(ch->ch_flags & CH_PRON))\r\nret -= ch->ch_digi.digi_onlen;\r\nret -= ch->ch_digi.digi_offlen;\r\n} else {\r\nif (ch->ch_flags & CH_PRON)\r\nret -= ch->ch_digi.digi_offlen;\r\n}\r\nif (ret < 0)\r\nret = 0;\r\ndgap_set_firmware_event(un, UN_LOW | UN_EMPTY);\r\nspin_unlock_irqrestore(&ch->ch_lock, lock_flags);\r\nreturn ret;\r\n}\r\nstatic int dgap_tty_write(struct tty_struct *tty, const unsigned char *buf,\r\nint count)\r\n{\r\nstruct channel_t *ch;\r\nstruct un_t *un;\r\nstruct bs_t __iomem *bs;\r\nchar __iomem *vaddr;\r\nu16 head, tail, tmask, remain;\r\nint bufcount, n;\r\nulong lock_flags;\r\nif (!tty)\r\nreturn 0;\r\nun = tty->driver_data;\r\nif (!un || un->magic != DGAP_UNIT_MAGIC)\r\nreturn 0;\r\nch = un->un_ch;\r\nif (!ch || ch->magic != DGAP_CHANNEL_MAGIC)\r\nreturn 0;\r\nbs = ch->ch_bs;\r\nif (!bs)\r\nreturn 0;\r\nif (!count)\r\nreturn 0;\r\nspin_lock_irqsave(&ch->ch_lock, lock_flags);\r\ntmask = ch->ch_tsize - 1;\r\nhead = readw(&(bs->tx_head)) & tmask;\r\ntail = readw(&(bs->tx_tail)) & tmask;\r\nbufcount = tail - head - 1;\r\nif (bufcount < 0)\r\nbufcount += ch->ch_tsize;\r\nbufcount = dgap_maxcps_room(ch, un, bufcount);\r\ncount = min(count, bufcount);\r\nif (count <= 0) {\r\ndgap_set_firmware_event(un, UN_LOW | UN_EMPTY);\r\nspin_unlock_irqrestore(&ch->ch_lock, lock_flags);\r\nreturn 0;\r\n}\r\nif ((un->un_type == DGAP_PRINT) && !(ch->ch_flags & CH_PRON)) {\r\ndgap_wmove(ch, ch->ch_digi.digi_onstr,\r\n(int)ch->ch_digi.digi_onlen);\r\nhead = readw(&bs->tx_head) & tmask;\r\nch->ch_flags |= CH_PRON;\r\n}\r\nif ((un->un_type != DGAP_PRINT) && (ch->ch_flags & CH_PRON)) {\r\ndgap_wmove(ch, ch->ch_digi.digi_offstr,\r\n(int)ch->ch_digi.digi_offlen);\r\nhead = readw(&bs->tx_head) & tmask;\r\nch->ch_flags &= ~CH_PRON;\r\n}\r\nn = count;\r\nremain = ch->ch_tstart + ch->ch_tsize - head;\r\nif (n >= remain) {\r\nn -= remain;\r\nvaddr = ch->ch_taddr + head;\r\nmemcpy_toio(vaddr, (u8 *)buf, remain);\r\nhead = ch->ch_tstart;\r\nbuf += remain;\r\n}\r\nif (n > 0) {\r\nvaddr = ch->ch_taddr + head;\r\nremain = n;\r\nmemcpy_toio(vaddr, (u8 *)buf, remain);\r\nhead += remain;\r\n}\r\nif (count) {\r\nch->ch_txcount += count;\r\nhead &= tmask;\r\nwritew(head, &bs->tx_head);\r\n}\r\ndgap_set_firmware_event(un, UN_LOW | UN_EMPTY);\r\nif ((un->un_type == DGAP_PRINT) && (ch->ch_flags & CH_PRON)) {\r\ntail = readw(&bs->tx_tail) & tmask;\r\nif (tail != head) {\r\nun->un_flags |= UN_EMPTY;\r\nwriteb(1, &bs->iempty);\r\n} else {\r\ndgap_wmove(ch, ch->ch_digi.digi_offstr,\r\n(int)ch->ch_digi.digi_offlen);\r\nhead = readw(&bs->tx_head) & tmask;\r\nch->ch_flags &= ~CH_PRON;\r\n}\r\n}\r\nif ((un->un_type == DGAP_PRINT) && (ch->ch_digi.digi_maxcps > 0)\r\n&& (ch->ch_digi.digi_bufsize > 0)) {\r\nch->ch_cpstime += (HZ * count) / ch->ch_digi.digi_maxcps;\r\n}\r\nspin_unlock_irqrestore(&ch->ch_lock, lock_flags);\r\nreturn count;\r\n}\r\nstatic int dgap_tty_put_char(struct tty_struct *tty, unsigned char c)\r\n{\r\ndgap_tty_write(tty, &c, 1);\r\nreturn 1;\r\n}\r\nstatic int dgap_tty_tiocmget(struct tty_struct *tty)\r\n{\r\nstruct channel_t *ch;\r\nstruct un_t *un;\r\nint result;\r\nu8 mstat;\r\nulong lock_flags;\r\nif (!tty || tty->magic != TTY_MAGIC)\r\nreturn -EIO;\r\nun = tty->driver_data;\r\nif (!un || un->magic != DGAP_UNIT_MAGIC)\r\nreturn -EIO;\r\nch = un->un_ch;\r\nif (!ch || ch->magic != DGAP_CHANNEL_MAGIC)\r\nreturn -EIO;\r\nspin_lock_irqsave(&ch->ch_lock, lock_flags);\r\nmstat = readb(&ch->ch_bs->m_stat);\r\nmstat |= ch->ch_mostat;\r\nspin_unlock_irqrestore(&ch->ch_lock, lock_flags);\r\nresult = 0;\r\nif (mstat & D_DTR(ch))\r\nresult |= TIOCM_DTR;\r\nif (mstat & D_RTS(ch))\r\nresult |= TIOCM_RTS;\r\nif (mstat & D_CTS(ch))\r\nresult |= TIOCM_CTS;\r\nif (mstat & D_DSR(ch))\r\nresult |= TIOCM_DSR;\r\nif (mstat & D_RI(ch))\r\nresult |= TIOCM_RI;\r\nif (mstat & D_CD(ch))\r\nresult |= TIOCM_CD;\r\nreturn result;\r\n}\r\nstatic int dgap_tty_tiocmset(struct tty_struct *tty,\r\nunsigned int set, unsigned int clear)\r\n{\r\nstruct board_t *bd;\r\nstruct channel_t *ch;\r\nstruct un_t *un;\r\nulong lock_flags;\r\nulong lock_flags2;\r\nif (!tty || tty->magic != TTY_MAGIC)\r\nreturn -EIO;\r\nun = tty->driver_data;\r\nif (!un || un->magic != DGAP_UNIT_MAGIC)\r\nreturn -EIO;\r\nch = un->un_ch;\r\nif (!ch || ch->magic != DGAP_CHANNEL_MAGIC)\r\nreturn -EIO;\r\nbd = ch->ch_bd;\r\nif (!bd || bd->magic != DGAP_BOARD_MAGIC)\r\nreturn -EIO;\r\nspin_lock_irqsave(&bd->bd_lock, lock_flags);\r\nspin_lock_irqsave(&ch->ch_lock, lock_flags2);\r\nif (set & TIOCM_RTS) {\r\nch->ch_mforce |= D_RTS(ch);\r\nch->ch_mval |= D_RTS(ch);\r\n}\r\nif (set & TIOCM_DTR) {\r\nch->ch_mforce |= D_DTR(ch);\r\nch->ch_mval |= D_DTR(ch);\r\n}\r\nif (clear & TIOCM_RTS) {\r\nch->ch_mforce |= D_RTS(ch);\r\nch->ch_mval &= ~(D_RTS(ch));\r\n}\r\nif (clear & TIOCM_DTR) {\r\nch->ch_mforce |= D_DTR(ch);\r\nch->ch_mval &= ~(D_DTR(ch));\r\n}\r\ndgap_param(ch, bd, un->un_type);\r\nspin_unlock_irqrestore(&ch->ch_lock, lock_flags2);\r\nspin_unlock_irqrestore(&bd->bd_lock, lock_flags);\r\nreturn 0;\r\n}\r\nstatic int dgap_tty_send_break(struct tty_struct *tty, int msec)\r\n{\r\nstruct board_t *bd;\r\nstruct channel_t *ch;\r\nstruct un_t *un;\r\nulong lock_flags;\r\nulong lock_flags2;\r\nif (!tty || tty->magic != TTY_MAGIC)\r\nreturn -EIO;\r\nun = tty->driver_data;\r\nif (!un || un->magic != DGAP_UNIT_MAGIC)\r\nreturn -EIO;\r\nch = un->un_ch;\r\nif (!ch || ch->magic != DGAP_CHANNEL_MAGIC)\r\nreturn -EIO;\r\nbd = ch->ch_bd;\r\nif (!bd || bd->magic != DGAP_BOARD_MAGIC)\r\nreturn -EIO;\r\nswitch (msec) {\r\ncase -1:\r\nmsec = 0xFFFF;\r\nbreak;\r\ncase 0:\r\nmsec = 1;\r\nbreak;\r\ndefault:\r\nmsec /= 10;\r\nbreak;\r\n}\r\nspin_lock_irqsave(&bd->bd_lock, lock_flags);\r\nspin_lock_irqsave(&ch->ch_lock, lock_flags2);\r\n#if 0\r\ndgap_cmdw(ch, SBREAK, (u16) SBREAK_TIME, 0);\r\n#endif\r\ndgap_cmdw(ch, SBREAK, (u16)msec, 0);\r\nspin_unlock_irqrestore(&ch->ch_lock, lock_flags2);\r\nspin_unlock_irqrestore(&bd->bd_lock, lock_flags);\r\nreturn 0;\r\n}\r\nstatic void dgap_tty_wait_until_sent(struct tty_struct *tty, int timeout)\r\n{\r\ndgap_wait_for_drain(tty);\r\n}\r\nstatic void dgap_tty_send_xchar(struct tty_struct *tty, char c)\r\n{\r\nstruct board_t *bd;\r\nstruct channel_t *ch;\r\nstruct un_t *un;\r\nulong lock_flags;\r\nulong lock_flags2;\r\nif (!tty || tty->magic != TTY_MAGIC)\r\nreturn;\r\nun = tty->driver_data;\r\nif (!un || un->magic != DGAP_UNIT_MAGIC)\r\nreturn;\r\nch = un->un_ch;\r\nif (!ch || ch->magic != DGAP_CHANNEL_MAGIC)\r\nreturn;\r\nbd = ch->ch_bd;\r\nif (!bd || bd->magic != DGAP_BOARD_MAGIC)\r\nreturn;\r\nspin_lock_irqsave(&bd->bd_lock, lock_flags);\r\nspin_lock_irqsave(&ch->ch_lock, lock_flags2);\r\n#if 0\r\nif (c == STOP_CHAR(tty))\r\ndgap_cmdw(ch, RPAUSE, 0, 0);\r\nelse if (c == START_CHAR(tty))\r\ndgap_cmdw(ch, RRESUME, 0, 0);\r\nelse\r\ndgap_wmove(ch, &c, 1);\r\n#else\r\ndgap_wmove(ch, &c, 1);\r\n#endif\r\nspin_unlock_irqrestore(&ch->ch_lock, lock_flags2);\r\nspin_unlock_irqrestore(&bd->bd_lock, lock_flags);\r\n}\r\nstatic int dgap_get_modem_info(struct channel_t *ch, unsigned int __user *value)\r\n{\r\nint result;\r\nu8 mstat;\r\nulong lock_flags;\r\nspin_lock_irqsave(&ch->ch_lock, lock_flags);\r\nmstat = readb(&ch->ch_bs->m_stat);\r\nmstat |= ch->ch_mostat;\r\nspin_unlock_irqrestore(&ch->ch_lock, lock_flags);\r\nresult = 0;\r\nif (mstat & D_DTR(ch))\r\nresult |= TIOCM_DTR;\r\nif (mstat & D_RTS(ch))\r\nresult |= TIOCM_RTS;\r\nif (mstat & D_CTS(ch))\r\nresult |= TIOCM_CTS;\r\nif (mstat & D_DSR(ch))\r\nresult |= TIOCM_DSR;\r\nif (mstat & D_RI(ch))\r\nresult |= TIOCM_RI;\r\nif (mstat & D_CD(ch))\r\nresult |= TIOCM_CD;\r\nreturn put_user(result, value);\r\n}\r\nstatic int dgap_set_modem_info(struct channel_t *ch, struct board_t *bd,\r\nstruct un_t *un, unsigned int command,\r\nunsigned int __user *value)\r\n{\r\nint ret;\r\nunsigned int arg;\r\nulong lock_flags;\r\nulong lock_flags2;\r\nret = get_user(arg, value);\r\nif (ret)\r\nreturn ret;\r\nswitch (command) {\r\ncase TIOCMBIS:\r\nif (arg & TIOCM_RTS) {\r\nch->ch_mforce |= D_RTS(ch);\r\nch->ch_mval |= D_RTS(ch);\r\n}\r\nif (arg & TIOCM_DTR) {\r\nch->ch_mforce |= D_DTR(ch);\r\nch->ch_mval |= D_DTR(ch);\r\n}\r\nbreak;\r\ncase TIOCMBIC:\r\nif (arg & TIOCM_RTS) {\r\nch->ch_mforce |= D_RTS(ch);\r\nch->ch_mval &= ~(D_RTS(ch));\r\n}\r\nif (arg & TIOCM_DTR) {\r\nch->ch_mforce |= D_DTR(ch);\r\nch->ch_mval &= ~(D_DTR(ch));\r\n}\r\nbreak;\r\ncase TIOCMSET:\r\nch->ch_mforce = D_DTR(ch) | D_RTS(ch);\r\nif (arg & TIOCM_RTS)\r\nch->ch_mval |= D_RTS(ch);\r\nelse\r\nch->ch_mval &= ~(D_RTS(ch));\r\nif (arg & TIOCM_DTR)\r\nch->ch_mval |= (D_DTR(ch));\r\nelse\r\nch->ch_mval &= ~(D_DTR(ch));\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nspin_lock_irqsave(&bd->bd_lock, lock_flags);\r\nspin_lock_irqsave(&ch->ch_lock, lock_flags2);\r\ndgap_param(ch, bd, un->un_type);\r\nspin_unlock_irqrestore(&ch->ch_lock, lock_flags2);\r\nspin_unlock_irqrestore(&bd->bd_lock, lock_flags);\r\nreturn 0;\r\n}\r\nstatic int dgap_tty_digigeta(struct channel_t *ch,\r\nstruct digi_t __user *retinfo)\r\n{\r\nstruct digi_t tmp;\r\nulong lock_flags;\r\nif (!retinfo)\r\nreturn -EFAULT;\r\nmemset(&tmp, 0, sizeof(tmp));\r\nspin_lock_irqsave(&ch->ch_lock, lock_flags);\r\nmemcpy(&tmp, &ch->ch_digi, sizeof(tmp));\r\nspin_unlock_irqrestore(&ch->ch_lock, lock_flags);\r\nif (copy_to_user(retinfo, &tmp, sizeof(*retinfo)))\r\nreturn -EFAULT;\r\nreturn 0;\r\n}\r\nstatic int dgap_tty_digiseta(struct channel_t *ch, struct board_t *bd,\r\nstruct un_t *un, struct digi_t __user *new_info)\r\n{\r\nstruct digi_t new_digi;\r\nulong lock_flags = 0;\r\nunsigned long lock_flags2;\r\nif (copy_from_user(&new_digi, new_info, sizeof(struct digi_t)))\r\nreturn -EFAULT;\r\nspin_lock_irqsave(&bd->bd_lock, lock_flags);\r\nspin_lock_irqsave(&ch->ch_lock, lock_flags2);\r\nmemcpy(&ch->ch_digi, &new_digi, sizeof(struct digi_t));\r\nif (ch->ch_digi.digi_maxcps < 1)\r\nch->ch_digi.digi_maxcps = 1;\r\nif (ch->ch_digi.digi_maxcps > 10000)\r\nch->ch_digi.digi_maxcps = 10000;\r\nif (ch->ch_digi.digi_bufsize < 10)\r\nch->ch_digi.digi_bufsize = 10;\r\nif (ch->ch_digi.digi_maxchar < 1)\r\nch->ch_digi.digi_maxchar = 1;\r\nif (ch->ch_digi.digi_maxchar > ch->ch_digi.digi_bufsize)\r\nch->ch_digi.digi_maxchar = ch->ch_digi.digi_bufsize;\r\nif (ch->ch_digi.digi_onlen > DIGI_PLEN)\r\nch->ch_digi.digi_onlen = DIGI_PLEN;\r\nif (ch->ch_digi.digi_offlen > DIGI_PLEN)\r\nch->ch_digi.digi_offlen = DIGI_PLEN;\r\ndgap_param(ch, bd, un->un_type);\r\nspin_unlock_irqrestore(&ch->ch_lock, lock_flags2);\r\nspin_unlock_irqrestore(&bd->bd_lock, lock_flags);\r\nreturn 0;\r\n}\r\nstatic int dgap_tty_digigetedelay(struct tty_struct *tty, int __user *retinfo)\r\n{\r\nstruct channel_t *ch;\r\nstruct un_t *un;\r\nint tmp;\r\nulong lock_flags;\r\nif (!retinfo)\r\nreturn -EFAULT;\r\nif (!tty || tty->magic != TTY_MAGIC)\r\nreturn -EFAULT;\r\nun = tty->driver_data;\r\nif (!un || un->magic != DGAP_UNIT_MAGIC)\r\nreturn -EFAULT;\r\nch = un->un_ch;\r\nif (!ch || ch->magic != DGAP_CHANNEL_MAGIC)\r\nreturn -EFAULT;\r\nmemset(&tmp, 0, sizeof(tmp));\r\nspin_lock_irqsave(&ch->ch_lock, lock_flags);\r\ntmp = readw(&ch->ch_bs->edelay);\r\nspin_unlock_irqrestore(&ch->ch_lock, lock_flags);\r\nif (copy_to_user(retinfo, &tmp, sizeof(*retinfo)))\r\nreturn -EFAULT;\r\nreturn 0;\r\n}\r\nstatic int dgap_tty_digisetedelay(struct channel_t *ch, struct board_t *bd,\r\nstruct un_t *un, int __user *new_info)\r\n{\r\nint new_digi;\r\nulong lock_flags;\r\nulong lock_flags2;\r\nif (copy_from_user(&new_digi, new_info, sizeof(int)))\r\nreturn -EFAULT;\r\nspin_lock_irqsave(&bd->bd_lock, lock_flags);\r\nspin_lock_irqsave(&ch->ch_lock, lock_flags2);\r\nwritew((u16)new_digi, &ch->ch_bs->edelay);\r\ndgap_param(ch, bd, un->un_type);\r\nspin_unlock_irqrestore(&ch->ch_lock, lock_flags2);\r\nspin_unlock_irqrestore(&bd->bd_lock, lock_flags);\r\nreturn 0;\r\n}\r\nstatic int dgap_tty_digigetcustombaud(struct channel_t *ch, struct un_t *un,\r\nint __user *retinfo)\r\n{\r\nint tmp;\r\nulong lock_flags;\r\nif (!retinfo)\r\nreturn -EFAULT;\r\nmemset(&tmp, 0, sizeof(tmp));\r\nspin_lock_irqsave(&ch->ch_lock, lock_flags);\r\ntmp = dgap_get_custom_baud(ch);\r\nspin_unlock_irqrestore(&ch->ch_lock, lock_flags);\r\nif (copy_to_user(retinfo, &tmp, sizeof(*retinfo)))\r\nreturn -EFAULT;\r\nreturn 0;\r\n}\r\nstatic int dgap_tty_digisetcustombaud(struct channel_t *ch, struct board_t *bd,\r\nstruct un_t *un, int __user *new_info)\r\n{\r\nuint new_rate;\r\nulong lock_flags;\r\nulong lock_flags2;\r\nif (copy_from_user(&new_rate, new_info, sizeof(unsigned int)))\r\nreturn -EFAULT;\r\nif (bd->bd_flags & BD_FEP5PLUS) {\r\nspin_lock_irqsave(&bd->bd_lock, lock_flags);\r\nspin_lock_irqsave(&ch->ch_lock, lock_flags2);\r\nch->ch_custom_speed = new_rate;\r\ndgap_param(ch, bd, un->un_type);\r\nspin_unlock_irqrestore(&ch->ch_lock, lock_flags2);\r\nspin_unlock_irqrestore(&bd->bd_lock, lock_flags);\r\n}\r\nreturn 0;\r\n}\r\nstatic void dgap_tty_set_termios(struct tty_struct *tty,\r\nstruct ktermios *old_termios)\r\n{\r\nstruct board_t *bd;\r\nstruct channel_t *ch;\r\nstruct un_t *un;\r\nunsigned long lock_flags;\r\nunsigned long lock_flags2;\r\nif (!tty || tty->magic != TTY_MAGIC)\r\nreturn;\r\nun = tty->driver_data;\r\nif (!un || un->magic != DGAP_UNIT_MAGIC)\r\nreturn;\r\nch = un->un_ch;\r\nif (!ch || ch->magic != DGAP_CHANNEL_MAGIC)\r\nreturn;\r\nbd = ch->ch_bd;\r\nif (!bd || bd->magic != DGAP_BOARD_MAGIC)\r\nreturn;\r\nspin_lock_irqsave(&bd->bd_lock, lock_flags);\r\nspin_lock_irqsave(&ch->ch_lock, lock_flags2);\r\nch->ch_c_cflag = tty->termios.c_cflag;\r\nch->ch_c_iflag = tty->termios.c_iflag;\r\nch->ch_c_oflag = tty->termios.c_oflag;\r\nch->ch_c_lflag = tty->termios.c_lflag;\r\nch->ch_startc = tty->termios.c_cc[VSTART];\r\nch->ch_stopc = tty->termios.c_cc[VSTOP];\r\ndgap_carrier(ch);\r\ndgap_param(ch, bd, un->un_type);\r\nspin_unlock_irqrestore(&ch->ch_lock, lock_flags2);\r\nspin_unlock_irqrestore(&bd->bd_lock, lock_flags);\r\n}\r\nstatic void dgap_tty_throttle(struct tty_struct *tty)\r\n{\r\nstruct board_t *bd;\r\nstruct channel_t *ch;\r\nstruct un_t *un;\r\nulong lock_flags;\r\nulong lock_flags2;\r\nif (!tty || tty->magic != TTY_MAGIC)\r\nreturn;\r\nun = tty->driver_data;\r\nif (!un || un->magic != DGAP_UNIT_MAGIC)\r\nreturn;\r\nch = un->un_ch;\r\nif (!ch || ch->magic != DGAP_CHANNEL_MAGIC)\r\nreturn;\r\nbd = ch->ch_bd;\r\nif (!bd || bd->magic != DGAP_BOARD_MAGIC)\r\nreturn;\r\nspin_lock_irqsave(&bd->bd_lock, lock_flags);\r\nspin_lock_irqsave(&ch->ch_lock, lock_flags2);\r\nch->ch_flags |= (CH_RXBLOCK);\r\n#if 1\r\ndgap_cmdw(ch, RPAUSE, 0, 0);\r\n#endif\r\nspin_unlock_irqrestore(&ch->ch_lock, lock_flags2);\r\nspin_unlock_irqrestore(&bd->bd_lock, lock_flags);\r\n}\r\nstatic void dgap_tty_unthrottle(struct tty_struct *tty)\r\n{\r\nstruct board_t *bd;\r\nstruct channel_t *ch;\r\nstruct un_t *un;\r\nulong lock_flags;\r\nulong lock_flags2;\r\nif (!tty || tty->magic != TTY_MAGIC)\r\nreturn;\r\nun = tty->driver_data;\r\nif (!un || un->magic != DGAP_UNIT_MAGIC)\r\nreturn;\r\nch = un->un_ch;\r\nif (!ch || ch->magic != DGAP_CHANNEL_MAGIC)\r\nreturn;\r\nbd = ch->ch_bd;\r\nif (!bd || bd->magic != DGAP_BOARD_MAGIC)\r\nreturn;\r\nspin_lock_irqsave(&bd->bd_lock, lock_flags);\r\nspin_lock_irqsave(&ch->ch_lock, lock_flags2);\r\nch->ch_flags &= ~(CH_RXBLOCK);\r\n#if 1\r\ndgap_cmdw(ch, RRESUME, 0, 0);\r\n#endif\r\nspin_unlock_irqrestore(&ch->ch_lock, lock_flags2);\r\nspin_unlock_irqrestore(&bd->bd_lock, lock_flags);\r\n}\r\nstatic struct board_t *find_board_by_major(unsigned int major)\r\n{\r\nunsigned int i;\r\nfor (i = 0; i < MAXBOARDS; i++) {\r\nstruct board_t *brd = dgap_board[i];\r\nif (!brd)\r\nreturn NULL;\r\nif (major == brd->serial_driver->major ||\r\nmajor == brd->print_driver->major)\r\nreturn brd;\r\n}\r\nreturn NULL;\r\n}\r\nstatic int dgap_tty_open(struct tty_struct *tty, struct file *file)\r\n{\r\nstruct board_t *brd;\r\nstruct channel_t *ch;\r\nstruct un_t *un;\r\nstruct bs_t __iomem *bs;\r\nuint major;\r\nuint minor;\r\nint rc;\r\nulong lock_flags;\r\nulong lock_flags2;\r\nu16 head;\r\nmajor = MAJOR(tty_devnum(tty));\r\nminor = MINOR(tty_devnum(tty));\r\nbrd = find_board_by_major(major);\r\nif (!brd)\r\nreturn -EIO;\r\nrc = wait_event_interruptible(brd->state_wait,\r\n(brd->state & BOARD_READY));\r\nif (rc)\r\nreturn rc;\r\nspin_lock_irqsave(&brd->bd_lock, lock_flags);\r\nif (brd->state != BOARD_READY) {\r\nspin_unlock_irqrestore(&brd->bd_lock, lock_flags);\r\nreturn -EIO;\r\n}\r\nif (MINOR(tty_devnum(tty)) > brd->nasync) {\r\nspin_unlock_irqrestore(&brd->bd_lock, lock_flags);\r\nreturn -EIO;\r\n}\r\nch = brd->channels[minor];\r\nif (!ch) {\r\nspin_unlock_irqrestore(&brd->bd_lock, lock_flags);\r\nreturn -EIO;\r\n}\r\nspin_lock_irqsave(&ch->ch_lock, lock_flags2);\r\nif (major == brd->serial_driver->major) {\r\nun = &brd->channels[minor]->ch_tun;\r\nun->un_type = DGAP_SERIAL;\r\n} else if (major == brd->print_driver->major) {\r\nun = &brd->channels[minor]->ch_pun;\r\nun->un_type = DGAP_PRINT;\r\n} else {\r\nspin_unlock_irqrestore(&ch->ch_lock, lock_flags2);\r\nspin_unlock_irqrestore(&brd->bd_lock, lock_flags);\r\nreturn -EIO;\r\n}\r\ntty->driver_data = un;\r\nbs = ch->ch_bs;\r\nif (!bs) {\r\nspin_unlock_irqrestore(&ch->ch_lock, lock_flags2);\r\nspin_unlock_irqrestore(&brd->bd_lock, lock_flags);\r\nreturn -EIO;\r\n}\r\nif (!(un->un_flags & UN_ISOPEN)) {\r\nun->un_tty = tty;\r\n}\r\nif (!((ch->ch_tun.un_flags | ch->ch_pun.un_flags) & UN_ISOPEN)) {\r\nch->ch_mforce = 0;\r\nch->ch_mval = 0;\r\nhead = readw(&bs->rx_head);\r\nwritew(head, &bs->rx_tail);\r\nch->ch_flags = 0;\r\nch->pscan_state = 0;\r\nch->pscan_savechar = 0;\r\nch->ch_c_cflag = tty->termios.c_cflag;\r\nch->ch_c_iflag = tty->termios.c_iflag;\r\nch->ch_c_oflag = tty->termios.c_oflag;\r\nch->ch_c_lflag = tty->termios.c_lflag;\r\nch->ch_startc = tty->termios.c_cc[VSTART];\r\nch->ch_stopc = tty->termios.c_cc[VSTOP];\r\n}\r\ndgap_carrier(ch);\r\ndgap_param(ch, brd, un->un_type);\r\nspin_unlock_irqrestore(&ch->ch_lock, lock_flags2);\r\nspin_unlock_irqrestore(&brd->bd_lock, lock_flags);\r\nrc = dgap_block_til_ready(tty, file, ch);\r\nif (!un->un_tty)\r\nreturn -ENODEV;\r\nspin_lock_irqsave(&ch->ch_lock, lock_flags);\r\nch->ch_open_count++;\r\nun->un_open_count++;\r\nun->un_flags |= (UN_ISOPEN);\r\nspin_unlock_irqrestore(&ch->ch_lock, lock_flags);\r\nreturn rc;\r\n}\r\nstatic void dgap_tty_close(struct tty_struct *tty, struct file *file)\r\n{\r\nstruct board_t *bd;\r\nstruct channel_t *ch;\r\nstruct un_t *un;\r\nulong lock_flags;\r\nif (!tty || tty->magic != TTY_MAGIC)\r\nreturn;\r\nun = tty->driver_data;\r\nif (!un || un->magic != DGAP_UNIT_MAGIC)\r\nreturn;\r\nch = un->un_ch;\r\nif (!ch || ch->magic != DGAP_CHANNEL_MAGIC)\r\nreturn;\r\nbd = ch->ch_bd;\r\nif (!bd || bd->magic != DGAP_BOARD_MAGIC)\r\nreturn;\r\nspin_lock_irqsave(&ch->ch_lock, lock_flags);\r\nif ((tty->count == 1) && (un->un_open_count != 1)) {\r\nun->un_open_count = 1;\r\n}\r\nif (--un->un_open_count < 0)\r\nun->un_open_count = 0;\r\nch->ch_open_count--;\r\nif (ch->ch_open_count && un->un_open_count) {\r\nspin_unlock_irqrestore(&ch->ch_lock, lock_flags);\r\nreturn;\r\n}\r\nun->un_flags |= UN_CLOSING;\r\ntty->closing = 1;\r\nif ((ch->ch_open_count == 0) &&\r\n!(ch->ch_digi.digi_flags & DIGI_PRINTER)) {\r\nch->ch_flags &= ~(CH_RXBLOCK);\r\nspin_unlock_irqrestore(&ch->ch_lock, lock_flags);\r\ndgap_wait_for_drain(tty);\r\ndgap_tty_flush_buffer(tty);\r\ntty_ldisc_flush(tty);\r\nspin_lock_irqsave(&ch->ch_lock, lock_flags);\r\ntty->closing = 0;\r\nif (ch->ch_c_cflag & HUPCL) {\r\nch->ch_mostat &= ~(D_RTS(ch) | D_DTR(ch));\r\ndgap_cmdb(ch, SMODEM, 0, D_DTR(ch) | D_RTS(ch), 0);\r\nspin_unlock_irqrestore(&ch->ch_lock,\r\nlock_flags);\r\nschedule_timeout_interruptible(msecs_to_jiffies(250));\r\nspin_lock_irqsave(&ch->ch_lock, lock_flags);\r\n}\r\nch->pscan_state = 0;\r\nch->pscan_savechar = 0;\r\nch->ch_baud_info = 0;\r\n}\r\nif ((un->un_type == DGAP_PRINT) && (ch->ch_flags & CH_PRON)) {\r\ndgap_wmove(ch, ch->ch_digi.digi_offstr,\r\n(int)ch->ch_digi.digi_offlen);\r\nch->ch_flags &= ~CH_PRON;\r\n}\r\nun->un_tty = NULL;\r\nun->un_flags &= ~(UN_ISOPEN | UN_CLOSING);\r\ntty->driver_data = NULL;\r\nwake_up_interruptible(&ch->ch_flags_wait);\r\nwake_up_interruptible(&un->un_flags_wait);\r\nspin_unlock_irqrestore(&ch->ch_lock, lock_flags);\r\n}\r\nstatic void dgap_tty_start(struct tty_struct *tty)\r\n{\r\nstruct board_t *bd;\r\nstruct channel_t *ch;\r\nstruct un_t *un;\r\nulong lock_flags;\r\nulong lock_flags2;\r\nif (!tty || tty->magic != TTY_MAGIC)\r\nreturn;\r\nun = tty->driver_data;\r\nif (!un || un->magic != DGAP_UNIT_MAGIC)\r\nreturn;\r\nch = un->un_ch;\r\nif (!ch || ch->magic != DGAP_CHANNEL_MAGIC)\r\nreturn;\r\nbd = ch->ch_bd;\r\nif (!bd || bd->magic != DGAP_BOARD_MAGIC)\r\nreturn;\r\nspin_lock_irqsave(&bd->bd_lock, lock_flags);\r\nspin_lock_irqsave(&ch->ch_lock, lock_flags2);\r\ndgap_cmdw(ch, RESUMETX, 0, 0);\r\nspin_unlock_irqrestore(&ch->ch_lock, lock_flags2);\r\nspin_unlock_irqrestore(&bd->bd_lock, lock_flags);\r\n}\r\nstatic void dgap_tty_stop(struct tty_struct *tty)\r\n{\r\nstruct board_t *bd;\r\nstruct channel_t *ch;\r\nstruct un_t *un;\r\nulong lock_flags;\r\nulong lock_flags2;\r\nif (!tty || tty->magic != TTY_MAGIC)\r\nreturn;\r\nun = tty->driver_data;\r\nif (!un || un->magic != DGAP_UNIT_MAGIC)\r\nreturn;\r\nch = un->un_ch;\r\nif (!ch || ch->magic != DGAP_CHANNEL_MAGIC)\r\nreturn;\r\nbd = ch->ch_bd;\r\nif (!bd || bd->magic != DGAP_BOARD_MAGIC)\r\nreturn;\r\nspin_lock_irqsave(&bd->bd_lock, lock_flags);\r\nspin_lock_irqsave(&ch->ch_lock, lock_flags2);\r\ndgap_cmdw(ch, PAUSETX, 0, 0);\r\nspin_unlock_irqrestore(&ch->ch_lock, lock_flags2);\r\nspin_unlock_irqrestore(&bd->bd_lock, lock_flags);\r\n}\r\nstatic void dgap_tty_flush_chars(struct tty_struct *tty)\r\n{\r\nstruct board_t *bd;\r\nstruct channel_t *ch;\r\nstruct un_t *un;\r\nulong lock_flags;\r\nulong lock_flags2;\r\nif (!tty || tty->magic != TTY_MAGIC)\r\nreturn;\r\nun = tty->driver_data;\r\nif (!un || un->magic != DGAP_UNIT_MAGIC)\r\nreturn;\r\nch = un->un_ch;\r\nif (!ch || ch->magic != DGAP_CHANNEL_MAGIC)\r\nreturn;\r\nbd = ch->ch_bd;\r\nif (!bd || bd->magic != DGAP_BOARD_MAGIC)\r\nreturn;\r\nspin_lock_irqsave(&bd->bd_lock, lock_flags);\r\nspin_lock_irqsave(&ch->ch_lock, lock_flags2);\r\nspin_unlock_irqrestore(&ch->ch_lock, lock_flags2);\r\nspin_unlock_irqrestore(&bd->bd_lock, lock_flags);\r\n}\r\nstatic int dgap_tty_ioctl(struct tty_struct *tty, unsigned int cmd,\r\nunsigned long arg)\r\n{\r\nstruct board_t *bd;\r\nstruct channel_t *ch;\r\nstruct un_t *un;\r\nint rc;\r\nu16 head;\r\nulong lock_flags = 0;\r\nulong lock_flags2 = 0;\r\nvoid __user *uarg = (void __user *)arg;\r\nif (!tty || tty->magic != TTY_MAGIC)\r\nreturn -ENODEV;\r\nun = tty->driver_data;\r\nif (!un || un->magic != DGAP_UNIT_MAGIC)\r\nreturn -ENODEV;\r\nch = un->un_ch;\r\nif (!ch || ch->magic != DGAP_CHANNEL_MAGIC)\r\nreturn -ENODEV;\r\nbd = ch->ch_bd;\r\nif (!bd || bd->magic != DGAP_BOARD_MAGIC)\r\nreturn -ENODEV;\r\nspin_lock_irqsave(&bd->bd_lock, lock_flags);\r\nspin_lock_irqsave(&ch->ch_lock, lock_flags2);\r\nif (un->un_open_count <= 0) {\r\nspin_unlock_irqrestore(&ch->ch_lock, lock_flags2);\r\nspin_unlock_irqrestore(&bd->bd_lock, lock_flags);\r\nreturn -EIO;\r\n}\r\nswitch (cmd) {\r\ncase TCSBRK:\r\nrc = tty_check_change(tty);\r\nspin_unlock_irqrestore(&ch->ch_lock, lock_flags2);\r\nspin_unlock_irqrestore(&bd->bd_lock, lock_flags);\r\nif (rc)\r\nreturn rc;\r\nrc = dgap_wait_for_drain(tty);\r\nif (rc)\r\nreturn -EINTR;\r\nspin_lock_irqsave(&bd->bd_lock, lock_flags);\r\nspin_lock_irqsave(&ch->ch_lock, lock_flags2);\r\nif (((cmd == TCSBRK) && (!arg)) || (cmd == TCSBRKP))\r\ndgap_cmdw(ch, SBREAK, (u16)SBREAK_TIME, 0);\r\nspin_unlock_irqrestore(&ch->ch_lock, lock_flags2);\r\nspin_unlock_irqrestore(&bd->bd_lock, lock_flags);\r\nreturn 0;\r\ncase TCSBRKP:\r\nrc = tty_check_change(tty);\r\nspin_unlock_irqrestore(&ch->ch_lock, lock_flags2);\r\nspin_unlock_irqrestore(&bd->bd_lock, lock_flags);\r\nif (rc)\r\nreturn rc;\r\nrc = dgap_wait_for_drain(tty);\r\nif (rc)\r\nreturn -EINTR;\r\nspin_lock_irqsave(&bd->bd_lock, lock_flags);\r\nspin_lock_irqsave(&ch->ch_lock, lock_flags2);\r\ndgap_cmdw(ch, SBREAK, (u16)SBREAK_TIME, 0);\r\nspin_unlock_irqrestore(&ch->ch_lock, lock_flags2);\r\nspin_unlock_irqrestore(&bd->bd_lock, lock_flags);\r\nreturn 0;\r\ncase TIOCSBRK:\r\nrc = tty_check_change(tty);\r\nspin_unlock_irqrestore(&ch->ch_lock, lock_flags2);\r\nspin_unlock_irqrestore(&bd->bd_lock, lock_flags);\r\nif (rc)\r\nreturn rc;\r\nrc = dgap_wait_for_drain(tty);\r\nif (rc)\r\nreturn -EINTR;\r\nspin_lock_irqsave(&bd->bd_lock, lock_flags);\r\nspin_lock_irqsave(&ch->ch_lock, lock_flags2);\r\ndgap_cmdw(ch, SBREAK, (u16)SBREAK_TIME, 0);\r\nspin_unlock_irqrestore(&ch->ch_lock, lock_flags2);\r\nspin_unlock_irqrestore(&bd->bd_lock, lock_flags);\r\nreturn 0;\r\ncase TIOCCBRK:\r\nspin_unlock_irqrestore(&ch->ch_lock, lock_flags2);\r\nspin_unlock_irqrestore(&bd->bd_lock, lock_flags);\r\nreturn 0;\r\ncase TIOCGSOFTCAR:\r\nspin_unlock_irqrestore(&ch->ch_lock, lock_flags2);\r\nspin_unlock_irqrestore(&bd->bd_lock, lock_flags);\r\nreturn put_user(C_CLOCAL(tty) ? 1 : 0,\r\n(unsigned long __user *)arg);\r\ncase TIOCSSOFTCAR:\r\nspin_unlock_irqrestore(&ch->ch_lock, lock_flags2);\r\nspin_unlock_irqrestore(&bd->bd_lock, lock_flags);\r\nrc = get_user(arg, (unsigned long __user *)arg);\r\nif (rc)\r\nreturn rc;\r\nspin_lock_irqsave(&bd->bd_lock, lock_flags);\r\nspin_lock_irqsave(&ch->ch_lock, lock_flags2);\r\ntty->termios.c_cflag = ((tty->termios.c_cflag & ~CLOCAL) |\r\n(arg ? CLOCAL : 0));\r\ndgap_param(ch, bd, un->un_type);\r\nspin_unlock_irqrestore(&ch->ch_lock, lock_flags2);\r\nspin_unlock_irqrestore(&bd->bd_lock, lock_flags);\r\nreturn 0;\r\ncase TIOCMGET:\r\nspin_unlock_irqrestore(&ch->ch_lock, lock_flags2);\r\nspin_unlock_irqrestore(&bd->bd_lock, lock_flags);\r\nreturn dgap_get_modem_info(ch, uarg);\r\ncase TIOCMBIS:\r\ncase TIOCMBIC:\r\ncase TIOCMSET:\r\nspin_unlock_irqrestore(&ch->ch_lock, lock_flags2);\r\nspin_unlock_irqrestore(&bd->bd_lock, lock_flags);\r\nreturn dgap_set_modem_info(ch, bd, un, cmd, uarg);\r\ncase TCFLSH:\r\nrc = tty_check_change(tty);\r\nif (rc) {\r\nspin_unlock_irqrestore(&ch->ch_lock, lock_flags2);\r\nspin_unlock_irqrestore(&bd->bd_lock, lock_flags);\r\nreturn rc;\r\n}\r\nif ((arg == TCIFLUSH) || (arg == TCIOFLUSH)) {\r\nif (!(un->un_type == DGAP_PRINT)) {\r\nhead = readw(&ch->ch_bs->rx_head);\r\nwritew(head, &ch->ch_bs->rx_tail);\r\nwriteb(0, &ch->ch_bs->orun);\r\n}\r\n}\r\nif ((arg != TCOFLUSH) && (arg != TCIOFLUSH)) {\r\nspin_unlock_irqrestore(&ch->ch_lock, lock_flags2);\r\nspin_unlock_irqrestore(&bd->bd_lock, lock_flags);\r\nreturn -ENOIOCTLCMD;\r\n}\r\nch->ch_flags &= ~CH_STOP;\r\nhead = readw(&ch->ch_bs->tx_head);\r\ndgap_cmdw(ch, FLUSHTX, (u16)head, 0);\r\ndgap_cmdw(ch, RESUMETX, 0, 0);\r\nif (ch->ch_tun.un_flags & (UN_LOW | UN_EMPTY)) {\r\nch->ch_tun.un_flags &= ~(UN_LOW | UN_EMPTY);\r\nwake_up_interruptible(&ch->ch_tun.un_flags_wait);\r\n}\r\nif (ch->ch_pun.un_flags & (UN_LOW | UN_EMPTY)) {\r\nch->ch_pun.un_flags &= ~(UN_LOW | UN_EMPTY);\r\nwake_up_interruptible(&ch->ch_pun.un_flags_wait);\r\n}\r\nif (waitqueue_active(&tty->write_wait))\r\nwake_up_interruptible(&tty->write_wait);\r\nspin_unlock_irqrestore(&ch->ch_lock, lock_flags2);\r\nspin_unlock_irqrestore(&bd->bd_lock, lock_flags);\r\ntty_wakeup(tty);\r\nreturn -ENOIOCTLCMD;\r\ncase TCSETSF:\r\ncase TCSETSW:\r\nif (cmd == TCSETSF) {\r\nch->ch_flags &= ~CH_STOP;\r\nhead = readw(&ch->ch_bs->rx_head);\r\nwritew(head, &ch->ch_bs->rx_tail);\r\n}\r\nspin_unlock_irqrestore(&ch->ch_lock, lock_flags2);\r\nspin_unlock_irqrestore(&bd->bd_lock, lock_flags);\r\nrc = dgap_wait_for_drain(tty);\r\nif (rc)\r\nreturn -EINTR;\r\nreturn -ENOIOCTLCMD;\r\ncase TCSETAW:\r\nspin_unlock_irqrestore(&ch->ch_lock, lock_flags2);\r\nspin_unlock_irqrestore(&bd->bd_lock, lock_flags);\r\nrc = dgap_wait_for_drain(tty);\r\nif (rc)\r\nreturn -EINTR;\r\nreturn -ENOIOCTLCMD;\r\ncase TCXONC:\r\nrc = tty_check_change(tty);\r\nif (rc) {\r\nspin_unlock_irqrestore(&ch->ch_lock, lock_flags2);\r\nspin_unlock_irqrestore(&bd->bd_lock, lock_flags);\r\nreturn rc;\r\n}\r\nswitch (arg) {\r\ncase TCOON:\r\nspin_unlock_irqrestore(&ch->ch_lock, lock_flags2);\r\nspin_unlock_irqrestore(&bd->bd_lock, lock_flags);\r\ndgap_tty_start(tty);\r\nreturn 0;\r\ncase TCOOFF:\r\nspin_unlock_irqrestore(&ch->ch_lock, lock_flags2);\r\nspin_unlock_irqrestore(&bd->bd_lock, lock_flags);\r\ndgap_tty_stop(tty);\r\nreturn 0;\r\ncase TCION:\r\nspin_unlock_irqrestore(&ch->ch_lock, lock_flags2);\r\nspin_unlock_irqrestore(&bd->bd_lock, lock_flags);\r\nreturn -ENOIOCTLCMD;\r\ncase TCIOFF:\r\nspin_unlock_irqrestore(&ch->ch_lock, lock_flags2);\r\nspin_unlock_irqrestore(&bd->bd_lock, lock_flags);\r\nreturn -ENOIOCTLCMD;\r\ndefault:\r\nspin_unlock_irqrestore(&ch->ch_lock, lock_flags2);\r\nspin_unlock_irqrestore(&bd->bd_lock, lock_flags);\r\nreturn -EINVAL;\r\n}\r\ncase DIGI_GETA:\r\nspin_unlock_irqrestore(&ch->ch_lock, lock_flags2);\r\nspin_unlock_irqrestore(&bd->bd_lock, lock_flags);\r\nreturn dgap_tty_digigeta(ch, uarg);\r\ncase DIGI_SETAW:\r\ncase DIGI_SETAF:\r\nif (cmd == (DIGI_SETAW)) {\r\nspin_unlock_irqrestore(&ch->ch_lock, lock_flags2);\r\nspin_unlock_irqrestore(&bd->bd_lock, lock_flags);\r\nrc = dgap_wait_for_drain(tty);\r\nif (rc)\r\nreturn -EINTR;\r\nspin_lock_irqsave(&bd->bd_lock, lock_flags);\r\nspin_lock_irqsave(&ch->ch_lock, lock_flags2);\r\n} else\r\ntty_ldisc_flush(tty);\r\ncase DIGI_SETA:\r\nspin_unlock_irqrestore(&ch->ch_lock, lock_flags2);\r\nspin_unlock_irqrestore(&bd->bd_lock, lock_flags);\r\nreturn dgap_tty_digiseta(ch, bd, un, uarg);\r\ncase DIGI_GEDELAY:\r\nspin_unlock_irqrestore(&ch->ch_lock, lock_flags2);\r\nspin_unlock_irqrestore(&bd->bd_lock, lock_flags);\r\nreturn dgap_tty_digigetedelay(tty, uarg);\r\ncase DIGI_SEDELAY:\r\nspin_unlock_irqrestore(&ch->ch_lock, lock_flags2);\r\nspin_unlock_irqrestore(&bd->bd_lock, lock_flags);\r\nreturn dgap_tty_digisetedelay(ch, bd, un, uarg);\r\ncase DIGI_GETCUSTOMBAUD:\r\nspin_unlock_irqrestore(&ch->ch_lock, lock_flags2);\r\nspin_unlock_irqrestore(&bd->bd_lock, lock_flags);\r\nreturn dgap_tty_digigetcustombaud(ch, un, uarg);\r\ncase DIGI_SETCUSTOMBAUD:\r\nspin_unlock_irqrestore(&ch->ch_lock, lock_flags2);\r\nspin_unlock_irqrestore(&bd->bd_lock, lock_flags);\r\nreturn dgap_tty_digisetcustombaud(ch, bd, un, uarg);\r\ncase DIGI_RESET_PORT:\r\ndgap_firmware_reset_port(ch);\r\ndgap_param(ch, bd, un->un_type);\r\nspin_unlock_irqrestore(&ch->ch_lock, lock_flags2);\r\nspin_unlock_irqrestore(&bd->bd_lock, lock_flags);\r\nreturn 0;\r\ndefault:\r\nspin_unlock_irqrestore(&ch->ch_lock, lock_flags2);\r\nspin_unlock_irqrestore(&bd->bd_lock, lock_flags);\r\nreturn -ENOIOCTLCMD;\r\n}\r\n}\r\nstatic int dgap_tty_register(struct board_t *brd)\r\n{\r\nint rc;\r\nbrd->serial_driver = tty_alloc_driver(MAXPORTS,\r\nTTY_DRIVER_REAL_RAW |\r\nTTY_DRIVER_DYNAMIC_DEV |\r\nTTY_DRIVER_HARDWARE_BREAK);\r\nif (IS_ERR(brd->serial_driver))\r\nreturn PTR_ERR(brd->serial_driver);\r\nsnprintf(brd->serial_name, MAXTTYNAMELEN, "tty_dgap_%d_",\r\nbrd->boardnum);\r\nbrd->serial_driver->name = brd->serial_name;\r\nbrd->serial_driver->name_base = 0;\r\nbrd->serial_driver->major = 0;\r\nbrd->serial_driver->minor_start = 0;\r\nbrd->serial_driver->type = TTY_DRIVER_TYPE_SERIAL;\r\nbrd->serial_driver->subtype = SERIAL_TYPE_NORMAL;\r\nbrd->serial_driver->init_termios = dgap_default_termios;\r\nbrd->serial_driver->driver_name = DRVSTR;\r\ntty_set_operations(brd->serial_driver, &dgap_tty_ops);\r\nbrd->print_driver = tty_alloc_driver(MAXPORTS,\r\nTTY_DRIVER_REAL_RAW |\r\nTTY_DRIVER_DYNAMIC_DEV |\r\nTTY_DRIVER_HARDWARE_BREAK);\r\nif (IS_ERR(brd->print_driver)) {\r\nrc = PTR_ERR(brd->print_driver);\r\ngoto free_serial_drv;\r\n}\r\nsnprintf(brd->print_name, MAXTTYNAMELEN, "pr_dgap_%d_",\r\nbrd->boardnum);\r\nbrd->print_driver->name = brd->print_name;\r\nbrd->print_driver->name_base = 0;\r\nbrd->print_driver->major = 0;\r\nbrd->print_driver->minor_start = 0;\r\nbrd->print_driver->type = TTY_DRIVER_TYPE_SERIAL;\r\nbrd->print_driver->subtype = SERIAL_TYPE_NORMAL;\r\nbrd->print_driver->init_termios = dgap_default_termios;\r\nbrd->print_driver->driver_name = DRVSTR;\r\ntty_set_operations(brd->print_driver, &dgap_tty_ops);\r\nrc = tty_register_driver(brd->serial_driver);\r\nif (rc < 0)\r\ngoto free_print_drv;\r\nrc = tty_register_driver(brd->print_driver);\r\nif (rc < 0)\r\ngoto unregister_serial_drv;\r\nreturn 0;\r\nunregister_serial_drv:\r\ntty_unregister_driver(brd->serial_driver);\r\nfree_print_drv:\r\nput_tty_driver(brd->print_driver);\r\nfree_serial_drv:\r\nput_tty_driver(brd->serial_driver);\r\nreturn rc;\r\n}\r\nstatic void dgap_tty_unregister(struct board_t *brd)\r\n{\r\ntty_unregister_driver(brd->print_driver);\r\ntty_unregister_driver(brd->serial_driver);\r\nput_tty_driver(brd->print_driver);\r\nput_tty_driver(brd->serial_driver);\r\n}\r\nstatic int dgap_alloc_flipbuf(struct board_t *brd)\r\n{\r\nbrd->flipbuf = kmalloc(MYFLIPLEN, GFP_KERNEL);\r\nif (!brd->flipbuf)\r\nreturn -ENOMEM;\r\nbrd->flipflagbuf = kmalloc(MYFLIPLEN, GFP_KERNEL);\r\nif (!brd->flipflagbuf) {\r\nkfree(brd->flipbuf);\r\nreturn -ENOMEM;\r\n}\r\nreturn 0;\r\n}\r\nstatic void dgap_free_flipbuf(struct board_t *brd)\r\n{\r\nkfree(brd->flipbuf);\r\nkfree(brd->flipflagbuf);\r\n}\r\nstatic struct board_t *dgap_verify_board(struct device *p)\r\n{\r\nstruct board_t *bd;\r\nif (!p)\r\nreturn NULL;\r\nbd = dev_get_drvdata(p);\r\nif (!bd || bd->magic != DGAP_BOARD_MAGIC || bd->state != BOARD_READY)\r\nreturn NULL;\r\nreturn bd;\r\n}\r\nstatic ssize_t dgap_ports_state_show(struct device *p,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct board_t *bd;\r\nint count = 0;\r\nunsigned int i;\r\nbd = dgap_verify_board(p);\r\nif (!bd)\r\nreturn 0;\r\nfor (i = 0; i < bd->nasync; i++) {\r\ncount += snprintf(buf + count, PAGE_SIZE - count,\r\n"%d %s\n", bd->channels[i]->ch_portnum,\r\nbd->channels[i]->ch_open_count ? "Open" : "Closed");\r\n}\r\nreturn count;\r\n}\r\nstatic ssize_t dgap_ports_baud_show(struct device *p,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct board_t *bd;\r\nint count = 0;\r\nunsigned int i;\r\nbd = dgap_verify_board(p);\r\nif (!bd)\r\nreturn 0;\r\nfor (i = 0; i < bd->nasync; i++) {\r\ncount += snprintf(buf + count, PAGE_SIZE - count, "%d %d\n",\r\nbd->channels[i]->ch_portnum,\r\nbd->channels[i]->ch_baud_info);\r\n}\r\nreturn count;\r\n}\r\nstatic ssize_t dgap_ports_msignals_show(struct device *p,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct board_t *bd;\r\nint count = 0;\r\nunsigned int i;\r\nbd = dgap_verify_board(p);\r\nif (!bd)\r\nreturn 0;\r\nfor (i = 0; i < bd->nasync; i++) {\r\nif (bd->channels[i]->ch_open_count)\r\ncount += snprintf(buf + count, PAGE_SIZE - count,\r\n"%d %s %s %s %s %s %s\n",\r\nbd->channels[i]->ch_portnum,\r\n(bd->channels[i]->ch_mostat &\r\nUART_MCR_RTS) ? "RTS" : "",\r\n(bd->channels[i]->ch_mistat &\r\nUART_MSR_CTS) ? "CTS" : "",\r\n(bd->channels[i]->ch_mostat &\r\nUART_MCR_DTR) ? "DTR" : "",\r\n(bd->channels[i]->ch_mistat &\r\nUART_MSR_DSR) ? "DSR" : "",\r\n(bd->channels[i]->ch_mistat &\r\nUART_MSR_DCD) ? "DCD" : "",\r\n(bd->channels[i]->ch_mistat &\r\nUART_MSR_RI) ? "RI" : "");\r\nelse\r\ncount += snprintf(buf + count, PAGE_SIZE - count,\r\n"%d\n", bd->channels[i]->ch_portnum);\r\n}\r\nreturn count;\r\n}\r\nstatic ssize_t dgap_ports_iflag_show(struct device *p,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct board_t *bd;\r\nint count = 0;\r\nunsigned int i;\r\nbd = dgap_verify_board(p);\r\nif (!bd)\r\nreturn 0;\r\nfor (i = 0; i < bd->nasync; i++)\r\ncount += snprintf(buf + count, PAGE_SIZE - count, "%d %x\n",\r\nbd->channels[i]->ch_portnum,\r\nbd->channels[i]->ch_c_iflag);\r\nreturn count;\r\n}\r\nstatic ssize_t dgap_ports_cflag_show(struct device *p,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct board_t *bd;\r\nint count = 0;\r\nunsigned int i;\r\nbd = dgap_verify_board(p);\r\nif (!bd)\r\nreturn 0;\r\nfor (i = 0; i < bd->nasync; i++)\r\ncount += snprintf(buf + count, PAGE_SIZE - count, "%d %x\n",\r\nbd->channels[i]->ch_portnum,\r\nbd->channels[i]->ch_c_cflag);\r\nreturn count;\r\n}\r\nstatic ssize_t dgap_ports_oflag_show(struct device *p,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct board_t *bd;\r\nint count = 0;\r\nunsigned int i;\r\nbd = dgap_verify_board(p);\r\nif (!bd)\r\nreturn 0;\r\nfor (i = 0; i < bd->nasync; i++)\r\ncount += snprintf(buf + count, PAGE_SIZE - count, "%d %x\n",\r\nbd->channels[i]->ch_portnum,\r\nbd->channels[i]->ch_c_oflag);\r\nreturn count;\r\n}\r\nstatic ssize_t dgap_ports_lflag_show(struct device *p,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct board_t *bd;\r\nint count = 0;\r\nunsigned int i;\r\nbd = dgap_verify_board(p);\r\nif (!bd)\r\nreturn 0;\r\nfor (i = 0; i < bd->nasync; i++)\r\ncount += snprintf(buf + count, PAGE_SIZE - count, "%d %x\n",\r\nbd->channels[i]->ch_portnum,\r\nbd->channels[i]->ch_c_lflag);\r\nreturn count;\r\n}\r\nstatic ssize_t dgap_ports_digi_flag_show(struct device *p,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct board_t *bd;\r\nint count = 0;\r\nunsigned int i;\r\nbd = dgap_verify_board(p);\r\nif (!bd)\r\nreturn 0;\r\nfor (i = 0; i < bd->nasync; i++)\r\ncount += snprintf(buf + count, PAGE_SIZE - count, "%d %x\n",\r\nbd->channels[i]->ch_portnum,\r\nbd->channels[i]->ch_digi.digi_flags);\r\nreturn count;\r\n}\r\nstatic ssize_t dgap_ports_rxcount_show(struct device *p,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct board_t *bd;\r\nint count = 0;\r\nunsigned int i;\r\nbd = dgap_verify_board(p);\r\nif (!bd)\r\nreturn 0;\r\nfor (i = 0; i < bd->nasync; i++)\r\ncount += snprintf(buf + count, PAGE_SIZE - count, "%d %ld\n",\r\nbd->channels[i]->ch_portnum,\r\nbd->channels[i]->ch_rxcount);\r\nreturn count;\r\n}\r\nstatic ssize_t dgap_ports_txcount_show(struct device *p,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct board_t *bd;\r\nint count = 0;\r\nunsigned int i;\r\nbd = dgap_verify_board(p);\r\nif (!bd)\r\nreturn 0;\r\nfor (i = 0; i < bd->nasync; i++)\r\ncount += snprintf(buf + count, PAGE_SIZE - count, "%d %ld\n",\r\nbd->channels[i]->ch_portnum,\r\nbd->channels[i]->ch_txcount);\r\nreturn count;\r\n}\r\nstatic ssize_t dgap_tty_state_show(struct device *d,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct board_t *bd;\r\nstruct channel_t *ch;\r\nstruct un_t *un;\r\nif (!d)\r\nreturn 0;\r\nun = dev_get_drvdata(d);\r\nif (!un || un->magic != DGAP_UNIT_MAGIC)\r\nreturn 0;\r\nch = un->un_ch;\r\nif (!ch || ch->magic != DGAP_CHANNEL_MAGIC)\r\nreturn 0;\r\nbd = ch->ch_bd;\r\nif (!bd || bd->magic != DGAP_BOARD_MAGIC)\r\nreturn 0;\r\nif (bd->state != BOARD_READY)\r\nreturn 0;\r\nreturn snprintf(buf, PAGE_SIZE, "%s", un->un_open_count ?\r\n"Open" : "Closed");\r\n}\r\nstatic ssize_t dgap_tty_baud_show(struct device *d,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct board_t *bd;\r\nstruct channel_t *ch;\r\nstruct un_t *un;\r\nif (!d)\r\nreturn 0;\r\nun = dev_get_drvdata(d);\r\nif (!un || un->magic != DGAP_UNIT_MAGIC)\r\nreturn 0;\r\nch = un->un_ch;\r\nif (!ch || ch->magic != DGAP_CHANNEL_MAGIC)\r\nreturn 0;\r\nbd = ch->ch_bd;\r\nif (!bd || bd->magic != DGAP_BOARD_MAGIC)\r\nreturn 0;\r\nif (bd->state != BOARD_READY)\r\nreturn 0;\r\nreturn snprintf(buf, PAGE_SIZE, "%d\n", ch->ch_baud_info);\r\n}\r\nstatic ssize_t dgap_tty_msignals_show(struct device *d,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct board_t *bd;\r\nstruct channel_t *ch;\r\nstruct un_t *un;\r\nif (!d)\r\nreturn 0;\r\nun = dev_get_drvdata(d);\r\nif (!un || un->magic != DGAP_UNIT_MAGIC)\r\nreturn 0;\r\nch = un->un_ch;\r\nif (!ch || ch->magic != DGAP_CHANNEL_MAGIC)\r\nreturn 0;\r\nbd = ch->ch_bd;\r\nif (!bd || bd->magic != DGAP_BOARD_MAGIC)\r\nreturn 0;\r\nif (bd->state != BOARD_READY)\r\nreturn 0;\r\nif (ch->ch_open_count) {\r\nreturn snprintf(buf, PAGE_SIZE, "%s %s %s %s %s %s\n",\r\n(ch->ch_mostat & UART_MCR_RTS) ? "RTS" : "",\r\n(ch->ch_mistat & UART_MSR_CTS) ? "CTS" : "",\r\n(ch->ch_mostat & UART_MCR_DTR) ? "DTR" : "",\r\n(ch->ch_mistat & UART_MSR_DSR) ? "DSR" : "",\r\n(ch->ch_mistat & UART_MSR_DCD) ? "DCD" : "",\r\n(ch->ch_mistat & UART_MSR_RI) ? "RI" : "");\r\n}\r\nreturn 0;\r\n}\r\nstatic ssize_t dgap_tty_iflag_show(struct device *d,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct board_t *bd;\r\nstruct channel_t *ch;\r\nstruct un_t *un;\r\nif (!d)\r\nreturn 0;\r\nun = dev_get_drvdata(d);\r\nif (!un || un->magic != DGAP_UNIT_MAGIC)\r\nreturn 0;\r\nch = un->un_ch;\r\nif (!ch || ch->magic != DGAP_CHANNEL_MAGIC)\r\nreturn 0;\r\nbd = ch->ch_bd;\r\nif (!bd || bd->magic != DGAP_BOARD_MAGIC)\r\nreturn 0;\r\nif (bd->state != BOARD_READY)\r\nreturn 0;\r\nreturn snprintf(buf, PAGE_SIZE, "%x\n", ch->ch_c_iflag);\r\n}\r\nstatic ssize_t dgap_tty_cflag_show(struct device *d,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct board_t *bd;\r\nstruct channel_t *ch;\r\nstruct un_t *un;\r\nif (!d)\r\nreturn 0;\r\nun = dev_get_drvdata(d);\r\nif (!un || un->magic != DGAP_UNIT_MAGIC)\r\nreturn 0;\r\nch = un->un_ch;\r\nif (!ch || ch->magic != DGAP_CHANNEL_MAGIC)\r\nreturn 0;\r\nbd = ch->ch_bd;\r\nif (!bd || bd->magic != DGAP_BOARD_MAGIC)\r\nreturn 0;\r\nif (bd->state != BOARD_READY)\r\nreturn 0;\r\nreturn snprintf(buf, PAGE_SIZE, "%x\n", ch->ch_c_cflag);\r\n}\r\nstatic ssize_t dgap_tty_oflag_show(struct device *d,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct board_t *bd;\r\nstruct channel_t *ch;\r\nstruct un_t *un;\r\nif (!d)\r\nreturn 0;\r\nun = dev_get_drvdata(d);\r\nif (!un || un->magic != DGAP_UNIT_MAGIC)\r\nreturn 0;\r\nch = un->un_ch;\r\nif (!ch || ch->magic != DGAP_CHANNEL_MAGIC)\r\nreturn 0;\r\nbd = ch->ch_bd;\r\nif (!bd || bd->magic != DGAP_BOARD_MAGIC)\r\nreturn 0;\r\nif (bd->state != BOARD_READY)\r\nreturn 0;\r\nreturn snprintf(buf, PAGE_SIZE, "%x\n", ch->ch_c_oflag);\r\n}\r\nstatic ssize_t dgap_tty_lflag_show(struct device *d,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct board_t *bd;\r\nstruct channel_t *ch;\r\nstruct un_t *un;\r\nif (!d)\r\nreturn 0;\r\nun = dev_get_drvdata(d);\r\nif (!un || un->magic != DGAP_UNIT_MAGIC)\r\nreturn 0;\r\nch = un->un_ch;\r\nif (!ch || ch->magic != DGAP_CHANNEL_MAGIC)\r\nreturn 0;\r\nbd = ch->ch_bd;\r\nif (!bd || bd->magic != DGAP_BOARD_MAGIC)\r\nreturn 0;\r\nif (bd->state != BOARD_READY)\r\nreturn 0;\r\nreturn snprintf(buf, PAGE_SIZE, "%x\n", ch->ch_c_lflag);\r\n}\r\nstatic ssize_t dgap_tty_digi_flag_show(struct device *d,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct board_t *bd;\r\nstruct channel_t *ch;\r\nstruct un_t *un;\r\nif (!d)\r\nreturn 0;\r\nun = dev_get_drvdata(d);\r\nif (!un || un->magic != DGAP_UNIT_MAGIC)\r\nreturn 0;\r\nch = un->un_ch;\r\nif (!ch || ch->magic != DGAP_CHANNEL_MAGIC)\r\nreturn 0;\r\nbd = ch->ch_bd;\r\nif (!bd || bd->magic != DGAP_BOARD_MAGIC)\r\nreturn 0;\r\nif (bd->state != BOARD_READY)\r\nreturn 0;\r\nreturn snprintf(buf, PAGE_SIZE, "%x\n", ch->ch_digi.digi_flags);\r\n}\r\nstatic ssize_t dgap_tty_rxcount_show(struct device *d,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct board_t *bd;\r\nstruct channel_t *ch;\r\nstruct un_t *un;\r\nif (!d)\r\nreturn 0;\r\nun = dev_get_drvdata(d);\r\nif (!un || un->magic != DGAP_UNIT_MAGIC)\r\nreturn 0;\r\nch = un->un_ch;\r\nif (!ch || ch->magic != DGAP_CHANNEL_MAGIC)\r\nreturn 0;\r\nbd = ch->ch_bd;\r\nif (!bd || bd->magic != DGAP_BOARD_MAGIC)\r\nreturn 0;\r\nif (bd->state != BOARD_READY)\r\nreturn 0;\r\nreturn snprintf(buf, PAGE_SIZE, "%ld\n", ch->ch_rxcount);\r\n}\r\nstatic ssize_t dgap_tty_txcount_show(struct device *d,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct board_t *bd;\r\nstruct channel_t *ch;\r\nstruct un_t *un;\r\nif (!d)\r\nreturn 0;\r\nun = dev_get_drvdata(d);\r\nif (!un || un->magic != DGAP_UNIT_MAGIC)\r\nreturn 0;\r\nch = un->un_ch;\r\nif (!ch || ch->magic != DGAP_CHANNEL_MAGIC)\r\nreturn 0;\r\nbd = ch->ch_bd;\r\nif (!bd || bd->magic != DGAP_BOARD_MAGIC)\r\nreturn 0;\r\nif (bd->state != BOARD_READY)\r\nreturn 0;\r\nreturn snprintf(buf, PAGE_SIZE, "%ld\n", ch->ch_txcount);\r\n}\r\nstatic ssize_t dgap_tty_name_show(struct device *d,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct board_t *bd;\r\nstruct channel_t *ch;\r\nstruct un_t *un;\r\nint cn;\r\nint bn;\r\nstruct cnode *cptr;\r\nint found = FALSE;\r\nint ncount = 0;\r\nint starto = 0;\r\nint i;\r\nif (!d)\r\nreturn 0;\r\nun = dev_get_drvdata(d);\r\nif (!un || un->magic != DGAP_UNIT_MAGIC)\r\nreturn 0;\r\nch = un->un_ch;\r\nif (!ch || ch->magic != DGAP_CHANNEL_MAGIC)\r\nreturn 0;\r\nbd = ch->ch_bd;\r\nif (!bd || bd->magic != DGAP_BOARD_MAGIC)\r\nreturn 0;\r\nif (bd->state != BOARD_READY)\r\nreturn 0;\r\nbn = bd->boardnum;\r\ncn = ch->ch_portnum;\r\nfor (cptr = bd->bd_config; cptr; cptr = cptr->next) {\r\nif ((cptr->type == BNODE) &&\r\n((cptr->u.board.type == APORT2_920P) ||\r\n(cptr->u.board.type == APORT4_920P) ||\r\n(cptr->u.board.type == APORT8_920P) ||\r\n(cptr->u.board.type == PAPORT4) ||\r\n(cptr->u.board.type == PAPORT8))) {\r\nfound = TRUE;\r\nif (cptr->u.board.v_start)\r\nstarto = cptr->u.board.start;\r\nelse\r\nstarto = 1;\r\n}\r\nif (cptr->type == TNODE && found == TRUE) {\r\nchar *ptr1;\r\nif (strstr(cptr->u.ttyname, "tty")) {\r\nptr1 = cptr->u.ttyname;\r\nptr1 += 3;\r\n} else\r\nptr1 = cptr->u.ttyname;\r\nfor (i = 0; i < dgap_config_get_num_prts(bd); i++) {\r\nif (cn != i)\r\ncontinue;\r\nreturn snprintf(buf, PAGE_SIZE, "%s%s%02d\n",\r\n(un->un_type == DGAP_PRINT) ?\r\n"pr" : "tty",\r\nptr1, i + starto);\r\n}\r\n}\r\nif (cptr->type == CNODE) {\r\nfor (i = 0; i < cptr->u.conc.nport; i++) {\r\nif (cn != (i + ncount))\r\ncontinue;\r\nreturn snprintf(buf, PAGE_SIZE, "%s%s%02ld\n",\r\n(un->un_type == DGAP_PRINT) ?\r\n"pr" : "tty",\r\ncptr->u.conc.id,\r\ni + (cptr->u.conc.v_start ?\r\ncptr->u.conc.start : 1));\r\n}\r\nncount += cptr->u.conc.nport;\r\n}\r\nif (cptr->type == MNODE) {\r\nfor (i = 0; i < cptr->u.module.nport; i++) {\r\nif (cn != (i + ncount))\r\ncontinue;\r\nreturn snprintf(buf, PAGE_SIZE, "%s%s%02ld\n",\r\n(un->un_type == DGAP_PRINT) ?\r\n"pr" : "tty",\r\ncptr->u.module.id,\r\ni + (cptr->u.module.v_start ?\r\ncptr->u.module.start : 1));\r\n}\r\nncount += cptr->u.module.nport;\r\n}\r\n}\r\nreturn snprintf(buf, PAGE_SIZE, "%s_dgap_%d_%d\n",\r\n(un->un_type == DGAP_PRINT) ? "pr" : "tty", bn, cn);\r\n}\r\nstatic void dgap_create_ports_sysfiles(struct board_t *bd)\r\n{\r\ndev_set_drvdata(&bd->pdev->dev, bd);\r\ndevice_create_file(&bd->pdev->dev, &dev_attr_ports_state);\r\ndevice_create_file(&bd->pdev->dev, &dev_attr_ports_baud);\r\ndevice_create_file(&bd->pdev->dev, &dev_attr_ports_msignals);\r\ndevice_create_file(&bd->pdev->dev, &dev_attr_ports_iflag);\r\ndevice_create_file(&bd->pdev->dev, &dev_attr_ports_cflag);\r\ndevice_create_file(&bd->pdev->dev, &dev_attr_ports_oflag);\r\ndevice_create_file(&bd->pdev->dev, &dev_attr_ports_lflag);\r\ndevice_create_file(&bd->pdev->dev, &dev_attr_ports_digi_flag);\r\ndevice_create_file(&bd->pdev->dev, &dev_attr_ports_rxcount);\r\ndevice_create_file(&bd->pdev->dev, &dev_attr_ports_txcount);\r\n}\r\nstatic void dgap_remove_ports_sysfiles(struct board_t *bd)\r\n{\r\ndevice_remove_file(&bd->pdev->dev, &dev_attr_ports_state);\r\ndevice_remove_file(&bd->pdev->dev, &dev_attr_ports_baud);\r\ndevice_remove_file(&bd->pdev->dev, &dev_attr_ports_msignals);\r\ndevice_remove_file(&bd->pdev->dev, &dev_attr_ports_iflag);\r\ndevice_remove_file(&bd->pdev->dev, &dev_attr_ports_cflag);\r\ndevice_remove_file(&bd->pdev->dev, &dev_attr_ports_oflag);\r\ndevice_remove_file(&bd->pdev->dev, &dev_attr_ports_lflag);\r\ndevice_remove_file(&bd->pdev->dev, &dev_attr_ports_digi_flag);\r\ndevice_remove_file(&bd->pdev->dev, &dev_attr_ports_rxcount);\r\ndevice_remove_file(&bd->pdev->dev, &dev_attr_ports_txcount);\r\n}\r\nstatic void dgap_do_bios_load(struct board_t *brd, const u8 *ubios, int len)\r\n{\r\nu8 __iomem *addr;\r\nuint offset;\r\nunsigned int i;\r\nif (!brd || (brd->magic != DGAP_BOARD_MAGIC) || !brd->re_map_membase)\r\nreturn;\r\naddr = brd->re_map_membase;\r\nfor (i = 0; i < 16; i++)\r\nwriteb(0, addr + POSTAREA + i);\r\noffset = 0x1000;\r\nmemcpy_toio(addr + offset, ubios, len);\r\nwritel(0x0bf00401, addr);\r\nwritel(0, (addr + 4));\r\nwriteb(FEPCLR, brd->re_map_port);\r\n}\r\nstatic int dgap_test_bios(struct board_t *brd)\r\n{\r\nu8 __iomem *addr;\r\nu16 word;\r\nu16 err1;\r\nu16 err2;\r\nif (!brd || (brd->magic != DGAP_BOARD_MAGIC) || !brd->re_map_membase)\r\nreturn -EINVAL;\r\naddr = brd->re_map_membase;\r\nword = readw(addr + POSTAREA);\r\nbrd->wait_for_bios = 0;\r\nwhile (brd->wait_for_bios < 1000) {\r\nif (word == *(u16 *)"GD")\r\nreturn 0;\r\nmsleep_interruptible(10);\r\nbrd->wait_for_bios++;\r\nword = readw(addr + POSTAREA);\r\n}\r\nerr1 = readw(addr + SEQUENCE);\r\nerr2 = readw(addr + ERROR);\r\ndev_warn(&brd->pdev->dev, "%s failed diagnostics. Error #(%x,%x).\n",\r\nbrd->name, err1, err2);\r\nbrd->state = BOARD_FAILED;\r\nbrd->dpastatus = BD_NOBIOS;\r\nreturn -EIO;\r\n}\r\nstatic void dgap_do_fep_load(struct board_t *brd, const u8 *ufep, int len)\r\n{\r\nu8 __iomem *addr;\r\nuint offset;\r\nif (!brd || (brd->magic != DGAP_BOARD_MAGIC) || !brd->re_map_membase)\r\nreturn;\r\naddr = brd->re_map_membase;\r\noffset = 0x1000;\r\nmemcpy_toio(addr + offset, ufep, len);\r\nif ((brd->type == PCX) || (brd->type == PEPC)) {\r\nu8 string[100];\r\nu8 __iomem *config;\r\nu8 *xconfig;\r\nunsigned int i = 0;\r\nxconfig = dgap_create_config_string(brd, string);\r\nconfig = addr + CONFIG;\r\nfor (; i < CONFIGSIZE; i++, config++, xconfig++) {\r\nwriteb(*xconfig, config);\r\nif ((*xconfig & 0xff) == 0xff)\r\nbreak;\r\n}\r\n}\r\nwritel(0xbfc01004, (addr + 0xc34));\r\nwritel(0x3, (addr + 0xc30));\r\n}\r\nstatic int dgap_test_fep(struct board_t *brd)\r\n{\r\nu8 __iomem *addr;\r\nu16 word;\r\nu16 err1;\r\nu16 err2;\r\nif (!brd || (brd->magic != DGAP_BOARD_MAGIC) || !brd->re_map_membase)\r\nreturn -EINVAL;\r\naddr = brd->re_map_membase;\r\nword = readw(addr + FEPSTAT);\r\nbrd->wait_for_fep = 0;\r\nwhile (brd->wait_for_fep < 500) {\r\nif (word == *(u16 *)"OS") {\r\nword = readw(addr + FEP5_PLUS);\r\nif (word == *(u16 *)"5A")\r\nbrd->bd_flags |= BD_FEP5PLUS;\r\nreturn 0;\r\n}\r\nmsleep_interruptible(10);\r\nbrd->wait_for_fep++;\r\nword = readw(addr + FEPSTAT);\r\n}\r\nerr1 = readw(addr + SEQUENCE);\r\nerr2 = readw(addr + ERROR);\r\ndev_warn(&brd->pdev->dev,\r\n"FEPOS for %s not functioning. Error #(%x,%x).\n",\r\nbrd->name, err1, err2);\r\nbrd->state = BOARD_FAILED;\r\nbrd->dpastatus = BD_NOFEP;\r\nreturn -EIO;\r\n}\r\nstatic void dgap_do_reset_board(struct board_t *brd)\r\n{\r\nu8 check;\r\nu32 check1;\r\nu32 check2;\r\nunsigned int i;\r\nif (!brd || (brd->magic != DGAP_BOARD_MAGIC) ||\r\n!brd->re_map_membase || !brd->re_map_port)\r\nreturn;\r\nwriteb(FEPRST, brd->re_map_port);\r\nfor (i = 0; i <= 1000; i++) {\r\ncheck = readb(brd->re_map_port) & 0xe;\r\nif (check == FEPRST)\r\nbreak;\r\nudelay(10);\r\n}\r\nif (i > 1000) {\r\ndev_warn(&brd->pdev->dev,\r\n"dgap: Board not resetting... Failing board.\n");\r\nbrd->state = BOARD_FAILED;\r\nbrd->dpastatus = BD_NOFEP;\r\nreturn;\r\n}\r\nwritel(0xa55a3cc3, (brd->re_map_membase + LOWMEM));\r\nwritel(0x5aa5c33c, (brd->re_map_membase + HIGHMEM));\r\ncheck1 = readl(brd->re_map_membase + LOWMEM);\r\ncheck2 = readl(brd->re_map_membase + HIGHMEM);\r\nif ((check1 != 0xa55a3cc3) || (check2 != 0x5aa5c33c)) {\r\ndev_warn(&brd->pdev->dev,\r\n"No memory at %p for board.\n",\r\nbrd->re_map_membase);\r\nbrd->state = BOARD_FAILED;\r\nbrd->dpastatus = BD_NOFEP;\r\nreturn;\r\n}\r\n}\r\nstatic void dgap_do_conc_load(struct board_t *brd, u8 *uaddr, int len)\r\n{\r\nchar __iomem *vaddr;\r\nu16 offset;\r\nstruct downld_t *to_dp;\r\nif (!brd || (brd->magic != DGAP_BOARD_MAGIC) || !brd->re_map_membase)\r\nreturn;\r\nvaddr = brd->re_map_membase;\r\noffset = readw((u16 *)(vaddr + DOWNREQ));\r\nto_dp = (struct downld_t *)(vaddr + (int)offset);\r\nmemcpy_toio(to_dp, uaddr, len);\r\nwritew(0, vaddr + (DOWNREQ));\r\nbrd->conc_dl_status = NO_PENDING_CONCENTRATOR_REQUESTS;\r\n}\r\nstatic void dgap_get_vpd(struct board_t *brd)\r\n{\r\nu32 magic;\r\nu32 base_offset;\r\nu16 rom_offset;\r\nu16 vpd_offset;\r\nu16 image_length;\r\nu16 i;\r\nu8 byte1;\r\nu8 byte2;\r\nmagic = FEP5_ROM_MAGIC;\r\npci_write_config_dword(brd->pdev, PCI_ROM_ADDRESS, magic);\r\npci_read_config_dword(brd->pdev, PCI_ROM_ADDRESS, &magic);\r\nif (!magic)\r\nreturn;\r\nmagic = brd->membase | 0x01;\r\npci_write_config_dword(brd->pdev, PCI_ROM_ADDRESS, magic);\r\npci_read_config_dword(brd->pdev, PCI_ROM_ADDRESS, &magic);\r\nbyte1 = readb(brd->re_map_membase);\r\nbyte2 = readb(brd->re_map_membase + 1);\r\nif (byte1 == 0x55 && byte2 == 0xAA) {\r\nbase_offset = 0;\r\nwhile (base_offset <= EXPANSION_ROM_SIZE) {\r\nrom_offset = readw(brd->re_map_membase +\r\nbase_offset + 0x18);\r\nimage_length = readw(brd->re_map_membase +\r\nrom_offset + 0x10) * 512;\r\nvpd_offset = readw(brd->re_map_membase +\r\nrom_offset + 0x08);\r\nif (vpd_offset)\r\nbreak;\r\nbase_offset += image_length;\r\nbyte1 = readb(brd->re_map_membase + base_offset);\r\nbyte2 = readb(brd->re_map_membase + base_offset + 1);\r\nif (byte1 != 0x55 || byte2 != 0xAA)\r\nbreak;\r\n}\r\nif (vpd_offset) {\r\nbrd->bd_flags |= BD_HAS_VPD;\r\nfor (i = 0; i < VPDSIZE; i++) {\r\nbrd->vpd[i] = readb(brd->re_map_membase +\r\nvpd_offset + i);\r\n}\r\n}\r\n}\r\nmagic = FEP5_ROM_MAGIC;\r\npci_write_config_dword(brd->pdev, PCI_ROM_ADDRESS, magic);\r\n}\r\nstatic ssize_t dgap_driver_version_show(struct device_driver *ddp, char *buf)\r\n{\r\nreturn snprintf(buf, PAGE_SIZE, "%s\n", DG_PART);\r\n}\r\nstatic ssize_t dgap_driver_boards_show(struct device_driver *ddp, char *buf)\r\n{\r\nreturn snprintf(buf, PAGE_SIZE, "%d\n", dgap_numboards);\r\n}\r\nstatic ssize_t dgap_driver_maxboards_show(struct device_driver *ddp, char *buf)\r\n{\r\nreturn snprintf(buf, PAGE_SIZE, "%d\n", MAXBOARDS);\r\n}\r\nstatic ssize_t dgap_driver_pollcounter_show(struct device_driver *ddp,\r\nchar *buf)\r\n{\r\nreturn snprintf(buf, PAGE_SIZE, "%ld\n", dgap_poll_counter);\r\n}\r\nstatic ssize_t dgap_driver_pollrate_show(struct device_driver *ddp, char *buf)\r\n{\r\nreturn snprintf(buf, PAGE_SIZE, "%dms\n", dgap_poll_tick);\r\n}\r\nstatic ssize_t dgap_driver_pollrate_store(struct device_driver *ddp,\r\nconst char *buf, size_t count)\r\n{\r\nif (sscanf(buf, "%d\n", &dgap_poll_tick) != 1)\r\nreturn -EINVAL;\r\nreturn count;\r\n}\r\nstatic int dgap_create_driver_sysfiles(struct pci_driver *dgap_driver)\r\n{\r\nint rc = 0;\r\nstruct device_driver *driverfs = &dgap_driver->driver;\r\nrc |= driver_create_file(driverfs, &driver_attr_version);\r\nrc |= driver_create_file(driverfs, &driver_attr_boards);\r\nrc |= driver_create_file(driverfs, &driver_attr_maxboards);\r\nrc |= driver_create_file(driverfs, &driver_attr_pollrate);\r\nrc |= driver_create_file(driverfs, &driver_attr_pollcounter);\r\nreturn rc;\r\n}\r\nstatic void dgap_remove_driver_sysfiles(struct pci_driver *dgap_driver)\r\n{\r\nstruct device_driver *driverfs = &dgap_driver->driver;\r\ndriver_remove_file(driverfs, &driver_attr_version);\r\ndriver_remove_file(driverfs, &driver_attr_boards);\r\ndriver_remove_file(driverfs, &driver_attr_maxboards);\r\ndriver_remove_file(driverfs, &driver_attr_pollrate);\r\ndriver_remove_file(driverfs, &driver_attr_pollcounter);\r\n}\r\nstatic void dgap_create_tty_sysfs(struct un_t *un, struct device *c)\r\n{\r\nint ret;\r\nret = sysfs_create_group(&c->kobj, &dgap_tty_attribute_group);\r\nif (ret)\r\nreturn;\r\ndev_set_drvdata(c, un);\r\n}\r\nstatic void dgap_remove_tty_sysfs(struct device *c)\r\n{\r\nsysfs_remove_group(&c->kobj, &dgap_tty_attribute_group);\r\n}\r\nstatic int dgap_tty_register_ports(struct board_t *brd)\r\n{\r\nstruct channel_t *ch;\r\nint i;\r\nint ret;\r\nbrd->serial_ports = kcalloc(brd->nasync, sizeof(*brd->serial_ports),\r\nGFP_KERNEL);\r\nif (!brd->serial_ports)\r\nreturn -ENOMEM;\r\nbrd->printer_ports = kcalloc(brd->nasync, sizeof(*brd->printer_ports),\r\nGFP_KERNEL);\r\nif (!brd->printer_ports) {\r\nret = -ENOMEM;\r\ngoto free_serial_ports;\r\n}\r\nfor (i = 0; i < brd->nasync; i++) {\r\ntty_port_init(&brd->serial_ports[i]);\r\ntty_port_init(&brd->printer_ports[i]);\r\n}\r\nch = brd->channels[0];\r\nfor (i = 0; i < brd->nasync; i++, ch = brd->channels[i]) {\r\nstruct device *classp;\r\nclassp = tty_port_register_device(&brd->serial_ports[i],\r\nbrd->serial_driver,\r\ni, NULL);\r\nif (IS_ERR(classp)) {\r\nret = PTR_ERR(classp);\r\ngoto unregister_ttys;\r\n}\r\ndgap_create_tty_sysfs(&ch->ch_tun, classp);\r\nch->ch_tun.un_sysfs = classp;\r\nclassp = tty_port_register_device(&brd->printer_ports[i],\r\nbrd->print_driver,\r\ni, NULL);\r\nif (IS_ERR(classp)) {\r\nret = PTR_ERR(classp);\r\ngoto unregister_ttys;\r\n}\r\ndgap_create_tty_sysfs(&ch->ch_pun, classp);\r\nch->ch_pun.un_sysfs = classp;\r\n}\r\ndgap_create_ports_sysfiles(brd);\r\nreturn 0;\r\nunregister_ttys:\r\nwhile (i >= 0) {\r\nch = brd->channels[i];\r\nif (ch->ch_tun.un_sysfs) {\r\ndgap_remove_tty_sysfs(ch->ch_tun.un_sysfs);\r\ntty_unregister_device(brd->serial_driver, i);\r\n}\r\nif (ch->ch_pun.un_sysfs) {\r\ndgap_remove_tty_sysfs(ch->ch_pun.un_sysfs);\r\ntty_unregister_device(brd->print_driver, i);\r\n}\r\ni--;\r\n}\r\nfor (i = 0; i < brd->nasync; i++) {\r\ntty_port_destroy(&brd->serial_ports[i]);\r\ntty_port_destroy(&brd->printer_ports[i]);\r\n}\r\nkfree(brd->printer_ports);\r\nbrd->printer_ports = NULL;\r\nfree_serial_ports:\r\nkfree(brd->serial_ports);\r\nbrd->serial_ports = NULL;\r\nreturn ret;\r\n}\r\nstatic void dgap_cleanup_tty(struct board_t *brd)\r\n{\r\nstruct device *dev;\r\nunsigned int i;\r\nfor (i = 0; i < brd->nasync; i++) {\r\ntty_port_destroy(&brd->serial_ports[i]);\r\ndev = brd->channels[i]->ch_tun.un_sysfs;\r\ndgap_remove_tty_sysfs(dev);\r\ntty_unregister_device(brd->serial_driver, i);\r\n}\r\ntty_unregister_driver(brd->serial_driver);\r\nput_tty_driver(brd->serial_driver);\r\nkfree(brd->serial_ports);\r\nfor (i = 0; i < brd->nasync; i++) {\r\ntty_port_destroy(&brd->printer_ports[i]);\r\ndev = brd->channels[i]->ch_pun.un_sysfs;\r\ndgap_remove_tty_sysfs(dev);\r\ntty_unregister_device(brd->print_driver, i);\r\n}\r\ntty_unregister_driver(brd->print_driver);\r\nput_tty_driver(brd->print_driver);\r\nkfree(brd->printer_ports);\r\n}\r\nstatic int dgap_request_irq(struct board_t *brd)\r\n{\r\nint rc;\r\nif (!brd || brd->magic != DGAP_BOARD_MAGIC)\r\nreturn -ENODEV;\r\nif (dgap_config_get_useintr(brd) && brd->irq) {\r\nrc = request_irq(brd->irq, dgap_intr, IRQF_SHARED, "DGAP", brd);\r\nif (!rc)\r\nbrd->intr_used = 1;\r\n}\r\nreturn 0;\r\n}\r\nstatic void dgap_free_irq(struct board_t *brd)\r\n{\r\nif (brd->intr_used && brd->irq)\r\nfree_irq(brd->irq, brd);\r\n}\r\nstatic int dgap_firmware_load(struct pci_dev *pdev, int card_type,\r\nstruct board_t *brd)\r\n{\r\nconst struct firmware *fw;\r\nchar *tmp_ptr;\r\nint ret;\r\nchar *dgap_config_buf;\r\ndgap_get_vpd(brd);\r\ndgap_do_reset_board(brd);\r\nif (fw_info[card_type].conf_name) {\r\nret = request_firmware(&fw, fw_info[card_type].conf_name,\r\n&pdev->dev);\r\nif (ret) {\r\ndev_err(&pdev->dev, "config file %s not found\n",\r\nfw_info[card_type].conf_name);\r\nreturn ret;\r\n}\r\ndgap_config_buf = kzalloc(fw->size + 1, GFP_KERNEL);\r\nif (!dgap_config_buf) {\r\nrelease_firmware(fw);\r\nreturn -ENOMEM;\r\n}\r\nmemcpy(dgap_config_buf, fw->data, fw->size);\r\nrelease_firmware(fw);\r\ntmp_ptr = dgap_config_buf;\r\nif (dgap_parsefile(&tmp_ptr) != 0) {\r\nkfree(dgap_config_buf);\r\nreturn -EINVAL;\r\n}\r\nkfree(dgap_config_buf);\r\n}\r\nbrd->bd_config =\r\ndgap_find_config(brd->type, brd->pci_bus, brd->pci_slot);\r\nif (brd->type == PAPORT8 && !brd->bd_config)\r\nbrd->bd_config =\r\ndgap_find_config(PAPORT4, brd->pci_bus, brd->pci_slot);\r\nif (!brd->bd_config) {\r\ndev_err(&pdev->dev, "No valid configuration found\n");\r\nreturn -EINVAL;\r\n}\r\nif (fw_info[card_type].bios_name) {\r\nret = request_firmware(&fw, fw_info[card_type].bios_name,\r\n&pdev->dev);\r\nif (ret) {\r\ndev_err(&pdev->dev, "bios file %s not found\n",\r\nfw_info[card_type].bios_name);\r\nreturn ret;\r\n}\r\ndgap_do_bios_load(brd, fw->data, fw->size);\r\nrelease_firmware(fw);\r\nret = dgap_test_bios(brd);\r\nif (ret)\r\nreturn ret;\r\n}\r\nif (fw_info[card_type].fep_name) {\r\nret = request_firmware(&fw, fw_info[card_type].fep_name,\r\n&pdev->dev);\r\nif (ret) {\r\ndev_err(&pdev->dev, "dgap: fep file %s not found\n",\r\nfw_info[card_type].fep_name);\r\nreturn ret;\r\n}\r\ndgap_do_fep_load(brd, fw->data, fw->size);\r\nrelease_firmware(fw);\r\nret = dgap_test_fep(brd);\r\nif (ret)\r\nreturn ret;\r\n}\r\n#ifdef DIGI_CONCENTRATORS_SUPPORTED\r\nif ((bd->type == PCX) || (bd->type == PEPC)) {\r\nchk_addr = (u16 *)(vaddr + DOWNREQ);\r\ncheck = readw(chk_addr);\r\nvaddr = brd->re_map_membase;\r\n}\r\nif (fw_info[card_type].con_name && check && vaddr) {\r\nret = request_firmware(&fw, fw_info[card_type].con_name,\r\n&pdev->dev);\r\nif (ret) {\r\ndev_err(&pdev->dev, "conc file %s not found\n",\r\nfw_info[card_type].con_name);\r\nreturn ret;\r\n}\r\noffset = readw((u16 *)(vaddr + DOWNREQ));\r\nmemcpy_toio(offset, fw->data, fw->size);\r\ndgap_do_conc_load(brd, (char *)fw->data, fw->size)\r\nrelease_firmware(fw);\r\n}\r\n#endif\r\nreturn 0;\r\n}\r\nstatic int dgap_tty_init(struct board_t *brd)\r\n{\r\nint i;\r\nint tlw;\r\nuint true_count;\r\nu8 __iomem *vaddr;\r\nu8 modem;\r\nstruct channel_t *ch;\r\nstruct bs_t __iomem *bs;\r\nstruct cm_t __iomem *cm;\r\nint ret;\r\nvaddr = brd->re_map_membase;\r\ntrue_count = readw((vaddr + NCHAN));\r\nbrd->nasync = dgap_config_get_num_prts(brd);\r\nif (!brd->nasync)\r\nbrd->nasync = brd->maxports;\r\nif (brd->nasync > brd->maxports)\r\nbrd->nasync = brd->maxports;\r\nif (true_count != brd->nasync) {\r\ndev_warn(&brd->pdev->dev,\r\n"%s configured for %d ports, has %d ports.\n",\r\nbrd->name, brd->nasync, true_count);\r\nif ((brd->type == PPCM) &&\r\n(true_count == 64 || true_count == 0)) {\r\ndev_warn(&brd->pdev->dev,\r\n"Please make SURE the EBI cable running from the card\n");\r\ndev_warn(&brd->pdev->dev,\r\n"to each EM module is plugged into EBI IN!\n");\r\n}\r\nbrd->nasync = true_count;\r\nif (!brd->nasync) {\r\nbrd->state = BOARD_FAILED;\r\nbrd->dpastatus = BD_NOFEP;\r\nreturn -EIO;\r\n}\r\n}\r\nfor (i = 0; i < brd->nasync; i++) {\r\nbrd->channels[i] =\r\nkzalloc(sizeof(struct channel_t), GFP_KERNEL);\r\nif (!brd->channels[i]) {\r\nret = -ENOMEM;\r\ngoto free_chan;\r\n}\r\n}\r\nch = brd->channels[0];\r\nvaddr = brd->re_map_membase;\r\nbs = (struct bs_t __iomem *)((ulong)vaddr + CHANBUF);\r\ncm = (struct cm_t __iomem *)((ulong)vaddr + CMDBUF);\r\nbrd->bd_bs = bs;\r\nfor (i = 0; i < brd->nasync; i++, ch = brd->channels[i], bs++) {\r\nspin_lock_init(&ch->ch_lock);\r\nch->magic = DGAP_CHANNEL_MAGIC;\r\nch->ch_tun.magic = DGAP_UNIT_MAGIC;\r\nch->ch_tun.un_type = DGAP_SERIAL;\r\nch->ch_tun.un_ch = ch;\r\nch->ch_tun.un_dev = i;\r\nch->ch_pun.magic = DGAP_UNIT_MAGIC;\r\nch->ch_pun.un_type = DGAP_PRINT;\r\nch->ch_pun.un_ch = ch;\r\nch->ch_pun.un_dev = i;\r\nch->ch_vaddr = vaddr;\r\nch->ch_bs = bs;\r\nch->ch_cm = cm;\r\nch->ch_bd = brd;\r\nch->ch_portnum = i;\r\nch->ch_digi = dgap_digi_init;\r\nif (dgap_config_get_altpin(brd)) {\r\nch->ch_dsr = DM_CD;\r\nch->ch_cd = DM_DSR;\r\nch->ch_digi.digi_flags |= DIGI_ALTPIN;\r\n} else {\r\nch->ch_cd = DM_CD;\r\nch->ch_dsr = DM_DSR;\r\n}\r\nch->ch_taddr = vaddr + (ioread16(&ch->ch_bs->tx_seg) << 4);\r\nch->ch_raddr = vaddr + (ioread16(&ch->ch_bs->rx_seg) << 4);\r\nch->ch_tx_win = 0;\r\nch->ch_rx_win = 0;\r\nch->ch_tsize = readw(&ch->ch_bs->tx_max) + 1;\r\nch->ch_rsize = readw(&ch->ch_bs->rx_max) + 1;\r\nch->ch_tstart = 0;\r\nch->ch_rstart = 0;\r\ntlw = ch->ch_tsize >= 2000 ? ((ch->ch_tsize * 5) / 8) :\r\nch->ch_tsize / 2;\r\nch->ch_tlw = tlw;\r\ndgap_cmdw(ch, STLOW, tlw, 0);\r\ndgap_cmdw(ch, SRLOW, ch->ch_rsize / 2, 0);\r\ndgap_cmdw(ch, SRHIGH, 7 * ch->ch_rsize / 8, 0);\r\nch->ch_mistat = readb(&ch->ch_bs->m_stat);\r\ninit_waitqueue_head(&ch->ch_flags_wait);\r\ninit_waitqueue_head(&ch->ch_tun.un_flags_wait);\r\ninit_waitqueue_head(&ch->ch_pun.un_flags_wait);\r\nmodem = (DM_CD | DM_DSR | DM_CTS | DM_RI);\r\nwriteb(modem, &ch->ch_bs->m_int);\r\nif (brd->intr_used)\r\nwritew(0, &ch->ch_bs->edelay);\r\nelse\r\nwritew(100, &ch->ch_bs->edelay);\r\nwriteb(1, &ch->ch_bs->idata);\r\n}\r\nreturn 0;\r\nfree_chan:\r\nwhile (--i >= 0) {\r\nkfree(brd->channels[i]);\r\nbrd->channels[i] = NULL;\r\n}\r\nreturn ret;\r\n}\r\nstatic void dgap_tty_free(struct board_t *brd)\r\n{\r\nint i;\r\nfor (i = 0; i < brd->nasync; i++)\r\nkfree(brd->channels[i]);\r\n}\r\nstatic int dgap_init_one(struct pci_dev *pdev, const struct pci_device_id *ent)\r\n{\r\nint rc;\r\nstruct board_t *brd;\r\nif (dgap_numboards >= MAXBOARDS)\r\nreturn -EPERM;\r\nrc = pci_enable_device(pdev);\r\nif (rc)\r\nreturn -EIO;\r\nbrd = dgap_found_board(pdev, ent->driver_data, dgap_numboards);\r\nif (IS_ERR(brd))\r\nreturn PTR_ERR(brd);\r\nrc = dgap_firmware_load(pdev, ent->driver_data, brd);\r\nif (rc)\r\ngoto cleanup_brd;\r\nrc = dgap_alloc_flipbuf(brd);\r\nif (rc)\r\ngoto cleanup_brd;\r\nrc = dgap_tty_register(brd);\r\nif (rc)\r\ngoto free_flipbuf;\r\nrc = dgap_request_irq(brd);\r\nif (rc)\r\ngoto unregister_tty;\r\nrc = dgap_tty_init(brd);\r\nif (rc < 0)\r\ngoto free_irq;\r\nrc = dgap_tty_register_ports(brd);\r\nif (rc)\r\ngoto tty_free;\r\nbrd->state = BOARD_READY;\r\nbrd->dpastatus = BD_RUNNING;\r\ndgap_board[dgap_numboards++] = brd;\r\nreturn 0;\r\ntty_free:\r\ndgap_tty_free(brd);\r\nfree_irq:\r\ndgap_free_irq(brd);\r\nunregister_tty:\r\ndgap_tty_unregister(brd);\r\nfree_flipbuf:\r\ndgap_free_flipbuf(brd);\r\ncleanup_brd:\r\ndgap_cleanup_nodes();\r\ndgap_unmap(brd);\r\nkfree(brd);\r\nreturn rc;\r\n}\r\nstatic void dgap_cleanup_board(struct board_t *brd)\r\n{\r\nunsigned int i;\r\nif (!brd || brd->magic != DGAP_BOARD_MAGIC)\r\nreturn;\r\ndgap_free_irq(brd);\r\ntasklet_kill(&brd->helper_tasklet);\r\ndgap_unmap(brd);\r\nfor (i = 0; i < MAXPORTS ; i++)\r\nkfree(brd->channels[i]);\r\nkfree(brd->flipbuf);\r\nkfree(brd->flipflagbuf);\r\ndgap_board[brd->boardnum] = NULL;\r\nkfree(brd);\r\n}\r\nstatic void dgap_stop(bool removesys, struct pci_driver *drv)\r\n{\r\nunsigned long lock_flags;\r\nspin_lock_irqsave(&dgap_poll_lock, lock_flags);\r\ndgap_poll_stop = 1;\r\nspin_unlock_irqrestore(&dgap_poll_lock, lock_flags);\r\ndel_timer_sync(&dgap_poll_timer);\r\nif (removesys)\r\ndgap_remove_driver_sysfiles(drv);\r\ndevice_destroy(dgap_class, MKDEV(DIGI_DGAP_MAJOR, 0));\r\nclass_destroy(dgap_class);\r\nunregister_chrdev(DIGI_DGAP_MAJOR, "dgap");\r\n}\r\nstatic void dgap_remove_one(struct pci_dev *dev)\r\n{\r\nunsigned int i;\r\nstruct pci_driver *drv = to_pci_driver(dev->dev.driver);\r\ndgap_stop(true, drv);\r\nfor (i = 0; i < dgap_numboards; ++i) {\r\ndgap_remove_ports_sysfiles(dgap_board[i]);\r\ndgap_cleanup_tty(dgap_board[i]);\r\ndgap_cleanup_board(dgap_board[i]);\r\n}\r\ndgap_cleanup_nodes();\r\n}\r\nstatic int dgap_start(void)\r\n{\r\nint rc;\r\nunsigned long flags;\r\nstruct device *device;\r\ndgap_numboards = 0;\r\npr_info("For the tools package please visit http://www.digi.com\n");\r\nrc = register_chrdev(DIGI_DGAP_MAJOR, "dgap", &dgap_board_fops);\r\nif (rc < 0)\r\nreturn rc;\r\ndgap_class = class_create(THIS_MODULE, "dgap_mgmt");\r\nif (IS_ERR(dgap_class)) {\r\nrc = PTR_ERR(dgap_class);\r\ngoto failed_class;\r\n}\r\ndevice = device_create(dgap_class, NULL,\r\nMKDEV(DIGI_DGAP_MAJOR, 0),\r\nNULL, "dgap_mgmt");\r\nif (IS_ERR(device)) {\r\nrc = PTR_ERR(device);\r\ngoto failed_device;\r\n}\r\nspin_lock_irqsave(&dgap_poll_lock, flags);\r\nsetup_timer(&dgap_poll_timer, dgap_poll_handler, 0);\r\ndgap_poll_timer.data = 0;\r\ndgap_poll_time = jiffies + dgap_jiffies_from_ms(dgap_poll_tick);\r\ndgap_poll_timer.expires = dgap_poll_time;\r\nspin_unlock_irqrestore(&dgap_poll_lock, flags);\r\nadd_timer(&dgap_poll_timer);\r\nreturn rc;\r\nfailed_device:\r\nclass_destroy(dgap_class);\r\nfailed_class:\r\nunregister_chrdev(DIGI_DGAP_MAJOR, "dgap");\r\nreturn rc;\r\n}\r\nstatic int dgap_init_module(void)\r\n{\r\nint rc;\r\npr_info("%s, Digi International Part Number %s\n", DG_NAME, DG_PART);\r\nrc = dgap_start();\r\nif (rc)\r\nreturn rc;\r\nrc = pci_register_driver(&dgap_driver);\r\nif (rc) {\r\ndgap_stop(false, NULL);\r\nreturn rc;\r\n}\r\nrc = dgap_create_driver_sysfiles(&dgap_driver);\r\nif (rc)\r\ngoto err_unregister;\r\ndgap_driver_state = DRIVER_READY;\r\nreturn 0;\r\nerr_unregister:\r\npci_unregister_driver(&dgap_driver);\r\nreturn rc;\r\n}\r\nstatic void dgap_cleanup_module(void)\r\n{\r\nif (dgap_numboards)\r\npci_unregister_driver(&dgap_driver);\r\n}
