static void atl1c_pcie_patch(struct atl1c_hw *hw)\r\n{\r\nu32 mst_data, data;\r\nAT_READ_REG(hw, REG_MASTER_CTRL, &mst_data);\r\nmst_data &= ~MASTER_CTRL_CLK_SEL_DIS;\r\nAT_WRITE_REG(hw, REG_MASTER_CTRL, mst_data);\r\nif (hw->nic_type == athr_l1c || hw->nic_type == athr_l2c) {\r\nAT_READ_REG(hw, REG_PCIE_PHYMISC, &data);\r\ndata |= PCIE_PHYMISC_FORCE_RCV_DET;\r\nAT_WRITE_REG(hw, REG_PCIE_PHYMISC, data);\r\n} else {\r\nif (!(mst_data & MASTER_CTRL_WAKEN_25M))\r\nAT_WRITE_REG(hw, REG_MASTER_CTRL,\r\nmst_data | MASTER_CTRL_WAKEN_25M);\r\n}\r\nif (hw->nic_type == athr_l2c_b && hw->revision_id == L2CB_V10) {\r\nAT_READ_REG(hw, REG_PCIE_PHYMISC2, &data);\r\ndata = FIELD_SETX(data, PCIE_PHYMISC2_CDR_BW,\r\nL2CB1_PCIE_PHYMISC2_CDR_BW);\r\ndata = FIELD_SETX(data, PCIE_PHYMISC2_L0S_TH,\r\nL2CB1_PCIE_PHYMISC2_L0S_TH);\r\nAT_WRITE_REG(hw, REG_PCIE_PHYMISC2, data);\r\nAT_READ_REG(hw, REG_LINK_CTRL, &data);\r\ndata |= LINK_CTRL_EXT_SYNC;\r\nAT_WRITE_REG(hw, REG_LINK_CTRL, data);\r\n}\r\nif (hw->nic_type == athr_l2c_b || hw->nic_type == athr_l1d) {\r\nAT_READ_REG(hw, REG_PM_CTRL, &data);\r\ndata |= PM_CTRL_L0S_BUFSRX_EN;\r\nAT_WRITE_REG(hw, REG_PM_CTRL, data);\r\nAT_READ_REG(hw, REG_DMA_DBG, &data);\r\nAT_WRITE_REG(hw, REG_DMA_DBG, data & ~DMA_DBG_VENDOR_MSG);\r\n}\r\n}\r\nstatic void atl1c_reset_pcie(struct atl1c_hw *hw, u32 flag)\r\n{\r\nu32 data;\r\nu32 pci_cmd;\r\nstruct pci_dev *pdev = hw->adapter->pdev;\r\nint pos;\r\nAT_READ_REG(hw, PCI_COMMAND, &pci_cmd);\r\npci_cmd &= ~PCI_COMMAND_INTX_DISABLE;\r\npci_cmd |= (PCI_COMMAND_MEMORY | PCI_COMMAND_MASTER |\r\nPCI_COMMAND_IO);\r\nAT_WRITE_REG(hw, PCI_COMMAND, pci_cmd);\r\npci_enable_wake(pdev, PCI_D3hot, 0);\r\npci_enable_wake(pdev, PCI_D3cold, 0);\r\nAT_READ_REG(hw, REG_WOL_CTRL, &data);\r\nAT_WRITE_REG(hw, REG_WOL_CTRL, 0);\r\npos = pci_find_ext_capability(pdev, PCI_EXT_CAP_ID_ERR);\r\nif (pos) {\r\npci_read_config_dword(pdev, pos + PCI_ERR_UNCOR_SEVER, &data);\r\ndata &= ~(PCI_ERR_UNC_DLP | PCI_ERR_UNC_FCP);\r\npci_write_config_dword(pdev, pos + PCI_ERR_UNCOR_SEVER, data);\r\n}\r\npcie_capability_write_word(pdev, PCI_EXP_DEVSTA,\r\nPCI_EXP_DEVSTA_NFED |\r\nPCI_EXP_DEVSTA_FED |\r\nPCI_EXP_DEVSTA_CED |\r\nPCI_EXP_DEVSTA_URD);\r\nAT_READ_REG(hw, REG_LTSSM_ID_CTRL, &data);\r\ndata &= ~LTSSM_ID_EN_WRO;\r\nAT_WRITE_REG(hw, REG_LTSSM_ID_CTRL, data);\r\natl1c_pcie_patch(hw);\r\nif (flag & ATL1C_PCIE_L0S_L1_DISABLE)\r\natl1c_disable_l0s_l1(hw);\r\nmsleep(5);\r\n}\r\nstatic inline void atl1c_irq_enable(struct atl1c_adapter *adapter)\r\n{\r\nif (likely(atomic_dec_and_test(&adapter->irq_sem))) {\r\nAT_WRITE_REG(&adapter->hw, REG_ISR, 0x7FFFFFFF);\r\nAT_WRITE_REG(&adapter->hw, REG_IMR, adapter->hw.intr_mask);\r\nAT_WRITE_FLUSH(&adapter->hw);\r\n}\r\n}\r\nstatic inline void atl1c_irq_disable(struct atl1c_adapter *adapter)\r\n{\r\natomic_inc(&adapter->irq_sem);\r\nAT_WRITE_REG(&adapter->hw, REG_IMR, 0);\r\nAT_WRITE_REG(&adapter->hw, REG_ISR, ISR_DIS_INT);\r\nAT_WRITE_FLUSH(&adapter->hw);\r\nsynchronize_irq(adapter->pdev->irq);\r\n}\r\nstatic inline void atl1c_irq_reset(struct atl1c_adapter *adapter)\r\n{\r\natomic_set(&adapter->irq_sem, 1);\r\natl1c_irq_enable(adapter);\r\n}\r\nstatic u32 atl1c_wait_until_idle(struct atl1c_hw *hw, u32 modu_ctrl)\r\n{\r\nint timeout;\r\nu32 data;\r\nfor (timeout = 0; timeout < AT_HW_MAX_IDLE_DELAY; timeout++) {\r\nAT_READ_REG(hw, REG_IDLE_STATUS, &data);\r\nif ((data & modu_ctrl) == 0)\r\nreturn 0;\r\nmsleep(1);\r\n}\r\nreturn data;\r\n}\r\nstatic void atl1c_phy_config(unsigned long data)\r\n{\r\nstruct atl1c_adapter *adapter = (struct atl1c_adapter *) data;\r\nstruct atl1c_hw *hw = &adapter->hw;\r\nunsigned long flags;\r\nspin_lock_irqsave(&adapter->mdio_lock, flags);\r\natl1c_restart_autoneg(hw);\r\nspin_unlock_irqrestore(&adapter->mdio_lock, flags);\r\n}\r\nvoid atl1c_reinit_locked(struct atl1c_adapter *adapter)\r\n{\r\nWARN_ON(in_interrupt());\r\natl1c_down(adapter);\r\natl1c_up(adapter);\r\nclear_bit(__AT_RESETTING, &adapter->flags);\r\n}\r\nstatic void atl1c_check_link_status(struct atl1c_adapter *adapter)\r\n{\r\nstruct atl1c_hw *hw = &adapter->hw;\r\nstruct net_device *netdev = adapter->netdev;\r\nstruct pci_dev *pdev = adapter->pdev;\r\nint err;\r\nunsigned long flags;\r\nu16 speed, duplex, phy_data;\r\nspin_lock_irqsave(&adapter->mdio_lock, flags);\r\natl1c_read_phy_reg(hw, MII_BMSR, &phy_data);\r\natl1c_read_phy_reg(hw, MII_BMSR, &phy_data);\r\nspin_unlock_irqrestore(&adapter->mdio_lock, flags);\r\nif ((phy_data & BMSR_LSTATUS) == 0) {\r\nnetif_carrier_off(netdev);\r\nhw->hibernate = true;\r\nif (atl1c_reset_mac(hw) != 0)\r\nif (netif_msg_hw(adapter))\r\ndev_warn(&pdev->dev, "reset mac failed\n");\r\natl1c_set_aspm(hw, SPEED_0);\r\natl1c_post_phy_linkchg(hw, SPEED_0);\r\natl1c_reset_dma_ring(adapter);\r\natl1c_configure(adapter);\r\n} else {\r\nhw->hibernate = false;\r\nspin_lock_irqsave(&adapter->mdio_lock, flags);\r\nerr = atl1c_get_speed_and_duplex(hw, &speed, &duplex);\r\nspin_unlock_irqrestore(&adapter->mdio_lock, flags);\r\nif (unlikely(err))\r\nreturn;\r\nif (adapter->link_speed != speed ||\r\nadapter->link_duplex != duplex) {\r\nadapter->link_speed = speed;\r\nadapter->link_duplex = duplex;\r\natl1c_set_aspm(hw, speed);\r\natl1c_post_phy_linkchg(hw, speed);\r\natl1c_start_mac(adapter);\r\nif (netif_msg_link(adapter))\r\ndev_info(&pdev->dev,\r\n"%s: %s NIC Link is Up<%d Mbps %s>\n",\r\natl1c_driver_name, netdev->name,\r\nadapter->link_speed,\r\nadapter->link_duplex == FULL_DUPLEX ?\r\n"Full Duplex" : "Half Duplex");\r\n}\r\nif (!netif_carrier_ok(netdev))\r\nnetif_carrier_on(netdev);\r\n}\r\n}\r\nstatic void atl1c_link_chg_event(struct atl1c_adapter *adapter)\r\n{\r\nstruct net_device *netdev = adapter->netdev;\r\nstruct pci_dev *pdev = adapter->pdev;\r\nu16 phy_data;\r\nu16 link_up;\r\nspin_lock(&adapter->mdio_lock);\r\natl1c_read_phy_reg(&adapter->hw, MII_BMSR, &phy_data);\r\natl1c_read_phy_reg(&adapter->hw, MII_BMSR, &phy_data);\r\nspin_unlock(&adapter->mdio_lock);\r\nlink_up = phy_data & BMSR_LSTATUS;\r\nif (!link_up) {\r\nif (netif_carrier_ok(netdev)) {\r\nnetif_carrier_off(netdev);\r\nif (netif_msg_link(adapter))\r\ndev_info(&pdev->dev,\r\n"%s: %s NIC Link is Down\n",\r\natl1c_driver_name, netdev->name);\r\nadapter->link_speed = SPEED_0;\r\n}\r\n}\r\nset_bit(ATL1C_WORK_EVENT_LINK_CHANGE, &adapter->work_event);\r\nschedule_work(&adapter->common_task);\r\n}\r\nstatic void atl1c_common_task(struct work_struct *work)\r\n{\r\nstruct atl1c_adapter *adapter;\r\nstruct net_device *netdev;\r\nadapter = container_of(work, struct atl1c_adapter, common_task);\r\nnetdev = adapter->netdev;\r\nif (test_bit(__AT_DOWN, &adapter->flags))\r\nreturn;\r\nif (test_and_clear_bit(ATL1C_WORK_EVENT_RESET, &adapter->work_event)) {\r\nnetif_device_detach(netdev);\r\natl1c_down(adapter);\r\natl1c_up(adapter);\r\nnetif_device_attach(netdev);\r\n}\r\nif (test_and_clear_bit(ATL1C_WORK_EVENT_LINK_CHANGE,\r\n&adapter->work_event)) {\r\natl1c_irq_disable(adapter);\r\natl1c_check_link_status(adapter);\r\natl1c_irq_enable(adapter);\r\n}\r\n}\r\nstatic void atl1c_del_timer(struct atl1c_adapter *adapter)\r\n{\r\ndel_timer_sync(&adapter->phy_config_timer);\r\n}\r\nstatic void atl1c_tx_timeout(struct net_device *netdev)\r\n{\r\nstruct atl1c_adapter *adapter = netdev_priv(netdev);\r\nset_bit(ATL1C_WORK_EVENT_RESET, &adapter->work_event);\r\nschedule_work(&adapter->common_task);\r\n}\r\nstatic void atl1c_set_multi(struct net_device *netdev)\r\n{\r\nstruct atl1c_adapter *adapter = netdev_priv(netdev);\r\nstruct atl1c_hw *hw = &adapter->hw;\r\nstruct netdev_hw_addr *ha;\r\nu32 mac_ctrl_data;\r\nu32 hash_value;\r\nAT_READ_REG(hw, REG_MAC_CTRL, &mac_ctrl_data);\r\nif (netdev->flags & IFF_PROMISC) {\r\nmac_ctrl_data |= MAC_CTRL_PROMIS_EN;\r\n} else if (netdev->flags & IFF_ALLMULTI) {\r\nmac_ctrl_data |= MAC_CTRL_MC_ALL_EN;\r\nmac_ctrl_data &= ~MAC_CTRL_PROMIS_EN;\r\n} else {\r\nmac_ctrl_data &= ~(MAC_CTRL_PROMIS_EN | MAC_CTRL_MC_ALL_EN);\r\n}\r\nAT_WRITE_REG(hw, REG_MAC_CTRL, mac_ctrl_data);\r\nAT_WRITE_REG(hw, REG_RX_HASH_TABLE, 0);\r\nAT_WRITE_REG_ARRAY(hw, REG_RX_HASH_TABLE, 1, 0);\r\nnetdev_for_each_mc_addr(ha, netdev) {\r\nhash_value = atl1c_hash_mc_addr(hw, ha->addr);\r\natl1c_hash_set(hw, hash_value);\r\n}\r\n}\r\nstatic void __atl1c_vlan_mode(netdev_features_t features, u32 *mac_ctrl_data)\r\n{\r\nif (features & NETIF_F_HW_VLAN_CTAG_RX) {\r\n*mac_ctrl_data |= MAC_CTRL_RMV_VLAN;\r\n} else {\r\n*mac_ctrl_data &= ~MAC_CTRL_RMV_VLAN;\r\n}\r\n}\r\nstatic void atl1c_vlan_mode(struct net_device *netdev,\r\nnetdev_features_t features)\r\n{\r\nstruct atl1c_adapter *adapter = netdev_priv(netdev);\r\nstruct pci_dev *pdev = adapter->pdev;\r\nu32 mac_ctrl_data = 0;\r\nif (netif_msg_pktdata(adapter))\r\ndev_dbg(&pdev->dev, "atl1c_vlan_mode\n");\r\natl1c_irq_disable(adapter);\r\nAT_READ_REG(&adapter->hw, REG_MAC_CTRL, &mac_ctrl_data);\r\n__atl1c_vlan_mode(features, &mac_ctrl_data);\r\nAT_WRITE_REG(&adapter->hw, REG_MAC_CTRL, mac_ctrl_data);\r\natl1c_irq_enable(adapter);\r\n}\r\nstatic void atl1c_restore_vlan(struct atl1c_adapter *adapter)\r\n{\r\nstruct pci_dev *pdev = adapter->pdev;\r\nif (netif_msg_pktdata(adapter))\r\ndev_dbg(&pdev->dev, "atl1c_restore_vlan\n");\r\natl1c_vlan_mode(adapter->netdev, adapter->netdev->features);\r\n}\r\nstatic int atl1c_set_mac_addr(struct net_device *netdev, void *p)\r\n{\r\nstruct atl1c_adapter *adapter = netdev_priv(netdev);\r\nstruct sockaddr *addr = p;\r\nif (!is_valid_ether_addr(addr->sa_data))\r\nreturn -EADDRNOTAVAIL;\r\nif (netif_running(netdev))\r\nreturn -EBUSY;\r\nmemcpy(netdev->dev_addr, addr->sa_data, netdev->addr_len);\r\nmemcpy(adapter->hw.mac_addr, addr->sa_data, netdev->addr_len);\r\natl1c_hw_set_mac_addr(&adapter->hw, adapter->hw.mac_addr);\r\nreturn 0;\r\n}\r\nstatic void atl1c_set_rxbufsize(struct atl1c_adapter *adapter,\r\nstruct net_device *dev)\r\n{\r\nunsigned int head_size;\r\nint mtu = dev->mtu;\r\nadapter->rx_buffer_len = mtu > AT_RX_BUF_SIZE ?\r\nroundup(mtu + ETH_HLEN + ETH_FCS_LEN + VLAN_HLEN, 8) : AT_RX_BUF_SIZE;\r\nhead_size = SKB_DATA_ALIGN(adapter->rx_buffer_len + NET_SKB_PAD) +\r\nSKB_DATA_ALIGN(sizeof(struct skb_shared_info));\r\nadapter->rx_frag_size = roundup_pow_of_two(head_size);\r\n}\r\nstatic netdev_features_t atl1c_fix_features(struct net_device *netdev,\r\nnetdev_features_t features)\r\n{\r\nif (features & NETIF_F_HW_VLAN_CTAG_RX)\r\nfeatures |= NETIF_F_HW_VLAN_CTAG_TX;\r\nelse\r\nfeatures &= ~NETIF_F_HW_VLAN_CTAG_TX;\r\nif (netdev->mtu > MAX_TSO_FRAME_SIZE)\r\nfeatures &= ~(NETIF_F_TSO | NETIF_F_TSO6);\r\nreturn features;\r\n}\r\nstatic int atl1c_set_features(struct net_device *netdev,\r\nnetdev_features_t features)\r\n{\r\nnetdev_features_t changed = netdev->features ^ features;\r\nif (changed & NETIF_F_HW_VLAN_CTAG_RX)\r\natl1c_vlan_mode(netdev, features);\r\nreturn 0;\r\n}\r\nstatic int atl1c_change_mtu(struct net_device *netdev, int new_mtu)\r\n{\r\nstruct atl1c_adapter *adapter = netdev_priv(netdev);\r\nstruct atl1c_hw *hw = &adapter->hw;\r\nint old_mtu = netdev->mtu;\r\nint max_frame = new_mtu + ETH_HLEN + ETH_FCS_LEN + VLAN_HLEN;\r\nif (((hw->nic_type == athr_l2c ||\r\nhw->nic_type == athr_l2c_b ||\r\nhw->nic_type == athr_l2c_b2) && new_mtu > ETH_DATA_LEN) ||\r\nmax_frame < ETH_ZLEN + ETH_FCS_LEN ||\r\nmax_frame > MAX_JUMBO_FRAME_SIZE) {\r\nif (netif_msg_link(adapter))\r\ndev_warn(&adapter->pdev->dev, "invalid MTU setting\n");\r\nreturn -EINVAL;\r\n}\r\nif (old_mtu != new_mtu && netif_running(netdev)) {\r\nwhile (test_and_set_bit(__AT_RESETTING, &adapter->flags))\r\nmsleep(1);\r\nnetdev->mtu = new_mtu;\r\nadapter->hw.max_frame_size = new_mtu;\r\natl1c_set_rxbufsize(adapter, netdev);\r\natl1c_down(adapter);\r\nnetdev_update_features(netdev);\r\natl1c_up(adapter);\r\nclear_bit(__AT_RESETTING, &adapter->flags);\r\n}\r\nreturn 0;\r\n}\r\nstatic int atl1c_mdio_read(struct net_device *netdev, int phy_id, int reg_num)\r\n{\r\nstruct atl1c_adapter *adapter = netdev_priv(netdev);\r\nu16 result;\r\natl1c_read_phy_reg(&adapter->hw, reg_num, &result);\r\nreturn result;\r\n}\r\nstatic void atl1c_mdio_write(struct net_device *netdev, int phy_id,\r\nint reg_num, int val)\r\n{\r\nstruct atl1c_adapter *adapter = netdev_priv(netdev);\r\natl1c_write_phy_reg(&adapter->hw, reg_num, val);\r\n}\r\nstatic int atl1c_mii_ioctl(struct net_device *netdev,\r\nstruct ifreq *ifr, int cmd)\r\n{\r\nstruct atl1c_adapter *adapter = netdev_priv(netdev);\r\nstruct pci_dev *pdev = adapter->pdev;\r\nstruct mii_ioctl_data *data = if_mii(ifr);\r\nunsigned long flags;\r\nint retval = 0;\r\nif (!netif_running(netdev))\r\nreturn -EINVAL;\r\nspin_lock_irqsave(&adapter->mdio_lock, flags);\r\nswitch (cmd) {\r\ncase SIOCGMIIPHY:\r\ndata->phy_id = 0;\r\nbreak;\r\ncase SIOCGMIIREG:\r\nif (atl1c_read_phy_reg(&adapter->hw, data->reg_num & 0x1F,\r\n&data->val_out)) {\r\nretval = -EIO;\r\ngoto out;\r\n}\r\nbreak;\r\ncase SIOCSMIIREG:\r\nif (data->reg_num & ~(0x1F)) {\r\nretval = -EFAULT;\r\ngoto out;\r\n}\r\ndev_dbg(&pdev->dev, "<atl1c_mii_ioctl> write %x %x",\r\ndata->reg_num, data->val_in);\r\nif (atl1c_write_phy_reg(&adapter->hw,\r\ndata->reg_num, data->val_in)) {\r\nretval = -EIO;\r\ngoto out;\r\n}\r\nbreak;\r\ndefault:\r\nretval = -EOPNOTSUPP;\r\nbreak;\r\n}\r\nout:\r\nspin_unlock_irqrestore(&adapter->mdio_lock, flags);\r\nreturn retval;\r\n}\r\nstatic int atl1c_ioctl(struct net_device *netdev, struct ifreq *ifr, int cmd)\r\n{\r\nswitch (cmd) {\r\ncase SIOCGMIIPHY:\r\ncase SIOCGMIIREG:\r\ncase SIOCSMIIREG:\r\nreturn atl1c_mii_ioctl(netdev, ifr, cmd);\r\ndefault:\r\nreturn -EOPNOTSUPP;\r\n}\r\n}\r\nstatic int atl1c_alloc_queues(struct atl1c_adapter *adapter)\r\n{\r\nreturn 0;\r\n}\r\nstatic void atl1c_set_mac_type(struct atl1c_hw *hw)\r\n{\r\nswitch (hw->device_id) {\r\ncase PCI_DEVICE_ID_ATTANSIC_L2C:\r\nhw->nic_type = athr_l2c;\r\nbreak;\r\ncase PCI_DEVICE_ID_ATTANSIC_L1C:\r\nhw->nic_type = athr_l1c;\r\nbreak;\r\ncase PCI_DEVICE_ID_ATHEROS_L2C_B:\r\nhw->nic_type = athr_l2c_b;\r\nbreak;\r\ncase PCI_DEVICE_ID_ATHEROS_L2C_B2:\r\nhw->nic_type = athr_l2c_b2;\r\nbreak;\r\ncase PCI_DEVICE_ID_ATHEROS_L1D:\r\nhw->nic_type = athr_l1d;\r\nbreak;\r\ncase PCI_DEVICE_ID_ATHEROS_L1D_2_0:\r\nhw->nic_type = athr_l1d_2;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nstatic int atl1c_setup_mac_funcs(struct atl1c_hw *hw)\r\n{\r\nu32 link_ctrl_data;\r\natl1c_set_mac_type(hw);\r\nAT_READ_REG(hw, REG_LINK_CTRL, &link_ctrl_data);\r\nhw->ctrl_flags = ATL1C_INTR_MODRT_ENABLE |\r\nATL1C_TXQ_MODE_ENHANCE;\r\nhw->ctrl_flags |= ATL1C_ASPM_L0S_SUPPORT |\r\nATL1C_ASPM_L1_SUPPORT;\r\nhw->ctrl_flags |= ATL1C_ASPM_CTRL_MON;\r\nif (hw->nic_type == athr_l1c ||\r\nhw->nic_type == athr_l1d ||\r\nhw->nic_type == athr_l1d_2)\r\nhw->link_cap_flags |= ATL1C_LINK_CAP_1000M;\r\nreturn 0;\r\n}\r\nstatic void atl1c_patch_assign(struct atl1c_hw *hw)\r\n{\r\nstruct pci_dev *pdev = hw->adapter->pdev;\r\nu32 misc_ctrl;\r\nint i = 0;\r\nhw->msi_lnkpatch = false;\r\nwhile (plats[i].pci_did != 0) {\r\nif (plats[i].pci_did == hw->device_id &&\r\nplats[i].pci_revid == hw->revision_id &&\r\nplats[i].subsystem_vid == hw->subsystem_vendor_id &&\r\nplats[i].subsystem_did == hw->subsystem_id) {\r\nif (plats[i].patch_flag & ATL1C_LINK_PATCH)\r\nhw->msi_lnkpatch = true;\r\n}\r\ni++;\r\n}\r\nif (hw->device_id == PCI_DEVICE_ID_ATHEROS_L2C_B2 &&\r\nhw->revision_id == L2CB_V21) {\r\npci_write_config_dword(pdev, REG_PCIE_IND_ACC_ADDR,\r\nREG_PCIE_DEV_MISC_CTRL);\r\npci_read_config_dword(pdev, REG_PCIE_IND_ACC_DATA, &misc_ctrl);\r\nmisc_ctrl &= ~0x100;\r\npci_write_config_dword(pdev, REG_PCIE_IND_ACC_ADDR,\r\nREG_PCIE_DEV_MISC_CTRL);\r\npci_write_config_dword(pdev, REG_PCIE_IND_ACC_DATA, misc_ctrl);\r\n}\r\n}\r\nstatic int atl1c_sw_init(struct atl1c_adapter *adapter)\r\n{\r\nstruct atl1c_hw *hw = &adapter->hw;\r\nstruct pci_dev *pdev = adapter->pdev;\r\nu32 revision;\r\nadapter->wol = 0;\r\ndevice_set_wakeup_enable(&pdev->dev, false);\r\nadapter->link_speed = SPEED_0;\r\nadapter->link_duplex = FULL_DUPLEX;\r\nadapter->tpd_ring[0].count = 1024;\r\nadapter->rfd_ring.count = 512;\r\nhw->vendor_id = pdev->vendor;\r\nhw->device_id = pdev->device;\r\nhw->subsystem_vendor_id = pdev->subsystem_vendor;\r\nhw->subsystem_id = pdev->subsystem_device;\r\npci_read_config_dword(pdev, PCI_CLASS_REVISION, &revision);\r\nhw->revision_id = revision & 0xFF;\r\nhw->hibernate = true;\r\nhw->media_type = MEDIA_TYPE_AUTO_SENSOR;\r\nif (atl1c_setup_mac_funcs(hw) != 0) {\r\ndev_err(&pdev->dev, "set mac function pointers failed\n");\r\nreturn -1;\r\n}\r\natl1c_patch_assign(hw);\r\nhw->intr_mask = IMR_NORMAL_MASK;\r\nhw->phy_configured = false;\r\nhw->preamble_len = 7;\r\nhw->max_frame_size = adapter->netdev->mtu;\r\nhw->autoneg_advertised = ADVERTISED_Autoneg;\r\nhw->indirect_tab = 0xE4E4E4E4;\r\nhw->base_cpu = 0;\r\nhw->ict = 50000;\r\nhw->smb_timer = 200000;\r\nhw->rx_imt = 200;\r\nhw->tx_imt = 1000;\r\nhw->tpd_burst = 5;\r\nhw->rfd_burst = 8;\r\nhw->dma_order = atl1c_dma_ord_out;\r\nhw->dmar_block = atl1c_dma_req_1024;\r\nif (atl1c_alloc_queues(adapter)) {\r\ndev_err(&pdev->dev, "Unable to allocate memory for queues\n");\r\nreturn -ENOMEM;\r\n}\r\natl1c_set_rxbufsize(adapter, adapter->netdev);\r\natomic_set(&adapter->irq_sem, 1);\r\nspin_lock_init(&adapter->mdio_lock);\r\nspin_lock_init(&adapter->tx_lock);\r\nset_bit(__AT_DOWN, &adapter->flags);\r\nreturn 0;\r\n}\r\nstatic inline void atl1c_clean_buffer(struct pci_dev *pdev,\r\nstruct atl1c_buffer *buffer_info)\r\n{\r\nu16 pci_driection;\r\nif (buffer_info->flags & ATL1C_BUFFER_FREE)\r\nreturn;\r\nif (buffer_info->dma) {\r\nif (buffer_info->flags & ATL1C_PCIMAP_FROMDEVICE)\r\npci_driection = PCI_DMA_FROMDEVICE;\r\nelse\r\npci_driection = PCI_DMA_TODEVICE;\r\nif (buffer_info->flags & ATL1C_PCIMAP_SINGLE)\r\npci_unmap_single(pdev, buffer_info->dma,\r\nbuffer_info->length, pci_driection);\r\nelse if (buffer_info->flags & ATL1C_PCIMAP_PAGE)\r\npci_unmap_page(pdev, buffer_info->dma,\r\nbuffer_info->length, pci_driection);\r\n}\r\nif (buffer_info->skb)\r\ndev_consume_skb_any(buffer_info->skb);\r\nbuffer_info->dma = 0;\r\nbuffer_info->skb = NULL;\r\nATL1C_SET_BUFFER_STATE(buffer_info, ATL1C_BUFFER_FREE);\r\n}\r\nstatic void atl1c_clean_tx_ring(struct atl1c_adapter *adapter,\r\nenum atl1c_trans_queue type)\r\n{\r\nstruct atl1c_tpd_ring *tpd_ring = &adapter->tpd_ring[type];\r\nstruct atl1c_buffer *buffer_info;\r\nstruct pci_dev *pdev = adapter->pdev;\r\nu16 index, ring_count;\r\nring_count = tpd_ring->count;\r\nfor (index = 0; index < ring_count; index++) {\r\nbuffer_info = &tpd_ring->buffer_info[index];\r\natl1c_clean_buffer(pdev, buffer_info);\r\n}\r\nnetdev_reset_queue(adapter->netdev);\r\nmemset(tpd_ring->desc, 0, sizeof(struct atl1c_tpd_desc) *\r\nring_count);\r\natomic_set(&tpd_ring->next_to_clean, 0);\r\ntpd_ring->next_to_use = 0;\r\n}\r\nstatic void atl1c_clean_rx_ring(struct atl1c_adapter *adapter)\r\n{\r\nstruct atl1c_rfd_ring *rfd_ring = &adapter->rfd_ring;\r\nstruct atl1c_rrd_ring *rrd_ring = &adapter->rrd_ring;\r\nstruct atl1c_buffer *buffer_info;\r\nstruct pci_dev *pdev = adapter->pdev;\r\nint j;\r\nfor (j = 0; j < rfd_ring->count; j++) {\r\nbuffer_info = &rfd_ring->buffer_info[j];\r\natl1c_clean_buffer(pdev, buffer_info);\r\n}\r\nmemset(rfd_ring->desc, 0, rfd_ring->size);\r\nrfd_ring->next_to_clean = 0;\r\nrfd_ring->next_to_use = 0;\r\nrrd_ring->next_to_use = 0;\r\nrrd_ring->next_to_clean = 0;\r\n}\r\nstatic void atl1c_init_ring_ptrs(struct atl1c_adapter *adapter)\r\n{\r\nstruct atl1c_tpd_ring *tpd_ring = adapter->tpd_ring;\r\nstruct atl1c_rfd_ring *rfd_ring = &adapter->rfd_ring;\r\nstruct atl1c_rrd_ring *rrd_ring = &adapter->rrd_ring;\r\nstruct atl1c_buffer *buffer_info;\r\nint i, j;\r\nfor (i = 0; i < AT_MAX_TRANSMIT_QUEUE; i++) {\r\ntpd_ring[i].next_to_use = 0;\r\natomic_set(&tpd_ring[i].next_to_clean, 0);\r\nbuffer_info = tpd_ring[i].buffer_info;\r\nfor (j = 0; j < tpd_ring->count; j++)\r\nATL1C_SET_BUFFER_STATE(&buffer_info[i],\r\nATL1C_BUFFER_FREE);\r\n}\r\nrfd_ring->next_to_use = 0;\r\nrfd_ring->next_to_clean = 0;\r\nrrd_ring->next_to_use = 0;\r\nrrd_ring->next_to_clean = 0;\r\nfor (j = 0; j < rfd_ring->count; j++) {\r\nbuffer_info = &rfd_ring->buffer_info[j];\r\nATL1C_SET_BUFFER_STATE(buffer_info, ATL1C_BUFFER_FREE);\r\n}\r\n}\r\nstatic void atl1c_free_ring_resources(struct atl1c_adapter *adapter)\r\n{\r\nstruct pci_dev *pdev = adapter->pdev;\r\npci_free_consistent(pdev, adapter->ring_header.size,\r\nadapter->ring_header.desc,\r\nadapter->ring_header.dma);\r\nadapter->ring_header.desc = NULL;\r\nif (adapter->tpd_ring[0].buffer_info) {\r\nkfree(adapter->tpd_ring[0].buffer_info);\r\nadapter->tpd_ring[0].buffer_info = NULL;\r\n}\r\nif (adapter->rx_page) {\r\nput_page(adapter->rx_page);\r\nadapter->rx_page = NULL;\r\n}\r\n}\r\nstatic int atl1c_setup_ring_resources(struct atl1c_adapter *adapter)\r\n{\r\nstruct pci_dev *pdev = adapter->pdev;\r\nstruct atl1c_tpd_ring *tpd_ring = adapter->tpd_ring;\r\nstruct atl1c_rfd_ring *rfd_ring = &adapter->rfd_ring;\r\nstruct atl1c_rrd_ring *rrd_ring = &adapter->rrd_ring;\r\nstruct atl1c_ring_header *ring_header = &adapter->ring_header;\r\nint size;\r\nint i;\r\nint count = 0;\r\nint rx_desc_count = 0;\r\nu32 offset = 0;\r\nrrd_ring->count = rfd_ring->count;\r\nfor (i = 1; i < AT_MAX_TRANSMIT_QUEUE; i++)\r\ntpd_ring[i].count = tpd_ring[0].count;\r\nsize = sizeof(struct atl1c_buffer) * (tpd_ring->count * 2 +\r\nrfd_ring->count);\r\ntpd_ring->buffer_info = kzalloc(size, GFP_KERNEL);\r\nif (unlikely(!tpd_ring->buffer_info))\r\ngoto err_nomem;\r\nfor (i = 0; i < AT_MAX_TRANSMIT_QUEUE; i++) {\r\ntpd_ring[i].buffer_info =\r\n(tpd_ring->buffer_info + count);\r\ncount += tpd_ring[i].count;\r\n}\r\nrfd_ring->buffer_info =\r\n(tpd_ring->buffer_info + count);\r\ncount += rfd_ring->count;\r\nrx_desc_count += rfd_ring->count;\r\nring_header->size = size =\r\nsizeof(struct atl1c_tpd_desc) * tpd_ring->count * 2 +\r\nsizeof(struct atl1c_rx_free_desc) * rx_desc_count +\r\nsizeof(struct atl1c_recv_ret_status) * rx_desc_count +\r\n8 * 4;\r\nring_header->desc = dma_zalloc_coherent(&pdev->dev, ring_header->size,\r\n&ring_header->dma, GFP_KERNEL);\r\nif (unlikely(!ring_header->desc)) {\r\ndev_err(&pdev->dev, "could not get memory for DMA buffer\n");\r\ngoto err_nomem;\r\n}\r\ntpd_ring[0].dma = roundup(ring_header->dma, 8);\r\noffset = tpd_ring[0].dma - ring_header->dma;\r\nfor (i = 0; i < AT_MAX_TRANSMIT_QUEUE; i++) {\r\ntpd_ring[i].dma = ring_header->dma + offset;\r\ntpd_ring[i].desc = (u8 *) ring_header->desc + offset;\r\ntpd_ring[i].size =\r\nsizeof(struct atl1c_tpd_desc) * tpd_ring[i].count;\r\noffset += roundup(tpd_ring[i].size, 8);\r\n}\r\nrfd_ring->dma = ring_header->dma + offset;\r\nrfd_ring->desc = (u8 *) ring_header->desc + offset;\r\nrfd_ring->size = sizeof(struct atl1c_rx_free_desc) * rfd_ring->count;\r\noffset += roundup(rfd_ring->size, 8);\r\nrrd_ring->dma = ring_header->dma + offset;\r\nrrd_ring->desc = (u8 *) ring_header->desc + offset;\r\nrrd_ring->size = sizeof(struct atl1c_recv_ret_status) *\r\nrrd_ring->count;\r\noffset += roundup(rrd_ring->size, 8);\r\nreturn 0;\r\nerr_nomem:\r\nkfree(tpd_ring->buffer_info);\r\nreturn -ENOMEM;\r\n}\r\nstatic void atl1c_configure_des_ring(struct atl1c_adapter *adapter)\r\n{\r\nstruct atl1c_hw *hw = &adapter->hw;\r\nstruct atl1c_rfd_ring *rfd_ring = &adapter->rfd_ring;\r\nstruct atl1c_rrd_ring *rrd_ring = &adapter->rrd_ring;\r\nstruct atl1c_tpd_ring *tpd_ring = (struct atl1c_tpd_ring *)\r\nadapter->tpd_ring;\r\nAT_WRITE_REG(hw, REG_TX_BASE_ADDR_HI,\r\n(u32)((tpd_ring[atl1c_trans_normal].dma &\r\nAT_DMA_HI_ADDR_MASK) >> 32));\r\nAT_WRITE_REG(hw, REG_TPD_PRI0_ADDR_LO,\r\n(u32)(tpd_ring[atl1c_trans_normal].dma &\r\nAT_DMA_LO_ADDR_MASK));\r\nAT_WRITE_REG(hw, REG_TPD_PRI1_ADDR_LO,\r\n(u32)(tpd_ring[atl1c_trans_high].dma &\r\nAT_DMA_LO_ADDR_MASK));\r\nAT_WRITE_REG(hw, REG_TPD_RING_SIZE,\r\n(u32)(tpd_ring[0].count & TPD_RING_SIZE_MASK));\r\nAT_WRITE_REG(hw, REG_RX_BASE_ADDR_HI,\r\n(u32)((rfd_ring->dma & AT_DMA_HI_ADDR_MASK) >> 32));\r\nAT_WRITE_REG(hw, REG_RFD0_HEAD_ADDR_LO,\r\n(u32)(rfd_ring->dma & AT_DMA_LO_ADDR_MASK));\r\nAT_WRITE_REG(hw, REG_RFD_RING_SIZE,\r\nrfd_ring->count & RFD_RING_SIZE_MASK);\r\nAT_WRITE_REG(hw, REG_RX_BUF_SIZE,\r\nadapter->rx_buffer_len & RX_BUF_SIZE_MASK);\r\nAT_WRITE_REG(hw, REG_RRD0_HEAD_ADDR_LO,\r\n(u32)(rrd_ring->dma & AT_DMA_LO_ADDR_MASK));\r\nAT_WRITE_REG(hw, REG_RRD_RING_SIZE,\r\n(rrd_ring->count & RRD_RING_SIZE_MASK));\r\nif (hw->nic_type == athr_l2c_b) {\r\nAT_WRITE_REG(hw, REG_SRAM_RXF_LEN, 0x02a0L);\r\nAT_WRITE_REG(hw, REG_SRAM_TXF_LEN, 0x0100L);\r\nAT_WRITE_REG(hw, REG_SRAM_RXF_ADDR, 0x029f0000L);\r\nAT_WRITE_REG(hw, REG_SRAM_RFD0_INFO, 0x02bf02a0L);\r\nAT_WRITE_REG(hw, REG_SRAM_TXF_ADDR, 0x03bf02c0L);\r\nAT_WRITE_REG(hw, REG_SRAM_TRD_ADDR, 0x03df03c0L);\r\nAT_WRITE_REG(hw, REG_TXF_WATER_MARK, 0);\r\nAT_WRITE_REG(hw, REG_RXD_DMA_CTRL, 0);\r\n}\r\nAT_WRITE_REG(hw, REG_LOAD_PTR, 1);\r\n}\r\nstatic void atl1c_configure_tx(struct atl1c_adapter *adapter)\r\n{\r\nstruct atl1c_hw *hw = &adapter->hw;\r\nint max_pay_load;\r\nu16 tx_offload_thresh;\r\nu32 txq_ctrl_data;\r\ntx_offload_thresh = MAX_TSO_FRAME_SIZE;\r\nAT_WRITE_REG(hw, REG_TX_TSO_OFFLOAD_THRESH,\r\n(tx_offload_thresh >> 3) & TX_TSO_OFFLOAD_THRESH_MASK);\r\nmax_pay_load = pcie_get_readrq(adapter->pdev) >> 8;\r\nhw->dmar_block = min_t(u32, max_pay_load, hw->dmar_block);\r\nif (hw->dmar_block < DEVICE_CTRL_MAXRRS_MIN) {\r\npcie_set_readrq(adapter->pdev, 128 << DEVICE_CTRL_MAXRRS_MIN);\r\nhw->dmar_block = DEVICE_CTRL_MAXRRS_MIN;\r\n}\r\ntxq_ctrl_data =\r\nhw->nic_type == athr_l2c_b || hw->nic_type == athr_l2c_b2 ?\r\nL2CB_TXQ_CFGV : L1C_TXQ_CFGV;\r\nAT_WRITE_REG(hw, REG_TXQ_CTRL, txq_ctrl_data);\r\n}\r\nstatic void atl1c_configure_rx(struct atl1c_adapter *adapter)\r\n{\r\nstruct atl1c_hw *hw = &adapter->hw;\r\nu32 rxq_ctrl_data;\r\nrxq_ctrl_data = (hw->rfd_burst & RXQ_RFD_BURST_NUM_MASK) <<\r\nRXQ_RFD_BURST_NUM_SHIFT;\r\nif (hw->ctrl_flags & ATL1C_RX_IPV6_CHKSUM)\r\nrxq_ctrl_data |= IPV6_CHKSUM_CTRL_EN;\r\nif (hw->nic_type != athr_l1d_2 && (hw->device_id & 1) != 0)\r\nrxq_ctrl_data = FIELD_SETX(rxq_ctrl_data, ASPM_THRUPUT_LIMIT,\r\nASPM_THRUPUT_LIMIT_100M);\r\nAT_WRITE_REG(hw, REG_RXQ_CTRL, rxq_ctrl_data);\r\n}\r\nstatic void atl1c_configure_dma(struct atl1c_adapter *adapter)\r\n{\r\nstruct atl1c_hw *hw = &adapter->hw;\r\nu32 dma_ctrl_data;\r\ndma_ctrl_data = FIELDX(DMA_CTRL_RORDER_MODE, DMA_CTRL_RORDER_MODE_OUT) |\r\nDMA_CTRL_RREQ_PRI_DATA |\r\nFIELDX(DMA_CTRL_RREQ_BLEN, hw->dmar_block) |\r\nFIELDX(DMA_CTRL_WDLY_CNT, DMA_CTRL_WDLY_CNT_DEF) |\r\nFIELDX(DMA_CTRL_RDLY_CNT, DMA_CTRL_RDLY_CNT_DEF);\r\nAT_WRITE_REG(hw, REG_DMA_CTRL, dma_ctrl_data);\r\n}\r\nstatic int atl1c_stop_mac(struct atl1c_hw *hw)\r\n{\r\nu32 data;\r\nAT_READ_REG(hw, REG_RXQ_CTRL, &data);\r\ndata &= ~RXQ_CTRL_EN;\r\nAT_WRITE_REG(hw, REG_RXQ_CTRL, data);\r\nAT_READ_REG(hw, REG_TXQ_CTRL, &data);\r\ndata &= ~TXQ_CTRL_EN;\r\nAT_WRITE_REG(hw, REG_TXQ_CTRL, data);\r\natl1c_wait_until_idle(hw, IDLE_STATUS_RXQ_BUSY | IDLE_STATUS_TXQ_BUSY);\r\nAT_READ_REG(hw, REG_MAC_CTRL, &data);\r\ndata &= ~(MAC_CTRL_TX_EN | MAC_CTRL_RX_EN);\r\nAT_WRITE_REG(hw, REG_MAC_CTRL, data);\r\nreturn (int)atl1c_wait_until_idle(hw,\r\nIDLE_STATUS_TXMAC_BUSY | IDLE_STATUS_RXMAC_BUSY);\r\n}\r\nstatic void atl1c_start_mac(struct atl1c_adapter *adapter)\r\n{\r\nstruct atl1c_hw *hw = &adapter->hw;\r\nu32 mac, txq, rxq;\r\nhw->mac_duplex = adapter->link_duplex == FULL_DUPLEX ? true : false;\r\nhw->mac_speed = adapter->link_speed == SPEED_1000 ?\r\natl1c_mac_speed_1000 : atl1c_mac_speed_10_100;\r\nAT_READ_REG(hw, REG_TXQ_CTRL, &txq);\r\nAT_READ_REG(hw, REG_RXQ_CTRL, &rxq);\r\nAT_READ_REG(hw, REG_MAC_CTRL, &mac);\r\ntxq |= TXQ_CTRL_EN;\r\nrxq |= RXQ_CTRL_EN;\r\nmac |= MAC_CTRL_TX_EN | MAC_CTRL_TX_FLOW |\r\nMAC_CTRL_RX_EN | MAC_CTRL_RX_FLOW |\r\nMAC_CTRL_ADD_CRC | MAC_CTRL_PAD |\r\nMAC_CTRL_BC_EN | MAC_CTRL_SINGLE_PAUSE_EN |\r\nMAC_CTRL_HASH_ALG_CRC32;\r\nif (hw->mac_duplex)\r\nmac |= MAC_CTRL_DUPLX;\r\nelse\r\nmac &= ~MAC_CTRL_DUPLX;\r\nmac = FIELD_SETX(mac, MAC_CTRL_SPEED, hw->mac_speed);\r\nmac = FIELD_SETX(mac, MAC_CTRL_PRMLEN, hw->preamble_len);\r\nAT_WRITE_REG(hw, REG_TXQ_CTRL, txq);\r\nAT_WRITE_REG(hw, REG_RXQ_CTRL, rxq);\r\nAT_WRITE_REG(hw, REG_MAC_CTRL, mac);\r\n}\r\nstatic int atl1c_reset_mac(struct atl1c_hw *hw)\r\n{\r\nstruct atl1c_adapter *adapter = hw->adapter;\r\nstruct pci_dev *pdev = adapter->pdev;\r\nu32 ctrl_data = 0;\r\natl1c_stop_mac(hw);\r\nAT_READ_REG(hw, REG_MASTER_CTRL, &ctrl_data);\r\nctrl_data |= MASTER_CTRL_OOB_DIS;\r\nAT_WRITE_REG(hw, REG_MASTER_CTRL, ctrl_data | MASTER_CTRL_SOFT_RST);\r\nAT_WRITE_FLUSH(hw);\r\nmsleep(10);\r\nif (atl1c_wait_until_idle(hw, IDLE_STATUS_MASK)) {\r\ndev_err(&pdev->dev,\r\n"MAC state machine can't be idle since"\r\n" disabled for 10ms second\n");\r\nreturn -1;\r\n}\r\nAT_WRITE_REG(hw, REG_MASTER_CTRL, ctrl_data);\r\nAT_READ_REG(hw, REG_MAC_CTRL, &ctrl_data);\r\nAT_WRITE_REG(hw, REG_MAC_CTRL, ctrl_data | MAC_CTRL_SPEED_MODE_SW);\r\nAT_READ_REG(hw, REG_SERDES, &ctrl_data);\r\nswitch (hw->nic_type) {\r\ncase athr_l2c_b:\r\nctrl_data &= ~(SERDES_PHY_CLK_SLOWDOWN |\r\nSERDES_MAC_CLK_SLOWDOWN);\r\nAT_WRITE_REG(hw, REG_SERDES, ctrl_data);\r\nbreak;\r\ncase athr_l2c_b2:\r\ncase athr_l1d_2:\r\nctrl_data |= SERDES_PHY_CLK_SLOWDOWN | SERDES_MAC_CLK_SLOWDOWN;\r\nAT_WRITE_REG(hw, REG_SERDES, ctrl_data);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic void atl1c_disable_l0s_l1(struct atl1c_hw *hw)\r\n{\r\nu16 ctrl_flags = hw->ctrl_flags;\r\nhw->ctrl_flags &= ~(ATL1C_ASPM_L0S_SUPPORT | ATL1C_ASPM_L1_SUPPORT);\r\natl1c_set_aspm(hw, SPEED_0);\r\nhw->ctrl_flags = ctrl_flags;\r\n}\r\nstatic void atl1c_set_aspm(struct atl1c_hw *hw, u16 link_speed)\r\n{\r\nu32 pm_ctrl_data;\r\nu32 link_l1_timer;\r\nAT_READ_REG(hw, REG_PM_CTRL, &pm_ctrl_data);\r\npm_ctrl_data &= ~(PM_CTRL_ASPM_L1_EN |\r\nPM_CTRL_ASPM_L0S_EN |\r\nPM_CTRL_MAC_ASPM_CHK);\r\nif (hw->nic_type == athr_l2c_b2 || hw->nic_type == athr_l1d_2) {\r\npm_ctrl_data &= ~PMCTRL_TXL1_AFTER_L0S;\r\nlink_l1_timer =\r\nlink_speed == SPEED_1000 || link_speed == SPEED_100 ?\r\nL1D_PMCTRL_L1_ENTRY_TM_16US : 1;\r\npm_ctrl_data = FIELD_SETX(pm_ctrl_data,\r\nL1D_PMCTRL_L1_ENTRY_TM, link_l1_timer);\r\n} else {\r\nlink_l1_timer = hw->nic_type == athr_l2c_b ?\r\nL2CB1_PM_CTRL_L1_ENTRY_TM : L1C_PM_CTRL_L1_ENTRY_TM;\r\nif (link_speed != SPEED_1000 && link_speed != SPEED_100)\r\nlink_l1_timer = 1;\r\npm_ctrl_data = FIELD_SETX(pm_ctrl_data,\r\nPM_CTRL_L1_ENTRY_TIMER, link_l1_timer);\r\n}\r\nif ((hw->ctrl_flags & ATL1C_ASPM_L0S_SUPPORT) && link_speed != SPEED_0)\r\npm_ctrl_data |= PM_CTRL_ASPM_L0S_EN | PM_CTRL_MAC_ASPM_CHK;\r\nif (hw->ctrl_flags & ATL1C_ASPM_L1_SUPPORT)\r\npm_ctrl_data |= PM_CTRL_ASPM_L1_EN | PM_CTRL_MAC_ASPM_CHK;\r\nif (hw->nic_type == athr_l2c_b || hw->nic_type == athr_l1d ||\r\nhw->nic_type == athr_l2c_b2 || hw->nic_type == athr_l1d_2) {\r\npm_ctrl_data = FIELD_SETX(pm_ctrl_data,\r\nPM_CTRL_PM_REQ_TIMER, PM_CTRL_PM_REQ_TO_DEF);\r\npm_ctrl_data |= PM_CTRL_RCVR_WT_TIMER |\r\nPM_CTRL_SERDES_PD_EX_L1 |\r\nPM_CTRL_CLK_SWH_L1;\r\npm_ctrl_data &= ~(PM_CTRL_SERDES_L1_EN |\r\nPM_CTRL_SERDES_PLL_L1_EN |\r\nPM_CTRL_SERDES_BUFS_RX_L1_EN |\r\nPM_CTRL_SA_DLY_EN |\r\nPM_CTRL_HOTRST);\r\nif (link_speed == SPEED_0 || hw->nic_type == athr_l2c_b)\r\npm_ctrl_data &= ~PM_CTRL_ASPM_L0S_EN;\r\n} else {\r\npm_ctrl_data =\r\nFIELD_SETX(pm_ctrl_data, PM_CTRL_L1_ENTRY_TIMER, 0);\r\nif (link_speed != SPEED_0) {\r\npm_ctrl_data |= PM_CTRL_SERDES_L1_EN |\r\nPM_CTRL_SERDES_PLL_L1_EN |\r\nPM_CTRL_SERDES_BUFS_RX_L1_EN;\r\npm_ctrl_data &= ~(PM_CTRL_SERDES_PD_EX_L1 |\r\nPM_CTRL_CLK_SWH_L1 |\r\nPM_CTRL_ASPM_L0S_EN |\r\nPM_CTRL_ASPM_L1_EN);\r\n} else {\r\npm_ctrl_data |= PM_CTRL_CLK_SWH_L1;\r\npm_ctrl_data &= ~(PM_CTRL_SERDES_L1_EN |\r\nPM_CTRL_SERDES_PLL_L1_EN |\r\nPM_CTRL_SERDES_BUFS_RX_L1_EN |\r\nPM_CTRL_ASPM_L0S_EN);\r\n}\r\n}\r\nAT_WRITE_REG(hw, REG_PM_CTRL, pm_ctrl_data);\r\nreturn;\r\n}\r\nstatic int atl1c_configure_mac(struct atl1c_adapter *adapter)\r\n{\r\nstruct atl1c_hw *hw = &adapter->hw;\r\nu32 master_ctrl_data = 0;\r\nu32 intr_modrt_data;\r\nu32 data;\r\nAT_READ_REG(hw, REG_MASTER_CTRL, &master_ctrl_data);\r\nmaster_ctrl_data &= ~(MASTER_CTRL_TX_ITIMER_EN |\r\nMASTER_CTRL_RX_ITIMER_EN |\r\nMASTER_CTRL_INT_RDCLR);\r\nAT_WRITE_REG(hw, REG_ISR, 0xFFFFFFFF);\r\nAT_WRITE_REG(hw, REG_WOL_CTRL, 0);\r\ndata = CLK_GATING_EN_ALL;\r\nif (hw->ctrl_flags & ATL1C_CLK_GATING_EN) {\r\nif (hw->nic_type == athr_l2c_b)\r\ndata &= ~CLK_GATING_RXMAC_EN;\r\n} else\r\ndata = 0;\r\nAT_WRITE_REG(hw, REG_CLK_GATING_CTRL, data);\r\nAT_WRITE_REG(hw, REG_INT_RETRIG_TIMER,\r\nhw->ict & INT_RETRIG_TIMER_MASK);\r\natl1c_configure_des_ring(adapter);\r\nif (hw->ctrl_flags & ATL1C_INTR_MODRT_ENABLE) {\r\nintr_modrt_data = (hw->tx_imt & IRQ_MODRT_TIMER_MASK) <<\r\nIRQ_MODRT_TX_TIMER_SHIFT;\r\nintr_modrt_data |= (hw->rx_imt & IRQ_MODRT_TIMER_MASK) <<\r\nIRQ_MODRT_RX_TIMER_SHIFT;\r\nAT_WRITE_REG(hw, REG_IRQ_MODRT_TIMER_INIT, intr_modrt_data);\r\nmaster_ctrl_data |=\r\nMASTER_CTRL_TX_ITIMER_EN | MASTER_CTRL_RX_ITIMER_EN;\r\n}\r\nif (hw->ctrl_flags & ATL1C_INTR_CLEAR_ON_READ)\r\nmaster_ctrl_data |= MASTER_CTRL_INT_RDCLR;\r\nmaster_ctrl_data |= MASTER_CTRL_SA_TIMER_EN;\r\nAT_WRITE_REG(hw, REG_MASTER_CTRL, master_ctrl_data);\r\nAT_WRITE_REG(hw, REG_SMB_STAT_TIMER,\r\nhw->smb_timer & SMB_STAT_TIMER_MASK);\r\nAT_WRITE_REG(hw, REG_MTU, hw->max_frame_size + ETH_HLEN +\r\nVLAN_HLEN + ETH_FCS_LEN);\r\natl1c_configure_tx(adapter);\r\natl1c_configure_rx(adapter);\r\natl1c_configure_dma(adapter);\r\nreturn 0;\r\n}\r\nstatic int atl1c_configure(struct atl1c_adapter *adapter)\r\n{\r\nstruct net_device *netdev = adapter->netdev;\r\nint num;\r\natl1c_init_ring_ptrs(adapter);\r\natl1c_set_multi(netdev);\r\natl1c_restore_vlan(adapter);\r\nnum = atl1c_alloc_rx_buffer(adapter);\r\nif (unlikely(num == 0))\r\nreturn -ENOMEM;\r\nif (atl1c_configure_mac(adapter))\r\nreturn -EIO;\r\nreturn 0;\r\n}\r\nstatic void atl1c_update_hw_stats(struct atl1c_adapter *adapter)\r\n{\r\nu16 hw_reg_addr = 0;\r\nunsigned long *stats_item = NULL;\r\nu32 data;\r\nhw_reg_addr = REG_MAC_RX_STATUS_BIN;\r\nstats_item = &adapter->hw_stats.rx_ok;\r\nwhile (hw_reg_addr <= REG_MAC_RX_STATUS_END) {\r\nAT_READ_REG(&adapter->hw, hw_reg_addr, &data);\r\n*stats_item += data;\r\nstats_item++;\r\nhw_reg_addr += 4;\r\n}\r\nhw_reg_addr = REG_MAC_TX_STATUS_BIN;\r\nstats_item = &adapter->hw_stats.tx_ok;\r\nwhile (hw_reg_addr <= REG_MAC_TX_STATUS_END) {\r\nAT_READ_REG(&adapter->hw, hw_reg_addr, &data);\r\n*stats_item += data;\r\nstats_item++;\r\nhw_reg_addr += 4;\r\n}\r\n}\r\nstatic struct net_device_stats *atl1c_get_stats(struct net_device *netdev)\r\n{\r\nstruct atl1c_adapter *adapter = netdev_priv(netdev);\r\nstruct atl1c_hw_stats *hw_stats = &adapter->hw_stats;\r\nstruct net_device_stats *net_stats = &netdev->stats;\r\natl1c_update_hw_stats(adapter);\r\nnet_stats->rx_bytes = hw_stats->rx_byte_cnt;\r\nnet_stats->tx_bytes = hw_stats->tx_byte_cnt;\r\nnet_stats->multicast = hw_stats->rx_mcast;\r\nnet_stats->collisions = hw_stats->tx_1_col +\r\nhw_stats->tx_2_col +\r\nhw_stats->tx_late_col +\r\nhw_stats->tx_abort_col;\r\nnet_stats->rx_errors = hw_stats->rx_frag +\r\nhw_stats->rx_fcs_err +\r\nhw_stats->rx_len_err +\r\nhw_stats->rx_sz_ov +\r\nhw_stats->rx_rrd_ov +\r\nhw_stats->rx_align_err +\r\nhw_stats->rx_rxf_ov;\r\nnet_stats->rx_fifo_errors = hw_stats->rx_rxf_ov;\r\nnet_stats->rx_length_errors = hw_stats->rx_len_err;\r\nnet_stats->rx_crc_errors = hw_stats->rx_fcs_err;\r\nnet_stats->rx_frame_errors = hw_stats->rx_align_err;\r\nnet_stats->rx_dropped = hw_stats->rx_rrd_ov;\r\nnet_stats->tx_errors = hw_stats->tx_late_col +\r\nhw_stats->tx_abort_col +\r\nhw_stats->tx_underrun +\r\nhw_stats->tx_trunc;\r\nnet_stats->tx_fifo_errors = hw_stats->tx_underrun;\r\nnet_stats->tx_aborted_errors = hw_stats->tx_abort_col;\r\nnet_stats->tx_window_errors = hw_stats->tx_late_col;\r\nnet_stats->rx_packets = hw_stats->rx_ok + net_stats->rx_errors;\r\nnet_stats->tx_packets = hw_stats->tx_ok + net_stats->tx_errors;\r\nreturn net_stats;\r\n}\r\nstatic inline void atl1c_clear_phy_int(struct atl1c_adapter *adapter)\r\n{\r\nu16 phy_data;\r\nspin_lock(&adapter->mdio_lock);\r\natl1c_read_phy_reg(&adapter->hw, MII_ISR, &phy_data);\r\nspin_unlock(&adapter->mdio_lock);\r\n}\r\nstatic bool atl1c_clean_tx_irq(struct atl1c_adapter *adapter,\r\nenum atl1c_trans_queue type)\r\n{\r\nstruct atl1c_tpd_ring *tpd_ring = &adapter->tpd_ring[type];\r\nstruct atl1c_buffer *buffer_info;\r\nstruct pci_dev *pdev = adapter->pdev;\r\nu16 next_to_clean = atomic_read(&tpd_ring->next_to_clean);\r\nu16 hw_next_to_clean;\r\nu16 reg;\r\nunsigned int total_bytes = 0, total_packets = 0;\r\nreg = type == atl1c_trans_high ? REG_TPD_PRI1_CIDX : REG_TPD_PRI0_CIDX;\r\nAT_READ_REGW(&adapter->hw, reg, &hw_next_to_clean);\r\nwhile (next_to_clean != hw_next_to_clean) {\r\nbuffer_info = &tpd_ring->buffer_info[next_to_clean];\r\nif (buffer_info->skb) {\r\ntotal_bytes += buffer_info->skb->len;\r\ntotal_packets++;\r\n}\r\natl1c_clean_buffer(pdev, buffer_info);\r\nif (++next_to_clean == tpd_ring->count)\r\nnext_to_clean = 0;\r\natomic_set(&tpd_ring->next_to_clean, next_to_clean);\r\n}\r\nnetdev_completed_queue(adapter->netdev, total_packets, total_bytes);\r\nif (netif_queue_stopped(adapter->netdev) &&\r\nnetif_carrier_ok(adapter->netdev)) {\r\nnetif_wake_queue(adapter->netdev);\r\n}\r\nreturn true;\r\n}\r\nstatic irqreturn_t atl1c_intr(int irq, void *data)\r\n{\r\nstruct net_device *netdev = data;\r\nstruct atl1c_adapter *adapter = netdev_priv(netdev);\r\nstruct pci_dev *pdev = adapter->pdev;\r\nstruct atl1c_hw *hw = &adapter->hw;\r\nint max_ints = AT_MAX_INT_WORK;\r\nint handled = IRQ_NONE;\r\nu32 status;\r\nu32 reg_data;\r\ndo {\r\nAT_READ_REG(hw, REG_ISR, &reg_data);\r\nstatus = reg_data & hw->intr_mask;\r\nif (status == 0 || (status & ISR_DIS_INT) != 0) {\r\nif (max_ints != AT_MAX_INT_WORK)\r\nhandled = IRQ_HANDLED;\r\nbreak;\r\n}\r\nif (status & ISR_GPHY)\r\natl1c_clear_phy_int(adapter);\r\nAT_WRITE_REG(hw, REG_ISR, status | ISR_DIS_INT);\r\nif (status & ISR_RX_PKT) {\r\nif (likely(napi_schedule_prep(&adapter->napi))) {\r\nhw->intr_mask &= ~ISR_RX_PKT;\r\nAT_WRITE_REG(hw, REG_IMR, hw->intr_mask);\r\n__napi_schedule(&adapter->napi);\r\n}\r\n}\r\nif (status & ISR_TX_PKT)\r\natl1c_clean_tx_irq(adapter, atl1c_trans_normal);\r\nhandled = IRQ_HANDLED;\r\nif (status & ISR_ERROR) {\r\nif (netif_msg_hw(adapter))\r\ndev_err(&pdev->dev,\r\n"atl1c hardware error (status = 0x%x)\n",\r\nstatus & ISR_ERROR);\r\nset_bit(ATL1C_WORK_EVENT_RESET, &adapter->work_event);\r\nschedule_work(&adapter->common_task);\r\nreturn IRQ_HANDLED;\r\n}\r\nif (status & ISR_OVER)\r\nif (netif_msg_intr(adapter))\r\ndev_warn(&pdev->dev,\r\n"TX/RX overflow (status = 0x%x)\n",\r\nstatus & ISR_OVER);\r\nif (status & (ISR_GPHY | ISR_MANUAL)) {\r\nnetdev->stats.tx_carrier_errors++;\r\natl1c_link_chg_event(adapter);\r\nbreak;\r\n}\r\n} while (--max_ints > 0);\r\nAT_WRITE_REG(&adapter->hw, REG_ISR, 0);\r\nreturn handled;\r\n}\r\nstatic inline void atl1c_rx_checksum(struct atl1c_adapter *adapter,\r\nstruct sk_buff *skb, struct atl1c_recv_ret_status *prrs)\r\n{\r\nskb_checksum_none_assert(skb);\r\n}\r\nstatic struct sk_buff *atl1c_alloc_skb(struct atl1c_adapter *adapter)\r\n{\r\nstruct sk_buff *skb;\r\nstruct page *page;\r\nif (adapter->rx_frag_size > PAGE_SIZE)\r\nreturn netdev_alloc_skb(adapter->netdev,\r\nadapter->rx_buffer_len);\r\npage = adapter->rx_page;\r\nif (!page) {\r\nadapter->rx_page = page = alloc_page(GFP_ATOMIC);\r\nif (unlikely(!page))\r\nreturn NULL;\r\nadapter->rx_page_offset = 0;\r\n}\r\nskb = build_skb(page_address(page) + adapter->rx_page_offset,\r\nadapter->rx_frag_size);\r\nif (likely(skb)) {\r\nadapter->rx_page_offset += adapter->rx_frag_size;\r\nif (adapter->rx_page_offset >= PAGE_SIZE)\r\nadapter->rx_page = NULL;\r\nelse\r\nget_page(page);\r\n}\r\nreturn skb;\r\n}\r\nstatic int atl1c_alloc_rx_buffer(struct atl1c_adapter *adapter)\r\n{\r\nstruct atl1c_rfd_ring *rfd_ring = &adapter->rfd_ring;\r\nstruct pci_dev *pdev = adapter->pdev;\r\nstruct atl1c_buffer *buffer_info, *next_info;\r\nstruct sk_buff *skb;\r\nvoid *vir_addr = NULL;\r\nu16 num_alloc = 0;\r\nu16 rfd_next_to_use, next_next;\r\nstruct atl1c_rx_free_desc *rfd_desc;\r\ndma_addr_t mapping;\r\nnext_next = rfd_next_to_use = rfd_ring->next_to_use;\r\nif (++next_next == rfd_ring->count)\r\nnext_next = 0;\r\nbuffer_info = &rfd_ring->buffer_info[rfd_next_to_use];\r\nnext_info = &rfd_ring->buffer_info[next_next];\r\nwhile (next_info->flags & ATL1C_BUFFER_FREE) {\r\nrfd_desc = ATL1C_RFD_DESC(rfd_ring, rfd_next_to_use);\r\nskb = atl1c_alloc_skb(adapter);\r\nif (unlikely(!skb)) {\r\nif (netif_msg_rx_err(adapter))\r\ndev_warn(&pdev->dev, "alloc rx buffer failed\n");\r\nbreak;\r\n}\r\nvir_addr = skb->data;\r\nATL1C_SET_BUFFER_STATE(buffer_info, ATL1C_BUFFER_BUSY);\r\nbuffer_info->skb = skb;\r\nbuffer_info->length = adapter->rx_buffer_len;\r\nmapping = pci_map_single(pdev, vir_addr,\r\nbuffer_info->length,\r\nPCI_DMA_FROMDEVICE);\r\nif (unlikely(pci_dma_mapping_error(pdev, mapping))) {\r\ndev_kfree_skb(skb);\r\nbuffer_info->skb = NULL;\r\nbuffer_info->length = 0;\r\nATL1C_SET_BUFFER_STATE(buffer_info, ATL1C_BUFFER_FREE);\r\nnetif_warn(adapter, rx_err, adapter->netdev, "RX pci_map_single failed");\r\nbreak;\r\n}\r\nbuffer_info->dma = mapping;\r\nATL1C_SET_PCIMAP_TYPE(buffer_info, ATL1C_PCIMAP_SINGLE,\r\nATL1C_PCIMAP_FROMDEVICE);\r\nrfd_desc->buffer_addr = cpu_to_le64(buffer_info->dma);\r\nrfd_next_to_use = next_next;\r\nif (++next_next == rfd_ring->count)\r\nnext_next = 0;\r\nbuffer_info = &rfd_ring->buffer_info[rfd_next_to_use];\r\nnext_info = &rfd_ring->buffer_info[next_next];\r\nnum_alloc++;\r\n}\r\nif (num_alloc) {\r\nwmb();\r\nrfd_ring->next_to_use = rfd_next_to_use;\r\nAT_WRITE_REG(&adapter->hw, REG_MB_RFD0_PROD_IDX,\r\nrfd_ring->next_to_use & MB_RFDX_PROD_IDX_MASK);\r\n}\r\nreturn num_alloc;\r\n}\r\nstatic void atl1c_clean_rrd(struct atl1c_rrd_ring *rrd_ring,\r\nstruct atl1c_recv_ret_status *rrs, u16 num)\r\n{\r\nu16 i;\r\nfor (i = 0; i < num; i++, rrs = ATL1C_RRD_DESC(rrd_ring,\r\nrrd_ring->next_to_clean)) {\r\nrrs->word3 &= ~RRS_RXD_UPDATED;\r\nif (++rrd_ring->next_to_clean == rrd_ring->count)\r\nrrd_ring->next_to_clean = 0;\r\n}\r\n}\r\nstatic void atl1c_clean_rfd(struct atl1c_rfd_ring *rfd_ring,\r\nstruct atl1c_recv_ret_status *rrs, u16 num)\r\n{\r\nu16 i;\r\nu16 rfd_index;\r\nstruct atl1c_buffer *buffer_info = rfd_ring->buffer_info;\r\nrfd_index = (rrs->word0 >> RRS_RX_RFD_INDEX_SHIFT) &\r\nRRS_RX_RFD_INDEX_MASK;\r\nfor (i = 0; i < num; i++) {\r\nbuffer_info[rfd_index].skb = NULL;\r\nATL1C_SET_BUFFER_STATE(&buffer_info[rfd_index],\r\nATL1C_BUFFER_FREE);\r\nif (++rfd_index == rfd_ring->count)\r\nrfd_index = 0;\r\n}\r\nrfd_ring->next_to_clean = rfd_index;\r\n}\r\nstatic void atl1c_clean_rx_irq(struct atl1c_adapter *adapter,\r\nint *work_done, int work_to_do)\r\n{\r\nu16 rfd_num, rfd_index;\r\nu16 count = 0;\r\nu16 length;\r\nstruct pci_dev *pdev = adapter->pdev;\r\nstruct net_device *netdev = adapter->netdev;\r\nstruct atl1c_rfd_ring *rfd_ring = &adapter->rfd_ring;\r\nstruct atl1c_rrd_ring *rrd_ring = &adapter->rrd_ring;\r\nstruct sk_buff *skb;\r\nstruct atl1c_recv_ret_status *rrs;\r\nstruct atl1c_buffer *buffer_info;\r\nwhile (1) {\r\nif (*work_done >= work_to_do)\r\nbreak;\r\nrrs = ATL1C_RRD_DESC(rrd_ring, rrd_ring->next_to_clean);\r\nif (likely(RRS_RXD_IS_VALID(rrs->word3))) {\r\nrfd_num = (rrs->word0 >> RRS_RX_RFD_CNT_SHIFT) &\r\nRRS_RX_RFD_CNT_MASK;\r\nif (unlikely(rfd_num != 1))\r\nif (netif_msg_rx_err(adapter))\r\ndev_warn(&pdev->dev,\r\n"Multi rfd not support yet!\n");\r\ngoto rrs_checked;\r\n} else {\r\nbreak;\r\n}\r\nrrs_checked:\r\natl1c_clean_rrd(rrd_ring, rrs, rfd_num);\r\nif (rrs->word3 & (RRS_RX_ERR_SUM | RRS_802_3_LEN_ERR)) {\r\natl1c_clean_rfd(rfd_ring, rrs, rfd_num);\r\nif (netif_msg_rx_err(adapter))\r\ndev_warn(&pdev->dev,\r\n"wrong packet! rrs word3 is %x\n",\r\nrrs->word3);\r\ncontinue;\r\n}\r\nlength = le16_to_cpu((rrs->word3 >> RRS_PKT_SIZE_SHIFT) &\r\nRRS_PKT_SIZE_MASK);\r\nif (likely(rfd_num == 1)) {\r\nrfd_index = (rrs->word0 >> RRS_RX_RFD_INDEX_SHIFT) &\r\nRRS_RX_RFD_INDEX_MASK;\r\nbuffer_info = &rfd_ring->buffer_info[rfd_index];\r\npci_unmap_single(pdev, buffer_info->dma,\r\nbuffer_info->length, PCI_DMA_FROMDEVICE);\r\nskb = buffer_info->skb;\r\n} else {\r\nif (netif_msg_rx_err(adapter))\r\ndev_warn(&pdev->dev,\r\n"Multi rfd not support yet!\n");\r\nbreak;\r\n}\r\natl1c_clean_rfd(rfd_ring, rrs, rfd_num);\r\nskb_put(skb, length - ETH_FCS_LEN);\r\nskb->protocol = eth_type_trans(skb, netdev);\r\natl1c_rx_checksum(adapter, skb, rrs);\r\nif (rrs->word3 & RRS_VLAN_INS) {\r\nu16 vlan;\r\nAT_TAG_TO_VLAN(rrs->vlan_tag, vlan);\r\nvlan = le16_to_cpu(vlan);\r\n__vlan_hwaccel_put_tag(skb, htons(ETH_P_8021Q), vlan);\r\n}\r\nnetif_receive_skb(skb);\r\n(*work_done)++;\r\ncount++;\r\n}\r\nif (count)\r\natl1c_alloc_rx_buffer(adapter);\r\n}\r\nstatic int atl1c_clean(struct napi_struct *napi, int budget)\r\n{\r\nstruct atl1c_adapter *adapter =\r\ncontainer_of(napi, struct atl1c_adapter, napi);\r\nint work_done = 0;\r\nif (!netif_carrier_ok(adapter->netdev))\r\ngoto quit_polling;\r\natl1c_clean_rx_irq(adapter, &work_done, budget);\r\nif (work_done < budget) {\r\nquit_polling:\r\nnapi_complete(napi);\r\nadapter->hw.intr_mask |= ISR_RX_PKT;\r\nAT_WRITE_REG(&adapter->hw, REG_IMR, adapter->hw.intr_mask);\r\n}\r\nreturn work_done;\r\n}\r\nstatic void atl1c_netpoll(struct net_device *netdev)\r\n{\r\nstruct atl1c_adapter *adapter = netdev_priv(netdev);\r\ndisable_irq(adapter->pdev->irq);\r\natl1c_intr(adapter->pdev->irq, netdev);\r\nenable_irq(adapter->pdev->irq);\r\n}\r\nstatic inline u16 atl1c_tpd_avail(struct atl1c_adapter *adapter, enum atl1c_trans_queue type)\r\n{\r\nstruct atl1c_tpd_ring *tpd_ring = &adapter->tpd_ring[type];\r\nu16 next_to_use = 0;\r\nu16 next_to_clean = 0;\r\nnext_to_clean = atomic_read(&tpd_ring->next_to_clean);\r\nnext_to_use = tpd_ring->next_to_use;\r\nreturn (u16)(next_to_clean > next_to_use) ?\r\n(next_to_clean - next_to_use - 1) :\r\n(tpd_ring->count + next_to_clean - next_to_use - 1);\r\n}\r\nstatic struct atl1c_tpd_desc *atl1c_get_tpd(struct atl1c_adapter *adapter,\r\nenum atl1c_trans_queue type)\r\n{\r\nstruct atl1c_tpd_ring *tpd_ring = &adapter->tpd_ring[type];\r\nstruct atl1c_tpd_desc *tpd_desc;\r\nu16 next_to_use = 0;\r\nnext_to_use = tpd_ring->next_to_use;\r\nif (++tpd_ring->next_to_use == tpd_ring->count)\r\ntpd_ring->next_to_use = 0;\r\ntpd_desc = ATL1C_TPD_DESC(tpd_ring, next_to_use);\r\nmemset(tpd_desc, 0, sizeof(struct atl1c_tpd_desc));\r\nreturn tpd_desc;\r\n}\r\nstatic struct atl1c_buffer *\r\natl1c_get_tx_buffer(struct atl1c_adapter *adapter, struct atl1c_tpd_desc *tpd)\r\n{\r\nstruct atl1c_tpd_ring *tpd_ring = adapter->tpd_ring;\r\nreturn &tpd_ring->buffer_info[tpd -\r\n(struct atl1c_tpd_desc *)tpd_ring->desc];\r\nu16 atl1c_cal_tpd_req(const struct sk_buff *skb)\r\n{\r\nu16 tpd_req;\r\nu16 proto_hdr_len = 0;\r\ntpd_req = skb_shinfo(skb)->nr_frags + 1;\r\nif (skb_is_gso(skb)) {\r\nproto_hdr_len = skb_transport_offset(skb) + tcp_hdrlen(skb);\r\nif (proto_hdr_len < skb_headlen(skb))\r\ntpd_req++;\r\nif (skb_shinfo(skb)->gso_type & SKB_GSO_TCPV6)\r\ntpd_req++;\r\n}\r\nreturn tpd_req;\r\n}\r\nstatic int atl1c_tso_csum(struct atl1c_adapter *adapter,\r\nstruct sk_buff *skb,\r\nstruct atl1c_tpd_desc **tpd,\r\nenum atl1c_trans_queue type)\r\n{\r\nstruct pci_dev *pdev = adapter->pdev;\r\nunsigned short offload_type;\r\nu8 hdr_len;\r\nu32 real_len;\r\nif (skb_is_gso(skb)) {\r\nint err;\r\nerr = skb_cow_head(skb, 0);\r\nif (err < 0)\r\nreturn err;\r\noffload_type = skb_shinfo(skb)->gso_type;\r\nif (offload_type & SKB_GSO_TCPV4) {\r\nreal_len = (((unsigned char *)ip_hdr(skb) - skb->data)\r\n+ ntohs(ip_hdr(skb)->tot_len));\r\nif (real_len < skb->len)\r\npskb_trim(skb, real_len);\r\nhdr_len = (skb_transport_offset(skb) + tcp_hdrlen(skb));\r\nif (unlikely(skb->len == hdr_len)) {\r\nif (netif_msg_tx_queued(adapter))\r\ndev_warn(&pdev->dev,\r\n"IPV4 tso with zero data??\n");\r\ngoto check_sum;\r\n} else {\r\nip_hdr(skb)->check = 0;\r\ntcp_hdr(skb)->check = ~csum_tcpudp_magic(\r\nip_hdr(skb)->saddr,\r\nip_hdr(skb)->daddr,\r\n0, IPPROTO_TCP, 0);\r\n(*tpd)->word1 |= 1 << TPD_IPV4_PACKET_SHIFT;\r\n}\r\n}\r\nif (offload_type & SKB_GSO_TCPV6) {\r\nstruct atl1c_tpd_ext_desc *etpd =\r\n*(struct atl1c_tpd_ext_desc **)(tpd);\r\nmemset(etpd, 0, sizeof(struct atl1c_tpd_ext_desc));\r\n*tpd = atl1c_get_tpd(adapter, type);\r\nipv6_hdr(skb)->payload_len = 0;\r\nhdr_len = (skb_transport_offset(skb) + tcp_hdrlen(skb));\r\nif (unlikely(skb->len == hdr_len)) {\r\nif (netif_msg_tx_queued(adapter))\r\ndev_warn(&pdev->dev,\r\n"IPV6 tso with zero data??\n");\r\ngoto check_sum;\r\n} else\r\ntcp_hdr(skb)->check = ~csum_ipv6_magic(\r\n&ipv6_hdr(skb)->saddr,\r\n&ipv6_hdr(skb)->daddr,\r\n0, IPPROTO_TCP, 0);\r\netpd->word1 |= 1 << TPD_LSO_EN_SHIFT;\r\netpd->word1 |= 1 << TPD_LSO_VER_SHIFT;\r\netpd->pkt_len = cpu_to_le32(skb->len);\r\n(*tpd)->word1 |= 1 << TPD_LSO_VER_SHIFT;\r\n}\r\n(*tpd)->word1 |= 1 << TPD_LSO_EN_SHIFT;\r\n(*tpd)->word1 |= (skb_transport_offset(skb) & TPD_TCPHDR_OFFSET_MASK) <<\r\nTPD_TCPHDR_OFFSET_SHIFT;\r\n(*tpd)->word1 |= (skb_shinfo(skb)->gso_size & TPD_MSS_MASK) <<\r\nTPD_MSS_SHIFT;\r\nreturn 0;\r\n}\r\ncheck_sum:\r\nif (likely(skb->ip_summed == CHECKSUM_PARTIAL)) {\r\nu8 css, cso;\r\ncso = skb_checksum_start_offset(skb);\r\nif (unlikely(cso & 0x1)) {\r\nif (netif_msg_tx_err(adapter))\r\ndev_err(&adapter->pdev->dev,\r\n"payload offset should not an event number\n");\r\nreturn -1;\r\n} else {\r\ncss = cso + skb->csum_offset;\r\n(*tpd)->word1 |= ((cso >> 1) & TPD_PLOADOFFSET_MASK) <<\r\nTPD_PLOADOFFSET_SHIFT;\r\n(*tpd)->word1 |= ((css >> 1) & TPD_CCSUM_OFFSET_MASK) <<\r\nTPD_CCSUM_OFFSET_SHIFT;\r\n(*tpd)->word1 |= 1 << TPD_CCSUM_EN_SHIFT;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic void atl1c_tx_rollback(struct atl1c_adapter *adpt,\r\nstruct atl1c_tpd_desc *first_tpd,\r\nenum atl1c_trans_queue type)\r\n{\r\nstruct atl1c_tpd_ring *tpd_ring = &adpt->tpd_ring[type];\r\nstruct atl1c_buffer *buffer_info;\r\nstruct atl1c_tpd_desc *tpd;\r\nu16 first_index, index;\r\nfirst_index = first_tpd - (struct atl1c_tpd_desc *)tpd_ring->desc;\r\nindex = first_index;\r\nwhile (index != tpd_ring->next_to_use) {\r\ntpd = ATL1C_TPD_DESC(tpd_ring, index);\r\nbuffer_info = &tpd_ring->buffer_info[index];\r\natl1c_clean_buffer(adpt->pdev, buffer_info);\r\nmemset(tpd, 0, sizeof(struct atl1c_tpd_desc));\r\nif (++index == tpd_ring->count)\r\nindex = 0;\r\n}\r\ntpd_ring->next_to_use = first_index;\r\n}\r\nstatic int atl1c_tx_map(struct atl1c_adapter *adapter,\r\nstruct sk_buff *skb, struct atl1c_tpd_desc *tpd,\r\nenum atl1c_trans_queue type)\r\n{\r\nstruct atl1c_tpd_desc *use_tpd = NULL;\r\nstruct atl1c_buffer *buffer_info = NULL;\r\nu16 buf_len = skb_headlen(skb);\r\nu16 map_len = 0;\r\nu16 mapped_len = 0;\r\nu16 hdr_len = 0;\r\nu16 nr_frags;\r\nu16 f;\r\nint tso;\r\nnr_frags = skb_shinfo(skb)->nr_frags;\r\ntso = (tpd->word1 >> TPD_LSO_EN_SHIFT) & TPD_LSO_EN_MASK;\r\nif (tso) {\r\nmap_len = hdr_len = skb_transport_offset(skb) + tcp_hdrlen(skb);\r\nuse_tpd = tpd;\r\nbuffer_info = atl1c_get_tx_buffer(adapter, use_tpd);\r\nbuffer_info->length = map_len;\r\nbuffer_info->dma = pci_map_single(adapter->pdev,\r\nskb->data, hdr_len, PCI_DMA_TODEVICE);\r\nif (unlikely(pci_dma_mapping_error(adapter->pdev,\r\nbuffer_info->dma)))\r\ngoto err_dma;\r\nATL1C_SET_BUFFER_STATE(buffer_info, ATL1C_BUFFER_BUSY);\r\nATL1C_SET_PCIMAP_TYPE(buffer_info, ATL1C_PCIMAP_SINGLE,\r\nATL1C_PCIMAP_TODEVICE);\r\nmapped_len += map_len;\r\nuse_tpd->buffer_addr = cpu_to_le64(buffer_info->dma);\r\nuse_tpd->buffer_len = cpu_to_le16(buffer_info->length);\r\n}\r\nif (mapped_len < buf_len) {\r\nif (mapped_len == 0)\r\nuse_tpd = tpd;\r\nelse {\r\nuse_tpd = atl1c_get_tpd(adapter, type);\r\nmemcpy(use_tpd, tpd, sizeof(struct atl1c_tpd_desc));\r\n}\r\nbuffer_info = atl1c_get_tx_buffer(adapter, use_tpd);\r\nbuffer_info->length = buf_len - mapped_len;\r\nbuffer_info->dma =\r\npci_map_single(adapter->pdev, skb->data + mapped_len,\r\nbuffer_info->length, PCI_DMA_TODEVICE);\r\nif (unlikely(pci_dma_mapping_error(adapter->pdev,\r\nbuffer_info->dma)))\r\ngoto err_dma;\r\nATL1C_SET_BUFFER_STATE(buffer_info, ATL1C_BUFFER_BUSY);\r\nATL1C_SET_PCIMAP_TYPE(buffer_info, ATL1C_PCIMAP_SINGLE,\r\nATL1C_PCIMAP_TODEVICE);\r\nuse_tpd->buffer_addr = cpu_to_le64(buffer_info->dma);\r\nuse_tpd->buffer_len = cpu_to_le16(buffer_info->length);\r\n}\r\nfor (f = 0; f < nr_frags; f++) {\r\nstruct skb_frag_struct *frag;\r\nfrag = &skb_shinfo(skb)->frags[f];\r\nuse_tpd = atl1c_get_tpd(adapter, type);\r\nmemcpy(use_tpd, tpd, sizeof(struct atl1c_tpd_desc));\r\nbuffer_info = atl1c_get_tx_buffer(adapter, use_tpd);\r\nbuffer_info->length = skb_frag_size(frag);\r\nbuffer_info->dma = skb_frag_dma_map(&adapter->pdev->dev,\r\nfrag, 0,\r\nbuffer_info->length,\r\nDMA_TO_DEVICE);\r\nif (dma_mapping_error(&adapter->pdev->dev, buffer_info->dma))\r\ngoto err_dma;\r\nATL1C_SET_BUFFER_STATE(buffer_info, ATL1C_BUFFER_BUSY);\r\nATL1C_SET_PCIMAP_TYPE(buffer_info, ATL1C_PCIMAP_PAGE,\r\nATL1C_PCIMAP_TODEVICE);\r\nuse_tpd->buffer_addr = cpu_to_le64(buffer_info->dma);\r\nuse_tpd->buffer_len = cpu_to_le16(buffer_info->length);\r\n}\r\nuse_tpd->word1 |= 1 << TPD_EOP_SHIFT;\r\nbuffer_info->skb = skb;\r\nreturn 0;\r\nerr_dma:\r\nbuffer_info->dma = 0;\r\nbuffer_info->length = 0;\r\nreturn -1;\r\n}\r\nstatic void atl1c_tx_queue(struct atl1c_adapter *adapter, struct sk_buff *skb,\r\nstruct atl1c_tpd_desc *tpd, enum atl1c_trans_queue type)\r\n{\r\nstruct atl1c_tpd_ring *tpd_ring = &adapter->tpd_ring[type];\r\nu16 reg;\r\nreg = type == atl1c_trans_high ? REG_TPD_PRI1_PIDX : REG_TPD_PRI0_PIDX;\r\nAT_WRITE_REGW(&adapter->hw, reg, tpd_ring->next_to_use);\r\n}\r\nstatic netdev_tx_t atl1c_xmit_frame(struct sk_buff *skb,\r\nstruct net_device *netdev)\r\n{\r\nstruct atl1c_adapter *adapter = netdev_priv(netdev);\r\nunsigned long flags;\r\nu16 tpd_req = 1;\r\nstruct atl1c_tpd_desc *tpd;\r\nenum atl1c_trans_queue type = atl1c_trans_normal;\r\nif (test_bit(__AT_DOWN, &adapter->flags)) {\r\ndev_kfree_skb_any(skb);\r\nreturn NETDEV_TX_OK;\r\n}\r\ntpd_req = atl1c_cal_tpd_req(skb);\r\nif (!spin_trylock_irqsave(&adapter->tx_lock, flags)) {\r\nif (netif_msg_pktdata(adapter))\r\ndev_info(&adapter->pdev->dev, "tx locked\n");\r\nreturn NETDEV_TX_LOCKED;\r\n}\r\nif (atl1c_tpd_avail(adapter, type) < tpd_req) {\r\nnetif_stop_queue(netdev);\r\nspin_unlock_irqrestore(&adapter->tx_lock, flags);\r\nreturn NETDEV_TX_BUSY;\r\n}\r\ntpd = atl1c_get_tpd(adapter, type);\r\nif (atl1c_tso_csum(adapter, skb, &tpd, type) != 0) {\r\nspin_unlock_irqrestore(&adapter->tx_lock, flags);\r\ndev_kfree_skb_any(skb);\r\nreturn NETDEV_TX_OK;\r\n}\r\nif (unlikely(skb_vlan_tag_present(skb))) {\r\nu16 vlan = skb_vlan_tag_get(skb);\r\n__le16 tag;\r\nvlan = cpu_to_le16(vlan);\r\nAT_VLAN_TO_TAG(vlan, tag);\r\ntpd->word1 |= 1 << TPD_INS_VTAG_SHIFT;\r\ntpd->vlan_tag = tag;\r\n}\r\nif (skb_network_offset(skb) != ETH_HLEN)\r\ntpd->word1 |= 1 << TPD_ETH_TYPE_SHIFT;\r\nif (atl1c_tx_map(adapter, skb, tpd, type) < 0) {\r\nnetif_info(adapter, tx_done, adapter->netdev,\r\n"tx-skb droppted due to dma error\n");\r\natl1c_tx_rollback(adapter, tpd, type);\r\nspin_unlock_irqrestore(&adapter->tx_lock, flags);\r\ndev_kfree_skb_any(skb);\r\n} else {\r\nnetdev_sent_queue(adapter->netdev, skb->len);\r\natl1c_tx_queue(adapter, skb, tpd, type);\r\nspin_unlock_irqrestore(&adapter->tx_lock, flags);\r\n}\r\nreturn NETDEV_TX_OK;\r\n}\r\nstatic void atl1c_free_irq(struct atl1c_adapter *adapter)\r\n{\r\nstruct net_device *netdev = adapter->netdev;\r\nfree_irq(adapter->pdev->irq, netdev);\r\nif (adapter->have_msi)\r\npci_disable_msi(adapter->pdev);\r\n}\r\nstatic int atl1c_request_irq(struct atl1c_adapter *adapter)\r\n{\r\nstruct pci_dev *pdev = adapter->pdev;\r\nstruct net_device *netdev = adapter->netdev;\r\nint flags = 0;\r\nint err = 0;\r\nadapter->have_msi = true;\r\nerr = pci_enable_msi(adapter->pdev);\r\nif (err) {\r\nif (netif_msg_ifup(adapter))\r\ndev_err(&pdev->dev,\r\n"Unable to allocate MSI interrupt Error: %d\n",\r\nerr);\r\nadapter->have_msi = false;\r\n}\r\nif (!adapter->have_msi)\r\nflags |= IRQF_SHARED;\r\nerr = request_irq(adapter->pdev->irq, atl1c_intr, flags,\r\nnetdev->name, netdev);\r\nif (err) {\r\nif (netif_msg_ifup(adapter))\r\ndev_err(&pdev->dev,\r\n"Unable to allocate interrupt Error: %d\n",\r\nerr);\r\nif (adapter->have_msi)\r\npci_disable_msi(adapter->pdev);\r\nreturn err;\r\n}\r\nif (netif_msg_ifup(adapter))\r\ndev_dbg(&pdev->dev, "atl1c_request_irq OK\n");\r\nreturn err;\r\n}\r\nstatic void atl1c_reset_dma_ring(struct atl1c_adapter *adapter)\r\n{\r\natl1c_clean_tx_ring(adapter, atl1c_trans_normal);\r\natl1c_clean_tx_ring(adapter, atl1c_trans_high);\r\natl1c_clean_rx_ring(adapter);\r\n}\r\nstatic int atl1c_up(struct atl1c_adapter *adapter)\r\n{\r\nstruct net_device *netdev = adapter->netdev;\r\nint err;\r\nnetif_carrier_off(netdev);\r\nerr = atl1c_configure(adapter);\r\nif (unlikely(err))\r\ngoto err_up;\r\nerr = atl1c_request_irq(adapter);\r\nif (unlikely(err))\r\ngoto err_up;\r\natl1c_check_link_status(adapter);\r\nclear_bit(__AT_DOWN, &adapter->flags);\r\nnapi_enable(&adapter->napi);\r\natl1c_irq_enable(adapter);\r\nnetif_start_queue(netdev);\r\nreturn err;\r\nerr_up:\r\natl1c_clean_rx_ring(adapter);\r\nreturn err;\r\n}\r\nstatic void atl1c_down(struct atl1c_adapter *adapter)\r\n{\r\nstruct net_device *netdev = adapter->netdev;\r\natl1c_del_timer(adapter);\r\nadapter->work_event = 0;\r\nset_bit(__AT_DOWN, &adapter->flags);\r\nnetif_carrier_off(netdev);\r\nnapi_disable(&adapter->napi);\r\natl1c_irq_disable(adapter);\r\natl1c_free_irq(adapter);\r\natl1c_disable_l0s_l1(&adapter->hw);\r\natl1c_reset_mac(&adapter->hw);\r\nmsleep(1);\r\nadapter->link_speed = SPEED_0;\r\nadapter->link_duplex = -1;\r\natl1c_reset_dma_ring(adapter);\r\n}\r\nstatic int atl1c_open(struct net_device *netdev)\r\n{\r\nstruct atl1c_adapter *adapter = netdev_priv(netdev);\r\nint err;\r\nif (test_bit(__AT_TESTING, &adapter->flags))\r\nreturn -EBUSY;\r\nerr = atl1c_setup_ring_resources(adapter);\r\nif (unlikely(err))\r\nreturn err;\r\nerr = atl1c_up(adapter);\r\nif (unlikely(err))\r\ngoto err_up;\r\nreturn 0;\r\nerr_up:\r\natl1c_free_irq(adapter);\r\natl1c_free_ring_resources(adapter);\r\natl1c_reset_mac(&adapter->hw);\r\nreturn err;\r\n}\r\nstatic int atl1c_close(struct net_device *netdev)\r\n{\r\nstruct atl1c_adapter *adapter = netdev_priv(netdev);\r\nWARN_ON(test_bit(__AT_RESETTING, &adapter->flags));\r\nset_bit(__AT_DOWN, &adapter->flags);\r\ncancel_work_sync(&adapter->common_task);\r\natl1c_down(adapter);\r\natl1c_free_ring_resources(adapter);\r\nreturn 0;\r\n}\r\nstatic int atl1c_suspend(struct device *dev)\r\n{\r\nstruct pci_dev *pdev = to_pci_dev(dev);\r\nstruct net_device *netdev = pci_get_drvdata(pdev);\r\nstruct atl1c_adapter *adapter = netdev_priv(netdev);\r\nstruct atl1c_hw *hw = &adapter->hw;\r\nu32 wufc = adapter->wol;\r\natl1c_disable_l0s_l1(hw);\r\nif (netif_running(netdev)) {\r\nWARN_ON(test_bit(__AT_RESETTING, &adapter->flags));\r\natl1c_down(adapter);\r\n}\r\nnetif_device_detach(netdev);\r\nif (wufc)\r\nif (atl1c_phy_to_ps_link(hw) != 0)\r\ndev_dbg(&pdev->dev, "phy power saving failed");\r\natl1c_power_saving(hw, wufc);\r\nreturn 0;\r\n}\r\nstatic int atl1c_resume(struct device *dev)\r\n{\r\nstruct pci_dev *pdev = to_pci_dev(dev);\r\nstruct net_device *netdev = pci_get_drvdata(pdev);\r\nstruct atl1c_adapter *adapter = netdev_priv(netdev);\r\nAT_WRITE_REG(&adapter->hw, REG_WOL_CTRL, 0);\r\natl1c_reset_pcie(&adapter->hw, ATL1C_PCIE_L0S_L1_DISABLE);\r\natl1c_phy_reset(&adapter->hw);\r\natl1c_reset_mac(&adapter->hw);\r\natl1c_phy_init(&adapter->hw);\r\n#if 0\r\nAT_READ_REG(&adapter->hw, REG_PM_CTRLSTAT, &pm_data);\r\npm_data &= ~PM_CTRLSTAT_PME_EN;\r\nAT_WRITE_REG(&adapter->hw, REG_PM_CTRLSTAT, pm_data);\r\n#endif\r\nnetif_device_attach(netdev);\r\nif (netif_running(netdev))\r\natl1c_up(adapter);\r\nreturn 0;\r\n}\r\nstatic void atl1c_shutdown(struct pci_dev *pdev)\r\n{\r\nstruct net_device *netdev = pci_get_drvdata(pdev);\r\nstruct atl1c_adapter *adapter = netdev_priv(netdev);\r\natl1c_suspend(&pdev->dev);\r\npci_wake_from_d3(pdev, adapter->wol);\r\npci_set_power_state(pdev, PCI_D3hot);\r\n}\r\nstatic int atl1c_init_netdev(struct net_device *netdev, struct pci_dev *pdev)\r\n{\r\nSET_NETDEV_DEV(netdev, &pdev->dev);\r\npci_set_drvdata(pdev, netdev);\r\nnetdev->netdev_ops = &atl1c_netdev_ops;\r\nnetdev->watchdog_timeo = AT_TX_WATCHDOG;\r\natl1c_set_ethtool_ops(netdev);\r\nnetdev->hw_features = NETIF_F_SG |\r\nNETIF_F_HW_CSUM |\r\nNETIF_F_HW_VLAN_CTAG_RX |\r\nNETIF_F_TSO |\r\nNETIF_F_TSO6;\r\nnetdev->features = netdev->hw_features |\r\nNETIF_F_HW_VLAN_CTAG_TX;\r\nreturn 0;\r\n}\r\nstatic int atl1c_probe(struct pci_dev *pdev, const struct pci_device_id *ent)\r\n{\r\nstruct net_device *netdev;\r\nstruct atl1c_adapter *adapter;\r\nstatic int cards_found;\r\nint err = 0;\r\nerr = pci_enable_device_mem(pdev);\r\nif (err) {\r\ndev_err(&pdev->dev, "cannot enable PCI device\n");\r\nreturn err;\r\n}\r\nif ((pci_set_dma_mask(pdev, DMA_BIT_MASK(32)) != 0) ||\r\n(pci_set_consistent_dma_mask(pdev, DMA_BIT_MASK(32)) != 0)) {\r\ndev_err(&pdev->dev, "No usable DMA configuration,aborting\n");\r\ngoto err_dma;\r\n}\r\nerr = pci_request_regions(pdev, atl1c_driver_name);\r\nif (err) {\r\ndev_err(&pdev->dev, "cannot obtain PCI resources\n");\r\ngoto err_pci_reg;\r\n}\r\npci_set_master(pdev);\r\nnetdev = alloc_etherdev(sizeof(struct atl1c_adapter));\r\nif (netdev == NULL) {\r\nerr = -ENOMEM;\r\ngoto err_alloc_etherdev;\r\n}\r\nerr = atl1c_init_netdev(netdev, pdev);\r\nif (err) {\r\ndev_err(&pdev->dev, "init netdevice failed\n");\r\ngoto err_init_netdev;\r\n}\r\nadapter = netdev_priv(netdev);\r\nadapter->bd_number = cards_found;\r\nadapter->netdev = netdev;\r\nadapter->pdev = pdev;\r\nadapter->hw.adapter = adapter;\r\nadapter->msg_enable = netif_msg_init(-1, atl1c_default_msg);\r\nadapter->hw.hw_addr = ioremap(pci_resource_start(pdev, 0), pci_resource_len(pdev, 0));\r\nif (!adapter->hw.hw_addr) {\r\nerr = -EIO;\r\ndev_err(&pdev->dev, "cannot map device registers\n");\r\ngoto err_ioremap;\r\n}\r\nadapter->mii.dev = netdev;\r\nadapter->mii.mdio_read = atl1c_mdio_read;\r\nadapter->mii.mdio_write = atl1c_mdio_write;\r\nadapter->mii.phy_id_mask = 0x1f;\r\nadapter->mii.reg_num_mask = MDIO_CTRL_REG_MASK;\r\nnetif_napi_add(netdev, &adapter->napi, atl1c_clean, 64);\r\nsetup_timer(&adapter->phy_config_timer, atl1c_phy_config,\r\n(unsigned long)adapter);\r\nerr = atl1c_sw_init(adapter);\r\nif (err) {\r\ndev_err(&pdev->dev, "net device private data init failed\n");\r\ngoto err_sw_init;\r\n}\r\natl1c_reset_pcie(&adapter->hw, ATL1C_PCIE_L0S_L1_DISABLE);\r\natl1c_phy_reset(&adapter->hw);\r\nerr = atl1c_reset_mac(&adapter->hw);\r\nif (err) {\r\nerr = -EIO;\r\ngoto err_reset;\r\n}\r\nerr = atl1c_phy_init(&adapter->hw);\r\nif (err) {\r\nerr = -EIO;\r\ngoto err_reset;\r\n}\r\nif (atl1c_read_mac_addr(&adapter->hw)) {\r\nnetdev->addr_assign_type = NET_ADDR_RANDOM;\r\n}\r\nmemcpy(netdev->dev_addr, adapter->hw.mac_addr, netdev->addr_len);\r\nif (netif_msg_probe(adapter))\r\ndev_dbg(&pdev->dev, "mac address : %pM\n",\r\nadapter->hw.mac_addr);\r\natl1c_hw_set_mac_addr(&adapter->hw, adapter->hw.mac_addr);\r\nINIT_WORK(&adapter->common_task, atl1c_common_task);\r\nadapter->work_event = 0;\r\nerr = register_netdev(netdev);\r\nif (err) {\r\ndev_err(&pdev->dev, "register netdevice failed\n");\r\ngoto err_register;\r\n}\r\nif (netif_msg_probe(adapter))\r\ndev_info(&pdev->dev, "version %s\n", ATL1C_DRV_VERSION);\r\ncards_found++;\r\nreturn 0;\r\nerr_reset:\r\nerr_register:\r\nerr_sw_init:\r\niounmap(adapter->hw.hw_addr);\r\nerr_init_netdev:\r\nerr_ioremap:\r\nfree_netdev(netdev);\r\nerr_alloc_etherdev:\r\npci_release_regions(pdev);\r\nerr_pci_reg:\r\nerr_dma:\r\npci_disable_device(pdev);\r\nreturn err;\r\n}\r\nstatic void atl1c_remove(struct pci_dev *pdev)\r\n{\r\nstruct net_device *netdev = pci_get_drvdata(pdev);\r\nstruct atl1c_adapter *adapter = netdev_priv(netdev);\r\nunregister_netdev(netdev);\r\natl1c_hw_set_mac_addr(&adapter->hw, adapter->hw.perm_mac_addr);\r\natl1c_phy_disable(&adapter->hw);\r\niounmap(adapter->hw.hw_addr);\r\npci_release_regions(pdev);\r\npci_disable_device(pdev);\r\nfree_netdev(netdev);\r\n}\r\nstatic pci_ers_result_t atl1c_io_error_detected(struct pci_dev *pdev,\r\npci_channel_state_t state)\r\n{\r\nstruct net_device *netdev = pci_get_drvdata(pdev);\r\nstruct atl1c_adapter *adapter = netdev_priv(netdev);\r\nnetif_device_detach(netdev);\r\nif (state == pci_channel_io_perm_failure)\r\nreturn PCI_ERS_RESULT_DISCONNECT;\r\nif (netif_running(netdev))\r\natl1c_down(adapter);\r\npci_disable_device(pdev);\r\nreturn PCI_ERS_RESULT_NEED_RESET;\r\n}\r\nstatic pci_ers_result_t atl1c_io_slot_reset(struct pci_dev *pdev)\r\n{\r\nstruct net_device *netdev = pci_get_drvdata(pdev);\r\nstruct atl1c_adapter *adapter = netdev_priv(netdev);\r\nif (pci_enable_device(pdev)) {\r\nif (netif_msg_hw(adapter))\r\ndev_err(&pdev->dev,\r\n"Cannot re-enable PCI device after reset\n");\r\nreturn PCI_ERS_RESULT_DISCONNECT;\r\n}\r\npci_set_master(pdev);\r\npci_enable_wake(pdev, PCI_D3hot, 0);\r\npci_enable_wake(pdev, PCI_D3cold, 0);\r\natl1c_reset_mac(&adapter->hw);\r\nreturn PCI_ERS_RESULT_RECOVERED;\r\n}\r\nstatic void atl1c_io_resume(struct pci_dev *pdev)\r\n{\r\nstruct net_device *netdev = pci_get_drvdata(pdev);\r\nstruct atl1c_adapter *adapter = netdev_priv(netdev);\r\nif (netif_running(netdev)) {\r\nif (atl1c_up(adapter)) {\r\nif (netif_msg_hw(adapter))\r\ndev_err(&pdev->dev,\r\n"Cannot bring device back up after reset\n");\r\nreturn;\r\n}\r\n}\r\nnetif_device_attach(netdev);\r\n}
