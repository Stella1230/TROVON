int snd_pt2258_reset(struct snd_pt2258 *pt)\r\n{\r\nunsigned char bytes[2];\r\nint i;\r\nbytes[0] = PT2258_CMD_RESET;\r\nsnd_i2c_lock(pt->i2c_bus);\r\nif (snd_i2c_sendbytes(pt->i2c_dev, bytes, 1) != 1)\r\ngoto __error;\r\nsnd_i2c_unlock(pt->i2c_bus);\r\npt->mute = 1;\r\nbytes[0] = PT2258_CMD_MUTE;\r\nsnd_i2c_lock(pt->i2c_bus);\r\nif (snd_i2c_sendbytes(pt->i2c_dev, bytes, 1) != 1)\r\ngoto __error;\r\nsnd_i2c_unlock(pt->i2c_bus);\r\nfor (i = 0; i < 6; ++i)\r\npt->volume[i] = 0;\r\nbytes[0] = 0xd0;\r\nbytes[1] = 0xe0;\r\nsnd_i2c_lock(pt->i2c_bus);\r\nif (snd_i2c_sendbytes(pt->i2c_dev, bytes, 2) != 2)\r\ngoto __error;\r\nsnd_i2c_unlock(pt->i2c_bus);\r\nreturn 0;\r\n__error:\r\nsnd_i2c_unlock(pt->i2c_bus);\r\nsnd_printk(KERN_ERR "PT2258 reset failed\n");\r\nreturn -EIO;\r\n}\r\nstatic int pt2258_stereo_volume_info(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_info *uinfo)\r\n{\r\nuinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;\r\nuinfo->count = 2;\r\nuinfo->value.integer.min = 0;\r\nuinfo->value.integer.max = 79;\r\nreturn 0;\r\n}\r\nstatic int pt2258_stereo_volume_get(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_pt2258 *pt = kcontrol->private_data;\r\nint base = kcontrol->private_value;\r\nucontrol->value.integer.value[0] = 79 - pt->volume[base];\r\nucontrol->value.integer.value[1] = 79 - pt->volume[base + 1];\r\nreturn 0;\r\n}\r\nstatic int pt2258_stereo_volume_put(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_pt2258 *pt = kcontrol->private_data;\r\nint base = kcontrol->private_value;\r\nunsigned char bytes[2];\r\nint val0, val1;\r\nval0 = 79 - ucontrol->value.integer.value[0];\r\nval1 = 79 - ucontrol->value.integer.value[1];\r\nif (val0 < 0 || val0 > 79 || val1 < 0 || val1 > 79)\r\nreturn -EINVAL;\r\nif (val0 == pt->volume[base] && val1 == pt->volume[base + 1])\r\nreturn 0;\r\npt->volume[base] = val0;\r\nbytes[0] = pt2258_channel_code[2 * base] | (val0 / 10);\r\nbytes[1] = pt2258_channel_code[2 * base + 1] | (val0 % 10);\r\nsnd_i2c_lock(pt->i2c_bus);\r\nif (snd_i2c_sendbytes(pt->i2c_dev, bytes, 2) != 2)\r\ngoto __error;\r\nsnd_i2c_unlock(pt->i2c_bus);\r\npt->volume[base + 1] = val1;\r\nbytes[0] = pt2258_channel_code[2 * base + 2] | (val1 / 10);\r\nbytes[1] = pt2258_channel_code[2 * base + 3] | (val1 % 10);\r\nsnd_i2c_lock(pt->i2c_bus);\r\nif (snd_i2c_sendbytes(pt->i2c_dev, bytes, 2) != 2)\r\ngoto __error;\r\nsnd_i2c_unlock(pt->i2c_bus);\r\nreturn 1;\r\n__error:\r\nsnd_i2c_unlock(pt->i2c_bus);\r\nsnd_printk(KERN_ERR "PT2258 access failed\n");\r\nreturn -EIO;\r\n}\r\nstatic int pt2258_switch_get(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_pt2258 *pt = kcontrol->private_data;\r\nucontrol->value.integer.value[0] = !pt->mute;\r\nreturn 0;\r\n}\r\nstatic int pt2258_switch_put(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_pt2258 *pt = kcontrol->private_data;\r\nunsigned char bytes[2];\r\nint val;\r\nval = !ucontrol->value.integer.value[0];\r\nif (pt->mute == val)\r\nreturn 0;\r\npt->mute = val;\r\nbytes[0] = val ? PT2258_CMD_MUTE : PT2258_CMD_UNMUTE;\r\nsnd_i2c_lock(pt->i2c_bus);\r\nif (snd_i2c_sendbytes(pt->i2c_dev, bytes, 1) != 1)\r\ngoto __error;\r\nsnd_i2c_unlock(pt->i2c_bus);\r\nreturn 1;\r\n__error:\r\nsnd_i2c_unlock(pt->i2c_bus);\r\nsnd_printk(KERN_ERR "PT2258 access failed 2\n");\r\nreturn -EIO;\r\n}\r\nint snd_pt2258_build_controls(struct snd_pt2258 *pt)\r\n{\r\nstruct snd_kcontrol_new knew;\r\nchar *names[3] = {\r\n"Mic Loopback Playback Volume",\r\n"Line Loopback Playback Volume",\r\n"CD Loopback Playback Volume"\r\n};\r\nint i, err;\r\nfor (i = 0; i < 3; ++i) {\r\nmemset(&knew, 0, sizeof(knew));\r\nknew.name = names[i];\r\nknew.iface = SNDRV_CTL_ELEM_IFACE_MIXER;\r\nknew.count = 1;\r\nknew.access = SNDRV_CTL_ELEM_ACCESS_READWRITE |\r\nSNDRV_CTL_ELEM_ACCESS_TLV_READ;\r\nknew.private_value = 2 * i;\r\nknew.info = pt2258_stereo_volume_info;\r\nknew.get = pt2258_stereo_volume_get;\r\nknew.put = pt2258_stereo_volume_put;\r\nknew.tlv.p = pt2258_db_scale;\r\nerr = snd_ctl_add(pt->card, snd_ctl_new1(&knew, pt));\r\nif (err < 0)\r\nreturn err;\r\n}\r\nmemset(&knew, 0, sizeof(knew));\r\nknew.name = "Loopback Switch";\r\nknew.iface = SNDRV_CTL_ELEM_IFACE_MIXER;\r\nknew.info = pt2258_switch_info;\r\nknew.get = pt2258_switch_get;\r\nknew.put = pt2258_switch_put;\r\nknew.access = 0;\r\nerr = snd_ctl_add(pt->card, snd_ctl_new1(&knew, pt));\r\nif (err < 0)\r\nreturn err;\r\nreturn 0;\r\n}
