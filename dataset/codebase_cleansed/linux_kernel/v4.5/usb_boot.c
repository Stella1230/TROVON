static void array_le32_to_cpu(u32 *arr, int num)\r\n{\r\nint i;\r\nfor (i = 0; i < num; i++, arr++)\r\nle32_to_cpus(arr);\r\n}\r\nstatic int gdm_wibro_send(struct usb_device *usbdev, void *data, int len)\r\n{\r\nint ret;\r\nint actual;\r\nret = usb_bulk_msg(usbdev, usb_sndbulkpipe(usbdev, 1), data, len,\r\n&actual, 1000);\r\nif (ret < 0) {\r\ndev_err(&usbdev->dev, "Error : usb_bulk_msg ( result = %d )\n",\r\nret);\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic int gdm_wibro_recv(struct usb_device *usbdev, void *data, int len)\r\n{\r\nint ret;\r\nint actual;\r\nret = usb_bulk_msg(usbdev, usb_rcvbulkpipe(usbdev, 2), data, len,\r\n&actual, 5000);\r\nif (ret < 0) {\r\ndev_err(&usbdev->dev,\r\n"Error : usb_bulk_msg(recv) ( result = %d )\n", ret);\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic int download_image(struct usb_device *usbdev,\r\nconst struct firmware *firm,\r\nloff_t pos, u32 img_len, u32 magic_num)\r\n{\r\nstruct dn_header h;\r\nint ret = 0;\r\nu32 size;\r\nsize = ALIGN(img_len, DOWNLOAD_SIZE);\r\nh.magic_num = cpu_to_be32(magic_num);\r\nh.file_size = cpu_to_be32(size);\r\nret = gdm_wibro_send(usbdev, &h, sizeof(h));\r\nif (ret < 0)\r\nreturn ret;\r\nwhile (img_len > 0) {\r\nif (img_len > DOWNLOAD_SIZE)\r\nsize = DOWNLOAD_SIZE;\r\nelse\r\nsize = img_len;\r\nmemcpy(tx_buf, firm->data + pos, size);\r\nret = gdm_wibro_send(usbdev, tx_buf, size);\r\nif (ret < 0)\r\nreturn ret;\r\nimg_len -= size;\r\npos += size;\r\n}\r\nreturn ret;\r\n}\r\nint usb_boot(struct usb_device *usbdev, u16 pid)\r\n{\r\nint i, ret = 0;\r\nstruct img_header hdr;\r\nstruct fw_info fw_info;\r\nloff_t pos = 0;\r\nchar *img_name = FW_DIR FW_UIMG;\r\nconst struct firmware *firm;\r\nret = request_firmware(&firm, img_name, &usbdev->dev);\r\nif (ret < 0) {\r\ndev_err(&usbdev->dev,\r\n"requesting firmware %s failed with error %d\n",\r\nimg_name, ret);\r\nreturn ret;\r\n}\r\ntx_buf = kmalloc(DOWNLOAD_SIZE, GFP_KERNEL);\r\nif (!tx_buf) {\r\nrelease_firmware(firm);\r\nreturn -ENOMEM;\r\n}\r\nif (firm->size < sizeof(hdr)) {\r\ndev_err(&usbdev->dev, "Cannot read the image info.\n");\r\nret = -EIO;\r\ngoto out;\r\n}\r\nmemcpy(&hdr, firm->data, sizeof(hdr));\r\narray_le32_to_cpu((u32 *)&hdr, 19);\r\nif (hdr.count > MAX_IMG_CNT) {\r\ndev_err(&usbdev->dev, "Too many images. %d\n", hdr.count);\r\nret = -EINVAL;\r\ngoto out;\r\n}\r\nfor (i = 0; i < hdr.count; i++) {\r\nif (hdr.offset[i] > hdr.len) {\r\ndev_err(&usbdev->dev,\r\n"Invalid offset. Entry = %d Offset = 0x%08x Image length = 0x%08x\n",\r\ni, hdr.offset[i], hdr.len);\r\nret = -EINVAL;\r\ngoto out;\r\n}\r\npos = hdr.offset[i];\r\nif (firm->size < sizeof(fw_info) + pos) {\r\ndev_err(&usbdev->dev, "Cannot read the FW info.\n");\r\nret = -EIO;\r\ngoto out;\r\n}\r\nmemcpy(&fw_info, firm->data + pos, sizeof(fw_info));\r\narray_le32_to_cpu((u32 *)&fw_info, 8);\r\nif ((fw_info.id & 0xffff) != pid)\r\ncontinue;\r\npos = hdr.offset[i] + fw_info.kernel_offset;\r\nif (firm->size < fw_info.kernel_len + pos) {\r\ndev_err(&usbdev->dev, "Kernel FW is too small.\n");\r\ngoto out;\r\n}\r\nret = download_image(usbdev, firm, pos, fw_info.kernel_len,\r\nDN_KERNEL_MAGIC_NUMBER);\r\nif (ret < 0)\r\ngoto out;\r\ndev_info(&usbdev->dev, "GCT: Kernel download success.\n");\r\npos = hdr.offset[i] + fw_info.rootfs_offset;\r\nif (firm->size < fw_info.rootfs_len + pos) {\r\ndev_err(&usbdev->dev, "Filesystem FW is too small.\n");\r\ngoto out;\r\n}\r\nret = download_image(usbdev, firm, pos, fw_info.rootfs_len,\r\nDN_ROOTFS_MAGIC_NUMBER);\r\nif (ret < 0)\r\ngoto out;\r\ndev_info(&usbdev->dev, "GCT: Filesystem download success.\n");\r\nbreak;\r\n}\r\nif (i == hdr.count) {\r\ndev_err(&usbdev->dev, "Firmware for gsk%x is not installed.\n",\r\npid);\r\nret = -EINVAL;\r\n}\r\nout:\r\nrelease_firmware(firm);\r\nkfree(tx_buf);\r\nreturn ret;\r\n}\r\nstatic int em_wait_ack(struct usb_device *usbdev, int send_zlp)\r\n{\r\nint ack;\r\nint ret = -1;\r\nif (send_zlp) {\r\nret = gdm_wibro_send(usbdev, NULL, 0);\r\nif (ret < 0)\r\ngoto out;\r\n}\r\nret = gdm_wibro_recv(usbdev, &ack, sizeof(ack));\r\nif (ret < 0)\r\ngoto out;\r\nout:\r\nreturn ret;\r\n}\r\nstatic int em_download_image(struct usb_device *usbdev, const char *img_name,\r\nchar *type_string)\r\n{\r\nchar *buf = NULL;\r\nloff_t pos = 0;\r\nint ret = 0;\r\nint len;\r\nint img_len;\r\nconst struct firmware *firm;\r\n#if defined(GDM7205_PADDING)\r\nconst int pad_size = GDM7205_PADDING;\r\n#else\r\nconst int pad_size = 0;\r\n#endif\r\nret = request_firmware(&firm, img_name, &usbdev->dev);\r\nif (ret < 0) {\r\ndev_err(&usbdev->dev,\r\n"requesting firmware %s failed with error %d\n",\r\nimg_name, ret);\r\nreturn ret;\r\n}\r\nbuf = kmalloc(DOWNLOAD_CHUCK + pad_size, GFP_KERNEL);\r\nif (!buf) {\r\nrelease_firmware(firm);\r\nreturn -ENOMEM;\r\n}\r\nstrcpy(buf+pad_size, type_string);\r\nret = gdm_wibro_send(usbdev, buf, strlen(type_string)+pad_size);\r\nif (ret < 0)\r\ngoto out;\r\nimg_len = firm->size;\r\nif (img_len <= 0) {\r\nret = -1;\r\ngoto out;\r\n}\r\nwhile (img_len > 0) {\r\nif (img_len > DOWNLOAD_CHUCK)\r\nlen = DOWNLOAD_CHUCK;\r\nelse\r\nlen = img_len;\r\nmemcpy(buf+pad_size, firm->data + pos, len);\r\nret = gdm_wibro_send(usbdev, buf, len+pad_size);\r\nif (ret < 0)\r\ngoto out;\r\nimg_len -= DOWNLOAD_CHUCK;\r\npos += DOWNLOAD_CHUCK;\r\nret = em_wait_ack(usbdev, ((len+pad_size) % 512 == 0));\r\nif (ret < 0)\r\ngoto out;\r\n}\r\nret = em_wait_ack(usbdev, 1);\r\nif (ret < 0)\r\ngoto out;\r\nout:\r\nrelease_firmware(firm);\r\nkfree(buf);\r\nreturn ret;\r\n}\r\nstatic int em_fw_reset(struct usb_device *usbdev)\r\n{\r\nreturn gdm_wibro_send(usbdev, NULL, 0);\r\n}\r\nint usb_emergency(struct usb_device *usbdev)\r\n{\r\nint ret;\r\nconst char *kern_name = FW_DIR FW_KERN;\r\nconst char *fs_name = FW_DIR FW_FS;\r\nret = em_download_image(usbdev, kern_name, KERNEL_TYPE_STRING);\r\nif (ret < 0)\r\nreturn ret;\r\ndev_err(&usbdev->dev, "GCT Emergency: Kernel download success.\n");\r\nret = em_download_image(usbdev, fs_name, FS_TYPE_STRING);\r\nif (ret < 0)\r\nreturn ret;\r\ndev_info(&usbdev->dev, "GCT Emergency: Filesystem download success.\n");\r\nret = em_fw_reset(usbdev);\r\nreturn ret;\r\n}
