static enum fore200e_aal\r\nfore200e_atm2fore_aal(int aal)\r\n{\r\nswitch(aal) {\r\ncase ATM_AAL0: return FORE200E_AAL0;\r\ncase ATM_AAL34: return FORE200E_AAL34;\r\ncase ATM_AAL1:\r\ncase ATM_AAL2:\r\ncase ATM_AAL5: return FORE200E_AAL5;\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic char*\r\nfore200e_irq_itoa(int irq)\r\n{\r\nstatic char str[8];\r\nsprintf(str, "%d", irq);\r\nreturn str;\r\n}\r\nstatic int\r\nfore200e_chunk_alloc(struct fore200e* fore200e, struct chunk* chunk, int size, int alignment, int direction)\r\n{\r\nunsigned long offset = 0;\r\nif (alignment <= sizeof(int))\r\nalignment = 0;\r\nchunk->alloc_size = size + alignment;\r\nchunk->align_size = size;\r\nchunk->direction = direction;\r\nchunk->alloc_addr = kzalloc(chunk->alloc_size, GFP_KERNEL | GFP_DMA);\r\nif (chunk->alloc_addr == NULL)\r\nreturn -ENOMEM;\r\nif (alignment > 0)\r\noffset = FORE200E_ALIGN(chunk->alloc_addr, alignment);\r\nchunk->align_addr = chunk->alloc_addr + offset;\r\nchunk->dma_addr = fore200e->bus->dma_map(fore200e, chunk->align_addr, chunk->align_size, direction);\r\nreturn 0;\r\n}\r\nstatic void\r\nfore200e_chunk_free(struct fore200e* fore200e, struct chunk* chunk)\r\n{\r\nfore200e->bus->dma_unmap(fore200e, chunk->dma_addr, chunk->dma_size, chunk->direction);\r\nkfree(chunk->alloc_addr);\r\n}\r\nstatic void\r\nfore200e_spin(int msecs)\r\n{\r\nunsigned long timeout = jiffies + msecs_to_jiffies(msecs);\r\nwhile (time_before(jiffies, timeout));\r\n}\r\nstatic int\r\nfore200e_poll(struct fore200e* fore200e, volatile u32* addr, u32 val, int msecs)\r\n{\r\nunsigned long timeout = jiffies + msecs_to_jiffies(msecs);\r\nint ok;\r\nmb();\r\ndo {\r\nif ((ok = (*addr == val)) || (*addr & STATUS_ERROR))\r\nbreak;\r\n} while (time_before(jiffies, timeout));\r\n#if 1\r\nif (!ok) {\r\nprintk(FORE200E "cmd polling failed, got status 0x%08x, expected 0x%08x\n",\r\n*addr, val);\r\n}\r\n#endif\r\nreturn ok;\r\n}\r\nstatic int\r\nfore200e_io_poll(struct fore200e* fore200e, volatile u32 __iomem *addr, u32 val, int msecs)\r\n{\r\nunsigned long timeout = jiffies + msecs_to_jiffies(msecs);\r\nint ok;\r\ndo {\r\nif ((ok = (fore200e->bus->read(addr) == val)))\r\nbreak;\r\n} while (time_before(jiffies, timeout));\r\n#if 1\r\nif (!ok) {\r\nprintk(FORE200E "I/O polling failed, got status 0x%08x, expected 0x%08x\n",\r\nfore200e->bus->read(addr), val);\r\n}\r\n#endif\r\nreturn ok;\r\n}\r\nstatic void\r\nfore200e_free_rx_buf(struct fore200e* fore200e)\r\n{\r\nint scheme, magn, nbr;\r\nstruct buffer* buffer;\r\nfor (scheme = 0; scheme < BUFFER_SCHEME_NBR; scheme++) {\r\nfor (magn = 0; magn < BUFFER_MAGN_NBR; magn++) {\r\nif ((buffer = fore200e->host_bsq[ scheme ][ magn ].buffer) != NULL) {\r\nfor (nbr = 0; nbr < fore200e_rx_buf_nbr[ scheme ][ magn ]; nbr++) {\r\nstruct chunk* data = &buffer[ nbr ].data;\r\nif (data->alloc_addr != NULL)\r\nfore200e_chunk_free(fore200e, data);\r\n}\r\n}\r\n}\r\n}\r\n}\r\nstatic void\r\nfore200e_uninit_bs_queue(struct fore200e* fore200e)\r\n{\r\nint scheme, magn;\r\nfor (scheme = 0; scheme < BUFFER_SCHEME_NBR; scheme++) {\r\nfor (magn = 0; magn < BUFFER_MAGN_NBR; magn++) {\r\nstruct chunk* status = &fore200e->host_bsq[ scheme ][ magn ].status;\r\nstruct chunk* rbd_block = &fore200e->host_bsq[ scheme ][ magn ].rbd_block;\r\nif (status->alloc_addr)\r\nfore200e->bus->dma_chunk_free(fore200e, status);\r\nif (rbd_block->alloc_addr)\r\nfore200e->bus->dma_chunk_free(fore200e, rbd_block);\r\n}\r\n}\r\n}\r\nstatic int\r\nfore200e_reset(struct fore200e* fore200e, int diag)\r\n{\r\nint ok;\r\nfore200e->cp_monitor = fore200e->virt_base + FORE200E_CP_MONITOR_OFFSET;\r\nfore200e->bus->write(BSTAT_COLD_START, &fore200e->cp_monitor->bstat);\r\nfore200e->bus->reset(fore200e);\r\nif (diag) {\r\nok = fore200e_io_poll(fore200e, &fore200e->cp_monitor->bstat, BSTAT_SELFTEST_OK, 1000);\r\nif (ok == 0) {\r\nprintk(FORE200E "device %s self-test failed\n", fore200e->name);\r\nreturn -ENODEV;\r\n}\r\nprintk(FORE200E "device %s self-test passed\n", fore200e->name);\r\nfore200e->state = FORE200E_STATE_RESET;\r\n}\r\nreturn 0;\r\n}\r\nstatic void\r\nfore200e_shutdown(struct fore200e* fore200e)\r\n{\r\nprintk(FORE200E "removing device %s at 0x%lx, IRQ %s\n",\r\nfore200e->name, fore200e->phys_base,\r\nfore200e_irq_itoa(fore200e->irq));\r\nif (fore200e->state > FORE200E_STATE_RESET) {\r\nfore200e_reset(fore200e, 0);\r\n}\r\nswitch(fore200e->state) {\r\ncase FORE200E_STATE_COMPLETE:\r\nkfree(fore200e->stats);\r\ncase FORE200E_STATE_IRQ:\r\nfree_irq(fore200e->irq, fore200e->atm_dev);\r\ncase FORE200E_STATE_ALLOC_BUF:\r\nfore200e_free_rx_buf(fore200e);\r\ncase FORE200E_STATE_INIT_BSQ:\r\nfore200e_uninit_bs_queue(fore200e);\r\ncase FORE200E_STATE_INIT_RXQ:\r\nfore200e->bus->dma_chunk_free(fore200e, &fore200e->host_rxq.status);\r\nfore200e->bus->dma_chunk_free(fore200e, &fore200e->host_rxq.rpd);\r\ncase FORE200E_STATE_INIT_TXQ:\r\nfore200e->bus->dma_chunk_free(fore200e, &fore200e->host_txq.status);\r\nfore200e->bus->dma_chunk_free(fore200e, &fore200e->host_txq.tpd);\r\ncase FORE200E_STATE_INIT_CMDQ:\r\nfore200e->bus->dma_chunk_free(fore200e, &fore200e->host_cmdq.status);\r\ncase FORE200E_STATE_INITIALIZE:\r\ncase FORE200E_STATE_START_FW:\r\ncase FORE200E_STATE_RESET:\r\ncase FORE200E_STATE_MAP:\r\nfore200e->bus->unmap(fore200e);\r\ncase FORE200E_STATE_CONFIGURE:\r\ncase FORE200E_STATE_REGISTER:\r\natm_dev_deregister(fore200e->atm_dev);\r\ncase FORE200E_STATE_BLANK:\r\nbreak;\r\n}\r\n}\r\nstatic u32 fore200e_pca_read(volatile u32 __iomem *addr)\r\n{\r\nreturn le32_to_cpu(readl(addr));\r\n}\r\nstatic void fore200e_pca_write(u32 val, volatile u32 __iomem *addr)\r\n{\r\nwritel(cpu_to_le32(val), addr);\r\n}\r\nstatic u32\r\nfore200e_pca_dma_map(struct fore200e* fore200e, void* virt_addr, int size, int direction)\r\n{\r\nu32 dma_addr = dma_map_single(&((struct pci_dev *) fore200e->bus_dev)->dev, virt_addr, size, direction);\r\nDPRINTK(3, "PCI DVMA mapping: virt_addr = 0x%p, size = %d, direction = %d, --> dma_addr = 0x%08x\n",\r\nvirt_addr, size, direction, dma_addr);\r\nreturn dma_addr;\r\n}\r\nstatic void\r\nfore200e_pca_dma_unmap(struct fore200e* fore200e, u32 dma_addr, int size, int direction)\r\n{\r\nDPRINTK(3, "PCI DVMA unmapping: dma_addr = 0x%08x, size = %d, direction = %d\n",\r\ndma_addr, size, direction);\r\ndma_unmap_single(&((struct pci_dev *) fore200e->bus_dev)->dev, dma_addr, size, direction);\r\n}\r\nstatic void\r\nfore200e_pca_dma_sync_for_cpu(struct fore200e* fore200e, u32 dma_addr, int size, int direction)\r\n{\r\nDPRINTK(3, "PCI DVMA sync: dma_addr = 0x%08x, size = %d, direction = %d\n", dma_addr, size, direction);\r\ndma_sync_single_for_cpu(&((struct pci_dev *) fore200e->bus_dev)->dev, dma_addr, size, direction);\r\n}\r\nstatic void\r\nfore200e_pca_dma_sync_for_device(struct fore200e* fore200e, u32 dma_addr, int size, int direction)\r\n{\r\nDPRINTK(3, "PCI DVMA sync: dma_addr = 0x%08x, size = %d, direction = %d\n", dma_addr, size, direction);\r\ndma_sync_single_for_device(&((struct pci_dev *) fore200e->bus_dev)->dev, dma_addr, size, direction);\r\n}\r\nstatic int\r\nfore200e_pca_dma_chunk_alloc(struct fore200e* fore200e, struct chunk* chunk,\r\nint size, int nbr, int alignment)\r\n{\r\nchunk->alloc_size = size * nbr;\r\nchunk->alloc_addr = dma_alloc_coherent(&((struct pci_dev *) fore200e->bus_dev)->dev,\r\nchunk->alloc_size,\r\n&chunk->dma_addr,\r\nGFP_KERNEL);\r\nif ((chunk->alloc_addr == NULL) || (chunk->dma_addr == 0))\r\nreturn -ENOMEM;\r\nchunk->align_addr = chunk->alloc_addr;\r\nreturn 0;\r\n}\r\nstatic void\r\nfore200e_pca_dma_chunk_free(struct fore200e* fore200e, struct chunk* chunk)\r\n{\r\ndma_free_coherent(&((struct pci_dev *) fore200e->bus_dev)->dev,\r\nchunk->alloc_size,\r\nchunk->alloc_addr,\r\nchunk->dma_addr);\r\n}\r\nstatic int\r\nfore200e_pca_irq_check(struct fore200e* fore200e)\r\n{\r\nint irq_posted = readl(fore200e->regs.pca.psr);\r\n#if defined(CONFIG_ATM_FORE200E_DEBUG) && (CONFIG_ATM_FORE200E_DEBUG == 2)\r\nif (irq_posted && (readl(fore200e->regs.pca.hcr) & PCA200E_HCR_OUTFULL)) {\r\nDPRINTK(2,"FIFO OUT full, device %d\n", fore200e->atm_dev->number);\r\n}\r\n#endif\r\nreturn irq_posted;\r\n}\r\nstatic void\r\nfore200e_pca_irq_ack(struct fore200e* fore200e)\r\n{\r\nwritel(PCA200E_HCR_CLRINTR, fore200e->regs.pca.hcr);\r\n}\r\nstatic void\r\nfore200e_pca_reset(struct fore200e* fore200e)\r\n{\r\nwritel(PCA200E_HCR_RESET, fore200e->regs.pca.hcr);\r\nfore200e_spin(10);\r\nwritel(0, fore200e->regs.pca.hcr);\r\n}\r\nstatic int fore200e_pca_map(struct fore200e* fore200e)\r\n{\r\nDPRINTK(2, "device %s being mapped in memory\n", fore200e->name);\r\nfore200e->virt_base = ioremap(fore200e->phys_base, PCA200E_IOSPACE_LENGTH);\r\nif (fore200e->virt_base == NULL) {\r\nprintk(FORE200E "can't map device %s\n", fore200e->name);\r\nreturn -EFAULT;\r\n}\r\nDPRINTK(1, "device %s mapped to 0x%p\n", fore200e->name, fore200e->virt_base);\r\nfore200e->regs.pca.hcr = fore200e->virt_base + PCA200E_HCR_OFFSET;\r\nfore200e->regs.pca.imr = fore200e->virt_base + PCA200E_IMR_OFFSET;\r\nfore200e->regs.pca.psr = fore200e->virt_base + PCA200E_PSR_OFFSET;\r\nfore200e->state = FORE200E_STATE_MAP;\r\nreturn 0;\r\n}\r\nstatic void\r\nfore200e_pca_unmap(struct fore200e* fore200e)\r\n{\r\nDPRINTK(2, "device %s being unmapped from memory\n", fore200e->name);\r\nif (fore200e->virt_base != NULL)\r\niounmap(fore200e->virt_base);\r\n}\r\nstatic int fore200e_pca_configure(struct fore200e *fore200e)\r\n{\r\nstruct pci_dev* pci_dev = (struct pci_dev*)fore200e->bus_dev;\r\nu8 master_ctrl, latency;\r\nDPRINTK(2, "device %s being configured\n", fore200e->name);\r\nif ((pci_dev->irq == 0) || (pci_dev->irq == 0xFF)) {\r\nprintk(FORE200E "incorrect IRQ setting - misconfigured PCI-PCI bridge?\n");\r\nreturn -EIO;\r\n}\r\npci_read_config_byte(pci_dev, PCA200E_PCI_MASTER_CTRL, &master_ctrl);\r\nmaster_ctrl = master_ctrl\r\n#if defined(__BIG_ENDIAN)\r\n| PCA200E_CTRL_CONVERT_ENDIAN\r\n#endif\r\n#if 0\r\n| PCA200E_CTRL_DIS_CACHE_RD\r\n| PCA200E_CTRL_DIS_WRT_INVAL\r\n| PCA200E_CTRL_ENA_CONT_REQ_MODE\r\n| PCA200E_CTRL_2_CACHE_WRT_INVAL\r\n#endif\r\n| PCA200E_CTRL_LARGE_PCI_BURSTS;\r\npci_write_config_byte(pci_dev, PCA200E_PCI_MASTER_CTRL, master_ctrl);\r\nlatency = 192;\r\npci_write_config_byte(pci_dev, PCI_LATENCY_TIMER, latency);\r\nfore200e->state = FORE200E_STATE_CONFIGURE;\r\nreturn 0;\r\n}\r\nstatic int __init\r\nfore200e_pca_prom_read(struct fore200e* fore200e, struct prom_data* prom)\r\n{\r\nstruct host_cmdq* cmdq = &fore200e->host_cmdq;\r\nstruct host_cmdq_entry* entry = &cmdq->host_entry[ cmdq->head ];\r\nstruct prom_opcode opcode;\r\nint ok;\r\nu32 prom_dma;\r\nFORE200E_NEXT_ENTRY(cmdq->head, QUEUE_SIZE_CMD);\r\nopcode.opcode = OPCODE_GET_PROM;\r\nopcode.pad = 0;\r\nprom_dma = fore200e->bus->dma_map(fore200e, prom, sizeof(struct prom_data), DMA_FROM_DEVICE);\r\nfore200e->bus->write(prom_dma, &entry->cp_entry->cmd.prom_block.prom_haddr);\r\n*entry->status = STATUS_PENDING;\r\nfore200e->bus->write(*(u32*)&opcode, (u32 __iomem *)&entry->cp_entry->cmd.prom_block.opcode);\r\nok = fore200e_poll(fore200e, entry->status, STATUS_COMPLETE, 400);\r\n*entry->status = STATUS_FREE;\r\nfore200e->bus->dma_unmap(fore200e, prom_dma, sizeof(struct prom_data), DMA_FROM_DEVICE);\r\nif (ok == 0) {\r\nprintk(FORE200E "unable to get PROM data from device %s\n", fore200e->name);\r\nreturn -EIO;\r\n}\r\n#if defined(__BIG_ENDIAN)\r\n#define swap_here(addr) (*((u32*)(addr)) = swab32( *((u32*)(addr)) ))\r\nswap_here(&prom->mac_addr[0]);\r\nswap_here(&prom->mac_addr[4]);\r\n#endif\r\nreturn 0;\r\n}\r\nstatic int\r\nfore200e_pca_proc_read(struct fore200e* fore200e, char *page)\r\n{\r\nstruct pci_dev* pci_dev = (struct pci_dev*)fore200e->bus_dev;\r\nreturn sprintf(page, " PCI bus/slot/function:\t%d/%d/%d\n",\r\npci_dev->bus->number, PCI_SLOT(pci_dev->devfn), PCI_FUNC(pci_dev->devfn));\r\n}\r\nstatic u32 fore200e_sba_read(volatile u32 __iomem *addr)\r\n{\r\nreturn sbus_readl(addr);\r\n}\r\nstatic void fore200e_sba_write(u32 val, volatile u32 __iomem *addr)\r\n{\r\nsbus_writel(val, addr);\r\n}\r\nstatic u32 fore200e_sba_dma_map(struct fore200e *fore200e, void* virt_addr, int size, int direction)\r\n{\r\nstruct platform_device *op = fore200e->bus_dev;\r\nu32 dma_addr;\r\ndma_addr = dma_map_single(&op->dev, virt_addr, size, direction);\r\nDPRINTK(3, "SBUS DVMA mapping: virt_addr = 0x%p, size = %d, direction = %d --> dma_addr = 0x%08x\n",\r\nvirt_addr, size, direction, dma_addr);\r\nreturn dma_addr;\r\n}\r\nstatic void fore200e_sba_dma_unmap(struct fore200e *fore200e, u32 dma_addr, int size, int direction)\r\n{\r\nstruct platform_device *op = fore200e->bus_dev;\r\nDPRINTK(3, "SBUS DVMA unmapping: dma_addr = 0x%08x, size = %d, direction = %d,\n",\r\ndma_addr, size, direction);\r\ndma_unmap_single(&op->dev, dma_addr, size, direction);\r\n}\r\nstatic void fore200e_sba_dma_sync_for_cpu(struct fore200e *fore200e, u32 dma_addr, int size, int direction)\r\n{\r\nstruct platform_device *op = fore200e->bus_dev;\r\nDPRINTK(3, "SBUS DVMA sync: dma_addr = 0x%08x, size = %d, direction = %d\n", dma_addr, size, direction);\r\ndma_sync_single_for_cpu(&op->dev, dma_addr, size, direction);\r\n}\r\nstatic void fore200e_sba_dma_sync_for_device(struct fore200e *fore200e, u32 dma_addr, int size, int direction)\r\n{\r\nstruct platform_device *op = fore200e->bus_dev;\r\nDPRINTK(3, "SBUS DVMA sync: dma_addr = 0x%08x, size = %d, direction = %d\n", dma_addr, size, direction);\r\ndma_sync_single_for_device(&op->dev, dma_addr, size, direction);\r\n}\r\nstatic int fore200e_sba_dma_chunk_alloc(struct fore200e *fore200e, struct chunk *chunk,\r\nint size, int nbr, int alignment)\r\n{\r\nstruct platform_device *op = fore200e->bus_dev;\r\nchunk->alloc_size = chunk->align_size = size * nbr;\r\nchunk->alloc_addr = dma_alloc_coherent(&op->dev, chunk->alloc_size,\r\n&chunk->dma_addr, GFP_ATOMIC);\r\nif ((chunk->alloc_addr == NULL) || (chunk->dma_addr == 0))\r\nreturn -ENOMEM;\r\nchunk->align_addr = chunk->alloc_addr;\r\nreturn 0;\r\n}\r\nstatic void fore200e_sba_dma_chunk_free(struct fore200e *fore200e, struct chunk *chunk)\r\n{\r\nstruct platform_device *op = fore200e->bus_dev;\r\ndma_free_coherent(&op->dev, chunk->alloc_size,\r\nchunk->alloc_addr, chunk->dma_addr);\r\n}\r\nstatic void fore200e_sba_irq_enable(struct fore200e *fore200e)\r\n{\r\nu32 hcr = fore200e->bus->read(fore200e->regs.sba.hcr) & SBA200E_HCR_STICKY;\r\nfore200e->bus->write(hcr | SBA200E_HCR_INTR_ENA, fore200e->regs.sba.hcr);\r\n}\r\nstatic int fore200e_sba_irq_check(struct fore200e *fore200e)\r\n{\r\nreturn fore200e->bus->read(fore200e->regs.sba.hcr) & SBA200E_HCR_INTR_REQ;\r\n}\r\nstatic void fore200e_sba_irq_ack(struct fore200e *fore200e)\r\n{\r\nu32 hcr = fore200e->bus->read(fore200e->regs.sba.hcr) & SBA200E_HCR_STICKY;\r\nfore200e->bus->write(hcr | SBA200E_HCR_INTR_CLR, fore200e->regs.sba.hcr);\r\n}\r\nstatic void fore200e_sba_reset(struct fore200e *fore200e)\r\n{\r\nfore200e->bus->write(SBA200E_HCR_RESET, fore200e->regs.sba.hcr);\r\nfore200e_spin(10);\r\nfore200e->bus->write(0, fore200e->regs.sba.hcr);\r\n}\r\nstatic int __init fore200e_sba_map(struct fore200e *fore200e)\r\n{\r\nstruct platform_device *op = fore200e->bus_dev;\r\nunsigned int bursts;\r\nfore200e->regs.sba.hcr = of_ioremap(&op->resource[0], 0, SBA200E_HCR_LENGTH, "SBA HCR");\r\nfore200e->regs.sba.bsr = of_ioremap(&op->resource[1], 0, SBA200E_BSR_LENGTH, "SBA BSR");\r\nfore200e->regs.sba.isr = of_ioremap(&op->resource[2], 0, SBA200E_ISR_LENGTH, "SBA ISR");\r\nfore200e->virt_base = of_ioremap(&op->resource[3], 0, SBA200E_RAM_LENGTH, "SBA RAM");\r\nif (!fore200e->virt_base) {\r\nprintk(FORE200E "unable to map RAM of device %s\n", fore200e->name);\r\nreturn -EFAULT;\r\n}\r\nDPRINTK(1, "device %s mapped to 0x%p\n", fore200e->name, fore200e->virt_base);\r\nfore200e->bus->write(0x02, fore200e->regs.sba.isr);\r\nbursts = of_getintprop_default(op->dev.of_node->parent, "burst-sizes", 0x00);\r\nif (sbus_can_dma_64bit())\r\nsbus_set_sbus64(&op->dev, bursts);\r\nfore200e->state = FORE200E_STATE_MAP;\r\nreturn 0;\r\n}\r\nstatic void fore200e_sba_unmap(struct fore200e *fore200e)\r\n{\r\nstruct platform_device *op = fore200e->bus_dev;\r\nof_iounmap(&op->resource[0], fore200e->regs.sba.hcr, SBA200E_HCR_LENGTH);\r\nof_iounmap(&op->resource[1], fore200e->regs.sba.bsr, SBA200E_BSR_LENGTH);\r\nof_iounmap(&op->resource[2], fore200e->regs.sba.isr, SBA200E_ISR_LENGTH);\r\nof_iounmap(&op->resource[3], fore200e->virt_base, SBA200E_RAM_LENGTH);\r\n}\r\nstatic int __init fore200e_sba_configure(struct fore200e *fore200e)\r\n{\r\nfore200e->state = FORE200E_STATE_CONFIGURE;\r\nreturn 0;\r\n}\r\nstatic int __init fore200e_sba_prom_read(struct fore200e *fore200e, struct prom_data *prom)\r\n{\r\nstruct platform_device *op = fore200e->bus_dev;\r\nconst u8 *prop;\r\nint len;\r\nprop = of_get_property(op->dev.of_node, "madaddrlo2", &len);\r\nif (!prop)\r\nreturn -ENODEV;\r\nmemcpy(&prom->mac_addr[4], prop, 4);\r\nprop = of_get_property(op->dev.of_node, "madaddrhi4", &len);\r\nif (!prop)\r\nreturn -ENODEV;\r\nmemcpy(&prom->mac_addr[2], prop, 4);\r\nprom->serial_number = of_getintprop_default(op->dev.of_node,\r\n"serialnumber", 0);\r\nprom->hw_revision = of_getintprop_default(op->dev.of_node,\r\n"promversion", 0);\r\nreturn 0;\r\n}\r\nstatic int fore200e_sba_proc_read(struct fore200e *fore200e, char *page)\r\n{\r\nstruct platform_device *op = fore200e->bus_dev;\r\nconst struct linux_prom_registers *regs;\r\nregs = of_get_property(op->dev.of_node, "reg", NULL);\r\nreturn sprintf(page, " SBUS slot/device:\t\t%d/'%s'\n",\r\n(regs ? regs->which_io : 0), op->dev.of_node->name);\r\n}\r\nstatic void\r\nfore200e_tx_irq(struct fore200e* fore200e)\r\n{\r\nstruct host_txq* txq = &fore200e->host_txq;\r\nstruct host_txq_entry* entry;\r\nstruct atm_vcc* vcc;\r\nstruct fore200e_vc_map* vc_map;\r\nif (fore200e->host_txq.txing == 0)\r\nreturn;\r\nfor (;;) {\r\nentry = &txq->host_entry[ txq->tail ];\r\nif ((*entry->status & STATUS_COMPLETE) == 0) {\r\nbreak;\r\n}\r\nDPRINTK(3, "TX COMPLETED: entry = %p [tail = %d], vc_map = %p, skb = %p\n",\r\nentry, txq->tail, entry->vc_map, entry->skb);\r\nkfree(entry->data);\r\nfore200e->bus->dma_unmap(fore200e, entry->tpd->tsd[ 0 ].buffer, entry->tpd->tsd[ 0 ].length,\r\nDMA_TO_DEVICE);\r\nvc_map = entry->vc_map;\r\nif ((vc_map->vcc == NULL) ||\r\n(test_bit(ATM_VF_READY, &vc_map->vcc->flags) == 0)) {\r\nDPRINTK(1, "no ready vcc found for PDU sent on device %d\n",\r\nfore200e->atm_dev->number);\r\ndev_kfree_skb_any(entry->skb);\r\n}\r\nelse {\r\nASSERT(vc_map->vcc);\r\nif (vc_map->incarn != entry->incarn) {\r\nDPRINTK(1, "vcc closed-then-re-opened; dropping PDU sent on device %d\n",\r\nfore200e->atm_dev->number);\r\ndev_kfree_skb_any(entry->skb);\r\n}\r\nelse {\r\nvcc = vc_map->vcc;\r\nASSERT(vcc);\r\nif (vcc->pop) {\r\nvcc->pop(vcc, entry->skb);\r\n}\r\nelse {\r\ndev_kfree_skb_any(entry->skb);\r\n}\r\n#if 1\r\nif (atomic_read(&sk_atm(vcc)->sk_wmem_alloc) < 0) {\r\natomic_set(&sk_atm(vcc)->sk_wmem_alloc, 0);\r\n}\r\n#endif\r\nif (*entry->status & STATUS_ERROR)\r\natomic_inc(&vcc->stats->tx_err);\r\nelse\r\natomic_inc(&vcc->stats->tx);\r\n}\r\n}\r\n*entry->status = STATUS_FREE;\r\nfore200e->host_txq.txing--;\r\nFORE200E_NEXT_ENTRY(txq->tail, QUEUE_SIZE_TX);\r\n}\r\n}\r\nint bsq_audit(int where, struct host_bsq* bsq, int scheme, int magn)\r\n{\r\nstruct buffer* buffer;\r\nint count = 0;\r\nbuffer = bsq->freebuf;\r\nwhile (buffer) {\r\nif (buffer->supplied) {\r\nprintk(FORE200E "bsq_audit(%d): queue %d.%d, buffer %ld supplied but in free list!\n",\r\nwhere, scheme, magn, buffer->index);\r\n}\r\nif (buffer->magn != magn) {\r\nprintk(FORE200E "bsq_audit(%d): queue %d.%d, buffer %ld, unexpected magn = %d\n",\r\nwhere, scheme, magn, buffer->index, buffer->magn);\r\n}\r\nif (buffer->scheme != scheme) {\r\nprintk(FORE200E "bsq_audit(%d): queue %d.%d, buffer %ld, unexpected scheme = %d\n",\r\nwhere, scheme, magn, buffer->index, buffer->scheme);\r\n}\r\nif ((buffer->index < 0) || (buffer->index >= fore200e_rx_buf_nbr[ scheme ][ magn ])) {\r\nprintk(FORE200E "bsq_audit(%d): queue %d.%d, out of range buffer index = %ld !\n",\r\nwhere, scheme, magn, buffer->index);\r\n}\r\ncount++;\r\nbuffer = buffer->next;\r\n}\r\nif (count != bsq->freebuf_count) {\r\nprintk(FORE200E "bsq_audit(%d): queue %d.%d, %d bufs in free list, but freebuf_count = %d\n",\r\nwhere, scheme, magn, count, bsq->freebuf_count);\r\n}\r\nreturn 0;\r\n}\r\nstatic void\r\nfore200e_supply(struct fore200e* fore200e)\r\n{\r\nint scheme, magn, i;\r\nstruct host_bsq* bsq;\r\nstruct host_bsq_entry* entry;\r\nstruct buffer* buffer;\r\nfor (scheme = 0; scheme < BUFFER_SCHEME_NBR; scheme++) {\r\nfor (magn = 0; magn < BUFFER_MAGN_NBR; magn++) {\r\nbsq = &fore200e->host_bsq[ scheme ][ magn ];\r\n#ifdef FORE200E_BSQ_DEBUG\r\nbsq_audit(1, bsq, scheme, magn);\r\n#endif\r\nwhile (bsq->freebuf_count >= RBD_BLK_SIZE) {\r\nDPRINTK(2, "supplying %d rx buffers to queue %d / %d, freebuf_count = %d\n",\r\nRBD_BLK_SIZE, scheme, magn, bsq->freebuf_count);\r\nentry = &bsq->host_entry[ bsq->head ];\r\nfor (i = 0; i < RBD_BLK_SIZE; i++) {\r\nbuffer = bsq->freebuf;\r\nif (!buffer) {\r\nprintk(FORE200E "no more free bufs in queue %d.%d, but freebuf_count = %d\n",\r\nscheme, magn, bsq->freebuf_count);\r\nreturn;\r\n}\r\nbsq->freebuf = buffer->next;\r\n#ifdef FORE200E_BSQ_DEBUG\r\nif (buffer->supplied)\r\nprintk(FORE200E "queue %d.%d, buffer %lu already supplied\n",\r\nscheme, magn, buffer->index);\r\nbuffer->supplied = 1;\r\n#endif\r\nentry->rbd_block->rbd[ i ].buffer_haddr = buffer->data.dma_addr;\r\nentry->rbd_block->rbd[ i ].handle = FORE200E_BUF2HDL(buffer);\r\n}\r\nFORE200E_NEXT_ENTRY(bsq->head, QUEUE_SIZE_BS);\r\nbsq->freebuf_count -= RBD_BLK_SIZE;\r\n*entry->status = STATUS_PENDING;\r\nfore200e->bus->write(entry->rbd_block_dma, &entry->cp_entry->rbd_block_haddr);\r\n}\r\n}\r\n}\r\n}\r\nstatic int\r\nfore200e_push_rpd(struct fore200e* fore200e, struct atm_vcc* vcc, struct rpd* rpd)\r\n{\r\nstruct sk_buff* skb;\r\nstruct buffer* buffer;\r\nstruct fore200e_vcc* fore200e_vcc;\r\nint i, pdu_len = 0;\r\n#ifdef FORE200E_52BYTE_AAL0_SDU\r\nu32 cell_header = 0;\r\n#endif\r\nASSERT(vcc);\r\nfore200e_vcc = FORE200E_VCC(vcc);\r\nASSERT(fore200e_vcc);\r\n#ifdef FORE200E_52BYTE_AAL0_SDU\r\nif ((vcc->qos.aal == ATM_AAL0) && (vcc->qos.rxtp.max_sdu == ATM_AAL0_SDU)) {\r\ncell_header = (rpd->atm_header.gfc << ATM_HDR_GFC_SHIFT) |\r\n(rpd->atm_header.vpi << ATM_HDR_VPI_SHIFT) |\r\n(rpd->atm_header.vci << ATM_HDR_VCI_SHIFT) |\r\n(rpd->atm_header.plt << ATM_HDR_PTI_SHIFT) |\r\nrpd->atm_header.clp;\r\npdu_len = 4;\r\n}\r\n#endif\r\nfor (i = 0; i < rpd->nseg; i++)\r\npdu_len += rpd->rsd[ i ].length;\r\nskb = alloc_skb(pdu_len, GFP_ATOMIC);\r\nif (skb == NULL) {\r\nDPRINTK(2, "unable to alloc new skb, rx PDU length = %d\n", pdu_len);\r\natomic_inc(&vcc->stats->rx_drop);\r\nreturn -ENOMEM;\r\n}\r\n__net_timestamp(skb);\r\n#ifdef FORE200E_52BYTE_AAL0_SDU\r\nif (cell_header) {\r\n*((u32*)skb_put(skb, 4)) = cell_header;\r\n}\r\n#endif\r\nfor (i = 0; i < rpd->nseg; i++) {\r\nbuffer = FORE200E_HDL2BUF(rpd->rsd[ i ].handle);\r\nfore200e->bus->dma_sync_for_cpu(fore200e, buffer->data.dma_addr, rpd->rsd[ i ].length, DMA_FROM_DEVICE);\r\nmemcpy(skb_put(skb, rpd->rsd[ i ].length), buffer->data.align_addr, rpd->rsd[ i ].length);\r\nfore200e->bus->dma_sync_for_device(fore200e, buffer->data.dma_addr, rpd->rsd[ i ].length, DMA_FROM_DEVICE);\r\n}\r\nDPRINTK(3, "rx skb: len = %d, truesize = %d\n", skb->len, skb->truesize);\r\nif (pdu_len < fore200e_vcc->rx_min_pdu)\r\nfore200e_vcc->rx_min_pdu = pdu_len;\r\nif (pdu_len > fore200e_vcc->rx_max_pdu)\r\nfore200e_vcc->rx_max_pdu = pdu_len;\r\nfore200e_vcc->rx_pdu++;\r\nif (atm_charge(vcc, skb->truesize) == 0) {\r\nDPRINTK(2, "receive buffers saturated for %d.%d.%d - PDU dropped\n",\r\nvcc->itf, vcc->vpi, vcc->vci);\r\ndev_kfree_skb_any(skb);\r\natomic_inc(&vcc->stats->rx_drop);\r\nreturn -ENOMEM;\r\n}\r\nASSERT(atomic_read(&sk_atm(vcc)->sk_wmem_alloc) >= 0);\r\nvcc->push(vcc, skb);\r\natomic_inc(&vcc->stats->rx);\r\nASSERT(atomic_read(&sk_atm(vcc)->sk_wmem_alloc) >= 0);\r\nreturn 0;\r\n}\r\nstatic void\r\nfore200e_collect_rpd(struct fore200e* fore200e, struct rpd* rpd)\r\n{\r\nstruct host_bsq* bsq;\r\nstruct buffer* buffer;\r\nint i;\r\nfor (i = 0; i < rpd->nseg; i++) {\r\nbuffer = FORE200E_HDL2BUF(rpd->rsd[ i ].handle);\r\nbsq = &fore200e->host_bsq[ buffer->scheme ][ buffer->magn ];\r\n#ifdef FORE200E_BSQ_DEBUG\r\nbsq_audit(2, bsq, buffer->scheme, buffer->magn);\r\nif (buffer->supplied == 0)\r\nprintk(FORE200E "queue %d.%d, buffer %ld was not supplied\n",\r\nbuffer->scheme, buffer->magn, buffer->index);\r\nbuffer->supplied = 0;\r\n#endif\r\nbuffer->next = bsq->freebuf;\r\nbsq->freebuf = buffer;\r\nbsq->freebuf_count++;\r\n}\r\n}\r\nstatic void\r\nfore200e_rx_irq(struct fore200e* fore200e)\r\n{\r\nstruct host_rxq* rxq = &fore200e->host_rxq;\r\nstruct host_rxq_entry* entry;\r\nstruct atm_vcc* vcc;\r\nstruct fore200e_vc_map* vc_map;\r\nfor (;;) {\r\nentry = &rxq->host_entry[ rxq->head ];\r\nif ((*entry->status & STATUS_COMPLETE) == 0)\r\nbreak;\r\nvc_map = FORE200E_VC_MAP(fore200e, entry->rpd->atm_header.vpi, entry->rpd->atm_header.vci);\r\nif ((vc_map->vcc == NULL) ||\r\n(test_bit(ATM_VF_READY, &vc_map->vcc->flags) == 0)) {\r\nDPRINTK(1, "no ready VC found for PDU received on %d.%d.%d\n",\r\nfore200e->atm_dev->number,\r\nentry->rpd->atm_header.vpi, entry->rpd->atm_header.vci);\r\n}\r\nelse {\r\nvcc = vc_map->vcc;\r\nASSERT(vcc);\r\nif ((*entry->status & STATUS_ERROR) == 0) {\r\nfore200e_push_rpd(fore200e, vcc, entry->rpd);\r\n}\r\nelse {\r\nDPRINTK(2, "damaged PDU on %d.%d.%d\n",\r\nfore200e->atm_dev->number,\r\nentry->rpd->atm_header.vpi, entry->rpd->atm_header.vci);\r\natomic_inc(&vcc->stats->rx_err);\r\n}\r\n}\r\nFORE200E_NEXT_ENTRY(rxq->head, QUEUE_SIZE_RX);\r\nfore200e_collect_rpd(fore200e, entry->rpd);\r\nfore200e->bus->write(entry->rpd_dma, &entry->cp_entry->rpd_haddr);\r\n*entry->status = STATUS_FREE;\r\nfore200e_supply(fore200e);\r\n}\r\n}\r\nstatic void\r\nfore200e_irq(struct fore200e* fore200e)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&fore200e->q_lock, flags);\r\nfore200e_rx_irq(fore200e);\r\nspin_unlock_irqrestore(&fore200e->q_lock, flags);\r\nspin_lock_irqsave(&fore200e->q_lock, flags);\r\nfore200e_tx_irq(fore200e);\r\nspin_unlock_irqrestore(&fore200e->q_lock, flags);\r\n}\r\nstatic irqreturn_t\r\nfore200e_interrupt(int irq, void* dev)\r\n{\r\nstruct fore200e* fore200e = FORE200E_DEV((struct atm_dev*)dev);\r\nif (fore200e->bus->irq_check(fore200e) == 0) {\r\nDPRINTK(3, "interrupt NOT triggered by device %d\n", fore200e->atm_dev->number);\r\nreturn IRQ_NONE;\r\n}\r\nDPRINTK(3, "interrupt triggered by device %d\n", fore200e->atm_dev->number);\r\n#ifdef FORE200E_USE_TASKLET\r\ntasklet_schedule(&fore200e->tx_tasklet);\r\ntasklet_schedule(&fore200e->rx_tasklet);\r\n#else\r\nfore200e_irq(fore200e);\r\n#endif\r\nfore200e->bus->irq_ack(fore200e);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void\r\nfore200e_tx_tasklet(unsigned long data)\r\n{\r\nstruct fore200e* fore200e = (struct fore200e*) data;\r\nunsigned long flags;\r\nDPRINTK(3, "tx tasklet scheduled for device %d\n", fore200e->atm_dev->number);\r\nspin_lock_irqsave(&fore200e->q_lock, flags);\r\nfore200e_tx_irq(fore200e);\r\nspin_unlock_irqrestore(&fore200e->q_lock, flags);\r\n}\r\nstatic void\r\nfore200e_rx_tasklet(unsigned long data)\r\n{\r\nstruct fore200e* fore200e = (struct fore200e*) data;\r\nunsigned long flags;\r\nDPRINTK(3, "rx tasklet scheduled for device %d\n", fore200e->atm_dev->number);\r\nspin_lock_irqsave(&fore200e->q_lock, flags);\r\nfore200e_rx_irq((struct fore200e*) data);\r\nspin_unlock_irqrestore(&fore200e->q_lock, flags);\r\n}\r\nstatic int\r\nfore200e_select_scheme(struct atm_vcc* vcc)\r\n{\r\nint scheme = vcc->vci % 2 ? BUFFER_SCHEME_ONE : BUFFER_SCHEME_TWO;\r\nDPRINTK(1, "VC %d.%d.%d uses buffer scheme %d\n",\r\nvcc->itf, vcc->vpi, vcc->vci, scheme);\r\nreturn scheme;\r\n}\r\nstatic int\r\nfore200e_activate_vcin(struct fore200e* fore200e, int activate, struct atm_vcc* vcc, int mtu)\r\n{\r\nstruct host_cmdq* cmdq = &fore200e->host_cmdq;\r\nstruct host_cmdq_entry* entry = &cmdq->host_entry[ cmdq->head ];\r\nstruct activate_opcode activ_opcode;\r\nstruct deactivate_opcode deactiv_opcode;\r\nstruct vpvc vpvc;\r\nint ok;\r\nenum fore200e_aal aal = fore200e_atm2fore_aal(vcc->qos.aal);\r\nFORE200E_NEXT_ENTRY(cmdq->head, QUEUE_SIZE_CMD);\r\nif (activate) {\r\nFORE200E_VCC(vcc)->scheme = fore200e_select_scheme(vcc);\r\nactiv_opcode.opcode = OPCODE_ACTIVATE_VCIN;\r\nactiv_opcode.aal = aal;\r\nactiv_opcode.scheme = FORE200E_VCC(vcc)->scheme;\r\nactiv_opcode.pad = 0;\r\n}\r\nelse {\r\ndeactiv_opcode.opcode = OPCODE_DEACTIVATE_VCIN;\r\ndeactiv_opcode.pad = 0;\r\n}\r\nvpvc.vci = vcc->vci;\r\nvpvc.vpi = vcc->vpi;\r\n*entry->status = STATUS_PENDING;\r\nif (activate) {\r\n#ifdef FORE200E_52BYTE_AAL0_SDU\r\nmtu = 48;\r\n#endif\r\nfore200e->bus->write(mtu, &entry->cp_entry->cmd.activate_block.mtu);\r\nfore200e->bus->write(*(u32*)&vpvc, (u32 __iomem *)&entry->cp_entry->cmd.activate_block.vpvc);\r\nfore200e->bus->write(*(u32*)&activ_opcode, (u32 __iomem *)&entry->cp_entry->cmd.activate_block.opcode);\r\n}\r\nelse {\r\nfore200e->bus->write(*(u32*)&vpvc, (u32 __iomem *)&entry->cp_entry->cmd.deactivate_block.vpvc);\r\nfore200e->bus->write(*(u32*)&deactiv_opcode, (u32 __iomem *)&entry->cp_entry->cmd.deactivate_block.opcode);\r\n}\r\nok = fore200e_poll(fore200e, entry->status, STATUS_COMPLETE, 400);\r\n*entry->status = STATUS_FREE;\r\nif (ok == 0) {\r\nprintk(FORE200E "unable to %s VC %d.%d.%d\n",\r\nactivate ? "open" : "close", vcc->itf, vcc->vpi, vcc->vci);\r\nreturn -EIO;\r\n}\r\nDPRINTK(1, "VC %d.%d.%d %sed\n", vcc->itf, vcc->vpi, vcc->vci,\r\nactivate ? "open" : "clos");\r\nreturn 0;\r\n}\r\nstatic void\r\nfore200e_rate_ctrl(struct atm_qos* qos, struct tpd_rate* rate)\r\n{\r\nif (qos->txtp.max_pcr < ATM_OC3_PCR) {\r\nrate->data_cells = qos->txtp.max_pcr * FORE200E_MAX_BACK2BACK_CELLS / ATM_OC3_PCR;\r\nrate->idle_cells = FORE200E_MAX_BACK2BACK_CELLS - rate->data_cells;\r\n}\r\nelse {\r\nrate->data_cells = rate->idle_cells = 0;\r\n}\r\n}\r\nstatic int\r\nfore200e_open(struct atm_vcc *vcc)\r\n{\r\nstruct fore200e* fore200e = FORE200E_DEV(vcc->dev);\r\nstruct fore200e_vcc* fore200e_vcc;\r\nstruct fore200e_vc_map* vc_map;\r\nunsigned long flags;\r\nint vci = vcc->vci;\r\nshort vpi = vcc->vpi;\r\nASSERT((vpi >= 0) && (vpi < 1<<FORE200E_VPI_BITS));\r\nASSERT((vci >= 0) && (vci < 1<<FORE200E_VCI_BITS));\r\nspin_lock_irqsave(&fore200e->q_lock, flags);\r\nvc_map = FORE200E_VC_MAP(fore200e, vpi, vci);\r\nif (vc_map->vcc) {\r\nspin_unlock_irqrestore(&fore200e->q_lock, flags);\r\nprintk(FORE200E "VC %d.%d.%d already in use\n",\r\nfore200e->atm_dev->number, vpi, vci);\r\nreturn -EINVAL;\r\n}\r\nvc_map->vcc = vcc;\r\nspin_unlock_irqrestore(&fore200e->q_lock, flags);\r\nfore200e_vcc = kzalloc(sizeof(struct fore200e_vcc), GFP_ATOMIC);\r\nif (fore200e_vcc == NULL) {\r\nvc_map->vcc = NULL;\r\nreturn -ENOMEM;\r\n}\r\nDPRINTK(2, "opening %d.%d.%d:%d QoS = (tx: cl=%s, pcr=%d-%d, cdv=%d, max_sdu=%d; "\r\n"rx: cl=%s, pcr=%d-%d, cdv=%d, max_sdu=%d)\n",\r\nvcc->itf, vcc->vpi, vcc->vci, fore200e_atm2fore_aal(vcc->qos.aal),\r\nfore200e_traffic_class[ vcc->qos.txtp.traffic_class ],\r\nvcc->qos.txtp.min_pcr, vcc->qos.txtp.max_pcr, vcc->qos.txtp.max_cdv, vcc->qos.txtp.max_sdu,\r\nfore200e_traffic_class[ vcc->qos.rxtp.traffic_class ],\r\nvcc->qos.rxtp.min_pcr, vcc->qos.rxtp.max_pcr, vcc->qos.rxtp.max_cdv, vcc->qos.rxtp.max_sdu);\r\nif ((vcc->qos.txtp.traffic_class == ATM_CBR) && (vcc->qos.txtp.max_pcr > 0)) {\r\nmutex_lock(&fore200e->rate_mtx);\r\nif (fore200e->available_cell_rate < vcc->qos.txtp.max_pcr) {\r\nmutex_unlock(&fore200e->rate_mtx);\r\nkfree(fore200e_vcc);\r\nvc_map->vcc = NULL;\r\nreturn -EAGAIN;\r\n}\r\nfore200e->available_cell_rate -= vcc->qos.txtp.max_pcr;\r\nmutex_unlock(&fore200e->rate_mtx);\r\n}\r\nvcc->itf = vcc->dev->number;\r\nset_bit(ATM_VF_PARTIAL,&vcc->flags);\r\nset_bit(ATM_VF_ADDR, &vcc->flags);\r\nvcc->dev_data = fore200e_vcc;\r\nif (fore200e_activate_vcin(fore200e, 1, vcc, vcc->qos.rxtp.max_sdu) < 0) {\r\nvc_map->vcc = NULL;\r\nclear_bit(ATM_VF_ADDR, &vcc->flags);\r\nclear_bit(ATM_VF_PARTIAL,&vcc->flags);\r\nvcc->dev_data = NULL;\r\nfore200e->available_cell_rate += vcc->qos.txtp.max_pcr;\r\nkfree(fore200e_vcc);\r\nreturn -EINVAL;\r\n}\r\nif ((vcc->qos.txtp.traffic_class == ATM_CBR) && (vcc->qos.txtp.max_pcr > 0)) {\r\nfore200e_rate_ctrl(&vcc->qos, &fore200e_vcc->rate);\r\nset_bit(ATM_VF_HASQOS, &vcc->flags);\r\nDPRINTK(3, "tx on %d.%d.%d:%d, tx PCR = %d, rx PCR = %d, data_cells = %u, idle_cells = %u\n",\r\nvcc->itf, vcc->vpi, vcc->vci, fore200e_atm2fore_aal(vcc->qos.aal),\r\nvcc->qos.txtp.max_pcr, vcc->qos.rxtp.max_pcr,\r\nfore200e_vcc->rate.data_cells, fore200e_vcc->rate.idle_cells);\r\n}\r\nfore200e_vcc->tx_min_pdu = fore200e_vcc->rx_min_pdu = MAX_PDU_SIZE + 1;\r\nfore200e_vcc->tx_max_pdu = fore200e_vcc->rx_max_pdu = 0;\r\nfore200e_vcc->tx_pdu = fore200e_vcc->rx_pdu = 0;\r\nvc_map->incarn = ++fore200e->incarn_count;\r\nset_bit(ATM_VF_READY, &vcc->flags);\r\nreturn 0;\r\n}\r\nstatic void\r\nfore200e_close(struct atm_vcc* vcc)\r\n{\r\nstruct fore200e* fore200e = FORE200E_DEV(vcc->dev);\r\nstruct fore200e_vcc* fore200e_vcc;\r\nstruct fore200e_vc_map* vc_map;\r\nunsigned long flags;\r\nASSERT(vcc);\r\nASSERT((vcc->vpi >= 0) && (vcc->vpi < 1<<FORE200E_VPI_BITS));\r\nASSERT((vcc->vci >= 0) && (vcc->vci < 1<<FORE200E_VCI_BITS));\r\nDPRINTK(2, "closing %d.%d.%d:%d\n", vcc->itf, vcc->vpi, vcc->vci, fore200e_atm2fore_aal(vcc->qos.aal));\r\nclear_bit(ATM_VF_READY, &vcc->flags);\r\nfore200e_activate_vcin(fore200e, 0, vcc, 0);\r\nspin_lock_irqsave(&fore200e->q_lock, flags);\r\nvc_map = FORE200E_VC_MAP(fore200e, vcc->vpi, vcc->vci);\r\nvc_map->vcc = NULL;\r\nvcc->itf = vcc->vci = vcc->vpi = 0;\r\nfore200e_vcc = FORE200E_VCC(vcc);\r\nvcc->dev_data = NULL;\r\nspin_unlock_irqrestore(&fore200e->q_lock, flags);\r\nif ((vcc->qos.txtp.traffic_class == ATM_CBR) && (vcc->qos.txtp.max_pcr > 0)) {\r\nmutex_lock(&fore200e->rate_mtx);\r\nfore200e->available_cell_rate += vcc->qos.txtp.max_pcr;\r\nmutex_unlock(&fore200e->rate_mtx);\r\nclear_bit(ATM_VF_HASQOS, &vcc->flags);\r\n}\r\nclear_bit(ATM_VF_ADDR, &vcc->flags);\r\nclear_bit(ATM_VF_PARTIAL,&vcc->flags);\r\nASSERT(fore200e_vcc);\r\nkfree(fore200e_vcc);\r\n}\r\nstatic int\r\nfore200e_send(struct atm_vcc *vcc, struct sk_buff *skb)\r\n{\r\nstruct fore200e* fore200e = FORE200E_DEV(vcc->dev);\r\nstruct fore200e_vcc* fore200e_vcc = FORE200E_VCC(vcc);\r\nstruct fore200e_vc_map* vc_map;\r\nstruct host_txq* txq = &fore200e->host_txq;\r\nstruct host_txq_entry* entry;\r\nstruct tpd* tpd;\r\nstruct tpd_haddr tpd_haddr;\r\nint retry = CONFIG_ATM_FORE200E_TX_RETRY;\r\nint tx_copy = 0;\r\nint tx_len = skb->len;\r\nu32* cell_header = NULL;\r\nunsigned char* skb_data;\r\nint skb_len;\r\nunsigned char* data;\r\nunsigned long flags;\r\nASSERT(vcc);\r\nASSERT(atomic_read(&sk_atm(vcc)->sk_wmem_alloc) >= 0);\r\nASSERT(fore200e);\r\nASSERT(fore200e_vcc);\r\nif (!test_bit(ATM_VF_READY, &vcc->flags)) {\r\nDPRINTK(1, "VC %d.%d.%d not ready for tx\n", vcc->itf, vcc->vpi, vcc->vpi);\r\ndev_kfree_skb_any(skb);\r\nreturn -EINVAL;\r\n}\r\n#ifdef FORE200E_52BYTE_AAL0_SDU\r\nif ((vcc->qos.aal == ATM_AAL0) && (vcc->qos.txtp.max_sdu == ATM_AAL0_SDU)) {\r\ncell_header = (u32*) skb->data;\r\nskb_data = skb->data + 4;\r\nskb_len = tx_len = skb->len - 4;\r\nDPRINTK(3, "user-supplied cell header = 0x%08x\n", *cell_header);\r\n}\r\nelse\r\n#endif\r\n{\r\nskb_data = skb->data;\r\nskb_len = skb->len;\r\n}\r\nif (((unsigned long)skb_data) & 0x3) {\r\nDPRINTK(2, "misaligned tx PDU on device %s\n", fore200e->name);\r\ntx_copy = 1;\r\ntx_len = skb_len;\r\n}\r\nif ((vcc->qos.aal == ATM_AAL0) && (skb_len % ATM_CELL_PAYLOAD)) {\r\nDPRINTK(2, "incomplete tx AAL0 PDU on device %s\n", fore200e->name);\r\ntx_copy = 1;\r\ntx_len = ((skb_len / ATM_CELL_PAYLOAD) + 1) * ATM_CELL_PAYLOAD;\r\n}\r\nif (tx_copy) {\r\ndata = kmalloc(tx_len, GFP_ATOMIC | GFP_DMA);\r\nif (data == NULL) {\r\nif (vcc->pop) {\r\nvcc->pop(vcc, skb);\r\n}\r\nelse {\r\ndev_kfree_skb_any(skb);\r\n}\r\nreturn -ENOMEM;\r\n}\r\nmemcpy(data, skb_data, skb_len);\r\nif (skb_len < tx_len)\r\nmemset(data + skb_len, 0x00, tx_len - skb_len);\r\n}\r\nelse {\r\ndata = skb_data;\r\n}\r\nvc_map = FORE200E_VC_MAP(fore200e, vcc->vpi, vcc->vci);\r\nASSERT(vc_map->vcc == vcc);\r\nretry_here:\r\nspin_lock_irqsave(&fore200e->q_lock, flags);\r\nentry = &txq->host_entry[ txq->head ];\r\nif ((*entry->status != STATUS_FREE) || (txq->txing >= QUEUE_SIZE_TX - 2)) {\r\nfore200e_tx_irq(fore200e);\r\nif (*entry->status != STATUS_FREE) {\r\nspin_unlock_irqrestore(&fore200e->q_lock, flags);\r\nif (--retry > 0) {\r\nudelay(50);\r\ngoto retry_here;\r\n}\r\natomic_inc(&vcc->stats->tx_err);\r\nfore200e->tx_sat++;\r\nDPRINTK(2, "tx queue of device %s is saturated, PDU dropped - heartbeat is %08x\n",\r\nfore200e->name, fore200e->cp_queues->heartbeat);\r\nif (vcc->pop) {\r\nvcc->pop(vcc, skb);\r\n}\r\nelse {\r\ndev_kfree_skb_any(skb);\r\n}\r\nif (tx_copy)\r\nkfree(data);\r\nreturn -ENOBUFS;\r\n}\r\n}\r\nentry->incarn = vc_map->incarn;\r\nentry->vc_map = vc_map;\r\nentry->skb = skb;\r\nentry->data = tx_copy ? data : NULL;\r\ntpd = entry->tpd;\r\ntpd->tsd[ 0 ].buffer = fore200e->bus->dma_map(fore200e, data, tx_len, DMA_TO_DEVICE);\r\ntpd->tsd[ 0 ].length = tx_len;\r\nFORE200E_NEXT_ENTRY(txq->head, QUEUE_SIZE_TX);\r\ntxq->txing++;\r\nDPRINTK(3, "tx on %d.%d.%d:%d, len = %u (%u)\n",\r\nvcc->itf, vcc->vpi, vcc->vci, fore200e_atm2fore_aal(vcc->qos.aal),\r\ntpd->tsd[0].length, skb_len);\r\nif (skb_len < fore200e_vcc->tx_min_pdu)\r\nfore200e_vcc->tx_min_pdu = skb_len;\r\nif (skb_len > fore200e_vcc->tx_max_pdu)\r\nfore200e_vcc->tx_max_pdu = skb_len;\r\nfore200e_vcc->tx_pdu++;\r\ntpd->rate.data_cells = fore200e_vcc->rate.data_cells;\r\ntpd->rate.idle_cells = fore200e_vcc->rate.idle_cells;\r\nif (cell_header) {\r\ntpd->atm_header.clp = (*cell_header & ATM_HDR_CLP);\r\ntpd->atm_header.plt = (*cell_header & ATM_HDR_PTI_MASK) >> ATM_HDR_PTI_SHIFT;\r\ntpd->atm_header.vci = (*cell_header & ATM_HDR_VCI_MASK) >> ATM_HDR_VCI_SHIFT;\r\ntpd->atm_header.vpi = (*cell_header & ATM_HDR_VPI_MASK) >> ATM_HDR_VPI_SHIFT;\r\ntpd->atm_header.gfc = (*cell_header & ATM_HDR_GFC_MASK) >> ATM_HDR_GFC_SHIFT;\r\n}\r\nelse {\r\ntpd->atm_header.clp = 0;\r\ntpd->atm_header.plt = 0;\r\ntpd->atm_header.vci = vcc->vci;\r\ntpd->atm_header.vpi = vcc->vpi;\r\ntpd->atm_header.gfc = 0;\r\n}\r\ntpd->spec.length = tx_len;\r\ntpd->spec.nseg = 1;\r\ntpd->spec.aal = fore200e_atm2fore_aal(vcc->qos.aal);\r\ntpd->spec.intr = 1;\r\ntpd_haddr.size = sizeof(struct tpd) / (1<<TPD_HADDR_SHIFT);\r\ntpd_haddr.pad = 0;\r\ntpd_haddr.haddr = entry->tpd_dma >> TPD_HADDR_SHIFT;\r\n*entry->status = STATUS_PENDING;\r\nfore200e->bus->write(*(u32*)&tpd_haddr, (u32 __iomem *)&entry->cp_entry->tpd_haddr);\r\nspin_unlock_irqrestore(&fore200e->q_lock, flags);\r\nreturn 0;\r\n}\r\nstatic int\r\nfore200e_getstats(struct fore200e* fore200e)\r\n{\r\nstruct host_cmdq* cmdq = &fore200e->host_cmdq;\r\nstruct host_cmdq_entry* entry = &cmdq->host_entry[ cmdq->head ];\r\nstruct stats_opcode opcode;\r\nint ok;\r\nu32 stats_dma_addr;\r\nif (fore200e->stats == NULL) {\r\nfore200e->stats = kzalloc(sizeof(struct stats), GFP_KERNEL | GFP_DMA);\r\nif (fore200e->stats == NULL)\r\nreturn -ENOMEM;\r\n}\r\nstats_dma_addr = fore200e->bus->dma_map(fore200e, fore200e->stats,\r\nsizeof(struct stats), DMA_FROM_DEVICE);\r\nFORE200E_NEXT_ENTRY(cmdq->head, QUEUE_SIZE_CMD);\r\nopcode.opcode = OPCODE_GET_STATS;\r\nopcode.pad = 0;\r\nfore200e->bus->write(stats_dma_addr, &entry->cp_entry->cmd.stats_block.stats_haddr);\r\n*entry->status = STATUS_PENDING;\r\nfore200e->bus->write(*(u32*)&opcode, (u32 __iomem *)&entry->cp_entry->cmd.stats_block.opcode);\r\nok = fore200e_poll(fore200e, entry->status, STATUS_COMPLETE, 400);\r\n*entry->status = STATUS_FREE;\r\nfore200e->bus->dma_unmap(fore200e, stats_dma_addr, sizeof(struct stats), DMA_FROM_DEVICE);\r\nif (ok == 0) {\r\nprintk(FORE200E "unable to get statistics from device %s\n", fore200e->name);\r\nreturn -EIO;\r\n}\r\nreturn 0;\r\n}\r\nstatic int\r\nfore200e_getsockopt(struct atm_vcc* vcc, int level, int optname, void __user *optval, int optlen)\r\n{\r\nDPRINTK(2, "getsockopt %d.%d.%d, level = %d, optname = 0x%x, optval = 0x%p, optlen = %d\n",\r\nvcc->itf, vcc->vpi, vcc->vci, level, optname, optval, optlen);\r\nreturn -EINVAL;\r\n}\r\nstatic int\r\nfore200e_setsockopt(struct atm_vcc* vcc, int level, int optname, void __user *optval, unsigned int optlen)\r\n{\r\nDPRINTK(2, "setsockopt %d.%d.%d, level = %d, optname = 0x%x, optval = 0x%p, optlen = %d\n",\r\nvcc->itf, vcc->vpi, vcc->vci, level, optname, optval, optlen);\r\nreturn -EINVAL;\r\n}\r\nstatic int\r\nfore200e_set_oc3(struct fore200e* fore200e, u32 reg, u32 value, u32 mask)\r\n{\r\nstruct host_cmdq* cmdq = &fore200e->host_cmdq;\r\nstruct host_cmdq_entry* entry = &cmdq->host_entry[ cmdq->head ];\r\nstruct oc3_opcode opcode;\r\nint ok;\r\nDPRINTK(2, "set OC-3 reg = 0x%02x, value = 0x%02x, mask = 0x%02x\n", reg, value, mask);\r\nFORE200E_NEXT_ENTRY(cmdq->head, QUEUE_SIZE_CMD);\r\nopcode.opcode = OPCODE_SET_OC3;\r\nopcode.reg = reg;\r\nopcode.value = value;\r\nopcode.mask = mask;\r\nfore200e->bus->write(0, &entry->cp_entry->cmd.oc3_block.regs_haddr);\r\n*entry->status = STATUS_PENDING;\r\nfore200e->bus->write(*(u32*)&opcode, (u32 __iomem *)&entry->cp_entry->cmd.oc3_block.opcode);\r\nok = fore200e_poll(fore200e, entry->status, STATUS_COMPLETE, 400);\r\n*entry->status = STATUS_FREE;\r\nif (ok == 0) {\r\nprintk(FORE200E "unable to set OC-3 reg 0x%02x of device %s\n", reg, fore200e->name);\r\nreturn -EIO;\r\n}\r\nreturn 0;\r\n}\r\nstatic int\r\nfore200e_setloop(struct fore200e* fore200e, int loop_mode)\r\n{\r\nu32 mct_value, mct_mask;\r\nint error;\r\nif (!capable(CAP_NET_ADMIN))\r\nreturn -EPERM;\r\nswitch (loop_mode) {\r\ncase ATM_LM_NONE:\r\nmct_value = 0;\r\nmct_mask = SUNI_MCT_DLE | SUNI_MCT_LLE;\r\nbreak;\r\ncase ATM_LM_LOC_PHY:\r\nmct_value = mct_mask = SUNI_MCT_DLE;\r\nbreak;\r\ncase ATM_LM_RMT_PHY:\r\nmct_value = mct_mask = SUNI_MCT_LLE;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nerror = fore200e_set_oc3(fore200e, SUNI_MCT, mct_value, mct_mask);\r\nif (error == 0)\r\nfore200e->loop_mode = loop_mode;\r\nreturn error;\r\n}\r\nstatic int\r\nfore200e_fetch_stats(struct fore200e* fore200e, struct sonet_stats __user *arg)\r\n{\r\nstruct sonet_stats tmp;\r\nif (fore200e_getstats(fore200e) < 0)\r\nreturn -EIO;\r\ntmp.section_bip = be32_to_cpu(fore200e->stats->oc3.section_bip8_errors);\r\ntmp.line_bip = be32_to_cpu(fore200e->stats->oc3.line_bip24_errors);\r\ntmp.path_bip = be32_to_cpu(fore200e->stats->oc3.path_bip8_errors);\r\ntmp.line_febe = be32_to_cpu(fore200e->stats->oc3.line_febe_errors);\r\ntmp.path_febe = be32_to_cpu(fore200e->stats->oc3.path_febe_errors);\r\ntmp.corr_hcs = be32_to_cpu(fore200e->stats->oc3.corr_hcs_errors);\r\ntmp.uncorr_hcs = be32_to_cpu(fore200e->stats->oc3.ucorr_hcs_errors);\r\ntmp.tx_cells = be32_to_cpu(fore200e->stats->aal0.cells_transmitted) +\r\nbe32_to_cpu(fore200e->stats->aal34.cells_transmitted) +\r\nbe32_to_cpu(fore200e->stats->aal5.cells_transmitted);\r\ntmp.rx_cells = be32_to_cpu(fore200e->stats->aal0.cells_received) +\r\nbe32_to_cpu(fore200e->stats->aal34.cells_received) +\r\nbe32_to_cpu(fore200e->stats->aal5.cells_received);\r\nif (arg)\r\nreturn copy_to_user(arg, &tmp, sizeof(struct sonet_stats)) ? -EFAULT : 0;\r\nreturn 0;\r\n}\r\nstatic int\r\nfore200e_ioctl(struct atm_dev* dev, unsigned int cmd, void __user * arg)\r\n{\r\nstruct fore200e* fore200e = FORE200E_DEV(dev);\r\nDPRINTK(2, "ioctl cmd = 0x%x (%u), arg = 0x%p (%lu)\n", cmd, cmd, arg, (unsigned long)arg);\r\nswitch (cmd) {\r\ncase SONET_GETSTAT:\r\nreturn fore200e_fetch_stats(fore200e, (struct sonet_stats __user *)arg);\r\ncase SONET_GETDIAG:\r\nreturn put_user(0, (int __user *)arg) ? -EFAULT : 0;\r\ncase ATM_SETLOOP:\r\nreturn fore200e_setloop(fore200e, (int)(unsigned long)arg);\r\ncase ATM_GETLOOP:\r\nreturn put_user(fore200e->loop_mode, (int __user *)arg) ? -EFAULT : 0;\r\ncase ATM_QUERYLOOP:\r\nreturn put_user(ATM_LM_LOC_PHY | ATM_LM_RMT_PHY, (int __user *)arg) ? -EFAULT : 0;\r\n}\r\nreturn -ENOSYS;\r\n}\r\nstatic int\r\nfore200e_change_qos(struct atm_vcc* vcc,struct atm_qos* qos, int flags)\r\n{\r\nstruct fore200e_vcc* fore200e_vcc = FORE200E_VCC(vcc);\r\nstruct fore200e* fore200e = FORE200E_DEV(vcc->dev);\r\nif (!test_bit(ATM_VF_READY, &vcc->flags)) {\r\nDPRINTK(1, "VC %d.%d.%d not ready for QoS change\n", vcc->itf, vcc->vpi, vcc->vpi);\r\nreturn -EINVAL;\r\n}\r\nDPRINTK(2, "change_qos %d.%d.%d, "\r\n"(tx: cl=%s, pcr=%d-%d, cdv=%d, max_sdu=%d; "\r\n"rx: cl=%s, pcr=%d-%d, cdv=%d, max_sdu=%d), flags = 0x%x\n"\r\n"available_cell_rate = %u",\r\nvcc->itf, vcc->vpi, vcc->vci,\r\nfore200e_traffic_class[ qos->txtp.traffic_class ],\r\nqos->txtp.min_pcr, qos->txtp.max_pcr, qos->txtp.max_cdv, qos->txtp.max_sdu,\r\nfore200e_traffic_class[ qos->rxtp.traffic_class ],\r\nqos->rxtp.min_pcr, qos->rxtp.max_pcr, qos->rxtp.max_cdv, qos->rxtp.max_sdu,\r\nflags, fore200e->available_cell_rate);\r\nif ((qos->txtp.traffic_class == ATM_CBR) && (qos->txtp.max_pcr > 0)) {\r\nmutex_lock(&fore200e->rate_mtx);\r\nif (fore200e->available_cell_rate + vcc->qos.txtp.max_pcr < qos->txtp.max_pcr) {\r\nmutex_unlock(&fore200e->rate_mtx);\r\nreturn -EAGAIN;\r\n}\r\nfore200e->available_cell_rate += vcc->qos.txtp.max_pcr;\r\nfore200e->available_cell_rate -= qos->txtp.max_pcr;\r\nmutex_unlock(&fore200e->rate_mtx);\r\nmemcpy(&vcc->qos, qos, sizeof(struct atm_qos));\r\nfore200e_rate_ctrl(qos, &fore200e_vcc->rate);\r\nset_bit(ATM_VF_HASQOS, &vcc->flags);\r\nreturn 0;\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int fore200e_irq_request(struct fore200e *fore200e)\r\n{\r\nif (request_irq(fore200e->irq, fore200e_interrupt, IRQF_SHARED, fore200e->name, fore200e->atm_dev) < 0) {\r\nprintk(FORE200E "unable to reserve IRQ %s for device %s\n",\r\nfore200e_irq_itoa(fore200e->irq), fore200e->name);\r\nreturn -EBUSY;\r\n}\r\nprintk(FORE200E "IRQ %s reserved for device %s\n",\r\nfore200e_irq_itoa(fore200e->irq), fore200e->name);\r\n#ifdef FORE200E_USE_TASKLET\r\ntasklet_init(&fore200e->tx_tasklet, fore200e_tx_tasklet, (unsigned long)fore200e);\r\ntasklet_init(&fore200e->rx_tasklet, fore200e_rx_tasklet, (unsigned long)fore200e);\r\n#endif\r\nfore200e->state = FORE200E_STATE_IRQ;\r\nreturn 0;\r\n}\r\nstatic int fore200e_get_esi(struct fore200e *fore200e)\r\n{\r\nstruct prom_data* prom = kzalloc(sizeof(struct prom_data), GFP_KERNEL | GFP_DMA);\r\nint ok, i;\r\nif (!prom)\r\nreturn -ENOMEM;\r\nok = fore200e->bus->prom_read(fore200e, prom);\r\nif (ok < 0) {\r\nkfree(prom);\r\nreturn -EBUSY;\r\n}\r\nprintk(FORE200E "device %s, rev. %c, S/N: %d, ESI: %pM\n",\r\nfore200e->name,\r\n(prom->hw_revision & 0xFF) + '@',\r\nprom->serial_number & 0xFFFF, &prom->mac_addr[2]);\r\nfor (i = 0; i < ESI_LEN; i++) {\r\nfore200e->esi[ i ] = fore200e->atm_dev->esi[ i ] = prom->mac_addr[ i + 2 ];\r\n}\r\nkfree(prom);\r\nreturn 0;\r\n}\r\nstatic int fore200e_alloc_rx_buf(struct fore200e *fore200e)\r\n{\r\nint scheme, magn, nbr, size, i;\r\nstruct host_bsq* bsq;\r\nstruct buffer* buffer;\r\nfor (scheme = 0; scheme < BUFFER_SCHEME_NBR; scheme++) {\r\nfor (magn = 0; magn < BUFFER_MAGN_NBR; magn++) {\r\nbsq = &fore200e->host_bsq[ scheme ][ magn ];\r\nnbr = fore200e_rx_buf_nbr[ scheme ][ magn ];\r\nsize = fore200e_rx_buf_size[ scheme ][ magn ];\r\nDPRINTK(2, "rx buffers %d / %d are being allocated\n", scheme, magn);\r\nbuffer = bsq->buffer = kzalloc(nbr * sizeof(struct buffer), GFP_KERNEL);\r\nif (buffer == NULL)\r\nreturn -ENOMEM;\r\nbsq->freebuf = NULL;\r\nfor (i = 0; i < nbr; i++) {\r\nbuffer[ i ].scheme = scheme;\r\nbuffer[ i ].magn = magn;\r\n#ifdef FORE200E_BSQ_DEBUG\r\nbuffer[ i ].index = i;\r\nbuffer[ i ].supplied = 0;\r\n#endif\r\nif (fore200e_chunk_alloc(fore200e,\r\n&buffer[ i ].data, size, fore200e->bus->buffer_alignment,\r\nDMA_FROM_DEVICE) < 0) {\r\nwhile (i > 0)\r\nfore200e_chunk_free(fore200e, &buffer[ --i ].data);\r\nkfree(buffer);\r\nreturn -ENOMEM;\r\n}\r\nbuffer[ i ].next = bsq->freebuf;\r\nbsq->freebuf = &buffer[ i ];\r\n}\r\nbsq->freebuf_count = nbr;\r\n#ifdef FORE200E_BSQ_DEBUG\r\nbsq_audit(3, bsq, scheme, magn);\r\n#endif\r\n}\r\n}\r\nfore200e->state = FORE200E_STATE_ALLOC_BUF;\r\nreturn 0;\r\n}\r\nstatic int fore200e_init_bs_queue(struct fore200e *fore200e)\r\n{\r\nint scheme, magn, i;\r\nstruct host_bsq* bsq;\r\nstruct cp_bsq_entry __iomem * cp_entry;\r\nfor (scheme = 0; scheme < BUFFER_SCHEME_NBR; scheme++) {\r\nfor (magn = 0; magn < BUFFER_MAGN_NBR; magn++) {\r\nDPRINTK(2, "buffer supply queue %d / %d is being initialized\n", scheme, magn);\r\nbsq = &fore200e->host_bsq[ scheme ][ magn ];\r\nif (fore200e->bus->dma_chunk_alloc(fore200e,\r\n&bsq->status,\r\nsizeof(enum status),\r\nQUEUE_SIZE_BS,\r\nfore200e->bus->status_alignment) < 0) {\r\nreturn -ENOMEM;\r\n}\r\nif (fore200e->bus->dma_chunk_alloc(fore200e,\r\n&bsq->rbd_block,\r\nsizeof(struct rbd_block),\r\nQUEUE_SIZE_BS,\r\nfore200e->bus->descr_alignment) < 0) {\r\nfore200e->bus->dma_chunk_free(fore200e, &bsq->status);\r\nreturn -ENOMEM;\r\n}\r\ncp_entry = fore200e->virt_base +\r\nfore200e->bus->read(&fore200e->cp_queues->cp_bsq[ scheme ][ magn ]);\r\nfor (i = 0; i < QUEUE_SIZE_BS; i++) {\r\nbsq->host_entry[ i ].status =\r\nFORE200E_INDEX(bsq->status.align_addr, enum status, i);\r\nbsq->host_entry[ i ].rbd_block =\r\nFORE200E_INDEX(bsq->rbd_block.align_addr, struct rbd_block, i);\r\nbsq->host_entry[ i ].rbd_block_dma =\r\nFORE200E_DMA_INDEX(bsq->rbd_block.dma_addr, struct rbd_block, i);\r\nbsq->host_entry[ i ].cp_entry = &cp_entry[ i ];\r\n*bsq->host_entry[ i ].status = STATUS_FREE;\r\nfore200e->bus->write(FORE200E_DMA_INDEX(bsq->status.dma_addr, enum status, i),\r\n&cp_entry[ i ].status_haddr);\r\n}\r\n}\r\n}\r\nfore200e->state = FORE200E_STATE_INIT_BSQ;\r\nreturn 0;\r\n}\r\nstatic int fore200e_init_rx_queue(struct fore200e *fore200e)\r\n{\r\nstruct host_rxq* rxq = &fore200e->host_rxq;\r\nstruct cp_rxq_entry __iomem * cp_entry;\r\nint i;\r\nDPRINTK(2, "receive queue is being initialized\n");\r\nif (fore200e->bus->dma_chunk_alloc(fore200e,\r\n&rxq->status,\r\nsizeof(enum status),\r\nQUEUE_SIZE_RX,\r\nfore200e->bus->status_alignment) < 0) {\r\nreturn -ENOMEM;\r\n}\r\nif (fore200e->bus->dma_chunk_alloc(fore200e,\r\n&rxq->rpd,\r\nsizeof(struct rpd),\r\nQUEUE_SIZE_RX,\r\nfore200e->bus->descr_alignment) < 0) {\r\nfore200e->bus->dma_chunk_free(fore200e, &rxq->status);\r\nreturn -ENOMEM;\r\n}\r\ncp_entry = fore200e->virt_base + fore200e->bus->read(&fore200e->cp_queues->cp_rxq);\r\nfor (i=0; i < QUEUE_SIZE_RX; i++) {\r\nrxq->host_entry[ i ].status =\r\nFORE200E_INDEX(rxq->status.align_addr, enum status, i);\r\nrxq->host_entry[ i ].rpd =\r\nFORE200E_INDEX(rxq->rpd.align_addr, struct rpd, i);\r\nrxq->host_entry[ i ].rpd_dma =\r\nFORE200E_DMA_INDEX(rxq->rpd.dma_addr, struct rpd, i);\r\nrxq->host_entry[ i ].cp_entry = &cp_entry[ i ];\r\n*rxq->host_entry[ i ].status = STATUS_FREE;\r\nfore200e->bus->write(FORE200E_DMA_INDEX(rxq->status.dma_addr, enum status, i),\r\n&cp_entry[ i ].status_haddr);\r\nfore200e->bus->write(FORE200E_DMA_INDEX(rxq->rpd.dma_addr, struct rpd, i),\r\n&cp_entry[ i ].rpd_haddr);\r\n}\r\nrxq->head = 0;\r\nfore200e->state = FORE200E_STATE_INIT_RXQ;\r\nreturn 0;\r\n}\r\nstatic int fore200e_init_tx_queue(struct fore200e *fore200e)\r\n{\r\nstruct host_txq* txq = &fore200e->host_txq;\r\nstruct cp_txq_entry __iomem * cp_entry;\r\nint i;\r\nDPRINTK(2, "transmit queue is being initialized\n");\r\nif (fore200e->bus->dma_chunk_alloc(fore200e,\r\n&txq->status,\r\nsizeof(enum status),\r\nQUEUE_SIZE_TX,\r\nfore200e->bus->status_alignment) < 0) {\r\nreturn -ENOMEM;\r\n}\r\nif (fore200e->bus->dma_chunk_alloc(fore200e,\r\n&txq->tpd,\r\nsizeof(struct tpd),\r\nQUEUE_SIZE_TX,\r\nfore200e->bus->descr_alignment) < 0) {\r\nfore200e->bus->dma_chunk_free(fore200e, &txq->status);\r\nreturn -ENOMEM;\r\n}\r\ncp_entry = fore200e->virt_base + fore200e->bus->read(&fore200e->cp_queues->cp_txq);\r\nfor (i=0; i < QUEUE_SIZE_TX; i++) {\r\ntxq->host_entry[ i ].status =\r\nFORE200E_INDEX(txq->status.align_addr, enum status, i);\r\ntxq->host_entry[ i ].tpd =\r\nFORE200E_INDEX(txq->tpd.align_addr, struct tpd, i);\r\ntxq->host_entry[ i ].tpd_dma =\r\nFORE200E_DMA_INDEX(txq->tpd.dma_addr, struct tpd, i);\r\ntxq->host_entry[ i ].cp_entry = &cp_entry[ i ];\r\n*txq->host_entry[ i ].status = STATUS_FREE;\r\nfore200e->bus->write(FORE200E_DMA_INDEX(txq->status.dma_addr, enum status, i),\r\n&cp_entry[ i ].status_haddr);\r\n}\r\ntxq->head = 0;\r\ntxq->tail = 0;\r\nfore200e->state = FORE200E_STATE_INIT_TXQ;\r\nreturn 0;\r\n}\r\nstatic int fore200e_init_cmd_queue(struct fore200e *fore200e)\r\n{\r\nstruct host_cmdq* cmdq = &fore200e->host_cmdq;\r\nstruct cp_cmdq_entry __iomem * cp_entry;\r\nint i;\r\nDPRINTK(2, "command queue is being initialized\n");\r\nif (fore200e->bus->dma_chunk_alloc(fore200e,\r\n&cmdq->status,\r\nsizeof(enum status),\r\nQUEUE_SIZE_CMD,\r\nfore200e->bus->status_alignment) < 0) {\r\nreturn -ENOMEM;\r\n}\r\ncp_entry = fore200e->virt_base + fore200e->bus->read(&fore200e->cp_queues->cp_cmdq);\r\nfor (i=0; i < QUEUE_SIZE_CMD; i++) {\r\ncmdq->host_entry[ i ].status =\r\nFORE200E_INDEX(cmdq->status.align_addr, enum status, i);\r\ncmdq->host_entry[ i ].cp_entry = &cp_entry[ i ];\r\n*cmdq->host_entry[ i ].status = STATUS_FREE;\r\nfore200e->bus->write(FORE200E_DMA_INDEX(cmdq->status.dma_addr, enum status, i),\r\n&cp_entry[ i ].status_haddr);\r\n}\r\ncmdq->head = 0;\r\nfore200e->state = FORE200E_STATE_INIT_CMDQ;\r\nreturn 0;\r\n}\r\nstatic void fore200e_param_bs_queue(struct fore200e *fore200e,\r\nenum buffer_scheme scheme,\r\nenum buffer_magn magn, int queue_length,\r\nint pool_size, int supply_blksize)\r\n{\r\nstruct bs_spec __iomem * bs_spec = &fore200e->cp_queues->init.bs_spec[ scheme ][ magn ];\r\nfore200e->bus->write(queue_length, &bs_spec->queue_length);\r\nfore200e->bus->write(fore200e_rx_buf_size[ scheme ][ magn ], &bs_spec->buffer_size);\r\nfore200e->bus->write(pool_size, &bs_spec->pool_size);\r\nfore200e->bus->write(supply_blksize, &bs_spec->supply_blksize);\r\n}\r\nstatic int fore200e_initialize(struct fore200e *fore200e)\r\n{\r\nstruct cp_queues __iomem * cpq;\r\nint ok, scheme, magn;\r\nDPRINTK(2, "device %s being initialized\n", fore200e->name);\r\nmutex_init(&fore200e->rate_mtx);\r\nspin_lock_init(&fore200e->q_lock);\r\ncpq = fore200e->cp_queues = fore200e->virt_base + FORE200E_CP_QUEUES_OFFSET;\r\nfore200e->bus->write(1, &cpq->imask);\r\nif (fore200e->bus->irq_enable)\r\nfore200e->bus->irq_enable(fore200e);\r\nfore200e->bus->write(NBR_CONNECT, &cpq->init.num_connect);\r\nfore200e->bus->write(QUEUE_SIZE_CMD, &cpq->init.cmd_queue_len);\r\nfore200e->bus->write(QUEUE_SIZE_RX, &cpq->init.rx_queue_len);\r\nfore200e->bus->write(QUEUE_SIZE_TX, &cpq->init.tx_queue_len);\r\nfore200e->bus->write(RSD_EXTENSION, &cpq->init.rsd_extension);\r\nfore200e->bus->write(TSD_EXTENSION, &cpq->init.tsd_extension);\r\nfor (scheme = 0; scheme < BUFFER_SCHEME_NBR; scheme++)\r\nfor (magn = 0; magn < BUFFER_MAGN_NBR; magn++)\r\nfore200e_param_bs_queue(fore200e, scheme, magn,\r\nQUEUE_SIZE_BS,\r\nfore200e_rx_buf_nbr[ scheme ][ magn ],\r\nRBD_BLK_SIZE);\r\nfore200e->bus->write(STATUS_PENDING, &cpq->init.status);\r\nfore200e->bus->write(OPCODE_INITIALIZE, &cpq->init.opcode);\r\nok = fore200e_io_poll(fore200e, &cpq->init.status, STATUS_COMPLETE, 3000);\r\nif (ok == 0) {\r\nprintk(FORE200E "device %s initialization failed\n", fore200e->name);\r\nreturn -ENODEV;\r\n}\r\nprintk(FORE200E "device %s initialized\n", fore200e->name);\r\nfore200e->state = FORE200E_STATE_INITIALIZE;\r\nreturn 0;\r\n}\r\nstatic void fore200e_monitor_putc(struct fore200e *fore200e, char c)\r\n{\r\nstruct cp_monitor __iomem * monitor = fore200e->cp_monitor;\r\n#if 0\r\nprintk("%c", c);\r\n#endif\r\nfore200e->bus->write(((u32) c) | FORE200E_CP_MONITOR_UART_AVAIL, &monitor->soft_uart.send);\r\n}\r\nstatic int fore200e_monitor_getc(struct fore200e *fore200e)\r\n{\r\nstruct cp_monitor __iomem * monitor = fore200e->cp_monitor;\r\nunsigned long timeout = jiffies + msecs_to_jiffies(50);\r\nint c;\r\nwhile (time_before(jiffies, timeout)) {\r\nc = (int) fore200e->bus->read(&monitor->soft_uart.recv);\r\nif (c & FORE200E_CP_MONITOR_UART_AVAIL) {\r\nfore200e->bus->write(FORE200E_CP_MONITOR_UART_FREE, &monitor->soft_uart.recv);\r\n#if 0\r\nprintk("%c", c & 0xFF);\r\n#endif\r\nreturn c & 0xFF;\r\n}\r\n}\r\nreturn -1;\r\n}\r\nstatic void fore200e_monitor_puts(struct fore200e *fore200e, char *str)\r\n{\r\nwhile (*str) {\r\nwhile (fore200e_monitor_getc(fore200e) >= 0);\r\nfore200e_monitor_putc(fore200e, *str++);\r\n}\r\nwhile (fore200e_monitor_getc(fore200e) >= 0);\r\n}\r\nstatic int fore200e_load_and_start_fw(struct fore200e *fore200e)\r\n{\r\nconst struct firmware *firmware;\r\nstruct device *device;\r\nstruct fw_header *fw_header;\r\nconst __le32 *fw_data;\r\nu32 fw_size;\r\nu32 __iomem *load_addr;\r\nchar buf[48];\r\nint err = -ENODEV;\r\nif (strcmp(fore200e->bus->model_name, "PCA-200E") == 0)\r\ndevice = &((struct pci_dev *) fore200e->bus_dev)->dev;\r\n#ifdef CONFIG_SBUS\r\nelse if (strcmp(fore200e->bus->model_name, "SBA-200E") == 0)\r\ndevice = &((struct platform_device *) fore200e->bus_dev)->dev;\r\n#endif\r\nelse\r\nreturn err;\r\nsprintf(buf, "%s%s", fore200e->bus->proc_name, FW_EXT);\r\nif ((err = request_firmware(&firmware, buf, device)) < 0) {\r\nprintk(FORE200E "problem loading firmware image %s\n", fore200e->bus->model_name);\r\nreturn err;\r\n}\r\nfw_data = (__le32 *) firmware->data;\r\nfw_size = firmware->size / sizeof(u32);\r\nfw_header = (struct fw_header *) firmware->data;\r\nload_addr = fore200e->virt_base + le32_to_cpu(fw_header->load_offset);\r\nDPRINTK(2, "device %s firmware being loaded at 0x%p (%d words)\n",\r\nfore200e->name, load_addr, fw_size);\r\nif (le32_to_cpu(fw_header->magic) != FW_HEADER_MAGIC) {\r\nprintk(FORE200E "corrupted %s firmware image\n", fore200e->bus->model_name);\r\ngoto release;\r\n}\r\nfor (; fw_size--; fw_data++, load_addr++)\r\nfore200e->bus->write(le32_to_cpu(*fw_data), load_addr);\r\nDPRINTK(2, "device %s firmware being started\n", fore200e->name);\r\n#if defined(__sparc_v9__)\r\nfore200e_spin(100);\r\n#endif\r\nsprintf(buf, "\rgo %x\r", le32_to_cpu(fw_header->start_offset));\r\nfore200e_monitor_puts(fore200e, buf);\r\nif (fore200e_io_poll(fore200e, &fore200e->cp_monitor->bstat, BSTAT_CP_RUNNING, 1000) == 0) {\r\nprintk(FORE200E "device %s firmware didn't start\n", fore200e->name);\r\ngoto release;\r\n}\r\nprintk(FORE200E "device %s firmware started\n", fore200e->name);\r\nfore200e->state = FORE200E_STATE_START_FW;\r\nerr = 0;\r\nrelease:\r\nrelease_firmware(firmware);\r\nreturn err;\r\n}\r\nstatic int fore200e_register(struct fore200e *fore200e, struct device *parent)\r\n{\r\nstruct atm_dev* atm_dev;\r\nDPRINTK(2, "device %s being registered\n", fore200e->name);\r\natm_dev = atm_dev_register(fore200e->bus->proc_name, parent, &fore200e_ops,\r\n-1, NULL);\r\nif (atm_dev == NULL) {\r\nprintk(FORE200E "unable to register device %s\n", fore200e->name);\r\nreturn -ENODEV;\r\n}\r\natm_dev->dev_data = fore200e;\r\nfore200e->atm_dev = atm_dev;\r\natm_dev->ci_range.vpi_bits = FORE200E_VPI_BITS;\r\natm_dev->ci_range.vci_bits = FORE200E_VCI_BITS;\r\nfore200e->available_cell_rate = ATM_OC3_PCR;\r\nfore200e->state = FORE200E_STATE_REGISTER;\r\nreturn 0;\r\n}\r\nstatic int fore200e_init(struct fore200e *fore200e, struct device *parent)\r\n{\r\nif (fore200e_register(fore200e, parent) < 0)\r\nreturn -ENODEV;\r\nif (fore200e->bus->configure(fore200e) < 0)\r\nreturn -ENODEV;\r\nif (fore200e->bus->map(fore200e) < 0)\r\nreturn -ENODEV;\r\nif (fore200e_reset(fore200e, 1) < 0)\r\nreturn -ENODEV;\r\nif (fore200e_load_and_start_fw(fore200e) < 0)\r\nreturn -ENODEV;\r\nif (fore200e_initialize(fore200e) < 0)\r\nreturn -ENODEV;\r\nif (fore200e_init_cmd_queue(fore200e) < 0)\r\nreturn -ENOMEM;\r\nif (fore200e_init_tx_queue(fore200e) < 0)\r\nreturn -ENOMEM;\r\nif (fore200e_init_rx_queue(fore200e) < 0)\r\nreturn -ENOMEM;\r\nif (fore200e_init_bs_queue(fore200e) < 0)\r\nreturn -ENOMEM;\r\nif (fore200e_alloc_rx_buf(fore200e) < 0)\r\nreturn -ENOMEM;\r\nif (fore200e_get_esi(fore200e) < 0)\r\nreturn -EIO;\r\nif (fore200e_irq_request(fore200e) < 0)\r\nreturn -EBUSY;\r\nfore200e_supply(fore200e);\r\nfore200e->state = FORE200E_STATE_COMPLETE;\r\nreturn 0;\r\n}\r\nstatic int fore200e_sba_probe(struct platform_device *op)\r\n{\r\nconst struct of_device_id *match;\r\nconst struct fore200e_bus *bus;\r\nstruct fore200e *fore200e;\r\nstatic int index = 0;\r\nint err;\r\nmatch = of_match_device(fore200e_sba_match, &op->dev);\r\nif (!match)\r\nreturn -EINVAL;\r\nbus = match->data;\r\nfore200e = kzalloc(sizeof(struct fore200e), GFP_KERNEL);\r\nif (!fore200e)\r\nreturn -ENOMEM;\r\nfore200e->bus = bus;\r\nfore200e->bus_dev = op;\r\nfore200e->irq = op->archdata.irqs[0];\r\nfore200e->phys_base = op->resource[0].start;\r\nsprintf(fore200e->name, "%s-%d", bus->model_name, index);\r\nerr = fore200e_init(fore200e, &op->dev);\r\nif (err < 0) {\r\nfore200e_shutdown(fore200e);\r\nkfree(fore200e);\r\nreturn err;\r\n}\r\nindex++;\r\ndev_set_drvdata(&op->dev, fore200e);\r\nreturn 0;\r\n}\r\nstatic int fore200e_sba_remove(struct platform_device *op)\r\n{\r\nstruct fore200e *fore200e = dev_get_drvdata(&op->dev);\r\nfore200e_shutdown(fore200e);\r\nkfree(fore200e);\r\nreturn 0;\r\n}\r\nstatic int fore200e_pca_detect(struct pci_dev *pci_dev,\r\nconst struct pci_device_id *pci_ent)\r\n{\r\nconst struct fore200e_bus* bus = (struct fore200e_bus*) pci_ent->driver_data;\r\nstruct fore200e* fore200e;\r\nint err = 0;\r\nstatic int index = 0;\r\nif (pci_enable_device(pci_dev)) {\r\nerr = -EINVAL;\r\ngoto out;\r\n}\r\nif (dma_set_mask_and_coherent(&pci_dev->dev, DMA_BIT_MASK(32))) {\r\nerr = -EINVAL;\r\ngoto out;\r\n}\r\nfore200e = kzalloc(sizeof(struct fore200e), GFP_KERNEL);\r\nif (fore200e == NULL) {\r\nerr = -ENOMEM;\r\ngoto out_disable;\r\n}\r\nfore200e->bus = bus;\r\nfore200e->bus_dev = pci_dev;\r\nfore200e->irq = pci_dev->irq;\r\nfore200e->phys_base = pci_resource_start(pci_dev, 0);\r\nsprintf(fore200e->name, "%s-%d", bus->model_name, index - 1);\r\npci_set_master(pci_dev);\r\nprintk(FORE200E "device %s found at 0x%lx, IRQ %s\n",\r\nfore200e->bus->model_name,\r\nfore200e->phys_base, fore200e_irq_itoa(fore200e->irq));\r\nsprintf(fore200e->name, "%s-%d", bus->model_name, index);\r\nerr = fore200e_init(fore200e, &pci_dev->dev);\r\nif (err < 0) {\r\nfore200e_shutdown(fore200e);\r\ngoto out_free;\r\n}\r\n++index;\r\npci_set_drvdata(pci_dev, fore200e);\r\nout:\r\nreturn err;\r\nout_free:\r\nkfree(fore200e);\r\nout_disable:\r\npci_disable_device(pci_dev);\r\ngoto out;\r\n}\r\nstatic void fore200e_pca_remove_one(struct pci_dev *pci_dev)\r\n{\r\nstruct fore200e *fore200e;\r\nfore200e = pci_get_drvdata(pci_dev);\r\nfore200e_shutdown(fore200e);\r\nkfree(fore200e);\r\npci_disable_device(pci_dev);\r\n}\r\nstatic int __init fore200e_module_init(void)\r\n{\r\nint err = 0;\r\nprintk(FORE200E "FORE Systems 200E-series ATM driver - version " FORE200E_VERSION "\n");\r\n#ifdef CONFIG_SBUS\r\nerr = platform_driver_register(&fore200e_sba_driver);\r\nif (err)\r\nreturn err;\r\n#endif\r\n#ifdef CONFIG_PCI\r\nerr = pci_register_driver(&fore200e_pca_driver);\r\n#endif\r\n#ifdef CONFIG_SBUS\r\nif (err)\r\nplatform_driver_unregister(&fore200e_sba_driver);\r\n#endif\r\nreturn err;\r\n}\r\nstatic void __exit fore200e_module_cleanup(void)\r\n{\r\n#ifdef CONFIG_PCI\r\npci_unregister_driver(&fore200e_pca_driver);\r\n#endif\r\n#ifdef CONFIG_SBUS\r\nplatform_driver_unregister(&fore200e_sba_driver);\r\n#endif\r\n}\r\nstatic int\r\nfore200e_proc_read(struct atm_dev *dev, loff_t* pos, char* page)\r\n{\r\nstruct fore200e* fore200e = FORE200E_DEV(dev);\r\nstruct fore200e_vcc* fore200e_vcc;\r\nstruct atm_vcc* vcc;\r\nint i, len, left = *pos;\r\nunsigned long flags;\r\nif (!left--) {\r\nif (fore200e_getstats(fore200e) < 0)\r\nreturn -EIO;\r\nlen = sprintf(page,"\n"\r\n" device:\n"\r\n" internal name:\t\t%s\n", fore200e->name);\r\nif (fore200e->bus->proc_read)\r\nlen += fore200e->bus->proc_read(fore200e, page + len);\r\nlen += sprintf(page + len,\r\n" interrupt line:\t\t%s\n"\r\n" physical base address:\t0x%p\n"\r\n" virtual base address:\t0x%p\n"\r\n" factory address (ESI):\t%pM\n"\r\n" board serial number:\t\t%d\n\n",\r\nfore200e_irq_itoa(fore200e->irq),\r\n(void*)fore200e->phys_base,\r\nfore200e->virt_base,\r\nfore200e->esi,\r\nfore200e->esi[4] * 256 + fore200e->esi[5]);\r\nreturn len;\r\n}\r\nif (!left--)\r\nreturn sprintf(page,\r\n" free small bufs, scheme 1:\t%d\n"\r\n" free large bufs, scheme 1:\t%d\n"\r\n" free small bufs, scheme 2:\t%d\n"\r\n" free large bufs, scheme 2:\t%d\n",\r\nfore200e->host_bsq[ BUFFER_SCHEME_ONE ][ BUFFER_MAGN_SMALL ].freebuf_count,\r\nfore200e->host_bsq[ BUFFER_SCHEME_ONE ][ BUFFER_MAGN_LARGE ].freebuf_count,\r\nfore200e->host_bsq[ BUFFER_SCHEME_TWO ][ BUFFER_MAGN_SMALL ].freebuf_count,\r\nfore200e->host_bsq[ BUFFER_SCHEME_TWO ][ BUFFER_MAGN_LARGE ].freebuf_count);\r\nif (!left--) {\r\nu32 hb = fore200e->bus->read(&fore200e->cp_queues->heartbeat);\r\nlen = sprintf(page,"\n\n"\r\n" cell processor:\n"\r\n" heartbeat state:\t\t");\r\nif (hb >> 16 != 0xDEAD)\r\nlen += sprintf(page + len, "0x%08x\n", hb);\r\nelse\r\nlen += sprintf(page + len, "*** FATAL ERROR %04x ***\n", hb & 0xFFFF);\r\nreturn len;\r\n}\r\nif (!left--) {\r\nstatic const char* media_name[] = {\r\n"unshielded twisted pair",\r\n"multimode optical fiber ST",\r\n"multimode optical fiber SC",\r\n"single-mode optical fiber ST",\r\n"single-mode optical fiber SC",\r\n"unknown"\r\n};\r\nstatic const char* oc3_mode[] = {\r\n"normal operation",\r\n"diagnostic loopback",\r\n"line loopback",\r\n"unknown"\r\n};\r\nu32 fw_release = fore200e->bus->read(&fore200e->cp_queues->fw_release);\r\nu32 mon960_release = fore200e->bus->read(&fore200e->cp_queues->mon960_release);\r\nu32 oc3_revision = fore200e->bus->read(&fore200e->cp_queues->oc3_revision);\r\nu32 media_index = FORE200E_MEDIA_INDEX(fore200e->bus->read(&fore200e->cp_queues->media_type));\r\nu32 oc3_index;\r\nif (media_index > 4)\r\nmedia_index = 5;\r\nswitch (fore200e->loop_mode) {\r\ncase ATM_LM_NONE: oc3_index = 0;\r\nbreak;\r\ncase ATM_LM_LOC_PHY: oc3_index = 1;\r\nbreak;\r\ncase ATM_LM_RMT_PHY: oc3_index = 2;\r\nbreak;\r\ndefault: oc3_index = 3;\r\n}\r\nreturn sprintf(page,\r\n" firmware release:\t\t%d.%d.%d\n"\r\n" monitor release:\t\t%d.%d\n"\r\n" media type:\t\t\t%s\n"\r\n" OC-3 revision:\t\t0x%x\n"\r\n" OC-3 mode:\t\t\t%s",\r\nfw_release >> 16, fw_release << 16 >> 24, fw_release << 24 >> 24,\r\nmon960_release >> 16, mon960_release << 16 >> 16,\r\nmedia_name[ media_index ],\r\noc3_revision,\r\noc3_mode[ oc3_index ]);\r\n}\r\nif (!left--) {\r\nstruct cp_monitor __iomem * cp_monitor = fore200e->cp_monitor;\r\nreturn sprintf(page,\r\n"\n\n"\r\n" monitor:\n"\r\n" version number:\t\t%d\n"\r\n" boot status word:\t\t0x%08x\n",\r\nfore200e->bus->read(&cp_monitor->mon_version),\r\nfore200e->bus->read(&cp_monitor->bstat));\r\n}\r\nif (!left--)\r\nreturn sprintf(page,\r\n"\n"\r\n" device statistics:\n"\r\n" 4b5b:\n"\r\n" crc_header_errors:\t\t%10u\n"\r\n" framing_errors:\t\t%10u\n",\r\nbe32_to_cpu(fore200e->stats->phy.crc_header_errors),\r\nbe32_to_cpu(fore200e->stats->phy.framing_errors));\r\nif (!left--)\r\nreturn sprintf(page, "\n"\r\n" OC-3:\n"\r\n" section_bip8_errors:\t%10u\n"\r\n" path_bip8_errors:\t\t%10u\n"\r\n" line_bip24_errors:\t\t%10u\n"\r\n" line_febe_errors:\t\t%10u\n"\r\n" path_febe_errors:\t\t%10u\n"\r\n" corr_hcs_errors:\t\t%10u\n"\r\n" ucorr_hcs_errors:\t\t%10u\n",\r\nbe32_to_cpu(fore200e->stats->oc3.section_bip8_errors),\r\nbe32_to_cpu(fore200e->stats->oc3.path_bip8_errors),\r\nbe32_to_cpu(fore200e->stats->oc3.line_bip24_errors),\r\nbe32_to_cpu(fore200e->stats->oc3.line_febe_errors),\r\nbe32_to_cpu(fore200e->stats->oc3.path_febe_errors),\r\nbe32_to_cpu(fore200e->stats->oc3.corr_hcs_errors),\r\nbe32_to_cpu(fore200e->stats->oc3.ucorr_hcs_errors));\r\nif (!left--)\r\nreturn sprintf(page,"\n"\r\n" ATM:\t\t\t\t cells\n"\r\n" TX:\t\t\t%10u\n"\r\n" RX:\t\t\t%10u\n"\r\n" vpi out of range:\t\t%10u\n"\r\n" vpi no conn:\t\t%10u\n"\r\n" vci out of range:\t\t%10u\n"\r\n" vci no conn:\t\t%10u\n",\r\nbe32_to_cpu(fore200e->stats->atm.cells_transmitted),\r\nbe32_to_cpu(fore200e->stats->atm.cells_received),\r\nbe32_to_cpu(fore200e->stats->atm.vpi_bad_range),\r\nbe32_to_cpu(fore200e->stats->atm.vpi_no_conn),\r\nbe32_to_cpu(fore200e->stats->atm.vci_bad_range),\r\nbe32_to_cpu(fore200e->stats->atm.vci_no_conn));\r\nif (!left--)\r\nreturn sprintf(page,"\n"\r\n" AAL0:\t\t\t cells\n"\r\n" TX:\t\t\t%10u\n"\r\n" RX:\t\t\t%10u\n"\r\n" dropped:\t\t\t%10u\n",\r\nbe32_to_cpu(fore200e->stats->aal0.cells_transmitted),\r\nbe32_to_cpu(fore200e->stats->aal0.cells_received),\r\nbe32_to_cpu(fore200e->stats->aal0.cells_dropped));\r\nif (!left--)\r\nreturn sprintf(page,"\n"\r\n" AAL3/4:\n"\r\n" SAR sublayer:\t\t cells\n"\r\n" TX:\t\t\t%10u\n"\r\n" RX:\t\t\t%10u\n"\r\n" dropped:\t\t\t%10u\n"\r\n" CRC errors:\t\t%10u\n"\r\n" protocol errors:\t\t%10u\n\n"\r\n" CS sublayer:\t\t PDUs\n"\r\n" TX:\t\t\t%10u\n"\r\n" RX:\t\t\t%10u\n"\r\n" dropped:\t\t\t%10u\n"\r\n" protocol errors:\t\t%10u\n",\r\nbe32_to_cpu(fore200e->stats->aal34.cells_transmitted),\r\nbe32_to_cpu(fore200e->stats->aal34.cells_received),\r\nbe32_to_cpu(fore200e->stats->aal34.cells_dropped),\r\nbe32_to_cpu(fore200e->stats->aal34.cells_crc_errors),\r\nbe32_to_cpu(fore200e->stats->aal34.cells_protocol_errors),\r\nbe32_to_cpu(fore200e->stats->aal34.cspdus_transmitted),\r\nbe32_to_cpu(fore200e->stats->aal34.cspdus_received),\r\nbe32_to_cpu(fore200e->stats->aal34.cspdus_dropped),\r\nbe32_to_cpu(fore200e->stats->aal34.cspdus_protocol_errors));\r\nif (!left--)\r\nreturn sprintf(page,"\n"\r\n" AAL5:\n"\r\n" SAR sublayer:\t\t cells\n"\r\n" TX:\t\t\t%10u\n"\r\n" RX:\t\t\t%10u\n"\r\n" dropped:\t\t\t%10u\n"\r\n" congestions:\t\t%10u\n\n"\r\n" CS sublayer:\t\t PDUs\n"\r\n" TX:\t\t\t%10u\n"\r\n" RX:\t\t\t%10u\n"\r\n" dropped:\t\t\t%10u\n"\r\n" CRC errors:\t\t%10u\n"\r\n" protocol errors:\t\t%10u\n",\r\nbe32_to_cpu(fore200e->stats->aal5.cells_transmitted),\r\nbe32_to_cpu(fore200e->stats->aal5.cells_received),\r\nbe32_to_cpu(fore200e->stats->aal5.cells_dropped),\r\nbe32_to_cpu(fore200e->stats->aal5.congestion_experienced),\r\nbe32_to_cpu(fore200e->stats->aal5.cspdus_transmitted),\r\nbe32_to_cpu(fore200e->stats->aal5.cspdus_received),\r\nbe32_to_cpu(fore200e->stats->aal5.cspdus_dropped),\r\nbe32_to_cpu(fore200e->stats->aal5.cspdus_crc_errors),\r\nbe32_to_cpu(fore200e->stats->aal5.cspdus_protocol_errors));\r\nif (!left--)\r\nreturn sprintf(page,"\n"\r\n" AUX:\t\t allocation failures\n"\r\n" small b1:\t\t\t%10u\n"\r\n" large b1:\t\t\t%10u\n"\r\n" small b2:\t\t\t%10u\n"\r\n" large b2:\t\t\t%10u\n"\r\n" RX PDUs:\t\t\t%10u\n"\r\n" TX PDUs:\t\t\t%10lu\n",\r\nbe32_to_cpu(fore200e->stats->aux.small_b1_failed),\r\nbe32_to_cpu(fore200e->stats->aux.large_b1_failed),\r\nbe32_to_cpu(fore200e->stats->aux.small_b2_failed),\r\nbe32_to_cpu(fore200e->stats->aux.large_b2_failed),\r\nbe32_to_cpu(fore200e->stats->aux.rpd_alloc_failed),\r\nfore200e->tx_sat);\r\nif (!left--)\r\nreturn sprintf(page,"\n"\r\n" receive carrier:\t\t\t%s\n",\r\nfore200e->stats->aux.receive_carrier ? "ON" : "OFF!");\r\nif (!left--) {\r\nreturn sprintf(page,"\n"\r\n" VCCs:\n address VPI VCI AAL "\r\n"TX PDUs TX min/max size RX PDUs RX min/max size\n");\r\n}\r\nfor (i = 0; i < NBR_CONNECT; i++) {\r\nvcc = fore200e->vc_map[i].vcc;\r\nif (vcc == NULL)\r\ncontinue;\r\nspin_lock_irqsave(&fore200e->q_lock, flags);\r\nif (vcc && test_bit(ATM_VF_READY, &vcc->flags) && !left--) {\r\nfore200e_vcc = FORE200E_VCC(vcc);\r\nASSERT(fore200e_vcc);\r\nlen = sprintf(page,\r\n" %08x %03d %05d %1d %09lu %05d/%05d %09lu %05d/%05d\n",\r\n(u32)(unsigned long)vcc,\r\nvcc->vpi, vcc->vci, fore200e_atm2fore_aal(vcc->qos.aal),\r\nfore200e_vcc->tx_pdu,\r\nfore200e_vcc->tx_min_pdu > 0xFFFF ? 0 : fore200e_vcc->tx_min_pdu,\r\nfore200e_vcc->tx_max_pdu,\r\nfore200e_vcc->rx_pdu,\r\nfore200e_vcc->rx_min_pdu > 0xFFFF ? 0 : fore200e_vcc->rx_min_pdu,\r\nfore200e_vcc->rx_max_pdu);\r\nspin_unlock_irqrestore(&fore200e->q_lock, flags);\r\nreturn len;\r\n}\r\nspin_unlock_irqrestore(&fore200e->q_lock, flags);\r\n}\r\nreturn 0;\r\n}
