static irqreturn_t soc_irq_thread_fn(int irq, void *dev_data)\r\n{\r\npr_debug("proc_thermal_interrupt\n");\r\nintel_soc_dts_iosf_interrupt_handler(soc_dts);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int __init intel_soc_thermal_init(void)\r\n{\r\nint err = 0;\r\nconst struct x86_cpu_id *match_cpu;\r\nmatch_cpu = x86_match_cpu(soc_thermal_ids);\r\nif (!match_cpu)\r\nreturn -ENODEV;\r\nsoc_dts = intel_soc_dts_iosf_init(INTEL_SOC_DTS_INTERRUPT_APIC, 2, 1);\r\nif (IS_ERR(soc_dts)) {\r\nerr = PTR_ERR(soc_dts);\r\nreturn err;\r\n}\r\nsoc_dts_thres_irq = (int)match_cpu->driver_data;\r\nif (soc_dts_thres_irq) {\r\nerr = request_threaded_irq(soc_dts_thres_irq, NULL,\r\nsoc_irq_thread_fn,\r\nIRQF_TRIGGER_RISING | IRQF_ONESHOT,\r\n"soc_dts", soc_dts);\r\nif (err) {\r\npr_err("request_threaded_irq ret %d\n", err);\r\ngoto error_irq;\r\n}\r\n}\r\nerr = intel_soc_dts_iosf_add_read_only_critical_trip(soc_dts,\r\ncrit_offset);\r\nif (err)\r\ngoto error_trips;\r\nreturn 0;\r\nerror_trips:\r\nif (soc_dts_thres_irq)\r\nfree_irq(soc_dts_thres_irq, soc_dts);\r\nerror_irq:\r\nintel_soc_dts_iosf_exit(soc_dts);\r\nreturn err;\r\n}\r\nstatic void __exit intel_soc_thermal_exit(void)\r\n{\r\nif (soc_dts_thres_irq)\r\nfree_irq(soc_dts_thres_irq, soc_dts);\r\nintel_soc_dts_iosf_exit(soc_dts);\r\n}
