static inline int drci_rd_reg(struct usb_device *dev, u16 reg, u16 *buf)\r\n{\r\nint retval;\r\nu16 *dma_buf = kzalloc(sizeof(u16), GFP_KERNEL);\r\nu8 req_type = USB_DIR_IN | USB_TYPE_VENDOR | USB_RECIP_DEVICE;\r\nif (!dma_buf)\r\nreturn -ENOMEM;\r\nretval = usb_control_msg(dev, usb_rcvctrlpipe(dev, 0),\r\nDRCI_READ_REQ, req_type,\r\n0x0000,\r\nreg, dma_buf, sizeof(u16), 5 * HZ);\r\n*buf = le16_to_cpu(*dma_buf);\r\nkfree(dma_buf);\r\nreturn retval;\r\n}\r\nstatic inline int drci_wr_reg(struct usb_device *dev, u16 reg, u16 data)\r\n{\r\nreturn usb_control_msg(dev,\r\nusb_sndctrlpipe(dev, 0),\r\nDRCI_WRITE_REQ,\r\nUSB_DIR_OUT | USB_TYPE_VENDOR | USB_RECIP_DEVICE,\r\ndata,\r\nreg,\r\nNULL,\r\n0,\r\n5 * HZ);\r\n}\r\nstatic void free_anchored_buffers(struct most_dev *mdev, unsigned int channel)\r\n{\r\nstruct mbo *mbo;\r\nstruct buf_anchor *anchor, *tmp;\r\nunsigned long flags;\r\nspin_lock_irqsave(&mdev->anchor_list_lock[channel], flags);\r\nlist_for_each_entry_safe(anchor, tmp, &mdev->anchor_list[channel],\r\nlist) {\r\nstruct urb *urb = anchor->urb;\r\nspin_unlock_irqrestore(&mdev->anchor_list_lock[channel], flags);\r\nif (likely(urb)) {\r\nmbo = urb->context;\r\nif (!irqs_disabled()) {\r\nusb_kill_urb(urb);\r\n} else {\r\nusb_unlink_urb(urb);\r\nwait_for_completion(&anchor->urb_compl);\r\n}\r\nif ((mbo) && (mbo->complete)) {\r\nmbo->status = MBO_E_CLOSE;\r\nmbo->processed_length = 0;\r\nmbo->complete(mbo);\r\n}\r\nusb_free_urb(urb);\r\n}\r\nspin_lock_irqsave(&mdev->anchor_list_lock[channel], flags);\r\nlist_del(&anchor->list);\r\nkfree(anchor);\r\n}\r\nspin_unlock_irqrestore(&mdev->anchor_list_lock[channel], flags);\r\n}\r\nstatic unsigned int get_stream_frame_size(struct most_channel_config *cfg)\r\n{\r\nunsigned int frame_size = 0;\r\nunsigned int sub_size = cfg->subbuffer_size;\r\nif (!sub_size) {\r\npr_warn("Misconfig: Subbuffer size zero.\n");\r\nreturn frame_size;\r\n}\r\nswitch (cfg->data_type) {\r\ncase MOST_CH_ISOC_AVP:\r\nframe_size = AV_PACKETS_PER_XACT * sub_size;\r\nbreak;\r\ncase MOST_CH_SYNC:\r\nif (cfg->packets_per_xact == 0) {\r\npr_warn("Misconfig: Packets per XACT zero\n");\r\nframe_size = 0;\r\n} else if (cfg->packets_per_xact == 0xFF) {\r\nframe_size = (USB_MTU / sub_size) * sub_size;\r\n} else {\r\nframe_size = cfg->packets_per_xact * sub_size;\r\n}\r\nbreak;\r\ndefault:\r\npr_warn("Query frame size of non-streaming channel\n");\r\nbreak;\r\n}\r\nreturn frame_size;\r\n}\r\nstatic int hdm_poison_channel(struct most_interface *iface, int channel)\r\n{\r\nstruct most_dev *mdev;\r\nmdev = to_mdev(iface);\r\nif (unlikely(!iface)) {\r\ndev_warn(&mdev->usb_device->dev, "Poison: Bad interface.\n");\r\nreturn -EIO;\r\n}\r\nif (unlikely((channel < 0) || (channel >= iface->num_channels))) {\r\ndev_warn(&mdev->usb_device->dev, "Channel ID out of range.\n");\r\nreturn -ECHRNG;\r\n}\r\nmdev->is_channel_healthy[channel] = false;\r\nmutex_lock(&mdev->io_mutex);\r\nfree_anchored_buffers(mdev, channel);\r\nif (mdev->padding_active[channel])\r\nmdev->padding_active[channel] = false;\r\nif (mdev->conf[channel].data_type == MOST_CH_ASYNC) {\r\ndel_timer_sync(&mdev->link_stat_timer);\r\ncancel_work_sync(&mdev->poll_work_obj);\r\n}\r\nmutex_unlock(&mdev->io_mutex);\r\nreturn 0;\r\n}\r\nstatic int hdm_add_padding(struct most_dev *mdev, int channel, struct mbo *mbo)\r\n{\r\nstruct most_channel_config *conf = &mdev->conf[channel];\r\nunsigned int j, num_frames, frame_size;\r\nu16 rd_addr, wr_addr;\r\nframe_size = get_stream_frame_size(conf);\r\nif (!frame_size)\r\nreturn -EIO;\r\nnum_frames = mbo->buffer_length / frame_size;\r\nif (num_frames < 1) {\r\ndev_err(&mdev->usb_device->dev,\r\n"Missed minimal transfer unit.\n");\r\nreturn -EIO;\r\n}\r\nfor (j = 1; j < num_frames; j++) {\r\nwr_addr = (num_frames - j) * USB_MTU;\r\nrd_addr = (num_frames - j) * frame_size;\r\nmemmove(mbo->virt_address + wr_addr,\r\nmbo->virt_address + rd_addr,\r\nframe_size);\r\n}\r\nmbo->buffer_length = num_frames * USB_MTU;\r\nreturn 0;\r\n}\r\nstatic int hdm_remove_padding(struct most_dev *mdev, int channel,\r\nstruct mbo *mbo)\r\n{\r\nunsigned int j, num_frames, frame_size;\r\nstruct most_channel_config *const conf = &mdev->conf[channel];\r\nframe_size = get_stream_frame_size(conf);\r\nif (!frame_size)\r\nreturn -EIO;\r\nnum_frames = mbo->processed_length / USB_MTU;\r\nfor (j = 1; j < num_frames; j++)\r\nmemmove(mbo->virt_address + frame_size * j,\r\nmbo->virt_address + USB_MTU * j,\r\nframe_size);\r\nmbo->processed_length = frame_size * num_frames;\r\nreturn 0;\r\n}\r\nstatic void hdm_write_completion(struct urb *urb)\r\n{\r\nstruct mbo *mbo;\r\nstruct buf_anchor *anchor;\r\nstruct most_dev *mdev;\r\nstruct device *dev;\r\nunsigned int channel;\r\nunsigned long flags;\r\nmbo = urb->context;\r\nanchor = mbo->priv;\r\nmdev = to_mdev(mbo->ifp);\r\nchannel = mbo->hdm_channel_id;\r\ndev = &mdev->usb_device->dev;\r\nif ((urb->status == -ENOENT) || (urb->status == -ECONNRESET) ||\r\n(!mdev->is_channel_healthy[channel])) {\r\ncomplete(&anchor->urb_compl);\r\nreturn;\r\n}\r\nif (unlikely(urb->status && !(urb->status == -ENOENT ||\r\nurb->status == -ECONNRESET ||\r\nurb->status == -ESHUTDOWN))) {\r\nmbo->processed_length = 0;\r\nswitch (urb->status) {\r\ncase -EPIPE:\r\ndev_warn(dev, "Broken OUT pipe detected\n");\r\nmost_stop_enqueue(&mdev->iface, channel);\r\nmbo->status = MBO_E_INVAL;\r\nusb_unlink_urb(urb);\r\nINIT_WORK(&anchor->clear_work_obj, wq_clear_halt);\r\nqueue_work(schedule_usb_work, &anchor->clear_work_obj);\r\nreturn;\r\ncase -ENODEV:\r\ncase -EPROTO:\r\nmbo->status = MBO_E_CLOSE;\r\nbreak;\r\ndefault:\r\nmbo->status = MBO_E_INVAL;\r\nbreak;\r\n}\r\n} else {\r\nmbo->status = MBO_SUCCESS;\r\nmbo->processed_length = urb->actual_length;\r\n}\r\nspin_lock_irqsave(&mdev->anchor_list_lock[channel], flags);\r\nlist_del(&anchor->list);\r\nspin_unlock_irqrestore(&mdev->anchor_list_lock[channel], flags);\r\nkfree(anchor);\r\nif (likely(mbo->complete))\r\nmbo->complete(mbo);\r\nusb_free_urb(urb);\r\n}\r\nstatic void hdm_read_completion(struct urb *urb)\r\n{\r\nstruct mbo *mbo;\r\nstruct buf_anchor *anchor;\r\nstruct most_dev *mdev;\r\nstruct device *dev;\r\nunsigned long flags;\r\nunsigned int channel;\r\nmbo = urb->context;\r\nanchor = mbo->priv;\r\nmdev = to_mdev(mbo->ifp);\r\nchannel = mbo->hdm_channel_id;\r\ndev = &mdev->usb_device->dev;\r\nif ((urb->status == -ENOENT) || (urb->status == -ECONNRESET) ||\r\n(!mdev->is_channel_healthy[channel])) {\r\ncomplete(&anchor->urb_compl);\r\nreturn;\r\n}\r\nif (unlikely(urb->status && !(urb->status == -ENOENT ||\r\nurb->status == -ECONNRESET ||\r\nurb->status == -ESHUTDOWN))) {\r\nmbo->processed_length = 0;\r\nswitch (urb->status) {\r\ncase -EPIPE:\r\ndev_warn(dev, "Broken IN pipe detected\n");\r\nmbo->status = MBO_E_INVAL;\r\nusb_unlink_urb(urb);\r\nINIT_WORK(&anchor->clear_work_obj, wq_clear_halt);\r\nqueue_work(schedule_usb_work, &anchor->clear_work_obj);\r\nreturn;\r\ncase -ENODEV:\r\ncase -EPROTO:\r\nmbo->status = MBO_E_CLOSE;\r\nbreak;\r\ncase -EOVERFLOW:\r\ndev_warn(dev, "Babble on IN pipe detected\n");\r\ndefault:\r\nmbo->status = MBO_E_INVAL;\r\nbreak;\r\n}\r\n} else {\r\nmbo->processed_length = urb->actual_length;\r\nif (!mdev->padding_active[channel]) {\r\nmbo->status = MBO_SUCCESS;\r\n} else {\r\nif (hdm_remove_padding(mdev, channel, mbo)) {\r\nmbo->processed_length = 0;\r\nmbo->status = MBO_E_INVAL;\r\n} else {\r\nmbo->status = MBO_SUCCESS;\r\n}\r\n}\r\n}\r\nspin_lock_irqsave(&mdev->anchor_list_lock[channel], flags);\r\nlist_del(&anchor->list);\r\nspin_unlock_irqrestore(&mdev->anchor_list_lock[channel], flags);\r\nkfree(anchor);\r\nif (likely(mbo->complete))\r\nmbo->complete(mbo);\r\nusb_free_urb(urb);\r\n}\r\nstatic int hdm_enqueue(struct most_interface *iface, int channel,\r\nstruct mbo *mbo)\r\n{\r\nstruct most_dev *mdev;\r\nstruct buf_anchor *anchor;\r\nstruct most_channel_config *conf;\r\nstruct device *dev;\r\nint retval = 0;\r\nstruct urb *urb;\r\nunsigned long flags;\r\nunsigned long length;\r\nvoid *virt_address;\r\nif (unlikely(!iface || !mbo))\r\nreturn -EIO;\r\nif (unlikely(iface->num_channels <= channel) || (channel < 0))\r\nreturn -ECHRNG;\r\nmdev = to_mdev(iface);\r\nconf = &mdev->conf[channel];\r\ndev = &mdev->usb_device->dev;\r\nif (!mdev->usb_device)\r\nreturn -ENODEV;\r\nurb = usb_alloc_urb(NO_ISOCHRONOUS_URB, GFP_ATOMIC);\r\nif (!urb) {\r\ndev_err(dev, "Failed to allocate URB\n");\r\nreturn -ENOMEM;\r\n}\r\nanchor = kzalloc(sizeof(*anchor), GFP_ATOMIC);\r\nif (!anchor) {\r\nretval = -ENOMEM;\r\ngoto _error;\r\n}\r\nanchor->urb = urb;\r\ninit_completion(&anchor->urb_compl);\r\nmbo->priv = anchor;\r\nspin_lock_irqsave(&mdev->anchor_list_lock[channel], flags);\r\nlist_add_tail(&anchor->list, &mdev->anchor_list[channel]);\r\nspin_unlock_irqrestore(&mdev->anchor_list_lock[channel], flags);\r\nif ((mdev->padding_active[channel]) &&\r\n(conf->direction & MOST_CH_TX))\r\nif (hdm_add_padding(mdev, channel, mbo)) {\r\nretval = -EIO;\r\ngoto _error_1;\r\n}\r\nurb->transfer_dma = mbo->bus_address;\r\nvirt_address = mbo->virt_address;\r\nlength = mbo->buffer_length;\r\nif (conf->direction & MOST_CH_TX) {\r\nusb_fill_bulk_urb(urb, mdev->usb_device,\r\nusb_sndbulkpipe(mdev->usb_device,\r\nmdev->ep_address[channel]),\r\nvirt_address,\r\nlength,\r\nhdm_write_completion,\r\nmbo);\r\nif (conf->data_type != MOST_CH_ISOC_AVP)\r\nurb->transfer_flags |= URB_ZERO_PACKET;\r\n} else {\r\nusb_fill_bulk_urb(urb, mdev->usb_device,\r\nusb_rcvbulkpipe(mdev->usb_device,\r\nmdev->ep_address[channel]),\r\nvirt_address,\r\nlength + conf->extra_len,\r\nhdm_read_completion,\r\nmbo);\r\n}\r\nurb->transfer_flags |= URB_NO_TRANSFER_DMA_MAP;\r\nretval = usb_submit_urb(urb, GFP_KERNEL);\r\nif (retval) {\r\ndev_err(dev, "URB submit failed with error %d.\n", retval);\r\ngoto _error_1;\r\n}\r\nreturn 0;\r\n_error_1:\r\nspin_lock_irqsave(&mdev->anchor_list_lock[channel], flags);\r\nlist_del(&anchor->list);\r\nspin_unlock_irqrestore(&mdev->anchor_list_lock[channel], flags);\r\nkfree(anchor);\r\n_error:\r\nusb_free_urb(urb);\r\nreturn retval;\r\n}\r\nstatic int hdm_configure_channel(struct most_interface *iface, int channel,\r\nstruct most_channel_config *conf)\r\n{\r\nunsigned int num_frames;\r\nunsigned int frame_size;\r\nunsigned int temp_size;\r\nunsigned int tail_space;\r\nstruct most_dev *mdev;\r\nstruct device *dev;\r\nmdev = to_mdev(iface);\r\nmdev->is_channel_healthy[channel] = true;\r\ndev = &mdev->usb_device->dev;\r\nif (unlikely(!iface || !conf)) {\r\ndev_err(dev, "Bad interface or config pointer.\n");\r\nreturn -EINVAL;\r\n}\r\nif (unlikely((channel < 0) || (channel >= iface->num_channels))) {\r\ndev_err(dev, "Channel ID out of range.\n");\r\nreturn -EINVAL;\r\n}\r\nif ((!conf->num_buffers) || (!conf->buffer_size)) {\r\ndev_err(dev, "Misconfig: buffer size or #buffers zero.\n");\r\nreturn -EINVAL;\r\n}\r\nif (!(conf->data_type == MOST_CH_SYNC) &&\r\n!((conf->data_type == MOST_CH_ISOC_AVP) &&\r\n(conf->packets_per_xact != 0xFF))) {\r\nmdev->padding_active[channel] = false;\r\ngoto exit;\r\n}\r\nmdev->padding_active[channel] = true;\r\ntemp_size = conf->buffer_size;\r\nframe_size = get_stream_frame_size(conf);\r\nif ((frame_size == 0) || (frame_size > USB_MTU)) {\r\ndev_warn(dev, "Misconfig: frame size wrong\n");\r\nreturn -EINVAL;\r\n}\r\nif (conf->buffer_size % frame_size) {\r\nu16 tmp_val;\r\ntmp_val = conf->buffer_size / frame_size;\r\nconf->buffer_size = tmp_val * frame_size;\r\ndev_notice(dev,\r\n"Channel %d - rounding buffer size to %d bytes, channel config says %d bytes\n",\r\nchannel,\r\nconf->buffer_size,\r\ntemp_size);\r\n}\r\nnum_frames = conf->buffer_size / frame_size;\r\ntail_space = num_frames * (USB_MTU - frame_size);\r\ntemp_size += tail_space;\r\nconf->extra_len = (CEILING(temp_size, USB_MTU) * USB_MTU)\r\n- conf->buffer_size;\r\nexit:\r\nmdev->conf[channel] = *conf;\r\nreturn 0;\r\n}\r\nstatic int hdm_update_netinfo(struct most_dev *mdev)\r\n{\r\nstruct usb_device *usb_device = mdev->usb_device;\r\nstruct device *dev = &usb_device->dev;\r\nu16 hi, mi, lo, link;\r\nif (!is_valid_ether_addr(mdev->hw_addr)) {\r\nif (drci_rd_reg(usb_device, DRCI_REG_HW_ADDR_HI, &hi) < 0) {\r\ndev_err(dev, "Vendor request \"hw_addr_hi\" failed\n");\r\nreturn -1;\r\n}\r\nif (drci_rd_reg(usb_device, DRCI_REG_HW_ADDR_MI, &mi) < 0) {\r\ndev_err(dev, "Vendor request \"hw_addr_mid\" failed\n");\r\nreturn -1;\r\n}\r\nif (drci_rd_reg(usb_device, DRCI_REG_HW_ADDR_LO, &lo) < 0) {\r\ndev_err(dev, "Vendor request \"hw_addr_low\" failed\n");\r\nreturn -1;\r\n}\r\nmutex_lock(&mdev->io_mutex);\r\nmdev->hw_addr[0] = hi >> 8;\r\nmdev->hw_addr[1] = hi;\r\nmdev->hw_addr[2] = mi >> 8;\r\nmdev->hw_addr[3] = mi;\r\nmdev->hw_addr[4] = lo >> 8;\r\nmdev->hw_addr[5] = lo;\r\nmutex_unlock(&mdev->io_mutex);\r\n}\r\nif (drci_rd_reg(usb_device, DRCI_REG_NI_STATE, &link) < 0) {\r\ndev_err(dev, "Vendor request \"link status\" failed\n");\r\nreturn -1;\r\n}\r\nmutex_lock(&mdev->io_mutex);\r\nmdev->link_stat = link;\r\nmutex_unlock(&mdev->io_mutex);\r\nreturn 0;\r\n}\r\nstatic void hdm_request_netinfo(struct most_interface *iface, int channel)\r\n{\r\nstruct most_dev *mdev;\r\nBUG_ON(!iface);\r\nmdev = to_mdev(iface);\r\nmdev->link_stat_timer.expires = jiffies + HZ;\r\nmod_timer(&mdev->link_stat_timer, mdev->link_stat_timer.expires);\r\n}\r\nstatic void link_stat_timer_handler(unsigned long data)\r\n{\r\nstruct most_dev *mdev = (struct most_dev *)data;\r\nqueue_work(schedule_usb_work, &mdev->poll_work_obj);\r\nmdev->link_stat_timer.expires = jiffies + (2 * HZ);\r\nadd_timer(&mdev->link_stat_timer);\r\n}\r\nstatic void wq_netinfo(struct work_struct *wq_obj)\r\n{\r\nstruct most_dev *mdev;\r\nint i, prev_link_stat;\r\nu8 prev_hw_addr[6];\r\nmdev = to_mdev_from_work(wq_obj);\r\nprev_link_stat = mdev->link_stat;\r\nfor (i = 0; i < 6; i++)\r\nprev_hw_addr[i] = mdev->hw_addr[i];\r\nif (hdm_update_netinfo(mdev) < 0)\r\nreturn;\r\nif ((prev_link_stat != mdev->link_stat) ||\r\n(prev_hw_addr[0] != mdev->hw_addr[0]) ||\r\n(prev_hw_addr[1] != mdev->hw_addr[1]) ||\r\n(prev_hw_addr[2] != mdev->hw_addr[2]) ||\r\n(prev_hw_addr[3] != mdev->hw_addr[3]) ||\r\n(prev_hw_addr[4] != mdev->hw_addr[4]) ||\r\n(prev_hw_addr[5] != mdev->hw_addr[5]))\r\nmost_deliver_netinfo(&mdev->iface, mdev->link_stat,\r\n&mdev->hw_addr[0]);\r\n}\r\nstatic void wq_clear_halt(struct work_struct *wq_obj)\r\n{\r\nstruct buf_anchor *anchor;\r\nstruct most_dev *mdev;\r\nstruct mbo *mbo;\r\nstruct urb *urb;\r\nunsigned int channel;\r\nunsigned long flags;\r\nanchor = to_buf_anchor(wq_obj);\r\nurb = anchor->urb;\r\nmbo = urb->context;\r\nmdev = to_mdev(mbo->ifp);\r\nchannel = mbo->hdm_channel_id;\r\nif (usb_clear_halt(urb->dev, urb->pipe))\r\ndev_warn(&mdev->usb_device->dev, "Failed to reset endpoint.\n");\r\nusb_free_urb(urb);\r\nspin_lock_irqsave(&mdev->anchor_list_lock[channel], flags);\r\nlist_del(&anchor->list);\r\nspin_unlock_irqrestore(&mdev->anchor_list_lock[channel], flags);\r\nif (likely(mbo->complete))\r\nmbo->complete(mbo);\r\nif (mdev->conf[channel].direction & MOST_CH_TX)\r\nmost_resume_enqueue(&mdev->iface, channel);\r\nkfree(anchor);\r\n}\r\nstatic ssize_t dci_attr_show(struct kobject *kobj, struct attribute *attr,\r\nchar *buf)\r\n{\r\nstruct most_dci_attribute *dci_attr = to_dci_attr(attr);\r\nstruct most_dci_obj *dci_obj = to_dci_obj(kobj);\r\nif (!dci_attr->show)\r\nreturn -EIO;\r\nreturn dci_attr->show(dci_obj, dci_attr, buf);\r\n}\r\nstatic ssize_t dci_attr_store(struct kobject *kobj,\r\nstruct attribute *attr,\r\nconst char *buf,\r\nsize_t len)\r\n{\r\nstruct most_dci_attribute *dci_attr = to_dci_attr(attr);\r\nstruct most_dci_obj *dci_obj = to_dci_obj(kobj);\r\nif (!dci_attr->store)\r\nreturn -EIO;\r\nreturn dci_attr->store(dci_obj, dci_attr, buf, len);\r\n}\r\nstatic void most_dci_release(struct kobject *kobj)\r\n{\r\nstruct most_dci_obj *dci_obj = to_dci_obj(kobj);\r\nkfree(dci_obj);\r\n}\r\nstatic ssize_t show_value(struct most_dci_obj *dci_obj,\r\nstruct most_dci_attribute *attr, char *buf)\r\n{\r\nu16 tmp_val;\r\nu16 reg_addr;\r\nint err;\r\nif (!strcmp(attr->attr.name, "ni_state"))\r\nreg_addr = DRCI_REG_NI_STATE;\r\nelse if (!strcmp(attr->attr.name, "packet_bandwidth"))\r\nreg_addr = DRCI_REG_PACKET_BW;\r\nelse if (!strcmp(attr->attr.name, "node_address"))\r\nreg_addr = DRCI_REG_NODE_ADDR;\r\nelse if (!strcmp(attr->attr.name, "node_position"))\r\nreg_addr = DRCI_REG_NODE_POS;\r\nelse if (!strcmp(attr->attr.name, "mep_filter"))\r\nreg_addr = DRCI_REG_MEP_FILTER;\r\nelse if (!strcmp(attr->attr.name, "mep_hash0"))\r\nreg_addr = DRCI_REG_HASH_TBL0;\r\nelse if (!strcmp(attr->attr.name, "mep_hash1"))\r\nreg_addr = DRCI_REG_HASH_TBL1;\r\nelse if (!strcmp(attr->attr.name, "mep_hash2"))\r\nreg_addr = DRCI_REG_HASH_TBL2;\r\nelse if (!strcmp(attr->attr.name, "mep_hash3"))\r\nreg_addr = DRCI_REG_HASH_TBL3;\r\nelse if (!strcmp(attr->attr.name, "mep_eui48_hi"))\r\nreg_addr = DRCI_REG_HW_ADDR_HI;\r\nelse if (!strcmp(attr->attr.name, "mep_eui48_mi"))\r\nreg_addr = DRCI_REG_HW_ADDR_MI;\r\nelse if (!strcmp(attr->attr.name, "mep_eui48_lo"))\r\nreg_addr = DRCI_REG_HW_ADDR_LO;\r\nelse\r\nreturn -EIO;\r\nerr = drci_rd_reg(dci_obj->usb_device, reg_addr, &tmp_val);\r\nif (err < 0)\r\nreturn err;\r\nreturn snprintf(buf, PAGE_SIZE, "%04x\n", tmp_val);\r\n}\r\nstatic ssize_t store_value(struct most_dci_obj *dci_obj,\r\nstruct most_dci_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nu16 val;\r\nu16 reg_addr;\r\nint err;\r\nif (!strcmp(attr->attr.name, "mep_filter"))\r\nreg_addr = DRCI_REG_MEP_FILTER;\r\nelse if (!strcmp(attr->attr.name, "mep_hash0"))\r\nreg_addr = DRCI_REG_HASH_TBL0;\r\nelse if (!strcmp(attr->attr.name, "mep_hash1"))\r\nreg_addr = DRCI_REG_HASH_TBL1;\r\nelse if (!strcmp(attr->attr.name, "mep_hash2"))\r\nreg_addr = DRCI_REG_HASH_TBL2;\r\nelse if (!strcmp(attr->attr.name, "mep_hash3"))\r\nreg_addr = DRCI_REG_HASH_TBL3;\r\nelse if (!strcmp(attr->attr.name, "mep_eui48_hi"))\r\nreg_addr = DRCI_REG_HW_ADDR_HI;\r\nelse if (!strcmp(attr->attr.name, "mep_eui48_mi"))\r\nreg_addr = DRCI_REG_HW_ADDR_MI;\r\nelse if (!strcmp(attr->attr.name, "mep_eui48_lo"))\r\nreg_addr = DRCI_REG_HW_ADDR_LO;\r\nelse\r\nreturn -EIO;\r\nerr = kstrtou16(buf, 16, &val);\r\nif (err)\r\nreturn err;\r\nerr = drci_wr_reg(dci_obj->usb_device, reg_addr, val);\r\nif (err < 0)\r\nreturn err;\r\nreturn count;\r\n}\r\nstatic struct\r\nmost_dci_obj *create_most_dci_obj(struct kobject *parent)\r\n{\r\nstruct most_dci_obj *most_dci;\r\nint retval;\r\nmost_dci = kzalloc(sizeof(*most_dci), GFP_KERNEL);\r\nif (!most_dci)\r\nreturn NULL;\r\nretval = kobject_init_and_add(&most_dci->kobj, &most_dci_ktype, parent,\r\n"dci");\r\nif (retval) {\r\nkobject_put(&most_dci->kobj);\r\nreturn NULL;\r\n}\r\nreturn most_dci;\r\n}\r\nstatic void destroy_most_dci_obj(struct most_dci_obj *p)\r\n{\r\nkobject_put(&p->kobj);\r\n}\r\nstatic int\r\nhdm_probe(struct usb_interface *interface, const struct usb_device_id *id)\r\n{\r\nunsigned int i;\r\nunsigned int num_endpoints;\r\nstruct most_channel_capability *tmp_cap;\r\nstruct most_dev *mdev;\r\nstruct usb_device *usb_dev;\r\nstruct device *dev;\r\nstruct usb_host_interface *usb_iface_desc;\r\nstruct usb_endpoint_descriptor *ep_desc;\r\nint ret = 0;\r\nint err;\r\nusb_iface_desc = interface->cur_altsetting;\r\nusb_dev = interface_to_usbdev(interface);\r\ndev = &usb_dev->dev;\r\nmdev = kzalloc(sizeof(*mdev), GFP_KERNEL);\r\nif (!mdev)\r\ngoto exit_ENOMEM;\r\nusb_set_intfdata(interface, mdev);\r\nnum_endpoints = usb_iface_desc->desc.bNumEndpoints;\r\nmutex_init(&mdev->io_mutex);\r\nINIT_WORK(&mdev->poll_work_obj, wq_netinfo);\r\nsetup_timer(&mdev->link_stat_timer, link_stat_timer_handler,\r\n(unsigned long)mdev);\r\nmdev->usb_device = usb_dev;\r\nmdev->link_stat_timer.expires = jiffies + (2 * HZ);\r\nmdev->iface.mod = hdm_usb_fops.owner;\r\nmdev->iface.interface = ITYPE_USB;\r\nmdev->iface.configure = hdm_configure_channel;\r\nmdev->iface.request_netinfo = hdm_request_netinfo;\r\nmdev->iface.enqueue = hdm_enqueue;\r\nmdev->iface.poison_channel = hdm_poison_channel;\r\nmdev->iface.description = mdev->description;\r\nmdev->iface.num_channels = num_endpoints;\r\nsnprintf(mdev->description, sizeof(mdev->description),\r\n"usb_device %d-%s:%d.%d",\r\nusb_dev->bus->busnum,\r\nusb_dev->devpath,\r\nusb_dev->config->desc.bConfigurationValue,\r\nusb_iface_desc->desc.bInterfaceNumber);\r\nmdev->conf = kcalloc(num_endpoints, sizeof(*mdev->conf), GFP_KERNEL);\r\nif (!mdev->conf)\r\ngoto exit_free;\r\nmdev->cap = kcalloc(num_endpoints, sizeof(*mdev->cap), GFP_KERNEL);\r\nif (!mdev->cap)\r\ngoto exit_free1;\r\nmdev->iface.channel_vector = mdev->cap;\r\nmdev->iface.priv = NULL;\r\nmdev->ep_address =\r\nkcalloc(num_endpoints, sizeof(*mdev->ep_address), GFP_KERNEL);\r\nif (!mdev->ep_address)\r\ngoto exit_free2;\r\nmdev->anchor_list =\r\nkcalloc(num_endpoints, sizeof(*mdev->anchor_list), GFP_KERNEL);\r\nif (!mdev->anchor_list)\r\ngoto exit_free3;\r\ntmp_cap = mdev->cap;\r\nfor (i = 0; i < num_endpoints; i++) {\r\nep_desc = &usb_iface_desc->endpoint[i].desc;\r\nmdev->ep_address[i] = ep_desc->bEndpointAddress;\r\nmdev->padding_active[i] = false;\r\nmdev->is_channel_healthy[i] = true;\r\nsnprintf(&mdev->suffix[i][0], MAX_SUFFIX_LEN, "ep%02x",\r\nmdev->ep_address[i]);\r\ntmp_cap->name_suffix = &mdev->suffix[i][0];\r\ntmp_cap->buffer_size_packet = MAX_BUF_SIZE;\r\ntmp_cap->buffer_size_streaming = MAX_BUF_SIZE;\r\ntmp_cap->num_buffers_packet = BUF_CHAIN_SIZE;\r\ntmp_cap->num_buffers_streaming = BUF_CHAIN_SIZE;\r\ntmp_cap->data_type = MOST_CH_CONTROL | MOST_CH_ASYNC |\r\nMOST_CH_ISOC_AVP | MOST_CH_SYNC;\r\nif (ep_desc->bEndpointAddress & USB_DIR_IN)\r\ntmp_cap->direction = MOST_CH_RX;\r\nelse\r\ntmp_cap->direction = MOST_CH_TX;\r\ntmp_cap++;\r\nINIT_LIST_HEAD(&mdev->anchor_list[i]);\r\nspin_lock_init(&mdev->anchor_list_lock[i]);\r\nerr = drci_wr_reg(usb_dev,\r\nDRCI_REG_BASE + DRCI_COMMAND +\r\nep_desc->bEndpointAddress * 16,\r\n1);\r\nif (err < 0)\r\npr_warn("DCI Sync for EP %02x failed",\r\nep_desc->bEndpointAddress);\r\n}\r\ndev_notice(dev, "claimed gadget: Vendor=%4.4x ProdID=%4.4x Bus=%02x Device=%02x\n",\r\nle16_to_cpu(usb_dev->descriptor.idVendor),\r\nle16_to_cpu(usb_dev->descriptor.idProduct),\r\nusb_dev->bus->busnum,\r\nusb_dev->devnum);\r\ndev_notice(dev, "device path: /sys/bus/usb/devices/%d-%s:%d.%d\n",\r\nusb_dev->bus->busnum,\r\nusb_dev->devpath,\r\nusb_dev->config->desc.bConfigurationValue,\r\nusb_iface_desc->desc.bInterfaceNumber);\r\nmdev->parent = most_register_interface(&mdev->iface);\r\nif (IS_ERR(mdev->parent)) {\r\nret = PTR_ERR(mdev->parent);\r\ngoto exit_free4;\r\n}\r\nmutex_lock(&mdev->io_mutex);\r\nif (le16_to_cpu(usb_dev->descriptor.idProduct) == USB_DEV_ID_INIC) {\r\nmdev->dci = create_most_dci_obj(mdev->parent);\r\nif (!mdev->dci) {\r\nmutex_unlock(&mdev->io_mutex);\r\nmost_deregister_interface(&mdev->iface);\r\nret = -ENOMEM;\r\ngoto exit_free4;\r\n}\r\nkobject_uevent(&mdev->dci->kobj, KOBJ_ADD);\r\nmdev->dci->usb_device = mdev->usb_device;\r\n}\r\nmutex_unlock(&mdev->io_mutex);\r\nreturn 0;\r\nexit_free4:\r\nkfree(mdev->anchor_list);\r\nexit_free3:\r\nkfree(mdev->ep_address);\r\nexit_free2:\r\nkfree(mdev->cap);\r\nexit_free1:\r\nkfree(mdev->conf);\r\nexit_free:\r\nkfree(mdev);\r\nexit_ENOMEM:\r\nif (ret == 0 || ret == -ENOMEM) {\r\nret = -ENOMEM;\r\ndev_err(dev, "out of memory\n");\r\n}\r\nreturn ret;\r\n}\r\nstatic void hdm_disconnect(struct usb_interface *interface)\r\n{\r\nstruct most_dev *mdev;\r\nmdev = usb_get_intfdata(interface);\r\nmutex_lock(&mdev->io_mutex);\r\nusb_set_intfdata(interface, NULL);\r\nmdev->usb_device = NULL;\r\nmutex_unlock(&mdev->io_mutex);\r\ndel_timer_sync(&mdev->link_stat_timer);\r\ncancel_work_sync(&mdev->poll_work_obj);\r\ndestroy_most_dci_obj(mdev->dci);\r\nmost_deregister_interface(&mdev->iface);\r\nkfree(mdev->anchor_list);\r\nkfree(mdev->cap);\r\nkfree(mdev->conf);\r\nkfree(mdev->ep_address);\r\nkfree(mdev);\r\n}\r\nstatic int __init hdm_usb_init(void)\r\n{\r\npr_info("hdm_usb_init()\n");\r\nif (usb_register(&hdm_usb)) {\r\npr_err("could not register hdm_usb driver\n");\r\nreturn -EIO;\r\n}\r\nschedule_usb_work = create_workqueue("hdmu_work");\r\nif (!schedule_usb_work) {\r\npr_err("could not create workqueue\n");\r\nusb_deregister(&hdm_usb);\r\nreturn -ENOMEM;\r\n}\r\nreturn 0;\r\n}\r\nstatic void __exit hdm_usb_exit(void)\r\n{\r\npr_info("hdm_usb_exit()\n");\r\ndestroy_workqueue(schedule_usb_work);\r\nusb_deregister(&hdm_usb);\r\n}
