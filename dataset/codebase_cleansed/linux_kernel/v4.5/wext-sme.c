int cfg80211_mgd_wext_connect(struct cfg80211_registered_device *rdev,\r\nstruct wireless_dev *wdev)\r\n{\r\nstruct cfg80211_cached_keys *ck = NULL;\r\nconst u8 *prev_bssid = NULL;\r\nint err, i;\r\nASSERT_RTNL();\r\nASSERT_WDEV_LOCK(wdev);\r\nif (!netif_running(wdev->netdev))\r\nreturn 0;\r\nwdev->wext.connect.ie = wdev->wext.ie;\r\nwdev->wext.connect.ie_len = wdev->wext.ie_len;\r\nwdev->wext.connect.bg_scan_period = -1;\r\nif (wdev->wext.keys) {\r\nwdev->wext.keys->def = wdev->wext.default_key;\r\nwdev->wext.keys->defmgmt = wdev->wext.default_mgmt_key;\r\nif (wdev->wext.default_key != -1)\r\nwdev->wext.connect.privacy = true;\r\n}\r\nif (!wdev->wext.connect.ssid_len)\r\nreturn 0;\r\nif (wdev->wext.keys) {\r\nck = kmemdup(wdev->wext.keys, sizeof(*ck), GFP_KERNEL);\r\nif (!ck)\r\nreturn -ENOMEM;\r\nfor (i = 0; i < 6; i++)\r\nck->params[i].key = ck->data[i];\r\n}\r\nif (wdev->wext.prev_bssid_valid)\r\nprev_bssid = wdev->wext.prev_bssid;\r\nerr = cfg80211_connect(rdev, wdev->netdev,\r\n&wdev->wext.connect, ck, prev_bssid);\r\nif (err)\r\nkzfree(ck);\r\nreturn err;\r\n}\r\nint cfg80211_mgd_wext_siwfreq(struct net_device *dev,\r\nstruct iw_request_info *info,\r\nstruct iw_freq *wextfreq, char *extra)\r\n{\r\nstruct wireless_dev *wdev = dev->ieee80211_ptr;\r\nstruct cfg80211_registered_device *rdev = wiphy_to_rdev(wdev->wiphy);\r\nstruct ieee80211_channel *chan = NULL;\r\nint err, freq;\r\nif (WARN_ON(wdev->iftype != NL80211_IFTYPE_STATION))\r\nreturn -EINVAL;\r\nfreq = cfg80211_wext_freq(wextfreq);\r\nif (freq < 0)\r\nreturn freq;\r\nif (freq) {\r\nchan = ieee80211_get_channel(wdev->wiphy, freq);\r\nif (!chan)\r\nreturn -EINVAL;\r\nif (chan->flags & IEEE80211_CHAN_DISABLED)\r\nreturn -EINVAL;\r\n}\r\nwdev_lock(wdev);\r\nif (wdev->conn) {\r\nbool event = true;\r\nif (wdev->wext.connect.channel == chan) {\r\nerr = 0;\r\ngoto out;\r\n}\r\nif (wdev->wext.connect.ssid_len)\r\nevent = false;\r\nerr = cfg80211_disconnect(rdev, dev,\r\nWLAN_REASON_DEAUTH_LEAVING, event);\r\nif (err)\r\ngoto out;\r\n}\r\nwdev->wext.connect.channel = chan;\r\nif (chan && !wdev->wext.connect.ssid_len) {\r\nstruct cfg80211_chan_def chandef = {\r\n.width = NL80211_CHAN_WIDTH_20_NOHT,\r\n.center_freq1 = freq,\r\n};\r\nchandef.chan = ieee80211_get_channel(&rdev->wiphy, freq);\r\nif (chandef.chan)\r\nerr = cfg80211_set_monitor_channel(rdev, &chandef);\r\nelse\r\nerr = -EINVAL;\r\ngoto out;\r\n}\r\nerr = cfg80211_mgd_wext_connect(rdev, wdev);\r\nout:\r\nwdev_unlock(wdev);\r\nreturn err;\r\n}\r\nint cfg80211_mgd_wext_giwfreq(struct net_device *dev,\r\nstruct iw_request_info *info,\r\nstruct iw_freq *freq, char *extra)\r\n{\r\nstruct wireless_dev *wdev = dev->ieee80211_ptr;\r\nstruct ieee80211_channel *chan = NULL;\r\nif (WARN_ON(wdev->iftype != NL80211_IFTYPE_STATION))\r\nreturn -EINVAL;\r\nwdev_lock(wdev);\r\nif (wdev->current_bss)\r\nchan = wdev->current_bss->pub.channel;\r\nelse if (wdev->wext.connect.channel)\r\nchan = wdev->wext.connect.channel;\r\nwdev_unlock(wdev);\r\nif (chan) {\r\nfreq->m = chan->center_freq;\r\nfreq->e = 6;\r\nreturn 0;\r\n}\r\nreturn -EINVAL;\r\n}\r\nint cfg80211_mgd_wext_siwessid(struct net_device *dev,\r\nstruct iw_request_info *info,\r\nstruct iw_point *data, char *ssid)\r\n{\r\nstruct wireless_dev *wdev = dev->ieee80211_ptr;\r\nstruct cfg80211_registered_device *rdev = wiphy_to_rdev(wdev->wiphy);\r\nsize_t len = data->length;\r\nint err;\r\nif (WARN_ON(wdev->iftype != NL80211_IFTYPE_STATION))\r\nreturn -EINVAL;\r\nif (!data->flags)\r\nlen = 0;\r\nif (len > 0 && ssid[len - 1] == '\0')\r\nlen--;\r\nwdev_lock(wdev);\r\nerr = 0;\r\nif (wdev->conn) {\r\nbool event = true;\r\nif (wdev->wext.connect.ssid && len &&\r\nlen == wdev->wext.connect.ssid_len &&\r\nmemcmp(wdev->wext.connect.ssid, ssid, len) == 0)\r\ngoto out;\r\nif (len)\r\nevent = false;\r\nerr = cfg80211_disconnect(rdev, dev,\r\nWLAN_REASON_DEAUTH_LEAVING, event);\r\nif (err)\r\ngoto out;\r\n}\r\nwdev->wext.prev_bssid_valid = false;\r\nwdev->wext.connect.ssid = wdev->wext.ssid;\r\nmemcpy(wdev->wext.ssid, ssid, len);\r\nwdev->wext.connect.ssid_len = len;\r\nwdev->wext.connect.crypto.control_port = false;\r\nwdev->wext.connect.crypto.control_port_ethertype =\r\ncpu_to_be16(ETH_P_PAE);\r\nerr = cfg80211_mgd_wext_connect(rdev, wdev);\r\nout:\r\nwdev_unlock(wdev);\r\nreturn err;\r\n}\r\nint cfg80211_mgd_wext_giwessid(struct net_device *dev,\r\nstruct iw_request_info *info,\r\nstruct iw_point *data, char *ssid)\r\n{\r\nstruct wireless_dev *wdev = dev->ieee80211_ptr;\r\nif (WARN_ON(wdev->iftype != NL80211_IFTYPE_STATION))\r\nreturn -EINVAL;\r\ndata->flags = 0;\r\nwdev_lock(wdev);\r\nif (wdev->current_bss) {\r\nconst u8 *ie;\r\nrcu_read_lock();\r\nie = ieee80211_bss_get_ie(&wdev->current_bss->pub,\r\nWLAN_EID_SSID);\r\nif (ie) {\r\ndata->flags = 1;\r\ndata->length = ie[1];\r\nmemcpy(ssid, ie + 2, data->length);\r\n}\r\nrcu_read_unlock();\r\n} else if (wdev->wext.connect.ssid && wdev->wext.connect.ssid_len) {\r\ndata->flags = 1;\r\ndata->length = wdev->wext.connect.ssid_len;\r\nmemcpy(ssid, wdev->wext.connect.ssid, data->length);\r\n}\r\nwdev_unlock(wdev);\r\nreturn 0;\r\n}\r\nint cfg80211_mgd_wext_siwap(struct net_device *dev,\r\nstruct iw_request_info *info,\r\nstruct sockaddr *ap_addr, char *extra)\r\n{\r\nstruct wireless_dev *wdev = dev->ieee80211_ptr;\r\nstruct cfg80211_registered_device *rdev = wiphy_to_rdev(wdev->wiphy);\r\nu8 *bssid = ap_addr->sa_data;\r\nint err;\r\nif (WARN_ON(wdev->iftype != NL80211_IFTYPE_STATION))\r\nreturn -EINVAL;\r\nif (ap_addr->sa_family != ARPHRD_ETHER)\r\nreturn -EINVAL;\r\nif (is_zero_ether_addr(bssid) || is_broadcast_ether_addr(bssid))\r\nbssid = NULL;\r\nwdev_lock(wdev);\r\nif (wdev->conn) {\r\nerr = 0;\r\nif (!bssid && !wdev->wext.connect.bssid)\r\ngoto out;\r\nif (wdev->wext.connect.bssid && bssid &&\r\nether_addr_equal(bssid, wdev->wext.connect.bssid))\r\ngoto out;\r\nerr = cfg80211_disconnect(rdev, dev,\r\nWLAN_REASON_DEAUTH_LEAVING, false);\r\nif (err)\r\ngoto out;\r\n}\r\nif (bssid) {\r\nmemcpy(wdev->wext.bssid, bssid, ETH_ALEN);\r\nwdev->wext.connect.bssid = wdev->wext.bssid;\r\n} else\r\nwdev->wext.connect.bssid = NULL;\r\nerr = cfg80211_mgd_wext_connect(rdev, wdev);\r\nout:\r\nwdev_unlock(wdev);\r\nreturn err;\r\n}\r\nint cfg80211_mgd_wext_giwap(struct net_device *dev,\r\nstruct iw_request_info *info,\r\nstruct sockaddr *ap_addr, char *extra)\r\n{\r\nstruct wireless_dev *wdev = dev->ieee80211_ptr;\r\nif (WARN_ON(wdev->iftype != NL80211_IFTYPE_STATION))\r\nreturn -EINVAL;\r\nap_addr->sa_family = ARPHRD_ETHER;\r\nwdev_lock(wdev);\r\nif (wdev->current_bss)\r\nmemcpy(ap_addr->sa_data, wdev->current_bss->pub.bssid, ETH_ALEN);\r\nelse\r\neth_zero_addr(ap_addr->sa_data);\r\nwdev_unlock(wdev);\r\nreturn 0;\r\n}\r\nint cfg80211_wext_siwgenie(struct net_device *dev,\r\nstruct iw_request_info *info,\r\nstruct iw_point *data, char *extra)\r\n{\r\nstruct wireless_dev *wdev = dev->ieee80211_ptr;\r\nstruct cfg80211_registered_device *rdev = wiphy_to_rdev(wdev->wiphy);\r\nu8 *ie = extra;\r\nint ie_len = data->length, err;\r\nif (wdev->iftype != NL80211_IFTYPE_STATION)\r\nreturn -EOPNOTSUPP;\r\nif (!ie_len)\r\nie = NULL;\r\nwdev_lock(wdev);\r\nerr = 0;\r\nif (wdev->wext.ie_len == ie_len &&\r\nmemcmp(wdev->wext.ie, ie, ie_len) == 0)\r\ngoto out;\r\nif (ie_len) {\r\nie = kmemdup(extra, ie_len, GFP_KERNEL);\r\nif (!ie) {\r\nerr = -ENOMEM;\r\ngoto out;\r\n}\r\n} else\r\nie = NULL;\r\nkfree(wdev->wext.ie);\r\nwdev->wext.ie = ie;\r\nwdev->wext.ie_len = ie_len;\r\nif (wdev->conn) {\r\nerr = cfg80211_disconnect(rdev, dev,\r\nWLAN_REASON_DEAUTH_LEAVING, false);\r\nif (err)\r\ngoto out;\r\n}\r\nerr = 0;\r\nout:\r\nwdev_unlock(wdev);\r\nreturn err;\r\n}\r\nint cfg80211_wext_siwmlme(struct net_device *dev,\r\nstruct iw_request_info *info,\r\nstruct iw_point *data, char *extra)\r\n{\r\nstruct wireless_dev *wdev = dev->ieee80211_ptr;\r\nstruct iw_mlme *mlme = (struct iw_mlme *)extra;\r\nstruct cfg80211_registered_device *rdev;\r\nint err;\r\nif (!wdev)\r\nreturn -EOPNOTSUPP;\r\nrdev = wiphy_to_rdev(wdev->wiphy);\r\nif (wdev->iftype != NL80211_IFTYPE_STATION)\r\nreturn -EINVAL;\r\nif (mlme->addr.sa_family != ARPHRD_ETHER)\r\nreturn -EINVAL;\r\nwdev_lock(wdev);\r\nswitch (mlme->cmd) {\r\ncase IW_MLME_DEAUTH:\r\ncase IW_MLME_DISASSOC:\r\nerr = cfg80211_disconnect(rdev, dev, mlme->reason_code, true);\r\nbreak;\r\ndefault:\r\nerr = -EOPNOTSUPP;\r\nbreak;\r\n}\r\nwdev_unlock(wdev);\r\nreturn err;\r\n}
