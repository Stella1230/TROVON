static bool rssi_threshold_check(struct ieee80211_sub_if_data *sdata,\r\nstruct sta_info *sta)\r\n{\r\ns32 rssi_threshold = sdata->u.mesh.mshcfg.rssi_threshold;\r\nreturn rssi_threshold == 0 ||\r\n(sta &&\r\n(s8)-ewma_signal_read(&sta->rx_stats.avg_signal) >\r\nrssi_threshold);\r\n}\r\nstatic inline void mesh_plink_fsm_restart(struct sta_info *sta)\r\n{\r\nlockdep_assert_held(&sta->mesh->plink_lock);\r\nsta->mesh->plink_state = NL80211_PLINK_LISTEN;\r\nsta->mesh->llid = sta->mesh->plid = sta->mesh->reason = 0;\r\nsta->mesh->plink_retries = 0;\r\n}\r\nstatic u32 mesh_set_short_slot_time(struct ieee80211_sub_if_data *sdata)\r\n{\r\nstruct ieee80211_local *local = sdata->local;\r\nenum ieee80211_band band = ieee80211_get_sdata_band(sdata);\r\nstruct ieee80211_supported_band *sband = local->hw.wiphy->bands[band];\r\nstruct sta_info *sta;\r\nu32 erp_rates = 0, changed = 0;\r\nint i;\r\nbool short_slot = false;\r\nif (band == IEEE80211_BAND_5GHZ) {\r\nshort_slot = true;\r\ngoto out;\r\n} else if (band != IEEE80211_BAND_2GHZ)\r\ngoto out;\r\nfor (i = 0; i < sband->n_bitrates; i++)\r\nif (sband->bitrates[i].flags & IEEE80211_RATE_ERP_G)\r\nerp_rates |= BIT(i);\r\nif (!erp_rates)\r\ngoto out;\r\nrcu_read_lock();\r\nlist_for_each_entry_rcu(sta, &local->sta_list, list) {\r\nif (sdata != sta->sdata ||\r\nsta->mesh->plink_state != NL80211_PLINK_ESTAB)\r\ncontinue;\r\nshort_slot = false;\r\nif (erp_rates & sta->sta.supp_rates[band])\r\nshort_slot = true;\r\nelse\r\nbreak;\r\n}\r\nrcu_read_unlock();\r\nout:\r\nif (sdata->vif.bss_conf.use_short_slot != short_slot) {\r\nsdata->vif.bss_conf.use_short_slot = short_slot;\r\nchanged = BSS_CHANGED_ERP_SLOT;\r\nmpl_dbg(sdata, "mesh_plink %pM: ERP short slot time %d\n",\r\nsdata->vif.addr, short_slot);\r\n}\r\nreturn changed;\r\n}\r\nstatic u32 mesh_set_ht_prot_mode(struct ieee80211_sub_if_data *sdata)\r\n{\r\nstruct ieee80211_local *local = sdata->local;\r\nstruct sta_info *sta;\r\nu16 ht_opmode;\r\nbool non_ht_sta = false, ht20_sta = false;\r\nswitch (sdata->vif.bss_conf.chandef.width) {\r\ncase NL80211_CHAN_WIDTH_20_NOHT:\r\ncase NL80211_CHAN_WIDTH_5:\r\ncase NL80211_CHAN_WIDTH_10:\r\nreturn 0;\r\ndefault:\r\nbreak;\r\n}\r\nrcu_read_lock();\r\nlist_for_each_entry_rcu(sta, &local->sta_list, list) {\r\nif (sdata != sta->sdata ||\r\nsta->mesh->plink_state != NL80211_PLINK_ESTAB)\r\ncontinue;\r\nif (sta->sta.bandwidth > IEEE80211_STA_RX_BW_20)\r\ncontinue;\r\nif (!sta->sta.ht_cap.ht_supported) {\r\nmpl_dbg(sdata, "nonHT sta (%pM) is present\n",\r\nsta->sta.addr);\r\nnon_ht_sta = true;\r\nbreak;\r\n}\r\nmpl_dbg(sdata, "HT20 sta (%pM) is present\n", sta->sta.addr);\r\nht20_sta = true;\r\n}\r\nrcu_read_unlock();\r\nif (non_ht_sta)\r\nht_opmode = IEEE80211_HT_OP_MODE_PROTECTION_NONHT_MIXED;\r\nelse if (ht20_sta &&\r\nsdata->vif.bss_conf.chandef.width > NL80211_CHAN_WIDTH_20)\r\nht_opmode = IEEE80211_HT_OP_MODE_PROTECTION_20MHZ;\r\nelse\r\nht_opmode = IEEE80211_HT_OP_MODE_PROTECTION_NONE;\r\nif (sdata->vif.bss_conf.ht_operation_mode == ht_opmode)\r\nreturn 0;\r\nsdata->vif.bss_conf.ht_operation_mode = ht_opmode;\r\nsdata->u.mesh.mshcfg.ht_opmode = ht_opmode;\r\nmpl_dbg(sdata, "selected new HT protection mode %d\n", ht_opmode);\r\nreturn BSS_CHANGED_HT;\r\n}\r\nstatic int mesh_plink_frame_tx(struct ieee80211_sub_if_data *sdata,\r\nstruct sta_info *sta,\r\nenum ieee80211_self_protected_actioncode action,\r\nu8 *da, u16 llid, u16 plid, u16 reason)\r\n{\r\nstruct ieee80211_local *local = sdata->local;\r\nstruct sk_buff *skb;\r\nstruct ieee80211_tx_info *info;\r\nstruct ieee80211_mgmt *mgmt;\r\nbool include_plid = false;\r\nu16 peering_proto = 0;\r\nu8 *pos, ie_len = 4;\r\nint hdr_len = offsetof(struct ieee80211_mgmt, u.action.u.self_prot) +\r\nsizeof(mgmt->u.action.u.self_prot);\r\nint err = -ENOMEM;\r\nskb = dev_alloc_skb(local->tx_headroom +\r\nhdr_len +\r\n2 +\r\n2 +\r\n2 + 8 +\r\n2 + (IEEE80211_MAX_SUPP_RATES - 8) +\r\n2 + sdata->u.mesh.mesh_id_len +\r\n2 + sizeof(struct ieee80211_meshconf_ie) +\r\n2 + sizeof(struct ieee80211_ht_cap) +\r\n2 + sizeof(struct ieee80211_ht_operation) +\r\n2 + sizeof(struct ieee80211_vht_cap) +\r\n2 + sizeof(struct ieee80211_vht_operation) +\r\n2 + 8 +\r\nsdata->u.mesh.ie_len);\r\nif (!skb)\r\nreturn err;\r\ninfo = IEEE80211_SKB_CB(skb);\r\nskb_reserve(skb, local->tx_headroom);\r\nmgmt = (struct ieee80211_mgmt *) skb_put(skb, hdr_len);\r\nmemset(mgmt, 0, hdr_len);\r\nmgmt->frame_control = cpu_to_le16(IEEE80211_FTYPE_MGMT |\r\nIEEE80211_STYPE_ACTION);\r\nmemcpy(mgmt->da, da, ETH_ALEN);\r\nmemcpy(mgmt->sa, sdata->vif.addr, ETH_ALEN);\r\nmemcpy(mgmt->bssid, sdata->vif.addr, ETH_ALEN);\r\nmgmt->u.action.category = WLAN_CATEGORY_SELF_PROTECTED;\r\nmgmt->u.action.u.self_prot.action_code = action;\r\nif (action != WLAN_SP_MESH_PEERING_CLOSE) {\r\nenum ieee80211_band band = ieee80211_get_sdata_band(sdata);\r\npos = skb_put(skb, 2);\r\nmemset(pos, 0, 2);\r\nif (action == WLAN_SP_MESH_PEERING_CONFIRM) {\r\npos = skb_put(skb, 2);\r\nput_unaligned_le16(sta->sta.aid, pos);\r\n}\r\nif (ieee80211_add_srates_ie(sdata, skb, true, band) ||\r\nieee80211_add_ext_srates_ie(sdata, skb, true, band) ||\r\nmesh_add_rsn_ie(sdata, skb) ||\r\nmesh_add_meshid_ie(sdata, skb) ||\r\nmesh_add_meshconf_ie(sdata, skb))\r\ngoto free;\r\n} else {\r\ninfo->flags |= IEEE80211_TX_CTL_NO_ACK;\r\nif (mesh_add_meshid_ie(sdata, skb))\r\ngoto free;\r\n}\r\nswitch (action) {\r\ncase WLAN_SP_MESH_PEERING_OPEN:\r\nbreak;\r\ncase WLAN_SP_MESH_PEERING_CONFIRM:\r\nie_len += 2;\r\ninclude_plid = true;\r\nbreak;\r\ncase WLAN_SP_MESH_PEERING_CLOSE:\r\nif (plid) {\r\nie_len += 2;\r\ninclude_plid = true;\r\n}\r\nie_len += 2;\r\nbreak;\r\ndefault:\r\nerr = -EINVAL;\r\ngoto free;\r\n}\r\nif (WARN_ON(skb_tailroom(skb) < 2 + ie_len))\r\ngoto free;\r\npos = skb_put(skb, 2 + ie_len);\r\n*pos++ = WLAN_EID_PEER_MGMT;\r\n*pos++ = ie_len;\r\nmemcpy(pos, &peering_proto, 2);\r\npos += 2;\r\nput_unaligned_le16(llid, pos);\r\npos += 2;\r\nif (include_plid) {\r\nput_unaligned_le16(plid, pos);\r\npos += 2;\r\n}\r\nif (action == WLAN_SP_MESH_PEERING_CLOSE) {\r\nput_unaligned_le16(reason, pos);\r\npos += 2;\r\n}\r\nif (action != WLAN_SP_MESH_PEERING_CLOSE) {\r\nif (mesh_add_ht_cap_ie(sdata, skb) ||\r\nmesh_add_ht_oper_ie(sdata, skb) ||\r\nmesh_add_vht_cap_ie(sdata, skb) ||\r\nmesh_add_vht_oper_ie(sdata, skb))\r\ngoto free;\r\n}\r\nif (mesh_add_vendor_ies(sdata, skb))\r\ngoto free;\r\nieee80211_tx_skb(sdata, skb);\r\nreturn 0;\r\nfree:\r\nkfree_skb(skb);\r\nreturn err;\r\n}\r\nstatic u32 __mesh_plink_deactivate(struct sta_info *sta)\r\n{\r\nstruct ieee80211_sub_if_data *sdata = sta->sdata;\r\nu32 changed = 0;\r\nlockdep_assert_held(&sta->mesh->plink_lock);\r\nif (sta->mesh->plink_state == NL80211_PLINK_ESTAB)\r\nchanged = mesh_plink_dec_estab_count(sdata);\r\nsta->mesh->plink_state = NL80211_PLINK_BLOCKED;\r\nmesh_path_flush_by_nexthop(sta);\r\nieee80211_mps_sta_status_update(sta);\r\nchanged |= ieee80211_mps_set_sta_local_pm(sta,\r\nNL80211_MESH_POWER_UNKNOWN);\r\nreturn changed;\r\n}\r\nu32 mesh_plink_deactivate(struct sta_info *sta)\r\n{\r\nstruct ieee80211_sub_if_data *sdata = sta->sdata;\r\nu32 changed;\r\nspin_lock_bh(&sta->mesh->plink_lock);\r\nchanged = __mesh_plink_deactivate(sta);\r\nsta->mesh->reason = WLAN_REASON_MESH_PEER_CANCELED;\r\nmesh_plink_frame_tx(sdata, sta, WLAN_SP_MESH_PEERING_CLOSE,\r\nsta->sta.addr, sta->mesh->llid, sta->mesh->plid,\r\nsta->mesh->reason);\r\nspin_unlock_bh(&sta->mesh->plink_lock);\r\nreturn changed;\r\n}\r\nstatic void mesh_sta_info_init(struct ieee80211_sub_if_data *sdata,\r\nstruct sta_info *sta,\r\nstruct ieee802_11_elems *elems, bool insert)\r\n{\r\nstruct ieee80211_local *local = sdata->local;\r\nenum ieee80211_band band = ieee80211_get_sdata_band(sdata);\r\nstruct ieee80211_supported_band *sband;\r\nu32 rates, basic_rates = 0, changed = 0;\r\nenum ieee80211_sta_rx_bandwidth bw = sta->sta.bandwidth;\r\nsband = local->hw.wiphy->bands[band];\r\nrates = ieee80211_sta_get_rates(sdata, elems, band, &basic_rates);\r\nspin_lock_bh(&sta->mesh->plink_lock);\r\nsta->rx_stats.last_rx = jiffies;\r\nif (sta->mesh->plink_state == NL80211_PLINK_ESTAB &&\r\nsta->mesh->processed_beacon)\r\ngoto out;\r\nsta->mesh->processed_beacon = true;\r\nif (sta->sta.supp_rates[band] != rates)\r\nchanged |= IEEE80211_RC_SUPP_RATES_CHANGED;\r\nsta->sta.supp_rates[band] = rates;\r\nif (ieee80211_ht_cap_ie_to_sta_ht_cap(sdata, sband,\r\nelems->ht_cap_elem, sta))\r\nchanged |= IEEE80211_RC_BW_CHANGED;\r\nieee80211_vht_cap_ie_to_sta_vht_cap(sdata, sband,\r\nelems->vht_cap_elem, sta);\r\nif (bw != sta->sta.bandwidth)\r\nchanged |= IEEE80211_RC_BW_CHANGED;\r\nif (elems->ht_operation &&\r\n!(elems->ht_operation->ht_param &\r\nIEEE80211_HT_PARAM_CHAN_WIDTH_ANY)) {\r\nif (sta->sta.bandwidth != IEEE80211_STA_RX_BW_20)\r\nchanged |= IEEE80211_RC_BW_CHANGED;\r\nsta->sta.bandwidth = IEEE80211_STA_RX_BW_20;\r\n}\r\nif (insert)\r\nrate_control_rate_init(sta);\r\nelse\r\nrate_control_rate_update(local, sband, sta, changed);\r\nout:\r\nspin_unlock_bh(&sta->mesh->plink_lock);\r\n}\r\nstatic int mesh_allocate_aid(struct ieee80211_sub_if_data *sdata)\r\n{\r\nstruct sta_info *sta;\r\nunsigned long *aid_map;\r\nint aid;\r\naid_map = kcalloc(BITS_TO_LONGS(IEEE80211_MAX_AID + 1),\r\nsizeof(*aid_map), GFP_KERNEL);\r\nif (!aid_map)\r\nreturn -ENOMEM;\r\n__set_bit(0, aid_map);\r\nrcu_read_lock();\r\nlist_for_each_entry_rcu(sta, &sdata->local->sta_list, list)\r\n__set_bit(sta->sta.aid, aid_map);\r\nrcu_read_unlock();\r\naid = find_first_zero_bit(aid_map, IEEE80211_MAX_AID + 1);\r\nkfree(aid_map);\r\nif (aid > IEEE80211_MAX_AID)\r\nreturn -ENOBUFS;\r\nreturn aid;\r\n}\r\nstatic struct sta_info *\r\n__mesh_sta_info_alloc(struct ieee80211_sub_if_data *sdata, u8 *hw_addr)\r\n{\r\nstruct sta_info *sta;\r\nint aid;\r\nif (sdata->local->num_sta >= MESH_MAX_PLINKS)\r\nreturn NULL;\r\naid = mesh_allocate_aid(sdata);\r\nif (aid < 0)\r\nreturn NULL;\r\nsta = sta_info_alloc(sdata, hw_addr, GFP_KERNEL);\r\nif (!sta)\r\nreturn NULL;\r\nsta->mesh->plink_state = NL80211_PLINK_LISTEN;\r\nsta->sta.wme = true;\r\nsta->sta.aid = aid;\r\nsta_info_pre_move_state(sta, IEEE80211_STA_AUTH);\r\nsta_info_pre_move_state(sta, IEEE80211_STA_ASSOC);\r\nsta_info_pre_move_state(sta, IEEE80211_STA_AUTHORIZED);\r\nreturn sta;\r\n}\r\nstatic struct sta_info *\r\nmesh_sta_info_alloc(struct ieee80211_sub_if_data *sdata, u8 *addr,\r\nstruct ieee802_11_elems *elems)\r\n{\r\nstruct sta_info *sta = NULL;\r\nif (sdata->u.mesh.user_mpm ||\r\nsdata->u.mesh.security & IEEE80211_MESH_SEC_AUTHED)\r\ncfg80211_notify_new_peer_candidate(sdata->dev, addr,\r\nelems->ie_start,\r\nelems->total_len,\r\nGFP_KERNEL);\r\nelse\r\nsta = __mesh_sta_info_alloc(sdata, addr);\r\nreturn sta;\r\n}\r\nstatic struct sta_info *\r\nmesh_sta_info_get(struct ieee80211_sub_if_data *sdata,\r\nu8 *addr, struct ieee802_11_elems *elems) __acquires(RCU)\r\n{\r\nstruct sta_info *sta = NULL;\r\nrcu_read_lock();\r\nsta = sta_info_get(sdata, addr);\r\nif (sta) {\r\nmesh_sta_info_init(sdata, sta, elems, false);\r\n} else {\r\nrcu_read_unlock();\r\nsta = mesh_sta_info_alloc(sdata, addr, elems);\r\nif (!sta) {\r\nrcu_read_lock();\r\nreturn NULL;\r\n}\r\nmesh_sta_info_init(sdata, sta, elems, true);\r\nif (sta_info_insert_rcu(sta))\r\nreturn NULL;\r\n}\r\nreturn sta;\r\n}\r\nvoid mesh_neighbour_update(struct ieee80211_sub_if_data *sdata,\r\nu8 *hw_addr,\r\nstruct ieee802_11_elems *elems)\r\n{\r\nstruct sta_info *sta;\r\nu32 changed = 0;\r\nsta = mesh_sta_info_get(sdata, hw_addr, elems);\r\nif (!sta)\r\ngoto out;\r\nif (mesh_peer_accepts_plinks(elems) &&\r\nsta->mesh->plink_state == NL80211_PLINK_LISTEN &&\r\nsdata->u.mesh.accepting_plinks &&\r\nsdata->u.mesh.mshcfg.auto_open_plinks &&\r\nrssi_threshold_check(sdata, sta))\r\nchanged = mesh_plink_open(sta);\r\nieee80211_mps_frame_release(sta, elems);\r\nout:\r\nrcu_read_unlock();\r\nieee80211_mbss_info_change_notify(sdata, changed);\r\n}\r\nstatic void mesh_plink_timer(unsigned long data)\r\n{\r\nstruct sta_info *sta;\r\nu16 reason = 0;\r\nstruct ieee80211_sub_if_data *sdata;\r\nstruct mesh_config *mshcfg;\r\nenum ieee80211_self_protected_actioncode action = 0;\r\nsta = (struct sta_info *) data;\r\nif (sta->sdata->local->quiescing)\r\nreturn;\r\nspin_lock_bh(&sta->mesh->plink_lock);\r\nif (time_before(jiffies, sta->mesh->plink_timer.expires)) {\r\nmpl_dbg(sta->sdata,\r\n"Ignoring timer for %pM in state %s (timer adjusted)",\r\nsta->sta.addr, mplstates[sta->mesh->plink_state]);\r\nspin_unlock_bh(&sta->mesh->plink_lock);\r\nreturn;\r\n}\r\nif (sta->mesh->plink_state == NL80211_PLINK_LISTEN ||\r\nsta->mesh->plink_state == NL80211_PLINK_ESTAB) {\r\nmpl_dbg(sta->sdata,\r\n"Ignoring timer for %pM in state %s (timer deleted)",\r\nsta->sta.addr, mplstates[sta->mesh->plink_state]);\r\nspin_unlock_bh(&sta->mesh->plink_lock);\r\nreturn;\r\n}\r\nmpl_dbg(sta->sdata,\r\n"Mesh plink timer for %pM fired on state %s\n",\r\nsta->sta.addr, mplstates[sta->mesh->plink_state]);\r\nsdata = sta->sdata;\r\nmshcfg = &sdata->u.mesh.mshcfg;\r\nswitch (sta->mesh->plink_state) {\r\ncase NL80211_PLINK_OPN_RCVD:\r\ncase NL80211_PLINK_OPN_SNT:\r\nif (sta->mesh->plink_retries < mshcfg->dot11MeshMaxRetries) {\r\nu32 rand;\r\nmpl_dbg(sta->sdata,\r\n"Mesh plink for %pM (retry, timeout): %d %d\n",\r\nsta->sta.addr, sta->mesh->plink_retries,\r\nsta->mesh->plink_timeout);\r\nget_random_bytes(&rand, sizeof(u32));\r\nsta->mesh->plink_timeout = sta->mesh->plink_timeout +\r\nrand % sta->mesh->plink_timeout;\r\n++sta->mesh->plink_retries;\r\nmod_plink_timer(sta, sta->mesh->plink_timeout);\r\naction = WLAN_SP_MESH_PEERING_OPEN;\r\nbreak;\r\n}\r\nreason = WLAN_REASON_MESH_MAX_RETRIES;\r\ncase NL80211_PLINK_CNF_RCVD:\r\nif (!reason)\r\nreason = WLAN_REASON_MESH_CONFIRM_TIMEOUT;\r\nsta->mesh->plink_state = NL80211_PLINK_HOLDING;\r\nmod_plink_timer(sta, mshcfg->dot11MeshHoldingTimeout);\r\naction = WLAN_SP_MESH_PEERING_CLOSE;\r\nbreak;\r\ncase NL80211_PLINK_HOLDING:\r\ndel_timer(&sta->mesh->plink_timer);\r\nmesh_plink_fsm_restart(sta);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nspin_unlock_bh(&sta->mesh->plink_lock);\r\nif (action)\r\nmesh_plink_frame_tx(sdata, sta, action, sta->sta.addr,\r\nsta->mesh->llid, sta->mesh->plid, reason);\r\n}\r\nstatic inline void mesh_plink_timer_set(struct sta_info *sta, u32 timeout)\r\n{\r\nsta->mesh->plink_timer.expires = jiffies + msecs_to_jiffies(timeout);\r\nsta->mesh->plink_timer.data = (unsigned long) sta;\r\nsta->mesh->plink_timer.function = mesh_plink_timer;\r\nsta->mesh->plink_timeout = timeout;\r\nadd_timer(&sta->mesh->plink_timer);\r\n}\r\nstatic bool llid_in_use(struct ieee80211_sub_if_data *sdata,\r\nu16 llid)\r\n{\r\nstruct ieee80211_local *local = sdata->local;\r\nbool in_use = false;\r\nstruct sta_info *sta;\r\nrcu_read_lock();\r\nlist_for_each_entry_rcu(sta, &local->sta_list, list) {\r\nif (sdata != sta->sdata)\r\ncontinue;\r\nif (!memcmp(&sta->mesh->llid, &llid, sizeof(llid))) {\r\nin_use = true;\r\nbreak;\r\n}\r\n}\r\nrcu_read_unlock();\r\nreturn in_use;\r\n}\r\nstatic u16 mesh_get_new_llid(struct ieee80211_sub_if_data *sdata)\r\n{\r\nu16 llid;\r\ndo {\r\nget_random_bytes(&llid, sizeof(llid));\r\n} while (llid_in_use(sdata, llid));\r\nreturn llid;\r\n}\r\nu32 mesh_plink_open(struct sta_info *sta)\r\n{\r\nstruct ieee80211_sub_if_data *sdata = sta->sdata;\r\nu32 changed;\r\nif (!test_sta_flag(sta, WLAN_STA_AUTH))\r\nreturn 0;\r\nspin_lock_bh(&sta->mesh->plink_lock);\r\nsta->mesh->llid = mesh_get_new_llid(sdata);\r\nif (sta->mesh->plink_state != NL80211_PLINK_LISTEN &&\r\nsta->mesh->plink_state != NL80211_PLINK_BLOCKED) {\r\nspin_unlock_bh(&sta->mesh->plink_lock);\r\nreturn 0;\r\n}\r\nsta->mesh->plink_state = NL80211_PLINK_OPN_SNT;\r\nmesh_plink_timer_set(sta, sdata->u.mesh.mshcfg.dot11MeshRetryTimeout);\r\nspin_unlock_bh(&sta->mesh->plink_lock);\r\nmpl_dbg(sdata,\r\n"Mesh plink: starting establishment with %pM\n",\r\nsta->sta.addr);\r\nchanged = ieee80211_mps_local_status_update(sdata);\r\nmesh_plink_frame_tx(sdata, sta, WLAN_SP_MESH_PEERING_OPEN,\r\nsta->sta.addr, sta->mesh->llid, 0, 0);\r\nreturn changed;\r\n}\r\nu32 mesh_plink_block(struct sta_info *sta)\r\n{\r\nu32 changed;\r\nspin_lock_bh(&sta->mesh->plink_lock);\r\nchanged = __mesh_plink_deactivate(sta);\r\nsta->mesh->plink_state = NL80211_PLINK_BLOCKED;\r\nspin_unlock_bh(&sta->mesh->plink_lock);\r\nreturn changed;\r\n}\r\nstatic void mesh_plink_close(struct ieee80211_sub_if_data *sdata,\r\nstruct sta_info *sta,\r\nenum plink_event event)\r\n{\r\nstruct mesh_config *mshcfg = &sdata->u.mesh.mshcfg;\r\nu16 reason = (event == CLS_ACPT) ?\r\nWLAN_REASON_MESH_CLOSE : WLAN_REASON_MESH_CONFIG;\r\nsta->mesh->reason = reason;\r\nsta->mesh->plink_state = NL80211_PLINK_HOLDING;\r\nmod_plink_timer(sta, mshcfg->dot11MeshHoldingTimeout);\r\n}\r\nstatic u32 mesh_plink_establish(struct ieee80211_sub_if_data *sdata,\r\nstruct sta_info *sta)\r\n{\r\nstruct mesh_config *mshcfg = &sdata->u.mesh.mshcfg;\r\nu32 changed = 0;\r\ndel_timer(&sta->mesh->plink_timer);\r\nsta->mesh->plink_state = NL80211_PLINK_ESTAB;\r\nchanged |= mesh_plink_inc_estab_count(sdata);\r\nchanged |= mesh_set_ht_prot_mode(sdata);\r\nchanged |= mesh_set_short_slot_time(sdata);\r\nmpl_dbg(sdata, "Mesh plink with %pM ESTABLISHED\n", sta->sta.addr);\r\nieee80211_mps_sta_status_update(sta);\r\nchanged |= ieee80211_mps_set_sta_local_pm(sta, mshcfg->power_mode);\r\nreturn changed;\r\n}\r\nstatic u32 mesh_plink_fsm(struct ieee80211_sub_if_data *sdata,\r\nstruct sta_info *sta, enum plink_event event)\r\n{\r\nstruct mesh_config *mshcfg = &sdata->u.mesh.mshcfg;\r\nenum ieee80211_self_protected_actioncode action = 0;\r\nu32 changed = 0;\r\nmpl_dbg(sdata, "peer %pM in state %s got event %s\n", sta->sta.addr,\r\nmplstates[sta->mesh->plink_state], mplevents[event]);\r\nspin_lock_bh(&sta->mesh->plink_lock);\r\nswitch (sta->mesh->plink_state) {\r\ncase NL80211_PLINK_LISTEN:\r\nswitch (event) {\r\ncase CLS_ACPT:\r\nmesh_plink_fsm_restart(sta);\r\nbreak;\r\ncase OPN_ACPT:\r\nsta->mesh->plink_state = NL80211_PLINK_OPN_RCVD;\r\nsta->mesh->llid = mesh_get_new_llid(sdata);\r\nmesh_plink_timer_set(sta,\r\nmshcfg->dot11MeshRetryTimeout);\r\nchanged |= ieee80211_mps_local_status_update(sdata);\r\naction = WLAN_SP_MESH_PEERING_OPEN;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nbreak;\r\ncase NL80211_PLINK_OPN_SNT:\r\nswitch (event) {\r\ncase OPN_RJCT:\r\ncase CNF_RJCT:\r\ncase CLS_ACPT:\r\nmesh_plink_close(sdata, sta, event);\r\naction = WLAN_SP_MESH_PEERING_CLOSE;\r\nbreak;\r\ncase OPN_ACPT:\r\nsta->mesh->plink_state = NL80211_PLINK_OPN_RCVD;\r\naction = WLAN_SP_MESH_PEERING_CONFIRM;\r\nbreak;\r\ncase CNF_ACPT:\r\nsta->mesh->plink_state = NL80211_PLINK_CNF_RCVD;\r\nmod_plink_timer(sta, mshcfg->dot11MeshConfirmTimeout);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nbreak;\r\ncase NL80211_PLINK_OPN_RCVD:\r\nswitch (event) {\r\ncase OPN_RJCT:\r\ncase CNF_RJCT:\r\ncase CLS_ACPT:\r\nmesh_plink_close(sdata, sta, event);\r\naction = WLAN_SP_MESH_PEERING_CLOSE;\r\nbreak;\r\ncase OPN_ACPT:\r\naction = WLAN_SP_MESH_PEERING_CONFIRM;\r\nbreak;\r\ncase CNF_ACPT:\r\nchanged |= mesh_plink_establish(sdata, sta);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nbreak;\r\ncase NL80211_PLINK_CNF_RCVD:\r\nswitch (event) {\r\ncase OPN_RJCT:\r\ncase CNF_RJCT:\r\ncase CLS_ACPT:\r\nmesh_plink_close(sdata, sta, event);\r\naction = WLAN_SP_MESH_PEERING_CLOSE;\r\nbreak;\r\ncase OPN_ACPT:\r\nchanged |= mesh_plink_establish(sdata, sta);\r\naction = WLAN_SP_MESH_PEERING_CONFIRM;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nbreak;\r\ncase NL80211_PLINK_ESTAB:\r\nswitch (event) {\r\ncase CLS_ACPT:\r\nchanged |= __mesh_plink_deactivate(sta);\r\nchanged |= mesh_set_ht_prot_mode(sdata);\r\nchanged |= mesh_set_short_slot_time(sdata);\r\nmesh_plink_close(sdata, sta, event);\r\naction = WLAN_SP_MESH_PEERING_CLOSE;\r\nbreak;\r\ncase OPN_ACPT:\r\naction = WLAN_SP_MESH_PEERING_CONFIRM;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nbreak;\r\ncase NL80211_PLINK_HOLDING:\r\nswitch (event) {\r\ncase CLS_ACPT:\r\ndel_timer(&sta->mesh->plink_timer);\r\nmesh_plink_fsm_restart(sta);\r\nbreak;\r\ncase OPN_ACPT:\r\ncase CNF_ACPT:\r\ncase OPN_RJCT:\r\ncase CNF_RJCT:\r\naction = WLAN_SP_MESH_PEERING_CLOSE;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nspin_unlock_bh(&sta->mesh->plink_lock);\r\nif (action) {\r\nmesh_plink_frame_tx(sdata, sta, action, sta->sta.addr,\r\nsta->mesh->llid, sta->mesh->plid,\r\nsta->mesh->reason);\r\nif (action == WLAN_SP_MESH_PEERING_OPEN) {\r\nmesh_plink_frame_tx(sdata, sta,\r\nWLAN_SP_MESH_PEERING_CONFIRM,\r\nsta->sta.addr, sta->mesh->llid,\r\nsta->mesh->plid, 0);\r\n}\r\n}\r\nreturn changed;\r\n}\r\nstatic enum plink_event\r\nmesh_plink_get_event(struct ieee80211_sub_if_data *sdata,\r\nstruct sta_info *sta,\r\nstruct ieee802_11_elems *elems,\r\nenum ieee80211_self_protected_actioncode ftype,\r\nu16 llid, u16 plid)\r\n{\r\nenum plink_event event = PLINK_UNDEFINED;\r\nu8 ie_len = elems->peering_len;\r\nbool matches_local;\r\nmatches_local = (ftype == WLAN_SP_MESH_PEERING_CLOSE ||\r\nmesh_matches_local(sdata, elems));\r\nif (!matches_local && !sta) {\r\nevent = OPN_RJCT;\r\ngoto out;\r\n}\r\nif (!sta) {\r\nif (ftype != WLAN_SP_MESH_PEERING_OPEN) {\r\nmpl_dbg(sdata, "Mesh plink: cls or cnf from unknown peer\n");\r\ngoto out;\r\n}\r\nif (!mesh_plink_free_count(sdata)) {\r\nmpl_dbg(sdata, "Mesh plink error: no more free plinks\n");\r\ngoto out;\r\n}\r\n} else {\r\nif (!test_sta_flag(sta, WLAN_STA_AUTH)) {\r\nmpl_dbg(sdata, "Mesh plink: Action frame from non-authed peer\n");\r\ngoto out;\r\n}\r\nif (sta->mesh->plink_state == NL80211_PLINK_BLOCKED)\r\ngoto out;\r\n}\r\nif (!sta) {\r\nevent = OPN_ACPT;\r\ngoto out;\r\n}\r\nswitch (ftype) {\r\ncase WLAN_SP_MESH_PEERING_OPEN:\r\nif (!matches_local)\r\nevent = OPN_RJCT;\r\nif (!mesh_plink_free_count(sdata) ||\r\n(sta->mesh->plid && sta->mesh->plid != plid))\r\nevent = OPN_IGNR;\r\nelse\r\nevent = OPN_ACPT;\r\nbreak;\r\ncase WLAN_SP_MESH_PEERING_CONFIRM:\r\nif (!matches_local)\r\nevent = CNF_RJCT;\r\nif (!mesh_plink_free_count(sdata) ||\r\nsta->mesh->llid != llid ||\r\n(sta->mesh->plid && sta->mesh->plid != plid))\r\nevent = CNF_IGNR;\r\nelse\r\nevent = CNF_ACPT;\r\nbreak;\r\ncase WLAN_SP_MESH_PEERING_CLOSE:\r\nif (sta->mesh->plink_state == NL80211_PLINK_ESTAB)\r\nevent = CLS_ACPT;\r\nelse if (sta->mesh->plid != plid)\r\nevent = CLS_IGNR;\r\nelse if (ie_len == 8 && sta->mesh->llid != llid)\r\nevent = CLS_IGNR;\r\nelse\r\nevent = CLS_ACPT;\r\nbreak;\r\ndefault:\r\nmpl_dbg(sdata, "Mesh plink: unknown frame subtype\n");\r\nbreak;\r\n}\r\nout:\r\nreturn event;\r\n}\r\nstatic void\r\nmesh_process_plink_frame(struct ieee80211_sub_if_data *sdata,\r\nstruct ieee80211_mgmt *mgmt,\r\nstruct ieee802_11_elems *elems)\r\n{\r\nstruct sta_info *sta;\r\nenum plink_event event;\r\nenum ieee80211_self_protected_actioncode ftype;\r\nu32 changed = 0;\r\nu8 ie_len = elems->peering_len;\r\nu16 plid, llid = 0;\r\nif (!elems->peering) {\r\nmpl_dbg(sdata,\r\n"Mesh plink: missing necessary peer link ie\n");\r\nreturn;\r\n}\r\nif (elems->rsn_len &&\r\nsdata->u.mesh.security == IEEE80211_MESH_SEC_NONE) {\r\nmpl_dbg(sdata,\r\n"Mesh plink: can't establish link with secure peer\n");\r\nreturn;\r\n}\r\nftype = mgmt->u.action.u.self_prot.action_code;\r\nif ((ftype == WLAN_SP_MESH_PEERING_OPEN && ie_len != 4) ||\r\n(ftype == WLAN_SP_MESH_PEERING_CONFIRM && ie_len != 6) ||\r\n(ftype == WLAN_SP_MESH_PEERING_CLOSE && ie_len != 6\r\n&& ie_len != 8)) {\r\nmpl_dbg(sdata,\r\n"Mesh plink: incorrect plink ie length %d %d\n",\r\nftype, ie_len);\r\nreturn;\r\n}\r\nif (ftype != WLAN_SP_MESH_PEERING_CLOSE &&\r\n(!elems->mesh_id || !elems->mesh_config)) {\r\nmpl_dbg(sdata, "Mesh plink: missing necessary ie\n");\r\nreturn;\r\n}\r\nplid = get_unaligned_le16(PLINK_GET_LLID(elems->peering));\r\nif (ftype == WLAN_SP_MESH_PEERING_CONFIRM ||\r\n(ftype == WLAN_SP_MESH_PEERING_CLOSE && ie_len == 8))\r\nllid = get_unaligned_le16(PLINK_GET_PLID(elems->peering));\r\nrcu_read_lock();\r\nsta = sta_info_get(sdata, mgmt->sa);\r\nif (ftype == WLAN_SP_MESH_PEERING_OPEN &&\r\n!rssi_threshold_check(sdata, sta)) {\r\nmpl_dbg(sdata, "Mesh plink: %pM does not meet rssi threshold\n",\r\nmgmt->sa);\r\ngoto unlock_rcu;\r\n}\r\nevent = mesh_plink_get_event(sdata, sta, elems, ftype, llid, plid);\r\nif (event == OPN_ACPT) {\r\nrcu_read_unlock();\r\nsta = mesh_sta_info_get(sdata, mgmt->sa, elems);\r\nif (!sta) {\r\nmpl_dbg(sdata, "Mesh plink: failed to init peer!\n");\r\ngoto unlock_rcu;\r\n}\r\nsta->mesh->plid = plid;\r\n} else if (!sta && event == OPN_RJCT) {\r\nmesh_plink_frame_tx(sdata, NULL, WLAN_SP_MESH_PEERING_CLOSE,\r\nmgmt->sa, 0, plid,\r\nWLAN_REASON_MESH_CONFIG);\r\ngoto unlock_rcu;\r\n} else if (!sta || event == PLINK_UNDEFINED) {\r\ngoto unlock_rcu;\r\n}\r\nif (event == CNF_ACPT) {\r\nif (!sta->mesh->plid)\r\nsta->mesh->plid = plid;\r\nsta->mesh->aid = get_unaligned_le16(PLINK_CNF_AID(mgmt));\r\n}\r\nchanged |= mesh_plink_fsm(sdata, sta, event);\r\nunlock_rcu:\r\nrcu_read_unlock();\r\nif (changed)\r\nieee80211_mbss_info_change_notify(sdata, changed);\r\n}\r\nvoid mesh_rx_plink_frame(struct ieee80211_sub_if_data *sdata,\r\nstruct ieee80211_mgmt *mgmt, size_t len,\r\nstruct ieee80211_rx_status *rx_status)\r\n{\r\nstruct ieee802_11_elems elems;\r\nsize_t baselen;\r\nu8 *baseaddr;\r\nif (len < IEEE80211_MIN_ACTION_SIZE + 3)\r\nreturn;\r\nif (sdata->u.mesh.user_mpm)\r\nreturn;\r\nif (is_multicast_ether_addr(mgmt->da)) {\r\nmpl_dbg(sdata,\r\n"Mesh plink: ignore frame from multicast address\n");\r\nreturn;\r\n}\r\nbaseaddr = mgmt->u.action.u.self_prot.variable;\r\nbaselen = (u8 *) mgmt->u.action.u.self_prot.variable - (u8 *) mgmt;\r\nif (mgmt->u.action.u.self_prot.action_code ==\r\nWLAN_SP_MESH_PEERING_CONFIRM) {\r\nbaseaddr += 4;\r\nbaselen += 4;\r\nif (baselen > len)\r\nreturn;\r\n}\r\nieee802_11_parse_elems(baseaddr, len - baselen, true, &elems);\r\nmesh_process_plink_frame(sdata, mgmt, &elems);\r\n}
