u32 hdmi_read(struct sti_hdmi *hdmi, int offset)\r\n{\r\nreturn readl(hdmi->regs + offset);\r\n}\r\nvoid hdmi_write(struct sti_hdmi *hdmi, u32 val, int offset)\r\n{\r\nwritel(val, hdmi->regs + offset);\r\n}\r\nstatic irqreturn_t hdmi_irq_thread(int irq, void *arg)\r\n{\r\nstruct sti_hdmi *hdmi = arg;\r\nif (hdmi->irq_status & HDMI_INT_HOT_PLUG) {\r\nhdmi->hpd = readl(hdmi->regs + HDMI_STA) & HDMI_STA_HOT_PLUG;\r\nif (hdmi->drm_dev)\r\ndrm_helper_hpd_irq_event(hdmi->drm_dev);\r\n}\r\nif (hdmi->irq_status & (HDMI_INT_SW_RST | HDMI_INT_DLL_LCK)) {\r\nhdmi->event_received = true;\r\nwake_up_interruptible(&hdmi->wait_event);\r\n}\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic irqreturn_t hdmi_irq(int irq, void *arg)\r\n{\r\nstruct sti_hdmi *hdmi = arg;\r\nhdmi->irq_status = hdmi_read(hdmi, HDMI_INT_STA);\r\nhdmi_write(hdmi, hdmi->irq_status, HDMI_INT_CLR);\r\nhdmi_read(hdmi, HDMI_INT_STA);\r\nreturn IRQ_WAKE_THREAD;\r\n}\r\nstatic void hdmi_active_area(struct sti_hdmi *hdmi)\r\n{\r\nu32 xmin, xmax;\r\nu32 ymin, ymax;\r\nxmin = sti_vtg_get_pixel_number(hdmi->mode, 1);\r\nxmax = sti_vtg_get_pixel_number(hdmi->mode, hdmi->mode.hdisplay);\r\nymin = sti_vtg_get_line_number(hdmi->mode, 0);\r\nymax = sti_vtg_get_line_number(hdmi->mode, hdmi->mode.vdisplay - 1);\r\nhdmi_write(hdmi, xmin, HDMI_ACTIVE_VID_XMIN);\r\nhdmi_write(hdmi, xmax, HDMI_ACTIVE_VID_XMAX);\r\nhdmi_write(hdmi, ymin, HDMI_ACTIVE_VID_YMIN);\r\nhdmi_write(hdmi, ymax, HDMI_ACTIVE_VID_YMAX);\r\n}\r\nstatic void hdmi_config(struct sti_hdmi *hdmi)\r\n{\r\nu32 conf;\r\nDRM_DEBUG_DRIVER("\n");\r\nconf = HDMI_CFG_FIFO_OVERRUN_CLR | HDMI_CFG_FIFO_UNDERRUN_CLR;\r\nconf |= HDMI_CFG_HDMI_NOT_DVI | HDMI_CFG_ESS_NOT_OESS;\r\nconf |= HDMI_CFG_SINK_TERM_DET_EN;\r\nif (hdmi->mode.flags & DRM_MODE_FLAG_NHSYNC) {\r\nDRM_DEBUG_DRIVER("H Sync Negative\n");\r\nconf |= HDMI_CFG_H_SYNC_POL_NEG;\r\n}\r\nif (hdmi->mode.flags & DRM_MODE_FLAG_NVSYNC) {\r\nDRM_DEBUG_DRIVER("V Sync Negative\n");\r\nconf |= HDMI_CFG_V_SYNC_POL_NEG;\r\n}\r\nconf |= HDMI_CFG_DEVICE_EN;\r\nhdmi_write(hdmi, conf, HDMI_CFG);\r\n}\r\nstatic inline unsigned int hdmi_infoframe_subpack(const u8 *ptr, size_t size)\r\n{\r\nunsigned long value = 0;\r\nsize_t i;\r\nfor (i = size; i > 0; i--)\r\nvalue = (value << 8) | ptr[i - 1];\r\nreturn value;\r\n}\r\nstatic void hdmi_infoframe_write_infopack(struct sti_hdmi *hdmi, const u8 *data)\r\n{\r\nconst u8 *ptr = data;\r\nu32 val, slot, mode, i;\r\nu32 head_offset, pack_offset;\r\nsize_t size;\r\nswitch (*ptr) {\r\ncase HDMI_INFOFRAME_TYPE_AVI:\r\nslot = HDMI_IFRAME_SLOT_AVI;\r\nmode = HDMI_IFRAME_FIELD;\r\nhead_offset = HDMI_SW_DI_N_HEAD_WORD(HDMI_IFRAME_SLOT_AVI);\r\npack_offset = HDMI_SW_DI_N_PKT_WORD0(HDMI_IFRAME_SLOT_AVI);\r\nsize = HDMI_AVI_INFOFRAME_SIZE;\r\nbreak;\r\ncase HDMI_INFOFRAME_TYPE_AUDIO:\r\nslot = HDMI_IFRAME_SLOT_AUDIO;\r\nmode = HDMI_IFRAME_FRAME;\r\nhead_offset = HDMI_SW_DI_N_HEAD_WORD(HDMI_IFRAME_SLOT_AUDIO);\r\npack_offset = HDMI_SW_DI_N_PKT_WORD0(HDMI_IFRAME_SLOT_AUDIO);\r\nsize = HDMI_AUDIO_INFOFRAME_SIZE;\r\nbreak;\r\ndefault:\r\nDRM_ERROR("unsupported infoframe type: %#x\n", *ptr);\r\nreturn;\r\n}\r\nval = hdmi_read(hdmi, HDMI_SW_DI_CFG);\r\nval &= ~HDMI_IFRAME_CFG_DI_N(HDMI_IFRAME_MASK, slot);\r\nhdmi_write(hdmi, val, HDMI_SW_DI_CFG);\r\nval = HDMI_INFOFRAME_HEADER_TYPE(*ptr++);\r\nval |= HDMI_INFOFRAME_HEADER_VERSION(*ptr++);\r\nval |= HDMI_INFOFRAME_HEADER_LEN(*ptr++);\r\nwritel(val, hdmi->regs + head_offset);\r\nfor (i = 0; i < size; i += sizeof(u32)) {\r\nsize_t num;\r\nnum = min_t(size_t, size - i, sizeof(u32));\r\nval = hdmi_infoframe_subpack(ptr, num);\r\nptr += sizeof(u32);\r\nwritel(val, hdmi->regs + pack_offset + i);\r\n}\r\nval = hdmi_read(hdmi, HDMI_SW_DI_CFG);\r\nval |= HDMI_IFRAME_CFG_DI_N(HDMI_IFRAME_FIELD, slot);\r\nhdmi_write(hdmi, val, HDMI_SW_DI_CFG);\r\n}\r\nstatic int hdmi_avi_infoframe_config(struct sti_hdmi *hdmi)\r\n{\r\nstruct drm_display_mode *mode = &hdmi->mode;\r\nstruct hdmi_avi_infoframe infoframe;\r\nu8 buffer[HDMI_INFOFRAME_SIZE(AVI)];\r\nint ret;\r\nDRM_DEBUG_DRIVER("\n");\r\nret = drm_hdmi_avi_infoframe_from_display_mode(&infoframe, mode);\r\nif (ret < 0) {\r\nDRM_ERROR("failed to setup AVI infoframe: %d\n", ret);\r\nreturn ret;\r\n}\r\ninfoframe.colorspace = HDMI_COLORSPACE_RGB;\r\ninfoframe.quantization_range = HDMI_QUANTIZATION_RANGE_DEFAULT;\r\ninfoframe.colorimetry = HDMI_COLORIMETRY_NONE;\r\nret = hdmi_avi_infoframe_pack(&infoframe, buffer, sizeof(buffer));\r\nif (ret < 0) {\r\nDRM_ERROR("failed to pack AVI infoframe: %d\n", ret);\r\nreturn ret;\r\n}\r\nhdmi_infoframe_write_infopack(hdmi, buffer);\r\nreturn 0;\r\n}\r\nstatic int hdmi_audio_infoframe_config(struct sti_hdmi *hdmi)\r\n{\r\nstruct hdmi_audio_infoframe infofame;\r\nu8 buffer[HDMI_INFOFRAME_SIZE(AUDIO)];\r\nint ret;\r\nret = hdmi_audio_infoframe_init(&infofame);\r\nif (ret < 0) {\r\nDRM_ERROR("failed to setup audio infoframe: %d\n", ret);\r\nreturn ret;\r\n}\r\ninfofame.channels = 2;\r\nret = hdmi_audio_infoframe_pack(&infofame, buffer, sizeof(buffer));\r\nif (ret < 0) {\r\nDRM_ERROR("failed to pack audio infoframe: %d\n", ret);\r\nreturn ret;\r\n}\r\nhdmi_infoframe_write_infopack(hdmi, buffer);\r\nreturn 0;\r\n}\r\nstatic void hdmi_swreset(struct sti_hdmi *hdmi)\r\n{\r\nu32 val;\r\nDRM_DEBUG_DRIVER("\n");\r\nif (clk_prepare_enable(hdmi->clk_audio))\r\nDRM_INFO("Failed to prepare/enable hdmi_audio clk\n");\r\nhdmi->event_received = false;\r\nval = hdmi_read(hdmi, HDMI_CFG);\r\nval |= HDMI_CFG_SW_RST_EN;\r\nhdmi_write(hdmi, val, HDMI_CFG);\r\nwait_event_interruptible_timeout(hdmi->wait_event,\r\nhdmi->event_received == true,\r\nmsecs_to_jiffies\r\n(HDMI_TIMEOUT_SWRESET));\r\nif ((hdmi_read(hdmi, HDMI_STA) & HDMI_STA_SW_RST) == 0)\r\nDRM_DEBUG_DRIVER("Warning: HDMI sw reset timeout occurs\n");\r\nval = hdmi_read(hdmi, HDMI_CFG);\r\nval &= ~HDMI_CFG_SW_RST_EN;\r\nhdmi_write(hdmi, val, HDMI_CFG);\r\nclk_disable_unprepare(hdmi->clk_audio);\r\n}\r\nstatic void sti_hdmi_disable(struct drm_bridge *bridge)\r\n{\r\nstruct sti_hdmi *hdmi = bridge->driver_private;\r\nu32 val = hdmi_read(hdmi, HDMI_CFG);\r\nif (!hdmi->enabled)\r\nreturn;\r\nDRM_DEBUG_DRIVER("\n");\r\nval &= ~HDMI_CFG_DEVICE_EN;\r\nhdmi_write(hdmi, val, HDMI_CFG);\r\nhdmi_write(hdmi, 0xffffffff, HDMI_INT_CLR);\r\nhdmi->phy_ops->stop(hdmi);\r\nhdmi_write(hdmi, 0x0000, HDMI_DFLT_CHL0_DAT);\r\nhdmi_write(hdmi, 0x0000, HDMI_DFLT_CHL1_DAT);\r\nhdmi_write(hdmi, 0x0060, HDMI_DFLT_CHL2_DAT);\r\nclk_disable_unprepare(hdmi->clk_phy);\r\nclk_disable_unprepare(hdmi->clk_tmds);\r\nclk_disable_unprepare(hdmi->clk_pix);\r\nhdmi->enabled = false;\r\n}\r\nstatic void sti_hdmi_pre_enable(struct drm_bridge *bridge)\r\n{\r\nstruct sti_hdmi *hdmi = bridge->driver_private;\r\nDRM_DEBUG_DRIVER("\n");\r\nif (hdmi->enabled)\r\nreturn;\r\nif (clk_prepare_enable(hdmi->clk_pix))\r\nDRM_ERROR("Failed to prepare/enable hdmi_pix clk\n");\r\nif (clk_prepare_enable(hdmi->clk_tmds))\r\nDRM_ERROR("Failed to prepare/enable hdmi_tmds clk\n");\r\nif (clk_prepare_enable(hdmi->clk_phy))\r\nDRM_ERROR("Failed to prepare/enable hdmi_rejec_pll clk\n");\r\nhdmi->enabled = true;\r\nif (!hdmi->phy_ops->start(hdmi)) {\r\nDRM_ERROR("Unable to start hdmi phy\n");\r\nreturn;\r\n}\r\nhdmi_active_area(hdmi);\r\nhdmi_write(hdmi, HDMI_WORKING_INT, HDMI_INT_EN);\r\nhdmi_config(hdmi);\r\nif (hdmi_avi_infoframe_config(hdmi))\r\nDRM_ERROR("Unable to configure AVI infoframe\n");\r\nif (hdmi_audio_infoframe_config(hdmi))\r\nDRM_ERROR("Unable to configure AUDIO infoframe\n");\r\nhdmi_swreset(hdmi);\r\n}\r\nstatic void sti_hdmi_set_mode(struct drm_bridge *bridge,\r\nstruct drm_display_mode *mode,\r\nstruct drm_display_mode *adjusted_mode)\r\n{\r\nstruct sti_hdmi *hdmi = bridge->driver_private;\r\nint ret;\r\nDRM_DEBUG_DRIVER("\n");\r\nmemcpy(&hdmi->mode, mode, sizeof(struct drm_display_mode));\r\nret = clk_set_rate(hdmi->clk_pix, mode->clock * 1000);\r\nif (ret < 0) {\r\nDRM_ERROR("Cannot set rate (%dHz) for hdmi_pix clk\n",\r\nmode->clock * 1000);\r\nreturn;\r\n}\r\nret = clk_set_rate(hdmi->clk_phy, mode->clock * 1000);\r\nif (ret < 0) {\r\nDRM_ERROR("Cannot set rate (%dHz) for hdmi_rejection_pll clk\n",\r\nmode->clock * 1000);\r\nreturn;\r\n}\r\n}\r\nstatic void sti_hdmi_bridge_nope(struct drm_bridge *bridge)\r\n{\r\n}\r\nstatic int sti_hdmi_connector_get_modes(struct drm_connector *connector)\r\n{\r\nstruct sti_hdmi_connector *hdmi_connector\r\n= to_sti_hdmi_connector(connector);\r\nstruct sti_hdmi *hdmi = hdmi_connector->hdmi;\r\nstruct edid *edid;\r\nint count;\r\nDRM_DEBUG_DRIVER("\n");\r\nedid = drm_get_edid(connector, hdmi->ddc_adapt);\r\nif (!edid)\r\ngoto fail;\r\ncount = drm_add_edid_modes(connector, edid);\r\ndrm_mode_connector_update_edid_property(connector, edid);\r\nkfree(edid);\r\nreturn count;\r\nfail:\r\nDRM_ERROR("Can't read HDMI EDID\n");\r\nreturn 0;\r\n}\r\nstatic int sti_hdmi_connector_mode_valid(struct drm_connector *connector,\r\nstruct drm_display_mode *mode)\r\n{\r\nint target = mode->clock * 1000;\r\nint target_min = target - CLK_TOLERANCE_HZ;\r\nint target_max = target + CLK_TOLERANCE_HZ;\r\nint result;\r\nstruct sti_hdmi_connector *hdmi_connector\r\n= to_sti_hdmi_connector(connector);\r\nstruct sti_hdmi *hdmi = hdmi_connector->hdmi;\r\nresult = clk_round_rate(hdmi->clk_pix, target);\r\nDRM_DEBUG_DRIVER("target rate = %d => available rate = %d\n",\r\ntarget, result);\r\nif ((result < target_min) || (result > target_max)) {\r\nDRM_DEBUG_DRIVER("hdmi pixclk=%d not supported\n", target);\r\nreturn MODE_BAD;\r\n}\r\nreturn MODE_OK;\r\n}\r\nstruct drm_encoder *sti_hdmi_best_encoder(struct drm_connector *connector)\r\n{\r\nstruct sti_hdmi_connector *hdmi_connector\r\n= to_sti_hdmi_connector(connector);\r\nreturn hdmi_connector->encoder;\r\n}\r\nstatic enum drm_connector_status\r\nsti_hdmi_connector_detect(struct drm_connector *connector, bool force)\r\n{\r\nstruct sti_hdmi_connector *hdmi_connector\r\n= to_sti_hdmi_connector(connector);\r\nstruct sti_hdmi *hdmi = hdmi_connector->hdmi;\r\nDRM_DEBUG_DRIVER("\n");\r\nif (hdmi->hpd) {\r\nDRM_DEBUG_DRIVER("hdmi cable connected\n");\r\nreturn connector_status_connected;\r\n}\r\nDRM_DEBUG_DRIVER("hdmi cable disconnected\n");\r\nreturn connector_status_disconnected;\r\n}\r\nstatic void sti_hdmi_connector_destroy(struct drm_connector *connector)\r\n{\r\nstruct sti_hdmi_connector *hdmi_connector\r\n= to_sti_hdmi_connector(connector);\r\ndrm_connector_unregister(connector);\r\ndrm_connector_cleanup(connector);\r\nkfree(hdmi_connector);\r\n}\r\nstatic struct drm_encoder *sti_hdmi_find_encoder(struct drm_device *dev)\r\n{\r\nstruct drm_encoder *encoder;\r\nlist_for_each_entry(encoder, &dev->mode_config.encoder_list, head) {\r\nif (encoder->encoder_type == DRM_MODE_ENCODER_TMDS)\r\nreturn encoder;\r\n}\r\nreturn NULL;\r\n}\r\nstatic int sti_hdmi_bind(struct device *dev, struct device *master, void *data)\r\n{\r\nstruct sti_hdmi *hdmi = dev_get_drvdata(dev);\r\nstruct drm_device *drm_dev = data;\r\nstruct drm_encoder *encoder;\r\nstruct sti_hdmi_connector *connector;\r\nstruct drm_connector *drm_connector;\r\nstruct drm_bridge *bridge;\r\nint err;\r\nhdmi->drm_dev = drm_dev;\r\nencoder = sti_hdmi_find_encoder(drm_dev);\r\nif (!encoder)\r\nreturn -EINVAL;\r\nconnector = devm_kzalloc(dev, sizeof(*connector), GFP_KERNEL);\r\nif (!connector)\r\nreturn -EINVAL;\r\nconnector->hdmi = hdmi;\r\nbridge = devm_kzalloc(dev, sizeof(*bridge), GFP_KERNEL);\r\nif (!bridge)\r\nreturn -EINVAL;\r\nbridge->driver_private = hdmi;\r\nbridge->funcs = &sti_hdmi_bridge_funcs;\r\ndrm_bridge_attach(drm_dev, bridge);\r\nencoder->bridge = bridge;\r\nconnector->encoder = encoder;\r\ndrm_connector = (struct drm_connector *)connector;\r\ndrm_connector->polled = DRM_CONNECTOR_POLL_HPD;\r\ndrm_connector_init(drm_dev, drm_connector,\r\n&sti_hdmi_connector_funcs, DRM_MODE_CONNECTOR_HDMIA);\r\ndrm_connector_helper_add(drm_connector,\r\n&sti_hdmi_connector_helper_funcs);\r\nerr = drm_connector_register(drm_connector);\r\nif (err)\r\ngoto err_connector;\r\nerr = drm_mode_connector_attach_encoder(drm_connector, encoder);\r\nif (err) {\r\nDRM_ERROR("Failed to attach a connector to a encoder\n");\r\ngoto err_sysfs;\r\n}\r\nhdmi_write(hdmi, HDMI_DEFAULT_INT, HDMI_INT_EN);\r\nreturn 0;\r\nerr_sysfs:\r\ndrm_connector_unregister(drm_connector);\r\nerr_connector:\r\ndrm_connector_cleanup(drm_connector);\r\nreturn -EINVAL;\r\n}\r\nstatic void sti_hdmi_unbind(struct device *dev,\r\nstruct device *master, void *data)\r\n{\r\n}\r\nstatic int sti_hdmi_probe(struct platform_device *pdev)\r\n{\r\nstruct device *dev = &pdev->dev;\r\nstruct sti_hdmi *hdmi;\r\nstruct device_node *np = dev->of_node;\r\nstruct resource *res;\r\nstruct device_node *ddc;\r\nint ret;\r\nDRM_INFO("%s\n", __func__);\r\nhdmi = devm_kzalloc(dev, sizeof(*hdmi), GFP_KERNEL);\r\nif (!hdmi)\r\nreturn -ENOMEM;\r\nddc = of_parse_phandle(pdev->dev.of_node, "ddc", 0);\r\nif (ddc) {\r\nhdmi->ddc_adapt = of_get_i2c_adapter_by_node(ddc);\r\nof_node_put(ddc);\r\nif (!hdmi->ddc_adapt)\r\nreturn -EPROBE_DEFER;\r\n}\r\nhdmi->dev = pdev->dev;\r\nres = platform_get_resource_byname(pdev, IORESOURCE_MEM, "hdmi-reg");\r\nif (!res) {\r\nDRM_ERROR("Invalid hdmi resource\n");\r\nret = -ENOMEM;\r\ngoto release_adapter;\r\n}\r\nhdmi->regs = devm_ioremap_nocache(dev, res->start, resource_size(res));\r\nif (!hdmi->regs) {\r\nret = -ENOMEM;\r\ngoto release_adapter;\r\n}\r\nif (of_device_is_compatible(np, "st,stih416-hdmi")) {\r\nres = platform_get_resource_byname(pdev, IORESOURCE_MEM,\r\n"syscfg");\r\nif (!res) {\r\nDRM_ERROR("Invalid syscfg resource\n");\r\nret = -ENOMEM;\r\ngoto release_adapter;\r\n}\r\nhdmi->syscfg = devm_ioremap_nocache(dev, res->start,\r\nresource_size(res));\r\nif (!hdmi->syscfg) {\r\nret = -ENOMEM;\r\ngoto release_adapter;\r\n}\r\n}\r\nhdmi->phy_ops = (struct hdmi_phy_ops *)\r\nof_match_node(hdmi_of_match, np)->data;\r\nhdmi->clk_pix = devm_clk_get(dev, "pix");\r\nif (IS_ERR(hdmi->clk_pix)) {\r\nDRM_ERROR("Cannot get hdmi_pix clock\n");\r\nret = PTR_ERR(hdmi->clk_pix);\r\ngoto release_adapter;\r\n}\r\nhdmi->clk_tmds = devm_clk_get(dev, "tmds");\r\nif (IS_ERR(hdmi->clk_tmds)) {\r\nDRM_ERROR("Cannot get hdmi_tmds clock\n");\r\nret = PTR_ERR(hdmi->clk_tmds);\r\ngoto release_adapter;\r\n}\r\nhdmi->clk_phy = devm_clk_get(dev, "phy");\r\nif (IS_ERR(hdmi->clk_phy)) {\r\nDRM_ERROR("Cannot get hdmi_phy clock\n");\r\nret = PTR_ERR(hdmi->clk_phy);\r\ngoto release_adapter;\r\n}\r\nhdmi->clk_audio = devm_clk_get(dev, "audio");\r\nif (IS_ERR(hdmi->clk_audio)) {\r\nDRM_ERROR("Cannot get hdmi_audio clock\n");\r\nret = PTR_ERR(hdmi->clk_audio);\r\ngoto release_adapter;\r\n}\r\nhdmi->hpd = readl(hdmi->regs + HDMI_STA) & HDMI_STA_HOT_PLUG;\r\ninit_waitqueue_head(&hdmi->wait_event);\r\nhdmi->irq = platform_get_irq_byname(pdev, "irq");\r\nret = devm_request_threaded_irq(dev, hdmi->irq, hdmi_irq,\r\nhdmi_irq_thread, IRQF_ONESHOT, dev_name(dev), hdmi);\r\nif (ret) {\r\nDRM_ERROR("Failed to register HDMI interrupt\n");\r\ngoto release_adapter;\r\n}\r\nhdmi->reset = devm_reset_control_get(dev, "hdmi");\r\nif (!IS_ERR(hdmi->reset))\r\nreset_control_deassert(hdmi->reset);\r\nplatform_set_drvdata(pdev, hdmi);\r\nreturn component_add(&pdev->dev, &sti_hdmi_ops);\r\nrelease_adapter:\r\ni2c_put_adapter(hdmi->ddc_adapt);\r\nreturn ret;\r\n}\r\nstatic int sti_hdmi_remove(struct platform_device *pdev)\r\n{\r\nstruct sti_hdmi *hdmi = dev_get_drvdata(&pdev->dev);\r\ni2c_put_adapter(hdmi->ddc_adapt);\r\ncomponent_del(&pdev->dev, &sti_hdmi_ops);\r\nreturn 0;\r\n}
