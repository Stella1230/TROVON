static int afu_control(struct cxl_afu *afu, u64 command,\r\nu64 result, u64 mask, bool enabled)\r\n{\r\nu64 AFU_Cntl = cxl_p2n_read(afu, CXL_AFU_Cntl_An);\r\nunsigned long timeout = jiffies + (HZ * CXL_TIMEOUT);\r\nint rc = 0;\r\nspin_lock(&afu->afu_cntl_lock);\r\npr_devel("AFU command starting: %llx\n", command);\r\ntrace_cxl_afu_ctrl(afu, command);\r\ncxl_p2n_write(afu, CXL_AFU_Cntl_An, AFU_Cntl | command);\r\nAFU_Cntl = cxl_p2n_read(afu, CXL_AFU_Cntl_An);\r\nwhile ((AFU_Cntl & mask) != result) {\r\nif (time_after_eq(jiffies, timeout)) {\r\ndev_warn(&afu->dev, "WARNING: AFU control timed out!\n");\r\nrc = -EBUSY;\r\ngoto out;\r\n}\r\nif (!cxl_adapter_link_ok(afu->adapter)) {\r\nafu->enabled = enabled;\r\nrc = -EIO;\r\ngoto out;\r\n}\r\npr_devel_ratelimited("AFU control... (0x%016llx)\n",\r\nAFU_Cntl | command);\r\ncpu_relax();\r\nAFU_Cntl = cxl_p2n_read(afu, CXL_AFU_Cntl_An);\r\n};\r\npr_devel("AFU command complete: %llx\n", command);\r\nafu->enabled = enabled;\r\nout:\r\ntrace_cxl_afu_ctrl_done(afu, command, rc);\r\nspin_unlock(&afu->afu_cntl_lock);\r\nreturn rc;\r\n}\r\nstatic int afu_enable(struct cxl_afu *afu)\r\n{\r\npr_devel("AFU enable request\n");\r\nreturn afu_control(afu, CXL_AFU_Cntl_An_E,\r\nCXL_AFU_Cntl_An_ES_Enabled,\r\nCXL_AFU_Cntl_An_ES_MASK, true);\r\n}\r\nint cxl_afu_disable(struct cxl_afu *afu)\r\n{\r\npr_devel("AFU disable request\n");\r\nreturn afu_control(afu, 0, CXL_AFU_Cntl_An_ES_Disabled,\r\nCXL_AFU_Cntl_An_ES_MASK, false);\r\n}\r\nint __cxl_afu_reset(struct cxl_afu *afu)\r\n{\r\npr_devel("AFU reset request\n");\r\nreturn afu_control(afu, CXL_AFU_Cntl_An_RA,\r\nCXL_AFU_Cntl_An_RS_Complete | CXL_AFU_Cntl_An_ES_Disabled,\r\nCXL_AFU_Cntl_An_RS_MASK | CXL_AFU_Cntl_An_ES_MASK,\r\nfalse);\r\n}\r\nint cxl_afu_check_and_enable(struct cxl_afu *afu)\r\n{\r\nif (!cxl_adapter_link_ok(afu->adapter)) {\r\nWARN(1, "Refusing to enable afu while link down!\n");\r\nreturn -EIO;\r\n}\r\nif (afu->enabled)\r\nreturn 0;\r\nreturn afu_enable(afu);\r\n}\r\nint cxl_psl_purge(struct cxl_afu *afu)\r\n{\r\nu64 PSL_CNTL = cxl_p1n_read(afu, CXL_PSL_SCNTL_An);\r\nu64 AFU_Cntl = cxl_p2n_read(afu, CXL_AFU_Cntl_An);\r\nu64 dsisr, dar;\r\nu64 start, end;\r\nunsigned long timeout = jiffies + (HZ * CXL_TIMEOUT);\r\nint rc = 0;\r\ntrace_cxl_psl_ctrl(afu, CXL_PSL_SCNTL_An_Pc);\r\npr_devel("PSL purge request\n");\r\nif (!cxl_adapter_link_ok(afu->adapter)) {\r\ndev_warn(&afu->dev, "PSL Purge called with link down, ignoring\n");\r\nrc = -EIO;\r\ngoto out;\r\n}\r\nif ((AFU_Cntl & CXL_AFU_Cntl_An_ES_MASK) != CXL_AFU_Cntl_An_ES_Disabled) {\r\nWARN(1, "psl_purge request while AFU not disabled!\n");\r\ncxl_afu_disable(afu);\r\n}\r\ncxl_p1n_write(afu, CXL_PSL_SCNTL_An,\r\nPSL_CNTL | CXL_PSL_SCNTL_An_Pc);\r\nstart = local_clock();\r\nPSL_CNTL = cxl_p1n_read(afu, CXL_PSL_SCNTL_An);\r\nwhile ((PSL_CNTL & CXL_PSL_SCNTL_An_Ps_MASK)\r\n== CXL_PSL_SCNTL_An_Ps_Pending) {\r\nif (time_after_eq(jiffies, timeout)) {\r\ndev_warn(&afu->dev, "WARNING: PSL Purge timed out!\n");\r\nrc = -EBUSY;\r\ngoto out;\r\n}\r\nif (!cxl_adapter_link_ok(afu->adapter)) {\r\nrc = -EIO;\r\ngoto out;\r\n}\r\ndsisr = cxl_p2n_read(afu, CXL_PSL_DSISR_An);\r\npr_devel_ratelimited("PSL purging... PSL_CNTL: 0x%016llx PSL_DSISR: 0x%016llx\n", PSL_CNTL, dsisr);\r\nif (dsisr & CXL_PSL_DSISR_TRANS) {\r\ndar = cxl_p2n_read(afu, CXL_PSL_DAR_An);\r\ndev_notice(&afu->dev, "PSL purge terminating pending translation, DSISR: 0x%016llx, DAR: 0x%016llx\n", dsisr, dar);\r\ncxl_p2n_write(afu, CXL_PSL_TFC_An, CXL_PSL_TFC_An_AE);\r\n} else if (dsisr) {\r\ndev_notice(&afu->dev, "PSL purge acknowledging pending non-translation fault, DSISR: 0x%016llx\n", dsisr);\r\ncxl_p2n_write(afu, CXL_PSL_TFC_An, CXL_PSL_TFC_An_A);\r\n} else {\r\ncpu_relax();\r\n}\r\nPSL_CNTL = cxl_p1n_read(afu, CXL_PSL_SCNTL_An);\r\n};\r\nend = local_clock();\r\npr_devel("PSL purged in %lld ns\n", end - start);\r\ncxl_p1n_write(afu, CXL_PSL_SCNTL_An,\r\nPSL_CNTL & ~CXL_PSL_SCNTL_An_Pc);\r\nout:\r\ntrace_cxl_psl_ctrl_done(afu, CXL_PSL_SCNTL_An_Pc, rc);\r\nreturn rc;\r\n}\r\nstatic int spa_max_procs(int spa_size)\r\n{\r\nreturn ((spa_size / 8) - 96) / 17;\r\n}\r\nint cxl_alloc_spa(struct cxl_afu *afu)\r\n{\r\nafu->spa_order = 0;\r\ndo {\r\nafu->spa_order++;\r\nafu->spa_size = (1 << afu->spa_order) * PAGE_SIZE;\r\nafu->spa_max_procs = spa_max_procs(afu->spa_size);\r\n} while (afu->spa_max_procs < afu->num_procs);\r\nWARN_ON(afu->spa_size > 0x100000);\r\nif (!(afu->spa = (struct cxl_process_element *)\r\n__get_free_pages(GFP_KERNEL | __GFP_ZERO, afu->spa_order))) {\r\npr_err("cxl_alloc_spa: Unable to allocate scheduled process area\n");\r\nreturn -ENOMEM;\r\n}\r\npr_devel("spa pages: %i afu->spa_max_procs: %i afu->num_procs: %i\n",\r\n1<<afu->spa_order, afu->spa_max_procs, afu->num_procs);\r\nreturn 0;\r\n}\r\nstatic void attach_spa(struct cxl_afu *afu)\r\n{\r\nu64 spap;\r\nafu->sw_command_status = (__be64 *)((char *)afu->spa +\r\n((afu->spa_max_procs + 3) * 128));\r\nspap = virt_to_phys(afu->spa) & CXL_PSL_SPAP_Addr;\r\nspap |= ((afu->spa_size >> (12 - CXL_PSL_SPAP_Size_Shift)) - 1) & CXL_PSL_SPAP_Size;\r\nspap |= CXL_PSL_SPAP_V;\r\npr_devel("cxl: SPA allocated at 0x%p. Max processes: %i, sw_command_status: 0x%p CXL_PSL_SPAP_An=0x%016llx\n", afu->spa, afu->spa_max_procs, afu->sw_command_status, spap);\r\ncxl_p1n_write(afu, CXL_PSL_SPAP_An, spap);\r\n}\r\nstatic inline void detach_spa(struct cxl_afu *afu)\r\n{\r\ncxl_p1n_write(afu, CXL_PSL_SPAP_An, 0);\r\n}\r\nvoid cxl_release_spa(struct cxl_afu *afu)\r\n{\r\nif (afu->spa) {\r\nfree_pages((unsigned long) afu->spa, afu->spa_order);\r\nafu->spa = NULL;\r\n}\r\n}\r\nint cxl_tlb_slb_invalidate(struct cxl *adapter)\r\n{\r\nunsigned long timeout = jiffies + (HZ * CXL_TIMEOUT);\r\npr_devel("CXL adapter wide TLBIA & SLBIA\n");\r\ncxl_p1_write(adapter, CXL_PSL_AFUSEL, CXL_PSL_AFUSEL_A);\r\ncxl_p1_write(adapter, CXL_PSL_TLBIA, CXL_TLB_SLB_IQ_ALL);\r\nwhile (cxl_p1_read(adapter, CXL_PSL_TLBIA) & CXL_TLB_SLB_P) {\r\nif (time_after_eq(jiffies, timeout)) {\r\ndev_warn(&adapter->dev, "WARNING: CXL adapter wide TLBIA timed out!\n");\r\nreturn -EBUSY;\r\n}\r\nif (!cxl_adapter_link_ok(adapter))\r\nreturn -EIO;\r\ncpu_relax();\r\n}\r\ncxl_p1_write(adapter, CXL_PSL_SLBIA, CXL_TLB_SLB_IQ_ALL);\r\nwhile (cxl_p1_read(adapter, CXL_PSL_SLBIA) & CXL_TLB_SLB_P) {\r\nif (time_after_eq(jiffies, timeout)) {\r\ndev_warn(&adapter->dev, "WARNING: CXL adapter wide SLBIA timed out!\n");\r\nreturn -EBUSY;\r\n}\r\nif (!cxl_adapter_link_ok(adapter))\r\nreturn -EIO;\r\ncpu_relax();\r\n}\r\nreturn 0;\r\n}\r\nint cxl_afu_slbia(struct cxl_afu *afu)\r\n{\r\nunsigned long timeout = jiffies + (HZ * CXL_TIMEOUT);\r\npr_devel("cxl_afu_slbia issuing SLBIA command\n");\r\ncxl_p2n_write(afu, CXL_SLBIA_An, CXL_TLB_SLB_IQ_ALL);\r\nwhile (cxl_p2n_read(afu, CXL_SLBIA_An) & CXL_TLB_SLB_P) {\r\nif (time_after_eq(jiffies, timeout)) {\r\ndev_warn(&afu->dev, "WARNING: CXL AFU SLBIA timed out!\n");\r\nreturn -EBUSY;\r\n}\r\nif (!cxl_adapter_link_ok(afu->adapter))\r\nreturn -EIO;\r\ncpu_relax();\r\n}\r\nreturn 0;\r\n}\r\nstatic int cxl_write_sstp(struct cxl_afu *afu, u64 sstp0, u64 sstp1)\r\n{\r\nint rc;\r\ncxl_p2n_write(afu, CXL_SSTP1_An, 0);\r\nif ((rc = cxl_afu_slbia(afu)))\r\nreturn rc;\r\ncxl_p2n_write(afu, CXL_SSTP0_An, sstp0);\r\ncxl_p2n_write(afu, CXL_SSTP1_An, sstp1);\r\nreturn 0;\r\n}\r\nstatic void slb_invalid(struct cxl_context *ctx)\r\n{\r\nstruct cxl *adapter = ctx->afu->adapter;\r\nu64 slbia;\r\nWARN_ON(!mutex_is_locked(&ctx->afu->spa_mutex));\r\ncxl_p1_write(adapter, CXL_PSL_LBISEL,\r\n((u64)be32_to_cpu(ctx->elem->common.pid) << 32) |\r\nbe32_to_cpu(ctx->elem->lpid));\r\ncxl_p1_write(adapter, CXL_PSL_SLBIA, CXL_TLB_SLB_IQ_LPIDPID);\r\nwhile (1) {\r\nif (!cxl_adapter_link_ok(adapter))\r\nbreak;\r\nslbia = cxl_p1_read(adapter, CXL_PSL_SLBIA);\r\nif (!(slbia & CXL_TLB_SLB_P))\r\nbreak;\r\ncpu_relax();\r\n}\r\n}\r\nstatic int do_process_element_cmd(struct cxl_context *ctx,\r\nu64 cmd, u64 pe_state)\r\n{\r\nu64 state;\r\nunsigned long timeout = jiffies + (HZ * CXL_TIMEOUT);\r\nint rc = 0;\r\ntrace_cxl_llcmd(ctx, cmd);\r\nWARN_ON(!ctx->afu->enabled);\r\nctx->elem->software_state = cpu_to_be32(pe_state);\r\nsmp_wmb();\r\n*(ctx->afu->sw_command_status) = cpu_to_be64(cmd | 0 | ctx->pe);\r\nsmp_mb();\r\ncxl_p1n_write(ctx->afu, CXL_PSL_LLCMD_An, cmd | ctx->pe);\r\nwhile (1) {\r\nif (time_after_eq(jiffies, timeout)) {\r\ndev_warn(&ctx->afu->dev, "WARNING: Process Element Command timed out!\n");\r\nrc = -EBUSY;\r\ngoto out;\r\n}\r\nif (!cxl_adapter_link_ok(ctx->afu->adapter)) {\r\ndev_warn(&ctx->afu->dev, "WARNING: Device link down, aborting Process Element Command!\n");\r\nrc = -EIO;\r\ngoto out;\r\n}\r\nstate = be64_to_cpup(ctx->afu->sw_command_status);\r\nif (state == ~0ULL) {\r\npr_err("cxl: Error adding process element to AFU\n");\r\nrc = -1;\r\ngoto out;\r\n}\r\nif ((state & (CXL_SPA_SW_CMD_MASK | CXL_SPA_SW_STATE_MASK | CXL_SPA_SW_LINK_MASK)) ==\r\n(cmd | (cmd >> 16) | ctx->pe))\r\nbreak;\r\nschedule();\r\n}\r\nout:\r\ntrace_cxl_llcmd_done(ctx, cmd, rc);\r\nreturn rc;\r\n}\r\nstatic int add_process_element(struct cxl_context *ctx)\r\n{\r\nint rc = 0;\r\nmutex_lock(&ctx->afu->spa_mutex);\r\npr_devel("%s Adding pe: %i started\n", __func__, ctx->pe);\r\nif (!(rc = do_process_element_cmd(ctx, CXL_SPA_SW_CMD_ADD, CXL_PE_SOFTWARE_STATE_V)))\r\nctx->pe_inserted = true;\r\npr_devel("%s Adding pe: %i finished\n", __func__, ctx->pe);\r\nmutex_unlock(&ctx->afu->spa_mutex);\r\nreturn rc;\r\n}\r\nstatic int terminate_process_element(struct cxl_context *ctx)\r\n{\r\nint rc = 0;\r\nif (!(ctx->elem->software_state & cpu_to_be32(CXL_PE_SOFTWARE_STATE_V)))\r\nreturn rc;\r\nmutex_lock(&ctx->afu->spa_mutex);\r\npr_devel("%s Terminate pe: %i started\n", __func__, ctx->pe);\r\nif (cxl_adapter_link_ok(ctx->afu->adapter))\r\nrc = do_process_element_cmd(ctx, CXL_SPA_SW_CMD_TERMINATE,\r\nCXL_PE_SOFTWARE_STATE_V | CXL_PE_SOFTWARE_STATE_T);\r\nctx->elem->software_state = 0;\r\npr_devel("%s Terminate pe: %i finished\n", __func__, ctx->pe);\r\nmutex_unlock(&ctx->afu->spa_mutex);\r\nreturn rc;\r\n}\r\nstatic int remove_process_element(struct cxl_context *ctx)\r\n{\r\nint rc = 0;\r\nmutex_lock(&ctx->afu->spa_mutex);\r\npr_devel("%s Remove pe: %i started\n", __func__, ctx->pe);\r\nif (cxl_adapter_link_ok(ctx->afu->adapter))\r\nrc = do_process_element_cmd(ctx, CXL_SPA_SW_CMD_REMOVE, 0);\r\nif (!rc)\r\nctx->pe_inserted = false;\r\nslb_invalid(ctx);\r\npr_devel("%s Remove pe: %i finished\n", __func__, ctx->pe);\r\nmutex_unlock(&ctx->afu->spa_mutex);\r\nreturn rc;\r\n}\r\nvoid cxl_assign_psn_space(struct cxl_context *ctx)\r\n{\r\nif (!ctx->afu->pp_size || ctx->master) {\r\nctx->psn_phys = ctx->afu->psn_phys;\r\nctx->psn_size = ctx->afu->adapter->ps_size;\r\n} else {\r\nctx->psn_phys = ctx->afu->psn_phys +\r\n(ctx->afu->pp_offset + ctx->afu->pp_size * ctx->pe);\r\nctx->psn_size = ctx->afu->pp_size;\r\n}\r\n}\r\nstatic int activate_afu_directed(struct cxl_afu *afu)\r\n{\r\nint rc;\r\ndev_info(&afu->dev, "Activating AFU directed mode\n");\r\nafu->num_procs = afu->max_procs_virtualised;\r\nif (afu->spa == NULL) {\r\nif (cxl_alloc_spa(afu))\r\nreturn -ENOMEM;\r\n}\r\nattach_spa(afu);\r\ncxl_p1n_write(afu, CXL_PSL_SCNTL_An, CXL_PSL_SCNTL_An_PM_AFU);\r\ncxl_p1n_write(afu, CXL_PSL_AMOR_An, 0xFFFFFFFFFFFFFFFFULL);\r\ncxl_p1n_write(afu, CXL_PSL_ID_An, CXL_PSL_ID_An_F | CXL_PSL_ID_An_L);\r\nafu->current_mode = CXL_MODE_DIRECTED;\r\nif ((rc = cxl_chardev_m_afu_add(afu)))\r\nreturn rc;\r\nif ((rc = cxl_sysfs_afu_m_add(afu)))\r\ngoto err;\r\nif ((rc = cxl_chardev_s_afu_add(afu)))\r\ngoto err1;\r\nreturn 0;\r\nerr1:\r\ncxl_sysfs_afu_m_remove(afu);\r\nerr:\r\ncxl_chardev_afu_remove(afu);\r\nreturn rc;\r\n}\r\nstatic u64 calculate_sr(struct cxl_context *ctx)\r\n{\r\nu64 sr = 0;\r\nset_endian(sr);\r\nif (ctx->master)\r\nsr |= CXL_PSL_SR_An_MP;\r\nif (mfspr(SPRN_LPCR) & LPCR_TC)\r\nsr |= CXL_PSL_SR_An_TC;\r\nif (ctx->kernel) {\r\nsr |= CXL_PSL_SR_An_R | (mfmsr() & MSR_SF);\r\nsr |= CXL_PSL_SR_An_HV;\r\n} else {\r\nsr |= CXL_PSL_SR_An_PR | CXL_PSL_SR_An_R;\r\nsr &= ~(CXL_PSL_SR_An_HV);\r\nif (!test_tsk_thread_flag(current, TIF_32BIT))\r\nsr |= CXL_PSL_SR_An_SF;\r\n}\r\nreturn sr;\r\n}\r\nstatic int attach_afu_directed(struct cxl_context *ctx, u64 wed, u64 amr)\r\n{\r\nu32 pid;\r\nint r, result;\r\ncxl_assign_psn_space(ctx);\r\nctx->elem->ctxtime = 0;\r\nctx->elem->lpid = cpu_to_be32(mfspr(SPRN_LPID));\r\nctx->elem->haurp = 0;\r\nctx->elem->sdr = cpu_to_be64(mfspr(SPRN_SDR1));\r\npid = current->pid;\r\nif (ctx->kernel)\r\npid = 0;\r\nctx->elem->common.tid = 0;\r\nctx->elem->common.pid = cpu_to_be32(pid);\r\nctx->elem->sr = cpu_to_be64(calculate_sr(ctx));\r\nctx->elem->common.csrp = 0;\r\nctx->elem->common.aurp0 = 0;\r\nctx->elem->common.aurp1 = 0;\r\ncxl_prefault(ctx, wed);\r\nctx->elem->common.sstp0 = cpu_to_be64(ctx->sstp0);\r\nctx->elem->common.sstp1 = cpu_to_be64(ctx->sstp1);\r\nfor (r = 0; r < CXL_IRQ_RANGES; r++) {\r\nctx->elem->ivte_offsets[r] = cpu_to_be16(ctx->irqs.offset[r]);\r\nctx->elem->ivte_ranges[r] = cpu_to_be16(ctx->irqs.range[r]);\r\n}\r\nctx->elem->common.amr = cpu_to_be64(amr);\r\nctx->elem->common.wed = cpu_to_be64(wed);\r\nif ((result = cxl_afu_check_and_enable(ctx->afu)))\r\nreturn result;\r\nreturn add_process_element(ctx);\r\n}\r\nstatic int deactivate_afu_directed(struct cxl_afu *afu)\r\n{\r\ndev_info(&afu->dev, "Deactivating AFU directed mode\n");\r\nafu->current_mode = 0;\r\nafu->num_procs = 0;\r\ncxl_sysfs_afu_m_remove(afu);\r\ncxl_chardev_afu_remove(afu);\r\n__cxl_afu_reset(afu);\r\ncxl_afu_disable(afu);\r\ncxl_psl_purge(afu);\r\nreturn 0;\r\n}\r\nstatic int activate_dedicated_process(struct cxl_afu *afu)\r\n{\r\ndev_info(&afu->dev, "Activating dedicated process mode\n");\r\ncxl_p1n_write(afu, CXL_PSL_SCNTL_An, CXL_PSL_SCNTL_An_PM_Process);\r\ncxl_p1n_write(afu, CXL_PSL_CtxTime_An, 0);\r\ncxl_p1n_write(afu, CXL_PSL_SPAP_An, 0);\r\ncxl_p1n_write(afu, CXL_PSL_AMOR_An, 0xFFFFFFFFFFFFFFFFULL);\r\ncxl_p1n_write(afu, CXL_PSL_LPID_An, mfspr(SPRN_LPID));\r\ncxl_p1n_write(afu, CXL_HAURP_An, 0);\r\ncxl_p1n_write(afu, CXL_PSL_SDR_An, mfspr(SPRN_SDR1));\r\ncxl_p2n_write(afu, CXL_CSRP_An, 0);\r\ncxl_p2n_write(afu, CXL_AURP0_An, 0);\r\ncxl_p2n_write(afu, CXL_AURP1_An, 0);\r\nafu->current_mode = CXL_MODE_DEDICATED;\r\nafu->num_procs = 1;\r\nreturn cxl_chardev_d_afu_add(afu);\r\n}\r\nstatic int attach_dedicated(struct cxl_context *ctx, u64 wed, u64 amr)\r\n{\r\nstruct cxl_afu *afu = ctx->afu;\r\nu64 pid;\r\nint rc;\r\npid = (u64)current->pid << 32;\r\nif (ctx->kernel)\r\npid = 0;\r\ncxl_p2n_write(afu, CXL_PSL_PID_TID_An, pid);\r\ncxl_p1n_write(afu, CXL_PSL_SR_An, calculate_sr(ctx));\r\nif ((rc = cxl_write_sstp(afu, ctx->sstp0, ctx->sstp1)))\r\nreturn rc;\r\ncxl_prefault(ctx, wed);\r\ncxl_p1n_write(afu, CXL_PSL_IVTE_Offset_An,\r\n(((u64)ctx->irqs.offset[0] & 0xffff) << 48) |\r\n(((u64)ctx->irqs.offset[1] & 0xffff) << 32) |\r\n(((u64)ctx->irqs.offset[2] & 0xffff) << 16) |\r\n((u64)ctx->irqs.offset[3] & 0xffff));\r\ncxl_p1n_write(afu, CXL_PSL_IVTE_Limit_An, (u64)\r\n(((u64)ctx->irqs.range[0] & 0xffff) << 48) |\r\n(((u64)ctx->irqs.range[1] & 0xffff) << 32) |\r\n(((u64)ctx->irqs.range[2] & 0xffff) << 16) |\r\n((u64)ctx->irqs.range[3] & 0xffff));\r\ncxl_p2n_write(afu, CXL_PSL_AMR_An, amr);\r\ncxl_assign_psn_space(ctx);\r\nif ((rc = __cxl_afu_reset(afu)))\r\nreturn rc;\r\ncxl_p2n_write(afu, CXL_PSL_WED_An, wed);\r\nreturn afu_enable(afu);\r\n}\r\nstatic int deactivate_dedicated_process(struct cxl_afu *afu)\r\n{\r\ndev_info(&afu->dev, "Deactivating dedicated process mode\n");\r\nafu->current_mode = 0;\r\nafu->num_procs = 0;\r\ncxl_chardev_afu_remove(afu);\r\nreturn 0;\r\n}\r\nint _cxl_afu_deactivate_mode(struct cxl_afu *afu, int mode)\r\n{\r\nif (mode == CXL_MODE_DIRECTED)\r\nreturn deactivate_afu_directed(afu);\r\nif (mode == CXL_MODE_DEDICATED)\r\nreturn deactivate_dedicated_process(afu);\r\nreturn 0;\r\n}\r\nint cxl_afu_deactivate_mode(struct cxl_afu *afu)\r\n{\r\nreturn _cxl_afu_deactivate_mode(afu, afu->current_mode);\r\n}\r\nint cxl_afu_activate_mode(struct cxl_afu *afu, int mode)\r\n{\r\nif (!mode)\r\nreturn 0;\r\nif (!(mode & afu->modes_supported))\r\nreturn -EINVAL;\r\nif (!cxl_adapter_link_ok(afu->adapter)) {\r\nWARN(1, "Device link is down, refusing to activate!\n");\r\nreturn -EIO;\r\n}\r\nif (mode == CXL_MODE_DIRECTED)\r\nreturn activate_afu_directed(afu);\r\nif (mode == CXL_MODE_DEDICATED)\r\nreturn activate_dedicated_process(afu);\r\nreturn -EINVAL;\r\n}\r\nint cxl_attach_process(struct cxl_context *ctx, bool kernel, u64 wed, u64 amr)\r\n{\r\nif (!cxl_adapter_link_ok(ctx->afu->adapter)) {\r\nWARN(1, "Device link is down, refusing to attach process!\n");\r\nreturn -EIO;\r\n}\r\nctx->kernel = kernel;\r\nif (ctx->afu->current_mode == CXL_MODE_DIRECTED)\r\nreturn attach_afu_directed(ctx, wed, amr);\r\nif (ctx->afu->current_mode == CXL_MODE_DEDICATED)\r\nreturn attach_dedicated(ctx, wed, amr);\r\nreturn -EINVAL;\r\n}\r\nstatic inline int detach_process_native_dedicated(struct cxl_context *ctx)\r\n{\r\n__cxl_afu_reset(ctx->afu);\r\ncxl_afu_disable(ctx->afu);\r\ncxl_psl_purge(ctx->afu);\r\nreturn 0;\r\n}\r\nstatic inline int detach_process_native_afu_directed(struct cxl_context *ctx)\r\n{\r\nif (!ctx->pe_inserted)\r\nreturn 0;\r\nif (terminate_process_element(ctx))\r\nreturn -1;\r\nif (remove_process_element(ctx))\r\nreturn -1;\r\nreturn 0;\r\n}\r\nint cxl_detach_process(struct cxl_context *ctx)\r\n{\r\ntrace_cxl_detach(ctx);\r\nif (ctx->afu->current_mode == CXL_MODE_DEDICATED)\r\nreturn detach_process_native_dedicated(ctx);\r\nreturn detach_process_native_afu_directed(ctx);\r\n}\r\nint cxl_get_irq(struct cxl_afu *afu, struct cxl_irq_info *info)\r\n{\r\nu64 pidtid;\r\nif (!cxl_adapter_link_ok(afu->adapter))\r\nreturn -EIO;\r\ninfo->dsisr = cxl_p2n_read(afu, CXL_PSL_DSISR_An);\r\ninfo->dar = cxl_p2n_read(afu, CXL_PSL_DAR_An);\r\ninfo->dsr = cxl_p2n_read(afu, CXL_PSL_DSR_An);\r\npidtid = cxl_p2n_read(afu, CXL_PSL_PID_TID_An);\r\ninfo->pid = pidtid >> 32;\r\ninfo->tid = pidtid & 0xffffffff;\r\ninfo->afu_err = cxl_p2n_read(afu, CXL_AFU_ERR_An);\r\ninfo->errstat = cxl_p2n_read(afu, CXL_PSL_ErrStat_An);\r\nreturn 0;\r\n}\r\nstatic void recover_psl_err(struct cxl_afu *afu, u64 errstat)\r\n{\r\nu64 dsisr;\r\npr_devel("RECOVERING FROM PSL ERROR... (0x%016llx)\n", errstat);\r\ndsisr = cxl_p2n_read(afu, CXL_PSL_DSISR_An);\r\ncxl_p2n_write(afu, CXL_PSL_DSISR_An, dsisr & ~CXL_PSL_DSISR_An_PE);\r\ncxl_p2n_write(afu, CXL_PSL_ErrStat_An, errstat);\r\n}\r\nint cxl_ack_irq(struct cxl_context *ctx, u64 tfc, u64 psl_reset_mask)\r\n{\r\ntrace_cxl_psl_irq_ack(ctx, tfc);\r\nif (tfc)\r\ncxl_p2n_write(ctx->afu, CXL_PSL_TFC_An, tfc);\r\nif (psl_reset_mask)\r\nrecover_psl_err(ctx->afu, psl_reset_mask);\r\nreturn 0;\r\n}\r\nint cxl_check_error(struct cxl_afu *afu)\r\n{\r\nreturn (cxl_p1n_read(afu, CXL_PSL_SCNTL_An) == ~0ULL);\r\n}
