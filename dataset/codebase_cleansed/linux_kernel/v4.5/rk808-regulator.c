static int rk808_buck1_2_get_voltage_sel_regmap(struct regulator_dev *rdev)\r\n{\r\nstruct rk808_regulator_data *pdata = rdev_get_drvdata(rdev);\r\nint id = rdev->desc->id - RK808_ID_DCDC1;\r\nstruct gpio_desc *gpio = pdata->dvs_gpio[id];\r\nunsigned int val;\r\nint ret;\r\nif (!gpio || gpiod_get_value(gpio) == 0)\r\nreturn regulator_get_voltage_sel_regmap(rdev);\r\nret = regmap_read(rdev->regmap,\r\nrdev->desc->vsel_reg + RK808_DVS_REG_OFFSET,\r\n&val);\r\nif (ret != 0)\r\nreturn ret;\r\nval &= rdev->desc->vsel_mask;\r\nval >>= ffs(rdev->desc->vsel_mask) - 1;\r\nreturn val;\r\n}\r\nstatic int rk808_buck1_2_i2c_set_voltage_sel(struct regulator_dev *rdev,\r\nunsigned sel)\r\n{\r\nint ret, delta_sel;\r\nunsigned int old_sel, tmp, val, mask = rdev->desc->vsel_mask;\r\nret = regmap_read(rdev->regmap, rdev->desc->vsel_reg, &val);\r\nif (ret != 0)\r\nreturn ret;\r\ntmp = val & ~mask;\r\nold_sel = val & mask;\r\nold_sel >>= ffs(mask) - 1;\r\ndelta_sel = sel - old_sel;\r\nwhile (delta_sel > MAX_STEPS_ONE_TIME) {\r\nold_sel += MAX_STEPS_ONE_TIME;\r\nval = old_sel << (ffs(mask) - 1);\r\nval |= tmp;\r\nret = regmap_write(rdev->regmap, rdev->desc->vsel_reg, val);\r\ndelta_sel = sel - old_sel;\r\n}\r\nsel <<= ffs(mask) - 1;\r\nval = tmp | sel;\r\nret = regmap_write(rdev->regmap, rdev->desc->vsel_reg, val);\r\nudelay(1);\r\nreturn ret;\r\n}\r\nstatic int rk808_buck1_2_set_voltage_sel(struct regulator_dev *rdev,\r\nunsigned sel)\r\n{\r\nstruct rk808_regulator_data *pdata = rdev_get_drvdata(rdev);\r\nint id = rdev->desc->id - RK808_ID_DCDC1;\r\nstruct gpio_desc *gpio = pdata->dvs_gpio[id];\r\nunsigned int reg = rdev->desc->vsel_reg;\r\nunsigned old_sel;\r\nint ret, gpio_level;\r\nif (!gpio)\r\nreturn rk808_buck1_2_i2c_set_voltage_sel(rdev, sel);\r\ngpio_level = gpiod_get_value(gpio);\r\nif (gpio_level == 0) {\r\nreg += RK808_DVS_REG_OFFSET;\r\nret = regmap_read(rdev->regmap, rdev->desc->vsel_reg, &old_sel);\r\n} else {\r\nret = regmap_read(rdev->regmap,\r\nreg + RK808_DVS_REG_OFFSET,\r\n&old_sel);\r\n}\r\nif (ret != 0)\r\nreturn ret;\r\nsel <<= ffs(rdev->desc->vsel_mask) - 1;\r\nsel |= old_sel & ~rdev->desc->vsel_mask;\r\nret = regmap_write(rdev->regmap, reg, sel);\r\nif (ret)\r\nreturn ret;\r\ngpiod_set_value(gpio, !gpio_level);\r\nreturn ret;\r\n}\r\nstatic int rk808_buck1_2_set_voltage_time_sel(struct regulator_dev *rdev,\r\nunsigned int old_selector,\r\nunsigned int new_selector)\r\n{\r\nstruct rk808_regulator_data *pdata = rdev_get_drvdata(rdev);\r\nint id = rdev->desc->id - RK808_ID_DCDC1;\r\nstruct gpio_desc *gpio = pdata->dvs_gpio[id];\r\nif (!gpio)\r\nreturn 0;\r\nreturn regulator_set_voltage_time_sel(rdev, old_selector, new_selector);\r\n}\r\nstatic int rk808_set_ramp_delay(struct regulator_dev *rdev, int ramp_delay)\r\n{\r\nunsigned int ramp_value = RK808_RAMP_RATE_10MV_PER_US;\r\nunsigned int reg = rk808_buck_config_regs[rdev->desc->id -\r\nRK808_ID_DCDC1];\r\nswitch (ramp_delay) {\r\ncase 1 ... 2000:\r\nramp_value = RK808_RAMP_RATE_2MV_PER_US;\r\nbreak;\r\ncase 2001 ... 4000:\r\nramp_value = RK808_RAMP_RATE_4MV_PER_US;\r\nbreak;\r\ncase 4001 ... 6000:\r\nramp_value = RK808_RAMP_RATE_6MV_PER_US;\r\nbreak;\r\ncase 6001 ... 10000:\r\nbreak;\r\ndefault:\r\npr_warn("%s ramp_delay: %d not supported, setting 10000\n",\r\nrdev->desc->name, ramp_delay);\r\n}\r\nreturn regmap_update_bits(rdev->regmap, reg,\r\nRK808_RAMP_RATE_MASK, ramp_value);\r\n}\r\nstatic int rk808_set_suspend_voltage(struct regulator_dev *rdev, int uv)\r\n{\r\nunsigned int reg;\r\nint sel = regulator_map_voltage_linear_range(rdev, uv, uv);\r\nif (sel < 0)\r\nreturn -EINVAL;\r\nreg = rdev->desc->vsel_reg + RK808_SLP_REG_OFFSET;\r\nreturn regmap_update_bits(rdev->regmap, reg,\r\nrdev->desc->vsel_mask,\r\nsel);\r\n}\r\nstatic int rk808_set_suspend_enable(struct regulator_dev *rdev)\r\n{\r\nunsigned int reg;\r\nreg = rdev->desc->enable_reg + RK808_SLP_SET_OFF_REG_OFFSET;\r\nreturn regmap_update_bits(rdev->regmap, reg,\r\nrdev->desc->enable_mask,\r\n0);\r\n}\r\nstatic int rk808_set_suspend_disable(struct regulator_dev *rdev)\r\n{\r\nunsigned int reg;\r\nreg = rdev->desc->enable_reg + RK808_SLP_SET_OFF_REG_OFFSET;\r\nreturn regmap_update_bits(rdev->regmap, reg,\r\nrdev->desc->enable_mask,\r\nrdev->desc->enable_mask);\r\n}\r\nstatic int rk808_regulator_dt_parse_pdata(struct device *dev,\r\nstruct device *client_dev,\r\nstruct regmap *map,\r\nstruct rk808_regulator_data *pdata)\r\n{\r\nstruct device_node *np;\r\nint tmp, ret, i;\r\nnp = of_get_child_by_name(client_dev->of_node, "regulators");\r\nif (!np)\r\nreturn -ENXIO;\r\nret = of_regulator_match(dev, np, rk808_reg_matches,\r\nRK808_NUM_REGULATORS);\r\nif (ret < 0)\r\ngoto dt_parse_end;\r\nfor (i = 0; i < ARRAY_SIZE(pdata->dvs_gpio); i++) {\r\npdata->dvs_gpio[i] =\r\ndevm_gpiod_get_index_optional(client_dev, "dvs", i,\r\nGPIOD_OUT_LOW);\r\nif (IS_ERR(pdata->dvs_gpio[i])) {\r\nret = PTR_ERR(pdata->dvs_gpio[i]);\r\ndev_err(dev, "failed to get dvs%d gpio (%d)\n", i, ret);\r\ngoto dt_parse_end;\r\n}\r\nif (!pdata->dvs_gpio[i]) {\r\ndev_warn(dev, "there is no dvs%d gpio\n", i);\r\ncontinue;\r\n}\r\ntmp = i ? RK808_DVS2_POL : RK808_DVS1_POL;\r\nret = regmap_update_bits(map, RK808_IO_POL_REG, tmp,\r\ngpiod_is_active_low(pdata->dvs_gpio[i]) ?\r\n0 : tmp);\r\n}\r\ndt_parse_end:\r\nof_node_put(np);\r\nreturn ret;\r\n}\r\nstatic int rk808_regulator_probe(struct platform_device *pdev)\r\n{\r\nstruct rk808 *rk808 = dev_get_drvdata(pdev->dev.parent);\r\nstruct i2c_client *client = rk808->i2c;\r\nstruct regulator_config config = {};\r\nstruct regulator_dev *rk808_rdev;\r\nstruct rk808_regulator_data *pdata;\r\nint ret, i;\r\npdata = devm_kzalloc(&pdev->dev, sizeof(*pdata), GFP_KERNEL);\r\nif (!pdata)\r\nreturn -ENOMEM;\r\nret = rk808_regulator_dt_parse_pdata(&pdev->dev, &client->dev,\r\nrk808->regmap, pdata);\r\nif (ret < 0)\r\nreturn ret;\r\nplatform_set_drvdata(pdev, pdata);\r\nfor (i = 0; i < RK808_NUM_REGULATORS; i++) {\r\nif (!rk808_reg_matches[i].init_data ||\r\n!rk808_reg_matches[i].of_node)\r\ncontinue;\r\nconfig.dev = &client->dev;\r\nconfig.driver_data = pdata;\r\nconfig.regmap = rk808->regmap;\r\nconfig.of_node = rk808_reg_matches[i].of_node;\r\nconfig.init_data = rk808_reg_matches[i].init_data;\r\nrk808_rdev = devm_regulator_register(&pdev->dev,\r\n&rk808_reg[i], &config);\r\nif (IS_ERR(rk808_rdev)) {\r\ndev_err(&client->dev,\r\n"failed to register %d regulator\n", i);\r\nreturn PTR_ERR(rk808_rdev);\r\n}\r\n}\r\nreturn 0;\r\n}
