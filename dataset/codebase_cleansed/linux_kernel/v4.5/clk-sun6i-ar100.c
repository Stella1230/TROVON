static inline struct ar100_clk *to_ar100_clk(struct clk_hw *hw)\r\n{\r\nreturn container_of(hw, struct ar100_clk, hw);\r\n}\r\nstatic unsigned long ar100_recalc_rate(struct clk_hw *hw,\r\nunsigned long parent_rate)\r\n{\r\nstruct ar100_clk *clk = to_ar100_clk(hw);\r\nu32 val = readl(clk->reg);\r\nint shift = (val >> SUN6I_AR100_SHIFT_SHIFT) & SUN6I_AR100_SHIFT_MASK;\r\nint div = (val >> SUN6I_AR100_DIV_SHIFT) & SUN6I_AR100_DIV_MASK;\r\nreturn (parent_rate >> shift) / (div + 1);\r\n}\r\nstatic int ar100_determine_rate(struct clk_hw *hw,\r\nstruct clk_rate_request *req)\r\n{\r\nint nparents = clk_hw_get_num_parents(hw);\r\nlong best_rate = -EINVAL;\r\nint i;\r\nreq->best_parent_hw = NULL;\r\nfor (i = 0; i < nparents; i++) {\r\nunsigned long parent_rate;\r\nunsigned long tmp_rate;\r\nstruct clk_hw *parent;\r\nunsigned long div;\r\nint shift;\r\nparent = clk_hw_get_parent_by_index(hw, i);\r\nparent_rate = clk_hw_get_rate(parent);\r\ndiv = DIV_ROUND_UP(parent_rate, req->rate);\r\nshift = ffs(div) - 1;\r\nif (shift > SUN6I_AR100_SHIFT_MAX)\r\nshift = SUN6I_AR100_SHIFT_MAX;\r\ndiv >>= shift;\r\nwhile (div > SUN6I_AR100_DIV_MAX) {\r\nshift++;\r\ndiv >>= 1;\r\nif (shift > SUN6I_AR100_SHIFT_MAX)\r\nbreak;\r\n}\r\nif (shift > SUN6I_AR100_SHIFT_MAX)\r\ncontinue;\r\ntmp_rate = (parent_rate >> shift) / div;\r\nif (!req->best_parent_hw || tmp_rate > best_rate) {\r\nreq->best_parent_hw = parent;\r\nreq->best_parent_rate = parent_rate;\r\nbest_rate = tmp_rate;\r\n}\r\n}\r\nif (best_rate < 0)\r\nreturn best_rate;\r\nreq->rate = best_rate;\r\nreturn 0;\r\n}\r\nstatic int ar100_set_parent(struct clk_hw *hw, u8 index)\r\n{\r\nstruct ar100_clk *clk = to_ar100_clk(hw);\r\nu32 val = readl(clk->reg);\r\nif (index >= SUN6I_AR100_MAX_PARENTS)\r\nreturn -EINVAL;\r\nval &= ~(SUN6I_AR100_MUX_MASK << SUN6I_AR100_MUX_SHIFT);\r\nval |= (index << SUN6I_AR100_MUX_SHIFT);\r\nwritel(val, clk->reg);\r\nreturn 0;\r\n}\r\nstatic u8 ar100_get_parent(struct clk_hw *hw)\r\n{\r\nstruct ar100_clk *clk = to_ar100_clk(hw);\r\nreturn (readl(clk->reg) >> SUN6I_AR100_MUX_SHIFT) &\r\nSUN6I_AR100_MUX_MASK;\r\n}\r\nstatic int ar100_set_rate(struct clk_hw *hw, unsigned long rate,\r\nunsigned long parent_rate)\r\n{\r\nunsigned long div = parent_rate / rate;\r\nstruct ar100_clk *clk = to_ar100_clk(hw);\r\nu32 val = readl(clk->reg);\r\nint shift;\r\nif (parent_rate % rate)\r\nreturn -EINVAL;\r\nshift = ffs(div) - 1;\r\nif (shift > SUN6I_AR100_SHIFT_MAX)\r\nshift = SUN6I_AR100_SHIFT_MAX;\r\ndiv >>= shift;\r\nif (div > SUN6I_AR100_DIV_MAX)\r\nreturn -EINVAL;\r\nval &= ~((SUN6I_AR100_SHIFT_MASK << SUN6I_AR100_SHIFT_SHIFT) |\r\n(SUN6I_AR100_DIV_MASK << SUN6I_AR100_DIV_SHIFT));\r\nval |= (shift << SUN6I_AR100_SHIFT_SHIFT) |\r\n(div << SUN6I_AR100_DIV_SHIFT);\r\nwritel(val, clk->reg);\r\nreturn 0;\r\n}\r\nstatic int sun6i_a31_ar100_clk_probe(struct platform_device *pdev)\r\n{\r\nconst char *parents[SUN6I_AR100_MAX_PARENTS];\r\nstruct device_node *np = pdev->dev.of_node;\r\nconst char *clk_name = np->name;\r\nstruct clk_init_data init;\r\nstruct ar100_clk *ar100;\r\nstruct resource *r;\r\nstruct clk *clk;\r\nint nparents;\r\nar100 = devm_kzalloc(&pdev->dev, sizeof(*ar100), GFP_KERNEL);\r\nif (!ar100)\r\nreturn -ENOMEM;\r\nr = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nar100->reg = devm_ioremap_resource(&pdev->dev, r);\r\nif (IS_ERR(ar100->reg))\r\nreturn PTR_ERR(ar100->reg);\r\nnparents = of_clk_get_parent_count(np);\r\nif (nparents > SUN6I_AR100_MAX_PARENTS)\r\nnparents = SUN6I_AR100_MAX_PARENTS;\r\nof_clk_parent_fill(np, parents, nparents);\r\nof_property_read_string(np, "clock-output-names", &clk_name);\r\ninit.name = clk_name;\r\ninit.ops = &ar100_ops;\r\ninit.parent_names = parents;\r\ninit.num_parents = nparents;\r\ninit.flags = 0;\r\nar100->hw.init = &init;\r\nclk = clk_register(&pdev->dev, &ar100->hw);\r\nif (IS_ERR(clk))\r\nreturn PTR_ERR(clk);\r\nreturn of_clk_add_provider(np, of_clk_src_simple_get, clk);\r\n}
