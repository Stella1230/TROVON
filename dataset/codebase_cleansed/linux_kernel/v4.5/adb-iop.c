static void adb_iop_end_req(struct adb_request *req, int state)\r\n{\r\nreq->complete = 1;\r\ncurrent_req = req->next;\r\nif (req->done) (*req->done)(req);\r\nadb_iop_state = state;\r\n}\r\nstatic void adb_iop_complete(struct iop_msg *msg)\r\n{\r\nstruct adb_request *req;\r\nunsigned long flags;\r\nlocal_irq_save(flags);\r\nreq = current_req;\r\nif ((adb_iop_state == sending) && req && req->reply_expected) {\r\nadb_iop_state = awaiting_reply;\r\n}\r\nlocal_irq_restore(flags);\r\n}\r\nstatic void adb_iop_listen(struct iop_msg *msg)\r\n{\r\nstruct adb_iopmsg *amsg = (struct adb_iopmsg *) msg->message;\r\nstruct adb_request *req;\r\nunsigned long flags;\r\n#ifdef DEBUG_ADB_IOP\r\nint i;\r\n#endif\r\nlocal_irq_save(flags);\r\nreq = current_req;\r\n#ifdef DEBUG_ADB_IOP\r\nprintk("adb_iop_listen %p: rcvd packet, %d bytes: %02X %02X", req,\r\n(uint) amsg->count + 2, (uint) amsg->flags, (uint) amsg->cmd);\r\nfor (i = 0; i < amsg->count; i++)\r\nprintk(" %02X", (uint) amsg->data[i]);\r\nprintk("\n");\r\n#endif\r\nif (amsg->flags & ADB_IOP_TIMEOUT) {\r\nmsg->reply[0] = ADB_IOP_TIMEOUT | ADB_IOP_AUTOPOLL;\r\nmsg->reply[1] = 0;\r\nmsg->reply[2] = 0;\r\nif (req && (adb_iop_state != idle)) {\r\nadb_iop_end_req(req, idle);\r\n}\r\n} else {\r\nif ((adb_iop_state == awaiting_reply) &&\r\n(amsg->flags & ADB_IOP_EXPLICIT)) {\r\nreq->reply_len = amsg->count + 1;\r\nmemcpy(req->reply, &amsg->cmd, req->reply_len);\r\n} else {\r\nadb_input(&amsg->cmd, amsg->count + 1,\r\namsg->flags & ADB_IOP_AUTOPOLL);\r\n}\r\nmemcpy(msg->reply, msg->message, IOP_MSG_LEN);\r\n}\r\niop_complete_message(msg);\r\nlocal_irq_restore(flags);\r\n}\r\nstatic void adb_iop_start(void)\r\n{\r\nunsigned long flags;\r\nstruct adb_request *req;\r\nstruct adb_iopmsg amsg;\r\n#ifdef DEBUG_ADB_IOP\r\nint i;\r\n#endif\r\nreq = current_req;\r\nif (!req) return;\r\nlocal_irq_save(flags);\r\n#ifdef DEBUG_ADB_IOP\r\nprintk("adb_iop_start %p: sending packet, %d bytes:", req, req->nbytes);\r\nfor (i = 0 ; i < req->nbytes ; i++)\r\nprintk(" %02X", (uint) req->data[i]);\r\nprintk("\n");\r\n#endif\r\namsg.flags = ADB_IOP_EXPLICIT;\r\namsg.count = req->nbytes - 2;\r\nmemcpy(&amsg.cmd, req->data + 1, req->nbytes - 1);\r\nreq->sent = 1;\r\nadb_iop_state = sending;\r\nlocal_irq_restore(flags);\r\niop_send_message(ADB_IOP, ADB_CHAN, req,\r\nsizeof(amsg), (__u8 *) &amsg, adb_iop_complete);\r\n}\r\nint adb_iop_probe(void)\r\n{\r\nif (!iop_ism_present) return -ENODEV;\r\nreturn 0;\r\n}\r\nint adb_iop_init(void)\r\n{\r\nprintk("adb: IOP ISM driver v0.4 for Unified ADB.\n");\r\niop_listen(ADB_IOP, ADB_CHAN, adb_iop_listen, "ADB");\r\nreturn 0;\r\n}\r\nint adb_iop_send_request(struct adb_request *req, int sync)\r\n{\r\nint err;\r\nerr = adb_iop_write(req);\r\nif (err) return err;\r\nif (sync) {\r\nwhile (!req->complete) adb_iop_poll();\r\n}\r\nreturn 0;\r\n}\r\nstatic int adb_iop_write(struct adb_request *req)\r\n{\r\nunsigned long flags;\r\nif ((req->nbytes < 2) || (req->data[0] != ADB_PACKET)) {\r\nreq->complete = 1;\r\nreturn -EINVAL;\r\n}\r\nlocal_irq_save(flags);\r\nreq->next = NULL;\r\nreq->sent = 0;\r\nreq->complete = 0;\r\nreq->reply_len = 0;\r\nif (current_req != 0) {\r\nlast_req->next = req;\r\nlast_req = req;\r\n} else {\r\ncurrent_req = req;\r\nlast_req = req;\r\n}\r\nlocal_irq_restore(flags);\r\nif (adb_iop_state == idle) adb_iop_start();\r\nreturn 0;\r\n}\r\nint adb_iop_autopoll(int devs)\r\n{\r\nreturn 0;\r\n}\r\nvoid adb_iop_poll(void)\r\n{\r\nif (adb_iop_state == idle) adb_iop_start();\r\niop_ism_irq(0, (void *) ADB_IOP);\r\n}\r\nint adb_iop_reset_bus(void)\r\n{\r\nstruct adb_request req = {\r\n.reply_expected = 0,\r\n.nbytes = 2,\r\n.data = { ADB_PACKET, 0 },\r\n};\r\nadb_iop_write(&req);\r\nwhile (!req.complete) {\r\nadb_iop_poll();\r\nschedule();\r\n}\r\nreturn 0;\r\n}
