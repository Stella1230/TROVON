static int __get_num_vlan_infos(struct net_bridge_vlan_group *vg,\r\nu32 filter_mask)\r\n{\r\nstruct net_bridge_vlan *v;\r\nu16 vid_range_start = 0, vid_range_end = 0, vid_range_flags = 0;\r\nu16 flags, pvid;\r\nint num_vlans = 0;\r\nif (!(filter_mask & RTEXT_FILTER_BRVLAN_COMPRESSED))\r\nreturn 0;\r\npvid = br_get_pvid(vg);\r\nlist_for_each_entry_rcu(v, &vg->vlan_list, vlist) {\r\nflags = 0;\r\nif (!br_vlan_should_use(v))\r\ncontinue;\r\nif (v->vid == pvid)\r\nflags |= BRIDGE_VLAN_INFO_PVID;\r\nif (v->flags & BRIDGE_VLAN_INFO_UNTAGGED)\r\nflags |= BRIDGE_VLAN_INFO_UNTAGGED;\r\nif (vid_range_start == 0) {\r\ngoto initvars;\r\n} else if ((v->vid - vid_range_end) == 1 &&\r\nflags == vid_range_flags) {\r\nvid_range_end = v->vid;\r\ncontinue;\r\n} else {\r\nif ((vid_range_end - vid_range_start) > 0)\r\nnum_vlans += 2;\r\nelse\r\nnum_vlans += 1;\r\n}\r\ninitvars:\r\nvid_range_start = v->vid;\r\nvid_range_end = v->vid;\r\nvid_range_flags = flags;\r\n}\r\nif (vid_range_start != 0) {\r\nif ((vid_range_end - vid_range_start) > 0)\r\nnum_vlans += 2;\r\nelse\r\nnum_vlans += 1;\r\n}\r\nreturn num_vlans;\r\n}\r\nstatic int br_get_num_vlan_infos(struct net_bridge_vlan_group *vg,\r\nu32 filter_mask)\r\n{\r\nint num_vlans;\r\nif (!vg)\r\nreturn 0;\r\nif (filter_mask & RTEXT_FILTER_BRVLAN)\r\nreturn vg->num_vlans;\r\nrcu_read_lock();\r\nnum_vlans = __get_num_vlan_infos(vg, filter_mask);\r\nrcu_read_unlock();\r\nreturn num_vlans;\r\n}\r\nstatic size_t br_get_link_af_size_filtered(const struct net_device *dev,\r\nu32 filter_mask)\r\n{\r\nstruct net_bridge_vlan_group *vg = NULL;\r\nstruct net_bridge_port *p;\r\nstruct net_bridge *br;\r\nint num_vlan_infos;\r\nrcu_read_lock();\r\nif (br_port_exists(dev)) {\r\np = br_port_get_rcu(dev);\r\nvg = nbp_vlan_group_rcu(p);\r\n} else if (dev->priv_flags & IFF_EBRIDGE) {\r\nbr = netdev_priv(dev);\r\nvg = br_vlan_group_rcu(br);\r\n}\r\nnum_vlan_infos = br_get_num_vlan_infos(vg, filter_mask);\r\nrcu_read_unlock();\r\nreturn num_vlan_infos * nla_total_size(sizeof(struct bridge_vlan_info));\r\n}\r\nstatic inline size_t br_port_info_size(void)\r\n{\r\nreturn nla_total_size(1)\r\n+ nla_total_size(2)\r\n+ nla_total_size(4)\r\n+ nla_total_size(1)\r\n+ nla_total_size(1)\r\n+ nla_total_size(1)\r\n+ nla_total_size(1)\r\n+ nla_total_size(1)\r\n+ nla_total_size(1)\r\n+ nla_total_size(1)\r\n+ nla_total_size(1)\r\n+ nla_total_size(sizeof(struct ifla_bridge_id))\r\n+ nla_total_size(sizeof(struct ifla_bridge_id))\r\n+ nla_total_size(sizeof(u16))\r\n+ nla_total_size(sizeof(u16))\r\n+ nla_total_size(sizeof(u16))\r\n+ nla_total_size(sizeof(u16))\r\n+ nla_total_size(sizeof(u8))\r\n+ nla_total_size(sizeof(u8))\r\n+ nla_total_size(sizeof(u64))\r\n+ nla_total_size(sizeof(u64))\r\n+ nla_total_size(sizeof(u64))\r\n#ifdef CONFIG_BRIDGE_IGMP_SNOOPING\r\n+ nla_total_size(sizeof(u8))\r\n#endif\r\n+ 0;\r\n}\r\nstatic inline size_t br_nlmsg_size(struct net_device *dev, u32 filter_mask)\r\n{\r\nreturn NLMSG_ALIGN(sizeof(struct ifinfomsg))\r\n+ nla_total_size(IFNAMSIZ)\r\n+ nla_total_size(MAX_ADDR_LEN)\r\n+ nla_total_size(4)\r\n+ nla_total_size(4)\r\n+ nla_total_size(4)\r\n+ nla_total_size(1)\r\n+ nla_total_size(br_port_info_size())\r\n+ nla_total_size(br_get_link_af_size_filtered(dev,\r\nfilter_mask));\r\n}\r\nstatic int br_port_fill_attrs(struct sk_buff *skb,\r\nconst struct net_bridge_port *p)\r\n{\r\nu8 mode = !!(p->flags & BR_HAIRPIN_MODE);\r\nu64 timerval;\r\nif (nla_put_u8(skb, IFLA_BRPORT_STATE, p->state) ||\r\nnla_put_u16(skb, IFLA_BRPORT_PRIORITY, p->priority) ||\r\nnla_put_u32(skb, IFLA_BRPORT_COST, p->path_cost) ||\r\nnla_put_u8(skb, IFLA_BRPORT_MODE, mode) ||\r\nnla_put_u8(skb, IFLA_BRPORT_GUARD, !!(p->flags & BR_BPDU_GUARD)) ||\r\nnla_put_u8(skb, IFLA_BRPORT_PROTECT, !!(p->flags & BR_ROOT_BLOCK)) ||\r\nnla_put_u8(skb, IFLA_BRPORT_FAST_LEAVE, !!(p->flags & BR_MULTICAST_FAST_LEAVE)) ||\r\nnla_put_u8(skb, IFLA_BRPORT_LEARNING, !!(p->flags & BR_LEARNING)) ||\r\nnla_put_u8(skb, IFLA_BRPORT_UNICAST_FLOOD, !!(p->flags & BR_FLOOD)) ||\r\nnla_put_u8(skb, IFLA_BRPORT_PROXYARP, !!(p->flags & BR_PROXYARP)) ||\r\nnla_put_u8(skb, IFLA_BRPORT_PROXYARP_WIFI,\r\n!!(p->flags & BR_PROXYARP_WIFI)) ||\r\nnla_put(skb, IFLA_BRPORT_ROOT_ID, sizeof(struct ifla_bridge_id),\r\n&p->designated_root) ||\r\nnla_put(skb, IFLA_BRPORT_BRIDGE_ID, sizeof(struct ifla_bridge_id),\r\n&p->designated_bridge) ||\r\nnla_put_u16(skb, IFLA_BRPORT_DESIGNATED_PORT, p->designated_port) ||\r\nnla_put_u16(skb, IFLA_BRPORT_DESIGNATED_COST, p->designated_cost) ||\r\nnla_put_u16(skb, IFLA_BRPORT_ID, p->port_id) ||\r\nnla_put_u16(skb, IFLA_BRPORT_NO, p->port_no) ||\r\nnla_put_u8(skb, IFLA_BRPORT_TOPOLOGY_CHANGE_ACK,\r\np->topology_change_ack) ||\r\nnla_put_u8(skb, IFLA_BRPORT_CONFIG_PENDING, p->config_pending))\r\nreturn -EMSGSIZE;\r\ntimerval = br_timer_value(&p->message_age_timer);\r\nif (nla_put_u64(skb, IFLA_BRPORT_MESSAGE_AGE_TIMER, timerval))\r\nreturn -EMSGSIZE;\r\ntimerval = br_timer_value(&p->forward_delay_timer);\r\nif (nla_put_u64(skb, IFLA_BRPORT_FORWARD_DELAY_TIMER, timerval))\r\nreturn -EMSGSIZE;\r\ntimerval = br_timer_value(&p->hold_timer);\r\nif (nla_put_u64(skb, IFLA_BRPORT_HOLD_TIMER, timerval))\r\nreturn -EMSGSIZE;\r\n#ifdef CONFIG_BRIDGE_IGMP_SNOOPING\r\nif (nla_put_u8(skb, IFLA_BRPORT_MULTICAST_ROUTER,\r\np->multicast_router))\r\nreturn -EMSGSIZE;\r\n#endif\r\nreturn 0;\r\n}\r\nstatic int br_fill_ifvlaninfo_range(struct sk_buff *skb, u16 vid_start,\r\nu16 vid_end, u16 flags)\r\n{\r\nstruct bridge_vlan_info vinfo;\r\nif ((vid_end - vid_start) > 0) {\r\nvinfo.vid = vid_start;\r\nvinfo.flags = flags | BRIDGE_VLAN_INFO_RANGE_BEGIN;\r\nif (nla_put(skb, IFLA_BRIDGE_VLAN_INFO,\r\nsizeof(vinfo), &vinfo))\r\ngoto nla_put_failure;\r\nvinfo.vid = vid_end;\r\nvinfo.flags = flags | BRIDGE_VLAN_INFO_RANGE_END;\r\nif (nla_put(skb, IFLA_BRIDGE_VLAN_INFO,\r\nsizeof(vinfo), &vinfo))\r\ngoto nla_put_failure;\r\n} else {\r\nvinfo.vid = vid_start;\r\nvinfo.flags = flags;\r\nif (nla_put(skb, IFLA_BRIDGE_VLAN_INFO,\r\nsizeof(vinfo), &vinfo))\r\ngoto nla_put_failure;\r\n}\r\nreturn 0;\r\nnla_put_failure:\r\nreturn -EMSGSIZE;\r\n}\r\nstatic int br_fill_ifvlaninfo_compressed(struct sk_buff *skb,\r\nstruct net_bridge_vlan_group *vg)\r\n{\r\nstruct net_bridge_vlan *v;\r\nu16 vid_range_start = 0, vid_range_end = 0, vid_range_flags = 0;\r\nu16 flags, pvid;\r\nint err = 0;\r\npvid = br_get_pvid(vg);\r\nlist_for_each_entry_rcu(v, &vg->vlan_list, vlist) {\r\nflags = 0;\r\nif (!br_vlan_should_use(v))\r\ncontinue;\r\nif (v->vid == pvid)\r\nflags |= BRIDGE_VLAN_INFO_PVID;\r\nif (v->flags & BRIDGE_VLAN_INFO_UNTAGGED)\r\nflags |= BRIDGE_VLAN_INFO_UNTAGGED;\r\nif (vid_range_start == 0) {\r\ngoto initvars;\r\n} else if ((v->vid - vid_range_end) == 1 &&\r\nflags == vid_range_flags) {\r\nvid_range_end = v->vid;\r\ncontinue;\r\n} else {\r\nerr = br_fill_ifvlaninfo_range(skb, vid_range_start,\r\nvid_range_end,\r\nvid_range_flags);\r\nif (err)\r\nreturn err;\r\n}\r\ninitvars:\r\nvid_range_start = v->vid;\r\nvid_range_end = v->vid;\r\nvid_range_flags = flags;\r\n}\r\nif (vid_range_start != 0) {\r\nerr = br_fill_ifvlaninfo_range(skb, vid_range_start,\r\nvid_range_end,\r\nvid_range_flags);\r\nif (err)\r\nreturn err;\r\n}\r\nreturn 0;\r\n}\r\nstatic int br_fill_ifvlaninfo(struct sk_buff *skb,\r\nstruct net_bridge_vlan_group *vg)\r\n{\r\nstruct bridge_vlan_info vinfo;\r\nstruct net_bridge_vlan *v;\r\nu16 pvid;\r\npvid = br_get_pvid(vg);\r\nlist_for_each_entry_rcu(v, &vg->vlan_list, vlist) {\r\nif (!br_vlan_should_use(v))\r\ncontinue;\r\nvinfo.vid = v->vid;\r\nvinfo.flags = 0;\r\nif (v->vid == pvid)\r\nvinfo.flags |= BRIDGE_VLAN_INFO_PVID;\r\nif (v->flags & BRIDGE_VLAN_INFO_UNTAGGED)\r\nvinfo.flags |= BRIDGE_VLAN_INFO_UNTAGGED;\r\nif (nla_put(skb, IFLA_BRIDGE_VLAN_INFO,\r\nsizeof(vinfo), &vinfo))\r\ngoto nla_put_failure;\r\n}\r\nreturn 0;\r\nnla_put_failure:\r\nreturn -EMSGSIZE;\r\n}\r\nstatic int br_fill_ifinfo(struct sk_buff *skb,\r\nstruct net_bridge_port *port,\r\nu32 pid, u32 seq, int event, unsigned int flags,\r\nu32 filter_mask, const struct net_device *dev)\r\n{\r\nstruct net_bridge *br;\r\nstruct ifinfomsg *hdr;\r\nstruct nlmsghdr *nlh;\r\nu8 operstate = netif_running(dev) ? dev->operstate : IF_OPER_DOWN;\r\nif (port)\r\nbr = port->br;\r\nelse\r\nbr = netdev_priv(dev);\r\nbr_debug(br, "br_fill_info event %d port %s master %s\n",\r\nevent, dev->name, br->dev->name);\r\nnlh = nlmsg_put(skb, pid, seq, event, sizeof(*hdr), flags);\r\nif (nlh == NULL)\r\nreturn -EMSGSIZE;\r\nhdr = nlmsg_data(nlh);\r\nhdr->ifi_family = AF_BRIDGE;\r\nhdr->__ifi_pad = 0;\r\nhdr->ifi_type = dev->type;\r\nhdr->ifi_index = dev->ifindex;\r\nhdr->ifi_flags = dev_get_flags(dev);\r\nhdr->ifi_change = 0;\r\nif (nla_put_string(skb, IFLA_IFNAME, dev->name) ||\r\nnla_put_u32(skb, IFLA_MASTER, br->dev->ifindex) ||\r\nnla_put_u32(skb, IFLA_MTU, dev->mtu) ||\r\nnla_put_u8(skb, IFLA_OPERSTATE, operstate) ||\r\n(dev->addr_len &&\r\nnla_put(skb, IFLA_ADDRESS, dev->addr_len, dev->dev_addr)) ||\r\n(dev->ifindex != dev_get_iflink(dev) &&\r\nnla_put_u32(skb, IFLA_LINK, dev_get_iflink(dev))))\r\ngoto nla_put_failure;\r\nif (event == RTM_NEWLINK && port) {\r\nstruct nlattr *nest\r\n= nla_nest_start(skb, IFLA_PROTINFO | NLA_F_NESTED);\r\nif (nest == NULL || br_port_fill_attrs(skb, port) < 0)\r\ngoto nla_put_failure;\r\nnla_nest_end(skb, nest);\r\n}\r\nif ((filter_mask & RTEXT_FILTER_BRVLAN) ||\r\n(filter_mask & RTEXT_FILTER_BRVLAN_COMPRESSED)) {\r\nstruct net_bridge_vlan_group *vg;\r\nstruct nlattr *af;\r\nint err;\r\nrcu_read_lock();\r\nif (port)\r\nvg = nbp_vlan_group_rcu(port);\r\nelse\r\nvg = br_vlan_group_rcu(br);\r\nif (!vg || !vg->num_vlans) {\r\nrcu_read_unlock();\r\ngoto done;\r\n}\r\naf = nla_nest_start(skb, IFLA_AF_SPEC);\r\nif (!af) {\r\nrcu_read_unlock();\r\ngoto nla_put_failure;\r\n}\r\nif (filter_mask & RTEXT_FILTER_BRVLAN_COMPRESSED)\r\nerr = br_fill_ifvlaninfo_compressed(skb, vg);\r\nelse\r\nerr = br_fill_ifvlaninfo(skb, vg);\r\nrcu_read_unlock();\r\nif (err)\r\ngoto nla_put_failure;\r\nnla_nest_end(skb, af);\r\n}\r\ndone:\r\nnlmsg_end(skb, nlh);\r\nreturn 0;\r\nnla_put_failure:\r\nnlmsg_cancel(skb, nlh);\r\nreturn -EMSGSIZE;\r\n}\r\nvoid br_ifinfo_notify(int event, struct net_bridge_port *port)\r\n{\r\nstruct net *net;\r\nstruct sk_buff *skb;\r\nint err = -ENOBUFS;\r\nu32 filter = RTEXT_FILTER_BRVLAN_COMPRESSED;\r\nif (!port)\r\nreturn;\r\nnet = dev_net(port->dev);\r\nbr_debug(port->br, "port %u(%s) event %d\n",\r\n(unsigned int)port->port_no, port->dev->name, event);\r\nskb = nlmsg_new(br_nlmsg_size(port->dev, filter), GFP_ATOMIC);\r\nif (skb == NULL)\r\ngoto errout;\r\nerr = br_fill_ifinfo(skb, port, 0, 0, event, 0, filter, port->dev);\r\nif (err < 0) {\r\nWARN_ON(err == -EMSGSIZE);\r\nkfree_skb(skb);\r\ngoto errout;\r\n}\r\nrtnl_notify(skb, net, 0, RTNLGRP_LINK, NULL, GFP_ATOMIC);\r\nreturn;\r\nerrout:\r\nrtnl_set_sk_err(net, RTNLGRP_LINK, err);\r\n}\r\nint br_getlink(struct sk_buff *skb, u32 pid, u32 seq,\r\nstruct net_device *dev, u32 filter_mask, int nlflags)\r\n{\r\nstruct net_bridge_port *port = br_port_get_rtnl(dev);\r\nif (!port && !(filter_mask & RTEXT_FILTER_BRVLAN) &&\r\n!(filter_mask & RTEXT_FILTER_BRVLAN_COMPRESSED))\r\nreturn 0;\r\nreturn br_fill_ifinfo(skb, port, pid, seq, RTM_NEWLINK, nlflags,\r\nfilter_mask, dev);\r\n}\r\nstatic int br_vlan_info(struct net_bridge *br, struct net_bridge_port *p,\r\nint cmd, struct bridge_vlan_info *vinfo)\r\n{\r\nint err = 0;\r\nswitch (cmd) {\r\ncase RTM_SETLINK:\r\nif (p) {\r\nerr = nbp_vlan_add(p, vinfo->vid, vinfo->flags);\r\nif (err)\r\nbreak;\r\n} else {\r\nvinfo->flags |= BRIDGE_VLAN_INFO_BRENTRY;\r\nerr = br_vlan_add(br, vinfo->vid, vinfo->flags);\r\n}\r\nbreak;\r\ncase RTM_DELLINK:\r\nif (p) {\r\nnbp_vlan_delete(p, vinfo->vid);\r\nif (vinfo->flags & BRIDGE_VLAN_INFO_MASTER)\r\nbr_vlan_delete(p->br, vinfo->vid);\r\n} else {\r\nbr_vlan_delete(br, vinfo->vid);\r\n}\r\nbreak;\r\n}\r\nreturn err;\r\n}\r\nstatic int br_afspec(struct net_bridge *br,\r\nstruct net_bridge_port *p,\r\nstruct nlattr *af_spec,\r\nint cmd)\r\n{\r\nstruct bridge_vlan_info *vinfo_start = NULL;\r\nstruct bridge_vlan_info *vinfo = NULL;\r\nstruct nlattr *attr;\r\nint err = 0;\r\nint rem;\r\nnla_for_each_nested(attr, af_spec, rem) {\r\nif (nla_type(attr) != IFLA_BRIDGE_VLAN_INFO)\r\ncontinue;\r\nif (nla_len(attr) != sizeof(struct bridge_vlan_info))\r\nreturn -EINVAL;\r\nvinfo = nla_data(attr);\r\nif (!vinfo->vid || vinfo->vid >= VLAN_VID_MASK)\r\nreturn -EINVAL;\r\nif (vinfo->flags & BRIDGE_VLAN_INFO_RANGE_BEGIN) {\r\nif (vinfo_start)\r\nreturn -EINVAL;\r\nvinfo_start = vinfo;\r\nif (vinfo_start->flags & BRIDGE_VLAN_INFO_PVID)\r\nreturn -EINVAL;\r\ncontinue;\r\n}\r\nif (vinfo_start) {\r\nstruct bridge_vlan_info tmp_vinfo;\r\nint v;\r\nif (!(vinfo->flags & BRIDGE_VLAN_INFO_RANGE_END))\r\nreturn -EINVAL;\r\nif (vinfo->vid <= vinfo_start->vid)\r\nreturn -EINVAL;\r\nmemcpy(&tmp_vinfo, vinfo_start,\r\nsizeof(struct bridge_vlan_info));\r\nfor (v = vinfo_start->vid; v <= vinfo->vid; v++) {\r\ntmp_vinfo.vid = v;\r\nerr = br_vlan_info(br, p, cmd, &tmp_vinfo);\r\nif (err)\r\nbreak;\r\n}\r\nvinfo_start = NULL;\r\n} else {\r\nerr = br_vlan_info(br, p, cmd, vinfo);\r\n}\r\nif (err)\r\nbreak;\r\n}\r\nreturn err;\r\n}\r\nstatic int br_set_port_state(struct net_bridge_port *p, u8 state)\r\n{\r\nif (state > BR_STATE_BLOCKING)\r\nreturn -EINVAL;\r\nif (p->br->stp_enabled == BR_KERNEL_STP)\r\nreturn -EBUSY;\r\nif (!netif_running(p->dev) ||\r\n(!netif_oper_up(p->dev) && state != BR_STATE_DISABLED))\r\nreturn -ENETDOWN;\r\nbr_set_state(p, state);\r\nbr_log_state(p);\r\nbr_port_state_selection(p->br);\r\nreturn 0;\r\n}\r\nstatic void br_set_port_flag(struct net_bridge_port *p, struct nlattr *tb[],\r\nint attrtype, unsigned long mask)\r\n{\r\nif (tb[attrtype]) {\r\nu8 flag = nla_get_u8(tb[attrtype]);\r\nif (flag)\r\np->flags |= mask;\r\nelse\r\np->flags &= ~mask;\r\n}\r\n}\r\nstatic int br_setport(struct net_bridge_port *p, struct nlattr *tb[])\r\n{\r\nint err;\r\nunsigned long old_flags = p->flags;\r\nbr_set_port_flag(p, tb, IFLA_BRPORT_MODE, BR_HAIRPIN_MODE);\r\nbr_set_port_flag(p, tb, IFLA_BRPORT_GUARD, BR_BPDU_GUARD);\r\nbr_set_port_flag(p, tb, IFLA_BRPORT_FAST_LEAVE, BR_MULTICAST_FAST_LEAVE);\r\nbr_set_port_flag(p, tb, IFLA_BRPORT_PROTECT, BR_ROOT_BLOCK);\r\nbr_set_port_flag(p, tb, IFLA_BRPORT_LEARNING, BR_LEARNING);\r\nbr_set_port_flag(p, tb, IFLA_BRPORT_UNICAST_FLOOD, BR_FLOOD);\r\nbr_set_port_flag(p, tb, IFLA_BRPORT_PROXYARP, BR_PROXYARP);\r\nbr_set_port_flag(p, tb, IFLA_BRPORT_PROXYARP_WIFI, BR_PROXYARP_WIFI);\r\nif (tb[IFLA_BRPORT_COST]) {\r\nerr = br_stp_set_path_cost(p, nla_get_u32(tb[IFLA_BRPORT_COST]));\r\nif (err)\r\nreturn err;\r\n}\r\nif (tb[IFLA_BRPORT_PRIORITY]) {\r\nerr = br_stp_set_port_priority(p, nla_get_u16(tb[IFLA_BRPORT_PRIORITY]));\r\nif (err)\r\nreturn err;\r\n}\r\nif (tb[IFLA_BRPORT_STATE]) {\r\nerr = br_set_port_state(p, nla_get_u8(tb[IFLA_BRPORT_STATE]));\r\nif (err)\r\nreturn err;\r\n}\r\nif (tb[IFLA_BRPORT_FLUSH])\r\nbr_fdb_delete_by_port(p->br, p, 0, 0);\r\n#ifdef CONFIG_BRIDGE_IGMP_SNOOPING\r\nif (tb[IFLA_BRPORT_MULTICAST_ROUTER]) {\r\nu8 mcast_router = nla_get_u8(tb[IFLA_BRPORT_MULTICAST_ROUTER]);\r\nerr = br_multicast_set_port_router(p, mcast_router);\r\nif (err)\r\nreturn err;\r\n}\r\n#endif\r\nbr_port_flags_change(p, old_flags ^ p->flags);\r\nreturn 0;\r\n}\r\nint br_setlink(struct net_device *dev, struct nlmsghdr *nlh, u16 flags)\r\n{\r\nstruct nlattr *protinfo;\r\nstruct nlattr *afspec;\r\nstruct net_bridge_port *p;\r\nstruct nlattr *tb[IFLA_BRPORT_MAX + 1];\r\nint err = 0;\r\nprotinfo = nlmsg_find_attr(nlh, sizeof(struct ifinfomsg), IFLA_PROTINFO);\r\nafspec = nlmsg_find_attr(nlh, sizeof(struct ifinfomsg), IFLA_AF_SPEC);\r\nif (!protinfo && !afspec)\r\nreturn 0;\r\np = br_port_get_rtnl(dev);\r\nif (!p && !afspec)\r\nreturn -EINVAL;\r\nif (p && protinfo) {\r\nif (protinfo->nla_type & NLA_F_NESTED) {\r\nerr = nla_parse_nested(tb, IFLA_BRPORT_MAX,\r\nprotinfo, br_port_policy);\r\nif (err)\r\nreturn err;\r\nspin_lock_bh(&p->br->lock);\r\nerr = br_setport(p, tb);\r\nspin_unlock_bh(&p->br->lock);\r\n} else {\r\nif (nla_len(protinfo) < sizeof(u8))\r\nreturn -EINVAL;\r\nspin_lock_bh(&p->br->lock);\r\nerr = br_set_port_state(p, nla_get_u8(protinfo));\r\nspin_unlock_bh(&p->br->lock);\r\n}\r\nif (err)\r\ngoto out;\r\n}\r\nif (afspec) {\r\nerr = br_afspec((struct net_bridge *)netdev_priv(dev), p,\r\nafspec, RTM_SETLINK);\r\n}\r\nif (err == 0)\r\nbr_ifinfo_notify(RTM_NEWLINK, p);\r\nout:\r\nreturn err;\r\n}\r\nint br_dellink(struct net_device *dev, struct nlmsghdr *nlh, u16 flags)\r\n{\r\nstruct nlattr *afspec;\r\nstruct net_bridge_port *p;\r\nint err = 0;\r\nafspec = nlmsg_find_attr(nlh, sizeof(struct ifinfomsg), IFLA_AF_SPEC);\r\nif (!afspec)\r\nreturn 0;\r\np = br_port_get_rtnl(dev);\r\nif (!p && !(dev->priv_flags & IFF_EBRIDGE))\r\nreturn -EINVAL;\r\nerr = br_afspec((struct net_bridge *)netdev_priv(dev), p,\r\nafspec, RTM_DELLINK);\r\nif (err == 0)\r\nbr_ifinfo_notify(RTM_NEWLINK, p);\r\nreturn err;\r\n}\r\nstatic int br_validate(struct nlattr *tb[], struct nlattr *data[])\r\n{\r\nif (tb[IFLA_ADDRESS]) {\r\nif (nla_len(tb[IFLA_ADDRESS]) != ETH_ALEN)\r\nreturn -EINVAL;\r\nif (!is_valid_ether_addr(nla_data(tb[IFLA_ADDRESS])))\r\nreturn -EADDRNOTAVAIL;\r\n}\r\nif (!data)\r\nreturn 0;\r\n#ifdef CONFIG_BRIDGE_VLAN_FILTERING\r\nif (data[IFLA_BR_VLAN_PROTOCOL]) {\r\nswitch (nla_get_be16(data[IFLA_BR_VLAN_PROTOCOL])) {\r\ncase htons(ETH_P_8021Q):\r\ncase htons(ETH_P_8021AD):\r\nbreak;\r\ndefault:\r\nreturn -EPROTONOSUPPORT;\r\n}\r\n}\r\n#endif\r\nreturn 0;\r\n}\r\nstatic int br_dev_newlink(struct net *src_net, struct net_device *dev,\r\nstruct nlattr *tb[], struct nlattr *data[])\r\n{\r\nstruct net_bridge *br = netdev_priv(dev);\r\nif (tb[IFLA_ADDRESS]) {\r\nspin_lock_bh(&br->lock);\r\nbr_stp_change_bridge_id(br, nla_data(tb[IFLA_ADDRESS]));\r\nspin_unlock_bh(&br->lock);\r\n}\r\nreturn register_netdevice(dev);\r\n}\r\nstatic int br_port_slave_changelink(struct net_device *brdev,\r\nstruct net_device *dev,\r\nstruct nlattr *tb[],\r\nstruct nlattr *data[])\r\n{\r\nstruct net_bridge *br = netdev_priv(brdev);\r\nint ret;\r\nif (!data)\r\nreturn 0;\r\nspin_lock_bh(&br->lock);\r\nret = br_setport(br_port_get_rtnl(dev), data);\r\nspin_unlock_bh(&br->lock);\r\nreturn ret;\r\n}\r\nstatic int br_port_fill_slave_info(struct sk_buff *skb,\r\nconst struct net_device *brdev,\r\nconst struct net_device *dev)\r\n{\r\nreturn br_port_fill_attrs(skb, br_port_get_rtnl(dev));\r\n}\r\nstatic size_t br_port_get_slave_size(const struct net_device *brdev,\r\nconst struct net_device *dev)\r\n{\r\nreturn br_port_info_size();\r\n}\r\nstatic int br_changelink(struct net_device *brdev, struct nlattr *tb[],\r\nstruct nlattr *data[])\r\n{\r\nstruct net_bridge *br = netdev_priv(brdev);\r\nint err;\r\nif (!data)\r\nreturn 0;\r\nif (data[IFLA_BR_FORWARD_DELAY]) {\r\nerr = br_set_forward_delay(br, nla_get_u32(data[IFLA_BR_FORWARD_DELAY]));\r\nif (err)\r\nreturn err;\r\n}\r\nif (data[IFLA_BR_HELLO_TIME]) {\r\nerr = br_set_hello_time(br, nla_get_u32(data[IFLA_BR_HELLO_TIME]));\r\nif (err)\r\nreturn err;\r\n}\r\nif (data[IFLA_BR_MAX_AGE]) {\r\nerr = br_set_max_age(br, nla_get_u32(data[IFLA_BR_MAX_AGE]));\r\nif (err)\r\nreturn err;\r\n}\r\nif (data[IFLA_BR_AGEING_TIME]) {\r\nerr = br_set_ageing_time(br, nla_get_u32(data[IFLA_BR_AGEING_TIME]));\r\nif (err)\r\nreturn err;\r\n}\r\nif (data[IFLA_BR_STP_STATE]) {\r\nu32 stp_enabled = nla_get_u32(data[IFLA_BR_STP_STATE]);\r\nbr_stp_set_enabled(br, stp_enabled);\r\n}\r\nif (data[IFLA_BR_PRIORITY]) {\r\nu32 priority = nla_get_u16(data[IFLA_BR_PRIORITY]);\r\nbr_stp_set_bridge_priority(br, priority);\r\n}\r\nif (data[IFLA_BR_VLAN_FILTERING]) {\r\nu8 vlan_filter = nla_get_u8(data[IFLA_BR_VLAN_FILTERING]);\r\nerr = __br_vlan_filter_toggle(br, vlan_filter);\r\nif (err)\r\nreturn err;\r\n}\r\n#ifdef CONFIG_BRIDGE_VLAN_FILTERING\r\nif (data[IFLA_BR_VLAN_PROTOCOL]) {\r\n__be16 vlan_proto = nla_get_be16(data[IFLA_BR_VLAN_PROTOCOL]);\r\nerr = __br_vlan_set_proto(br, vlan_proto);\r\nif (err)\r\nreturn err;\r\n}\r\nif (data[IFLA_BR_VLAN_DEFAULT_PVID]) {\r\n__u16 defpvid = nla_get_u16(data[IFLA_BR_VLAN_DEFAULT_PVID]);\r\nerr = __br_vlan_set_default_pvid(br, defpvid);\r\nif (err)\r\nreturn err;\r\n}\r\n#endif\r\nif (data[IFLA_BR_GROUP_FWD_MASK]) {\r\nu16 fwd_mask = nla_get_u16(data[IFLA_BR_GROUP_FWD_MASK]);\r\nif (fwd_mask & BR_GROUPFWD_RESTRICTED)\r\nreturn -EINVAL;\r\nbr->group_fwd_mask = fwd_mask;\r\n}\r\nif (data[IFLA_BR_GROUP_ADDR]) {\r\nu8 new_addr[ETH_ALEN];\r\nif (nla_len(data[IFLA_BR_GROUP_ADDR]) != ETH_ALEN)\r\nreturn -EINVAL;\r\nmemcpy(new_addr, nla_data(data[IFLA_BR_GROUP_ADDR]), ETH_ALEN);\r\nif (!is_link_local_ether_addr(new_addr))\r\nreturn -EINVAL;\r\nif (new_addr[5] == 1 ||\r\nnew_addr[5] == 2 ||\r\nnew_addr[5] == 3)\r\nreturn -EINVAL;\r\nspin_lock_bh(&br->lock);\r\nmemcpy(br->group_addr, new_addr, sizeof(br->group_addr));\r\nspin_unlock_bh(&br->lock);\r\nbr->group_addr_set = true;\r\nbr_recalculate_fwd_mask(br);\r\n}\r\nif (data[IFLA_BR_FDB_FLUSH])\r\nbr_fdb_flush(br);\r\n#ifdef CONFIG_BRIDGE_IGMP_SNOOPING\r\nif (data[IFLA_BR_MCAST_ROUTER]) {\r\nu8 multicast_router = nla_get_u8(data[IFLA_BR_MCAST_ROUTER]);\r\nerr = br_multicast_set_router(br, multicast_router);\r\nif (err)\r\nreturn err;\r\n}\r\nif (data[IFLA_BR_MCAST_SNOOPING]) {\r\nu8 mcast_snooping = nla_get_u8(data[IFLA_BR_MCAST_SNOOPING]);\r\nerr = br_multicast_toggle(br, mcast_snooping);\r\nif (err)\r\nreturn err;\r\n}\r\nif (data[IFLA_BR_MCAST_QUERY_USE_IFADDR]) {\r\nu8 val;\r\nval = nla_get_u8(data[IFLA_BR_MCAST_QUERY_USE_IFADDR]);\r\nbr->multicast_query_use_ifaddr = !!val;\r\n}\r\nif (data[IFLA_BR_MCAST_QUERIER]) {\r\nu8 mcast_querier = nla_get_u8(data[IFLA_BR_MCAST_QUERIER]);\r\nerr = br_multicast_set_querier(br, mcast_querier);\r\nif (err)\r\nreturn err;\r\n}\r\nif (data[IFLA_BR_MCAST_HASH_ELASTICITY]) {\r\nu32 val = nla_get_u32(data[IFLA_BR_MCAST_HASH_ELASTICITY]);\r\nbr->hash_elasticity = val;\r\n}\r\nif (data[IFLA_BR_MCAST_HASH_MAX]) {\r\nu32 hash_max = nla_get_u32(data[IFLA_BR_MCAST_HASH_MAX]);\r\nerr = br_multicast_set_hash_max(br, hash_max);\r\nif (err)\r\nreturn err;\r\n}\r\nif (data[IFLA_BR_MCAST_LAST_MEMBER_CNT]) {\r\nu32 val = nla_get_u32(data[IFLA_BR_MCAST_LAST_MEMBER_CNT]);\r\nbr->multicast_last_member_count = val;\r\n}\r\nif (data[IFLA_BR_MCAST_STARTUP_QUERY_CNT]) {\r\nu32 val = nla_get_u32(data[IFLA_BR_MCAST_STARTUP_QUERY_CNT]);\r\nbr->multicast_startup_query_count = val;\r\n}\r\nif (data[IFLA_BR_MCAST_LAST_MEMBER_INTVL]) {\r\nu64 val = nla_get_u64(data[IFLA_BR_MCAST_LAST_MEMBER_INTVL]);\r\nbr->multicast_last_member_interval = clock_t_to_jiffies(val);\r\n}\r\nif (data[IFLA_BR_MCAST_MEMBERSHIP_INTVL]) {\r\nu64 val = nla_get_u64(data[IFLA_BR_MCAST_MEMBERSHIP_INTVL]);\r\nbr->multicast_membership_interval = clock_t_to_jiffies(val);\r\n}\r\nif (data[IFLA_BR_MCAST_QUERIER_INTVL]) {\r\nu64 val = nla_get_u64(data[IFLA_BR_MCAST_QUERIER_INTVL]);\r\nbr->multicast_querier_interval = clock_t_to_jiffies(val);\r\n}\r\nif (data[IFLA_BR_MCAST_QUERY_INTVL]) {\r\nu64 val = nla_get_u64(data[IFLA_BR_MCAST_QUERY_INTVL]);\r\nbr->multicast_query_interval = clock_t_to_jiffies(val);\r\n}\r\nif (data[IFLA_BR_MCAST_QUERY_RESPONSE_INTVL]) {\r\nu64 val = nla_get_u64(data[IFLA_BR_MCAST_QUERY_RESPONSE_INTVL]);\r\nbr->multicast_query_response_interval = clock_t_to_jiffies(val);\r\n}\r\nif (data[IFLA_BR_MCAST_STARTUP_QUERY_INTVL]) {\r\nu64 val = nla_get_u64(data[IFLA_BR_MCAST_STARTUP_QUERY_INTVL]);\r\nbr->multicast_startup_query_interval = clock_t_to_jiffies(val);\r\n}\r\n#endif\r\n#if IS_ENABLED(CONFIG_BRIDGE_NETFILTER)\r\nif (data[IFLA_BR_NF_CALL_IPTABLES]) {\r\nu8 val = nla_get_u8(data[IFLA_BR_NF_CALL_IPTABLES]);\r\nbr->nf_call_iptables = val ? true : false;\r\n}\r\nif (data[IFLA_BR_NF_CALL_IP6TABLES]) {\r\nu8 val = nla_get_u8(data[IFLA_BR_NF_CALL_IP6TABLES]);\r\nbr->nf_call_ip6tables = val ? true : false;\r\n}\r\nif (data[IFLA_BR_NF_CALL_ARPTABLES]) {\r\nu8 val = nla_get_u8(data[IFLA_BR_NF_CALL_ARPTABLES]);\r\nbr->nf_call_arptables = val ? true : false;\r\n}\r\n#endif\r\nreturn 0;\r\n}\r\nstatic size_t br_get_size(const struct net_device *brdev)\r\n{\r\nreturn nla_total_size(sizeof(u32)) +\r\nnla_total_size(sizeof(u32)) +\r\nnla_total_size(sizeof(u32)) +\r\nnla_total_size(sizeof(u32)) +\r\nnla_total_size(sizeof(u32)) +\r\nnla_total_size(sizeof(u16)) +\r\nnla_total_size(sizeof(u8)) +\r\n#ifdef CONFIG_BRIDGE_VLAN_FILTERING\r\nnla_total_size(sizeof(__be16)) +\r\nnla_total_size(sizeof(u16)) +\r\n#endif\r\nnla_total_size(sizeof(u16)) +\r\nnla_total_size(sizeof(struct ifla_bridge_id)) +\r\nnla_total_size(sizeof(struct ifla_bridge_id)) +\r\nnla_total_size(sizeof(u16)) +\r\nnla_total_size(sizeof(u32)) +\r\nnla_total_size(sizeof(u8)) +\r\nnla_total_size(sizeof(u8)) +\r\nnla_total_size(sizeof(u64)) +\r\nnla_total_size(sizeof(u64)) +\r\nnla_total_size(sizeof(u64)) +\r\nnla_total_size(sizeof(u64)) +\r\nnla_total_size(ETH_ALEN) +\r\n#ifdef CONFIG_BRIDGE_IGMP_SNOOPING\r\nnla_total_size(sizeof(u8)) +\r\nnla_total_size(sizeof(u8)) +\r\nnla_total_size(sizeof(u8)) +\r\nnla_total_size(sizeof(u8)) +\r\nnla_total_size(sizeof(u32)) +\r\nnla_total_size(sizeof(u32)) +\r\nnla_total_size(sizeof(u32)) +\r\nnla_total_size(sizeof(u32)) +\r\nnla_total_size(sizeof(u64)) +\r\nnla_total_size(sizeof(u64)) +\r\nnla_total_size(sizeof(u64)) +\r\nnla_total_size(sizeof(u64)) +\r\nnla_total_size(sizeof(u64)) +\r\nnla_total_size(sizeof(u64)) +\r\n#endif\r\n#if IS_ENABLED(CONFIG_BRIDGE_NETFILTER)\r\nnla_total_size(sizeof(u8)) +\r\nnla_total_size(sizeof(u8)) +\r\nnla_total_size(sizeof(u8)) +\r\n#endif\r\n0;\r\n}\r\nstatic int br_fill_info(struct sk_buff *skb, const struct net_device *brdev)\r\n{\r\nstruct net_bridge *br = netdev_priv(brdev);\r\nu32 forward_delay = jiffies_to_clock_t(br->forward_delay);\r\nu32 hello_time = jiffies_to_clock_t(br->hello_time);\r\nu32 age_time = jiffies_to_clock_t(br->max_age);\r\nu32 ageing_time = jiffies_to_clock_t(br->ageing_time);\r\nu32 stp_enabled = br->stp_enabled;\r\nu16 priority = (br->bridge_id.prio[0] << 8) | br->bridge_id.prio[1];\r\nu8 vlan_enabled = br_vlan_enabled(br);\r\nu64 clockval;\r\nclockval = br_timer_value(&br->hello_timer);\r\nif (nla_put_u64(skb, IFLA_BR_HELLO_TIMER, clockval))\r\nreturn -EMSGSIZE;\r\nclockval = br_timer_value(&br->tcn_timer);\r\nif (nla_put_u64(skb, IFLA_BR_TCN_TIMER, clockval))\r\nreturn -EMSGSIZE;\r\nclockval = br_timer_value(&br->topology_change_timer);\r\nif (nla_put_u64(skb, IFLA_BR_TOPOLOGY_CHANGE_TIMER, clockval))\r\nreturn -EMSGSIZE;\r\nclockval = br_timer_value(&br->gc_timer);\r\nif (nla_put_u64(skb, IFLA_BR_GC_TIMER, clockval))\r\nreturn -EMSGSIZE;\r\nif (nla_put_u32(skb, IFLA_BR_FORWARD_DELAY, forward_delay) ||\r\nnla_put_u32(skb, IFLA_BR_HELLO_TIME, hello_time) ||\r\nnla_put_u32(skb, IFLA_BR_MAX_AGE, age_time) ||\r\nnla_put_u32(skb, IFLA_BR_AGEING_TIME, ageing_time) ||\r\nnla_put_u32(skb, IFLA_BR_STP_STATE, stp_enabled) ||\r\nnla_put_u16(skb, IFLA_BR_PRIORITY, priority) ||\r\nnla_put_u8(skb, IFLA_BR_VLAN_FILTERING, vlan_enabled) ||\r\nnla_put_u16(skb, IFLA_BR_GROUP_FWD_MASK, br->group_fwd_mask) ||\r\nnla_put(skb, IFLA_BR_BRIDGE_ID, sizeof(struct ifla_bridge_id),\r\n&br->bridge_id) ||\r\nnla_put(skb, IFLA_BR_ROOT_ID, sizeof(struct ifla_bridge_id),\r\n&br->designated_root) ||\r\nnla_put_u16(skb, IFLA_BR_ROOT_PORT, br->root_port) ||\r\nnla_put_u32(skb, IFLA_BR_ROOT_PATH_COST, br->root_path_cost) ||\r\nnla_put_u8(skb, IFLA_BR_TOPOLOGY_CHANGE, br->topology_change) ||\r\nnla_put_u8(skb, IFLA_BR_TOPOLOGY_CHANGE_DETECTED,\r\nbr->topology_change_detected) ||\r\nnla_put(skb, IFLA_BR_GROUP_ADDR, ETH_ALEN, br->group_addr))\r\nreturn -EMSGSIZE;\r\n#ifdef CONFIG_BRIDGE_VLAN_FILTERING\r\nif (nla_put_be16(skb, IFLA_BR_VLAN_PROTOCOL, br->vlan_proto) ||\r\nnla_put_u16(skb, IFLA_BR_VLAN_DEFAULT_PVID, br->default_pvid))\r\nreturn -EMSGSIZE;\r\n#endif\r\n#ifdef CONFIG_BRIDGE_IGMP_SNOOPING\r\nif (nla_put_u8(skb, IFLA_BR_MCAST_ROUTER, br->multicast_router) ||\r\nnla_put_u8(skb, IFLA_BR_MCAST_SNOOPING, !br->multicast_disabled) ||\r\nnla_put_u8(skb, IFLA_BR_MCAST_QUERY_USE_IFADDR,\r\nbr->multicast_query_use_ifaddr) ||\r\nnla_put_u8(skb, IFLA_BR_MCAST_QUERIER, br->multicast_querier) ||\r\nnla_put_u32(skb, IFLA_BR_MCAST_HASH_ELASTICITY,\r\nbr->hash_elasticity) ||\r\nnla_put_u32(skb, IFLA_BR_MCAST_HASH_MAX, br->hash_max) ||\r\nnla_put_u32(skb, IFLA_BR_MCAST_LAST_MEMBER_CNT,\r\nbr->multicast_last_member_count) ||\r\nnla_put_u32(skb, IFLA_BR_MCAST_STARTUP_QUERY_CNT,\r\nbr->multicast_startup_query_count))\r\nreturn -EMSGSIZE;\r\nclockval = jiffies_to_clock_t(br->multicast_last_member_interval);\r\nif (nla_put_u64(skb, IFLA_BR_MCAST_LAST_MEMBER_INTVL, clockval))\r\nreturn -EMSGSIZE;\r\nclockval = jiffies_to_clock_t(br->multicast_membership_interval);\r\nif (nla_put_u64(skb, IFLA_BR_MCAST_MEMBERSHIP_INTVL, clockval))\r\nreturn -EMSGSIZE;\r\nclockval = jiffies_to_clock_t(br->multicast_querier_interval);\r\nif (nla_put_u64(skb, IFLA_BR_MCAST_QUERIER_INTVL, clockval))\r\nreturn -EMSGSIZE;\r\nclockval = jiffies_to_clock_t(br->multicast_query_interval);\r\nif (nla_put_u64(skb, IFLA_BR_MCAST_QUERY_INTVL, clockval))\r\nreturn -EMSGSIZE;\r\nclockval = jiffies_to_clock_t(br->multicast_query_response_interval);\r\nif (nla_put_u64(skb, IFLA_BR_MCAST_QUERY_RESPONSE_INTVL, clockval))\r\nreturn -EMSGSIZE;\r\nclockval = jiffies_to_clock_t(br->multicast_startup_query_interval);\r\nif (nla_put_u64(skb, IFLA_BR_MCAST_STARTUP_QUERY_INTVL, clockval))\r\nreturn -EMSGSIZE;\r\n#endif\r\n#if IS_ENABLED(CONFIG_BRIDGE_NETFILTER)\r\nif (nla_put_u8(skb, IFLA_BR_NF_CALL_IPTABLES,\r\nbr->nf_call_iptables ? 1 : 0) ||\r\nnla_put_u8(skb, IFLA_BR_NF_CALL_IP6TABLES,\r\nbr->nf_call_ip6tables ? 1 : 0) ||\r\nnla_put_u8(skb, IFLA_BR_NF_CALL_ARPTABLES,\r\nbr->nf_call_arptables ? 1 : 0))\r\nreturn -EMSGSIZE;\r\n#endif\r\nreturn 0;\r\n}\r\nint __init br_netlink_init(void)\r\n{\r\nint err;\r\nbr_mdb_init();\r\nrtnl_af_register(&br_af_ops);\r\nerr = rtnl_link_register(&br_link_ops);\r\nif (err)\r\ngoto out_af;\r\nreturn 0;\r\nout_af:\r\nrtnl_af_unregister(&br_af_ops);\r\nbr_mdb_uninit();\r\nreturn err;\r\n}\r\nvoid br_netlink_fini(void)\r\n{\r\nbr_mdb_uninit();\r\nrtnl_af_unregister(&br_af_ops);\r\nrtnl_link_unregister(&br_link_ops);\r\n}
