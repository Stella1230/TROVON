static unsigned int __get_fid(struct iproc_arm_pll *pll)\r\n{\r\nu32 val;\r\nunsigned int policy, fid, active_fid;\r\nval = readl(pll->base + IPROC_CLK_ARM_DIV_OFFSET);\r\nif (val & (1 << IPROC_CLK_ARM_DIV_PLL_SELECT_OVERRIDE_SHIFT))\r\npolicy = val & IPROC_CLK_ARM_DIV_ARM_PLL_SELECT_MASK;\r\nelse\r\npolicy = 0;\r\nBUG_ON(policy > IPROC_CLK_MAX_FREQ_POLICY);\r\nval = readl(pll->base + IPROC_CLK_POLICY_FREQ_OFFSET);\r\nfid = (val >> (IPROC_CLK_POLICY_FREQ_POLICY_FREQ_SHIFT * policy)) &\r\nIPROC_CLK_POLICY_FREQ_POLICY_FREQ_MASK;\r\nval = readl(pll->base + IPROC_CLK_POLICY_DBG_OFFSET);\r\nactive_fid = IPROC_CLK_POLICY_DBG_ACT_FREQ_MASK &\r\n(val >> IPROC_CLK_POLICY_DBG_ACT_FREQ_SHIFT);\r\nif (fid != active_fid) {\r\npr_debug("%s: fid override %u->%u\n", __func__, fid,\r\nactive_fid);\r\nfid = active_fid;\r\n}\r\npr_debug("%s: active fid: %u\n", __func__, fid);\r\nreturn fid;\r\n}\r\nstatic int __get_mdiv(struct iproc_arm_pll *pll)\r\n{\r\nunsigned int fid;\r\nint mdiv;\r\nu32 val;\r\nfid = __get_fid(pll);\r\nswitch (fid) {\r\ncase ARM_PLL_FID_CRYSTAL_CLK:\r\ncase ARM_PLL_FID_SYS_CLK:\r\nmdiv = 1;\r\nbreak;\r\ncase ARM_PLL_FID_CH0_SLOW_CLK:\r\nval = readl(pll->base + IPROC_CLK_PLLARMC_OFFSET);\r\nmdiv = val & IPROC_CLK_PLLARMC_MDIV_MASK;\r\nif (mdiv == 0)\r\nmdiv = 256;\r\nbreak;\r\ncase ARM_PLL_FID_CH1_FAST_CLK:\r\nval = readl(pll->base + IPROC_CLK_PLLARMCTL5_OFFSET);\r\nmdiv = val & IPROC_CLK_PLLARMCTL5_H_MDIV_MASK;\r\nif (mdiv == 0)\r\nmdiv = 256;\r\nbreak;\r\ndefault:\r\nmdiv = -EFAULT;\r\n}\r\nreturn mdiv;\r\n}\r\nstatic unsigned int __get_ndiv(struct iproc_arm_pll *pll)\r\n{\r\nu32 val;\r\nunsigned int ndiv_int, ndiv_frac, ndiv;\r\nval = readl(pll->base + IPROC_CLK_PLLARM_OFFSET_OFFSET);\r\nif (val & (1 << IPROC_CLK_PLLARM_SW_CTL_SHIFT)) {\r\nndiv_int = (val >> IPROC_CLK_PLLARM_NDIV_INT_OFFSET_SHIFT) &\r\nIPROC_CLK_PLLARM_NDIV_INT_OFFSET_MASK;\r\nif (ndiv_int == 0)\r\nndiv_int = 256;\r\nndiv_frac = val & IPROC_CLK_PLLARM_NDIV_FRAC_OFFSET_MASK;\r\n} else {\r\nval = readl(pll->base + IPROC_CLK_PLLARMA_OFFSET);\r\nndiv_int = (val >> IPROC_CLK_PLLARMA_NDIV_INT_SHIFT) &\r\nIPROC_CLK_PLLARMA_NDIV_INT_MASK;\r\nif (ndiv_int == 0)\r\nndiv_int = 1024;\r\nval = readl(pll->base + IPROC_CLK_PLLARMB_OFFSET);\r\nndiv_frac = val & IPROC_CLK_PLLARMB_NDIV_FRAC_MASK;\r\n}\r\nndiv = (ndiv_int << 20) | ndiv_frac;\r\nreturn ndiv;\r\n}\r\nstatic unsigned long iproc_arm_pll_recalc_rate(struct clk_hw *hw,\r\nunsigned long parent_rate)\r\n{\r\nstruct iproc_arm_pll *pll = to_iproc_arm_pll(hw);\r\nu32 val;\r\nint mdiv;\r\nu64 ndiv;\r\nunsigned int pdiv;\r\nval = readl(pll->base + IPROC_CLK_PLLARMC_OFFSET);\r\nif (val & (1 << IPROC_CLK_PLLARMC_BYPCLK_EN_SHIFT)) {\r\npll->rate = parent_rate;\r\nreturn pll->rate;\r\n}\r\nval = readl(pll->base + IPROC_CLK_PLLARMA_OFFSET);\r\nif (!(val & (1 << IPROC_CLK_PLLARMA_LOCK_SHIFT))) {\r\npll->rate = 0;\r\nreturn 0;\r\n}\r\npdiv = (val >> IPROC_CLK_PLLARMA_PDIV_SHIFT) &\r\nIPROC_CLK_PLLARMA_PDIV_MASK;\r\nif (pdiv == 0)\r\npdiv = 16;\r\nndiv = __get_ndiv(pll);\r\nmdiv = __get_mdiv(pll);\r\nif (mdiv <= 0) {\r\npll->rate = 0;\r\nreturn 0;\r\n}\r\npll->rate = (ndiv * parent_rate) >> 20;\r\npll->rate = (pll->rate / pdiv) / mdiv;\r\npr_debug("%s: ARM PLL rate: %lu. parent rate: %lu\n", __func__,\r\npll->rate, parent_rate);\r\npr_debug("%s: ndiv_int: %u, pdiv: %u, mdiv: %d\n", __func__,\r\n(unsigned int)(ndiv >> 20), pdiv, mdiv);\r\nreturn pll->rate;\r\n}\r\nvoid __init iproc_armpll_setup(struct device_node *node)\r\n{\r\nint ret;\r\nstruct clk *clk;\r\nstruct iproc_arm_pll *pll;\r\nstruct clk_init_data init;\r\nconst char *parent_name;\r\npll = kzalloc(sizeof(*pll), GFP_KERNEL);\r\nif (WARN_ON(!pll))\r\nreturn;\r\npll->base = of_iomap(node, 0);\r\nif (WARN_ON(!pll->base))\r\ngoto err_free_pll;\r\ninit.name = node->name;\r\ninit.ops = &iproc_arm_pll_ops;\r\ninit.flags = 0;\r\nparent_name = of_clk_get_parent_name(node, 0);\r\ninit.parent_names = (parent_name ? &parent_name : NULL);\r\ninit.num_parents = (parent_name ? 1 : 0);\r\npll->hw.init = &init;\r\nclk = clk_register(NULL, &pll->hw);\r\nif (WARN_ON(IS_ERR(clk)))\r\ngoto err_iounmap;\r\nret = of_clk_add_provider(node, of_clk_src_simple_get, clk);\r\nif (WARN_ON(ret))\r\ngoto err_clk_unregister;\r\nreturn;\r\nerr_clk_unregister:\r\nclk_unregister(clk);\r\nerr_iounmap:\r\niounmap(pll->base);\r\nerr_free_pll:\r\nkfree(pll);\r\n}
