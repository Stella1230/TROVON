static inline void ieee80211_monitor_rx(struct ieee80211_device *ieee,\r\nstruct sk_buff *skb,\r\nstruct ieee80211_rx_stats *rx_stats)\r\n{\r\nstruct rtl_80211_hdr_4addr *hdr = (struct rtl_80211_hdr_4addr *)skb->data;\r\nu16 fc = le16_to_cpu(hdr->frame_ctl);\r\nskb->dev = ieee->dev;\r\nskb_reset_mac_header(skb);\r\nskb_pull(skb, ieee80211_get_hdrlen(fc));\r\nskb->pkt_type = PACKET_OTHERHOST;\r\nskb->protocol = htons(ETH_P_80211_RAW);\r\nmemset(skb->cb, 0, sizeof(skb->cb));\r\nnetif_rx(skb);\r\n}\r\nstatic struct ieee80211_frag_entry *\r\nieee80211_frag_cache_find(struct ieee80211_device *ieee, unsigned int seq,\r\nunsigned int frag, u8 tid, u8 *src, u8 *dst)\r\n{\r\nstruct ieee80211_frag_entry *entry;\r\nint i;\r\nfor (i = 0; i < IEEE80211_FRAG_CACHE_LEN; i++) {\r\nentry = &ieee->frag_cache[tid][i];\r\nif (entry->skb != NULL &&\r\ntime_after(jiffies, entry->first_frag_time + 2 * HZ)) {\r\nIEEE80211_DEBUG_FRAG(\r\n"expiring fragment cache entry "\r\n"seq=%u last_frag=%u\n",\r\nentry->seq, entry->last_frag);\r\ndev_kfree_skb_any(entry->skb);\r\nentry->skb = NULL;\r\n}\r\nif (entry->skb != NULL && entry->seq == seq &&\r\n(entry->last_frag + 1 == frag || frag == -1) &&\r\nmemcmp(entry->src_addr, src, ETH_ALEN) == 0 &&\r\nmemcmp(entry->dst_addr, dst, ETH_ALEN) == 0)\r\nreturn entry;\r\n}\r\nreturn NULL;\r\n}\r\nstatic struct sk_buff *\r\nieee80211_frag_cache_get(struct ieee80211_device *ieee,\r\nstruct rtl_80211_hdr_4addr *hdr)\r\n{\r\nstruct sk_buff *skb = NULL;\r\nu16 fc = le16_to_cpu(hdr->frame_ctl);\r\nu16 sc = le16_to_cpu(hdr->seq_ctl);\r\nunsigned int frag = WLAN_GET_SEQ_FRAG(sc);\r\nunsigned int seq = WLAN_GET_SEQ_SEQ(sc);\r\nstruct ieee80211_frag_entry *entry;\r\nstruct rtl_80211_hdr_3addrqos *hdr_3addrqos;\r\nstruct rtl_80211_hdr_4addrqos *hdr_4addrqos;\r\nu8 tid;\r\nif (((fc & IEEE80211_FCTL_DSTODS) == IEEE80211_FCTL_DSTODS)&&IEEE80211_QOS_HAS_SEQ(fc)) {\r\nhdr_4addrqos = (struct rtl_80211_hdr_4addrqos *)hdr;\r\ntid = le16_to_cpu(hdr_4addrqos->qos_ctl) & IEEE80211_QCTL_TID;\r\ntid = UP2AC(tid);\r\ntid ++;\r\n} else if (IEEE80211_QOS_HAS_SEQ(fc)) {\r\nhdr_3addrqos = (struct rtl_80211_hdr_3addrqos *)hdr;\r\ntid = le16_to_cpu(hdr_3addrqos->qos_ctl) & IEEE80211_QCTL_TID;\r\ntid = UP2AC(tid);\r\ntid ++;\r\n} else {\r\ntid = 0;\r\n}\r\nif (frag == 0) {\r\nskb = dev_alloc_skb(ieee->dev->mtu +\r\nsizeof(struct rtl_80211_hdr_4addr) +\r\n8 +\r\n2 +\r\n8 +\r\nETH_ALEN +\r\n(IEEE80211_QOS_HAS_SEQ(fc)?2:0) );\r\nif (skb == NULL)\r\nreturn NULL;\r\nentry = &ieee->frag_cache[tid][ieee->frag_next_idx[tid]];\r\nieee->frag_next_idx[tid]++;\r\nif (ieee->frag_next_idx[tid] >= IEEE80211_FRAG_CACHE_LEN)\r\nieee->frag_next_idx[tid] = 0;\r\nif (entry->skb != NULL)\r\ndev_kfree_skb_any(entry->skb);\r\nentry->first_frag_time = jiffies;\r\nentry->seq = seq;\r\nentry->last_frag = frag;\r\nentry->skb = skb;\r\nmemcpy(entry->src_addr, hdr->addr2, ETH_ALEN);\r\nmemcpy(entry->dst_addr, hdr->addr1, ETH_ALEN);\r\n} else {\r\nentry = ieee80211_frag_cache_find(ieee, seq, frag, tid,hdr->addr2,\r\nhdr->addr1);\r\nif (entry != NULL) {\r\nentry->last_frag = frag;\r\nskb = entry->skb;\r\n}\r\n}\r\nreturn skb;\r\n}\r\nstatic int ieee80211_frag_cache_invalidate(struct ieee80211_device *ieee,\r\nstruct rtl_80211_hdr_4addr *hdr)\r\n{\r\nu16 fc = le16_to_cpu(hdr->frame_ctl);\r\nu16 sc = le16_to_cpu(hdr->seq_ctl);\r\nunsigned int seq = WLAN_GET_SEQ_SEQ(sc);\r\nstruct ieee80211_frag_entry *entry;\r\nstruct rtl_80211_hdr_3addrqos *hdr_3addrqos;\r\nstruct rtl_80211_hdr_4addrqos *hdr_4addrqos;\r\nu8 tid;\r\nif(((fc & IEEE80211_FCTL_DSTODS) == IEEE80211_FCTL_DSTODS)&&IEEE80211_QOS_HAS_SEQ(fc)) {\r\nhdr_4addrqos = (struct rtl_80211_hdr_4addrqos *)hdr;\r\ntid = le16_to_cpu(hdr_4addrqos->qos_ctl) & IEEE80211_QCTL_TID;\r\ntid = UP2AC(tid);\r\ntid ++;\r\n} else if (IEEE80211_QOS_HAS_SEQ(fc)) {\r\nhdr_3addrqos = (struct rtl_80211_hdr_3addrqos *)hdr;\r\ntid = le16_to_cpu(hdr_3addrqos->qos_ctl) & IEEE80211_QCTL_TID;\r\ntid = UP2AC(tid);\r\ntid ++;\r\n} else {\r\ntid = 0;\r\n}\r\nentry = ieee80211_frag_cache_find(ieee, seq, -1, tid, hdr->addr2,\r\nhdr->addr1);\r\nif (entry == NULL) {\r\nIEEE80211_DEBUG_FRAG(\r\n"could not invalidate fragment cache "\r\n"entry (seq=%u)\n", seq);\r\nreturn -1;\r\n}\r\nentry->skb = NULL;\r\nreturn 0;\r\n}\r\nstatic inline int\r\nieee80211_rx_frame_mgmt(struct ieee80211_device *ieee, struct sk_buff *skb,\r\nstruct ieee80211_rx_stats *rx_stats, u16 type,\r\nu16 stype)\r\n{\r\nstruct rtl_80211_hdr_3addr *hdr = (struct rtl_80211_hdr_3addr *)skb->data;\r\nrx_stats->len = skb->len;\r\nieee80211_rx_mgt(ieee,(struct rtl_80211_hdr_4addr *)skb->data,rx_stats);\r\nif ((memcmp(hdr->addr1, ieee->dev->dev_addr, ETH_ALEN)))\r\n{\r\ndev_kfree_skb_any(skb);\r\nreturn 0;\r\n}\r\nieee80211_rx_frame_softmac(ieee, skb, rx_stats, type, stype);\r\ndev_kfree_skb_any(skb);\r\nreturn 0;\r\n#ifdef NOT_YET\r\nif (ieee->iw_mode == IW_MODE_MASTER) {\r\nprintk(KERN_DEBUG "%s: Master mode not yet supported.\n",\r\nieee->dev->name);\r\nreturn 0;\r\n}\r\nif (ieee->hostapd && type == IEEE80211_TYPE_MGMT) {\r\nif (stype == WLAN_FC_STYPE_BEACON &&\r\nieee->iw_mode == IW_MODE_MASTER) {\r\nstruct sk_buff *skb2;\r\nskb2 = skb_clone(skb, GFP_ATOMIC);\r\nif (skb2)\r\nhostap_rx(skb2->dev, skb2, rx_stats);\r\n}\r\nieee->apdevstats.rx_packets++;\r\nieee->apdevstats.rx_bytes += skb->len;\r\nprism2_rx_80211(ieee->apdev, skb, rx_stats, PRISM2_RX_MGMT);\r\nreturn 0;\r\n}\r\nif (ieee->iw_mode == IW_MODE_MASTER) {\r\nif (type != WLAN_FC_TYPE_MGMT && type != WLAN_FC_TYPE_CTRL) {\r\nprintk(KERN_DEBUG "%s: unknown management frame "\r\n"(type=0x%02x, stype=0x%02x) dropped\n",\r\nskb->dev->name, type, stype);\r\nreturn -1;\r\n}\r\nhostap_rx(skb->dev, skb, rx_stats);\r\nreturn 0;\r\n}\r\nprintk(KERN_DEBUG "%s: hostap_rx_frame_mgmt: management frame "\r\n"received in non-Host AP mode\n", skb->dev->name);\r\nreturn -1;\r\n#endif\r\n}\r\nstatic int ieee80211_is_eapol_frame(struct ieee80211_device *ieee,\r\nstruct sk_buff *skb, size_t hdrlen)\r\n{\r\nstruct net_device *dev = ieee->dev;\r\nu16 fc, ethertype;\r\nstruct rtl_80211_hdr_4addr *hdr;\r\nu8 *pos;\r\nif (skb->len < 24)\r\nreturn 0;\r\nhdr = (struct rtl_80211_hdr_4addr *) skb->data;\r\nfc = le16_to_cpu(hdr->frame_ctl);\r\nif ((fc & (IEEE80211_FCTL_TODS | IEEE80211_FCTL_FROMDS)) ==\r\nIEEE80211_FCTL_TODS &&\r\nmemcmp(hdr->addr1, dev->dev_addr, ETH_ALEN) == 0 &&\r\nmemcmp(hdr->addr3, dev->dev_addr, ETH_ALEN) == 0) {\r\n} else if ((fc & (IEEE80211_FCTL_TODS | IEEE80211_FCTL_FROMDS)) ==\r\nIEEE80211_FCTL_FROMDS &&\r\nmemcmp(hdr->addr1, dev->dev_addr, ETH_ALEN) == 0) {\r\n} else\r\nreturn 0;\r\nif (skb->len < 24 + 8)\r\nreturn 0;\r\npos = skb->data + hdrlen;\r\nethertype = (pos[6] << 8) | pos[7];\r\nif (ethertype == ETH_P_PAE)\r\nreturn 1;\r\nreturn 0;\r\n}\r\nstatic inline int\r\nieee80211_rx_frame_decrypt(struct ieee80211_device *ieee, struct sk_buff *skb,\r\nstruct ieee80211_crypt_data *crypt)\r\n{\r\nstruct rtl_80211_hdr_4addr *hdr;\r\nint res, hdrlen;\r\nif (crypt == NULL || crypt->ops->decrypt_mpdu == NULL)\r\nreturn 0;\r\nif (ieee->hwsec_active)\r\n{\r\ncb_desc *tcb_desc = (cb_desc *)(skb->cb+ MAX_DEV_ADDR_SIZE);\r\ntcb_desc->bHwSec = 1;\r\n}\r\nhdr = (struct rtl_80211_hdr_4addr *) skb->data;\r\nhdrlen = ieee80211_get_hdrlen(le16_to_cpu(hdr->frame_ctl));\r\nif (ieee->tkip_countermeasures &&\r\nstrcmp(crypt->ops->name, "TKIP") == 0) {\r\nif (net_ratelimit()) {\r\nprintk(KERN_DEBUG "%s: TKIP countermeasures: dropped "\r\n"received packet from %pM\n",\r\nieee->dev->name, hdr->addr2);\r\n}\r\nreturn -1;\r\n}\r\natomic_inc(&crypt->refcnt);\r\nres = crypt->ops->decrypt_mpdu(skb, hdrlen, crypt->priv);\r\natomic_dec(&crypt->refcnt);\r\nif (res < 0) {\r\nIEEE80211_DEBUG_DROP(\r\n"decryption failed (SA=%pM"\r\n") res=%d\n", hdr->addr2, res);\r\nif (res == -2)\r\nIEEE80211_DEBUG_DROP("Decryption failed ICV "\r\n"mismatch (key %d)\n",\r\nskb->data[hdrlen + 3] >> 6);\r\nieee->ieee_stats.rx_discards_undecryptable++;\r\nreturn -1;\r\n}\r\nreturn res;\r\n}\r\nstatic inline int\r\nieee80211_rx_frame_decrypt_msdu(struct ieee80211_device *ieee, struct sk_buff *skb,\r\nint keyidx, struct ieee80211_crypt_data *crypt)\r\n{\r\nstruct rtl_80211_hdr_4addr *hdr;\r\nint res, hdrlen;\r\nif (crypt == NULL || crypt->ops->decrypt_msdu == NULL)\r\nreturn 0;\r\nif (ieee->hwsec_active)\r\n{\r\ncb_desc *tcb_desc = (cb_desc *)(skb->cb+ MAX_DEV_ADDR_SIZE);\r\ntcb_desc->bHwSec = 1;\r\n}\r\nhdr = (struct rtl_80211_hdr_4addr *) skb->data;\r\nhdrlen = ieee80211_get_hdrlen(le16_to_cpu(hdr->frame_ctl));\r\natomic_inc(&crypt->refcnt);\r\nres = crypt->ops->decrypt_msdu(skb, keyidx, hdrlen, crypt->priv);\r\natomic_dec(&crypt->refcnt);\r\nif (res < 0) {\r\nprintk(KERN_DEBUG "%s: MSDU decryption/MIC verification failed"\r\n" (SA=%pM keyidx=%d)\n",\r\nieee->dev->name, hdr->addr2, keyidx);\r\nreturn -1;\r\n}\r\nreturn 0;\r\n}\r\nstatic int is_duplicate_packet(struct ieee80211_device *ieee,\r\nstruct rtl_80211_hdr_4addr *header)\r\n{\r\nu16 fc = le16_to_cpu(header->frame_ctl);\r\nu16 sc = le16_to_cpu(header->seq_ctl);\r\nu16 seq = WLAN_GET_SEQ_SEQ(sc);\r\nu16 frag = WLAN_GET_SEQ_FRAG(sc);\r\nu16 *last_seq, *last_frag;\r\nunsigned long *last_time;\r\nstruct rtl_80211_hdr_3addrqos *hdr_3addrqos;\r\nstruct rtl_80211_hdr_4addrqos *hdr_4addrqos;\r\nu8 tid;\r\nif(((fc & IEEE80211_FCTL_DSTODS) == IEEE80211_FCTL_DSTODS)&&IEEE80211_QOS_HAS_SEQ(fc)) {\r\nhdr_4addrqos = (struct rtl_80211_hdr_4addrqos *)header;\r\ntid = le16_to_cpu(hdr_4addrqos->qos_ctl) & IEEE80211_QCTL_TID;\r\ntid = UP2AC(tid);\r\ntid ++;\r\n} else if(IEEE80211_QOS_HAS_SEQ(fc)) {\r\nhdr_3addrqos = (struct rtl_80211_hdr_3addrqos *)header;\r\ntid = le16_to_cpu(hdr_3addrqos->qos_ctl) & IEEE80211_QCTL_TID;\r\ntid = UP2AC(tid);\r\ntid ++;\r\n} else {\r\ntid = 0;\r\n}\r\nswitch (ieee->iw_mode) {\r\ncase IW_MODE_ADHOC:\r\n{\r\nstruct list_head *p;\r\nstruct ieee_ibss_seq *entry = NULL;\r\nu8 *mac = header->addr2;\r\nint index = mac[5] % IEEE_IBSS_MAC_HASH_SIZE;\r\nlist_for_each(p, &ieee->ibss_mac_hash[index]) {\r\nentry = list_entry(p, struct ieee_ibss_seq, list);\r\nif (!memcmp(entry->mac, mac, ETH_ALEN))\r\nbreak;\r\n}\r\nif (p == &ieee->ibss_mac_hash[index]) {\r\nentry = kmalloc(sizeof(struct ieee_ibss_seq), GFP_ATOMIC);\r\nif (!entry) {\r\nprintk(KERN_WARNING "Cannot malloc new mac entry\n");\r\nreturn 0;\r\n}\r\nmemcpy(entry->mac, mac, ETH_ALEN);\r\nentry->seq_num[tid] = seq;\r\nentry->frag_num[tid] = frag;\r\nentry->packet_time[tid] = jiffies;\r\nlist_add(&entry->list, &ieee->ibss_mac_hash[index]);\r\nreturn 0;\r\n}\r\nlast_seq = &entry->seq_num[tid];\r\nlast_frag = &entry->frag_num[tid];\r\nlast_time = &entry->packet_time[tid];\r\nbreak;\r\n}\r\ncase IW_MODE_INFRA:\r\nlast_seq = &ieee->last_rxseq_num[tid];\r\nlast_frag = &ieee->last_rxfrag_num[tid];\r\nlast_time = &ieee->last_packet_time[tid];\r\nbreak;\r\ndefault:\r\nreturn 0;\r\n}\r\nif ((*last_seq == seq) &&\r\ntime_after(*last_time + IEEE_PACKET_RETRY_TIME, jiffies)) {\r\nif (*last_frag == frag)\r\ngoto drop;\r\nif (*last_frag + 1 != frag)\r\ngoto drop;\r\n} else\r\n*last_seq = seq;\r\n*last_frag = frag;\r\n*last_time = jiffies;\r\nreturn 0;\r\ndrop:\r\nreturn 1;\r\n}\r\nstatic bool AddReorderEntry(PRX_TS_RECORD pTS, PRX_REORDER_ENTRY pReorderEntry)\r\n{\r\nstruct list_head *pList = &pTS->RxPendingPktList;\r\nwhile(pList->next != &pTS->RxPendingPktList)\r\n{\r\nif( SN_LESS(pReorderEntry->SeqNum, ((PRX_REORDER_ENTRY)list_entry(pList->next,RX_REORDER_ENTRY,List))->SeqNum) )\r\n{\r\npList = pList->next;\r\n}\r\nelse if( SN_EQUAL(pReorderEntry->SeqNum, ((PRX_REORDER_ENTRY)list_entry(pList->next,RX_REORDER_ENTRY,List))->SeqNum) )\r\n{\r\nreturn false;\r\n}\r\nelse\r\n{\r\nbreak;\r\n}\r\n}\r\npReorderEntry->List.next = pList->next;\r\npReorderEntry->List.next->prev = &pReorderEntry->List;\r\npReorderEntry->List.prev = pList;\r\npList->next = &pReorderEntry->List;\r\nreturn true;\r\n}\r\nvoid ieee80211_indicate_packets(struct ieee80211_device *ieee, struct ieee80211_rxb **prxbIndicateArray,u8 index)\r\n{\r\nu8 i = 0 , j=0;\r\nu16 ethertype;\r\nfor(j = 0; j<index; j++)\r\n{\r\nstruct ieee80211_rxb *prxb = prxbIndicateArray[j];\r\nfor(i = 0; i<prxb->nr_subframes; i++) {\r\nstruct sk_buff *sub_skb = prxb->subframes[i];\r\nethertype = (sub_skb->data[6] << 8) | sub_skb->data[7];\r\nif (sub_skb->len >= 8 &&\r\n((memcmp(sub_skb->data, rfc1042_header, SNAP_SIZE) == 0 &&\r\nethertype != ETH_P_AARP && ethertype != ETH_P_IPX) ||\r\nmemcmp(sub_skb->data, bridge_tunnel_header, SNAP_SIZE) == 0)) {\r\nskb_pull(sub_skb, SNAP_SIZE);\r\nmemcpy(skb_push(sub_skb, ETH_ALEN), prxb->src, ETH_ALEN);\r\nmemcpy(skb_push(sub_skb, ETH_ALEN), prxb->dst, ETH_ALEN);\r\n} else {\r\nu16 len;\r\nlen = htons(sub_skb->len);\r\nmemcpy(skb_push(sub_skb, 2), &len, 2);\r\nmemcpy(skb_push(sub_skb, ETH_ALEN), prxb->src, ETH_ALEN);\r\nmemcpy(skb_push(sub_skb, ETH_ALEN), prxb->dst, ETH_ALEN);\r\n}\r\nif (sub_skb) {\r\nsub_skb->protocol = eth_type_trans(sub_skb, ieee->dev);\r\nmemset(sub_skb->cb, 0, sizeof(sub_skb->cb));\r\nsub_skb->dev = ieee->dev;\r\nsub_skb->ip_summed = CHECKSUM_NONE;\r\nieee->last_rx_ps_time = jiffies;\r\nnetif_rx(sub_skb);\r\n}\r\n}\r\nkfree(prxb);\r\nprxb = NULL;\r\n}\r\n}\r\nstatic void RxReorderIndicatePacket(struct ieee80211_device *ieee,\r\nstruct ieee80211_rxb *prxb,\r\nPRX_TS_RECORD pTS, u16 SeqNum)\r\n{\r\nPRT_HIGH_THROUGHPUT pHTInfo = ieee->pHTInfo;\r\nPRX_REORDER_ENTRY pReorderEntry = NULL;\r\nstruct ieee80211_rxb *prxbIndicateArray[REORDER_WIN_SIZE];\r\nu8 WinSize = pHTInfo->RxReorderWinSize;\r\nu16 WinEnd = (pTS->RxIndicateSeq + WinSize -1)%4096;\r\nu8 index = 0;\r\nbool bMatchWinStart = false, bPktInBuf = false;\r\nIEEE80211_DEBUG(IEEE80211_DL_REORDER,"%s(): Seq is %d,pTS->RxIndicateSeq is %d, WinSize is %d\n",__func__,SeqNum,pTS->RxIndicateSeq,WinSize);\r\nif (pTS->RxIndicateSeq == 0xffff) {\r\npTS->RxIndicateSeq = SeqNum;\r\n}\r\nif (SN_LESS(SeqNum, pTS->RxIndicateSeq)) {\r\nIEEE80211_DEBUG(IEEE80211_DL_REORDER,"Packet Drop! IndicateSeq: %d, NewSeq: %d\n",\r\npTS->RxIndicateSeq, SeqNum);\r\npHTInfo->RxReorderDropCounter++;\r\n{\r\nint i;\r\nfor(i =0; i < prxb->nr_subframes; i++) {\r\ndev_kfree_skb(prxb->subframes[i]);\r\n}\r\nkfree(prxb);\r\nprxb = NULL;\r\n}\r\nreturn;\r\n}\r\nif(SN_EQUAL(SeqNum, pTS->RxIndicateSeq)) {\r\npTS->RxIndicateSeq = (pTS->RxIndicateSeq + 1) % 4096;\r\nbMatchWinStart = true;\r\n} else if(SN_LESS(WinEnd, SeqNum)) {\r\nif(SeqNum >= (WinSize - 1)) {\r\npTS->RxIndicateSeq = SeqNum + 1 -WinSize;\r\n} else {\r\npTS->RxIndicateSeq = 4095 - (WinSize - (SeqNum +1)) + 1;\r\n}\r\nIEEE80211_DEBUG(IEEE80211_DL_REORDER, "Window Shift! IndicateSeq: %d, NewSeq: %d\n",pTS->RxIndicateSeq, SeqNum);\r\n}\r\nif(bMatchWinStart) {\r\nIEEE80211_DEBUG(IEEE80211_DL_REORDER, "Packets indication!! IndicateSeq: %d, NewSeq: %d\n",\\r\npTS->RxIndicateSeq, SeqNum);\r\nprxbIndicateArray[0] = prxb;\r\nindex = 1;\r\n} else {\r\nif(!list_empty(&ieee->RxReorder_Unused_List)) {\r\npReorderEntry = (PRX_REORDER_ENTRY)list_entry(ieee->RxReorder_Unused_List.next,RX_REORDER_ENTRY,List);\r\nlist_del_init(&pReorderEntry->List);\r\npReorderEntry->SeqNum = SeqNum;\r\npReorderEntry->prxb = prxb;\r\nif(!AddReorderEntry(pTS, pReorderEntry)) {\r\nIEEE80211_DEBUG(IEEE80211_DL_REORDER, "%s(): Duplicate packet is dropped!! IndicateSeq: %d, NewSeq: %d\n",\r\n__func__, pTS->RxIndicateSeq, SeqNum);\r\nlist_add_tail(&pReorderEntry->List,&ieee->RxReorder_Unused_List);\r\n{\r\nint i;\r\nfor(i =0; i < prxb->nr_subframes; i++) {\r\ndev_kfree_skb(prxb->subframes[i]);\r\n}\r\nkfree(prxb);\r\nprxb = NULL;\r\n}\r\n} else {\r\nIEEE80211_DEBUG(IEEE80211_DL_REORDER,\r\n"Pkt insert into buffer!! IndicateSeq: %d, NewSeq: %d\n",pTS->RxIndicateSeq, SeqNum);\r\n}\r\n}\r\nelse {\r\nIEEE80211_DEBUG(IEEE80211_DL_ERR, "RxReorderIndicatePacket(): There is no reorder entry!! Packet is dropped!!\n");\r\n{\r\nint i;\r\nfor(i =0; i < prxb->nr_subframes; i++) {\r\ndev_kfree_skb(prxb->subframes[i]);\r\n}\r\nkfree(prxb);\r\nprxb = NULL;\r\n}\r\n}\r\n}\r\nwhile(!list_empty(&pTS->RxPendingPktList)) {\r\nIEEE80211_DEBUG(IEEE80211_DL_REORDER,"%s(): start RREORDER indicate\n",__func__);\r\npReorderEntry = (PRX_REORDER_ENTRY)list_entry(pTS->RxPendingPktList.prev,RX_REORDER_ENTRY,List);\r\nif (SN_LESS(pReorderEntry->SeqNum, pTS->RxIndicateSeq) ||\r\nSN_EQUAL(pReorderEntry->SeqNum, pTS->RxIndicateSeq))\r\n{\r\nif (index >= REORDER_WIN_SIZE) {\r\nIEEE80211_DEBUG(IEEE80211_DL_ERR, "RxReorderIndicatePacket(): Buffer overflow!! \n");\r\nbPktInBuf = true;\r\nbreak;\r\n}\r\nlist_del_init(&pReorderEntry->List);\r\nif(SN_EQUAL(pReorderEntry->SeqNum, pTS->RxIndicateSeq))\r\npTS->RxIndicateSeq = (pTS->RxIndicateSeq + 1) % 4096;\r\nIEEE80211_DEBUG(IEEE80211_DL_REORDER,"Packets indication!! IndicateSeq: %d, NewSeq: %d\n",pTS->RxIndicateSeq, SeqNum);\r\nprxbIndicateArray[index] = pReorderEntry->prxb;\r\nindex++;\r\nlist_add_tail(&pReorderEntry->List,&ieee->RxReorder_Unused_List);\r\n} else {\r\nbPktInBuf = true;\r\nbreak;\r\n}\r\n}\r\nif (index>0) {\r\npTS->RxTimeoutIndicateSeq = 0xffff;\r\nif(index>REORDER_WIN_SIZE){\r\nIEEE80211_DEBUG(IEEE80211_DL_ERR, "RxReorderIndicatePacket(): Rx Reorer buffer full!! \n");\r\nreturn;\r\n}\r\nieee80211_indicate_packets(ieee, prxbIndicateArray, index);\r\n}\r\nif (bPktInBuf && pTS->RxTimeoutIndicateSeq==0xffff) {\r\nIEEE80211_DEBUG(IEEE80211_DL_REORDER,"%s(): SET rx timeout timer\n", __func__);\r\npTS->RxTimeoutIndicateSeq = pTS->RxIndicateSeq;\r\nif(timer_pending(&pTS->RxPktPendingTimer))\r\ndel_timer_sync(&pTS->RxPktPendingTimer);\r\npTS->RxPktPendingTimer.expires = jiffies + MSECS(pHTInfo->RxReorderPendingTime);\r\nadd_timer(&pTS->RxPktPendingTimer);\r\n}\r\n}\r\nstatic u8 parse_subframe(struct sk_buff *skb,\r\nstruct ieee80211_rx_stats *rx_stats,\r\nstruct ieee80211_rxb *rxb, u8 *src, u8 *dst)\r\n{\r\nstruct rtl_80211_hdr_3addr *hdr = (struct rtl_80211_hdr_3addr *)skb->data;\r\nu16 fc = le16_to_cpu(hdr->frame_ctl);\r\nu16 LLCOffset= sizeof(struct rtl_80211_hdr_3addr);\r\nu16 ChkLength;\r\nbool bIsAggregateFrame = false;\r\nu16 nSubframe_Length;\r\nu8 nPadding_Length = 0;\r\nu16 SeqNum=0;\r\nstruct sk_buff *sub_skb;\r\nu8 *data_ptr;\r\nSeqNum = WLAN_GET_SEQ_SEQ(le16_to_cpu(hdr->seq_ctl));\r\nif ((IEEE80211_QOS_HAS_SEQ(fc))&&\\r\n(((frameqos *)(skb->data + IEEE80211_3ADDR_LEN))->field.reserved)) {\r\nbIsAggregateFrame = true;\r\n}\r\nif (IEEE80211_QOS_HAS_SEQ(fc)) {\r\nLLCOffset += 2;\r\n}\r\nif (rx_stats->bContainHTC) {\r\nLLCOffset += sHTCLng;\r\n}\r\nChkLength = LLCOffset;\r\nif (skb->len <= ChkLength)\r\nreturn 0;\r\nskb_pull(skb, LLCOffset);\r\nif(!bIsAggregateFrame) {\r\nrxb->nr_subframes = 1;\r\n#ifdef JOHN_NOCPY\r\nrxb->subframes[0] = skb;\r\n#else\r\nrxb->subframes[0] = skb_copy(skb, GFP_ATOMIC);\r\n#endif\r\nmemcpy(rxb->src,src,ETH_ALEN);\r\nmemcpy(rxb->dst,dst,ETH_ALEN);\r\nreturn 1;\r\n} else {\r\nrxb->nr_subframes = 0;\r\nmemcpy(rxb->src,src,ETH_ALEN);\r\nmemcpy(rxb->dst,dst,ETH_ALEN);\r\nwhile(skb->len > ETHERNET_HEADER_SIZE) {\r\nnSubframe_Length = *((u16 *)(skb->data + 12));\r\nnSubframe_Length = (nSubframe_Length>>8) + (nSubframe_Length<<8);\r\nif (skb->len<(ETHERNET_HEADER_SIZE + nSubframe_Length)) {\r\nprintk("%s: A-MSDU parse error!! pRfd->nTotalSubframe : %d\n",\\r\n__func__, rxb->nr_subframes);\r\nprintk("%s: A-MSDU parse error!! Subframe Length: %d\n",__func__, nSubframe_Length);\r\nprintk("nRemain_Length is %d and nSubframe_Length is : %d\n",skb->len,nSubframe_Length);\r\nprintk("The Packet SeqNum is %d\n",SeqNum);\r\nreturn 0;\r\n}\r\nskb_pull(skb, ETHERNET_HEADER_SIZE);\r\n#ifdef JOHN_NOCPY\r\nsub_skb = skb_clone(skb, GFP_ATOMIC);\r\nsub_skb->len = nSubframe_Length;\r\nsub_skb->tail = sub_skb->data + nSubframe_Length;\r\n#else\r\nsub_skb = dev_alloc_skb(nSubframe_Length + 12);\r\nif (!sub_skb)\r\nreturn 0;\r\nskb_reserve(sub_skb, 12);\r\ndata_ptr = (u8 *)skb_put(sub_skb, nSubframe_Length);\r\nmemcpy(data_ptr, skb->data, nSubframe_Length);\r\n#endif\r\nrxb->subframes[rxb->nr_subframes++] = sub_skb;\r\nif (rxb->nr_subframes >= MAX_SUBFRAME_COUNT) {\r\nIEEE80211_DEBUG_RX("ParseSubframe(): Too many Subframes! Packets dropped!\n");\r\nbreak;\r\n}\r\nskb_pull(skb, nSubframe_Length);\r\nif (skb->len != 0) {\r\nnPadding_Length = 4 - ((nSubframe_Length + ETHERNET_HEADER_SIZE) % 4);\r\nif (nPadding_Length == 4) {\r\nnPadding_Length = 0;\r\n}\r\nif (skb->len < nPadding_Length) {\r\nreturn 0;\r\n}\r\nskb_pull(skb, nPadding_Length);\r\n}\r\n}\r\n#ifdef JOHN_NOCPY\r\ndev_kfree_skb(skb);\r\n#endif\r\nreturn rxb->nr_subframes;\r\n}\r\n}\r\nint ieee80211_rx(struct ieee80211_device *ieee, struct sk_buff *skb,\r\nstruct ieee80211_rx_stats *rx_stats)\r\n{\r\nstruct net_device *dev = ieee->dev;\r\nstruct rtl_80211_hdr_4addr *hdr;\r\nsize_t hdrlen;\r\nu16 fc, type, stype, sc;\r\nstruct net_device_stats *stats;\r\nunsigned int frag;\r\nu8 *payload;\r\nu16 ethertype;\r\nu8 TID = 0;\r\nu16 SeqNum = 0;\r\nPRX_TS_RECORD pTS = NULL;\r\n#ifdef NOT_YET\r\nstruct net_device *wds = NULL;\r\nstruct sk_buff *skb2 = NULL;\r\nstruct net_device *wds = NULL;\r\nint from_assoc_ap = 0;\r\nvoid *sta = NULL;\r\n#endif\r\nu8 dst[ETH_ALEN];\r\nu8 src[ETH_ALEN];\r\nu8 bssid[ETH_ALEN];\r\nstruct ieee80211_crypt_data *crypt = NULL;\r\nint keyidx = 0;\r\nint i;\r\nstruct ieee80211_rxb *rxb = NULL;\r\nhdr = (struct rtl_80211_hdr_4addr *)skb->data;\r\nstats = &ieee->stats;\r\nif (skb->len < 10) {\r\nprintk(KERN_INFO "%s: SKB length < 10\n",\r\ndev->name);\r\ngoto rx_dropped;\r\n}\r\nfc = le16_to_cpu(hdr->frame_ctl);\r\ntype = WLAN_FC_GET_TYPE(fc);\r\nstype = WLAN_FC_GET_STYPE(fc);\r\nsc = le16_to_cpu(hdr->seq_ctl);\r\nfrag = WLAN_GET_SEQ_FRAG(sc);\r\nhdrlen = ieee80211_get_hdrlen(fc);\r\nif (HTCCheck(ieee, skb->data))\r\n{\r\nif(net_ratelimit())\r\nprintk("find HTCControl\n");\r\nhdrlen += 4;\r\nrx_stats->bContainHTC = true;\r\n}\r\n#ifdef NOT_YET\r\n#ifdef IW_WIRELESS_SPY\r\nif (iface->spy_data.spy_number > 0) {\r\nstruct iw_quality wstats;\r\nwstats.level = rx_stats->rssi;\r\nwstats.noise = rx_stats->noise;\r\nwstats.updated = 6;\r\nwireless_spy_update(dev, hdr->addr2, &wstats);\r\n}\r\n#endif\r\nhostap_update_rx_stats(local->ap, hdr, rx_stats);\r\n#endif\r\nif (ieee->iw_mode == IW_MODE_MONITOR) {\r\nieee80211_monitor_rx(ieee, skb, rx_stats);\r\nstats->rx_packets++;\r\nstats->rx_bytes += skb->len;\r\nreturn 1;\r\n}\r\nif (ieee->host_decrypt) {\r\nint idx = 0;\r\nif (skb->len >= hdrlen + 3)\r\nidx = skb->data[hdrlen + 3] >> 6;\r\ncrypt = ieee->crypt[idx];\r\n#ifdef NOT_YET\r\nsta = NULL;\r\nif (!(hdr->addr1[0] & 0x01) || local->bcrx_sta_key)\r\n(void) hostap_handle_sta_crypto(local, hdr, &crypt,\r\n&sta);\r\n#endif\r\nif (crypt && (crypt->ops == NULL ||\r\ncrypt->ops->decrypt_mpdu == NULL))\r\ncrypt = NULL;\r\nif (!crypt && (fc & IEEE80211_FCTL_WEP)) {\r\nIEEE80211_DEBUG_DROP("Decryption failed (not set)"\r\n" (SA=%pM)\n",\r\nhdr->addr2);\r\nieee->ieee_stats.rx_discards_undecryptable++;\r\ngoto rx_dropped;\r\n}\r\n}\r\nif (skb->len < IEEE80211_DATA_HDR3_LEN)\r\ngoto rx_dropped;\r\nif ((!ieee->pHTInfo->bCurRxReorderEnable) || !ieee->current_network.qos_data.active|| !IsDataFrame(skb->data) || IsLegacyDataFrame(skb->data)) {\r\nif (is_duplicate_packet(ieee, hdr))\r\ngoto rx_dropped;\r\n}\r\nelse\r\n{\r\nPRX_TS_RECORD pRxTS = NULL;\r\nif(GetTs(\r\nieee,\r\n(PTS_COMMON_INFO *) &pRxTS,\r\nhdr->addr2,\r\n(u8)Frame_QoSTID((u8 *)(skb->data)),\r\nRX_DIR,\r\ntrue))\r\n{\r\nif ((fc & (1<<11)) &&\r\n(frag == pRxTS->RxLastFragNum) &&\r\n(WLAN_GET_SEQ_SEQ(sc) == pRxTS->RxLastSeqNum)) {\r\ngoto rx_dropped;\r\n}\r\nelse\r\n{\r\npRxTS->RxLastFragNum = frag;\r\npRxTS->RxLastSeqNum = WLAN_GET_SEQ_SEQ(sc);\r\n}\r\n}\r\nelse\r\n{\r\nIEEE80211_DEBUG(IEEE80211_DL_ERR, "%s(): No TS!! Skip the check!!\n",__func__);\r\ngoto rx_dropped;\r\n}\r\n}\r\nif (type == IEEE80211_FTYPE_MGMT) {\r\nif (ieee80211_rx_frame_mgmt(ieee, skb, rx_stats, type, stype))\r\ngoto rx_dropped;\r\nelse\r\ngoto rx_exit;\r\n}\r\nswitch (fc & (IEEE80211_FCTL_FROMDS | IEEE80211_FCTL_TODS)) {\r\ncase IEEE80211_FCTL_FROMDS:\r\nmemcpy(dst, hdr->addr1, ETH_ALEN);\r\nmemcpy(src, hdr->addr3, ETH_ALEN);\r\nmemcpy(bssid, hdr->addr2, ETH_ALEN);\r\nbreak;\r\ncase IEEE80211_FCTL_TODS:\r\nmemcpy(dst, hdr->addr3, ETH_ALEN);\r\nmemcpy(src, hdr->addr2, ETH_ALEN);\r\nmemcpy(bssid, hdr->addr1, ETH_ALEN);\r\nbreak;\r\ncase IEEE80211_FCTL_FROMDS | IEEE80211_FCTL_TODS:\r\nif (skb->len < IEEE80211_DATA_HDR4_LEN)\r\ngoto rx_dropped;\r\nmemcpy(dst, hdr->addr3, ETH_ALEN);\r\nmemcpy(src, hdr->addr4, ETH_ALEN);\r\nmemcpy(bssid, ieee->current_network.bssid, ETH_ALEN);\r\nbreak;\r\ncase 0:\r\nmemcpy(dst, hdr->addr1, ETH_ALEN);\r\nmemcpy(src, hdr->addr2, ETH_ALEN);\r\nmemcpy(bssid, hdr->addr3, ETH_ALEN);\r\nbreak;\r\n}\r\n#ifdef NOT_YET\r\nif (hostap_rx_frame_wds(ieee, hdr, fc, &wds))\r\ngoto rx_dropped;\r\nif (wds) {\r\nskb->dev = dev = wds;\r\nstats = hostap_get_stats(dev);\r\n}\r\nif (ieee->iw_mode == IW_MODE_MASTER && !wds &&\r\n(fc & (IEEE80211_FCTL_TODS | IEEE80211_FCTL_FROMDS)) == IEEE80211_FCTL_FROMDS &&\r\nieee->stadev &&\r\nmemcmp(hdr->addr2, ieee->assoc_ap_addr, ETH_ALEN) == 0) {\r\nskb->dev = dev = ieee->stadev;\r\nstats = hostap_get_stats(dev);\r\nfrom_assoc_ap = 1;\r\n}\r\n#endif\r\ndev->last_rx = jiffies;\r\n#ifdef NOT_YET\r\nif ((ieee->iw_mode == IW_MODE_MASTER ||\r\nieee->iw_mode == IW_MODE_REPEAT) &&\r\n!from_assoc_ap) {\r\nswitch (hostap_handle_sta_rx(ieee, dev, skb, rx_stats,\r\nwds != NULL)) {\r\ncase AP_RX_CONTINUE_NOT_AUTHORIZED:\r\ncase AP_RX_CONTINUE:\r\nbreak;\r\ncase AP_RX_DROP:\r\ngoto rx_dropped;\r\ncase AP_RX_EXIT:\r\ngoto rx_exit;\r\n}\r\n}\r\n#endif\r\nif (stype != IEEE80211_STYPE_DATA &&\r\nstype != IEEE80211_STYPE_DATA_CFACK &&\r\nstype != IEEE80211_STYPE_DATA_CFPOLL &&\r\nstype != IEEE80211_STYPE_DATA_CFACKPOLL&&\r\nstype != IEEE80211_STYPE_QOS_DATA\r\n) {\r\nif (stype != IEEE80211_STYPE_NULLFUNC)\r\nIEEE80211_DEBUG_DROP(\r\n"RX: dropped data frame "\r\n"with no data (type=0x%02x, "\r\n"subtype=0x%02x, len=%d)\n",\r\ntype, stype, skb->len);\r\ngoto rx_dropped;\r\n}\r\nif (memcmp(bssid, ieee->current_network.bssid, ETH_ALEN))\r\ngoto rx_dropped;\r\nif (ieee->host_decrypt && (fc & IEEE80211_FCTL_WEP) &&\r\n(keyidx = ieee80211_rx_frame_decrypt(ieee, skb, crypt)) < 0)\r\n{\r\nprintk("decrypt frame error\n");\r\ngoto rx_dropped;\r\n}\r\nhdr = (struct rtl_80211_hdr_4addr *) skb->data;\r\nif ((frag != 0 || (fc & IEEE80211_FCTL_MOREFRAGS))) {\r\nint flen;\r\nstruct sk_buff *frag_skb = ieee80211_frag_cache_get(ieee, hdr);\r\nIEEE80211_DEBUG_FRAG("Rx Fragment received (%u)\n", frag);\r\nif (!frag_skb) {\r\nIEEE80211_DEBUG(IEEE80211_DL_RX | IEEE80211_DL_FRAG,\r\n"Rx cannot get skb from fragment "\r\n"cache (morefrag=%d seq=%u frag=%u)\n",\r\n(fc & IEEE80211_FCTL_MOREFRAGS) != 0,\r\nWLAN_GET_SEQ_SEQ(sc), frag);\r\ngoto rx_dropped;\r\n}\r\nflen = skb->len;\r\nif (frag != 0)\r\nflen -= hdrlen;\r\nif (frag_skb->tail + flen > frag_skb->end) {\r\nprintk(KERN_WARNING "%s: host decrypted and "\r\n"reassembled frame did not fit skb\n",\r\ndev->name);\r\nieee80211_frag_cache_invalidate(ieee, hdr);\r\ngoto rx_dropped;\r\n}\r\nif (frag == 0) {\r\nmemcpy(skb_put(frag_skb, flen), skb->data, flen);\r\n} else {\r\nmemcpy(skb_put(frag_skb, flen), skb->data + hdrlen,\r\nflen);\r\n}\r\ndev_kfree_skb_any(skb);\r\nskb = NULL;\r\nif (fc & IEEE80211_FCTL_MOREFRAGS) {\r\ngoto rx_exit;\r\n}\r\nskb = frag_skb;\r\nhdr = (struct rtl_80211_hdr_4addr *) skb->data;\r\nieee80211_frag_cache_invalidate(ieee, hdr);\r\n}\r\nif (ieee->host_decrypt && (fc & IEEE80211_FCTL_WEP) &&\r\nieee80211_rx_frame_decrypt_msdu(ieee, skb, keyidx, crypt))\r\n{\r\nprintk("==>decrypt msdu error\n");\r\ngoto rx_dropped;\r\n}\r\nieee->LinkDetectInfo.NumRecvDataInPeriod++;\r\nieee->LinkDetectInfo.NumRxOkInPeriod++;\r\nhdr = (struct rtl_80211_hdr_4addr *) skb->data;\r\nif (crypt && !(fc & IEEE80211_FCTL_WEP) && !ieee->open_wep) {\r\nif (\r\nieee80211_is_eapol_frame(ieee, skb, hdrlen)) {\r\n#ifdef CONFIG_IEEE80211_DEBUG\r\nstruct eapol *eap = (struct eapol *)(skb->data +\r\n24);\r\nIEEE80211_DEBUG_EAP("RX: IEEE 802.1X EAPOL frame: %s\n",\r\neap_get_type(eap->type));\r\n#endif\r\n} else {\r\nIEEE80211_DEBUG_DROP(\r\n"encryption configured, but RX "\r\n"frame not encrypted (SA=%pM)\n",\r\nhdr->addr2);\r\ngoto rx_dropped;\r\n}\r\n}\r\n#ifdef CONFIG_IEEE80211_DEBUG\r\nif (crypt && !(fc & IEEE80211_FCTL_WEP) &&\r\nieee80211_is_eapol_frame(ieee, skb, hdrlen)) {\r\nstruct eapol *eap = (struct eapol *)(skb->data +\r\n24);\r\nIEEE80211_DEBUG_EAP("RX: IEEE 802.1X EAPOL frame: %s\n",\r\neap_get_type(eap->type));\r\n}\r\n#endif\r\nif (crypt && !(fc & IEEE80211_FCTL_WEP) && !ieee->open_wep &&\r\n!ieee80211_is_eapol_frame(ieee, skb, hdrlen)) {\r\nIEEE80211_DEBUG_DROP(\r\n"dropped unencrypted RX data "\r\n"frame from %pM"\r\n" (drop_unencrypted=1)\n",\r\nhdr->addr2);\r\ngoto rx_dropped;\r\n}\r\nif (ieee->current_network.qos_data.active && IsQoSDataFrame(skb->data)\r\n&& !is_multicast_ether_addr(hdr->addr1))\r\n{\r\nTID = Frame_QoSTID(skb->data);\r\nSeqNum = WLAN_GET_SEQ_SEQ(sc);\r\nGetTs(ieee,(PTS_COMMON_INFO *) &pTS,hdr->addr2,TID,RX_DIR,true);\r\nif (TID !=0 && TID !=3)\r\n{\r\nieee->bis_any_nonbepkts = true;\r\n}\r\n}\r\npayload = skb->data + hdrlen;\r\nrxb = kmalloc(sizeof(struct ieee80211_rxb), GFP_ATOMIC);\r\nif (rxb == NULL)\r\n{\r\nIEEE80211_DEBUG(IEEE80211_DL_ERR,"%s(): kmalloc rxb error\n",__func__);\r\ngoto rx_dropped;\r\n}\r\nif (parse_subframe(skb, rx_stats, rxb, src, dst) == 0) {\r\nfor(i =0; i < rxb->nr_subframes; i++) {\r\ndev_kfree_skb(rxb->subframes[i]);\r\n}\r\nkfree(rxb);\r\nrxb = NULL;\r\ngoto rx_dropped;\r\n}\r\nif (!ieee->pHTInfo->bCurRxReorderEnable || pTS == NULL){\r\nfor(i = 0; i<rxb->nr_subframes; i++) {\r\nstruct sk_buff *sub_skb = rxb->subframes[i];\r\nif (sub_skb) {\r\nethertype = (sub_skb->data[6] << 8) | sub_skb->data[7];\r\nif (sub_skb->len >= 8 &&\r\n((memcmp(sub_skb->data, rfc1042_header, SNAP_SIZE) == 0 &&\r\nethertype != ETH_P_AARP && ethertype != ETH_P_IPX) ||\r\nmemcmp(sub_skb->data, bridge_tunnel_header, SNAP_SIZE) == 0)) {\r\nskb_pull(sub_skb, SNAP_SIZE);\r\nmemcpy(skb_push(sub_skb, ETH_ALEN), src, ETH_ALEN);\r\nmemcpy(skb_push(sub_skb, ETH_ALEN), dst, ETH_ALEN);\r\n} else {\r\nu16 len;\r\nlen = htons(sub_skb->len);\r\nmemcpy(skb_push(sub_skb, 2), &len, 2);\r\nmemcpy(skb_push(sub_skb, ETH_ALEN), src, ETH_ALEN);\r\nmemcpy(skb_push(sub_skb, ETH_ALEN), dst, ETH_ALEN);\r\n}\r\nstats->rx_packets++;\r\nstats->rx_bytes += sub_skb->len;\r\nif (is_multicast_ether_addr(dst)) {\r\nstats->multicast++;\r\n}\r\nsub_skb->protocol = eth_type_trans(sub_skb, dev);\r\nmemset(sub_skb->cb, 0, sizeof(sub_skb->cb));\r\nsub_skb->dev = dev;\r\nsub_skb->ip_summed = CHECKSUM_NONE;\r\nieee->last_rx_ps_time = jiffies;\r\nnetif_rx(sub_skb);\r\n}\r\n}\r\nkfree(rxb);\r\nrxb = NULL;\r\n}\r\nelse\r\n{\r\nIEEE80211_DEBUG(IEEE80211_DL_REORDER,"%s(): REORDER ENABLE AND PTS not NULL, and we will enter RxReorderIndicatePacket()\n",__func__);\r\nRxReorderIndicatePacket(ieee, rxb, pTS, SeqNum);\r\n}\r\n#ifndef JOHN_NOCPY\r\ndev_kfree_skb(skb);\r\n#endif\r\nrx_exit:\r\n#ifdef NOT_YET\r\nif (sta)\r\nhostap_handle_sta_release(sta);\r\n#endif\r\nreturn 1;\r\nrx_dropped:\r\nkfree(rxb);\r\nrxb = NULL;\r\nstats->rx_dropped++;\r\nreturn 0;\r\n}\r\nstatic int ieee80211_verify_qos_info(struct ieee80211_qos_information_element\r\n*info_element, int sub_type)\r\n{\r\nif (info_element->qui_subtype != sub_type)\r\nreturn -1;\r\nif (memcmp(info_element->qui, qos_oui, QOS_OUI_LEN))\r\nreturn -1;\r\nif (info_element->qui_type != QOS_OUI_TYPE)\r\nreturn -1;\r\nif (info_element->version != QOS_VERSION_1)\r\nreturn -1;\r\nreturn 0;\r\n}\r\nstatic int ieee80211_read_qos_param_element(struct ieee80211_qos_parameter_info\r\n*element_param, struct ieee80211_info_element\r\n*info_element)\r\n{\r\nint ret = 0;\r\nu16 size = sizeof(struct ieee80211_qos_parameter_info) - 2;\r\nif ((info_element == NULL) || (element_param == NULL))\r\nreturn -1;\r\nif (info_element->id == QOS_ELEMENT_ID && info_element->len == size) {\r\nmemcpy(element_param->info_element.qui, info_element->data,\r\ninfo_element->len);\r\nelement_param->info_element.elementID = info_element->id;\r\nelement_param->info_element.length = info_element->len;\r\n} else\r\nret = -1;\r\nif (ret == 0)\r\nret = ieee80211_verify_qos_info(&element_param->info_element,\r\nQOS_OUI_PARAM_SUB_TYPE);\r\nreturn ret;\r\n}\r\nstatic int ieee80211_read_qos_info_element(struct\r\nieee80211_qos_information_element\r\n*element_info, struct ieee80211_info_element\r\n*info_element)\r\n{\r\nint ret = 0;\r\nu16 size = sizeof(struct ieee80211_qos_information_element) - 2;\r\nif (element_info == NULL)\r\nreturn -1;\r\nif (info_element == NULL)\r\nreturn -1;\r\nif ((info_element->id == QOS_ELEMENT_ID) && (info_element->len == size)) {\r\nmemcpy(element_info->qui, info_element->data,\r\ninfo_element->len);\r\nelement_info->elementID = info_element->id;\r\nelement_info->length = info_element->len;\r\n} else\r\nret = -1;\r\nif (ret == 0)\r\nret = ieee80211_verify_qos_info(element_info,\r\nQOS_OUI_INFO_SUB_TYPE);\r\nreturn ret;\r\n}\r\nstatic int ieee80211_qos_convert_ac_to_parameters(struct\r\nieee80211_qos_parameter_info\r\n*param_elm, struct\r\nieee80211_qos_parameters\r\n*qos_param)\r\n{\r\nint i;\r\nstruct ieee80211_qos_ac_parameter *ac_params;\r\nu8 aci;\r\nfor (i = 0; i < QOS_QUEUE_NUM; i++) {\r\nac_params = &(param_elm->ac_params_record[i]);\r\naci = (ac_params->aci_aifsn & 0x60) >> 5;\r\nif(aci >= QOS_QUEUE_NUM)\r\ncontinue;\r\nqos_param->aifs[aci] = (ac_params->aci_aifsn) & 0x0f;\r\nqos_param->aifs[aci] = (qos_param->aifs[aci] < 2) ? 2:qos_param->aifs[aci];\r\nqos_param->cw_min[aci] = ac_params->ecw_min_max & 0x0F;\r\nqos_param->cw_max[aci] = (ac_params->ecw_min_max & 0xF0) >> 4;\r\nqos_param->flag[aci] =\r\n(ac_params->aci_aifsn & 0x10) ? 0x01 : 0x00;\r\nqos_param->tx_op_limit[aci] = le16_to_cpu(ac_params->tx_op_limit);\r\n}\r\nreturn 0;\r\n}\r\nstatic int ieee80211_parse_qos_info_param_IE(struct ieee80211_info_element\r\n*info_element,\r\nstruct ieee80211_network *network)\r\n{\r\nint rc = 0;\r\nstruct ieee80211_qos_parameters *qos_param = NULL;\r\nstruct ieee80211_qos_information_element qos_info_element;\r\nrc = ieee80211_read_qos_info_element(&qos_info_element, info_element);\r\nif (rc == 0) {\r\nnetwork->qos_data.param_count = qos_info_element.ac_info & 0x0F;\r\nnetwork->flags |= NETWORK_HAS_QOS_INFORMATION;\r\n} else {\r\nstruct ieee80211_qos_parameter_info param_element;\r\nrc = ieee80211_read_qos_param_element(&param_element,\r\ninfo_element);\r\nif (rc == 0) {\r\nqos_param = &(network->qos_data.parameters);\r\nieee80211_qos_convert_ac_to_parameters(&param_element,\r\nqos_param);\r\nnetwork->flags |= NETWORK_HAS_QOS_PARAMETERS;\r\nnetwork->qos_data.param_count =\r\nparam_element.info_element.ac_info & 0x0F;\r\n}\r\n}\r\nif (rc == 0) {\r\nIEEE80211_DEBUG_QOS("QoS is supported\n");\r\nnetwork->qos_data.supported = 1;\r\n}\r\nreturn rc;\r\n}\r\nstatic const char *get_info_element_string(u16 id)\r\n{\r\nswitch (id) {\r\nMFIE_STRING(SSID);\r\nMFIE_STRING(RATES);\r\nMFIE_STRING(FH_SET);\r\nMFIE_STRING(DS_SET);\r\nMFIE_STRING(CF_SET);\r\nMFIE_STRING(TIM);\r\nMFIE_STRING(IBSS_SET);\r\nMFIE_STRING(COUNTRY);\r\nMFIE_STRING(HOP_PARAMS);\r\nMFIE_STRING(HOP_TABLE);\r\nMFIE_STRING(REQUEST);\r\nMFIE_STRING(CHALLENGE);\r\nMFIE_STRING(POWER_CONSTRAINT);\r\nMFIE_STRING(POWER_CAPABILITY);\r\nMFIE_STRING(TPC_REQUEST);\r\nMFIE_STRING(TPC_REPORT);\r\nMFIE_STRING(SUPP_CHANNELS);\r\nMFIE_STRING(CSA);\r\nMFIE_STRING(MEASURE_REQUEST);\r\nMFIE_STRING(MEASURE_REPORT);\r\nMFIE_STRING(QUIET);\r\nMFIE_STRING(IBSS_DFS);\r\nMFIE_STRING(RSN);\r\nMFIE_STRING(RATES_EX);\r\nMFIE_STRING(GENERIC);\r\nMFIE_STRING(QOS_PARAMETER);\r\ndefault:\r\nreturn "UNKNOWN";\r\n}\r\n}\r\nstatic inline void ieee80211_extract_country_ie(\r\nstruct ieee80211_device *ieee,\r\nstruct ieee80211_info_element *info_element,\r\nstruct ieee80211_network *network,\r\nu8 *addr2\r\n)\r\n{\r\nif (IS_DOT11D_ENABLE(ieee))\r\n{\r\nif (info_element->len!= 0)\r\n{\r\nmemcpy(network->CountryIeBuf, info_element->data, info_element->len);\r\nnetwork->CountryIeLen = info_element->len;\r\nif (!IS_COUNTRY_IE_VALID(ieee))\r\n{\r\nDot11d_UpdateCountryIe(ieee, addr2, info_element->len, info_element->data);\r\n}\r\n}\r\nif (IS_EQUAL_CIE_SRC(ieee, addr2) )\r\n{\r\nUPDATE_CIE_WATCHDOG(ieee);\r\n}\r\n}\r\n}\r\nint ieee80211_parse_info_param(struct ieee80211_device *ieee,\r\nstruct ieee80211_info_element *info_element,\r\nu16 length,\r\nstruct ieee80211_network *network,\r\nstruct ieee80211_rx_stats *stats)\r\n{\r\nu8 i;\r\nshort offset;\r\nu16 tmp_htcap_len=0;\r\nu16 tmp_htinfo_len=0;\r\nu16 ht_realtek_agg_len=0;\r\nu8 ht_realtek_agg_buf[MAX_IE_LEN];\r\n#ifdef CONFIG_IEEE80211_DEBUG\r\nchar rates_str[64];\r\nchar *p;\r\n#endif\r\nwhile (length >= sizeof(*info_element)) {\r\nif (sizeof(*info_element) + info_element->len > length) {\r\nIEEE80211_DEBUG_MGMT("Info elem: parse failed: "\r\n"info_element->len + 2 > left : "\r\n"info_element->len+2=%zd left=%d, id=%d.\n",\r\ninfo_element->len +\r\nsizeof(*info_element),\r\nlength, info_element->id);\r\nbreak;\r\n}\r\nswitch (info_element->id) {\r\ncase MFIE_TYPE_SSID:\r\nif (ieee80211_is_empty_essid(info_element->data,\r\ninfo_element->len)) {\r\nnetwork->flags |= NETWORK_EMPTY_ESSID;\r\nbreak;\r\n}\r\nnetwork->ssid_len = min(info_element->len,\r\n(u8) IW_ESSID_MAX_SIZE);\r\nmemcpy(network->ssid, info_element->data, network->ssid_len);\r\nif (network->ssid_len < IW_ESSID_MAX_SIZE)\r\nmemset(network->ssid + network->ssid_len, 0,\r\nIW_ESSID_MAX_SIZE - network->ssid_len);\r\nIEEE80211_DEBUG_MGMT("MFIE_TYPE_SSID: '%s' len=%d.\n",\r\nnetwork->ssid, network->ssid_len);\r\nbreak;\r\ncase MFIE_TYPE_RATES:\r\n#ifdef CONFIG_IEEE80211_DEBUG\r\np = rates_str;\r\n#endif\r\nnetwork->rates_len = min(info_element->len,\r\nMAX_RATES_LENGTH);\r\nfor (i = 0; i < network->rates_len; i++) {\r\nnetwork->rates[i] = info_element->data[i];\r\n#ifdef CONFIG_IEEE80211_DEBUG\r\np += snprintf(p, sizeof(rates_str) -\r\n(p - rates_str), "%02X ",\r\nnetwork->rates[i]);\r\n#endif\r\nif (ieee80211_is_ofdm_rate\r\n(info_element->data[i])) {\r\nnetwork->flags |= NETWORK_HAS_OFDM;\r\nif (info_element->data[i] &\r\nIEEE80211_BASIC_RATE_MASK)\r\nnetwork->flags &=\r\n~NETWORK_HAS_CCK;\r\n}\r\n}\r\nIEEE80211_DEBUG_MGMT("MFIE_TYPE_RATES: '%s' (%d)\n",\r\nrates_str, network->rates_len);\r\nbreak;\r\ncase MFIE_TYPE_RATES_EX:\r\n#ifdef CONFIG_IEEE80211_DEBUG\r\np = rates_str;\r\n#endif\r\nnetwork->rates_ex_len = min(info_element->len,\r\nMAX_RATES_EX_LENGTH);\r\nfor (i = 0; i < network->rates_ex_len; i++) {\r\nnetwork->rates_ex[i] = info_element->data[i];\r\n#ifdef CONFIG_IEEE80211_DEBUG\r\np += snprintf(p, sizeof(rates_str) -\r\n(p - rates_str), "%02X ",\r\nnetwork->rates_ex[i]);\r\n#endif\r\nif (ieee80211_is_ofdm_rate\r\n(info_element->data[i])) {\r\nnetwork->flags |= NETWORK_HAS_OFDM;\r\nif (info_element->data[i] &\r\nIEEE80211_BASIC_RATE_MASK)\r\nnetwork->flags &=\r\n~NETWORK_HAS_CCK;\r\n}\r\n}\r\nIEEE80211_DEBUG_MGMT("MFIE_TYPE_RATES_EX: '%s' (%d)\n",\r\nrates_str, network->rates_ex_len);\r\nbreak;\r\ncase MFIE_TYPE_DS_SET:\r\nIEEE80211_DEBUG_MGMT("MFIE_TYPE_DS_SET: %d\n",\r\ninfo_element->data[0]);\r\nnetwork->channel = info_element->data[0];\r\nbreak;\r\ncase MFIE_TYPE_FH_SET:\r\nIEEE80211_DEBUG_MGMT("MFIE_TYPE_FH_SET: ignored\n");\r\nbreak;\r\ncase MFIE_TYPE_CF_SET:\r\nIEEE80211_DEBUG_MGMT("MFIE_TYPE_CF_SET: ignored\n");\r\nbreak;\r\ncase MFIE_TYPE_TIM:\r\nif(info_element->len < 4)\r\nbreak;\r\nnetwork->tim.tim_count = info_element->data[0];\r\nnetwork->tim.tim_period = info_element->data[1];\r\nnetwork->dtim_period = info_element->data[1];\r\nif(ieee->state != IEEE80211_LINKED)\r\nbreak;\r\nnetwork->last_dtim_sta_time[0] = stats->mac_time[0];\r\nnetwork->last_dtim_sta_time[1] = stats->mac_time[1];\r\nnetwork->dtim_data = IEEE80211_DTIM_VALID;\r\nif(info_element->data[0] != 0)\r\nbreak;\r\nif(info_element->data[2] & 1)\r\nnetwork->dtim_data |= IEEE80211_DTIM_MBCAST;\r\noffset = (info_element->data[2] >> 1)*2;\r\nif(ieee->assoc_id < 8*offset ||\r\nieee->assoc_id > 8*(offset + info_element->len -3))\r\nbreak;\r\noffset = (ieee->assoc_id / 8) - offset;\r\nif(info_element->data[3+offset] & (1<<(ieee->assoc_id%8)))\r\nnetwork->dtim_data |= IEEE80211_DTIM_UCAST;\r\nbreak;\r\ncase MFIE_TYPE_ERP:\r\nnetwork->erp_value = info_element->data[0];\r\nnetwork->flags |= NETWORK_HAS_ERP_VALUE;\r\nIEEE80211_DEBUG_MGMT("MFIE_TYPE_ERP_SET: %d\n",\r\nnetwork->erp_value);\r\nbreak;\r\ncase MFIE_TYPE_IBSS_SET:\r\nnetwork->atim_window = info_element->data[0];\r\nIEEE80211_DEBUG_MGMT("MFIE_TYPE_IBSS_SET: %d\n",\r\nnetwork->atim_window);\r\nbreak;\r\ncase MFIE_TYPE_CHALLENGE:\r\nIEEE80211_DEBUG_MGMT("MFIE_TYPE_CHALLENGE: ignored\n");\r\nbreak;\r\ncase MFIE_TYPE_GENERIC:\r\nIEEE80211_DEBUG_MGMT("MFIE_TYPE_GENERIC: %d bytes\n",\r\ninfo_element->len);\r\nif (!ieee80211_parse_qos_info_param_IE(info_element,\r\nnetwork))\r\nbreak;\r\nif (info_element->len >= 4 &&\r\ninfo_element->data[0] == 0x00 &&\r\ninfo_element->data[1] == 0x50 &&\r\ninfo_element->data[2] == 0xf2 &&\r\ninfo_element->data[3] == 0x01) {\r\nnetwork->wpa_ie_len = min(info_element->len + 2,\r\nMAX_WPA_IE_LEN);\r\nmemcpy(network->wpa_ie, info_element,\r\nnetwork->wpa_ie_len);\r\nbreak;\r\n}\r\n#ifdef THOMAS_TURBO\r\nif (info_element->len == 7 &&\r\ninfo_element->data[0] == 0x00 &&\r\ninfo_element->data[1] == 0xe0 &&\r\ninfo_element->data[2] == 0x4c &&\r\ninfo_element->data[3] == 0x01 &&\r\ninfo_element->data[4] == 0x02) {\r\nnetwork->Turbo_Enable = 1;\r\n}\r\n#endif\r\nif(tmp_htcap_len == 0){\r\nif(info_element->len >= 4 &&\r\ninfo_element->data[0] == 0x00 &&\r\ninfo_element->data[1] == 0x90 &&\r\ninfo_element->data[2] == 0x4c &&\r\ninfo_element->data[3] == 0x033){\r\ntmp_htcap_len = min(info_element->len,(u8)MAX_IE_LEN);\r\nif(tmp_htcap_len != 0){\r\nnetwork->bssht.bdHTSpecVer = HT_SPEC_VER_EWC;\r\nnetwork->bssht.bdHTCapLen = tmp_htcap_len > sizeof(network->bssht.bdHTCapBuf)?\\r\nsizeof(network->bssht.bdHTCapBuf):tmp_htcap_len;\r\nmemcpy(network->bssht.bdHTCapBuf,info_element->data,network->bssht.bdHTCapLen);\r\n}\r\n}\r\nif(tmp_htcap_len != 0)\r\nnetwork->bssht.bdSupportHT = true;\r\nelse\r\nnetwork->bssht.bdSupportHT = false;\r\n}\r\nif(tmp_htinfo_len == 0){\r\nif(info_element->len >= 4 &&\r\ninfo_element->data[0] == 0x00 &&\r\ninfo_element->data[1] == 0x90 &&\r\ninfo_element->data[2] == 0x4c &&\r\ninfo_element->data[3] == 0x034){\r\ntmp_htinfo_len = min(info_element->len,(u8)MAX_IE_LEN);\r\nif(tmp_htinfo_len != 0){\r\nnetwork->bssht.bdHTSpecVer = HT_SPEC_VER_EWC;\r\nif(tmp_htinfo_len){\r\nnetwork->bssht.bdHTInfoLen = tmp_htinfo_len > sizeof(network->bssht.bdHTInfoBuf)?\\r\nsizeof(network->bssht.bdHTInfoBuf):tmp_htinfo_len;\r\nmemcpy(network->bssht.bdHTInfoBuf,info_element->data,network->bssht.bdHTInfoLen);\r\n}\r\n}\r\n}\r\n}\r\nif(ieee->aggregation){\r\nif(network->bssht.bdSupportHT){\r\nif(info_element->len >= 4 &&\r\ninfo_element->data[0] == 0x00 &&\r\ninfo_element->data[1] == 0xe0 &&\r\ninfo_element->data[2] == 0x4c &&\r\ninfo_element->data[3] == 0x02){\r\nht_realtek_agg_len = min(info_element->len,(u8)MAX_IE_LEN);\r\nmemcpy(ht_realtek_agg_buf,info_element->data,info_element->len);\r\n}\r\nif(ht_realtek_agg_len >= 5){\r\nnetwork->bssht.bdRT2RTAggregation = true;\r\nif((ht_realtek_agg_buf[4] == 1) && (ht_realtek_agg_buf[5] & 0x02))\r\nnetwork->bssht.bdRT2RTLongSlotTime = true;\r\n}\r\n}\r\n}\r\n{\r\nif ((info_element->len >= 3 &&\r\ninfo_element->data[0] == 0x00 &&\r\ninfo_element->data[1] == 0x05 &&\r\ninfo_element->data[2] == 0xb5) ||\r\n(info_element->len >= 3 &&\r\ninfo_element->data[0] == 0x00 &&\r\ninfo_element->data[1] == 0x0a &&\r\ninfo_element->data[2] == 0xf7) ||\r\n(info_element->len >= 3 &&\r\ninfo_element->data[0] == 0x00 &&\r\ninfo_element->data[1] == 0x10 &&\r\ninfo_element->data[2] == 0x18)){\r\nnetwork->broadcom_cap_exist = true;\r\n}\r\n}\r\nif(info_element->len >= 3 &&\r\ninfo_element->data[0] == 0x00 &&\r\ninfo_element->data[1] == 0x0c &&\r\ninfo_element->data[2] == 0x43)\r\n{\r\nnetwork->ralink_cap_exist = true;\r\n}\r\nelse\r\nnetwork->ralink_cap_exist = false;\r\nif((info_element->len >= 3 &&\r\ninfo_element->data[0] == 0x00 &&\r\ninfo_element->data[1] == 0x03 &&\r\ninfo_element->data[2] == 0x7f) ||\r\n(info_element->len >= 3 &&\r\ninfo_element->data[0] == 0x00 &&\r\ninfo_element->data[1] == 0x13 &&\r\ninfo_element->data[2] == 0x74))\r\n{\r\nprintk("========>%s(): athros AP is exist\n",__func__);\r\nnetwork->atheros_cap_exist = true;\r\n}\r\nelse\r\nnetwork->atheros_cap_exist = false;\r\nif(info_element->len >= 3 &&\r\ninfo_element->data[0] == 0x00 &&\r\ninfo_element->data[1] == 0x40 &&\r\ninfo_element->data[2] == 0x96)\r\n{\r\nnetwork->cisco_cap_exist = true;\r\n}\r\nelse\r\nnetwork->cisco_cap_exist = false;\r\nif (info_element->len > 4 &&\r\ninfo_element->data[0] == 0x00 &&\r\ninfo_element->data[1] == 0x40 &&\r\ninfo_element->data[2] == 0x96 &&\r\ninfo_element->data[3] == 0x01)\r\n{\r\nif(info_element->len == 6)\r\n{\r\nmemcpy(network->CcxRmState, &info_element[4], 2);\r\nif(network->CcxRmState[0] != 0)\r\n{\r\nnetwork->bCcxRmEnable = true;\r\n}\r\nelse\r\nnetwork->bCcxRmEnable = false;\r\nnetwork->MBssidMask = network->CcxRmState[1] & 0x07;\r\nif(network->MBssidMask != 0)\r\n{\r\nnetwork->bMBssidValid = true;\r\nnetwork->MBssidMask = 0xff << (network->MBssidMask);\r\ncpMacAddr(network->MBssid, network->bssid);\r\nnetwork->MBssid[5] &= network->MBssidMask;\r\n}\r\nelse\r\n{\r\nnetwork->bMBssidValid = false;\r\n}\r\n}\r\nelse\r\n{\r\nnetwork->bCcxRmEnable = false;\r\n}\r\n}\r\nif (info_element->len > 4 &&\r\ninfo_element->data[0] == 0x00 &&\r\ninfo_element->data[1] == 0x40 &&\r\ninfo_element->data[2] == 0x96 &&\r\ninfo_element->data[3] == 0x03)\r\n{\r\nif(info_element->len == 5)\r\n{\r\nnetwork->bWithCcxVerNum = true;\r\nnetwork->BssCcxVerNumber = info_element->data[4];\r\n}\r\nelse\r\n{\r\nnetwork->bWithCcxVerNum = false;\r\nnetwork->BssCcxVerNumber = 0;\r\n}\r\n}\r\nbreak;\r\ncase MFIE_TYPE_RSN:\r\nIEEE80211_DEBUG_MGMT("MFIE_TYPE_RSN: %d bytes\n",\r\ninfo_element->len);\r\nnetwork->rsn_ie_len = min(info_element->len + 2,\r\nMAX_WPA_IE_LEN);\r\nmemcpy(network->rsn_ie, info_element,\r\nnetwork->rsn_ie_len);\r\nbreak;\r\ncase MFIE_TYPE_HT_CAP:\r\nIEEE80211_DEBUG_SCAN("MFIE_TYPE_HT_CAP: %d bytes\n",\r\ninfo_element->len);\r\ntmp_htcap_len = min(info_element->len,(u8)MAX_IE_LEN);\r\nif(tmp_htcap_len != 0){\r\nnetwork->bssht.bdHTSpecVer = HT_SPEC_VER_EWC;\r\nnetwork->bssht.bdHTCapLen = tmp_htcap_len > sizeof(network->bssht.bdHTCapBuf)?\\r\nsizeof(network->bssht.bdHTCapBuf):tmp_htcap_len;\r\nmemcpy(network->bssht.bdHTCapBuf,info_element->data,network->bssht.bdHTCapLen);\r\nnetwork->bssht.bdSupportHT = true;\r\n}\r\nelse\r\nnetwork->bssht.bdSupportHT = false;\r\nbreak;\r\ncase MFIE_TYPE_HT_INFO:\r\nIEEE80211_DEBUG_SCAN("MFIE_TYPE_HT_INFO: %d bytes\n",\r\ninfo_element->len);\r\ntmp_htinfo_len = min(info_element->len,(u8)MAX_IE_LEN);\r\nif(tmp_htinfo_len){\r\nnetwork->bssht.bdHTSpecVer = HT_SPEC_VER_IEEE;\r\nnetwork->bssht.bdHTInfoLen = tmp_htinfo_len > sizeof(network->bssht.bdHTInfoBuf)?\\r\nsizeof(network->bssht.bdHTInfoBuf):tmp_htinfo_len;\r\nmemcpy(network->bssht.bdHTInfoBuf,info_element->data,network->bssht.bdHTInfoLen);\r\n}\r\nbreak;\r\ncase MFIE_TYPE_AIRONET:\r\nIEEE80211_DEBUG_SCAN("MFIE_TYPE_AIRONET: %d bytes\n",\r\ninfo_element->len);\r\nif(info_element->len >IE_CISCO_FLAG_POSITION)\r\n{\r\nnetwork->bWithAironetIE = true;\r\nif( (info_element->data[IE_CISCO_FLAG_POSITION]&SUPPORT_CKIP_MIC) ||\r\n(info_element->data[IE_CISCO_FLAG_POSITION]&SUPPORT_CKIP_PK) )\r\n{\r\nnetwork->bCkipSupported = true;\r\n}\r\nelse\r\n{\r\nnetwork->bCkipSupported = false;\r\n}\r\n}\r\nelse\r\n{\r\nnetwork->bWithAironetIE = false;\r\nnetwork->bCkipSupported = false;\r\n}\r\nbreak;\r\ncase MFIE_TYPE_QOS_PARAMETER:\r\nprintk(KERN_ERR\r\n"QoS Error need to parse QOS_PARAMETER IE\n");\r\nbreak;\r\ncase MFIE_TYPE_COUNTRY:\r\nIEEE80211_DEBUG_SCAN("MFIE_TYPE_COUNTRY: %d bytes\n",\r\ninfo_element->len);\r\nieee80211_extract_country_ie(ieee, info_element, network, network->bssid);\r\nbreak;\r\ndefault:\r\nIEEE80211_DEBUG_MGMT\r\n("Unsupported info element: %s (%d)\n",\r\nget_info_element_string(info_element->id),\r\ninfo_element->id);\r\nbreak;\r\n}\r\nlength -= sizeof(*info_element) + info_element->len;\r\ninfo_element =\r\n(struct ieee80211_info_element *)&info_element->\r\ndata[info_element->len];\r\n}\r\nif(!network->atheros_cap_exist && !network->broadcom_cap_exist &&\r\n!network->cisco_cap_exist && !network->ralink_cap_exist && !network->bssht.bdRT2RTAggregation)\r\n{\r\nnetwork->unknown_cap_exist = true;\r\n}\r\nelse\r\n{\r\nnetwork->unknown_cap_exist = false;\r\n}\r\nreturn 0;\r\n}\r\nstatic inline u8 ieee80211_SignalStrengthTranslate(\r\nu8 CurrSS\r\n)\r\n{\r\nu8 RetSS;\r\nif(CurrSS >= 71 && CurrSS <= 100)\r\n{\r\nRetSS = 90 + ((CurrSS - 70) / 3);\r\n}\r\nelse if(CurrSS >= 41 && CurrSS <= 70)\r\n{\r\nRetSS = 78 + ((CurrSS - 40) / 3);\r\n}\r\nelse if(CurrSS >= 31 && CurrSS <= 40)\r\n{\r\nRetSS = 66 + (CurrSS - 30);\r\n}\r\nelse if(CurrSS >= 21 && CurrSS <= 30)\r\n{\r\nRetSS = 54 + (CurrSS - 20);\r\n}\r\nelse if(CurrSS >= 5 && CurrSS <= 20)\r\n{\r\nRetSS = 42 + (((CurrSS - 5) * 2) / 3);\r\n}\r\nelse if(CurrSS == 4)\r\n{\r\nRetSS = 36;\r\n}\r\nelse if(CurrSS == 3)\r\n{\r\nRetSS = 27;\r\n}\r\nelse if(CurrSS == 2)\r\n{\r\nRetSS = 18;\r\n}\r\nelse if(CurrSS == 1)\r\n{\r\nRetSS = 9;\r\n}\r\nelse\r\n{\r\nRetSS = CurrSS;\r\n}\r\nreturn RetSS;\r\n}\r\nstatic long ieee80211_translate_todbm(u8 signal_strength_index)\r\n{\r\nlong signal_power;\r\nsignal_power = (long)((signal_strength_index + 1) >> 1);\r\nsignal_power -= 95;\r\nreturn signal_power;\r\n}\r\nstatic inline int ieee80211_network_init(\r\nstruct ieee80211_device *ieee,\r\nstruct ieee80211_probe_response *beacon,\r\nstruct ieee80211_network *network,\r\nstruct ieee80211_rx_stats *stats)\r\n{\r\n#ifdef CONFIG_IEEE80211_DEBUG\r\n#endif\r\nnetwork->qos_data.active = 0;\r\nnetwork->qos_data.supported = 0;\r\nnetwork->qos_data.param_count = 0;\r\nnetwork->qos_data.old_param_count = 0;\r\nmemcpy(network->bssid, beacon->header.addr3, ETH_ALEN);\r\nnetwork->capability = le16_to_cpu(beacon->capability);\r\nnetwork->last_scanned = jiffies;\r\nnetwork->time_stamp[0] = le32_to_cpu(beacon->time_stamp[0]);\r\nnetwork->time_stamp[1] = le32_to_cpu(beacon->time_stamp[1]);\r\nnetwork->beacon_interval = le16_to_cpu(beacon->beacon_interval);\r\nnetwork->listen_interval = 0x0A;\r\nnetwork->rates_len = network->rates_ex_len = 0;\r\nnetwork->last_associate = 0;\r\nnetwork->ssid_len = 0;\r\nnetwork->flags = 0;\r\nnetwork->atim_window = 0;\r\nnetwork->erp_value = (network->capability & WLAN_CAPABILITY_IBSS) ?\r\n0x3 : 0x0;\r\nnetwork->berp_info_valid = false;\r\nnetwork->broadcom_cap_exist = false;\r\nnetwork->ralink_cap_exist = false;\r\nnetwork->atheros_cap_exist = false;\r\nnetwork->cisco_cap_exist = false;\r\nnetwork->unknown_cap_exist = false;\r\n#ifdef THOMAS_TURBO\r\nnetwork->Turbo_Enable = 0;\r\n#endif\r\nnetwork->CountryIeLen = 0;\r\nmemset(network->CountryIeBuf, 0, MAX_IE_LEN);\r\nHTInitializeBssDesc(&network->bssht);\r\nif (stats->freq == IEEE80211_52GHZ_BAND) {\r\nnetwork->channel = stats->received_channel;\r\n} else\r\nnetwork->flags |= NETWORK_HAS_CCK;\r\nnetwork->wpa_ie_len = 0;\r\nnetwork->rsn_ie_len = 0;\r\nif (ieee80211_parse_info_param\r\n(ieee,beacon->info_element, stats->len - sizeof(*beacon), network, stats))\r\nreturn 1;\r\nnetwork->mode = 0;\r\nif (stats->freq == IEEE80211_52GHZ_BAND)\r\nnetwork->mode = IEEE_A;\r\nelse {\r\nif (network->flags & NETWORK_HAS_OFDM)\r\nnetwork->mode |= IEEE_G;\r\nif (network->flags & NETWORK_HAS_CCK)\r\nnetwork->mode |= IEEE_B;\r\n}\r\nif (network->mode == 0) {\r\nIEEE80211_DEBUG_SCAN("Filtered out '%s (%pM)' "\r\n"network.\n",\r\nescape_essid(network->ssid,\r\nnetwork->ssid_len),\r\nnetwork->bssid);\r\nreturn 1;\r\n}\r\nif(network->bssht.bdSupportHT){\r\nif(network->mode == IEEE_A)\r\nnetwork->mode = IEEE_N_5G;\r\nelse if(network->mode & (IEEE_G | IEEE_B))\r\nnetwork->mode = IEEE_N_24G;\r\n}\r\nif (ieee80211_is_empty_essid(network->ssid, network->ssid_len))\r\nnetwork->flags |= NETWORK_EMPTY_ESSID;\r\nstats->signal = 30 + (stats->SignalStrength * 70) / 100;\r\nstats->noise = ieee80211_translate_todbm((u8)(100-stats->signal)) -25;\r\nmemcpy(&network->stats, stats, sizeof(network->stats));\r\nreturn 0;\r\n}\r\nstatic inline int is_same_network(struct ieee80211_network *src,\r\nstruct ieee80211_network *dst, struct ieee80211_device *ieee)\r\n{\r\nreturn\r\n(((src->ssid_len == dst->ssid_len) || (ieee->iw_mode == IW_MODE_INFRA)) &&\r\n(src->channel == dst->channel) &&\r\n!memcmp(src->bssid, dst->bssid, ETH_ALEN) &&\r\n(!memcmp(src->ssid, dst->ssid, src->ssid_len) || (ieee->iw_mode == IW_MODE_INFRA)) &&\r\n((src->capability & WLAN_CAPABILITY_IBSS) ==\r\n(dst->capability & WLAN_CAPABILITY_IBSS)) &&\r\n((src->capability & WLAN_CAPABILITY_BSS) ==\r\n(dst->capability & WLAN_CAPABILITY_BSS)));\r\n}\r\nstatic inline void update_network(struct ieee80211_network *dst,\r\nstruct ieee80211_network *src)\r\n{\r\nint qos_active;\r\nu8 old_param;\r\nmemcpy(&dst->stats, &src->stats, sizeof(struct ieee80211_rx_stats));\r\ndst->capability = src->capability;\r\nmemcpy(dst->rates, src->rates, src->rates_len);\r\ndst->rates_len = src->rates_len;\r\nmemcpy(dst->rates_ex, src->rates_ex, src->rates_ex_len);\r\ndst->rates_ex_len = src->rates_ex_len;\r\nif (src->ssid_len > 0)\r\n{\r\nmemset(dst->ssid, 0, dst->ssid_len);\r\ndst->ssid_len = src->ssid_len;\r\nmemcpy(dst->ssid, src->ssid, src->ssid_len);\r\n}\r\ndst->mode = src->mode;\r\ndst->flags = src->flags;\r\ndst->time_stamp[0] = src->time_stamp[0];\r\ndst->time_stamp[1] = src->time_stamp[1];\r\nif (src->flags & NETWORK_HAS_ERP_VALUE)\r\n{\r\ndst->erp_value = src->erp_value;\r\ndst->berp_info_valid = src->berp_info_valid = true;\r\n}\r\ndst->beacon_interval = src->beacon_interval;\r\ndst->listen_interval = src->listen_interval;\r\ndst->atim_window = src->atim_window;\r\ndst->dtim_period = src->dtim_period;\r\ndst->dtim_data = src->dtim_data;\r\ndst->last_dtim_sta_time[0] = src->last_dtim_sta_time[0];\r\ndst->last_dtim_sta_time[1] = src->last_dtim_sta_time[1];\r\nmemcpy(&dst->tim, &src->tim, sizeof(struct ieee80211_tim_parameters));\r\ndst->bssht.bdSupportHT = src->bssht.bdSupportHT;\r\ndst->bssht.bdRT2RTAggregation = src->bssht.bdRT2RTAggregation;\r\ndst->bssht.bdHTCapLen= src->bssht.bdHTCapLen;\r\nmemcpy(dst->bssht.bdHTCapBuf,src->bssht.bdHTCapBuf,src->bssht.bdHTCapLen);\r\ndst->bssht.bdHTInfoLen= src->bssht.bdHTInfoLen;\r\nmemcpy(dst->bssht.bdHTInfoBuf,src->bssht.bdHTInfoBuf,src->bssht.bdHTInfoLen);\r\ndst->bssht.bdHTSpecVer = src->bssht.bdHTSpecVer;\r\ndst->bssht.bdRT2RTLongSlotTime = src->bssht.bdRT2RTLongSlotTime;\r\ndst->broadcom_cap_exist = src->broadcom_cap_exist;\r\ndst->ralink_cap_exist = src->ralink_cap_exist;\r\ndst->atheros_cap_exist = src->atheros_cap_exist;\r\ndst->cisco_cap_exist = src->cisco_cap_exist;\r\ndst->unknown_cap_exist = src->unknown_cap_exist;\r\nmemcpy(dst->wpa_ie, src->wpa_ie, src->wpa_ie_len);\r\ndst->wpa_ie_len = src->wpa_ie_len;\r\nmemcpy(dst->rsn_ie, src->rsn_ie, src->rsn_ie_len);\r\ndst->rsn_ie_len = src->rsn_ie_len;\r\ndst->last_scanned = jiffies;\r\nqos_active = dst->qos_data.active;\r\nold_param = dst->qos_data.param_count;\r\nif(dst->flags & NETWORK_HAS_QOS_MASK)\r\nmemcpy(&dst->qos_data, &src->qos_data,\r\nsizeof(struct ieee80211_qos_data));\r\nelse {\r\ndst->qos_data.supported = src->qos_data.supported;\r\ndst->qos_data.param_count = src->qos_data.param_count;\r\n}\r\nif (dst->qos_data.supported == 1) {\r\ndst->QoS_Enable = 1;\r\nif(dst->ssid_len)\r\nIEEE80211_DEBUG_QOS\r\n("QoS the network %s is QoS supported\n",\r\ndst->ssid);\r\nelse\r\nIEEE80211_DEBUG_QOS\r\n("QoS the network is QoS supported\n");\r\n}\r\ndst->qos_data.active = qos_active;\r\ndst->qos_data.old_param_count = old_param;\r\ndst->wmm_info = src->wmm_info;\r\nif (src->wmm_param[0].aci_aifsn|| \\r\nsrc->wmm_param[1].aci_aifsn|| \\r\nsrc->wmm_param[2].aci_aifsn|| \\r\nsrc->wmm_param[3].aci_aifsn) {\r\nmemcpy(dst->wmm_param, src->wmm_param, WME_AC_PRAM_LEN);\r\n}\r\n#ifdef THOMAS_TURBO\r\ndst->Turbo_Enable = src->Turbo_Enable;\r\n#endif\r\ndst->CountryIeLen = src->CountryIeLen;\r\nmemcpy(dst->CountryIeBuf, src->CountryIeBuf, src->CountryIeLen);\r\ndst->bWithAironetIE = src->bWithAironetIE;\r\ndst->bCkipSupported = src->bCkipSupported;\r\nmemcpy(dst->CcxRmState, src->CcxRmState, 2);\r\ndst->bCcxRmEnable = src->bCcxRmEnable;\r\ndst->MBssidMask = src->MBssidMask;\r\ndst->bMBssidValid = src->bMBssidValid;\r\nmemcpy(dst->MBssid, src->MBssid, 6);\r\ndst->bWithCcxVerNum = src->bWithCcxVerNum;\r\ndst->BssCcxVerNumber = src->BssCcxVerNumber;\r\n}\r\nstatic inline int is_beacon(__le16 fc)\r\n{\r\nreturn (WLAN_FC_GET_STYPE(le16_to_cpu(fc)) == IEEE80211_STYPE_BEACON);\r\n}\r\nstatic inline void ieee80211_process_probe_response(\r\nstruct ieee80211_device *ieee,\r\nstruct ieee80211_probe_response *beacon,\r\nstruct ieee80211_rx_stats *stats)\r\n{\r\nstruct ieee80211_network network;\r\nstruct ieee80211_network *target;\r\nstruct ieee80211_network *oldest = NULL;\r\n#ifdef CONFIG_IEEE80211_DEBUG\r\nstruct ieee80211_info_element *info_element = &beacon->info_element[0];\r\n#endif\r\nunsigned long flags;\r\nshort renew;\r\nmemset(&network, 0, sizeof(struct ieee80211_network));\r\nIEEE80211_DEBUG_SCAN(\r\n"'%s' (%pM): %c%c%c%c %c%c%c%c-%c%c%c%c %c%c%c%c\n",\r\nescape_essid(info_element->data, info_element->len),\r\nbeacon->header.addr3,\r\n(beacon->capability & (1<<0xf)) ? '1' : '0',\r\n(beacon->capability & (1<<0xe)) ? '1' : '0',\r\n(beacon->capability & (1<<0xd)) ? '1' : '0',\r\n(beacon->capability & (1<<0xc)) ? '1' : '0',\r\n(beacon->capability & (1<<0xb)) ? '1' : '0',\r\n(beacon->capability & (1<<0xa)) ? '1' : '0',\r\n(beacon->capability & (1<<0x9)) ? '1' : '0',\r\n(beacon->capability & (1<<0x8)) ? '1' : '0',\r\n(beacon->capability & (1<<0x7)) ? '1' : '0',\r\n(beacon->capability & (1<<0x6)) ? '1' : '0',\r\n(beacon->capability & (1<<0x5)) ? '1' : '0',\r\n(beacon->capability & (1<<0x4)) ? '1' : '0',\r\n(beacon->capability & (1<<0x3)) ? '1' : '0',\r\n(beacon->capability & (1<<0x2)) ? '1' : '0',\r\n(beacon->capability & (1<<0x1)) ? '1' : '0',\r\n(beacon->capability & (1<<0x0)) ? '1' : '0');\r\nif (ieee80211_network_init(ieee, beacon, &network, stats)) {\r\nIEEE80211_DEBUG_SCAN("Dropped '%s' (%pM) via %s.\n",\r\nescape_essid(info_element->data,\r\ninfo_element->len),\r\nbeacon->header.addr3,\r\nWLAN_FC_GET_STYPE(beacon->header.frame_ctl) ==\r\nIEEE80211_STYPE_PROBE_RESP ?\r\n"PROBE RESPONSE" : "BEACON");\r\nreturn;\r\n}\r\nif (!IsLegalChannel(ieee, network.channel))\r\nreturn;\r\nif (ieee->bGlobalDomain)\r\n{\r\nif (WLAN_FC_GET_STYPE(beacon->header.frame_ctl) == IEEE80211_STYPE_PROBE_RESP)\r\n{\r\nif(IS_COUNTRY_IE_VALID(ieee) )\r\n{\r\nif (!IsLegalChannel(ieee, network.channel)) {\r\nprintk("GetScanInfo(): For Country code, filter probe response at channel(%d).\n", network.channel);\r\nreturn;\r\n}\r\n}\r\nelse\r\n{\r\nif (network.channel > 11)\r\n{\r\nprintk("GetScanInfo(): For Global Domain, filter probe response at channel(%d).\n", network.channel);\r\nreturn;\r\n}\r\n}\r\n}\r\nelse\r\n{\r\nif(IS_COUNTRY_IE_VALID(ieee) )\r\n{\r\nif (!IsLegalChannel(ieee, network.channel)) {\r\nprintk("GetScanInfo(): For Country code, filter beacon at channel(%d).\n",network.channel);\r\nreturn;\r\n}\r\n}\r\nelse\r\n{\r\nif (network.channel > 14)\r\n{\r\nprintk("GetScanInfo(): For Global Domain, filter beacon at channel(%d).\n",network.channel);\r\nreturn;\r\n}\r\n}\r\n}\r\n}\r\nspin_lock_irqsave(&ieee->lock, flags);\r\nif (is_same_network(&ieee->current_network, &network, ieee)) {\r\nupdate_network(&ieee->current_network, &network);\r\nif ((ieee->current_network.mode == IEEE_N_24G || ieee->current_network.mode == IEEE_G)\r\n&& ieee->current_network.berp_info_valid){\r\nif(ieee->current_network.erp_value& ERP_UseProtection)\r\nieee->current_network.buseprotection = true;\r\nelse\r\nieee->current_network.buseprotection = false;\r\n}\r\nif(is_beacon(beacon->header.frame_ctl))\r\n{\r\nif(ieee->state == IEEE80211_LINKED)\r\nieee->LinkDetectInfo.NumRecvBcnInPeriod++;\r\n}\r\nelse\r\nnetwork.flags = (~NETWORK_EMPTY_ESSID & network.flags)|(NETWORK_EMPTY_ESSID & ieee->current_network.flags);\r\n}\r\nlist_for_each_entry(target, &ieee->network_list, list) {\r\nif (is_same_network(target, &network, ieee))\r\nbreak;\r\nif ((oldest == NULL) ||\r\n(target->last_scanned < oldest->last_scanned))\r\noldest = target;\r\n}\r\nif (&target->list == &ieee->network_list) {\r\nif (list_empty(&ieee->network_free_list)) {\r\nlist_del(&oldest->list);\r\ntarget = oldest;\r\nIEEE80211_DEBUG_SCAN("Expired '%s' (%pM) from "\r\n"network list.\n",\r\nescape_essid(target->ssid,\r\ntarget->ssid_len),\r\ntarget->bssid);\r\n} else {\r\ntarget = list_entry(ieee->network_free_list.next,\r\nstruct ieee80211_network, list);\r\nlist_del(ieee->network_free_list.next);\r\n}\r\n#ifdef CONFIG_IEEE80211_DEBUG\r\nIEEE80211_DEBUG_SCAN("Adding '%s' (%pM) via %s.\n",\r\nescape_essid(network.ssid,\r\nnetwork.ssid_len),\r\nnetwork.bssid,\r\nWLAN_FC_GET_STYPE(beacon->header.frame_ctl) ==\r\nIEEE80211_STYPE_PROBE_RESP ?\r\n"PROBE RESPONSE" : "BEACON");\r\n#endif\r\nmemcpy(target, &network, sizeof(*target));\r\nlist_add_tail(&target->list, &ieee->network_list);\r\nif(ieee->softmac_features & IEEE_SOFTMAC_ASSOCIATE)\r\nieee80211_softmac_new_net(ieee,&network);\r\n} else {\r\nIEEE80211_DEBUG_SCAN("Updating '%s' (%pM) via %s.\n",\r\nescape_essid(target->ssid,\r\ntarget->ssid_len),\r\ntarget->bssid,\r\nWLAN_FC_GET_STYPE(beacon->header.frame_ctl) ==\r\nIEEE80211_STYPE_PROBE_RESP ?\r\n"PROBE RESPONSE" : "BEACON");\r\nrenew = !time_after(target->last_scanned + ieee->scan_age, jiffies);\r\nif(is_beacon(beacon->header.frame_ctl) == 0)\r\nnetwork.flags = (~NETWORK_EMPTY_ESSID & network.flags)|(NETWORK_EMPTY_ESSID & target->flags);\r\nif(((network.flags & NETWORK_EMPTY_ESSID) == NETWORK_EMPTY_ESSID) \\r\n&& (((network.ssid_len > 0) && (strncmp(target->ssid, network.ssid, network.ssid_len)))\\r\n||((ieee->current_network.ssid_len == network.ssid_len)&&(strncmp(ieee->current_network.ssid, network.ssid, network.ssid_len) == 0)&&(ieee->state == IEEE80211_NOLINK))))\r\nrenew = 1;\r\nupdate_network(target, &network);\r\nif(renew && (ieee->softmac_features & IEEE_SOFTMAC_ASSOCIATE))\r\nieee80211_softmac_new_net(ieee,&network);\r\n}\r\nspin_unlock_irqrestore(&ieee->lock, flags);\r\nif (is_beacon(beacon->header.frame_ctl)&&is_same_network(&ieee->current_network, &network, ieee)&&\\r\n(ieee->state == IEEE80211_LINKED)) {\r\nif (ieee->handle_beacon != NULL) {\r\nieee->handle_beacon(ieee->dev,beacon,&ieee->current_network);\r\n}\r\n}\r\n}\r\nvoid ieee80211_rx_mgt(struct ieee80211_device *ieee,\r\nstruct rtl_80211_hdr_4addr *header,\r\nstruct ieee80211_rx_stats *stats)\r\n{\r\nswitch (WLAN_FC_GET_STYPE(header->frame_ctl)) {\r\ncase IEEE80211_STYPE_BEACON:\r\nIEEE80211_DEBUG_MGMT("received BEACON (%d)\n",\r\nWLAN_FC_GET_STYPE(header->frame_ctl));\r\nIEEE80211_DEBUG_SCAN("Beacon\n");\r\nieee80211_process_probe_response(\r\nieee, (struct ieee80211_probe_response *)header, stats);\r\nbreak;\r\ncase IEEE80211_STYPE_PROBE_RESP:\r\nIEEE80211_DEBUG_MGMT("received PROBE RESPONSE (%d)\n",\r\nWLAN_FC_GET_STYPE(header->frame_ctl));\r\nIEEE80211_DEBUG_SCAN("Probe response\n");\r\nieee80211_process_probe_response(\r\nieee, (struct ieee80211_probe_response *)header, stats);\r\nbreak;\r\n}\r\n}
