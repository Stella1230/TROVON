static inline u32 qib_read_ureg32(const struct qib_devdata *dd,\r\nenum qib_ureg regno, int ctxt)\r\n{\r\nif (!dd->kregbase || !(dd->flags & QIB_PRESENT))\r\nreturn 0;\r\nif (dd->userbase)\r\nreturn readl(regno + (u64 __iomem *)\r\n((char __iomem *)dd->userbase +\r\ndd->ureg_align * ctxt));\r\nelse\r\nreturn readl(regno + (u64 __iomem *)\r\n(dd->uregbase +\r\n(char __iomem *)dd->kregbase +\r\ndd->ureg_align * ctxt));\r\n}\r\nstatic inline void qib_write_ureg(const struct qib_devdata *dd,\r\nenum qib_ureg regno, u64 value, int ctxt)\r\n{\r\nu64 __iomem *ubase;\r\nif (dd->userbase)\r\nubase = (u64 __iomem *)\r\n((char __iomem *) dd->userbase +\r\ndd->ureg_align * ctxt);\r\nelse\r\nubase = (u64 __iomem *)\r\n(dd->uregbase +\r\n(char __iomem *) dd->kregbase +\r\ndd->ureg_align * ctxt);\r\nif (dd->kregbase && (dd->flags & QIB_PRESENT))\r\nwriteq(value, &ubase[regno]);\r\n}\r\nstatic inline u32 qib_read_kreg32(const struct qib_devdata *dd,\r\nconst u16 regno)\r\n{\r\nif (!dd->kregbase || !(dd->flags & QIB_PRESENT))\r\nreturn -1;\r\nreturn readl((u32 __iomem *)&dd->kregbase[regno]);\r\n}\r\nstatic inline u64 qib_read_kreg64(const struct qib_devdata *dd,\r\nconst u16 regno)\r\n{\r\nif (!dd->kregbase || !(dd->flags & QIB_PRESENT))\r\nreturn -1;\r\nreturn readq(&dd->kregbase[regno]);\r\n}\r\nstatic inline void qib_write_kreg(const struct qib_devdata *dd,\r\nconst u16 regno, u64 value)\r\n{\r\nif (dd->kregbase && (dd->flags & QIB_PRESENT))\r\nwriteq(value, &dd->kregbase[regno]);\r\n}\r\nstatic inline void qib_write_kreg_ctxt(const struct qib_devdata *dd,\r\nconst u16 regno, unsigned ctxt,\r\nu64 value)\r\n{\r\nqib_write_kreg(dd, regno + ctxt, value);\r\n}\r\nstatic inline void write_6120_creg(const struct qib_devdata *dd,\r\nu16 regno, u64 value)\r\n{\r\nif (dd->cspec->cregbase && (dd->flags & QIB_PRESENT))\r\nwriteq(value, &dd->cspec->cregbase[regno]);\r\n}\r\nstatic inline u64 read_6120_creg(const struct qib_devdata *dd, u16 regno)\r\n{\r\nif (!dd->cspec->cregbase || !(dd->flags & QIB_PRESENT))\r\nreturn 0;\r\nreturn readq(&dd->cspec->cregbase[regno]);\r\n}\r\nstatic inline u32 read_6120_creg32(const struct qib_devdata *dd, u16 regno)\r\n{\r\nif (!dd->cspec->cregbase || !(dd->flags & QIB_PRESENT))\r\nreturn 0;\r\nreturn readl(&dd->cspec->cregbase[regno]);\r\n}\r\nstatic void qib_6120_txe_recover(struct qib_devdata *dd)\r\n{\r\nif (!qib_unordered_wc())\r\nqib_devinfo(dd->pcidev,\r\n"Recovering from TXE PIO parity error\n");\r\n}\r\nstatic void qib_6120_set_intr_state(struct qib_devdata *dd, u32 enable)\r\n{\r\nif (enable) {\r\nif (dd->flags & QIB_BADINTR)\r\nreturn;\r\nqib_write_kreg(dd, kr_intmask, ~0ULL);\r\nqib_write_kreg(dd, kr_intclear, 0ULL);\r\n} else\r\nqib_write_kreg(dd, kr_intmask, 0ULL);\r\n}\r\nstatic void qib_6120_clear_freeze(struct qib_devdata *dd)\r\n{\r\nqib_write_kreg(dd, kr_errmask, 0ULL);\r\nqib_6120_set_intr_state(dd, 0);\r\nqib_cancel_sends(dd->pport);\r\nqib_write_kreg(dd, kr_control, dd->control);\r\nqib_read_kreg32(dd, kr_scratch);\r\nqib_force_pio_avail_update(dd);\r\nqib_write_kreg(dd, kr_hwerrclear, 0ULL);\r\nqib_write_kreg(dd, kr_errclear, E_SPKT_ERRS_IGNORE);\r\nqib_write_kreg(dd, kr_errmask, dd->cspec->errormask);\r\nqib_6120_set_intr_state(dd, 1);\r\n}\r\nstatic void qib_handle_6120_hwerrors(struct qib_devdata *dd, char *msg,\r\nsize_t msgl)\r\n{\r\nu64 hwerrs;\r\nu32 bits, ctrl;\r\nint isfatal = 0;\r\nchar *bitsmsg;\r\nint log_idx;\r\nhwerrs = qib_read_kreg64(dd, kr_hwerrstatus);\r\nif (!hwerrs)\r\nreturn;\r\nif (hwerrs == ~0ULL) {\r\nqib_dev_err(dd,\r\n"Read of hardware error status failed (all bits set); ignoring\n");\r\nreturn;\r\n}\r\nqib_stats.sps_hwerrs++;\r\nqib_write_kreg(dd, kr_hwerrclear,\r\nhwerrs & ~HWE_MASK(PowerOnBISTFailed));\r\nhwerrs &= dd->cspec->hwerrmask;\r\nfor (log_idx = 0; log_idx < QIB_EEP_LOG_CNT; ++log_idx)\r\nif (hwerrs & dd->eep_st_masks[log_idx].hwerrs_to_log)\r\nqib_inc_eeprom_err(dd, log_idx, 1);\r\nif (hwerrs & ~(TXE_PIO_PARITY | RXEMEMPARITYERR_EAGERTID))\r\nqib_devinfo(dd->pcidev,\r\n"Hardware error: hwerr=0x%llx (cleared)\n",\r\n(unsigned long long) hwerrs);\r\nif (hwerrs & ~IB_HWE_BITSEXTANT)\r\nqib_dev_err(dd,\r\n"hwerror interrupt with unknown errors %llx set\n",\r\n(unsigned long long)(hwerrs & ~IB_HWE_BITSEXTANT));\r\nctrl = qib_read_kreg32(dd, kr_control);\r\nif ((ctrl & QLOGIC_IB_C_FREEZEMODE) && !dd->diag_client) {\r\nif (hwerrs & TXE_PIO_PARITY) {\r\nqib_6120_txe_recover(dd);\r\nhwerrs &= ~TXE_PIO_PARITY;\r\n}\r\nif (!hwerrs) {\r\nstatic u32 freeze_cnt;\r\nfreeze_cnt++;\r\nqib_6120_clear_freeze(dd);\r\n} else\r\nisfatal = 1;\r\n}\r\n*msg = '\0';\r\nif (hwerrs & HWE_MASK(PowerOnBISTFailed)) {\r\nisfatal = 1;\r\nstrlcat(msg,\r\n"[Memory BIST test failed, InfiniPath hardware unusable]",\r\nmsgl);\r\ndd->cspec->hwerrmask &= ~HWE_MASK(PowerOnBISTFailed);\r\nqib_write_kreg(dd, kr_hwerrmask, dd->cspec->hwerrmask);\r\n}\r\nqib_format_hwerrors(hwerrs, qib_6120_hwerror_msgs,\r\nARRAY_SIZE(qib_6120_hwerror_msgs), msg, msgl);\r\nbitsmsg = dd->cspec->bitsmsgbuf;\r\nif (hwerrs & (QLOGIC_IB_HWE_PCIEMEMPARITYERR_MASK <<\r\nQLOGIC_IB_HWE_PCIEMEMPARITYERR_SHIFT)) {\r\nbits = (u32) ((hwerrs >>\r\nQLOGIC_IB_HWE_PCIEMEMPARITYERR_SHIFT) &\r\nQLOGIC_IB_HWE_PCIEMEMPARITYERR_MASK);\r\nsnprintf(bitsmsg, sizeof(dd->cspec->bitsmsgbuf),\r\n"[PCIe Mem Parity Errs %x] ", bits);\r\nstrlcat(msg, bitsmsg, msgl);\r\n}\r\nif (hwerrs & _QIB_PLL_FAIL) {\r\nisfatal = 1;\r\nsnprintf(bitsmsg, sizeof(dd->cspec->bitsmsgbuf),\r\n"[PLL failed (%llx), InfiniPath hardware unusable]",\r\n(unsigned long long) hwerrs & _QIB_PLL_FAIL);\r\nstrlcat(msg, bitsmsg, msgl);\r\ndd->cspec->hwerrmask &= ~(hwerrs & _QIB_PLL_FAIL);\r\nqib_write_kreg(dd, kr_hwerrmask, dd->cspec->hwerrmask);\r\n}\r\nif (hwerrs & QLOGIC_IB_HWE_SERDESPLLFAILED) {\r\ndd->cspec->hwerrmask &= ~QLOGIC_IB_HWE_SERDESPLLFAILED;\r\nqib_write_kreg(dd, kr_hwerrmask, dd->cspec->hwerrmask);\r\n}\r\nif (hwerrs)\r\nqib_dev_err(dd, "%s hardware error\n", msg);\r\nelse\r\n*msg = 0;\r\nif (isfatal && !dd->diag_client) {\r\nqib_dev_err(dd,\r\n"Fatal Hardware Error, no longer usable, SN %.16s\n",\r\ndd->serial);\r\nif (dd->freezemsg)\r\nsnprintf(dd->freezemsg, dd->freezelen,\r\n"{%s}", msg);\r\nqib_disable_after_error(dd);\r\n}\r\n}\r\nstatic int qib_decode_6120_err(struct qib_devdata *dd, char *buf, size_t blen,\r\nu64 err)\r\n{\r\nint iserr = 1;\r\n*buf = '\0';\r\nif (err & QLOGIC_IB_E_PKTERRS) {\r\nif (!(err & ~QLOGIC_IB_E_PKTERRS))\r\niserr = 0;\r\nif ((err & ERR_MASK(RcvICRCErr)) &&\r\n!(err&(ERR_MASK(RcvVCRCErr)|ERR_MASK(RcvEBPErr))))\r\nstrlcat(buf, "CRC ", blen);\r\nif (!iserr)\r\ngoto done;\r\n}\r\nif (err & ERR_MASK(RcvHdrLenErr))\r\nstrlcat(buf, "rhdrlen ", blen);\r\nif (err & ERR_MASK(RcvBadTidErr))\r\nstrlcat(buf, "rbadtid ", blen);\r\nif (err & ERR_MASK(RcvBadVersionErr))\r\nstrlcat(buf, "rbadversion ", blen);\r\nif (err & ERR_MASK(RcvHdrErr))\r\nstrlcat(buf, "rhdr ", blen);\r\nif (err & ERR_MASK(RcvLongPktLenErr))\r\nstrlcat(buf, "rlongpktlen ", blen);\r\nif (err & ERR_MASK(RcvMaxPktLenErr))\r\nstrlcat(buf, "rmaxpktlen ", blen);\r\nif (err & ERR_MASK(RcvMinPktLenErr))\r\nstrlcat(buf, "rminpktlen ", blen);\r\nif (err & ERR_MASK(SendMinPktLenErr))\r\nstrlcat(buf, "sminpktlen ", blen);\r\nif (err & ERR_MASK(RcvFormatErr))\r\nstrlcat(buf, "rformaterr ", blen);\r\nif (err & ERR_MASK(RcvUnsupportedVLErr))\r\nstrlcat(buf, "runsupvl ", blen);\r\nif (err & ERR_MASK(RcvUnexpectedCharErr))\r\nstrlcat(buf, "runexpchar ", blen);\r\nif (err & ERR_MASK(RcvIBFlowErr))\r\nstrlcat(buf, "ribflow ", blen);\r\nif (err & ERR_MASK(SendUnderRunErr))\r\nstrlcat(buf, "sunderrun ", blen);\r\nif (err & ERR_MASK(SendPioArmLaunchErr))\r\nstrlcat(buf, "spioarmlaunch ", blen);\r\nif (err & ERR_MASK(SendUnexpectedPktNumErr))\r\nstrlcat(buf, "sunexperrpktnum ", blen);\r\nif (err & ERR_MASK(SendDroppedSmpPktErr))\r\nstrlcat(buf, "sdroppedsmppkt ", blen);\r\nif (err & ERR_MASK(SendMaxPktLenErr))\r\nstrlcat(buf, "smaxpktlen ", blen);\r\nif (err & ERR_MASK(SendUnsupportedVLErr))\r\nstrlcat(buf, "sunsupVL ", blen);\r\nif (err & ERR_MASK(InvalidAddrErr))\r\nstrlcat(buf, "invalidaddr ", blen);\r\nif (err & ERR_MASK(RcvEgrFullErr))\r\nstrlcat(buf, "rcvegrfull ", blen);\r\nif (err & ERR_MASK(RcvHdrFullErr))\r\nstrlcat(buf, "rcvhdrfull ", blen);\r\nif (err & ERR_MASK(IBStatusChanged))\r\nstrlcat(buf, "ibcstatuschg ", blen);\r\nif (err & ERR_MASK(RcvIBLostLinkErr))\r\nstrlcat(buf, "riblostlink ", blen);\r\nif (err & ERR_MASK(HardwareErr))\r\nstrlcat(buf, "hardware ", blen);\r\nif (err & ERR_MASK(ResetNegated))\r\nstrlcat(buf, "reset ", blen);\r\ndone:\r\nreturn iserr;\r\n}\r\nstatic void qib_disarm_6120_senderrbufs(struct qib_pportdata *ppd)\r\n{\r\nunsigned long sbuf[2];\r\nstruct qib_devdata *dd = ppd->dd;\r\nsbuf[0] = qib_read_kreg64(dd, kr_sendbuffererror);\r\nsbuf[1] = qib_read_kreg64(dd, kr_sendbuffererror + 1);\r\nif (sbuf[0] || sbuf[1])\r\nqib_disarm_piobufs_set(dd, sbuf,\r\ndd->piobcnt2k + dd->piobcnt4k);\r\n}\r\nstatic int chk_6120_linkrecovery(struct qib_devdata *dd, u64 ibcs)\r\n{\r\nint ret = 1;\r\nu32 ibstate = qib_6120_iblink_state(ibcs);\r\nu32 linkrecov = read_6120_creg32(dd, cr_iblinkerrrecov);\r\nif (linkrecov != dd->cspec->lastlinkrecov) {\r\ndd->cspec->lastlinkrecov = 0;\r\nqib_set_linkstate(dd->pport, QIB_IB_LINKDOWN);\r\nret = 0;\r\n}\r\nif (ibstate == IB_PORT_ACTIVE)\r\ndd->cspec->lastlinkrecov =\r\nread_6120_creg32(dd, cr_iblinkerrrecov);\r\nreturn ret;\r\n}\r\nstatic void handle_6120_errors(struct qib_devdata *dd, u64 errs)\r\n{\r\nchar *msg;\r\nu64 ignore_this_time = 0;\r\nu64 iserr = 0;\r\nint log_idx;\r\nstruct qib_pportdata *ppd = dd->pport;\r\nu64 mask;\r\nerrs &= dd->cspec->errormask;\r\nmsg = dd->cspec->emsgbuf;\r\nif (errs & ERR_MASK(HardwareErr))\r\nqib_handle_6120_hwerrors(dd, msg, sizeof(dd->cspec->emsgbuf));\r\nelse\r\nfor (log_idx = 0; log_idx < QIB_EEP_LOG_CNT; ++log_idx)\r\nif (errs & dd->eep_st_masks[log_idx].errs_to_log)\r\nqib_inc_eeprom_err(dd, log_idx, 1);\r\nif (errs & ~IB_E_BITSEXTANT)\r\nqib_dev_err(dd,\r\n"error interrupt with unknown errors %llx set\n",\r\n(unsigned long long) (errs & ~IB_E_BITSEXTANT));\r\nif (errs & E_SUM_ERRS) {\r\nqib_disarm_6120_senderrbufs(ppd);\r\nif ((errs & E_SUM_LINK_PKTERRS) &&\r\n!(ppd->lflags & QIBL_LINKACTIVE)) {\r\nignore_this_time = errs & E_SUM_LINK_PKTERRS;\r\n}\r\n} else if ((errs & E_SUM_LINK_PKTERRS) &&\r\n!(ppd->lflags & QIBL_LINKACTIVE)) {\r\nignore_this_time = errs & E_SUM_LINK_PKTERRS;\r\n}\r\nqib_write_kreg(dd, kr_errclear, errs);\r\nerrs &= ~ignore_this_time;\r\nif (!errs)\r\ngoto done;\r\nmask = ERR_MASK(IBStatusChanged) | ERR_MASK(RcvEgrFullErr) |\r\nERR_MASK(RcvHdrFullErr) | ERR_MASK(HardwareErr);\r\nqib_decode_6120_err(dd, msg, sizeof(dd->cspec->emsgbuf), errs & ~mask);\r\nif (errs & E_SUM_PKTERRS)\r\nqib_stats.sps_rcverrs++;\r\nif (errs & E_SUM_ERRS)\r\nqib_stats.sps_txerrs++;\r\niserr = errs & ~(E_SUM_PKTERRS | QLOGIC_IB_E_PKTERRS);\r\nif (errs & ERR_MASK(IBStatusChanged)) {\r\nu64 ibcs = qib_read_kreg64(dd, kr_ibcstatus);\r\nu32 ibstate = qib_6120_iblink_state(ibcs);\r\nint handle = 1;\r\nif (ibstate != IB_PORT_INIT && dd->cspec->lastlinkrecov)\r\nhandle = chk_6120_linkrecovery(dd, ibcs);\r\nif (handle && qib_6120_phys_portstate(ibcs) ==\r\nIB_PHYSPORTSTATE_LINK_ERR_RECOVER)\r\nhandle = 0;\r\nif (handle)\r\nqib_handle_e_ibstatuschanged(ppd, ibcs);\r\n}\r\nif (errs & ERR_MASK(ResetNegated)) {\r\nqib_dev_err(dd,\r\n"Got reset, requires re-init (unload and reload driver)\n");\r\ndd->flags &= ~QIB_INITTED;\r\n*dd->devstatusp |= QIB_STATUS_HWERROR;\r\n*dd->pport->statusp &= ~QIB_STATUS_IB_CONF;\r\n}\r\nif (*msg && iserr)\r\nqib_dev_porterr(dd, ppd->port, "%s error\n", msg);\r\nif (ppd->state_wanted & ppd->lflags)\r\nwake_up_interruptible(&ppd->state_wait);\r\nif (errs & (ERR_MASK(RcvEgrFullErr) | ERR_MASK(RcvHdrFullErr))) {\r\nqib_handle_urcv(dd, ~0U);\r\nif (errs & ERR_MASK(RcvEgrFullErr))\r\nqib_stats.sps_buffull++;\r\nelse\r\nqib_stats.sps_hdrfull++;\r\n}\r\ndone:\r\nreturn;\r\n}\r\nstatic void qib_6120_init_hwerrors(struct qib_devdata *dd)\r\n{\r\nu64 val;\r\nu64 extsval;\r\nextsval = qib_read_kreg64(dd, kr_extstatus);\r\nif (!(extsval & QLOGIC_IB_EXTS_MEMBIST_ENDTEST))\r\nqib_dev_err(dd, "MemBIST did not complete!\n");\r\nval = ~0ULL;\r\nif (dd->minrev < 2) {\r\nval &= ~QLOGIC_IB_HWE_PCIEBUSPARITYRADM;\r\n}\r\nval &= ~TXEMEMPARITYERR_PIOBUF;\r\ndd->cspec->hwerrmask = val;\r\nqib_write_kreg(dd, kr_hwerrclear, ~HWE_MASK(PowerOnBISTFailed));\r\nqib_write_kreg(dd, kr_hwerrmask, dd->cspec->hwerrmask);\r\nqib_write_kreg(dd, kr_errclear, ~0ULL);\r\nqib_write_kreg(dd, kr_errmask, ~0ULL);\r\ndd->cspec->errormask = qib_read_kreg64(dd, kr_errmask);\r\nqib_write_kreg(dd, kr_intclear, ~0ULL);\r\nqib_write_kreg(dd, kr_rcvbthqp,\r\ndd->qpn_mask << (QIB_6120_RcvBTHQP_BTHQP_Mask_LSB - 1) |\r\nQIB_KD_QP);\r\n}\r\nstatic void qib_set_6120_armlaunch(struct qib_devdata *dd, u32 enable)\r\n{\r\nif (enable) {\r\nqib_write_kreg(dd, kr_errclear,\r\nERR_MASK(SendPioArmLaunchErr));\r\ndd->cspec->errormask |= ERR_MASK(SendPioArmLaunchErr);\r\n} else\r\ndd->cspec->errormask &= ~ERR_MASK(SendPioArmLaunchErr);\r\nqib_write_kreg(dd, kr_errmask, dd->cspec->errormask);\r\n}\r\nstatic void qib_set_ib_6120_lstate(struct qib_pportdata *ppd, u16 linkcmd,\r\nu16 linitcmd)\r\n{\r\nu64 mod_wd;\r\nstruct qib_devdata *dd = ppd->dd;\r\nunsigned long flags;\r\nif (linitcmd == QLOGIC_IB_IBCC_LINKINITCMD_DISABLE) {\r\nspin_lock_irqsave(&ppd->lflags_lock, flags);\r\nppd->lflags |= QIBL_IB_LINK_DISABLED;\r\nspin_unlock_irqrestore(&ppd->lflags_lock, flags);\r\n} else if (linitcmd || linkcmd == QLOGIC_IB_IBCC_LINKCMD_DOWN) {\r\nspin_lock_irqsave(&ppd->lflags_lock, flags);\r\nppd->lflags &= ~QIBL_IB_LINK_DISABLED;\r\nspin_unlock_irqrestore(&ppd->lflags_lock, flags);\r\n}\r\nmod_wd = (linkcmd << QLOGIC_IB_IBCC_LINKCMD_SHIFT) |\r\n(linitcmd << QLOGIC_IB_IBCC_LINKINITCMD_SHIFT);\r\nqib_write_kreg(dd, kr_ibcctrl, dd->cspec->ibcctrl | mod_wd);\r\nqib_write_kreg(dd, kr_scratch, 0);\r\n}\r\nstatic int qib_6120_bringup_serdes(struct qib_pportdata *ppd)\r\n{\r\nstruct qib_devdata *dd = ppd->dd;\r\nu64 val, config1, prev_val, hwstat, ibc;\r\ndd->control &= ~QLOGIC_IB_C_LINKENABLE;\r\nqib_write_kreg(dd, kr_control, 0ULL);\r\ndd->cspec->ibdeltainprog = 1;\r\ndd->cspec->ibsymsnap = read_6120_creg32(dd, cr_ibsymbolerr);\r\ndd->cspec->iblnkerrsnap = read_6120_creg32(dd, cr_iblinkerrrecov);\r\nibc = 0x5ULL << SYM_LSB(IBCCtrl, FlowCtrlWaterMark);\r\nibc |= 0x3ULL << SYM_LSB(IBCCtrl, FlowCtrlPeriod);\r\ndd->cspec->lli_thresh = 0xf;\r\nibc |= (u64) dd->cspec->lli_thresh << SYM_LSB(IBCCtrl, PhyerrThreshold);\r\nibc |= 4ULL << SYM_LSB(IBCCtrl, CreditScale);\r\nibc |= 0xfULL << SYM_LSB(IBCCtrl, OverrunThreshold);\r\nibc |= ((u64)(ppd->ibmaxlen >> 2) + 1) << SYM_LSB(IBCCtrl, MaxPktLen);\r\ndd->cspec->ibcctrl = ibc;\r\nval = dd->cspec->ibcctrl | (QLOGIC_IB_IBCC_LINKINITCMD_DISABLE <<\r\nQLOGIC_IB_IBCC_LINKINITCMD_SHIFT);\r\nqib_write_kreg(dd, kr_ibcctrl, val);\r\nval = qib_read_kreg64(dd, kr_serdes_cfg0);\r\nconfig1 = qib_read_kreg64(dd, kr_serdes_cfg1);\r\nval |= SYM_MASK(SerdesCfg0, ResetPLL) |\r\nSYM_MASK(SerdesCfg0, RxDetEnX) |\r\n(SYM_MASK(SerdesCfg0, L1PwrDnA) |\r\nSYM_MASK(SerdesCfg0, L1PwrDnB) |\r\nSYM_MASK(SerdesCfg0, L1PwrDnC) |\r\nSYM_MASK(SerdesCfg0, L1PwrDnD));\r\nqib_write_kreg(dd, kr_serdes_cfg0, val);\r\nqib_read_kreg64(dd, kr_scratch);\r\nudelay(5);\r\nval &= ~(SYM_MASK(SerdesCfg0, RxDetEnX) |\r\nSYM_MASK(SerdesCfg0, ResetPLL) |\r\n(SYM_MASK(SerdesCfg0, L1PwrDnA) |\r\nSYM_MASK(SerdesCfg0, L1PwrDnB) |\r\nSYM_MASK(SerdesCfg0, L1PwrDnC) |\r\nSYM_MASK(SerdesCfg0, L1PwrDnD)));\r\nval |= (SYM_MASK(SerdesCfg0, ResetA) |\r\nSYM_MASK(SerdesCfg0, ResetB) |\r\nSYM_MASK(SerdesCfg0, ResetC) |\r\nSYM_MASK(SerdesCfg0, ResetD)) |\r\nSYM_MASK(SerdesCfg0, TxIdeEnX);\r\nqib_write_kreg(dd, kr_serdes_cfg0, val);\r\n(void) qib_read_kreg64(dd, kr_scratch);\r\nudelay(15);\r\nval &= ~((SYM_MASK(SerdesCfg0, ResetA) |\r\nSYM_MASK(SerdesCfg0, ResetB) |\r\nSYM_MASK(SerdesCfg0, ResetC) |\r\nSYM_MASK(SerdesCfg0, ResetD)) |\r\nSYM_MASK(SerdesCfg0, TxIdeEnX));\r\nqib_write_kreg(dd, kr_serdes_cfg0, val);\r\n(void) qib_read_kreg64(dd, kr_scratch);\r\nval = qib_read_kreg64(dd, kr_xgxs_cfg);\r\nprev_val = val;\r\nif (val & QLOGIC_IB_XGXS_RESET)\r\nval &= ~QLOGIC_IB_XGXS_RESET;\r\nif (SYM_FIELD(val, XGXSCfg, polarity_inv) != ppd->rx_pol_inv) {\r\nval &= ~SYM_MASK(XGXSCfg, polarity_inv);\r\nval |= (u64)ppd->rx_pol_inv << SYM_LSB(XGXSCfg, polarity_inv);\r\n}\r\nif (val != prev_val)\r\nqib_write_kreg(dd, kr_xgxs_cfg, val);\r\nval = qib_read_kreg64(dd, kr_serdes_cfg0);\r\nconfig1 &= ~0x0ffffffff00ULL;\r\nconfig1 |= 0x00000000000ULL;\r\nconfig1 |= 0x0cccc000000ULL;\r\nqib_write_kreg(dd, kr_serdes_cfg1, config1);\r\nppd->guid = dd->base_guid;\r\nhwstat = qib_read_kreg64(dd, kr_hwerrstatus);\r\nif (hwstat) {\r\nqib_write_kreg(dd, kr_hwerrclear, hwstat);\r\nqib_write_kreg(dd, kr_errclear, ERR_MASK(HardwareErr));\r\n}\r\ndd->control |= QLOGIC_IB_C_LINKENABLE;\r\ndd->control &= ~QLOGIC_IB_C_FREEZEMODE;\r\nqib_write_kreg(dd, kr_control, dd->control);\r\nreturn 0;\r\n}\r\nstatic void qib_6120_quiet_serdes(struct qib_pportdata *ppd)\r\n{\r\nstruct qib_devdata *dd = ppd->dd;\r\nu64 val;\r\nqib_set_ib_6120_lstate(ppd, 0, QLOGIC_IB_IBCC_LINKINITCMD_DISABLE);\r\ndd->control &= ~QLOGIC_IB_C_LINKENABLE;\r\nqib_write_kreg(dd, kr_control,\r\ndd->control | QLOGIC_IB_C_FREEZEMODE);\r\nif (dd->cspec->ibsymdelta || dd->cspec->iblnkerrdelta ||\r\ndd->cspec->ibdeltainprog) {\r\nu64 diagc;\r\ndiagc = qib_read_kreg64(dd, kr_hwdiagctrl);\r\nqib_write_kreg(dd, kr_hwdiagctrl,\r\ndiagc | SYM_MASK(HwDiagCtrl, CounterWrEnable));\r\nif (dd->cspec->ibsymdelta || dd->cspec->ibdeltainprog) {\r\nval = read_6120_creg32(dd, cr_ibsymbolerr);\r\nif (dd->cspec->ibdeltainprog)\r\nval -= val - dd->cspec->ibsymsnap;\r\nval -= dd->cspec->ibsymdelta;\r\nwrite_6120_creg(dd, cr_ibsymbolerr, val);\r\n}\r\nif (dd->cspec->iblnkerrdelta || dd->cspec->ibdeltainprog) {\r\nval = read_6120_creg32(dd, cr_iblinkerrrecov);\r\nif (dd->cspec->ibdeltainprog)\r\nval -= val - dd->cspec->iblnkerrsnap;\r\nval -= dd->cspec->iblnkerrdelta;\r\nwrite_6120_creg(dd, cr_iblinkerrrecov, val);\r\n}\r\nqib_write_kreg(dd, kr_hwdiagctrl, diagc);\r\n}\r\nval = qib_read_kreg64(dd, kr_serdes_cfg0);\r\nval |= SYM_MASK(SerdesCfg0, TxIdeEnX);\r\nqib_write_kreg(dd, kr_serdes_cfg0, val);\r\n}\r\nstatic void qib_6120_setup_setextled(struct qib_pportdata *ppd, u32 on)\r\n{\r\nu64 extctl, val, lst, ltst;\r\nunsigned long flags;\r\nstruct qib_devdata *dd = ppd->dd;\r\nif (dd->diag_client)\r\nreturn;\r\nif (ppd->led_override) {\r\nltst = (ppd->led_override & QIB_LED_PHYS) ?\r\nIB_PHYSPORTSTATE_LINKUP : IB_PHYSPORTSTATE_DISABLED,\r\nlst = (ppd->led_override & QIB_LED_LOG) ?\r\nIB_PORT_ACTIVE : IB_PORT_DOWN;\r\n} else if (on) {\r\nval = qib_read_kreg64(dd, kr_ibcstatus);\r\nltst = qib_6120_phys_portstate(val);\r\nlst = qib_6120_iblink_state(val);\r\n} else {\r\nltst = 0;\r\nlst = 0;\r\n}\r\nspin_lock_irqsave(&dd->cspec->gpio_lock, flags);\r\nextctl = dd->cspec->extctrl & ~(SYM_MASK(EXTCtrl, LEDPriPortGreenOn) |\r\nSYM_MASK(EXTCtrl, LEDPriPortYellowOn));\r\nif (ltst == IB_PHYSPORTSTATE_LINKUP)\r\nextctl |= SYM_MASK(EXTCtrl, LEDPriPortYellowOn);\r\nif (lst == IB_PORT_ACTIVE)\r\nextctl |= SYM_MASK(EXTCtrl, LEDPriPortGreenOn);\r\ndd->cspec->extctrl = extctl;\r\nqib_write_kreg(dd, kr_extctrl, extctl);\r\nspin_unlock_irqrestore(&dd->cspec->gpio_lock, flags);\r\n}\r\nstatic void qib_6120_free_irq(struct qib_devdata *dd)\r\n{\r\nif (dd->cspec->irq) {\r\nfree_irq(dd->cspec->irq, dd);\r\ndd->cspec->irq = 0;\r\n}\r\nqib_nomsi(dd);\r\n}\r\nstatic void qib_6120_setup_cleanup(struct qib_devdata *dd)\r\n{\r\nqib_6120_free_irq(dd);\r\nkfree(dd->cspec->cntrs);\r\nkfree(dd->cspec->portcntrs);\r\nif (dd->cspec->dummy_hdrq) {\r\ndma_free_coherent(&dd->pcidev->dev,\r\nALIGN(dd->rcvhdrcnt *\r\ndd->rcvhdrentsize *\r\nsizeof(u32), PAGE_SIZE),\r\ndd->cspec->dummy_hdrq,\r\ndd->cspec->dummy_hdrq_phys);\r\ndd->cspec->dummy_hdrq = NULL;\r\n}\r\n}\r\nstatic void qib_wantpiobuf_6120_intr(struct qib_devdata *dd, u32 needint)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&dd->sendctrl_lock, flags);\r\nif (needint)\r\ndd->sendctrl |= SYM_MASK(SendCtrl, PIOIntBufAvail);\r\nelse\r\ndd->sendctrl &= ~SYM_MASK(SendCtrl, PIOIntBufAvail);\r\nqib_write_kreg(dd, kr_sendctrl, dd->sendctrl);\r\nqib_write_kreg(dd, kr_scratch, 0ULL);\r\nspin_unlock_irqrestore(&dd->sendctrl_lock, flags);\r\n}\r\nstatic noinline void unlikely_6120_intr(struct qib_devdata *dd, u64 istat)\r\n{\r\nif (unlikely(istat & ~QLOGIC_IB_I_BITSEXTANT))\r\nqib_dev_err(dd, "interrupt with unknown interrupts %Lx set\n",\r\nistat & ~QLOGIC_IB_I_BITSEXTANT);\r\nif (istat & QLOGIC_IB_I_ERROR) {\r\nu64 estat = 0;\r\nqib_stats.sps_errints++;\r\nestat = qib_read_kreg64(dd, kr_errstatus);\r\nif (!estat)\r\nqib_devinfo(dd->pcidev,\r\n"error interrupt (%Lx), but no error bits set!\n",\r\nistat);\r\nhandle_6120_errors(dd, estat);\r\n}\r\nif (istat & QLOGIC_IB_I_GPIO) {\r\nu32 gpiostatus;\r\nu32 to_clear = 0;\r\ngpiostatus = qib_read_kreg32(dd, kr_gpio_status);\r\nif (gpiostatus & GPIO_ERRINTR_MASK) {\r\nto_clear |= (gpiostatus & GPIO_ERRINTR_MASK);\r\nif (gpiostatus & (1 << GPIO_RXUVL_BIT))\r\ndd->cspec->rxfc_unsupvl_errs++;\r\nif (gpiostatus & (1 << GPIO_OVRUN_BIT))\r\ndd->cspec->overrun_thresh_errs++;\r\nif (gpiostatus & (1 << GPIO_LLI_BIT))\r\ndd->cspec->lli_errs++;\r\ngpiostatus &= ~GPIO_ERRINTR_MASK;\r\n}\r\nif (gpiostatus) {\r\nconst u32 mask = qib_read_kreg32(dd, kr_gpio_mask);\r\nif (mask & gpiostatus) {\r\nto_clear |= (gpiostatus & mask);\r\ndd->cspec->gpio_mask &= ~(gpiostatus & mask);\r\nqib_write_kreg(dd, kr_gpio_mask,\r\ndd->cspec->gpio_mask);\r\n}\r\n}\r\nif (to_clear)\r\nqib_write_kreg(dd, kr_gpio_clear, (u64) to_clear);\r\n}\r\n}\r\nstatic irqreturn_t qib_6120intr(int irq, void *data)\r\n{\r\nstruct qib_devdata *dd = data;\r\nirqreturn_t ret;\r\nu32 istat, ctxtrbits, rmask, crcs = 0;\r\nunsigned i;\r\nif ((dd->flags & (QIB_PRESENT | QIB_BADINTR)) != QIB_PRESENT) {\r\nret = IRQ_HANDLED;\r\ngoto bail;\r\n}\r\nistat = qib_read_kreg32(dd, kr_intstatus);\r\nif (unlikely(!istat)) {\r\nret = IRQ_NONE;\r\ngoto bail;\r\n}\r\nif (unlikely(istat == -1)) {\r\nqib_bad_intrstatus(dd);\r\nret = IRQ_NONE;\r\ngoto bail;\r\n}\r\nthis_cpu_inc(*dd->int_counter);\r\nif (unlikely(istat & (~QLOGIC_IB_I_BITSEXTANT |\r\nQLOGIC_IB_I_GPIO | QLOGIC_IB_I_ERROR)))\r\nunlikely_6120_intr(dd, istat);\r\nqib_write_kreg(dd, kr_intclear, istat);\r\nctxtrbits = istat &\r\n((QLOGIC_IB_I_RCVAVAIL_MASK << QLOGIC_IB_I_RCVAVAIL_SHIFT) |\r\n(QLOGIC_IB_I_RCVURG_MASK << QLOGIC_IB_I_RCVURG_SHIFT));\r\nif (ctxtrbits) {\r\nrmask = (1U << QLOGIC_IB_I_RCVAVAIL_SHIFT) |\r\n(1U << QLOGIC_IB_I_RCVURG_SHIFT);\r\nfor (i = 0; i < dd->first_user_ctxt; i++) {\r\nif (ctxtrbits & rmask) {\r\nctxtrbits &= ~rmask;\r\ncrcs += qib_kreceive(dd->rcd[i],\r\n&dd->cspec->lli_counter,\r\nNULL);\r\n}\r\nrmask <<= 1;\r\n}\r\nif (crcs) {\r\nu32 cntr = dd->cspec->lli_counter;\r\ncntr += crcs;\r\nif (cntr) {\r\nif (cntr > dd->cspec->lli_thresh) {\r\ndd->cspec->lli_counter = 0;\r\ndd->cspec->lli_errs++;\r\n} else\r\ndd->cspec->lli_counter += cntr;\r\n}\r\n}\r\nif (ctxtrbits) {\r\nctxtrbits =\r\n(ctxtrbits >> QLOGIC_IB_I_RCVAVAIL_SHIFT) |\r\n(ctxtrbits >> QLOGIC_IB_I_RCVURG_SHIFT);\r\nqib_handle_urcv(dd, ctxtrbits);\r\n}\r\n}\r\nif ((istat & QLOGIC_IB_I_SPIOBUFAVAIL) && (dd->flags & QIB_INITTED))\r\nqib_ib_piobufavail(dd);\r\nret = IRQ_HANDLED;\r\nbail:\r\nreturn ret;\r\n}\r\nstatic void qib_setup_6120_interrupt(struct qib_devdata *dd)\r\n{\r\nif (SYM_FIELD(dd->revision, Revision_R,\r\nChipRevMinor) > 1) {\r\ndd->cspec->gpio_mask |= GPIO_ERRINTR_MASK;\r\nqib_write_kreg(dd, kr_gpio_mask, dd->cspec->gpio_mask);\r\n}\r\nif (!dd->cspec->irq)\r\nqib_dev_err(dd,\r\n"irq is 0, BIOS error? Interrupts won't work\n");\r\nelse {\r\nint ret;\r\nret = request_irq(dd->cspec->irq, qib_6120intr, 0,\r\nQIB_DRV_NAME, dd);\r\nif (ret)\r\nqib_dev_err(dd,\r\n"Couldn't setup interrupt (irq=%d): %d\n",\r\ndd->cspec->irq, ret);\r\n}\r\n}\r\nstatic void pe_boardname(struct qib_devdata *dd)\r\n{\r\nchar *n;\r\nu32 boardid, namelen;\r\nboardid = SYM_FIELD(dd->revision, Revision,\r\nBoardID);\r\nswitch (boardid) {\r\ncase 2:\r\nn = "InfiniPath_QLE7140";\r\nbreak;\r\ndefault:\r\nqib_dev_err(dd, "Unknown 6120 board with ID %u\n", boardid);\r\nn = "Unknown_InfiniPath_6120";\r\nbreak;\r\n}\r\nnamelen = strlen(n) + 1;\r\ndd->boardname = kmalloc(namelen, GFP_KERNEL);\r\nif (!dd->boardname)\r\nqib_dev_err(dd, "Failed allocation for board name: %s\n", n);\r\nelse\r\nsnprintf(dd->boardname, namelen, "%s", n);\r\nif (dd->majrev != 4 || !dd->minrev || dd->minrev > 2)\r\nqib_dev_err(dd,\r\n"Unsupported InfiniPath hardware revision %u.%u!\n",\r\ndd->majrev, dd->minrev);\r\nsnprintf(dd->boardversion, sizeof(dd->boardversion),\r\n"ChipABI %u.%u, %s, InfiniPath%u %u.%u, SW Compat %u\n",\r\nQIB_CHIP_VERS_MAJ, QIB_CHIP_VERS_MIN, dd->boardname,\r\n(unsigned)SYM_FIELD(dd->revision, Revision_R, Arch),\r\ndd->majrev, dd->minrev,\r\n(unsigned)SYM_FIELD(dd->revision, Revision_R, SW));\r\n}\r\nstatic int qib_6120_setup_reset(struct qib_devdata *dd)\r\n{\r\nu64 val;\r\nint i;\r\nint ret;\r\nu16 cmdval;\r\nu8 int_line, clinesz;\r\nqib_pcie_getcmd(dd, &cmdval, &int_line, &clinesz);\r\nqib_dev_err(dd, "Resetting InfiniPath unit %u\n", dd->unit);\r\nqib_6120_set_intr_state(dd, 0);\r\ndd->cspec->ibdeltainprog = 0;\r\ndd->cspec->ibsymdelta = 0;\r\ndd->cspec->iblnkerrdelta = 0;\r\ndd->flags &= ~(QIB_INITTED | QIB_PRESENT);\r\ndd->z_int_counter = qib_int_counter(dd);\r\nval = dd->control | QLOGIC_IB_C_RESET;\r\nwriteq(val, &dd->kregbase[kr_control]);\r\nmb();\r\nfor (i = 1; i <= 5; i++) {\r\nmsleep(1000 + (1 + i) * 2000);\r\nqib_pcie_reenable(dd, cmdval, int_line, clinesz);\r\nval = readq(&dd->kregbase[kr_revision]);\r\nif (val == dd->revision) {\r\ndd->flags |= QIB_PRESENT;\r\nret = qib_reinit_intr(dd);\r\ngoto bail;\r\n}\r\n}\r\nret = 0;\r\nbail:\r\nif (ret) {\r\nif (qib_pcie_params(dd, dd->lbus_width, NULL, NULL))\r\nqib_dev_err(dd,\r\n"Reset failed to setup PCIe or interrupts; continuing anyway\n");\r\nqib_6120_init_hwerrors(dd);\r\nqib_write_kreg(dd, kr_gpio_mask, dd->cspec->gpio_mask);\r\nqib_6120_init_hwerrors(dd);\r\n}\r\nreturn ret;\r\n}\r\nstatic void qib_6120_put_tid(struct qib_devdata *dd, u64 __iomem *tidptr,\r\nu32 type, unsigned long pa)\r\n{\r\nu32 __iomem *tidp32 = (u32 __iomem *)tidptr;\r\nunsigned long flags;\r\nint tidx;\r\nspinlock_t *tidlockp;\r\nif (!dd->kregbase)\r\nreturn;\r\nif (pa != dd->tidinvalid) {\r\nif (pa & ((1U << 11) - 1)) {\r\nqib_dev_err(dd, "Physaddr %lx not 2KB aligned!\n",\r\npa);\r\nreturn;\r\n}\r\npa >>= 11;\r\nif (pa & ~QLOGIC_IB_RT_ADDR_MASK) {\r\nqib_dev_err(dd,\r\n"Physical page address 0x%lx larger than supported\n",\r\npa);\r\nreturn;\r\n}\r\nif (type == RCVHQ_RCV_TYPE_EAGER)\r\npa |= dd->tidtemplate;\r\nelse\r\npa |= 2 << 29;\r\n}\r\ntidx = tidptr - dd->egrtidbase;\r\ntidlockp = (type == RCVHQ_RCV_TYPE_EAGER && tidx < dd->rcvhdrcnt)\r\n? &dd->cspec->kernel_tid_lock : &dd->cspec->user_tid_lock;\r\nspin_lock_irqsave(tidlockp, flags);\r\nqib_write_kreg(dd, kr_scratch, 0xfeeddeaf);\r\nwritel(pa, tidp32);\r\nqib_write_kreg(dd, kr_scratch, 0xdeadbeef);\r\nmmiowb();\r\nspin_unlock_irqrestore(tidlockp, flags);\r\n}\r\nstatic void qib_6120_put_tid_2(struct qib_devdata *dd, u64 __iomem *tidptr,\r\nu32 type, unsigned long pa)\r\n{\r\nu32 __iomem *tidp32 = (u32 __iomem *)tidptr;\r\nu32 tidx;\r\nif (!dd->kregbase)\r\nreturn;\r\nif (pa != dd->tidinvalid) {\r\nif (pa & ((1U << 11) - 1)) {\r\nqib_dev_err(dd, "Physaddr %lx not 2KB aligned!\n",\r\npa);\r\nreturn;\r\n}\r\npa >>= 11;\r\nif (pa & ~QLOGIC_IB_RT_ADDR_MASK) {\r\nqib_dev_err(dd,\r\n"Physical page address 0x%lx larger than supported\n",\r\npa);\r\nreturn;\r\n}\r\nif (type == RCVHQ_RCV_TYPE_EAGER)\r\npa |= dd->tidtemplate;\r\nelse\r\npa |= 2 << 29;\r\n}\r\ntidx = tidptr - dd->egrtidbase;\r\nwritel(pa, tidp32);\r\nmmiowb();\r\n}\r\nstatic void qib_6120_clear_tids(struct qib_devdata *dd,\r\nstruct qib_ctxtdata *rcd)\r\n{\r\nu64 __iomem *tidbase;\r\nunsigned long tidinv;\r\nu32 ctxt;\r\nint i;\r\nif (!dd->kregbase || !rcd)\r\nreturn;\r\nctxt = rcd->ctxt;\r\ntidinv = dd->tidinvalid;\r\ntidbase = (u64 __iomem *)\r\n((char __iomem *)(dd->kregbase) +\r\ndd->rcvtidbase +\r\nctxt * dd->rcvtidcnt * sizeof(*tidbase));\r\nfor (i = 0; i < dd->rcvtidcnt; i++)\r\ndd->f_put_tid(dd, &tidbase[i], RCVHQ_RCV_TYPE_EXPECTED,\r\ntidinv);\r\ntidbase = (u64 __iomem *)\r\n((char __iomem *)(dd->kregbase) +\r\ndd->rcvegrbase +\r\nrcd->rcvegr_tid_base * sizeof(*tidbase));\r\nfor (i = 0; i < rcd->rcvegrcnt; i++)\r\ndd->f_put_tid(dd, &tidbase[i], RCVHQ_RCV_TYPE_EAGER,\r\ntidinv);\r\n}\r\nstatic void qib_6120_tidtemplate(struct qib_devdata *dd)\r\n{\r\nu32 egrsize = dd->rcvegrbufsize;\r\nif (egrsize == 2048)\r\ndd->tidtemplate = 1U << 29;\r\nelse if (egrsize == 4096)\r\ndd->tidtemplate = 2U << 29;\r\ndd->tidinvalid = 0;\r\n}\r\nstatic int qib_6120_get_base_info(struct qib_ctxtdata *rcd,\r\nstruct qib_base_info *kinfo)\r\n{\r\nif (qib_unordered_wc())\r\nkinfo->spi_runtime_flags |= QIB_RUNTIME_FORCE_WC_ORDER;\r\nkinfo->spi_runtime_flags |= QIB_RUNTIME_PCIE |\r\nQIB_RUNTIME_FORCE_PIOAVAIL | QIB_RUNTIME_PIO_REGSWAPPED;\r\nreturn 0;\r\n}\r\nstatic struct qib_message_header *\r\nqib_6120_get_msgheader(struct qib_devdata *dd, __le32 *rhf_addr)\r\n{\r\nreturn (struct qib_message_header *)\r\n&rhf_addr[sizeof(u64) / sizeof(u32)];\r\n}\r\nstatic void qib_6120_config_ctxts(struct qib_devdata *dd)\r\n{\r\ndd->ctxtcnt = qib_read_kreg32(dd, kr_portcnt);\r\nif (qib_n_krcv_queues > 1) {\r\ndd->first_user_ctxt = qib_n_krcv_queues * dd->num_pports;\r\nif (dd->first_user_ctxt > dd->ctxtcnt)\r\ndd->first_user_ctxt = dd->ctxtcnt;\r\ndd->qpn_mask = dd->first_user_ctxt <= 2 ? 2 : 6;\r\n} else\r\ndd->first_user_ctxt = dd->num_pports;\r\ndd->n_krcv_queues = dd->first_user_ctxt;\r\n}\r\nstatic void qib_update_6120_usrhead(struct qib_ctxtdata *rcd, u64 hd,\r\nu32 updegr, u32 egrhd, u32 npkts)\r\n{\r\nif (updegr)\r\nqib_write_ureg(rcd->dd, ur_rcvegrindexhead, egrhd, rcd->ctxt);\r\nmmiowb();\r\nqib_write_ureg(rcd->dd, ur_rcvhdrhead, hd, rcd->ctxt);\r\nmmiowb();\r\n}\r\nstatic u32 qib_6120_hdrqempty(struct qib_ctxtdata *rcd)\r\n{\r\nu32 head, tail;\r\nhead = qib_read_ureg32(rcd->dd, ur_rcvhdrhead, rcd->ctxt);\r\nif (rcd->rcvhdrtail_kvaddr)\r\ntail = qib_get_rcvhdrtail(rcd);\r\nelse\r\ntail = qib_read_ureg32(rcd->dd, ur_rcvhdrtail, rcd->ctxt);\r\nreturn head == tail;\r\n}\r\nstatic void alloc_dummy_hdrq(struct qib_devdata *dd)\r\n{\r\ndd->cspec->dummy_hdrq = dma_alloc_coherent(&dd->pcidev->dev,\r\ndd->rcd[0]->rcvhdrq_size,\r\n&dd->cspec->dummy_hdrq_phys,\r\nGFP_ATOMIC | __GFP_COMP);\r\nif (!dd->cspec->dummy_hdrq) {\r\nqib_devinfo(dd->pcidev, "Couldn't allocate dummy hdrq\n");\r\ndd->cspec->dummy_hdrq_phys = 0UL;\r\n}\r\n}\r\nstatic void rcvctrl_6120_mod(struct qib_pportdata *ppd, unsigned int op,\r\nint ctxt)\r\n{\r\nstruct qib_devdata *dd = ppd->dd;\r\nu64 mask, val;\r\nunsigned long flags;\r\nspin_lock_irqsave(&dd->cspec->rcvmod_lock, flags);\r\nif (op & QIB_RCVCTRL_TAILUPD_ENB)\r\ndd->rcvctrl |= (1ULL << QLOGIC_IB_R_TAILUPD_SHIFT);\r\nif (op & QIB_RCVCTRL_TAILUPD_DIS)\r\ndd->rcvctrl &= ~(1ULL << QLOGIC_IB_R_TAILUPD_SHIFT);\r\nif (op & QIB_RCVCTRL_PKEY_ENB)\r\ndd->rcvctrl &= ~(1ULL << IBA6120_R_PKEY_DIS_SHIFT);\r\nif (op & QIB_RCVCTRL_PKEY_DIS)\r\ndd->rcvctrl |= (1ULL << IBA6120_R_PKEY_DIS_SHIFT);\r\nif (ctxt < 0)\r\nmask = (1ULL << dd->ctxtcnt) - 1;\r\nelse\r\nmask = (1ULL << ctxt);\r\nif (op & QIB_RCVCTRL_CTXT_ENB) {\r\ndd->rcvctrl |= (mask << SYM_LSB(RcvCtrl, PortEnable));\r\nif (!(dd->flags & QIB_NODMA_RTAIL))\r\ndd->rcvctrl |= 1ULL << QLOGIC_IB_R_TAILUPD_SHIFT;\r\nqib_write_kreg_ctxt(dd, kr_rcvhdrtailaddr, ctxt,\r\ndd->rcd[ctxt]->rcvhdrqtailaddr_phys);\r\nqib_write_kreg_ctxt(dd, kr_rcvhdraddr, ctxt,\r\ndd->rcd[ctxt]->rcvhdrq_phys);\r\nif (ctxt == 0 && !dd->cspec->dummy_hdrq)\r\nalloc_dummy_hdrq(dd);\r\n}\r\nif (op & QIB_RCVCTRL_CTXT_DIS)\r\ndd->rcvctrl &= ~(mask << SYM_LSB(RcvCtrl, PortEnable));\r\nif (op & QIB_RCVCTRL_INTRAVAIL_ENB)\r\ndd->rcvctrl |= (mask << QLOGIC_IB_R_INTRAVAIL_SHIFT);\r\nif (op & QIB_RCVCTRL_INTRAVAIL_DIS)\r\ndd->rcvctrl &= ~(mask << QLOGIC_IB_R_INTRAVAIL_SHIFT);\r\nqib_write_kreg(dd, kr_rcvctrl, dd->rcvctrl);\r\nif ((op & QIB_RCVCTRL_INTRAVAIL_ENB) && dd->rhdrhead_intr_off) {\r\nval = qib_read_ureg32(dd, ur_rcvhdrhead, ctxt) |\r\ndd->rhdrhead_intr_off;\r\nqib_write_ureg(dd, ur_rcvhdrhead, val, ctxt);\r\n}\r\nif (op & QIB_RCVCTRL_CTXT_ENB) {\r\nval = qib_read_ureg32(dd, ur_rcvegrindextail, ctxt);\r\nqib_write_ureg(dd, ur_rcvegrindexhead, val, ctxt);\r\nval = qib_read_ureg32(dd, ur_rcvhdrtail, ctxt);\r\ndd->rcd[ctxt]->head = val;\r\nif (ctxt < dd->first_user_ctxt)\r\nval |= dd->rhdrhead_intr_off;\r\nqib_write_ureg(dd, ur_rcvhdrhead, val, ctxt);\r\n}\r\nif (op & QIB_RCVCTRL_CTXT_DIS) {\r\nif (ctxt >= 0) {\r\nqib_write_kreg_ctxt(dd, kr_rcvhdrtailaddr, ctxt,\r\ndd->cspec->dummy_hdrq_phys);\r\nqib_write_kreg_ctxt(dd, kr_rcvhdraddr, ctxt,\r\ndd->cspec->dummy_hdrq_phys);\r\n} else {\r\nunsigned i;\r\nfor (i = 0; i < dd->cfgctxts; i++) {\r\nqib_write_kreg_ctxt(dd, kr_rcvhdrtailaddr,\r\ni, dd->cspec->dummy_hdrq_phys);\r\nqib_write_kreg_ctxt(dd, kr_rcvhdraddr,\r\ni, dd->cspec->dummy_hdrq_phys);\r\n}\r\n}\r\n}\r\nspin_unlock_irqrestore(&dd->cspec->rcvmod_lock, flags);\r\n}\r\nstatic void sendctrl_6120_mod(struct qib_pportdata *ppd, u32 op)\r\n{\r\nstruct qib_devdata *dd = ppd->dd;\r\nu64 tmp_dd_sendctrl;\r\nunsigned long flags;\r\nspin_lock_irqsave(&dd->sendctrl_lock, flags);\r\nif (op & QIB_SENDCTRL_CLEAR)\r\ndd->sendctrl = 0;\r\nif (op & QIB_SENDCTRL_SEND_DIS)\r\ndd->sendctrl &= ~SYM_MASK(SendCtrl, PIOEnable);\r\nelse if (op & QIB_SENDCTRL_SEND_ENB)\r\ndd->sendctrl |= SYM_MASK(SendCtrl, PIOEnable);\r\nif (op & QIB_SENDCTRL_AVAIL_DIS)\r\ndd->sendctrl &= ~SYM_MASK(SendCtrl, PIOBufAvailUpd);\r\nelse if (op & QIB_SENDCTRL_AVAIL_ENB)\r\ndd->sendctrl |= SYM_MASK(SendCtrl, PIOBufAvailUpd);\r\nif (op & QIB_SENDCTRL_DISARM_ALL) {\r\nu32 i, last;\r\ntmp_dd_sendctrl = dd->sendctrl;\r\nlast = dd->piobcnt2k + dd->piobcnt4k;\r\ntmp_dd_sendctrl &=\r\n~(SYM_MASK(SendCtrl, PIOEnable) |\r\nSYM_MASK(SendCtrl, PIOBufAvailUpd));\r\nfor (i = 0; i < last; i++) {\r\nqib_write_kreg(dd, kr_sendctrl, tmp_dd_sendctrl |\r\nSYM_MASK(SendCtrl, Disarm) | i);\r\nqib_write_kreg(dd, kr_scratch, 0);\r\n}\r\n}\r\ntmp_dd_sendctrl = dd->sendctrl;\r\nif (op & QIB_SENDCTRL_FLUSH)\r\ntmp_dd_sendctrl |= SYM_MASK(SendCtrl, Abort);\r\nif (op & QIB_SENDCTRL_DISARM)\r\ntmp_dd_sendctrl |= SYM_MASK(SendCtrl, Disarm) |\r\n((op & QIB_6120_SendCtrl_DisarmPIOBuf_RMASK) <<\r\nSYM_LSB(SendCtrl, DisarmPIOBuf));\r\nif (op & QIB_SENDCTRL_AVAIL_BLIP)\r\ntmp_dd_sendctrl &= ~SYM_MASK(SendCtrl, PIOBufAvailUpd);\r\nqib_write_kreg(dd, kr_sendctrl, tmp_dd_sendctrl);\r\nqib_write_kreg(dd, kr_scratch, 0);\r\nif (op & QIB_SENDCTRL_AVAIL_BLIP) {\r\nqib_write_kreg(dd, kr_sendctrl, dd->sendctrl);\r\nqib_write_kreg(dd, kr_scratch, 0);\r\n}\r\nspin_unlock_irqrestore(&dd->sendctrl_lock, flags);\r\nif (op & QIB_SENDCTRL_FLUSH) {\r\nu32 v;\r\nv = qib_read_kreg32(dd, kr_scratch);\r\nqib_write_kreg(dd, kr_scratch, v);\r\nv = qib_read_kreg32(dd, kr_scratch);\r\nqib_write_kreg(dd, kr_scratch, v);\r\nqib_read_kreg32(dd, kr_scratch);\r\n}\r\n}\r\nstatic u64 qib_portcntr_6120(struct qib_pportdata *ppd, u32 reg)\r\n{\r\nu64 ret = 0ULL;\r\nstruct qib_devdata *dd = ppd->dd;\r\nu16 creg;\r\nstatic const u16 xlator[] = {\r\n[QIBPORTCNTR_PKTSEND] = cr_pktsend,\r\n[QIBPORTCNTR_WORDSEND] = cr_wordsend,\r\n[QIBPORTCNTR_PSXMITDATA] = 0xffff,\r\n[QIBPORTCNTR_PSXMITPKTS] = 0xffff,\r\n[QIBPORTCNTR_PSXMITWAIT] = 0xffff,\r\n[QIBPORTCNTR_SENDSTALL] = cr_sendstall,\r\n[QIBPORTCNTR_PKTRCV] = cr_pktrcv,\r\n[QIBPORTCNTR_PSRCVDATA] = 0xffff,\r\n[QIBPORTCNTR_PSRCVPKTS] = 0xffff,\r\n[QIBPORTCNTR_RCVEBP] = cr_rcvebp,\r\n[QIBPORTCNTR_RCVOVFL] = cr_rcvovfl,\r\n[QIBPORTCNTR_WORDRCV] = cr_wordrcv,\r\n[QIBPORTCNTR_RXDROPPKT] = cr_rxdroppkt,\r\n[QIBPORTCNTR_RXLOCALPHYERR] = 0xffff,\r\n[QIBPORTCNTR_RXVLERR] = 0xffff,\r\n[QIBPORTCNTR_ERRICRC] = cr_erricrc,\r\n[QIBPORTCNTR_ERRVCRC] = cr_errvcrc,\r\n[QIBPORTCNTR_ERRLPCRC] = cr_errlpcrc,\r\n[QIBPORTCNTR_BADFORMAT] = cr_badformat,\r\n[QIBPORTCNTR_ERR_RLEN] = cr_err_rlen,\r\n[QIBPORTCNTR_IBSYMBOLERR] = cr_ibsymbolerr,\r\n[QIBPORTCNTR_INVALIDRLEN] = cr_invalidrlen,\r\n[QIBPORTCNTR_UNSUPVL] = cr_txunsupvl,\r\n[QIBPORTCNTR_EXCESSBUFOVFL] = 0xffff,\r\n[QIBPORTCNTR_ERRLINK] = cr_errlink,\r\n[QIBPORTCNTR_IBLINKDOWN] = cr_iblinkdown,\r\n[QIBPORTCNTR_IBLINKERRRECOV] = cr_iblinkerrrecov,\r\n[QIBPORTCNTR_LLI] = 0xffff,\r\n[QIBPORTCNTR_PSINTERVAL] = 0xffff,\r\n[QIBPORTCNTR_PSSTART] = 0xffff,\r\n[QIBPORTCNTR_PSSTAT] = 0xffff,\r\n[QIBPORTCNTR_VL15PKTDROP] = 0xffff,\r\n[QIBPORTCNTR_ERRPKEY] = cr_errpkey,\r\n[QIBPORTCNTR_KHDROVFL] = 0xffff,\r\n};\r\nif (reg >= ARRAY_SIZE(xlator)) {\r\nqib_devinfo(ppd->dd->pcidev,\r\n"Unimplemented portcounter %u\n", reg);\r\ngoto done;\r\n}\r\ncreg = xlator[reg];\r\nif (reg == QIBPORTCNTR_LLI)\r\nret = dd->cspec->lli_errs;\r\nelse if (reg == QIBPORTCNTR_EXCESSBUFOVFL)\r\nret = dd->cspec->overrun_thresh_errs;\r\nelse if (reg == QIBPORTCNTR_KHDROVFL) {\r\nint i;\r\nfor (i = 0; i < dd->first_user_ctxt; i++)\r\nret += read_6120_creg32(dd, cr_portovfl + i);\r\n} else if (reg == QIBPORTCNTR_PSSTAT)\r\nret = dd->cspec->pma_sample_status;\r\nif (creg == 0xffff)\r\ngoto done;\r\nif (creg == cr_wordsend || creg == cr_wordrcv ||\r\ncreg == cr_pktsend || creg == cr_pktrcv)\r\nret = read_6120_creg(dd, creg);\r\nelse\r\nret = read_6120_creg32(dd, creg);\r\nif (creg == cr_ibsymbolerr) {\r\nif (dd->cspec->ibdeltainprog)\r\nret -= ret - dd->cspec->ibsymsnap;\r\nret -= dd->cspec->ibsymdelta;\r\n} else if (creg == cr_iblinkerrrecov) {\r\nif (dd->cspec->ibdeltainprog)\r\nret -= ret - dd->cspec->iblnkerrsnap;\r\nret -= dd->cspec->iblnkerrdelta;\r\n}\r\nif (reg == QIBPORTCNTR_RXDROPPKT)\r\nret += dd->cspec->rxfc_unsupvl_errs;\r\ndone:\r\nreturn ret;\r\n}\r\nstatic void init_6120_cntrnames(struct qib_devdata *dd)\r\n{\r\nint i, j = 0;\r\nchar *s;\r\nfor (i = 0, s = (char *)cntr6120names; s && j <= dd->cfgctxts;\r\ni++) {\r\nif (!j && !strncmp("Ctxt0EgrOvfl", s + 1, 12))\r\nj = 1;\r\ns = strchr(s + 1, '\n');\r\nif (s && j)\r\nj++;\r\n}\r\ndd->cspec->ncntrs = i;\r\nif (!s)\r\ndd->cspec->cntrnamelen = sizeof(cntr6120names) - 1;\r\nelse\r\ndd->cspec->cntrnamelen = 1 + s - cntr6120names;\r\ndd->cspec->cntrs = kmalloc(dd->cspec->ncntrs\r\n* sizeof(u64), GFP_KERNEL);\r\nif (!dd->cspec->cntrs)\r\nqib_dev_err(dd, "Failed allocation for counters\n");\r\nfor (i = 0, s = (char *)portcntr6120names; s; i++)\r\ns = strchr(s + 1, '\n');\r\ndd->cspec->nportcntrs = i - 1;\r\ndd->cspec->portcntrnamelen = sizeof(portcntr6120names) - 1;\r\ndd->cspec->portcntrs = kmalloc(dd->cspec->nportcntrs\r\n* sizeof(u64), GFP_KERNEL);\r\nif (!dd->cspec->portcntrs)\r\nqib_dev_err(dd, "Failed allocation for portcounters\n");\r\n}\r\nstatic u32 qib_read_6120cntrs(struct qib_devdata *dd, loff_t pos, char **namep,\r\nu64 **cntrp)\r\n{\r\nu32 ret;\r\nif (namep) {\r\nret = dd->cspec->cntrnamelen;\r\nif (pos >= ret)\r\nret = 0;\r\nelse\r\n*namep = (char *)cntr6120names;\r\n} else {\r\nu64 *cntr = dd->cspec->cntrs;\r\nint i;\r\nret = dd->cspec->ncntrs * sizeof(u64);\r\nif (!cntr || pos >= ret) {\r\nret = 0;\r\ngoto done;\r\n}\r\nif (pos >= ret) {\r\nret = 0;\r\ngoto done;\r\n}\r\n*cntrp = cntr;\r\nfor (i = 0; i < dd->cspec->ncntrs; i++)\r\n*cntr++ = read_6120_creg32(dd, cntr6120indices[i]);\r\n}\r\ndone:\r\nreturn ret;\r\n}\r\nstatic u32 qib_read_6120portcntrs(struct qib_devdata *dd, loff_t pos, u32 port,\r\nchar **namep, u64 **cntrp)\r\n{\r\nu32 ret;\r\nif (namep) {\r\nret = dd->cspec->portcntrnamelen;\r\nif (pos >= ret)\r\nret = 0;\r\nelse\r\n*namep = (char *)portcntr6120names;\r\n} else {\r\nu64 *cntr = dd->cspec->portcntrs;\r\nstruct qib_pportdata *ppd = &dd->pport[port];\r\nint i;\r\nret = dd->cspec->nportcntrs * sizeof(u64);\r\nif (!cntr || pos >= ret) {\r\nret = 0;\r\ngoto done;\r\n}\r\n*cntrp = cntr;\r\nfor (i = 0; i < dd->cspec->nportcntrs; i++) {\r\nif (portcntr6120indices[i] & _PORT_VIRT_FLAG)\r\n*cntr++ = qib_portcntr_6120(ppd,\r\nportcntr6120indices[i] &\r\n~_PORT_VIRT_FLAG);\r\nelse\r\n*cntr++ = read_6120_creg32(dd,\r\nportcntr6120indices[i]);\r\n}\r\n}\r\ndone:\r\nreturn ret;\r\n}\r\nstatic void qib_chk_6120_errormask(struct qib_devdata *dd)\r\n{\r\nstatic u32 fixed;\r\nu32 ctrl;\r\nunsigned long errormask;\r\nunsigned long hwerrs;\r\nif (!dd->cspec->errormask || !(dd->flags & QIB_INITTED))\r\nreturn;\r\nerrormask = qib_read_kreg64(dd, kr_errmask);\r\nif (errormask == dd->cspec->errormask)\r\nreturn;\r\nfixed++;\r\nhwerrs = qib_read_kreg64(dd, kr_hwerrstatus);\r\nctrl = qib_read_kreg32(dd, kr_control);\r\nqib_write_kreg(dd, kr_errmask,\r\ndd->cspec->errormask);\r\nif ((hwerrs & dd->cspec->hwerrmask) ||\r\n(ctrl & QLOGIC_IB_C_FREEZEMODE)) {\r\nqib_write_kreg(dd, kr_hwerrclear, 0ULL);\r\nqib_write_kreg(dd, kr_errclear, 0ULL);\r\nqib_write_kreg(dd, kr_intclear, 0ULL);\r\nqib_devinfo(dd->pcidev,\r\n"errormask fixed(%u) %lx->%lx, ctrl %x hwerr %lx\n",\r\nfixed, errormask, (unsigned long)dd->cspec->errormask,\r\nctrl, hwerrs);\r\n}\r\n}\r\nstatic void qib_get_6120_faststats(unsigned long opaque)\r\n{\r\nstruct qib_devdata *dd = (struct qib_devdata *) opaque;\r\nstruct qib_pportdata *ppd = dd->pport;\r\nunsigned long flags;\r\nu64 traffic_wds;\r\nif (!(dd->flags & QIB_INITTED) || dd->diag_client)\r\ngoto done;\r\ntraffic_wds = qib_portcntr_6120(ppd, cr_wordsend) +\r\nqib_portcntr_6120(ppd, cr_wordrcv);\r\nspin_lock_irqsave(&dd->eep_st_lock, flags);\r\ntraffic_wds -= dd->traffic_wds;\r\ndd->traffic_wds += traffic_wds;\r\nspin_unlock_irqrestore(&dd->eep_st_lock, flags);\r\nqib_chk_6120_errormask(dd);\r\ndone:\r\nmod_timer(&dd->stats_timer, jiffies + HZ * ACTIVITY_TIMER);\r\n}\r\nstatic int qib_6120_nointr_fallback(struct qib_devdata *dd)\r\n{\r\nreturn 0;\r\n}\r\nstatic void qib_6120_xgxs_reset(struct qib_pportdata *ppd)\r\n{\r\nu64 val, prev_val;\r\nstruct qib_devdata *dd = ppd->dd;\r\nprev_val = qib_read_kreg64(dd, kr_xgxs_cfg);\r\nval = prev_val | QLOGIC_IB_XGXS_RESET;\r\nprev_val &= ~QLOGIC_IB_XGXS_RESET;\r\nqib_write_kreg(dd, kr_control,\r\ndd->control & ~QLOGIC_IB_C_LINKENABLE);\r\nqib_write_kreg(dd, kr_xgxs_cfg, val);\r\nqib_read_kreg32(dd, kr_scratch);\r\nqib_write_kreg(dd, kr_xgxs_cfg, prev_val);\r\nqib_write_kreg(dd, kr_control, dd->control);\r\n}\r\nstatic int qib_6120_get_ib_cfg(struct qib_pportdata *ppd, int which)\r\n{\r\nint ret;\r\nswitch (which) {\r\ncase QIB_IB_CFG_LWID:\r\nret = ppd->link_width_active;\r\nbreak;\r\ncase QIB_IB_CFG_SPD:\r\nret = ppd->link_speed_active;\r\nbreak;\r\ncase QIB_IB_CFG_LWID_ENB:\r\nret = ppd->link_width_enabled;\r\nbreak;\r\ncase QIB_IB_CFG_SPD_ENB:\r\nret = ppd->link_speed_enabled;\r\nbreak;\r\ncase QIB_IB_CFG_OP_VLS:\r\nret = ppd->vls_operational;\r\nbreak;\r\ncase QIB_IB_CFG_VL_HIGH_CAP:\r\nret = 0;\r\nbreak;\r\ncase QIB_IB_CFG_VL_LOW_CAP:\r\nret = 0;\r\nbreak;\r\ncase QIB_IB_CFG_OVERRUN_THRESH:\r\nret = SYM_FIELD(ppd->dd->cspec->ibcctrl, IBCCtrl,\r\nOverrunThreshold);\r\nbreak;\r\ncase QIB_IB_CFG_PHYERR_THRESH:\r\nret = SYM_FIELD(ppd->dd->cspec->ibcctrl, IBCCtrl,\r\nPhyerrThreshold);\r\nbreak;\r\ncase QIB_IB_CFG_LINKDEFAULT:\r\nret = (ppd->dd->cspec->ibcctrl &\r\nSYM_MASK(IBCCtrl, LinkDownDefaultState)) ?\r\nIB_LINKINITCMD_SLEEP : IB_LINKINITCMD_POLL;\r\nbreak;\r\ncase QIB_IB_CFG_HRTBT:\r\nret = 0;\r\nbreak;\r\ncase QIB_IB_CFG_PMA_TICKS:\r\nret = 250;\r\nbreak;\r\ndefault:\r\nret = -EINVAL;\r\nbreak;\r\n}\r\nreturn ret;\r\n}\r\nstatic int qib_6120_set_ib_cfg(struct qib_pportdata *ppd, int which, u32 val)\r\n{\r\nstruct qib_devdata *dd = ppd->dd;\r\nint ret = 0;\r\nu64 val64;\r\nu16 lcmd, licmd;\r\nswitch (which) {\r\ncase QIB_IB_CFG_LWID_ENB:\r\nppd->link_width_enabled = val;\r\nbreak;\r\ncase QIB_IB_CFG_SPD_ENB:\r\nppd->link_speed_enabled = val;\r\nbreak;\r\ncase QIB_IB_CFG_OVERRUN_THRESH:\r\nval64 = SYM_FIELD(dd->cspec->ibcctrl, IBCCtrl,\r\nOverrunThreshold);\r\nif (val64 != val) {\r\ndd->cspec->ibcctrl &=\r\n~SYM_MASK(IBCCtrl, OverrunThreshold);\r\ndd->cspec->ibcctrl |= (u64) val <<\r\nSYM_LSB(IBCCtrl, OverrunThreshold);\r\nqib_write_kreg(dd, kr_ibcctrl, dd->cspec->ibcctrl);\r\nqib_write_kreg(dd, kr_scratch, 0);\r\n}\r\nbreak;\r\ncase QIB_IB_CFG_PHYERR_THRESH:\r\nval64 = SYM_FIELD(dd->cspec->ibcctrl, IBCCtrl,\r\nPhyerrThreshold);\r\nif (val64 != val) {\r\ndd->cspec->ibcctrl &=\r\n~SYM_MASK(IBCCtrl, PhyerrThreshold);\r\ndd->cspec->ibcctrl |= (u64) val <<\r\nSYM_LSB(IBCCtrl, PhyerrThreshold);\r\nqib_write_kreg(dd, kr_ibcctrl, dd->cspec->ibcctrl);\r\nqib_write_kreg(dd, kr_scratch, 0);\r\n}\r\nbreak;\r\ncase QIB_IB_CFG_PKEYS:\r\nval64 = (u64) ppd->pkeys[0] | ((u64) ppd->pkeys[1] << 16) |\r\n((u64) ppd->pkeys[2] << 32) |\r\n((u64) ppd->pkeys[3] << 48);\r\nqib_write_kreg(dd, kr_partitionkey, val64);\r\nbreak;\r\ncase QIB_IB_CFG_LINKDEFAULT:\r\nif (val == IB_LINKINITCMD_POLL)\r\ndd->cspec->ibcctrl &=\r\n~SYM_MASK(IBCCtrl, LinkDownDefaultState);\r\nelse\r\ndd->cspec->ibcctrl |=\r\nSYM_MASK(IBCCtrl, LinkDownDefaultState);\r\nqib_write_kreg(dd, kr_ibcctrl, dd->cspec->ibcctrl);\r\nqib_write_kreg(dd, kr_scratch, 0);\r\nbreak;\r\ncase QIB_IB_CFG_MTU:\r\nval = (ppd->ibmaxlen >> 2) + 1;\r\ndd->cspec->ibcctrl &= ~SYM_MASK(IBCCtrl, MaxPktLen);\r\ndd->cspec->ibcctrl |= (u64)val <<\r\nSYM_LSB(IBCCtrl, MaxPktLen);\r\nqib_write_kreg(dd, kr_ibcctrl, dd->cspec->ibcctrl);\r\nqib_write_kreg(dd, kr_scratch, 0);\r\nbreak;\r\ncase QIB_IB_CFG_LSTATE:\r\nswitch (val & 0xffff0000) {\r\ncase IB_LINKCMD_DOWN:\r\nlcmd = QLOGIC_IB_IBCC_LINKCMD_DOWN;\r\nif (!dd->cspec->ibdeltainprog) {\r\ndd->cspec->ibdeltainprog = 1;\r\ndd->cspec->ibsymsnap =\r\nread_6120_creg32(dd, cr_ibsymbolerr);\r\ndd->cspec->iblnkerrsnap =\r\nread_6120_creg32(dd, cr_iblinkerrrecov);\r\n}\r\nbreak;\r\ncase IB_LINKCMD_ARMED:\r\nlcmd = QLOGIC_IB_IBCC_LINKCMD_ARMED;\r\nbreak;\r\ncase IB_LINKCMD_ACTIVE:\r\nlcmd = QLOGIC_IB_IBCC_LINKCMD_ACTIVE;\r\nbreak;\r\ndefault:\r\nret = -EINVAL;\r\nqib_dev_err(dd, "bad linkcmd req 0x%x\n", val >> 16);\r\ngoto bail;\r\n}\r\nswitch (val & 0xffff) {\r\ncase IB_LINKINITCMD_NOP:\r\nlicmd = 0;\r\nbreak;\r\ncase IB_LINKINITCMD_POLL:\r\nlicmd = QLOGIC_IB_IBCC_LINKINITCMD_POLL;\r\nbreak;\r\ncase IB_LINKINITCMD_SLEEP:\r\nlicmd = QLOGIC_IB_IBCC_LINKINITCMD_SLEEP;\r\nbreak;\r\ncase IB_LINKINITCMD_DISABLE:\r\nlicmd = QLOGIC_IB_IBCC_LINKINITCMD_DISABLE;\r\nbreak;\r\ndefault:\r\nret = -EINVAL;\r\nqib_dev_err(dd, "bad linkinitcmd req 0x%x\n",\r\nval & 0xffff);\r\ngoto bail;\r\n}\r\nqib_set_ib_6120_lstate(ppd, lcmd, licmd);\r\ngoto bail;\r\ncase QIB_IB_CFG_HRTBT:\r\nret = -EINVAL;\r\nbreak;\r\ndefault:\r\nret = -EINVAL;\r\n}\r\nbail:\r\nreturn ret;\r\n}\r\nstatic int qib_6120_set_loopback(struct qib_pportdata *ppd, const char *what)\r\n{\r\nint ret = 0;\r\nif (!strncmp(what, "ibc", 3)) {\r\nppd->dd->cspec->ibcctrl |= SYM_MASK(IBCCtrl, Loopback);\r\nqib_devinfo(ppd->dd->pcidev, "Enabling IB%u:%u IBC loopback\n",\r\nppd->dd->unit, ppd->port);\r\n} else if (!strncmp(what, "off", 3)) {\r\nppd->dd->cspec->ibcctrl &= ~SYM_MASK(IBCCtrl, Loopback);\r\nqib_devinfo(ppd->dd->pcidev,\r\n"Disabling IB%u:%u IBC loopback (normal)\n",\r\nppd->dd->unit, ppd->port);\r\n} else\r\nret = -EINVAL;\r\nif (!ret) {\r\nqib_write_kreg(ppd->dd, kr_ibcctrl, ppd->dd->cspec->ibcctrl);\r\nqib_write_kreg(ppd->dd, kr_scratch, 0);\r\n}\r\nreturn ret;\r\n}\r\nstatic void pma_6120_timer(unsigned long data)\r\n{\r\nstruct qib_pportdata *ppd = (struct qib_pportdata *)data;\r\nstruct qib_chip_specific *cs = ppd->dd->cspec;\r\nstruct qib_ibport *ibp = &ppd->ibport_data;\r\nunsigned long flags;\r\nspin_lock_irqsave(&ibp->lock, flags);\r\nif (cs->pma_sample_status == IB_PMA_SAMPLE_STATUS_STARTED) {\r\ncs->pma_sample_status = IB_PMA_SAMPLE_STATUS_RUNNING;\r\nqib_snapshot_counters(ppd, &cs->sword, &cs->rword,\r\n&cs->spkts, &cs->rpkts, &cs->xmit_wait);\r\nmod_timer(&cs->pma_timer,\r\njiffies + usecs_to_jiffies(ibp->pma_sample_interval));\r\n} else if (cs->pma_sample_status == IB_PMA_SAMPLE_STATUS_RUNNING) {\r\nu64 ta, tb, tc, td, te;\r\ncs->pma_sample_status = IB_PMA_SAMPLE_STATUS_DONE;\r\nqib_snapshot_counters(ppd, &ta, &tb, &tc, &td, &te);\r\ncs->sword = ta - cs->sword;\r\ncs->rword = tb - cs->rword;\r\ncs->spkts = tc - cs->spkts;\r\ncs->rpkts = td - cs->rpkts;\r\ncs->xmit_wait = te - cs->xmit_wait;\r\n}\r\nspin_unlock_irqrestore(&ibp->lock, flags);\r\n}\r\nstatic void qib_set_cntr_6120_sample(struct qib_pportdata *ppd, u32 intv,\r\nu32 start)\r\n{\r\nstruct qib_chip_specific *cs = ppd->dd->cspec;\r\nif (start && intv) {\r\ncs->pma_sample_status = IB_PMA_SAMPLE_STATUS_STARTED;\r\nmod_timer(&cs->pma_timer, jiffies + usecs_to_jiffies(start));\r\n} else if (intv) {\r\ncs->pma_sample_status = IB_PMA_SAMPLE_STATUS_RUNNING;\r\nqib_snapshot_counters(ppd, &cs->sword, &cs->rword,\r\n&cs->spkts, &cs->rpkts, &cs->xmit_wait);\r\nmod_timer(&cs->pma_timer, jiffies + usecs_to_jiffies(intv));\r\n} else {\r\ncs->pma_sample_status = IB_PMA_SAMPLE_STATUS_DONE;\r\ncs->sword = 0;\r\ncs->rword = 0;\r\ncs->spkts = 0;\r\ncs->rpkts = 0;\r\ncs->xmit_wait = 0;\r\n}\r\n}\r\nstatic u32 qib_6120_iblink_state(u64 ibcs)\r\n{\r\nu32 state = (u32)SYM_FIELD(ibcs, IBCStatus, LinkState);\r\nswitch (state) {\r\ncase IB_6120_L_STATE_INIT:\r\nstate = IB_PORT_INIT;\r\nbreak;\r\ncase IB_6120_L_STATE_ARM:\r\nstate = IB_PORT_ARMED;\r\nbreak;\r\ncase IB_6120_L_STATE_ACTIVE:\r\ncase IB_6120_L_STATE_ACT_DEFER:\r\nstate = IB_PORT_ACTIVE;\r\nbreak;\r\ndefault:\r\ncase IB_6120_L_STATE_DOWN:\r\nstate = IB_PORT_DOWN;\r\nbreak;\r\n}\r\nreturn state;\r\n}\r\nstatic u8 qib_6120_phys_portstate(u64 ibcs)\r\n{\r\nu8 state = (u8)SYM_FIELD(ibcs, IBCStatus, LinkTrainingState);\r\nreturn qib_6120_physportstate[state];\r\n}\r\nstatic int qib_6120_ib_updown(struct qib_pportdata *ppd, int ibup, u64 ibcs)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&ppd->lflags_lock, flags);\r\nppd->lflags &= ~QIBL_IB_FORCE_NOTIFY;\r\nspin_unlock_irqrestore(&ppd->lflags_lock, flags);\r\nif (ibup) {\r\nif (ppd->dd->cspec->ibdeltainprog) {\r\nppd->dd->cspec->ibdeltainprog = 0;\r\nppd->dd->cspec->ibsymdelta +=\r\nread_6120_creg32(ppd->dd, cr_ibsymbolerr) -\r\nppd->dd->cspec->ibsymsnap;\r\nppd->dd->cspec->iblnkerrdelta +=\r\nread_6120_creg32(ppd->dd, cr_iblinkerrrecov) -\r\nppd->dd->cspec->iblnkerrsnap;\r\n}\r\nqib_hol_init(ppd);\r\n} else {\r\nppd->dd->cspec->lli_counter = 0;\r\nif (!ppd->dd->cspec->ibdeltainprog) {\r\nppd->dd->cspec->ibdeltainprog = 1;\r\nppd->dd->cspec->ibsymsnap =\r\nread_6120_creg32(ppd->dd, cr_ibsymbolerr);\r\nppd->dd->cspec->iblnkerrsnap =\r\nread_6120_creg32(ppd->dd, cr_iblinkerrrecov);\r\n}\r\nqib_hol_down(ppd);\r\n}\r\nqib_6120_setup_setextled(ppd, ibup);\r\nreturn 0;\r\n}\r\nstatic int gpio_6120_mod(struct qib_devdata *dd, u32 out, u32 dir, u32 mask)\r\n{\r\nu64 read_val, new_out;\r\nunsigned long flags;\r\nif (mask) {\r\ndir &= mask;\r\nout &= mask;\r\nspin_lock_irqsave(&dd->cspec->gpio_lock, flags);\r\ndd->cspec->extctrl &= ~((u64)mask << SYM_LSB(EXTCtrl, GPIOOe));\r\ndd->cspec->extctrl |= ((u64) dir << SYM_LSB(EXTCtrl, GPIOOe));\r\nnew_out = (dd->cspec->gpio_out & ~mask) | out;\r\nqib_write_kreg(dd, kr_extctrl, dd->cspec->extctrl);\r\nqib_write_kreg(dd, kr_gpio_out, new_out);\r\ndd->cspec->gpio_out = new_out;\r\nspin_unlock_irqrestore(&dd->cspec->gpio_lock, flags);\r\n}\r\nread_val = qib_read_kreg64(dd, kr_extstatus);\r\nreturn SYM_FIELD(read_val, EXTStatus, GPIOIn);\r\n}\r\nstatic void get_6120_chip_params(struct qib_devdata *dd)\r\n{\r\nu64 val;\r\nu32 piobufs;\r\nint mtu;\r\ndd->uregbase = qib_read_kreg32(dd, kr_userregbase);\r\ndd->rcvtidcnt = qib_read_kreg32(dd, kr_rcvtidcnt);\r\ndd->rcvtidbase = qib_read_kreg32(dd, kr_rcvtidbase);\r\ndd->rcvegrbase = qib_read_kreg32(dd, kr_rcvegrbase);\r\ndd->palign = qib_read_kreg32(dd, kr_palign);\r\ndd->piobufbase = qib_read_kreg64(dd, kr_sendpiobufbase);\r\ndd->pio2k_bufbase = dd->piobufbase & 0xffffffff;\r\ndd->rcvhdrcnt = qib_read_kreg32(dd, kr_rcvegrcnt);\r\nval = qib_read_kreg64(dd, kr_sendpiosize);\r\ndd->piosize2k = val & ~0U;\r\ndd->piosize4k = val >> 32;\r\nmtu = ib_mtu_enum_to_int(qib_ibmtu);\r\nif (mtu == -1)\r\nmtu = QIB_DEFAULT_MTU;\r\ndd->pport->ibmtu = (u32)mtu;\r\nval = qib_read_kreg64(dd, kr_sendpiobufcnt);\r\ndd->piobcnt2k = val & ~0U;\r\ndd->piobcnt4k = val >> 32;\r\ndd->last_pio = dd->piobcnt4k + dd->piobcnt2k - 1;\r\ndd->pio2kbase = (u32 __iomem *)\r\n(((char __iomem *)dd->kregbase) + dd->pio2k_bufbase);\r\nif (dd->piobcnt4k) {\r\ndd->pio4kbase = (u32 __iomem *)\r\n(((char __iomem *) dd->kregbase) +\r\n(dd->piobufbase >> 32));\r\ndd->align4k = ALIGN(dd->piosize4k, dd->palign);\r\n}\r\npiobufs = dd->piobcnt4k + dd->piobcnt2k;\r\ndd->pioavregs = ALIGN(piobufs, sizeof(u64) * BITS_PER_BYTE / 2) /\r\n(sizeof(u64) * BITS_PER_BYTE / 2);\r\n}\r\nstatic void set_6120_baseaddrs(struct qib_devdata *dd)\r\n{\r\nu32 cregbase;\r\ncregbase = qib_read_kreg32(dd, kr_counterregbase);\r\ndd->cspec->cregbase = (u64 __iomem *)\r\n((char __iomem *) dd->kregbase + cregbase);\r\ndd->egrtidbase = (u64 __iomem *)\r\n((char __iomem *) dd->kregbase + dd->rcvegrbase);\r\n}\r\nstatic int qib_late_6120_initreg(struct qib_devdata *dd)\r\n{\r\nint ret = 0;\r\nu64 val;\r\nqib_write_kreg(dd, kr_rcvhdrentsize, dd->rcvhdrentsize);\r\nqib_write_kreg(dd, kr_rcvhdrsize, dd->rcvhdrsize);\r\nqib_write_kreg(dd, kr_rcvhdrcnt, dd->rcvhdrcnt);\r\nqib_write_kreg(dd, kr_sendpioavailaddr, dd->pioavailregs_phys);\r\nval = qib_read_kreg64(dd, kr_sendpioavailaddr);\r\nif (val != dd->pioavailregs_phys) {\r\nqib_dev_err(dd,\r\n"Catastrophic software error, SendPIOAvailAddr written as %lx, read back as %llx\n",\r\n(unsigned long) dd->pioavailregs_phys,\r\n(unsigned long long) val);\r\nret = -EINVAL;\r\n}\r\nreturn ret;\r\n}\r\nstatic int init_6120_variables(struct qib_devdata *dd)\r\n{\r\nint ret = 0;\r\nstruct qib_pportdata *ppd;\r\nu32 sbufs;\r\nppd = (struct qib_pportdata *)(dd + 1);\r\ndd->pport = ppd;\r\ndd->num_pports = 1;\r\ndd->cspec = (struct qib_chip_specific *)(ppd + dd->num_pports);\r\nppd->cpspec = NULL;\r\nspin_lock_init(&dd->cspec->kernel_tid_lock);\r\nspin_lock_init(&dd->cspec->user_tid_lock);\r\nspin_lock_init(&dd->cspec->rcvmod_lock);\r\nspin_lock_init(&dd->cspec->gpio_lock);\r\ndd->revision = readq(&dd->kregbase[kr_revision]);\r\nif ((dd->revision & 0xffffffffU) == 0xffffffffU) {\r\nqib_dev_err(dd,\r\n"Revision register read failure, giving up initialization\n");\r\nret = -ENODEV;\r\ngoto bail;\r\n}\r\ndd->flags |= QIB_PRESENT;\r\ndd->majrev = (u8) SYM_FIELD(dd->revision, Revision_R,\r\nChipRevMajor);\r\ndd->minrev = (u8) SYM_FIELD(dd->revision, Revision_R,\r\nChipRevMinor);\r\nget_6120_chip_params(dd);\r\npe_boardname(dd);\r\ndd->gpio_sda_num = _QIB_GPIO_SDA_NUM;\r\ndd->gpio_scl_num = _QIB_GPIO_SCL_NUM;\r\ndd->twsi_eeprom_dev = QIB_TWSI_NO_DEV;\r\nif (qib_unordered_wc())\r\ndd->flags |= QIB_PIO_FLUSH_WC;\r\ndd->eep_st_masks[0].hwerrs_to_log = HWE_MASK(TXEMemParityErr);\r\nif (qib_unordered_wc())\r\ndd->eep_st_masks[0].hwerrs_to_log &= ~TXE_PIO_PARITY;\r\ndd->eep_st_masks[1].hwerrs_to_log = HWE_MASK(RXEMemParityErr);\r\ndd->eep_st_masks[2].errs_to_log = ERR_MASK(ResetNegated);\r\nret = qib_init_pportdata(ppd, dd, 0, 1);\r\nif (ret)\r\ngoto bail;\r\nppd->link_width_supported = IB_WIDTH_1X | IB_WIDTH_4X;\r\nppd->link_speed_supported = QIB_IB_SDR;\r\nppd->link_width_enabled = IB_WIDTH_4X;\r\nppd->link_speed_enabled = ppd->link_speed_supported;\r\nppd->link_width_active = ppd->link_width_enabled;\r\nppd->link_speed_active = ppd->link_speed_enabled;\r\nppd->vls_supported = IB_VL_VL0;\r\nppd->vls_operational = ppd->vls_supported;\r\ndd->rcvhdrentsize = QIB_RCVHDR_ENTSIZE;\r\ndd->rcvhdrsize = QIB_DFLT_RCVHDRSIZE;\r\ndd->rhf_offset = 0;\r\nret = ib_mtu_enum_to_int(qib_ibmtu);\r\ndd->rcvegrbufsize = ret != -1 ? max(ret, 2048) : QIB_DEFAULT_MTU;\r\nBUG_ON(!is_power_of_2(dd->rcvegrbufsize));\r\ndd->rcvegrbufsize_shift = ilog2(dd->rcvegrbufsize);\r\nqib_6120_tidtemplate(dd);\r\ndd->rhdrhead_intr_off = 1ULL << 32;\r\ninit_timer(&dd->stats_timer);\r\ndd->stats_timer.function = qib_get_6120_faststats;\r\ndd->stats_timer.data = (unsigned long) dd;\r\ninit_timer(&dd->cspec->pma_timer);\r\ndd->cspec->pma_timer.function = pma_6120_timer;\r\ndd->cspec->pma_timer.data = (unsigned long) ppd;\r\ndd->ureg_align = qib_read_kreg32(dd, kr_palign);\r\ndd->piosize2kmax_dwords = dd->piosize2k >> 2;\r\nqib_6120_config_ctxts(dd);\r\nqib_set_ctxtcnt(dd);\r\nret = init_chip_wc_pat(dd, 0);\r\nif (ret)\r\ngoto bail;\r\nset_6120_baseaddrs(dd);\r\nret = 0;\r\nif (qib_mini_init)\r\ngoto bail;\r\nqib_num_cfg_vls = 1;\r\nret = qib_create_ctxts(dd);\r\ninit_6120_cntrnames(dd);\r\nsbufs = dd->piobcnt4k ? dd->piobcnt4k : 16;\r\ndd->lastctxt_piobuf = dd->piobcnt2k + dd->piobcnt4k - sbufs;\r\ndd->pbufsctxt = dd->lastctxt_piobuf /\r\n(dd->cfgctxts - dd->first_user_ctxt);\r\nif (ret)\r\ngoto bail;\r\nbail:\r\nreturn ret;\r\n}\r\nstatic u32 __iomem *get_6120_link_buf(struct qib_pportdata *ppd, u32 *bnum)\r\n{\r\nu32 __iomem *buf;\r\nu32 lbuf = ppd->dd->piobcnt2k + ppd->dd->piobcnt4k - 1;\r\nsendctrl_6120_mod(ppd->dd->pport, QIB_SENDCTRL_AVAIL_BLIP);\r\nqib_read_kreg64(ppd->dd, kr_scratch);\r\nbuf = qib_getsendbuf_range(ppd->dd, bnum, lbuf, lbuf);\r\nif (buf)\r\ngoto done;\r\nsendctrl_6120_mod(ppd, QIB_SENDCTRL_DISARM_ALL | QIB_SENDCTRL_FLUSH |\r\nQIB_SENDCTRL_AVAIL_BLIP);\r\nppd->dd->upd_pio_shadow = 1;\r\nqib_read_kreg64(ppd->dd, kr_scratch);\r\nbuf = qib_getsendbuf_range(ppd->dd, bnum, lbuf, lbuf);\r\ndone:\r\nreturn buf;\r\n}\r\nstatic u32 __iomem *qib_6120_getsendbuf(struct qib_pportdata *ppd, u64 pbc,\r\nu32 *pbufnum)\r\n{\r\nu32 first, last, plen = pbc & QIB_PBC_LENGTH_MASK;\r\nstruct qib_devdata *dd = ppd->dd;\r\nu32 __iomem *buf;\r\nif (((pbc >> 32) & PBC_6120_VL15_SEND_CTRL) &&\r\n!(ppd->lflags & (QIBL_IB_AUTONEG_INPROG | QIBL_LINKACTIVE)))\r\nbuf = get_6120_link_buf(ppd, pbufnum);\r\nelse {\r\nif ((plen + 1) > dd->piosize2kmax_dwords)\r\nfirst = dd->piobcnt2k;\r\nelse\r\nfirst = 0;\r\nlast = dd->piobcnt2k + dd->piobcnt4k - 1;\r\nbuf = qib_getsendbuf_range(dd, pbufnum, first, last);\r\n}\r\nreturn buf;\r\n}\r\nstatic int init_sdma_6120_regs(struct qib_pportdata *ppd)\r\n{\r\nreturn -ENODEV;\r\n}\r\nstatic u16 qib_sdma_6120_gethead(struct qib_pportdata *ppd)\r\n{\r\nreturn 0;\r\n}\r\nstatic int qib_sdma_6120_busy(struct qib_pportdata *ppd)\r\n{\r\nreturn 0;\r\n}\r\nstatic void qib_sdma_update_6120_tail(struct qib_pportdata *ppd, u16 tail)\r\n{\r\n}\r\nstatic void qib_6120_sdma_sendctrl(struct qib_pportdata *ppd, unsigned op)\r\n{\r\n}\r\nstatic void qib_sdma_set_6120_desc_cnt(struct qib_pportdata *ppd, unsigned cnt)\r\n{\r\n}\r\nstatic u32 qib_6120_setpbc_control(struct qib_pportdata *ppd, u32 plen,\r\nu8 srate, u8 vl)\r\n{\r\nreturn vl == 15 ? PBC_6120_VL15_SEND_CTRL : 0;\r\n}\r\nstatic void qib_6120_initvl15_bufs(struct qib_devdata *dd)\r\n{\r\n}\r\nstatic void qib_6120_init_ctxt(struct qib_ctxtdata *rcd)\r\n{\r\nrcd->rcvegrcnt = rcd->dd->rcvhdrcnt;\r\nrcd->rcvegr_tid_base = rcd->ctxt * rcd->rcvegrcnt;\r\n}\r\nstatic void qib_6120_txchk_change(struct qib_devdata *dd, u32 start,\r\nu32 len, u32 avail, struct qib_ctxtdata *rcd)\r\n{\r\n}\r\nstatic void writescratch(struct qib_devdata *dd, u32 val)\r\n{\r\n(void) qib_write_kreg(dd, kr_scratch, val);\r\n}\r\nstatic int qib_6120_tempsense_rd(struct qib_devdata *dd, int regnum)\r\n{\r\nreturn -ENXIO;\r\n}\r\nstatic int qib_6120_notify_dca(struct qib_devdata *dd, unsigned long event)\r\n{\r\nreturn 0;\r\n}\r\nstatic int qib_6120_eeprom_wen(struct qib_devdata *dd, int wen)\r\n{\r\nreturn 1;\r\n}\r\nstruct qib_devdata *qib_init_iba6120_funcs(struct pci_dev *pdev,\r\nconst struct pci_device_id *ent)\r\n{\r\nstruct qib_devdata *dd;\r\nint ret;\r\ndd = qib_alloc_devdata(pdev, sizeof(struct qib_pportdata) +\r\nsizeof(struct qib_chip_specific));\r\nif (IS_ERR(dd))\r\ngoto bail;\r\ndd->f_bringup_serdes = qib_6120_bringup_serdes;\r\ndd->f_cleanup = qib_6120_setup_cleanup;\r\ndd->f_clear_tids = qib_6120_clear_tids;\r\ndd->f_free_irq = qib_6120_free_irq;\r\ndd->f_get_base_info = qib_6120_get_base_info;\r\ndd->f_get_msgheader = qib_6120_get_msgheader;\r\ndd->f_getsendbuf = qib_6120_getsendbuf;\r\ndd->f_gpio_mod = gpio_6120_mod;\r\ndd->f_eeprom_wen = qib_6120_eeprom_wen;\r\ndd->f_hdrqempty = qib_6120_hdrqempty;\r\ndd->f_ib_updown = qib_6120_ib_updown;\r\ndd->f_init_ctxt = qib_6120_init_ctxt;\r\ndd->f_initvl15_bufs = qib_6120_initvl15_bufs;\r\ndd->f_intr_fallback = qib_6120_nointr_fallback;\r\ndd->f_late_initreg = qib_late_6120_initreg;\r\ndd->f_setpbc_control = qib_6120_setpbc_control;\r\ndd->f_portcntr = qib_portcntr_6120;\r\ndd->f_put_tid = (dd->minrev >= 2) ?\r\nqib_6120_put_tid_2 :\r\nqib_6120_put_tid;\r\ndd->f_quiet_serdes = qib_6120_quiet_serdes;\r\ndd->f_rcvctrl = rcvctrl_6120_mod;\r\ndd->f_read_cntrs = qib_read_6120cntrs;\r\ndd->f_read_portcntrs = qib_read_6120portcntrs;\r\ndd->f_reset = qib_6120_setup_reset;\r\ndd->f_init_sdma_regs = init_sdma_6120_regs;\r\ndd->f_sdma_busy = qib_sdma_6120_busy;\r\ndd->f_sdma_gethead = qib_sdma_6120_gethead;\r\ndd->f_sdma_sendctrl = qib_6120_sdma_sendctrl;\r\ndd->f_sdma_set_desc_cnt = qib_sdma_set_6120_desc_cnt;\r\ndd->f_sdma_update_tail = qib_sdma_update_6120_tail;\r\ndd->f_sendctrl = sendctrl_6120_mod;\r\ndd->f_set_armlaunch = qib_set_6120_armlaunch;\r\ndd->f_set_cntr_sample = qib_set_cntr_6120_sample;\r\ndd->f_iblink_state = qib_6120_iblink_state;\r\ndd->f_ibphys_portstate = qib_6120_phys_portstate;\r\ndd->f_get_ib_cfg = qib_6120_get_ib_cfg;\r\ndd->f_set_ib_cfg = qib_6120_set_ib_cfg;\r\ndd->f_set_ib_loopback = qib_6120_set_loopback;\r\ndd->f_set_intr_state = qib_6120_set_intr_state;\r\ndd->f_setextled = qib_6120_setup_setextled;\r\ndd->f_txchk_change = qib_6120_txchk_change;\r\ndd->f_update_usrhead = qib_update_6120_usrhead;\r\ndd->f_wantpiobuf_intr = qib_wantpiobuf_6120_intr;\r\ndd->f_xgxs_reset = qib_6120_xgxs_reset;\r\ndd->f_writescratch = writescratch;\r\ndd->f_tempsense_rd = qib_6120_tempsense_rd;\r\n#ifdef CONFIG_INFINIBAND_QIB_DCA\r\ndd->f_notify_dca = qib_6120_notify_dca;\r\n#endif\r\nret = qib_pcie_ddinit(dd, pdev, ent);\r\nif (ret < 0)\r\ngoto bail_free;\r\nret = init_6120_variables(dd);\r\nif (ret)\r\ngoto bail_cleanup;\r\nif (qib_mini_init)\r\ngoto bail;\r\nif (qib_pcie_params(dd, 8, NULL, NULL))\r\nqib_dev_err(dd,\r\n"Failed to setup PCIe or interrupts; continuing anyway\n");\r\ndd->cspec->irq = pdev->irq;\r\nqib_write_kreg(dd, kr_hwdiagctrl, 0);\r\nif (qib_read_kreg64(dd, kr_hwerrstatus) &\r\nQLOGIC_IB_HWE_SERDESPLLFAILED)\r\nqib_write_kreg(dd, kr_hwerrclear,\r\nQLOGIC_IB_HWE_SERDESPLLFAILED);\r\nqib_setup_6120_interrupt(dd);\r\nqib_6120_init_hwerrors(dd);\r\ngoto bail;\r\nbail_cleanup:\r\nqib_pcie_ddcleanup(dd);\r\nbail_free:\r\nqib_free_devdata(dd);\r\ndd = ERR_PTR(ret);\r\nbail:\r\nreturn dd;\r\n}
