static struct i2c_client *__add_probed_i2c_device(\r\nconst char *name,\r\nint bus,\r\nstruct i2c_board_info *info,\r\nconst unsigned short *alt_addr_list)\r\n{\r\nconst struct dmi_device *dmi_dev;\r\nconst struct dmi_dev_onboard *dev_data;\r\nstruct i2c_adapter *adapter;\r\nstruct i2c_client *client = NULL;\r\nconst unsigned short addr_list[] = { info->addr, I2C_CLIENT_END };\r\nif (bus < 0)\r\nreturn NULL;\r\nif (name) {\r\ndmi_dev = dmi_find_device(DMI_DEV_TYPE_DEV_ONBOARD, name, NULL);\r\nif (!dmi_dev) {\r\npr_err("%s failed to dmi find device %s.\n",\r\n__func__,\r\nname);\r\nreturn NULL;\r\n}\r\ndev_data = (struct dmi_dev_onboard *)dmi_dev->device_data;\r\nif (!dev_data) {\r\npr_err("%s failed to get data from dmi for %s.\n",\r\n__func__, name);\r\nreturn NULL;\r\n}\r\ninfo->irq = dev_data->instance;\r\n}\r\nadapter = i2c_get_adapter(bus);\r\nif (!adapter) {\r\npr_err("%s failed to get i2c adapter %d.\n", __func__, bus);\r\nreturn NULL;\r\n}\r\nclient = i2c_new_probed_device(adapter, info, addr_list, NULL);\r\nif (!client && alt_addr_list) {\r\nstruct i2c_board_info dummy_info = {\r\nI2C_BOARD_INFO("dummy", info->addr),\r\n};\r\nstruct i2c_client *dummy;\r\ndummy = i2c_new_probed_device(adapter, &dummy_info,\r\nalt_addr_list, NULL);\r\nif (dummy) {\r\npr_debug("%s %d-%02x is probed at %02x\n",\r\n__func__, bus, info->addr, dummy->addr);\r\ni2c_unregister_device(dummy);\r\nclient = i2c_new_device(adapter, info);\r\n}\r\n}\r\nif (!client)\r\npr_notice("%s failed to register device %d-%02x\n",\r\n__func__, bus, info->addr);\r\nelse\r\npr_debug("%s added i2c device %d-%02x\n",\r\n__func__, bus, info->addr);\r\ni2c_put_adapter(adapter);\r\nreturn client;\r\n}\r\nstatic int __find_i2c_adap(struct device *dev, void *data)\r\n{\r\nstruct i2c_lookup *lookup = data;\r\nstatic const char *prefix = "i2c-";\r\nstruct i2c_adapter *adapter;\r\nif (strncmp(dev_name(dev), prefix, strlen(prefix)) != 0)\r\nreturn 0;\r\nadapter = to_i2c_adapter(dev);\r\nif (strncmp(adapter->name, lookup->name, strlen(lookup->name)) == 0 &&\r\nlookup->n++ == lookup->instance)\r\nreturn 1;\r\nreturn 0;\r\n}\r\nstatic int find_i2c_adapter_num(enum i2c_adapter_type type)\r\n{\r\nstruct device *dev = NULL;\r\nstruct i2c_adapter *adapter;\r\nstruct i2c_lookup lookup;\r\nmemset(&lookup, 0, sizeof(lookup));\r\nlookup.name = i2c_adapter_names[type];\r\nlookup.instance = (type == I2C_ADAPTER_DESIGNWARE_1) ? 1 : 0;\r\ndev = bus_find_device(&i2c_bus_type, NULL, &lookup, __find_i2c_adap);\r\nif (!dev) {\r\npr_notice("%s: i2c adapter %s not found on system.\n", __func__,\r\nlookup.name);\r\nreturn -ENODEV;\r\n}\r\nadapter = to_i2c_adapter(dev);\r\nreturn adapter->nr;\r\n}\r\nstatic struct i2c_client *add_probed_i2c_device(\r\nconst char *name,\r\nenum i2c_adapter_type type,\r\nstruct i2c_board_info *info,\r\nconst unsigned short *addrs)\r\n{\r\nreturn __add_probed_i2c_device(name,\r\nfind_i2c_adapter_num(type),\r\ninfo,\r\naddrs);\r\n}\r\nstatic struct i2c_client *add_i2c_device(const char *name,\r\nenum i2c_adapter_type type,\r\nstruct i2c_board_info *info)\r\n{\r\nreturn __add_probed_i2c_device(name,\r\nfind_i2c_adapter_num(type),\r\ninfo,\r\nNULL);\r\n}\r\nstatic int setup_cyapa_tp(enum i2c_adapter_type type)\r\n{\r\nif (tp)\r\nreturn 0;\r\ntp = add_i2c_device("trackpad", type, &cyapa_device);\r\nreturn (!tp) ? -EAGAIN : 0;\r\n}\r\nstatic int setup_atmel_224s_tp(enum i2c_adapter_type type)\r\n{\r\nconst unsigned short addr_list[] = { ATMEL_TP_I2C_BL_ADDR,\r\nI2C_CLIENT_END };\r\nif (tp)\r\nreturn 0;\r\ntp = add_probed_i2c_device("trackpad", type,\r\n&atmel_224s_tp_device, addr_list);\r\nreturn (!tp) ? -EAGAIN : 0;\r\n}\r\nstatic int setup_atmel_1664s_ts(enum i2c_adapter_type type)\r\n{\r\nconst unsigned short addr_list[] = { ATMEL_TS_I2C_BL_ADDR,\r\nI2C_CLIENT_END };\r\nif (ts)\r\nreturn 0;\r\nts = add_probed_i2c_device("touchscreen", type,\r\n&atmel_1664s_device, addr_list);\r\nreturn (!ts) ? -EAGAIN : 0;\r\n}\r\nstatic int setup_isl29018_als(enum i2c_adapter_type type)\r\n{\r\nif (als)\r\nreturn 0;\r\nals = add_i2c_device("lightsensor", type, &isl_als_device);\r\nreturn (!als) ? -EAGAIN : 0;\r\n}\r\nstatic int setup_tsl2583_als(enum i2c_adapter_type type)\r\n{\r\nif (als)\r\nreturn 0;\r\nals = add_i2c_device(NULL, type, &tsl2583_als_device);\r\nreturn (!als) ? -EAGAIN : 0;\r\n}\r\nstatic int setup_tsl2563_als(enum i2c_adapter_type type)\r\n{\r\nif (als)\r\nreturn 0;\r\nals = add_i2c_device(NULL, type, &tsl2563_als_device);\r\nreturn (!als) ? -EAGAIN : 0;\r\n}\r\nstatic int __init chromeos_laptop_dmi_matched(const struct dmi_system_id *id)\r\n{\r\ncros_laptop = (void *)id->driver_data;\r\npr_debug("DMI Matched %s.\n", id->ident);\r\nreturn 1;\r\n}\r\nstatic int chromeos_laptop_probe(struct platform_device *pdev)\r\n{\r\nint i;\r\nint ret = 0;\r\nfor (i = 0; i < MAX_I2C_PERIPHERALS; i++) {\r\nstruct i2c_peripheral *i2c_dev;\r\ni2c_dev = &cros_laptop->i2c_peripherals[i];\r\nif (i2c_dev->add == NULL)\r\nbreak;\r\nif (i2c_dev->state == TIMEDOUT || i2c_dev->state == PROBED)\r\ncontinue;\r\nif (find_i2c_adapter_num(i2c_dev->type) == -ENODEV) {\r\nret = -EPROBE_DEFER;\r\ncontinue;\r\n}\r\nif (i2c_dev->add(i2c_dev->type) == -EAGAIN) {\r\nif (++i2c_dev->tries < MAX_I2C_DEVICE_DEFERRALS) {\r\nret = -EPROBE_DEFER;\r\n} else {\r\npr_notice("%s: Ran out of tries for device.\n",\r\n__func__);\r\ni2c_dev->state = TIMEDOUT;\r\n}\r\n} else {\r\ni2c_dev->state = PROBED;\r\n}\r\n}\r\nreturn ret;\r\n}\r\nstatic int __init chromeos_laptop_init(void)\r\n{\r\nint ret;\r\nif (!dmi_check_system(chromeos_laptop_dmi_table)) {\r\npr_debug("%s unsupported system.\n", __func__);\r\nreturn -ENODEV;\r\n}\r\nret = platform_driver_register(&cros_platform_driver);\r\nif (ret)\r\nreturn ret;\r\ncros_platform_device = platform_device_alloc("chromeos_laptop", -1);\r\nif (!cros_platform_device) {\r\nret = -ENOMEM;\r\ngoto fail_platform_device1;\r\n}\r\nret = platform_device_add(cros_platform_device);\r\nif (ret)\r\ngoto fail_platform_device2;\r\nreturn 0;\r\nfail_platform_device2:\r\nplatform_device_put(cros_platform_device);\r\nfail_platform_device1:\r\nplatform_driver_unregister(&cros_platform_driver);\r\nreturn ret;\r\n}\r\nstatic void __exit chromeos_laptop_exit(void)\r\n{\r\nif (als)\r\ni2c_unregister_device(als);\r\nif (tp)\r\ni2c_unregister_device(tp);\r\nif (ts)\r\ni2c_unregister_device(ts);\r\nplatform_device_unregister(cros_platform_device);\r\nplatform_driver_unregister(&cros_platform_driver);\r\n}
