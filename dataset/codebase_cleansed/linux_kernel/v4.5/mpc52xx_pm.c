static int mpc52xx_pm_valid(suspend_state_t state)\r\n{\r\nswitch (state) {\r\ncase PM_SUSPEND_STANDBY:\r\nreturn 1;\r\ndefault:\r\nreturn 0;\r\n}\r\n}\r\nint mpc52xx_set_wakeup_gpio(u8 pin, u8 level)\r\n{\r\nu16 tmp;\r\nout_8(&gpiow->wkup_gpioe, in_8(&gpiow->wkup_gpioe) | (1 << pin));\r\nout_8(&gpiow->wkup_ddr, in_8(&gpiow->wkup_ddr) & ~(1 << pin));\r\nout_8(&gpiow->wkup_inten, in_8(&gpiow->wkup_inten) | (1 << pin));\r\ntmp = in_be16(&gpiow->wkup_itype);\r\ntmp &= ~(0x3 << (pin * 2));\r\ntmp |= (!level + 1) << (pin * 2);\r\nout_be16(&gpiow->wkup_itype, tmp);\r\nout_8(&gpiow->wkup_maste, 1);\r\nreturn 0;\r\n}\r\nint mpc52xx_pm_prepare(void)\r\n{\r\nstruct device_node *np;\r\nconst struct of_device_id immr_ids[] = {\r\n{ .compatible = "fsl,mpc5200-immr", },\r\n{ .compatible = "fsl,mpc5200b-immr", },\r\n{ .type = "soc", .compatible = "mpc5200", },\r\n{ .type = "builtin", .compatible = "mpc5200", },\r\n{}\r\n};\r\nstruct resource res;\r\nnp = of_find_matching_node(NULL, immr_ids);\r\nif (of_address_to_resource(np, 0, &res)) {\r\npr_err("mpc52xx_pm_prepare(): could not get IMMR address\n");\r\nof_node_put(np);\r\nreturn -ENOSYS;\r\n}\r\nmbar = ioremap(res.start, 0xc000);\r\nof_node_put(np);\r\nif (!mbar) {\r\npr_err("mpc52xx_pm_prepare(): could not map registers\n");\r\nreturn -ENOSYS;\r\n}\r\nsdram = mbar + 0x100;\r\ncdm = mbar + 0x200;\r\nintr = mbar + 0x500;\r\ngpiow = mbar + 0xc00;\r\nsram = mbar + 0x8000;\r\nsram_size = 0x4000;\r\nif (mpc52xx_suspend.board_suspend_prepare)\r\nmpc52xx_suspend.board_suspend_prepare(mbar);\r\nelse {\r\nprintk(KERN_ALERT "%s: %i don't know how to wake up the board\n",\r\n__func__, __LINE__);\r\ngoto out_unmap;\r\n}\r\nreturn 0;\r\nout_unmap:\r\niounmap(mbar);\r\nreturn -ENOSYS;\r\n}\r\nint mpc52xx_pm_enter(suspend_state_t state)\r\n{\r\nu32 clk_enables;\r\nu32 msr, hid0;\r\nu32 intr_main_mask;\r\nvoid __iomem * irq_0x500 = (void __iomem *)CONFIG_KERNEL_START + 0x500;\r\nunsigned long irq_0x500_stop = (unsigned long)irq_0x500 + mpc52xx_ds_cached_size;\r\nchar saved_0x500[mpc52xx_ds_cached_size];\r\nintr_main_mask = in_be32(&intr->main_mask);\r\nout_be32(&intr->main_mask, intr_main_mask | 0x1ffff);\r\nmtspr(SPRN_DEC, 0x7fffffff);\r\nmemcpy(saved_sram, sram, sram_size);\r\nmemcpy(sram, mpc52xx_ds_sram, mpc52xx_ds_sram_size);\r\nout_8(&cdm->ccs_sleep_enable, 1);\r\nout_8(&cdm->osc_sleep_enable, 1);\r\nout_8(&cdm->ccs_qreq_test, 1);\r\nclk_enables = in_be32(&cdm->clk_enables);\r\nout_be32(&cdm->clk_enables, clk_enables & 0x00088000);\r\nmsr = mfmsr();\r\nmtmsr(msr & ~MSR_POW);\r\nhid0 = mfspr(SPRN_HID0);\r\nmtspr(SPRN_HID0, (hid0 & ~(HID0_DOZE | HID0_NAP | HID0_DPM)) | HID0_SLEEP);\r\nmemcpy(saved_0x500, irq_0x500, mpc52xx_ds_cached_size);\r\nmemcpy(irq_0x500, mpc52xx_ds_cached, mpc52xx_ds_cached_size);\r\nflush_icache_range((unsigned long)irq_0x500, irq_0x500_stop);\r\nmpc52xx_deep_sleep(sram, sdram, cdm, intr);\r\nmemcpy(irq_0x500, saved_0x500, mpc52xx_ds_cached_size);\r\nflush_icache_range((unsigned long)irq_0x500, irq_0x500_stop);\r\nmtmsr(msr & ~MSR_POW);\r\nmtspr(SPRN_HID0, hid0);\r\nmtmsr(msr);\r\nout_be32(&cdm->clk_enables, clk_enables);\r\nout_8(&cdm->ccs_sleep_enable, 0);\r\nout_8(&cdm->osc_sleep_enable, 0);\r\nmemcpy(sram, saved_sram, sram_size);\r\nout_be32(&intr->main_mask, intr_main_mask);\r\nreturn 0;\r\n}\r\nvoid mpc52xx_pm_finish(void)\r\n{\r\nif (mpc52xx_suspend.board_resume_finish)\r\nmpc52xx_suspend.board_resume_finish(mbar);\r\niounmap(mbar);\r\n}\r\nint __init mpc52xx_pm_init(void)\r\n{\r\nsuspend_set_ops(&mpc52xx_pm_ops);\r\nreturn 0;\r\n}
