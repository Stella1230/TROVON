static inline int local_sid_setup_one(struct id *entry)\r\n{\r\nunsigned long sid;\r\nint ret = -1;\r\nsid = __this_cpu_inc_return(pcpu_last_used_sid);\r\nif (sid < NUM_TIDS) {\r\n__this_cpu_write(pcpu_sids.entry[sid], entry);\r\nentry->val = sid;\r\nentry->pentry = this_cpu_ptr(&pcpu_sids.entry[sid]);\r\nret = sid;\r\n}\r\nWARN_ON(sid > NUM_TIDS);\r\nreturn ret;\r\n}\r\nstatic inline int local_sid_lookup(struct id *entry)\r\n{\r\nif (entry && entry->val != 0 &&\r\n__this_cpu_read(pcpu_sids.entry[entry->val]) == entry &&\r\nentry->pentry == this_cpu_ptr(&pcpu_sids.entry[entry->val]))\r\nreturn entry->val;\r\nreturn -1;\r\n}\r\nstatic inline void local_sid_destroy_all(void)\r\n{\r\n__this_cpu_write(pcpu_last_used_sid, 0);\r\nmemset(this_cpu_ptr(&pcpu_sids), 0, sizeof(pcpu_sids));\r\n}\r\nstatic void *kvmppc_e500_id_table_alloc(struct kvmppc_vcpu_e500 *vcpu_e500)\r\n{\r\nvcpu_e500->idt = kzalloc(sizeof(struct vcpu_id_table), GFP_KERNEL);\r\nreturn vcpu_e500->idt;\r\n}\r\nstatic void kvmppc_e500_id_table_free(struct kvmppc_vcpu_e500 *vcpu_e500)\r\n{\r\nkfree(vcpu_e500->idt);\r\nvcpu_e500->idt = NULL;\r\n}\r\nstatic void kvmppc_e500_recalc_shadow_pid(struct kvmppc_vcpu_e500 *vcpu_e500)\r\n{\r\npreempt_disable();\r\nvcpu_e500->vcpu.arch.shadow_pid = kvmppc_e500_get_sid(vcpu_e500,\r\nget_cur_as(&vcpu_e500->vcpu),\r\nget_cur_pid(&vcpu_e500->vcpu),\r\nget_cur_pr(&vcpu_e500->vcpu), 1);\r\nvcpu_e500->vcpu.arch.shadow_pid1 = kvmppc_e500_get_sid(vcpu_e500,\r\nget_cur_as(&vcpu_e500->vcpu), 0,\r\nget_cur_pr(&vcpu_e500->vcpu), 1);\r\npreempt_enable();\r\n}\r\nstatic void kvmppc_e500_id_table_reset_all(struct kvmppc_vcpu_e500 *vcpu_e500)\r\n{\r\nmemset(vcpu_e500->idt, 0, sizeof(struct vcpu_id_table));\r\nkvmppc_e500_recalc_shadow_pid(vcpu_e500);\r\n}\r\nstatic inline void kvmppc_e500_id_table_reset_one(\r\nstruct kvmppc_vcpu_e500 *vcpu_e500,\r\nint as, int pid, int pr)\r\n{\r\nstruct vcpu_id_table *idt = vcpu_e500->idt;\r\nBUG_ON(as >= 2);\r\nBUG_ON(pid >= NUM_TIDS);\r\nBUG_ON(pr >= 2);\r\nidt->id[as][pid][pr].val = 0;\r\nidt->id[as][pid][pr].pentry = NULL;\r\nkvmppc_e500_recalc_shadow_pid(vcpu_e500);\r\n}\r\nunsigned int kvmppc_e500_get_sid(struct kvmppc_vcpu_e500 *vcpu_e500,\r\nunsigned int as, unsigned int gid,\r\nunsigned int pr, int avoid_recursion)\r\n{\r\nstruct vcpu_id_table *idt = vcpu_e500->idt;\r\nint sid;\r\nBUG_ON(as >= 2);\r\nBUG_ON(gid >= NUM_TIDS);\r\nBUG_ON(pr >= 2);\r\nsid = local_sid_lookup(&idt->id[as][gid][pr]);\r\nwhile (sid <= 0) {\r\nsid = local_sid_setup_one(&idt->id[as][gid][pr]);\r\nif (sid <= 0) {\r\n_tlbil_all();\r\nlocal_sid_destroy_all();\r\n}\r\nif (!avoid_recursion)\r\nkvmppc_e500_recalc_shadow_pid(vcpu_e500);\r\n}\r\nreturn sid;\r\n}\r\nunsigned int kvmppc_e500_get_tlb_stid(struct kvm_vcpu *vcpu,\r\nstruct kvm_book3e_206_tlb_entry *gtlbe)\r\n{\r\nreturn kvmppc_e500_get_sid(to_e500(vcpu), get_tlb_ts(gtlbe),\r\nget_tlb_tid(gtlbe), get_cur_pr(vcpu), 0);\r\n}\r\nvoid kvmppc_set_pid(struct kvm_vcpu *vcpu, u32 pid)\r\n{\r\nstruct kvmppc_vcpu_e500 *vcpu_e500 = to_e500(vcpu);\r\nif (vcpu->arch.pid != pid) {\r\nvcpu_e500->pid[0] = vcpu->arch.pid = pid;\r\nkvmppc_e500_recalc_shadow_pid(vcpu_e500);\r\n}\r\n}\r\nvoid kvmppc_e500_tlbil_one(struct kvmppc_vcpu_e500 *vcpu_e500,\r\nstruct kvm_book3e_206_tlb_entry *gtlbe)\r\n{\r\nstruct vcpu_id_table *idt = vcpu_e500->idt;\r\nunsigned int pr, tid, ts;\r\nint pid;\r\nu32 val, eaddr;\r\nunsigned long flags;\r\nts = get_tlb_ts(gtlbe);\r\ntid = get_tlb_tid(gtlbe);\r\npreempt_disable();\r\nfor (pr = 0; pr < 2; pr++) {\r\npid = local_sid_lookup(&idt->id[ts][tid][pr]);\r\nif (pid <= 0) {\r\nkvmppc_e500_id_table_reset_one(vcpu_e500, ts, tid, pr);\r\ncontinue;\r\n}\r\nval = (pid << MAS6_SPID_SHIFT) | MAS6_SAS;\r\neaddr = get_tlb_eaddr(gtlbe);\r\nlocal_irq_save(flags);\r\nmtspr(SPRN_MAS6, val);\r\nasm volatile("tlbsx 0, %[eaddr]" : : [eaddr] "r" (eaddr));\r\nval = mfspr(SPRN_MAS1);\r\nif (val & MAS1_VALID) {\r\nmtspr(SPRN_MAS1, val & ~MAS1_VALID);\r\nasm volatile("tlbwe");\r\n}\r\nlocal_irq_restore(flags);\r\n}\r\npreempt_enable();\r\n}\r\nvoid kvmppc_e500_tlbil_all(struct kvmppc_vcpu_e500 *vcpu_e500)\r\n{\r\nkvmppc_e500_id_table_reset_all(vcpu_e500);\r\n}\r\nvoid kvmppc_mmu_msr_notify(struct kvm_vcpu *vcpu, u32 old_msr)\r\n{\r\nkvmppc_e500_recalc_shadow_pid(to_e500(vcpu));\r\n}\r\nstatic void kvmppc_core_vcpu_load_e500(struct kvm_vcpu *vcpu, int cpu)\r\n{\r\nkvmppc_booke_vcpu_load(vcpu, cpu);\r\nkvmppc_e500_recalc_shadow_pid(to_e500(vcpu));\r\n}\r\nstatic void kvmppc_core_vcpu_put_e500(struct kvm_vcpu *vcpu)\r\n{\r\n#ifdef CONFIG_SPE\r\nif (vcpu->arch.shadow_msr & MSR_SPE)\r\nkvmppc_vcpu_disable_spe(vcpu);\r\n#endif\r\nkvmppc_booke_vcpu_put(vcpu);\r\n}\r\nint kvmppc_core_check_processor_compat(void)\r\n{\r\nint r;\r\nif (strcmp(cur_cpu_spec->cpu_name, "e500v2") == 0)\r\nr = 0;\r\nelse\r\nr = -ENOTSUPP;\r\nreturn r;\r\n}\r\nstatic void kvmppc_e500_tlb_setup(struct kvmppc_vcpu_e500 *vcpu_e500)\r\n{\r\nstruct kvm_book3e_206_tlb_entry *tlbe;\r\ntlbe = get_entry(vcpu_e500, 1, 0);\r\ntlbe->mas1 = MAS1_VALID | MAS1_TSIZE(BOOK3E_PAGESZ_256M);\r\ntlbe->mas2 = 0;\r\ntlbe->mas7_3 = E500_TLB_SUPER_PERM_MASK;\r\ntlbe = get_entry(vcpu_e500, 1, 1);\r\ntlbe->mas1 = MAS1_VALID | MAS1_TSIZE(BOOK3E_PAGESZ_4K);\r\ntlbe->mas2 = (0xe0004500 & 0xFFFFF000) | MAS2_I | MAS2_G;\r\ntlbe->mas7_3 = (0xe0004500 & 0xFFFFF000) | E500_TLB_SUPER_PERM_MASK;\r\n}\r\nint kvmppc_core_vcpu_setup(struct kvm_vcpu *vcpu)\r\n{\r\nstruct kvmppc_vcpu_e500 *vcpu_e500 = to_e500(vcpu);\r\nkvmppc_e500_tlb_setup(vcpu_e500);\r\nvcpu->arch.pvr = mfspr(SPRN_PVR);\r\nvcpu_e500->svr = mfspr(SPRN_SVR);\r\nvcpu->arch.cpu_type = KVM_CPU_E500V2;\r\nreturn 0;\r\n}\r\nstatic int kvmppc_core_get_sregs_e500(struct kvm_vcpu *vcpu,\r\nstruct kvm_sregs *sregs)\r\n{\r\nstruct kvmppc_vcpu_e500 *vcpu_e500 = to_e500(vcpu);\r\nsregs->u.e.features |= KVM_SREGS_E_ARCH206_MMU | KVM_SREGS_E_SPE |\r\nKVM_SREGS_E_PM;\r\nsregs->u.e.impl_id = KVM_SREGS_E_IMPL_FSL;\r\nsregs->u.e.impl.fsl.features = 0;\r\nsregs->u.e.impl.fsl.svr = vcpu_e500->svr;\r\nsregs->u.e.impl.fsl.hid0 = vcpu_e500->hid0;\r\nsregs->u.e.impl.fsl.mcar = vcpu_e500->mcar;\r\nsregs->u.e.ivor_high[0] = vcpu->arch.ivor[BOOKE_IRQPRIO_SPE_UNAVAIL];\r\nsregs->u.e.ivor_high[1] = vcpu->arch.ivor[BOOKE_IRQPRIO_SPE_FP_DATA];\r\nsregs->u.e.ivor_high[2] = vcpu->arch.ivor[BOOKE_IRQPRIO_SPE_FP_ROUND];\r\nsregs->u.e.ivor_high[3] =\r\nvcpu->arch.ivor[BOOKE_IRQPRIO_PERFORMANCE_MONITOR];\r\nkvmppc_get_sregs_ivor(vcpu, sregs);\r\nkvmppc_get_sregs_e500_tlb(vcpu, sregs);\r\nreturn 0;\r\n}\r\nstatic int kvmppc_core_set_sregs_e500(struct kvm_vcpu *vcpu,\r\nstruct kvm_sregs *sregs)\r\n{\r\nstruct kvmppc_vcpu_e500 *vcpu_e500 = to_e500(vcpu);\r\nint ret;\r\nif (sregs->u.e.impl_id == KVM_SREGS_E_IMPL_FSL) {\r\nvcpu_e500->svr = sregs->u.e.impl.fsl.svr;\r\nvcpu_e500->hid0 = sregs->u.e.impl.fsl.hid0;\r\nvcpu_e500->mcar = sregs->u.e.impl.fsl.mcar;\r\n}\r\nret = kvmppc_set_sregs_e500_tlb(vcpu, sregs);\r\nif (ret < 0)\r\nreturn ret;\r\nif (!(sregs->u.e.features & KVM_SREGS_E_IVOR))\r\nreturn 0;\r\nif (sregs->u.e.features & KVM_SREGS_E_SPE) {\r\nvcpu->arch.ivor[BOOKE_IRQPRIO_SPE_UNAVAIL] =\r\nsregs->u.e.ivor_high[0];\r\nvcpu->arch.ivor[BOOKE_IRQPRIO_SPE_FP_DATA] =\r\nsregs->u.e.ivor_high[1];\r\nvcpu->arch.ivor[BOOKE_IRQPRIO_SPE_FP_ROUND] =\r\nsregs->u.e.ivor_high[2];\r\n}\r\nif (sregs->u.e.features & KVM_SREGS_E_PM) {\r\nvcpu->arch.ivor[BOOKE_IRQPRIO_PERFORMANCE_MONITOR] =\r\nsregs->u.e.ivor_high[3];\r\n}\r\nreturn kvmppc_set_sregs_ivor(vcpu, sregs);\r\n}\r\nstatic int kvmppc_get_one_reg_e500(struct kvm_vcpu *vcpu, u64 id,\r\nunion kvmppc_one_reg *val)\r\n{\r\nint r = kvmppc_get_one_reg_e500_tlb(vcpu, id, val);\r\nreturn r;\r\n}\r\nstatic int kvmppc_set_one_reg_e500(struct kvm_vcpu *vcpu, u64 id,\r\nunion kvmppc_one_reg *val)\r\n{\r\nint r = kvmppc_get_one_reg_e500_tlb(vcpu, id, val);\r\nreturn r;\r\n}\r\nstatic struct kvm_vcpu *kvmppc_core_vcpu_create_e500(struct kvm *kvm,\r\nunsigned int id)\r\n{\r\nstruct kvmppc_vcpu_e500 *vcpu_e500;\r\nstruct kvm_vcpu *vcpu;\r\nint err;\r\nvcpu_e500 = kmem_cache_zalloc(kvm_vcpu_cache, GFP_KERNEL);\r\nif (!vcpu_e500) {\r\nerr = -ENOMEM;\r\ngoto out;\r\n}\r\nvcpu = &vcpu_e500->vcpu;\r\nerr = kvm_vcpu_init(vcpu, kvm, id);\r\nif (err)\r\ngoto free_vcpu;\r\nif (kvmppc_e500_id_table_alloc(vcpu_e500) == NULL)\r\ngoto uninit_vcpu;\r\nerr = kvmppc_e500_tlb_init(vcpu_e500);\r\nif (err)\r\ngoto uninit_id;\r\nvcpu->arch.shared = (void*)__get_free_page(GFP_KERNEL|__GFP_ZERO);\r\nif (!vcpu->arch.shared)\r\ngoto uninit_tlb;\r\nreturn vcpu;\r\nuninit_tlb:\r\nkvmppc_e500_tlb_uninit(vcpu_e500);\r\nuninit_id:\r\nkvmppc_e500_id_table_free(vcpu_e500);\r\nuninit_vcpu:\r\nkvm_vcpu_uninit(vcpu);\r\nfree_vcpu:\r\nkmem_cache_free(kvm_vcpu_cache, vcpu_e500);\r\nout:\r\nreturn ERR_PTR(err);\r\n}\r\nstatic void kvmppc_core_vcpu_free_e500(struct kvm_vcpu *vcpu)\r\n{\r\nstruct kvmppc_vcpu_e500 *vcpu_e500 = to_e500(vcpu);\r\nfree_page((unsigned long)vcpu->arch.shared);\r\nkvmppc_e500_tlb_uninit(vcpu_e500);\r\nkvmppc_e500_id_table_free(vcpu_e500);\r\nkvm_vcpu_uninit(vcpu);\r\nkmem_cache_free(kvm_vcpu_cache, vcpu_e500);\r\n}\r\nstatic int kvmppc_core_init_vm_e500(struct kvm *kvm)\r\n{\r\nreturn 0;\r\n}\r\nstatic void kvmppc_core_destroy_vm_e500(struct kvm *kvm)\r\n{\r\n}\r\nstatic int __init kvmppc_e500_init(void)\r\n{\r\nint r, i;\r\nunsigned long ivor[3];\r\nunsigned long *handler = &kvmppc_booke_handler_addr[16];\r\nunsigned long handler_len;\r\nunsigned long max_ivor = 0;\r\nr = kvmppc_core_check_processor_compat();\r\nif (r)\r\ngoto err_out;\r\nr = kvmppc_booke_init();\r\nif (r)\r\ngoto err_out;\r\nivor[0] = mfspr(SPRN_IVOR32);\r\nivor[1] = mfspr(SPRN_IVOR33);\r\nivor[2] = mfspr(SPRN_IVOR34);\r\nfor (i = 0; i < 3; i++) {\r\nif (ivor[i] > ivor[max_ivor])\r\nmax_ivor = i;\r\nhandler_len = handler[i + 1] - handler[i];\r\nmemcpy((void *)kvmppc_booke_handlers + ivor[i],\r\n(void *)handler[i], handler_len);\r\n}\r\nhandler_len = handler[max_ivor + 1] - handler[max_ivor];\r\nflush_icache_range(kvmppc_booke_handlers, kvmppc_booke_handlers +\r\nivor[max_ivor] + handler_len);\r\nr = kvm_init(NULL, sizeof(struct kvmppc_vcpu_e500), 0, THIS_MODULE);\r\nif (r)\r\ngoto err_out;\r\nkvm_ops_e500.owner = THIS_MODULE;\r\nkvmppc_pr_ops = &kvm_ops_e500;\r\nerr_out:\r\nreturn r;\r\n}\r\nstatic void __exit kvmppc_e500_exit(void)\r\n{\r\nkvmppc_pr_ops = NULL;\r\nkvmppc_booke_exit();\r\n}
