bool libceph_compatible(void *data)\r\n{\r\nreturn true;\r\n}\r\nconst char *ceph_file_part(const char *s, int len)\r\n{\r\nconst char *e = s + len;\r\nwhile (e != s && *(e-1) != '/')\r\ne--;\r\nreturn e;\r\n}\r\nconst char *ceph_msg_type_name(int type)\r\n{\r\nswitch (type) {\r\ncase CEPH_MSG_SHUTDOWN: return "shutdown";\r\ncase CEPH_MSG_PING: return "ping";\r\ncase CEPH_MSG_AUTH: return "auth";\r\ncase CEPH_MSG_AUTH_REPLY: return "auth_reply";\r\ncase CEPH_MSG_MON_MAP: return "mon_map";\r\ncase CEPH_MSG_MON_GET_MAP: return "mon_get_map";\r\ncase CEPH_MSG_MON_SUBSCRIBE: return "mon_subscribe";\r\ncase CEPH_MSG_MON_SUBSCRIBE_ACK: return "mon_subscribe_ack";\r\ncase CEPH_MSG_STATFS: return "statfs";\r\ncase CEPH_MSG_STATFS_REPLY: return "statfs_reply";\r\ncase CEPH_MSG_MON_GET_VERSION: return "mon_get_version";\r\ncase CEPH_MSG_MON_GET_VERSION_REPLY: return "mon_get_version_reply";\r\ncase CEPH_MSG_MDS_MAP: return "mds_map";\r\ncase CEPH_MSG_CLIENT_SESSION: return "client_session";\r\ncase CEPH_MSG_CLIENT_RECONNECT: return "client_reconnect";\r\ncase CEPH_MSG_CLIENT_REQUEST: return "client_request";\r\ncase CEPH_MSG_CLIENT_REQUEST_FORWARD: return "client_request_forward";\r\ncase CEPH_MSG_CLIENT_REPLY: return "client_reply";\r\ncase CEPH_MSG_CLIENT_CAPS: return "client_caps";\r\ncase CEPH_MSG_CLIENT_CAPRELEASE: return "client_cap_release";\r\ncase CEPH_MSG_CLIENT_SNAP: return "client_snap";\r\ncase CEPH_MSG_CLIENT_LEASE: return "client_lease";\r\ncase CEPH_MSG_OSD_MAP: return "osd_map";\r\ncase CEPH_MSG_OSD_OP: return "osd_op";\r\ncase CEPH_MSG_OSD_OPREPLY: return "osd_opreply";\r\ncase CEPH_MSG_WATCH_NOTIFY: return "watch_notify";\r\ndefault: return "unknown";\r\n}\r\n}\r\nint ceph_check_fsid(struct ceph_client *client, struct ceph_fsid *fsid)\r\n{\r\nif (client->have_fsid) {\r\nif (ceph_fsid_compare(&client->fsid, fsid)) {\r\npr_err("bad fsid, had %pU got %pU",\r\n&client->fsid, fsid);\r\nreturn -1;\r\n}\r\n} else {\r\nmemcpy(&client->fsid, fsid, sizeof(*fsid));\r\n}\r\nreturn 0;\r\n}\r\nstatic int strcmp_null(const char *s1, const char *s2)\r\n{\r\nif (!s1 && !s2)\r\nreturn 0;\r\nif (s1 && !s2)\r\nreturn -1;\r\nif (!s1 && s2)\r\nreturn 1;\r\nreturn strcmp(s1, s2);\r\n}\r\nint ceph_compare_options(struct ceph_options *new_opt,\r\nstruct ceph_client *client)\r\n{\r\nstruct ceph_options *opt1 = new_opt;\r\nstruct ceph_options *opt2 = client->options;\r\nint ofs = offsetof(struct ceph_options, mon_addr);\r\nint i;\r\nint ret;\r\nif (!net_eq(current->nsproxy->net_ns, read_pnet(&client->msgr.net)))\r\nreturn -1;\r\nret = memcmp(opt1, opt2, ofs);\r\nif (ret)\r\nreturn ret;\r\nret = strcmp_null(opt1->name, opt2->name);\r\nif (ret)\r\nreturn ret;\r\nif (opt1->key && !opt2->key)\r\nreturn -1;\r\nif (!opt1->key && opt2->key)\r\nreturn 1;\r\nif (opt1->key && opt2->key) {\r\nif (opt1->key->type != opt2->key->type)\r\nreturn -1;\r\nif (opt1->key->created.tv_sec != opt2->key->created.tv_sec)\r\nreturn -1;\r\nif (opt1->key->created.tv_nsec != opt2->key->created.tv_nsec)\r\nreturn -1;\r\nif (opt1->key->len != opt2->key->len)\r\nreturn -1;\r\nif (opt1->key->key && !opt2->key->key)\r\nreturn -1;\r\nif (!opt1->key->key && opt2->key->key)\r\nreturn 1;\r\nif (opt1->key->key && opt2->key->key) {\r\nret = memcmp(opt1->key->key, opt2->key->key, opt1->key->len);\r\nif (ret)\r\nreturn ret;\r\n}\r\n}\r\nfor (i = 0; i < opt1->num_mon; i++) {\r\nif (ceph_monmap_contains(client->monc.monmap,\r\n&opt1->mon_addr[i]))\r\nreturn 0;\r\n}\r\nreturn -1;\r\n}\r\nvoid *ceph_kvmalloc(size_t size, gfp_t flags)\r\n{\r\nif (size <= (PAGE_SIZE << PAGE_ALLOC_COSTLY_ORDER)) {\r\nvoid *ptr = kmalloc(size, flags | __GFP_NOWARN);\r\nif (ptr)\r\nreturn ptr;\r\n}\r\nreturn __vmalloc(size, flags | __GFP_HIGHMEM, PAGE_KERNEL);\r\n}\r\nstatic int parse_fsid(const char *str, struct ceph_fsid *fsid)\r\n{\r\nint i = 0;\r\nchar tmp[3];\r\nint err = -EINVAL;\r\nint d;\r\ndout("parse_fsid '%s'\n", str);\r\ntmp[2] = 0;\r\nwhile (*str && i < 16) {\r\nif (ispunct(*str)) {\r\nstr++;\r\ncontinue;\r\n}\r\nif (!isxdigit(str[0]) || !isxdigit(str[1]))\r\nbreak;\r\ntmp[0] = str[0];\r\ntmp[1] = str[1];\r\nif (sscanf(tmp, "%x", &d) < 1)\r\nbreak;\r\nfsid->fsid[i] = d & 0xff;\r\ni++;\r\nstr += 2;\r\n}\r\nif (i == 16)\r\nerr = 0;\r\ndout("parse_fsid ret %d got fsid %pU", err, fsid);\r\nreturn err;\r\n}\r\nvoid ceph_destroy_options(struct ceph_options *opt)\r\n{\r\ndout("destroy_options %p\n", opt);\r\nkfree(opt->name);\r\nif (opt->key) {\r\nceph_crypto_key_destroy(opt->key);\r\nkfree(opt->key);\r\n}\r\nkfree(opt->mon_addr);\r\nkfree(opt);\r\n}\r\nstatic int get_secret(struct ceph_crypto_key *dst, const char *name) {\r\nstruct key *ukey;\r\nint key_err;\r\nint err = 0;\r\nstruct ceph_crypto_key *ckey;\r\nukey = request_key(&key_type_ceph, name, NULL);\r\nif (!ukey || IS_ERR(ukey)) {\r\nkey_err = PTR_ERR(ukey);\r\nswitch (key_err) {\r\ncase -ENOKEY:\r\npr_warn("ceph: Mount failed due to key not found: %s\n",\r\nname);\r\nbreak;\r\ncase -EKEYEXPIRED:\r\npr_warn("ceph: Mount failed due to expired key: %s\n",\r\nname);\r\nbreak;\r\ncase -EKEYREVOKED:\r\npr_warn("ceph: Mount failed due to revoked key: %s\n",\r\nname);\r\nbreak;\r\ndefault:\r\npr_warn("ceph: Mount failed due to unknown key error %d: %s\n",\r\nkey_err, name);\r\n}\r\nerr = -EPERM;\r\ngoto out;\r\n}\r\nckey = ukey->payload.data[0];\r\nerr = ceph_crypto_key_clone(dst, ckey);\r\nif (err)\r\ngoto out_key;\r\nout_key:\r\nkey_put(ukey);\r\nout:\r\nreturn err;\r\n}\r\nstruct ceph_options *\r\nceph_parse_options(char *options, const char *dev_name,\r\nconst char *dev_name_end,\r\nint (*parse_extra_token)(char *c, void *private),\r\nvoid *private)\r\n{\r\nstruct ceph_options *opt;\r\nconst char *c;\r\nint err = -ENOMEM;\r\nsubstring_t argstr[MAX_OPT_ARGS];\r\nopt = kzalloc(sizeof(*opt), GFP_KERNEL);\r\nif (!opt)\r\nreturn ERR_PTR(-ENOMEM);\r\nopt->mon_addr = kcalloc(CEPH_MAX_MON, sizeof(*opt->mon_addr),\r\nGFP_KERNEL);\r\nif (!opt->mon_addr)\r\ngoto out;\r\ndout("parse_options %p options '%s' dev_name '%s'\n", opt, options,\r\ndev_name);\r\nopt->flags = CEPH_OPT_DEFAULT;\r\nopt->osd_keepalive_timeout = CEPH_OSD_KEEPALIVE_DEFAULT;\r\nopt->mount_timeout = CEPH_MOUNT_TIMEOUT_DEFAULT;\r\nopt->osd_idle_ttl = CEPH_OSD_IDLE_TTL_DEFAULT;\r\nopt->monc_ping_timeout = CEPH_MONC_PING_TIMEOUT_DEFAULT;\r\nerr = ceph_parse_ips(dev_name, dev_name_end, opt->mon_addr,\r\nCEPH_MAX_MON, &opt->num_mon);\r\nif (err < 0)\r\ngoto out;\r\nwhile ((c = strsep(&options, ",")) != NULL) {\r\nint token, intval, ret;\r\nif (!*c)\r\ncontinue;\r\nerr = -EINVAL;\r\ntoken = match_token((char *)c, opt_tokens, argstr);\r\nif (token < 0 && parse_extra_token) {\r\nerr = parse_extra_token((char *)c, private);\r\nif (err < 0) {\r\npr_err("bad option at '%s'\n", c);\r\ngoto out;\r\n}\r\ncontinue;\r\n}\r\nif (token < Opt_last_int) {\r\nret = match_int(&argstr[0], &intval);\r\nif (ret < 0) {\r\npr_err("bad mount option arg (not int) "\r\n"at '%s'\n", c);\r\ncontinue;\r\n}\r\ndout("got int token %d val %d\n", token, intval);\r\n} else if (token > Opt_last_int && token < Opt_last_string) {\r\ndout("got string token %d val %s\n", token,\r\nargstr[0].from);\r\n} else {\r\ndout("got token %d\n", token);\r\n}\r\nswitch (token) {\r\ncase Opt_ip:\r\nerr = ceph_parse_ips(argstr[0].from,\r\nargstr[0].to,\r\n&opt->my_addr,\r\n1, NULL);\r\nif (err < 0)\r\ngoto out;\r\nopt->flags |= CEPH_OPT_MYIP;\r\nbreak;\r\ncase Opt_fsid:\r\nerr = parse_fsid(argstr[0].from, &opt->fsid);\r\nif (err == 0)\r\nopt->flags |= CEPH_OPT_FSID;\r\nbreak;\r\ncase Opt_name:\r\nopt->name = kstrndup(argstr[0].from,\r\nargstr[0].to-argstr[0].from,\r\nGFP_KERNEL);\r\nbreak;\r\ncase Opt_secret:\r\nopt->key = kzalloc(sizeof(*opt->key), GFP_KERNEL);\r\nif (!opt->key) {\r\nerr = -ENOMEM;\r\ngoto out;\r\n}\r\nerr = ceph_crypto_key_unarmor(opt->key, argstr[0].from);\r\nif (err < 0)\r\ngoto out;\r\nbreak;\r\ncase Opt_key:\r\nopt->key = kzalloc(sizeof(*opt->key), GFP_KERNEL);\r\nif (!opt->key) {\r\nerr = -ENOMEM;\r\ngoto out;\r\n}\r\nerr = get_secret(opt->key, argstr[0].from);\r\nif (err < 0)\r\ngoto out;\r\nbreak;\r\ncase Opt_osdtimeout:\r\npr_warn("ignoring deprecated osdtimeout option\n");\r\nbreak;\r\ncase Opt_osdkeepalivetimeout:\r\nif (intval < 1 || intval > INT_MAX / 1000) {\r\npr_err("osdkeepalive out of range\n");\r\nerr = -EINVAL;\r\ngoto out;\r\n}\r\nopt->osd_keepalive_timeout =\r\nmsecs_to_jiffies(intval * 1000);\r\nbreak;\r\ncase Opt_osd_idle_ttl:\r\nif (intval < 1 || intval > INT_MAX / 1000) {\r\npr_err("osd_idle_ttl out of range\n");\r\nerr = -EINVAL;\r\ngoto out;\r\n}\r\nopt->osd_idle_ttl = msecs_to_jiffies(intval * 1000);\r\nbreak;\r\ncase Opt_mount_timeout:\r\nif (intval < 0 || intval > INT_MAX / 1000) {\r\npr_err("mount_timeout out of range\n");\r\nerr = -EINVAL;\r\ngoto out;\r\n}\r\nopt->mount_timeout = msecs_to_jiffies(intval * 1000);\r\nbreak;\r\ncase Opt_share:\r\nopt->flags &= ~CEPH_OPT_NOSHARE;\r\nbreak;\r\ncase Opt_noshare:\r\nopt->flags |= CEPH_OPT_NOSHARE;\r\nbreak;\r\ncase Opt_crc:\r\nopt->flags &= ~CEPH_OPT_NOCRC;\r\nbreak;\r\ncase Opt_nocrc:\r\nopt->flags |= CEPH_OPT_NOCRC;\r\nbreak;\r\ncase Opt_cephx_require_signatures:\r\nopt->flags &= ~CEPH_OPT_NOMSGAUTH;\r\nbreak;\r\ncase Opt_nocephx_require_signatures:\r\nopt->flags |= CEPH_OPT_NOMSGAUTH;\r\nbreak;\r\ncase Opt_cephx_sign_messages:\r\nopt->flags &= ~CEPH_OPT_NOMSGSIGN;\r\nbreak;\r\ncase Opt_nocephx_sign_messages:\r\nopt->flags |= CEPH_OPT_NOMSGSIGN;\r\nbreak;\r\ncase Opt_tcp_nodelay:\r\nopt->flags |= CEPH_OPT_TCP_NODELAY;\r\nbreak;\r\ncase Opt_notcp_nodelay:\r\nopt->flags &= ~CEPH_OPT_TCP_NODELAY;\r\nbreak;\r\ndefault:\r\nBUG_ON(token);\r\n}\r\n}\r\nreturn opt;\r\nout:\r\nceph_destroy_options(opt);\r\nreturn ERR_PTR(err);\r\n}\r\nint ceph_print_client_options(struct seq_file *m, struct ceph_client *client)\r\n{\r\nstruct ceph_options *opt = client->options;\r\nsize_t pos = m->count;\r\nif (opt->name) {\r\nseq_puts(m, "name=");\r\nseq_escape(m, opt->name, ", \t\n\\");\r\nseq_putc(m, ',');\r\n}\r\nif (opt->key)\r\nseq_puts(m, "secret=<hidden>,");\r\nif (opt->flags & CEPH_OPT_FSID)\r\nseq_printf(m, "fsid=%pU,", &opt->fsid);\r\nif (opt->flags & CEPH_OPT_NOSHARE)\r\nseq_puts(m, "noshare,");\r\nif (opt->flags & CEPH_OPT_NOCRC)\r\nseq_puts(m, "nocrc,");\r\nif (opt->flags & CEPH_OPT_NOMSGAUTH)\r\nseq_puts(m, "nocephx_require_signatures,");\r\nif (opt->flags & CEPH_OPT_NOMSGSIGN)\r\nseq_puts(m, "nocephx_sign_messages,");\r\nif ((opt->flags & CEPH_OPT_TCP_NODELAY) == 0)\r\nseq_puts(m, "notcp_nodelay,");\r\nif (opt->mount_timeout != CEPH_MOUNT_TIMEOUT_DEFAULT)\r\nseq_printf(m, "mount_timeout=%d,",\r\njiffies_to_msecs(opt->mount_timeout) / 1000);\r\nif (opt->osd_idle_ttl != CEPH_OSD_IDLE_TTL_DEFAULT)\r\nseq_printf(m, "osd_idle_ttl=%d,",\r\njiffies_to_msecs(opt->osd_idle_ttl) / 1000);\r\nif (opt->osd_keepalive_timeout != CEPH_OSD_KEEPALIVE_DEFAULT)\r\nseq_printf(m, "osdkeepalivetimeout=%d,",\r\njiffies_to_msecs(opt->osd_keepalive_timeout) / 1000);\r\nif (m->count != pos)\r\nm->count--;\r\nreturn 0;\r\n}\r\nu64 ceph_client_id(struct ceph_client *client)\r\n{\r\nreturn client->monc.auth->global_id;\r\n}\r\nstruct ceph_client *ceph_create_client(struct ceph_options *opt, void *private,\r\nu64 supported_features,\r\nu64 required_features)\r\n{\r\nstruct ceph_client *client;\r\nstruct ceph_entity_addr *myaddr = NULL;\r\nint err = -ENOMEM;\r\nclient = kzalloc(sizeof(*client), GFP_KERNEL);\r\nif (client == NULL)\r\nreturn ERR_PTR(-ENOMEM);\r\nclient->private = private;\r\nclient->options = opt;\r\nmutex_init(&client->mount_mutex);\r\ninit_waitqueue_head(&client->auth_wq);\r\nclient->auth_err = 0;\r\nif (!ceph_test_opt(client, NOMSGAUTH))\r\nrequired_features |= CEPH_FEATURE_MSG_AUTH;\r\nclient->extra_mon_dispatch = NULL;\r\nclient->supported_features = CEPH_FEATURES_SUPPORTED_DEFAULT |\r\nsupported_features;\r\nclient->required_features = CEPH_FEATURES_REQUIRED_DEFAULT |\r\nrequired_features;\r\nif (ceph_test_opt(client, MYIP))\r\nmyaddr = &client->options->my_addr;\r\nceph_messenger_init(&client->msgr, myaddr);\r\nerr = ceph_monc_init(&client->monc, client);\r\nif (err < 0)\r\ngoto fail;\r\nerr = ceph_osdc_init(&client->osdc, client);\r\nif (err < 0)\r\ngoto fail_monc;\r\nreturn client;\r\nfail_monc:\r\nceph_monc_stop(&client->monc);\r\nfail:\r\nceph_messenger_fini(&client->msgr);\r\nkfree(client);\r\nreturn ERR_PTR(err);\r\n}\r\nvoid ceph_destroy_client(struct ceph_client *client)\r\n{\r\ndout("destroy_client %p\n", client);\r\natomic_set(&client->msgr.stopping, 1);\r\nceph_osdc_stop(&client->osdc);\r\nceph_monc_stop(&client->monc);\r\nceph_messenger_fini(&client->msgr);\r\nceph_debugfs_client_cleanup(client);\r\nceph_destroy_options(client->options);\r\nkfree(client);\r\ndout("destroy_client %p done\n", client);\r\n}\r\nstatic int have_mon_and_osd_map(struct ceph_client *client)\r\n{\r\nreturn client->monc.monmap && client->monc.monmap->epoch &&\r\nclient->osdc.osdmap && client->osdc.osdmap->epoch;\r\n}\r\nint __ceph_open_session(struct ceph_client *client, unsigned long started)\r\n{\r\nunsigned long timeout = client->options->mount_timeout;\r\nlong err;\r\nerr = ceph_monc_open_session(&client->monc);\r\nif (err < 0)\r\nreturn err;\r\nwhile (!have_mon_and_osd_map(client)) {\r\nif (timeout && time_after_eq(jiffies, started + timeout))\r\nreturn -ETIMEDOUT;\r\ndout("mount waiting for mon_map\n");\r\nerr = wait_event_interruptible_timeout(client->auth_wq,\r\nhave_mon_and_osd_map(client) || (client->auth_err < 0),\r\nceph_timeout_jiffies(timeout));\r\nif (err < 0)\r\nreturn err;\r\nif (client->auth_err < 0)\r\nreturn client->auth_err;\r\n}\r\nreturn 0;\r\n}\r\nint ceph_open_session(struct ceph_client *client)\r\n{\r\nint ret;\r\nunsigned long started = jiffies;\r\ndout("open_session start\n");\r\nmutex_lock(&client->mount_mutex);\r\nret = __ceph_open_session(client, started);\r\nmutex_unlock(&client->mount_mutex);\r\nreturn ret;\r\n}\r\nstatic int __init init_ceph_lib(void)\r\n{\r\nint ret = 0;\r\nret = ceph_debugfs_init();\r\nif (ret < 0)\r\ngoto out;\r\nret = ceph_crypto_init();\r\nif (ret < 0)\r\ngoto out_debugfs;\r\nret = ceph_msgr_init();\r\nif (ret < 0)\r\ngoto out_crypto;\r\nret = ceph_osdc_setup();\r\nif (ret < 0)\r\ngoto out_msgr;\r\npr_info("loaded (mon/osd proto %d/%d)\n",\r\nCEPH_MONC_PROTOCOL, CEPH_OSDC_PROTOCOL);\r\nreturn 0;\r\nout_msgr:\r\nceph_msgr_exit();\r\nout_crypto:\r\nceph_crypto_shutdown();\r\nout_debugfs:\r\nceph_debugfs_cleanup();\r\nout:\r\nreturn ret;\r\n}\r\nstatic void __exit exit_ceph_lib(void)\r\n{\r\ndout("exit_ceph_lib\n");\r\nceph_osdc_cleanup();\r\nceph_msgr_exit();\r\nceph_crypto_shutdown();\r\nceph_debugfs_cleanup();\r\n}
