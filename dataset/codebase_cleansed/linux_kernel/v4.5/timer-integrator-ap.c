static u64 notrace integrator_read_sched_clock(void)\r\n{\r\nreturn -readl(sched_clk_base + TIMER_VALUE);\r\n}\r\nstatic void integrator_clocksource_init(unsigned long inrate,\r\nvoid __iomem *base)\r\n{\r\nu32 ctrl = TIMER_CTRL_ENABLE | TIMER_CTRL_PERIODIC;\r\nunsigned long rate = inrate;\r\nif (rate >= 1500000) {\r\nrate /= 16;\r\nctrl |= TIMER_CTRL_DIV16;\r\n}\r\nwritel(0xffff, base + TIMER_LOAD);\r\nwritel(ctrl, base + TIMER_CTRL);\r\nclocksource_mmio_init(base + TIMER_VALUE, "timer2",\r\nrate, 200, 16, clocksource_mmio_readl_down);\r\nsched_clk_base = base;\r\nsched_clock_register(integrator_read_sched_clock, 16, rate);\r\n}\r\nstatic irqreturn_t integrator_timer_interrupt(int irq, void *dev_id)\r\n{\r\nstruct clock_event_device *evt = dev_id;\r\nwritel(1, clkevt_base + TIMER_INTCLR);\r\nevt->event_handler(evt);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int clkevt_shutdown(struct clock_event_device *evt)\r\n{\r\nu32 ctrl = readl(clkevt_base + TIMER_CTRL) & ~TIMER_CTRL_ENABLE;\r\nwritel(ctrl, clkevt_base + TIMER_CTRL);\r\nreturn 0;\r\n}\r\nstatic int clkevt_set_oneshot(struct clock_event_device *evt)\r\n{\r\nu32 ctrl = readl(clkevt_base + TIMER_CTRL) &\r\n~(TIMER_CTRL_ENABLE | TIMER_CTRL_PERIODIC);\r\nwritel(ctrl, clkevt_base + TIMER_CTRL);\r\nreturn 0;\r\n}\r\nstatic int clkevt_set_periodic(struct clock_event_device *evt)\r\n{\r\nu32 ctrl = readl(clkevt_base + TIMER_CTRL) & ~TIMER_CTRL_ENABLE;\r\nwritel(ctrl, clkevt_base + TIMER_CTRL);\r\nwritel(timer_reload, clkevt_base + TIMER_LOAD);\r\nctrl |= TIMER_CTRL_PERIODIC | TIMER_CTRL_ENABLE;\r\nwritel(ctrl, clkevt_base + TIMER_CTRL);\r\nreturn 0;\r\n}\r\nstatic int clkevt_set_next_event(unsigned long next, struct clock_event_device *evt)\r\n{\r\nunsigned long ctrl = readl(clkevt_base + TIMER_CTRL);\r\nwritel(ctrl & ~TIMER_CTRL_ENABLE, clkevt_base + TIMER_CTRL);\r\nwritel(next, clkevt_base + TIMER_LOAD);\r\nwritel(ctrl | TIMER_CTRL_ENABLE, clkevt_base + TIMER_CTRL);\r\nreturn 0;\r\n}\r\nstatic void integrator_clockevent_init(unsigned long inrate,\r\nvoid __iomem *base, int irq)\r\n{\r\nunsigned long rate = inrate;\r\nunsigned int ctrl = 0;\r\nclkevt_base = base;\r\nif (rate > 0x100000 * HZ) {\r\nrate /= 256;\r\nctrl |= TIMER_CTRL_DIV256;\r\n} else if (rate > 0x10000 * HZ) {\r\nrate /= 16;\r\nctrl |= TIMER_CTRL_DIV16;\r\n}\r\ntimer_reload = rate / HZ;\r\nwritel(ctrl, clkevt_base + TIMER_CTRL);\r\nsetup_irq(irq, &integrator_timer_irq);\r\nclockevents_config_and_register(&integrator_clockevent,\r\nrate,\r\n1,\r\n0xffffU);\r\n}\r\nstatic void __init integrator_ap_timer_init_of(struct device_node *node)\r\n{\r\nconst char *path;\r\nvoid __iomem *base;\r\nint err;\r\nint irq;\r\nstruct clk *clk;\r\nunsigned long rate;\r\nstruct device_node *pri_node;\r\nstruct device_node *sec_node;\r\nbase = of_io_request_and_map(node, 0, "integrator-timer");\r\nif (IS_ERR(base))\r\nreturn;\r\nclk = of_clk_get(node, 0);\r\nif (IS_ERR(clk)) {\r\npr_err("No clock for %s\n", node->name);\r\nreturn;\r\n}\r\nclk_prepare_enable(clk);\r\nrate = clk_get_rate(clk);\r\nwritel(0, base + TIMER_CTRL);\r\nerr = of_property_read_string(of_aliases,\r\n"arm,timer-primary", &path);\r\nif (WARN_ON(err))\r\nreturn;\r\npri_node = of_find_node_by_path(path);\r\nerr = of_property_read_string(of_aliases,\r\n"arm,timer-secondary", &path);\r\nif (WARN_ON(err))\r\nreturn;\r\nsec_node = of_find_node_by_path(path);\r\nif (node == pri_node) {\r\nintegrator_clocksource_init(rate, base);\r\nreturn;\r\n}\r\nif (node == sec_node) {\r\nirq = irq_of_parse_and_map(node, 0);\r\nintegrator_clockevent_init(rate, base, irq);\r\nreturn;\r\n}\r\npr_info("Timer @%p unused\n", base);\r\nclk_disable_unprepare(clk);\r\n}
