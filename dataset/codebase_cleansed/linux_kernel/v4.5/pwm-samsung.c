static inline\r\nstruct samsung_pwm_chip *to_samsung_pwm_chip(struct pwm_chip *chip)\r\n{\r\nreturn container_of(chip, struct samsung_pwm_chip, chip);\r\n}\r\nstatic inline unsigned int to_tcon_channel(unsigned int channel)\r\n{\r\nreturn (channel == 0) ? 0 : (channel + 1);\r\n}\r\nstatic void pwm_samsung_set_divisor(struct samsung_pwm_chip *pwm,\r\nunsigned int channel, u8 divisor)\r\n{\r\nu8 shift = TCFG1_SHIFT(channel);\r\nunsigned long flags;\r\nu32 reg;\r\nu8 bits;\r\nbits = (fls(divisor) - 1) - pwm->variant.div_base;\r\nspin_lock_irqsave(&samsung_pwm_lock, flags);\r\nreg = readl(pwm->base + REG_TCFG1);\r\nreg &= ~(TCFG1_MUX_MASK << shift);\r\nreg |= bits << shift;\r\nwritel(reg, pwm->base + REG_TCFG1);\r\nspin_unlock_irqrestore(&samsung_pwm_lock, flags);\r\n}\r\nstatic int pwm_samsung_is_tdiv(struct samsung_pwm_chip *chip, unsigned int chan)\r\n{\r\nstruct samsung_pwm_variant *variant = &chip->variant;\r\nu32 reg;\r\nreg = readl(chip->base + REG_TCFG1);\r\nreg >>= TCFG1_SHIFT(chan);\r\nreg &= TCFG1_MUX_MASK;\r\nreturn (BIT(reg) & variant->tclk_mask) == 0;\r\n}\r\nstatic unsigned long pwm_samsung_get_tin_rate(struct samsung_pwm_chip *chip,\r\nunsigned int chan)\r\n{\r\nunsigned long rate;\r\nu32 reg;\r\nrate = clk_get_rate(chip->base_clk);\r\nreg = readl(chip->base + REG_TCFG0);\r\nif (chan >= 2)\r\nreg >>= TCFG0_PRESCALER1_SHIFT;\r\nreg &= TCFG0_PRESCALER_MASK;\r\nreturn rate / (reg + 1);\r\n}\r\nstatic unsigned long pwm_samsung_calc_tin(struct samsung_pwm_chip *chip,\r\nunsigned int chan, unsigned long freq)\r\n{\r\nstruct samsung_pwm_variant *variant = &chip->variant;\r\nunsigned long rate;\r\nstruct clk *clk;\r\nu8 div;\r\nif (!pwm_samsung_is_tdiv(chip, chan)) {\r\nclk = (chan < 2) ? chip->tclk0 : chip->tclk1;\r\nif (!IS_ERR(clk)) {\r\nrate = clk_get_rate(clk);\r\nif (rate)\r\nreturn rate;\r\n}\r\ndev_warn(chip->chip.dev,\r\n"tclk of PWM %d is inoperational, using tdiv\n", chan);\r\n}\r\nrate = pwm_samsung_get_tin_rate(chip, chan);\r\ndev_dbg(chip->chip.dev, "tin parent at %lu\n", rate);\r\nfor (div = variant->div_base; div < 4; ++div)\r\nif ((rate >> (variant->bits + div)) < freq)\r\nbreak;\r\npwm_samsung_set_divisor(chip, chan, BIT(div));\r\nreturn rate >> div;\r\n}\r\nstatic int pwm_samsung_request(struct pwm_chip *chip, struct pwm_device *pwm)\r\n{\r\nstruct samsung_pwm_chip *our_chip = to_samsung_pwm_chip(chip);\r\nstruct samsung_pwm_channel *our_chan;\r\nif (!(our_chip->variant.output_mask & BIT(pwm->hwpwm))) {\r\ndev_warn(chip->dev,\r\n"tried to request PWM channel %d without output\n",\r\npwm->hwpwm);\r\nreturn -EINVAL;\r\n}\r\nour_chan = devm_kzalloc(chip->dev, sizeof(*our_chan), GFP_KERNEL);\r\nif (!our_chan)\r\nreturn -ENOMEM;\r\npwm_set_chip_data(pwm, our_chan);\r\nreturn 0;\r\n}\r\nstatic void pwm_samsung_free(struct pwm_chip *chip, struct pwm_device *pwm)\r\n{\r\ndevm_kfree(chip->dev, pwm_get_chip_data(pwm));\r\npwm_set_chip_data(pwm, NULL);\r\n}\r\nstatic int pwm_samsung_enable(struct pwm_chip *chip, struct pwm_device *pwm)\r\n{\r\nstruct samsung_pwm_chip *our_chip = to_samsung_pwm_chip(chip);\r\nunsigned int tcon_chan = to_tcon_channel(pwm->hwpwm);\r\nunsigned long flags;\r\nu32 tcon;\r\nspin_lock_irqsave(&samsung_pwm_lock, flags);\r\ntcon = readl(our_chip->base + REG_TCON);\r\ntcon &= ~TCON_START(tcon_chan);\r\ntcon |= TCON_MANUALUPDATE(tcon_chan);\r\nwritel(tcon, our_chip->base + REG_TCON);\r\ntcon &= ~TCON_MANUALUPDATE(tcon_chan);\r\ntcon |= TCON_START(tcon_chan) | TCON_AUTORELOAD(tcon_chan);\r\nwritel(tcon, our_chip->base + REG_TCON);\r\nspin_unlock_irqrestore(&samsung_pwm_lock, flags);\r\nreturn 0;\r\n}\r\nstatic void pwm_samsung_disable(struct pwm_chip *chip, struct pwm_device *pwm)\r\n{\r\nstruct samsung_pwm_chip *our_chip = to_samsung_pwm_chip(chip);\r\nunsigned int tcon_chan = to_tcon_channel(pwm->hwpwm);\r\nunsigned long flags;\r\nu32 tcon;\r\nspin_lock_irqsave(&samsung_pwm_lock, flags);\r\ntcon = readl(our_chip->base + REG_TCON);\r\ntcon &= ~TCON_AUTORELOAD(tcon_chan);\r\nwritel(tcon, our_chip->base + REG_TCON);\r\nspin_unlock_irqrestore(&samsung_pwm_lock, flags);\r\n}\r\nstatic void pwm_samsung_manual_update(struct samsung_pwm_chip *chip,\r\nstruct pwm_device *pwm)\r\n{\r\nunsigned int tcon_chan = to_tcon_channel(pwm->hwpwm);\r\nu32 tcon;\r\nunsigned long flags;\r\nspin_lock_irqsave(&samsung_pwm_lock, flags);\r\ntcon = readl(chip->base + REG_TCON);\r\ntcon |= TCON_MANUALUPDATE(tcon_chan);\r\nwritel(tcon, chip->base + REG_TCON);\r\ntcon &= ~TCON_MANUALUPDATE(tcon_chan);\r\nwritel(tcon, chip->base + REG_TCON);\r\nspin_unlock_irqrestore(&samsung_pwm_lock, flags);\r\n}\r\nstatic int pwm_samsung_config(struct pwm_chip *chip, struct pwm_device *pwm,\r\nint duty_ns, int period_ns)\r\n{\r\nstruct samsung_pwm_chip *our_chip = to_samsung_pwm_chip(chip);\r\nstruct samsung_pwm_channel *chan = pwm_get_chip_data(pwm);\r\nu32 tin_ns = chan->tin_ns, tcnt, tcmp, oldtcmp;\r\nif (period_ns > NSEC_PER_SEC)\r\nreturn -ERANGE;\r\nif (period_ns == chan->period_ns && duty_ns == chan->duty_ns)\r\nreturn 0;\r\ntcnt = readl(our_chip->base + REG_TCNTB(pwm->hwpwm));\r\noldtcmp = readl(our_chip->base + REG_TCMPB(pwm->hwpwm));\r\n++tcnt;\r\nif (chan->period_ns != period_ns) {\r\nunsigned long tin_rate;\r\nu32 period;\r\nperiod = NSEC_PER_SEC / period_ns;\r\ndev_dbg(our_chip->chip.dev, "duty_ns=%d, period_ns=%d (%u)\n",\r\nduty_ns, period_ns, period);\r\ntin_rate = pwm_samsung_calc_tin(our_chip, pwm->hwpwm, period);\r\ndev_dbg(our_chip->chip.dev, "tin_rate=%lu\n", tin_rate);\r\ntin_ns = NSEC_PER_SEC / tin_rate;\r\ntcnt = period_ns / tin_ns;\r\n}\r\nif (tcnt <= 1)\r\nreturn -ERANGE;\r\ntcmp = duty_ns / tin_ns;\r\nif (!tcmp)\r\n++tcmp;\r\ntcmp = tcnt - tcmp;\r\n--tcnt;\r\n--tcmp;\r\ndev_dbg(our_chip->chip.dev,\r\n"tin_ns=%u, tcmp=%u/%u\n", tin_ns, tcmp, tcnt);\r\nwritel(tcnt, our_chip->base + REG_TCNTB(pwm->hwpwm));\r\nwritel(tcmp, our_chip->base + REG_TCMPB(pwm->hwpwm));\r\nif (oldtcmp == (u32) -1) {\r\ndev_dbg(our_chip->chip.dev, "Forcing manual update");\r\npwm_samsung_manual_update(our_chip, pwm);\r\n}\r\nchan->period_ns = period_ns;\r\nchan->tin_ns = tin_ns;\r\nchan->duty_ns = duty_ns;\r\nreturn 0;\r\n}\r\nstatic void pwm_samsung_set_invert(struct samsung_pwm_chip *chip,\r\nunsigned int channel, bool invert)\r\n{\r\nunsigned int tcon_chan = to_tcon_channel(channel);\r\nunsigned long flags;\r\nu32 tcon;\r\nspin_lock_irqsave(&samsung_pwm_lock, flags);\r\ntcon = readl(chip->base + REG_TCON);\r\nif (invert) {\r\nchip->inverter_mask |= BIT(channel);\r\ntcon |= TCON_INVERT(tcon_chan);\r\n} else {\r\nchip->inverter_mask &= ~BIT(channel);\r\ntcon &= ~TCON_INVERT(tcon_chan);\r\n}\r\nwritel(tcon, chip->base + REG_TCON);\r\nspin_unlock_irqrestore(&samsung_pwm_lock, flags);\r\n}\r\nstatic int pwm_samsung_set_polarity(struct pwm_chip *chip,\r\nstruct pwm_device *pwm,\r\nenum pwm_polarity polarity)\r\n{\r\nstruct samsung_pwm_chip *our_chip = to_samsung_pwm_chip(chip);\r\nbool invert = (polarity == PWM_POLARITY_NORMAL);\r\npwm_samsung_set_invert(our_chip, pwm->hwpwm, invert);\r\nreturn 0;\r\n}\r\nstatic int pwm_samsung_parse_dt(struct samsung_pwm_chip *chip)\r\n{\r\nstruct device_node *np = chip->chip.dev->of_node;\r\nconst struct of_device_id *match;\r\nstruct property *prop;\r\nconst __be32 *cur;\r\nu32 val;\r\nmatch = of_match_node(samsung_pwm_matches, np);\r\nif (!match)\r\nreturn -ENODEV;\r\nmemcpy(&chip->variant, match->data, sizeof(chip->variant));\r\nof_property_for_each_u32(np, "samsung,pwm-outputs", prop, cur, val) {\r\nif (val >= SAMSUNG_PWM_NUM) {\r\ndev_err(chip->chip.dev,\r\n"%s: invalid channel index in samsung,pwm-outputs property\n",\r\n__func__);\r\ncontinue;\r\n}\r\nchip->variant.output_mask |= BIT(val);\r\n}\r\nreturn 0;\r\n}\r\nstatic int pwm_samsung_parse_dt(struct samsung_pwm_chip *chip)\r\n{\r\nreturn -ENODEV;\r\n}\r\nstatic int pwm_samsung_probe(struct platform_device *pdev)\r\n{\r\nstruct device *dev = &pdev->dev;\r\nstruct samsung_pwm_chip *chip;\r\nstruct resource *res;\r\nunsigned int chan;\r\nint ret;\r\nchip = devm_kzalloc(&pdev->dev, sizeof(*chip), GFP_KERNEL);\r\nif (chip == NULL)\r\nreturn -ENOMEM;\r\nchip->chip.dev = &pdev->dev;\r\nchip->chip.ops = &pwm_samsung_ops;\r\nchip->chip.base = -1;\r\nchip->chip.npwm = SAMSUNG_PWM_NUM;\r\nchip->inverter_mask = BIT(SAMSUNG_PWM_NUM) - 1;\r\nif (IS_ENABLED(CONFIG_OF) && pdev->dev.of_node) {\r\nret = pwm_samsung_parse_dt(chip);\r\nif (ret)\r\nreturn ret;\r\nchip->chip.of_xlate = of_pwm_xlate_with_flags;\r\nchip->chip.of_pwm_n_cells = 3;\r\n} else {\r\nif (!pdev->dev.platform_data) {\r\ndev_err(&pdev->dev, "no platform data specified\n");\r\nreturn -EINVAL;\r\n}\r\nmemcpy(&chip->variant, pdev->dev.platform_data,\r\nsizeof(chip->variant));\r\n}\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nchip->base = devm_ioremap_resource(&pdev->dev, res);\r\nif (IS_ERR(chip->base))\r\nreturn PTR_ERR(chip->base);\r\nchip->base_clk = devm_clk_get(&pdev->dev, "timers");\r\nif (IS_ERR(chip->base_clk)) {\r\ndev_err(dev, "failed to get timer base clk\n");\r\nreturn PTR_ERR(chip->base_clk);\r\n}\r\nret = clk_prepare_enable(chip->base_clk);\r\nif (ret < 0) {\r\ndev_err(dev, "failed to enable base clock\n");\r\nreturn ret;\r\n}\r\nfor (chan = 0; chan < SAMSUNG_PWM_NUM; ++chan)\r\nif (chip->variant.output_mask & BIT(chan))\r\npwm_samsung_set_invert(chip, chan, true);\r\nchip->tclk0 = devm_clk_get(&pdev->dev, "pwm-tclk0");\r\nchip->tclk1 = devm_clk_get(&pdev->dev, "pwm-tclk1");\r\nplatform_set_drvdata(pdev, chip);\r\nret = pwmchip_add(&chip->chip);\r\nif (ret < 0) {\r\ndev_err(dev, "failed to register PWM chip\n");\r\nclk_disable_unprepare(chip->base_clk);\r\nreturn ret;\r\n}\r\ndev_dbg(dev, "base_clk at %lu, tclk0 at %lu, tclk1 at %lu\n",\r\nclk_get_rate(chip->base_clk),\r\n!IS_ERR(chip->tclk0) ? clk_get_rate(chip->tclk0) : 0,\r\n!IS_ERR(chip->tclk1) ? clk_get_rate(chip->tclk1) : 0);\r\nreturn 0;\r\n}\r\nstatic int pwm_samsung_remove(struct platform_device *pdev)\r\n{\r\nstruct samsung_pwm_chip *chip = platform_get_drvdata(pdev);\r\nint ret;\r\nret = pwmchip_remove(&chip->chip);\r\nif (ret < 0)\r\nreturn ret;\r\nclk_disable_unprepare(chip->base_clk);\r\nreturn 0;\r\n}\r\nstatic int pwm_samsung_suspend(struct device *dev)\r\n{\r\nstruct samsung_pwm_chip *chip = dev_get_drvdata(dev);\r\nunsigned int i;\r\nfor (i = 0; i < SAMSUNG_PWM_NUM; ++i) {\r\nstruct pwm_device *pwm = &chip->chip.pwms[i];\r\nstruct samsung_pwm_channel *chan = pwm_get_chip_data(pwm);\r\nif (!chan)\r\ncontinue;\r\nchan->period_ns = 0;\r\nchan->duty_ns = 0;\r\n}\r\nreturn 0;\r\n}\r\nstatic int pwm_samsung_resume(struct device *dev)\r\n{\r\nstruct samsung_pwm_chip *chip = dev_get_drvdata(dev);\r\nunsigned int chan;\r\nfor (chan = 0; chan < SAMSUNG_PWM_NUM; ++chan) {\r\nif (chip->variant.output_mask & BIT(chan))\r\npwm_samsung_set_invert(chip, chan,\r\nchip->inverter_mask & BIT(chan));\r\n}\r\nreturn 0;\r\n}
