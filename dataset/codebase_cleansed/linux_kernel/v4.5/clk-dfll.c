static inline u32 dfll_readl(struct tegra_dfll *td, u32 offs)\r\n{\r\nreturn __raw_readl(td->base + offs);\r\n}\r\nstatic inline void dfll_writel(struct tegra_dfll *td, u32 val, u32 offs)\r\n{\r\nWARN_ON(offs >= DFLL_I2C_CFG);\r\n__raw_writel(val, td->base + offs);\r\n}\r\nstatic inline void dfll_wmb(struct tegra_dfll *td)\r\n{\r\ndfll_readl(td, DFLL_CTRL);\r\n}\r\nstatic inline u32 dfll_i2c_readl(struct tegra_dfll *td, u32 offs)\r\n{\r\nreturn __raw_readl(td->i2c_base + offs);\r\n}\r\nstatic inline void dfll_i2c_writel(struct tegra_dfll *td, u32 val, u32 offs)\r\n{\r\n__raw_writel(val, td->i2c_base + offs);\r\n}\r\nstatic inline void dfll_i2c_wmb(struct tegra_dfll *td)\r\n{\r\ndfll_i2c_readl(td, DFLL_I2C_CFG);\r\n}\r\nstatic bool dfll_is_running(struct tegra_dfll *td)\r\n{\r\nreturn td->mode >= DFLL_OPEN_LOOP;\r\n}\r\nint tegra_dfll_runtime_resume(struct device *dev)\r\n{\r\nstruct tegra_dfll *td = dev_get_drvdata(dev);\r\nint ret;\r\nret = clk_enable(td->ref_clk);\r\nif (ret) {\r\ndev_err(dev, "could not enable ref clock: %d\n", ret);\r\nreturn ret;\r\n}\r\nret = clk_enable(td->soc_clk);\r\nif (ret) {\r\ndev_err(dev, "could not enable register clock: %d\n", ret);\r\nclk_disable(td->ref_clk);\r\nreturn ret;\r\n}\r\nret = clk_enable(td->i2c_clk);\r\nif (ret) {\r\ndev_err(dev, "could not enable i2c clock: %d\n", ret);\r\nclk_disable(td->soc_clk);\r\nclk_disable(td->ref_clk);\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nint tegra_dfll_runtime_suspend(struct device *dev)\r\n{\r\nstruct tegra_dfll *td = dev_get_drvdata(dev);\r\nclk_disable(td->ref_clk);\r\nclk_disable(td->soc_clk);\r\nclk_disable(td->i2c_clk);\r\nreturn 0;\r\n}\r\nstatic void dfll_tune_low(struct tegra_dfll *td)\r\n{\r\ntd->tune_range = DFLL_TUNE_LOW;\r\ndfll_writel(td, td->soc->tune0_low, DFLL_TUNE0);\r\ndfll_writel(td, td->soc->tune1, DFLL_TUNE1);\r\ndfll_wmb(td);\r\nif (td->soc->set_clock_trimmers_low)\r\ntd->soc->set_clock_trimmers_low();\r\n}\r\nstatic unsigned long dfll_scale_dvco_rate(int scale_bits,\r\nunsigned long dvco_rate)\r\n{\r\nreturn (u64)dvco_rate * (scale_bits + 1) / DFLL_FREQ_REQ_SCALE_MAX;\r\n}\r\nstatic void dfll_set_mode(struct tegra_dfll *td,\r\nenum dfll_ctrl_mode mode)\r\n{\r\ntd->mode = mode;\r\ndfll_writel(td, mode - 1, DFLL_CTRL);\r\ndfll_wmb(td);\r\n}\r\nstatic int dfll_i2c_set_output_enabled(struct tegra_dfll *td, bool enable)\r\n{\r\nu32 val;\r\nval = dfll_i2c_readl(td, DFLL_OUTPUT_CFG);\r\nif (enable)\r\nval |= DFLL_OUTPUT_CFG_I2C_ENABLE;\r\nelse\r\nval &= ~DFLL_OUTPUT_CFG_I2C_ENABLE;\r\ndfll_i2c_writel(td, val, DFLL_OUTPUT_CFG);\r\ndfll_i2c_wmb(td);\r\nreturn 0;\r\n}\r\nstatic void dfll_load_i2c_lut(struct tegra_dfll *td)\r\n{\r\nint i, lut_index;\r\nu32 val;\r\nfor (i = 0; i < MAX_DFLL_VOLTAGES; i++) {\r\nif (i < td->lut_min)\r\nlut_index = td->lut_min;\r\nelse if (i > td->lut_max)\r\nlut_index = td->lut_max;\r\nelse\r\nlut_index = i;\r\nval = regulator_list_hardware_vsel(td->vdd_reg,\r\ntd->i2c_lut[lut_index]);\r\n__raw_writel(val, td->lut_base + i * 4);\r\n}\r\ndfll_i2c_wmb(td);\r\n}\r\nstatic void dfll_init_i2c_if(struct tegra_dfll *td)\r\n{\r\nu32 val;\r\nif (td->i2c_slave_addr > 0x7f) {\r\nval = td->i2c_slave_addr << DFLL_I2C_CFG_SLAVE_ADDR_SHIFT_10BIT;\r\nval |= DFLL_I2C_CFG_SLAVE_ADDR_10;\r\n} else {\r\nval = td->i2c_slave_addr << DFLL_I2C_CFG_SLAVE_ADDR_SHIFT_7BIT;\r\n}\r\nval |= DFLL_I2C_CFG_SIZE_MASK;\r\nval |= DFLL_I2C_CFG_ARB_ENABLE;\r\ndfll_i2c_writel(td, val, DFLL_I2C_CFG);\r\ndfll_i2c_writel(td, td->i2c_reg, DFLL_I2C_VDD_REG_ADDR);\r\nval = DIV_ROUND_UP(td->i2c_clk_rate, td->i2c_fs_rate * 8);\r\nBUG_ON(!val || (val > DFLL_I2C_CLK_DIVISOR_MASK));\r\nval = (val - 1) << DFLL_I2C_CLK_DIVISOR_FS_SHIFT;\r\nval |= 1 << DFLL_I2C_CLK_DIVISOR_HS_SHIFT;\r\n__raw_writel(val, td->i2c_controller_base + DFLL_I2C_CLK_DIVISOR);\r\ndfll_i2c_wmb(td);\r\n}\r\nstatic void dfll_init_out_if(struct tegra_dfll *td)\r\n{\r\nu32 val;\r\ntd->lut_min = 0;\r\ntd->lut_max = td->i2c_lut_size - 1;\r\ntd->lut_safe = td->lut_min + 1;\r\ndfll_i2c_writel(td, 0, DFLL_OUTPUT_CFG);\r\nval = (td->lut_safe << DFLL_OUTPUT_CFG_SAFE_SHIFT) |\r\n(td->lut_max << DFLL_OUTPUT_CFG_MAX_SHIFT) |\r\n(td->lut_min << DFLL_OUTPUT_CFG_MIN_SHIFT);\r\ndfll_i2c_writel(td, val, DFLL_OUTPUT_CFG);\r\ndfll_i2c_wmb(td);\r\ndfll_writel(td, 0, DFLL_OUTPUT_FORCE);\r\ndfll_i2c_writel(td, 0, DFLL_INTR_EN);\r\ndfll_i2c_writel(td, DFLL_INTR_MAX_MASK | DFLL_INTR_MIN_MASK,\r\nDFLL_INTR_STS);\r\ndfll_load_i2c_lut(td);\r\ndfll_init_i2c_if(td);\r\n}\r\nstatic int find_lut_index_for_rate(struct tegra_dfll *td, unsigned long rate)\r\n{\r\nstruct dev_pm_opp *opp;\r\nint i, uv;\r\nrcu_read_lock();\r\nopp = dev_pm_opp_find_freq_ceil(td->soc->dev, &rate);\r\nif (IS_ERR(opp)) {\r\nrcu_read_unlock();\r\nreturn PTR_ERR(opp);\r\n}\r\nuv = dev_pm_opp_get_voltage(opp);\r\nrcu_read_unlock();\r\nfor (i = 0; i < td->i2c_lut_size; i++) {\r\nif (regulator_list_voltage(td->vdd_reg, td->i2c_lut[i]) == uv)\r\nreturn i;\r\n}\r\nreturn -ENOENT;\r\n}\r\nstatic int dfll_calculate_rate_request(struct tegra_dfll *td,\r\nstruct dfll_rate_req *req,\r\nunsigned long rate)\r\n{\r\nu32 val;\r\nreq->scale_bits = DFLL_FREQ_REQ_SCALE_MAX - 1;\r\nif (rate < td->dvco_rate_min) {\r\nint scale;\r\nscale = DIV_ROUND_CLOSEST(rate / 1000 * DFLL_FREQ_REQ_SCALE_MAX,\r\ntd->dvco_rate_min / 1000);\r\nif (!scale) {\r\ndev_err(td->dev, "%s: Rate %lu is too low\n",\r\n__func__, rate);\r\nreturn -EINVAL;\r\n}\r\nreq->scale_bits = scale - 1;\r\nrate = td->dvco_rate_min;\r\n}\r\nval = DVCO_RATE_TO_MULT(rate, td->ref_rate);\r\nif (val > FREQ_MAX) {\r\ndev_err(td->dev, "%s: Rate %lu is above dfll range\n",\r\n__func__, rate);\r\nreturn -EINVAL;\r\n}\r\nreq->mult_bits = val;\r\nreq->dvco_target_rate = MULT_TO_DVCO_RATE(req->mult_bits, td->ref_rate);\r\nreq->rate = dfll_scale_dvco_rate(req->scale_bits,\r\nreq->dvco_target_rate);\r\nreq->lut_index = find_lut_index_for_rate(td, req->dvco_target_rate);\r\nif (req->lut_index < 0)\r\nreturn req->lut_index;\r\nreturn 0;\r\n}\r\nstatic void dfll_set_frequency_request(struct tegra_dfll *td,\r\nstruct dfll_rate_req *req)\r\n{\r\nu32 val = 0;\r\nint force_val;\r\nint coef = 128; ;\r\nforce_val = (req->lut_index - td->lut_safe) * coef / td->cg;\r\nforce_val = clamp(force_val, FORCE_MIN, FORCE_MAX);\r\nval |= req->mult_bits << DFLL_FREQ_REQ_MULT_SHIFT;\r\nval |= req->scale_bits << DFLL_FREQ_REQ_SCALE_SHIFT;\r\nval |= ((u32)force_val << DFLL_FREQ_REQ_FORCE_SHIFT) &\r\nDFLL_FREQ_REQ_FORCE_MASK;\r\nval |= DFLL_FREQ_REQ_FREQ_VALID | DFLL_FREQ_REQ_FORCE_ENABLE;\r\ndfll_writel(td, val, DFLL_FREQ_REQ);\r\ndfll_wmb(td);\r\n}\r\nstatic int dfll_request_rate(struct tegra_dfll *td, unsigned long rate)\r\n{\r\nint ret;\r\nstruct dfll_rate_req req;\r\nif (td->mode == DFLL_UNINITIALIZED) {\r\ndev_err(td->dev, "%s: Cannot set DFLL rate in %s mode\n",\r\n__func__, mode_name[td->mode]);\r\nreturn -EPERM;\r\n}\r\nret = dfll_calculate_rate_request(td, &req, rate);\r\nif (ret)\r\nreturn ret;\r\ntd->last_unrounded_rate = rate;\r\ntd->last_req = req;\r\nif (td->mode == DFLL_CLOSED_LOOP)\r\ndfll_set_frequency_request(td, &td->last_req);\r\nreturn 0;\r\n}\r\nstatic int dfll_disable(struct tegra_dfll *td)\r\n{\r\nif (td->mode != DFLL_OPEN_LOOP) {\r\ndev_err(td->dev, "cannot disable DFLL in %s mode\n",\r\nmode_name[td->mode]);\r\nreturn -EINVAL;\r\n}\r\ndfll_set_mode(td, DFLL_DISABLED);\r\npm_runtime_put_sync(td->dev);\r\nreturn 0;\r\n}\r\nstatic int dfll_enable(struct tegra_dfll *td)\r\n{\r\nif (td->mode != DFLL_DISABLED) {\r\ndev_err(td->dev, "cannot enable DFLL in %s mode\n",\r\nmode_name[td->mode]);\r\nreturn -EPERM;\r\n}\r\npm_runtime_get_sync(td->dev);\r\ndfll_set_mode(td, DFLL_OPEN_LOOP);\r\nreturn 0;\r\n}\r\nstatic void dfll_set_open_loop_config(struct tegra_dfll *td)\r\n{\r\nu32 val;\r\nif (td->tune_range != DFLL_TUNE_LOW)\r\ndfll_tune_low(td);\r\nval = dfll_readl(td, DFLL_FREQ_REQ);\r\nval |= DFLL_FREQ_REQ_SCALE_MASK;\r\nval &= ~DFLL_FREQ_REQ_FORCE_ENABLE;\r\ndfll_writel(td, val, DFLL_FREQ_REQ);\r\ndfll_wmb(td);\r\n}\r\nstatic int dfll_lock(struct tegra_dfll *td)\r\n{\r\nstruct dfll_rate_req *req = &td->last_req;\r\nswitch (td->mode) {\r\ncase DFLL_CLOSED_LOOP:\r\nreturn 0;\r\ncase DFLL_OPEN_LOOP:\r\nif (req->rate == 0) {\r\ndev_err(td->dev, "%s: Cannot lock DFLL at rate 0\n",\r\n__func__);\r\nreturn -EINVAL;\r\n}\r\ndfll_i2c_set_output_enabled(td, true);\r\ndfll_set_mode(td, DFLL_CLOSED_LOOP);\r\ndfll_set_frequency_request(td, req);\r\nreturn 0;\r\ndefault:\r\nBUG_ON(td->mode > DFLL_CLOSED_LOOP);\r\ndev_err(td->dev, "%s: Cannot lock DFLL in %s mode\n",\r\n__func__, mode_name[td->mode]);\r\nreturn -EPERM;\r\n}\r\n}\r\nstatic int dfll_unlock(struct tegra_dfll *td)\r\n{\r\nswitch (td->mode) {\r\ncase DFLL_CLOSED_LOOP:\r\ndfll_set_open_loop_config(td);\r\ndfll_set_mode(td, DFLL_OPEN_LOOP);\r\ndfll_i2c_set_output_enabled(td, false);\r\nreturn 0;\r\ncase DFLL_OPEN_LOOP:\r\nreturn 0;\r\ndefault:\r\nBUG_ON(td->mode > DFLL_CLOSED_LOOP);\r\ndev_err(td->dev, "%s: Cannot unlock DFLL in %s mode\n",\r\n__func__, mode_name[td->mode]);\r\nreturn -EPERM;\r\n}\r\n}\r\nstatic int dfll_clk_is_enabled(struct clk_hw *hw)\r\n{\r\nstruct tegra_dfll *td = clk_hw_to_dfll(hw);\r\nreturn dfll_is_running(td);\r\n}\r\nstatic int dfll_clk_enable(struct clk_hw *hw)\r\n{\r\nstruct tegra_dfll *td = clk_hw_to_dfll(hw);\r\nint ret;\r\nret = dfll_enable(td);\r\nif (ret)\r\nreturn ret;\r\nret = dfll_lock(td);\r\nif (ret)\r\ndfll_disable(td);\r\nreturn ret;\r\n}\r\nstatic void dfll_clk_disable(struct clk_hw *hw)\r\n{\r\nstruct tegra_dfll *td = clk_hw_to_dfll(hw);\r\nint ret;\r\nret = dfll_unlock(td);\r\nif (!ret)\r\ndfll_disable(td);\r\n}\r\nstatic unsigned long dfll_clk_recalc_rate(struct clk_hw *hw,\r\nunsigned long parent_rate)\r\n{\r\nstruct tegra_dfll *td = clk_hw_to_dfll(hw);\r\nreturn td->last_unrounded_rate;\r\n}\r\nstatic int dfll_clk_determine_rate(struct clk_hw *hw,\r\nstruct clk_rate_request *clk_req)\r\n{\r\nstruct tegra_dfll *td = clk_hw_to_dfll(hw);\r\nstruct dfll_rate_req req;\r\nint ret;\r\nret = dfll_calculate_rate_request(td, &req, clk_req->rate);\r\nif (ret)\r\nreturn ret;\r\nreturn 0;\r\n}\r\nstatic int dfll_clk_set_rate(struct clk_hw *hw, unsigned long rate,\r\nunsigned long parent_rate)\r\n{\r\nstruct tegra_dfll *td = clk_hw_to_dfll(hw);\r\nreturn dfll_request_rate(td, rate);\r\n}\r\nstatic int dfll_register_clk(struct tegra_dfll *td)\r\n{\r\nint ret;\r\ndfll_clk_init_data.name = td->output_clock_name;\r\ntd->dfll_clk_hw.init = &dfll_clk_init_data;\r\ntd->dfll_clk = clk_register(td->dev, &td->dfll_clk_hw);\r\nif (IS_ERR(td->dfll_clk)) {\r\ndev_err(td->dev, "DFLL clock registration error\n");\r\nreturn -EINVAL;\r\n}\r\nret = of_clk_add_provider(td->dev->of_node, of_clk_src_simple_get,\r\ntd->dfll_clk);\r\nif (ret) {\r\ndev_err(td->dev, "of_clk_add_provider() failed\n");\r\nclk_unregister(td->dfll_clk);\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic void dfll_unregister_clk(struct tegra_dfll *td)\r\n{\r\nof_clk_del_provider(td->dev->of_node);\r\nclk_unregister(td->dfll_clk);\r\ntd->dfll_clk = NULL;\r\n}\r\nstatic u64 dfll_calc_monitored_rate(u32 monitor_data,\r\nunsigned long ref_rate)\r\n{\r\nreturn monitor_data * (ref_rate / REF_CLK_CYC_PER_DVCO_SAMPLE);\r\n}\r\nstatic u64 dfll_read_monitor_rate(struct tegra_dfll *td)\r\n{\r\nu32 v, s;\r\nu64 pre_scaler_rate, post_scaler_rate;\r\nif (!dfll_is_running(td))\r\nreturn 0;\r\nv = dfll_readl(td, DFLL_MONITOR_DATA);\r\nv = (v & DFLL_MONITOR_DATA_VAL_MASK) >> DFLL_MONITOR_DATA_VAL_SHIFT;\r\npre_scaler_rate = dfll_calc_monitored_rate(v, td->ref_rate);\r\ns = dfll_readl(td, DFLL_FREQ_REQ);\r\ns = (s & DFLL_FREQ_REQ_SCALE_MASK) >> DFLL_FREQ_REQ_SCALE_SHIFT;\r\npost_scaler_rate = dfll_scale_dvco_rate(s, pre_scaler_rate);\r\nreturn post_scaler_rate;\r\n}\r\nstatic int attr_enable_get(void *data, u64 *val)\r\n{\r\nstruct tegra_dfll *td = data;\r\n*val = dfll_is_running(td);\r\nreturn 0;\r\n}\r\nstatic int attr_enable_set(void *data, u64 val)\r\n{\r\nstruct tegra_dfll *td = data;\r\nreturn val ? dfll_enable(td) : dfll_disable(td);\r\n}\r\nstatic int attr_lock_get(void *data, u64 *val)\r\n{\r\nstruct tegra_dfll *td = data;\r\n*val = (td->mode == DFLL_CLOSED_LOOP);\r\nreturn 0;\r\n}\r\nstatic int attr_lock_set(void *data, u64 val)\r\n{\r\nstruct tegra_dfll *td = data;\r\nreturn val ? dfll_lock(td) : dfll_unlock(td);\r\n}\r\nstatic int attr_rate_get(void *data, u64 *val)\r\n{\r\nstruct tegra_dfll *td = data;\r\n*val = dfll_read_monitor_rate(td);\r\nreturn 0;\r\n}\r\nstatic int attr_rate_set(void *data, u64 val)\r\n{\r\nstruct tegra_dfll *td = data;\r\nreturn dfll_request_rate(td, val);\r\n}\r\nstatic int attr_registers_show(struct seq_file *s, void *data)\r\n{\r\nu32 val, offs;\r\nstruct tegra_dfll *td = s->private;\r\nseq_puts(s, "CONTROL REGISTERS:\n");\r\nfor (offs = 0; offs <= DFLL_MONITOR_DATA; offs += 4) {\r\nif (offs == DFLL_OUTPUT_CFG)\r\nval = dfll_i2c_readl(td, offs);\r\nelse\r\nval = dfll_readl(td, offs);\r\nseq_printf(s, "[0x%02x] = 0x%08x\n", offs, val);\r\n}\r\nseq_puts(s, "\nI2C and INTR REGISTERS:\n");\r\nfor (offs = DFLL_I2C_CFG; offs <= DFLL_I2C_STS; offs += 4)\r\nseq_printf(s, "[0x%02x] = 0x%08x\n", offs,\r\ndfll_i2c_readl(td, offs));\r\nfor (offs = DFLL_INTR_STS; offs <= DFLL_INTR_EN; offs += 4)\r\nseq_printf(s, "[0x%02x] = 0x%08x\n", offs,\r\ndfll_i2c_readl(td, offs));\r\nseq_puts(s, "\nINTEGRATED I2C CONTROLLER REGISTERS:\n");\r\noffs = DFLL_I2C_CLK_DIVISOR;\r\nseq_printf(s, "[0x%02x] = 0x%08x\n", offs,\r\n__raw_readl(td->i2c_controller_base + offs));\r\nseq_puts(s, "\nLUT:\n");\r\nfor (offs = 0; offs < 4 * MAX_DFLL_VOLTAGES; offs += 4)\r\nseq_printf(s, "[0x%02x] = 0x%08x\n", offs,\r\n__raw_readl(td->lut_base + offs));\r\nreturn 0;\r\n}\r\nstatic int attr_registers_open(struct inode *inode, struct file *file)\r\n{\r\nreturn single_open(file, attr_registers_show, inode->i_private);\r\n}\r\nstatic int dfll_debug_init(struct tegra_dfll *td)\r\n{\r\nint ret;\r\nif (!td || (td->mode == DFLL_UNINITIALIZED))\r\nreturn 0;\r\ntd->debugfs_dir = debugfs_create_dir("tegra_dfll_fcpu", NULL);\r\nif (!td->debugfs_dir)\r\nreturn -ENOMEM;\r\nret = -ENOMEM;\r\nif (!debugfs_create_file("enable", S_IRUGO | S_IWUSR,\r\ntd->debugfs_dir, td, &enable_fops))\r\ngoto err_out;\r\nif (!debugfs_create_file("lock", S_IRUGO,\r\ntd->debugfs_dir, td, &lock_fops))\r\ngoto err_out;\r\nif (!debugfs_create_file("rate", S_IRUGO,\r\ntd->debugfs_dir, td, &rate_fops))\r\ngoto err_out;\r\nif (!debugfs_create_file("registers", S_IRUGO,\r\ntd->debugfs_dir, td, &attr_registers_fops))\r\ngoto err_out;\r\nreturn 0;\r\nerr_out:\r\ndebugfs_remove_recursive(td->debugfs_dir);\r\nreturn ret;\r\n}\r\nstatic void dfll_set_default_params(struct tegra_dfll *td)\r\n{\r\nu32 val;\r\nval = DIV_ROUND_UP(td->ref_rate, td->sample_rate * 32);\r\nBUG_ON(val > DFLL_CONFIG_DIV_MASK);\r\ndfll_writel(td, val, DFLL_CONFIG);\r\nval = (td->force_mode << DFLL_PARAMS_FORCE_MODE_SHIFT) |\r\n(td->cf << DFLL_PARAMS_CF_PARAM_SHIFT) |\r\n(td->ci << DFLL_PARAMS_CI_PARAM_SHIFT) |\r\n(td->cg << DFLL_PARAMS_CG_PARAM_SHIFT) |\r\n(td->cg_scale ? DFLL_PARAMS_CG_SCALE : 0);\r\ndfll_writel(td, val, DFLL_PARAMS);\r\ndfll_tune_low(td);\r\ndfll_writel(td, td->droop_ctrl, DFLL_DROOP_CTRL);\r\ndfll_writel(td, DFLL_MONITOR_CTRL_FREQ, DFLL_MONITOR_CTRL);\r\n}\r\nstatic int dfll_init_clks(struct tegra_dfll *td)\r\n{\r\ntd->ref_clk = devm_clk_get(td->dev, "ref");\r\nif (IS_ERR(td->ref_clk)) {\r\ndev_err(td->dev, "missing ref clock\n");\r\nreturn PTR_ERR(td->ref_clk);\r\n}\r\ntd->soc_clk = devm_clk_get(td->dev, "soc");\r\nif (IS_ERR(td->soc_clk)) {\r\ndev_err(td->dev, "missing soc clock\n");\r\nreturn PTR_ERR(td->soc_clk);\r\n}\r\ntd->i2c_clk = devm_clk_get(td->dev, "i2c");\r\nif (IS_ERR(td->i2c_clk)) {\r\ndev_err(td->dev, "missing i2c clock\n");\r\nreturn PTR_ERR(td->i2c_clk);\r\n}\r\ntd->i2c_clk_rate = clk_get_rate(td->i2c_clk);\r\nreturn 0;\r\n}\r\nstatic int dfll_init(struct tegra_dfll *td)\r\n{\r\nint ret;\r\ntd->ref_rate = clk_get_rate(td->ref_clk);\r\nif (td->ref_rate != REF_CLOCK_RATE) {\r\ndev_err(td->dev, "unexpected ref clk rate %lu, expecting %lu",\r\ntd->ref_rate, REF_CLOCK_RATE);\r\nreturn -EINVAL;\r\n}\r\nreset_control_deassert(td->dvco_rst);\r\nret = clk_prepare(td->ref_clk);\r\nif (ret) {\r\ndev_err(td->dev, "failed to prepare ref_clk\n");\r\nreturn ret;\r\n}\r\nret = clk_prepare(td->soc_clk);\r\nif (ret) {\r\ndev_err(td->dev, "failed to prepare soc_clk\n");\r\ngoto di_err1;\r\n}\r\nret = clk_prepare(td->i2c_clk);\r\nif (ret) {\r\ndev_err(td->dev, "failed to prepare i2c_clk\n");\r\ngoto di_err2;\r\n}\r\ntd->last_unrounded_rate = 0;\r\npm_runtime_enable(td->dev);\r\npm_runtime_get_sync(td->dev);\r\ndfll_set_mode(td, DFLL_DISABLED);\r\ndfll_set_default_params(td);\r\nif (td->soc->init_clock_trimmers)\r\ntd->soc->init_clock_trimmers();\r\ndfll_set_open_loop_config(td);\r\ndfll_init_out_if(td);\r\npm_runtime_put_sync(td->dev);\r\nreturn 0;\r\ndi_err2:\r\nclk_unprepare(td->soc_clk);\r\ndi_err1:\r\nclk_unprepare(td->ref_clk);\r\nreset_control_assert(td->dvco_rst);\r\nreturn ret;\r\n}\r\nstatic int find_vdd_map_entry_exact(struct tegra_dfll *td, int uV)\r\n{\r\nint i, n_voltages, reg_uV;\r\nn_voltages = regulator_count_voltages(td->vdd_reg);\r\nfor (i = 0; i < n_voltages; i++) {\r\nreg_uV = regulator_list_voltage(td->vdd_reg, i);\r\nif (reg_uV < 0)\r\nbreak;\r\nif (uV == reg_uV)\r\nreturn i;\r\n}\r\ndev_err(td->dev, "no voltage map entry for %d uV\n", uV);\r\nreturn -EINVAL;\r\n}\r\nstatic int find_vdd_map_entry_min(struct tegra_dfll *td, int uV)\r\n{\r\nint i, n_voltages, reg_uV;\r\nn_voltages = regulator_count_voltages(td->vdd_reg);\r\nfor (i = 0; i < n_voltages; i++) {\r\nreg_uV = regulator_list_voltage(td->vdd_reg, i);\r\nif (reg_uV < 0)\r\nbreak;\r\nif (uV <= reg_uV)\r\nreturn i;\r\n}\r\ndev_err(td->dev, "no voltage map entry rounding to %d uV\n", uV);\r\nreturn -EINVAL;\r\n}\r\nstatic int dfll_build_i2c_lut(struct tegra_dfll *td)\r\n{\r\nint ret = -EINVAL;\r\nint j, v, v_max, v_opp;\r\nint selector;\r\nunsigned long rate;\r\nstruct dev_pm_opp *opp;\r\nint lut;\r\nrcu_read_lock();\r\nrate = ULONG_MAX;\r\nopp = dev_pm_opp_find_freq_floor(td->soc->dev, &rate);\r\nif (IS_ERR(opp)) {\r\ndev_err(td->dev, "couldn't get vmax opp, empty opp table?\n");\r\ngoto out;\r\n}\r\nv_max = dev_pm_opp_get_voltage(opp);\r\nv = td->soc->min_millivolts * 1000;\r\nlut = find_vdd_map_entry_exact(td, v);\r\nif (lut < 0)\r\ngoto out;\r\ntd->i2c_lut[0] = lut;\r\nfor (j = 1, rate = 0; ; rate++) {\r\nopp = dev_pm_opp_find_freq_ceil(td->soc->dev, &rate);\r\nif (IS_ERR(opp))\r\nbreak;\r\nv_opp = dev_pm_opp_get_voltage(opp);\r\nif (v_opp <= td->soc->min_millivolts * 1000)\r\ntd->dvco_rate_min = dev_pm_opp_get_freq(opp);\r\nfor (;;) {\r\nv += max(1, (v_max - v) / (MAX_DFLL_VOLTAGES - j));\r\nif (v >= v_opp)\r\nbreak;\r\nselector = find_vdd_map_entry_min(td, v);\r\nif (selector < 0)\r\ngoto out;\r\nif (selector != td->i2c_lut[j - 1])\r\ntd->i2c_lut[j++] = selector;\r\n}\r\nv = (j == MAX_DFLL_VOLTAGES - 1) ? v_max : v_opp;\r\nselector = find_vdd_map_entry_exact(td, v);\r\nif (selector < 0)\r\ngoto out;\r\nif (selector != td->i2c_lut[j - 1])\r\ntd->i2c_lut[j++] = selector;\r\nif (v >= v_max)\r\nbreak;\r\n}\r\ntd->i2c_lut_size = j;\r\nif (!td->dvco_rate_min)\r\ndev_err(td->dev, "no opp above DFLL minimum voltage %d mV\n",\r\ntd->soc->min_millivolts);\r\nelse\r\nret = 0;\r\nout:\r\nrcu_read_unlock();\r\nreturn ret;\r\n}\r\nstatic bool read_dt_param(struct tegra_dfll *td, const char *param, u32 *dest)\r\n{\r\nint err = of_property_read_u32(td->dev->of_node, param, dest);\r\nif (err < 0) {\r\ndev_err(td->dev, "failed to read DT parameter %s: %d\n",\r\nparam, err);\r\nreturn false;\r\n}\r\nreturn true;\r\n}\r\nstatic int dfll_fetch_i2c_params(struct tegra_dfll *td)\r\n{\r\nstruct regmap *regmap;\r\nstruct device *i2c_dev;\r\nstruct i2c_client *i2c_client;\r\nint vsel_reg, vsel_mask;\r\nint ret;\r\nif (!read_dt_param(td, "nvidia,i2c-fs-rate", &td->i2c_fs_rate))\r\nreturn -EINVAL;\r\nregmap = regulator_get_regmap(td->vdd_reg);\r\ni2c_dev = regmap_get_device(regmap);\r\ni2c_client = to_i2c_client(i2c_dev);\r\ntd->i2c_slave_addr = i2c_client->addr;\r\nret = regulator_get_hardware_vsel_register(td->vdd_reg,\r\n&vsel_reg,\r\n&vsel_mask);\r\nif (ret < 0) {\r\ndev_err(td->dev,\r\n"regulator unsuitable for DFLL I2C operation\n");\r\nreturn -EINVAL;\r\n}\r\ntd->i2c_reg = vsel_reg;\r\nret = dfll_build_i2c_lut(td);\r\nif (ret) {\r\ndev_err(td->dev, "couldn't build I2C LUT\n");\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic int dfll_fetch_common_params(struct tegra_dfll *td)\r\n{\r\nbool ok = true;\r\nok &= read_dt_param(td, "nvidia,droop-ctrl", &td->droop_ctrl);\r\nok &= read_dt_param(td, "nvidia,sample-rate", &td->sample_rate);\r\nok &= read_dt_param(td, "nvidia,force-mode", &td->force_mode);\r\nok &= read_dt_param(td, "nvidia,cf", &td->cf);\r\nok &= read_dt_param(td, "nvidia,ci", &td->ci);\r\nok &= read_dt_param(td, "nvidia,cg", &td->cg);\r\ntd->cg_scale = of_property_read_bool(td->dev->of_node,\r\n"nvidia,cg-scale");\r\nif (of_property_read_string(td->dev->of_node, "clock-output-names",\r\n&td->output_clock_name)) {\r\ndev_err(td->dev, "missing clock-output-names property\n");\r\nok = false;\r\n}\r\nreturn ok ? 0 : -EINVAL;\r\n}\r\nint tegra_dfll_register(struct platform_device *pdev,\r\nstruct tegra_dfll_soc_data *soc)\r\n{\r\nstruct resource *mem;\r\nstruct tegra_dfll *td;\r\nint ret;\r\nif (!soc) {\r\ndev_err(&pdev->dev, "no tegra_dfll_soc_data provided\n");\r\nreturn -EINVAL;\r\n}\r\ntd = devm_kzalloc(&pdev->dev, sizeof(*td), GFP_KERNEL);\r\nif (!td)\r\nreturn -ENOMEM;\r\ntd->dev = &pdev->dev;\r\nplatform_set_drvdata(pdev, td);\r\ntd->soc = soc;\r\ntd->vdd_reg = devm_regulator_get(td->dev, "vdd-cpu");\r\nif (IS_ERR(td->vdd_reg)) {\r\ndev_err(td->dev, "couldn't get vdd_cpu regulator\n");\r\nreturn PTR_ERR(td->vdd_reg);\r\n}\r\ntd->dvco_rst = devm_reset_control_get(td->dev, "dvco");\r\nif (IS_ERR(td->dvco_rst)) {\r\ndev_err(td->dev, "couldn't get dvco reset\n");\r\nreturn PTR_ERR(td->dvco_rst);\r\n}\r\nret = dfll_fetch_common_params(td);\r\nif (ret) {\r\ndev_err(td->dev, "couldn't parse device tree parameters\n");\r\nreturn ret;\r\n}\r\nret = dfll_fetch_i2c_params(td);\r\nif (ret)\r\nreturn ret;\r\nmem = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nif (!mem) {\r\ndev_err(td->dev, "no control register resource\n");\r\nreturn -ENODEV;\r\n}\r\ntd->base = devm_ioremap(td->dev, mem->start, resource_size(mem));\r\nif (!td->base) {\r\ndev_err(td->dev, "couldn't ioremap DFLL control registers\n");\r\nreturn -ENODEV;\r\n}\r\nmem = platform_get_resource(pdev, IORESOURCE_MEM, 1);\r\nif (!mem) {\r\ndev_err(td->dev, "no i2c_base resource\n");\r\nreturn -ENODEV;\r\n}\r\ntd->i2c_base = devm_ioremap(td->dev, mem->start, resource_size(mem));\r\nif (!td->i2c_base) {\r\ndev_err(td->dev, "couldn't ioremap i2c_base resource\n");\r\nreturn -ENODEV;\r\n}\r\nmem = platform_get_resource(pdev, IORESOURCE_MEM, 2);\r\nif (!mem) {\r\ndev_err(td->dev, "no i2c_controller_base resource\n");\r\nreturn -ENODEV;\r\n}\r\ntd->i2c_controller_base = devm_ioremap(td->dev, mem->start,\r\nresource_size(mem));\r\nif (!td->i2c_controller_base) {\r\ndev_err(td->dev,\r\n"couldn't ioremap i2c_controller_base resource\n");\r\nreturn -ENODEV;\r\n}\r\nmem = platform_get_resource(pdev, IORESOURCE_MEM, 3);\r\nif (!mem) {\r\ndev_err(td->dev, "no lut_base resource\n");\r\nreturn -ENODEV;\r\n}\r\ntd->lut_base = devm_ioremap(td->dev, mem->start, resource_size(mem));\r\nif (!td->lut_base) {\r\ndev_err(td->dev,\r\n"couldn't ioremap lut_base resource\n");\r\nreturn -ENODEV;\r\n}\r\nret = dfll_init_clks(td);\r\nif (ret) {\r\ndev_err(&pdev->dev, "DFLL clock init error\n");\r\nreturn ret;\r\n}\r\nret = dfll_init(td);\r\nif (ret)\r\nreturn ret;\r\nret = dfll_register_clk(td);\r\nif (ret) {\r\ndev_err(&pdev->dev, "DFLL clk registration failed\n");\r\nreturn ret;\r\n}\r\n#ifdef CONFIG_DEBUG_FS\r\ndfll_debug_init(td);\r\n#endif\r\nreturn 0;\r\n}\r\nint tegra_dfll_unregister(struct platform_device *pdev)\r\n{\r\nstruct tegra_dfll *td = platform_get_drvdata(pdev);\r\nif (td->mode != DFLL_DISABLED) {\r\ndev_err(&pdev->dev,\r\n"must disable DFLL before removing driver\n");\r\nreturn -EBUSY;\r\n}\r\ndebugfs_remove_recursive(td->debugfs_dir);\r\ndfll_unregister_clk(td);\r\npm_runtime_disable(&pdev->dev);\r\nclk_unprepare(td->ref_clk);\r\nclk_unprepare(td->soc_clk);\r\nclk_unprepare(td->i2c_clk);\r\nreset_control_assert(td->dvco_rst);\r\nreturn 0;\r\n}
