static struct qcom_scm_command *alloc_qcom_scm_command(size_t cmd_size, size_t resp_size)\r\n{\r\nstruct qcom_scm_command *cmd;\r\nsize_t len = sizeof(*cmd) + sizeof(struct qcom_scm_response) + cmd_size +\r\nresp_size;\r\nu32 offset;\r\ncmd = kzalloc(PAGE_ALIGN(len), GFP_KERNEL);\r\nif (cmd) {\r\ncmd->len = cpu_to_le32(len);\r\noffset = offsetof(struct qcom_scm_command, buf);\r\ncmd->buf_offset = cpu_to_le32(offset);\r\ncmd->resp_hdr_offset = cpu_to_le32(offset + cmd_size);\r\n}\r\nreturn cmd;\r\n}\r\nstatic inline void free_qcom_scm_command(struct qcom_scm_command *cmd)\r\n{\r\nkfree(cmd);\r\n}\r\nstatic inline struct qcom_scm_response *qcom_scm_command_to_response(\r\nconst struct qcom_scm_command *cmd)\r\n{\r\nreturn (void *)cmd + le32_to_cpu(cmd->resp_hdr_offset);\r\n}\r\nstatic inline void *qcom_scm_get_command_buffer(const struct qcom_scm_command *cmd)\r\n{\r\nreturn (void *)cmd->buf;\r\n}\r\nstatic inline void *qcom_scm_get_response_buffer(const struct qcom_scm_response *rsp)\r\n{\r\nreturn (void *)rsp + le32_to_cpu(rsp->buf_offset);\r\n}\r\nstatic int qcom_scm_remap_error(int err)\r\n{\r\npr_err("qcom_scm_call failed with error code %d\n", err);\r\nswitch (err) {\r\ncase QCOM_SCM_ERROR:\r\nreturn -EIO;\r\ncase QCOM_SCM_EINVAL_ADDR:\r\ncase QCOM_SCM_EINVAL_ARG:\r\nreturn -EINVAL;\r\ncase QCOM_SCM_EOPNOTSUPP:\r\nreturn -EOPNOTSUPP;\r\ncase QCOM_SCM_ENOMEM:\r\nreturn -ENOMEM;\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic u32 smc(u32 cmd_addr)\r\n{\r\nint context_id;\r\nregister u32 r0 asm("r0") = 1;\r\nregister u32 r1 asm("r1") = (u32)&context_id;\r\nregister u32 r2 asm("r2") = cmd_addr;\r\ndo {\r\nasm volatile(\r\n__asmeq("%0", "r0")\r\n__asmeq("%1", "r0")\r\n__asmeq("%2", "r1")\r\n__asmeq("%3", "r2")\r\n#ifdef REQUIRES_SEC\r\n".arch_extension sec\n"\r\n#endif\r\n"smc #0 @ switch to secure world\n"\r\n: "=r" (r0)\r\n: "r" (r0), "r" (r1), "r" (r2)\r\n: "r3");\r\n} while (r0 == QCOM_SCM_INTERRUPTED);\r\nreturn r0;\r\n}\r\nstatic int __qcom_scm_call(const struct qcom_scm_command *cmd)\r\n{\r\nint ret;\r\nu32 cmd_addr = virt_to_phys(cmd);\r\nsecure_flush_area(cmd, cmd->len);\r\nret = smc(cmd_addr);\r\nif (ret < 0)\r\nret = qcom_scm_remap_error(ret);\r\nreturn ret;\r\n}\r\nstatic void qcom_scm_inv_range(unsigned long start, unsigned long end)\r\n{\r\nu32 cacheline_size, ctr;\r\nasm volatile("mrc p15, 0, %0, c0, c0, 1" : "=r" (ctr));\r\ncacheline_size = 4 << ((ctr >> 16) & 0xf);\r\nstart = round_down(start, cacheline_size);\r\nend = round_up(end, cacheline_size);\r\nouter_inv_range(start, end);\r\nwhile (start < end) {\r\nasm ("mcr p15, 0, %0, c7, c6, 1" : : "r" (start)\r\n: "memory");\r\nstart += cacheline_size;\r\n}\r\ndsb();\r\nisb();\r\n}\r\nstatic int qcom_scm_call(u32 svc_id, u32 cmd_id, const void *cmd_buf,\r\nsize_t cmd_len, void *resp_buf, size_t resp_len)\r\n{\r\nint ret;\r\nstruct qcom_scm_command *cmd;\r\nstruct qcom_scm_response *rsp;\r\nunsigned long start, end;\r\ncmd = alloc_qcom_scm_command(cmd_len, resp_len);\r\nif (!cmd)\r\nreturn -ENOMEM;\r\ncmd->id = cpu_to_le32((svc_id << 10) | cmd_id);\r\nif (cmd_buf)\r\nmemcpy(qcom_scm_get_command_buffer(cmd), cmd_buf, cmd_len);\r\nmutex_lock(&qcom_scm_lock);\r\nret = __qcom_scm_call(cmd);\r\nmutex_unlock(&qcom_scm_lock);\r\nif (ret)\r\ngoto out;\r\nrsp = qcom_scm_command_to_response(cmd);\r\nstart = (unsigned long)rsp;\r\ndo {\r\nqcom_scm_inv_range(start, start + sizeof(*rsp));\r\n} while (!rsp->is_complete);\r\nend = (unsigned long)qcom_scm_get_response_buffer(rsp) + resp_len;\r\nqcom_scm_inv_range(start, end);\r\nif (resp_buf)\r\nmemcpy(resp_buf, qcom_scm_get_response_buffer(rsp), resp_len);\r\nout:\r\nfree_qcom_scm_command(cmd);\r\nreturn ret;\r\n}\r\nstatic s32 qcom_scm_call_atomic1(u32 svc, u32 cmd, u32 arg1)\r\n{\r\nint context_id;\r\nregister u32 r0 asm("r0") = SCM_ATOMIC(svc, cmd, 1);\r\nregister u32 r1 asm("r1") = (u32)&context_id;\r\nregister u32 r2 asm("r2") = arg1;\r\nasm volatile(\r\n__asmeq("%0", "r0")\r\n__asmeq("%1", "r0")\r\n__asmeq("%2", "r1")\r\n__asmeq("%3", "r2")\r\n#ifdef REQUIRES_SEC\r\n".arch_extension sec\n"\r\n#endif\r\n"smc #0 @ switch to secure world\n"\r\n: "=r" (r0)\r\n: "r" (r0), "r" (r1), "r" (r2)\r\n: "r3");\r\nreturn r0;\r\n}\r\nu32 qcom_scm_get_version(void)\r\n{\r\nint context_id;\r\nstatic u32 version = -1;\r\nregister u32 r0 asm("r0");\r\nregister u32 r1 asm("r1");\r\nif (version != -1)\r\nreturn version;\r\nmutex_lock(&qcom_scm_lock);\r\nr0 = 0x1 << 8;\r\nr1 = (u32)&context_id;\r\ndo {\r\nasm volatile(\r\n__asmeq("%0", "r0")\r\n__asmeq("%1", "r1")\r\n__asmeq("%2", "r0")\r\n__asmeq("%3", "r1")\r\n#ifdef REQUIRES_SEC\r\n".arch_extension sec\n"\r\n#endif\r\n"smc #0 @ switch to secure world\n"\r\n: "=r" (r0), "=r" (r1)\r\n: "r" (r0), "r" (r1)\r\n: "r2", "r3");\r\n} while (r0 == QCOM_SCM_INTERRUPTED);\r\nversion = r1;\r\nmutex_unlock(&qcom_scm_lock);\r\nreturn version;\r\n}\r\nstatic int qcom_scm_set_boot_addr(u32 addr, int flags)\r\n{\r\nstruct {\r\n__le32 flags;\r\n__le32 addr;\r\n} cmd;\r\ncmd.addr = cpu_to_le32(addr);\r\ncmd.flags = cpu_to_le32(flags);\r\nreturn qcom_scm_call(QCOM_SCM_SVC_BOOT, QCOM_SCM_BOOT_ADDR,\r\n&cmd, sizeof(cmd), NULL, 0);\r\n}\r\nint __qcom_scm_set_cold_boot_addr(void *entry, const cpumask_t *cpus)\r\n{\r\nint flags = 0;\r\nint cpu;\r\nint scm_cb_flags[] = {\r\nQCOM_SCM_FLAG_COLDBOOT_CPU0,\r\nQCOM_SCM_FLAG_COLDBOOT_CPU1,\r\nQCOM_SCM_FLAG_COLDBOOT_CPU2,\r\nQCOM_SCM_FLAG_COLDBOOT_CPU3,\r\n};\r\nif (!cpus || (cpus && cpumask_empty(cpus)))\r\nreturn -EINVAL;\r\nfor_each_cpu(cpu, cpus) {\r\nif (cpu < ARRAY_SIZE(scm_cb_flags))\r\nflags |= scm_cb_flags[cpu];\r\nelse\r\nset_cpu_present(cpu, false);\r\n}\r\nreturn qcom_scm_set_boot_addr(virt_to_phys(entry), flags);\r\n}\r\nint __qcom_scm_set_warm_boot_addr(void *entry, const cpumask_t *cpus)\r\n{\r\nint ret;\r\nint flags = 0;\r\nint cpu;\r\nfor_each_cpu(cpu, cpus) {\r\nif (entry == qcom_scm_wb[cpu].entry)\r\ncontinue;\r\nflags |= qcom_scm_wb[cpu].flag;\r\n}\r\nif (!flags)\r\nreturn 0;\r\nret = qcom_scm_set_boot_addr(virt_to_phys(entry), flags);\r\nif (!ret) {\r\nfor_each_cpu(cpu, cpus)\r\nqcom_scm_wb[cpu].entry = entry;\r\n}\r\nreturn ret;\r\n}\r\nvoid __qcom_scm_cpu_power_down(u32 flags)\r\n{\r\nqcom_scm_call_atomic1(QCOM_SCM_SVC_BOOT, QCOM_SCM_CMD_TERMINATE_PC,\r\nflags & QCOM_SCM_FLUSH_FLAG_MASK);\r\n}\r\nint __qcom_scm_is_call_available(u32 svc_id, u32 cmd_id)\r\n{\r\nint ret;\r\n__le32 svc_cmd = cpu_to_le32((svc_id << 10) | cmd_id);\r\n__le32 ret_val = 0;\r\nret = qcom_scm_call(QCOM_SCM_SVC_INFO, QCOM_IS_CALL_AVAIL_CMD, &svc_cmd,\r\nsizeof(svc_cmd), &ret_val, sizeof(ret_val));\r\nif (ret)\r\nreturn ret;\r\nreturn le32_to_cpu(ret_val);\r\n}\r\nint __qcom_scm_hdcp_req(struct qcom_scm_hdcp_req *req, u32 req_cnt, u32 *resp)\r\n{\r\nif (req_cnt > QCOM_SCM_HDCP_MAX_REQ_CNT)\r\nreturn -ERANGE;\r\nreturn qcom_scm_call(QCOM_SCM_SVC_HDCP, QCOM_SCM_CMD_HDCP,\r\nreq, req_cnt * sizeof(*req), resp, sizeof(*resp));\r\n}
