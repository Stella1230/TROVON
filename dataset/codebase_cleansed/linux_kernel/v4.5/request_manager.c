static inline int IQ_INSTR_MODE_64B(struct octeon_device *oct, int iq_no)\r\n{\r\nstruct octeon_instr_queue *iq =\r\n(struct octeon_instr_queue *)oct->instr_queue[iq_no];\r\nreturn iq->iqcmd_64B;\r\n}\r\nint octeon_init_instr_queue(struct octeon_device *oct,\r\nu32 iq_no, u32 num_descs)\r\n{\r\nstruct octeon_instr_queue *iq;\r\nstruct octeon_iq_config *conf = NULL;\r\nu32 q_size;\r\nstruct cavium_wq *db_wq;\r\nif (OCTEON_CN6XXX(oct))\r\nconf = &(CFG_GET_IQ_CFG(CHIP_FIELD(oct, cn6xxx, conf)));\r\nif (!conf) {\r\ndev_err(&oct->pci_dev->dev, "Unsupported Chip %x\n",\r\noct->chip_id);\r\nreturn 1;\r\n}\r\nif (num_descs & (num_descs - 1)) {\r\ndev_err(&oct->pci_dev->dev,\r\n"Number of descriptors for instr queue %d not in power of 2.\n",\r\niq_no);\r\nreturn 1;\r\n}\r\nq_size = (u32)conf->instr_type * num_descs;\r\niq = oct->instr_queue[iq_no];\r\niq->base_addr = lio_dma_alloc(oct, q_size,\r\n(dma_addr_t *)&iq->base_addr_dma);\r\nif (!iq->base_addr) {\r\ndev_err(&oct->pci_dev->dev, "Cannot allocate memory for instr queue %d\n",\r\niq_no);\r\nreturn 1;\r\n}\r\niq->max_count = num_descs;\r\niq->request_list = vmalloc(sizeof(*iq->request_list) * num_descs);\r\nif (!iq->request_list) {\r\nlio_dma_free(oct, q_size, iq->base_addr, iq->base_addr_dma);\r\ndev_err(&oct->pci_dev->dev, "Alloc failed for IQ[%d] nr free list\n",\r\niq_no);\r\nreturn 1;\r\n}\r\nmemset(iq->request_list, 0, sizeof(*iq->request_list) * num_descs);\r\ndev_dbg(&oct->pci_dev->dev, "IQ[%d]: base: %p basedma: %llx count: %d\n",\r\niq_no, iq->base_addr, iq->base_addr_dma, iq->max_count);\r\niq->iq_no = iq_no;\r\niq->fill_threshold = (u32)conf->db_min;\r\niq->fill_cnt = 0;\r\niq->host_write_index = 0;\r\niq->octeon_read_index = 0;\r\niq->flush_index = 0;\r\niq->last_db_time = 0;\r\niq->do_auto_flush = 1;\r\niq->db_timeout = (u32)conf->db_timeout;\r\natomic_set(&iq->instr_pending, 0);\r\nspin_lock_init(&iq->lock);\r\noct->io_qmask.iq |= (1 << iq_no);\r\noct->io_qmask.iq64B |= ((conf->instr_type == 64) << iq_no);\r\niq->iqcmd_64B = (conf->instr_type == 64);\r\noct->fn_list.setup_iq_regs(oct, iq_no);\r\noct->check_db_wq[iq_no].wq = create_workqueue("check_iq_db");\r\nif (!oct->check_db_wq[iq_no].wq) {\r\nlio_dma_free(oct, q_size, iq->base_addr, iq->base_addr_dma);\r\ndev_err(&oct->pci_dev->dev, "check db wq create failed for iq %d\n",\r\niq_no);\r\nreturn 1;\r\n}\r\ndb_wq = &oct->check_db_wq[iq_no];\r\nINIT_DELAYED_WORK(&db_wq->wk.work, check_db_timeout);\r\ndb_wq->wk.ctxptr = oct;\r\ndb_wq->wk.ctxul = iq_no;\r\nqueue_delayed_work(db_wq->wq, &db_wq->wk.work, msecs_to_jiffies(1));\r\nreturn 0;\r\n}\r\nint octeon_delete_instr_queue(struct octeon_device *oct, u32 iq_no)\r\n{\r\nu64 desc_size = 0, q_size;\r\nstruct octeon_instr_queue *iq = oct->instr_queue[iq_no];\r\ncancel_delayed_work_sync(&oct->check_db_wq[iq_no].wk.work);\r\nflush_workqueue(oct->check_db_wq[iq_no].wq);\r\ndestroy_workqueue(oct->check_db_wq[iq_no].wq);\r\nif (OCTEON_CN6XXX(oct))\r\ndesc_size =\r\nCFG_GET_IQ_INSTR_TYPE(CHIP_FIELD(oct, cn6xxx, conf));\r\nvfree(iq->request_list);\r\nif (iq->base_addr) {\r\nq_size = iq->max_count * desc_size;\r\nlio_dma_free(oct, (u32)q_size, iq->base_addr,\r\niq->base_addr_dma);\r\nreturn 0;\r\n}\r\nreturn 1;\r\n}\r\nint octeon_setup_iq(struct octeon_device *oct,\r\nu32 iq_no,\r\nu32 num_descs,\r\nvoid *app_ctx)\r\n{\r\nif (oct->instr_queue[iq_no]) {\r\ndev_dbg(&oct->pci_dev->dev, "IQ is in use. Cannot create the IQ: %d again\n",\r\niq_no);\r\noct->instr_queue[iq_no]->app_ctx = app_ctx;\r\nreturn 0;\r\n}\r\noct->instr_queue[iq_no] =\r\nvmalloc(sizeof(struct octeon_instr_queue));\r\nif (!oct->instr_queue[iq_no])\r\nreturn 1;\r\nmemset(oct->instr_queue[iq_no], 0,\r\nsizeof(struct octeon_instr_queue));\r\noct->instr_queue[iq_no]->app_ctx = app_ctx;\r\nif (octeon_init_instr_queue(oct, iq_no, num_descs)) {\r\nvfree(oct->instr_queue[iq_no]);\r\noct->instr_queue[iq_no] = NULL;\r\nreturn 1;\r\n}\r\noct->num_iqs++;\r\noct->fn_list.enable_io_queues(oct);\r\nreturn 0;\r\n}\r\nint lio_wait_for_instr_fetch(struct octeon_device *oct)\r\n{\r\nint i, retry = 1000, pending, instr_cnt = 0;\r\ndo {\r\ninstr_cnt = 0;\r\nfor (i = 0; i < MAX_OCTEON_INSTR_QUEUES; i++) {\r\nif (!(oct->io_qmask.iq & (1UL << i)))\r\ncontinue;\r\npending =\r\natomic_read(&oct->\r\ninstr_queue[i]->instr_pending);\r\nif (pending)\r\n__check_db_timeout(oct, i);\r\ninstr_cnt += pending;\r\n}\r\nif (instr_cnt == 0)\r\nbreak;\r\nschedule_timeout_uninterruptible(1);\r\n} while (retry-- && instr_cnt);\r\nreturn instr_cnt;\r\n}\r\nstatic inline void\r\nring_doorbell(struct octeon_device *oct, struct octeon_instr_queue *iq)\r\n{\r\nif (atomic_read(&oct->status) == OCT_DEV_RUNNING) {\r\nwritel(iq->fill_cnt, iq->doorbell_reg);\r\nmmiowb();\r\niq->fill_cnt = 0;\r\niq->last_db_time = jiffies;\r\nreturn;\r\n}\r\n}\r\nstatic inline void __copy_cmd_into_iq(struct octeon_instr_queue *iq,\r\nu8 *cmd)\r\n{\r\nu8 *iqptr, cmdsize;\r\ncmdsize = ((iq->iqcmd_64B) ? 64 : 32);\r\niqptr = iq->base_addr + (cmdsize * iq->host_write_index);\r\nmemcpy(iqptr, cmd, cmdsize);\r\n}\r\nint\r\nocteon_register_reqtype_free_fn(struct octeon_device *oct, int reqtype,\r\nvoid (*fn)(void *))\r\n{\r\nif (reqtype > REQTYPE_LAST) {\r\ndev_err(&oct->pci_dev->dev, "%s: Invalid reqtype: %d\n",\r\n__func__, reqtype);\r\nreturn -EINVAL;\r\n}\r\nreqtype_free_fn[oct->octeon_id][reqtype] = fn;\r\nreturn 0;\r\n}\r\nstatic inline void\r\n__add_to_request_list(struct octeon_instr_queue *iq,\r\nint idx, void *buf, int reqtype)\r\n{\r\niq->request_list[idx].buf = buf;\r\niq->request_list[idx].reqtype = reqtype;\r\n}\r\nint\r\nlio_process_iq_request_list(struct octeon_device *oct,\r\nstruct octeon_instr_queue *iq)\r\n{\r\nint reqtype;\r\nvoid *buf;\r\nu32 old = iq->flush_index;\r\nu32 inst_count = 0;\r\nunsigned pkts_compl = 0, bytes_compl = 0;\r\nstruct octeon_soft_command *sc;\r\nstruct octeon_instr_irh *irh;\r\nwhile (old != iq->octeon_read_index) {\r\nreqtype = iq->request_list[old].reqtype;\r\nbuf = iq->request_list[old].buf;\r\nif (reqtype == REQTYPE_NONE)\r\ngoto skip_this;\r\nocteon_update_tx_completion_counters(buf, reqtype, &pkts_compl,\r\n&bytes_compl);\r\nswitch (reqtype) {\r\ncase REQTYPE_NORESP_NET:\r\ncase REQTYPE_NORESP_NET_SG:\r\ncase REQTYPE_RESP_NET_SG:\r\nreqtype_free_fn[oct->octeon_id][reqtype](buf);\r\nbreak;\r\ncase REQTYPE_RESP_NET:\r\ncase REQTYPE_SOFT_COMMAND:\r\nsc = buf;\r\nirh = (struct octeon_instr_irh *)&sc->cmd.irh;\r\nif (irh->rflag) {\r\nspin_lock_bh(&oct->response_list\r\n[OCTEON_ORDERED_SC_LIST].lock);\r\natomic_inc(&oct->response_list\r\n[OCTEON_ORDERED_SC_LIST].\r\npending_req_count);\r\nlist_add_tail(&sc->node, &oct->response_list\r\n[OCTEON_ORDERED_SC_LIST].head);\r\nspin_unlock_bh(&oct->response_list\r\n[OCTEON_ORDERED_SC_LIST].lock);\r\n} else {\r\nif (sc->callback) {\r\nsc->callback(oct, OCTEON_REQUEST_DONE,\r\nsc->callback_arg);\r\n}\r\n}\r\nbreak;\r\ndefault:\r\ndev_err(&oct->pci_dev->dev,\r\n"%s Unknown reqtype: %d buf: %p at idx %d\n",\r\n__func__, reqtype, buf, old);\r\n}\r\niq->request_list[old].buf = NULL;\r\niq->request_list[old].reqtype = 0;\r\nskip_this:\r\ninst_count++;\r\nINCR_INDEX_BY1(old, iq->max_count);\r\n}\r\nif (bytes_compl)\r\nocteon_report_tx_completion_to_bql(iq->app_ctx, pkts_compl,\r\nbytes_compl);\r\niq->flush_index = old;\r\nreturn inst_count;\r\n}\r\nstatic inline void\r\nupdate_iq_indices(struct octeon_device *oct, struct octeon_instr_queue *iq)\r\n{\r\nu32 inst_processed = 0;\r\niq->octeon_read_index = oct->fn_list.update_iq_read_idx(oct, iq);\r\nif (iq->flush_index != iq->octeon_read_index)\r\ninst_processed = lio_process_iq_request_list(oct, iq);\r\nif (inst_processed) {\r\natomic_sub(inst_processed, &iq->instr_pending);\r\niq->stats.instr_processed += inst_processed;\r\n}\r\n}\r\nstatic void\r\nocteon_flush_iq(struct octeon_device *oct, struct octeon_instr_queue *iq,\r\nu32 pending_thresh)\r\n{\r\nif (atomic_read(&iq->instr_pending) >= (s32)pending_thresh) {\r\nspin_lock_bh(&iq->lock);\r\nupdate_iq_indices(oct, iq);\r\nspin_unlock_bh(&iq->lock);\r\n}\r\n}\r\nstatic void __check_db_timeout(struct octeon_device *oct, unsigned long iq_no)\r\n{\r\nstruct octeon_instr_queue *iq;\r\nu64 next_time;\r\nif (!oct)\r\nreturn;\r\niq = oct->instr_queue[iq_no];\r\nif (!iq)\r\nreturn;\r\nnext_time = iq->last_db_time + iq->db_timeout;\r\nif (!time_after(jiffies, (unsigned long)next_time))\r\nreturn;\r\niq->last_db_time = jiffies;\r\nspin_lock_bh(&iq->lock);\r\nif (iq->fill_cnt != 0)\r\nring_doorbell(oct, iq);\r\nspin_unlock_bh(&iq->lock);\r\nif (iq->do_auto_flush)\r\nocteon_flush_iq(oct, iq, 1);\r\n}\r\nstatic void check_db_timeout(struct work_struct *work)\r\n{\r\nstruct cavium_wk *wk = (struct cavium_wk *)work;\r\nstruct octeon_device *oct = (struct octeon_device *)wk->ctxptr;\r\nunsigned long iq_no = wk->ctxul;\r\nstruct cavium_wq *db_wq = &oct->check_db_wq[iq_no];\r\n__check_db_timeout(oct, iq_no);\r\nqueue_delayed_work(db_wq->wq, &db_wq->wk.work, msecs_to_jiffies(1));\r\n}\r\nint\r\nocteon_send_command(struct octeon_device *oct, u32 iq_no,\r\nu32 force_db, void *cmd, void *buf,\r\nu32 datasize, u32 reqtype)\r\n{\r\nstruct iq_post_status st;\r\nstruct octeon_instr_queue *iq = oct->instr_queue[iq_no];\r\nspin_lock_bh(&iq->lock);\r\nst = __post_command2(oct, iq, force_db, cmd);\r\nif (st.status != IQ_SEND_FAILED) {\r\nocteon_report_sent_bytes_to_bql(buf, reqtype);\r\n__add_to_request_list(iq, st.index, buf, reqtype);\r\nINCR_INSTRQUEUE_PKT_COUNT(oct, iq_no, bytes_sent, datasize);\r\nINCR_INSTRQUEUE_PKT_COUNT(oct, iq_no, instr_posted, 1);\r\nif (iq->fill_cnt >= iq->fill_threshold || force_db)\r\nring_doorbell(oct, iq);\r\n} else {\r\nINCR_INSTRQUEUE_PKT_COUNT(oct, iq_no, instr_dropped, 1);\r\n}\r\nspin_unlock_bh(&iq->lock);\r\nif (iq->do_auto_flush)\r\nocteon_flush_iq(oct, iq, 2);\r\nreturn st.status;\r\n}\r\nvoid\r\nocteon_prepare_soft_command(struct octeon_device *oct,\r\nstruct octeon_soft_command *sc,\r\nu8 opcode,\r\nu8 subcode,\r\nu32 irh_ossp,\r\nu64 ossp0,\r\nu64 ossp1)\r\n{\r\nstruct octeon_config *oct_cfg;\r\nstruct octeon_instr_ih *ih;\r\nstruct octeon_instr_irh *irh;\r\nstruct octeon_instr_rdp *rdp;\r\nBUG_ON(opcode > 15);\r\nBUG_ON(subcode > 127);\r\noct_cfg = octeon_get_conf(oct);\r\nih = (struct octeon_instr_ih *)&sc->cmd.ih;\r\nih->tagtype = ATOMIC_TAG;\r\nih->tag = LIO_CONTROL;\r\nih->raw = 1;\r\nih->grp = CFG_GET_CTRL_Q_GRP(oct_cfg);\r\nif (sc->datasize) {\r\nih->dlengsz = sc->datasize;\r\nih->rs = 1;\r\n}\r\nirh = (struct octeon_instr_irh *)&sc->cmd.irh;\r\nirh->opcode = opcode;\r\nirh->subcode = subcode;\r\nirh->ossp = irh_ossp;\r\nsc->cmd.ossp[0] = ossp0;\r\nsc->cmd.ossp[1] = ossp1;\r\nif (sc->rdatasize) {\r\nrdp = (struct octeon_instr_rdp *)&sc->cmd.rdp;\r\nrdp->pcie_port = oct->pcie_port;\r\nrdp->rlen = sc->rdatasize;\r\nirh->rflag = 1;\r\nirh->len = 4;\r\nih->fsz = 40;\r\n} else {\r\nirh->rflag = 0;\r\nirh->len = 2;\r\nih->fsz = 24;\r\n}\r\nwhile (!(oct->io_qmask.iq & (1 << sc->iq_no)))\r\nsc->iq_no++;\r\n}\r\nint octeon_send_soft_command(struct octeon_device *oct,\r\nstruct octeon_soft_command *sc)\r\n{\r\nstruct octeon_instr_ih *ih;\r\nstruct octeon_instr_irh *irh;\r\nstruct octeon_instr_rdp *rdp;\r\nih = (struct octeon_instr_ih *)&sc->cmd.ih;\r\nif (ih->dlengsz) {\r\nBUG_ON(!sc->dmadptr);\r\nsc->cmd.dptr = sc->dmadptr;\r\n}\r\nirh = (struct octeon_instr_irh *)&sc->cmd.irh;\r\nif (irh->rflag) {\r\nBUG_ON(!sc->dmarptr);\r\nBUG_ON(!sc->status_word);\r\n*sc->status_word = COMPLETION_WORD_INIT;\r\nrdp = (struct octeon_instr_rdp *)&sc->cmd.rdp;\r\nsc->cmd.rptr = sc->dmarptr;\r\n}\r\nif (sc->wait_time)\r\nsc->timeout = jiffies + sc->wait_time;\r\nreturn octeon_send_command(oct, sc->iq_no, 1, &sc->cmd, sc,\r\n(u32)ih->dlengsz, REQTYPE_SOFT_COMMAND);\r\n}\r\nint octeon_setup_sc_buffer_pool(struct octeon_device *oct)\r\n{\r\nint i;\r\nu64 dma_addr;\r\nstruct octeon_soft_command *sc;\r\nINIT_LIST_HEAD(&oct->sc_buf_pool.head);\r\nspin_lock_init(&oct->sc_buf_pool.lock);\r\natomic_set(&oct->sc_buf_pool.alloc_buf_count, 0);\r\nfor (i = 0; i < MAX_SOFT_COMMAND_BUFFERS; i++) {\r\nsc = (struct octeon_soft_command *)\r\nlio_dma_alloc(oct,\r\nSOFT_COMMAND_BUFFER_SIZE,\r\n(dma_addr_t *)&dma_addr);\r\nif (!sc)\r\nreturn 1;\r\nsc->dma_addr = dma_addr;\r\nsc->size = SOFT_COMMAND_BUFFER_SIZE;\r\nlist_add_tail(&sc->node, &oct->sc_buf_pool.head);\r\n}\r\nreturn 0;\r\n}\r\nint octeon_free_sc_buffer_pool(struct octeon_device *oct)\r\n{\r\nstruct list_head *tmp, *tmp2;\r\nstruct octeon_soft_command *sc;\r\nspin_lock(&oct->sc_buf_pool.lock);\r\nlist_for_each_safe(tmp, tmp2, &oct->sc_buf_pool.head) {\r\nlist_del(tmp);\r\nsc = (struct octeon_soft_command *)tmp;\r\nlio_dma_free(oct, sc->size, sc, sc->dma_addr);\r\n}\r\nINIT_LIST_HEAD(&oct->sc_buf_pool.head);\r\nspin_unlock(&oct->sc_buf_pool.lock);\r\nreturn 0;\r\n}\r\nstruct octeon_soft_command *octeon_alloc_soft_command(struct octeon_device *oct,\r\nu32 datasize,\r\nu32 rdatasize,\r\nu32 ctxsize)\r\n{\r\nu64 dma_addr;\r\nu32 size;\r\nu32 offset = sizeof(struct octeon_soft_command);\r\nstruct octeon_soft_command *sc = NULL;\r\nstruct list_head *tmp;\r\nBUG_ON((offset + datasize + rdatasize + ctxsize) >\r\nSOFT_COMMAND_BUFFER_SIZE);\r\nspin_lock(&oct->sc_buf_pool.lock);\r\nif (list_empty(&oct->sc_buf_pool.head)) {\r\nspin_unlock(&oct->sc_buf_pool.lock);\r\nreturn NULL;\r\n}\r\nlist_for_each(tmp, &oct->sc_buf_pool.head)\r\nbreak;\r\nlist_del(tmp);\r\natomic_inc(&oct->sc_buf_pool.alloc_buf_count);\r\nspin_unlock(&oct->sc_buf_pool.lock);\r\nsc = (struct octeon_soft_command *)tmp;\r\ndma_addr = sc->dma_addr;\r\nsize = sc->size;\r\nmemset(sc, 0, sc->size);\r\nsc->dma_addr = dma_addr;\r\nsc->size = size;\r\nif (ctxsize) {\r\nsc->ctxptr = (u8 *)sc + offset;\r\nsc->ctxsize = ctxsize;\r\n}\r\noffset = (offset + ctxsize + 127) & 0xffffff80;\r\nif (datasize) {\r\nsc->virtdptr = (u8 *)sc + offset;\r\nsc->dmadptr = dma_addr + offset;\r\nsc->datasize = datasize;\r\n}\r\noffset = (offset + datasize + 127) & 0xffffff80;\r\nif (rdatasize) {\r\nBUG_ON(rdatasize < 16);\r\nsc->virtrptr = (u8 *)sc + offset;\r\nsc->dmarptr = dma_addr + offset;\r\nsc->rdatasize = rdatasize;\r\nsc->status_word = (u64 *)((u8 *)(sc->virtrptr) + rdatasize - 8);\r\n}\r\nreturn sc;\r\n}\r\nvoid octeon_free_soft_command(struct octeon_device *oct,\r\nstruct octeon_soft_command *sc)\r\n{\r\nspin_lock(&oct->sc_buf_pool.lock);\r\nlist_add_tail(&sc->node, &oct->sc_buf_pool.head);\r\natomic_dec(&oct->sc_buf_pool.alloc_buf_count);\r\nspin_unlock(&oct->sc_buf_pool.lock);\r\n}
