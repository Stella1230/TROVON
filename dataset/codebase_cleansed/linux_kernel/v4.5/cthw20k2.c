static int src_get_rsc_ctrl_blk(void **rblk)\r\n{\r\nstruct src_rsc_ctrl_blk *blk;\r\n*rblk = NULL;\r\nblk = kzalloc(sizeof(*blk), GFP_KERNEL);\r\nif (!blk)\r\nreturn -ENOMEM;\r\n*rblk = blk;\r\nreturn 0;\r\n}\r\nstatic int src_put_rsc_ctrl_blk(void *blk)\r\n{\r\nkfree(blk);\r\nreturn 0;\r\n}\r\nstatic int src_set_state(void *blk, unsigned int state)\r\n{\r\nstruct src_rsc_ctrl_blk *ctl = blk;\r\nset_field(&ctl->ctl, SRCCTL_STATE, state);\r\nctl->dirty.bf.ctl = 1;\r\nreturn 0;\r\n}\r\nstatic int src_set_bm(void *blk, unsigned int bm)\r\n{\r\nstruct src_rsc_ctrl_blk *ctl = blk;\r\nset_field(&ctl->ctl, SRCCTL_BM, bm);\r\nctl->dirty.bf.ctl = 1;\r\nreturn 0;\r\n}\r\nstatic int src_set_rsr(void *blk, unsigned int rsr)\r\n{\r\nstruct src_rsc_ctrl_blk *ctl = blk;\r\nset_field(&ctl->ctl, SRCCTL_RSR, rsr);\r\nctl->dirty.bf.ctl = 1;\r\nreturn 0;\r\n}\r\nstatic int src_set_sf(void *blk, unsigned int sf)\r\n{\r\nstruct src_rsc_ctrl_blk *ctl = blk;\r\nset_field(&ctl->ctl, SRCCTL_SF, sf);\r\nctl->dirty.bf.ctl = 1;\r\nreturn 0;\r\n}\r\nstatic int src_set_wr(void *blk, unsigned int wr)\r\n{\r\nstruct src_rsc_ctrl_blk *ctl = blk;\r\nset_field(&ctl->ctl, SRCCTL_WR, wr);\r\nctl->dirty.bf.ctl = 1;\r\nreturn 0;\r\n}\r\nstatic int src_set_pm(void *blk, unsigned int pm)\r\n{\r\nstruct src_rsc_ctrl_blk *ctl = blk;\r\nset_field(&ctl->ctl, SRCCTL_PM, pm);\r\nctl->dirty.bf.ctl = 1;\r\nreturn 0;\r\n}\r\nstatic int src_set_rom(void *blk, unsigned int rom)\r\n{\r\nstruct src_rsc_ctrl_blk *ctl = blk;\r\nset_field(&ctl->ctl, SRCCTL_ROM, rom);\r\nctl->dirty.bf.ctl = 1;\r\nreturn 0;\r\n}\r\nstatic int src_set_vo(void *blk, unsigned int vo)\r\n{\r\nstruct src_rsc_ctrl_blk *ctl = blk;\r\nset_field(&ctl->ctl, SRCCTL_VO, vo);\r\nctl->dirty.bf.ctl = 1;\r\nreturn 0;\r\n}\r\nstatic int src_set_st(void *blk, unsigned int st)\r\n{\r\nstruct src_rsc_ctrl_blk *ctl = blk;\r\nset_field(&ctl->ctl, SRCCTL_ST, st);\r\nctl->dirty.bf.ctl = 1;\r\nreturn 0;\r\n}\r\nstatic int src_set_ie(void *blk, unsigned int ie)\r\n{\r\nstruct src_rsc_ctrl_blk *ctl = blk;\r\nset_field(&ctl->ctl, SRCCTL_IE, ie);\r\nctl->dirty.bf.ctl = 1;\r\nreturn 0;\r\n}\r\nstatic int src_set_ilsz(void *blk, unsigned int ilsz)\r\n{\r\nstruct src_rsc_ctrl_blk *ctl = blk;\r\nset_field(&ctl->ctl, SRCCTL_ILSZ, ilsz);\r\nctl->dirty.bf.ctl = 1;\r\nreturn 0;\r\n}\r\nstatic int src_set_bp(void *blk, unsigned int bp)\r\n{\r\nstruct src_rsc_ctrl_blk *ctl = blk;\r\nset_field(&ctl->ctl, SRCCTL_BP, bp);\r\nctl->dirty.bf.ctl = 1;\r\nreturn 0;\r\n}\r\nstatic int src_set_cisz(void *blk, unsigned int cisz)\r\n{\r\nstruct src_rsc_ctrl_blk *ctl = blk;\r\nset_field(&ctl->ccr, SRCCCR_CISZ, cisz);\r\nctl->dirty.bf.ccr = 1;\r\nreturn 0;\r\n}\r\nstatic int src_set_ca(void *blk, unsigned int ca)\r\n{\r\nstruct src_rsc_ctrl_blk *ctl = blk;\r\nset_field(&ctl->ca, SRCCA_CA, ca);\r\nctl->dirty.bf.ca = 1;\r\nreturn 0;\r\n}\r\nstatic int src_set_sa(void *blk, unsigned int sa)\r\n{\r\nstruct src_rsc_ctrl_blk *ctl = blk;\r\nset_field(&ctl->sa, SRCSA_SA, sa);\r\nctl->dirty.bf.sa = 1;\r\nreturn 0;\r\n}\r\nstatic int src_set_la(void *blk, unsigned int la)\r\n{\r\nstruct src_rsc_ctrl_blk *ctl = blk;\r\nset_field(&ctl->la, SRCLA_LA, la);\r\nctl->dirty.bf.la = 1;\r\nreturn 0;\r\n}\r\nstatic int src_set_pitch(void *blk, unsigned int pitch)\r\n{\r\nstruct src_rsc_ctrl_blk *ctl = blk;\r\nset_field(&ctl->mpr, MPRLH_PITCH, pitch);\r\nctl->dirty.bf.mpr = 1;\r\nreturn 0;\r\n}\r\nstatic int src_set_clear_zbufs(void *blk, unsigned int clear)\r\n{\r\n((struct src_rsc_ctrl_blk *)blk)->dirty.bf.czbfs = (clear ? 1 : 0);\r\nreturn 0;\r\n}\r\nstatic int src_set_dirty(void *blk, unsigned int flags)\r\n{\r\n((struct src_rsc_ctrl_blk *)blk)->dirty.data = (flags & 0xffff);\r\nreturn 0;\r\n}\r\nstatic int src_set_dirty_all(void *blk)\r\n{\r\n((struct src_rsc_ctrl_blk *)blk)->dirty.data = ~(0x0);\r\nreturn 0;\r\n}\r\nstatic unsigned int src_param_pitch_mixer(unsigned int src_idx)\r\n{\r\nreturn ((src_idx << 4) + AR_PTS_PITCH + AR_SLOT_SIZE\r\n- AR_PARAM_SRC_OFFSET) % AR_SLOT_SIZE;\r\n}\r\nstatic int src_commit_write(struct hw *hw, unsigned int idx, void *blk)\r\n{\r\nstruct src_rsc_ctrl_blk *ctl = blk;\r\nint i;\r\nif (ctl->dirty.bf.czbfs) {\r\nfor (i = 0; i < 8; i++)\r\nhw_write_20kx(hw, SRC_UPZ+idx*0x100+i*0x4, 0);\r\nfor (i = 0; i < 4; i++)\r\nhw_write_20kx(hw, SRC_DN0Z+idx*0x100+i*0x4, 0);\r\nfor (i = 0; i < 8; i++)\r\nhw_write_20kx(hw, SRC_DN1Z+idx*0x100+i*0x4, 0);\r\nctl->dirty.bf.czbfs = 0;\r\n}\r\nif (ctl->dirty.bf.mpr) {\r\nunsigned int pm_idx = src_param_pitch_mixer(idx);\r\nhw_write_20kx(hw, MIXER_PRING_LO_HI+4*pm_idx, ctl->mpr);\r\nhw_write_20kx(hw, MIXER_PMOPLO+8*pm_idx, 0x3);\r\nhw_write_20kx(hw, MIXER_PMOPHI+8*pm_idx, 0x0);\r\nctl->dirty.bf.mpr = 0;\r\n}\r\nif (ctl->dirty.bf.sa) {\r\nhw_write_20kx(hw, SRC_SA+idx*0x100, ctl->sa);\r\nctl->dirty.bf.sa = 0;\r\n}\r\nif (ctl->dirty.bf.la) {\r\nhw_write_20kx(hw, SRC_LA+idx*0x100, ctl->la);\r\nctl->dirty.bf.la = 0;\r\n}\r\nif (ctl->dirty.bf.ca) {\r\nhw_write_20kx(hw, SRC_CA+idx*0x100, ctl->ca);\r\nctl->dirty.bf.ca = 0;\r\n}\r\nhw_write_20kx(hw, SRC_CF+idx*0x100, 0x0);\r\nif (ctl->dirty.bf.ccr) {\r\nhw_write_20kx(hw, SRC_CCR+idx*0x100, ctl->ccr);\r\nctl->dirty.bf.ccr = 0;\r\n}\r\nif (ctl->dirty.bf.ctl) {\r\nhw_write_20kx(hw, SRC_CTL+idx*0x100, ctl->ctl);\r\nctl->dirty.bf.ctl = 0;\r\n}\r\nreturn 0;\r\n}\r\nstatic int src_get_ca(struct hw *hw, unsigned int idx, void *blk)\r\n{\r\nstruct src_rsc_ctrl_blk *ctl = blk;\r\nctl->ca = hw_read_20kx(hw, SRC_CA+idx*0x100);\r\nctl->dirty.bf.ca = 0;\r\nreturn get_field(ctl->ca, SRCCA_CA);\r\n}\r\nstatic unsigned int src_get_dirty(void *blk)\r\n{\r\nreturn ((struct src_rsc_ctrl_blk *)blk)->dirty.data;\r\n}\r\nstatic unsigned int src_dirty_conj_mask(void)\r\n{\r\nreturn 0x20;\r\n}\r\nstatic int src_mgr_enbs_src(void *blk, unsigned int idx)\r\n{\r\n((struct src_mgr_ctrl_blk *)blk)->enbsa |= (0x1 << ((idx%128)/4));\r\n((struct src_mgr_ctrl_blk *)blk)->dirty.bf.enbsa = 1;\r\n((struct src_mgr_ctrl_blk *)blk)->enb[idx/32] |= (0x1 << (idx%32));\r\nreturn 0;\r\n}\r\nstatic int src_mgr_enb_src(void *blk, unsigned int idx)\r\n{\r\n((struct src_mgr_ctrl_blk *)blk)->enb[idx/32] |= (0x1 << (idx%32));\r\n((struct src_mgr_ctrl_blk *)blk)->dirty.data |= (0x1 << (idx/32));\r\nreturn 0;\r\n}\r\nstatic int src_mgr_dsb_src(void *blk, unsigned int idx)\r\n{\r\n((struct src_mgr_ctrl_blk *)blk)->enb[idx/32] &= ~(0x1 << (idx%32));\r\n((struct src_mgr_ctrl_blk *)blk)->dirty.data |= (0x1 << (idx/32));\r\nreturn 0;\r\n}\r\nstatic int src_mgr_commit_write(struct hw *hw, void *blk)\r\n{\r\nstruct src_mgr_ctrl_blk *ctl = blk;\r\nint i;\r\nunsigned int ret;\r\nif (ctl->dirty.bf.enbsa) {\r\ndo {\r\nret = hw_read_20kx(hw, SRC_ENBSTAT);\r\n} while (ret & 0x1);\r\nhw_write_20kx(hw, SRC_ENBSA, ctl->enbsa);\r\nctl->dirty.bf.enbsa = 0;\r\n}\r\nfor (i = 0; i < 8; i++) {\r\nif ((ctl->dirty.data & (0x1 << i))) {\r\nhw_write_20kx(hw, SRC_ENB+(i*0x100), ctl->enb[i]);\r\nctl->dirty.data &= ~(0x1 << i);\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int src_mgr_get_ctrl_blk(void **rblk)\r\n{\r\nstruct src_mgr_ctrl_blk *blk;\r\n*rblk = NULL;\r\nblk = kzalloc(sizeof(*blk), GFP_KERNEL);\r\nif (!blk)\r\nreturn -ENOMEM;\r\n*rblk = blk;\r\nreturn 0;\r\n}\r\nstatic int src_mgr_put_ctrl_blk(void *blk)\r\n{\r\nkfree(blk);\r\nreturn 0;\r\n}\r\nstatic int srcimp_mgr_get_ctrl_blk(void **rblk)\r\n{\r\nstruct srcimp_mgr_ctrl_blk *blk;\r\n*rblk = NULL;\r\nblk = kzalloc(sizeof(*blk), GFP_KERNEL);\r\nif (!blk)\r\nreturn -ENOMEM;\r\n*rblk = blk;\r\nreturn 0;\r\n}\r\nstatic int srcimp_mgr_put_ctrl_blk(void *blk)\r\n{\r\nkfree(blk);\r\nreturn 0;\r\n}\r\nstatic int srcimp_mgr_set_imaparc(void *blk, unsigned int slot)\r\n{\r\nstruct srcimp_mgr_ctrl_blk *ctl = blk;\r\nset_field(&ctl->srcimap.srcaim, SRCAIM_ARC, slot);\r\nctl->dirty.bf.srcimap = 1;\r\nreturn 0;\r\n}\r\nstatic int srcimp_mgr_set_imapuser(void *blk, unsigned int user)\r\n{\r\nstruct srcimp_mgr_ctrl_blk *ctl = blk;\r\nset_field(&ctl->srcimap.srcaim, SRCAIM_SRC, user);\r\nctl->dirty.bf.srcimap = 1;\r\nreturn 0;\r\n}\r\nstatic int srcimp_mgr_set_imapnxt(void *blk, unsigned int next)\r\n{\r\nstruct srcimp_mgr_ctrl_blk *ctl = blk;\r\nset_field(&ctl->srcimap.srcaim, SRCAIM_NXT, next);\r\nctl->dirty.bf.srcimap = 1;\r\nreturn 0;\r\n}\r\nstatic int srcimp_mgr_set_imapaddr(void *blk, unsigned int addr)\r\n{\r\n((struct srcimp_mgr_ctrl_blk *)blk)->srcimap.idx = addr;\r\n((struct srcimp_mgr_ctrl_blk *)blk)->dirty.bf.srcimap = 1;\r\nreturn 0;\r\n}\r\nstatic int srcimp_mgr_commit_write(struct hw *hw, void *blk)\r\n{\r\nstruct srcimp_mgr_ctrl_blk *ctl = blk;\r\nif (ctl->dirty.bf.srcimap) {\r\nhw_write_20kx(hw, SRC_IMAP+ctl->srcimap.idx*0x100,\r\nctl->srcimap.srcaim);\r\nctl->dirty.bf.srcimap = 0;\r\n}\r\nreturn 0;\r\n}\r\nstatic int amixer_set_mode(void *blk, unsigned int mode)\r\n{\r\nstruct amixer_rsc_ctrl_blk *ctl = blk;\r\nset_field(&ctl->amoplo, AMOPLO_M, mode);\r\nctl->dirty.bf.amoplo = 1;\r\nreturn 0;\r\n}\r\nstatic int amixer_set_iv(void *blk, unsigned int iv)\r\n{\r\nstruct amixer_rsc_ctrl_blk *ctl = blk;\r\nset_field(&ctl->amoplo, AMOPLO_IV, iv);\r\nctl->dirty.bf.amoplo = 1;\r\nreturn 0;\r\n}\r\nstatic int amixer_set_x(void *blk, unsigned int x)\r\n{\r\nstruct amixer_rsc_ctrl_blk *ctl = blk;\r\nset_field(&ctl->amoplo, AMOPLO_X, x);\r\nctl->dirty.bf.amoplo = 1;\r\nreturn 0;\r\n}\r\nstatic int amixer_set_y(void *blk, unsigned int y)\r\n{\r\nstruct amixer_rsc_ctrl_blk *ctl = blk;\r\nset_field(&ctl->amoplo, AMOPLO_Y, y);\r\nctl->dirty.bf.amoplo = 1;\r\nreturn 0;\r\n}\r\nstatic int amixer_set_sadr(void *blk, unsigned int sadr)\r\n{\r\nstruct amixer_rsc_ctrl_blk *ctl = blk;\r\nset_field(&ctl->amophi, AMOPHI_SADR, sadr);\r\nctl->dirty.bf.amophi = 1;\r\nreturn 0;\r\n}\r\nstatic int amixer_set_se(void *blk, unsigned int se)\r\n{\r\nstruct amixer_rsc_ctrl_blk *ctl = blk;\r\nset_field(&ctl->amophi, AMOPHI_SE, se);\r\nctl->dirty.bf.amophi = 1;\r\nreturn 0;\r\n}\r\nstatic int amixer_set_dirty(void *blk, unsigned int flags)\r\n{\r\n((struct amixer_rsc_ctrl_blk *)blk)->dirty.data = (flags & 0xffff);\r\nreturn 0;\r\n}\r\nstatic int amixer_set_dirty_all(void *blk)\r\n{\r\n((struct amixer_rsc_ctrl_blk *)blk)->dirty.data = ~(0x0);\r\nreturn 0;\r\n}\r\nstatic int amixer_commit_write(struct hw *hw, unsigned int idx, void *blk)\r\n{\r\nstruct amixer_rsc_ctrl_blk *ctl = blk;\r\nif (ctl->dirty.bf.amoplo || ctl->dirty.bf.amophi) {\r\nhw_write_20kx(hw, MIXER_AMOPLO+idx*8, ctl->amoplo);\r\nctl->dirty.bf.amoplo = 0;\r\nhw_write_20kx(hw, MIXER_AMOPHI+idx*8, ctl->amophi);\r\nctl->dirty.bf.amophi = 0;\r\n}\r\nreturn 0;\r\n}\r\nstatic int amixer_get_y(void *blk)\r\n{\r\nstruct amixer_rsc_ctrl_blk *ctl = blk;\r\nreturn get_field(ctl->amoplo, AMOPLO_Y);\r\n}\r\nstatic unsigned int amixer_get_dirty(void *blk)\r\n{\r\nreturn ((struct amixer_rsc_ctrl_blk *)blk)->dirty.data;\r\n}\r\nstatic int amixer_rsc_get_ctrl_blk(void **rblk)\r\n{\r\nstruct amixer_rsc_ctrl_blk *blk;\r\n*rblk = NULL;\r\nblk = kzalloc(sizeof(*blk), GFP_KERNEL);\r\nif (!blk)\r\nreturn -ENOMEM;\r\n*rblk = blk;\r\nreturn 0;\r\n}\r\nstatic int amixer_rsc_put_ctrl_blk(void *blk)\r\n{\r\nkfree(blk);\r\nreturn 0;\r\n}\r\nstatic int amixer_mgr_get_ctrl_blk(void **rblk)\r\n{\r\n*rblk = NULL;\r\nreturn 0;\r\n}\r\nstatic int amixer_mgr_put_ctrl_blk(void *blk)\r\n{\r\nreturn 0;\r\n}\r\nstatic int dai_srt_set_srco(void *blk, unsigned int src)\r\n{\r\nstruct dai_ctrl_blk *ctl = blk;\r\nset_field(&ctl->srt, SRTCTL_SRCO, src);\r\nctl->dirty.bf.srt = 1;\r\nreturn 0;\r\n}\r\nstatic int dai_srt_set_srcm(void *blk, unsigned int src)\r\n{\r\nstruct dai_ctrl_blk *ctl = blk;\r\nset_field(&ctl->srt, SRTCTL_SRCM, src);\r\nctl->dirty.bf.srt = 1;\r\nreturn 0;\r\n}\r\nstatic int dai_srt_set_rsr(void *blk, unsigned int rsr)\r\n{\r\nstruct dai_ctrl_blk *ctl = blk;\r\nset_field(&ctl->srt, SRTCTL_RSR, rsr);\r\nctl->dirty.bf.srt = 1;\r\nreturn 0;\r\n}\r\nstatic int dai_srt_set_drat(void *blk, unsigned int drat)\r\n{\r\nstruct dai_ctrl_blk *ctl = blk;\r\nset_field(&ctl->srt, SRTCTL_DRAT, drat);\r\nctl->dirty.bf.srt = 1;\r\nreturn 0;\r\n}\r\nstatic int dai_srt_set_ec(void *blk, unsigned int ec)\r\n{\r\nstruct dai_ctrl_blk *ctl = blk;\r\nset_field(&ctl->srt, SRTCTL_EC, ec ? 1 : 0);\r\nctl->dirty.bf.srt = 1;\r\nreturn 0;\r\n}\r\nstatic int dai_srt_set_et(void *blk, unsigned int et)\r\n{\r\nstruct dai_ctrl_blk *ctl = blk;\r\nset_field(&ctl->srt, SRTCTL_ET, et ? 1 : 0);\r\nctl->dirty.bf.srt = 1;\r\nreturn 0;\r\n}\r\nstatic int dai_commit_write(struct hw *hw, unsigned int idx, void *blk)\r\n{\r\nstruct dai_ctrl_blk *ctl = blk;\r\nif (ctl->dirty.bf.srt) {\r\nhw_write_20kx(hw, AUDIO_IO_RX_SRT_CTL+0x40*idx, ctl->srt);\r\nctl->dirty.bf.srt = 0;\r\n}\r\nreturn 0;\r\n}\r\nstatic int dai_get_ctrl_blk(void **rblk)\r\n{\r\nstruct dai_ctrl_blk *blk;\r\n*rblk = NULL;\r\nblk = kzalloc(sizeof(*blk), GFP_KERNEL);\r\nif (!blk)\r\nreturn -ENOMEM;\r\n*rblk = blk;\r\nreturn 0;\r\n}\r\nstatic int dai_put_ctrl_blk(void *blk)\r\n{\r\nkfree(blk);\r\nreturn 0;\r\n}\r\nstatic int dao_set_spos(void *blk, unsigned int spos)\r\n{\r\n((struct dao_ctrl_blk *)blk)->atxcsl = spos;\r\n((struct dao_ctrl_blk *)blk)->dirty.bf.atxcsl = 1;\r\nreturn 0;\r\n}\r\nstatic int dao_commit_write(struct hw *hw, unsigned int idx, void *blk)\r\n{\r\nstruct dao_ctrl_blk *ctl = blk;\r\nif (ctl->dirty.bf.atxcsl) {\r\nif (idx < 4) {\r\nhw_write_20kx(hw, AUDIO_IO_TX_CSTAT_L+0x40*idx,\r\nctl->atxcsl);\r\n}\r\nctl->dirty.bf.atxcsl = 0;\r\n}\r\nreturn 0;\r\n}\r\nstatic int dao_get_spos(void *blk, unsigned int *spos)\r\n{\r\n*spos = ((struct dao_ctrl_blk *)blk)->atxcsl;\r\nreturn 0;\r\n}\r\nstatic int dao_get_ctrl_blk(void **rblk)\r\n{\r\nstruct dao_ctrl_blk *blk;\r\n*rblk = NULL;\r\nblk = kzalloc(sizeof(*blk), GFP_KERNEL);\r\nif (!blk)\r\nreturn -ENOMEM;\r\n*rblk = blk;\r\nreturn 0;\r\n}\r\nstatic int dao_put_ctrl_blk(void *blk)\r\n{\r\nkfree(blk);\r\nreturn 0;\r\n}\r\nstatic int daio_mgr_enb_dai(void *blk, unsigned int idx)\r\n{\r\nstruct daio_mgr_ctrl_blk *ctl = blk;\r\nset_field(&ctl->rxctl[idx], ARXCTL_EN, 1);\r\nctl->dirty.bf.arxctl |= (0x1 << idx);\r\nreturn 0;\r\n}\r\nstatic int daio_mgr_dsb_dai(void *blk, unsigned int idx)\r\n{\r\nstruct daio_mgr_ctrl_blk *ctl = blk;\r\nset_field(&ctl->rxctl[idx], ARXCTL_EN, 0);\r\nctl->dirty.bf.arxctl |= (0x1 << idx);\r\nreturn 0;\r\n}\r\nstatic int daio_mgr_enb_dao(void *blk, unsigned int idx)\r\n{\r\nstruct daio_mgr_ctrl_blk *ctl = blk;\r\nset_field(&ctl->txctl[idx], ATXCTL_EN, 1);\r\nctl->dirty.bf.atxctl |= (0x1 << idx);\r\nreturn 0;\r\n}\r\nstatic int daio_mgr_dsb_dao(void *blk, unsigned int idx)\r\n{\r\nstruct daio_mgr_ctrl_blk *ctl = blk;\r\nset_field(&ctl->txctl[idx], ATXCTL_EN, 0);\r\nctl->dirty.bf.atxctl |= (0x1 << idx);\r\nreturn 0;\r\n}\r\nstatic int daio_mgr_dao_init(void *blk, unsigned int idx, unsigned int conf)\r\n{\r\nstruct daio_mgr_ctrl_blk *ctl = blk;\r\nif (idx < 4) {\r\nswitch ((conf & 0x7)) {\r\ncase 1:\r\nset_field(&ctl->txctl[idx], ATXCTL_NUC, 0);\r\nbreak;\r\ncase 2:\r\nset_field(&ctl->txctl[idx], ATXCTL_NUC, 1);\r\nbreak;\r\ncase 4:\r\nset_field(&ctl->txctl[idx], ATXCTL_NUC, 2);\r\nbreak;\r\ncase 8:\r\nset_field(&ctl->txctl[idx], ATXCTL_NUC, 3);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nset_field(&ctl->txctl[idx], ATXCTL_CD, (!(conf & 0x7)));\r\nset_field(&ctl->txctl[idx], ATXCTL_LIV, (conf >> 4) & 0x1);\r\nset_field(&ctl->txctl[idx], ATXCTL_RIV, (conf >> 4) & 0x1);\r\nset_field(&ctl->txctl[idx], ATXCTL_RAW,\r\n((conf >> 3) & 0x1) ? 0 : 0);\r\nctl->dirty.bf.atxctl |= (0x1 << idx);\r\n} else {\r\n}\r\nreturn 0;\r\n}\r\nstatic int daio_mgr_set_imaparc(void *blk, unsigned int slot)\r\n{\r\nstruct daio_mgr_ctrl_blk *ctl = blk;\r\nset_field(&ctl->daoimap.aim, AIM_ARC, slot);\r\nctl->dirty.bf.daoimap = 1;\r\nreturn 0;\r\n}\r\nstatic int daio_mgr_set_imapnxt(void *blk, unsigned int next)\r\n{\r\nstruct daio_mgr_ctrl_blk *ctl = blk;\r\nset_field(&ctl->daoimap.aim, AIM_NXT, next);\r\nctl->dirty.bf.daoimap = 1;\r\nreturn 0;\r\n}\r\nstatic int daio_mgr_set_imapaddr(void *blk, unsigned int addr)\r\n{\r\n((struct daio_mgr_ctrl_blk *)blk)->daoimap.idx = addr;\r\n((struct daio_mgr_ctrl_blk *)blk)->dirty.bf.daoimap = 1;\r\nreturn 0;\r\n}\r\nstatic int daio_mgr_commit_write(struct hw *hw, void *blk)\r\n{\r\nstruct daio_mgr_ctrl_blk *ctl = blk;\r\nunsigned int data;\r\nint i;\r\nfor (i = 0; i < 8; i++) {\r\nif ((ctl->dirty.bf.atxctl & (0x1 << i))) {\r\ndata = ctl->txctl[i];\r\nhw_write_20kx(hw, (AUDIO_IO_TX_CTL+(0x40*i)), data);\r\nctl->dirty.bf.atxctl &= ~(0x1 << i);\r\nmdelay(1);\r\n}\r\nif ((ctl->dirty.bf.arxctl & (0x1 << i))) {\r\ndata = ctl->rxctl[i];\r\nhw_write_20kx(hw, (AUDIO_IO_RX_CTL+(0x40*i)), data);\r\nctl->dirty.bf.arxctl &= ~(0x1 << i);\r\nmdelay(1);\r\n}\r\n}\r\nif (ctl->dirty.bf.daoimap) {\r\nhw_write_20kx(hw, AUDIO_IO_AIM+ctl->daoimap.idx*4,\r\nctl->daoimap.aim);\r\nctl->dirty.bf.daoimap = 0;\r\n}\r\nreturn 0;\r\n}\r\nstatic int daio_mgr_get_ctrl_blk(struct hw *hw, void **rblk)\r\n{\r\nstruct daio_mgr_ctrl_blk *blk;\r\nint i;\r\n*rblk = NULL;\r\nblk = kzalloc(sizeof(*blk), GFP_KERNEL);\r\nif (!blk)\r\nreturn -ENOMEM;\r\nfor (i = 0; i < 8; i++) {\r\nblk->txctl[i] = hw_read_20kx(hw, AUDIO_IO_TX_CTL+(0x40*i));\r\nblk->rxctl[i] = hw_read_20kx(hw, AUDIO_IO_RX_CTL+(0x40*i));\r\n}\r\n*rblk = blk;\r\nreturn 0;\r\n}\r\nstatic int daio_mgr_put_ctrl_blk(void *blk)\r\n{\r\nkfree(blk);\r\nreturn 0;\r\n}\r\nstatic int set_timer_irq(struct hw *hw, int enable)\r\n{\r\nhw_write_20kx(hw, GIE, enable ? IT_INT : 0);\r\nreturn 0;\r\n}\r\nstatic int set_timer_tick(struct hw *hw, unsigned int ticks)\r\n{\r\nif (ticks)\r\nticks |= TIMR_IE | TIMR_IP;\r\nhw_write_20kx(hw, TIMR, ticks);\r\nreturn 0;\r\n}\r\nstatic unsigned int get_wc(struct hw *hw)\r\n{\r\nreturn hw_read_20kx(hw, WC);\r\n}\r\nstatic int hw_daio_init(struct hw *hw, const struct daio_conf *info)\r\n{\r\nu32 data;\r\nint i;\r\nif (1 == info->msr) {\r\nhw_write_20kx(hw, AUDIO_IO_MCLK, 0x01010101);\r\nhw_write_20kx(hw, AUDIO_IO_TX_BLRCLK, 0x01010101);\r\nhw_write_20kx(hw, AUDIO_IO_RX_BLRCLK, 0);\r\n} else if (2 == info->msr) {\r\nif (hw->model != CTSB1270) {\r\nhw_write_20kx(hw, AUDIO_IO_MCLK, 0x11111111);\r\n} else {\r\nhw_write_20kx(hw, AUDIO_IO_MCLK, 0x11011111);\r\n}\r\nhw_write_20kx(hw, AUDIO_IO_TX_BLRCLK, 0x11111111);\r\nhw_write_20kx(hw, AUDIO_IO_RX_BLRCLK, 0);\r\n} else if ((4 == info->msr) && (hw->model == CTSB1270)) {\r\nhw_write_20kx(hw, AUDIO_IO_MCLK, 0x21011111);\r\nhw_write_20kx(hw, AUDIO_IO_TX_BLRCLK, 0x21212121);\r\nhw_write_20kx(hw, AUDIO_IO_RX_BLRCLK, 0);\r\n} else {\r\ndev_alert(hw->card->dev,\r\n"ERROR!!! Invalid sampling rate!!!\n");\r\nreturn -EINVAL;\r\n}\r\nfor (i = 0; i < 8; i++) {\r\nif (i <= 3) {\r\nif (i == 3)\r\ndata = 0x1001001;\r\nelse\r\ndata = 0x1000001;\r\nhw_write_20kx(hw, (AUDIO_IO_TX_CTL+(0x40*i)), data);\r\nhw_write_20kx(hw, (AUDIO_IO_RX_CTL+(0x40*i)), data);\r\nhw_write_20kx(hw, AUDIO_IO_TX_CSTAT_L+(0x40*i),\r\n0x02109204);\r\nhw_write_20kx(hw, AUDIO_IO_TX_CSTAT_H+(0x40*i), 0x0B);\r\n} else {\r\ndata = 0x11;\r\nhw_write_20kx(hw, AUDIO_IO_RX_CTL+(0x40*i), data);\r\nif (2 == info->msr) {\r\ndata |= 0x1000;\r\n} else if (4 == info->msr) {\r\ndata |= 0x2000;\r\n}\r\nhw_write_20kx(hw, AUDIO_IO_TX_CTL+(0x40*i), data);\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int hw_trn_init(struct hw *hw, const struct trn_conf *info)\r\n{\r\nu32 vmctl, data;\r\nu32 ptp_phys_low, ptp_phys_high;\r\nint i;\r\nif ((~0UL) == info->vm_pgt_phys) {\r\ndev_alert(hw->card->dev,\r\n"Wrong device page table page address!!!\n");\r\nreturn -1;\r\n}\r\nvmctl = 0x80000C0F;\r\nptp_phys_low = (u32)info->vm_pgt_phys;\r\nptp_phys_high = upper_32_bits(info->vm_pgt_phys);\r\nif (sizeof(void *) == 8)\r\nvmctl |= (3 << 8);\r\nfor (i = 0; i < 64; i++) {\r\nhw_write_20kx(hw, VMEM_PTPAL+(16*i), ptp_phys_low);\r\nhw_write_20kx(hw, VMEM_PTPAH+(16*i), ptp_phys_high);\r\n}\r\nhw_write_20kx(hw, VMEM_CTL, vmctl);\r\nhw_write_20kx(hw, TRANSPORT_CTL, 0x03);\r\nhw_write_20kx(hw, TRANSPORT_INT, 0x200c01);\r\ndata = hw_read_20kx(hw, TRANSPORT_ENB);\r\nhw_write_20kx(hw, TRANSPORT_ENB, (data | 0x03));\r\nreturn 0;\r\n}\r\nstatic int hw_pll_init(struct hw *hw, unsigned int rsr)\r\n{\r\nunsigned int pllenb;\r\nunsigned int pllctl;\r\nunsigned int pllstat;\r\nint i;\r\npllenb = 0xB;\r\nhw_write_20kx(hw, PLL_ENB, pllenb);\r\npllctl = 0x20C00000;\r\nset_field(&pllctl, PLLCTL_B, 0);\r\nset_field(&pllctl, PLLCTL_FD, 48000 == rsr ? 16 - 4 : 147 - 4);\r\nset_field(&pllctl, PLLCTL_RD, 48000 == rsr ? 1 - 1 : 10 - 1);\r\nhw_write_20kx(hw, PLL_CTL, pllctl);\r\nmdelay(40);\r\npllctl = hw_read_20kx(hw, PLL_CTL);\r\nset_field(&pllctl, PLLCTL_FD, 48000 == rsr ? 16 - 2 : 147 - 2);\r\nhw_write_20kx(hw, PLL_CTL, pllctl);\r\nmdelay(40);\r\nfor (i = 0; i < 1000; i++) {\r\npllstat = hw_read_20kx(hw, PLL_STAT);\r\nif (get_field(pllstat, PLLSTAT_PD))\r\ncontinue;\r\nif (get_field(pllstat, PLLSTAT_B) !=\r\nget_field(pllctl, PLLCTL_B))\r\ncontinue;\r\nif (get_field(pllstat, PLLSTAT_CCS) !=\r\nget_field(pllctl, PLLCTL_SRC))\r\ncontinue;\r\nif (get_field(pllstat, PLLSTAT_CRD) !=\r\nget_field(pllctl, PLLCTL_RD))\r\ncontinue;\r\nif (get_field(pllstat, PLLSTAT_CFD) !=\r\nget_field(pllctl, PLLCTL_FD))\r\ncontinue;\r\nbreak;\r\n}\r\nif (i >= 1000) {\r\ndev_alert(hw->card->dev,\r\n"PLL initialization failed!!!\n");\r\nreturn -EBUSY;\r\n}\r\nreturn 0;\r\n}\r\nstatic int hw_auto_init(struct hw *hw)\r\n{\r\nunsigned int gctl;\r\nint i;\r\ngctl = hw_read_20kx(hw, GLOBAL_CNTL_GCTL);\r\nset_field(&gctl, GCTL_AIE, 0);\r\nhw_write_20kx(hw, GLOBAL_CNTL_GCTL, gctl);\r\nset_field(&gctl, GCTL_AIE, 1);\r\nhw_write_20kx(hw, GLOBAL_CNTL_GCTL, gctl);\r\nmdelay(10);\r\nfor (i = 0; i < 400000; i++) {\r\ngctl = hw_read_20kx(hw, GLOBAL_CNTL_GCTL);\r\nif (get_field(gctl, GCTL_AID))\r\nbreak;\r\n}\r\nif (!get_field(gctl, GCTL_AID)) {\r\ndev_alert(hw->card->dev, "Card Auto-init failed!!!\n");\r\nreturn -EBUSY;\r\n}\r\nreturn 0;\r\n}\r\nstatic int hw20k2_i2c_unlock_full_access(struct hw *hw)\r\n{\r\nu8 UnlockKeySequence_FLASH_FULLACCESS_MODE[2] = {0xB3, 0xD4};\r\nhw_write_20kx(hw, I2C_IF_WLOCK,\r\nUnlockKeySequence_FLASH_FULLACCESS_MODE[0]);\r\nhw_write_20kx(hw, I2C_IF_WLOCK,\r\nUnlockKeySequence_FLASH_FULLACCESS_MODE[1]);\r\nif (hw_read_20kx(hw, I2C_IF_WLOCK) == STATE_UNLOCKED)\r\nreturn 0;\r\nreturn -1;\r\n}\r\nstatic int hw20k2_i2c_lock_chip(struct hw *hw)\r\n{\r\nhw_write_20kx(hw, I2C_IF_WLOCK, STATE_LOCKED);\r\nhw_write_20kx(hw, I2C_IF_WLOCK, STATE_LOCKED);\r\nif (hw_read_20kx(hw, I2C_IF_WLOCK) == STATE_LOCKED)\r\nreturn 0;\r\nreturn -1;\r\n}\r\nstatic int hw20k2_i2c_init(struct hw *hw, u8 dev_id, u8 addr_size, u8 data_size)\r\n{\r\nstruct hw20k2 *hw20k2 = (struct hw20k2 *)hw;\r\nint err;\r\nunsigned int i2c_status;\r\nunsigned int i2c_addr;\r\nerr = hw20k2_i2c_unlock_full_access(hw);\r\nif (err < 0)\r\nreturn err;\r\nhw20k2->addr_size = addr_size;\r\nhw20k2->data_size = data_size;\r\nhw20k2->dev_id = dev_id;\r\ni2c_addr = 0;\r\nset_field(&i2c_addr, I2C_ADDRESS_SLAD, dev_id);\r\nhw_write_20kx(hw, I2C_IF_ADDRESS, i2c_addr);\r\ni2c_status = hw_read_20kx(hw, I2C_IF_STATUS);\r\nset_field(&i2c_status, I2C_STATUS_DCM, 1);\r\nhw_write_20kx(hw, I2C_IF_STATUS, i2c_status);\r\nreturn 0;\r\n}\r\nstatic int hw20k2_i2c_uninit(struct hw *hw)\r\n{\r\nunsigned int i2c_status;\r\nunsigned int i2c_addr;\r\ni2c_addr = 0;\r\nset_field(&i2c_addr, I2C_ADDRESS_SLAD, 0x57);\r\nhw_write_20kx(hw, I2C_IF_ADDRESS, i2c_addr);\r\ni2c_status = hw_read_20kx(hw, I2C_IF_STATUS);\r\nset_field(&i2c_status, I2C_STATUS_DCM, 0);\r\nhw_write_20kx(hw, I2C_IF_STATUS, i2c_status);\r\nreturn hw20k2_i2c_lock_chip(hw);\r\n}\r\nstatic int hw20k2_i2c_wait_data_ready(struct hw *hw)\r\n{\r\nint i = 0x400000;\r\nunsigned int ret;\r\ndo {\r\nret = hw_read_20kx(hw, I2C_IF_STATUS);\r\n} while ((!(ret & DATA_READY)) && --i);\r\nreturn i;\r\n}\r\nstatic int hw20k2_i2c_read(struct hw *hw, u16 addr, u32 *datap)\r\n{\r\nstruct hw20k2 *hw20k2 = (struct hw20k2 *)hw;\r\nunsigned int i2c_status;\r\ni2c_status = hw_read_20kx(hw, I2C_IF_STATUS);\r\nset_field(&i2c_status, I2C_STATUS_BC,\r\n(4 == hw20k2->addr_size) ? 0 : hw20k2->addr_size);\r\nhw_write_20kx(hw, I2C_IF_STATUS, i2c_status);\r\nif (!hw20k2_i2c_wait_data_ready(hw))\r\nreturn -1;\r\nhw_write_20kx(hw, I2C_IF_WDATA, addr);\r\nif (!hw20k2_i2c_wait_data_ready(hw))\r\nreturn -1;\r\nhw_write_20kx(hw, I2C_IF_RDATA, 0);\r\nif (!hw20k2_i2c_wait_data_ready(hw))\r\nreturn -1;\r\n*datap = hw_read_20kx(hw, I2C_IF_RDATA);\r\nreturn 0;\r\n}\r\nstatic int hw20k2_i2c_write(struct hw *hw, u16 addr, u32 data)\r\n{\r\nstruct hw20k2 *hw20k2 = (struct hw20k2 *)hw;\r\nunsigned int i2c_data = (data << (hw20k2->addr_size * 8)) | addr;\r\nunsigned int i2c_status;\r\ni2c_status = hw_read_20kx(hw, I2C_IF_STATUS);\r\nset_field(&i2c_status, I2C_STATUS_BC,\r\n(4 == (hw20k2->addr_size + hw20k2->data_size)) ?\r\n0 : (hw20k2->addr_size + hw20k2->data_size));\r\nhw_write_20kx(hw, I2C_IF_STATUS, i2c_status);\r\nhw20k2_i2c_wait_data_ready(hw);\r\nhw_write_20kx(hw, I2C_IF_WDATA, 0);\r\nhw20k2_i2c_wait_data_ready(hw);\r\nhw_write_20kx(hw, I2C_IF_WDATA, i2c_data);\r\nhw20k2_i2c_wait_data_ready(hw);\r\nreturn 0;\r\n}\r\nstatic void hw_dac_stop(struct hw *hw)\r\n{\r\nu32 data;\r\ndata = hw_read_20kx(hw, GPIO_DATA);\r\ndata &= 0xFFFFFFFD;\r\nhw_write_20kx(hw, GPIO_DATA, data);\r\nmdelay(10);\r\n}\r\nstatic void hw_dac_start(struct hw *hw)\r\n{\r\nu32 data;\r\ndata = hw_read_20kx(hw, GPIO_DATA);\r\ndata |= 0x2;\r\nhw_write_20kx(hw, GPIO_DATA, data);\r\nmdelay(50);\r\n}\r\nstatic void hw_dac_reset(struct hw *hw)\r\n{\r\nhw_dac_stop(hw);\r\nhw_dac_start(hw);\r\n}\r\nstatic int hw_dac_init(struct hw *hw, const struct dac_conf *info)\r\n{\r\nint err;\r\nu32 data;\r\nint i;\r\nstruct regs_cs4382 cs_read = {0};\r\nstruct regs_cs4382 cs_def = {\r\n0x00000001,\r\n0x00000000,\r\n0x00000084,\r\n0x00000000,\r\n0x00000000,\r\n0x00000024,\r\n0x00000000,\r\n0x00000000,\r\n0x00000024,\r\n0x00000000,\r\n0x00000000,\r\n0x00000024,\r\n0x00000000,\r\n0x00000000,\r\n0x00000024,\r\n0x00000000,\r\n0x00000000\r\n};\r\nif (hw->model == CTSB1270) {\r\nhw_dac_stop(hw);\r\ndata = hw_read_20kx(hw, GPIO_DATA);\r\ndata &= ~0x0600;\r\nif (1 == info->msr)\r\ndata |= 0x0000;\r\nelse if (2 == info->msr)\r\ndata |= 0x0200;\r\nelse\r\ndata |= 0x0600;\r\nhw_write_20kx(hw, GPIO_DATA, data);\r\nhw_dac_start(hw);\r\nreturn 0;\r\n}\r\ndata = hw_read_20kx(hw, GPIO_CTRL);\r\ndata |= 0x02;\r\nhw_write_20kx(hw, GPIO_CTRL, data);\r\nerr = hw20k2_i2c_init(hw, 0x18, 1, 1);\r\nif (err < 0)\r\ngoto End;\r\nfor (i = 0; i < 2; i++) {\r\nhw_dac_reset(hw);\r\nhw_dac_reset(hw);\r\nif (hw20k2_i2c_read(hw, CS4382_MC1, &cs_read.mode_control_1))\r\ncontinue;\r\nif (hw20k2_i2c_read(hw, CS4382_MC2, &cs_read.mode_control_2))\r\ncontinue;\r\nif (hw20k2_i2c_read(hw, CS4382_MC3, &cs_read.mode_control_3))\r\ncontinue;\r\nif (hw20k2_i2c_read(hw, CS4382_FC, &cs_read.filter_control))\r\ncontinue;\r\nif (hw20k2_i2c_read(hw, CS4382_IC, &cs_read.invert_control))\r\ncontinue;\r\nif (hw20k2_i2c_read(hw, CS4382_XC1, &cs_read.mix_control_P1))\r\ncontinue;\r\nif (hw20k2_i2c_read(hw, CS4382_VCA1, &cs_read.vol_control_A1))\r\ncontinue;\r\nif (hw20k2_i2c_read(hw, CS4382_VCB1, &cs_read.vol_control_B1))\r\ncontinue;\r\nif (hw20k2_i2c_read(hw, CS4382_XC2, &cs_read.mix_control_P2))\r\ncontinue;\r\nif (hw20k2_i2c_read(hw, CS4382_VCA2, &cs_read.vol_control_A2))\r\ncontinue;\r\nif (hw20k2_i2c_read(hw, CS4382_VCB2, &cs_read.vol_control_B2))\r\ncontinue;\r\nif (hw20k2_i2c_read(hw, CS4382_XC3, &cs_read.mix_control_P3))\r\ncontinue;\r\nif (hw20k2_i2c_read(hw, CS4382_VCA3, &cs_read.vol_control_A3))\r\ncontinue;\r\nif (hw20k2_i2c_read(hw, CS4382_VCB3, &cs_read.vol_control_B3))\r\ncontinue;\r\nif (hw20k2_i2c_read(hw, CS4382_XC4, &cs_read.mix_control_P4))\r\ncontinue;\r\nif (hw20k2_i2c_read(hw, CS4382_VCA4, &cs_read.vol_control_A4))\r\ncontinue;\r\nif (hw20k2_i2c_read(hw, CS4382_VCB4, &cs_read.vol_control_B4))\r\ncontinue;\r\nif (memcmp(&cs_read, &cs_def, sizeof(cs_read)))\r\ncontinue;\r\nelse\r\nbreak;\r\n}\r\nif (i >= 2)\r\ngoto End;\r\nhw20k2_i2c_write(hw, CS4382_MC1, 0x80);\r\nhw20k2_i2c_write(hw, CS4382_MC2, 0x10);\r\nif (1 == info->msr) {\r\nhw20k2_i2c_write(hw, CS4382_XC1, 0x24);\r\nhw20k2_i2c_write(hw, CS4382_XC2, 0x24);\r\nhw20k2_i2c_write(hw, CS4382_XC3, 0x24);\r\nhw20k2_i2c_write(hw, CS4382_XC4, 0x24);\r\n} else if (2 == info->msr) {\r\nhw20k2_i2c_write(hw, CS4382_XC1, 0x25);\r\nhw20k2_i2c_write(hw, CS4382_XC2, 0x25);\r\nhw20k2_i2c_write(hw, CS4382_XC3, 0x25);\r\nhw20k2_i2c_write(hw, CS4382_XC4, 0x25);\r\n} else {\r\nhw20k2_i2c_write(hw, CS4382_XC1, 0x26);\r\nhw20k2_i2c_write(hw, CS4382_XC2, 0x26);\r\nhw20k2_i2c_write(hw, CS4382_XC3, 0x26);\r\nhw20k2_i2c_write(hw, CS4382_XC4, 0x26);\r\n}\r\nreturn 0;\r\nEnd:\r\nhw20k2_i2c_uninit(hw);\r\nreturn -1;\r\n}\r\nstatic int hw_is_adc_input_selected(struct hw *hw, enum ADCSRC type)\r\n{\r\nu32 data;\r\nif (hw->model == CTSB1270) {\r\nreturn 1;\r\n}\r\ndata = hw_read_20kx(hw, GPIO_DATA);\r\nswitch (type) {\r\ncase ADC_MICIN:\r\ndata = (data & (0x1 << 14)) ? 1 : 0;\r\nbreak;\r\ncase ADC_LINEIN:\r\ndata = (data & (0x1 << 14)) ? 0 : 1;\r\nbreak;\r\ndefault:\r\ndata = 0;\r\n}\r\nreturn data;\r\n}\r\nstatic void hw_wm8775_input_select(struct hw *hw, u8 input, s8 gain_in_db)\r\n{\r\nu32 adcmc, gain;\r\nif (input > 3)\r\ninput = 3;\r\nadcmc = ((u32)1 << input) | 0x100;\r\nhw20k2_i2c_write(hw, MAKE_WM8775_ADDR(WM8775_ADCMC, adcmc),\r\nMAKE_WM8775_DATA(adcmc));\r\nif (gain_in_db < -103)\r\ngain_in_db = -103;\r\nif (gain_in_db > 24)\r\ngain_in_db = 24;\r\ngain = gain_in_db * MIC_BOOST_STEPS_PER_DB + MIC_BOOST_0DB;\r\nhw20k2_i2c_write(hw, MAKE_WM8775_ADDR(WM8775_AADCL, gain),\r\nMAKE_WM8775_DATA(gain));\r\nhw20k2_i2c_write(hw, MAKE_WM8775_ADDR(WM8775_AADCR, gain),\r\nMAKE_WM8775_DATA(gain));\r\n}\r\nstatic int hw_adc_input_select(struct hw *hw, enum ADCSRC type)\r\n{\r\nu32 data;\r\ndata = hw_read_20kx(hw, GPIO_DATA);\r\nswitch (type) {\r\ncase ADC_MICIN:\r\ndata |= (0x1 << 14);\r\nhw_write_20kx(hw, GPIO_DATA, data);\r\nhw_wm8775_input_select(hw, 0, 20);\r\nbreak;\r\ncase ADC_LINEIN:\r\ndata &= ~(0x1 << 14);\r\nhw_write_20kx(hw, GPIO_DATA, data);\r\nhw_wm8775_input_select(hw, 1, 0);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic int hw_adc_init(struct hw *hw, const struct adc_conf *info)\r\n{\r\nint err;\r\nu32 data, ctl;\r\ndata = hw_read_20kx(hw, GPIO_CTRL);\r\ndata |= (0x1 << 15);\r\nhw_write_20kx(hw, GPIO_CTRL, data);\r\nerr = hw20k2_i2c_init(hw, 0x1A, 1, 1);\r\nif (err < 0) {\r\ndev_alert(hw->card->dev, "Failure to acquire I2C!!!\n");\r\ngoto error;\r\n}\r\ndata = hw_read_20kx(hw, GPIO_DATA);\r\ndata &= ~(0x1 << 15);\r\nhw_write_20kx(hw, GPIO_DATA, data);\r\nif (hw->model == CTSB1270) {\r\ndata &= ~0x0C;\r\nif (1 == info->msr)\r\ndata |= 0x00;\r\nelse if (2 == info->msr)\r\ndata |= 0x08;\r\nelse\r\ndata |= 0x04;\r\nhw_write_20kx(hw, GPIO_DATA, data);\r\n}\r\nmdelay(10);\r\ndata |= (0x1 << 15);\r\nhw_write_20kx(hw, GPIO_DATA, data);\r\nmdelay(50);\r\nhw20k2_i2c_write(hw, MAKE_WM8775_ADDR(WM8775_IC, 0x26),\r\nMAKE_WM8775_DATA(0x26));\r\nif (1 == info->msr) {\r\nhw20k2_i2c_write(hw, MAKE_WM8775_ADDR(WM8775_MMC, 0x02),\r\nMAKE_WM8775_DATA(0x02));\r\n} else if ((2 == info->msr) || (4 == info->msr)) {\r\nhw20k2_i2c_write(hw, MAKE_WM8775_ADDR(WM8775_MMC, 0x0A),\r\nMAKE_WM8775_DATA(0x0A));\r\n} else {\r\ndev_alert(hw->card->dev,\r\n"Invalid master sampling rate (msr %d)!!!\n",\r\ninfo->msr);\r\nerr = -EINVAL;\r\ngoto error;\r\n}\r\nif (hw->model != CTSB1270) {\r\nctl = hw_read_20kx(hw, GPIO_CTRL);\r\nctl |= 0x1 << 14;\r\nhw_write_20kx(hw, GPIO_CTRL, ctl);\r\nhw_adc_input_select(hw, ADC_LINEIN);\r\n} else {\r\nhw_wm8775_input_select(hw, 0, 0);\r\n}\r\nreturn 0;\r\nerror:\r\nhw20k2_i2c_uninit(hw);\r\nreturn err;\r\n}\r\nstatic struct capabilities hw_capabilities(struct hw *hw)\r\n{\r\nstruct capabilities cap;\r\ncap.digit_io_switch = 0;\r\ncap.dedicated_mic = hw->model == CTSB1270;\r\ncap.output_switch = hw->model == CTSB1270;\r\ncap.mic_source_switch = hw->model == CTSB1270;\r\nreturn cap;\r\n}\r\nstatic int hw_output_switch_get(struct hw *hw)\r\n{\r\nu32 data = hw_read_20kx(hw, GPIO_EXT_DATA);\r\nswitch (data & 0x30) {\r\ncase 0x00:\r\nreturn 0;\r\ncase 0x10:\r\nreturn 1;\r\ncase 0x20:\r\nreturn 2;\r\ndefault:\r\nreturn 3;\r\n}\r\n}\r\nstatic int hw_output_switch_put(struct hw *hw, int position)\r\n{\r\nu32 data;\r\nif (position == hw_output_switch_get(hw))\r\nreturn 0;\r\ndata = hw_read_20kx(hw, GPIO_DATA);\r\ndata |= (0x03 << 11);\r\nhw_write_20kx(hw, GPIO_DATA, data);\r\ndata = hw_read_20kx(hw, GPIO_EXT_DATA) & ~0x30;\r\nswitch (position) {\r\ncase 0:\r\nbreak;\r\ncase 1:\r\ndata |= 0x10;\r\nbreak;\r\ndefault:\r\ndata |= 0x20;\r\n}\r\nhw_write_20kx(hw, GPIO_EXT_DATA, data);\r\ndata = hw_read_20kx(hw, GPIO_DATA);\r\ndata &= ~(0x03 << 11);\r\nhw_write_20kx(hw, GPIO_DATA, data);\r\nreturn 1;\r\n}\r\nstatic int hw_mic_source_switch_get(struct hw *hw)\r\n{\r\nstruct hw20k2 *hw20k2 = (struct hw20k2 *)hw;\r\nreturn hw20k2->mic_source;\r\n}\r\nstatic int hw_mic_source_switch_put(struct hw *hw, int position)\r\n{\r\nstruct hw20k2 *hw20k2 = (struct hw20k2 *)hw;\r\nif (position == hw20k2->mic_source)\r\nreturn 0;\r\nswitch (position) {\r\ncase 0:\r\nhw_wm8775_input_select(hw, 0, 0);\r\nbreak;\r\ncase 1:\r\nhw_wm8775_input_select(hw, 1, 0);\r\nbreak;\r\ncase 2:\r\nhw_wm8775_input_select(hw, 3, 0);\r\nbreak;\r\ndefault:\r\nreturn 0;\r\n}\r\nhw20k2->mic_source = position;\r\nreturn 1;\r\n}\r\nstatic irqreturn_t ct_20k2_interrupt(int irq, void *dev_id)\r\n{\r\nstruct hw *hw = dev_id;\r\nunsigned int status;\r\nstatus = hw_read_20kx(hw, GIP);\r\nif (!status)\r\nreturn IRQ_NONE;\r\nif (hw->irq_callback)\r\nhw->irq_callback(hw->irq_callback_data, status);\r\nhw_write_20kx(hw, GIP, status);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int hw_card_start(struct hw *hw)\r\n{\r\nint err = 0;\r\nstruct pci_dev *pci = hw->pci;\r\nunsigned int gctl;\r\nerr = pci_enable_device(pci);\r\nif (err < 0)\r\nreturn err;\r\nif (dma_set_mask(&pci->dev, CT_XFI_DMA_MASK) < 0 ||\r\ndma_set_coherent_mask(&pci->dev, CT_XFI_DMA_MASK) < 0) {\r\ndev_err(hw->card->dev,\r\n"architecture does not support PCI busmaster DMA with mask 0x%llx\n",\r\nCT_XFI_DMA_MASK);\r\nerr = -ENXIO;\r\ngoto error1;\r\n}\r\nif (!hw->io_base) {\r\nerr = pci_request_regions(pci, "XFi");\r\nif (err < 0)\r\ngoto error1;\r\nhw->io_base = pci_resource_start(hw->pci, 2);\r\nhw->mem_base = ioremap(hw->io_base,\r\npci_resource_len(hw->pci, 2));\r\nif (!hw->mem_base) {\r\nerr = -ENOENT;\r\ngoto error2;\r\n}\r\n}\r\ngctl = hw_read_20kx(hw, GLOBAL_CNTL_GCTL);\r\nset_field(&gctl, GCTL_UAA, 0);\r\nhw_write_20kx(hw, GLOBAL_CNTL_GCTL, gctl);\r\nif (hw->irq < 0) {\r\nerr = request_irq(pci->irq, ct_20k2_interrupt, IRQF_SHARED,\r\nKBUILD_MODNAME, hw);\r\nif (err < 0) {\r\ndev_err(hw->card->dev,\r\n"XFi: Cannot get irq %d\n", pci->irq);\r\ngoto error2;\r\n}\r\nhw->irq = pci->irq;\r\n}\r\npci_set_master(pci);\r\nreturn 0;\r\nerror2:\r\npci_release_regions(pci);\r\nhw->io_base = 0;\r\nerror1:\r\npci_disable_device(pci);\r\nreturn err;\r\n}\r\nstatic int hw_card_stop(struct hw *hw)\r\n{\r\nunsigned int data;\r\nhw_write_20kx(hw, TRANSPORT_CTL, 0x00);\r\ndata = hw_read_20kx(hw, PLL_ENB);\r\nhw_write_20kx(hw, PLL_ENB, (data & (~0x07)));\r\nreturn 0;\r\n}\r\nstatic int hw_card_shutdown(struct hw *hw)\r\n{\r\nif (hw->irq >= 0)\r\nfree_irq(hw->irq, hw);\r\nhw->irq = -1;\r\niounmap(hw->mem_base);\r\nhw->mem_base = NULL;\r\nif (hw->io_base)\r\npci_release_regions(hw->pci);\r\nhw->io_base = 0;\r\npci_disable_device(hw->pci);\r\nreturn 0;\r\n}\r\nstatic int hw_card_init(struct hw *hw, struct card_conf *info)\r\n{\r\nint err;\r\nunsigned int gctl;\r\nu32 data = 0;\r\nstruct dac_conf dac_info = {0};\r\nstruct adc_conf adc_info = {0};\r\nstruct daio_conf daio_info = {0};\r\nstruct trn_conf trn_info = {0};\r\nerr = hw_card_start(hw);\r\nif (err)\r\nreturn err;\r\nerr = hw_pll_init(hw, info->rsr);\r\nif (err < 0)\r\nreturn err;\r\nerr = hw_auto_init(hw);\r\nif (err < 0)\r\nreturn err;\r\ngctl = hw_read_20kx(hw, GLOBAL_CNTL_GCTL);\r\nset_field(&gctl, GCTL_DBP, 1);\r\nset_field(&gctl, GCTL_TBP, 1);\r\nset_field(&gctl, GCTL_FBP, 1);\r\nset_field(&gctl, GCTL_DPC, 0);\r\nhw_write_20kx(hw, GLOBAL_CNTL_GCTL, gctl);\r\nhw_write_20kx(hw, GIE, 0);\r\nhw_write_20kx(hw, SRC_IP, 0);\r\nif (hw->model != CTSB1270) {\r\nhw_write_20kx(hw, GPIO_CTRL, 0xD802);\r\n} else {\r\nhw_write_20kx(hw, GPIO_CTRL, 0x9E5F);\r\n}\r\nhw_write_20kx(hw, MIXER_AR_ENABLE, 0x01);\r\ntrn_info.vm_pgt_phys = info->vm_pgt_phys;\r\nerr = hw_trn_init(hw, &trn_info);\r\nif (err < 0)\r\nreturn err;\r\ndaio_info.msr = info->msr;\r\nerr = hw_daio_init(hw, &daio_info);\r\nif (err < 0)\r\nreturn err;\r\ndac_info.msr = info->msr;\r\nerr = hw_dac_init(hw, &dac_info);\r\nif (err < 0)\r\nreturn err;\r\nadc_info.msr = info->msr;\r\nadc_info.input = ADC_LINEIN;\r\nadc_info.mic20db = 0;\r\nerr = hw_adc_init(hw, &adc_info);\r\nif (err < 0)\r\nreturn err;\r\ndata = hw_read_20kx(hw, SRC_MCTL);\r\ndata |= 0x1;\r\nhw_write_20kx(hw, SRC_MCTL, data);\r\nreturn 0;\r\n}\r\nstatic int hw_suspend(struct hw *hw)\r\n{\r\nhw_card_stop(hw);\r\nreturn 0;\r\n}\r\nstatic int hw_resume(struct hw *hw, struct card_conf *info)\r\n{\r\nreturn hw_card_init(hw, info);\r\n}\r\nstatic u32 hw_read_20kx(struct hw *hw, u32 reg)\r\n{\r\nreturn readl(hw->mem_base + reg);\r\n}\r\nstatic void hw_write_20kx(struct hw *hw, u32 reg, u32 data)\r\n{\r\nwritel(data, hw->mem_base + reg);\r\n}\r\nint create_20k2_hw_obj(struct hw **rhw)\r\n{\r\nstruct hw20k2 *hw20k2;\r\n*rhw = NULL;\r\nhw20k2 = kzalloc(sizeof(*hw20k2), GFP_KERNEL);\r\nif (!hw20k2)\r\nreturn -ENOMEM;\r\nhw20k2->hw = ct20k2_preset;\r\n*rhw = &hw20k2->hw;\r\nreturn 0;\r\n}\r\nint destroy_20k2_hw_obj(struct hw *hw)\r\n{\r\nif (hw->io_base)\r\nhw_card_shutdown(hw);\r\nkfree(hw);\r\nreturn 0;\r\n}
