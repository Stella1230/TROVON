int cvmx_helper_board_get_mii_address(int ipd_port)\r\n{\r\nswitch (cvmx_sysinfo_get()->board_type) {\r\ncase CVMX_BOARD_TYPE_SIM:\r\nreturn -1;\r\ncase CVMX_BOARD_TYPE_EBT3000:\r\ncase CVMX_BOARD_TYPE_EBT5800:\r\ncase CVMX_BOARD_TYPE_THUNDER:\r\ncase CVMX_BOARD_TYPE_NICPRO2:\r\nif ((ipd_port >= 16) && (ipd_port < 20))\r\nreturn ipd_port - 16;\r\nelse\r\nreturn -1;\r\ncase CVMX_BOARD_TYPE_KODAMA:\r\ncase CVMX_BOARD_TYPE_EBH3100:\r\ncase CVMX_BOARD_TYPE_HIKARI:\r\ncase CVMX_BOARD_TYPE_CN3010_EVB_HS5:\r\ncase CVMX_BOARD_TYPE_CN3005_EVB_HS5:\r\ncase CVMX_BOARD_TYPE_CN3020_EVB_HS5:\r\nif (ipd_port == 0)\r\nreturn 4;\r\nelse if (ipd_port == 1)\r\nreturn 9;\r\nelse\r\nreturn -1;\r\ncase CVMX_BOARD_TYPE_NAC38:\r\nif ((ipd_port >= 0) && (ipd_port < 4))\r\nreturn ipd_port;\r\nelse if ((ipd_port >= 16) && (ipd_port < 20))\r\nreturn ipd_port - 16 + 4;\r\nelse\r\nreturn -1;\r\ncase CVMX_BOARD_TYPE_EBH3000:\r\nreturn -1;\r\ncase CVMX_BOARD_TYPE_EBH5200:\r\ncase CVMX_BOARD_TYPE_EBH5201:\r\ncase CVMX_BOARD_TYPE_EBT5200:\r\nif ((ipd_port >= CVMX_HELPER_BOARD_MGMT_IPD_PORT) &&\r\n(ipd_port < (CVMX_HELPER_BOARD_MGMT_IPD_PORT + 2)))\r\nreturn ipd_port - CVMX_HELPER_BOARD_MGMT_IPD_PORT;\r\nif ((ipd_port >= 0) && (ipd_port < 4))\r\nreturn ipd_port + 2;\r\nelse\r\nreturn -1;\r\ncase CVMX_BOARD_TYPE_EBH5600:\r\ncase CVMX_BOARD_TYPE_EBH5601:\r\ncase CVMX_BOARD_TYPE_EBH5610:\r\nif (ipd_port == CVMX_HELPER_BOARD_MGMT_IPD_PORT)\r\nreturn 0;\r\nif ((ipd_port >= 0) && (ipd_port < 4))\r\nreturn ipd_port + 1;\r\nelse\r\nreturn -1;\r\ncase CVMX_BOARD_TYPE_CUST_NB5:\r\nif (ipd_port == 2)\r\nreturn 4;\r\nelse\r\nreturn -1;\r\ncase CVMX_BOARD_TYPE_NIC_XLE_4G:\r\nif ((ipd_port >= 16) && (ipd_port < 20))\r\nreturn ipd_port - 16 + 1;\r\nelse\r\nreturn -1;\r\ncase CVMX_BOARD_TYPE_NIC_XLE_10G:\r\ncase CVMX_BOARD_TYPE_NIC10E:\r\nreturn -1;\r\ncase CVMX_BOARD_TYPE_NIC4E:\r\nif (ipd_port >= 0 && ipd_port <= 3)\r\nreturn (ipd_port + 0x1f) & 0x1f;\r\nelse\r\nreturn -1;\r\ncase CVMX_BOARD_TYPE_NIC2E:\r\nif (ipd_port >= 0 && ipd_port <= 1)\r\nreturn ipd_port + 1;\r\nelse\r\nreturn -1;\r\ncase CVMX_BOARD_TYPE_BBGW_REF:\r\nreturn -1;\r\ncase CVMX_BOARD_TYPE_CUST_WSX16:\r\nif (ipd_port >= 0 && ipd_port <= 3)\r\nreturn ipd_port;\r\nelse if (ipd_port >= 16 && ipd_port <= 19)\r\nreturn ipd_port - 16 + 4;\r\nelse\r\nreturn -1;\r\ncase CVMX_BOARD_TYPE_UBNT_E100:\r\nif (ipd_port >= 0 && ipd_port <= 2)\r\nreturn 7 - ipd_port;\r\nelse\r\nreturn -1;\r\ncase CVMX_BOARD_TYPE_CUST_DSR1000N:\r\nif (ipd_port == 2)\r\nreturn 8;\r\nelse\r\nreturn -1;\r\ncase CVMX_BOARD_TYPE_KONTRON_S1901:\r\nif (ipd_port == CVMX_HELPER_BOARD_MGMT_IPD_PORT)\r\nreturn 1;\r\nelse\r\nreturn -1;\r\n}\r\ncvmx_dprintf\r\n("cvmx_helper_board_get_mii_address: Unknown board type %d\n",\r\ncvmx_sysinfo_get()->board_type);\r\nreturn -1;\r\n}\r\ncvmx_helper_link_info_t __cvmx_helper_board_link_get(int ipd_port)\r\n{\r\ncvmx_helper_link_info_t result;\r\nint phy_addr;\r\nint is_broadcom_phy = 0;\r\nif (cvmx_override_board_link_get)\r\nreturn cvmx_override_board_link_get(ipd_port);\r\nresult.u64 = 0;\r\nswitch (cvmx_sysinfo_get()->board_type) {\r\ncase CVMX_BOARD_TYPE_SIM:\r\nresult.s.link_up = 1;\r\nresult.s.full_duplex = 1;\r\nresult.s.speed = 1000;\r\nreturn result;\r\ncase CVMX_BOARD_TYPE_EBH3100:\r\ncase CVMX_BOARD_TYPE_CN3010_EVB_HS5:\r\ncase CVMX_BOARD_TYPE_CN3005_EVB_HS5:\r\ncase CVMX_BOARD_TYPE_CN3020_EVB_HS5:\r\nif (ipd_port == 1) {\r\nresult.s.link_up = 1;\r\nresult.s.full_duplex = 1;\r\nresult.s.speed = 1000;\r\nreturn result;\r\n}\r\nbreak;\r\ncase CVMX_BOARD_TYPE_CUST_NB5:\r\nif (ipd_port == 1) {\r\nresult.s.link_up = 1;\r\nresult.s.full_duplex = 1;\r\nresult.s.speed = 1000;\r\nreturn result;\r\n} else\r\nis_broadcom_phy = 1;\r\nbreak;\r\ncase CVMX_BOARD_TYPE_BBGW_REF:\r\nif (ipd_port == 2) {\r\nresult.u64 = 0;\r\nreturn result;\r\n} else {\r\nresult.s.link_up = 1;\r\nresult.s.full_duplex = 1;\r\nresult.s.speed = 1000;\r\nreturn result;\r\n}\r\nbreak;\r\ncase CVMX_BOARD_TYPE_CUST_DSR1000N:\r\nif (ipd_port == 0 || ipd_port == 1) {\r\nresult.s.link_up = 1;\r\nresult.s.full_duplex = 1;\r\nresult.s.speed = 1000;\r\nreturn result;\r\n} else {\r\nis_broadcom_phy = 1;\r\n}\r\nbreak;\r\n}\r\nphy_addr = cvmx_helper_board_get_mii_address(ipd_port);\r\nif (phy_addr != -1) {\r\nif (is_broadcom_phy) {\r\nint phy_status =\r\ncvmx_mdio_read(phy_addr >> 8, phy_addr & 0xff,\r\n0x19);\r\nswitch ((phy_status >> 8) & 0x7) {\r\ncase 0:\r\nresult.u64 = 0;\r\nbreak;\r\ncase 1:\r\nresult.s.link_up = 1;\r\nresult.s.full_duplex = 0;\r\nresult.s.speed = 10;\r\nbreak;\r\ncase 2:\r\nresult.s.link_up = 1;\r\nresult.s.full_duplex = 1;\r\nresult.s.speed = 10;\r\nbreak;\r\ncase 3:\r\nresult.s.link_up = 1;\r\nresult.s.full_duplex = 0;\r\nresult.s.speed = 100;\r\nbreak;\r\ncase 4:\r\nresult.s.link_up = 1;\r\nresult.s.full_duplex = 1;\r\nresult.s.speed = 100;\r\nbreak;\r\ncase 5:\r\nresult.s.link_up = 1;\r\nresult.s.full_duplex = 1;\r\nresult.s.speed = 100;\r\nbreak;\r\ncase 6:\r\nresult.s.link_up = 1;\r\nresult.s.full_duplex = 0;\r\nresult.s.speed = 1000;\r\nbreak;\r\ncase 7:\r\nresult.s.link_up = 1;\r\nresult.s.full_duplex = 1;\r\nresult.s.speed = 1000;\r\nbreak;\r\n}\r\n} else {\r\nint phy_status =\r\ncvmx_mdio_read(phy_addr >> 8, phy_addr & 0xff, 17);\r\nif ((phy_status & (1 << 11)) == 0) {\r\nint auto_status =\r\ncvmx_mdio_read(phy_addr >> 8,\r\nphy_addr & 0xff, 0);\r\nif ((auto_status & (1 << 12)) == 0)\r\nphy_status |= 1 << 11;\r\n}\r\nif (phy_status & (1 << 11)) {\r\nresult.s.link_up = 1;\r\nresult.s.full_duplex = ((phy_status >> 13) & 1);\r\nswitch ((phy_status >> 14) & 3) {\r\ncase 0:\r\nresult.s.speed = 10;\r\nbreak;\r\ncase 1:\r\nresult.s.speed = 100;\r\nbreak;\r\ncase 2:\r\nresult.s.speed = 1000;\r\nbreak;\r\ncase 3:\r\nresult.u64 = 0;\r\nbreak;\r\n}\r\n}\r\n}\r\n} else if (OCTEON_IS_MODEL(OCTEON_CN3XXX)\r\n|| OCTEON_IS_MODEL(OCTEON_CN58XX)\r\n|| OCTEON_IS_MODEL(OCTEON_CN50XX)) {\r\nunion cvmx_gmxx_rxx_rx_inbnd inband_status;\r\nint interface = cvmx_helper_get_interface_num(ipd_port);\r\nint index = cvmx_helper_get_interface_index_num(ipd_port);\r\ninband_status.u64 =\r\ncvmx_read_csr(CVMX_GMXX_RXX_RX_INBND(index, interface));\r\nresult.s.link_up = inband_status.s.status;\r\nresult.s.full_duplex = inband_status.s.duplex;\r\nswitch (inband_status.s.speed) {\r\ncase 0:\r\nresult.s.speed = 10;\r\nbreak;\r\ncase 1:\r\nresult.s.speed = 100;\r\nbreak;\r\ncase 2:\r\nresult.s.speed = 1000;\r\nbreak;\r\ncase 3:\r\nresult.u64 = 0;\r\nbreak;\r\n}\r\n} else {\r\nresult.u64 = 0;\r\n}\r\nif (!result.s.link_up)\r\nresult.u64 = 0;\r\nreturn result;\r\n}\r\nint cvmx_helper_board_link_set_phy(int phy_addr,\r\ncvmx_helper_board_set_phy_link_flags_types_t\r\nlink_flags,\r\ncvmx_helper_link_info_t link_info)\r\n{\r\nif ((link_flags & set_phy_link_flags_flow_control_mask) !=\r\nset_phy_link_flags_flow_control_dont_touch) {\r\ncvmx_mdio_phy_reg_autoneg_adver_t reg_autoneg_adver;\r\nreg_autoneg_adver.u16 =\r\ncvmx_mdio_read(phy_addr >> 8, phy_addr & 0xff,\r\nCVMX_MDIO_PHY_REG_AUTONEG_ADVER);\r\nreg_autoneg_adver.s.asymmetric_pause =\r\n(link_flags & set_phy_link_flags_flow_control_mask) ==\r\nset_phy_link_flags_flow_control_enable;\r\nreg_autoneg_adver.s.pause =\r\n(link_flags & set_phy_link_flags_flow_control_mask) ==\r\nset_phy_link_flags_flow_control_enable;\r\ncvmx_mdio_write(phy_addr >> 8, phy_addr & 0xff,\r\nCVMX_MDIO_PHY_REG_AUTONEG_ADVER,\r\nreg_autoneg_adver.u16);\r\n}\r\nif ((link_flags & set_phy_link_flags_autoneg)\r\n&& (link_info.s.speed == 0)) {\r\ncvmx_mdio_phy_reg_control_t reg_control;\r\ncvmx_mdio_phy_reg_status_t reg_status;\r\ncvmx_mdio_phy_reg_autoneg_adver_t reg_autoneg_adver;\r\ncvmx_mdio_phy_reg_extended_status_t reg_extended_status;\r\ncvmx_mdio_phy_reg_control_1000_t reg_control_1000;\r\nreg_status.u16 =\r\ncvmx_mdio_read(phy_addr >> 8, phy_addr & 0xff,\r\nCVMX_MDIO_PHY_REG_STATUS);\r\nreg_autoneg_adver.u16 =\r\ncvmx_mdio_read(phy_addr >> 8, phy_addr & 0xff,\r\nCVMX_MDIO_PHY_REG_AUTONEG_ADVER);\r\nreg_autoneg_adver.s.advert_100base_t4 =\r\nreg_status.s.capable_100base_t4;\r\nreg_autoneg_adver.s.advert_10base_tx_full =\r\nreg_status.s.capable_10_full;\r\nreg_autoneg_adver.s.advert_10base_tx_half =\r\nreg_status.s.capable_10_half;\r\nreg_autoneg_adver.s.advert_100base_tx_full =\r\nreg_status.s.capable_100base_x_full;\r\nreg_autoneg_adver.s.advert_100base_tx_half =\r\nreg_status.s.capable_100base_x_half;\r\ncvmx_mdio_write(phy_addr >> 8, phy_addr & 0xff,\r\nCVMX_MDIO_PHY_REG_AUTONEG_ADVER,\r\nreg_autoneg_adver.u16);\r\nif (reg_status.s.capable_extended_status) {\r\nreg_extended_status.u16 =\r\ncvmx_mdio_read(phy_addr >> 8, phy_addr & 0xff,\r\nCVMX_MDIO_PHY_REG_EXTENDED_STATUS);\r\nreg_control_1000.u16 =\r\ncvmx_mdio_read(phy_addr >> 8, phy_addr & 0xff,\r\nCVMX_MDIO_PHY_REG_CONTROL_1000);\r\nreg_control_1000.s.advert_1000base_t_full =\r\nreg_extended_status.s.capable_1000base_t_full;\r\nreg_control_1000.s.advert_1000base_t_half =\r\nreg_extended_status.s.capable_1000base_t_half;\r\ncvmx_mdio_write(phy_addr >> 8, phy_addr & 0xff,\r\nCVMX_MDIO_PHY_REG_CONTROL_1000,\r\nreg_control_1000.u16);\r\n}\r\nreg_control.u16 =\r\ncvmx_mdio_read(phy_addr >> 8, phy_addr & 0xff,\r\nCVMX_MDIO_PHY_REG_CONTROL);\r\nreg_control.s.autoneg_enable = 1;\r\nreg_control.s.restart_autoneg = 1;\r\ncvmx_mdio_write(phy_addr >> 8, phy_addr & 0xff,\r\nCVMX_MDIO_PHY_REG_CONTROL, reg_control.u16);\r\n} else if ((link_flags & set_phy_link_flags_autoneg)) {\r\ncvmx_mdio_phy_reg_control_t reg_control;\r\ncvmx_mdio_phy_reg_status_t reg_status;\r\ncvmx_mdio_phy_reg_autoneg_adver_t reg_autoneg_adver;\r\ncvmx_mdio_phy_reg_control_1000_t reg_control_1000;\r\nreg_status.u16 =\r\ncvmx_mdio_read(phy_addr >> 8, phy_addr & 0xff,\r\nCVMX_MDIO_PHY_REG_STATUS);\r\nreg_autoneg_adver.u16 =\r\ncvmx_mdio_read(phy_addr >> 8, phy_addr & 0xff,\r\nCVMX_MDIO_PHY_REG_AUTONEG_ADVER);\r\nreg_autoneg_adver.s.advert_100base_t4 = 0;\r\nreg_autoneg_adver.s.advert_10base_tx_full = 0;\r\nreg_autoneg_adver.s.advert_10base_tx_half = 0;\r\nreg_autoneg_adver.s.advert_100base_tx_full = 0;\r\nreg_autoneg_adver.s.advert_100base_tx_half = 0;\r\nif (reg_status.s.capable_extended_status) {\r\nreg_control_1000.u16 =\r\ncvmx_mdio_read(phy_addr >> 8, phy_addr & 0xff,\r\nCVMX_MDIO_PHY_REG_CONTROL_1000);\r\nreg_control_1000.s.advert_1000base_t_full = 0;\r\nreg_control_1000.s.advert_1000base_t_half = 0;\r\n}\r\nswitch (link_info.s.speed) {\r\ncase 10:\r\nreg_autoneg_adver.s.advert_10base_tx_full =\r\nlink_info.s.full_duplex;\r\nreg_autoneg_adver.s.advert_10base_tx_half =\r\n!link_info.s.full_duplex;\r\nbreak;\r\ncase 100:\r\nreg_autoneg_adver.s.advert_100base_tx_full =\r\nlink_info.s.full_duplex;\r\nreg_autoneg_adver.s.advert_100base_tx_half =\r\n!link_info.s.full_duplex;\r\nbreak;\r\ncase 1000:\r\nreg_control_1000.s.advert_1000base_t_full =\r\nlink_info.s.full_duplex;\r\nreg_control_1000.s.advert_1000base_t_half =\r\n!link_info.s.full_duplex;\r\nbreak;\r\n}\r\ncvmx_mdio_write(phy_addr >> 8, phy_addr & 0xff,\r\nCVMX_MDIO_PHY_REG_AUTONEG_ADVER,\r\nreg_autoneg_adver.u16);\r\nif (reg_status.s.capable_extended_status)\r\ncvmx_mdio_write(phy_addr >> 8, phy_addr & 0xff,\r\nCVMX_MDIO_PHY_REG_CONTROL_1000,\r\nreg_control_1000.u16);\r\nreg_control.u16 =\r\ncvmx_mdio_read(phy_addr >> 8, phy_addr & 0xff,\r\nCVMX_MDIO_PHY_REG_CONTROL);\r\nreg_control.s.autoneg_enable = 1;\r\nreg_control.s.restart_autoneg = 1;\r\ncvmx_mdio_write(phy_addr >> 8, phy_addr & 0xff,\r\nCVMX_MDIO_PHY_REG_CONTROL, reg_control.u16);\r\n} else {\r\ncvmx_mdio_phy_reg_control_t reg_control;\r\nreg_control.u16 =\r\ncvmx_mdio_read(phy_addr >> 8, phy_addr & 0xff,\r\nCVMX_MDIO_PHY_REG_CONTROL);\r\nreg_control.s.autoneg_enable = 0;\r\nreg_control.s.restart_autoneg = 1;\r\nreg_control.s.duplex = link_info.s.full_duplex;\r\nif (link_info.s.speed == 1000) {\r\nreg_control.s.speed_msb = 1;\r\nreg_control.s.speed_lsb = 0;\r\n} else if (link_info.s.speed == 100) {\r\nreg_control.s.speed_msb = 0;\r\nreg_control.s.speed_lsb = 1;\r\n} else if (link_info.s.speed == 10) {\r\nreg_control.s.speed_msb = 0;\r\nreg_control.s.speed_lsb = 0;\r\n}\r\ncvmx_mdio_write(phy_addr >> 8, phy_addr & 0xff,\r\nCVMX_MDIO_PHY_REG_CONTROL, reg_control.u16);\r\n}\r\nreturn 0;\r\n}\r\nint __cvmx_helper_board_interface_probe(int interface, int supported_ports)\r\n{\r\nswitch (cvmx_sysinfo_get()->board_type) {\r\ncase CVMX_BOARD_TYPE_CN3005_EVB_HS5:\r\nif (interface == 0)\r\nreturn 2;\r\nbreak;\r\ncase CVMX_BOARD_TYPE_BBGW_REF:\r\nif (interface == 0)\r\nreturn 2;\r\nbreak;\r\ncase CVMX_BOARD_TYPE_NIC_XLE_4G:\r\nif (interface == 0)\r\nreturn 0;\r\nbreak;\r\ncase CVMX_BOARD_TYPE_EBH5600:\r\nif (interface == 1)\r\nreturn 0;\r\nbreak;\r\n}\r\nreturn supported_ports;\r\n}\r\nint __cvmx_helper_board_hardware_enable(int interface)\r\n{\r\nif (cvmx_sysinfo_get()->board_type == CVMX_BOARD_TYPE_CN3005_EVB_HS5) {\r\nif (interface == 0) {\r\ncvmx_write_csr(CVMX_ASXX_TX_CLK_SETX(1, interface), 0);\r\ncvmx_write_csr(CVMX_ASXX_RX_CLK_SETX(1, interface), 0);\r\ncvmx_write_csr(CVMX_ASXX_TX_CLK_SETX(0, interface),\r\n0xc);\r\ncvmx_write_csr(CVMX_ASXX_RX_CLK_SETX(0, interface),\r\n0xc);\r\n}\r\n} else if (cvmx_sysinfo_get()->board_type ==\r\nCVMX_BOARD_TYPE_CN3010_EVB_HS5) {\r\nif (interface == 0) {\r\nint phy_addr = cvmx_helper_board_get_mii_address(0);\r\nif (phy_addr != -1) {\r\nint phy_identifier =\r\ncvmx_mdio_read(phy_addr >> 8,\r\nphy_addr & 0xff, 0x2);\r\nif (phy_identifier == 0x0143) {\r\ncvmx_dprintf("\n");\r\ncvmx_dprintf("ERROR:\n");\r\ncvmx_dprintf\r\n("ERROR: Board type is CVMX_BOARD_TYPE_CN3010_EVB_HS5, but Broadcom PHY found.\n");\r\ncvmx_dprintf\r\n("ERROR: The board type is mis-configured, and software malfunctions are likely.\n");\r\ncvmx_dprintf\r\n("ERROR: All boards require a unique board type to identify them.\n");\r\ncvmx_dprintf("ERROR:\n");\r\ncvmx_dprintf("\n");\r\ncvmx_wait(1000000000);\r\ncvmx_write_csr(CVMX_ASXX_RX_CLK_SETX\r\n(0, interface), 5);\r\ncvmx_write_csr(CVMX_ASXX_TX_CLK_SETX\r\n(0, interface), 5);\r\n}\r\n}\r\n}\r\n} else if (cvmx_sysinfo_get()->board_type ==\r\nCVMX_BOARD_TYPE_UBNT_E100) {\r\ncvmx_write_csr(CVMX_ASXX_RX_CLK_SETX(0, interface), 0);\r\ncvmx_write_csr(CVMX_ASXX_TX_CLK_SETX(0, interface), 0x10);\r\ncvmx_write_csr(CVMX_ASXX_RX_CLK_SETX(1, interface), 0);\r\ncvmx_write_csr(CVMX_ASXX_TX_CLK_SETX(1, interface), 0x10);\r\ncvmx_write_csr(CVMX_ASXX_RX_CLK_SETX(2, interface), 0);\r\ncvmx_write_csr(CVMX_ASXX_TX_CLK_SETX(2, interface), 0x10);\r\n}\r\nreturn 0;\r\n}\r\nenum cvmx_helper_board_usb_clock_types __cvmx_helper_board_usb_get_clock_type(void)\r\n{\r\nswitch (cvmx_sysinfo_get()->board_type) {\r\ncase CVMX_BOARD_TYPE_BBGW_REF:\r\ncase CVMX_BOARD_TYPE_LANAI2_A:\r\ncase CVMX_BOARD_TYPE_LANAI2_U:\r\ncase CVMX_BOARD_TYPE_LANAI2_G:\r\ncase CVMX_BOARD_TYPE_NIC10E_66:\r\ncase CVMX_BOARD_TYPE_UBNT_E100:\r\ncase CVMX_BOARD_TYPE_CUST_DSR1000N:\r\nreturn USB_CLOCK_TYPE_CRYSTAL_12;\r\ncase CVMX_BOARD_TYPE_NIC10E:\r\nreturn USB_CLOCK_TYPE_REF_12;\r\ndefault:\r\nbreak;\r\n}\r\nif (OCTEON_IS_OCTEON2())\r\nreturn USB_CLOCK_TYPE_CRYSTAL_12;\r\nreturn USB_CLOCK_TYPE_REF_48;\r\n}
