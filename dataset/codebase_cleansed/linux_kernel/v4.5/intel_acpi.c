static char *intel_dsm_port_name(u8 id)\r\n{\r\nswitch (id) {\r\ncase 0:\r\nreturn "Reserved";\r\ncase 1:\r\nreturn "Analog VGA";\r\ncase 2:\r\nreturn "LVDS";\r\ncase 3:\r\nreturn "Reserved";\r\ncase 4:\r\nreturn "HDMI/DVI_B";\r\ncase 5:\r\nreturn "HDMI/DVI_C";\r\ncase 6:\r\nreturn "HDMI/DVI_D";\r\ncase 7:\r\nreturn "DisplayPort_A";\r\ncase 8:\r\nreturn "DisplayPort_B";\r\ncase 9:\r\nreturn "DisplayPort_C";\r\ncase 0xa:\r\nreturn "DisplayPort_D";\r\ncase 0xb:\r\ncase 0xc:\r\ncase 0xd:\r\nreturn "Reserved";\r\ncase 0xe:\r\nreturn "WiDi";\r\ndefault:\r\nreturn "bad type";\r\n}\r\n}\r\nstatic char *intel_dsm_mux_type(u8 type)\r\n{\r\nswitch (type) {\r\ncase 0:\r\nreturn "unknown";\r\ncase 1:\r\nreturn "No MUX, iGPU only";\r\ncase 2:\r\nreturn "No MUX, dGPU only";\r\ncase 3:\r\nreturn "MUXed between iGPU and dGPU";\r\ndefault:\r\nreturn "bad type";\r\n}\r\n}\r\nstatic void intel_dsm_platform_mux_info(void)\r\n{\r\nint i;\r\nunion acpi_object *pkg, *connector_count;\r\npkg = acpi_evaluate_dsm_typed(intel_dsm_priv.dhandle, intel_dsm_guid,\r\nINTEL_DSM_REVISION_ID, INTEL_DSM_FN_PLATFORM_MUX_INFO,\r\nNULL, ACPI_TYPE_PACKAGE);\r\nif (!pkg) {\r\nDRM_DEBUG_DRIVER("failed to evaluate _DSM\n");\r\nreturn;\r\n}\r\nconnector_count = &pkg->package.elements[0];\r\nDRM_DEBUG_DRIVER("MUX info connectors: %lld\n",\r\n(unsigned long long)connector_count->integer.value);\r\nfor (i = 1; i < pkg->package.count; i++) {\r\nunion acpi_object *obj = &pkg->package.elements[i];\r\nunion acpi_object *connector_id = &obj->package.elements[0];\r\nunion acpi_object *info = &obj->package.elements[1];\r\nDRM_DEBUG_DRIVER("Connector id: 0x%016llx\n",\r\n(unsigned long long)connector_id->integer.value);\r\nDRM_DEBUG_DRIVER(" port id: %s\n",\r\nintel_dsm_port_name(info->buffer.pointer[0]));\r\nDRM_DEBUG_DRIVER(" display mux info: %s\n",\r\nintel_dsm_mux_type(info->buffer.pointer[1]));\r\nDRM_DEBUG_DRIVER(" aux/dc mux info: %s\n",\r\nintel_dsm_mux_type(info->buffer.pointer[2]));\r\nDRM_DEBUG_DRIVER(" hpd mux info: %s\n",\r\nintel_dsm_mux_type(info->buffer.pointer[3]));\r\n}\r\nACPI_FREE(pkg);\r\n}\r\nstatic bool intel_dsm_pci_probe(struct pci_dev *pdev)\r\n{\r\nacpi_handle dhandle;\r\ndhandle = ACPI_HANDLE(&pdev->dev);\r\nif (!dhandle)\r\nreturn false;\r\nif (!acpi_check_dsm(dhandle, intel_dsm_guid, INTEL_DSM_REVISION_ID,\r\n1 << INTEL_DSM_FN_PLATFORM_MUX_INFO)) {\r\nDRM_DEBUG_KMS("no _DSM method for intel device\n");\r\nreturn false;\r\n}\r\nintel_dsm_priv.dhandle = dhandle;\r\nintel_dsm_platform_mux_info();\r\nreturn true;\r\n}\r\nstatic bool intel_dsm_detect(void)\r\n{\r\nchar acpi_method_name[255] = { 0 };\r\nstruct acpi_buffer buffer = {sizeof(acpi_method_name), acpi_method_name};\r\nstruct pci_dev *pdev = NULL;\r\nbool has_dsm = false;\r\nint vga_count = 0;\r\nwhile ((pdev = pci_get_class(PCI_CLASS_DISPLAY_VGA << 8, pdev)) != NULL) {\r\nvga_count++;\r\nhas_dsm |= intel_dsm_pci_probe(pdev);\r\n}\r\nif (vga_count == 2 && has_dsm) {\r\nacpi_get_name(intel_dsm_priv.dhandle, ACPI_FULL_PATHNAME, &buffer);\r\nDRM_DEBUG_DRIVER("vga_switcheroo: detected DSM switching method %s handle\n",\r\nacpi_method_name);\r\nreturn true;\r\n}\r\nreturn false;\r\n}\r\nvoid intel_register_dsm_handler(void)\r\n{\r\nif (!intel_dsm_detect())\r\nreturn;\r\n}\r\nvoid intel_unregister_dsm_handler(void)\r\n{\r\n}
