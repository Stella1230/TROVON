static int ipv6_mc_check_ip6hdr(struct sk_buff *skb)\r\n{\r\nconst struct ipv6hdr *ip6h;\r\nunsigned int len;\r\nunsigned int offset = skb_network_offset(skb) + sizeof(*ip6h);\r\nif (!pskb_may_pull(skb, offset))\r\nreturn -EINVAL;\r\nip6h = ipv6_hdr(skb);\r\nif (ip6h->version != 6)\r\nreturn -EINVAL;\r\nlen = offset + ntohs(ip6h->payload_len);\r\nif (skb->len < len || len <= offset)\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\nstatic int ipv6_mc_check_exthdrs(struct sk_buff *skb)\r\n{\r\nconst struct ipv6hdr *ip6h;\r\nint offset;\r\nu8 nexthdr;\r\n__be16 frag_off;\r\nip6h = ipv6_hdr(skb);\r\nif (ip6h->nexthdr != IPPROTO_HOPOPTS)\r\nreturn -ENOMSG;\r\nnexthdr = ip6h->nexthdr;\r\noffset = skb_network_offset(skb) + sizeof(*ip6h);\r\noffset = ipv6_skip_exthdr(skb, offset, &nexthdr, &frag_off);\r\nif (offset < 0)\r\nreturn -EINVAL;\r\nif (nexthdr != IPPROTO_ICMPV6)\r\nreturn -ENOMSG;\r\nskb_set_transport_header(skb, offset);\r\nreturn 0;\r\n}\r\nstatic int ipv6_mc_check_mld_reportv2(struct sk_buff *skb)\r\n{\r\nunsigned int len = skb_transport_offset(skb);\r\nlen += sizeof(struct mld2_report);\r\nreturn pskb_may_pull(skb, len) ? 0 : -EINVAL;\r\n}\r\nstatic int ipv6_mc_check_mld_query(struct sk_buff *skb)\r\n{\r\nstruct mld_msg *mld;\r\nunsigned int len = skb_transport_offset(skb);\r\nif (!(ipv6_addr_type(&ipv6_hdr(skb)->saddr) & IPV6_ADDR_LINKLOCAL))\r\nreturn -EINVAL;\r\nlen += sizeof(struct mld_msg);\r\nif (skb->len < len)\r\nreturn -EINVAL;\r\nif (skb->len != len) {\r\nlen += sizeof(struct mld2_query) - sizeof(struct mld_msg);\r\nif (skb->len < len || !pskb_may_pull(skb, len))\r\nreturn -EINVAL;\r\n}\r\nmld = (struct mld_msg *)skb_transport_header(skb);\r\nif (ipv6_addr_any(&mld->mld_mca) &&\r\n!ipv6_addr_is_ll_all_nodes(&ipv6_hdr(skb)->daddr))\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\nstatic int ipv6_mc_check_mld_msg(struct sk_buff *skb)\r\n{\r\nstruct mld_msg *mld = (struct mld_msg *)skb_transport_header(skb);\r\nswitch (mld->mld_type) {\r\ncase ICMPV6_MGM_REDUCTION:\r\ncase ICMPV6_MGM_REPORT:\r\nreturn 0;\r\ncase ICMPV6_MLD2_REPORT:\r\nreturn ipv6_mc_check_mld_reportv2(skb);\r\ncase ICMPV6_MGM_QUERY:\r\nreturn ipv6_mc_check_mld_query(skb);\r\ndefault:\r\nreturn -ENOMSG;\r\n}\r\n}\r\nstatic inline __sum16 ipv6_mc_validate_checksum(struct sk_buff *skb)\r\n{\r\nreturn skb_checksum_validate(skb, IPPROTO_ICMPV6, ip6_compute_pseudo);\r\n}\r\nstatic int __ipv6_mc_check_mld(struct sk_buff *skb,\r\nstruct sk_buff **skb_trimmed)\r\n{\r\nstruct sk_buff *skb_chk = NULL;\r\nunsigned int transport_len;\r\nunsigned int len = skb_transport_offset(skb) + sizeof(struct mld_msg);\r\nint ret = -EINVAL;\r\ntransport_len = ntohs(ipv6_hdr(skb)->payload_len);\r\ntransport_len -= skb_transport_offset(skb) - sizeof(struct ipv6hdr);\r\nskb_chk = skb_checksum_trimmed(skb, transport_len,\r\nipv6_mc_validate_checksum);\r\nif (!skb_chk)\r\ngoto err;\r\nif (!pskb_may_pull(skb_chk, len))\r\ngoto err;\r\nret = ipv6_mc_check_mld_msg(skb_chk);\r\nif (ret)\r\ngoto err;\r\nif (skb_trimmed)\r\n*skb_trimmed = skb_chk;\r\nelse if (skb_chk != skb)\r\nkfree_skb(skb_chk);\r\nret = 0;\r\nerr:\r\nif (ret && skb_chk && skb_chk != skb)\r\nkfree_skb(skb_chk);\r\nreturn ret;\r\n}\r\nint ipv6_mc_check_mld(struct sk_buff *skb, struct sk_buff **skb_trimmed)\r\n{\r\nint ret;\r\nret = ipv6_mc_check_ip6hdr(skb);\r\nif (ret < 0)\r\nreturn ret;\r\nret = ipv6_mc_check_exthdrs(skb);\r\nif (ret < 0)\r\nreturn ret;\r\nreturn __ipv6_mc_check_mld(skb, skb_trimmed);\r\n}
