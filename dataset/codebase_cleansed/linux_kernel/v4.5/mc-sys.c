int __must_check fsl_create_mc_io(struct device *dev,\r\nphys_addr_t mc_portal_phys_addr,\r\nu32 mc_portal_size,\r\nstruct fsl_mc_device *dpmcp_dev,\r\nu32 flags, struct fsl_mc_io **new_mc_io)\r\n{\r\nint error;\r\nstruct fsl_mc_io *mc_io;\r\nvoid __iomem *mc_portal_virt_addr;\r\nstruct resource *res;\r\nmc_io = devm_kzalloc(dev, sizeof(*mc_io), GFP_KERNEL);\r\nif (!mc_io)\r\nreturn -ENOMEM;\r\nmc_io->dev = dev;\r\nmc_io->flags = flags;\r\nmc_io->portal_phys_addr = mc_portal_phys_addr;\r\nmc_io->portal_size = mc_portal_size;\r\nif (flags & FSL_MC_IO_ATOMIC_CONTEXT_PORTAL)\r\nspin_lock_init(&mc_io->spinlock);\r\nelse\r\nmutex_init(&mc_io->mutex);\r\nres = devm_request_mem_region(dev,\r\nmc_portal_phys_addr,\r\nmc_portal_size,\r\n"mc_portal");\r\nif (!res) {\r\ndev_err(dev,\r\n"devm_request_mem_region failed for MC portal %#llx\n",\r\nmc_portal_phys_addr);\r\nreturn -EBUSY;\r\n}\r\nmc_portal_virt_addr = devm_ioremap_nocache(dev,\r\nmc_portal_phys_addr,\r\nmc_portal_size);\r\nif (!mc_portal_virt_addr) {\r\ndev_err(dev,\r\n"devm_ioremap_nocache failed for MC portal %#llx\n",\r\nmc_portal_phys_addr);\r\nreturn -ENXIO;\r\n}\r\nmc_io->portal_virt_addr = mc_portal_virt_addr;\r\nif (dpmcp_dev) {\r\nerror = fsl_mc_io_set_dpmcp(mc_io, dpmcp_dev);\r\nif (error < 0)\r\ngoto error_destroy_mc_io;\r\n}\r\n*new_mc_io = mc_io;\r\nreturn 0;\r\nerror_destroy_mc_io:\r\nfsl_destroy_mc_io(mc_io);\r\nreturn error;\r\n}\r\nvoid fsl_destroy_mc_io(struct fsl_mc_io *mc_io)\r\n{\r\nstruct fsl_mc_device *dpmcp_dev = mc_io->dpmcp_dev;\r\nif (dpmcp_dev)\r\nfsl_mc_io_unset_dpmcp(mc_io);\r\ndevm_iounmap(mc_io->dev, mc_io->portal_virt_addr);\r\ndevm_release_mem_region(mc_io->dev,\r\nmc_io->portal_phys_addr,\r\nmc_io->portal_size);\r\nmc_io->portal_virt_addr = NULL;\r\ndevm_kfree(mc_io->dev, mc_io);\r\n}\r\nint fsl_mc_io_set_dpmcp(struct fsl_mc_io *mc_io,\r\nstruct fsl_mc_device *dpmcp_dev)\r\n{\r\nint error;\r\nif (WARN_ON(!dpmcp_dev))\r\nreturn -EINVAL;\r\nif (WARN_ON(mc_io->dpmcp_dev))\r\nreturn -EINVAL;\r\nif (WARN_ON(dpmcp_dev->mc_io))\r\nreturn -EINVAL;\r\nerror = dpmcp_open(mc_io,\r\n0,\r\ndpmcp_dev->obj_desc.id,\r\n&dpmcp_dev->mc_handle);\r\nif (error < 0)\r\nreturn error;\r\nmc_io->dpmcp_dev = dpmcp_dev;\r\ndpmcp_dev->mc_io = mc_io;\r\nreturn 0;\r\n}\r\nvoid fsl_mc_io_unset_dpmcp(struct fsl_mc_io *mc_io)\r\n{\r\nint error;\r\nstruct fsl_mc_device *dpmcp_dev = mc_io->dpmcp_dev;\r\nif (WARN_ON(!dpmcp_dev))\r\nreturn;\r\nif (WARN_ON(dpmcp_dev->mc_io != mc_io))\r\nreturn;\r\nerror = dpmcp_close(mc_io,\r\n0,\r\ndpmcp_dev->mc_handle);\r\nif (error < 0) {\r\ndev_err(&dpmcp_dev->dev, "dpmcp_close() failed: %d\n",\r\nerror);\r\n}\r\nmc_io->dpmcp_dev = NULL;\r\ndpmcp_dev->mc_io = NULL;\r\n}\r\nstatic int mc_status_to_error(enum mc_cmd_status status)\r\n{\r\nstatic const int mc_status_to_error_map[] = {\r\n[MC_CMD_STATUS_OK] = 0,\r\n[MC_CMD_STATUS_AUTH_ERR] = -EACCES,\r\n[MC_CMD_STATUS_NO_PRIVILEGE] = -EPERM,\r\n[MC_CMD_STATUS_DMA_ERR] = -EIO,\r\n[MC_CMD_STATUS_CONFIG_ERR] = -ENXIO,\r\n[MC_CMD_STATUS_TIMEOUT] = -ETIMEDOUT,\r\n[MC_CMD_STATUS_NO_RESOURCE] = -ENAVAIL,\r\n[MC_CMD_STATUS_NO_MEMORY] = -ENOMEM,\r\n[MC_CMD_STATUS_BUSY] = -EBUSY,\r\n[MC_CMD_STATUS_UNSUPPORTED_OP] = -ENOTSUPP,\r\n[MC_CMD_STATUS_INVALID_STATE] = -ENODEV,\r\n};\r\nif (WARN_ON((u32)status >= ARRAY_SIZE(mc_status_to_error_map)))\r\nreturn -EINVAL;\r\nreturn mc_status_to_error_map[status];\r\n}\r\nstatic const char *mc_status_to_string(enum mc_cmd_status status)\r\n{\r\nstatic const char *const status_strings[] = {\r\n[MC_CMD_STATUS_OK] = "Command completed successfully",\r\n[MC_CMD_STATUS_READY] = "Command ready to be processed",\r\n[MC_CMD_STATUS_AUTH_ERR] = "Authentication error",\r\n[MC_CMD_STATUS_NO_PRIVILEGE] = "No privilege",\r\n[MC_CMD_STATUS_DMA_ERR] = "DMA or I/O error",\r\n[MC_CMD_STATUS_CONFIG_ERR] = "Configuration error",\r\n[MC_CMD_STATUS_TIMEOUT] = "Operation timed out",\r\n[MC_CMD_STATUS_NO_RESOURCE] = "No resources",\r\n[MC_CMD_STATUS_NO_MEMORY] = "No memory available",\r\n[MC_CMD_STATUS_BUSY] = "Device is busy",\r\n[MC_CMD_STATUS_UNSUPPORTED_OP] = "Unsupported operation",\r\n[MC_CMD_STATUS_INVALID_STATE] = "Invalid state"\r\n};\r\nif ((unsigned int)status >= ARRAY_SIZE(status_strings))\r\nreturn "Unknown MC error";\r\nreturn status_strings[status];\r\n}\r\nstatic inline void mc_write_command(struct mc_command __iomem *portal,\r\nstruct mc_command *cmd)\r\n{\r\nint i;\r\nfor (i = 0; i < MC_CMD_NUM_OF_PARAMS; i++)\r\nwriteq(cmd->params[i], &portal->params[i]);\r\nwriteq(cmd->header, &portal->header);\r\n}\r\nstatic inline enum mc_cmd_status mc_read_response(struct mc_command __iomem *\r\nportal,\r\nstruct mc_command *resp)\r\n{\r\nint i;\r\nenum mc_cmd_status status;\r\nresp->header = readq(&portal->header);\r\nstatus = MC_CMD_HDR_READ_STATUS(resp->header);\r\nif (status != MC_CMD_STATUS_OK)\r\nreturn status;\r\nfor (i = 0; i < MC_CMD_NUM_OF_PARAMS; i++)\r\nresp->params[i] = readq(&portal->params[i]);\r\nreturn status;\r\n}\r\nstatic int mc_polling_wait_preemptible(struct fsl_mc_io *mc_io,\r\nstruct mc_command *cmd,\r\nenum mc_cmd_status *mc_status)\r\n{\r\nenum mc_cmd_status status;\r\nunsigned long jiffies_until_timeout =\r\njiffies + msecs_to_jiffies(MC_CMD_COMPLETION_TIMEOUT_MS);\r\nfor (;;) {\r\nstatus = mc_read_response(mc_io->portal_virt_addr, cmd);\r\nif (status != MC_CMD_STATUS_READY)\r\nbreak;\r\nusleep_range(MC_CMD_COMPLETION_POLLING_MIN_SLEEP_USECS,\r\nMC_CMD_COMPLETION_POLLING_MAX_SLEEP_USECS);\r\nif (time_after_eq(jiffies, jiffies_until_timeout)) {\r\npr_debug("MC command timed out (portal: %#llx, obj handle: %#x, command: %#x)\n",\r\nmc_io->portal_phys_addr,\r\n(unsigned int)\r\nMC_CMD_HDR_READ_TOKEN(cmd->header),\r\n(unsigned int)\r\nMC_CMD_HDR_READ_CMDID(cmd->header));\r\nreturn -ETIMEDOUT;\r\n}\r\n}\r\n*mc_status = status;\r\nreturn 0;\r\n}\r\nstatic int mc_polling_wait_atomic(struct fsl_mc_io *mc_io,\r\nstruct mc_command *cmd,\r\nenum mc_cmd_status *mc_status)\r\n{\r\nenum mc_cmd_status status;\r\nunsigned long timeout_usecs = MC_CMD_COMPLETION_TIMEOUT_MS * 1000;\r\nBUILD_BUG_ON((MC_CMD_COMPLETION_TIMEOUT_MS * 1000) %\r\nMC_CMD_COMPLETION_POLLING_MAX_SLEEP_USECS != 0);\r\nfor (;;) {\r\nstatus = mc_read_response(mc_io->portal_virt_addr, cmd);\r\nif (status != MC_CMD_STATUS_READY)\r\nbreak;\r\nudelay(MC_CMD_COMPLETION_POLLING_MAX_SLEEP_USECS);\r\ntimeout_usecs -= MC_CMD_COMPLETION_POLLING_MAX_SLEEP_USECS;\r\nif (timeout_usecs == 0) {\r\npr_debug("MC command timed out (portal: %#llx, obj handle: %#x, command: %#x)\n",\r\nmc_io->portal_phys_addr,\r\n(unsigned int)\r\nMC_CMD_HDR_READ_TOKEN(cmd->header),\r\n(unsigned int)\r\nMC_CMD_HDR_READ_CMDID(cmd->header));\r\nreturn -ETIMEDOUT;\r\n}\r\n}\r\n*mc_status = status;\r\nreturn 0;\r\n}\r\nint mc_send_command(struct fsl_mc_io *mc_io, struct mc_command *cmd)\r\n{\r\nint error;\r\nenum mc_cmd_status status;\r\nunsigned long irq_flags = 0;\r\nif (WARN_ON(in_irq() &&\r\n!(mc_io->flags & FSL_MC_IO_ATOMIC_CONTEXT_PORTAL)))\r\nreturn -EINVAL;\r\nif (mc_io->flags & FSL_MC_IO_ATOMIC_CONTEXT_PORTAL)\r\nspin_lock_irqsave(&mc_io->spinlock, irq_flags);\r\nelse\r\nmutex_lock(&mc_io->mutex);\r\nmc_write_command(mc_io->portal_virt_addr, cmd);\r\nif (!(mc_io->flags & FSL_MC_IO_ATOMIC_CONTEXT_PORTAL))\r\nerror = mc_polling_wait_preemptible(mc_io, cmd, &status);\r\nelse\r\nerror = mc_polling_wait_atomic(mc_io, cmd, &status);\r\nif (error < 0)\r\ngoto common_exit;\r\nif (status != MC_CMD_STATUS_OK) {\r\npr_debug("MC command failed: portal: %#llx, obj handle: %#x, command: %#x, status: %s (%#x)\n",\r\nmc_io->portal_phys_addr,\r\n(unsigned int)MC_CMD_HDR_READ_TOKEN(cmd->header),\r\n(unsigned int)MC_CMD_HDR_READ_CMDID(cmd->header),\r\nmc_status_to_string(status),\r\n(unsigned int)status);\r\nerror = mc_status_to_error(status);\r\ngoto common_exit;\r\n}\r\nerror = 0;\r\ncommon_exit:\r\nif (mc_io->flags & FSL_MC_IO_ATOMIC_CONTEXT_PORTAL)\r\nspin_unlock_irqrestore(&mc_io->spinlock, irq_flags);\r\nelse\r\nmutex_unlock(&mc_io->mutex);\r\nreturn error;\r\n}
