static int rockchip_efuse_write(void *context, const void *data, size_t count)\r\n{\r\nreturn 0;\r\n}\r\nstatic int rockchip_efuse_read(void *context,\r\nconst void *reg, size_t reg_size,\r\nvoid *val, size_t val_size)\r\n{\r\nunsigned int offset = *(u32 *)reg;\r\nstruct rockchip_efuse_context *_context = context;\r\nvoid __iomem *base = _context->base;\r\nstruct clk *clk = _context->efuse_clk;\r\nu8 *buf = val;\r\nint ret;\r\nret = clk_prepare_enable(clk);\r\nif (ret < 0) {\r\ndev_err(_context->dev, "failed to prepare/enable efuse clk\n");\r\nreturn ret;\r\n}\r\nwritel(EFUSE_LOAD | EFUSE_PGENB, base + REG_EFUSE_CTRL);\r\nudelay(1);\r\nwhile (val_size) {\r\nwritel(readl(base + REG_EFUSE_CTRL) &\r\n(~(EFUSE_A_MASK << EFUSE_A_SHIFT)),\r\nbase + REG_EFUSE_CTRL);\r\nwritel(readl(base + REG_EFUSE_CTRL) |\r\n((offset & EFUSE_A_MASK) << EFUSE_A_SHIFT),\r\nbase + REG_EFUSE_CTRL);\r\nudelay(1);\r\nwritel(readl(base + REG_EFUSE_CTRL) |\r\nEFUSE_STROBE, base + REG_EFUSE_CTRL);\r\nudelay(1);\r\n*buf++ = readb(base + REG_EFUSE_DOUT);\r\nwritel(readl(base + REG_EFUSE_CTRL) &\r\n(~EFUSE_STROBE), base + REG_EFUSE_CTRL);\r\nudelay(1);\r\nval_size -= 1;\r\noffset += 1;\r\n}\r\nwritel(EFUSE_PGENB | EFUSE_CSB, base + REG_EFUSE_CTRL);\r\nclk_disable_unprepare(clk);\r\nreturn 0;\r\n}\r\nstatic int rockchip_efuse_probe(struct platform_device *pdev)\r\n{\r\nstruct device *dev = &pdev->dev;\r\nstruct resource *res;\r\nstruct nvmem_device *nvmem;\r\nstruct regmap *regmap;\r\nvoid __iomem *base;\r\nstruct clk *clk;\r\nstruct rockchip_efuse_context *context;\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nbase = devm_ioremap_resource(dev, res);\r\nif (IS_ERR(base))\r\nreturn PTR_ERR(base);\r\ncontext = devm_kzalloc(dev, sizeof(struct rockchip_efuse_context),\r\nGFP_KERNEL);\r\nif (IS_ERR(context))\r\nreturn PTR_ERR(context);\r\nclk = devm_clk_get(dev, "pclk_efuse");\r\nif (IS_ERR(clk))\r\nreturn PTR_ERR(clk);\r\ncontext->dev = dev;\r\ncontext->base = base;\r\ncontext->efuse_clk = clk;\r\nrockchip_efuse_regmap_config.max_register = resource_size(res) - 1;\r\nregmap = devm_regmap_init(dev, &rockchip_efuse_bus,\r\ncontext, &rockchip_efuse_regmap_config);\r\nif (IS_ERR(regmap)) {\r\ndev_err(dev, "regmap init failed\n");\r\nreturn PTR_ERR(regmap);\r\n}\r\neconfig.dev = dev;\r\nnvmem = nvmem_register(&econfig);\r\nif (IS_ERR(nvmem))\r\nreturn PTR_ERR(nvmem);\r\nplatform_set_drvdata(pdev, nvmem);\r\nreturn 0;\r\n}\r\nstatic int rockchip_efuse_remove(struct platform_device *pdev)\r\n{\r\nstruct nvmem_device *nvmem = platform_get_drvdata(pdev);\r\nreturn nvmem_unregister(nvmem);\r\n}
