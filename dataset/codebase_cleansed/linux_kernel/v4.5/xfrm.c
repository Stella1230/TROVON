static inline int selinux_authorizable_ctx(struct xfrm_sec_ctx *ctx)\r\n{\r\nreturn (ctx &&\r\n(ctx->ctx_doi == XFRM_SC_DOI_LSM) &&\r\n(ctx->ctx_alg == XFRM_SC_ALG_SELINUX));\r\n}\r\nstatic inline int selinux_authorizable_xfrm(struct xfrm_state *x)\r\n{\r\nreturn selinux_authorizable_ctx(x->security);\r\n}\r\nstatic int selinux_xfrm_alloc_user(struct xfrm_sec_ctx **ctxp,\r\nstruct xfrm_user_sec_ctx *uctx,\r\ngfp_t gfp)\r\n{\r\nint rc;\r\nconst struct task_security_struct *tsec = current_security();\r\nstruct xfrm_sec_ctx *ctx = NULL;\r\nu32 str_len;\r\nif (ctxp == NULL || uctx == NULL ||\r\nuctx->ctx_doi != XFRM_SC_DOI_LSM ||\r\nuctx->ctx_alg != XFRM_SC_ALG_SELINUX)\r\nreturn -EINVAL;\r\nstr_len = uctx->ctx_len;\r\nif (str_len >= PAGE_SIZE)\r\nreturn -ENOMEM;\r\nctx = kmalloc(sizeof(*ctx) + str_len + 1, gfp);\r\nif (!ctx)\r\nreturn -ENOMEM;\r\nctx->ctx_doi = XFRM_SC_DOI_LSM;\r\nctx->ctx_alg = XFRM_SC_ALG_SELINUX;\r\nctx->ctx_len = str_len;\r\nmemcpy(ctx->ctx_str, &uctx[1], str_len);\r\nctx->ctx_str[str_len] = '\0';\r\nrc = security_context_to_sid(ctx->ctx_str, str_len, &ctx->ctx_sid, gfp);\r\nif (rc)\r\ngoto err;\r\nrc = avc_has_perm(tsec->sid, ctx->ctx_sid,\r\nSECCLASS_ASSOCIATION, ASSOCIATION__SETCONTEXT, NULL);\r\nif (rc)\r\ngoto err;\r\n*ctxp = ctx;\r\natomic_inc(&selinux_xfrm_refcount);\r\nreturn 0;\r\nerr:\r\nkfree(ctx);\r\nreturn rc;\r\n}\r\nstatic void selinux_xfrm_free(struct xfrm_sec_ctx *ctx)\r\n{\r\nif (!ctx)\r\nreturn;\r\natomic_dec(&selinux_xfrm_refcount);\r\nkfree(ctx);\r\n}\r\nstatic int selinux_xfrm_delete(struct xfrm_sec_ctx *ctx)\r\n{\r\nconst struct task_security_struct *tsec = current_security();\r\nif (!ctx)\r\nreturn 0;\r\nreturn avc_has_perm(tsec->sid, ctx->ctx_sid,\r\nSECCLASS_ASSOCIATION, ASSOCIATION__SETCONTEXT,\r\nNULL);\r\n}\r\nint selinux_xfrm_policy_lookup(struct xfrm_sec_ctx *ctx, u32 fl_secid, u8 dir)\r\n{\r\nint rc;\r\nif (!ctx)\r\nreturn 0;\r\nif (!selinux_authorizable_ctx(ctx))\r\nreturn -EINVAL;\r\nrc = avc_has_perm(fl_secid, ctx->ctx_sid,\r\nSECCLASS_ASSOCIATION, ASSOCIATION__POLMATCH, NULL);\r\nreturn (rc == -EACCES ? -ESRCH : rc);\r\n}\r\nint selinux_xfrm_state_pol_flow_match(struct xfrm_state *x,\r\nstruct xfrm_policy *xp,\r\nconst struct flowi *fl)\r\n{\r\nu32 state_sid;\r\nif (!xp->security)\r\nif (x->security)\r\nreturn 0;\r\nelse\r\nreturn 1;\r\nelse\r\nif (!x->security)\r\nreturn 0;\r\nelse\r\nif (!selinux_authorizable_xfrm(x))\r\nreturn 0;\r\nstate_sid = x->security->ctx_sid;\r\nif (fl->flowi_secid != state_sid)\r\nreturn 0;\r\nreturn (avc_has_perm(fl->flowi_secid, state_sid,\r\nSECCLASS_ASSOCIATION, ASSOCIATION__SENDTO,\r\nNULL) ? 0 : 1);\r\n}\r\nstatic u32 selinux_xfrm_skb_sid_egress(struct sk_buff *skb)\r\n{\r\nstruct dst_entry *dst = skb_dst(skb);\r\nstruct xfrm_state *x;\r\nif (dst == NULL)\r\nreturn SECSID_NULL;\r\nx = dst->xfrm;\r\nif (x == NULL || !selinux_authorizable_xfrm(x))\r\nreturn SECSID_NULL;\r\nreturn x->security->ctx_sid;\r\n}\r\nstatic int selinux_xfrm_skb_sid_ingress(struct sk_buff *skb,\r\nu32 *sid, int ckall)\r\n{\r\nu32 sid_session = SECSID_NULL;\r\nstruct sec_path *sp = skb->sp;\r\nif (sp) {\r\nint i;\r\nfor (i = sp->len - 1; i >= 0; i--) {\r\nstruct xfrm_state *x = sp->xvec[i];\r\nif (selinux_authorizable_xfrm(x)) {\r\nstruct xfrm_sec_ctx *ctx = x->security;\r\nif (sid_session == SECSID_NULL) {\r\nsid_session = ctx->ctx_sid;\r\nif (!ckall)\r\ngoto out;\r\n} else if (sid_session != ctx->ctx_sid) {\r\n*sid = SECSID_NULL;\r\nreturn -EINVAL;\r\n}\r\n}\r\n}\r\n}\r\nout:\r\n*sid = sid_session;\r\nreturn 0;\r\n}\r\nint selinux_xfrm_decode_session(struct sk_buff *skb, u32 *sid, int ckall)\r\n{\r\nif (skb == NULL) {\r\n*sid = SECSID_NULL;\r\nreturn 0;\r\n}\r\nreturn selinux_xfrm_skb_sid_ingress(skb, sid, ckall);\r\n}\r\nint selinux_xfrm_skb_sid(struct sk_buff *skb, u32 *sid)\r\n{\r\nint rc;\r\nrc = selinux_xfrm_skb_sid_ingress(skb, sid, 0);\r\nif (rc == 0 && *sid == SECSID_NULL)\r\n*sid = selinux_xfrm_skb_sid_egress(skb);\r\nreturn rc;\r\n}\r\nint selinux_xfrm_policy_alloc(struct xfrm_sec_ctx **ctxp,\r\nstruct xfrm_user_sec_ctx *uctx,\r\ngfp_t gfp)\r\n{\r\nreturn selinux_xfrm_alloc_user(ctxp, uctx, gfp);\r\n}\r\nint selinux_xfrm_policy_clone(struct xfrm_sec_ctx *old_ctx,\r\nstruct xfrm_sec_ctx **new_ctxp)\r\n{\r\nstruct xfrm_sec_ctx *new_ctx;\r\nif (!old_ctx)\r\nreturn 0;\r\nnew_ctx = kmemdup(old_ctx, sizeof(*old_ctx) + old_ctx->ctx_len,\r\nGFP_ATOMIC);\r\nif (!new_ctx)\r\nreturn -ENOMEM;\r\natomic_inc(&selinux_xfrm_refcount);\r\n*new_ctxp = new_ctx;\r\nreturn 0;\r\n}\r\nvoid selinux_xfrm_policy_free(struct xfrm_sec_ctx *ctx)\r\n{\r\nselinux_xfrm_free(ctx);\r\n}\r\nint selinux_xfrm_policy_delete(struct xfrm_sec_ctx *ctx)\r\n{\r\nreturn selinux_xfrm_delete(ctx);\r\n}\r\nint selinux_xfrm_state_alloc(struct xfrm_state *x,\r\nstruct xfrm_user_sec_ctx *uctx)\r\n{\r\nreturn selinux_xfrm_alloc_user(&x->security, uctx, GFP_KERNEL);\r\n}\r\nint selinux_xfrm_state_alloc_acquire(struct xfrm_state *x,\r\nstruct xfrm_sec_ctx *polsec, u32 secid)\r\n{\r\nint rc;\r\nstruct xfrm_sec_ctx *ctx;\r\nchar *ctx_str = NULL;\r\nint str_len;\r\nif (!polsec)\r\nreturn 0;\r\nif (secid == 0)\r\nreturn -EINVAL;\r\nrc = security_sid_to_context(secid, &ctx_str, &str_len);\r\nif (rc)\r\nreturn rc;\r\nctx = kmalloc(sizeof(*ctx) + str_len, GFP_ATOMIC);\r\nif (!ctx) {\r\nrc = -ENOMEM;\r\ngoto out;\r\n}\r\nctx->ctx_doi = XFRM_SC_DOI_LSM;\r\nctx->ctx_alg = XFRM_SC_ALG_SELINUX;\r\nctx->ctx_sid = secid;\r\nctx->ctx_len = str_len;\r\nmemcpy(ctx->ctx_str, ctx_str, str_len);\r\nx->security = ctx;\r\natomic_inc(&selinux_xfrm_refcount);\r\nout:\r\nkfree(ctx_str);\r\nreturn rc;\r\n}\r\nvoid selinux_xfrm_state_free(struct xfrm_state *x)\r\n{\r\nselinux_xfrm_free(x->security);\r\n}\r\nint selinux_xfrm_state_delete(struct xfrm_state *x)\r\n{\r\nreturn selinux_xfrm_delete(x->security);\r\n}\r\nint selinux_xfrm_sock_rcv_skb(u32 sk_sid, struct sk_buff *skb,\r\nstruct common_audit_data *ad)\r\n{\r\nint i;\r\nstruct sec_path *sp = skb->sp;\r\nu32 peer_sid = SECINITSID_UNLABELED;\r\nif (sp) {\r\nfor (i = 0; i < sp->len; i++) {\r\nstruct xfrm_state *x = sp->xvec[i];\r\nif (x && selinux_authorizable_xfrm(x)) {\r\nstruct xfrm_sec_ctx *ctx = x->security;\r\npeer_sid = ctx->ctx_sid;\r\nbreak;\r\n}\r\n}\r\n}\r\nreturn avc_has_perm(sk_sid, peer_sid,\r\nSECCLASS_ASSOCIATION, ASSOCIATION__RECVFROM, ad);\r\n}\r\nint selinux_xfrm_postroute_last(u32 sk_sid, struct sk_buff *skb,\r\nstruct common_audit_data *ad, u8 proto)\r\n{\r\nstruct dst_entry *dst;\r\nswitch (proto) {\r\ncase IPPROTO_AH:\r\ncase IPPROTO_ESP:\r\ncase IPPROTO_COMP:\r\nreturn 0;\r\ndefault:\r\nbreak;\r\n}\r\ndst = skb_dst(skb);\r\nif (dst) {\r\nstruct dst_entry *iter;\r\nfor (iter = dst; iter != NULL; iter = iter->child) {\r\nstruct xfrm_state *x = iter->xfrm;\r\nif (x && selinux_authorizable_xfrm(x))\r\nreturn 0;\r\n}\r\n}\r\nreturn avc_has_perm(sk_sid, SECINITSID_UNLABELED,\r\nSECCLASS_ASSOCIATION, ASSOCIATION__SENDTO, ad);\r\n}
