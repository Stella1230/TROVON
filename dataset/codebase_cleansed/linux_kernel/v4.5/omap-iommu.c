static struct omap_iommu_domain *to_omap_domain(struct iommu_domain *dom)\r\n{\r\nreturn container_of(dom, struct omap_iommu_domain, domain);\r\n}\r\nvoid omap_iommu_save_ctx(struct device *dev)\r\n{\r\nstruct omap_iommu *obj = dev_to_omap_iommu(dev);\r\nu32 *p = obj->ctx;\r\nint i;\r\nfor (i = 0; i < (MMU_REG_SIZE / sizeof(u32)); i++) {\r\np[i] = iommu_read_reg(obj, i * sizeof(u32));\r\ndev_dbg(obj->dev, "%s\t[%02d] %08x\n", __func__, i, p[i]);\r\n}\r\n}\r\nvoid omap_iommu_restore_ctx(struct device *dev)\r\n{\r\nstruct omap_iommu *obj = dev_to_omap_iommu(dev);\r\nu32 *p = obj->ctx;\r\nint i;\r\nfor (i = 0; i < (MMU_REG_SIZE / sizeof(u32)); i++) {\r\niommu_write_reg(obj, p[i], i * sizeof(u32));\r\ndev_dbg(obj->dev, "%s\t[%02d] %08x\n", __func__, i, p[i]);\r\n}\r\n}\r\nstatic void dra7_cfg_dspsys_mmu(struct omap_iommu *obj, bool enable)\r\n{\r\nu32 val, mask;\r\nif (!obj->syscfg)\r\nreturn;\r\nmask = (1 << (obj->id * DSP_SYS_MMU_CONFIG_EN_SHIFT));\r\nval = enable ? mask : 0;\r\nregmap_update_bits(obj->syscfg, DSP_SYS_MMU_CONFIG, mask, val);\r\n}\r\nstatic void __iommu_set_twl(struct omap_iommu *obj, bool on)\r\n{\r\nu32 l = iommu_read_reg(obj, MMU_CNTL);\r\nif (on)\r\niommu_write_reg(obj, MMU_IRQ_TWL_MASK, MMU_IRQENABLE);\r\nelse\r\niommu_write_reg(obj, MMU_IRQ_TLB_MISS_MASK, MMU_IRQENABLE);\r\nl &= ~MMU_CNTL_MASK;\r\nif (on)\r\nl |= (MMU_CNTL_MMU_EN | MMU_CNTL_TWL_EN);\r\nelse\r\nl |= (MMU_CNTL_MMU_EN);\r\niommu_write_reg(obj, l, MMU_CNTL);\r\n}\r\nstatic int omap2_iommu_enable(struct omap_iommu *obj)\r\n{\r\nu32 l, pa;\r\nif (!obj->iopgd || !IS_ALIGNED((u32)obj->iopgd, SZ_16K))\r\nreturn -EINVAL;\r\npa = virt_to_phys(obj->iopgd);\r\nif (!IS_ALIGNED(pa, SZ_16K))\r\nreturn -EINVAL;\r\nl = iommu_read_reg(obj, MMU_REVISION);\r\ndev_info(obj->dev, "%s: version %d.%d\n", obj->name,\r\n(l >> 4) & 0xf, l & 0xf);\r\niommu_write_reg(obj, pa, MMU_TTB);\r\ndra7_cfg_dspsys_mmu(obj, true);\r\nif (obj->has_bus_err_back)\r\niommu_write_reg(obj, MMU_GP_REG_BUS_ERR_BACK_EN, MMU_GP_REG);\r\n__iommu_set_twl(obj, true);\r\nreturn 0;\r\n}\r\nstatic void omap2_iommu_disable(struct omap_iommu *obj)\r\n{\r\nu32 l = iommu_read_reg(obj, MMU_CNTL);\r\nl &= ~MMU_CNTL_MASK;\r\niommu_write_reg(obj, l, MMU_CNTL);\r\ndra7_cfg_dspsys_mmu(obj, false);\r\ndev_dbg(obj->dev, "%s is shutting down\n", obj->name);\r\n}\r\nstatic int iommu_enable(struct omap_iommu *obj)\r\n{\r\nint err;\r\nstruct platform_device *pdev = to_platform_device(obj->dev);\r\nstruct iommu_platform_data *pdata = dev_get_platdata(&pdev->dev);\r\nif (pdata && pdata->deassert_reset) {\r\nerr = pdata->deassert_reset(pdev, pdata->reset_name);\r\nif (err) {\r\ndev_err(obj->dev, "deassert_reset failed: %d\n", err);\r\nreturn err;\r\n}\r\n}\r\npm_runtime_get_sync(obj->dev);\r\nerr = omap2_iommu_enable(obj);\r\nreturn err;\r\n}\r\nstatic void iommu_disable(struct omap_iommu *obj)\r\n{\r\nstruct platform_device *pdev = to_platform_device(obj->dev);\r\nstruct iommu_platform_data *pdata = dev_get_platdata(&pdev->dev);\r\nomap2_iommu_disable(obj);\r\npm_runtime_put_sync(obj->dev);\r\nif (pdata && pdata->assert_reset)\r\npdata->assert_reset(pdev, pdata->reset_name);\r\n}\r\nstatic u32 iotlb_cr_to_virt(struct cr_regs *cr)\r\n{\r\nu32 page_size = cr->cam & MMU_CAM_PGSZ_MASK;\r\nu32 mask = get_cam_va_mask(cr->cam & page_size);\r\nreturn cr->cam & mask;\r\n}\r\nstatic u32 get_iopte_attr(struct iotlb_entry *e)\r\n{\r\nu32 attr;\r\nattr = e->mixed << 5;\r\nattr |= e->endian;\r\nattr |= e->elsz >> 3;\r\nattr <<= (((e->pgsz == MMU_CAM_PGSZ_4K) ||\r\n(e->pgsz == MMU_CAM_PGSZ_64K)) ? 0 : 6);\r\nreturn attr;\r\n}\r\nstatic u32 iommu_report_fault(struct omap_iommu *obj, u32 *da)\r\n{\r\nu32 status, fault_addr;\r\nstatus = iommu_read_reg(obj, MMU_IRQSTATUS);\r\nstatus &= MMU_IRQ_MASK;\r\nif (!status) {\r\n*da = 0;\r\nreturn 0;\r\n}\r\nfault_addr = iommu_read_reg(obj, MMU_FAULT_AD);\r\n*da = fault_addr;\r\niommu_write_reg(obj, status, MMU_IRQSTATUS);\r\nreturn status;\r\n}\r\nvoid iotlb_lock_get(struct omap_iommu *obj, struct iotlb_lock *l)\r\n{\r\nu32 val;\r\nval = iommu_read_reg(obj, MMU_LOCK);\r\nl->base = MMU_LOCK_BASE(val);\r\nl->vict = MMU_LOCK_VICT(val);\r\n}\r\nvoid iotlb_lock_set(struct omap_iommu *obj, struct iotlb_lock *l)\r\n{\r\nu32 val;\r\nval = (l->base << MMU_LOCK_BASE_SHIFT);\r\nval |= (l->vict << MMU_LOCK_VICT_SHIFT);\r\niommu_write_reg(obj, val, MMU_LOCK);\r\n}\r\nstatic void iotlb_read_cr(struct omap_iommu *obj, struct cr_regs *cr)\r\n{\r\ncr->cam = iommu_read_reg(obj, MMU_READ_CAM);\r\ncr->ram = iommu_read_reg(obj, MMU_READ_RAM);\r\n}\r\nstatic void iotlb_load_cr(struct omap_iommu *obj, struct cr_regs *cr)\r\n{\r\niommu_write_reg(obj, cr->cam | MMU_CAM_V, MMU_CAM);\r\niommu_write_reg(obj, cr->ram, MMU_RAM);\r\niommu_write_reg(obj, 1, MMU_FLUSH_ENTRY);\r\niommu_write_reg(obj, 1, MMU_LD_TLB);\r\n}\r\nstruct cr_regs __iotlb_read_cr(struct omap_iommu *obj, int n)\r\n{\r\nstruct cr_regs cr;\r\nstruct iotlb_lock l;\r\niotlb_lock_get(obj, &l);\r\nl.vict = n;\r\niotlb_lock_set(obj, &l);\r\niotlb_read_cr(obj, &cr);\r\nreturn cr;\r\n}\r\nstatic struct cr_regs *iotlb_alloc_cr(struct omap_iommu *obj,\r\nstruct iotlb_entry *e)\r\n{\r\nstruct cr_regs *cr;\r\nif (!e)\r\nreturn NULL;\r\nif (e->da & ~(get_cam_va_mask(e->pgsz))) {\r\ndev_err(obj->dev, "%s:\twrong alignment: %08x\n", __func__,\r\ne->da);\r\nreturn ERR_PTR(-EINVAL);\r\n}\r\ncr = kmalloc(sizeof(*cr), GFP_KERNEL);\r\nif (!cr)\r\nreturn ERR_PTR(-ENOMEM);\r\ncr->cam = (e->da & MMU_CAM_VATAG_MASK) | e->prsvd | e->pgsz | e->valid;\r\ncr->ram = e->pa | e->endian | e->elsz | e->mixed;\r\nreturn cr;\r\n}\r\nstatic int load_iotlb_entry(struct omap_iommu *obj, struct iotlb_entry *e)\r\n{\r\nint err = 0;\r\nstruct iotlb_lock l;\r\nstruct cr_regs *cr;\r\nif (!obj || !obj->nr_tlb_entries || !e)\r\nreturn -EINVAL;\r\npm_runtime_get_sync(obj->dev);\r\niotlb_lock_get(obj, &l);\r\nif (l.base == obj->nr_tlb_entries) {\r\ndev_warn(obj->dev, "%s: preserve entries full\n", __func__);\r\nerr = -EBUSY;\r\ngoto out;\r\n}\r\nif (!e->prsvd) {\r\nint i;\r\nstruct cr_regs tmp;\r\nfor_each_iotlb_cr(obj, obj->nr_tlb_entries, i, tmp)\r\nif (!iotlb_cr_valid(&tmp))\r\nbreak;\r\nif (i == obj->nr_tlb_entries) {\r\ndev_dbg(obj->dev, "%s: full: no entry\n", __func__);\r\nerr = -EBUSY;\r\ngoto out;\r\n}\r\niotlb_lock_get(obj, &l);\r\n} else {\r\nl.vict = l.base;\r\niotlb_lock_set(obj, &l);\r\n}\r\ncr = iotlb_alloc_cr(obj, e);\r\nif (IS_ERR(cr)) {\r\npm_runtime_put_sync(obj->dev);\r\nreturn PTR_ERR(cr);\r\n}\r\niotlb_load_cr(obj, cr);\r\nkfree(cr);\r\nif (e->prsvd)\r\nl.base++;\r\nif (++l.vict == obj->nr_tlb_entries)\r\nl.vict = l.base;\r\niotlb_lock_set(obj, &l);\r\nout:\r\npm_runtime_put_sync(obj->dev);\r\nreturn err;\r\n}\r\nstatic int load_iotlb_entry(struct omap_iommu *obj, struct iotlb_entry *e)\r\n{\r\nreturn 0;\r\n}\r\nstatic int prefetch_iotlb_entry(struct omap_iommu *obj, struct iotlb_entry *e)\r\n{\r\nreturn load_iotlb_entry(obj, e);\r\n}\r\nstatic void flush_iotlb_page(struct omap_iommu *obj, u32 da)\r\n{\r\nint i;\r\nstruct cr_regs cr;\r\npm_runtime_get_sync(obj->dev);\r\nfor_each_iotlb_cr(obj, obj->nr_tlb_entries, i, cr) {\r\nu32 start;\r\nsize_t bytes;\r\nif (!iotlb_cr_valid(&cr))\r\ncontinue;\r\nstart = iotlb_cr_to_virt(&cr);\r\nbytes = iopgsz_to_bytes(cr.cam & 3);\r\nif ((start <= da) && (da < start + bytes)) {\r\ndev_dbg(obj->dev, "%s: %08x<=%08x(%x)\n",\r\n__func__, start, da, bytes);\r\niotlb_load_cr(obj, &cr);\r\niommu_write_reg(obj, 1, MMU_FLUSH_ENTRY);\r\nbreak;\r\n}\r\n}\r\npm_runtime_put_sync(obj->dev);\r\nif (i == obj->nr_tlb_entries)\r\ndev_dbg(obj->dev, "%s: no page for %08x\n", __func__, da);\r\n}\r\nstatic void flush_iotlb_all(struct omap_iommu *obj)\r\n{\r\nstruct iotlb_lock l;\r\npm_runtime_get_sync(obj->dev);\r\nl.base = 0;\r\nl.vict = 0;\r\niotlb_lock_set(obj, &l);\r\niommu_write_reg(obj, 1, MMU_GFLUSH);\r\npm_runtime_put_sync(obj->dev);\r\n}\r\nstatic void flush_iopgd_range(u32 *first, u32 *last)\r\n{\r\ndo {\r\nasm("mcr p15, 0, %0, c7, c10, 1 @ flush_pgd"\r\n: : "r" (first));\r\nfirst += L1_CACHE_BYTES / sizeof(*first);\r\n} while (first <= last);\r\n}\r\nstatic void flush_iopte_range(u32 *first, u32 *last)\r\n{\r\ndo {\r\nasm("mcr p15, 0, %0, c7, c10, 1 @ flush_pte"\r\n: : "r" (first));\r\nfirst += L1_CACHE_BYTES / sizeof(*first);\r\n} while (first <= last);\r\n}\r\nstatic void iopte_free(u32 *iopte)\r\n{\r\nif (iopte)\r\nkmem_cache_free(iopte_cachep, iopte);\r\n}\r\nstatic u32 *iopte_alloc(struct omap_iommu *obj, u32 *iopgd, u32 da)\r\n{\r\nu32 *iopte;\r\nif (*iopgd)\r\ngoto pte_ready;\r\nspin_unlock(&obj->page_table_lock);\r\niopte = kmem_cache_zalloc(iopte_cachep, GFP_KERNEL);\r\nspin_lock(&obj->page_table_lock);\r\nif (!*iopgd) {\r\nif (!iopte)\r\nreturn ERR_PTR(-ENOMEM);\r\n*iopgd = virt_to_phys(iopte) | IOPGD_TABLE;\r\nflush_iopgd_range(iopgd, iopgd);\r\ndev_vdbg(obj->dev, "%s: a new pte:%p\n", __func__, iopte);\r\n} else {\r\niopte_free(iopte);\r\n}\r\npte_ready:\r\niopte = iopte_offset(iopgd, da);\r\ndev_vdbg(obj->dev,\r\n"%s: da:%08x pgd:%p *pgd:%08x pte:%p *pte:%08x\n",\r\n__func__, da, iopgd, *iopgd, iopte, *iopte);\r\nreturn iopte;\r\n}\r\nstatic int iopgd_alloc_section(struct omap_iommu *obj, u32 da, u32 pa, u32 prot)\r\n{\r\nu32 *iopgd = iopgd_offset(obj, da);\r\nif ((da | pa) & ~IOSECTION_MASK) {\r\ndev_err(obj->dev, "%s: %08x:%08x should aligned on %08lx\n",\r\n__func__, da, pa, IOSECTION_SIZE);\r\nreturn -EINVAL;\r\n}\r\n*iopgd = (pa & IOSECTION_MASK) | prot | IOPGD_SECTION;\r\nflush_iopgd_range(iopgd, iopgd);\r\nreturn 0;\r\n}\r\nstatic int iopgd_alloc_super(struct omap_iommu *obj, u32 da, u32 pa, u32 prot)\r\n{\r\nu32 *iopgd = iopgd_offset(obj, da);\r\nint i;\r\nif ((da | pa) & ~IOSUPER_MASK) {\r\ndev_err(obj->dev, "%s: %08x:%08x should aligned on %08lx\n",\r\n__func__, da, pa, IOSUPER_SIZE);\r\nreturn -EINVAL;\r\n}\r\nfor (i = 0; i < 16; i++)\r\n*(iopgd + i) = (pa & IOSUPER_MASK) | prot | IOPGD_SUPER;\r\nflush_iopgd_range(iopgd, iopgd + 15);\r\nreturn 0;\r\n}\r\nstatic int iopte_alloc_page(struct omap_iommu *obj, u32 da, u32 pa, u32 prot)\r\n{\r\nu32 *iopgd = iopgd_offset(obj, da);\r\nu32 *iopte = iopte_alloc(obj, iopgd, da);\r\nif (IS_ERR(iopte))\r\nreturn PTR_ERR(iopte);\r\n*iopte = (pa & IOPAGE_MASK) | prot | IOPTE_SMALL;\r\nflush_iopte_range(iopte, iopte);\r\ndev_vdbg(obj->dev, "%s: da:%08x pa:%08x pte:%p *pte:%08x\n",\r\n__func__, da, pa, iopte, *iopte);\r\nreturn 0;\r\n}\r\nstatic int iopte_alloc_large(struct omap_iommu *obj, u32 da, u32 pa, u32 prot)\r\n{\r\nu32 *iopgd = iopgd_offset(obj, da);\r\nu32 *iopte = iopte_alloc(obj, iopgd, da);\r\nint i;\r\nif ((da | pa) & ~IOLARGE_MASK) {\r\ndev_err(obj->dev, "%s: %08x:%08x should aligned on %08lx\n",\r\n__func__, da, pa, IOLARGE_SIZE);\r\nreturn -EINVAL;\r\n}\r\nif (IS_ERR(iopte))\r\nreturn PTR_ERR(iopte);\r\nfor (i = 0; i < 16; i++)\r\n*(iopte + i) = (pa & IOLARGE_MASK) | prot | IOPTE_LARGE;\r\nflush_iopte_range(iopte, iopte + 15);\r\nreturn 0;\r\n}\r\nstatic int\r\niopgtable_store_entry_core(struct omap_iommu *obj, struct iotlb_entry *e)\r\n{\r\nint (*fn)(struct omap_iommu *, u32, u32, u32);\r\nu32 prot;\r\nint err;\r\nif (!obj || !e)\r\nreturn -EINVAL;\r\nswitch (e->pgsz) {\r\ncase MMU_CAM_PGSZ_16M:\r\nfn = iopgd_alloc_super;\r\nbreak;\r\ncase MMU_CAM_PGSZ_1M:\r\nfn = iopgd_alloc_section;\r\nbreak;\r\ncase MMU_CAM_PGSZ_64K:\r\nfn = iopte_alloc_large;\r\nbreak;\r\ncase MMU_CAM_PGSZ_4K:\r\nfn = iopte_alloc_page;\r\nbreak;\r\ndefault:\r\nfn = NULL;\r\nBUG();\r\nbreak;\r\n}\r\nprot = get_iopte_attr(e);\r\nspin_lock(&obj->page_table_lock);\r\nerr = fn(obj, e->da, e->pa, prot);\r\nspin_unlock(&obj->page_table_lock);\r\nreturn err;\r\n}\r\nstatic int\r\nomap_iopgtable_store_entry(struct omap_iommu *obj, struct iotlb_entry *e)\r\n{\r\nint err;\r\nflush_iotlb_page(obj, e->da);\r\nerr = iopgtable_store_entry_core(obj, e);\r\nif (!err)\r\nprefetch_iotlb_entry(obj, e);\r\nreturn err;\r\n}\r\nstatic void\r\niopgtable_lookup_entry(struct omap_iommu *obj, u32 da, u32 **ppgd, u32 **ppte)\r\n{\r\nu32 *iopgd, *iopte = NULL;\r\niopgd = iopgd_offset(obj, da);\r\nif (!*iopgd)\r\ngoto out;\r\nif (iopgd_is_table(*iopgd))\r\niopte = iopte_offset(iopgd, da);\r\nout:\r\n*ppgd = iopgd;\r\n*ppte = iopte;\r\n}\r\nstatic size_t iopgtable_clear_entry_core(struct omap_iommu *obj, u32 da)\r\n{\r\nsize_t bytes;\r\nu32 *iopgd = iopgd_offset(obj, da);\r\nint nent = 1;\r\nif (!*iopgd)\r\nreturn 0;\r\nif (iopgd_is_table(*iopgd)) {\r\nint i;\r\nu32 *iopte = iopte_offset(iopgd, da);\r\nbytes = IOPTE_SIZE;\r\nif (*iopte & IOPTE_LARGE) {\r\nnent *= 16;\r\niopte = iopte_offset(iopgd, (da & IOLARGE_MASK));\r\n}\r\nbytes *= nent;\r\nmemset(iopte, 0, nent * sizeof(*iopte));\r\nflush_iopte_range(iopte, iopte + (nent - 1) * sizeof(*iopte));\r\niopte = iopte_offset(iopgd, 0);\r\nfor (i = 0; i < PTRS_PER_IOPTE; i++)\r\nif (iopte[i])\r\ngoto out;\r\niopte_free(iopte);\r\nnent = 1;\r\n} else {\r\nbytes = IOPGD_SIZE;\r\nif ((*iopgd & IOPGD_SUPER) == IOPGD_SUPER) {\r\nnent *= 16;\r\niopgd = iopgd_offset(obj, (da & IOSUPER_MASK));\r\n}\r\nbytes *= nent;\r\n}\r\nmemset(iopgd, 0, nent * sizeof(*iopgd));\r\nflush_iopgd_range(iopgd, iopgd + (nent - 1) * sizeof(*iopgd));\r\nout:\r\nreturn bytes;\r\n}\r\nstatic size_t iopgtable_clear_entry(struct omap_iommu *obj, u32 da)\r\n{\r\nsize_t bytes;\r\nspin_lock(&obj->page_table_lock);\r\nbytes = iopgtable_clear_entry_core(obj, da);\r\nflush_iotlb_page(obj, da);\r\nspin_unlock(&obj->page_table_lock);\r\nreturn bytes;\r\n}\r\nstatic void iopgtable_clear_entry_all(struct omap_iommu *obj)\r\n{\r\nint i;\r\nspin_lock(&obj->page_table_lock);\r\nfor (i = 0; i < PTRS_PER_IOPGD; i++) {\r\nu32 da;\r\nu32 *iopgd;\r\nda = i << IOPGD_SHIFT;\r\niopgd = iopgd_offset(obj, da);\r\nif (!*iopgd)\r\ncontinue;\r\nif (iopgd_is_table(*iopgd))\r\niopte_free(iopte_offset(iopgd, 0));\r\n*iopgd = 0;\r\nflush_iopgd_range(iopgd, iopgd);\r\n}\r\nflush_iotlb_all(obj);\r\nspin_unlock(&obj->page_table_lock);\r\n}\r\nstatic irqreturn_t iommu_fault_handler(int irq, void *data)\r\n{\r\nu32 da, errs;\r\nu32 *iopgd, *iopte;\r\nstruct omap_iommu *obj = data;\r\nstruct iommu_domain *domain = obj->domain;\r\nstruct omap_iommu_domain *omap_domain = to_omap_domain(domain);\r\nif (!omap_domain->iommu_dev)\r\nreturn IRQ_NONE;\r\nerrs = iommu_report_fault(obj, &da);\r\nif (errs == 0)\r\nreturn IRQ_HANDLED;\r\nif (!report_iommu_fault(domain, obj->dev, da, 0))\r\nreturn IRQ_HANDLED;\r\niommu_disable(obj);\r\niopgd = iopgd_offset(obj, da);\r\nif (!iopgd_is_table(*iopgd)) {\r\ndev_err(obj->dev, "%s: errs:0x%08x da:0x%08x pgd:0x%p *pgd:px%08x\n",\r\nobj->name, errs, da, iopgd, *iopgd);\r\nreturn IRQ_NONE;\r\n}\r\niopte = iopte_offset(iopgd, da);\r\ndev_err(obj->dev, "%s: errs:0x%08x da:0x%08x pgd:0x%p *pgd:0x%08x pte:0x%p *pte:0x%08x\n",\r\nobj->name, errs, da, iopgd, *iopgd, iopte, *iopte);\r\nreturn IRQ_NONE;\r\n}\r\nstatic int device_match_by_alias(struct device *dev, void *data)\r\n{\r\nstruct omap_iommu *obj = to_iommu(dev);\r\nconst char *name = data;\r\npr_debug("%s: %s %s\n", __func__, obj->name, name);\r\nreturn strcmp(obj->name, name) == 0;\r\n}\r\nstatic struct omap_iommu *omap_iommu_attach(const char *name, u32 *iopgd)\r\n{\r\nint err;\r\nstruct device *dev;\r\nstruct omap_iommu *obj;\r\ndev = driver_find_device(&omap_iommu_driver.driver, NULL, (void *)name,\r\ndevice_match_by_alias);\r\nif (!dev)\r\nreturn ERR_PTR(-ENODEV);\r\nobj = to_iommu(dev);\r\nspin_lock(&obj->iommu_lock);\r\nobj->iopgd = iopgd;\r\nerr = iommu_enable(obj);\r\nif (err)\r\ngoto err_enable;\r\nflush_iotlb_all(obj);\r\nspin_unlock(&obj->iommu_lock);\r\ndev_dbg(obj->dev, "%s: %s\n", __func__, obj->name);\r\nreturn obj;\r\nerr_enable:\r\nspin_unlock(&obj->iommu_lock);\r\nreturn ERR_PTR(err);\r\n}\r\nstatic void omap_iommu_detach(struct omap_iommu *obj)\r\n{\r\nif (!obj || IS_ERR(obj))\r\nreturn;\r\nspin_lock(&obj->iommu_lock);\r\niommu_disable(obj);\r\nobj->iopgd = NULL;\r\nspin_unlock(&obj->iommu_lock);\r\ndev_dbg(obj->dev, "%s: %s\n", __func__, obj->name);\r\n}\r\nstatic int omap_iommu_dra7_get_dsp_system_cfg(struct platform_device *pdev,\r\nstruct omap_iommu *obj)\r\n{\r\nstruct device_node *np = pdev->dev.of_node;\r\nint ret;\r\nif (!of_device_is_compatible(np, "ti,dra7-dsp-iommu"))\r\nreturn 0;\r\nif (!of_property_read_bool(np, "ti,syscon-mmuconfig")) {\r\ndev_err(&pdev->dev, "ti,syscon-mmuconfig property is missing\n");\r\nreturn -EINVAL;\r\n}\r\nobj->syscfg =\r\nsyscon_regmap_lookup_by_phandle(np, "ti,syscon-mmuconfig");\r\nif (IS_ERR(obj->syscfg)) {\r\nret = PTR_ERR(obj->syscfg);\r\nreturn ret;\r\n}\r\nif (of_property_read_u32_index(np, "ti,syscon-mmuconfig", 1,\r\n&obj->id)) {\r\ndev_err(&pdev->dev, "couldn't get the IOMMU instance id within subsystem\n");\r\nreturn -EINVAL;\r\n}\r\nif (obj->id != 0 && obj->id != 1) {\r\ndev_err(&pdev->dev, "invalid IOMMU instance id\n");\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int omap_iommu_probe(struct platform_device *pdev)\r\n{\r\nint err = -ENODEV;\r\nint irq;\r\nstruct omap_iommu *obj;\r\nstruct resource *res;\r\nstruct iommu_platform_data *pdata = dev_get_platdata(&pdev->dev);\r\nstruct device_node *of = pdev->dev.of_node;\r\nobj = devm_kzalloc(&pdev->dev, sizeof(*obj) + MMU_REG_SIZE, GFP_KERNEL);\r\nif (!obj)\r\nreturn -ENOMEM;\r\nif (of) {\r\nobj->name = dev_name(&pdev->dev);\r\nobj->nr_tlb_entries = 32;\r\nerr = of_property_read_u32(of, "ti,#tlb-entries",\r\n&obj->nr_tlb_entries);\r\nif (err && err != -EINVAL)\r\nreturn err;\r\nif (obj->nr_tlb_entries != 32 && obj->nr_tlb_entries != 8)\r\nreturn -EINVAL;\r\nif (of_find_property(of, "ti,iommu-bus-err-back", NULL))\r\nobj->has_bus_err_back = MMU_GP_REG_BUS_ERR_BACK_EN;\r\n} else {\r\nobj->nr_tlb_entries = pdata->nr_tlb_entries;\r\nobj->name = pdata->name;\r\n}\r\nobj->dev = &pdev->dev;\r\nobj->ctx = (void *)obj + sizeof(*obj);\r\nspin_lock_init(&obj->iommu_lock);\r\nspin_lock_init(&obj->page_table_lock);\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nobj->regbase = devm_ioremap_resource(obj->dev, res);\r\nif (IS_ERR(obj->regbase))\r\nreturn PTR_ERR(obj->regbase);\r\nerr = omap_iommu_dra7_get_dsp_system_cfg(pdev, obj);\r\nif (err)\r\nreturn err;\r\nirq = platform_get_irq(pdev, 0);\r\nif (irq < 0)\r\nreturn -ENODEV;\r\nerr = devm_request_irq(obj->dev, irq, iommu_fault_handler, IRQF_SHARED,\r\ndev_name(obj->dev), obj);\r\nif (err < 0)\r\nreturn err;\r\nplatform_set_drvdata(pdev, obj);\r\npm_runtime_irq_safe(obj->dev);\r\npm_runtime_enable(obj->dev);\r\nomap_iommu_debugfs_add(obj);\r\ndev_info(&pdev->dev, "%s registered\n", obj->name);\r\nreturn 0;\r\n}\r\nstatic int omap_iommu_remove(struct platform_device *pdev)\r\n{\r\nstruct omap_iommu *obj = platform_get_drvdata(pdev);\r\niopgtable_clear_entry_all(obj);\r\nomap_iommu_debugfs_remove(obj);\r\npm_runtime_disable(obj->dev);\r\ndev_info(&pdev->dev, "%s removed\n", obj->name);\r\nreturn 0;\r\n}\r\nstatic void iopte_cachep_ctor(void *iopte)\r\n{\r\nclean_dcache_area(iopte, IOPTE_TABLE_SIZE);\r\n}\r\nstatic u32 iotlb_init_entry(struct iotlb_entry *e, u32 da, u32 pa, int pgsz)\r\n{\r\nmemset(e, 0, sizeof(*e));\r\ne->da = da;\r\ne->pa = pa;\r\ne->valid = MMU_CAM_V;\r\ne->pgsz = pgsz;\r\ne->endian = MMU_RAM_ENDIAN_LITTLE;\r\ne->elsz = MMU_RAM_ELSZ_8;\r\ne->mixed = 0;\r\nreturn iopgsz_to_bytes(e->pgsz);\r\n}\r\nstatic int omap_iommu_map(struct iommu_domain *domain, unsigned long da,\r\nphys_addr_t pa, size_t bytes, int prot)\r\n{\r\nstruct omap_iommu_domain *omap_domain = to_omap_domain(domain);\r\nstruct omap_iommu *oiommu = omap_domain->iommu_dev;\r\nstruct device *dev = oiommu->dev;\r\nstruct iotlb_entry e;\r\nint omap_pgsz;\r\nu32 ret;\r\nomap_pgsz = bytes_to_iopgsz(bytes);\r\nif (omap_pgsz < 0) {\r\ndev_err(dev, "invalid size to map: %d\n", bytes);\r\nreturn -EINVAL;\r\n}\r\ndev_dbg(dev, "mapping da 0x%lx to pa %pa size 0x%x\n", da, &pa, bytes);\r\niotlb_init_entry(&e, da, pa, omap_pgsz);\r\nret = omap_iopgtable_store_entry(oiommu, &e);\r\nif (ret)\r\ndev_err(dev, "omap_iopgtable_store_entry failed: %d\n", ret);\r\nreturn ret;\r\n}\r\nstatic size_t omap_iommu_unmap(struct iommu_domain *domain, unsigned long da,\r\nsize_t size)\r\n{\r\nstruct omap_iommu_domain *omap_domain = to_omap_domain(domain);\r\nstruct omap_iommu *oiommu = omap_domain->iommu_dev;\r\nstruct device *dev = oiommu->dev;\r\ndev_dbg(dev, "unmapping da 0x%lx size %u\n", da, size);\r\nreturn iopgtable_clear_entry(oiommu, da);\r\n}\r\nstatic int\r\nomap_iommu_attach_dev(struct iommu_domain *domain, struct device *dev)\r\n{\r\nstruct omap_iommu_domain *omap_domain = to_omap_domain(domain);\r\nstruct omap_iommu *oiommu;\r\nstruct omap_iommu_arch_data *arch_data = dev->archdata.iommu;\r\nint ret = 0;\r\nif (!arch_data || !arch_data->name) {\r\ndev_err(dev, "device doesn't have an associated iommu\n");\r\nreturn -EINVAL;\r\n}\r\nspin_lock(&omap_domain->lock);\r\nif (omap_domain->iommu_dev) {\r\ndev_err(dev, "iommu domain is already attached\n");\r\nret = -EBUSY;\r\ngoto out;\r\n}\r\noiommu = omap_iommu_attach(arch_data->name, omap_domain->pgtable);\r\nif (IS_ERR(oiommu)) {\r\nret = PTR_ERR(oiommu);\r\ndev_err(dev, "can't get omap iommu: %d\n", ret);\r\ngoto out;\r\n}\r\nomap_domain->iommu_dev = arch_data->iommu_dev = oiommu;\r\nomap_domain->dev = dev;\r\noiommu->domain = domain;\r\nout:\r\nspin_unlock(&omap_domain->lock);\r\nreturn ret;\r\n}\r\nstatic void _omap_iommu_detach_dev(struct omap_iommu_domain *omap_domain,\r\nstruct device *dev)\r\n{\r\nstruct omap_iommu *oiommu = dev_to_omap_iommu(dev);\r\nstruct omap_iommu_arch_data *arch_data = dev->archdata.iommu;\r\nif (omap_domain->iommu_dev != oiommu) {\r\ndev_err(dev, "invalid iommu device\n");\r\nreturn;\r\n}\r\niopgtable_clear_entry_all(oiommu);\r\nomap_iommu_detach(oiommu);\r\nomap_domain->iommu_dev = arch_data->iommu_dev = NULL;\r\nomap_domain->dev = NULL;\r\noiommu->domain = NULL;\r\n}\r\nstatic void omap_iommu_detach_dev(struct iommu_domain *domain,\r\nstruct device *dev)\r\n{\r\nstruct omap_iommu_domain *omap_domain = to_omap_domain(domain);\r\nspin_lock(&omap_domain->lock);\r\n_omap_iommu_detach_dev(omap_domain, dev);\r\nspin_unlock(&omap_domain->lock);\r\n}\r\nstatic struct iommu_domain *omap_iommu_domain_alloc(unsigned type)\r\n{\r\nstruct omap_iommu_domain *omap_domain;\r\nif (type != IOMMU_DOMAIN_UNMANAGED)\r\nreturn NULL;\r\nomap_domain = kzalloc(sizeof(*omap_domain), GFP_KERNEL);\r\nif (!omap_domain)\r\ngoto out;\r\nomap_domain->pgtable = kzalloc(IOPGD_TABLE_SIZE, GFP_KERNEL);\r\nif (!omap_domain->pgtable)\r\ngoto fail_nomem;\r\nBUG_ON(!IS_ALIGNED((long)omap_domain->pgtable, IOPGD_TABLE_SIZE));\r\nclean_dcache_area(omap_domain->pgtable, IOPGD_TABLE_SIZE);\r\nspin_lock_init(&omap_domain->lock);\r\nomap_domain->domain.geometry.aperture_start = 0;\r\nomap_domain->domain.geometry.aperture_end = (1ULL << 32) - 1;\r\nomap_domain->domain.geometry.force_aperture = true;\r\nreturn &omap_domain->domain;\r\nfail_nomem:\r\nkfree(omap_domain);\r\nout:\r\nreturn NULL;\r\n}\r\nstatic void omap_iommu_domain_free(struct iommu_domain *domain)\r\n{\r\nstruct omap_iommu_domain *omap_domain = to_omap_domain(domain);\r\nif (omap_domain->iommu_dev)\r\n_omap_iommu_detach_dev(omap_domain, omap_domain->dev);\r\nkfree(omap_domain->pgtable);\r\nkfree(omap_domain);\r\n}\r\nstatic phys_addr_t omap_iommu_iova_to_phys(struct iommu_domain *domain,\r\ndma_addr_t da)\r\n{\r\nstruct omap_iommu_domain *omap_domain = to_omap_domain(domain);\r\nstruct omap_iommu *oiommu = omap_domain->iommu_dev;\r\nstruct device *dev = oiommu->dev;\r\nu32 *pgd, *pte;\r\nphys_addr_t ret = 0;\r\niopgtable_lookup_entry(oiommu, da, &pgd, &pte);\r\nif (pte) {\r\nif (iopte_is_small(*pte))\r\nret = omap_iommu_translate(*pte, da, IOPTE_MASK);\r\nelse if (iopte_is_large(*pte))\r\nret = omap_iommu_translate(*pte, da, IOLARGE_MASK);\r\nelse\r\ndev_err(dev, "bogus pte 0x%x, da 0x%llx", *pte,\r\n(unsigned long long)da);\r\n} else {\r\nif (iopgd_is_section(*pgd))\r\nret = omap_iommu_translate(*pgd, da, IOSECTION_MASK);\r\nelse if (iopgd_is_super(*pgd))\r\nret = omap_iommu_translate(*pgd, da, IOSUPER_MASK);\r\nelse\r\ndev_err(dev, "bogus pgd 0x%x, da 0x%llx", *pgd,\r\n(unsigned long long)da);\r\n}\r\nreturn ret;\r\n}\r\nstatic int omap_iommu_add_device(struct device *dev)\r\n{\r\nstruct omap_iommu_arch_data *arch_data;\r\nstruct device_node *np;\r\nstruct platform_device *pdev;\r\nif (!dev->of_node)\r\nreturn 0;\r\nnp = of_parse_phandle(dev->of_node, "iommus", 0);\r\nif (!np)\r\nreturn 0;\r\npdev = of_find_device_by_node(np);\r\nif (WARN_ON(!pdev)) {\r\nof_node_put(np);\r\nreturn -EINVAL;\r\n}\r\narch_data = kzalloc(sizeof(*arch_data), GFP_KERNEL);\r\nif (!arch_data) {\r\nof_node_put(np);\r\nreturn -ENOMEM;\r\n}\r\narch_data->name = kstrdup(dev_name(&pdev->dev), GFP_KERNEL);\r\ndev->archdata.iommu = arch_data;\r\nof_node_put(np);\r\nreturn 0;\r\n}\r\nstatic void omap_iommu_remove_device(struct device *dev)\r\n{\r\nstruct omap_iommu_arch_data *arch_data = dev->archdata.iommu;\r\nif (!dev->of_node || !arch_data)\r\nreturn;\r\nkfree(arch_data->name);\r\nkfree(arch_data);\r\n}\r\nstatic int __init omap_iommu_init(void)\r\n{\r\nstruct kmem_cache *p;\r\nconst unsigned long flags = SLAB_HWCACHE_ALIGN;\r\nsize_t align = 1 << 10;\r\nstruct device_node *np;\r\nnp = of_find_matching_node(NULL, omap_iommu_of_match);\r\nif (!np)\r\nreturn 0;\r\nof_node_put(np);\r\np = kmem_cache_create("iopte_cache", IOPTE_TABLE_SIZE, align, flags,\r\niopte_cachep_ctor);\r\nif (!p)\r\nreturn -ENOMEM;\r\niopte_cachep = p;\r\nbus_set_iommu(&platform_bus_type, &omap_iommu_ops);\r\nomap_iommu_debugfs_init();\r\nreturn platform_driver_register(&omap_iommu_driver);\r\n}
