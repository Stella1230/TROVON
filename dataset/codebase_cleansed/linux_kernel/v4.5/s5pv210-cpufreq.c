static void s5pv210_set_refresh(enum s5pv210_dmc_port ch, unsigned long freq)\r\n{\r\nunsigned long tmp, tmp1;\r\nvoid __iomem *reg = NULL;\r\nif (ch == DMC0) {\r\nreg = (dmc_base[0] + 0x30);\r\n} else if (ch == DMC1) {\r\nreg = (dmc_base[1] + 0x30);\r\n} else {\r\nprintk(KERN_ERR "Cannot find DMC port\n");\r\nreturn;\r\n}\r\ntmp = s5pv210_dram_conf[ch].freq;\r\ntmp /= freq;\r\ntmp1 = s5pv210_dram_conf[ch].refresh;\r\ntmp1 /= tmp;\r\n__raw_writel(tmp1, reg);\r\n}\r\nstatic int s5pv210_target(struct cpufreq_policy *policy, unsigned int index)\r\n{\r\nunsigned long reg;\r\nunsigned int priv_index;\r\nunsigned int pll_changing = 0;\r\nunsigned int bus_speed_changing = 0;\r\nunsigned int old_freq, new_freq;\r\nint arm_volt, int_volt;\r\nint ret = 0;\r\nmutex_lock(&set_freq_lock);\r\nif (no_cpufreq_access) {\r\npr_err("Denied access to %s as it is disabled temporarily\n",\r\n__func__);\r\nret = -EINVAL;\r\ngoto exit;\r\n}\r\nold_freq = policy->cur;\r\nnew_freq = s5pv210_freq_table[index].frequency;\r\nif (cpufreq_frequency_table_target(policy, s5pv210_freq_table,\r\nold_freq, CPUFREQ_RELATION_H,\r\n&priv_index)) {\r\nret = -EINVAL;\r\ngoto exit;\r\n}\r\narm_volt = dvs_conf[index].arm_volt;\r\nint_volt = dvs_conf[index].int_volt;\r\nif (new_freq > old_freq) {\r\nret = regulator_set_voltage(arm_regulator,\r\narm_volt, arm_volt_max);\r\nif (ret)\r\ngoto exit;\r\nret = regulator_set_voltage(int_regulator,\r\nint_volt, int_volt_max);\r\nif (ret)\r\ngoto exit;\r\n}\r\nif ((index == L0) || (priv_index == L0))\r\npll_changing = 1;\r\nif ((index == L4) || (priv_index == L4))\r\nbus_speed_changing = 1;\r\nif (bus_speed_changing) {\r\nif (pll_changing)\r\ns5pv210_set_refresh(DMC1, 83000);\r\nelse\r\ns5pv210_set_refresh(DMC1, 100000);\r\ns5pv210_set_refresh(DMC0, 83000);\r\n}\r\nif (pll_changing) {\r\nreg = __raw_readl(S5P_CLK_DIV2);\r\nreg &= ~(S5P_CLKDIV2_G3D_MASK | S5P_CLKDIV2_MFC_MASK);\r\nreg |= (3 << S5P_CLKDIV2_G3D_SHIFT) |\r\n(3 << S5P_CLKDIV2_MFC_SHIFT);\r\n__raw_writel(reg, S5P_CLK_DIV2);\r\ndo {\r\nreg = __raw_readl(S5P_CLKDIV_STAT0);\r\n} while (reg & ((1 << 16) | (1 << 17)));\r\nreg = __raw_readl(S5P_CLK_SRC2);\r\nreg &= ~(S5P_CLKSRC2_G3D_MASK | S5P_CLKSRC2_MFC_MASK);\r\nreg |= (1 << S5P_CLKSRC2_G3D_SHIFT) |\r\n(1 << S5P_CLKSRC2_MFC_SHIFT);\r\n__raw_writel(reg, S5P_CLK_SRC2);\r\ndo {\r\nreg = __raw_readl(S5P_CLKMUX_STAT1);\r\n} while (reg & ((1 << 7) | (1 << 3)));\r\nif (!bus_speed_changing)\r\ns5pv210_set_refresh(DMC1, 133000);\r\nreg = __raw_readl(S5P_CLK_SRC0);\r\nreg &= ~(S5P_CLKSRC0_MUX200_MASK);\r\nreg |= (0x1 << S5P_CLKSRC0_MUX200_SHIFT);\r\n__raw_writel(reg, S5P_CLK_SRC0);\r\ndo {\r\nreg = __raw_readl(S5P_CLKMUX_STAT0);\r\n} while (reg & (0x1 << 18));\r\n}\r\nreg = __raw_readl(S5P_CLK_DIV0);\r\nreg &= ~(S5P_CLKDIV0_APLL_MASK | S5P_CLKDIV0_A2M_MASK |\r\nS5P_CLKDIV0_HCLK200_MASK | S5P_CLKDIV0_PCLK100_MASK |\r\nS5P_CLKDIV0_HCLK166_MASK | S5P_CLKDIV0_PCLK83_MASK |\r\nS5P_CLKDIV0_HCLK133_MASK | S5P_CLKDIV0_PCLK66_MASK);\r\nreg |= ((clkdiv_val[index][0] << S5P_CLKDIV0_APLL_SHIFT) |\r\n(clkdiv_val[index][1] << S5P_CLKDIV0_A2M_SHIFT) |\r\n(clkdiv_val[index][2] << S5P_CLKDIV0_HCLK200_SHIFT) |\r\n(clkdiv_val[index][3] << S5P_CLKDIV0_PCLK100_SHIFT) |\r\n(clkdiv_val[index][4] << S5P_CLKDIV0_HCLK166_SHIFT) |\r\n(clkdiv_val[index][5] << S5P_CLKDIV0_PCLK83_SHIFT) |\r\n(clkdiv_val[index][6] << S5P_CLKDIV0_HCLK133_SHIFT) |\r\n(clkdiv_val[index][7] << S5P_CLKDIV0_PCLK66_SHIFT));\r\n__raw_writel(reg, S5P_CLK_DIV0);\r\ndo {\r\nreg = __raw_readl(S5P_CLKDIV_STAT0);\r\n} while (reg & 0xff);\r\nreg = __raw_readl(S5P_ARM_MCS_CON);\r\nreg &= ~0x3;\r\nif (index >= L3)\r\nreg |= 0x3;\r\nelse\r\nreg |= 0x1;\r\n__raw_writel(reg, S5P_ARM_MCS_CON);\r\nif (pll_changing) {\r\n__raw_writel(0x2cf, S5P_APLL_LOCK);\r\nif (index == L0)\r\n__raw_writel(APLL_VAL_1000, S5P_APLL_CON);\r\nelse\r\n__raw_writel(APLL_VAL_800, S5P_APLL_CON);\r\ndo {\r\nreg = __raw_readl(S5P_APLL_CON);\r\n} while (!(reg & (0x1 << 29)));\r\nreg = __raw_readl(S5P_CLK_SRC2);\r\nreg &= ~(S5P_CLKSRC2_G3D_MASK | S5P_CLKSRC2_MFC_MASK);\r\nreg |= (0 << S5P_CLKSRC2_G3D_SHIFT) |\r\n(0 << S5P_CLKSRC2_MFC_SHIFT);\r\n__raw_writel(reg, S5P_CLK_SRC2);\r\ndo {\r\nreg = __raw_readl(S5P_CLKMUX_STAT1);\r\n} while (reg & ((1 << 7) | (1 << 3)));\r\nreg = __raw_readl(S5P_CLK_DIV2);\r\nreg &= ~(S5P_CLKDIV2_G3D_MASK | S5P_CLKDIV2_MFC_MASK);\r\nreg |= (clkdiv_val[index][10] << S5P_CLKDIV2_G3D_SHIFT) |\r\n(clkdiv_val[index][9] << S5P_CLKDIV2_MFC_SHIFT);\r\n__raw_writel(reg, S5P_CLK_DIV2);\r\ndo {\r\nreg = __raw_readl(S5P_CLKDIV_STAT0);\r\n} while (reg & ((1 << 16) | (1 << 17)));\r\nreg = __raw_readl(S5P_CLK_SRC0);\r\nreg &= ~(S5P_CLKSRC0_MUX200_MASK);\r\nreg |= (0x0 << S5P_CLKSRC0_MUX200_SHIFT);\r\n__raw_writel(reg, S5P_CLK_SRC0);\r\ndo {\r\nreg = __raw_readl(S5P_CLKMUX_STAT0);\r\n} while (reg & (0x1 << 18));\r\nif (!bus_speed_changing)\r\ns5pv210_set_refresh(DMC1, 200000);\r\n}\r\nif (bus_speed_changing) {\r\nreg = __raw_readl(S5P_CLK_DIV6);\r\nreg &= ~S5P_CLKDIV6_ONEDRAM_MASK;\r\nreg |= (clkdiv_val[index][8] << S5P_CLKDIV6_ONEDRAM_SHIFT);\r\n__raw_writel(reg, S5P_CLK_DIV6);\r\ndo {\r\nreg = __raw_readl(S5P_CLKDIV_STAT1);\r\n} while (reg & (1 << 15));\r\nif (index != L4) {\r\ns5pv210_set_refresh(DMC0, 166000);\r\ns5pv210_set_refresh(DMC1, 200000);\r\n} else {\r\ns5pv210_set_refresh(DMC0, 83000);\r\ns5pv210_set_refresh(DMC1, 100000);\r\n}\r\n}\r\nif (new_freq < old_freq) {\r\nregulator_set_voltage(int_regulator,\r\nint_volt, int_volt_max);\r\nregulator_set_voltage(arm_regulator,\r\narm_volt, arm_volt_max);\r\n}\r\nprintk(KERN_DEBUG "Perf changed[L%d]\n", index);\r\nexit:\r\nmutex_unlock(&set_freq_lock);\r\nreturn ret;\r\n}\r\nstatic int check_mem_type(void __iomem *dmc_reg)\r\n{\r\nunsigned long val;\r\nval = __raw_readl(dmc_reg + 0x4);\r\nval = (val & (0xf << 8));\r\nreturn val >> 8;\r\n}\r\nstatic int s5pv210_cpu_init(struct cpufreq_policy *policy)\r\n{\r\nunsigned long mem_type;\r\nint ret;\r\npolicy->clk = clk_get(NULL, "armclk");\r\nif (IS_ERR(policy->clk))\r\nreturn PTR_ERR(policy->clk);\r\ndmc0_clk = clk_get(NULL, "sclk_dmc0");\r\nif (IS_ERR(dmc0_clk)) {\r\nret = PTR_ERR(dmc0_clk);\r\ngoto out_dmc0;\r\n}\r\ndmc1_clk = clk_get(NULL, "hclk_msys");\r\nif (IS_ERR(dmc1_clk)) {\r\nret = PTR_ERR(dmc1_clk);\r\ngoto out_dmc1;\r\n}\r\nif (policy->cpu != 0) {\r\nret = -EINVAL;\r\ngoto out_dmc1;\r\n}\r\nmem_type = check_mem_type(dmc_base[0]);\r\nif ((mem_type != LPDDR) && (mem_type != LPDDR2)) {\r\nprintk(KERN_ERR "CPUFreq doesn't support this memory type\n");\r\nret = -EINVAL;\r\ngoto out_dmc1;\r\n}\r\ns5pv210_dram_conf[0].refresh = (__raw_readl(dmc_base[0] + 0x30) * 1000);\r\ns5pv210_dram_conf[0].freq = clk_get_rate(dmc0_clk);\r\ns5pv210_dram_conf[1].refresh = (__raw_readl(dmc_base[1] + 0x30) * 1000);\r\ns5pv210_dram_conf[1].freq = clk_get_rate(dmc1_clk);\r\npolicy->suspend_freq = SLEEP_FREQ;\r\nreturn cpufreq_generic_init(policy, s5pv210_freq_table, 40000);\r\nout_dmc1:\r\nclk_put(dmc0_clk);\r\nout_dmc0:\r\nclk_put(policy->clk);\r\nreturn ret;\r\n}\r\nstatic int s5pv210_cpufreq_reboot_notifier_event(struct notifier_block *this,\r\nunsigned long event, void *ptr)\r\n{\r\nint ret;\r\nret = cpufreq_driver_target(cpufreq_cpu_get(0), SLEEP_FREQ, 0);\r\nif (ret < 0)\r\nreturn NOTIFY_BAD;\r\nno_cpufreq_access = true;\r\nreturn NOTIFY_DONE;\r\n}\r\nstatic int s5pv210_cpufreq_probe(struct platform_device *pdev)\r\n{\r\nstruct device_node *np;\r\nint id;\r\nnp = of_find_compatible_node(NULL, NULL, "samsung,s5pv210-clock");\r\nif (!np) {\r\npr_err("%s: failed to find clock controller DT node\n",\r\n__func__);\r\nreturn -ENODEV;\r\n}\r\nclk_base = of_iomap(np, 0);\r\nif (!clk_base) {\r\npr_err("%s: failed to map clock registers\n", __func__);\r\nreturn -EFAULT;\r\n}\r\nfor_each_compatible_node(np, NULL, "samsung,s5pv210-dmc") {\r\nid = of_alias_get_id(np, "dmc");\r\nif (id < 0 || id >= ARRAY_SIZE(dmc_base)) {\r\npr_err("%s: failed to get alias of dmc node '%s'\n",\r\n__func__, np->name);\r\nreturn id;\r\n}\r\ndmc_base[id] = of_iomap(np, 0);\r\nif (!dmc_base[id]) {\r\npr_err("%s: failed to map dmc%d registers\n",\r\n__func__, id);\r\nreturn -EFAULT;\r\n}\r\n}\r\nfor (id = 0; id < ARRAY_SIZE(dmc_base); ++id) {\r\nif (!dmc_base[id]) {\r\npr_err("%s: failed to find dmc%d node\n", __func__, id);\r\nreturn -ENODEV;\r\n}\r\n}\r\narm_regulator = regulator_get(NULL, "vddarm");\r\nif (IS_ERR(arm_regulator)) {\r\npr_err("failed to get regulator vddarm");\r\nreturn PTR_ERR(arm_regulator);\r\n}\r\nint_regulator = regulator_get(NULL, "vddint");\r\nif (IS_ERR(int_regulator)) {\r\npr_err("failed to get regulator vddint");\r\nregulator_put(arm_regulator);\r\nreturn PTR_ERR(int_regulator);\r\n}\r\nregister_reboot_notifier(&s5pv210_cpufreq_reboot_notifier);\r\nreturn cpufreq_register_driver(&s5pv210_driver);\r\n}
