static inline u32 mei_me_reg_read(const struct mei_me_hw *hw,\r\nunsigned long offset)\r\n{\r\nreturn ioread32(hw->mem_addr + offset);\r\n}\r\nstatic inline void mei_me_reg_write(const struct mei_me_hw *hw,\r\nunsigned long offset, u32 value)\r\n{\r\niowrite32(value, hw->mem_addr + offset);\r\n}\r\nstatic inline u32 mei_me_mecbrw_read(const struct mei_device *dev)\r\n{\r\nreturn mei_me_reg_read(to_me_hw(dev), ME_CB_RW);\r\n}\r\nstatic inline void mei_me_hcbww_write(struct mei_device *dev, u32 data)\r\n{\r\nmei_me_reg_write(to_me_hw(dev), H_CB_WW, data);\r\n}\r\nstatic inline u32 mei_me_mecsr_read(const struct mei_device *dev)\r\n{\r\nu32 reg;\r\nreg = mei_me_reg_read(to_me_hw(dev), ME_CSR_HA);\r\ntrace_mei_reg_read(dev->dev, "ME_CSR_HA", ME_CSR_HA, reg);\r\nreturn reg;\r\n}\r\nstatic inline u32 mei_hcsr_read(const struct mei_device *dev)\r\n{\r\nu32 reg;\r\nreg = mei_me_reg_read(to_me_hw(dev), H_CSR);\r\ntrace_mei_reg_read(dev->dev, "H_CSR", H_CSR, reg);\r\nreturn reg;\r\n}\r\nstatic inline void mei_hcsr_write(struct mei_device *dev, u32 reg)\r\n{\r\ntrace_mei_reg_write(dev->dev, "H_CSR", H_CSR, reg);\r\nmei_me_reg_write(to_me_hw(dev), H_CSR, reg);\r\n}\r\nstatic inline void mei_hcsr_set(struct mei_device *dev, u32 reg)\r\n{\r\nreg &= ~H_CSR_IS_MASK;\r\nmei_hcsr_write(dev, reg);\r\n}\r\nstatic inline u32 mei_me_d0i3c_read(const struct mei_device *dev)\r\n{\r\nu32 reg;\r\nreg = mei_me_reg_read(to_me_hw(dev), H_D0I3C);\r\ntrace_mei_reg_read(dev->dev, "H_D0I3C", H_D0I3C, reg);\r\nreturn reg;\r\n}\r\nstatic inline void mei_me_d0i3c_write(struct mei_device *dev, u32 reg)\r\n{\r\ntrace_mei_reg_write(dev->dev, "H_D0I3C", H_D0I3C, reg);\r\nmei_me_reg_write(to_me_hw(dev), H_D0I3C, reg);\r\n}\r\nstatic int mei_me_fw_status(struct mei_device *dev,\r\nstruct mei_fw_status *fw_status)\r\n{\r\nstruct pci_dev *pdev = to_pci_dev(dev->dev);\r\nstruct mei_me_hw *hw = to_me_hw(dev);\r\nconst struct mei_fw_status *fw_src = &hw->cfg->fw_status;\r\nint ret;\r\nint i;\r\nif (!fw_status)\r\nreturn -EINVAL;\r\nfw_status->count = fw_src->count;\r\nfor (i = 0; i < fw_src->count && i < MEI_FW_STATUS_MAX; i++) {\r\nret = pci_read_config_dword(pdev,\r\nfw_src->status[i], &fw_status->status[i]);\r\nif (ret)\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic void mei_me_hw_config(struct mei_device *dev)\r\n{\r\nstruct pci_dev *pdev = to_pci_dev(dev->dev);\r\nstruct mei_me_hw *hw = to_me_hw(dev);\r\nu32 hcsr, reg;\r\nhcsr = mei_hcsr_read(dev);\r\ndev->hbuf_depth = (hcsr & H_CBD) >> 24;\r\nreg = 0;\r\npci_read_config_dword(pdev, PCI_CFG_HFS_1, &reg);\r\nhw->d0i3_supported =\r\n((reg & PCI_CFG_HFS_1_D0I3_MSK) == PCI_CFG_HFS_1_D0I3_MSK);\r\nhw->pg_state = MEI_PG_OFF;\r\nif (hw->d0i3_supported) {\r\nreg = mei_me_d0i3c_read(dev);\r\nif (reg & H_D0I3C_I3)\r\nhw->pg_state = MEI_PG_ON;\r\n}\r\n}\r\nstatic inline enum mei_pg_state mei_me_pg_state(struct mei_device *dev)\r\n{\r\nstruct mei_me_hw *hw = to_me_hw(dev);\r\nreturn hw->pg_state;\r\n}\r\nstatic void mei_me_intr_clear(struct mei_device *dev)\r\n{\r\nu32 hcsr = mei_hcsr_read(dev);\r\nif (hcsr & H_CSR_IS_MASK)\r\nmei_hcsr_write(dev, hcsr);\r\n}\r\nstatic void mei_me_intr_enable(struct mei_device *dev)\r\n{\r\nu32 hcsr = mei_hcsr_read(dev);\r\nhcsr |= H_CSR_IE_MASK;\r\nmei_hcsr_set(dev, hcsr);\r\n}\r\nstatic void mei_me_intr_disable(struct mei_device *dev)\r\n{\r\nu32 hcsr = mei_hcsr_read(dev);\r\nhcsr &= ~H_CSR_IE_MASK;\r\nmei_hcsr_set(dev, hcsr);\r\n}\r\nstatic void mei_me_hw_reset_release(struct mei_device *dev)\r\n{\r\nu32 hcsr = mei_hcsr_read(dev);\r\nhcsr |= H_IG;\r\nhcsr &= ~H_RST;\r\nmei_hcsr_set(dev, hcsr);\r\nmmiowb();\r\n}\r\nstatic void mei_me_host_set_ready(struct mei_device *dev)\r\n{\r\nu32 hcsr = mei_hcsr_read(dev);\r\nhcsr |= H_CSR_IE_MASK | H_IG | H_RDY;\r\nmei_hcsr_set(dev, hcsr);\r\n}\r\nstatic bool mei_me_host_is_ready(struct mei_device *dev)\r\n{\r\nu32 hcsr = mei_hcsr_read(dev);\r\nreturn (hcsr & H_RDY) == H_RDY;\r\n}\r\nstatic bool mei_me_hw_is_ready(struct mei_device *dev)\r\n{\r\nu32 mecsr = mei_me_mecsr_read(dev);\r\nreturn (mecsr & ME_RDY_HRA) == ME_RDY_HRA;\r\n}\r\nstatic int mei_me_hw_ready_wait(struct mei_device *dev)\r\n{\r\nmutex_unlock(&dev->device_lock);\r\nwait_event_timeout(dev->wait_hw_ready,\r\ndev->recvd_hw_ready,\r\nmei_secs_to_jiffies(MEI_HW_READY_TIMEOUT));\r\nmutex_lock(&dev->device_lock);\r\nif (!dev->recvd_hw_ready) {\r\ndev_err(dev->dev, "wait hw ready failed\n");\r\nreturn -ETIME;\r\n}\r\nmei_me_hw_reset_release(dev);\r\ndev->recvd_hw_ready = false;\r\nreturn 0;\r\n}\r\nstatic int mei_me_hw_start(struct mei_device *dev)\r\n{\r\nint ret = mei_me_hw_ready_wait(dev);\r\nif (ret)\r\nreturn ret;\r\ndev_dbg(dev->dev, "hw is ready\n");\r\nmei_me_host_set_ready(dev);\r\nreturn ret;\r\n}\r\nstatic unsigned char mei_hbuf_filled_slots(struct mei_device *dev)\r\n{\r\nu32 hcsr;\r\nchar read_ptr, write_ptr;\r\nhcsr = mei_hcsr_read(dev);\r\nread_ptr = (char) ((hcsr & H_CBRP) >> 8);\r\nwrite_ptr = (char) ((hcsr & H_CBWP) >> 16);\r\nreturn (unsigned char) (write_ptr - read_ptr);\r\n}\r\nstatic bool mei_me_hbuf_is_empty(struct mei_device *dev)\r\n{\r\nreturn mei_hbuf_filled_slots(dev) == 0;\r\n}\r\nstatic int mei_me_hbuf_empty_slots(struct mei_device *dev)\r\n{\r\nunsigned char filled_slots, empty_slots;\r\nfilled_slots = mei_hbuf_filled_slots(dev);\r\nempty_slots = dev->hbuf_depth - filled_slots;\r\nif (filled_slots > dev->hbuf_depth)\r\nreturn -EOVERFLOW;\r\nreturn empty_slots;\r\n}\r\nstatic size_t mei_me_hbuf_max_len(const struct mei_device *dev)\r\n{\r\nreturn dev->hbuf_depth * sizeof(u32) - sizeof(struct mei_msg_hdr);\r\n}\r\nstatic int mei_me_write_message(struct mei_device *dev,\r\nstruct mei_msg_hdr *header,\r\nunsigned char *buf)\r\n{\r\nunsigned long rem;\r\nunsigned long length = header->length;\r\nu32 *reg_buf = (u32 *)buf;\r\nu32 hcsr;\r\nu32 dw_cnt;\r\nint i;\r\nint empty_slots;\r\ndev_dbg(dev->dev, MEI_HDR_FMT, MEI_HDR_PRM(header));\r\nempty_slots = mei_hbuf_empty_slots(dev);\r\ndev_dbg(dev->dev, "empty slots = %hu.\n", empty_slots);\r\ndw_cnt = mei_data2slots(length);\r\nif (empty_slots < 0 || dw_cnt > empty_slots)\r\nreturn -EMSGSIZE;\r\nmei_me_hcbww_write(dev, *((u32 *) header));\r\nfor (i = 0; i < length / 4; i++)\r\nmei_me_hcbww_write(dev, reg_buf[i]);\r\nrem = length & 0x3;\r\nif (rem > 0) {\r\nu32 reg = 0;\r\nmemcpy(&reg, &buf[length - rem], rem);\r\nmei_me_hcbww_write(dev, reg);\r\n}\r\nhcsr = mei_hcsr_read(dev) | H_IG;\r\nmei_hcsr_set(dev, hcsr);\r\nif (!mei_me_hw_is_ready(dev))\r\nreturn -EIO;\r\nreturn 0;\r\n}\r\nstatic int mei_me_count_full_read_slots(struct mei_device *dev)\r\n{\r\nu32 me_csr;\r\nchar read_ptr, write_ptr;\r\nunsigned char buffer_depth, filled_slots;\r\nme_csr = mei_me_mecsr_read(dev);\r\nbuffer_depth = (unsigned char)((me_csr & ME_CBD_HRA) >> 24);\r\nread_ptr = (char) ((me_csr & ME_CBRP_HRA) >> 8);\r\nwrite_ptr = (char) ((me_csr & ME_CBWP_HRA) >> 16);\r\nfilled_slots = (unsigned char) (write_ptr - read_ptr);\r\nif (filled_slots > buffer_depth)\r\nreturn -EOVERFLOW;\r\ndev_dbg(dev->dev, "filled_slots =%08x\n", filled_slots);\r\nreturn (int)filled_slots;\r\n}\r\nstatic int mei_me_read_slots(struct mei_device *dev, unsigned char *buffer,\r\nunsigned long buffer_length)\r\n{\r\nu32 *reg_buf = (u32 *)buffer;\r\nu32 hcsr;\r\nfor (; buffer_length >= sizeof(u32); buffer_length -= sizeof(u32))\r\n*reg_buf++ = mei_me_mecbrw_read(dev);\r\nif (buffer_length > 0) {\r\nu32 reg = mei_me_mecbrw_read(dev);\r\nmemcpy(reg_buf, &reg, buffer_length);\r\n}\r\nhcsr = mei_hcsr_read(dev) | H_IG;\r\nmei_hcsr_set(dev, hcsr);\r\nreturn 0;\r\n}\r\nstatic void mei_me_pg_set(struct mei_device *dev)\r\n{\r\nstruct mei_me_hw *hw = to_me_hw(dev);\r\nu32 reg;\r\nreg = mei_me_reg_read(hw, H_HPG_CSR);\r\ntrace_mei_reg_read(dev->dev, "H_HPG_CSR", H_HPG_CSR, reg);\r\nreg |= H_HPG_CSR_PGI;\r\ntrace_mei_reg_write(dev->dev, "H_HPG_CSR", H_HPG_CSR, reg);\r\nmei_me_reg_write(hw, H_HPG_CSR, reg);\r\n}\r\nstatic void mei_me_pg_unset(struct mei_device *dev)\r\n{\r\nstruct mei_me_hw *hw = to_me_hw(dev);\r\nu32 reg;\r\nreg = mei_me_reg_read(hw, H_HPG_CSR);\r\ntrace_mei_reg_read(dev->dev, "H_HPG_CSR", H_HPG_CSR, reg);\r\nWARN(!(reg & H_HPG_CSR_PGI), "PGI is not set\n");\r\nreg |= H_HPG_CSR_PGIHEXR;\r\ntrace_mei_reg_write(dev->dev, "H_HPG_CSR", H_HPG_CSR, reg);\r\nmei_me_reg_write(hw, H_HPG_CSR, reg);\r\n}\r\nstatic int mei_me_pg_legacy_enter_sync(struct mei_device *dev)\r\n{\r\nstruct mei_me_hw *hw = to_me_hw(dev);\r\nunsigned long timeout = mei_secs_to_jiffies(MEI_PGI_TIMEOUT);\r\nint ret;\r\ndev->pg_event = MEI_PG_EVENT_WAIT;\r\nret = mei_hbm_pg(dev, MEI_PG_ISOLATION_ENTRY_REQ_CMD);\r\nif (ret)\r\nreturn ret;\r\nmutex_unlock(&dev->device_lock);\r\nwait_event_timeout(dev->wait_pg,\r\ndev->pg_event == MEI_PG_EVENT_RECEIVED, timeout);\r\nmutex_lock(&dev->device_lock);\r\nif (dev->pg_event == MEI_PG_EVENT_RECEIVED) {\r\nmei_me_pg_set(dev);\r\nret = 0;\r\n} else {\r\nret = -ETIME;\r\n}\r\ndev->pg_event = MEI_PG_EVENT_IDLE;\r\nhw->pg_state = MEI_PG_ON;\r\nreturn ret;\r\n}\r\nstatic int mei_me_pg_legacy_exit_sync(struct mei_device *dev)\r\n{\r\nstruct mei_me_hw *hw = to_me_hw(dev);\r\nunsigned long timeout = mei_secs_to_jiffies(MEI_PGI_TIMEOUT);\r\nint ret;\r\nif (dev->pg_event == MEI_PG_EVENT_RECEIVED)\r\ngoto reply;\r\ndev->pg_event = MEI_PG_EVENT_WAIT;\r\nmei_me_pg_unset(dev);\r\nmutex_unlock(&dev->device_lock);\r\nwait_event_timeout(dev->wait_pg,\r\ndev->pg_event == MEI_PG_EVENT_RECEIVED, timeout);\r\nmutex_lock(&dev->device_lock);\r\nreply:\r\nif (dev->pg_event != MEI_PG_EVENT_RECEIVED) {\r\nret = -ETIME;\r\ngoto out;\r\n}\r\ndev->pg_event = MEI_PG_EVENT_INTR_WAIT;\r\nret = mei_hbm_pg(dev, MEI_PG_ISOLATION_EXIT_RES_CMD);\r\nif (ret)\r\nreturn ret;\r\nmutex_unlock(&dev->device_lock);\r\nwait_event_timeout(dev->wait_pg,\r\ndev->pg_event == MEI_PG_EVENT_INTR_RECEIVED, timeout);\r\nmutex_lock(&dev->device_lock);\r\nif (dev->pg_event == MEI_PG_EVENT_INTR_RECEIVED)\r\nret = 0;\r\nelse\r\nret = -ETIME;\r\nout:\r\ndev->pg_event = MEI_PG_EVENT_IDLE;\r\nhw->pg_state = MEI_PG_OFF;\r\nreturn ret;\r\n}\r\nstatic bool mei_me_pg_in_transition(struct mei_device *dev)\r\n{\r\nreturn dev->pg_event >= MEI_PG_EVENT_WAIT &&\r\ndev->pg_event <= MEI_PG_EVENT_INTR_WAIT;\r\n}\r\nstatic bool mei_me_pg_is_enabled(struct mei_device *dev)\r\n{\r\nstruct mei_me_hw *hw = to_me_hw(dev);\r\nu32 reg = mei_me_mecsr_read(dev);\r\nif (hw->d0i3_supported)\r\nreturn true;\r\nif ((reg & ME_PGIC_HRA) == 0)\r\ngoto notsupported;\r\nif (!dev->hbm_f_pg_supported)\r\ngoto notsupported;\r\nreturn true;\r\nnotsupported:\r\ndev_dbg(dev->dev, "pg: not supported: d0i3 = %d HGP = %d hbm version %d.%d ?= %d.%d\n",\r\nhw->d0i3_supported,\r\n!!(reg & ME_PGIC_HRA),\r\ndev->version.major_version,\r\ndev->version.minor_version,\r\nHBM_MAJOR_VERSION_PGI,\r\nHBM_MINOR_VERSION_PGI);\r\nreturn false;\r\n}\r\nstatic u32 mei_me_d0i3_set(struct mei_device *dev, bool intr)\r\n{\r\nu32 reg = mei_me_d0i3c_read(dev);\r\nreg |= H_D0I3C_I3;\r\nif (intr)\r\nreg |= H_D0I3C_IR;\r\nelse\r\nreg &= ~H_D0I3C_IR;\r\nmei_me_d0i3c_write(dev, reg);\r\nreg = mei_me_d0i3c_read(dev);\r\nreturn reg;\r\n}\r\nstatic u32 mei_me_d0i3_unset(struct mei_device *dev)\r\n{\r\nu32 reg = mei_me_d0i3c_read(dev);\r\nreg &= ~H_D0I3C_I3;\r\nreg |= H_D0I3C_IR;\r\nmei_me_d0i3c_write(dev, reg);\r\nreg = mei_me_d0i3c_read(dev);\r\nreturn reg;\r\n}\r\nstatic int mei_me_d0i3_enter_sync(struct mei_device *dev)\r\n{\r\nstruct mei_me_hw *hw = to_me_hw(dev);\r\nunsigned long d0i3_timeout = mei_secs_to_jiffies(MEI_D0I3_TIMEOUT);\r\nunsigned long pgi_timeout = mei_secs_to_jiffies(MEI_PGI_TIMEOUT);\r\nint ret;\r\nu32 reg;\r\nreg = mei_me_d0i3c_read(dev);\r\nif (reg & H_D0I3C_I3) {\r\ndev_dbg(dev->dev, "d0i3 set not needed\n");\r\nret = 0;\r\ngoto on;\r\n}\r\ndev->pg_event = MEI_PG_EVENT_WAIT;\r\nret = mei_hbm_pg(dev, MEI_PG_ISOLATION_ENTRY_REQ_CMD);\r\nif (ret)\r\ngoto out;\r\nmutex_unlock(&dev->device_lock);\r\nwait_event_timeout(dev->wait_pg,\r\ndev->pg_event == MEI_PG_EVENT_RECEIVED, pgi_timeout);\r\nmutex_lock(&dev->device_lock);\r\nif (dev->pg_event != MEI_PG_EVENT_RECEIVED) {\r\nret = -ETIME;\r\ngoto out;\r\n}\r\ndev->pg_event = MEI_PG_EVENT_INTR_WAIT;\r\nreg = mei_me_d0i3_set(dev, true);\r\nif (!(reg & H_D0I3C_CIP)) {\r\ndev_dbg(dev->dev, "d0i3 enter wait not needed\n");\r\nret = 0;\r\ngoto on;\r\n}\r\nmutex_unlock(&dev->device_lock);\r\nwait_event_timeout(dev->wait_pg,\r\ndev->pg_event == MEI_PG_EVENT_INTR_RECEIVED, d0i3_timeout);\r\nmutex_lock(&dev->device_lock);\r\nif (dev->pg_event != MEI_PG_EVENT_INTR_RECEIVED) {\r\nreg = mei_me_d0i3c_read(dev);\r\nif (!(reg & H_D0I3C_I3)) {\r\nret = -ETIME;\r\ngoto out;\r\n}\r\n}\r\nret = 0;\r\non:\r\nhw->pg_state = MEI_PG_ON;\r\nout:\r\ndev->pg_event = MEI_PG_EVENT_IDLE;\r\ndev_dbg(dev->dev, "d0i3 enter ret = %d\n", ret);\r\nreturn ret;\r\n}\r\nstatic int mei_me_d0i3_enter(struct mei_device *dev)\r\n{\r\nstruct mei_me_hw *hw = to_me_hw(dev);\r\nu32 reg;\r\nreg = mei_me_d0i3c_read(dev);\r\nif (reg & H_D0I3C_I3) {\r\ndev_dbg(dev->dev, "already d0i3 : set not needed\n");\r\ngoto on;\r\n}\r\nmei_me_d0i3_set(dev, false);\r\non:\r\nhw->pg_state = MEI_PG_ON;\r\ndev->pg_event = MEI_PG_EVENT_IDLE;\r\ndev_dbg(dev->dev, "d0i3 enter\n");\r\nreturn 0;\r\n}\r\nstatic int mei_me_d0i3_exit_sync(struct mei_device *dev)\r\n{\r\nstruct mei_me_hw *hw = to_me_hw(dev);\r\nunsigned long timeout = mei_secs_to_jiffies(MEI_D0I3_TIMEOUT);\r\nint ret;\r\nu32 reg;\r\ndev->pg_event = MEI_PG_EVENT_INTR_WAIT;\r\nreg = mei_me_d0i3c_read(dev);\r\nif (!(reg & H_D0I3C_I3)) {\r\ndev_dbg(dev->dev, "d0i3 exit not needed\n");\r\nret = 0;\r\ngoto off;\r\n}\r\nreg = mei_me_d0i3_unset(dev);\r\nif (!(reg & H_D0I3C_CIP)) {\r\ndev_dbg(dev->dev, "d0i3 exit wait not needed\n");\r\nret = 0;\r\ngoto off;\r\n}\r\nmutex_unlock(&dev->device_lock);\r\nwait_event_timeout(dev->wait_pg,\r\ndev->pg_event == MEI_PG_EVENT_INTR_RECEIVED, timeout);\r\nmutex_lock(&dev->device_lock);\r\nif (dev->pg_event != MEI_PG_EVENT_INTR_RECEIVED) {\r\nreg = mei_me_d0i3c_read(dev);\r\nif (reg & H_D0I3C_I3) {\r\nret = -ETIME;\r\ngoto out;\r\n}\r\n}\r\nret = 0;\r\noff:\r\nhw->pg_state = MEI_PG_OFF;\r\nout:\r\ndev->pg_event = MEI_PG_EVENT_IDLE;\r\ndev_dbg(dev->dev, "d0i3 exit ret = %d\n", ret);\r\nreturn ret;\r\n}\r\nstatic void mei_me_pg_legacy_intr(struct mei_device *dev)\r\n{\r\nstruct mei_me_hw *hw = to_me_hw(dev);\r\nif (dev->pg_event != MEI_PG_EVENT_INTR_WAIT)\r\nreturn;\r\ndev->pg_event = MEI_PG_EVENT_INTR_RECEIVED;\r\nhw->pg_state = MEI_PG_OFF;\r\nif (waitqueue_active(&dev->wait_pg))\r\nwake_up(&dev->wait_pg);\r\n}\r\nstatic void mei_me_d0i3_intr(struct mei_device *dev)\r\n{\r\nstruct mei_me_hw *hw = to_me_hw(dev);\r\nif (dev->pg_event == MEI_PG_EVENT_INTR_WAIT &&\r\n(hw->intr_source & H_D0I3C_IS)) {\r\ndev->pg_event = MEI_PG_EVENT_INTR_RECEIVED;\r\nif (hw->pg_state == MEI_PG_ON) {\r\nhw->pg_state = MEI_PG_OFF;\r\nif (dev->hbm_state != MEI_HBM_IDLE) {\r\ndev_dbg(dev->dev, "d0i3 set host ready\n");\r\nmei_me_host_set_ready(dev);\r\n}\r\n} else {\r\nhw->pg_state = MEI_PG_ON;\r\n}\r\nwake_up(&dev->wait_pg);\r\n}\r\nif (hw->pg_state == MEI_PG_ON && (hw->intr_source & H_IS)) {\r\ndev_dbg(dev->dev, "d0i3 want resume\n");\r\nmei_hbm_pg_resume(dev);\r\n}\r\n}\r\nstatic void mei_me_pg_intr(struct mei_device *dev)\r\n{\r\nstruct mei_me_hw *hw = to_me_hw(dev);\r\nif (hw->d0i3_supported)\r\nmei_me_d0i3_intr(dev);\r\nelse\r\nmei_me_pg_legacy_intr(dev);\r\n}\r\nint mei_me_pg_enter_sync(struct mei_device *dev)\r\n{\r\nstruct mei_me_hw *hw = to_me_hw(dev);\r\nif (hw->d0i3_supported)\r\nreturn mei_me_d0i3_enter_sync(dev);\r\nelse\r\nreturn mei_me_pg_legacy_enter_sync(dev);\r\n}\r\nint mei_me_pg_exit_sync(struct mei_device *dev)\r\n{\r\nstruct mei_me_hw *hw = to_me_hw(dev);\r\nif (hw->d0i3_supported)\r\nreturn mei_me_d0i3_exit_sync(dev);\r\nelse\r\nreturn mei_me_pg_legacy_exit_sync(dev);\r\n}\r\nstatic int mei_me_hw_reset(struct mei_device *dev, bool intr_enable)\r\n{\r\nstruct mei_me_hw *hw = to_me_hw(dev);\r\nint ret;\r\nu32 hcsr;\r\nif (intr_enable) {\r\nmei_me_intr_enable(dev);\r\nif (hw->d0i3_supported) {\r\nret = mei_me_d0i3_exit_sync(dev);\r\nif (ret)\r\nreturn ret;\r\n}\r\n}\r\nhcsr = mei_hcsr_read(dev);\r\nif ((hcsr & H_RST) == H_RST) {\r\ndev_warn(dev->dev, "H_RST is set = 0x%08X", hcsr);\r\nhcsr &= ~H_RST;\r\nmei_hcsr_set(dev, hcsr);\r\nhcsr = mei_hcsr_read(dev);\r\n}\r\nhcsr |= H_RST | H_IG | H_CSR_IS_MASK;\r\nif (!intr_enable)\r\nhcsr &= ~H_CSR_IE_MASK;\r\ndev->recvd_hw_ready = false;\r\nmei_hcsr_write(dev, hcsr);\r\nhcsr = mei_hcsr_read(dev);\r\nif ((hcsr & H_RST) == 0)\r\ndev_warn(dev->dev, "H_RST is not set = 0x%08X", hcsr);\r\nif ((hcsr & H_RDY) == H_RDY)\r\ndev_warn(dev->dev, "H_RDY is not cleared 0x%08X", hcsr);\r\nif (!intr_enable) {\r\nmei_me_hw_reset_release(dev);\r\nif (hw->d0i3_supported) {\r\nret = mei_me_d0i3_enter(dev);\r\nif (ret)\r\nreturn ret;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nirqreturn_t mei_me_irq_quick_handler(int irq, void *dev_id)\r\n{\r\nstruct mei_device *dev = (struct mei_device *)dev_id;\r\nstruct mei_me_hw *hw = to_me_hw(dev);\r\nu32 hcsr;\r\nhcsr = mei_hcsr_read(dev);\r\nif (!(hcsr & H_CSR_IS_MASK))\r\nreturn IRQ_NONE;\r\nhw->intr_source = hcsr & H_CSR_IS_MASK;\r\ndev_dbg(dev->dev, "interrupt source 0x%08X.\n", hw->intr_source);\r\nmei_hcsr_write(dev, hcsr);\r\nreturn IRQ_WAKE_THREAD;\r\n}\r\nirqreturn_t mei_me_irq_thread_handler(int irq, void *dev_id)\r\n{\r\nstruct mei_device *dev = (struct mei_device *) dev_id;\r\nstruct mei_cl_cb complete_list;\r\ns32 slots;\r\nint rets = 0;\r\ndev_dbg(dev->dev, "function called after ISR to handle the interrupt processing.\n");\r\nmutex_lock(&dev->device_lock);\r\nmei_io_list_init(&complete_list);\r\nif (!mei_hw_is_ready(dev) && dev->dev_state != MEI_DEV_RESETTING) {\r\ndev_warn(dev->dev, "FW not ready: resetting.\n");\r\nschedule_work(&dev->reset_work);\r\ngoto end;\r\n}\r\nmei_me_pg_intr(dev);\r\nif (!mei_host_is_ready(dev)) {\r\nif (mei_hw_is_ready(dev)) {\r\ndev_dbg(dev->dev, "we need to start the dev.\n");\r\ndev->recvd_hw_ready = true;\r\nwake_up(&dev->wait_hw_ready);\r\n} else {\r\ndev_dbg(dev->dev, "Spurious Interrupt\n");\r\n}\r\ngoto end;\r\n}\r\nslots = mei_count_full_read_slots(dev);\r\nwhile (slots > 0) {\r\ndev_dbg(dev->dev, "slots to read = %08x\n", slots);\r\nrets = mei_irq_read_handler(dev, &complete_list, &slots);\r\nif (rets == -ENODATA)\r\nbreak;\r\nif (rets && dev->dev_state != MEI_DEV_RESETTING) {\r\ndev_err(dev->dev, "mei_irq_read_handler ret = %d.\n",\r\nrets);\r\nschedule_work(&dev->reset_work);\r\ngoto end;\r\n}\r\n}\r\ndev->hbuf_is_ready = mei_hbuf_is_ready(dev);\r\nif (dev->pg_event != MEI_PG_EVENT_WAIT &&\r\ndev->pg_event != MEI_PG_EVENT_RECEIVED) {\r\nrets = mei_irq_write_handler(dev, &complete_list);\r\ndev->hbuf_is_ready = mei_hbuf_is_ready(dev);\r\n}\r\nmei_irq_compl_handler(dev, &complete_list);\r\nend:\r\ndev_dbg(dev->dev, "interrupt thread end ret = %d\n", rets);\r\nmutex_unlock(&dev->device_lock);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic bool mei_me_fw_type_nm(struct pci_dev *pdev)\r\n{\r\nu32 reg;\r\npci_read_config_dword(pdev, PCI_CFG_HFS_2, &reg);\r\nreturn (reg & 0x600) == 0x200;\r\n}\r\nstatic bool mei_me_fw_type_sps(struct pci_dev *pdev)\r\n{\r\nu32 reg;\r\npci_read_config_dword(pdev, PCI_CFG_HFS_1, &reg);\r\nreturn (reg & 0xf0000) == 0xf0000;\r\n}\r\nstruct mei_device *mei_me_dev_init(struct pci_dev *pdev,\r\nconst struct mei_cfg *cfg)\r\n{\r\nstruct mei_device *dev;\r\nstruct mei_me_hw *hw;\r\ndev = kzalloc(sizeof(struct mei_device) +\r\nsizeof(struct mei_me_hw), GFP_KERNEL);\r\nif (!dev)\r\nreturn NULL;\r\nhw = to_me_hw(dev);\r\nmei_device_init(dev, &pdev->dev, &mei_me_hw_ops);\r\nhw->cfg = cfg;\r\nreturn dev;\r\n}
