u32 fjes_hw_rd32(struct fjes_hw *hw, u32 reg)\r\n{\r\nu8 *base = hw->base;\r\nu32 value = 0;\r\nvalue = readl(&base[reg]);\r\nreturn value;\r\n}\r\nstatic u8 *fjes_hw_iomap(struct fjes_hw *hw)\r\n{\r\nu8 *base;\r\nif (!request_mem_region(hw->hw_res.start, hw->hw_res.size,\r\nfjes_driver_name)) {\r\npr_err("request_mem_region failed\n");\r\nreturn NULL;\r\n}\r\nbase = (u8 *)ioremap_nocache(hw->hw_res.start, hw->hw_res.size);\r\nreturn base;\r\n}\r\nstatic void fjes_hw_iounmap(struct fjes_hw *hw)\r\n{\r\niounmap(hw->base);\r\nrelease_mem_region(hw->hw_res.start, hw->hw_res.size);\r\n}\r\nint fjes_hw_reset(struct fjes_hw *hw)\r\n{\r\nunion REG_DCTL dctl;\r\nint timeout;\r\ndctl.reg = 0;\r\ndctl.bits.reset = 1;\r\nwr32(XSCT_DCTL, dctl.reg);\r\ntimeout = FJES_DEVICE_RESET_TIMEOUT * 1000;\r\ndctl.reg = rd32(XSCT_DCTL);\r\nwhile ((dctl.bits.reset == 1) && (timeout > 0)) {\r\nmsleep(1000);\r\ndctl.reg = rd32(XSCT_DCTL);\r\ntimeout -= 1000;\r\n}\r\nreturn timeout > 0 ? 0 : -EIO;\r\n}\r\nstatic int fjes_hw_get_max_epid(struct fjes_hw *hw)\r\n{\r\nunion REG_MAX_EP info;\r\ninfo.reg = rd32(XSCT_MAX_EP);\r\nreturn info.bits.maxep;\r\n}\r\nstatic int fjes_hw_get_my_epid(struct fjes_hw *hw)\r\n{\r\nunion REG_OWNER_EPID info;\r\ninfo.reg = rd32(XSCT_OWNER_EPID);\r\nreturn info.bits.epid;\r\n}\r\nstatic int fjes_hw_alloc_shared_status_region(struct fjes_hw *hw)\r\n{\r\nsize_t size;\r\nsize = sizeof(struct fjes_device_shared_info) +\r\n(sizeof(u8) * hw->max_epid);\r\nhw->hw_info.share = kzalloc(size, GFP_KERNEL);\r\nif (!hw->hw_info.share)\r\nreturn -ENOMEM;\r\nhw->hw_info.share->epnum = hw->max_epid;\r\nreturn 0;\r\n}\r\nstatic void fjes_hw_free_shared_status_region(struct fjes_hw *hw)\r\n{\r\nkfree(hw->hw_info.share);\r\nhw->hw_info.share = NULL;\r\n}\r\nstatic int fjes_hw_alloc_epbuf(struct epbuf_handler *epbh)\r\n{\r\nvoid *mem;\r\nmem = vzalloc(EP_BUFFER_SIZE);\r\nif (!mem)\r\nreturn -ENOMEM;\r\nepbh->buffer = mem;\r\nepbh->size = EP_BUFFER_SIZE;\r\nepbh->info = (union ep_buffer_info *)mem;\r\nepbh->ring = (u8 *)(mem + sizeof(union ep_buffer_info));\r\nreturn 0;\r\n}\r\nstatic void fjes_hw_free_epbuf(struct epbuf_handler *epbh)\r\n{\r\nvfree(epbh->buffer);\r\nepbh->buffer = NULL;\r\nepbh->size = 0;\r\nepbh->info = NULL;\r\nepbh->ring = NULL;\r\n}\r\nvoid fjes_hw_setup_epbuf(struct epbuf_handler *epbh, u8 *mac_addr, u32 mtu)\r\n{\r\nunion ep_buffer_info *info = epbh->info;\r\nu16 vlan_id[EP_BUFFER_SUPPORT_VLAN_MAX];\r\nint i;\r\nfor (i = 0; i < EP_BUFFER_SUPPORT_VLAN_MAX; i++)\r\nvlan_id[i] = info->v1i.vlan_id[i];\r\nmemset(info, 0, sizeof(union ep_buffer_info));\r\ninfo->v1i.version = 0;\r\nfor (i = 0; i < ETH_ALEN; i++)\r\ninfo->v1i.mac_addr[i] = mac_addr[i];\r\ninfo->v1i.head = 0;\r\ninfo->v1i.tail = 1;\r\ninfo->v1i.info_size = sizeof(union ep_buffer_info);\r\ninfo->v1i.buffer_size = epbh->size - info->v1i.info_size;\r\ninfo->v1i.frame_max = FJES_MTU_TO_FRAME_SIZE(mtu);\r\ninfo->v1i.count_max =\r\nEP_RING_NUM(info->v1i.buffer_size, info->v1i.frame_max);\r\nfor (i = 0; i < EP_BUFFER_SUPPORT_VLAN_MAX; i++)\r\ninfo->v1i.vlan_id[i] = vlan_id[i];\r\n}\r\nvoid\r\nfjes_hw_init_command_registers(struct fjes_hw *hw,\r\nstruct fjes_device_command_param *param)\r\n{\r\nwr32(XSCT_REQBL, (__le32)(param->req_len));\r\nwr32(XSCT_RESPBL, (__le32)(param->res_len));\r\nwr32(XSCT_REQBAL,\r\n(__le32)(param->req_start & GENMASK_ULL(31, 0)));\r\nwr32(XSCT_REQBAH,\r\n(__le32)((param->req_start & GENMASK_ULL(63, 32)) >> 32));\r\nwr32(XSCT_RESPBAL,\r\n(__le32)(param->res_start & GENMASK_ULL(31, 0)));\r\nwr32(XSCT_RESPBAH,\r\n(__le32)((param->res_start & GENMASK_ULL(63, 32)) >> 32));\r\nwr32(XSCT_SHSTSAL,\r\n(__le32)(param->share_start & GENMASK_ULL(31, 0)));\r\nwr32(XSCT_SHSTSAH,\r\n(__le32)((param->share_start & GENMASK_ULL(63, 32)) >> 32));\r\n}\r\nstatic int fjes_hw_setup(struct fjes_hw *hw)\r\n{\r\nu8 mac[ETH_ALEN] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };\r\nstruct fjes_device_command_param param;\r\nstruct ep_share_mem_info *buf_pair;\r\nsize_t mem_size;\r\nint result;\r\nint epidx;\r\nvoid *buf;\r\nhw->hw_info.max_epid = &hw->max_epid;\r\nhw->hw_info.my_epid = &hw->my_epid;\r\nbuf = kcalloc(hw->max_epid, sizeof(struct ep_share_mem_info),\r\nGFP_KERNEL);\r\nif (!buf)\r\nreturn -ENOMEM;\r\nhw->ep_shm_info = (struct ep_share_mem_info *)buf;\r\nmem_size = FJES_DEV_REQ_BUF_SIZE(hw->max_epid);\r\nhw->hw_info.req_buf = kzalloc(mem_size, GFP_KERNEL);\r\nif (!(hw->hw_info.req_buf))\r\nreturn -ENOMEM;\r\nhw->hw_info.req_buf_size = mem_size;\r\nmem_size = FJES_DEV_RES_BUF_SIZE(hw->max_epid);\r\nhw->hw_info.res_buf = kzalloc(mem_size, GFP_KERNEL);\r\nif (!(hw->hw_info.res_buf))\r\nreturn -ENOMEM;\r\nhw->hw_info.res_buf_size = mem_size;\r\nresult = fjes_hw_alloc_shared_status_region(hw);\r\nif (result)\r\nreturn result;\r\nhw->hw_info.buffer_share_bit = 0;\r\nhw->hw_info.buffer_unshare_reserve_bit = 0;\r\nfor (epidx = 0; epidx < hw->max_epid; epidx++) {\r\nif (epidx != hw->my_epid) {\r\nbuf_pair = &hw->ep_shm_info[epidx];\r\nresult = fjes_hw_alloc_epbuf(&buf_pair->tx);\r\nif (result)\r\nreturn result;\r\nresult = fjes_hw_alloc_epbuf(&buf_pair->rx);\r\nif (result)\r\nreturn result;\r\nfjes_hw_setup_epbuf(&buf_pair->tx, mac,\r\nfjes_support_mtu[0]);\r\nfjes_hw_setup_epbuf(&buf_pair->rx, mac,\r\nfjes_support_mtu[0]);\r\n}\r\n}\r\nmemset(&param, 0, sizeof(param));\r\nparam.req_len = hw->hw_info.req_buf_size;\r\nparam.req_start = __pa(hw->hw_info.req_buf);\r\nparam.res_len = hw->hw_info.res_buf_size;\r\nparam.res_start = __pa(hw->hw_info.res_buf);\r\nparam.share_start = __pa(hw->hw_info.share->ep_status);\r\nfjes_hw_init_command_registers(hw, &param);\r\nreturn 0;\r\n}\r\nstatic void fjes_hw_cleanup(struct fjes_hw *hw)\r\n{\r\nint epidx;\r\nif (!hw->ep_shm_info)\r\nreturn;\r\nfjes_hw_free_shared_status_region(hw);\r\nkfree(hw->hw_info.req_buf);\r\nhw->hw_info.req_buf = NULL;\r\nkfree(hw->hw_info.res_buf);\r\nhw->hw_info.res_buf = NULL;\r\nfor (epidx = 0; epidx < hw->max_epid ; epidx++) {\r\nif (epidx == hw->my_epid)\r\ncontinue;\r\nfjes_hw_free_epbuf(&hw->ep_shm_info[epidx].tx);\r\nfjes_hw_free_epbuf(&hw->ep_shm_info[epidx].rx);\r\n}\r\nkfree(hw->ep_shm_info);\r\nhw->ep_shm_info = NULL;\r\n}\r\nint fjes_hw_init(struct fjes_hw *hw)\r\n{\r\nint ret;\r\nhw->base = fjes_hw_iomap(hw);\r\nif (!hw->base)\r\nreturn -EIO;\r\nret = fjes_hw_reset(hw);\r\nif (ret)\r\nreturn ret;\r\nfjes_hw_set_irqmask(hw, REG_ICTL_MASK_ALL, true);\r\nINIT_WORK(&hw->update_zone_task, fjes_hw_update_zone_task);\r\nINIT_WORK(&hw->epstop_task, fjes_hw_epstop_task);\r\nmutex_init(&hw->hw_info.lock);\r\nhw->max_epid = fjes_hw_get_max_epid(hw);\r\nhw->my_epid = fjes_hw_get_my_epid(hw);\r\nif ((hw->max_epid == 0) || (hw->my_epid >= hw->max_epid))\r\nreturn -ENXIO;\r\nret = fjes_hw_setup(hw);\r\nreturn ret;\r\n}\r\nvoid fjes_hw_exit(struct fjes_hw *hw)\r\n{\r\nint ret;\r\nif (hw->base) {\r\nret = fjes_hw_reset(hw);\r\nif (ret)\r\npr_err("%s: reset error", __func__);\r\nfjes_hw_iounmap(hw);\r\nhw->base = NULL;\r\n}\r\nfjes_hw_cleanup(hw);\r\ncancel_work_sync(&hw->update_zone_task);\r\ncancel_work_sync(&hw->epstop_task);\r\n}\r\nstatic enum fjes_dev_command_response_e\r\nfjes_hw_issue_request_command(struct fjes_hw *hw,\r\nenum fjes_dev_command_request_type type)\r\n{\r\nenum fjes_dev_command_response_e ret = FJES_CMD_STATUS_UNKNOWN;\r\nunion REG_CR cr;\r\nunion REG_CS cs;\r\nint timeout;\r\ncr.reg = 0;\r\ncr.bits.req_start = 1;\r\ncr.bits.req_code = type;\r\nwr32(XSCT_CR, cr.reg);\r\ncr.reg = rd32(XSCT_CR);\r\nif (cr.bits.error == 0) {\r\ntimeout = FJES_COMMAND_REQ_TIMEOUT * 1000;\r\ncs.reg = rd32(XSCT_CS);\r\nwhile ((cs.bits.complete != 1) && timeout > 0) {\r\nmsleep(1000);\r\ncs.reg = rd32(XSCT_CS);\r\ntimeout -= 1000;\r\n}\r\nif (cs.bits.complete == 1)\r\nret = FJES_CMD_STATUS_NORMAL;\r\nelse if (timeout <= 0)\r\nret = FJES_CMD_STATUS_TIMEOUT;\r\n} else {\r\nswitch (cr.bits.err_info) {\r\ncase FJES_CMD_REQ_ERR_INFO_PARAM:\r\nret = FJES_CMD_STATUS_ERROR_PARAM;\r\nbreak;\r\ncase FJES_CMD_REQ_ERR_INFO_STATUS:\r\nret = FJES_CMD_STATUS_ERROR_STATUS;\r\nbreak;\r\ndefault:\r\nret = FJES_CMD_STATUS_UNKNOWN;\r\nbreak;\r\n}\r\n}\r\nreturn ret;\r\n}\r\nint fjes_hw_request_info(struct fjes_hw *hw)\r\n{\r\nunion fjes_device_command_req *req_buf = hw->hw_info.req_buf;\r\nunion fjes_device_command_res *res_buf = hw->hw_info.res_buf;\r\nenum fjes_dev_command_response_e ret;\r\nint result;\r\nmemset(req_buf, 0, hw->hw_info.req_buf_size);\r\nmemset(res_buf, 0, hw->hw_info.res_buf_size);\r\nreq_buf->info.length = FJES_DEV_COMMAND_INFO_REQ_LEN;\r\nres_buf->info.length = 0;\r\nres_buf->info.code = 0;\r\nret = fjes_hw_issue_request_command(hw, FJES_CMD_REQ_INFO);\r\nresult = 0;\r\nif (FJES_DEV_COMMAND_INFO_RES_LEN((*hw->hw_info.max_epid)) !=\r\nres_buf->info.length) {\r\nresult = -ENOMSG;\r\n} else if (ret == FJES_CMD_STATUS_NORMAL) {\r\nswitch (res_buf->info.code) {\r\ncase FJES_CMD_REQ_RES_CODE_NORMAL:\r\nresult = 0;\r\nbreak;\r\ndefault:\r\nresult = -EPERM;\r\nbreak;\r\n}\r\n} else {\r\nswitch (ret) {\r\ncase FJES_CMD_STATUS_UNKNOWN:\r\nresult = -EPERM;\r\nbreak;\r\ncase FJES_CMD_STATUS_TIMEOUT:\r\nresult = -EBUSY;\r\nbreak;\r\ncase FJES_CMD_STATUS_ERROR_PARAM:\r\nresult = -EPERM;\r\nbreak;\r\ncase FJES_CMD_STATUS_ERROR_STATUS:\r\nresult = -EPERM;\r\nbreak;\r\ndefault:\r\nresult = -EPERM;\r\nbreak;\r\n}\r\n}\r\nreturn result;\r\n}\r\nint fjes_hw_register_buff_addr(struct fjes_hw *hw, int dest_epid,\r\nstruct ep_share_mem_info *buf_pair)\r\n{\r\nunion fjes_device_command_req *req_buf = hw->hw_info.req_buf;\r\nunion fjes_device_command_res *res_buf = hw->hw_info.res_buf;\r\nenum fjes_dev_command_response_e ret;\r\nint page_count;\r\nint timeout;\r\nint i, idx;\r\nvoid *addr;\r\nint result;\r\nif (test_bit(dest_epid, &hw->hw_info.buffer_share_bit))\r\nreturn 0;\r\nmemset(req_buf, 0, hw->hw_info.req_buf_size);\r\nmemset(res_buf, 0, hw->hw_info.res_buf_size);\r\nreq_buf->share_buffer.length = FJES_DEV_COMMAND_SHARE_BUFFER_REQ_LEN(\r\nbuf_pair->tx.size,\r\nbuf_pair->rx.size);\r\nreq_buf->share_buffer.epid = dest_epid;\r\nidx = 0;\r\nreq_buf->share_buffer.buffer[idx++] = buf_pair->tx.size;\r\npage_count = buf_pair->tx.size / EP_BUFFER_INFO_SIZE;\r\nfor (i = 0; i < page_count; i++) {\r\naddr = ((u8 *)(buf_pair->tx.buffer)) +\r\n(i * EP_BUFFER_INFO_SIZE);\r\nreq_buf->share_buffer.buffer[idx++] =\r\n(__le64)(page_to_phys(vmalloc_to_page(addr)) +\r\noffset_in_page(addr));\r\n}\r\nreq_buf->share_buffer.buffer[idx++] = buf_pair->rx.size;\r\npage_count = buf_pair->rx.size / EP_BUFFER_INFO_SIZE;\r\nfor (i = 0; i < page_count; i++) {\r\naddr = ((u8 *)(buf_pair->rx.buffer)) +\r\n(i * EP_BUFFER_INFO_SIZE);\r\nreq_buf->share_buffer.buffer[idx++] =\r\n(__le64)(page_to_phys(vmalloc_to_page(addr)) +\r\noffset_in_page(addr));\r\n}\r\nres_buf->share_buffer.length = 0;\r\nres_buf->share_buffer.code = 0;\r\nret = fjes_hw_issue_request_command(hw, FJES_CMD_REQ_SHARE_BUFFER);\r\ntimeout = FJES_COMMAND_REQ_BUFF_TIMEOUT * 1000;\r\nwhile ((ret == FJES_CMD_STATUS_NORMAL) &&\r\n(res_buf->share_buffer.length ==\r\nFJES_DEV_COMMAND_SHARE_BUFFER_RES_LEN) &&\r\n(res_buf->share_buffer.code == FJES_CMD_REQ_RES_CODE_BUSY) &&\r\n(timeout > 0)) {\r\nmsleep(200 + hw->my_epid * 20);\r\ntimeout -= (200 + hw->my_epid * 20);\r\nres_buf->share_buffer.length = 0;\r\nres_buf->share_buffer.code = 0;\r\nret = fjes_hw_issue_request_command(\r\nhw, FJES_CMD_REQ_SHARE_BUFFER);\r\n}\r\nresult = 0;\r\nif (res_buf->share_buffer.length !=\r\nFJES_DEV_COMMAND_SHARE_BUFFER_RES_LEN)\r\nresult = -ENOMSG;\r\nelse if (ret == FJES_CMD_STATUS_NORMAL) {\r\nswitch (res_buf->share_buffer.code) {\r\ncase FJES_CMD_REQ_RES_CODE_NORMAL:\r\nresult = 0;\r\nset_bit(dest_epid, &hw->hw_info.buffer_share_bit);\r\nbreak;\r\ncase FJES_CMD_REQ_RES_CODE_BUSY:\r\nresult = -EBUSY;\r\nbreak;\r\ndefault:\r\nresult = -EPERM;\r\nbreak;\r\n}\r\n} else {\r\nswitch (ret) {\r\ncase FJES_CMD_STATUS_UNKNOWN:\r\nresult = -EPERM;\r\nbreak;\r\ncase FJES_CMD_STATUS_TIMEOUT:\r\nresult = -EBUSY;\r\nbreak;\r\ncase FJES_CMD_STATUS_ERROR_PARAM:\r\ncase FJES_CMD_STATUS_ERROR_STATUS:\r\ndefault:\r\nresult = -EPERM;\r\nbreak;\r\n}\r\n}\r\nreturn result;\r\n}\r\nint fjes_hw_unregister_buff_addr(struct fjes_hw *hw, int dest_epid)\r\n{\r\nunion fjes_device_command_req *req_buf = hw->hw_info.req_buf;\r\nunion fjes_device_command_res *res_buf = hw->hw_info.res_buf;\r\nstruct fjes_device_shared_info *share = hw->hw_info.share;\r\nenum fjes_dev_command_response_e ret;\r\nint timeout;\r\nint result;\r\nif (!hw->base)\r\nreturn -EPERM;\r\nif (!req_buf || !res_buf || !share)\r\nreturn -EPERM;\r\nif (!test_bit(dest_epid, &hw->hw_info.buffer_share_bit))\r\nreturn 0;\r\nmemset(req_buf, 0, hw->hw_info.req_buf_size);\r\nmemset(res_buf, 0, hw->hw_info.res_buf_size);\r\nreq_buf->unshare_buffer.length =\r\nFJES_DEV_COMMAND_UNSHARE_BUFFER_REQ_LEN;\r\nreq_buf->unshare_buffer.epid = dest_epid;\r\nres_buf->unshare_buffer.length = 0;\r\nres_buf->unshare_buffer.code = 0;\r\nret = fjes_hw_issue_request_command(hw, FJES_CMD_REQ_UNSHARE_BUFFER);\r\ntimeout = FJES_COMMAND_REQ_BUFF_TIMEOUT * 1000;\r\nwhile ((ret == FJES_CMD_STATUS_NORMAL) &&\r\n(res_buf->unshare_buffer.length ==\r\nFJES_DEV_COMMAND_UNSHARE_BUFFER_RES_LEN) &&\r\n(res_buf->unshare_buffer.code ==\r\nFJES_CMD_REQ_RES_CODE_BUSY) &&\r\n(timeout > 0)) {\r\nmsleep(200 + hw->my_epid * 20);\r\ntimeout -= (200 + hw->my_epid * 20);\r\nres_buf->unshare_buffer.length = 0;\r\nres_buf->unshare_buffer.code = 0;\r\nret =\r\nfjes_hw_issue_request_command(hw, FJES_CMD_REQ_UNSHARE_BUFFER);\r\n}\r\nresult = 0;\r\nif (res_buf->unshare_buffer.length !=\r\nFJES_DEV_COMMAND_UNSHARE_BUFFER_RES_LEN) {\r\nresult = -ENOMSG;\r\n} else if (ret == FJES_CMD_STATUS_NORMAL) {\r\nswitch (res_buf->unshare_buffer.code) {\r\ncase FJES_CMD_REQ_RES_CODE_NORMAL:\r\nresult = 0;\r\nclear_bit(dest_epid, &hw->hw_info.buffer_share_bit);\r\nbreak;\r\ncase FJES_CMD_REQ_RES_CODE_BUSY:\r\nresult = -EBUSY;\r\nbreak;\r\ndefault:\r\nresult = -EPERM;\r\nbreak;\r\n}\r\n} else {\r\nswitch (ret) {\r\ncase FJES_CMD_STATUS_UNKNOWN:\r\nresult = -EPERM;\r\nbreak;\r\ncase FJES_CMD_STATUS_TIMEOUT:\r\nresult = -EBUSY;\r\nbreak;\r\ncase FJES_CMD_STATUS_ERROR_PARAM:\r\ncase FJES_CMD_STATUS_ERROR_STATUS:\r\ndefault:\r\nresult = -EPERM;\r\nbreak;\r\n}\r\n}\r\nreturn result;\r\n}\r\nint fjes_hw_raise_interrupt(struct fjes_hw *hw, int dest_epid,\r\nenum REG_ICTL_MASK mask)\r\n{\r\nu32 ig = mask | dest_epid;\r\nwr32(XSCT_IG, cpu_to_le32(ig));\r\nreturn 0;\r\n}\r\nu32 fjes_hw_capture_interrupt_status(struct fjes_hw *hw)\r\n{\r\nu32 cur_is;\r\ncur_is = rd32(XSCT_IS);\r\nreturn cur_is;\r\n}\r\nvoid fjes_hw_set_irqmask(struct fjes_hw *hw,\r\nenum REG_ICTL_MASK intr_mask, bool mask)\r\n{\r\nif (mask)\r\nwr32(XSCT_IMS, intr_mask);\r\nelse\r\nwr32(XSCT_IMC, intr_mask);\r\n}\r\nbool fjes_hw_epid_is_same_zone(struct fjes_hw *hw, int epid)\r\n{\r\nif (epid >= hw->max_epid)\r\nreturn false;\r\nif ((hw->ep_shm_info[epid].es_status !=\r\nFJES_ZONING_STATUS_ENABLE) ||\r\n(hw->ep_shm_info[hw->my_epid].zone ==\r\nFJES_ZONING_ZONE_TYPE_NONE))\r\nreturn false;\r\nelse\r\nreturn (hw->ep_shm_info[epid].zone ==\r\nhw->ep_shm_info[hw->my_epid].zone);\r\n}\r\nint fjes_hw_epid_is_shared(struct fjes_device_shared_info *share,\r\nint dest_epid)\r\n{\r\nint value = false;\r\nif (dest_epid < share->epnum)\r\nvalue = share->ep_status[dest_epid];\r\nreturn value;\r\n}\r\nstatic bool fjes_hw_epid_is_stop_requested(struct fjes_hw *hw, int src_epid)\r\n{\r\nreturn test_bit(src_epid, &hw->txrx_stop_req_bit);\r\n}\r\nstatic bool fjes_hw_epid_is_stop_process_done(struct fjes_hw *hw, int src_epid)\r\n{\r\nreturn (hw->ep_shm_info[src_epid].tx.info->v1i.rx_status &\r\nFJES_RX_STOP_REQ_DONE);\r\n}\r\nenum ep_partner_status\r\nfjes_hw_get_partner_ep_status(struct fjes_hw *hw, int epid)\r\n{\r\nenum ep_partner_status status;\r\nif (fjes_hw_epid_is_shared(hw->hw_info.share, epid)) {\r\nif (fjes_hw_epid_is_stop_requested(hw, epid)) {\r\nstatus = EP_PARTNER_WAITING;\r\n} else {\r\nif (fjes_hw_epid_is_stop_process_done(hw, epid))\r\nstatus = EP_PARTNER_COMPLETE;\r\nelse\r\nstatus = EP_PARTNER_SHARED;\r\n}\r\n} else {\r\nstatus = EP_PARTNER_UNSHARE;\r\n}\r\nreturn status;\r\n}\r\nvoid fjes_hw_raise_epstop(struct fjes_hw *hw)\r\n{\r\nenum ep_partner_status status;\r\nint epidx;\r\nfor (epidx = 0; epidx < hw->max_epid; epidx++) {\r\nif (epidx == hw->my_epid)\r\ncontinue;\r\nstatus = fjes_hw_get_partner_ep_status(hw, epidx);\r\nswitch (status) {\r\ncase EP_PARTNER_SHARED:\r\nfjes_hw_raise_interrupt(hw, epidx,\r\nREG_ICTL_MASK_TXRX_STOP_REQ);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nset_bit(epidx, &hw->hw_info.buffer_unshare_reserve_bit);\r\nset_bit(epidx, &hw->txrx_stop_req_bit);\r\nhw->ep_shm_info[epidx].tx.info->v1i.rx_status |=\r\nFJES_RX_STOP_REQ_REQUEST;\r\n}\r\n}\r\nint fjes_hw_wait_epstop(struct fjes_hw *hw)\r\n{\r\nenum ep_partner_status status;\r\nunion ep_buffer_info *info;\r\nint wait_time = 0;\r\nint epidx;\r\nwhile (hw->hw_info.buffer_unshare_reserve_bit &&\r\n(wait_time < FJES_COMMAND_EPSTOP_WAIT_TIMEOUT * 1000)) {\r\nfor (epidx = 0; epidx < hw->max_epid; epidx++) {\r\nif (epidx == hw->my_epid)\r\ncontinue;\r\nstatus = fjes_hw_epid_is_shared(hw->hw_info.share,\r\nepidx);\r\ninfo = hw->ep_shm_info[epidx].rx.info;\r\nif ((!status ||\r\n(info->v1i.rx_status &\r\nFJES_RX_STOP_REQ_DONE)) &&\r\ntest_bit(epidx,\r\n&hw->hw_info.buffer_unshare_reserve_bit)) {\r\nclear_bit(epidx,\r\n&hw->hw_info.buffer_unshare_reserve_bit);\r\n}\r\n}\r\nmsleep(100);\r\nwait_time += 100;\r\n}\r\nfor (epidx = 0; epidx < hw->max_epid; epidx++) {\r\nif (epidx == hw->my_epid)\r\ncontinue;\r\nif (test_bit(epidx, &hw->hw_info.buffer_unshare_reserve_bit))\r\nclear_bit(epidx,\r\n&hw->hw_info.buffer_unshare_reserve_bit);\r\n}\r\nreturn (wait_time < FJES_COMMAND_EPSTOP_WAIT_TIMEOUT * 1000)\r\n? 0 : -EBUSY;\r\n}\r\nbool fjes_hw_check_epbuf_version(struct epbuf_handler *epbh, u32 version)\r\n{\r\nunion ep_buffer_info *info = epbh->info;\r\nreturn (info->common.version == version);\r\n}\r\nbool fjes_hw_check_mtu(struct epbuf_handler *epbh, u32 mtu)\r\n{\r\nunion ep_buffer_info *info = epbh->info;\r\nreturn (info->v1i.frame_max == FJES_MTU_TO_FRAME_SIZE(mtu));\r\n}\r\nbool fjes_hw_check_vlan_id(struct epbuf_handler *epbh, u16 vlan_id)\r\n{\r\nunion ep_buffer_info *info = epbh->info;\r\nbool ret = false;\r\nint i;\r\nif (vlan_id == 0) {\r\nret = true;\r\n} else {\r\nfor (i = 0; i < EP_BUFFER_SUPPORT_VLAN_MAX; i++) {\r\nif (vlan_id == info->v1i.vlan_id[i]) {\r\nret = true;\r\nbreak;\r\n}\r\n}\r\n}\r\nreturn ret;\r\n}\r\nbool fjes_hw_set_vlan_id(struct epbuf_handler *epbh, u16 vlan_id)\r\n{\r\nunion ep_buffer_info *info = epbh->info;\r\nint i;\r\nfor (i = 0; i < EP_BUFFER_SUPPORT_VLAN_MAX; i++) {\r\nif (info->v1i.vlan_id[i] == 0) {\r\ninfo->v1i.vlan_id[i] = vlan_id;\r\nreturn true;\r\n}\r\n}\r\nreturn false;\r\n}\r\nvoid fjes_hw_del_vlan_id(struct epbuf_handler *epbh, u16 vlan_id)\r\n{\r\nunion ep_buffer_info *info = epbh->info;\r\nint i;\r\nif (0 != vlan_id) {\r\nfor (i = 0; i < EP_BUFFER_SUPPORT_VLAN_MAX; i++) {\r\nif (vlan_id == info->v1i.vlan_id[i])\r\ninfo->v1i.vlan_id[i] = 0;\r\n}\r\n}\r\n}\r\nbool fjes_hw_epbuf_rx_is_empty(struct epbuf_handler *epbh)\r\n{\r\nunion ep_buffer_info *info = epbh->info;\r\nif (info->v1i.count_max == 0)\r\nreturn true;\r\nreturn EP_RING_EMPTY(info->v1i.head, info->v1i.tail,\r\ninfo->v1i.count_max);\r\n}\r\nvoid *fjes_hw_epbuf_rx_curpkt_get_addr(struct epbuf_handler *epbh,\r\nsize_t *psize)\r\n{\r\nunion ep_buffer_info *info = epbh->info;\r\nstruct esmem_frame *ring_frame;\r\nvoid *frame;\r\nring_frame = (struct esmem_frame *)&(epbh->ring[EP_RING_INDEX\r\n(info->v1i.head,\r\ninfo->v1i.count_max) *\r\ninfo->v1i.frame_max]);\r\n*psize = (size_t)ring_frame->frame_size;\r\nframe = ring_frame->frame_data;\r\nreturn frame;\r\n}\r\nvoid fjes_hw_epbuf_rx_curpkt_drop(struct epbuf_handler *epbh)\r\n{\r\nunion ep_buffer_info *info = epbh->info;\r\nif (fjes_hw_epbuf_rx_is_empty(epbh))\r\nreturn;\r\nEP_RING_INDEX_INC(epbh->info->v1i.head, info->v1i.count_max);\r\n}\r\nint fjes_hw_epbuf_tx_pkt_send(struct epbuf_handler *epbh,\r\nvoid *frame, size_t size)\r\n{\r\nunion ep_buffer_info *info = epbh->info;\r\nstruct esmem_frame *ring_frame;\r\nif (EP_RING_FULL(info->v1i.head, info->v1i.tail, info->v1i.count_max))\r\nreturn -ENOBUFS;\r\nring_frame = (struct esmem_frame *)&(epbh->ring[EP_RING_INDEX\r\n(info->v1i.tail - 1,\r\ninfo->v1i.count_max) *\r\ninfo->v1i.frame_max]);\r\nring_frame->frame_size = size;\r\nmemcpy((void *)(ring_frame->frame_data), (void *)frame, size);\r\nEP_RING_INDEX_INC(epbh->info->v1i.tail, info->v1i.count_max);\r\nreturn 0;\r\n}\r\nstatic void fjes_hw_update_zone_task(struct work_struct *work)\r\n{\r\nstruct fjes_hw *hw = container_of(work,\r\nstruct fjes_hw, update_zone_task);\r\nstruct my_s {u8 es_status; u8 zone; } *info;\r\nunion fjes_device_command_res *res_buf;\r\nenum ep_partner_status pstatus;\r\nstruct fjes_adapter *adapter;\r\nstruct net_device *netdev;\r\nulong unshare_bit = 0;\r\nulong share_bit = 0;\r\nulong irq_bit = 0;\r\nint epidx;\r\nint ret;\r\nadapter = (struct fjes_adapter *)hw->back;\r\nnetdev = adapter->netdev;\r\nres_buf = hw->hw_info.res_buf;\r\ninfo = (struct my_s *)&res_buf->info.info;\r\nmutex_lock(&hw->hw_info.lock);\r\nret = fjes_hw_request_info(hw);\r\nswitch (ret) {\r\ncase -ENOMSG:\r\ncase -EBUSY:\r\ndefault:\r\nif (!work_pending(&adapter->force_close_task)) {\r\nadapter->force_reset = true;\r\nschedule_work(&adapter->force_close_task);\r\n}\r\nbreak;\r\ncase 0:\r\nfor (epidx = 0; epidx < hw->max_epid; epidx++) {\r\nif (epidx == hw->my_epid) {\r\nhw->ep_shm_info[epidx].es_status =\r\ninfo[epidx].es_status;\r\nhw->ep_shm_info[epidx].zone =\r\ninfo[epidx].zone;\r\ncontinue;\r\n}\r\npstatus = fjes_hw_get_partner_ep_status(hw, epidx);\r\nswitch (pstatus) {\r\ncase EP_PARTNER_UNSHARE:\r\ndefault:\r\nif ((info[epidx].zone !=\r\nFJES_ZONING_ZONE_TYPE_NONE) &&\r\n(info[epidx].es_status ==\r\nFJES_ZONING_STATUS_ENABLE) &&\r\n(info[epidx].zone ==\r\ninfo[hw->my_epid].zone))\r\nset_bit(epidx, &share_bit);\r\nelse\r\nset_bit(epidx, &unshare_bit);\r\nbreak;\r\ncase EP_PARTNER_COMPLETE:\r\ncase EP_PARTNER_WAITING:\r\nif ((info[epidx].zone ==\r\nFJES_ZONING_ZONE_TYPE_NONE) ||\r\n(info[epidx].es_status !=\r\nFJES_ZONING_STATUS_ENABLE) ||\r\n(info[epidx].zone !=\r\ninfo[hw->my_epid].zone)) {\r\nset_bit(epidx,\r\n&adapter->unshare_watch_bitmask);\r\nset_bit(epidx,\r\n&hw->hw_info.buffer_unshare_reserve_bit);\r\n}\r\nbreak;\r\ncase EP_PARTNER_SHARED:\r\nif ((info[epidx].zone ==\r\nFJES_ZONING_ZONE_TYPE_NONE) ||\r\n(info[epidx].es_status !=\r\nFJES_ZONING_STATUS_ENABLE) ||\r\n(info[epidx].zone !=\r\ninfo[hw->my_epid].zone))\r\nset_bit(epidx, &irq_bit);\r\nbreak;\r\n}\r\nhw->ep_shm_info[epidx].es_status =\r\ninfo[epidx].es_status;\r\nhw->ep_shm_info[epidx].zone = info[epidx].zone;\r\n}\r\nbreak;\r\n}\r\nmutex_unlock(&hw->hw_info.lock);\r\nfor (epidx = 0; epidx < hw->max_epid; epidx++) {\r\nif (epidx == hw->my_epid)\r\ncontinue;\r\nif (test_bit(epidx, &share_bit)) {\r\nfjes_hw_setup_epbuf(&hw->ep_shm_info[epidx].tx,\r\nnetdev->dev_addr, netdev->mtu);\r\nmutex_lock(&hw->hw_info.lock);\r\nret = fjes_hw_register_buff_addr(\r\nhw, epidx, &hw->ep_shm_info[epidx]);\r\nswitch (ret) {\r\ncase 0:\r\nbreak;\r\ncase -ENOMSG:\r\ncase -EBUSY:\r\ndefault:\r\nif (!work_pending(&adapter->force_close_task)) {\r\nadapter->force_reset = true;\r\nschedule_work(\r\n&adapter->force_close_task);\r\n}\r\nbreak;\r\n}\r\nmutex_unlock(&hw->hw_info.lock);\r\n}\r\nif (test_bit(epidx, &unshare_bit)) {\r\nmutex_lock(&hw->hw_info.lock);\r\nret = fjes_hw_unregister_buff_addr(hw, epidx);\r\nswitch (ret) {\r\ncase 0:\r\nbreak;\r\ncase -ENOMSG:\r\ncase -EBUSY:\r\ndefault:\r\nif (!work_pending(&adapter->force_close_task)) {\r\nadapter->force_reset = true;\r\nschedule_work(\r\n&adapter->force_close_task);\r\n}\r\nbreak;\r\n}\r\nmutex_unlock(&hw->hw_info.lock);\r\nif (ret == 0)\r\nfjes_hw_setup_epbuf(\r\n&hw->ep_shm_info[epidx].tx,\r\nnetdev->dev_addr, netdev->mtu);\r\n}\r\nif (test_bit(epidx, &irq_bit)) {\r\nfjes_hw_raise_interrupt(hw, epidx,\r\nREG_ICTL_MASK_TXRX_STOP_REQ);\r\nset_bit(epidx, &hw->txrx_stop_req_bit);\r\nhw->ep_shm_info[epidx].tx.\r\ninfo->v1i.rx_status |=\r\nFJES_RX_STOP_REQ_REQUEST;\r\nset_bit(epidx, &hw->hw_info.buffer_unshare_reserve_bit);\r\n}\r\n}\r\nif (irq_bit || adapter->unshare_watch_bitmask) {\r\nif (!work_pending(&adapter->unshare_watch_task))\r\nqueue_work(adapter->control_wq,\r\n&adapter->unshare_watch_task);\r\n}\r\n}\r\nstatic void fjes_hw_epstop_task(struct work_struct *work)\r\n{\r\nstruct fjes_hw *hw = container_of(work, struct fjes_hw, epstop_task);\r\nstruct fjes_adapter *adapter = (struct fjes_adapter *)hw->back;\r\nulong remain_bit;\r\nint epid_bit;\r\nwhile ((remain_bit = hw->epstop_req_bit)) {\r\nfor (epid_bit = 0; remain_bit; remain_bit >>= 1, epid_bit++) {\r\nif (remain_bit & 1) {\r\nhw->ep_shm_info[epid_bit].\r\ntx.info->v1i.rx_status |=\r\nFJES_RX_STOP_REQ_DONE;\r\nclear_bit(epid_bit, &hw->epstop_req_bit);\r\nset_bit(epid_bit,\r\n&adapter->unshare_watch_bitmask);\r\nif (!work_pending(&adapter->unshare_watch_task))\r\nqueue_work(\r\nadapter->control_wq,\r\n&adapter->unshare_watch_task);\r\n}\r\n}\r\n}\r\n}
