static map_word flash_read(struct map_info *map, unsigned long ofs)\r\n{\r\nmap_word tmp;\r\ntmp.x[0] = *(flash_data *)(map->map_priv_1 + ofs);\r\nreturn tmp;\r\n}\r\nstatic void flash_copy_from(struct map_info *map, void *to,\r\nunsigned long from, ssize_t len)\r\n{\r\nmemcpy(to, (void *)(map->map_priv_1 + from), len);\r\n}\r\nstatic void flash_write(struct map_info *map, map_word d, unsigned long adr)\r\n{\r\n*(flash_data *)(map->map_priv_1 + adr) = (flash_data)d.x[0];\r\n}\r\nstatic struct mtd_info *probe_cs(struct map_info *map_cs)\r\n{\r\nstruct mtd_info *mtd_cs = NULL;\r\nprintk(KERN_INFO\r\n"%s: Probing a 0x%08lx bytes large window at 0x%08lx.\n",\r\nmap_cs->name, map_cs->size, map_cs->map_priv_1);\r\n#ifdef CONFIG_MTD_CFI\r\nmtd_cs = do_map_probe("cfi_probe", map_cs);\r\n#endif\r\n#ifdef CONFIG_MTD_JEDECPROBE\r\nif (!mtd_cs)\r\nmtd_cs = do_map_probe("jedec_probe", map_cs);\r\n#endif\r\nreturn mtd_cs;\r\n}\r\nstatic struct mtd_info *flash_probe(void)\r\n{\r\nstruct mtd_info *mtd_cse0;\r\nstruct mtd_info *mtd_cse1;\r\nstruct mtd_info *mtd_cse;\r\nmtd_cse0 = probe_cs(&map_cse0);\r\nmtd_cse1 = probe_cs(&map_cse1);\r\nif (!mtd_cse0 && !mtd_cse1) {\r\nreturn NULL;\r\n}\r\nif (mtd_cse0 && mtd_cse1) {\r\nstruct mtd_info *mtds[] = { mtd_cse0, mtd_cse1 };\r\nmtd_cse = mtd_concat_create(mtds, ARRAY_SIZE(mtds),\r\n"cse0+cse1");\r\nif (!mtd_cse) {\r\nprintk(KERN_ERR "%s and %s: Concatenation failed!\n",\r\nmap_cse0.name, map_cse1.name);\r\nmtd_cse = mtd_cse0;\r\nmap_destroy(mtd_cse1);\r\n}\r\n} else {\r\nmtd_cse = mtd_cse0? mtd_cse0 : mtd_cse1;\r\n}\r\nreturn mtd_cse;\r\n}\r\nstatic int __init init_axis_flash(void)\r\n{\r\nstruct mtd_info *mymtd;\r\nint err = 0;\r\nint pidx = 0;\r\nstruct partitiontable_head *ptable_head = NULL;\r\nstruct partitiontable_entry *ptable;\r\nint use_default_ptable = 1;\r\nconst char pmsg[] = " /dev/flash%d at 0x%08x, size 0x%08x\n";\r\nif (!(mymtd = flash_probe())) {\r\nprintk(KERN_INFO "axisflashmap: Found no flash chip.\n");\r\n} else {\r\nprintk(KERN_INFO "%s: 0x%08x bytes of flash memory.\n",\r\nmymtd->name, mymtd->size);\r\naxisflash_mtd = mymtd;\r\n}\r\nif (mymtd) {\r\nmymtd->owner = THIS_MODULE;\r\nptable_head = (struct partitiontable_head *)(FLASH_CACHED_ADDR +\r\nCONFIG_ETRAX_PTABLE_SECTOR +\r\nPARTITION_TABLE_OFFSET);\r\n}\r\npidx++;\r\nif (ptable_head && (ptable_head->magic == PARTITION_TABLE_MAGIC)\r\n&& (ptable_head->size <\r\n(MAX_PARTITIONS * sizeof(struct partitiontable_entry) +\r\nPARTITIONTABLE_END_MARKER_SIZE))\r\n&& (*(unsigned long*)((void*)ptable_head + sizeof(*ptable_head) +\r\nptable_head->size -\r\nPARTITIONTABLE_END_MARKER_SIZE)\r\n== PARTITIONTABLE_END_MARKER)) {\r\nint ptable_ok = 0;\r\nstruct partitiontable_entry *max_addr =\r\n(struct partitiontable_entry *)\r\n((unsigned long)ptable_head + sizeof(*ptable_head) +\r\nptable_head->size);\r\nunsigned long offset = CONFIG_ETRAX_PTABLE_SECTOR;\r\nunsigned char *p;\r\nunsigned long csum = 0;\r\nptable = (struct partitiontable_entry *)\r\n((unsigned long)ptable_head + sizeof(*ptable_head));\r\np = (unsigned char*) ptable;\r\nwhile (p <= (unsigned char*)max_addr) {\r\ncsum += *p++;\r\ncsum += *p++;\r\ncsum += *p++;\r\ncsum += *p++;\r\n}\r\nptable_ok = (csum == ptable_head->checksum);\r\nprintk(KERN_INFO " Found a%s partition table at 0x%p-0x%p.\n",\r\n(ptable_ok ? " valid" : "n invalid"), ptable_head,\r\nmax_addr);\r\nwhile (ptable_ok\r\n&& ptable->offset != 0xffffffff\r\n&& ptable < max_addr\r\n&& pidx < MAX_PARTITIONS) {\r\naxis_partitions[pidx].offset = offset + ptable->offset;\r\naxis_partitions[pidx].size = ptable->size;\r\nprintk(pmsg, pidx, axis_partitions[pidx].offset,\r\naxis_partitions[pidx].size);\r\npidx++;\r\nptable++;\r\n}\r\nuse_default_ptable = !ptable_ok;\r\n}\r\nif (romfs_in_flash) {\r\naxis_partitions[pidx].name = "romfs";\r\naxis_partitions[pidx].size = romfs_length;\r\naxis_partitions[pidx].offset = romfs_start - FLASH_CACHED_ADDR;\r\naxis_partitions[pidx].mask_flags |= MTD_WRITEABLE;\r\nprintk(KERN_INFO\r\n" Adding readonly flash partition for romfs image:\n");\r\nprintk(pmsg, pidx, axis_partitions[pidx].offset,\r\naxis_partitions[pidx].size);\r\npidx++;\r\n}\r\n#ifdef CONFIG_ETRAX_AXISFLASHMAP_MTD0WHOLE\r\nif (mymtd) {\r\nmain_partition.size = mymtd->size;\r\nerr = mtd_device_register(mymtd, &main_partition, 1);\r\nif (err)\r\npanic("axisflashmap: Could not initialize "\r\n"partition for whole main mtd device!\n");\r\n}\r\n#endif\r\nif (mymtd) {\r\nif (use_default_ptable) {\r\nprintk(KERN_INFO " Using default partition table.\n");\r\nerr = mtd_device_register(mymtd,\r\naxis_default_partitions,\r\nNUM_DEFAULT_PARTITIONS);\r\n} else {\r\nerr = mtd_device_register(mymtd, axis_partitions,\r\npidx);\r\n}\r\nif (err)\r\npanic("axisflashmap could not add MTD partitions!\n");\r\n}\r\nif (!romfs_in_flash) {\r\n#if !defined(CONFIG_MTD_MTDRAM) || (CONFIG_MTDRAM_TOTAL_SIZE != 0) || (CONFIG_MTDRAM_ABS_POS != 0)\r\nprintk(KERN_EMERG "axisflashmap: Cannot create an MTD RAM "\r\n"device due to kernel (mis)configuration!\n");\r\npanic("This kernel cannot boot from RAM!\n");\r\n#else\r\nstruct mtd_info *mtd_ram;\r\nmtd_ram = kmalloc(sizeof(struct mtd_info), GFP_KERNEL);\r\nif (!mtd_ram)\r\npanic("axisflashmap couldn't allocate memory for "\r\n"mtd_info!\n");\r\nprintk(KERN_INFO " Adding RAM partition for romfs image:\n");\r\nprintk(pmsg, pidx, (unsigned)romfs_start,\r\n(unsigned)romfs_length);\r\nerr = mtdram_init_device(mtd_ram,\r\n(void *)romfs_start,\r\nromfs_length,\r\n"romfs");\r\nif (err)\r\npanic("axisflashmap could not initialize MTD RAM "\r\n"device!\n");\r\n#endif\r\n}\r\nreturn err;\r\n}
