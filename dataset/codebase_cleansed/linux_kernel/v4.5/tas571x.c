static int tas571x_register_size(struct tas571x_private *priv, unsigned int reg)\r\n{\r\nswitch (reg) {\r\ncase TAS571X_MVOL_REG:\r\ncase TAS571X_CH1_VOL_REG:\r\ncase TAS571X_CH2_VOL_REG:\r\nreturn priv->chip->vol_reg_size;\r\ndefault:\r\nreturn 1;\r\n}\r\n}\r\nstatic int tas571x_reg_write(void *context, unsigned int reg,\r\nunsigned int value)\r\n{\r\nstruct i2c_client *client = context;\r\nstruct tas571x_private *priv = i2c_get_clientdata(client);\r\nunsigned int i, size;\r\nuint8_t buf[5];\r\nint ret;\r\nsize = tas571x_register_size(priv, reg);\r\nbuf[0] = reg;\r\nfor (i = size; i >= 1; --i) {\r\nbuf[i] = value;\r\nvalue >>= 8;\r\n}\r\nret = i2c_master_send(client, buf, size + 1);\r\nif (ret == size + 1)\r\nreturn 0;\r\nelse if (ret < 0)\r\nreturn ret;\r\nelse\r\nreturn -EIO;\r\n}\r\nstatic int tas571x_reg_read(void *context, unsigned int reg,\r\nunsigned int *value)\r\n{\r\nstruct i2c_client *client = context;\r\nstruct tas571x_private *priv = i2c_get_clientdata(client);\r\nuint8_t send_buf, recv_buf[4];\r\nstruct i2c_msg msgs[2];\r\nunsigned int size;\r\nunsigned int i;\r\nint ret;\r\nsize = tas571x_register_size(priv, reg);\r\nsend_buf = reg;\r\nmsgs[0].addr = client->addr;\r\nmsgs[0].len = sizeof(send_buf);\r\nmsgs[0].buf = &send_buf;\r\nmsgs[0].flags = 0;\r\nmsgs[1].addr = client->addr;\r\nmsgs[1].len = size;\r\nmsgs[1].buf = recv_buf;\r\nmsgs[1].flags = I2C_M_RD;\r\nret = i2c_transfer(client->adapter, msgs, ARRAY_SIZE(msgs));\r\nif (ret < 0)\r\nreturn ret;\r\nelse if (ret != ARRAY_SIZE(msgs))\r\nreturn -EIO;\r\n*value = 0;\r\nfor (i = 0; i < size; i++) {\r\n*value <<= 8;\r\n*value |= recv_buf[i];\r\n}\r\nreturn 0;\r\n}\r\nstatic int tas571x_set_dai_fmt(struct snd_soc_dai *dai, unsigned int format)\r\n{\r\nstruct tas571x_private *priv = snd_soc_codec_get_drvdata(dai->codec);\r\npriv->format = format;\r\nreturn 0;\r\n}\r\nstatic int tas571x_hw_params(struct snd_pcm_substream *substream,\r\nstruct snd_pcm_hw_params *params,\r\nstruct snd_soc_dai *dai)\r\n{\r\nstruct tas571x_private *priv = snd_soc_codec_get_drvdata(dai->codec);\r\nu32 val;\r\nswitch (priv->format & SND_SOC_DAIFMT_FORMAT_MASK) {\r\ncase SND_SOC_DAIFMT_RIGHT_J:\r\nval = 0x00;\r\nbreak;\r\ncase SND_SOC_DAIFMT_I2S:\r\nval = 0x03;\r\nbreak;\r\ncase SND_SOC_DAIFMT_LEFT_J:\r\nval = 0x06;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nif (params_width(params) >= 24)\r\nval += 2;\r\nelse if (params_width(params) >= 20)\r\nval += 1;\r\nreturn regmap_update_bits(priv->regmap, TAS571X_SDI_REG,\r\nTAS571X_SDI_FMT_MASK, val);\r\n}\r\nstatic int tas571x_set_bias_level(struct snd_soc_codec *codec,\r\nenum snd_soc_bias_level level)\r\n{\r\nstruct tas571x_private *priv = snd_soc_codec_get_drvdata(codec);\r\nint ret;\r\nswitch (level) {\r\ncase SND_SOC_BIAS_ON:\r\nbreak;\r\ncase SND_SOC_BIAS_PREPARE:\r\nbreak;\r\ncase SND_SOC_BIAS_STANDBY:\r\nif (snd_soc_codec_get_bias_level(codec) == SND_SOC_BIAS_OFF) {\r\nif (!IS_ERR(priv->mclk)) {\r\nret = clk_prepare_enable(priv->mclk);\r\nif (ret) {\r\ndev_err(codec->dev,\r\n"Failed to enable master clock: %d\n",\r\nret);\r\nreturn ret;\r\n}\r\n}\r\ngpiod_set_value(priv->pdn_gpio, 0);\r\nusleep_range(5000, 6000);\r\nregcache_cache_only(priv->regmap, false);\r\nret = regcache_sync(priv->regmap);\r\nif (ret)\r\nreturn ret;\r\n}\r\nbreak;\r\ncase SND_SOC_BIAS_OFF:\r\nregcache_cache_only(priv->regmap, true);\r\ngpiod_set_value(priv->pdn_gpio, 1);\r\nif (!IS_ERR(priv->mclk))\r\nclk_disable_unprepare(priv->mclk);\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic int tas571x_i2c_probe(struct i2c_client *client,\r\nconst struct i2c_device_id *id)\r\n{\r\nstruct tas571x_private *priv;\r\nstruct device *dev = &client->dev;\r\nconst struct of_device_id *of_id;\r\nint i, ret;\r\npriv = devm_kzalloc(dev, sizeof(*priv), GFP_KERNEL);\r\nif (!priv)\r\nreturn -ENOMEM;\r\ni2c_set_clientdata(client, priv);\r\nof_id = of_match_device(tas571x_of_match, dev);\r\nif (!of_id) {\r\ndev_err(dev, "Unknown device type\n");\r\nreturn -EINVAL;\r\n}\r\npriv->chip = of_id->data;\r\npriv->mclk = devm_clk_get(dev, "mclk");\r\nif (IS_ERR(priv->mclk) && PTR_ERR(priv->mclk) != -ENOENT) {\r\ndev_err(dev, "Failed to request mclk: %ld\n",\r\nPTR_ERR(priv->mclk));\r\nreturn PTR_ERR(priv->mclk);\r\n}\r\nBUG_ON(priv->chip->num_supply_names > TAS571X_MAX_SUPPLIES);\r\nfor (i = 0; i < priv->chip->num_supply_names; i++)\r\npriv->supplies[i].supply = priv->chip->supply_names[i];\r\nret = devm_regulator_bulk_get(dev, priv->chip->num_supply_names,\r\npriv->supplies);\r\nif (ret) {\r\ndev_err(dev, "Failed to get supplies: %d\n", ret);\r\nreturn ret;\r\n}\r\nret = regulator_bulk_enable(priv->chip->num_supply_names,\r\npriv->supplies);\r\nif (ret) {\r\ndev_err(dev, "Failed to enable supplies: %d\n", ret);\r\nreturn ret;\r\n}\r\npriv->regmap = devm_regmap_init(dev, NULL, client,\r\npriv->chip->regmap_config);\r\nif (IS_ERR(priv->regmap))\r\nreturn PTR_ERR(priv->regmap);\r\npriv->pdn_gpio = devm_gpiod_get_optional(dev, "pdn", GPIOD_OUT_LOW);\r\nif (IS_ERR(priv->pdn_gpio)) {\r\ndev_err(dev, "error requesting pdn_gpio: %ld\n",\r\nPTR_ERR(priv->pdn_gpio));\r\nreturn PTR_ERR(priv->pdn_gpio);\r\n}\r\npriv->reset_gpio = devm_gpiod_get_optional(dev, "reset",\r\nGPIOD_OUT_HIGH);\r\nif (IS_ERR(priv->reset_gpio)) {\r\ndev_err(dev, "error requesting reset_gpio: %ld\n",\r\nPTR_ERR(priv->reset_gpio));\r\nreturn PTR_ERR(priv->reset_gpio);\r\n} else if (priv->reset_gpio) {\r\nusleep_range(100, 200);\r\ngpiod_set_value(priv->reset_gpio, 0);\r\nusleep_range(12000, 20000);\r\n}\r\nret = regmap_write(priv->regmap, TAS571X_OSC_TRIM_REG, 0);\r\nif (ret)\r\nreturn ret;\r\nret = regmap_update_bits(priv->regmap, TAS571X_SYS_CTRL_2_REG,\r\nTAS571X_SYS_CTRL_2_SDN_MASK, 0);\r\nif (ret)\r\nreturn ret;\r\nmemcpy(&priv->codec_driver, &tas571x_codec, sizeof(priv->codec_driver));\r\npriv->codec_driver.controls = priv->chip->controls;\r\npriv->codec_driver.num_controls = priv->chip->num_controls;\r\nif (priv->chip->vol_reg_size == 2) {\r\nret = regmap_update_bits(priv->regmap, TAS571X_MVOL_REG, 1, 0);\r\nif (ret)\r\nreturn ret;\r\n}\r\nregcache_cache_only(priv->regmap, true);\r\ngpiod_set_value(priv->pdn_gpio, 1);\r\nreturn snd_soc_register_codec(&client->dev, &priv->codec_driver,\r\n&tas571x_dai, 1);\r\n}\r\nstatic int tas571x_i2c_remove(struct i2c_client *client)\r\n{\r\nstruct tas571x_private *priv = i2c_get_clientdata(client);\r\nsnd_soc_unregister_codec(&client->dev);\r\nregulator_bulk_disable(priv->chip->num_supply_names, priv->supplies);\r\nreturn 0;\r\n}
