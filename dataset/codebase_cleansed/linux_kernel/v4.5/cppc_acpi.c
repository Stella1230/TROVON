static int send_pcc_cmd(u16 cmd)\r\n{\r\nint retries, result = -EIO;\r\nstruct acpi_pcct_hw_reduced *pcct_ss = pcc_channel->con_priv;\r\nstruct acpi_pcct_shared_memory *generic_comm_base =\r\n(struct acpi_pcct_shared_memory *) pcc_comm_addr;\r\nu32 cmd_latency = pcct_ss->latency;\r\nudelay(pcc_cmd_delay);\r\nwritew(cmd, &generic_comm_base->command);\r\nwritew(0, &generic_comm_base->status);\r\nresult = mbox_send_message(pcc_channel, &cmd);\r\nif (result < 0) {\r\npr_err("Err sending PCC mbox message. cmd:%d, ret:%d\n",\r\ncmd, result);\r\nreturn result;\r\n}\r\nudelay(cmd_latency);\r\nfor (retries = NUM_RETRIES; retries > 0; retries--) {\r\nif (readw_relaxed(&generic_comm_base->status) & PCC_CMD_COMPLETE) {\r\nresult = 0;\r\nbreak;\r\n}\r\n}\r\nmbox_client_txdone(pcc_channel, result);\r\nreturn result;\r\n}\r\nstatic void cppc_chan_tx_done(struct mbox_client *cl, void *msg, int ret)\r\n{\r\nif (ret)\r\npr_debug("TX did not complete: CMD sent:%x, ret:%d\n",\r\n*(u16 *)msg, ret);\r\nelse\r\npr_debug("TX completed. CMD sent:%x, ret:%d\n",\r\n*(u16 *)msg, ret);\r\n}\r\nstatic int acpi_get_psd(struct cpc_desc *cpc_ptr, acpi_handle handle)\r\n{\r\nint result = -EFAULT;\r\nacpi_status status = AE_OK;\r\nstruct acpi_buffer buffer = {ACPI_ALLOCATE_BUFFER, NULL};\r\nstruct acpi_buffer format = {sizeof("NNNNN"), "NNNNN"};\r\nstruct acpi_buffer state = {0, NULL};\r\nunion acpi_object *psd = NULL;\r\nstruct acpi_psd_package *pdomain;\r\nstatus = acpi_evaluate_object_typed(handle, "_PSD", NULL, &buffer,\r\nACPI_TYPE_PACKAGE);\r\nif (ACPI_FAILURE(status))\r\nreturn -ENODEV;\r\npsd = buffer.pointer;\r\nif (!psd || psd->package.count != 1) {\r\npr_debug("Invalid _PSD data\n");\r\ngoto end;\r\n}\r\npdomain = &(cpc_ptr->domain_info);\r\nstate.length = sizeof(struct acpi_psd_package);\r\nstate.pointer = pdomain;\r\nstatus = acpi_extract_package(&(psd->package.elements[0]),\r\n&format, &state);\r\nif (ACPI_FAILURE(status)) {\r\npr_debug("Invalid _PSD data for CPU:%d\n", cpc_ptr->cpu_id);\r\ngoto end;\r\n}\r\nif (pdomain->num_entries != ACPI_PSD_REV0_ENTRIES) {\r\npr_debug("Unknown _PSD:num_entries for CPU:%d\n", cpc_ptr->cpu_id);\r\ngoto end;\r\n}\r\nif (pdomain->revision != ACPI_PSD_REV0_REVISION) {\r\npr_debug("Unknown _PSD:revision for CPU: %d\n", cpc_ptr->cpu_id);\r\ngoto end;\r\n}\r\nif (pdomain->coord_type != DOMAIN_COORD_TYPE_SW_ALL &&\r\npdomain->coord_type != DOMAIN_COORD_TYPE_SW_ANY &&\r\npdomain->coord_type != DOMAIN_COORD_TYPE_HW_ALL) {\r\npr_debug("Invalid _PSD:coord_type for CPU:%d\n", cpc_ptr->cpu_id);\r\ngoto end;\r\n}\r\nresult = 0;\r\nend:\r\nkfree(buffer.pointer);\r\nreturn result;\r\n}\r\nint acpi_get_psd_map(struct cpudata **all_cpu_data)\r\n{\r\nint count_target;\r\nint retval = 0;\r\nunsigned int i, j;\r\ncpumask_var_t covered_cpus;\r\nstruct cpudata *pr, *match_pr;\r\nstruct acpi_psd_package *pdomain;\r\nstruct acpi_psd_package *match_pdomain;\r\nstruct cpc_desc *cpc_ptr, *match_cpc_ptr;\r\nif (!zalloc_cpumask_var(&covered_cpus, GFP_KERNEL))\r\nreturn -ENOMEM;\r\nfor_each_possible_cpu(i) {\r\npr = all_cpu_data[i];\r\nif (!pr)\r\ncontinue;\r\nif (cpumask_test_cpu(i, covered_cpus))\r\ncontinue;\r\ncpc_ptr = per_cpu(cpc_desc_ptr, i);\r\nif (!cpc_ptr)\r\ncontinue;\r\npdomain = &(cpc_ptr->domain_info);\r\ncpumask_set_cpu(i, pr->shared_cpu_map);\r\ncpumask_set_cpu(i, covered_cpus);\r\nif (pdomain->num_processors <= 1)\r\ncontinue;\r\ncount_target = pdomain->num_processors;\r\nif (pdomain->coord_type == DOMAIN_COORD_TYPE_SW_ALL)\r\npr->shared_type = CPUFREQ_SHARED_TYPE_ALL;\r\nelse if (pdomain->coord_type == DOMAIN_COORD_TYPE_HW_ALL)\r\npr->shared_type = CPUFREQ_SHARED_TYPE_HW;\r\nelse if (pdomain->coord_type == DOMAIN_COORD_TYPE_SW_ANY)\r\npr->shared_type = CPUFREQ_SHARED_TYPE_ANY;\r\nfor_each_possible_cpu(j) {\r\nif (i == j)\r\ncontinue;\r\nmatch_cpc_ptr = per_cpu(cpc_desc_ptr, j);\r\nif (!match_cpc_ptr)\r\ncontinue;\r\nmatch_pdomain = &(match_cpc_ptr->domain_info);\r\nif (match_pdomain->domain != pdomain->domain)\r\ncontinue;\r\nif (match_pdomain->num_processors != count_target) {\r\nretval = -EFAULT;\r\ngoto err_ret;\r\n}\r\nif (pdomain->coord_type != match_pdomain->coord_type) {\r\nretval = -EFAULT;\r\ngoto err_ret;\r\n}\r\ncpumask_set_cpu(j, covered_cpus);\r\ncpumask_set_cpu(j, pr->shared_cpu_map);\r\n}\r\nfor_each_possible_cpu(j) {\r\nif (i == j)\r\ncontinue;\r\nmatch_pr = all_cpu_data[j];\r\nif (!match_pr)\r\ncontinue;\r\nmatch_cpc_ptr = per_cpu(cpc_desc_ptr, j);\r\nif (!match_cpc_ptr)\r\ncontinue;\r\nmatch_pdomain = &(match_cpc_ptr->domain_info);\r\nif (match_pdomain->domain != pdomain->domain)\r\ncontinue;\r\nmatch_pr->shared_type = pr->shared_type;\r\ncpumask_copy(match_pr->shared_cpu_map,\r\npr->shared_cpu_map);\r\n}\r\n}\r\nerr_ret:\r\nfor_each_possible_cpu(i) {\r\npr = all_cpu_data[i];\r\nif (!pr)\r\ncontinue;\r\nif (retval) {\r\ncpumask_clear(pr->shared_cpu_map);\r\ncpumask_set_cpu(i, pr->shared_cpu_map);\r\npr->shared_type = CPUFREQ_SHARED_TYPE_ALL;\r\n}\r\n}\r\nfree_cpumask_var(covered_cpus);\r\nreturn retval;\r\n}\r\nstatic int register_pcc_channel(int pcc_subspace_idx)\r\n{\r\nstruct acpi_pcct_hw_reduced *cppc_ss;\r\nunsigned int len;\r\nif (pcc_subspace_idx >= 0) {\r\npcc_channel = pcc_mbox_request_channel(&cppc_mbox_cl,\r\npcc_subspace_idx);\r\nif (IS_ERR(pcc_channel)) {\r\npr_err("Failed to find PCC communication channel\n");\r\nreturn -ENODEV;\r\n}\r\ncppc_ss = pcc_channel->con_priv;\r\nif (!cppc_ss) {\r\npr_err("No PCC subspace found for CPPC\n");\r\nreturn -ENODEV;\r\n}\r\ncomm_base_addr = cppc_ss->base_address;\r\nlen = cppc_ss->length;\r\npcc_cmd_delay = cppc_ss->min_turnaround_time;\r\npcc_comm_addr = acpi_os_ioremap(comm_base_addr, len);\r\nif (!pcc_comm_addr) {\r\npr_err("Failed to ioremap PCC comm region mem\n");\r\nreturn -ENOMEM;\r\n}\r\npcc_channel_acquired = true;\r\n}\r\nreturn 0;\r\n}\r\nint acpi_cppc_processor_probe(struct acpi_processor *pr)\r\n{\r\nstruct acpi_buffer output = {ACPI_ALLOCATE_BUFFER, NULL};\r\nunion acpi_object *out_obj, *cpc_obj;\r\nstruct cpc_desc *cpc_ptr;\r\nstruct cpc_reg *gas_t;\r\nacpi_handle handle = pr->handle;\r\nunsigned int num_ent, i, cpc_rev;\r\nacpi_status status;\r\nint ret = -EFAULT;\r\nstatus = acpi_evaluate_object_typed(handle, "_CPC", NULL, &output,\r\nACPI_TYPE_PACKAGE);\r\nif (ACPI_FAILURE(status)) {\r\nret = -ENODEV;\r\ngoto out_buf_free;\r\n}\r\nout_obj = (union acpi_object *) output.pointer;\r\ncpc_ptr = kzalloc(sizeof(struct cpc_desc), GFP_KERNEL);\r\nif (!cpc_ptr) {\r\nret = -ENOMEM;\r\ngoto out_buf_free;\r\n}\r\ncpc_obj = &out_obj->package.elements[0];\r\nif (cpc_obj->type == ACPI_TYPE_INTEGER) {\r\nnum_ent = cpc_obj->integer.value;\r\n} else {\r\npr_debug("Unexpected entry type(%d) for NumEntries\n",\r\ncpc_obj->type);\r\ngoto out_free;\r\n}\r\nif (num_ent != CPPC_NUM_ENT) {\r\npr_debug("Firmware exports %d entries. Expected: %d\n",\r\nnum_ent, CPPC_NUM_ENT);\r\ngoto out_free;\r\n}\r\ncpc_obj = &out_obj->package.elements[1];\r\nif (cpc_obj->type == ACPI_TYPE_INTEGER) {\r\ncpc_rev = cpc_obj->integer.value;\r\n} else {\r\npr_debug("Unexpected entry type(%d) for Revision\n",\r\ncpc_obj->type);\r\ngoto out_free;\r\n}\r\nif (cpc_rev != CPPC_REV) {\r\npr_debug("Firmware exports revision:%d. Expected:%d\n",\r\ncpc_rev, CPPC_REV);\r\ngoto out_free;\r\n}\r\nfor (i = 2; i < num_ent; i++) {\r\ncpc_obj = &out_obj->package.elements[i];\r\nif (cpc_obj->type == ACPI_TYPE_INTEGER) {\r\ncpc_ptr->cpc_regs[i-2].type = ACPI_TYPE_INTEGER;\r\ncpc_ptr->cpc_regs[i-2].cpc_entry.int_value = cpc_obj->integer.value;\r\n} else if (cpc_obj->type == ACPI_TYPE_BUFFER) {\r\ngas_t = (struct cpc_reg *)\r\ncpc_obj->buffer.pointer;\r\nif (gas_t->space_id == ACPI_ADR_SPACE_PLATFORM_COMM) {\r\nif (pcc_subspace_idx < 0)\r\npcc_subspace_idx = gas_t->access_width;\r\nelse if (pcc_subspace_idx != gas_t->access_width) {\r\npr_debug("Mismatched PCC ids.\n");\r\ngoto out_free;\r\n}\r\n} else if (gas_t->space_id != ACPI_ADR_SPACE_SYSTEM_MEMORY) {\r\npr_debug("Unsupported register type: %d\n", gas_t->space_id);\r\ngoto out_free;\r\n}\r\ncpc_ptr->cpc_regs[i-2].type = ACPI_TYPE_BUFFER;\r\nmemcpy(&cpc_ptr->cpc_regs[i-2].cpc_entry.reg, gas_t, sizeof(*gas_t));\r\n} else {\r\npr_debug("Err in entry:%d in CPC table of CPU:%d \n", i, pr->id);\r\ngoto out_free;\r\n}\r\n}\r\ncpc_ptr->cpu_id = pr->id;\r\nper_cpu(cpc_desc_ptr, pr->id) = cpc_ptr;\r\nret = acpi_get_psd(cpc_ptr, handle);\r\nif (ret)\r\ngoto out_free;\r\nif (!pcc_channel_acquired) {\r\nret = register_pcc_channel(pcc_subspace_idx);\r\nif (ret)\r\ngoto out_free;\r\n}\r\npr_debug("Parsed CPC struct for CPU: %d\n", pr->id);\r\nkfree(output.pointer);\r\nreturn 0;\r\nout_free:\r\nkfree(cpc_ptr);\r\nout_buf_free:\r\nkfree(output.pointer);\r\nreturn ret;\r\n}\r\nvoid acpi_cppc_processor_exit(struct acpi_processor *pr)\r\n{\r\nstruct cpc_desc *cpc_ptr;\r\ncpc_ptr = per_cpu(cpc_desc_ptr, pr->id);\r\nkfree(cpc_ptr);\r\n}\r\nstatic u64 get_phys_addr(struct cpc_reg *reg)\r\n{\r\nif (reg->space_id == ACPI_ADR_SPACE_PLATFORM_COMM)\r\nreturn (u64)comm_base_addr + 0x8 + reg->address;\r\nelse\r\nreturn reg->address;\r\n}\r\nstatic void cpc_read(struct cpc_reg *reg, u64 *val)\r\n{\r\nu64 addr = get_phys_addr(reg);\r\nacpi_os_read_memory((acpi_physical_address)addr,\r\nval, reg->bit_width);\r\n}\r\nstatic void cpc_write(struct cpc_reg *reg, u64 val)\r\n{\r\nu64 addr = get_phys_addr(reg);\r\nacpi_os_write_memory((acpi_physical_address)addr,\r\nval, reg->bit_width);\r\n}\r\nint cppc_get_perf_caps(int cpunum, struct cppc_perf_caps *perf_caps)\r\n{\r\nstruct cpc_desc *cpc_desc = per_cpu(cpc_desc_ptr, cpunum);\r\nstruct cpc_register_resource *highest_reg, *lowest_reg, *ref_perf,\r\n*nom_perf;\r\nu64 high, low, ref, nom;\r\nint ret = 0;\r\nif (!cpc_desc) {\r\npr_debug("No CPC descriptor for CPU:%d\n", cpunum);\r\nreturn -ENODEV;\r\n}\r\nhighest_reg = &cpc_desc->cpc_regs[HIGHEST_PERF];\r\nlowest_reg = &cpc_desc->cpc_regs[LOWEST_PERF];\r\nref_perf = &cpc_desc->cpc_regs[REFERENCE_PERF];\r\nnom_perf = &cpc_desc->cpc_regs[NOMINAL_PERF];\r\nspin_lock(&pcc_lock);\r\nif ((highest_reg->cpc_entry.reg.space_id == ACPI_ADR_SPACE_PLATFORM_COMM) ||\r\n(lowest_reg->cpc_entry.reg.space_id == ACPI_ADR_SPACE_PLATFORM_COMM) ||\r\n(ref_perf->cpc_entry.reg.space_id == ACPI_ADR_SPACE_PLATFORM_COMM) ||\r\n(nom_perf->cpc_entry.reg.space_id == ACPI_ADR_SPACE_PLATFORM_COMM)) {\r\nif (send_pcc_cmd(CMD_READ)) {\r\nret = -EIO;\r\ngoto out_err;\r\n}\r\n}\r\ncpc_read(&highest_reg->cpc_entry.reg, &high);\r\nperf_caps->highest_perf = high;\r\ncpc_read(&lowest_reg->cpc_entry.reg, &low);\r\nperf_caps->lowest_perf = low;\r\ncpc_read(&ref_perf->cpc_entry.reg, &ref);\r\nperf_caps->reference_perf = ref;\r\ncpc_read(&nom_perf->cpc_entry.reg, &nom);\r\nperf_caps->nominal_perf = nom;\r\nif (!ref)\r\nperf_caps->reference_perf = perf_caps->nominal_perf;\r\nif (!high || !low || !nom)\r\nret = -EFAULT;\r\nout_err:\r\nspin_unlock(&pcc_lock);\r\nreturn ret;\r\n}\r\nint cppc_get_perf_ctrs(int cpunum, struct cppc_perf_fb_ctrs *perf_fb_ctrs)\r\n{\r\nstruct cpc_desc *cpc_desc = per_cpu(cpc_desc_ptr, cpunum);\r\nstruct cpc_register_resource *delivered_reg, *reference_reg;\r\nu64 delivered, reference;\r\nint ret = 0;\r\nif (!cpc_desc) {\r\npr_debug("No CPC descriptor for CPU:%d\n", cpunum);\r\nreturn -ENODEV;\r\n}\r\ndelivered_reg = &cpc_desc->cpc_regs[DELIVERED_CTR];\r\nreference_reg = &cpc_desc->cpc_regs[REFERENCE_CTR];\r\nspin_lock(&pcc_lock);\r\nif ((delivered_reg->cpc_entry.reg.space_id == ACPI_ADR_SPACE_PLATFORM_COMM) ||\r\n(reference_reg->cpc_entry.reg.space_id == ACPI_ADR_SPACE_PLATFORM_COMM)) {\r\nif (send_pcc_cmd(CMD_READ)) {\r\nret = -EIO;\r\ngoto out_err;\r\n}\r\n}\r\ncpc_read(&delivered_reg->cpc_entry.reg, &delivered);\r\ncpc_read(&reference_reg->cpc_entry.reg, &reference);\r\nif (!delivered || !reference) {\r\nret = -EFAULT;\r\ngoto out_err;\r\n}\r\nperf_fb_ctrs->delivered = delivered;\r\nperf_fb_ctrs->reference = reference;\r\nperf_fb_ctrs->delivered -= perf_fb_ctrs->prev_delivered;\r\nperf_fb_ctrs->reference -= perf_fb_ctrs->prev_reference;\r\nperf_fb_ctrs->prev_delivered = delivered;\r\nperf_fb_ctrs->prev_reference = reference;\r\nout_err:\r\nspin_unlock(&pcc_lock);\r\nreturn ret;\r\n}\r\nint cppc_set_perf(int cpu, struct cppc_perf_ctrls *perf_ctrls)\r\n{\r\nstruct cpc_desc *cpc_desc = per_cpu(cpc_desc_ptr, cpu);\r\nstruct cpc_register_resource *desired_reg;\r\nint ret = 0;\r\nif (!cpc_desc) {\r\npr_debug("No CPC descriptor for CPU:%d\n", cpu);\r\nreturn -ENODEV;\r\n}\r\ndesired_reg = &cpc_desc->cpc_regs[DESIRED_PERF];\r\nspin_lock(&pcc_lock);\r\ncpc_write(&desired_reg->cpc_entry.reg, perf_ctrls->desired_perf);\r\nif (desired_reg->cpc_entry.reg.space_id == ACPI_ADR_SPACE_PLATFORM_COMM) {\r\nif (send_pcc_cmd(CMD_WRITE))\r\nret = -EIO;\r\n}\r\nspin_unlock(&pcc_lock);\r\nreturn ret;\r\n}
