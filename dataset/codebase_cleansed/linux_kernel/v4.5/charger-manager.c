static bool is_batt_present(struct charger_manager *cm)\r\n{\r\nunion power_supply_propval val;\r\nstruct power_supply *psy;\r\nbool present = false;\r\nint i, ret;\r\nswitch (cm->desc->battery_present) {\r\ncase CM_BATTERY_PRESENT:\r\npresent = true;\r\nbreak;\r\ncase CM_NO_BATTERY:\r\nbreak;\r\ncase CM_FUEL_GAUGE:\r\npsy = power_supply_get_by_name(cm->desc->psy_fuel_gauge);\r\nif (!psy)\r\nbreak;\r\nret = power_supply_get_property(psy, POWER_SUPPLY_PROP_PRESENT,\r\n&val);\r\nif (ret == 0 && val.intval)\r\npresent = true;\r\npower_supply_put(psy);\r\nbreak;\r\ncase CM_CHARGER_STAT:\r\nfor (i = 0; cm->desc->psy_charger_stat[i]; i++) {\r\npsy = power_supply_get_by_name(\r\ncm->desc->psy_charger_stat[i]);\r\nif (!psy) {\r\ndev_err(cm->dev, "Cannot find power supply \"%s\"\n",\r\ncm->desc->psy_charger_stat[i]);\r\ncontinue;\r\n}\r\nret = power_supply_get_property(psy,\r\nPOWER_SUPPLY_PROP_PRESENT, &val);\r\npower_supply_put(psy);\r\nif (ret == 0 && val.intval) {\r\npresent = true;\r\nbreak;\r\n}\r\n}\r\nbreak;\r\n}\r\nreturn present;\r\n}\r\nstatic bool is_ext_pwr_online(struct charger_manager *cm)\r\n{\r\nunion power_supply_propval val;\r\nstruct power_supply *psy;\r\nbool online = false;\r\nint i, ret;\r\nfor (i = 0; cm->desc->psy_charger_stat[i]; i++) {\r\npsy = power_supply_get_by_name(cm->desc->psy_charger_stat[i]);\r\nif (!psy) {\r\ndev_err(cm->dev, "Cannot find power supply \"%s\"\n",\r\ncm->desc->psy_charger_stat[i]);\r\ncontinue;\r\n}\r\nret = power_supply_get_property(psy, POWER_SUPPLY_PROP_ONLINE,\r\n&val);\r\npower_supply_put(psy);\r\nif (ret == 0 && val.intval) {\r\nonline = true;\r\nbreak;\r\n}\r\n}\r\nreturn online;\r\n}\r\nstatic int get_batt_uV(struct charger_manager *cm, int *uV)\r\n{\r\nunion power_supply_propval val;\r\nstruct power_supply *fuel_gauge;\r\nint ret;\r\nfuel_gauge = power_supply_get_by_name(cm->desc->psy_fuel_gauge);\r\nif (!fuel_gauge)\r\nreturn -ENODEV;\r\nret = power_supply_get_property(fuel_gauge,\r\nPOWER_SUPPLY_PROP_VOLTAGE_NOW, &val);\r\npower_supply_put(fuel_gauge);\r\nif (ret)\r\nreturn ret;\r\n*uV = val.intval;\r\nreturn 0;\r\n}\r\nstatic bool is_charging(struct charger_manager *cm)\r\n{\r\nint i, ret;\r\nbool charging = false;\r\nstruct power_supply *psy;\r\nunion power_supply_propval val;\r\nif (!is_batt_present(cm))\r\nreturn false;\r\nfor (i = 0; cm->desc->psy_charger_stat[i]; i++) {\r\nif (cm->emergency_stop)\r\ncontinue;\r\nif (!cm->charger_enabled)\r\ncontinue;\r\npsy = power_supply_get_by_name(cm->desc->psy_charger_stat[i]);\r\nif (!psy) {\r\ndev_err(cm->dev, "Cannot find power supply \"%s\"\n",\r\ncm->desc->psy_charger_stat[i]);\r\ncontinue;\r\n}\r\nret = power_supply_get_property(psy, POWER_SUPPLY_PROP_ONLINE,\r\n&val);\r\nif (ret) {\r\ndev_warn(cm->dev, "Cannot read ONLINE value from %s\n",\r\ncm->desc->psy_charger_stat[i]);\r\npower_supply_put(psy);\r\ncontinue;\r\n}\r\nif (val.intval == 0) {\r\npower_supply_put(psy);\r\ncontinue;\r\n}\r\nret = power_supply_get_property(psy, POWER_SUPPLY_PROP_STATUS,\r\n&val);\r\npower_supply_put(psy);\r\nif (ret) {\r\ndev_warn(cm->dev, "Cannot read STATUS value from %s\n",\r\ncm->desc->psy_charger_stat[i]);\r\ncontinue;\r\n}\r\nif (val.intval == POWER_SUPPLY_STATUS_FULL ||\r\nval.intval == POWER_SUPPLY_STATUS_DISCHARGING ||\r\nval.intval == POWER_SUPPLY_STATUS_NOT_CHARGING)\r\ncontinue;\r\ncharging = true;\r\nbreak;\r\n}\r\nreturn charging;\r\n}\r\nstatic bool is_full_charged(struct charger_manager *cm)\r\n{\r\nstruct charger_desc *desc = cm->desc;\r\nunion power_supply_propval val;\r\nstruct power_supply *fuel_gauge;\r\nbool is_full = false;\r\nint ret = 0;\r\nint uV;\r\nif (!is_batt_present(cm))\r\nreturn false;\r\nfuel_gauge = power_supply_get_by_name(cm->desc->psy_fuel_gauge);\r\nif (!fuel_gauge)\r\nreturn false;\r\nif (desc->fullbatt_full_capacity > 0) {\r\nval.intval = 0;\r\nret = power_supply_get_property(fuel_gauge,\r\nPOWER_SUPPLY_PROP_CHARGE_FULL, &val);\r\nif (!ret && val.intval > desc->fullbatt_full_capacity) {\r\nis_full = true;\r\ngoto out;\r\n}\r\n}\r\nif (desc->fullbatt_uV > 0) {\r\nret = get_batt_uV(cm, &uV);\r\nif (!ret && uV >= desc->fullbatt_uV) {\r\nis_full = true;\r\ngoto out;\r\n}\r\n}\r\nif (desc->fullbatt_soc > 0) {\r\nval.intval = 0;\r\nret = power_supply_get_property(fuel_gauge,\r\nPOWER_SUPPLY_PROP_CAPACITY, &val);\r\nif (!ret && val.intval >= desc->fullbatt_soc) {\r\nis_full = true;\r\ngoto out;\r\n}\r\n}\r\nout:\r\npower_supply_put(fuel_gauge);\r\nreturn is_full;\r\n}\r\nstatic bool is_polling_required(struct charger_manager *cm)\r\n{\r\nswitch (cm->desc->polling_mode) {\r\ncase CM_POLL_DISABLE:\r\nreturn false;\r\ncase CM_POLL_ALWAYS:\r\nreturn true;\r\ncase CM_POLL_EXTERNAL_POWER_ONLY:\r\nreturn is_ext_pwr_online(cm);\r\ncase CM_POLL_CHARGING_ONLY:\r\nreturn is_charging(cm);\r\ndefault:\r\ndev_warn(cm->dev, "Incorrect polling_mode (%d)\n",\r\ncm->desc->polling_mode);\r\n}\r\nreturn false;\r\n}\r\nstatic int try_charger_enable(struct charger_manager *cm, bool enable)\r\n{\r\nint err = 0, i;\r\nstruct charger_desc *desc = cm->desc;\r\nif (enable == cm->charger_enabled)\r\nreturn 0;\r\nif (enable) {\r\nif (cm->emergency_stop)\r\nreturn -EAGAIN;\r\ncm->charging_start_time = ktime_to_ms(ktime_get());\r\ncm->charging_end_time = 0;\r\nfor (i = 0 ; i < desc->num_charger_regulators ; i++) {\r\nif (desc->charger_regulators[i].externally_control)\r\ncontinue;\r\nerr = regulator_enable(desc->charger_regulators[i].consumer);\r\nif (err < 0) {\r\ndev_warn(cm->dev, "Cannot enable %s regulator\n",\r\ndesc->charger_regulators[i].regulator_name);\r\n}\r\n}\r\n} else {\r\ncm->charging_start_time = 0;\r\ncm->charging_end_time = ktime_to_ms(ktime_get());\r\nfor (i = 0 ; i < desc->num_charger_regulators ; i++) {\r\nif (desc->charger_regulators[i].externally_control)\r\ncontinue;\r\nerr = regulator_disable(desc->charger_regulators[i].consumer);\r\nif (err < 0) {\r\ndev_warn(cm->dev, "Cannot disable %s regulator\n",\r\ndesc->charger_regulators[i].regulator_name);\r\n}\r\n}\r\nfor (i = 0; i < desc->num_charger_regulators; i++) {\r\nif (regulator_is_enabled(\r\ndesc->charger_regulators[i].consumer)) {\r\nregulator_force_disable(\r\ndesc->charger_regulators[i].consumer);\r\ndev_warn(cm->dev, "Disable regulator(%s) forcibly\n",\r\ndesc->charger_regulators[i].regulator_name);\r\n}\r\n}\r\n}\r\nif (!err)\r\ncm->charger_enabled = enable;\r\nreturn err;\r\n}\r\nstatic int try_charger_restart(struct charger_manager *cm)\r\n{\r\nint err;\r\nif (cm->emergency_stop)\r\nreturn -EAGAIN;\r\nerr = try_charger_enable(cm, false);\r\nif (err)\r\nreturn err;\r\nreturn try_charger_enable(cm, true);\r\n}\r\nstatic void uevent_notify(struct charger_manager *cm, const char *event)\r\n{\r\nstatic char env_str[UEVENT_BUF_SIZE + 1] = "";\r\nstatic char env_str_save[UEVENT_BUF_SIZE + 1] = "";\r\nif (cm_suspended) {\r\nif (env_str_save[0] == 0) {\r\nif (!strncmp(env_str, event, UEVENT_BUF_SIZE))\r\nreturn;\r\nstrncpy(env_str_save, event, UEVENT_BUF_SIZE);\r\nreturn;\r\n}\r\nif (!strncmp(env_str_save, event, UEVENT_BUF_SIZE))\r\nreturn;\r\nstrncpy(env_str_save, event, UEVENT_BUF_SIZE);\r\nreturn;\r\n}\r\nif (event == NULL) {\r\nif (!env_str_save[0])\r\nreturn;\r\nstrncpy(env_str, env_str_save, UEVENT_BUF_SIZE);\r\nkobject_uevent(&cm->dev->kobj, KOBJ_CHANGE);\r\nenv_str_save[0] = 0;\r\nreturn;\r\n}\r\nif (!strncmp(env_str, event, UEVENT_BUF_SIZE))\r\nreturn;\r\nstrncpy(env_str, event, UEVENT_BUF_SIZE);\r\nkobject_uevent(&cm->dev->kobj, KOBJ_CHANGE);\r\ndev_info(cm->dev, "%s\n", event);\r\n}\r\nstatic void fullbatt_vchk(struct work_struct *work)\r\n{\r\nstruct delayed_work *dwork = to_delayed_work(work);\r\nstruct charger_manager *cm = container_of(dwork,\r\nstruct charger_manager, fullbatt_vchk_work);\r\nstruct charger_desc *desc = cm->desc;\r\nint batt_uV, err, diff;\r\ncm->fullbatt_vchk_jiffies_at = 0;\r\nif (!desc->fullbatt_vchkdrop_uV || !desc->fullbatt_vchkdrop_ms)\r\nreturn;\r\nerr = get_batt_uV(cm, &batt_uV);\r\nif (err) {\r\ndev_err(cm->dev, "%s: get_batt_uV error(%d)\n", __func__, err);\r\nreturn;\r\n}\r\ndiff = desc->fullbatt_uV - batt_uV;\r\nif (diff < 0)\r\nreturn;\r\ndev_info(cm->dev, "VBATT dropped %duV after full-batt\n", diff);\r\nif (diff > desc->fullbatt_vchkdrop_uV) {\r\ntry_charger_restart(cm);\r\nuevent_notify(cm, "Recharging");\r\n}\r\n}\r\nstatic int check_charging_duration(struct charger_manager *cm)\r\n{\r\nstruct charger_desc *desc = cm->desc;\r\nu64 curr = ktime_to_ms(ktime_get());\r\nu64 duration;\r\nint ret = false;\r\nif (!desc->charging_max_duration_ms &&\r\n!desc->discharging_max_duration_ms)\r\nreturn ret;\r\nif (cm->charger_enabled) {\r\nduration = curr - cm->charging_start_time;\r\nif (duration > desc->charging_max_duration_ms) {\r\ndev_info(cm->dev, "Charging duration exceed %ums\n",\r\ndesc->charging_max_duration_ms);\r\nuevent_notify(cm, "Discharging");\r\ntry_charger_enable(cm, false);\r\nret = true;\r\n}\r\n} else if (is_ext_pwr_online(cm) && !cm->charger_enabled) {\r\nduration = curr - cm->charging_end_time;\r\nif (duration > desc->charging_max_duration_ms &&\r\nis_ext_pwr_online(cm)) {\r\ndev_info(cm->dev, "Discharging duration exceed %ums\n",\r\ndesc->discharging_max_duration_ms);\r\nuevent_notify(cm, "Recharging");\r\ntry_charger_enable(cm, true);\r\nret = true;\r\n}\r\n}\r\nreturn ret;\r\n}\r\nstatic int cm_get_battery_temperature_by_psy(struct charger_manager *cm,\r\nint *temp)\r\n{\r\nstruct power_supply *fuel_gauge;\r\nint ret;\r\nfuel_gauge = power_supply_get_by_name(cm->desc->psy_fuel_gauge);\r\nif (!fuel_gauge)\r\nreturn -ENODEV;\r\nret = power_supply_get_property(fuel_gauge,\r\nPOWER_SUPPLY_PROP_TEMP,\r\n(union power_supply_propval *)temp);\r\npower_supply_put(fuel_gauge);\r\nreturn ret;\r\n}\r\nstatic int cm_get_battery_temperature(struct charger_manager *cm,\r\nint *temp)\r\n{\r\nint ret;\r\nif (!cm->desc->measure_battery_temp)\r\nreturn -ENODEV;\r\n#ifdef CONFIG_THERMAL\r\nif (cm->tzd_batt) {\r\nret = thermal_zone_get_temp(cm->tzd_batt, temp);\r\nif (!ret)\r\n*temp /= 100;\r\n} else\r\n#endif\r\n{\r\nret = cm_get_battery_temperature_by_psy(cm, temp);\r\n}\r\nreturn ret;\r\n}\r\nstatic int cm_check_thermal_status(struct charger_manager *cm)\r\n{\r\nstruct charger_desc *desc = cm->desc;\r\nint temp, upper_limit, lower_limit;\r\nint ret = 0;\r\nret = cm_get_battery_temperature(cm, &temp);\r\nif (ret) {\r\ndev_err(cm->dev, "Failed to get battery temperature\n");\r\nreturn 0;\r\n}\r\nupper_limit = desc->temp_max;\r\nlower_limit = desc->temp_min;\r\nif (cm->emergency_stop) {\r\nupper_limit -= desc->temp_diff;\r\nlower_limit += desc->temp_diff;\r\n}\r\nif (temp > upper_limit)\r\nret = CM_EVENT_BATT_OVERHEAT;\r\nelse if (temp < lower_limit)\r\nret = CM_EVENT_BATT_COLD;\r\nreturn ret;\r\n}\r\nstatic bool _cm_monitor(struct charger_manager *cm)\r\n{\r\nint temp_alrt;\r\ntemp_alrt = cm_check_thermal_status(cm);\r\nif (temp_alrt && cm->emergency_stop)\r\nreturn false;\r\nif (temp_alrt) {\r\ncm->emergency_stop = temp_alrt;\r\nif (!try_charger_enable(cm, false))\r\nuevent_notify(cm, default_event_names[temp_alrt]);\r\n} else if (!cm->emergency_stop && check_charging_duration(cm)) {\r\ndev_dbg(cm->dev,\r\n"Charging/Discharging duration is out of range\n");\r\n} else if (!cm->emergency_stop && is_ext_pwr_online(cm) &&\r\n!cm->charger_enabled) {\r\nfullbatt_vchk(&cm->fullbatt_vchk_work.work);\r\n} else if (!cm->emergency_stop && is_full_charged(cm) &&\r\ncm->charger_enabled) {\r\ndev_info(cm->dev, "EVENT_HANDLE: Battery Fully Charged\n");\r\nuevent_notify(cm, default_event_names[CM_EVENT_BATT_FULL]);\r\ntry_charger_enable(cm, false);\r\nfullbatt_vchk(&cm->fullbatt_vchk_work.work);\r\n} else {\r\ncm->emergency_stop = 0;\r\nif (is_ext_pwr_online(cm)) {\r\nif (!try_charger_enable(cm, true))\r\nuevent_notify(cm, "CHARGING");\r\n}\r\n}\r\nreturn true;\r\n}\r\nstatic bool cm_monitor(void)\r\n{\r\nbool stop = false;\r\nstruct charger_manager *cm;\r\nmutex_lock(&cm_list_mtx);\r\nlist_for_each_entry(cm, &cm_list, entry) {\r\nif (_cm_monitor(cm))\r\nstop = true;\r\n}\r\nmutex_unlock(&cm_list_mtx);\r\nreturn stop;\r\n}\r\nstatic void _setup_polling(struct work_struct *work)\r\n{\r\nunsigned long min = ULONG_MAX;\r\nstruct charger_manager *cm;\r\nbool keep_polling = false;\r\nunsigned long _next_polling;\r\nmutex_lock(&cm_list_mtx);\r\nlist_for_each_entry(cm, &cm_list, entry) {\r\nif (is_polling_required(cm) && cm->desc->polling_interval_ms) {\r\nkeep_polling = true;\r\nif (min > cm->desc->polling_interval_ms)\r\nmin = cm->desc->polling_interval_ms;\r\n}\r\n}\r\npolling_jiffy = msecs_to_jiffies(min);\r\nif (polling_jiffy <= CM_JIFFIES_SMALL)\r\npolling_jiffy = CM_JIFFIES_SMALL + 1;\r\nif (!keep_polling)\r\npolling_jiffy = ULONG_MAX;\r\nif (polling_jiffy == ULONG_MAX)\r\ngoto out;\r\nWARN(cm_wq == NULL, "charger-manager: workqueue not initialized"\r\n". try it later. %s\n", __func__);\r\n_next_polling = jiffies + polling_jiffy;\r\nif (time_before(_next_polling, next_polling)) {\r\nmod_delayed_work(cm_wq, &cm_monitor_work, polling_jiffy);\r\nnext_polling = _next_polling;\r\n} else {\r\nif (queue_delayed_work(cm_wq, &cm_monitor_work, polling_jiffy))\r\nnext_polling = _next_polling;\r\n}\r\nout:\r\nmutex_unlock(&cm_list_mtx);\r\n}\r\nstatic void cm_monitor_poller(struct work_struct *work)\r\n{\r\ncm_monitor();\r\nschedule_work(&setup_polling);\r\n}\r\nstatic void fullbatt_handler(struct charger_manager *cm)\r\n{\r\nstruct charger_desc *desc = cm->desc;\r\nif (!desc->fullbatt_vchkdrop_uV || !desc->fullbatt_vchkdrop_ms)\r\ngoto out;\r\nif (cm_suspended)\r\ndevice_set_wakeup_capable(cm->dev, true);\r\nmod_delayed_work(cm_wq, &cm->fullbatt_vchk_work,\r\nmsecs_to_jiffies(desc->fullbatt_vchkdrop_ms));\r\ncm->fullbatt_vchk_jiffies_at = jiffies + msecs_to_jiffies(\r\ndesc->fullbatt_vchkdrop_ms);\r\nif (cm->fullbatt_vchk_jiffies_at == 0)\r\ncm->fullbatt_vchk_jiffies_at = 1;\r\nout:\r\ndev_info(cm->dev, "EVENT_HANDLE: Battery Fully Charged\n");\r\nuevent_notify(cm, default_event_names[CM_EVENT_BATT_FULL]);\r\n}\r\nstatic void battout_handler(struct charger_manager *cm)\r\n{\r\nif (cm_suspended)\r\ndevice_set_wakeup_capable(cm->dev, true);\r\nif (!is_batt_present(cm)) {\r\ndev_emerg(cm->dev, "Battery Pulled Out!\n");\r\nuevent_notify(cm, default_event_names[CM_EVENT_BATT_OUT]);\r\n} else {\r\nuevent_notify(cm, "Battery Reinserted?");\r\n}\r\n}\r\nstatic void misc_event_handler(struct charger_manager *cm,\r\nenum cm_event_types type)\r\n{\r\nif (cm_suspended)\r\ndevice_set_wakeup_capable(cm->dev, true);\r\nif (is_polling_required(cm) && cm->desc->polling_interval_ms)\r\nschedule_work(&setup_polling);\r\nuevent_notify(cm, default_event_names[type]);\r\n}\r\nstatic int charger_get_property(struct power_supply *psy,\r\nenum power_supply_property psp,\r\nunion power_supply_propval *val)\r\n{\r\nstruct charger_manager *cm = power_supply_get_drvdata(psy);\r\nstruct charger_desc *desc = cm->desc;\r\nstruct power_supply *fuel_gauge = NULL;\r\nint ret = 0;\r\nint uV;\r\nswitch (psp) {\r\ncase POWER_SUPPLY_PROP_STATUS:\r\nif (is_charging(cm))\r\nval->intval = POWER_SUPPLY_STATUS_CHARGING;\r\nelse if (is_ext_pwr_online(cm))\r\nval->intval = POWER_SUPPLY_STATUS_NOT_CHARGING;\r\nelse\r\nval->intval = POWER_SUPPLY_STATUS_DISCHARGING;\r\nbreak;\r\ncase POWER_SUPPLY_PROP_HEALTH:\r\nif (cm->emergency_stop > 0)\r\nval->intval = POWER_SUPPLY_HEALTH_OVERHEAT;\r\nelse if (cm->emergency_stop < 0)\r\nval->intval = POWER_SUPPLY_HEALTH_COLD;\r\nelse\r\nval->intval = POWER_SUPPLY_HEALTH_GOOD;\r\nbreak;\r\ncase POWER_SUPPLY_PROP_PRESENT:\r\nif (is_batt_present(cm))\r\nval->intval = 1;\r\nelse\r\nval->intval = 0;\r\nbreak;\r\ncase POWER_SUPPLY_PROP_VOLTAGE_NOW:\r\nret = get_batt_uV(cm, &val->intval);\r\nbreak;\r\ncase POWER_SUPPLY_PROP_CURRENT_NOW:\r\nfuel_gauge = power_supply_get_by_name(cm->desc->psy_fuel_gauge);\r\nif (!fuel_gauge) {\r\nret = -ENODEV;\r\nbreak;\r\n}\r\nret = power_supply_get_property(fuel_gauge,\r\nPOWER_SUPPLY_PROP_CURRENT_NOW, val);\r\nbreak;\r\ncase POWER_SUPPLY_PROP_TEMP:\r\ncase POWER_SUPPLY_PROP_TEMP_AMBIENT:\r\nreturn cm_get_battery_temperature(cm, &val->intval);\r\ncase POWER_SUPPLY_PROP_CAPACITY:\r\nif (!is_batt_present(cm)) {\r\nval->intval = 100;\r\nbreak;\r\n}\r\nfuel_gauge = power_supply_get_by_name(cm->desc->psy_fuel_gauge);\r\nif (!fuel_gauge) {\r\nret = -ENODEV;\r\nbreak;\r\n}\r\nret = power_supply_get_property(fuel_gauge,\r\nPOWER_SUPPLY_PROP_CAPACITY, val);\r\nif (ret)\r\nbreak;\r\nif (val->intval > 100) {\r\nval->intval = 100;\r\nbreak;\r\n}\r\nif (val->intval < 0)\r\nval->intval = 0;\r\nif (is_charging(cm))\r\nbreak;\r\nret = get_batt_uV(cm, &uV);\r\nif (ret) {\r\nret = 0;\r\nbreak;\r\n}\r\nif (desc->fullbatt_uV > 0 && uV >= desc->fullbatt_uV &&\r\n!is_charging(cm)) {\r\nval->intval = 100;\r\nbreak;\r\n}\r\nbreak;\r\ncase POWER_SUPPLY_PROP_ONLINE:\r\nif (is_ext_pwr_online(cm))\r\nval->intval = 1;\r\nelse\r\nval->intval = 0;\r\nbreak;\r\ncase POWER_SUPPLY_PROP_CHARGE_FULL:\r\nif (is_full_charged(cm))\r\nval->intval = 1;\r\nelse\r\nval->intval = 0;\r\nret = 0;\r\nbreak;\r\ncase POWER_SUPPLY_PROP_CHARGE_NOW:\r\nif (is_charging(cm)) {\r\nfuel_gauge = power_supply_get_by_name(\r\ncm->desc->psy_fuel_gauge);\r\nif (!fuel_gauge) {\r\nret = -ENODEV;\r\nbreak;\r\n}\r\nret = power_supply_get_property(fuel_gauge,\r\nPOWER_SUPPLY_PROP_CHARGE_NOW,\r\nval);\r\nif (ret) {\r\nval->intval = 1;\r\nret = 0;\r\n} else {\r\nval->intval = (val->intval > 0) ?\r\nval->intval : 1;\r\n}\r\n} else {\r\nval->intval = 0;\r\n}\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nif (fuel_gauge)\r\npower_supply_put(fuel_gauge);\r\nreturn ret;\r\n}\r\nstatic bool cm_setup_timer(void)\r\n{\r\nstruct charger_manager *cm;\r\nunsigned int wakeup_ms = UINT_MAX;\r\nint timer_req = 0;\r\nif (time_after(next_polling, jiffies))\r\nCM_MIN_VALID(wakeup_ms,\r\njiffies_to_msecs(next_polling - jiffies));\r\nmutex_lock(&cm_list_mtx);\r\nlist_for_each_entry(cm, &cm_list, entry) {\r\nunsigned int fbchk_ms = 0;\r\nif (cm->fullbatt_vchk_jiffies_at) {\r\nfbchk_ms = jiffies_to_msecs(cm->fullbatt_vchk_jiffies_at\r\n- jiffies);\r\nif (time_is_before_eq_jiffies(\r\ncm->fullbatt_vchk_jiffies_at) ||\r\nmsecs_to_jiffies(fbchk_ms) < CM_JIFFIES_SMALL) {\r\nfullbatt_vchk(&cm->fullbatt_vchk_work.work);\r\nfbchk_ms = 0;\r\n}\r\n}\r\nCM_MIN_VALID(wakeup_ms, fbchk_ms);\r\nif (!is_polling_required(cm) && !cm->emergency_stop)\r\ncontinue;\r\ntimer_req++;\r\nif (cm->desc->polling_interval_ms == 0)\r\ncontinue;\r\nCM_MIN_VALID(wakeup_ms, cm->desc->polling_interval_ms);\r\n}\r\nmutex_unlock(&cm_list_mtx);\r\nif (timer_req && cm_timer) {\r\nktime_t now, add;\r\nif (wakeup_ms == UINT_MAX ||\r\nwakeup_ms < CM_RTC_SMALL * MSEC_PER_SEC)\r\nwakeup_ms = 2 * CM_RTC_SMALL * MSEC_PER_SEC;\r\npr_info("Charger Manager wakeup timer: %u ms\n", wakeup_ms);\r\nnow = ktime_get_boottime();\r\nadd = ktime_set(wakeup_ms / MSEC_PER_SEC,\r\n(wakeup_ms % MSEC_PER_SEC) * NSEC_PER_MSEC);\r\nalarm_start(cm_timer, ktime_add(now, add));\r\ncm_suspend_duration_ms = wakeup_ms;\r\nreturn true;\r\n}\r\nreturn false;\r\n}\r\nstatic void charger_extcon_work(struct work_struct *work)\r\n{\r\nstruct charger_cable *cable =\r\ncontainer_of(work, struct charger_cable, wq);\r\nint ret;\r\nif (cable->attached && cable->min_uA != 0 && cable->max_uA != 0) {\r\nret = regulator_set_current_limit(cable->charger->consumer,\r\ncable->min_uA, cable->max_uA);\r\nif (ret < 0) {\r\npr_err("Cannot set current limit of %s (%s)\n",\r\ncable->charger->regulator_name, cable->name);\r\nreturn;\r\n}\r\npr_info("Set current limit of %s : %duA ~ %duA\n",\r\ncable->charger->regulator_name,\r\ncable->min_uA, cable->max_uA);\r\n}\r\ntry_charger_enable(cable->cm, cable->attached);\r\n}\r\nstatic int charger_extcon_notifier(struct notifier_block *self,\r\nunsigned long event, void *ptr)\r\n{\r\nstruct charger_cable *cable =\r\ncontainer_of(self, struct charger_cable, nb);\r\ncable->attached = event;\r\nif (cable->attached && is_polling_required(cable->cm)) {\r\ncancel_work_sync(&setup_polling);\r\nschedule_work(&setup_polling);\r\n}\r\nschedule_work(&cable->wq);\r\nreturn NOTIFY_DONE;\r\n}\r\nstatic int charger_extcon_init(struct charger_manager *cm,\r\nstruct charger_cable *cable)\r\n{\r\nint ret = 0;\r\nINIT_WORK(&cable->wq, charger_extcon_work);\r\ncable->nb.notifier_call = charger_extcon_notifier;\r\nret = extcon_register_interest(&cable->extcon_dev,\r\ncable->extcon_name, cable->name, &cable->nb);\r\nif (ret < 0) {\r\npr_info("Cannot register extcon_dev for %s(cable: %s)\n",\r\ncable->extcon_name, cable->name);\r\nret = -EINVAL;\r\n}\r\nreturn ret;\r\n}\r\nstatic int charger_manager_register_extcon(struct charger_manager *cm)\r\n{\r\nstruct charger_desc *desc = cm->desc;\r\nstruct charger_regulator *charger;\r\nint ret = 0;\r\nint i;\r\nint j;\r\nfor (i = 0; i < desc->num_charger_regulators; i++) {\r\ncharger = &desc->charger_regulators[i];\r\ncharger->consumer = regulator_get(cm->dev,\r\ncharger->regulator_name);\r\nif (IS_ERR(charger->consumer)) {\r\ndev_err(cm->dev, "Cannot find charger(%s)\n",\r\ncharger->regulator_name);\r\nreturn PTR_ERR(charger->consumer);\r\n}\r\ncharger->cm = cm;\r\nfor (j = 0; j < charger->num_cables; j++) {\r\nstruct charger_cable *cable = &charger->cables[j];\r\nret = charger_extcon_init(cm, cable);\r\nif (ret < 0) {\r\ndev_err(cm->dev, "Cannot initialize charger(%s)\n",\r\ncharger->regulator_name);\r\ngoto err;\r\n}\r\ncable->charger = charger;\r\ncable->cm = cm;\r\n}\r\n}\r\nerr:\r\nreturn ret;\r\n}\r\nstatic ssize_t charger_name_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct charger_regulator *charger\r\n= container_of(attr, struct charger_regulator, attr_name);\r\nreturn sprintf(buf, "%s\n", charger->regulator_name);\r\n}\r\nstatic ssize_t charger_state_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct charger_regulator *charger\r\n= container_of(attr, struct charger_regulator, attr_state);\r\nint state = 0;\r\nif (!charger->externally_control)\r\nstate = regulator_is_enabled(charger->consumer);\r\nreturn sprintf(buf, "%s\n", state ? "enabled" : "disabled");\r\n}\r\nstatic ssize_t charger_externally_control_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct charger_regulator *charger = container_of(attr,\r\nstruct charger_regulator, attr_externally_control);\r\nreturn sprintf(buf, "%d\n", charger->externally_control);\r\n}\r\nstatic ssize_t charger_externally_control_store(struct device *dev,\r\nstruct device_attribute *attr, const char *buf,\r\nsize_t count)\r\n{\r\nstruct charger_regulator *charger\r\n= container_of(attr, struct charger_regulator,\r\nattr_externally_control);\r\nstruct charger_manager *cm = charger->cm;\r\nstruct charger_desc *desc = cm->desc;\r\nint i;\r\nint ret;\r\nint externally_control;\r\nint chargers_externally_control = 1;\r\nret = sscanf(buf, "%d", &externally_control);\r\nif (ret == 0) {\r\nret = -EINVAL;\r\nreturn ret;\r\n}\r\nif (!externally_control) {\r\ncharger->externally_control = 0;\r\nreturn count;\r\n}\r\nfor (i = 0; i < desc->num_charger_regulators; i++) {\r\nif (&desc->charger_regulators[i] != charger &&\r\n!desc->charger_regulators[i].externally_control) {\r\nchargers_externally_control = 0;\r\nbreak;\r\n}\r\n}\r\nif (!chargers_externally_control) {\r\nif (cm->charger_enabled) {\r\ntry_charger_enable(charger->cm, false);\r\ncharger->externally_control = externally_control;\r\ntry_charger_enable(charger->cm, true);\r\n} else {\r\ncharger->externally_control = externally_control;\r\n}\r\n} else {\r\ndev_warn(cm->dev,\r\n"'%s' regulator should be controlled in charger-manager because charger-manager must need at least one charger for charging\n",\r\ncharger->regulator_name);\r\n}\r\nreturn count;\r\n}\r\nstatic int charger_manager_register_sysfs(struct charger_manager *cm)\r\n{\r\nstruct charger_desc *desc = cm->desc;\r\nstruct charger_regulator *charger;\r\nint chargers_externally_control = 1;\r\nchar buf[11];\r\nchar *str;\r\nint ret = 0;\r\nint i;\r\nfor (i = 0; i < desc->num_charger_regulators; i++) {\r\ncharger = &desc->charger_regulators[i];\r\nsnprintf(buf, 10, "charger.%d", i);\r\nstr = devm_kzalloc(cm->dev,\r\nsizeof(char) * (strlen(buf) + 1), GFP_KERNEL);\r\nif (!str) {\r\nret = -ENOMEM;\r\ngoto err;\r\n}\r\nstrcpy(str, buf);\r\ncharger->attrs[0] = &charger->attr_name.attr;\r\ncharger->attrs[1] = &charger->attr_state.attr;\r\ncharger->attrs[2] = &charger->attr_externally_control.attr;\r\ncharger->attrs[3] = NULL;\r\ncharger->attr_g.name = str;\r\ncharger->attr_g.attrs = charger->attrs;\r\nsysfs_attr_init(&charger->attr_name.attr);\r\ncharger->attr_name.attr.name = "name";\r\ncharger->attr_name.attr.mode = 0444;\r\ncharger->attr_name.show = charger_name_show;\r\nsysfs_attr_init(&charger->attr_state.attr);\r\ncharger->attr_state.attr.name = "state";\r\ncharger->attr_state.attr.mode = 0444;\r\ncharger->attr_state.show = charger_state_show;\r\nsysfs_attr_init(&charger->attr_externally_control.attr);\r\ncharger->attr_externally_control.attr.name\r\n= "externally_control";\r\ncharger->attr_externally_control.attr.mode = 0644;\r\ncharger->attr_externally_control.show\r\n= charger_externally_control_show;\r\ncharger->attr_externally_control.store\r\n= charger_externally_control_store;\r\nif (!desc->charger_regulators[i].externally_control ||\r\n!chargers_externally_control)\r\nchargers_externally_control = 0;\r\ndev_info(cm->dev, "'%s' regulator's externally_control is %d\n",\r\ncharger->regulator_name, charger->externally_control);\r\nret = sysfs_create_group(&cm->charger_psy->dev.kobj,\r\n&charger->attr_g);\r\nif (ret < 0) {\r\ndev_err(cm->dev, "Cannot create sysfs entry of %s regulator\n",\r\ncharger->regulator_name);\r\nret = -EINVAL;\r\ngoto err;\r\n}\r\n}\r\nif (chargers_externally_control) {\r\ndev_err(cm->dev, "Cannot register regulator because charger-manager must need at least one charger for charging battery\n");\r\nret = -EINVAL;\r\ngoto err;\r\n}\r\nerr:\r\nreturn ret;\r\n}\r\nstatic int cm_init_thermal_data(struct charger_manager *cm,\r\nstruct power_supply *fuel_gauge)\r\n{\r\nstruct charger_desc *desc = cm->desc;\r\nunion power_supply_propval val;\r\nint ret;\r\nret = power_supply_get_property(fuel_gauge,\r\nPOWER_SUPPLY_PROP_TEMP, &val);\r\nif (!ret) {\r\ncm->charger_psy_desc.properties[cm->charger_psy_desc.num_properties] =\r\nPOWER_SUPPLY_PROP_TEMP;\r\ncm->charger_psy_desc.num_properties++;\r\ncm->desc->measure_battery_temp = true;\r\n}\r\n#ifdef CONFIG_THERMAL\r\nif (ret && desc->thermal_zone) {\r\ncm->tzd_batt =\r\nthermal_zone_get_zone_by_name(desc->thermal_zone);\r\nif (IS_ERR(cm->tzd_batt))\r\nreturn PTR_ERR(cm->tzd_batt);\r\ncm->charger_psy_desc.properties[cm->charger_psy_desc.num_properties] =\r\nPOWER_SUPPLY_PROP_TEMP_AMBIENT;\r\ncm->charger_psy_desc.num_properties++;\r\ncm->desc->measure_battery_temp = true;\r\nret = 0;\r\n}\r\n#endif\r\nif (cm->desc->measure_battery_temp) {\r\nif (!desc->temp_max)\r\ndesc->temp_max = CM_DEFAULT_CHARGE_TEMP_MAX;\r\nif (!desc->temp_diff)\r\ndesc->temp_diff = CM_DEFAULT_RECHARGE_TEMP_DIFF;\r\n}\r\nreturn ret;\r\n}\r\nstatic struct charger_desc *of_cm_parse_desc(struct device *dev)\r\n{\r\nstruct charger_desc *desc;\r\nstruct device_node *np = dev->of_node;\r\nu32 poll_mode = CM_POLL_DISABLE;\r\nu32 battery_stat = CM_NO_BATTERY;\r\nint num_chgs = 0;\r\ndesc = devm_kzalloc(dev, sizeof(*desc), GFP_KERNEL);\r\nif (!desc)\r\nreturn ERR_PTR(-ENOMEM);\r\nof_property_read_string(np, "cm-name", &desc->psy_name);\r\nof_property_read_u32(np, "cm-poll-mode", &poll_mode);\r\ndesc->polling_mode = poll_mode;\r\nof_property_read_u32(np, "cm-poll-interval",\r\n&desc->polling_interval_ms);\r\nof_property_read_u32(np, "cm-fullbatt-vchkdrop-ms",\r\n&desc->fullbatt_vchkdrop_ms);\r\nof_property_read_u32(np, "cm-fullbatt-vchkdrop-volt",\r\n&desc->fullbatt_vchkdrop_uV);\r\nof_property_read_u32(np, "cm-fullbatt-voltage", &desc->fullbatt_uV);\r\nof_property_read_u32(np, "cm-fullbatt-soc", &desc->fullbatt_soc);\r\nof_property_read_u32(np, "cm-fullbatt-capacity",\r\n&desc->fullbatt_full_capacity);\r\nof_property_read_u32(np, "cm-battery-stat", &battery_stat);\r\ndesc->battery_present = battery_stat;\r\nof_property_read_u32(np, "cm-num-chargers", &num_chgs);\r\nif (num_chgs) {\r\ndesc->psy_charger_stat = devm_kzalloc(dev, sizeof(char *)\r\n* (num_chgs + 1), GFP_KERNEL);\r\nif (desc->psy_charger_stat) {\r\nint i;\r\nfor (i = 0; i < num_chgs; i++)\r\nof_property_read_string_index(np, "cm-chargers",\r\ni, &desc->psy_charger_stat[i]);\r\n} else {\r\nreturn ERR_PTR(-ENOMEM);\r\n}\r\n}\r\nof_property_read_string(np, "cm-fuel-gauge", &desc->psy_fuel_gauge);\r\nof_property_read_string(np, "cm-thermal-zone", &desc->thermal_zone);\r\nof_property_read_u32(np, "cm-battery-cold", &desc->temp_min);\r\nif (of_get_property(np, "cm-battery-cold-in-minus", NULL))\r\ndesc->temp_min *= -1;\r\nof_property_read_u32(np, "cm-battery-hot", &desc->temp_max);\r\nof_property_read_u32(np, "cm-battery-temp-diff", &desc->temp_diff);\r\nof_property_read_u32(np, "cm-charging-max",\r\n&desc->charging_max_duration_ms);\r\nof_property_read_u32(np, "cm-discharging-max",\r\n&desc->discharging_max_duration_ms);\r\ndesc->num_charger_regulators = of_get_child_count(np);\r\nif (desc->num_charger_regulators) {\r\nstruct charger_regulator *chg_regs;\r\nstruct device_node *child;\r\nchg_regs = devm_kzalloc(dev, sizeof(*chg_regs)\r\n* desc->num_charger_regulators,\r\nGFP_KERNEL);\r\nif (!chg_regs)\r\nreturn ERR_PTR(-ENOMEM);\r\ndesc->charger_regulators = chg_regs;\r\nfor_each_child_of_node(np, child) {\r\nstruct charger_cable *cables;\r\nstruct device_node *_child;\r\nof_property_read_string(child, "cm-regulator-name",\r\n&chg_regs->regulator_name);\r\nchg_regs->num_cables = of_get_child_count(child);\r\nif (chg_regs->num_cables) {\r\ncables = devm_kzalloc(dev, sizeof(*cables)\r\n* chg_regs->num_cables,\r\nGFP_KERNEL);\r\nif (!cables) {\r\nof_node_put(child);\r\nreturn ERR_PTR(-ENOMEM);\r\n}\r\nchg_regs->cables = cables;\r\nfor_each_child_of_node(child, _child) {\r\nof_property_read_string(_child,\r\n"cm-cable-name", &cables->name);\r\nof_property_read_string(_child,\r\n"cm-cable-extcon",\r\n&cables->extcon_name);\r\nof_property_read_u32(_child,\r\n"cm-cable-min",\r\n&cables->min_uA);\r\nof_property_read_u32(_child,\r\n"cm-cable-max",\r\n&cables->max_uA);\r\ncables++;\r\n}\r\n}\r\nchg_regs++;\r\n}\r\n}\r\nreturn desc;\r\n}\r\nstatic inline struct charger_desc *cm_get_drv_data(struct platform_device *pdev)\r\n{\r\nif (pdev->dev.of_node)\r\nreturn of_cm_parse_desc(&pdev->dev);\r\nreturn dev_get_platdata(&pdev->dev);\r\n}\r\nstatic enum alarmtimer_restart cm_timer_func(struct alarm *alarm, ktime_t now)\r\n{\r\ncm_timer_set = false;\r\nreturn ALARMTIMER_NORESTART;\r\n}\r\nstatic int charger_manager_probe(struct platform_device *pdev)\r\n{\r\nstruct charger_desc *desc = cm_get_drv_data(pdev);\r\nstruct charger_manager *cm;\r\nint ret = 0, i = 0;\r\nint j = 0;\r\nunion power_supply_propval val;\r\nstruct power_supply *fuel_gauge;\r\nstruct power_supply_config psy_cfg = {};\r\nif (IS_ERR(desc)) {\r\ndev_err(&pdev->dev, "No platform data (desc) found\n");\r\nreturn -ENODEV;\r\n}\r\ncm = devm_kzalloc(&pdev->dev,\r\nsizeof(struct charger_manager), GFP_KERNEL);\r\nif (!cm)\r\nreturn -ENOMEM;\r\ncm->dev = &pdev->dev;\r\ncm->desc = desc;\r\npsy_cfg.drv_data = cm;\r\nif (alarmtimer_get_rtcdev()) {\r\ncm_timer = devm_kzalloc(cm->dev, sizeof(*cm_timer), GFP_KERNEL);\r\nalarm_init(cm_timer, ALARM_BOOTTIME, cm_timer_func);\r\n}\r\nif (desc->fullbatt_uV == 0) {\r\ndev_info(&pdev->dev, "Ignoring full-battery voltage threshold as it is not supplied\n");\r\n}\r\nif (!desc->fullbatt_vchkdrop_ms || !desc->fullbatt_vchkdrop_uV) {\r\ndev_info(&pdev->dev, "Disabling full-battery voltage drop checking mechanism as it is not supplied\n");\r\ndesc->fullbatt_vchkdrop_ms = 0;\r\ndesc->fullbatt_vchkdrop_uV = 0;\r\n}\r\nif (desc->fullbatt_soc == 0) {\r\ndev_info(&pdev->dev, "Ignoring full-battery soc(state of charge) threshold as it is not supplied\n");\r\n}\r\nif (desc->fullbatt_full_capacity == 0) {\r\ndev_info(&pdev->dev, "Ignoring full-battery full capacity threshold as it is not supplied\n");\r\n}\r\nif (!desc->charger_regulators || desc->num_charger_regulators < 1) {\r\ndev_err(&pdev->dev, "charger_regulators undefined\n");\r\nreturn -EINVAL;\r\n}\r\nif (!desc->psy_charger_stat || !desc->psy_charger_stat[0]) {\r\ndev_err(&pdev->dev, "No power supply defined\n");\r\nreturn -EINVAL;\r\n}\r\nif (!desc->psy_fuel_gauge) {\r\ndev_err(&pdev->dev, "No fuel gauge power supply defined\n");\r\nreturn -EINVAL;\r\n}\r\nwhile (desc->psy_charger_stat[i])\r\ni++;\r\nfor (i = 0; desc->psy_charger_stat[i]; i++) {\r\nstruct power_supply *psy;\r\npsy = power_supply_get_by_name(desc->psy_charger_stat[i]);\r\nif (!psy) {\r\ndev_err(&pdev->dev, "Cannot find power supply \"%s\"\n",\r\ndesc->psy_charger_stat[i]);\r\nreturn -ENODEV;\r\n}\r\npower_supply_put(psy);\r\n}\r\nif (desc->polling_interval_ms == 0 ||\r\nmsecs_to_jiffies(desc->polling_interval_ms) <= CM_JIFFIES_SMALL) {\r\ndev_err(&pdev->dev, "polling_interval_ms is too small\n");\r\nreturn -EINVAL;\r\n}\r\nif (!desc->charging_max_duration_ms ||\r\n!desc->discharging_max_duration_ms) {\r\ndev_info(&pdev->dev, "Cannot limit charging duration checking mechanism to prevent overcharge/overheat and control discharging duration\n");\r\ndesc->charging_max_duration_ms = 0;\r\ndesc->discharging_max_duration_ms = 0;\r\n}\r\nplatform_set_drvdata(pdev, cm);\r\nmemcpy(&cm->charger_psy_desc, &psy_default, sizeof(psy_default));\r\nif (!desc->psy_name)\r\nstrncpy(cm->psy_name_buf, psy_default.name, PSY_NAME_MAX);\r\nelse\r\nstrncpy(cm->psy_name_buf, desc->psy_name, PSY_NAME_MAX);\r\ncm->charger_psy_desc.name = cm->psy_name_buf;\r\ncm->charger_psy_desc.properties = devm_kzalloc(&pdev->dev,\r\nsizeof(enum power_supply_property)\r\n* (ARRAY_SIZE(default_charger_props) +\r\nNUM_CHARGER_PSY_OPTIONAL), GFP_KERNEL);\r\nif (!cm->charger_psy_desc.properties)\r\nreturn -ENOMEM;\r\nmemcpy(cm->charger_psy_desc.properties, default_charger_props,\r\nsizeof(enum power_supply_property) *\r\nARRAY_SIZE(default_charger_props));\r\ncm->charger_psy_desc.num_properties = psy_default.num_properties;\r\nfuel_gauge = power_supply_get_by_name(desc->psy_fuel_gauge);\r\nif (!fuel_gauge) {\r\ndev_err(&pdev->dev, "Cannot find power supply \"%s\"\n",\r\ndesc->psy_fuel_gauge);\r\nreturn -ENODEV;\r\n}\r\nif (!power_supply_get_property(fuel_gauge,\r\nPOWER_SUPPLY_PROP_CHARGE_NOW, &val)) {\r\ncm->charger_psy_desc.properties[cm->charger_psy_desc.num_properties] =\r\nPOWER_SUPPLY_PROP_CHARGE_NOW;\r\ncm->charger_psy_desc.num_properties++;\r\n}\r\nif (!power_supply_get_property(fuel_gauge,\r\nPOWER_SUPPLY_PROP_CURRENT_NOW,\r\n&val)) {\r\ncm->charger_psy_desc.properties[cm->charger_psy_desc.num_properties] =\r\nPOWER_SUPPLY_PROP_CURRENT_NOW;\r\ncm->charger_psy_desc.num_properties++;\r\n}\r\nret = cm_init_thermal_data(cm, fuel_gauge);\r\nif (ret) {\r\ndev_err(&pdev->dev, "Failed to initialize thermal data\n");\r\ncm->desc->measure_battery_temp = false;\r\n}\r\npower_supply_put(fuel_gauge);\r\nINIT_DELAYED_WORK(&cm->fullbatt_vchk_work, fullbatt_vchk);\r\ncm->charger_psy = power_supply_register(&pdev->dev,\r\n&cm->charger_psy_desc,\r\n&psy_cfg);\r\nif (IS_ERR(cm->charger_psy)) {\r\ndev_err(&pdev->dev, "Cannot register charger-manager with name \"%s\"\n",\r\ncm->charger_psy_desc.name);\r\nreturn PTR_ERR(cm->charger_psy);\r\n}\r\nret = charger_manager_register_extcon(cm);\r\nif (ret < 0) {\r\ndev_err(&pdev->dev, "Cannot initialize extcon device\n");\r\ngoto err_reg_extcon;\r\n}\r\nret = charger_manager_register_sysfs(cm);\r\nif (ret < 0) {\r\ndev_err(&pdev->dev,\r\n"Cannot initialize sysfs entry of regulator\n");\r\ngoto err_reg_sysfs;\r\n}\r\nmutex_lock(&cm_list_mtx);\r\nlist_add(&cm->entry, &cm_list);\r\nmutex_unlock(&cm_list_mtx);\r\ndevice_init_wakeup(&pdev->dev, true);\r\ndevice_set_wakeup_capable(&pdev->dev, false);\r\ncm_monitor();\r\nschedule_work(&setup_polling);\r\nreturn 0;\r\nerr_reg_sysfs:\r\nfor (i = 0; i < desc->num_charger_regulators; i++) {\r\nstruct charger_regulator *charger;\r\ncharger = &desc->charger_regulators[i];\r\nsysfs_remove_group(&cm->charger_psy->dev.kobj,\r\n&charger->attr_g);\r\n}\r\nerr_reg_extcon:\r\nfor (i = 0; i < desc->num_charger_regulators; i++) {\r\nstruct charger_regulator *charger;\r\ncharger = &desc->charger_regulators[i];\r\nfor (j = 0; j < charger->num_cables; j++) {\r\nstruct charger_cable *cable = &charger->cables[j];\r\nif (cable->extcon_dev.edev)\r\nextcon_unregister_interest(&cable->extcon_dev);\r\n}\r\nregulator_put(desc->charger_regulators[i].consumer);\r\n}\r\npower_supply_unregister(cm->charger_psy);\r\nreturn ret;\r\n}\r\nstatic int charger_manager_remove(struct platform_device *pdev)\r\n{\r\nstruct charger_manager *cm = platform_get_drvdata(pdev);\r\nstruct charger_desc *desc = cm->desc;\r\nint i = 0;\r\nint j = 0;\r\nmutex_lock(&cm_list_mtx);\r\nlist_del(&cm->entry);\r\nmutex_unlock(&cm_list_mtx);\r\ncancel_work_sync(&setup_polling);\r\ncancel_delayed_work_sync(&cm_monitor_work);\r\nfor (i = 0 ; i < desc->num_charger_regulators ; i++) {\r\nstruct charger_regulator *charger\r\n= &desc->charger_regulators[i];\r\nfor (j = 0 ; j < charger->num_cables ; j++) {\r\nstruct charger_cable *cable = &charger->cables[j];\r\nextcon_unregister_interest(&cable->extcon_dev);\r\n}\r\n}\r\nfor (i = 0 ; i < desc->num_charger_regulators ; i++)\r\nregulator_put(desc->charger_regulators[i].consumer);\r\npower_supply_unregister(cm->charger_psy);\r\ntry_charger_enable(cm, false);\r\nreturn 0;\r\n}\r\nstatic int cm_suspend_noirq(struct device *dev)\r\n{\r\nint ret = 0;\r\nif (device_may_wakeup(dev)) {\r\ndevice_set_wakeup_capable(dev, false);\r\nret = -EAGAIN;\r\n}\r\nreturn ret;\r\n}\r\nstatic bool cm_need_to_awake(void)\r\n{\r\nstruct charger_manager *cm;\r\nif (cm_timer)\r\nreturn false;\r\nmutex_lock(&cm_list_mtx);\r\nlist_for_each_entry(cm, &cm_list, entry) {\r\nif (is_charging(cm)) {\r\nmutex_unlock(&cm_list_mtx);\r\nreturn true;\r\n}\r\n}\r\nmutex_unlock(&cm_list_mtx);\r\nreturn false;\r\n}\r\nstatic int cm_suspend_prepare(struct device *dev)\r\n{\r\nstruct charger_manager *cm = dev_get_drvdata(dev);\r\nif (cm_need_to_awake())\r\nreturn -EBUSY;\r\nif (!cm_suspended)\r\ncm_suspended = true;\r\ncm_timer_set = cm_setup_timer();\r\nif (cm_timer_set) {\r\ncancel_work_sync(&setup_polling);\r\ncancel_delayed_work_sync(&cm_monitor_work);\r\ncancel_delayed_work(&cm->fullbatt_vchk_work);\r\n}\r\nreturn 0;\r\n}\r\nstatic void cm_suspend_complete(struct device *dev)\r\n{\r\nstruct charger_manager *cm = dev_get_drvdata(dev);\r\nif (cm_suspended)\r\ncm_suspended = false;\r\nif (cm_timer_set) {\r\nktime_t remain;\r\nalarm_cancel(cm_timer);\r\ncm_timer_set = false;\r\nremain = alarm_expires_remaining(cm_timer);\r\ncm_suspend_duration_ms -= ktime_to_ms(remain);\r\nschedule_work(&setup_polling);\r\n}\r\n_cm_monitor(cm);\r\nif (cm->fullbatt_vchk_jiffies_at) {\r\nunsigned long delay = 0;\r\nunsigned long now = jiffies + CM_JIFFIES_SMALL;\r\nif (time_after_eq(now, cm->fullbatt_vchk_jiffies_at)) {\r\ndelay = (unsigned long)((long)now\r\n- (long)(cm->fullbatt_vchk_jiffies_at));\r\ndelay = jiffies_to_msecs(delay);\r\n} else {\r\ndelay = 0;\r\n}\r\nif (delay > cm_suspend_duration_ms)\r\ndelay -= cm_suspend_duration_ms;\r\nelse\r\ndelay = 0;\r\nqueue_delayed_work(cm_wq, &cm->fullbatt_vchk_work,\r\nmsecs_to_jiffies(delay));\r\n}\r\ndevice_set_wakeup_capable(cm->dev, false);\r\n}\r\nstatic int __init charger_manager_init(void)\r\n{\r\ncm_wq = create_freezable_workqueue("charger_manager");\r\nINIT_DELAYED_WORK(&cm_monitor_work, cm_monitor_poller);\r\nreturn platform_driver_register(&charger_manager_driver);\r\n}\r\nstatic void __exit charger_manager_cleanup(void)\r\n{\r\ndestroy_workqueue(cm_wq);\r\ncm_wq = NULL;\r\nplatform_driver_unregister(&charger_manager_driver);\r\n}\r\nstatic bool find_power_supply(struct charger_manager *cm,\r\nstruct power_supply *psy)\r\n{\r\nint i;\r\nbool found = false;\r\nfor (i = 0; cm->desc->psy_charger_stat[i]; i++) {\r\nif (!strcmp(psy->desc->name, cm->desc->psy_charger_stat[i])) {\r\nfound = true;\r\nbreak;\r\n}\r\n}\r\nreturn found;\r\n}\r\nvoid cm_notify_event(struct power_supply *psy, enum cm_event_types type,\r\nchar *msg)\r\n{\r\nstruct charger_manager *cm;\r\nbool found_power_supply = false;\r\nif (psy == NULL)\r\nreturn;\r\nmutex_lock(&cm_list_mtx);\r\nlist_for_each_entry(cm, &cm_list, entry) {\r\nfound_power_supply = find_power_supply(cm, psy);\r\nif (found_power_supply)\r\nbreak;\r\n}\r\nmutex_unlock(&cm_list_mtx);\r\nif (!found_power_supply)\r\nreturn;\r\nswitch (type) {\r\ncase CM_EVENT_BATT_FULL:\r\nfullbatt_handler(cm);\r\nbreak;\r\ncase CM_EVENT_BATT_OUT:\r\nbattout_handler(cm);\r\nbreak;\r\ncase CM_EVENT_BATT_IN:\r\ncase CM_EVENT_EXT_PWR_IN_OUT ... CM_EVENT_CHG_START_STOP:\r\nmisc_event_handler(cm, type);\r\nbreak;\r\ncase CM_EVENT_UNKNOWN:\r\ncase CM_EVENT_OTHERS:\r\nuevent_notify(cm, msg ? msg : default_event_names[type]);\r\nbreak;\r\ndefault:\r\ndev_err(cm->dev, "%s: type not specified\n", __func__);\r\nbreak;\r\n}\r\n}
