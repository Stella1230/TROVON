u64 cper_next_record_id(void)\r\n{\r\nstatic atomic64_t seq;\r\nif (!atomic64_read(&seq))\r\natomic64_set(&seq, ((u64)get_seconds()) << 32);\r\nreturn atomic64_inc_return(&seq);\r\n}\r\nconst char *cper_severity_str(unsigned int severity)\r\n{\r\nreturn severity < ARRAY_SIZE(severity_strs) ?\r\nseverity_strs[severity] : "unknown";\r\n}\r\nvoid cper_print_bits(const char *pfx, unsigned int bits,\r\nconst char * const strs[], unsigned int strs_size)\r\n{\r\nint i, len = 0;\r\nconst char *str;\r\nchar buf[84];\r\nfor (i = 0; i < strs_size; i++) {\r\nif (!(bits & (1U << i)))\r\ncontinue;\r\nstr = strs[i];\r\nif (!str)\r\ncontinue;\r\nif (len && len + strlen(str) + 2 > 80) {\r\nprintk("%s\n", buf);\r\nlen = 0;\r\n}\r\nif (!len)\r\nlen = snprintf(buf, sizeof(buf), "%s%s", pfx, str);\r\nelse\r\nlen += snprintf(buf+len, sizeof(buf)-len, ", %s", str);\r\n}\r\nif (len)\r\nprintk("%s\n", buf);\r\n}\r\nstatic void cper_print_proc_generic(const char *pfx,\r\nconst struct cper_sec_proc_generic *proc)\r\n{\r\nif (proc->validation_bits & CPER_PROC_VALID_TYPE)\r\nprintk("%s""processor_type: %d, %s\n", pfx, proc->proc_type,\r\nproc->proc_type < ARRAY_SIZE(proc_type_strs) ?\r\nproc_type_strs[proc->proc_type] : "unknown");\r\nif (proc->validation_bits & CPER_PROC_VALID_ISA)\r\nprintk("%s""processor_isa: %d, %s\n", pfx, proc->proc_isa,\r\nproc->proc_isa < ARRAY_SIZE(proc_isa_strs) ?\r\nproc_isa_strs[proc->proc_isa] : "unknown");\r\nif (proc->validation_bits & CPER_PROC_VALID_ERROR_TYPE) {\r\nprintk("%s""error_type: 0x%02x\n", pfx, proc->proc_error_type);\r\ncper_print_bits(pfx, proc->proc_error_type,\r\nproc_error_type_strs,\r\nARRAY_SIZE(proc_error_type_strs));\r\n}\r\nif (proc->validation_bits & CPER_PROC_VALID_OPERATION)\r\nprintk("%s""operation: %d, %s\n", pfx, proc->operation,\r\nproc->operation < ARRAY_SIZE(proc_op_strs) ?\r\nproc_op_strs[proc->operation] : "unknown");\r\nif (proc->validation_bits & CPER_PROC_VALID_FLAGS) {\r\nprintk("%s""flags: 0x%02x\n", pfx, proc->flags);\r\ncper_print_bits(pfx, proc->flags, proc_flag_strs,\r\nARRAY_SIZE(proc_flag_strs));\r\n}\r\nif (proc->validation_bits & CPER_PROC_VALID_LEVEL)\r\nprintk("%s""level: %d\n", pfx, proc->level);\r\nif (proc->validation_bits & CPER_PROC_VALID_VERSION)\r\nprintk("%s""version_info: 0x%016llx\n", pfx, proc->cpu_version);\r\nif (proc->validation_bits & CPER_PROC_VALID_ID)\r\nprintk("%s""processor_id: 0x%016llx\n", pfx, proc->proc_id);\r\nif (proc->validation_bits & CPER_PROC_VALID_TARGET_ADDRESS)\r\nprintk("%s""target_address: 0x%016llx\n",\r\npfx, proc->target_addr);\r\nif (proc->validation_bits & CPER_PROC_VALID_REQUESTOR_ID)\r\nprintk("%s""requestor_id: 0x%016llx\n",\r\npfx, proc->requestor_id);\r\nif (proc->validation_bits & CPER_PROC_VALID_RESPONDER_ID)\r\nprintk("%s""responder_id: 0x%016llx\n",\r\npfx, proc->responder_id);\r\nif (proc->validation_bits & CPER_PROC_VALID_IP)\r\nprintk("%s""IP: 0x%016llx\n", pfx, proc->ip);\r\n}\r\nstatic const char * const mem_err_type_strs[] = {\r\n"unknown",\r\n"no error",\r\n"single-bit ECC",\r\n"multi-bit ECC",\r\n"single-symbol chipkill ECC",\r\n"multi-symbol chipkill ECC",\r\n"master abort",\r\n"target abort",\r\n"parity error",\r\n"watchdog timeout",\r\n"invalid address",\r\n"mirror Broken",\r\n"memory sparing",\r\n"scrub corrected error",\r\n"scrub uncorrected error",\r\n"physical memory map-out event",\r\n};\r\nconst char *cper_mem_err_type_str(unsigned int etype)\r\n{\r\nreturn etype < ARRAY_SIZE(mem_err_type_strs) ?\r\nmem_err_type_strs[etype] : "unknown";\r\n}\r\nEXPORT_SYMBOL_GPL(cper_mem_err_type_str);\r\nstatic int cper_mem_err_location(struct cper_mem_err_compact *mem, char *msg)\r\n{\r\nu32 len, n;\r\nif (!msg)\r\nreturn 0;\r\nn = 0;\r\nlen = CPER_REC_LEN - 1;\r\nif (mem->validation_bits & CPER_MEM_VALID_NODE)\r\nn += scnprintf(msg + n, len - n, "node: %d ", mem->node);\r\nif (mem->validation_bits & CPER_MEM_VALID_CARD)\r\nn += scnprintf(msg + n, len - n, "card: %d ", mem->card);\r\nif (mem->validation_bits & CPER_MEM_VALID_MODULE)\r\nn += scnprintf(msg + n, len - n, "module: %d ", mem->module);\r\nif (mem->validation_bits & CPER_MEM_VALID_RANK_NUMBER)\r\nn += scnprintf(msg + n, len - n, "rank: %d ", mem->rank);\r\nif (mem->validation_bits & CPER_MEM_VALID_BANK)\r\nn += scnprintf(msg + n, len - n, "bank: %d ", mem->bank);\r\nif (mem->validation_bits & CPER_MEM_VALID_DEVICE)\r\nn += scnprintf(msg + n, len - n, "device: %d ", mem->device);\r\nif (mem->validation_bits & CPER_MEM_VALID_ROW)\r\nn += scnprintf(msg + n, len - n, "row: %d ", mem->row);\r\nif (mem->validation_bits & CPER_MEM_VALID_COLUMN)\r\nn += scnprintf(msg + n, len - n, "column: %d ", mem->column);\r\nif (mem->validation_bits & CPER_MEM_VALID_BIT_POSITION)\r\nn += scnprintf(msg + n, len - n, "bit_position: %d ",\r\nmem->bit_pos);\r\nif (mem->validation_bits & CPER_MEM_VALID_REQUESTOR_ID)\r\nn += scnprintf(msg + n, len - n, "requestor_id: 0x%016llx ",\r\nmem->requestor_id);\r\nif (mem->validation_bits & CPER_MEM_VALID_RESPONDER_ID)\r\nn += scnprintf(msg + n, len - n, "responder_id: 0x%016llx ",\r\nmem->responder_id);\r\nif (mem->validation_bits & CPER_MEM_VALID_TARGET_ID)\r\nscnprintf(msg + n, len - n, "target_id: 0x%016llx ",\r\nmem->target_id);\r\nmsg[n] = '\0';\r\nreturn n;\r\n}\r\nstatic int cper_dimm_err_location(struct cper_mem_err_compact *mem, char *msg)\r\n{\r\nu32 len, n;\r\nconst char *bank = NULL, *device = NULL;\r\nif (!msg || !(mem->validation_bits & CPER_MEM_VALID_MODULE_HANDLE))\r\nreturn 0;\r\nn = 0;\r\nlen = CPER_REC_LEN - 1;\r\ndmi_memdev_name(mem->mem_dev_handle, &bank, &device);\r\nif (bank && device)\r\nn = snprintf(msg, len, "DIMM location: %s %s ", bank, device);\r\nelse\r\nn = snprintf(msg, len,\r\n"DIMM location: not present. DMI handle: 0x%.4x ",\r\nmem->mem_dev_handle);\r\nmsg[n] = '\0';\r\nreturn n;\r\n}\r\nvoid cper_mem_err_pack(const struct cper_sec_mem_err *mem,\r\nstruct cper_mem_err_compact *cmem)\r\n{\r\ncmem->validation_bits = mem->validation_bits;\r\ncmem->node = mem->node;\r\ncmem->card = mem->card;\r\ncmem->module = mem->module;\r\ncmem->bank = mem->bank;\r\ncmem->device = mem->device;\r\ncmem->row = mem->row;\r\ncmem->column = mem->column;\r\ncmem->bit_pos = mem->bit_pos;\r\ncmem->requestor_id = mem->requestor_id;\r\ncmem->responder_id = mem->responder_id;\r\ncmem->target_id = mem->target_id;\r\ncmem->rank = mem->rank;\r\ncmem->mem_array_handle = mem->mem_array_handle;\r\ncmem->mem_dev_handle = mem->mem_dev_handle;\r\n}\r\nconst char *cper_mem_err_unpack(struct trace_seq *p,\r\nstruct cper_mem_err_compact *cmem)\r\n{\r\nconst char *ret = trace_seq_buffer_ptr(p);\r\nif (cper_mem_err_location(cmem, rcd_decode_str))\r\ntrace_seq_printf(p, "%s", rcd_decode_str);\r\nif (cper_dimm_err_location(cmem, rcd_decode_str))\r\ntrace_seq_printf(p, "%s", rcd_decode_str);\r\ntrace_seq_putc(p, '\0');\r\nreturn ret;\r\n}\r\nstatic void cper_print_mem(const char *pfx, const struct cper_sec_mem_err *mem,\r\nint len)\r\n{\r\nstruct cper_mem_err_compact cmem;\r\n/* Don't trust UEFI 2.1/2.2 structure with bad validation bits */\r\nif (len == sizeof(struct cper_sec_mem_err_old) &&\r\n(mem->validation_bits & ~(CPER_MEM_VALID_RANK_NUMBER - 1))) {\r\npr_err(FW_WARN "valid bits set for fields beyond structure\n");\r\nreturn;\r\n}\r\nif (mem->validation_bits & CPER_MEM_VALID_ERROR_STATUS)\r\nprintk("%s""error_status: 0x%016llx\n", pfx, mem->error_status);\r\nif (mem->validation_bits & CPER_MEM_VALID_PA)\r\nprintk("%s""physical_address: 0x%016llx\n",\r\npfx, mem->physical_addr);\r\nif (mem->validation_bits & CPER_MEM_VALID_PA_MASK)\r\nprintk("%s""physical_address_mask: 0x%016llx\n",\r\npfx, mem->physical_addr_mask);\r\ncper_mem_err_pack(mem, &cmem);\r\nif (cper_mem_err_location(&cmem, rcd_decode_str))\r\nprintk("%s%s\n", pfx, rcd_decode_str);\r\nif (mem->validation_bits & CPER_MEM_VALID_ERROR_TYPE) {\r\nu8 etype = mem->error_type;\r\nprintk("%s""error_type: %d, %s\n", pfx, etype,\r\ncper_mem_err_type_str(etype));\r\n}\r\nif (cper_dimm_err_location(&cmem, rcd_decode_str))\r\nprintk("%s%s\n", pfx, rcd_decode_str);\r\n}\r\nstatic const char * const pcie_port_type_strs[] = {\r\n"PCIe end point",\r\n"legacy PCI end point",\r\n"unknown",\r\n"unknown",\r\n"root port",\r\n"upstream switch port",\r\n"downstream switch port",\r\n"PCIe to PCI/PCI-X bridge",\r\n"PCI/PCI-X to PCIe bridge",\r\n"root complex integrated endpoint device",\r\n"root complex event collector",\r\n};\r\nstatic void cper_print_pcie(const char *pfx, const struct cper_sec_pcie *pcie,\r\nconst struct acpi_hest_generic_data *gdata)\r\n{\r\nif (pcie->validation_bits & CPER_PCIE_VALID_PORT_TYPE)\r\nprintk("%s""port_type: %d, %s\n", pfx, pcie->port_type,\r\npcie->port_type < ARRAY_SIZE(pcie_port_type_strs) ?\r\npcie_port_type_strs[pcie->port_type] : "unknown");\r\nif (pcie->validation_bits & CPER_PCIE_VALID_VERSION)\r\nprintk("%s""version: %d.%d\n", pfx,\r\npcie->version.major, pcie->version.minor);\r\nif (pcie->validation_bits & CPER_PCIE_VALID_COMMAND_STATUS)\r\nprintk("%s""command: 0x%04x, status: 0x%04x\n", pfx,\r\npcie->command, pcie->status);\r\nif (pcie->validation_bits & CPER_PCIE_VALID_DEVICE_ID) {\r\nconst __u8 *p;\r\nprintk("%s""device_id: %04x:%02x:%02x.%x\n", pfx,\r\npcie->device_id.segment, pcie->device_id.bus,\r\npcie->device_id.device, pcie->device_id.function);\r\nprintk("%s""slot: %d\n", pfx,\r\npcie->device_id.slot >> CPER_PCIE_SLOT_SHIFT);\r\nprintk("%s""secondary_bus: 0x%02x\n", pfx,\r\npcie->device_id.secondary_bus);\r\nprintk("%s""vendor_id: 0x%04x, device_id: 0x%04x\n", pfx,\r\npcie->device_id.vendor_id, pcie->device_id.device_id);\r\np = pcie->device_id.class_code;\r\nprintk("%s""class_code: %02x%02x%02x\n", pfx, p[0], p[1], p[2]);\r\n}\r\nif (pcie->validation_bits & CPER_PCIE_VALID_SERIAL_NUMBER)\r\nprintk("%s""serial number: 0x%04x, 0x%04x\n", pfx,\r\npcie->serial_number.lower, pcie->serial_number.upper);\r\nif (pcie->validation_bits & CPER_PCIE_VALID_BRIDGE_CONTROL_STATUS)\r\nprintk(\r\n"%s""bridge: secondary_status: 0x%04x, control: 0x%04x\n",\r\npfx, pcie->bridge.secondary_status, pcie->bridge.control);\r\n}\r\nstatic void cper_estatus_print_section(\r\nconst char *pfx, const struct acpi_hest_generic_data *gdata, int sec_no)\r\n{\r\nuuid_le *sec_type = (uuid_le *)gdata->section_type;\r\n__u16 severity;\r\nchar newpfx[64];\r\nseverity = gdata->error_severity;\r\nprintk("%s""Error %d, type: %s\n", pfx, sec_no,\r\ncper_severity_str(severity));\r\nif (gdata->validation_bits & CPER_SEC_VALID_FRU_ID)\r\nprintk("%s""fru_id: %pUl\n", pfx, (uuid_le *)gdata->fru_id);\r\nif (gdata->validation_bits & CPER_SEC_VALID_FRU_TEXT)\r\nprintk("%s""fru_text: %.20s\n", pfx, gdata->fru_text);\r\nsnprintf(newpfx, sizeof(newpfx), "%s%s", pfx, INDENT_SP);\r\nif (!uuid_le_cmp(*sec_type, CPER_SEC_PROC_GENERIC)) {\r\nstruct cper_sec_proc_generic *proc_err = (void *)(gdata + 1);\r\nprintk("%s""section_type: general processor error\n", newpfx);\r\nif (gdata->error_data_length >= sizeof(*proc_err))\r\ncper_print_proc_generic(newpfx, proc_err);\r\nelse\r\ngoto err_section_too_small;\r\n} else if (!uuid_le_cmp(*sec_type, CPER_SEC_PLATFORM_MEM)) {\r\nstruct cper_sec_mem_err *mem_err = (void *)(gdata + 1);\r\nprintk("%s""section_type: memory error\n", newpfx);\r\nif (gdata->error_data_length >=\r\nsizeof(struct cper_sec_mem_err_old))\r\ncper_print_mem(newpfx, mem_err,\r\ngdata->error_data_length);\r\nelse\r\ngoto err_section_too_small;\r\n} else if (!uuid_le_cmp(*sec_type, CPER_SEC_PCIE)) {\r\nstruct cper_sec_pcie *pcie = (void *)(gdata + 1);\r\nprintk("%s""section_type: PCIe error\n", newpfx);\r\nif (gdata->error_data_length >= sizeof(*pcie))\r\ncper_print_pcie(newpfx, pcie, gdata);\r\nelse\r\ngoto err_section_too_small;\r\n} else\r\nprintk("%s""section type: unknown, %pUl\n", newpfx, sec_type);\r\nreturn;\r\nerr_section_too_small:\r\npr_err(FW_WARN "error section length is too small\n");\r\n}\r\nvoid cper_estatus_print(const char *pfx,\r\nconst struct acpi_hest_generic_status *estatus)\r\n{\r\nstruct acpi_hest_generic_data *gdata;\r\nunsigned int data_len, gedata_len;\r\nint sec_no = 0;\r\nchar newpfx[64];\r\n__u16 severity;\r\nseverity = estatus->error_severity;\r\nif (severity == CPER_SEV_CORRECTED)\r\nprintk("%s%s\n", pfx,\r\n"It has been corrected by h/w "\r\n"and requires no further action");\r\nprintk("%s""event severity: %s\n", pfx, cper_severity_str(severity));\r\ndata_len = estatus->data_length;\r\ngdata = (struct acpi_hest_generic_data *)(estatus + 1);\r\nsnprintf(newpfx, sizeof(newpfx), "%s%s"
