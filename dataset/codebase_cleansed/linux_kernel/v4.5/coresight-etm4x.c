static void etm4_os_unlock(void *info)\r\n{\r\nstruct etmv4_drvdata *drvdata = (struct etmv4_drvdata *)info;\r\nwritel_relaxed(0x0, drvdata->base + TRCOSLAR);\r\nisb();\r\n}\r\nstatic bool etm4_arch_supported(u8 arch)\r\n{\r\nswitch (arch) {\r\ncase ETM_ARCH_V4:\r\nbreak;\r\ndefault:\r\nreturn false;\r\n}\r\nreturn true;\r\n}\r\nstatic int etm4_trace_id(struct coresight_device *csdev)\r\n{\r\nstruct etmv4_drvdata *drvdata = dev_get_drvdata(csdev->dev.parent);\r\nunsigned long flags;\r\nint trace_id = -1;\r\nif (!drvdata->enable)\r\nreturn drvdata->trcid;\r\npm_runtime_get_sync(drvdata->dev);\r\nspin_lock_irqsave(&drvdata->spinlock, flags);\r\nCS_UNLOCK(drvdata->base);\r\ntrace_id = readl_relaxed(drvdata->base + TRCTRACEIDR);\r\ntrace_id &= ETM_TRACEID_MASK;\r\nCS_LOCK(drvdata->base);\r\nspin_unlock_irqrestore(&drvdata->spinlock, flags);\r\npm_runtime_put(drvdata->dev);\r\nreturn trace_id;\r\n}\r\nstatic void etm4_enable_hw(void *info)\r\n{\r\nint i;\r\nstruct etmv4_drvdata *drvdata = info;\r\nCS_UNLOCK(drvdata->base);\r\netm4_os_unlock(drvdata);\r\nwritel_relaxed(0, drvdata->base + TRCPRGCTLR);\r\nif (coresight_timeout(drvdata->base, TRCSTATR, TRCSTATR_IDLE_BIT, 1))\r\ndev_err(drvdata->dev,\r\n"timeout observed when probing at offset %#x\n",\r\nTRCSTATR);\r\nwritel_relaxed(drvdata->pe_sel, drvdata->base + TRCPROCSELR);\r\nwritel_relaxed(drvdata->cfg, drvdata->base + TRCCONFIGR);\r\nwritel_relaxed(0x0, drvdata->base + TRCAUXCTLR);\r\nwritel_relaxed(drvdata->eventctrl0, drvdata->base + TRCEVENTCTL0R);\r\nwritel_relaxed(drvdata->eventctrl1, drvdata->base + TRCEVENTCTL1R);\r\nwritel_relaxed(drvdata->stall_ctrl, drvdata->base + TRCSTALLCTLR);\r\nwritel_relaxed(drvdata->ts_ctrl, drvdata->base + TRCTSCTLR);\r\nwritel_relaxed(drvdata->syncfreq, drvdata->base + TRCSYNCPR);\r\nwritel_relaxed(drvdata->ccctlr, drvdata->base + TRCCCCTLR);\r\nwritel_relaxed(drvdata->bb_ctrl, drvdata->base + TRCBBCTLR);\r\nwritel_relaxed(drvdata->trcid, drvdata->base + TRCTRACEIDR);\r\nwritel_relaxed(drvdata->vinst_ctrl, drvdata->base + TRCVICTLR);\r\nwritel_relaxed(drvdata->viiectlr, drvdata->base + TRCVIIECTLR);\r\nwritel_relaxed(drvdata->vissctlr,\r\ndrvdata->base + TRCVISSCTLR);\r\nwritel_relaxed(drvdata->vipcssctlr,\r\ndrvdata->base + TRCVIPCSSCTLR);\r\nfor (i = 0; i < drvdata->nrseqstate - 1; i++)\r\nwritel_relaxed(drvdata->seq_ctrl[i],\r\ndrvdata->base + TRCSEQEVRn(i));\r\nwritel_relaxed(drvdata->seq_rst, drvdata->base + TRCSEQRSTEVR);\r\nwritel_relaxed(drvdata->seq_state, drvdata->base + TRCSEQSTR);\r\nwritel_relaxed(drvdata->ext_inp, drvdata->base + TRCEXTINSELR);\r\nfor (i = 0; i < drvdata->nr_cntr; i++) {\r\nwritel_relaxed(drvdata->cntrldvr[i],\r\ndrvdata->base + TRCCNTRLDVRn(i));\r\nwritel_relaxed(drvdata->cntr_ctrl[i],\r\ndrvdata->base + TRCCNTCTLRn(i));\r\nwritel_relaxed(drvdata->cntr_val[i],\r\ndrvdata->base + TRCCNTVRn(i));\r\n}\r\nfor (i = 2; i < drvdata->nr_resource * 2; i++)\r\nwritel_relaxed(drvdata->res_ctrl[i],\r\ndrvdata->base + TRCRSCTLRn(i));\r\nfor (i = 0; i < drvdata->nr_ss_cmp; i++) {\r\nwritel_relaxed(drvdata->ss_ctrl[i],\r\ndrvdata->base + TRCSSCCRn(i));\r\nwritel_relaxed(drvdata->ss_status[i],\r\ndrvdata->base + TRCSSCSRn(i));\r\nwritel_relaxed(drvdata->ss_pe_cmp[i],\r\ndrvdata->base + TRCSSPCICRn(i));\r\n}\r\nfor (i = 0; i < drvdata->nr_addr_cmp; i++) {\r\nwriteq_relaxed(drvdata->addr_val[i],\r\ndrvdata->base + TRCACVRn(i));\r\nwriteq_relaxed(drvdata->addr_acc[i],\r\ndrvdata->base + TRCACATRn(i));\r\n}\r\nfor (i = 0; i < drvdata->numcidc; i++)\r\nwriteq_relaxed(drvdata->ctxid_pid[i],\r\ndrvdata->base + TRCCIDCVRn(i));\r\nwritel_relaxed(drvdata->ctxid_mask0, drvdata->base + TRCCIDCCTLR0);\r\nwritel_relaxed(drvdata->ctxid_mask1, drvdata->base + TRCCIDCCTLR1);\r\nfor (i = 0; i < drvdata->numvmidc; i++)\r\nwriteq_relaxed(drvdata->vmid_val[i],\r\ndrvdata->base + TRCVMIDCVRn(i));\r\nwritel_relaxed(drvdata->vmid_mask0, drvdata->base + TRCVMIDCCTLR0);\r\nwritel_relaxed(drvdata->vmid_mask1, drvdata->base + TRCVMIDCCTLR1);\r\nwritel_relaxed(1, drvdata->base + TRCPRGCTLR);\r\nif (coresight_timeout(drvdata->base, TRCSTATR, TRCSTATR_IDLE_BIT, 0))\r\ndev_err(drvdata->dev,\r\n"timeout observed when probing at offset %#x\n",\r\nTRCSTATR);\r\nCS_LOCK(drvdata->base);\r\ndev_dbg(drvdata->dev, "cpu: %d enable smp call done\n", drvdata->cpu);\r\n}\r\nstatic int etm4_enable(struct coresight_device *csdev)\r\n{\r\nstruct etmv4_drvdata *drvdata = dev_get_drvdata(csdev->dev.parent);\r\nint ret;\r\npm_runtime_get_sync(drvdata->dev);\r\nspin_lock(&drvdata->spinlock);\r\nret = smp_call_function_single(drvdata->cpu,\r\netm4_enable_hw, drvdata, 1);\r\nif (ret)\r\ngoto err;\r\ndrvdata->enable = true;\r\ndrvdata->sticky_enable = true;\r\nspin_unlock(&drvdata->spinlock);\r\ndev_info(drvdata->dev, "ETM tracing enabled\n");\r\nreturn 0;\r\nerr:\r\nspin_unlock(&drvdata->spinlock);\r\npm_runtime_put(drvdata->dev);\r\nreturn ret;\r\n}\r\nstatic void etm4_disable_hw(void *info)\r\n{\r\nu32 control;\r\nstruct etmv4_drvdata *drvdata = info;\r\nCS_UNLOCK(drvdata->base);\r\ncontrol = readl_relaxed(drvdata->base + TRCPRGCTLR);\r\ncontrol &= ~0x1;\r\nmb();\r\nisb();\r\nwritel_relaxed(control, drvdata->base + TRCPRGCTLR);\r\nCS_LOCK(drvdata->base);\r\ndev_dbg(drvdata->dev, "cpu: %d disable smp call done\n", drvdata->cpu);\r\n}\r\nstatic void etm4_disable(struct coresight_device *csdev)\r\n{\r\nstruct etmv4_drvdata *drvdata = dev_get_drvdata(csdev->dev.parent);\r\nget_online_cpus();\r\nspin_lock(&drvdata->spinlock);\r\nsmp_call_function_single(drvdata->cpu, etm4_disable_hw, drvdata, 1);\r\ndrvdata->enable = false;\r\nspin_unlock(&drvdata->spinlock);\r\nput_online_cpus();\r\npm_runtime_put(drvdata->dev);\r\ndev_info(drvdata->dev, "ETM tracing disabled\n");\r\n}\r\nstatic int etm4_set_mode_exclude(struct etmv4_drvdata *drvdata, bool exclude)\r\n{\r\nu8 idx = drvdata->addr_idx;\r\nif (BMVAL(drvdata->addr_acc[idx], 0, 1) == ETM_INSTR_ADDR) {\r\nif (idx % 2 != 0)\r\nreturn -EINVAL;\r\nif (drvdata->addr_type[idx] != ETM_ADDR_TYPE_RANGE ||\r\ndrvdata->addr_type[idx + 1] != ETM_ADDR_TYPE_RANGE)\r\nreturn -EINVAL;\r\nif (exclude == true) {\r\ndrvdata->viiectlr |= BIT(idx / 2 + 16);\r\ndrvdata->viiectlr &= ~BIT(idx / 2);\r\n} else {\r\ndrvdata->viiectlr |= BIT(idx / 2);\r\ndrvdata->viiectlr &= ~BIT(idx / 2 + 16);\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic ssize_t nr_pe_cmp_show(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nunsigned long val;\r\nstruct etmv4_drvdata *drvdata = dev_get_drvdata(dev->parent);\r\nval = drvdata->nr_pe_cmp;\r\nreturn scnprintf(buf, PAGE_SIZE, "%#lx\n", val);\r\n}\r\nstatic ssize_t nr_addr_cmp_show(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nunsigned long val;\r\nstruct etmv4_drvdata *drvdata = dev_get_drvdata(dev->parent);\r\nval = drvdata->nr_addr_cmp;\r\nreturn scnprintf(buf, PAGE_SIZE, "%#lx\n", val);\r\n}\r\nstatic ssize_t nr_cntr_show(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nunsigned long val;\r\nstruct etmv4_drvdata *drvdata = dev_get_drvdata(dev->parent);\r\nval = drvdata->nr_cntr;\r\nreturn scnprintf(buf, PAGE_SIZE, "%#lx\n", val);\r\n}\r\nstatic ssize_t nr_ext_inp_show(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nunsigned long val;\r\nstruct etmv4_drvdata *drvdata = dev_get_drvdata(dev->parent);\r\nval = drvdata->nr_ext_inp;\r\nreturn scnprintf(buf, PAGE_SIZE, "%#lx\n", val);\r\n}\r\nstatic ssize_t numcidc_show(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nunsigned long val;\r\nstruct etmv4_drvdata *drvdata = dev_get_drvdata(dev->parent);\r\nval = drvdata->numcidc;\r\nreturn scnprintf(buf, PAGE_SIZE, "%#lx\n", val);\r\n}\r\nstatic ssize_t numvmidc_show(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nunsigned long val;\r\nstruct etmv4_drvdata *drvdata = dev_get_drvdata(dev->parent);\r\nval = drvdata->numvmidc;\r\nreturn scnprintf(buf, PAGE_SIZE, "%#lx\n", val);\r\n}\r\nstatic ssize_t nrseqstate_show(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nunsigned long val;\r\nstruct etmv4_drvdata *drvdata = dev_get_drvdata(dev->parent);\r\nval = drvdata->nrseqstate;\r\nreturn scnprintf(buf, PAGE_SIZE, "%#lx\n", val);\r\n}\r\nstatic ssize_t nr_resource_show(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nunsigned long val;\r\nstruct etmv4_drvdata *drvdata = dev_get_drvdata(dev->parent);\r\nval = drvdata->nr_resource;\r\nreturn scnprintf(buf, PAGE_SIZE, "%#lx\n", val);\r\n}\r\nstatic ssize_t nr_ss_cmp_show(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nunsigned long val;\r\nstruct etmv4_drvdata *drvdata = dev_get_drvdata(dev->parent);\r\nval = drvdata->nr_ss_cmp;\r\nreturn scnprintf(buf, PAGE_SIZE, "%#lx\n", val);\r\n}\r\nstatic ssize_t reset_store(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t size)\r\n{\r\nint i;\r\nunsigned long val;\r\nstruct etmv4_drvdata *drvdata = dev_get_drvdata(dev->parent);\r\nif (kstrtoul(buf, 16, &val))\r\nreturn -EINVAL;\r\nspin_lock(&drvdata->spinlock);\r\nif (val)\r\ndrvdata->mode = 0x0;\r\ndrvdata->mode &= ~(ETM_MODE_LOAD | ETM_MODE_STORE);\r\ndrvdata->cfg &= ~(BIT(1) | BIT(2));\r\ndrvdata->mode &= ~(ETM_MODE_DATA_TRACE_ADDR |\r\nETM_MODE_DATA_TRACE_VAL);\r\ndrvdata->cfg &= ~(BIT(16) | BIT(17));\r\ndrvdata->eventctrl0 = 0x0;\r\ndrvdata->eventctrl1 = 0x0;\r\ndrvdata->ts_ctrl = 0x0;\r\ndrvdata->stall_ctrl = 0x0;\r\nif (drvdata->syncpr == false)\r\ndrvdata->syncfreq = 0x8;\r\ndrvdata->vinst_ctrl |= BIT(0);\r\nif (drvdata->nr_addr_cmp == true) {\r\ndrvdata->mode |= ETM_MODE_VIEWINST_STARTSTOP;\r\ndrvdata->vinst_ctrl |= BIT(9);\r\n}\r\ndrvdata->viiectlr = 0x0;\r\ndrvdata->vissctlr = 0x0;\r\nfor (i = 0; i < drvdata->nrseqstate-1; i++)\r\ndrvdata->seq_ctrl[i] = 0x0;\r\ndrvdata->seq_rst = 0x0;\r\ndrvdata->seq_state = 0x0;\r\ndrvdata->ext_inp = 0x0;\r\ndrvdata->cntr_idx = 0x0;\r\nfor (i = 0; i < drvdata->nr_cntr; i++) {\r\ndrvdata->cntrldvr[i] = 0x0;\r\ndrvdata->cntr_ctrl[i] = 0x0;\r\ndrvdata->cntr_val[i] = 0x0;\r\n}\r\ndrvdata->res_idx = 0x2;\r\nfor (i = 2; i < drvdata->nr_resource * 2; i++)\r\ndrvdata->res_ctrl[i] = 0x0;\r\nfor (i = 0; i < drvdata->nr_ss_cmp; i++) {\r\ndrvdata->ss_ctrl[i] = 0x0;\r\ndrvdata->ss_pe_cmp[i] = 0x0;\r\n}\r\ndrvdata->addr_idx = 0x0;\r\nfor (i = 0; i < drvdata->nr_addr_cmp * 2; i++) {\r\ndrvdata->addr_val[i] = 0x0;\r\ndrvdata->addr_acc[i] = 0x0;\r\ndrvdata->addr_type[i] = ETM_ADDR_TYPE_NONE;\r\n}\r\ndrvdata->ctxid_idx = 0x0;\r\nfor (i = 0; i < drvdata->numcidc; i++) {\r\ndrvdata->ctxid_pid[i] = 0x0;\r\ndrvdata->ctxid_vpid[i] = 0x0;\r\n}\r\ndrvdata->ctxid_mask0 = 0x0;\r\ndrvdata->ctxid_mask1 = 0x0;\r\ndrvdata->vmid_idx = 0x0;\r\nfor (i = 0; i < drvdata->numvmidc; i++)\r\ndrvdata->vmid_val[i] = 0x0;\r\ndrvdata->vmid_mask0 = 0x0;\r\ndrvdata->vmid_mask1 = 0x0;\r\ndrvdata->trcid = drvdata->cpu + 1;\r\nspin_unlock(&drvdata->spinlock);\r\nreturn size;\r\n}\r\nstatic ssize_t mode_show(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nunsigned long val;\r\nstruct etmv4_drvdata *drvdata = dev_get_drvdata(dev->parent);\r\nval = drvdata->mode;\r\nreturn scnprintf(buf, PAGE_SIZE, "%#lx\n", val);\r\n}\r\nstatic ssize_t mode_store(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t size)\r\n{\r\nunsigned long val, mode;\r\nstruct etmv4_drvdata *drvdata = dev_get_drvdata(dev->parent);\r\nif (kstrtoul(buf, 16, &val))\r\nreturn -EINVAL;\r\nspin_lock(&drvdata->spinlock);\r\ndrvdata->mode = val & ETMv4_MODE_ALL;\r\nif (drvdata->mode & ETM_MODE_EXCLUDE)\r\netm4_set_mode_exclude(drvdata, true);\r\nelse\r\netm4_set_mode_exclude(drvdata, false);\r\nif (drvdata->instrp0 == true) {\r\ndrvdata->cfg &= ~(BIT(1) | BIT(2));\r\nif (drvdata->mode & ETM_MODE_LOAD)\r\ndrvdata->cfg |= BIT(1);\r\nif (drvdata->mode & ETM_MODE_STORE)\r\ndrvdata->cfg |= BIT(2);\r\nif (drvdata->mode & ETM_MODE_LOAD_STORE)\r\ndrvdata->cfg |= BIT(1) | BIT(2);\r\n}\r\nif ((drvdata->mode & ETM_MODE_BB) && (drvdata->trcbb == true))\r\ndrvdata->cfg |= BIT(3);\r\nelse\r\ndrvdata->cfg &= ~BIT(3);\r\nif ((drvdata->mode & ETMv4_MODE_CYCACC) &&\r\n(drvdata->trccci == true))\r\ndrvdata->cfg |= BIT(4);\r\nelse\r\ndrvdata->cfg &= ~BIT(4);\r\nif ((drvdata->mode & ETMv4_MODE_CTXID) && (drvdata->ctxid_size))\r\ndrvdata->cfg |= BIT(6);\r\nelse\r\ndrvdata->cfg &= ~BIT(6);\r\nif ((drvdata->mode & ETM_MODE_VMID) && (drvdata->vmid_size))\r\ndrvdata->cfg |= BIT(7);\r\nelse\r\ndrvdata->cfg &= ~BIT(7);\r\nmode = ETM_MODE_COND(drvdata->mode);\r\nif (drvdata->trccond == true) {\r\ndrvdata->cfg &= ~(BIT(8) | BIT(9) | BIT(10));\r\ndrvdata->cfg |= mode << 8;\r\n}\r\nif ((drvdata->mode & ETMv4_MODE_TIMESTAMP) && (drvdata->ts_size))\r\ndrvdata->cfg |= BIT(11);\r\nelse\r\ndrvdata->cfg &= ~BIT(11);\r\nif ((drvdata->mode & ETM_MODE_RETURNSTACK) &&\r\n(drvdata->retstack == true))\r\ndrvdata->cfg |= BIT(12);\r\nelse\r\ndrvdata->cfg &= ~BIT(12);\r\nmode = ETM_MODE_QELEM(drvdata->mode);\r\ndrvdata->cfg &= ~(BIT(13) | BIT(14));\r\nif ((mode & BIT(0)) && (drvdata->q_support & BIT(0)))\r\ndrvdata->cfg |= BIT(13);\r\nif ((mode & BIT(1)) && (drvdata->q_support & BIT(1)))\r\ndrvdata->cfg |= BIT(14);\r\nif ((drvdata->mode & ETM_MODE_ATB_TRIGGER) &&\r\n(drvdata->atbtrig == true))\r\ndrvdata->eventctrl1 |= BIT(11);\r\nelse\r\ndrvdata->eventctrl1 &= ~BIT(11);\r\nif ((drvdata->mode & ETM_MODE_LPOVERRIDE) &&\r\n(drvdata->lpoverride == true))\r\ndrvdata->eventctrl1 |= BIT(12);\r\nelse\r\ndrvdata->eventctrl1 &= ~BIT(12);\r\nif (drvdata->mode & ETM_MODE_ISTALL_EN)\r\ndrvdata->stall_ctrl |= BIT(8);\r\nelse\r\ndrvdata->stall_ctrl &= ~BIT(8);\r\nif (drvdata->mode & ETM_MODE_INSTPRIO)\r\ndrvdata->stall_ctrl |= BIT(10);\r\nelse\r\ndrvdata->stall_ctrl &= ~BIT(10);\r\nif ((drvdata->mode & ETM_MODE_NOOVERFLOW) &&\r\n(drvdata->nooverflow == true))\r\ndrvdata->stall_ctrl |= BIT(13);\r\nelse\r\ndrvdata->stall_ctrl &= ~BIT(13);\r\nif (drvdata->mode & ETM_MODE_VIEWINST_STARTSTOP)\r\ndrvdata->vinst_ctrl |= BIT(9);\r\nelse\r\ndrvdata->vinst_ctrl &= ~BIT(9);\r\nif (drvdata->mode & ETM_MODE_TRACE_RESET)\r\ndrvdata->vinst_ctrl |= BIT(10);\r\nelse\r\ndrvdata->vinst_ctrl &= ~BIT(10);\r\nif ((drvdata->mode & ETM_MODE_TRACE_ERR) &&\r\n(drvdata->trc_error == true))\r\ndrvdata->vinst_ctrl |= BIT(11);\r\nelse\r\ndrvdata->vinst_ctrl &= ~BIT(11);\r\nspin_unlock(&drvdata->spinlock);\r\nreturn size;\r\n}\r\nstatic ssize_t pe_show(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nunsigned long val;\r\nstruct etmv4_drvdata *drvdata = dev_get_drvdata(dev->parent);\r\nval = drvdata->pe_sel;\r\nreturn scnprintf(buf, PAGE_SIZE, "%#lx\n", val);\r\n}\r\nstatic ssize_t pe_store(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t size)\r\n{\r\nunsigned long val;\r\nstruct etmv4_drvdata *drvdata = dev_get_drvdata(dev->parent);\r\nif (kstrtoul(buf, 16, &val))\r\nreturn -EINVAL;\r\nspin_lock(&drvdata->spinlock);\r\nif (val > drvdata->nr_pe) {\r\nspin_unlock(&drvdata->spinlock);\r\nreturn -EINVAL;\r\n}\r\ndrvdata->pe_sel = val;\r\nspin_unlock(&drvdata->spinlock);\r\nreturn size;\r\n}\r\nstatic ssize_t event_show(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nunsigned long val;\r\nstruct etmv4_drvdata *drvdata = dev_get_drvdata(dev->parent);\r\nval = drvdata->eventctrl0;\r\nreturn scnprintf(buf, PAGE_SIZE, "%#lx\n", val);\r\n}\r\nstatic ssize_t event_store(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t size)\r\n{\r\nunsigned long val;\r\nstruct etmv4_drvdata *drvdata = dev_get_drvdata(dev->parent);\r\nif (kstrtoul(buf, 16, &val))\r\nreturn -EINVAL;\r\nspin_lock(&drvdata->spinlock);\r\nswitch (drvdata->nr_event) {\r\ncase 0x0:\r\ndrvdata->eventctrl0 = val & 0xFF;\r\nbreak;\r\ncase 0x1:\r\ndrvdata->eventctrl0 = val & 0xFFFF;\r\nbreak;\r\ncase 0x2:\r\ndrvdata->eventctrl0 = val & 0xFFFFFF;\r\nbreak;\r\ncase 0x3:\r\ndrvdata->eventctrl0 = val;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nspin_unlock(&drvdata->spinlock);\r\nreturn size;\r\n}\r\nstatic ssize_t event_instren_show(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nunsigned long val;\r\nstruct etmv4_drvdata *drvdata = dev_get_drvdata(dev->parent);\r\nval = BMVAL(drvdata->eventctrl1, 0, 3);\r\nreturn scnprintf(buf, PAGE_SIZE, "%#lx\n", val);\r\n}\r\nstatic ssize_t event_instren_store(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t size)\r\n{\r\nunsigned long val;\r\nstruct etmv4_drvdata *drvdata = dev_get_drvdata(dev->parent);\r\nif (kstrtoul(buf, 16, &val))\r\nreturn -EINVAL;\r\nspin_lock(&drvdata->spinlock);\r\ndrvdata->eventctrl1 &= ~(BIT(0) | BIT(1) | BIT(2) | BIT(3));\r\nswitch (drvdata->nr_event) {\r\ncase 0x0:\r\ndrvdata->eventctrl1 |= val & BIT(1);\r\nbreak;\r\ncase 0x1:\r\ndrvdata->eventctrl1 |= val & (BIT(0) | BIT(1));\r\nbreak;\r\ncase 0x2:\r\ndrvdata->eventctrl1 |= val & (BIT(0) | BIT(1) | BIT(2));\r\nbreak;\r\ncase 0x3:\r\ndrvdata->eventctrl1 |= val & 0xF;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nspin_unlock(&drvdata->spinlock);\r\nreturn size;\r\n}\r\nstatic ssize_t event_ts_show(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nunsigned long val;\r\nstruct etmv4_drvdata *drvdata = dev_get_drvdata(dev->parent);\r\nval = drvdata->ts_ctrl;\r\nreturn scnprintf(buf, PAGE_SIZE, "%#lx\n", val);\r\n}\r\nstatic ssize_t event_ts_store(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t size)\r\n{\r\nunsigned long val;\r\nstruct etmv4_drvdata *drvdata = dev_get_drvdata(dev->parent);\r\nif (kstrtoul(buf, 16, &val))\r\nreturn -EINVAL;\r\nif (!drvdata->ts_size)\r\nreturn -EINVAL;\r\ndrvdata->ts_ctrl = val & ETMv4_EVENT_MASK;\r\nreturn size;\r\n}\r\nstatic ssize_t syncfreq_show(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nunsigned long val;\r\nstruct etmv4_drvdata *drvdata = dev_get_drvdata(dev->parent);\r\nval = drvdata->syncfreq;\r\nreturn scnprintf(buf, PAGE_SIZE, "%#lx\n", val);\r\n}\r\nstatic ssize_t syncfreq_store(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t size)\r\n{\r\nunsigned long val;\r\nstruct etmv4_drvdata *drvdata = dev_get_drvdata(dev->parent);\r\nif (kstrtoul(buf, 16, &val))\r\nreturn -EINVAL;\r\nif (drvdata->syncpr == true)\r\nreturn -EINVAL;\r\ndrvdata->syncfreq = val & ETMv4_SYNC_MASK;\r\nreturn size;\r\n}\r\nstatic ssize_t cyc_threshold_show(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nunsigned long val;\r\nstruct etmv4_drvdata *drvdata = dev_get_drvdata(dev->parent);\r\nval = drvdata->ccctlr;\r\nreturn scnprintf(buf, PAGE_SIZE, "%#lx\n", val);\r\n}\r\nstatic ssize_t cyc_threshold_store(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t size)\r\n{\r\nunsigned long val;\r\nstruct etmv4_drvdata *drvdata = dev_get_drvdata(dev->parent);\r\nif (kstrtoul(buf, 16, &val))\r\nreturn -EINVAL;\r\nif (val < drvdata->ccitmin)\r\nreturn -EINVAL;\r\ndrvdata->ccctlr = val & ETM_CYC_THRESHOLD_MASK;\r\nreturn size;\r\n}\r\nstatic ssize_t bb_ctrl_show(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nunsigned long val;\r\nstruct etmv4_drvdata *drvdata = dev_get_drvdata(dev->parent);\r\nval = drvdata->bb_ctrl;\r\nreturn scnprintf(buf, PAGE_SIZE, "%#lx\n", val);\r\n}\r\nstatic ssize_t bb_ctrl_store(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t size)\r\n{\r\nunsigned long val;\r\nstruct etmv4_drvdata *drvdata = dev_get_drvdata(dev->parent);\r\nif (kstrtoul(buf, 16, &val))\r\nreturn -EINVAL;\r\nif (drvdata->trcbb == false)\r\nreturn -EINVAL;\r\nif (!drvdata->nr_addr_cmp)\r\nreturn -EINVAL;\r\nif (BMVAL(val, 0, 7) > drvdata->nr_addr_cmp)\r\nreturn -EINVAL;\r\ndrvdata->bb_ctrl = val;\r\nreturn size;\r\n}\r\nstatic ssize_t event_vinst_show(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nunsigned long val;\r\nstruct etmv4_drvdata *drvdata = dev_get_drvdata(dev->parent);\r\nval = drvdata->vinst_ctrl & ETMv4_EVENT_MASK;\r\nreturn scnprintf(buf, PAGE_SIZE, "%#lx\n", val);\r\n}\r\nstatic ssize_t event_vinst_store(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t size)\r\n{\r\nunsigned long val;\r\nstruct etmv4_drvdata *drvdata = dev_get_drvdata(dev->parent);\r\nif (kstrtoul(buf, 16, &val))\r\nreturn -EINVAL;\r\nspin_lock(&drvdata->spinlock);\r\nval &= ETMv4_EVENT_MASK;\r\ndrvdata->vinst_ctrl &= ~ETMv4_EVENT_MASK;\r\ndrvdata->vinst_ctrl |= val;\r\nspin_unlock(&drvdata->spinlock);\r\nreturn size;\r\n}\r\nstatic ssize_t s_exlevel_vinst_show(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nunsigned long val;\r\nstruct etmv4_drvdata *drvdata = dev_get_drvdata(dev->parent);\r\nval = BMVAL(drvdata->vinst_ctrl, 16, 19);\r\nreturn scnprintf(buf, PAGE_SIZE, "%#lx\n", val);\r\n}\r\nstatic ssize_t s_exlevel_vinst_store(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t size)\r\n{\r\nunsigned long val;\r\nstruct etmv4_drvdata *drvdata = dev_get_drvdata(dev->parent);\r\nif (kstrtoul(buf, 16, &val))\r\nreturn -EINVAL;\r\nspin_lock(&drvdata->spinlock);\r\ndrvdata->vinst_ctrl &= ~(BIT(16) | BIT(17) | BIT(19));\r\nval &= drvdata->s_ex_level;\r\ndrvdata->vinst_ctrl |= (val << 16);\r\nspin_unlock(&drvdata->spinlock);\r\nreturn size;\r\n}\r\nstatic ssize_t ns_exlevel_vinst_show(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nunsigned long val;\r\nstruct etmv4_drvdata *drvdata = dev_get_drvdata(dev->parent);\r\nval = BMVAL(drvdata->vinst_ctrl, 20, 23);\r\nreturn scnprintf(buf, PAGE_SIZE, "%#lx\n", val);\r\n}\r\nstatic ssize_t ns_exlevel_vinst_store(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t size)\r\n{\r\nunsigned long val;\r\nstruct etmv4_drvdata *drvdata = dev_get_drvdata(dev->parent);\r\nif (kstrtoul(buf, 16, &val))\r\nreturn -EINVAL;\r\nspin_lock(&drvdata->spinlock);\r\ndrvdata->vinst_ctrl &= ~(BIT(20) | BIT(21) | BIT(22));\r\nval &= drvdata->ns_ex_level;\r\ndrvdata->vinst_ctrl |= (val << 20);\r\nspin_unlock(&drvdata->spinlock);\r\nreturn size;\r\n}\r\nstatic ssize_t addr_idx_show(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nunsigned long val;\r\nstruct etmv4_drvdata *drvdata = dev_get_drvdata(dev->parent);\r\nval = drvdata->addr_idx;\r\nreturn scnprintf(buf, PAGE_SIZE, "%#lx\n", val);\r\n}\r\nstatic ssize_t addr_idx_store(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t size)\r\n{\r\nunsigned long val;\r\nstruct etmv4_drvdata *drvdata = dev_get_drvdata(dev->parent);\r\nif (kstrtoul(buf, 16, &val))\r\nreturn -EINVAL;\r\nif (val >= drvdata->nr_addr_cmp * 2)\r\nreturn -EINVAL;\r\nspin_lock(&drvdata->spinlock);\r\ndrvdata->addr_idx = val;\r\nspin_unlock(&drvdata->spinlock);\r\nreturn size;\r\n}\r\nstatic ssize_t addr_instdatatype_show(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nssize_t len;\r\nu8 val, idx;\r\nstruct etmv4_drvdata *drvdata = dev_get_drvdata(dev->parent);\r\nspin_lock(&drvdata->spinlock);\r\nidx = drvdata->addr_idx;\r\nval = BMVAL(drvdata->addr_acc[idx], 0, 1);\r\nlen = scnprintf(buf, PAGE_SIZE, "%s\n",\r\nval == ETM_INSTR_ADDR ? "instr" :\r\n(val == ETM_DATA_LOAD_ADDR ? "data_load" :\r\n(val == ETM_DATA_STORE_ADDR ? "data_store" :\r\n"data_load_store")));\r\nspin_unlock(&drvdata->spinlock);\r\nreturn len;\r\n}\r\nstatic ssize_t addr_instdatatype_store(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t size)\r\n{\r\nu8 idx;\r\nchar str[20] = "";\r\nstruct etmv4_drvdata *drvdata = dev_get_drvdata(dev->parent);\r\nif (strlen(buf) >= 20)\r\nreturn -EINVAL;\r\nif (sscanf(buf, "%s", str) != 1)\r\nreturn -EINVAL;\r\nspin_lock(&drvdata->spinlock);\r\nidx = drvdata->addr_idx;\r\nif (!strcmp(str, "instr"))\r\ndrvdata->addr_acc[idx] &= ~(BIT(0) | BIT(1));\r\nspin_unlock(&drvdata->spinlock);\r\nreturn size;\r\n}\r\nstatic ssize_t addr_single_show(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nu8 idx;\r\nunsigned long val;\r\nstruct etmv4_drvdata *drvdata = dev_get_drvdata(dev->parent);\r\nidx = drvdata->addr_idx;\r\nspin_lock(&drvdata->spinlock);\r\nif (!(drvdata->addr_type[idx] == ETM_ADDR_TYPE_NONE ||\r\ndrvdata->addr_type[idx] == ETM_ADDR_TYPE_SINGLE)) {\r\nspin_unlock(&drvdata->spinlock);\r\nreturn -EPERM;\r\n}\r\nval = (unsigned long)drvdata->addr_val[idx];\r\nspin_unlock(&drvdata->spinlock);\r\nreturn scnprintf(buf, PAGE_SIZE, "%#lx\n", val);\r\n}\r\nstatic ssize_t addr_single_store(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t size)\r\n{\r\nu8 idx;\r\nunsigned long val;\r\nstruct etmv4_drvdata *drvdata = dev_get_drvdata(dev->parent);\r\nif (kstrtoul(buf, 16, &val))\r\nreturn -EINVAL;\r\nspin_lock(&drvdata->spinlock);\r\nidx = drvdata->addr_idx;\r\nif (!(drvdata->addr_type[idx] == ETM_ADDR_TYPE_NONE ||\r\ndrvdata->addr_type[idx] == ETM_ADDR_TYPE_SINGLE)) {\r\nspin_unlock(&drvdata->spinlock);\r\nreturn -EPERM;\r\n}\r\ndrvdata->addr_val[idx] = (u64)val;\r\ndrvdata->addr_type[idx] = ETM_ADDR_TYPE_SINGLE;\r\nspin_unlock(&drvdata->spinlock);\r\nreturn size;\r\n}\r\nstatic ssize_t addr_range_show(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nu8 idx;\r\nunsigned long val1, val2;\r\nstruct etmv4_drvdata *drvdata = dev_get_drvdata(dev->parent);\r\nspin_lock(&drvdata->spinlock);\r\nidx = drvdata->addr_idx;\r\nif (idx % 2 != 0) {\r\nspin_unlock(&drvdata->spinlock);\r\nreturn -EPERM;\r\n}\r\nif (!((drvdata->addr_type[idx] == ETM_ADDR_TYPE_NONE &&\r\ndrvdata->addr_type[idx + 1] == ETM_ADDR_TYPE_NONE) ||\r\n(drvdata->addr_type[idx] == ETM_ADDR_TYPE_RANGE &&\r\ndrvdata->addr_type[idx + 1] == ETM_ADDR_TYPE_RANGE))) {\r\nspin_unlock(&drvdata->spinlock);\r\nreturn -EPERM;\r\n}\r\nval1 = (unsigned long)drvdata->addr_val[idx];\r\nval2 = (unsigned long)drvdata->addr_val[idx + 1];\r\nspin_unlock(&drvdata->spinlock);\r\nreturn scnprintf(buf, PAGE_SIZE, "%#lx %#lx\n", val1, val2);\r\n}\r\nstatic ssize_t addr_range_store(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t size)\r\n{\r\nu8 idx;\r\nunsigned long val1, val2;\r\nstruct etmv4_drvdata *drvdata = dev_get_drvdata(dev->parent);\r\nif (sscanf(buf, "%lx %lx", &val1, &val2) != 2)\r\nreturn -EINVAL;\r\nif (val1 > val2)\r\nreturn -EINVAL;\r\nspin_lock(&drvdata->spinlock);\r\nidx = drvdata->addr_idx;\r\nif (idx % 2 != 0) {\r\nspin_unlock(&drvdata->spinlock);\r\nreturn -EPERM;\r\n}\r\nif (!((drvdata->addr_type[idx] == ETM_ADDR_TYPE_NONE &&\r\ndrvdata->addr_type[idx + 1] == ETM_ADDR_TYPE_NONE) ||\r\n(drvdata->addr_type[idx] == ETM_ADDR_TYPE_RANGE &&\r\ndrvdata->addr_type[idx + 1] == ETM_ADDR_TYPE_RANGE))) {\r\nspin_unlock(&drvdata->spinlock);\r\nreturn -EPERM;\r\n}\r\ndrvdata->addr_val[idx] = (u64)val1;\r\ndrvdata->addr_type[idx] = ETM_ADDR_TYPE_RANGE;\r\ndrvdata->addr_val[idx + 1] = (u64)val2;\r\ndrvdata->addr_type[idx + 1] = ETM_ADDR_TYPE_RANGE;\r\nif (drvdata->mode & ETM_MODE_EXCLUDE)\r\netm4_set_mode_exclude(drvdata, true);\r\nelse\r\netm4_set_mode_exclude(drvdata, false);\r\nspin_unlock(&drvdata->spinlock);\r\nreturn size;\r\n}\r\nstatic ssize_t addr_start_show(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nu8 idx;\r\nunsigned long val;\r\nstruct etmv4_drvdata *drvdata = dev_get_drvdata(dev->parent);\r\nspin_lock(&drvdata->spinlock);\r\nidx = drvdata->addr_idx;\r\nif (!(drvdata->addr_type[idx] == ETM_ADDR_TYPE_NONE ||\r\ndrvdata->addr_type[idx] == ETM_ADDR_TYPE_START)) {\r\nspin_unlock(&drvdata->spinlock);\r\nreturn -EPERM;\r\n}\r\nval = (unsigned long)drvdata->addr_val[idx];\r\nspin_unlock(&drvdata->spinlock);\r\nreturn scnprintf(buf, PAGE_SIZE, "%#lx\n", val);\r\n}\r\nstatic ssize_t addr_start_store(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t size)\r\n{\r\nu8 idx;\r\nunsigned long val;\r\nstruct etmv4_drvdata *drvdata = dev_get_drvdata(dev->parent);\r\nif (kstrtoul(buf, 16, &val))\r\nreturn -EINVAL;\r\nspin_lock(&drvdata->spinlock);\r\nidx = drvdata->addr_idx;\r\nif (!drvdata->nr_addr_cmp) {\r\nspin_unlock(&drvdata->spinlock);\r\nreturn -EINVAL;\r\n}\r\nif (!(drvdata->addr_type[idx] == ETM_ADDR_TYPE_NONE ||\r\ndrvdata->addr_type[idx] == ETM_ADDR_TYPE_START)) {\r\nspin_unlock(&drvdata->spinlock);\r\nreturn -EPERM;\r\n}\r\ndrvdata->addr_val[idx] = (u64)val;\r\ndrvdata->addr_type[idx] = ETM_ADDR_TYPE_START;\r\ndrvdata->vissctlr |= BIT(idx);\r\ndrvdata->vinst_ctrl |= BIT(9);\r\nspin_unlock(&drvdata->spinlock);\r\nreturn size;\r\n}\r\nstatic ssize_t addr_stop_show(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nu8 idx;\r\nunsigned long val;\r\nstruct etmv4_drvdata *drvdata = dev_get_drvdata(dev->parent);\r\nspin_lock(&drvdata->spinlock);\r\nidx = drvdata->addr_idx;\r\nif (!(drvdata->addr_type[idx] == ETM_ADDR_TYPE_NONE ||\r\ndrvdata->addr_type[idx] == ETM_ADDR_TYPE_STOP)) {\r\nspin_unlock(&drvdata->spinlock);\r\nreturn -EPERM;\r\n}\r\nval = (unsigned long)drvdata->addr_val[idx];\r\nspin_unlock(&drvdata->spinlock);\r\nreturn scnprintf(buf, PAGE_SIZE, "%#lx\n", val);\r\n}\r\nstatic ssize_t addr_stop_store(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t size)\r\n{\r\nu8 idx;\r\nunsigned long val;\r\nstruct etmv4_drvdata *drvdata = dev_get_drvdata(dev->parent);\r\nif (kstrtoul(buf, 16, &val))\r\nreturn -EINVAL;\r\nspin_lock(&drvdata->spinlock);\r\nidx = drvdata->addr_idx;\r\nif (!drvdata->nr_addr_cmp) {\r\nspin_unlock(&drvdata->spinlock);\r\nreturn -EINVAL;\r\n}\r\nif (!(drvdata->addr_type[idx] == ETM_ADDR_TYPE_NONE ||\r\ndrvdata->addr_type[idx] == ETM_ADDR_TYPE_STOP)) {\r\nspin_unlock(&drvdata->spinlock);\r\nreturn -EPERM;\r\n}\r\ndrvdata->addr_val[idx] = (u64)val;\r\ndrvdata->addr_type[idx] = ETM_ADDR_TYPE_STOP;\r\ndrvdata->vissctlr |= BIT(idx + 16);\r\ndrvdata->vinst_ctrl |= BIT(9);\r\nspin_unlock(&drvdata->spinlock);\r\nreturn size;\r\n}\r\nstatic ssize_t addr_ctxtype_show(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nssize_t len;\r\nu8 idx, val;\r\nstruct etmv4_drvdata *drvdata = dev_get_drvdata(dev->parent);\r\nspin_lock(&drvdata->spinlock);\r\nidx = drvdata->addr_idx;\r\nval = BMVAL(drvdata->addr_acc[idx], 2, 3);\r\nlen = scnprintf(buf, PAGE_SIZE, "%s\n", val == ETM_CTX_NONE ? "none" :\r\n(val == ETM_CTX_CTXID ? "ctxid" :\r\n(val == ETM_CTX_VMID ? "vmid" : "all")));\r\nspin_unlock(&drvdata->spinlock);\r\nreturn len;\r\n}\r\nstatic ssize_t addr_ctxtype_store(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t size)\r\n{\r\nu8 idx;\r\nchar str[10] = "";\r\nstruct etmv4_drvdata *drvdata = dev_get_drvdata(dev->parent);\r\nif (strlen(buf) >= 10)\r\nreturn -EINVAL;\r\nif (sscanf(buf, "%s", str) != 1)\r\nreturn -EINVAL;\r\nspin_lock(&drvdata->spinlock);\r\nidx = drvdata->addr_idx;\r\nif (!strcmp(str, "none"))\r\ndrvdata->addr_acc[idx] &= ~(BIT(2) | BIT(3));\r\nelse if (!strcmp(str, "ctxid")) {\r\nif (drvdata->numcidc) {\r\ndrvdata->addr_acc[idx] |= BIT(2);\r\ndrvdata->addr_acc[idx] &= ~BIT(3);\r\n}\r\n} else if (!strcmp(str, "vmid")) {\r\nif (drvdata->numvmidc) {\r\ndrvdata->addr_acc[idx] &= ~BIT(2);\r\ndrvdata->addr_acc[idx] |= BIT(3);\r\n}\r\n} else if (!strcmp(str, "all")) {\r\nif (drvdata->numcidc)\r\ndrvdata->addr_acc[idx] |= BIT(2);\r\nif (drvdata->numvmidc)\r\ndrvdata->addr_acc[idx] |= BIT(3);\r\n}\r\nspin_unlock(&drvdata->spinlock);\r\nreturn size;\r\n}\r\nstatic ssize_t addr_context_show(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nu8 idx;\r\nunsigned long val;\r\nstruct etmv4_drvdata *drvdata = dev_get_drvdata(dev->parent);\r\nspin_lock(&drvdata->spinlock);\r\nidx = drvdata->addr_idx;\r\nval = BMVAL(drvdata->addr_acc[idx], 4, 6);\r\nspin_unlock(&drvdata->spinlock);\r\nreturn scnprintf(buf, PAGE_SIZE, "%#lx\n", val);\r\n}\r\nstatic ssize_t addr_context_store(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t size)\r\n{\r\nu8 idx;\r\nunsigned long val;\r\nstruct etmv4_drvdata *drvdata = dev_get_drvdata(dev->parent);\r\nif (kstrtoul(buf, 16, &val))\r\nreturn -EINVAL;\r\nif ((drvdata->numcidc <= 1) && (drvdata->numvmidc <= 1))\r\nreturn -EINVAL;\r\nif (val >= (drvdata->numcidc >= drvdata->numvmidc ?\r\ndrvdata->numcidc : drvdata->numvmidc))\r\nreturn -EINVAL;\r\nspin_lock(&drvdata->spinlock);\r\nidx = drvdata->addr_idx;\r\ndrvdata->addr_acc[idx] &= ~(BIT(4) | BIT(5) | BIT(6));\r\ndrvdata->addr_acc[idx] |= (val << 4);\r\nspin_unlock(&drvdata->spinlock);\r\nreturn size;\r\n}\r\nstatic ssize_t seq_idx_show(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nunsigned long val;\r\nstruct etmv4_drvdata *drvdata = dev_get_drvdata(dev->parent);\r\nval = drvdata->seq_idx;\r\nreturn scnprintf(buf, PAGE_SIZE, "%#lx\n", val);\r\n}\r\nstatic ssize_t seq_idx_store(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t size)\r\n{\r\nunsigned long val;\r\nstruct etmv4_drvdata *drvdata = dev_get_drvdata(dev->parent);\r\nif (kstrtoul(buf, 16, &val))\r\nreturn -EINVAL;\r\nif (val >= drvdata->nrseqstate - 1)\r\nreturn -EINVAL;\r\nspin_lock(&drvdata->spinlock);\r\ndrvdata->seq_idx = val;\r\nspin_unlock(&drvdata->spinlock);\r\nreturn size;\r\n}\r\nstatic ssize_t seq_state_show(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nunsigned long val;\r\nstruct etmv4_drvdata *drvdata = dev_get_drvdata(dev->parent);\r\nval = drvdata->seq_state;\r\nreturn scnprintf(buf, PAGE_SIZE, "%#lx\n", val);\r\n}\r\nstatic ssize_t seq_state_store(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t size)\r\n{\r\nunsigned long val;\r\nstruct etmv4_drvdata *drvdata = dev_get_drvdata(dev->parent);\r\nif (kstrtoul(buf, 16, &val))\r\nreturn -EINVAL;\r\nif (val >= drvdata->nrseqstate)\r\nreturn -EINVAL;\r\ndrvdata->seq_state = val;\r\nreturn size;\r\n}\r\nstatic ssize_t seq_event_show(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nu8 idx;\r\nunsigned long val;\r\nstruct etmv4_drvdata *drvdata = dev_get_drvdata(dev->parent);\r\nspin_lock(&drvdata->spinlock);\r\nidx = drvdata->seq_idx;\r\nval = drvdata->seq_ctrl[idx];\r\nspin_unlock(&drvdata->spinlock);\r\nreturn scnprintf(buf, PAGE_SIZE, "%#lx\n", val);\r\n}\r\nstatic ssize_t seq_event_store(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t size)\r\n{\r\nu8 idx;\r\nunsigned long val;\r\nstruct etmv4_drvdata *drvdata = dev_get_drvdata(dev->parent);\r\nif (kstrtoul(buf, 16, &val))\r\nreturn -EINVAL;\r\nspin_lock(&drvdata->spinlock);\r\nidx = drvdata->seq_idx;\r\ndrvdata->seq_ctrl[idx] = val & 0xFF;\r\nspin_unlock(&drvdata->spinlock);\r\nreturn size;\r\n}\r\nstatic ssize_t seq_reset_event_show(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nunsigned long val;\r\nstruct etmv4_drvdata *drvdata = dev_get_drvdata(dev->parent);\r\nval = drvdata->seq_rst;\r\nreturn scnprintf(buf, PAGE_SIZE, "%#lx\n", val);\r\n}\r\nstatic ssize_t seq_reset_event_store(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t size)\r\n{\r\nunsigned long val;\r\nstruct etmv4_drvdata *drvdata = dev_get_drvdata(dev->parent);\r\nif (kstrtoul(buf, 16, &val))\r\nreturn -EINVAL;\r\nif (!(drvdata->nrseqstate))\r\nreturn -EINVAL;\r\ndrvdata->seq_rst = val & ETMv4_EVENT_MASK;\r\nreturn size;\r\n}\r\nstatic ssize_t cntr_idx_show(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nunsigned long val;\r\nstruct etmv4_drvdata *drvdata = dev_get_drvdata(dev->parent);\r\nval = drvdata->cntr_idx;\r\nreturn scnprintf(buf, PAGE_SIZE, "%#lx\n", val);\r\n}\r\nstatic ssize_t cntr_idx_store(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t size)\r\n{\r\nunsigned long val;\r\nstruct etmv4_drvdata *drvdata = dev_get_drvdata(dev->parent);\r\nif (kstrtoul(buf, 16, &val))\r\nreturn -EINVAL;\r\nif (val >= drvdata->nr_cntr)\r\nreturn -EINVAL;\r\nspin_lock(&drvdata->spinlock);\r\ndrvdata->cntr_idx = val;\r\nspin_unlock(&drvdata->spinlock);\r\nreturn size;\r\n}\r\nstatic ssize_t cntrldvr_show(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nu8 idx;\r\nunsigned long val;\r\nstruct etmv4_drvdata *drvdata = dev_get_drvdata(dev->parent);\r\nspin_lock(&drvdata->spinlock);\r\nidx = drvdata->cntr_idx;\r\nval = drvdata->cntrldvr[idx];\r\nspin_unlock(&drvdata->spinlock);\r\nreturn scnprintf(buf, PAGE_SIZE, "%#lx\n", val);\r\n}\r\nstatic ssize_t cntrldvr_store(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t size)\r\n{\r\nu8 idx;\r\nunsigned long val;\r\nstruct etmv4_drvdata *drvdata = dev_get_drvdata(dev->parent);\r\nif (kstrtoul(buf, 16, &val))\r\nreturn -EINVAL;\r\nif (val > ETM_CNTR_MAX_VAL)\r\nreturn -EINVAL;\r\nspin_lock(&drvdata->spinlock);\r\nidx = drvdata->cntr_idx;\r\ndrvdata->cntrldvr[idx] = val;\r\nspin_unlock(&drvdata->spinlock);\r\nreturn size;\r\n}\r\nstatic ssize_t cntr_val_show(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nu8 idx;\r\nunsigned long val;\r\nstruct etmv4_drvdata *drvdata = dev_get_drvdata(dev->parent);\r\nspin_lock(&drvdata->spinlock);\r\nidx = drvdata->cntr_idx;\r\nval = drvdata->cntr_val[idx];\r\nspin_unlock(&drvdata->spinlock);\r\nreturn scnprintf(buf, PAGE_SIZE, "%#lx\n", val);\r\n}\r\nstatic ssize_t cntr_val_store(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t size)\r\n{\r\nu8 idx;\r\nunsigned long val;\r\nstruct etmv4_drvdata *drvdata = dev_get_drvdata(dev->parent);\r\nif (kstrtoul(buf, 16, &val))\r\nreturn -EINVAL;\r\nif (val > ETM_CNTR_MAX_VAL)\r\nreturn -EINVAL;\r\nspin_lock(&drvdata->spinlock);\r\nidx = drvdata->cntr_idx;\r\ndrvdata->cntr_val[idx] = val;\r\nspin_unlock(&drvdata->spinlock);\r\nreturn size;\r\n}\r\nstatic ssize_t cntr_ctrl_show(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nu8 idx;\r\nunsigned long val;\r\nstruct etmv4_drvdata *drvdata = dev_get_drvdata(dev->parent);\r\nspin_lock(&drvdata->spinlock);\r\nidx = drvdata->cntr_idx;\r\nval = drvdata->cntr_ctrl[idx];\r\nspin_unlock(&drvdata->spinlock);\r\nreturn scnprintf(buf, PAGE_SIZE, "%#lx\n", val);\r\n}\r\nstatic ssize_t cntr_ctrl_store(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t size)\r\n{\r\nu8 idx;\r\nunsigned long val;\r\nstruct etmv4_drvdata *drvdata = dev_get_drvdata(dev->parent);\r\nif (kstrtoul(buf, 16, &val))\r\nreturn -EINVAL;\r\nspin_lock(&drvdata->spinlock);\r\nidx = drvdata->cntr_idx;\r\ndrvdata->cntr_ctrl[idx] = val;\r\nspin_unlock(&drvdata->spinlock);\r\nreturn size;\r\n}\r\nstatic ssize_t res_idx_show(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nunsigned long val;\r\nstruct etmv4_drvdata *drvdata = dev_get_drvdata(dev->parent);\r\nval = drvdata->res_idx;\r\nreturn scnprintf(buf, PAGE_SIZE, "%#lx\n", val);\r\n}\r\nstatic ssize_t res_idx_store(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t size)\r\n{\r\nunsigned long val;\r\nstruct etmv4_drvdata *drvdata = dev_get_drvdata(dev->parent);\r\nif (kstrtoul(buf, 16, &val))\r\nreturn -EINVAL;\r\nif (val < 2 || val >= drvdata->nr_resource * 2)\r\nreturn -EINVAL;\r\nspin_lock(&drvdata->spinlock);\r\ndrvdata->res_idx = val;\r\nspin_unlock(&drvdata->spinlock);\r\nreturn size;\r\n}\r\nstatic ssize_t res_ctrl_show(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nu8 idx;\r\nunsigned long val;\r\nstruct etmv4_drvdata *drvdata = dev_get_drvdata(dev->parent);\r\nspin_lock(&drvdata->spinlock);\r\nidx = drvdata->res_idx;\r\nval = drvdata->res_ctrl[idx];\r\nspin_unlock(&drvdata->spinlock);\r\nreturn scnprintf(buf, PAGE_SIZE, "%#lx\n", val);\r\n}\r\nstatic ssize_t res_ctrl_store(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t size)\r\n{\r\nu8 idx;\r\nunsigned long val;\r\nstruct etmv4_drvdata *drvdata = dev_get_drvdata(dev->parent);\r\nif (kstrtoul(buf, 16, &val))\r\nreturn -EINVAL;\r\nspin_lock(&drvdata->spinlock);\r\nidx = drvdata->res_idx;\r\nif (idx % 2 != 0)\r\nval &= ~BIT(21);\r\ndrvdata->res_ctrl[idx] = val;\r\nspin_unlock(&drvdata->spinlock);\r\nreturn size;\r\n}\r\nstatic ssize_t ctxid_idx_show(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nunsigned long val;\r\nstruct etmv4_drvdata *drvdata = dev_get_drvdata(dev->parent);\r\nval = drvdata->ctxid_idx;\r\nreturn scnprintf(buf, PAGE_SIZE, "%#lx\n", val);\r\n}\r\nstatic ssize_t ctxid_idx_store(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t size)\r\n{\r\nunsigned long val;\r\nstruct etmv4_drvdata *drvdata = dev_get_drvdata(dev->parent);\r\nif (kstrtoul(buf, 16, &val))\r\nreturn -EINVAL;\r\nif (val >= drvdata->numcidc)\r\nreturn -EINVAL;\r\nspin_lock(&drvdata->spinlock);\r\ndrvdata->ctxid_idx = val;\r\nspin_unlock(&drvdata->spinlock);\r\nreturn size;\r\n}\r\nstatic ssize_t ctxid_pid_show(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nu8 idx;\r\nunsigned long val;\r\nstruct etmv4_drvdata *drvdata = dev_get_drvdata(dev->parent);\r\nspin_lock(&drvdata->spinlock);\r\nidx = drvdata->ctxid_idx;\r\nval = (unsigned long)drvdata->ctxid_vpid[idx];\r\nspin_unlock(&drvdata->spinlock);\r\nreturn scnprintf(buf, PAGE_SIZE, "%#lx\n", val);\r\n}\r\nstatic ssize_t ctxid_pid_store(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t size)\r\n{\r\nu8 idx;\r\nunsigned long vpid, pid;\r\nstruct etmv4_drvdata *drvdata = dev_get_drvdata(dev->parent);\r\nif (!drvdata->ctxid_size || !drvdata->numcidc)\r\nreturn -EINVAL;\r\nif (kstrtoul(buf, 16, &vpid))\r\nreturn -EINVAL;\r\npid = coresight_vpid_to_pid(vpid);\r\nspin_lock(&drvdata->spinlock);\r\nidx = drvdata->ctxid_idx;\r\ndrvdata->ctxid_pid[idx] = (u64)pid;\r\ndrvdata->ctxid_vpid[idx] = (u64)vpid;\r\nspin_unlock(&drvdata->spinlock);\r\nreturn size;\r\n}\r\nstatic ssize_t ctxid_masks_show(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nunsigned long val1, val2;\r\nstruct etmv4_drvdata *drvdata = dev_get_drvdata(dev->parent);\r\nspin_lock(&drvdata->spinlock);\r\nval1 = drvdata->ctxid_mask0;\r\nval2 = drvdata->ctxid_mask1;\r\nspin_unlock(&drvdata->spinlock);\r\nreturn scnprintf(buf, PAGE_SIZE, "%#lx %#lx\n", val1, val2);\r\n}\r\nstatic ssize_t ctxid_masks_store(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t size)\r\n{\r\nu8 i, j, maskbyte;\r\nunsigned long val1, val2, mask;\r\nstruct etmv4_drvdata *drvdata = dev_get_drvdata(dev->parent);\r\nif (!drvdata->ctxid_size || !drvdata->numcidc)\r\nreturn -EINVAL;\r\nif (sscanf(buf, "%lx %lx", &val1, &val2) != 2)\r\nreturn -EINVAL;\r\nspin_lock(&drvdata->spinlock);\r\nswitch (drvdata->numcidc) {\r\ncase 0x1:\r\ndrvdata->ctxid_mask0 = val1 & 0xFF;\r\nbreak;\r\ncase 0x2:\r\ndrvdata->ctxid_mask0 = val1 & 0xFFFF;\r\nbreak;\r\ncase 0x3:\r\ndrvdata->ctxid_mask0 = val1 & 0xFFFFFF;\r\nbreak;\r\ncase 0x4:\r\ndrvdata->ctxid_mask0 = val1;\r\nbreak;\r\ncase 0x5:\r\ndrvdata->ctxid_mask0 = val1;\r\ndrvdata->ctxid_mask1 = val2 & 0xFF;\r\nbreak;\r\ncase 0x6:\r\ndrvdata->ctxid_mask0 = val1;\r\ndrvdata->ctxid_mask1 = val2 & 0xFFFF;\r\nbreak;\r\ncase 0x7:\r\ndrvdata->ctxid_mask0 = val1;\r\ndrvdata->ctxid_mask1 = val2 & 0xFFFFFF;\r\nbreak;\r\ncase 0x8:\r\ndrvdata->ctxid_mask0 = val1;\r\ndrvdata->ctxid_mask1 = val2;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nmask = drvdata->ctxid_mask0;\r\nfor (i = 0; i < drvdata->numcidc; i++) {\r\nmaskbyte = mask & ETMv4_EVENT_MASK;\r\nfor (j = 0; j < 8; j++) {\r\nif (maskbyte & 1)\r\ndrvdata->ctxid_pid[i] &= ~(0xFF << (j * 8));\r\nmaskbyte >>= 1;\r\n}\r\nif (i == 3)\r\nmask = drvdata->ctxid_mask1;\r\nelse\r\nmask >>= 0x8;\r\n}\r\nspin_unlock(&drvdata->spinlock);\r\nreturn size;\r\n}\r\nstatic ssize_t vmid_idx_show(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nunsigned long val;\r\nstruct etmv4_drvdata *drvdata = dev_get_drvdata(dev->parent);\r\nval = drvdata->vmid_idx;\r\nreturn scnprintf(buf, PAGE_SIZE, "%#lx\n", val);\r\n}\r\nstatic ssize_t vmid_idx_store(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t size)\r\n{\r\nunsigned long val;\r\nstruct etmv4_drvdata *drvdata = dev_get_drvdata(dev->parent);\r\nif (kstrtoul(buf, 16, &val))\r\nreturn -EINVAL;\r\nif (val >= drvdata->numvmidc)\r\nreturn -EINVAL;\r\nspin_lock(&drvdata->spinlock);\r\ndrvdata->vmid_idx = val;\r\nspin_unlock(&drvdata->spinlock);\r\nreturn size;\r\n}\r\nstatic ssize_t vmid_val_show(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nunsigned long val;\r\nstruct etmv4_drvdata *drvdata = dev_get_drvdata(dev->parent);\r\nval = (unsigned long)drvdata->vmid_val[drvdata->vmid_idx];\r\nreturn scnprintf(buf, PAGE_SIZE, "%#lx\n", val);\r\n}\r\nstatic ssize_t vmid_val_store(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t size)\r\n{\r\nunsigned long val;\r\nstruct etmv4_drvdata *drvdata = dev_get_drvdata(dev->parent);\r\nif (!drvdata->vmid_size || !drvdata->numvmidc)\r\nreturn -EINVAL;\r\nif (kstrtoul(buf, 16, &val))\r\nreturn -EINVAL;\r\nspin_lock(&drvdata->spinlock);\r\ndrvdata->vmid_val[drvdata->vmid_idx] = (u64)val;\r\nspin_unlock(&drvdata->spinlock);\r\nreturn size;\r\n}\r\nstatic ssize_t vmid_masks_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nunsigned long val1, val2;\r\nstruct etmv4_drvdata *drvdata = dev_get_drvdata(dev->parent);\r\nspin_lock(&drvdata->spinlock);\r\nval1 = drvdata->vmid_mask0;\r\nval2 = drvdata->vmid_mask1;\r\nspin_unlock(&drvdata->spinlock);\r\nreturn scnprintf(buf, PAGE_SIZE, "%#lx %#lx\n", val1, val2);\r\n}\r\nstatic ssize_t vmid_masks_store(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t size)\r\n{\r\nu8 i, j, maskbyte;\r\nunsigned long val1, val2, mask;\r\nstruct etmv4_drvdata *drvdata = dev_get_drvdata(dev->parent);\r\nif (!drvdata->vmid_size || !drvdata->numvmidc)\r\nreturn -EINVAL;\r\nif (sscanf(buf, "%lx %lx", &val1, &val2) != 2)\r\nreturn -EINVAL;\r\nspin_lock(&drvdata->spinlock);\r\nswitch (drvdata->numvmidc) {\r\ncase 0x1:\r\ndrvdata->vmid_mask0 = val1 & 0xFF;\r\nbreak;\r\ncase 0x2:\r\ndrvdata->vmid_mask0 = val1 & 0xFFFF;\r\nbreak;\r\ncase 0x3:\r\ndrvdata->vmid_mask0 = val1 & 0xFFFFFF;\r\nbreak;\r\ncase 0x4:\r\ndrvdata->vmid_mask0 = val1;\r\nbreak;\r\ncase 0x5:\r\ndrvdata->vmid_mask0 = val1;\r\ndrvdata->vmid_mask1 = val2 & 0xFF;\r\nbreak;\r\ncase 0x6:\r\ndrvdata->vmid_mask0 = val1;\r\ndrvdata->vmid_mask1 = val2 & 0xFFFF;\r\nbreak;\r\ncase 0x7:\r\ndrvdata->vmid_mask0 = val1;\r\ndrvdata->vmid_mask1 = val2 & 0xFFFFFF;\r\nbreak;\r\ncase 0x8:\r\ndrvdata->vmid_mask0 = val1;\r\ndrvdata->vmid_mask1 = val2;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nmask = drvdata->vmid_mask0;\r\nfor (i = 0; i < drvdata->numvmidc; i++) {\r\nmaskbyte = mask & ETMv4_EVENT_MASK;\r\nfor (j = 0; j < 8; j++) {\r\nif (maskbyte & 1)\r\ndrvdata->vmid_val[i] &= ~(0xFF << (j * 8));\r\nmaskbyte >>= 1;\r\n}\r\nif (i == 3)\r\nmask = drvdata->vmid_mask1;\r\nelse\r\nmask >>= 0x8;\r\n}\r\nspin_unlock(&drvdata->spinlock);\r\nreturn size;\r\n}\r\nstatic ssize_t cpu_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nint val;\r\nstruct etmv4_drvdata *drvdata = dev_get_drvdata(dev->parent);\r\nval = drvdata->cpu;\r\nreturn scnprintf(buf, PAGE_SIZE, "%d\n", val);\r\n}\r\nstatic void etm4_init_arch_data(void *info)\r\n{\r\nu32 etmidr0;\r\nu32 etmidr1;\r\nu32 etmidr2;\r\nu32 etmidr3;\r\nu32 etmidr4;\r\nu32 etmidr5;\r\nstruct etmv4_drvdata *drvdata = info;\r\nCS_UNLOCK(drvdata->base);\r\netmidr0 = readl_relaxed(drvdata->base + TRCIDR0);\r\nif (BMVAL(etmidr0, 1, 1) && BMVAL(etmidr0, 2, 2))\r\ndrvdata->instrp0 = true;\r\nelse\r\ndrvdata->instrp0 = false;\r\nif (BMVAL(etmidr0, 5, 5))\r\ndrvdata->trcbb = true;\r\nelse\r\ndrvdata->trcbb = false;\r\nif (BMVAL(etmidr0, 6, 6))\r\ndrvdata->trccond = true;\r\nelse\r\ndrvdata->trccond = false;\r\nif (BMVAL(etmidr0, 7, 7))\r\ndrvdata->trccci = true;\r\nelse\r\ndrvdata->trccci = false;\r\nif (BMVAL(etmidr0, 9, 9))\r\ndrvdata->retstack = true;\r\nelse\r\ndrvdata->retstack = false;\r\ndrvdata->nr_event = BMVAL(etmidr0, 10, 11);\r\ndrvdata->q_support = BMVAL(etmidr0, 15, 16);\r\ndrvdata->ts_size = BMVAL(etmidr0, 24, 28);\r\netmidr1 = readl_relaxed(drvdata->base + TRCIDR1);\r\ndrvdata->arch = BMVAL(etmidr1, 4, 11);\r\netmidr2 = readl_relaxed(drvdata->base + TRCIDR2);\r\ndrvdata->ctxid_size = BMVAL(etmidr2, 5, 9);\r\ndrvdata->vmid_size = BMVAL(etmidr2, 10, 14);\r\ndrvdata->ccsize = BMVAL(etmidr2, 25, 28);\r\netmidr3 = readl_relaxed(drvdata->base + TRCIDR3);\r\ndrvdata->ccitmin = BMVAL(etmidr3, 0, 11);\r\ndrvdata->s_ex_level = BMVAL(etmidr3, 16, 19);\r\ndrvdata->ns_ex_level = BMVAL(etmidr3, 20, 23);\r\nif (BMVAL(etmidr3, 24, 24))\r\ndrvdata->trc_error = true;\r\nelse\r\ndrvdata->trc_error = false;\r\nif (BMVAL(etmidr3, 25, 25))\r\ndrvdata->syncpr = true;\r\nelse\r\ndrvdata->syncpr = false;\r\nif (BMVAL(etmidr3, 26, 26))\r\ndrvdata->stallctl = true;\r\nelse\r\ndrvdata->stallctl = false;\r\nif (BMVAL(etmidr3, 27, 27))\r\ndrvdata->sysstall = true;\r\nelse\r\ndrvdata->sysstall = false;\r\ndrvdata->nr_pe = BMVAL(etmidr3, 28, 30);\r\nif (BMVAL(etmidr3, 31, 31))\r\ndrvdata->nooverflow = true;\r\nelse\r\ndrvdata->nooverflow = false;\r\netmidr4 = readl_relaxed(drvdata->base + TRCIDR4);\r\ndrvdata->nr_addr_cmp = BMVAL(etmidr4, 0, 3);\r\ndrvdata->nr_pe_cmp = BMVAL(etmidr4, 12, 15);\r\ndrvdata->nr_resource = BMVAL(etmidr4, 16, 19) + 1;\r\ndrvdata->nr_ss_cmp = BMVAL(etmidr4, 20, 23);\r\ndrvdata->numcidc = BMVAL(etmidr4, 24, 27);\r\ndrvdata->numvmidc = BMVAL(etmidr4, 28, 31);\r\netmidr5 = readl_relaxed(drvdata->base + TRCIDR5);\r\ndrvdata->nr_ext_inp = BMVAL(etmidr5, 0, 8);\r\ndrvdata->trcid_size = BMVAL(etmidr5, 16, 21);\r\nif (BMVAL(etmidr5, 22, 22))\r\ndrvdata->atbtrig = true;\r\nelse\r\ndrvdata->atbtrig = false;\r\nif (BMVAL(etmidr5, 23, 23))\r\ndrvdata->lpoverride = true;\r\nelse\r\ndrvdata->lpoverride = false;\r\ndrvdata->nrseqstate = BMVAL(etmidr5, 25, 27);\r\ndrvdata->nr_cntr = BMVAL(etmidr5, 28, 30);\r\nCS_LOCK(drvdata->base);\r\n}\r\nstatic void etm4_init_default_data(struct etmv4_drvdata *drvdata)\r\n{\r\nint i;\r\ndrvdata->pe_sel = 0x0;\r\ndrvdata->cfg = (ETMv4_MODE_CTXID | ETM_MODE_VMID |\r\nETMv4_MODE_TIMESTAMP | ETM_MODE_RETURNSTACK);\r\ndrvdata->eventctrl0 = 0x0;\r\ndrvdata->eventctrl1 = 0x0;\r\ndrvdata->stall_ctrl = 0x0;\r\ndrvdata->ts_ctrl = 0x0;\r\nif (drvdata->syncpr == false)\r\ndrvdata->syncfreq = 0xC;\r\ndrvdata->vinst_ctrl |= BIT(0);\r\nif (drvdata->nr_addr_cmp)\r\ndrvdata->vinst_ctrl |= BIT(9);\r\ndrvdata->viiectlr = 0x0;\r\ndrvdata->vissctlr = 0x0;\r\nfor (i = 0; i < drvdata->nrseqstate-1; i++)\r\ndrvdata->seq_ctrl[i] = 0x0;\r\ndrvdata->seq_rst = 0x0;\r\ndrvdata->seq_state = 0x0;\r\ndrvdata->ext_inp = 0x0;\r\nfor (i = 0; i < drvdata->nr_cntr; i++) {\r\ndrvdata->cntrldvr[i] = 0x0;\r\ndrvdata->cntr_ctrl[i] = 0x0;\r\ndrvdata->cntr_val[i] = 0x0;\r\n}\r\ndrvdata->res_idx = 0x2;\r\nfor (i = 2; i < drvdata->nr_resource * 2; i++)\r\ndrvdata->res_ctrl[i] = 0x0;\r\nfor (i = 0; i < drvdata->nr_ss_cmp; i++) {\r\ndrvdata->ss_ctrl[i] = 0x0;\r\ndrvdata->ss_pe_cmp[i] = 0x0;\r\n}\r\nif (drvdata->nr_addr_cmp >= 1) {\r\ndrvdata->addr_val[0] = (unsigned long)_stext;\r\ndrvdata->addr_val[1] = (unsigned long)_etext;\r\ndrvdata->addr_type[0] = ETM_ADDR_TYPE_RANGE;\r\ndrvdata->addr_type[1] = ETM_ADDR_TYPE_RANGE;\r\n}\r\nfor (i = 0; i < drvdata->numcidc; i++) {\r\ndrvdata->ctxid_pid[i] = 0x0;\r\ndrvdata->ctxid_vpid[i] = 0x0;\r\n}\r\ndrvdata->ctxid_mask0 = 0x0;\r\ndrvdata->ctxid_mask1 = 0x0;\r\nfor (i = 0; i < drvdata->numvmidc; i++)\r\ndrvdata->vmid_val[i] = 0x0;\r\ndrvdata->vmid_mask0 = 0x0;\r\ndrvdata->vmid_mask1 = 0x0;\r\ndrvdata->trcid = 0x20 + drvdata->cpu;\r\n}\r\nstatic int etm4_cpu_callback(struct notifier_block *nfb, unsigned long action,\r\nvoid *hcpu)\r\n{\r\nunsigned int cpu = (unsigned long)hcpu;\r\nif (!etmdrvdata[cpu])\r\ngoto out;\r\nswitch (action & (~CPU_TASKS_FROZEN)) {\r\ncase CPU_STARTING:\r\nspin_lock(&etmdrvdata[cpu]->spinlock);\r\nif (!etmdrvdata[cpu]->os_unlock) {\r\netm4_os_unlock(etmdrvdata[cpu]);\r\netmdrvdata[cpu]->os_unlock = true;\r\n}\r\nif (etmdrvdata[cpu]->enable)\r\netm4_enable_hw(etmdrvdata[cpu]);\r\nspin_unlock(&etmdrvdata[cpu]->spinlock);\r\nbreak;\r\ncase CPU_ONLINE:\r\nif (etmdrvdata[cpu]->boot_enable &&\r\n!etmdrvdata[cpu]->sticky_enable)\r\ncoresight_enable(etmdrvdata[cpu]->csdev);\r\nbreak;\r\ncase CPU_DYING:\r\nspin_lock(&etmdrvdata[cpu]->spinlock);\r\nif (etmdrvdata[cpu]->enable)\r\netm4_disable_hw(etmdrvdata[cpu]);\r\nspin_unlock(&etmdrvdata[cpu]->spinlock);\r\nbreak;\r\n}\r\nout:\r\nreturn NOTIFY_OK;\r\n}\r\nstatic int etm4_probe(struct amba_device *adev, const struct amba_id *id)\r\n{\r\nint ret;\r\nvoid __iomem *base;\r\nstruct device *dev = &adev->dev;\r\nstruct coresight_platform_data *pdata = NULL;\r\nstruct etmv4_drvdata *drvdata;\r\nstruct resource *res = &adev->res;\r\nstruct coresight_desc *desc;\r\nstruct device_node *np = adev->dev.of_node;\r\ndesc = devm_kzalloc(dev, sizeof(*desc), GFP_KERNEL);\r\nif (!desc)\r\nreturn -ENOMEM;\r\ndrvdata = devm_kzalloc(dev, sizeof(*drvdata), GFP_KERNEL);\r\nif (!drvdata)\r\nreturn -ENOMEM;\r\nif (np) {\r\npdata = of_get_coresight_platform_data(dev, np);\r\nif (IS_ERR(pdata))\r\nreturn PTR_ERR(pdata);\r\nadev->dev.platform_data = pdata;\r\n}\r\ndrvdata->dev = &adev->dev;\r\ndev_set_drvdata(dev, drvdata);\r\nbase = devm_ioremap_resource(dev, res);\r\nif (IS_ERR(base))\r\nreturn PTR_ERR(base);\r\ndrvdata->base = base;\r\nspin_lock_init(&drvdata->spinlock);\r\ndrvdata->cpu = pdata ? pdata->cpu : 0;\r\nget_online_cpus();\r\netmdrvdata[drvdata->cpu] = drvdata;\r\nif (!smp_call_function_single(drvdata->cpu, etm4_os_unlock, drvdata, 1))\r\ndrvdata->os_unlock = true;\r\nif (smp_call_function_single(drvdata->cpu,\r\netm4_init_arch_data, drvdata, 1))\r\ndev_err(dev, "ETM arch init failed\n");\r\nif (!etm4_count++)\r\nregister_hotcpu_notifier(&etm4_cpu_notifier);\r\nput_online_cpus();\r\nif (etm4_arch_supported(drvdata->arch) == false) {\r\nret = -EINVAL;\r\ngoto err_arch_supported;\r\n}\r\netm4_init_default_data(drvdata);\r\npm_runtime_put(&adev->dev);\r\ndesc->type = CORESIGHT_DEV_TYPE_SOURCE;\r\ndesc->subtype.source_subtype = CORESIGHT_DEV_SUBTYPE_SOURCE_PROC;\r\ndesc->ops = &etm4_cs_ops;\r\ndesc->pdata = pdata;\r\ndesc->dev = dev;\r\ndesc->groups = coresight_etmv4_groups;\r\ndrvdata->csdev = coresight_register(desc);\r\nif (IS_ERR(drvdata->csdev)) {\r\nret = PTR_ERR(drvdata->csdev);\r\ngoto err_coresight_register;\r\n}\r\ndev_info(dev, "%s initialized\n", (char *)id->data);\r\nif (boot_enable) {\r\ncoresight_enable(drvdata->csdev);\r\ndrvdata->boot_enable = true;\r\n}\r\nreturn 0;\r\nerr_arch_supported:\r\npm_runtime_put(&adev->dev);\r\nerr_coresight_register:\r\nif (--etm4_count == 0)\r\nunregister_hotcpu_notifier(&etm4_cpu_notifier);\r\nreturn ret;\r\n}\r\nstatic int etm4_remove(struct amba_device *adev)\r\n{\r\nstruct etmv4_drvdata *drvdata = amba_get_drvdata(adev);\r\ncoresight_unregister(drvdata->csdev);\r\nif (--etm4_count == 0)\r\nunregister_hotcpu_notifier(&etm4_cpu_notifier);\r\nreturn 0;\r\n}
