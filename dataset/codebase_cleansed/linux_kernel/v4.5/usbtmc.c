static void usbtmc_delete(struct kref *kref)\r\n{\r\nstruct usbtmc_device_data *data = to_usbtmc_data(kref);\r\nusb_put_dev(data->usb_dev);\r\n}\r\nstatic int usbtmc_open(struct inode *inode, struct file *filp)\r\n{\r\nstruct usb_interface *intf;\r\nstruct usbtmc_device_data *data;\r\nint retval = 0;\r\nintf = usb_find_interface(&usbtmc_driver, iminor(inode));\r\nif (!intf) {\r\npr_err("can not find device for minor %d", iminor(inode));\r\nreturn -ENODEV;\r\n}\r\ndata = usb_get_intfdata(intf);\r\nkref_get(&data->kref);\r\nfilp->private_data = data;\r\nreturn retval;\r\n}\r\nstatic int usbtmc_release(struct inode *inode, struct file *file)\r\n{\r\nstruct usbtmc_device_data *data = file->private_data;\r\nkref_put(&data->kref, usbtmc_delete);\r\nreturn 0;\r\n}\r\nstatic int usbtmc_ioctl_abort_bulk_in(struct usbtmc_device_data *data)\r\n{\r\nu8 *buffer;\r\nstruct device *dev;\r\nint rv;\r\nint n;\r\nint actual;\r\nstruct usb_host_interface *current_setting;\r\nint max_size;\r\ndev = &data->intf->dev;\r\nbuffer = kmalloc(USBTMC_SIZE_IOBUFFER, GFP_KERNEL);\r\nif (!buffer)\r\nreturn -ENOMEM;\r\nrv = usb_control_msg(data->usb_dev,\r\nusb_rcvctrlpipe(data->usb_dev, 0),\r\nUSBTMC_REQUEST_INITIATE_ABORT_BULK_IN,\r\nUSB_DIR_IN | USB_TYPE_CLASS | USB_RECIP_ENDPOINT,\r\ndata->bTag_last_read, data->bulk_in,\r\nbuffer, 2, USBTMC_TIMEOUT);\r\nif (rv < 0) {\r\ndev_err(dev, "usb_control_msg returned %d\n", rv);\r\ngoto exit;\r\n}\r\ndev_dbg(dev, "INITIATE_ABORT_BULK_IN returned %x\n", buffer[0]);\r\nif (buffer[0] == USBTMC_STATUS_FAILED) {\r\nrv = 0;\r\ngoto exit;\r\n}\r\nif (buffer[0] != USBTMC_STATUS_SUCCESS) {\r\ndev_err(dev, "INITIATE_ABORT_BULK_IN returned %x\n",\r\nbuffer[0]);\r\nrv = -EPERM;\r\ngoto exit;\r\n}\r\nmax_size = 0;\r\ncurrent_setting = data->intf->cur_altsetting;\r\nfor (n = 0; n < current_setting->desc.bNumEndpoints; n++)\r\nif (current_setting->endpoint[n].desc.bEndpointAddress ==\r\ndata->bulk_in)\r\nmax_size = usb_endpoint_maxp(&current_setting->endpoint[n].desc);\r\nif (max_size == 0) {\r\ndev_err(dev, "Couldn't get wMaxPacketSize\n");\r\nrv = -EPERM;\r\ngoto exit;\r\n}\r\ndev_dbg(&data->intf->dev, "wMaxPacketSize is %d\n", max_size);\r\nn = 0;\r\ndo {\r\ndev_dbg(dev, "Reading from bulk in EP\n");\r\nrv = usb_bulk_msg(data->usb_dev,\r\nusb_rcvbulkpipe(data->usb_dev,\r\ndata->bulk_in),\r\nbuffer, USBTMC_SIZE_IOBUFFER,\r\n&actual, USBTMC_TIMEOUT);\r\nn++;\r\nif (rv < 0) {\r\ndev_err(dev, "usb_bulk_msg returned %d\n", rv);\r\ngoto exit;\r\n}\r\n} while ((actual == max_size) &&\r\n(n < USBTMC_MAX_READS_TO_CLEAR_BULK_IN));\r\nif (actual == max_size) {\r\ndev_err(dev, "Couldn't clear device buffer within %d cycles\n",\r\nUSBTMC_MAX_READS_TO_CLEAR_BULK_IN);\r\nrv = -EPERM;\r\ngoto exit;\r\n}\r\nn = 0;\r\nusbtmc_abort_bulk_in_status:\r\nrv = usb_control_msg(data->usb_dev,\r\nusb_rcvctrlpipe(data->usb_dev, 0),\r\nUSBTMC_REQUEST_CHECK_ABORT_BULK_IN_STATUS,\r\nUSB_DIR_IN | USB_TYPE_CLASS | USB_RECIP_ENDPOINT,\r\n0, data->bulk_in, buffer, 0x08,\r\nUSBTMC_TIMEOUT);\r\nif (rv < 0) {\r\ndev_err(dev, "usb_control_msg returned %d\n", rv);\r\ngoto exit;\r\n}\r\ndev_dbg(dev, "INITIATE_ABORT_BULK_IN returned %x\n", buffer[0]);\r\nif (buffer[0] == USBTMC_STATUS_SUCCESS) {\r\nrv = 0;\r\ngoto exit;\r\n}\r\nif (buffer[0] != USBTMC_STATUS_PENDING) {\r\ndev_err(dev, "INITIATE_ABORT_BULK_IN returned %x\n", buffer[0]);\r\nrv = -EPERM;\r\ngoto exit;\r\n}\r\nif (buffer[1] == 1)\r\ndo {\r\ndev_dbg(dev, "Reading from bulk in EP\n");\r\nrv = usb_bulk_msg(data->usb_dev,\r\nusb_rcvbulkpipe(data->usb_dev,\r\ndata->bulk_in),\r\nbuffer, USBTMC_SIZE_IOBUFFER,\r\n&actual, USBTMC_TIMEOUT);\r\nn++;\r\nif (rv < 0) {\r\ndev_err(dev, "usb_bulk_msg returned %d\n", rv);\r\ngoto exit;\r\n}\r\n} while ((actual == max_size) &&\r\n(n < USBTMC_MAX_READS_TO_CLEAR_BULK_IN));\r\nif (actual == max_size) {\r\ndev_err(dev, "Couldn't clear device buffer within %d cycles\n",\r\nUSBTMC_MAX_READS_TO_CLEAR_BULK_IN);\r\nrv = -EPERM;\r\ngoto exit;\r\n}\r\ngoto usbtmc_abort_bulk_in_status;\r\nexit:\r\nkfree(buffer);\r\nreturn rv;\r\n}\r\nstatic int usbtmc_ioctl_abort_bulk_out(struct usbtmc_device_data *data)\r\n{\r\nstruct device *dev;\r\nu8 *buffer;\r\nint rv;\r\nint n;\r\ndev = &data->intf->dev;\r\nbuffer = kmalloc(8, GFP_KERNEL);\r\nif (!buffer)\r\nreturn -ENOMEM;\r\nrv = usb_control_msg(data->usb_dev,\r\nusb_rcvctrlpipe(data->usb_dev, 0),\r\nUSBTMC_REQUEST_INITIATE_ABORT_BULK_OUT,\r\nUSB_DIR_IN | USB_TYPE_CLASS | USB_RECIP_ENDPOINT,\r\ndata->bTag_last_write, data->bulk_out,\r\nbuffer, 2, USBTMC_TIMEOUT);\r\nif (rv < 0) {\r\ndev_err(dev, "usb_control_msg returned %d\n", rv);\r\ngoto exit;\r\n}\r\ndev_dbg(dev, "INITIATE_ABORT_BULK_OUT returned %x\n", buffer[0]);\r\nif (buffer[0] != USBTMC_STATUS_SUCCESS) {\r\ndev_err(dev, "INITIATE_ABORT_BULK_OUT returned %x\n",\r\nbuffer[0]);\r\nrv = -EPERM;\r\ngoto exit;\r\n}\r\nn = 0;\r\nusbtmc_abort_bulk_out_check_status:\r\nrv = usb_control_msg(data->usb_dev,\r\nusb_rcvctrlpipe(data->usb_dev, 0),\r\nUSBTMC_REQUEST_CHECK_ABORT_BULK_OUT_STATUS,\r\nUSB_DIR_IN | USB_TYPE_CLASS | USB_RECIP_ENDPOINT,\r\n0, data->bulk_out, buffer, 0x08,\r\nUSBTMC_TIMEOUT);\r\nn++;\r\nif (rv < 0) {\r\ndev_err(dev, "usb_control_msg returned %d\n", rv);\r\ngoto exit;\r\n}\r\ndev_dbg(dev, "CHECK_ABORT_BULK_OUT returned %x\n", buffer[0]);\r\nif (buffer[0] == USBTMC_STATUS_SUCCESS)\r\ngoto usbtmc_abort_bulk_out_clear_halt;\r\nif ((buffer[0] == USBTMC_STATUS_PENDING) &&\r\n(n < USBTMC_MAX_READS_TO_CLEAR_BULK_IN))\r\ngoto usbtmc_abort_bulk_out_check_status;\r\nrv = -EPERM;\r\ngoto exit;\r\nusbtmc_abort_bulk_out_clear_halt:\r\nrv = usb_clear_halt(data->usb_dev,\r\nusb_sndbulkpipe(data->usb_dev, data->bulk_out));\r\nif (rv < 0) {\r\ndev_err(dev, "usb_control_msg returned %d\n", rv);\r\ngoto exit;\r\n}\r\nrv = 0;\r\nexit:\r\nkfree(buffer);\r\nreturn rv;\r\n}\r\nstatic int send_request_dev_dep_msg_in(struct usbtmc_device_data *data, size_t transfer_size)\r\n{\r\nint retval;\r\nu8 *buffer;\r\nint actual;\r\nbuffer = kmalloc(USBTMC_HEADER_SIZE, GFP_KERNEL);\r\nif (!buffer)\r\nreturn -ENOMEM;\r\nbuffer[0] = 2;\r\nbuffer[1] = data->bTag;\r\nbuffer[2] = ~data->bTag;\r\nbuffer[3] = 0;\r\nbuffer[4] = transfer_size >> 0;\r\nbuffer[5] = transfer_size >> 8;\r\nbuffer[6] = transfer_size >> 16;\r\nbuffer[7] = transfer_size >> 24;\r\nbuffer[8] = data->TermCharEnabled * 2;\r\nbuffer[9] = data->TermChar;\r\nbuffer[10] = 0;\r\nbuffer[11] = 0;\r\nretval = usb_bulk_msg(data->usb_dev,\r\nusb_sndbulkpipe(data->usb_dev,\r\ndata->bulk_out),\r\nbuffer, USBTMC_HEADER_SIZE, &actual, USBTMC_TIMEOUT);\r\ndata->bTag_last_write = data->bTag;\r\ndata->bTag++;\r\nif (!data->bTag)\r\ndata->bTag++;\r\nkfree(buffer);\r\nif (retval < 0) {\r\ndev_err(&data->intf->dev, "usb_bulk_msg in send_request_dev_dep_msg_in() returned %d\n", retval);\r\nreturn retval;\r\n}\r\nreturn 0;\r\n}\r\nstatic ssize_t usbtmc_read(struct file *filp, char __user *buf,\r\nsize_t count, loff_t *f_pos)\r\n{\r\nstruct usbtmc_device_data *data;\r\nstruct device *dev;\r\nu32 n_characters;\r\nu8 *buffer;\r\nint actual;\r\nsize_t done;\r\nsize_t remaining;\r\nint retval;\r\nsize_t this_part;\r\ndata = filp->private_data;\r\ndev = &data->intf->dev;\r\nbuffer = kmalloc(USBTMC_SIZE_IOBUFFER, GFP_KERNEL);\r\nif (!buffer)\r\nreturn -ENOMEM;\r\nmutex_lock(&data->io_mutex);\r\nif (data->zombie) {\r\nretval = -ENODEV;\r\ngoto exit;\r\n}\r\nif (data->rigol_quirk) {\r\ndev_dbg(dev, "usb_bulk_msg_in: count(%zu)\n", count);\r\nretval = send_request_dev_dep_msg_in(data, count);\r\nif (retval < 0) {\r\nif (data->auto_abort)\r\nusbtmc_ioctl_abort_bulk_out(data);\r\ngoto exit;\r\n}\r\n}\r\nremaining = count;\r\nthis_part = remaining;\r\ndone = 0;\r\nwhile (remaining > 0) {\r\nif (!data->rigol_quirk) {\r\ndev_dbg(dev, "usb_bulk_msg_in: remaining(%zu), count(%zu)\n", remaining, count);\r\nif (remaining > USBTMC_SIZE_IOBUFFER - USBTMC_HEADER_SIZE - 3)\r\nthis_part = USBTMC_SIZE_IOBUFFER - USBTMC_HEADER_SIZE - 3;\r\nelse\r\nthis_part = remaining;\r\nretval = send_request_dev_dep_msg_in(data, this_part);\r\nif (retval < 0) {\r\ndev_err(dev, "usb_bulk_msg returned %d\n", retval);\r\nif (data->auto_abort)\r\nusbtmc_ioctl_abort_bulk_out(data);\r\ngoto exit;\r\n}\r\n}\r\nretval = usb_bulk_msg(data->usb_dev,\r\nusb_rcvbulkpipe(data->usb_dev,\r\ndata->bulk_in),\r\nbuffer, USBTMC_SIZE_IOBUFFER, &actual,\r\nUSBTMC_TIMEOUT);\r\ndev_dbg(dev, "usb_bulk_msg: retval(%u), done(%zu), remaining(%zu), actual(%d)\n", retval, done, remaining, actual);\r\ndata->bTag_last_read = data->bTag;\r\nif (retval < 0) {\r\ndev_dbg(dev, "Unable to read data, error %d\n", retval);\r\nif (data->auto_abort)\r\nusbtmc_ioctl_abort_bulk_in(data);\r\ngoto exit;\r\n}\r\nif ((done == 0) || !data->rigol_quirk) {\r\nif (actual < USBTMC_HEADER_SIZE) {\r\ndev_err(dev, "Device sent too small first packet: %u < %u\n", actual, USBTMC_HEADER_SIZE);\r\nif (data->auto_abort)\r\nusbtmc_ioctl_abort_bulk_in(data);\r\ngoto exit;\r\n}\r\nif (buffer[0] != 2) {\r\ndev_err(dev, "Device sent reply with wrong MsgID: %u != 2\n", buffer[0]);\r\nif (data->auto_abort)\r\nusbtmc_ioctl_abort_bulk_in(data);\r\ngoto exit;\r\n}\r\nif (buffer[1] != data->bTag_last_write) {\r\ndev_err(dev, "Device sent reply with wrong bTag: %u != %u\n", buffer[1], data->bTag_last_write);\r\nif (data->auto_abort)\r\nusbtmc_ioctl_abort_bulk_in(data);\r\ngoto exit;\r\n}\r\nn_characters = buffer[4] +\r\n(buffer[5] << 8) +\r\n(buffer[6] << 16) +\r\n(buffer[7] << 24);\r\nif (n_characters > this_part) {\r\ndev_err(dev, "Device wants to return more data than requested: %u > %zu\n", n_characters, count);\r\nif (data->auto_abort)\r\nusbtmc_ioctl_abort_bulk_in(data);\r\ngoto exit;\r\n}\r\nactual -= USBTMC_HEADER_SIZE;\r\nif (data->rigol_quirk) {\r\nif (remaining > n_characters)\r\nremaining = n_characters;\r\nif (actual > remaining)\r\nactual = remaining;\r\n}\r\nelse {\r\nif (this_part > n_characters)\r\nthis_part = n_characters;\r\nif (actual > this_part)\r\nactual = this_part;\r\n}\r\ndev_dbg(dev, "Bulk-IN header: N_characters(%u), bTransAttr(%u)\n", n_characters, buffer[8]);\r\nremaining -= actual;\r\nif ((buffer[8] & 0x01) && (actual >= n_characters))\r\nremaining = 0;\r\ndev_dbg(dev, "Bulk-IN header: remaining(%zu), buf(%p), buffer(%p) done(%zu)\n", remaining,buf,buffer,done);\r\nif (copy_to_user(buf + done, &buffer[USBTMC_HEADER_SIZE], actual)) {\r\nretval = -EFAULT;\r\ngoto exit;\r\n}\r\ndone += actual;\r\n}\r\nelse {\r\nif (actual > remaining)\r\nactual = remaining;\r\nremaining -= actual;\r\ndev_dbg(dev, "Bulk-IN header cont: actual(%u), done(%zu), remaining(%zu), buf(%p), buffer(%p)\n", actual, done, remaining,buf,buffer);\r\nif (copy_to_user(buf + done, buffer, actual)) {\r\nretval = -EFAULT;\r\ngoto exit;\r\n}\r\ndone += actual;\r\n}\r\n}\r\n*f_pos = *f_pos + done;\r\nretval = done;\r\nexit:\r\nmutex_unlock(&data->io_mutex);\r\nkfree(buffer);\r\nreturn retval;\r\n}\r\nstatic ssize_t usbtmc_write(struct file *filp, const char __user *buf,\r\nsize_t count, loff_t *f_pos)\r\n{\r\nstruct usbtmc_device_data *data;\r\nu8 *buffer;\r\nint retval;\r\nint actual;\r\nunsigned long int n_bytes;\r\nint remaining;\r\nint done;\r\nint this_part;\r\ndata = filp->private_data;\r\nbuffer = kmalloc(USBTMC_SIZE_IOBUFFER, GFP_KERNEL);\r\nif (!buffer)\r\nreturn -ENOMEM;\r\nmutex_lock(&data->io_mutex);\r\nif (data->zombie) {\r\nretval = -ENODEV;\r\ngoto exit;\r\n}\r\nremaining = count;\r\ndone = 0;\r\nwhile (remaining > 0) {\r\nif (remaining > USBTMC_SIZE_IOBUFFER - USBTMC_HEADER_SIZE) {\r\nthis_part = USBTMC_SIZE_IOBUFFER - USBTMC_HEADER_SIZE;\r\nbuffer[8] = 0;\r\n} else {\r\nthis_part = remaining;\r\nbuffer[8] = 1;\r\n}\r\nbuffer[0] = 1;\r\nbuffer[1] = data->bTag;\r\nbuffer[2] = ~data->bTag;\r\nbuffer[3] = 0;\r\nbuffer[4] = this_part >> 0;\r\nbuffer[5] = this_part >> 8;\r\nbuffer[6] = this_part >> 16;\r\nbuffer[7] = this_part >> 24;\r\nbuffer[9] = 0;\r\nbuffer[10] = 0;\r\nbuffer[11] = 0;\r\nif (copy_from_user(&buffer[USBTMC_HEADER_SIZE], buf + done, this_part)) {\r\nretval = -EFAULT;\r\ngoto exit;\r\n}\r\nn_bytes = roundup(USBTMC_HEADER_SIZE + this_part, 4);\r\nmemset(buffer + USBTMC_HEADER_SIZE + this_part, 0, n_bytes - (USBTMC_HEADER_SIZE + this_part));\r\ndo {\r\nretval = usb_bulk_msg(data->usb_dev,\r\nusb_sndbulkpipe(data->usb_dev,\r\ndata->bulk_out),\r\nbuffer, n_bytes,\r\n&actual, USBTMC_TIMEOUT);\r\nif (retval != 0)\r\nbreak;\r\nn_bytes -= actual;\r\n} while (n_bytes);\r\ndata->bTag_last_write = data->bTag;\r\ndata->bTag++;\r\nif (!data->bTag)\r\ndata->bTag++;\r\nif (retval < 0) {\r\ndev_err(&data->intf->dev,\r\n"Unable to send data, error %d\n", retval);\r\nif (data->auto_abort)\r\nusbtmc_ioctl_abort_bulk_out(data);\r\ngoto exit;\r\n}\r\nremaining -= this_part;\r\ndone += this_part;\r\n}\r\nretval = count;\r\nexit:\r\nmutex_unlock(&data->io_mutex);\r\nkfree(buffer);\r\nreturn retval;\r\n}\r\nstatic int usbtmc_ioctl_clear(struct usbtmc_device_data *data)\r\n{\r\nstruct usb_host_interface *current_setting;\r\nstruct usb_endpoint_descriptor *desc;\r\nstruct device *dev;\r\nu8 *buffer;\r\nint rv;\r\nint n;\r\nint actual = 0;\r\nint max_size;\r\ndev = &data->intf->dev;\r\ndev_dbg(dev, "Sending INITIATE_CLEAR request\n");\r\nbuffer = kmalloc(USBTMC_SIZE_IOBUFFER, GFP_KERNEL);\r\nif (!buffer)\r\nreturn -ENOMEM;\r\nrv = usb_control_msg(data->usb_dev,\r\nusb_rcvctrlpipe(data->usb_dev, 0),\r\nUSBTMC_REQUEST_INITIATE_CLEAR,\r\nUSB_DIR_IN | USB_TYPE_CLASS | USB_RECIP_INTERFACE,\r\n0, 0, buffer, 1, USBTMC_TIMEOUT);\r\nif (rv < 0) {\r\ndev_err(dev, "usb_control_msg returned %d\n", rv);\r\ngoto exit;\r\n}\r\ndev_dbg(dev, "INITIATE_CLEAR returned %x\n", buffer[0]);\r\nif (buffer[0] != USBTMC_STATUS_SUCCESS) {\r\ndev_err(dev, "INITIATE_CLEAR returned %x\n", buffer[0]);\r\nrv = -EPERM;\r\ngoto exit;\r\n}\r\nmax_size = 0;\r\ncurrent_setting = data->intf->cur_altsetting;\r\nfor (n = 0; n < current_setting->desc.bNumEndpoints; n++) {\r\ndesc = &current_setting->endpoint[n].desc;\r\nif (desc->bEndpointAddress == data->bulk_in)\r\nmax_size = usb_endpoint_maxp(desc);\r\n}\r\nif (max_size == 0) {\r\ndev_err(dev, "Couldn't get wMaxPacketSize\n");\r\nrv = -EPERM;\r\ngoto exit;\r\n}\r\ndev_dbg(dev, "wMaxPacketSize is %d\n", max_size);\r\nn = 0;\r\nusbtmc_clear_check_status:\r\ndev_dbg(dev, "Sending CHECK_CLEAR_STATUS request\n");\r\nrv = usb_control_msg(data->usb_dev,\r\nusb_rcvctrlpipe(data->usb_dev, 0),\r\nUSBTMC_REQUEST_CHECK_CLEAR_STATUS,\r\nUSB_DIR_IN | USB_TYPE_CLASS | USB_RECIP_INTERFACE,\r\n0, 0, buffer, 2, USBTMC_TIMEOUT);\r\nif (rv < 0) {\r\ndev_err(dev, "usb_control_msg returned %d\n", rv);\r\ngoto exit;\r\n}\r\ndev_dbg(dev, "CHECK_CLEAR_STATUS returned %x\n", buffer[0]);\r\nif (buffer[0] == USBTMC_STATUS_SUCCESS)\r\ngoto usbtmc_clear_bulk_out_halt;\r\nif (buffer[0] != USBTMC_STATUS_PENDING) {\r\ndev_err(dev, "CHECK_CLEAR_STATUS returned %x\n", buffer[0]);\r\nrv = -EPERM;\r\ngoto exit;\r\n}\r\nif (buffer[1] == 1)\r\ndo {\r\ndev_dbg(dev, "Reading from bulk in EP\n");\r\nrv = usb_bulk_msg(data->usb_dev,\r\nusb_rcvbulkpipe(data->usb_dev,\r\ndata->bulk_in),\r\nbuffer, USBTMC_SIZE_IOBUFFER,\r\n&actual, USBTMC_TIMEOUT);\r\nn++;\r\nif (rv < 0) {\r\ndev_err(dev, "usb_control_msg returned %d\n",\r\nrv);\r\ngoto exit;\r\n}\r\n} while ((actual == max_size) &&\r\n(n < USBTMC_MAX_READS_TO_CLEAR_BULK_IN));\r\nif (actual == max_size) {\r\ndev_err(dev, "Couldn't clear device buffer within %d cycles\n",\r\nUSBTMC_MAX_READS_TO_CLEAR_BULK_IN);\r\nrv = -EPERM;\r\ngoto exit;\r\n}\r\ngoto usbtmc_clear_check_status;\r\nusbtmc_clear_bulk_out_halt:\r\nrv = usb_clear_halt(data->usb_dev,\r\nusb_sndbulkpipe(data->usb_dev, data->bulk_out));\r\nif (rv < 0) {\r\ndev_err(dev, "usb_control_msg returned %d\n", rv);\r\ngoto exit;\r\n}\r\nrv = 0;\r\nexit:\r\nkfree(buffer);\r\nreturn rv;\r\n}\r\nstatic int usbtmc_ioctl_clear_out_halt(struct usbtmc_device_data *data)\r\n{\r\nint rv;\r\nrv = usb_clear_halt(data->usb_dev,\r\nusb_sndbulkpipe(data->usb_dev, data->bulk_out));\r\nif (rv < 0) {\r\ndev_err(&data->usb_dev->dev, "usb_control_msg returned %d\n",\r\nrv);\r\nreturn rv;\r\n}\r\nreturn 0;\r\n}\r\nstatic int usbtmc_ioctl_clear_in_halt(struct usbtmc_device_data *data)\r\n{\r\nint rv;\r\nrv = usb_clear_halt(data->usb_dev,\r\nusb_rcvbulkpipe(data->usb_dev, data->bulk_in));\r\nif (rv < 0) {\r\ndev_err(&data->usb_dev->dev, "usb_control_msg returned %d\n",\r\nrv);\r\nreturn rv;\r\n}\r\nreturn 0;\r\n}\r\nstatic int get_capabilities(struct usbtmc_device_data *data)\r\n{\r\nstruct device *dev = &data->usb_dev->dev;\r\nchar *buffer;\r\nint rv = 0;\r\nbuffer = kmalloc(0x18, GFP_KERNEL);\r\nif (!buffer)\r\nreturn -ENOMEM;\r\nrv = usb_control_msg(data->usb_dev, usb_rcvctrlpipe(data->usb_dev, 0),\r\nUSBTMC_REQUEST_GET_CAPABILITIES,\r\nUSB_DIR_IN | USB_TYPE_CLASS | USB_RECIP_INTERFACE,\r\n0, 0, buffer, 0x18, USBTMC_TIMEOUT);\r\nif (rv < 0) {\r\ndev_err(dev, "usb_control_msg returned %d\n", rv);\r\ngoto err_out;\r\n}\r\ndev_dbg(dev, "GET_CAPABILITIES returned %x\n", buffer[0]);\r\nif (buffer[0] != USBTMC_STATUS_SUCCESS) {\r\ndev_err(dev, "GET_CAPABILITIES returned %x\n", buffer[0]);\r\nrv = -EPERM;\r\ngoto err_out;\r\n}\r\ndev_dbg(dev, "Interface capabilities are %x\n", buffer[4]);\r\ndev_dbg(dev, "Device capabilities are %x\n", buffer[5]);\r\ndev_dbg(dev, "USB488 interface capabilities are %x\n", buffer[14]);\r\ndev_dbg(dev, "USB488 device capabilities are %x\n", buffer[15]);\r\ndata->capabilities.interface_capabilities = buffer[4];\r\ndata->capabilities.device_capabilities = buffer[5];\r\ndata->capabilities.usb488_interface_capabilities = buffer[14];\r\ndata->capabilities.usb488_device_capabilities = buffer[15];\r\nrv = 0;\r\nerr_out:\r\nkfree(buffer);\r\nreturn rv;\r\n}\r\nstatic ssize_t TermChar_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct usb_interface *intf = to_usb_interface(dev);\r\nstruct usbtmc_device_data *data = usb_get_intfdata(intf);\r\nreturn sprintf(buf, "%c\n", data->TermChar);\r\n}\r\nstatic ssize_t TermChar_store(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct usb_interface *intf = to_usb_interface(dev);\r\nstruct usbtmc_device_data *data = usb_get_intfdata(intf);\r\nif (count < 1)\r\nreturn -EINVAL;\r\ndata->TermChar = buf[0];\r\nreturn count;\r\n}\r\nstatic int usbtmc_ioctl_indicator_pulse(struct usbtmc_device_data *data)\r\n{\r\nstruct device *dev;\r\nu8 *buffer;\r\nint rv;\r\ndev = &data->intf->dev;\r\nbuffer = kmalloc(2, GFP_KERNEL);\r\nif (!buffer)\r\nreturn -ENOMEM;\r\nrv = usb_control_msg(data->usb_dev,\r\nusb_rcvctrlpipe(data->usb_dev, 0),\r\nUSBTMC_REQUEST_INDICATOR_PULSE,\r\nUSB_DIR_IN | USB_TYPE_CLASS | USB_RECIP_INTERFACE,\r\n0, 0, buffer, 0x01, USBTMC_TIMEOUT);\r\nif (rv < 0) {\r\ndev_err(dev, "usb_control_msg returned %d\n", rv);\r\ngoto exit;\r\n}\r\ndev_dbg(dev, "INDICATOR_PULSE returned %x\n", buffer[0]);\r\nif (buffer[0] != USBTMC_STATUS_SUCCESS) {\r\ndev_err(dev, "INDICATOR_PULSE returned %x\n", buffer[0]);\r\nrv = -EPERM;\r\ngoto exit;\r\n}\r\nrv = 0;\r\nexit:\r\nkfree(buffer);\r\nreturn rv;\r\n}\r\nstatic long usbtmc_ioctl(struct file *file, unsigned int cmd, unsigned long arg)\r\n{\r\nstruct usbtmc_device_data *data;\r\nint retval = -EBADRQC;\r\ndata = file->private_data;\r\nmutex_lock(&data->io_mutex);\r\nif (data->zombie) {\r\nretval = -ENODEV;\r\ngoto skip_io_on_zombie;\r\n}\r\nswitch (cmd) {\r\ncase USBTMC_IOCTL_CLEAR_OUT_HALT:\r\nretval = usbtmc_ioctl_clear_out_halt(data);\r\nbreak;\r\ncase USBTMC_IOCTL_CLEAR_IN_HALT:\r\nretval = usbtmc_ioctl_clear_in_halt(data);\r\nbreak;\r\ncase USBTMC_IOCTL_INDICATOR_PULSE:\r\nretval = usbtmc_ioctl_indicator_pulse(data);\r\nbreak;\r\ncase USBTMC_IOCTL_CLEAR:\r\nretval = usbtmc_ioctl_clear(data);\r\nbreak;\r\ncase USBTMC_IOCTL_ABORT_BULK_OUT:\r\nretval = usbtmc_ioctl_abort_bulk_out(data);\r\nbreak;\r\ncase USBTMC_IOCTL_ABORT_BULK_IN:\r\nretval = usbtmc_ioctl_abort_bulk_in(data);\r\nbreak;\r\n}\r\nskip_io_on_zombie:\r\nmutex_unlock(&data->io_mutex);\r\nreturn retval;\r\n}\r\nstatic int usbtmc_probe(struct usb_interface *intf,\r\nconst struct usb_device_id *id)\r\n{\r\nstruct usbtmc_device_data *data;\r\nstruct usb_host_interface *iface_desc;\r\nstruct usb_endpoint_descriptor *endpoint;\r\nint n;\r\nint retcode;\r\ndev_dbg(&intf->dev, "%s called\n", __func__);\r\ndata = devm_kzalloc(&intf->dev, sizeof(*data), GFP_KERNEL);\r\nif (!data)\r\nreturn -ENOMEM;\r\ndata->intf = intf;\r\ndata->id = id;\r\ndata->usb_dev = usb_get_dev(interface_to_usbdev(intf));\r\nusb_set_intfdata(intf, data);\r\nkref_init(&data->kref);\r\nmutex_init(&data->io_mutex);\r\ndata->zombie = 0;\r\ndata->rigol_quirk = 0;\r\ndev_dbg(&intf->dev, "Trying to find if device Vendor 0x%04X Product 0x%04X has the RIGOL quirk\n",\r\nle16_to_cpu(data->usb_dev->descriptor.idVendor),\r\nle16_to_cpu(data->usb_dev->descriptor.idProduct));\r\nfor(n = 0; usbtmc_id_quirk[n].idVendor > 0; n++) {\r\nif ((usbtmc_id_quirk[n].idVendor == le16_to_cpu(data->usb_dev->descriptor.idVendor)) &&\r\n(usbtmc_id_quirk[n].idProduct == le16_to_cpu(data->usb_dev->descriptor.idProduct))) {\r\ndev_dbg(&intf->dev, "Setting this device as having the RIGOL quirk\n");\r\ndata->rigol_quirk = 1;\r\nbreak;\r\n}\r\n}\r\ndata->bTag = 1;\r\ndata->TermCharEnabled = 0;\r\ndata->TermChar = '\n';\r\niface_desc = data->intf->cur_altsetting;\r\nfor (n = 0; n < iface_desc->desc.bNumEndpoints; n++) {\r\nendpoint = &iface_desc->endpoint[n].desc;\r\nif (usb_endpoint_is_bulk_in(endpoint)) {\r\ndata->bulk_in = endpoint->bEndpointAddress;\r\ndev_dbg(&intf->dev, "Found bulk in endpoint at %u\n",\r\ndata->bulk_in);\r\nbreak;\r\n}\r\n}\r\nfor (n = 0; n < iface_desc->desc.bNumEndpoints; n++) {\r\nendpoint = &iface_desc->endpoint[n].desc;\r\nif (usb_endpoint_is_bulk_out(endpoint)) {\r\ndata->bulk_out = endpoint->bEndpointAddress;\r\ndev_dbg(&intf->dev, "Found Bulk out endpoint at %u\n",\r\ndata->bulk_out);\r\nbreak;\r\n}\r\n}\r\nretcode = get_capabilities(data);\r\nif (retcode)\r\ndev_err(&intf->dev, "can't read capabilities\n");\r\nelse\r\nretcode = sysfs_create_group(&intf->dev.kobj,\r\n&capability_attr_grp);\r\nretcode = sysfs_create_group(&intf->dev.kobj, &data_attr_grp);\r\nretcode = usb_register_dev(intf, &usbtmc_class);\r\nif (retcode) {\r\ndev_err(&intf->dev, "Not able to get a minor"\r\n" (base %u, slice default): %d\n", USBTMC_MINOR_BASE,\r\nretcode);\r\ngoto error_register;\r\n}\r\ndev_dbg(&intf->dev, "Using minor number %d\n", intf->minor);\r\nreturn 0;\r\nerror_register:\r\nsysfs_remove_group(&intf->dev.kobj, &capability_attr_grp);\r\nsysfs_remove_group(&intf->dev.kobj, &data_attr_grp);\r\nkref_put(&data->kref, usbtmc_delete);\r\nreturn retcode;\r\n}\r\nstatic void usbtmc_disconnect(struct usb_interface *intf)\r\n{\r\nstruct usbtmc_device_data *data;\r\ndev_dbg(&intf->dev, "usbtmc_disconnect called\n");\r\ndata = usb_get_intfdata(intf);\r\nusb_deregister_dev(intf, &usbtmc_class);\r\nsysfs_remove_group(&intf->dev.kobj, &capability_attr_grp);\r\nsysfs_remove_group(&intf->dev.kobj, &data_attr_grp);\r\nmutex_lock(&data->io_mutex);\r\ndata->zombie = 1;\r\nmutex_unlock(&data->io_mutex);\r\nkref_put(&data->kref, usbtmc_delete);\r\n}\r\nstatic int usbtmc_suspend(struct usb_interface *intf, pm_message_t message)\r\n{\r\nreturn 0;\r\n}\r\nstatic int usbtmc_resume(struct usb_interface *intf)\r\n{\r\nreturn 0;\r\n}
