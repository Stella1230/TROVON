static inline struct s3c24xx_spi *to_hw(struct spi_device *sdev)\r\n{\r\nreturn spi_master_get_devdata(sdev->master);\r\n}\r\nstatic void s3c24xx_spi_gpiocs(struct s3c2410_spi_info *spi, int cs, int pol)\r\n{\r\ngpio_set_value(spi->pin_cs, pol);\r\n}\r\nstatic void s3c24xx_spi_chipsel(struct spi_device *spi, int value)\r\n{\r\nstruct s3c24xx_spi_devstate *cs = spi->controller_state;\r\nstruct s3c24xx_spi *hw = to_hw(spi);\r\nunsigned int cspol = spi->mode & SPI_CS_HIGH ? 1 : 0;\r\nswitch (value) {\r\ncase BITBANG_CS_INACTIVE:\r\nhw->set_cs(hw->pdata, spi->chip_select, cspol^1);\r\nwriteb(cs->spcon, hw->regs + S3C2410_SPCON);\r\nbreak;\r\ncase BITBANG_CS_ACTIVE:\r\nwriteb(cs->spcon | S3C2410_SPCON_ENSCK,\r\nhw->regs + S3C2410_SPCON);\r\nhw->set_cs(hw->pdata, spi->chip_select, cspol);\r\nbreak;\r\n}\r\n}\r\nstatic int s3c24xx_spi_update_state(struct spi_device *spi,\r\nstruct spi_transfer *t)\r\n{\r\nstruct s3c24xx_spi *hw = to_hw(spi);\r\nstruct s3c24xx_spi_devstate *cs = spi->controller_state;\r\nunsigned int hz;\r\nunsigned int div;\r\nunsigned long clk;\r\nhz = t ? t->speed_hz : spi->max_speed_hz;\r\nif (!hz)\r\nhz = spi->max_speed_hz;\r\nif (spi->mode != cs->mode) {\r\nu8 spcon = SPCON_DEFAULT | S3C2410_SPCON_ENSCK;\r\nif (spi->mode & SPI_CPHA)\r\nspcon |= S3C2410_SPCON_CPHA_FMTB;\r\nif (spi->mode & SPI_CPOL)\r\nspcon |= S3C2410_SPCON_CPOL_HIGH;\r\ncs->mode = spi->mode;\r\ncs->spcon = spcon;\r\n}\r\nif (cs->hz != hz) {\r\nclk = clk_get_rate(hw->clk);\r\ndiv = DIV_ROUND_UP(clk, hz * 2) - 1;\r\nif (div > 255)\r\ndiv = 255;\r\ndev_dbg(&spi->dev, "pre-scaler=%d (wanted %d, got %ld)\n",\r\ndiv, hz, clk / (2 * (div + 1)));\r\ncs->hz = hz;\r\ncs->sppre = div;\r\n}\r\nreturn 0;\r\n}\r\nstatic int s3c24xx_spi_setupxfer(struct spi_device *spi,\r\nstruct spi_transfer *t)\r\n{\r\nstruct s3c24xx_spi_devstate *cs = spi->controller_state;\r\nstruct s3c24xx_spi *hw = to_hw(spi);\r\nint ret;\r\nret = s3c24xx_spi_update_state(spi, t);\r\nif (!ret)\r\nwriteb(cs->sppre, hw->regs + S3C2410_SPPRE);\r\nreturn ret;\r\n}\r\nstatic int s3c24xx_spi_setup(struct spi_device *spi)\r\n{\r\nstruct s3c24xx_spi_devstate *cs = spi->controller_state;\r\nstruct s3c24xx_spi *hw = to_hw(spi);\r\nint ret;\r\nif (!cs) {\r\ncs = devm_kzalloc(&spi->dev,\r\nsizeof(struct s3c24xx_spi_devstate),\r\nGFP_KERNEL);\r\nif (!cs)\r\nreturn -ENOMEM;\r\ncs->spcon = SPCON_DEFAULT;\r\ncs->hz = -1;\r\nspi->controller_state = cs;\r\n}\r\nret = s3c24xx_spi_update_state(spi, NULL);\r\nif (ret)\r\nreturn ret;\r\nmutex_lock(&hw->bitbang.lock);\r\nif (!hw->bitbang.busy) {\r\nhw->bitbang.chipselect(spi, BITBANG_CS_INACTIVE);\r\n}\r\nmutex_unlock(&hw->bitbang.lock);\r\nreturn 0;\r\n}\r\nstatic inline unsigned int hw_txbyte(struct s3c24xx_spi *hw, int count)\r\n{\r\nreturn hw->tx ? hw->tx[count] : 0;\r\n}\r\nstatic inline u32 ack_bit(unsigned int irq)\r\n{\r\nreturn 1 << (irq - IRQ_EINT0);\r\n}\r\nstatic void s3c24xx_spi_tryfiq(struct s3c24xx_spi *hw)\r\n{\r\nstruct pt_regs regs;\r\nenum spi_fiq_mode mode;\r\nstruct spi_fiq_code *code;\r\nint ret;\r\nif (!hw->fiq_claimed) {\r\nret = claim_fiq(&hw->fiq_handler);\r\nif (ret)\r\nreturn;\r\n}\r\nif (hw->tx && !hw->rx)\r\nmode = FIQ_MODE_TX;\r\nelse if (hw->rx && !hw->tx)\r\nmode = FIQ_MODE_RX;\r\nelse\r\nmode = FIQ_MODE_TXRX;\r\nregs.uregs[fiq_rspi] = (long)hw->regs;\r\nregs.uregs[fiq_rrx] = (long)hw->rx;\r\nregs.uregs[fiq_rtx] = (long)hw->tx + 1;\r\nregs.uregs[fiq_rcount] = hw->len - 1;\r\nregs.uregs[fiq_rirq] = (long)S3C24XX_VA_IRQ;\r\nset_fiq_regs(&regs);\r\nif (hw->fiq_mode != mode) {\r\nu32 *ack_ptr;\r\nhw->fiq_mode = mode;\r\nswitch (mode) {\r\ncase FIQ_MODE_TX:\r\ncode = &s3c24xx_spi_fiq_tx;\r\nbreak;\r\ncase FIQ_MODE_RX:\r\ncode = &s3c24xx_spi_fiq_rx;\r\nbreak;\r\ncase FIQ_MODE_TXRX:\r\ncode = &s3c24xx_spi_fiq_txrx;\r\nbreak;\r\ndefault:\r\ncode = NULL;\r\n}\r\nBUG_ON(!code);\r\nack_ptr = (u32 *)&code->data[code->ack_offset];\r\n*ack_ptr = ack_bit(hw->irq);\r\nset_fiq_handler(&code->data, code->length);\r\n}\r\ns3c24xx_set_fiq(hw->irq, true);\r\nhw->fiq_mode = mode;\r\nhw->fiq_inuse = 1;\r\n}\r\nstatic int s3c24xx_spi_fiqop(void *pw, int release)\r\n{\r\nstruct s3c24xx_spi *hw = pw;\r\nint ret = 0;\r\nif (release) {\r\nif (hw->fiq_inuse)\r\nret = -EBUSY;\r\nhw->fiq_mode = FIQ_MODE_NONE;\r\nhw->fiq_claimed = 0;\r\n} else {\r\nhw->fiq_claimed = 1;\r\n}\r\nreturn ret;\r\n}\r\nstatic inline void s3c24xx_spi_initfiq(struct s3c24xx_spi *hw)\r\n{\r\nhw->fiq_handler.dev_id = hw;\r\nhw->fiq_handler.name = dev_name(hw->dev);\r\nhw->fiq_handler.fiq_op = s3c24xx_spi_fiqop;\r\n}\r\nstatic inline bool s3c24xx_spi_usefiq(struct s3c24xx_spi *hw)\r\n{\r\nreturn hw->pdata->use_fiq;\r\n}\r\nstatic inline bool s3c24xx_spi_usingfiq(struct s3c24xx_spi *spi)\r\n{\r\nreturn spi->fiq_inuse;\r\n}\r\nstatic inline void s3c24xx_spi_initfiq(struct s3c24xx_spi *s) { }\r\nstatic inline void s3c24xx_spi_tryfiq(struct s3c24xx_spi *s) { }\r\nstatic inline bool s3c24xx_spi_usefiq(struct s3c24xx_spi *s) { return false; }\r\nstatic inline bool s3c24xx_spi_usingfiq(struct s3c24xx_spi *s) { return false; }\r\nstatic int s3c24xx_spi_txrx(struct spi_device *spi, struct spi_transfer *t)\r\n{\r\nstruct s3c24xx_spi *hw = to_hw(spi);\r\nhw->tx = t->tx_buf;\r\nhw->rx = t->rx_buf;\r\nhw->len = t->len;\r\nhw->count = 0;\r\ninit_completion(&hw->done);\r\nhw->fiq_inuse = 0;\r\nif (s3c24xx_spi_usefiq(hw) && t->len >= 3)\r\ns3c24xx_spi_tryfiq(hw);\r\nwriteb(hw_txbyte(hw, 0), hw->regs + S3C2410_SPTDAT);\r\nwait_for_completion(&hw->done);\r\nreturn hw->count;\r\n}\r\nstatic irqreturn_t s3c24xx_spi_irq(int irq, void *dev)\r\n{\r\nstruct s3c24xx_spi *hw = dev;\r\nunsigned int spsta = readb(hw->regs + S3C2410_SPSTA);\r\nunsigned int count = hw->count;\r\nif (spsta & S3C2410_SPSTA_DCOL) {\r\ndev_dbg(hw->dev, "data-collision\n");\r\ncomplete(&hw->done);\r\ngoto irq_done;\r\n}\r\nif (!(spsta & S3C2410_SPSTA_READY)) {\r\ndev_dbg(hw->dev, "spi not ready for tx?\n");\r\ncomplete(&hw->done);\r\ngoto irq_done;\r\n}\r\nif (!s3c24xx_spi_usingfiq(hw)) {\r\nhw->count++;\r\nif (hw->rx)\r\nhw->rx[count] = readb(hw->regs + S3C2410_SPRDAT);\r\ncount++;\r\nif (count < hw->len)\r\nwriteb(hw_txbyte(hw, count), hw->regs + S3C2410_SPTDAT);\r\nelse\r\ncomplete(&hw->done);\r\n} else {\r\nhw->count = hw->len;\r\nhw->fiq_inuse = 0;\r\nif (hw->rx)\r\nhw->rx[hw->len-1] = readb(hw->regs + S3C2410_SPRDAT);\r\ncomplete(&hw->done);\r\n}\r\nirq_done:\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void s3c24xx_spi_initialsetup(struct s3c24xx_spi *hw)\r\n{\r\nclk_enable(hw->clk);\r\nwriteb(0xff, hw->regs + S3C2410_SPPRE);\r\nwriteb(SPPIN_DEFAULT, hw->regs + S3C2410_SPPIN);\r\nwriteb(SPCON_DEFAULT, hw->regs + S3C2410_SPCON);\r\nif (hw->pdata) {\r\nif (hw->set_cs == s3c24xx_spi_gpiocs)\r\ngpio_direction_output(hw->pdata->pin_cs, 1);\r\nif (hw->pdata->gpio_setup)\r\nhw->pdata->gpio_setup(hw->pdata, 1);\r\n}\r\n}\r\nstatic int s3c24xx_spi_probe(struct platform_device *pdev)\r\n{\r\nstruct s3c2410_spi_info *pdata;\r\nstruct s3c24xx_spi *hw;\r\nstruct spi_master *master;\r\nstruct resource *res;\r\nint err = 0;\r\nmaster = spi_alloc_master(&pdev->dev, sizeof(struct s3c24xx_spi));\r\nif (master == NULL) {\r\ndev_err(&pdev->dev, "No memory for spi_master\n");\r\nreturn -ENOMEM;\r\n}\r\nhw = spi_master_get_devdata(master);\r\nhw->master = master;\r\nhw->pdata = pdata = dev_get_platdata(&pdev->dev);\r\nhw->dev = &pdev->dev;\r\nif (pdata == NULL) {\r\ndev_err(&pdev->dev, "No platform data supplied\n");\r\nerr = -ENOENT;\r\ngoto err_no_pdata;\r\n}\r\nplatform_set_drvdata(pdev, hw);\r\ninit_completion(&hw->done);\r\ns3c24xx_spi_initfiq(hw);\r\nmaster->mode_bits = SPI_CPOL | SPI_CPHA | SPI_CS_HIGH;\r\nmaster->num_chipselect = hw->pdata->num_cs;\r\nmaster->bus_num = pdata->bus_num;\r\nmaster->bits_per_word_mask = SPI_BPW_MASK(8);\r\nhw->bitbang.master = hw->master;\r\nhw->bitbang.setup_transfer = s3c24xx_spi_setupxfer;\r\nhw->bitbang.chipselect = s3c24xx_spi_chipsel;\r\nhw->bitbang.txrx_bufs = s3c24xx_spi_txrx;\r\nhw->master->setup = s3c24xx_spi_setup;\r\ndev_dbg(hw->dev, "bitbang at %p\n", &hw->bitbang);\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nhw->regs = devm_ioremap_resource(&pdev->dev, res);\r\nif (IS_ERR(hw->regs)) {\r\nerr = PTR_ERR(hw->regs);\r\ngoto err_no_pdata;\r\n}\r\nhw->irq = platform_get_irq(pdev, 0);\r\nif (hw->irq < 0) {\r\ndev_err(&pdev->dev, "No IRQ specified\n");\r\nerr = -ENOENT;\r\ngoto err_no_pdata;\r\n}\r\nerr = devm_request_irq(&pdev->dev, hw->irq, s3c24xx_spi_irq, 0,\r\npdev->name, hw);\r\nif (err) {\r\ndev_err(&pdev->dev, "Cannot claim IRQ\n");\r\ngoto err_no_pdata;\r\n}\r\nhw->clk = devm_clk_get(&pdev->dev, "spi");\r\nif (IS_ERR(hw->clk)) {\r\ndev_err(&pdev->dev, "No clock for device\n");\r\nerr = PTR_ERR(hw->clk);\r\ngoto err_no_pdata;\r\n}\r\nif (!pdata->set_cs) {\r\nif (pdata->pin_cs < 0) {\r\ndev_err(&pdev->dev, "No chipselect pin\n");\r\nerr = -EINVAL;\r\ngoto err_register;\r\n}\r\nerr = devm_gpio_request(&pdev->dev, pdata->pin_cs,\r\ndev_name(&pdev->dev));\r\nif (err) {\r\ndev_err(&pdev->dev, "Failed to get gpio for cs\n");\r\ngoto err_register;\r\n}\r\nhw->set_cs = s3c24xx_spi_gpiocs;\r\ngpio_direction_output(pdata->pin_cs, 1);\r\n} else\r\nhw->set_cs = pdata->set_cs;\r\ns3c24xx_spi_initialsetup(hw);\r\nerr = spi_bitbang_start(&hw->bitbang);\r\nif (err) {\r\ndev_err(&pdev->dev, "Failed to register SPI master\n");\r\ngoto err_register;\r\n}\r\nreturn 0;\r\nerr_register:\r\nclk_disable(hw->clk);\r\nerr_no_pdata:\r\nspi_master_put(hw->master);\r\nreturn err;\r\n}\r\nstatic int s3c24xx_spi_remove(struct platform_device *dev)\r\n{\r\nstruct s3c24xx_spi *hw = platform_get_drvdata(dev);\r\nspi_bitbang_stop(&hw->bitbang);\r\nclk_disable(hw->clk);\r\nspi_master_put(hw->master);\r\nreturn 0;\r\n}\r\nstatic int s3c24xx_spi_suspend(struct device *dev)\r\n{\r\nstruct s3c24xx_spi *hw = dev_get_drvdata(dev);\r\nint ret;\r\nret = spi_master_suspend(hw->master);\r\nif (ret)\r\nreturn ret;\r\nif (hw->pdata && hw->pdata->gpio_setup)\r\nhw->pdata->gpio_setup(hw->pdata, 0);\r\nclk_disable(hw->clk);\r\nreturn 0;\r\n}\r\nstatic int s3c24xx_spi_resume(struct device *dev)\r\n{\r\nstruct s3c24xx_spi *hw = dev_get_drvdata(dev);\r\ns3c24xx_spi_initialsetup(hw);\r\nreturn spi_master_resume(hw->master);\r\n}
